// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 39877 0 0
// InitNature ;
  19: CALL 39745 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12700 0 0
// PrepareRussian ;
  40: CALL 7630 0 0
// PrepareLegion ;
  44: CALL 4684 0 0
// PreparePowell ;
  48: CALL 3218 0 0
// PrepareAmerican ;
  52: CALL 1818 0 0
// Action ;
  56: CALL 17650 0 0
// MC_Start ( ) ;
  60: CALL 42057 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 126
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 127
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 65113 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 65210 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 64552 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 64367 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 65113 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 65210 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 64367 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 64552 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 64984 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 64030 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 65113 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 65210 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 131
 971: PUSH
 972: LD_EXP 131
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 64367 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 65113 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 65210 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 64259 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_gatling_gun ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 4
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 65540 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 64691 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 64984 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 64984 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 65330 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 64367 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 64933 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: IFFALSE 1558
1548: PUSH
1549: LD_EXP 17
1553: PUSH
1554: LD_INT 2
1556: GREATEREQUAL
1557: AND
1558: IFFALSE 1570
1560: GO 1562
1562: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1563: LD_STRING ACH_POWELL
1565: PPUSH
1566: CALL_OW 543
1570: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1571: LD_EXP 39
1575: PUSH
1576: LD_INT 30
1578: GREATEREQUAL
1579: IFFALSE 1591
1581: GO 1583
1583: DISABLE
// SetAchievement ( ACH_PROD ) ;
1584: LD_STRING ACH_PROD
1586: PPUSH
1587: CALL_OW 543
1591: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1592: LD_INT 22
1594: PUSH
1595: LD_INT 1
1597: PUSH
1598: EMPTY
1599: LIST
1600: LIST
1601: PUSH
1602: LD_INT 21
1604: PUSH
1605: LD_INT 1
1607: PUSH
1608: EMPTY
1609: LIST
1610: LIST
1611: PUSH
1612: LD_INT 2
1614: PUSH
1615: LD_INT 28
1617: PUSH
1618: LD_INT 1
1620: PUSH
1621: LD_INT 10
1623: PUSH
1624: EMPTY
1625: LIST
1626: LIST
1627: LIST
1628: PUSH
1629: LD_INT 28
1631: PUSH
1632: LD_INT 2
1634: PUSH
1635: LD_INT 10
1637: PUSH
1638: EMPTY
1639: LIST
1640: LIST
1641: LIST
1642: PUSH
1643: LD_INT 28
1645: PUSH
1646: LD_INT 3
1648: PUSH
1649: LD_INT 10
1651: PUSH
1652: EMPTY
1653: LIST
1654: LIST
1655: LIST
1656: PUSH
1657: LD_INT 28
1659: PUSH
1660: LD_INT 4
1662: PUSH
1663: LD_INT 10
1665: PUSH
1666: EMPTY
1667: LIST
1668: LIST
1669: LIST
1670: PUSH
1671: EMPTY
1672: LIST
1673: LIST
1674: LIST
1675: LIST
1676: LIST
1677: PUSH
1678: EMPTY
1679: LIST
1680: LIST
1681: LIST
1682: PPUSH
1683: CALL_OW 69
1687: PUSH
1688: LD_INT 10
1690: GREATEREQUAL
1691: IFFALSE 1703
1693: GO 1695
1695: DISABLE
// SetAchievement ( ACH_EXP ) ;
1696: LD_STRING ACH_EXP
1698: PPUSH
1699: CALL_OW 543
1703: END
// every 0 0$1 trigger debug do var i , tmp ;
1704: LD_EXP 1
1708: IFFALSE 1815
1710: GO 1712
1712: DISABLE
1713: LD_INT 0
1715: PPUSH
1716: PPUSH
// begin enable ;
1717: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1718: LD_ADDR_VAR 0 2
1722: PUSH
1723: LD_INT 22
1725: PUSH
1726: LD_INT 1
1728: PUSH
1729: EMPTY
1730: LIST
1731: LIST
1732: PUSH
1733: LD_INT 3
1735: PUSH
1736: LD_INT 21
1738: PUSH
1739: LD_INT 3
1741: PUSH
1742: EMPTY
1743: LIST
1744: LIST
1745: PUSH
1746: EMPTY
1747: LIST
1748: LIST
1749: PUSH
1750: LD_INT 3
1752: PUSH
1753: LD_INT 24
1755: PUSH
1756: LD_INT 999
1758: PUSH
1759: EMPTY
1760: LIST
1761: LIST
1762: PUSH
1763: EMPTY
1764: LIST
1765: LIST
1766: PUSH
1767: EMPTY
1768: LIST
1769: LIST
1770: LIST
1771: PPUSH
1772: CALL_OW 69
1776: ST_TO_ADDR
// if not tmp then
1777: LD_VAR 0 2
1781: NOT
1782: IFFALSE 1786
// exit ;
1784: GO 1815
// for i in tmp do
1786: LD_ADDR_VAR 0 1
1790: PUSH
1791: LD_VAR 0 2
1795: PUSH
1796: FOR_IN
1797: IFFALSE 1813
// SetLives ( i , 1000 ) ;
1799: LD_VAR 0 1
1803: PPUSH
1804: LD_INT 1000
1806: PPUSH
1807: CALL_OW 234
1811: GO 1796
1813: POP
1814: POP
// end ; end_of_file
1815: PPOPN 2
1817: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike , DeltaDoctor ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1818: LD_INT 0
1820: PPUSH
// uc_side := 1 ;
1821: LD_ADDR_OWVAR 20
1825: PUSH
1826: LD_INT 1
1828: ST_TO_ADDR
// uc_nation := 1 ;
1829: LD_ADDR_OWVAR 21
1833: PUSH
1834: LD_INT 1
1836: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1837: LD_ADDR_EXP 40
1841: PUSH
1842: LD_STRING JMM
1844: PPUSH
1845: LD_EXP 1
1849: NOT
1850: PPUSH
1851: LD_STRING 14_
1853: PPUSH
1854: CALL 70939 0 3
1858: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1859: LD_EXP 4
1863: NOT
1864: IFTRUE 1881
1866: PUSH
1867: LD_EXP 4
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: PUSH
1876: LD_INT 1
1878: ARRAY
1879: NOT
1880: OR
1881: IFFALSE 1946
// PrepareVehicle ( [ us_morphling , us_morphling , us_medium_tracked , us_medium_tracked ] [ Difficulty ] , engine_siberite , control_manual , [ us_laser , us_laser , us_double_gun , us_double_gun ] [ Difficulty ] , 100 ) else
1883: LD_INT 5
1885: PUSH
1886: LD_INT 5
1888: PUSH
1889: LD_INT 3
1891: PUSH
1892: LD_INT 3
1894: PUSH
1895: EMPTY
1896: LIST
1897: LIST
1898: LIST
1899: LIST
1900: PUSH
1901: LD_OWVAR 67
1905: ARRAY
1906: PPUSH
1907: LD_INT 3
1909: PPUSH
1910: LD_INT 1
1912: PPUSH
1913: LD_INT 9
1915: PUSH
1916: LD_INT 9
1918: PUSH
1919: LD_INT 5
1921: PUSH
1922: LD_INT 5
1924: PUSH
1925: EMPTY
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: PUSH
1931: LD_OWVAR 67
1935: ARRAY
1936: PPUSH
1937: LD_INT 100
1939: PPUSH
1940: CALL 75959 0 5
1944: GO 2005
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1946: LD_EXP 4
1950: PUSH
1951: LD_INT 1
1953: ARRAY
1954: PUSH
1955: LD_INT 1
1957: ARRAY
1958: PPUSH
1959: LD_EXP 4
1963: PUSH
1964: LD_INT 2
1966: ARRAY
1967: PUSH
1968: LD_INT 1
1970: ARRAY
1971: PPUSH
1972: LD_EXP 4
1976: PUSH
1977: LD_INT 3
1979: ARRAY
1980: PUSH
1981: LD_INT 1
1983: ARRAY
1984: PPUSH
1985: LD_EXP 4
1989: PUSH
1990: LD_INT 4
1992: ARRAY
1993: PUSH
1994: LD_INT 1
1996: ARRAY
1997: PPUSH
1998: LD_INT 30
2000: PPUSH
2001: CALL 75959 0 5
// JMMNewVeh := CreateVehicle ;
2005: LD_ADDR_EXP 59
2009: PUSH
2010: CALL_OW 45
2014: ST_TO_ADDR
// if not JMMNewVeh then
2015: LD_EXP 59
2019: NOT
2020: IFFALSE 2051
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
2022: LD_INT 5
2024: PPUSH
2025: LD_INT 3
2027: PPUSH
2028: LD_INT 1
2030: PPUSH
2031: LD_INT 9
2033: PPUSH
2034: LD_INT 100
2036: PPUSH
2037: CALL 75959 0 5
// JMMNewVeh := CreateVehicle ;
2041: LD_ADDR_EXP 59
2045: PUSH
2046: CALL_OW 45
2050: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2051: LD_EXP 59
2055: PPUSH
2056: LD_INT 4
2058: PPUSH
2059: CALL_OW 233
// SetMark ( JMMNewVeh , - 1 ) ;
2063: LD_EXP 59
2067: PPUSH
2068: LD_INT 1
2070: NEG
2071: PPUSH
2072: CALL_OW 242
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2076: LD_EXP 59
2080: PPUSH
2081: LD_INT 79
2083: PPUSH
2084: LD_INT 91
2086: PPUSH
2087: LD_INT 0
2089: PPUSH
2090: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2094: LD_EXP 40
2098: PPUSH
2099: LD_EXP 59
2103: PPUSH
2104: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2108: LD_EXP 6
2112: IFFALSE 2121
2114: PUSH
2115: LD_EXP 2
2119: NOT
2120: AND
2121: IFFALSE 2379
// begin if not JMMGirlVeh then
2123: LD_EXP 5
2127: NOT
2128: IFFALSE 2151
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2130: LD_INT 3
2132: PPUSH
2133: LD_INT 3
2135: PPUSH
2136: LD_INT 1
2138: PPUSH
2139: LD_INT 9
2141: PPUSH
2142: LD_INT 100
2144: PPUSH
2145: CALL 75959 0 5
2149: GO 2210
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2151: LD_EXP 5
2155: PUSH
2156: LD_INT 1
2158: ARRAY
2159: PUSH
2160: LD_INT 1
2162: ARRAY
2163: PPUSH
2164: LD_EXP 5
2168: PUSH
2169: LD_INT 2
2171: ARRAY
2172: PUSH
2173: LD_INT 1
2175: ARRAY
2176: PPUSH
2177: LD_EXP 5
2181: PUSH
2182: LD_INT 3
2184: ARRAY
2185: PUSH
2186: LD_INT 1
2188: ARRAY
2189: PPUSH
2190: LD_EXP 5
2194: PUSH
2195: LD_INT 4
2197: ARRAY
2198: PUSH
2199: LD_INT 1
2201: ARRAY
2202: PPUSH
2203: LD_INT 30
2205: PPUSH
2206: CALL 75959 0 5
// GirlNewVeh := CreateVehicle ;
2210: LD_ADDR_EXP 60
2214: PUSH
2215: CALL_OW 45
2219: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2220: LD_EXP 60
2224: PPUSH
2225: LD_INT 4
2227: PPUSH
2228: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2232: LD_EXP 60
2236: PPUSH
2237: LD_INT 82
2239: PPUSH
2240: LD_INT 96
2242: PPUSH
2243: LD_INT 0
2245: PPUSH
2246: CALL_OW 48
// if JMMGirl = 1 then
2250: LD_EXP 7
2254: PUSH
2255: LD_INT 1
2257: EQUAL
2258: IFFALSE 2293
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2260: LD_ADDR_EXP 41
2264: PUSH
2265: LD_STRING Joan
2267: PPUSH
2268: LD_INT 1
2270: PPUSH
2271: LD_STRING 14_
2273: PPUSH
2274: CALL 70939 0 3
2278: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2279: LD_EXP 41
2283: PPUSH
2284: LD_EXP 60
2288: PPUSH
2289: CALL_OW 52
// end ; if JMMGirl = 2 then
2293: LD_EXP 7
2297: PUSH
2298: LD_INT 2
2300: EQUAL
2301: IFFALSE 2336
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2303: LD_ADDR_EXP 43
2307: PUSH
2308: LD_STRING Lisa
2310: PPUSH
2311: LD_INT 1
2313: PPUSH
2314: LD_STRING 14_
2316: PPUSH
2317: CALL 70939 0 3
2321: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2322: LD_EXP 43
2326: PPUSH
2327: LD_EXP 60
2331: PPUSH
2332: CALL_OW 52
// end ; if JMMGirl = 3 then
2336: LD_EXP 7
2340: PUSH
2341: LD_INT 3
2343: EQUAL
2344: IFFALSE 2379
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2346: LD_ADDR_EXP 55
2350: PUSH
2351: LD_STRING Connie
2353: PPUSH
2354: LD_INT 1
2356: PPUSH
2357: LD_STRING 14_
2359: PPUSH
2360: CALL 70939 0 3
2364: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2365: LD_EXP 55
2369: PPUSH
2370: LD_EXP 60
2374: PPUSH
2375: CALL_OW 52
// end ; end ; end ;
2379: LD_VAR 0 1
2383: RET
// export function PrepareStevensSquad ; var tmp ; begin
2384: LD_INT 0
2386: PPUSH
2387: PPUSH
// uc_side := 1 ;
2388: LD_ADDR_OWVAR 20
2392: PUSH
2393: LD_INT 1
2395: ST_TO_ADDR
// uc_nation := 1 ;
2396: LD_ADDR_OWVAR 21
2400: PUSH
2401: LD_INT 1
2403: ST_TO_ADDR
// tmp := [ ] ;
2404: LD_ADDR_VAR 0 2
2408: PUSH
2409: EMPTY
2410: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2411: LD_ADDR_EXP 42
2415: PUSH
2416: LD_STRING Stevens
2418: PPUSH
2419: LD_EXP 1
2423: NOT
2424: PPUSH
2425: LD_STRING 13f_
2427: PPUSH
2428: CALL 70939 0 3
2432: ST_TO_ADDR
// if not Stevens then
2433: LD_EXP 42
2437: NOT
2438: IFFALSE 2552
// begin hc_name = Baker Smith ;
2440: LD_ADDR_OWVAR 26
2444: PUSH
2445: LD_STRING Baker Smith
2447: ST_TO_ADDR
// hc_gallery = us ;
2448: LD_ADDR_OWVAR 33
2452: PUSH
2453: LD_STRING us
2455: ST_TO_ADDR
// hc_face_number := 29 ;
2456: LD_ADDR_OWVAR 34
2460: PUSH
2461: LD_INT 29
2463: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2464: LD_INT 1
2466: PPUSH
2467: LD_INT 10
2469: PPUSH
2470: CALL_OW 384
// hc_basic_skills := [ 2 , 2 , 0 , 2 ] ;
2474: LD_ADDR_OWVAR 30
2478: PUSH
2479: LD_INT 2
2481: PUSH
2482: LD_INT 2
2484: PUSH
2485: LD_INT 0
2487: PUSH
2488: LD_INT 2
2490: PUSH
2491: EMPTY
2492: LIST
2493: LIST
2494: LIST
2495: LIST
2496: ST_TO_ADDR
// hc_skills := [ 4 , 5 , 2 , 10 ] ;
2497: LD_ADDR_OWVAR 31
2501: PUSH
2502: LD_INT 4
2504: PUSH
2505: LD_INT 5
2507: PUSH
2508: LD_INT 2
2510: PUSH
2511: LD_INT 10
2513: PUSH
2514: EMPTY
2515: LIST
2516: LIST
2517: LIST
2518: LIST
2519: ST_TO_ADDR
// Baker := CreateHuman ;
2520: LD_ADDR_EXP 56
2524: PUSH
2525: CALL_OW 44
2529: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2530: LD_ADDR_VAR 0 2
2534: PUSH
2535: LD_VAR 0 2
2539: PUSH
2540: LD_EXP 56
2544: ADD
2545: ST_TO_ADDR
// InitHc ;
2546: CALL_OW 19
// end else
2550: GO 2568
// tmp := tmp ^ Stevens ;
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 2
2561: PUSH
2562: LD_EXP 42
2566: ADD
2567: ST_TO_ADDR
// if not Lisa then
2568: LD_EXP 43
2572: NOT
2573: IFFALSE 2619
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2575: LD_ADDR_EXP 43
2579: PUSH
2580: LD_STRING Lisa
2582: PPUSH
2583: LD_EXP 1
2587: NOT
2588: PPUSH
2589: LD_STRING 13f_
2591: PPUSH
2592: CALL 70939 0 3
2596: ST_TO_ADDR
// if Lisa then
2597: LD_EXP 43
2601: IFFALSE 2619
// tmp := tmp ^ Lisa ;
2603: LD_ADDR_VAR 0 2
2607: PUSH
2608: LD_VAR 0 2
2612: PUSH
2613: LD_EXP 43
2617: ADD
2618: ST_TO_ADDR
// end ; if not Donaldson then
2619: LD_EXP 44
2623: NOT
2624: IFFALSE 2670
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2626: LD_ADDR_EXP 44
2630: PUSH
2631: LD_STRING Donaldson
2633: PPUSH
2634: LD_EXP 1
2638: NOT
2639: PPUSH
2640: LD_STRING 13f_
2642: PPUSH
2643: CALL 70939 0 3
2647: ST_TO_ADDR
// if Donaldson then
2648: LD_EXP 44
2652: IFFALSE 2670
// tmp := tmp ^ Donaldson ;
2654: LD_ADDR_VAR 0 2
2658: PUSH
2659: LD_VAR 0 2
2663: PUSH
2664: LD_EXP 44
2668: ADD
2669: ST_TO_ADDR
// end ; if not Bobby then
2670: LD_EXP 45
2674: NOT
2675: IFFALSE 2721
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2677: LD_ADDR_EXP 45
2681: PUSH
2682: LD_STRING Bobby
2684: PPUSH
2685: LD_EXP 1
2689: NOT
2690: PPUSH
2691: LD_STRING 13f_
2693: PPUSH
2694: CALL 70939 0 3
2698: ST_TO_ADDR
// if Bobby then
2699: LD_EXP 45
2703: IFFALSE 2721
// tmp := tmp ^ Bobby ;
2705: LD_ADDR_VAR 0 2
2709: PUSH
2710: LD_VAR 0 2
2714: PUSH
2715: LD_EXP 45
2719: ADD
2720: ST_TO_ADDR
// end ; if not Cyrus then
2721: LD_EXP 46
2725: NOT
2726: IFFALSE 2772
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2728: LD_ADDR_EXP 46
2732: PUSH
2733: LD_STRING Cyrus
2735: PPUSH
2736: LD_EXP 1
2740: NOT
2741: PPUSH
2742: LD_STRING 13f_
2744: PPUSH
2745: CALL 70939 0 3
2749: ST_TO_ADDR
// if Cyrus then
2750: LD_EXP 46
2754: IFFALSE 2772
// tmp := tmp ^ Cyrus ;
2756: LD_ADDR_VAR 0 2
2760: PUSH
2761: LD_VAR 0 2
2765: PUSH
2766: LD_EXP 46
2770: ADD
2771: ST_TO_ADDR
// end ; if not Brown then
2772: LD_EXP 48
2776: NOT
2777: IFFALSE 2823
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2779: LD_ADDR_EXP 48
2783: PUSH
2784: LD_STRING Brown
2786: PPUSH
2787: LD_EXP 1
2791: NOT
2792: PPUSH
2793: LD_STRING 13f_
2795: PPUSH
2796: CALL 70939 0 3
2800: ST_TO_ADDR
// if Brown then
2801: LD_EXP 48
2805: IFFALSE 2823
// tmp := tmp ^ Brown ;
2807: LD_ADDR_VAR 0 2
2811: PUSH
2812: LD_VAR 0 2
2816: PUSH
2817: LD_EXP 48
2821: ADD
2822: ST_TO_ADDR
// end ; if not Gladstone then
2823: LD_EXP 49
2827: NOT
2828: IFFALSE 2874
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2830: LD_ADDR_EXP 49
2834: PUSH
2835: LD_STRING Gladstone
2837: PPUSH
2838: LD_EXP 1
2842: NOT
2843: PPUSH
2844: LD_STRING 13f_
2846: PPUSH
2847: CALL 70939 0 3
2851: ST_TO_ADDR
// if Gladstone then
2852: LD_EXP 49
2856: IFFALSE 2874
// tmp := tmp ^ Gladstone ;
2858: LD_ADDR_VAR 0 2
2862: PUSH
2863: LD_VAR 0 2
2867: PUSH
2868: LD_EXP 49
2872: ADD
2873: ST_TO_ADDR
// end ; if not Houten then
2874: LD_EXP 50
2878: NOT
2879: IFFALSE 2925
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2881: LD_ADDR_EXP 50
2885: PUSH
2886: LD_STRING Houten
2888: PPUSH
2889: LD_EXP 1
2893: NOT
2894: PPUSH
2895: LD_STRING 13f_
2897: PPUSH
2898: CALL 70939 0 3
2902: ST_TO_ADDR
// if Houten then
2903: LD_EXP 50
2907: IFFALSE 2925
// tmp := tmp ^ Houten ;
2909: LD_ADDR_VAR 0 2
2913: PUSH
2914: LD_VAR 0 2
2918: PUSH
2919: LD_EXP 50
2923: ADD
2924: ST_TO_ADDR
// end ; if not Cornel then
2925: LD_EXP 51
2929: NOT
2930: IFFALSE 2976
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2932: LD_ADDR_EXP 51
2936: PUSH
2937: LD_STRING Cornell
2939: PPUSH
2940: LD_EXP 1
2944: NOT
2945: PPUSH
2946: LD_STRING 13f_
2948: PPUSH
2949: CALL 70939 0 3
2953: ST_TO_ADDR
// if Cornel then
2954: LD_EXP 51
2958: IFFALSE 2976
// tmp := tmp ^ Cornel ;
2960: LD_ADDR_VAR 0 2
2964: PUSH
2965: LD_VAR 0 2
2969: PUSH
2970: LD_EXP 51
2974: ADD
2975: ST_TO_ADDR
// end ; if not Gary then
2976: LD_EXP 52
2980: NOT
2981: IFFALSE 3027
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2983: LD_ADDR_EXP 52
2987: PUSH
2988: LD_STRING Gary
2990: PPUSH
2991: LD_EXP 1
2995: NOT
2996: PPUSH
2997: LD_STRING 13f_
2999: PPUSH
3000: CALL 70939 0 3
3004: ST_TO_ADDR
// if Gary then
3005: LD_EXP 52
3009: IFFALSE 3027
// tmp := tmp ^ Gary ;
3011: LD_ADDR_VAR 0 2
3015: PUSH
3016: LD_VAR 0 2
3020: PUSH
3021: LD_EXP 52
3025: ADD
3026: ST_TO_ADDR
// end ; if not Frank then
3027: LD_EXP 53
3031: NOT
3032: IFFALSE 3078
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
3034: LD_ADDR_EXP 53
3038: PUSH
3039: LD_STRING Frank
3041: PPUSH
3042: LD_EXP 1
3046: NOT
3047: PPUSH
3048: LD_STRING 13f_
3050: PPUSH
3051: CALL 70939 0 3
3055: ST_TO_ADDR
// if Frank then
3056: LD_EXP 53
3060: IFFALSE 3078
// tmp := tmp ^ Frank ;
3062: LD_ADDR_VAR 0 2
3066: PUSH
3067: LD_VAR 0 2
3071: PUSH
3072: LD_EXP 53
3076: ADD
3077: ST_TO_ADDR
// end ; if not Kikuchi then
3078: LD_EXP 54
3082: NOT
3083: IFFALSE 3129
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
3085: LD_ADDR_EXP 54
3089: PUSH
3090: LD_STRING Kikuchi
3092: PPUSH
3093: LD_EXP 1
3097: NOT
3098: PPUSH
3099: LD_STRING 13f_
3101: PPUSH
3102: CALL 70939 0 3
3106: ST_TO_ADDR
// if Kikuchi then
3107: LD_EXP 54
3111: IFFALSE 3129
// tmp := tmp ^ Kikuchi ;
3113: LD_ADDR_VAR 0 2
3117: PUSH
3118: LD_VAR 0 2
3122: PUSH
3123: LD_EXP 54
3127: ADD
3128: ST_TO_ADDR
// end ; if not DeltaDoctor then
3129: LD_EXP 58
3133: NOT
3134: IFFALSE 3180
// begin DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13f_ ) ;
3136: LD_ADDR_EXP 58
3140: PUSH
3141: LD_STRING DeltaDoctor
3143: PPUSH
3144: LD_EXP 1
3148: NOT
3149: PPUSH
3150: LD_STRING 13f_
3152: PPUSH
3153: CALL 70939 0 3
3157: ST_TO_ADDR
// if Bobby then
3158: LD_EXP 45
3162: IFFALSE 3180
// tmp := tmp ^ DeltaDoctor ;
3164: LD_ADDR_VAR 0 2
3168: PUSH
3169: LD_VAR 0 2
3173: PUSH
3174: LD_EXP 58
3178: ADD
3179: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3180: LD_ADDR_VAR 0 2
3184: PUSH
3185: LD_VAR 0 2
3189: PUSH
3190: LD_STRING 13_other_survivors
3192: PPUSH
3193: CALL_OW 31
3197: UNION
3198: ST_TO_ADDR
// result := tmp diff 0 ;
3199: LD_ADDR_VAR 0 1
3203: PUSH
3204: LD_VAR 0 2
3208: PUSH
3209: LD_INT 0
3211: DIFF
3212: ST_TO_ADDR
// end ; end_of_file
3213: LD_VAR 0 1
3217: RET
// export Powell ; export vip , extraSquad ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3218: LD_INT 0
3220: PPUSH
3221: PPUSH
3222: PPUSH
3223: PPUSH
3224: PPUSH
3225: PPUSH
3226: PPUSH
3227: PPUSH
3228: PPUSH
3229: PPUSH
// uc_side := 4 ;
3230: LD_ADDR_OWVAR 20
3234: PUSH
3235: LD_INT 4
3237: ST_TO_ADDR
// uc_nation := 1 ;
3238: LD_ADDR_OWVAR 21
3242: PUSH
3243: LD_INT 1
3245: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3246: LD_INT 387
3248: PPUSH
3249: CALL_OW 274
3253: PPUSH
3254: LD_INT 1
3256: PPUSH
3257: LD_INT 3500
3259: PUSH
3260: LD_INT 3000
3262: PUSH
3263: LD_INT 2500
3265: PUSH
3266: LD_INT 2000
3268: PUSH
3269: EMPTY
3270: LIST
3271: LIST
3272: LIST
3273: LIST
3274: PUSH
3275: LD_OWVAR 67
3279: ARRAY
3280: PPUSH
3281: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3285: LD_INT 387
3287: PPUSH
3288: CALL_OW 274
3292: PPUSH
3293: LD_INT 2
3295: PPUSH
3296: LD_INT 400
3298: PPUSH
3299: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3303: LD_INT 387
3305: PPUSH
3306: CALL_OW 274
3310: PPUSH
3311: LD_INT 3
3313: PPUSH
3314: LD_INT 10
3316: PPUSH
3317: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3321: LD_INT 387
3323: PPUSH
3324: LD_STRING sigma
3326: PPUSH
3327: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3331: LD_ADDR_EXP 61
3335: PUSH
3336: LD_STRING Powell
3338: PPUSH
3339: CALL_OW 25
3343: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3344: LD_EXP 61
3348: PPUSH
3349: LD_INT 57
3351: PPUSH
3352: LD_INT 94
3354: PPUSH
3355: LD_INT 0
3357: PPUSH
3358: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3362: LD_EXP 61
3366: PPUSH
3367: LD_INT 58
3369: PPUSH
3370: LD_INT 94
3372: PPUSH
3373: CALL_OW 118
// vip := [ ] ;
3377: LD_ADDR_EXP 62
3381: PUSH
3382: EMPTY
3383: ST_TO_ADDR
// extraSquad := [ ] ;
3384: LD_ADDR_EXP 63
3388: PUSH
3389: EMPTY
3390: ST_TO_ADDR
// tmp := [ ] ;
3391: LD_ADDR_VAR 0 5
3395: PUSH
3396: EMPTY
3397: ST_TO_ADDR
// if JMMGirl <> 2 then
3398: LD_EXP 7
3402: PUSH
3403: LD_INT 2
3405: NONEQUAL
3406: IFFALSE 3430
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3408: LD_ADDR_EXP 43
3412: PUSH
3413: LD_STRING Lisa
3415: PPUSH
3416: LD_EXP 1
3420: NOT
3421: PPUSH
3422: LD_STRING 13s_
3424: PPUSH
3425: CALL 70939 0 3
3429: ST_TO_ADDR
// if Lisa then
3430: LD_EXP 43
3434: IFFALSE 3452
// tmp := tmp ^ Lisa ;
3436: LD_ADDR_VAR 0 5
3440: PUSH
3441: LD_VAR 0 5
3445: PUSH
3446: LD_EXP 43
3450: ADD
3451: ST_TO_ADDR
// if JMMGirl < 3 then
3452: LD_EXP 7
3456: PUSH
3457: LD_INT 3
3459: LESS
3460: IFFALSE 3491
// begin Connie := NewCharacter ( Coonie ) ;
3462: LD_ADDR_EXP 55
3466: PUSH
3467: LD_STRING Coonie
3469: PPUSH
3470: CALL_OW 25
3474: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3475: LD_ADDR_VAR 0 5
3479: PUSH
3480: LD_VAR 0 5
3484: PUSH
3485: LD_EXP 55
3489: ADD
3490: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3491: LD_ADDR_EXP 44
3495: PUSH
3496: LD_STRING Donaldson
3498: PPUSH
3499: LD_EXP 1
3503: NOT
3504: PPUSH
3505: LD_STRING 13s_
3507: PPUSH
3508: CALL 70939 0 3
3512: ST_TO_ADDR
// if Donaldson then
3513: LD_EXP 44
3517: IFFALSE 3535
// tmp := tmp ^ Donaldson ;
3519: LD_ADDR_VAR 0 5
3523: PUSH
3524: LD_VAR 0 5
3528: PUSH
3529: LD_EXP 44
3533: ADD
3534: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3535: LD_ADDR_EXP 45
3539: PUSH
3540: LD_STRING Bobby
3542: PPUSH
3543: LD_EXP 1
3547: NOT
3548: PPUSH
3549: LD_STRING 13s_
3551: PPUSH
3552: CALL 70939 0 3
3556: ST_TO_ADDR
// if Bobby then
3557: LD_EXP 45
3561: IFFALSE 3579
// tmp := tmp ^ Bobby ;
3563: LD_ADDR_VAR 0 5
3567: PUSH
3568: LD_VAR 0 5
3572: PUSH
3573: LD_EXP 45
3577: ADD
3578: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3579: LD_ADDR_EXP 46
3583: PUSH
3584: LD_STRING Cyrus
3586: PPUSH
3587: LD_EXP 1
3591: NOT
3592: PPUSH
3593: LD_STRING 13s_
3595: PPUSH
3596: CALL 70939 0 3
3600: ST_TO_ADDR
// if Cyrus then
3601: LD_EXP 46
3605: IFFALSE 3623
// tmp := tmp ^ Cyrus ;
3607: LD_ADDR_VAR 0 5
3611: PUSH
3612: LD_VAR 0 5
3616: PUSH
3617: LD_EXP 46
3621: ADD
3622: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3623: LD_ADDR_EXP 47
3627: PUSH
3628: LD_STRING Denis
3630: PPUSH
3631: LD_EXP 1
3635: NOT
3636: PPUSH
3637: LD_STRING 13s_
3639: PPUSH
3640: CALL 70939 0 3
3644: ST_TO_ADDR
// if not Denis then
3645: LD_EXP 47
3649: NOT
3650: IFFALSE 3674
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3652: LD_ADDR_EXP 47
3656: PUSH
3657: LD_STRING Denis
3659: PPUSH
3660: LD_EXP 1
3664: NOT
3665: PPUSH
3666: LD_STRING 13f_
3668: PPUSH
3669: CALL 70939 0 3
3673: ST_TO_ADDR
// if Denis then
3674: LD_EXP 47
3678: IFFALSE 3696
// tmp := tmp ^ Denis ;
3680: LD_ADDR_VAR 0 5
3684: PUSH
3685: LD_VAR 0 5
3689: PUSH
3690: LD_EXP 47
3694: ADD
3695: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3696: LD_ADDR_EXP 48
3700: PUSH
3701: LD_STRING Brown
3703: PPUSH
3704: LD_EXP 1
3708: NOT
3709: PPUSH
3710: LD_STRING 13s_
3712: PPUSH
3713: CALL 70939 0 3
3717: ST_TO_ADDR
// if Brown then
3718: LD_EXP 48
3722: IFFALSE 3740
// tmp := tmp ^ Brown ;
3724: LD_ADDR_VAR 0 5
3728: PUSH
3729: LD_VAR 0 5
3733: PUSH
3734: LD_EXP 48
3738: ADD
3739: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3740: LD_ADDR_EXP 49
3744: PUSH
3745: LD_STRING Gladstone
3747: PPUSH
3748: LD_EXP 1
3752: NOT
3753: PPUSH
3754: LD_STRING 13s_
3756: PPUSH
3757: CALL 70939 0 3
3761: ST_TO_ADDR
// if Gladstone then
3762: LD_EXP 49
3766: IFFALSE 3784
// tmp := tmp ^ Gladstone ;
3768: LD_ADDR_VAR 0 5
3772: PUSH
3773: LD_VAR 0 5
3777: PUSH
3778: LD_EXP 49
3782: ADD
3783: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3784: LD_ADDR_EXP 50
3788: PUSH
3789: LD_STRING Houten
3791: PPUSH
3792: LD_EXP 1
3796: NOT
3797: PPUSH
3798: LD_STRING 13s_
3800: PPUSH
3801: CALL 70939 0 3
3805: ST_TO_ADDR
// if Houten then
3806: LD_EXP 50
3810: IFFALSE 3828
// tmp := tmp ^ Houten ;
3812: LD_ADDR_VAR 0 5
3816: PUSH
3817: LD_VAR 0 5
3821: PUSH
3822: LD_EXP 50
3826: ADD
3827: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3828: LD_ADDR_EXP 51
3832: PUSH
3833: LD_STRING Cornel
3835: PPUSH
3836: LD_EXP 1
3840: NOT
3841: PPUSH
3842: LD_STRING 13s_
3844: PPUSH
3845: CALL 70939 0 3
3849: ST_TO_ADDR
// if Cornel then
3850: LD_EXP 51
3854: IFFALSE 3872
// tmp := tmp ^ Cornel ;
3856: LD_ADDR_VAR 0 5
3860: PUSH
3861: LD_VAR 0 5
3865: PUSH
3866: LD_EXP 51
3870: ADD
3871: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3872: LD_ADDR_EXP 52
3876: PUSH
3877: LD_STRING Gary
3879: PPUSH
3880: LD_EXP 1
3884: NOT
3885: PPUSH
3886: LD_STRING 13s_
3888: PPUSH
3889: CALL 70939 0 3
3893: ST_TO_ADDR
// if Gary then
3894: LD_EXP 52
3898: IFFALSE 3916
// tmp := tmp ^ Gary ;
3900: LD_ADDR_VAR 0 5
3904: PUSH
3905: LD_VAR 0 5
3909: PUSH
3910: LD_EXP 52
3914: ADD
3915: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3916: LD_ADDR_EXP 53
3920: PUSH
3921: LD_STRING Frank
3923: PPUSH
3924: LD_EXP 1
3928: NOT
3929: PPUSH
3930: LD_STRING 13s_
3932: PPUSH
3933: CALL 70939 0 3
3937: ST_TO_ADDR
// if Frank then
3938: LD_EXP 53
3942: IFFALSE 3960
// tmp := tmp ^ Frank ;
3944: LD_ADDR_VAR 0 5
3948: PUSH
3949: LD_VAR 0 5
3953: PUSH
3954: LD_EXP 53
3958: ADD
3959: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3960: LD_ADDR_EXP 54
3964: PUSH
3965: LD_STRING Kikuchi
3967: PPUSH
3968: LD_EXP 1
3972: NOT
3973: PPUSH
3974: LD_STRING 13s_
3976: PPUSH
3977: CALL 70939 0 3
3981: ST_TO_ADDR
// if Kikuchi then
3982: LD_EXP 54
3986: IFFALSE 4004
// tmp := tmp ^ Kikuchi ;
3988: LD_ADDR_VAR 0 5
3992: PUSH
3993: LD_VAR 0 5
3997: PUSH
3998: LD_EXP 54
4002: ADD
4003: ST_TO_ADDR
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 13s_ ) ;
4004: LD_ADDR_EXP 58
4008: PUSH
4009: LD_STRING DeltaDoctor
4011: PPUSH
4012: LD_EXP 1
4016: NOT
4017: PPUSH
4018: LD_STRING 13s_
4020: PPUSH
4021: CALL 70939 0 3
4025: ST_TO_ADDR
// if DeltaDoctor then
4026: LD_EXP 58
4030: IFFALSE 4048
// tmp := tmp ^ DeltaDoctor ;
4032: LD_ADDR_VAR 0 5
4036: PUSH
4037: LD_VAR 0 5
4041: PUSH
4042: LD_EXP 58
4046: ADD
4047: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
4048: LD_ADDR_EXP 57
4052: PUSH
4053: LD_STRING Mike
4055: PPUSH
4056: LD_EXP 1
4060: NOT
4061: PPUSH
4062: LD_STRING 10c_
4064: PPUSH
4065: CALL 70939 0 3
4069: ST_TO_ADDR
// if Mike then
4070: LD_EXP 57
4074: IFFALSE 4097
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
4076: LD_EXP 57
4080: PPUSH
4081: LD_INT 61
4083: PPUSH
4084: LD_INT 89
4086: PPUSH
4087: LD_INT 8
4089: PPUSH
4090: LD_INT 0
4092: PPUSH
4093: CALL_OW 50
// vip := tmp ;
4097: LD_ADDR_EXP 62
4101: PUSH
4102: LD_VAR 0 5
4106: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
4107: LD_ADDR_VAR 0 5
4111: PUSH
4112: LD_VAR 0 5
4116: PUSH
4117: LD_STRING 13s_others
4119: PPUSH
4120: CALL_OW 31
4124: UNION
4125: ST_TO_ADDR
// if tmp < 18 then
4126: LD_VAR 0 5
4130: PUSH
4131: LD_INT 18
4133: LESS
4134: IFFALSE 4239
// begin InitHC_All ( ) ;
4136: CALL_OW 584
// for i = 1 to 18 - tmp do
4140: LD_ADDR_VAR 0 2
4144: PUSH
4145: DOUBLE
4146: LD_INT 1
4148: DEC
4149: ST_TO_ADDR
4150: LD_INT 18
4152: PUSH
4153: LD_VAR 0 5
4157: MINUS
4158: PUSH
4159: FOR_TO
4160: IFFALSE 4237
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
4162: LD_INT 1
4164: PPUSH
4165: LD_VAR 0 2
4169: PUSH
4170: LD_INT 4
4172: MOD
4173: PUSH
4174: LD_INT 1
4176: PLUS
4177: PPUSH
4178: LD_INT 4
4180: PPUSH
4181: CALL_OW 380
// un := CreateHuman ;
4185: LD_ADDR_VAR 0 10
4189: PUSH
4190: CALL_OW 44
4194: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
4195: LD_ADDR_VAR 0 5
4199: PUSH
4200: LD_VAR 0 5
4204: PPUSH
4205: LD_VAR 0 10
4209: PPUSH
4210: CALL 109139 0 2
4214: ST_TO_ADDR
// extraSquad := Join ( extraSquad , un ) ;
4215: LD_ADDR_EXP 63
4219: PUSH
4220: LD_EXP 63
4224: PPUSH
4225: LD_VAR 0 10
4229: PPUSH
4230: CALL 109139 0 2
4234: ST_TO_ADDR
// end ;
4235: GO 4159
4237: POP
4238: POP
// end ; depot := HexInfo ( 53 , 94 ) ;
4239: LD_ADDR_VAR 0 6
4243: PUSH
4244: LD_INT 53
4246: PPUSH
4247: LD_INT 94
4249: PPUSH
4250: CALL_OW 428
4254: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4255: LD_ADDR_VAR 0 7
4259: PUSH
4260: LD_INT 56
4262: PPUSH
4263: LD_INT 101
4265: PPUSH
4266: CALL_OW 428
4270: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4271: LD_ADDR_VAR 0 8
4275: PUSH
4276: LD_INT 67
4278: PPUSH
4279: LD_INT 101
4281: PPUSH
4282: CALL_OW 428
4286: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4287: LD_ADDR_VAR 0 9
4291: PUSH
4292: LD_INT 54
4294: PPUSH
4295: LD_INT 85
4297: PPUSH
4298: CALL_OW 428
4302: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4303: LD_ADDR_VAR 0 3
4307: PUSH
4308: LD_VAR 0 8
4312: PUSH
4313: LD_VAR 0 6
4317: PUSH
4318: LD_VAR 0 9
4322: PUSH
4323: LD_VAR 0 7
4327: PUSH
4328: EMPTY
4329: LIST
4330: LIST
4331: LIST
4332: LIST
4333: ST_TO_ADDR
// for i in tmp do
4334: LD_ADDR_VAR 0 2
4338: PUSH
4339: LD_VAR 0 5
4343: PUSH
4344: FOR_IN
4345: IFFALSE 4540
// begin case GetBType ( b [ 1 ] ) of b_armoury :
4347: LD_VAR 0 3
4351: PUSH
4352: LD_INT 1
4354: ARRAY
4355: PPUSH
4356: CALL_OW 266
4360: PUSH
4361: LD_INT 4
4363: DOUBLE
4364: EQUAL
4365: IFTRUE 4369
4367: GO 4384
4369: POP
// SetClass ( i , class_soldier ) ; b_depot :
4370: LD_VAR 0 2
4374: PPUSH
4375: LD_INT 1
4377: PPUSH
4378: CALL_OW 336
4382: GO 4454
4384: LD_INT 0
4386: DOUBLE
4387: EQUAL
4388: IFTRUE 4392
4390: GO 4407
4392: POP
// SetClass ( i , class_engineer ) ; b_workshop :
4393: LD_VAR 0 2
4397: PPUSH
4398: LD_INT 2
4400: PPUSH
4401: CALL_OW 336
4405: GO 4454
4407: LD_INT 2
4409: DOUBLE
4410: EQUAL
4411: IFTRUE 4415
4413: GO 4430
4415: POP
// SetClass ( i , class_mechanic ) ; b_lab :
4416: LD_VAR 0 2
4420: PPUSH
4421: LD_INT 3
4423: PPUSH
4424: CALL_OW 336
4428: GO 4454
4430: LD_INT 6
4432: DOUBLE
4433: EQUAL
4434: IFTRUE 4438
4436: GO 4453
4438: POP
// SetClass ( i , class_scientistic ) ; end ;
4439: LD_VAR 0 2
4443: PPUSH
4444: LD_INT 4
4446: PPUSH
4447: CALL_OW 336
4451: GO 4454
4453: POP
// if UnitsInside ( b [ 1 ] ) = 6 then
4454: LD_VAR 0 3
4458: PUSH
4459: LD_INT 1
4461: ARRAY
4462: PPUSH
4463: CALL_OW 313
4467: PUSH
4468: LD_INT 6
4470: EQUAL
4471: IFFALSE 4491
// b := Delete ( b , 1 ) ;
4473: LD_ADDR_VAR 0 3
4477: PUSH
4478: LD_VAR 0 3
4482: PPUSH
4483: LD_INT 1
4485: PPUSH
4486: CALL_OW 3
4490: ST_TO_ADDR
// if b then
4491: LD_VAR 0 3
4495: IFFALSE 4517
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4497: LD_VAR 0 2
4501: PPUSH
4502: LD_VAR 0 3
4506: PUSH
4507: LD_INT 1
4509: ARRAY
4510: PPUSH
4511: CALL_OW 52
4515: GO 4538
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4517: LD_VAR 0 2
4521: PPUSH
4522: LD_INT 61
4524: PPUSH
4525: LD_INT 89
4527: PPUSH
4528: LD_INT 8
4530: PPUSH
4531: LD_INT 0
4533: PPUSH
4534: CALL_OW 50
// end ;
4538: GO 4344
4540: POP
4541: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4542: LD_INT 2
4544: PPUSH
4545: LD_INT 1
4547: PPUSH
4548: LD_INT 1
4550: PPUSH
4551: LD_INT 12
4553: PPUSH
4554: LD_INT 100
4556: PPUSH
4557: CALL 75959 0 5
// veh := CreateVehicle ;
4561: LD_ADDR_VAR 0 4
4565: PUSH
4566: CALL_OW 45
4570: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4571: LD_VAR 0 4
4575: PPUSH
4576: LD_INT 4
4578: PPUSH
4579: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4583: LD_VAR 0 4
4587: PPUSH
4588: LD_INT 49
4590: PPUSH
4591: LD_INT 88
4593: PPUSH
4594: LD_INT 0
4596: PPUSH
4597: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4601: LD_VAR 0 4
4605: PPUSH
4606: LD_INT 1
4608: PPUSH
4609: LD_INT 100
4611: PPUSH
4612: CALL_OW 290
// uc_side := 0 ;
4616: LD_ADDR_OWVAR 20
4620: PUSH
4621: LD_INT 0
4623: ST_TO_ADDR
// uc_nation := 0 ;
4624: LD_ADDR_OWVAR 21
4628: PUSH
4629: LD_INT 0
4631: ST_TO_ADDR
// for i := 1 to 3 do
4632: LD_ADDR_VAR 0 2
4636: PUSH
4637: DOUBLE
4638: LD_INT 1
4640: DEC
4641: ST_TO_ADDR
4642: LD_INT 3
4644: PUSH
4645: FOR_TO
4646: IFFALSE 4677
// begin InitHc ;
4648: CALL_OW 19
// hc_class := class_apeman ;
4652: LD_ADDR_OWVAR 28
4656: PUSH
4657: LD_INT 12
4659: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4660: CALL_OW 44
4664: PPUSH
4665: LD_INT 13
4667: PPUSH
4668: LD_INT 0
4670: PPUSH
4671: CALL_OW 49
// end ;
4675: GO 4645
4677: POP
4678: POP
// end ; end_of_file
4679: LD_VAR 0 1
4683: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4684: LD_INT 0
4686: PPUSH
4687: PPUSH
4688: PPUSH
4689: PPUSH
4690: PPUSH
// side := 8 ;
4691: LD_ADDR_VAR 0 3
4695: PUSH
4696: LD_INT 8
4698: ST_TO_ADDR
// uc_side := side ;
4699: LD_ADDR_OWVAR 20
4703: PUSH
4704: LD_VAR 0 3
4708: ST_TO_ADDR
// uc_nation := 2 ;
4709: LD_ADDR_OWVAR 21
4713: PUSH
4714: LD_INT 2
4716: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4717: LD_ADDR_VAR 0 2
4721: PUSH
4722: LD_INT 22
4724: PUSH
4725: LD_VAR 0 3
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PUSH
4734: LD_INT 21
4736: PUSH
4737: LD_INT 3
4739: PUSH
4740: EMPTY
4741: LIST
4742: LIST
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: PPUSH
4748: CALL_OW 69
4752: PUSH
4753: FOR_IN
4754: IFFALSE 4770
// SetBLevel ( i , 10 ) ;
4756: LD_VAR 0 2
4760: PPUSH
4761: LD_INT 10
4763: PPUSH
4764: CALL_OW 241
4768: GO 4753
4770: POP
4771: POP
// if KurtStatus then
4772: LD_EXP 3
4776: IFFALSE 4799
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4778: LD_ADDR_EXP 64
4782: PUSH
4783: LD_STRING Kurt
4785: PPUSH
4786: LD_INT 0
4788: PPUSH
4789: LD_STRING 
4791: PPUSH
4792: CALL 70939 0 3
4796: ST_TO_ADDR
4797: GO 4821
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4799: LD_ADDR_EXP 64
4803: PUSH
4804: LD_STRING AltKurt
4806: PPUSH
4807: LD_EXP 1
4811: NOT
4812: PPUSH
4813: LD_STRING 
4815: PPUSH
4816: CALL 70939 0 3
4820: ST_TO_ADDR
// if not Kurt then
4821: LD_EXP 64
4825: NOT
4826: IFFALSE 4852
// begin InitHc ;
4828: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4832: LD_INT 1
4834: PPUSH
4835: LD_INT 10
4837: PPUSH
4838: CALL_OW 381
// Kurt := CreateHuman ;
4842: LD_ADDR_EXP 64
4846: PUSH
4847: CALL_OW 44
4851: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4852: LD_EXP 64
4856: PPUSH
4857: LD_INT 324
4859: PPUSH
4860: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4864: LD_ADDR_EXP 65
4868: PUSH
4869: LD_STRING Kozlov
4871: PPUSH
4872: LD_INT 0
4874: PPUSH
4875: LD_STRING 
4877: PPUSH
4878: CALL 70939 0 3
4882: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4883: LD_EXP 65
4887: PPUSH
4888: LD_INT 22
4890: PUSH
4891: LD_INT 8
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 23
4900: PUSH
4901: LD_INT 3
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PUSH
4908: LD_INT 30
4910: PUSH
4911: LD_INT 8
4913: PUSH
4914: EMPTY
4915: LIST
4916: LIST
4917: PUSH
4918: EMPTY
4919: LIST
4920: LIST
4921: LIST
4922: PPUSH
4923: CALL_OW 69
4927: PUSH
4928: LD_INT 1
4930: ARRAY
4931: PPUSH
4932: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4936: LD_EXP 65
4940: PPUSH
4941: LD_INT 3
4943: PPUSH
4944: LD_INT 10
4946: PPUSH
4947: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4951: LD_EXP 65
4955: PPUSH
4956: LD_INT 4
4958: PPUSH
4959: LD_INT 10
4961: PPUSH
4962: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4966: LD_ADDR_VAR 0 5
4970: PUSH
4971: LD_INT 22
4973: PUSH
4974: LD_VAR 0 3
4978: PUSH
4979: EMPTY
4980: LIST
4981: LIST
4982: PUSH
4983: LD_INT 30
4985: PUSH
4986: LD_INT 32
4988: PUSH
4989: EMPTY
4990: LIST
4991: LIST
4992: PUSH
4993: LD_INT 58
4995: PUSH
4996: EMPTY
4997: LIST
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: LIST
5003: PPUSH
5004: CALL_OW 69
5008: ST_TO_ADDR
// for i = 1 to 10 do
5009: LD_ADDR_VAR 0 2
5013: PUSH
5014: DOUBLE
5015: LD_INT 1
5017: DEC
5018: ST_TO_ADDR
5019: LD_INT 10
5021: PUSH
5022: FOR_TO
5023: IFFALSE 5095
// begin uc_nation := nation_nature ;
5025: LD_ADDR_OWVAR 21
5029: PUSH
5030: LD_INT 0
5032: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
5033: LD_ADDR_OWVAR 28
5037: PUSH
5038: LD_INT 15
5040: ST_TO_ADDR
// hc_gallery :=  ;
5041: LD_ADDR_OWVAR 33
5045: PUSH
5046: LD_STRING 
5048: ST_TO_ADDR
// hc_name :=  ;
5049: LD_ADDR_OWVAR 26
5053: PUSH
5054: LD_STRING 
5056: ST_TO_ADDR
// un := CreateHuman ;
5057: LD_ADDR_VAR 0 4
5061: PUSH
5062: CALL_OW 44
5066: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
5067: LD_VAR 0 4
5071: PPUSH
5072: LD_VAR 0 5
5076: PUSH
5077: LD_VAR 0 5
5081: PUSH
5082: LD_VAR 0 2
5086: MINUS
5087: ARRAY
5088: PPUSH
5089: CALL_OW 52
// end ;
5093: GO 5022
5095: POP
5096: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
5097: LD_ADDR_VAR 0 5
5101: PUSH
5102: LD_STRING 12_kurt_squad
5104: PPUSH
5105: CALL_OW 31
5109: ST_TO_ADDR
// if tmp then
5110: LD_VAR 0 5
5114: IFFALSE 5148
// for i in tmp do
5116: LD_ADDR_VAR 0 2
5120: PUSH
5121: LD_VAR 0 5
5125: PUSH
5126: FOR_IN
5127: IFFALSE 5146
// PlaceUnitArea ( i , legionBaseArea , false ) ;
5129: LD_VAR 0 2
5133: PPUSH
5134: LD_INT 5
5136: PPUSH
5137: LD_INT 0
5139: PPUSH
5140: CALL_OW 49
5144: GO 5126
5146: POP
5147: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
5148: LD_INT 324
5150: PPUSH
5151: LD_INT 5
5153: PPUSH
5154: LD_STRING 
5156: PPUSH
5157: LD_INT 8
5159: PUSH
5160: LD_INT 9
5162: PUSH
5163: LD_INT 10
5165: PUSH
5166: LD_INT 10
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: LIST
5173: LIST
5174: PUSH
5175: LD_OWVAR 67
5179: ARRAY
5180: PPUSH
5181: LD_INT 3000
5183: PUSH
5184: LD_INT 500
5186: PUSH
5187: LD_INT 150
5189: PUSH
5190: EMPTY
5191: LIST
5192: LIST
5193: LIST
5194: PPUSH
5195: LD_INT 16
5197: PUSH
5198: LD_INT 6
5200: PUSH
5201: LD_INT 6
5203: PUSH
5204: LD_INT 8
5206: PUSH
5207: EMPTY
5208: LIST
5209: LIST
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL 79796 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
5217: LD_ADDR_EXP 102
5221: PUSH
5222: LD_EXP 102
5226: PPUSH
5227: LD_INT 3
5229: PPUSH
5230: LD_INT 22
5232: PUSH
5233: LD_VAR 0 3
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: PUSH
5242: LD_INT 23
5244: PUSH
5245: LD_INT 2
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: PUSH
5252: LD_INT 3
5254: PUSH
5255: LD_INT 21
5257: PUSH
5258: LD_INT 2
5260: PUSH
5261: EMPTY
5262: LIST
5263: LIST
5264: PUSH
5265: EMPTY
5266: LIST
5267: LIST
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: LIST
5273: PPUSH
5274: CALL_OW 69
5278: PUSH
5279: LD_EXP 64
5283: DIFF
5284: PPUSH
5285: CALL_OW 1
5289: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
5290: LD_INT 1
5292: PPUSH
5293: LD_INT 7
5295: PPUSH
5296: CALL_OW 383
// hc_name := Ali Hadrach ;
5300: LD_ADDR_OWVAR 26
5304: PUSH
5305: LD_STRING Ali Hadrach
5307: ST_TO_ADDR
// hc_gallery := us ;
5308: LD_ADDR_OWVAR 33
5312: PUSH
5313: LD_STRING us
5315: ST_TO_ADDR
// hc_face_number := 31 ;
5316: LD_ADDR_OWVAR 34
5320: PUSH
5321: LD_INT 31
5323: ST_TO_ADDR
// Friend := CreateHuman ;
5324: LD_ADDR_EXP 66
5328: PUSH
5329: CALL_OW 44
5333: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5334: LD_INT 14
5336: PPUSH
5337: LD_INT 3
5339: PPUSH
5340: LD_INT 1
5342: PPUSH
5343: LD_INT 29
5345: PPUSH
5346: LD_INT 100
5348: PPUSH
5349: CALL 75959 0 5
// powellBomb := CreateVehicle ;
5353: LD_ADDR_EXP 67
5357: PUSH
5358: CALL_OW 45
5362: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5363: LD_EXP 67
5367: PPUSH
5368: LD_INT 90
5370: PPUSH
5371: LD_INT 51
5373: PPUSH
5374: LD_INT 0
5376: PPUSH
5377: CALL_OW 48
// end ;
5381: LD_VAR 0 1
5385: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5386: LD_INT 0
5388: PPUSH
5389: PPUSH
5390: PPUSH
// if IsLive ( kozlov_fac ) then
5391: LD_INT 332
5393: PPUSH
5394: CALL_OW 300
5398: IFFALSE 5402
// exit ;
5400: GO 5969
// ComExitBuilding ( Kozlov ) ;
5402: LD_EXP 65
5406: PPUSH
5407: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5411: LD_EXP 65
5415: PPUSH
5416: CALL_OW 257
5420: PUSH
5421: LD_INT 2
5423: NONEQUAL
5424: IFFALSE 5459
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5426: LD_EXP 65
5430: PPUSH
5431: LD_INT 324
5433: PPUSH
5434: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5438: LD_EXP 65
5442: PPUSH
5443: LD_INT 2
5445: PPUSH
5446: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5450: LD_EXP 65
5454: PPUSH
5455: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5459: LD_EXP 65
5463: PPUSH
5464: LD_INT 2
5466: PPUSH
5467: LD_INT 93
5469: PPUSH
5470: LD_INT 32
5472: PPUSH
5473: LD_INT 3
5475: PPUSH
5476: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5480: LD_INT 35
5482: PPUSH
5483: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5487: LD_INT 22
5489: PUSH
5490: LD_INT 8
5492: PUSH
5493: EMPTY
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 30
5499: PUSH
5500: LD_INT 3
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: PUSH
5507: LD_INT 23
5509: PUSH
5510: LD_INT 3
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 57
5519: PUSH
5520: EMPTY
5521: LIST
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: LIST
5527: LIST
5528: PPUSH
5529: CALL_OW 69
5533: IFFALSE 5480
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5535: LD_ADDR_VAR 0 2
5539: PUSH
5540: LD_INT 22
5542: PUSH
5543: LD_INT 8
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: LD_INT 30
5552: PUSH
5553: LD_INT 3
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: PUSH
5560: LD_INT 23
5562: PUSH
5563: LD_INT 3
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: PUSH
5570: LD_INT 57
5572: PUSH
5573: EMPTY
5574: LIST
5575: PUSH
5576: EMPTY
5577: LIST
5578: LIST
5579: LIST
5580: LIST
5581: PPUSH
5582: CALL_OW 69
5586: PUSH
5587: LD_INT 1
5589: ARRAY
5590: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5591: LD_INT 22
5593: PUSH
5594: LD_INT 8
5596: PUSH
5597: EMPTY
5598: LIST
5599: LIST
5600: PUSH
5601: LD_INT 23
5603: PUSH
5604: LD_INT 3
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: PUSH
5611: LD_INT 30
5613: PUSH
5614: LD_INT 21
5616: PUSH
5617: EMPTY
5618: LIST
5619: LIST
5620: PUSH
5621: EMPTY
5622: LIST
5623: LIST
5624: LIST
5625: PPUSH
5626: CALL_OW 69
5630: NOT
5631: IFFALSE 5709
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5633: LD_EXP 65
5637: PPUSH
5638: LD_INT 21
5640: PPUSH
5641: LD_INT 97
5643: PPUSH
5644: LD_INT 36
5646: PPUSH
5647: LD_INT 5
5649: PPUSH
5650: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5654: LD_INT 35
5656: PPUSH
5657: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5661: LD_INT 22
5663: PUSH
5664: LD_INT 8
5666: PUSH
5667: EMPTY
5668: LIST
5669: LIST
5670: PUSH
5671: LD_INT 23
5673: PUSH
5674: LD_INT 3
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: PUSH
5681: LD_INT 30
5683: PUSH
5684: LD_INT 21
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: PUSH
5691: LD_INT 57
5693: PUSH
5694: EMPTY
5695: LIST
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: LIST
5701: LIST
5702: PPUSH
5703: CALL_OW 69
5707: IFFALSE 5654
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5709: LD_INT 22
5711: PUSH
5712: LD_INT 8
5714: PUSH
5715: EMPTY
5716: LIST
5717: LIST
5718: PUSH
5719: LD_INT 23
5721: PUSH
5722: LD_INT 3
5724: PUSH
5725: EMPTY
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 30
5731: PUSH
5732: LD_INT 18
5734: PUSH
5735: EMPTY
5736: LIST
5737: LIST
5738: PUSH
5739: EMPTY
5740: LIST
5741: LIST
5742: LIST
5743: PPUSH
5744: CALL_OW 69
5748: NOT
5749: IFFALSE 5827
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5751: LD_EXP 65
5755: PPUSH
5756: LD_INT 18
5758: PPUSH
5759: LD_INT 89
5761: PPUSH
5762: LD_INT 32
5764: PPUSH
5765: LD_INT 1
5767: PPUSH
5768: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5772: LD_INT 35
5774: PPUSH
5775: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5779: LD_INT 22
5781: PUSH
5782: LD_INT 8
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PUSH
5789: LD_INT 23
5791: PUSH
5792: LD_INT 3
5794: PUSH
5795: EMPTY
5796: LIST
5797: LIST
5798: PUSH
5799: LD_INT 30
5801: PUSH
5802: LD_INT 18
5804: PUSH
5805: EMPTY
5806: LIST
5807: LIST
5808: PUSH
5809: LD_INT 57
5811: PUSH
5812: EMPTY
5813: LIST
5814: PUSH
5815: EMPTY
5816: LIST
5817: LIST
5818: LIST
5819: LIST
5820: PPUSH
5821: CALL_OW 69
5825: IFFALSE 5772
// end ; lab := kozlov_lab ;
5827: LD_ADDR_VAR 0 3
5831: PUSH
5832: LD_INT 336
5834: ST_TO_ADDR
// if not lab then
5835: LD_VAR 0 3
5839: NOT
5840: IFFALSE 5844
// exit ;
5842: GO 5969
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5844: LD_EXP 65
5848: PPUSH
5849: LD_VAR 0 3
5853: PUSH
5854: LD_INT 1
5856: ARRAY
5857: PPUSH
5858: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5862: LD_EXP 65
5866: PPUSH
5867: LD_INT 4
5869: PPUSH
5870: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5874: LD_VAR 0 3
5878: PUSH
5879: LD_INT 1
5881: ARRAY
5882: PPUSH
5883: LD_INT 25
5885: PPUSH
5886: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5890: LD_INT 35
5892: PPUSH
5893: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5897: LD_INT 25
5899: PPUSH
5900: LD_INT 8
5902: PPUSH
5903: CALL_OW 321
5907: PUSH
5908: LD_INT 2
5910: EQUAL
5911: IFFALSE 5890
// ComExitBuilding ( Kozlov ) ;
5913: LD_EXP 65
5917: PPUSH
5918: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5922: LD_EXP 65
5926: PPUSH
5927: LD_VAR 0 2
5931: PPUSH
5932: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5936: LD_EXP 65
5940: PPUSH
5941: LD_INT 3
5943: PPUSH
5944: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5948: LD_VAR 0 2
5952: PPUSH
5953: LD_INT 23
5955: PPUSH
5956: LD_INT 3
5958: PPUSH
5959: LD_INT 1
5961: PPUSH
5962: LD_INT 48
5964: PPUSH
5965: CALL_OW 125
// end ;
5969: LD_VAR 0 1
5973: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5974: LD_EXP 22
5978: NOT
5979: IFFALSE 5991
5981: PUSH
5982: LD_EXP 15
5986: PUSH
5987: LD_INT 6
5989: GREATEREQUAL
5990: AND
5991: IFFALSE 6072
5993: GO 5995
5995: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5996: LD_INT 3
5998: PPUSH
5999: LD_INT 3
6001: PPUSH
6002: CALL 64552 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
6006: LD_INT 3
6008: PPUSH
6009: LD_INT 14
6011: PUSH
6012: LD_INT 1
6014: PUSH
6015: LD_INT 1
6017: PUSH
6018: LD_INT 28
6020: PUSH
6021: EMPTY
6022: LIST
6023: LIST
6024: LIST
6025: LIST
6026: PUSH
6027: LD_INT 14
6029: PUSH
6030: LD_INT 1
6032: PUSH
6033: LD_INT 1
6035: PUSH
6036: LD_INT 28
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_INT 14
6047: PUSH
6048: LD_INT 1
6050: PUSH
6051: LD_INT 1
6053: PUSH
6054: LD_INT 28
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: LIST
6061: LIST
6062: PUSH
6063: EMPTY
6064: LIST
6065: LIST
6066: LIST
6067: PPUSH
6068: CALL 64415 0 2
// end ;
6072: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target , p ;
6073: LD_EXP 22
6077: NOT
6078: IFFALSE 6090
6080: PUSH
6081: LD_EXP 15
6085: PUSH
6086: LD_INT 6
6088: GREATEREQUAL
6089: AND
6090: IFFALSE 6105
6092: PUSH
6093: LD_INT 3
6095: PPUSH
6096: LD_INT 1
6098: PPUSH
6099: CALL 65871 0 2
6103: NOT
6104: AND
6105: IFFALSE 7062
6107: GO 6109
6109: DISABLE
6110: LD_INT 0
6112: PPUSH
6113: PPUSH
6114: PPUSH
6115: PPUSH
// begin enable ;
6116: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
6117: LD_INT 22
6119: PUSH
6120: LD_INT 8
6122: PUSH
6123: EMPTY
6124: LIST
6125: LIST
6126: PUSH
6127: LD_INT 23
6129: PUSH
6130: LD_INT 2
6132: PUSH
6133: EMPTY
6134: LIST
6135: LIST
6136: PUSH
6137: LD_INT 30
6139: PUSH
6140: LD_INT 3
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: PUSH
6147: EMPTY
6148: LIST
6149: LIST
6150: LIST
6151: PPUSH
6152: CALL_OW 69
6156: NOT
6157: IFFALSE 6161
// exit ;
6159: GO 7062
// if Prob ( 40 ) then
6161: LD_INT 40
6163: PPUSH
6164: CALL_OW 13
6168: IFFALSE 6295
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6170: LD_INT 3
6172: PPUSH
6173: LD_INT 14
6175: PUSH
6176: LD_INT 1
6178: PUSH
6179: LD_INT 2
6181: PUSH
6182: LD_INT 28
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: PUSH
6191: LD_INT 14
6193: PUSH
6194: LD_INT 1
6196: PUSH
6197: LD_INT 2
6199: PUSH
6200: LD_INT 28
6202: PUSH
6203: EMPTY
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 14
6211: PUSH
6212: LD_INT 1
6214: PUSH
6215: LD_INT 2
6217: PUSH
6218: LD_INT 28
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 14
6229: PUSH
6230: LD_INT 1
6232: PUSH
6233: LD_INT 2
6235: PUSH
6236: LD_INT 28
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: PUSH
6245: LD_INT 14
6247: PUSH
6248: LD_INT 1
6250: PUSH
6251: LD_INT 2
6253: PUSH
6254: LD_INT 28
6256: PUSH
6257: EMPTY
6258: LIST
6259: LIST
6260: LIST
6261: LIST
6262: PUSH
6263: LD_INT 14
6265: PUSH
6266: LD_INT 1
6268: PUSH
6269: LD_INT 2
6271: PUSH
6272: LD_INT 26
6274: PUSH
6275: EMPTY
6276: LIST
6277: LIST
6278: LIST
6279: LIST
6280: PUSH
6281: EMPTY
6282: LIST
6283: LIST
6284: LIST
6285: LIST
6286: LIST
6287: LIST
6288: PPUSH
6289: CALL 64415 0 2
// end else
6293: GO 6502
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
6295: LD_INT 3
6297: PPUSH
6298: LD_INT 14
6300: PUSH
6301: LD_INT 1
6303: PUSH
6304: LD_INT 2
6306: PUSH
6307: LD_INT 27
6309: PUSH
6310: LD_INT 26
6312: PUSH
6313: LD_INT 26
6315: PUSH
6316: LD_INT 28
6318: PUSH
6319: EMPTY
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: PUSH
6325: LD_OWVAR 67
6329: ARRAY
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: PUSH
6337: LD_INT 14
6339: PUSH
6340: LD_INT 1
6342: PUSH
6343: LD_INT 2
6345: PUSH
6346: LD_INT 27
6348: PUSH
6349: LD_INT 26
6351: PUSH
6352: LD_INT 26
6354: PUSH
6355: LD_INT 26
6357: PUSH
6358: EMPTY
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: PUSH
6364: LD_OWVAR 67
6368: ARRAY
6369: PUSH
6370: EMPTY
6371: LIST
6372: LIST
6373: LIST
6374: LIST
6375: PUSH
6376: LD_INT 14
6378: PUSH
6379: LD_INT 1
6381: PUSH
6382: LD_INT 2
6384: PUSH
6385: LD_INT 26
6387: PUSH
6388: LD_INT 26
6390: PUSH
6391: LD_INT 29
6393: PUSH
6394: LD_INT 29
6396: PUSH
6397: EMPTY
6398: LIST
6399: LIST
6400: LIST
6401: LIST
6402: PUSH
6403: LD_OWVAR 67
6407: ARRAY
6408: PUSH
6409: EMPTY
6410: LIST
6411: LIST
6412: LIST
6413: LIST
6414: PUSH
6415: LD_INT 13
6417: PUSH
6418: LD_INT 1
6420: PUSH
6421: LD_INT 2
6423: PUSH
6424: LD_INT 26
6426: PUSH
6427: LD_INT 29
6429: PUSH
6430: LD_INT 29
6432: PUSH
6433: LD_INT 29
6435: PUSH
6436: EMPTY
6437: LIST
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: LD_OWVAR 67
6446: ARRAY
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 13
6456: PUSH
6457: LD_INT 1
6459: PUSH
6460: LD_INT 2
6462: PUSH
6463: LD_INT 29
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 14
6474: PUSH
6475: LD_INT 1
6477: PUSH
6478: LD_INT 2
6480: PUSH
6481: LD_INT 26
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: EMPTY
6491: LIST
6492: LIST
6493: LIST
6494: LIST
6495: LIST
6496: LIST
6497: PPUSH
6498: CALL 64415 0 2
// end ; wait ( 2 2$00 ) ;
6502: LD_INT 4200
6504: PPUSH
6505: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ar_control_tower ] ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] , [ f_not , [ f_weapon , ar_crane ] ] ] ) diff mc_defender [ 3 ] ;
6509: LD_ADDR_VAR 0 2
6513: PUSH
6514: LD_INT 22
6516: PUSH
6517: LD_INT 8
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: PUSH
6524: LD_INT 21
6526: PUSH
6527: LD_INT 2
6529: PUSH
6530: EMPTY
6531: LIST
6532: LIST
6533: PUSH
6534: LD_INT 3
6536: PUSH
6537: LD_INT 34
6539: PUSH
6540: LD_INT 31
6542: PUSH
6543: EMPTY
6544: LIST
6545: LIST
6546: PUSH
6547: EMPTY
6548: LIST
6549: LIST
6550: PUSH
6551: LD_INT 3
6553: PUSH
6554: LD_INT 34
6556: PUSH
6557: LD_INT 32
6559: PUSH
6560: EMPTY
6561: LIST
6562: LIST
6563: PUSH
6564: EMPTY
6565: LIST
6566: LIST
6567: PUSH
6568: LD_INT 3
6570: PUSH
6571: LD_INT 34
6573: PUSH
6574: LD_INT 88
6576: PUSH
6577: EMPTY
6578: LIST
6579: LIST
6580: PUSH
6581: EMPTY
6582: LIST
6583: LIST
6584: PUSH
6585: EMPTY
6586: LIST
6587: LIST
6588: LIST
6589: LIST
6590: LIST
6591: PPUSH
6592: CALL_OW 69
6596: PUSH
6597: LD_EXP 124
6601: PUSH
6602: LD_INT 3
6604: ARRAY
6605: DIFF
6606: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6607: LD_ADDR_EXP 121
6611: PUSH
6612: LD_EXP 121
6616: PPUSH
6617: LD_INT 3
6619: PPUSH
6620: LD_EXP 121
6624: PUSH
6625: LD_INT 3
6627: ARRAY
6628: PUSH
6629: LD_VAR 0 2
6633: DIFF
6634: PPUSH
6635: CALL_OW 1
6639: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6640: LD_ADDR_VAR 0 3
6644: PUSH
6645: LD_INT 0
6647: PPUSH
6648: LD_INT 2
6650: PPUSH
6651: CALL_OW 12
6655: ST_TO_ADDR
// if target then
6656: LD_VAR 0 3
6660: IFFALSE 6820
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6662: LD_ADDR_VAR 0 2
6666: PUSH
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 50
6674: PUSH
6675: EMPTY
6676: LIST
6677: PPUSH
6678: CALL_OW 72
6682: ST_TO_ADDR
// if not tmp then
6683: LD_VAR 0 2
6687: NOT
6688: IFFALSE 6692
// break ;
6690: GO 6818
// for i in tmp do
6692: LD_ADDR_VAR 0 1
6696: PUSH
6697: LD_VAR 0 2
6701: PUSH
6702: FOR_IN
6703: IFFALSE 6743
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6705: LD_VAR 0 1
6709: PPUSH
6710: LD_INT 89
6712: PPUSH
6713: LD_INT 71
6715: PPUSH
6716: CALL_OW 297
6720: PUSH
6721: LD_INT 9
6723: GREATER
6724: IFFALSE 6741
// ComMoveXY ( i , 89 , 71 ) ;
6726: LD_VAR 0 1
6730: PPUSH
6731: LD_INT 89
6733: PPUSH
6734: LD_INT 71
6736: PPUSH
6737: CALL_OW 111
6741: GO 6702
6743: POP
6744: POP
// wait ( 0 0$1 ) ;
6745: LD_INT 35
6747: PPUSH
6748: CALL_OW 67
// p := Inc ( p ) ;
6752: LD_ADDR_VAR 0 4
6756: PUSH
6757: LD_VAR 0 4
6761: PPUSH
6762: CALL 110512 0 1
6766: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6767: LD_VAR 0 2
6771: PPUSH
6772: LD_INT 92
6774: PUSH
6775: LD_INT 89
6777: PUSH
6778: LD_INT 71
6780: PUSH
6781: LD_INT 9
6783: PUSH
6784: EMPTY
6785: LIST
6786: LIST
6787: LIST
6788: LIST
6789: PPUSH
6790: CALL_OW 72
6794: PUSH
6795: LD_VAR 0 2
6799: PUSH
6800: LD_INT 1
6802: MINUS
6803: GREATEREQUAL
6804: IFTRUE 6816
6806: PUSH
6807: LD_VAR 0 4
6811: PUSH
6812: LD_INT 30
6814: GREATER
6815: OR
6816: IFFALSE 6662
// end else
6818: GO 6976
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6820: LD_ADDR_VAR 0 2
6824: PUSH
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 50
6832: PUSH
6833: EMPTY
6834: LIST
6835: PPUSH
6836: CALL_OW 72
6840: ST_TO_ADDR
// if not tmp then
6841: LD_VAR 0 2
6845: NOT
6846: IFFALSE 6850
// break ;
6848: GO 6976
// for i in tmp do
6850: LD_ADDR_VAR 0 1
6854: PUSH
6855: LD_VAR 0 2
6859: PUSH
6860: FOR_IN
6861: IFFALSE 6901
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6863: LD_VAR 0 1
6867: PPUSH
6868: LD_INT 125
6870: PPUSH
6871: LD_INT 129
6873: PPUSH
6874: CALL_OW 297
6878: PUSH
6879: LD_INT 9
6881: GREATER
6882: IFFALSE 6899
// ComMoveXY ( i , 125 , 129 ) ;
6884: LD_VAR 0 1
6888: PPUSH
6889: LD_INT 125
6891: PPUSH
6892: LD_INT 129
6894: PPUSH
6895: CALL_OW 111
6899: GO 6860
6901: POP
6902: POP
// wait ( 0 0$1 ) ;
6903: LD_INT 35
6905: PPUSH
6906: CALL_OW 67
// p := Inc ( p ) ;
6910: LD_ADDR_VAR 0 4
6914: PUSH
6915: LD_VAR 0 4
6919: PPUSH
6920: CALL 110512 0 1
6924: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
6925: LD_VAR 0 2
6929: PPUSH
6930: LD_INT 92
6932: PUSH
6933: LD_INT 125
6935: PUSH
6936: LD_INT 129
6938: PUSH
6939: LD_INT 9
6941: PUSH
6942: EMPTY
6943: LIST
6944: LIST
6945: LIST
6946: LIST
6947: PPUSH
6948: CALL_OW 72
6952: PUSH
6953: LD_VAR 0 2
6957: PUSH
6958: LD_INT 1
6960: MINUS
6961: GREATEREQUAL
6962: IFTRUE 6974
6964: PUSH
6965: LD_VAR 0 4
6969: PUSH
6970: LD_INT 30
6972: GREATER
6973: OR
6974: IFFALSE 6820
// end ; repeat wait ( 0 0$1 ) ;
6976: LD_INT 35
6978: PPUSH
6979: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
6983: LD_ADDR_VAR 0 2
6987: PUSH
6988: LD_VAR 0 2
6992: PPUSH
6993: LD_INT 50
6995: PUSH
6996: EMPTY
6997: LIST
6998: PPUSH
6999: CALL_OW 72
7003: ST_TO_ADDR
// for i in tmp do
7004: LD_ADDR_VAR 0 1
7008: PUSH
7009: LD_VAR 0 2
7013: PUSH
7014: FOR_IN
7015: IFFALSE 7053
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7017: LD_VAR 0 1
7021: PPUSH
7022: LD_INT 81
7024: PUSH
7025: LD_INT 8
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: PPUSH
7032: CALL_OW 69
7036: PPUSH
7037: LD_VAR 0 1
7041: PPUSH
7042: CALL_OW 74
7046: PPUSH
7047: CALL_OW 115
7051: GO 7014
7053: POP
7054: POP
// until not tmp ;
7055: LD_VAR 0 2
7059: NOT
7060: IFFALSE 6976
// end ;
7062: PPOPN 4
7064: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
7065: LD_EXP 22
7069: NOT
7070: IFFALSE 7082
7072: PUSH
7073: LD_EXP 15
7077: PUSH
7078: LD_INT 6
7080: GREATEREQUAL
7081: AND
7082: IFFALSE 7094
7084: PUSH
7085: LD_OWVAR 67
7089: PUSH
7090: LD_INT 1
7092: GREATER
7093: AND
7094: IFFALSE 7627
7096: GO 7098
7098: DISABLE
7099: LD_INT 0
7101: PPUSH
7102: PPUSH
7103: PPUSH
// begin enable ;
7104: ENABLE
// tmp := [ ] ;
7105: LD_ADDR_VAR 0 3
7109: PUSH
7110: EMPTY
7111: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
7112: LD_ADDR_VAR 0 1
7116: PUSH
7117: DOUBLE
7118: LD_INT 1
7120: DEC
7121: ST_TO_ADDR
7122: LD_INT 4
7124: PUSH
7125: LD_INT 6
7127: PUSH
7128: LD_INT 7
7130: PUSH
7131: LD_INT 8
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: LIST
7138: LIST
7139: PUSH
7140: LD_OWVAR 67
7144: ARRAY
7145: PUSH
7146: FOR_TO
7147: IFFALSE 7307
// begin uc_side := 8 ;
7149: LD_ADDR_OWVAR 20
7153: PUSH
7154: LD_INT 8
7156: ST_TO_ADDR
// uc_nation := 2 ;
7157: LD_ADDR_OWVAR 21
7161: PUSH
7162: LD_INT 2
7164: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
7165: LD_INT 13
7167: PUSH
7168: LD_INT 14
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: PUSH
7175: LD_INT 1
7177: PPUSH
7178: LD_INT 2
7180: PPUSH
7181: CALL_OW 12
7185: ARRAY
7186: PPUSH
7187: LD_INT 1
7189: PPUSH
7190: LD_INT 5
7192: PPUSH
7193: LD_INT 27
7195: PUSH
7196: LD_INT 28
7198: PUSH
7199: LD_INT 26
7201: PUSH
7202: LD_INT 25
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: LIST
7209: LIST
7210: PUSH
7211: LD_INT 1
7213: PPUSH
7214: LD_INT 4
7216: PPUSH
7217: CALL_OW 12
7221: ARRAY
7222: PPUSH
7223: LD_INT 88
7225: PPUSH
7226: CALL 75959 0 5
// un := CreateVehicle ;
7230: LD_ADDR_VAR 0 2
7234: PUSH
7235: CALL_OW 45
7239: ST_TO_ADDR
// tmp := tmp ^ un ;
7240: LD_ADDR_VAR 0 3
7244: PUSH
7245: LD_VAR 0 3
7249: PUSH
7250: LD_VAR 0 2
7254: ADD
7255: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7256: LD_VAR 0 2
7260: PPUSH
7261: LD_INT 3
7263: PPUSH
7264: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7268: LD_VAR 0 2
7272: PPUSH
7273: LD_INT 30
7275: PPUSH
7276: LD_INT 0
7278: PPUSH
7279: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7283: LD_VAR 0 2
7287: PPUSH
7288: LD_INT 16
7290: PPUSH
7291: LD_INT 11
7293: PPUSH
7294: CALL_OW 111
// wait ( 0 0$2 ) ;
7298: LD_INT 70
7300: PPUSH
7301: CALL_OW 67
// end ;
7305: GO 7146
7307: POP
7308: POP
// for i = 1 to Difficulty do
7309: LD_ADDR_VAR 0 1
7313: PUSH
7314: DOUBLE
7315: LD_INT 1
7317: DEC
7318: ST_TO_ADDR
7319: LD_OWVAR 67
7323: PUSH
7324: FOR_TO
7325: IFFALSE 7454
// begin uc_side := 8 ;
7327: LD_ADDR_OWVAR 20
7331: PUSH
7332: LD_INT 8
7334: ST_TO_ADDR
// uc_nation := 2 ;
7335: LD_ADDR_OWVAR 21
7339: PUSH
7340: LD_INT 2
7342: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
7343: LD_INT 0
7345: PPUSH
7346: LD_INT 8
7348: PPUSH
7349: LD_INT 8
7351: PUSH
7352: LD_INT 8
7354: PUSH
7355: LD_INT 9
7357: PUSH
7358: LD_INT 10
7360: PUSH
7361: EMPTY
7362: LIST
7363: LIST
7364: LIST
7365: LIST
7366: PUSH
7367: LD_OWVAR 67
7371: ARRAY
7372: PPUSH
7373: CALL_OW 380
// un := CreateHuman ;
7377: LD_ADDR_VAR 0 2
7381: PUSH
7382: CALL_OW 44
7386: ST_TO_ADDR
// tmp := tmp ^ un ;
7387: LD_ADDR_VAR 0 3
7391: PUSH
7392: LD_VAR 0 3
7396: PUSH
7397: LD_VAR 0 2
7401: ADD
7402: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7403: LD_VAR 0 2
7407: PPUSH
7408: LD_INT 3
7410: PPUSH
7411: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7415: LD_VAR 0 2
7419: PPUSH
7420: LD_INT 30
7422: PPUSH
7423: LD_INT 0
7425: PPUSH
7426: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7430: LD_VAR 0 2
7434: PPUSH
7435: LD_INT 16
7437: PPUSH
7438: LD_INT 11
7440: PPUSH
7441: CALL_OW 111
// wait ( 0 0$2 ) ;
7445: LD_INT 70
7447: PPUSH
7448: CALL_OW 67
// end ;
7452: GO 7324
7454: POP
7455: POP
// repeat wait ( 0 0$1 ) ;
7456: LD_INT 35
7458: PPUSH
7459: CALL_OW 67
// if legionDestroyed then
7463: LD_EXP 22
7467: IFFALSE 7471
// exit ;
7469: GO 7627
// for i in tmp do
7471: LD_ADDR_VAR 0 1
7475: PUSH
7476: LD_VAR 0 3
7480: PUSH
7481: FOR_IN
7482: IFFALSE 7618
// begin if GetLives ( i ) > 250 then
7484: LD_VAR 0 1
7488: PPUSH
7489: CALL_OW 256
7493: PUSH
7494: LD_INT 250
7496: GREATER
7497: IFFALSE 7589
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7499: LD_INT 81
7501: PUSH
7502: LD_INT 8
7504: PUSH
7505: EMPTY
7506: LIST
7507: LIST
7508: PUSH
7509: LD_INT 91
7511: PUSH
7512: LD_VAR 0 1
7516: PUSH
7517: LD_INT 10
7519: PUSH
7520: EMPTY
7521: LIST
7522: LIST
7523: LIST
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: PPUSH
7529: CALL_OW 69
7533: NOT
7534: IFFALSE 7553
// ComAgressiveMove ( i , 67 , 110 ) else
7536: LD_VAR 0 1
7540: PPUSH
7541: LD_INT 67
7543: PPUSH
7544: LD_INT 110
7546: PPUSH
7547: CALL_OW 114
7551: GO 7587
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7553: LD_VAR 0 1
7557: PPUSH
7558: LD_INT 81
7560: PUSH
7561: LD_INT 8
7563: PUSH
7564: EMPTY
7565: LIST
7566: LIST
7567: PPUSH
7568: CALL_OW 69
7572: PPUSH
7573: LD_VAR 0 1
7577: PPUSH
7578: CALL_OW 74
7582: PPUSH
7583: CALL_OW 115
// end else
7587: GO 7616
// if IsDead ( i ) then
7589: LD_VAR 0 1
7593: PPUSH
7594: CALL_OW 301
7598: IFFALSE 7616
// tmp := tmp diff i ;
7600: LD_ADDR_VAR 0 3
7604: PUSH
7605: LD_VAR 0 3
7609: PUSH
7610: LD_VAR 0 1
7614: DIFF
7615: ST_TO_ADDR
// end ;
7616: GO 7481
7618: POP
7619: POP
// until not tmp ;
7620: LD_VAR 0 3
7624: NOT
7625: IFFALSE 7456
// end ; end_of_file
7627: PPOPN 3
7629: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7630: LD_INT 0
7632: PPUSH
7633: PPUSH
7634: PPUSH
7635: PPUSH
7636: PPUSH
7637: PPUSH
7638: PPUSH
7639: PPUSH
7640: PPUSH
7641: PPUSH
// side := 3 ;
7642: LD_ADDR_VAR 0 6
7646: PUSH
7647: LD_INT 3
7649: ST_TO_ADDR
// uc_side := side ;
7650: LD_ADDR_OWVAR 20
7654: PUSH
7655: LD_VAR 0 6
7659: ST_TO_ADDR
// uc_nation := 3 ;
7660: LD_ADDR_OWVAR 21
7664: PUSH
7665: LD_INT 3
7667: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7668: LD_ADDR_VAR 0 2
7672: PUSH
7673: LD_INT 22
7675: PUSH
7676: LD_VAR 0 6
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: LD_INT 21
7687: PUSH
7688: LD_INT 3
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: PUSH
7695: EMPTY
7696: LIST
7697: LIST
7698: PPUSH
7699: CALL_OW 69
7703: PUSH
7704: FOR_IN
7705: IFFALSE 7721
// SetBLevel ( i , 10 ) ;
7707: LD_VAR 0 2
7711: PPUSH
7712: LD_INT 10
7714: PPUSH
7715: CALL_OW 241
7719: GO 7704
7721: POP
7722: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7723: LD_ADDR_VAR 0 10
7727: PUSH
7728: LD_INT 22
7730: PUSH
7731: LD_VAR 0 6
7735: PUSH
7736: EMPTY
7737: LIST
7738: LIST
7739: PUSH
7740: LD_INT 30
7742: PUSH
7743: LD_INT 34
7745: PUSH
7746: EMPTY
7747: LIST
7748: LIST
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: PPUSH
7754: CALL_OW 69
7758: ST_TO_ADDR
// if teleport then
7759: LD_VAR 0 10
7763: IFFALSE 7784
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7765: LD_VAR 0 10
7769: PUSH
7770: LD_INT 1
7772: ARRAY
7773: PPUSH
7774: LD_INT 123
7776: PPUSH
7777: LD_INT 122
7779: PPUSH
7780: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7784: LD_ADDR_EXP 68
7788: PUSH
7789: LD_STRING Platonov
7791: PPUSH
7792: CALL_OW 25
7796: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7797: LD_ADDR_EXP 69
7801: PUSH
7802: LD_STRING Kovalyuk
7804: PPUSH
7805: CALL_OW 25
7809: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7810: LD_ADDR_EXP 71
7814: PUSH
7815: LD_STRING Yakotich
7817: PPUSH
7818: LD_EXP 1
7822: NOT
7823: PPUSH
7824: LD_STRING 09_
7826: PPUSH
7827: CALL 70939 0 3
7831: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7832: LD_ADDR_EXP 70
7836: PUSH
7837: LD_STRING Bystrov
7839: PPUSH
7840: CALL_OW 25
7844: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7845: LD_ADDR_EXP 72
7849: PUSH
7850: LD_STRING Gleb
7852: PPUSH
7853: CALL_OW 25
7857: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7858: LD_STRING 03_Cornel
7860: PPUSH
7861: CALL_OW 28
7865: IFFALSE 7913
// begin Bierezov := NewCharacter ( Mikhail ) ;
7867: LD_ADDR_EXP 73
7871: PUSH
7872: LD_STRING Mikhail
7874: PPUSH
7875: CALL_OW 25
7879: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7880: LD_EXP 73
7884: PPUSH
7885: LD_INT 197
7887: PPUSH
7888: LD_INT 111
7890: PPUSH
7891: LD_INT 9
7893: PPUSH
7894: LD_INT 0
7896: PPUSH
7897: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7901: LD_EXP 73
7905: PPUSH
7906: LD_INT 3
7908: PPUSH
7909: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7913: LD_EXP 68
7917: PPUSH
7918: LD_INT 126
7920: PPUSH
7921: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7925: LD_EXP 69
7929: PPUSH
7930: LD_INT 134
7932: PPUSH
7933: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7937: LD_EXP 71
7941: PPUSH
7942: LD_INT 197
7944: PPUSH
7945: LD_INT 111
7947: PPUSH
7948: LD_INT 9
7950: PPUSH
7951: LD_INT 0
7953: PPUSH
7954: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7958: LD_EXP 70
7962: PPUSH
7963: LD_INT 197
7965: PPUSH
7966: LD_INT 111
7968: PPUSH
7969: LD_INT 9
7971: PPUSH
7972: LD_INT 0
7974: PPUSH
7975: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7979: LD_EXP 72
7983: PPUSH
7984: LD_INT 197
7986: PPUSH
7987: LD_INT 111
7989: PPUSH
7990: LD_INT 9
7992: PPUSH
7993: LD_INT 0
7995: PPUSH
7996: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 12 , 6 ] ) ;
8000: LD_ADDR_VAR 0 5
8004: PUSH
8005: LD_INT 126
8007: PPUSH
8008: LD_INT 4
8010: PPUSH
8011: LD_STRING zhukov
8013: PPUSH
8014: LD_INT 9
8016: PUSH
8017: LD_INT 10
8019: PUSH
8020: LD_INT 10
8022: PUSH
8023: LD_INT 10
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: LIST
8030: LIST
8031: PUSH
8032: LD_OWVAR 67
8036: ARRAY
8037: PPUSH
8038: LD_INT 90000
8040: PUSH
8041: LD_INT 1000
8043: PUSH
8044: LD_INT 300
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: LIST
8051: PPUSH
8052: LD_INT 18
8054: PUSH
8055: LD_INT 8
8057: PUSH
8058: LD_INT 12
8060: PUSH
8061: LD_INT 6
8063: PUSH
8064: EMPTY
8065: LIST
8066: LIST
8067: LIST
8068: LIST
8069: PPUSH
8070: CALL 79796 0 6
8074: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
8075: LD_ADDR_EXP 102
8079: PUSH
8080: LD_EXP 102
8084: PPUSH
8085: LD_INT 2
8087: PPUSH
8088: LD_VAR 0 5
8092: PUSH
8093: LD_EXP 71
8097: PUSH
8098: LD_EXP 70
8102: PUSH
8103: LD_EXP 72
8107: PUSH
8108: LD_EXP 73
8112: PUSH
8113: EMPTY
8114: LIST
8115: LIST
8116: LIST
8117: LIST
8118: UNION
8119: PPUSH
8120: CALL_OW 1
8124: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
8125: LD_ADDR_VAR 0 4
8129: PUSH
8130: LD_INT 267
8132: PPUSH
8133: CALL_OW 274
8137: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
8138: LD_VAR 0 4
8142: PPUSH
8143: LD_INT 1
8145: PPUSH
8146: LD_INT 5000
8148: PPUSH
8149: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
8153: LD_VAR 0 4
8157: PPUSH
8158: LD_INT 2
8160: PPUSH
8161: LD_INT 200
8163: PPUSH
8164: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
8168: LD_VAR 0 4
8172: PPUSH
8173: LD_INT 3
8175: PPUSH
8176: LD_INT 200
8178: PPUSH
8179: CALL_OW 277
// for i := 1 to 6 do
8183: LD_ADDR_VAR 0 2
8187: PUSH
8188: DOUBLE
8189: LD_INT 1
8191: DEC
8192: ST_TO_ADDR
8193: LD_INT 6
8195: PUSH
8196: FOR_TO
8197: IFFALSE 8280
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
8199: LD_INT 0
8201: PPUSH
8202: LD_INT 8
8204: PUSH
8205: LD_INT 9
8207: PUSH
8208: LD_INT 10
8210: PUSH
8211: LD_INT 10
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: PUSH
8220: LD_OWVAR 67
8224: ARRAY
8225: PPUSH
8226: CALL_OW 381
// un := CreateHuman ;
8230: LD_ADDR_VAR 0 8
8234: PUSH
8235: CALL_OW 44
8239: ST_TO_ADDR
// if i mod 2 = 0 then
8240: LD_VAR 0 2
8244: PUSH
8245: LD_INT 2
8247: MOD
8248: PUSH
8249: LD_INT 0
8251: EQUAL
8252: IFFALSE 8266
// SetClass ( un , class_bazooker ) ;
8254: LD_VAR 0 8
8258: PPUSH
8259: LD_INT 9
8261: PPUSH
8262: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
8266: LD_VAR 0 8
8270: PPUSH
8271: LD_INT 460
8273: PPUSH
8274: CALL_OW 52
// end ;
8278: GO 8196
8280: POP
8281: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
8282: LD_INT 21
8284: PPUSH
8285: LD_INT 3
8287: PPUSH
8288: LD_INT 3
8290: PPUSH
8291: LD_INT 52
8293: PPUSH
8294: LD_INT 100
8296: PPUSH
8297: CALL 75959 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
8301: CALL_OW 45
8305: PPUSH
8306: LD_INT 259
8308: PPUSH
8309: LD_INT 145
8311: PPUSH
8312: LD_INT 3
8314: PPUSH
8315: LD_INT 0
8317: PPUSH
8318: CALL 111299 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
8322: CALL_OW 45
8326: PPUSH
8327: LD_INT 245
8329: PPUSH
8330: LD_INT 139
8332: PPUSH
8333: LD_INT 3
8335: PPUSH
8336: LD_INT 0
8338: PPUSH
8339: CALL 111299 0 5
// behemoths := [ ] ;
8343: LD_ADDR_EXP 76
8347: PUSH
8348: EMPTY
8349: ST_TO_ADDR
// behemothBuilders := [ ] ;
8350: LD_ADDR_EXP 77
8354: PUSH
8355: EMPTY
8356: ST_TO_ADDR
// if Kovalyuk then
8357: LD_EXP 69
8361: IFFALSE 8383
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
8363: LD_ADDR_EXP 77
8367: PUSH
8368: LD_EXP 77
8372: PPUSH
8373: LD_EXP 69
8377: PPUSH
8378: CALL 109139 0 2
8382: ST_TO_ADDR
// end ;
8383: LD_VAR 0 1
8387: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8388: LD_INT 0
8390: PPUSH
8391: PPUSH
8392: PPUSH
8393: PPUSH
8394: PPUSH
// xy := [ [ 221 , 154 ] , [ 223 , 149 ] , [ 228 , 147 ] , [ 232 , 155 ] ] ;
8395: LD_ADDR_VAR 0 4
8399: PUSH
8400: LD_INT 221
8402: PUSH
8403: LD_INT 154
8405: PUSH
8406: EMPTY
8407: LIST
8408: LIST
8409: PUSH
8410: LD_INT 223
8412: PUSH
8413: LD_INT 149
8415: PUSH
8416: EMPTY
8417: LIST
8418: LIST
8419: PUSH
8420: LD_INT 228
8422: PUSH
8423: LD_INT 147
8425: PUSH
8426: EMPTY
8427: LIST
8428: LIST
8429: PUSH
8430: LD_INT 232
8432: PUSH
8433: LD_INT 155
8435: PUSH
8436: EMPTY
8437: LIST
8438: LIST
8439: PUSH
8440: EMPTY
8441: LIST
8442: LIST
8443: LIST
8444: LIST
8445: ST_TO_ADDR
// if not behemothBuilders then
8446: LD_EXP 77
8450: NOT
8451: IFFALSE 8455
// exit ;
8453: GO 8586
// j := 1 ;
8455: LD_ADDR_VAR 0 3
8459: PUSH
8460: LD_INT 1
8462: ST_TO_ADDR
// for i in behemothBuilders do
8463: LD_ADDR_VAR 0 2
8467: PUSH
8468: LD_EXP 77
8472: PUSH
8473: FOR_IN
8474: IFFALSE 8584
// begin if GetClass ( i ) <> class_mechanic then
8476: LD_VAR 0 2
8480: PPUSH
8481: CALL_OW 257
8485: PUSH
8486: LD_INT 3
8488: NONEQUAL
8489: IFFALSE 8503
// SetClass ( i , class_mechanic ) ;
8491: LD_VAR 0 2
8495: PPUSH
8496: LD_INT 3
8498: PPUSH
8499: CALL_OW 336
// if IsInUnit ( i ) then
8503: LD_VAR 0 2
8507: PPUSH
8508: CALL_OW 310
8512: IFFALSE 8523
// ComExitBuilding ( i ) ;
8514: LD_VAR 0 2
8518: PPUSH
8519: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8523: LD_VAR 0 2
8527: PPUSH
8528: LD_INT 37
8530: PPUSH
8531: LD_VAR 0 4
8535: PUSH
8536: LD_VAR 0 3
8540: ARRAY
8541: PUSH
8542: LD_INT 1
8544: ARRAY
8545: PPUSH
8546: LD_VAR 0 4
8550: PUSH
8551: LD_VAR 0 3
8555: ARRAY
8556: PUSH
8557: LD_INT 2
8559: ARRAY
8560: PPUSH
8561: LD_INT 0
8563: PPUSH
8564: CALL_OW 230
// j := j + 1 ;
8568: LD_ADDR_VAR 0 3
8572: PUSH
8573: LD_VAR 0 3
8577: PUSH
8578: LD_INT 1
8580: PLUS
8581: ST_TO_ADDR
// end ;
8582: GO 8473
8584: POP
8585: POP
// end ;
8586: LD_VAR 0 1
8590: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8591: LD_INT 24
8593: PPUSH
8594: LD_INT 30
8596: PUSH
8597: LD_INT 37
8599: PUSH
8600: EMPTY
8601: LIST
8602: LIST
8603: PPUSH
8604: CALL_OW 70
8608: IFFALSE 8621
8610: GO 8612
8612: DISABLE
// behemothUnderConstruct := true ;
8613: LD_ADDR_EXP 26
8617: PUSH
8618: LD_INT 1
8620: ST_TO_ADDR
8621: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8622: LD_INT 3
8624: PPUSH
8625: CALL 109200 0 1
8629: IFFALSE 8662
8631: PUSH
8632: LD_INT 22
8634: PUSH
8635: LD_INT 3
8637: PUSH
8638: EMPTY
8639: LIST
8640: LIST
8641: PUSH
8642: LD_INT 30
8644: PUSH
8645: LD_INT 37
8647: PUSH
8648: EMPTY
8649: LIST
8650: LIST
8651: PUSH
8652: EMPTY
8653: LIST
8654: LIST
8655: PPUSH
8656: CALL_OW 69
8660: NOT
8661: AND
8662: IFFALSE 8852
8664: GO 8666
8666: DISABLE
8667: LD_INT 0
8669: PPUSH
8670: PPUSH
// begin enable ;
8671: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8672: LD_ADDR_VAR 0 2
8676: PUSH
8677: LD_INT 3
8679: PPUSH
8680: CALL 109200 0 1
8684: ST_TO_ADDR
// for i in tmp do
8685: LD_ADDR_VAR 0 1
8689: PUSH
8690: LD_VAR 0 2
8694: PUSH
8695: FOR_IN
8696: IFFALSE 8850
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8698: LD_VAR 0 1
8702: PPUSH
8703: LD_INT 9
8705: PPUSH
8706: CALL_OW 308
8710: IFFALSE 8728
8712: PUSH
8713: LD_VAR 0 1
8717: PPUSH
8718: CALL_OW 110
8722: PUSH
8723: LD_INT 2
8725: EQUAL
8726: NOT
8727: AND
8728: IFFALSE 8742
// SetTag ( i , 2 ) ;
8730: LD_VAR 0 1
8734: PPUSH
8735: LD_INT 2
8737: PPUSH
8738: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8742: LD_INT 81
8744: PUSH
8745: LD_INT 3
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PUSH
8752: LD_INT 91
8754: PUSH
8755: LD_VAR 0 1
8759: PUSH
8760: LD_INT 12
8762: PUSH
8763: EMPTY
8764: LIST
8765: LIST
8766: LIST
8767: PUSH
8768: EMPTY
8769: LIST
8770: LIST
8771: PPUSH
8772: CALL_OW 69
8776: NOT
8777: IFFALSE 8795
8779: PUSH
8780: LD_VAR 0 1
8784: PPUSH
8785: CALL_OW 110
8789: PUSH
8790: LD_INT 2
8792: EQUAL
8793: NOT
8794: AND
8795: IFFALSE 8814
// ComAgressiveMove ( i , 64 , 93 ) else
8797: LD_VAR 0 1
8801: PPUSH
8802: LD_INT 64
8804: PPUSH
8805: LD_INT 93
8807: PPUSH
8808: CALL_OW 114
8812: GO 8848
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8814: LD_VAR 0 1
8818: PPUSH
8819: LD_INT 81
8821: PUSH
8822: LD_INT 3
8824: PUSH
8825: EMPTY
8826: LIST
8827: LIST
8828: PPUSH
8829: CALL_OW 69
8833: PPUSH
8834: LD_VAR 0 1
8838: PPUSH
8839: CALL_OW 74
8843: PPUSH
8844: CALL_OW 115
// end ;
8848: GO 8695
8850: POP
8851: POP
// end ;
8852: PPOPN 2
8854: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8855: LD_INT 0
8857: PPUSH
8858: PPUSH
8859: PPUSH
// result := [ ] ;
8860: LD_ADDR_VAR 0 2
8864: PUSH
8865: EMPTY
8866: ST_TO_ADDR
// uc_side := 6 ;
8867: LD_ADDR_OWVAR 20
8871: PUSH
8872: LD_INT 6
8874: ST_TO_ADDR
// uc_nation := 3 ;
8875: LD_ADDR_OWVAR 21
8879: PUSH
8880: LD_INT 3
8882: ST_TO_ADDR
// case strength of 1 :
8883: LD_VAR 0 1
8887: PUSH
8888: LD_INT 1
8890: DOUBLE
8891: EQUAL
8892: IFTRUE 8896
8894: GO 9038
8896: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8897: LD_ADDR_VAR 0 3
8901: PUSH
8902: DOUBLE
8903: LD_INT 1
8905: DEC
8906: ST_TO_ADDR
8907: LD_INT 4
8909: PUSH
8910: LD_INT 5
8912: PUSH
8913: LD_INT 6
8915: PUSH
8916: LD_INT 7
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: LIST
8924: PUSH
8925: LD_OWVAR 67
8929: ARRAY
8930: PUSH
8931: FOR_TO
8932: IFFALSE 9034
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8934: LD_INT 22
8936: PUSH
8937: LD_INT 24
8939: PUSH
8940: EMPTY
8941: LIST
8942: LIST
8943: PUSH
8944: LD_VAR 0 3
8948: PUSH
8949: LD_INT 2
8951: MOD
8952: PUSH
8953: LD_INT 1
8955: PLUS
8956: ARRAY
8957: PPUSH
8958: LD_INT 1
8960: PUSH
8961: LD_INT 3
8963: PUSH
8964: EMPTY
8965: LIST
8966: LIST
8967: PUSH
8968: LD_INT 1
8970: PPUSH
8971: LD_INT 2
8973: PPUSH
8974: CALL_OW 12
8978: ARRAY
8979: PPUSH
8980: LD_INT 3
8982: PPUSH
8983: LD_INT 43
8985: PUSH
8986: LD_INT 44
8988: PUSH
8989: LD_INT 45
8991: PUSH
8992: EMPTY
8993: LIST
8994: LIST
8995: LIST
8996: PUSH
8997: LD_INT 1
8999: PPUSH
9000: LD_INT 3
9002: PPUSH
9003: CALL_OW 12
9007: ARRAY
9008: PPUSH
9009: LD_INT 80
9011: PPUSH
9012: CALL 75959 0 5
// result := result union CreateVehicle ;
9016: LD_ADDR_VAR 0 2
9020: PUSH
9021: LD_VAR 0 2
9025: PUSH
9026: CALL_OW 45
9030: UNION
9031: ST_TO_ADDR
// end ;
9032: GO 8931
9034: POP
9035: POP
// end ; 2 :
9036: GO 10033
9038: LD_INT 2
9040: DOUBLE
9041: EQUAL
9042: IFTRUE 9046
9044: GO 9214
9046: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
9047: LD_ADDR_VAR 0 3
9051: PUSH
9052: DOUBLE
9053: LD_INT 1
9055: DEC
9056: ST_TO_ADDR
9057: LD_INT 5
9059: PUSH
9060: LD_INT 6
9062: PUSH
9063: LD_INT 7
9065: PUSH
9066: LD_INT 8
9068: PUSH
9069: EMPTY
9070: LIST
9071: LIST
9072: LIST
9073: LIST
9074: PUSH
9075: LD_OWVAR 67
9079: ARRAY
9080: PUSH
9081: FOR_TO
9082: IFFALSE 9210
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
9084: LD_INT 22
9086: PUSH
9087: LD_INT 24
9089: PUSH
9090: LD_INT 24
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: LIST
9097: PUSH
9098: LD_VAR 0 3
9102: PUSH
9103: LD_INT 3
9105: MOD
9106: PUSH
9107: LD_INT 1
9109: PLUS
9110: ARRAY
9111: PPUSH
9112: LD_INT 1
9114: PUSH
9115: LD_INT 3
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: LD_INT 1
9124: PPUSH
9125: LD_INT 2
9127: PPUSH
9128: CALL_OW 12
9132: ARRAY
9133: PPUSH
9134: LD_INT 3
9136: PPUSH
9137: LD_INT 43
9139: PUSH
9140: LD_INT 44
9142: PUSH
9143: LD_INT 45
9145: PUSH
9146: LD_INT 44
9148: PUSH
9149: LD_INT 46
9151: PUSH
9152: LD_INT 46
9154: PUSH
9155: LD_INT 49
9157: PUSH
9158: LD_INT 49
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: PUSH
9171: LD_VAR 0 3
9175: PUSH
9176: LD_INT 8
9178: MOD
9179: PUSH
9180: LD_INT 1
9182: PLUS
9183: ARRAY
9184: PPUSH
9185: LD_INT 80
9187: PPUSH
9188: CALL 75959 0 5
// result := result union CreateVehicle ;
9192: LD_ADDR_VAR 0 2
9196: PUSH
9197: LD_VAR 0 2
9201: PUSH
9202: CALL_OW 45
9206: UNION
9207: ST_TO_ADDR
// end ;
9208: GO 9081
9210: POP
9211: POP
// end ; 3 :
9212: GO 10033
9214: LD_INT 3
9216: DOUBLE
9217: EQUAL
9218: IFTRUE 9222
9220: GO 9394
9222: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
9223: LD_ADDR_VAR 0 3
9227: PUSH
9228: DOUBLE
9229: LD_INT 1
9231: DEC
9232: ST_TO_ADDR
9233: LD_INT 6
9235: PUSH
9236: LD_INT 7
9238: PUSH
9239: LD_INT 8
9241: PUSH
9242: LD_INT 9
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: LIST
9249: LIST
9250: PUSH
9251: LD_OWVAR 67
9255: ARRAY
9256: PUSH
9257: FOR_TO
9258: IFFALSE 9390
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9260: LD_INT 22
9262: PUSH
9263: LD_INT 24
9265: PUSH
9266: LD_INT 24
9268: PUSH
9269: EMPTY
9270: LIST
9271: LIST
9272: LIST
9273: PUSH
9274: LD_VAR 0 3
9278: PUSH
9279: LD_INT 3
9281: MOD
9282: PUSH
9283: LD_INT 1
9285: PLUS
9286: ARRAY
9287: PPUSH
9288: LD_INT 1
9290: PUSH
9291: LD_INT 3
9293: PUSH
9294: EMPTY
9295: LIST
9296: LIST
9297: PUSH
9298: LD_INT 1
9300: PPUSH
9301: LD_INT 2
9303: PPUSH
9304: CALL_OW 12
9308: ARRAY
9309: PPUSH
9310: LD_INT 3
9312: PPUSH
9313: LD_INT 43
9315: PUSH
9316: LD_INT 47
9318: PUSH
9319: LD_INT 45
9321: PUSH
9322: LD_INT 45
9324: PUSH
9325: LD_INT 46
9327: PUSH
9328: LD_INT 46
9330: PUSH
9331: LD_INT 49
9333: PUSH
9334: LD_INT 49
9336: PUSH
9337: LD_INT 49
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: LIST
9347: LIST
9348: LIST
9349: LIST
9350: PUSH
9351: LD_VAR 0 3
9355: PUSH
9356: LD_INT 9
9358: MOD
9359: PUSH
9360: LD_INT 1
9362: PLUS
9363: ARRAY
9364: PPUSH
9365: LD_INT 80
9367: PPUSH
9368: CALL 75959 0 5
// result := result union CreateVehicle ;
9372: LD_ADDR_VAR 0 2
9376: PUSH
9377: LD_VAR 0 2
9381: PUSH
9382: CALL_OW 45
9386: UNION
9387: ST_TO_ADDR
// end ;
9388: GO 9257
9390: POP
9391: POP
// end ; 4 :
9392: GO 10033
9394: LD_INT 4
9396: DOUBLE
9397: EQUAL
9398: IFTRUE 9402
9400: GO 10032
9402: POP
// begin uc_nation := 3 ;
9403: LD_ADDR_OWVAR 21
9407: PUSH
9408: LD_INT 3
9410: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9411: LD_ADDR_VAR 0 3
9415: PUSH
9416: DOUBLE
9417: LD_INT 1
9419: DEC
9420: ST_TO_ADDR
9421: LD_INT 6
9423: PUSH
9424: LD_INT 8
9426: PUSH
9427: LD_INT 9
9429: PUSH
9430: LD_INT 10
9432: PUSH
9433: EMPTY
9434: LIST
9435: LIST
9436: LIST
9437: LIST
9438: PUSH
9439: LD_OWVAR 67
9443: ARRAY
9444: PUSH
9445: FOR_TO
9446: IFFALSE 9578
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9448: LD_INT 22
9450: PUSH
9451: LD_INT 24
9453: PUSH
9454: LD_INT 24
9456: PUSH
9457: EMPTY
9458: LIST
9459: LIST
9460: LIST
9461: PUSH
9462: LD_VAR 0 3
9466: PUSH
9467: LD_INT 3
9469: MOD
9470: PUSH
9471: LD_INT 1
9473: PLUS
9474: ARRAY
9475: PPUSH
9476: LD_INT 1
9478: PUSH
9479: LD_INT 3
9481: PUSH
9482: EMPTY
9483: LIST
9484: LIST
9485: PUSH
9486: LD_INT 1
9488: PPUSH
9489: LD_INT 2
9491: PPUSH
9492: CALL_OW 12
9496: ARRAY
9497: PPUSH
9498: LD_INT 3
9500: PPUSH
9501: LD_INT 45
9503: PUSH
9504: LD_INT 47
9506: PUSH
9507: LD_INT 47
9509: PUSH
9510: LD_INT 45
9512: PUSH
9513: LD_INT 46
9515: PUSH
9516: LD_INT 46
9518: PUSH
9519: LD_INT 49
9521: PUSH
9522: LD_INT 49
9524: PUSH
9525: LD_INT 49
9527: PUSH
9528: EMPTY
9529: LIST
9530: LIST
9531: LIST
9532: LIST
9533: LIST
9534: LIST
9535: LIST
9536: LIST
9537: LIST
9538: PUSH
9539: LD_VAR 0 3
9543: PUSH
9544: LD_INT 9
9546: MOD
9547: PUSH
9548: LD_INT 1
9550: PLUS
9551: ARRAY
9552: PPUSH
9553: LD_INT 80
9555: PPUSH
9556: CALL 75959 0 5
// result := result union CreateVehicle ;
9560: LD_ADDR_VAR 0 2
9564: PUSH
9565: LD_VAR 0 2
9569: PUSH
9570: CALL_OW 45
9574: UNION
9575: ST_TO_ADDR
// end ;
9576: GO 9445
9578: POP
9579: POP
// if not KappaStatus then
9580: LD_EXP 2
9584: NOT
9585: IFFALSE 9820
// begin uc_nation := 1 ;
9587: LD_ADDR_OWVAR 21
9591: PUSH
9592: LD_INT 1
9594: ST_TO_ADDR
// for i = 1 to 3 do
9595: LD_ADDR_VAR 0 3
9599: PUSH
9600: DOUBLE
9601: LD_INT 1
9603: DEC
9604: ST_TO_ADDR
9605: LD_INT 3
9607: PUSH
9608: FOR_TO
9609: IFFALSE 9745
// begin j := rand ( 0 , 1 ) ;
9611: LD_ADDR_VAR 0 4
9615: PUSH
9616: LD_INT 0
9618: PPUSH
9619: LD_INT 1
9621: PPUSH
9622: CALL_OW 12
9626: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9627: LD_INT 3
9629: PUSH
9630: LD_INT 5
9632: PUSH
9633: LD_INT 5
9635: PUSH
9636: LD_INT 4
9638: PUSH
9639: EMPTY
9640: LIST
9641: LIST
9642: LIST
9643: LIST
9644: PUSH
9645: LD_VAR 0 4
9649: PUSH
9650: LD_INT 1
9652: PPUSH
9653: LD_INT 3
9655: PPUSH
9656: CALL_OW 12
9660: PLUS
9661: ARRAY
9662: PPUSH
9663: LD_INT 1
9665: PUSH
9666: LD_INT 3
9668: PUSH
9669: EMPTY
9670: LIST
9671: LIST
9672: PUSH
9673: LD_INT 1
9675: PPUSH
9676: LD_INT 2
9678: PPUSH
9679: CALL_OW 12
9683: ARRAY
9684: PPUSH
9685: LD_INT 3
9687: PPUSH
9688: LD_INT 9
9690: PUSH
9691: LD_INT 7
9693: PUSH
9694: LD_INT 6
9696: PUSH
9697: EMPTY
9698: LIST
9699: LIST
9700: LIST
9701: PUSH
9702: LD_VAR 0 4
9706: PUSH
9707: LD_INT 1
9709: PPUSH
9710: LD_INT 2
9712: PPUSH
9713: CALL_OW 12
9717: PLUS
9718: ARRAY
9719: PPUSH
9720: LD_INT 85
9722: PPUSH
9723: CALL 75959 0 5
// result := result union CreateVehicle ;
9727: LD_ADDR_VAR 0 2
9731: PUSH
9732: LD_VAR 0 2
9736: PUSH
9737: CALL_OW 45
9741: UNION
9742: ST_TO_ADDR
// end ;
9743: GO 9608
9745: POP
9746: POP
// if vsevolodFirstAttack then
9747: LD_EXP 24
9751: IFFALSE 9818
// begin vsevolodFirstAttack := false ;
9753: LD_ADDR_EXP 24
9757: PUSH
9758: LD_INT 0
9760: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9761: LD_INT 5
9763: PPUSH
9764: LD_INT 3
9766: PPUSH
9767: LD_INT 1
9769: PPUSH
9770: LD_INT 6
9772: PPUSH
9773: LD_INT 100
9775: PPUSH
9776: CALL 75959 0 5
// sewiVeh := CreateVehicle ;
9780: LD_ADDR_EXP 75
9784: PUSH
9785: CALL_OW 45
9789: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9790: LD_EXP 75
9794: PPUSH
9795: LD_INT 1
9797: PPUSH
9798: CALL_OW 242
// result := result union sewiVeh ;
9802: LD_ADDR_VAR 0 2
9806: PUSH
9807: LD_VAR 0 2
9811: PUSH
9812: LD_EXP 75
9816: UNION
9817: ST_TO_ADDR
// end ; end else
9818: GO 10030
// if vsevolodFirstAttack then
9820: LD_EXP 24
9824: IFFALSE 10030
// begin vsevolodFirstAttack := false ;
9826: LD_ADDR_EXP 24
9830: PUSH
9831: LD_INT 0
9833: ST_TO_ADDR
// uc_nation := 3 ;
9834: LD_ADDR_OWVAR 21
9838: PUSH
9839: LD_INT 3
9841: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9842: LD_ADDR_VAR 0 3
9846: PUSH
9847: DOUBLE
9848: LD_INT 1
9850: DEC
9851: ST_TO_ADDR
9852: LD_INT 2
9854: PUSH
9855: LD_OWVAR 67
9859: PLUS
9860: PUSH
9861: FOR_TO
9862: IFFALSE 9970
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9864: LD_INT 22
9866: PUSH
9867: LD_INT 24
9869: PUSH
9870: LD_INT 24
9872: PUSH
9873: EMPTY
9874: LIST
9875: LIST
9876: LIST
9877: PUSH
9878: LD_VAR 0 3
9882: PUSH
9883: LD_INT 3
9885: MOD
9886: PUSH
9887: LD_INT 1
9889: PLUS
9890: ARRAY
9891: PPUSH
9892: LD_INT 1
9894: PUSH
9895: LD_INT 3
9897: PUSH
9898: EMPTY
9899: LIST
9900: LIST
9901: PUSH
9902: LD_INT 1
9904: PPUSH
9905: LD_INT 2
9907: PPUSH
9908: CALL_OW 12
9912: ARRAY
9913: PPUSH
9914: LD_INT 1
9916: PPUSH
9917: LD_INT 45
9919: PUSH
9920: LD_INT 47
9922: PUSH
9923: LD_INT 47
9925: PUSH
9926: EMPTY
9927: LIST
9928: LIST
9929: LIST
9930: PUSH
9931: LD_VAR 0 3
9935: PUSH
9936: LD_INT 3
9938: MOD
9939: PUSH
9940: LD_INT 1
9942: PLUS
9943: ARRAY
9944: PPUSH
9945: LD_INT 80
9947: PPUSH
9948: CALL 75959 0 5
// result := result union CreateVehicle ;
9952: LD_ADDR_VAR 0 2
9956: PUSH
9957: LD_VAR 0 2
9961: PUSH
9962: CALL_OW 45
9966: UNION
9967: ST_TO_ADDR
// end ;
9968: GO 9861
9970: POP
9971: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9972: LD_INT 24
9974: PPUSH
9975: LD_INT 3
9977: PPUSH
9978: LD_INT 1
9980: PPUSH
9981: LD_INT 47
9983: PPUSH
9984: LD_INT 100
9986: PPUSH
9987: CALL 75959 0 5
// sewiVeh := CreateVehicle ;
9991: LD_ADDR_EXP 75
9995: PUSH
9996: CALL_OW 45
10000: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
10001: LD_EXP 75
10005: PPUSH
10006: LD_INT 6
10008: NEG
10009: PPUSH
10010: CALL_OW 242
// result := result union sewiVeh ;
10014: LD_ADDR_VAR 0 2
10018: PUSH
10019: LD_VAR 0 2
10023: PUSH
10024: LD_EXP 75
10028: UNION
10029: ST_TO_ADDR
// end ; end ; end ;
10030: GO 10033
10032: POP
// end ;
10033: LD_VAR 0 2
10037: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
10038: LD_EXP 16
10042: IFFALSE 10803
10044: GO 10046
10046: DISABLE
10047: LD_INT 0
10049: PPUSH
10050: PPUSH
10051: PPUSH
10052: PPUSH
10053: PPUSH
10054: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
10055: LD_ADDR_VAR 0 4
10059: PUSH
10060: LD_INT 11
10062: PUSH
10063: LD_INT 12
10065: PUSH
10066: EMPTY
10067: LIST
10068: LIST
10069: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
10070: LD_ADDR_VAR 0 3
10074: PUSH
10075: LD_INT 11550
10077: PUSH
10078: LD_INT 10150
10080: PUSH
10081: LD_INT 9800
10083: PUSH
10084: LD_INT 9450
10086: PUSH
10087: EMPTY
10088: LIST
10089: LIST
10090: LIST
10091: LIST
10092: PUSH
10093: LD_OWVAR 67
10097: ARRAY
10098: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
10099: LD_ADDR_VAR 0 6
10103: PUSH
10104: LD_INT 70
10106: PUSH
10107: LD_INT 118
10109: PUSH
10110: EMPTY
10111: LIST
10112: LIST
10113: PUSH
10114: LD_INT 78
10116: PUSH
10117: LD_INT 31
10119: PUSH
10120: EMPTY
10121: LIST
10122: LIST
10123: PUSH
10124: EMPTY
10125: LIST
10126: LIST
10127: ST_TO_ADDR
// repeat if missionStage = 2 then
10128: LD_EXP 15
10132: PUSH
10133: LD_INT 2
10135: EQUAL
10136: IFFALSE 10147
// wait ( 1 1$30 ) else
10138: LD_INT 3150
10140: PPUSH
10141: CALL_OW 67
10145: GO 10156
// wait ( time ) ;
10147: LD_VAR 0 3
10151: PPUSH
10152: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
10156: LD_EXP 15
10160: PUSH
10161: LD_INT 6
10163: EQUAL
10164: IFTRUE 10176
10166: PUSH
10167: LD_OWVAR 67
10171: PUSH
10172: LD_INT 2
10174: GREATER
10175: OR
10176: IFFALSE 10204
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
10178: LD_INT 51
10180: PPUSH
10181: LD_INT 6
10183: PPUSH
10184: LD_INT 2
10186: PPUSH
10187: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
10191: LD_INT 57
10193: PPUSH
10194: LD_INT 6
10196: PPUSH
10197: LD_INT 2
10199: PPUSH
10200: CALL_OW 322
// end ; if missionStage = 8 then
10204: LD_EXP 15
10208: PUSH
10209: LD_INT 8
10211: EQUAL
10212: IFFALSE 10240
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
10214: LD_INT 52
10216: PPUSH
10217: LD_INT 6
10219: PPUSH
10220: LD_INT 2
10222: PPUSH
10223: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
10227: LD_INT 58
10229: PPUSH
10230: LD_INT 6
10232: PPUSH
10233: LD_INT 2
10235: PPUSH
10236: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
10240: LD_OWVAR 67
10244: PUSH
10245: LD_INT 4
10247: EQUAL
10248: IFTRUE 10260
10250: PUSH
10251: LD_EXP 15
10255: PUSH
10256: LD_INT 10
10258: EQUAL
10259: OR
10260: IFFALSE 10288
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
10262: LD_INT 53
10264: PPUSH
10265: LD_INT 6
10267: PPUSH
10268: LD_INT 2
10270: PPUSH
10271: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
10275: LD_INT 59
10277: PPUSH
10278: LD_INT 6
10280: PPUSH
10281: LD_INT 2
10283: PPUSH
10284: CALL_OW 322
// end ; if activeAttacks then
10288: LD_EXP 16
10292: IFFALSE 10797
// begin if missionStage = 2 then
10294: LD_EXP 15
10298: PUSH
10299: LD_INT 2
10301: EQUAL
10302: IFFALSE 10312
// strength := 1 ;
10304: LD_ADDR_VAR 0 5
10308: PUSH
10309: LD_INT 1
10311: ST_TO_ADDR
// if missionStage > 2 then
10312: LD_EXP 15
10316: PUSH
10317: LD_INT 2
10319: GREATER
10320: IFFALSE 10330
// strength := 2 ;
10322: LD_ADDR_VAR 0 5
10326: PUSH
10327: LD_INT 2
10329: ST_TO_ADDR
// if missionStage > 6 then
10330: LD_EXP 15
10334: PUSH
10335: LD_INT 6
10337: GREATER
10338: IFFALSE 10348
// strength := 3 ;
10340: LD_ADDR_VAR 0 5
10344: PUSH
10345: LD_INT 3
10347: ST_TO_ADDR
// if missionStage > 10 then
10348: LD_EXP 15
10352: PUSH
10353: LD_INT 10
10355: GREATER
10356: IFFALSE 10366
// strength := 4 ;
10358: LD_ADDR_VAR 0 5
10362: PUSH
10363: LD_INT 4
10365: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10366: LD_ADDR_VAR 0 2
10370: PUSH
10371: LD_VAR 0 5
10375: PPUSH
10376: CALL 8855 0 1
10380: ST_TO_ADDR
// for i in tmp do
10381: LD_ADDR_VAR 0 1
10385: PUSH
10386: LD_VAR 0 2
10390: PUSH
10391: FOR_IN
10392: IFFALSE 10666
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10394: LD_VAR 0 1
10398: PPUSH
10399: LD_VAR 0 4
10403: PUSH
10404: LD_INT 1
10406: PPUSH
10407: LD_INT 2
10409: PPUSH
10410: CALL_OW 12
10414: ARRAY
10415: PPUSH
10416: LD_INT 0
10418: PPUSH
10419: CALL_OW 49
// if i = sewiVeh then
10423: LD_VAR 0 1
10427: PUSH
10428: LD_EXP 75
10432: EQUAL
10433: IFFALSE 10486
// begin uc_side := 6 ;
10435: LD_ADDR_OWVAR 20
10439: PUSH
10440: LD_INT 6
10442: ST_TO_ADDR
// uc_nation := nation_russian ;
10443: LD_ADDR_OWVAR 21
10447: PUSH
10448: LD_INT 3
10450: ST_TO_ADDR
// Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10451: LD_ADDR_EXP 74
10455: PUSH
10456: LD_STRING Vsevolod
10458: PPUSH
10459: LD_INT 0
10461: PPUSH
10462: LD_STRING 
10464: PPUSH
10465: CALL 70939 0 3
10469: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10470: LD_EXP 74
10474: PPUSH
10475: LD_VAR 0 1
10479: PPUSH
10480: CALL_OW 52
// end else
10484: GO 10567
// if GetControl ( i ) = control_manual then
10486: LD_VAR 0 1
10490: PPUSH
10491: CALL_OW 263
10495: PUSH
10496: LD_INT 1
10498: EQUAL
10499: IFFALSE 10567
// begin uc_side := 6 ;
10501: LD_ADDR_OWVAR 20
10505: PUSH
10506: LD_INT 6
10508: ST_TO_ADDR
// uc_nation := 3 ;
10509: LD_ADDR_OWVAR 21
10513: PUSH
10514: LD_INT 3
10516: ST_TO_ADDR
// hc_gallery :=  ;
10517: LD_ADDR_OWVAR 33
10521: PUSH
10522: LD_STRING 
10524: ST_TO_ADDR
// hc_name :=  ;
10525: LD_ADDR_OWVAR 26
10529: PUSH
10530: LD_STRING 
10532: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10533: LD_INT 0
10535: PPUSH
10536: LD_INT 3
10538: PPUSH
10539: LD_INT 10
10541: PPUSH
10542: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10546: CALL_OW 44
10550: PPUSH
10551: LD_VAR 0 1
10555: PPUSH
10556: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10560: LD_INT 10
10562: PPUSH
10563: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10567: LD_INT 1
10569: PPUSH
10570: LD_INT 3
10572: PPUSH
10573: CALL_OW 12
10577: PUSH
10578: LD_INT 1
10580: DOUBLE
10581: EQUAL
10582: IFTRUE 10586
10584: GO 10604
10586: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10587: LD_VAR 0 1
10591: PPUSH
10592: LD_INT 111
10594: PPUSH
10595: LD_INT 197
10597: PPUSH
10598: CALL_OW 111
10602: GO 10657
10604: LD_INT 2
10606: DOUBLE
10607: EQUAL
10608: IFTRUE 10612
10610: GO 10630
10612: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10613: LD_VAR 0 1
10617: PPUSH
10618: LD_INT 91
10620: PPUSH
10621: LD_INT 165
10623: PPUSH
10624: CALL_OW 111
10628: GO 10657
10630: LD_INT 3
10632: DOUBLE
10633: EQUAL
10634: IFTRUE 10638
10636: GO 10656
10638: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10639: LD_VAR 0 1
10643: PPUSH
10644: LD_INT 137
10646: PPUSH
10647: LD_INT 157
10649: PPUSH
10650: CALL_OW 111
10654: GO 10657
10656: POP
// wait ( 0 0$2 ) ;
10657: LD_INT 70
10659: PPUSH
10660: CALL_OW 67
// end ;
10664: GO 10391
10666: POP
10667: POP
// repeat wait ( 0 0$1 ) ;
10668: LD_INT 35
10670: PPUSH
10671: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10675: LD_ADDR_VAR 0 1
10679: PUSH
10680: LD_VAR 0 2
10684: PPUSH
10685: LD_INT 50
10687: PUSH
10688: EMPTY
10689: LIST
10690: PPUSH
10691: CALL_OW 72
10695: PUSH
10696: FOR_IN
10697: IFFALSE 10756
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10699: LD_VAR 0 1
10703: PPUSH
10704: LD_INT 108
10706: PUSH
10707: LD_INT 153
10709: PUSH
10710: EMPTY
10711: LIST
10712: LIST
10713: PUSH
10714: LD_INT 105
10716: PUSH
10717: LD_INT 149
10719: PUSH
10720: EMPTY
10721: LIST
10722: LIST
10723: PUSH
10724: LD_INT 85
10726: PUSH
10727: LD_INT 131
10729: PUSH
10730: EMPTY
10731: LIST
10732: LIST
10733: PUSH
10734: LD_INT 64
10736: PUSH
10737: LD_INT 105
10739: PUSH
10740: EMPTY
10741: LIST
10742: LIST
10743: PUSH
10744: EMPTY
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: PPUSH
10750: CALL 111905 0 2
10754: GO 10696
10756: POP
10757: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10758: LD_VAR 0 2
10762: PPUSH
10763: LD_INT 3
10765: PUSH
10766: LD_INT 34
10768: PUSH
10769: LD_INT 49
10771: PUSH
10772: EMPTY
10773: LIST
10774: LIST
10775: PUSH
10776: EMPTY
10777: LIST
10778: LIST
10779: PUSH
10780: LD_INT 50
10782: PUSH
10783: EMPTY
10784: LIST
10785: PUSH
10786: EMPTY
10787: LIST
10788: LIST
10789: PPUSH
10790: CALL_OW 72
10794: NOT
10795: IFFALSE 10668
// end ; until russianDestroyed ;
10797: LD_EXP 21
10801: IFFALSE 10128
// end ;
10803: PPOPN 6
10805: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport , p ;
10806: LD_EXP 21
10810: NOT
10811: IFFALSE 10823
10813: PUSH
10814: LD_EXP 15
10818: PUSH
10819: LD_INT 6
10821: GREATEREQUAL
10822: AND
10823: IFFALSE 11864
10825: GO 10827
10827: DISABLE
10828: LD_INT 0
10830: PPUSH
10831: PPUSH
10832: PPUSH
10833: PPUSH
10834: PPUSH
// begin enable ;
10835: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10836: LD_INT 22
10838: PUSH
10839: LD_INT 3
10841: PUSH
10842: EMPTY
10843: LIST
10844: LIST
10845: PUSH
10846: LD_INT 30
10848: PUSH
10849: LD_INT 3
10851: PUSH
10852: EMPTY
10853: LIST
10854: LIST
10855: PUSH
10856: EMPTY
10857: LIST
10858: LIST
10859: PPUSH
10860: CALL_OW 69
10864: NOT
10865: IFFALSE 10869
// exit ;
10867: GO 11864
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10869: LD_ADDR_VAR 0 4
10873: PUSH
10874: LD_INT 22
10876: PUSH
10877: LD_INT 3
10879: PUSH
10880: EMPTY
10881: LIST
10882: LIST
10883: PUSH
10884: LD_INT 30
10886: PUSH
10887: LD_INT 34
10889: PUSH
10890: EMPTY
10891: LIST
10892: LIST
10893: PUSH
10894: EMPTY
10895: LIST
10896: LIST
10897: PPUSH
10898: CALL_OW 69
10902: ST_TO_ADDR
// if Prob ( 40 ) then
10903: LD_INT 40
10905: PPUSH
10906: CALL_OW 13
10910: IFFALSE 11056
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10912: LD_INT 2
10914: PPUSH
10915: LD_INT 22
10917: PUSH
10918: LD_INT 3
10920: PUSH
10921: LD_INT 3
10923: PUSH
10924: LD_INT 49
10926: PUSH
10927: EMPTY
10928: LIST
10929: LIST
10930: LIST
10931: LIST
10932: PUSH
10933: LD_INT 22
10935: PUSH
10936: LD_INT 3
10938: PUSH
10939: LD_INT 3
10941: PUSH
10942: LD_INT 49
10944: PUSH
10945: EMPTY
10946: LIST
10947: LIST
10948: LIST
10949: LIST
10950: PUSH
10951: LD_INT 22
10953: PUSH
10954: LD_INT 3
10956: PUSH
10957: LD_INT 3
10959: PUSH
10960: LD_INT 49
10962: PUSH
10963: EMPTY
10964: LIST
10965: LIST
10966: LIST
10967: LIST
10968: PUSH
10969: LD_INT 24
10971: PUSH
10972: LD_INT 3
10974: PUSH
10975: LD_INT 3
10977: PUSH
10978: LD_INT 46
10980: PUSH
10981: EMPTY
10982: LIST
10983: LIST
10984: LIST
10985: LIST
10986: PUSH
10987: LD_INT 24
10989: PUSH
10990: LD_INT 3
10992: PUSH
10993: LD_INT 3
10995: PUSH
10996: LD_INT 46
10998: PUSH
10999: EMPTY
11000: LIST
11001: LIST
11002: LIST
11003: LIST
11004: PUSH
11005: LD_INT 24
11007: PUSH
11008: LD_INT 3
11010: PUSH
11011: LD_INT 3
11013: PUSH
11014: LD_INT 46
11016: PUSH
11017: EMPTY
11018: LIST
11019: LIST
11020: LIST
11021: LIST
11022: PUSH
11023: LD_INT 24
11025: PUSH
11026: LD_INT 3
11028: PUSH
11029: LD_INT 3
11031: PUSH
11032: LD_INT 46
11034: PUSH
11035: EMPTY
11036: LIST
11037: LIST
11038: LIST
11039: LIST
11040: PUSH
11041: EMPTY
11042: LIST
11043: LIST
11044: LIST
11045: LIST
11046: LIST
11047: LIST
11048: LIST
11049: PPUSH
11050: CALL 64415 0 2
// end else
11054: GO 11198
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
11056: LD_INT 2
11058: PPUSH
11059: LD_INT 24
11061: PUSH
11062: LD_INT 3
11064: PUSH
11065: LD_INT 3
11067: PUSH
11068: LD_INT 47
11070: PUSH
11071: EMPTY
11072: LIST
11073: LIST
11074: LIST
11075: LIST
11076: PUSH
11077: LD_INT 24
11079: PUSH
11080: LD_INT 3
11082: PUSH
11083: LD_INT 3
11085: PUSH
11086: LD_INT 47
11088: PUSH
11089: EMPTY
11090: LIST
11091: LIST
11092: LIST
11093: LIST
11094: PUSH
11095: LD_INT 24
11097: PUSH
11098: LD_INT 3
11100: PUSH
11101: LD_INT 3
11103: PUSH
11104: LD_INT 47
11106: PUSH
11107: EMPTY
11108: LIST
11109: LIST
11110: LIST
11111: LIST
11112: PUSH
11113: LD_INT 24
11115: PUSH
11116: LD_INT 3
11118: PUSH
11119: LD_INT 3
11121: PUSH
11122: LD_INT 46
11124: PUSH
11125: EMPTY
11126: LIST
11127: LIST
11128: LIST
11129: LIST
11130: PUSH
11131: LD_INT 24
11133: PUSH
11134: LD_INT 3
11136: PUSH
11137: LD_INT 3
11139: PUSH
11140: LD_INT 46
11142: PUSH
11143: EMPTY
11144: LIST
11145: LIST
11146: LIST
11147: LIST
11148: PUSH
11149: LD_INT 24
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: LD_INT 3
11157: PUSH
11158: LD_INT 46
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: LIST
11165: LIST
11166: PUSH
11167: LD_INT 24
11169: PUSH
11170: LD_INT 3
11172: PUSH
11173: LD_INT 3
11175: PUSH
11176: LD_INT 46
11178: PUSH
11179: EMPTY
11180: LIST
11181: LIST
11182: LIST
11183: LIST
11184: PUSH
11185: EMPTY
11186: LIST
11187: LIST
11188: LIST
11189: LIST
11190: LIST
11191: LIST
11192: LIST
11193: PPUSH
11194: CALL 64415 0 2
// end ; wait ( 2 2$00 ) ;
11198: LD_INT 4200
11200: PPUSH
11201: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , ru_siberium_rocket ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 2 ] ;
11205: LD_ADDR_VAR 0 2
11209: PUSH
11210: LD_INT 22
11212: PUSH
11213: LD_INT 3
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: LD_INT 23
11222: PUSH
11223: LD_INT 3
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: LD_INT 21
11232: PUSH
11233: LD_INT 2
11235: PUSH
11236: EMPTY
11237: LIST
11238: LIST
11239: PUSH
11240: LD_INT 3
11242: PUSH
11243: LD_INT 34
11245: PUSH
11246: LD_INT 48
11248: PUSH
11249: EMPTY
11250: LIST
11251: LIST
11252: PUSH
11253: EMPTY
11254: LIST
11255: LIST
11256: PUSH
11257: LD_INT 3
11259: PUSH
11260: LD_INT 34
11262: PUSH
11263: LD_INT 51
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: PUSH
11270: EMPTY
11271: LIST
11272: LIST
11273: PUSH
11274: LD_INT 3
11276: PUSH
11277: LD_INT 34
11279: PUSH
11280: LD_INT 52
11282: PUSH
11283: EMPTY
11284: LIST
11285: LIST
11286: PUSH
11287: EMPTY
11288: LIST
11289: LIST
11290: PUSH
11291: EMPTY
11292: LIST
11293: LIST
11294: LIST
11295: LIST
11296: LIST
11297: LIST
11298: PPUSH
11299: CALL_OW 69
11303: PUSH
11304: LD_EXP 124
11308: PUSH
11309: LD_INT 2
11311: ARRAY
11312: DIFF
11313: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
11314: LD_ADDR_EXP 121
11318: PUSH
11319: LD_EXP 121
11323: PPUSH
11324: LD_INT 2
11326: PPUSH
11327: LD_EXP 121
11331: PUSH
11332: LD_INT 2
11334: ARRAY
11335: PUSH
11336: LD_VAR 0 2
11340: DIFF
11341: PPUSH
11342: CALL_OW 1
11346: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
11347: LD_ADDR_VAR 0 3
11351: PUSH
11352: LD_INT 0
11354: PPUSH
11355: LD_INT 1
11357: PPUSH
11358: CALL_OW 12
11362: ST_TO_ADDR
// p := 0 ;
11363: LD_ADDR_VAR 0 5
11367: PUSH
11368: LD_INT 0
11370: ST_TO_ADDR
// if target then
11371: LD_VAR 0 3
11375: IFFALSE 11526
// begin repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11377: LD_ADDR_VAR 0 2
11381: PUSH
11382: LD_VAR 0 2
11386: PPUSH
11387: LD_INT 50
11389: PUSH
11390: EMPTY
11391: LIST
11392: PPUSH
11393: CALL_OW 72
11397: ST_TO_ADDR
// for i in tmp do
11398: LD_ADDR_VAR 0 1
11402: PUSH
11403: LD_VAR 0 2
11407: PUSH
11408: FOR_IN
11409: IFFALSE 11449
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11411: LD_VAR 0 1
11415: PPUSH
11416: LD_INT 139
11418: PPUSH
11419: LD_INT 89
11421: PPUSH
11422: CALL_OW 297
11426: PUSH
11427: LD_INT 9
11429: GREATER
11430: IFFALSE 11447
// ComMoveXY ( i , 139 , 89 ) ;
11432: LD_VAR 0 1
11436: PPUSH
11437: LD_INT 139
11439: PPUSH
11440: LD_INT 89
11442: PPUSH
11443: CALL_OW 111
11447: GO 11408
11449: POP
11450: POP
// wait ( 0 0$1 ) ;
11451: LD_INT 35
11453: PPUSH
11454: CALL_OW 67
// p := Inc ( p ) ;
11458: LD_ADDR_VAR 0 5
11462: PUSH
11463: LD_VAR 0 5
11467: PPUSH
11468: CALL 110512 0 1
11472: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11473: LD_VAR 0 2
11477: PPUSH
11478: LD_INT 92
11480: PUSH
11481: LD_INT 139
11483: PUSH
11484: LD_INT 89
11486: PUSH
11487: LD_INT 9
11489: PUSH
11490: EMPTY
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: PPUSH
11496: CALL_OW 72
11500: PUSH
11501: LD_VAR 0 2
11505: PUSH
11506: LD_INT 1
11508: MINUS
11509: GREATEREQUAL
11510: IFTRUE 11522
11512: PUSH
11513: LD_VAR 0 5
11517: PUSH
11518: LD_INT 60
11520: GREATER
11521: OR
11522: IFFALSE 11377
// end else
11524: GO 11691
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11526: LD_VAR 0 2
11530: PPUSH
11531: LD_VAR 0 4
11535: PUSH
11536: LD_INT 1
11538: ARRAY
11539: PPUSH
11540: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11544: LD_ADDR_VAR 0 2
11548: PUSH
11549: LD_VAR 0 2
11553: PPUSH
11554: LD_INT 50
11556: PUSH
11557: EMPTY
11558: LIST
11559: PPUSH
11560: CALL_OW 72
11564: ST_TO_ADDR
// for i in tmp do
11565: LD_ADDR_VAR 0 1
11569: PUSH
11570: LD_VAR 0 2
11574: PUSH
11575: FOR_IN
11576: IFFALSE 11616
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11578: LD_VAR 0 1
11582: PPUSH
11583: LD_INT 124
11585: PPUSH
11586: LD_INT 139
11588: PPUSH
11589: CALL_OW 297
11593: PUSH
11594: LD_INT 9
11596: GREATER
11597: IFFALSE 11614
// ComMoveXY ( i , 124 , 139 ) ;
11599: LD_VAR 0 1
11603: PPUSH
11604: LD_INT 124
11606: PPUSH
11607: LD_INT 139
11609: PPUSH
11610: CALL_OW 111
11614: GO 11575
11616: POP
11617: POP
// wait ( 0 0$1 ) ;
11618: LD_INT 35
11620: PPUSH
11621: CALL_OW 67
// p := Inc ( p ) ;
11625: LD_ADDR_VAR 0 5
11629: PUSH
11630: LD_VAR 0 5
11634: PPUSH
11635: CALL 110512 0 1
11639: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) or p > 60 ;
11640: LD_VAR 0 2
11644: PPUSH
11645: LD_INT 92
11647: PUSH
11648: LD_INT 124
11650: PUSH
11651: LD_INT 139
11653: PUSH
11654: LD_INT 9
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: LIST
11661: LIST
11662: PPUSH
11663: CALL_OW 72
11667: PUSH
11668: LD_VAR 0 2
11672: PUSH
11673: LD_INT 1
11675: MINUS
11676: GREATEREQUAL
11677: IFTRUE 11689
11679: PUSH
11680: LD_VAR 0 5
11684: PUSH
11685: LD_INT 60
11687: GREATER
11688: OR
11689: IFFALSE 11544
// end ; repeat wait ( 0 0$1 ) ;
11691: LD_INT 35
11693: PPUSH
11694: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
11698: LD_ADDR_VAR 0 2
11702: PUSH
11703: LD_VAR 0 2
11707: PPUSH
11708: LD_INT 50
11710: PUSH
11711: EMPTY
11712: LIST
11713: PPUSH
11714: CALL_OW 72
11718: ST_TO_ADDR
// for i in tmp do
11719: LD_ADDR_VAR 0 1
11723: PUSH
11724: LD_VAR 0 2
11728: PUSH
11729: FOR_IN
11730: IFFALSE 11855
// begin if GetWeapon ( i ) = ru_time_lapser then
11732: LD_VAR 0 1
11736: PPUSH
11737: CALL_OW 264
11741: PUSH
11742: LD_INT 49
11744: EQUAL
11745: IFFALSE 11801
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11747: LD_VAR 0 1
11751: PPUSH
11752: LD_INT 2
11754: PUSH
11755: LD_INT 22
11757: PUSH
11758: LD_INT 1
11760: PUSH
11761: EMPTY
11762: LIST
11763: LIST
11764: PUSH
11765: LD_INT 22
11767: PUSH
11768: LD_INT 8
11770: PUSH
11771: EMPTY
11772: LIST
11773: LIST
11774: PUSH
11775: EMPTY
11776: LIST
11777: LIST
11778: LIST
11779: PPUSH
11780: CALL_OW 69
11784: PPUSH
11785: LD_VAR 0 1
11789: PPUSH
11790: CALL_OW 74
11794: PPUSH
11795: CALL_OW 112
11799: GO 11853
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11801: LD_VAR 0 1
11805: PPUSH
11806: LD_INT 2
11808: PUSH
11809: LD_INT 22
11811: PUSH
11812: LD_INT 1
11814: PUSH
11815: EMPTY
11816: LIST
11817: LIST
11818: PUSH
11819: LD_INT 22
11821: PUSH
11822: LD_INT 8
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: PUSH
11829: EMPTY
11830: LIST
11831: LIST
11832: LIST
11833: PPUSH
11834: CALL_OW 69
11838: PPUSH
11839: LD_VAR 0 1
11843: PPUSH
11844: CALL_OW 74
11848: PPUSH
11849: CALL_OW 115
// end ;
11853: GO 11729
11855: POP
11856: POP
// until not tmp ;
11857: LD_VAR 0 2
11861: NOT
11862: IFFALSE 11691
// end ;
11864: PPOPN 5
11866: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11867: LD_EXP 15
11871: PUSH
11872: LD_INT 7
11874: GREATEREQUAL
11875: IFFALSE 11887
11877: PUSH
11878: LD_OWVAR 67
11882: PUSH
11883: LD_INT 1
11885: GREATER
11886: AND
11887: IFFALSE 12179
11889: GO 11891
11891: DISABLE
11892: LD_INT 0
11894: PPUSH
11895: PPUSH
11896: PPUSH
// begin ruMobile := [ ] ;
11897: LD_ADDR_EXP 78
11901: PUSH
11902: EMPTY
11903: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11904: LD_ADDR_VAR 0 1
11908: PUSH
11909: DOUBLE
11910: LD_INT 1
11912: DEC
11913: ST_TO_ADDR
11914: LD_INT 4
11916: PUSH
11917: LD_INT 5
11919: PUSH
11920: LD_INT 6
11922: PUSH
11923: EMPTY
11924: LIST
11925: LIST
11926: LIST
11927: PUSH
11928: LD_OWVAR 67
11932: PUSH
11933: LD_INT 1
11935: MINUS
11936: ARRAY
11937: PUSH
11938: FOR_TO
11939: IFFALSE 12177
// begin uc_side := 3 ;
11941: LD_ADDR_OWVAR 20
11945: PUSH
11946: LD_INT 3
11948: ST_TO_ADDR
// uc_nation := 1 ;
11949: LD_ADDR_OWVAR 21
11953: PUSH
11954: LD_INT 1
11956: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11957: LD_INT 5
11959: PPUSH
11960: LD_INT 3
11962: PPUSH
11963: LD_INT 1
11965: PPUSH
11966: LD_INT 9
11968: PUSH
11969: LD_INT 7
11971: PUSH
11972: EMPTY
11973: LIST
11974: LIST
11975: PUSH
11976: LD_VAR 0 1
11980: PUSH
11981: LD_INT 2
11983: MOD
11984: PUSH
11985: LD_INT 1
11987: PLUS
11988: ARRAY
11989: PPUSH
11990: LD_INT 100
11992: PPUSH
11993: CALL 75959 0 5
// veh := CreateVehicle ;
11997: LD_ADDR_VAR 0 2
12001: PUSH
12002: CALL_OW 45
12006: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
12007: LD_VAR 0 2
12011: PPUSH
12012: LD_INT 3
12014: PPUSH
12015: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
12019: LD_VAR 0 2
12023: PPUSH
12024: LD_INT 29
12026: PPUSH
12027: LD_INT 0
12029: PPUSH
12030: CALL_OW 49
// uc_nation := 3 ;
12034: LD_ADDR_OWVAR 21
12038: PUSH
12039: LD_INT 3
12041: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
12042: LD_INT 0
12044: PPUSH
12045: LD_INT 10
12047: PPUSH
12048: CALL_OW 383
// un := CreateHuman ;
12052: LD_ADDR_VAR 0 3
12056: PUSH
12057: CALL_OW 44
12061: ST_TO_ADDR
// SetTag ( un , 105 ) ;
12062: LD_VAR 0 3
12066: PPUSH
12067: LD_INT 105
12069: PPUSH
12070: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
12074: LD_VAR 0 3
12078: PPUSH
12079: LD_INT 3
12081: PPUSH
12082: CALL_OW 259
12086: PUSH
12087: LD_INT 8
12089: PUSH
12090: LD_INT 9
12092: PUSH
12093: LD_INT 10
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: LIST
12100: PUSH
12101: LD_OWVAR 67
12105: ARRAY
12106: LESS
12107: IFFALSE 12141
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
12109: LD_VAR 0 3
12113: PPUSH
12114: LD_INT 3
12116: PPUSH
12117: LD_INT 8
12119: PUSH
12120: LD_INT 9
12122: PUSH
12123: LD_INT 10
12125: PUSH
12126: EMPTY
12127: LIST
12128: LIST
12129: LIST
12130: PUSH
12131: LD_OWVAR 67
12135: ARRAY
12136: PPUSH
12137: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
12141: LD_VAR 0 3
12145: PPUSH
12146: LD_VAR 0 2
12150: PPUSH
12151: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
12155: LD_ADDR_EXP 78
12159: PUSH
12160: LD_EXP 78
12164: PPUSH
12165: LD_VAR 0 2
12169: PPUSH
12170: CALL 109139 0 2
12174: ST_TO_ADDR
// end ;
12175: GO 11938
12177: POP
12178: POP
// end ;
12179: PPOPN 3
12181: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
12182: LD_EXP 78
12186: IFFALSE 12697
12188: GO 12190
12190: DISABLE
12191: LD_INT 0
12193: PPUSH
12194: PPUSH
12195: PPUSH
// begin enable ;
12196: ENABLE
// if not ruMobile then
12197: LD_EXP 78
12201: NOT
12202: IFFALSE 12207
// begin disable ;
12204: DISABLE
// exit ;
12205: GO 12697
// end ; for i in ruMobile do
12207: LD_ADDR_VAR 0 1
12211: PUSH
12212: LD_EXP 78
12216: PUSH
12217: FOR_IN
12218: IFFALSE 12695
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
12220: LD_VAR 0 1
12224: PPUSH
12225: CALL_OW 302
12229: NOT
12230: IFTRUE 12247
12232: PUSH
12233: LD_VAR 0 1
12237: PPUSH
12238: CALL_OW 255
12242: PUSH
12243: LD_INT 3
12245: NONEQUAL
12246: OR
12247: IFFALSE 12267
// begin ruMobile := ruMobile diff i ;
12249: LD_ADDR_EXP 78
12253: PUSH
12254: LD_EXP 78
12258: PUSH
12259: LD_VAR 0 1
12263: DIFF
12264: ST_TO_ADDR
// continue ;
12265: GO 12217
// end ; if GetTag ( i ) = 300 then
12267: LD_VAR 0 1
12271: PPUSH
12272: CALL_OW 110
12276: PUSH
12277: LD_INT 300
12279: EQUAL
12280: IFFALSE 12330
// begin ComMoveXY ( i , 160 , 81 ) ;
12282: LD_VAR 0 1
12286: PPUSH
12287: LD_INT 160
12289: PPUSH
12290: LD_INT 81
12292: PPUSH
12293: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
12297: LD_VAR 0 1
12301: PPUSH
12302: LD_INT 160
12304: PPUSH
12305: LD_INT 81
12307: PPUSH
12308: CALL_OW 297
12312: PUSH
12313: LD_INT 8
12315: LESS
12316: IFFALSE 12330
// SetTag ( i , 301 ) ;
12318: LD_VAR 0 1
12322: PPUSH
12323: LD_INT 301
12325: PPUSH
12326: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
12330: LD_VAR 0 1
12334: PPUSH
12335: CALL_OW 110
12339: PUSH
12340: LD_INT 301
12342: EQUAL
12343: IFFALSE 12386
// begin if not IsInArea ( i , ruMobileParkingArea ) then
12345: LD_VAR 0 1
12349: PPUSH
12350: LD_INT 33
12352: PPUSH
12353: CALL_OW 308
12357: NOT
12358: IFFALSE 12374
// ComMoveToArea ( i , ruMobileParkingArea ) else
12360: LD_VAR 0 1
12364: PPUSH
12365: LD_INT 33
12367: PPUSH
12368: CALL_OW 113
12372: GO 12386
// SetTag ( i , 302 ) ;
12374: LD_VAR 0 1
12378: PPUSH
12379: LD_INT 302
12381: PPUSH
12382: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
12386: LD_VAR 0 1
12390: PPUSH
12391: CALL_OW 110
12395: PUSH
12396: LD_INT 302
12398: EQUAL
12399: IFFALSE 12529
// begin if GetLives ( i ) < 1000 then
12401: LD_VAR 0 1
12405: PPUSH
12406: CALL_OW 256
12410: PUSH
12411: LD_INT 1000
12413: LESS
12414: IFFALSE 12506
// begin if not IsDrivenBy ( i ) then
12416: LD_VAR 0 1
12420: PPUSH
12421: CALL_OW 311
12425: NOT
12426: IFFALSE 12430
// continue ;
12428: GO 12217
// mech := IsDrivenBy ( i ) ;
12430: LD_ADDR_VAR 0 2
12434: PUSH
12435: LD_VAR 0 1
12439: PPUSH
12440: CALL_OW 311
12444: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12445: LD_VAR 0 2
12449: PPUSH
12450: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12454: LD_VAR 0 2
12458: PPUSH
12459: LD_VAR 0 1
12463: PPUSH
12464: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12468: LD_INT 35
12470: PPUSH
12471: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12475: LD_VAR 0 1
12479: PPUSH
12480: CALL_OW 256
12484: PUSH
12485: LD_INT 1000
12487: EQUAL
12488: IFFALSE 12468
// ComEnterUnit ( mech , i ) ;
12490: LD_VAR 0 2
12494: PPUSH
12495: LD_VAR 0 1
12499: PPUSH
12500: CALL_OW 120
// end else
12504: GO 12529
// if IsDrivenBy ( i ) then
12506: LD_VAR 0 1
12510: PPUSH
12511: CALL_OW 311
12515: IFFALSE 12529
// SetTag ( i , 0 ) ;
12517: LD_VAR 0 1
12521: PPUSH
12522: LD_INT 0
12524: PPUSH
12525: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12529: LD_VAR 0 1
12533: PPUSH
12534: CALL_OW 110
12538: PUSH
12539: LD_INT 300
12541: LESS
12542: IFFALSE 12693
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12544: LD_ADDR_VAR 0 3
12548: PUSH
12549: LD_INT 4
12551: PPUSH
12552: LD_INT 81
12554: PUSH
12555: LD_INT 3
12557: PUSH
12558: EMPTY
12559: LIST
12560: LIST
12561: PPUSH
12562: CALL_OW 70
12566: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12567: LD_VAR 0 1
12571: PPUSH
12572: CALL_OW 256
12576: PUSH
12577: LD_INT 650
12579: LESS
12580: IFFALSE 12605
// begin ComStop ( i ) ;
12582: LD_VAR 0 1
12586: PPUSH
12587: CALL_OW 141
// SetTag ( i , 300 ) ;
12591: LD_VAR 0 1
12595: PPUSH
12596: LD_INT 300
12598: PPUSH
12599: CALL_OW 109
// continue ;
12603: GO 12217
// end ; if enemy then
12605: LD_VAR 0 3
12609: IFFALSE 12649
// begin if not HasTask ( i ) then
12611: LD_VAR 0 1
12615: PPUSH
12616: CALL_OW 314
12620: NOT
12621: IFFALSE 12647
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12623: LD_VAR 0 1
12627: PPUSH
12628: LD_VAR 0 3
12632: PPUSH
12633: LD_VAR 0 1
12637: PPUSH
12638: CALL_OW 74
12642: PPUSH
12643: CALL_OW 115
// end else
12647: GO 12693
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12649: LD_VAR 0 1
12653: PPUSH
12654: LD_INT 158
12656: PUSH
12657: LD_INT 61
12659: PUSH
12660: EMPTY
12661: LIST
12662: LIST
12663: PUSH
12664: LD_INT 98
12666: PUSH
12667: LD_INT 100
12669: PUSH
12670: EMPTY
12671: LIST
12672: LIST
12673: PUSH
12674: LD_INT 78
12676: PUSH
12677: LD_INT 93
12679: PUSH
12680: EMPTY
12681: LIST
12682: LIST
12683: PUSH
12684: EMPTY
12685: LIST
12686: LIST
12687: LIST
12688: PPUSH
12689: CALL 111905 0 2
// end ; end ;
12693: GO 12217
12695: POP
12696: POP
// end ; end_of_file
12697: PPOPN 3
12699: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12700: LD_INT 0
12702: PPUSH
12703: PPUSH
12704: PPUSH
12705: PPUSH
12706: PPUSH
12707: PPUSH
12708: PPUSH
// if Difficulty = 1 then
12709: LD_OWVAR 67
12713: PUSH
12714: LD_INT 1
12716: EQUAL
12717: IFFALSE 12755
// for i in FilterAllUnits ( [ f_inarea , delBuildingsArea ] ) do
12719: LD_ADDR_VAR 0 2
12723: PUSH
12724: LD_INT 95
12726: PUSH
12727: LD_INT 34
12729: PUSH
12730: EMPTY
12731: LIST
12732: LIST
12733: PPUSH
12734: CALL_OW 69
12738: PUSH
12739: FOR_IN
12740: IFFALSE 12753
// RemoveUnit ( i ) ;
12742: LD_VAR 0 2
12746: PPUSH
12747: CALL_OW 64
12751: GO 12739
12753: POP
12754: POP
// SetInvulnrability ( alien , true ) ;
12755: LD_INT 1
12757: PPUSH
12758: LD_INT 1
12760: PPUSH
12761: CALL_OW 607
// side := 7 ;
12765: LD_ADDR_VAR 0 5
12769: PUSH
12770: LD_INT 7
12772: ST_TO_ADDR
// uc_side := side ;
12773: LD_ADDR_OWVAR 20
12777: PUSH
12778: LD_VAR 0 5
12782: ST_TO_ADDR
// uc_nation := 1 ;
12783: LD_ADDR_OWVAR 21
12787: PUSH
12788: LD_INT 1
12790: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12791: LD_ADDR_VAR 0 2
12795: PUSH
12796: LD_INT 22
12798: PUSH
12799: LD_VAR 0 5
12803: PUSH
12804: EMPTY
12805: LIST
12806: LIST
12807: PUSH
12808: LD_INT 21
12810: PUSH
12811: LD_INT 3
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PPUSH
12822: CALL_OW 69
12826: PUSH
12827: FOR_IN
12828: IFFALSE 12844
// SetBLevel ( i , 10 ) ;
12830: LD_VAR 0 2
12834: PPUSH
12835: LD_INT 10
12837: PPUSH
12838: CALL_OW 241
12842: GO 12827
12844: POP
12845: POP
// base := GetBase ( al_depot ) ;
12846: LD_ADDR_VAR 0 4
12850: PUSH
12851: LD_INT 2
12853: PPUSH
12854: CALL_OW 274
12858: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12859: LD_ADDR_VAR 0 6
12863: PUSH
12864: LD_INT 22
12866: PUSH
12867: LD_VAR 0 5
12871: PUSH
12872: EMPTY
12873: LIST
12874: LIST
12875: PUSH
12876: LD_INT 30
12878: PUSH
12879: LD_INT 34
12881: PUSH
12882: EMPTY
12883: LIST
12884: LIST
12885: PUSH
12886: EMPTY
12887: LIST
12888: LIST
12889: PPUSH
12890: CALL_OW 69
12894: ST_TO_ADDR
// if teleport then
12895: LD_VAR 0 6
12899: IFFALSE 12920
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12901: LD_VAR 0 6
12905: PUSH
12906: LD_INT 1
12908: ARRAY
12909: PPUSH
12910: LD_INT 262
12912: PPUSH
12913: LD_INT 119
12915: PPUSH
12916: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12920: LD_VAR 0 4
12924: PPUSH
12925: LD_INT 1
12927: PPUSH
12928: LD_INT 19500
12930: PPUSH
12931: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12935: LD_VAR 0 4
12939: PPUSH
12940: LD_INT 2
12942: PPUSH
12943: LD_INT 200
12945: PPUSH
12946: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12950: LD_VAR 0 4
12954: PPUSH
12955: LD_INT 3
12957: PPUSH
12958: LD_INT 650
12960: PPUSH
12961: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12965: LD_ADDR_EXP 79
12969: PUSH
12970: LD_STRING Roth
12972: PPUSH
12973: CALL_OW 25
12977: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12978: LD_ADDR_EXP 80
12982: PUSH
12983: LD_STRING Simms
12985: PPUSH
12986: LD_EXP 1
12990: NOT
12991: PPUSH
12992: LD_STRING 10c_
12994: PPUSH
12995: CALL 70939 0 3
12999: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
13000: LD_EXP 80
13004: PPUSH
13005: LD_INT 4
13007: PPUSH
13008: CALL_OW 336
// if not Simms then
13012: LD_EXP 80
13016: NOT
13017: IFFALSE 13047
// begin uc_nation := 1 ;
13019: LD_ADDR_OWVAR 21
13023: PUSH
13024: LD_INT 1
13026: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
13027: LD_INT 2
13029: PPUSH
13030: LD_INT 10
13032: PPUSH
13033: CALL_OW 384
// Simms := CreateHuman ;
13037: LD_ADDR_EXP 80
13041: PUSH
13042: CALL_OW 44
13046: ST_TO_ADDR
// end ; uc_nation := 3 ;
13047: LD_ADDR_OWVAR 21
13051: PUSH
13052: LD_INT 3
13054: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
13055: LD_ADDR_EXP 81
13059: PUSH
13060: LD_STRING Kirilenkova
13062: PPUSH
13063: CALL_OW 25
13067: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
13068: LD_ADDR_EXP 95
13072: PUSH
13073: LD_STRING Oblukov
13075: PPUSH
13076: CALL_OW 25
13080: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
13081: LD_ADDR_EXP 82
13085: PUSH
13086: LD_STRING Dolgov
13088: PPUSH
13089: CALL_OW 25
13093: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
13094: LD_ADDR_EXP 83
13098: PUSH
13099: LD_STRING Petrosyan
13101: PPUSH
13102: CALL_OW 25
13106: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
13107: LD_ADDR_EXP 94
13111: PUSH
13112: LD_STRING Scholtze
13114: PPUSH
13115: CALL_OW 25
13119: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
13120: LD_ADDR_EXP 93
13124: PUSH
13125: LD_STRING Kapitsova
13127: PPUSH
13128: CALL_OW 25
13132: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
13133: LD_ADDR_EXP 84
13137: PUSH
13138: LD_STRING Petrovova
13140: PPUSH
13141: CALL_OW 25
13145: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
13146: LD_ADDR_EXP 85
13150: PUSH
13151: LD_STRING Kuzmov
13153: PPUSH
13154: CALL_OW 25
13158: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
13159: LD_ADDR_EXP 92
13163: PUSH
13164: LD_STRING Karamazov
13166: PPUSH
13167: CALL_OW 25
13171: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
13172: LD_STRING 13_Lipshchin_1
13174: PPUSH
13175: LD_INT 0
13177: PPUSH
13178: CALL_OW 30
13182: IFFALSE 13197
// Lipshchin := NewCharacter ( Lipshchin ) ;
13184: LD_ADDR_EXP 86
13188: PUSH
13189: LD_STRING Lipshchin
13191: PPUSH
13192: CALL_OW 25
13196: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
13197: LD_STRING 13_Titov_1
13199: PPUSH
13200: LD_INT 0
13202: PPUSH
13203: CALL_OW 30
13207: IFFALSE 13222
// Titov := NewCharacter ( Titov ) ;
13209: LD_ADDR_EXP 88
13213: PUSH
13214: LD_STRING Titov
13216: PPUSH
13217: CALL_OW 25
13221: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
13222: LD_STRING 13_Gnyevko_1
13224: PPUSH
13225: LD_INT 0
13227: PPUSH
13228: CALL_OW 30
13232: IFFALSE 13247
// Gnyevko := NewCharacter ( Gnyevko ) ;
13234: LD_ADDR_EXP 87
13238: PUSH
13239: LD_STRING Gnyevko
13241: PPUSH
13242: CALL_OW 25
13246: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
13247: LD_STRING 13_Xavier_1
13249: PPUSH
13250: LD_INT 0
13252: PPUSH
13253: CALL_OW 30
13257: IFFALSE 13272
// Xavier := NewCharacter ( Xavier2 ) ;
13259: LD_ADDR_EXP 89
13263: PUSH
13264: LD_STRING Xavier2
13266: PPUSH
13267: CALL_OW 25
13271: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
13272: LD_STRING 13_Belkov_1
13274: PPUSH
13275: LD_INT 0
13277: PPUSH
13278: CALL_OW 30
13282: IFFALSE 13297
// Belkov := NewCharacter ( Belkov ) ;
13284: LD_ADDR_EXP 90
13288: PUSH
13289: LD_STRING Belkov
13291: PPUSH
13292: CALL_OW 25
13296: ST_TO_ADDR
// if not BurlakStatus then
13297: LD_EXP 9
13301: NOT
13302: IFFALSE 13317
// Burlak = NewCharacter ( Burlak ) ;
13304: LD_ADDR_EXP 91
13308: PUSH
13309: LD_STRING Burlak
13311: PPUSH
13312: CALL_OW 25
13316: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
13317: LD_ADDR_VAR 0 3
13321: PUSH
13322: LD_EXP 79
13326: PUSH
13327: LD_EXP 81
13331: PUSH
13332: LD_EXP 95
13336: PUSH
13337: LD_EXP 82
13341: PUSH
13342: LD_EXP 83
13346: PUSH
13347: LD_EXP 94
13351: PUSH
13352: LD_EXP 93
13356: PUSH
13357: LD_EXP 84
13361: PUSH
13362: LD_EXP 85
13366: PUSH
13367: LD_EXP 92
13371: PUSH
13372: EMPTY
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: LIST
13378: LIST
13379: LIST
13380: LIST
13381: LIST
13382: LIST
13383: ST_TO_ADDR
// if Simms then
13384: LD_EXP 80
13388: IFFALSE 13406
// tmp := tmp ^ Simms ;
13390: LD_ADDR_VAR 0 3
13394: PUSH
13395: LD_VAR 0 3
13399: PUSH
13400: LD_EXP 80
13404: ADD
13405: ST_TO_ADDR
// if Titov then
13406: LD_EXP 88
13410: IFFALSE 13428
// tmp := tmp ^ Titov ;
13412: LD_ADDR_VAR 0 3
13416: PUSH
13417: LD_VAR 0 3
13421: PUSH
13422: LD_EXP 88
13426: ADD
13427: ST_TO_ADDR
// if Lipshchin then
13428: LD_EXP 86
13432: IFFALSE 13450
// tmp := tmp ^ Lipshchin ;
13434: LD_ADDR_VAR 0 3
13438: PUSH
13439: LD_VAR 0 3
13443: PUSH
13444: LD_EXP 86
13448: ADD
13449: ST_TO_ADDR
// if Gnyevko then
13450: LD_EXP 87
13454: IFFALSE 13472
// tmp := tmp ^ Gnyevko ;
13456: LD_ADDR_VAR 0 3
13460: PUSH
13461: LD_VAR 0 3
13465: PUSH
13466: LD_EXP 87
13470: ADD
13471: ST_TO_ADDR
// if Xavier then
13472: LD_EXP 89
13476: IFFALSE 13494
// tmp := tmp ^ Xavier ;
13478: LD_ADDR_VAR 0 3
13482: PUSH
13483: LD_VAR 0 3
13487: PUSH
13488: LD_EXP 89
13492: ADD
13493: ST_TO_ADDR
// if Belkov then
13494: LD_EXP 90
13498: IFFALSE 13516
// tmp := tmp ^ Belkov ;
13500: LD_ADDR_VAR 0 3
13504: PUSH
13505: LD_VAR 0 3
13509: PUSH
13510: LD_EXP 90
13514: ADD
13515: ST_TO_ADDR
// if Burlak then
13516: LD_EXP 91
13520: IFFALSE 13538
// tmp := tmp ^ Burlak ;
13522: LD_ADDR_VAR 0 3
13526: PUSH
13527: LD_VAR 0 3
13531: PUSH
13532: LD_EXP 91
13536: ADD
13537: ST_TO_ADDR
// for i = 1 to 11 do
13538: LD_ADDR_VAR 0 2
13542: PUSH
13543: DOUBLE
13544: LD_INT 1
13546: DEC
13547: ST_TO_ADDR
13548: LD_INT 11
13550: PUSH
13551: FOR_TO
13552: IFFALSE 13620
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13554: LD_ADDR_OWVAR 21
13558: PUSH
13559: LD_INT 1
13561: PUSH
13562: LD_INT 3
13564: PUSH
13565: EMPTY
13566: LIST
13567: LIST
13568: PUSH
13569: LD_INT 1
13571: PPUSH
13572: LD_INT 2
13574: PPUSH
13575: CALL_OW 12
13579: ARRAY
13580: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13581: LD_INT 0
13583: PPUSH
13584: LD_INT 1
13586: PPUSH
13587: LD_INT 4
13589: PPUSH
13590: CALL_OW 12
13594: PPUSH
13595: LD_INT 10
13597: PPUSH
13598: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13602: LD_ADDR_VAR 0 3
13606: PUSH
13607: LD_VAR 0 3
13611: PUSH
13612: CALL_OW 44
13616: ADD
13617: ST_TO_ADDR
// end ;
13618: GO 13551
13620: POP
13621: POP
// for i in tmp do
13622: LD_ADDR_VAR 0 2
13626: PUSH
13627: LD_VAR 0 3
13631: PUSH
13632: FOR_IN
13633: IFFALSE 13658
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13635: LD_VAR 0 2
13639: PPUSH
13640: LD_INT 260
13642: PPUSH
13643: LD_INT 235
13645: PPUSH
13646: LD_INT 8
13648: PPUSH
13649: LD_INT 0
13651: PPUSH
13652: CALL_OW 50
13656: GO 13632
13658: POP
13659: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13660: LD_ADDR_EXP 102
13664: PUSH
13665: LD_EXP 102
13669: PPUSH
13670: LD_INT 1
13672: PPUSH
13673: LD_INT 22
13675: PUSH
13676: LD_VAR 0 5
13680: PUSH
13681: EMPTY
13682: LIST
13683: LIST
13684: PUSH
13685: LD_INT 3
13687: PUSH
13688: LD_INT 21
13690: PUSH
13691: LD_INT 2
13693: PUSH
13694: EMPTY
13695: LIST
13696: LIST
13697: PUSH
13698: EMPTY
13699: LIST
13700: LIST
13701: PUSH
13702: EMPTY
13703: LIST
13704: LIST
13705: PPUSH
13706: CALL_OW 69
13710: PUSH
13711: LD_EXP 79
13715: PUSH
13716: LD_EXP 80
13720: PUSH
13721: EMPTY
13722: LIST
13723: LIST
13724: DIFF
13725: PPUSH
13726: CALL_OW 1
13730: ST_TO_ADDR
// uc_side := 0 ;
13731: LD_ADDR_OWVAR 20
13735: PUSH
13736: LD_INT 0
13738: ST_TO_ADDR
// uc_nation := 0 ;
13739: LD_ADDR_OWVAR 21
13743: PUSH
13744: LD_INT 0
13746: ST_TO_ADDR
// for i = 1 to 5 do
13747: LD_ADDR_VAR 0 2
13751: PUSH
13752: DOUBLE
13753: LD_INT 1
13755: DEC
13756: ST_TO_ADDR
13757: LD_INT 5
13759: PUSH
13760: FOR_TO
13761: IFFALSE 13798
// begin InitHc ;
13763: CALL_OW 19
// hc_class := class_apeman ;
13767: LD_ADDR_OWVAR 28
13771: PUSH
13772: LD_INT 12
13774: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13775: CALL_OW 44
13779: PPUSH
13780: LD_INT 299
13782: PPUSH
13783: LD_INT 229
13785: PPUSH
13786: LD_INT 10
13788: PPUSH
13789: LD_INT 0
13791: PPUSH
13792: CALL_OW 50
// end ;
13796: GO 13760
13798: POP
13799: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13800: LD_EXP 79
13804: PPUSH
13805: LD_INT 259
13807: PPUSH
13808: LD_INT 235
13810: PPUSH
13811: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13815: LD_EXP 79
13819: PPUSH
13820: LD_INT 262
13822: PPUSH
13823: LD_INT 235
13825: PPUSH
13826: CALL_OW 178
// if Simms then
13830: LD_EXP 80
13834: IFFALSE 13865
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13836: LD_EXP 80
13840: PPUSH
13841: LD_INT 262
13843: PPUSH
13844: LD_INT 235
13846: PPUSH
13847: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13851: LD_EXP 80
13855: PPUSH
13856: LD_EXP 79
13860: PPUSH
13861: CALL_OW 179
// end ; uc_side := 7 ;
13865: LD_ADDR_OWVAR 20
13869: PUSH
13870: LD_INT 7
13872: ST_TO_ADDR
// uc_nation := 1 ;
13873: LD_ADDR_OWVAR 21
13877: PUSH
13878: LD_INT 1
13880: ST_TO_ADDR
// bc_type := b_control_tower ;
13881: LD_ADDR_OWVAR 42
13885: PUSH
13886: LD_INT 36
13888: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13889: LD_ADDR_VAR 0 7
13893: PUSH
13894: LD_INT 268
13896: PPUSH
13897: LD_INT 251
13899: PPUSH
13900: LD_INT 4
13902: PPUSH
13903: CALL_OW 47
13907: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13908: LD_INT 0
13910: PPUSH
13911: LD_INT 10
13913: PPUSH
13914: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13918: CALL_OW 44
13922: PPUSH
13923: LD_VAR 0 7
13927: PPUSH
13928: CALL_OW 52
// end ;
13932: LD_VAR 0 1
13936: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed and FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_lab_full ] ] ) do var i , tmp , target ;
13937: LD_EXP 31
13941: IFFALSE 13950
13943: PUSH
13944: LD_EXP 23
13948: NOT
13949: AND
13950: IFFALSE 13982
13952: PUSH
13953: LD_INT 22
13955: PUSH
13956: LD_INT 7
13958: PUSH
13959: EMPTY
13960: LIST
13961: LIST
13962: PUSH
13963: LD_INT 30
13965: PUSH
13966: LD_INT 8
13968: PUSH
13969: EMPTY
13970: LIST
13971: LIST
13972: PUSH
13973: EMPTY
13974: LIST
13975: LIST
13976: PPUSH
13977: CALL_OW 69
13981: AND
13982: IFFALSE 14210
13984: GO 13986
13986: DISABLE
13987: LD_INT 0
13989: PPUSH
13990: PPUSH
13991: PPUSH
// begin enable ;
13992: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13993: LD_ADDR_VAR 0 2
13997: PUSH
13998: LD_INT 81
14000: PUSH
14001: LD_INT 7
14003: PUSH
14004: EMPTY
14005: LIST
14006: LIST
14007: PUSH
14008: LD_INT 2
14010: PUSH
14011: LD_INT 32
14013: PUSH
14014: LD_INT 3
14016: PUSH
14017: EMPTY
14018: LIST
14019: LIST
14020: PUSH
14021: LD_INT 30
14023: PUSH
14024: LD_INT 30
14026: PUSH
14027: EMPTY
14028: LIST
14029: LIST
14030: PUSH
14031: LD_INT 30
14033: PUSH
14034: LD_INT 28
14036: PUSH
14037: EMPTY
14038: LIST
14039: LIST
14040: PUSH
14041: LD_INT 34
14043: PUSH
14044: LD_INT 49
14046: PUSH
14047: EMPTY
14048: LIST
14049: LIST
14050: PUSH
14051: LD_INT 34
14053: PUSH
14054: LD_INT 10
14056: PUSH
14057: EMPTY
14058: LIST
14059: LIST
14060: PUSH
14061: LD_INT 34
14063: PUSH
14064: LD_INT 8
14066: PUSH
14067: EMPTY
14068: LIST
14069: LIST
14070: PUSH
14071: EMPTY
14072: LIST
14073: LIST
14074: LIST
14075: LIST
14076: LIST
14077: LIST
14078: LIST
14079: PUSH
14080: EMPTY
14081: LIST
14082: LIST
14083: PPUSH
14084: CALL_OW 69
14088: ST_TO_ADDR
// if not tmp then
14089: LD_VAR 0 2
14093: NOT
14094: IFFALSE 14098
// exit ;
14096: GO 14210
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
14098: LD_VAR 0 2
14102: PPUSH
14103: LD_INT 34
14105: PUSH
14106: LD_INT 8
14108: PUSH
14109: EMPTY
14110: LIST
14111: LIST
14112: PPUSH
14113: CALL_OW 72
14117: IFFALSE 14150
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
14119: LD_ADDR_VAR 0 3
14123: PUSH
14124: LD_VAR 0 2
14128: PPUSH
14129: LD_INT 34
14131: PUSH
14132: LD_INT 8
14134: PUSH
14135: EMPTY
14136: LIST
14137: LIST
14138: PPUSH
14139: CALL_OW 72
14143: PUSH
14144: LD_INT 1
14146: ARRAY
14147: ST_TO_ADDR
14148: GO 14174
// target := tmp [ rand ( 1 , tmp ) ] ;
14150: LD_ADDR_VAR 0 3
14154: PUSH
14155: LD_VAR 0 2
14159: PUSH
14160: LD_INT 1
14162: PPUSH
14163: LD_VAR 0 2
14167: PPUSH
14168: CALL_OW 12
14172: ARRAY
14173: ST_TO_ADDR
// if GetSide ( target ) = 1 then
14174: LD_VAR 0 3
14178: PPUSH
14179: CALL_OW 255
14183: PUSH
14184: LD_INT 1
14186: EQUAL
14187: IFFALSE 14198
// CenterNowOnUnits ( target ) ;
14189: LD_VAR 0 3
14193: PPUSH
14194: CALL_OW 87
// SetLives ( target , 0 ) ;
14198: LD_VAR 0 3
14202: PPUSH
14203: LD_INT 0
14205: PPUSH
14206: CALL_OW 234
// end ;
14210: PPOPN 3
14212: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
14213: LD_EXP 23
14217: NOT
14218: IFFALSE 14226
14220: PUSH
14221: LD_EXP 31
14225: AND
14226: IFFALSE 14744
14228: GO 14230
14230: DISABLE
14231: LD_INT 0
14233: PPUSH
14234: PPUSH
14235: PPUSH
// begin uc_side := 7 ;
14236: LD_ADDR_OWVAR 20
14240: PUSH
14241: LD_INT 7
14243: ST_TO_ADDR
// uc_nation := 1 ;
14244: LD_ADDR_OWVAR 21
14248: PUSH
14249: LD_INT 1
14251: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
14252: LD_ADDR_VAR 0 3
14256: PUSH
14257: LD_INT 125
14259: PUSH
14260: LD_INT 163
14262: PUSH
14263: EMPTY
14264: LIST
14265: LIST
14266: PUSH
14267: LD_INT 185
14269: PUSH
14270: LD_INT 168
14272: PUSH
14273: EMPTY
14274: LIST
14275: LIST
14276: PUSH
14277: LD_INT 111
14279: PUSH
14280: LD_INT 97
14282: PUSH
14283: EMPTY
14284: LIST
14285: LIST
14286: PUSH
14287: LD_INT 94
14289: PUSH
14290: LD_INT 114
14292: PUSH
14293: EMPTY
14294: LIST
14295: LIST
14296: PUSH
14297: EMPTY
14298: LIST
14299: LIST
14300: LIST
14301: LIST
14302: PPUSH
14303: CALL 109244 0 1
14307: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
14308: LD_ADDR_EXP 96
14312: PUSH
14313: EMPTY
14314: ST_TO_ADDR
// for i = 1 to Difficulty do
14315: LD_ADDR_VAR 0 1
14319: PUSH
14320: DOUBLE
14321: LD_INT 1
14323: DEC
14324: ST_TO_ADDR
14325: LD_OWVAR 67
14329: PUSH
14330: FOR_TO
14331: IFFALSE 14489
// begin InitHc ;
14333: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
14337: LD_INT 0
14339: PPUSH
14340: LD_INT 8
14342: PPUSH
14343: CALL_OW 381
// un := CreateHuman ;
14347: LD_ADDR_VAR 0 2
14351: PUSH
14352: CALL_OW 44
14356: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
14357: LD_VAR 0 2
14361: PPUSH
14362: LD_INT 258
14364: PPUSH
14365: LD_INT 267
14367: PPUSH
14368: LD_INT 4
14370: PPUSH
14371: LD_INT 0
14373: PPUSH
14374: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
14378: LD_ADDR_EXP 96
14382: PUSH
14383: LD_EXP 96
14387: PUSH
14388: LD_VAR 0 2
14392: UNION
14393: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
14394: LD_VAR 0 2
14398: PPUSH
14399: LD_VAR 0 3
14403: PUSH
14404: LD_VAR 0 1
14408: ARRAY
14409: PUSH
14410: LD_INT 1
14412: ARRAY
14413: PPUSH
14414: LD_VAR 0 3
14418: PUSH
14419: LD_VAR 0 1
14423: ARRAY
14424: PUSH
14425: LD_INT 2
14427: ARRAY
14428: PPUSH
14429: LD_INT 4
14431: PPUSH
14432: LD_INT 1
14434: PPUSH
14435: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
14439: LD_VAR 0 2
14443: PPUSH
14444: LD_VAR 0 3
14448: PUSH
14449: LD_VAR 0 1
14453: ARRAY
14454: PUSH
14455: LD_INT 1
14457: ARRAY
14458: PPUSH
14459: LD_VAR 0 3
14463: PUSH
14464: LD_VAR 0 1
14468: ARRAY
14469: PUSH
14470: LD_INT 2
14472: ARRAY
14473: PPUSH
14474: CALL_OW 171
// AddComInvisible ( un ) ;
14478: LD_VAR 0 2
14482: PPUSH
14483: CALL_OW 212
// end ;
14487: GO 14330
14489: POP
14490: POP
// repeat wait ( 0 0$45 ) ;
14491: LD_INT 1575
14493: PPUSH
14494: CALL_OW 67
// for i in allianceSpecialForce do
14498: LD_ADDR_VAR 0 1
14502: PUSH
14503: LD_EXP 96
14507: PUSH
14508: FOR_IN
14509: IFFALSE 14727
// begin if IsInvisible ( i ) then
14511: LD_VAR 0 1
14515: PPUSH
14516: CALL_OW 571
14520: IFFALSE 14696
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14522: LD_ADDR_VAR 0 3
14526: PUSH
14527: LD_INT 22
14529: PUSH
14530: LD_INT 1
14532: PUSH
14533: EMPTY
14534: LIST
14535: LIST
14536: PUSH
14537: LD_INT 50
14539: PUSH
14540: EMPTY
14541: LIST
14542: PUSH
14543: LD_INT 56
14545: PUSH
14546: EMPTY
14547: LIST
14548: PUSH
14549: LD_INT 91
14551: PUSH
14552: LD_VAR 0 1
14556: PUSH
14557: LD_INT 25
14559: PUSH
14560: EMPTY
14561: LIST
14562: LIST
14563: LIST
14564: PUSH
14565: LD_INT 2
14567: PUSH
14568: LD_INT 25
14570: PUSH
14571: LD_INT 1
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: PUSH
14578: LD_INT 25
14580: PUSH
14581: LD_INT 2
14583: PUSH
14584: EMPTY
14585: LIST
14586: LIST
14587: PUSH
14588: LD_INT 25
14590: PUSH
14591: LD_INT 3
14593: PUSH
14594: EMPTY
14595: LIST
14596: LIST
14597: PUSH
14598: LD_INT 25
14600: PUSH
14601: LD_INT 4
14603: PUSH
14604: EMPTY
14605: LIST
14606: LIST
14607: PUSH
14608: LD_INT 25
14610: PUSH
14611: LD_INT 5
14613: PUSH
14614: EMPTY
14615: LIST
14616: LIST
14617: PUSH
14618: LD_INT 25
14620: PUSH
14621: LD_INT 8
14623: PUSH
14624: EMPTY
14625: LIST
14626: LIST
14627: PUSH
14628: EMPTY
14629: LIST
14630: LIST
14631: LIST
14632: LIST
14633: LIST
14634: LIST
14635: LIST
14636: PUSH
14637: EMPTY
14638: LIST
14639: LIST
14640: LIST
14641: LIST
14642: LIST
14643: PPUSH
14644: CALL_OW 69
14648: ST_TO_ADDR
// if not tmp then
14649: LD_VAR 0 3
14653: NOT
14654: IFFALSE 14658
// continue ;
14656: GO 14508
// if Prob ( 30 * Difficulty ) then
14658: LD_INT 30
14660: PUSH
14661: LD_OWVAR 67
14665: MUL
14666: PPUSH
14667: CALL_OW 13
14671: IFFALSE 14696
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14673: LD_VAR 0 3
14677: PUSH
14678: LD_INT 1
14680: PPUSH
14681: LD_VAR 0 3
14685: PPUSH
14686: CALL_OW 12
14690: ARRAY
14691: PPUSH
14692: CALL 35627 0 1
// end ; if IsDead ( i ) then
14696: LD_VAR 0 1
14700: PPUSH
14701: CALL_OW 301
14705: IFFALSE 14725
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14707: LD_ADDR_EXP 96
14711: PUSH
14712: LD_EXP 96
14716: PUSH
14717: LD_VAR 0 1
14721: DIFF
14722: ST_TO_ADDR
// continue ;
14723: GO 14508
// end ; end ;
14725: GO 14508
14727: POP
14728: POP
// until allianceDestroyed or not allianceSpecialForce ;
14729: LD_EXP 23
14733: IFTRUE 14742
14735: PUSH
14736: LD_EXP 96
14740: NOT
14741: OR
14742: IFFALSE 14491
// end ;
14744: PPOPN 3
14746: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14747: LD_EXP 31
14751: IFFALSE 14801
14753: PUSH
14754: LD_INT 22
14756: PUSH
14757: LD_INT 1
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: PUSH
14764: LD_INT 2
14766: PUSH
14767: LD_INT 35
14769: PUSH
14770: LD_INT 8
14772: PUSH
14773: EMPTY
14774: LIST
14775: LIST
14776: PUSH
14777: LD_INT 34
14779: PUSH
14780: LD_INT 8
14782: PUSH
14783: EMPTY
14784: LIST
14785: LIST
14786: PUSH
14787: EMPTY
14788: LIST
14789: LIST
14790: LIST
14791: PUSH
14792: EMPTY
14793: LIST
14794: LIST
14795: PPUSH
14796: CALL_OW 69
14800: AND
14801: IFFALSE 15201
14803: GO 14805
14805: DISABLE
14806: LD_INT 0
14808: PPUSH
14809: PPUSH
14810: PPUSH
14811: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14812: LD_ADDR_VAR 0 1
14816: PUSH
14817: DOUBLE
14818: LD_INT 1
14820: DEC
14821: ST_TO_ADDR
14822: LD_INT 6
14824: PUSH
14825: LD_INT 8
14827: PUSH
14828: LD_INT 10
14830: PUSH
14831: LD_INT 12
14833: PUSH
14834: EMPTY
14835: LIST
14836: LIST
14837: LIST
14838: LIST
14839: PUSH
14840: LD_OWVAR 67
14844: ARRAY
14845: PUSH
14846: FOR_TO
14847: IFFALSE 15039
// begin uc_side := 7 ;
14849: LD_ADDR_OWVAR 20
14853: PUSH
14854: LD_INT 7
14856: ST_TO_ADDR
// uc_nation := 1 ;
14857: LD_ADDR_OWVAR 21
14861: PUSH
14862: LD_INT 1
14864: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14865: LD_INT 5
14867: PPUSH
14868: LD_INT 3
14870: PPUSH
14871: LD_INT 2
14873: PUSH
14874: LD_INT 3
14876: PUSH
14877: EMPTY
14878: LIST
14879: LIST
14880: PUSH
14881: LD_INT 1
14883: PPUSH
14884: LD_INT 2
14886: PPUSH
14887: CALL_OW 12
14891: ARRAY
14892: PPUSH
14893: LD_INT 6
14895: PUSH
14896: LD_INT 9
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: PUSH
14903: LD_INT 1
14905: PPUSH
14906: LD_INT 2
14908: PPUSH
14909: CALL_OW 12
14913: ARRAY
14914: PPUSH
14915: LD_INT 100
14917: PPUSH
14918: CALL 75959 0 5
// un := CreateVehicle ;
14922: LD_ADDR_VAR 0 2
14926: PUSH
14927: CALL_OW 45
14931: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14932: LD_VAR 0 2
14936: PPUSH
14937: LD_INT 4
14939: PPUSH
14940: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14944: LD_VAR 0 2
14948: PPUSH
14949: LD_INT 307
14951: PPUSH
14952: LD_INT 219
14954: PPUSH
14955: LD_INT 6
14957: PPUSH
14958: LD_INT 0
14960: PPUSH
14961: CALL_OW 50
// if GetControl ( un ) = control_remote then
14965: LD_VAR 0 2
14969: PPUSH
14970: CALL_OW 263
14974: PUSH
14975: LD_INT 2
14977: EQUAL
14978: IFFALSE 14989
// Connect ( un ) ;
14980: LD_VAR 0 2
14984: PPUSH
14985: CALL 79441 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14989: LD_VAR 0 2
14993: PPUSH
14994: LD_INT 124
14996: PPUSH
14997: LD_INT 92
14999: PPUSH
15000: LD_INT 12
15002: PPUSH
15003: LD_INT 1
15005: PPUSH
15006: CALL_OW 483
// tmp := Join ( tmp , un ) ;
15010: LD_ADDR_VAR 0 3
15014: PUSH
15015: LD_VAR 0 3
15019: PPUSH
15020: LD_VAR 0 2
15024: PPUSH
15025: CALL 109139 0 2
15029: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
15030: LD_INT 10
15032: PPUSH
15033: CALL_OW 67
// end ;
15037: GO 14846
15039: POP
15040: POP
// repeat wait ( 0 0$2 ) ;
15041: LD_INT 70
15043: PPUSH
15044: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
15048: LD_ADDR_VAR 0 4
15052: PUSH
15053: LD_INT 22
15055: PUSH
15056: LD_INT 1
15058: PUSH
15059: EMPTY
15060: LIST
15061: LIST
15062: PUSH
15063: LD_INT 34
15065: PUSH
15066: LD_INT 8
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: PUSH
15073: EMPTY
15074: LIST
15075: LIST
15076: PPUSH
15077: CALL_OW 69
15081: ST_TO_ADDR
// if not e then
15082: LD_VAR 0 4
15086: NOT
15087: IFFALSE 15123
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
15089: LD_ADDR_VAR 0 4
15093: PUSH
15094: LD_INT 22
15096: PUSH
15097: LD_INT 1
15099: PUSH
15100: EMPTY
15101: LIST
15102: LIST
15103: PUSH
15104: LD_INT 21
15106: PUSH
15107: LD_INT 2
15109: PUSH
15110: EMPTY
15111: LIST
15112: LIST
15113: PUSH
15114: EMPTY
15115: LIST
15116: LIST
15117: PPUSH
15118: CALL_OW 69
15122: ST_TO_ADDR
// for i in tmp do
15123: LD_ADDR_VAR 0 1
15127: PUSH
15128: LD_VAR 0 3
15132: PUSH
15133: FOR_IN
15134: IFFALSE 15192
// if not IsOK ( i ) then
15136: LD_VAR 0 1
15140: PPUSH
15141: CALL_OW 302
15145: NOT
15146: IFFALSE 15166
// tmp := tmp diff i else
15148: LD_ADDR_VAR 0 3
15152: PUSH
15153: LD_VAR 0 3
15157: PUSH
15158: LD_VAR 0 1
15162: DIFF
15163: ST_TO_ADDR
15164: GO 15190
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
15166: LD_VAR 0 1
15170: PPUSH
15171: LD_VAR 0 4
15175: PPUSH
15176: LD_VAR 0 1
15180: PPUSH
15181: CALL_OW 74
15185: PPUSH
15186: CALL_OW 115
15190: GO 15133
15192: POP
15193: POP
// until not tmp ;
15194: LD_VAR 0 3
15198: NOT
15199: IFFALSE 15041
// end ;
15201: PPOPN 4
15203: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport , p ;
15204: LD_EXP 23
15208: NOT
15209: IFFALSE 15217
15211: PUSH
15212: LD_EXP 31
15216: AND
15217: IFFALSE 16295
15219: GO 15221
15221: DISABLE
15222: LD_INT 0
15224: PPUSH
15225: PPUSH
15226: PPUSH
15227: PPUSH
15228: PPUSH
// begin enable ;
15229: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
15230: LD_INT 22
15232: PUSH
15233: LD_INT 7
15235: PUSH
15236: EMPTY
15237: LIST
15238: LIST
15239: PUSH
15240: LD_INT 30
15242: PUSH
15243: LD_INT 3
15245: PUSH
15246: EMPTY
15247: LIST
15248: LIST
15249: PUSH
15250: EMPTY
15251: LIST
15252: LIST
15253: PPUSH
15254: CALL_OW 69
15258: NOT
15259: IFFALSE 15263
// exit ;
15261: GO 16295
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
15263: LD_ADDR_VAR 0 4
15267: PUSH
15268: LD_INT 22
15270: PUSH
15271: LD_INT 7
15273: PUSH
15274: EMPTY
15275: LIST
15276: LIST
15277: PUSH
15278: LD_INT 30
15280: PUSH
15281: LD_INT 34
15283: PUSH
15284: EMPTY
15285: LIST
15286: LIST
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PPUSH
15292: CALL_OW 69
15296: ST_TO_ADDR
// if Prob ( 40 ) then
15297: LD_INT 40
15299: PPUSH
15300: CALL_OW 13
15304: IFFALSE 15450
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
15306: LD_INT 1
15308: PPUSH
15309: LD_INT 5
15311: PUSH
15312: LD_INT 3
15314: PUSH
15315: LD_INT 2
15317: PUSH
15318: LD_INT 6
15320: PUSH
15321: EMPTY
15322: LIST
15323: LIST
15324: LIST
15325: LIST
15326: PUSH
15327: LD_INT 5
15329: PUSH
15330: LD_INT 3
15332: PUSH
15333: LD_INT 2
15335: PUSH
15336: LD_INT 6
15338: PUSH
15339: EMPTY
15340: LIST
15341: LIST
15342: LIST
15343: LIST
15344: PUSH
15345: LD_INT 5
15347: PUSH
15348: LD_INT 3
15350: PUSH
15351: LD_INT 2
15353: PUSH
15354: LD_INT 6
15356: PUSH
15357: EMPTY
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: PUSH
15363: LD_INT 5
15365: PUSH
15366: LD_INT 3
15368: PUSH
15369: LD_INT 2
15371: PUSH
15372: LD_INT 9
15374: PUSH
15375: EMPTY
15376: LIST
15377: LIST
15378: LIST
15379: LIST
15380: PUSH
15381: LD_INT 24
15383: PUSH
15384: LD_INT 3
15386: PUSH
15387: LD_INT 3
15389: PUSH
15390: LD_INT 45
15392: PUSH
15393: EMPTY
15394: LIST
15395: LIST
15396: LIST
15397: LIST
15398: PUSH
15399: LD_INT 24
15401: PUSH
15402: LD_INT 3
15404: PUSH
15405: LD_INT 3
15407: PUSH
15408: LD_INT 47
15410: PUSH
15411: EMPTY
15412: LIST
15413: LIST
15414: LIST
15415: LIST
15416: PUSH
15417: LD_INT 24
15419: PUSH
15420: LD_INT 3
15422: PUSH
15423: LD_INT 3
15425: PUSH
15426: LD_INT 45
15428: PUSH
15429: EMPTY
15430: LIST
15431: LIST
15432: LIST
15433: LIST
15434: PUSH
15435: EMPTY
15436: LIST
15437: LIST
15438: LIST
15439: LIST
15440: LIST
15441: LIST
15442: LIST
15443: PPUSH
15444: CALL 64415 0 2
// end else
15448: GO 15592
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
15450: LD_INT 1
15452: PPUSH
15453: LD_INT 24
15455: PUSH
15456: LD_INT 3
15458: PUSH
15459: LD_INT 3
15461: PUSH
15462: LD_INT 47
15464: PUSH
15465: EMPTY
15466: LIST
15467: LIST
15468: LIST
15469: LIST
15470: PUSH
15471: LD_INT 24
15473: PUSH
15474: LD_INT 3
15476: PUSH
15477: LD_INT 3
15479: PUSH
15480: LD_INT 47
15482: PUSH
15483: EMPTY
15484: LIST
15485: LIST
15486: LIST
15487: LIST
15488: PUSH
15489: LD_INT 5
15491: PUSH
15492: LD_INT 3
15494: PUSH
15495: LD_INT 2
15497: PUSH
15498: LD_INT 9
15500: PUSH
15501: EMPTY
15502: LIST
15503: LIST
15504: LIST
15505: LIST
15506: PUSH
15507: LD_INT 5
15509: PUSH
15510: LD_INT 3
15512: PUSH
15513: LD_INT 2
15515: PUSH
15516: LD_INT 9
15518: PUSH
15519: EMPTY
15520: LIST
15521: LIST
15522: LIST
15523: LIST
15524: PUSH
15525: LD_INT 5
15527: PUSH
15528: LD_INT 3
15530: PUSH
15531: LD_INT 2
15533: PUSH
15534: LD_INT 9
15536: PUSH
15537: EMPTY
15538: LIST
15539: LIST
15540: LIST
15541: LIST
15542: PUSH
15543: LD_INT 24
15545: PUSH
15546: LD_INT 1
15548: PUSH
15549: LD_INT 3
15551: PUSH
15552: LD_INT 45
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: LIST
15559: LIST
15560: PUSH
15561: LD_INT 24
15563: PUSH
15564: LD_INT 1
15566: PUSH
15567: LD_INT 3
15569: PUSH
15570: LD_INT 45
15572: PUSH
15573: EMPTY
15574: LIST
15575: LIST
15576: LIST
15577: LIST
15578: PUSH
15579: EMPTY
15580: LIST
15581: LIST
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: LIST
15587: PPUSH
15588: CALL 64415 0 2
// end ; wait ( 2 2$00 ) ;
15592: LD_INT 4200
15594: PPUSH
15595: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_crane ] ] , [ f_not , [ f_weapon , us_cargo_bay ] ] , [ f_not , [ f_weapon , ru_cargo_bay ] ] , [ f_not , [ f_weapon , ru_crane ] ] ] ) diff mc_defender [ 1 ] ;
15599: LD_ADDR_VAR 0 2
15603: PUSH
15604: LD_INT 22
15606: PUSH
15607: LD_INT 7
15609: PUSH
15610: EMPTY
15611: LIST
15612: LIST
15613: PUSH
15614: LD_INT 21
15616: PUSH
15617: LD_INT 2
15619: PUSH
15620: EMPTY
15621: LIST
15622: LIST
15623: PUSH
15624: LD_INT 3
15626: PUSH
15627: LD_INT 34
15629: PUSH
15630: LD_INT 13
15632: PUSH
15633: EMPTY
15634: LIST
15635: LIST
15636: PUSH
15637: EMPTY
15638: LIST
15639: LIST
15640: PUSH
15641: LD_INT 3
15643: PUSH
15644: LD_INT 34
15646: PUSH
15647: LD_INT 12
15649: PUSH
15650: EMPTY
15651: LIST
15652: LIST
15653: PUSH
15654: EMPTY
15655: LIST
15656: LIST
15657: PUSH
15658: LD_INT 3
15660: PUSH
15661: LD_INT 34
15663: PUSH
15664: LD_INT 51
15666: PUSH
15667: EMPTY
15668: LIST
15669: LIST
15670: PUSH
15671: EMPTY
15672: LIST
15673: LIST
15674: PUSH
15675: LD_INT 3
15677: PUSH
15678: LD_INT 34
15680: PUSH
15681: LD_INT 52
15683: PUSH
15684: EMPTY
15685: LIST
15686: LIST
15687: PUSH
15688: EMPTY
15689: LIST
15690: LIST
15691: PUSH
15692: EMPTY
15693: LIST
15694: LIST
15695: LIST
15696: LIST
15697: LIST
15698: LIST
15699: PPUSH
15700: CALL_OW 69
15704: PUSH
15705: LD_EXP 124
15709: PUSH
15710: LD_INT 1
15712: ARRAY
15713: DIFF
15714: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15715: LD_ADDR_EXP 121
15719: PUSH
15720: LD_EXP 121
15724: PPUSH
15725: LD_INT 1
15727: PPUSH
15728: LD_EXP 121
15732: PUSH
15733: LD_INT 1
15735: ARRAY
15736: PUSH
15737: LD_VAR 0 2
15741: DIFF
15742: PPUSH
15743: CALL_OW 1
15747: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15748: LD_ADDR_VAR 0 3
15752: PUSH
15753: LD_INT 0
15755: PPUSH
15756: LD_INT 1
15758: PPUSH
15759: CALL_OW 12
15763: ST_TO_ADDR
// p := 0 ;
15764: LD_ADDR_VAR 0 5
15768: PUSH
15769: LD_INT 0
15771: ST_TO_ADDR
// if target then
15772: LD_VAR 0 3
15776: IFFALSE 15969
// begin for i in tmp do
15778: LD_ADDR_VAR 0 1
15782: PUSH
15783: LD_VAR 0 2
15787: PUSH
15788: FOR_IN
15789: IFFALSE 15814
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15791: LD_VAR 0 1
15795: PPUSH
15796: LD_INT 179
15798: PPUSH
15799: LD_INT 209
15801: PPUSH
15802: LD_INT 8
15804: PPUSH
15805: LD_INT 1
15807: PPUSH
15808: CALL_OW 483
15812: GO 15788
15814: POP
15815: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15816: LD_ADDR_VAR 0 2
15820: PUSH
15821: LD_VAR 0 2
15825: PPUSH
15826: LD_INT 24
15828: PUSH
15829: LD_INT 250
15831: PUSH
15832: EMPTY
15833: LIST
15834: LIST
15835: PPUSH
15836: CALL_OW 72
15840: ST_TO_ADDR
// for i in tmp do
15841: LD_ADDR_VAR 0 1
15845: PUSH
15846: LD_VAR 0 2
15850: PUSH
15851: FOR_IN
15852: IFFALSE 15892
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15854: LD_VAR 0 1
15858: PPUSH
15859: LD_INT 179
15861: PPUSH
15862: LD_INT 209
15864: PPUSH
15865: CALL_OW 297
15869: PUSH
15870: LD_INT 9
15872: GREATER
15873: IFFALSE 15890
// ComMoveXY ( i , 179 , 209 ) ;
15875: LD_VAR 0 1
15879: PPUSH
15880: LD_INT 179
15882: PPUSH
15883: LD_INT 209
15885: PPUSH
15886: CALL_OW 111
15890: GO 15851
15892: POP
15893: POP
// wait ( 0 0$1 ) ;
15894: LD_INT 35
15896: PPUSH
15897: CALL_OW 67
// p := Inc ( p ) ;
15901: LD_ADDR_VAR 0 5
15905: PUSH
15906: LD_VAR 0 5
15910: PPUSH
15911: CALL 110512 0 1
15915: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
15916: LD_VAR 0 2
15920: PPUSH
15921: LD_INT 92
15923: PUSH
15924: LD_INT 179
15926: PUSH
15927: LD_INT 209
15929: PUSH
15930: LD_INT 9
15932: PUSH
15933: EMPTY
15934: LIST
15935: LIST
15936: LIST
15937: LIST
15938: PPUSH
15939: CALL_OW 72
15943: PUSH
15944: LD_VAR 0 2
15948: PUSH
15949: LD_INT 1
15951: MINUS
15952: GREATEREQUAL
15953: IFTRUE 15965
15955: PUSH
15956: LD_VAR 0 5
15960: PUSH
15961: LD_INT 30
15963: GREATER
15964: OR
15965: IFFALSE 15816
// end else
15967: GO 16158
// begin for i in tmp do
15969: LD_ADDR_VAR 0 1
15973: PUSH
15974: LD_VAR 0 2
15978: PUSH
15979: FOR_IN
15980: IFFALSE 16005
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15982: LD_VAR 0 1
15986: PPUSH
15987: LD_INT 285
15989: PPUSH
15990: LD_INT 163
15992: PPUSH
15993: LD_INT 8
15995: PPUSH
15996: LD_INT 1
15998: PPUSH
15999: CALL_OW 483
16003: GO 15979
16005: POP
16006: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
16007: LD_ADDR_VAR 0 2
16011: PUSH
16012: LD_VAR 0 2
16016: PPUSH
16017: LD_INT 24
16019: PUSH
16020: LD_INT 250
16022: PUSH
16023: EMPTY
16024: LIST
16025: LIST
16026: PPUSH
16027: CALL_OW 72
16031: ST_TO_ADDR
// for i in tmp do
16032: LD_ADDR_VAR 0 1
16036: PUSH
16037: LD_VAR 0 2
16041: PUSH
16042: FOR_IN
16043: IFFALSE 16083
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
16045: LD_VAR 0 1
16049: PPUSH
16050: LD_INT 285
16052: PPUSH
16053: LD_INT 163
16055: PPUSH
16056: CALL_OW 297
16060: PUSH
16061: LD_INT 9
16063: GREATER
16064: IFFALSE 16081
// ComMoveXY ( i , 285 , 163 ) ;
16066: LD_VAR 0 1
16070: PPUSH
16071: LD_INT 285
16073: PPUSH
16074: LD_INT 163
16076: PPUSH
16077: CALL_OW 111
16081: GO 16042
16083: POP
16084: POP
// wait ( 0 0$1 ) ;
16085: LD_INT 35
16087: PPUSH
16088: CALL_OW 67
// p := Inc ( p ) ;
16092: LD_ADDR_VAR 0 5
16096: PUSH
16097: LD_VAR 0 5
16101: PPUSH
16102: CALL 110512 0 1
16106: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) or p > 30 ;
16107: LD_VAR 0 2
16111: PPUSH
16112: LD_INT 92
16114: PUSH
16115: LD_INT 285
16117: PUSH
16118: LD_INT 163
16120: PUSH
16121: LD_INT 9
16123: PUSH
16124: EMPTY
16125: LIST
16126: LIST
16127: LIST
16128: LIST
16129: PPUSH
16130: CALL_OW 72
16134: PUSH
16135: LD_VAR 0 2
16139: PUSH
16140: LD_INT 1
16142: MINUS
16143: GREATEREQUAL
16144: IFTRUE 16156
16146: PUSH
16147: LD_VAR 0 5
16151: PUSH
16152: LD_INT 30
16154: GREATER
16155: OR
16156: IFFALSE 16007
// end ; repeat wait ( 0 0$1 ) ;
16158: LD_INT 35
16160: PPUSH
16161: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
16165: LD_ADDR_VAR 0 2
16169: PUSH
16170: LD_VAR 0 2
16174: PPUSH
16175: LD_INT 50
16177: PUSH
16178: EMPTY
16179: LIST
16180: PPUSH
16181: CALL_OW 72
16185: ST_TO_ADDR
// for i in tmp do
16186: LD_ADDR_VAR 0 1
16190: PUSH
16191: LD_VAR 0 2
16195: PUSH
16196: FOR_IN
16197: IFFALSE 16286
// if GetWeapon ( i ) = ru_time_lapser then
16199: LD_VAR 0 1
16203: PPUSH
16204: CALL_OW 264
16208: PUSH
16209: LD_INT 49
16211: EQUAL
16212: IFFALSE 16250
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
16214: LD_VAR 0 1
16218: PPUSH
16219: LD_INT 81
16221: PUSH
16222: LD_INT 7
16224: PUSH
16225: EMPTY
16226: LIST
16227: LIST
16228: PPUSH
16229: CALL_OW 69
16233: PPUSH
16234: LD_VAR 0 1
16238: PPUSH
16239: CALL_OW 74
16243: PPUSH
16244: CALL_OW 112
16248: GO 16284
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
16250: LD_VAR 0 1
16254: PPUSH
16255: LD_INT 81
16257: PUSH
16258: LD_INT 7
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: PPUSH
16265: CALL_OW 69
16269: PPUSH
16270: LD_VAR 0 1
16274: PPUSH
16275: CALL_OW 74
16279: PPUSH
16280: CALL_OW 115
16284: GO 16196
16286: POP
16287: POP
// until not tmp ;
16288: LD_VAR 0 2
16292: NOT
16293: IFFALSE 16158
// end ;
16295: PPOPN 5
16297: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
16298: LD_EXP 31
16302: IFFALSE 16315
16304: PUSH
16305: LD_EXP 79
16309: PPUSH
16310: CALL_OW 302
16314: AND
16315: IFFALSE 16327
16317: PUSH
16318: LD_OWVAR 67
16322: PUSH
16323: LD_INT 2
16325: GREATER
16326: AND
16327: IFFALSE 16427
16329: GO 16331
16331: DISABLE
// begin enable ;
16332: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
16333: LD_EXP 79
16337: PPUSH
16338: LD_INT 245
16340: PPUSH
16341: LD_INT 234
16343: PPUSH
16344: CALL_OW 297
16348: PUSH
16349: LD_INT 6
16351: GREATER
16352: IFFALSE 16371
// ComMoveXY ( Roth , 245 , 234 ) else
16354: LD_EXP 79
16358: PPUSH
16359: LD_INT 245
16361: PPUSH
16362: LD_INT 234
16364: PPUSH
16365: CALL_OW 111
16369: GO 16427
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
16371: LD_EXP 79
16375: PPUSH
16376: LD_INT 259
16378: PUSH
16379: LD_INT 235
16381: PUSH
16382: EMPTY
16383: LIST
16384: LIST
16385: PUSH
16386: LD_INT 252
16388: PUSH
16389: LD_INT 209
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PUSH
16396: LD_INT 275
16398: PUSH
16399: LD_INT 235
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: PUSH
16406: EMPTY
16407: LIST
16408: LIST
16409: LIST
16410: PUSH
16411: LD_INT 1
16413: PPUSH
16414: LD_INT 3
16416: PPUSH
16417: CALL_OW 12
16421: ARRAY
16422: PPUSH
16423: CALL 113467 0 2
// end ; end_of_file
16427: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
16428: LD_INT 0
16430: PPUSH
16431: PPUSH
16432: PPUSH
16433: PPUSH
// missionStage := 13 ;
16434: LD_ADDR_EXP 15
16438: PUSH
16439: LD_INT 13
16441: ST_TO_ADDR
// uc_side := 2 ;
16442: LD_ADDR_OWVAR 20
16446: PUSH
16447: LD_INT 2
16449: ST_TO_ADDR
// uc_nation := 2 ;
16450: LD_ADDR_OWVAR 21
16454: PUSH
16455: LD_INT 2
16457: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
16458: LD_ADDR_EXP 97
16462: PUSH
16463: LD_STRING Omar
16465: PPUSH
16466: CALL_OW 25
16470: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
16471: LD_EXP 97
16475: PPUSH
16476: LD_INT 4
16478: PPUSH
16479: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
16483: LD_EXP 97
16487: PPUSH
16488: LD_INT 242
16490: PPUSH
16491: LD_INT 75
16493: PPUSH
16494: LD_INT 0
16496: PPUSH
16497: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
16501: LD_ADDR_EXP 98
16505: PUSH
16506: LD_STRING Heike
16508: PPUSH
16509: CALL_OW 25
16513: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
16514: LD_INT 14
16516: PPUSH
16517: LD_INT 3
16519: PPUSH
16520: LD_INT 1
16522: PPUSH
16523: LD_INT 27
16525: PPUSH
16526: LD_INT 100
16528: PPUSH
16529: CALL 75959 0 5
// veh := CreateVehicle ;
16533: LD_ADDR_VAR 0 3
16537: PUSH
16538: CALL_OW 45
16542: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
16543: LD_VAR 0 3
16547: PPUSH
16548: LD_INT 2
16550: NEG
16551: PPUSH
16552: CALL_OW 242
// SetDir ( veh , 4 ) ;
16556: LD_VAR 0 3
16560: PPUSH
16561: LD_INT 4
16563: PPUSH
16564: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
16568: LD_VAR 0 3
16572: PPUSH
16573: LD_INT 241
16575: PPUSH
16576: LD_INT 72
16578: PPUSH
16579: LD_INT 0
16581: PPUSH
16582: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
16586: LD_EXP 98
16590: PPUSH
16591: LD_VAR 0 3
16595: PPUSH
16596: CALL_OW 52
// if KhatamStatus then
16600: LD_EXP 8
16604: IFFALSE 16667
// begin Khatam := NewCharacter ( Khatam ) ;
16606: LD_ADDR_EXP 99
16610: PUSH
16611: LD_STRING Khatam
16613: PPUSH
16614: CALL_OW 25
16618: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
16619: LD_EXP 99
16623: PPUSH
16624: LD_INT 245
16626: PPUSH
16627: LD_INT 78
16629: PPUSH
16630: LD_INT 3
16632: PPUSH
16633: LD_INT 0
16635: PPUSH
16636: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
16640: LD_EXP 99
16644: PPUSH
16645: LD_INT 4
16647: PPUSH
16648: LD_INT 10
16650: PPUSH
16651: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
16655: LD_EXP 99
16659: PPUSH
16660: LD_INT 4
16662: PPUSH
16663: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16667: LD_ADDR_VAR 0 2
16671: PUSH
16672: DOUBLE
16673: LD_INT 1
16675: DEC
16676: ST_TO_ADDR
16677: LD_INT 2
16679: PUSH
16680: LD_INT 2
16682: PUSH
16683: LD_INT 3
16685: PUSH
16686: LD_INT 3
16688: PUSH
16689: EMPTY
16690: LIST
16691: LIST
16692: LIST
16693: LIST
16694: PUSH
16695: LD_OWVAR 67
16699: ARRAY
16700: PUSH
16701: FOR_TO
16702: IFFALSE 16768
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16704: LD_INT 0
16706: PPUSH
16707: LD_INT 6
16709: PUSH
16710: LD_OWVAR 67
16714: PLUS
16715: PPUSH
16716: CALL_OW 384
// un := CreateHuman ;
16720: LD_ADDR_VAR 0 4
16724: PUSH
16725: CALL_OW 44
16729: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16730: LD_VAR 0 4
16734: PPUSH
16735: LD_INT 28
16737: PUSH
16738: LD_INT 29
16740: PUSH
16741: EMPTY
16742: LIST
16743: LIST
16744: PUSH
16745: LD_VAR 0 2
16749: PUSH
16750: LD_INT 2
16752: MOD
16753: PUSH
16754: LD_INT 1
16756: PLUS
16757: ARRAY
16758: PPUSH
16759: LD_INT 0
16761: PPUSH
16762: CALL_OW 49
// end ;
16766: GO 16701
16768: POP
16769: POP
// for i = 1 to 6 do
16770: LD_ADDR_VAR 0 2
16774: PUSH
16775: DOUBLE
16776: LD_INT 1
16778: DEC
16779: ST_TO_ADDR
16780: LD_INT 6
16782: PUSH
16783: FOR_TO
16784: IFFALSE 16829
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16786: LD_INT 0
16788: PPUSH
16789: LD_INT 6
16791: PUSH
16792: LD_OWVAR 67
16796: PLUS
16797: PPUSH
16798: CALL_OW 381
// un := CreateHuman ;
16802: LD_ADDR_VAR 0 4
16806: PUSH
16807: CALL_OW 44
16811: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16812: LD_VAR 0 4
16816: PPUSH
16817: LD_INT 32
16819: PPUSH
16820: LD_INT 0
16822: PPUSH
16823: CALL_OW 49
// end ;
16827: GO 16783
16829: POP
16830: POP
// for i = 1 to 3 do
16831: LD_ADDR_VAR 0 2
16835: PUSH
16836: DOUBLE
16837: LD_INT 1
16839: DEC
16840: ST_TO_ADDR
16841: LD_INT 3
16843: PUSH
16844: FOR_TO
16845: IFFALSE 16893
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16847: LD_INT 0
16849: PPUSH
16850: LD_INT 8
16852: PPUSH
16853: LD_INT 6
16855: PUSH
16856: LD_OWVAR 67
16860: PLUS
16861: PPUSH
16862: CALL_OW 380
// un := CreateHuman ;
16866: LD_ADDR_VAR 0 4
16870: PUSH
16871: CALL_OW 44
16875: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16876: LD_VAR 0 4
16880: PPUSH
16881: LD_INT 32
16883: PPUSH
16884: LD_INT 0
16886: PPUSH
16887: CALL_OW 49
// end ;
16891: GO 16844
16893: POP
16894: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16895: LD_ADDR_VAR 0 2
16899: PUSH
16900: DOUBLE
16901: LD_INT 1
16903: DEC
16904: ST_TO_ADDR
16905: LD_INT 2
16907: PUSH
16908: LD_INT 3
16910: PUSH
16911: LD_INT 4
16913: PUSH
16914: LD_INT 4
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: LIST
16921: LIST
16922: PUSH
16923: LD_OWVAR 67
16927: ARRAY
16928: PUSH
16929: FOR_TO
16930: IFFALSE 17020
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16932: LD_INT 14
16934: PPUSH
16935: LD_INT 2
16937: PPUSH
16938: LD_INT 1
16940: PPUSH
16941: LD_INT 28
16943: PPUSH
16944: LD_INT 80
16946: PPUSH
16947: CALL 75959 0 5
// veh := CreateVehicle ;
16951: LD_ADDR_VAR 0 3
16955: PUSH
16956: CALL_OW 45
16960: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16961: LD_VAR 0 3
16965: PPUSH
16966: LD_INT 3
16968: PPUSH
16969: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16973: LD_VAR 0 3
16977: PPUSH
16978: LD_INT 29
16980: PPUSH
16981: LD_INT 0
16983: PPUSH
16984: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16988: LD_INT 0
16990: PPUSH
16991: LD_INT 6
16993: PUSH
16994: LD_OWVAR 67
16998: PLUS
16999: PPUSH
17000: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17004: CALL_OW 44
17008: PPUSH
17009: LD_VAR 0 3
17013: PPUSH
17014: CALL_OW 52
// end ;
17018: GO 16929
17020: POP
17021: POP
// for i = 1 to 5 + Difficulty do
17022: LD_ADDR_VAR 0 2
17026: PUSH
17027: DOUBLE
17028: LD_INT 1
17030: DEC
17031: ST_TO_ADDR
17032: LD_INT 5
17034: PUSH
17035: LD_OWVAR 67
17039: PLUS
17040: PUSH
17041: FOR_TO
17042: IFFALSE 17169
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
17044: LD_INT 14
17046: PPUSH
17047: LD_INT 1
17049: PPUSH
17050: LD_INT 3
17052: PPUSH
17053: CALL_OW 12
17057: PPUSH
17058: LD_INT 1
17060: PPUSH
17061: LD_INT 28
17063: PUSH
17064: LD_INT 26
17066: PUSH
17067: LD_INT 27
17069: PUSH
17070: LD_INT 25
17072: PUSH
17073: EMPTY
17074: LIST
17075: LIST
17076: LIST
17077: LIST
17078: PUSH
17079: LD_VAR 0 2
17083: PUSH
17084: LD_INT 4
17086: MOD
17087: PUSH
17088: LD_INT 1
17090: PLUS
17091: ARRAY
17092: PPUSH
17093: LD_INT 80
17095: PPUSH
17096: CALL 75959 0 5
// veh := CreateVehicle ;
17100: LD_ADDR_VAR 0 3
17104: PUSH
17105: CALL_OW 45
17109: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17110: LD_VAR 0 3
17114: PPUSH
17115: LD_INT 4
17117: PPUSH
17118: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17122: LD_VAR 0 3
17126: PPUSH
17127: LD_INT 28
17129: PPUSH
17130: LD_INT 0
17132: PPUSH
17133: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
17137: LD_INT 0
17139: PPUSH
17140: LD_INT 6
17142: PUSH
17143: LD_OWVAR 67
17147: PLUS
17148: PPUSH
17149: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
17153: CALL_OW 44
17157: PPUSH
17158: LD_VAR 0 3
17162: PPUSH
17163: CALL_OW 52
// end ;
17167: GO 17041
17169: POP
17170: POP
// for i = 1 to Difficulty do
17171: LD_ADDR_VAR 0 2
17175: PUSH
17176: DOUBLE
17177: LD_INT 1
17179: DEC
17180: ST_TO_ADDR
17181: LD_OWVAR 67
17185: PUSH
17186: FOR_TO
17187: IFFALSE 17247
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
17189: LD_INT 14
17191: PPUSH
17192: LD_INT 3
17194: PPUSH
17195: LD_INT 5
17197: PPUSH
17198: LD_INT 29
17200: PPUSH
17201: LD_INT 80
17203: PPUSH
17204: CALL 75959 0 5
// veh := CreateVehicle ;
17208: LD_ADDR_VAR 0 3
17212: PUSH
17213: CALL_OW 45
17217: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
17218: LD_VAR 0 3
17222: PPUSH
17223: LD_INT 4
17225: PPUSH
17226: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
17230: LD_VAR 0 3
17234: PPUSH
17235: LD_INT 28
17237: PPUSH
17238: LD_INT 0
17240: PPUSH
17241: CALL_OW 49
// end ;
17245: GO 17186
17247: POP
17248: POP
// end ;
17249: LD_VAR 0 1
17253: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
17254: LD_INT 22
17256: PUSH
17257: LD_INT 2
17259: PUSH
17260: EMPTY
17261: LIST
17262: LIST
17263: PPUSH
17264: CALL_OW 69
17268: IFFALSE 17647
17270: GO 17272
17272: DISABLE
17273: LD_INT 0
17275: PPUSH
17276: PPUSH
17277: PPUSH
17278: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
17279: LD_ADDR_VAR 0 3
17283: PUSH
17284: LD_INT 22
17286: PUSH
17287: LD_INT 2
17289: PUSH
17290: EMPTY
17291: LIST
17292: LIST
17293: PUSH
17294: LD_INT 25
17296: PUSH
17297: LD_INT 4
17299: PUSH
17300: EMPTY
17301: LIST
17302: LIST
17303: PUSH
17304: EMPTY
17305: LIST
17306: LIST
17307: PPUSH
17308: CALL_OW 69
17312: PUSH
17313: LD_EXP 99
17317: DIFF
17318: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
17319: LD_ADDR_VAR 0 2
17323: PUSH
17324: LD_INT 22
17326: PUSH
17327: LD_INT 2
17329: PUSH
17330: EMPTY
17331: LIST
17332: LIST
17333: PPUSH
17334: CALL_OW 69
17338: PUSH
17339: LD_EXP 99
17343: PUSH
17344: LD_VAR 0 3
17348: UNION
17349: DIFF
17350: ST_TO_ADDR
// if Khatam then
17351: LD_EXP 99
17355: IFFALSE 17372
// ComMoveXY ( Khatam , 211 , 92 ) ;
17357: LD_EXP 99
17361: PPUSH
17362: LD_INT 211
17364: PPUSH
17365: LD_INT 92
17367: PPUSH
17368: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
17372: LD_INT 197
17374: PPUSH
17375: LD_INT 80
17377: PPUSH
17378: LD_INT 2
17380: PPUSH
17381: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
17385: LD_INT 213
17387: PPUSH
17388: LD_INT 90
17390: PPUSH
17391: LD_INT 2
17393: PPUSH
17394: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
17398: LD_INT 215
17400: PPUSH
17401: LD_INT 129
17403: PPUSH
17404: LD_INT 2
17406: PPUSH
17407: CALL_OW 441
// if sci then
17411: LD_VAR 0 3
17415: IFFALSE 17436
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
17417: LD_VAR 0 3
17421: PUSH
17422: LD_INT 1
17424: ARRAY
17425: PPUSH
17426: LD_INT 197
17428: PPUSH
17429: LD_INT 80
17431: PPUSH
17432: CALL_OW 158
// if sci > 1 then
17436: LD_VAR 0 3
17440: PUSH
17441: LD_INT 1
17443: GREATER
17444: IFFALSE 17465
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
17446: LD_VAR 0 3
17450: PUSH
17451: LD_INT 2
17453: ARRAY
17454: PPUSH
17455: LD_INT 213
17457: PPUSH
17458: LD_INT 90
17460: PPUSH
17461: CALL_OW 158
// if sci > 2 then
17465: LD_VAR 0 3
17469: PUSH
17470: LD_INT 2
17472: GREATER
17473: IFFALSE 17494
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
17475: LD_VAR 0 3
17479: PUSH
17480: LD_INT 3
17482: ARRAY
17483: PPUSH
17484: LD_INT 215
17486: PPUSH
17487: LD_INT 129
17489: PPUSH
17490: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
17494: LD_VAR 0 2
17498: PPUSH
17499: LD_INT 195
17501: PPUSH
17502: LD_INT 102
17504: PPUSH
17505: CALL_OW 114
// wait ( 0 0$5 ) ;
17509: LD_INT 175
17511: PPUSH
17512: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
17516: LD_INT 70
17518: PPUSH
17519: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
17523: LD_ADDR_VAR 0 4
17527: PUSH
17528: LD_INT 92
17530: PUSH
17531: LD_INT 195
17533: PUSH
17534: LD_INT 102
17536: PUSH
17537: LD_INT 36
17539: PUSH
17540: EMPTY
17541: LIST
17542: LIST
17543: LIST
17544: LIST
17545: PUSH
17546: LD_INT 22
17548: PUSH
17549: LD_INT 1
17551: PUSH
17552: EMPTY
17553: LIST
17554: LIST
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: PPUSH
17560: CALL_OW 69
17564: ST_TO_ADDR
// for i in tmp do
17565: LD_ADDR_VAR 0 1
17569: PUSH
17570: LD_VAR 0 2
17574: PUSH
17575: FOR_IN
17576: IFFALSE 17627
// if enemy then
17578: LD_VAR 0 4
17582: IFFALSE 17610
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
17584: LD_VAR 0 1
17588: PPUSH
17589: LD_VAR 0 4
17593: PPUSH
17594: LD_VAR 0 1
17598: PPUSH
17599: CALL_OW 74
17603: PPUSH
17604: CALL_OW 115
17608: GO 17625
// ComAgressiveMove ( i , 195 , 102 ) ;
17610: LD_VAR 0 1
17614: PPUSH
17615: LD_INT 195
17617: PPUSH
17618: LD_INT 102
17620: PPUSH
17621: CALL_OW 114
17625: GO 17575
17627: POP
17628: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
17629: LD_VAR 0 2
17633: PPUSH
17634: LD_INT 50
17636: PUSH
17637: EMPTY
17638: LIST
17639: PPUSH
17640: CALL_OW 72
17644: NOT
17645: IFFALSE 17516
// end ; end_of_file
17647: PPOPN 4
17649: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad , hasSomethingToSay ; begin
17650: LD_INT 0
17652: PPUSH
17653: PPUSH
17654: PPUSH
17655: PPUSH
17656: PPUSH
17657: PPUSH
17658: PPUSH
17659: PPUSH
17660: PPUSH
17661: PPUSH
// Video ( true ) ;
17662: LD_INT 1
17664: PPUSH
17665: CALL 109111 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17669: LD_ADDR_VAR 0 5
17673: PUSH
17674: LD_INT 7
17676: PPUSH
17677: LD_INT 0
17679: PPUSH
17680: CALL_OW 517
17684: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17685: LD_ADDR_VAR 0 2
17689: PUSH
17690: DOUBLE
17691: LD_INT 1
17693: DEC
17694: ST_TO_ADDR
17695: LD_VAR 0 5
17699: PUSH
17700: LD_INT 1
17702: ARRAY
17703: PUSH
17704: FOR_TO
17705: IFFALSE 17750
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17707: LD_VAR 0 5
17711: PUSH
17712: LD_INT 1
17714: ARRAY
17715: PUSH
17716: LD_VAR 0 2
17720: ARRAY
17721: PPUSH
17722: LD_VAR 0 5
17726: PUSH
17727: LD_INT 2
17729: ARRAY
17730: PUSH
17731: LD_VAR 0 2
17735: ARRAY
17736: PPUSH
17737: LD_INT 1
17739: PPUSH
17740: LD_INT 15
17742: NEG
17743: PPUSH
17744: CALL 109023 0 4
17748: GO 17704
17750: POP
17751: POP
// CenterNowOnUnits ( Powell ) ;
17752: LD_EXP 61
17756: PPUSH
17757: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17761: LD_ADDR_VAR 0 5
17765: PUSH
17766: LD_EXP 59
17770: PUSH
17771: EMPTY
17772: LIST
17773: ST_TO_ADDR
// if GirlNewVeh then
17774: LD_EXP 60
17778: IFFALSE 17796
// tmp := tmp ^ GirlNewVeh ;
17780: LD_ADDR_VAR 0 5
17784: PUSH
17785: LD_VAR 0 5
17789: PUSH
17790: LD_EXP 60
17794: ADD
17795: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17796: LD_VAR 0 5
17800: PPUSH
17801: LD_INT 60
17803: PPUSH
17804: LD_INT 109
17806: PPUSH
17807: CALL_OW 111
// if KappaStatus then
17811: LD_EXP 2
17815: IFFALSE 17867
// begin Say ( JMM , D1nT-JMM-1 ) ;
17817: LD_EXP 40
17821: PPUSH
17822: LD_STRING D1nT-JMM-1
17824: PPUSH
17825: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17829: LD_EXP 61
17833: PPUSH
17834: LD_STRING D1T-Pow-1
17836: PPUSH
17837: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17841: LD_EXP 40
17845: PPUSH
17846: LD_STRING D1T-JMM-2
17848: PPUSH
17849: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17853: LD_EXP 61
17857: PPUSH
17858: LD_STRING D1T-Pow-2
17860: PPUSH
17861: CALL_OW 88
// end else
17865: GO 18073
// if JMMGirlStatus then
17867: LD_EXP 6
17871: IFFALSE 18016
// begin Say ( JMM , D1T-JMM-1 ) ;
17873: LD_EXP 40
17877: PPUSH
17878: LD_STRING D1T-JMM-1
17880: PPUSH
17881: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17885: LD_EXP 61
17889: PPUSH
17890: LD_STRING D1T-Pow-1
17892: PPUSH
17893: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17897: LD_EXP 40
17901: PPUSH
17902: LD_STRING D1T-JMM-3
17904: PPUSH
17905: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17909: LD_EXP 61
17913: PPUSH
17914: LD_STRING D1T-Pow-3
17916: PPUSH
17917: CALL_OW 88
// if JMMGirl then
17921: LD_EXP 7
17925: IFFALSE 18014
// begin case JMMGirl of 1 :
17927: LD_EXP 7
17931: PUSH
17932: LD_INT 1
17934: DOUBLE
17935: EQUAL
17936: IFTRUE 17940
17938: GO 17955
17940: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17941: LD_EXP 41
17945: PPUSH
17946: LD_STRING D1T-Joan-3
17948: PPUSH
17949: CALL_OW 88
17953: GO 18002
17955: LD_INT 2
17957: DOUBLE
17958: EQUAL
17959: IFTRUE 17963
17961: GO 17978
17963: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17964: LD_EXP 43
17968: PPUSH
17969: LD_STRING D1T-Lisa-3
17971: PPUSH
17972: CALL_OW 88
17976: GO 18002
17978: LD_INT 3
17980: DOUBLE
17981: EQUAL
17982: IFTRUE 17986
17984: GO 18001
17986: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17987: LD_EXP 55
17991: PPUSH
17992: LD_STRING D1T-Con-3
17994: PPUSH
17995: CALL_OW 88
17999: GO 18002
18001: POP
// Say ( Powell , D1T-Pow-4 ) ;
18002: LD_EXP 61
18006: PPUSH
18007: LD_STRING D1T-Pow-4
18009: PPUSH
18010: CALL_OW 88
// end ; end else
18014: GO 18073
// if not FastEnd then
18016: LD_EXP 11
18020: NOT
18021: IFFALSE 18049
// begin Say ( JMM , D1T-JMM-4 ) ;
18023: LD_EXP 40
18027: PPUSH
18028: LD_STRING D1T-JMM-4
18030: PPUSH
18031: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
18035: LD_EXP 61
18039: PPUSH
18040: LD_STRING D1T-Pow-5
18042: PPUSH
18043: CALL_OW 88
// end else
18047: GO 18073
// begin Say ( JMM , D1nT-JMM-1 ) ;
18049: LD_EXP 40
18053: PPUSH
18054: LD_STRING D1nT-JMM-1
18056: PPUSH
18057: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
18061: LD_EXP 61
18065: PPUSH
18066: LD_STRING D1nT-Pow-1
18068: PPUSH
18069: CALL_OW 88
// end ; repeat wait ( 3 ) ;
18073: LD_INT 3
18075: PPUSH
18076: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
18080: LD_EXP 59
18084: PPUSH
18085: CALL_OW 314
18089: NOT
18090: IFFALSE 18073
// ComExitVehicle ( JMM ) ;
18092: LD_EXP 40
18096: PPUSH
18097: CALL_OW 121
// repeat wait ( 3 ) ;
18101: LD_INT 3
18103: PPUSH
18104: CALL_OW 67
// until not IsInUnit ( JMM ) ;
18108: LD_EXP 40
18112: PPUSH
18113: CALL_OW 310
18117: NOT
18118: IFFALSE 18101
// ComMoveXY ( JMM , 60 , 94 ) ;
18120: LD_EXP 40
18124: PPUSH
18125: LD_INT 60
18127: PPUSH
18128: LD_INT 94
18130: PPUSH
18131: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18135: LD_EXP 40
18139: PPUSH
18140: LD_EXP 61
18144: PPUSH
18145: CALL_OW 179
// if Joan then
18149: LD_EXP 41
18153: IFFALSE 18207
// begin ComExitVehicle ( Joan ) ;
18155: LD_EXP 41
18159: PPUSH
18160: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
18164: LD_EXP 41
18168: PPUSH
18169: LD_INT 35
18171: PPUSH
18172: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
18176: LD_EXP 41
18180: PPUSH
18181: LD_INT 65
18183: PPUSH
18184: LD_INT 104
18186: PPUSH
18187: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
18191: LD_EXP 41
18195: PPUSH
18196: LD_EXP 40
18200: PPUSH
18201: CALL_OW 179
// end else
18205: GO 18345
// if Lisa and JMMGirl = 2 then
18207: LD_EXP 43
18211: IFFALSE 18223
18213: PUSH
18214: LD_EXP 7
18218: PUSH
18219: LD_INT 2
18221: EQUAL
18222: AND
18223: IFFALSE 18277
// begin ComExitVehicle ( Lisa ) ;
18225: LD_EXP 43
18229: PPUSH
18230: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
18234: LD_EXP 43
18238: PPUSH
18239: LD_INT 35
18241: PPUSH
18242: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
18246: LD_EXP 43
18250: PPUSH
18251: LD_INT 65
18253: PPUSH
18254: LD_INT 104
18256: PPUSH
18257: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
18261: LD_EXP 43
18265: PPUSH
18266: LD_EXP 40
18270: PPUSH
18271: CALL_OW 179
// end else
18275: GO 18345
// if Connie and JMMGirl = 3 then
18277: LD_EXP 55
18281: IFFALSE 18293
18283: PUSH
18284: LD_EXP 7
18288: PUSH
18289: LD_INT 3
18291: EQUAL
18292: AND
18293: IFFALSE 18345
// begin ComExitVehicle ( Connie ) ;
18295: LD_EXP 55
18299: PPUSH
18300: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
18304: LD_EXP 55
18308: PPUSH
18309: LD_INT 35
18311: PPUSH
18312: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
18316: LD_EXP 55
18320: PPUSH
18321: LD_INT 65
18323: PPUSH
18324: LD_INT 104
18326: PPUSH
18327: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
18331: LD_EXP 55
18335: PPUSH
18336: LD_EXP 40
18340: PPUSH
18341: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
18345: LD_INT 35
18347: PPUSH
18348: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
18352: LD_EXP 40
18356: PPUSH
18357: LD_EXP 61
18361: PPUSH
18362: CALL_OW 296
18366: PUSH
18367: LD_INT 8
18369: LESS
18370: IFFALSE 18345
// wait ( 0 0$0.5 ) ;
18372: LD_INT 18
18374: PPUSH
18375: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
18379: LD_EXP 40
18383: PPUSH
18384: LD_STRING D1-JMM-1
18386: PPUSH
18387: CALL_OW 88
// async ;
18391: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
18392: LD_EXP 61
18396: PPUSH
18397: LD_STRING D1-Pow-1
18399: PPUSH
18400: CALL_OW 88
// if not dialogue_skipped then
18404: LD_OWVAR 59
18408: NOT
18409: IFFALSE 18418
// wait ( 0 0$2 ) ;
18411: LD_INT 70
18413: PPUSH
18414: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
18418: LD_INT 170
18420: PPUSH
18421: LD_INT 99
18423: PPUSH
18424: LD_INT 1
18426: PPUSH
18427: LD_INT 6
18429: NEG
18430: PPUSH
18431: CALL 109023 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
18435: LD_INT 174
18437: PPUSH
18438: LD_INT 115
18440: PPUSH
18441: LD_INT 1
18443: PPUSH
18444: LD_INT 6
18446: NEG
18447: PPUSH
18448: CALL 109023 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
18452: LD_INT 169
18454: PPUSH
18455: LD_INT 71
18457: PPUSH
18458: LD_INT 1
18460: PPUSH
18461: LD_INT 6
18463: NEG
18464: PPUSH
18465: CALL 109023 0 4
// if not dialogue_skipped then
18469: LD_OWVAR 59
18473: NOT
18474: IFFALSE 18493
// begin CenterOnXY ( 170 , 99 ) ;
18476: LD_INT 170
18478: PPUSH
18479: LD_INT 99
18481: PPUSH
18482: CALL_OW 84
// wait ( 0 0$2.3 ) ;
18486: LD_INT 80
18488: PPUSH
18489: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
18493: LD_INT 75
18495: PPUSH
18496: LD_INT 53
18498: PPUSH
18499: LD_INT 1
18501: PPUSH
18502: LD_INT 9
18504: NEG
18505: PPUSH
18506: CALL 109023 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
18510: LD_INT 54
18512: PPUSH
18513: LD_INT 42
18515: PPUSH
18516: LD_INT 1
18518: PPUSH
18519: LD_INT 9
18521: NEG
18522: PPUSH
18523: CALL 109023 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
18527: LD_INT 62
18529: PPUSH
18530: LD_INT 51
18532: PPUSH
18533: LD_INT 1
18535: PPUSH
18536: LD_INT 9
18538: NEG
18539: PPUSH
18540: CALL 109023 0 4
// if not dialogue_skipped then
18544: LD_OWVAR 59
18548: NOT
18549: IFFALSE 18568
// begin CenterOnXY ( 75 , 53 ) ;
18551: LD_INT 75
18553: PPUSH
18554: LD_INT 53
18556: PPUSH
18557: CALL_OW 84
// wait ( 0 0$4 ) ;
18561: LD_INT 140
18563: PPUSH
18564: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
18568: LD_EXP 61
18572: PPUSH
18573: CALL_OW 87
// if not dialogue_skipped then
18577: LD_OWVAR 59
18581: NOT
18582: IFFALSE 18591
// wait ( 0 0$2 ) ;
18584: LD_INT 70
18586: PPUSH
18587: CALL_OW 67
// sync ;
18591: SYNC
// Say ( JMM , D1-JMM-2 ) ;
18592: LD_EXP 40
18596: PPUSH
18597: LD_STRING D1-JMM-2
18599: PPUSH
18600: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
18604: LD_EXP 61
18608: PPUSH
18609: LD_STRING D1-Pow-2
18611: PPUSH
18612: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
18616: LD_EXP 40
18620: PPUSH
18621: LD_STRING D1-JMM-3
18623: PPUSH
18624: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
18628: LD_EXP 61
18632: PPUSH
18633: LD_STRING D1-Pow-3
18635: PPUSH
18636: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
18640: LD_EXP 40
18644: PPUSH
18645: LD_STRING D1-JMM-4
18647: PPUSH
18648: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
18652: LD_EXP 61
18656: PPUSH
18657: LD_STRING D1-Pow-4
18659: PPUSH
18660: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18664: LD_EXP 40
18668: PPUSH
18669: LD_STRING D1-JMM-5
18671: PPUSH
18672: CALL_OW 88
// async ;
18676: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18677: LD_EXP 61
18681: PPUSH
18682: LD_STRING D1-Pow-5
18684: PPUSH
18685: CALL_OW 88
// if not dialogue_skipped then
18689: LD_OWVAR 59
18693: NOT
18694: IFFALSE 18703
// wait ( 0 0$3.6 ) ;
18696: LD_INT 126
18698: PPUSH
18699: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18703: LD_INT 134
18705: PPUSH
18706: LD_INT 210
18708: PPUSH
18709: LD_INT 1
18711: PPUSH
18712: LD_INT 11
18714: NEG
18715: PPUSH
18716: CALL 109023 0 4
// if not dialogue_skipped then
18720: LD_OWVAR 59
18724: NOT
18725: IFFALSE 18744
// begin CenterOnXY ( 134 , 210 ) ;
18727: LD_INT 134
18729: PPUSH
18730: LD_INT 210
18732: PPUSH
18733: CALL_OW 84
// wait ( 0 0$2 ) ;
18737: LD_INT 70
18739: PPUSH
18740: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18744: LD_INT 101
18746: PPUSH
18747: LD_INT 159
18749: PPUSH
18750: LD_INT 1
18752: PPUSH
18753: LD_INT 10
18755: NEG
18756: PPUSH
18757: CALL 109023 0 4
// if not dialogue_skipped then
18761: LD_OWVAR 59
18765: NOT
18766: IFFALSE 18785
// begin CenterOnXY ( 101 , 159 ) ;
18768: LD_INT 101
18770: PPUSH
18771: LD_INT 159
18773: PPUSH
18774: CALL_OW 84
// wait ( 0 0$2 ) ;
18778: LD_INT 70
18780: PPUSH
18781: CALL_OW 67
// end ; sync ;
18785: SYNC
// CenterNowOnUnits ( Powell ) ;
18786: LD_EXP 61
18790: PPUSH
18791: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18795: LD_ADDR_VAR 0 6
18799: PUSH
18800: LD_INT 1
18802: PUSH
18803: LD_INT 2
18805: PUSH
18806: LD_INT 3
18808: PUSH
18809: LD_INT 4
18811: PUSH
18812: LD_INT 5
18814: PUSH
18815: LD_INT 6
18817: PUSH
18818: EMPTY
18819: LIST
18820: LIST
18821: LIST
18822: LIST
18823: LIST
18824: LIST
18825: ST_TO_ADDR
// if not dialogue_skipped then
18826: LD_OWVAR 59
18830: NOT
18831: IFFALSE 19002
// begin game_speed := 4 ;
18833: LD_ADDR_OWVAR 65
18837: PUSH
18838: LD_INT 4
18840: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18841: LD_INT 210
18843: PPUSH
18844: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18848: LD_ADDR_VAR 0 7
18852: PUSH
18853: LD_STRING Q1
18855: PPUSH
18856: LD_VAR 0 6
18860: PPUSH
18861: CALL_OW 98
18865: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18866: LD_ADDR_VAR 0 7
18870: PUSH
18871: LD_STRING Q1
18873: PPUSH
18874: LD_VAR 0 6
18878: PPUSH
18879: CALL_OW 98
18883: ST_TO_ADDR
// options := options diff dec ;
18884: LD_ADDR_VAR 0 6
18888: PUSH
18889: LD_VAR 0 6
18893: PUSH
18894: LD_VAR 0 7
18898: DIFF
18899: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18900: LD_VAR 0 7
18904: PPUSH
18905: LD_VAR 0 6
18909: PPUSH
18910: CALL 20690 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18914: LD_VAR 0 7
18918: PUSH
18919: LD_INT 5
18921: PUSH
18922: LD_INT 6
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: IN
18929: IFTRUE 18941
18931: PUSH
18932: LD_VAR 0 6
18936: PUSH
18937: LD_INT 2
18939: EQUAL
18940: OR
18941: IFFALSE 18866
// if not ( dec in [ 5 , 6 ] ) then
18943: LD_VAR 0 7
18947: PUSH
18948: LD_INT 5
18950: PUSH
18951: LD_INT 6
18953: PUSH
18954: EMPTY
18955: LIST
18956: LIST
18957: IN
18958: NOT
18959: IFFALSE 19002
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18961: LD_ADDR_VAR 0 7
18965: PUSH
18966: LD_STRING Q1a
18968: PPUSH
18969: LD_INT 1
18971: PUSH
18972: LD_INT 2
18974: PUSH
18975: EMPTY
18976: LIST
18977: LIST
18978: PPUSH
18979: CALL_OW 98
18983: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18984: LD_VAR 0 7
18988: PUSH
18989: LD_INT 4
18991: PLUS
18992: PPUSH
18993: LD_VAR 0 6
18997: PPUSH
18998: CALL 20690 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
19002: LD_INT 81
19004: PPUSH
19005: LD_INT 127
19007: PPUSH
19008: CALL_OW 84
// amount := 8 ;
19012: LD_ADDR_VAR 0 8
19016: PUSH
19017: LD_INT 8
19019: ST_TO_ADDR
// macmilan_squad := [ ] ;
19020: LD_ADDR_VAR 0 9
19024: PUSH
19025: EMPTY
19026: ST_TO_ADDR
// if vip < amount then
19027: LD_EXP 62
19031: PUSH
19032: LD_VAR 0 8
19036: LESS
19037: IFFALSE 19092
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_type , unit_human ] ] ) else
19039: LD_ADDR_VAR 0 5
19043: PUSH
19044: LD_EXP 62
19048: PUSH
19049: LD_INT 22
19051: PUSH
19052: LD_INT 4
19054: PUSH
19055: EMPTY
19056: LIST
19057: LIST
19058: PUSH
19059: LD_INT 23
19061: PUSH
19062: LD_INT 1
19064: PUSH
19065: EMPTY
19066: LIST
19067: LIST
19068: PUSH
19069: LD_INT 21
19071: PUSH
19072: LD_INT 1
19074: PUSH
19075: EMPTY
19076: LIST
19077: LIST
19078: PUSH
19079: EMPTY
19080: LIST
19081: LIST
19082: LIST
19083: PPUSH
19084: CALL_OW 69
19088: UNION
19089: ST_TO_ADDR
19090: GO 19102
// tmp := vip ;
19092: LD_ADDR_VAR 0 5
19096: PUSH
19097: LD_EXP 62
19101: ST_TO_ADDR
// tmp := tmp diff Powell ;
19102: LD_ADDR_VAR 0 5
19106: PUSH
19107: LD_VAR 0 5
19111: PUSH
19112: LD_EXP 61
19116: DIFF
19117: ST_TO_ADDR
// if tmp < amount then
19118: LD_VAR 0 5
19122: PUSH
19123: LD_VAR 0 8
19127: LESS
19128: IFFALSE 19140
// amount := tmp ;
19130: LD_ADDR_VAR 0 8
19134: PUSH
19135: LD_VAR 0 5
19139: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
19140: LD_VAR 0 5
19144: PUSH
19145: LD_INT 1
19147: ARRAY
19148: PPUSH
19149: CALL_OW 257
19153: PUSH
19154: LD_INT 2
19156: NONEQUAL
19157: IFFALSE 19255
// begin if IsInUnit ( tmp [ 1 ] ) then
19159: LD_VAR 0 5
19163: PUSH
19164: LD_INT 1
19166: ARRAY
19167: PPUSH
19168: CALL_OW 310
19172: IFFALSE 19187
// ComExitBuilding ( tmp [ 1 ] ) ;
19174: LD_VAR 0 5
19178: PUSH
19179: LD_INT 1
19181: ARRAY
19182: PPUSH
19183: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
19187: LD_INT 387
19189: PPUSH
19190: CALL_OW 313
19194: PUSH
19195: LD_INT 6
19197: EQUAL
19198: IFFALSE 19223
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
19200: LD_INT 387
19202: PPUSH
19203: CALL_OW 313
19207: PUSH
19208: LD_INT 1
19210: ARRAY
19211: PPUSH
19212: CALL_OW 122
// wait ( 3 ) ;
19216: LD_INT 3
19218: PPUSH
19219: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
19223: LD_VAR 0 5
19227: PUSH
19228: LD_INT 1
19230: ARRAY
19231: PPUSH
19232: LD_INT 387
19234: PPUSH
19235: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
19239: LD_VAR 0 5
19243: PUSH
19244: LD_INT 1
19246: ARRAY
19247: PPUSH
19248: LD_INT 2
19250: PPUSH
19251: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
19255: LD_EXP 40
19259: PPUSH
19260: LD_INT 82
19262: PPUSH
19263: LD_INT 129
19265: PPUSH
19266: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
19270: LD_EXP 40
19274: PPUSH
19275: LD_EXP 61
19279: PPUSH
19280: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
19284: LD_INT 22
19286: PUSH
19287: LD_INT 1
19289: PUSH
19290: EMPTY
19291: LIST
19292: LIST
19293: PPUSH
19294: CALL_OW 69
19298: PUSH
19299: LD_EXP 40
19303: DIFF
19304: PPUSH
19305: LD_INT 84
19307: PPUSH
19308: LD_INT 128
19310: PPUSH
19311: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
19315: LD_INT 22
19317: PUSH
19318: LD_INT 1
19320: PUSH
19321: EMPTY
19322: LIST
19323: LIST
19324: PPUSH
19325: CALL_OW 69
19329: PUSH
19330: LD_EXP 40
19334: DIFF
19335: PPUSH
19336: LD_EXP 40
19340: PPUSH
19341: CALL_OW 179
// for i = 1 to amount do
19345: LD_ADDR_VAR 0 2
19349: PUSH
19350: DOUBLE
19351: LD_INT 1
19353: DEC
19354: ST_TO_ADDR
19355: LD_VAR 0 8
19359: PUSH
19360: FOR_TO
19361: IFFALSE 19531
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
19363: LD_ADDR_VAR 0 9
19367: PUSH
19368: LD_VAR 0 9
19372: PUSH
19373: LD_VAR 0 5
19377: PUSH
19378: LD_VAR 0 2
19382: ARRAY
19383: ADD
19384: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
19385: LD_VAR 0 5
19389: PUSH
19390: LD_VAR 0 2
19394: ARRAY
19395: PPUSH
19396: CALL_OW 310
19400: IFFALSE 19417
// AddComExitBuilding ( tmp [ i ] ) ;
19402: LD_VAR 0 5
19406: PUSH
19407: LD_VAR 0 2
19411: ARRAY
19412: PPUSH
19413: CALL_OW 182
// if i = 2 and JMMNewVeh then
19417: LD_VAR 0 2
19421: PUSH
19422: LD_INT 2
19424: EQUAL
19425: IFFALSE 19433
19427: PUSH
19428: LD_EXP 59
19432: AND
19433: IFFALSE 19491
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
19435: LD_VAR 0 5
19439: PUSH
19440: LD_VAR 0 2
19444: ARRAY
19445: PPUSH
19446: LD_EXP 59
19450: PPUSH
19451: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
19455: LD_VAR 0 5
19459: PUSH
19460: LD_VAR 0 2
19464: ARRAY
19465: PPUSH
19466: LD_INT 86
19468: PPUSH
19469: LD_INT 133
19471: PPUSH
19472: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
19476: LD_VAR 0 5
19480: PUSH
19481: LD_VAR 0 2
19485: ARRAY
19486: PPUSH
19487: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
19491: LD_VAR 0 5
19495: PUSH
19496: LD_VAR 0 2
19500: ARRAY
19501: PPUSH
19502: LD_INT 8
19504: PPUSH
19505: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
19509: LD_VAR 0 5
19513: PUSH
19514: LD_VAR 0 2
19518: ARRAY
19519: PPUSH
19520: LD_EXP 40
19524: PPUSH
19525: CALL_OW 179
// end ;
19529: GO 19360
19531: POP
19532: POP
// if GirlNewVeh then
19533: LD_EXP 60
19537: IFFALSE 19551
// SetSide ( GirlNewVeh , 4 ) ;
19539: LD_EXP 60
19543: PPUSH
19544: LD_INT 4
19546: PPUSH
19547: CALL_OW 235
// if Mike then
19551: LD_EXP 57
19555: IFFALSE 19592
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
19557: LD_ADDR_VAR 0 9
19561: PUSH
19562: LD_VAR 0 9
19566: PPUSH
19567: LD_EXP 57
19571: PPUSH
19572: CALL 109139 0 2
19576: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
19577: LD_EXP 57
19581: PPUSH
19582: LD_INT 86
19584: PPUSH
19585: LD_INT 133
19587: PPUSH
19588: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
19592: LD_INT 35
19594: PPUSH
19595: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
19599: LD_VAR 0 9
19603: PPUSH
19604: LD_INT 95
19606: PUSH
19607: LD_INT 9
19609: PUSH
19610: EMPTY
19611: LIST
19612: LIST
19613: PPUSH
19614: CALL_OW 72
19618: PUSH
19619: LD_INT 0
19621: EQUAL
19622: IFFALSE 19639
19624: PUSH
19625: LD_EXP 40
19629: PPUSH
19630: LD_INT 9
19632: PPUSH
19633: CALL_OW 308
19637: NOT
19638: AND
19639: IFFALSE 19592
// wait ( 0 0$2 ) ;
19641: LD_INT 70
19643: PPUSH
19644: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
19648: LD_VAR 0 9
19652: PPUSH
19653: LD_INT 1
19655: PPUSH
19656: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
19660: LD_INT 21
19662: PUSH
19663: LD_INT 2
19665: PUSH
19666: EMPTY
19667: LIST
19668: LIST
19669: PUSH
19670: LD_INT 92
19672: PUSH
19673: LD_INT 83
19675: PUSH
19676: LD_INT 130
19678: PUSH
19679: LD_INT 10
19681: PUSH
19682: EMPTY
19683: LIST
19684: LIST
19685: LIST
19686: LIST
19687: PUSH
19688: EMPTY
19689: LIST
19690: LIST
19691: PPUSH
19692: CALL_OW 69
19696: PPUSH
19697: LD_INT 1
19699: PPUSH
19700: CALL_OW 235
// tick := 0 ;
19704: LD_ADDR_OWVAR 1
19708: PUSH
19709: LD_INT 0
19711: ST_TO_ADDR
// Video ( false ) ;
19712: LD_INT 0
19714: PPUSH
19715: CALL 109111 0 1
// ChangeMissionObjectives ( M1 ) ;
19719: LD_STRING M1
19721: PPUSH
19722: CALL_OW 337
// SaveForQuickRestart ;
19726: CALL_OW 22
// missionStart := true ;
19730: LD_ADDR_EXP 13
19734: PUSH
19735: LD_INT 1
19737: ST_TO_ADDR
// missionStage := 2 ;
19738: LD_ADDR_EXP 15
19742: PUSH
19743: LD_INT 2
19745: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19746: LD_INT 35
19748: PPUSH
19749: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19753: LD_ADDR_VAR 0 5
19757: PUSH
19758: LD_INT 22
19760: PUSH
19761: LD_INT 4
19763: PUSH
19764: EMPTY
19765: LIST
19766: LIST
19767: PUSH
19768: LD_INT 21
19770: PUSH
19771: LD_INT 1
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: PUSH
19778: EMPTY
19779: LIST
19780: LIST
19781: PPUSH
19782: CALL_OW 69
19786: PUSH
19787: LD_EXP 61
19791: DIFF
19792: ST_TO_ADDR
// if not tmp then
19793: LD_VAR 0 5
19797: NOT
19798: IFFALSE 19813
// tmp := [ Powell ] ;
19800: LD_ADDR_VAR 0 5
19804: PUSH
19805: LD_EXP 61
19809: PUSH
19810: EMPTY
19811: LIST
19812: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19813: LD_ADDR_VAR 0 4
19817: PUSH
19818: LD_INT 22
19820: PUSH
19821: LD_INT 4
19823: PUSH
19824: EMPTY
19825: LIST
19826: LIST
19827: PUSH
19828: LD_INT 34
19830: PUSH
19831: LD_INT 12
19833: PUSH
19834: EMPTY
19835: LIST
19836: LIST
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PPUSH
19842: CALL_OW 69
19846: PUSH
19847: LD_INT 1
19849: ARRAY
19850: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19851: LD_VAR 0 5
19855: PUSH
19856: LD_INT 1
19858: ARRAY
19859: PPUSH
19860: CALL_OW 310
19864: IFFALSE 19879
// ComExitBuilding ( tmp [ 1 ] ) ;
19866: LD_VAR 0 5
19870: PUSH
19871: LD_INT 1
19873: ARRAY
19874: PPUSH
19875: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19879: LD_VAR 0 5
19883: PUSH
19884: LD_INT 1
19886: ARRAY
19887: PPUSH
19888: LD_VAR 0 4
19892: PPUSH
19893: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19897: LD_VAR 0 5
19901: PUSH
19902: LD_INT 1
19904: ARRAY
19905: PPUSH
19906: LD_INT 80
19908: PPUSH
19909: LD_INT 136
19911: PPUSH
19912: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19916: LD_VAR 0 5
19920: PUSH
19921: LD_INT 1
19923: ARRAY
19924: PPUSH
19925: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19929: LD_VAR 0 5
19933: PUSH
19934: LD_INT 1
19936: ARRAY
19937: PPUSH
19938: LD_INT 59
19940: PPUSH
19941: LD_INT 112
19943: PPUSH
19944: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19948: LD_VAR 0 5
19952: PUSH
19953: LD_INT 1
19955: ARRAY
19956: PPUSH
19957: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 and JMMGirl = 1 then
19961: LD_EXP 41
19965: IFFALSE 19982
19967: PUSH
19968: LD_EXP 41
19972: PPUSH
19973: CALL_OW 255
19977: PUSH
19978: LD_INT 1
19980: EQUAL
19981: AND
19982: IFFALSE 19994
19984: PUSH
19985: LD_EXP 7
19989: PUSH
19990: LD_INT 1
19992: EQUAL
19993: AND
19994: IFFALSE 20020
// begin Say ( Joan , D3W-Joan-1 ) ;
19996: LD_EXP 41
20000: PPUSH
20001: LD_STRING D3W-Joan-1
20003: PPUSH
20004: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20008: LD_EXP 40
20012: PPUSH
20013: LD_STRING D3W-JMM-1
20015: PPUSH
20016: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip and JMMGirl = 2 then
20020: LD_EXP 43
20024: IFFALSE 20041
20026: PUSH
20027: LD_EXP 43
20031: PPUSH
20032: CALL_OW 255
20036: PUSH
20037: LD_INT 1
20039: EQUAL
20040: AND
20041: IFFALSE 20056
20043: PUSH
20044: LD_EXP 43
20048: PUSH
20049: LD_EXP 62
20053: IN
20054: NOT
20055: AND
20056: IFFALSE 20068
20058: PUSH
20059: LD_EXP 7
20063: PUSH
20064: LD_INT 2
20066: EQUAL
20067: AND
20068: IFFALSE 20094
// begin Say ( Lisa , D3W-Lisa-1 ) ;
20070: LD_EXP 43
20074: PPUSH
20075: LD_STRING D3W-Lisa-1
20077: PPUSH
20078: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20082: LD_EXP 40
20086: PPUSH
20087: LD_STRING D3W-JMM-1
20089: PPUSH
20090: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 and JMMGirl = 3 then
20094: LD_EXP 55
20098: IFFALSE 20115
20100: PUSH
20101: LD_EXP 55
20105: PPUSH
20106: CALL_OW 255
20110: PUSH
20111: LD_INT 1
20113: EQUAL
20114: AND
20115: IFFALSE 20127
20117: PUSH
20118: LD_EXP 7
20122: PUSH
20123: LD_INT 3
20125: EQUAL
20126: AND
20127: IFFALSE 20153
// begin Say ( Connie , D3W-Con-1 ) ;
20129: LD_EXP 55
20133: PPUSH
20134: LD_STRING D3W-Con-1
20136: PPUSH
20137: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
20141: LD_EXP 40
20145: PPUSH
20146: LD_STRING D3W-JMM-1
20148: PPUSH
20149: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
20153: LD_INT 18
20155: PPUSH
20156: CALL_OW 67
// hasSomethingToSay := false ;
20160: LD_ADDR_VAR 0 10
20164: PUSH
20165: LD_INT 0
20167: ST_TO_ADDR
// if Lisa in vip and GetSide ( Lisa ) = 1 then
20168: LD_EXP 43
20172: PUSH
20173: LD_EXP 62
20177: IN
20178: IFFALSE 20195
20180: PUSH
20181: LD_EXP 43
20185: PPUSH
20186: CALL_OW 255
20190: PUSH
20191: LD_INT 1
20193: EQUAL
20194: AND
20195: IFFALSE 20219
// begin hasSomethingToSay := true ;
20197: LD_ADDR_VAR 0 10
20201: PUSH
20202: LD_INT 1
20204: ST_TO_ADDR
// Say ( Lisa , D3nW-Lisa-1 ) ;
20205: LD_EXP 43
20209: PPUSH
20210: LD_STRING D3nW-Lisa-1
20212: PPUSH
20213: CALL_OW 88
// end else
20217: GO 20523
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
20219: LD_EXP 46
20223: PUSH
20224: LD_EXP 62
20228: IN
20229: IFFALSE 20246
20231: PUSH
20232: LD_EXP 46
20236: PPUSH
20237: CALL_OW 255
20241: PUSH
20242: LD_INT 1
20244: EQUAL
20245: AND
20246: IFFALSE 20270
// begin hasSomethingToSay := true ;
20248: LD_ADDR_VAR 0 10
20252: PUSH
20253: LD_INT 1
20255: ST_TO_ADDR
// Say ( Cyrus , D3nW-Cyrus-1 ) ;
20256: LD_EXP 46
20260: PPUSH
20261: LD_STRING D3nW-Cyrus-1
20263: PPUSH
20264: CALL_OW 88
// end else
20268: GO 20523
// if Bobby in vip and GetSide ( Bobby ) = 1 then
20270: LD_EXP 45
20274: PUSH
20275: LD_EXP 62
20279: IN
20280: IFFALSE 20297
20282: PUSH
20283: LD_EXP 45
20287: PPUSH
20288: CALL_OW 255
20292: PUSH
20293: LD_INT 1
20295: EQUAL
20296: AND
20297: IFFALSE 20321
// begin hasSomethingToSay := true ;
20299: LD_ADDR_VAR 0 10
20303: PUSH
20304: LD_INT 1
20306: ST_TO_ADDR
// Say ( Bobby , D3nW-Bobby-1 ) ;
20307: LD_EXP 45
20311: PPUSH
20312: LD_STRING D3nW-Bobby-1
20314: PPUSH
20315: CALL_OW 88
// end else
20319: GO 20523
// if Gary in vip and GetSide ( Gary ) = 1 then
20321: LD_EXP 52
20325: PUSH
20326: LD_EXP 62
20330: IN
20331: IFFALSE 20348
20333: PUSH
20334: LD_EXP 52
20338: PPUSH
20339: CALL_OW 255
20343: PUSH
20344: LD_INT 1
20346: EQUAL
20347: AND
20348: IFFALSE 20372
// begin hasSomethingToSay := true ;
20350: LD_ADDR_VAR 0 10
20354: PUSH
20355: LD_INT 1
20357: ST_TO_ADDR
// Say ( Gary , D3nW-Gary-1 ) ;
20358: LD_EXP 52
20362: PPUSH
20363: LD_STRING D3nW-Gary-1
20365: PPUSH
20366: CALL_OW 88
// end else
20370: GO 20523
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
20372: LD_EXP 44
20376: PUSH
20377: LD_EXP 62
20381: IN
20382: IFFALSE 20399
20384: PUSH
20385: LD_EXP 44
20389: PPUSH
20390: CALL_OW 255
20394: PUSH
20395: LD_INT 1
20397: EQUAL
20398: AND
20399: IFFALSE 20423
// begin hasSomethingToSay := true ;
20401: LD_ADDR_VAR 0 10
20405: PUSH
20406: LD_INT 1
20408: ST_TO_ADDR
// Say ( Donaldson , D3nW-Don-1 ) ;
20409: LD_EXP 44
20413: PPUSH
20414: LD_STRING D3nW-Don-1
20416: PPUSH
20417: CALL_OW 88
// end else
20421: GO 20523
// if Cornel in vip and GetSide ( Cornel ) = 1 then
20423: LD_EXP 51
20427: PUSH
20428: LD_EXP 62
20432: IN
20433: IFFALSE 20450
20435: PUSH
20436: LD_EXP 51
20440: PPUSH
20441: CALL_OW 255
20445: PUSH
20446: LD_INT 1
20448: EQUAL
20449: AND
20450: IFFALSE 20474
// begin hasSomethingToSay := true ;
20452: LD_ADDR_VAR 0 10
20456: PUSH
20457: LD_INT 1
20459: ST_TO_ADDR
// Say ( Cornel , D3nW-Corn-1 ) ;
20460: LD_EXP 51
20464: PPUSH
20465: LD_STRING D3nW-Corn-1
20467: PPUSH
20468: CALL_OW 88
// end else
20472: GO 20523
// if Frank in vip and GetSide ( Frank ) = 1 then
20474: LD_EXP 53
20478: PUSH
20479: LD_EXP 62
20483: IN
20484: IFFALSE 20501
20486: PUSH
20487: LD_EXP 53
20491: PPUSH
20492: CALL_OW 255
20496: PUSH
20497: LD_INT 1
20499: EQUAL
20500: AND
20501: IFFALSE 20523
// begin hasSomethingToSay := true ;
20503: LD_ADDR_VAR 0 10
20507: PUSH
20508: LD_INT 1
20510: ST_TO_ADDR
// Say ( Frank , D3nW-Frank-1 ) ;
20511: LD_EXP 53
20515: PPUSH
20516: LD_STRING D3nW-Frank-1
20518: PPUSH
20519: CALL_OW 88
// end ; if hasSomethingToSay then
20523: LD_VAR 0 10
20527: IFFALSE 20553
// begin Say ( JMM , D3nW-JMM-1 ) ;
20529: LD_EXP 40
20533: PPUSH
20534: LD_STRING D3nW-JMM-1
20536: PPUSH
20537: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
20541: LD_EXP 40
20545: PPUSH
20546: LD_STRING D3nW-JMM-1a
20548: PPUSH
20549: CALL_OW 88
// end ; t := 0 0$00 ;
20553: LD_ADDR_VAR 0 3
20557: PUSH
20558: LD_INT 0
20560: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20561: LD_INT 35
20563: PPUSH
20564: CALL_OW 67
// t := t + 0 0$1 ;
20568: LD_ADDR_VAR 0 3
20572: PUSH
20573: LD_VAR 0 3
20577: PUSH
20578: LD_INT 35
20580: PLUS
20581: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
20582: LD_INT 59
20584: PPUSH
20585: LD_INT 112
20587: PPUSH
20588: CALL_OW 428
20592: IFTRUE 20604
20594: PUSH
20595: LD_VAR 0 3
20599: PUSH
20600: LD_INT 2100
20602: GREATER
20603: OR
20604: IFFALSE 20561
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
20606: LD_ADDR_EXP 102
20610: PUSH
20611: LD_EXP 102
20615: PPUSH
20616: LD_INT 4
20618: PPUSH
20619: LD_INT 22
20621: PUSH
20622: LD_INT 4
20624: PUSH
20625: EMPTY
20626: LIST
20627: LIST
20628: PUSH
20629: LD_INT 23
20631: PUSH
20632: LD_INT 1
20634: PUSH
20635: EMPTY
20636: LIST
20637: LIST
20638: PUSH
20639: LD_INT 3
20641: PUSH
20642: LD_INT 21
20644: PUSH
20645: LD_INT 2
20647: PUSH
20648: EMPTY
20649: LIST
20650: LIST
20651: PUSH
20652: EMPTY
20653: LIST
20654: LIST
20655: PUSH
20656: EMPTY
20657: LIST
20658: LIST
20659: LIST
20660: PPUSH
20661: CALL_OW 69
20665: PUSH
20666: LD_EXP 61
20670: DIFF
20671: PPUSH
20672: CALL_OW 1
20676: ST_TO_ADDR
// activeAttacks := true ;
20677: LD_ADDR_EXP 16
20681: PUSH
20682: LD_INT 1
20684: ST_TO_ADDR
// end ;
20685: LD_VAR 0 1
20689: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
20690: LD_INT 0
20692: PPUSH
// case question of 1 :
20693: LD_VAR 0 1
20697: PUSH
20698: LD_INT 1
20700: DOUBLE
20701: EQUAL
20702: IFTRUE 20706
20704: GO 20757
20706: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
20707: LD_EXP 40
20711: PPUSH
20712: LD_STRING D2Mot-JMM-1
20714: PPUSH
20715: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
20719: LD_EXP 61
20723: PPUSH
20724: LD_STRING D2Mot-Pow-1
20726: PPUSH
20727: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
20731: LD_EXP 40
20735: PPUSH
20736: LD_STRING D2Mot-JMM-2
20738: PPUSH
20739: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
20743: LD_EXP 61
20747: PPUSH
20748: LD_STRING D2Mot-Pow-2
20750: PPUSH
20751: CALL_OW 88
// end ; 2 :
20755: GO 21108
20757: LD_INT 2
20759: DOUBLE
20760: EQUAL
20761: IFTRUE 20765
20763: GO 20841
20765: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
20766: LD_EXP 40
20770: PPUSH
20771: LD_STRING D2Rus-JMM-1
20773: PPUSH
20774: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
20778: LD_EXP 61
20782: PPUSH
20783: LD_STRING D2Rus-Pow-1
20785: PPUSH
20786: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20790: LD_EXP 40
20794: PPUSH
20795: LD_STRING D2Rus-JMM-2
20797: PPUSH
20798: CALL_OW 88
// if not ( 3 in list_of_q ) then
20802: LD_INT 3
20804: PUSH
20805: LD_VAR 0 2
20809: IN
20810: NOT
20811: IFFALSE 20827
// Say ( Powell , D2Rus-Pow-2 ) else
20813: LD_EXP 61
20817: PPUSH
20818: LD_STRING D2Rus-Pow-2
20820: PPUSH
20821: CALL_OW 88
20825: GO 20839
// Say ( Powell , D2Rus-Pow-2a ) ;
20827: LD_EXP 61
20831: PPUSH
20832: LD_STRING D2Rus-Pow-2a
20834: PPUSH
20835: CALL_OW 88
// end ; 3 :
20839: GO 21108
20841: LD_INT 3
20843: DOUBLE
20844: EQUAL
20845: IFTRUE 20849
20847: GO 20934
20849: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20850: LD_EXP 40
20854: PPUSH
20855: LD_STRING D2Leg-JMM-1
20857: PPUSH
20858: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20862: LD_EXP 61
20866: PPUSH
20867: LD_STRING D2Leg-Pow-1
20869: PPUSH
20870: CALL_OW 88
// if 2 in list_of_q then
20874: LD_INT 2
20876: PUSH
20877: LD_VAR 0 2
20881: IN
20882: IFFALSE 20908
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20884: LD_EXP 40
20888: PPUSH
20889: LD_STRING D2Leg-JMM-2
20891: PPUSH
20892: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20896: LD_EXP 61
20900: PPUSH
20901: LD_STRING D2Leg-Pow-2
20903: PPUSH
20904: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20908: LD_EXP 40
20912: PPUSH
20913: LD_STRING D2Leg-JMM-3
20915: PPUSH
20916: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20920: LD_EXP 61
20924: PPUSH
20925: LD_STRING D2Leg-Pow-3
20927: PPUSH
20928: CALL_OW 88
// end ; 4 :
20932: GO 21108
20934: LD_INT 4
20936: DOUBLE
20937: EQUAL
20938: IFTRUE 20942
20940: GO 21017
20942: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20943: LD_EXP 40
20947: PPUSH
20948: LD_STRING D2Ar-JMM-1
20950: PPUSH
20951: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20955: LD_EXP 61
20959: PPUSH
20960: LD_STRING D2Ar-Pow-1
20962: PPUSH
20963: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20967: LD_EXP 40
20971: PPUSH
20972: LD_STRING D2Ar-JMM-2
20974: PPUSH
20975: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20979: LD_EXP 61
20983: PPUSH
20984: LD_STRING D2Ar-Pow-2
20986: PPUSH
20987: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20991: LD_EXP 40
20995: PPUSH
20996: LD_STRING D2Ar-JMM-3
20998: PPUSH
20999: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
21003: LD_EXP 61
21007: PPUSH
21008: LD_STRING D2Ar-Pow-3
21010: PPUSH
21011: CALL_OW 88
// end ; 5 :
21015: GO 21108
21017: LD_INT 5
21019: DOUBLE
21020: EQUAL
21021: IFTRUE 21025
21023: GO 21040
21025: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
21026: LD_EXP 40
21030: PPUSH
21031: LD_STRING D2Conf-JMM-1
21033: PPUSH
21034: CALL_OW 88
21038: GO 21108
21040: LD_INT 6
21042: DOUBLE
21043: EQUAL
21044: IFTRUE 21048
21046: GO 21107
21048: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
21049: LD_EXP 40
21053: PPUSH
21054: LD_STRING D2Com-JMM-1
21056: PPUSH
21057: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
21061: LD_EXP 61
21065: PPUSH
21066: LD_STRING D2Com-Pow-1
21068: PPUSH
21069: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
21073: LD_EXP 40
21077: PPUSH
21078: LD_STRING D2Com-JMM-2
21080: PPUSH
21081: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
21085: LD_EXP 61
21089: PPUSH
21090: LD_STRING D2Com-Pow-2
21092: PPUSH
21093: CALL_OW 88
// powellAngerQuery := true ;
21097: LD_ADDR_EXP 36
21101: PUSH
21102: LD_INT 1
21104: ST_TO_ADDR
// end ; end ;
21105: GO 21108
21107: POP
// end ;
21108: LD_VAR 0 3
21112: RET
// every 0 0$5 trigger missionStart do var tmp ;
21113: LD_EXP 13
21117: IFFALSE 21444
21119: GO 21121
21121: DISABLE
21122: LD_INT 0
21124: PPUSH
// begin repeat wait ( 0 0$1 ) ;
21125: LD_INT 35
21127: PPUSH
21128: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
21132: LD_INT 14
21134: PPUSH
21135: LD_INT 22
21137: PUSH
21138: LD_INT 1
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: PUSH
21145: LD_INT 3
21147: PUSH
21148: LD_INT 21
21150: PUSH
21151: LD_INT 3
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: PUSH
21158: EMPTY
21159: LIST
21160: LIST
21161: PUSH
21162: EMPTY
21163: LIST
21164: LIST
21165: PPUSH
21166: CALL_OW 70
21170: IFFALSE 21197
21172: PUSH
21173: LD_EXP 15
21177: PUSH
21178: LD_INT 2
21180: PUSH
21181: LD_INT 3
21183: PUSH
21184: LD_INT 4
21186: PUSH
21187: LD_INT 5
21189: PUSH
21190: EMPTY
21191: LIST
21192: LIST
21193: LIST
21194: LIST
21195: IN
21196: AND
21197: IFFALSE 21434
// begin powellAnger := powellAnger + 1 ;
21199: LD_ADDR_EXP 17
21203: PUSH
21204: LD_EXP 17
21208: PUSH
21209: LD_INT 1
21211: PLUS
21212: ST_TO_ADDR
// Video ( true ) ;
21213: LD_INT 1
21215: PPUSH
21216: CALL 109111 0 1
// CenterNowOnUnits ( tmp ) ;
21220: LD_VAR 0 1
21224: PPUSH
21225: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21229: LD_INT 14
21231: PPUSH
21232: LD_INT 22
21234: PUSH
21235: LD_INT 1
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: PPUSH
21242: CALL_OW 70
21246: PPUSH
21247: LD_INT 86
21249: PPUSH
21250: LD_INT 133
21252: PPUSH
21253: CALL_OW 111
// async ;
21257: ASYNC
// case powellAnger of 1 :
21258: LD_EXP 17
21262: PUSH
21263: LD_INT 1
21265: DOUBLE
21266: EQUAL
21267: IFTRUE 21271
21269: GO 21286
21271: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
21272: LD_EXP 61
21276: PPUSH
21277: LD_STRING DBack1-Pow-1
21279: PPUSH
21280: CALL_OW 88
21284: GO 21333
21286: LD_INT 2
21288: DOUBLE
21289: EQUAL
21290: IFTRUE 21294
21292: GO 21309
21294: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
21295: LD_EXP 61
21299: PPUSH
21300: LD_STRING DBack2-Pow-1
21302: PPUSH
21303: CALL_OW 88
21307: GO 21333
21309: LD_INT 3
21311: DOUBLE
21312: EQUAL
21313: IFTRUE 21317
21315: GO 21332
21317: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
21318: LD_EXP 61
21322: PPUSH
21323: LD_STRING DBack3-Pow-1
21325: PPUSH
21326: CALL_OW 88
21330: GO 21333
21332: POP
// sync ;
21333: SYNC
// repeat wait ( 0 0$1 ) ;
21334: LD_INT 35
21336: PPUSH
21337: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
21341: LD_INT 14
21343: PPUSH
21344: LD_INT 22
21346: PUSH
21347: LD_INT 1
21349: PUSH
21350: EMPTY
21351: LIST
21352: LIST
21353: PPUSH
21354: CALL_OW 70
21358: PPUSH
21359: LD_INT 86
21361: PPUSH
21362: LD_INT 133
21364: PPUSH
21365: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21369: LD_INT 14
21371: PPUSH
21372: LD_INT 22
21374: PUSH
21375: LD_INT 1
21377: PUSH
21378: EMPTY
21379: LIST
21380: LIST
21381: PUSH
21382: LD_INT 3
21384: PUSH
21385: LD_INT 21
21387: PUSH
21388: LD_INT 3
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: PUSH
21395: EMPTY
21396: LIST
21397: LIST
21398: PUSH
21399: EMPTY
21400: LIST
21401: LIST
21402: PPUSH
21403: CALL_OW 70
21407: NOT
21408: IFFALSE 21334
// if powellAnger >= 3 then
21410: LD_EXP 17
21414: PUSH
21415: LD_INT 3
21417: GREATEREQUAL
21418: IFFALSE 21427
// YouLost ( Dismissed ) ;
21420: LD_STRING Dismissed
21422: PPUSH
21423: CALL_OW 104
// Video ( false ) ;
21427: LD_INT 0
21429: PPUSH
21430: CALL 109111 0 1
// end ; until missionStage > 5 ;
21434: LD_EXP 15
21438: PUSH
21439: LD_INT 5
21441: GREATER
21442: IFFALSE 21125
// end ;
21444: PPOPN 1
21446: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t , p ;
21447: LD_EXP 13
21451: IFFALSE 21487
21453: PUSH
21454: LD_INT 22
21456: PUSH
21457: LD_INT 4
21459: PUSH
21460: EMPTY
21461: LIST
21462: LIST
21463: PUSH
21464: LD_INT 21
21466: PUSH
21467: LD_INT 2
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: PUSH
21474: EMPTY
21475: LIST
21476: LIST
21477: PPUSH
21478: CALL_OW 69
21482: PUSH
21483: LD_INT 4
21485: GREATEREQUAL
21486: AND
21487: IFFALSE 21499
21489: PUSH
21490: LD_EXP 15
21494: PUSH
21495: LD_INT 2
21497: EQUAL
21498: AND
21499: IFFALSE 24127
21501: GO 21503
21503: DISABLE
21504: LD_INT 0
21506: PPUSH
21507: PPUSH
21508: PPUSH
21509: PPUSH
21510: PPUSH
21511: PPUSH
21512: PPUSH
21513: PPUSH
21514: PPUSH
21515: PPUSH
21516: PPUSH
// begin missionStage := 3 ;
21517: LD_ADDR_EXP 15
21521: PUSH
21522: LD_INT 3
21524: ST_TO_ADDR
// retreat := false ;
21525: LD_ADDR_VAR 0 4
21529: PUSH
21530: LD_INT 0
21532: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
21533: LD_ADDR_VAR 0 5
21537: PUSH
21538: LD_INT 22
21540: PUSH
21541: LD_INT 4
21543: PUSH
21544: EMPTY
21545: LIST
21546: LIST
21547: PUSH
21548: LD_INT 30
21550: PUSH
21551: LD_INT 4
21553: PUSH
21554: EMPTY
21555: LIST
21556: LIST
21557: PUSH
21558: EMPTY
21559: LIST
21560: LIST
21561: PPUSH
21562: CALL_OW 69
21566: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21567: LD_ADDR_VAR 0 6
21571: PUSH
21572: LD_INT 22
21574: PUSH
21575: LD_INT 4
21577: PUSH
21578: EMPTY
21579: LIST
21580: LIST
21581: PUSH
21582: LD_INT 30
21584: PUSH
21585: LD_INT 5
21587: PUSH
21588: EMPTY
21589: LIST
21590: LIST
21591: PUSH
21592: EMPTY
21593: LIST
21594: LIST
21595: PPUSH
21596: CALL_OW 69
21600: ST_TO_ADDR
// if not bar then
21601: LD_VAR 0 6
21605: NOT
21606: IFFALSE 21659
// begin repeat wait ( 0 0$1 ) ;
21608: LD_INT 35
21610: PPUSH
21611: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
21615: LD_INT 22
21617: PUSH
21618: LD_INT 4
21620: PUSH
21621: EMPTY
21622: LIST
21623: LIST
21624: PUSH
21625: LD_INT 3
21627: PUSH
21628: LD_INT 57
21630: PUSH
21631: EMPTY
21632: LIST
21633: PUSH
21634: EMPTY
21635: LIST
21636: LIST
21637: PUSH
21638: LD_INT 30
21640: PUSH
21641: LD_INT 5
21643: PUSH
21644: EMPTY
21645: LIST
21646: LIST
21647: PUSH
21648: EMPTY
21649: LIST
21650: LIST
21651: LIST
21652: PPUSH
21653: CALL_OW 69
21657: IFFALSE 21608
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
21659: LD_ADDR_VAR 0 6
21663: PUSH
21664: LD_INT 22
21666: PUSH
21667: LD_INT 4
21669: PUSH
21670: EMPTY
21671: LIST
21672: LIST
21673: PUSH
21674: LD_INT 30
21676: PUSH
21677: LD_INT 5
21679: PUSH
21680: EMPTY
21681: LIST
21682: LIST
21683: PUSH
21684: EMPTY
21685: LIST
21686: LIST
21687: PPUSH
21688: CALL_OW 69
21692: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
21693: LD_INT 35
21695: PPUSH
21696: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
21700: LD_EXP 121
21704: PUSH
21705: LD_INT 4
21707: ARRAY
21708: PUSH
21709: LD_INT 4
21711: GREATEREQUAL
21712: IFFALSE 21693
// tmp := [ ] ;
21714: LD_ADDR_VAR 0 2
21718: PUSH
21719: EMPTY
21720: ST_TO_ADDR
// tmp2 := [ ] ;
21721: LD_ADDR_VAR 0 3
21725: PUSH
21726: EMPTY
21727: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell union vip ) do
21728: LD_ADDR_VAR 0 1
21732: PUSH
21733: LD_INT 22
21735: PUSH
21736: LD_INT 4
21738: PUSH
21739: EMPTY
21740: LIST
21741: LIST
21742: PUSH
21743: LD_INT 2
21745: PUSH
21746: LD_INT 25
21748: PUSH
21749: LD_INT 1
21751: PUSH
21752: EMPTY
21753: LIST
21754: LIST
21755: PUSH
21756: LD_INT 25
21758: PUSH
21759: LD_INT 2
21761: PUSH
21762: EMPTY
21763: LIST
21764: LIST
21765: PUSH
21766: LD_INT 25
21768: PUSH
21769: LD_INT 3
21771: PUSH
21772: EMPTY
21773: LIST
21774: LIST
21775: PUSH
21776: LD_INT 25
21778: PUSH
21779: LD_INT 4
21781: PUSH
21782: EMPTY
21783: LIST
21784: LIST
21785: PUSH
21786: LD_INT 25
21788: PUSH
21789: LD_INT 5
21791: PUSH
21792: EMPTY
21793: LIST
21794: LIST
21795: PUSH
21796: EMPTY
21797: LIST
21798: LIST
21799: LIST
21800: LIST
21801: LIST
21802: LIST
21803: PUSH
21804: EMPTY
21805: LIST
21806: LIST
21807: PPUSH
21808: CALL_OW 69
21812: PUSH
21813: LD_EXP 61
21817: PUSH
21818: LD_EXP 62
21822: UNION
21823: DIFF
21824: PUSH
21825: FOR_IN
21826: IFFALSE 21888
// if not i in extraSquad then
21828: LD_VAR 0 1
21832: PUSH
21833: LD_EXP 63
21837: IN
21838: NOT
21839: IFFALSE 21863
// tmp := Join ( tmp , i ) else
21841: LD_ADDR_VAR 0 2
21845: PUSH
21846: LD_VAR 0 2
21850: PPUSH
21851: LD_VAR 0 1
21855: PPUSH
21856: CALL 109139 0 2
21860: ST_TO_ADDR
21861: GO 21886
// tmp := Insert ( tmp , 1 , i ) ;
21863: LD_ADDR_VAR 0 2
21867: PUSH
21868: LD_VAR 0 2
21872: PPUSH
21873: LD_INT 1
21875: PPUSH
21876: LD_VAR 0 1
21880: PPUSH
21881: CALL_OW 2
21885: ST_TO_ADDR
21886: GO 21825
21888: POP
21889: POP
// tmp := tmp diff 0 ;
21890: LD_ADDR_VAR 0 2
21894: PUSH
21895: LD_VAR 0 2
21899: PUSH
21900: LD_INT 0
21902: DIFF
21903: ST_TO_ADDR
// p := 0 ;
21904: LD_ADDR_VAR 0 11
21908: PUSH
21909: LD_INT 0
21911: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_sex , sex_male ] ) do
21912: LD_ADDR_VAR 0 1
21916: PUSH
21917: LD_VAR 0 2
21921: PPUSH
21922: LD_INT 26
21924: PUSH
21925: LD_INT 1
21927: PUSH
21928: EMPTY
21929: LIST
21930: LIST
21931: PPUSH
21932: CALL_OW 72
21936: PUSH
21937: FOR_IN
21938: IFFALSE 21989
// begin p := Inc ( p ) ;
21940: LD_ADDR_VAR 0 11
21944: PUSH
21945: LD_VAR 0 11
21949: PPUSH
21950: CALL 110512 0 1
21954: ST_TO_ADDR
// tmp2 := Join ( tmp2 , i ) ;
21955: LD_ADDR_VAR 0 3
21959: PUSH
21960: LD_VAR 0 3
21964: PPUSH
21965: LD_VAR 0 1
21969: PPUSH
21970: CALL 109139 0 2
21974: ST_TO_ADDR
// if p = 4 then
21975: LD_VAR 0 11
21979: PUSH
21980: LD_INT 4
21982: EQUAL
21983: IFFALSE 21987
// break ;
21985: GO 21989
// end ;
21987: GO 21937
21989: POP
21990: POP
// tmp := tmp diff tmp2 ;
21991: LD_ADDR_VAR 0 2
21995: PUSH
21996: LD_VAR 0 2
22000: PUSH
22001: LD_VAR 0 3
22005: DIFF
22006: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
22007: LD_ADDR_VAR 0 2
22011: PUSH
22012: LD_VAR 0 2
22016: PPUSH
22017: LD_INT 3
22019: PPUSH
22020: CALL 107619 0 2
22024: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
22025: LD_ADDR_VAR 0 3
22029: PUSH
22030: LD_VAR 0 3
22034: PPUSH
22035: LD_INT 3
22037: PPUSH
22038: CALL 107619 0 2
22042: ST_TO_ADDR
// for i := 1 to 4 do
22043: LD_ADDR_VAR 0 1
22047: PUSH
22048: DOUBLE
22049: LD_INT 1
22051: DEC
22052: ST_TO_ADDR
22053: LD_INT 4
22055: PUSH
22056: FOR_TO
22057: IFFALSE 22223
// begin if tmp2 then
22059: LD_VAR 0 3
22063: IFFALSE 22144
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
22065: LD_ADDR_EXP 18
22069: PUSH
22070: LD_EXP 18
22074: PPUSH
22075: LD_INT 1
22077: PPUSH
22078: LD_EXP 18
22082: PUSH
22083: LD_INT 1
22085: ARRAY
22086: PUSH
22087: LD_VAR 0 3
22091: PUSH
22092: LD_VAR 0 3
22096: ARRAY
22097: ADD
22098: PPUSH
22099: CALL_OW 1
22103: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
22104: LD_VAR 0 3
22108: PUSH
22109: LD_VAR 0 3
22113: ARRAY
22114: PPUSH
22115: LD_INT 1
22117: PPUSH
22118: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
22122: LD_ADDR_VAR 0 3
22126: PUSH
22127: LD_VAR 0 3
22131: PPUSH
22132: LD_VAR 0 3
22136: PPUSH
22137: CALL_OW 3
22141: ST_TO_ADDR
// end else
22142: GO 22221
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
22144: LD_ADDR_EXP 18
22148: PUSH
22149: LD_EXP 18
22153: PPUSH
22154: LD_INT 1
22156: PPUSH
22157: LD_EXP 18
22161: PUSH
22162: LD_INT 1
22164: ARRAY
22165: PUSH
22166: LD_VAR 0 2
22170: PUSH
22171: LD_VAR 0 2
22175: ARRAY
22176: ADD
22177: PPUSH
22178: CALL_OW 1
22182: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
22183: LD_VAR 0 2
22187: PUSH
22188: LD_VAR 0 2
22192: ARRAY
22193: PPUSH
22194: LD_INT 1
22196: PPUSH
22197: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
22201: LD_ADDR_VAR 0 2
22205: PUSH
22206: LD_VAR 0 2
22210: PPUSH
22211: LD_VAR 0 2
22215: PPUSH
22216: CALL_OW 3
22220: ST_TO_ADDR
// end ; end ;
22221: GO 22056
22223: POP
22224: POP
// if tmp2 then
22225: LD_VAR 0 3
22229: IFFALSE 22247
// tmp := tmp union tmp2 ;
22231: LD_ADDR_VAR 0 2
22235: PUSH
22236: LD_VAR 0 2
22240: PUSH
22241: LD_VAR 0 3
22245: UNION
22246: ST_TO_ADDR
// for i := 0 to 3 do
22247: LD_ADDR_VAR 0 1
22251: PUSH
22252: DOUBLE
22253: LD_INT 0
22255: DEC
22256: ST_TO_ADDR
22257: LD_INT 3
22259: PUSH
22260: FOR_TO
22261: IFFALSE 22424
// begin if not tmp [ tmp - i ] then
22263: LD_VAR 0 2
22267: PUSH
22268: LD_VAR 0 2
22272: PUSH
22273: LD_VAR 0 1
22277: MINUS
22278: ARRAY
22279: NOT
22280: IFFALSE 22377
// begin uc_side := 4 ;
22282: LD_ADDR_OWVAR 20
22286: PUSH
22287: LD_INT 4
22289: ST_TO_ADDR
// uc_nation := 1 ;
22290: LD_ADDR_OWVAR 21
22294: PUSH
22295: LD_INT 1
22297: ST_TO_ADDR
// InitHc ;
22298: CALL_OW 19
// PrepareSoldier ( sex_male , 3 ) ;
22302: LD_INT 1
22304: PPUSH
22305: LD_INT 3
22307: PPUSH
22308: CALL_OW 381
// un := CreateHuman ;
22312: LD_ADDR_VAR 0 8
22316: PUSH
22317: CALL_OW 44
22321: ST_TO_ADDR
// PlaceHumanInUnit ( un , HexInfo ( 39 , 61 ) ) ;
22322: LD_VAR 0 8
22326: PPUSH
22327: LD_INT 39
22329: PPUSH
22330: LD_INT 61
22332: PPUSH
22333: CALL_OW 428
22337: PPUSH
22338: CALL_OW 52
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ un ) ;
22342: LD_ADDR_EXP 18
22346: PUSH
22347: LD_EXP 18
22351: PPUSH
22352: LD_INT 2
22354: PPUSH
22355: LD_EXP 18
22359: PUSH
22360: LD_INT 2
22362: ARRAY
22363: PUSH
22364: LD_VAR 0 8
22368: ADD
22369: PPUSH
22370: CALL_OW 1
22374: ST_TO_ADDR
// end else
22375: GO 22422
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
22377: LD_ADDR_EXP 18
22381: PUSH
22382: LD_EXP 18
22386: PPUSH
22387: LD_INT 2
22389: PPUSH
22390: LD_EXP 18
22394: PUSH
22395: LD_INT 2
22397: ARRAY
22398: PUSH
22399: LD_VAR 0 2
22403: PUSH
22404: LD_VAR 0 2
22408: PUSH
22409: LD_VAR 0 1
22413: MINUS
22414: ARRAY
22415: ADD
22416: PPUSH
22417: CALL_OW 1
22421: ST_TO_ADDR
// end ;
22422: GO 22260
22424: POP
22425: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
22426: LD_ADDR_EXP 102
22430: PUSH
22431: LD_EXP 102
22435: PPUSH
22436: LD_INT 4
22438: PPUSH
22439: LD_EXP 102
22443: PUSH
22444: LD_INT 4
22446: ARRAY
22447: PUSH
22448: LD_EXP 18
22452: PUSH
22453: LD_INT 1
22455: ARRAY
22456: DIFF
22457: PPUSH
22458: CALL_OW 1
22462: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
22463: LD_VAR 0 5
22467: PUSH
22468: LD_INT 1
22470: ARRAY
22471: PPUSH
22472: CALL_OW 313
22476: IFFALSE 22531
// begin for i in UnitsInside ( arm [ 1 ] ) do
22478: LD_ADDR_VAR 0 1
22482: PUSH
22483: LD_VAR 0 5
22487: PUSH
22488: LD_INT 1
22490: ARRAY
22491: PPUSH
22492: CALL_OW 313
22496: PUSH
22497: FOR_IN
22498: IFFALSE 22529
// begin ComExitBuilding ( i ) ;
22500: LD_VAR 0 1
22504: PPUSH
22505: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
22509: LD_VAR 0 1
22513: PPUSH
22514: LD_VAR 0 6
22518: PUSH
22519: LD_INT 1
22521: ARRAY
22522: PPUSH
22523: CALL_OW 180
// end ;
22527: GO 22497
22529: POP
22530: POP
// end ; wait ( 0 0$5 ) ;
22531: LD_INT 175
22533: PPUSH
22534: CALL_OW 67
// repeat wait ( 0 0$1 ) until not UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) ;
22538: LD_INT 35
22540: PPUSH
22541: CALL_OW 67
22545: LD_EXP 18
22549: PUSH
22550: LD_INT 1
22552: ARRAY
22553: PPUSH
22554: LD_INT 55
22556: PUSH
22557: EMPTY
22558: LIST
22559: PPUSH
22560: CALL_OW 72
22564: NOT
22565: IFFALSE 22538
// for i in powellSquadAttack [ 1 ] do
22567: LD_ADDR_VAR 0 1
22571: PUSH
22572: LD_EXP 18
22576: PUSH
22577: LD_INT 1
22579: ARRAY
22580: PUSH
22581: FOR_IN
22582: IFFALSE 22689
// begin if IsInUnit ( i ) then
22584: LD_VAR 0 1
22588: PPUSH
22589: CALL_OW 310
22593: IFFALSE 22604
// ComExitBuilding ( i ) ;
22595: LD_VAR 0 1
22599: PPUSH
22600: CALL_OW 122
// if GetClass ( i ) <> 1 then
22604: LD_VAR 0 1
22608: PPUSH
22609: CALL_OW 257
22613: PUSH
22614: LD_INT 1
22616: NONEQUAL
22617: IFFALSE 22658
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
22619: LD_VAR 0 1
22623: PPUSH
22624: LD_VAR 0 5
22628: PUSH
22629: LD_INT 1
22631: ARRAY
22632: PPUSH
22633: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
22637: LD_VAR 0 1
22641: PPUSH
22642: LD_INT 1
22644: PPUSH
22645: CALL_OW 183
// AddComExitBuilding ( i ) ;
22649: LD_VAR 0 1
22653: PPUSH
22654: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
22658: LD_VAR 0 1
22662: PPUSH
22663: LD_INT 60
22665: PPUSH
22666: LD_INT 94
22668: PPUSH
22669: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
22673: LD_VAR 0 1
22677: PPUSH
22678: LD_EXP 61
22682: PPUSH
22683: CALL_OW 179
// end ;
22687: GO 22581
22689: POP
22690: POP
// wait ( 0 0$45 ) ;
22691: LD_INT 1575
22693: PPUSH
22694: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
22698: LD_EXP 61
22702: PPUSH
22703: LD_STRING D4-Pow-1
22705: PPUSH
22706: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
22710: LD_ADDR_VAR 0 2
22714: PUSH
22715: LD_EXP 18
22719: PUSH
22720: LD_INT 1
22722: ARRAY
22723: PPUSH
22724: LD_INT 26
22726: PUSH
22727: LD_INT 1
22729: PUSH
22730: EMPTY
22731: LIST
22732: LIST
22733: PPUSH
22734: CALL_OW 72
22738: ST_TO_ADDR
// if tmp then
22739: LD_VAR 0 2
22743: IFFALSE 22761
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
22745: LD_VAR 0 2
22749: PUSH
22750: LD_INT 1
22752: ARRAY
22753: PPUSH
22754: LD_STRING D4-Sol1-1
22756: PPUSH
22757: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
22761: LD_EXP 61
22765: PPUSH
22766: LD_STRING D4-Pow-2
22768: PPUSH
22769: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
22773: LD_ADDR_VAR 0 1
22777: PUSH
22778: DOUBLE
22779: LD_INT 1
22781: DEC
22782: ST_TO_ADDR
22783: LD_EXP 18
22787: PUSH
22788: LD_INT 1
22790: ARRAY
22791: PUSH
22792: FOR_TO
22793: IFFALSE 22886
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
22795: LD_EXP 18
22799: PUSH
22800: LD_INT 1
22802: ARRAY
22803: PUSH
22804: LD_VAR 0 1
22808: ARRAY
22809: PPUSH
22810: LD_EXP 121
22814: PUSH
22815: LD_INT 4
22817: ARRAY
22818: PUSH
22819: LD_INT 1
22821: ARRAY
22822: PPUSH
22823: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
22827: LD_ADDR_EXP 121
22831: PUSH
22832: LD_EXP 121
22836: PPUSH
22837: LD_INT 4
22839: PPUSH
22840: LD_EXP 121
22844: PUSH
22845: LD_INT 4
22847: ARRAY
22848: PPUSH
22849: LD_INT 1
22851: PPUSH
22852: CALL_OW 3
22856: PPUSH
22857: CALL_OW 1
22861: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
22862: LD_INT 8
22864: PPUSH
22865: LD_EXP 18
22869: PUSH
22870: LD_INT 1
22872: ARRAY
22873: PUSH
22874: LD_VAR 0 1
22878: ARRAY
22879: PPUSH
22880: CALL_OW 471
// end ;
22884: GO 22792
22886: POP
22887: POP
// repeat wait ( 0 0$1 ) ;
22888: LD_INT 35
22890: PPUSH
22891: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
22895: LD_EXP 18
22899: PUSH
22900: LD_INT 1
22902: ARRAY
22903: PPUSH
22904: LD_INT 55
22906: PUSH
22907: EMPTY
22908: LIST
22909: PPUSH
22910: CALL_OW 72
22914: PUSH
22915: LD_INT 4
22917: GREATEREQUAL
22918: IFFALSE 22888
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
22920: LD_EXP 18
22924: PUSH
22925: LD_INT 1
22927: ARRAY
22928: PPUSH
22929: LD_INT 69
22931: PPUSH
22932: LD_INT 94
22934: PPUSH
22935: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
22939: LD_EXP 18
22943: PUSH
22944: LD_INT 1
22946: ARRAY
22947: PPUSH
22948: LD_INT 82
22950: PPUSH
22951: LD_INT 83
22953: PPUSH
22954: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
22958: LD_EXP 18
22962: PUSH
22963: LD_INT 1
22965: ARRAY
22966: PPUSH
22967: LD_INT 77
22969: PPUSH
22970: LD_INT 69
22972: PPUSH
22973: CALL_OW 174
// wait ( 0 0$30 ) ;
22977: LD_INT 1050
22979: PPUSH
22980: CALL_OW 67
// repeat wait ( 3 ) ;
22984: LD_INT 3
22986: PPUSH
22987: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
22991: LD_ADDR_VAR 0 1
22995: PUSH
22996: LD_EXP 18
23000: PUSH
23001: LD_INT 1
23003: ARRAY
23004: PUSH
23005: FOR_IN
23006: IFFALSE 23144
// begin if GetLives ( i ) < 990 then
23008: LD_VAR 0 1
23012: PPUSH
23013: CALL_OW 256
23017: PUSH
23018: LD_INT 990
23020: LESS
23021: IFFALSE 23035
// SetLives ( i , 1000 ) ;
23023: LD_VAR 0 1
23027: PPUSH
23028: LD_INT 1000
23030: PPUSH
23031: CALL_OW 234
// if not IsInUnit ( i ) then
23035: LD_VAR 0 1
23039: PPUSH
23040: CALL_OW 310
23044: NOT
23045: IFFALSE 23142
// begin if not HasTask ( i ) then
23047: LD_VAR 0 1
23051: PPUSH
23052: CALL_OW 314
23056: NOT
23057: IFFALSE 23074
// ComMoveXY ( i , 64 , 93 ) ;
23059: LD_VAR 0 1
23063: PPUSH
23064: LD_INT 64
23066: PPUSH
23067: LD_INT 93
23069: PPUSH
23070: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
23074: LD_VAR 0 4
23078: NOT
23079: IFFALSE 23096
23081: PUSH
23082: LD_VAR 0 1
23086: PPUSH
23087: CALL_OW 258
23091: PUSH
23092: LD_INT 1
23094: EQUAL
23095: AND
23096: IFFALSE 23142
// begin retreat := true ;
23098: LD_ADDR_VAR 0 4
23102: PUSH
23103: LD_INT 1
23105: ST_TO_ADDR
// SetTag ( i , 2 ) ;
23106: LD_VAR 0 1
23110: PPUSH
23111: LD_INT 2
23113: PPUSH
23114: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
23118: LD_VAR 0 1
23122: PPUSH
23123: LD_STRING D4a-Sol1-1
23125: PPUSH
23126: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
23130: LD_EXP 61
23134: PPUSH
23135: LD_STRING D4a-Pow-1
23137: PPUSH
23138: CALL_OW 88
// end ; end ; end ;
23142: GO 23005
23144: POP
23145: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_inarea , powellBase ] ) >= 4 ;
23146: LD_EXP 18
23150: PUSH
23151: LD_INT 1
23153: ARRAY
23154: PPUSH
23155: LD_INT 95
23157: PUSH
23158: LD_INT 9
23160: PUSH
23161: EMPTY
23162: LIST
23163: LIST
23164: PPUSH
23165: CALL_OW 72
23169: PUSH
23170: LD_INT 4
23172: GREATEREQUAL
23173: IFFALSE 22984
// for i in powellSquadAttack [ 1 ] do
23175: LD_ADDR_VAR 0 1
23179: PUSH
23180: LD_EXP 18
23184: PUSH
23185: LD_INT 1
23187: ARRAY
23188: PUSH
23189: FOR_IN
23190: IFFALSE 23326
// begin if GetTag ( i ) = 2 then
23192: LD_VAR 0 1
23196: PPUSH
23197: CALL_OW 110
23201: PUSH
23202: LD_INT 2
23204: EQUAL
23205: IFFALSE 23267
// begin ComMoveXY ( i , 60 , 94 ) ;
23207: LD_VAR 0 1
23211: PPUSH
23212: LD_INT 60
23214: PPUSH
23215: LD_INT 94
23217: PPUSH
23218: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
23222: LD_VAR 0 1
23226: PPUSH
23227: LD_EXP 61
23231: PPUSH
23232: CALL_OW 179
// wait ( 0 0$3 ) ;
23236: LD_INT 105
23238: PPUSH
23239: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
23243: LD_VAR 0 1
23247: PPUSH
23248: LD_STRING D4a-Sol1-2
23250: PPUSH
23251: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
23255: LD_EXP 61
23259: PPUSH
23260: LD_STRING D4a-Pow-2
23262: PPUSH
23263: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
23267: LD_VAR 0 1
23271: PPUSH
23272: LD_INT 0
23274: PPUSH
23275: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
23279: LD_ADDR_EXP 102
23283: PUSH
23284: LD_EXP 102
23288: PPUSH
23289: LD_INT 4
23291: PPUSH
23292: LD_EXP 102
23296: PUSH
23297: LD_INT 4
23299: ARRAY
23300: PUSH
23301: LD_VAR 0 1
23305: UNION
23306: PPUSH
23307: CALL_OW 1
23311: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
23312: LD_INT 8
23314: PPUSH
23315: LD_VAR 0 1
23319: PPUSH
23320: CALL_OW 472
// end ;
23324: GO 23189
23326: POP
23327: POP
// wait ( 1 1$00 ) ;
23328: LD_INT 2100
23330: PPUSH
23331: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23335: LD_ADDR_VAR 0 9
23339: PUSH
23340: LD_INT 22
23342: PUSH
23343: LD_INT 4
23345: PUSH
23346: EMPTY
23347: LIST
23348: LIST
23349: PUSH
23350: LD_INT 30
23352: PUSH
23353: LD_INT 32
23355: PUSH
23356: EMPTY
23357: LIST
23358: LIST
23359: PUSH
23360: LD_INT 58
23362: PUSH
23363: EMPTY
23364: LIST
23365: PUSH
23366: EMPTY
23367: LIST
23368: LIST
23369: LIST
23370: PPUSH
23371: CALL_OW 69
23375: ST_TO_ADDR
// if tmp then
23376: LD_VAR 0 2
23380: IFFALSE 23622
// begin for i := 1 to tmp do
23382: LD_ADDR_VAR 0 1
23386: PUSH
23387: DOUBLE
23388: LD_INT 1
23390: DEC
23391: ST_TO_ADDR
23392: LD_VAR 0 2
23396: PUSH
23397: FOR_TO
23398: IFFALSE 23613
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
23400: LD_ADDR_EXP 102
23404: PUSH
23405: LD_EXP 102
23409: PPUSH
23410: LD_INT 4
23412: PPUSH
23413: LD_EXP 102
23417: PUSH
23418: LD_INT 4
23420: ARRAY
23421: PUSH
23422: LD_VAR 0 2
23426: PUSH
23427: LD_VAR 0 1
23431: ARRAY
23432: DIFF
23433: PPUSH
23434: CALL_OW 1
23438: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
23439: LD_ADDR_VAR 0 10
23443: PUSH
23444: LD_VAR 0 2
23448: PUSH
23449: LD_VAR 0 1
23453: ARRAY
23454: PPUSH
23455: CALL_OW 310
23459: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
23460: LD_VAR 0 10
23464: IFFALSE 23481
23466: PUSH
23467: LD_VAR 0 10
23471: PPUSH
23472: CALL_OW 266
23476: PUSH
23477: LD_INT 32
23479: EQUAL
23480: AND
23481: IFFALSE 23485
// continue ;
23483: GO 23397
// if t then
23485: LD_VAR 0 10
23489: IFFALSE 23506
// ComExitBuilding ( tmp [ i ] ) ;
23491: LD_VAR 0 2
23495: PUSH
23496: LD_VAR 0 1
23500: ARRAY
23501: PPUSH
23502: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23506: LD_VAR 0 2
23510: PUSH
23511: LD_VAR 0 1
23515: ARRAY
23516: PPUSH
23517: LD_VAR 0 5
23521: PUSH
23522: LD_INT 1
23524: ARRAY
23525: PPUSH
23526: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23530: LD_VAR 0 2
23534: PUSH
23535: LD_VAR 0 1
23539: ARRAY
23540: PPUSH
23541: LD_INT 1
23543: PPUSH
23544: CALL_OW 183
// if emptyTowers then
23548: LD_VAR 0 9
23552: IFFALSE 23611
// begin AddComExitBuilding ( tmp [ i ] ) ;
23554: LD_VAR 0 2
23558: PUSH
23559: LD_VAR 0 1
23563: ARRAY
23564: PPUSH
23565: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
23569: LD_VAR 0 2
23573: PUSH
23574: LD_VAR 0 1
23578: ARRAY
23579: PPUSH
23580: LD_VAR 0 9
23584: PUSH
23585: LD_INT 1
23587: ARRAY
23588: PPUSH
23589: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
23593: LD_ADDR_VAR 0 9
23597: PUSH
23598: LD_VAR 0 9
23602: PPUSH
23603: LD_INT 1
23605: PPUSH
23606: CALL_OW 3
23610: ST_TO_ADDR
// end ; end ;
23611: GO 23397
23613: POP
23614: POP
// wait ( 0 0$30 ) ;
23615: LD_INT 1050
23617: PPUSH
23618: CALL_OW 67
// end ; uc_side := 6 ;
23622: LD_ADDR_OWVAR 20
23626: PUSH
23627: LD_INT 6
23629: ST_TO_ADDR
// uc_nation := 3 ;
23630: LD_ADDR_OWVAR 21
23634: PUSH
23635: LD_INT 3
23637: ST_TO_ADDR
// ru := [ ] ;
23638: LD_ADDR_VAR 0 7
23642: PUSH
23643: EMPTY
23644: ST_TO_ADDR
// for i = 1 to 5 do
23645: LD_ADDR_VAR 0 1
23649: PUSH
23650: DOUBLE
23651: LD_INT 1
23653: DEC
23654: ST_TO_ADDR
23655: LD_INT 5
23657: PUSH
23658: FOR_TO
23659: IFFALSE 23779
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
23661: LD_INT 22
23663: PUSH
23664: LD_INT 23
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: PUSH
23671: LD_INT 1
23673: PPUSH
23674: LD_INT 2
23676: PPUSH
23677: CALL_OW 12
23681: ARRAY
23682: PPUSH
23683: LD_INT 1
23685: PPUSH
23686: LD_INT 3
23688: PPUSH
23689: LD_INT 43
23691: PUSH
23692: LD_INT 44
23694: PUSH
23695: EMPTY
23696: LIST
23697: LIST
23698: PUSH
23699: LD_INT 1
23701: PPUSH
23702: LD_INT 2
23704: PPUSH
23705: CALL_OW 12
23709: ARRAY
23710: PPUSH
23711: LD_INT 89
23713: PPUSH
23714: CALL 75959 0 5
// un := CreateVehicle ;
23718: LD_ADDR_VAR 0 8
23722: PUSH
23723: CALL_OW 45
23727: ST_TO_ADDR
// SetDir ( un , 4 ) ;
23728: LD_VAR 0 8
23732: PPUSH
23733: LD_INT 4
23735: PPUSH
23736: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
23740: LD_VAR 0 8
23744: PPUSH
23745: LD_INT 136
23747: PPUSH
23748: LD_INT 90
23750: PPUSH
23751: LD_INT 8
23753: PPUSH
23754: LD_INT 0
23756: PPUSH
23757: CALL_OW 50
// ru := ru ^ un ;
23761: LD_ADDR_VAR 0 7
23765: PUSH
23766: LD_VAR 0 7
23770: PUSH
23771: LD_VAR 0 8
23775: ADD
23776: ST_TO_ADDR
// end ;
23777: GO 23658
23779: POP
23780: POP
// if ru then
23781: LD_VAR 0 7
23785: IFFALSE 23802
// ComAgressiveMove ( ru , 57 , 94 ) ;
23787: LD_VAR 0 7
23791: PPUSH
23792: LD_INT 57
23794: PPUSH
23795: LD_INT 94
23797: PPUSH
23798: CALL_OW 114
// wait ( 3 3$00 ) ;
23802: LD_INT 6300
23804: PPUSH
23805: CALL_OW 67
// p := UnitsInside ( HexInfo ( 54 , 85 ) ) ;
23809: LD_ADDR_VAR 0 11
23813: PUSH
23814: LD_INT 54
23816: PPUSH
23817: LD_INT 85
23819: PPUSH
23820: CALL_OW 428
23824: PPUSH
23825: CALL_OW 313
23829: ST_TO_ADDR
// t := 0 ;
23830: LD_ADDR_VAR 0 10
23834: PUSH
23835: LD_INT 0
23837: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_empty ] ] , [ f_btype , b_bunker ] ] ) do
23838: LD_ADDR_VAR 0 1
23842: PUSH
23843: LD_INT 22
23845: PUSH
23846: LD_INT 4
23848: PUSH
23849: EMPTY
23850: LIST
23851: LIST
23852: PUSH
23853: LD_INT 3
23855: PUSH
23856: LD_INT 58
23858: PUSH
23859: EMPTY
23860: LIST
23861: PUSH
23862: EMPTY
23863: LIST
23864: LIST
23865: PUSH
23866: LD_INT 30
23868: PUSH
23869: LD_INT 32
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: PUSH
23876: EMPTY
23877: LIST
23878: LIST
23879: LIST
23880: PPUSH
23881: CALL_OW 69
23885: PUSH
23886: FOR_IN
23887: IFFALSE 24013
// begin if p + t > 5 then
23889: LD_VAR 0 11
23893: PUSH
23894: LD_VAR 0 10
23898: PLUS
23899: PUSH
23900: LD_INT 5
23902: GREATER
23903: IFFALSE 23907
// break ;
23905: GO 24013
// un := UnitsInside ( i ) ;
23907: LD_ADDR_VAR 0 8
23911: PUSH
23912: LD_VAR 0 1
23916: PPUSH
23917: CALL_OW 313
23921: ST_TO_ADDR
// ComExitBuilding ( un ) ;
23922: LD_VAR 0 8
23926: PPUSH
23927: CALL_OW 122
// AddComEnterUnit ( un , HexInfo ( 54 , 85 ) ) ;
23931: LD_VAR 0 8
23935: PPUSH
23936: LD_INT 54
23938: PPUSH
23939: LD_INT 85
23941: PPUSH
23942: CALL_OW 428
23946: PPUSH
23947: CALL_OW 180
// AddComChangeProfession ( un , class_mechanic ) ;
23951: LD_VAR 0 8
23955: PPUSH
23956: LD_INT 3
23958: PPUSH
23959: CALL_OW 183
// t := Inc ( t ) ;
23963: LD_ADDR_VAR 0 10
23967: PUSH
23968: LD_VAR 0 10
23972: PPUSH
23973: CALL 110512 0 1
23977: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] ^ un ) ;
23978: LD_ADDR_EXP 102
23982: PUSH
23983: LD_EXP 102
23987: PPUSH
23988: LD_INT 4
23990: PPUSH
23991: LD_EXP 102
23995: PUSH
23996: LD_INT 4
23998: ARRAY
23999: PUSH
24000: LD_VAR 0 8
24004: ADD
24005: PPUSH
24006: CALL_OW 1
24010: ST_TO_ADDR
// end ;
24011: GO 23886
24013: POP
24014: POP
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
24015: LD_INT 4
24017: PPUSH
24018: LD_INT 3
24020: PUSH
24021: LD_INT 1
24023: PUSH
24024: LD_INT 1
24026: PUSH
24027: LD_INT 5
24029: PUSH
24030: EMPTY
24031: LIST
24032: LIST
24033: LIST
24034: LIST
24035: PUSH
24036: LD_INT 4
24038: PUSH
24039: LD_INT 1
24041: PUSH
24042: LD_INT 1
24044: PUSH
24045: LD_INT 6
24047: PUSH
24048: EMPTY
24049: LIST
24050: LIST
24051: LIST
24052: LIST
24053: PUSH
24054: LD_INT 4
24056: PUSH
24057: LD_INT 1
24059: PUSH
24060: LD_INT 1
24062: PUSH
24063: LD_INT 7
24065: PUSH
24066: EMPTY
24067: LIST
24068: LIST
24069: LIST
24070: LIST
24071: PUSH
24072: LD_INT 3
24074: PUSH
24075: LD_INT 1
24077: PUSH
24078: LD_INT 1
24080: PUSH
24081: LD_INT 7
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: LIST
24088: LIST
24089: PUSH
24090: LD_INT 3
24092: PUSH
24093: LD_INT 1
24095: PUSH
24096: LD_INT 1
24098: PUSH
24099: LD_INT 5
24101: PUSH
24102: EMPTY
24103: LIST
24104: LIST
24105: LIST
24106: LIST
24107: PUSH
24108: EMPTY
24109: LIST
24110: LIST
24111: LIST
24112: LIST
24113: LIST
24114: PPUSH
24115: CALL 64367 0 2
// missionStage := 4 ;
24119: LD_ADDR_EXP 15
24123: PUSH
24124: LD_INT 4
24126: ST_TO_ADDR
// end ;
24127: PPOPN 11
24129: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , t , _xy , dist , fac , arm , speaker , emp_towers , veh ;
24130: LD_EXP 15
24134: PUSH
24135: LD_INT 4
24137: EQUAL
24138: IFFALSE 24174
24140: PUSH
24141: LD_INT 22
24143: PUSH
24144: LD_INT 4
24146: PUSH
24147: EMPTY
24148: LIST
24149: LIST
24150: PUSH
24151: LD_INT 21
24153: PUSH
24154: LD_INT 2
24156: PUSH
24157: EMPTY
24158: LIST
24159: LIST
24160: PUSH
24161: EMPTY
24162: LIST
24163: LIST
24164: PPUSH
24165: CALL_OW 69
24169: PUSH
24170: LD_INT 5
24172: GREATEREQUAL
24173: AND
24174: IFFALSE 28550
24176: GO 24178
24178: DISABLE
24179: LD_INT 0
24181: PPUSH
24182: PPUSH
24183: PPUSH
24184: PPUSH
24185: PPUSH
24186: PPUSH
24187: PPUSH
24188: PPUSH
24189: PPUSH
24190: PPUSH
24191: PPUSH
24192: PPUSH
24193: PPUSH
24194: PPUSH
// begin wait ( 0 0$10 ) ;
24195: LD_INT 350
24197: PPUSH
24198: CALL_OW 67
// missionStage := 5 ;
24202: LD_ADDR_EXP 15
24206: PUSH
24207: LD_INT 5
24209: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
24210: LD_ADDR_VAR 0 11
24214: PUSH
24215: LD_INT 22
24217: PUSH
24218: LD_INT 4
24220: PUSH
24221: EMPTY
24222: LIST
24223: LIST
24224: PUSH
24225: LD_INT 2
24227: PUSH
24228: LD_INT 30
24230: PUSH
24231: LD_INT 4
24233: PUSH
24234: EMPTY
24235: LIST
24236: LIST
24237: PUSH
24238: LD_INT 30
24240: PUSH
24241: LD_INT 5
24243: PUSH
24244: EMPTY
24245: LIST
24246: LIST
24247: PUSH
24248: EMPTY
24249: LIST
24250: LIST
24251: LIST
24252: PUSH
24253: EMPTY
24254: LIST
24255: LIST
24256: PPUSH
24257: CALL_OW 69
24261: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
24262: LD_ADDR_VAR 0 6
24266: PUSH
24267: LD_INT 22
24269: PUSH
24270: LD_INT 4
24272: PUSH
24273: EMPTY
24274: LIST
24275: LIST
24276: PUSH
24277: LD_INT 21
24279: PUSH
24280: LD_INT 1
24282: PUSH
24283: EMPTY
24284: LIST
24285: LIST
24286: PUSH
24287: LD_INT 3
24289: PUSH
24290: LD_INT 25
24292: PUSH
24293: LD_INT 16
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: PUSH
24300: EMPTY
24301: LIST
24302: LIST
24303: PUSH
24304: LD_INT 3
24306: PUSH
24307: LD_INT 25
24309: PUSH
24310: LD_INT 12
24312: PUSH
24313: EMPTY
24314: LIST
24315: LIST
24316: PUSH
24317: EMPTY
24318: LIST
24319: LIST
24320: PUSH
24321: EMPTY
24322: LIST
24323: LIST
24324: LIST
24325: LIST
24326: PPUSH
24327: CALL_OW 69
24331: PUSH
24332: LD_EXP 61
24336: DIFF
24337: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
24338: LD_ADDR_VAR 0 10
24342: PUSH
24343: LD_INT 22
24345: PUSH
24346: LD_INT 4
24348: PUSH
24349: EMPTY
24350: LIST
24351: LIST
24352: PUSH
24353: LD_INT 30
24355: PUSH
24356: LD_INT 3
24358: PUSH
24359: EMPTY
24360: LIST
24361: LIST
24362: PUSH
24363: EMPTY
24364: LIST
24365: LIST
24366: PPUSH
24367: CALL_OW 69
24371: PUSH
24372: LD_INT 1
24374: ARRAY
24375: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
24376: LD_INT 350
24378: PPUSH
24379: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
24383: LD_EXP 121
24387: PUSH
24388: LD_INT 4
24390: ARRAY
24391: PUSH
24392: LD_INT 5
24394: LESS
24395: IFFALSE 24412
24397: PUSH
24398: LD_VAR 0 10
24402: PPUSH
24403: CALL_OW 461
24407: PUSH
24408: LD_INT 2
24410: EQUAL
24411: AND
24412: IFFALSE 24442
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
24414: LD_INT 4
24416: PPUSH
24417: LD_INT 3
24419: PUSH
24420: LD_INT 1
24422: PUSH
24423: LD_INT 1
24425: PUSH
24426: LD_INT 5
24428: PUSH
24429: EMPTY
24430: LIST
24431: LIST
24432: LIST
24433: LIST
24434: PUSH
24435: EMPTY
24436: LIST
24437: PPUSH
24438: CALL 64415 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
24442: LD_EXP 121
24446: PUSH
24447: LD_INT 4
24449: ARRAY
24450: PUSH
24451: LD_INT 5
24453: GREATEREQUAL
24454: IFFALSE 24481
24456: PUSH
24457: LD_EXP 121
24461: PUSH
24462: LD_INT 4
24464: ARRAY
24465: PPUSH
24466: LD_INT 58
24468: PUSH
24469: EMPTY
24470: LIST
24471: PPUSH
24472: CALL_OW 72
24476: PUSH
24477: LD_INT 5
24479: GREATEREQUAL
24480: AND
24481: IFFALSE 24376
// powellAllowRetreat := false ;
24483: LD_ADDR_EXP 19
24487: PUSH
24488: LD_INT 0
24490: ST_TO_ADDR
// activeAttacks := false ;
24491: LD_ADDR_EXP 16
24495: PUSH
24496: LD_INT 0
24498: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
24499: LD_INT 35
24501: PPUSH
24502: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
24506: LD_INT 22
24508: PUSH
24509: LD_INT 6
24511: PUSH
24512: EMPTY
24513: LIST
24514: LIST
24515: PPUSH
24516: CALL_OW 69
24520: PUSH
24521: LD_INT 0
24523: EQUAL
24524: IFFALSE 24499
// tmp := mc_vehicles [ 4 ] ;
24526: LD_ADDR_VAR 0 3
24530: PUSH
24531: LD_EXP 121
24535: PUSH
24536: LD_INT 4
24538: ARRAY
24539: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
24540: LD_ADDR_VAR 0 1
24544: PUSH
24545: DOUBLE
24546: LD_INT 1
24548: DEC
24549: ST_TO_ADDR
24550: LD_EXP 18
24554: PUSH
24555: FOR_TO
24556: IFFALSE 24880
// begin for j in powellSquadAttack [ i ] do
24558: LD_ADDR_VAR 0 2
24562: PUSH
24563: LD_EXP 18
24567: PUSH
24568: LD_VAR 0 1
24572: ARRAY
24573: PUSH
24574: FOR_IN
24575: IFFALSE 24876
// begin if j in mc_bases [ 4 ] then
24577: LD_VAR 0 2
24581: PUSH
24582: LD_EXP 102
24586: PUSH
24587: LD_INT 4
24589: ARRAY
24590: IN
24591: IFFALSE 24626
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff j ) ;
24593: LD_ADDR_EXP 102
24597: PUSH
24598: LD_EXP 102
24602: PPUSH
24603: LD_INT 4
24605: PPUSH
24606: LD_EXP 102
24610: PUSH
24611: LD_INT 4
24613: ARRAY
24614: PUSH
24615: LD_VAR 0 2
24619: DIFF
24620: PPUSH
24621: CALL_OW 1
24625: ST_TO_ADDR
// forces := forces diff j ;
24626: LD_ADDR_VAR 0 6
24630: PUSH
24631: LD_VAR 0 6
24635: PUSH
24636: LD_VAR 0 2
24640: DIFF
24641: ST_TO_ADDR
// SetTag ( j , 1 ) ;
24642: LD_VAR 0 2
24646: PPUSH
24647: LD_INT 1
24649: PPUSH
24650: CALL_OW 109
// wait ( 0 0$2 ) ;
24654: LD_INT 70
24656: PPUSH
24657: CALL_OW 67
// if IsInUnit ( j ) then
24661: LD_VAR 0 2
24665: PPUSH
24666: CALL_OW 310
24670: IFFALSE 24681
// ComExitBuilding ( j ) ;
24672: LD_VAR 0 2
24676: PPUSH
24677: CALL_OW 122
// if GetClass ( j ) <> 1 and not HasTask ( j ) then
24681: LD_VAR 0 2
24685: PPUSH
24686: CALL_OW 257
24690: PUSH
24691: LD_INT 1
24693: NONEQUAL
24694: IFFALSE 24708
24696: PUSH
24697: LD_VAR 0 2
24701: PPUSH
24702: CALL_OW 314
24706: NOT
24707: AND
24708: IFFALSE 24788
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
24710: LD_VAR 0 11
24714: PUSH
24715: LD_INT 1
24717: ARRAY
24718: PPUSH
24719: CALL_OW 313
24723: PUSH
24724: LD_INT 5
24726: GREATEREQUAL
24727: IFFALSE 24749
// ComEnterUnit ( j , arm [ 2 ] ) else
24729: LD_VAR 0 2
24733: PPUSH
24734: LD_VAR 0 11
24738: PUSH
24739: LD_INT 2
24741: ARRAY
24742: PPUSH
24743: CALL_OW 120
24747: GO 24767
// ComEnterUnit ( j , arm [ 1 ] ) ;
24749: LD_VAR 0 2
24753: PPUSH
24754: LD_VAR 0 11
24758: PUSH
24759: LD_INT 1
24761: ARRAY
24762: PPUSH
24763: CALL_OW 120
// AddComChangeProfession ( j , 1 ) ;
24767: LD_VAR 0 2
24771: PPUSH
24772: LD_INT 1
24774: PPUSH
24775: CALL_OW 183
// AddComExitBuilding ( j ) ;
24779: LD_VAR 0 2
24783: PPUSH
24784: CALL_OW 182
// end ; if i = 2 then
24788: LD_VAR 0 1
24792: PUSH
24793: LD_INT 2
24795: EQUAL
24796: IFFALSE 24813
// AddComMoveXY ( j , 61 , 93 ) ;
24798: LD_VAR 0 2
24802: PPUSH
24803: LD_INT 61
24805: PPUSH
24806: LD_INT 93
24808: PPUSH
24809: CALL_OW 171
// if i = 1 then
24813: LD_VAR 0 1
24817: PUSH
24818: LD_INT 1
24820: EQUAL
24821: IFFALSE 24874
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
24823: LD_VAR 0 2
24827: PPUSH
24828: LD_VAR 0 3
24832: PUSH
24833: LD_INT 1
24835: ARRAY
24836: PPUSH
24837: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
24841: LD_ADDR_VAR 0 3
24845: PUSH
24846: LD_VAR 0 3
24850: PPUSH
24851: LD_INT 1
24853: PPUSH
24854: CALL_OW 3
24858: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
24859: LD_VAR 0 2
24863: PPUSH
24864: LD_INT 69
24866: PPUSH
24867: LD_INT 94
24869: PPUSH
24870: CALL_OW 171
// end ; end ;
24874: GO 24574
24876: POP
24877: POP
// end ;
24878: GO 24555
24880: POP
24881: POP
// wait ( 0 0$30 ) ;
24882: LD_INT 1050
24884: PPUSH
24885: CALL_OW 67
// MC_Kill ( 4 ) ;
24889: LD_INT 4
24891: PPUSH
24892: CALL 40134 0 1
// tmp := UnitsInside ( fac ) ;
24896: LD_ADDR_VAR 0 3
24900: PUSH
24901: LD_VAR 0 10
24905: PPUSH
24906: CALL_OW 313
24910: ST_TO_ADDR
// if tmp then
24911: LD_VAR 0 3
24915: IFFALSE 25036
// for i in tmp do
24917: LD_ADDR_VAR 0 1
24921: PUSH
24922: LD_VAR 0 3
24926: PUSH
24927: FOR_IN
24928: IFFALSE 25034
// begin ComExitBuilding ( i ) ;
24930: LD_VAR 0 1
24934: PPUSH
24935: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
24939: LD_VAR 0 11
24943: PUSH
24944: LD_INT 2
24946: ARRAY
24947: PPUSH
24948: CALL_OW 313
24952: PUSH
24953: LD_INT 6
24955: LESS
24956: IFFALSE 24978
// AddComEnterUnit ( i , arm [ 2 ] ) else
24958: LD_VAR 0 1
24962: PPUSH
24963: LD_VAR 0 11
24967: PUSH
24968: LD_INT 2
24970: ARRAY
24971: PPUSH
24972: CALL_OW 180
24976: GO 25032
// if UnitsInside ( arm [ 1 ] ) < 6 then
24978: LD_VAR 0 11
24982: PUSH
24983: LD_INT 1
24985: ARRAY
24986: PPUSH
24987: CALL_OW 313
24991: PUSH
24992: LD_INT 6
24994: LESS
24995: IFFALSE 25017
// AddComEnterUnit ( i , arm [ 1 ] ) else
24997: LD_VAR 0 1
25001: PPUSH
25002: LD_VAR 0 11
25006: PUSH
25007: LD_INT 1
25009: ARRAY
25010: PPUSH
25011: CALL_OW 180
25015: GO 25032
// AddComMoveXY ( i , 37 , 68 ) ;
25017: LD_VAR 0 1
25021: PPUSH
25022: LD_INT 37
25024: PPUSH
25025: LD_INT 68
25027: PPUSH
25028: CALL_OW 171
// end ;
25032: GO 24927
25034: POP
25035: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
25036: LD_ADDR_VAR 0 12
25040: PUSH
25041: LD_VAR 0 6
25045: PPUSH
25046: LD_INT 26
25048: PUSH
25049: LD_INT 1
25051: PUSH
25052: EMPTY
25053: LIST
25054: LIST
25055: PPUSH
25056: CALL_OW 72
25060: PUSH
25061: LD_EXP 62
25065: DIFF
25066: ST_TO_ADDR
// if not speaker then
25067: LD_VAR 0 12
25071: NOT
25072: IFFALSE 25099
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
25074: LD_ADDR_VAR 0 12
25078: PUSH
25079: LD_VAR 0 6
25083: PPUSH
25084: LD_INT 26
25086: PUSH
25087: LD_INT 1
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: PPUSH
25094: CALL_OW 72
25098: ST_TO_ADDR
// if speaker then
25099: LD_VAR 0 12
25103: IFFALSE 25119
// speaker := speaker [ 1 ] ;
25105: LD_ADDR_VAR 0 12
25109: PUSH
25110: LD_VAR 0 12
25114: PUSH
25115: LD_INT 1
25117: ARRAY
25118: ST_TO_ADDR
// Video ( true ) ;
25119: LD_INT 1
25121: PPUSH
25122: CALL 109111 0 1
// CenterNowOnUnits ( Powell ) ;
25126: LD_EXP 61
25130: PPUSH
25131: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
25135: LD_ADDR_VAR 0 3
25139: PUSH
25140: LD_VAR 0 6
25144: PPUSH
25145: LD_INT 3
25147: PUSH
25148: LD_INT 25
25150: PUSH
25151: LD_INT 1
25153: PUSH
25154: EMPTY
25155: LIST
25156: LIST
25157: PUSH
25158: EMPTY
25159: LIST
25160: LIST
25161: PPUSH
25162: CALL_OW 72
25166: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
25167: LD_ADDR_VAR 0 13
25171: PUSH
25172: LD_INT 22
25174: PUSH
25175: LD_INT 4
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: PUSH
25182: LD_INT 30
25184: PUSH
25185: LD_INT 32
25187: PUSH
25188: EMPTY
25189: LIST
25190: LIST
25191: PUSH
25192: LD_INT 58
25194: PUSH
25195: EMPTY
25196: LIST
25197: PUSH
25198: EMPTY
25199: LIST
25200: LIST
25201: LIST
25202: PPUSH
25203: CALL_OW 69
25207: ST_TO_ADDR
// t := Count ( tmp ) ;
25208: LD_ADDR_VAR 0 7
25212: PUSH
25213: LD_VAR 0 3
25217: PPUSH
25218: CALL 73163 0 1
25222: ST_TO_ADDR
// if t > 4 then
25223: LD_VAR 0 7
25227: PUSH
25228: LD_INT 4
25230: GREATER
25231: IFFALSE 25241
// t := 4 ;
25233: LD_ADDR_VAR 0 7
25237: PUSH
25238: LD_INT 4
25240: ST_TO_ADDR
// for i := 1 to t do
25241: LD_ADDR_VAR 0 1
25245: PUSH
25246: DOUBLE
25247: LD_INT 1
25249: DEC
25250: ST_TO_ADDR
25251: LD_VAR 0 7
25255: PUSH
25256: FOR_TO
25257: IFFALSE 25403
// begin if IsInUnit ( tmp [ i ] ) then
25259: LD_VAR 0 3
25263: PUSH
25264: LD_VAR 0 1
25268: ARRAY
25269: PPUSH
25270: CALL_OW 310
25274: IFFALSE 25291
// ComExitBuilding ( tmp [ i ] ) ;
25276: LD_VAR 0 3
25280: PUSH
25281: LD_VAR 0 1
25285: ARRAY
25286: PPUSH
25287: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
25291: LD_VAR 0 3
25295: PUSH
25296: LD_VAR 0 1
25300: ARRAY
25301: PPUSH
25302: LD_VAR 0 11
25306: PUSH
25307: LD_INT 1
25309: ARRAY
25310: PPUSH
25311: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
25315: LD_VAR 0 3
25319: PUSH
25320: LD_VAR 0 1
25324: ARRAY
25325: PPUSH
25326: LD_INT 1
25328: PPUSH
25329: CALL_OW 183
// if Count ( emp_towers ) then
25333: LD_VAR 0 13
25337: PPUSH
25338: CALL 73163 0 1
25342: IFFALSE 25401
// begin AddComExitBuilding ( tmp [ i ] ) ;
25344: LD_VAR 0 3
25348: PUSH
25349: LD_VAR 0 1
25353: ARRAY
25354: PPUSH
25355: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
25359: LD_VAR 0 3
25363: PUSH
25364: LD_VAR 0 1
25368: ARRAY
25369: PPUSH
25370: LD_VAR 0 13
25374: PUSH
25375: LD_INT 1
25377: ARRAY
25378: PPUSH
25379: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
25383: LD_ADDR_VAR 0 13
25387: PUSH
25388: LD_VAR 0 13
25392: PPUSH
25393: LD_INT 1
25395: PPUSH
25396: CALL_OW 3
25400: ST_TO_ADDR
// end ; end ;
25401: GO 25256
25403: POP
25404: POP
// wait ( 0 0$5 ) ;
25405: LD_INT 175
25407: PPUSH
25408: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
25412: LD_VAR 0 3
25416: PPUSH
25417: LD_INT 3
25419: PUSH
25420: LD_INT 54
25422: PUSH
25423: EMPTY
25424: LIST
25425: PUSH
25426: EMPTY
25427: LIST
25428: LIST
25429: PPUSH
25430: CALL_OW 72
25434: IFFALSE 25454
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
25436: LD_VAR 0 3
25440: PPUSH
25441: LD_VAR 0 11
25445: PUSH
25446: LD_INT 1
25448: ARRAY
25449: PPUSH
25450: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
25454: LD_ADDR_VAR 0 3
25458: PUSH
25459: LD_EXP 18
25463: PUSH
25464: LD_INT 1
25466: ARRAY
25467: PUSH
25468: LD_EXP 18
25472: PUSH
25473: LD_INT 2
25475: ARRAY
25476: ADD
25477: PPUSH
25478: LD_INT 26
25480: PUSH
25481: LD_INT 1
25483: PUSH
25484: EMPTY
25485: LIST
25486: LIST
25487: PPUSH
25488: CALL_OW 72
25492: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
25493: LD_ADDR_VAR 0 1
25497: PUSH
25498: LD_EXP 18
25502: PUSH
25503: LD_INT 2
25505: ARRAY
25506: PUSH
25507: FOR_IN
25508: IFFALSE 25526
// ComTurnUnit ( i , Powell ) ;
25510: LD_VAR 0 1
25514: PPUSH
25515: LD_EXP 61
25519: PPUSH
25520: CALL_OW 119
25524: GO 25507
25526: POP
25527: POP
// Say ( Powell , D5-Pow-1 ) ;
25528: LD_EXP 61
25532: PPUSH
25533: LD_STRING D5-Pow-1
25535: PPUSH
25536: CALL_OW 88
// if tmp then
25540: LD_VAR 0 3
25544: IFFALSE 25562
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
25546: LD_VAR 0 3
25550: PUSH
25551: LD_INT 1
25553: ARRAY
25554: PPUSH
25555: LD_STRING D5-Sol2-1
25557: PPUSH
25558: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
25562: LD_EXP 61
25566: PPUSH
25567: LD_STRING D5-Pow-2
25569: PPUSH
25570: CALL_OW 88
// if tmp > 1 then
25574: LD_VAR 0 3
25578: PUSH
25579: LD_INT 1
25581: GREATER
25582: IFFALSE 25600
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
25584: LD_VAR 0 3
25588: PUSH
25589: LD_INT 2
25591: ARRAY
25592: PPUSH
25593: LD_STRING D5-Sol2-2
25595: PPUSH
25596: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
25600: LD_EXP 61
25604: PPUSH
25605: LD_STRING D5-Pow-3
25607: PPUSH
25608: CALL_OW 88
// wait ( 0 0$1 ) ;
25612: LD_INT 35
25614: PPUSH
25615: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
25619: LD_ADDR_VAR 0 3
25623: PUSH
25624: LD_EXP 18
25628: PUSH
25629: LD_INT 1
25631: ARRAY
25632: PUSH
25633: LD_EXP 18
25637: PUSH
25638: LD_INT 2
25640: ARRAY
25641: UNION
25642: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
25643: LD_VAR 0 3
25647: PPUSH
25648: LD_INT 80
25650: PPUSH
25651: LD_INT 67
25653: PPUSH
25654: CALL_OW 114
// wait ( 0 0$2 ) ;
25658: LD_INT 70
25660: PPUSH
25661: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
25665: LD_INT 79
25667: PPUSH
25668: LD_INT 72
25670: PPUSH
25671: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
25675: LD_INT 70
25677: PPUSH
25678: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
25682: LD_VAR 0 3
25686: PPUSH
25687: LD_INT 3
25689: PUSH
25690: LD_INT 24
25692: PUSH
25693: LD_INT 1000
25695: PUSH
25696: EMPTY
25697: LIST
25698: LIST
25699: PUSH
25700: EMPTY
25701: LIST
25702: LIST
25703: PPUSH
25704: CALL_OW 72
25708: IFFALSE 25675
// Say ( Powell , D5a-Pow-1 ) ;
25710: LD_EXP 61
25714: PPUSH
25715: LD_STRING D5a-Pow-1
25717: PPUSH
25718: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
25722: LD_EXP 61
25726: PPUSH
25727: LD_STRING D5a-Pow-1a
25729: PPUSH
25730: CALL_OW 88
// wait ( 0 0$0.7 ) ;
25734: LD_INT 24
25736: PPUSH
25737: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
25741: LD_EXP 61
25745: PPUSH
25746: LD_STRING D5a-Pow-1b
25748: PPUSH
25749: CALL_OW 88
// wait ( 0 0$0.3 ) ;
25753: LD_INT 10
25755: PPUSH
25756: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
25760: LD_EXP 61
25764: PPUSH
25765: LD_STRING D5a-Pow-1c
25767: PPUSH
25768: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
25772: LD_VAR 0 3
25776: PPUSH
25777: LD_INT 68
25779: PPUSH
25780: LD_INT 63
25782: PPUSH
25783: CALL_OW 111
// wait ( 0 0$0.5 ) ;
25787: LD_INT 18
25789: PPUSH
25790: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
25794: LD_EXP 61
25798: PPUSH
25799: LD_STRING D5a-Pow-1d
25801: PPUSH
25802: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
25806: LD_INT 35
25808: PPUSH
25809: CALL_OW 67
// if not HasTask ( tmp ) then
25813: LD_VAR 0 3
25817: PPUSH
25818: CALL_OW 314
25822: NOT
25823: IFFALSE 25840
// ComAgressiveMove ( tmp , 68 , 63 ) ;
25825: LD_VAR 0 3
25829: PPUSH
25830: LD_INT 68
25832: PPUSH
25833: LD_INT 63
25835: PPUSH
25836: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
25840: LD_VAR 0 3
25844: PPUSH
25845: LD_INT 24
25847: PUSH
25848: LD_INT 1
25850: PUSH
25851: EMPTY
25852: LIST
25853: LIST
25854: PPUSH
25855: CALL_OW 72
25859: NOT
25860: IFFALSE 25806
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
25862: LD_ADDR_VAR 0 3
25866: PUSH
25867: LD_INT 22
25869: PUSH
25870: LD_INT 4
25872: PUSH
25873: EMPTY
25874: LIST
25875: LIST
25876: PUSH
25877: LD_INT 92
25879: PUSH
25880: LD_INT 60
25882: PUSH
25883: LD_INT 93
25885: PUSH
25886: LD_INT 10
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: LIST
25893: LIST
25894: PUSH
25895: LD_INT 3
25897: PUSH
25898: LD_INT 54
25900: PUSH
25901: EMPTY
25902: LIST
25903: PUSH
25904: EMPTY
25905: LIST
25906: LIST
25907: PUSH
25908: EMPTY
25909: LIST
25910: LIST
25911: LIST
25912: PPUSH
25913: CALL_OW 69
25917: PUSH
25918: LD_EXP 61
25922: DIFF
25923: ST_TO_ADDR
// if tmp then
25924: LD_VAR 0 3
25928: IFFALSE 25962
// for i in tmp do
25930: LD_ADDR_VAR 0 1
25934: PUSH
25935: LD_VAR 0 3
25939: PUSH
25940: FOR_IN
25941: IFFALSE 25960
// ComMoveXY ( i , 36 , 67 ) ;
25943: LD_VAR 0 1
25947: PPUSH
25948: LD_INT 36
25950: PPUSH
25951: LD_INT 67
25953: PPUSH
25954: CALL_OW 111
25958: GO 25940
25960: POP
25961: POP
// wait ( 0 0$3 ) ;
25962: LD_INT 105
25964: PPUSH
25965: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
25969: LD_VAR 0 12
25973: PPUSH
25974: LD_STRING D6-Sol3-1
25976: PPUSH
25977: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
25981: LD_EXP 61
25985: PPUSH
25986: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
25990: LD_EXP 61
25994: PPUSH
25995: LD_STRING D6-Pow-1
25997: PPUSH
25998: CALL_OW 88
// tmp := [ ] ;
26002: LD_ADDR_VAR 0 3
26006: PUSH
26007: EMPTY
26008: ST_TO_ADDR
// for i = 1 to 2 do
26009: LD_ADDR_VAR 0 1
26013: PUSH
26014: DOUBLE
26015: LD_INT 1
26017: DEC
26018: ST_TO_ADDR
26019: LD_INT 2
26021: PUSH
26022: FOR_TO
26023: IFFALSE 26137
// begin uc_side := 8 ;
26025: LD_ADDR_OWVAR 20
26029: PUSH
26030: LD_INT 8
26032: ST_TO_ADDR
// uc_nation := 2 ;
26033: LD_ADDR_OWVAR 21
26037: PUSH
26038: LD_INT 2
26040: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
26041: LD_INT 14
26043: PPUSH
26044: LD_INT 3
26046: PPUSH
26047: LD_INT 2
26049: PPUSH
26050: LD_INT 29
26052: PPUSH
26053: LD_INT 100
26055: PPUSH
26056: CALL 75959 0 5
// veh := CreateVehicle ;
26060: LD_ADDR_VAR 0 14
26064: PUSH
26065: CALL_OW 45
26069: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
26070: LD_VAR 0 14
26074: PPUSH
26075: LD_INT 4
26077: PPUSH
26078: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
26082: LD_VAR 0 14
26086: PPUSH
26087: LD_INT 99
26089: PPUSH
26090: LD_INT 83
26092: PPUSH
26093: LD_INT 3
26095: PPUSH
26096: LD_INT 0
26098: PPUSH
26099: CALL_OW 50
// wait ( 3 ) ;
26103: LD_INT 3
26105: PPUSH
26106: CALL_OW 67
// Connect ( veh ) ;
26110: LD_VAR 0 14
26114: PPUSH
26115: CALL 79441 0 1
// tmp := tmp ^ veh ;
26119: LD_ADDR_VAR 0 3
26123: PUSH
26124: LD_VAR 0 3
26128: PUSH
26129: LD_VAR 0 14
26133: ADD
26134: ST_TO_ADDR
// end ;
26135: GO 26022
26137: POP
26138: POP
// wait ( 0 0$1 ) ;
26139: LD_INT 35
26141: PPUSH
26142: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
26146: LD_INT 99
26148: PPUSH
26149: LD_INT 83
26151: PPUSH
26152: LD_INT 1
26154: PPUSH
26155: LD_INT 10
26157: PPUSH
26158: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
26162: LD_INT 99
26164: PPUSH
26165: LD_INT 83
26167: PPUSH
26168: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
26172: LD_VAR 0 12
26176: PPUSH
26177: LD_STRING D6-Sol3-2
26179: PPUSH
26180: CALL_OW 88
// async ;
26184: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
26185: LD_EXP 61
26189: PPUSH
26190: LD_STRING D6-Pow-2
26192: PPUSH
26193: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
26197: LD_VAR 0 3
26201: PUSH
26202: LD_INT 1
26204: ARRAY
26205: PPUSH
26206: LD_VAR 0 10
26210: PPUSH
26211: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
26215: LD_VAR 0 3
26219: PUSH
26220: LD_INT 2
26222: ARRAY
26223: PPUSH
26224: LD_INT 22
26226: PUSH
26227: LD_INT 4
26229: PUSH
26230: EMPTY
26231: LIST
26232: LIST
26233: PUSH
26234: LD_INT 21
26236: PUSH
26237: LD_INT 3
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: EMPTY
26245: LIST
26246: LIST
26247: PPUSH
26248: CALL_OW 69
26252: PPUSH
26253: LD_VAR 0 3
26257: PUSH
26258: LD_INT 2
26260: ARRAY
26261: PPUSH
26262: CALL_OW 74
26266: PPUSH
26267: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
26271: LD_EXP 61
26275: PPUSH
26276: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
26280: LD_INT 99
26282: PPUSH
26283: LD_INT 83
26285: PPUSH
26286: LD_INT 1
26288: PPUSH
26289: CALL_OW 331
// repeat wait ( 4 ) ;
26293: LD_INT 4
26295: PPUSH
26296: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
26300: LD_VAR 0 3
26304: PUSH
26305: LD_INT 1
26307: ARRAY
26308: PPUSH
26309: CALL_OW 256
26313: PUSH
26314: LD_INT 1000
26316: LESS
26317: IFFALSE 26335
// SetLives ( tmp [ 1 ] , 1000 ) ;
26319: LD_VAR 0 3
26323: PUSH
26324: LD_INT 1
26326: ARRAY
26327: PPUSH
26328: LD_INT 1000
26330: PPUSH
26331: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
26335: LD_INT 22
26337: PUSH
26338: LD_INT 4
26340: PUSH
26341: EMPTY
26342: LIST
26343: LIST
26344: PUSH
26345: LD_INT 30
26347: PUSH
26348: LD_INT 3
26350: PUSH
26351: EMPTY
26352: LIST
26353: LIST
26354: PUSH
26355: EMPTY
26356: LIST
26357: LIST
26358: PPUSH
26359: CALL_OW 69
26363: PUSH
26364: LD_INT 0
26366: EQUAL
26367: IFFALSE 26293
// skirmish := false ;
26369: LD_ADDR_EXP 100
26373: PUSH
26374: LD_INT 0
26376: ST_TO_ADDR
// sync ;
26377: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
26378: LD_EXP 61
26382: PPUSH
26383: LD_STRING D6a-Pow-1
26385: PPUSH
26386: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
26390: LD_VAR 0 12
26394: PPUSH
26395: LD_STRING D6a-Sol3-1
26397: PPUSH
26398: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
26402: LD_EXP 61
26406: PPUSH
26407: LD_STRING D6a-Pow-2
26409: PPUSH
26410: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
26414: LD_VAR 0 12
26418: PPUSH
26419: LD_STRING D6a-Sol3-2
26421: PPUSH
26422: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
26426: LD_EXP 61
26430: PPUSH
26431: LD_STRING D6a-Pow-3
26433: PPUSH
26434: CALL_OW 88
// powellCenterCameraMode := true ;
26438: LD_ADDR_EXP 20
26442: PUSH
26443: LD_INT 1
26445: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26446: LD_ADDR_VAR 0 1
26450: PUSH
26451: LD_INT 22
26453: PUSH
26454: LD_INT 8
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: PUSH
26461: LD_INT 25
26463: PUSH
26464: LD_INT 2
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PPUSH
26475: CALL_OW 69
26479: PUSH
26480: FOR_IN
26481: IFFALSE 26536
// begin SetTag ( i , 1 ) ;
26483: LD_VAR 0 1
26487: PPUSH
26488: LD_INT 1
26490: PPUSH
26491: CALL_OW 109
// ComExitBuilding ( i ) ;
26495: LD_VAR 0 1
26499: PPUSH
26500: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
26504: LD_VAR 0 1
26508: PPUSH
26509: LD_INT 35
26511: PPUSH
26512: LD_INT 6
26514: PPUSH
26515: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
26519: LD_VAR 0 1
26523: PPUSH
26524: LD_INT 53
26526: PPUSH
26527: LD_INT 4
26529: PPUSH
26530: CALL_OW 171
// end ;
26534: GO 26480
26536: POP
26537: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
26538: LD_ADDR_VAR 0 3
26542: PUSH
26543: LD_INT 22
26545: PUSH
26546: LD_INT 4
26548: PUSH
26549: EMPTY
26550: LIST
26551: LIST
26552: PUSH
26553: LD_INT 21
26555: PUSH
26556: LD_INT 2
26558: PUSH
26559: EMPTY
26560: LIST
26561: LIST
26562: PUSH
26563: LD_INT 3
26565: PUSH
26566: LD_INT 34
26568: PUSH
26569: LD_INT 12
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: LIST
26584: PPUSH
26585: CALL_OW 69
26589: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
26590: LD_EXP 61
26594: PPUSH
26595: LD_VAR 0 3
26599: PPUSH
26600: LD_EXP 61
26604: PPUSH
26605: CALL_OW 74
26609: PPUSH
26610: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
26614: LD_EXP 61
26618: PPUSH
26619: LD_INT 100
26621: PPUSH
26622: LD_INT 88
26624: PPUSH
26625: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
26629: LD_EXP 61
26633: PPUSH
26634: LD_INT 100
26636: PPUSH
26637: LD_INT 75
26639: PPUSH
26640: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
26644: LD_EXP 61
26648: PPUSH
26649: LD_INT 88
26651: PPUSH
26652: LD_INT 53
26654: PPUSH
26655: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
26659: LD_INT 8
26661: PPUSH
26662: LD_EXP 61
26666: PPUSH
26667: CALL_OW 471
// repeat wait ( 3 ) ;
26671: LD_INT 3
26673: PPUSH
26674: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
26678: LD_INT 22
26680: PUSH
26681: LD_INT 4
26683: PUSH
26684: EMPTY
26685: LIST
26686: LIST
26687: PUSH
26688: LD_INT 92
26690: PUSH
26691: LD_INT 100
26693: PUSH
26694: LD_INT 75
26696: PUSH
26697: LD_INT 6
26699: PUSH
26700: EMPTY
26701: LIST
26702: LIST
26703: LIST
26704: LIST
26705: PUSH
26706: EMPTY
26707: LIST
26708: LIST
26709: PPUSH
26710: CALL_OW 69
26714: IFFALSE 26671
// async ;
26716: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
26717: LD_EXP 61
26721: PPUSH
26722: LD_STRING D6b-Pow-1
26724: PPUSH
26725: CALL_OW 88
// repeat wait ( 3 ) ;
26729: LD_INT 3
26731: PPUSH
26732: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
26736: LD_EXP 61
26740: PPUSH
26741: CALL_OW 310
26745: PPUSH
26746: CALL_OW 256
26750: PUSH
26751: LD_INT 1000
26753: LESS
26754: IFFALSE 26773
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
26756: LD_EXP 61
26760: PPUSH
26761: CALL_OW 310
26765: PPUSH
26766: LD_INT 1000
26768: PPUSH
26769: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
26773: LD_EXP 61
26777: PPUSH
26778: CALL_OW 256
26782: PUSH
26783: LD_INT 1000
26785: LESS
26786: IFFALSE 26800
// SetLives ( Powell , 1000 ) ;
26788: LD_EXP 61
26792: PPUSH
26793: LD_INT 1000
26795: PPUSH
26796: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
26800: LD_EXP 61
26804: PPUSH
26805: LD_EXP 67
26809: PPUSH
26810: CALL_OW 296
26814: PUSH
26815: LD_INT 5
26817: LESS
26818: IFTRUE 26845
26820: PUSH
26821: LD_EXP 61
26825: PPUSH
26826: CALL_OW 310
26830: PPUSH
26831: LD_EXP 67
26835: PPUSH
26836: CALL_OW 296
26840: PUSH
26841: LD_INT 5
26843: LESS
26844: OR
26845: IFFALSE 26864
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
26847: LD_EXP 61
26851: PPUSH
26852: CALL_OW 310
26856: PPUSH
26857: LD_INT 100
26859: PPUSH
26860: CALL_OW 234
// until not IsInUnit ( Powell ) ;
26864: LD_EXP 61
26868: PPUSH
26869: CALL_OW 310
26873: NOT
26874: IFFALSE 26729
// DoNotAttack ( 8 , powellBomb ) ;
26876: LD_INT 8
26878: PPUSH
26879: LD_EXP 67
26883: PPUSH
26884: CALL_OW 471
// game_speed := 4 ;
26888: LD_ADDR_OWVAR 65
26892: PUSH
26893: LD_INT 4
26895: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
26896: LD_EXP 61
26900: PPUSH
26901: LD_STRING D6b-Pow-1a
26903: PPUSH
26904: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
26908: LD_EXP 61
26912: PPUSH
26913: LD_EXP 67
26917: PPUSH
26918: CALL_OW 180
// sync ;
26922: SYNC
// repeat wait ( 0 0$1 ) ;
26923: LD_INT 35
26925: PPUSH
26926: CALL_OW 67
// until IsInUnit ( Powell ) ;
26930: LD_EXP 61
26934: PPUSH
26935: CALL_OW 310
26939: IFFALSE 26923
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
26941: LD_INT 8
26943: PPUSH
26944: LD_EXP 61
26948: PPUSH
26949: CALL_OW 310
26953: PPUSH
26954: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
26958: LD_EXP 61
26962: PPUSH
26963: LD_INT 91
26965: PPUSH
26966: LD_INT 44
26968: PPUSH
26969: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
26973: LD_EXP 61
26977: PPUSH
26978: LD_INT 96
26980: PPUSH
26981: LD_INT 44
26983: PPUSH
26984: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
26988: LD_EXP 61
26992: PPUSH
26993: LD_INT 96
26995: PPUSH
26996: LD_INT 41
26998: PPUSH
26999: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
27003: LD_EXP 61
27007: PPUSH
27008: LD_INT 92
27010: PPUSH
27011: LD_INT 39
27013: PPUSH
27014: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
27018: LD_EXP 61
27022: PPUSH
27023: LD_INT 88
27025: PPUSH
27026: LD_INT 41
27028: PPUSH
27029: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
27033: LD_EXP 61
27037: PPUSH
27038: LD_INT 91
27040: PPUSH
27041: LD_INT 44
27043: PPUSH
27044: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
27048: LD_EXP 61
27052: PPUSH
27053: LD_INT 96
27055: PPUSH
27056: LD_INT 44
27058: PPUSH
27059: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
27063: LD_EXP 61
27067: PPUSH
27068: LD_INT 96
27070: PPUSH
27071: LD_INT 41
27073: PPUSH
27074: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
27078: LD_EXP 61
27082: PPUSH
27083: LD_INT 92
27085: PPUSH
27086: LD_INT 39
27088: PPUSH
27089: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
27093: LD_EXP 61
27097: PPUSH
27098: LD_INT 88
27100: PPUSH
27101: LD_INT 41
27103: PPUSH
27104: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
27108: LD_EXP 61
27112: PPUSH
27113: LD_INT 91
27115: PPUSH
27116: LD_INT 44
27118: PPUSH
27119: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
27123: LD_EXP 61
27127: PPUSH
27128: LD_INT 93
27130: PPUSH
27131: LD_INT 39
27133: PPUSH
27134: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
27138: LD_EXP 61
27142: PPUSH
27143: LD_INT 93
27145: PPUSH
27146: LD_INT 36
27148: PPUSH
27149: CALL_OW 171
// wait ( 0 0$3.5 ) ;
27153: LD_INT 122
27155: PPUSH
27156: CALL_OW 67
// game_speed := 4 ;
27160: LD_ADDR_OWVAR 65
27164: PUSH
27165: LD_INT 4
27167: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
27168: LD_EXP 61
27172: PPUSH
27173: LD_STRING D6b-Pow-1b
27175: PPUSH
27176: CALL_OW 88
// tmp := [ ] ;
27180: LD_ADDR_VAR 0 3
27184: PUSH
27185: EMPTY
27186: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
27187: LD_ADDR_VAR 0 5
27191: PUSH
27192: LD_INT 78
27194: PUSH
27195: LD_INT 47
27197: PUSH
27198: EMPTY
27199: LIST
27200: LIST
27201: PUSH
27202: LD_INT 106
27204: PUSH
27205: LD_INT 53
27207: PUSH
27208: EMPTY
27209: LIST
27210: LIST
27211: PUSH
27212: EMPTY
27213: LIST
27214: LIST
27215: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
27216: LD_ADDR_VAR 0 1
27220: PUSH
27221: LD_INT 22
27223: PUSH
27224: LD_INT 8
27226: PUSH
27227: EMPTY
27228: LIST
27229: LIST
27230: PUSH
27231: LD_INT 21
27233: PUSH
27234: LD_INT 3
27236: PUSH
27237: EMPTY
27238: LIST
27239: LIST
27240: PUSH
27241: LD_INT 92
27243: PUSH
27244: LD_INT 90
27246: PUSH
27247: LD_INT 52
27249: PUSH
27250: LD_INT 12
27252: PUSH
27253: EMPTY
27254: LIST
27255: LIST
27256: LIST
27257: LIST
27258: PUSH
27259: EMPTY
27260: LIST
27261: LIST
27262: LIST
27263: PPUSH
27264: CALL_OW 69
27268: PUSH
27269: FOR_IN
27270: IFFALSE 27295
// tmp := tmp ^ UnitsInside ( i ) ;
27272: LD_ADDR_VAR 0 3
27276: PUSH
27277: LD_VAR 0 3
27281: PUSH
27282: LD_VAR 0 1
27286: PPUSH
27287: CALL_OW 313
27291: ADD
27292: ST_TO_ADDR
27293: GO 27269
27295: POP
27296: POP
// for i in tmp do
27297: LD_ADDR_VAR 0 1
27301: PUSH
27302: LD_VAR 0 3
27306: PUSH
27307: FOR_IN
27308: IFFALSE 27470
// begin dist := 9999 ;
27310: LD_ADDR_VAR 0 9
27314: PUSH
27315: LD_INT 9999
27317: ST_TO_ADDR
// _xy := [ ] ;
27318: LD_ADDR_VAR 0 8
27322: PUSH
27323: EMPTY
27324: ST_TO_ADDR
// SetTag ( i , 1 ) ;
27325: LD_VAR 0 1
27329: PPUSH
27330: LD_INT 1
27332: PPUSH
27333: CALL_OW 109
// ComExitBuilding ( i ) ;
27337: LD_VAR 0 1
27341: PPUSH
27342: CALL_OW 122
// for j in xy do
27346: LD_ADDR_VAR 0 2
27350: PUSH
27351: LD_VAR 0 5
27355: PUSH
27356: FOR_IN
27357: IFFALSE 27439
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
27359: LD_VAR 0 1
27363: PPUSH
27364: LD_VAR 0 2
27368: PUSH
27369: LD_INT 1
27371: ARRAY
27372: PPUSH
27373: LD_VAR 0 2
27377: PUSH
27378: LD_INT 2
27380: ARRAY
27381: PPUSH
27382: CALL_OW 297
27386: PUSH
27387: LD_VAR 0 9
27391: LESS
27392: IFFALSE 27437
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
27394: LD_ADDR_VAR 0 9
27398: PUSH
27399: LD_VAR 0 1
27403: PPUSH
27404: LD_VAR 0 2
27408: PUSH
27409: LD_INT 1
27411: ARRAY
27412: PPUSH
27413: LD_VAR 0 2
27417: PUSH
27418: LD_INT 2
27420: ARRAY
27421: PPUSH
27422: CALL_OW 297
27426: ST_TO_ADDR
// _xy := j ;
27427: LD_ADDR_VAR 0 8
27431: PUSH
27432: LD_VAR 0 2
27436: ST_TO_ADDR
// end ;
27437: GO 27356
27439: POP
27440: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
27441: LD_VAR 0 1
27445: PPUSH
27446: LD_VAR 0 8
27450: PUSH
27451: LD_INT 1
27453: ARRAY
27454: PPUSH
27455: LD_VAR 0 8
27459: PUSH
27460: LD_INT 2
27462: ARRAY
27463: PPUSH
27464: CALL_OW 171
// end ;
27468: GO 27307
27470: POP
27471: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
27472: LD_ADDR_VAR 0 4
27476: PUSH
27477: LD_VAR 0 3
27481: PPUSH
27482: LD_INT 26
27484: PUSH
27485: LD_INT 1
27487: PUSH
27488: EMPTY
27489: LIST
27490: LIST
27491: PUSH
27492: LD_INT 25
27494: PUSH
27495: LD_INT 1
27497: PUSH
27498: EMPTY
27499: LIST
27500: LIST
27501: PUSH
27502: EMPTY
27503: LIST
27504: LIST
27505: PPUSH
27506: CALL_OW 72
27510: ST_TO_ADDR
// if tmp2 < 2 then
27511: LD_VAR 0 4
27515: PUSH
27516: LD_INT 2
27518: LESS
27519: IFFALSE 27588
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
27521: LD_ADDR_VAR 0 4
27525: PUSH
27526: LD_INT 22
27528: PUSH
27529: LD_INT 8
27531: PUSH
27532: EMPTY
27533: LIST
27534: LIST
27535: PUSH
27536: LD_INT 26
27538: PUSH
27539: LD_INT 1
27541: PUSH
27542: EMPTY
27543: LIST
27544: LIST
27545: PUSH
27546: LD_INT 3
27548: PUSH
27549: LD_INT 25
27551: PUSH
27552: LD_INT 15
27554: PUSH
27555: EMPTY
27556: LIST
27557: LIST
27558: PUSH
27559: EMPTY
27560: LIST
27561: LIST
27562: PUSH
27563: EMPTY
27564: LIST
27565: LIST
27566: LIST
27567: PPUSH
27568: CALL_OW 69
27572: PUSH
27573: LD_EXP 64
27577: PUSH
27578: LD_EXP 65
27582: PUSH
27583: EMPTY
27584: LIST
27585: LIST
27586: DIFF
27587: ST_TO_ADDR
// if tmp2 then
27588: LD_VAR 0 4
27592: IFFALSE 27610
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
27594: LD_VAR 0 4
27598: PUSH
27599: LD_INT 1
27601: ARRAY
27602: PPUSH
27603: LD_STRING D6b-ArSol1-1
27605: PPUSH
27606: CALL_OW 88
// async ;
27610: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
27611: LD_EXP 61
27615: PPUSH
27616: LD_STRING D6b-Pow-2
27618: PPUSH
27619: CALL_OW 88
// wait ( 0 0$0.5 ) ;
27623: LD_INT 18
27625: PPUSH
27626: CALL_OW 67
// if tmp2 > 1 then
27630: LD_VAR 0 4
27634: PUSH
27635: LD_INT 1
27637: GREATER
27638: IFFALSE 27656
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
27640: LD_VAR 0 4
27644: PUSH
27645: LD_INT 2
27647: ARRAY
27648: PPUSH
27649: LD_STRING D6b-ArSol2-1
27651: PPUSH
27652: CALL_OW 88
// sync ;
27656: SYNC
// repeat wait ( 5 ) ;
27657: LD_INT 5
27659: PPUSH
27660: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
27664: LD_INT 93
27666: PPUSH
27667: LD_INT 36
27669: PPUSH
27670: CALL_OW 428
27674: PPUSH
27675: CALL_OW 255
27679: PUSH
27680: LD_INT 4
27682: EQUAL
27683: IFFALSE 27657
// DialogueOn ;
27685: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
27689: LD_INT 10
27691: PPUSH
27692: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
27696: LD_EXP 61
27700: PPUSH
27701: LD_STRING D6b-Pow-2a
27703: PPUSH
27704: CALL_OW 88
// DialogueOff ;
27708: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
27712: LD_EXP 61
27716: PPUSH
27717: CALL_OW 310
27721: PPUSH
27722: LD_INT 332
27724: PPUSH
27725: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
27729: LD_INT 93
27731: PPUSH
27732: LD_INT 35
27734: PPUSH
27735: LD_INT 1
27737: PPUSH
27738: LD_INT 6
27740: NEG
27741: PPUSH
27742: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
27746: LD_INT 35
27748: PPUSH
27749: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
27753: LD_INT 332
27755: PPUSH
27756: CALL_OW 256
27760: PUSH
27761: LD_INT 1000
27763: LESS
27764: IFFALSE 27775
27766: PUSH
27767: LD_INT 332
27769: PPUSH
27770: CALL_OW 300
27774: AND
27775: IFFALSE 27787
// SetLives ( kozlov_fac , 0 ) ;
27777: LD_INT 332
27779: PPUSH
27780: LD_INT 0
27782: PPUSH
27783: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
27787: LD_INT 332
27789: PPUSH
27790: CALL_OW 301
27794: IFTRUE 27807
27796: PUSH
27797: LD_EXP 61
27801: PPUSH
27802: CALL_OW 301
27806: OR
27807: IFFALSE 27746
// game_speed := 4 ;
27809: LD_ADDR_OWVAR 65
27813: PUSH
27814: LD_INT 4
27816: ST_TO_ADDR
// powellCenterCameraMode := false ;
27817: LD_ADDR_EXP 20
27821: PUSH
27822: LD_INT 0
27824: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
27825: LD_ADDR_VAR 0 1
27829: PUSH
27830: LD_VAR 0 3
27834: PUSH
27835: LD_INT 22
27837: PUSH
27838: LD_INT 8
27840: PUSH
27841: EMPTY
27842: LIST
27843: LIST
27844: PUSH
27845: LD_INT 25
27847: PUSH
27848: LD_INT 2
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PPUSH
27859: CALL_OW 69
27863: UNION
27864: PUSH
27865: FOR_IN
27866: IFFALSE 27882
// SetTag ( i , 0 ) ;
27868: LD_VAR 0 1
27872: PPUSH
27873: LD_INT 0
27875: PPUSH
27876: CALL_OW 109
27880: GO 27865
27882: POP
27883: POP
// wait ( 0 0$3 ) ;
27884: LD_INT 105
27886: PPUSH
27887: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
27891: LD_INT 93
27893: PPUSH
27894: LD_INT 35
27896: PPUSH
27897: LD_INT 1
27899: PPUSH
27900: CALL_OW 331
// DialogueOn ;
27904: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
27908: LD_VAR 0 12
27912: PPUSH
27913: LD_STRING D6c-Sol3-1
27915: PPUSH
27916: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
27920: LD_INT 10
27922: PPUSH
27923: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
27927: LD_EXP 40
27931: PPUSH
27932: LD_STRING D6c-JMM-1
27934: PPUSH
27935: CALL_OW 88
// if Cyrus then
27939: LD_EXP 46
27943: IFFALSE 27957
// Say ( Cyrus , D6c-Cyrus-1 ) ;
27945: LD_EXP 46
27949: PPUSH
27950: LD_STRING D6c-Cyrus-1
27952: PPUSH
27953: CALL_OW 88
// if Bobby then
27957: LD_EXP 45
27961: IFFALSE 27975
// Say ( Bobby , D6c-Bobby-1 ) ;
27963: LD_EXP 45
27967: PPUSH
27968: LD_STRING D6c-Bobby-1
27970: PPUSH
27971: CALL_OW 88
// if Cornel then
27975: LD_EXP 51
27979: IFFALSE 27993
// Say ( Cornel , D6c-Corn-1 ) ;
27981: LD_EXP 51
27985: PPUSH
27986: LD_STRING D6c-Corn-1
27988: PPUSH
27989: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
27993: LD_ADDR_VAR 0 4
27997: PUSH
27998: LD_INT 2
28000: PUSH
28001: LD_INT 22
28003: PUSH
28004: LD_INT 1
28006: PUSH
28007: EMPTY
28008: LIST
28009: LIST
28010: PUSH
28011: LD_INT 22
28013: PUSH
28014: LD_INT 4
28016: PUSH
28017: EMPTY
28018: LIST
28019: LIST
28020: PUSH
28021: EMPTY
28022: LIST
28023: LIST
28024: LIST
28025: PUSH
28026: LD_INT 26
28028: PUSH
28029: LD_INT 1
28031: PUSH
28032: EMPTY
28033: LIST
28034: LIST
28035: PUSH
28036: LD_INT 23
28038: PUSH
28039: LD_INT 1
28041: PUSH
28042: EMPTY
28043: LIST
28044: LIST
28045: PUSH
28046: EMPTY
28047: LIST
28048: LIST
28049: LIST
28050: PPUSH
28051: CALL_OW 69
28055: PUSH
28056: LD_VAR 0 12
28060: PUSH
28061: LD_EXP 40
28065: UNION
28066: PUSH
28067: LD_EXP 62
28071: UNION
28072: DIFF
28073: ST_TO_ADDR
// if tmp2 then
28074: LD_VAR 0 4
28078: IFFALSE 28096
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
28080: LD_VAR 0 4
28084: PUSH
28085: LD_INT 1
28087: ARRAY
28088: PPUSH
28089: LD_STRING D6c-Sol1-1
28091: PPUSH
28092: CALL_OW 88
// if Lisa then
28096: LD_EXP 43
28100: IFFALSE 28114
// Say ( Lisa , D6c-Lisa-1 ) ;
28102: LD_EXP 43
28106: PPUSH
28107: LD_STRING D6c-Lisa-1
28109: PPUSH
28110: CALL_OW 88
// if Gary then
28114: LD_EXP 52
28118: IFFALSE 28132
// Say ( Gary , D6c-Gary-1 ) ;
28120: LD_EXP 52
28124: PPUSH
28125: LD_STRING D6c-Gary-1
28127: PPUSH
28128: CALL_OW 88
// if Donaldson then
28132: LD_EXP 44
28136: IFFALSE 28150
// Say ( Donaldson , D6c-Don-1 ) ;
28138: LD_EXP 44
28142: PPUSH
28143: LD_STRING D6c-Don-1
28145: PPUSH
28146: CALL_OW 88
// if tmp2 > 1 then
28150: LD_VAR 0 4
28154: PUSH
28155: LD_INT 1
28157: GREATER
28158: IFFALSE 28176
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
28160: LD_VAR 0 4
28164: PUSH
28165: LD_INT 2
28167: ARRAY
28168: PPUSH
28169: LD_STRING D6c-Sol2-1
28171: PPUSH
28172: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
28176: LD_VAR 0 12
28180: PPUSH
28181: LD_STRING D6c-Sol3-2
28183: PPUSH
28184: CALL_OW 88
// if IsInUnit ( JMM ) then
28188: LD_EXP 40
28192: PPUSH
28193: CALL_OW 310
28197: IFFALSE 28215
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
28199: LD_EXP 40
28203: PPUSH
28204: CALL_OW 310
28208: PPUSH
28209: CALL_OW 87
28213: GO 28224
// CenterNowOnUnits ( JMM ) ;
28215: LD_EXP 40
28219: PPUSH
28220: CALL_OW 87
// dwait ( 0 0$2 ) ;
28224: LD_INT 70
28226: PPUSH
28227: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
28231: LD_EXP 40
28235: PPUSH
28236: LD_STRING D6c-JMM-2
28238: PPUSH
28239: CALL_OW 88
// DialogueOff ;
28243: CALL_OW 7
// Video ( false ) ;
28247: LD_INT 0
28249: PPUSH
28250: CALL 109111 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
28254: LD_INT 22
28256: PUSH
28257: LD_INT 4
28259: PUSH
28260: EMPTY
28261: LIST
28262: LIST
28263: PPUSH
28264: CALL_OW 69
28268: PPUSH
28269: LD_INT 1
28271: PPUSH
28272: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
28276: LD_INT 4
28278: PPUSH
28279: LD_INT 4
28281: PPUSH
28282: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
28286: LD_ADDR_VAR 0 1
28290: PUSH
28291: LD_INT 4
28293: PPUSH
28294: LD_INT 1
28296: PPUSH
28297: LD_INT 2
28299: PPUSH
28300: CALL 71086 0 3
28304: PUSH
28305: FOR_IN
28306: IFFALSE 28343
// if GetTech ( i , 1 ) <> state_researched then
28308: LD_VAR 0 1
28312: PPUSH
28313: LD_INT 1
28315: PPUSH
28316: CALL_OW 321
28320: PUSH
28321: LD_INT 2
28323: NONEQUAL
28324: IFFALSE 28341
// SetTech ( i , 1 , state_researched ) ;
28326: LD_VAR 0 1
28330: PPUSH
28331: LD_INT 1
28333: PPUSH
28334: LD_INT 2
28336: PPUSH
28337: CALL_OW 322
28341: GO 28305
28343: POP
28344: POP
// missionStage := 6 ;
28345: LD_ADDR_EXP 15
28349: PUSH
28350: LD_INT 6
28352: ST_TO_ADDR
// activeAttacks := true ;
28353: LD_ADDR_EXP 16
28357: PUSH
28358: LD_INT 1
28360: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
28361: LD_STRING M2
28363: PPUSH
28364: CALL_OW 337
// SaveForQuickRestart ;
28368: CALL_OW 22
// wait ( 0 0$40 ) ;
28372: LD_INT 1400
28374: PPUSH
28375: CALL_OW 67
// DialogueOn ;
28379: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
28383: LD_EXP 66
28387: PPUSH
28388: LD_STRING D7-Friend-1
28390: PPUSH
28391: CALL 113384 0 2
// Say ( JMM , D7-JMM-1 ) ;
28395: LD_EXP 40
28399: PPUSH
28400: LD_STRING D7-JMM-1
28402: PPUSH
28403: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
28407: LD_EXP 66
28411: PPUSH
28412: LD_STRING D7-Friend-2
28414: PPUSH
28415: CALL 113384 0 2
// Say ( JMM , D7-JMM-2 ) ;
28419: LD_EXP 40
28423: PPUSH
28424: LD_STRING D7-JMM-2
28426: PPUSH
28427: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
28431: LD_EXP 66
28435: PPUSH
28436: LD_STRING D7-Friend-3
28438: PPUSH
28439: CALL 113384 0 2
// Say ( JMM , D7-JMM-3 ) ;
28443: LD_EXP 40
28447: PPUSH
28448: LD_STRING D7-JMM-3
28450: PPUSH
28451: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
28455: LD_EXP 66
28459: PPUSH
28460: LD_STRING D7-Friend-4
28462: PPUSH
28463: CALL 113384 0 2
// Say ( JMM , D7-JMM-4 ) ;
28467: LD_EXP 40
28471: PPUSH
28472: LD_STRING D7-JMM-4
28474: PPUSH
28475: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
28479: LD_EXP 66
28483: PPUSH
28484: LD_STRING D7-Friend-5
28486: PPUSH
28487: CALL 113384 0 2
// Say ( JMM , D7-JMM-5 ) ;
28491: LD_EXP 40
28495: PPUSH
28496: LD_STRING D7-JMM-5
28498: PPUSH
28499: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
28503: LD_EXP 66
28507: PPUSH
28508: LD_STRING D7-Friend-6
28510: PPUSH
28511: CALL 113384 0 2
// Say ( JMM , D7-JMM-6 ) ;
28515: LD_EXP 40
28519: PPUSH
28520: LD_STRING D7-JMM-6
28522: PPUSH
28523: CALL_OW 88
// DialogueOff ;
28527: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
28531: LD_STRING Mlegion
28533: PPUSH
28534: CALL_OW 337
// skirmish := true ;
28538: LD_ADDR_EXP 100
28542: PUSH
28543: LD_INT 1
28545: ST_TO_ADDR
// RebuildKozlovFactory ;
28546: CALL 5386 0 0
// end ;
28550: PPOPN 14
28552: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
28553: LD_EXP 20
28557: IFFALSE 28570
28559: PUSH
28560: LD_EXP 61
28564: PPUSH
28565: CALL_OW 300
28569: AND
28570: IFFALSE 28612
28572: GO 28574
28574: DISABLE
// begin enable ;
28575: ENABLE
// if IsInUnit ( Powell ) then
28576: LD_EXP 61
28580: PPUSH
28581: CALL_OW 310
28585: IFFALSE 28603
// CenterOnUnits ( IsInUnit ( Powell ) ) else
28587: LD_EXP 61
28591: PPUSH
28592: CALL_OW 310
28596: PPUSH
28597: CALL_OW 85
28601: GO 28612
// CenterOnUnits ( Powell ) ;
28603: LD_EXP 61
28607: PPUSH
28608: CALL_OW 85
// end ;
28612: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
28613: LD_INT 22
28615: PUSH
28616: LD_INT 8
28618: PUSH
28619: EMPTY
28620: LIST
28621: LIST
28622: PUSH
28623: LD_INT 34
28625: PUSH
28626: LD_INT 48
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: PPUSH
28637: CALL_OW 69
28641: IFFALSE 28917
28643: GO 28645
28645: DISABLE
28646: LD_INT 0
28648: PPUSH
28649: PPUSH
// begin if missionStage < 9 then
28650: LD_EXP 15
28654: PUSH
28655: LD_INT 9
28657: LESS
28658: IFFALSE 28668
// missionStage := 9 ;
28660: LD_ADDR_EXP 15
28664: PUSH
28665: LD_INT 9
28667: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28668: LD_ADDR_VAR 0 1
28672: PUSH
28673: LD_INT 22
28675: PUSH
28676: LD_INT 8
28678: PUSH
28679: EMPTY
28680: LIST
28681: LIST
28682: PUSH
28683: LD_INT 34
28685: PUSH
28686: LD_INT 48
28688: PUSH
28689: EMPTY
28690: LIST
28691: LIST
28692: PUSH
28693: EMPTY
28694: LIST
28695: LIST
28696: PPUSH
28697: CALL_OW 69
28701: PUSH
28702: LD_INT 1
28704: ARRAY
28705: ST_TO_ADDR
// wait ( 0 0$05 ) ;
28706: LD_INT 175
28708: PPUSH
28709: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
28713: LD_EXP 12
28717: IFTRUE 28736
28719: PUSH
28720: LD_EXP 3
28724: PUSH
28725: LD_INT 0
28727: PUSH
28728: LD_INT 2
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: IN
28735: OR
28736: IFFALSE 28759
// target := [ 68 , 108 , 1 ] else
28738: LD_ADDR_VAR 0 2
28742: PUSH
28743: LD_INT 68
28745: PUSH
28746: LD_INT 108
28748: PUSH
28749: LD_INT 1
28751: PUSH
28752: EMPTY
28753: LIST
28754: LIST
28755: LIST
28756: ST_TO_ADDR
28757: GO 28778
// target := [ 181 , 88 , 2 ] ;
28759: LD_ADDR_VAR 0 2
28763: PUSH
28764: LD_INT 181
28766: PUSH
28767: LD_INT 88
28769: PUSH
28770: LD_INT 2
28772: PUSH
28773: EMPTY
28774: LIST
28775: LIST
28776: LIST
28777: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
28778: LD_VAR 0 1
28782: PPUSH
28783: LD_VAR 0 2
28787: PUSH
28788: LD_INT 1
28790: ARRAY
28791: PPUSH
28792: LD_VAR 0 2
28796: PUSH
28797: LD_INT 2
28799: ARRAY
28800: PPUSH
28801: CALL_OW 176
// if target [ 3 ] = 1 then
28805: LD_VAR 0 2
28809: PUSH
28810: LD_INT 3
28812: ARRAY
28813: PUSH
28814: LD_INT 1
28816: EQUAL
28817: IFFALSE 28833
// SayRadio ( Kurt , D12-Kurt-1 ) else
28819: LD_EXP 64
28823: PPUSH
28824: LD_STRING D12-Kurt-1
28826: PPUSH
28827: CALL_OW 94
28831: GO 28857
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
28833: LD_EXP 64
28837: PPUSH
28838: LD_STRING D12a-Kurt-1
28840: PPUSH
28841: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
28845: LD_EXP 79
28849: PPUSH
28850: LD_STRING D12a-Roth-1
28852: PPUSH
28853: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
28857: LD_INT 350
28859: PPUSH
28860: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
28864: LD_VAR 0 1
28868: PPUSH
28869: LD_INT 22
28871: PUSH
28872: LD_INT 8
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 23
28881: PUSH
28882: LD_INT 2
28884: PUSH
28885: EMPTY
28886: LIST
28887: LIST
28888: PUSH
28889: LD_INT 30
28891: PUSH
28892: LD_INT 3
28894: PUSH
28895: EMPTY
28896: LIST
28897: LIST
28898: PUSH
28899: EMPTY
28900: LIST
28901: LIST
28902: LIST
28903: PPUSH
28904: CALL_OW 69
28908: PUSH
28909: LD_INT 1
28911: ARRAY
28912: PPUSH
28913: CALL_OW 228
// end ;
28917: PPOPN 2
28919: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
28920: LD_EXP 64
28924: PPUSH
28925: CALL_OW 256
28929: PUSH
28930: LD_INT 999
28932: LESS
28933: IFTRUE 29001
28935: PUSH
28936: LD_INT 22
28938: PUSH
28939: LD_INT 8
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 21
28948: PUSH
28949: LD_INT 1
28951: PUSH
28952: EMPTY
28953: LIST
28954: LIST
28955: PUSH
28956: LD_INT 23
28958: PUSH
28959: LD_INT 2
28961: PUSH
28962: EMPTY
28963: LIST
28964: LIST
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: LIST
28970: PPUSH
28971: CALL_OW 69
28975: PUSH
28976: LD_INT 9
28978: PUSH
28979: LD_INT 8
28981: PUSH
28982: LD_INT 7
28984: PUSH
28985: LD_INT 6
28987: PUSH
28988: EMPTY
28989: LIST
28990: LIST
28991: LIST
28992: LIST
28993: PUSH
28994: LD_OWVAR 67
28998: ARRAY
28999: LESSEQUAL
29000: OR
29001: IFFALSE 29034
29003: PUSH
29004: LD_INT 22
29006: PUSH
29007: LD_INT 8
29009: PUSH
29010: EMPTY
29011: LIST
29012: LIST
29013: PUSH
29014: LD_INT 34
29016: PUSH
29017: LD_INT 48
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: EMPTY
29025: LIST
29026: LIST
29027: PPUSH
29028: CALL_OW 69
29032: NOT
29033: AND
29034: IFFALSE 29047
29036: PUSH
29037: LD_EXP 64
29041: PPUSH
29042: CALL_OW 302
29046: AND
29047: IFFALSE 29068
29049: PUSH
29050: LD_INT 5
29052: PPUSH
29053: LD_INT 22
29055: PUSH
29056: LD_INT 1
29058: PUSH
29059: EMPTY
29060: LIST
29061: LIST
29062: PPUSH
29063: CALL_OW 70
29067: AND
29068: IFFALSE 29830
29070: GO 29072
29072: DISABLE
29073: LD_INT 0
29075: PPUSH
29076: PPUSH
29077: PPUSH
// begin legionDestroyed := true ;
29078: LD_ADDR_EXP 22
29082: PUSH
29083: LD_INT 1
29085: ST_TO_ADDR
// DialogueOn ;
29086: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
29090: LD_EXP 40
29094: PPUSH
29095: LD_STRING D13-JMM-1
29097: PPUSH
29098: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
29102: LD_EXP 64
29106: PPUSH
29107: LD_STRING D13-Kurt-1
29109: PPUSH
29110: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
29114: LD_EXP 40
29118: PPUSH
29119: LD_STRING D13-JMM-2
29121: PPUSH
29122: CALL_OW 88
// if FakeInfo then
29126: LD_EXP 12
29130: IFFALSE 29150
// begin Say ( Kurt , D13-Kurt-2 ) ;
29132: LD_EXP 64
29136: PPUSH
29137: LD_STRING D13-Kurt-2
29139: PPUSH
29140: CALL_OW 88
// DialogueOff ;
29144: CALL_OW 7
// exit ;
29148: GO 29830
// end ; if not KurtStatus then
29150: LD_EXP 3
29154: NOT
29155: IFFALSE 29171
// Say ( Kurt , D13-Kurt-2b ) else
29157: LD_EXP 64
29161: PPUSH
29162: LD_STRING D13-Kurt-2b
29164: PPUSH
29165: CALL_OW 88
29169: GO 29183
// Say ( Kurt , D13-Kurt-2a ) ;
29171: LD_EXP 64
29175: PPUSH
29176: LD_STRING D13-Kurt-2a
29178: PPUSH
29179: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
29183: LD_EXP 40
29187: PPUSH
29188: LD_STRING D13-JMM-3
29190: PPUSH
29191: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
29195: LD_EXP 64
29199: PPUSH
29200: LD_STRING D13-Kurt-3
29202: PPUSH
29203: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
29207: LD_EXP 40
29211: PPUSH
29212: LD_STRING D13-JMM-4
29214: PPUSH
29215: CALL_OW 88
// DialogueOff ;
29219: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
29223: LD_STRING MlegionOut
29225: PPUSH
29226: CALL_OW 337
// MC_Kill ( 3 ) ;
29230: LD_INT 3
29232: PPUSH
29233: CALL 40134 0 1
// KillUnit ( Kozlov ) ;
29237: LD_EXP 65
29241: PPUSH
29242: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
29246: LD_ADDR_VAR 0 1
29250: PUSH
29251: LD_INT 22
29253: PUSH
29254: LD_INT 8
29256: PUSH
29257: EMPTY
29258: LIST
29259: LIST
29260: PUSH
29261: LD_INT 23
29263: PUSH
29264: LD_INT 3
29266: PUSH
29267: EMPTY
29268: LIST
29269: LIST
29270: PUSH
29271: LD_INT 3
29273: PUSH
29274: LD_INT 21
29276: PUSH
29277: LD_INT 33
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: EMPTY
29285: LIST
29286: LIST
29287: PUSH
29288: EMPTY
29289: LIST
29290: LIST
29291: LIST
29292: PPUSH
29293: CALL_OW 69
29297: PUSH
29298: FOR_IN
29299: IFFALSE 29312
// KillUnit ( i ) ;
29301: LD_VAR 0 1
29305: PPUSH
29306: CALL_OW 66
29310: GO 29298
29312: POP
29313: POP
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
29314: LD_ADDR_VAR 0 1
29318: PUSH
29319: LD_INT 22
29321: PUSH
29322: LD_INT 8
29324: PUSH
29325: EMPTY
29326: LIST
29327: LIST
29328: PUSH
29329: LD_INT 21
29331: PUSH
29332: LD_INT 2
29334: PUSH
29335: EMPTY
29336: LIST
29337: LIST
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PPUSH
29343: CALL_OW 69
29347: PUSH
29348: FOR_IN
29349: IFFALSE 29362
// KillUnit ( i ) ;
29351: LD_VAR 0 1
29355: PPUSH
29356: CALL_OW 66
29360: GO 29348
29362: POP
29363: POP
// wait ( 0 0$0.6 ) ;
29364: LD_INT 21
29366: PPUSH
29367: CALL_OW 67
// ChangeSideFog ( 8 , 1 ) ;
29371: LD_INT 8
29373: PPUSH
29374: LD_INT 1
29376: PPUSH
29377: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
29381: LD_ADDR_VAR 0 2
29385: PUSH
29386: LD_INT 22
29388: PUSH
29389: LD_INT 8
29391: PUSH
29392: EMPTY
29393: LIST
29394: LIST
29395: PUSH
29396: LD_INT 21
29398: PUSH
29399: LD_INT 1
29401: PUSH
29402: EMPTY
29403: LIST
29404: LIST
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PPUSH
29410: CALL_OW 69
29414: PUSH
29415: LD_EXP 65
29419: PUSH
29420: LD_EXP 64
29424: PUSH
29425: EMPTY
29426: LIST
29427: LIST
29428: DIFF
29429: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
29430: LD_VAR 0 2
29434: PUSH
29435: LD_INT 6
29437: PUSH
29438: LD_INT 5
29440: PUSH
29441: LD_INT 4
29443: PUSH
29444: LD_INT 3
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: PUSH
29453: LD_OWVAR 67
29457: ARRAY
29458: GREATEREQUAL
29459: IFFALSE 29611
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
29461: LD_ADDR_VAR 0 3
29465: PUSH
29466: LD_INT 6
29468: PUSH
29469: LD_INT 5
29471: PUSH
29472: LD_INT 4
29474: PUSH
29475: LD_INT 3
29477: PUSH
29478: EMPTY
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: PUSH
29484: LD_OWVAR 67
29488: ARRAY
29489: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
29490: LD_ADDR_VAR 0 1
29494: PUSH
29495: DOUBLE
29496: LD_VAR 0 2
29500: PUSH
29501: LD_VAR 0 3
29505: PUSH
29506: LD_INT 1
29508: PLUS
29509: MINUS
29510: INC
29511: ST_TO_ADDR
29512: LD_INT 1
29514: PUSH
29515: FOR_DOWNTO
29516: IFFALSE 29607
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
29518: LD_ADDR_EXP 38
29522: PUSH
29523: LD_EXP 38
29527: PUSH
29528: LD_VAR 0 2
29532: PUSH
29533: LD_VAR 0 1
29537: ARRAY
29538: ADD
29539: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
29540: LD_VAR 0 2
29544: PUSH
29545: LD_VAR 0 1
29549: ARRAY
29550: PPUSH
29551: CALL_OW 310
29555: IFFALSE 29572
// ComExit ( tmp [ i ] ) ;
29557: LD_VAR 0 2
29561: PUSH
29562: LD_VAR 0 1
29566: ARRAY
29567: PPUSH
29568: CALL 109537 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
29572: LD_VAR 0 2
29576: PUSH
29577: LD_VAR 0 1
29581: ARRAY
29582: PPUSH
29583: LD_INT 34
29585: PUSH
29586: LD_INT 0
29588: PPUSH
29589: LD_INT 6
29591: PPUSH
29592: CALL_OW 12
29596: PLUS
29597: PPUSH
29598: LD_INT 1
29600: PPUSH
29601: CALL_OW 171
// end ;
29605: GO 29515
29607: POP
29608: POP
// end else
29609: GO 29621
// x := tmp ;
29611: LD_ADDR_VAR 0 3
29615: PUSH
29616: LD_VAR 0 2
29620: ST_TO_ADDR
// for i := tmp downto tmp - x do
29621: LD_ADDR_VAR 0 1
29625: PUSH
29626: DOUBLE
29627: LD_VAR 0 2
29631: INC
29632: ST_TO_ADDR
29633: LD_VAR 0 2
29637: PUSH
29638: LD_VAR 0 3
29642: MINUS
29643: PUSH
29644: FOR_DOWNTO
29645: IFFALSE 29717
// begin if IsInUnit ( tmp [ i ] ) then
29647: LD_VAR 0 2
29651: PUSH
29652: LD_VAR 0 1
29656: ARRAY
29657: PPUSH
29658: CALL_OW 310
29662: IFFALSE 29679
// ComExit ( tmp [ i ] ) ;
29664: LD_VAR 0 2
29668: PUSH
29669: LD_VAR 0 1
29673: ARRAY
29674: PPUSH
29675: CALL 109537 0 1
// SetSide ( tmp [ i ] , 1 ) ;
29679: LD_VAR 0 2
29683: PUSH
29684: LD_VAR 0 1
29688: ARRAY
29689: PPUSH
29690: LD_INT 1
29692: PPUSH
29693: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
29697: LD_VAR 0 2
29701: PUSH
29702: LD_VAR 0 1
29706: ARRAY
29707: PPUSH
29708: LD_INT 1000
29710: PPUSH
29711: CALL_OW 234
// end ;
29715: GO 29644
29717: POP
29718: POP
// SetSide ( Kurt , 1 ) ;
29719: LD_EXP 64
29723: PPUSH
29724: LD_INT 1
29726: PPUSH
29727: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
29731: LD_INT 22
29733: PUSH
29734: LD_INT 8
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 21
29743: PUSH
29744: LD_INT 3
29746: PUSH
29747: EMPTY
29748: LIST
29749: LIST
29750: PUSH
29751: EMPTY
29752: LIST
29753: LIST
29754: PPUSH
29755: CALL_OW 69
29759: PPUSH
29760: LD_INT 1
29762: PPUSH
29763: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
29767: LD_INT 8
29769: PPUSH
29770: LD_INT 1
29772: PPUSH
29773: LD_INT 1
29775: PPUSH
29776: LD_INT 1
29778: PPUSH
29779: CALL_OW 80
// wait ( 1 1$20 ) ;
29783: LD_INT 2800
29785: PPUSH
29786: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
29790: LD_EXP 66
29794: PPUSH
29795: LD_INT 37
29797: PPUSH
29798: LD_INT 1
29800: PPUSH
29801: LD_INT 0
29803: PPUSH
29804: CALL_OW 48
// wait ( 0 0$1 ) ;
29808: LD_INT 35
29810: PPUSH
29811: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
29815: LD_EXP 66
29819: PPUSH
29820: LD_INT 60
29822: PPUSH
29823: LD_INT 95
29825: PPUSH
29826: CALL_OW 111
// end ;
29830: PPOPN 3
29832: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
29833: LD_EXP 22
29837: NOT
29838: IFFALSE 29874
29840: PUSH
29841: LD_INT 22
29843: PUSH
29844: LD_INT 8
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 21
29853: PUSH
29854: LD_INT 1
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: PPUSH
29865: CALL_OW 69
29869: PUSH
29870: LD_INT 0
29872: EQUAL
29873: AND
29874: IFFALSE 29894
29876: GO 29878
29878: DISABLE
// begin legionDestroyed := true ;
29879: LD_ADDR_EXP 22
29883: PUSH
29884: LD_INT 1
29886: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
29887: LD_STRING MlegionOut
29889: PPUSH
29890: CALL_OW 337
// end ;
29894: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
29895: LD_EXP 38
29899: IFFALSE 29974
29901: GO 29903
29903: DISABLE
29904: LD_INT 0
29906: PPUSH
// begin enable ;
29907: ENABLE
// for i in legionEscapeUnits do
29908: LD_ADDR_VAR 0 1
29912: PUSH
29913: LD_EXP 38
29917: PUSH
29918: FOR_IN
29919: IFFALSE 29972
// begin if IsInArea ( i , legionEscapeArea ) then
29921: LD_VAR 0 1
29925: PPUSH
29926: LD_INT 31
29928: PPUSH
29929: CALL_OW 308
29933: IFFALSE 29946
// RemoveUnit ( i ) else
29935: LD_VAR 0 1
29939: PPUSH
29940: CALL_OW 64
29944: GO 29970
// if not HasTask ( i ) then
29946: LD_VAR 0 1
29950: PPUSH
29951: CALL_OW 314
29955: NOT
29956: IFFALSE 29970
// ComMoveToArea ( i , legionEscapeArea ) ;
29958: LD_VAR 0 1
29962: PPUSH
29963: LD_INT 31
29965: PPUSH
29966: CALL_OW 113
// end ;
29970: GO 29918
29972: POP
29973: POP
// end ;
29974: PPOPN 1
29976: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
29977: LD_INT 1
29979: PPUSH
29980: LD_EXP 66
29984: PPUSH
29985: CALL_OW 292
29989: IFFALSE 30287
29991: GO 29993
29993: DISABLE
29994: LD_INT 0
29996: PPUSH
// begin wait ( 0 0$2 ) ;
29997: LD_INT 70
29999: PPUSH
30000: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
30004: LD_EXP 66
30008: PPUSH
30009: CALL_OW 87
// DialogueOn ;
30013: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
30017: LD_EXP 40
30021: PPUSH
30022: LD_STRING D14-JMM-1
30024: PPUSH
30025: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
30029: LD_EXP 66
30033: PPUSH
30034: LD_STRING D14-Friend-1
30036: PPUSH
30037: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
30041: LD_EXP 40
30045: PPUSH
30046: LD_STRING D14-JMM-2
30048: PPUSH
30049: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
30053: LD_EXP 66
30057: PPUSH
30058: LD_STRING D14-Friend-2
30060: PPUSH
30061: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
30065: LD_EXP 40
30069: PPUSH
30070: LD_STRING D14-JMM-3
30072: PPUSH
30073: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
30077: LD_EXP 66
30081: PPUSH
30082: LD_STRING D14-Friend-3
30084: PPUSH
30085: CALL_OW 88
// DialogueOff ;
30089: CALL_OW 7
// dec := Query ( Q14 ) ;
30093: LD_ADDR_VAR 0 1
30097: PUSH
30098: LD_STRING Q14
30100: PPUSH
30101: CALL_OW 97
30105: ST_TO_ADDR
// if dec = 1 then
30106: LD_VAR 0 1
30110: PUSH
30111: LD_INT 1
30113: EQUAL
30114: IFFALSE 30148
// begin DialogueOn ;
30116: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
30120: LD_EXP 40
30124: PPUSH
30125: LD_STRING D14a-JMM-1
30127: PPUSH
30128: CALL_OW 88
// DialogueOff ;
30132: CALL_OW 7
// SetSide ( Friend , 1 ) ;
30136: LD_EXP 66
30140: PPUSH
30141: LD_INT 1
30143: PPUSH
30144: CALL_OW 235
// end ; if dec = 2 then
30148: LD_VAR 0 1
30152: PUSH
30153: LD_INT 2
30155: EQUAL
30156: IFFALSE 30209
// begin DialogueOn ;
30158: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
30162: LD_EXP 40
30166: PPUSH
30167: LD_STRING D14b-JMM-1
30169: PPUSH
30170: CALL_OW 88
// DialogueOff ;
30174: CALL_OW 7
// wait ( 0 0$1 ) ;
30178: LD_INT 35
30180: PPUSH
30181: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
30185: LD_EXP 66
30189: PPUSH
30190: LD_INT 9
30192: PPUSH
30193: LD_INT 2
30195: PPUSH
30196: CALL_OW 111
// AddComHold ( Friend ) ;
30200: LD_EXP 66
30204: PPUSH
30205: CALL_OW 200
// end ; if dec = 3 then
30209: LD_VAR 0 1
30213: PUSH
30214: LD_INT 3
30216: EQUAL
30217: IFFALSE 30287
// begin DialogueOn ;
30219: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
30223: LD_EXP 40
30227: PPUSH
30228: LD_STRING D14c-JMM-1
30230: PPUSH
30231: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
30235: LD_EXP 66
30239: PPUSH
30240: LD_STRING D14c-Friend-1
30242: PPUSH
30243: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
30247: LD_EXP 40
30251: PPUSH
30252: LD_STRING D14c-JMM-2
30254: PPUSH
30255: CALL_OW 88
// DialogueOff ;
30259: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
30263: LD_EXP 66
30267: PPUSH
30268: LD_INT 9
30270: PPUSH
30271: LD_INT 2
30273: PPUSH
30274: CALL_OW 111
// AddComHold ( Friend ) ;
30278: LD_EXP 66
30282: PPUSH
30283: CALL_OW 200
// end ; end ;
30287: PPOPN 1
30289: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
30290: LD_INT 9
30292: PPUSH
30293: LD_INT 2
30295: PPUSH
30296: CALL_OW 428
30300: PUSH
30301: LD_EXP 66
30305: EQUAL
30306: IFFALSE 30323
30308: PUSH
30309: LD_EXP 66
30313: PPUSH
30314: CALL_OW 255
30318: PUSH
30319: LD_INT 8
30321: EQUAL
30322: AND
30323: IFFALSE 30337
30325: GO 30327
30327: DISABLE
// RemoveUnit ( Friend ) ;
30328: LD_EXP 66
30332: PPUSH
30333: CALL_OW 64
30337: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
30338: LD_EXP 14
30342: PUSH
30343: LD_INT 31500
30345: GREATEREQUAL
30346: IFFALSE 30354
30348: PUSH
30349: LD_EXP 7
30353: AND
30354: IFFALSE 30362
30356: PUSH
30357: LD_EXP 2
30361: AND
30362: IFFALSE 30808
30364: GO 30366
30366: DISABLE
30367: LD_INT 0
30369: PPUSH
30370: PPUSH
30371: PPUSH
// begin missionStage := 7 ;
30372: LD_ADDR_EXP 15
30376: PUSH
30377: LD_INT 7
30379: ST_TO_ADDR
// for i := 1 to 5 do
30380: LD_ADDR_VAR 0 1
30384: PUSH
30385: DOUBLE
30386: LD_INT 1
30388: DEC
30389: ST_TO_ADDR
30390: LD_INT 5
30392: PUSH
30393: FOR_TO
30394: IFFALSE 30506
// begin uc_side = 1 ;
30396: LD_ADDR_OWVAR 20
30400: PUSH
30401: LD_INT 1
30403: ST_TO_ADDR
// uc_nation = 1 ;
30404: LD_ADDR_OWVAR 21
30408: PUSH
30409: LD_INT 1
30411: ST_TO_ADDR
// vc_engine = engine_siberite ;
30412: LD_ADDR_OWVAR 39
30416: PUSH
30417: LD_INT 3
30419: ST_TO_ADDR
// vc_control = control_computer ;
30420: LD_ADDR_OWVAR 38
30424: PUSH
30425: LD_INT 3
30427: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
30428: LD_ADDR_OWVAR 37
30432: PUSH
30433: LD_INT 3
30435: ST_TO_ADDR
// vc_weapon = [ us_double_gun , us_laser , us_rocket_launcher ] [ Rand ( 1 , 3 ) ] ;
30436: LD_ADDR_OWVAR 40
30440: PUSH
30441: LD_INT 5
30443: PUSH
30444: LD_INT 9
30446: PUSH
30447: LD_INT 7
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: LIST
30454: PUSH
30455: LD_INT 1
30457: PPUSH
30458: LD_INT 3
30460: PPUSH
30461: CALL_OW 12
30465: ARRAY
30466: ST_TO_ADDR
// veh = CreateVehicle ;
30467: LD_ADDR_VAR 0 2
30471: PUSH
30472: CALL_OW 45
30476: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30477: LD_VAR 0 2
30481: PPUSH
30482: LD_INT 1
30484: PPUSH
30485: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30489: LD_VAR 0 2
30493: PPUSH
30494: LD_INT 19
30496: PPUSH
30497: LD_INT 0
30499: PPUSH
30500: CALL_OW 49
// end ;
30504: GO 30393
30506: POP
30507: POP
// uc_side = 1 ;
30508: LD_ADDR_OWVAR 20
30512: PUSH
30513: LD_INT 1
30515: ST_TO_ADDR
// uc_nation = 1 ;
30516: LD_ADDR_OWVAR 21
30520: PUSH
30521: LD_INT 1
30523: ST_TO_ADDR
// vc_engine = 3 ;
30524: LD_ADDR_OWVAR 39
30528: PUSH
30529: LD_INT 3
30531: ST_TO_ADDR
// vc_control = 1 ;
30532: LD_ADDR_OWVAR 38
30536: PUSH
30537: LD_INT 1
30539: ST_TO_ADDR
// vc_chassis = 3 ;
30540: LD_ADDR_OWVAR 37
30544: PUSH
30545: LD_INT 3
30547: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
30548: LD_ADDR_OWVAR 40
30552: PUSH
30553: LD_INT 5
30555: PUSH
30556: LD_INT 9
30558: PUSH
30559: LD_INT 7
30561: PUSH
30562: EMPTY
30563: LIST
30564: LIST
30565: LIST
30566: PUSH
30567: LD_INT 1
30569: PPUSH
30570: LD_INT 3
30572: PPUSH
30573: CALL_OW 12
30577: ARRAY
30578: ST_TO_ADDR
// vehG = CreateVehicle ;
30579: LD_ADDR_VAR 0 3
30583: PUSH
30584: CALL_OW 45
30588: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
30589: LD_VAR 0 3
30593: PPUSH
30594: LD_INT 1
30596: PPUSH
30597: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
30601: LD_VAR 0 3
30605: PPUSH
30606: LD_INT 19
30608: PPUSH
30609: LD_INT 0
30611: PPUSH
30612: CALL_OW 49
// if JMMGirl = 1 then
30616: LD_EXP 7
30620: PUSH
30621: LD_INT 1
30623: EQUAL
30624: IFFALSE 30680
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
30626: LD_ADDR_EXP 41
30630: PUSH
30631: LD_STRING Joan
30633: PPUSH
30634: LD_INT 1
30636: PPUSH
30637: LD_STRING 14_
30639: PPUSH
30640: CALL 70939 0 3
30644: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
30645: LD_EXP 41
30649: PPUSH
30650: LD_VAR 0 3
30654: PPUSH
30655: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30659: LD_VAR 0 3
30663: PPUSH
30664: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
30668: LD_EXP 41
30672: PPUSH
30673: LD_STRING D10BW-Joan-1
30675: PPUSH
30676: CALL_OW 94
// end ; if JMMGirl = 2 then
30680: LD_EXP 7
30684: PUSH
30685: LD_INT 2
30687: EQUAL
30688: IFFALSE 30744
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
30690: LD_ADDR_EXP 43
30694: PUSH
30695: LD_STRING Lisa
30697: PPUSH
30698: LD_INT 1
30700: PPUSH
30701: LD_STRING 14_
30703: PPUSH
30704: CALL 70939 0 3
30708: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
30709: LD_EXP 43
30713: PPUSH
30714: LD_VAR 0 3
30718: PPUSH
30719: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30723: LD_VAR 0 3
30727: PPUSH
30728: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
30732: LD_EXP 43
30736: PPUSH
30737: LD_STRING D10BW-Lisa-1
30739: PPUSH
30740: CALL_OW 94
// end ; if JMMGirl = 3 then
30744: LD_EXP 7
30748: PUSH
30749: LD_INT 3
30751: EQUAL
30752: IFFALSE 30808
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
30754: LD_ADDR_EXP 55
30758: PUSH
30759: LD_STRING Connie
30761: PPUSH
30762: LD_INT 1
30764: PPUSH
30765: LD_STRING 14_
30767: PPUSH
30768: CALL 70939 0 3
30772: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
30773: LD_EXP 55
30777: PPUSH
30778: LD_VAR 0 3
30782: PPUSH
30783: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
30787: LD_VAR 0 3
30791: PPUSH
30792: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
30796: LD_EXP 55
30800: PPUSH
30801: LD_STRING D10BW-Con-1
30803: PPUSH
30804: CALL_OW 94
// end ; end ;
30808: PPOPN 3
30810: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
30811: LD_EXP 14
30815: PUSH
30816: LD_INT 94500
30818: GREATEREQUAL
30819: IFFALSE 31231
30821: GO 30823
30823: DISABLE
30824: LD_INT 0
30826: PPUSH
30827: PPUSH
30828: PPUSH
// begin tmp := PrepareStevensSquad ;
30829: LD_ADDR_VAR 0 3
30833: PUSH
30834: CALL 2384 0 0
30838: ST_TO_ADDR
// if not tmp then
30839: LD_VAR 0 3
30843: NOT
30844: IFFALSE 30848
// exit ;
30846: GO 31231
// uc_side := 1 ;
30848: LD_ADDR_OWVAR 20
30852: PUSH
30853: LD_INT 1
30855: ST_TO_ADDR
// uc_nation := 1 ;
30856: LD_ADDR_OWVAR 21
30860: PUSH
30861: LD_INT 1
30863: ST_TO_ADDR
// for i in tmp do
30864: LD_ADDR_VAR 0 1
30868: PUSH
30869: LD_VAR 0 3
30873: PUSH
30874: FOR_IN
30875: IFFALSE 30972
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
30877: LD_INT 3
30879: PPUSH
30880: LD_INT 3
30882: PPUSH
30883: LD_INT 1
30885: PPUSH
30886: LD_INT 5
30888: PUSH
30889: LD_INT 9
30891: PUSH
30892: LD_INT 7
30894: PUSH
30895: EMPTY
30896: LIST
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 1
30902: PPUSH
30903: LD_INT 3
30905: PPUSH
30906: CALL_OW 12
30910: ARRAY
30911: PPUSH
30912: LD_INT 40
30914: PPUSH
30915: CALL 75959 0 5
// veh := CreateVehicle ;
30919: LD_ADDR_VAR 0 2
30923: PUSH
30924: CALL_OW 45
30928: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
30929: LD_VAR 0 2
30933: PPUSH
30934: LD_INT 1
30936: PPUSH
30937: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
30941: LD_VAR 0 2
30945: PPUSH
30946: LD_INT 19
30948: PPUSH
30949: LD_INT 0
30951: PPUSH
30952: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
30956: LD_VAR 0 1
30960: PPUSH
30961: LD_VAR 0 2
30965: PPUSH
30966: CALL_OW 52
// end ;
30970: GO 30874
30972: POP
30973: POP
// missionStage := 8 ;
30974: LD_ADDR_EXP 15
30978: PUSH
30979: LD_INT 8
30981: ST_TO_ADDR
// DialogueOn ;
30982: CALL_OW 6
// if Stevens then
30986: LD_EXP 42
30990: IFFALSE 31104
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
30992: LD_EXP 42
30996: PPUSH
30997: CALL_OW 310
31001: PPUSH
31002: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
31006: LD_EXP 42
31010: PPUSH
31011: LD_STRING D8-Huck-1
31013: PPUSH
31014: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
31018: LD_EXP 40
31022: PPUSH
31023: LD_STRING D8-JMM-1
31025: PPUSH
31026: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
31030: LD_EXP 42
31034: PPUSH
31035: LD_STRING D8-Huck-2
31037: PPUSH
31038: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
31042: LD_EXP 40
31046: PPUSH
31047: LD_STRING D8-JMM-2
31049: PPUSH
31050: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
31054: LD_EXP 42
31058: PPUSH
31059: LD_STRING D8-Huck-3
31061: PPUSH
31062: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
31066: LD_EXP 40
31070: PPUSH
31071: LD_STRING D8-JMM-3
31073: PPUSH
31074: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
31078: LD_EXP 42
31082: PPUSH
31083: LD_STRING D8-Huck-4
31085: PPUSH
31086: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
31090: LD_EXP 40
31094: PPUSH
31095: LD_STRING D8-JMM-4
31097: PPUSH
31098: CALL_OW 88
// end else
31102: GO 31214
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
31104: LD_EXP 56
31108: PPUSH
31109: CALL_OW 310
31113: PPUSH
31114: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
31118: LD_EXP 56
31122: PPUSH
31123: LD_STRING D8-Huck-1
31125: PPUSH
31126: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
31130: LD_EXP 40
31134: PPUSH
31135: LD_STRING D8-JMM-1a
31137: PPUSH
31138: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
31142: LD_EXP 56
31146: PPUSH
31147: LD_STRING D8-Huck-2
31149: PPUSH
31150: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
31154: LD_EXP 40
31158: PPUSH
31159: LD_STRING D8-JMM-2
31161: PPUSH
31162: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
31166: LD_EXP 56
31170: PPUSH
31171: LD_STRING D8-Huck-3
31173: PPUSH
31174: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
31178: LD_EXP 40
31182: PPUSH
31183: LD_STRING D8-JMM-3
31185: PPUSH
31186: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
31190: LD_EXP 56
31194: PPUSH
31195: LD_STRING D8-Huck-4
31197: PPUSH
31198: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
31202: LD_EXP 40
31206: PPUSH
31207: LD_STRING D8-JMM-4
31209: PPUSH
31210: CALL_OW 88
// end ; DialogueOff ;
31214: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
31218: LD_INT 25
31220: PPUSH
31221: LD_INT 1
31223: PPUSH
31224: LD_INT 1
31226: PPUSH
31227: CALL_OW 322
// end ;
31231: PPOPN 3
31233: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
31234: LD_EXP 75
31238: PPUSH
31239: CALL_OW 302
31243: IFFALSE 31259
31245: PUSH
31246: LD_INT 1
31248: PPUSH
31249: LD_EXP 75
31253: PPUSH
31254: CALL_OW 292
31258: AND
31259: IFFALSE 31497
31261: GO 31263
31263: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
31264: LD_EXP 75
31268: PPUSH
31269: CALL_OW 87
// DialogueOn ;
31273: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
31277: LD_EXP 40
31281: PPUSH
31282: LD_STRING D10nB-JMM-1
31284: PPUSH
31285: CALL_OW 88
// if BurlakStatus = 1 then
31289: LD_EXP 9
31293: PUSH
31294: LD_INT 1
31296: EQUAL
31297: IFFALSE 31313
// SayRadio ( Vsevolod , D10nB-Vse-1a ) else
31299: LD_EXP 74
31303: PPUSH
31304: LD_STRING D10nB-Vse-1a
31306: PPUSH
31307: CALL_OW 94
31311: GO 31325
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
31313: LD_EXP 74
31317: PPUSH
31318: LD_STRING D10nB-Vse-1
31320: PPUSH
31321: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
31325: LD_EXP 40
31329: PPUSH
31330: LD_STRING D10nB-JMM-2
31332: PPUSH
31333: CALL_OW 88
// if KappaStatus then
31337: LD_EXP 2
31341: IFFALSE 31357
// SayRadio ( Vsevolod , D10nB-Vse-5a ) else
31343: LD_EXP 74
31347: PPUSH
31348: LD_STRING D10nB-Vse-5a
31350: PPUSH
31351: CALL_OW 94
31355: GO 31493
// if JMMGirlStatus = 0 then
31357: LD_EXP 6
31361: PUSH
31362: LD_INT 0
31364: EQUAL
31365: IFFALSE 31493
// begin if JMMGirl = 1 then
31367: LD_EXP 7
31371: PUSH
31372: LD_INT 1
31374: EQUAL
31375: IFFALSE 31425
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
31377: LD_EXP 74
31381: PPUSH
31382: LD_STRING D10nB-Vse-2
31384: PPUSH
31385: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
31389: LD_EXP 40
31393: PPUSH
31394: LD_STRING D10nB-JMM-3
31396: PPUSH
31397: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
31401: LD_EXP 74
31405: PPUSH
31406: LD_STRING D10nB-Vse-3
31408: PPUSH
31409: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
31413: LD_EXP 40
31417: PPUSH
31418: LD_STRING D10nB-JMM-4
31420: PPUSH
31421: CALL_OW 88
// end ; if JMMGirl = 2 then
31425: LD_EXP 7
31429: PUSH
31430: LD_INT 2
31432: EQUAL
31433: IFFALSE 31459
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
31435: LD_EXP 74
31439: PPUSH
31440: LD_STRING D10nB-Vse-4
31442: PPUSH
31443: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
31447: LD_EXP 40
31451: PPUSH
31452: LD_STRING D10nB-JMM-5
31454: PPUSH
31455: CALL_OW 88
// end ; if JMMGirl = 3 then
31459: LD_EXP 7
31463: PUSH
31464: LD_INT 3
31466: EQUAL
31467: IFFALSE 31493
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
31469: LD_EXP 74
31473: PPUSH
31474: LD_STRING D10nB-Vse-5
31476: PPUSH
31477: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
31481: LD_EXP 40
31485: PPUSH
31486: LD_STRING D10nB-JMM-6
31488: PPUSH
31489: CALL_OW 88
// end ; end ; DialogueOff ;
31493: CALL_OW 7
// end ;
31497: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var i , j , tmp ;
31498: LD_EXP 14
31502: PUSH
31503: LD_INT 115500
31505: GREATEREQUAL
31506: IFFALSE 31519
31508: PUSH
31509: LD_EXP 69
31513: PPUSH
31514: CALL_OW 302
31518: AND
31519: IFFALSE 31530
31521: PUSH
31522: LD_INT 267
31524: PPUSH
31525: CALL_OW 302
31529: AND
31530: IFFALSE 32046
31532: GO 31534
31534: DISABLE
31535: LD_INT 0
31537: PPUSH
31538: PPUSH
31539: PPUSH
// begin missionStage := 10 ;
31540: LD_ADDR_EXP 15
31544: PUSH
31545: LD_INT 10
31547: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31548: LD_ADDR_VAR 0 3
31552: PUSH
31553: LD_INT 22
31555: PUSH
31556: LD_INT 1
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 23
31565: PUSH
31566: LD_INT 1
31568: PUSH
31569: EMPTY
31570: LIST
31571: LIST
31572: PUSH
31573: LD_INT 26
31575: PUSH
31576: LD_INT 1
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 3
31585: PUSH
31586: LD_INT 25
31588: PUSH
31589: LD_INT 12
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: EMPTY
31597: LIST
31598: LIST
31599: PUSH
31600: LD_INT 3
31602: PUSH
31603: LD_INT 25
31605: PUSH
31606: LD_INT 16
31608: PUSH
31609: EMPTY
31610: LIST
31611: LIST
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: LIST
31621: LIST
31622: LIST
31623: PPUSH
31624: CALL_OW 69
31628: PUSH
31629: LD_EXP 40
31633: PUSH
31634: LD_EXP 64
31638: PUSH
31639: LD_EXP 42
31643: PUSH
31644: LD_EXP 56
31648: PUSH
31649: LD_EXP 43
31653: PUSH
31654: LD_EXP 44
31658: PUSH
31659: LD_EXP 45
31663: PUSH
31664: LD_EXP 46
31668: PUSH
31669: LD_EXP 47
31673: PUSH
31674: LD_EXP 48
31678: PUSH
31679: LD_EXP 49
31683: PUSH
31684: LD_EXP 50
31688: PUSH
31689: LD_EXP 51
31693: PUSH
31694: LD_EXP 52
31698: PUSH
31699: LD_EXP 53
31703: PUSH
31704: LD_EXP 54
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: DIFF
31727: ST_TO_ADDR
// if not tmp and Brown then
31728: LD_VAR 0 3
31732: NOT
31733: IFFALSE 31741
31735: PUSH
31736: LD_EXP 48
31740: AND
31741: IFFALSE 31756
// tmp := [ Brown ] ;
31743: LD_ADDR_VAR 0 3
31747: PUSH
31748: LD_EXP 48
31752: PUSH
31753: EMPTY
31754: LIST
31755: ST_TO_ADDR
// DialogueOn ;
31756: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
31760: LD_VAR 0 3
31764: PUSH
31765: LD_INT 1
31767: ARRAY
31768: PPUSH
31769: LD_STRING D11-Sol1-1
31771: PPUSH
31772: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
31776: LD_EXP 68
31780: PPUSH
31781: LD_STRING D11-Pla-1
31783: PPUSH
31784: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
31788: LD_EXP 69
31792: PPUSH
31793: LD_STRING D11-Kov-1
31795: PPUSH
31796: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
31800: LD_EXP 68
31804: PPUSH
31805: LD_STRING D11-Pla-2
31807: PPUSH
31808: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
31812: LD_VAR 0 3
31816: PUSH
31817: LD_INT 1
31819: ARRAY
31820: PPUSH
31821: LD_STRING D11-Sol1-2
31823: PPUSH
31824: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
31828: LD_EXP 40
31832: PPUSH
31833: LD_STRING D11-JMM-2
31835: PPUSH
31836: CALL_OW 88
// DialogueOff ;
31840: CALL_OW 7
// allowBehemothConstruct := true ;
31844: LD_ADDR_EXP 25
31848: PUSH
31849: LD_INT 1
31851: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
31852: LD_STRING M4
31854: PPUSH
31855: CALL_OW 337
// j := 3 ;
31859: LD_ADDR_VAR 0 2
31863: PUSH
31864: LD_INT 3
31866: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_ok ] , [ f_not , [ f_tag , 105 ] ] , [ f_class , 3 ] ] ) diff Kovalyuk ;
31867: LD_ADDR_VAR 0 3
31871: PUSH
31872: LD_INT 22
31874: PUSH
31875: LD_INT 3
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 50
31884: PUSH
31885: EMPTY
31886: LIST
31887: PUSH
31888: LD_INT 3
31890: PUSH
31891: LD_INT 120
31893: PUSH
31894: LD_INT 105
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 25
31907: PUSH
31908: LD_INT 3
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: LIST
31919: LIST
31920: PPUSH
31921: CALL_OW 69
31925: PUSH
31926: LD_EXP 69
31930: DIFF
31931: ST_TO_ADDR
// for i in tmp do
31932: LD_ADDR_VAR 0 1
31936: PUSH
31937: LD_VAR 0 3
31941: PUSH
31942: FOR_IN
31943: IFFALSE 31993
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
31945: LD_ADDR_EXP 77
31949: PUSH
31950: LD_EXP 77
31954: PPUSH
31955: LD_VAR 0 1
31959: PPUSH
31960: CALL 109139 0 2
31964: ST_TO_ADDR
// j := j - 1 ;
31965: LD_ADDR_VAR 0 2
31969: PUSH
31970: LD_VAR 0 2
31974: PUSH
31975: LD_INT 1
31977: MINUS
31978: ST_TO_ADDR
// if j = 0 then
31979: LD_VAR 0 2
31983: PUSH
31984: LD_INT 0
31986: EQUAL
31987: IFFALSE 31991
// break ;
31989: GO 31993
// end ;
31991: GO 31942
31993: POP
31994: POP
// BuildBehemoths ;
31995: CALL 8388 0 0
// repeat wait ( 15 15$00 ) ;
31999: LD_INT 31500
32001: PPUSH
32002: CALL_OW 67
// if behemothDestroyedBeforeFinish then
32006: LD_EXP 27
32010: IFFALSE 32014
// break ;
32012: GO 32046
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
32014: LD_INT 267
32016: PPUSH
32017: CALL_OW 274
32021: PPUSH
32022: LD_INT 1
32024: PPUSH
32025: CALL_OW 275
32029: PUSH
32030: LD_INT 1000
32032: GREATEREQUAL
32033: IFFALSE 32039
// BuildBehemoths ;
32035: CALL 8388 0 0
// until not behemothBuilders ;
32039: LD_EXP 77
32043: NOT
32044: IFFALSE 31999
// end ;
32046: PPOPN 3
32048: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
32049: LD_EXP 77
32053: NOT
32054: IFFALSE 32063
32056: PUSH
32057: LD_EXP 28
32061: NOT
32062: AND
32063: IFFALSE 32071
32065: PUSH
32066: LD_EXP 25
32070: AND
32071: IFFALSE 32091
32073: GO 32075
32075: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
32076: LD_STRING M4a
32078: PPUSH
32079: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
32083: LD_ADDR_EXP 27
32087: PUSH
32088: LD_INT 1
32090: ST_TO_ADDR
// end ;
32091: END
// every 0 0$1 trigger behemothDone do
32092: LD_EXP 28
32096: IFFALSE 32108
32098: GO 32100
32100: DISABLE
// ChangeMissionObjectives ( M4b ) ;
32101: LD_STRING M4b
32103: PPUSH
32104: CALL_OW 337
32108: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
32109: LD_EXP 29
32113: NOT
32114: IFFALSE 32312
32116: GO 32118
32118: DISABLE
32119: LD_INT 0
32121: PPUSH
32122: PPUSH
// begin enable ;
32123: ENABLE
// tmp := GetBehemoths ( 3 ) ;
32124: LD_ADDR_VAR 0 1
32128: PUSH
32129: LD_INT 3
32131: PPUSH
32132: CALL 109200 0 1
32136: ST_TO_ADDR
// if not tmp and not behemothDone then
32137: LD_VAR 0 1
32141: NOT
32142: IFFALSE 32151
32144: PUSH
32145: LD_EXP 28
32149: NOT
32150: AND
32151: IFFALSE 32187
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
32153: LD_ADDR_VAR 0 1
32157: PUSH
32158: LD_INT 22
32160: PUSH
32161: LD_INT 3
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 30
32170: PUSH
32171: LD_INT 37
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PPUSH
32182: CALL_OW 69
32186: ST_TO_ADDR
// if not tmp then
32187: LD_VAR 0 1
32191: NOT
32192: IFFALSE 32196
// exit ;
32194: GO 32312
// for i in tmp do
32196: LD_ADDR_VAR 0 2
32200: PUSH
32201: LD_VAR 0 1
32205: PUSH
32206: FOR_IN
32207: IFFALSE 32310
// if See ( 1 , i ) then
32209: LD_INT 1
32211: PPUSH
32212: LD_VAR 0 2
32216: PPUSH
32217: CALL_OW 292
32221: IFFALSE 32308
// begin if GetType ( i ) = unit_building then
32223: LD_VAR 0 2
32227: PPUSH
32228: CALL_OW 247
32232: PUSH
32233: LD_INT 3
32235: EQUAL
32236: IFFALSE 32274
// begin disable ;
32238: DISABLE
// CenterNowOnUnits ( i ) ;
32239: LD_VAR 0 2
32243: PPUSH
32244: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
32248: LD_EXP 40
32252: PPUSH
32253: LD_STRING D17a-JMM-1
32255: PPUSH
32256: CALL_OW 88
// seeBehemoth := true ;
32260: LD_ADDR_EXP 29
32264: PUSH
32265: LD_INT 1
32267: ST_TO_ADDR
// exit ;
32268: POP
32269: POP
32270: GO 32312
// end else
32272: GO 32308
// begin disable ;
32274: DISABLE
// CenterNowOnUnits ( i ) ;
32275: LD_VAR 0 2
32279: PPUSH
32280: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
32284: LD_EXP 40
32288: PPUSH
32289: LD_STRING D17b-JMM-1
32291: PPUSH
32292: CALL_OW 88
// seeBehemoth := true ;
32296: LD_ADDR_EXP 29
32300: PUSH
32301: LD_INT 1
32303: ST_TO_ADDR
// exit ;
32304: POP
32305: POP
32306: GO 32312
// end ; end ;
32308: GO 32206
32310: POP
32311: POP
// end ;
32312: PPOPN 2
32314: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
32315: LD_EXP 14
32319: PUSH
32320: LD_INT 123200
32322: GREATEREQUAL
32323: IFFALSE 33536
32325: GO 32327
32327: DISABLE
32328: LD_INT 0
32330: PPUSH
32331: PPUSH
32332: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
32333: LD_INT 2
32335: PPUSH
32336: LD_INT 23
32338: PUSH
32339: LD_INT 3
32341: PUSH
32342: LD_INT 3
32344: PUSH
32345: LD_INT 48
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: LIST
32352: LIST
32353: PUSH
32354: EMPTY
32355: LIST
32356: PPUSH
32357: CALL 64415 0 2
// repeat wait ( 0 0$1 ) ;
32361: LD_INT 35
32363: PPUSH
32364: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
32368: LD_INT 22
32370: PUSH
32371: LD_INT 3
32373: PUSH
32374: EMPTY
32375: LIST
32376: LIST
32377: PUSH
32378: LD_INT 34
32380: PUSH
32381: LD_INT 48
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: EMPTY
32389: LIST
32390: LIST
32391: PPUSH
32392: CALL_OW 69
32396: IFFALSE 32361
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
32398: LD_ADDR_VAR 0 1
32402: PUSH
32403: LD_INT 22
32405: PUSH
32406: LD_INT 3
32408: PUSH
32409: EMPTY
32410: LIST
32411: LIST
32412: PUSH
32413: LD_INT 34
32415: PUSH
32416: LD_INT 48
32418: PUSH
32419: EMPTY
32420: LIST
32421: LIST
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PPUSH
32427: CALL_OW 69
32431: PUSH
32432: LD_INT 1
32434: ARRAY
32435: ST_TO_ADDR
// missionStage := 12 ;
32436: LD_ADDR_EXP 15
32440: PUSH
32441: LD_INT 12
32443: ST_TO_ADDR
// platonovHasBomb := true ;
32444: LD_ADDR_EXP 30
32448: PUSH
32449: LD_INT 1
32451: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
32452: LD_VAR 0 1
32456: PPUSH
32457: LD_INT 181
32459: PPUSH
32460: LD_INT 86
32462: PPUSH
32463: CALL_OW 171
// AddComHold ( bomb ) ;
32467: LD_VAR 0 1
32471: PPUSH
32472: CALL_OW 200
// wait ( 0 0$10 ) ;
32476: LD_INT 350
32478: PPUSH
32479: CALL_OW 67
// DialogueOn ;
32483: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
32487: LD_EXP 68
32491: PPUSH
32492: LD_STRING D15-Pla-1
32494: PPUSH
32495: CALL_OW 94
// dec := Query ( Q15a ) ;
32499: LD_ADDR_VAR 0 2
32503: PUSH
32504: LD_STRING Q15a
32506: PPUSH
32507: CALL_OW 97
32511: ST_TO_ADDR
// if dec = 1 then
32512: LD_VAR 0 2
32516: PUSH
32517: LD_INT 1
32519: EQUAL
32520: IFFALSE 32543
// begin Say ( JMM , D15a-JMM-1 ) ;
32522: LD_EXP 40
32526: PPUSH
32527: LD_STRING D15a-JMM-1
32529: PPUSH
32530: CALL_OW 88
// YouLost ( Surrender ) ;
32534: LD_STRING Surrender
32536: PPUSH
32537: CALL_OW 104
// exit ;
32541: GO 33536
// end ; if dec = 2 then
32543: LD_VAR 0 2
32547: PUSH
32548: LD_INT 2
32550: EQUAL
32551: IFFALSE 32620
// begin Say ( JMM , D15b-JMM-1 ) ;
32553: LD_EXP 40
32557: PPUSH
32558: LD_STRING D15b-JMM-1
32560: PPUSH
32561: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
32565: LD_EXP 68
32569: PPUSH
32570: LD_STRING D15b-Pla-1
32572: PPUSH
32573: CALL_OW 94
// DialogueOff ;
32577: CALL_OW 7
// wait ( 3 3$00 ) ;
32581: LD_INT 6300
32583: PPUSH
32584: CALL_OW 67
// DialogueOn ;
32588: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
32592: LD_EXP 40
32596: PPUSH
32597: LD_STRING D15d-JMM-1a
32599: PPUSH
32600: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32604: LD_EXP 68
32608: PPUSH
32609: LD_STRING D15d-Pla-1
32611: PPUSH
32612: CALL_OW 94
// DialogueOff ;
32616: CALL_OW 7
// end ; if dec = 3 then
32620: LD_VAR 0 2
32624: PUSH
32625: LD_INT 3
32627: EQUAL
32628: IFFALSE 32682
// begin Say ( JMM , D15c-JMM-1 ) ;
32630: LD_EXP 40
32634: PPUSH
32635: LD_STRING D15c-JMM-1
32637: PPUSH
32638: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
32642: LD_EXP 68
32646: PPUSH
32647: LD_STRING D15c-Pla-1
32649: PPUSH
32650: CALL_OW 94
// DialogueOff ;
32654: CALL_OW 7
// wait ( 0 0$15 ) ;
32658: LD_INT 525
32660: PPUSH
32661: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
32665: LD_VAR 0 1
32669: PPUSH
32670: LD_INT 60
32672: PPUSH
32673: LD_INT 95
32675: PPUSH
32676: CALL_OW 116
// exit ;
32680: GO 33536
// end ; if dec = 4 then
32682: LD_VAR 0 2
32686: PUSH
32687: LD_INT 4
32689: EQUAL
32690: IFFALSE 32720
// begin Say ( JMM , D15d-JMM-1 ) ;
32692: LD_EXP 40
32696: PPUSH
32697: LD_STRING D15d-JMM-1
32699: PPUSH
32700: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
32704: LD_EXP 68
32708: PPUSH
32709: LD_STRING D15d-Pla-1
32711: PPUSH
32712: CALL_OW 94
// DialogueOff ;
32716: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32720: LD_EXP 66
32724: PPUSH
32725: CALL_OW 302
32729: IFFALSE 32746
32731: PUSH
32732: LD_EXP 66
32736: PPUSH
32737: CALL_OW 255
32741: PUSH
32742: LD_INT 1
32744: EQUAL
32745: AND
32746: IFFALSE 32779
32748: PUSH
32749: LD_INT 22
32751: PUSH
32752: LD_INT 1
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: PUSH
32759: LD_INT 34
32761: PUSH
32762: LD_INT 8
32764: PUSH
32765: EMPTY
32766: LIST
32767: LIST
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PPUSH
32773: CALL_OW 69
32777: NOT
32778: AND
32779: IFFALSE 33428
// begin SetSide ( Friend , 8 ) ;
32781: LD_EXP 66
32785: PPUSH
32786: LD_INT 8
32788: PPUSH
32789: CALL_OW 235
// if IsInUnit ( Friend ) then
32793: LD_EXP 66
32797: PPUSH
32798: CALL_OW 310
32802: IFFALSE 32813
// ComExitBuilding ( Friend ) ;
32804: LD_EXP 66
32808: PPUSH
32809: CALL_OW 122
// if IsDriver ( Friend ) then
32813: LD_EXP 66
32817: PPUSH
32818: CALL 106719 0 1
32822: IFFALSE 32833
// ComExitVehicle ( Friend ) ;
32824: LD_EXP 66
32828: PPUSH
32829: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
32833: LD_EXP 66
32837: PPUSH
32838: LD_INT 9
32840: PPUSH
32841: LD_INT 2
32843: PPUSH
32844: CALL_OW 171
// wait ( 0 0$05 ) ;
32848: LD_INT 175
32850: PPUSH
32851: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
32855: LD_EXP 66
32859: PPUSH
32860: CALL_OW 87
// DialogueOn ;
32864: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
32868: LD_EXP 40
32872: PPUSH
32873: LD_STRING D16-JMM-1
32875: PPUSH
32876: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
32880: LD_EXP 66
32884: PPUSH
32885: LD_STRING D16-Friend-1
32887: PPUSH
32888: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
32892: LD_EXP 40
32896: PPUSH
32897: LD_STRING D16-JMM-2
32899: PPUSH
32900: CALL_OW 88
// DialogueOff ;
32904: CALL_OW 7
// SetSide ( Friend , 1 ) ;
32908: LD_EXP 66
32912: PPUSH
32913: LD_INT 1
32915: PPUSH
32916: CALL_OW 235
// ComHold ( Friend ) ;
32920: LD_EXP 66
32924: PPUSH
32925: CALL_OW 140
// wait ( 0 0$20 ) ;
32929: LD_INT 700
32931: PPUSH
32932: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
32936: LD_EXP 66
32940: PPUSH
32941: LD_INT 9
32943: PPUSH
32944: LD_INT 2
32946: PPUSH
32947: CALL_OW 297
32951: PUSH
32952: LD_INT 30
32954: LESS
32955: IFFALSE 33024
// begin SetSide ( Friend , 8 ) ;
32957: LD_EXP 66
32961: PPUSH
32962: LD_INT 8
32964: PPUSH
32965: CALL_OW 235
// if IsInUnit ( Friend ) then
32969: LD_EXP 66
32973: PPUSH
32974: CALL_OW 310
32978: IFFALSE 32989
// ComExitBuilding ( Friend ) ;
32980: LD_EXP 66
32984: PPUSH
32985: CALL_OW 122
// if IsDriver ( Friend ) then
32989: LD_EXP 66
32993: PPUSH
32994: CALL 106719 0 1
32998: IFFALSE 33009
// ComExitVehicle ( Friend ) ;
33000: LD_EXP 66
33004: PPUSH
33005: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
33009: LD_EXP 66
33013: PPUSH
33014: LD_INT 9
33016: PPUSH
33017: LD_INT 2
33019: PPUSH
33020: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
33024: LD_INT 1050
33026: PPUSH
33027: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33031: LD_INT 22
33033: PUSH
33034: LD_INT 1
33036: PUSH
33037: EMPTY
33038: LIST
33039: LIST
33040: PUSH
33041: LD_INT 34
33043: PUSH
33044: LD_INT 8
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PPUSH
33055: CALL_OW 69
33059: NOT
33060: IFFALSE 33406
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
33062: LD_ADDR_VAR 0 3
33066: PUSH
33067: LD_INT 22
33069: PUSH
33070: LD_INT 1
33072: PUSH
33073: EMPTY
33074: LIST
33075: LIST
33076: PUSH
33077: LD_INT 26
33079: PUSH
33080: LD_INT 1
33082: PUSH
33083: EMPTY
33084: LIST
33085: LIST
33086: PUSH
33087: LD_INT 3
33089: PUSH
33090: LD_INT 25
33092: PUSH
33093: LD_INT 12
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 25
33102: PUSH
33103: LD_INT 16
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: LIST
33114: PUSH
33115: EMPTY
33116: LIST
33117: LIST
33118: LIST
33119: PPUSH
33120: CALL_OW 69
33124: PUSH
33125: LD_EXP 40
33129: PUSH
33130: LD_EXP 42
33134: PUSH
33135: LD_EXP 56
33139: PUSH
33140: LD_EXP 43
33144: PUSH
33145: LD_EXP 44
33149: PUSH
33150: LD_EXP 45
33154: PUSH
33155: LD_EXP 46
33159: PUSH
33160: LD_EXP 47
33164: PUSH
33165: LD_EXP 48
33169: PUSH
33170: LD_EXP 49
33174: PUSH
33175: LD_EXP 50
33179: PUSH
33180: LD_EXP 51
33184: PUSH
33185: LD_EXP 52
33189: PUSH
33190: LD_EXP 53
33194: PUSH
33195: LD_EXP 54
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: LIST
33204: LIST
33205: LIST
33206: LIST
33207: LIST
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: LIST
33216: DIFF
33217: ST_TO_ADDR
// DialogueOn ;
33218: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
33222: LD_EXP 68
33226: PPUSH
33227: LD_STRING D16a-Pla-1
33229: PPUSH
33230: CALL_OW 94
// if Stevens then
33234: LD_EXP 42
33238: IFFALSE 33254
// Say ( Stevens , D16a-Huck-1 ) else
33240: LD_EXP 42
33244: PPUSH
33245: LD_STRING D16a-Huck-1
33247: PPUSH
33248: CALL_OW 88
33252: GO 33296
// if Baker then
33254: LD_EXP 56
33258: IFFALSE 33274
// Say ( Baker , D16a-Huck-1 ) else
33260: LD_EXP 56
33264: PPUSH
33265: LD_STRING D16a-Huck-1
33267: PPUSH
33268: CALL_OW 88
33272: GO 33296
// if tmp then
33274: LD_VAR 0 3
33278: IFFALSE 33296
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
33280: LD_VAR 0 3
33284: PUSH
33285: LD_INT 1
33287: ARRAY
33288: PPUSH
33289: LD_STRING D16a-Sol1-1
33291: PPUSH
33292: CALL_OW 88
// if GetSide ( Friend ) = 8 then
33296: LD_EXP 66
33300: PPUSH
33301: CALL_OW 255
33305: PUSH
33306: LD_INT 8
33308: EQUAL
33309: IFFALSE 33325
// Say ( JMM , D16a-JMM-1 ) else
33311: LD_EXP 40
33315: PPUSH
33316: LD_STRING D16a-JMM-1
33318: PPUSH
33319: CALL_OW 88
33323: GO 33385
// begin Say ( JMM , D16a-JMM-1a ) ;
33325: LD_EXP 40
33329: PPUSH
33330: LD_STRING D16a-JMM-1a
33332: PPUSH
33333: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
33337: LD_EXP 66
33341: PPUSH
33342: LD_STRING D16a-Friend-1
33344: PPUSH
33345: CALL_OW 88
// ComExitBuilding ( Friend ) ;
33349: LD_EXP 66
33353: PPUSH
33354: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
33358: LD_EXP 66
33362: PPUSH
33363: LD_INT 191
33365: PPUSH
33366: LD_INT 103
33368: PPUSH
33369: CALL_OW 171
// SetSide ( Friend , 3 ) ;
33373: LD_EXP 66
33377: PPUSH
33378: LD_INT 3
33380: PPUSH
33381: CALL_OW 235
// end ; DialogueOff ;
33385: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
33389: LD_VAR 0 1
33393: PPUSH
33394: LD_INT 60
33396: PPUSH
33397: LD_INT 95
33399: PPUSH
33400: CALL_OW 116
// end else
33404: GO 33426
// begin DialogueOn ;
33406: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33410: LD_EXP 68
33414: PPUSH
33415: LD_STRING D16c-Pla-1
33417: PPUSH
33418: CALL_OW 94
// DialogueOff ;
33422: CALL_OW 7
// end ; end else
33426: GO 33536
// begin wait ( 3 3$00 ) ;
33428: LD_INT 6300
33430: PPUSH
33431: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) and not bombExploded then
33435: LD_INT 22
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: EMPTY
33442: LIST
33443: LIST
33444: PUSH
33445: LD_INT 34
33447: PUSH
33448: LD_INT 8
33450: PUSH
33451: EMPTY
33452: LIST
33453: LIST
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PPUSH
33459: CALL_OW 69
33463: NOT
33464: IFFALSE 33473
33466: PUSH
33467: LD_EXP 37
33471: NOT
33472: AND
33473: IFFALSE 33516
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
33475: LD_EXP 68
33479: PPUSH
33480: LD_STRING D16b-Pla-1
33482: PPUSH
33483: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
33487: LD_EXP 40
33491: PPUSH
33492: LD_STRING D16b-JMM-1
33494: PPUSH
33495: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
33499: LD_VAR 0 1
33503: PPUSH
33504: LD_INT 60
33506: PPUSH
33507: LD_INT 95
33509: PPUSH
33510: CALL_OW 116
// end else
33514: GO 33536
// begin DialogueOn ;
33516: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
33520: LD_EXP 68
33524: PPUSH
33525: LD_STRING D16c-Pla-1
33527: PPUSH
33528: CALL_OW 94
// DialogueOff ;
33532: CALL_OW 7
// end ; end ; end ;
33536: PPOPN 3
33538: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
33539: LD_INT 25
33541: PPUSH
33542: LD_INT 1
33544: PPUSH
33545: CALL_OW 321
33549: PUSH
33550: LD_INT 2
33552: EQUAL
33553: IFTRUE 33565
33555: PUSH
33556: LD_EXP 14
33560: PUSH
33561: LD_INT 126000
33563: GREATEREQUAL
33564: OR
33565: IFFALSE 33574
33567: PUSH
33568: LD_EXP 23
33572: NOT
33573: AND
33574: IFFALSE 33587
33576: PUSH
33577: LD_EXP 79
33581: PPUSH
33582: CALL_OW 302
33586: AND
33587: IFFALSE 33945
33589: GO 33591
33591: DISABLE
33592: LD_INT 0
33594: PPUSH
// begin missionStage := 11 ;
33595: LD_ADDR_EXP 15
33599: PUSH
33600: LD_INT 11
33602: ST_TO_ADDR
// DialogueOn ;
33603: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
33607: LD_EXP 79
33611: PPUSH
33612: LD_STRING D9-Roth-1
33614: PPUSH
33615: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
33619: LD_EXP 40
33623: PPUSH
33624: LD_STRING D9-JMM-1
33626: PPUSH
33627: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
33631: LD_EXP 79
33635: PPUSH
33636: LD_STRING D9-Roth-2
33638: PPUSH
33639: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
33643: LD_EXP 79
33647: PPUSH
33648: LD_STRING D9-Roth-2a
33650: PPUSH
33651: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
33655: LD_EXP 68
33659: PPUSH
33660: LD_STRING D9-Pla-2
33662: PPUSH
33663: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
33667: LD_EXP 79
33671: PPUSH
33672: LD_STRING D9-Roth-3
33674: PPUSH
33675: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
33679: LD_EXP 68
33683: PPUSH
33684: LD_STRING D9-Pla-3
33686: PPUSH
33687: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
33691: LD_EXP 79
33695: PPUSH
33696: LD_STRING D9-Roth-4
33698: PPUSH
33699: CALL_OW 94
// dec := Query ( Q9 ) ;
33703: LD_ADDR_VAR 0 1
33707: PUSH
33708: LD_STRING Q9
33710: PPUSH
33711: CALL_OW 97
33715: ST_TO_ADDR
// if dec = 1 then
33716: LD_VAR 0 1
33720: PUSH
33721: LD_INT 1
33723: EQUAL
33724: IFFALSE 33738
// SayRadio ( Roth , D9a-Roth-1 ) ;
33726: LD_EXP 79
33730: PPUSH
33731: LD_STRING D9a-Roth-1
33733: PPUSH
33734: CALL_OW 94
// if dec = 2 then
33738: LD_VAR 0 1
33742: PUSH
33743: LD_INT 2
33745: EQUAL
33746: IFFALSE 33772
// begin Say ( JMM , D9b-JMM-1 ) ;
33748: LD_EXP 40
33752: PPUSH
33753: LD_STRING D9b-JMM-1
33755: PPUSH
33756: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
33760: LD_EXP 79
33764: PPUSH
33765: LD_STRING D9b-Roth-1
33767: PPUSH
33768: CALL_OW 94
// end ; if dec = 3 then
33772: LD_VAR 0 1
33776: PUSH
33777: LD_INT 3
33779: EQUAL
33780: IFFALSE 33842
// begin Say ( JMM , D9c-JMM-1 ) ;
33782: LD_EXP 40
33786: PPUSH
33787: LD_STRING D9c-JMM-1
33789: PPUSH
33790: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
33794: LD_EXP 79
33798: PPUSH
33799: LD_STRING D9c-Roth-1
33801: PPUSH
33802: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
33806: LD_EXP 40
33810: PPUSH
33811: LD_STRING D9c-JMM-2
33813: PPUSH
33814: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
33818: LD_EXP 79
33822: PPUSH
33823: LD_STRING D9c-Roth-2
33825: PPUSH
33826: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
33830: LD_EXP 40
33834: PPUSH
33835: LD_STRING D9c-JMM-3
33837: PPUSH
33838: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
33842: LD_EXP 79
33846: PPUSH
33847: LD_STRING D9c-Roth-3
33849: PPUSH
33850: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
33854: LD_EXP 79
33858: PPUSH
33859: LD_STRING D9cont-Roth-1
33861: PPUSH
33862: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
33866: LD_EXP 40
33870: PPUSH
33871: LD_STRING D9cont-JMM-1
33873: PPUSH
33874: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
33878: LD_EXP 79
33882: PPUSH
33883: LD_STRING D9cont-Roth-2
33885: PPUSH
33886: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
33890: LD_EXP 40
33894: PPUSH
33895: LD_STRING D9cont-JMM-2
33897: PPUSH
33898: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
33902: LD_EXP 79
33906: PPUSH
33907: LD_STRING D9cont-Roth-3
33909: PPUSH
33910: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
33914: LD_EXP 40
33918: PPUSH
33919: LD_STRING D9cont-JMM-3
33921: PPUSH
33922: CALL_OW 88
// DialogueOff ;
33926: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
33930: LD_STRING M3
33932: PPUSH
33933: CALL_OW 337
// allianceActive := true ;
33937: LD_ADDR_EXP 31
33941: PUSH
33942: LD_INT 1
33944: ST_TO_ADDR
// end ;
33945: PPOPN 1
33947: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
33948: LD_INT 1
33950: PPUSH
33951: LD_INT 126
33953: PPUSH
33954: CALL_OW 292
33958: IFFALSE 33971
33960: PUSH
33961: LD_EXP 68
33965: PPUSH
33966: CALL_OW 310
33970: AND
33971: IFFALSE 34124
33973: GO 33975
33975: DISABLE
33976: LD_INT 0
33978: PPUSH
// begin ComExitBuilding ( Platonov ) ;
33979: LD_EXP 68
33983: PPUSH
33984: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
33988: LD_ADDR_VAR 0 1
33992: PUSH
33993: LD_INT 4
33995: PPUSH
33996: LD_INT 22
33998: PUSH
33999: LD_INT 1
34001: PUSH
34002: EMPTY
34003: LIST
34004: LIST
34005: PPUSH
34006: CALL_OW 70
34010: PPUSH
34011: LD_EXP 68
34015: PPUSH
34016: CALL_OW 74
34020: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
34021: LD_EXP 68
34025: PPUSH
34026: LD_VAR 0 1
34030: PUSH
34031: LD_INT 1
34033: ARRAY
34034: PPUSH
34035: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
34039: LD_EXP 68
34043: PPUSH
34044: LD_STRING D18-Pla-1
34046: PPUSH
34047: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
34051: LD_INT 22
34053: PUSH
34054: LD_INT 3
34056: PUSH
34057: EMPTY
34058: LIST
34059: LIST
34060: PUSH
34061: LD_INT 34
34063: PUSH
34064: LD_INT 48
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PPUSH
34075: CALL_OW 69
34079: IFFALSE 34124
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
34081: LD_INT 22
34083: PUSH
34084: LD_INT 3
34086: PUSH
34087: EMPTY
34088: LIST
34089: LIST
34090: PUSH
34091: LD_INT 34
34093: PUSH
34094: LD_INT 48
34096: PUSH
34097: EMPTY
34098: LIST
34099: LIST
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PPUSH
34105: CALL_OW 69
34109: PUSH
34110: LD_INT 1
34112: ARRAY
34113: PPUSH
34114: LD_INT 111
34116: PPUSH
34117: LD_INT 97
34119: PPUSH
34120: CALL_OW 116
// end ;
34124: PPOPN 1
34126: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 14 , 13 , 12 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
34127: LD_EXP 68
34131: PPUSH
34132: CALL_OW 301
34136: IFFALSE 34149
34138: PUSH
34139: LD_EXP 71
34143: PPUSH
34144: CALL_OW 301
34148: AND
34149: IFFALSE 34213
34151: PUSH
34152: LD_INT 22
34154: PUSH
34155: LD_INT 3
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 21
34164: PUSH
34165: LD_INT 1
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: LD_INT 50
34174: PUSH
34175: EMPTY
34176: LIST
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: LIST
34182: PPUSH
34183: CALL_OW 69
34187: PUSH
34188: LD_INT 14
34190: PUSH
34191: LD_INT 13
34193: PUSH
34194: LD_INT 12
34196: PUSH
34197: LD_INT 10
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: LIST
34204: LIST
34205: PUSH
34206: LD_OWVAR 67
34210: ARRAY
34211: LESS
34212: AND
34213: IFFALSE 35014
34215: GO 34217
34217: DISABLE
34218: LD_INT 0
34220: PPUSH
34221: PPUSH
34222: PPUSH
34223: PPUSH
// begin MC_Kill ( 2 ) ;
34224: LD_INT 2
34226: PPUSH
34227: CALL 40134 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
34231: LD_INT 1
34233: PPUSH
34234: LD_INT 3
34236: PPUSH
34237: LD_INT 1
34239: PPUSH
34240: LD_INT 1
34242: PPUSH
34243: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
34247: LD_ADDR_VAR 0 2
34251: PUSH
34252: LD_INT 22
34254: PUSH
34255: LD_INT 3
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: LD_INT 21
34264: PUSH
34265: LD_INT 1
34267: PUSH
34268: EMPTY
34269: LIST
34270: LIST
34271: PUSH
34272: LD_INT 50
34274: PUSH
34275: EMPTY
34276: LIST
34277: PUSH
34278: LD_INT 26
34280: PUSH
34281: LD_INT 1
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: LIST
34292: LIST
34293: PPUSH
34294: CALL_OW 69
34298: ST_TO_ADDR
// if not tmp then
34299: LD_VAR 0 2
34303: NOT
34304: IFFALSE 34360
// begin uc_side = 3 ;
34306: LD_ADDR_OWVAR 20
34310: PUSH
34311: LD_INT 3
34313: ST_TO_ADDR
// uc_nation = 3 ;
34314: LD_ADDR_OWVAR 21
34318: PUSH
34319: LD_INT 3
34321: ST_TO_ADDR
// hc_name =  ;
34322: LD_ADDR_OWVAR 26
34326: PUSH
34327: LD_STRING 
34329: ST_TO_ADDR
// hc_gallery =  ;
34330: LD_ADDR_OWVAR 33
34334: PUSH
34335: LD_STRING 
34337: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
34338: LD_INT 1
34340: PPUSH
34341: LD_INT 10
34343: PPUSH
34344: CALL_OW 381
// tmp = CreateHuman ;
34348: LD_ADDR_VAR 0 2
34352: PUSH
34353: CALL_OW 44
34357: ST_TO_ADDR
// end else
34358: GO 34374
// tmp := tmp [ 1 ] ;
34360: LD_ADDR_VAR 0 2
34364: PUSH
34365: LD_VAR 0 2
34369: PUSH
34370: LD_INT 1
34372: ARRAY
34373: ST_TO_ADDR
// DialogueOn ;
34374: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
34378: LD_VAR 0 2
34382: PPUSH
34383: LD_STRING DSurrenderRussians-RSol1-1a
34385: PPUSH
34386: CALL_OW 94
// DialogueOff ;
34390: CALL_OW 7
// russianDestroyed := true ;
34394: LD_ADDR_EXP 21
34398: PUSH
34399: LD_INT 1
34401: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
34402: LD_ADDR_VAR 0 1
34406: PUSH
34407: LD_INT 22
34409: PUSH
34410: LD_INT 6
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PPUSH
34417: CALL_OW 69
34421: PUSH
34422: FOR_IN
34423: IFFALSE 34436
// KillUnit ( i ) ;
34425: LD_VAR 0 1
34429: PPUSH
34430: CALL_OW 66
34434: GO 34422
34436: POP
34437: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
34438: LD_INT 22
34440: PUSH
34441: LD_INT 3
34443: PUSH
34444: EMPTY
34445: LIST
34446: LIST
34447: PUSH
34448: LD_INT 21
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: EMPTY
34455: LIST
34456: LIST
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PPUSH
34462: CALL_OW 69
34466: PPUSH
34467: CALL_OW 122
// wait ( 0 0$1 ) ;
34471: LD_INT 35
34473: PPUSH
34474: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
34478: LD_INT 22
34480: PUSH
34481: LD_INT 3
34483: PUSH
34484: EMPTY
34485: LIST
34486: LIST
34487: PUSH
34488: LD_INT 21
34490: PUSH
34491: LD_INT 1
34493: PUSH
34494: EMPTY
34495: LIST
34496: LIST
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PPUSH
34502: CALL_OW 69
34506: PPUSH
34507: LD_INT 25
34509: PPUSH
34510: CALL_OW 173
// wait ( 0 0$35 ) ;
34514: LD_INT 1225
34516: PPUSH
34517: CALL_OW 67
// PrepareOmarInvasion ;
34521: CALL 16428 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
34525: LD_ADDR_VAR 0 2
34529: PUSH
34530: LD_EXP 97
34534: PPUSH
34535: CALL_OW 250
34539: PUSH
34540: LD_EXP 97
34544: PPUSH
34545: CALL_OW 251
34549: PUSH
34550: EMPTY
34551: LIST
34552: LIST
34553: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
34554: LD_VAR 0 2
34558: PUSH
34559: LD_INT 1
34561: ARRAY
34562: PPUSH
34563: LD_VAR 0 2
34567: PUSH
34568: LD_INT 2
34570: ARRAY
34571: PPUSH
34572: LD_INT 1
34574: PPUSH
34575: LD_INT 8
34577: NEG
34578: PPUSH
34579: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
34583: LD_EXP 97
34587: PPUSH
34588: CALL_OW 87
// DialogueOn ;
34592: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
34596: LD_EXP 40
34600: PPUSH
34601: LD_STRING D19-JMM-1
34603: PPUSH
34604: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
34608: LD_ADDR_VAR 0 3
34612: PUSH
34613: LD_INT 22
34615: PUSH
34616: LD_INT 1
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 26
34625: PUSH
34626: LD_INT 1
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 2
34635: PUSH
34636: LD_INT 25
34638: PUSH
34639: LD_INT 1
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 25
34648: PUSH
34649: LD_INT 2
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 25
34658: PUSH
34659: LD_INT 3
34661: PUSH
34662: EMPTY
34663: LIST
34664: LIST
34665: PUSH
34666: LD_INT 25
34668: PUSH
34669: LD_INT 4
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: LD_INT 25
34678: PUSH
34679: LD_INT 5
34681: PUSH
34682: EMPTY
34683: LIST
34684: LIST
34685: PUSH
34686: LD_INT 25
34688: PUSH
34689: LD_INT 8
34691: PUSH
34692: EMPTY
34693: LIST
34694: LIST
34695: PUSH
34696: EMPTY
34697: LIST
34698: LIST
34699: LIST
34700: LIST
34701: LIST
34702: LIST
34703: LIST
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: LIST
34709: PPUSH
34710: CALL_OW 69
34714: PUSH
34715: LD_EXP 40
34719: PUSH
34720: LD_EXP 41
34724: PUSH
34725: LD_EXP 64
34729: PUSH
34730: LD_EXP 42
34734: PUSH
34735: LD_EXP 43
34739: PUSH
34740: LD_EXP 44
34744: PUSH
34745: LD_EXP 45
34749: PUSH
34750: LD_EXP 46
34754: PUSH
34755: LD_EXP 47
34759: PUSH
34760: LD_EXP 48
34764: PUSH
34765: LD_EXP 49
34769: PUSH
34770: LD_EXP 50
34774: PUSH
34775: LD_EXP 51
34779: PUSH
34780: LD_EXP 52
34784: PUSH
34785: LD_EXP 53
34789: PUSH
34790: LD_EXP 54
34794: PUSH
34795: LD_EXP 55
34799: PUSH
34800: LD_EXP 56
34804: PUSH
34805: EMPTY
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: DIFF
34825: ST_TO_ADDR
// if tmp2 then
34826: LD_VAR 0 3
34830: IFFALSE 34848
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
34832: LD_VAR 0 3
34836: PUSH
34837: LD_INT 1
34839: ARRAY
34840: PPUSH
34841: LD_STRING D19-Sol1-1
34843: PPUSH
34844: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
34848: LD_EXP 40
34852: PPUSH
34853: LD_STRING D19-JMM-2
34855: PPUSH
34856: CALL_OW 88
// DialogueOff ;
34860: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
34864: LD_VAR 0 2
34868: PUSH
34869: LD_INT 1
34871: ARRAY
34872: PPUSH
34873: LD_VAR 0 2
34877: PUSH
34878: LD_INT 2
34880: ARRAY
34881: PPUSH
34882: LD_INT 1
34884: PPUSH
34885: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
34889: LD_STRING M5
34891: PPUSH
34892: CALL_OW 337
// omarOnMotherLode := false ;
34896: LD_ADDR_VAR 0 4
34900: PUSH
34901: LD_INT 0
34903: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
34904: LD_INT 35
34906: PPUSH
34907: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
34911: LD_EXP 97
34915: PPUSH
34916: LD_INT 215
34918: PPUSH
34919: LD_INT 100
34921: PPUSH
34922: CALL_OW 297
34926: PUSH
34927: LD_INT 10
34929: LESS
34930: IFFALSE 34939
34932: PUSH
34933: LD_VAR 0 4
34937: NOT
34938: AND
34939: IFFALSE 34973
// begin omarOnMotherLode := true ;
34941: LD_ADDR_VAR 0 4
34945: PUSH
34946: LD_INT 1
34948: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
34949: LD_EXP 40
34953: PPUSH
34954: LD_STRING D19b-JMM-1
34956: PPUSH
34957: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
34961: LD_EXP 97
34965: PPUSH
34966: LD_STRING DOmarContam-Omar-1
34968: PPUSH
34969: CALL_OW 88
// end ; until IsDead ( Omar ) ;
34973: LD_EXP 97
34977: PPUSH
34978: CALL_OW 301
34982: IFFALSE 34904
// Say ( JMM , D19a-JMM-1 ) ;
34984: LD_EXP 40
34988: PPUSH
34989: LD_STRING D19a-JMM-1
34991: PPUSH
34992: CALL_OW 88
// if Heike then
34996: LD_EXP 98
35000: IFFALSE 35014
// Say ( Heike , D19a-Hke-1 ) ;
35002: LD_EXP 98
35006: PPUSH
35007: LD_STRING D19a-Hke-1
35009: PPUSH
35010: CALL_OW 88
// end ;
35014: PPOPN 4
35016: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
35017: LD_INT 22
35019: PUSH
35020: LD_INT 3
35022: PUSH
35023: EMPTY
35024: LIST
35025: LIST
35026: PUSH
35027: LD_INT 21
35029: PUSH
35030: LD_INT 1
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: EMPTY
35038: LIST
35039: LIST
35040: PPUSH
35041: CALL_OW 69
35045: IFFALSE 35053
35047: PUSH
35048: LD_EXP 21
35052: AND
35053: IFFALSE 35121
35055: GO 35057
35057: DISABLE
35058: LD_INT 0
35060: PPUSH
35061: PPUSH
// begin enable ;
35062: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
35063: LD_ADDR_VAR 0 2
35067: PUSH
35068: LD_INT 25
35070: PPUSH
35071: LD_INT 22
35073: PUSH
35074: LD_INT 3
35076: PUSH
35077: EMPTY
35078: LIST
35079: LIST
35080: PPUSH
35081: CALL_OW 70
35085: ST_TO_ADDR
// if not tmp then
35086: LD_VAR 0 2
35090: NOT
35091: IFFALSE 35095
// exit ;
35093: GO 35121
// for i in tmp do
35095: LD_ADDR_VAR 0 1
35099: PUSH
35100: LD_VAR 0 2
35104: PUSH
35105: FOR_IN
35106: IFFALSE 35119
// RemoveUnit ( i ) ;
35108: LD_VAR 0 1
35112: PPUSH
35113: CALL_OW 64
35117: GO 35105
35119: POP
35120: POP
// end ;
35121: PPOPN 2
35123: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
35124: LD_INT 22
35126: PUSH
35127: LD_INT 7
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 21
35136: PUSH
35137: LD_INT 1
35139: PUSH
35140: EMPTY
35141: LIST
35142: LIST
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PPUSH
35148: CALL_OW 69
35152: PUSH
35153: LD_INT 6
35155: LESS
35156: IFFALSE 35624
35158: GO 35160
35160: DISABLE
35161: LD_INT 0
35163: PPUSH
35164: PPUSH
// begin MC_Kill ( 1 ) ;
35165: LD_INT 1
35167: PPUSH
35168: CALL 40134 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
35172: LD_INT 7
35174: PPUSH
35175: LD_INT 1
35177: PPUSH
35178: LD_INT 1
35180: PPUSH
35181: LD_INT 1
35183: PPUSH
35184: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
35188: LD_ADDR_VAR 0 1
35192: PUSH
35193: LD_INT 22
35195: PUSH
35196: LD_INT 7
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: LD_INT 26
35205: PUSH
35206: LD_INT 1
35208: PUSH
35209: EMPTY
35210: LIST
35211: LIST
35212: PUSH
35213: EMPTY
35214: LIST
35215: LIST
35216: PPUSH
35217: CALL_OW 69
35221: PUSH
35222: LD_EXP 79
35226: DIFF
35227: ST_TO_ADDR
// if tmp then
35228: LD_VAR 0 1
35232: IFFALSE 35250
// tmp := tmp [ 1 ] else
35234: LD_ADDR_VAR 0 1
35238: PUSH
35239: LD_VAR 0 1
35243: PUSH
35244: LD_INT 1
35246: ARRAY
35247: ST_TO_ADDR
35248: GO 35286
// begin uc_side := 7 ;
35250: LD_ADDR_OWVAR 20
35254: PUSH
35255: LD_INT 7
35257: ST_TO_ADDR
// uc_nation := 1 ;
35258: LD_ADDR_OWVAR 21
35262: PUSH
35263: LD_INT 1
35265: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
35266: LD_INT 1
35268: PPUSH
35269: LD_INT 8
35271: PPUSH
35272: CALL_OW 384
// tmp := CreateHuman ;
35276: LD_ADDR_VAR 0 1
35280: PUSH
35281: CALL_OW 44
35285: ST_TO_ADDR
// end ; DialogueOn ;
35286: CALL_OW 6
// if IsOK ( Roth ) then
35290: LD_EXP 79
35294: PPUSH
35295: CALL_OW 302
35299: IFFALSE 35313
// Say ( JMM , DAb-JMM-1 ) ;
35301: LD_EXP 40
35305: PPUSH
35306: LD_STRING DAb-JMM-1
35308: PPUSH
35309: CALL_OW 88
// if IsOK ( Roth ) then
35313: LD_EXP 79
35317: PPUSH
35318: CALL_OW 302
35322: IFFALSE 35346
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
35324: LD_EXP 79
35328: PPUSH
35329: LD_STRING DSurrenderAlliance-Roth-1
35331: PPUSH
35332: CALL_OW 88
// RothCaptured := true ;
35336: LD_ADDR_EXP 33
35340: PUSH
35341: LD_INT 1
35343: ST_TO_ADDR
// end else
35344: GO 35358
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
35346: LD_VAR 0 1
35350: PPUSH
35351: LD_STRING DSurrenderAlliance-Sci1-1
35353: PPUSH
35354: CALL_OW 88
// DialogueOff ;
35358: CALL_OW 7
// allianceDestroyed := true ;
35362: LD_ADDR_EXP 23
35366: PUSH
35367: LD_INT 1
35369: ST_TO_ADDR
// if capturedUnit = 0 then
35370: LD_EXP 34
35374: PUSH
35375: LD_INT 0
35377: EQUAL
35378: IFFALSE 35387
// SetAchievement ( ACH_ALLIANCE ) ;
35380: LD_STRING ACH_ALLIANCE
35382: PPUSH
35383: CALL_OW 543
// if trueAmericans then
35387: LD_EXP 35
35391: IFFALSE 35467
// begin if trueAmericans = 1 then
35393: LD_EXP 35
35397: PUSH
35398: LD_INT 1
35400: EQUAL
35401: IFFALSE 35417
// Say ( JMM , DAb-JMM-1a ) else
35403: LD_EXP 40
35407: PPUSH
35408: LD_STRING DAb-JMM-1a
35410: PPUSH
35411: CALL_OW 88
35415: GO 35429
// Say ( JMM , DAb-JMM-1b ) ;
35417: LD_EXP 40
35421: PPUSH
35422: LD_STRING DAb-JMM-1b
35424: PPUSH
35425: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
35429: LD_EXP 35
35433: PPUSH
35434: CALL_OW 87
// for i in trueAmericans do
35438: LD_ADDR_VAR 0 2
35442: PUSH
35443: LD_EXP 35
35447: PUSH
35448: FOR_IN
35449: IFFALSE 35465
// SetSide ( i , 1 ) ;
35451: LD_VAR 0 2
35455: PPUSH
35456: LD_INT 1
35458: PPUSH
35459: CALL_OW 235
35463: GO 35448
35465: POP
35466: POP
// end ; repeat wait ( 0 0$1 ) ;
35467: LD_INT 35
35469: PPUSH
35470: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
35474: LD_ADDR_VAR 0 2
35478: PUSH
35479: LD_INT 22
35481: PUSH
35482: LD_INT 7
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 21
35491: PUSH
35492: LD_INT 1
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: EMPTY
35500: LIST
35501: LIST
35502: PPUSH
35503: CALL_OW 69
35507: PUSH
35508: FOR_IN
35509: IFFALSE 35591
// begin if IsInUnit ( i ) then
35511: LD_VAR 0 2
35515: PPUSH
35516: CALL_OW 310
35520: IFFALSE 35531
// ComExitBuilding ( i ) ;
35522: LD_VAR 0 2
35526: PPUSH
35527: CALL_OW 122
// if IsDriver ( i ) then
35531: LD_VAR 0 2
35535: PPUSH
35536: CALL 106719 0 1
35540: IFFALSE 35551
// ComExitVehicle ( i ) ;
35542: LD_VAR 0 2
35546: PPUSH
35547: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
35551: LD_VAR 0 2
35555: PPUSH
35556: LD_INT 26
35558: PPUSH
35559: CALL_OW 308
35563: NOT
35564: IFFALSE 35580
// AddComMoveToArea ( i , allianceEscapeArea ) else
35566: LD_VAR 0 2
35570: PPUSH
35571: LD_INT 26
35573: PPUSH
35574: CALL_OW 173
35578: GO 35589
// RemoveUnit ( i ) ;
35580: LD_VAR 0 2
35584: PPUSH
35585: CALL_OW 64
// end ;
35589: GO 35508
35591: POP
35592: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
35593: LD_INT 22
35595: PUSH
35596: LD_INT 7
35598: PUSH
35599: EMPTY
35600: LIST
35601: LIST
35602: PUSH
35603: LD_INT 21
35605: PUSH
35606: LD_INT 1
35608: PUSH
35609: EMPTY
35610: LIST
35611: LIST
35612: PUSH
35613: EMPTY
35614: LIST
35615: LIST
35616: PPUSH
35617: CALL_OW 69
35621: NOT
35622: IFFALSE 35467
// end ;
35624: PPOPN 2
35626: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
35627: LD_INT 0
35629: PPUSH
35630: PPUSH
// if not unit then
35631: LD_VAR 0 1
35635: NOT
35636: IFFALSE 35640
// exit ;
35638: GO 37156
// DoNotAttack ( 7 , unit ) ;
35640: LD_INT 7
35642: PPUSH
35643: LD_VAR 0 1
35647: PPUSH
35648: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
35652: LD_VAR 0 1
35656: PPUSH
35657: LD_INT 260
35659: PPUSH
35660: LD_INT 235
35662: PPUSH
35663: LD_INT 3
35665: PPUSH
35666: LD_INT 1
35668: PPUSH
35669: CALL_OW 483
// SetSide ( unit , 4 ) ;
35673: LD_VAR 0 1
35677: PPUSH
35678: LD_INT 4
35680: PPUSH
35681: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
35685: LD_ADDR_EXP 34
35689: PUSH
35690: LD_EXP 34
35694: PUSH
35695: LD_INT 1
35697: PLUS
35698: ST_TO_ADDR
// wait ( 0 0$2 ) ;
35699: LD_INT 70
35701: PPUSH
35702: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
35706: LD_INT 260
35708: PPUSH
35709: LD_INT 235
35711: PPUSH
35712: LD_INT 1
35714: PPUSH
35715: LD_INT 8
35717: NEG
35718: PPUSH
35719: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
35723: LD_VAR 0 1
35727: PPUSH
35728: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
35732: LD_VAR 0 1
35736: PPUSH
35737: LD_EXP 79
35741: PPUSH
35742: CALL_OW 119
// DialogueOn ;
35746: CALL_OW 6
// case unit of JMM :
35750: LD_VAR 0 1
35754: PUSH
35755: LD_EXP 40
35759: DOUBLE
35760: EQUAL
35761: IFTRUE 35765
35763: GO 35780
35765: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
35766: LD_EXP 40
35770: PPUSH
35771: LD_STRING DA1-JMM-1
35773: PPUSH
35774: CALL_OW 91
35778: GO 36222
35780: LD_EXP 41
35784: DOUBLE
35785: EQUAL
35786: IFTRUE 35790
35788: GO 35805
35790: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
35791: LD_EXP 41
35795: PPUSH
35796: LD_STRING DA1-Joan-1
35798: PPUSH
35799: CALL_OW 91
35803: GO 36222
35805: LD_EXP 43
35809: DOUBLE
35810: EQUAL
35811: IFTRUE 35815
35813: GO 35830
35815: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
35816: LD_EXP 43
35820: PPUSH
35821: LD_STRING DA1-Lisa-1
35823: PPUSH
35824: CALL_OW 91
35828: GO 36222
35830: LD_EXP 44
35834: DOUBLE
35835: EQUAL
35836: IFTRUE 35840
35838: GO 35855
35840: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
35841: LD_EXP 44
35845: PPUSH
35846: LD_STRING DA1-Don-1
35848: PPUSH
35849: CALL_OW 91
35853: GO 36222
35855: LD_EXP 51
35859: DOUBLE
35860: EQUAL
35861: IFTRUE 35865
35863: GO 35880
35865: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
35866: LD_EXP 51
35870: PPUSH
35871: LD_STRING DA1-Corn-1
35873: PPUSH
35874: CALL_OW 91
35878: GO 36222
35880: LD_EXP 47
35884: DOUBLE
35885: EQUAL
35886: IFTRUE 35890
35888: GO 35905
35890: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
35891: LD_EXP 47
35895: PPUSH
35896: LD_STRING DA1-Den-1
35898: PPUSH
35899: CALL_OW 91
35903: GO 36222
35905: LD_EXP 45
35909: DOUBLE
35910: EQUAL
35911: IFTRUE 35915
35913: GO 35930
35915: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
35916: LD_EXP 45
35920: PPUSH
35921: LD_STRING DA1-Bobby-1
35923: PPUSH
35924: CALL_OW 91
35928: GO 36222
35930: LD_EXP 49
35934: DOUBLE
35935: EQUAL
35936: IFTRUE 35940
35938: GO 35955
35940: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
35941: LD_EXP 49
35945: PPUSH
35946: LD_STRING DA1-Glad-1
35948: PPUSH
35949: CALL_OW 91
35953: GO 36222
35955: LD_EXP 46
35959: DOUBLE
35960: EQUAL
35961: IFTRUE 35965
35963: GO 35980
35965: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
35966: LD_EXP 46
35970: PPUSH
35971: LD_STRING DA1-Cyrus-1
35973: PPUSH
35974: CALL_OW 91
35978: GO 36222
35980: LD_EXP 42
35984: DOUBLE
35985: EQUAL
35986: IFTRUE 35990
35988: GO 36005
35990: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
35991: LD_EXP 42
35995: PPUSH
35996: LD_STRING DA1-Huck-1
35998: PPUSH
35999: CALL_OW 91
36003: GO 36222
36005: LD_EXP 56
36009: DOUBLE
36010: EQUAL
36011: IFTRUE 36015
36013: GO 36030
36015: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
36016: LD_EXP 56
36020: PPUSH
36021: LD_STRING DA1-Huck-1
36023: PPUSH
36024: CALL_OW 91
36028: GO 36222
36030: LD_EXP 48
36034: DOUBLE
36035: EQUAL
36036: IFTRUE 36040
36038: GO 36055
36040: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
36041: LD_EXP 48
36045: PPUSH
36046: LD_STRING DA1-Brown-1
36048: PPUSH
36049: CALL_OW 91
36053: GO 36222
36055: LD_EXP 52
36059: DOUBLE
36060: EQUAL
36061: IFTRUE 36065
36063: GO 36080
36065: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
36066: LD_EXP 52
36070: PPUSH
36071: LD_STRING DA1-Gary-1
36073: PPUSH
36074: CALL_OW 91
36078: GO 36222
36080: LD_EXP 55
36084: DOUBLE
36085: EQUAL
36086: IFTRUE 36090
36088: GO 36105
36090: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
36091: LD_EXP 55
36095: PPUSH
36096: LD_STRING DA1-Con-1
36098: PPUSH
36099: CALL_OW 91
36103: GO 36222
36105: LD_EXP 64
36109: DOUBLE
36110: EQUAL
36111: IFTRUE 36115
36113: GO 36130
36115: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
36116: LD_EXP 64
36120: PPUSH
36121: LD_STRING DA1-Kurt-1
36123: PPUSH
36124: CALL_OW 91
36128: GO 36222
36130: LD_EXP 54
36134: DOUBLE
36135: EQUAL
36136: IFTRUE 36140
36138: GO 36155
36140: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
36141: LD_EXP 54
36145: PPUSH
36146: LD_STRING DA1-Yam-1
36148: PPUSH
36149: CALL_OW 91
36153: GO 36222
36155: LD_EXP 53
36159: DOUBLE
36160: EQUAL
36161: IFTRUE 36165
36163: GO 36180
36165: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
36166: LD_EXP 53
36170: PPUSH
36171: LD_STRING DA1-Frank-1
36173: PPUSH
36174: CALL_OW 91
36178: GO 36222
36180: POP
// begin if GetSex ( unit ) = sex_male then
36181: LD_VAR 0 1
36185: PPUSH
36186: CALL_OW 258
36190: PUSH
36191: LD_INT 1
36193: EQUAL
36194: IFFALSE 36210
// ForceSay ( unit , DA1-Sol1-1 ) else
36196: LD_VAR 0 1
36200: PPUSH
36201: LD_STRING DA1-Sol1-1
36203: PPUSH
36204: CALL_OW 91
36208: GO 36222
// ForceSay ( unit , DA1-FSol1-1 ) ;
36210: LD_VAR 0 1
36214: PPUSH
36215: LD_STRING DA1-FSol1-1
36217: PPUSH
36218: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
36222: LD_EXP 79
36226: PPUSH
36227: LD_STRING DA-Roth-1
36229: PPUSH
36230: CALL_OW 88
// if capturedUnit = 1 then
36234: LD_EXP 34
36238: PUSH
36239: LD_INT 1
36241: EQUAL
36242: IFFALSE 36270
// begin Say ( Simms , DA-Sim-1 ) ;
36244: LD_EXP 80
36248: PPUSH
36249: LD_STRING DA-Sim-1
36251: PPUSH
36252: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
36256: LD_EXP 79
36260: PPUSH
36261: LD_STRING DA-Roth-2
36263: PPUSH
36264: CALL_OW 88
// end else
36268: GO 36282
// Say ( Simms , DA-Sim-2 ) ;
36270: LD_EXP 80
36274: PPUSH
36275: LD_STRING DA-Sim-2
36277: PPUSH
36278: CALL_OW 88
// case unit of JMM :
36282: LD_VAR 0 1
36286: PUSH
36287: LD_EXP 40
36291: DOUBLE
36292: EQUAL
36293: IFTRUE 36297
36295: GO 36312
36297: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
36298: LD_EXP 40
36302: PPUSH
36303: LD_STRING DA1-JMM-1a
36305: PPUSH
36306: CALL_OW 91
36310: GO 36829
36312: LD_EXP 41
36316: DOUBLE
36317: EQUAL
36318: IFTRUE 36322
36320: GO 36337
36322: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
36323: LD_EXP 41
36327: PPUSH
36328: LD_STRING DA1-Joan-1a
36330: PPUSH
36331: CALL_OW 91
36335: GO 36829
36337: LD_EXP 43
36341: DOUBLE
36342: EQUAL
36343: IFTRUE 36347
36345: GO 36362
36347: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
36348: LD_EXP 43
36352: PPUSH
36353: LD_STRING DA1-Lisa-1a
36355: PPUSH
36356: CALL_OW 91
36360: GO 36829
36362: LD_EXP 44
36366: DOUBLE
36367: EQUAL
36368: IFTRUE 36372
36370: GO 36387
36372: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
36373: LD_EXP 44
36377: PPUSH
36378: LD_STRING DA1-Don-1a
36380: PPUSH
36381: CALL_OW 91
36385: GO 36829
36387: LD_EXP 51
36391: DOUBLE
36392: EQUAL
36393: IFTRUE 36397
36395: GO 36412
36397: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
36398: LD_EXP 51
36402: PPUSH
36403: LD_STRING DA1-Corn-1a
36405: PPUSH
36406: CALL_OW 91
36410: GO 36829
36412: LD_EXP 47
36416: DOUBLE
36417: EQUAL
36418: IFTRUE 36422
36420: GO 36437
36422: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
36423: LD_EXP 47
36427: PPUSH
36428: LD_STRING DA1-Den-1a
36430: PPUSH
36431: CALL_OW 91
36435: GO 36829
36437: LD_EXP 45
36441: DOUBLE
36442: EQUAL
36443: IFTRUE 36447
36445: GO 36462
36447: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
36448: LD_EXP 45
36452: PPUSH
36453: LD_STRING DA1-Bobby-1a
36455: PPUSH
36456: CALL_OW 91
36460: GO 36829
36462: LD_EXP 49
36466: DOUBLE
36467: EQUAL
36468: IFTRUE 36472
36470: GO 36487
36472: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
36473: LD_EXP 49
36477: PPUSH
36478: LD_STRING DA1-Glad-1a
36480: PPUSH
36481: CALL_OW 91
36485: GO 36829
36487: LD_EXP 46
36491: DOUBLE
36492: EQUAL
36493: IFTRUE 36497
36495: GO 36512
36497: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
36498: LD_EXP 46
36502: PPUSH
36503: LD_STRING DA1-Cyrus-1a
36505: PPUSH
36506: CALL_OW 91
36510: GO 36829
36512: LD_EXP 42
36516: DOUBLE
36517: EQUAL
36518: IFTRUE 36522
36520: GO 36537
36522: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
36523: LD_EXP 42
36527: PPUSH
36528: LD_STRING DA1-Huck-1a
36530: PPUSH
36531: CALL_OW 91
36535: GO 36829
36537: LD_EXP 56
36541: DOUBLE
36542: EQUAL
36543: IFTRUE 36547
36545: GO 36562
36547: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
36548: LD_EXP 56
36552: PPUSH
36553: LD_STRING DA1-Huck-1a
36555: PPUSH
36556: CALL_OW 91
36560: GO 36829
36562: LD_EXP 48
36566: DOUBLE
36567: EQUAL
36568: IFTRUE 36572
36570: GO 36587
36572: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
36573: LD_EXP 48
36577: PPUSH
36578: LD_STRING DA1-Brown-1a
36580: PPUSH
36581: CALL_OW 91
36585: GO 36829
36587: LD_EXP 52
36591: DOUBLE
36592: EQUAL
36593: IFTRUE 36597
36595: GO 36612
36597: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
36598: LD_EXP 52
36602: PPUSH
36603: LD_STRING DA1-Gary-1a
36605: PPUSH
36606: CALL_OW 91
36610: GO 36829
36612: LD_EXP 55
36616: DOUBLE
36617: EQUAL
36618: IFTRUE 36622
36620: GO 36647
36622: POP
// if JMMGirl = 3 then
36623: LD_EXP 7
36627: PUSH
36628: LD_INT 3
36630: EQUAL
36631: IFFALSE 36645
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
36633: LD_EXP 55
36637: PPUSH
36638: LD_STRING DA1-Con-1a
36640: PPUSH
36641: CALL_OW 91
36645: GO 36829
36647: LD_EXP 64
36651: DOUBLE
36652: EQUAL
36653: IFTRUE 36657
36655: GO 36672
36657: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
36658: LD_EXP 64
36662: PPUSH
36663: LD_STRING DA1-Kurt-1a
36665: PPUSH
36666: CALL_OW 91
36670: GO 36829
36672: LD_EXP 54
36676: DOUBLE
36677: EQUAL
36678: IFTRUE 36682
36680: GO 36697
36682: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
36683: LD_EXP 54
36687: PPUSH
36688: LD_STRING DA1-Yam-1a
36690: PPUSH
36691: CALL_OW 91
36695: GO 36829
36697: LD_EXP 53
36701: DOUBLE
36702: EQUAL
36703: IFTRUE 36707
36705: GO 36722
36707: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
36708: LD_EXP 53
36712: PPUSH
36713: LD_STRING DA1-Frank-1a
36715: PPUSH
36716: CALL_OW 91
36720: GO 36829
36722: POP
// begin join := rand ( 0 , 1 ) ;
36723: LD_ADDR_VAR 0 3
36727: PUSH
36728: LD_INT 0
36730: PPUSH
36731: LD_INT 1
36733: PPUSH
36734: CALL_OW 12
36738: ST_TO_ADDR
// if join then
36739: LD_VAR 0 3
36743: IFFALSE 36788
// begin if GetSex ( unit ) = sex_male then
36745: LD_VAR 0 1
36749: PPUSH
36750: CALL_OW 258
36754: PUSH
36755: LD_INT 1
36757: EQUAL
36758: IFFALSE 36774
// ForceSay ( unit , DA1-Sol1-1b ) else
36760: LD_VAR 0 1
36764: PPUSH
36765: LD_STRING DA1-Sol1-1b
36767: PPUSH
36768: CALL_OW 91
36772: GO 36786
// ForceSay ( unit , DA1-FSol1-1b ) ;
36774: LD_VAR 0 1
36778: PPUSH
36779: LD_STRING DA1-FSol1-1b
36781: PPUSH
36782: CALL_OW 91
// end else
36786: GO 36829
// begin if GetSex ( unit ) = sex_male then
36788: LD_VAR 0 1
36792: PPUSH
36793: CALL_OW 258
36797: PUSH
36798: LD_INT 1
36800: EQUAL
36801: IFFALSE 36817
// ForceSay ( unit , DA1-Sol1-1a ) else
36803: LD_VAR 0 1
36807: PPUSH
36808: LD_STRING DA1-Sol1-1a
36810: PPUSH
36811: CALL_OW 91
36815: GO 36829
// ForceSay ( unit , DA1-FSol1-1a ) ;
36817: LD_VAR 0 1
36821: PPUSH
36822: LD_STRING DA1-FSol1-1a
36824: PPUSH
36825: CALL_OW 91
// end ; end ; end ; if unit = JMM then
36829: LD_VAR 0 1
36833: PUSH
36834: LD_EXP 40
36838: EQUAL
36839: IFFALSE 36850
// begin YouLost ( JMMCaptured ) ;
36841: LD_STRING JMMCaptured
36843: PPUSH
36844: CALL_OW 104
// exit ;
36848: GO 37156
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi , DeltaDoctor ] or join then
36850: LD_VAR 0 1
36854: PUSH
36855: LD_EXP 44
36859: PUSH
36860: LD_EXP 47
36864: PUSH
36865: LD_EXP 45
36869: PUSH
36870: LD_EXP 42
36874: PUSH
36875: LD_EXP 56
36879: PUSH
36880: LD_EXP 48
36884: PUSH
36885: LD_EXP 54
36889: PUSH
36890: LD_EXP 58
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: LIST
36899: LIST
36900: LIST
36901: LIST
36902: LIST
36903: LIST
36904: IN
36905: IFTRUE 36913
36907: PUSH
36908: LD_VAR 0 3
36912: OR
36913: IFFALSE 37012
// begin Say ( Roth , DA-Roth-3 ) ;
36915: LD_EXP 79
36919: PPUSH
36920: LD_STRING DA-Roth-3
36922: PPUSH
36923: CALL_OW 88
// SetSide ( unit , 7 ) ;
36927: LD_VAR 0 1
36931: PPUSH
36932: LD_INT 7
36934: PPUSH
36935: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
36939: LD_ADDR_EXP 102
36943: PUSH
36944: LD_EXP 102
36948: PPUSH
36949: LD_INT 1
36951: PPUSH
36952: LD_EXP 102
36956: PUSH
36957: LD_INT 1
36959: ARRAY
36960: PUSH
36961: LD_VAR 0 1
36965: ADD
36966: PPUSH
36967: CALL_OW 1
36971: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
36972: LD_INT 260
36974: PPUSH
36975: LD_INT 235
36977: PPUSH
36978: LD_INT 1
36980: PPUSH
36981: CALL_OW 331
// SetLives ( unit , 1000 ) ;
36985: LD_VAR 0 1
36989: PPUSH
36990: LD_INT 1000
36992: PPUSH
36993: CALL_OW 234
// DialogueOff ;
36997: CALL_OW 7
// ComFree ( unit ) ;
37001: LD_VAR 0 1
37005: PPUSH
37006: CALL_OW 139
// end else
37010: GO 37093
// begin Say ( Roth , DA-Roth-3a ) ;
37012: LD_EXP 79
37016: PPUSH
37017: LD_STRING DA-Roth-3a
37019: PPUSH
37020: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
37024: LD_ADDR_EXP 35
37028: PUSH
37029: LD_EXP 35
37033: PUSH
37034: LD_VAR 0 1
37038: ADD
37039: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
37040: LD_INT 260
37042: PPUSH
37043: LD_INT 235
37045: PPUSH
37046: LD_INT 1
37048: PPUSH
37049: CALL_OW 331
// SetLives ( unit , 1000 ) ;
37053: LD_VAR 0 1
37057: PPUSH
37058: LD_INT 1000
37060: PPUSH
37061: CALL_OW 234
// DialogueOff ;
37065: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
37069: LD_VAR 0 1
37073: PPUSH
37074: LD_INT 272
37076: PPUSH
37077: LD_INT 254
37079: PPUSH
37080: CALL_OW 111
// AddComHold ( unit ) ;
37084: LD_VAR 0 1
37088: PPUSH
37089: CALL_OW 200
// end ; if capturedUnit = 1 then
37093: LD_EXP 34
37097: PUSH
37098: LD_INT 1
37100: EQUAL
37101: IFFALSE 37156
// begin DialogueOn ;
37103: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
37107: LD_EXP 40
37111: PPUSH
37112: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
37116: LD_EXP 40
37120: PPUSH
37121: LD_STRING DAa-JMM-1
37123: PPUSH
37124: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
37128: LD_EXP 40
37132: PPUSH
37133: LD_STRING DAa-JMM-1a
37135: PPUSH
37136: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
37140: LD_EXP 40
37144: PPUSH
37145: LD_STRING DAa-JMM-1b
37147: PPUSH
37148: CALL_OW 88
// DialogueOff ;
37152: CALL_OW 7
// end ; end ;
37156: LD_VAR 0 2
37160: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
37161: LD_EXP 15
37165: PUSH
37166: LD_INT 13
37168: GREATEREQUAL
37169: IFFALSE 37205
37171: PUSH
37172: LD_INT 22
37174: PUSH
37175: LD_INT 2
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 21
37184: PUSH
37185: LD_INT 1
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: EMPTY
37193: LIST
37194: LIST
37195: PPUSH
37196: CALL_OW 69
37200: PUSH
37201: LD_INT 0
37203: EQUAL
37204: AND
37205: IFFALSE 37259
37207: PUSH
37208: LD_INT 22
37210: PUSH
37211: LD_INT 2
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: LD_INT 33
37220: PUSH
37221: LD_INT 5
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: LD_INT 21
37230: PUSH
37231: LD_INT 2
37233: PUSH
37234: EMPTY
37235: LIST
37236: LIST
37237: PUSH
37238: LD_INT 50
37240: PUSH
37241: EMPTY
37242: LIST
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: PPUSH
37250: CALL_OW 69
37254: PUSH
37255: LD_INT 0
37257: EQUAL
37258: AND
37259: IFFALSE 37267
37261: PUSH
37262: LD_EXP 21
37266: AND
37267: IFFALSE 37275
37269: PUSH
37270: LD_EXP 22
37274: AND
37275: IFFALSE 37283
37277: PUSH
37278: LD_EXP 23
37282: AND
37283: IFFALSE 38064
37285: GO 37287
37287: DISABLE
37288: LD_INT 0
37290: PPUSH
37291: PPUSH
37292: PPUSH
// begin wait ( 0 0$05 ) ;
37293: LD_INT 175
37295: PPUSH
37296: CALL_OW 67
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 2 then
37300: LD_INT 22
37302: PUSH
37303: LD_INT 1
37305: PUSH
37306: EMPTY
37307: LIST
37308: LIST
37309: PUSH
37310: LD_INT 21
37312: PUSH
37313: LD_INT 1
37315: PUSH
37316: EMPTY
37317: LIST
37318: LIST
37319: PUSH
37320: LD_INT 23
37322: PUSH
37323: LD_INT 1
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 50
37332: PUSH
37333: EMPTY
37334: LIST
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: LIST
37340: LIST
37341: PPUSH
37342: CALL_OW 69
37346: PPUSH
37347: CALL 73163 0 1
37351: PUSH
37352: LD_INT 2
37354: LESS
37355: IFFALSE 37366
// begin YouLost ( LostVictory ) ;
37357: LD_STRING LostVictory
37359: PPUSH
37360: CALL_OW 104
// exit ;
37364: GO 38064
// end ; m1 := false ;
37366: LD_ADDR_VAR 0 1
37370: PUSH
37371: LD_INT 0
37373: ST_TO_ADDR
// m2 := false ;
37374: LD_ADDR_VAR 0 2
37378: PUSH
37379: LD_INT 0
37381: ST_TO_ADDR
// m3 := false ;
37382: LD_ADDR_VAR 0 3
37386: PUSH
37387: LD_INT 0
37389: ST_TO_ADDR
// if not bombExploded then
37390: LD_EXP 37
37394: NOT
37395: IFFALSE 37404
// SetAchievement ( ACH_SIBROCKET ) ;
37397: LD_STRING ACH_SIBROCKET
37399: PPUSH
37400: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
37404: LD_EXP 66
37408: PPUSH
37409: CALL_OW 255
37413: PUSH
37414: LD_INT 1
37416: EQUAL
37417: IFFALSE 37430
37419: PUSH
37420: LD_EXP 66
37424: PPUSH
37425: CALL_OW 302
37429: AND
37430: IFFALSE 37446
// begin wait ( 3 ) ;
37432: LD_INT 3
37434: PPUSH
37435: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
37439: LD_STRING ACH_OPO
37441: PPUSH
37442: CALL_OW 543
// end ; if tick <= 120 120$00 then
37446: LD_OWVAR 1
37450: PUSH
37451: LD_INT 252000
37453: LESSEQUAL
37454: IFFALSE 37470
// begin wait ( 3 ) ;
37456: LD_INT 3
37458: PPUSH
37459: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
37463: LD_STRING ACH_ASPEED_15
37465: PPUSH
37466: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
37470: LD_EXP 40
37474: PPUSH
37475: CALL_OW 87
// music_class := 5 ;
37479: LD_ADDR_OWVAR 72
37483: PUSH
37484: LD_INT 5
37486: ST_TO_ADDR
// music_nat := 5 ;
37487: LD_ADDR_OWVAR 71
37491: PUSH
37492: LD_INT 5
37494: ST_TO_ADDR
// DialogueOn ;
37495: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
37499: LD_EXP 40
37503: PPUSH
37504: LD_STRING D20-JMM-1
37506: PPUSH
37507: CALL_OW 88
// if IsOK ( Joan ) then
37511: LD_EXP 41
37515: PPUSH
37516: CALL_OW 302
37520: IFFALSE 37534
// Say ( Joan , D20-Joan-1 ) ;
37522: LD_EXP 41
37526: PPUSH
37527: LD_STRING D20-Joan-1
37529: PPUSH
37530: CALL_OW 88
// if IsOk ( Lisa ) then
37534: LD_EXP 43
37538: PPUSH
37539: CALL_OW 302
37543: IFFALSE 37557
// Say ( Lisa , D20-Lisa-1 ) ;
37545: LD_EXP 43
37549: PPUSH
37550: LD_STRING D20-Lisa-1
37552: PPUSH
37553: CALL_OW 88
// if IsOk ( Donaldson ) then
37557: LD_EXP 44
37561: PPUSH
37562: CALL_OW 302
37566: IFFALSE 37580
// Say ( Donaldson , D20-Don-1 ) ;
37568: LD_EXP 44
37572: PPUSH
37573: LD_STRING D20-Don-1
37575: PPUSH
37576: CALL_OW 88
// if IsOK ( Cornel ) then
37580: LD_EXP 51
37584: PPUSH
37585: CALL_OW 302
37589: IFFALSE 37603
// Say ( Cornel , D20-Corn-1 ) ;
37591: LD_EXP 51
37595: PPUSH
37596: LD_STRING D20-Corn-1
37598: PPUSH
37599: CALL_OW 88
// if IsOk ( Denis ) then
37603: LD_EXP 47
37607: PPUSH
37608: CALL_OW 302
37612: IFFALSE 37626
// Say ( Denis , D20-Den-1 ) ;
37614: LD_EXP 47
37618: PPUSH
37619: LD_STRING D20-Den-1
37621: PPUSH
37622: CALL_OW 88
// if IsOk ( Bobby ) then
37626: LD_EXP 45
37630: PPUSH
37631: CALL_OW 302
37635: IFFALSE 37649
// Say ( Bobby , D20-Bobby-1 ) ;
37637: LD_EXP 45
37641: PPUSH
37642: LD_STRING D20-Bobby-1
37644: PPUSH
37645: CALL_OW 88
// if IsOk ( Gladstone ) then
37649: LD_EXP 49
37653: PPUSH
37654: CALL_OW 302
37658: IFFALSE 37672
// Say ( Gladstone , D20-Glad-1 ) ;
37660: LD_EXP 49
37664: PPUSH
37665: LD_STRING D20-Glad-1
37667: PPUSH
37668: CALL_OW 88
// if IsOk ( Cyrus ) then
37672: LD_EXP 46
37676: PPUSH
37677: CALL_OW 302
37681: IFFALSE 37695
// Say ( Cyrus , D20-Cyrus-1 ) ;
37683: LD_EXP 46
37687: PPUSH
37688: LD_STRING D20-Cyrus-1
37690: PPUSH
37691: CALL_OW 88
// if IsOk ( Stevens ) then
37695: LD_EXP 42
37699: PPUSH
37700: CALL_OW 302
37704: IFFALSE 37718
// Say ( Stevens , D20-Huck-1 ) ;
37706: LD_EXP 42
37710: PPUSH
37711: LD_STRING D20-Huck-1
37713: PPUSH
37714: CALL_OW 88
// if IsOk ( Brown ) then
37718: LD_EXP 48
37722: PPUSH
37723: CALL_OW 302
37727: IFFALSE 37741
// Say ( Brown , D20-Brown-1 ) ;
37729: LD_EXP 48
37733: PPUSH
37734: LD_STRING D20-Brown-1
37736: PPUSH
37737: CALL_OW 88
// if IsOk ( Gary ) then
37741: LD_EXP 52
37745: PPUSH
37746: CALL_OW 302
37750: IFFALSE 37764
// Say ( Gary , D20-Gary-1 ) ;
37752: LD_EXP 52
37756: PPUSH
37757: LD_STRING D20-Gary-1
37759: PPUSH
37760: CALL_OW 88
// if IsOk ( Connie ) then
37764: LD_EXP 55
37768: PPUSH
37769: CALL_OW 302
37773: IFFALSE 37787
// Say ( Connie , D20-Con-1 ) ;
37775: LD_EXP 55
37779: PPUSH
37780: LD_STRING D20-Con-1
37782: PPUSH
37783: CALL_OW 88
// if IsOk ( Kurt ) then
37787: LD_EXP 64
37791: PPUSH
37792: CALL_OW 302
37796: IFFALSE 37810
// Say ( Kurt , D20-Kurt-1 ) ;
37798: LD_EXP 64
37802: PPUSH
37803: LD_STRING D20-Kurt-1
37805: PPUSH
37806: CALL_OW 88
// if IsOk ( Kikuchi ) then
37810: LD_EXP 54
37814: PPUSH
37815: CALL_OW 302
37819: IFFALSE 37833
// Say ( Kikuchi , D20-Yam-1 ) ;
37821: LD_EXP 54
37825: PPUSH
37826: LD_STRING D20-Yam-1
37828: PPUSH
37829: CALL_OW 88
// if IsOk ( Frank ) then
37833: LD_EXP 53
37837: PPUSH
37838: CALL_OW 302
37842: IFFALSE 37856
// Say ( Frank , D20-Frank-1 ) ;
37844: LD_EXP 53
37848: PPUSH
37849: LD_STRING D20-Frank-1
37851: PPUSH
37852: CALL_OW 88
// DialogueOff ;
37856: CALL_OW 7
// if RothCaptured then
37860: LD_EXP 33
37864: IFFALSE 37886
// begin m1 := true ;
37866: LD_ADDR_VAR 0 1
37870: PUSH
37871: LD_INT 1
37873: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
37874: LD_STRING Roth
37876: PPUSH
37877: LD_INT 1
37879: PPUSH
37880: CALL_OW 101
// end else
37884: GO 37897
// AddMedal ( Roth , - 1 ) ;
37886: LD_STRING Roth
37888: PPUSH
37889: LD_INT 1
37891: NEG
37892: PPUSH
37893: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
37897: LD_EXP 25
37901: NOT
37902: IFTRUE 37910
37904: PUSH
37905: LD_EXP 27
37909: OR
37910: IFTRUE 37919
37912: PUSH
37913: LD_EXP 28
37917: NOT
37918: OR
37919: IFFALSE 37941
// begin m2 := true ;
37921: LD_ADDR_VAR 0 2
37925: PUSH
37926: LD_INT 1
37928: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
37929: LD_STRING Project
37931: PPUSH
37932: LD_INT 1
37934: PPUSH
37935: CALL_OW 101
// end else
37939: GO 37952
// AddMedal ( Project , - 1 ) ;
37941: LD_STRING Project
37943: PPUSH
37944: LD_INT 1
37946: NEG
37947: PPUSH
37948: CALL_OW 101
// if lostCounter = 0 then
37952: LD_EXP 32
37956: PUSH
37957: LD_INT 0
37959: EQUAL
37960: IFFALSE 37982
// begin m3 := true ;
37962: LD_ADDR_VAR 0 3
37966: PUSH
37967: LD_INT 1
37969: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
37970: LD_STRING NoLosses
37972: PPUSH
37973: LD_INT 1
37975: PPUSH
37976: CALL_OW 101
// end else
37980: GO 37993
// AddMedal ( NoLosses , - 1 ) ;
37982: LD_STRING NoLosses
37984: PPUSH
37985: LD_INT 1
37987: NEG
37988: PPUSH
37989: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
37993: LD_VAR 0 1
37997: IFFALSE 38005
37999: PUSH
38000: LD_VAR 0 2
38004: AND
38005: IFFALSE 38013
38007: PUSH
38008: LD_VAR 0 3
38012: AND
38013: IFFALSE 38025
38015: PUSH
38016: LD_OWVAR 67
38020: PUSH
38021: LD_INT 3
38023: GREATEREQUAL
38024: AND
38025: IFFALSE 38037
// SetAchievementEX ( ACH_AMER , 15 ) ;
38027: LD_STRING ACH_AMER
38029: PPUSH
38030: LD_INT 15
38032: PPUSH
38033: CALL_OW 564
// GiveMedals ( MAIN ) ;
38037: LD_STRING MAIN
38039: PPUSH
38040: CALL_OW 102
// music_class := 4 ;
38044: LD_ADDR_OWVAR 72
38048: PUSH
38049: LD_INT 4
38051: ST_TO_ADDR
// music_nat := 1 ;
38052: LD_ADDR_OWVAR 71
38056: PUSH
38057: LD_INT 1
38059: ST_TO_ADDR
// YouWin ;
38060: CALL_OW 103
// end ; end_of_file
38064: PPOPN 3
38066: END
// export function CustomEvent ( event ) ; begin
38067: LD_INT 0
38069: PPUSH
// end ;
38070: LD_VAR 0 2
38074: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
38075: LD_VAR 0 1
38079: PUSH
38080: LD_INT 1
38082: EQUAL
38083: IFFALSE 38095
38085: PUSH
38086: LD_VAR 0 2
38090: PUSH
38091: LD_INT 4
38093: EQUAL
38094: AND
38095: IFFALSE 38108
38097: PUSH
38098: LD_EXP 61
38102: PPUSH
38103: CALL_OW 300
38107: AND
38108: IFFALSE 38124
// begin wait ( 0 0$2 ) ;
38110: LD_INT 70
38112: PPUSH
38113: CALL_OW 67
// YouLost ( Dismissed ) ;
38117: LD_STRING Dismissed
38119: PPUSH
38120: CALL_OW 104
// end ; end ;
38124: PPOPN 2
38126: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
38127: LD_VAR 0 2
38131: PPUSH
38132: LD_VAR 0 3
38136: PPUSH
38137: LD_INT 18
38139: PPUSH
38140: CALL_OW 309
38144: IFFALSE 38153
// YouLost ( Motherlode3 ) ;
38146: LD_STRING Motherlode3
38148: PPUSH
38149: CALL_OW 104
// end ;
38153: PPOPN 3
38155: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
38156: LD_EXP 27
38160: NOT
38161: IFFALSE 38171
// behemothDone := true ;
38163: LD_ADDR_EXP 28
38167: PUSH
38168: LD_INT 1
38170: ST_TO_ADDR
// end ;
38171: PPOPN 1
38173: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
38174: LD_VAR 0 1
38178: PPUSH
38179: CALL_OW 255
38183: PUSH
38184: LD_INT 1
38186: EQUAL
38187: IFFALSE 38197
// bombExploded := true ;
38189: LD_ADDR_EXP 37
38193: PUSH
38194: LD_INT 1
38196: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
38197: LD_VAR 0 1
38201: PPUSH
38202: CALL_OW 255
38206: PUSH
38207: LD_INT 3
38209: EQUAL
38210: IFFALSE 38240
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
38212: LD_INT 2
38214: PPUSH
38215: LD_INT 23
38217: PUSH
38218: LD_INT 3
38220: PUSH
38221: LD_INT 3
38223: PUSH
38224: LD_INT 48
38226: PUSH
38227: EMPTY
38228: LIST
38229: LIST
38230: LIST
38231: LIST
38232: PUSH
38233: EMPTY
38234: LIST
38235: PPUSH
38236: CALL 64415 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
38240: LD_VAR 0 1
38244: PPUSH
38245: CALL_OW 255
38249: PUSH
38250: LD_INT 1
38252: EQUAL
38253: IFFALSE 38270
38255: PUSH
38256: LD_EXP 66
38260: PPUSH
38261: CALL_OW 255
38265: PUSH
38266: LD_INT 1
38268: EQUAL
38269: AND
38270: IFFALSE 38283
38272: PUSH
38273: LD_EXP 66
38277: PPUSH
38278: CALL_OW 302
38282: AND
38283: IFFALSE 38291
38285: PUSH
38286: LD_EXP 30
38290: AND
38291: IFFALSE 38323
38293: PUSH
38294: LD_INT 22
38296: PUSH
38297: LD_INT 3
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: LD_INT 34
38306: PUSH
38307: LD_INT 48
38309: PUSH
38310: EMPTY
38311: LIST
38312: LIST
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PPUSH
38318: CALL_OW 69
38322: AND
38323: IFFALSE 38356
38325: PUSH
38326: LD_INT 22
38328: PUSH
38329: LD_INT 1
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 34
38338: PUSH
38339: LD_INT 8
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PPUSH
38350: CALL_OW 69
38354: NOT
38355: AND
38356: IFFALSE 38408
// begin wait ( 0 0$5 ) ;
38358: LD_INT 175
38360: PPUSH
38361: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
38365: LD_INT 22
38367: PUSH
38368: LD_INT 3
38370: PUSH
38371: EMPTY
38372: LIST
38373: LIST
38374: PUSH
38375: LD_INT 34
38377: PUSH
38378: LD_INT 48
38380: PUSH
38381: EMPTY
38382: LIST
38383: LIST
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PPUSH
38389: CALL_OW 69
38393: PUSH
38394: LD_INT 1
38396: ARRAY
38397: PPUSH
38398: LD_INT 60
38400: PPUSH
38401: LD_INT 95
38403: PPUSH
38404: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
38408: LD_VAR 0 2
38412: PPUSH
38413: LD_VAR 0 3
38417: PPUSH
38418: LD_INT 18
38420: PPUSH
38421: CALL_OW 309
38425: IFTRUE 38446
38427: PUSH
38428: LD_VAR 0 2
38432: PPUSH
38433: LD_VAR 0 3
38437: PPUSH
38438: LD_INT 18
38440: PPUSH
38441: CALL 113124 0 3
38445: OR
38446: IFFALSE 38493
// begin if GetSide ( unit ) = 1 then
38448: LD_VAR 0 1
38452: PPUSH
38453: CALL_OW 255
38457: PUSH
38458: LD_INT 1
38460: EQUAL
38461: IFFALSE 38479
// begin wait ( 0 0$6 ) ;
38463: LD_INT 210
38465: PPUSH
38466: CALL_OW 67
// YouLost ( Motherlode2 ) ;
38470: LD_STRING Motherlode2
38472: PPUSH
38473: CALL_OW 104
// end else
38477: GO 38493
// begin wait ( 0 0$6 ) ;
38479: LD_INT 210
38481: PPUSH
38482: CALL_OW 67
// YouLost ( Motherlode1 ) ;
38486: LD_STRING Motherlode1
38488: PPUSH
38489: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
38493: LD_VAR 0 1
38497: PPUSH
38498: CALL_OW 255
38502: PUSH
38503: LD_INT 3
38505: EQUAL
38506: IFFALSE 38527
// begin wait ( 0 0$5 ) ;
38508: LD_INT 175
38510: PPUSH
38511: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
38515: LD_EXP 68
38519: PPUSH
38520: LD_STRING D18-Pla-1
38522: PPUSH
38523: CALL_OW 94
// end ; end ;
38527: PPOPN 3
38529: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
38530: LD_VAR 0 1
38534: PPUSH
38535: CALL 130579 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
38539: LD_VAR 0 1
38543: PUSH
38544: LD_INT 22
38546: PUSH
38547: LD_INT 1
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: PUSH
38554: LD_INT 21
38556: PUSH
38557: LD_INT 1
38559: PUSH
38560: EMPTY
38561: LIST
38562: LIST
38563: PUSH
38564: LD_INT 23
38566: PUSH
38567: LD_INT 1
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: LIST
38578: PPUSH
38579: CALL_OW 69
38583: IN
38584: IFFALSE 38600
// lostCounter := lostCounter + 1 ;
38586: LD_ADDR_EXP 32
38590: PUSH
38591: LD_EXP 32
38595: PUSH
38596: LD_INT 1
38598: PLUS
38599: ST_TO_ADDR
// if un in behemothBuilders then
38600: LD_VAR 0 1
38604: PUSH
38605: LD_EXP 77
38609: IN
38610: IFFALSE 38630
// begin behemothBuilders := behemothBuilders diff un ;
38612: LD_ADDR_EXP 77
38616: PUSH
38617: LD_EXP 77
38621: PUSH
38622: LD_VAR 0 1
38626: DIFF
38627: ST_TO_ADDR
// exit ;
38628: GO 38660
// end ; if un = JMM then
38630: LD_VAR 0 1
38634: PUSH
38635: LD_EXP 40
38639: EQUAL
38640: IFFALSE 38651
// begin YouLost ( JMM ) ;
38642: LD_STRING JMM
38644: PPUSH
38645: CALL_OW 104
// exit ;
38649: GO 38660
// end ; MCE_UnitDestroyed ( un ) ;
38651: LD_VAR 0 1
38655: PPUSH
38656: CALL 67921 0 1
// end ;
38660: PPOPN 1
38662: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
38663: LD_VAR 0 1
38667: PPUSH
38668: LD_VAR 0 2
38672: PPUSH
38673: CALL 70275 0 2
// end ;
38677: PPOPN 2
38679: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
38680: LD_VAR 0 1
38684: PPUSH
38685: CALL 69339 0 1
// end ;
38689: PPOPN 1
38691: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
38692: LD_VAR 0 1
38696: PUSH
38697: LD_INT 22
38699: PUSH
38700: LD_INT 8
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 30
38709: PUSH
38710: LD_INT 2
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 23
38719: PUSH
38720: LD_INT 3
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: EMPTY
38728: LIST
38729: LIST
38730: LIST
38731: PPUSH
38732: CALL_OW 69
38736: IN
38737: IFFALSE 38764
// begin ComUpgrade ( building ) ;
38739: LD_VAR 0 1
38743: PPUSH
38744: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
38748: LD_EXP 65
38752: PPUSH
38753: LD_VAR 0 1
38757: PPUSH
38758: CALL 79333 0 2
// exit ;
38762: GO 38773
// end ; MCE_BuildingComplete ( building ) ;
38764: LD_VAR 0 1
38768: PPUSH
38769: CALL 69582 0 1
// end ;
38773: PPOPN 1
38775: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
38776: LD_VAR 0 1
38780: PPUSH
38781: LD_VAR 0 2
38785: PPUSH
38786: CALL 67609 0 2
// end ;
38790: PPOPN 2
38792: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
38793: LD_VAR 0 1
38797: PPUSH
38798: LD_VAR 0 2
38802: PPUSH
38803: LD_VAR 0 3
38807: PPUSH
38808: LD_VAR 0 4
38812: PPUSH
38813: LD_VAR 0 5
38817: PPUSH
38818: CALL 67227 0 5
// end ;
38822: PPOPN 5
38824: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
38825: LD_VAR 0 1
38829: PPUSH
38830: CALL_OW 255
38834: PUSH
38835: LD_INT 1
38837: EQUAL
38838: IFFALSE 38855
// amConstructCounter := Inc ( amConstructCounter ) ;
38840: LD_ADDR_EXP 39
38844: PUSH
38845: LD_EXP 39
38849: PPUSH
38850: CALL 110512 0 1
38854: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
38855: LD_VAR 0 1
38859: PPUSH
38860: LD_VAR 0 2
38864: PPUSH
38865: CALL 130637 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
38869: LD_VAR 0 1
38873: PPUSH
38874: LD_VAR 0 2
38878: PPUSH
38879: CALL 66776 0 2
// end ;
38883: PPOPN 2
38885: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
38886: LD_VAR 0 1
38890: PPUSH
38891: LD_VAR 0 2
38895: PPUSH
38896: LD_VAR 0 3
38900: PPUSH
38901: LD_VAR 0 4
38905: PPUSH
38906: CALL 66608 0 4
// end ;
38910: PPOPN 4
38912: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
38913: LD_VAR 0 1
38917: PPUSH
38918: LD_VAR 0 2
38922: PPUSH
38923: LD_VAR 0 3
38927: PPUSH
38928: CALL 66381 0 3
// end ;
38932: PPOPN 3
38934: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
38935: LD_VAR 0 1
38939: PPUSH
38940: LD_VAR 0 2
38944: PPUSH
38945: CALL 66264 0 2
// end ;
38949: PPOPN 2
38951: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
38952: LD_VAR 0 1
38956: PPUSH
38957: LD_VAR 0 2
38961: PPUSH
38962: CALL 70572 0 2
// end ;
38966: PPOPN 2
38968: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
38969: LD_VAR 0 1
38973: PUSH
38974: LD_INT 460
38976: EQUAL
38977: IFFALSE 38999
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
38979: LD_VAR 0 2
38983: PPUSH
38984: LD_INT 227
38986: PPUSH
38987: LD_INT 136
38989: PPUSH
38990: CALL_OW 428
38994: PPUSH
38995: CALL_OW 120
// end ;
38999: PPOPN 2
39001: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
39002: LD_VAR 0 1
39006: PPUSH
39007: CALL_OW 255
39011: PUSH
39012: LD_INT 4
39014: EQUAL
39015: IFFALSE 39033
39017: PUSH
39018: LD_VAR 0 1
39022: PUSH
39023: LD_EXP 18
39027: PUSH
39028: LD_INT 1
39030: ARRAY
39031: IN
39032: AND
39033: IFFALSE 39041
39035: PUSH
39036: LD_EXP 19
39040: AND
39041: IFFALSE 39060
// begin ComMoveXY ( driver , 61 , 93 ) ;
39043: LD_VAR 0 1
39047: PPUSH
39048: LD_INT 61
39050: PPUSH
39051: LD_INT 93
39053: PPUSH
39054: CALL_OW 111
// exit ;
39058: GO 39131
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
39060: LD_VAR 0 1
39064: PPUSH
39065: CALL_OW 255
39069: PUSH
39070: LD_INT 3
39072: EQUAL
39073: IFFALSE 39090
39075: PUSH
39076: LD_VAR 0 1
39080: PPUSH
39081: CALL_OW 110
39085: PUSH
39086: LD_INT 105
39088: EQUAL
39089: AND
39090: IFFALSE 39107
// begin ComMoveXY ( driver , 187 , 92 ) ;
39092: LD_VAR 0 1
39096: PPUSH
39097: LD_INT 187
39099: PPUSH
39100: LD_INT 92
39102: PPUSH
39103: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
39107: LD_VAR 0 1
39111: PPUSH
39112: LD_VAR 0 2
39116: PPUSH
39117: LD_VAR 0 3
39121: PPUSH
39122: LD_VAR 0 4
39126: PPUSH
39127: CALL 70796 0 4
// end ;
39131: PPOPN 4
39133: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
39134: LD_VAR 0 1
39138: PPUSH
39139: LD_VAR 0 2
39143: PPUSH
39144: CALL 66071 0 2
// end ;
39148: PPOPN 2
39150: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
39151: LD_VAR 0 1
39155: PPUSH
39156: CALL 130621 0 1
// end ; end_of_file
39160: PPOPN 1
39162: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
39163: LD_EXP 15
39167: PUSH
39168: LD_INT 2
39170: EQUAL
39171: IFFALSE 39688
39173: GO 39175
39175: DISABLE
39176: LD_INT 0
39178: PPUSH
39179: PPUSH
// begin time := 0 0$35 ;
39180: LD_ADDR_VAR 0 2
39184: PUSH
39185: LD_INT 1225
39187: ST_TO_ADDR
// repeat wait ( time ) ;
39188: LD_VAR 0 2
39192: PPUSH
39193: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
39197: LD_INT 1
39199: PPUSH
39200: LD_INT 5
39202: PPUSH
39203: CALL_OW 12
39207: PPUSH
39208: LD_INT 106
39210: PPUSH
39211: LD_INT 150
39213: PPUSH
39214: LD_INT 19
39216: PPUSH
39217: LD_INT 1
39219: PPUSH
39220: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
39224: LD_INT 455
39226: PPUSH
39227: LD_INT 770
39229: PPUSH
39230: CALL_OW 12
39234: PPUSH
39235: CALL_OW 67
// if Prob ( 50 ) then
39239: LD_INT 50
39241: PPUSH
39242: CALL_OW 13
39246: IFFALSE 39275
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
39248: LD_INT 1
39250: PPUSH
39251: LD_INT 5
39253: PPUSH
39254: CALL_OW 12
39258: PPUSH
39259: LD_INT 62
39261: PPUSH
39262: LD_INT 108
39264: PPUSH
39265: LD_INT 10
39267: PPUSH
39268: LD_INT 1
39270: PPUSH
39271: CALL_OW 56
// until missionStage > 4 ;
39275: LD_EXP 15
39279: PUSH
39280: LD_INT 4
39282: GREATER
39283: IFFALSE 39188
// repeat wait ( 0 0$1 ) ;
39285: LD_INT 35
39287: PPUSH
39288: CALL_OW 67
// until missionStage = 6 ;
39292: LD_EXP 15
39296: PUSH
39297: LD_INT 6
39299: EQUAL
39300: IFFALSE 39285
// time := 0 0$20 ;
39302: LD_ADDR_VAR 0 2
39306: PUSH
39307: LD_INT 700
39309: ST_TO_ADDR
// repeat wait ( time ) ;
39310: LD_VAR 0 2
39314: PPUSH
39315: CALL_OW 67
// if Prob ( 90 ) then
39319: LD_INT 90
39321: PPUSH
39322: CALL_OW 13
39326: IFFALSE 39369
// begin time := time + 0 0$2 ;
39328: LD_ADDR_VAR 0 2
39332: PUSH
39333: LD_VAR 0 2
39337: PUSH
39338: LD_INT 70
39340: PLUS
39341: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
39342: LD_INT 1
39344: PPUSH
39345: LD_INT 5
39347: PPUSH
39348: CALL_OW 12
39352: PPUSH
39353: LD_INT 106
39355: PPUSH
39356: LD_INT 89
39358: PPUSH
39359: LD_INT 45
39361: PPUSH
39362: LD_INT 1
39364: PPUSH
39365: CALL_OW 56
// end ; if Prob ( 45 ) then
39369: LD_INT 45
39371: PPUSH
39372: CALL_OW 13
39376: IFFALSE 39432
// begin for i := 1 to 4 do
39378: LD_ADDR_VAR 0 1
39382: PUSH
39383: DOUBLE
39384: LD_INT 1
39386: DEC
39387: ST_TO_ADDR
39388: LD_INT 4
39390: PUSH
39391: FOR_TO
39392: IFFALSE 39430
// begin wait ( 0 0$5 ) ;
39394: LD_INT 175
39396: PPUSH
39397: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
39401: LD_INT 1
39403: PPUSH
39404: LD_INT 5
39406: PPUSH
39407: CALL_OW 12
39411: PPUSH
39412: LD_INT 113
39414: PPUSH
39415: LD_INT 117
39417: PPUSH
39418: LD_INT 25
39420: PPUSH
39421: LD_INT 1
39423: PPUSH
39424: CALL_OW 56
// end ;
39428: GO 39391
39430: POP
39431: POP
// end ; if Prob ( 40 ) then
39432: LD_INT 40
39434: PPUSH
39435: CALL_OW 13
39439: IFFALSE 39485
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
39441: LD_INT 385
39443: PPUSH
39444: LD_INT 945
39446: PPUSH
39447: CALL_OW 12
39451: PPUSH
39452: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
39456: LD_INT 1
39458: PPUSH
39459: LD_INT 5
39461: PPUSH
39462: CALL_OW 12
39466: PPUSH
39467: LD_INT 21
39469: PPUSH
39470: LD_INT 26
39472: PPUSH
39473: LD_INT 12
39475: PPUSH
39476: LD_INT 1
39478: PPUSH
39479: CALL_OW 56
// end else
39483: GO 39521
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
39485: LD_INT 700
39487: PPUSH
39488: LD_INT 1225
39490: PPUSH
39491: CALL_OW 12
39495: PPUSH
39496: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
39500: LD_INT 1
39502: PPUSH
39503: LD_INT 5
39505: PPUSH
39506: CALL_OW 12
39510: PPUSH
39511: LD_INT 16
39513: PPUSH
39514: LD_INT 1
39516: PPUSH
39517: CALL_OW 55
// end ; if Prob ( 50 ) then
39521: LD_INT 50
39523: PPUSH
39524: CALL_OW 13
39528: IFFALSE 39574
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
39530: LD_INT 700
39532: PPUSH
39533: LD_INT 1050
39535: PPUSH
39536: CALL_OW 12
39540: PPUSH
39541: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
39545: LD_INT 1
39547: PPUSH
39548: LD_INT 5
39550: PPUSH
39551: CALL_OW 12
39555: PPUSH
39556: LD_INT 168
39558: PPUSH
39559: LD_INT 168
39561: PPUSH
39562: LD_INT 16
39564: PPUSH
39565: LD_INT 1
39567: PPUSH
39568: CALL_OW 56
// end else
39572: GO 39610
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
39574: LD_INT 350
39576: PPUSH
39577: LD_INT 525
39579: PPUSH
39580: CALL_OW 12
39584: PPUSH
39585: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
39589: LD_INT 1
39591: PPUSH
39592: LD_INT 5
39594: PPUSH
39595: CALL_OW 12
39599: PPUSH
39600: LD_INT 15
39602: PPUSH
39603: LD_INT 1
39605: PPUSH
39606: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
39610: LD_INT 175
39612: PPUSH
39613: LD_INT 315
39615: PPUSH
39616: CALL_OW 12
39620: PPUSH
39621: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
39625: LD_INT 1
39627: PPUSH
39628: LD_INT 5
39630: PPUSH
39631: CALL_OW 12
39635: PPUSH
39636: LD_INT 103
39638: PPUSH
39639: LD_INT 140
39641: PPUSH
39642: LD_INT 20
39644: PPUSH
39645: LD_INT 1
39647: PPUSH
39648: CALL_OW 56
// time := time + 0 0$2 ;
39652: LD_ADDR_VAR 0 2
39656: PUSH
39657: LD_VAR 0 2
39661: PUSH
39662: LD_INT 70
39664: PLUS
39665: ST_TO_ADDR
// if time > 1 1$20 then
39666: LD_VAR 0 2
39670: PUSH
39671: LD_INT 2800
39673: GREATER
39674: IFFALSE 39684
// time := 0 0$30 ;
39676: LD_ADDR_VAR 0 2
39680: PUSH
39681: LD_INT 1050
39683: ST_TO_ADDR
// until false ;
39684: LD_INT 0
39686: IFFALSE 39310
// end ; end_of_file
39688: PPOPN 2
39690: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
39691: LD_EXP 13
39695: IFFALSE 39707
39697: PUSH
39698: LD_EXP 15
39702: PUSH
39703: LD_INT 6
39705: GREATEREQUAL
39706: AND
39707: IFFALSE 39744
39709: GO 39711
39711: DISABLE
// begin enable ;
39712: ENABLE
// missionTime := missionTime + 0 0$1 ;
39713: LD_ADDR_EXP 14
39717: PUSH
39718: LD_EXP 14
39722: PUSH
39723: LD_INT 35
39725: PLUS
39726: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
39727: LD_ADDR_OWVAR 47
39731: PUSH
39732: LD_STRING #Am15-1
39734: PUSH
39735: LD_EXP 14
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: ST_TO_ADDR
// end ; end_of_file
39744: END
// export function InitNature ; begin
39745: LD_INT 0
39747: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
39748: LD_INT 3
39750: PPUSH
39751: LD_INT 3
39753: PPUSH
39754: LD_INT 2
39756: PPUSH
39757: LD_INT 1
39759: PPUSH
39760: LD_INT 1
39762: PPUSH
39763: LD_INT 0
39765: PPUSH
39766: LD_INT 0
39768: PPUSH
39769: LD_INT 20
39771: PPUSH
39772: LD_INT 0
39774: PPUSH
39775: CALL 105790 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
39779: LD_INT 2
39781: PPUSH
39782: LD_INT 1
39784: PPUSH
39785: LD_INT 1
39787: PPUSH
39788: LD_INT 1
39790: PPUSH
39791: LD_INT 1
39793: PPUSH
39794: LD_INT 0
39796: PPUSH
39797: LD_INT 0
39799: PPUSH
39800: LD_INT 21
39802: PPUSH
39803: LD_INT 0
39805: PPUSH
39806: CALL 105790 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
39810: LD_INT 4
39812: PPUSH
39813: LD_INT 1
39815: PPUSH
39816: LD_INT 2
39818: PPUSH
39819: LD_INT 4
39821: PPUSH
39822: LD_INT 2
39824: PPUSH
39825: LD_INT 1
39827: PPUSH
39828: LD_INT 0
39830: PPUSH
39831: LD_INT 22
39833: PPUSH
39834: LD_INT 0
39836: PPUSH
39837: CALL 105790 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
39841: LD_INT 0
39843: PPUSH
39844: LD_INT 0
39846: PPUSH
39847: LD_INT 0
39849: PPUSH
39850: LD_INT 0
39852: PPUSH
39853: LD_INT 0
39855: PPUSH
39856: LD_INT 0
39858: PPUSH
39859: LD_INT 9
39861: PPUSH
39862: LD_INT 0
39864: PPUSH
39865: LD_INT 23
39867: PPUSH
39868: CALL 105790 0 9
// end ; end_of_file
39872: LD_VAR 0 1
39876: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
39877: LD_INT 0
39879: PPUSH
39880: PPUSH
// skirmish := false ;
39881: LD_ADDR_EXP 100
39885: PUSH
39886: LD_INT 0
39888: ST_TO_ADDR
// debug_mc := false ;
39889: LD_ADDR_EXP 101
39893: PUSH
39894: LD_INT 0
39896: ST_TO_ADDR
// mc_bases := [ ] ;
39897: LD_ADDR_EXP 102
39901: PUSH
39902: EMPTY
39903: ST_TO_ADDR
// mc_sides := [ ] ;
39904: LD_ADDR_EXP 128
39908: PUSH
39909: EMPTY
39910: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
39911: LD_ADDR_EXP 103
39915: PUSH
39916: EMPTY
39917: ST_TO_ADDR
// mc_building_repairs := [ ] ;
39918: LD_ADDR_EXP 104
39922: PUSH
39923: EMPTY
39924: ST_TO_ADDR
// mc_need_heal := [ ] ;
39925: LD_ADDR_EXP 105
39929: PUSH
39930: EMPTY
39931: ST_TO_ADDR
// mc_healers := [ ] ;
39932: LD_ADDR_EXP 106
39936: PUSH
39937: EMPTY
39938: ST_TO_ADDR
// mc_build_list := [ ] ;
39939: LD_ADDR_EXP 107
39943: PUSH
39944: EMPTY
39945: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
39946: LD_ADDR_EXP 134
39950: PUSH
39951: EMPTY
39952: ST_TO_ADDR
// mc_builders := [ ] ;
39953: LD_ADDR_EXP 108
39957: PUSH
39958: EMPTY
39959: ST_TO_ADDR
// mc_construct_list := [ ] ;
39960: LD_ADDR_EXP 109
39964: PUSH
39965: EMPTY
39966: ST_TO_ADDR
// mc_turret_list := [ ] ;
39967: LD_ADDR_EXP 110
39971: PUSH
39972: EMPTY
39973: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
39974: LD_ADDR_EXP 111
39978: PUSH
39979: EMPTY
39980: ST_TO_ADDR
// mc_miners := [ ] ;
39981: LD_ADDR_EXP 116
39985: PUSH
39986: EMPTY
39987: ST_TO_ADDR
// mc_mines := [ ] ;
39988: LD_ADDR_EXP 115
39992: PUSH
39993: EMPTY
39994: ST_TO_ADDR
// mc_minefields := [ ] ;
39995: LD_ADDR_EXP 117
39999: PUSH
40000: EMPTY
40001: ST_TO_ADDR
// mc_crates := [ ] ;
40002: LD_ADDR_EXP 118
40006: PUSH
40007: EMPTY
40008: ST_TO_ADDR
// mc_crates_collector := [ ] ;
40009: LD_ADDR_EXP 119
40013: PUSH
40014: EMPTY
40015: ST_TO_ADDR
// mc_crates_area := [ ] ;
40016: LD_ADDR_EXP 120
40020: PUSH
40021: EMPTY
40022: ST_TO_ADDR
// mc_vehicles := [ ] ;
40023: LD_ADDR_EXP 121
40027: PUSH
40028: EMPTY
40029: ST_TO_ADDR
// mc_attack := [ ] ;
40030: LD_ADDR_EXP 122
40034: PUSH
40035: EMPTY
40036: ST_TO_ADDR
// mc_produce := [ ] ;
40037: LD_ADDR_EXP 123
40041: PUSH
40042: EMPTY
40043: ST_TO_ADDR
// mc_defender := [ ] ;
40044: LD_ADDR_EXP 124
40048: PUSH
40049: EMPTY
40050: ST_TO_ADDR
// mc_parking := [ ] ;
40051: LD_ADDR_EXP 126
40055: PUSH
40056: EMPTY
40057: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
40058: LD_ADDR_EXP 112
40062: PUSH
40063: EMPTY
40064: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
40065: LD_ADDR_EXP 114
40069: PUSH
40070: EMPTY
40071: ST_TO_ADDR
// mc_scan := [ ] ;
40072: LD_ADDR_EXP 125
40076: PUSH
40077: EMPTY
40078: ST_TO_ADDR
// mc_scan_area := [ ] ;
40079: LD_ADDR_EXP 127
40083: PUSH
40084: EMPTY
40085: ST_TO_ADDR
// mc_tech := [ ] ;
40086: LD_ADDR_EXP 129
40090: PUSH
40091: EMPTY
40092: ST_TO_ADDR
// mc_class := [ ] ;
40093: LD_ADDR_EXP 143
40097: PUSH
40098: EMPTY
40099: ST_TO_ADDR
// mc_class_case_use := [ ] ;
40100: LD_ADDR_EXP 144
40104: PUSH
40105: EMPTY
40106: ST_TO_ADDR
// mc_is_defending := [ ] ;
40107: LD_ADDR_EXP 145
40111: PUSH
40112: EMPTY
40113: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
40114: LD_ADDR_EXP 136
40118: PUSH
40119: EMPTY
40120: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
40121: LD_ADDR_EXP 146
40125: PUSH
40126: LD_INT 0
40128: ST_TO_ADDR
// end ;
40129: LD_VAR 0 1
40133: RET
// export function MC_Kill ( base ) ; begin
40134: LD_INT 0
40136: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
40137: LD_ADDR_EXP 102
40141: PUSH
40142: LD_EXP 102
40146: PPUSH
40147: LD_VAR 0 1
40151: PPUSH
40152: EMPTY
40153: PPUSH
40154: CALL_OW 1
40158: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
40159: LD_ADDR_EXP 103
40163: PUSH
40164: LD_EXP 103
40168: PPUSH
40169: LD_VAR 0 1
40173: PPUSH
40174: EMPTY
40175: PPUSH
40176: CALL_OW 1
40180: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
40181: LD_ADDR_EXP 104
40185: PUSH
40186: LD_EXP 104
40190: PPUSH
40191: LD_VAR 0 1
40195: PPUSH
40196: EMPTY
40197: PPUSH
40198: CALL_OW 1
40202: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
40203: LD_ADDR_EXP 105
40207: PUSH
40208: LD_EXP 105
40212: PPUSH
40213: LD_VAR 0 1
40217: PPUSH
40218: EMPTY
40219: PPUSH
40220: CALL_OW 1
40224: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
40225: LD_ADDR_EXP 106
40229: PUSH
40230: LD_EXP 106
40234: PPUSH
40235: LD_VAR 0 1
40239: PPUSH
40240: EMPTY
40241: PPUSH
40242: CALL_OW 1
40246: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
40247: LD_ADDR_EXP 107
40251: PUSH
40252: LD_EXP 107
40256: PPUSH
40257: LD_VAR 0 1
40261: PPUSH
40262: EMPTY
40263: PPUSH
40264: CALL_OW 1
40268: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
40269: LD_ADDR_EXP 108
40273: PUSH
40274: LD_EXP 108
40278: PPUSH
40279: LD_VAR 0 1
40283: PPUSH
40284: EMPTY
40285: PPUSH
40286: CALL_OW 1
40290: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
40291: LD_ADDR_EXP 109
40295: PUSH
40296: LD_EXP 109
40300: PPUSH
40301: LD_VAR 0 1
40305: PPUSH
40306: EMPTY
40307: PPUSH
40308: CALL_OW 1
40312: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
40313: LD_ADDR_EXP 110
40317: PUSH
40318: LD_EXP 110
40322: PPUSH
40323: LD_VAR 0 1
40327: PPUSH
40328: EMPTY
40329: PPUSH
40330: CALL_OW 1
40334: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
40335: LD_ADDR_EXP 111
40339: PUSH
40340: LD_EXP 111
40344: PPUSH
40345: LD_VAR 0 1
40349: PPUSH
40350: EMPTY
40351: PPUSH
40352: CALL_OW 1
40356: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
40357: LD_ADDR_EXP 112
40361: PUSH
40362: LD_EXP 112
40366: PPUSH
40367: LD_VAR 0 1
40371: PPUSH
40372: EMPTY
40373: PPUSH
40374: CALL_OW 1
40378: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
40379: LD_ADDR_EXP 113
40383: PUSH
40384: LD_EXP 113
40388: PPUSH
40389: LD_VAR 0 1
40393: PPUSH
40394: LD_INT 0
40396: PPUSH
40397: CALL_OW 1
40401: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
40402: LD_ADDR_EXP 114
40406: PUSH
40407: LD_EXP 114
40411: PPUSH
40412: LD_VAR 0 1
40416: PPUSH
40417: EMPTY
40418: PPUSH
40419: CALL_OW 1
40423: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
40424: LD_ADDR_EXP 115
40428: PUSH
40429: LD_EXP 115
40433: PPUSH
40434: LD_VAR 0 1
40438: PPUSH
40439: EMPTY
40440: PPUSH
40441: CALL_OW 1
40445: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
40446: LD_ADDR_EXP 116
40450: PUSH
40451: LD_EXP 116
40455: PPUSH
40456: LD_VAR 0 1
40460: PPUSH
40461: EMPTY
40462: PPUSH
40463: CALL_OW 1
40467: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
40468: LD_ADDR_EXP 117
40472: PUSH
40473: LD_EXP 117
40477: PPUSH
40478: LD_VAR 0 1
40482: PPUSH
40483: EMPTY
40484: PPUSH
40485: CALL_OW 1
40489: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
40490: LD_ADDR_EXP 118
40494: PUSH
40495: LD_EXP 118
40499: PPUSH
40500: LD_VAR 0 1
40504: PPUSH
40505: EMPTY
40506: PPUSH
40507: CALL_OW 1
40511: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
40512: LD_ADDR_EXP 119
40516: PUSH
40517: LD_EXP 119
40521: PPUSH
40522: LD_VAR 0 1
40526: PPUSH
40527: EMPTY
40528: PPUSH
40529: CALL_OW 1
40533: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
40534: LD_ADDR_EXP 120
40538: PUSH
40539: LD_EXP 120
40543: PPUSH
40544: LD_VAR 0 1
40548: PPUSH
40549: EMPTY
40550: PPUSH
40551: CALL_OW 1
40555: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
40556: LD_ADDR_EXP 121
40560: PUSH
40561: LD_EXP 121
40565: PPUSH
40566: LD_VAR 0 1
40570: PPUSH
40571: EMPTY
40572: PPUSH
40573: CALL_OW 1
40577: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
40578: LD_ADDR_EXP 122
40582: PUSH
40583: LD_EXP 122
40587: PPUSH
40588: LD_VAR 0 1
40592: PPUSH
40593: EMPTY
40594: PPUSH
40595: CALL_OW 1
40599: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
40600: LD_ADDR_EXP 123
40604: PUSH
40605: LD_EXP 123
40609: PPUSH
40610: LD_VAR 0 1
40614: PPUSH
40615: EMPTY
40616: PPUSH
40617: CALL_OW 1
40621: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
40622: LD_ADDR_EXP 124
40626: PUSH
40627: LD_EXP 124
40631: PPUSH
40632: LD_VAR 0 1
40636: PPUSH
40637: EMPTY
40638: PPUSH
40639: CALL_OW 1
40643: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
40644: LD_ADDR_EXP 125
40648: PUSH
40649: LD_EXP 125
40653: PPUSH
40654: LD_VAR 0 1
40658: PPUSH
40659: EMPTY
40660: PPUSH
40661: CALL_OW 1
40665: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
40666: LD_ADDR_EXP 126
40670: PUSH
40671: LD_EXP 126
40675: PPUSH
40676: LD_VAR 0 1
40680: PPUSH
40681: EMPTY
40682: PPUSH
40683: CALL_OW 1
40687: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
40688: LD_ADDR_EXP 127
40692: PUSH
40693: LD_EXP 127
40697: PPUSH
40698: LD_VAR 0 1
40702: PPUSH
40703: EMPTY
40704: PPUSH
40705: CALL_OW 1
40709: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40710: LD_ADDR_EXP 129
40714: PUSH
40715: LD_EXP 129
40719: PPUSH
40720: LD_VAR 0 1
40724: PPUSH
40725: EMPTY
40726: PPUSH
40727: CALL_OW 1
40731: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40732: LD_ADDR_EXP 131
40736: PUSH
40737: LD_EXP 131
40741: PPUSH
40742: LD_VAR 0 1
40746: PPUSH
40747: EMPTY
40748: PPUSH
40749: CALL_OW 1
40753: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40754: LD_ADDR_EXP 132
40758: PUSH
40759: LD_EXP 132
40763: PPUSH
40764: LD_VAR 0 1
40768: PPUSH
40769: EMPTY
40770: PPUSH
40771: CALL_OW 1
40775: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40776: LD_ADDR_EXP 133
40780: PUSH
40781: LD_EXP 133
40785: PPUSH
40786: LD_VAR 0 1
40790: PPUSH
40791: EMPTY
40792: PPUSH
40793: CALL_OW 1
40797: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40798: LD_ADDR_EXP 134
40802: PUSH
40803: LD_EXP 134
40807: PPUSH
40808: LD_VAR 0 1
40812: PPUSH
40813: EMPTY
40814: PPUSH
40815: CALL_OW 1
40819: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40820: LD_ADDR_EXP 135
40824: PUSH
40825: LD_EXP 135
40829: PPUSH
40830: LD_VAR 0 1
40834: PPUSH
40835: EMPTY
40836: PPUSH
40837: CALL_OW 1
40841: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40842: LD_ADDR_EXP 136
40846: PUSH
40847: LD_EXP 136
40851: PPUSH
40852: LD_VAR 0 1
40856: PPUSH
40857: EMPTY
40858: PPUSH
40859: CALL_OW 1
40863: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40864: LD_ADDR_EXP 137
40868: PUSH
40869: LD_EXP 137
40873: PPUSH
40874: LD_VAR 0 1
40878: PPUSH
40879: EMPTY
40880: PPUSH
40881: CALL_OW 1
40885: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40886: LD_ADDR_EXP 138
40890: PUSH
40891: LD_EXP 138
40895: PPUSH
40896: LD_VAR 0 1
40900: PPUSH
40901: EMPTY
40902: PPUSH
40903: CALL_OW 1
40907: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40908: LD_ADDR_EXP 139
40912: PUSH
40913: LD_EXP 139
40917: PPUSH
40918: LD_VAR 0 1
40922: PPUSH
40923: EMPTY
40924: PPUSH
40925: CALL_OW 1
40929: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40930: LD_ADDR_EXP 140
40934: PUSH
40935: LD_EXP 140
40939: PPUSH
40940: LD_VAR 0 1
40944: PPUSH
40945: EMPTY
40946: PPUSH
40947: CALL_OW 1
40951: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40952: LD_ADDR_EXP 141
40956: PUSH
40957: LD_EXP 141
40961: PPUSH
40962: LD_VAR 0 1
40966: PPUSH
40967: EMPTY
40968: PPUSH
40969: CALL_OW 1
40973: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40974: LD_ADDR_EXP 142
40978: PUSH
40979: LD_EXP 142
40983: PPUSH
40984: LD_VAR 0 1
40988: PPUSH
40989: EMPTY
40990: PPUSH
40991: CALL_OW 1
40995: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40996: LD_ADDR_EXP 143
41000: PUSH
41001: LD_EXP 143
41005: PPUSH
41006: LD_VAR 0 1
41010: PPUSH
41011: EMPTY
41012: PPUSH
41013: CALL_OW 1
41017: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41018: LD_ADDR_EXP 144
41022: PUSH
41023: LD_EXP 144
41027: PPUSH
41028: LD_VAR 0 1
41032: PPUSH
41033: LD_INT 0
41035: PPUSH
41036: CALL_OW 1
41040: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
41041: LD_ADDR_EXP 145
41045: PUSH
41046: LD_EXP 145
41050: PPUSH
41051: LD_VAR 0 1
41055: PPUSH
41056: LD_INT 0
41058: PPUSH
41059: CALL_OW 1
41063: ST_TO_ADDR
// end ;
41064: LD_VAR 0 2
41068: RET
// export function MC_Add ( side , units ) ; var base ; begin
41069: LD_INT 0
41071: PPUSH
41072: PPUSH
// base := mc_bases + 1 ;
41073: LD_ADDR_VAR 0 4
41077: PUSH
41078: LD_EXP 102
41082: PUSH
41083: LD_INT 1
41085: PLUS
41086: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
41087: LD_ADDR_EXP 128
41091: PUSH
41092: LD_EXP 128
41096: PPUSH
41097: LD_VAR 0 4
41101: PPUSH
41102: LD_VAR 0 1
41106: PPUSH
41107: CALL_OW 1
41111: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
41112: LD_ADDR_EXP 102
41116: PUSH
41117: LD_EXP 102
41121: PPUSH
41122: LD_VAR 0 4
41126: PPUSH
41127: LD_VAR 0 2
41131: PPUSH
41132: CALL_OW 1
41136: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
41137: LD_ADDR_EXP 103
41141: PUSH
41142: LD_EXP 103
41146: PPUSH
41147: LD_VAR 0 4
41151: PPUSH
41152: EMPTY
41153: PPUSH
41154: CALL_OW 1
41158: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
41159: LD_ADDR_EXP 104
41163: PUSH
41164: LD_EXP 104
41168: PPUSH
41169: LD_VAR 0 4
41173: PPUSH
41174: EMPTY
41175: PPUSH
41176: CALL_OW 1
41180: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
41181: LD_ADDR_EXP 105
41185: PUSH
41186: LD_EXP 105
41190: PPUSH
41191: LD_VAR 0 4
41195: PPUSH
41196: EMPTY
41197: PPUSH
41198: CALL_OW 1
41202: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
41203: LD_ADDR_EXP 106
41207: PUSH
41208: LD_EXP 106
41212: PPUSH
41213: LD_VAR 0 4
41217: PPUSH
41218: EMPTY
41219: PPUSH
41220: CALL_OW 1
41224: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
41225: LD_ADDR_EXP 107
41229: PUSH
41230: LD_EXP 107
41234: PPUSH
41235: LD_VAR 0 4
41239: PPUSH
41240: EMPTY
41241: PPUSH
41242: CALL_OW 1
41246: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
41247: LD_ADDR_EXP 108
41251: PUSH
41252: LD_EXP 108
41256: PPUSH
41257: LD_VAR 0 4
41261: PPUSH
41262: EMPTY
41263: PPUSH
41264: CALL_OW 1
41268: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
41269: LD_ADDR_EXP 109
41273: PUSH
41274: LD_EXP 109
41278: PPUSH
41279: LD_VAR 0 4
41283: PPUSH
41284: EMPTY
41285: PPUSH
41286: CALL_OW 1
41290: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
41291: LD_ADDR_EXP 110
41295: PUSH
41296: LD_EXP 110
41300: PPUSH
41301: LD_VAR 0 4
41305: PPUSH
41306: EMPTY
41307: PPUSH
41308: CALL_OW 1
41312: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
41313: LD_ADDR_EXP 111
41317: PUSH
41318: LD_EXP 111
41322: PPUSH
41323: LD_VAR 0 4
41327: PPUSH
41328: EMPTY
41329: PPUSH
41330: CALL_OW 1
41334: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
41335: LD_ADDR_EXP 112
41339: PUSH
41340: LD_EXP 112
41344: PPUSH
41345: LD_VAR 0 4
41349: PPUSH
41350: EMPTY
41351: PPUSH
41352: CALL_OW 1
41356: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
41357: LD_ADDR_EXP 113
41361: PUSH
41362: LD_EXP 113
41366: PPUSH
41367: LD_VAR 0 4
41371: PPUSH
41372: LD_INT 0
41374: PPUSH
41375: CALL_OW 1
41379: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
41380: LD_ADDR_EXP 114
41384: PUSH
41385: LD_EXP 114
41389: PPUSH
41390: LD_VAR 0 4
41394: PPUSH
41395: EMPTY
41396: PPUSH
41397: CALL_OW 1
41401: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
41402: LD_ADDR_EXP 115
41406: PUSH
41407: LD_EXP 115
41411: PPUSH
41412: LD_VAR 0 4
41416: PPUSH
41417: EMPTY
41418: PPUSH
41419: CALL_OW 1
41423: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
41424: LD_ADDR_EXP 116
41428: PUSH
41429: LD_EXP 116
41433: PPUSH
41434: LD_VAR 0 4
41438: PPUSH
41439: EMPTY
41440: PPUSH
41441: CALL_OW 1
41445: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
41446: LD_ADDR_EXP 117
41450: PUSH
41451: LD_EXP 117
41455: PPUSH
41456: LD_VAR 0 4
41460: PPUSH
41461: EMPTY
41462: PPUSH
41463: CALL_OW 1
41467: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
41468: LD_ADDR_EXP 118
41472: PUSH
41473: LD_EXP 118
41477: PPUSH
41478: LD_VAR 0 4
41482: PPUSH
41483: EMPTY
41484: PPUSH
41485: CALL_OW 1
41489: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
41490: LD_ADDR_EXP 119
41494: PUSH
41495: LD_EXP 119
41499: PPUSH
41500: LD_VAR 0 4
41504: PPUSH
41505: EMPTY
41506: PPUSH
41507: CALL_OW 1
41511: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
41512: LD_ADDR_EXP 120
41516: PUSH
41517: LD_EXP 120
41521: PPUSH
41522: LD_VAR 0 4
41526: PPUSH
41527: EMPTY
41528: PPUSH
41529: CALL_OW 1
41533: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
41534: LD_ADDR_EXP 121
41538: PUSH
41539: LD_EXP 121
41543: PPUSH
41544: LD_VAR 0 4
41548: PPUSH
41549: EMPTY
41550: PPUSH
41551: CALL_OW 1
41555: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
41556: LD_ADDR_EXP 122
41560: PUSH
41561: LD_EXP 122
41565: PPUSH
41566: LD_VAR 0 4
41570: PPUSH
41571: EMPTY
41572: PPUSH
41573: CALL_OW 1
41577: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
41578: LD_ADDR_EXP 123
41582: PUSH
41583: LD_EXP 123
41587: PPUSH
41588: LD_VAR 0 4
41592: PPUSH
41593: EMPTY
41594: PPUSH
41595: CALL_OW 1
41599: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
41600: LD_ADDR_EXP 124
41604: PUSH
41605: LD_EXP 124
41609: PPUSH
41610: LD_VAR 0 4
41614: PPUSH
41615: EMPTY
41616: PPUSH
41617: CALL_OW 1
41621: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
41622: LD_ADDR_EXP 125
41626: PUSH
41627: LD_EXP 125
41631: PPUSH
41632: LD_VAR 0 4
41636: PPUSH
41637: EMPTY
41638: PPUSH
41639: CALL_OW 1
41643: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
41644: LD_ADDR_EXP 126
41648: PUSH
41649: LD_EXP 126
41653: PPUSH
41654: LD_VAR 0 4
41658: PPUSH
41659: EMPTY
41660: PPUSH
41661: CALL_OW 1
41665: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
41666: LD_ADDR_EXP 127
41670: PUSH
41671: LD_EXP 127
41675: PPUSH
41676: LD_VAR 0 4
41680: PPUSH
41681: EMPTY
41682: PPUSH
41683: CALL_OW 1
41687: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
41688: LD_ADDR_EXP 129
41692: PUSH
41693: LD_EXP 129
41697: PPUSH
41698: LD_VAR 0 4
41702: PPUSH
41703: EMPTY
41704: PPUSH
41705: CALL_OW 1
41709: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
41710: LD_ADDR_EXP 131
41714: PUSH
41715: LD_EXP 131
41719: PPUSH
41720: LD_VAR 0 4
41724: PPUSH
41725: EMPTY
41726: PPUSH
41727: CALL_OW 1
41731: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
41732: LD_ADDR_EXP 132
41736: PUSH
41737: LD_EXP 132
41741: PPUSH
41742: LD_VAR 0 4
41746: PPUSH
41747: EMPTY
41748: PPUSH
41749: CALL_OW 1
41753: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
41754: LD_ADDR_EXP 133
41758: PUSH
41759: LD_EXP 133
41763: PPUSH
41764: LD_VAR 0 4
41768: PPUSH
41769: EMPTY
41770: PPUSH
41771: CALL_OW 1
41775: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
41776: LD_ADDR_EXP 134
41780: PUSH
41781: LD_EXP 134
41785: PPUSH
41786: LD_VAR 0 4
41790: PPUSH
41791: EMPTY
41792: PPUSH
41793: CALL_OW 1
41797: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
41798: LD_ADDR_EXP 135
41802: PUSH
41803: LD_EXP 135
41807: PPUSH
41808: LD_VAR 0 4
41812: PPUSH
41813: EMPTY
41814: PPUSH
41815: CALL_OW 1
41819: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
41820: LD_ADDR_EXP 136
41824: PUSH
41825: LD_EXP 136
41829: PPUSH
41830: LD_VAR 0 4
41834: PPUSH
41835: EMPTY
41836: PPUSH
41837: CALL_OW 1
41841: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
41842: LD_ADDR_EXP 137
41846: PUSH
41847: LD_EXP 137
41851: PPUSH
41852: LD_VAR 0 4
41856: PPUSH
41857: EMPTY
41858: PPUSH
41859: CALL_OW 1
41863: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
41864: LD_ADDR_EXP 138
41868: PUSH
41869: LD_EXP 138
41873: PPUSH
41874: LD_VAR 0 4
41878: PPUSH
41879: EMPTY
41880: PPUSH
41881: CALL_OW 1
41885: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
41886: LD_ADDR_EXP 139
41890: PUSH
41891: LD_EXP 139
41895: PPUSH
41896: LD_VAR 0 4
41900: PPUSH
41901: EMPTY
41902: PPUSH
41903: CALL_OW 1
41907: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
41908: LD_ADDR_EXP 140
41912: PUSH
41913: LD_EXP 140
41917: PPUSH
41918: LD_VAR 0 4
41922: PPUSH
41923: EMPTY
41924: PPUSH
41925: CALL_OW 1
41929: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
41930: LD_ADDR_EXP 141
41934: PUSH
41935: LD_EXP 141
41939: PPUSH
41940: LD_VAR 0 4
41944: PPUSH
41945: EMPTY
41946: PPUSH
41947: CALL_OW 1
41951: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
41952: LD_ADDR_EXP 142
41956: PUSH
41957: LD_EXP 142
41961: PPUSH
41962: LD_VAR 0 4
41966: PPUSH
41967: EMPTY
41968: PPUSH
41969: CALL_OW 1
41973: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
41974: LD_ADDR_EXP 143
41978: PUSH
41979: LD_EXP 143
41983: PPUSH
41984: LD_VAR 0 4
41988: PPUSH
41989: EMPTY
41990: PPUSH
41991: CALL_OW 1
41995: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
41996: LD_ADDR_EXP 144
42000: PUSH
42001: LD_EXP 144
42005: PPUSH
42006: LD_VAR 0 4
42010: PPUSH
42011: LD_INT 0
42013: PPUSH
42014: CALL_OW 1
42018: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
42019: LD_ADDR_EXP 145
42023: PUSH
42024: LD_EXP 145
42028: PPUSH
42029: LD_VAR 0 4
42033: PPUSH
42034: LD_INT 0
42036: PPUSH
42037: CALL_OW 1
42041: ST_TO_ADDR
// result := base ;
42042: LD_ADDR_VAR 0 3
42046: PUSH
42047: LD_VAR 0 4
42051: ST_TO_ADDR
// end ;
42052: LD_VAR 0 3
42056: RET
// export function MC_Start ( ) ; var i ; begin
42057: LD_INT 0
42059: PPUSH
42060: PPUSH
// for i = 1 to mc_bases do
42061: LD_ADDR_VAR 0 2
42065: PUSH
42066: DOUBLE
42067: LD_INT 1
42069: DEC
42070: ST_TO_ADDR
42071: LD_EXP 102
42075: PUSH
42076: FOR_TO
42077: IFFALSE 43177
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
42079: LD_ADDR_EXP 102
42083: PUSH
42084: LD_EXP 102
42088: PPUSH
42089: LD_VAR 0 2
42093: PPUSH
42094: LD_EXP 102
42098: PUSH
42099: LD_VAR 0 2
42103: ARRAY
42104: PUSH
42105: LD_INT 0
42107: DIFF
42108: PPUSH
42109: CALL_OW 1
42113: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
42114: LD_ADDR_EXP 103
42118: PUSH
42119: LD_EXP 103
42123: PPUSH
42124: LD_VAR 0 2
42128: PPUSH
42129: EMPTY
42130: PPUSH
42131: CALL_OW 1
42135: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
42136: LD_ADDR_EXP 104
42140: PUSH
42141: LD_EXP 104
42145: PPUSH
42146: LD_VAR 0 2
42150: PPUSH
42151: EMPTY
42152: PPUSH
42153: CALL_OW 1
42157: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
42158: LD_ADDR_EXP 105
42162: PUSH
42163: LD_EXP 105
42167: PPUSH
42168: LD_VAR 0 2
42172: PPUSH
42173: EMPTY
42174: PPUSH
42175: CALL_OW 1
42179: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
42180: LD_ADDR_EXP 106
42184: PUSH
42185: LD_EXP 106
42189: PPUSH
42190: LD_VAR 0 2
42194: PPUSH
42195: EMPTY
42196: PUSH
42197: EMPTY
42198: PUSH
42199: EMPTY
42200: LIST
42201: LIST
42202: PPUSH
42203: CALL_OW 1
42207: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
42208: LD_ADDR_EXP 107
42212: PUSH
42213: LD_EXP 107
42217: PPUSH
42218: LD_VAR 0 2
42222: PPUSH
42223: EMPTY
42224: PPUSH
42225: CALL_OW 1
42229: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
42230: LD_ADDR_EXP 134
42234: PUSH
42235: LD_EXP 134
42239: PPUSH
42240: LD_VAR 0 2
42244: PPUSH
42245: EMPTY
42246: PPUSH
42247: CALL_OW 1
42251: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
42252: LD_ADDR_EXP 108
42256: PUSH
42257: LD_EXP 108
42261: PPUSH
42262: LD_VAR 0 2
42266: PPUSH
42267: EMPTY
42268: PPUSH
42269: CALL_OW 1
42273: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
42274: LD_ADDR_EXP 109
42278: PUSH
42279: LD_EXP 109
42283: PPUSH
42284: LD_VAR 0 2
42288: PPUSH
42289: EMPTY
42290: PPUSH
42291: CALL_OW 1
42295: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
42296: LD_ADDR_EXP 110
42300: PUSH
42301: LD_EXP 110
42305: PPUSH
42306: LD_VAR 0 2
42310: PPUSH
42311: LD_EXP 102
42315: PUSH
42316: LD_VAR 0 2
42320: ARRAY
42321: PPUSH
42322: LD_INT 2
42324: PUSH
42325: LD_INT 30
42327: PUSH
42328: LD_INT 32
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 30
42337: PUSH
42338: LD_INT 33
42340: PUSH
42341: EMPTY
42342: LIST
42343: LIST
42344: PUSH
42345: EMPTY
42346: LIST
42347: LIST
42348: LIST
42349: PPUSH
42350: CALL_OW 72
42354: PPUSH
42355: CALL_OW 1
42359: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
42360: LD_ADDR_EXP 111
42364: PUSH
42365: LD_EXP 111
42369: PPUSH
42370: LD_VAR 0 2
42374: PPUSH
42375: LD_EXP 102
42379: PUSH
42380: LD_VAR 0 2
42384: ARRAY
42385: PPUSH
42386: LD_INT 2
42388: PUSH
42389: LD_INT 30
42391: PUSH
42392: LD_INT 32
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: PUSH
42399: LD_INT 30
42401: PUSH
42402: LD_INT 31
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 58
42416: PUSH
42417: EMPTY
42418: LIST
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PPUSH
42424: CALL_OW 72
42428: PPUSH
42429: CALL_OW 1
42433: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
42434: LD_ADDR_EXP 112
42438: PUSH
42439: LD_EXP 112
42443: PPUSH
42444: LD_VAR 0 2
42448: PPUSH
42449: EMPTY
42450: PPUSH
42451: CALL_OW 1
42455: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
42456: LD_ADDR_EXP 116
42460: PUSH
42461: LD_EXP 116
42465: PPUSH
42466: LD_VAR 0 2
42470: PPUSH
42471: EMPTY
42472: PPUSH
42473: CALL_OW 1
42477: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
42478: LD_ADDR_EXP 115
42482: PUSH
42483: LD_EXP 115
42487: PPUSH
42488: LD_VAR 0 2
42492: PPUSH
42493: EMPTY
42494: PPUSH
42495: CALL_OW 1
42499: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
42500: LD_ADDR_EXP 117
42504: PUSH
42505: LD_EXP 117
42509: PPUSH
42510: LD_VAR 0 2
42514: PPUSH
42515: EMPTY
42516: PPUSH
42517: CALL_OW 1
42521: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
42522: LD_ADDR_EXP 118
42526: PUSH
42527: LD_EXP 118
42531: PPUSH
42532: LD_VAR 0 2
42536: PPUSH
42537: EMPTY
42538: PPUSH
42539: CALL_OW 1
42543: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
42544: LD_ADDR_EXP 119
42548: PUSH
42549: LD_EXP 119
42553: PPUSH
42554: LD_VAR 0 2
42558: PPUSH
42559: EMPTY
42560: PPUSH
42561: CALL_OW 1
42565: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
42566: LD_ADDR_EXP 120
42570: PUSH
42571: LD_EXP 120
42575: PPUSH
42576: LD_VAR 0 2
42580: PPUSH
42581: EMPTY
42582: PPUSH
42583: CALL_OW 1
42587: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
42588: LD_ADDR_EXP 121
42592: PUSH
42593: LD_EXP 121
42597: PPUSH
42598: LD_VAR 0 2
42602: PPUSH
42603: EMPTY
42604: PPUSH
42605: CALL_OW 1
42609: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
42610: LD_ADDR_EXP 122
42614: PUSH
42615: LD_EXP 122
42619: PPUSH
42620: LD_VAR 0 2
42624: PPUSH
42625: EMPTY
42626: PPUSH
42627: CALL_OW 1
42631: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
42632: LD_ADDR_EXP 123
42636: PUSH
42637: LD_EXP 123
42641: PPUSH
42642: LD_VAR 0 2
42646: PPUSH
42647: EMPTY
42648: PPUSH
42649: CALL_OW 1
42653: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
42654: LD_ADDR_EXP 124
42658: PUSH
42659: LD_EXP 124
42663: PPUSH
42664: LD_VAR 0 2
42668: PPUSH
42669: EMPTY
42670: PPUSH
42671: CALL_OW 1
42675: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
42676: LD_ADDR_EXP 113
42680: PUSH
42681: LD_EXP 113
42685: PPUSH
42686: LD_VAR 0 2
42690: PPUSH
42691: LD_INT 0
42693: PPUSH
42694: CALL_OW 1
42698: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
42699: LD_ADDR_EXP 126
42703: PUSH
42704: LD_EXP 126
42708: PPUSH
42709: LD_VAR 0 2
42713: PPUSH
42714: LD_INT 0
42716: PPUSH
42717: CALL_OW 1
42721: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
42722: LD_ADDR_EXP 114
42726: PUSH
42727: LD_EXP 114
42731: PPUSH
42732: LD_VAR 0 2
42736: PPUSH
42737: EMPTY
42738: PPUSH
42739: CALL_OW 1
42743: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
42744: LD_ADDR_EXP 125
42748: PUSH
42749: LD_EXP 125
42753: PPUSH
42754: LD_VAR 0 2
42758: PPUSH
42759: LD_INT 0
42761: PPUSH
42762: CALL_OW 1
42766: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
42767: LD_ADDR_EXP 127
42771: PUSH
42772: LD_EXP 127
42776: PPUSH
42777: LD_VAR 0 2
42781: PPUSH
42782: EMPTY
42783: PPUSH
42784: CALL_OW 1
42788: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
42789: LD_ADDR_EXP 130
42793: PUSH
42794: LD_EXP 130
42798: PPUSH
42799: LD_VAR 0 2
42803: PPUSH
42804: LD_INT 0
42806: PPUSH
42807: CALL_OW 1
42811: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
42812: LD_ADDR_EXP 131
42816: PUSH
42817: LD_EXP 131
42821: PPUSH
42822: LD_VAR 0 2
42826: PPUSH
42827: EMPTY
42828: PPUSH
42829: CALL_OW 1
42833: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
42834: LD_ADDR_EXP 132
42838: PUSH
42839: LD_EXP 132
42843: PPUSH
42844: LD_VAR 0 2
42848: PPUSH
42849: EMPTY
42850: PPUSH
42851: CALL_OW 1
42855: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
42856: LD_ADDR_EXP 133
42860: PUSH
42861: LD_EXP 133
42865: PPUSH
42866: LD_VAR 0 2
42870: PPUSH
42871: EMPTY
42872: PPUSH
42873: CALL_OW 1
42877: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
42878: LD_ADDR_EXP 135
42882: PUSH
42883: LD_EXP 135
42887: PPUSH
42888: LD_VAR 0 2
42892: PPUSH
42893: LD_EXP 102
42897: PUSH
42898: LD_VAR 0 2
42902: ARRAY
42903: PPUSH
42904: LD_INT 2
42906: PUSH
42907: LD_INT 30
42909: PUSH
42910: LD_INT 6
42912: PUSH
42913: EMPTY
42914: LIST
42915: LIST
42916: PUSH
42917: LD_INT 30
42919: PUSH
42920: LD_INT 7
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: LD_INT 30
42929: PUSH
42930: LD_INT 8
42932: PUSH
42933: EMPTY
42934: LIST
42935: LIST
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: LIST
42941: LIST
42942: PPUSH
42943: CALL_OW 72
42947: PPUSH
42948: CALL_OW 1
42952: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
42953: LD_ADDR_EXP 136
42957: PUSH
42958: LD_EXP 136
42962: PPUSH
42963: LD_VAR 0 2
42967: PPUSH
42968: EMPTY
42969: PPUSH
42970: CALL_OW 1
42974: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
42975: LD_ADDR_EXP 137
42979: PUSH
42980: LD_EXP 137
42984: PPUSH
42985: LD_VAR 0 2
42989: PPUSH
42990: EMPTY
42991: PPUSH
42992: CALL_OW 1
42996: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
42997: LD_ADDR_EXP 138
43001: PUSH
43002: LD_EXP 138
43006: PPUSH
43007: LD_VAR 0 2
43011: PPUSH
43012: EMPTY
43013: PPUSH
43014: CALL_OW 1
43018: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
43019: LD_ADDR_EXP 139
43023: PUSH
43024: LD_EXP 139
43028: PPUSH
43029: LD_VAR 0 2
43033: PPUSH
43034: EMPTY
43035: PPUSH
43036: CALL_OW 1
43040: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
43041: LD_ADDR_EXP 140
43045: PUSH
43046: LD_EXP 140
43050: PPUSH
43051: LD_VAR 0 2
43055: PPUSH
43056: EMPTY
43057: PPUSH
43058: CALL_OW 1
43062: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
43063: LD_ADDR_EXP 141
43067: PUSH
43068: LD_EXP 141
43072: PPUSH
43073: LD_VAR 0 2
43077: PPUSH
43078: EMPTY
43079: PPUSH
43080: CALL_OW 1
43084: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
43085: LD_ADDR_EXP 142
43089: PUSH
43090: LD_EXP 142
43094: PPUSH
43095: LD_VAR 0 2
43099: PPUSH
43100: EMPTY
43101: PPUSH
43102: CALL_OW 1
43106: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
43107: LD_ADDR_EXP 143
43111: PUSH
43112: LD_EXP 143
43116: PPUSH
43117: LD_VAR 0 2
43121: PPUSH
43122: EMPTY
43123: PPUSH
43124: CALL_OW 1
43128: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
43129: LD_ADDR_EXP 144
43133: PUSH
43134: LD_EXP 144
43138: PPUSH
43139: LD_VAR 0 2
43143: PPUSH
43144: LD_INT 0
43146: PPUSH
43147: CALL_OW 1
43151: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
43152: LD_ADDR_EXP 145
43156: PUSH
43157: LD_EXP 145
43161: PPUSH
43162: LD_VAR 0 2
43166: PPUSH
43167: LD_INT 0
43169: PPUSH
43170: CALL_OW 1
43174: ST_TO_ADDR
// end ;
43175: GO 42076
43177: POP
43178: POP
// MC_InitSides ( ) ;
43179: CALL 43465 0 0
// MC_InitResearch ( ) ;
43183: CALL 43204 0 0
// CustomInitMacro ( ) ;
43187: CALL 475 0 0
// skirmish := true ;
43191: LD_ADDR_EXP 100
43195: PUSH
43196: LD_INT 1
43198: ST_TO_ADDR
// end ;
43199: LD_VAR 0 1
43203: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
43204: LD_INT 0
43206: PPUSH
43207: PPUSH
43208: PPUSH
43209: PPUSH
43210: PPUSH
43211: PPUSH
// if not mc_bases then
43212: LD_EXP 102
43216: NOT
43217: IFFALSE 43221
// exit ;
43219: GO 43460
// for i = 1 to 8 do
43221: LD_ADDR_VAR 0 2
43225: PUSH
43226: DOUBLE
43227: LD_INT 1
43229: DEC
43230: ST_TO_ADDR
43231: LD_INT 8
43233: PUSH
43234: FOR_TO
43235: IFFALSE 43261
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
43237: LD_ADDR_EXP 129
43241: PUSH
43242: LD_EXP 129
43246: PPUSH
43247: LD_VAR 0 2
43251: PPUSH
43252: EMPTY
43253: PPUSH
43254: CALL_OW 1
43258: ST_TO_ADDR
43259: GO 43234
43261: POP
43262: POP
// tmp := [ ] ;
43263: LD_ADDR_VAR 0 5
43267: PUSH
43268: EMPTY
43269: ST_TO_ADDR
// for i = 1 to mc_sides do
43270: LD_ADDR_VAR 0 2
43274: PUSH
43275: DOUBLE
43276: LD_INT 1
43278: DEC
43279: ST_TO_ADDR
43280: LD_EXP 128
43284: PUSH
43285: FOR_TO
43286: IFFALSE 43344
// if not mc_sides [ i ] in tmp then
43288: LD_EXP 128
43292: PUSH
43293: LD_VAR 0 2
43297: ARRAY
43298: PUSH
43299: LD_VAR 0 5
43303: IN
43304: NOT
43305: IFFALSE 43342
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
43307: LD_ADDR_VAR 0 5
43311: PUSH
43312: LD_VAR 0 5
43316: PPUSH
43317: LD_VAR 0 5
43321: PUSH
43322: LD_INT 1
43324: PLUS
43325: PPUSH
43326: LD_EXP 128
43330: PUSH
43331: LD_VAR 0 2
43335: ARRAY
43336: PPUSH
43337: CALL_OW 2
43341: ST_TO_ADDR
43342: GO 43285
43344: POP
43345: POP
// if not tmp then
43346: LD_VAR 0 5
43350: NOT
43351: IFFALSE 43355
// exit ;
43353: GO 43460
// for j in tmp do
43355: LD_ADDR_VAR 0 3
43359: PUSH
43360: LD_VAR 0 5
43364: PUSH
43365: FOR_IN
43366: IFFALSE 43458
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
43368: LD_ADDR_VAR 0 6
43372: PUSH
43373: LD_INT 22
43375: PUSH
43376: LD_VAR 0 3
43380: PUSH
43381: EMPTY
43382: LIST
43383: LIST
43384: PPUSH
43385: CALL_OW 69
43389: ST_TO_ADDR
// if not un then
43390: LD_VAR 0 6
43394: NOT
43395: IFFALSE 43399
// continue ;
43397: GO 43365
// nation := GetNation ( un [ 1 ] ) ;
43399: LD_ADDR_VAR 0 4
43403: PUSH
43404: LD_VAR 0 6
43408: PUSH
43409: LD_INT 1
43411: ARRAY
43412: PPUSH
43413: CALL_OW 248
43417: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
43418: LD_ADDR_EXP 129
43422: PUSH
43423: LD_EXP 129
43427: PPUSH
43428: LD_VAR 0 3
43432: PPUSH
43433: LD_VAR 0 3
43437: PPUSH
43438: LD_VAR 0 4
43442: PPUSH
43443: LD_INT 1
43445: PPUSH
43446: CALL 71086 0 3
43450: PPUSH
43451: CALL_OW 1
43455: ST_TO_ADDR
// end ;
43456: GO 43365
43458: POP
43459: POP
// end ;
43460: LD_VAR 0 1
43464: RET
// export function MC_InitSides ( ) ; var i ; begin
43465: LD_INT 0
43467: PPUSH
43468: PPUSH
// if not mc_bases then
43469: LD_EXP 102
43473: NOT
43474: IFFALSE 43478
// exit ;
43476: GO 43552
// for i = 1 to mc_bases do
43478: LD_ADDR_VAR 0 2
43482: PUSH
43483: DOUBLE
43484: LD_INT 1
43486: DEC
43487: ST_TO_ADDR
43488: LD_EXP 102
43492: PUSH
43493: FOR_TO
43494: IFFALSE 43550
// if mc_bases [ i ] then
43496: LD_EXP 102
43500: PUSH
43501: LD_VAR 0 2
43505: ARRAY
43506: IFFALSE 43548
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
43508: LD_ADDR_EXP 128
43512: PUSH
43513: LD_EXP 128
43517: PPUSH
43518: LD_VAR 0 2
43522: PPUSH
43523: LD_EXP 102
43527: PUSH
43528: LD_VAR 0 2
43532: ARRAY
43533: PUSH
43534: LD_INT 1
43536: ARRAY
43537: PPUSH
43538: CALL_OW 255
43542: PPUSH
43543: CALL_OW 1
43547: ST_TO_ADDR
43548: GO 43493
43550: POP
43551: POP
// end ;
43552: LD_VAR 0 1
43556: RET
// every 0 0$03 trigger skirmish do
43557: LD_EXP 100
43561: IFFALSE 43715
43563: GO 43565
43565: DISABLE
// begin enable ;
43566: ENABLE
// MC_CheckBuildings ( ) ;
43567: CALL 48273 0 0
// MC_CheckPeopleLife ( ) ;
43571: CALL 48434 0 0
// RaiseSailEvent ( 100 ) ;
43575: LD_INT 100
43577: PPUSH
43578: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
43582: LD_INT 103
43584: PPUSH
43585: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
43589: LD_INT 104
43591: PPUSH
43592: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
43596: LD_INT 105
43598: PPUSH
43599: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
43603: LD_INT 106
43605: PPUSH
43606: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
43610: LD_INT 107
43612: PPUSH
43613: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
43617: LD_INT 108
43619: PPUSH
43620: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
43624: LD_INT 109
43626: PPUSH
43627: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
43631: LD_INT 110
43633: PPUSH
43634: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
43638: LD_INT 111
43640: PPUSH
43641: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
43645: LD_INT 112
43647: PPUSH
43648: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
43652: LD_INT 113
43654: PPUSH
43655: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
43659: LD_INT 120
43661: PPUSH
43662: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
43666: LD_INT 121
43668: PPUSH
43669: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
43673: LD_INT 122
43675: PPUSH
43676: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
43680: LD_INT 123
43682: PPUSH
43683: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
43687: LD_INT 124
43689: PPUSH
43690: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
43694: LD_INT 125
43696: PPUSH
43697: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
43701: LD_INT 126
43703: PPUSH
43704: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
43708: LD_INT 200
43710: PPUSH
43711: CALL_OW 427
// end ;
43715: END
// on SailEvent ( event ) do begin if event < 100 then
43716: LD_VAR 0 1
43720: PUSH
43721: LD_INT 100
43723: LESS
43724: IFFALSE 43735
// CustomEvent ( event ) ;
43726: LD_VAR 0 1
43730: PPUSH
43731: CALL 38067 0 1
// if event = 100 then
43735: LD_VAR 0 1
43739: PUSH
43740: LD_INT 100
43742: EQUAL
43743: IFFALSE 43749
// MC_ClassManager ( ) ;
43745: CALL 44143 0 0
// if event = 101 then
43749: LD_VAR 0 1
43753: PUSH
43754: LD_INT 101
43756: EQUAL
43757: IFFALSE 43763
// MC_RepairBuildings ( ) ;
43759: CALL 49021 0 0
// if event = 102 then
43763: LD_VAR 0 1
43767: PUSH
43768: LD_INT 102
43770: EQUAL
43771: IFFALSE 43777
// MC_Heal ( ) ;
43773: CALL 49960 0 0
// if event = 103 then
43777: LD_VAR 0 1
43781: PUSH
43782: LD_INT 103
43784: EQUAL
43785: IFFALSE 43791
// MC_Build ( ) ;
43787: CALL 50386 0 0
// if event = 104 then
43791: LD_VAR 0 1
43795: PUSH
43796: LD_INT 104
43798: EQUAL
43799: IFFALSE 43805
// MC_TurretWeapon ( ) ;
43801: CALL 52034 0 0
// if event = 105 then
43805: LD_VAR 0 1
43809: PUSH
43810: LD_INT 105
43812: EQUAL
43813: IFFALSE 43819
// MC_BuildUpgrade ( ) ;
43815: CALL 51579 0 0
// if event = 106 then
43819: LD_VAR 0 1
43823: PUSH
43824: LD_INT 106
43826: EQUAL
43827: IFFALSE 43833
// MC_PlantMines ( ) ;
43829: CALL 52466 0 0
// if event = 107 then
43833: LD_VAR 0 1
43837: PUSH
43838: LD_INT 107
43840: EQUAL
43841: IFFALSE 43847
// MC_CollectCrates ( ) ;
43843: CALL 53276 0 0
// if event = 108 then
43847: LD_VAR 0 1
43851: PUSH
43852: LD_INT 108
43854: EQUAL
43855: IFFALSE 43861
// MC_LinkRemoteControl ( ) ;
43857: CALL 55150 0 0
// if event = 109 then
43861: LD_VAR 0 1
43865: PUSH
43866: LD_INT 109
43868: EQUAL
43869: IFFALSE 43875
// MC_ProduceVehicle ( ) ;
43871: CALL 55335 0 0
// if event = 110 then
43875: LD_VAR 0 1
43879: PUSH
43880: LD_INT 110
43882: EQUAL
43883: IFFALSE 43889
// MC_SendAttack ( ) ;
43885: CALL 55805 0 0
// if event = 111 then
43889: LD_VAR 0 1
43893: PUSH
43894: LD_INT 111
43896: EQUAL
43897: IFFALSE 43903
// MC_Defend ( ) ;
43899: CALL 55913 0 0
// if event = 112 then
43903: LD_VAR 0 1
43907: PUSH
43908: LD_INT 112
43910: EQUAL
43911: IFFALSE 43917
// MC_Research ( ) ;
43913: CALL 56813 0 0
// if event = 113 then
43917: LD_VAR 0 1
43921: PUSH
43922: LD_INT 113
43924: EQUAL
43925: IFFALSE 43931
// MC_MinesTrigger ( ) ;
43927: CALL 57953 0 0
// if event = 120 then
43931: LD_VAR 0 1
43935: PUSH
43936: LD_INT 120
43938: EQUAL
43939: IFFALSE 43945
// MC_RepairVehicle ( ) ;
43941: CALL 58054 0 0
// if event = 121 then
43945: LD_VAR 0 1
43949: PUSH
43950: LD_INT 121
43952: EQUAL
43953: IFFALSE 43959
// MC_TameApe ( ) ;
43955: CALL 58831 0 0
// if event = 122 then
43959: LD_VAR 0 1
43963: PUSH
43964: LD_INT 122
43966: EQUAL
43967: IFFALSE 43973
// MC_ChangeApeClass ( ) ;
43969: CALL 59676 0 0
// if event = 123 then
43973: LD_VAR 0 1
43977: PUSH
43978: LD_INT 123
43980: EQUAL
43981: IFFALSE 43987
// MC_Bazooka ( ) ;
43983: CALL 60332 0 0
// if event = 124 then
43987: LD_VAR 0 1
43991: PUSH
43992: LD_INT 124
43994: EQUAL
43995: IFFALSE 44001
// MC_TeleportExit ( ) ;
43997: CALL 60534 0 0
// if event = 125 then
44001: LD_VAR 0 1
44005: PUSH
44006: LD_INT 125
44008: EQUAL
44009: IFFALSE 44015
// MC_Deposits ( ) ;
44011: CALL 61191 0 0
// if event = 126 then
44015: LD_VAR 0 1
44019: PUSH
44020: LD_INT 126
44022: EQUAL
44023: IFFALSE 44029
// MC_RemoteDriver ( ) ;
44025: CALL 61824 0 0
// if event = 200 then
44029: LD_VAR 0 1
44033: PUSH
44034: LD_INT 200
44036: EQUAL
44037: IFFALSE 44043
// MC_Idle ( ) ;
44039: CALL 63759 0 0
// end ;
44043: PPOPN 1
44045: END
// export function MC_Reset ( base , tag ) ; var i ; begin
44046: LD_INT 0
44048: PPUSH
44049: PPUSH
// if not mc_bases [ base ] or not tag then
44050: LD_EXP 102
44054: PUSH
44055: LD_VAR 0 1
44059: ARRAY
44060: NOT
44061: IFTRUE 44070
44063: PUSH
44064: LD_VAR 0 2
44068: NOT
44069: OR
44070: IFFALSE 44074
// exit ;
44072: GO 44138
// for i in mc_bases [ base ] union mc_ape [ base ] do
44074: LD_ADDR_VAR 0 4
44078: PUSH
44079: LD_EXP 102
44083: PUSH
44084: LD_VAR 0 1
44088: ARRAY
44089: PUSH
44090: LD_EXP 131
44094: PUSH
44095: LD_VAR 0 1
44099: ARRAY
44100: UNION
44101: PUSH
44102: FOR_IN
44103: IFFALSE 44136
// if GetTag ( i ) = tag then
44105: LD_VAR 0 4
44109: PPUSH
44110: CALL_OW 110
44114: PUSH
44115: LD_VAR 0 2
44119: EQUAL
44120: IFFALSE 44134
// SetTag ( i , 0 ) ;
44122: LD_VAR 0 4
44126: PPUSH
44127: LD_INT 0
44129: PPUSH
44130: CALL_OW 109
44134: GO 44102
44136: POP
44137: POP
// end ;
44138: LD_VAR 0 3
44142: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
44143: LD_INT 0
44145: PPUSH
44146: PPUSH
44147: PPUSH
44148: PPUSH
44149: PPUSH
44150: PPUSH
44151: PPUSH
44152: PPUSH
// if not mc_bases then
44153: LD_EXP 102
44157: NOT
44158: IFFALSE 44162
// exit ;
44160: GO 44613
// for i = 1 to mc_bases do
44162: LD_ADDR_VAR 0 2
44166: PUSH
44167: DOUBLE
44168: LD_INT 1
44170: DEC
44171: ST_TO_ADDR
44172: LD_EXP 102
44176: PUSH
44177: FOR_TO
44178: IFFALSE 44611
// begin tmp := MC_ClassCheckReq ( i ) ;
44180: LD_ADDR_VAR 0 4
44184: PUSH
44185: LD_VAR 0 2
44189: PPUSH
44190: CALL 44618 0 1
44194: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
44195: LD_ADDR_EXP 143
44199: PUSH
44200: LD_EXP 143
44204: PPUSH
44205: LD_VAR 0 2
44209: PPUSH
44210: LD_VAR 0 4
44214: PPUSH
44215: CALL_OW 1
44219: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
44220: LD_ADDR_VAR 0 6
44224: PUSH
44225: LD_EXP 102
44229: PUSH
44230: LD_VAR 0 2
44234: ARRAY
44235: PPUSH
44236: LD_INT 2
44238: PUSH
44239: LD_INT 30
44241: PUSH
44242: LD_INT 4
44244: PUSH
44245: EMPTY
44246: LIST
44247: LIST
44248: PUSH
44249: LD_INT 30
44251: PUSH
44252: LD_INT 5
44254: PUSH
44255: EMPTY
44256: LIST
44257: LIST
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: LIST
44263: PPUSH
44264: CALL_OW 72
44268: PUSH
44269: LD_EXP 102
44273: PUSH
44274: LD_VAR 0 2
44278: ARRAY
44279: PPUSH
44280: LD_INT 2
44282: PUSH
44283: LD_INT 30
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: EMPTY
44290: LIST
44291: LIST
44292: PUSH
44293: LD_INT 30
44295: PUSH
44296: LD_INT 1
44298: PUSH
44299: EMPTY
44300: LIST
44301: LIST
44302: PUSH
44303: EMPTY
44304: LIST
44305: LIST
44306: LIST
44307: PPUSH
44308: CALL_OW 72
44312: PUSH
44313: LD_EXP 102
44317: PUSH
44318: LD_VAR 0 2
44322: ARRAY
44323: PPUSH
44324: LD_INT 30
44326: PUSH
44327: LD_INT 3
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PPUSH
44334: CALL_OW 72
44338: PUSH
44339: LD_EXP 102
44343: PUSH
44344: LD_VAR 0 2
44348: ARRAY
44349: PPUSH
44350: LD_INT 2
44352: PUSH
44353: LD_INT 30
44355: PUSH
44356: LD_INT 6
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 30
44365: PUSH
44366: LD_INT 7
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 30
44375: PUSH
44376: LD_INT 8
44378: PUSH
44379: EMPTY
44380: LIST
44381: LIST
44382: PUSH
44383: EMPTY
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: PPUSH
44389: CALL_OW 72
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: ST_TO_ADDR
// for j := 1 to 4 do
44400: LD_ADDR_VAR 0 3
44404: PUSH
44405: DOUBLE
44406: LD_INT 1
44408: DEC
44409: ST_TO_ADDR
44410: LD_INT 4
44412: PUSH
44413: FOR_TO
44414: IFFALSE 44607
// begin if not tmp [ j ] then
44416: LD_VAR 0 4
44420: PUSH
44421: LD_VAR 0 3
44425: ARRAY
44426: NOT
44427: IFFALSE 44431
// continue ;
44429: GO 44413
// for p in tmp [ j ] do
44431: LD_ADDR_VAR 0 5
44435: PUSH
44436: LD_VAR 0 4
44440: PUSH
44441: LD_VAR 0 3
44445: ARRAY
44446: PUSH
44447: FOR_IN
44448: IFFALSE 44603
// begin if not b [ j ] then
44450: LD_VAR 0 6
44454: PUSH
44455: LD_VAR 0 3
44459: ARRAY
44460: NOT
44461: IFFALSE 44465
// break ;
44463: GO 44603
// e := 0 ;
44465: LD_ADDR_VAR 0 7
44469: PUSH
44470: LD_INT 0
44472: ST_TO_ADDR
// for k in b [ j ] do
44473: LD_ADDR_VAR 0 8
44477: PUSH
44478: LD_VAR 0 6
44482: PUSH
44483: LD_VAR 0 3
44487: ARRAY
44488: PUSH
44489: FOR_IN
44490: IFFALSE 44517
// if IsNotFull ( k ) then
44492: LD_VAR 0 8
44496: PPUSH
44497: CALL 73245 0 1
44501: IFFALSE 44515
// begin e := k ;
44503: LD_ADDR_VAR 0 7
44507: PUSH
44508: LD_VAR 0 8
44512: ST_TO_ADDR
// break ;
44513: GO 44517
// end ;
44515: GO 44489
44517: POP
44518: POP
// if e and not UnitGoingToBuilding ( p , e ) then
44519: LD_VAR 0 7
44523: IFFALSE 44542
44525: PUSH
44526: LD_VAR 0 5
44530: PPUSH
44531: LD_VAR 0 7
44535: PPUSH
44536: CALL 107749 0 2
44540: NOT
44541: AND
44542: IFFALSE 44601
// begin if IsInUnit ( p ) then
44544: LD_VAR 0 5
44548: PPUSH
44549: CALL_OW 310
44553: IFFALSE 44564
// ComExitBuilding ( p ) ;
44555: LD_VAR 0 5
44559: PPUSH
44560: CALL_OW 122
// ComEnterUnit ( p , e ) ;
44564: LD_VAR 0 5
44568: PPUSH
44569: LD_VAR 0 7
44573: PPUSH
44574: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
44578: LD_VAR 0 5
44582: PPUSH
44583: LD_VAR 0 3
44587: PPUSH
44588: CALL_OW 183
// AddComExitBuilding ( p ) ;
44592: LD_VAR 0 5
44596: PPUSH
44597: CALL_OW 182
// end ; end ;
44601: GO 44447
44603: POP
44604: POP
// end ;
44605: GO 44413
44607: POP
44608: POP
// end ;
44609: GO 44177
44611: POP
44612: POP
// end ;
44613: LD_VAR 0 1
44617: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
44618: LD_INT 0
44620: PPUSH
44621: PPUSH
44622: PPUSH
44623: PPUSH
44624: PPUSH
44625: PPUSH
44626: PPUSH
44627: PPUSH
44628: PPUSH
44629: PPUSH
44630: PPUSH
44631: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
44632: LD_ADDR_VAR 0 2
44636: PUSH
44637: LD_INT 0
44639: PUSH
44640: LD_INT 0
44642: PUSH
44643: LD_INT 0
44645: PUSH
44646: LD_INT 0
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
44655: LD_VAR 0 1
44659: NOT
44660: IFTRUE 44675
44662: PUSH
44663: LD_EXP 102
44667: PUSH
44668: LD_VAR 0 1
44672: ARRAY
44673: NOT
44674: OR
44675: IFTRUE 44723
44677: PUSH
44678: LD_EXP 102
44682: PUSH
44683: LD_VAR 0 1
44687: ARRAY
44688: PPUSH
44689: LD_INT 2
44691: PUSH
44692: LD_INT 30
44694: PUSH
44695: LD_INT 0
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PUSH
44702: LD_INT 30
44704: PUSH
44705: LD_INT 1
44707: PUSH
44708: EMPTY
44709: LIST
44710: LIST
44711: PUSH
44712: EMPTY
44713: LIST
44714: LIST
44715: LIST
44716: PPUSH
44717: CALL_OW 72
44721: NOT
44722: OR
44723: IFFALSE 44727
// exit ;
44725: GO 48268
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44727: LD_ADDR_VAR 0 4
44731: PUSH
44732: LD_EXP 102
44736: PUSH
44737: LD_VAR 0 1
44741: ARRAY
44742: PPUSH
44743: LD_INT 2
44745: PUSH
44746: LD_INT 25
44748: PUSH
44749: LD_INT 1
44751: PUSH
44752: EMPTY
44753: LIST
44754: LIST
44755: PUSH
44756: LD_INT 25
44758: PUSH
44759: LD_INT 2
44761: PUSH
44762: EMPTY
44763: LIST
44764: LIST
44765: PUSH
44766: LD_INT 25
44768: PUSH
44769: LD_INT 3
44771: PUSH
44772: EMPTY
44773: LIST
44774: LIST
44775: PUSH
44776: LD_INT 25
44778: PUSH
44779: LD_INT 4
44781: PUSH
44782: EMPTY
44783: LIST
44784: LIST
44785: PUSH
44786: LD_INT 25
44788: PUSH
44789: LD_INT 5
44791: PUSH
44792: EMPTY
44793: LIST
44794: LIST
44795: PUSH
44796: LD_INT 25
44798: PUSH
44799: LD_INT 8
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: LD_INT 25
44808: PUSH
44809: LD_INT 9
44811: PUSH
44812: EMPTY
44813: LIST
44814: LIST
44815: PUSH
44816: EMPTY
44817: LIST
44818: LIST
44819: LIST
44820: LIST
44821: LIST
44822: LIST
44823: LIST
44824: LIST
44825: PPUSH
44826: CALL_OW 72
44830: ST_TO_ADDR
// if not tmp then
44831: LD_VAR 0 4
44835: NOT
44836: IFFALSE 44840
// exit ;
44838: GO 48268
// for i in tmp do
44840: LD_ADDR_VAR 0 3
44844: PUSH
44845: LD_VAR 0 4
44849: PUSH
44850: FOR_IN
44851: IFFALSE 44882
// if GetTag ( i ) then
44853: LD_VAR 0 3
44857: PPUSH
44858: CALL_OW 110
44862: IFFALSE 44880
// tmp := tmp diff i ;
44864: LD_ADDR_VAR 0 4
44868: PUSH
44869: LD_VAR 0 4
44873: PUSH
44874: LD_VAR 0 3
44878: DIFF
44879: ST_TO_ADDR
44880: GO 44850
44882: POP
44883: POP
// if not tmp then
44884: LD_VAR 0 4
44888: NOT
44889: IFFALSE 44893
// exit ;
44891: GO 48268
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
44893: LD_ADDR_VAR 0 5
44897: PUSH
44898: LD_EXP 102
44902: PUSH
44903: LD_VAR 0 1
44907: ARRAY
44908: PPUSH
44909: LD_INT 2
44911: PUSH
44912: LD_INT 25
44914: PUSH
44915: LD_INT 1
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 25
44924: PUSH
44925: LD_INT 5
44927: PUSH
44928: EMPTY
44929: LIST
44930: LIST
44931: PUSH
44932: LD_INT 25
44934: PUSH
44935: LD_INT 8
44937: PUSH
44938: EMPTY
44939: LIST
44940: LIST
44941: PUSH
44942: LD_INT 25
44944: PUSH
44945: LD_INT 9
44947: PUSH
44948: EMPTY
44949: LIST
44950: LIST
44951: PUSH
44952: EMPTY
44953: LIST
44954: LIST
44955: LIST
44956: LIST
44957: LIST
44958: PPUSH
44959: CALL_OW 72
44963: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
44964: LD_ADDR_VAR 0 6
44968: PUSH
44969: LD_EXP 102
44973: PUSH
44974: LD_VAR 0 1
44978: ARRAY
44979: PPUSH
44980: LD_INT 25
44982: PUSH
44983: LD_INT 2
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PPUSH
44990: CALL_OW 72
44994: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
44995: LD_ADDR_VAR 0 7
44999: PUSH
45000: LD_EXP 102
45004: PUSH
45005: LD_VAR 0 1
45009: ARRAY
45010: PPUSH
45011: LD_INT 25
45013: PUSH
45014: LD_INT 3
45016: PUSH
45017: EMPTY
45018: LIST
45019: LIST
45020: PPUSH
45021: CALL_OW 72
45025: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
45026: LD_ADDR_VAR 0 8
45030: PUSH
45031: LD_EXP 102
45035: PUSH
45036: LD_VAR 0 1
45040: ARRAY
45041: PPUSH
45042: LD_INT 25
45044: PUSH
45045: LD_INT 4
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 24
45054: PUSH
45055: LD_INT 251
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PPUSH
45066: CALL_OW 72
45070: ST_TO_ADDR
// if mc_is_defending [ base ] then
45071: LD_EXP 145
45075: PUSH
45076: LD_VAR 0 1
45080: ARRAY
45081: IFFALSE 45542
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
45083: LD_ADDR_EXP 144
45087: PUSH
45088: LD_EXP 144
45092: PPUSH
45093: LD_VAR 0 1
45097: PPUSH
45098: LD_INT 4
45100: PPUSH
45101: CALL_OW 1
45105: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
45106: LD_ADDR_VAR 0 12
45110: PUSH
45111: LD_EXP 102
45115: PUSH
45116: LD_VAR 0 1
45120: ARRAY
45121: PPUSH
45122: LD_INT 2
45124: PUSH
45125: LD_INT 30
45127: PUSH
45128: LD_INT 4
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: PUSH
45135: LD_INT 30
45137: PUSH
45138: LD_INT 5
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: LIST
45149: PPUSH
45150: CALL_OW 72
45154: ST_TO_ADDR
// if not b then
45155: LD_VAR 0 12
45159: NOT
45160: IFFALSE 45164
// exit ;
45162: GO 48268
// p := [ ] ;
45164: LD_ADDR_VAR 0 11
45168: PUSH
45169: EMPTY
45170: ST_TO_ADDR
// if sci >= 2 then
45171: LD_VAR 0 8
45175: PUSH
45176: LD_INT 2
45178: GREATEREQUAL
45179: IFFALSE 45210
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
45181: LD_ADDR_VAR 0 8
45185: PUSH
45186: LD_VAR 0 8
45190: PUSH
45191: LD_INT 1
45193: ARRAY
45194: PUSH
45195: LD_VAR 0 8
45199: PUSH
45200: LD_INT 2
45202: ARRAY
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: ST_TO_ADDR
45208: GO 45271
// if sci = 1 then
45210: LD_VAR 0 8
45214: PUSH
45215: LD_INT 1
45217: EQUAL
45218: IFFALSE 45239
// sci := [ sci [ 1 ] ] else
45220: LD_ADDR_VAR 0 8
45224: PUSH
45225: LD_VAR 0 8
45229: PUSH
45230: LD_INT 1
45232: ARRAY
45233: PUSH
45234: EMPTY
45235: LIST
45236: ST_TO_ADDR
45237: GO 45271
// if sci = 0 then
45239: LD_VAR 0 8
45243: PUSH
45244: LD_INT 0
45246: EQUAL
45247: IFFALSE 45271
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
45249: LD_ADDR_VAR 0 11
45253: PUSH
45254: LD_VAR 0 4
45258: PPUSH
45259: LD_INT 4
45261: PPUSH
45262: CALL 107619 0 2
45266: PUSH
45267: LD_INT 1
45269: ARRAY
45270: ST_TO_ADDR
// if eng > 4 then
45271: LD_VAR 0 6
45275: PUSH
45276: LD_INT 4
45278: GREATER
45279: IFFALSE 45325
// for i = eng downto 4 do
45281: LD_ADDR_VAR 0 3
45285: PUSH
45286: DOUBLE
45287: LD_VAR 0 6
45291: INC
45292: ST_TO_ADDR
45293: LD_INT 4
45295: PUSH
45296: FOR_DOWNTO
45297: IFFALSE 45323
// eng := eng diff eng [ i ] ;
45299: LD_ADDR_VAR 0 6
45303: PUSH
45304: LD_VAR 0 6
45308: PUSH
45309: LD_VAR 0 6
45313: PUSH
45314: LD_VAR 0 3
45318: ARRAY
45319: DIFF
45320: ST_TO_ADDR
45321: GO 45296
45323: POP
45324: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
45325: LD_ADDR_VAR 0 4
45329: PUSH
45330: LD_VAR 0 4
45334: PUSH
45335: LD_VAR 0 5
45339: PUSH
45340: LD_VAR 0 6
45344: UNION
45345: PUSH
45346: LD_VAR 0 7
45350: UNION
45351: PUSH
45352: LD_VAR 0 8
45356: UNION
45357: DIFF
45358: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
45359: LD_ADDR_VAR 0 13
45363: PUSH
45364: LD_EXP 102
45368: PUSH
45369: LD_VAR 0 1
45373: ARRAY
45374: PPUSH
45375: LD_INT 2
45377: PUSH
45378: LD_INT 30
45380: PUSH
45381: LD_INT 32
45383: PUSH
45384: EMPTY
45385: LIST
45386: LIST
45387: PUSH
45388: LD_INT 30
45390: PUSH
45391: LD_INT 31
45393: PUSH
45394: EMPTY
45395: LIST
45396: LIST
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: LIST
45402: PPUSH
45403: CALL_OW 72
45407: PUSH
45408: LD_EXP 102
45412: PUSH
45413: LD_VAR 0 1
45417: ARRAY
45418: PPUSH
45419: LD_INT 2
45421: PUSH
45422: LD_INT 30
45424: PUSH
45425: LD_INT 4
45427: PUSH
45428: EMPTY
45429: LIST
45430: LIST
45431: PUSH
45432: LD_INT 30
45434: PUSH
45435: LD_INT 5
45437: PUSH
45438: EMPTY
45439: LIST
45440: LIST
45441: PUSH
45442: EMPTY
45443: LIST
45444: LIST
45445: LIST
45446: PPUSH
45447: CALL_OW 72
45451: PUSH
45452: LD_INT 6
45454: MUL
45455: PLUS
45456: ST_TO_ADDR
// if bcount < tmp then
45457: LD_VAR 0 13
45461: PUSH
45462: LD_VAR 0 4
45466: LESS
45467: IFFALSE 45513
// for i = tmp downto bcount do
45469: LD_ADDR_VAR 0 3
45473: PUSH
45474: DOUBLE
45475: LD_VAR 0 4
45479: INC
45480: ST_TO_ADDR
45481: LD_VAR 0 13
45485: PUSH
45486: FOR_DOWNTO
45487: IFFALSE 45511
// tmp := Delete ( tmp , tmp ) ;
45489: LD_ADDR_VAR 0 4
45493: PUSH
45494: LD_VAR 0 4
45498: PPUSH
45499: LD_VAR 0 4
45503: PPUSH
45504: CALL_OW 3
45508: ST_TO_ADDR
45509: GO 45486
45511: POP
45512: POP
// result := [ tmp , 0 , 0 , p ] ;
45513: LD_ADDR_VAR 0 2
45517: PUSH
45518: LD_VAR 0 4
45522: PUSH
45523: LD_INT 0
45525: PUSH
45526: LD_INT 0
45528: PUSH
45529: LD_VAR 0 11
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: ST_TO_ADDR
// exit ;
45540: GO 48268
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45542: LD_EXP 102
45546: PUSH
45547: LD_VAR 0 1
45551: ARRAY
45552: PPUSH
45553: LD_INT 2
45555: PUSH
45556: LD_INT 30
45558: PUSH
45559: LD_INT 6
45561: PUSH
45562: EMPTY
45563: LIST
45564: LIST
45565: PUSH
45566: LD_INT 30
45568: PUSH
45569: LD_INT 7
45571: PUSH
45572: EMPTY
45573: LIST
45574: LIST
45575: PUSH
45576: LD_INT 30
45578: PUSH
45579: LD_INT 8
45581: PUSH
45582: EMPTY
45583: LIST
45584: LIST
45585: PUSH
45586: EMPTY
45587: LIST
45588: LIST
45589: LIST
45590: LIST
45591: PPUSH
45592: CALL_OW 72
45596: NOT
45597: IFFALSE 45627
45599: PUSH
45600: LD_EXP 102
45604: PUSH
45605: LD_VAR 0 1
45609: ARRAY
45610: PPUSH
45611: LD_INT 30
45613: PUSH
45614: LD_INT 3
45616: PUSH
45617: EMPTY
45618: LIST
45619: LIST
45620: PPUSH
45621: CALL_OW 72
45625: NOT
45626: AND
45627: IFFALSE 45699
// begin if eng = tmp then
45629: LD_VAR 0 6
45633: PUSH
45634: LD_VAR 0 4
45638: EQUAL
45639: IFFALSE 45643
// exit ;
45641: GO 48268
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
45643: LD_ADDR_EXP 144
45647: PUSH
45648: LD_EXP 144
45652: PPUSH
45653: LD_VAR 0 1
45657: PPUSH
45658: LD_INT 1
45660: PPUSH
45661: CALL_OW 1
45665: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
45666: LD_ADDR_VAR 0 2
45670: PUSH
45671: LD_INT 0
45673: PUSH
45674: LD_VAR 0 4
45678: PUSH
45679: LD_VAR 0 6
45683: DIFF
45684: PUSH
45685: LD_INT 0
45687: PUSH
45688: LD_INT 0
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: LIST
45695: LIST
45696: ST_TO_ADDR
// exit ;
45697: GO 48268
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
45699: LD_EXP 129
45703: PUSH
45704: LD_EXP 128
45708: PUSH
45709: LD_VAR 0 1
45713: ARRAY
45714: ARRAY
45715: IFFALSE 45773
45717: PUSH
45718: LD_EXP 102
45722: PUSH
45723: LD_VAR 0 1
45727: ARRAY
45728: PPUSH
45729: LD_INT 2
45731: PUSH
45732: LD_INT 30
45734: PUSH
45735: LD_INT 6
45737: PUSH
45738: EMPTY
45739: LIST
45740: LIST
45741: PUSH
45742: LD_INT 30
45744: PUSH
45745: LD_INT 7
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 30
45754: PUSH
45755: LD_INT 8
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: LIST
45766: LIST
45767: PPUSH
45768: CALL_OW 72
45772: AND
45773: IFFALSE 45803
45775: PUSH
45776: LD_EXP 102
45780: PUSH
45781: LD_VAR 0 1
45785: ARRAY
45786: PPUSH
45787: LD_INT 30
45789: PUSH
45790: LD_INT 3
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PPUSH
45797: CALL_OW 72
45801: NOT
45802: AND
45803: IFFALSE 46019
// begin if sci >= 6 then
45805: LD_VAR 0 8
45809: PUSH
45810: LD_INT 6
45812: GREATEREQUAL
45813: IFFALSE 45817
// exit ;
45815: GO 48268
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
45817: LD_ADDR_EXP 144
45821: PUSH
45822: LD_EXP 144
45826: PPUSH
45827: LD_VAR 0 1
45831: PPUSH
45832: LD_INT 2
45834: PPUSH
45835: CALL_OW 1
45839: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
45840: LD_ADDR_VAR 0 9
45844: PUSH
45845: LD_VAR 0 4
45849: PUSH
45850: LD_VAR 0 8
45854: DIFF
45855: PPUSH
45856: LD_INT 4
45858: PPUSH
45859: CALL 107619 0 2
45863: ST_TO_ADDR
// p := [ ] ;
45864: LD_ADDR_VAR 0 11
45868: PUSH
45869: EMPTY
45870: ST_TO_ADDR
// if sci < 6 and sort > 6 then
45871: LD_VAR 0 8
45875: PUSH
45876: LD_INT 6
45878: LESS
45879: IFFALSE 45891
45881: PUSH
45882: LD_VAR 0 9
45886: PUSH
45887: LD_INT 6
45889: GREATER
45890: AND
45891: IFFALSE 45972
// begin for i = 1 to 6 - sci do
45893: LD_ADDR_VAR 0 3
45897: PUSH
45898: DOUBLE
45899: LD_INT 1
45901: DEC
45902: ST_TO_ADDR
45903: LD_INT 6
45905: PUSH
45906: LD_VAR 0 8
45910: MINUS
45911: PUSH
45912: FOR_TO
45913: IFFALSE 45968
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
45915: LD_ADDR_VAR 0 11
45919: PUSH
45920: LD_VAR 0 11
45924: PPUSH
45925: LD_VAR 0 11
45929: PUSH
45930: LD_INT 1
45932: PLUS
45933: PPUSH
45934: LD_VAR 0 9
45938: PUSH
45939: LD_INT 1
45941: ARRAY
45942: PPUSH
45943: CALL_OW 2
45947: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
45948: LD_ADDR_VAR 0 9
45952: PUSH
45953: LD_VAR 0 9
45957: PPUSH
45958: LD_INT 1
45960: PPUSH
45961: CALL_OW 3
45965: ST_TO_ADDR
// end ;
45966: GO 45912
45968: POP
45969: POP
// end else
45970: GO 45992
// if sort then
45972: LD_VAR 0 9
45976: IFFALSE 45992
// p := sort [ 1 ] ;
45978: LD_ADDR_VAR 0 11
45982: PUSH
45983: LD_VAR 0 9
45987: PUSH
45988: LD_INT 1
45990: ARRAY
45991: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
45992: LD_ADDR_VAR 0 2
45996: PUSH
45997: LD_INT 0
45999: PUSH
46000: LD_INT 0
46002: PUSH
46003: LD_INT 0
46005: PUSH
46006: LD_VAR 0 11
46010: PUSH
46011: EMPTY
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: ST_TO_ADDR
// exit ;
46017: GO 48268
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
46019: LD_EXP 129
46023: PUSH
46024: LD_EXP 128
46028: PUSH
46029: LD_VAR 0 1
46033: ARRAY
46034: ARRAY
46035: IFFALSE 46093
46037: PUSH
46038: LD_EXP 102
46042: PUSH
46043: LD_VAR 0 1
46047: ARRAY
46048: PPUSH
46049: LD_INT 2
46051: PUSH
46052: LD_INT 30
46054: PUSH
46055: LD_INT 6
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: PUSH
46062: LD_INT 30
46064: PUSH
46065: LD_INT 7
46067: PUSH
46068: EMPTY
46069: LIST
46070: LIST
46071: PUSH
46072: LD_INT 30
46074: PUSH
46075: LD_INT 8
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: LIST
46086: LIST
46087: PPUSH
46088: CALL_OW 72
46092: AND
46093: IFFALSE 46122
46095: PUSH
46096: LD_EXP 102
46100: PUSH
46101: LD_VAR 0 1
46105: ARRAY
46106: PPUSH
46107: LD_INT 30
46109: PUSH
46110: LD_INT 3
46112: PUSH
46113: EMPTY
46114: LIST
46115: LIST
46116: PPUSH
46117: CALL_OW 72
46121: AND
46122: IFFALSE 46862
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
46124: LD_ADDR_EXP 144
46128: PUSH
46129: LD_EXP 144
46133: PPUSH
46134: LD_VAR 0 1
46138: PPUSH
46139: LD_INT 3
46141: PPUSH
46142: CALL_OW 1
46146: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46147: LD_ADDR_VAR 0 2
46151: PUSH
46152: LD_INT 0
46154: PUSH
46155: LD_INT 0
46157: PUSH
46158: LD_INT 0
46160: PUSH
46161: LD_INT 0
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: LIST
46168: LIST
46169: ST_TO_ADDR
// if not eng then
46170: LD_VAR 0 6
46174: NOT
46175: IFFALSE 46238
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
46177: LD_ADDR_VAR 0 11
46181: PUSH
46182: LD_VAR 0 4
46186: PPUSH
46187: LD_INT 2
46189: PPUSH
46190: CALL 107619 0 2
46194: PUSH
46195: LD_INT 1
46197: ARRAY
46198: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
46199: LD_ADDR_VAR 0 2
46203: PUSH
46204: LD_VAR 0 2
46208: PPUSH
46209: LD_INT 2
46211: PPUSH
46212: LD_VAR 0 11
46216: PPUSH
46217: CALL_OW 1
46221: ST_TO_ADDR
// tmp := tmp diff p ;
46222: LD_ADDR_VAR 0 4
46226: PUSH
46227: LD_VAR 0 4
46231: PUSH
46232: LD_VAR 0 11
46236: DIFF
46237: ST_TO_ADDR
// end ; if tmp and sci < 6 then
46238: LD_VAR 0 4
46242: IFFALSE 46254
46244: PUSH
46245: LD_VAR 0 8
46249: PUSH
46250: LD_INT 6
46252: LESS
46253: AND
46254: IFFALSE 46442
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
46256: LD_ADDR_VAR 0 9
46260: PUSH
46261: LD_VAR 0 4
46265: PUSH
46266: LD_VAR 0 8
46270: PUSH
46271: LD_VAR 0 7
46275: UNION
46276: DIFF
46277: PPUSH
46278: LD_INT 4
46280: PPUSH
46281: CALL 107619 0 2
46285: ST_TO_ADDR
// p := [ ] ;
46286: LD_ADDR_VAR 0 11
46290: PUSH
46291: EMPTY
46292: ST_TO_ADDR
// if sort then
46293: LD_VAR 0 9
46297: IFFALSE 46413
// for i = 1 to 6 - sci do
46299: LD_ADDR_VAR 0 3
46303: PUSH
46304: DOUBLE
46305: LD_INT 1
46307: DEC
46308: ST_TO_ADDR
46309: LD_INT 6
46311: PUSH
46312: LD_VAR 0 8
46316: MINUS
46317: PUSH
46318: FOR_TO
46319: IFFALSE 46411
// begin if i = sort then
46321: LD_VAR 0 3
46325: PUSH
46326: LD_VAR 0 9
46330: EQUAL
46331: IFFALSE 46335
// break ;
46333: GO 46411
// if GetClass ( i ) = 4 then
46335: LD_VAR 0 3
46339: PPUSH
46340: CALL_OW 257
46344: PUSH
46345: LD_INT 4
46347: EQUAL
46348: IFFALSE 46352
// continue ;
46350: GO 46318
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46352: LD_ADDR_VAR 0 11
46356: PUSH
46357: LD_VAR 0 11
46361: PPUSH
46362: LD_VAR 0 11
46366: PUSH
46367: LD_INT 1
46369: PLUS
46370: PPUSH
46371: LD_VAR 0 9
46375: PUSH
46376: LD_VAR 0 3
46380: ARRAY
46381: PPUSH
46382: CALL_OW 2
46386: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46387: LD_ADDR_VAR 0 4
46391: PUSH
46392: LD_VAR 0 4
46396: PUSH
46397: LD_VAR 0 9
46401: PUSH
46402: LD_VAR 0 3
46406: ARRAY
46407: DIFF
46408: ST_TO_ADDR
// end ;
46409: GO 46318
46411: POP
46412: POP
// if p then
46413: LD_VAR 0 11
46417: IFFALSE 46442
// result := Replace ( result , 4 , p ) ;
46419: LD_ADDR_VAR 0 2
46423: PUSH
46424: LD_VAR 0 2
46428: PPUSH
46429: LD_INT 4
46431: PPUSH
46432: LD_VAR 0 11
46436: PPUSH
46437: CALL_OW 1
46441: ST_TO_ADDR
// end ; if tmp and mech < 6 then
46442: LD_VAR 0 4
46446: IFFALSE 46458
46448: PUSH
46449: LD_VAR 0 7
46453: PUSH
46454: LD_INT 6
46456: LESS
46457: AND
46458: IFFALSE 46646
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
46460: LD_ADDR_VAR 0 9
46464: PUSH
46465: LD_VAR 0 4
46469: PUSH
46470: LD_VAR 0 8
46474: PUSH
46475: LD_VAR 0 7
46479: UNION
46480: DIFF
46481: PPUSH
46482: LD_INT 3
46484: PPUSH
46485: CALL 107619 0 2
46489: ST_TO_ADDR
// p := [ ] ;
46490: LD_ADDR_VAR 0 11
46494: PUSH
46495: EMPTY
46496: ST_TO_ADDR
// if sort then
46497: LD_VAR 0 9
46501: IFFALSE 46617
// for i = 1 to 6 - mech do
46503: LD_ADDR_VAR 0 3
46507: PUSH
46508: DOUBLE
46509: LD_INT 1
46511: DEC
46512: ST_TO_ADDR
46513: LD_INT 6
46515: PUSH
46516: LD_VAR 0 7
46520: MINUS
46521: PUSH
46522: FOR_TO
46523: IFFALSE 46615
// begin if i = sort then
46525: LD_VAR 0 3
46529: PUSH
46530: LD_VAR 0 9
46534: EQUAL
46535: IFFALSE 46539
// break ;
46537: GO 46615
// if GetClass ( i ) = 3 then
46539: LD_VAR 0 3
46543: PPUSH
46544: CALL_OW 257
46548: PUSH
46549: LD_INT 3
46551: EQUAL
46552: IFFALSE 46556
// continue ;
46554: GO 46522
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46556: LD_ADDR_VAR 0 11
46560: PUSH
46561: LD_VAR 0 11
46565: PPUSH
46566: LD_VAR 0 11
46570: PUSH
46571: LD_INT 1
46573: PLUS
46574: PPUSH
46575: LD_VAR 0 9
46579: PUSH
46580: LD_VAR 0 3
46584: ARRAY
46585: PPUSH
46586: CALL_OW 2
46590: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46591: LD_ADDR_VAR 0 4
46595: PUSH
46596: LD_VAR 0 4
46600: PUSH
46601: LD_VAR 0 9
46605: PUSH
46606: LD_VAR 0 3
46610: ARRAY
46611: DIFF
46612: ST_TO_ADDR
// end ;
46613: GO 46522
46615: POP
46616: POP
// if p then
46617: LD_VAR 0 11
46621: IFFALSE 46646
// result := Replace ( result , 3 , p ) ;
46623: LD_ADDR_VAR 0 2
46627: PUSH
46628: LD_VAR 0 2
46632: PPUSH
46633: LD_INT 3
46635: PPUSH
46636: LD_VAR 0 11
46640: PPUSH
46641: CALL_OW 1
46645: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
46646: LD_VAR 0 4
46650: PUSH
46651: LD_INT 6
46653: GREATER
46654: IFFALSE 46666
46656: PUSH
46657: LD_VAR 0 6
46661: PUSH
46662: LD_INT 6
46664: LESS
46665: AND
46666: IFFALSE 46860
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
46668: LD_ADDR_VAR 0 9
46672: PUSH
46673: LD_VAR 0 4
46677: PUSH
46678: LD_VAR 0 8
46682: PUSH
46683: LD_VAR 0 7
46687: UNION
46688: PUSH
46689: LD_VAR 0 6
46693: UNION
46694: DIFF
46695: PPUSH
46696: LD_INT 2
46698: PPUSH
46699: CALL 107619 0 2
46703: ST_TO_ADDR
// p := [ ] ;
46704: LD_ADDR_VAR 0 11
46708: PUSH
46709: EMPTY
46710: ST_TO_ADDR
// if sort then
46711: LD_VAR 0 9
46715: IFFALSE 46831
// for i = 1 to 6 - eng do
46717: LD_ADDR_VAR 0 3
46721: PUSH
46722: DOUBLE
46723: LD_INT 1
46725: DEC
46726: ST_TO_ADDR
46727: LD_INT 6
46729: PUSH
46730: LD_VAR 0 6
46734: MINUS
46735: PUSH
46736: FOR_TO
46737: IFFALSE 46829
// begin if i = sort then
46739: LD_VAR 0 3
46743: PUSH
46744: LD_VAR 0 9
46748: EQUAL
46749: IFFALSE 46753
// break ;
46751: GO 46829
// if GetClass ( i ) = 2 then
46753: LD_VAR 0 3
46757: PPUSH
46758: CALL_OW 257
46762: PUSH
46763: LD_INT 2
46765: EQUAL
46766: IFFALSE 46770
// continue ;
46768: GO 46736
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46770: LD_ADDR_VAR 0 11
46774: PUSH
46775: LD_VAR 0 11
46779: PPUSH
46780: LD_VAR 0 11
46784: PUSH
46785: LD_INT 1
46787: PLUS
46788: PPUSH
46789: LD_VAR 0 9
46793: PUSH
46794: LD_VAR 0 3
46798: ARRAY
46799: PPUSH
46800: CALL_OW 2
46804: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46805: LD_ADDR_VAR 0 4
46809: PUSH
46810: LD_VAR 0 4
46814: PUSH
46815: LD_VAR 0 9
46819: PUSH
46820: LD_VAR 0 3
46824: ARRAY
46825: DIFF
46826: ST_TO_ADDR
// end ;
46827: GO 46736
46829: POP
46830: POP
// if p then
46831: LD_VAR 0 11
46835: IFFALSE 46860
// result := Replace ( result , 2 , p ) ;
46837: LD_ADDR_VAR 0 2
46841: PUSH
46842: LD_VAR 0 2
46846: PPUSH
46847: LD_INT 2
46849: PPUSH
46850: LD_VAR 0 11
46854: PPUSH
46855: CALL_OW 1
46859: ST_TO_ADDR
// end ; exit ;
46860: GO 48268
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
46862: LD_EXP 129
46866: PUSH
46867: LD_EXP 128
46871: PUSH
46872: LD_VAR 0 1
46876: ARRAY
46877: ARRAY
46878: NOT
46879: IFFALSE 46908
46881: PUSH
46882: LD_EXP 102
46886: PUSH
46887: LD_VAR 0 1
46891: ARRAY
46892: PPUSH
46893: LD_INT 30
46895: PUSH
46896: LD_INT 3
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PPUSH
46903: CALL_OW 72
46907: AND
46908: IFFALSE 46922
46910: PUSH
46911: LD_EXP 107
46915: PUSH
46916: LD_VAR 0 1
46920: ARRAY
46921: AND
46922: IFFALSE 47536
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
46924: LD_ADDR_EXP 144
46928: PUSH
46929: LD_EXP 144
46933: PPUSH
46934: LD_VAR 0 1
46938: PPUSH
46939: LD_INT 5
46941: PPUSH
46942: CALL_OW 1
46946: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
46947: LD_ADDR_VAR 0 2
46951: PUSH
46952: LD_INT 0
46954: PUSH
46955: LD_INT 0
46957: PUSH
46958: LD_INT 0
46960: PUSH
46961: LD_INT 0
46963: PUSH
46964: EMPTY
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: ST_TO_ADDR
// if sci > 1 then
46970: LD_VAR 0 8
46974: PUSH
46975: LD_INT 1
46977: GREATER
46978: IFFALSE 47006
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
46980: LD_ADDR_VAR 0 4
46984: PUSH
46985: LD_VAR 0 4
46989: PUSH
46990: LD_VAR 0 8
46994: PUSH
46995: LD_VAR 0 8
46999: PUSH
47000: LD_INT 1
47002: ARRAY
47003: DIFF
47004: DIFF
47005: ST_TO_ADDR
// if tmp and not sci then
47006: LD_VAR 0 4
47010: IFFALSE 47019
47012: PUSH
47013: LD_VAR 0 8
47017: NOT
47018: AND
47019: IFFALSE 47088
// begin sort := SortBySkill ( tmp , 4 ) ;
47021: LD_ADDR_VAR 0 9
47025: PUSH
47026: LD_VAR 0 4
47030: PPUSH
47031: LD_INT 4
47033: PPUSH
47034: CALL 107619 0 2
47038: ST_TO_ADDR
// if sort then
47039: LD_VAR 0 9
47043: IFFALSE 47059
// p := sort [ 1 ] ;
47045: LD_ADDR_VAR 0 11
47049: PUSH
47050: LD_VAR 0 9
47054: PUSH
47055: LD_INT 1
47057: ARRAY
47058: ST_TO_ADDR
// if p then
47059: LD_VAR 0 11
47063: IFFALSE 47088
// result := Replace ( result , 4 , p ) ;
47065: LD_ADDR_VAR 0 2
47069: PUSH
47070: LD_VAR 0 2
47074: PPUSH
47075: LD_INT 4
47077: PPUSH
47078: LD_VAR 0 11
47082: PPUSH
47083: CALL_OW 1
47087: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
47088: LD_ADDR_VAR 0 4
47092: PUSH
47093: LD_VAR 0 4
47097: PUSH
47098: LD_VAR 0 7
47102: DIFF
47103: ST_TO_ADDR
// if tmp and mech < 6 then
47104: LD_VAR 0 4
47108: IFFALSE 47120
47110: PUSH
47111: LD_VAR 0 7
47115: PUSH
47116: LD_INT 6
47118: LESS
47119: AND
47120: IFFALSE 47308
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
47122: LD_ADDR_VAR 0 9
47126: PUSH
47127: LD_VAR 0 4
47131: PUSH
47132: LD_VAR 0 8
47136: PUSH
47137: LD_VAR 0 7
47141: UNION
47142: DIFF
47143: PPUSH
47144: LD_INT 3
47146: PPUSH
47147: CALL 107619 0 2
47151: ST_TO_ADDR
// p := [ ] ;
47152: LD_ADDR_VAR 0 11
47156: PUSH
47157: EMPTY
47158: ST_TO_ADDR
// if sort then
47159: LD_VAR 0 9
47163: IFFALSE 47279
// for i = 1 to 6 - mech do
47165: LD_ADDR_VAR 0 3
47169: PUSH
47170: DOUBLE
47171: LD_INT 1
47173: DEC
47174: ST_TO_ADDR
47175: LD_INT 6
47177: PUSH
47178: LD_VAR 0 7
47182: MINUS
47183: PUSH
47184: FOR_TO
47185: IFFALSE 47277
// begin if i = sort then
47187: LD_VAR 0 3
47191: PUSH
47192: LD_VAR 0 9
47196: EQUAL
47197: IFFALSE 47201
// break ;
47199: GO 47277
// if GetClass ( i ) = 3 then
47201: LD_VAR 0 3
47205: PPUSH
47206: CALL_OW 257
47210: PUSH
47211: LD_INT 3
47213: EQUAL
47214: IFFALSE 47218
// continue ;
47216: GO 47184
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47218: LD_ADDR_VAR 0 11
47222: PUSH
47223: LD_VAR 0 11
47227: PPUSH
47228: LD_VAR 0 11
47232: PUSH
47233: LD_INT 1
47235: PLUS
47236: PPUSH
47237: LD_VAR 0 9
47241: PUSH
47242: LD_VAR 0 3
47246: ARRAY
47247: PPUSH
47248: CALL_OW 2
47252: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47253: LD_ADDR_VAR 0 4
47257: PUSH
47258: LD_VAR 0 4
47262: PUSH
47263: LD_VAR 0 9
47267: PUSH
47268: LD_VAR 0 3
47272: ARRAY
47273: DIFF
47274: ST_TO_ADDR
// end ;
47275: GO 47184
47277: POP
47278: POP
// if p then
47279: LD_VAR 0 11
47283: IFFALSE 47308
// result := Replace ( result , 3 , p ) ;
47285: LD_ADDR_VAR 0 2
47289: PUSH
47290: LD_VAR 0 2
47294: PPUSH
47295: LD_INT 3
47297: PPUSH
47298: LD_VAR 0 11
47302: PPUSH
47303: CALL_OW 1
47307: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47308: LD_ADDR_VAR 0 4
47312: PUSH
47313: LD_VAR 0 4
47317: PUSH
47318: LD_VAR 0 6
47322: DIFF
47323: ST_TO_ADDR
// if tmp and eng < 6 then
47324: LD_VAR 0 4
47328: IFFALSE 47340
47330: PUSH
47331: LD_VAR 0 6
47335: PUSH
47336: LD_INT 6
47338: LESS
47339: AND
47340: IFFALSE 47534
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
47342: LD_ADDR_VAR 0 9
47346: PUSH
47347: LD_VAR 0 4
47351: PUSH
47352: LD_VAR 0 8
47356: PUSH
47357: LD_VAR 0 7
47361: UNION
47362: PUSH
47363: LD_VAR 0 6
47367: UNION
47368: DIFF
47369: PPUSH
47370: LD_INT 2
47372: PPUSH
47373: CALL 107619 0 2
47377: ST_TO_ADDR
// p := [ ] ;
47378: LD_ADDR_VAR 0 11
47382: PUSH
47383: EMPTY
47384: ST_TO_ADDR
// if sort then
47385: LD_VAR 0 9
47389: IFFALSE 47505
// for i = 1 to 6 - eng do
47391: LD_ADDR_VAR 0 3
47395: PUSH
47396: DOUBLE
47397: LD_INT 1
47399: DEC
47400: ST_TO_ADDR
47401: LD_INT 6
47403: PUSH
47404: LD_VAR 0 6
47408: MINUS
47409: PUSH
47410: FOR_TO
47411: IFFALSE 47503
// begin if i = sort then
47413: LD_VAR 0 3
47417: PUSH
47418: LD_VAR 0 9
47422: EQUAL
47423: IFFALSE 47427
// break ;
47425: GO 47503
// if GetClass ( i ) = 2 then
47427: LD_VAR 0 3
47431: PPUSH
47432: CALL_OW 257
47436: PUSH
47437: LD_INT 2
47439: EQUAL
47440: IFFALSE 47444
// continue ;
47442: GO 47410
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47444: LD_ADDR_VAR 0 11
47448: PUSH
47449: LD_VAR 0 11
47453: PPUSH
47454: LD_VAR 0 11
47458: PUSH
47459: LD_INT 1
47461: PLUS
47462: PPUSH
47463: LD_VAR 0 9
47467: PUSH
47468: LD_VAR 0 3
47472: ARRAY
47473: PPUSH
47474: CALL_OW 2
47478: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47479: LD_ADDR_VAR 0 4
47483: PUSH
47484: LD_VAR 0 4
47488: PUSH
47489: LD_VAR 0 9
47493: PUSH
47494: LD_VAR 0 3
47498: ARRAY
47499: DIFF
47500: ST_TO_ADDR
// end ;
47501: GO 47410
47503: POP
47504: POP
// if p then
47505: LD_VAR 0 11
47509: IFFALSE 47534
// result := Replace ( result , 2 , p ) ;
47511: LD_ADDR_VAR 0 2
47515: PUSH
47516: LD_VAR 0 2
47520: PPUSH
47521: LD_INT 2
47523: PPUSH
47524: LD_VAR 0 11
47528: PPUSH
47529: CALL_OW 1
47533: ST_TO_ADDR
// end ; exit ;
47534: GO 48268
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
47536: LD_EXP 129
47540: PUSH
47541: LD_EXP 128
47545: PUSH
47546: LD_VAR 0 1
47550: ARRAY
47551: ARRAY
47552: NOT
47553: IFFALSE 47582
47555: PUSH
47556: LD_EXP 102
47560: PUSH
47561: LD_VAR 0 1
47565: ARRAY
47566: PPUSH
47567: LD_INT 30
47569: PUSH
47570: LD_INT 3
47572: PUSH
47573: EMPTY
47574: LIST
47575: LIST
47576: PPUSH
47577: CALL_OW 72
47581: AND
47582: IFFALSE 47597
47584: PUSH
47585: LD_EXP 107
47589: PUSH
47590: LD_VAR 0 1
47594: ARRAY
47595: NOT
47596: AND
47597: IFFALSE 48268
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
47599: LD_ADDR_EXP 144
47603: PUSH
47604: LD_EXP 144
47608: PPUSH
47609: LD_VAR 0 1
47613: PPUSH
47614: LD_INT 6
47616: PPUSH
47617: CALL_OW 1
47621: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
47622: LD_ADDR_VAR 0 2
47626: PUSH
47627: LD_INT 0
47629: PUSH
47630: LD_INT 0
47632: PUSH
47633: LD_INT 0
47635: PUSH
47636: LD_INT 0
47638: PUSH
47639: EMPTY
47640: LIST
47641: LIST
47642: LIST
47643: LIST
47644: ST_TO_ADDR
// if sci >= 1 then
47645: LD_VAR 0 8
47649: PUSH
47650: LD_INT 1
47652: GREATEREQUAL
47653: IFFALSE 47675
// tmp := tmp diff sci [ 1 ] ;
47655: LD_ADDR_VAR 0 4
47659: PUSH
47660: LD_VAR 0 4
47664: PUSH
47665: LD_VAR 0 8
47669: PUSH
47670: LD_INT 1
47672: ARRAY
47673: DIFF
47674: ST_TO_ADDR
// if tmp and not sci then
47675: LD_VAR 0 4
47679: IFFALSE 47688
47681: PUSH
47682: LD_VAR 0 8
47686: NOT
47687: AND
47688: IFFALSE 47757
// begin sort := SortBySkill ( tmp , 4 ) ;
47690: LD_ADDR_VAR 0 9
47694: PUSH
47695: LD_VAR 0 4
47699: PPUSH
47700: LD_INT 4
47702: PPUSH
47703: CALL 107619 0 2
47707: ST_TO_ADDR
// if sort then
47708: LD_VAR 0 9
47712: IFFALSE 47728
// p := sort [ 1 ] ;
47714: LD_ADDR_VAR 0 11
47718: PUSH
47719: LD_VAR 0 9
47723: PUSH
47724: LD_INT 1
47726: ARRAY
47727: ST_TO_ADDR
// if p then
47728: LD_VAR 0 11
47732: IFFALSE 47757
// result := Replace ( result , 4 , p ) ;
47734: LD_ADDR_VAR 0 2
47738: PUSH
47739: LD_VAR 0 2
47743: PPUSH
47744: LD_INT 4
47746: PPUSH
47747: LD_VAR 0 11
47751: PPUSH
47752: CALL_OW 1
47756: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
47757: LD_ADDR_VAR 0 4
47761: PUSH
47762: LD_VAR 0 4
47766: PUSH
47767: LD_VAR 0 7
47771: DIFF
47772: ST_TO_ADDR
// if tmp and mech < 6 then
47773: LD_VAR 0 4
47777: IFFALSE 47789
47779: PUSH
47780: LD_VAR 0 7
47784: PUSH
47785: LD_INT 6
47787: LESS
47788: AND
47789: IFFALSE 47971
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
47791: LD_ADDR_VAR 0 9
47795: PUSH
47796: LD_VAR 0 4
47800: PUSH
47801: LD_VAR 0 7
47805: DIFF
47806: PPUSH
47807: LD_INT 3
47809: PPUSH
47810: CALL 107619 0 2
47814: ST_TO_ADDR
// p := [ ] ;
47815: LD_ADDR_VAR 0 11
47819: PUSH
47820: EMPTY
47821: ST_TO_ADDR
// if sort then
47822: LD_VAR 0 9
47826: IFFALSE 47942
// for i = 1 to 6 - mech do
47828: LD_ADDR_VAR 0 3
47832: PUSH
47833: DOUBLE
47834: LD_INT 1
47836: DEC
47837: ST_TO_ADDR
47838: LD_INT 6
47840: PUSH
47841: LD_VAR 0 7
47845: MINUS
47846: PUSH
47847: FOR_TO
47848: IFFALSE 47940
// begin if i = sort then
47850: LD_VAR 0 3
47854: PUSH
47855: LD_VAR 0 9
47859: EQUAL
47860: IFFALSE 47864
// break ;
47862: GO 47940
// if GetClass ( i ) = 3 then
47864: LD_VAR 0 3
47868: PPUSH
47869: CALL_OW 257
47873: PUSH
47874: LD_INT 3
47876: EQUAL
47877: IFFALSE 47881
// continue ;
47879: GO 47847
// p := Insert ( p , p + 1 , sort [ i ] ) ;
47881: LD_ADDR_VAR 0 11
47885: PUSH
47886: LD_VAR 0 11
47890: PPUSH
47891: LD_VAR 0 11
47895: PUSH
47896: LD_INT 1
47898: PLUS
47899: PPUSH
47900: LD_VAR 0 9
47904: PUSH
47905: LD_VAR 0 3
47909: ARRAY
47910: PPUSH
47911: CALL_OW 2
47915: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
47916: LD_ADDR_VAR 0 4
47920: PUSH
47921: LD_VAR 0 4
47925: PUSH
47926: LD_VAR 0 9
47930: PUSH
47931: LD_VAR 0 3
47935: ARRAY
47936: DIFF
47937: ST_TO_ADDR
// end ;
47938: GO 47847
47940: POP
47941: POP
// if p then
47942: LD_VAR 0 11
47946: IFFALSE 47971
// result := Replace ( result , 3 , p ) ;
47948: LD_ADDR_VAR 0 2
47952: PUSH
47953: LD_VAR 0 2
47957: PPUSH
47958: LD_INT 3
47960: PPUSH
47961: LD_VAR 0 11
47965: PPUSH
47966: CALL_OW 1
47970: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
47971: LD_ADDR_VAR 0 4
47975: PUSH
47976: LD_VAR 0 4
47980: PUSH
47981: LD_VAR 0 6
47985: DIFF
47986: ST_TO_ADDR
// if tmp and eng < 4 then
47987: LD_VAR 0 4
47991: IFFALSE 48003
47993: PUSH
47994: LD_VAR 0 6
47998: PUSH
47999: LD_INT 4
48001: LESS
48002: AND
48003: IFFALSE 48193
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
48005: LD_ADDR_VAR 0 9
48009: PUSH
48010: LD_VAR 0 4
48014: PUSH
48015: LD_VAR 0 7
48019: PUSH
48020: LD_VAR 0 6
48024: UNION
48025: DIFF
48026: PPUSH
48027: LD_INT 2
48029: PPUSH
48030: CALL 107619 0 2
48034: ST_TO_ADDR
// p := [ ] ;
48035: LD_ADDR_VAR 0 11
48039: PUSH
48040: EMPTY
48041: ST_TO_ADDR
// if sort then
48042: LD_VAR 0 9
48046: IFFALSE 48162
// for i = 1 to 4 - eng do
48048: LD_ADDR_VAR 0 3
48052: PUSH
48053: DOUBLE
48054: LD_INT 1
48056: DEC
48057: ST_TO_ADDR
48058: LD_INT 4
48060: PUSH
48061: LD_VAR 0 6
48065: MINUS
48066: PUSH
48067: FOR_TO
48068: IFFALSE 48160
// begin if i = sort then
48070: LD_VAR 0 3
48074: PUSH
48075: LD_VAR 0 9
48079: EQUAL
48080: IFFALSE 48084
// break ;
48082: GO 48160
// if GetClass ( i ) = 2 then
48084: LD_VAR 0 3
48088: PPUSH
48089: CALL_OW 257
48093: PUSH
48094: LD_INT 2
48096: EQUAL
48097: IFFALSE 48101
// continue ;
48099: GO 48067
// p := Insert ( p , p + 1 , sort [ i ] ) ;
48101: LD_ADDR_VAR 0 11
48105: PUSH
48106: LD_VAR 0 11
48110: PPUSH
48111: LD_VAR 0 11
48115: PUSH
48116: LD_INT 1
48118: PLUS
48119: PPUSH
48120: LD_VAR 0 9
48124: PUSH
48125: LD_VAR 0 3
48129: ARRAY
48130: PPUSH
48131: CALL_OW 2
48135: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
48136: LD_ADDR_VAR 0 4
48140: PUSH
48141: LD_VAR 0 4
48145: PUSH
48146: LD_VAR 0 9
48150: PUSH
48151: LD_VAR 0 3
48155: ARRAY
48156: DIFF
48157: ST_TO_ADDR
// end ;
48158: GO 48067
48160: POP
48161: POP
// if p then
48162: LD_VAR 0 11
48166: IFFALSE 48191
// result := Replace ( result , 2 , p ) ;
48168: LD_ADDR_VAR 0 2
48172: PUSH
48173: LD_VAR 0 2
48177: PPUSH
48178: LD_INT 2
48180: PPUSH
48181: LD_VAR 0 11
48185: PPUSH
48186: CALL_OW 1
48190: ST_TO_ADDR
// end else
48191: GO 48237
// for i = eng downto 5 do
48193: LD_ADDR_VAR 0 3
48197: PUSH
48198: DOUBLE
48199: LD_VAR 0 6
48203: INC
48204: ST_TO_ADDR
48205: LD_INT 5
48207: PUSH
48208: FOR_DOWNTO
48209: IFFALSE 48235
// tmp := tmp union eng [ i ] ;
48211: LD_ADDR_VAR 0 4
48215: PUSH
48216: LD_VAR 0 4
48220: PUSH
48221: LD_VAR 0 6
48225: PUSH
48226: LD_VAR 0 3
48230: ARRAY
48231: UNION
48232: ST_TO_ADDR
48233: GO 48208
48235: POP
48236: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
48237: LD_ADDR_VAR 0 2
48241: PUSH
48242: LD_VAR 0 2
48246: PPUSH
48247: LD_INT 1
48249: PPUSH
48250: LD_VAR 0 4
48254: PUSH
48255: LD_VAR 0 5
48259: DIFF
48260: PPUSH
48261: CALL_OW 1
48265: ST_TO_ADDR
// exit ;
48266: GO 48268
// end ; end ;
48268: LD_VAR 0 2
48272: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
48273: LD_INT 0
48275: PPUSH
48276: PPUSH
48277: PPUSH
// if not mc_bases then
48278: LD_EXP 102
48282: NOT
48283: IFFALSE 48287
// exit ;
48285: GO 48429
// for i = 1 to mc_bases do
48287: LD_ADDR_VAR 0 2
48291: PUSH
48292: DOUBLE
48293: LD_INT 1
48295: DEC
48296: ST_TO_ADDR
48297: LD_EXP 102
48301: PUSH
48302: FOR_TO
48303: IFFALSE 48420
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
48305: LD_ADDR_VAR 0 3
48309: PUSH
48310: LD_EXP 102
48314: PUSH
48315: LD_VAR 0 2
48319: ARRAY
48320: PPUSH
48321: LD_INT 21
48323: PUSH
48324: LD_INT 3
48326: PUSH
48327: EMPTY
48328: LIST
48329: LIST
48330: PUSH
48331: LD_INT 3
48333: PUSH
48334: LD_INT 2
48336: PUSH
48337: LD_INT 30
48339: PUSH
48340: LD_INT 29
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: PUSH
48347: LD_INT 30
48349: PUSH
48350: LD_INT 30
48352: PUSH
48353: EMPTY
48354: LIST
48355: LIST
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: LIST
48361: PUSH
48362: EMPTY
48363: LIST
48364: LIST
48365: PUSH
48366: LD_INT 3
48368: PUSH
48369: LD_INT 24
48371: PUSH
48372: LD_INT 1000
48374: PUSH
48375: EMPTY
48376: LIST
48377: LIST
48378: PUSH
48379: EMPTY
48380: LIST
48381: LIST
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: LIST
48387: PPUSH
48388: CALL_OW 72
48392: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
48393: LD_ADDR_EXP 103
48397: PUSH
48398: LD_EXP 103
48402: PPUSH
48403: LD_VAR 0 2
48407: PPUSH
48408: LD_VAR 0 3
48412: PPUSH
48413: CALL_OW 1
48417: ST_TO_ADDR
// end ;
48418: GO 48302
48420: POP
48421: POP
// RaiseSailEvent ( 101 ) ;
48422: LD_INT 101
48424: PPUSH
48425: CALL_OW 427
// end ;
48429: LD_VAR 0 1
48433: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
48434: LD_INT 0
48436: PPUSH
48437: PPUSH
48438: PPUSH
48439: PPUSH
48440: PPUSH
48441: PPUSH
48442: PPUSH
// if not mc_bases then
48443: LD_EXP 102
48447: NOT
48448: IFFALSE 48452
// exit ;
48450: GO 49016
// for i = 1 to mc_bases do
48452: LD_ADDR_VAR 0 2
48456: PUSH
48457: DOUBLE
48458: LD_INT 1
48460: DEC
48461: ST_TO_ADDR
48462: LD_EXP 102
48466: PUSH
48467: FOR_TO
48468: IFFALSE 49007
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
48470: LD_ADDR_VAR 0 5
48474: PUSH
48475: LD_EXP 102
48479: PUSH
48480: LD_VAR 0 2
48484: ARRAY
48485: PUSH
48486: LD_EXP 131
48490: PUSH
48491: LD_VAR 0 2
48495: ARRAY
48496: UNION
48497: PPUSH
48498: LD_INT 21
48500: PUSH
48501: LD_INT 1
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: PUSH
48508: LD_INT 1
48510: PUSH
48511: LD_INT 3
48513: PUSH
48514: LD_INT 54
48516: PUSH
48517: EMPTY
48518: LIST
48519: PUSH
48520: EMPTY
48521: LIST
48522: LIST
48523: PUSH
48524: LD_INT 3
48526: PUSH
48527: LD_INT 24
48529: PUSH
48530: LD_INT 1000
48532: PUSH
48533: EMPTY
48534: LIST
48535: LIST
48536: PUSH
48537: EMPTY
48538: LIST
48539: LIST
48540: PUSH
48541: EMPTY
48542: LIST
48543: LIST
48544: LIST
48545: PUSH
48546: EMPTY
48547: LIST
48548: LIST
48549: PPUSH
48550: CALL_OW 72
48554: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
48555: LD_ADDR_VAR 0 6
48559: PUSH
48560: LD_EXP 102
48564: PUSH
48565: LD_VAR 0 2
48569: ARRAY
48570: PPUSH
48571: LD_INT 21
48573: PUSH
48574: LD_INT 1
48576: PUSH
48577: EMPTY
48578: LIST
48579: LIST
48580: PUSH
48581: LD_INT 1
48583: PUSH
48584: LD_INT 3
48586: PUSH
48587: LD_INT 54
48589: PUSH
48590: EMPTY
48591: LIST
48592: PUSH
48593: EMPTY
48594: LIST
48595: LIST
48596: PUSH
48597: LD_INT 3
48599: PUSH
48600: LD_INT 24
48602: PUSH
48603: LD_INT 250
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: PUSH
48610: EMPTY
48611: LIST
48612: LIST
48613: PUSH
48614: EMPTY
48615: LIST
48616: LIST
48617: LIST
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: PPUSH
48623: CALL_OW 72
48627: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
48628: LD_ADDR_VAR 0 7
48632: PUSH
48633: LD_VAR 0 5
48637: PUSH
48638: LD_VAR 0 6
48642: DIFF
48643: ST_TO_ADDR
// if not need_heal_1 then
48644: LD_VAR 0 6
48648: NOT
48649: IFFALSE 48682
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
48651: LD_ADDR_EXP 105
48655: PUSH
48656: LD_EXP 105
48660: PPUSH
48661: LD_VAR 0 2
48665: PUSH
48666: LD_INT 1
48668: PUSH
48669: EMPTY
48670: LIST
48671: LIST
48672: PPUSH
48673: EMPTY
48674: PPUSH
48675: CALL 76081 0 3
48679: ST_TO_ADDR
48680: GO 48752
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
48682: LD_ADDR_EXP 105
48686: PUSH
48687: LD_EXP 105
48691: PPUSH
48692: LD_VAR 0 2
48696: PUSH
48697: LD_INT 1
48699: PUSH
48700: EMPTY
48701: LIST
48702: LIST
48703: PPUSH
48704: LD_EXP 105
48708: PUSH
48709: LD_VAR 0 2
48713: ARRAY
48714: PUSH
48715: LD_INT 1
48717: ARRAY
48718: PPUSH
48719: LD_INT 3
48721: PUSH
48722: LD_INT 24
48724: PUSH
48725: LD_INT 1000
48727: PUSH
48728: EMPTY
48729: LIST
48730: LIST
48731: PUSH
48732: EMPTY
48733: LIST
48734: LIST
48735: PPUSH
48736: CALL_OW 72
48740: PUSH
48741: LD_VAR 0 6
48745: UNION
48746: PPUSH
48747: CALL 76081 0 3
48751: ST_TO_ADDR
// if not need_heal_2 then
48752: LD_VAR 0 7
48756: NOT
48757: IFFALSE 48790
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
48759: LD_ADDR_EXP 105
48763: PUSH
48764: LD_EXP 105
48768: PPUSH
48769: LD_VAR 0 2
48773: PUSH
48774: LD_INT 2
48776: PUSH
48777: EMPTY
48778: LIST
48779: LIST
48780: PPUSH
48781: EMPTY
48782: PPUSH
48783: CALL 76081 0 3
48787: ST_TO_ADDR
48788: GO 48822
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
48790: LD_ADDR_EXP 105
48794: PUSH
48795: LD_EXP 105
48799: PPUSH
48800: LD_VAR 0 2
48804: PUSH
48805: LD_INT 2
48807: PUSH
48808: EMPTY
48809: LIST
48810: LIST
48811: PPUSH
48812: LD_VAR 0 7
48816: PPUSH
48817: CALL 76081 0 3
48821: ST_TO_ADDR
// if need_heal_2 then
48822: LD_VAR 0 7
48826: IFFALSE 48987
// for j in need_heal_2 do
48828: LD_ADDR_VAR 0 3
48832: PUSH
48833: LD_VAR 0 7
48837: PUSH
48838: FOR_IN
48839: IFFALSE 48985
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48841: LD_ADDR_VAR 0 5
48845: PUSH
48846: LD_EXP 102
48850: PUSH
48851: LD_VAR 0 2
48855: ARRAY
48856: PPUSH
48857: LD_INT 2
48859: PUSH
48860: LD_INT 30
48862: PUSH
48863: LD_INT 6
48865: PUSH
48866: EMPTY
48867: LIST
48868: LIST
48869: PUSH
48870: LD_INT 30
48872: PUSH
48873: LD_INT 7
48875: PUSH
48876: EMPTY
48877: LIST
48878: LIST
48879: PUSH
48880: LD_INT 30
48882: PUSH
48883: LD_INT 8
48885: PUSH
48886: EMPTY
48887: LIST
48888: LIST
48889: PUSH
48890: LD_INT 30
48892: PUSH
48893: LD_INT 0
48895: PUSH
48896: EMPTY
48897: LIST
48898: LIST
48899: PUSH
48900: LD_INT 30
48902: PUSH
48903: LD_INT 1
48905: PUSH
48906: EMPTY
48907: LIST
48908: LIST
48909: PUSH
48910: EMPTY
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: PPUSH
48918: CALL_OW 72
48922: ST_TO_ADDR
// if tmp then
48923: LD_VAR 0 5
48927: IFFALSE 48983
// begin k := NearestUnitToUnit ( tmp , j ) ;
48929: LD_ADDR_VAR 0 4
48933: PUSH
48934: LD_VAR 0 5
48938: PPUSH
48939: LD_VAR 0 3
48943: PPUSH
48944: CALL_OW 74
48948: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
48949: LD_VAR 0 3
48953: PPUSH
48954: LD_VAR 0 4
48958: PPUSH
48959: CALL_OW 296
48963: PUSH
48964: LD_INT 5
48966: GREATER
48967: IFFALSE 48983
// ComMoveToNearbyEntrance ( j , k ) ;
48969: LD_VAR 0 3
48973: PPUSH
48974: LD_VAR 0 4
48978: PPUSH
48979: CALL 110018 0 2
// end ; end ;
48983: GO 48838
48985: POP
48986: POP
// if not need_heal_1 and not need_heal_2 then
48987: LD_VAR 0 6
48991: NOT
48992: IFFALSE 49001
48994: PUSH
48995: LD_VAR 0 7
48999: NOT
49000: AND
49001: IFFALSE 49005
// continue ;
49003: GO 48467
// end ;
49005: GO 48467
49007: POP
49008: POP
// RaiseSailEvent ( 102 ) ;
49009: LD_INT 102
49011: PPUSH
49012: CALL_OW 427
// end ;
49016: LD_VAR 0 1
49020: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
49021: LD_INT 0
49023: PPUSH
49024: PPUSH
49025: PPUSH
49026: PPUSH
49027: PPUSH
49028: PPUSH
49029: PPUSH
49030: PPUSH
// if not mc_bases then
49031: LD_EXP 102
49035: NOT
49036: IFFALSE 49040
// exit ;
49038: GO 49955
// for i = 1 to mc_bases do
49040: LD_ADDR_VAR 0 2
49044: PUSH
49045: DOUBLE
49046: LD_INT 1
49048: DEC
49049: ST_TO_ADDR
49050: LD_EXP 102
49054: PUSH
49055: FOR_TO
49056: IFFALSE 49953
// begin if not mc_building_need_repair [ i ] then
49058: LD_EXP 103
49062: PUSH
49063: LD_VAR 0 2
49067: ARRAY
49068: NOT
49069: IFFALSE 49254
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
49071: LD_ADDR_VAR 0 6
49075: PUSH
49076: LD_EXP 121
49080: PUSH
49081: LD_VAR 0 2
49085: ARRAY
49086: PPUSH
49087: LD_INT 3
49089: PUSH
49090: LD_INT 24
49092: PUSH
49093: LD_INT 1000
49095: PUSH
49096: EMPTY
49097: LIST
49098: LIST
49099: PUSH
49100: EMPTY
49101: LIST
49102: LIST
49103: PUSH
49104: LD_INT 2
49106: PUSH
49107: LD_INT 34
49109: PUSH
49110: LD_INT 13
49112: PUSH
49113: EMPTY
49114: LIST
49115: LIST
49116: PUSH
49117: LD_INT 34
49119: PUSH
49120: LD_INT 52
49122: PUSH
49123: EMPTY
49124: LIST
49125: LIST
49126: PUSH
49127: LD_INT 34
49129: PUSH
49130: LD_INT 88
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: LIST
49141: LIST
49142: PUSH
49143: EMPTY
49144: LIST
49145: LIST
49146: PPUSH
49147: CALL_OW 72
49151: ST_TO_ADDR
// if cranes then
49152: LD_VAR 0 6
49156: IFFALSE 49218
// for j in cranes do
49158: LD_ADDR_VAR 0 3
49162: PUSH
49163: LD_VAR 0 6
49167: PUSH
49168: FOR_IN
49169: IFFALSE 49216
// if not IsInArea ( j , mc_parking [ i ] ) then
49171: LD_VAR 0 3
49175: PPUSH
49176: LD_EXP 126
49180: PUSH
49181: LD_VAR 0 2
49185: ARRAY
49186: PPUSH
49187: CALL_OW 308
49191: NOT
49192: IFFALSE 49214
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49194: LD_VAR 0 3
49198: PPUSH
49199: LD_EXP 126
49203: PUSH
49204: LD_VAR 0 2
49208: ARRAY
49209: PPUSH
49210: CALL_OW 113
49214: GO 49168
49216: POP
49217: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
49218: LD_ADDR_EXP 104
49222: PUSH
49223: LD_EXP 104
49227: PPUSH
49228: LD_VAR 0 2
49232: PPUSH
49233: EMPTY
49234: PPUSH
49235: CALL_OW 1
49239: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
49240: LD_VAR 0 2
49244: PPUSH
49245: LD_INT 101
49247: PPUSH
49248: CALL 44046 0 2
// continue ;
49252: GO 49055
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
49254: LD_ADDR_EXP 108
49258: PUSH
49259: LD_EXP 108
49263: PPUSH
49264: LD_VAR 0 2
49268: PPUSH
49269: EMPTY
49270: PPUSH
49271: CALL_OW 1
49275: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
49276: LD_VAR 0 2
49280: PPUSH
49281: LD_INT 103
49283: PPUSH
49284: CALL 44046 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
49288: LD_ADDR_VAR 0 5
49292: PUSH
49293: LD_EXP 102
49297: PUSH
49298: LD_VAR 0 2
49302: ARRAY
49303: PUSH
49304: LD_EXP 131
49308: PUSH
49309: LD_VAR 0 2
49313: ARRAY
49314: UNION
49315: PPUSH
49316: LD_INT 2
49318: PUSH
49319: LD_INT 25
49321: PUSH
49322: LD_INT 2
49324: PUSH
49325: EMPTY
49326: LIST
49327: LIST
49328: PUSH
49329: LD_INT 25
49331: PUSH
49332: LD_INT 16
49334: PUSH
49335: EMPTY
49336: LIST
49337: LIST
49338: PUSH
49339: EMPTY
49340: LIST
49341: LIST
49342: LIST
49343: PUSH
49344: EMPTY
49345: LIST
49346: PPUSH
49347: CALL_OW 72
49351: ST_TO_ADDR
// if mc_need_heal [ i ] then
49352: LD_EXP 105
49356: PUSH
49357: LD_VAR 0 2
49361: ARRAY
49362: IFFALSE 49406
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
49364: LD_ADDR_VAR 0 5
49368: PUSH
49369: LD_VAR 0 5
49373: PUSH
49374: LD_EXP 105
49378: PUSH
49379: LD_VAR 0 2
49383: ARRAY
49384: PUSH
49385: LD_INT 1
49387: ARRAY
49388: PUSH
49389: LD_EXP 105
49393: PUSH
49394: LD_VAR 0 2
49398: ARRAY
49399: PUSH
49400: LD_INT 2
49402: ARRAY
49403: UNION
49404: DIFF
49405: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
49406: LD_ADDR_VAR 0 6
49410: PUSH
49411: LD_EXP 121
49415: PUSH
49416: LD_VAR 0 2
49420: ARRAY
49421: PPUSH
49422: LD_INT 2
49424: PUSH
49425: LD_INT 34
49427: PUSH
49428: LD_INT 13
49430: PUSH
49431: EMPTY
49432: LIST
49433: LIST
49434: PUSH
49435: LD_INT 34
49437: PUSH
49438: LD_INT 52
49440: PUSH
49441: EMPTY
49442: LIST
49443: LIST
49444: PUSH
49445: LD_INT 34
49447: PUSH
49448: LD_INT 88
49450: PUSH
49451: EMPTY
49452: LIST
49453: LIST
49454: PUSH
49455: EMPTY
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: PPUSH
49461: CALL_OW 72
49465: ST_TO_ADDR
// if cranes then
49466: LD_VAR 0 6
49470: IFFALSE 49642
// begin for j in cranes do
49472: LD_ADDR_VAR 0 3
49476: PUSH
49477: LD_VAR 0 6
49481: PUSH
49482: FOR_IN
49483: IFFALSE 49640
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
49485: LD_VAR 0 3
49489: PPUSH
49490: CALL_OW 256
49494: PUSH
49495: LD_INT 1000
49497: EQUAL
49498: IFFALSE 49512
49500: PUSH
49501: LD_VAR 0 3
49505: PPUSH
49506: CALL_OW 314
49510: NOT
49511: AND
49512: IFFALSE 49578
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
49514: LD_ADDR_VAR 0 8
49518: PUSH
49519: LD_EXP 103
49523: PUSH
49524: LD_VAR 0 2
49528: ARRAY
49529: PPUSH
49530: LD_VAR 0 3
49534: PPUSH
49535: CALL_OW 74
49539: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
49540: LD_VAR 0 8
49544: PPUSH
49545: LD_INT 16
49547: PPUSH
49548: CALL 79060 0 2
49552: PUSH
49553: LD_INT 4
49555: ARRAY
49556: PUSH
49557: LD_INT 10
49559: LESS
49560: IFFALSE 49576
// ComRepairBuilding ( j , to_repair ) ;
49562: LD_VAR 0 3
49566: PPUSH
49567: LD_VAR 0 8
49571: PPUSH
49572: CALL_OW 130
// end else
49576: GO 49638
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
49578: LD_VAR 0 3
49582: PPUSH
49583: CALL_OW 256
49587: PUSH
49588: LD_INT 500
49590: LESS
49591: IFFALSE 49616
49593: PUSH
49594: LD_VAR 0 3
49598: PPUSH
49599: LD_EXP 126
49603: PUSH
49604: LD_VAR 0 2
49608: ARRAY
49609: PPUSH
49610: CALL_OW 308
49614: NOT
49615: AND
49616: IFFALSE 49638
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49618: LD_VAR 0 3
49622: PPUSH
49623: LD_EXP 126
49627: PUSH
49628: LD_VAR 0 2
49632: ARRAY
49633: PPUSH
49634: CALL_OW 113
// end ;
49638: GO 49482
49640: POP
49641: POP
// end ; if tmp > 3 then
49642: LD_VAR 0 5
49646: PUSH
49647: LD_INT 3
49649: GREATER
49650: IFFALSE 49670
// tmp := ShrinkArray ( tmp , 4 ) ;
49652: LD_ADDR_VAR 0 5
49656: PUSH
49657: LD_VAR 0 5
49661: PPUSH
49662: LD_INT 4
49664: PPUSH
49665: CALL 109454 0 2
49669: ST_TO_ADDR
// if not tmp then
49670: LD_VAR 0 5
49674: NOT
49675: IFFALSE 49679
// continue ;
49677: GO 49055
// for j in tmp do
49679: LD_ADDR_VAR 0 3
49683: PUSH
49684: LD_VAR 0 5
49688: PUSH
49689: FOR_IN
49690: IFFALSE 49949
// begin if IsInUnit ( j ) then
49692: LD_VAR 0 3
49696: PPUSH
49697: CALL_OW 310
49701: IFFALSE 49712
// ComExitBuilding ( j ) ;
49703: LD_VAR 0 3
49707: PPUSH
49708: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
49712: LD_VAR 0 3
49716: PUSH
49717: LD_EXP 104
49721: PUSH
49722: LD_VAR 0 2
49726: ARRAY
49727: IN
49728: NOT
49729: IFFALSE 49787
// begin SetTag ( j , 101 ) ;
49731: LD_VAR 0 3
49735: PPUSH
49736: LD_INT 101
49738: PPUSH
49739: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
49743: LD_ADDR_EXP 104
49747: PUSH
49748: LD_EXP 104
49752: PPUSH
49753: LD_VAR 0 2
49757: PUSH
49758: LD_EXP 104
49762: PUSH
49763: LD_VAR 0 2
49767: ARRAY
49768: PUSH
49769: LD_INT 1
49771: PLUS
49772: PUSH
49773: EMPTY
49774: LIST
49775: LIST
49776: PPUSH
49777: LD_VAR 0 3
49781: PPUSH
49782: CALL 76081 0 3
49786: ST_TO_ADDR
// end ; wait ( 1 ) ;
49787: LD_INT 1
49789: PPUSH
49790: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
49794: LD_ADDR_VAR 0 7
49798: PUSH
49799: LD_EXP 103
49803: PUSH
49804: LD_VAR 0 2
49808: ARRAY
49809: ST_TO_ADDR
// if mc_scan [ i ] then
49810: LD_EXP 125
49814: PUSH
49815: LD_VAR 0 2
49819: ARRAY
49820: IFFALSE 49882
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
49822: LD_ADDR_VAR 0 7
49826: PUSH
49827: LD_EXP 103
49831: PUSH
49832: LD_VAR 0 2
49836: ARRAY
49837: PPUSH
49838: LD_INT 3
49840: PUSH
49841: LD_INT 30
49843: PUSH
49844: LD_INT 32
49846: PUSH
49847: EMPTY
49848: LIST
49849: LIST
49850: PUSH
49851: LD_INT 30
49853: PUSH
49854: LD_INT 33
49856: PUSH
49857: EMPTY
49858: LIST
49859: LIST
49860: PUSH
49861: LD_INT 30
49863: PUSH
49864: LD_INT 31
49866: PUSH
49867: EMPTY
49868: LIST
49869: LIST
49870: PUSH
49871: EMPTY
49872: LIST
49873: LIST
49874: LIST
49875: LIST
49876: PPUSH
49877: CALL_OW 72
49881: ST_TO_ADDR
// if not to_repair_tmp then
49882: LD_VAR 0 7
49886: NOT
49887: IFFALSE 49891
// continue ;
49889: GO 49689
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
49891: LD_ADDR_VAR 0 8
49895: PUSH
49896: LD_VAR 0 7
49900: PPUSH
49901: LD_VAR 0 3
49905: PPUSH
49906: CALL_OW 74
49910: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
49911: LD_VAR 0 8
49915: PPUSH
49916: LD_INT 16
49918: PPUSH
49919: CALL 79060 0 2
49923: PUSH
49924: LD_INT 4
49926: ARRAY
49927: PUSH
49928: LD_INT 14
49930: LESS
49931: IFFALSE 49947
// ComRepairBuilding ( j , to_repair ) ;
49933: LD_VAR 0 3
49937: PPUSH
49938: LD_VAR 0 8
49942: PPUSH
49943: CALL_OW 130
// end ;
49947: GO 49689
49949: POP
49950: POP
// end ;
49951: GO 49055
49953: POP
49954: POP
// end ;
49955: LD_VAR 0 1
49959: RET
// export function MC_Heal ; var i , j , tmp ; begin
49960: LD_INT 0
49962: PPUSH
49963: PPUSH
49964: PPUSH
49965: PPUSH
// if not mc_bases then
49966: LD_EXP 102
49970: NOT
49971: IFFALSE 49975
// exit ;
49973: GO 50381
// for i = 1 to mc_bases do
49975: LD_ADDR_VAR 0 2
49979: PUSH
49980: DOUBLE
49981: LD_INT 1
49983: DEC
49984: ST_TO_ADDR
49985: LD_EXP 102
49989: PUSH
49990: FOR_TO
49991: IFFALSE 50379
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
49993: LD_EXP 105
49997: PUSH
49998: LD_VAR 0 2
50002: ARRAY
50003: PUSH
50004: LD_INT 1
50006: ARRAY
50007: NOT
50008: IFFALSE 50027
50010: PUSH
50011: LD_EXP 105
50015: PUSH
50016: LD_VAR 0 2
50020: ARRAY
50021: PUSH
50022: LD_INT 2
50024: ARRAY
50025: NOT
50026: AND
50027: IFFALSE 50065
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
50029: LD_ADDR_EXP 106
50033: PUSH
50034: LD_EXP 106
50038: PPUSH
50039: LD_VAR 0 2
50043: PPUSH
50044: EMPTY
50045: PPUSH
50046: CALL_OW 1
50050: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
50051: LD_VAR 0 2
50055: PPUSH
50056: LD_INT 102
50058: PPUSH
50059: CALL 44046 0 2
// continue ;
50063: GO 49990
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
50065: LD_ADDR_VAR 0 4
50069: PUSH
50070: LD_EXP 102
50074: PUSH
50075: LD_VAR 0 2
50079: ARRAY
50080: PPUSH
50081: LD_INT 25
50083: PUSH
50084: LD_INT 4
50086: PUSH
50087: EMPTY
50088: LIST
50089: LIST
50090: PPUSH
50091: CALL_OW 72
50095: ST_TO_ADDR
// if not tmp then
50096: LD_VAR 0 4
50100: NOT
50101: IFFALSE 50105
// continue ;
50103: GO 49990
// if mc_taming [ i ] then
50105: LD_EXP 133
50109: PUSH
50110: LD_VAR 0 2
50114: ARRAY
50115: IFFALSE 50139
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
50117: LD_ADDR_EXP 133
50121: PUSH
50122: LD_EXP 133
50126: PPUSH
50127: LD_VAR 0 2
50131: PPUSH
50132: EMPTY
50133: PPUSH
50134: CALL_OW 1
50138: ST_TO_ADDR
// for j in tmp do
50139: LD_ADDR_VAR 0 3
50143: PUSH
50144: LD_VAR 0 4
50148: PUSH
50149: FOR_IN
50150: IFFALSE 50375
// begin if IsInUnit ( j ) then
50152: LD_VAR 0 3
50156: PPUSH
50157: CALL_OW 310
50161: IFFALSE 50172
// ComExitBuilding ( j ) ;
50163: LD_VAR 0 3
50167: PPUSH
50168: CALL_OW 122
// if not j in mc_healers [ i ] then
50172: LD_VAR 0 3
50176: PUSH
50177: LD_EXP 106
50181: PUSH
50182: LD_VAR 0 2
50186: ARRAY
50187: IN
50188: NOT
50189: IFFALSE 50235
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
50191: LD_ADDR_EXP 106
50195: PUSH
50196: LD_EXP 106
50200: PPUSH
50201: LD_VAR 0 2
50205: PUSH
50206: LD_EXP 106
50210: PUSH
50211: LD_VAR 0 2
50215: ARRAY
50216: PUSH
50217: LD_INT 1
50219: PLUS
50220: PUSH
50221: EMPTY
50222: LIST
50223: LIST
50224: PPUSH
50225: LD_VAR 0 3
50229: PPUSH
50230: CALL 76081 0 3
50234: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
50235: LD_VAR 0 3
50239: PPUSH
50240: CALL_OW 110
50244: PUSH
50245: LD_INT 102
50247: NONEQUAL
50248: IFFALSE 50262
// SetTag ( j , 102 ) ;
50250: LD_VAR 0 3
50254: PPUSH
50255: LD_INT 102
50257: PPUSH
50258: CALL_OW 109
// Wait ( 3 ) ;
50262: LD_INT 3
50264: PPUSH
50265: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
50269: LD_EXP 105
50273: PUSH
50274: LD_VAR 0 2
50278: ARRAY
50279: PUSH
50280: LD_INT 1
50282: ARRAY
50283: IFFALSE 50315
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
50285: LD_VAR 0 3
50289: PPUSH
50290: LD_EXP 105
50294: PUSH
50295: LD_VAR 0 2
50299: ARRAY
50300: PUSH
50301: LD_INT 1
50303: ARRAY
50304: PUSH
50305: LD_INT 1
50307: ARRAY
50308: PPUSH
50309: CALL_OW 128
50313: GO 50373
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
50315: LD_VAR 0 3
50319: PPUSH
50320: CALL_OW 314
50324: NOT
50325: IFFALSE 50343
50327: PUSH
50328: LD_EXP 105
50332: PUSH
50333: LD_VAR 0 2
50337: ARRAY
50338: PUSH
50339: LD_INT 2
50341: ARRAY
50342: AND
50343: IFFALSE 50373
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
50345: LD_VAR 0 3
50349: PPUSH
50350: LD_EXP 105
50354: PUSH
50355: LD_VAR 0 2
50359: ARRAY
50360: PUSH
50361: LD_INT 2
50363: ARRAY
50364: PUSH
50365: LD_INT 1
50367: ARRAY
50368: PPUSH
50369: CALL_OW 128
// end ;
50373: GO 50149
50375: POP
50376: POP
// end ;
50377: GO 49990
50379: POP
50380: POP
// end ;
50381: LD_VAR 0 1
50385: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
50386: LD_INT 0
50388: PPUSH
50389: PPUSH
50390: PPUSH
50391: PPUSH
50392: PPUSH
50393: PPUSH
// if not mc_bases then
50394: LD_EXP 102
50398: NOT
50399: IFFALSE 50403
// exit ;
50401: GO 51574
// for i = 1 to mc_bases do
50403: LD_ADDR_VAR 0 2
50407: PUSH
50408: DOUBLE
50409: LD_INT 1
50411: DEC
50412: ST_TO_ADDR
50413: LD_EXP 102
50417: PUSH
50418: FOR_TO
50419: IFFALSE 51572
// begin if mc_scan [ i ] then
50421: LD_EXP 125
50425: PUSH
50426: LD_VAR 0 2
50430: ARRAY
50431: IFFALSE 50435
// continue ;
50433: GO 50418
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
50435: LD_EXP 107
50439: PUSH
50440: LD_VAR 0 2
50444: ARRAY
50445: NOT
50446: IFFALSE 50461
50448: PUSH
50449: LD_EXP 109
50453: PUSH
50454: LD_VAR 0 2
50458: ARRAY
50459: NOT
50460: AND
50461: IFFALSE 50475
50463: PUSH
50464: LD_EXP 108
50468: PUSH
50469: LD_VAR 0 2
50473: ARRAY
50474: AND
50475: IFFALSE 50513
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
50477: LD_ADDR_EXP 108
50481: PUSH
50482: LD_EXP 108
50486: PPUSH
50487: LD_VAR 0 2
50491: PPUSH
50492: EMPTY
50493: PPUSH
50494: CALL_OW 1
50498: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
50499: LD_VAR 0 2
50503: PPUSH
50504: LD_INT 103
50506: PPUSH
50507: CALL 44046 0 2
// continue ;
50511: GO 50418
// end ; if mc_construct_list [ i ] then
50513: LD_EXP 109
50517: PUSH
50518: LD_VAR 0 2
50522: ARRAY
50523: IFFALSE 50743
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
50525: LD_ADDR_VAR 0 5
50529: PUSH
50530: LD_EXP 102
50534: PUSH
50535: LD_VAR 0 2
50539: ARRAY
50540: PPUSH
50541: LD_INT 25
50543: PUSH
50544: LD_INT 2
50546: PUSH
50547: EMPTY
50548: LIST
50549: LIST
50550: PPUSH
50551: CALL_OW 72
50555: PUSH
50556: LD_EXP 104
50560: PUSH
50561: LD_VAR 0 2
50565: ARRAY
50566: DIFF
50567: ST_TO_ADDR
// if not tmp then
50568: LD_VAR 0 5
50572: NOT
50573: IFFALSE 50577
// continue ;
50575: GO 50418
// for j in tmp do
50577: LD_ADDR_VAR 0 3
50581: PUSH
50582: LD_VAR 0 5
50586: PUSH
50587: FOR_IN
50588: IFFALSE 50739
// begin if not mc_builders [ i ] then
50590: LD_EXP 108
50594: PUSH
50595: LD_VAR 0 2
50599: ARRAY
50600: NOT
50601: IFFALSE 50659
// begin SetTag ( j , 103 ) ;
50603: LD_VAR 0 3
50607: PPUSH
50608: LD_INT 103
50610: PPUSH
50611: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
50615: LD_ADDR_EXP 108
50619: PUSH
50620: LD_EXP 108
50624: PPUSH
50625: LD_VAR 0 2
50629: PUSH
50630: LD_EXP 108
50634: PUSH
50635: LD_VAR 0 2
50639: ARRAY
50640: PUSH
50641: LD_INT 1
50643: PLUS
50644: PUSH
50645: EMPTY
50646: LIST
50647: LIST
50648: PPUSH
50649: LD_VAR 0 3
50653: PPUSH
50654: CALL 76081 0 3
50658: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
50659: LD_VAR 0 3
50663: PPUSH
50664: CALL_OW 310
50668: IFFALSE 50679
// ComExitBuilding ( j ) ;
50670: LD_VAR 0 3
50674: PPUSH
50675: CALL_OW 122
// wait ( 3 ) ;
50679: LD_INT 3
50681: PPUSH
50682: CALL_OW 67
// if not mc_construct_list [ i ] then
50686: LD_EXP 109
50690: PUSH
50691: LD_VAR 0 2
50695: ARRAY
50696: NOT
50697: IFFALSE 50701
// break ;
50699: GO 50739
// if not HasTask ( j ) then
50701: LD_VAR 0 3
50705: PPUSH
50706: CALL_OW 314
50710: NOT
50711: IFFALSE 50737
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
50713: LD_VAR 0 3
50717: PPUSH
50718: LD_EXP 109
50722: PUSH
50723: LD_VAR 0 2
50727: ARRAY
50728: PUSH
50729: LD_INT 1
50731: ARRAY
50732: PPUSH
50733: CALL 79333 0 2
// end ;
50737: GO 50587
50739: POP
50740: POP
// end else
50741: GO 51570
// if mc_build_list [ i ] then
50743: LD_EXP 107
50747: PUSH
50748: LD_VAR 0 2
50752: ARRAY
50753: IFFALSE 51570
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
50755: LD_EXP 107
50759: PUSH
50760: LD_VAR 0 2
50764: ARRAY
50765: PUSH
50766: LD_INT 1
50768: ARRAY
50769: PUSH
50770: LD_INT 1
50772: ARRAY
50773: PPUSH
50774: CALL 79157 0 1
50778: IFFALSE 50826
50780: PUSH
50781: LD_EXP 102
50785: PUSH
50786: LD_VAR 0 2
50790: ARRAY
50791: PPUSH
50792: LD_INT 2
50794: PUSH
50795: LD_INT 30
50797: PUSH
50798: LD_INT 2
50800: PUSH
50801: EMPTY
50802: LIST
50803: LIST
50804: PUSH
50805: LD_INT 30
50807: PUSH
50808: LD_INT 3
50810: PUSH
50811: EMPTY
50812: LIST
50813: LIST
50814: PUSH
50815: EMPTY
50816: LIST
50817: LIST
50818: LIST
50819: PPUSH
50820: CALL_OW 72
50824: NOT
50825: AND
50826: IFFALSE 50931
// begin for j = 1 to mc_build_list [ i ] do
50828: LD_ADDR_VAR 0 3
50832: PUSH
50833: DOUBLE
50834: LD_INT 1
50836: DEC
50837: ST_TO_ADDR
50838: LD_EXP 107
50842: PUSH
50843: LD_VAR 0 2
50847: ARRAY
50848: PUSH
50849: FOR_TO
50850: IFFALSE 50929
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
50852: LD_EXP 107
50856: PUSH
50857: LD_VAR 0 2
50861: ARRAY
50862: PUSH
50863: LD_VAR 0 3
50867: ARRAY
50868: PUSH
50869: LD_INT 1
50871: ARRAY
50872: PUSH
50873: LD_INT 2
50875: EQUAL
50876: IFFALSE 50927
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
50878: LD_ADDR_EXP 107
50882: PUSH
50883: LD_EXP 107
50887: PPUSH
50888: LD_VAR 0 2
50892: PPUSH
50893: LD_EXP 107
50897: PUSH
50898: LD_VAR 0 2
50902: ARRAY
50903: PPUSH
50904: LD_VAR 0 3
50908: PPUSH
50909: LD_INT 1
50911: PPUSH
50912: LD_INT 0
50914: PPUSH
50915: CALL 75489 0 4
50919: PPUSH
50920: CALL_OW 1
50924: ST_TO_ADDR
// break ;
50925: GO 50929
// end ;
50927: GO 50849
50929: POP
50930: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
50931: LD_ADDR_VAR 0 6
50935: PUSH
50936: LD_EXP 102
50940: PUSH
50941: LD_VAR 0 2
50945: ARRAY
50946: PPUSH
50947: LD_INT 2
50949: PUSH
50950: LD_INT 30
50952: PUSH
50953: LD_INT 0
50955: PUSH
50956: EMPTY
50957: LIST
50958: LIST
50959: PUSH
50960: LD_INT 30
50962: PUSH
50963: LD_INT 1
50965: PUSH
50966: EMPTY
50967: LIST
50968: LIST
50969: PUSH
50970: EMPTY
50971: LIST
50972: LIST
50973: LIST
50974: PPUSH
50975: CALL_OW 72
50979: ST_TO_ADDR
// for k := 1 to depot do
50980: LD_ADDR_VAR 0 4
50984: PUSH
50985: DOUBLE
50986: LD_INT 1
50988: DEC
50989: ST_TO_ADDR
50990: LD_VAR 0 6
50994: PUSH
50995: FOR_TO
50996: IFFALSE 51568
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
50998: LD_EXP 107
51002: PUSH
51003: LD_VAR 0 2
51007: ARRAY
51008: PUSH
51009: LD_INT 1
51011: ARRAY
51012: PUSH
51013: LD_INT 1
51015: ARRAY
51016: PUSH
51017: LD_INT 0
51019: EQUAL
51020: IFTRUE 51115
51022: PUSH
51023: LD_VAR 0 6
51027: PUSH
51028: LD_VAR 0 4
51032: ARRAY
51033: PPUSH
51034: LD_EXP 107
51038: PUSH
51039: LD_VAR 0 2
51043: ARRAY
51044: PUSH
51045: LD_INT 1
51047: ARRAY
51048: PUSH
51049: LD_INT 1
51051: ARRAY
51052: PPUSH
51053: LD_EXP 107
51057: PUSH
51058: LD_VAR 0 2
51062: ARRAY
51063: PUSH
51064: LD_INT 1
51066: ARRAY
51067: PUSH
51068: LD_INT 2
51070: ARRAY
51071: PPUSH
51072: LD_EXP 107
51076: PUSH
51077: LD_VAR 0 2
51081: ARRAY
51082: PUSH
51083: LD_INT 1
51085: ARRAY
51086: PUSH
51087: LD_INT 3
51089: ARRAY
51090: PPUSH
51091: LD_EXP 107
51095: PUSH
51096: LD_VAR 0 2
51100: ARRAY
51101: PUSH
51102: LD_INT 1
51104: ARRAY
51105: PUSH
51106: LD_INT 4
51108: ARRAY
51109: PPUSH
51110: CALL 84637 0 5
51114: OR
51115: IFFALSE 51396
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
51117: LD_ADDR_VAR 0 5
51121: PUSH
51122: LD_EXP 102
51126: PUSH
51127: LD_VAR 0 2
51131: ARRAY
51132: PPUSH
51133: LD_INT 25
51135: PUSH
51136: LD_INT 2
51138: PUSH
51139: EMPTY
51140: LIST
51141: LIST
51142: PPUSH
51143: CALL_OW 72
51147: PUSH
51148: LD_EXP 104
51152: PUSH
51153: LD_VAR 0 2
51157: ARRAY
51158: DIFF
51159: ST_TO_ADDR
// if not tmp then
51160: LD_VAR 0 5
51164: NOT
51165: IFFALSE 51169
// continue ;
51167: GO 50995
// for j in tmp do
51169: LD_ADDR_VAR 0 3
51173: PUSH
51174: LD_VAR 0 5
51178: PUSH
51179: FOR_IN
51180: IFFALSE 51392
// begin if not mc_builders [ i ] then
51182: LD_EXP 108
51186: PUSH
51187: LD_VAR 0 2
51191: ARRAY
51192: NOT
51193: IFFALSE 51251
// begin SetTag ( j , 103 ) ;
51195: LD_VAR 0 3
51199: PPUSH
51200: LD_INT 103
51202: PPUSH
51203: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
51207: LD_ADDR_EXP 108
51211: PUSH
51212: LD_EXP 108
51216: PPUSH
51217: LD_VAR 0 2
51221: PUSH
51222: LD_EXP 108
51226: PUSH
51227: LD_VAR 0 2
51231: ARRAY
51232: PUSH
51233: LD_INT 1
51235: PLUS
51236: PUSH
51237: EMPTY
51238: LIST
51239: LIST
51240: PPUSH
51241: LD_VAR 0 3
51245: PPUSH
51246: CALL 76081 0 3
51250: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
51251: LD_VAR 0 3
51255: PPUSH
51256: CALL_OW 310
51260: IFFALSE 51271
// ComExitBuilding ( j ) ;
51262: LD_VAR 0 3
51266: PPUSH
51267: CALL_OW 122
// wait ( 3 ) ;
51271: LD_INT 3
51273: PPUSH
51274: CALL_OW 67
// if not mc_build_list [ i ] then
51278: LD_EXP 107
51282: PUSH
51283: LD_VAR 0 2
51287: ARRAY
51288: NOT
51289: IFFALSE 51293
// break ;
51291: GO 51392
// if not HasTask ( j ) then
51293: LD_VAR 0 3
51297: PPUSH
51298: CALL_OW 314
51302: NOT
51303: IFFALSE 51390
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
51305: LD_VAR 0 3
51309: PPUSH
51310: LD_EXP 107
51314: PUSH
51315: LD_VAR 0 2
51319: ARRAY
51320: PUSH
51321: LD_INT 1
51323: ARRAY
51324: PUSH
51325: LD_INT 1
51327: ARRAY
51328: PPUSH
51329: LD_EXP 107
51333: PUSH
51334: LD_VAR 0 2
51338: ARRAY
51339: PUSH
51340: LD_INT 1
51342: ARRAY
51343: PUSH
51344: LD_INT 2
51346: ARRAY
51347: PPUSH
51348: LD_EXP 107
51352: PUSH
51353: LD_VAR 0 2
51357: ARRAY
51358: PUSH
51359: LD_INT 1
51361: ARRAY
51362: PUSH
51363: LD_INT 3
51365: ARRAY
51366: PPUSH
51367: LD_EXP 107
51371: PUSH
51372: LD_VAR 0 2
51376: ARRAY
51377: PUSH
51378: LD_INT 1
51380: ARRAY
51381: PUSH
51382: LD_INT 4
51384: ARRAY
51385: PPUSH
51386: CALL_OW 145
// end ;
51390: GO 51179
51392: POP
51393: POP
// end else
51394: GO 51566
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
51396: LD_EXP 102
51400: PUSH
51401: LD_VAR 0 2
51405: ARRAY
51406: PPUSH
51407: LD_EXP 107
51411: PUSH
51412: LD_VAR 0 2
51416: ARRAY
51417: PUSH
51418: LD_INT 1
51420: ARRAY
51421: PUSH
51422: LD_INT 1
51424: ARRAY
51425: PPUSH
51426: LD_EXP 107
51430: PUSH
51431: LD_VAR 0 2
51435: ARRAY
51436: PUSH
51437: LD_INT 1
51439: ARRAY
51440: PUSH
51441: LD_INT 2
51443: ARRAY
51444: PPUSH
51445: LD_EXP 107
51449: PUSH
51450: LD_VAR 0 2
51454: ARRAY
51455: PUSH
51456: LD_INT 1
51458: ARRAY
51459: PUSH
51460: LD_INT 3
51462: ARRAY
51463: PPUSH
51464: LD_EXP 107
51468: PUSH
51469: LD_VAR 0 2
51473: ARRAY
51474: PUSH
51475: LD_INT 1
51477: ARRAY
51478: PUSH
51479: LD_INT 4
51481: ARRAY
51482: PPUSH
51483: LD_EXP 102
51487: PUSH
51488: LD_VAR 0 2
51492: ARRAY
51493: PPUSH
51494: LD_INT 21
51496: PUSH
51497: LD_INT 3
51499: PUSH
51500: EMPTY
51501: LIST
51502: LIST
51503: PPUSH
51504: CALL_OW 72
51508: PPUSH
51509: EMPTY
51510: PPUSH
51511: CALL 83373 0 7
51515: NOT
51516: IFFALSE 51566
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
51518: LD_ADDR_EXP 107
51522: PUSH
51523: LD_EXP 107
51527: PPUSH
51528: LD_VAR 0 2
51532: PPUSH
51533: LD_EXP 107
51537: PUSH
51538: LD_VAR 0 2
51542: ARRAY
51543: PPUSH
51544: LD_INT 1
51546: PPUSH
51547: LD_INT 1
51549: NEG
51550: PPUSH
51551: LD_INT 0
51553: PPUSH
51554: CALL 75489 0 4
51558: PPUSH
51559: CALL_OW 1
51563: ST_TO_ADDR
// continue ;
51564: GO 50995
// end ; end ;
51566: GO 50995
51568: POP
51569: POP
// end ; end ;
51570: GO 50418
51572: POP
51573: POP
// end ;
51574: LD_VAR 0 1
51578: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
51579: LD_INT 0
51581: PPUSH
51582: PPUSH
51583: PPUSH
51584: PPUSH
51585: PPUSH
51586: PPUSH
// if not mc_bases then
51587: LD_EXP 102
51591: NOT
51592: IFFALSE 51596
// exit ;
51594: GO 52029
// for i = 1 to mc_bases do
51596: LD_ADDR_VAR 0 2
51600: PUSH
51601: DOUBLE
51602: LD_INT 1
51604: DEC
51605: ST_TO_ADDR
51606: LD_EXP 102
51610: PUSH
51611: FOR_TO
51612: IFFALSE 52027
// begin tmp := mc_build_upgrade [ i ] ;
51614: LD_ADDR_VAR 0 4
51618: PUSH
51619: LD_EXP 134
51623: PUSH
51624: LD_VAR 0 2
51628: ARRAY
51629: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
51630: LD_ADDR_VAR 0 6
51634: PUSH
51635: LD_EXP 135
51639: PUSH
51640: LD_VAR 0 2
51644: ARRAY
51645: PPUSH
51646: LD_INT 2
51648: PUSH
51649: LD_INT 30
51651: PUSH
51652: LD_INT 6
51654: PUSH
51655: EMPTY
51656: LIST
51657: LIST
51658: PUSH
51659: LD_INT 30
51661: PUSH
51662: LD_INT 7
51664: PUSH
51665: EMPTY
51666: LIST
51667: LIST
51668: PUSH
51669: EMPTY
51670: LIST
51671: LIST
51672: LIST
51673: PPUSH
51674: CALL_OW 72
51678: ST_TO_ADDR
// if not tmp and not lab then
51679: LD_VAR 0 4
51683: NOT
51684: IFFALSE 51693
51686: PUSH
51687: LD_VAR 0 6
51691: NOT
51692: AND
51693: IFFALSE 51697
// continue ;
51695: GO 51611
// if tmp then
51697: LD_VAR 0 4
51701: IFFALSE 51821
// for j in tmp do
51703: LD_ADDR_VAR 0 3
51707: PUSH
51708: LD_VAR 0 4
51712: PUSH
51713: FOR_IN
51714: IFFALSE 51819
// begin if UpgradeCost ( j ) then
51716: LD_VAR 0 3
51720: PPUSH
51721: CALL 83025 0 1
51725: IFFALSE 51817
// begin ComUpgrade ( j ) ;
51727: LD_VAR 0 3
51731: PPUSH
51732: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
51736: LD_ADDR_EXP 134
51740: PUSH
51741: LD_EXP 134
51745: PPUSH
51746: LD_VAR 0 2
51750: PPUSH
51751: LD_EXP 134
51755: PUSH
51756: LD_VAR 0 2
51760: ARRAY
51761: PUSH
51762: LD_VAR 0 3
51766: DIFF
51767: PPUSH
51768: CALL_OW 1
51772: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51773: LD_ADDR_EXP 109
51777: PUSH
51778: LD_EXP 109
51782: PPUSH
51783: LD_VAR 0 2
51787: PUSH
51788: LD_EXP 109
51792: PUSH
51793: LD_VAR 0 2
51797: ARRAY
51798: PUSH
51799: LD_INT 1
51801: PLUS
51802: PUSH
51803: EMPTY
51804: LIST
51805: LIST
51806: PPUSH
51807: LD_VAR 0 3
51811: PPUSH
51812: CALL 76081 0 3
51816: ST_TO_ADDR
// end ; end ;
51817: GO 51713
51819: POP
51820: POP
// if not lab or not mc_lab_upgrade [ i ] then
51821: LD_VAR 0 6
51825: NOT
51826: IFTRUE 51841
51828: PUSH
51829: LD_EXP 136
51833: PUSH
51834: LD_VAR 0 2
51838: ARRAY
51839: NOT
51840: OR
51841: IFFALSE 51845
// continue ;
51843: GO 51611
// for j in lab do
51845: LD_ADDR_VAR 0 3
51849: PUSH
51850: LD_VAR 0 6
51854: PUSH
51855: FOR_IN
51856: IFFALSE 52023
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
51858: LD_VAR 0 3
51862: PPUSH
51863: CALL_OW 266
51867: PUSH
51868: LD_INT 6
51870: PUSH
51871: LD_INT 7
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: IN
51878: IFFALSE 51895
51880: PUSH
51881: LD_VAR 0 3
51885: PPUSH
51886: CALL_OW 461
51890: PUSH
51891: LD_INT 1
51893: NONEQUAL
51894: AND
51895: IFFALSE 52021
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
51897: LD_VAR 0 3
51901: PPUSH
51902: LD_EXP 136
51906: PUSH
51907: LD_VAR 0 2
51911: ARRAY
51912: PUSH
51913: LD_INT 1
51915: ARRAY
51916: PPUSH
51917: CALL 83234 0 2
51921: IFFALSE 52021
// begin ComCancel ( j ) ;
51923: LD_VAR 0 3
51927: PPUSH
51928: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
51932: LD_VAR 0 3
51936: PPUSH
51937: LD_EXP 136
51941: PUSH
51942: LD_VAR 0 2
51946: ARRAY
51947: PUSH
51948: LD_INT 1
51950: ARRAY
51951: PPUSH
51952: CALL_OW 207
// if not j in mc_construct_list [ i ] then
51956: LD_VAR 0 3
51960: PUSH
51961: LD_EXP 109
51965: PUSH
51966: LD_VAR 0 2
51970: ARRAY
51971: IN
51972: NOT
51973: IFFALSE 52019
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
51975: LD_ADDR_EXP 109
51979: PUSH
51980: LD_EXP 109
51984: PPUSH
51985: LD_VAR 0 2
51989: PUSH
51990: LD_EXP 109
51994: PUSH
51995: LD_VAR 0 2
51999: ARRAY
52000: PUSH
52001: LD_INT 1
52003: PLUS
52004: PUSH
52005: EMPTY
52006: LIST
52007: LIST
52008: PPUSH
52009: LD_VAR 0 3
52013: PPUSH
52014: CALL 76081 0 3
52018: ST_TO_ADDR
// break ;
52019: GO 52023
// end ; end ; end ;
52021: GO 51855
52023: POP
52024: POP
// end ;
52025: GO 51611
52027: POP
52028: POP
// end ;
52029: LD_VAR 0 1
52033: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
52034: LD_INT 0
52036: PPUSH
52037: PPUSH
52038: PPUSH
52039: PPUSH
52040: PPUSH
52041: PPUSH
52042: PPUSH
52043: PPUSH
52044: PPUSH
// if not mc_bases then
52045: LD_EXP 102
52049: NOT
52050: IFFALSE 52054
// exit ;
52052: GO 52461
// for i = 1 to mc_bases do
52054: LD_ADDR_VAR 0 2
52058: PUSH
52059: DOUBLE
52060: LD_INT 1
52062: DEC
52063: ST_TO_ADDR
52064: LD_EXP 102
52068: PUSH
52069: FOR_TO
52070: IFFALSE 52459
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
52072: LD_EXP 110
52076: PUSH
52077: LD_VAR 0 2
52081: ARRAY
52082: NOT
52083: IFTRUE 52113
52085: PUSH
52086: LD_EXP 102
52090: PUSH
52091: LD_VAR 0 2
52095: ARRAY
52096: PPUSH
52097: LD_INT 30
52099: PUSH
52100: LD_INT 3
52102: PUSH
52103: EMPTY
52104: LIST
52105: LIST
52106: PPUSH
52107: CALL_OW 72
52111: NOT
52112: OR
52113: IFFALSE 52117
// continue ;
52115: GO 52069
// busy := false ;
52117: LD_ADDR_VAR 0 8
52121: PUSH
52122: LD_INT 0
52124: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52125: LD_ADDR_VAR 0 4
52129: PUSH
52130: LD_EXP 102
52134: PUSH
52135: LD_VAR 0 2
52139: ARRAY
52140: PPUSH
52141: LD_INT 30
52143: PUSH
52144: LD_INT 3
52146: PUSH
52147: EMPTY
52148: LIST
52149: LIST
52150: PPUSH
52151: CALL_OW 72
52155: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
52156: LD_ADDR_VAR 0 6
52160: PUSH
52161: LD_EXP 110
52165: PUSH
52166: LD_VAR 0 2
52170: ARRAY
52171: PPUSH
52172: LD_INT 2
52174: PUSH
52175: LD_INT 30
52177: PUSH
52178: LD_INT 32
52180: PUSH
52181: EMPTY
52182: LIST
52183: LIST
52184: PUSH
52185: LD_INT 30
52187: PUSH
52188: LD_INT 33
52190: PUSH
52191: EMPTY
52192: LIST
52193: LIST
52194: PUSH
52195: EMPTY
52196: LIST
52197: LIST
52198: LIST
52199: PPUSH
52200: CALL_OW 72
52204: ST_TO_ADDR
// if not t then
52205: LD_VAR 0 6
52209: NOT
52210: IFFALSE 52214
// continue ;
52212: GO 52069
// for j in tmp do
52214: LD_ADDR_VAR 0 3
52218: PUSH
52219: LD_VAR 0 4
52223: PUSH
52224: FOR_IN
52225: IFFALSE 52255
// if not BuildingStatus ( j ) = bs_idle then
52227: LD_VAR 0 3
52231: PPUSH
52232: CALL_OW 461
52236: PUSH
52237: LD_INT 2
52239: EQUAL
52240: NOT
52241: IFFALSE 52253
// begin busy := true ;
52243: LD_ADDR_VAR 0 8
52247: PUSH
52248: LD_INT 1
52250: ST_TO_ADDR
// break ;
52251: GO 52255
// end ;
52253: GO 52224
52255: POP
52256: POP
// if busy then
52257: LD_VAR 0 8
52261: IFFALSE 52265
// continue ;
52263: GO 52069
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
52265: LD_ADDR_VAR 0 7
52269: PUSH
52270: LD_VAR 0 6
52274: PPUSH
52275: LD_INT 35
52277: PUSH
52278: LD_INT 0
52280: PUSH
52281: EMPTY
52282: LIST
52283: LIST
52284: PPUSH
52285: CALL_OW 72
52289: ST_TO_ADDR
// if tw then
52290: LD_VAR 0 7
52294: IFFALSE 52371
// begin tw := tw [ 1 ] ;
52296: LD_ADDR_VAR 0 7
52300: PUSH
52301: LD_VAR 0 7
52305: PUSH
52306: LD_INT 1
52308: ARRAY
52309: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
52310: LD_ADDR_VAR 0 9
52314: PUSH
52315: LD_VAR 0 7
52319: PPUSH
52320: LD_EXP 127
52324: PUSH
52325: LD_VAR 0 2
52329: ARRAY
52330: PPUSH
52331: CALL 81488 0 2
52335: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
52336: LD_EXP 141
52340: PUSH
52341: LD_VAR 0 2
52345: ARRAY
52346: IFFALSE 52369
// if not weapon in mc_allowed_tower_weapons [ i ] then
52348: LD_VAR 0 9
52352: PUSH
52353: LD_EXP 141
52357: PUSH
52358: LD_VAR 0 2
52362: ARRAY
52363: IN
52364: NOT
52365: IFFALSE 52369
// continue ;
52367: GO 52069
// end else
52369: GO 52434
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
52371: LD_ADDR_VAR 0 5
52375: PUSH
52376: LD_EXP 110
52380: PUSH
52381: LD_VAR 0 2
52385: ARRAY
52386: PPUSH
52387: LD_VAR 0 4
52391: PPUSH
52392: CALL 108683 0 2
52396: ST_TO_ADDR
// if not tmp2 then
52397: LD_VAR 0 5
52401: NOT
52402: IFFALSE 52406
// continue ;
52404: GO 52069
// tw := tmp2 [ 1 ] ;
52406: LD_ADDR_VAR 0 7
52410: PUSH
52411: LD_VAR 0 5
52415: PUSH
52416: LD_INT 1
52418: ARRAY
52419: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
52420: LD_ADDR_VAR 0 9
52424: PUSH
52425: LD_VAR 0 5
52429: PUSH
52430: LD_INT 2
52432: ARRAY
52433: ST_TO_ADDR
// end ; if not weapon then
52434: LD_VAR 0 9
52438: NOT
52439: IFFALSE 52443
// continue ;
52441: GO 52069
// ComPlaceWeapon ( tw , weapon ) ;
52443: LD_VAR 0 7
52447: PPUSH
52448: LD_VAR 0 9
52452: PPUSH
52453: CALL_OW 148
// end ;
52457: GO 52069
52459: POP
52460: POP
// end ;
52461: LD_VAR 0 1
52465: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
52466: LD_INT 0
52468: PPUSH
52469: PPUSH
52470: PPUSH
52471: PPUSH
52472: PPUSH
52473: PPUSH
52474: PPUSH
// if not mc_bases then
52475: LD_EXP 102
52479: NOT
52480: IFFALSE 52484
// exit ;
52482: GO 53271
// for i = 1 to mc_bases do
52484: LD_ADDR_VAR 0 2
52488: PUSH
52489: DOUBLE
52490: LD_INT 1
52492: DEC
52493: ST_TO_ADDR
52494: LD_EXP 102
52498: PUSH
52499: FOR_TO
52500: IFFALSE 53269
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
52502: LD_EXP 115
52506: PUSH
52507: LD_VAR 0 2
52511: ARRAY
52512: NOT
52513: IFTRUE 52539
52515: PUSH
52516: LD_EXP 115
52520: PUSH
52521: LD_VAR 0 2
52525: ARRAY
52526: PUSH
52527: LD_EXP 116
52531: PUSH
52532: LD_VAR 0 2
52536: ARRAY
52537: EQUAL
52538: OR
52539: IFTRUE 52553
52541: PUSH
52542: LD_EXP 125
52546: PUSH
52547: LD_VAR 0 2
52551: ARRAY
52552: OR
52553: IFFALSE 52557
// continue ;
52555: GO 52499
// if mc_miners [ i ] then
52557: LD_EXP 116
52561: PUSH
52562: LD_VAR 0 2
52566: ARRAY
52567: IFFALSE 52954
// begin for j = mc_miners [ i ] downto 1 do
52569: LD_ADDR_VAR 0 3
52573: PUSH
52574: DOUBLE
52575: LD_EXP 116
52579: PUSH
52580: LD_VAR 0 2
52584: ARRAY
52585: INC
52586: ST_TO_ADDR
52587: LD_INT 1
52589: PUSH
52590: FOR_DOWNTO
52591: IFFALSE 52952
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
52593: LD_EXP 116
52597: PUSH
52598: LD_VAR 0 2
52602: ARRAY
52603: PUSH
52604: LD_VAR 0 3
52608: ARRAY
52609: PPUSH
52610: CALL_OW 301
52614: IFTRUE 52643
52616: PUSH
52617: LD_EXP 116
52621: PUSH
52622: LD_VAR 0 2
52626: ARRAY
52627: PUSH
52628: LD_VAR 0 3
52632: ARRAY
52633: PPUSH
52634: CALL_OW 257
52638: PUSH
52639: LD_INT 1
52641: NONEQUAL
52642: OR
52643: IFFALSE 52706
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
52645: LD_ADDR_VAR 0 5
52649: PUSH
52650: LD_EXP 116
52654: PUSH
52655: LD_VAR 0 2
52659: ARRAY
52660: PUSH
52661: LD_EXP 116
52665: PUSH
52666: LD_VAR 0 2
52670: ARRAY
52671: PUSH
52672: LD_VAR 0 3
52676: ARRAY
52677: DIFF
52678: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
52679: LD_ADDR_EXP 116
52683: PUSH
52684: LD_EXP 116
52688: PPUSH
52689: LD_VAR 0 2
52693: PPUSH
52694: LD_VAR 0 5
52698: PPUSH
52699: CALL_OW 1
52703: ST_TO_ADDR
// continue ;
52704: GO 52590
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
52706: LD_EXP 116
52710: PUSH
52711: LD_VAR 0 2
52715: ARRAY
52716: PUSH
52717: LD_VAR 0 3
52721: ARRAY
52722: PPUSH
52723: CALL_OW 257
52727: PUSH
52728: LD_INT 1
52730: EQUAL
52731: IFFALSE 52757
52733: PUSH
52734: LD_EXP 116
52738: PUSH
52739: LD_VAR 0 2
52743: ARRAY
52744: PUSH
52745: LD_VAR 0 3
52749: ARRAY
52750: PPUSH
52751: CALL_OW 459
52755: NOT
52756: AND
52757: IFFALSE 52783
52759: PUSH
52760: LD_EXP 116
52764: PUSH
52765: LD_VAR 0 2
52769: ARRAY
52770: PUSH
52771: LD_VAR 0 3
52775: ARRAY
52776: PPUSH
52777: CALL_OW 314
52781: NOT
52782: AND
52783: IFFALSE 52950
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
52785: LD_EXP 116
52789: PUSH
52790: LD_VAR 0 2
52794: ARRAY
52795: PUSH
52796: LD_VAR 0 3
52800: ARRAY
52801: PPUSH
52802: CALL_OW 310
52806: IFFALSE 52829
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
52808: LD_EXP 116
52812: PUSH
52813: LD_VAR 0 2
52817: ARRAY
52818: PUSH
52819: LD_VAR 0 3
52823: ARRAY
52824: PPUSH
52825: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
52829: LD_EXP 116
52833: PUSH
52834: LD_VAR 0 2
52838: ARRAY
52839: PUSH
52840: LD_VAR 0 3
52844: ARRAY
52845: PPUSH
52846: CALL_OW 314
52850: NOT
52851: IFFALSE 52950
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
52853: LD_ADDR_VAR 0 7
52857: PUSH
52858: LD_VAR 0 3
52862: PUSH
52863: LD_EXP 115
52867: PUSH
52868: LD_VAR 0 2
52872: ARRAY
52873: PPUSH
52874: CALL 73163 0 1
52878: MOD
52879: PUSH
52880: LD_INT 1
52882: PLUS
52883: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
52884: LD_EXP 116
52888: PUSH
52889: LD_VAR 0 2
52893: ARRAY
52894: PUSH
52895: LD_VAR 0 3
52899: ARRAY
52900: PPUSH
52901: LD_EXP 115
52905: PUSH
52906: LD_VAR 0 2
52910: ARRAY
52911: PUSH
52912: LD_VAR 0 7
52916: ARRAY
52917: PUSH
52918: LD_INT 1
52920: ARRAY
52921: PPUSH
52922: LD_EXP 115
52926: PUSH
52927: LD_VAR 0 2
52931: ARRAY
52932: PUSH
52933: LD_VAR 0 7
52937: ARRAY
52938: PUSH
52939: LD_INT 2
52941: ARRAY
52942: PPUSH
52943: LD_INT 0
52945: PPUSH
52946: CALL_OW 193
// end ; end ; end ;
52950: GO 52590
52952: POP
52953: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
52954: LD_ADDR_VAR 0 5
52958: PUSH
52959: LD_EXP 102
52963: PUSH
52964: LD_VAR 0 2
52968: ARRAY
52969: PPUSH
52970: LD_INT 2
52972: PUSH
52973: LD_INT 30
52975: PUSH
52976: LD_INT 4
52978: PUSH
52979: EMPTY
52980: LIST
52981: LIST
52982: PUSH
52983: LD_INT 30
52985: PUSH
52986: LD_INT 5
52988: PUSH
52989: EMPTY
52990: LIST
52991: LIST
52992: PUSH
52993: LD_INT 30
52995: PUSH
52996: LD_INT 32
52998: PUSH
52999: EMPTY
53000: LIST
53001: LIST
53002: PUSH
53003: EMPTY
53004: LIST
53005: LIST
53006: LIST
53007: LIST
53008: PPUSH
53009: CALL_OW 72
53013: ST_TO_ADDR
// if not tmp then
53014: LD_VAR 0 5
53018: NOT
53019: IFFALSE 53023
// continue ;
53021: GO 52499
// list := [ ] ;
53023: LD_ADDR_VAR 0 6
53027: PUSH
53028: EMPTY
53029: ST_TO_ADDR
// for j in tmp do
53030: LD_ADDR_VAR 0 3
53034: PUSH
53035: LD_VAR 0 5
53039: PUSH
53040: FOR_IN
53041: IFFALSE 53112
// begin for k in UnitsInside ( j ) do
53043: LD_ADDR_VAR 0 4
53047: PUSH
53048: LD_VAR 0 3
53052: PPUSH
53053: CALL_OW 313
53057: PUSH
53058: FOR_IN
53059: IFFALSE 53108
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
53061: LD_VAR 0 4
53065: PPUSH
53066: CALL_OW 257
53070: PUSH
53071: LD_INT 1
53073: EQUAL
53074: IFFALSE 53088
53076: PUSH
53077: LD_VAR 0 4
53081: PPUSH
53082: CALL_OW 459
53086: NOT
53087: AND
53088: IFFALSE 53106
// list := list ^ k ;
53090: LD_ADDR_VAR 0 6
53094: PUSH
53095: LD_VAR 0 6
53099: PUSH
53100: LD_VAR 0 4
53104: ADD
53105: ST_TO_ADDR
53106: GO 53058
53108: POP
53109: POP
// end ;
53110: GO 53040
53112: POP
53113: POP
// list := list diff mc_miners [ i ] ;
53114: LD_ADDR_VAR 0 6
53118: PUSH
53119: LD_VAR 0 6
53123: PUSH
53124: LD_EXP 116
53128: PUSH
53129: LD_VAR 0 2
53133: ARRAY
53134: DIFF
53135: ST_TO_ADDR
// if not list then
53136: LD_VAR 0 6
53140: NOT
53141: IFFALSE 53145
// continue ;
53143: GO 52499
// k := mc_mines [ i ] - mc_miners [ i ] ;
53145: LD_ADDR_VAR 0 4
53149: PUSH
53150: LD_EXP 115
53154: PUSH
53155: LD_VAR 0 2
53159: ARRAY
53160: PUSH
53161: LD_EXP 116
53165: PUSH
53166: LD_VAR 0 2
53170: ARRAY
53171: MINUS
53172: ST_TO_ADDR
// if k > list then
53173: LD_VAR 0 4
53177: PUSH
53178: LD_VAR 0 6
53182: GREATER
53183: IFFALSE 53195
// k := list ;
53185: LD_ADDR_VAR 0 4
53189: PUSH
53190: LD_VAR 0 6
53194: ST_TO_ADDR
// for j = 1 to k do
53195: LD_ADDR_VAR 0 3
53199: PUSH
53200: DOUBLE
53201: LD_INT 1
53203: DEC
53204: ST_TO_ADDR
53205: LD_VAR 0 4
53209: PUSH
53210: FOR_TO
53211: IFFALSE 53265
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
53213: LD_ADDR_EXP 116
53217: PUSH
53218: LD_EXP 116
53222: PPUSH
53223: LD_VAR 0 2
53227: PUSH
53228: LD_EXP 116
53232: PUSH
53233: LD_VAR 0 2
53237: ARRAY
53238: PUSH
53239: LD_INT 1
53241: PLUS
53242: PUSH
53243: EMPTY
53244: LIST
53245: LIST
53246: PPUSH
53247: LD_VAR 0 6
53251: PUSH
53252: LD_VAR 0 3
53256: ARRAY
53257: PPUSH
53258: CALL 76081 0 3
53262: ST_TO_ADDR
53263: GO 53210
53265: POP
53266: POP
// end ;
53267: GO 52499
53269: POP
53270: POP
// end ;
53271: LD_VAR 0 1
53275: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
53276: LD_INT 0
53278: PPUSH
53279: PPUSH
53280: PPUSH
53281: PPUSH
53282: PPUSH
53283: PPUSH
53284: PPUSH
53285: PPUSH
53286: PPUSH
53287: PPUSH
53288: PPUSH
// if not mc_bases then
53289: LD_EXP 102
53293: NOT
53294: IFFALSE 53298
// exit ;
53296: GO 55145
// for i = 1 to mc_bases do
53298: LD_ADDR_VAR 0 2
53302: PUSH
53303: DOUBLE
53304: LD_INT 1
53306: DEC
53307: ST_TO_ADDR
53308: LD_EXP 102
53312: PUSH
53313: FOR_TO
53314: IFFALSE 55143
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
53316: LD_EXP 102
53320: PUSH
53321: LD_VAR 0 2
53325: ARRAY
53326: NOT
53327: IFTRUE 53341
53329: PUSH
53330: LD_EXP 109
53334: PUSH
53335: LD_VAR 0 2
53339: ARRAY
53340: OR
53341: IFFALSE 53345
// continue ;
53343: GO 53313
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
53345: LD_EXP 118
53349: PUSH
53350: LD_VAR 0 2
53354: ARRAY
53355: NOT
53356: IFFALSE 53370
53358: PUSH
53359: LD_EXP 119
53363: PUSH
53364: LD_VAR 0 2
53368: ARRAY
53369: AND
53370: IFFALSE 53408
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53372: LD_ADDR_EXP 119
53376: PUSH
53377: LD_EXP 119
53381: PPUSH
53382: LD_VAR 0 2
53386: PPUSH
53387: EMPTY
53388: PPUSH
53389: CALL_OW 1
53393: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
53394: LD_VAR 0 2
53398: PPUSH
53399: LD_INT 107
53401: PPUSH
53402: CALL 44046 0 2
// continue ;
53406: GO 53313
// end ; target := [ ] ;
53408: LD_ADDR_VAR 0 7
53412: PUSH
53413: EMPTY
53414: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53415: LD_ADDR_VAR 0 6
53419: PUSH
53420: LD_EXP 102
53424: PUSH
53425: LD_VAR 0 2
53429: ARRAY
53430: PUSH
53431: LD_INT 1
53433: ARRAY
53434: PPUSH
53435: CALL_OW 255
53439: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53440: LD_ADDR_VAR 0 9
53444: PUSH
53445: LD_EXP 102
53449: PUSH
53450: LD_VAR 0 2
53454: ARRAY
53455: PPUSH
53456: LD_INT 2
53458: PUSH
53459: LD_INT 30
53461: PUSH
53462: LD_INT 0
53464: PUSH
53465: EMPTY
53466: LIST
53467: LIST
53468: PUSH
53469: LD_INT 30
53471: PUSH
53472: LD_INT 1
53474: PUSH
53475: EMPTY
53476: LIST
53477: LIST
53478: PUSH
53479: EMPTY
53480: LIST
53481: LIST
53482: LIST
53483: PPUSH
53484: CALL_OW 72
53488: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
53489: LD_ADDR_VAR 0 3
53493: PUSH
53494: DOUBLE
53495: LD_EXP 118
53499: PUSH
53500: LD_VAR 0 2
53504: ARRAY
53505: INC
53506: ST_TO_ADDR
53507: LD_INT 1
53509: PUSH
53510: FOR_DOWNTO
53511: IFFALSE 53758
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
53513: LD_EXP 118
53517: PUSH
53518: LD_VAR 0 2
53522: ARRAY
53523: PUSH
53524: LD_VAR 0 3
53528: ARRAY
53529: PUSH
53530: LD_INT 2
53532: ARRAY
53533: PPUSH
53534: LD_EXP 118
53538: PUSH
53539: LD_VAR 0 2
53543: ARRAY
53544: PUSH
53545: LD_VAR 0 3
53549: ARRAY
53550: PUSH
53551: LD_INT 3
53553: ARRAY
53554: PPUSH
53555: CALL_OW 488
53559: IFFALSE 53613
53561: PUSH
53562: LD_EXP 118
53566: PUSH
53567: LD_VAR 0 2
53571: ARRAY
53572: PUSH
53573: LD_VAR 0 3
53577: ARRAY
53578: PUSH
53579: LD_INT 2
53581: ARRAY
53582: PPUSH
53583: LD_EXP 118
53587: PUSH
53588: LD_VAR 0 2
53592: ARRAY
53593: PUSH
53594: LD_VAR 0 3
53598: ARRAY
53599: PUSH
53600: LD_INT 3
53602: ARRAY
53603: PPUSH
53604: CALL_OW 284
53608: PUSH
53609: LD_INT 0
53611: EQUAL
53612: AND
53613: IFFALSE 53668
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
53615: LD_ADDR_VAR 0 5
53619: PUSH
53620: LD_EXP 118
53624: PUSH
53625: LD_VAR 0 2
53629: ARRAY
53630: PPUSH
53631: LD_VAR 0 3
53635: PPUSH
53636: CALL_OW 3
53640: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
53641: LD_ADDR_EXP 118
53645: PUSH
53646: LD_EXP 118
53650: PPUSH
53651: LD_VAR 0 2
53655: PPUSH
53656: LD_VAR 0 5
53660: PPUSH
53661: CALL_OW 1
53665: ST_TO_ADDR
// continue ;
53666: GO 53510
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
53668: LD_VAR 0 6
53672: PPUSH
53673: LD_EXP 118
53677: PUSH
53678: LD_VAR 0 2
53682: ARRAY
53683: PUSH
53684: LD_VAR 0 3
53688: ARRAY
53689: PUSH
53690: LD_INT 2
53692: ARRAY
53693: PPUSH
53694: LD_EXP 118
53698: PUSH
53699: LD_VAR 0 2
53703: ARRAY
53704: PUSH
53705: LD_VAR 0 3
53709: ARRAY
53710: PUSH
53711: LD_INT 3
53713: ARRAY
53714: PPUSH
53715: LD_INT 30
53717: PPUSH
53718: CALL 77351 0 4
53722: PUSH
53723: LD_INT 4
53725: ARRAY
53726: PUSH
53727: LD_INT 0
53729: EQUAL
53730: IFFALSE 53756
// begin target := mc_crates [ i ] [ j ] ;
53732: LD_ADDR_VAR 0 7
53736: PUSH
53737: LD_EXP 118
53741: PUSH
53742: LD_VAR 0 2
53746: ARRAY
53747: PUSH
53748: LD_VAR 0 3
53752: ARRAY
53753: ST_TO_ADDR
// break ;
53754: GO 53758
// end ; end ;
53756: GO 53510
53758: POP
53759: POP
// if not target then
53760: LD_VAR 0 7
53764: NOT
53765: IFFALSE 53769
// continue ;
53767: GO 53313
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
53769: LD_ADDR_VAR 0 8
53773: PUSH
53774: LD_EXP 121
53778: PUSH
53779: LD_VAR 0 2
53783: ARRAY
53784: PPUSH
53785: LD_INT 2
53787: PUSH
53788: LD_INT 3
53790: PUSH
53791: LD_INT 58
53793: PUSH
53794: EMPTY
53795: LIST
53796: PUSH
53797: EMPTY
53798: LIST
53799: LIST
53800: PUSH
53801: LD_INT 61
53803: PUSH
53804: EMPTY
53805: LIST
53806: PUSH
53807: LD_INT 33
53809: PUSH
53810: LD_INT 5
53812: PUSH
53813: EMPTY
53814: LIST
53815: LIST
53816: PUSH
53817: LD_INT 33
53819: PUSH
53820: LD_INT 3
53822: PUSH
53823: EMPTY
53824: LIST
53825: LIST
53826: PUSH
53827: EMPTY
53828: LIST
53829: LIST
53830: LIST
53831: LIST
53832: LIST
53833: PUSH
53834: LD_INT 2
53836: PUSH
53837: LD_INT 34
53839: PUSH
53840: LD_INT 32
53842: PUSH
53843: EMPTY
53844: LIST
53845: LIST
53846: PUSH
53847: LD_INT 34
53849: PUSH
53850: LD_INT 51
53852: PUSH
53853: EMPTY
53854: LIST
53855: LIST
53856: PUSH
53857: LD_INT 34
53859: PUSH
53860: LD_INT 12
53862: PUSH
53863: EMPTY
53864: LIST
53865: LIST
53866: PUSH
53867: EMPTY
53868: LIST
53869: LIST
53870: LIST
53871: LIST
53872: PUSH
53873: EMPTY
53874: LIST
53875: LIST
53876: PPUSH
53877: CALL_OW 72
53881: ST_TO_ADDR
// if not cargo then
53882: LD_VAR 0 8
53886: NOT
53887: IFFALSE 54601
// begin if mc_crates_collector [ i ] < 5 then
53889: LD_EXP 119
53893: PUSH
53894: LD_VAR 0 2
53898: ARRAY
53899: PUSH
53900: LD_INT 5
53902: LESS
53903: IFFALSE 54273
// begin if mc_ape [ i ] then
53905: LD_EXP 131
53909: PUSH
53910: LD_VAR 0 2
53914: ARRAY
53915: IFFALSE 53962
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
53917: LD_ADDR_VAR 0 5
53921: PUSH
53922: LD_EXP 131
53926: PUSH
53927: LD_VAR 0 2
53931: ARRAY
53932: PPUSH
53933: LD_INT 25
53935: PUSH
53936: LD_INT 16
53938: PUSH
53939: EMPTY
53940: LIST
53941: LIST
53942: PUSH
53943: LD_INT 24
53945: PUSH
53946: LD_INT 750
53948: PUSH
53949: EMPTY
53950: LIST
53951: LIST
53952: PUSH
53953: EMPTY
53954: LIST
53955: LIST
53956: PPUSH
53957: CALL_OW 72
53961: ST_TO_ADDR
// if not tmp then
53962: LD_VAR 0 5
53966: NOT
53967: IFFALSE 54014
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
53969: LD_ADDR_VAR 0 5
53973: PUSH
53974: LD_EXP 102
53978: PUSH
53979: LD_VAR 0 2
53983: ARRAY
53984: PPUSH
53985: LD_INT 25
53987: PUSH
53988: LD_INT 2
53990: PUSH
53991: EMPTY
53992: LIST
53993: LIST
53994: PUSH
53995: LD_INT 24
53997: PUSH
53998: LD_INT 750
54000: PUSH
54001: EMPTY
54002: LIST
54003: LIST
54004: PUSH
54005: EMPTY
54006: LIST
54007: LIST
54008: PPUSH
54009: CALL_OW 72
54013: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
54014: LD_EXP 131
54018: PUSH
54019: LD_VAR 0 2
54023: ARRAY
54024: IFFALSE 54067
54026: PUSH
54027: LD_EXP 102
54031: PUSH
54032: LD_VAR 0 2
54036: ARRAY
54037: PPUSH
54038: LD_INT 25
54040: PUSH
54041: LD_INT 2
54043: PUSH
54044: EMPTY
54045: LIST
54046: LIST
54047: PUSH
54048: LD_INT 24
54050: PUSH
54051: LD_INT 750
54053: PUSH
54054: EMPTY
54055: LIST
54056: LIST
54057: PUSH
54058: EMPTY
54059: LIST
54060: LIST
54061: PPUSH
54062: CALL_OW 72
54066: AND
54067: IFFALSE 54079
54069: PUSH
54070: LD_VAR 0 5
54074: PUSH
54075: LD_INT 5
54077: LESS
54078: AND
54079: IFFALSE 54161
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
54081: LD_ADDR_VAR 0 3
54085: PUSH
54086: LD_EXP 102
54090: PUSH
54091: LD_VAR 0 2
54095: ARRAY
54096: PPUSH
54097: LD_INT 25
54099: PUSH
54100: LD_INT 2
54102: PUSH
54103: EMPTY
54104: LIST
54105: LIST
54106: PUSH
54107: LD_INT 24
54109: PUSH
54110: LD_INT 750
54112: PUSH
54113: EMPTY
54114: LIST
54115: LIST
54116: PUSH
54117: EMPTY
54118: LIST
54119: LIST
54120: PPUSH
54121: CALL_OW 72
54125: PUSH
54126: FOR_IN
54127: IFFALSE 54159
// begin tmp := tmp union j ;
54129: LD_ADDR_VAR 0 5
54133: PUSH
54134: LD_VAR 0 5
54138: PUSH
54139: LD_VAR 0 3
54143: UNION
54144: ST_TO_ADDR
// if tmp >= 5 then
54145: LD_VAR 0 5
54149: PUSH
54150: LD_INT 5
54152: GREATEREQUAL
54153: IFFALSE 54157
// break ;
54155: GO 54159
// end ;
54157: GO 54126
54159: POP
54160: POP
// end ; if not tmp then
54161: LD_VAR 0 5
54165: NOT
54166: IFFALSE 54170
// continue ;
54168: GO 53313
// for j in tmp do
54170: LD_ADDR_VAR 0 3
54174: PUSH
54175: LD_VAR 0 5
54179: PUSH
54180: FOR_IN
54181: IFFALSE 54271
// if not GetTag ( j ) then
54183: LD_VAR 0 3
54187: PPUSH
54188: CALL_OW 110
54192: NOT
54193: IFFALSE 54269
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
54195: LD_ADDR_EXP 119
54199: PUSH
54200: LD_EXP 119
54204: PPUSH
54205: LD_VAR 0 2
54209: PUSH
54210: LD_EXP 119
54214: PUSH
54215: LD_VAR 0 2
54219: ARRAY
54220: PUSH
54221: LD_INT 1
54223: PLUS
54224: PUSH
54225: EMPTY
54226: LIST
54227: LIST
54228: PPUSH
54229: LD_VAR 0 3
54233: PPUSH
54234: CALL 76081 0 3
54238: ST_TO_ADDR
// SetTag ( j , 107 ) ;
54239: LD_VAR 0 3
54243: PPUSH
54244: LD_INT 107
54246: PPUSH
54247: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
54251: LD_EXP 119
54255: PUSH
54256: LD_VAR 0 2
54260: ARRAY
54261: PUSH
54262: LD_INT 5
54264: GREATEREQUAL
54265: IFFALSE 54269
// break ;
54267: GO 54271
// end ;
54269: GO 54180
54271: POP
54272: POP
// end ; if mc_crates_collector [ i ] and target then
54273: LD_EXP 119
54277: PUSH
54278: LD_VAR 0 2
54282: ARRAY
54283: IFFALSE 54291
54285: PUSH
54286: LD_VAR 0 7
54290: AND
54291: IFFALSE 54599
// begin if mc_crates_collector [ i ] < target [ 1 ] then
54293: LD_EXP 119
54297: PUSH
54298: LD_VAR 0 2
54302: ARRAY
54303: PUSH
54304: LD_VAR 0 7
54308: PUSH
54309: LD_INT 1
54311: ARRAY
54312: LESS
54313: IFFALSE 54333
// tmp := mc_crates_collector [ i ] else
54315: LD_ADDR_VAR 0 5
54319: PUSH
54320: LD_EXP 119
54324: PUSH
54325: LD_VAR 0 2
54329: ARRAY
54330: ST_TO_ADDR
54331: GO 54347
// tmp := target [ 1 ] ;
54333: LD_ADDR_VAR 0 5
54337: PUSH
54338: LD_VAR 0 7
54342: PUSH
54343: LD_INT 1
54345: ARRAY
54346: ST_TO_ADDR
// k := 0 ;
54347: LD_ADDR_VAR 0 4
54351: PUSH
54352: LD_INT 0
54354: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
54355: LD_ADDR_VAR 0 3
54359: PUSH
54360: LD_EXP 119
54364: PUSH
54365: LD_VAR 0 2
54369: ARRAY
54370: PUSH
54371: FOR_IN
54372: IFFALSE 54597
// begin k := k + 1 ;
54374: LD_ADDR_VAR 0 4
54378: PUSH
54379: LD_VAR 0 4
54383: PUSH
54384: LD_INT 1
54386: PLUS
54387: ST_TO_ADDR
// if k > tmp then
54388: LD_VAR 0 4
54392: PUSH
54393: LD_VAR 0 5
54397: GREATER
54398: IFFALSE 54402
// break ;
54400: GO 54597
// if not GetClass ( j ) in [ 2 , 16 ] then
54402: LD_VAR 0 3
54406: PPUSH
54407: CALL_OW 257
54411: PUSH
54412: LD_INT 2
54414: PUSH
54415: LD_INT 16
54417: PUSH
54418: EMPTY
54419: LIST
54420: LIST
54421: IN
54422: NOT
54423: IFFALSE 54476
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
54425: LD_ADDR_EXP 119
54429: PUSH
54430: LD_EXP 119
54434: PPUSH
54435: LD_VAR 0 2
54439: PPUSH
54440: LD_EXP 119
54444: PUSH
54445: LD_VAR 0 2
54449: ARRAY
54450: PUSH
54451: LD_VAR 0 3
54455: DIFF
54456: PPUSH
54457: CALL_OW 1
54461: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54462: LD_VAR 0 3
54466: PPUSH
54467: LD_INT 0
54469: PPUSH
54470: CALL_OW 109
// continue ;
54474: GO 54371
// end ; if IsInUnit ( j ) then
54476: LD_VAR 0 3
54480: PPUSH
54481: CALL_OW 310
54485: IFFALSE 54496
// ComExitBuilding ( j ) ;
54487: LD_VAR 0 3
54491: PPUSH
54492: CALL_OW 122
// wait ( 3 ) ;
54496: LD_INT 3
54498: PPUSH
54499: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
54503: LD_VAR 0 3
54507: PPUSH
54508: CALL_OW 314
54512: IFFALSE 54550
54514: PUSH
54515: LD_VAR 0 6
54519: PPUSH
54520: LD_VAR 0 7
54524: PUSH
54525: LD_INT 2
54527: ARRAY
54528: PPUSH
54529: LD_VAR 0 7
54533: PUSH
54534: LD_INT 3
54536: ARRAY
54537: PPUSH
54538: LD_INT 30
54540: PPUSH
54541: CALL 77351 0 4
54545: PUSH
54546: LD_INT 4
54548: ARRAY
54549: AND
54550: IFFALSE 54568
// ComStandNearbyBuilding ( j , depot ) else
54552: LD_VAR 0 3
54556: PPUSH
54557: LD_VAR 0 9
54561: PPUSH
54562: CALL 72623 0 2
54566: GO 54595
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
54568: LD_VAR 0 3
54572: PPUSH
54573: LD_VAR 0 7
54577: PUSH
54578: LD_INT 2
54580: ARRAY
54581: PPUSH
54582: LD_VAR 0 7
54586: PUSH
54587: LD_INT 3
54589: ARRAY
54590: PPUSH
54591: CALL_OW 117
// end ;
54595: GO 54371
54597: POP
54598: POP
// end ; end else
54599: GO 55141
// begin for j in cargo do
54601: LD_ADDR_VAR 0 3
54605: PUSH
54606: LD_VAR 0 8
54610: PUSH
54611: FOR_IN
54612: IFFALSE 55139
// begin if GetTag ( j ) <> 0 then
54614: LD_VAR 0 3
54618: PPUSH
54619: CALL_OW 110
54623: PUSH
54624: LD_INT 0
54626: NONEQUAL
54627: IFFALSE 54631
// continue ;
54629: GO 54611
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
54631: LD_VAR 0 3
54635: PPUSH
54636: CALL_OW 256
54640: PUSH
54641: LD_INT 1000
54643: LESS
54644: IFFALSE 54669
54646: PUSH
54647: LD_VAR 0 3
54651: PPUSH
54652: LD_EXP 126
54656: PUSH
54657: LD_VAR 0 2
54661: ARRAY
54662: PPUSH
54663: CALL_OW 308
54667: NOT
54668: AND
54669: IFFALSE 54691
// ComMoveToArea ( j , mc_parking [ i ] ) ;
54671: LD_VAR 0 3
54675: PPUSH
54676: LD_EXP 126
54680: PUSH
54681: LD_VAR 0 2
54685: ARRAY
54686: PPUSH
54687: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
54691: LD_VAR 0 3
54695: PPUSH
54696: CALL_OW 256
54700: PUSH
54701: LD_INT 1000
54703: LESS
54704: IFFALSE 54728
54706: PUSH
54707: LD_VAR 0 3
54711: PPUSH
54712: LD_EXP 126
54716: PUSH
54717: LD_VAR 0 2
54721: ARRAY
54722: PPUSH
54723: CALL_OW 308
54727: AND
54728: IFFALSE 54732
// continue ;
54730: GO 54611
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
54732: LD_VAR 0 3
54736: PPUSH
54737: CALL_OW 262
54741: PUSH
54742: LD_INT 2
54744: EQUAL
54745: IFFALSE 54762
54747: PUSH
54748: LD_VAR 0 3
54752: PPUSH
54753: CALL_OW 261
54757: PUSH
54758: LD_INT 15
54760: LESS
54761: AND
54762: IFFALSE 54766
// continue ;
54764: GO 54611
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
54766: LD_VAR 0 3
54770: PPUSH
54771: CALL_OW 262
54775: PUSH
54776: LD_INT 1
54778: EQUAL
54779: IFFALSE 54796
54781: PUSH
54782: LD_VAR 0 3
54786: PPUSH
54787: CALL_OW 261
54791: PUSH
54792: LD_INT 10
54794: LESS
54795: AND
54796: IFFALSE 55076
// begin if not depot then
54798: LD_VAR 0 9
54802: NOT
54803: IFFALSE 54807
// continue ;
54805: GO 54611
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
54807: LD_VAR 0 3
54811: PPUSH
54812: LD_VAR 0 9
54816: PPUSH
54817: LD_VAR 0 3
54821: PPUSH
54822: CALL_OW 74
54826: PPUSH
54827: CALL_OW 296
54831: PUSH
54832: LD_INT 6
54834: LESS
54835: IFFALSE 54851
// SetFuel ( j , 100 ) else
54837: LD_VAR 0 3
54841: PPUSH
54842: LD_INT 100
54844: PPUSH
54845: CALL_OW 240
54849: GO 55076
// if GetFuel ( j ) = 0 then
54851: LD_VAR 0 3
54855: PPUSH
54856: CALL_OW 261
54860: PUSH
54861: LD_INT 0
54863: EQUAL
54864: IFFALSE 55076
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
54866: LD_ADDR_EXP 121
54870: PUSH
54871: LD_EXP 121
54875: PPUSH
54876: LD_VAR 0 2
54880: PPUSH
54881: LD_EXP 121
54885: PUSH
54886: LD_VAR 0 2
54890: ARRAY
54891: PUSH
54892: LD_VAR 0 3
54896: DIFF
54897: PPUSH
54898: CALL_OW 1
54902: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
54903: LD_VAR 0 3
54907: PPUSH
54908: CALL_OW 263
54912: PUSH
54913: LD_INT 1
54915: EQUAL
54916: IFFALSE 54932
// ComExitVehicle ( IsInUnit ( j ) ) ;
54918: LD_VAR 0 3
54922: PPUSH
54923: CALL_OW 310
54927: PPUSH
54928: CALL_OW 121
// if GetControl ( j ) = control_remote then
54932: LD_VAR 0 3
54936: PPUSH
54937: CALL_OW 263
54941: PUSH
54942: LD_INT 2
54944: EQUAL
54945: IFFALSE 54956
// ComUnlink ( j ) ;
54947: LD_VAR 0 3
54951: PPUSH
54952: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
54956: LD_ADDR_VAR 0 10
54960: PUSH
54961: LD_VAR 0 2
54965: PPUSH
54966: LD_INT 3
54968: PPUSH
54969: CALL 64870 0 2
54973: ST_TO_ADDR
// if fac then
54974: LD_VAR 0 10
54978: IFFALSE 55074
// begin for k in fac do
54980: LD_ADDR_VAR 0 4
54984: PUSH
54985: LD_VAR 0 10
54989: PUSH
54990: FOR_IN
54991: IFFALSE 55072
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
54993: LD_ADDR_VAR 0 11
54997: PUSH
54998: LD_VAR 0 10
55002: PPUSH
55003: LD_VAR 0 3
55007: PPUSH
55008: CALL_OW 265
55012: PPUSH
55013: LD_VAR 0 3
55017: PPUSH
55018: CALL_OW 262
55022: PPUSH
55023: LD_VAR 0 3
55027: PPUSH
55028: CALL_OW 263
55032: PPUSH
55033: LD_VAR 0 3
55037: PPUSH
55038: CALL_OW 264
55042: PPUSH
55043: CALL 73521 0 5
55047: ST_TO_ADDR
// if components then
55048: LD_VAR 0 11
55052: IFFALSE 55070
// begin MC_InsertProduceList ( i , components ) ;
55054: LD_VAR 0 2
55058: PPUSH
55059: LD_VAR 0 11
55063: PPUSH
55064: CALL 64415 0 2
// break ;
55068: GO 55072
// end ; end ;
55070: GO 54990
55072: POP
55073: POP
// end ; continue ;
55074: GO 54611
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
55076: LD_VAR 0 3
55080: PPUSH
55081: LD_INT 1
55083: PPUSH
55084: CALL_OW 289
55088: PUSH
55089: LD_INT 100
55091: LESS
55092: IFFALSE 55106
55094: PUSH
55095: LD_VAR 0 3
55099: PPUSH
55100: CALL_OW 314
55104: NOT
55105: AND
55106: IFFALSE 55135
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
55108: LD_VAR 0 3
55112: PPUSH
55113: LD_VAR 0 7
55117: PUSH
55118: LD_INT 2
55120: ARRAY
55121: PPUSH
55122: LD_VAR 0 7
55126: PUSH
55127: LD_INT 3
55129: ARRAY
55130: PPUSH
55131: CALL_OW 117
// break ;
55135: GO 55139
// end ;
55137: GO 54611
55139: POP
55140: POP
// end ; end ;
55141: GO 53313
55143: POP
55144: POP
// end ;
55145: LD_VAR 0 1
55149: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
55150: LD_INT 0
55152: PPUSH
55153: PPUSH
55154: PPUSH
55155: PPUSH
// if not mc_bases then
55156: LD_EXP 102
55160: NOT
55161: IFFALSE 55165
// exit ;
55163: GO 55330
// for i = 1 to mc_bases do
55165: LD_ADDR_VAR 0 2
55169: PUSH
55170: DOUBLE
55171: LD_INT 1
55173: DEC
55174: ST_TO_ADDR
55175: LD_EXP 102
55179: PUSH
55180: FOR_TO
55181: IFFALSE 55328
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
55183: LD_ADDR_VAR 0 4
55187: PUSH
55188: LD_EXP 121
55192: PUSH
55193: LD_VAR 0 2
55197: ARRAY
55198: PUSH
55199: LD_EXP 124
55203: PUSH
55204: LD_VAR 0 2
55208: ARRAY
55209: UNION
55210: PPUSH
55211: LD_INT 33
55213: PUSH
55214: LD_INT 2
55216: PUSH
55217: EMPTY
55218: LIST
55219: LIST
55220: PPUSH
55221: CALL_OW 72
55225: ST_TO_ADDR
// if tmp then
55226: LD_VAR 0 4
55230: IFFALSE 55326
// for j in tmp do
55232: LD_ADDR_VAR 0 3
55236: PUSH
55237: LD_VAR 0 4
55241: PUSH
55242: FOR_IN
55243: IFFALSE 55324
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
55245: LD_VAR 0 3
55249: PPUSH
55250: CALL_OW 312
55254: NOT
55255: IFFALSE 55272
55257: PUSH
55258: LD_VAR 0 3
55262: PPUSH
55263: CALL_OW 256
55267: PUSH
55268: LD_INT 250
55270: GREATEREQUAL
55271: AND
55272: IFFALSE 55285
// Connect ( j ) else
55274: LD_VAR 0 3
55278: PPUSH
55279: CALL 79441 0 1
55283: GO 55322
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
55285: LD_VAR 0 3
55289: PPUSH
55290: CALL_OW 256
55294: PUSH
55295: LD_INT 250
55297: LESS
55298: IFFALSE 55311
55300: PUSH
55301: LD_VAR 0 3
55305: PPUSH
55306: CALL_OW 312
55310: AND
55311: IFFALSE 55322
// ComUnlink ( j ) ;
55313: LD_VAR 0 3
55317: PPUSH
55318: CALL_OW 136
55322: GO 55242
55324: POP
55325: POP
// end ;
55326: GO 55180
55328: POP
55329: POP
// end ;
55330: LD_VAR 0 1
55334: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
55335: LD_INT 0
55337: PPUSH
55338: PPUSH
55339: PPUSH
55340: PPUSH
55341: PPUSH
// if not mc_bases then
55342: LD_EXP 102
55346: NOT
55347: IFFALSE 55351
// exit ;
55349: GO 55800
// for i = 1 to mc_bases do
55351: LD_ADDR_VAR 0 2
55355: PUSH
55356: DOUBLE
55357: LD_INT 1
55359: DEC
55360: ST_TO_ADDR
55361: LD_EXP 102
55365: PUSH
55366: FOR_TO
55367: IFFALSE 55798
// begin if not mc_produce [ i ] then
55369: LD_EXP 123
55373: PUSH
55374: LD_VAR 0 2
55378: ARRAY
55379: NOT
55380: IFFALSE 55384
// continue ;
55382: GO 55366
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
55384: LD_ADDR_VAR 0 5
55388: PUSH
55389: LD_EXP 102
55393: PUSH
55394: LD_VAR 0 2
55398: ARRAY
55399: PPUSH
55400: LD_INT 30
55402: PUSH
55403: LD_INT 3
55405: PUSH
55406: EMPTY
55407: LIST
55408: LIST
55409: PPUSH
55410: CALL_OW 72
55414: ST_TO_ADDR
// if not fac then
55415: LD_VAR 0 5
55419: NOT
55420: IFFALSE 55424
// continue ;
55422: GO 55366
// for j in fac do
55424: LD_ADDR_VAR 0 3
55428: PUSH
55429: LD_VAR 0 5
55433: PUSH
55434: FOR_IN
55435: IFFALSE 55794
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
55437: LD_VAR 0 3
55441: PPUSH
55442: CALL_OW 461
55446: PUSH
55447: LD_INT 2
55449: NONEQUAL
55450: IFTRUE 55470
55452: PUSH
55453: LD_VAR 0 3
55457: PPUSH
55458: LD_INT 15
55460: PPUSH
55461: CALL 79060 0 2
55465: PUSH
55466: LD_INT 4
55468: ARRAY
55469: OR
55470: IFFALSE 55474
// continue ;
55472: GO 55434
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
55474: LD_VAR 0 3
55478: PPUSH
55479: LD_EXP 123
55483: PUSH
55484: LD_VAR 0 2
55488: ARRAY
55489: PUSH
55490: LD_INT 1
55492: ARRAY
55493: PUSH
55494: LD_INT 1
55496: ARRAY
55497: PPUSH
55498: LD_EXP 123
55502: PUSH
55503: LD_VAR 0 2
55507: ARRAY
55508: PUSH
55509: LD_INT 1
55511: ARRAY
55512: PUSH
55513: LD_INT 2
55515: ARRAY
55516: PPUSH
55517: LD_EXP 123
55521: PUSH
55522: LD_VAR 0 2
55526: ARRAY
55527: PUSH
55528: LD_INT 1
55530: ARRAY
55531: PUSH
55532: LD_INT 3
55534: ARRAY
55535: PPUSH
55536: LD_EXP 123
55540: PUSH
55541: LD_VAR 0 2
55545: ARRAY
55546: PUSH
55547: LD_INT 1
55549: ARRAY
55550: PUSH
55551: LD_INT 4
55553: ARRAY
55554: PPUSH
55555: CALL_OW 448
55559: IFFALSE 55654
55561: PUSH
55562: LD_VAR 0 3
55566: PPUSH
55567: LD_EXP 123
55571: PUSH
55572: LD_VAR 0 2
55576: ARRAY
55577: PUSH
55578: LD_INT 1
55580: ARRAY
55581: PUSH
55582: LD_INT 1
55584: ARRAY
55585: PUSH
55586: LD_EXP 123
55590: PUSH
55591: LD_VAR 0 2
55595: ARRAY
55596: PUSH
55597: LD_INT 1
55599: ARRAY
55600: PUSH
55601: LD_INT 2
55603: ARRAY
55604: PUSH
55605: LD_EXP 123
55609: PUSH
55610: LD_VAR 0 2
55614: ARRAY
55615: PUSH
55616: LD_INT 1
55618: ARRAY
55619: PUSH
55620: LD_INT 3
55622: ARRAY
55623: PUSH
55624: LD_EXP 123
55628: PUSH
55629: LD_VAR 0 2
55633: ARRAY
55634: PUSH
55635: LD_INT 1
55637: ARRAY
55638: PUSH
55639: LD_INT 4
55641: ARRAY
55642: PUSH
55643: EMPTY
55644: LIST
55645: LIST
55646: LIST
55647: LIST
55648: PPUSH
55649: CALL 82874 0 2
55653: AND
55654: IFFALSE 55792
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
55656: LD_VAR 0 3
55660: PPUSH
55661: LD_EXP 123
55665: PUSH
55666: LD_VAR 0 2
55670: ARRAY
55671: PUSH
55672: LD_INT 1
55674: ARRAY
55675: PUSH
55676: LD_INT 1
55678: ARRAY
55679: PPUSH
55680: LD_EXP 123
55684: PUSH
55685: LD_VAR 0 2
55689: ARRAY
55690: PUSH
55691: LD_INT 1
55693: ARRAY
55694: PUSH
55695: LD_INT 2
55697: ARRAY
55698: PPUSH
55699: LD_EXP 123
55703: PUSH
55704: LD_VAR 0 2
55708: ARRAY
55709: PUSH
55710: LD_INT 1
55712: ARRAY
55713: PUSH
55714: LD_INT 3
55716: ARRAY
55717: PPUSH
55718: LD_EXP 123
55722: PUSH
55723: LD_VAR 0 2
55727: ARRAY
55728: PUSH
55729: LD_INT 1
55731: ARRAY
55732: PUSH
55733: LD_INT 4
55735: ARRAY
55736: PPUSH
55737: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
55741: LD_ADDR_VAR 0 4
55745: PUSH
55746: LD_EXP 123
55750: PUSH
55751: LD_VAR 0 2
55755: ARRAY
55756: PPUSH
55757: LD_INT 1
55759: PPUSH
55760: CALL_OW 3
55764: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
55765: LD_ADDR_EXP 123
55769: PUSH
55770: LD_EXP 123
55774: PPUSH
55775: LD_VAR 0 2
55779: PPUSH
55780: LD_VAR 0 4
55784: PPUSH
55785: CALL_OW 1
55789: ST_TO_ADDR
// break ;
55790: GO 55794
// end ; end ;
55792: GO 55434
55794: POP
55795: POP
// end ;
55796: GO 55366
55798: POP
55799: POP
// end ;
55800: LD_VAR 0 1
55804: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
55805: LD_INT 0
55807: PPUSH
55808: PPUSH
55809: PPUSH
// if not mc_bases then
55810: LD_EXP 102
55814: NOT
55815: IFFALSE 55819
// exit ;
55817: GO 55908
// for i = 1 to mc_bases do
55819: LD_ADDR_VAR 0 2
55823: PUSH
55824: DOUBLE
55825: LD_INT 1
55827: DEC
55828: ST_TO_ADDR
55829: LD_EXP 102
55833: PUSH
55834: FOR_TO
55835: IFFALSE 55906
// begin if mc_attack [ i ] then
55837: LD_EXP 122
55841: PUSH
55842: LD_VAR 0 2
55846: ARRAY
55847: IFFALSE 55904
// begin tmp := mc_attack [ i ] [ 1 ] ;
55849: LD_ADDR_VAR 0 3
55853: PUSH
55854: LD_EXP 122
55858: PUSH
55859: LD_VAR 0 2
55863: ARRAY
55864: PUSH
55865: LD_INT 1
55867: ARRAY
55868: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
55869: LD_ADDR_EXP 122
55873: PUSH
55874: LD_EXP 122
55878: PPUSH
55879: LD_VAR 0 2
55883: PPUSH
55884: EMPTY
55885: PPUSH
55886: CALL_OW 1
55890: ST_TO_ADDR
// Attack ( tmp ) ;
55891: LD_VAR 0 3
55895: PPUSH
55896: CALL 137053 0 1
// exit ;
55900: POP
55901: POP
55902: GO 55908
// end ; end ;
55904: GO 55834
55906: POP
55907: POP
// end ;
55908: LD_VAR 0 1
55912: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
55913: LD_INT 0
55915: PPUSH
55916: PPUSH
55917: PPUSH
55918: PPUSH
55919: PPUSH
55920: PPUSH
55921: PPUSH
// if not mc_bases then
55922: LD_EXP 102
55926: NOT
55927: IFFALSE 55931
// exit ;
55929: GO 56808
// for i = 1 to mc_bases do
55931: LD_ADDR_VAR 0 2
55935: PUSH
55936: DOUBLE
55937: LD_INT 1
55939: DEC
55940: ST_TO_ADDR
55941: LD_EXP 102
55945: PUSH
55946: FOR_TO
55947: IFFALSE 56806
// begin if not mc_bases [ i ] then
55949: LD_EXP 102
55953: PUSH
55954: LD_VAR 0 2
55958: ARRAY
55959: NOT
55960: IFFALSE 55964
// continue ;
55962: GO 55946
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
55964: LD_ADDR_VAR 0 7
55968: PUSH
55969: LD_EXP 102
55973: PUSH
55974: LD_VAR 0 2
55978: ARRAY
55979: PUSH
55980: LD_INT 1
55982: ARRAY
55983: PPUSH
55984: CALL 72847 0 1
55988: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
55989: LD_ADDR_EXP 125
55993: PUSH
55994: LD_EXP 125
55998: PPUSH
55999: LD_VAR 0 2
56003: PPUSH
56004: LD_EXP 102
56008: PUSH
56009: LD_VAR 0 2
56013: ARRAY
56014: PUSH
56015: LD_INT 1
56017: ARRAY
56018: PPUSH
56019: CALL_OW 255
56023: PPUSH
56024: LD_EXP 127
56028: PUSH
56029: LD_VAR 0 2
56033: ARRAY
56034: PPUSH
56035: CALL 72812 0 2
56039: PPUSH
56040: CALL_OW 1
56044: ST_TO_ADDR
// if not mc_scan [ i ] then
56045: LD_EXP 125
56049: PUSH
56050: LD_VAR 0 2
56054: ARRAY
56055: NOT
56056: IFFALSE 56240
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
56058: LD_ADDR_EXP 145
56062: PUSH
56063: LD_EXP 145
56067: PPUSH
56068: LD_VAR 0 2
56072: PPUSH
56073: LD_INT 0
56075: PPUSH
56076: CALL_OW 1
56080: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56081: LD_ADDR_VAR 0 4
56085: PUSH
56086: LD_EXP 102
56090: PUSH
56091: LD_VAR 0 2
56095: ARRAY
56096: PPUSH
56097: LD_INT 2
56099: PUSH
56100: LD_INT 25
56102: PUSH
56103: LD_INT 5
56105: PUSH
56106: EMPTY
56107: LIST
56108: LIST
56109: PUSH
56110: LD_INT 25
56112: PUSH
56113: LD_INT 8
56115: PUSH
56116: EMPTY
56117: LIST
56118: LIST
56119: PUSH
56120: LD_INT 25
56122: PUSH
56123: LD_INT 9
56125: PUSH
56126: EMPTY
56127: LIST
56128: LIST
56129: PUSH
56130: EMPTY
56131: LIST
56132: LIST
56133: LIST
56134: LIST
56135: PPUSH
56136: CALL_OW 72
56140: ST_TO_ADDR
// if not tmp then
56141: LD_VAR 0 4
56145: NOT
56146: IFFALSE 56150
// continue ;
56148: GO 55946
// for j in tmp do
56150: LD_ADDR_VAR 0 3
56154: PUSH
56155: LD_VAR 0 4
56159: PUSH
56160: FOR_IN
56161: IFFALSE 56238
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
56163: LD_VAR 0 3
56167: PPUSH
56168: CALL_OW 310
56172: PPUSH
56173: CALL_OW 266
56177: PUSH
56178: LD_INT 5
56180: EQUAL
56181: IFFALSE 56198
56183: PUSH
56184: LD_VAR 0 3
56188: PPUSH
56189: CALL_OW 257
56193: PUSH
56194: LD_INT 1
56196: EQUAL
56197: AND
56198: IFFALSE 56212
56200: PUSH
56201: LD_VAR 0 3
56205: PPUSH
56206: CALL_OW 459
56210: NOT
56211: AND
56212: IFFALSE 56220
56214: PUSH
56215: LD_VAR 0 7
56219: AND
56220: IFFALSE 56236
// ComChangeProfession ( j , class ) ;
56222: LD_VAR 0 3
56226: PPUSH
56227: LD_VAR 0 7
56231: PPUSH
56232: CALL_OW 123
56236: GO 56160
56238: POP
56239: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
56240: LD_EXP 125
56244: PUSH
56245: LD_VAR 0 2
56249: ARRAY
56250: IFFALSE 56265
56252: PUSH
56253: LD_EXP 145
56257: PUSH
56258: LD_VAR 0 2
56262: ARRAY
56263: NOT
56264: AND
56265: IFFALSE 56280
56267: PUSH
56268: LD_EXP 124
56272: PUSH
56273: LD_VAR 0 2
56277: ARRAY
56278: NOT
56279: AND
56280: IFFALSE 56431
56282: PUSH
56283: LD_EXP 102
56287: PUSH
56288: LD_VAR 0 2
56292: ARRAY
56293: PPUSH
56294: LD_INT 50
56296: PUSH
56297: EMPTY
56298: LIST
56299: PUSH
56300: LD_INT 2
56302: PUSH
56303: LD_INT 30
56305: PUSH
56306: LD_INT 32
56308: PUSH
56309: EMPTY
56310: LIST
56311: LIST
56312: PUSH
56313: LD_INT 30
56315: PUSH
56316: LD_INT 33
56318: PUSH
56319: EMPTY
56320: LIST
56321: LIST
56322: PUSH
56323: LD_INT 30
56325: PUSH
56326: LD_INT 4
56328: PUSH
56329: EMPTY
56330: LIST
56331: LIST
56332: PUSH
56333: LD_INT 30
56335: PUSH
56336: LD_INT 5
56338: PUSH
56339: EMPTY
56340: LIST
56341: LIST
56342: PUSH
56343: EMPTY
56344: LIST
56345: LIST
56346: LIST
56347: LIST
56348: LIST
56349: PUSH
56350: EMPTY
56351: LIST
56352: LIST
56353: PPUSH
56354: CALL_OW 72
56358: PUSH
56359: LD_INT 4
56361: LESS
56362: IFTRUE 56430
56364: PUSH
56365: LD_EXP 102
56369: PUSH
56370: LD_VAR 0 2
56374: ARRAY
56375: PPUSH
56376: LD_INT 3
56378: PUSH
56379: LD_INT 24
56381: PUSH
56382: LD_INT 1000
56384: PUSH
56385: EMPTY
56386: LIST
56387: LIST
56388: PUSH
56389: EMPTY
56390: LIST
56391: LIST
56392: PUSH
56393: LD_INT 2
56395: PUSH
56396: LD_INT 30
56398: PUSH
56399: LD_INT 0
56401: PUSH
56402: EMPTY
56403: LIST
56404: LIST
56405: PUSH
56406: LD_INT 30
56408: PUSH
56409: LD_INT 1
56411: PUSH
56412: EMPTY
56413: LIST
56414: LIST
56415: PUSH
56416: EMPTY
56417: LIST
56418: LIST
56419: LIST
56420: PUSH
56421: EMPTY
56422: LIST
56423: LIST
56424: PPUSH
56425: CALL_OW 72
56429: OR
56430: AND
56431: IFFALSE 56684
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56433: LD_ADDR_EXP 145
56437: PUSH
56438: LD_EXP 145
56442: PPUSH
56443: LD_VAR 0 2
56447: PPUSH
56448: LD_INT 1
56450: PPUSH
56451: CALL_OW 1
56455: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56456: LD_ADDR_VAR 0 4
56460: PUSH
56461: LD_EXP 102
56465: PUSH
56466: LD_VAR 0 2
56470: ARRAY
56471: PPUSH
56472: LD_INT 2
56474: PUSH
56475: LD_INT 25
56477: PUSH
56478: LD_INT 1
56480: PUSH
56481: EMPTY
56482: LIST
56483: LIST
56484: PUSH
56485: LD_INT 25
56487: PUSH
56488: LD_INT 5
56490: PUSH
56491: EMPTY
56492: LIST
56493: LIST
56494: PUSH
56495: LD_INT 25
56497: PUSH
56498: LD_INT 8
56500: PUSH
56501: EMPTY
56502: LIST
56503: LIST
56504: PUSH
56505: LD_INT 25
56507: PUSH
56508: LD_INT 9
56510: PUSH
56511: EMPTY
56512: LIST
56513: LIST
56514: PUSH
56515: EMPTY
56516: LIST
56517: LIST
56518: LIST
56519: LIST
56520: LIST
56521: PPUSH
56522: CALL_OW 72
56526: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
56527: LD_ADDR_VAR 0 4
56531: PUSH
56532: LD_VAR 0 4
56536: PUSH
56537: LD_VAR 0 4
56541: PPUSH
56542: LD_INT 18
56544: PPUSH
56545: CALL 106684 0 2
56549: DIFF
56550: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
56551: LD_VAR 0 4
56555: NOT
56556: IFFALSE 56604
56558: PUSH
56559: LD_EXP 102
56563: PUSH
56564: LD_VAR 0 2
56568: ARRAY
56569: PPUSH
56570: LD_INT 2
56572: PUSH
56573: LD_INT 30
56575: PUSH
56576: LD_INT 4
56578: PUSH
56579: EMPTY
56580: LIST
56581: LIST
56582: PUSH
56583: LD_INT 30
56585: PUSH
56586: LD_INT 5
56588: PUSH
56589: EMPTY
56590: LIST
56591: LIST
56592: PUSH
56593: EMPTY
56594: LIST
56595: LIST
56596: LIST
56597: PPUSH
56598: CALL_OW 72
56602: NOT
56603: AND
56604: IFFALSE 56666
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
56606: LD_ADDR_VAR 0 4
56610: PUSH
56611: LD_EXP 102
56615: PUSH
56616: LD_VAR 0 2
56620: ARRAY
56621: PPUSH
56622: LD_INT 2
56624: PUSH
56625: LD_INT 25
56627: PUSH
56628: LD_INT 2
56630: PUSH
56631: EMPTY
56632: LIST
56633: LIST
56634: PUSH
56635: LD_INT 25
56637: PUSH
56638: LD_INT 3
56640: PUSH
56641: EMPTY
56642: LIST
56643: LIST
56644: PUSH
56645: LD_INT 25
56647: PUSH
56648: LD_INT 4
56650: PUSH
56651: EMPTY
56652: LIST
56653: LIST
56654: PUSH
56655: EMPTY
56656: LIST
56657: LIST
56658: LIST
56659: LIST
56660: PPUSH
56661: CALL_OW 72
56665: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
56666: LD_VAR 0 2
56670: PPUSH
56671: LD_VAR 0 4
56675: PPUSH
56676: CALL 141822 0 2
// exit ;
56680: POP
56681: POP
56682: GO 56808
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
56684: LD_EXP 125
56688: PUSH
56689: LD_VAR 0 2
56693: ARRAY
56694: IFFALSE 56709
56696: PUSH
56697: LD_EXP 145
56701: PUSH
56702: LD_VAR 0 2
56706: ARRAY
56707: NOT
56708: AND
56709: IFFALSE 56723
56711: PUSH
56712: LD_EXP 124
56716: PUSH
56717: LD_VAR 0 2
56721: ARRAY
56722: AND
56723: IFFALSE 56804
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
56725: LD_ADDR_EXP 145
56729: PUSH
56730: LD_EXP 145
56734: PPUSH
56735: LD_VAR 0 2
56739: PPUSH
56740: LD_INT 1
56742: PPUSH
56743: CALL_OW 1
56747: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
56748: LD_ADDR_VAR 0 4
56752: PUSH
56753: LD_EXP 124
56757: PUSH
56758: LD_VAR 0 2
56762: ARRAY
56763: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
56764: LD_ADDR_EXP 124
56768: PUSH
56769: LD_EXP 124
56773: PPUSH
56774: LD_VAR 0 2
56778: PPUSH
56779: EMPTY
56780: PPUSH
56781: CALL_OW 1
56785: ST_TO_ADDR
// Defend ( i , tmp ) ;
56786: LD_VAR 0 2
56790: PPUSH
56791: LD_VAR 0 4
56795: PPUSH
56796: CALL 142426 0 2
// exit ;
56800: POP
56801: POP
56802: GO 56808
// end ; end ;
56804: GO 55946
56806: POP
56807: POP
// end ;
56808: LD_VAR 0 1
56812: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
56813: LD_INT 0
56815: PPUSH
56816: PPUSH
56817: PPUSH
56818: PPUSH
56819: PPUSH
56820: PPUSH
56821: PPUSH
56822: PPUSH
56823: PPUSH
56824: PPUSH
56825: PPUSH
// if not mc_bases then
56826: LD_EXP 102
56830: NOT
56831: IFFALSE 56835
// exit ;
56833: GO 57948
// for i = 1 to mc_bases do
56835: LD_ADDR_VAR 0 2
56839: PUSH
56840: DOUBLE
56841: LD_INT 1
56843: DEC
56844: ST_TO_ADDR
56845: LD_EXP 102
56849: PUSH
56850: FOR_TO
56851: IFFALSE 57946
// begin tmp := mc_lab [ i ] ;
56853: LD_ADDR_VAR 0 6
56857: PUSH
56858: LD_EXP 135
56862: PUSH
56863: LD_VAR 0 2
56867: ARRAY
56868: ST_TO_ADDR
// if not tmp then
56869: LD_VAR 0 6
56873: NOT
56874: IFFALSE 56878
// continue ;
56876: GO 56850
// idle_lab := 0 ;
56878: LD_ADDR_VAR 0 11
56882: PUSH
56883: LD_INT 0
56885: ST_TO_ADDR
// for j in tmp do
56886: LD_ADDR_VAR 0 3
56890: PUSH
56891: LD_VAR 0 6
56895: PUSH
56896: FOR_IN
56897: IFFALSE 57942
// begin researching := false ;
56899: LD_ADDR_VAR 0 10
56903: PUSH
56904: LD_INT 0
56906: ST_TO_ADDR
// side := GetSide ( j ) ;
56907: LD_ADDR_VAR 0 4
56911: PUSH
56912: LD_VAR 0 3
56916: PPUSH
56917: CALL_OW 255
56921: ST_TO_ADDR
// if not mc_tech [ side ] then
56922: LD_EXP 129
56926: PUSH
56927: LD_VAR 0 4
56931: ARRAY
56932: NOT
56933: IFFALSE 56937
// continue ;
56935: GO 56896
// if BuildingStatus ( j ) = bs_idle then
56937: LD_VAR 0 3
56941: PPUSH
56942: CALL_OW 461
56946: PUSH
56947: LD_INT 2
56949: EQUAL
56950: IFFALSE 57142
// begin if idle_lab and UnitsInside ( j ) < 6 then
56952: LD_VAR 0 11
56956: IFFALSE 56973
56958: PUSH
56959: LD_VAR 0 3
56963: PPUSH
56964: CALL_OW 313
56968: PUSH
56969: LD_INT 6
56971: LESS
56972: AND
56973: IFFALSE 57044
// begin tmp2 := UnitsInside ( idle_lab ) ;
56975: LD_ADDR_VAR 0 9
56979: PUSH
56980: LD_VAR 0 11
56984: PPUSH
56985: CALL_OW 313
56989: ST_TO_ADDR
// if tmp2 then
56990: LD_VAR 0 9
56994: IFFALSE 57036
// for x in tmp2 do
56996: LD_ADDR_VAR 0 7
57000: PUSH
57001: LD_VAR 0 9
57005: PUSH
57006: FOR_IN
57007: IFFALSE 57034
// begin ComExitBuilding ( x ) ;
57009: LD_VAR 0 7
57013: PPUSH
57014: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57018: LD_VAR 0 7
57022: PPUSH
57023: LD_VAR 0 3
57027: PPUSH
57028: CALL_OW 180
// end ;
57032: GO 57006
57034: POP
57035: POP
// idle_lab := 0 ;
57036: LD_ADDR_VAR 0 11
57040: PUSH
57041: LD_INT 0
57043: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
57044: LD_ADDR_VAR 0 5
57048: PUSH
57049: LD_EXP 129
57053: PUSH
57054: LD_VAR 0 4
57058: ARRAY
57059: PUSH
57060: FOR_IN
57061: IFFALSE 57123
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
57063: LD_VAR 0 3
57067: PPUSH
57068: LD_VAR 0 5
57072: PPUSH
57073: CALL_OW 430
57077: IFFALSE 57095
57079: PUSH
57080: LD_VAR 0 4
57084: PPUSH
57085: LD_VAR 0 5
57089: PPUSH
57090: CALL 71907 0 2
57094: AND
57095: IFFALSE 57121
// begin researching := true ;
57097: LD_ADDR_VAR 0 10
57101: PUSH
57102: LD_INT 1
57104: ST_TO_ADDR
// ComResearch ( j , t ) ;
57105: LD_VAR 0 3
57109: PPUSH
57110: LD_VAR 0 5
57114: PPUSH
57115: CALL_OW 124
// break ;
57119: GO 57123
// end ;
57121: GO 57060
57123: POP
57124: POP
// if not researching then
57125: LD_VAR 0 10
57129: NOT
57130: IFFALSE 57142
// idle_lab := j ;
57132: LD_ADDR_VAR 0 11
57136: PUSH
57137: LD_VAR 0 3
57141: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
57142: LD_VAR 0 3
57146: PPUSH
57147: CALL_OW 461
57151: PUSH
57152: LD_INT 10
57154: EQUAL
57155: IFFALSE 57761
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
57157: LD_EXP 131
57161: PUSH
57162: LD_VAR 0 2
57166: ARRAY
57167: NOT
57168: IFFALSE 57183
57170: PUSH
57171: LD_EXP 132
57175: PUSH
57176: LD_VAR 0 2
57180: ARRAY
57181: NOT
57182: AND
57183: IFFALSE 57201
57185: PUSH
57186: LD_EXP 129
57190: PUSH
57191: LD_VAR 0 4
57195: ARRAY
57196: PUSH
57197: LD_INT 1
57199: GREATER
57200: AND
57201: IFFALSE 57332
// begin ComCancel ( j ) ;
57203: LD_VAR 0 3
57207: PPUSH
57208: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
57212: LD_ADDR_EXP 129
57216: PUSH
57217: LD_EXP 129
57221: PPUSH
57222: LD_VAR 0 4
57226: PPUSH
57227: LD_EXP 129
57231: PUSH
57232: LD_VAR 0 4
57236: ARRAY
57237: PPUSH
57238: LD_EXP 129
57242: PUSH
57243: LD_VAR 0 4
57247: ARRAY
57248: PUSH
57249: LD_INT 1
57251: MINUS
57252: PPUSH
57253: LD_EXP 129
57257: PUSH
57258: LD_VAR 0 4
57262: ARRAY
57263: PPUSH
57264: LD_INT 0
57266: PPUSH
57267: CALL 75489 0 4
57271: PPUSH
57272: CALL_OW 1
57276: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
57277: LD_ADDR_EXP 129
57281: PUSH
57282: LD_EXP 129
57286: PPUSH
57287: LD_VAR 0 4
57291: PPUSH
57292: LD_EXP 129
57296: PUSH
57297: LD_VAR 0 4
57301: ARRAY
57302: PPUSH
57303: LD_EXP 129
57307: PUSH
57308: LD_VAR 0 4
57312: ARRAY
57313: PPUSH
57314: LD_INT 1
57316: PPUSH
57317: LD_INT 0
57319: PPUSH
57320: CALL 75489 0 4
57324: PPUSH
57325: CALL_OW 1
57329: ST_TO_ADDR
// continue ;
57330: GO 56896
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
57332: LD_EXP 131
57336: PUSH
57337: LD_VAR 0 2
57341: ARRAY
57342: IFFALSE 57357
57344: PUSH
57345: LD_EXP 132
57349: PUSH
57350: LD_VAR 0 2
57354: ARRAY
57355: NOT
57356: AND
57357: IFFALSE 57484
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
57359: LD_ADDR_EXP 132
57363: PUSH
57364: LD_EXP 132
57368: PPUSH
57369: LD_VAR 0 2
57373: PUSH
57374: LD_EXP 132
57378: PUSH
57379: LD_VAR 0 2
57383: ARRAY
57384: PUSH
57385: LD_INT 1
57387: PLUS
57388: PUSH
57389: EMPTY
57390: LIST
57391: LIST
57392: PPUSH
57393: LD_EXP 131
57397: PUSH
57398: LD_VAR 0 2
57402: ARRAY
57403: PUSH
57404: LD_INT 1
57406: ARRAY
57407: PPUSH
57408: CALL 76081 0 3
57412: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
57413: LD_EXP 131
57417: PUSH
57418: LD_VAR 0 2
57422: ARRAY
57423: PUSH
57424: LD_INT 1
57426: ARRAY
57427: PPUSH
57428: LD_INT 112
57430: PPUSH
57431: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
57435: LD_ADDR_VAR 0 9
57439: PUSH
57440: LD_EXP 131
57444: PUSH
57445: LD_VAR 0 2
57449: ARRAY
57450: PPUSH
57451: LD_INT 1
57453: PPUSH
57454: CALL_OW 3
57458: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
57459: LD_ADDR_EXP 131
57463: PUSH
57464: LD_EXP 131
57468: PPUSH
57469: LD_VAR 0 2
57473: PPUSH
57474: LD_VAR 0 9
57478: PPUSH
57479: CALL_OW 1
57483: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
57484: LD_EXP 131
57488: PUSH
57489: LD_VAR 0 2
57493: ARRAY
57494: IFFALSE 57508
57496: PUSH
57497: LD_EXP 132
57501: PUSH
57502: LD_VAR 0 2
57506: ARRAY
57507: AND
57508: IFFALSE 57532
57510: PUSH
57511: LD_EXP 132
57515: PUSH
57516: LD_VAR 0 2
57520: ARRAY
57521: PUSH
57522: LD_INT 1
57524: ARRAY
57525: PPUSH
57526: CALL_OW 310
57530: NOT
57531: AND
57532: IFFALSE 57549
57534: PUSH
57535: LD_VAR 0 3
57539: PPUSH
57540: CALL_OW 313
57544: PUSH
57545: LD_INT 6
57547: EQUAL
57548: AND
57549: IFFALSE 57605
// begin tmp2 := UnitsInside ( j ) ;
57551: LD_ADDR_VAR 0 9
57555: PUSH
57556: LD_VAR 0 3
57560: PPUSH
57561: CALL_OW 313
57565: ST_TO_ADDR
// if tmp2 = 6 then
57566: LD_VAR 0 9
57570: PUSH
57571: LD_INT 6
57573: EQUAL
57574: IFFALSE 57605
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
57576: LD_VAR 0 9
57580: PUSH
57581: LD_INT 1
57583: ARRAY
57584: PPUSH
57585: LD_INT 112
57587: PPUSH
57588: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
57592: LD_VAR 0 9
57596: PUSH
57597: LD_INT 1
57599: ARRAY
57600: PPUSH
57601: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
57605: LD_EXP 132
57609: PUSH
57610: LD_VAR 0 2
57614: ARRAY
57615: IFFALSE 57639
57617: PUSH
57618: LD_EXP 132
57622: PUSH
57623: LD_VAR 0 2
57627: ARRAY
57628: PUSH
57629: LD_INT 1
57631: ARRAY
57632: PPUSH
57633: CALL_OW 314
57637: NOT
57638: AND
57639: IFFALSE 57663
57641: PUSH
57642: LD_EXP 132
57646: PUSH
57647: LD_VAR 0 2
57651: ARRAY
57652: PUSH
57653: LD_INT 1
57655: ARRAY
57656: PPUSH
57657: CALL_OW 310
57661: NOT
57662: AND
57663: IFFALSE 57689
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
57665: LD_EXP 132
57669: PUSH
57670: LD_VAR 0 2
57674: ARRAY
57675: PUSH
57676: LD_INT 1
57678: ARRAY
57679: PPUSH
57680: LD_VAR 0 3
57684: PPUSH
57685: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
57689: LD_EXP 132
57693: PUSH
57694: LD_VAR 0 2
57698: ARRAY
57699: PUSH
57700: LD_INT 1
57702: ARRAY
57703: PPUSH
57704: CALL_OW 310
57708: IFFALSE 57740
57710: PUSH
57711: LD_EXP 132
57715: PUSH
57716: LD_VAR 0 2
57720: ARRAY
57721: PUSH
57722: LD_INT 1
57724: ARRAY
57725: PPUSH
57726: CALL_OW 310
57730: PPUSH
57731: CALL_OW 461
57735: PUSH
57736: LD_INT 3
57738: NONEQUAL
57739: AND
57740: IFFALSE 57761
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
57742: LD_EXP 132
57746: PUSH
57747: LD_VAR 0 2
57751: ARRAY
57752: PUSH
57753: LD_INT 1
57755: ARRAY
57756: PPUSH
57757: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
57761: LD_VAR 0 3
57765: PPUSH
57766: CALL_OW 461
57770: PUSH
57771: LD_INT 6
57773: EQUAL
57774: IFFALSE 57786
57776: PUSH
57777: LD_VAR 0 6
57781: PUSH
57782: LD_INT 1
57784: GREATER
57785: AND
57786: IFFALSE 57940
// begin sci := [ ] ;
57788: LD_ADDR_VAR 0 8
57792: PUSH
57793: EMPTY
57794: ST_TO_ADDR
// for x in ( tmp diff j ) do
57795: LD_ADDR_VAR 0 7
57799: PUSH
57800: LD_VAR 0 6
57804: PUSH
57805: LD_VAR 0 3
57809: DIFF
57810: PUSH
57811: FOR_IN
57812: IFFALSE 57864
// begin if sci = 6 then
57814: LD_VAR 0 8
57818: PUSH
57819: LD_INT 6
57821: EQUAL
57822: IFFALSE 57826
// break ;
57824: GO 57864
// if BuildingStatus ( x ) = bs_idle then
57826: LD_VAR 0 7
57830: PPUSH
57831: CALL_OW 461
57835: PUSH
57836: LD_INT 2
57838: EQUAL
57839: IFFALSE 57862
// sci := sci ^ UnitsInside ( x ) ;
57841: LD_ADDR_VAR 0 8
57845: PUSH
57846: LD_VAR 0 8
57850: PUSH
57851: LD_VAR 0 7
57855: PPUSH
57856: CALL_OW 313
57860: ADD
57861: ST_TO_ADDR
// end ;
57862: GO 57811
57864: POP
57865: POP
// if not sci then
57866: LD_VAR 0 8
57870: NOT
57871: IFFALSE 57875
// continue ;
57873: GO 56896
// for x in sci do
57875: LD_ADDR_VAR 0 7
57879: PUSH
57880: LD_VAR 0 8
57884: PUSH
57885: FOR_IN
57886: IFFALSE 57938
// if IsInUnit ( x ) and not HasTask ( x ) then
57888: LD_VAR 0 7
57892: PPUSH
57893: CALL_OW 310
57897: IFFALSE 57911
57899: PUSH
57900: LD_VAR 0 7
57904: PPUSH
57905: CALL_OW 314
57909: NOT
57910: AND
57911: IFFALSE 57936
// begin ComExitBuilding ( x ) ;
57913: LD_VAR 0 7
57917: PPUSH
57918: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
57922: LD_VAR 0 7
57926: PPUSH
57927: LD_VAR 0 3
57931: PPUSH
57932: CALL_OW 180
// end ;
57936: GO 57885
57938: POP
57939: POP
// end ; end ;
57940: GO 56896
57942: POP
57943: POP
// end ;
57944: GO 56850
57946: POP
57947: POP
// end ;
57948: LD_VAR 0 1
57952: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
57953: LD_INT 0
57955: PPUSH
57956: PPUSH
// if not mc_bases then
57957: LD_EXP 102
57961: NOT
57962: IFFALSE 57966
// exit ;
57964: GO 58049
// for i = 1 to mc_bases do
57966: LD_ADDR_VAR 0 2
57970: PUSH
57971: DOUBLE
57972: LD_INT 1
57974: DEC
57975: ST_TO_ADDR
57976: LD_EXP 102
57980: PUSH
57981: FOR_TO
57982: IFFALSE 58047
// if mc_mines [ i ] and mc_miners [ i ] then
57984: LD_EXP 115
57988: PUSH
57989: LD_VAR 0 2
57993: ARRAY
57994: IFFALSE 58008
57996: PUSH
57997: LD_EXP 116
58001: PUSH
58002: LD_VAR 0 2
58006: ARRAY
58007: AND
58008: IFFALSE 58045
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
58010: LD_EXP 116
58014: PUSH
58015: LD_VAR 0 2
58019: ARRAY
58020: PUSH
58021: LD_INT 1
58023: ARRAY
58024: PPUSH
58025: CALL_OW 255
58029: PPUSH
58030: LD_EXP 115
58034: PUSH
58035: LD_VAR 0 2
58039: ARRAY
58040: PPUSH
58041: CALL 73000 0 2
58045: GO 57981
58047: POP
58048: POP
// end ;
58049: LD_VAR 0 1
58053: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
58054: LD_INT 0
58056: PPUSH
58057: PPUSH
58058: PPUSH
58059: PPUSH
58060: PPUSH
58061: PPUSH
58062: PPUSH
58063: PPUSH
// if not mc_bases or not mc_parking then
58064: LD_EXP 102
58068: NOT
58069: IFTRUE 58078
58071: PUSH
58072: LD_EXP 126
58076: NOT
58077: OR
58078: IFFALSE 58082
// exit ;
58080: GO 58826
// for i = 1 to mc_bases do
58082: LD_ADDR_VAR 0 2
58086: PUSH
58087: DOUBLE
58088: LD_INT 1
58090: DEC
58091: ST_TO_ADDR
58092: LD_EXP 102
58096: PUSH
58097: FOR_TO
58098: IFFALSE 58824
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
58100: LD_EXP 102
58104: PUSH
58105: LD_VAR 0 2
58109: ARRAY
58110: NOT
58111: IFTRUE 58126
58113: PUSH
58114: LD_EXP 126
58118: PUSH
58119: LD_VAR 0 2
58123: ARRAY
58124: NOT
58125: OR
58126: IFFALSE 58130
// continue ;
58128: GO 58097
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
58130: LD_ADDR_VAR 0 5
58134: PUSH
58135: LD_EXP 102
58139: PUSH
58140: LD_VAR 0 2
58144: ARRAY
58145: PUSH
58146: LD_INT 1
58148: ARRAY
58149: PPUSH
58150: CALL_OW 255
58154: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58155: LD_ADDR_VAR 0 6
58159: PUSH
58160: LD_EXP 102
58164: PUSH
58165: LD_VAR 0 2
58169: ARRAY
58170: PPUSH
58171: LD_INT 30
58173: PUSH
58174: LD_INT 3
58176: PUSH
58177: EMPTY
58178: LIST
58179: LIST
58180: PPUSH
58181: CALL_OW 72
58185: ST_TO_ADDR
// if not fac then
58186: LD_VAR 0 6
58190: NOT
58191: IFFALSE 58242
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58193: LD_ADDR_VAR 0 6
58197: PUSH
58198: LD_EXP 102
58202: PUSH
58203: LD_VAR 0 2
58207: ARRAY
58208: PPUSH
58209: LD_INT 2
58211: PUSH
58212: LD_INT 30
58214: PUSH
58215: LD_INT 0
58217: PUSH
58218: EMPTY
58219: LIST
58220: LIST
58221: PUSH
58222: LD_INT 30
58224: PUSH
58225: LD_INT 1
58227: PUSH
58228: EMPTY
58229: LIST
58230: LIST
58231: PUSH
58232: EMPTY
58233: LIST
58234: LIST
58235: LIST
58236: PPUSH
58237: CALL_OW 72
58241: ST_TO_ADDR
// if not fac then
58242: LD_VAR 0 6
58246: NOT
58247: IFFALSE 58251
// continue ;
58249: GO 58097
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58251: LD_ADDR_VAR 0 7
58255: PUSH
58256: LD_EXP 126
58260: PUSH
58261: LD_VAR 0 2
58265: ARRAY
58266: PPUSH
58267: LD_INT 22
58269: PUSH
58270: LD_VAR 0 5
58274: PUSH
58275: EMPTY
58276: LIST
58277: LIST
58278: PUSH
58279: LD_INT 21
58281: PUSH
58282: LD_INT 2
58284: PUSH
58285: EMPTY
58286: LIST
58287: LIST
58288: PUSH
58289: LD_INT 3
58291: PUSH
58292: LD_INT 60
58294: PUSH
58295: EMPTY
58296: LIST
58297: PUSH
58298: EMPTY
58299: LIST
58300: LIST
58301: PUSH
58302: LD_INT 3
58304: PUSH
58305: LD_INT 24
58307: PUSH
58308: LD_INT 1000
58310: PUSH
58311: EMPTY
58312: LIST
58313: LIST
58314: PUSH
58315: EMPTY
58316: LIST
58317: LIST
58318: PUSH
58319: EMPTY
58320: LIST
58321: LIST
58322: LIST
58323: LIST
58324: PPUSH
58325: CALL_OW 70
58329: ST_TO_ADDR
// for j in fac do
58330: LD_ADDR_VAR 0 3
58334: PUSH
58335: LD_VAR 0 6
58339: PUSH
58340: FOR_IN
58341: IFFALSE 58436
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58343: LD_ADDR_VAR 0 7
58347: PUSH
58348: LD_VAR 0 7
58352: PUSH
58353: LD_INT 22
58355: PUSH
58356: LD_VAR 0 5
58360: PUSH
58361: EMPTY
58362: LIST
58363: LIST
58364: PUSH
58365: LD_INT 91
58367: PUSH
58368: LD_VAR 0 3
58372: PUSH
58373: LD_INT 15
58375: PUSH
58376: EMPTY
58377: LIST
58378: LIST
58379: LIST
58380: PUSH
58381: LD_INT 21
58383: PUSH
58384: LD_INT 2
58386: PUSH
58387: EMPTY
58388: LIST
58389: LIST
58390: PUSH
58391: LD_INT 3
58393: PUSH
58394: LD_INT 60
58396: PUSH
58397: EMPTY
58398: LIST
58399: PUSH
58400: EMPTY
58401: LIST
58402: LIST
58403: PUSH
58404: LD_INT 3
58406: PUSH
58407: LD_INT 24
58409: PUSH
58410: LD_INT 1000
58412: PUSH
58413: EMPTY
58414: LIST
58415: LIST
58416: PUSH
58417: EMPTY
58418: LIST
58419: LIST
58420: PUSH
58421: EMPTY
58422: LIST
58423: LIST
58424: LIST
58425: LIST
58426: LIST
58427: PPUSH
58428: CALL_OW 69
58432: UNION
58433: ST_TO_ADDR
58434: GO 58340
58436: POP
58437: POP
// if not vehs then
58438: LD_VAR 0 7
58442: NOT
58443: IFFALSE 58469
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
58445: LD_ADDR_EXP 114
58449: PUSH
58450: LD_EXP 114
58454: PPUSH
58455: LD_VAR 0 2
58459: PPUSH
58460: EMPTY
58461: PPUSH
58462: CALL_OW 1
58466: ST_TO_ADDR
// continue ;
58467: GO 58097
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
58469: LD_ADDR_VAR 0 8
58473: PUSH
58474: LD_EXP 102
58478: PUSH
58479: LD_VAR 0 2
58483: ARRAY
58484: PPUSH
58485: LD_INT 30
58487: PUSH
58488: LD_INT 3
58490: PUSH
58491: EMPTY
58492: LIST
58493: LIST
58494: PPUSH
58495: CALL_OW 72
58499: ST_TO_ADDR
// if tmp then
58500: LD_VAR 0 8
58504: IFFALSE 58607
// begin for j in tmp do
58506: LD_ADDR_VAR 0 3
58510: PUSH
58511: LD_VAR 0 8
58515: PUSH
58516: FOR_IN
58517: IFFALSE 58605
// for k in UnitsInside ( j ) do
58519: LD_ADDR_VAR 0 4
58523: PUSH
58524: LD_VAR 0 3
58528: PPUSH
58529: CALL_OW 313
58533: PUSH
58534: FOR_IN
58535: IFFALSE 58601
// if k then
58537: LD_VAR 0 4
58541: IFFALSE 58599
// if not k in mc_repair_vehicle [ i ] then
58543: LD_VAR 0 4
58547: PUSH
58548: LD_EXP 114
58552: PUSH
58553: LD_VAR 0 2
58557: ARRAY
58558: IN
58559: NOT
58560: IFFALSE 58599
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
58562: LD_ADDR_EXP 114
58566: PUSH
58567: LD_EXP 114
58571: PPUSH
58572: LD_VAR 0 2
58576: PPUSH
58577: LD_EXP 114
58581: PUSH
58582: LD_VAR 0 2
58586: ARRAY
58587: PUSH
58588: LD_VAR 0 4
58592: UNION
58593: PPUSH
58594: CALL_OW 1
58598: ST_TO_ADDR
58599: GO 58534
58601: POP
58602: POP
58603: GO 58516
58605: POP
58606: POP
// end ; if not mc_repair_vehicle [ i ] then
58607: LD_EXP 114
58611: PUSH
58612: LD_VAR 0 2
58616: ARRAY
58617: NOT
58618: IFFALSE 58622
// continue ;
58620: GO 58097
// for j in mc_repair_vehicle [ i ] do
58622: LD_ADDR_VAR 0 3
58626: PUSH
58627: LD_EXP 114
58631: PUSH
58632: LD_VAR 0 2
58636: ARRAY
58637: PUSH
58638: FOR_IN
58639: IFFALSE 58820
// begin if GetClass ( j ) <> 3 then
58641: LD_VAR 0 3
58645: PPUSH
58646: CALL_OW 257
58650: PUSH
58651: LD_INT 3
58653: NONEQUAL
58654: IFFALSE 58695
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
58656: LD_ADDR_EXP 114
58660: PUSH
58661: LD_EXP 114
58665: PPUSH
58666: LD_VAR 0 2
58670: PPUSH
58671: LD_EXP 114
58675: PUSH
58676: LD_VAR 0 2
58680: ARRAY
58681: PUSH
58682: LD_VAR 0 3
58686: DIFF
58687: PPUSH
58688: CALL_OW 1
58692: ST_TO_ADDR
// continue ;
58693: GO 58638
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58695: LD_VAR 0 3
58699: PPUSH
58700: CALL_OW 311
58704: NOT
58705: IFFALSE 58730
58707: PUSH
58708: LD_VAR 0 3
58712: PUSH
58713: LD_EXP 105
58717: PUSH
58718: LD_VAR 0 2
58722: ARRAY
58723: PUSH
58724: LD_INT 1
58726: ARRAY
58727: IN
58728: NOT
58729: AND
58730: IFFALSE 58755
58732: PUSH
58733: LD_VAR 0 3
58737: PUSH
58738: LD_EXP 105
58742: PUSH
58743: LD_VAR 0 2
58747: ARRAY
58748: PUSH
58749: LD_INT 2
58751: ARRAY
58752: IN
58753: NOT
58754: AND
58755: IFFALSE 58818
// begin if IsInUnit ( j ) then
58757: LD_VAR 0 3
58761: PPUSH
58762: CALL_OW 310
58766: IFFALSE 58779
// ComExitBuilding ( j ) else
58768: LD_VAR 0 3
58772: PPUSH
58773: CALL_OW 122
58777: GO 58818
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
58779: LD_VAR 0 3
58783: PPUSH
58784: LD_VAR 0 7
58788: PUSH
58789: LD_INT 1
58791: ARRAY
58792: PPUSH
58793: CALL 111222 0 2
58797: NOT
58798: IFFALSE 58818
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
58800: LD_VAR 0 3
58804: PPUSH
58805: LD_VAR 0 7
58809: PUSH
58810: LD_INT 1
58812: ARRAY
58813: PPUSH
58814: CALL_OW 129
// end ; end ;
58818: GO 58638
58820: POP
58821: POP
// end ;
58822: GO 58097
58824: POP
58825: POP
// end ;
58826: LD_VAR 0 1
58830: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
58831: LD_INT 0
58833: PPUSH
58834: PPUSH
58835: PPUSH
58836: PPUSH
58837: PPUSH
58838: PPUSH
58839: PPUSH
58840: PPUSH
58841: PPUSH
58842: PPUSH
58843: PPUSH
// if not mc_bases then
58844: LD_EXP 102
58848: NOT
58849: IFFALSE 58853
// exit ;
58851: GO 59671
// for i = 1 to mc_bases do
58853: LD_ADDR_VAR 0 2
58857: PUSH
58858: DOUBLE
58859: LD_INT 1
58861: DEC
58862: ST_TO_ADDR
58863: LD_EXP 102
58867: PUSH
58868: FOR_TO
58869: IFFALSE 59669
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
58871: LD_EXP 130
58875: PUSH
58876: LD_VAR 0 2
58880: ARRAY
58881: NOT
58882: IFTRUE 58900
58884: PUSH
58885: LD_EXP 105
58889: PUSH
58890: LD_VAR 0 2
58894: ARRAY
58895: PUSH
58896: LD_INT 1
58898: ARRAY
58899: OR
58900: IFTRUE 58918
58902: PUSH
58903: LD_EXP 105
58907: PUSH
58908: LD_VAR 0 2
58912: ARRAY
58913: PUSH
58914: LD_INT 2
58916: ARRAY
58917: OR
58918: IFTRUE 58941
58920: PUSH
58921: LD_EXP 128
58925: PUSH
58926: LD_VAR 0 2
58930: ARRAY
58931: PPUSH
58932: LD_INT 1
58934: PPUSH
58935: CALL_OW 325
58939: NOT
58940: OR
58941: IFTRUE 58955
58943: PUSH
58944: LD_EXP 125
58948: PUSH
58949: LD_VAR 0 2
58953: ARRAY
58954: OR
58955: IFFALSE 58959
// continue ;
58957: GO 58868
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
58959: LD_ADDR_VAR 0 8
58963: PUSH
58964: LD_EXP 102
58968: PUSH
58969: LD_VAR 0 2
58973: ARRAY
58974: PPUSH
58975: LD_INT 25
58977: PUSH
58978: LD_INT 4
58980: PUSH
58981: EMPTY
58982: LIST
58983: LIST
58984: PUSH
58985: LD_INT 50
58987: PUSH
58988: EMPTY
58989: LIST
58990: PUSH
58991: LD_INT 3
58993: PUSH
58994: LD_INT 60
58996: PUSH
58997: EMPTY
58998: LIST
58999: PUSH
59000: EMPTY
59001: LIST
59002: LIST
59003: PUSH
59004: EMPTY
59005: LIST
59006: LIST
59007: LIST
59008: PPUSH
59009: CALL_OW 72
59013: PUSH
59014: LD_EXP 106
59018: PUSH
59019: LD_VAR 0 2
59023: ARRAY
59024: DIFF
59025: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59026: LD_ADDR_VAR 0 9
59030: PUSH
59031: LD_EXP 102
59035: PUSH
59036: LD_VAR 0 2
59040: ARRAY
59041: PPUSH
59042: LD_INT 2
59044: PUSH
59045: LD_INT 30
59047: PUSH
59048: LD_INT 0
59050: PUSH
59051: EMPTY
59052: LIST
59053: LIST
59054: PUSH
59055: LD_INT 30
59057: PUSH
59058: LD_INT 1
59060: PUSH
59061: EMPTY
59062: LIST
59063: LIST
59064: PUSH
59065: EMPTY
59066: LIST
59067: LIST
59068: LIST
59069: PPUSH
59070: CALL_OW 72
59074: ST_TO_ADDR
// if not tmp or not dep then
59075: LD_VAR 0 8
59079: NOT
59080: IFTRUE 59089
59082: PUSH
59083: LD_VAR 0 9
59087: NOT
59088: OR
59089: IFFALSE 59093
// continue ;
59091: GO 58868
// side := GetSide ( tmp [ 1 ] ) ;
59093: LD_ADDR_VAR 0 11
59097: PUSH
59098: LD_VAR 0 8
59102: PUSH
59103: LD_INT 1
59105: ARRAY
59106: PPUSH
59107: CALL_OW 255
59111: ST_TO_ADDR
// dep := dep [ 1 ] ;
59112: LD_ADDR_VAR 0 9
59116: PUSH
59117: LD_VAR 0 9
59121: PUSH
59122: LD_INT 1
59124: ARRAY
59125: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
59126: LD_ADDR_VAR 0 7
59130: PUSH
59131: LD_EXP 130
59135: PUSH
59136: LD_VAR 0 2
59140: ARRAY
59141: PPUSH
59142: LD_INT 22
59144: PUSH
59145: LD_INT 0
59147: PUSH
59148: EMPTY
59149: LIST
59150: LIST
59151: PUSH
59152: LD_INT 25
59154: PUSH
59155: LD_INT 12
59157: PUSH
59158: EMPTY
59159: LIST
59160: LIST
59161: PUSH
59162: EMPTY
59163: LIST
59164: LIST
59165: PPUSH
59166: CALL_OW 70
59170: PUSH
59171: LD_INT 22
59173: PUSH
59174: LD_INT 0
59176: PUSH
59177: EMPTY
59178: LIST
59179: LIST
59180: PUSH
59181: LD_INT 25
59183: PUSH
59184: LD_INT 12
59186: PUSH
59187: EMPTY
59188: LIST
59189: LIST
59190: PUSH
59191: LD_INT 91
59193: PUSH
59194: LD_VAR 0 9
59198: PUSH
59199: LD_INT 20
59201: PUSH
59202: EMPTY
59203: LIST
59204: LIST
59205: LIST
59206: PUSH
59207: EMPTY
59208: LIST
59209: LIST
59210: LIST
59211: PPUSH
59212: CALL_OW 69
59216: UNION
59217: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
59218: LD_ADDR_VAR 0 10
59222: PUSH
59223: LD_EXP 130
59227: PUSH
59228: LD_VAR 0 2
59232: ARRAY
59233: PPUSH
59234: LD_INT 81
59236: PUSH
59237: LD_VAR 0 11
59241: PUSH
59242: EMPTY
59243: LIST
59244: LIST
59245: PPUSH
59246: CALL_OW 70
59250: ST_TO_ADDR
// if not apes or danger_at_area then
59251: LD_VAR 0 7
59255: NOT
59256: IFTRUE 59264
59258: PUSH
59259: LD_VAR 0 10
59263: OR
59264: IFFALSE 59314
// begin if mc_taming [ i ] then
59266: LD_EXP 133
59270: PUSH
59271: LD_VAR 0 2
59275: ARRAY
59276: IFFALSE 59312
// begin MC_Reset ( i , 121 ) ;
59278: LD_VAR 0 2
59282: PPUSH
59283: LD_INT 121
59285: PPUSH
59286: CALL 44046 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59290: LD_ADDR_EXP 133
59294: PUSH
59295: LD_EXP 133
59299: PPUSH
59300: LD_VAR 0 2
59304: PPUSH
59305: EMPTY
59306: PPUSH
59307: CALL_OW 1
59311: ST_TO_ADDR
// end ; continue ;
59312: GO 58868
// end ; for j in tmp do
59314: LD_ADDR_VAR 0 3
59318: PUSH
59319: LD_VAR 0 8
59323: PUSH
59324: FOR_IN
59325: IFFALSE 59665
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
59327: LD_VAR 0 3
59331: PUSH
59332: LD_EXP 133
59336: PUSH
59337: LD_VAR 0 2
59341: ARRAY
59342: IN
59343: NOT
59344: IFFALSE 59362
59346: PUSH
59347: LD_EXP 133
59351: PUSH
59352: LD_VAR 0 2
59356: ARRAY
59357: PUSH
59358: LD_INT 3
59360: LESS
59361: AND
59362: IFFALSE 59420
// begin SetTag ( j , 121 ) ;
59364: LD_VAR 0 3
59368: PPUSH
59369: LD_INT 121
59371: PPUSH
59372: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
59376: LD_ADDR_EXP 133
59380: PUSH
59381: LD_EXP 133
59385: PPUSH
59386: LD_VAR 0 2
59390: PUSH
59391: LD_EXP 133
59395: PUSH
59396: LD_VAR 0 2
59400: ARRAY
59401: PUSH
59402: LD_INT 1
59404: PLUS
59405: PUSH
59406: EMPTY
59407: LIST
59408: LIST
59409: PPUSH
59410: LD_VAR 0 3
59414: PPUSH
59415: CALL 76081 0 3
59419: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
59420: LD_VAR 0 3
59424: PUSH
59425: LD_EXP 133
59429: PUSH
59430: LD_VAR 0 2
59434: ARRAY
59435: IN
59436: IFFALSE 59663
// begin if GetClass ( j ) <> 4 then
59438: LD_VAR 0 3
59442: PPUSH
59443: CALL_OW 257
59447: PUSH
59448: LD_INT 4
59450: NONEQUAL
59451: IFFALSE 59504
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
59453: LD_ADDR_EXP 133
59457: PUSH
59458: LD_EXP 133
59462: PPUSH
59463: LD_VAR 0 2
59467: PPUSH
59468: LD_EXP 133
59472: PUSH
59473: LD_VAR 0 2
59477: ARRAY
59478: PUSH
59479: LD_VAR 0 3
59483: DIFF
59484: PPUSH
59485: CALL_OW 1
59489: ST_TO_ADDR
// SetTag ( j , 0 ) ;
59490: LD_VAR 0 3
59494: PPUSH
59495: LD_INT 0
59497: PPUSH
59498: CALL_OW 109
// continue ;
59502: GO 59324
// end ; if IsInUnit ( j ) then
59504: LD_VAR 0 3
59508: PPUSH
59509: CALL_OW 310
59513: IFFALSE 59524
// ComExitBuilding ( j ) ;
59515: LD_VAR 0 3
59519: PPUSH
59520: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
59524: LD_ADDR_VAR 0 6
59528: PUSH
59529: LD_VAR 0 7
59533: PPUSH
59534: LD_VAR 0 3
59538: PPUSH
59539: CALL_OW 74
59543: ST_TO_ADDR
// if not ape then
59544: LD_VAR 0 6
59548: NOT
59549: IFFALSE 59553
// break ;
59551: GO 59665
// x := GetX ( ape ) ;
59553: LD_ADDR_VAR 0 4
59557: PUSH
59558: LD_VAR 0 6
59562: PPUSH
59563: CALL_OW 250
59567: ST_TO_ADDR
// y := GetY ( ape ) ;
59568: LD_ADDR_VAR 0 5
59572: PUSH
59573: LD_VAR 0 6
59577: PPUSH
59578: CALL_OW 251
59582: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
59583: LD_VAR 0 4
59587: PPUSH
59588: LD_VAR 0 5
59592: PPUSH
59593: CALL_OW 488
59597: NOT
59598: IFTRUE 59628
59600: PUSH
59601: LD_VAR 0 11
59605: PPUSH
59606: LD_VAR 0 4
59610: PPUSH
59611: LD_VAR 0 5
59615: PPUSH
59616: LD_INT 20
59618: PPUSH
59619: CALL 77351 0 4
59623: PUSH
59624: LD_INT 4
59626: ARRAY
59627: OR
59628: IFFALSE 59632
// break ;
59630: GO 59665
// if not HasTask ( j ) then
59632: LD_VAR 0 3
59636: PPUSH
59637: CALL_OW 314
59641: NOT
59642: IFFALSE 59663
// ComTameXY ( j , x , y ) ;
59644: LD_VAR 0 3
59648: PPUSH
59649: LD_VAR 0 4
59653: PPUSH
59654: LD_VAR 0 5
59658: PPUSH
59659: CALL_OW 131
// end ; end ;
59663: GO 59324
59665: POP
59666: POP
// end ;
59667: GO 58868
59669: POP
59670: POP
// end ;
59671: LD_VAR 0 1
59675: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
59676: LD_INT 0
59678: PPUSH
59679: PPUSH
59680: PPUSH
59681: PPUSH
59682: PPUSH
59683: PPUSH
59684: PPUSH
59685: PPUSH
// if not mc_bases then
59686: LD_EXP 102
59690: NOT
59691: IFFALSE 59695
// exit ;
59693: GO 60327
// for i = 1 to mc_bases do
59695: LD_ADDR_VAR 0 2
59699: PUSH
59700: DOUBLE
59701: LD_INT 1
59703: DEC
59704: ST_TO_ADDR
59705: LD_EXP 102
59709: PUSH
59710: FOR_TO
59711: IFFALSE 60325
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
59713: LD_EXP 131
59717: PUSH
59718: LD_VAR 0 2
59722: ARRAY
59723: NOT
59724: IFTRUE 59754
59726: PUSH
59727: LD_EXP 131
59731: PUSH
59732: LD_VAR 0 2
59736: ARRAY
59737: PPUSH
59738: LD_INT 25
59740: PUSH
59741: LD_INT 12
59743: PUSH
59744: EMPTY
59745: LIST
59746: LIST
59747: PPUSH
59748: CALL_OW 72
59752: NOT
59753: OR
59754: IFFALSE 59758
// continue ;
59756: GO 59710
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
59758: LD_ADDR_VAR 0 5
59762: PUSH
59763: LD_EXP 131
59767: PUSH
59768: LD_VAR 0 2
59772: ARRAY
59773: PUSH
59774: LD_INT 1
59776: ARRAY
59777: PPUSH
59778: CALL_OW 255
59782: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
59783: LD_VAR 0 5
59787: PPUSH
59788: LD_INT 2
59790: PPUSH
59791: CALL_OW 325
59795: IFFALSE 60048
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
59797: LD_ADDR_VAR 0 4
59801: PUSH
59802: LD_EXP 131
59806: PUSH
59807: LD_VAR 0 2
59811: ARRAY
59812: PPUSH
59813: LD_INT 25
59815: PUSH
59816: LD_INT 16
59818: PUSH
59819: EMPTY
59820: LIST
59821: LIST
59822: PPUSH
59823: CALL_OW 72
59827: ST_TO_ADDR
// if tmp < 6 then
59828: LD_VAR 0 4
59832: PUSH
59833: LD_INT 6
59835: LESS
59836: IFFALSE 60048
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59838: LD_ADDR_VAR 0 6
59842: PUSH
59843: LD_EXP 102
59847: PUSH
59848: LD_VAR 0 2
59852: ARRAY
59853: PPUSH
59854: LD_INT 2
59856: PUSH
59857: LD_INT 30
59859: PUSH
59860: LD_INT 0
59862: PUSH
59863: EMPTY
59864: LIST
59865: LIST
59866: PUSH
59867: LD_INT 30
59869: PUSH
59870: LD_INT 1
59872: PUSH
59873: EMPTY
59874: LIST
59875: LIST
59876: PUSH
59877: EMPTY
59878: LIST
59879: LIST
59880: LIST
59881: PPUSH
59882: CALL_OW 72
59886: ST_TO_ADDR
// if depot then
59887: LD_VAR 0 6
59891: IFFALSE 60048
// begin selected := 0 ;
59893: LD_ADDR_VAR 0 7
59897: PUSH
59898: LD_INT 0
59900: ST_TO_ADDR
// for j in depot do
59901: LD_ADDR_VAR 0 3
59905: PUSH
59906: LD_VAR 0 6
59910: PUSH
59911: FOR_IN
59912: IFFALSE 59943
// begin if UnitsInside ( j ) < 6 then
59914: LD_VAR 0 3
59918: PPUSH
59919: CALL_OW 313
59923: PUSH
59924: LD_INT 6
59926: LESS
59927: IFFALSE 59941
// begin selected := j ;
59929: LD_ADDR_VAR 0 7
59933: PUSH
59934: LD_VAR 0 3
59938: ST_TO_ADDR
// break ;
59939: GO 59943
// end ; end ;
59941: GO 59911
59943: POP
59944: POP
// if selected then
59945: LD_VAR 0 7
59949: IFFALSE 60048
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
59951: LD_ADDR_VAR 0 3
59955: PUSH
59956: LD_EXP 131
59960: PUSH
59961: LD_VAR 0 2
59965: ARRAY
59966: PPUSH
59967: LD_INT 25
59969: PUSH
59970: LD_INT 12
59972: PUSH
59973: EMPTY
59974: LIST
59975: LIST
59976: PPUSH
59977: CALL_OW 72
59981: PUSH
59982: FOR_IN
59983: IFFALSE 60046
// if not HasTask ( j ) then
59985: LD_VAR 0 3
59989: PPUSH
59990: CALL_OW 314
59994: NOT
59995: IFFALSE 60044
// begin if not IsInUnit ( j ) then
59997: LD_VAR 0 3
60001: PPUSH
60002: CALL_OW 310
60006: NOT
60007: IFFALSE 60023
// ComEnterUnit ( j , selected ) ;
60009: LD_VAR 0 3
60013: PPUSH
60014: LD_VAR 0 7
60018: PPUSH
60019: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
60023: LD_VAR 0 3
60027: PPUSH
60028: LD_INT 16
60030: PPUSH
60031: CALL_OW 183
// AddComExitBuilding ( j ) ;
60035: LD_VAR 0 3
60039: PPUSH
60040: CALL_OW 182
// end ;
60044: GO 59982
60046: POP
60047: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
60048: LD_VAR 0 5
60052: PPUSH
60053: LD_INT 11
60055: PPUSH
60056: CALL_OW 325
60060: IFFALSE 60323
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
60062: LD_ADDR_VAR 0 4
60066: PUSH
60067: LD_EXP 131
60071: PUSH
60072: LD_VAR 0 2
60076: ARRAY
60077: PPUSH
60078: LD_INT 25
60080: PUSH
60081: LD_INT 16
60083: PUSH
60084: EMPTY
60085: LIST
60086: LIST
60087: PPUSH
60088: CALL_OW 72
60092: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
60093: LD_VAR 0 4
60097: PUSH
60098: LD_INT 6
60100: GREATEREQUAL
60101: IFTRUE 60118
60103: PUSH
60104: LD_VAR 0 5
60108: PPUSH
60109: LD_INT 2
60111: PPUSH
60112: CALL_OW 325
60116: NOT
60117: OR
60118: IFFALSE 60323
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
60120: LD_ADDR_VAR 0 8
60124: PUSH
60125: LD_EXP 102
60129: PUSH
60130: LD_VAR 0 2
60134: ARRAY
60135: PPUSH
60136: LD_INT 2
60138: PUSH
60139: LD_INT 30
60141: PUSH
60142: LD_INT 4
60144: PUSH
60145: EMPTY
60146: LIST
60147: LIST
60148: PUSH
60149: LD_INT 30
60151: PUSH
60152: LD_INT 5
60154: PUSH
60155: EMPTY
60156: LIST
60157: LIST
60158: PUSH
60159: EMPTY
60160: LIST
60161: LIST
60162: LIST
60163: PPUSH
60164: CALL_OW 72
60168: ST_TO_ADDR
// if barracks then
60169: LD_VAR 0 8
60173: IFFALSE 60323
// begin selected := 0 ;
60175: LD_ADDR_VAR 0 7
60179: PUSH
60180: LD_INT 0
60182: ST_TO_ADDR
// for j in barracks do
60183: LD_ADDR_VAR 0 3
60187: PUSH
60188: LD_VAR 0 8
60192: PUSH
60193: FOR_IN
60194: IFFALSE 60225
// begin if UnitsInside ( j ) < 6 then
60196: LD_VAR 0 3
60200: PPUSH
60201: CALL_OW 313
60205: PUSH
60206: LD_INT 6
60208: LESS
60209: IFFALSE 60223
// begin selected := j ;
60211: LD_ADDR_VAR 0 7
60215: PUSH
60216: LD_VAR 0 3
60220: ST_TO_ADDR
// break ;
60221: GO 60225
// end ; end ;
60223: GO 60193
60225: POP
60226: POP
// if selected then
60227: LD_VAR 0 7
60231: IFFALSE 60323
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
60233: LD_ADDR_VAR 0 3
60237: PUSH
60238: LD_EXP 131
60242: PUSH
60243: LD_VAR 0 2
60247: ARRAY
60248: PPUSH
60249: LD_INT 25
60251: PUSH
60252: LD_INT 12
60254: PUSH
60255: EMPTY
60256: LIST
60257: LIST
60258: PPUSH
60259: CALL_OW 72
60263: PUSH
60264: FOR_IN
60265: IFFALSE 60321
// if not IsInUnit ( j ) and not HasTask ( j ) then
60267: LD_VAR 0 3
60271: PPUSH
60272: CALL_OW 310
60276: NOT
60277: IFFALSE 60291
60279: PUSH
60280: LD_VAR 0 3
60284: PPUSH
60285: CALL_OW 314
60289: NOT
60290: AND
60291: IFFALSE 60319
// begin ComEnterUnit ( j , selected ) ;
60293: LD_VAR 0 3
60297: PPUSH
60298: LD_VAR 0 7
60302: PPUSH
60303: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
60307: LD_VAR 0 3
60311: PPUSH
60312: LD_INT 15
60314: PPUSH
60315: CALL_OW 183
// end ;
60319: GO 60264
60321: POP
60322: POP
// end ; end ; end ; end ; end ;
60323: GO 59710
60325: POP
60326: POP
// end ;
60327: LD_VAR 0 1
60331: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
60332: LD_INT 0
60334: PPUSH
60335: PPUSH
60336: PPUSH
60337: PPUSH
// if not mc_bases then
60338: LD_EXP 102
60342: NOT
60343: IFFALSE 60347
// exit ;
60345: GO 60529
// for i = 1 to mc_bases do
60347: LD_ADDR_VAR 0 2
60351: PUSH
60352: DOUBLE
60353: LD_INT 1
60355: DEC
60356: ST_TO_ADDR
60357: LD_EXP 102
60361: PUSH
60362: FOR_TO
60363: IFFALSE 60527
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
60365: LD_ADDR_VAR 0 4
60369: PUSH
60370: LD_EXP 102
60374: PUSH
60375: LD_VAR 0 2
60379: ARRAY
60380: PPUSH
60381: LD_INT 25
60383: PUSH
60384: LD_INT 9
60386: PUSH
60387: EMPTY
60388: LIST
60389: LIST
60390: PPUSH
60391: CALL_OW 72
60395: ST_TO_ADDR
// if not tmp then
60396: LD_VAR 0 4
60400: NOT
60401: IFFALSE 60405
// continue ;
60403: GO 60362
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
60405: LD_EXP 128
60409: PUSH
60410: LD_VAR 0 2
60414: ARRAY
60415: PPUSH
60416: LD_INT 29
60418: PPUSH
60419: CALL_OW 325
60423: NOT
60424: IFFALSE 60447
60426: PUSH
60427: LD_EXP 128
60431: PUSH
60432: LD_VAR 0 2
60436: ARRAY
60437: PPUSH
60438: LD_INT 28
60440: PPUSH
60441: CALL_OW 325
60445: NOT
60446: AND
60447: IFFALSE 60451
// continue ;
60449: GO 60362
// for j in tmp do
60451: LD_ADDR_VAR 0 3
60455: PUSH
60456: LD_VAR 0 4
60460: PUSH
60461: FOR_IN
60462: IFFALSE 60523
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
60464: LD_VAR 0 3
60468: PUSH
60469: LD_EXP 105
60473: PUSH
60474: LD_VAR 0 2
60478: ARRAY
60479: PUSH
60480: LD_INT 1
60482: ARRAY
60483: IN
60484: NOT
60485: IFFALSE 60510
60487: PUSH
60488: LD_VAR 0 3
60492: PUSH
60493: LD_EXP 105
60497: PUSH
60498: LD_VAR 0 2
60502: ARRAY
60503: PUSH
60504: LD_INT 2
60506: ARRAY
60507: IN
60508: NOT
60509: AND
60510: IFFALSE 60521
// ComSpaceTimeShoot ( j ) ;
60512: LD_VAR 0 3
60516: PPUSH
60517: CALL 71998 0 1
60521: GO 60461
60523: POP
60524: POP
// end ;
60525: GO 60362
60527: POP
60528: POP
// end ;
60529: LD_VAR 0 1
60533: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
60534: LD_INT 0
60536: PPUSH
60537: PPUSH
60538: PPUSH
60539: PPUSH
60540: PPUSH
60541: PPUSH
60542: PPUSH
60543: PPUSH
60544: PPUSH
// if not mc_bases then
60545: LD_EXP 102
60549: NOT
60550: IFFALSE 60554
// exit ;
60552: GO 61186
// for i = 1 to mc_bases do
60554: LD_ADDR_VAR 0 2
60558: PUSH
60559: DOUBLE
60560: LD_INT 1
60562: DEC
60563: ST_TO_ADDR
60564: LD_EXP 102
60568: PUSH
60569: FOR_TO
60570: IFFALSE 61184
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
60572: LD_EXP 137
60576: PUSH
60577: LD_VAR 0 2
60581: ARRAY
60582: NOT
60583: IFTRUE 60609
60585: PUSH
60586: LD_INT 38
60588: PPUSH
60589: LD_EXP 128
60593: PUSH
60594: LD_VAR 0 2
60598: ARRAY
60599: PPUSH
60600: CALL_OW 321
60604: PUSH
60605: LD_INT 2
60607: NONEQUAL
60608: OR
60609: IFFALSE 60613
// continue ;
60611: GO 60569
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
60613: LD_ADDR_VAR 0 8
60617: PUSH
60618: LD_EXP 102
60622: PUSH
60623: LD_VAR 0 2
60627: ARRAY
60628: PPUSH
60629: LD_INT 30
60631: PUSH
60632: LD_INT 34
60634: PUSH
60635: EMPTY
60636: LIST
60637: LIST
60638: PPUSH
60639: CALL_OW 72
60643: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
60644: LD_ADDR_VAR 0 9
60648: PUSH
60649: LD_EXP 102
60653: PUSH
60654: LD_VAR 0 2
60658: ARRAY
60659: PPUSH
60660: LD_INT 25
60662: PUSH
60663: LD_INT 4
60665: PUSH
60666: EMPTY
60667: LIST
60668: LIST
60669: PPUSH
60670: CALL_OW 72
60674: PPUSH
60675: LD_INT 0
60677: PPUSH
60678: CALL 106684 0 2
60682: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
60683: LD_VAR 0 9
60687: NOT
60688: IFTRUE 60697
60690: PUSH
60691: LD_VAR 0 8
60695: NOT
60696: OR
60697: IFTRUE 60719
60699: PUSH
60700: LD_EXP 102
60704: PUSH
60705: LD_VAR 0 2
60709: ARRAY
60710: PPUSH
60711: LD_INT 124
60713: PPUSH
60714: CALL 106684 0 2
60718: OR
60719: IFFALSE 60723
// continue ;
60721: GO 60569
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
60723: LD_EXP 138
60727: PUSH
60728: LD_VAR 0 2
60732: ARRAY
60733: PUSH
60734: LD_EXP 137
60738: PUSH
60739: LD_VAR 0 2
60743: ARRAY
60744: LESS
60745: IFFALSE 60765
60747: PUSH
60748: LD_EXP 138
60752: PUSH
60753: LD_VAR 0 2
60757: ARRAY
60758: PUSH
60759: LD_VAR 0 8
60763: LESS
60764: AND
60765: IFFALSE 61182
// begin tmp := sci [ 1 ] ;
60767: LD_ADDR_VAR 0 7
60771: PUSH
60772: LD_VAR 0 9
60776: PUSH
60777: LD_INT 1
60779: ARRAY
60780: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
60781: LD_VAR 0 7
60785: PPUSH
60786: LD_INT 124
60788: PPUSH
60789: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
60793: LD_ADDR_VAR 0 3
60797: PUSH
60798: DOUBLE
60799: LD_EXP 137
60803: PUSH
60804: LD_VAR 0 2
60808: ARRAY
60809: INC
60810: ST_TO_ADDR
60811: LD_EXP 137
60815: PUSH
60816: LD_VAR 0 2
60820: ARRAY
60821: PUSH
60822: FOR_DOWNTO
60823: IFFALSE 61168
// begin if IsInUnit ( tmp ) then
60825: LD_VAR 0 7
60829: PPUSH
60830: CALL_OW 310
60834: IFFALSE 60845
// ComExitBuilding ( tmp ) ;
60836: LD_VAR 0 7
60840: PPUSH
60841: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
60845: LD_INT 35
60847: PPUSH
60848: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
60852: LD_VAR 0 7
60856: PPUSH
60857: CALL_OW 310
60861: NOT
60862: IFFALSE 60876
60864: PUSH
60865: LD_VAR 0 7
60869: PPUSH
60870: CALL_OW 314
60874: NOT
60875: AND
60876: IFFALSE 60845
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
60878: LD_ADDR_VAR 0 6
60882: PUSH
60883: LD_VAR 0 7
60887: PPUSH
60888: CALL_OW 250
60892: PUSH
60893: LD_VAR 0 7
60897: PPUSH
60898: CALL_OW 251
60902: PUSH
60903: EMPTY
60904: LIST
60905: LIST
60906: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
60907: LD_INT 35
60909: PPUSH
60910: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
60914: LD_ADDR_VAR 0 4
60918: PUSH
60919: LD_EXP 137
60923: PUSH
60924: LD_VAR 0 2
60928: ARRAY
60929: PUSH
60930: LD_VAR 0 3
60934: ARRAY
60935: PUSH
60936: LD_INT 1
60938: ARRAY
60939: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
60940: LD_ADDR_VAR 0 5
60944: PUSH
60945: LD_EXP 137
60949: PUSH
60950: LD_VAR 0 2
60954: ARRAY
60955: PUSH
60956: LD_VAR 0 3
60960: ARRAY
60961: PUSH
60962: LD_INT 2
60964: ARRAY
60965: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
60966: LD_VAR 0 7
60970: PPUSH
60971: LD_INT 10
60973: PPUSH
60974: CALL 79060 0 2
60978: PUSH
60979: LD_INT 4
60981: ARRAY
60982: IFFALSE 61020
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
60984: LD_VAR 0 7
60988: PPUSH
60989: LD_VAR 0 6
60993: PUSH
60994: LD_INT 1
60996: ARRAY
60997: PPUSH
60998: LD_VAR 0 6
61002: PUSH
61003: LD_INT 2
61005: ARRAY
61006: PPUSH
61007: CALL_OW 111
// wait ( 0 0$10 ) ;
61011: LD_INT 350
61013: PPUSH
61014: CALL_OW 67
// end else
61018: GO 61046
// begin ComMoveXY ( tmp , x , y ) ;
61020: LD_VAR 0 7
61024: PPUSH
61025: LD_VAR 0 4
61029: PPUSH
61030: LD_VAR 0 5
61034: PPUSH
61035: CALL_OW 111
// wait ( 0 0$3 ) ;
61039: LD_INT 105
61041: PPUSH
61042: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
61046: LD_VAR 0 7
61050: PPUSH
61051: LD_VAR 0 4
61055: PPUSH
61056: LD_VAR 0 5
61060: PPUSH
61061: CALL_OW 307
61065: IFFALSE 60907
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
61067: LD_VAR 0 7
61071: PPUSH
61072: LD_VAR 0 4
61076: PPUSH
61077: LD_VAR 0 5
61081: PPUSH
61082: LD_VAR 0 8
61086: PUSH
61087: LD_VAR 0 3
61091: ARRAY
61092: PPUSH
61093: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
61097: LD_INT 35
61099: PPUSH
61100: CALL_OW 67
// until not HasTask ( tmp ) ;
61104: LD_VAR 0 7
61108: PPUSH
61109: CALL_OW 314
61113: NOT
61114: IFFALSE 61097
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
61116: LD_ADDR_EXP 138
61120: PUSH
61121: LD_EXP 138
61125: PPUSH
61126: LD_VAR 0 2
61130: PUSH
61131: LD_EXP 138
61135: PUSH
61136: LD_VAR 0 2
61140: ARRAY
61141: PUSH
61142: LD_INT 1
61144: PLUS
61145: PUSH
61146: EMPTY
61147: LIST
61148: LIST
61149: PPUSH
61150: LD_VAR 0 8
61154: PUSH
61155: LD_VAR 0 3
61159: ARRAY
61160: PPUSH
61161: CALL 76081 0 3
61165: ST_TO_ADDR
// end ;
61166: GO 60822
61168: POP
61169: POP
// MC_Reset ( i , 124 ) ;
61170: LD_VAR 0 2
61174: PPUSH
61175: LD_INT 124
61177: PPUSH
61178: CALL 44046 0 2
// end ; end ;
61182: GO 60569
61184: POP
61185: POP
// end ;
61186: LD_VAR 0 1
61190: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
61191: LD_INT 0
61193: PPUSH
61194: PPUSH
61195: PPUSH
// if not mc_bases then
61196: LD_EXP 102
61200: NOT
61201: IFFALSE 61205
// exit ;
61203: GO 61819
// for i = 1 to mc_bases do
61205: LD_ADDR_VAR 0 2
61209: PUSH
61210: DOUBLE
61211: LD_INT 1
61213: DEC
61214: ST_TO_ADDR
61215: LD_EXP 102
61219: PUSH
61220: FOR_TO
61221: IFFALSE 61817
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61223: LD_ADDR_VAR 0 3
61227: PUSH
61228: LD_EXP 102
61232: PUSH
61233: LD_VAR 0 2
61237: ARRAY
61238: PPUSH
61239: LD_INT 25
61241: PUSH
61242: LD_INT 4
61244: PUSH
61245: EMPTY
61246: LIST
61247: LIST
61248: PPUSH
61249: CALL_OW 72
61253: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61254: LD_VAR 0 3
61258: NOT
61259: IFTRUE 61274
61261: PUSH
61262: LD_EXP 139
61266: PUSH
61267: LD_VAR 0 2
61271: ARRAY
61272: NOT
61273: OR
61274: IFTRUE 61322
61276: PUSH
61277: LD_EXP 102
61281: PUSH
61282: LD_VAR 0 2
61286: ARRAY
61287: PPUSH
61288: LD_INT 2
61290: PUSH
61291: LD_INT 30
61293: PUSH
61294: LD_INT 0
61296: PUSH
61297: EMPTY
61298: LIST
61299: LIST
61300: PUSH
61301: LD_INT 30
61303: PUSH
61304: LD_INT 1
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: PUSH
61311: EMPTY
61312: LIST
61313: LIST
61314: LIST
61315: PPUSH
61316: CALL_OW 72
61320: NOT
61321: OR
61322: IFFALSE 61372
// begin if mc_deposits_finder [ i ] then
61324: LD_EXP 140
61328: PUSH
61329: LD_VAR 0 2
61333: ARRAY
61334: IFFALSE 61370
// begin MC_Reset ( i , 125 ) ;
61336: LD_VAR 0 2
61340: PPUSH
61341: LD_INT 125
61343: PPUSH
61344: CALL 44046 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
61348: LD_ADDR_EXP 140
61352: PUSH
61353: LD_EXP 140
61357: PPUSH
61358: LD_VAR 0 2
61362: PPUSH
61363: EMPTY
61364: PPUSH
61365: CALL_OW 1
61369: ST_TO_ADDR
// end ; continue ;
61370: GO 61220
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
61372: LD_EXP 139
61376: PUSH
61377: LD_VAR 0 2
61381: ARRAY
61382: PUSH
61383: LD_INT 1
61385: ARRAY
61386: PUSH
61387: LD_INT 3
61389: ARRAY
61390: PUSH
61391: LD_INT 1
61393: EQUAL
61394: IFFALSE 61420
61396: PUSH
61397: LD_INT 20
61399: PPUSH
61400: LD_EXP 128
61404: PUSH
61405: LD_VAR 0 2
61409: ARRAY
61410: PPUSH
61411: CALL_OW 321
61415: PUSH
61416: LD_INT 2
61418: NONEQUAL
61419: AND
61420: IFFALSE 61470
// begin if mc_deposits_finder [ i ] then
61422: LD_EXP 140
61426: PUSH
61427: LD_VAR 0 2
61431: ARRAY
61432: IFFALSE 61468
// begin MC_Reset ( i , 125 ) ;
61434: LD_VAR 0 2
61438: PPUSH
61439: LD_INT 125
61441: PPUSH
61442: CALL 44046 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
61446: LD_ADDR_EXP 140
61450: PUSH
61451: LD_EXP 140
61455: PPUSH
61456: LD_VAR 0 2
61460: PPUSH
61461: EMPTY
61462: PPUSH
61463: CALL_OW 1
61467: ST_TO_ADDR
// end ; continue ;
61468: GO 61220
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
61470: LD_EXP 139
61474: PUSH
61475: LD_VAR 0 2
61479: ARRAY
61480: PUSH
61481: LD_INT 1
61483: ARRAY
61484: PUSH
61485: LD_INT 1
61487: ARRAY
61488: PPUSH
61489: LD_EXP 139
61493: PUSH
61494: LD_VAR 0 2
61498: ARRAY
61499: PUSH
61500: LD_INT 1
61502: ARRAY
61503: PUSH
61504: LD_INT 2
61506: ARRAY
61507: PPUSH
61508: LD_EXP 128
61512: PUSH
61513: LD_VAR 0 2
61517: ARRAY
61518: PPUSH
61519: CALL_OW 440
61523: IFFALSE 61566
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
61525: LD_ADDR_EXP 139
61529: PUSH
61530: LD_EXP 139
61534: PPUSH
61535: LD_VAR 0 2
61539: PPUSH
61540: LD_EXP 139
61544: PUSH
61545: LD_VAR 0 2
61549: ARRAY
61550: PPUSH
61551: LD_INT 1
61553: PPUSH
61554: CALL_OW 3
61558: PPUSH
61559: CALL_OW 1
61563: ST_TO_ADDR
61564: GO 61815
// begin if not mc_deposits_finder [ i ] then
61566: LD_EXP 140
61570: PUSH
61571: LD_VAR 0 2
61575: ARRAY
61576: NOT
61577: IFFALSE 61629
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
61579: LD_ADDR_EXP 140
61583: PUSH
61584: LD_EXP 140
61588: PPUSH
61589: LD_VAR 0 2
61593: PPUSH
61594: LD_VAR 0 3
61598: PUSH
61599: LD_INT 1
61601: ARRAY
61602: PUSH
61603: EMPTY
61604: LIST
61605: PPUSH
61606: CALL_OW 1
61610: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
61611: LD_VAR 0 3
61615: PUSH
61616: LD_INT 1
61618: ARRAY
61619: PPUSH
61620: LD_INT 125
61622: PPUSH
61623: CALL_OW 109
// end else
61627: GO 61815
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
61629: LD_EXP 140
61633: PUSH
61634: LD_VAR 0 2
61638: ARRAY
61639: PUSH
61640: LD_INT 1
61642: ARRAY
61643: PPUSH
61644: CALL_OW 310
61648: IFFALSE 61671
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
61650: LD_EXP 140
61654: PUSH
61655: LD_VAR 0 2
61659: ARRAY
61660: PUSH
61661: LD_INT 1
61663: ARRAY
61664: PPUSH
61665: CALL_OW 122
61669: GO 61815
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
61671: LD_EXP 140
61675: PUSH
61676: LD_VAR 0 2
61680: ARRAY
61681: PUSH
61682: LD_INT 1
61684: ARRAY
61685: PPUSH
61686: CALL_OW 314
61690: NOT
61691: IFFALSE 61756
61693: PUSH
61694: LD_EXP 140
61698: PUSH
61699: LD_VAR 0 2
61703: ARRAY
61704: PUSH
61705: LD_INT 1
61707: ARRAY
61708: PPUSH
61709: LD_EXP 139
61713: PUSH
61714: LD_VAR 0 2
61718: ARRAY
61719: PUSH
61720: LD_INT 1
61722: ARRAY
61723: PUSH
61724: LD_INT 1
61726: ARRAY
61727: PPUSH
61728: LD_EXP 139
61732: PUSH
61733: LD_VAR 0 2
61737: ARRAY
61738: PUSH
61739: LD_INT 1
61741: ARRAY
61742: PUSH
61743: LD_INT 2
61745: ARRAY
61746: PPUSH
61747: CALL_OW 297
61751: PUSH
61752: LD_INT 6
61754: GREATER
61755: AND
61756: IFFALSE 61815
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
61758: LD_EXP 140
61762: PUSH
61763: LD_VAR 0 2
61767: ARRAY
61768: PUSH
61769: LD_INT 1
61771: ARRAY
61772: PPUSH
61773: LD_EXP 139
61777: PUSH
61778: LD_VAR 0 2
61782: ARRAY
61783: PUSH
61784: LD_INT 1
61786: ARRAY
61787: PUSH
61788: LD_INT 1
61790: ARRAY
61791: PPUSH
61792: LD_EXP 139
61796: PUSH
61797: LD_VAR 0 2
61801: ARRAY
61802: PUSH
61803: LD_INT 1
61805: ARRAY
61806: PUSH
61807: LD_INT 2
61809: ARRAY
61810: PPUSH
61811: CALL_OW 111
// end ; end ; end ;
61815: GO 61220
61817: POP
61818: POP
// end ;
61819: LD_VAR 0 1
61823: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
61824: LD_INT 0
61826: PPUSH
61827: PPUSH
61828: PPUSH
61829: PPUSH
61830: PPUSH
61831: PPUSH
61832: PPUSH
61833: PPUSH
61834: PPUSH
61835: PPUSH
61836: PPUSH
// if not mc_bases then
61837: LD_EXP 102
61841: NOT
61842: IFFALSE 61846
// exit ;
61844: GO 62806
// for i = 1 to mc_bases do
61846: LD_ADDR_VAR 0 2
61850: PUSH
61851: DOUBLE
61852: LD_INT 1
61854: DEC
61855: ST_TO_ADDR
61856: LD_EXP 102
61860: PUSH
61861: FOR_TO
61862: IFFALSE 62804
// begin if not mc_bases [ i ] or mc_scan [ i ] then
61864: LD_EXP 102
61868: PUSH
61869: LD_VAR 0 2
61873: ARRAY
61874: NOT
61875: IFTRUE 61889
61877: PUSH
61878: LD_EXP 125
61882: PUSH
61883: LD_VAR 0 2
61887: ARRAY
61888: OR
61889: IFFALSE 61893
// continue ;
61891: GO 61861
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
61893: LD_ADDR_VAR 0 7
61897: PUSH
61898: LD_EXP 102
61902: PUSH
61903: LD_VAR 0 2
61907: ARRAY
61908: PUSH
61909: LD_INT 1
61911: ARRAY
61912: PPUSH
61913: CALL_OW 248
61917: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
61918: LD_VAR 0 7
61922: PUSH
61923: LD_INT 3
61925: EQUAL
61926: IFTRUE 61968
61928: PUSH
61929: LD_EXP 121
61933: PUSH
61934: LD_VAR 0 2
61938: ARRAY
61939: PUSH
61940: LD_EXP 124
61944: PUSH
61945: LD_VAR 0 2
61949: ARRAY
61950: UNION
61951: PPUSH
61952: LD_INT 33
61954: PUSH
61955: LD_INT 2
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: PPUSH
61962: CALL_OW 72
61966: NOT
61967: OR
61968: IFFALSE 61972
// continue ;
61970: GO 61861
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
61972: LD_ADDR_VAR 0 9
61976: PUSH
61977: LD_EXP 102
61981: PUSH
61982: LD_VAR 0 2
61986: ARRAY
61987: PPUSH
61988: LD_INT 30
61990: PUSH
61991: LD_INT 36
61993: PUSH
61994: EMPTY
61995: LIST
61996: LIST
61997: PPUSH
61998: CALL_OW 72
62002: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
62003: LD_ADDR_VAR 0 10
62007: PUSH
62008: LD_EXP 121
62012: PUSH
62013: LD_VAR 0 2
62017: ARRAY
62018: PPUSH
62019: LD_INT 34
62021: PUSH
62022: LD_INT 31
62024: PUSH
62025: EMPTY
62026: LIST
62027: LIST
62028: PPUSH
62029: CALL_OW 72
62033: ST_TO_ADDR
// if not cts and not mcts then
62034: LD_VAR 0 9
62038: NOT
62039: IFFALSE 62048
62041: PUSH
62042: LD_VAR 0 10
62046: NOT
62047: AND
62048: IFFALSE 62052
// continue ;
62050: GO 61861
// x := cts ;
62052: LD_ADDR_VAR 0 11
62056: PUSH
62057: LD_VAR 0 9
62061: ST_TO_ADDR
// if not x then
62062: LD_VAR 0 11
62066: NOT
62067: IFFALSE 62079
// x := mcts ;
62069: LD_ADDR_VAR 0 11
62073: PUSH
62074: LD_VAR 0 10
62078: ST_TO_ADDR
// if not x then
62079: LD_VAR 0 11
62083: NOT
62084: IFFALSE 62088
// continue ;
62086: GO 61861
// if mc_remote_driver [ i ] then
62088: LD_EXP 142
62092: PUSH
62093: LD_VAR 0 2
62097: ARRAY
62098: IFFALSE 62497
// for j in mc_remote_driver [ i ] do
62100: LD_ADDR_VAR 0 3
62104: PUSH
62105: LD_EXP 142
62109: PUSH
62110: LD_VAR 0 2
62114: ARRAY
62115: PUSH
62116: FOR_IN
62117: IFFALSE 62495
// begin if GetClass ( j ) <> 3 then
62119: LD_VAR 0 3
62123: PPUSH
62124: CALL_OW 257
62128: PUSH
62129: LD_INT 3
62131: NONEQUAL
62132: IFFALSE 62185
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
62134: LD_ADDR_EXP 142
62138: PUSH
62139: LD_EXP 142
62143: PPUSH
62144: LD_VAR 0 2
62148: PPUSH
62149: LD_EXP 142
62153: PUSH
62154: LD_VAR 0 2
62158: ARRAY
62159: PUSH
62160: LD_VAR 0 3
62164: DIFF
62165: PPUSH
62166: CALL_OW 1
62170: ST_TO_ADDR
// SetTag ( j , 0 ) ;
62171: LD_VAR 0 3
62175: PPUSH
62176: LD_INT 0
62178: PPUSH
62179: CALL_OW 109
// continue ;
62183: GO 62116
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
62185: LD_EXP 121
62189: PUSH
62190: LD_VAR 0 2
62194: ARRAY
62195: PPUSH
62196: LD_INT 34
62198: PUSH
62199: LD_INT 31
62201: PUSH
62202: EMPTY
62203: LIST
62204: LIST
62205: PUSH
62206: LD_INT 58
62208: PUSH
62209: EMPTY
62210: LIST
62211: PUSH
62212: EMPTY
62213: LIST
62214: LIST
62215: PPUSH
62216: CALL_OW 72
62220: IFFALSE 62234
62222: PUSH
62223: LD_VAR 0 3
62227: PPUSH
62228: CALL 106719 0 1
62232: NOT
62233: AND
62234: IFFALSE 62305
// begin if IsInUnit ( j ) then
62236: LD_VAR 0 3
62240: PPUSH
62241: CALL_OW 310
62245: IFFALSE 62256
// ComExitBuilding ( j ) ;
62247: LD_VAR 0 3
62251: PPUSH
62252: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
62256: LD_VAR 0 3
62260: PPUSH
62261: LD_EXP 121
62265: PUSH
62266: LD_VAR 0 2
62270: ARRAY
62271: PPUSH
62272: LD_INT 34
62274: PUSH
62275: LD_INT 31
62277: PUSH
62278: EMPTY
62279: LIST
62280: LIST
62281: PUSH
62282: LD_INT 58
62284: PUSH
62285: EMPTY
62286: LIST
62287: PUSH
62288: EMPTY
62289: LIST
62290: LIST
62291: PPUSH
62292: CALL_OW 72
62296: PUSH
62297: LD_INT 1
62299: ARRAY
62300: PPUSH
62301: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
62305: LD_VAR 0 3
62309: PPUSH
62310: CALL_OW 310
62314: NOT
62315: IFTRUE 62351
62317: PUSH
62318: LD_VAR 0 3
62322: PPUSH
62323: CALL_OW 310
62327: PPUSH
62328: CALL_OW 266
62332: PUSH
62333: LD_INT 36
62335: NONEQUAL
62336: IFFALSE 62350
62338: PUSH
62339: LD_VAR 0 3
62343: PPUSH
62344: CALL 106719 0 1
62348: NOT
62349: AND
62350: OR
62351: IFFALSE 62493
// begin if IsInUnit ( j ) then
62353: LD_VAR 0 3
62357: PPUSH
62358: CALL_OW 310
62362: IFFALSE 62373
// ComExitBuilding ( j ) ;
62364: LD_VAR 0 3
62368: PPUSH
62369: CALL_OW 122
// ct := 0 ;
62373: LD_ADDR_VAR 0 8
62377: PUSH
62378: LD_INT 0
62380: ST_TO_ADDR
// for k in x do
62381: LD_ADDR_VAR 0 4
62385: PUSH
62386: LD_VAR 0 11
62390: PUSH
62391: FOR_IN
62392: IFFALSE 62471
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
62394: LD_VAR 0 4
62398: PPUSH
62399: CALL_OW 264
62403: PUSH
62404: LD_INT 31
62406: EQUAL
62407: IFFALSE 62421
62409: PUSH
62410: LD_VAR 0 4
62414: PPUSH
62415: CALL_OW 311
62419: NOT
62420: AND
62421: IFTRUE 62455
62423: PUSH
62424: LD_VAR 0 4
62428: PPUSH
62429: CALL_OW 266
62433: PUSH
62434: LD_INT 36
62436: EQUAL
62437: IFFALSE 62454
62439: PUSH
62440: LD_VAR 0 4
62444: PPUSH
62445: CALL_OW 313
62449: PUSH
62450: LD_INT 3
62452: LESS
62453: AND
62454: OR
62455: IFFALSE 62469
// begin ct := k ;
62457: LD_ADDR_VAR 0 8
62461: PUSH
62462: LD_VAR 0 4
62466: ST_TO_ADDR
// break ;
62467: GO 62471
// end ;
62469: GO 62391
62471: POP
62472: POP
// if ct then
62473: LD_VAR 0 8
62477: IFFALSE 62493
// ComEnterUnit ( j , ct ) ;
62479: LD_VAR 0 3
62483: PPUSH
62484: LD_VAR 0 8
62488: PPUSH
62489: CALL_OW 120
// end ; end ;
62493: GO 62116
62495: POP
62496: POP
// places := 0 ;
62497: LD_ADDR_VAR 0 5
62501: PUSH
62502: LD_INT 0
62504: ST_TO_ADDR
// for j = 1 to x do
62505: LD_ADDR_VAR 0 3
62509: PUSH
62510: DOUBLE
62511: LD_INT 1
62513: DEC
62514: ST_TO_ADDR
62515: LD_VAR 0 11
62519: PUSH
62520: FOR_TO
62521: IFFALSE 62597
// if GetWeapon ( x [ j ] ) = ar_control_tower then
62523: LD_VAR 0 11
62527: PUSH
62528: LD_VAR 0 3
62532: ARRAY
62533: PPUSH
62534: CALL_OW 264
62538: PUSH
62539: LD_INT 31
62541: EQUAL
62542: IFFALSE 62560
// places := places + 1 else
62544: LD_ADDR_VAR 0 5
62548: PUSH
62549: LD_VAR 0 5
62553: PUSH
62554: LD_INT 1
62556: PLUS
62557: ST_TO_ADDR
62558: GO 62595
// if GetBType ( x [ j ] ) = b_control_tower then
62560: LD_VAR 0 11
62564: PUSH
62565: LD_VAR 0 3
62569: ARRAY
62570: PPUSH
62571: CALL_OW 266
62575: PUSH
62576: LD_INT 36
62578: EQUAL
62579: IFFALSE 62595
// places := places + 3 ;
62581: LD_ADDR_VAR 0 5
62585: PUSH
62586: LD_VAR 0 5
62590: PUSH
62591: LD_INT 3
62593: PLUS
62594: ST_TO_ADDR
62595: GO 62520
62597: POP
62598: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
62599: LD_VAR 0 5
62603: PUSH
62604: LD_INT 0
62606: EQUAL
62607: IFTRUE 62627
62609: PUSH
62610: LD_VAR 0 5
62614: PUSH
62615: LD_EXP 142
62619: PUSH
62620: LD_VAR 0 2
62624: ARRAY
62625: LESSEQUAL
62626: OR
62627: IFFALSE 62631
// continue ;
62629: GO 61861
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
62631: LD_ADDR_VAR 0 6
62635: PUSH
62636: LD_EXP 102
62640: PUSH
62641: LD_VAR 0 2
62645: ARRAY
62646: PPUSH
62647: LD_INT 25
62649: PUSH
62650: LD_INT 3
62652: PUSH
62653: EMPTY
62654: LIST
62655: LIST
62656: PPUSH
62657: CALL_OW 72
62661: PUSH
62662: LD_EXP 142
62666: PUSH
62667: LD_VAR 0 2
62671: ARRAY
62672: DIFF
62673: PPUSH
62674: LD_INT 3
62676: PPUSH
62677: CALL 107619 0 2
62681: ST_TO_ADDR
// for j in tmp do
62682: LD_ADDR_VAR 0 3
62686: PUSH
62687: LD_VAR 0 6
62691: PUSH
62692: FOR_IN
62693: IFFALSE 62728
// if GetTag ( j ) > 0 then
62695: LD_VAR 0 3
62699: PPUSH
62700: CALL_OW 110
62704: PUSH
62705: LD_INT 0
62707: GREATER
62708: IFFALSE 62726
// tmp := tmp diff j ;
62710: LD_ADDR_VAR 0 6
62714: PUSH
62715: LD_VAR 0 6
62719: PUSH
62720: LD_VAR 0 3
62724: DIFF
62725: ST_TO_ADDR
62726: GO 62692
62728: POP
62729: POP
// if not tmp then
62730: LD_VAR 0 6
62734: NOT
62735: IFFALSE 62739
// continue ;
62737: GO 61861
// if places then
62739: LD_VAR 0 5
62743: IFFALSE 62802
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
62745: LD_ADDR_EXP 142
62749: PUSH
62750: LD_EXP 142
62754: PPUSH
62755: LD_VAR 0 2
62759: PPUSH
62760: LD_EXP 142
62764: PUSH
62765: LD_VAR 0 2
62769: ARRAY
62770: PUSH
62771: LD_VAR 0 6
62775: PUSH
62776: LD_INT 1
62778: ARRAY
62779: UNION
62780: PPUSH
62781: CALL_OW 1
62785: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
62786: LD_VAR 0 6
62790: PUSH
62791: LD_INT 1
62793: ARRAY
62794: PPUSH
62795: LD_INT 126
62797: PPUSH
62798: CALL_OW 109
// end ; end ;
62802: GO 61861
62804: POP
62805: POP
// end ;
62806: LD_VAR 0 1
62810: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
62811: LD_INT 0
62813: PPUSH
62814: PPUSH
62815: PPUSH
62816: PPUSH
62817: PPUSH
62818: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
62819: LD_VAR 0 1
62823: NOT
62824: IFTRUE 62833
62826: PUSH
62827: LD_VAR 0 2
62831: NOT
62832: OR
62833: IFTRUE 62842
62835: PUSH
62836: LD_VAR 0 3
62840: NOT
62841: OR
62842: IFTRUE 62890
62844: PUSH
62845: LD_VAR 0 4
62849: PUSH
62850: LD_INT 1
62852: PUSH
62853: LD_INT 2
62855: PUSH
62856: LD_INT 3
62858: PUSH
62859: LD_INT 4
62861: PUSH
62862: LD_INT 5
62864: PUSH
62865: LD_INT 8
62867: PUSH
62868: LD_INT 9
62870: PUSH
62871: LD_INT 15
62873: PUSH
62874: LD_INT 16
62876: PUSH
62877: EMPTY
62878: LIST
62879: LIST
62880: LIST
62881: LIST
62882: LIST
62883: LIST
62884: LIST
62885: LIST
62886: LIST
62887: IN
62888: NOT
62889: OR
62890: IFFALSE 62894
// exit ;
62892: GO 63754
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
62894: LD_ADDR_VAR 0 2
62898: PUSH
62899: LD_VAR 0 2
62903: PPUSH
62904: LD_INT 21
62906: PUSH
62907: LD_INT 3
62909: PUSH
62910: EMPTY
62911: LIST
62912: LIST
62913: PUSH
62914: LD_INT 24
62916: PUSH
62917: LD_INT 250
62919: PUSH
62920: EMPTY
62921: LIST
62922: LIST
62923: PUSH
62924: EMPTY
62925: LIST
62926: LIST
62927: PPUSH
62928: CALL_OW 72
62932: ST_TO_ADDR
// case class of 1 , 15 :
62933: LD_VAR 0 4
62937: PUSH
62938: LD_INT 1
62940: DOUBLE
62941: EQUAL
62942: IFTRUE 62952
62944: LD_INT 15
62946: DOUBLE
62947: EQUAL
62948: IFTRUE 62952
62950: GO 63037
62952: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
62953: LD_ADDR_VAR 0 8
62957: PUSH
62958: LD_VAR 0 2
62962: PPUSH
62963: LD_INT 2
62965: PUSH
62966: LD_INT 30
62968: PUSH
62969: LD_INT 32
62971: PUSH
62972: EMPTY
62973: LIST
62974: LIST
62975: PUSH
62976: LD_INT 30
62978: PUSH
62979: LD_INT 31
62981: PUSH
62982: EMPTY
62983: LIST
62984: LIST
62985: PUSH
62986: EMPTY
62987: LIST
62988: LIST
62989: LIST
62990: PPUSH
62991: CALL_OW 72
62995: PUSH
62996: LD_VAR 0 2
63000: PPUSH
63001: LD_INT 2
63003: PUSH
63004: LD_INT 30
63006: PUSH
63007: LD_INT 4
63009: PUSH
63010: EMPTY
63011: LIST
63012: LIST
63013: PUSH
63014: LD_INT 30
63016: PUSH
63017: LD_INT 5
63019: PUSH
63020: EMPTY
63021: LIST
63022: LIST
63023: PUSH
63024: EMPTY
63025: LIST
63026: LIST
63027: LIST
63028: PPUSH
63029: CALL_OW 72
63033: ADD
63034: ST_TO_ADDR
63035: GO 63283
63037: LD_INT 2
63039: DOUBLE
63040: EQUAL
63041: IFTRUE 63051
63043: LD_INT 16
63045: DOUBLE
63046: EQUAL
63047: IFTRUE 63051
63049: GO 63097
63051: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
63052: LD_ADDR_VAR 0 8
63056: PUSH
63057: LD_VAR 0 2
63061: PPUSH
63062: LD_INT 2
63064: PUSH
63065: LD_INT 30
63067: PUSH
63068: LD_INT 0
63070: PUSH
63071: EMPTY
63072: LIST
63073: LIST
63074: PUSH
63075: LD_INT 30
63077: PUSH
63078: LD_INT 1
63080: PUSH
63081: EMPTY
63082: LIST
63083: LIST
63084: PUSH
63085: EMPTY
63086: LIST
63087: LIST
63088: LIST
63089: PPUSH
63090: CALL_OW 72
63094: ST_TO_ADDR
63095: GO 63283
63097: LD_INT 3
63099: DOUBLE
63100: EQUAL
63101: IFTRUE 63105
63103: GO 63151
63105: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
63106: LD_ADDR_VAR 0 8
63110: PUSH
63111: LD_VAR 0 2
63115: PPUSH
63116: LD_INT 2
63118: PUSH
63119: LD_INT 30
63121: PUSH
63122: LD_INT 2
63124: PUSH
63125: EMPTY
63126: LIST
63127: LIST
63128: PUSH
63129: LD_INT 30
63131: PUSH
63132: LD_INT 3
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: PUSH
63139: EMPTY
63140: LIST
63141: LIST
63142: LIST
63143: PPUSH
63144: CALL_OW 72
63148: ST_TO_ADDR
63149: GO 63283
63151: LD_INT 4
63153: DOUBLE
63154: EQUAL
63155: IFTRUE 63159
63157: GO 63216
63159: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
63160: LD_ADDR_VAR 0 8
63164: PUSH
63165: LD_VAR 0 2
63169: PPUSH
63170: LD_INT 2
63172: PUSH
63173: LD_INT 30
63175: PUSH
63176: LD_INT 6
63178: PUSH
63179: EMPTY
63180: LIST
63181: LIST
63182: PUSH
63183: LD_INT 30
63185: PUSH
63186: LD_INT 7
63188: PUSH
63189: EMPTY
63190: LIST
63191: LIST
63192: PUSH
63193: LD_INT 30
63195: PUSH
63196: LD_INT 8
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: EMPTY
63204: LIST
63205: LIST
63206: LIST
63207: LIST
63208: PPUSH
63209: CALL_OW 72
63213: ST_TO_ADDR
63214: GO 63283
63216: LD_INT 5
63218: DOUBLE
63219: EQUAL
63220: IFTRUE 63236
63222: LD_INT 8
63224: DOUBLE
63225: EQUAL
63226: IFTRUE 63236
63228: LD_INT 9
63230: DOUBLE
63231: EQUAL
63232: IFTRUE 63236
63234: GO 63282
63236: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
63237: LD_ADDR_VAR 0 8
63241: PUSH
63242: LD_VAR 0 2
63246: PPUSH
63247: LD_INT 2
63249: PUSH
63250: LD_INT 30
63252: PUSH
63253: LD_INT 4
63255: PUSH
63256: EMPTY
63257: LIST
63258: LIST
63259: PUSH
63260: LD_INT 30
63262: PUSH
63263: LD_INT 5
63265: PUSH
63266: EMPTY
63267: LIST
63268: LIST
63269: PUSH
63270: EMPTY
63271: LIST
63272: LIST
63273: LIST
63274: PPUSH
63275: CALL_OW 72
63279: ST_TO_ADDR
63280: GO 63283
63282: POP
// if not tmp then
63283: LD_VAR 0 8
63287: NOT
63288: IFFALSE 63292
// exit ;
63290: GO 63754
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
63292: LD_VAR 0 4
63296: PUSH
63297: LD_INT 1
63299: PUSH
63300: LD_INT 15
63302: PUSH
63303: EMPTY
63304: LIST
63305: LIST
63306: IN
63307: IFFALSE 63321
63309: PUSH
63310: LD_EXP 111
63314: PUSH
63315: LD_VAR 0 1
63319: ARRAY
63320: AND
63321: IFFALSE 63477
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
63323: LD_ADDR_VAR 0 9
63327: PUSH
63328: LD_EXP 111
63332: PUSH
63333: LD_VAR 0 1
63337: ARRAY
63338: PUSH
63339: LD_INT 1
63341: ARRAY
63342: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
63343: LD_VAR 0 9
63347: PUSH
63348: LD_EXP 112
63352: PUSH
63353: LD_VAR 0 1
63357: ARRAY
63358: IN
63359: NOT
63360: IFFALSE 63475
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
63362: LD_ADDR_EXP 112
63366: PUSH
63367: LD_EXP 112
63371: PPUSH
63372: LD_VAR 0 1
63376: PUSH
63377: LD_EXP 112
63381: PUSH
63382: LD_VAR 0 1
63386: ARRAY
63387: PUSH
63388: LD_INT 1
63390: PLUS
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: PPUSH
63396: LD_VAR 0 9
63400: PPUSH
63401: CALL 76081 0 3
63405: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
63406: LD_ADDR_EXP 111
63410: PUSH
63411: LD_EXP 111
63415: PPUSH
63416: LD_VAR 0 1
63420: PPUSH
63421: LD_EXP 111
63425: PUSH
63426: LD_VAR 0 1
63430: ARRAY
63431: PUSH
63432: LD_VAR 0 9
63436: DIFF
63437: PPUSH
63438: CALL_OW 1
63442: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
63443: LD_VAR 0 3
63447: PPUSH
63448: LD_EXP 112
63452: PUSH
63453: LD_VAR 0 1
63457: ARRAY
63458: PUSH
63459: LD_EXP 112
63463: PUSH
63464: LD_VAR 0 1
63468: ARRAY
63469: ARRAY
63470: PPUSH
63471: CALL_OW 120
// end ; exit ;
63475: GO 63754
// end ; if tmp > 1 then
63477: LD_VAR 0 8
63481: PUSH
63482: LD_INT 1
63484: GREATER
63485: IFFALSE 63589
// for i = 2 to tmp do
63487: LD_ADDR_VAR 0 6
63491: PUSH
63492: DOUBLE
63493: LD_INT 2
63495: DEC
63496: ST_TO_ADDR
63497: LD_VAR 0 8
63501: PUSH
63502: FOR_TO
63503: IFFALSE 63587
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
63505: LD_VAR 0 8
63509: PUSH
63510: LD_VAR 0 6
63514: ARRAY
63515: PPUSH
63516: CALL_OW 461
63520: PUSH
63521: LD_INT 6
63523: EQUAL
63524: IFFALSE 63585
// begin x := tmp [ i ] ;
63526: LD_ADDR_VAR 0 9
63530: PUSH
63531: LD_VAR 0 8
63535: PUSH
63536: LD_VAR 0 6
63540: ARRAY
63541: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
63542: LD_ADDR_VAR 0 8
63546: PUSH
63547: LD_VAR 0 8
63551: PPUSH
63552: LD_VAR 0 6
63556: PPUSH
63557: CALL_OW 3
63561: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
63562: LD_ADDR_VAR 0 8
63566: PUSH
63567: LD_VAR 0 8
63571: PPUSH
63572: LD_INT 1
63574: PPUSH
63575: LD_VAR 0 9
63579: PPUSH
63580: CALL_OW 2
63584: ST_TO_ADDR
// end ;
63585: GO 63502
63587: POP
63588: POP
// for i in tmp do
63589: LD_ADDR_VAR 0 6
63593: PUSH
63594: LD_VAR 0 8
63598: PUSH
63599: FOR_IN
63600: IFFALSE 63627
// begin if IsNotFull ( i ) then
63602: LD_VAR 0 6
63606: PPUSH
63607: CALL 73245 0 1
63611: IFFALSE 63625
// begin j := i ;
63613: LD_ADDR_VAR 0 7
63617: PUSH
63618: LD_VAR 0 6
63622: ST_TO_ADDR
// break ;
63623: GO 63627
// end ; end ;
63625: GO 63599
63627: POP
63628: POP
// if j then
63629: LD_VAR 0 7
63633: IFFALSE 63651
// ComEnterUnit ( unit , j ) else
63635: LD_VAR 0 3
63639: PPUSH
63640: LD_VAR 0 7
63644: PPUSH
63645: CALL_OW 120
63649: GO 63754
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
63651: LD_ADDR_VAR 0 10
63655: PUSH
63656: LD_VAR 0 2
63660: PPUSH
63661: LD_INT 2
63663: PUSH
63664: LD_INT 30
63666: PUSH
63667: LD_INT 0
63669: PUSH
63670: EMPTY
63671: LIST
63672: LIST
63673: PUSH
63674: LD_INT 30
63676: PUSH
63677: LD_INT 1
63679: PUSH
63680: EMPTY
63681: LIST
63682: LIST
63683: PUSH
63684: EMPTY
63685: LIST
63686: LIST
63687: LIST
63688: PPUSH
63689: CALL_OW 72
63693: ST_TO_ADDR
// if depot then
63694: LD_VAR 0 10
63698: IFFALSE 63754
// begin depot := NearestUnitToUnit ( depot , unit ) ;
63700: LD_ADDR_VAR 0 10
63704: PUSH
63705: LD_VAR 0 10
63709: PPUSH
63710: LD_VAR 0 3
63714: PPUSH
63715: CALL_OW 74
63719: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
63720: LD_VAR 0 3
63724: PPUSH
63725: LD_VAR 0 10
63729: PPUSH
63730: CALL_OW 296
63734: PUSH
63735: LD_INT 10
63737: GREATER
63738: IFFALSE 63754
// ComStandNearbyBuilding ( unit , depot ) ;
63740: LD_VAR 0 3
63744: PPUSH
63745: LD_VAR 0 10
63749: PPUSH
63750: CALL 72623 0 2
// end ; end ; end ;
63754: LD_VAR 0 5
63758: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
63759: LD_INT 0
63761: PPUSH
63762: PPUSH
63763: PPUSH
63764: PPUSH
// if not mc_bases then
63765: LD_EXP 102
63769: NOT
63770: IFFALSE 63774
// exit ;
63772: GO 64025
// for i = 1 to mc_bases do
63774: LD_ADDR_VAR 0 2
63778: PUSH
63779: DOUBLE
63780: LD_INT 1
63782: DEC
63783: ST_TO_ADDR
63784: LD_EXP 102
63788: PUSH
63789: FOR_TO
63790: IFFALSE 64023
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
63792: LD_ADDR_VAR 0 4
63796: PUSH
63797: LD_EXP 102
63801: PUSH
63802: LD_VAR 0 2
63806: ARRAY
63807: PPUSH
63808: LD_INT 21
63810: PUSH
63811: LD_INT 1
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PPUSH
63818: CALL_OW 72
63822: PUSH
63823: LD_EXP 131
63827: PUSH
63828: LD_VAR 0 2
63832: ARRAY
63833: UNION
63834: ST_TO_ADDR
// if not tmp then
63835: LD_VAR 0 4
63839: NOT
63840: IFFALSE 63844
// continue ;
63842: GO 63789
// for j in tmp do
63844: LD_ADDR_VAR 0 3
63848: PUSH
63849: LD_VAR 0 4
63853: PUSH
63854: FOR_IN
63855: IFFALSE 64019
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
63857: LD_VAR 0 3
63861: PPUSH
63862: CALL_OW 110
63866: NOT
63867: IFFALSE 63881
63869: PUSH
63870: LD_VAR 0 3
63874: PPUSH
63875: CALL_OW 314
63879: NOT
63880: AND
63881: IFFALSE 63895
63883: PUSH
63884: LD_VAR 0 3
63888: PPUSH
63889: CALL_OW 311
63893: NOT
63894: AND
63895: IFFALSE 63909
63897: PUSH
63898: LD_VAR 0 3
63902: PPUSH
63903: CALL_OW 310
63907: NOT
63908: AND
63909: IFFALSE 63934
63911: PUSH
63912: LD_VAR 0 3
63916: PUSH
63917: LD_EXP 105
63921: PUSH
63922: LD_VAR 0 2
63926: ARRAY
63927: PUSH
63928: LD_INT 1
63930: ARRAY
63931: IN
63932: NOT
63933: AND
63934: IFFALSE 63959
63936: PUSH
63937: LD_VAR 0 3
63941: PUSH
63942: LD_EXP 105
63946: PUSH
63947: LD_VAR 0 2
63951: ARRAY
63952: PUSH
63953: LD_INT 2
63955: ARRAY
63956: IN
63957: NOT
63958: AND
63959: IFFALSE 63980
63961: PUSH
63962: LD_VAR 0 3
63966: PUSH
63967: LD_EXP 114
63971: PUSH
63972: LD_VAR 0 2
63976: ARRAY
63977: IN
63978: NOT
63979: AND
63980: IFFALSE 64017
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
63982: LD_VAR 0 2
63986: PPUSH
63987: LD_EXP 102
63991: PUSH
63992: LD_VAR 0 2
63996: ARRAY
63997: PPUSH
63998: LD_VAR 0 3
64002: PPUSH
64003: LD_VAR 0 3
64007: PPUSH
64008: CALL_OW 257
64012: PPUSH
64013: CALL 62811 0 4
// end ;
64017: GO 63854
64019: POP
64020: POP
// end ;
64021: GO 63789
64023: POP
64024: POP
// end ;
64025: LD_VAR 0 1
64029: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
64030: LD_INT 0
64032: PPUSH
64033: PPUSH
64034: PPUSH
64035: PPUSH
64036: PPUSH
64037: PPUSH
// if not mc_bases [ base ] then
64038: LD_EXP 102
64042: PUSH
64043: LD_VAR 0 1
64047: ARRAY
64048: NOT
64049: IFFALSE 64053
// exit ;
64051: GO 64254
// tmp := [ ] ;
64053: LD_ADDR_VAR 0 6
64057: PUSH
64058: EMPTY
64059: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
64060: LD_ADDR_VAR 0 7
64064: PUSH
64065: LD_VAR 0 3
64069: PPUSH
64070: LD_INT 0
64072: PPUSH
64073: CALL_OW 517
64077: ST_TO_ADDR
// if not list then
64078: LD_VAR 0 7
64082: NOT
64083: IFFALSE 64087
// exit ;
64085: GO 64254
// c := Count ( list [ 1 ] ) ;
64087: LD_ADDR_VAR 0 9
64091: PUSH
64092: LD_VAR 0 7
64096: PUSH
64097: LD_INT 1
64099: ARRAY
64100: PPUSH
64101: CALL 73163 0 1
64105: ST_TO_ADDR
// if amount > c then
64106: LD_VAR 0 2
64110: PUSH
64111: LD_VAR 0 9
64115: GREATER
64116: IFFALSE 64128
// amount := c ;
64118: LD_ADDR_VAR 0 2
64122: PUSH
64123: LD_VAR 0 9
64127: ST_TO_ADDR
// for i := 1 to amount do
64128: LD_ADDR_VAR 0 5
64132: PUSH
64133: DOUBLE
64134: LD_INT 1
64136: DEC
64137: ST_TO_ADDR
64138: LD_VAR 0 2
64142: PUSH
64143: FOR_TO
64144: IFFALSE 64202
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
64146: LD_ADDR_VAR 0 6
64150: PUSH
64151: LD_VAR 0 6
64155: PPUSH
64156: LD_VAR 0 5
64160: PPUSH
64161: LD_VAR 0 7
64165: PUSH
64166: LD_INT 1
64168: ARRAY
64169: PUSH
64170: LD_VAR 0 5
64174: ARRAY
64175: PUSH
64176: LD_VAR 0 7
64180: PUSH
64181: LD_INT 2
64183: ARRAY
64184: PUSH
64185: LD_VAR 0 5
64189: ARRAY
64190: PUSH
64191: EMPTY
64192: LIST
64193: LIST
64194: PPUSH
64195: CALL_OW 1
64199: ST_TO_ADDR
64200: GO 64143
64202: POP
64203: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
64204: LD_ADDR_EXP 115
64208: PUSH
64209: LD_EXP 115
64213: PPUSH
64214: LD_VAR 0 1
64218: PPUSH
64219: LD_VAR 0 6
64223: PPUSH
64224: CALL_OW 1
64228: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
64229: LD_ADDR_EXP 117
64233: PUSH
64234: LD_EXP 117
64238: PPUSH
64239: LD_VAR 0 1
64243: PPUSH
64244: LD_VAR 0 3
64248: PPUSH
64249: CALL_OW 1
64253: ST_TO_ADDR
// end ;
64254: LD_VAR 0 4
64258: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
64259: LD_INT 0
64261: PPUSH
// if not mc_bases [ base ] then
64262: LD_EXP 102
64266: PUSH
64267: LD_VAR 0 1
64271: ARRAY
64272: NOT
64273: IFFALSE 64277
// exit ;
64275: GO 64302
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
64277: LD_ADDR_EXP 107
64281: PUSH
64282: LD_EXP 107
64286: PPUSH
64287: LD_VAR 0 1
64291: PPUSH
64292: LD_VAR 0 2
64296: PPUSH
64297: CALL_OW 1
64301: ST_TO_ADDR
// end ;
64302: LD_VAR 0 3
64306: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
64307: LD_INT 0
64309: PPUSH
// if not mc_bases [ base ] then
64310: LD_EXP 102
64314: PUSH
64315: LD_VAR 0 1
64319: ARRAY
64320: NOT
64321: IFFALSE 64325
// exit ;
64323: GO 64362
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
64325: LD_ADDR_EXP 107
64329: PUSH
64330: LD_EXP 107
64334: PPUSH
64335: LD_VAR 0 1
64339: PPUSH
64340: LD_EXP 107
64344: PUSH
64345: LD_VAR 0 1
64349: ARRAY
64350: PUSH
64351: LD_VAR 0 2
64355: UNION
64356: PPUSH
64357: CALL_OW 1
64361: ST_TO_ADDR
// end ;
64362: LD_VAR 0 3
64366: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
64367: LD_INT 0
64369: PPUSH
// if not mc_bases [ base ] then
64370: LD_EXP 102
64374: PUSH
64375: LD_VAR 0 1
64379: ARRAY
64380: NOT
64381: IFFALSE 64385
// exit ;
64383: GO 64410
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
64385: LD_ADDR_EXP 123
64389: PUSH
64390: LD_EXP 123
64394: PPUSH
64395: LD_VAR 0 1
64399: PPUSH
64400: LD_VAR 0 2
64404: PPUSH
64405: CALL_OW 1
64409: ST_TO_ADDR
// end ;
64410: LD_VAR 0 3
64414: RET
// export function MC_InsertProduceList ( base , components ) ; begin
64415: LD_INT 0
64417: PPUSH
// if not mc_bases [ base ] then
64418: LD_EXP 102
64422: PUSH
64423: LD_VAR 0 1
64427: ARRAY
64428: NOT
64429: IFFALSE 64433
// exit ;
64431: GO 64470
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
64433: LD_ADDR_EXP 123
64437: PUSH
64438: LD_EXP 123
64442: PPUSH
64443: LD_VAR 0 1
64447: PPUSH
64448: LD_EXP 123
64452: PUSH
64453: LD_VAR 0 1
64457: ARRAY
64458: PUSH
64459: LD_VAR 0 2
64463: ADD
64464: PPUSH
64465: CALL_OW 1
64469: ST_TO_ADDR
// end ;
64470: LD_VAR 0 3
64474: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
64475: LD_INT 0
64477: PPUSH
// if not mc_bases [ base ] then
64478: LD_EXP 102
64482: PUSH
64483: LD_VAR 0 1
64487: ARRAY
64488: NOT
64489: IFFALSE 64493
// exit ;
64491: GO 64547
// mc_defender := Replace ( mc_defender , base , deflist ) ;
64493: LD_ADDR_EXP 124
64497: PUSH
64498: LD_EXP 124
64502: PPUSH
64503: LD_VAR 0 1
64507: PPUSH
64508: LD_VAR 0 2
64512: PPUSH
64513: CALL_OW 1
64517: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
64518: LD_ADDR_EXP 113
64522: PUSH
64523: LD_EXP 113
64527: PPUSH
64528: LD_VAR 0 1
64532: PPUSH
64533: LD_VAR 0 2
64537: PUSH
64538: LD_INT 0
64540: PLUS
64541: PPUSH
64542: CALL_OW 1
64546: ST_TO_ADDR
// end ;
64547: LD_VAR 0 3
64551: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
64552: LD_INT 0
64554: PPUSH
// if not mc_bases [ base ] then
64555: LD_EXP 102
64559: PUSH
64560: LD_VAR 0 1
64564: ARRAY
64565: NOT
64566: IFFALSE 64570
// exit ;
64568: GO 64595
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
64570: LD_ADDR_EXP 113
64574: PUSH
64575: LD_EXP 113
64579: PPUSH
64580: LD_VAR 0 1
64584: PPUSH
64585: LD_VAR 0 2
64589: PPUSH
64590: CALL_OW 1
64594: ST_TO_ADDR
// end ;
64595: LD_VAR 0 3
64599: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
64600: LD_INT 0
64602: PPUSH
64603: PPUSH
64604: PPUSH
64605: PPUSH
// if not mc_bases [ base ] then
64606: LD_EXP 102
64610: PUSH
64611: LD_VAR 0 1
64615: ARRAY
64616: NOT
64617: IFFALSE 64621
// exit ;
64619: GO 64686
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
64621: LD_ADDR_EXP 122
64625: PUSH
64626: LD_EXP 122
64630: PPUSH
64631: LD_VAR 0 1
64635: PUSH
64636: LD_EXP 122
64640: PUSH
64641: LD_VAR 0 1
64645: ARRAY
64646: PUSH
64647: LD_INT 1
64649: PLUS
64650: PUSH
64651: EMPTY
64652: LIST
64653: LIST
64654: PPUSH
64655: LD_VAR 0 1
64659: PUSH
64660: LD_VAR 0 2
64664: PUSH
64665: LD_VAR 0 3
64669: PUSH
64670: LD_VAR 0 4
64674: PUSH
64675: EMPTY
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: PPUSH
64681: CALL 76081 0 3
64685: ST_TO_ADDR
// end ;
64686: LD_VAR 0 5
64690: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
64691: LD_INT 0
64693: PPUSH
// if not mc_bases [ base ] then
64694: LD_EXP 102
64698: PUSH
64699: LD_VAR 0 1
64703: ARRAY
64704: NOT
64705: IFFALSE 64709
// exit ;
64707: GO 64734
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
64709: LD_ADDR_EXP 139
64713: PUSH
64714: LD_EXP 139
64718: PPUSH
64719: LD_VAR 0 1
64723: PPUSH
64724: LD_VAR 0 2
64728: PPUSH
64729: CALL_OW 1
64733: ST_TO_ADDR
// end ;
64734: LD_VAR 0 3
64738: RET
// export function MC_GetMinesField ( base ) ; begin
64739: LD_INT 0
64741: PPUSH
// result := mc_mines [ base ] ;
64742: LD_ADDR_VAR 0 2
64746: PUSH
64747: LD_EXP 115
64751: PUSH
64752: LD_VAR 0 1
64756: ARRAY
64757: ST_TO_ADDR
// end ;
64758: LD_VAR 0 2
64762: RET
// export function MC_GetProduceList ( base ) ; begin
64763: LD_INT 0
64765: PPUSH
// result := mc_produce [ base ] ;
64766: LD_ADDR_VAR 0 2
64770: PUSH
64771: LD_EXP 123
64775: PUSH
64776: LD_VAR 0 1
64780: ARRAY
64781: ST_TO_ADDR
// end ;
64782: LD_VAR 0 2
64786: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
64787: LD_INT 0
64789: PPUSH
64790: PPUSH
// if not mc_bases then
64791: LD_EXP 102
64795: NOT
64796: IFFALSE 64800
// exit ;
64798: GO 64865
// if mc_bases [ base ] then
64800: LD_EXP 102
64804: PUSH
64805: LD_VAR 0 1
64809: ARRAY
64810: IFFALSE 64865
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64812: LD_ADDR_VAR 0 3
64816: PUSH
64817: LD_EXP 102
64821: PUSH
64822: LD_VAR 0 1
64826: ARRAY
64827: PPUSH
64828: LD_INT 30
64830: PUSH
64831: LD_VAR 0 2
64835: PUSH
64836: EMPTY
64837: LIST
64838: LIST
64839: PPUSH
64840: CALL_OW 72
64844: ST_TO_ADDR
// if result then
64845: LD_VAR 0 3
64849: IFFALSE 64865
// result := result [ 1 ] ;
64851: LD_ADDR_VAR 0 3
64855: PUSH
64856: LD_VAR 0 3
64860: PUSH
64861: LD_INT 1
64863: ARRAY
64864: ST_TO_ADDR
// end ; end ;
64865: LD_VAR 0 3
64869: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
64870: LD_INT 0
64872: PPUSH
64873: PPUSH
// if not mc_bases then
64874: LD_EXP 102
64878: NOT
64879: IFFALSE 64883
// exit ;
64881: GO 64928
// if mc_bases [ base ] then
64883: LD_EXP 102
64887: PUSH
64888: LD_VAR 0 1
64892: ARRAY
64893: IFFALSE 64928
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
64895: LD_ADDR_VAR 0 3
64899: PUSH
64900: LD_EXP 102
64904: PUSH
64905: LD_VAR 0 1
64909: ARRAY
64910: PPUSH
64911: LD_INT 30
64913: PUSH
64914: LD_VAR 0 2
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PPUSH
64923: CALL_OW 72
64927: ST_TO_ADDR
// end ;
64928: LD_VAR 0 3
64932: RET
// export function MC_SetTame ( base , area ) ; begin
64933: LD_INT 0
64935: PPUSH
// if not mc_bases or not base then
64936: LD_EXP 102
64940: NOT
64941: IFTRUE 64950
64943: PUSH
64944: LD_VAR 0 1
64948: NOT
64949: OR
64950: IFFALSE 64954
// exit ;
64952: GO 64979
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
64954: LD_ADDR_EXP 130
64958: PUSH
64959: LD_EXP 130
64963: PPUSH
64964: LD_VAR 0 1
64968: PPUSH
64969: LD_VAR 0 2
64973: PPUSH
64974: CALL_OW 1
64978: ST_TO_ADDR
// end ;
64979: LD_VAR 0 3
64983: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
64984: LD_INT 0
64986: PPUSH
64987: PPUSH
// if not mc_bases or not base then
64988: LD_EXP 102
64992: NOT
64993: IFTRUE 65002
64995: PUSH
64996: LD_VAR 0 1
65000: NOT
65001: OR
65002: IFFALSE 65006
// exit ;
65004: GO 65108
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
65006: LD_ADDR_VAR 0 4
65010: PUSH
65011: LD_EXP 102
65015: PUSH
65016: LD_VAR 0 1
65020: ARRAY
65021: PPUSH
65022: LD_INT 30
65024: PUSH
65025: LD_VAR 0 2
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: PPUSH
65034: CALL_OW 72
65038: ST_TO_ADDR
// if not tmp then
65039: LD_VAR 0 4
65043: NOT
65044: IFFALSE 65048
// exit ;
65046: GO 65108
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
65048: LD_ADDR_EXP 134
65052: PUSH
65053: LD_EXP 134
65057: PPUSH
65058: LD_VAR 0 1
65062: PPUSH
65063: LD_EXP 134
65067: PUSH
65068: LD_VAR 0 1
65072: ARRAY
65073: PPUSH
65074: LD_EXP 134
65078: PUSH
65079: LD_VAR 0 1
65083: ARRAY
65084: PUSH
65085: LD_INT 1
65087: PLUS
65088: PPUSH
65089: LD_VAR 0 4
65093: PUSH
65094: LD_INT 1
65096: ARRAY
65097: PPUSH
65098: CALL_OW 2
65102: PPUSH
65103: CALL_OW 1
65107: ST_TO_ADDR
// end ;
65108: LD_VAR 0 3
65112: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
65113: LD_INT 0
65115: PPUSH
65116: PPUSH
// if not mc_bases or not base or not kinds then
65117: LD_EXP 102
65121: NOT
65122: IFTRUE 65131
65124: PUSH
65125: LD_VAR 0 1
65129: NOT
65130: OR
65131: IFTRUE 65140
65133: PUSH
65134: LD_VAR 0 2
65138: NOT
65139: OR
65140: IFFALSE 65144
// exit ;
65142: GO 65205
// for i in kinds do
65144: LD_ADDR_VAR 0 4
65148: PUSH
65149: LD_VAR 0 2
65153: PUSH
65154: FOR_IN
65155: IFFALSE 65203
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
65157: LD_ADDR_EXP 136
65161: PUSH
65162: LD_EXP 136
65166: PPUSH
65167: LD_VAR 0 1
65171: PUSH
65172: LD_EXP 136
65176: PUSH
65177: LD_VAR 0 1
65181: ARRAY
65182: PUSH
65183: LD_INT 1
65185: PLUS
65186: PUSH
65187: EMPTY
65188: LIST
65189: LIST
65190: PPUSH
65191: LD_VAR 0 4
65195: PPUSH
65196: CALL 76081 0 3
65200: ST_TO_ADDR
65201: GO 65154
65203: POP
65204: POP
// end ;
65205: LD_VAR 0 3
65209: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
65210: LD_INT 0
65212: PPUSH
// if not mc_bases or not base or not areas then
65213: LD_EXP 102
65217: NOT
65218: IFTRUE 65227
65220: PUSH
65221: LD_VAR 0 1
65225: NOT
65226: OR
65227: IFTRUE 65236
65229: PUSH
65230: LD_VAR 0 2
65234: NOT
65235: OR
65236: IFFALSE 65240
// exit ;
65238: GO 65265
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
65240: LD_ADDR_EXP 120
65244: PUSH
65245: LD_EXP 120
65249: PPUSH
65250: LD_VAR 0 1
65254: PPUSH
65255: LD_VAR 0 2
65259: PPUSH
65260: CALL_OW 1
65264: ST_TO_ADDR
// end ;
65265: LD_VAR 0 3
65269: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
65270: LD_INT 0
65272: PPUSH
// if not mc_bases or not base or not teleports_exit then
65273: LD_EXP 102
65277: NOT
65278: IFTRUE 65287
65280: PUSH
65281: LD_VAR 0 1
65285: NOT
65286: OR
65287: IFTRUE 65296
65289: PUSH
65290: LD_VAR 0 2
65294: NOT
65295: OR
65296: IFFALSE 65300
// exit ;
65298: GO 65325
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
65300: LD_ADDR_EXP 137
65304: PUSH
65305: LD_EXP 137
65309: PPUSH
65310: LD_VAR 0 1
65314: PPUSH
65315: LD_VAR 0 2
65319: PPUSH
65320: CALL_OW 1
65324: ST_TO_ADDR
// end ;
65325: LD_VAR 0 3
65329: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
65330: LD_INT 0
65332: PPUSH
65333: PPUSH
65334: PPUSH
// if not mc_bases or not base or not ext_list then
65335: LD_EXP 102
65339: NOT
65340: IFTRUE 65349
65342: PUSH
65343: LD_VAR 0 1
65347: NOT
65348: OR
65349: IFTRUE 65358
65351: PUSH
65352: LD_VAR 0 5
65356: NOT
65357: OR
65358: IFFALSE 65362
// exit ;
65360: GO 65535
// tmp := GetFacExtXYD ( x , y , d ) ;
65362: LD_ADDR_VAR 0 8
65366: PUSH
65367: LD_VAR 0 2
65371: PPUSH
65372: LD_VAR 0 3
65376: PPUSH
65377: LD_VAR 0 4
65381: PPUSH
65382: CALL 106749 0 3
65386: ST_TO_ADDR
// if not tmp then
65387: LD_VAR 0 8
65391: NOT
65392: IFFALSE 65396
// exit ;
65394: GO 65535
// for i in tmp do
65396: LD_ADDR_VAR 0 7
65400: PUSH
65401: LD_VAR 0 8
65405: PUSH
65406: FOR_IN
65407: IFFALSE 65533
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
65409: LD_ADDR_EXP 107
65413: PUSH
65414: LD_EXP 107
65418: PPUSH
65419: LD_VAR 0 1
65423: PPUSH
65424: LD_EXP 107
65428: PUSH
65429: LD_VAR 0 1
65433: ARRAY
65434: PPUSH
65435: LD_EXP 107
65439: PUSH
65440: LD_VAR 0 1
65444: ARRAY
65445: PUSH
65446: LD_INT 1
65448: PLUS
65449: PPUSH
65450: LD_VAR 0 5
65454: PUSH
65455: LD_INT 1
65457: ARRAY
65458: PUSH
65459: LD_VAR 0 7
65463: PUSH
65464: LD_INT 1
65466: ARRAY
65467: PUSH
65468: LD_VAR 0 7
65472: PUSH
65473: LD_INT 2
65475: ARRAY
65476: PUSH
65477: LD_VAR 0 7
65481: PUSH
65482: LD_INT 3
65484: ARRAY
65485: PUSH
65486: EMPTY
65487: LIST
65488: LIST
65489: LIST
65490: LIST
65491: PPUSH
65492: CALL_OW 2
65496: PPUSH
65497: CALL_OW 1
65501: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
65502: LD_ADDR_VAR 0 5
65506: PUSH
65507: LD_VAR 0 5
65511: PPUSH
65512: LD_INT 1
65514: PPUSH
65515: CALL_OW 3
65519: ST_TO_ADDR
// if not ext_list then
65520: LD_VAR 0 5
65524: NOT
65525: IFFALSE 65531
// exit ;
65527: POP
65528: POP
65529: GO 65535
// end ;
65531: GO 65406
65533: POP
65534: POP
// end ;
65535: LD_VAR 0 6
65539: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
65540: LD_INT 0
65542: PPUSH
// if not mc_bases or not base or not weapon_list then
65543: LD_EXP 102
65547: NOT
65548: IFTRUE 65557
65550: PUSH
65551: LD_VAR 0 1
65555: NOT
65556: OR
65557: IFTRUE 65566
65559: PUSH
65560: LD_VAR 0 2
65564: NOT
65565: OR
65566: IFFALSE 65570
// exit ;
65568: GO 65595
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
65570: LD_ADDR_EXP 141
65574: PUSH
65575: LD_EXP 141
65579: PPUSH
65580: LD_VAR 0 1
65584: PPUSH
65585: LD_VAR 0 2
65589: PPUSH
65590: CALL_OW 1
65594: ST_TO_ADDR
// end ;
65595: LD_VAR 0 3
65599: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
65600: LD_INT 0
65602: PPUSH
// if not mc_bases or not base or not tech_list then
65603: LD_EXP 102
65607: NOT
65608: IFTRUE 65617
65610: PUSH
65611: LD_VAR 0 1
65615: NOT
65616: OR
65617: IFTRUE 65626
65619: PUSH
65620: LD_VAR 0 2
65624: NOT
65625: OR
65626: IFFALSE 65630
// exit ;
65628: GO 65655
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
65630: LD_ADDR_EXP 129
65634: PUSH
65635: LD_EXP 129
65639: PPUSH
65640: LD_VAR 0 1
65644: PPUSH
65645: LD_VAR 0 2
65649: PPUSH
65650: CALL_OW 1
65654: ST_TO_ADDR
// end ;
65655: LD_VAR 0 3
65659: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
65660: LD_INT 0
65662: PPUSH
// if not mc_bases or not parking_area or not base then
65663: LD_EXP 102
65667: NOT
65668: IFTRUE 65677
65670: PUSH
65671: LD_VAR 0 2
65675: NOT
65676: OR
65677: IFTRUE 65686
65679: PUSH
65680: LD_VAR 0 1
65684: NOT
65685: OR
65686: IFFALSE 65690
// exit ;
65688: GO 65715
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
65690: LD_ADDR_EXP 126
65694: PUSH
65695: LD_EXP 126
65699: PPUSH
65700: LD_VAR 0 1
65704: PPUSH
65705: LD_VAR 0 2
65709: PPUSH
65710: CALL_OW 1
65714: ST_TO_ADDR
// end ;
65715: LD_VAR 0 3
65719: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
65720: LD_INT 0
65722: PPUSH
// if not mc_bases or not base or not scan_area then
65723: LD_EXP 102
65727: NOT
65728: IFTRUE 65737
65730: PUSH
65731: LD_VAR 0 1
65735: NOT
65736: OR
65737: IFTRUE 65746
65739: PUSH
65740: LD_VAR 0 2
65744: NOT
65745: OR
65746: IFFALSE 65750
// exit ;
65748: GO 65775
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
65750: LD_ADDR_EXP 127
65754: PUSH
65755: LD_EXP 127
65759: PPUSH
65760: LD_VAR 0 1
65764: PPUSH
65765: LD_VAR 0 2
65769: PPUSH
65770: CALL_OW 1
65774: ST_TO_ADDR
// end ;
65775: LD_VAR 0 3
65779: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
65780: LD_INT 0
65782: PPUSH
65783: PPUSH
// if not mc_bases or not base then
65784: LD_EXP 102
65788: NOT
65789: IFTRUE 65798
65791: PUSH
65792: LD_VAR 0 1
65796: NOT
65797: OR
65798: IFFALSE 65802
// exit ;
65800: GO 65866
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
65802: LD_ADDR_VAR 0 3
65806: PUSH
65807: LD_INT 1
65809: PUSH
65810: LD_INT 2
65812: PUSH
65813: LD_INT 3
65815: PUSH
65816: LD_INT 4
65818: PUSH
65819: LD_INT 11
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: LIST
65826: LIST
65827: LIST
65828: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
65829: LD_ADDR_EXP 129
65833: PUSH
65834: LD_EXP 129
65838: PPUSH
65839: LD_VAR 0 1
65843: PPUSH
65844: LD_EXP 129
65848: PUSH
65849: LD_VAR 0 1
65853: ARRAY
65854: PUSH
65855: LD_VAR 0 3
65859: DIFF
65860: PPUSH
65861: CALL_OW 1
65865: ST_TO_ADDR
// end ;
65866: LD_VAR 0 2
65870: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
65871: LD_INT 0
65873: PPUSH
// result := mc_vehicles [ base ] ;
65874: LD_ADDR_VAR 0 3
65878: PUSH
65879: LD_EXP 121
65883: PUSH
65884: LD_VAR 0 1
65888: ARRAY
65889: ST_TO_ADDR
// if onlyCombat then
65890: LD_VAR 0 2
65894: IFFALSE 66066
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
65896: LD_ADDR_VAR 0 3
65900: PUSH
65901: LD_VAR 0 3
65905: PUSH
65906: LD_VAR 0 3
65910: PPUSH
65911: LD_INT 2
65913: PUSH
65914: LD_INT 34
65916: PUSH
65917: LD_INT 12
65919: PUSH
65920: EMPTY
65921: LIST
65922: LIST
65923: PUSH
65924: LD_INT 34
65926: PUSH
65927: LD_INT 51
65929: PUSH
65930: EMPTY
65931: LIST
65932: LIST
65933: PUSH
65934: LD_INT 34
65936: PUSH
65937: LD_INT 89
65939: PUSH
65940: EMPTY
65941: LIST
65942: LIST
65943: PUSH
65944: LD_INT 34
65946: PUSH
65947: LD_INT 32
65949: PUSH
65950: EMPTY
65951: LIST
65952: LIST
65953: PUSH
65954: LD_INT 34
65956: PUSH
65957: LD_INT 13
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 34
65966: PUSH
65967: LD_INT 52
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 34
65976: PUSH
65977: LD_INT 88
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 34
65986: PUSH
65987: LD_INT 14
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: LD_INT 34
65996: PUSH
65997: LD_INT 53
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: LD_INT 34
66006: PUSH
66007: LD_INT 98
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: LD_INT 34
66016: PUSH
66017: LD_INT 31
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PUSH
66024: LD_INT 34
66026: PUSH
66027: LD_INT 48
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: PUSH
66034: LD_INT 34
66036: PUSH
66037: LD_INT 8
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: LIST
66048: LIST
66049: LIST
66050: LIST
66051: LIST
66052: LIST
66053: LIST
66054: LIST
66055: LIST
66056: LIST
66057: LIST
66058: LIST
66059: PPUSH
66060: CALL_OW 72
66064: DIFF
66065: ST_TO_ADDR
// end ; end_of_file
66066: LD_VAR 0 3
66070: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
66071: LD_INT 0
66073: PPUSH
66074: PPUSH
66075: PPUSH
// if not mc_bases or not skirmish then
66076: LD_EXP 102
66080: NOT
66081: IFTRUE 66090
66083: PUSH
66084: LD_EXP 100
66088: NOT
66089: OR
66090: IFFALSE 66094
// exit ;
66092: GO 66259
// for i = 1 to mc_bases do
66094: LD_ADDR_VAR 0 4
66098: PUSH
66099: DOUBLE
66100: LD_INT 1
66102: DEC
66103: ST_TO_ADDR
66104: LD_EXP 102
66108: PUSH
66109: FOR_TO
66110: IFFALSE 66257
// begin if sci in mc_bases [ i ] then
66112: LD_VAR 0 2
66116: PUSH
66117: LD_EXP 102
66121: PUSH
66122: LD_VAR 0 4
66126: ARRAY
66127: IN
66128: IFFALSE 66255
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
66130: LD_ADDR_EXP 131
66134: PUSH
66135: LD_EXP 131
66139: PPUSH
66140: LD_VAR 0 4
66144: PUSH
66145: LD_EXP 131
66149: PUSH
66150: LD_VAR 0 4
66154: ARRAY
66155: PUSH
66156: LD_INT 1
66158: PLUS
66159: PUSH
66160: EMPTY
66161: LIST
66162: LIST
66163: PPUSH
66164: LD_VAR 0 1
66168: PPUSH
66169: CALL 76081 0 3
66173: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
66174: LD_ADDR_VAR 0 5
66178: PUSH
66179: LD_EXP 102
66183: PUSH
66184: LD_VAR 0 4
66188: ARRAY
66189: PPUSH
66190: LD_INT 2
66192: PUSH
66193: LD_INT 30
66195: PUSH
66196: LD_INT 0
66198: PUSH
66199: EMPTY
66200: LIST
66201: LIST
66202: PUSH
66203: LD_INT 30
66205: PUSH
66206: LD_INT 1
66208: PUSH
66209: EMPTY
66210: LIST
66211: LIST
66212: PUSH
66213: EMPTY
66214: LIST
66215: LIST
66216: LIST
66217: PPUSH
66218: CALL_OW 72
66222: PPUSH
66223: LD_VAR 0 1
66227: PPUSH
66228: CALL_OW 74
66232: ST_TO_ADDR
// if tmp then
66233: LD_VAR 0 5
66237: IFFALSE 66253
// ComStandNearbyBuilding ( ape , tmp ) ;
66239: LD_VAR 0 1
66243: PPUSH
66244: LD_VAR 0 5
66248: PPUSH
66249: CALL 72623 0 2
// break ;
66253: GO 66257
// end ; end ;
66255: GO 66109
66257: POP
66258: POP
// end ;
66259: LD_VAR 0 3
66263: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
66264: LD_INT 0
66266: PPUSH
66267: PPUSH
66268: PPUSH
// if not mc_bases or not skirmish then
66269: LD_EXP 102
66273: NOT
66274: IFTRUE 66283
66276: PUSH
66277: LD_EXP 100
66281: NOT
66282: OR
66283: IFFALSE 66287
// exit ;
66285: GO 66376
// for i = 1 to mc_bases do
66287: LD_ADDR_VAR 0 4
66291: PUSH
66292: DOUBLE
66293: LD_INT 1
66295: DEC
66296: ST_TO_ADDR
66297: LD_EXP 102
66301: PUSH
66302: FOR_TO
66303: IFFALSE 66374
// begin if building in mc_busy_turret_list [ i ] then
66305: LD_VAR 0 1
66309: PUSH
66310: LD_EXP 112
66314: PUSH
66315: LD_VAR 0 4
66319: ARRAY
66320: IN
66321: IFFALSE 66372
// begin tmp := mc_busy_turret_list [ i ] diff building ;
66323: LD_ADDR_VAR 0 5
66327: PUSH
66328: LD_EXP 112
66332: PUSH
66333: LD_VAR 0 4
66337: ARRAY
66338: PUSH
66339: LD_VAR 0 1
66343: DIFF
66344: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
66345: LD_ADDR_EXP 112
66349: PUSH
66350: LD_EXP 112
66354: PPUSH
66355: LD_VAR 0 4
66359: PPUSH
66360: LD_VAR 0 5
66364: PPUSH
66365: CALL_OW 1
66369: ST_TO_ADDR
// break ;
66370: GO 66374
// end ; end ;
66372: GO 66302
66374: POP
66375: POP
// end ;
66376: LD_VAR 0 3
66380: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
66381: LD_INT 0
66383: PPUSH
66384: PPUSH
66385: PPUSH
// if not mc_bases or not skirmish then
66386: LD_EXP 102
66390: NOT
66391: IFTRUE 66400
66393: PUSH
66394: LD_EXP 100
66398: NOT
66399: OR
66400: IFFALSE 66404
// exit ;
66402: GO 66603
// for i = 1 to mc_bases do
66404: LD_ADDR_VAR 0 5
66408: PUSH
66409: DOUBLE
66410: LD_INT 1
66412: DEC
66413: ST_TO_ADDR
66414: LD_EXP 102
66418: PUSH
66419: FOR_TO
66420: IFFALSE 66601
// if building in mc_bases [ i ] then
66422: LD_VAR 0 1
66426: PUSH
66427: LD_EXP 102
66431: PUSH
66432: LD_VAR 0 5
66436: ARRAY
66437: IN
66438: IFFALSE 66599
// begin tmp := mc_bases [ i ] diff building ;
66440: LD_ADDR_VAR 0 6
66444: PUSH
66445: LD_EXP 102
66449: PUSH
66450: LD_VAR 0 5
66454: ARRAY
66455: PUSH
66456: LD_VAR 0 1
66460: DIFF
66461: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
66462: LD_ADDR_EXP 102
66466: PUSH
66467: LD_EXP 102
66471: PPUSH
66472: LD_VAR 0 5
66476: PPUSH
66477: LD_VAR 0 6
66481: PPUSH
66482: CALL_OW 1
66486: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
66487: LD_VAR 0 1
66491: PUSH
66492: LD_EXP 110
66496: PUSH
66497: LD_VAR 0 5
66501: ARRAY
66502: IN
66503: IFFALSE 66542
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
66505: LD_ADDR_EXP 110
66509: PUSH
66510: LD_EXP 110
66514: PPUSH
66515: LD_VAR 0 5
66519: PPUSH
66520: LD_EXP 110
66524: PUSH
66525: LD_VAR 0 5
66529: ARRAY
66530: PUSH
66531: LD_VAR 0 1
66535: DIFF
66536: PPUSH
66537: CALL_OW 1
66541: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
66542: LD_VAR 0 1
66546: PUSH
66547: LD_EXP 111
66551: PUSH
66552: LD_VAR 0 5
66556: ARRAY
66557: IN
66558: IFFALSE 66597
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
66560: LD_ADDR_EXP 111
66564: PUSH
66565: LD_EXP 111
66569: PPUSH
66570: LD_VAR 0 5
66574: PPUSH
66575: LD_EXP 111
66579: PUSH
66580: LD_VAR 0 5
66584: ARRAY
66585: PUSH
66586: LD_VAR 0 1
66590: DIFF
66591: PPUSH
66592: CALL_OW 1
66596: ST_TO_ADDR
// break ;
66597: GO 66601
// end ;
66599: GO 66419
66601: POP
66602: POP
// end ;
66603: LD_VAR 0 4
66607: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
66608: LD_INT 0
66610: PPUSH
66611: PPUSH
66612: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
66613: LD_EXP 102
66617: NOT
66618: IFTRUE 66627
66620: PUSH
66621: LD_EXP 100
66625: NOT
66626: OR
66627: IFTRUE 66642
66629: PUSH
66630: LD_VAR 0 3
66634: PUSH
66635: LD_EXP 128
66639: IN
66640: NOT
66641: OR
66642: IFFALSE 66646
// exit ;
66644: GO 66771
// for i = 1 to mc_vehicles do
66646: LD_ADDR_VAR 0 6
66650: PUSH
66651: DOUBLE
66652: LD_INT 1
66654: DEC
66655: ST_TO_ADDR
66656: LD_EXP 121
66660: PUSH
66661: FOR_TO
66662: IFFALSE 66769
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
66664: LD_VAR 0 2
66668: PUSH
66669: LD_EXP 121
66673: PUSH
66674: LD_VAR 0 6
66678: ARRAY
66679: IN
66680: IFTRUE 66700
66682: PUSH
66683: LD_VAR 0 1
66687: PUSH
66688: LD_EXP 121
66692: PUSH
66693: LD_VAR 0 6
66697: ARRAY
66698: IN
66699: OR
66700: IFFALSE 66767
// begin tmp := mc_vehicles [ i ] diff old ;
66702: LD_ADDR_VAR 0 7
66706: PUSH
66707: LD_EXP 121
66711: PUSH
66712: LD_VAR 0 6
66716: ARRAY
66717: PUSH
66718: LD_VAR 0 2
66722: DIFF
66723: ST_TO_ADDR
// tmp := tmp diff new ;
66724: LD_ADDR_VAR 0 7
66728: PUSH
66729: LD_VAR 0 7
66733: PUSH
66734: LD_VAR 0 1
66738: DIFF
66739: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
66740: LD_ADDR_EXP 121
66744: PUSH
66745: LD_EXP 121
66749: PPUSH
66750: LD_VAR 0 6
66754: PPUSH
66755: LD_VAR 0 7
66759: PPUSH
66760: CALL_OW 1
66764: ST_TO_ADDR
// break ;
66765: GO 66769
// end ;
66767: GO 66661
66769: POP
66770: POP
// end ;
66771: LD_VAR 0 5
66775: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
66776: LD_INT 0
66778: PPUSH
66779: PPUSH
66780: PPUSH
66781: PPUSH
// if not mc_bases or not skirmish then
66782: LD_EXP 102
66786: NOT
66787: IFTRUE 66796
66789: PUSH
66790: LD_EXP 100
66794: NOT
66795: OR
66796: IFFALSE 66800
// exit ;
66798: GO 67222
// repeat wait ( 0 0$1 ) ;
66800: LD_INT 35
66802: PPUSH
66803: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
66807: LD_EXP 146
66811: NOT
66812: IFFALSE 66800
// mc_block_vehicle_constructed_thread := true ;
66814: LD_ADDR_EXP 146
66818: PUSH
66819: LD_INT 1
66821: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
66822: LD_ADDR_VAR 0 5
66826: PUSH
66827: LD_VAR 0 1
66831: PPUSH
66832: CALL_OW 255
66836: ST_TO_ADDR
// for i = 1 to mc_bases do
66837: LD_ADDR_VAR 0 4
66841: PUSH
66842: DOUBLE
66843: LD_INT 1
66845: DEC
66846: ST_TO_ADDR
66847: LD_EXP 102
66851: PUSH
66852: FOR_TO
66853: IFFALSE 67212
// begin if factory in mc_bases [ i ] then
66855: LD_VAR 0 2
66859: PUSH
66860: LD_EXP 102
66864: PUSH
66865: LD_VAR 0 4
66869: ARRAY
66870: IN
66871: IFFALSE 67210
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
66873: LD_EXP 124
66877: PUSH
66878: LD_VAR 0 4
66882: ARRAY
66883: PUSH
66884: LD_EXP 113
66888: PUSH
66889: LD_VAR 0 4
66893: ARRAY
66894: LESS
66895: IFFALSE 66984
66897: PUSH
66898: LD_VAR 0 1
66902: PPUSH
66903: CALL_OW 264
66907: PUSH
66908: LD_INT 31
66910: PUSH
66911: LD_INT 32
66913: PUSH
66914: LD_INT 51
66916: PUSH
66917: LD_INT 89
66919: PUSH
66920: LD_INT 12
66922: PUSH
66923: LD_INT 30
66925: PUSH
66926: LD_INT 98
66928: PUSH
66929: LD_INT 11
66931: PUSH
66932: LD_INT 53
66934: PUSH
66935: LD_INT 14
66937: PUSH
66938: LD_INT 91
66940: PUSH
66941: LD_INT 29
66943: PUSH
66944: LD_INT 99
66946: PUSH
66947: LD_INT 13
66949: PUSH
66950: LD_INT 52
66952: PUSH
66953: LD_INT 88
66955: PUSH
66956: LD_INT 48
66958: PUSH
66959: LD_INT 8
66961: PUSH
66962: EMPTY
66963: LIST
66964: LIST
66965: LIST
66966: LIST
66967: LIST
66968: LIST
66969: LIST
66970: LIST
66971: LIST
66972: LIST
66973: LIST
66974: LIST
66975: LIST
66976: LIST
66977: LIST
66978: LIST
66979: LIST
66980: LIST
66981: IN
66982: NOT
66983: AND
66984: IFFALSE 67032
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
66986: LD_ADDR_EXP 124
66990: PUSH
66991: LD_EXP 124
66995: PPUSH
66996: LD_VAR 0 4
67000: PUSH
67001: LD_EXP 124
67005: PUSH
67006: LD_VAR 0 4
67010: ARRAY
67011: PUSH
67012: LD_INT 1
67014: PLUS
67015: PUSH
67016: EMPTY
67017: LIST
67018: LIST
67019: PPUSH
67020: LD_VAR 0 1
67024: PPUSH
67025: CALL 76081 0 3
67029: ST_TO_ADDR
67030: GO 67076
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
67032: LD_ADDR_EXP 121
67036: PUSH
67037: LD_EXP 121
67041: PPUSH
67042: LD_VAR 0 4
67046: PUSH
67047: LD_EXP 121
67051: PUSH
67052: LD_VAR 0 4
67056: ARRAY
67057: PUSH
67058: LD_INT 1
67060: PLUS
67061: PUSH
67062: EMPTY
67063: LIST
67064: LIST
67065: PPUSH
67066: LD_VAR 0 1
67070: PPUSH
67071: CALL 76081 0 3
67075: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
67076: LD_ADDR_EXP 146
67080: PUSH
67081: LD_INT 0
67083: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
67084: LD_VAR 0 1
67088: PPUSH
67089: CALL_OW 263
67093: PUSH
67094: LD_INT 2
67096: EQUAL
67097: IFFALSE 67126
// begin repeat wait ( 0 0$3 ) ;
67099: LD_INT 105
67101: PPUSH
67102: CALL_OW 67
// Connect ( vehicle ) ;
67106: LD_VAR 0 1
67110: PPUSH
67111: CALL 79441 0 1
// until IsControledBy ( vehicle ) ;
67115: LD_VAR 0 1
67119: PPUSH
67120: CALL_OW 312
67124: IFFALSE 67099
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
67126: LD_VAR 0 1
67130: PPUSH
67131: LD_EXP 126
67135: PUSH
67136: LD_VAR 0 4
67140: ARRAY
67141: PPUSH
67142: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
67146: LD_VAR 0 1
67150: PPUSH
67151: CALL_OW 263
67155: PUSH
67156: LD_INT 1
67158: NONEQUAL
67159: IFFALSE 67163
// break ;
67161: GO 67212
// repeat wait ( 0 0$1 ) ;
67163: LD_INT 35
67165: PPUSH
67166: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
67170: LD_VAR 0 1
67174: PPUSH
67175: LD_EXP 126
67179: PUSH
67180: LD_VAR 0 4
67184: ARRAY
67185: PPUSH
67186: CALL_OW 308
67190: IFFALSE 67163
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
67192: LD_VAR 0 1
67196: PPUSH
67197: CALL_OW 311
67201: PPUSH
67202: CALL_OW 121
// exit ;
67206: POP
67207: POP
67208: GO 67222
// end ; end ;
67210: GO 66852
67212: POP
67213: POP
// mc_block_vehicle_constructed_thread := false ;
67214: LD_ADDR_EXP 146
67218: PUSH
67219: LD_INT 0
67221: ST_TO_ADDR
// end ;
67222: LD_VAR 0 3
67226: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
67227: LD_INT 0
67229: PPUSH
67230: PPUSH
67231: PPUSH
67232: PPUSH
// if not mc_bases or not skirmish then
67233: LD_EXP 102
67237: NOT
67238: IFTRUE 67247
67240: PUSH
67241: LD_EXP 100
67245: NOT
67246: OR
67247: IFFALSE 67251
// exit ;
67249: GO 67604
// repeat wait ( 0 0$1 ) ;
67251: LD_INT 35
67253: PPUSH
67254: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
67258: LD_VAR 0 2
67262: PPUSH
67263: LD_VAR 0 3
67267: PPUSH
67268: CALL_OW 284
67272: IFFALSE 67251
// if GetResourceTypeXY ( x , y ) = mat_artefact then
67274: LD_VAR 0 2
67278: PPUSH
67279: LD_VAR 0 3
67283: PPUSH
67284: CALL_OW 283
67288: PUSH
67289: LD_INT 4
67291: EQUAL
67292: IFFALSE 67296
// exit ;
67294: GO 67604
// for i = 1 to mc_bases do
67296: LD_ADDR_VAR 0 7
67300: PUSH
67301: DOUBLE
67302: LD_INT 1
67304: DEC
67305: ST_TO_ADDR
67306: LD_EXP 102
67310: PUSH
67311: FOR_TO
67312: IFFALSE 67602
// begin if mc_crates_area [ i ] then
67314: LD_EXP 120
67318: PUSH
67319: LD_VAR 0 7
67323: ARRAY
67324: IFFALSE 67435
// for j in mc_crates_area [ i ] do
67326: LD_ADDR_VAR 0 8
67330: PUSH
67331: LD_EXP 120
67335: PUSH
67336: LD_VAR 0 7
67340: ARRAY
67341: PUSH
67342: FOR_IN
67343: IFFALSE 67433
// if InArea ( x , y , j ) then
67345: LD_VAR 0 2
67349: PPUSH
67350: LD_VAR 0 3
67354: PPUSH
67355: LD_VAR 0 8
67359: PPUSH
67360: CALL_OW 309
67364: IFFALSE 67431
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
67366: LD_ADDR_EXP 118
67370: PUSH
67371: LD_EXP 118
67375: PPUSH
67376: LD_VAR 0 7
67380: PUSH
67381: LD_EXP 118
67385: PUSH
67386: LD_VAR 0 7
67390: ARRAY
67391: PUSH
67392: LD_INT 1
67394: PLUS
67395: PUSH
67396: EMPTY
67397: LIST
67398: LIST
67399: PPUSH
67400: LD_VAR 0 4
67404: PUSH
67405: LD_VAR 0 2
67409: PUSH
67410: LD_VAR 0 3
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: LIST
67419: PPUSH
67420: CALL 76081 0 3
67424: ST_TO_ADDR
// exit ;
67425: POP
67426: POP
67427: POP
67428: POP
67429: GO 67604
// end ;
67431: GO 67342
67433: POP
67434: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67435: LD_ADDR_VAR 0 9
67439: PUSH
67440: LD_EXP 102
67444: PUSH
67445: LD_VAR 0 7
67449: ARRAY
67450: PPUSH
67451: LD_INT 2
67453: PUSH
67454: LD_INT 30
67456: PUSH
67457: LD_INT 0
67459: PUSH
67460: EMPTY
67461: LIST
67462: LIST
67463: PUSH
67464: LD_INT 30
67466: PUSH
67467: LD_INT 1
67469: PUSH
67470: EMPTY
67471: LIST
67472: LIST
67473: PUSH
67474: EMPTY
67475: LIST
67476: LIST
67477: LIST
67478: PPUSH
67479: CALL_OW 72
67483: ST_TO_ADDR
// if not depot then
67484: LD_VAR 0 9
67488: NOT
67489: IFFALSE 67493
// continue ;
67491: GO 67311
// for j in depot do
67493: LD_ADDR_VAR 0 8
67497: PUSH
67498: LD_VAR 0 9
67502: PUSH
67503: FOR_IN
67504: IFFALSE 67598
// if GetDistUnitXY ( j , x , y ) < 30 then
67506: LD_VAR 0 8
67510: PPUSH
67511: LD_VAR 0 2
67515: PPUSH
67516: LD_VAR 0 3
67520: PPUSH
67521: CALL_OW 297
67525: PUSH
67526: LD_INT 30
67528: LESS
67529: IFFALSE 67596
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
67531: LD_ADDR_EXP 118
67535: PUSH
67536: LD_EXP 118
67540: PPUSH
67541: LD_VAR 0 7
67545: PUSH
67546: LD_EXP 118
67550: PUSH
67551: LD_VAR 0 7
67555: ARRAY
67556: PUSH
67557: LD_INT 1
67559: PLUS
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PPUSH
67565: LD_VAR 0 4
67569: PUSH
67570: LD_VAR 0 2
67574: PUSH
67575: LD_VAR 0 3
67579: PUSH
67580: EMPTY
67581: LIST
67582: LIST
67583: LIST
67584: PPUSH
67585: CALL 76081 0 3
67589: ST_TO_ADDR
// exit ;
67590: POP
67591: POP
67592: POP
67593: POP
67594: GO 67604
// end ;
67596: GO 67503
67598: POP
67599: POP
// end ;
67600: GO 67311
67602: POP
67603: POP
// end ;
67604: LD_VAR 0 6
67608: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
67609: LD_INT 0
67611: PPUSH
67612: PPUSH
67613: PPUSH
67614: PPUSH
// if not mc_bases or not skirmish then
67615: LD_EXP 102
67619: NOT
67620: IFTRUE 67629
67622: PUSH
67623: LD_EXP 100
67627: NOT
67628: OR
67629: IFFALSE 67633
// exit ;
67631: GO 67916
// side := GetSide ( lab ) ;
67633: LD_ADDR_VAR 0 4
67637: PUSH
67638: LD_VAR 0 2
67642: PPUSH
67643: CALL_OW 255
67647: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
67648: LD_VAR 0 4
67652: PUSH
67653: LD_EXP 128
67657: IN
67658: NOT
67659: IFTRUE 67668
67661: PUSH
67662: LD_EXP 129
67666: NOT
67667: OR
67668: IFTRUE 67677
67670: PUSH
67671: LD_EXP 102
67675: NOT
67676: OR
67677: IFFALSE 67681
// exit ;
67679: GO 67916
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
67681: LD_ADDR_EXP 129
67685: PUSH
67686: LD_EXP 129
67690: PPUSH
67691: LD_VAR 0 4
67695: PPUSH
67696: LD_EXP 129
67700: PUSH
67701: LD_VAR 0 4
67705: ARRAY
67706: PUSH
67707: LD_VAR 0 1
67711: DIFF
67712: PPUSH
67713: CALL_OW 1
67717: ST_TO_ADDR
// for i = 1 to mc_bases do
67718: LD_ADDR_VAR 0 5
67722: PUSH
67723: DOUBLE
67724: LD_INT 1
67726: DEC
67727: ST_TO_ADDR
67728: LD_EXP 102
67732: PUSH
67733: FOR_TO
67734: IFFALSE 67914
// begin if lab in mc_bases [ i ] then
67736: LD_VAR 0 2
67740: PUSH
67741: LD_EXP 102
67745: PUSH
67746: LD_VAR 0 5
67750: ARRAY
67751: IN
67752: IFFALSE 67912
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
67754: LD_VAR 0 1
67758: PUSH
67759: LD_INT 11
67761: PUSH
67762: LD_INT 4
67764: PUSH
67765: LD_INT 3
67767: PUSH
67768: LD_INT 2
67770: PUSH
67771: EMPTY
67772: LIST
67773: LIST
67774: LIST
67775: LIST
67776: IN
67777: IFFALSE 67791
67779: PUSH
67780: LD_EXP 132
67784: PUSH
67785: LD_VAR 0 5
67789: ARRAY
67790: AND
67791: IFFALSE 67912
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
67793: LD_ADDR_VAR 0 6
67797: PUSH
67798: LD_EXP 132
67802: PUSH
67803: LD_VAR 0 5
67807: ARRAY
67808: PUSH
67809: LD_INT 1
67811: ARRAY
67812: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
67813: LD_ADDR_EXP 132
67817: PUSH
67818: LD_EXP 132
67822: PPUSH
67823: LD_VAR 0 5
67827: PPUSH
67828: EMPTY
67829: PPUSH
67830: CALL_OW 1
67834: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
67835: LD_VAR 0 6
67839: PPUSH
67840: LD_INT 0
67842: PPUSH
67843: CALL_OW 109
// ComExitBuilding ( tmp ) ;
67847: LD_VAR 0 6
67851: PPUSH
67852: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
67856: LD_ADDR_EXP 131
67860: PUSH
67861: LD_EXP 131
67865: PPUSH
67866: LD_VAR 0 5
67870: PPUSH
67871: LD_EXP 131
67875: PUSH
67876: LD_VAR 0 5
67880: ARRAY
67881: PPUSH
67882: LD_INT 1
67884: PPUSH
67885: LD_VAR 0 6
67889: PPUSH
67890: CALL_OW 2
67894: PPUSH
67895: CALL_OW 1
67899: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
67900: LD_VAR 0 5
67904: PPUSH
67905: LD_INT 112
67907: PPUSH
67908: CALL 44046 0 2
// end ; end ; end ;
67912: GO 67733
67914: POP
67915: POP
// end ;
67916: LD_VAR 0 3
67920: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
67921: LD_INT 0
67923: PPUSH
67924: PPUSH
67925: PPUSH
67926: PPUSH
67927: PPUSH
67928: PPUSH
67929: PPUSH
67930: PPUSH
// if not mc_bases or not skirmish then
67931: LD_EXP 102
67935: NOT
67936: IFTRUE 67945
67938: PUSH
67939: LD_EXP 100
67943: NOT
67944: OR
67945: IFFALSE 67949
// exit ;
67947: GO 69334
// for i = 1 to mc_bases do
67949: LD_ADDR_VAR 0 3
67953: PUSH
67954: DOUBLE
67955: LD_INT 1
67957: DEC
67958: ST_TO_ADDR
67959: LD_EXP 102
67963: PUSH
67964: FOR_TO
67965: IFFALSE 69332
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
67967: LD_VAR 0 1
67971: PUSH
67972: LD_EXP 102
67976: PUSH
67977: LD_VAR 0 3
67981: ARRAY
67982: IN
67983: IFTRUE 68003
67985: PUSH
67986: LD_VAR 0 1
67990: PUSH
67991: LD_EXP 109
67995: PUSH
67996: LD_VAR 0 3
68000: ARRAY
68001: IN
68002: OR
68003: IFTRUE 68023
68005: PUSH
68006: LD_VAR 0 1
68010: PUSH
68011: LD_EXP 124
68015: PUSH
68016: LD_VAR 0 3
68020: ARRAY
68021: IN
68022: OR
68023: IFTRUE 68043
68025: PUSH
68026: LD_VAR 0 1
68030: PUSH
68031: LD_EXP 121
68035: PUSH
68036: LD_VAR 0 3
68040: ARRAY
68041: IN
68042: OR
68043: IFTRUE 68063
68045: PUSH
68046: LD_VAR 0 1
68050: PUSH
68051: LD_EXP 131
68055: PUSH
68056: LD_VAR 0 3
68060: ARRAY
68061: IN
68062: OR
68063: IFTRUE 68083
68065: PUSH
68066: LD_VAR 0 1
68070: PUSH
68071: LD_EXP 132
68075: PUSH
68076: LD_VAR 0 3
68080: ARRAY
68081: IN
68082: OR
68083: IFFALSE 69330
// begin if un in mc_ape [ i ] then
68085: LD_VAR 0 1
68089: PUSH
68090: LD_EXP 131
68094: PUSH
68095: LD_VAR 0 3
68099: ARRAY
68100: IN
68101: IFFALSE 68140
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
68103: LD_ADDR_EXP 131
68107: PUSH
68108: LD_EXP 131
68112: PPUSH
68113: LD_VAR 0 3
68117: PPUSH
68118: LD_EXP 131
68122: PUSH
68123: LD_VAR 0 3
68127: ARRAY
68128: PUSH
68129: LD_VAR 0 1
68133: DIFF
68134: PPUSH
68135: CALL_OW 1
68139: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
68140: LD_VAR 0 1
68144: PUSH
68145: LD_EXP 132
68149: PUSH
68150: LD_VAR 0 3
68154: ARRAY
68155: IN
68156: IFFALSE 68180
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
68158: LD_ADDR_EXP 132
68162: PUSH
68163: LD_EXP 132
68167: PPUSH
68168: LD_VAR 0 3
68172: PPUSH
68173: EMPTY
68174: PPUSH
68175: CALL_OW 1
68179: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
68180: LD_VAR 0 1
68184: PPUSH
68185: CALL_OW 247
68189: PUSH
68190: LD_INT 2
68192: EQUAL
68193: IFFALSE 68274
68195: PUSH
68196: LD_VAR 0 1
68200: PPUSH
68201: CALL_OW 110
68205: PUSH
68206: LD_INT 20
68208: EQUAL
68209: IFTRUE 68229
68211: PUSH
68212: LD_VAR 0 1
68216: PUSH
68217: LD_EXP 124
68221: PUSH
68222: LD_VAR 0 3
68226: ARRAY
68227: IN
68228: OR
68229: IFTRUE 68273
68231: PUSH
68232: LD_VAR 0 1
68236: PPUSH
68237: CALL_OW 264
68241: PUSH
68242: LD_INT 12
68244: PUSH
68245: LD_INT 51
68247: PUSH
68248: LD_INT 89
68250: PUSH
68251: LD_INT 32
68253: PUSH
68254: LD_INT 13
68256: PUSH
68257: LD_INT 52
68259: PUSH
68260: LD_INT 31
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: LIST
68267: LIST
68268: LIST
68269: LIST
68270: LIST
68271: IN
68272: OR
68273: AND
68274: IFFALSE 68582
// begin if un in mc_defender [ i ] then
68276: LD_VAR 0 1
68280: PUSH
68281: LD_EXP 124
68285: PUSH
68286: LD_VAR 0 3
68290: ARRAY
68291: IN
68292: IFFALSE 68331
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
68294: LD_ADDR_EXP 124
68298: PUSH
68299: LD_EXP 124
68303: PPUSH
68304: LD_VAR 0 3
68308: PPUSH
68309: LD_EXP 124
68313: PUSH
68314: LD_VAR 0 3
68318: ARRAY
68319: PUSH
68320: LD_VAR 0 1
68324: DIFF
68325: PPUSH
68326: CALL_OW 1
68330: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
68331: LD_ADDR_VAR 0 8
68335: PUSH
68336: LD_VAR 0 3
68340: PPUSH
68341: LD_INT 3
68343: PPUSH
68344: CALL 64870 0 2
68348: ST_TO_ADDR
// if fac then
68349: LD_VAR 0 8
68353: IFFALSE 68582
// begin for j in fac do
68355: LD_ADDR_VAR 0 4
68359: PUSH
68360: LD_VAR 0 8
68364: PUSH
68365: FOR_IN
68366: IFFALSE 68580
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
68368: LD_ADDR_VAR 0 9
68372: PUSH
68373: LD_VAR 0 8
68377: PPUSH
68378: LD_VAR 0 1
68382: PPUSH
68383: CALL_OW 265
68387: PPUSH
68388: LD_VAR 0 1
68392: PPUSH
68393: CALL_OW 262
68397: PPUSH
68398: LD_VAR 0 1
68402: PPUSH
68403: CALL_OW 263
68407: PPUSH
68408: LD_VAR 0 1
68412: PPUSH
68413: CALL_OW 264
68417: PPUSH
68418: CALL 73521 0 5
68422: ST_TO_ADDR
// if components then
68423: LD_VAR 0 9
68427: IFFALSE 68578
// begin if GetWeapon ( un ) = ar_control_tower then
68429: LD_VAR 0 1
68433: PPUSH
68434: CALL_OW 264
68438: PUSH
68439: LD_INT 31
68441: EQUAL
68442: IFFALSE 68559
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
68444: LD_VAR 0 1
68448: PPUSH
68449: CALL_OW 311
68453: PPUSH
68454: LD_INT 0
68456: PPUSH
68457: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
68461: LD_ADDR_EXP 142
68465: PUSH
68466: LD_EXP 142
68470: PPUSH
68471: LD_VAR 0 3
68475: PPUSH
68476: LD_EXP 142
68480: PUSH
68481: LD_VAR 0 3
68485: ARRAY
68486: PUSH
68487: LD_VAR 0 1
68491: PPUSH
68492: CALL_OW 311
68496: DIFF
68497: PPUSH
68498: CALL_OW 1
68502: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
68503: LD_ADDR_VAR 0 7
68507: PUSH
68508: LD_EXP 123
68512: PUSH
68513: LD_VAR 0 3
68517: ARRAY
68518: PPUSH
68519: LD_INT 1
68521: PPUSH
68522: LD_VAR 0 9
68526: PPUSH
68527: CALL_OW 2
68531: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
68532: LD_ADDR_EXP 123
68536: PUSH
68537: LD_EXP 123
68541: PPUSH
68542: LD_VAR 0 3
68546: PPUSH
68547: LD_VAR 0 7
68551: PPUSH
68552: CALL_OW 1
68556: ST_TO_ADDR
// end else
68557: GO 68576
// MC_InsertProduceList ( i , [ components ] ) ;
68559: LD_VAR 0 3
68563: PPUSH
68564: LD_VAR 0 9
68568: PUSH
68569: EMPTY
68570: LIST
68571: PPUSH
68572: CALL 64415 0 2
// break ;
68576: GO 68580
// end ; end ;
68578: GO 68365
68580: POP
68581: POP
// end ; end ; if GetType ( un ) = unit_building then
68582: LD_VAR 0 1
68586: PPUSH
68587: CALL_OW 247
68591: PUSH
68592: LD_INT 3
68594: EQUAL
68595: IFFALSE 68998
// begin btype := GetBType ( un ) ;
68597: LD_ADDR_VAR 0 5
68601: PUSH
68602: LD_VAR 0 1
68606: PPUSH
68607: CALL_OW 266
68611: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
68612: LD_VAR 0 5
68616: PUSH
68617: LD_INT 29
68619: PUSH
68620: LD_INT 30
68622: PUSH
68623: EMPTY
68624: LIST
68625: LIST
68626: IN
68627: IFFALSE 68700
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
68629: LD_VAR 0 1
68633: PPUSH
68634: CALL_OW 250
68638: PPUSH
68639: LD_VAR 0 1
68643: PPUSH
68644: CALL_OW 251
68648: PPUSH
68649: LD_VAR 0 1
68653: PPUSH
68654: CALL_OW 255
68658: PPUSH
68659: CALL_OW 440
68663: NOT
68664: IFFALSE 68700
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
68666: LD_VAR 0 1
68670: PPUSH
68671: CALL_OW 250
68675: PPUSH
68676: LD_VAR 0 1
68680: PPUSH
68681: CALL_OW 251
68685: PPUSH
68686: LD_VAR 0 1
68690: PPUSH
68691: CALL_OW 255
68695: PPUSH
68696: CALL_OW 441
// end ; if btype = b_warehouse then
68700: LD_VAR 0 5
68704: PUSH
68705: LD_INT 1
68707: EQUAL
68708: IFFALSE 68726
// begin btype := b_depot ;
68710: LD_ADDR_VAR 0 5
68714: PUSH
68715: LD_INT 0
68717: ST_TO_ADDR
// pos := 1 ;
68718: LD_ADDR_VAR 0 6
68722: PUSH
68723: LD_INT 1
68725: ST_TO_ADDR
// end ; if btype = b_factory then
68726: LD_VAR 0 5
68730: PUSH
68731: LD_INT 3
68733: EQUAL
68734: IFFALSE 68752
// begin btype := b_workshop ;
68736: LD_ADDR_VAR 0 5
68740: PUSH
68741: LD_INT 2
68743: ST_TO_ADDR
// pos := 1 ;
68744: LD_ADDR_VAR 0 6
68748: PUSH
68749: LD_INT 1
68751: ST_TO_ADDR
// end ; if btype = b_barracks then
68752: LD_VAR 0 5
68756: PUSH
68757: LD_INT 5
68759: EQUAL
68760: IFFALSE 68770
// btype := b_armoury ;
68762: LD_ADDR_VAR 0 5
68766: PUSH
68767: LD_INT 4
68769: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
68770: LD_VAR 0 5
68774: PUSH
68775: LD_INT 7
68777: PUSH
68778: LD_INT 8
68780: PUSH
68781: EMPTY
68782: LIST
68783: LIST
68784: IN
68785: IFFALSE 68795
// btype := b_lab ;
68787: LD_ADDR_VAR 0 5
68791: PUSH
68792: LD_INT 6
68794: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
68795: LD_ADDR_EXP 107
68799: PUSH
68800: LD_EXP 107
68804: PPUSH
68805: LD_VAR 0 3
68809: PUSH
68810: LD_EXP 107
68814: PUSH
68815: LD_VAR 0 3
68819: ARRAY
68820: PUSH
68821: LD_INT 1
68823: PLUS
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PPUSH
68829: LD_VAR 0 5
68833: PUSH
68834: LD_VAR 0 1
68838: PPUSH
68839: CALL_OW 250
68843: PUSH
68844: LD_VAR 0 1
68848: PPUSH
68849: CALL_OW 251
68853: PUSH
68854: LD_VAR 0 1
68858: PPUSH
68859: CALL_OW 254
68863: PUSH
68864: EMPTY
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: PPUSH
68870: CALL 76081 0 3
68874: ST_TO_ADDR
// if pos = 1 then
68875: LD_VAR 0 6
68879: PUSH
68880: LD_INT 1
68882: EQUAL
68883: IFFALSE 68998
// begin tmp := mc_build_list [ i ] ;
68885: LD_ADDR_VAR 0 7
68889: PUSH
68890: LD_EXP 107
68894: PUSH
68895: LD_VAR 0 3
68899: ARRAY
68900: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
68901: LD_VAR 0 7
68905: PPUSH
68906: LD_INT 2
68908: PUSH
68909: LD_INT 30
68911: PUSH
68912: LD_INT 0
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: LD_INT 30
68921: PUSH
68922: LD_INT 1
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: LIST
68933: PPUSH
68934: CALL_OW 72
68938: IFFALSE 68948
// pos := 2 ;
68940: LD_ADDR_VAR 0 6
68944: PUSH
68945: LD_INT 2
68947: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
68948: LD_ADDR_VAR 0 7
68952: PUSH
68953: LD_VAR 0 7
68957: PPUSH
68958: LD_VAR 0 6
68962: PPUSH
68963: LD_VAR 0 7
68967: PPUSH
68968: CALL 76407 0 3
68972: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
68973: LD_ADDR_EXP 107
68977: PUSH
68978: LD_EXP 107
68982: PPUSH
68983: LD_VAR 0 3
68987: PPUSH
68988: LD_VAR 0 7
68992: PPUSH
68993: CALL_OW 1
68997: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
68998: LD_VAR 0 1
69002: PUSH
69003: LD_EXP 102
69007: PUSH
69008: LD_VAR 0 3
69012: ARRAY
69013: IN
69014: IFFALSE 69053
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
69016: LD_ADDR_EXP 102
69020: PUSH
69021: LD_EXP 102
69025: PPUSH
69026: LD_VAR 0 3
69030: PPUSH
69031: LD_EXP 102
69035: PUSH
69036: LD_VAR 0 3
69040: ARRAY
69041: PUSH
69042: LD_VAR 0 1
69046: DIFF
69047: PPUSH
69048: CALL_OW 1
69052: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
69053: LD_VAR 0 1
69057: PUSH
69058: LD_EXP 109
69062: PUSH
69063: LD_VAR 0 3
69067: ARRAY
69068: IN
69069: IFFALSE 69108
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
69071: LD_ADDR_EXP 109
69075: PUSH
69076: LD_EXP 109
69080: PPUSH
69081: LD_VAR 0 3
69085: PPUSH
69086: LD_EXP 109
69090: PUSH
69091: LD_VAR 0 3
69095: ARRAY
69096: PUSH
69097: LD_VAR 0 1
69101: DIFF
69102: PPUSH
69103: CALL_OW 1
69107: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
69108: LD_VAR 0 1
69112: PUSH
69113: LD_EXP 121
69117: PUSH
69118: LD_VAR 0 3
69122: ARRAY
69123: IN
69124: IFFALSE 69163
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
69126: LD_ADDR_EXP 121
69130: PUSH
69131: LD_EXP 121
69135: PPUSH
69136: LD_VAR 0 3
69140: PPUSH
69141: LD_EXP 121
69145: PUSH
69146: LD_VAR 0 3
69150: ARRAY
69151: PUSH
69152: LD_VAR 0 1
69156: DIFF
69157: PPUSH
69158: CALL_OW 1
69162: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
69163: LD_VAR 0 1
69167: PUSH
69168: LD_EXP 124
69172: PUSH
69173: LD_VAR 0 3
69177: ARRAY
69178: IN
69179: IFFALSE 69218
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
69181: LD_ADDR_EXP 124
69185: PUSH
69186: LD_EXP 124
69190: PPUSH
69191: LD_VAR 0 3
69195: PPUSH
69196: LD_EXP 124
69200: PUSH
69201: LD_VAR 0 3
69205: ARRAY
69206: PUSH
69207: LD_VAR 0 1
69211: DIFF
69212: PPUSH
69213: CALL_OW 1
69217: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
69218: LD_VAR 0 1
69222: PUSH
69223: LD_EXP 111
69227: PUSH
69228: LD_VAR 0 3
69232: ARRAY
69233: IN
69234: IFFALSE 69273
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
69236: LD_ADDR_EXP 111
69240: PUSH
69241: LD_EXP 111
69245: PPUSH
69246: LD_VAR 0 3
69250: PPUSH
69251: LD_EXP 111
69255: PUSH
69256: LD_VAR 0 3
69260: ARRAY
69261: PUSH
69262: LD_VAR 0 1
69266: DIFF
69267: PPUSH
69268: CALL_OW 1
69272: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
69273: LD_VAR 0 1
69277: PUSH
69278: LD_EXP 110
69282: PUSH
69283: LD_VAR 0 3
69287: ARRAY
69288: IN
69289: IFFALSE 69328
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
69291: LD_ADDR_EXP 110
69295: PUSH
69296: LD_EXP 110
69300: PPUSH
69301: LD_VAR 0 3
69305: PPUSH
69306: LD_EXP 110
69310: PUSH
69311: LD_VAR 0 3
69315: ARRAY
69316: PUSH
69317: LD_VAR 0 1
69321: DIFF
69322: PPUSH
69323: CALL_OW 1
69327: ST_TO_ADDR
// end ; break ;
69328: GO 69332
// end ;
69330: GO 67964
69332: POP
69333: POP
// end ;
69334: LD_VAR 0 2
69338: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
69339: LD_INT 0
69341: PPUSH
69342: PPUSH
69343: PPUSH
// if not mc_bases or not skirmish then
69344: LD_EXP 102
69348: NOT
69349: IFTRUE 69358
69351: PUSH
69352: LD_EXP 100
69356: NOT
69357: OR
69358: IFFALSE 69362
// exit ;
69360: GO 69577
// for i = 1 to mc_bases do
69362: LD_ADDR_VAR 0 3
69366: PUSH
69367: DOUBLE
69368: LD_INT 1
69370: DEC
69371: ST_TO_ADDR
69372: LD_EXP 102
69376: PUSH
69377: FOR_TO
69378: IFFALSE 69575
// begin if building in mc_construct_list [ i ] then
69380: LD_VAR 0 1
69384: PUSH
69385: LD_EXP 109
69389: PUSH
69390: LD_VAR 0 3
69394: ARRAY
69395: IN
69396: IFFALSE 69573
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
69398: LD_ADDR_EXP 109
69402: PUSH
69403: LD_EXP 109
69407: PPUSH
69408: LD_VAR 0 3
69412: PPUSH
69413: LD_EXP 109
69417: PUSH
69418: LD_VAR 0 3
69422: ARRAY
69423: PUSH
69424: LD_VAR 0 1
69428: DIFF
69429: PPUSH
69430: CALL_OW 1
69434: ST_TO_ADDR
// if building in mc_lab [ i ] then
69435: LD_VAR 0 1
69439: PUSH
69440: LD_EXP 135
69444: PUSH
69445: LD_VAR 0 3
69449: ARRAY
69450: IN
69451: IFFALSE 69506
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
69453: LD_ADDR_EXP 136
69457: PUSH
69458: LD_EXP 136
69462: PPUSH
69463: LD_VAR 0 3
69467: PPUSH
69468: LD_EXP 136
69472: PUSH
69473: LD_VAR 0 3
69477: ARRAY
69478: PPUSH
69479: LD_INT 1
69481: PPUSH
69482: LD_EXP 136
69486: PUSH
69487: LD_VAR 0 3
69491: ARRAY
69492: PPUSH
69493: LD_INT 0
69495: PPUSH
69496: CALL 75489 0 4
69500: PPUSH
69501: CALL_OW 1
69505: ST_TO_ADDR
// if not building in mc_bases [ i ] then
69506: LD_VAR 0 1
69510: PUSH
69511: LD_EXP 102
69515: PUSH
69516: LD_VAR 0 3
69520: ARRAY
69521: IN
69522: NOT
69523: IFFALSE 69569
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69525: LD_ADDR_EXP 102
69529: PUSH
69530: LD_EXP 102
69534: PPUSH
69535: LD_VAR 0 3
69539: PUSH
69540: LD_EXP 102
69544: PUSH
69545: LD_VAR 0 3
69549: ARRAY
69550: PUSH
69551: LD_INT 1
69553: PLUS
69554: PUSH
69555: EMPTY
69556: LIST
69557: LIST
69558: PPUSH
69559: LD_VAR 0 1
69563: PPUSH
69564: CALL 76081 0 3
69568: ST_TO_ADDR
// exit ;
69569: POP
69570: POP
69571: GO 69577
// end ; end ;
69573: GO 69377
69575: POP
69576: POP
// end ;
69577: LD_VAR 0 2
69581: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
69582: LD_INT 0
69584: PPUSH
69585: PPUSH
69586: PPUSH
69587: PPUSH
69588: PPUSH
69589: PPUSH
69590: PPUSH
// if not mc_bases or not skirmish then
69591: LD_EXP 102
69595: NOT
69596: IFTRUE 69605
69598: PUSH
69599: LD_EXP 100
69603: NOT
69604: OR
69605: IFFALSE 69609
// exit ;
69607: GO 70270
// for i = 1 to mc_bases do
69609: LD_ADDR_VAR 0 3
69613: PUSH
69614: DOUBLE
69615: LD_INT 1
69617: DEC
69618: ST_TO_ADDR
69619: LD_EXP 102
69623: PUSH
69624: FOR_TO
69625: IFFALSE 70268
// begin if building in mc_construct_list [ i ] then
69627: LD_VAR 0 1
69631: PUSH
69632: LD_EXP 109
69636: PUSH
69637: LD_VAR 0 3
69641: ARRAY
69642: IN
69643: IFFALSE 70266
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
69645: LD_ADDR_EXP 109
69649: PUSH
69650: LD_EXP 109
69654: PPUSH
69655: LD_VAR 0 3
69659: PPUSH
69660: LD_EXP 109
69664: PUSH
69665: LD_VAR 0 3
69669: ARRAY
69670: PUSH
69671: LD_VAR 0 1
69675: DIFF
69676: PPUSH
69677: CALL_OW 1
69681: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
69682: LD_ADDR_EXP 102
69686: PUSH
69687: LD_EXP 102
69691: PPUSH
69692: LD_VAR 0 3
69696: PUSH
69697: LD_EXP 102
69701: PUSH
69702: LD_VAR 0 3
69706: ARRAY
69707: PUSH
69708: LD_INT 1
69710: PLUS
69711: PUSH
69712: EMPTY
69713: LIST
69714: LIST
69715: PPUSH
69716: LD_VAR 0 1
69720: PPUSH
69721: CALL 76081 0 3
69725: ST_TO_ADDR
// btype := GetBType ( building ) ;
69726: LD_ADDR_VAR 0 5
69730: PUSH
69731: LD_VAR 0 1
69735: PPUSH
69736: CALL_OW 266
69740: ST_TO_ADDR
// side := GetSide ( building ) ;
69741: LD_ADDR_VAR 0 8
69745: PUSH
69746: LD_VAR 0 1
69750: PPUSH
69751: CALL_OW 255
69755: ST_TO_ADDR
// if btype = b_lab then
69756: LD_VAR 0 5
69760: PUSH
69761: LD_INT 6
69763: EQUAL
69764: IFFALSE 69814
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
69766: LD_ADDR_EXP 135
69770: PUSH
69771: LD_EXP 135
69775: PPUSH
69776: LD_VAR 0 3
69780: PUSH
69781: LD_EXP 135
69785: PUSH
69786: LD_VAR 0 3
69790: ARRAY
69791: PUSH
69792: LD_INT 1
69794: PLUS
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: PPUSH
69800: LD_VAR 0 1
69804: PPUSH
69805: CALL 76081 0 3
69809: ST_TO_ADDR
// exit ;
69810: POP
69811: POP
69812: GO 70270
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
69814: LD_VAR 0 5
69818: PUSH
69819: LD_INT 0
69821: PUSH
69822: LD_INT 2
69824: PUSH
69825: LD_INT 4
69827: PUSH
69828: EMPTY
69829: LIST
69830: LIST
69831: LIST
69832: IN
69833: IFFALSE 69957
// begin if btype = b_armoury then
69835: LD_VAR 0 5
69839: PUSH
69840: LD_INT 4
69842: EQUAL
69843: IFFALSE 69853
// btype := b_barracks ;
69845: LD_ADDR_VAR 0 5
69849: PUSH
69850: LD_INT 5
69852: ST_TO_ADDR
// if btype = b_depot then
69853: LD_VAR 0 5
69857: PUSH
69858: LD_INT 0
69860: EQUAL
69861: IFFALSE 69871
// btype := b_warehouse ;
69863: LD_ADDR_VAR 0 5
69867: PUSH
69868: LD_INT 1
69870: ST_TO_ADDR
// if btype = b_workshop then
69871: LD_VAR 0 5
69875: PUSH
69876: LD_INT 2
69878: EQUAL
69879: IFFALSE 69889
// btype := b_factory ;
69881: LD_ADDR_VAR 0 5
69885: PUSH
69886: LD_INT 3
69888: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
69889: LD_VAR 0 5
69893: PPUSH
69894: LD_VAR 0 8
69898: PPUSH
69899: CALL_OW 323
69903: PUSH
69904: LD_INT 1
69906: EQUAL
69907: IFFALSE 69953
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
69909: LD_ADDR_EXP 134
69913: PUSH
69914: LD_EXP 134
69918: PPUSH
69919: LD_VAR 0 3
69923: PUSH
69924: LD_EXP 134
69928: PUSH
69929: LD_VAR 0 3
69933: ARRAY
69934: PUSH
69935: LD_INT 1
69937: PLUS
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: PPUSH
69943: LD_VAR 0 1
69947: PPUSH
69948: CALL 76081 0 3
69952: ST_TO_ADDR
// exit ;
69953: POP
69954: POP
69955: GO 70270
// end ; if btype in [ b_bunker , b_turret ] then
69957: LD_VAR 0 5
69961: PUSH
69962: LD_INT 32
69964: PUSH
69965: LD_INT 33
69967: PUSH
69968: EMPTY
69969: LIST
69970: LIST
69971: IN
69972: IFFALSE 70262
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
69974: LD_ADDR_EXP 110
69978: PUSH
69979: LD_EXP 110
69983: PPUSH
69984: LD_VAR 0 3
69988: PUSH
69989: LD_EXP 110
69993: PUSH
69994: LD_VAR 0 3
69998: ARRAY
69999: PUSH
70000: LD_INT 1
70002: PLUS
70003: PUSH
70004: EMPTY
70005: LIST
70006: LIST
70007: PPUSH
70008: LD_VAR 0 1
70012: PPUSH
70013: CALL 76081 0 3
70017: ST_TO_ADDR
// if btype = b_bunker then
70018: LD_VAR 0 5
70022: PUSH
70023: LD_INT 32
70025: EQUAL
70026: IFFALSE 70262
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70028: LD_ADDR_EXP 111
70032: PUSH
70033: LD_EXP 111
70037: PPUSH
70038: LD_VAR 0 3
70042: PUSH
70043: LD_EXP 111
70047: PUSH
70048: LD_VAR 0 3
70052: ARRAY
70053: PUSH
70054: LD_INT 1
70056: PLUS
70057: PUSH
70058: EMPTY
70059: LIST
70060: LIST
70061: PPUSH
70062: LD_VAR 0 1
70066: PPUSH
70067: CALL 76081 0 3
70071: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
70072: LD_ADDR_VAR 0 6
70076: PUSH
70077: LD_EXP 102
70081: PUSH
70082: LD_VAR 0 3
70086: ARRAY
70087: PPUSH
70088: LD_INT 25
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 3
70100: PUSH
70101: LD_INT 54
70103: PUSH
70104: EMPTY
70105: LIST
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: EMPTY
70112: LIST
70113: LIST
70114: PPUSH
70115: CALL_OW 72
70119: ST_TO_ADDR
// if tmp then
70120: LD_VAR 0 6
70124: IFFALSE 70130
// exit ;
70126: POP
70127: POP
70128: GO 70270
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70130: LD_ADDR_VAR 0 6
70134: PUSH
70135: LD_EXP 102
70139: PUSH
70140: LD_VAR 0 3
70144: ARRAY
70145: PPUSH
70146: LD_INT 2
70148: PUSH
70149: LD_INT 30
70151: PUSH
70152: LD_INT 4
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 30
70161: PUSH
70162: LD_INT 5
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: LIST
70173: PPUSH
70174: CALL_OW 72
70178: ST_TO_ADDR
// if not tmp then
70179: LD_VAR 0 6
70183: NOT
70184: IFFALSE 70190
// exit ;
70186: POP
70187: POP
70188: GO 70270
// for j in tmp do
70190: LD_ADDR_VAR 0 4
70194: PUSH
70195: LD_VAR 0 6
70199: PUSH
70200: FOR_IN
70201: IFFALSE 70260
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
70203: LD_ADDR_VAR 0 7
70207: PUSH
70208: LD_VAR 0 4
70212: PPUSH
70213: CALL_OW 313
70217: PPUSH
70218: LD_INT 25
70220: PUSH
70221: LD_INT 1
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PPUSH
70228: CALL_OW 72
70232: ST_TO_ADDR
// if units then
70233: LD_VAR 0 7
70237: IFFALSE 70258
// begin ComExitBuilding ( units [ 1 ] ) ;
70239: LD_VAR 0 7
70243: PUSH
70244: LD_INT 1
70246: ARRAY
70247: PPUSH
70248: CALL_OW 122
// exit ;
70252: POP
70253: POP
70254: POP
70255: POP
70256: GO 70270
// end ; end ;
70258: GO 70200
70260: POP
70261: POP
// end ; end ; exit ;
70262: POP
70263: POP
70264: GO 70270
// end ; end ;
70266: GO 69624
70268: POP
70269: POP
// end ;
70270: LD_VAR 0 2
70274: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
70275: LD_INT 0
70277: PPUSH
70278: PPUSH
70279: PPUSH
70280: PPUSH
70281: PPUSH
70282: PPUSH
70283: PPUSH
// if not mc_bases or not skirmish then
70284: LD_EXP 102
70288: NOT
70289: IFTRUE 70298
70291: PUSH
70292: LD_EXP 100
70296: NOT
70297: OR
70298: IFFALSE 70302
// exit ;
70300: GO 70567
// btype := GetBType ( building ) ;
70302: LD_ADDR_VAR 0 6
70306: PUSH
70307: LD_VAR 0 1
70311: PPUSH
70312: CALL_OW 266
70316: ST_TO_ADDR
// x := GetX ( building ) ;
70317: LD_ADDR_VAR 0 7
70321: PUSH
70322: LD_VAR 0 1
70326: PPUSH
70327: CALL_OW 250
70331: ST_TO_ADDR
// y := GetY ( building ) ;
70332: LD_ADDR_VAR 0 8
70336: PUSH
70337: LD_VAR 0 1
70341: PPUSH
70342: CALL_OW 251
70346: ST_TO_ADDR
// d := GetDir ( building ) ;
70347: LD_ADDR_VAR 0 9
70351: PUSH
70352: LD_VAR 0 1
70356: PPUSH
70357: CALL_OW 254
70361: ST_TO_ADDR
// for i = 1 to mc_bases do
70362: LD_ADDR_VAR 0 4
70366: PUSH
70367: DOUBLE
70368: LD_INT 1
70370: DEC
70371: ST_TO_ADDR
70372: LD_EXP 102
70376: PUSH
70377: FOR_TO
70378: IFFALSE 70565
// begin if not mc_build_list [ i ] then
70380: LD_EXP 107
70384: PUSH
70385: LD_VAR 0 4
70389: ARRAY
70390: NOT
70391: IFFALSE 70395
// continue ;
70393: GO 70377
// for j := 1 to mc_build_list [ i ] do
70395: LD_ADDR_VAR 0 5
70399: PUSH
70400: DOUBLE
70401: LD_INT 1
70403: DEC
70404: ST_TO_ADDR
70405: LD_EXP 107
70409: PUSH
70410: LD_VAR 0 4
70414: ARRAY
70415: PUSH
70416: FOR_TO
70417: IFFALSE 70561
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
70419: LD_VAR 0 6
70423: PUSH
70424: LD_VAR 0 7
70428: PUSH
70429: LD_VAR 0 8
70433: PUSH
70434: LD_VAR 0 9
70438: PUSH
70439: EMPTY
70440: LIST
70441: LIST
70442: LIST
70443: LIST
70444: PPUSH
70445: LD_EXP 107
70449: PUSH
70450: LD_VAR 0 4
70454: ARRAY
70455: PUSH
70456: LD_VAR 0 5
70460: ARRAY
70461: PPUSH
70462: CALL 82688 0 2
70466: IFFALSE 70559
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
70468: LD_ADDR_EXP 107
70472: PUSH
70473: LD_EXP 107
70477: PPUSH
70478: LD_VAR 0 4
70482: PPUSH
70483: LD_EXP 107
70487: PUSH
70488: LD_VAR 0 4
70492: ARRAY
70493: PPUSH
70494: LD_VAR 0 5
70498: PPUSH
70499: CALL_OW 3
70503: PPUSH
70504: CALL_OW 1
70508: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
70509: LD_ADDR_EXP 109
70513: PUSH
70514: LD_EXP 109
70518: PPUSH
70519: LD_VAR 0 4
70523: PUSH
70524: LD_EXP 109
70528: PUSH
70529: LD_VAR 0 4
70533: ARRAY
70534: PUSH
70535: LD_INT 1
70537: PLUS
70538: PUSH
70539: EMPTY
70540: LIST
70541: LIST
70542: PPUSH
70543: LD_VAR 0 1
70547: PPUSH
70548: CALL 76081 0 3
70552: ST_TO_ADDR
// exit ;
70553: POP
70554: POP
70555: POP
70556: POP
70557: GO 70567
// end ;
70559: GO 70416
70561: POP
70562: POP
// end ;
70563: GO 70377
70565: POP
70566: POP
// end ;
70567: LD_VAR 0 3
70571: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
70572: LD_INT 0
70574: PPUSH
70575: PPUSH
70576: PPUSH
// if not mc_bases or not skirmish then
70577: LD_EXP 102
70581: NOT
70582: IFTRUE 70591
70584: PUSH
70585: LD_EXP 100
70589: NOT
70590: OR
70591: IFFALSE 70595
// exit ;
70593: GO 70791
// for i = 1 to mc_bases do
70595: LD_ADDR_VAR 0 4
70599: PUSH
70600: DOUBLE
70601: LD_INT 1
70603: DEC
70604: ST_TO_ADDR
70605: LD_EXP 102
70609: PUSH
70610: FOR_TO
70611: IFFALSE 70700
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
70613: LD_VAR 0 1
70617: PUSH
70618: LD_EXP 110
70622: PUSH
70623: LD_VAR 0 4
70627: ARRAY
70628: IN
70629: IFFALSE 70650
70631: PUSH
70632: LD_VAR 0 1
70636: PUSH
70637: LD_EXP 111
70641: PUSH
70642: LD_VAR 0 4
70646: ARRAY
70647: IN
70648: NOT
70649: AND
70650: IFFALSE 70698
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
70652: LD_ADDR_EXP 111
70656: PUSH
70657: LD_EXP 111
70661: PPUSH
70662: LD_VAR 0 4
70666: PUSH
70667: LD_EXP 111
70671: PUSH
70672: LD_VAR 0 4
70676: ARRAY
70677: PUSH
70678: LD_INT 1
70680: PLUS
70681: PUSH
70682: EMPTY
70683: LIST
70684: LIST
70685: PPUSH
70686: LD_VAR 0 1
70690: PPUSH
70691: CALL 76081 0 3
70695: ST_TO_ADDR
// break ;
70696: GO 70700
// end ; end ;
70698: GO 70610
70700: POP
70701: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
70702: LD_VAR 0 1
70706: PPUSH
70707: CALL_OW 257
70711: PUSH
70712: LD_EXP 128
70716: IN
70717: IFFALSE 70734
70719: PUSH
70720: LD_VAR 0 1
70724: PPUSH
70725: CALL_OW 266
70729: PUSH
70730: LD_INT 5
70732: EQUAL
70733: AND
70734: IFFALSE 70751
70736: PUSH
70737: LD_VAR 0 2
70741: PPUSH
70742: CALL_OW 110
70746: PUSH
70747: LD_INT 18
70749: NONEQUAL
70750: AND
70751: IFFALSE 70791
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
70753: LD_VAR 0 2
70757: PPUSH
70758: CALL_OW 257
70762: PUSH
70763: LD_INT 5
70765: PUSH
70766: LD_INT 8
70768: PUSH
70769: LD_INT 9
70771: PUSH
70772: EMPTY
70773: LIST
70774: LIST
70775: LIST
70776: IN
70777: IFFALSE 70791
// SetClass ( unit , 1 ) ;
70779: LD_VAR 0 2
70783: PPUSH
70784: LD_INT 1
70786: PPUSH
70787: CALL_OW 336
// end ;
70791: LD_VAR 0 3
70795: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
70796: LD_INT 0
70798: PPUSH
70799: PPUSH
// if not mc_bases or not skirmish then
70800: LD_EXP 102
70804: NOT
70805: IFTRUE 70814
70807: PUSH
70808: LD_EXP 100
70812: NOT
70813: OR
70814: IFFALSE 70818
// exit ;
70816: GO 70934
// if GetLives ( abandoned_vehicle ) > 250 then
70818: LD_VAR 0 2
70822: PPUSH
70823: CALL_OW 256
70827: PUSH
70828: LD_INT 250
70830: GREATER
70831: IFFALSE 70835
// exit ;
70833: GO 70934
// for i = 1 to mc_bases do
70835: LD_ADDR_VAR 0 6
70839: PUSH
70840: DOUBLE
70841: LD_INT 1
70843: DEC
70844: ST_TO_ADDR
70845: LD_EXP 102
70849: PUSH
70850: FOR_TO
70851: IFFALSE 70932
// begin if driver in mc_bases [ i ] then
70853: LD_VAR 0 1
70857: PUSH
70858: LD_EXP 102
70862: PUSH
70863: LD_VAR 0 6
70867: ARRAY
70868: IN
70869: IFFALSE 70930
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
70871: LD_VAR 0 1
70875: PPUSH
70876: LD_EXP 102
70880: PUSH
70881: LD_VAR 0 6
70885: ARRAY
70886: PPUSH
70887: LD_INT 2
70889: PUSH
70890: LD_INT 30
70892: PUSH
70893: LD_INT 0
70895: PUSH
70896: EMPTY
70897: LIST
70898: LIST
70899: PUSH
70900: LD_INT 30
70902: PUSH
70903: LD_INT 1
70905: PUSH
70906: EMPTY
70907: LIST
70908: LIST
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: LIST
70914: PPUSH
70915: CALL_OW 72
70919: PUSH
70920: LD_INT 1
70922: ARRAY
70923: PPUSH
70924: CALL 110018 0 2
// break ;
70928: GO 70932
// end ; end ;
70930: GO 70850
70932: POP
70933: POP
// end ; end_of_file
70934: LD_VAR 0 5
70938: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
70939: LD_INT 0
70941: PPUSH
70942: PPUSH
// if exist_mode then
70943: LD_VAR 0 2
70947: IFFALSE 70993
// begin unit := CreateCharacter ( prefix & ident ) ;
70949: LD_ADDR_VAR 0 5
70953: PUSH
70954: LD_VAR 0 3
70958: PUSH
70959: LD_VAR 0 1
70963: STR
70964: PPUSH
70965: CALL_OW 34
70969: ST_TO_ADDR
// if unit then
70970: LD_VAR 0 5
70974: IFFALSE 70991
// DeleteCharacters ( prefix & ident ) ;
70976: LD_VAR 0 3
70980: PUSH
70981: LD_VAR 0 1
70985: STR
70986: PPUSH
70987: CALL_OW 40
// end else
70991: GO 71008
// unit := NewCharacter ( ident ) ;
70993: LD_ADDR_VAR 0 5
70997: PUSH
70998: LD_VAR 0 1
71002: PPUSH
71003: CALL_OW 25
71007: ST_TO_ADDR
// result := unit ;
71008: LD_ADDR_VAR 0 4
71012: PUSH
71013: LD_VAR 0 5
71017: ST_TO_ADDR
// end ;
71018: LD_VAR 0 4
71022: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
71023: LD_INT 0
71025: PPUSH
71026: PPUSH
// if exist_mode then
71027: LD_VAR 0 2
71031: IFFALSE 71056
// unit := CreateCharacter ( prefix & ident ) else
71033: LD_ADDR_VAR 0 5
71037: PUSH
71038: LD_VAR 0 3
71042: PUSH
71043: LD_VAR 0 1
71047: STR
71048: PPUSH
71049: CALL_OW 34
71053: ST_TO_ADDR
71054: GO 71071
// unit := NewCharacter ( ident ) ;
71056: LD_ADDR_VAR 0 5
71060: PUSH
71061: LD_VAR 0 1
71065: PPUSH
71066: CALL_OW 25
71070: ST_TO_ADDR
// result := unit ;
71071: LD_ADDR_VAR 0 4
71075: PUSH
71076: LD_VAR 0 5
71080: ST_TO_ADDR
// end ;
71081: LD_VAR 0 4
71085: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
71086: LD_INT 0
71088: PPUSH
71089: PPUSH
// if not side or not nation then
71090: LD_VAR 0 1
71094: NOT
71095: IFTRUE 71104
71097: PUSH
71098: LD_VAR 0 2
71102: NOT
71103: OR
71104: IFFALSE 71108
// exit ;
71106: GO 71902
// case nation of nation_american :
71108: LD_VAR 0 2
71112: PUSH
71113: LD_INT 1
71115: DOUBLE
71116: EQUAL
71117: IFTRUE 71121
71119: GO 71343
71121: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 , 90 , 93 ] ; nation_arabian :
71122: LD_ADDR_VAR 0 4
71126: PUSH
71127: LD_INT 35
71129: PUSH
71130: LD_INT 45
71132: PUSH
71133: LD_INT 46
71135: PUSH
71136: LD_INT 47
71138: PUSH
71139: LD_INT 82
71141: PUSH
71142: LD_INT 83
71144: PUSH
71145: LD_INT 84
71147: PUSH
71148: LD_INT 85
71150: PUSH
71151: LD_INT 86
71153: PUSH
71154: LD_INT 1
71156: PUSH
71157: LD_INT 2
71159: PUSH
71160: LD_INT 6
71162: PUSH
71163: LD_INT 15
71165: PUSH
71166: LD_INT 16
71168: PUSH
71169: LD_INT 7
71171: PUSH
71172: LD_INT 12
71174: PUSH
71175: LD_INT 13
71177: PUSH
71178: LD_INT 10
71180: PUSH
71181: LD_INT 14
71183: PUSH
71184: LD_INT 20
71186: PUSH
71187: LD_INT 21
71189: PUSH
71190: LD_INT 22
71192: PUSH
71193: LD_INT 25
71195: PUSH
71196: LD_INT 32
71198: PUSH
71199: LD_INT 27
71201: PUSH
71202: LD_INT 36
71204: PUSH
71205: LD_INT 69
71207: PUSH
71208: LD_INT 39
71210: PUSH
71211: LD_INT 34
71213: PUSH
71214: LD_INT 40
71216: PUSH
71217: LD_INT 48
71219: PUSH
71220: LD_INT 49
71222: PUSH
71223: LD_INT 50
71225: PUSH
71226: LD_INT 51
71228: PUSH
71229: LD_INT 52
71231: PUSH
71232: LD_INT 53
71234: PUSH
71235: LD_INT 54
71237: PUSH
71238: LD_INT 55
71240: PUSH
71241: LD_INT 56
71243: PUSH
71244: LD_INT 57
71246: PUSH
71247: LD_INT 58
71249: PUSH
71250: LD_INT 59
71252: PUSH
71253: LD_INT 60
71255: PUSH
71256: LD_INT 61
71258: PUSH
71259: LD_INT 62
71261: PUSH
71262: LD_INT 80
71264: PUSH
71265: LD_INT 82
71267: PUSH
71268: LD_INT 83
71270: PUSH
71271: LD_INT 84
71273: PUSH
71274: LD_INT 85
71276: PUSH
71277: LD_INT 86
71279: PUSH
71280: LD_INT 90
71282: PUSH
71283: LD_INT 93
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: LIST
71290: LIST
71291: LIST
71292: LIST
71293: LIST
71294: LIST
71295: LIST
71296: LIST
71297: LIST
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: LIST
71303: LIST
71304: LIST
71305: LIST
71306: LIST
71307: LIST
71308: LIST
71309: LIST
71310: LIST
71311: LIST
71312: LIST
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: LIST
71331: LIST
71332: LIST
71333: LIST
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: ST_TO_ADDR
71341: GO 71824
71343: LD_INT 2
71345: DOUBLE
71346: EQUAL
71347: IFTRUE 71351
71349: GO 71585
71351: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 , 92 , 94 ] ; nation_russian :
71352: LD_ADDR_VAR 0 4
71356: PUSH
71357: LD_INT 35
71359: PUSH
71360: LD_INT 45
71362: PUSH
71363: LD_INT 46
71365: PUSH
71366: LD_INT 47
71368: PUSH
71369: LD_INT 82
71371: PUSH
71372: LD_INT 83
71374: PUSH
71375: LD_INT 84
71377: PUSH
71378: LD_INT 85
71380: PUSH
71381: LD_INT 87
71383: PUSH
71384: LD_INT 70
71386: PUSH
71387: LD_INT 1
71389: PUSH
71390: LD_INT 11
71392: PUSH
71393: LD_INT 3
71395: PUSH
71396: LD_INT 4
71398: PUSH
71399: LD_INT 5
71401: PUSH
71402: LD_INT 6
71404: PUSH
71405: LD_INT 15
71407: PUSH
71408: LD_INT 18
71410: PUSH
71411: LD_INT 7
71413: PUSH
71414: LD_INT 17
71416: PUSH
71417: LD_INT 8
71419: PUSH
71420: LD_INT 20
71422: PUSH
71423: LD_INT 21
71425: PUSH
71426: LD_INT 22
71428: PUSH
71429: LD_INT 72
71431: PUSH
71432: LD_INT 26
71434: PUSH
71435: LD_INT 69
71437: PUSH
71438: LD_INT 39
71440: PUSH
71441: LD_INT 40
71443: PUSH
71444: LD_INT 41
71446: PUSH
71447: LD_INT 42
71449: PUSH
71450: LD_INT 43
71452: PUSH
71453: LD_INT 48
71455: PUSH
71456: LD_INT 49
71458: PUSH
71459: LD_INT 50
71461: PUSH
71462: LD_INT 51
71464: PUSH
71465: LD_INT 52
71467: PUSH
71468: LD_INT 53
71470: PUSH
71471: LD_INT 54
71473: PUSH
71474: LD_INT 55
71476: PUSH
71477: LD_INT 56
71479: PUSH
71480: LD_INT 60
71482: PUSH
71483: LD_INT 61
71485: PUSH
71486: LD_INT 62
71488: PUSH
71489: LD_INT 66
71491: PUSH
71492: LD_INT 67
71494: PUSH
71495: LD_INT 68
71497: PUSH
71498: LD_INT 81
71500: PUSH
71501: LD_INT 82
71503: PUSH
71504: LD_INT 83
71506: PUSH
71507: LD_INT 84
71509: PUSH
71510: LD_INT 85
71512: PUSH
71513: LD_INT 87
71515: PUSH
71516: LD_INT 88
71518: PUSH
71519: LD_INT 92
71521: PUSH
71522: LD_INT 94
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: LIST
71529: LIST
71530: LIST
71531: LIST
71532: LIST
71533: LIST
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: LIST
71539: LIST
71540: LIST
71541: LIST
71542: LIST
71543: LIST
71544: LIST
71545: LIST
71546: LIST
71547: LIST
71548: LIST
71549: LIST
71550: LIST
71551: LIST
71552: LIST
71553: LIST
71554: LIST
71555: LIST
71556: LIST
71557: LIST
71558: LIST
71559: LIST
71560: LIST
71561: LIST
71562: LIST
71563: LIST
71564: LIST
71565: LIST
71566: LIST
71567: LIST
71568: LIST
71569: LIST
71570: LIST
71571: LIST
71572: LIST
71573: LIST
71574: LIST
71575: LIST
71576: LIST
71577: LIST
71578: LIST
71579: LIST
71580: LIST
71581: LIST
71582: ST_TO_ADDR
71583: GO 71824
71585: LD_INT 3
71587: DOUBLE
71588: EQUAL
71589: IFTRUE 71593
71591: GO 71823
71593: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 , 89 , 91 ] ; end ;
71594: LD_ADDR_VAR 0 4
71598: PUSH
71599: LD_INT 46
71601: PUSH
71602: LD_INT 47
71604: PUSH
71605: LD_INT 1
71607: PUSH
71608: LD_INT 2
71610: PUSH
71611: LD_INT 82
71613: PUSH
71614: LD_INT 83
71616: PUSH
71617: LD_INT 84
71619: PUSH
71620: LD_INT 85
71622: PUSH
71623: LD_INT 86
71625: PUSH
71626: LD_INT 11
71628: PUSH
71629: LD_INT 9
71631: PUSH
71632: LD_INT 20
71634: PUSH
71635: LD_INT 19
71637: PUSH
71638: LD_INT 21
71640: PUSH
71641: LD_INT 24
71643: PUSH
71644: LD_INT 22
71646: PUSH
71647: LD_INT 25
71649: PUSH
71650: LD_INT 28
71652: PUSH
71653: LD_INT 29
71655: PUSH
71656: LD_INT 30
71658: PUSH
71659: LD_INT 31
71661: PUSH
71662: LD_INT 37
71664: PUSH
71665: LD_INT 38
71667: PUSH
71668: LD_INT 32
71670: PUSH
71671: LD_INT 27
71673: PUSH
71674: LD_INT 33
71676: PUSH
71677: LD_INT 69
71679: PUSH
71680: LD_INT 39
71682: PUSH
71683: LD_INT 34
71685: PUSH
71686: LD_INT 40
71688: PUSH
71689: LD_INT 71
71691: PUSH
71692: LD_INT 23
71694: PUSH
71695: LD_INT 44
71697: PUSH
71698: LD_INT 48
71700: PUSH
71701: LD_INT 49
71703: PUSH
71704: LD_INT 50
71706: PUSH
71707: LD_INT 51
71709: PUSH
71710: LD_INT 52
71712: PUSH
71713: LD_INT 53
71715: PUSH
71716: LD_INT 54
71718: PUSH
71719: LD_INT 55
71721: PUSH
71722: LD_INT 56
71724: PUSH
71725: LD_INT 57
71727: PUSH
71728: LD_INT 58
71730: PUSH
71731: LD_INT 59
71733: PUSH
71734: LD_INT 63
71736: PUSH
71737: LD_INT 64
71739: PUSH
71740: LD_INT 65
71742: PUSH
71743: LD_INT 82
71745: PUSH
71746: LD_INT 83
71748: PUSH
71749: LD_INT 84
71751: PUSH
71752: LD_INT 85
71754: PUSH
71755: LD_INT 86
71757: PUSH
71758: LD_INT 89
71760: PUSH
71761: LD_INT 91
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: LIST
71791: LIST
71792: LIST
71793: LIST
71794: LIST
71795: LIST
71796: LIST
71797: LIST
71798: LIST
71799: LIST
71800: LIST
71801: LIST
71802: LIST
71803: LIST
71804: LIST
71805: LIST
71806: LIST
71807: LIST
71808: LIST
71809: LIST
71810: LIST
71811: LIST
71812: LIST
71813: LIST
71814: LIST
71815: LIST
71816: LIST
71817: LIST
71818: LIST
71819: LIST
71820: ST_TO_ADDR
71821: GO 71824
71823: POP
// if state > - 1 and state < 3 then
71824: LD_VAR 0 3
71828: PUSH
71829: LD_INT 1
71831: NEG
71832: GREATER
71833: IFFALSE 71845
71835: PUSH
71836: LD_VAR 0 3
71840: PUSH
71841: LD_INT 3
71843: LESS
71844: AND
71845: IFFALSE 71902
// for i in result do
71847: LD_ADDR_VAR 0 5
71851: PUSH
71852: LD_VAR 0 4
71856: PUSH
71857: FOR_IN
71858: IFFALSE 71900
// if GetTech ( i , side ) <> state then
71860: LD_VAR 0 5
71864: PPUSH
71865: LD_VAR 0 1
71869: PPUSH
71870: CALL_OW 321
71874: PUSH
71875: LD_VAR 0 3
71879: NONEQUAL
71880: IFFALSE 71898
// result := result diff i ;
71882: LD_ADDR_VAR 0 4
71886: PUSH
71887: LD_VAR 0 4
71891: PUSH
71892: LD_VAR 0 5
71896: DIFF
71897: ST_TO_ADDR
71898: GO 71857
71900: POP
71901: POP
// end ;
71902: LD_VAR 0 4
71906: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
71907: LD_INT 0
71909: PPUSH
71910: PPUSH
71911: PPUSH
// result := true ;
71912: LD_ADDR_VAR 0 3
71916: PUSH
71917: LD_INT 1
71919: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
71920: LD_ADDR_VAR 0 5
71924: PUSH
71925: LD_VAR 0 2
71929: PPUSH
71930: CALL_OW 480
71934: ST_TO_ADDR
// if not tmp then
71935: LD_VAR 0 5
71939: NOT
71940: IFFALSE 71944
// exit ;
71942: GO 71993
// for i in tmp do
71944: LD_ADDR_VAR 0 4
71948: PUSH
71949: LD_VAR 0 5
71953: PUSH
71954: FOR_IN
71955: IFFALSE 71991
// if GetTech ( i , side ) <> state_researched then
71957: LD_VAR 0 4
71961: PPUSH
71962: LD_VAR 0 1
71966: PPUSH
71967: CALL_OW 321
71971: PUSH
71972: LD_INT 2
71974: NONEQUAL
71975: IFFALSE 71989
// begin result := false ;
71977: LD_ADDR_VAR 0 3
71981: PUSH
71982: LD_INT 0
71984: ST_TO_ADDR
// exit ;
71985: POP
71986: POP
71987: GO 71993
// end ;
71989: GO 71954
71991: POP
71992: POP
// end ;
71993: LD_VAR 0 3
71997: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
71998: LD_INT 0
72000: PPUSH
72001: PPUSH
72002: PPUSH
72003: PPUSH
72004: PPUSH
72005: PPUSH
72006: PPUSH
72007: PPUSH
72008: PPUSH
72009: PPUSH
72010: PPUSH
72011: PPUSH
72012: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
72013: LD_VAR 0 1
72017: NOT
72018: IFTRUE 72035
72020: PUSH
72021: LD_VAR 0 1
72025: PPUSH
72026: CALL_OW 257
72030: PUSH
72031: LD_INT 9
72033: NONEQUAL
72034: OR
72035: IFFALSE 72039
// exit ;
72037: GO 72618
// side := GetSide ( unit ) ;
72039: LD_ADDR_VAR 0 9
72043: PUSH
72044: LD_VAR 0 1
72048: PPUSH
72049: CALL_OW 255
72053: ST_TO_ADDR
// tech_space := tech_spacanom ;
72054: LD_ADDR_VAR 0 12
72058: PUSH
72059: LD_INT 29
72061: ST_TO_ADDR
// tech_time := tech_taurad ;
72062: LD_ADDR_VAR 0 13
72066: PUSH
72067: LD_INT 28
72069: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
72070: LD_ADDR_VAR 0 11
72074: PUSH
72075: LD_VAR 0 1
72079: PPUSH
72080: CALL_OW 310
72084: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
72085: LD_VAR 0 11
72089: PPUSH
72090: CALL_OW 247
72094: PUSH
72095: LD_INT 2
72097: EQUAL
72098: IFFALSE 72102
// exit ;
72100: GO 72618
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72102: LD_ADDR_VAR 0 8
72106: PUSH
72107: LD_INT 81
72109: PUSH
72110: LD_VAR 0 9
72114: PUSH
72115: EMPTY
72116: LIST
72117: LIST
72118: PUSH
72119: LD_INT 3
72121: PUSH
72122: LD_INT 21
72124: PUSH
72125: LD_INT 3
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PPUSH
72140: CALL_OW 69
72144: ST_TO_ADDR
// if not tmp then
72145: LD_VAR 0 8
72149: NOT
72150: IFFALSE 72154
// exit ;
72152: GO 72618
// if in_unit then
72154: LD_VAR 0 11
72158: IFFALSE 72182
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
72160: LD_ADDR_VAR 0 10
72164: PUSH
72165: LD_VAR 0 8
72169: PPUSH
72170: LD_VAR 0 11
72174: PPUSH
72175: CALL_OW 74
72179: ST_TO_ADDR
72180: GO 72202
// enemy := NearestUnitToUnit ( tmp , unit ) ;
72182: LD_ADDR_VAR 0 10
72186: PUSH
72187: LD_VAR 0 8
72191: PPUSH
72192: LD_VAR 0 1
72196: PPUSH
72197: CALL_OW 74
72201: ST_TO_ADDR
// if not enemy then
72202: LD_VAR 0 10
72206: NOT
72207: IFFALSE 72211
// exit ;
72209: GO 72618
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
72211: LD_VAR 0 11
72215: IFFALSE 72237
72217: PUSH
72218: LD_VAR 0 11
72222: PPUSH
72223: LD_VAR 0 10
72227: PPUSH
72228: CALL_OW 296
72232: PUSH
72233: LD_INT 13
72235: GREATER
72236: AND
72237: IFTRUE 72259
72239: PUSH
72240: LD_VAR 0 1
72244: PPUSH
72245: LD_VAR 0 10
72249: PPUSH
72250: CALL_OW 296
72254: PUSH
72255: LD_INT 12
72257: GREATER
72258: OR
72259: IFFALSE 72263
// exit ;
72261: GO 72618
// missile := [ 1 ] ;
72263: LD_ADDR_VAR 0 14
72267: PUSH
72268: LD_INT 1
72270: PUSH
72271: EMPTY
72272: LIST
72273: ST_TO_ADDR
// if Researched ( side , tech_space ) then
72274: LD_VAR 0 9
72278: PPUSH
72279: LD_VAR 0 12
72283: PPUSH
72284: CALL_OW 325
72288: IFFALSE 72317
// missile := Replace ( missile , missile + 1 , 2 ) ;
72290: LD_ADDR_VAR 0 14
72294: PUSH
72295: LD_VAR 0 14
72299: PPUSH
72300: LD_VAR 0 14
72304: PUSH
72305: LD_INT 1
72307: PLUS
72308: PPUSH
72309: LD_INT 2
72311: PPUSH
72312: CALL_OW 1
72316: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
72317: LD_VAR 0 9
72321: PPUSH
72322: LD_VAR 0 13
72326: PPUSH
72327: CALL_OW 325
72331: IFFALSE 72355
72333: PUSH
72334: LD_VAR 0 10
72338: PPUSH
72339: CALL_OW 255
72343: PPUSH
72344: LD_VAR 0 13
72348: PPUSH
72349: CALL_OW 325
72353: NOT
72354: AND
72355: IFFALSE 72384
// missile := Replace ( missile , missile + 1 , 3 ) ;
72357: LD_ADDR_VAR 0 14
72361: PUSH
72362: LD_VAR 0 14
72366: PPUSH
72367: LD_VAR 0 14
72371: PUSH
72372: LD_INT 1
72374: PLUS
72375: PPUSH
72376: LD_INT 3
72378: PPUSH
72379: CALL_OW 1
72383: ST_TO_ADDR
// if missile < 2 then
72384: LD_VAR 0 14
72388: PUSH
72389: LD_INT 2
72391: LESS
72392: IFFALSE 72396
// exit ;
72394: GO 72618
// x := GetX ( enemy ) ;
72396: LD_ADDR_VAR 0 4
72400: PUSH
72401: LD_VAR 0 10
72405: PPUSH
72406: CALL_OW 250
72410: ST_TO_ADDR
// y := GetY ( enemy ) ;
72411: LD_ADDR_VAR 0 5
72415: PUSH
72416: LD_VAR 0 10
72420: PPUSH
72421: CALL_OW 251
72425: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
72426: LD_ADDR_VAR 0 6
72430: PUSH
72431: LD_VAR 0 4
72435: PUSH
72436: LD_INT 1
72438: NEG
72439: PPUSH
72440: LD_INT 1
72442: PPUSH
72443: CALL_OW 12
72447: PLUS
72448: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
72449: LD_ADDR_VAR 0 7
72453: PUSH
72454: LD_VAR 0 5
72458: PUSH
72459: LD_INT 1
72461: NEG
72462: PPUSH
72463: LD_INT 1
72465: PPUSH
72466: CALL_OW 12
72470: PLUS
72471: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
72472: LD_VAR 0 6
72476: PPUSH
72477: LD_VAR 0 7
72481: PPUSH
72482: CALL_OW 488
72486: NOT
72487: IFFALSE 72509
// begin _x := x ;
72489: LD_ADDR_VAR 0 6
72493: PUSH
72494: LD_VAR 0 4
72498: ST_TO_ADDR
// _y := y ;
72499: LD_ADDR_VAR 0 7
72503: PUSH
72504: LD_VAR 0 5
72508: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
72509: LD_ADDR_VAR 0 3
72513: PUSH
72514: LD_INT 1
72516: PPUSH
72517: LD_VAR 0 14
72521: PPUSH
72522: CALL_OW 12
72526: ST_TO_ADDR
// case i of 1 :
72527: LD_VAR 0 3
72531: PUSH
72532: LD_INT 1
72534: DOUBLE
72535: EQUAL
72536: IFTRUE 72540
72538: GO 72557
72540: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
72541: LD_VAR 0 1
72545: PPUSH
72546: LD_VAR 0 10
72550: PPUSH
72551: CALL_OW 115
72555: GO 72618
72557: LD_INT 2
72559: DOUBLE
72560: EQUAL
72561: IFTRUE 72565
72563: GO 72587
72565: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
72566: LD_VAR 0 1
72570: PPUSH
72571: LD_VAR 0 6
72575: PPUSH
72576: LD_VAR 0 7
72580: PPUSH
72581: CALL_OW 153
72585: GO 72618
72587: LD_INT 3
72589: DOUBLE
72590: EQUAL
72591: IFTRUE 72595
72593: GO 72617
72595: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
72596: LD_VAR 0 1
72600: PPUSH
72601: LD_VAR 0 6
72605: PPUSH
72606: LD_VAR 0 7
72610: PPUSH
72611: CALL_OW 154
72615: GO 72618
72617: POP
// end ;
72618: LD_VAR 0 2
72622: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
72623: LD_INT 0
72625: PPUSH
72626: PPUSH
72627: PPUSH
72628: PPUSH
72629: PPUSH
72630: PPUSH
// if not unit or not building then
72631: LD_VAR 0 1
72635: NOT
72636: IFTRUE 72645
72638: PUSH
72639: LD_VAR 0 2
72643: NOT
72644: OR
72645: IFFALSE 72649
// exit ;
72647: GO 72807
// x := GetX ( building ) ;
72649: LD_ADDR_VAR 0 5
72653: PUSH
72654: LD_VAR 0 2
72658: PPUSH
72659: CALL_OW 250
72663: ST_TO_ADDR
// y := GetY ( building ) ;
72664: LD_ADDR_VAR 0 6
72668: PUSH
72669: LD_VAR 0 2
72673: PPUSH
72674: CALL_OW 251
72678: ST_TO_ADDR
// for i := 0 to 5 do
72679: LD_ADDR_VAR 0 4
72683: PUSH
72684: DOUBLE
72685: LD_INT 0
72687: DEC
72688: ST_TO_ADDR
72689: LD_INT 5
72691: PUSH
72692: FOR_TO
72693: IFFALSE 72805
// begin _x := ShiftX ( x , i , 3 ) ;
72695: LD_ADDR_VAR 0 7
72699: PUSH
72700: LD_VAR 0 5
72704: PPUSH
72705: LD_VAR 0 4
72709: PPUSH
72710: LD_INT 3
72712: PPUSH
72713: CALL_OW 272
72717: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
72718: LD_ADDR_VAR 0 8
72722: PUSH
72723: LD_VAR 0 6
72727: PPUSH
72728: LD_VAR 0 4
72732: PPUSH
72733: LD_INT 3
72735: PPUSH
72736: CALL_OW 273
72740: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
72741: LD_VAR 0 7
72745: PPUSH
72746: LD_VAR 0 8
72750: PPUSH
72751: CALL_OW 488
72755: NOT
72756: IFFALSE 72760
// continue ;
72758: GO 72692
// if HexInfo ( _x , _y ) = 0 then
72760: LD_VAR 0 7
72764: PPUSH
72765: LD_VAR 0 8
72769: PPUSH
72770: CALL_OW 428
72774: PUSH
72775: LD_INT 0
72777: EQUAL
72778: IFFALSE 72803
// begin ComMoveXY ( unit , _x , _y ) ;
72780: LD_VAR 0 1
72784: PPUSH
72785: LD_VAR 0 7
72789: PPUSH
72790: LD_VAR 0 8
72794: PPUSH
72795: CALL_OW 111
// exit ;
72799: POP
72800: POP
72801: GO 72807
// end ; end ;
72803: GO 72692
72805: POP
72806: POP
// end ;
72807: LD_VAR 0 3
72811: RET
// export function ScanBase ( side , base_area ) ; begin
72812: LD_INT 0
72814: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
72815: LD_ADDR_VAR 0 3
72819: PUSH
72820: LD_VAR 0 2
72824: PPUSH
72825: LD_INT 81
72827: PUSH
72828: LD_VAR 0 1
72832: PUSH
72833: EMPTY
72834: LIST
72835: LIST
72836: PPUSH
72837: CALL_OW 70
72841: ST_TO_ADDR
// end ;
72842: LD_VAR 0 3
72846: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
72847: LD_INT 0
72849: PPUSH
72850: PPUSH
72851: PPUSH
72852: PPUSH
// result := false ;
72853: LD_ADDR_VAR 0 2
72857: PUSH
72858: LD_INT 0
72860: ST_TO_ADDR
// side := GetSide ( unit ) ;
72861: LD_ADDR_VAR 0 3
72865: PUSH
72866: LD_VAR 0 1
72870: PPUSH
72871: CALL_OW 255
72875: ST_TO_ADDR
// nat := GetNation ( unit ) ;
72876: LD_ADDR_VAR 0 4
72880: PUSH
72881: LD_VAR 0 1
72885: PPUSH
72886: CALL_OW 248
72890: ST_TO_ADDR
// case nat of 1 :
72891: LD_VAR 0 4
72895: PUSH
72896: LD_INT 1
72898: DOUBLE
72899: EQUAL
72900: IFTRUE 72904
72902: GO 72915
72904: POP
// tech := tech_lassight ; 2 :
72905: LD_ADDR_VAR 0 5
72909: PUSH
72910: LD_INT 12
72912: ST_TO_ADDR
72913: GO 72954
72915: LD_INT 2
72917: DOUBLE
72918: EQUAL
72919: IFTRUE 72923
72921: GO 72934
72923: POP
// tech := tech_mortar ; 3 :
72924: LD_ADDR_VAR 0 5
72928: PUSH
72929: LD_INT 41
72931: ST_TO_ADDR
72932: GO 72954
72934: LD_INT 3
72936: DOUBLE
72937: EQUAL
72938: IFTRUE 72942
72940: GO 72953
72942: POP
// tech := tech_bazooka ; end ;
72943: LD_ADDR_VAR 0 5
72947: PUSH
72948: LD_INT 44
72950: ST_TO_ADDR
72951: GO 72954
72953: POP
// if Researched ( side , tech ) then
72954: LD_VAR 0 3
72958: PPUSH
72959: LD_VAR 0 5
72963: PPUSH
72964: CALL_OW 325
72968: IFFALSE 72995
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
72970: LD_ADDR_VAR 0 2
72974: PUSH
72975: LD_INT 5
72977: PUSH
72978: LD_INT 8
72980: PUSH
72981: LD_INT 9
72983: PUSH
72984: EMPTY
72985: LIST
72986: LIST
72987: LIST
72988: PUSH
72989: LD_VAR 0 4
72993: ARRAY
72994: ST_TO_ADDR
// end ;
72995: LD_VAR 0 2
72999: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
73000: LD_INT 0
73002: PPUSH
73003: PPUSH
73004: PPUSH
// if not mines then
73005: LD_VAR 0 2
73009: NOT
73010: IFFALSE 73014
// exit ;
73012: GO 73158
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73014: LD_ADDR_VAR 0 5
73018: PUSH
73019: LD_INT 81
73021: PUSH
73022: LD_VAR 0 1
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 3
73033: PUSH
73034: LD_INT 21
73036: PUSH
73037: LD_INT 3
73039: PUSH
73040: EMPTY
73041: LIST
73042: LIST
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PPUSH
73052: CALL_OW 69
73056: ST_TO_ADDR
// for i in mines do
73057: LD_ADDR_VAR 0 4
73061: PUSH
73062: LD_VAR 0 2
73066: PUSH
73067: FOR_IN
73068: IFFALSE 73156
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
73070: LD_VAR 0 4
73074: PUSH
73075: LD_INT 1
73077: ARRAY
73078: PPUSH
73079: LD_VAR 0 4
73083: PUSH
73084: LD_INT 2
73086: ARRAY
73087: PPUSH
73088: CALL_OW 458
73092: NOT
73093: IFFALSE 73097
// continue ;
73095: GO 73067
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
73097: LD_VAR 0 4
73101: PUSH
73102: LD_INT 1
73104: ARRAY
73105: PPUSH
73106: LD_VAR 0 4
73110: PUSH
73111: LD_INT 2
73113: ARRAY
73114: PPUSH
73115: CALL_OW 428
73119: PUSH
73120: LD_VAR 0 5
73124: IN
73125: IFFALSE 73154
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
73127: LD_VAR 0 4
73131: PUSH
73132: LD_INT 1
73134: ARRAY
73135: PPUSH
73136: LD_VAR 0 4
73140: PUSH
73141: LD_INT 2
73143: ARRAY
73144: PPUSH
73145: LD_VAR 0 1
73149: PPUSH
73150: CALL_OW 456
// end ;
73154: GO 73067
73156: POP
73157: POP
// end ;
73158: LD_VAR 0 3
73162: RET
// export function Count ( array ) ; begin
73163: LD_INT 0
73165: PPUSH
// result := array + 0 ;
73166: LD_ADDR_VAR 0 2
73170: PUSH
73171: LD_VAR 0 1
73175: PUSH
73176: LD_INT 0
73178: PLUS
73179: ST_TO_ADDR
// end ;
73180: LD_VAR 0 2
73184: RET
// export function IsEmpty ( building ) ; begin
73185: LD_INT 0
73187: PPUSH
// if not building then
73188: LD_VAR 0 1
73192: NOT
73193: IFFALSE 73197
// exit ;
73195: GO 73240
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
73197: LD_ADDR_VAR 0 2
73201: PUSH
73202: LD_VAR 0 1
73206: PUSH
73207: LD_INT 22
73209: PUSH
73210: LD_VAR 0 1
73214: PPUSH
73215: CALL_OW 255
73219: PUSH
73220: EMPTY
73221: LIST
73222: LIST
73223: PUSH
73224: LD_INT 58
73226: PUSH
73227: EMPTY
73228: LIST
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PPUSH
73234: CALL_OW 69
73238: IN
73239: ST_TO_ADDR
// end ;
73240: LD_VAR 0 2
73244: RET
// export function IsNotFull ( building ) ; var places ; begin
73245: LD_INT 0
73247: PPUSH
73248: PPUSH
// if not building then
73249: LD_VAR 0 1
73253: NOT
73254: IFFALSE 73258
// exit ;
73256: GO 73286
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
73258: LD_ADDR_VAR 0 2
73262: PUSH
73263: LD_VAR 0 1
73267: PPUSH
73268: LD_INT 3
73270: PUSH
73271: LD_INT 62
73273: PUSH
73274: EMPTY
73275: LIST
73276: PUSH
73277: EMPTY
73278: LIST
73279: LIST
73280: PPUSH
73281: CALL_OW 72
73285: ST_TO_ADDR
// end ;
73286: LD_VAR 0 2
73290: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
73291: LD_INT 0
73293: PPUSH
73294: PPUSH
73295: PPUSH
73296: PPUSH
// tmp := [ ] ;
73297: LD_ADDR_VAR 0 3
73301: PUSH
73302: EMPTY
73303: ST_TO_ADDR
// list := [ ] ;
73304: LD_ADDR_VAR 0 5
73308: PUSH
73309: EMPTY
73310: ST_TO_ADDR
// for i = 16 to 25 do
73311: LD_ADDR_VAR 0 4
73315: PUSH
73316: DOUBLE
73317: LD_INT 16
73319: DEC
73320: ST_TO_ADDR
73321: LD_INT 25
73323: PUSH
73324: FOR_TO
73325: IFFALSE 73398
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
73327: LD_ADDR_VAR 0 3
73331: PUSH
73332: LD_VAR 0 3
73336: PUSH
73337: LD_INT 22
73339: PUSH
73340: LD_VAR 0 1
73344: PPUSH
73345: CALL_OW 255
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 91
73356: PUSH
73357: LD_VAR 0 1
73361: PUSH
73362: LD_INT 6
73364: PUSH
73365: EMPTY
73366: LIST
73367: LIST
73368: LIST
73369: PUSH
73370: LD_INT 30
73372: PUSH
73373: LD_VAR 0 4
73377: PUSH
73378: EMPTY
73379: LIST
73380: LIST
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: LIST
73386: PUSH
73387: EMPTY
73388: LIST
73389: PPUSH
73390: CALL_OW 69
73394: ADD
73395: ST_TO_ADDR
73396: GO 73324
73398: POP
73399: POP
// for i = 1 to tmp do
73400: LD_ADDR_VAR 0 4
73404: PUSH
73405: DOUBLE
73406: LD_INT 1
73408: DEC
73409: ST_TO_ADDR
73410: LD_VAR 0 3
73414: PUSH
73415: FOR_TO
73416: IFFALSE 73504
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
73418: LD_ADDR_VAR 0 5
73422: PUSH
73423: LD_VAR 0 5
73427: PUSH
73428: LD_VAR 0 3
73432: PUSH
73433: LD_VAR 0 4
73437: ARRAY
73438: PPUSH
73439: CALL_OW 266
73443: PUSH
73444: LD_VAR 0 3
73448: PUSH
73449: LD_VAR 0 4
73453: ARRAY
73454: PPUSH
73455: CALL_OW 250
73459: PUSH
73460: LD_VAR 0 3
73464: PUSH
73465: LD_VAR 0 4
73469: ARRAY
73470: PPUSH
73471: CALL_OW 251
73475: PUSH
73476: LD_VAR 0 3
73480: PUSH
73481: LD_VAR 0 4
73485: ARRAY
73486: PPUSH
73487: CALL_OW 254
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: LIST
73496: LIST
73497: PUSH
73498: EMPTY
73499: LIST
73500: ADD
73501: ST_TO_ADDR
73502: GO 73415
73504: POP
73505: POP
// result := list ;
73506: LD_ADDR_VAR 0 2
73510: PUSH
73511: LD_VAR 0 5
73515: ST_TO_ADDR
// end ;
73516: LD_VAR 0 2
73520: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
73521: LD_INT 0
73523: PPUSH
73524: PPUSH
73525: PPUSH
73526: PPUSH
73527: PPUSH
73528: PPUSH
73529: PPUSH
// if not factory then
73530: LD_VAR 0 1
73534: NOT
73535: IFFALSE 73539
// exit ;
73537: GO 74142
// if control = control_apeman then
73539: LD_VAR 0 4
73543: PUSH
73544: LD_INT 5
73546: EQUAL
73547: IFFALSE 73656
// begin tmp := UnitsInside ( factory ) ;
73549: LD_ADDR_VAR 0 8
73553: PUSH
73554: LD_VAR 0 1
73558: PPUSH
73559: CALL_OW 313
73563: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
73564: LD_VAR 0 8
73568: PPUSH
73569: LD_INT 25
73571: PUSH
73572: LD_INT 12
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PPUSH
73579: CALL_OW 72
73583: NOT
73584: IFFALSE 73594
// control := control_manual ;
73586: LD_ADDR_VAR 0 4
73590: PUSH
73591: LD_INT 1
73593: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
73594: LD_ADDR_VAR 0 8
73598: PUSH
73599: LD_VAR 0 1
73603: PPUSH
73604: CALL 73291 0 1
73608: ST_TO_ADDR
// if tmp then
73609: LD_VAR 0 8
73613: IFFALSE 73656
// begin for i in tmp do
73615: LD_ADDR_VAR 0 7
73619: PUSH
73620: LD_VAR 0 8
73624: PUSH
73625: FOR_IN
73626: IFFALSE 73654
// if i [ 1 ] = b_ext_radio then
73628: LD_VAR 0 7
73632: PUSH
73633: LD_INT 1
73635: ARRAY
73636: PUSH
73637: LD_INT 22
73639: EQUAL
73640: IFFALSE 73652
// begin control := control_remote ;
73642: LD_ADDR_VAR 0 4
73646: PUSH
73647: LD_INT 2
73649: ST_TO_ADDR
// break ;
73650: GO 73654
// end ;
73652: GO 73625
73654: POP
73655: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
73656: LD_VAR 0 1
73660: PPUSH
73661: LD_VAR 0 2
73665: PPUSH
73666: LD_VAR 0 3
73670: PPUSH
73671: LD_VAR 0 4
73675: PPUSH
73676: LD_VAR 0 5
73680: PPUSH
73681: CALL_OW 448
73685: IFFALSE 73720
// begin result := [ chassis , engine , control , weapon ] ;
73687: LD_ADDR_VAR 0 6
73691: PUSH
73692: LD_VAR 0 2
73696: PUSH
73697: LD_VAR 0 3
73701: PUSH
73702: LD_VAR 0 4
73706: PUSH
73707: LD_VAR 0 5
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: LIST
73716: LIST
73717: ST_TO_ADDR
// exit ;
73718: GO 74142
// end ; _chassis := AvailableChassisList ( factory ) ;
73720: LD_ADDR_VAR 0 9
73724: PUSH
73725: LD_VAR 0 1
73729: PPUSH
73730: CALL_OW 475
73734: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
73735: LD_ADDR_VAR 0 11
73739: PUSH
73740: LD_VAR 0 1
73744: PPUSH
73745: CALL_OW 476
73749: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
73750: LD_ADDR_VAR 0 12
73754: PUSH
73755: LD_VAR 0 1
73759: PPUSH
73760: CALL_OW 477
73764: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
73765: LD_ADDR_VAR 0 10
73769: PUSH
73770: LD_VAR 0 1
73774: PPUSH
73775: CALL_OW 478
73779: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
73780: LD_VAR 0 9
73784: NOT
73785: IFTRUE 73794
73787: PUSH
73788: LD_VAR 0 11
73792: NOT
73793: OR
73794: IFTRUE 73803
73796: PUSH
73797: LD_VAR 0 12
73801: NOT
73802: OR
73803: IFTRUE 73812
73805: PUSH
73806: LD_VAR 0 10
73810: NOT
73811: OR
73812: IFFALSE 73847
// begin result := [ chassis , engine , control , weapon ] ;
73814: LD_ADDR_VAR 0 6
73818: PUSH
73819: LD_VAR 0 2
73823: PUSH
73824: LD_VAR 0 3
73828: PUSH
73829: LD_VAR 0 4
73833: PUSH
73834: LD_VAR 0 5
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: ST_TO_ADDR
// exit ;
73845: GO 74142
// end ; if not chassis in _chassis then
73847: LD_VAR 0 2
73851: PUSH
73852: LD_VAR 0 9
73856: IN
73857: NOT
73858: IFFALSE 73884
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
73860: LD_ADDR_VAR 0 2
73864: PUSH
73865: LD_VAR 0 9
73869: PUSH
73870: LD_INT 1
73872: PPUSH
73873: LD_VAR 0 9
73877: PPUSH
73878: CALL_OW 12
73882: ARRAY
73883: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
73884: LD_VAR 0 2
73888: PPUSH
73889: LD_VAR 0 3
73893: PPUSH
73894: CALL 74147 0 2
73898: NOT
73899: IFFALSE 73960
// repeat engine := _engine [ 1 ] ;
73901: LD_ADDR_VAR 0 3
73905: PUSH
73906: LD_VAR 0 11
73910: PUSH
73911: LD_INT 1
73913: ARRAY
73914: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
73915: LD_ADDR_VAR 0 11
73919: PUSH
73920: LD_VAR 0 11
73924: PPUSH
73925: LD_INT 1
73927: PPUSH
73928: CALL_OW 3
73932: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
73933: LD_VAR 0 2
73937: PPUSH
73938: LD_VAR 0 3
73942: PPUSH
73943: CALL 74147 0 2
73947: IFTRUE 73958
73949: PUSH
73950: LD_VAR 0 11
73954: PUSH
73955: EMPTY
73956: EQUAL
73957: OR
73958: IFFALSE 73901
// if not control in _control then
73960: LD_VAR 0 4
73964: PUSH
73965: LD_VAR 0 12
73969: IN
73970: NOT
73971: IFFALSE 73997
// control := _control [ rand ( 1 , _control ) ] ;
73973: LD_ADDR_VAR 0 4
73977: PUSH
73978: LD_VAR 0 12
73982: PUSH
73983: LD_INT 1
73985: PPUSH
73986: LD_VAR 0 12
73990: PPUSH
73991: CALL_OW 12
73995: ARRAY
73996: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
73997: LD_VAR 0 2
74001: PPUSH
74002: LD_VAR 0 5
74006: PPUSH
74007: CALL 74369 0 2
74011: NOT
74012: IFFALSE 74073
// repeat weapon := _weapon [ 1 ] ;
74014: LD_ADDR_VAR 0 5
74018: PUSH
74019: LD_VAR 0 10
74023: PUSH
74024: LD_INT 1
74026: ARRAY
74027: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
74028: LD_ADDR_VAR 0 10
74032: PUSH
74033: LD_VAR 0 10
74037: PPUSH
74038: LD_INT 1
74040: PPUSH
74041: CALL_OW 3
74045: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
74046: LD_VAR 0 2
74050: PPUSH
74051: LD_VAR 0 5
74055: PPUSH
74056: CALL 74369 0 2
74060: IFTRUE 74071
74062: PUSH
74063: LD_VAR 0 10
74067: PUSH
74068: EMPTY
74069: EQUAL
74070: OR
74071: IFFALSE 74014
// result := [ ] ;
74073: LD_ADDR_VAR 0 6
74077: PUSH
74078: EMPTY
74079: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
74080: LD_VAR 0 1
74084: PPUSH
74085: LD_VAR 0 2
74089: PPUSH
74090: LD_VAR 0 3
74094: PPUSH
74095: LD_VAR 0 4
74099: PPUSH
74100: LD_VAR 0 5
74104: PPUSH
74105: CALL_OW 448
74109: IFFALSE 74142
// result := [ chassis , engine , control , weapon ] ;
74111: LD_ADDR_VAR 0 6
74115: PUSH
74116: LD_VAR 0 2
74120: PUSH
74121: LD_VAR 0 3
74125: PUSH
74126: LD_VAR 0 4
74130: PUSH
74131: LD_VAR 0 5
74135: PUSH
74136: EMPTY
74137: LIST
74138: LIST
74139: LIST
74140: LIST
74141: ST_TO_ADDR
// end ;
74142: LD_VAR 0 6
74146: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
74147: LD_INT 0
74149: PPUSH
// if not chassis or not engine then
74150: LD_VAR 0 1
74154: NOT
74155: IFTRUE 74164
74157: PUSH
74158: LD_VAR 0 2
74162: NOT
74163: OR
74164: IFFALSE 74168
// exit ;
74166: GO 74364
// case engine of engine_solar :
74168: LD_VAR 0 2
74172: PUSH
74173: LD_INT 2
74175: DOUBLE
74176: EQUAL
74177: IFTRUE 74181
74179: GO 74219
74181: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
74182: LD_ADDR_VAR 0 3
74186: PUSH
74187: LD_INT 11
74189: PUSH
74190: LD_INT 12
74192: PUSH
74193: LD_INT 13
74195: PUSH
74196: LD_INT 14
74198: PUSH
74199: LD_INT 1
74201: PUSH
74202: LD_INT 2
74204: PUSH
74205: LD_INT 3
74207: PUSH
74208: EMPTY
74209: LIST
74210: LIST
74211: LIST
74212: LIST
74213: LIST
74214: LIST
74215: LIST
74216: ST_TO_ADDR
74217: GO 74348
74219: LD_INT 1
74221: DOUBLE
74222: EQUAL
74223: IFTRUE 74227
74225: GO 74289
74227: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
74228: LD_ADDR_VAR 0 3
74232: PUSH
74233: LD_INT 11
74235: PUSH
74236: LD_INT 12
74238: PUSH
74239: LD_INT 13
74241: PUSH
74242: LD_INT 14
74244: PUSH
74245: LD_INT 1
74247: PUSH
74248: LD_INT 2
74250: PUSH
74251: LD_INT 3
74253: PUSH
74254: LD_INT 4
74256: PUSH
74257: LD_INT 5
74259: PUSH
74260: LD_INT 21
74262: PUSH
74263: LD_INT 23
74265: PUSH
74266: LD_INT 22
74268: PUSH
74269: LD_INT 24
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: LIST
74276: LIST
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: LIST
74284: LIST
74285: LIST
74286: ST_TO_ADDR
74287: GO 74348
74289: LD_INT 3
74291: DOUBLE
74292: EQUAL
74293: IFTRUE 74297
74295: GO 74347
74297: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
74298: LD_ADDR_VAR 0 3
74302: PUSH
74303: LD_INT 13
74305: PUSH
74306: LD_INT 14
74308: PUSH
74309: LD_INT 2
74311: PUSH
74312: LD_INT 3
74314: PUSH
74315: LD_INT 4
74317: PUSH
74318: LD_INT 5
74320: PUSH
74321: LD_INT 21
74323: PUSH
74324: LD_INT 22
74326: PUSH
74327: LD_INT 23
74329: PUSH
74330: LD_INT 24
74332: PUSH
74333: EMPTY
74334: LIST
74335: LIST
74336: LIST
74337: LIST
74338: LIST
74339: LIST
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: ST_TO_ADDR
74345: GO 74348
74347: POP
// result := ( chassis in result ) ;
74348: LD_ADDR_VAR 0 3
74352: PUSH
74353: LD_VAR 0 1
74357: PUSH
74358: LD_VAR 0 3
74362: IN
74363: ST_TO_ADDR
// end ;
74364: LD_VAR 0 3
74368: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
74369: LD_INT 0
74371: PPUSH
// if not chassis or not weapon then
74372: LD_VAR 0 1
74376: NOT
74377: IFTRUE 74386
74379: PUSH
74380: LD_VAR 0 2
74384: NOT
74385: OR
74386: IFFALSE 74390
// exit ;
74388: GO 75484
// case weapon of us_machine_gun :
74390: LD_VAR 0 2
74394: PUSH
74395: LD_INT 2
74397: DOUBLE
74398: EQUAL
74399: IFTRUE 74403
74401: GO 74433
74403: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
74404: LD_ADDR_VAR 0 3
74408: PUSH
74409: LD_INT 1
74411: PUSH
74412: LD_INT 2
74414: PUSH
74415: LD_INT 3
74417: PUSH
74418: LD_INT 4
74420: PUSH
74421: LD_INT 5
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: LIST
74428: LIST
74429: LIST
74430: ST_TO_ADDR
74431: GO 75468
74433: LD_INT 3
74435: DOUBLE
74436: EQUAL
74437: IFTRUE 74441
74439: GO 74471
74441: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
74442: LD_ADDR_VAR 0 3
74446: PUSH
74447: LD_INT 1
74449: PUSH
74450: LD_INT 2
74452: PUSH
74453: LD_INT 3
74455: PUSH
74456: LD_INT 4
74458: PUSH
74459: LD_INT 5
74461: PUSH
74462: EMPTY
74463: LIST
74464: LIST
74465: LIST
74466: LIST
74467: LIST
74468: ST_TO_ADDR
74469: GO 75468
74471: LD_INT 11
74473: DOUBLE
74474: EQUAL
74475: IFTRUE 74479
74477: GO 74509
74479: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
74480: LD_ADDR_VAR 0 3
74484: PUSH
74485: LD_INT 1
74487: PUSH
74488: LD_INT 2
74490: PUSH
74491: LD_INT 3
74493: PUSH
74494: LD_INT 4
74496: PUSH
74497: LD_INT 5
74499: PUSH
74500: EMPTY
74501: LIST
74502: LIST
74503: LIST
74504: LIST
74505: LIST
74506: ST_TO_ADDR
74507: GO 75468
74509: LD_INT 4
74511: DOUBLE
74512: EQUAL
74513: IFTRUE 74517
74515: GO 74543
74517: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
74518: LD_ADDR_VAR 0 3
74522: PUSH
74523: LD_INT 2
74525: PUSH
74526: LD_INT 3
74528: PUSH
74529: LD_INT 4
74531: PUSH
74532: LD_INT 5
74534: PUSH
74535: EMPTY
74536: LIST
74537: LIST
74538: LIST
74539: LIST
74540: ST_TO_ADDR
74541: GO 75468
74543: LD_INT 5
74545: DOUBLE
74546: EQUAL
74547: IFTRUE 74551
74549: GO 74577
74551: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
74552: LD_ADDR_VAR 0 3
74556: PUSH
74557: LD_INT 2
74559: PUSH
74560: LD_INT 3
74562: PUSH
74563: LD_INT 4
74565: PUSH
74566: LD_INT 5
74568: PUSH
74569: EMPTY
74570: LIST
74571: LIST
74572: LIST
74573: LIST
74574: ST_TO_ADDR
74575: GO 75468
74577: LD_INT 9
74579: DOUBLE
74580: EQUAL
74581: IFTRUE 74585
74583: GO 74611
74585: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
74586: LD_ADDR_VAR 0 3
74590: PUSH
74591: LD_INT 2
74593: PUSH
74594: LD_INT 3
74596: PUSH
74597: LD_INT 4
74599: PUSH
74600: LD_INT 5
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: LIST
74607: LIST
74608: ST_TO_ADDR
74609: GO 75468
74611: LD_INT 7
74613: DOUBLE
74614: EQUAL
74615: IFTRUE 74619
74617: GO 74645
74619: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
74620: LD_ADDR_VAR 0 3
74624: PUSH
74625: LD_INT 2
74627: PUSH
74628: LD_INT 3
74630: PUSH
74631: LD_INT 4
74633: PUSH
74634: LD_INT 5
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: LIST
74641: LIST
74642: ST_TO_ADDR
74643: GO 75468
74645: LD_INT 12
74647: DOUBLE
74648: EQUAL
74649: IFTRUE 74653
74651: GO 74679
74653: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
74654: LD_ADDR_VAR 0 3
74658: PUSH
74659: LD_INT 2
74661: PUSH
74662: LD_INT 3
74664: PUSH
74665: LD_INT 4
74667: PUSH
74668: LD_INT 5
74670: PUSH
74671: EMPTY
74672: LIST
74673: LIST
74674: LIST
74675: LIST
74676: ST_TO_ADDR
74677: GO 75468
74679: LD_INT 13
74681: DOUBLE
74682: EQUAL
74683: IFTRUE 74687
74685: GO 74713
74687: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
74688: LD_ADDR_VAR 0 3
74692: PUSH
74693: LD_INT 2
74695: PUSH
74696: LD_INT 3
74698: PUSH
74699: LD_INT 4
74701: PUSH
74702: LD_INT 5
74704: PUSH
74705: EMPTY
74706: LIST
74707: LIST
74708: LIST
74709: LIST
74710: ST_TO_ADDR
74711: GO 75468
74713: LD_INT 14
74715: DOUBLE
74716: EQUAL
74717: IFTRUE 74721
74719: GO 74739
74721: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
74722: LD_ADDR_VAR 0 3
74726: PUSH
74727: LD_INT 4
74729: PUSH
74730: LD_INT 5
74732: PUSH
74733: EMPTY
74734: LIST
74735: LIST
74736: ST_TO_ADDR
74737: GO 75468
74739: LD_INT 6
74741: DOUBLE
74742: EQUAL
74743: IFTRUE 74747
74745: GO 74765
74747: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
74748: LD_ADDR_VAR 0 3
74752: PUSH
74753: LD_INT 4
74755: PUSH
74756: LD_INT 5
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: ST_TO_ADDR
74763: GO 75468
74765: LD_INT 10
74767: DOUBLE
74768: EQUAL
74769: IFTRUE 74773
74771: GO 74791
74773: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
74774: LD_ADDR_VAR 0 3
74778: PUSH
74779: LD_INT 4
74781: PUSH
74782: LD_INT 5
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: ST_TO_ADDR
74789: GO 75468
74791: LD_INT 22
74793: DOUBLE
74794: EQUAL
74795: IFTRUE 74799
74797: GO 74825
74799: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
74800: LD_ADDR_VAR 0 3
74804: PUSH
74805: LD_INT 11
74807: PUSH
74808: LD_INT 12
74810: PUSH
74811: LD_INT 13
74813: PUSH
74814: LD_INT 14
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: LIST
74821: LIST
74822: ST_TO_ADDR
74823: GO 75468
74825: LD_INT 23
74827: DOUBLE
74828: EQUAL
74829: IFTRUE 74833
74831: GO 74859
74833: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
74834: LD_ADDR_VAR 0 3
74838: PUSH
74839: LD_INT 11
74841: PUSH
74842: LD_INT 12
74844: PUSH
74845: LD_INT 13
74847: PUSH
74848: LD_INT 14
74850: PUSH
74851: EMPTY
74852: LIST
74853: LIST
74854: LIST
74855: LIST
74856: ST_TO_ADDR
74857: GO 75468
74859: LD_INT 24
74861: DOUBLE
74862: EQUAL
74863: IFTRUE 74867
74865: GO 74893
74867: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
74868: LD_ADDR_VAR 0 3
74872: PUSH
74873: LD_INT 11
74875: PUSH
74876: LD_INT 12
74878: PUSH
74879: LD_INT 13
74881: PUSH
74882: LD_INT 14
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: LIST
74889: LIST
74890: ST_TO_ADDR
74891: GO 75468
74893: LD_INT 30
74895: DOUBLE
74896: EQUAL
74897: IFTRUE 74901
74899: GO 74927
74901: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
74902: LD_ADDR_VAR 0 3
74906: PUSH
74907: LD_INT 11
74909: PUSH
74910: LD_INT 12
74912: PUSH
74913: LD_INT 13
74915: PUSH
74916: LD_INT 14
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: LIST
74923: LIST
74924: ST_TO_ADDR
74925: GO 75468
74927: LD_INT 25
74929: DOUBLE
74930: EQUAL
74931: IFTRUE 74935
74933: GO 74953
74935: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
74936: LD_ADDR_VAR 0 3
74940: PUSH
74941: LD_INT 13
74943: PUSH
74944: LD_INT 14
74946: PUSH
74947: EMPTY
74948: LIST
74949: LIST
74950: ST_TO_ADDR
74951: GO 75468
74953: LD_INT 27
74955: DOUBLE
74956: EQUAL
74957: IFTRUE 74961
74959: GO 74979
74961: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
74962: LD_ADDR_VAR 0 3
74966: PUSH
74967: LD_INT 13
74969: PUSH
74970: LD_INT 14
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: ST_TO_ADDR
74977: GO 75468
74979: LD_INT 92
74981: DOUBLE
74982: EQUAL
74983: IFTRUE 74987
74985: GO 75013
74987: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
74988: LD_ADDR_VAR 0 3
74992: PUSH
74993: LD_INT 11
74995: PUSH
74996: LD_INT 12
74998: PUSH
74999: LD_INT 13
75001: PUSH
75002: LD_INT 14
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: LIST
75009: LIST
75010: ST_TO_ADDR
75011: GO 75468
75013: LD_INT 28
75015: DOUBLE
75016: EQUAL
75017: IFTRUE 75021
75019: GO 75039
75021: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
75022: LD_ADDR_VAR 0 3
75026: PUSH
75027: LD_INT 13
75029: PUSH
75030: LD_INT 14
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: ST_TO_ADDR
75037: GO 75468
75039: LD_INT 29
75041: DOUBLE
75042: EQUAL
75043: IFTRUE 75047
75045: GO 75065
75047: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
75048: LD_ADDR_VAR 0 3
75052: PUSH
75053: LD_INT 13
75055: PUSH
75056: LD_INT 14
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: ST_TO_ADDR
75063: GO 75468
75065: LD_INT 31
75067: DOUBLE
75068: EQUAL
75069: IFTRUE 75073
75071: GO 75091
75073: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
75074: LD_ADDR_VAR 0 3
75078: PUSH
75079: LD_INT 13
75081: PUSH
75082: LD_INT 14
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: ST_TO_ADDR
75089: GO 75468
75091: LD_INT 26
75093: DOUBLE
75094: EQUAL
75095: IFTRUE 75099
75097: GO 75117
75099: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
75100: LD_ADDR_VAR 0 3
75104: PUSH
75105: LD_INT 13
75107: PUSH
75108: LD_INT 14
75110: PUSH
75111: EMPTY
75112: LIST
75113: LIST
75114: ST_TO_ADDR
75115: GO 75468
75117: LD_INT 42
75119: DOUBLE
75120: EQUAL
75121: IFTRUE 75125
75123: GO 75151
75125: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
75126: LD_ADDR_VAR 0 3
75130: PUSH
75131: LD_INT 21
75133: PUSH
75134: LD_INT 22
75136: PUSH
75137: LD_INT 23
75139: PUSH
75140: LD_INT 24
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: LIST
75147: LIST
75148: ST_TO_ADDR
75149: GO 75468
75151: LD_INT 43
75153: DOUBLE
75154: EQUAL
75155: IFTRUE 75159
75157: GO 75185
75159: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
75160: LD_ADDR_VAR 0 3
75164: PUSH
75165: LD_INT 21
75167: PUSH
75168: LD_INT 22
75170: PUSH
75171: LD_INT 23
75173: PUSH
75174: LD_INT 24
75176: PUSH
75177: EMPTY
75178: LIST
75179: LIST
75180: LIST
75181: LIST
75182: ST_TO_ADDR
75183: GO 75468
75185: LD_INT 44
75187: DOUBLE
75188: EQUAL
75189: IFTRUE 75193
75191: GO 75219
75193: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
75194: LD_ADDR_VAR 0 3
75198: PUSH
75199: LD_INT 21
75201: PUSH
75202: LD_INT 22
75204: PUSH
75205: LD_INT 23
75207: PUSH
75208: LD_INT 24
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: LIST
75215: LIST
75216: ST_TO_ADDR
75217: GO 75468
75219: LD_INT 45
75221: DOUBLE
75222: EQUAL
75223: IFTRUE 75227
75225: GO 75253
75227: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
75228: LD_ADDR_VAR 0 3
75232: PUSH
75233: LD_INT 21
75235: PUSH
75236: LD_INT 22
75238: PUSH
75239: LD_INT 23
75241: PUSH
75242: LD_INT 24
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: LIST
75249: LIST
75250: ST_TO_ADDR
75251: GO 75468
75253: LD_INT 49
75255: DOUBLE
75256: EQUAL
75257: IFTRUE 75261
75259: GO 75287
75261: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
75262: LD_ADDR_VAR 0 3
75266: PUSH
75267: LD_INT 21
75269: PUSH
75270: LD_INT 22
75272: PUSH
75273: LD_INT 23
75275: PUSH
75276: LD_INT 24
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: LIST
75283: LIST
75284: ST_TO_ADDR
75285: GO 75468
75287: LD_INT 51
75289: DOUBLE
75290: EQUAL
75291: IFTRUE 75295
75293: GO 75321
75295: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
75296: LD_ADDR_VAR 0 3
75300: PUSH
75301: LD_INT 21
75303: PUSH
75304: LD_INT 22
75306: PUSH
75307: LD_INT 23
75309: PUSH
75310: LD_INT 24
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: LIST
75317: LIST
75318: ST_TO_ADDR
75319: GO 75468
75321: LD_INT 52
75323: DOUBLE
75324: EQUAL
75325: IFTRUE 75329
75327: GO 75355
75329: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
75330: LD_ADDR_VAR 0 3
75334: PUSH
75335: LD_INT 21
75337: PUSH
75338: LD_INT 22
75340: PUSH
75341: LD_INT 23
75343: PUSH
75344: LD_INT 24
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: LIST
75351: LIST
75352: ST_TO_ADDR
75353: GO 75468
75355: LD_INT 53
75357: DOUBLE
75358: EQUAL
75359: IFTRUE 75363
75361: GO 75381
75363: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
75364: LD_ADDR_VAR 0 3
75368: PUSH
75369: LD_INT 23
75371: PUSH
75372: LD_INT 24
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: ST_TO_ADDR
75379: GO 75468
75381: LD_INT 46
75383: DOUBLE
75384: EQUAL
75385: IFTRUE 75389
75387: GO 75407
75389: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
75390: LD_ADDR_VAR 0 3
75394: PUSH
75395: LD_INT 23
75397: PUSH
75398: LD_INT 24
75400: PUSH
75401: EMPTY
75402: LIST
75403: LIST
75404: ST_TO_ADDR
75405: GO 75468
75407: LD_INT 47
75409: DOUBLE
75410: EQUAL
75411: IFTRUE 75415
75413: GO 75433
75415: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_radar :
75416: LD_ADDR_VAR 0 3
75420: PUSH
75421: LD_INT 23
75423: PUSH
75424: LD_INT 24
75426: PUSH
75427: EMPTY
75428: LIST
75429: LIST
75430: ST_TO_ADDR
75431: GO 75468
75433: LD_INT 98
75435: DOUBLE
75436: EQUAL
75437: IFTRUE 75441
75439: GO 75467
75441: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
75442: LD_ADDR_VAR 0 3
75446: PUSH
75447: LD_INT 21
75449: PUSH
75450: LD_INT 22
75452: PUSH
75453: LD_INT 23
75455: PUSH
75456: LD_INT 24
75458: PUSH
75459: EMPTY
75460: LIST
75461: LIST
75462: LIST
75463: LIST
75464: ST_TO_ADDR
75465: GO 75468
75467: POP
// result := ( chassis in result ) ;
75468: LD_ADDR_VAR 0 3
75472: PUSH
75473: LD_VAR 0 1
75477: PUSH
75478: LD_VAR 0 3
75482: IN
75483: ST_TO_ADDR
// end ;
75484: LD_VAR 0 3
75488: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
75489: LD_INT 0
75491: PPUSH
75492: PPUSH
75493: PPUSH
75494: PPUSH
75495: PPUSH
75496: PPUSH
75497: PPUSH
// result := array ;
75498: LD_ADDR_VAR 0 5
75502: PUSH
75503: LD_VAR 0 1
75507: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
75508: LD_VAR 0 1
75512: NOT
75513: IFTRUE 75522
75515: PUSH
75516: LD_VAR 0 2
75520: NOT
75521: OR
75522: IFTRUE 75531
75524: PUSH
75525: LD_VAR 0 3
75529: NOT
75530: OR
75531: IFTRUE 75545
75533: PUSH
75534: LD_VAR 0 2
75538: PUSH
75539: LD_VAR 0 1
75543: GREATER
75544: OR
75545: IFTRUE 75559
75547: PUSH
75548: LD_VAR 0 3
75552: PUSH
75553: LD_VAR 0 1
75557: GREATER
75558: OR
75559: IFFALSE 75563
// exit ;
75561: GO 75859
// if direction then
75563: LD_VAR 0 4
75567: IFFALSE 75631
// begin d := 1 ;
75569: LD_ADDR_VAR 0 9
75573: PUSH
75574: LD_INT 1
75576: ST_TO_ADDR
// if i_from > i_to then
75577: LD_VAR 0 2
75581: PUSH
75582: LD_VAR 0 3
75586: GREATER
75587: IFFALSE 75613
// length := ( array - i_from ) + i_to else
75589: LD_ADDR_VAR 0 11
75593: PUSH
75594: LD_VAR 0 1
75598: PUSH
75599: LD_VAR 0 2
75603: MINUS
75604: PUSH
75605: LD_VAR 0 3
75609: PLUS
75610: ST_TO_ADDR
75611: GO 75629
// length := i_to - i_from ;
75613: LD_ADDR_VAR 0 11
75617: PUSH
75618: LD_VAR 0 3
75622: PUSH
75623: LD_VAR 0 2
75627: MINUS
75628: ST_TO_ADDR
// end else
75629: GO 75692
// begin d := - 1 ;
75631: LD_ADDR_VAR 0 9
75635: PUSH
75636: LD_INT 1
75638: NEG
75639: ST_TO_ADDR
// if i_from > i_to then
75640: LD_VAR 0 2
75644: PUSH
75645: LD_VAR 0 3
75649: GREATER
75650: IFFALSE 75670
// length := i_from - i_to else
75652: LD_ADDR_VAR 0 11
75656: PUSH
75657: LD_VAR 0 2
75661: PUSH
75662: LD_VAR 0 3
75666: MINUS
75667: ST_TO_ADDR
75668: GO 75692
// length := ( array - i_to ) + i_from ;
75670: LD_ADDR_VAR 0 11
75674: PUSH
75675: LD_VAR 0 1
75679: PUSH
75680: LD_VAR 0 3
75684: MINUS
75685: PUSH
75686: LD_VAR 0 2
75690: PLUS
75691: ST_TO_ADDR
// end ; if not length then
75692: LD_VAR 0 11
75696: NOT
75697: IFFALSE 75701
// exit ;
75699: GO 75859
// tmp := array ;
75701: LD_ADDR_VAR 0 10
75705: PUSH
75706: LD_VAR 0 1
75710: ST_TO_ADDR
// for i = 1 to length do
75711: LD_ADDR_VAR 0 6
75715: PUSH
75716: DOUBLE
75717: LD_INT 1
75719: DEC
75720: ST_TO_ADDR
75721: LD_VAR 0 11
75725: PUSH
75726: FOR_TO
75727: IFFALSE 75847
// begin for j = 1 to array do
75729: LD_ADDR_VAR 0 7
75733: PUSH
75734: DOUBLE
75735: LD_INT 1
75737: DEC
75738: ST_TO_ADDR
75739: LD_VAR 0 1
75743: PUSH
75744: FOR_TO
75745: IFFALSE 75833
// begin k := j + d ;
75747: LD_ADDR_VAR 0 8
75751: PUSH
75752: LD_VAR 0 7
75756: PUSH
75757: LD_VAR 0 9
75761: PLUS
75762: ST_TO_ADDR
// if k > array then
75763: LD_VAR 0 8
75767: PUSH
75768: LD_VAR 0 1
75772: GREATER
75773: IFFALSE 75783
// k := 1 ;
75775: LD_ADDR_VAR 0 8
75779: PUSH
75780: LD_INT 1
75782: ST_TO_ADDR
// if not k then
75783: LD_VAR 0 8
75787: NOT
75788: IFFALSE 75800
// k := array ;
75790: LD_ADDR_VAR 0 8
75794: PUSH
75795: LD_VAR 0 1
75799: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
75800: LD_ADDR_VAR 0 10
75804: PUSH
75805: LD_VAR 0 10
75809: PPUSH
75810: LD_VAR 0 8
75814: PPUSH
75815: LD_VAR 0 1
75819: PUSH
75820: LD_VAR 0 7
75824: ARRAY
75825: PPUSH
75826: CALL_OW 1
75830: ST_TO_ADDR
// end ;
75831: GO 75744
75833: POP
75834: POP
// array := tmp ;
75835: LD_ADDR_VAR 0 1
75839: PUSH
75840: LD_VAR 0 10
75844: ST_TO_ADDR
// end ;
75845: GO 75726
75847: POP
75848: POP
// result := array ;
75849: LD_ADDR_VAR 0 5
75853: PUSH
75854: LD_VAR 0 1
75858: ST_TO_ADDR
// end ;
75859: LD_VAR 0 5
75863: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
75864: LD_INT 0
75866: PPUSH
75867: PPUSH
// result := 0 ;
75868: LD_ADDR_VAR 0 3
75872: PUSH
75873: LD_INT 0
75875: ST_TO_ADDR
// if not array or not value in array then
75876: LD_VAR 0 1
75880: NOT
75881: IFTRUE 75896
75883: PUSH
75884: LD_VAR 0 2
75888: PUSH
75889: LD_VAR 0 1
75893: IN
75894: NOT
75895: OR
75896: IFFALSE 75900
// exit ;
75898: GO 75954
// for i = 1 to array do
75900: LD_ADDR_VAR 0 4
75904: PUSH
75905: DOUBLE
75906: LD_INT 1
75908: DEC
75909: ST_TO_ADDR
75910: LD_VAR 0 1
75914: PUSH
75915: FOR_TO
75916: IFFALSE 75952
// if value = array [ i ] then
75918: LD_VAR 0 2
75922: PUSH
75923: LD_VAR 0 1
75927: PUSH
75928: LD_VAR 0 4
75932: ARRAY
75933: EQUAL
75934: IFFALSE 75950
// begin result := i ;
75936: LD_ADDR_VAR 0 3
75940: PUSH
75941: LD_VAR 0 4
75945: ST_TO_ADDR
// exit ;
75946: POP
75947: POP
75948: GO 75954
// end ;
75950: GO 75915
75952: POP
75953: POP
// end ;
75954: LD_VAR 0 3
75958: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
75959: LD_INT 0
75961: PPUSH
// vc_chassis := chassis ;
75962: LD_ADDR_OWVAR 37
75966: PUSH
75967: LD_VAR 0 1
75971: ST_TO_ADDR
// vc_engine := engine ;
75972: LD_ADDR_OWVAR 39
75976: PUSH
75977: LD_VAR 0 2
75981: ST_TO_ADDR
// vc_control := control ;
75982: LD_ADDR_OWVAR 38
75986: PUSH
75987: LD_VAR 0 3
75991: ST_TO_ADDR
// vc_weapon := weapon ;
75992: LD_ADDR_OWVAR 40
75996: PUSH
75997: LD_VAR 0 4
76001: ST_TO_ADDR
// vc_fuel_battery := fuel ;
76002: LD_ADDR_OWVAR 41
76006: PUSH
76007: LD_VAR 0 5
76011: ST_TO_ADDR
// end ;
76012: LD_VAR 0 6
76016: RET
// export function WantPlant ( unit ) ; var task ; begin
76017: LD_INT 0
76019: PPUSH
76020: PPUSH
// result := false ;
76021: LD_ADDR_VAR 0 2
76025: PUSH
76026: LD_INT 0
76028: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
76029: LD_ADDR_VAR 0 3
76033: PUSH
76034: LD_VAR 0 1
76038: PPUSH
76039: CALL_OW 437
76043: ST_TO_ADDR
// if task then
76044: LD_VAR 0 3
76048: IFFALSE 76076
// if task [ 1 ] [ 1 ] = p then
76050: LD_VAR 0 3
76054: PUSH
76055: LD_INT 1
76057: ARRAY
76058: PUSH
76059: LD_INT 1
76061: ARRAY
76062: PUSH
76063: LD_STRING p
76065: EQUAL
76066: IFFALSE 76076
// result := true ;
76068: LD_ADDR_VAR 0 2
76072: PUSH
76073: LD_INT 1
76075: ST_TO_ADDR
// end ;
76076: LD_VAR 0 2
76080: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
76081: LD_INT 0
76083: PPUSH
76084: PPUSH
76085: PPUSH
76086: PPUSH
// if pos < 1 then
76087: LD_VAR 0 2
76091: PUSH
76092: LD_INT 1
76094: LESS
76095: IFFALSE 76099
// exit ;
76097: GO 76402
// if pos = 1 then
76099: LD_VAR 0 2
76103: PUSH
76104: LD_INT 1
76106: EQUAL
76107: IFFALSE 76140
// result := Replace ( arr , pos [ 1 ] , value ) else
76109: LD_ADDR_VAR 0 4
76113: PUSH
76114: LD_VAR 0 1
76118: PPUSH
76119: LD_VAR 0 2
76123: PUSH
76124: LD_INT 1
76126: ARRAY
76127: PPUSH
76128: LD_VAR 0 3
76132: PPUSH
76133: CALL_OW 1
76137: ST_TO_ADDR
76138: GO 76402
// begin tmp := arr ;
76140: LD_ADDR_VAR 0 6
76144: PUSH
76145: LD_VAR 0 1
76149: ST_TO_ADDR
// s_arr := [ tmp ] ;
76150: LD_ADDR_VAR 0 7
76154: PUSH
76155: LD_VAR 0 6
76159: PUSH
76160: EMPTY
76161: LIST
76162: ST_TO_ADDR
// for i = 1 to pos - 1 do
76163: LD_ADDR_VAR 0 5
76167: PUSH
76168: DOUBLE
76169: LD_INT 1
76171: DEC
76172: ST_TO_ADDR
76173: LD_VAR 0 2
76177: PUSH
76178: LD_INT 1
76180: MINUS
76181: PUSH
76182: FOR_TO
76183: IFFALSE 76228
// begin tmp := tmp [ pos [ i ] ] ;
76185: LD_ADDR_VAR 0 6
76189: PUSH
76190: LD_VAR 0 6
76194: PUSH
76195: LD_VAR 0 2
76199: PUSH
76200: LD_VAR 0 5
76204: ARRAY
76205: ARRAY
76206: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
76207: LD_ADDR_VAR 0 7
76211: PUSH
76212: LD_VAR 0 7
76216: PUSH
76217: LD_VAR 0 6
76221: PUSH
76222: EMPTY
76223: LIST
76224: ADD
76225: ST_TO_ADDR
// end ;
76226: GO 76182
76228: POP
76229: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
76230: LD_ADDR_VAR 0 6
76234: PUSH
76235: LD_VAR 0 6
76239: PPUSH
76240: LD_VAR 0 2
76244: PUSH
76245: LD_VAR 0 2
76249: ARRAY
76250: PPUSH
76251: LD_VAR 0 3
76255: PPUSH
76256: CALL_OW 1
76260: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
76261: LD_ADDR_VAR 0 7
76265: PUSH
76266: LD_VAR 0 7
76270: PPUSH
76271: LD_VAR 0 7
76275: PPUSH
76276: LD_VAR 0 6
76280: PPUSH
76281: CALL_OW 1
76285: ST_TO_ADDR
// for i = s_arr downto 2 do
76286: LD_ADDR_VAR 0 5
76290: PUSH
76291: DOUBLE
76292: LD_VAR 0 7
76296: INC
76297: ST_TO_ADDR
76298: LD_INT 2
76300: PUSH
76301: FOR_DOWNTO
76302: IFFALSE 76386
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
76304: LD_ADDR_VAR 0 6
76308: PUSH
76309: LD_VAR 0 7
76313: PUSH
76314: LD_VAR 0 5
76318: PUSH
76319: LD_INT 1
76321: MINUS
76322: ARRAY
76323: PPUSH
76324: LD_VAR 0 2
76328: PUSH
76329: LD_VAR 0 5
76333: PUSH
76334: LD_INT 1
76336: MINUS
76337: ARRAY
76338: PPUSH
76339: LD_VAR 0 7
76343: PUSH
76344: LD_VAR 0 5
76348: ARRAY
76349: PPUSH
76350: CALL_OW 1
76354: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
76355: LD_ADDR_VAR 0 7
76359: PUSH
76360: LD_VAR 0 7
76364: PPUSH
76365: LD_VAR 0 5
76369: PUSH
76370: LD_INT 1
76372: MINUS
76373: PPUSH
76374: LD_VAR 0 6
76378: PPUSH
76379: CALL_OW 1
76383: ST_TO_ADDR
// end ;
76384: GO 76301
76386: POP
76387: POP
// result := s_arr [ 1 ] ;
76388: LD_ADDR_VAR 0 4
76392: PUSH
76393: LD_VAR 0 7
76397: PUSH
76398: LD_INT 1
76400: ARRAY
76401: ST_TO_ADDR
// end ; end ;
76402: LD_VAR 0 4
76406: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
76407: LD_INT 0
76409: PPUSH
76410: PPUSH
// if not list then
76411: LD_VAR 0 1
76415: NOT
76416: IFFALSE 76420
// exit ;
76418: GO 76511
// i := list [ pos1 ] ;
76420: LD_ADDR_VAR 0 5
76424: PUSH
76425: LD_VAR 0 1
76429: PUSH
76430: LD_VAR 0 2
76434: ARRAY
76435: ST_TO_ADDR
// if not i then
76436: LD_VAR 0 5
76440: NOT
76441: IFFALSE 76445
// exit ;
76443: GO 76511
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
76445: LD_ADDR_VAR 0 1
76449: PUSH
76450: LD_VAR 0 1
76454: PPUSH
76455: LD_VAR 0 2
76459: PPUSH
76460: LD_VAR 0 1
76464: PUSH
76465: LD_VAR 0 3
76469: ARRAY
76470: PPUSH
76471: CALL_OW 1
76475: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
76476: LD_ADDR_VAR 0 1
76480: PUSH
76481: LD_VAR 0 1
76485: PPUSH
76486: LD_VAR 0 3
76490: PPUSH
76491: LD_VAR 0 5
76495: PPUSH
76496: CALL_OW 1
76500: ST_TO_ADDR
// result := list ;
76501: LD_ADDR_VAR 0 4
76505: PUSH
76506: LD_VAR 0 1
76510: ST_TO_ADDR
// end ;
76511: LD_VAR 0 4
76515: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
76516: LD_INT 0
76518: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
76519: LD_ADDR_VAR 0 5
76523: PUSH
76524: LD_VAR 0 1
76528: PPUSH
76529: CALL_OW 250
76533: PPUSH
76534: LD_VAR 0 1
76538: PPUSH
76539: CALL_OW 251
76543: PPUSH
76544: LD_VAR 0 2
76548: PPUSH
76549: LD_VAR 0 3
76553: PPUSH
76554: LD_VAR 0 4
76558: PPUSH
76559: CALL 76941 0 5
76563: ST_TO_ADDR
// end ;
76564: LD_VAR 0 5
76568: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
76569: LD_INT 0
76571: PPUSH
76572: PPUSH
76573: PPUSH
76574: PPUSH
// if not list or not unit then
76575: LD_VAR 0 2
76579: NOT
76580: IFTRUE 76589
76582: PUSH
76583: LD_VAR 0 1
76587: NOT
76588: OR
76589: IFFALSE 76593
// exit ;
76591: GO 76936
// result := [ ] ;
76593: LD_ADDR_VAR 0 5
76597: PUSH
76598: EMPTY
76599: ST_TO_ADDR
// for i in list do
76600: LD_ADDR_VAR 0 6
76604: PUSH
76605: LD_VAR 0 2
76609: PUSH
76610: FOR_IN
76611: IFFALSE 76829
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
76613: LD_ADDR_VAR 0 8
76617: PUSH
76618: LD_VAR 0 1
76622: PPUSH
76623: LD_VAR 0 6
76627: PUSH
76628: LD_INT 1
76630: ARRAY
76631: PPUSH
76632: LD_VAR 0 6
76636: PUSH
76637: LD_INT 2
76639: ARRAY
76640: PPUSH
76641: CALL_OW 297
76645: ST_TO_ADDR
// if not Count ( result ) then
76646: LD_VAR 0 5
76650: PPUSH
76651: CALL 73163 0 1
76655: NOT
76656: IFFALSE 76689
// begin result := Join ( result , [ i , tmp ] ) ;
76658: LD_ADDR_VAR 0 5
76662: PUSH
76663: LD_VAR 0 5
76667: PPUSH
76668: LD_VAR 0 6
76672: PUSH
76673: LD_VAR 0 8
76677: PUSH
76678: EMPTY
76679: LIST
76680: LIST
76681: PPUSH
76682: CALL 109139 0 2
76686: ST_TO_ADDR
// continue ;
76687: GO 76610
// end ; if result [ result ] [ 2 ] <= tmp then
76689: LD_VAR 0 5
76693: PUSH
76694: LD_VAR 0 5
76698: ARRAY
76699: PUSH
76700: LD_INT 2
76702: ARRAY
76703: PUSH
76704: LD_VAR 0 8
76708: LESSEQUAL
76709: IFFALSE 76742
// result := Join ( result , [ i , tmp ] ) else
76711: LD_ADDR_VAR 0 5
76715: PUSH
76716: LD_VAR 0 5
76720: PPUSH
76721: LD_VAR 0 6
76725: PUSH
76726: LD_VAR 0 8
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PPUSH
76735: CALL 109139 0 2
76739: ST_TO_ADDR
76740: GO 76827
// begin for j := 1 to Count ( result ) do
76742: LD_ADDR_VAR 0 7
76746: PUSH
76747: DOUBLE
76748: LD_INT 1
76750: DEC
76751: ST_TO_ADDR
76752: LD_VAR 0 5
76756: PPUSH
76757: CALL 73163 0 1
76761: PUSH
76762: FOR_TO
76763: IFFALSE 76825
// begin if tmp < result [ j ] [ 2 ] then
76765: LD_VAR 0 8
76769: PUSH
76770: LD_VAR 0 5
76774: PUSH
76775: LD_VAR 0 7
76779: ARRAY
76780: PUSH
76781: LD_INT 2
76783: ARRAY
76784: LESS
76785: IFFALSE 76823
// begin result := Insert ( result , j , [ i , tmp ] ) ;
76787: LD_ADDR_VAR 0 5
76791: PUSH
76792: LD_VAR 0 5
76796: PPUSH
76797: LD_VAR 0 7
76801: PPUSH
76802: LD_VAR 0 6
76806: PUSH
76807: LD_VAR 0 8
76811: PUSH
76812: EMPTY
76813: LIST
76814: LIST
76815: PPUSH
76816: CALL_OW 2
76820: ST_TO_ADDR
// break ;
76821: GO 76825
// end ; end ;
76823: GO 76762
76825: POP
76826: POP
// end ; end ;
76827: GO 76610
76829: POP
76830: POP
// if result and not asc then
76831: LD_VAR 0 5
76835: IFFALSE 76844
76837: PUSH
76838: LD_VAR 0 3
76842: NOT
76843: AND
76844: IFFALSE 76861
// result := ReverseArray ( result ) ;
76846: LD_ADDR_VAR 0 5
76850: PUSH
76851: LD_VAR 0 5
76855: PPUSH
76856: CALL 104219 0 1
76860: ST_TO_ADDR
// tmp := [ ] ;
76861: LD_ADDR_VAR 0 8
76865: PUSH
76866: EMPTY
76867: ST_TO_ADDR
// if mode then
76868: LD_VAR 0 4
76872: IFFALSE 76936
// begin for i := 1 to result do
76874: LD_ADDR_VAR 0 6
76878: PUSH
76879: DOUBLE
76880: LD_INT 1
76882: DEC
76883: ST_TO_ADDR
76884: LD_VAR 0 5
76888: PUSH
76889: FOR_TO
76890: IFFALSE 76924
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
76892: LD_ADDR_VAR 0 8
76896: PUSH
76897: LD_VAR 0 8
76901: PPUSH
76902: LD_VAR 0 5
76906: PUSH
76907: LD_VAR 0 6
76911: ARRAY
76912: PUSH
76913: LD_INT 1
76915: ARRAY
76916: PPUSH
76917: CALL 109139 0 2
76921: ST_TO_ADDR
76922: GO 76889
76924: POP
76925: POP
// result := tmp ;
76926: LD_ADDR_VAR 0 5
76930: PUSH
76931: LD_VAR 0 8
76935: ST_TO_ADDR
// end ; end ;
76936: LD_VAR 0 5
76940: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
76941: LD_INT 0
76943: PPUSH
76944: PPUSH
76945: PPUSH
76946: PPUSH
// if not list then
76947: LD_VAR 0 3
76951: NOT
76952: IFFALSE 76956
// exit ;
76954: GO 77346
// result := [ ] ;
76956: LD_ADDR_VAR 0 6
76960: PUSH
76961: EMPTY
76962: ST_TO_ADDR
// for i in list do
76963: LD_ADDR_VAR 0 7
76967: PUSH
76968: LD_VAR 0 3
76972: PUSH
76973: FOR_IN
76974: IFFALSE 77176
// begin tmp := GetDistUnitXY ( i , x , y ) ;
76976: LD_ADDR_VAR 0 9
76980: PUSH
76981: LD_VAR 0 7
76985: PPUSH
76986: LD_VAR 0 1
76990: PPUSH
76991: LD_VAR 0 2
76995: PPUSH
76996: CALL_OW 297
77000: ST_TO_ADDR
// if not result then
77001: LD_VAR 0 6
77005: NOT
77006: IFFALSE 77032
// result := [ [ i , tmp ] ] else
77008: LD_ADDR_VAR 0 6
77012: PUSH
77013: LD_VAR 0 7
77017: PUSH
77018: LD_VAR 0 9
77022: PUSH
77023: EMPTY
77024: LIST
77025: LIST
77026: PUSH
77027: EMPTY
77028: LIST
77029: ST_TO_ADDR
77030: GO 77174
// begin if result [ result ] [ 2 ] <= tmp then
77032: LD_VAR 0 6
77036: PUSH
77037: LD_VAR 0 6
77041: ARRAY
77042: PUSH
77043: LD_INT 2
77045: ARRAY
77046: PUSH
77047: LD_VAR 0 9
77051: LESSEQUAL
77052: IFFALSE 77094
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
77054: LD_ADDR_VAR 0 6
77058: PUSH
77059: LD_VAR 0 6
77063: PPUSH
77064: LD_VAR 0 6
77068: PUSH
77069: LD_INT 1
77071: PLUS
77072: PPUSH
77073: LD_VAR 0 7
77077: PUSH
77078: LD_VAR 0 9
77082: PUSH
77083: EMPTY
77084: LIST
77085: LIST
77086: PPUSH
77087: CALL_OW 2
77091: ST_TO_ADDR
77092: GO 77174
// for j := 1 to result do
77094: LD_ADDR_VAR 0 8
77098: PUSH
77099: DOUBLE
77100: LD_INT 1
77102: DEC
77103: ST_TO_ADDR
77104: LD_VAR 0 6
77108: PUSH
77109: FOR_TO
77110: IFFALSE 77172
// begin if tmp < result [ j ] [ 2 ] then
77112: LD_VAR 0 9
77116: PUSH
77117: LD_VAR 0 6
77121: PUSH
77122: LD_VAR 0 8
77126: ARRAY
77127: PUSH
77128: LD_INT 2
77130: ARRAY
77131: LESS
77132: IFFALSE 77170
// begin result := Insert ( result , j , [ i , tmp ] ) ;
77134: LD_ADDR_VAR 0 6
77138: PUSH
77139: LD_VAR 0 6
77143: PPUSH
77144: LD_VAR 0 8
77148: PPUSH
77149: LD_VAR 0 7
77153: PUSH
77154: LD_VAR 0 9
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PPUSH
77163: CALL_OW 2
77167: ST_TO_ADDR
// break ;
77168: GO 77172
// end ; end ;
77170: GO 77109
77172: POP
77173: POP
// end ; end ;
77174: GO 76973
77176: POP
77177: POP
// if result and not asc then
77178: LD_VAR 0 6
77182: IFFALSE 77191
77184: PUSH
77185: LD_VAR 0 4
77189: NOT
77190: AND
77191: IFFALSE 77266
// begin tmp := result ;
77193: LD_ADDR_VAR 0 9
77197: PUSH
77198: LD_VAR 0 6
77202: ST_TO_ADDR
// for i = tmp downto 1 do
77203: LD_ADDR_VAR 0 7
77207: PUSH
77208: DOUBLE
77209: LD_VAR 0 9
77213: INC
77214: ST_TO_ADDR
77215: LD_INT 1
77217: PUSH
77218: FOR_DOWNTO
77219: IFFALSE 77264
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
77221: LD_ADDR_VAR 0 6
77225: PUSH
77226: LD_VAR 0 6
77230: PPUSH
77231: LD_VAR 0 9
77235: PUSH
77236: LD_VAR 0 7
77240: MINUS
77241: PUSH
77242: LD_INT 1
77244: PLUS
77245: PPUSH
77246: LD_VAR 0 9
77250: PUSH
77251: LD_VAR 0 7
77255: ARRAY
77256: PPUSH
77257: CALL_OW 1
77261: ST_TO_ADDR
77262: GO 77218
77264: POP
77265: POP
// end ; tmp := [ ] ;
77266: LD_ADDR_VAR 0 9
77270: PUSH
77271: EMPTY
77272: ST_TO_ADDR
// if mode then
77273: LD_VAR 0 5
77277: IFFALSE 77346
// begin for i = 1 to result do
77279: LD_ADDR_VAR 0 7
77283: PUSH
77284: DOUBLE
77285: LD_INT 1
77287: DEC
77288: ST_TO_ADDR
77289: LD_VAR 0 6
77293: PUSH
77294: FOR_TO
77295: IFFALSE 77334
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
77297: LD_ADDR_VAR 0 9
77301: PUSH
77302: LD_VAR 0 9
77306: PPUSH
77307: LD_VAR 0 7
77311: PPUSH
77312: LD_VAR 0 6
77316: PUSH
77317: LD_VAR 0 7
77321: ARRAY
77322: PUSH
77323: LD_INT 1
77325: ARRAY
77326: PPUSH
77327: CALL_OW 1
77331: ST_TO_ADDR
77332: GO 77294
77334: POP
77335: POP
// result := tmp ;
77336: LD_ADDR_VAR 0 6
77340: PUSH
77341: LD_VAR 0 9
77345: ST_TO_ADDR
// end ; end ;
77346: LD_VAR 0 6
77350: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
77351: LD_INT 0
77353: PPUSH
77354: PPUSH
77355: PPUSH
77356: PPUSH
77357: PPUSH
77358: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
77359: LD_ADDR_VAR 0 5
77363: PUSH
77364: LD_INT 0
77366: PUSH
77367: LD_INT 0
77369: PUSH
77370: LD_INT 0
77372: PUSH
77373: EMPTY
77374: PUSH
77375: EMPTY
77376: LIST
77377: LIST
77378: LIST
77379: LIST
77380: ST_TO_ADDR
// if not x or not y then
77381: LD_VAR 0 2
77385: NOT
77386: IFTRUE 77395
77388: PUSH
77389: LD_VAR 0 3
77393: NOT
77394: OR
77395: IFFALSE 77399
// exit ;
77397: GO 79055
// if not range then
77399: LD_VAR 0 4
77403: NOT
77404: IFFALSE 77414
// range := 10 ;
77406: LD_ADDR_VAR 0 4
77410: PUSH
77411: LD_INT 10
77413: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
77414: LD_ADDR_VAR 0 8
77418: PUSH
77419: LD_INT 81
77421: PUSH
77422: LD_VAR 0 1
77426: PUSH
77427: EMPTY
77428: LIST
77429: LIST
77430: PUSH
77431: LD_INT 92
77433: PUSH
77434: LD_VAR 0 2
77438: PUSH
77439: LD_VAR 0 3
77443: PUSH
77444: LD_VAR 0 4
77448: PUSH
77449: EMPTY
77450: LIST
77451: LIST
77452: LIST
77453: LIST
77454: PUSH
77455: LD_INT 3
77457: PUSH
77458: LD_INT 21
77460: PUSH
77461: LD_INT 3
77463: PUSH
77464: EMPTY
77465: LIST
77466: LIST
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: EMPTY
77473: LIST
77474: LIST
77475: LIST
77476: PPUSH
77477: CALL_OW 69
77481: ST_TO_ADDR
// if not tmp then
77482: LD_VAR 0 8
77486: NOT
77487: IFFALSE 77491
// exit ;
77489: GO 79055
// for i in tmp do
77491: LD_ADDR_VAR 0 6
77495: PUSH
77496: LD_VAR 0 8
77500: PUSH
77501: FOR_IN
77502: IFFALSE 79030
// begin points := [ 0 , 0 , 0 ] ;
77504: LD_ADDR_VAR 0 9
77508: PUSH
77509: LD_INT 0
77511: PUSH
77512: LD_INT 0
77514: PUSH
77515: LD_INT 0
77517: PUSH
77518: EMPTY
77519: LIST
77520: LIST
77521: LIST
77522: ST_TO_ADDR
// bpoints := 1 ;
77523: LD_ADDR_VAR 0 10
77527: PUSH
77528: LD_INT 1
77530: ST_TO_ADDR
// case GetType ( i ) of unit_human :
77531: LD_VAR 0 6
77535: PPUSH
77536: CALL_OW 247
77540: PUSH
77541: LD_INT 1
77543: DOUBLE
77544: EQUAL
77545: IFTRUE 77549
77547: GO 78131
77549: POP
// begin if GetClass ( i ) = 1 then
77550: LD_VAR 0 6
77554: PPUSH
77555: CALL_OW 257
77559: PUSH
77560: LD_INT 1
77562: EQUAL
77563: IFFALSE 77584
// points := [ 10 , 5 , 3 ] ;
77565: LD_ADDR_VAR 0 9
77569: PUSH
77570: LD_INT 10
77572: PUSH
77573: LD_INT 5
77575: PUSH
77576: LD_INT 3
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: LIST
77583: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
77584: LD_VAR 0 6
77588: PPUSH
77589: CALL_OW 257
77593: PUSH
77594: LD_INT 2
77596: PUSH
77597: LD_INT 3
77599: PUSH
77600: LD_INT 4
77602: PUSH
77603: EMPTY
77604: LIST
77605: LIST
77606: LIST
77607: IN
77608: IFFALSE 77629
// points := [ 3 , 2 , 1 ] ;
77610: LD_ADDR_VAR 0 9
77614: PUSH
77615: LD_INT 3
77617: PUSH
77618: LD_INT 2
77620: PUSH
77621: LD_INT 1
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: LIST
77628: ST_TO_ADDR
// if GetClass ( i ) = 5 then
77629: LD_VAR 0 6
77633: PPUSH
77634: CALL_OW 257
77638: PUSH
77639: LD_INT 5
77641: EQUAL
77642: IFFALSE 77663
// points := [ 130 , 5 , 2 ] ;
77644: LD_ADDR_VAR 0 9
77648: PUSH
77649: LD_INT 130
77651: PUSH
77652: LD_INT 5
77654: PUSH
77655: LD_INT 2
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: LIST
77662: ST_TO_ADDR
// if GetClass ( i ) = 8 then
77663: LD_VAR 0 6
77667: PPUSH
77668: CALL_OW 257
77672: PUSH
77673: LD_INT 8
77675: EQUAL
77676: IFFALSE 77697
// points := [ 35 , 35 , 30 ] ;
77678: LD_ADDR_VAR 0 9
77682: PUSH
77683: LD_INT 35
77685: PUSH
77686: LD_INT 35
77688: PUSH
77689: LD_INT 30
77691: PUSH
77692: EMPTY
77693: LIST
77694: LIST
77695: LIST
77696: ST_TO_ADDR
// if GetClass ( i ) = 9 then
77697: LD_VAR 0 6
77701: PPUSH
77702: CALL_OW 257
77706: PUSH
77707: LD_INT 9
77709: EQUAL
77710: IFFALSE 77731
// points := [ 20 , 55 , 40 ] ;
77712: LD_ADDR_VAR 0 9
77716: PUSH
77717: LD_INT 20
77719: PUSH
77720: LD_INT 55
77722: PUSH
77723: LD_INT 40
77725: PUSH
77726: EMPTY
77727: LIST
77728: LIST
77729: LIST
77730: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
77731: LD_VAR 0 6
77735: PPUSH
77736: CALL_OW 257
77740: PUSH
77741: LD_INT 12
77743: PUSH
77744: LD_INT 16
77746: PUSH
77747: EMPTY
77748: LIST
77749: LIST
77750: IN
77751: IFFALSE 77772
// points := [ 5 , 3 , 2 ] ;
77753: LD_ADDR_VAR 0 9
77757: PUSH
77758: LD_INT 5
77760: PUSH
77761: LD_INT 3
77763: PUSH
77764: LD_INT 2
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: LIST
77771: ST_TO_ADDR
// if GetClass ( i ) = 17 then
77772: LD_VAR 0 6
77776: PPUSH
77777: CALL_OW 257
77781: PUSH
77782: LD_INT 17
77784: EQUAL
77785: IFFALSE 77806
// points := [ 100 , 50 , 75 ] ;
77787: LD_ADDR_VAR 0 9
77791: PUSH
77792: LD_INT 100
77794: PUSH
77795: LD_INT 50
77797: PUSH
77798: LD_INT 75
77800: PUSH
77801: EMPTY
77802: LIST
77803: LIST
77804: LIST
77805: ST_TO_ADDR
// if GetClass ( i ) = 15 then
77806: LD_VAR 0 6
77810: PPUSH
77811: CALL_OW 257
77815: PUSH
77816: LD_INT 15
77818: EQUAL
77819: IFFALSE 77840
// points := [ 10 , 5 , 3 ] ;
77821: LD_ADDR_VAR 0 9
77825: PUSH
77826: LD_INT 10
77828: PUSH
77829: LD_INT 5
77831: PUSH
77832: LD_INT 3
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: LIST
77839: ST_TO_ADDR
// if GetClass ( i ) = 14 then
77840: LD_VAR 0 6
77844: PPUSH
77845: CALL_OW 257
77849: PUSH
77850: LD_INT 14
77852: EQUAL
77853: IFFALSE 77874
// points := [ 10 , 0 , 0 ] ;
77855: LD_ADDR_VAR 0 9
77859: PUSH
77860: LD_INT 10
77862: PUSH
77863: LD_INT 0
77865: PUSH
77866: LD_INT 0
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: LIST
77873: ST_TO_ADDR
// if GetClass ( i ) = 11 then
77874: LD_VAR 0 6
77878: PPUSH
77879: CALL_OW 257
77883: PUSH
77884: LD_INT 11
77886: EQUAL
77887: IFFALSE 77908
// points := [ 30 , 10 , 5 ] ;
77889: LD_ADDR_VAR 0 9
77893: PUSH
77894: LD_INT 30
77896: PUSH
77897: LD_INT 10
77899: PUSH
77900: LD_INT 5
77902: PUSH
77903: EMPTY
77904: LIST
77905: LIST
77906: LIST
77907: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
77908: LD_VAR 0 1
77912: PPUSH
77913: LD_INT 5
77915: PPUSH
77916: CALL_OW 321
77920: PUSH
77921: LD_INT 2
77923: EQUAL
77924: IFFALSE 77941
// bpoints := bpoints * 1.8 ;
77926: LD_ADDR_VAR 0 10
77930: PUSH
77931: LD_VAR 0 10
77935: PUSH
77936: LD_REAL  1.80000000000000E+0000
77939: MUL
77940: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
77941: LD_VAR 0 6
77945: PPUSH
77946: CALL_OW 257
77950: PUSH
77951: LD_INT 1
77953: PUSH
77954: LD_INT 2
77956: PUSH
77957: LD_INT 3
77959: PUSH
77960: LD_INT 4
77962: PUSH
77963: EMPTY
77964: LIST
77965: LIST
77966: LIST
77967: LIST
77968: IN
77969: IFFALSE 77989
77971: PUSH
77972: LD_VAR 0 1
77976: PPUSH
77977: LD_INT 51
77979: PPUSH
77980: CALL_OW 321
77984: PUSH
77985: LD_INT 2
77987: EQUAL
77988: AND
77989: IFFALSE 78006
// bpoints := bpoints * 1.2 ;
77991: LD_ADDR_VAR 0 10
77995: PUSH
77996: LD_VAR 0 10
78000: PUSH
78001: LD_REAL  1.20000000000000E+0000
78004: MUL
78005: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
78006: LD_VAR 0 6
78010: PPUSH
78011: CALL_OW 257
78015: PUSH
78016: LD_INT 5
78018: PUSH
78019: LD_INT 7
78021: PUSH
78022: LD_INT 9
78024: PUSH
78025: EMPTY
78026: LIST
78027: LIST
78028: LIST
78029: IN
78030: IFFALSE 78050
78032: PUSH
78033: LD_VAR 0 1
78037: PPUSH
78038: LD_INT 52
78040: PPUSH
78041: CALL_OW 321
78045: PUSH
78046: LD_INT 2
78048: EQUAL
78049: AND
78050: IFFALSE 78067
// bpoints := bpoints * 1.5 ;
78052: LD_ADDR_VAR 0 10
78056: PUSH
78057: LD_VAR 0 10
78061: PUSH
78062: LD_REAL  1.50000000000000E+0000
78065: MUL
78066: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
78067: LD_VAR 0 1
78071: PPUSH
78072: LD_INT 66
78074: PPUSH
78075: CALL_OW 321
78079: PUSH
78080: LD_INT 2
78082: EQUAL
78083: IFFALSE 78100
// bpoints := bpoints * 1.1 ;
78085: LD_ADDR_VAR 0 10
78089: PUSH
78090: LD_VAR 0 10
78094: PUSH
78095: LD_REAL  1.10000000000000E+0000
78098: MUL
78099: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
78100: LD_ADDR_VAR 0 10
78104: PUSH
78105: LD_VAR 0 10
78109: PUSH
78110: LD_VAR 0 6
78114: PPUSH
78115: LD_INT 1
78117: PPUSH
78118: CALL_OW 259
78122: PUSH
78123: LD_REAL  1.15000000000000E+0000
78126: MUL
78127: MUL
78128: ST_TO_ADDR
// end ; unit_vehicle :
78129: GO 78959
78131: LD_INT 2
78133: DOUBLE
78134: EQUAL
78135: IFTRUE 78139
78137: GO 78947
78139: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
78140: LD_VAR 0 6
78144: PPUSH
78145: CALL_OW 264
78149: PUSH
78150: LD_INT 2
78152: PUSH
78153: LD_INT 42
78155: PUSH
78156: LD_INT 24
78158: PUSH
78159: EMPTY
78160: LIST
78161: LIST
78162: LIST
78163: IN
78164: IFFALSE 78185
// points := [ 25 , 5 , 3 ] ;
78166: LD_ADDR_VAR 0 9
78170: PUSH
78171: LD_INT 25
78173: PUSH
78174: LD_INT 5
78176: PUSH
78177: LD_INT 3
78179: PUSH
78180: EMPTY
78181: LIST
78182: LIST
78183: LIST
78184: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
78185: LD_VAR 0 6
78189: PPUSH
78190: CALL_OW 264
78194: PUSH
78195: LD_INT 4
78197: PUSH
78198: LD_INT 43
78200: PUSH
78201: LD_INT 25
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: LIST
78208: IN
78209: IFFALSE 78230
// points := [ 40 , 15 , 5 ] ;
78211: LD_ADDR_VAR 0 9
78215: PUSH
78216: LD_INT 40
78218: PUSH
78219: LD_INT 15
78221: PUSH
78222: LD_INT 5
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: LIST
78229: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
78230: LD_VAR 0 6
78234: PPUSH
78235: CALL_OW 264
78239: PUSH
78240: LD_INT 3
78242: PUSH
78243: LD_INT 23
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: IN
78250: IFFALSE 78271
// points := [ 7 , 25 , 8 ] ;
78252: LD_ADDR_VAR 0 9
78256: PUSH
78257: LD_INT 7
78259: PUSH
78260: LD_INT 25
78262: PUSH
78263: LD_INT 8
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: LIST
78270: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
78271: LD_VAR 0 6
78275: PPUSH
78276: CALL_OW 264
78280: PUSH
78281: LD_INT 5
78283: PUSH
78284: LD_INT 27
78286: PUSH
78287: LD_INT 44
78289: PUSH
78290: EMPTY
78291: LIST
78292: LIST
78293: LIST
78294: IN
78295: IFFALSE 78316
// points := [ 14 , 50 , 16 ] ;
78297: LD_ADDR_VAR 0 9
78301: PUSH
78302: LD_INT 14
78304: PUSH
78305: LD_INT 50
78307: PUSH
78308: LD_INT 16
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: LIST
78315: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
78316: LD_VAR 0 6
78320: PPUSH
78321: CALL_OW 264
78325: PUSH
78326: LD_INT 6
78328: PUSH
78329: LD_INT 46
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: IN
78336: IFFALSE 78357
// points := [ 32 , 120 , 70 ] ;
78338: LD_ADDR_VAR 0 9
78342: PUSH
78343: LD_INT 32
78345: PUSH
78346: LD_INT 120
78348: PUSH
78349: LD_INT 70
78351: PUSH
78352: EMPTY
78353: LIST
78354: LIST
78355: LIST
78356: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
78357: LD_VAR 0 6
78361: PPUSH
78362: CALL_OW 264
78366: PUSH
78367: LD_INT 7
78369: PUSH
78370: LD_INT 28
78372: PUSH
78373: LD_INT 45
78375: PUSH
78376: LD_INT 92
78378: PUSH
78379: EMPTY
78380: LIST
78381: LIST
78382: LIST
78383: LIST
78384: IN
78385: IFFALSE 78406
// points := [ 35 , 20 , 45 ] ;
78387: LD_ADDR_VAR 0 9
78391: PUSH
78392: LD_INT 35
78394: PUSH
78395: LD_INT 20
78397: PUSH
78398: LD_INT 45
78400: PUSH
78401: EMPTY
78402: LIST
78403: LIST
78404: LIST
78405: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
78406: LD_VAR 0 6
78410: PPUSH
78411: CALL_OW 264
78415: PUSH
78416: LD_INT 47
78418: PUSH
78419: EMPTY
78420: LIST
78421: IN
78422: IFFALSE 78443
// points := [ 67 , 45 , 75 ] ;
78424: LD_ADDR_VAR 0 9
78428: PUSH
78429: LD_INT 67
78431: PUSH
78432: LD_INT 45
78434: PUSH
78435: LD_INT 75
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: LIST
78442: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
78443: LD_VAR 0 6
78447: PPUSH
78448: CALL_OW 264
78452: PUSH
78453: LD_INT 26
78455: PUSH
78456: EMPTY
78457: LIST
78458: IN
78459: IFFALSE 78480
// points := [ 120 , 30 , 80 ] ;
78461: LD_ADDR_VAR 0 9
78465: PUSH
78466: LD_INT 120
78468: PUSH
78469: LD_INT 30
78471: PUSH
78472: LD_INT 80
78474: PUSH
78475: EMPTY
78476: LIST
78477: LIST
78478: LIST
78479: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
78480: LD_VAR 0 6
78484: PPUSH
78485: CALL_OW 264
78489: PUSH
78490: LD_INT 22
78492: PUSH
78493: EMPTY
78494: LIST
78495: IN
78496: IFFALSE 78517
// points := [ 40 , 1 , 1 ] ;
78498: LD_ADDR_VAR 0 9
78502: PUSH
78503: LD_INT 40
78505: PUSH
78506: LD_INT 1
78508: PUSH
78509: LD_INT 1
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: LIST
78516: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
78517: LD_VAR 0 6
78521: PPUSH
78522: CALL_OW 264
78526: PUSH
78527: LD_INT 29
78529: PUSH
78530: EMPTY
78531: LIST
78532: IN
78533: IFFALSE 78554
// points := [ 70 , 200 , 400 ] ;
78535: LD_ADDR_VAR 0 9
78539: PUSH
78540: LD_INT 70
78542: PUSH
78543: LD_INT 200
78545: PUSH
78546: LD_INT 400
78548: PUSH
78549: EMPTY
78550: LIST
78551: LIST
78552: LIST
78553: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
78554: LD_VAR 0 6
78558: PPUSH
78559: CALL_OW 264
78563: PUSH
78564: LD_INT 14
78566: PUSH
78567: LD_INT 53
78569: PUSH
78570: EMPTY
78571: LIST
78572: LIST
78573: IN
78574: IFFALSE 78595
// points := [ 40 , 10 , 20 ] ;
78576: LD_ADDR_VAR 0 9
78580: PUSH
78581: LD_INT 40
78583: PUSH
78584: LD_INT 10
78586: PUSH
78587: LD_INT 20
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: LIST
78594: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
78595: LD_VAR 0 6
78599: PPUSH
78600: CALL_OW 264
78604: PUSH
78605: LD_INT 9
78607: PUSH
78608: EMPTY
78609: LIST
78610: IN
78611: IFFALSE 78632
// points := [ 5 , 70 , 20 ] ;
78613: LD_ADDR_VAR 0 9
78617: PUSH
78618: LD_INT 5
78620: PUSH
78621: LD_INT 70
78623: PUSH
78624: LD_INT 20
78626: PUSH
78627: EMPTY
78628: LIST
78629: LIST
78630: LIST
78631: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
78632: LD_VAR 0 6
78636: PPUSH
78637: CALL_OW 264
78641: PUSH
78642: LD_INT 10
78644: PUSH
78645: EMPTY
78646: LIST
78647: IN
78648: IFFALSE 78669
// points := [ 35 , 110 , 70 ] ;
78650: LD_ADDR_VAR 0 9
78654: PUSH
78655: LD_INT 35
78657: PUSH
78658: LD_INT 110
78660: PUSH
78661: LD_INT 70
78663: PUSH
78664: EMPTY
78665: LIST
78666: LIST
78667: LIST
78668: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
78669: LD_VAR 0 6
78673: PPUSH
78674: CALL_OW 265
78678: PUSH
78679: LD_INT 25
78681: EQUAL
78682: IFFALSE 78703
// points := [ 80 , 65 , 100 ] ;
78684: LD_ADDR_VAR 0 9
78688: PUSH
78689: LD_INT 80
78691: PUSH
78692: LD_INT 65
78694: PUSH
78695: LD_INT 100
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: LIST
78702: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
78703: LD_VAR 0 6
78707: PPUSH
78708: CALL_OW 263
78712: PUSH
78713: LD_INT 1
78715: EQUAL
78716: IFFALSE 78751
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
78718: LD_ADDR_VAR 0 10
78722: PUSH
78723: LD_VAR 0 10
78727: PUSH
78728: LD_VAR 0 6
78732: PPUSH
78733: CALL_OW 311
78737: PPUSH
78738: LD_INT 3
78740: PPUSH
78741: CALL_OW 259
78745: PUSH
78746: LD_INT 4
78748: MUL
78749: MUL
78750: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
78751: LD_VAR 0 6
78755: PPUSH
78756: CALL_OW 263
78760: PUSH
78761: LD_INT 2
78763: EQUAL
78764: IFFALSE 78815
// begin j := IsControledBy ( i ) ;
78766: LD_ADDR_VAR 0 7
78770: PUSH
78771: LD_VAR 0 6
78775: PPUSH
78776: CALL_OW 312
78780: ST_TO_ADDR
// if j then
78781: LD_VAR 0 7
78785: IFFALSE 78815
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
78787: LD_ADDR_VAR 0 10
78791: PUSH
78792: LD_VAR 0 10
78796: PUSH
78797: LD_VAR 0 7
78801: PPUSH
78802: LD_INT 3
78804: PPUSH
78805: CALL_OW 259
78809: PUSH
78810: LD_INT 3
78812: MUL
78813: MUL
78814: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
78815: LD_VAR 0 6
78819: PPUSH
78820: CALL_OW 264
78824: PUSH
78825: LD_INT 5
78827: PUSH
78828: LD_INT 6
78830: PUSH
78831: LD_INT 46
78833: PUSH
78834: LD_INT 44
78836: PUSH
78837: LD_INT 47
78839: PUSH
78840: LD_INT 45
78842: PUSH
78843: LD_INT 28
78845: PUSH
78846: LD_INT 7
78848: PUSH
78849: LD_INT 27
78851: PUSH
78852: LD_INT 29
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: LIST
78859: LIST
78860: LIST
78861: LIST
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: IN
78867: IFFALSE 78887
78869: PUSH
78870: LD_VAR 0 1
78874: PPUSH
78875: LD_INT 52
78877: PPUSH
78878: CALL_OW 321
78882: PUSH
78883: LD_INT 2
78885: EQUAL
78886: AND
78887: IFFALSE 78904
// bpoints := bpoints * 1.2 ;
78889: LD_ADDR_VAR 0 10
78893: PUSH
78894: LD_VAR 0 10
78898: PUSH
78899: LD_REAL  1.20000000000000E+0000
78902: MUL
78903: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
78904: LD_VAR 0 6
78908: PPUSH
78909: CALL_OW 264
78913: PUSH
78914: LD_INT 6
78916: PUSH
78917: LD_INT 46
78919: PUSH
78920: LD_INT 47
78922: PUSH
78923: EMPTY
78924: LIST
78925: LIST
78926: LIST
78927: IN
78928: IFFALSE 78945
// bpoints := bpoints * 1.2 ;
78930: LD_ADDR_VAR 0 10
78934: PUSH
78935: LD_VAR 0 10
78939: PUSH
78940: LD_REAL  1.20000000000000E+0000
78943: MUL
78944: ST_TO_ADDR
// end ; unit_building :
78945: GO 78959
78947: LD_INT 3
78949: DOUBLE
78950: EQUAL
78951: IFTRUE 78955
78953: GO 78958
78955: POP
// ; end ;
78956: GO 78959
78958: POP
// for j = 1 to 3 do
78959: LD_ADDR_VAR 0 7
78963: PUSH
78964: DOUBLE
78965: LD_INT 1
78967: DEC
78968: ST_TO_ADDR
78969: LD_INT 3
78971: PUSH
78972: FOR_TO
78973: IFFALSE 79026
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
78975: LD_ADDR_VAR 0 5
78979: PUSH
78980: LD_VAR 0 5
78984: PPUSH
78985: LD_VAR 0 7
78989: PPUSH
78990: LD_VAR 0 5
78994: PUSH
78995: LD_VAR 0 7
78999: ARRAY
79000: PUSH
79001: LD_VAR 0 9
79005: PUSH
79006: LD_VAR 0 7
79010: ARRAY
79011: PUSH
79012: LD_VAR 0 10
79016: MUL
79017: PLUS
79018: PPUSH
79019: CALL_OW 1
79023: ST_TO_ADDR
79024: GO 78972
79026: POP
79027: POP
// end ;
79028: GO 77501
79030: POP
79031: POP
// result := Replace ( result , 4 , tmp ) ;
79032: LD_ADDR_VAR 0 5
79036: PUSH
79037: LD_VAR 0 5
79041: PPUSH
79042: LD_INT 4
79044: PPUSH
79045: LD_VAR 0 8
79049: PPUSH
79050: CALL_OW 1
79054: ST_TO_ADDR
// end ;
79055: LD_VAR 0 5
79059: RET
// export function DangerAtRange ( unit , range ) ; begin
79060: LD_INT 0
79062: PPUSH
// if not unit then
79063: LD_VAR 0 1
79067: NOT
79068: IFFALSE 79072
// exit ;
79070: GO 79117
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
79072: LD_ADDR_VAR 0 3
79076: PUSH
79077: LD_VAR 0 1
79081: PPUSH
79082: CALL_OW 255
79086: PPUSH
79087: LD_VAR 0 1
79091: PPUSH
79092: CALL_OW 250
79096: PPUSH
79097: LD_VAR 0 1
79101: PPUSH
79102: CALL_OW 251
79106: PPUSH
79107: LD_VAR 0 2
79111: PPUSH
79112: CALL 77351 0 4
79116: ST_TO_ADDR
// end ;
79117: LD_VAR 0 3
79121: RET
// export function DangerInArea ( side , area ) ; begin
79122: LD_INT 0
79124: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
79125: LD_ADDR_VAR 0 3
79129: PUSH
79130: LD_VAR 0 2
79134: PPUSH
79135: LD_INT 81
79137: PUSH
79138: LD_VAR 0 1
79142: PUSH
79143: EMPTY
79144: LIST
79145: LIST
79146: PPUSH
79147: CALL_OW 70
79151: ST_TO_ADDR
// end ;
79152: LD_VAR 0 3
79156: RET
// export function IsExtension ( b ) ; begin
79157: LD_INT 0
79159: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
79160: LD_ADDR_VAR 0 2
79164: PUSH
79165: LD_VAR 0 1
79169: PUSH
79170: LD_INT 23
79172: PUSH
79173: LD_INT 20
79175: PUSH
79176: LD_INT 22
79178: PUSH
79179: LD_INT 17
79181: PUSH
79182: LD_INT 24
79184: PUSH
79185: LD_INT 21
79187: PUSH
79188: LD_INT 19
79190: PUSH
79191: LD_INT 16
79193: PUSH
79194: LD_INT 25
79196: PUSH
79197: LD_INT 18
79199: PUSH
79200: EMPTY
79201: LIST
79202: LIST
79203: LIST
79204: LIST
79205: LIST
79206: LIST
79207: LIST
79208: LIST
79209: LIST
79210: LIST
79211: IN
79212: ST_TO_ADDR
// end ;
79213: LD_VAR 0 2
79217: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
79218: LD_INT 0
79220: PPUSH
79221: PPUSH
79222: PPUSH
// result := [ ] ;
79223: LD_ADDR_VAR 0 4
79227: PUSH
79228: EMPTY
79229: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
79230: LD_ADDR_VAR 0 5
79234: PUSH
79235: LD_VAR 0 2
79239: PPUSH
79240: LD_INT 21
79242: PUSH
79243: LD_INT 3
79245: PUSH
79246: EMPTY
79247: LIST
79248: LIST
79249: PPUSH
79250: CALL_OW 70
79254: ST_TO_ADDR
// if not tmp then
79255: LD_VAR 0 5
79259: NOT
79260: IFFALSE 79264
// exit ;
79262: GO 79328
// if checkLink then
79264: LD_VAR 0 3
79268: IFFALSE 79318
// begin for i in tmp do
79270: LD_ADDR_VAR 0 6
79274: PUSH
79275: LD_VAR 0 5
79279: PUSH
79280: FOR_IN
79281: IFFALSE 79316
// if GetBase ( i ) <> base then
79283: LD_VAR 0 6
79287: PPUSH
79288: CALL_OW 274
79292: PUSH
79293: LD_VAR 0 1
79297: NONEQUAL
79298: IFFALSE 79314
// ComLinkToBase ( base , i ) ;
79300: LD_VAR 0 1
79304: PPUSH
79305: LD_VAR 0 6
79309: PPUSH
79310: CALL_OW 169
79314: GO 79280
79316: POP
79317: POP
// end ; result := tmp ;
79318: LD_ADDR_VAR 0 4
79322: PUSH
79323: LD_VAR 0 5
79327: ST_TO_ADDR
// end ;
79328: LD_VAR 0 4
79332: RET
// export function ComComplete ( units , b ) ; var i ; begin
79333: LD_INT 0
79335: PPUSH
79336: PPUSH
// if not units then
79337: LD_VAR 0 1
79341: NOT
79342: IFFALSE 79346
// exit ;
79344: GO 79436
// for i in units do
79346: LD_ADDR_VAR 0 4
79350: PUSH
79351: LD_VAR 0 1
79355: PUSH
79356: FOR_IN
79357: IFFALSE 79434
// if BuildingStatus ( b ) = bs_build then
79359: LD_VAR 0 2
79363: PPUSH
79364: CALL_OW 461
79368: PUSH
79369: LD_INT 1
79371: EQUAL
79372: IFFALSE 79432
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
79374: LD_VAR 0 4
79378: PPUSH
79379: LD_STRING h
79381: PUSH
79382: LD_VAR 0 2
79386: PPUSH
79387: CALL_OW 250
79391: PUSH
79392: LD_VAR 0 2
79396: PPUSH
79397: CALL_OW 251
79401: PUSH
79402: LD_VAR 0 2
79406: PUSH
79407: LD_INT 0
79409: PUSH
79410: LD_INT 0
79412: PUSH
79413: LD_INT 0
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: LIST
79420: LIST
79421: LIST
79422: LIST
79423: LIST
79424: PUSH
79425: EMPTY
79426: LIST
79427: PPUSH
79428: CALL_OW 446
79432: GO 79356
79434: POP
79435: POP
// end ;
79436: LD_VAR 0 3
79440: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
79441: LD_INT 0
79443: PPUSH
79444: PPUSH
79445: PPUSH
79446: PPUSH
79447: PPUSH
79448: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
79449: LD_VAR 0 1
79453: NOT
79454: IFTRUE 79471
79456: PUSH
79457: LD_VAR 0 1
79461: PPUSH
79462: CALL_OW 263
79466: PUSH
79467: LD_INT 2
79469: NONEQUAL
79470: OR
79471: IFFALSE 79475
// exit ;
79473: GO 79791
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
79475: LD_ADDR_VAR 0 6
79479: PUSH
79480: LD_INT 22
79482: PUSH
79483: LD_VAR 0 1
79487: PPUSH
79488: CALL_OW 255
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 2
79499: PUSH
79500: LD_INT 30
79502: PUSH
79503: LD_INT 36
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 34
79512: PUSH
79513: LD_INT 31
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: EMPTY
79521: LIST
79522: LIST
79523: LIST
79524: PUSH
79525: EMPTY
79526: LIST
79527: LIST
79528: PPUSH
79529: CALL_OW 69
79533: ST_TO_ADDR
// if not tmp then
79534: LD_VAR 0 6
79538: NOT
79539: IFFALSE 79543
// exit ;
79541: GO 79791
// result := [ ] ;
79543: LD_ADDR_VAR 0 2
79547: PUSH
79548: EMPTY
79549: ST_TO_ADDR
// for i in tmp do
79550: LD_ADDR_VAR 0 3
79554: PUSH
79555: LD_VAR 0 6
79559: PUSH
79560: FOR_IN
79561: IFFALSE 79632
// begin t := UnitsInside ( i ) ;
79563: LD_ADDR_VAR 0 4
79567: PUSH
79568: LD_VAR 0 3
79572: PPUSH
79573: CALL_OW 313
79577: ST_TO_ADDR
// if t then
79578: LD_VAR 0 4
79582: IFFALSE 79630
// for j in t do
79584: LD_ADDR_VAR 0 7
79588: PUSH
79589: LD_VAR 0 4
79593: PUSH
79594: FOR_IN
79595: IFFALSE 79628
// result := Replace ( result , result + 1 , j ) ;
79597: LD_ADDR_VAR 0 2
79601: PUSH
79602: LD_VAR 0 2
79606: PPUSH
79607: LD_VAR 0 2
79611: PUSH
79612: LD_INT 1
79614: PLUS
79615: PPUSH
79616: LD_VAR 0 7
79620: PPUSH
79621: CALL_OW 1
79625: ST_TO_ADDR
79626: GO 79594
79628: POP
79629: POP
// end ;
79630: GO 79560
79632: POP
79633: POP
// if not result then
79634: LD_VAR 0 2
79638: NOT
79639: IFFALSE 79643
// exit ;
79641: GO 79791
// mech := result [ 1 ] ;
79643: LD_ADDR_VAR 0 5
79647: PUSH
79648: LD_VAR 0 2
79652: PUSH
79653: LD_INT 1
79655: ARRAY
79656: ST_TO_ADDR
// if result > 1 then
79657: LD_VAR 0 2
79661: PUSH
79662: LD_INT 1
79664: GREATER
79665: IFFALSE 79777
// begin for i = 2 to result do
79667: LD_ADDR_VAR 0 3
79671: PUSH
79672: DOUBLE
79673: LD_INT 2
79675: DEC
79676: ST_TO_ADDR
79677: LD_VAR 0 2
79681: PUSH
79682: FOR_TO
79683: IFFALSE 79775
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
79685: LD_ADDR_VAR 0 4
79689: PUSH
79690: LD_VAR 0 2
79694: PUSH
79695: LD_VAR 0 3
79699: ARRAY
79700: PPUSH
79701: LD_INT 3
79703: PPUSH
79704: CALL_OW 259
79708: PUSH
79709: LD_VAR 0 2
79713: PUSH
79714: LD_VAR 0 3
79718: ARRAY
79719: PPUSH
79720: CALL_OW 432
79724: MINUS
79725: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
79726: LD_VAR 0 4
79730: PUSH
79731: LD_VAR 0 5
79735: PPUSH
79736: LD_INT 3
79738: PPUSH
79739: CALL_OW 259
79743: PUSH
79744: LD_VAR 0 5
79748: PPUSH
79749: CALL_OW 432
79753: MINUS
79754: GREATEREQUAL
79755: IFFALSE 79773
// mech := result [ i ] ;
79757: LD_ADDR_VAR 0 5
79761: PUSH
79762: LD_VAR 0 2
79766: PUSH
79767: LD_VAR 0 3
79771: ARRAY
79772: ST_TO_ADDR
// end ;
79773: GO 79682
79775: POP
79776: POP
// end ; ComLinkTo ( vehicle , mech ) ;
79777: LD_VAR 0 1
79781: PPUSH
79782: LD_VAR 0 5
79786: PPUSH
79787: CALL_OW 135
// end ;
79791: LD_VAR 0 2
79795: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
79796: LD_INT 0
79798: PPUSH
79799: PPUSH
79800: PPUSH
79801: PPUSH
79802: PPUSH
79803: PPUSH
79804: PPUSH
79805: PPUSH
79806: PPUSH
79807: PPUSH
79808: PPUSH
79809: PPUSH
79810: PPUSH
// result := [ ] ;
79811: LD_ADDR_VAR 0 7
79815: PUSH
79816: EMPTY
79817: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
79818: LD_VAR 0 1
79822: PPUSH
79823: CALL_OW 266
79827: PUSH
79828: LD_INT 0
79830: PUSH
79831: LD_INT 1
79833: PUSH
79834: EMPTY
79835: LIST
79836: LIST
79837: IN
79838: NOT
79839: IFFALSE 79843
// exit ;
79841: GO 81483
// if name then
79843: LD_VAR 0 3
79847: IFFALSE 79863
// SetBName ( base_dep , name ) ;
79849: LD_VAR 0 1
79853: PPUSH
79854: LD_VAR 0 3
79858: PPUSH
79859: CALL_OW 500
// base := GetBase ( base_dep ) ;
79863: LD_ADDR_VAR 0 15
79867: PUSH
79868: LD_VAR 0 1
79872: PPUSH
79873: CALL_OW 274
79877: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
79878: LD_ADDR_VAR 0 16
79882: PUSH
79883: LD_VAR 0 1
79887: PPUSH
79888: CALL_OW 255
79892: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
79893: LD_ADDR_VAR 0 17
79897: PUSH
79898: LD_VAR 0 1
79902: PPUSH
79903: CALL_OW 248
79907: ST_TO_ADDR
// if sources then
79908: LD_VAR 0 5
79912: IFFALSE 79959
// for i = 1 to 3 do
79914: LD_ADDR_VAR 0 8
79918: PUSH
79919: DOUBLE
79920: LD_INT 1
79922: DEC
79923: ST_TO_ADDR
79924: LD_INT 3
79926: PUSH
79927: FOR_TO
79928: IFFALSE 79957
// AddResourceType ( base , i , sources [ i ] ) ;
79930: LD_VAR 0 15
79934: PPUSH
79935: LD_VAR 0 8
79939: PPUSH
79940: LD_VAR 0 5
79944: PUSH
79945: LD_VAR 0 8
79949: ARRAY
79950: PPUSH
79951: CALL_OW 276
79955: GO 79927
79957: POP
79958: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
79959: LD_ADDR_VAR 0 18
79963: PUSH
79964: LD_VAR 0 15
79968: PPUSH
79969: LD_VAR 0 2
79973: PPUSH
79974: LD_INT 1
79976: PPUSH
79977: CALL 79218 0 3
79981: ST_TO_ADDR
// InitHc ;
79982: CALL_OW 19
// InitUc ;
79986: CALL_OW 18
// uc_side := side ;
79990: LD_ADDR_OWVAR 20
79994: PUSH
79995: LD_VAR 0 16
79999: ST_TO_ADDR
// uc_nation := nation ;
80000: LD_ADDR_OWVAR 21
80004: PUSH
80005: LD_VAR 0 17
80009: ST_TO_ADDR
// if buildings then
80010: LD_VAR 0 18
80014: IFFALSE 81342
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
80016: LD_ADDR_VAR 0 19
80020: PUSH
80021: LD_VAR 0 18
80025: PPUSH
80026: LD_INT 2
80028: PUSH
80029: LD_INT 30
80031: PUSH
80032: LD_INT 29
80034: PUSH
80035: EMPTY
80036: LIST
80037: LIST
80038: PUSH
80039: LD_INT 30
80041: PUSH
80042: LD_INT 30
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: LIST
80053: PPUSH
80054: CALL_OW 72
80058: ST_TO_ADDR
// if tmp then
80059: LD_VAR 0 19
80063: IFFALSE 80111
// for i in tmp do
80065: LD_ADDR_VAR 0 8
80069: PUSH
80070: LD_VAR 0 19
80074: PUSH
80075: FOR_IN
80076: IFFALSE 80109
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
80078: LD_VAR 0 8
80082: PPUSH
80083: CALL_OW 250
80087: PPUSH
80088: LD_VAR 0 8
80092: PPUSH
80093: CALL_OW 251
80097: PPUSH
80098: LD_VAR 0 16
80102: PPUSH
80103: CALL_OW 441
80107: GO 80075
80109: POP
80110: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
80111: LD_VAR 0 18
80115: PPUSH
80116: LD_INT 2
80118: PUSH
80119: LD_INT 30
80121: PUSH
80122: LD_INT 32
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 30
80131: PUSH
80132: LD_INT 33
80134: PUSH
80135: EMPTY
80136: LIST
80137: LIST
80138: PUSH
80139: EMPTY
80140: LIST
80141: LIST
80142: LIST
80143: PPUSH
80144: CALL_OW 72
80148: IFFALSE 80236
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
80150: LD_ADDR_VAR 0 8
80154: PUSH
80155: LD_VAR 0 18
80159: PPUSH
80160: LD_INT 2
80162: PUSH
80163: LD_INT 30
80165: PUSH
80166: LD_INT 32
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: PUSH
80173: LD_INT 30
80175: PUSH
80176: LD_INT 33
80178: PUSH
80179: EMPTY
80180: LIST
80181: LIST
80182: PUSH
80183: EMPTY
80184: LIST
80185: LIST
80186: LIST
80187: PPUSH
80188: CALL_OW 72
80192: PUSH
80193: FOR_IN
80194: IFFALSE 80234
// begin if not GetBWeapon ( i ) then
80196: LD_VAR 0 8
80200: PPUSH
80201: CALL_OW 269
80205: NOT
80206: IFFALSE 80232
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
80208: LD_VAR 0 8
80212: PPUSH
80213: LD_VAR 0 8
80217: PPUSH
80218: LD_VAR 0 2
80222: PPUSH
80223: CALL 81488 0 2
80227: PPUSH
80228: CALL_OW 431
// end ;
80232: GO 80193
80234: POP
80235: POP
// end ; for i = 1 to personel do
80236: LD_ADDR_VAR 0 8
80240: PUSH
80241: DOUBLE
80242: LD_INT 1
80244: DEC
80245: ST_TO_ADDR
80246: LD_VAR 0 6
80250: PUSH
80251: FOR_TO
80252: IFFALSE 81322
// begin if i > 4 then
80254: LD_VAR 0 8
80258: PUSH
80259: LD_INT 4
80261: GREATER
80262: IFFALSE 80266
// break ;
80264: GO 81322
// case i of 1 :
80266: LD_VAR 0 8
80270: PUSH
80271: LD_INT 1
80273: DOUBLE
80274: EQUAL
80275: IFTRUE 80279
80277: GO 80359
80279: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
80280: LD_ADDR_VAR 0 12
80284: PUSH
80285: LD_VAR 0 18
80289: PPUSH
80290: LD_INT 22
80292: PUSH
80293: LD_VAR 0 16
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 58
80304: PUSH
80305: EMPTY
80306: LIST
80307: PUSH
80308: LD_INT 2
80310: PUSH
80311: LD_INT 30
80313: PUSH
80314: LD_INT 32
80316: PUSH
80317: EMPTY
80318: LIST
80319: LIST
80320: PUSH
80321: LD_INT 30
80323: PUSH
80324: LD_INT 4
80326: PUSH
80327: EMPTY
80328: LIST
80329: LIST
80330: PUSH
80331: LD_INT 30
80333: PUSH
80334: LD_INT 5
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: EMPTY
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: LIST
80351: PPUSH
80352: CALL_OW 72
80356: ST_TO_ADDR
80357: GO 80581
80359: LD_INT 2
80361: DOUBLE
80362: EQUAL
80363: IFTRUE 80367
80365: GO 80429
80367: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
80368: LD_ADDR_VAR 0 12
80372: PUSH
80373: LD_VAR 0 18
80377: PPUSH
80378: LD_INT 22
80380: PUSH
80381: LD_VAR 0 16
80385: PUSH
80386: EMPTY
80387: LIST
80388: LIST
80389: PUSH
80390: LD_INT 2
80392: PUSH
80393: LD_INT 30
80395: PUSH
80396: LD_INT 0
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 30
80405: PUSH
80406: LD_INT 1
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: EMPTY
80414: LIST
80415: LIST
80416: LIST
80417: PUSH
80418: EMPTY
80419: LIST
80420: LIST
80421: PPUSH
80422: CALL_OW 72
80426: ST_TO_ADDR
80427: GO 80581
80429: LD_INT 3
80431: DOUBLE
80432: EQUAL
80433: IFTRUE 80437
80435: GO 80499
80437: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
80438: LD_ADDR_VAR 0 12
80442: PUSH
80443: LD_VAR 0 18
80447: PPUSH
80448: LD_INT 22
80450: PUSH
80451: LD_VAR 0 16
80455: PUSH
80456: EMPTY
80457: LIST
80458: LIST
80459: PUSH
80460: LD_INT 2
80462: PUSH
80463: LD_INT 30
80465: PUSH
80466: LD_INT 2
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 30
80475: PUSH
80476: LD_INT 3
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: LIST
80487: PUSH
80488: EMPTY
80489: LIST
80490: LIST
80491: PPUSH
80492: CALL_OW 72
80496: ST_TO_ADDR
80497: GO 80581
80499: LD_INT 4
80501: DOUBLE
80502: EQUAL
80503: IFTRUE 80507
80505: GO 80580
80507: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
80508: LD_ADDR_VAR 0 12
80512: PUSH
80513: LD_VAR 0 18
80517: PPUSH
80518: LD_INT 22
80520: PUSH
80521: LD_VAR 0 16
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: PUSH
80530: LD_INT 2
80532: PUSH
80533: LD_INT 30
80535: PUSH
80536: LD_INT 6
80538: PUSH
80539: EMPTY
80540: LIST
80541: LIST
80542: PUSH
80543: LD_INT 30
80545: PUSH
80546: LD_INT 7
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: LD_INT 30
80555: PUSH
80556: LD_INT 8
80558: PUSH
80559: EMPTY
80560: LIST
80561: LIST
80562: PUSH
80563: EMPTY
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: PUSH
80569: EMPTY
80570: LIST
80571: LIST
80572: PPUSH
80573: CALL_OW 72
80577: ST_TO_ADDR
80578: GO 80581
80580: POP
// if i = 1 then
80581: LD_VAR 0 8
80585: PUSH
80586: LD_INT 1
80588: EQUAL
80589: IFFALSE 80700
// begin tmp := [ ] ;
80591: LD_ADDR_VAR 0 19
80595: PUSH
80596: EMPTY
80597: ST_TO_ADDR
// for j in f do
80598: LD_ADDR_VAR 0 9
80602: PUSH
80603: LD_VAR 0 12
80607: PUSH
80608: FOR_IN
80609: IFFALSE 80682
// if GetBType ( j ) = b_bunker then
80611: LD_VAR 0 9
80615: PPUSH
80616: CALL_OW 266
80620: PUSH
80621: LD_INT 32
80623: EQUAL
80624: IFFALSE 80651
// tmp := Insert ( tmp , 1 , j ) else
80626: LD_ADDR_VAR 0 19
80630: PUSH
80631: LD_VAR 0 19
80635: PPUSH
80636: LD_INT 1
80638: PPUSH
80639: LD_VAR 0 9
80643: PPUSH
80644: CALL_OW 2
80648: ST_TO_ADDR
80649: GO 80680
// tmp := Insert ( tmp , tmp + 1 , j ) ;
80651: LD_ADDR_VAR 0 19
80655: PUSH
80656: LD_VAR 0 19
80660: PPUSH
80661: LD_VAR 0 19
80665: PUSH
80666: LD_INT 1
80668: PLUS
80669: PPUSH
80670: LD_VAR 0 9
80674: PPUSH
80675: CALL_OW 2
80679: ST_TO_ADDR
80680: GO 80608
80682: POP
80683: POP
// if tmp then
80684: LD_VAR 0 19
80688: IFFALSE 80700
// f := tmp ;
80690: LD_ADDR_VAR 0 12
80694: PUSH
80695: LD_VAR 0 19
80699: ST_TO_ADDR
// end ; x := personel [ i ] ;
80700: LD_ADDR_VAR 0 13
80704: PUSH
80705: LD_VAR 0 6
80709: PUSH
80710: LD_VAR 0 8
80714: ARRAY
80715: ST_TO_ADDR
// if x = - 1 then
80716: LD_VAR 0 13
80720: PUSH
80721: LD_INT 1
80723: NEG
80724: EQUAL
80725: IFFALSE 80936
// begin for j in f do
80727: LD_ADDR_VAR 0 9
80731: PUSH
80732: LD_VAR 0 12
80736: PUSH
80737: FOR_IN
80738: IFFALSE 80932
// repeat InitHc ;
80740: CALL_OW 19
// if GetBType ( j ) = b_barracks then
80744: LD_VAR 0 9
80748: PPUSH
80749: CALL_OW 266
80753: PUSH
80754: LD_INT 5
80756: EQUAL
80757: IFFALSE 80827
// begin if UnitsInside ( j ) < 3 then
80759: LD_VAR 0 9
80763: PPUSH
80764: CALL_OW 313
80768: PUSH
80769: LD_INT 3
80771: LESS
80772: IFFALSE 80808
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
80774: LD_INT 0
80776: PPUSH
80777: LD_INT 5
80779: PUSH
80780: LD_INT 8
80782: PUSH
80783: LD_INT 9
80785: PUSH
80786: EMPTY
80787: LIST
80788: LIST
80789: LIST
80790: PUSH
80791: LD_VAR 0 17
80795: ARRAY
80796: PPUSH
80797: LD_VAR 0 4
80801: PPUSH
80802: CALL_OW 380
80806: GO 80825
// PrepareHuman ( false , i , skill ) ;
80808: LD_INT 0
80810: PPUSH
80811: LD_VAR 0 8
80815: PPUSH
80816: LD_VAR 0 4
80820: PPUSH
80821: CALL_OW 380
// end else
80825: GO 80844
// PrepareHuman ( false , i , skill ) ;
80827: LD_INT 0
80829: PPUSH
80830: LD_VAR 0 8
80834: PPUSH
80835: LD_VAR 0 4
80839: PPUSH
80840: CALL_OW 380
// un := CreateHuman ;
80844: LD_ADDR_VAR 0 14
80848: PUSH
80849: CALL_OW 44
80853: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80854: LD_ADDR_VAR 0 7
80858: PUSH
80859: LD_VAR 0 7
80863: PPUSH
80864: LD_INT 1
80866: PPUSH
80867: LD_VAR 0 14
80871: PPUSH
80872: CALL_OW 2
80876: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
80877: LD_VAR 0 14
80881: PPUSH
80882: LD_VAR 0 9
80886: PPUSH
80887: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
80891: LD_VAR 0 9
80895: PPUSH
80896: CALL_OW 313
80900: PUSH
80901: LD_INT 6
80903: EQUAL
80904: IFTRUE 80928
80906: PUSH
80907: LD_VAR 0 9
80911: PPUSH
80912: CALL_OW 266
80916: PUSH
80917: LD_INT 32
80919: PUSH
80920: LD_INT 31
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: IN
80927: OR
80928: IFFALSE 80740
80930: GO 80737
80932: POP
80933: POP
// end else
80934: GO 81320
// for j = 1 to x do
80936: LD_ADDR_VAR 0 9
80940: PUSH
80941: DOUBLE
80942: LD_INT 1
80944: DEC
80945: ST_TO_ADDR
80946: LD_VAR 0 13
80950: PUSH
80951: FOR_TO
80952: IFFALSE 81318
// begin InitHc ;
80954: CALL_OW 19
// if not f then
80958: LD_VAR 0 12
80962: NOT
80963: IFFALSE 81052
// begin PrepareHuman ( false , i , skill ) ;
80965: LD_INT 0
80967: PPUSH
80968: LD_VAR 0 8
80972: PPUSH
80973: LD_VAR 0 4
80977: PPUSH
80978: CALL_OW 380
// un := CreateHuman ;
80982: LD_ADDR_VAR 0 14
80986: PUSH
80987: CALL_OW 44
80991: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
80992: LD_ADDR_VAR 0 7
80996: PUSH
80997: LD_VAR 0 7
81001: PPUSH
81002: LD_INT 1
81004: PPUSH
81005: LD_VAR 0 14
81009: PPUSH
81010: CALL_OW 2
81014: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
81015: LD_VAR 0 14
81019: PPUSH
81020: LD_VAR 0 1
81024: PPUSH
81025: CALL_OW 250
81029: PPUSH
81030: LD_VAR 0 1
81034: PPUSH
81035: CALL_OW 251
81039: PPUSH
81040: LD_INT 10
81042: PPUSH
81043: LD_INT 0
81045: PPUSH
81046: CALL_OW 50
// continue ;
81050: GO 80951
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
81052: LD_VAR 0 12
81056: PUSH
81057: LD_INT 1
81059: ARRAY
81060: PPUSH
81061: CALL_OW 313
81065: IFFALSE 81093
81067: PUSH
81068: LD_VAR 0 12
81072: PUSH
81073: LD_INT 1
81075: ARRAY
81076: PPUSH
81077: CALL_OW 266
81081: PUSH
81082: LD_INT 32
81084: PUSH
81085: LD_INT 31
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: IN
81092: AND
81093: IFTRUE 81114
81095: PUSH
81096: LD_VAR 0 12
81100: PUSH
81101: LD_INT 1
81103: ARRAY
81104: PPUSH
81105: CALL_OW 313
81109: PUSH
81110: LD_INT 6
81112: EQUAL
81113: OR
81114: IFFALSE 81134
// f := Delete ( f , 1 ) ;
81116: LD_ADDR_VAR 0 12
81120: PUSH
81121: LD_VAR 0 12
81125: PPUSH
81126: LD_INT 1
81128: PPUSH
81129: CALL_OW 3
81133: ST_TO_ADDR
// if not f then
81134: LD_VAR 0 12
81138: NOT
81139: IFFALSE 81157
// begin x := x + 2 ;
81141: LD_ADDR_VAR 0 13
81145: PUSH
81146: LD_VAR 0 13
81150: PUSH
81151: LD_INT 2
81153: PLUS
81154: ST_TO_ADDR
// continue ;
81155: GO 80951
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
81157: LD_VAR 0 12
81161: PUSH
81162: LD_INT 1
81164: ARRAY
81165: PPUSH
81166: CALL_OW 266
81170: PUSH
81171: LD_INT 5
81173: EQUAL
81174: IFFALSE 81248
// begin if UnitsInside ( f [ 1 ] ) < 3 then
81176: LD_VAR 0 12
81180: PUSH
81181: LD_INT 1
81183: ARRAY
81184: PPUSH
81185: CALL_OW 313
81189: PUSH
81190: LD_INT 3
81192: LESS
81193: IFFALSE 81229
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
81195: LD_INT 0
81197: PPUSH
81198: LD_INT 5
81200: PUSH
81201: LD_INT 8
81203: PUSH
81204: LD_INT 9
81206: PUSH
81207: EMPTY
81208: LIST
81209: LIST
81210: LIST
81211: PUSH
81212: LD_VAR 0 17
81216: ARRAY
81217: PPUSH
81218: LD_VAR 0 4
81222: PPUSH
81223: CALL_OW 380
81227: GO 81246
// PrepareHuman ( false , i , skill ) ;
81229: LD_INT 0
81231: PPUSH
81232: LD_VAR 0 8
81236: PPUSH
81237: LD_VAR 0 4
81241: PPUSH
81242: CALL_OW 380
// end else
81246: GO 81265
// PrepareHuman ( false , i , skill ) ;
81248: LD_INT 0
81250: PPUSH
81251: LD_VAR 0 8
81255: PPUSH
81256: LD_VAR 0 4
81260: PPUSH
81261: CALL_OW 380
// un := CreateHuman ;
81265: LD_ADDR_VAR 0 14
81269: PUSH
81270: CALL_OW 44
81274: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
81275: LD_ADDR_VAR 0 7
81279: PUSH
81280: LD_VAR 0 7
81284: PPUSH
81285: LD_INT 1
81287: PPUSH
81288: LD_VAR 0 14
81292: PPUSH
81293: CALL_OW 2
81297: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
81298: LD_VAR 0 14
81302: PPUSH
81303: LD_VAR 0 12
81307: PUSH
81308: LD_INT 1
81310: ARRAY
81311: PPUSH
81312: CALL_OW 52
// end ;
81316: GO 80951
81318: POP
81319: POP
// end ;
81320: GO 80251
81322: POP
81323: POP
// result := result ^ buildings ;
81324: LD_ADDR_VAR 0 7
81328: PUSH
81329: LD_VAR 0 7
81333: PUSH
81334: LD_VAR 0 18
81338: ADD
81339: ST_TO_ADDR
// end else
81340: GO 81483
// begin for i = 1 to personel do
81342: LD_ADDR_VAR 0 8
81346: PUSH
81347: DOUBLE
81348: LD_INT 1
81350: DEC
81351: ST_TO_ADDR
81352: LD_VAR 0 6
81356: PUSH
81357: FOR_TO
81358: IFFALSE 81481
// begin if i > 4 then
81360: LD_VAR 0 8
81364: PUSH
81365: LD_INT 4
81367: GREATER
81368: IFFALSE 81372
// break ;
81370: GO 81481
// x := personel [ i ] ;
81372: LD_ADDR_VAR 0 13
81376: PUSH
81377: LD_VAR 0 6
81381: PUSH
81382: LD_VAR 0 8
81386: ARRAY
81387: ST_TO_ADDR
// if x = - 1 then
81388: LD_VAR 0 13
81392: PUSH
81393: LD_INT 1
81395: NEG
81396: EQUAL
81397: IFFALSE 81401
// continue ;
81399: GO 81357
// PrepareHuman ( false , i , skill ) ;
81401: LD_INT 0
81403: PPUSH
81404: LD_VAR 0 8
81408: PPUSH
81409: LD_VAR 0 4
81413: PPUSH
81414: CALL_OW 380
// un := CreateHuman ;
81418: LD_ADDR_VAR 0 14
81422: PUSH
81423: CALL_OW 44
81427: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
81428: LD_VAR 0 14
81432: PPUSH
81433: LD_VAR 0 1
81437: PPUSH
81438: CALL_OW 250
81442: PPUSH
81443: LD_VAR 0 1
81447: PPUSH
81448: CALL_OW 251
81452: PPUSH
81453: LD_INT 10
81455: PPUSH
81456: LD_INT 0
81458: PPUSH
81459: CALL_OW 50
// result := result ^ un ;
81463: LD_ADDR_VAR 0 7
81467: PUSH
81468: LD_VAR 0 7
81472: PUSH
81473: LD_VAR 0 14
81477: ADD
81478: ST_TO_ADDR
// end ;
81479: GO 81357
81481: POP
81482: POP
// end ; end ;
81483: LD_VAR 0 7
81487: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
81488: LD_INT 0
81490: PPUSH
81491: PPUSH
81492: PPUSH
81493: PPUSH
81494: PPUSH
81495: PPUSH
81496: PPUSH
81497: PPUSH
81498: PPUSH
81499: PPUSH
81500: PPUSH
81501: PPUSH
81502: PPUSH
81503: PPUSH
81504: PPUSH
81505: PPUSH
// result := false ;
81506: LD_ADDR_VAR 0 3
81510: PUSH
81511: LD_INT 0
81513: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
81514: LD_VAR 0 1
81518: NOT
81519: IFTRUE 81544
81521: PUSH
81522: LD_VAR 0 1
81526: PPUSH
81527: CALL_OW 266
81531: PUSH
81532: LD_INT 32
81534: PUSH
81535: LD_INT 33
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: IN
81542: NOT
81543: OR
81544: IFFALSE 81548
// exit ;
81546: GO 82683
// nat := GetNation ( tower ) ;
81548: LD_ADDR_VAR 0 12
81552: PUSH
81553: LD_VAR 0 1
81557: PPUSH
81558: CALL_OW 248
81562: ST_TO_ADDR
// side := GetSide ( tower ) ;
81563: LD_ADDR_VAR 0 16
81567: PUSH
81568: LD_VAR 0 1
81572: PPUSH
81573: CALL_OW 255
81577: ST_TO_ADDR
// x := GetX ( tower ) ;
81578: LD_ADDR_VAR 0 10
81582: PUSH
81583: LD_VAR 0 1
81587: PPUSH
81588: CALL_OW 250
81592: ST_TO_ADDR
// y := GetY ( tower ) ;
81593: LD_ADDR_VAR 0 11
81597: PUSH
81598: LD_VAR 0 1
81602: PPUSH
81603: CALL_OW 251
81607: ST_TO_ADDR
// if not x or not y then
81608: LD_VAR 0 10
81612: NOT
81613: IFTRUE 81622
81615: PUSH
81616: LD_VAR 0 11
81620: NOT
81621: OR
81622: IFFALSE 81626
// exit ;
81624: GO 82683
// weapon := 0 ;
81626: LD_ADDR_VAR 0 18
81630: PUSH
81631: LD_INT 0
81633: ST_TO_ADDR
// fac_list := [ ] ;
81634: LD_ADDR_VAR 0 17
81638: PUSH
81639: EMPTY
81640: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
81641: LD_ADDR_VAR 0 6
81645: PUSH
81646: LD_VAR 0 1
81650: PPUSH
81651: CALL_OW 274
81655: PPUSH
81656: LD_VAR 0 2
81660: PPUSH
81661: LD_INT 0
81663: PPUSH
81664: CALL 79218 0 3
81668: PPUSH
81669: LD_INT 30
81671: PUSH
81672: LD_INT 3
81674: PUSH
81675: EMPTY
81676: LIST
81677: LIST
81678: PPUSH
81679: CALL_OW 72
81683: ST_TO_ADDR
// if not factories then
81684: LD_VAR 0 6
81688: NOT
81689: IFFALSE 81693
// exit ;
81691: GO 82683
// for i in factories do
81693: LD_ADDR_VAR 0 8
81697: PUSH
81698: LD_VAR 0 6
81702: PUSH
81703: FOR_IN
81704: IFFALSE 81729
// fac_list := fac_list union AvailableWeaponList ( i ) ;
81706: LD_ADDR_VAR 0 17
81710: PUSH
81711: LD_VAR 0 17
81715: PUSH
81716: LD_VAR 0 8
81720: PPUSH
81721: CALL_OW 478
81725: UNION
81726: ST_TO_ADDR
81727: GO 81703
81729: POP
81730: POP
// if not fac_list then
81731: LD_VAR 0 17
81735: NOT
81736: IFFALSE 81740
// exit ;
81738: GO 82683
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
81740: LD_ADDR_VAR 0 5
81744: PUSH
81745: LD_INT 4
81747: PUSH
81748: LD_INT 5
81750: PUSH
81751: LD_INT 9
81753: PUSH
81754: LD_INT 10
81756: PUSH
81757: LD_INT 6
81759: PUSH
81760: LD_INT 7
81762: PUSH
81763: LD_INT 11
81765: PUSH
81766: EMPTY
81767: LIST
81768: LIST
81769: LIST
81770: LIST
81771: LIST
81772: LIST
81773: LIST
81774: PUSH
81775: LD_INT 27
81777: PUSH
81778: LD_INT 28
81780: PUSH
81781: LD_INT 26
81783: PUSH
81784: LD_INT 30
81786: PUSH
81787: EMPTY
81788: LIST
81789: LIST
81790: LIST
81791: LIST
81792: PUSH
81793: LD_INT 43
81795: PUSH
81796: LD_INT 44
81798: PUSH
81799: LD_INT 46
81801: PUSH
81802: LD_INT 45
81804: PUSH
81805: LD_INT 47
81807: PUSH
81808: LD_INT 49
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: LIST
81823: PUSH
81824: LD_VAR 0 12
81828: ARRAY
81829: ST_TO_ADDR
// list := list isect fac_list ;
81830: LD_ADDR_VAR 0 5
81834: PUSH
81835: LD_VAR 0 5
81839: PUSH
81840: LD_VAR 0 17
81844: ISECT
81845: ST_TO_ADDR
// if not list then
81846: LD_VAR 0 5
81850: NOT
81851: IFFALSE 81855
// exit ;
81853: GO 82683
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
81855: LD_VAR 0 12
81859: PUSH
81860: LD_INT 3
81862: EQUAL
81863: IFFALSE 81875
81865: PUSH
81866: LD_INT 49
81868: PUSH
81869: LD_VAR 0 5
81873: IN
81874: AND
81875: IFFALSE 81895
81877: PUSH
81878: LD_INT 31
81880: PPUSH
81881: LD_VAR 0 16
81885: PPUSH
81886: CALL_OW 321
81890: PUSH
81891: LD_INT 2
81893: EQUAL
81894: AND
81895: IFFALSE 81955
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
81897: LD_INT 22
81899: PUSH
81900: LD_VAR 0 16
81904: PUSH
81905: EMPTY
81906: LIST
81907: LIST
81908: PUSH
81909: LD_INT 35
81911: PUSH
81912: LD_INT 49
81914: PUSH
81915: EMPTY
81916: LIST
81917: LIST
81918: PUSH
81919: LD_INT 91
81921: PUSH
81922: LD_VAR 0 1
81926: PUSH
81927: LD_INT 10
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: LIST
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: LIST
81939: PPUSH
81940: CALL_OW 69
81944: NOT
81945: IFFALSE 81955
// weapon := ru_time_lapser ;
81947: LD_ADDR_VAR 0 18
81951: PUSH
81952: LD_INT 49
81954: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
81955: LD_VAR 0 12
81959: PUSH
81960: LD_INT 1
81962: PUSH
81963: LD_INT 2
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: IN
81970: IFFALSE 81994
81972: PUSH
81973: LD_INT 11
81975: PUSH
81976: LD_VAR 0 5
81980: IN
81981: IFTRUE 81993
81983: PUSH
81984: LD_INT 30
81986: PUSH
81987: LD_VAR 0 5
81991: IN
81992: OR
81993: AND
81994: IFFALSE 82014
81996: PUSH
81997: LD_INT 6
81999: PPUSH
82000: LD_VAR 0 16
82004: PPUSH
82005: CALL_OW 321
82009: PUSH
82010: LD_INT 2
82012: EQUAL
82013: AND
82014: IFFALSE 82181
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
82016: LD_INT 22
82018: PUSH
82019: LD_VAR 0 16
82023: PUSH
82024: EMPTY
82025: LIST
82026: LIST
82027: PUSH
82028: LD_INT 2
82030: PUSH
82031: LD_INT 35
82033: PUSH
82034: LD_INT 11
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: PUSH
82041: LD_INT 35
82043: PUSH
82044: LD_INT 30
82046: PUSH
82047: EMPTY
82048: LIST
82049: LIST
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: LIST
82055: PUSH
82056: LD_INT 91
82058: PUSH
82059: LD_VAR 0 1
82063: PUSH
82064: LD_INT 18
82066: PUSH
82067: EMPTY
82068: LIST
82069: LIST
82070: LIST
82071: PUSH
82072: EMPTY
82073: LIST
82074: LIST
82075: LIST
82076: PPUSH
82077: CALL_OW 69
82081: NOT
82082: IFFALSE 82158
82084: PUSH
82085: LD_INT 22
82087: PUSH
82088: LD_VAR 0 16
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: PUSH
82097: LD_INT 2
82099: PUSH
82100: LD_INT 30
82102: PUSH
82103: LD_INT 32
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: PUSH
82110: LD_INT 30
82112: PUSH
82113: LD_INT 33
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: EMPTY
82121: LIST
82122: LIST
82123: LIST
82124: PUSH
82125: LD_INT 91
82127: PUSH
82128: LD_VAR 0 1
82132: PUSH
82133: LD_INT 12
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: LIST
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: LIST
82145: PUSH
82146: EMPTY
82147: LIST
82148: PPUSH
82149: CALL_OW 69
82153: PUSH
82154: LD_INT 2
82156: GREATER
82157: AND
82158: IFFALSE 82181
// weapon := [ us_radar , ar_radar ] [ nat ] ;
82160: LD_ADDR_VAR 0 18
82164: PUSH
82165: LD_INT 11
82167: PUSH
82168: LD_INT 30
82170: PUSH
82171: EMPTY
82172: LIST
82173: LIST
82174: PUSH
82175: LD_VAR 0 12
82179: ARRAY
82180: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
82181: LD_VAR 0 18
82185: NOT
82186: IFFALSE 82206
82188: PUSH
82189: LD_INT 40
82191: PPUSH
82192: LD_VAR 0 16
82196: PPUSH
82197: CALL_OW 321
82201: PUSH
82202: LD_INT 2
82204: EQUAL
82205: AND
82206: IFFALSE 82242
82208: PUSH
82209: LD_INT 7
82211: PUSH
82212: LD_VAR 0 5
82216: IN
82217: IFTRUE 82229
82219: PUSH
82220: LD_INT 28
82222: PUSH
82223: LD_VAR 0 5
82227: IN
82228: OR
82229: IFTRUE 82241
82231: PUSH
82232: LD_INT 45
82234: PUSH
82235: LD_VAR 0 5
82239: IN
82240: OR
82241: AND
82242: IFFALSE 82496
// begin hex := GetHexInfo ( x , y ) ;
82244: LD_ADDR_VAR 0 4
82248: PUSH
82249: LD_VAR 0 10
82253: PPUSH
82254: LD_VAR 0 11
82258: PPUSH
82259: CALL_OW 546
82263: ST_TO_ADDR
// if hex [ 1 ] then
82264: LD_VAR 0 4
82268: PUSH
82269: LD_INT 1
82271: ARRAY
82272: IFFALSE 82276
// exit ;
82274: GO 82683
// height := hex [ 2 ] ;
82276: LD_ADDR_VAR 0 15
82280: PUSH
82281: LD_VAR 0 4
82285: PUSH
82286: LD_INT 2
82288: ARRAY
82289: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
82290: LD_ADDR_VAR 0 14
82294: PUSH
82295: LD_INT 0
82297: PUSH
82298: LD_INT 2
82300: PUSH
82301: LD_INT 3
82303: PUSH
82304: LD_INT 5
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: LIST
82311: LIST
82312: ST_TO_ADDR
// for i in tmp do
82313: LD_ADDR_VAR 0 8
82317: PUSH
82318: LD_VAR 0 14
82322: PUSH
82323: FOR_IN
82324: IFFALSE 82494
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
82326: LD_ADDR_VAR 0 9
82330: PUSH
82331: LD_VAR 0 10
82335: PPUSH
82336: LD_VAR 0 8
82340: PPUSH
82341: LD_INT 5
82343: PPUSH
82344: CALL_OW 272
82348: PUSH
82349: LD_VAR 0 11
82353: PPUSH
82354: LD_VAR 0 8
82358: PPUSH
82359: LD_INT 5
82361: PPUSH
82362: CALL_OW 273
82366: PUSH
82367: EMPTY
82368: LIST
82369: LIST
82370: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
82371: LD_VAR 0 9
82375: PUSH
82376: LD_INT 1
82378: ARRAY
82379: PPUSH
82380: LD_VAR 0 9
82384: PUSH
82385: LD_INT 2
82387: ARRAY
82388: PPUSH
82389: CALL_OW 488
82393: IFFALSE 82492
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
82395: LD_ADDR_VAR 0 4
82399: PUSH
82400: LD_VAR 0 9
82404: PUSH
82405: LD_INT 1
82407: ARRAY
82408: PPUSH
82409: LD_VAR 0 9
82413: PUSH
82414: LD_INT 2
82416: ARRAY
82417: PPUSH
82418: CALL_OW 546
82422: ST_TO_ADDR
// if hex [ 1 ] then
82423: LD_VAR 0 4
82427: PUSH
82428: LD_INT 1
82430: ARRAY
82431: IFFALSE 82435
// continue ;
82433: GO 82323
// h := hex [ 2 ] ;
82435: LD_ADDR_VAR 0 13
82439: PUSH
82440: LD_VAR 0 4
82444: PUSH
82445: LD_INT 2
82447: ARRAY
82448: ST_TO_ADDR
// if h + 7 < height then
82449: LD_VAR 0 13
82453: PUSH
82454: LD_INT 7
82456: PLUS
82457: PUSH
82458: LD_VAR 0 15
82462: LESS
82463: IFFALSE 82492
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
82465: LD_ADDR_VAR 0 18
82469: PUSH
82470: LD_INT 7
82472: PUSH
82473: LD_INT 28
82475: PUSH
82476: LD_INT 45
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: LIST
82483: PUSH
82484: LD_VAR 0 12
82488: ARRAY
82489: ST_TO_ADDR
// break ;
82490: GO 82494
// end ; end ; end ;
82492: GO 82323
82494: POP
82495: POP
// end ; if not weapon then
82496: LD_VAR 0 18
82500: NOT
82501: IFFALSE 82561
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
82503: LD_ADDR_VAR 0 5
82507: PUSH
82508: LD_VAR 0 5
82512: PUSH
82513: LD_INT 11
82515: PUSH
82516: LD_INT 30
82518: PUSH
82519: LD_INT 49
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: LIST
82526: DIFF
82527: ST_TO_ADDR
// if not list then
82528: LD_VAR 0 5
82532: NOT
82533: IFFALSE 82537
// exit ;
82535: GO 82683
// weapon := list [ rand ( 1 , list ) ] ;
82537: LD_ADDR_VAR 0 18
82541: PUSH
82542: LD_VAR 0 5
82546: PUSH
82547: LD_INT 1
82549: PPUSH
82550: LD_VAR 0 5
82554: PPUSH
82555: CALL_OW 12
82559: ARRAY
82560: ST_TO_ADDR
// end ; if weapon then
82561: LD_VAR 0 18
82565: IFFALSE 82683
// begin tmp := CostOfWeapon ( weapon ) ;
82567: LD_ADDR_VAR 0 14
82571: PUSH
82572: LD_VAR 0 18
82576: PPUSH
82577: CALL_OW 451
82581: ST_TO_ADDR
// j := GetBase ( tower ) ;
82582: LD_ADDR_VAR 0 9
82586: PUSH
82587: LD_VAR 0 1
82591: PPUSH
82592: CALL_OW 274
82596: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
82597: LD_VAR 0 9
82601: PPUSH
82602: LD_INT 1
82604: PPUSH
82605: CALL_OW 275
82609: PUSH
82610: LD_VAR 0 14
82614: PUSH
82615: LD_INT 1
82617: ARRAY
82618: GREATEREQUAL
82619: IFFALSE 82645
82621: PUSH
82622: LD_VAR 0 9
82626: PPUSH
82627: LD_INT 2
82629: PPUSH
82630: CALL_OW 275
82634: PUSH
82635: LD_VAR 0 14
82639: PUSH
82640: LD_INT 2
82642: ARRAY
82643: GREATEREQUAL
82644: AND
82645: IFFALSE 82671
82647: PUSH
82648: LD_VAR 0 9
82652: PPUSH
82653: LD_INT 3
82655: PPUSH
82656: CALL_OW 275
82660: PUSH
82661: LD_VAR 0 14
82665: PUSH
82666: LD_INT 3
82668: ARRAY
82669: GREATEREQUAL
82670: AND
82671: IFFALSE 82683
// result := weapon ;
82673: LD_ADDR_VAR 0 3
82677: PUSH
82678: LD_VAR 0 18
82682: ST_TO_ADDR
// end ; end ;
82683: LD_VAR 0 3
82687: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
82688: LD_INT 0
82690: PPUSH
82691: PPUSH
// result := true ;
82692: LD_ADDR_VAR 0 3
82696: PUSH
82697: LD_INT 1
82699: ST_TO_ADDR
// if array1 = array2 then
82700: LD_VAR 0 1
82704: PUSH
82705: LD_VAR 0 2
82709: EQUAL
82710: IFFALSE 82770
// begin for i = 1 to array1 do
82712: LD_ADDR_VAR 0 4
82716: PUSH
82717: DOUBLE
82718: LD_INT 1
82720: DEC
82721: ST_TO_ADDR
82722: LD_VAR 0 1
82726: PUSH
82727: FOR_TO
82728: IFFALSE 82766
// if array1 [ i ] <> array2 [ i ] then
82730: LD_VAR 0 1
82734: PUSH
82735: LD_VAR 0 4
82739: ARRAY
82740: PUSH
82741: LD_VAR 0 2
82745: PUSH
82746: LD_VAR 0 4
82750: ARRAY
82751: NONEQUAL
82752: IFFALSE 82764
// begin result := false ;
82754: LD_ADDR_VAR 0 3
82758: PUSH
82759: LD_INT 0
82761: ST_TO_ADDR
// break ;
82762: GO 82766
// end ;
82764: GO 82727
82766: POP
82767: POP
// end else
82768: GO 82778
// result := false ;
82770: LD_ADDR_VAR 0 3
82774: PUSH
82775: LD_INT 0
82777: ST_TO_ADDR
// end ;
82778: LD_VAR 0 3
82782: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
82783: LD_INT 0
82785: PPUSH
82786: PPUSH
// if not array1 or not array2 then
82787: LD_VAR 0 1
82791: NOT
82792: IFTRUE 82801
82794: PUSH
82795: LD_VAR 0 2
82799: NOT
82800: OR
82801: IFFALSE 82805
// exit ;
82803: GO 82869
// result := true ;
82805: LD_ADDR_VAR 0 3
82809: PUSH
82810: LD_INT 1
82812: ST_TO_ADDR
// for i = 1 to array1 do
82813: LD_ADDR_VAR 0 4
82817: PUSH
82818: DOUBLE
82819: LD_INT 1
82821: DEC
82822: ST_TO_ADDR
82823: LD_VAR 0 1
82827: PUSH
82828: FOR_TO
82829: IFFALSE 82867
// if array1 [ i ] <> array2 [ i ] then
82831: LD_VAR 0 1
82835: PUSH
82836: LD_VAR 0 4
82840: ARRAY
82841: PUSH
82842: LD_VAR 0 2
82846: PUSH
82847: LD_VAR 0 4
82851: ARRAY
82852: NONEQUAL
82853: IFFALSE 82865
// begin result := false ;
82855: LD_ADDR_VAR 0 3
82859: PUSH
82860: LD_INT 0
82862: ST_TO_ADDR
// break ;
82863: GO 82867
// end ;
82865: GO 82828
82867: POP
82868: POP
// end ;
82869: LD_VAR 0 3
82873: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
82874: LD_INT 0
82876: PPUSH
82877: PPUSH
82878: PPUSH
// pom := GetBase ( fac ) ;
82879: LD_ADDR_VAR 0 5
82883: PUSH
82884: LD_VAR 0 1
82888: PPUSH
82889: CALL_OW 274
82893: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
82894: LD_ADDR_VAR 0 4
82898: PUSH
82899: LD_VAR 0 2
82903: PUSH
82904: LD_INT 1
82906: ARRAY
82907: PPUSH
82908: LD_VAR 0 2
82912: PUSH
82913: LD_INT 2
82915: ARRAY
82916: PPUSH
82917: LD_VAR 0 2
82921: PUSH
82922: LD_INT 3
82924: ARRAY
82925: PPUSH
82926: LD_VAR 0 2
82930: PUSH
82931: LD_INT 4
82933: ARRAY
82934: PPUSH
82935: CALL_OW 449
82939: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
82940: LD_ADDR_VAR 0 3
82944: PUSH
82945: LD_VAR 0 5
82949: PPUSH
82950: LD_INT 1
82952: PPUSH
82953: CALL_OW 275
82957: PUSH
82958: LD_VAR 0 4
82962: PUSH
82963: LD_INT 1
82965: ARRAY
82966: GREATEREQUAL
82967: IFFALSE 82993
82969: PUSH
82970: LD_VAR 0 5
82974: PPUSH
82975: LD_INT 2
82977: PPUSH
82978: CALL_OW 275
82982: PUSH
82983: LD_VAR 0 4
82987: PUSH
82988: LD_INT 2
82990: ARRAY
82991: GREATEREQUAL
82992: AND
82993: IFFALSE 83019
82995: PUSH
82996: LD_VAR 0 5
83000: PPUSH
83001: LD_INT 3
83003: PPUSH
83004: CALL_OW 275
83008: PUSH
83009: LD_VAR 0 4
83013: PUSH
83014: LD_INT 3
83016: ARRAY
83017: GREATEREQUAL
83018: AND
83019: ST_TO_ADDR
// end ;
83020: LD_VAR 0 3
83024: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
83025: LD_INT 0
83027: PPUSH
83028: PPUSH
83029: PPUSH
83030: PPUSH
// pom := GetBase ( building ) ;
83031: LD_ADDR_VAR 0 3
83035: PUSH
83036: LD_VAR 0 1
83040: PPUSH
83041: CALL_OW 274
83045: ST_TO_ADDR
// if not pom then
83046: LD_VAR 0 3
83050: NOT
83051: IFFALSE 83055
// exit ;
83053: GO 83229
// btype := GetBType ( building ) ;
83055: LD_ADDR_VAR 0 5
83059: PUSH
83060: LD_VAR 0 1
83064: PPUSH
83065: CALL_OW 266
83069: ST_TO_ADDR
// if btype = b_armoury then
83070: LD_VAR 0 5
83074: PUSH
83075: LD_INT 4
83077: EQUAL
83078: IFFALSE 83088
// btype := b_barracks ;
83080: LD_ADDR_VAR 0 5
83084: PUSH
83085: LD_INT 5
83087: ST_TO_ADDR
// if btype = b_depot then
83088: LD_VAR 0 5
83092: PUSH
83093: LD_INT 0
83095: EQUAL
83096: IFFALSE 83106
// btype := b_warehouse ;
83098: LD_ADDR_VAR 0 5
83102: PUSH
83103: LD_INT 1
83105: ST_TO_ADDR
// if btype = b_workshop then
83106: LD_VAR 0 5
83110: PUSH
83111: LD_INT 2
83113: EQUAL
83114: IFFALSE 83124
// btype := b_factory ;
83116: LD_ADDR_VAR 0 5
83120: PUSH
83121: LD_INT 3
83123: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
83124: LD_ADDR_VAR 0 4
83128: PUSH
83129: LD_VAR 0 5
83133: PPUSH
83134: LD_VAR 0 1
83138: PPUSH
83139: CALL_OW 248
83143: PPUSH
83144: CALL_OW 450
83148: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
83149: LD_ADDR_VAR 0 2
83153: PUSH
83154: LD_VAR 0 3
83158: PPUSH
83159: LD_INT 1
83161: PPUSH
83162: CALL_OW 275
83166: PUSH
83167: LD_VAR 0 4
83171: PUSH
83172: LD_INT 1
83174: ARRAY
83175: GREATEREQUAL
83176: IFFALSE 83202
83178: PUSH
83179: LD_VAR 0 3
83183: PPUSH
83184: LD_INT 2
83186: PPUSH
83187: CALL_OW 275
83191: PUSH
83192: LD_VAR 0 4
83196: PUSH
83197: LD_INT 2
83199: ARRAY
83200: GREATEREQUAL
83201: AND
83202: IFFALSE 83228
83204: PUSH
83205: LD_VAR 0 3
83209: PPUSH
83210: LD_INT 3
83212: PPUSH
83213: CALL_OW 275
83217: PUSH
83218: LD_VAR 0 4
83222: PUSH
83223: LD_INT 3
83225: ARRAY
83226: GREATEREQUAL
83227: AND
83228: ST_TO_ADDR
// end ;
83229: LD_VAR 0 2
83233: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
83234: LD_INT 0
83236: PPUSH
83237: PPUSH
83238: PPUSH
// pom := GetBase ( building ) ;
83239: LD_ADDR_VAR 0 4
83243: PUSH
83244: LD_VAR 0 1
83248: PPUSH
83249: CALL_OW 274
83253: ST_TO_ADDR
// if not pom then
83254: LD_VAR 0 4
83258: NOT
83259: IFFALSE 83263
// exit ;
83261: GO 83368
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
83263: LD_ADDR_VAR 0 5
83267: PUSH
83268: LD_VAR 0 2
83272: PPUSH
83273: LD_VAR 0 1
83277: PPUSH
83278: CALL_OW 248
83282: PPUSH
83283: CALL_OW 450
83287: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
83288: LD_ADDR_VAR 0 3
83292: PUSH
83293: LD_VAR 0 4
83297: PPUSH
83298: LD_INT 1
83300: PPUSH
83301: CALL_OW 275
83305: PUSH
83306: LD_VAR 0 5
83310: PUSH
83311: LD_INT 1
83313: ARRAY
83314: GREATEREQUAL
83315: IFFALSE 83341
83317: PUSH
83318: LD_VAR 0 4
83322: PPUSH
83323: LD_INT 2
83325: PPUSH
83326: CALL_OW 275
83330: PUSH
83331: LD_VAR 0 5
83335: PUSH
83336: LD_INT 2
83338: ARRAY
83339: GREATEREQUAL
83340: AND
83341: IFFALSE 83367
83343: PUSH
83344: LD_VAR 0 4
83348: PPUSH
83349: LD_INT 3
83351: PPUSH
83352: CALL_OW 275
83356: PUSH
83357: LD_VAR 0 5
83361: PUSH
83362: LD_INT 3
83364: ARRAY
83365: GREATEREQUAL
83366: AND
83367: ST_TO_ADDR
// end ;
83368: LD_VAR 0 3
83372: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
83373: LD_INT 0
83375: PPUSH
83376: PPUSH
83377: PPUSH
83378: PPUSH
83379: PPUSH
83380: PPUSH
83381: PPUSH
83382: PPUSH
83383: PPUSH
83384: PPUSH
83385: PPUSH
// result := false ;
83386: LD_ADDR_VAR 0 8
83390: PUSH
83391: LD_INT 0
83393: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
83394: LD_VAR 0 5
83398: NOT
83399: IFTRUE 83408
83401: PUSH
83402: LD_VAR 0 1
83406: NOT
83407: OR
83408: IFTRUE 83417
83410: PUSH
83411: LD_VAR 0 2
83415: NOT
83416: OR
83417: IFTRUE 83426
83419: PUSH
83420: LD_VAR 0 3
83424: NOT
83425: OR
83426: IFFALSE 83430
// exit ;
83428: GO 84256
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
83430: LD_ADDR_VAR 0 14
83434: PUSH
83435: LD_VAR 0 1
83439: PPUSH
83440: LD_VAR 0 2
83444: PPUSH
83445: LD_VAR 0 3
83449: PPUSH
83450: LD_VAR 0 4
83454: PPUSH
83455: LD_VAR 0 5
83459: PUSH
83460: LD_INT 1
83462: ARRAY
83463: PPUSH
83464: CALL_OW 248
83468: PPUSH
83469: LD_INT 0
83471: PPUSH
83472: CALL 85537 0 6
83476: ST_TO_ADDR
// if not hexes then
83477: LD_VAR 0 14
83481: NOT
83482: IFFALSE 83486
// exit ;
83484: GO 84256
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
83486: LD_ADDR_VAR 0 17
83490: PUSH
83491: LD_VAR 0 5
83495: PPUSH
83496: LD_INT 22
83498: PUSH
83499: LD_VAR 0 13
83503: PPUSH
83504: CALL_OW 255
83508: PUSH
83509: EMPTY
83510: LIST
83511: LIST
83512: PUSH
83513: LD_INT 2
83515: PUSH
83516: LD_INT 30
83518: PUSH
83519: LD_INT 0
83521: PUSH
83522: EMPTY
83523: LIST
83524: LIST
83525: PUSH
83526: LD_INT 30
83528: PUSH
83529: LD_INT 1
83531: PUSH
83532: EMPTY
83533: LIST
83534: LIST
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: LIST
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: PPUSH
83545: CALL_OW 72
83549: ST_TO_ADDR
// for i = 1 to hexes do
83550: LD_ADDR_VAR 0 9
83554: PUSH
83555: DOUBLE
83556: LD_INT 1
83558: DEC
83559: ST_TO_ADDR
83560: LD_VAR 0 14
83564: PUSH
83565: FOR_TO
83566: IFFALSE 84254
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
83568: LD_ADDR_VAR 0 13
83572: PUSH
83573: LD_VAR 0 14
83577: PUSH
83578: LD_VAR 0 9
83582: ARRAY
83583: PUSH
83584: LD_INT 1
83586: ARRAY
83587: PPUSH
83588: LD_VAR 0 14
83592: PUSH
83593: LD_VAR 0 9
83597: ARRAY
83598: PUSH
83599: LD_INT 2
83601: ARRAY
83602: PPUSH
83603: CALL_OW 428
83607: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
83608: LD_VAR 0 14
83612: PUSH
83613: LD_VAR 0 9
83617: ARRAY
83618: PUSH
83619: LD_INT 1
83621: ARRAY
83622: PPUSH
83623: LD_VAR 0 14
83627: PUSH
83628: LD_VAR 0 9
83632: ARRAY
83633: PUSH
83634: LD_INT 2
83636: ARRAY
83637: PPUSH
83638: CALL_OW 351
83642: IFTRUE 83681
83644: PUSH
83645: LD_VAR 0 14
83649: PUSH
83650: LD_VAR 0 9
83654: ARRAY
83655: PUSH
83656: LD_INT 1
83658: ARRAY
83659: PPUSH
83660: LD_VAR 0 14
83664: PUSH
83665: LD_VAR 0 9
83669: ARRAY
83670: PUSH
83671: LD_INT 2
83673: ARRAY
83674: PPUSH
83675: CALL_OW 488
83679: NOT
83680: OR
83681: IFTRUE 83698
83683: PUSH
83684: LD_VAR 0 13
83688: PPUSH
83689: CALL_OW 247
83693: PUSH
83694: LD_INT 3
83696: EQUAL
83697: OR
83698: IFFALSE 83704
// exit ;
83700: POP
83701: POP
83702: GO 84256
// if not tmp then
83704: LD_VAR 0 13
83708: NOT
83709: IFFALSE 83713
// continue ;
83711: GO 83565
// result := true ;
83713: LD_ADDR_VAR 0 8
83717: PUSH
83718: LD_INT 1
83720: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
83721: LD_VAR 0 6
83725: IFFALSE 83742
83727: PUSH
83728: LD_VAR 0 13
83732: PPUSH
83733: CALL_OW 247
83737: PUSH
83738: LD_INT 2
83740: EQUAL
83741: AND
83742: IFFALSE 83759
83744: PUSH
83745: LD_VAR 0 13
83749: PPUSH
83750: CALL_OW 263
83754: PUSH
83755: LD_INT 1
83757: EQUAL
83758: AND
83759: IFFALSE 83923
// begin if IsDrivenBy ( tmp ) then
83761: LD_VAR 0 13
83765: PPUSH
83766: CALL_OW 311
83770: IFFALSE 83774
// continue ;
83772: GO 83565
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
83774: LD_VAR 0 6
83778: PPUSH
83779: LD_INT 3
83781: PUSH
83782: LD_INT 60
83784: PUSH
83785: EMPTY
83786: LIST
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 3
83794: PUSH
83795: LD_INT 55
83797: PUSH
83798: EMPTY
83799: LIST
83800: PUSH
83801: EMPTY
83802: LIST
83803: LIST
83804: PUSH
83805: EMPTY
83806: LIST
83807: LIST
83808: PPUSH
83809: CALL_OW 72
83813: IFFALSE 83921
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
83815: LD_ADDR_VAR 0 18
83819: PUSH
83820: LD_VAR 0 6
83824: PPUSH
83825: LD_INT 3
83827: PUSH
83828: LD_INT 60
83830: PUSH
83831: EMPTY
83832: LIST
83833: PUSH
83834: EMPTY
83835: LIST
83836: LIST
83837: PUSH
83838: LD_INT 3
83840: PUSH
83841: LD_INT 55
83843: PUSH
83844: EMPTY
83845: LIST
83846: PUSH
83847: EMPTY
83848: LIST
83849: LIST
83850: PUSH
83851: EMPTY
83852: LIST
83853: LIST
83854: PPUSH
83855: CALL_OW 72
83859: PUSH
83860: LD_INT 1
83862: ARRAY
83863: ST_TO_ADDR
// if IsInUnit ( driver ) then
83864: LD_VAR 0 18
83868: PPUSH
83869: CALL_OW 310
83873: IFFALSE 83884
// ComExit ( driver ) ;
83875: LD_VAR 0 18
83879: PPUSH
83880: CALL 109537 0 1
// AddComEnterUnit ( driver , tmp ) ;
83884: LD_VAR 0 18
83888: PPUSH
83889: LD_VAR 0 13
83893: PPUSH
83894: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
83898: LD_VAR 0 18
83902: PPUSH
83903: LD_VAR 0 7
83907: PPUSH
83908: CALL_OW 173
// AddComExitVehicle ( driver ) ;
83912: LD_VAR 0 18
83916: PPUSH
83917: CALL_OW 181
// end ; continue ;
83921: GO 83565
// end ; if not cleaners or not tmp in cleaners then
83923: LD_VAR 0 6
83927: NOT
83928: IFTRUE 83943
83930: PUSH
83931: LD_VAR 0 13
83935: PUSH
83936: LD_VAR 0 6
83940: IN
83941: NOT
83942: OR
83943: IFFALSE 84252
// begin if dep then
83945: LD_VAR 0 17
83949: IFFALSE 84085
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
83951: LD_ADDR_VAR 0 16
83955: PUSH
83956: LD_VAR 0 17
83960: PUSH
83961: LD_INT 1
83963: ARRAY
83964: PPUSH
83965: CALL_OW 250
83969: PPUSH
83970: LD_VAR 0 17
83974: PUSH
83975: LD_INT 1
83977: ARRAY
83978: PPUSH
83979: CALL_OW 254
83983: PPUSH
83984: LD_INT 5
83986: PPUSH
83987: CALL_OW 272
83991: PUSH
83992: LD_VAR 0 17
83996: PUSH
83997: LD_INT 1
83999: ARRAY
84000: PPUSH
84001: CALL_OW 251
84005: PPUSH
84006: LD_VAR 0 17
84010: PUSH
84011: LD_INT 1
84013: ARRAY
84014: PPUSH
84015: CALL_OW 254
84019: PPUSH
84020: LD_INT 5
84022: PPUSH
84023: CALL_OW 273
84027: PUSH
84028: EMPTY
84029: LIST
84030: LIST
84031: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
84032: LD_VAR 0 16
84036: PUSH
84037: LD_INT 1
84039: ARRAY
84040: PPUSH
84041: LD_VAR 0 16
84045: PUSH
84046: LD_INT 2
84048: ARRAY
84049: PPUSH
84050: CALL_OW 488
84054: IFFALSE 84085
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
84056: LD_VAR 0 13
84060: PPUSH
84061: LD_VAR 0 16
84065: PUSH
84066: LD_INT 1
84068: ARRAY
84069: PPUSH
84070: LD_VAR 0 16
84074: PUSH
84075: LD_INT 2
84077: ARRAY
84078: PPUSH
84079: CALL_OW 111
// continue ;
84083: GO 83565
// end ; end ; r := GetDir ( tmp ) ;
84085: LD_ADDR_VAR 0 15
84089: PUSH
84090: LD_VAR 0 13
84094: PPUSH
84095: CALL_OW 254
84099: ST_TO_ADDR
// if r = 5 then
84100: LD_VAR 0 15
84104: PUSH
84105: LD_INT 5
84107: EQUAL
84108: IFFALSE 84118
// r := 0 ;
84110: LD_ADDR_VAR 0 15
84114: PUSH
84115: LD_INT 0
84117: ST_TO_ADDR
// for j = r to 5 do
84118: LD_ADDR_VAR 0 10
84122: PUSH
84123: DOUBLE
84124: LD_VAR 0 15
84128: DEC
84129: ST_TO_ADDR
84130: LD_INT 5
84132: PUSH
84133: FOR_TO
84134: IFFALSE 84250
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
84136: LD_ADDR_VAR 0 11
84140: PUSH
84141: LD_VAR 0 13
84145: PPUSH
84146: CALL_OW 250
84150: PPUSH
84151: LD_VAR 0 10
84155: PPUSH
84156: LD_INT 2
84158: PPUSH
84159: CALL_OW 272
84163: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
84164: LD_ADDR_VAR 0 12
84168: PUSH
84169: LD_VAR 0 13
84173: PPUSH
84174: CALL_OW 251
84178: PPUSH
84179: LD_VAR 0 10
84183: PPUSH
84184: LD_INT 2
84186: PPUSH
84187: CALL_OW 273
84191: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
84192: LD_VAR 0 11
84196: PPUSH
84197: LD_VAR 0 12
84201: PPUSH
84202: CALL_OW 488
84206: IFFALSE 84225
84208: PUSH
84209: LD_VAR 0 11
84213: PPUSH
84214: LD_VAR 0 12
84218: PPUSH
84219: CALL_OW 428
84223: NOT
84224: AND
84225: IFFALSE 84248
// begin ComMoveXY ( tmp , _x , _y ) ;
84227: LD_VAR 0 13
84231: PPUSH
84232: LD_VAR 0 11
84236: PPUSH
84237: LD_VAR 0 12
84241: PPUSH
84242: CALL_OW 111
// break ;
84246: GO 84250
// end ; end ;
84248: GO 84133
84250: POP
84251: POP
// end ; end ;
84252: GO 83565
84254: POP
84255: POP
// end ;
84256: LD_VAR 0 8
84260: RET
// export function BuildingTechInvented ( side , btype ) ; begin
84261: LD_INT 0
84263: PPUSH
// result := true ;
84264: LD_ADDR_VAR 0 3
84268: PUSH
84269: LD_INT 1
84271: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
84272: LD_VAR 0 2
84276: PUSH
84277: LD_INT 24
84279: DOUBLE
84280: EQUAL
84281: IFTRUE 84291
84283: LD_INT 33
84285: DOUBLE
84286: EQUAL
84287: IFTRUE 84291
84289: GO 84316
84291: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
84292: LD_ADDR_VAR 0 3
84296: PUSH
84297: LD_INT 32
84299: PPUSH
84300: LD_VAR 0 1
84304: PPUSH
84305: CALL_OW 321
84309: PUSH
84310: LD_INT 2
84312: EQUAL
84313: ST_TO_ADDR
84314: GO 84632
84316: LD_INT 20
84318: DOUBLE
84319: EQUAL
84320: IFTRUE 84324
84322: GO 84349
84324: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
84325: LD_ADDR_VAR 0 3
84329: PUSH
84330: LD_INT 6
84332: PPUSH
84333: LD_VAR 0 1
84337: PPUSH
84338: CALL_OW 321
84342: PUSH
84343: LD_INT 2
84345: EQUAL
84346: ST_TO_ADDR
84347: GO 84632
84349: LD_INT 22
84351: DOUBLE
84352: EQUAL
84353: IFTRUE 84363
84355: LD_INT 36
84357: DOUBLE
84358: EQUAL
84359: IFTRUE 84363
84361: GO 84388
84363: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
84364: LD_ADDR_VAR 0 3
84368: PUSH
84369: LD_INT 15
84371: PPUSH
84372: LD_VAR 0 1
84376: PPUSH
84377: CALL_OW 321
84381: PUSH
84382: LD_INT 2
84384: EQUAL
84385: ST_TO_ADDR
84386: GO 84632
84388: LD_INT 30
84390: DOUBLE
84391: EQUAL
84392: IFTRUE 84396
84394: GO 84421
84396: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
84397: LD_ADDR_VAR 0 3
84401: PUSH
84402: LD_INT 20
84404: PPUSH
84405: LD_VAR 0 1
84409: PPUSH
84410: CALL_OW 321
84414: PUSH
84415: LD_INT 2
84417: EQUAL
84418: ST_TO_ADDR
84419: GO 84632
84421: LD_INT 28
84423: DOUBLE
84424: EQUAL
84425: IFTRUE 84435
84427: LD_INT 21
84429: DOUBLE
84430: EQUAL
84431: IFTRUE 84435
84433: GO 84460
84435: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
84436: LD_ADDR_VAR 0 3
84440: PUSH
84441: LD_INT 21
84443: PPUSH
84444: LD_VAR 0 1
84448: PPUSH
84449: CALL_OW 321
84453: PUSH
84454: LD_INT 2
84456: EQUAL
84457: ST_TO_ADDR
84458: GO 84632
84460: LD_INT 16
84462: DOUBLE
84463: EQUAL
84464: IFTRUE 84468
84466: GO 84493
84468: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
84469: LD_ADDR_VAR 0 3
84473: PUSH
84474: LD_INT 84
84476: PPUSH
84477: LD_VAR 0 1
84481: PPUSH
84482: CALL_OW 321
84486: PUSH
84487: LD_INT 2
84489: EQUAL
84490: ST_TO_ADDR
84491: GO 84632
84493: LD_INT 19
84495: DOUBLE
84496: EQUAL
84497: IFTRUE 84507
84499: LD_INT 23
84501: DOUBLE
84502: EQUAL
84503: IFTRUE 84507
84505: GO 84532
84507: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
84508: LD_ADDR_VAR 0 3
84512: PUSH
84513: LD_INT 83
84515: PPUSH
84516: LD_VAR 0 1
84520: PPUSH
84521: CALL_OW 321
84525: PUSH
84526: LD_INT 2
84528: EQUAL
84529: ST_TO_ADDR
84530: GO 84632
84532: LD_INT 17
84534: DOUBLE
84535: EQUAL
84536: IFTRUE 84540
84538: GO 84565
84540: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
84541: LD_ADDR_VAR 0 3
84545: PUSH
84546: LD_INT 39
84548: PPUSH
84549: LD_VAR 0 1
84553: PPUSH
84554: CALL_OW 321
84558: PUSH
84559: LD_INT 2
84561: EQUAL
84562: ST_TO_ADDR
84563: GO 84632
84565: LD_INT 18
84567: DOUBLE
84568: EQUAL
84569: IFTRUE 84573
84571: GO 84598
84573: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
84574: LD_ADDR_VAR 0 3
84578: PUSH
84579: LD_INT 40
84581: PPUSH
84582: LD_VAR 0 1
84586: PPUSH
84587: CALL_OW 321
84591: PUSH
84592: LD_INT 2
84594: EQUAL
84595: ST_TO_ADDR
84596: GO 84632
84598: LD_INT 27
84600: DOUBLE
84601: EQUAL
84602: IFTRUE 84606
84604: GO 84631
84606: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
84607: LD_ADDR_VAR 0 3
84611: PUSH
84612: LD_INT 35
84614: PPUSH
84615: LD_VAR 0 1
84619: PPUSH
84620: CALL_OW 321
84624: PUSH
84625: LD_INT 2
84627: EQUAL
84628: ST_TO_ADDR
84629: GO 84632
84631: POP
// end ;
84632: LD_VAR 0 3
84636: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
84637: LD_INT 0
84639: PPUSH
84640: PPUSH
84641: PPUSH
84642: PPUSH
84643: PPUSH
84644: PPUSH
84645: PPUSH
84646: PPUSH
84647: PPUSH
84648: PPUSH
84649: PPUSH
// result := false ;
84650: LD_ADDR_VAR 0 6
84654: PUSH
84655: LD_INT 0
84657: ST_TO_ADDR
// if btype = b_depot then
84658: LD_VAR 0 2
84662: PUSH
84663: LD_INT 0
84665: EQUAL
84666: IFFALSE 84678
// begin result := true ;
84668: LD_ADDR_VAR 0 6
84672: PUSH
84673: LD_INT 1
84675: ST_TO_ADDR
// exit ;
84676: GO 85532
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
84678: LD_VAR 0 1
84682: NOT
84683: IFTRUE 84708
84685: PUSH
84686: LD_VAR 0 1
84690: PPUSH
84691: CALL_OW 266
84695: PUSH
84696: LD_INT 0
84698: PUSH
84699: LD_INT 1
84701: PUSH
84702: EMPTY
84703: LIST
84704: LIST
84705: IN
84706: NOT
84707: OR
84708: IFTRUE 84717
84710: PUSH
84711: LD_VAR 0 2
84715: NOT
84716: OR
84717: IFTRUE 84753
84719: PUSH
84720: LD_VAR 0 5
84724: PUSH
84725: LD_INT 0
84727: PUSH
84728: LD_INT 1
84730: PUSH
84731: LD_INT 2
84733: PUSH
84734: LD_INT 3
84736: PUSH
84737: LD_INT 4
84739: PUSH
84740: LD_INT 5
84742: PUSH
84743: EMPTY
84744: LIST
84745: LIST
84746: LIST
84747: LIST
84748: LIST
84749: LIST
84750: IN
84751: NOT
84752: OR
84753: IFTRUE 84772
84755: PUSH
84756: LD_VAR 0 3
84760: PPUSH
84761: LD_VAR 0 4
84765: PPUSH
84766: CALL_OW 488
84770: NOT
84771: OR
84772: IFFALSE 84776
// exit ;
84774: GO 85532
// side := GetSide ( depot ) ;
84776: LD_ADDR_VAR 0 9
84780: PUSH
84781: LD_VAR 0 1
84785: PPUSH
84786: CALL_OW 255
84790: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
84791: LD_VAR 0 9
84795: PPUSH
84796: LD_VAR 0 2
84800: PPUSH
84801: CALL 84261 0 2
84805: NOT
84806: IFFALSE 84810
// exit ;
84808: GO 85532
// pom := GetBase ( depot ) ;
84810: LD_ADDR_VAR 0 10
84814: PUSH
84815: LD_VAR 0 1
84819: PPUSH
84820: CALL_OW 274
84824: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
84825: LD_ADDR_VAR 0 11
84829: PUSH
84830: LD_VAR 0 2
84834: PPUSH
84835: LD_VAR 0 1
84839: PPUSH
84840: CALL_OW 248
84844: PPUSH
84845: CALL_OW 450
84849: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
84850: LD_VAR 0 10
84854: PPUSH
84855: LD_INT 1
84857: PPUSH
84858: CALL_OW 275
84862: PUSH
84863: LD_VAR 0 11
84867: PUSH
84868: LD_INT 1
84870: ARRAY
84871: GREATEREQUAL
84872: IFFALSE 84898
84874: PUSH
84875: LD_VAR 0 10
84879: PPUSH
84880: LD_INT 2
84882: PPUSH
84883: CALL_OW 275
84887: PUSH
84888: LD_VAR 0 11
84892: PUSH
84893: LD_INT 2
84895: ARRAY
84896: GREATEREQUAL
84897: AND
84898: IFFALSE 84924
84900: PUSH
84901: LD_VAR 0 10
84905: PPUSH
84906: LD_INT 3
84908: PPUSH
84909: CALL_OW 275
84913: PUSH
84914: LD_VAR 0 11
84918: PUSH
84919: LD_INT 3
84921: ARRAY
84922: GREATEREQUAL
84923: AND
84924: NOT
84925: IFFALSE 84929
// exit ;
84927: GO 85532
// if GetBType ( depot ) = b_depot then
84929: LD_VAR 0 1
84933: PPUSH
84934: CALL_OW 266
84938: PUSH
84939: LD_INT 0
84941: EQUAL
84942: IFFALSE 84954
// dist := 28 else
84944: LD_ADDR_VAR 0 14
84948: PUSH
84949: LD_INT 28
84951: ST_TO_ADDR
84952: GO 84962
// dist := 36 ;
84954: LD_ADDR_VAR 0 14
84958: PUSH
84959: LD_INT 36
84961: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
84962: LD_VAR 0 1
84966: PPUSH
84967: LD_VAR 0 3
84971: PPUSH
84972: LD_VAR 0 4
84976: PPUSH
84977: CALL_OW 297
84981: PUSH
84982: LD_VAR 0 14
84986: GREATER
84987: IFFALSE 84991
// exit ;
84989: GO 85532
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
84991: LD_ADDR_VAR 0 12
84995: PUSH
84996: LD_VAR 0 2
85000: PPUSH
85001: LD_VAR 0 3
85005: PPUSH
85006: LD_VAR 0 4
85010: PPUSH
85011: LD_VAR 0 5
85015: PPUSH
85016: LD_VAR 0 1
85020: PPUSH
85021: CALL_OW 248
85025: PPUSH
85026: LD_INT 0
85028: PPUSH
85029: CALL 85537 0 6
85033: ST_TO_ADDR
// if not hexes then
85034: LD_VAR 0 12
85038: NOT
85039: IFFALSE 85043
// exit ;
85041: GO 85532
// hex := GetHexInfo ( x , y ) ;
85043: LD_ADDR_VAR 0 15
85047: PUSH
85048: LD_VAR 0 3
85052: PPUSH
85053: LD_VAR 0 4
85057: PPUSH
85058: CALL_OW 546
85062: ST_TO_ADDR
// if hex [ 1 ] then
85063: LD_VAR 0 15
85067: PUSH
85068: LD_INT 1
85070: ARRAY
85071: IFFALSE 85075
// exit ;
85073: GO 85532
// height := hex [ 2 ] ;
85075: LD_ADDR_VAR 0 13
85079: PUSH
85080: LD_VAR 0 15
85084: PUSH
85085: LD_INT 2
85087: ARRAY
85088: ST_TO_ADDR
// for i = 1 to hexes do
85089: LD_ADDR_VAR 0 7
85093: PUSH
85094: DOUBLE
85095: LD_INT 1
85097: DEC
85098: ST_TO_ADDR
85099: LD_VAR 0 12
85103: PUSH
85104: FOR_TO
85105: IFFALSE 85449
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
85107: LD_VAR 0 12
85111: PUSH
85112: LD_VAR 0 7
85116: ARRAY
85117: PUSH
85118: LD_INT 1
85120: ARRAY
85121: PPUSH
85122: LD_VAR 0 12
85126: PUSH
85127: LD_VAR 0 7
85131: ARRAY
85132: PUSH
85133: LD_INT 2
85135: ARRAY
85136: PPUSH
85137: CALL_OW 488
85141: NOT
85142: IFTRUE 85184
85144: PUSH
85145: LD_VAR 0 12
85149: PUSH
85150: LD_VAR 0 7
85154: ARRAY
85155: PUSH
85156: LD_INT 1
85158: ARRAY
85159: PPUSH
85160: LD_VAR 0 12
85164: PUSH
85165: LD_VAR 0 7
85169: ARRAY
85170: PUSH
85171: LD_INT 2
85173: ARRAY
85174: PPUSH
85175: CALL_OW 428
85179: PUSH
85180: LD_INT 0
85182: GREATER
85183: OR
85184: IFTRUE 85222
85186: PUSH
85187: LD_VAR 0 12
85191: PUSH
85192: LD_VAR 0 7
85196: ARRAY
85197: PUSH
85198: LD_INT 1
85200: ARRAY
85201: PPUSH
85202: LD_VAR 0 12
85206: PUSH
85207: LD_VAR 0 7
85211: ARRAY
85212: PUSH
85213: LD_INT 2
85215: ARRAY
85216: PPUSH
85217: CALL_OW 351
85221: OR
85222: IFFALSE 85228
// exit ;
85224: POP
85225: POP
85226: GO 85532
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
85228: LD_ADDR_VAR 0 8
85232: PUSH
85233: LD_VAR 0 12
85237: PUSH
85238: LD_VAR 0 7
85242: ARRAY
85243: PUSH
85244: LD_INT 1
85246: ARRAY
85247: PPUSH
85248: LD_VAR 0 12
85252: PUSH
85253: LD_VAR 0 7
85257: ARRAY
85258: PUSH
85259: LD_INT 2
85261: ARRAY
85262: PPUSH
85263: CALL_OW 546
85267: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
85268: LD_VAR 0 8
85272: PUSH
85273: LD_INT 1
85275: ARRAY
85276: IFTRUE 85298
85278: PUSH
85279: LD_VAR 0 8
85283: PUSH
85284: LD_INT 2
85286: ARRAY
85287: PUSH
85288: LD_VAR 0 13
85292: PUSH
85293: LD_INT 2
85295: PLUS
85296: GREATER
85297: OR
85298: IFTRUE 85320
85300: PUSH
85301: LD_VAR 0 8
85305: PUSH
85306: LD_INT 2
85308: ARRAY
85309: PUSH
85310: LD_VAR 0 13
85314: PUSH
85315: LD_INT 2
85317: MINUS
85318: LESS
85319: OR
85320: IFTRUE 85388
85322: PUSH
85323: LD_VAR 0 8
85327: PUSH
85328: LD_INT 3
85330: ARRAY
85331: PUSH
85332: LD_INT 0
85334: PUSH
85335: LD_INT 8
85337: PUSH
85338: LD_INT 9
85340: PUSH
85341: LD_INT 10
85343: PUSH
85344: LD_INT 11
85346: PUSH
85347: LD_INT 12
85349: PUSH
85350: LD_INT 13
85352: PUSH
85353: LD_INT 16
85355: PUSH
85356: LD_INT 17
85358: PUSH
85359: LD_INT 18
85361: PUSH
85362: LD_INT 19
85364: PUSH
85365: LD_INT 20
85367: PUSH
85368: LD_INT 21
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: LIST
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: IN
85386: NOT
85387: OR
85388: IFTRUE 85401
85390: PUSH
85391: LD_VAR 0 8
85395: PUSH
85396: LD_INT 5
85398: ARRAY
85399: NOT
85400: OR
85401: IFTRUE 85441
85403: PUSH
85404: LD_VAR 0 8
85408: PUSH
85409: LD_INT 6
85411: ARRAY
85412: PUSH
85413: LD_INT 1
85415: PUSH
85416: LD_INT 2
85418: PUSH
85419: LD_INT 7
85421: PUSH
85422: LD_INT 9
85424: PUSH
85425: LD_INT 10
85427: PUSH
85428: LD_INT 11
85430: PUSH
85431: EMPTY
85432: LIST
85433: LIST
85434: LIST
85435: LIST
85436: LIST
85437: LIST
85438: IN
85439: NOT
85440: OR
85441: IFFALSE 85447
// exit ;
85443: POP
85444: POP
85445: GO 85532
// end ;
85447: GO 85104
85449: POP
85450: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
85451: LD_VAR 0 9
85455: PPUSH
85456: LD_VAR 0 3
85460: PPUSH
85461: LD_VAR 0 4
85465: PPUSH
85466: LD_INT 20
85468: PPUSH
85469: CALL 77351 0 4
85473: PUSH
85474: LD_INT 4
85476: ARRAY
85477: IFFALSE 85481
// exit ;
85479: GO 85532
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
85481: LD_VAR 0 2
85485: PUSH
85486: LD_INT 29
85488: PUSH
85489: LD_INT 30
85491: PUSH
85492: EMPTY
85493: LIST
85494: LIST
85495: IN
85496: IFFALSE 85520
85498: PUSH
85499: LD_VAR 0 3
85503: PPUSH
85504: LD_VAR 0 4
85508: PPUSH
85509: LD_VAR 0 9
85513: PPUSH
85514: CALL_OW 440
85518: NOT
85519: AND
85520: IFFALSE 85524
// exit ;
85522: GO 85532
// result := true ;
85524: LD_ADDR_VAR 0 6
85528: PUSH
85529: LD_INT 1
85531: ST_TO_ADDR
// end ;
85532: LD_VAR 0 6
85536: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
85537: LD_INT 0
85539: PPUSH
85540: PPUSH
85541: PPUSH
85542: PPUSH
85543: PPUSH
85544: PPUSH
85545: PPUSH
85546: PPUSH
85547: PPUSH
85548: PPUSH
85549: PPUSH
85550: PPUSH
85551: PPUSH
85552: PPUSH
85553: PPUSH
85554: PPUSH
85555: PPUSH
85556: PPUSH
85557: PPUSH
85558: PPUSH
85559: PPUSH
85560: PPUSH
85561: PPUSH
85562: PPUSH
85563: PPUSH
85564: PPUSH
85565: PPUSH
85566: PPUSH
85567: PPUSH
85568: PPUSH
85569: PPUSH
85570: PPUSH
85571: PPUSH
85572: PPUSH
85573: PPUSH
85574: PPUSH
85575: PPUSH
85576: PPUSH
85577: PPUSH
85578: PPUSH
85579: PPUSH
85580: PPUSH
85581: PPUSH
85582: PPUSH
85583: PPUSH
85584: PPUSH
85585: PPUSH
85586: PPUSH
85587: PPUSH
85588: PPUSH
85589: PPUSH
85590: PPUSH
85591: PPUSH
85592: PPUSH
85593: PPUSH
85594: PPUSH
85595: PPUSH
85596: PPUSH
// result = [ ] ;
85597: LD_ADDR_VAR 0 7
85601: PUSH
85602: EMPTY
85603: ST_TO_ADDR
// temp_list = [ ] ;
85604: LD_ADDR_VAR 0 9
85608: PUSH
85609: EMPTY
85610: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
85611: LD_VAR 0 4
85615: PUSH
85616: LD_INT 0
85618: PUSH
85619: LD_INT 1
85621: PUSH
85622: LD_INT 2
85624: PUSH
85625: LD_INT 3
85627: PUSH
85628: LD_INT 4
85630: PUSH
85631: LD_INT 5
85633: PUSH
85634: EMPTY
85635: LIST
85636: LIST
85637: LIST
85638: LIST
85639: LIST
85640: LIST
85641: IN
85642: NOT
85643: IFTRUE 85686
85645: PUSH
85646: LD_VAR 0 1
85650: PUSH
85651: LD_INT 0
85653: PUSH
85654: LD_INT 1
85656: PUSH
85657: EMPTY
85658: LIST
85659: LIST
85660: IN
85661: IFFALSE 85685
85663: PUSH
85664: LD_VAR 0 5
85668: PUSH
85669: LD_INT 1
85671: PUSH
85672: LD_INT 2
85674: PUSH
85675: LD_INT 3
85677: PUSH
85678: EMPTY
85679: LIST
85680: LIST
85681: LIST
85682: IN
85683: NOT
85684: AND
85685: OR
85686: IFFALSE 85690
// exit ;
85688: GO 104089
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
85690: LD_VAR 0 1
85694: PUSH
85695: LD_INT 6
85697: PUSH
85698: LD_INT 7
85700: PUSH
85701: LD_INT 8
85703: PUSH
85704: LD_INT 13
85706: PUSH
85707: LD_INT 12
85709: PUSH
85710: LD_INT 15
85712: PUSH
85713: LD_INT 11
85715: PUSH
85716: LD_INT 14
85718: PUSH
85719: LD_INT 10
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: LIST
85726: LIST
85727: LIST
85728: LIST
85729: LIST
85730: LIST
85731: LIST
85732: IN
85733: IFFALSE 85743
// btype = b_lab ;
85735: LD_ADDR_VAR 0 1
85739: PUSH
85740: LD_INT 6
85742: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
85743: LD_VAR 0 6
85747: PUSH
85748: LD_INT 0
85750: PUSH
85751: LD_INT 1
85753: PUSH
85754: LD_INT 2
85756: PUSH
85757: EMPTY
85758: LIST
85759: LIST
85760: LIST
85761: IN
85762: NOT
85763: IFTRUE 85831
85765: PUSH
85766: LD_VAR 0 1
85770: PUSH
85771: LD_INT 0
85773: PUSH
85774: LD_INT 1
85776: PUSH
85777: LD_INT 2
85779: PUSH
85780: LD_INT 3
85782: PUSH
85783: LD_INT 6
85785: PUSH
85786: LD_INT 36
85788: PUSH
85789: LD_INT 4
85791: PUSH
85792: LD_INT 5
85794: PUSH
85795: LD_INT 31
85797: PUSH
85798: LD_INT 32
85800: PUSH
85801: LD_INT 33
85803: PUSH
85804: EMPTY
85805: LIST
85806: LIST
85807: LIST
85808: LIST
85809: LIST
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: LIST
85815: LIST
85816: IN
85817: NOT
85818: IFFALSE 85830
85820: PUSH
85821: LD_VAR 0 6
85825: PUSH
85826: LD_INT 1
85828: EQUAL
85829: AND
85830: OR
85831: IFTRUE 85863
85833: PUSH
85834: LD_VAR 0 1
85838: PUSH
85839: LD_INT 2
85841: PUSH
85842: LD_INT 3
85844: PUSH
85845: EMPTY
85846: LIST
85847: LIST
85848: IN
85849: NOT
85850: IFFALSE 85862
85852: PUSH
85853: LD_VAR 0 6
85857: PUSH
85858: LD_INT 2
85860: EQUAL
85861: AND
85862: OR
85863: IFFALSE 85873
// mode = 0 ;
85865: LD_ADDR_VAR 0 6
85869: PUSH
85870: LD_INT 0
85872: ST_TO_ADDR
// case mode of 0 :
85873: LD_VAR 0 6
85877: PUSH
85878: LD_INT 0
85880: DOUBLE
85881: EQUAL
85882: IFTRUE 85886
85884: GO 97339
85886: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
85887: LD_ADDR_VAR 0 11
85891: PUSH
85892: LD_INT 0
85894: PUSH
85895: LD_INT 0
85897: PUSH
85898: EMPTY
85899: LIST
85900: LIST
85901: PUSH
85902: LD_INT 0
85904: PUSH
85905: LD_INT 1
85907: NEG
85908: PUSH
85909: EMPTY
85910: LIST
85911: LIST
85912: PUSH
85913: LD_INT 1
85915: PUSH
85916: LD_INT 0
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 1
85925: PUSH
85926: LD_INT 1
85928: PUSH
85929: EMPTY
85930: LIST
85931: LIST
85932: PUSH
85933: LD_INT 0
85935: PUSH
85936: LD_INT 1
85938: PUSH
85939: EMPTY
85940: LIST
85941: LIST
85942: PUSH
85943: LD_INT 1
85945: NEG
85946: PUSH
85947: LD_INT 0
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 1
85956: NEG
85957: PUSH
85958: LD_INT 1
85960: NEG
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: LD_INT 1
85968: NEG
85969: PUSH
85970: LD_INT 2
85972: NEG
85973: PUSH
85974: EMPTY
85975: LIST
85976: LIST
85977: PUSH
85978: LD_INT 0
85980: PUSH
85981: LD_INT 2
85983: NEG
85984: PUSH
85985: EMPTY
85986: LIST
85987: LIST
85988: PUSH
85989: LD_INT 1
85991: PUSH
85992: LD_INT 1
85994: NEG
85995: PUSH
85996: EMPTY
85997: LIST
85998: LIST
85999: PUSH
86000: LD_INT 1
86002: PUSH
86003: LD_INT 2
86005: PUSH
86006: EMPTY
86007: LIST
86008: LIST
86009: PUSH
86010: LD_INT 0
86012: PUSH
86013: LD_INT 2
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: PUSH
86020: LD_INT 1
86022: NEG
86023: PUSH
86024: LD_INT 1
86026: PUSH
86027: EMPTY
86028: LIST
86029: LIST
86030: PUSH
86031: LD_INT 1
86033: PUSH
86034: LD_INT 3
86036: PUSH
86037: EMPTY
86038: LIST
86039: LIST
86040: PUSH
86041: LD_INT 0
86043: PUSH
86044: LD_INT 3
86046: PUSH
86047: EMPTY
86048: LIST
86049: LIST
86050: PUSH
86051: LD_INT 1
86053: NEG
86054: PUSH
86055: LD_INT 2
86057: PUSH
86058: EMPTY
86059: LIST
86060: LIST
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: LIST
86066: LIST
86067: LIST
86068: LIST
86069: LIST
86070: LIST
86071: LIST
86072: LIST
86073: LIST
86074: LIST
86075: LIST
86076: LIST
86077: LIST
86078: LIST
86079: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86080: LD_ADDR_VAR 0 12
86084: PUSH
86085: LD_INT 0
86087: PUSH
86088: LD_INT 0
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 0
86097: PUSH
86098: LD_INT 1
86100: NEG
86101: PUSH
86102: EMPTY
86103: LIST
86104: LIST
86105: PUSH
86106: LD_INT 1
86108: PUSH
86109: LD_INT 0
86111: PUSH
86112: EMPTY
86113: LIST
86114: LIST
86115: PUSH
86116: LD_INT 1
86118: PUSH
86119: LD_INT 1
86121: PUSH
86122: EMPTY
86123: LIST
86124: LIST
86125: PUSH
86126: LD_INT 0
86128: PUSH
86129: LD_INT 1
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: PUSH
86136: LD_INT 1
86138: NEG
86139: PUSH
86140: LD_INT 0
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 1
86149: NEG
86150: PUSH
86151: LD_INT 1
86153: NEG
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: PUSH
86159: LD_INT 1
86161: PUSH
86162: LD_INT 1
86164: NEG
86165: PUSH
86166: EMPTY
86167: LIST
86168: LIST
86169: PUSH
86170: LD_INT 2
86172: PUSH
86173: LD_INT 0
86175: PUSH
86176: EMPTY
86177: LIST
86178: LIST
86179: PUSH
86180: LD_INT 2
86182: PUSH
86183: LD_INT 1
86185: PUSH
86186: EMPTY
86187: LIST
86188: LIST
86189: PUSH
86190: LD_INT 1
86192: NEG
86193: PUSH
86194: LD_INT 1
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: LD_INT 2
86203: NEG
86204: PUSH
86205: LD_INT 0
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: PUSH
86212: LD_INT 2
86214: NEG
86215: PUSH
86216: LD_INT 1
86218: NEG
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: PUSH
86224: LD_INT 2
86226: NEG
86227: PUSH
86228: LD_INT 1
86230: PUSH
86231: EMPTY
86232: LIST
86233: LIST
86234: PUSH
86235: LD_INT 3
86237: NEG
86238: PUSH
86239: LD_INT 0
86241: PUSH
86242: EMPTY
86243: LIST
86244: LIST
86245: PUSH
86246: LD_INT 3
86248: NEG
86249: PUSH
86250: LD_INT 1
86252: NEG
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: PUSH
86258: EMPTY
86259: LIST
86260: LIST
86261: LIST
86262: LIST
86263: LIST
86264: LIST
86265: LIST
86266: LIST
86267: LIST
86268: LIST
86269: LIST
86270: LIST
86271: LIST
86272: LIST
86273: LIST
86274: LIST
86275: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86276: LD_ADDR_VAR 0 13
86280: PUSH
86281: LD_INT 0
86283: PUSH
86284: LD_INT 0
86286: PUSH
86287: EMPTY
86288: LIST
86289: LIST
86290: PUSH
86291: LD_INT 0
86293: PUSH
86294: LD_INT 1
86296: NEG
86297: PUSH
86298: EMPTY
86299: LIST
86300: LIST
86301: PUSH
86302: LD_INT 1
86304: PUSH
86305: LD_INT 0
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PUSH
86312: LD_INT 1
86314: PUSH
86315: LD_INT 1
86317: PUSH
86318: EMPTY
86319: LIST
86320: LIST
86321: PUSH
86322: LD_INT 0
86324: PUSH
86325: LD_INT 1
86327: PUSH
86328: EMPTY
86329: LIST
86330: LIST
86331: PUSH
86332: LD_INT 1
86334: NEG
86335: PUSH
86336: LD_INT 0
86338: PUSH
86339: EMPTY
86340: LIST
86341: LIST
86342: PUSH
86343: LD_INT 1
86345: NEG
86346: PUSH
86347: LD_INT 1
86349: NEG
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: PUSH
86355: LD_INT 1
86357: NEG
86358: PUSH
86359: LD_INT 2
86361: NEG
86362: PUSH
86363: EMPTY
86364: LIST
86365: LIST
86366: PUSH
86367: LD_INT 2
86369: PUSH
86370: LD_INT 1
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 2
86379: PUSH
86380: LD_INT 2
86382: PUSH
86383: EMPTY
86384: LIST
86385: LIST
86386: PUSH
86387: LD_INT 1
86389: PUSH
86390: LD_INT 2
86392: PUSH
86393: EMPTY
86394: LIST
86395: LIST
86396: PUSH
86397: LD_INT 2
86399: NEG
86400: PUSH
86401: LD_INT 1
86403: NEG
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 2
86411: NEG
86412: PUSH
86413: LD_INT 2
86415: NEG
86416: PUSH
86417: EMPTY
86418: LIST
86419: LIST
86420: PUSH
86421: LD_INT 2
86423: NEG
86424: PUSH
86425: LD_INT 3
86427: NEG
86428: PUSH
86429: EMPTY
86430: LIST
86431: LIST
86432: PUSH
86433: LD_INT 3
86435: NEG
86436: PUSH
86437: LD_INT 2
86439: NEG
86440: PUSH
86441: EMPTY
86442: LIST
86443: LIST
86444: PUSH
86445: LD_INT 3
86447: NEG
86448: PUSH
86449: LD_INT 3
86451: NEG
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: EMPTY
86458: LIST
86459: LIST
86460: LIST
86461: LIST
86462: LIST
86463: LIST
86464: LIST
86465: LIST
86466: LIST
86467: LIST
86468: LIST
86469: LIST
86470: LIST
86471: LIST
86472: LIST
86473: LIST
86474: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
86475: LD_ADDR_VAR 0 14
86479: PUSH
86480: LD_INT 0
86482: PUSH
86483: LD_INT 0
86485: PUSH
86486: EMPTY
86487: LIST
86488: LIST
86489: PUSH
86490: LD_INT 0
86492: PUSH
86493: LD_INT 1
86495: NEG
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: LD_INT 1
86503: PUSH
86504: LD_INT 0
86506: PUSH
86507: EMPTY
86508: LIST
86509: LIST
86510: PUSH
86511: LD_INT 1
86513: PUSH
86514: LD_INT 1
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PUSH
86521: LD_INT 0
86523: PUSH
86524: LD_INT 1
86526: PUSH
86527: EMPTY
86528: LIST
86529: LIST
86530: PUSH
86531: LD_INT 1
86533: NEG
86534: PUSH
86535: LD_INT 0
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: PUSH
86542: LD_INT 1
86544: NEG
86545: PUSH
86546: LD_INT 1
86548: NEG
86549: PUSH
86550: EMPTY
86551: LIST
86552: LIST
86553: PUSH
86554: LD_INT 1
86556: NEG
86557: PUSH
86558: LD_INT 2
86560: NEG
86561: PUSH
86562: EMPTY
86563: LIST
86564: LIST
86565: PUSH
86566: LD_INT 0
86568: PUSH
86569: LD_INT 2
86571: NEG
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PUSH
86577: LD_INT 1
86579: PUSH
86580: LD_INT 1
86582: NEG
86583: PUSH
86584: EMPTY
86585: LIST
86586: LIST
86587: PUSH
86588: LD_INT 1
86590: PUSH
86591: LD_INT 2
86593: PUSH
86594: EMPTY
86595: LIST
86596: LIST
86597: PUSH
86598: LD_INT 0
86600: PUSH
86601: LD_INT 2
86603: PUSH
86604: EMPTY
86605: LIST
86606: LIST
86607: PUSH
86608: LD_INT 1
86610: NEG
86611: PUSH
86612: LD_INT 1
86614: PUSH
86615: EMPTY
86616: LIST
86617: LIST
86618: PUSH
86619: LD_INT 1
86621: NEG
86622: PUSH
86623: LD_INT 3
86625: NEG
86626: PUSH
86627: EMPTY
86628: LIST
86629: LIST
86630: PUSH
86631: LD_INT 0
86633: PUSH
86634: LD_INT 3
86636: NEG
86637: PUSH
86638: EMPTY
86639: LIST
86640: LIST
86641: PUSH
86642: LD_INT 1
86644: PUSH
86645: LD_INT 2
86647: NEG
86648: PUSH
86649: EMPTY
86650: LIST
86651: LIST
86652: PUSH
86653: EMPTY
86654: LIST
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
86671: LD_ADDR_VAR 0 15
86675: PUSH
86676: LD_INT 0
86678: PUSH
86679: LD_INT 0
86681: PUSH
86682: EMPTY
86683: LIST
86684: LIST
86685: PUSH
86686: LD_INT 0
86688: PUSH
86689: LD_INT 1
86691: NEG
86692: PUSH
86693: EMPTY
86694: LIST
86695: LIST
86696: PUSH
86697: LD_INT 1
86699: PUSH
86700: LD_INT 0
86702: PUSH
86703: EMPTY
86704: LIST
86705: LIST
86706: PUSH
86707: LD_INT 1
86709: PUSH
86710: LD_INT 1
86712: PUSH
86713: EMPTY
86714: LIST
86715: LIST
86716: PUSH
86717: LD_INT 0
86719: PUSH
86720: LD_INT 1
86722: PUSH
86723: EMPTY
86724: LIST
86725: LIST
86726: PUSH
86727: LD_INT 1
86729: NEG
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: LD_INT 1
86740: NEG
86741: PUSH
86742: LD_INT 1
86744: NEG
86745: PUSH
86746: EMPTY
86747: LIST
86748: LIST
86749: PUSH
86750: LD_INT 1
86752: PUSH
86753: LD_INT 1
86755: NEG
86756: PUSH
86757: EMPTY
86758: LIST
86759: LIST
86760: PUSH
86761: LD_INT 2
86763: PUSH
86764: LD_INT 0
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: PUSH
86771: LD_INT 2
86773: PUSH
86774: LD_INT 1
86776: PUSH
86777: EMPTY
86778: LIST
86779: LIST
86780: PUSH
86781: LD_INT 1
86783: NEG
86784: PUSH
86785: LD_INT 1
86787: PUSH
86788: EMPTY
86789: LIST
86790: LIST
86791: PUSH
86792: LD_INT 2
86794: NEG
86795: PUSH
86796: LD_INT 0
86798: PUSH
86799: EMPTY
86800: LIST
86801: LIST
86802: PUSH
86803: LD_INT 2
86805: NEG
86806: PUSH
86807: LD_INT 1
86809: NEG
86810: PUSH
86811: EMPTY
86812: LIST
86813: LIST
86814: PUSH
86815: LD_INT 2
86817: PUSH
86818: LD_INT 1
86820: NEG
86821: PUSH
86822: EMPTY
86823: LIST
86824: LIST
86825: PUSH
86826: LD_INT 3
86828: PUSH
86829: LD_INT 0
86831: PUSH
86832: EMPTY
86833: LIST
86834: LIST
86835: PUSH
86836: LD_INT 3
86838: PUSH
86839: LD_INT 1
86841: PUSH
86842: EMPTY
86843: LIST
86844: LIST
86845: PUSH
86846: EMPTY
86847: LIST
86848: LIST
86849: LIST
86850: LIST
86851: LIST
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
86864: LD_ADDR_VAR 0 16
86868: PUSH
86869: LD_INT 0
86871: PUSH
86872: LD_INT 0
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 0
86881: PUSH
86882: LD_INT 1
86884: NEG
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 1
86892: PUSH
86893: LD_INT 0
86895: PUSH
86896: EMPTY
86897: LIST
86898: LIST
86899: PUSH
86900: LD_INT 1
86902: PUSH
86903: LD_INT 1
86905: PUSH
86906: EMPTY
86907: LIST
86908: LIST
86909: PUSH
86910: LD_INT 0
86912: PUSH
86913: LD_INT 1
86915: PUSH
86916: EMPTY
86917: LIST
86918: LIST
86919: PUSH
86920: LD_INT 1
86922: NEG
86923: PUSH
86924: LD_INT 0
86926: PUSH
86927: EMPTY
86928: LIST
86929: LIST
86930: PUSH
86931: LD_INT 1
86933: NEG
86934: PUSH
86935: LD_INT 1
86937: NEG
86938: PUSH
86939: EMPTY
86940: LIST
86941: LIST
86942: PUSH
86943: LD_INT 1
86945: NEG
86946: PUSH
86947: LD_INT 2
86949: NEG
86950: PUSH
86951: EMPTY
86952: LIST
86953: LIST
86954: PUSH
86955: LD_INT 2
86957: PUSH
86958: LD_INT 1
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PUSH
86965: LD_INT 2
86967: PUSH
86968: LD_INT 2
86970: PUSH
86971: EMPTY
86972: LIST
86973: LIST
86974: PUSH
86975: LD_INT 1
86977: PUSH
86978: LD_INT 2
86980: PUSH
86981: EMPTY
86982: LIST
86983: LIST
86984: PUSH
86985: LD_INT 2
86987: NEG
86988: PUSH
86989: LD_INT 1
86991: NEG
86992: PUSH
86993: EMPTY
86994: LIST
86995: LIST
86996: PUSH
86997: LD_INT 2
86999: NEG
87000: PUSH
87001: LD_INT 2
87003: NEG
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 3
87011: PUSH
87012: LD_INT 2
87014: PUSH
87015: EMPTY
87016: LIST
87017: LIST
87018: PUSH
87019: LD_INT 3
87021: PUSH
87022: LD_INT 3
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: LD_INT 2
87031: PUSH
87032: LD_INT 3
87034: PUSH
87035: EMPTY
87036: LIST
87037: LIST
87038: PUSH
87039: EMPTY
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87057: LD_ADDR_VAR 0 17
87061: PUSH
87062: LD_INT 0
87064: PUSH
87065: LD_INT 0
87067: PUSH
87068: EMPTY
87069: LIST
87070: LIST
87071: PUSH
87072: LD_INT 0
87074: PUSH
87075: LD_INT 1
87077: NEG
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: PUSH
87083: LD_INT 1
87085: PUSH
87086: LD_INT 0
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: PUSH
87093: LD_INT 1
87095: PUSH
87096: LD_INT 1
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: LD_INT 0
87105: PUSH
87106: LD_INT 1
87108: PUSH
87109: EMPTY
87110: LIST
87111: LIST
87112: PUSH
87113: LD_INT 1
87115: NEG
87116: PUSH
87117: LD_INT 0
87119: PUSH
87120: EMPTY
87121: LIST
87122: LIST
87123: PUSH
87124: LD_INT 1
87126: NEG
87127: PUSH
87128: LD_INT 1
87130: NEG
87131: PUSH
87132: EMPTY
87133: LIST
87134: LIST
87135: PUSH
87136: LD_INT 1
87138: NEG
87139: PUSH
87140: LD_INT 2
87142: NEG
87143: PUSH
87144: EMPTY
87145: LIST
87146: LIST
87147: PUSH
87148: LD_INT 0
87150: PUSH
87151: LD_INT 2
87153: NEG
87154: PUSH
87155: EMPTY
87156: LIST
87157: LIST
87158: PUSH
87159: LD_INT 1
87161: PUSH
87162: LD_INT 1
87164: NEG
87165: PUSH
87166: EMPTY
87167: LIST
87168: LIST
87169: PUSH
87170: LD_INT 2
87172: PUSH
87173: LD_INT 0
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: PUSH
87180: LD_INT 2
87182: PUSH
87183: LD_INT 1
87185: PUSH
87186: EMPTY
87187: LIST
87188: LIST
87189: PUSH
87190: LD_INT 2
87192: PUSH
87193: LD_INT 2
87195: PUSH
87196: EMPTY
87197: LIST
87198: LIST
87199: PUSH
87200: LD_INT 1
87202: PUSH
87203: LD_INT 2
87205: PUSH
87206: EMPTY
87207: LIST
87208: LIST
87209: PUSH
87210: LD_INT 0
87212: PUSH
87213: LD_INT 2
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 1
87222: NEG
87223: PUSH
87224: LD_INT 1
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: PUSH
87231: LD_INT 2
87233: NEG
87234: PUSH
87235: LD_INT 0
87237: PUSH
87238: EMPTY
87239: LIST
87240: LIST
87241: PUSH
87242: LD_INT 2
87244: NEG
87245: PUSH
87246: LD_INT 1
87248: NEG
87249: PUSH
87250: EMPTY
87251: LIST
87252: LIST
87253: PUSH
87254: LD_INT 2
87256: NEG
87257: PUSH
87258: LD_INT 2
87260: NEG
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: PUSH
87266: EMPTY
87267: LIST
87268: LIST
87269: LIST
87270: LIST
87271: LIST
87272: LIST
87273: LIST
87274: LIST
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: LIST
87281: LIST
87282: LIST
87283: LIST
87284: LIST
87285: LIST
87286: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87287: LD_ADDR_VAR 0 18
87291: PUSH
87292: LD_INT 0
87294: PUSH
87295: LD_INT 0
87297: PUSH
87298: EMPTY
87299: LIST
87300: LIST
87301: PUSH
87302: LD_INT 0
87304: PUSH
87305: LD_INT 1
87307: NEG
87308: PUSH
87309: EMPTY
87310: LIST
87311: LIST
87312: PUSH
87313: LD_INT 1
87315: PUSH
87316: LD_INT 0
87318: PUSH
87319: EMPTY
87320: LIST
87321: LIST
87322: PUSH
87323: LD_INT 1
87325: PUSH
87326: LD_INT 1
87328: PUSH
87329: EMPTY
87330: LIST
87331: LIST
87332: PUSH
87333: LD_INT 0
87335: PUSH
87336: LD_INT 1
87338: PUSH
87339: EMPTY
87340: LIST
87341: LIST
87342: PUSH
87343: LD_INT 1
87345: NEG
87346: PUSH
87347: LD_INT 0
87349: PUSH
87350: EMPTY
87351: LIST
87352: LIST
87353: PUSH
87354: LD_INT 1
87356: NEG
87357: PUSH
87358: LD_INT 1
87360: NEG
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: PUSH
87366: LD_INT 1
87368: NEG
87369: PUSH
87370: LD_INT 2
87372: NEG
87373: PUSH
87374: EMPTY
87375: LIST
87376: LIST
87377: PUSH
87378: LD_INT 0
87380: PUSH
87381: LD_INT 2
87383: NEG
87384: PUSH
87385: EMPTY
87386: LIST
87387: LIST
87388: PUSH
87389: LD_INT 1
87391: PUSH
87392: LD_INT 1
87394: NEG
87395: PUSH
87396: EMPTY
87397: LIST
87398: LIST
87399: PUSH
87400: LD_INT 2
87402: PUSH
87403: LD_INT 0
87405: PUSH
87406: EMPTY
87407: LIST
87408: LIST
87409: PUSH
87410: LD_INT 2
87412: PUSH
87413: LD_INT 1
87415: PUSH
87416: EMPTY
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 2
87422: PUSH
87423: LD_INT 2
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: PUSH
87430: LD_INT 1
87432: PUSH
87433: LD_INT 2
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: PUSH
87440: LD_INT 0
87442: PUSH
87443: LD_INT 2
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 1
87452: NEG
87453: PUSH
87454: LD_INT 1
87456: PUSH
87457: EMPTY
87458: LIST
87459: LIST
87460: PUSH
87461: LD_INT 2
87463: NEG
87464: PUSH
87465: LD_INT 0
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 2
87474: NEG
87475: PUSH
87476: LD_INT 1
87478: NEG
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: PUSH
87484: LD_INT 2
87486: NEG
87487: PUSH
87488: LD_INT 2
87490: NEG
87491: PUSH
87492: EMPTY
87493: LIST
87494: LIST
87495: PUSH
87496: EMPTY
87497: LIST
87498: LIST
87499: LIST
87500: LIST
87501: LIST
87502: LIST
87503: LIST
87504: LIST
87505: LIST
87506: LIST
87507: LIST
87508: LIST
87509: LIST
87510: LIST
87511: LIST
87512: LIST
87513: LIST
87514: LIST
87515: LIST
87516: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87517: LD_ADDR_VAR 0 19
87521: PUSH
87522: LD_INT 0
87524: PUSH
87525: LD_INT 0
87527: PUSH
87528: EMPTY
87529: LIST
87530: LIST
87531: PUSH
87532: LD_INT 0
87534: PUSH
87535: LD_INT 1
87537: NEG
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: PUSH
87543: LD_INT 1
87545: PUSH
87546: LD_INT 0
87548: PUSH
87549: EMPTY
87550: LIST
87551: LIST
87552: PUSH
87553: LD_INT 1
87555: PUSH
87556: LD_INT 1
87558: PUSH
87559: EMPTY
87560: LIST
87561: LIST
87562: PUSH
87563: LD_INT 0
87565: PUSH
87566: LD_INT 1
87568: PUSH
87569: EMPTY
87570: LIST
87571: LIST
87572: PUSH
87573: LD_INT 1
87575: NEG
87576: PUSH
87577: LD_INT 0
87579: PUSH
87580: EMPTY
87581: LIST
87582: LIST
87583: PUSH
87584: LD_INT 1
87586: NEG
87587: PUSH
87588: LD_INT 1
87590: NEG
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: LD_INT 1
87598: NEG
87599: PUSH
87600: LD_INT 2
87602: NEG
87603: PUSH
87604: EMPTY
87605: LIST
87606: LIST
87607: PUSH
87608: LD_INT 0
87610: PUSH
87611: LD_INT 2
87613: NEG
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: LD_INT 1
87621: PUSH
87622: LD_INT 1
87624: NEG
87625: PUSH
87626: EMPTY
87627: LIST
87628: LIST
87629: PUSH
87630: LD_INT 2
87632: PUSH
87633: LD_INT 0
87635: PUSH
87636: EMPTY
87637: LIST
87638: LIST
87639: PUSH
87640: LD_INT 2
87642: PUSH
87643: LD_INT 1
87645: PUSH
87646: EMPTY
87647: LIST
87648: LIST
87649: PUSH
87650: LD_INT 2
87652: PUSH
87653: LD_INT 2
87655: PUSH
87656: EMPTY
87657: LIST
87658: LIST
87659: PUSH
87660: LD_INT 1
87662: PUSH
87663: LD_INT 2
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 0
87672: PUSH
87673: LD_INT 2
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 1
87682: NEG
87683: PUSH
87684: LD_INT 1
87686: PUSH
87687: EMPTY
87688: LIST
87689: LIST
87690: PUSH
87691: LD_INT 2
87693: NEG
87694: PUSH
87695: LD_INT 0
87697: PUSH
87698: EMPTY
87699: LIST
87700: LIST
87701: PUSH
87702: LD_INT 2
87704: NEG
87705: PUSH
87706: LD_INT 1
87708: NEG
87709: PUSH
87710: EMPTY
87711: LIST
87712: LIST
87713: PUSH
87714: LD_INT 2
87716: NEG
87717: PUSH
87718: LD_INT 2
87720: NEG
87721: PUSH
87722: EMPTY
87723: LIST
87724: LIST
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87747: LD_ADDR_VAR 0 20
87751: PUSH
87752: LD_INT 0
87754: PUSH
87755: LD_INT 0
87757: PUSH
87758: EMPTY
87759: LIST
87760: LIST
87761: PUSH
87762: LD_INT 0
87764: PUSH
87765: LD_INT 1
87767: NEG
87768: PUSH
87769: EMPTY
87770: LIST
87771: LIST
87772: PUSH
87773: LD_INT 1
87775: PUSH
87776: LD_INT 0
87778: PUSH
87779: EMPTY
87780: LIST
87781: LIST
87782: PUSH
87783: LD_INT 1
87785: PUSH
87786: LD_INT 1
87788: PUSH
87789: EMPTY
87790: LIST
87791: LIST
87792: PUSH
87793: LD_INT 0
87795: PUSH
87796: LD_INT 1
87798: PUSH
87799: EMPTY
87800: LIST
87801: LIST
87802: PUSH
87803: LD_INT 1
87805: NEG
87806: PUSH
87807: LD_INT 0
87809: PUSH
87810: EMPTY
87811: LIST
87812: LIST
87813: PUSH
87814: LD_INT 1
87816: NEG
87817: PUSH
87818: LD_INT 1
87820: NEG
87821: PUSH
87822: EMPTY
87823: LIST
87824: LIST
87825: PUSH
87826: LD_INT 1
87828: NEG
87829: PUSH
87830: LD_INT 2
87832: NEG
87833: PUSH
87834: EMPTY
87835: LIST
87836: LIST
87837: PUSH
87838: LD_INT 0
87840: PUSH
87841: LD_INT 2
87843: NEG
87844: PUSH
87845: EMPTY
87846: LIST
87847: LIST
87848: PUSH
87849: LD_INT 1
87851: PUSH
87852: LD_INT 1
87854: NEG
87855: PUSH
87856: EMPTY
87857: LIST
87858: LIST
87859: PUSH
87860: LD_INT 2
87862: PUSH
87863: LD_INT 0
87865: PUSH
87866: EMPTY
87867: LIST
87868: LIST
87869: PUSH
87870: LD_INT 2
87872: PUSH
87873: LD_INT 1
87875: PUSH
87876: EMPTY
87877: LIST
87878: LIST
87879: PUSH
87880: LD_INT 2
87882: PUSH
87883: LD_INT 2
87885: PUSH
87886: EMPTY
87887: LIST
87888: LIST
87889: PUSH
87890: LD_INT 1
87892: PUSH
87893: LD_INT 2
87895: PUSH
87896: EMPTY
87897: LIST
87898: LIST
87899: PUSH
87900: LD_INT 0
87902: PUSH
87903: LD_INT 2
87905: PUSH
87906: EMPTY
87907: LIST
87908: LIST
87909: PUSH
87910: LD_INT 1
87912: NEG
87913: PUSH
87914: LD_INT 1
87916: PUSH
87917: EMPTY
87918: LIST
87919: LIST
87920: PUSH
87921: LD_INT 2
87923: NEG
87924: PUSH
87925: LD_INT 0
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: LD_INT 2
87934: NEG
87935: PUSH
87936: LD_INT 1
87938: NEG
87939: PUSH
87940: EMPTY
87941: LIST
87942: LIST
87943: PUSH
87944: LD_INT 2
87946: NEG
87947: PUSH
87948: LD_INT 2
87950: NEG
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: EMPTY
87957: LIST
87958: LIST
87959: LIST
87960: LIST
87961: LIST
87962: LIST
87963: LIST
87964: LIST
87965: LIST
87966: LIST
87967: LIST
87968: LIST
87969: LIST
87970: LIST
87971: LIST
87972: LIST
87973: LIST
87974: LIST
87975: LIST
87976: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87977: LD_ADDR_VAR 0 21
87981: PUSH
87982: LD_INT 0
87984: PUSH
87985: LD_INT 0
87987: PUSH
87988: EMPTY
87989: LIST
87990: LIST
87991: PUSH
87992: LD_INT 0
87994: PUSH
87995: LD_INT 1
87997: NEG
87998: PUSH
87999: EMPTY
88000: LIST
88001: LIST
88002: PUSH
88003: LD_INT 1
88005: PUSH
88006: LD_INT 0
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PUSH
88013: LD_INT 1
88015: PUSH
88016: LD_INT 1
88018: PUSH
88019: EMPTY
88020: LIST
88021: LIST
88022: PUSH
88023: LD_INT 0
88025: PUSH
88026: LD_INT 1
88028: PUSH
88029: EMPTY
88030: LIST
88031: LIST
88032: PUSH
88033: LD_INT 1
88035: NEG
88036: PUSH
88037: LD_INT 0
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: PUSH
88044: LD_INT 1
88046: NEG
88047: PUSH
88048: LD_INT 1
88050: NEG
88051: PUSH
88052: EMPTY
88053: LIST
88054: LIST
88055: PUSH
88056: LD_INT 1
88058: NEG
88059: PUSH
88060: LD_INT 2
88062: NEG
88063: PUSH
88064: EMPTY
88065: LIST
88066: LIST
88067: PUSH
88068: LD_INT 0
88070: PUSH
88071: LD_INT 2
88073: NEG
88074: PUSH
88075: EMPTY
88076: LIST
88077: LIST
88078: PUSH
88079: LD_INT 1
88081: PUSH
88082: LD_INT 1
88084: NEG
88085: PUSH
88086: EMPTY
88087: LIST
88088: LIST
88089: PUSH
88090: LD_INT 2
88092: PUSH
88093: LD_INT 0
88095: PUSH
88096: EMPTY
88097: LIST
88098: LIST
88099: PUSH
88100: LD_INT 2
88102: PUSH
88103: LD_INT 1
88105: PUSH
88106: EMPTY
88107: LIST
88108: LIST
88109: PUSH
88110: LD_INT 2
88112: PUSH
88113: LD_INT 2
88115: PUSH
88116: EMPTY
88117: LIST
88118: LIST
88119: PUSH
88120: LD_INT 1
88122: PUSH
88123: LD_INT 2
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: PUSH
88130: LD_INT 0
88132: PUSH
88133: LD_INT 2
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: PUSH
88140: LD_INT 1
88142: NEG
88143: PUSH
88144: LD_INT 1
88146: PUSH
88147: EMPTY
88148: LIST
88149: LIST
88150: PUSH
88151: LD_INT 2
88153: NEG
88154: PUSH
88155: LD_INT 0
88157: PUSH
88158: EMPTY
88159: LIST
88160: LIST
88161: PUSH
88162: LD_INT 2
88164: NEG
88165: PUSH
88166: LD_INT 1
88168: NEG
88169: PUSH
88170: EMPTY
88171: LIST
88172: LIST
88173: PUSH
88174: LD_INT 2
88176: NEG
88177: PUSH
88178: LD_INT 2
88180: NEG
88181: PUSH
88182: EMPTY
88183: LIST
88184: LIST
88185: PUSH
88186: EMPTY
88187: LIST
88188: LIST
88189: LIST
88190: LIST
88191: LIST
88192: LIST
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88207: LD_ADDR_VAR 0 22
88211: PUSH
88212: LD_INT 0
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: EMPTY
88219: LIST
88220: LIST
88221: PUSH
88222: LD_INT 0
88224: PUSH
88225: LD_INT 1
88227: NEG
88228: PUSH
88229: EMPTY
88230: LIST
88231: LIST
88232: PUSH
88233: LD_INT 1
88235: PUSH
88236: LD_INT 0
88238: PUSH
88239: EMPTY
88240: LIST
88241: LIST
88242: PUSH
88243: LD_INT 1
88245: PUSH
88246: LD_INT 1
88248: PUSH
88249: EMPTY
88250: LIST
88251: LIST
88252: PUSH
88253: LD_INT 0
88255: PUSH
88256: LD_INT 1
88258: PUSH
88259: EMPTY
88260: LIST
88261: LIST
88262: PUSH
88263: LD_INT 1
88265: NEG
88266: PUSH
88267: LD_INT 0
88269: PUSH
88270: EMPTY
88271: LIST
88272: LIST
88273: PUSH
88274: LD_INT 1
88276: NEG
88277: PUSH
88278: LD_INT 1
88280: NEG
88281: PUSH
88282: EMPTY
88283: LIST
88284: LIST
88285: PUSH
88286: LD_INT 1
88288: NEG
88289: PUSH
88290: LD_INT 2
88292: NEG
88293: PUSH
88294: EMPTY
88295: LIST
88296: LIST
88297: PUSH
88298: LD_INT 0
88300: PUSH
88301: LD_INT 2
88303: NEG
88304: PUSH
88305: EMPTY
88306: LIST
88307: LIST
88308: PUSH
88309: LD_INT 1
88311: PUSH
88312: LD_INT 1
88314: NEG
88315: PUSH
88316: EMPTY
88317: LIST
88318: LIST
88319: PUSH
88320: LD_INT 2
88322: PUSH
88323: LD_INT 0
88325: PUSH
88326: EMPTY
88327: LIST
88328: LIST
88329: PUSH
88330: LD_INT 2
88332: PUSH
88333: LD_INT 1
88335: PUSH
88336: EMPTY
88337: LIST
88338: LIST
88339: PUSH
88340: LD_INT 2
88342: PUSH
88343: LD_INT 2
88345: PUSH
88346: EMPTY
88347: LIST
88348: LIST
88349: PUSH
88350: LD_INT 1
88352: PUSH
88353: LD_INT 2
88355: PUSH
88356: EMPTY
88357: LIST
88358: LIST
88359: PUSH
88360: LD_INT 0
88362: PUSH
88363: LD_INT 2
88365: PUSH
88366: EMPTY
88367: LIST
88368: LIST
88369: PUSH
88370: LD_INT 1
88372: NEG
88373: PUSH
88374: LD_INT 1
88376: PUSH
88377: EMPTY
88378: LIST
88379: LIST
88380: PUSH
88381: LD_INT 2
88383: NEG
88384: PUSH
88385: LD_INT 0
88387: PUSH
88388: EMPTY
88389: LIST
88390: LIST
88391: PUSH
88392: LD_INT 2
88394: NEG
88395: PUSH
88396: LD_INT 1
88398: NEG
88399: PUSH
88400: EMPTY
88401: LIST
88402: LIST
88403: PUSH
88404: LD_INT 2
88406: NEG
88407: PUSH
88408: LD_INT 2
88410: NEG
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: LIST
88420: LIST
88421: LIST
88422: LIST
88423: LIST
88424: LIST
88425: LIST
88426: LIST
88427: LIST
88428: LIST
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: LIST
88434: LIST
88435: LIST
88436: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
88437: LD_ADDR_VAR 0 23
88441: PUSH
88442: LD_INT 0
88444: PUSH
88445: LD_INT 0
88447: PUSH
88448: EMPTY
88449: LIST
88450: LIST
88451: PUSH
88452: LD_INT 0
88454: PUSH
88455: LD_INT 1
88457: NEG
88458: PUSH
88459: EMPTY
88460: LIST
88461: LIST
88462: PUSH
88463: LD_INT 1
88465: PUSH
88466: LD_INT 0
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: PUSH
88473: LD_INT 1
88475: PUSH
88476: LD_INT 1
88478: PUSH
88479: EMPTY
88480: LIST
88481: LIST
88482: PUSH
88483: LD_INT 0
88485: PUSH
88486: LD_INT 1
88488: PUSH
88489: EMPTY
88490: LIST
88491: LIST
88492: PUSH
88493: LD_INT 1
88495: NEG
88496: PUSH
88497: LD_INT 0
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: PUSH
88504: LD_INT 1
88506: NEG
88507: PUSH
88508: LD_INT 1
88510: NEG
88511: PUSH
88512: EMPTY
88513: LIST
88514: LIST
88515: PUSH
88516: LD_INT 1
88518: NEG
88519: PUSH
88520: LD_INT 2
88522: NEG
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 0
88530: PUSH
88531: LD_INT 2
88533: NEG
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: LD_INT 1
88541: PUSH
88542: LD_INT 1
88544: NEG
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 2
88552: PUSH
88553: LD_INT 0
88555: PUSH
88556: EMPTY
88557: LIST
88558: LIST
88559: PUSH
88560: LD_INT 2
88562: PUSH
88563: LD_INT 1
88565: PUSH
88566: EMPTY
88567: LIST
88568: LIST
88569: PUSH
88570: LD_INT 2
88572: PUSH
88573: LD_INT 2
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 1
88582: PUSH
88583: LD_INT 2
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: PUSH
88590: LD_INT 0
88592: PUSH
88593: LD_INT 2
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: LD_INT 1
88602: NEG
88603: PUSH
88604: LD_INT 1
88606: PUSH
88607: EMPTY
88608: LIST
88609: LIST
88610: PUSH
88611: LD_INT 2
88613: NEG
88614: PUSH
88615: LD_INT 0
88617: PUSH
88618: EMPTY
88619: LIST
88620: LIST
88621: PUSH
88622: LD_INT 2
88624: NEG
88625: PUSH
88626: LD_INT 1
88628: NEG
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: PUSH
88634: LD_INT 2
88636: NEG
88637: PUSH
88638: LD_INT 2
88640: NEG
88641: PUSH
88642: EMPTY
88643: LIST
88644: LIST
88645: PUSH
88646: LD_INT 2
88648: NEG
88649: PUSH
88650: LD_INT 3
88652: NEG
88653: PUSH
88654: EMPTY
88655: LIST
88656: LIST
88657: PUSH
88658: LD_INT 1
88660: NEG
88661: PUSH
88662: LD_INT 3
88664: NEG
88665: PUSH
88666: EMPTY
88667: LIST
88668: LIST
88669: PUSH
88670: LD_INT 1
88672: PUSH
88673: LD_INT 2
88675: NEG
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 2
88683: PUSH
88684: LD_INT 1
88686: NEG
88687: PUSH
88688: EMPTY
88689: LIST
88690: LIST
88691: PUSH
88692: EMPTY
88693: LIST
88694: LIST
88695: LIST
88696: LIST
88697: LIST
88698: LIST
88699: LIST
88700: LIST
88701: LIST
88702: LIST
88703: LIST
88704: LIST
88705: LIST
88706: LIST
88707: LIST
88708: LIST
88709: LIST
88710: LIST
88711: LIST
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
88717: LD_ADDR_VAR 0 24
88721: PUSH
88722: LD_INT 0
88724: PUSH
88725: LD_INT 0
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 0
88734: PUSH
88735: LD_INT 1
88737: NEG
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PUSH
88743: LD_INT 1
88745: PUSH
88746: LD_INT 0
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: PUSH
88753: LD_INT 1
88755: PUSH
88756: LD_INT 1
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 0
88765: PUSH
88766: LD_INT 1
88768: PUSH
88769: EMPTY
88770: LIST
88771: LIST
88772: PUSH
88773: LD_INT 1
88775: NEG
88776: PUSH
88777: LD_INT 0
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: PUSH
88784: LD_INT 1
88786: NEG
88787: PUSH
88788: LD_INT 1
88790: NEG
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 1
88798: NEG
88799: PUSH
88800: LD_INT 2
88802: NEG
88803: PUSH
88804: EMPTY
88805: LIST
88806: LIST
88807: PUSH
88808: LD_INT 0
88810: PUSH
88811: LD_INT 2
88813: NEG
88814: PUSH
88815: EMPTY
88816: LIST
88817: LIST
88818: PUSH
88819: LD_INT 1
88821: PUSH
88822: LD_INT 1
88824: NEG
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: PUSH
88830: LD_INT 2
88832: PUSH
88833: LD_INT 0
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: PUSH
88840: LD_INT 2
88842: PUSH
88843: LD_INT 1
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PUSH
88850: LD_INT 2
88852: PUSH
88853: LD_INT 2
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 1
88862: PUSH
88863: LD_INT 2
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 0
88872: PUSH
88873: LD_INT 2
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 1
88882: NEG
88883: PUSH
88884: LD_INT 1
88886: PUSH
88887: EMPTY
88888: LIST
88889: LIST
88890: PUSH
88891: LD_INT 2
88893: NEG
88894: PUSH
88895: LD_INT 0
88897: PUSH
88898: EMPTY
88899: LIST
88900: LIST
88901: PUSH
88902: LD_INT 2
88904: NEG
88905: PUSH
88906: LD_INT 1
88908: NEG
88909: PUSH
88910: EMPTY
88911: LIST
88912: LIST
88913: PUSH
88914: LD_INT 2
88916: NEG
88917: PUSH
88918: LD_INT 2
88920: NEG
88921: PUSH
88922: EMPTY
88923: LIST
88924: LIST
88925: PUSH
88926: LD_INT 1
88928: PUSH
88929: LD_INT 2
88931: NEG
88932: PUSH
88933: EMPTY
88934: LIST
88935: LIST
88936: PUSH
88937: LD_INT 2
88939: PUSH
88940: LD_INT 1
88942: NEG
88943: PUSH
88944: EMPTY
88945: LIST
88946: LIST
88947: PUSH
88948: LD_INT 3
88950: PUSH
88951: LD_INT 1
88953: PUSH
88954: EMPTY
88955: LIST
88956: LIST
88957: PUSH
88958: LD_INT 3
88960: PUSH
88961: LD_INT 2
88963: PUSH
88964: EMPTY
88965: LIST
88966: LIST
88967: PUSH
88968: EMPTY
88969: LIST
88970: LIST
88971: LIST
88972: LIST
88973: LIST
88974: LIST
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: LIST
88984: LIST
88985: LIST
88986: LIST
88987: LIST
88988: LIST
88989: LIST
88990: LIST
88991: LIST
88992: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
88993: LD_ADDR_VAR 0 25
88997: PUSH
88998: LD_INT 0
89000: PUSH
89001: LD_INT 0
89003: PUSH
89004: EMPTY
89005: LIST
89006: LIST
89007: PUSH
89008: LD_INT 0
89010: PUSH
89011: LD_INT 1
89013: NEG
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: LD_INT 1
89021: PUSH
89022: LD_INT 0
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PUSH
89029: LD_INT 1
89031: PUSH
89032: LD_INT 1
89034: PUSH
89035: EMPTY
89036: LIST
89037: LIST
89038: PUSH
89039: LD_INT 0
89041: PUSH
89042: LD_INT 1
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 1
89051: NEG
89052: PUSH
89053: LD_INT 0
89055: PUSH
89056: EMPTY
89057: LIST
89058: LIST
89059: PUSH
89060: LD_INT 1
89062: NEG
89063: PUSH
89064: LD_INT 1
89066: NEG
89067: PUSH
89068: EMPTY
89069: LIST
89070: LIST
89071: PUSH
89072: LD_INT 1
89074: NEG
89075: PUSH
89076: LD_INT 2
89078: NEG
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: LD_INT 0
89086: PUSH
89087: LD_INT 2
89089: NEG
89090: PUSH
89091: EMPTY
89092: LIST
89093: LIST
89094: PUSH
89095: LD_INT 1
89097: PUSH
89098: LD_INT 1
89100: NEG
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: LD_INT 2
89108: PUSH
89109: LD_INT 0
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: PUSH
89116: LD_INT 2
89118: PUSH
89119: LD_INT 1
89121: PUSH
89122: EMPTY
89123: LIST
89124: LIST
89125: PUSH
89126: LD_INT 2
89128: PUSH
89129: LD_INT 2
89131: PUSH
89132: EMPTY
89133: LIST
89134: LIST
89135: PUSH
89136: LD_INT 1
89138: PUSH
89139: LD_INT 2
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: PUSH
89146: LD_INT 0
89148: PUSH
89149: LD_INT 2
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 1
89158: NEG
89159: PUSH
89160: LD_INT 1
89162: PUSH
89163: EMPTY
89164: LIST
89165: LIST
89166: PUSH
89167: LD_INT 2
89169: NEG
89170: PUSH
89171: LD_INT 0
89173: PUSH
89174: EMPTY
89175: LIST
89176: LIST
89177: PUSH
89178: LD_INT 2
89180: NEG
89181: PUSH
89182: LD_INT 1
89184: NEG
89185: PUSH
89186: EMPTY
89187: LIST
89188: LIST
89189: PUSH
89190: LD_INT 2
89192: NEG
89193: PUSH
89194: LD_INT 2
89196: NEG
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PUSH
89202: LD_INT 3
89204: PUSH
89205: LD_INT 1
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 3
89214: PUSH
89215: LD_INT 2
89217: PUSH
89218: EMPTY
89219: LIST
89220: LIST
89221: PUSH
89222: LD_INT 2
89224: PUSH
89225: LD_INT 3
89227: PUSH
89228: EMPTY
89229: LIST
89230: LIST
89231: PUSH
89232: LD_INT 1
89234: PUSH
89235: LD_INT 3
89237: PUSH
89238: EMPTY
89239: LIST
89240: LIST
89241: PUSH
89242: EMPTY
89243: LIST
89244: LIST
89245: LIST
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: LIST
89264: LIST
89265: LIST
89266: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
89267: LD_ADDR_VAR 0 26
89271: PUSH
89272: LD_INT 0
89274: PUSH
89275: LD_INT 0
89277: PUSH
89278: EMPTY
89279: LIST
89280: LIST
89281: PUSH
89282: LD_INT 0
89284: PUSH
89285: LD_INT 1
89287: NEG
89288: PUSH
89289: EMPTY
89290: LIST
89291: LIST
89292: PUSH
89293: LD_INT 1
89295: PUSH
89296: LD_INT 0
89298: PUSH
89299: EMPTY
89300: LIST
89301: LIST
89302: PUSH
89303: LD_INT 1
89305: PUSH
89306: LD_INT 1
89308: PUSH
89309: EMPTY
89310: LIST
89311: LIST
89312: PUSH
89313: LD_INT 0
89315: PUSH
89316: LD_INT 1
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: LD_INT 1
89325: NEG
89326: PUSH
89327: LD_INT 0
89329: PUSH
89330: EMPTY
89331: LIST
89332: LIST
89333: PUSH
89334: LD_INT 1
89336: NEG
89337: PUSH
89338: LD_INT 1
89340: NEG
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: PUSH
89346: LD_INT 1
89348: NEG
89349: PUSH
89350: LD_INT 2
89352: NEG
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: PUSH
89358: LD_INT 0
89360: PUSH
89361: LD_INT 2
89363: NEG
89364: PUSH
89365: EMPTY
89366: LIST
89367: LIST
89368: PUSH
89369: LD_INT 1
89371: PUSH
89372: LD_INT 1
89374: NEG
89375: PUSH
89376: EMPTY
89377: LIST
89378: LIST
89379: PUSH
89380: LD_INT 2
89382: PUSH
89383: LD_INT 0
89385: PUSH
89386: EMPTY
89387: LIST
89388: LIST
89389: PUSH
89390: LD_INT 2
89392: PUSH
89393: LD_INT 1
89395: PUSH
89396: EMPTY
89397: LIST
89398: LIST
89399: PUSH
89400: LD_INT 2
89402: PUSH
89403: LD_INT 2
89405: PUSH
89406: EMPTY
89407: LIST
89408: LIST
89409: PUSH
89410: LD_INT 1
89412: PUSH
89413: LD_INT 2
89415: PUSH
89416: EMPTY
89417: LIST
89418: LIST
89419: PUSH
89420: LD_INT 0
89422: PUSH
89423: LD_INT 2
89425: PUSH
89426: EMPTY
89427: LIST
89428: LIST
89429: PUSH
89430: LD_INT 1
89432: NEG
89433: PUSH
89434: LD_INT 1
89436: PUSH
89437: EMPTY
89438: LIST
89439: LIST
89440: PUSH
89441: LD_INT 2
89443: NEG
89444: PUSH
89445: LD_INT 0
89447: PUSH
89448: EMPTY
89449: LIST
89450: LIST
89451: PUSH
89452: LD_INT 2
89454: NEG
89455: PUSH
89456: LD_INT 1
89458: NEG
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 2
89466: NEG
89467: PUSH
89468: LD_INT 2
89470: NEG
89471: PUSH
89472: EMPTY
89473: LIST
89474: LIST
89475: PUSH
89476: LD_INT 2
89478: PUSH
89479: LD_INT 3
89481: PUSH
89482: EMPTY
89483: LIST
89484: LIST
89485: PUSH
89486: LD_INT 1
89488: PUSH
89489: LD_INT 3
89491: PUSH
89492: EMPTY
89493: LIST
89494: LIST
89495: PUSH
89496: LD_INT 1
89498: NEG
89499: PUSH
89500: LD_INT 2
89502: PUSH
89503: EMPTY
89504: LIST
89505: LIST
89506: PUSH
89507: LD_INT 2
89509: NEG
89510: PUSH
89511: LD_INT 1
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: EMPTY
89519: LIST
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: LIST
89534: LIST
89535: LIST
89536: LIST
89537: LIST
89538: LIST
89539: LIST
89540: LIST
89541: LIST
89542: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
89543: LD_ADDR_VAR 0 27
89547: PUSH
89548: LD_INT 0
89550: PUSH
89551: LD_INT 0
89553: PUSH
89554: EMPTY
89555: LIST
89556: LIST
89557: PUSH
89558: LD_INT 0
89560: PUSH
89561: LD_INT 1
89563: NEG
89564: PUSH
89565: EMPTY
89566: LIST
89567: LIST
89568: PUSH
89569: LD_INT 1
89571: PUSH
89572: LD_INT 0
89574: PUSH
89575: EMPTY
89576: LIST
89577: LIST
89578: PUSH
89579: LD_INT 1
89581: PUSH
89582: LD_INT 1
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: PUSH
89589: LD_INT 0
89591: PUSH
89592: LD_INT 1
89594: PUSH
89595: EMPTY
89596: LIST
89597: LIST
89598: PUSH
89599: LD_INT 1
89601: NEG
89602: PUSH
89603: LD_INT 0
89605: PUSH
89606: EMPTY
89607: LIST
89608: LIST
89609: PUSH
89610: LD_INT 1
89612: NEG
89613: PUSH
89614: LD_INT 1
89616: NEG
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: LD_INT 1
89624: NEG
89625: PUSH
89626: LD_INT 2
89628: NEG
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: PUSH
89634: LD_INT 0
89636: PUSH
89637: LD_INT 2
89639: NEG
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: PUSH
89645: LD_INT 1
89647: PUSH
89648: LD_INT 1
89650: NEG
89651: PUSH
89652: EMPTY
89653: LIST
89654: LIST
89655: PUSH
89656: LD_INT 2
89658: PUSH
89659: LD_INT 0
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: PUSH
89666: LD_INT 2
89668: PUSH
89669: LD_INT 1
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 2
89678: PUSH
89679: LD_INT 2
89681: PUSH
89682: EMPTY
89683: LIST
89684: LIST
89685: PUSH
89686: LD_INT 1
89688: PUSH
89689: LD_INT 2
89691: PUSH
89692: EMPTY
89693: LIST
89694: LIST
89695: PUSH
89696: LD_INT 0
89698: PUSH
89699: LD_INT 2
89701: PUSH
89702: EMPTY
89703: LIST
89704: LIST
89705: PUSH
89706: LD_INT 1
89708: NEG
89709: PUSH
89710: LD_INT 1
89712: PUSH
89713: EMPTY
89714: LIST
89715: LIST
89716: PUSH
89717: LD_INT 2
89719: NEG
89720: PUSH
89721: LD_INT 0
89723: PUSH
89724: EMPTY
89725: LIST
89726: LIST
89727: PUSH
89728: LD_INT 2
89730: NEG
89731: PUSH
89732: LD_INT 1
89734: NEG
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: LD_INT 2
89742: NEG
89743: PUSH
89744: LD_INT 2
89746: NEG
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 1
89754: NEG
89755: PUSH
89756: LD_INT 2
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: LD_INT 2
89765: NEG
89766: PUSH
89767: LD_INT 1
89769: PUSH
89770: EMPTY
89771: LIST
89772: LIST
89773: PUSH
89774: LD_INT 3
89776: NEG
89777: PUSH
89778: LD_INT 1
89780: NEG
89781: PUSH
89782: EMPTY
89783: LIST
89784: LIST
89785: PUSH
89786: LD_INT 3
89788: NEG
89789: PUSH
89790: LD_INT 2
89792: NEG
89793: PUSH
89794: EMPTY
89795: LIST
89796: LIST
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: LIST
89802: LIST
89803: LIST
89804: LIST
89805: LIST
89806: LIST
89807: LIST
89808: LIST
89809: LIST
89810: LIST
89811: LIST
89812: LIST
89813: LIST
89814: LIST
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: LIST
89821: LIST
89822: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
89823: LD_ADDR_VAR 0 28
89827: PUSH
89828: LD_INT 0
89830: PUSH
89831: LD_INT 0
89833: PUSH
89834: EMPTY
89835: LIST
89836: LIST
89837: PUSH
89838: LD_INT 0
89840: PUSH
89841: LD_INT 1
89843: NEG
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: PUSH
89849: LD_INT 1
89851: PUSH
89852: LD_INT 0
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: LD_INT 1
89861: PUSH
89862: LD_INT 1
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: PUSH
89869: LD_INT 0
89871: PUSH
89872: LD_INT 1
89874: PUSH
89875: EMPTY
89876: LIST
89877: LIST
89878: PUSH
89879: LD_INT 1
89881: NEG
89882: PUSH
89883: LD_INT 0
89885: PUSH
89886: EMPTY
89887: LIST
89888: LIST
89889: PUSH
89890: LD_INT 1
89892: NEG
89893: PUSH
89894: LD_INT 1
89896: NEG
89897: PUSH
89898: EMPTY
89899: LIST
89900: LIST
89901: PUSH
89902: LD_INT 1
89904: NEG
89905: PUSH
89906: LD_INT 2
89908: NEG
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: PUSH
89914: LD_INT 0
89916: PUSH
89917: LD_INT 2
89919: NEG
89920: PUSH
89921: EMPTY
89922: LIST
89923: LIST
89924: PUSH
89925: LD_INT 1
89927: PUSH
89928: LD_INT 1
89930: NEG
89931: PUSH
89932: EMPTY
89933: LIST
89934: LIST
89935: PUSH
89936: LD_INT 2
89938: PUSH
89939: LD_INT 0
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: LD_INT 2
89948: PUSH
89949: LD_INT 1
89951: PUSH
89952: EMPTY
89953: LIST
89954: LIST
89955: PUSH
89956: LD_INT 2
89958: PUSH
89959: LD_INT 2
89961: PUSH
89962: EMPTY
89963: LIST
89964: LIST
89965: PUSH
89966: LD_INT 1
89968: PUSH
89969: LD_INT 2
89971: PUSH
89972: EMPTY
89973: LIST
89974: LIST
89975: PUSH
89976: LD_INT 0
89978: PUSH
89979: LD_INT 2
89981: PUSH
89982: EMPTY
89983: LIST
89984: LIST
89985: PUSH
89986: LD_INT 1
89988: NEG
89989: PUSH
89990: LD_INT 1
89992: PUSH
89993: EMPTY
89994: LIST
89995: LIST
89996: PUSH
89997: LD_INT 2
89999: NEG
90000: PUSH
90001: LD_INT 0
90003: PUSH
90004: EMPTY
90005: LIST
90006: LIST
90007: PUSH
90008: LD_INT 2
90010: NEG
90011: PUSH
90012: LD_INT 1
90014: NEG
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 2
90022: NEG
90023: PUSH
90024: LD_INT 2
90026: NEG
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: PUSH
90032: LD_INT 2
90034: NEG
90035: PUSH
90036: LD_INT 3
90038: NEG
90039: PUSH
90040: EMPTY
90041: LIST
90042: LIST
90043: PUSH
90044: LD_INT 1
90046: NEG
90047: PUSH
90048: LD_INT 3
90050: NEG
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: PUSH
90056: LD_INT 3
90058: NEG
90059: PUSH
90060: LD_INT 1
90062: NEG
90063: PUSH
90064: EMPTY
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 3
90070: NEG
90071: PUSH
90072: LD_INT 2
90074: NEG
90075: PUSH
90076: EMPTY
90077: LIST
90078: LIST
90079: PUSH
90080: EMPTY
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: LIST
90097: LIST
90098: LIST
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: LIST
90104: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
90105: LD_ADDR_VAR 0 29
90109: PUSH
90110: LD_INT 0
90112: PUSH
90113: LD_INT 0
90115: PUSH
90116: EMPTY
90117: LIST
90118: LIST
90119: PUSH
90120: LD_INT 0
90122: PUSH
90123: LD_INT 1
90125: NEG
90126: PUSH
90127: EMPTY
90128: LIST
90129: LIST
90130: PUSH
90131: LD_INT 1
90133: PUSH
90134: LD_INT 0
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: PUSH
90141: LD_INT 1
90143: PUSH
90144: LD_INT 1
90146: PUSH
90147: EMPTY
90148: LIST
90149: LIST
90150: PUSH
90151: LD_INT 0
90153: PUSH
90154: LD_INT 1
90156: PUSH
90157: EMPTY
90158: LIST
90159: LIST
90160: PUSH
90161: LD_INT 1
90163: NEG
90164: PUSH
90165: LD_INT 0
90167: PUSH
90168: EMPTY
90169: LIST
90170: LIST
90171: PUSH
90172: LD_INT 1
90174: NEG
90175: PUSH
90176: LD_INT 1
90178: NEG
90179: PUSH
90180: EMPTY
90181: LIST
90182: LIST
90183: PUSH
90184: LD_INT 1
90186: NEG
90187: PUSH
90188: LD_INT 2
90190: NEG
90191: PUSH
90192: EMPTY
90193: LIST
90194: LIST
90195: PUSH
90196: LD_INT 0
90198: PUSH
90199: LD_INT 2
90201: NEG
90202: PUSH
90203: EMPTY
90204: LIST
90205: LIST
90206: PUSH
90207: LD_INT 1
90209: PUSH
90210: LD_INT 1
90212: NEG
90213: PUSH
90214: EMPTY
90215: LIST
90216: LIST
90217: PUSH
90218: LD_INT 2
90220: PUSH
90221: LD_INT 0
90223: PUSH
90224: EMPTY
90225: LIST
90226: LIST
90227: PUSH
90228: LD_INT 2
90230: PUSH
90231: LD_INT 1
90233: PUSH
90234: EMPTY
90235: LIST
90236: LIST
90237: PUSH
90238: LD_INT 1
90240: PUSH
90241: LD_INT 2
90243: PUSH
90244: EMPTY
90245: LIST
90246: LIST
90247: PUSH
90248: LD_INT 0
90250: PUSH
90251: LD_INT 2
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: PUSH
90258: LD_INT 1
90260: NEG
90261: PUSH
90262: LD_INT 1
90264: PUSH
90265: EMPTY
90266: LIST
90267: LIST
90268: PUSH
90269: LD_INT 2
90271: NEG
90272: PUSH
90273: LD_INT 1
90275: NEG
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: PUSH
90281: LD_INT 2
90283: NEG
90284: PUSH
90285: LD_INT 2
90287: NEG
90288: PUSH
90289: EMPTY
90290: LIST
90291: LIST
90292: PUSH
90293: LD_INT 2
90295: NEG
90296: PUSH
90297: LD_INT 3
90299: NEG
90300: PUSH
90301: EMPTY
90302: LIST
90303: LIST
90304: PUSH
90305: LD_INT 2
90307: PUSH
90308: LD_INT 1
90310: NEG
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: PUSH
90316: LD_INT 3
90318: PUSH
90319: LD_INT 1
90321: PUSH
90322: EMPTY
90323: LIST
90324: LIST
90325: PUSH
90326: LD_INT 1
90328: PUSH
90329: LD_INT 3
90331: PUSH
90332: EMPTY
90333: LIST
90334: LIST
90335: PUSH
90336: LD_INT 1
90338: NEG
90339: PUSH
90340: LD_INT 2
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: PUSH
90347: LD_INT 3
90349: NEG
90350: PUSH
90351: LD_INT 2
90353: NEG
90354: PUSH
90355: EMPTY
90356: LIST
90357: LIST
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: LIST
90370: LIST
90371: LIST
90372: LIST
90373: LIST
90374: LIST
90375: LIST
90376: LIST
90377: LIST
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90384: LD_ADDR_VAR 0 30
90388: PUSH
90389: LD_INT 0
90391: PUSH
90392: LD_INT 0
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: LD_INT 0
90401: PUSH
90402: LD_INT 1
90404: NEG
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PUSH
90410: LD_INT 1
90412: PUSH
90413: LD_INT 0
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PUSH
90420: LD_INT 1
90422: PUSH
90423: LD_INT 1
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: LD_INT 0
90432: PUSH
90433: LD_INT 1
90435: PUSH
90436: EMPTY
90437: LIST
90438: LIST
90439: PUSH
90440: LD_INT 1
90442: NEG
90443: PUSH
90444: LD_INT 0
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: PUSH
90451: LD_INT 1
90453: NEG
90454: PUSH
90455: LD_INT 1
90457: NEG
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 1
90465: NEG
90466: PUSH
90467: LD_INT 2
90469: NEG
90470: PUSH
90471: EMPTY
90472: LIST
90473: LIST
90474: PUSH
90475: LD_INT 0
90477: PUSH
90478: LD_INT 2
90480: NEG
90481: PUSH
90482: EMPTY
90483: LIST
90484: LIST
90485: PUSH
90486: LD_INT 1
90488: PUSH
90489: LD_INT 1
90491: NEG
90492: PUSH
90493: EMPTY
90494: LIST
90495: LIST
90496: PUSH
90497: LD_INT 2
90499: PUSH
90500: LD_INT 0
90502: PUSH
90503: EMPTY
90504: LIST
90505: LIST
90506: PUSH
90507: LD_INT 2
90509: PUSH
90510: LD_INT 1
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: PUSH
90517: LD_INT 2
90519: PUSH
90520: LD_INT 2
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: PUSH
90527: LD_INT 1
90529: PUSH
90530: LD_INT 2
90532: PUSH
90533: EMPTY
90534: LIST
90535: LIST
90536: PUSH
90537: LD_INT 1
90539: NEG
90540: PUSH
90541: LD_INT 1
90543: PUSH
90544: EMPTY
90545: LIST
90546: LIST
90547: PUSH
90548: LD_INT 2
90550: NEG
90551: PUSH
90552: LD_INT 0
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: PUSH
90559: LD_INT 2
90561: NEG
90562: PUSH
90563: LD_INT 1
90565: NEG
90566: PUSH
90567: EMPTY
90568: LIST
90569: LIST
90570: PUSH
90571: LD_INT 1
90573: NEG
90574: PUSH
90575: LD_INT 3
90577: NEG
90578: PUSH
90579: EMPTY
90580: LIST
90581: LIST
90582: PUSH
90583: LD_INT 1
90585: PUSH
90586: LD_INT 2
90588: NEG
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: PUSH
90594: LD_INT 3
90596: PUSH
90597: LD_INT 2
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: LD_INT 2
90606: PUSH
90607: LD_INT 3
90609: PUSH
90610: EMPTY
90611: LIST
90612: LIST
90613: PUSH
90614: LD_INT 2
90616: NEG
90617: PUSH
90618: LD_INT 1
90620: PUSH
90621: EMPTY
90622: LIST
90623: LIST
90624: PUSH
90625: LD_INT 3
90627: NEG
90628: PUSH
90629: LD_INT 1
90631: NEG
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
90662: LD_ADDR_VAR 0 31
90666: PUSH
90667: LD_INT 0
90669: PUSH
90670: LD_INT 0
90672: PUSH
90673: EMPTY
90674: LIST
90675: LIST
90676: PUSH
90677: LD_INT 0
90679: PUSH
90680: LD_INT 1
90682: NEG
90683: PUSH
90684: EMPTY
90685: LIST
90686: LIST
90687: PUSH
90688: LD_INT 1
90690: PUSH
90691: LD_INT 0
90693: PUSH
90694: EMPTY
90695: LIST
90696: LIST
90697: PUSH
90698: LD_INT 1
90700: PUSH
90701: LD_INT 1
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: PUSH
90708: LD_INT 0
90710: PUSH
90711: LD_INT 1
90713: PUSH
90714: EMPTY
90715: LIST
90716: LIST
90717: PUSH
90718: LD_INT 1
90720: NEG
90721: PUSH
90722: LD_INT 0
90724: PUSH
90725: EMPTY
90726: LIST
90727: LIST
90728: PUSH
90729: LD_INT 1
90731: NEG
90732: PUSH
90733: LD_INT 1
90735: NEG
90736: PUSH
90737: EMPTY
90738: LIST
90739: LIST
90740: PUSH
90741: LD_INT 1
90743: NEG
90744: PUSH
90745: LD_INT 2
90747: NEG
90748: PUSH
90749: EMPTY
90750: LIST
90751: LIST
90752: PUSH
90753: LD_INT 1
90755: PUSH
90756: LD_INT 1
90758: NEG
90759: PUSH
90760: EMPTY
90761: LIST
90762: LIST
90763: PUSH
90764: LD_INT 2
90766: PUSH
90767: LD_INT 0
90769: PUSH
90770: EMPTY
90771: LIST
90772: LIST
90773: PUSH
90774: LD_INT 2
90776: PUSH
90777: LD_INT 1
90779: PUSH
90780: EMPTY
90781: LIST
90782: LIST
90783: PUSH
90784: LD_INT 2
90786: PUSH
90787: LD_INT 2
90789: PUSH
90790: EMPTY
90791: LIST
90792: LIST
90793: PUSH
90794: LD_INT 1
90796: PUSH
90797: LD_INT 2
90799: PUSH
90800: EMPTY
90801: LIST
90802: LIST
90803: PUSH
90804: LD_INT 0
90806: PUSH
90807: LD_INT 2
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: PUSH
90814: LD_INT 1
90816: NEG
90817: PUSH
90818: LD_INT 1
90820: PUSH
90821: EMPTY
90822: LIST
90823: LIST
90824: PUSH
90825: LD_INT 2
90827: NEG
90828: PUSH
90829: LD_INT 1
90831: NEG
90832: PUSH
90833: EMPTY
90834: LIST
90835: LIST
90836: PUSH
90837: LD_INT 2
90839: NEG
90840: PUSH
90841: LD_INT 2
90843: NEG
90844: PUSH
90845: EMPTY
90846: LIST
90847: LIST
90848: PUSH
90849: LD_INT 2
90851: NEG
90852: PUSH
90853: LD_INT 3
90855: NEG
90856: PUSH
90857: EMPTY
90858: LIST
90859: LIST
90860: PUSH
90861: LD_INT 2
90863: PUSH
90864: LD_INT 1
90866: NEG
90867: PUSH
90868: EMPTY
90869: LIST
90870: LIST
90871: PUSH
90872: LD_INT 3
90874: PUSH
90875: LD_INT 1
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 1
90884: PUSH
90885: LD_INT 3
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 1
90894: NEG
90895: PUSH
90896: LD_INT 2
90898: PUSH
90899: EMPTY
90900: LIST
90901: LIST
90902: PUSH
90903: LD_INT 3
90905: NEG
90906: PUSH
90907: LD_INT 2
90909: NEG
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: LIST
90919: LIST
90920: LIST
90921: LIST
90922: LIST
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: LIST
90928: LIST
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
90940: LD_ADDR_VAR 0 32
90944: PUSH
90945: LD_INT 0
90947: PUSH
90948: LD_INT 0
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: LD_INT 0
90957: PUSH
90958: LD_INT 1
90960: NEG
90961: PUSH
90962: EMPTY
90963: LIST
90964: LIST
90965: PUSH
90966: LD_INT 1
90968: PUSH
90969: LD_INT 0
90971: PUSH
90972: EMPTY
90973: LIST
90974: LIST
90975: PUSH
90976: LD_INT 1
90978: PUSH
90979: LD_INT 1
90981: PUSH
90982: EMPTY
90983: LIST
90984: LIST
90985: PUSH
90986: LD_INT 0
90988: PUSH
90989: LD_INT 1
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PUSH
90996: LD_INT 1
90998: NEG
90999: PUSH
91000: LD_INT 0
91002: PUSH
91003: EMPTY
91004: LIST
91005: LIST
91006: PUSH
91007: LD_INT 1
91009: NEG
91010: PUSH
91011: LD_INT 1
91013: NEG
91014: PUSH
91015: EMPTY
91016: LIST
91017: LIST
91018: PUSH
91019: LD_INT 1
91021: NEG
91022: PUSH
91023: LD_INT 2
91025: NEG
91026: PUSH
91027: EMPTY
91028: LIST
91029: LIST
91030: PUSH
91031: LD_INT 0
91033: PUSH
91034: LD_INT 2
91036: NEG
91037: PUSH
91038: EMPTY
91039: LIST
91040: LIST
91041: PUSH
91042: LD_INT 1
91044: PUSH
91045: LD_INT 1
91047: NEG
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: PUSH
91053: LD_INT 2
91055: PUSH
91056: LD_INT 1
91058: PUSH
91059: EMPTY
91060: LIST
91061: LIST
91062: PUSH
91063: LD_INT 2
91065: PUSH
91066: LD_INT 2
91068: PUSH
91069: EMPTY
91070: LIST
91071: LIST
91072: PUSH
91073: LD_INT 1
91075: PUSH
91076: LD_INT 2
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: LD_INT 0
91085: PUSH
91086: LD_INT 2
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PUSH
91093: LD_INT 1
91095: NEG
91096: PUSH
91097: LD_INT 1
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 2
91106: NEG
91107: PUSH
91108: LD_INT 0
91110: PUSH
91111: EMPTY
91112: LIST
91113: LIST
91114: PUSH
91115: LD_INT 2
91117: NEG
91118: PUSH
91119: LD_INT 1
91121: NEG
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: PUSH
91127: LD_INT 1
91129: NEG
91130: PUSH
91131: LD_INT 3
91133: NEG
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: PUSH
91139: LD_INT 1
91141: PUSH
91142: LD_INT 2
91144: NEG
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: PUSH
91150: LD_INT 3
91152: PUSH
91153: LD_INT 2
91155: PUSH
91156: EMPTY
91157: LIST
91158: LIST
91159: PUSH
91160: LD_INT 2
91162: PUSH
91163: LD_INT 3
91165: PUSH
91166: EMPTY
91167: LIST
91168: LIST
91169: PUSH
91170: LD_INT 2
91172: NEG
91173: PUSH
91174: LD_INT 1
91176: PUSH
91177: EMPTY
91178: LIST
91179: LIST
91180: PUSH
91181: LD_INT 3
91183: NEG
91184: PUSH
91185: LD_INT 1
91187: NEG
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: EMPTY
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: LIST
91213: LIST
91214: LIST
91215: LIST
91216: LIST
91217: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
91218: LD_ADDR_VAR 0 33
91222: PUSH
91223: LD_INT 0
91225: PUSH
91226: LD_INT 0
91228: PUSH
91229: EMPTY
91230: LIST
91231: LIST
91232: PUSH
91233: LD_INT 0
91235: PUSH
91236: LD_INT 1
91238: NEG
91239: PUSH
91240: EMPTY
91241: LIST
91242: LIST
91243: PUSH
91244: LD_INT 1
91246: PUSH
91247: LD_INT 0
91249: PUSH
91250: EMPTY
91251: LIST
91252: LIST
91253: PUSH
91254: LD_INT 1
91256: PUSH
91257: LD_INT 1
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: PUSH
91264: LD_INT 0
91266: PUSH
91267: LD_INT 1
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: PUSH
91274: LD_INT 1
91276: NEG
91277: PUSH
91278: LD_INT 0
91280: PUSH
91281: EMPTY
91282: LIST
91283: LIST
91284: PUSH
91285: LD_INT 1
91287: NEG
91288: PUSH
91289: LD_INT 1
91291: NEG
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PUSH
91297: LD_INT 1
91299: NEG
91300: PUSH
91301: LD_INT 2
91303: NEG
91304: PUSH
91305: EMPTY
91306: LIST
91307: LIST
91308: PUSH
91309: LD_INT 1
91311: PUSH
91312: LD_INT 1
91314: NEG
91315: PUSH
91316: EMPTY
91317: LIST
91318: LIST
91319: PUSH
91320: LD_INT 2
91322: PUSH
91323: LD_INT 0
91325: PUSH
91326: EMPTY
91327: LIST
91328: LIST
91329: PUSH
91330: LD_INT 2
91332: PUSH
91333: LD_INT 1
91335: PUSH
91336: EMPTY
91337: LIST
91338: LIST
91339: PUSH
91340: LD_INT 1
91342: PUSH
91343: LD_INT 2
91345: PUSH
91346: EMPTY
91347: LIST
91348: LIST
91349: PUSH
91350: LD_INT 0
91352: PUSH
91353: LD_INT 2
91355: PUSH
91356: EMPTY
91357: LIST
91358: LIST
91359: PUSH
91360: LD_INT 1
91362: NEG
91363: PUSH
91364: LD_INT 1
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: LD_INT 2
91373: NEG
91374: PUSH
91375: LD_INT 0
91377: PUSH
91378: EMPTY
91379: LIST
91380: LIST
91381: PUSH
91382: LD_INT 2
91384: NEG
91385: PUSH
91386: LD_INT 1
91388: NEG
91389: PUSH
91390: EMPTY
91391: LIST
91392: LIST
91393: PUSH
91394: LD_INT 2
91396: NEG
91397: PUSH
91398: LD_INT 2
91400: NEG
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 2
91408: NEG
91409: PUSH
91410: LD_INT 3
91412: NEG
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: PUSH
91418: LD_INT 2
91420: PUSH
91421: LD_INT 1
91423: NEG
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: LD_INT 3
91431: PUSH
91432: LD_INT 1
91434: PUSH
91435: EMPTY
91436: LIST
91437: LIST
91438: PUSH
91439: LD_INT 1
91441: PUSH
91442: LD_INT 3
91444: PUSH
91445: EMPTY
91446: LIST
91447: LIST
91448: PUSH
91449: LD_INT 1
91451: NEG
91452: PUSH
91453: LD_INT 2
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: PUSH
91460: LD_INT 3
91462: NEG
91463: PUSH
91464: LD_INT 2
91466: NEG
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: EMPTY
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: LIST
91478: LIST
91479: LIST
91480: LIST
91481: LIST
91482: LIST
91483: LIST
91484: LIST
91485: LIST
91486: LIST
91487: LIST
91488: LIST
91489: LIST
91490: LIST
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91497: LD_ADDR_VAR 0 34
91501: PUSH
91502: LD_INT 0
91504: PUSH
91505: LD_INT 0
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: PUSH
91512: LD_INT 0
91514: PUSH
91515: LD_INT 1
91517: NEG
91518: PUSH
91519: EMPTY
91520: LIST
91521: LIST
91522: PUSH
91523: LD_INT 1
91525: PUSH
91526: LD_INT 0
91528: PUSH
91529: EMPTY
91530: LIST
91531: LIST
91532: PUSH
91533: LD_INT 1
91535: PUSH
91536: LD_INT 1
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: PUSH
91543: LD_INT 0
91545: PUSH
91546: LD_INT 1
91548: PUSH
91549: EMPTY
91550: LIST
91551: LIST
91552: PUSH
91553: LD_INT 1
91555: NEG
91556: PUSH
91557: LD_INT 0
91559: PUSH
91560: EMPTY
91561: LIST
91562: LIST
91563: PUSH
91564: LD_INT 1
91566: NEG
91567: PUSH
91568: LD_INT 1
91570: NEG
91571: PUSH
91572: EMPTY
91573: LIST
91574: LIST
91575: PUSH
91576: LD_INT 1
91578: NEG
91579: PUSH
91580: LD_INT 2
91582: NEG
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 0
91590: PUSH
91591: LD_INT 2
91593: NEG
91594: PUSH
91595: EMPTY
91596: LIST
91597: LIST
91598: PUSH
91599: LD_INT 1
91601: PUSH
91602: LD_INT 1
91604: NEG
91605: PUSH
91606: EMPTY
91607: LIST
91608: LIST
91609: PUSH
91610: LD_INT 2
91612: PUSH
91613: LD_INT 1
91615: PUSH
91616: EMPTY
91617: LIST
91618: LIST
91619: PUSH
91620: LD_INT 2
91622: PUSH
91623: LD_INT 2
91625: PUSH
91626: EMPTY
91627: LIST
91628: LIST
91629: PUSH
91630: LD_INT 1
91632: PUSH
91633: LD_INT 2
91635: PUSH
91636: EMPTY
91637: LIST
91638: LIST
91639: PUSH
91640: LD_INT 1
91642: NEG
91643: PUSH
91644: LD_INT 1
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PUSH
91651: LD_INT 2
91653: NEG
91654: PUSH
91655: LD_INT 0
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: LD_INT 2
91664: NEG
91665: PUSH
91666: LD_INT 1
91668: NEG
91669: PUSH
91670: EMPTY
91671: LIST
91672: LIST
91673: PUSH
91674: LD_INT 2
91676: NEG
91677: PUSH
91678: LD_INT 2
91680: NEG
91681: PUSH
91682: EMPTY
91683: LIST
91684: LIST
91685: PUSH
91686: LD_INT 1
91688: NEG
91689: PUSH
91690: LD_INT 3
91692: NEG
91693: PUSH
91694: EMPTY
91695: LIST
91696: LIST
91697: PUSH
91698: LD_INT 1
91700: PUSH
91701: LD_INT 2
91703: NEG
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: PUSH
91709: LD_INT 3
91711: PUSH
91712: LD_INT 2
91714: PUSH
91715: EMPTY
91716: LIST
91717: LIST
91718: PUSH
91719: LD_INT 2
91721: PUSH
91722: LD_INT 3
91724: PUSH
91725: EMPTY
91726: LIST
91727: LIST
91728: PUSH
91729: LD_INT 2
91731: NEG
91732: PUSH
91733: LD_INT 1
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 3
91742: NEG
91743: PUSH
91744: LD_INT 1
91746: NEG
91747: PUSH
91748: EMPTY
91749: LIST
91750: LIST
91751: PUSH
91752: EMPTY
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: LIST
91766: LIST
91767: LIST
91768: LIST
91769: LIST
91770: LIST
91771: LIST
91772: LIST
91773: LIST
91774: LIST
91775: LIST
91776: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
91777: LD_ADDR_VAR 0 35
91781: PUSH
91782: LD_INT 0
91784: PUSH
91785: LD_INT 0
91787: PUSH
91788: EMPTY
91789: LIST
91790: LIST
91791: PUSH
91792: LD_INT 0
91794: PUSH
91795: LD_INT 1
91797: NEG
91798: PUSH
91799: EMPTY
91800: LIST
91801: LIST
91802: PUSH
91803: LD_INT 1
91805: PUSH
91806: LD_INT 0
91808: PUSH
91809: EMPTY
91810: LIST
91811: LIST
91812: PUSH
91813: LD_INT 1
91815: PUSH
91816: LD_INT 1
91818: PUSH
91819: EMPTY
91820: LIST
91821: LIST
91822: PUSH
91823: LD_INT 0
91825: PUSH
91826: LD_INT 1
91828: PUSH
91829: EMPTY
91830: LIST
91831: LIST
91832: PUSH
91833: LD_INT 1
91835: NEG
91836: PUSH
91837: LD_INT 0
91839: PUSH
91840: EMPTY
91841: LIST
91842: LIST
91843: PUSH
91844: LD_INT 1
91846: NEG
91847: PUSH
91848: LD_INT 1
91850: NEG
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PUSH
91856: LD_INT 2
91858: PUSH
91859: LD_INT 1
91861: PUSH
91862: EMPTY
91863: LIST
91864: LIST
91865: PUSH
91866: LD_INT 2
91868: NEG
91869: PUSH
91870: LD_INT 1
91872: NEG
91873: PUSH
91874: EMPTY
91875: LIST
91876: LIST
91877: PUSH
91878: EMPTY
91879: LIST
91880: LIST
91881: LIST
91882: LIST
91883: LIST
91884: LIST
91885: LIST
91886: LIST
91887: LIST
91888: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
91889: LD_ADDR_VAR 0 36
91893: PUSH
91894: LD_INT 0
91896: PUSH
91897: LD_INT 0
91899: PUSH
91900: EMPTY
91901: LIST
91902: LIST
91903: PUSH
91904: LD_INT 0
91906: PUSH
91907: LD_INT 1
91909: NEG
91910: PUSH
91911: EMPTY
91912: LIST
91913: LIST
91914: PUSH
91915: LD_INT 1
91917: PUSH
91918: LD_INT 0
91920: PUSH
91921: EMPTY
91922: LIST
91923: LIST
91924: PUSH
91925: LD_INT 1
91927: PUSH
91928: LD_INT 1
91930: PUSH
91931: EMPTY
91932: LIST
91933: LIST
91934: PUSH
91935: LD_INT 0
91937: PUSH
91938: LD_INT 1
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: PUSH
91945: LD_INT 1
91947: NEG
91948: PUSH
91949: LD_INT 0
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: PUSH
91956: LD_INT 1
91958: NEG
91959: PUSH
91960: LD_INT 1
91962: NEG
91963: PUSH
91964: EMPTY
91965: LIST
91966: LIST
91967: PUSH
91968: LD_INT 1
91970: NEG
91971: PUSH
91972: LD_INT 2
91974: NEG
91975: PUSH
91976: EMPTY
91977: LIST
91978: LIST
91979: PUSH
91980: LD_INT 1
91982: PUSH
91983: LD_INT 2
91985: PUSH
91986: EMPTY
91987: LIST
91988: LIST
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: LIST
91998: LIST
91999: LIST
92000: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
92001: LD_ADDR_VAR 0 37
92005: PUSH
92006: LD_INT 0
92008: PUSH
92009: LD_INT 0
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PUSH
92016: LD_INT 0
92018: PUSH
92019: LD_INT 1
92021: NEG
92022: PUSH
92023: EMPTY
92024: LIST
92025: LIST
92026: PUSH
92027: LD_INT 1
92029: PUSH
92030: LD_INT 0
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: PUSH
92037: LD_INT 1
92039: PUSH
92040: LD_INT 1
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: PUSH
92047: LD_INT 0
92049: PUSH
92050: LD_INT 1
92052: PUSH
92053: EMPTY
92054: LIST
92055: LIST
92056: PUSH
92057: LD_INT 1
92059: NEG
92060: PUSH
92061: LD_INT 0
92063: PUSH
92064: EMPTY
92065: LIST
92066: LIST
92067: PUSH
92068: LD_INT 1
92070: NEG
92071: PUSH
92072: LD_INT 1
92074: NEG
92075: PUSH
92076: EMPTY
92077: LIST
92078: LIST
92079: PUSH
92080: LD_INT 1
92082: PUSH
92083: LD_INT 1
92085: NEG
92086: PUSH
92087: EMPTY
92088: LIST
92089: LIST
92090: PUSH
92091: LD_INT 1
92093: NEG
92094: PUSH
92095: LD_INT 1
92097: PUSH
92098: EMPTY
92099: LIST
92100: LIST
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: LIST
92106: LIST
92107: LIST
92108: LIST
92109: LIST
92110: LIST
92111: LIST
92112: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
92113: LD_ADDR_VAR 0 38
92117: PUSH
92118: LD_INT 0
92120: PUSH
92121: LD_INT 0
92123: PUSH
92124: EMPTY
92125: LIST
92126: LIST
92127: PUSH
92128: LD_INT 0
92130: PUSH
92131: LD_INT 1
92133: NEG
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 1
92141: PUSH
92142: LD_INT 0
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: PUSH
92149: LD_INT 1
92151: PUSH
92152: LD_INT 1
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: LD_INT 0
92161: PUSH
92162: LD_INT 1
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: PUSH
92169: LD_INT 1
92171: NEG
92172: PUSH
92173: LD_INT 0
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: PUSH
92180: LD_INT 1
92182: NEG
92183: PUSH
92184: LD_INT 1
92186: NEG
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: PUSH
92192: LD_INT 2
92194: PUSH
92195: LD_INT 1
92197: PUSH
92198: EMPTY
92199: LIST
92200: LIST
92201: PUSH
92202: LD_INT 2
92204: NEG
92205: PUSH
92206: LD_INT 1
92208: NEG
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: EMPTY
92215: LIST
92216: LIST
92217: LIST
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
92225: LD_ADDR_VAR 0 39
92229: PUSH
92230: LD_INT 0
92232: PUSH
92233: LD_INT 0
92235: PUSH
92236: EMPTY
92237: LIST
92238: LIST
92239: PUSH
92240: LD_INT 0
92242: PUSH
92243: LD_INT 1
92245: NEG
92246: PUSH
92247: EMPTY
92248: LIST
92249: LIST
92250: PUSH
92251: LD_INT 1
92253: PUSH
92254: LD_INT 0
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: PUSH
92261: LD_INT 1
92263: PUSH
92264: LD_INT 1
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: PUSH
92271: LD_INT 0
92273: PUSH
92274: LD_INT 1
92276: PUSH
92277: EMPTY
92278: LIST
92279: LIST
92280: PUSH
92281: LD_INT 1
92283: NEG
92284: PUSH
92285: LD_INT 0
92287: PUSH
92288: EMPTY
92289: LIST
92290: LIST
92291: PUSH
92292: LD_INT 1
92294: NEG
92295: PUSH
92296: LD_INT 1
92298: NEG
92299: PUSH
92300: EMPTY
92301: LIST
92302: LIST
92303: PUSH
92304: LD_INT 1
92306: NEG
92307: PUSH
92308: LD_INT 2
92310: NEG
92311: PUSH
92312: EMPTY
92313: LIST
92314: LIST
92315: PUSH
92316: LD_INT 1
92318: PUSH
92319: LD_INT 2
92321: PUSH
92322: EMPTY
92323: LIST
92324: LIST
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: LIST
92330: LIST
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
92337: LD_ADDR_VAR 0 40
92341: PUSH
92342: LD_INT 0
92344: PUSH
92345: LD_INT 0
92347: PUSH
92348: EMPTY
92349: LIST
92350: LIST
92351: PUSH
92352: LD_INT 0
92354: PUSH
92355: LD_INT 1
92357: NEG
92358: PUSH
92359: EMPTY
92360: LIST
92361: LIST
92362: PUSH
92363: LD_INT 1
92365: PUSH
92366: LD_INT 0
92368: PUSH
92369: EMPTY
92370: LIST
92371: LIST
92372: PUSH
92373: LD_INT 1
92375: PUSH
92376: LD_INT 1
92378: PUSH
92379: EMPTY
92380: LIST
92381: LIST
92382: PUSH
92383: LD_INT 0
92385: PUSH
92386: LD_INT 1
92388: PUSH
92389: EMPTY
92390: LIST
92391: LIST
92392: PUSH
92393: LD_INT 1
92395: NEG
92396: PUSH
92397: LD_INT 0
92399: PUSH
92400: EMPTY
92401: LIST
92402: LIST
92403: PUSH
92404: LD_INT 1
92406: NEG
92407: PUSH
92408: LD_INT 1
92410: NEG
92411: PUSH
92412: EMPTY
92413: LIST
92414: LIST
92415: PUSH
92416: LD_INT 1
92418: PUSH
92419: LD_INT 1
92421: NEG
92422: PUSH
92423: EMPTY
92424: LIST
92425: LIST
92426: PUSH
92427: LD_INT 1
92429: NEG
92430: PUSH
92431: LD_INT 1
92433: PUSH
92434: EMPTY
92435: LIST
92436: LIST
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92449: LD_ADDR_VAR 0 41
92453: PUSH
92454: LD_INT 0
92456: PUSH
92457: LD_INT 0
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: PUSH
92464: LD_INT 0
92466: PUSH
92467: LD_INT 1
92469: NEG
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 1
92477: PUSH
92478: LD_INT 0
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: PUSH
92485: LD_INT 1
92487: PUSH
92488: LD_INT 1
92490: PUSH
92491: EMPTY
92492: LIST
92493: LIST
92494: PUSH
92495: LD_INT 0
92497: PUSH
92498: LD_INT 1
92500: PUSH
92501: EMPTY
92502: LIST
92503: LIST
92504: PUSH
92505: LD_INT 1
92507: NEG
92508: PUSH
92509: LD_INT 0
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: LD_INT 1
92518: NEG
92519: PUSH
92520: LD_INT 1
92522: NEG
92523: PUSH
92524: EMPTY
92525: LIST
92526: LIST
92527: PUSH
92528: LD_INT 1
92530: NEG
92531: PUSH
92532: LD_INT 2
92534: NEG
92535: PUSH
92536: EMPTY
92537: LIST
92538: LIST
92539: PUSH
92540: LD_INT 1
92542: PUSH
92543: LD_INT 1
92545: NEG
92546: PUSH
92547: EMPTY
92548: LIST
92549: LIST
92550: PUSH
92551: LD_INT 2
92553: PUSH
92554: LD_INT 0
92556: PUSH
92557: EMPTY
92558: LIST
92559: LIST
92560: PUSH
92561: LD_INT 2
92563: PUSH
92564: LD_INT 1
92566: PUSH
92567: EMPTY
92568: LIST
92569: LIST
92570: PUSH
92571: LD_INT 2
92573: PUSH
92574: LD_INT 2
92576: PUSH
92577: EMPTY
92578: LIST
92579: LIST
92580: PUSH
92581: LD_INT 1
92583: PUSH
92584: LD_INT 2
92586: PUSH
92587: EMPTY
92588: LIST
92589: LIST
92590: PUSH
92591: LD_INT 1
92593: NEG
92594: PUSH
92595: LD_INT 1
92597: PUSH
92598: EMPTY
92599: LIST
92600: LIST
92601: PUSH
92602: LD_INT 2
92604: NEG
92605: PUSH
92606: LD_INT 0
92608: PUSH
92609: EMPTY
92610: LIST
92611: LIST
92612: PUSH
92613: LD_INT 2
92615: NEG
92616: PUSH
92617: LD_INT 1
92619: NEG
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: PUSH
92625: LD_INT 2
92627: NEG
92628: PUSH
92629: LD_INT 2
92631: NEG
92632: PUSH
92633: EMPTY
92634: LIST
92635: LIST
92636: PUSH
92637: LD_INT 2
92639: NEG
92640: PUSH
92641: LD_INT 3
92643: NEG
92644: PUSH
92645: EMPTY
92646: LIST
92647: LIST
92648: PUSH
92649: LD_INT 2
92651: PUSH
92652: LD_INT 1
92654: NEG
92655: PUSH
92656: EMPTY
92657: LIST
92658: LIST
92659: PUSH
92660: LD_INT 3
92662: PUSH
92663: LD_INT 0
92665: PUSH
92666: EMPTY
92667: LIST
92668: LIST
92669: PUSH
92670: LD_INT 3
92672: PUSH
92673: LD_INT 1
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: PUSH
92680: LD_INT 3
92682: PUSH
92683: LD_INT 2
92685: PUSH
92686: EMPTY
92687: LIST
92688: LIST
92689: PUSH
92690: LD_INT 3
92692: PUSH
92693: LD_INT 3
92695: PUSH
92696: EMPTY
92697: LIST
92698: LIST
92699: PUSH
92700: LD_INT 2
92702: PUSH
92703: LD_INT 3
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 2
92712: NEG
92713: PUSH
92714: LD_INT 1
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 3
92723: NEG
92724: PUSH
92725: LD_INT 0
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: PUSH
92732: LD_INT 3
92734: NEG
92735: PUSH
92736: LD_INT 1
92738: NEG
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: PUSH
92744: LD_INT 3
92746: NEG
92747: PUSH
92748: LD_INT 2
92750: NEG
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: PUSH
92756: LD_INT 3
92758: NEG
92759: PUSH
92760: LD_INT 3
92762: NEG
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: EMPTY
92769: LIST
92770: LIST
92771: LIST
92772: LIST
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: LIST
92782: LIST
92783: LIST
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: LIST
92797: LIST
92798: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92799: LD_ADDR_VAR 0 42
92803: PUSH
92804: LD_INT 0
92806: PUSH
92807: LD_INT 0
92809: PUSH
92810: EMPTY
92811: LIST
92812: LIST
92813: PUSH
92814: LD_INT 0
92816: PUSH
92817: LD_INT 1
92819: NEG
92820: PUSH
92821: EMPTY
92822: LIST
92823: LIST
92824: PUSH
92825: LD_INT 1
92827: PUSH
92828: LD_INT 0
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: PUSH
92835: LD_INT 1
92837: PUSH
92838: LD_INT 1
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: PUSH
92845: LD_INT 0
92847: PUSH
92848: LD_INT 1
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: PUSH
92855: LD_INT 1
92857: NEG
92858: PUSH
92859: LD_INT 0
92861: PUSH
92862: EMPTY
92863: LIST
92864: LIST
92865: PUSH
92866: LD_INT 1
92868: NEG
92869: PUSH
92870: LD_INT 1
92872: NEG
92873: PUSH
92874: EMPTY
92875: LIST
92876: LIST
92877: PUSH
92878: LD_INT 1
92880: NEG
92881: PUSH
92882: LD_INT 2
92884: NEG
92885: PUSH
92886: EMPTY
92887: LIST
92888: LIST
92889: PUSH
92890: LD_INT 0
92892: PUSH
92893: LD_INT 2
92895: NEG
92896: PUSH
92897: EMPTY
92898: LIST
92899: LIST
92900: PUSH
92901: LD_INT 1
92903: PUSH
92904: LD_INT 1
92906: NEG
92907: PUSH
92908: EMPTY
92909: LIST
92910: LIST
92911: PUSH
92912: LD_INT 2
92914: PUSH
92915: LD_INT 1
92917: PUSH
92918: EMPTY
92919: LIST
92920: LIST
92921: PUSH
92922: LD_INT 2
92924: PUSH
92925: LD_INT 2
92927: PUSH
92928: EMPTY
92929: LIST
92930: LIST
92931: PUSH
92932: LD_INT 1
92934: PUSH
92935: LD_INT 2
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: PUSH
92942: LD_INT 0
92944: PUSH
92945: LD_INT 2
92947: PUSH
92948: EMPTY
92949: LIST
92950: LIST
92951: PUSH
92952: LD_INT 1
92954: NEG
92955: PUSH
92956: LD_INT 1
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: LD_INT 2
92965: NEG
92966: PUSH
92967: LD_INT 1
92969: NEG
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: LD_INT 2
92977: NEG
92978: PUSH
92979: LD_INT 2
92981: NEG
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: PUSH
92987: LD_INT 2
92989: NEG
92990: PUSH
92991: LD_INT 3
92993: NEG
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 1
93001: NEG
93002: PUSH
93003: LD_INT 3
93005: NEG
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 0
93013: PUSH
93014: LD_INT 3
93016: NEG
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 1
93024: PUSH
93025: LD_INT 2
93027: NEG
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: LD_INT 3
93035: PUSH
93036: LD_INT 2
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PUSH
93043: LD_INT 3
93045: PUSH
93046: LD_INT 3
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 2
93055: PUSH
93056: LD_INT 3
93058: PUSH
93059: EMPTY
93060: LIST
93061: LIST
93062: PUSH
93063: LD_INT 1
93065: PUSH
93066: LD_INT 3
93068: PUSH
93069: EMPTY
93070: LIST
93071: LIST
93072: PUSH
93073: LD_INT 0
93075: PUSH
93076: LD_INT 3
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 1
93085: NEG
93086: PUSH
93087: LD_INT 2
93089: PUSH
93090: EMPTY
93091: LIST
93092: LIST
93093: PUSH
93094: LD_INT 3
93096: NEG
93097: PUSH
93098: LD_INT 2
93100: NEG
93101: PUSH
93102: EMPTY
93103: LIST
93104: LIST
93105: PUSH
93106: LD_INT 3
93108: NEG
93109: PUSH
93110: LD_INT 3
93112: NEG
93113: PUSH
93114: EMPTY
93115: LIST
93116: LIST
93117: PUSH
93118: EMPTY
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93149: LD_ADDR_VAR 0 43
93153: PUSH
93154: LD_INT 0
93156: PUSH
93157: LD_INT 0
93159: PUSH
93160: EMPTY
93161: LIST
93162: LIST
93163: PUSH
93164: LD_INT 0
93166: PUSH
93167: LD_INT 1
93169: NEG
93170: PUSH
93171: EMPTY
93172: LIST
93173: LIST
93174: PUSH
93175: LD_INT 1
93177: PUSH
93178: LD_INT 0
93180: PUSH
93181: EMPTY
93182: LIST
93183: LIST
93184: PUSH
93185: LD_INT 1
93187: PUSH
93188: LD_INT 1
93190: PUSH
93191: EMPTY
93192: LIST
93193: LIST
93194: PUSH
93195: LD_INT 0
93197: PUSH
93198: LD_INT 1
93200: PUSH
93201: EMPTY
93202: LIST
93203: LIST
93204: PUSH
93205: LD_INT 1
93207: NEG
93208: PUSH
93209: LD_INT 0
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PUSH
93216: LD_INT 1
93218: NEG
93219: PUSH
93220: LD_INT 1
93222: NEG
93223: PUSH
93224: EMPTY
93225: LIST
93226: LIST
93227: PUSH
93228: LD_INT 1
93230: NEG
93231: PUSH
93232: LD_INT 2
93234: NEG
93235: PUSH
93236: EMPTY
93237: LIST
93238: LIST
93239: PUSH
93240: LD_INT 0
93242: PUSH
93243: LD_INT 2
93245: NEG
93246: PUSH
93247: EMPTY
93248: LIST
93249: LIST
93250: PUSH
93251: LD_INT 1
93253: PUSH
93254: LD_INT 1
93256: NEG
93257: PUSH
93258: EMPTY
93259: LIST
93260: LIST
93261: PUSH
93262: LD_INT 2
93264: PUSH
93265: LD_INT 0
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 2
93274: PUSH
93275: LD_INT 1
93277: PUSH
93278: EMPTY
93279: LIST
93280: LIST
93281: PUSH
93282: LD_INT 1
93284: PUSH
93285: LD_INT 2
93287: PUSH
93288: EMPTY
93289: LIST
93290: LIST
93291: PUSH
93292: LD_INT 0
93294: PUSH
93295: LD_INT 2
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 1
93304: NEG
93305: PUSH
93306: LD_INT 1
93308: PUSH
93309: EMPTY
93310: LIST
93311: LIST
93312: PUSH
93313: LD_INT 2
93315: NEG
93316: PUSH
93317: LD_INT 0
93319: PUSH
93320: EMPTY
93321: LIST
93322: LIST
93323: PUSH
93324: LD_INT 2
93326: NEG
93327: PUSH
93328: LD_INT 1
93330: NEG
93331: PUSH
93332: EMPTY
93333: LIST
93334: LIST
93335: PUSH
93336: LD_INT 1
93338: NEG
93339: PUSH
93340: LD_INT 3
93342: NEG
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PUSH
93348: LD_INT 0
93350: PUSH
93351: LD_INT 3
93353: NEG
93354: PUSH
93355: EMPTY
93356: LIST
93357: LIST
93358: PUSH
93359: LD_INT 1
93361: PUSH
93362: LD_INT 2
93364: NEG
93365: PUSH
93366: EMPTY
93367: LIST
93368: LIST
93369: PUSH
93370: LD_INT 2
93372: PUSH
93373: LD_INT 1
93375: NEG
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: LD_INT 3
93383: PUSH
93384: LD_INT 0
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: PUSH
93391: LD_INT 3
93393: PUSH
93394: LD_INT 1
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PUSH
93401: LD_INT 1
93403: PUSH
93404: LD_INT 3
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: PUSH
93411: LD_INT 0
93413: PUSH
93414: LD_INT 3
93416: PUSH
93417: EMPTY
93418: LIST
93419: LIST
93420: PUSH
93421: LD_INT 1
93423: NEG
93424: PUSH
93425: LD_INT 2
93427: PUSH
93428: EMPTY
93429: LIST
93430: LIST
93431: PUSH
93432: LD_INT 2
93434: NEG
93435: PUSH
93436: LD_INT 1
93438: PUSH
93439: EMPTY
93440: LIST
93441: LIST
93442: PUSH
93443: LD_INT 3
93445: NEG
93446: PUSH
93447: LD_INT 0
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: PUSH
93454: LD_INT 3
93456: NEG
93457: PUSH
93458: LD_INT 1
93460: NEG
93461: PUSH
93462: EMPTY
93463: LIST
93464: LIST
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: LIST
93470: LIST
93471: LIST
93472: LIST
93473: LIST
93474: LIST
93475: LIST
93476: LIST
93477: LIST
93478: LIST
93479: LIST
93480: LIST
93481: LIST
93482: LIST
93483: LIST
93484: LIST
93485: LIST
93486: LIST
93487: LIST
93488: LIST
93489: LIST
93490: LIST
93491: LIST
93492: LIST
93493: LIST
93494: LIST
93495: LIST
93496: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93497: LD_ADDR_VAR 0 44
93501: PUSH
93502: LD_INT 0
93504: PUSH
93505: LD_INT 0
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: PUSH
93512: LD_INT 0
93514: PUSH
93515: LD_INT 1
93517: NEG
93518: PUSH
93519: EMPTY
93520: LIST
93521: LIST
93522: PUSH
93523: LD_INT 1
93525: PUSH
93526: LD_INT 0
93528: PUSH
93529: EMPTY
93530: LIST
93531: LIST
93532: PUSH
93533: LD_INT 1
93535: PUSH
93536: LD_INT 1
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: PUSH
93543: LD_INT 0
93545: PUSH
93546: LD_INT 1
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: PUSH
93553: LD_INT 1
93555: NEG
93556: PUSH
93557: LD_INT 0
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 1
93566: NEG
93567: PUSH
93568: LD_INT 1
93570: NEG
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: LD_INT 1
93578: NEG
93579: PUSH
93580: LD_INT 2
93582: NEG
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: LD_INT 1
93590: PUSH
93591: LD_INT 1
93593: NEG
93594: PUSH
93595: EMPTY
93596: LIST
93597: LIST
93598: PUSH
93599: LD_INT 2
93601: PUSH
93602: LD_INT 0
93604: PUSH
93605: EMPTY
93606: LIST
93607: LIST
93608: PUSH
93609: LD_INT 2
93611: PUSH
93612: LD_INT 1
93614: PUSH
93615: EMPTY
93616: LIST
93617: LIST
93618: PUSH
93619: LD_INT 2
93621: PUSH
93622: LD_INT 2
93624: PUSH
93625: EMPTY
93626: LIST
93627: LIST
93628: PUSH
93629: LD_INT 1
93631: PUSH
93632: LD_INT 2
93634: PUSH
93635: EMPTY
93636: LIST
93637: LIST
93638: PUSH
93639: LD_INT 1
93641: NEG
93642: PUSH
93643: LD_INT 1
93645: PUSH
93646: EMPTY
93647: LIST
93648: LIST
93649: PUSH
93650: LD_INT 2
93652: NEG
93653: PUSH
93654: LD_INT 0
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: PUSH
93661: LD_INT 2
93663: NEG
93664: PUSH
93665: LD_INT 1
93667: NEG
93668: PUSH
93669: EMPTY
93670: LIST
93671: LIST
93672: PUSH
93673: LD_INT 2
93675: NEG
93676: PUSH
93677: LD_INT 2
93679: NEG
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: PUSH
93685: LD_INT 2
93687: NEG
93688: PUSH
93689: LD_INT 3
93691: NEG
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: PUSH
93697: LD_INT 2
93699: PUSH
93700: LD_INT 1
93702: NEG
93703: PUSH
93704: EMPTY
93705: LIST
93706: LIST
93707: PUSH
93708: LD_INT 3
93710: PUSH
93711: LD_INT 0
93713: PUSH
93714: EMPTY
93715: LIST
93716: LIST
93717: PUSH
93718: LD_INT 3
93720: PUSH
93721: LD_INT 1
93723: PUSH
93724: EMPTY
93725: LIST
93726: LIST
93727: PUSH
93728: LD_INT 3
93730: PUSH
93731: LD_INT 2
93733: PUSH
93734: EMPTY
93735: LIST
93736: LIST
93737: PUSH
93738: LD_INT 3
93740: PUSH
93741: LD_INT 3
93743: PUSH
93744: EMPTY
93745: LIST
93746: LIST
93747: PUSH
93748: LD_INT 2
93750: PUSH
93751: LD_INT 3
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: PUSH
93758: LD_INT 2
93760: NEG
93761: PUSH
93762: LD_INT 1
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: PUSH
93769: LD_INT 3
93771: NEG
93772: PUSH
93773: LD_INT 0
93775: PUSH
93776: EMPTY
93777: LIST
93778: LIST
93779: PUSH
93780: LD_INT 3
93782: NEG
93783: PUSH
93784: LD_INT 1
93786: NEG
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: PUSH
93792: LD_INT 3
93794: NEG
93795: PUSH
93796: LD_INT 2
93798: NEG
93799: PUSH
93800: EMPTY
93801: LIST
93802: LIST
93803: PUSH
93804: LD_INT 3
93806: NEG
93807: PUSH
93808: LD_INT 3
93810: NEG
93811: PUSH
93812: EMPTY
93813: LIST
93814: LIST
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: LIST
93820: LIST
93821: LIST
93822: LIST
93823: LIST
93824: LIST
93825: LIST
93826: LIST
93827: LIST
93828: LIST
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: LIST
93838: LIST
93839: LIST
93840: LIST
93841: LIST
93842: LIST
93843: LIST
93844: LIST
93845: LIST
93846: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93847: LD_ADDR_VAR 0 45
93851: PUSH
93852: LD_INT 0
93854: PUSH
93855: LD_INT 0
93857: PUSH
93858: EMPTY
93859: LIST
93860: LIST
93861: PUSH
93862: LD_INT 0
93864: PUSH
93865: LD_INT 1
93867: NEG
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: PUSH
93873: LD_INT 1
93875: PUSH
93876: LD_INT 0
93878: PUSH
93879: EMPTY
93880: LIST
93881: LIST
93882: PUSH
93883: LD_INT 1
93885: PUSH
93886: LD_INT 1
93888: PUSH
93889: EMPTY
93890: LIST
93891: LIST
93892: PUSH
93893: LD_INT 0
93895: PUSH
93896: LD_INT 1
93898: PUSH
93899: EMPTY
93900: LIST
93901: LIST
93902: PUSH
93903: LD_INT 1
93905: NEG
93906: PUSH
93907: LD_INT 0
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: PUSH
93914: LD_INT 1
93916: NEG
93917: PUSH
93918: LD_INT 1
93920: NEG
93921: PUSH
93922: EMPTY
93923: LIST
93924: LIST
93925: PUSH
93926: LD_INT 1
93928: NEG
93929: PUSH
93930: LD_INT 2
93932: NEG
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 0
93940: PUSH
93941: LD_INT 2
93943: NEG
93944: PUSH
93945: EMPTY
93946: LIST
93947: LIST
93948: PUSH
93949: LD_INT 1
93951: PUSH
93952: LD_INT 1
93954: NEG
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: PUSH
93960: LD_INT 2
93962: PUSH
93963: LD_INT 1
93965: PUSH
93966: EMPTY
93967: LIST
93968: LIST
93969: PUSH
93970: LD_INT 2
93972: PUSH
93973: LD_INT 2
93975: PUSH
93976: EMPTY
93977: LIST
93978: LIST
93979: PUSH
93980: LD_INT 1
93982: PUSH
93983: LD_INT 2
93985: PUSH
93986: EMPTY
93987: LIST
93988: LIST
93989: PUSH
93990: LD_INT 0
93992: PUSH
93993: LD_INT 2
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: PUSH
94000: LD_INT 1
94002: NEG
94003: PUSH
94004: LD_INT 1
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: PUSH
94011: LD_INT 2
94013: NEG
94014: PUSH
94015: LD_INT 1
94017: NEG
94018: PUSH
94019: EMPTY
94020: LIST
94021: LIST
94022: PUSH
94023: LD_INT 2
94025: NEG
94026: PUSH
94027: LD_INT 2
94029: NEG
94030: PUSH
94031: EMPTY
94032: LIST
94033: LIST
94034: PUSH
94035: LD_INT 2
94037: NEG
94038: PUSH
94039: LD_INT 3
94041: NEG
94042: PUSH
94043: EMPTY
94044: LIST
94045: LIST
94046: PUSH
94047: LD_INT 1
94049: NEG
94050: PUSH
94051: LD_INT 3
94053: NEG
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 0
94061: PUSH
94062: LD_INT 3
94064: NEG
94065: PUSH
94066: EMPTY
94067: LIST
94068: LIST
94069: PUSH
94070: LD_INT 1
94072: PUSH
94073: LD_INT 2
94075: NEG
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: PUSH
94081: LD_INT 3
94083: PUSH
94084: LD_INT 2
94086: PUSH
94087: EMPTY
94088: LIST
94089: LIST
94090: PUSH
94091: LD_INT 3
94093: PUSH
94094: LD_INT 3
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: PUSH
94101: LD_INT 2
94103: PUSH
94104: LD_INT 3
94106: PUSH
94107: EMPTY
94108: LIST
94109: LIST
94110: PUSH
94111: LD_INT 1
94113: PUSH
94114: LD_INT 3
94116: PUSH
94117: EMPTY
94118: LIST
94119: LIST
94120: PUSH
94121: LD_INT 0
94123: PUSH
94124: LD_INT 3
94126: PUSH
94127: EMPTY
94128: LIST
94129: LIST
94130: PUSH
94131: LD_INT 1
94133: NEG
94134: PUSH
94135: LD_INT 2
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: PUSH
94142: LD_INT 3
94144: NEG
94145: PUSH
94146: LD_INT 2
94148: NEG
94149: PUSH
94150: EMPTY
94151: LIST
94152: LIST
94153: PUSH
94154: LD_INT 3
94156: NEG
94157: PUSH
94158: LD_INT 3
94160: NEG
94161: PUSH
94162: EMPTY
94163: LIST
94164: LIST
94165: PUSH
94166: EMPTY
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: LIST
94177: LIST
94178: LIST
94179: LIST
94180: LIST
94181: LIST
94182: LIST
94183: LIST
94184: LIST
94185: LIST
94186: LIST
94187: LIST
94188: LIST
94189: LIST
94190: LIST
94191: LIST
94192: LIST
94193: LIST
94194: LIST
94195: LIST
94196: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94197: LD_ADDR_VAR 0 46
94201: PUSH
94202: LD_INT 0
94204: PUSH
94205: LD_INT 0
94207: PUSH
94208: EMPTY
94209: LIST
94210: LIST
94211: PUSH
94212: LD_INT 0
94214: PUSH
94215: LD_INT 1
94217: NEG
94218: PUSH
94219: EMPTY
94220: LIST
94221: LIST
94222: PUSH
94223: LD_INT 1
94225: PUSH
94226: LD_INT 0
94228: PUSH
94229: EMPTY
94230: LIST
94231: LIST
94232: PUSH
94233: LD_INT 1
94235: PUSH
94236: LD_INT 1
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 0
94245: PUSH
94246: LD_INT 1
94248: PUSH
94249: EMPTY
94250: LIST
94251: LIST
94252: PUSH
94253: LD_INT 1
94255: NEG
94256: PUSH
94257: LD_INT 0
94259: PUSH
94260: EMPTY
94261: LIST
94262: LIST
94263: PUSH
94264: LD_INT 1
94266: NEG
94267: PUSH
94268: LD_INT 1
94270: NEG
94271: PUSH
94272: EMPTY
94273: LIST
94274: LIST
94275: PUSH
94276: LD_INT 1
94278: NEG
94279: PUSH
94280: LD_INT 2
94282: NEG
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: PUSH
94288: LD_INT 0
94290: PUSH
94291: LD_INT 2
94293: NEG
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PUSH
94299: LD_INT 1
94301: PUSH
94302: LD_INT 1
94304: NEG
94305: PUSH
94306: EMPTY
94307: LIST
94308: LIST
94309: PUSH
94310: LD_INT 2
94312: PUSH
94313: LD_INT 0
94315: PUSH
94316: EMPTY
94317: LIST
94318: LIST
94319: PUSH
94320: LD_INT 2
94322: PUSH
94323: LD_INT 1
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 1
94332: PUSH
94333: LD_INT 2
94335: PUSH
94336: EMPTY
94337: LIST
94338: LIST
94339: PUSH
94340: LD_INT 0
94342: PUSH
94343: LD_INT 2
94345: PUSH
94346: EMPTY
94347: LIST
94348: LIST
94349: PUSH
94350: LD_INT 1
94352: NEG
94353: PUSH
94354: LD_INT 1
94356: PUSH
94357: EMPTY
94358: LIST
94359: LIST
94360: PUSH
94361: LD_INT 2
94363: NEG
94364: PUSH
94365: LD_INT 0
94367: PUSH
94368: EMPTY
94369: LIST
94370: LIST
94371: PUSH
94372: LD_INT 2
94374: NEG
94375: PUSH
94376: LD_INT 1
94378: NEG
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: LD_INT 1
94386: NEG
94387: PUSH
94388: LD_INT 3
94390: NEG
94391: PUSH
94392: EMPTY
94393: LIST
94394: LIST
94395: PUSH
94396: LD_INT 0
94398: PUSH
94399: LD_INT 3
94401: NEG
94402: PUSH
94403: EMPTY
94404: LIST
94405: LIST
94406: PUSH
94407: LD_INT 1
94409: PUSH
94410: LD_INT 2
94412: NEG
94413: PUSH
94414: EMPTY
94415: LIST
94416: LIST
94417: PUSH
94418: LD_INT 2
94420: PUSH
94421: LD_INT 1
94423: NEG
94424: PUSH
94425: EMPTY
94426: LIST
94427: LIST
94428: PUSH
94429: LD_INT 3
94431: PUSH
94432: LD_INT 0
94434: PUSH
94435: EMPTY
94436: LIST
94437: LIST
94438: PUSH
94439: LD_INT 3
94441: PUSH
94442: LD_INT 1
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PUSH
94449: LD_INT 1
94451: PUSH
94452: LD_INT 3
94454: PUSH
94455: EMPTY
94456: LIST
94457: LIST
94458: PUSH
94459: LD_INT 0
94461: PUSH
94462: LD_INT 3
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PUSH
94469: LD_INT 1
94471: NEG
94472: PUSH
94473: LD_INT 2
94475: PUSH
94476: EMPTY
94477: LIST
94478: LIST
94479: PUSH
94480: LD_INT 2
94482: NEG
94483: PUSH
94484: LD_INT 1
94486: PUSH
94487: EMPTY
94488: LIST
94489: LIST
94490: PUSH
94491: LD_INT 3
94493: NEG
94494: PUSH
94495: LD_INT 0
94497: PUSH
94498: EMPTY
94499: LIST
94500: LIST
94501: PUSH
94502: LD_INT 3
94504: NEG
94505: PUSH
94506: LD_INT 1
94508: NEG
94509: PUSH
94510: EMPTY
94511: LIST
94512: LIST
94513: PUSH
94514: EMPTY
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94545: LD_ADDR_VAR 0 47
94549: PUSH
94550: LD_INT 0
94552: PUSH
94553: LD_INT 0
94555: PUSH
94556: EMPTY
94557: LIST
94558: LIST
94559: PUSH
94560: LD_INT 0
94562: PUSH
94563: LD_INT 1
94565: NEG
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 1
94573: PUSH
94574: LD_INT 0
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: PUSH
94581: LD_INT 1
94583: PUSH
94584: LD_INT 1
94586: PUSH
94587: EMPTY
94588: LIST
94589: LIST
94590: PUSH
94591: LD_INT 0
94593: PUSH
94594: LD_INT 1
94596: PUSH
94597: EMPTY
94598: LIST
94599: LIST
94600: PUSH
94601: LD_INT 1
94603: NEG
94604: PUSH
94605: LD_INT 0
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 1
94614: NEG
94615: PUSH
94616: LD_INT 1
94618: NEG
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PUSH
94624: LD_INT 1
94626: NEG
94627: PUSH
94628: LD_INT 2
94630: NEG
94631: PUSH
94632: EMPTY
94633: LIST
94634: LIST
94635: PUSH
94636: LD_INT 0
94638: PUSH
94639: LD_INT 2
94641: NEG
94642: PUSH
94643: EMPTY
94644: LIST
94645: LIST
94646: PUSH
94647: LD_INT 1
94649: PUSH
94650: LD_INT 1
94652: NEG
94653: PUSH
94654: EMPTY
94655: LIST
94656: LIST
94657: PUSH
94658: LD_INT 2
94660: NEG
94661: PUSH
94662: LD_INT 1
94664: NEG
94665: PUSH
94666: EMPTY
94667: LIST
94668: LIST
94669: PUSH
94670: LD_INT 2
94672: NEG
94673: PUSH
94674: LD_INT 2
94676: NEG
94677: PUSH
94678: EMPTY
94679: LIST
94680: LIST
94681: PUSH
94682: EMPTY
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: LIST
94693: LIST
94694: LIST
94695: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94696: LD_ADDR_VAR 0 48
94700: PUSH
94701: LD_INT 0
94703: PUSH
94704: LD_INT 0
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 0
94713: PUSH
94714: LD_INT 1
94716: NEG
94717: PUSH
94718: EMPTY
94719: LIST
94720: LIST
94721: PUSH
94722: LD_INT 1
94724: PUSH
94725: LD_INT 0
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: PUSH
94732: LD_INT 1
94734: PUSH
94735: LD_INT 1
94737: PUSH
94738: EMPTY
94739: LIST
94740: LIST
94741: PUSH
94742: LD_INT 0
94744: PUSH
94745: LD_INT 1
94747: PUSH
94748: EMPTY
94749: LIST
94750: LIST
94751: PUSH
94752: LD_INT 1
94754: NEG
94755: PUSH
94756: LD_INT 0
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 1
94765: NEG
94766: PUSH
94767: LD_INT 1
94769: NEG
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: PUSH
94775: LD_INT 1
94777: NEG
94778: PUSH
94779: LD_INT 2
94781: NEG
94782: PUSH
94783: EMPTY
94784: LIST
94785: LIST
94786: PUSH
94787: LD_INT 0
94789: PUSH
94790: LD_INT 2
94792: NEG
94793: PUSH
94794: EMPTY
94795: LIST
94796: LIST
94797: PUSH
94798: LD_INT 1
94800: PUSH
94801: LD_INT 1
94803: NEG
94804: PUSH
94805: EMPTY
94806: LIST
94807: LIST
94808: PUSH
94809: LD_INT 2
94811: PUSH
94812: LD_INT 0
94814: PUSH
94815: EMPTY
94816: LIST
94817: LIST
94818: PUSH
94819: LD_INT 2
94821: PUSH
94822: LD_INT 1
94824: PUSH
94825: EMPTY
94826: LIST
94827: LIST
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94843: LD_ADDR_VAR 0 49
94847: PUSH
94848: LD_INT 0
94850: PUSH
94851: LD_INT 0
94853: PUSH
94854: EMPTY
94855: LIST
94856: LIST
94857: PUSH
94858: LD_INT 0
94860: PUSH
94861: LD_INT 1
94863: NEG
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: PUSH
94869: LD_INT 1
94871: PUSH
94872: LD_INT 0
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: PUSH
94879: LD_INT 1
94881: PUSH
94882: LD_INT 1
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 0
94891: PUSH
94892: LD_INT 1
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 1
94901: NEG
94902: PUSH
94903: LD_INT 0
94905: PUSH
94906: EMPTY
94907: LIST
94908: LIST
94909: PUSH
94910: LD_INT 1
94912: NEG
94913: PUSH
94914: LD_INT 1
94916: NEG
94917: PUSH
94918: EMPTY
94919: LIST
94920: LIST
94921: PUSH
94922: LD_INT 1
94924: PUSH
94925: LD_INT 1
94927: NEG
94928: PUSH
94929: EMPTY
94930: LIST
94931: LIST
94932: PUSH
94933: LD_INT 2
94935: PUSH
94936: LD_INT 0
94938: PUSH
94939: EMPTY
94940: LIST
94941: LIST
94942: PUSH
94943: LD_INT 2
94945: PUSH
94946: LD_INT 1
94948: PUSH
94949: EMPTY
94950: LIST
94951: LIST
94952: PUSH
94953: LD_INT 2
94955: PUSH
94956: LD_INT 2
94958: PUSH
94959: EMPTY
94960: LIST
94961: LIST
94962: PUSH
94963: LD_INT 1
94965: PUSH
94966: LD_INT 2
94968: PUSH
94969: EMPTY
94970: LIST
94971: LIST
94972: PUSH
94973: EMPTY
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94987: LD_ADDR_VAR 0 50
94991: PUSH
94992: LD_INT 0
94994: PUSH
94995: LD_INT 0
94997: PUSH
94998: EMPTY
94999: LIST
95000: LIST
95001: PUSH
95002: LD_INT 0
95004: PUSH
95005: LD_INT 1
95007: NEG
95008: PUSH
95009: EMPTY
95010: LIST
95011: LIST
95012: PUSH
95013: LD_INT 1
95015: PUSH
95016: LD_INT 0
95018: PUSH
95019: EMPTY
95020: LIST
95021: LIST
95022: PUSH
95023: LD_INT 1
95025: PUSH
95026: LD_INT 1
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: PUSH
95033: LD_INT 0
95035: PUSH
95036: LD_INT 1
95038: PUSH
95039: EMPTY
95040: LIST
95041: LIST
95042: PUSH
95043: LD_INT 1
95045: NEG
95046: PUSH
95047: LD_INT 0
95049: PUSH
95050: EMPTY
95051: LIST
95052: LIST
95053: PUSH
95054: LD_INT 1
95056: NEG
95057: PUSH
95058: LD_INT 1
95060: NEG
95061: PUSH
95062: EMPTY
95063: LIST
95064: LIST
95065: PUSH
95066: LD_INT 2
95068: PUSH
95069: LD_INT 1
95071: PUSH
95072: EMPTY
95073: LIST
95074: LIST
95075: PUSH
95076: LD_INT 2
95078: PUSH
95079: LD_INT 2
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: PUSH
95086: LD_INT 1
95088: PUSH
95089: LD_INT 2
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: PUSH
95096: LD_INT 0
95098: PUSH
95099: LD_INT 2
95101: PUSH
95102: EMPTY
95103: LIST
95104: LIST
95105: PUSH
95106: LD_INT 1
95108: NEG
95109: PUSH
95110: LD_INT 1
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: PUSH
95117: EMPTY
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: LIST
95130: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
95131: LD_ADDR_VAR 0 51
95135: PUSH
95136: LD_INT 0
95138: PUSH
95139: LD_INT 0
95141: PUSH
95142: EMPTY
95143: LIST
95144: LIST
95145: PUSH
95146: LD_INT 0
95148: PUSH
95149: LD_INT 1
95151: NEG
95152: PUSH
95153: EMPTY
95154: LIST
95155: LIST
95156: PUSH
95157: LD_INT 1
95159: PUSH
95160: LD_INT 0
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: PUSH
95167: LD_INT 1
95169: PUSH
95170: LD_INT 1
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: PUSH
95177: LD_INT 0
95179: PUSH
95180: LD_INT 1
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: LD_INT 1
95189: NEG
95190: PUSH
95191: LD_INT 0
95193: PUSH
95194: EMPTY
95195: LIST
95196: LIST
95197: PUSH
95198: LD_INT 1
95200: NEG
95201: PUSH
95202: LD_INT 1
95204: NEG
95205: PUSH
95206: EMPTY
95207: LIST
95208: LIST
95209: PUSH
95210: LD_INT 1
95212: PUSH
95213: LD_INT 2
95215: PUSH
95216: EMPTY
95217: LIST
95218: LIST
95219: PUSH
95220: LD_INT 0
95222: PUSH
95223: LD_INT 2
95225: PUSH
95226: EMPTY
95227: LIST
95228: LIST
95229: PUSH
95230: LD_INT 1
95232: NEG
95233: PUSH
95234: LD_INT 1
95236: PUSH
95237: EMPTY
95238: LIST
95239: LIST
95240: PUSH
95241: LD_INT 2
95243: NEG
95244: PUSH
95245: LD_INT 0
95247: PUSH
95248: EMPTY
95249: LIST
95250: LIST
95251: PUSH
95252: LD_INT 2
95254: NEG
95255: PUSH
95256: LD_INT 1
95258: NEG
95259: PUSH
95260: EMPTY
95261: LIST
95262: LIST
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: LIST
95277: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95278: LD_ADDR_VAR 0 52
95282: PUSH
95283: LD_INT 0
95285: PUSH
95286: LD_INT 0
95288: PUSH
95289: EMPTY
95290: LIST
95291: LIST
95292: PUSH
95293: LD_INT 0
95295: PUSH
95296: LD_INT 1
95298: NEG
95299: PUSH
95300: EMPTY
95301: LIST
95302: LIST
95303: PUSH
95304: LD_INT 1
95306: PUSH
95307: LD_INT 0
95309: PUSH
95310: EMPTY
95311: LIST
95312: LIST
95313: PUSH
95314: LD_INT 1
95316: PUSH
95317: LD_INT 1
95319: PUSH
95320: EMPTY
95321: LIST
95322: LIST
95323: PUSH
95324: LD_INT 0
95326: PUSH
95327: LD_INT 1
95329: PUSH
95330: EMPTY
95331: LIST
95332: LIST
95333: PUSH
95334: LD_INT 1
95336: NEG
95337: PUSH
95338: LD_INT 0
95340: PUSH
95341: EMPTY
95342: LIST
95343: LIST
95344: PUSH
95345: LD_INT 1
95347: NEG
95348: PUSH
95349: LD_INT 1
95351: NEG
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: PUSH
95357: LD_INT 1
95359: NEG
95360: PUSH
95361: LD_INT 2
95363: NEG
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: PUSH
95369: LD_INT 1
95371: NEG
95372: PUSH
95373: LD_INT 1
95375: PUSH
95376: EMPTY
95377: LIST
95378: LIST
95379: PUSH
95380: LD_INT 2
95382: NEG
95383: PUSH
95384: LD_INT 0
95386: PUSH
95387: EMPTY
95388: LIST
95389: LIST
95390: PUSH
95391: LD_INT 2
95393: NEG
95394: PUSH
95395: LD_INT 1
95397: NEG
95398: PUSH
95399: EMPTY
95400: LIST
95401: LIST
95402: PUSH
95403: LD_INT 2
95405: NEG
95406: PUSH
95407: LD_INT 2
95409: NEG
95410: PUSH
95411: EMPTY
95412: LIST
95413: LIST
95414: PUSH
95415: EMPTY
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95429: LD_ADDR_VAR 0 53
95433: PUSH
95434: LD_INT 0
95436: PUSH
95437: LD_INT 0
95439: PUSH
95440: EMPTY
95441: LIST
95442: LIST
95443: PUSH
95444: LD_INT 0
95446: PUSH
95447: LD_INT 1
95449: NEG
95450: PUSH
95451: EMPTY
95452: LIST
95453: LIST
95454: PUSH
95455: LD_INT 1
95457: PUSH
95458: LD_INT 0
95460: PUSH
95461: EMPTY
95462: LIST
95463: LIST
95464: PUSH
95465: LD_INT 1
95467: PUSH
95468: LD_INT 1
95470: PUSH
95471: EMPTY
95472: LIST
95473: LIST
95474: PUSH
95475: LD_INT 0
95477: PUSH
95478: LD_INT 1
95480: PUSH
95481: EMPTY
95482: LIST
95483: LIST
95484: PUSH
95485: LD_INT 1
95487: NEG
95488: PUSH
95489: LD_INT 0
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 1
95498: NEG
95499: PUSH
95500: LD_INT 1
95502: NEG
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PUSH
95508: LD_INT 1
95510: NEG
95511: PUSH
95512: LD_INT 2
95514: NEG
95515: PUSH
95516: EMPTY
95517: LIST
95518: LIST
95519: PUSH
95520: LD_INT 0
95522: PUSH
95523: LD_INT 2
95525: NEG
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PUSH
95531: LD_INT 1
95533: PUSH
95534: LD_INT 1
95536: NEG
95537: PUSH
95538: EMPTY
95539: LIST
95540: LIST
95541: PUSH
95542: LD_INT 2
95544: PUSH
95545: LD_INT 0
95547: PUSH
95548: EMPTY
95549: LIST
95550: LIST
95551: PUSH
95552: LD_INT 2
95554: PUSH
95555: LD_INT 1
95557: PUSH
95558: EMPTY
95559: LIST
95560: LIST
95561: PUSH
95562: LD_INT 2
95564: PUSH
95565: LD_INT 2
95567: PUSH
95568: EMPTY
95569: LIST
95570: LIST
95571: PUSH
95572: LD_INT 1
95574: PUSH
95575: LD_INT 2
95577: PUSH
95578: EMPTY
95579: LIST
95580: LIST
95581: PUSH
95582: LD_INT 0
95584: PUSH
95585: LD_INT 2
95587: PUSH
95588: EMPTY
95589: LIST
95590: LIST
95591: PUSH
95592: LD_INT 1
95594: NEG
95595: PUSH
95596: LD_INT 1
95598: PUSH
95599: EMPTY
95600: LIST
95601: LIST
95602: PUSH
95603: LD_INT 2
95605: NEG
95606: PUSH
95607: LD_INT 0
95609: PUSH
95610: EMPTY
95611: LIST
95612: LIST
95613: PUSH
95614: LD_INT 2
95616: NEG
95617: PUSH
95618: LD_INT 1
95620: NEG
95621: PUSH
95622: EMPTY
95623: LIST
95624: LIST
95625: PUSH
95626: LD_INT 2
95628: NEG
95629: PUSH
95630: LD_INT 2
95632: NEG
95633: PUSH
95634: EMPTY
95635: LIST
95636: LIST
95637: PUSH
95638: EMPTY
95639: LIST
95640: LIST
95641: LIST
95642: LIST
95643: LIST
95644: LIST
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95659: LD_ADDR_VAR 0 54
95663: PUSH
95664: LD_INT 0
95666: PUSH
95667: LD_INT 0
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: PUSH
95674: LD_INT 0
95676: PUSH
95677: LD_INT 1
95679: NEG
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 1
95687: PUSH
95688: LD_INT 0
95690: PUSH
95691: EMPTY
95692: LIST
95693: LIST
95694: PUSH
95695: LD_INT 1
95697: PUSH
95698: LD_INT 1
95700: PUSH
95701: EMPTY
95702: LIST
95703: LIST
95704: PUSH
95705: LD_INT 0
95707: PUSH
95708: LD_INT 1
95710: PUSH
95711: EMPTY
95712: LIST
95713: LIST
95714: PUSH
95715: LD_INT 1
95717: NEG
95718: PUSH
95719: LD_INT 0
95721: PUSH
95722: EMPTY
95723: LIST
95724: LIST
95725: PUSH
95726: LD_INT 1
95728: NEG
95729: PUSH
95730: LD_INT 1
95732: NEG
95733: PUSH
95734: EMPTY
95735: LIST
95736: LIST
95737: PUSH
95738: LD_INT 1
95740: NEG
95741: PUSH
95742: LD_INT 2
95744: NEG
95745: PUSH
95746: EMPTY
95747: LIST
95748: LIST
95749: PUSH
95750: LD_INT 0
95752: PUSH
95753: LD_INT 2
95755: NEG
95756: PUSH
95757: EMPTY
95758: LIST
95759: LIST
95760: PUSH
95761: LD_INT 1
95763: PUSH
95764: LD_INT 1
95766: NEG
95767: PUSH
95768: EMPTY
95769: LIST
95770: LIST
95771: PUSH
95772: LD_INT 2
95774: PUSH
95775: LD_INT 0
95777: PUSH
95778: EMPTY
95779: LIST
95780: LIST
95781: PUSH
95782: LD_INT 2
95784: PUSH
95785: LD_INT 1
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PUSH
95792: LD_INT 2
95794: PUSH
95795: LD_INT 2
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 1
95804: PUSH
95805: LD_INT 2
95807: PUSH
95808: EMPTY
95809: LIST
95810: LIST
95811: PUSH
95812: LD_INT 0
95814: PUSH
95815: LD_INT 2
95817: PUSH
95818: EMPTY
95819: LIST
95820: LIST
95821: PUSH
95822: LD_INT 1
95824: NEG
95825: PUSH
95826: LD_INT 1
95828: PUSH
95829: EMPTY
95830: LIST
95831: LIST
95832: PUSH
95833: LD_INT 2
95835: NEG
95836: PUSH
95837: LD_INT 0
95839: PUSH
95840: EMPTY
95841: LIST
95842: LIST
95843: PUSH
95844: LD_INT 2
95846: NEG
95847: PUSH
95848: LD_INT 1
95850: NEG
95851: PUSH
95852: EMPTY
95853: LIST
95854: LIST
95855: PUSH
95856: LD_INT 2
95858: NEG
95859: PUSH
95860: LD_INT 2
95862: NEG
95863: PUSH
95864: EMPTY
95865: LIST
95866: LIST
95867: PUSH
95868: EMPTY
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
95889: LD_ADDR_VAR 0 55
95893: PUSH
95894: LD_INT 0
95896: PUSH
95897: LD_INT 0
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: PUSH
95904: LD_INT 0
95906: PUSH
95907: LD_INT 1
95909: NEG
95910: PUSH
95911: EMPTY
95912: LIST
95913: LIST
95914: PUSH
95915: LD_INT 1
95917: PUSH
95918: LD_INT 0
95920: PUSH
95921: EMPTY
95922: LIST
95923: LIST
95924: PUSH
95925: LD_INT 1
95927: PUSH
95928: LD_INT 1
95930: PUSH
95931: EMPTY
95932: LIST
95933: LIST
95934: PUSH
95935: LD_INT 0
95937: PUSH
95938: LD_INT 1
95940: PUSH
95941: EMPTY
95942: LIST
95943: LIST
95944: PUSH
95945: LD_INT 1
95947: NEG
95948: PUSH
95949: LD_INT 0
95951: PUSH
95952: EMPTY
95953: LIST
95954: LIST
95955: PUSH
95956: LD_INT 1
95958: NEG
95959: PUSH
95960: LD_INT 1
95962: NEG
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: PUSH
95968: LD_INT 1
95970: NEG
95971: PUSH
95972: LD_INT 2
95974: NEG
95975: PUSH
95976: EMPTY
95977: LIST
95978: LIST
95979: PUSH
95980: LD_INT 0
95982: PUSH
95983: LD_INT 2
95985: NEG
95986: PUSH
95987: EMPTY
95988: LIST
95989: LIST
95990: PUSH
95991: LD_INT 1
95993: PUSH
95994: LD_INT 1
95996: NEG
95997: PUSH
95998: EMPTY
95999: LIST
96000: LIST
96001: PUSH
96002: LD_INT 2
96004: PUSH
96005: LD_INT 0
96007: PUSH
96008: EMPTY
96009: LIST
96010: LIST
96011: PUSH
96012: LD_INT 2
96014: PUSH
96015: LD_INT 1
96017: PUSH
96018: EMPTY
96019: LIST
96020: LIST
96021: PUSH
96022: LD_INT 2
96024: PUSH
96025: LD_INT 2
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: PUSH
96032: LD_INT 1
96034: PUSH
96035: LD_INT 2
96037: PUSH
96038: EMPTY
96039: LIST
96040: LIST
96041: PUSH
96042: LD_INT 0
96044: PUSH
96045: LD_INT 2
96047: PUSH
96048: EMPTY
96049: LIST
96050: LIST
96051: PUSH
96052: LD_INT 1
96054: NEG
96055: PUSH
96056: LD_INT 1
96058: PUSH
96059: EMPTY
96060: LIST
96061: LIST
96062: PUSH
96063: LD_INT 2
96065: NEG
96066: PUSH
96067: LD_INT 0
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: PUSH
96074: LD_INT 2
96076: NEG
96077: PUSH
96078: LD_INT 1
96080: NEG
96081: PUSH
96082: EMPTY
96083: LIST
96084: LIST
96085: PUSH
96086: LD_INT 2
96088: NEG
96089: PUSH
96090: LD_INT 2
96092: NEG
96093: PUSH
96094: EMPTY
96095: LIST
96096: LIST
96097: PUSH
96098: EMPTY
96099: LIST
96100: LIST
96101: LIST
96102: LIST
96103: LIST
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: LIST
96111: LIST
96112: LIST
96113: LIST
96114: LIST
96115: LIST
96116: LIST
96117: LIST
96118: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96119: LD_ADDR_VAR 0 56
96123: PUSH
96124: LD_INT 0
96126: PUSH
96127: LD_INT 0
96129: PUSH
96130: EMPTY
96131: LIST
96132: LIST
96133: PUSH
96134: LD_INT 0
96136: PUSH
96137: LD_INT 1
96139: NEG
96140: PUSH
96141: EMPTY
96142: LIST
96143: LIST
96144: PUSH
96145: LD_INT 1
96147: PUSH
96148: LD_INT 0
96150: PUSH
96151: EMPTY
96152: LIST
96153: LIST
96154: PUSH
96155: LD_INT 1
96157: PUSH
96158: LD_INT 1
96160: PUSH
96161: EMPTY
96162: LIST
96163: LIST
96164: PUSH
96165: LD_INT 0
96167: PUSH
96168: LD_INT 1
96170: PUSH
96171: EMPTY
96172: LIST
96173: LIST
96174: PUSH
96175: LD_INT 1
96177: NEG
96178: PUSH
96179: LD_INT 0
96181: PUSH
96182: EMPTY
96183: LIST
96184: LIST
96185: PUSH
96186: LD_INT 1
96188: NEG
96189: PUSH
96190: LD_INT 1
96192: NEG
96193: PUSH
96194: EMPTY
96195: LIST
96196: LIST
96197: PUSH
96198: LD_INT 1
96200: NEG
96201: PUSH
96202: LD_INT 2
96204: NEG
96205: PUSH
96206: EMPTY
96207: LIST
96208: LIST
96209: PUSH
96210: LD_INT 0
96212: PUSH
96213: LD_INT 2
96215: NEG
96216: PUSH
96217: EMPTY
96218: LIST
96219: LIST
96220: PUSH
96221: LD_INT 1
96223: PUSH
96224: LD_INT 1
96226: NEG
96227: PUSH
96228: EMPTY
96229: LIST
96230: LIST
96231: PUSH
96232: LD_INT 2
96234: PUSH
96235: LD_INT 0
96237: PUSH
96238: EMPTY
96239: LIST
96240: LIST
96241: PUSH
96242: LD_INT 2
96244: PUSH
96245: LD_INT 1
96247: PUSH
96248: EMPTY
96249: LIST
96250: LIST
96251: PUSH
96252: LD_INT 2
96254: PUSH
96255: LD_INT 2
96257: PUSH
96258: EMPTY
96259: LIST
96260: LIST
96261: PUSH
96262: LD_INT 1
96264: PUSH
96265: LD_INT 2
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 0
96274: PUSH
96275: LD_INT 2
96277: PUSH
96278: EMPTY
96279: LIST
96280: LIST
96281: PUSH
96282: LD_INT 1
96284: NEG
96285: PUSH
96286: LD_INT 1
96288: PUSH
96289: EMPTY
96290: LIST
96291: LIST
96292: PUSH
96293: LD_INT 2
96295: NEG
96296: PUSH
96297: LD_INT 0
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: PUSH
96304: LD_INT 2
96306: NEG
96307: PUSH
96308: LD_INT 1
96310: NEG
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: LD_INT 2
96318: NEG
96319: PUSH
96320: LD_INT 2
96322: NEG
96323: PUSH
96324: EMPTY
96325: LIST
96326: LIST
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: LIST
96332: LIST
96333: LIST
96334: LIST
96335: LIST
96336: LIST
96337: LIST
96338: LIST
96339: LIST
96340: LIST
96341: LIST
96342: LIST
96343: LIST
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96349: LD_ADDR_VAR 0 57
96353: PUSH
96354: LD_INT 0
96356: PUSH
96357: LD_INT 0
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PUSH
96364: LD_INT 0
96366: PUSH
96367: LD_INT 1
96369: NEG
96370: PUSH
96371: EMPTY
96372: LIST
96373: LIST
96374: PUSH
96375: LD_INT 1
96377: PUSH
96378: LD_INT 0
96380: PUSH
96381: EMPTY
96382: LIST
96383: LIST
96384: PUSH
96385: LD_INT 1
96387: PUSH
96388: LD_INT 1
96390: PUSH
96391: EMPTY
96392: LIST
96393: LIST
96394: PUSH
96395: LD_INT 0
96397: PUSH
96398: LD_INT 1
96400: PUSH
96401: EMPTY
96402: LIST
96403: LIST
96404: PUSH
96405: LD_INT 1
96407: NEG
96408: PUSH
96409: LD_INT 0
96411: PUSH
96412: EMPTY
96413: LIST
96414: LIST
96415: PUSH
96416: LD_INT 1
96418: NEG
96419: PUSH
96420: LD_INT 1
96422: NEG
96423: PUSH
96424: EMPTY
96425: LIST
96426: LIST
96427: PUSH
96428: LD_INT 1
96430: NEG
96431: PUSH
96432: LD_INT 2
96434: NEG
96435: PUSH
96436: EMPTY
96437: LIST
96438: LIST
96439: PUSH
96440: LD_INT 0
96442: PUSH
96443: LD_INT 2
96445: NEG
96446: PUSH
96447: EMPTY
96448: LIST
96449: LIST
96450: PUSH
96451: LD_INT 1
96453: PUSH
96454: LD_INT 1
96456: NEG
96457: PUSH
96458: EMPTY
96459: LIST
96460: LIST
96461: PUSH
96462: LD_INT 2
96464: PUSH
96465: LD_INT 0
96467: PUSH
96468: EMPTY
96469: LIST
96470: LIST
96471: PUSH
96472: LD_INT 2
96474: PUSH
96475: LD_INT 1
96477: PUSH
96478: EMPTY
96479: LIST
96480: LIST
96481: PUSH
96482: LD_INT 2
96484: PUSH
96485: LD_INT 2
96487: PUSH
96488: EMPTY
96489: LIST
96490: LIST
96491: PUSH
96492: LD_INT 1
96494: PUSH
96495: LD_INT 2
96497: PUSH
96498: EMPTY
96499: LIST
96500: LIST
96501: PUSH
96502: LD_INT 0
96504: PUSH
96505: LD_INT 2
96507: PUSH
96508: EMPTY
96509: LIST
96510: LIST
96511: PUSH
96512: LD_INT 1
96514: NEG
96515: PUSH
96516: LD_INT 1
96518: PUSH
96519: EMPTY
96520: LIST
96521: LIST
96522: PUSH
96523: LD_INT 2
96525: NEG
96526: PUSH
96527: LD_INT 0
96529: PUSH
96530: EMPTY
96531: LIST
96532: LIST
96533: PUSH
96534: LD_INT 2
96536: NEG
96537: PUSH
96538: LD_INT 1
96540: NEG
96541: PUSH
96542: EMPTY
96543: LIST
96544: LIST
96545: PUSH
96546: LD_INT 2
96548: NEG
96549: PUSH
96550: LD_INT 2
96552: NEG
96553: PUSH
96554: EMPTY
96555: LIST
96556: LIST
96557: PUSH
96558: EMPTY
96559: LIST
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
96579: LD_ADDR_VAR 0 58
96583: PUSH
96584: LD_INT 0
96586: PUSH
96587: LD_INT 0
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: PUSH
96594: LD_INT 0
96596: PUSH
96597: LD_INT 1
96599: NEG
96600: PUSH
96601: EMPTY
96602: LIST
96603: LIST
96604: PUSH
96605: LD_INT 1
96607: PUSH
96608: LD_INT 0
96610: PUSH
96611: EMPTY
96612: LIST
96613: LIST
96614: PUSH
96615: LD_INT 1
96617: PUSH
96618: LD_INT 1
96620: PUSH
96621: EMPTY
96622: LIST
96623: LIST
96624: PUSH
96625: LD_INT 0
96627: PUSH
96628: LD_INT 1
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: PUSH
96635: LD_INT 1
96637: NEG
96638: PUSH
96639: LD_INT 0
96641: PUSH
96642: EMPTY
96643: LIST
96644: LIST
96645: PUSH
96646: LD_INT 1
96648: NEG
96649: PUSH
96650: LD_INT 1
96652: NEG
96653: PUSH
96654: EMPTY
96655: LIST
96656: LIST
96657: PUSH
96658: LD_INT 1
96660: NEG
96661: PUSH
96662: LD_INT 2
96664: NEG
96665: PUSH
96666: EMPTY
96667: LIST
96668: LIST
96669: PUSH
96670: LD_INT 0
96672: PUSH
96673: LD_INT 2
96675: NEG
96676: PUSH
96677: EMPTY
96678: LIST
96679: LIST
96680: PUSH
96681: LD_INT 1
96683: PUSH
96684: LD_INT 1
96686: NEG
96687: PUSH
96688: EMPTY
96689: LIST
96690: LIST
96691: PUSH
96692: LD_INT 2
96694: PUSH
96695: LD_INT 0
96697: PUSH
96698: EMPTY
96699: LIST
96700: LIST
96701: PUSH
96702: LD_INT 2
96704: PUSH
96705: LD_INT 1
96707: PUSH
96708: EMPTY
96709: LIST
96710: LIST
96711: PUSH
96712: LD_INT 2
96714: PUSH
96715: LD_INT 2
96717: PUSH
96718: EMPTY
96719: LIST
96720: LIST
96721: PUSH
96722: LD_INT 1
96724: PUSH
96725: LD_INT 2
96727: PUSH
96728: EMPTY
96729: LIST
96730: LIST
96731: PUSH
96732: LD_INT 0
96734: PUSH
96735: LD_INT 2
96737: PUSH
96738: EMPTY
96739: LIST
96740: LIST
96741: PUSH
96742: LD_INT 1
96744: NEG
96745: PUSH
96746: LD_INT 1
96748: PUSH
96749: EMPTY
96750: LIST
96751: LIST
96752: PUSH
96753: LD_INT 2
96755: NEG
96756: PUSH
96757: LD_INT 0
96759: PUSH
96760: EMPTY
96761: LIST
96762: LIST
96763: PUSH
96764: LD_INT 2
96766: NEG
96767: PUSH
96768: LD_INT 1
96770: NEG
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: PUSH
96776: LD_INT 2
96778: NEG
96779: PUSH
96780: LD_INT 2
96782: NEG
96783: PUSH
96784: EMPTY
96785: LIST
96786: LIST
96787: PUSH
96788: EMPTY
96789: LIST
96790: LIST
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: LIST
96798: LIST
96799: LIST
96800: LIST
96801: LIST
96802: LIST
96803: LIST
96804: LIST
96805: LIST
96806: LIST
96807: LIST
96808: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96809: LD_ADDR_VAR 0 59
96813: PUSH
96814: LD_INT 0
96816: PUSH
96817: LD_INT 0
96819: PUSH
96820: EMPTY
96821: LIST
96822: LIST
96823: PUSH
96824: LD_INT 0
96826: PUSH
96827: LD_INT 1
96829: NEG
96830: PUSH
96831: EMPTY
96832: LIST
96833: LIST
96834: PUSH
96835: LD_INT 1
96837: PUSH
96838: LD_INT 0
96840: PUSH
96841: EMPTY
96842: LIST
96843: LIST
96844: PUSH
96845: LD_INT 1
96847: PUSH
96848: LD_INT 1
96850: PUSH
96851: EMPTY
96852: LIST
96853: LIST
96854: PUSH
96855: LD_INT 0
96857: PUSH
96858: LD_INT 1
96860: PUSH
96861: EMPTY
96862: LIST
96863: LIST
96864: PUSH
96865: LD_INT 1
96867: NEG
96868: PUSH
96869: LD_INT 0
96871: PUSH
96872: EMPTY
96873: LIST
96874: LIST
96875: PUSH
96876: LD_INT 1
96878: NEG
96879: PUSH
96880: LD_INT 1
96882: NEG
96883: PUSH
96884: EMPTY
96885: LIST
96886: LIST
96887: PUSH
96888: EMPTY
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96897: LD_ADDR_VAR 0 60
96901: PUSH
96902: LD_INT 0
96904: PUSH
96905: LD_INT 0
96907: PUSH
96908: EMPTY
96909: LIST
96910: LIST
96911: PUSH
96912: LD_INT 0
96914: PUSH
96915: LD_INT 1
96917: NEG
96918: PUSH
96919: EMPTY
96920: LIST
96921: LIST
96922: PUSH
96923: LD_INT 1
96925: PUSH
96926: LD_INT 0
96928: PUSH
96929: EMPTY
96930: LIST
96931: LIST
96932: PUSH
96933: LD_INT 1
96935: PUSH
96936: LD_INT 1
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: PUSH
96943: LD_INT 0
96945: PUSH
96946: LD_INT 1
96948: PUSH
96949: EMPTY
96950: LIST
96951: LIST
96952: PUSH
96953: LD_INT 1
96955: NEG
96956: PUSH
96957: LD_INT 0
96959: PUSH
96960: EMPTY
96961: LIST
96962: LIST
96963: PUSH
96964: LD_INT 1
96966: NEG
96967: PUSH
96968: LD_INT 1
96970: NEG
96971: PUSH
96972: EMPTY
96973: LIST
96974: LIST
96975: PUSH
96976: EMPTY
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
96985: LD_ADDR_VAR 0 61
96989: PUSH
96990: LD_INT 0
96992: PUSH
96993: LD_INT 0
96995: PUSH
96996: EMPTY
96997: LIST
96998: LIST
96999: PUSH
97000: LD_INT 0
97002: PUSH
97003: LD_INT 1
97005: NEG
97006: PUSH
97007: EMPTY
97008: LIST
97009: LIST
97010: PUSH
97011: LD_INT 1
97013: PUSH
97014: LD_INT 0
97016: PUSH
97017: EMPTY
97018: LIST
97019: LIST
97020: PUSH
97021: LD_INT 1
97023: PUSH
97024: LD_INT 1
97026: PUSH
97027: EMPTY
97028: LIST
97029: LIST
97030: PUSH
97031: LD_INT 0
97033: PUSH
97034: LD_INT 1
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PUSH
97041: LD_INT 1
97043: NEG
97044: PUSH
97045: LD_INT 0
97047: PUSH
97048: EMPTY
97049: LIST
97050: LIST
97051: PUSH
97052: LD_INT 1
97054: NEG
97055: PUSH
97056: LD_INT 1
97058: NEG
97059: PUSH
97060: EMPTY
97061: LIST
97062: LIST
97063: PUSH
97064: EMPTY
97065: LIST
97066: LIST
97067: LIST
97068: LIST
97069: LIST
97070: LIST
97071: LIST
97072: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
97073: LD_ADDR_VAR 0 62
97077: PUSH
97078: LD_INT 0
97080: PUSH
97081: LD_INT 0
97083: PUSH
97084: EMPTY
97085: LIST
97086: LIST
97087: PUSH
97088: LD_INT 0
97090: PUSH
97091: LD_INT 1
97093: NEG
97094: PUSH
97095: EMPTY
97096: LIST
97097: LIST
97098: PUSH
97099: LD_INT 1
97101: PUSH
97102: LD_INT 0
97104: PUSH
97105: EMPTY
97106: LIST
97107: LIST
97108: PUSH
97109: LD_INT 1
97111: PUSH
97112: LD_INT 1
97114: PUSH
97115: EMPTY
97116: LIST
97117: LIST
97118: PUSH
97119: LD_INT 0
97121: PUSH
97122: LD_INT 1
97124: PUSH
97125: EMPTY
97126: LIST
97127: LIST
97128: PUSH
97129: LD_INT 1
97131: NEG
97132: PUSH
97133: LD_INT 0
97135: PUSH
97136: EMPTY
97137: LIST
97138: LIST
97139: PUSH
97140: LD_INT 1
97142: NEG
97143: PUSH
97144: LD_INT 1
97146: NEG
97147: PUSH
97148: EMPTY
97149: LIST
97150: LIST
97151: PUSH
97152: EMPTY
97153: LIST
97154: LIST
97155: LIST
97156: LIST
97157: LIST
97158: LIST
97159: LIST
97160: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
97161: LD_ADDR_VAR 0 63
97165: PUSH
97166: LD_INT 0
97168: PUSH
97169: LD_INT 0
97171: PUSH
97172: EMPTY
97173: LIST
97174: LIST
97175: PUSH
97176: LD_INT 0
97178: PUSH
97179: LD_INT 1
97181: NEG
97182: PUSH
97183: EMPTY
97184: LIST
97185: LIST
97186: PUSH
97187: LD_INT 1
97189: PUSH
97190: LD_INT 0
97192: PUSH
97193: EMPTY
97194: LIST
97195: LIST
97196: PUSH
97197: LD_INT 1
97199: PUSH
97200: LD_INT 1
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: PUSH
97207: LD_INT 0
97209: PUSH
97210: LD_INT 1
97212: PUSH
97213: EMPTY
97214: LIST
97215: LIST
97216: PUSH
97217: LD_INT 1
97219: NEG
97220: PUSH
97221: LD_INT 0
97223: PUSH
97224: EMPTY
97225: LIST
97226: LIST
97227: PUSH
97228: LD_INT 1
97230: NEG
97231: PUSH
97232: LD_INT 1
97234: NEG
97235: PUSH
97236: EMPTY
97237: LIST
97238: LIST
97239: PUSH
97240: EMPTY
97241: LIST
97242: LIST
97243: LIST
97244: LIST
97245: LIST
97246: LIST
97247: LIST
97248: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
97249: LD_ADDR_VAR 0 64
97253: PUSH
97254: LD_INT 0
97256: PUSH
97257: LD_INT 0
97259: PUSH
97260: EMPTY
97261: LIST
97262: LIST
97263: PUSH
97264: LD_INT 0
97266: PUSH
97267: LD_INT 1
97269: NEG
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PUSH
97275: LD_INT 1
97277: PUSH
97278: LD_INT 0
97280: PUSH
97281: EMPTY
97282: LIST
97283: LIST
97284: PUSH
97285: LD_INT 1
97287: PUSH
97288: LD_INT 1
97290: PUSH
97291: EMPTY
97292: LIST
97293: LIST
97294: PUSH
97295: LD_INT 0
97297: PUSH
97298: LD_INT 1
97300: PUSH
97301: EMPTY
97302: LIST
97303: LIST
97304: PUSH
97305: LD_INT 1
97307: NEG
97308: PUSH
97309: LD_INT 0
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: PUSH
97316: LD_INT 1
97318: NEG
97319: PUSH
97320: LD_INT 1
97322: NEG
97323: PUSH
97324: EMPTY
97325: LIST
97326: LIST
97327: PUSH
97328: EMPTY
97329: LIST
97330: LIST
97331: LIST
97332: LIST
97333: LIST
97334: LIST
97335: LIST
97336: ST_TO_ADDR
// end ; 1 :
97337: GO 103234
97339: LD_INT 1
97341: DOUBLE
97342: EQUAL
97343: IFTRUE 97347
97345: GO 99970
97347: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97348: LD_ADDR_VAR 0 11
97352: PUSH
97353: LD_INT 1
97355: NEG
97356: PUSH
97357: LD_INT 3
97359: NEG
97360: PUSH
97361: EMPTY
97362: LIST
97363: LIST
97364: PUSH
97365: LD_INT 0
97367: PUSH
97368: LD_INT 3
97370: NEG
97371: PUSH
97372: EMPTY
97373: LIST
97374: LIST
97375: PUSH
97376: LD_INT 1
97378: PUSH
97379: LD_INT 2
97381: NEG
97382: PUSH
97383: EMPTY
97384: LIST
97385: LIST
97386: PUSH
97387: EMPTY
97388: LIST
97389: LIST
97390: LIST
97391: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97392: LD_ADDR_VAR 0 12
97396: PUSH
97397: LD_INT 2
97399: PUSH
97400: LD_INT 1
97402: NEG
97403: PUSH
97404: EMPTY
97405: LIST
97406: LIST
97407: PUSH
97408: LD_INT 3
97410: PUSH
97411: LD_INT 0
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: PUSH
97418: LD_INT 3
97420: PUSH
97421: LD_INT 1
97423: PUSH
97424: EMPTY
97425: LIST
97426: LIST
97427: PUSH
97428: EMPTY
97429: LIST
97430: LIST
97431: LIST
97432: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97433: LD_ADDR_VAR 0 13
97437: PUSH
97438: LD_INT 3
97440: PUSH
97441: LD_INT 2
97443: PUSH
97444: EMPTY
97445: LIST
97446: LIST
97447: PUSH
97448: LD_INT 3
97450: PUSH
97451: LD_INT 3
97453: PUSH
97454: EMPTY
97455: LIST
97456: LIST
97457: PUSH
97458: LD_INT 2
97460: PUSH
97461: LD_INT 3
97463: PUSH
97464: EMPTY
97465: LIST
97466: LIST
97467: PUSH
97468: EMPTY
97469: LIST
97470: LIST
97471: LIST
97472: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
97473: LD_ADDR_VAR 0 14
97477: PUSH
97478: LD_INT 1
97480: PUSH
97481: LD_INT 3
97483: PUSH
97484: EMPTY
97485: LIST
97486: LIST
97487: PUSH
97488: LD_INT 0
97490: PUSH
97491: LD_INT 3
97493: PUSH
97494: EMPTY
97495: LIST
97496: LIST
97497: PUSH
97498: LD_INT 1
97500: NEG
97501: PUSH
97502: LD_INT 2
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: PUSH
97509: EMPTY
97510: LIST
97511: LIST
97512: LIST
97513: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
97514: LD_ADDR_VAR 0 15
97518: PUSH
97519: LD_INT 2
97521: NEG
97522: PUSH
97523: LD_INT 1
97525: PUSH
97526: EMPTY
97527: LIST
97528: LIST
97529: PUSH
97530: LD_INT 3
97532: NEG
97533: PUSH
97534: LD_INT 0
97536: PUSH
97537: EMPTY
97538: LIST
97539: LIST
97540: PUSH
97541: LD_INT 3
97543: NEG
97544: PUSH
97545: LD_INT 1
97547: NEG
97548: PUSH
97549: EMPTY
97550: LIST
97551: LIST
97552: PUSH
97553: EMPTY
97554: LIST
97555: LIST
97556: LIST
97557: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
97558: LD_ADDR_VAR 0 16
97562: PUSH
97563: LD_INT 2
97565: NEG
97566: PUSH
97567: LD_INT 3
97569: NEG
97570: PUSH
97571: EMPTY
97572: LIST
97573: LIST
97574: PUSH
97575: LD_INT 3
97577: NEG
97578: PUSH
97579: LD_INT 2
97581: NEG
97582: PUSH
97583: EMPTY
97584: LIST
97585: LIST
97586: PUSH
97587: LD_INT 3
97589: NEG
97590: PUSH
97591: LD_INT 3
97593: NEG
97594: PUSH
97595: EMPTY
97596: LIST
97597: LIST
97598: PUSH
97599: EMPTY
97600: LIST
97601: LIST
97602: LIST
97603: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
97604: LD_ADDR_VAR 0 17
97608: PUSH
97609: LD_INT 1
97611: NEG
97612: PUSH
97613: LD_INT 3
97615: NEG
97616: PUSH
97617: EMPTY
97618: LIST
97619: LIST
97620: PUSH
97621: LD_INT 0
97623: PUSH
97624: LD_INT 3
97626: NEG
97627: PUSH
97628: EMPTY
97629: LIST
97630: LIST
97631: PUSH
97632: LD_INT 1
97634: PUSH
97635: LD_INT 2
97637: NEG
97638: PUSH
97639: EMPTY
97640: LIST
97641: LIST
97642: PUSH
97643: EMPTY
97644: LIST
97645: LIST
97646: LIST
97647: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
97648: LD_ADDR_VAR 0 18
97652: PUSH
97653: LD_INT 2
97655: PUSH
97656: LD_INT 1
97658: NEG
97659: PUSH
97660: EMPTY
97661: LIST
97662: LIST
97663: PUSH
97664: LD_INT 3
97666: PUSH
97667: LD_INT 0
97669: PUSH
97670: EMPTY
97671: LIST
97672: LIST
97673: PUSH
97674: LD_INT 3
97676: PUSH
97677: LD_INT 1
97679: PUSH
97680: EMPTY
97681: LIST
97682: LIST
97683: PUSH
97684: EMPTY
97685: LIST
97686: LIST
97687: LIST
97688: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
97689: LD_ADDR_VAR 0 19
97693: PUSH
97694: LD_INT 3
97696: PUSH
97697: LD_INT 2
97699: PUSH
97700: EMPTY
97701: LIST
97702: LIST
97703: PUSH
97704: LD_INT 3
97706: PUSH
97707: LD_INT 3
97709: PUSH
97710: EMPTY
97711: LIST
97712: LIST
97713: PUSH
97714: LD_INT 2
97716: PUSH
97717: LD_INT 3
97719: PUSH
97720: EMPTY
97721: LIST
97722: LIST
97723: PUSH
97724: EMPTY
97725: LIST
97726: LIST
97727: LIST
97728: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
97729: LD_ADDR_VAR 0 20
97733: PUSH
97734: LD_INT 1
97736: PUSH
97737: LD_INT 3
97739: PUSH
97740: EMPTY
97741: LIST
97742: LIST
97743: PUSH
97744: LD_INT 0
97746: PUSH
97747: LD_INT 3
97749: PUSH
97750: EMPTY
97751: LIST
97752: LIST
97753: PUSH
97754: LD_INT 1
97756: NEG
97757: PUSH
97758: LD_INT 2
97760: PUSH
97761: EMPTY
97762: LIST
97763: LIST
97764: PUSH
97765: EMPTY
97766: LIST
97767: LIST
97768: LIST
97769: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
97770: LD_ADDR_VAR 0 21
97774: PUSH
97775: LD_INT 2
97777: NEG
97778: PUSH
97779: LD_INT 1
97781: PUSH
97782: EMPTY
97783: LIST
97784: LIST
97785: PUSH
97786: LD_INT 3
97788: NEG
97789: PUSH
97790: LD_INT 0
97792: PUSH
97793: EMPTY
97794: LIST
97795: LIST
97796: PUSH
97797: LD_INT 3
97799: NEG
97800: PUSH
97801: LD_INT 1
97803: NEG
97804: PUSH
97805: EMPTY
97806: LIST
97807: LIST
97808: PUSH
97809: EMPTY
97810: LIST
97811: LIST
97812: LIST
97813: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
97814: LD_ADDR_VAR 0 22
97818: PUSH
97819: LD_INT 2
97821: NEG
97822: PUSH
97823: LD_INT 3
97825: NEG
97826: PUSH
97827: EMPTY
97828: LIST
97829: LIST
97830: PUSH
97831: LD_INT 3
97833: NEG
97834: PUSH
97835: LD_INT 2
97837: NEG
97838: PUSH
97839: EMPTY
97840: LIST
97841: LIST
97842: PUSH
97843: LD_INT 3
97845: NEG
97846: PUSH
97847: LD_INT 3
97849: NEG
97850: PUSH
97851: EMPTY
97852: LIST
97853: LIST
97854: PUSH
97855: EMPTY
97856: LIST
97857: LIST
97858: LIST
97859: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
97860: LD_ADDR_VAR 0 23
97864: PUSH
97865: LD_INT 0
97867: PUSH
97868: LD_INT 3
97870: NEG
97871: PUSH
97872: EMPTY
97873: LIST
97874: LIST
97875: PUSH
97876: LD_INT 1
97878: NEG
97879: PUSH
97880: LD_INT 4
97882: NEG
97883: PUSH
97884: EMPTY
97885: LIST
97886: LIST
97887: PUSH
97888: LD_INT 1
97890: PUSH
97891: LD_INT 3
97893: NEG
97894: PUSH
97895: EMPTY
97896: LIST
97897: LIST
97898: PUSH
97899: EMPTY
97900: LIST
97901: LIST
97902: LIST
97903: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
97904: LD_ADDR_VAR 0 24
97908: PUSH
97909: LD_INT 3
97911: PUSH
97912: LD_INT 0
97914: PUSH
97915: EMPTY
97916: LIST
97917: LIST
97918: PUSH
97919: LD_INT 3
97921: PUSH
97922: LD_INT 1
97924: NEG
97925: PUSH
97926: EMPTY
97927: LIST
97928: LIST
97929: PUSH
97930: LD_INT 4
97932: PUSH
97933: LD_INT 1
97935: PUSH
97936: EMPTY
97937: LIST
97938: LIST
97939: PUSH
97940: EMPTY
97941: LIST
97942: LIST
97943: LIST
97944: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
97945: LD_ADDR_VAR 0 25
97949: PUSH
97950: LD_INT 3
97952: PUSH
97953: LD_INT 3
97955: PUSH
97956: EMPTY
97957: LIST
97958: LIST
97959: PUSH
97960: LD_INT 4
97962: PUSH
97963: LD_INT 3
97965: PUSH
97966: EMPTY
97967: LIST
97968: LIST
97969: PUSH
97970: LD_INT 3
97972: PUSH
97973: LD_INT 4
97975: PUSH
97976: EMPTY
97977: LIST
97978: LIST
97979: PUSH
97980: EMPTY
97981: LIST
97982: LIST
97983: LIST
97984: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
97985: LD_ADDR_VAR 0 26
97989: PUSH
97990: LD_INT 0
97992: PUSH
97993: LD_INT 3
97995: PUSH
97996: EMPTY
97997: LIST
97998: LIST
97999: PUSH
98000: LD_INT 1
98002: PUSH
98003: LD_INT 4
98005: PUSH
98006: EMPTY
98007: LIST
98008: LIST
98009: PUSH
98010: LD_INT 1
98012: NEG
98013: PUSH
98014: LD_INT 3
98016: PUSH
98017: EMPTY
98018: LIST
98019: LIST
98020: PUSH
98021: EMPTY
98022: LIST
98023: LIST
98024: LIST
98025: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
98026: LD_ADDR_VAR 0 27
98030: PUSH
98031: LD_INT 3
98033: NEG
98034: PUSH
98035: LD_INT 0
98037: PUSH
98038: EMPTY
98039: LIST
98040: LIST
98041: PUSH
98042: LD_INT 3
98044: NEG
98045: PUSH
98046: LD_INT 1
98048: PUSH
98049: EMPTY
98050: LIST
98051: LIST
98052: PUSH
98053: LD_INT 4
98055: NEG
98056: PUSH
98057: LD_INT 1
98059: NEG
98060: PUSH
98061: EMPTY
98062: LIST
98063: LIST
98064: PUSH
98065: EMPTY
98066: LIST
98067: LIST
98068: LIST
98069: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
98070: LD_ADDR_VAR 0 28
98074: PUSH
98075: LD_INT 3
98077: NEG
98078: PUSH
98079: LD_INT 3
98081: NEG
98082: PUSH
98083: EMPTY
98084: LIST
98085: LIST
98086: PUSH
98087: LD_INT 3
98089: NEG
98090: PUSH
98091: LD_INT 4
98093: NEG
98094: PUSH
98095: EMPTY
98096: LIST
98097: LIST
98098: PUSH
98099: LD_INT 4
98101: NEG
98102: PUSH
98103: LD_INT 3
98105: NEG
98106: PUSH
98107: EMPTY
98108: LIST
98109: LIST
98110: PUSH
98111: EMPTY
98112: LIST
98113: LIST
98114: LIST
98115: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
98116: LD_ADDR_VAR 0 29
98120: PUSH
98121: LD_INT 1
98123: NEG
98124: PUSH
98125: LD_INT 3
98127: NEG
98128: PUSH
98129: EMPTY
98130: LIST
98131: LIST
98132: PUSH
98133: LD_INT 0
98135: PUSH
98136: LD_INT 3
98138: NEG
98139: PUSH
98140: EMPTY
98141: LIST
98142: LIST
98143: PUSH
98144: LD_INT 1
98146: PUSH
98147: LD_INT 2
98149: NEG
98150: PUSH
98151: EMPTY
98152: LIST
98153: LIST
98154: PUSH
98155: LD_INT 1
98157: NEG
98158: PUSH
98159: LD_INT 4
98161: NEG
98162: PUSH
98163: EMPTY
98164: LIST
98165: LIST
98166: PUSH
98167: LD_INT 0
98169: PUSH
98170: LD_INT 4
98172: NEG
98173: PUSH
98174: EMPTY
98175: LIST
98176: LIST
98177: PUSH
98178: LD_INT 1
98180: PUSH
98181: LD_INT 3
98183: NEG
98184: PUSH
98185: EMPTY
98186: LIST
98187: LIST
98188: PUSH
98189: LD_INT 1
98191: NEG
98192: PUSH
98193: LD_INT 5
98195: NEG
98196: PUSH
98197: EMPTY
98198: LIST
98199: LIST
98200: PUSH
98201: LD_INT 0
98203: PUSH
98204: LD_INT 5
98206: NEG
98207: PUSH
98208: EMPTY
98209: LIST
98210: LIST
98211: PUSH
98212: LD_INT 1
98214: PUSH
98215: LD_INT 4
98217: NEG
98218: PUSH
98219: EMPTY
98220: LIST
98221: LIST
98222: PUSH
98223: LD_INT 1
98225: NEG
98226: PUSH
98227: LD_INT 6
98229: NEG
98230: PUSH
98231: EMPTY
98232: LIST
98233: LIST
98234: PUSH
98235: LD_INT 0
98237: PUSH
98238: LD_INT 6
98240: NEG
98241: PUSH
98242: EMPTY
98243: LIST
98244: LIST
98245: PUSH
98246: LD_INT 1
98248: PUSH
98249: LD_INT 5
98251: NEG
98252: PUSH
98253: EMPTY
98254: LIST
98255: LIST
98256: PUSH
98257: EMPTY
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: LIST
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
98271: LD_ADDR_VAR 0 30
98275: PUSH
98276: LD_INT 2
98278: PUSH
98279: LD_INT 1
98281: NEG
98282: PUSH
98283: EMPTY
98284: LIST
98285: LIST
98286: PUSH
98287: LD_INT 3
98289: PUSH
98290: LD_INT 0
98292: PUSH
98293: EMPTY
98294: LIST
98295: LIST
98296: PUSH
98297: LD_INT 3
98299: PUSH
98300: LD_INT 1
98302: PUSH
98303: EMPTY
98304: LIST
98305: LIST
98306: PUSH
98307: LD_INT 3
98309: PUSH
98310: LD_INT 1
98312: NEG
98313: PUSH
98314: EMPTY
98315: LIST
98316: LIST
98317: PUSH
98318: LD_INT 4
98320: PUSH
98321: LD_INT 0
98323: PUSH
98324: EMPTY
98325: LIST
98326: LIST
98327: PUSH
98328: LD_INT 4
98330: PUSH
98331: LD_INT 1
98333: PUSH
98334: EMPTY
98335: LIST
98336: LIST
98337: PUSH
98338: LD_INT 4
98340: PUSH
98341: LD_INT 1
98343: NEG
98344: PUSH
98345: EMPTY
98346: LIST
98347: LIST
98348: PUSH
98349: LD_INT 5
98351: PUSH
98352: LD_INT 0
98354: PUSH
98355: EMPTY
98356: LIST
98357: LIST
98358: PUSH
98359: LD_INT 5
98361: PUSH
98362: LD_INT 1
98364: PUSH
98365: EMPTY
98366: LIST
98367: LIST
98368: PUSH
98369: LD_INT 5
98371: PUSH
98372: LD_INT 1
98374: NEG
98375: PUSH
98376: EMPTY
98377: LIST
98378: LIST
98379: PUSH
98380: LD_INT 6
98382: PUSH
98383: LD_INT 0
98385: PUSH
98386: EMPTY
98387: LIST
98388: LIST
98389: PUSH
98390: LD_INT 6
98392: PUSH
98393: LD_INT 1
98395: PUSH
98396: EMPTY
98397: LIST
98398: LIST
98399: PUSH
98400: EMPTY
98401: LIST
98402: LIST
98403: LIST
98404: LIST
98405: LIST
98406: LIST
98407: LIST
98408: LIST
98409: LIST
98410: LIST
98411: LIST
98412: LIST
98413: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
98414: LD_ADDR_VAR 0 31
98418: PUSH
98419: LD_INT 3
98421: PUSH
98422: LD_INT 2
98424: PUSH
98425: EMPTY
98426: LIST
98427: LIST
98428: PUSH
98429: LD_INT 3
98431: PUSH
98432: LD_INT 3
98434: PUSH
98435: EMPTY
98436: LIST
98437: LIST
98438: PUSH
98439: LD_INT 2
98441: PUSH
98442: LD_INT 3
98444: PUSH
98445: EMPTY
98446: LIST
98447: LIST
98448: PUSH
98449: LD_INT 4
98451: PUSH
98452: LD_INT 3
98454: PUSH
98455: EMPTY
98456: LIST
98457: LIST
98458: PUSH
98459: LD_INT 4
98461: PUSH
98462: LD_INT 4
98464: PUSH
98465: EMPTY
98466: LIST
98467: LIST
98468: PUSH
98469: LD_INT 3
98471: PUSH
98472: LD_INT 4
98474: PUSH
98475: EMPTY
98476: LIST
98477: LIST
98478: PUSH
98479: LD_INT 5
98481: PUSH
98482: LD_INT 4
98484: PUSH
98485: EMPTY
98486: LIST
98487: LIST
98488: PUSH
98489: LD_INT 5
98491: PUSH
98492: LD_INT 5
98494: PUSH
98495: EMPTY
98496: LIST
98497: LIST
98498: PUSH
98499: LD_INT 4
98501: PUSH
98502: LD_INT 5
98504: PUSH
98505: EMPTY
98506: LIST
98507: LIST
98508: PUSH
98509: LD_INT 6
98511: PUSH
98512: LD_INT 5
98514: PUSH
98515: EMPTY
98516: LIST
98517: LIST
98518: PUSH
98519: LD_INT 6
98521: PUSH
98522: LD_INT 6
98524: PUSH
98525: EMPTY
98526: LIST
98527: LIST
98528: PUSH
98529: LD_INT 5
98531: PUSH
98532: LD_INT 6
98534: PUSH
98535: EMPTY
98536: LIST
98537: LIST
98538: PUSH
98539: EMPTY
98540: LIST
98541: LIST
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
98553: LD_ADDR_VAR 0 32
98557: PUSH
98558: LD_INT 1
98560: PUSH
98561: LD_INT 3
98563: PUSH
98564: EMPTY
98565: LIST
98566: LIST
98567: PUSH
98568: LD_INT 0
98570: PUSH
98571: LD_INT 3
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: PUSH
98578: LD_INT 1
98580: NEG
98581: PUSH
98582: LD_INT 2
98584: PUSH
98585: EMPTY
98586: LIST
98587: LIST
98588: PUSH
98589: LD_INT 1
98591: PUSH
98592: LD_INT 4
98594: PUSH
98595: EMPTY
98596: LIST
98597: LIST
98598: PUSH
98599: LD_INT 0
98601: PUSH
98602: LD_INT 4
98604: PUSH
98605: EMPTY
98606: LIST
98607: LIST
98608: PUSH
98609: LD_INT 1
98611: NEG
98612: PUSH
98613: LD_INT 3
98615: PUSH
98616: EMPTY
98617: LIST
98618: LIST
98619: PUSH
98620: LD_INT 1
98622: PUSH
98623: LD_INT 5
98625: PUSH
98626: EMPTY
98627: LIST
98628: LIST
98629: PUSH
98630: LD_INT 0
98632: PUSH
98633: LD_INT 5
98635: PUSH
98636: EMPTY
98637: LIST
98638: LIST
98639: PUSH
98640: LD_INT 1
98642: NEG
98643: PUSH
98644: LD_INT 4
98646: PUSH
98647: EMPTY
98648: LIST
98649: LIST
98650: PUSH
98651: LD_INT 1
98653: PUSH
98654: LD_INT 6
98656: PUSH
98657: EMPTY
98658: LIST
98659: LIST
98660: PUSH
98661: LD_INT 0
98663: PUSH
98664: LD_INT 6
98666: PUSH
98667: EMPTY
98668: LIST
98669: LIST
98670: PUSH
98671: LD_INT 1
98673: NEG
98674: PUSH
98675: LD_INT 5
98677: PUSH
98678: EMPTY
98679: LIST
98680: LIST
98681: PUSH
98682: EMPTY
98683: LIST
98684: LIST
98685: LIST
98686: LIST
98687: LIST
98688: LIST
98689: LIST
98690: LIST
98691: LIST
98692: LIST
98693: LIST
98694: LIST
98695: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
98696: LD_ADDR_VAR 0 33
98700: PUSH
98701: LD_INT 2
98703: NEG
98704: PUSH
98705: LD_INT 1
98707: PUSH
98708: EMPTY
98709: LIST
98710: LIST
98711: PUSH
98712: LD_INT 3
98714: NEG
98715: PUSH
98716: LD_INT 0
98718: PUSH
98719: EMPTY
98720: LIST
98721: LIST
98722: PUSH
98723: LD_INT 3
98725: NEG
98726: PUSH
98727: LD_INT 1
98729: NEG
98730: PUSH
98731: EMPTY
98732: LIST
98733: LIST
98734: PUSH
98735: LD_INT 3
98737: NEG
98738: PUSH
98739: LD_INT 1
98741: PUSH
98742: EMPTY
98743: LIST
98744: LIST
98745: PUSH
98746: LD_INT 4
98748: NEG
98749: PUSH
98750: LD_INT 0
98752: PUSH
98753: EMPTY
98754: LIST
98755: LIST
98756: PUSH
98757: LD_INT 4
98759: NEG
98760: PUSH
98761: LD_INT 1
98763: NEG
98764: PUSH
98765: EMPTY
98766: LIST
98767: LIST
98768: PUSH
98769: LD_INT 4
98771: NEG
98772: PUSH
98773: LD_INT 1
98775: PUSH
98776: EMPTY
98777: LIST
98778: LIST
98779: PUSH
98780: LD_INT 5
98782: NEG
98783: PUSH
98784: LD_INT 0
98786: PUSH
98787: EMPTY
98788: LIST
98789: LIST
98790: PUSH
98791: LD_INT 5
98793: NEG
98794: PUSH
98795: LD_INT 1
98797: NEG
98798: PUSH
98799: EMPTY
98800: LIST
98801: LIST
98802: PUSH
98803: LD_INT 5
98805: NEG
98806: PUSH
98807: LD_INT 1
98809: PUSH
98810: EMPTY
98811: LIST
98812: LIST
98813: PUSH
98814: LD_INT 6
98816: NEG
98817: PUSH
98818: LD_INT 0
98820: PUSH
98821: EMPTY
98822: LIST
98823: LIST
98824: PUSH
98825: LD_INT 6
98827: NEG
98828: PUSH
98829: LD_INT 1
98831: NEG
98832: PUSH
98833: EMPTY
98834: LIST
98835: LIST
98836: PUSH
98837: EMPTY
98838: LIST
98839: LIST
98840: LIST
98841: LIST
98842: LIST
98843: LIST
98844: LIST
98845: LIST
98846: LIST
98847: LIST
98848: LIST
98849: LIST
98850: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
98851: LD_ADDR_VAR 0 34
98855: PUSH
98856: LD_INT 2
98858: NEG
98859: PUSH
98860: LD_INT 3
98862: NEG
98863: PUSH
98864: EMPTY
98865: LIST
98866: LIST
98867: PUSH
98868: LD_INT 3
98870: NEG
98871: PUSH
98872: LD_INT 2
98874: NEG
98875: PUSH
98876: EMPTY
98877: LIST
98878: LIST
98879: PUSH
98880: LD_INT 3
98882: NEG
98883: PUSH
98884: LD_INT 3
98886: NEG
98887: PUSH
98888: EMPTY
98889: LIST
98890: LIST
98891: PUSH
98892: LD_INT 3
98894: NEG
98895: PUSH
98896: LD_INT 4
98898: NEG
98899: PUSH
98900: EMPTY
98901: LIST
98902: LIST
98903: PUSH
98904: LD_INT 4
98906: NEG
98907: PUSH
98908: LD_INT 3
98910: NEG
98911: PUSH
98912: EMPTY
98913: LIST
98914: LIST
98915: PUSH
98916: LD_INT 4
98918: NEG
98919: PUSH
98920: LD_INT 4
98922: NEG
98923: PUSH
98924: EMPTY
98925: LIST
98926: LIST
98927: PUSH
98928: LD_INT 4
98930: NEG
98931: PUSH
98932: LD_INT 5
98934: NEG
98935: PUSH
98936: EMPTY
98937: LIST
98938: LIST
98939: PUSH
98940: LD_INT 5
98942: NEG
98943: PUSH
98944: LD_INT 4
98946: NEG
98947: PUSH
98948: EMPTY
98949: LIST
98950: LIST
98951: PUSH
98952: LD_INT 5
98954: NEG
98955: PUSH
98956: LD_INT 5
98958: NEG
98959: PUSH
98960: EMPTY
98961: LIST
98962: LIST
98963: PUSH
98964: LD_INT 5
98966: NEG
98967: PUSH
98968: LD_INT 6
98970: NEG
98971: PUSH
98972: EMPTY
98973: LIST
98974: LIST
98975: PUSH
98976: LD_INT 6
98978: NEG
98979: PUSH
98980: LD_INT 5
98982: NEG
98983: PUSH
98984: EMPTY
98985: LIST
98986: LIST
98987: PUSH
98988: LD_INT 6
98990: NEG
98991: PUSH
98992: LD_INT 6
98994: NEG
98995: PUSH
98996: EMPTY
98997: LIST
98998: LIST
98999: PUSH
99000: EMPTY
99001: LIST
99002: LIST
99003: LIST
99004: LIST
99005: LIST
99006: LIST
99007: LIST
99008: LIST
99009: LIST
99010: LIST
99011: LIST
99012: LIST
99013: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
99014: LD_ADDR_VAR 0 41
99018: PUSH
99019: LD_INT 0
99021: PUSH
99022: LD_INT 2
99024: NEG
99025: PUSH
99026: EMPTY
99027: LIST
99028: LIST
99029: PUSH
99030: LD_INT 1
99032: NEG
99033: PUSH
99034: LD_INT 3
99036: NEG
99037: PUSH
99038: EMPTY
99039: LIST
99040: LIST
99041: PUSH
99042: LD_INT 1
99044: PUSH
99045: LD_INT 2
99047: NEG
99048: PUSH
99049: EMPTY
99050: LIST
99051: LIST
99052: PUSH
99053: EMPTY
99054: LIST
99055: LIST
99056: LIST
99057: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
99058: LD_ADDR_VAR 0 42
99062: PUSH
99063: LD_INT 2
99065: PUSH
99066: LD_INT 0
99068: PUSH
99069: EMPTY
99070: LIST
99071: LIST
99072: PUSH
99073: LD_INT 2
99075: PUSH
99076: LD_INT 1
99078: NEG
99079: PUSH
99080: EMPTY
99081: LIST
99082: LIST
99083: PUSH
99084: LD_INT 3
99086: PUSH
99087: LD_INT 1
99089: PUSH
99090: EMPTY
99091: LIST
99092: LIST
99093: PUSH
99094: EMPTY
99095: LIST
99096: LIST
99097: LIST
99098: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
99099: LD_ADDR_VAR 0 43
99103: PUSH
99104: LD_INT 2
99106: PUSH
99107: LD_INT 2
99109: PUSH
99110: EMPTY
99111: LIST
99112: LIST
99113: PUSH
99114: LD_INT 3
99116: PUSH
99117: LD_INT 2
99119: PUSH
99120: EMPTY
99121: LIST
99122: LIST
99123: PUSH
99124: LD_INT 2
99126: PUSH
99127: LD_INT 3
99129: PUSH
99130: EMPTY
99131: LIST
99132: LIST
99133: PUSH
99134: EMPTY
99135: LIST
99136: LIST
99137: LIST
99138: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
99139: LD_ADDR_VAR 0 44
99143: PUSH
99144: LD_INT 0
99146: PUSH
99147: LD_INT 2
99149: PUSH
99150: EMPTY
99151: LIST
99152: LIST
99153: PUSH
99154: LD_INT 1
99156: PUSH
99157: LD_INT 3
99159: PUSH
99160: EMPTY
99161: LIST
99162: LIST
99163: PUSH
99164: LD_INT 1
99166: NEG
99167: PUSH
99168: LD_INT 2
99170: PUSH
99171: EMPTY
99172: LIST
99173: LIST
99174: PUSH
99175: EMPTY
99176: LIST
99177: LIST
99178: LIST
99179: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
99180: LD_ADDR_VAR 0 45
99184: PUSH
99185: LD_INT 2
99187: NEG
99188: PUSH
99189: LD_INT 0
99191: PUSH
99192: EMPTY
99193: LIST
99194: LIST
99195: PUSH
99196: LD_INT 2
99198: NEG
99199: PUSH
99200: LD_INT 1
99202: PUSH
99203: EMPTY
99204: LIST
99205: LIST
99206: PUSH
99207: LD_INT 3
99209: NEG
99210: PUSH
99211: LD_INT 1
99213: NEG
99214: PUSH
99215: EMPTY
99216: LIST
99217: LIST
99218: PUSH
99219: EMPTY
99220: LIST
99221: LIST
99222: LIST
99223: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
99224: LD_ADDR_VAR 0 46
99228: PUSH
99229: LD_INT 2
99231: NEG
99232: PUSH
99233: LD_INT 2
99235: NEG
99236: PUSH
99237: EMPTY
99238: LIST
99239: LIST
99240: PUSH
99241: LD_INT 2
99243: NEG
99244: PUSH
99245: LD_INT 3
99247: NEG
99248: PUSH
99249: EMPTY
99250: LIST
99251: LIST
99252: PUSH
99253: LD_INT 3
99255: NEG
99256: PUSH
99257: LD_INT 2
99259: NEG
99260: PUSH
99261: EMPTY
99262: LIST
99263: LIST
99264: PUSH
99265: EMPTY
99266: LIST
99267: LIST
99268: LIST
99269: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
99270: LD_ADDR_VAR 0 47
99274: PUSH
99275: LD_INT 2
99277: NEG
99278: PUSH
99279: LD_INT 3
99281: NEG
99282: PUSH
99283: EMPTY
99284: LIST
99285: LIST
99286: PUSH
99287: LD_INT 1
99289: NEG
99290: PUSH
99291: LD_INT 3
99293: NEG
99294: PUSH
99295: EMPTY
99296: LIST
99297: LIST
99298: PUSH
99299: EMPTY
99300: LIST
99301: LIST
99302: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
99303: LD_ADDR_VAR 0 48
99307: PUSH
99308: LD_INT 1
99310: PUSH
99311: LD_INT 2
99313: NEG
99314: PUSH
99315: EMPTY
99316: LIST
99317: LIST
99318: PUSH
99319: LD_INT 2
99321: PUSH
99322: LD_INT 1
99324: NEG
99325: PUSH
99326: EMPTY
99327: LIST
99328: LIST
99329: PUSH
99330: EMPTY
99331: LIST
99332: LIST
99333: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
99334: LD_ADDR_VAR 0 49
99338: PUSH
99339: LD_INT 3
99341: PUSH
99342: LD_INT 1
99344: PUSH
99345: EMPTY
99346: LIST
99347: LIST
99348: PUSH
99349: LD_INT 3
99351: PUSH
99352: LD_INT 2
99354: PUSH
99355: EMPTY
99356: LIST
99357: LIST
99358: PUSH
99359: EMPTY
99360: LIST
99361: LIST
99362: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
99363: LD_ADDR_VAR 0 50
99367: PUSH
99368: LD_INT 2
99370: PUSH
99371: LD_INT 3
99373: PUSH
99374: EMPTY
99375: LIST
99376: LIST
99377: PUSH
99378: LD_INT 1
99380: PUSH
99381: LD_INT 3
99383: PUSH
99384: EMPTY
99385: LIST
99386: LIST
99387: PUSH
99388: EMPTY
99389: LIST
99390: LIST
99391: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
99392: LD_ADDR_VAR 0 51
99396: PUSH
99397: LD_INT 1
99399: NEG
99400: PUSH
99401: LD_INT 2
99403: PUSH
99404: EMPTY
99405: LIST
99406: LIST
99407: PUSH
99408: LD_INT 2
99410: NEG
99411: PUSH
99412: LD_INT 1
99414: PUSH
99415: EMPTY
99416: LIST
99417: LIST
99418: PUSH
99419: EMPTY
99420: LIST
99421: LIST
99422: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
99423: LD_ADDR_VAR 0 52
99427: PUSH
99428: LD_INT 3
99430: NEG
99431: PUSH
99432: LD_INT 1
99434: NEG
99435: PUSH
99436: EMPTY
99437: LIST
99438: LIST
99439: PUSH
99440: LD_INT 3
99442: NEG
99443: PUSH
99444: LD_INT 2
99446: NEG
99447: PUSH
99448: EMPTY
99449: LIST
99450: LIST
99451: PUSH
99452: EMPTY
99453: LIST
99454: LIST
99455: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
99456: LD_ADDR_VAR 0 53
99460: PUSH
99461: LD_INT 1
99463: NEG
99464: PUSH
99465: LD_INT 3
99467: NEG
99468: PUSH
99469: EMPTY
99470: LIST
99471: LIST
99472: PUSH
99473: LD_INT 0
99475: PUSH
99476: LD_INT 3
99478: NEG
99479: PUSH
99480: EMPTY
99481: LIST
99482: LIST
99483: PUSH
99484: LD_INT 1
99486: PUSH
99487: LD_INT 2
99489: NEG
99490: PUSH
99491: EMPTY
99492: LIST
99493: LIST
99494: PUSH
99495: EMPTY
99496: LIST
99497: LIST
99498: LIST
99499: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
99500: LD_ADDR_VAR 0 54
99504: PUSH
99505: LD_INT 2
99507: PUSH
99508: LD_INT 1
99510: NEG
99511: PUSH
99512: EMPTY
99513: LIST
99514: LIST
99515: PUSH
99516: LD_INT 3
99518: PUSH
99519: LD_INT 0
99521: PUSH
99522: EMPTY
99523: LIST
99524: LIST
99525: PUSH
99526: LD_INT 3
99528: PUSH
99529: LD_INT 1
99531: PUSH
99532: EMPTY
99533: LIST
99534: LIST
99535: PUSH
99536: EMPTY
99537: LIST
99538: LIST
99539: LIST
99540: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
99541: LD_ADDR_VAR 0 55
99545: PUSH
99546: LD_INT 3
99548: PUSH
99549: LD_INT 2
99551: PUSH
99552: EMPTY
99553: LIST
99554: LIST
99555: PUSH
99556: LD_INT 3
99558: PUSH
99559: LD_INT 3
99561: PUSH
99562: EMPTY
99563: LIST
99564: LIST
99565: PUSH
99566: LD_INT 2
99568: PUSH
99569: LD_INT 3
99571: PUSH
99572: EMPTY
99573: LIST
99574: LIST
99575: PUSH
99576: EMPTY
99577: LIST
99578: LIST
99579: LIST
99580: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
99581: LD_ADDR_VAR 0 56
99585: PUSH
99586: LD_INT 1
99588: PUSH
99589: LD_INT 3
99591: PUSH
99592: EMPTY
99593: LIST
99594: LIST
99595: PUSH
99596: LD_INT 0
99598: PUSH
99599: LD_INT 3
99601: PUSH
99602: EMPTY
99603: LIST
99604: LIST
99605: PUSH
99606: LD_INT 1
99608: NEG
99609: PUSH
99610: LD_INT 2
99612: PUSH
99613: EMPTY
99614: LIST
99615: LIST
99616: PUSH
99617: EMPTY
99618: LIST
99619: LIST
99620: LIST
99621: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
99622: LD_ADDR_VAR 0 57
99626: PUSH
99627: LD_INT 2
99629: NEG
99630: PUSH
99631: LD_INT 1
99633: PUSH
99634: EMPTY
99635: LIST
99636: LIST
99637: PUSH
99638: LD_INT 3
99640: NEG
99641: PUSH
99642: LD_INT 0
99644: PUSH
99645: EMPTY
99646: LIST
99647: LIST
99648: PUSH
99649: LD_INT 3
99651: NEG
99652: PUSH
99653: LD_INT 1
99655: NEG
99656: PUSH
99657: EMPTY
99658: LIST
99659: LIST
99660: PUSH
99661: EMPTY
99662: LIST
99663: LIST
99664: LIST
99665: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
99666: LD_ADDR_VAR 0 58
99670: PUSH
99671: LD_INT 2
99673: NEG
99674: PUSH
99675: LD_INT 3
99677: NEG
99678: PUSH
99679: EMPTY
99680: LIST
99681: LIST
99682: PUSH
99683: LD_INT 3
99685: NEG
99686: PUSH
99687: LD_INT 2
99689: NEG
99690: PUSH
99691: EMPTY
99692: LIST
99693: LIST
99694: PUSH
99695: LD_INT 3
99697: NEG
99698: PUSH
99699: LD_INT 3
99701: NEG
99702: PUSH
99703: EMPTY
99704: LIST
99705: LIST
99706: PUSH
99707: EMPTY
99708: LIST
99709: LIST
99710: LIST
99711: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
99712: LD_ADDR_VAR 0 59
99716: PUSH
99717: LD_INT 1
99719: NEG
99720: PUSH
99721: LD_INT 2
99723: NEG
99724: PUSH
99725: EMPTY
99726: LIST
99727: LIST
99728: PUSH
99729: LD_INT 0
99731: PUSH
99732: LD_INT 2
99734: NEG
99735: PUSH
99736: EMPTY
99737: LIST
99738: LIST
99739: PUSH
99740: LD_INT 1
99742: PUSH
99743: LD_INT 1
99745: NEG
99746: PUSH
99747: EMPTY
99748: LIST
99749: LIST
99750: PUSH
99751: EMPTY
99752: LIST
99753: LIST
99754: LIST
99755: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
99756: LD_ADDR_VAR 0 60
99760: PUSH
99761: LD_INT 1
99763: PUSH
99764: LD_INT 1
99766: NEG
99767: PUSH
99768: EMPTY
99769: LIST
99770: LIST
99771: PUSH
99772: LD_INT 2
99774: PUSH
99775: LD_INT 0
99777: PUSH
99778: EMPTY
99779: LIST
99780: LIST
99781: PUSH
99782: LD_INT 2
99784: PUSH
99785: LD_INT 1
99787: PUSH
99788: EMPTY
99789: LIST
99790: LIST
99791: PUSH
99792: EMPTY
99793: LIST
99794: LIST
99795: LIST
99796: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
99797: LD_ADDR_VAR 0 61
99801: PUSH
99802: LD_INT 2
99804: PUSH
99805: LD_INT 1
99807: PUSH
99808: EMPTY
99809: LIST
99810: LIST
99811: PUSH
99812: LD_INT 2
99814: PUSH
99815: LD_INT 2
99817: PUSH
99818: EMPTY
99819: LIST
99820: LIST
99821: PUSH
99822: LD_INT 1
99824: PUSH
99825: LD_INT 2
99827: PUSH
99828: EMPTY
99829: LIST
99830: LIST
99831: PUSH
99832: EMPTY
99833: LIST
99834: LIST
99835: LIST
99836: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
99837: LD_ADDR_VAR 0 62
99841: PUSH
99842: LD_INT 1
99844: PUSH
99845: LD_INT 2
99847: PUSH
99848: EMPTY
99849: LIST
99850: LIST
99851: PUSH
99852: LD_INT 0
99854: PUSH
99855: LD_INT 2
99857: PUSH
99858: EMPTY
99859: LIST
99860: LIST
99861: PUSH
99862: LD_INT 1
99864: NEG
99865: PUSH
99866: LD_INT 1
99868: PUSH
99869: EMPTY
99870: LIST
99871: LIST
99872: PUSH
99873: EMPTY
99874: LIST
99875: LIST
99876: LIST
99877: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
99878: LD_ADDR_VAR 0 63
99882: PUSH
99883: LD_INT 1
99885: NEG
99886: PUSH
99887: LD_INT 1
99889: PUSH
99890: EMPTY
99891: LIST
99892: LIST
99893: PUSH
99894: LD_INT 2
99896: NEG
99897: PUSH
99898: LD_INT 0
99900: PUSH
99901: EMPTY
99902: LIST
99903: LIST
99904: PUSH
99905: LD_INT 2
99907: NEG
99908: PUSH
99909: LD_INT 1
99911: NEG
99912: PUSH
99913: EMPTY
99914: LIST
99915: LIST
99916: PUSH
99917: EMPTY
99918: LIST
99919: LIST
99920: LIST
99921: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
99922: LD_ADDR_VAR 0 64
99926: PUSH
99927: LD_INT 1
99929: NEG
99930: PUSH
99931: LD_INT 2
99933: NEG
99934: PUSH
99935: EMPTY
99936: LIST
99937: LIST
99938: PUSH
99939: LD_INT 2
99941: NEG
99942: PUSH
99943: LD_INT 1
99945: NEG
99946: PUSH
99947: EMPTY
99948: LIST
99949: LIST
99950: PUSH
99951: LD_INT 2
99953: NEG
99954: PUSH
99955: LD_INT 2
99957: NEG
99958: PUSH
99959: EMPTY
99960: LIST
99961: LIST
99962: PUSH
99963: EMPTY
99964: LIST
99965: LIST
99966: LIST
99967: ST_TO_ADDR
// end ; 2 :
99968: GO 103234
99970: LD_INT 2
99972: DOUBLE
99973: EQUAL
99974: IFTRUE 99978
99976: GO 103233
99978: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
99979: LD_ADDR_VAR 0 29
99983: PUSH
99984: LD_INT 4
99986: PUSH
99987: LD_INT 0
99989: PUSH
99990: EMPTY
99991: LIST
99992: LIST
99993: PUSH
99994: LD_INT 4
99996: PUSH
99997: LD_INT 1
99999: NEG
100000: PUSH
100001: EMPTY
100002: LIST
100003: LIST
100004: PUSH
100005: LD_INT 5
100007: PUSH
100008: LD_INT 0
100010: PUSH
100011: EMPTY
100012: LIST
100013: LIST
100014: PUSH
100015: LD_INT 5
100017: PUSH
100018: LD_INT 1
100020: PUSH
100021: EMPTY
100022: LIST
100023: LIST
100024: PUSH
100025: LD_INT 4
100027: PUSH
100028: LD_INT 1
100030: PUSH
100031: EMPTY
100032: LIST
100033: LIST
100034: PUSH
100035: LD_INT 3
100037: PUSH
100038: LD_INT 0
100040: PUSH
100041: EMPTY
100042: LIST
100043: LIST
100044: PUSH
100045: LD_INT 3
100047: PUSH
100048: LD_INT 1
100050: NEG
100051: PUSH
100052: EMPTY
100053: LIST
100054: LIST
100055: PUSH
100056: LD_INT 3
100058: PUSH
100059: LD_INT 2
100061: NEG
100062: PUSH
100063: EMPTY
100064: LIST
100065: LIST
100066: PUSH
100067: LD_INT 5
100069: PUSH
100070: LD_INT 2
100072: PUSH
100073: EMPTY
100074: LIST
100075: LIST
100076: PUSH
100077: LD_INT 3
100079: PUSH
100080: LD_INT 3
100082: PUSH
100083: EMPTY
100084: LIST
100085: LIST
100086: PUSH
100087: LD_INT 3
100089: PUSH
100090: LD_INT 2
100092: PUSH
100093: EMPTY
100094: LIST
100095: LIST
100096: PUSH
100097: LD_INT 4
100099: PUSH
100100: LD_INT 3
100102: PUSH
100103: EMPTY
100104: LIST
100105: LIST
100106: PUSH
100107: LD_INT 4
100109: PUSH
100110: LD_INT 4
100112: PUSH
100113: EMPTY
100114: LIST
100115: LIST
100116: PUSH
100117: LD_INT 3
100119: PUSH
100120: LD_INT 4
100122: PUSH
100123: EMPTY
100124: LIST
100125: LIST
100126: PUSH
100127: LD_INT 2
100129: PUSH
100130: LD_INT 3
100132: PUSH
100133: EMPTY
100134: LIST
100135: LIST
100136: PUSH
100137: LD_INT 2
100139: PUSH
100140: LD_INT 2
100142: PUSH
100143: EMPTY
100144: LIST
100145: LIST
100146: PUSH
100147: LD_INT 4
100149: PUSH
100150: LD_INT 2
100152: PUSH
100153: EMPTY
100154: LIST
100155: LIST
100156: PUSH
100157: LD_INT 2
100159: PUSH
100160: LD_INT 4
100162: PUSH
100163: EMPTY
100164: LIST
100165: LIST
100166: PUSH
100167: LD_INT 0
100169: PUSH
100170: LD_INT 4
100172: PUSH
100173: EMPTY
100174: LIST
100175: LIST
100176: PUSH
100177: LD_INT 0
100179: PUSH
100180: LD_INT 3
100182: PUSH
100183: EMPTY
100184: LIST
100185: LIST
100186: PUSH
100187: LD_INT 1
100189: PUSH
100190: LD_INT 4
100192: PUSH
100193: EMPTY
100194: LIST
100195: LIST
100196: PUSH
100197: LD_INT 1
100199: PUSH
100200: LD_INT 5
100202: PUSH
100203: EMPTY
100204: LIST
100205: LIST
100206: PUSH
100207: LD_INT 0
100209: PUSH
100210: LD_INT 5
100212: PUSH
100213: EMPTY
100214: LIST
100215: LIST
100216: PUSH
100217: LD_INT 1
100219: NEG
100220: PUSH
100221: LD_INT 4
100223: PUSH
100224: EMPTY
100225: LIST
100226: LIST
100227: PUSH
100228: LD_INT 1
100230: NEG
100231: PUSH
100232: LD_INT 3
100234: PUSH
100235: EMPTY
100236: LIST
100237: LIST
100238: PUSH
100239: LD_INT 2
100241: PUSH
100242: LD_INT 5
100244: PUSH
100245: EMPTY
100246: LIST
100247: LIST
100248: PUSH
100249: LD_INT 2
100251: NEG
100252: PUSH
100253: LD_INT 3
100255: PUSH
100256: EMPTY
100257: LIST
100258: LIST
100259: PUSH
100260: LD_INT 3
100262: NEG
100263: PUSH
100264: LD_INT 0
100266: PUSH
100267: EMPTY
100268: LIST
100269: LIST
100270: PUSH
100271: LD_INT 3
100273: NEG
100274: PUSH
100275: LD_INT 1
100277: NEG
100278: PUSH
100279: EMPTY
100280: LIST
100281: LIST
100282: PUSH
100283: LD_INT 2
100285: NEG
100286: PUSH
100287: LD_INT 0
100289: PUSH
100290: EMPTY
100291: LIST
100292: LIST
100293: PUSH
100294: LD_INT 2
100296: NEG
100297: PUSH
100298: LD_INT 1
100300: PUSH
100301: EMPTY
100302: LIST
100303: LIST
100304: PUSH
100305: LD_INT 3
100307: NEG
100308: PUSH
100309: LD_INT 1
100311: PUSH
100312: EMPTY
100313: LIST
100314: LIST
100315: PUSH
100316: LD_INT 4
100318: NEG
100319: PUSH
100320: LD_INT 0
100322: PUSH
100323: EMPTY
100324: LIST
100325: LIST
100326: PUSH
100327: LD_INT 4
100329: NEG
100330: PUSH
100331: LD_INT 1
100333: NEG
100334: PUSH
100335: EMPTY
100336: LIST
100337: LIST
100338: PUSH
100339: LD_INT 4
100341: NEG
100342: PUSH
100343: LD_INT 2
100345: NEG
100346: PUSH
100347: EMPTY
100348: LIST
100349: LIST
100350: PUSH
100351: LD_INT 2
100353: NEG
100354: PUSH
100355: LD_INT 2
100357: PUSH
100358: EMPTY
100359: LIST
100360: LIST
100361: PUSH
100362: LD_INT 4
100364: NEG
100365: PUSH
100366: LD_INT 4
100368: NEG
100369: PUSH
100370: EMPTY
100371: LIST
100372: LIST
100373: PUSH
100374: LD_INT 4
100376: NEG
100377: PUSH
100378: LD_INT 5
100380: NEG
100381: PUSH
100382: EMPTY
100383: LIST
100384: LIST
100385: PUSH
100386: LD_INT 3
100388: NEG
100389: PUSH
100390: LD_INT 4
100392: NEG
100393: PUSH
100394: EMPTY
100395: LIST
100396: LIST
100397: PUSH
100398: LD_INT 3
100400: NEG
100401: PUSH
100402: LD_INT 3
100404: NEG
100405: PUSH
100406: EMPTY
100407: LIST
100408: LIST
100409: PUSH
100410: LD_INT 4
100412: NEG
100413: PUSH
100414: LD_INT 3
100416: NEG
100417: PUSH
100418: EMPTY
100419: LIST
100420: LIST
100421: PUSH
100422: LD_INT 5
100424: NEG
100425: PUSH
100426: LD_INT 4
100428: NEG
100429: PUSH
100430: EMPTY
100431: LIST
100432: LIST
100433: PUSH
100434: LD_INT 5
100436: NEG
100437: PUSH
100438: LD_INT 5
100440: NEG
100441: PUSH
100442: EMPTY
100443: LIST
100444: LIST
100445: PUSH
100446: LD_INT 3
100448: NEG
100449: PUSH
100450: LD_INT 5
100452: NEG
100453: PUSH
100454: EMPTY
100455: LIST
100456: LIST
100457: PUSH
100458: LD_INT 5
100460: NEG
100461: PUSH
100462: LD_INT 3
100464: NEG
100465: PUSH
100466: EMPTY
100467: LIST
100468: LIST
100469: PUSH
100470: EMPTY
100471: LIST
100472: LIST
100473: LIST
100474: LIST
100475: LIST
100476: LIST
100477: LIST
100478: LIST
100479: LIST
100480: LIST
100481: LIST
100482: LIST
100483: LIST
100484: LIST
100485: LIST
100486: LIST
100487: LIST
100488: LIST
100489: LIST
100490: LIST
100491: LIST
100492: LIST
100493: LIST
100494: LIST
100495: LIST
100496: LIST
100497: LIST
100498: LIST
100499: LIST
100500: LIST
100501: LIST
100502: LIST
100503: LIST
100504: LIST
100505: LIST
100506: LIST
100507: LIST
100508: LIST
100509: LIST
100510: LIST
100511: LIST
100512: LIST
100513: LIST
100514: LIST
100515: LIST
100516: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
100517: LD_ADDR_VAR 0 30
100521: PUSH
100522: LD_INT 4
100524: PUSH
100525: LD_INT 4
100527: PUSH
100528: EMPTY
100529: LIST
100530: LIST
100531: PUSH
100532: LD_INT 4
100534: PUSH
100535: LD_INT 3
100537: PUSH
100538: EMPTY
100539: LIST
100540: LIST
100541: PUSH
100542: LD_INT 5
100544: PUSH
100545: LD_INT 4
100547: PUSH
100548: EMPTY
100549: LIST
100550: LIST
100551: PUSH
100552: LD_INT 5
100554: PUSH
100555: LD_INT 5
100557: PUSH
100558: EMPTY
100559: LIST
100560: LIST
100561: PUSH
100562: LD_INT 4
100564: PUSH
100565: LD_INT 5
100567: PUSH
100568: EMPTY
100569: LIST
100570: LIST
100571: PUSH
100572: LD_INT 3
100574: PUSH
100575: LD_INT 4
100577: PUSH
100578: EMPTY
100579: LIST
100580: LIST
100581: PUSH
100582: LD_INT 3
100584: PUSH
100585: LD_INT 3
100587: PUSH
100588: EMPTY
100589: LIST
100590: LIST
100591: PUSH
100592: LD_INT 5
100594: PUSH
100595: LD_INT 3
100597: PUSH
100598: EMPTY
100599: LIST
100600: LIST
100601: PUSH
100602: LD_INT 3
100604: PUSH
100605: LD_INT 5
100607: PUSH
100608: EMPTY
100609: LIST
100610: LIST
100611: PUSH
100612: LD_INT 0
100614: PUSH
100615: LD_INT 3
100617: PUSH
100618: EMPTY
100619: LIST
100620: LIST
100621: PUSH
100622: LD_INT 0
100624: PUSH
100625: LD_INT 2
100627: PUSH
100628: EMPTY
100629: LIST
100630: LIST
100631: PUSH
100632: LD_INT 1
100634: PUSH
100635: LD_INT 3
100637: PUSH
100638: EMPTY
100639: LIST
100640: LIST
100641: PUSH
100642: LD_INT 1
100644: PUSH
100645: LD_INT 4
100647: PUSH
100648: EMPTY
100649: LIST
100650: LIST
100651: PUSH
100652: LD_INT 0
100654: PUSH
100655: LD_INT 4
100657: PUSH
100658: EMPTY
100659: LIST
100660: LIST
100661: PUSH
100662: LD_INT 1
100664: NEG
100665: PUSH
100666: LD_INT 3
100668: PUSH
100669: EMPTY
100670: LIST
100671: LIST
100672: PUSH
100673: LD_INT 1
100675: NEG
100676: PUSH
100677: LD_INT 2
100679: PUSH
100680: EMPTY
100681: LIST
100682: LIST
100683: PUSH
100684: LD_INT 2
100686: PUSH
100687: LD_INT 4
100689: PUSH
100690: EMPTY
100691: LIST
100692: LIST
100693: PUSH
100694: LD_INT 2
100696: NEG
100697: PUSH
100698: LD_INT 2
100700: PUSH
100701: EMPTY
100702: LIST
100703: LIST
100704: PUSH
100705: LD_INT 4
100707: NEG
100708: PUSH
100709: LD_INT 0
100711: PUSH
100712: EMPTY
100713: LIST
100714: LIST
100715: PUSH
100716: LD_INT 4
100718: NEG
100719: PUSH
100720: LD_INT 1
100722: NEG
100723: PUSH
100724: EMPTY
100725: LIST
100726: LIST
100727: PUSH
100728: LD_INT 3
100730: NEG
100731: PUSH
100732: LD_INT 0
100734: PUSH
100735: EMPTY
100736: LIST
100737: LIST
100738: PUSH
100739: LD_INT 3
100741: NEG
100742: PUSH
100743: LD_INT 1
100745: PUSH
100746: EMPTY
100747: LIST
100748: LIST
100749: PUSH
100750: LD_INT 4
100752: NEG
100753: PUSH
100754: LD_INT 1
100756: PUSH
100757: EMPTY
100758: LIST
100759: LIST
100760: PUSH
100761: LD_INT 5
100763: NEG
100764: PUSH
100765: LD_INT 0
100767: PUSH
100768: EMPTY
100769: LIST
100770: LIST
100771: PUSH
100772: LD_INT 5
100774: NEG
100775: PUSH
100776: LD_INT 1
100778: NEG
100779: PUSH
100780: EMPTY
100781: LIST
100782: LIST
100783: PUSH
100784: LD_INT 5
100786: NEG
100787: PUSH
100788: LD_INT 2
100790: NEG
100791: PUSH
100792: EMPTY
100793: LIST
100794: LIST
100795: PUSH
100796: LD_INT 3
100798: NEG
100799: PUSH
100800: LD_INT 2
100802: PUSH
100803: EMPTY
100804: LIST
100805: LIST
100806: PUSH
100807: LD_INT 3
100809: NEG
100810: PUSH
100811: LD_INT 3
100813: NEG
100814: PUSH
100815: EMPTY
100816: LIST
100817: LIST
100818: PUSH
100819: LD_INT 3
100821: NEG
100822: PUSH
100823: LD_INT 4
100825: NEG
100826: PUSH
100827: EMPTY
100828: LIST
100829: LIST
100830: PUSH
100831: LD_INT 2
100833: NEG
100834: PUSH
100835: LD_INT 3
100837: NEG
100838: PUSH
100839: EMPTY
100840: LIST
100841: LIST
100842: PUSH
100843: LD_INT 2
100845: NEG
100846: PUSH
100847: LD_INT 2
100849: NEG
100850: PUSH
100851: EMPTY
100852: LIST
100853: LIST
100854: PUSH
100855: LD_INT 3
100857: NEG
100858: PUSH
100859: LD_INT 2
100861: NEG
100862: PUSH
100863: EMPTY
100864: LIST
100865: LIST
100866: PUSH
100867: LD_INT 4
100869: NEG
100870: PUSH
100871: LD_INT 3
100873: NEG
100874: PUSH
100875: EMPTY
100876: LIST
100877: LIST
100878: PUSH
100879: LD_INT 4
100881: NEG
100882: PUSH
100883: LD_INT 4
100885: NEG
100886: PUSH
100887: EMPTY
100888: LIST
100889: LIST
100890: PUSH
100891: LD_INT 2
100893: NEG
100894: PUSH
100895: LD_INT 4
100897: NEG
100898: PUSH
100899: EMPTY
100900: LIST
100901: LIST
100902: PUSH
100903: LD_INT 4
100905: NEG
100906: PUSH
100907: LD_INT 2
100909: NEG
100910: PUSH
100911: EMPTY
100912: LIST
100913: LIST
100914: PUSH
100915: LD_INT 0
100917: PUSH
100918: LD_INT 4
100920: NEG
100921: PUSH
100922: EMPTY
100923: LIST
100924: LIST
100925: PUSH
100926: LD_INT 0
100928: PUSH
100929: LD_INT 5
100931: NEG
100932: PUSH
100933: EMPTY
100934: LIST
100935: LIST
100936: PUSH
100937: LD_INT 1
100939: PUSH
100940: LD_INT 4
100942: NEG
100943: PUSH
100944: EMPTY
100945: LIST
100946: LIST
100947: PUSH
100948: LD_INT 1
100950: PUSH
100951: LD_INT 3
100953: NEG
100954: PUSH
100955: EMPTY
100956: LIST
100957: LIST
100958: PUSH
100959: LD_INT 0
100961: PUSH
100962: LD_INT 3
100964: NEG
100965: PUSH
100966: EMPTY
100967: LIST
100968: LIST
100969: PUSH
100970: LD_INT 1
100972: NEG
100973: PUSH
100974: LD_INT 4
100976: NEG
100977: PUSH
100978: EMPTY
100979: LIST
100980: LIST
100981: PUSH
100982: LD_INT 1
100984: NEG
100985: PUSH
100986: LD_INT 5
100988: NEG
100989: PUSH
100990: EMPTY
100991: LIST
100992: LIST
100993: PUSH
100994: LD_INT 2
100996: PUSH
100997: LD_INT 3
100999: NEG
101000: PUSH
101001: EMPTY
101002: LIST
101003: LIST
101004: PUSH
101005: LD_INT 2
101007: NEG
101008: PUSH
101009: LD_INT 5
101011: NEG
101012: PUSH
101013: EMPTY
101014: LIST
101015: LIST
101016: PUSH
101017: EMPTY
101018: LIST
101019: LIST
101020: LIST
101021: LIST
101022: LIST
101023: LIST
101024: LIST
101025: LIST
101026: LIST
101027: LIST
101028: LIST
101029: LIST
101030: LIST
101031: LIST
101032: LIST
101033: LIST
101034: LIST
101035: LIST
101036: LIST
101037: LIST
101038: LIST
101039: LIST
101040: LIST
101041: LIST
101042: LIST
101043: LIST
101044: LIST
101045: LIST
101046: LIST
101047: LIST
101048: LIST
101049: LIST
101050: LIST
101051: LIST
101052: LIST
101053: LIST
101054: LIST
101055: LIST
101056: LIST
101057: LIST
101058: LIST
101059: LIST
101060: LIST
101061: LIST
101062: LIST
101063: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
101064: LD_ADDR_VAR 0 31
101068: PUSH
101069: LD_INT 0
101071: PUSH
101072: LD_INT 4
101074: PUSH
101075: EMPTY
101076: LIST
101077: LIST
101078: PUSH
101079: LD_INT 0
101081: PUSH
101082: LD_INT 3
101084: PUSH
101085: EMPTY
101086: LIST
101087: LIST
101088: PUSH
101089: LD_INT 1
101091: PUSH
101092: LD_INT 4
101094: PUSH
101095: EMPTY
101096: LIST
101097: LIST
101098: PUSH
101099: LD_INT 1
101101: PUSH
101102: LD_INT 5
101104: PUSH
101105: EMPTY
101106: LIST
101107: LIST
101108: PUSH
101109: LD_INT 0
101111: PUSH
101112: LD_INT 5
101114: PUSH
101115: EMPTY
101116: LIST
101117: LIST
101118: PUSH
101119: LD_INT 1
101121: NEG
101122: PUSH
101123: LD_INT 4
101125: PUSH
101126: EMPTY
101127: LIST
101128: LIST
101129: PUSH
101130: LD_INT 1
101132: NEG
101133: PUSH
101134: LD_INT 3
101136: PUSH
101137: EMPTY
101138: LIST
101139: LIST
101140: PUSH
101141: LD_INT 2
101143: PUSH
101144: LD_INT 5
101146: PUSH
101147: EMPTY
101148: LIST
101149: LIST
101150: PUSH
101151: LD_INT 2
101153: NEG
101154: PUSH
101155: LD_INT 3
101157: PUSH
101158: EMPTY
101159: LIST
101160: LIST
101161: PUSH
101162: LD_INT 3
101164: NEG
101165: PUSH
101166: LD_INT 0
101168: PUSH
101169: EMPTY
101170: LIST
101171: LIST
101172: PUSH
101173: LD_INT 3
101175: NEG
101176: PUSH
101177: LD_INT 1
101179: NEG
101180: PUSH
101181: EMPTY
101182: LIST
101183: LIST
101184: PUSH
101185: LD_INT 2
101187: NEG
101188: PUSH
101189: LD_INT 0
101191: PUSH
101192: EMPTY
101193: LIST
101194: LIST
101195: PUSH
101196: LD_INT 2
101198: NEG
101199: PUSH
101200: LD_INT 1
101202: PUSH
101203: EMPTY
101204: LIST
101205: LIST
101206: PUSH
101207: LD_INT 3
101209: NEG
101210: PUSH
101211: LD_INT 1
101213: PUSH
101214: EMPTY
101215: LIST
101216: LIST
101217: PUSH
101218: LD_INT 4
101220: NEG
101221: PUSH
101222: LD_INT 0
101224: PUSH
101225: EMPTY
101226: LIST
101227: LIST
101228: PUSH
101229: LD_INT 4
101231: NEG
101232: PUSH
101233: LD_INT 1
101235: NEG
101236: PUSH
101237: EMPTY
101238: LIST
101239: LIST
101240: PUSH
101241: LD_INT 4
101243: NEG
101244: PUSH
101245: LD_INT 2
101247: NEG
101248: PUSH
101249: EMPTY
101250: LIST
101251: LIST
101252: PUSH
101253: LD_INT 2
101255: NEG
101256: PUSH
101257: LD_INT 2
101259: PUSH
101260: EMPTY
101261: LIST
101262: LIST
101263: PUSH
101264: LD_INT 4
101266: NEG
101267: PUSH
101268: LD_INT 4
101270: NEG
101271: PUSH
101272: EMPTY
101273: LIST
101274: LIST
101275: PUSH
101276: LD_INT 4
101278: NEG
101279: PUSH
101280: LD_INT 5
101282: NEG
101283: PUSH
101284: EMPTY
101285: LIST
101286: LIST
101287: PUSH
101288: LD_INT 3
101290: NEG
101291: PUSH
101292: LD_INT 4
101294: NEG
101295: PUSH
101296: EMPTY
101297: LIST
101298: LIST
101299: PUSH
101300: LD_INT 3
101302: NEG
101303: PUSH
101304: LD_INT 3
101306: NEG
101307: PUSH
101308: EMPTY
101309: LIST
101310: LIST
101311: PUSH
101312: LD_INT 4
101314: NEG
101315: PUSH
101316: LD_INT 3
101318: NEG
101319: PUSH
101320: EMPTY
101321: LIST
101322: LIST
101323: PUSH
101324: LD_INT 5
101326: NEG
101327: PUSH
101328: LD_INT 4
101330: NEG
101331: PUSH
101332: EMPTY
101333: LIST
101334: LIST
101335: PUSH
101336: LD_INT 5
101338: NEG
101339: PUSH
101340: LD_INT 5
101342: NEG
101343: PUSH
101344: EMPTY
101345: LIST
101346: LIST
101347: PUSH
101348: LD_INT 3
101350: NEG
101351: PUSH
101352: LD_INT 5
101354: NEG
101355: PUSH
101356: EMPTY
101357: LIST
101358: LIST
101359: PUSH
101360: LD_INT 5
101362: NEG
101363: PUSH
101364: LD_INT 3
101366: NEG
101367: PUSH
101368: EMPTY
101369: LIST
101370: LIST
101371: PUSH
101372: LD_INT 0
101374: PUSH
101375: LD_INT 3
101377: NEG
101378: PUSH
101379: EMPTY
101380: LIST
101381: LIST
101382: PUSH
101383: LD_INT 0
101385: PUSH
101386: LD_INT 4
101388: NEG
101389: PUSH
101390: EMPTY
101391: LIST
101392: LIST
101393: PUSH
101394: LD_INT 1
101396: PUSH
101397: LD_INT 3
101399: NEG
101400: PUSH
101401: EMPTY
101402: LIST
101403: LIST
101404: PUSH
101405: LD_INT 1
101407: PUSH
101408: LD_INT 2
101410: NEG
101411: PUSH
101412: EMPTY
101413: LIST
101414: LIST
101415: PUSH
101416: LD_INT 0
101418: PUSH
101419: LD_INT 2
101421: NEG
101422: PUSH
101423: EMPTY
101424: LIST
101425: LIST
101426: PUSH
101427: LD_INT 1
101429: NEG
101430: PUSH
101431: LD_INT 3
101433: NEG
101434: PUSH
101435: EMPTY
101436: LIST
101437: LIST
101438: PUSH
101439: LD_INT 1
101441: NEG
101442: PUSH
101443: LD_INT 4
101445: NEG
101446: PUSH
101447: EMPTY
101448: LIST
101449: LIST
101450: PUSH
101451: LD_INT 2
101453: PUSH
101454: LD_INT 2
101456: NEG
101457: PUSH
101458: EMPTY
101459: LIST
101460: LIST
101461: PUSH
101462: LD_INT 2
101464: NEG
101465: PUSH
101466: LD_INT 4
101468: NEG
101469: PUSH
101470: EMPTY
101471: LIST
101472: LIST
101473: PUSH
101474: LD_INT 4
101476: PUSH
101477: LD_INT 0
101479: PUSH
101480: EMPTY
101481: LIST
101482: LIST
101483: PUSH
101484: LD_INT 4
101486: PUSH
101487: LD_INT 1
101489: NEG
101490: PUSH
101491: EMPTY
101492: LIST
101493: LIST
101494: PUSH
101495: LD_INT 5
101497: PUSH
101498: LD_INT 0
101500: PUSH
101501: EMPTY
101502: LIST
101503: LIST
101504: PUSH
101505: LD_INT 5
101507: PUSH
101508: LD_INT 1
101510: PUSH
101511: EMPTY
101512: LIST
101513: LIST
101514: PUSH
101515: LD_INT 4
101517: PUSH
101518: LD_INT 1
101520: PUSH
101521: EMPTY
101522: LIST
101523: LIST
101524: PUSH
101525: LD_INT 3
101527: PUSH
101528: LD_INT 0
101530: PUSH
101531: EMPTY
101532: LIST
101533: LIST
101534: PUSH
101535: LD_INT 3
101537: PUSH
101538: LD_INT 1
101540: NEG
101541: PUSH
101542: EMPTY
101543: LIST
101544: LIST
101545: PUSH
101546: LD_INT 3
101548: PUSH
101549: LD_INT 2
101551: NEG
101552: PUSH
101553: EMPTY
101554: LIST
101555: LIST
101556: PUSH
101557: LD_INT 5
101559: PUSH
101560: LD_INT 2
101562: PUSH
101563: EMPTY
101564: LIST
101565: LIST
101566: PUSH
101567: EMPTY
101568: LIST
101569: LIST
101570: LIST
101571: LIST
101572: LIST
101573: LIST
101574: LIST
101575: LIST
101576: LIST
101577: LIST
101578: LIST
101579: LIST
101580: LIST
101581: LIST
101582: LIST
101583: LIST
101584: LIST
101585: LIST
101586: LIST
101587: LIST
101588: LIST
101589: LIST
101590: LIST
101591: LIST
101592: LIST
101593: LIST
101594: LIST
101595: LIST
101596: LIST
101597: LIST
101598: LIST
101599: LIST
101600: LIST
101601: LIST
101602: LIST
101603: LIST
101604: LIST
101605: LIST
101606: LIST
101607: LIST
101608: LIST
101609: LIST
101610: LIST
101611: LIST
101612: LIST
101613: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
101614: LD_ADDR_VAR 0 32
101618: PUSH
101619: LD_INT 4
101621: NEG
101622: PUSH
101623: LD_INT 0
101625: PUSH
101626: EMPTY
101627: LIST
101628: LIST
101629: PUSH
101630: LD_INT 4
101632: NEG
101633: PUSH
101634: LD_INT 1
101636: NEG
101637: PUSH
101638: EMPTY
101639: LIST
101640: LIST
101641: PUSH
101642: LD_INT 3
101644: NEG
101645: PUSH
101646: LD_INT 0
101648: PUSH
101649: EMPTY
101650: LIST
101651: LIST
101652: PUSH
101653: LD_INT 3
101655: NEG
101656: PUSH
101657: LD_INT 1
101659: PUSH
101660: EMPTY
101661: LIST
101662: LIST
101663: PUSH
101664: LD_INT 4
101666: NEG
101667: PUSH
101668: LD_INT 1
101670: PUSH
101671: EMPTY
101672: LIST
101673: LIST
101674: PUSH
101675: LD_INT 5
101677: NEG
101678: PUSH
101679: LD_INT 0
101681: PUSH
101682: EMPTY
101683: LIST
101684: LIST
101685: PUSH
101686: LD_INT 5
101688: NEG
101689: PUSH
101690: LD_INT 1
101692: NEG
101693: PUSH
101694: EMPTY
101695: LIST
101696: LIST
101697: PUSH
101698: LD_INT 5
101700: NEG
101701: PUSH
101702: LD_INT 2
101704: NEG
101705: PUSH
101706: EMPTY
101707: LIST
101708: LIST
101709: PUSH
101710: LD_INT 3
101712: NEG
101713: PUSH
101714: LD_INT 2
101716: PUSH
101717: EMPTY
101718: LIST
101719: LIST
101720: PUSH
101721: LD_INT 3
101723: NEG
101724: PUSH
101725: LD_INT 3
101727: NEG
101728: PUSH
101729: EMPTY
101730: LIST
101731: LIST
101732: PUSH
101733: LD_INT 3
101735: NEG
101736: PUSH
101737: LD_INT 4
101739: NEG
101740: PUSH
101741: EMPTY
101742: LIST
101743: LIST
101744: PUSH
101745: LD_INT 2
101747: NEG
101748: PUSH
101749: LD_INT 3
101751: NEG
101752: PUSH
101753: EMPTY
101754: LIST
101755: LIST
101756: PUSH
101757: LD_INT 2
101759: NEG
101760: PUSH
101761: LD_INT 2
101763: NEG
101764: PUSH
101765: EMPTY
101766: LIST
101767: LIST
101768: PUSH
101769: LD_INT 3
101771: NEG
101772: PUSH
101773: LD_INT 2
101775: NEG
101776: PUSH
101777: EMPTY
101778: LIST
101779: LIST
101780: PUSH
101781: LD_INT 4
101783: NEG
101784: PUSH
101785: LD_INT 3
101787: NEG
101788: PUSH
101789: EMPTY
101790: LIST
101791: LIST
101792: PUSH
101793: LD_INT 4
101795: NEG
101796: PUSH
101797: LD_INT 4
101799: NEG
101800: PUSH
101801: EMPTY
101802: LIST
101803: LIST
101804: PUSH
101805: LD_INT 2
101807: NEG
101808: PUSH
101809: LD_INT 4
101811: NEG
101812: PUSH
101813: EMPTY
101814: LIST
101815: LIST
101816: PUSH
101817: LD_INT 4
101819: NEG
101820: PUSH
101821: LD_INT 2
101823: NEG
101824: PUSH
101825: EMPTY
101826: LIST
101827: LIST
101828: PUSH
101829: LD_INT 0
101831: PUSH
101832: LD_INT 4
101834: NEG
101835: PUSH
101836: EMPTY
101837: LIST
101838: LIST
101839: PUSH
101840: LD_INT 0
101842: PUSH
101843: LD_INT 5
101845: NEG
101846: PUSH
101847: EMPTY
101848: LIST
101849: LIST
101850: PUSH
101851: LD_INT 1
101853: PUSH
101854: LD_INT 4
101856: NEG
101857: PUSH
101858: EMPTY
101859: LIST
101860: LIST
101861: PUSH
101862: LD_INT 1
101864: PUSH
101865: LD_INT 3
101867: NEG
101868: PUSH
101869: EMPTY
101870: LIST
101871: LIST
101872: PUSH
101873: LD_INT 0
101875: PUSH
101876: LD_INT 3
101878: NEG
101879: PUSH
101880: EMPTY
101881: LIST
101882: LIST
101883: PUSH
101884: LD_INT 1
101886: NEG
101887: PUSH
101888: LD_INT 4
101890: NEG
101891: PUSH
101892: EMPTY
101893: LIST
101894: LIST
101895: PUSH
101896: LD_INT 1
101898: NEG
101899: PUSH
101900: LD_INT 5
101902: NEG
101903: PUSH
101904: EMPTY
101905: LIST
101906: LIST
101907: PUSH
101908: LD_INT 2
101910: PUSH
101911: LD_INT 3
101913: NEG
101914: PUSH
101915: EMPTY
101916: LIST
101917: LIST
101918: PUSH
101919: LD_INT 2
101921: NEG
101922: PUSH
101923: LD_INT 5
101925: NEG
101926: PUSH
101927: EMPTY
101928: LIST
101929: LIST
101930: PUSH
101931: LD_INT 3
101933: PUSH
101934: LD_INT 0
101936: PUSH
101937: EMPTY
101938: LIST
101939: LIST
101940: PUSH
101941: LD_INT 3
101943: PUSH
101944: LD_INT 1
101946: NEG
101947: PUSH
101948: EMPTY
101949: LIST
101950: LIST
101951: PUSH
101952: LD_INT 4
101954: PUSH
101955: LD_INT 0
101957: PUSH
101958: EMPTY
101959: LIST
101960: LIST
101961: PUSH
101962: LD_INT 4
101964: PUSH
101965: LD_INT 1
101967: PUSH
101968: EMPTY
101969: LIST
101970: LIST
101971: PUSH
101972: LD_INT 3
101974: PUSH
101975: LD_INT 1
101977: PUSH
101978: EMPTY
101979: LIST
101980: LIST
101981: PUSH
101982: LD_INT 2
101984: PUSH
101985: LD_INT 0
101987: PUSH
101988: EMPTY
101989: LIST
101990: LIST
101991: PUSH
101992: LD_INT 2
101994: PUSH
101995: LD_INT 1
101997: NEG
101998: PUSH
101999: EMPTY
102000: LIST
102001: LIST
102002: PUSH
102003: LD_INT 2
102005: PUSH
102006: LD_INT 2
102008: NEG
102009: PUSH
102010: EMPTY
102011: LIST
102012: LIST
102013: PUSH
102014: LD_INT 4
102016: PUSH
102017: LD_INT 2
102019: PUSH
102020: EMPTY
102021: LIST
102022: LIST
102023: PUSH
102024: LD_INT 4
102026: PUSH
102027: LD_INT 4
102029: PUSH
102030: EMPTY
102031: LIST
102032: LIST
102033: PUSH
102034: LD_INT 4
102036: PUSH
102037: LD_INT 3
102039: PUSH
102040: EMPTY
102041: LIST
102042: LIST
102043: PUSH
102044: LD_INT 5
102046: PUSH
102047: LD_INT 4
102049: PUSH
102050: EMPTY
102051: LIST
102052: LIST
102053: PUSH
102054: LD_INT 5
102056: PUSH
102057: LD_INT 5
102059: PUSH
102060: EMPTY
102061: LIST
102062: LIST
102063: PUSH
102064: LD_INT 4
102066: PUSH
102067: LD_INT 5
102069: PUSH
102070: EMPTY
102071: LIST
102072: LIST
102073: PUSH
102074: LD_INT 3
102076: PUSH
102077: LD_INT 4
102079: PUSH
102080: EMPTY
102081: LIST
102082: LIST
102083: PUSH
102084: LD_INT 3
102086: PUSH
102087: LD_INT 3
102089: PUSH
102090: EMPTY
102091: LIST
102092: LIST
102093: PUSH
102094: LD_INT 5
102096: PUSH
102097: LD_INT 3
102099: PUSH
102100: EMPTY
102101: LIST
102102: LIST
102103: PUSH
102104: LD_INT 3
102106: PUSH
102107: LD_INT 5
102109: PUSH
102110: EMPTY
102111: LIST
102112: LIST
102113: PUSH
102114: EMPTY
102115: LIST
102116: LIST
102117: LIST
102118: LIST
102119: LIST
102120: LIST
102121: LIST
102122: LIST
102123: LIST
102124: LIST
102125: LIST
102126: LIST
102127: LIST
102128: LIST
102129: LIST
102130: LIST
102131: LIST
102132: LIST
102133: LIST
102134: LIST
102135: LIST
102136: LIST
102137: LIST
102138: LIST
102139: LIST
102140: LIST
102141: LIST
102142: LIST
102143: LIST
102144: LIST
102145: LIST
102146: LIST
102147: LIST
102148: LIST
102149: LIST
102150: LIST
102151: LIST
102152: LIST
102153: LIST
102154: LIST
102155: LIST
102156: LIST
102157: LIST
102158: LIST
102159: LIST
102160: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
102161: LD_ADDR_VAR 0 33
102165: PUSH
102166: LD_INT 4
102168: NEG
102169: PUSH
102170: LD_INT 4
102172: NEG
102173: PUSH
102174: EMPTY
102175: LIST
102176: LIST
102177: PUSH
102178: LD_INT 4
102180: NEG
102181: PUSH
102182: LD_INT 5
102184: NEG
102185: PUSH
102186: EMPTY
102187: LIST
102188: LIST
102189: PUSH
102190: LD_INT 3
102192: NEG
102193: PUSH
102194: LD_INT 4
102196: NEG
102197: PUSH
102198: EMPTY
102199: LIST
102200: LIST
102201: PUSH
102202: LD_INT 3
102204: NEG
102205: PUSH
102206: LD_INT 3
102208: NEG
102209: PUSH
102210: EMPTY
102211: LIST
102212: LIST
102213: PUSH
102214: LD_INT 4
102216: NEG
102217: PUSH
102218: LD_INT 3
102220: NEG
102221: PUSH
102222: EMPTY
102223: LIST
102224: LIST
102225: PUSH
102226: LD_INT 5
102228: NEG
102229: PUSH
102230: LD_INT 4
102232: NEG
102233: PUSH
102234: EMPTY
102235: LIST
102236: LIST
102237: PUSH
102238: LD_INT 5
102240: NEG
102241: PUSH
102242: LD_INT 5
102244: NEG
102245: PUSH
102246: EMPTY
102247: LIST
102248: LIST
102249: PUSH
102250: LD_INT 3
102252: NEG
102253: PUSH
102254: LD_INT 5
102256: NEG
102257: PUSH
102258: EMPTY
102259: LIST
102260: LIST
102261: PUSH
102262: LD_INT 5
102264: NEG
102265: PUSH
102266: LD_INT 3
102268: NEG
102269: PUSH
102270: EMPTY
102271: LIST
102272: LIST
102273: PUSH
102274: LD_INT 0
102276: PUSH
102277: LD_INT 3
102279: NEG
102280: PUSH
102281: EMPTY
102282: LIST
102283: LIST
102284: PUSH
102285: LD_INT 0
102287: PUSH
102288: LD_INT 4
102290: NEG
102291: PUSH
102292: EMPTY
102293: LIST
102294: LIST
102295: PUSH
102296: LD_INT 1
102298: PUSH
102299: LD_INT 3
102301: NEG
102302: PUSH
102303: EMPTY
102304: LIST
102305: LIST
102306: PUSH
102307: LD_INT 1
102309: PUSH
102310: LD_INT 2
102312: NEG
102313: PUSH
102314: EMPTY
102315: LIST
102316: LIST
102317: PUSH
102318: LD_INT 0
102320: PUSH
102321: LD_INT 2
102323: NEG
102324: PUSH
102325: EMPTY
102326: LIST
102327: LIST
102328: PUSH
102329: LD_INT 1
102331: NEG
102332: PUSH
102333: LD_INT 3
102335: NEG
102336: PUSH
102337: EMPTY
102338: LIST
102339: LIST
102340: PUSH
102341: LD_INT 1
102343: NEG
102344: PUSH
102345: LD_INT 4
102347: NEG
102348: PUSH
102349: EMPTY
102350: LIST
102351: LIST
102352: PUSH
102353: LD_INT 2
102355: PUSH
102356: LD_INT 2
102358: NEG
102359: PUSH
102360: EMPTY
102361: LIST
102362: LIST
102363: PUSH
102364: LD_INT 2
102366: NEG
102367: PUSH
102368: LD_INT 4
102370: NEG
102371: PUSH
102372: EMPTY
102373: LIST
102374: LIST
102375: PUSH
102376: LD_INT 4
102378: PUSH
102379: LD_INT 0
102381: PUSH
102382: EMPTY
102383: LIST
102384: LIST
102385: PUSH
102386: LD_INT 4
102388: PUSH
102389: LD_INT 1
102391: NEG
102392: PUSH
102393: EMPTY
102394: LIST
102395: LIST
102396: PUSH
102397: LD_INT 5
102399: PUSH
102400: LD_INT 0
102402: PUSH
102403: EMPTY
102404: LIST
102405: LIST
102406: PUSH
102407: LD_INT 5
102409: PUSH
102410: LD_INT 1
102412: PUSH
102413: EMPTY
102414: LIST
102415: LIST
102416: PUSH
102417: LD_INT 4
102419: PUSH
102420: LD_INT 1
102422: PUSH
102423: EMPTY
102424: LIST
102425: LIST
102426: PUSH
102427: LD_INT 3
102429: PUSH
102430: LD_INT 0
102432: PUSH
102433: EMPTY
102434: LIST
102435: LIST
102436: PUSH
102437: LD_INT 3
102439: PUSH
102440: LD_INT 1
102442: NEG
102443: PUSH
102444: EMPTY
102445: LIST
102446: LIST
102447: PUSH
102448: LD_INT 3
102450: PUSH
102451: LD_INT 2
102453: NEG
102454: PUSH
102455: EMPTY
102456: LIST
102457: LIST
102458: PUSH
102459: LD_INT 5
102461: PUSH
102462: LD_INT 2
102464: PUSH
102465: EMPTY
102466: LIST
102467: LIST
102468: PUSH
102469: LD_INT 3
102471: PUSH
102472: LD_INT 3
102474: PUSH
102475: EMPTY
102476: LIST
102477: LIST
102478: PUSH
102479: LD_INT 3
102481: PUSH
102482: LD_INT 2
102484: PUSH
102485: EMPTY
102486: LIST
102487: LIST
102488: PUSH
102489: LD_INT 4
102491: PUSH
102492: LD_INT 3
102494: PUSH
102495: EMPTY
102496: LIST
102497: LIST
102498: PUSH
102499: LD_INT 4
102501: PUSH
102502: LD_INT 4
102504: PUSH
102505: EMPTY
102506: LIST
102507: LIST
102508: PUSH
102509: LD_INT 3
102511: PUSH
102512: LD_INT 4
102514: PUSH
102515: EMPTY
102516: LIST
102517: LIST
102518: PUSH
102519: LD_INT 2
102521: PUSH
102522: LD_INT 3
102524: PUSH
102525: EMPTY
102526: LIST
102527: LIST
102528: PUSH
102529: LD_INT 2
102531: PUSH
102532: LD_INT 2
102534: PUSH
102535: EMPTY
102536: LIST
102537: LIST
102538: PUSH
102539: LD_INT 4
102541: PUSH
102542: LD_INT 2
102544: PUSH
102545: EMPTY
102546: LIST
102547: LIST
102548: PUSH
102549: LD_INT 2
102551: PUSH
102552: LD_INT 4
102554: PUSH
102555: EMPTY
102556: LIST
102557: LIST
102558: PUSH
102559: LD_INT 0
102561: PUSH
102562: LD_INT 4
102564: PUSH
102565: EMPTY
102566: LIST
102567: LIST
102568: PUSH
102569: LD_INT 0
102571: PUSH
102572: LD_INT 3
102574: PUSH
102575: EMPTY
102576: LIST
102577: LIST
102578: PUSH
102579: LD_INT 1
102581: PUSH
102582: LD_INT 4
102584: PUSH
102585: EMPTY
102586: LIST
102587: LIST
102588: PUSH
102589: LD_INT 1
102591: PUSH
102592: LD_INT 5
102594: PUSH
102595: EMPTY
102596: LIST
102597: LIST
102598: PUSH
102599: LD_INT 0
102601: PUSH
102602: LD_INT 5
102604: PUSH
102605: EMPTY
102606: LIST
102607: LIST
102608: PUSH
102609: LD_INT 1
102611: NEG
102612: PUSH
102613: LD_INT 4
102615: PUSH
102616: EMPTY
102617: LIST
102618: LIST
102619: PUSH
102620: LD_INT 1
102622: NEG
102623: PUSH
102624: LD_INT 3
102626: PUSH
102627: EMPTY
102628: LIST
102629: LIST
102630: PUSH
102631: LD_INT 2
102633: PUSH
102634: LD_INT 5
102636: PUSH
102637: EMPTY
102638: LIST
102639: LIST
102640: PUSH
102641: LD_INT 2
102643: NEG
102644: PUSH
102645: LD_INT 3
102647: PUSH
102648: EMPTY
102649: LIST
102650: LIST
102651: PUSH
102652: EMPTY
102653: LIST
102654: LIST
102655: LIST
102656: LIST
102657: LIST
102658: LIST
102659: LIST
102660: LIST
102661: LIST
102662: LIST
102663: LIST
102664: LIST
102665: LIST
102666: LIST
102667: LIST
102668: LIST
102669: LIST
102670: LIST
102671: LIST
102672: LIST
102673: LIST
102674: LIST
102675: LIST
102676: LIST
102677: LIST
102678: LIST
102679: LIST
102680: LIST
102681: LIST
102682: LIST
102683: LIST
102684: LIST
102685: LIST
102686: LIST
102687: LIST
102688: LIST
102689: LIST
102690: LIST
102691: LIST
102692: LIST
102693: LIST
102694: LIST
102695: LIST
102696: LIST
102697: LIST
102698: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
102699: LD_ADDR_VAR 0 34
102703: PUSH
102704: LD_INT 0
102706: PUSH
102707: LD_INT 4
102709: NEG
102710: PUSH
102711: EMPTY
102712: LIST
102713: LIST
102714: PUSH
102715: LD_INT 0
102717: PUSH
102718: LD_INT 5
102720: NEG
102721: PUSH
102722: EMPTY
102723: LIST
102724: LIST
102725: PUSH
102726: LD_INT 1
102728: PUSH
102729: LD_INT 4
102731: NEG
102732: PUSH
102733: EMPTY
102734: LIST
102735: LIST
102736: PUSH
102737: LD_INT 1
102739: PUSH
102740: LD_INT 3
102742: NEG
102743: PUSH
102744: EMPTY
102745: LIST
102746: LIST
102747: PUSH
102748: LD_INT 0
102750: PUSH
102751: LD_INT 3
102753: NEG
102754: PUSH
102755: EMPTY
102756: LIST
102757: LIST
102758: PUSH
102759: LD_INT 1
102761: NEG
102762: PUSH
102763: LD_INT 4
102765: NEG
102766: PUSH
102767: EMPTY
102768: LIST
102769: LIST
102770: PUSH
102771: LD_INT 1
102773: NEG
102774: PUSH
102775: LD_INT 5
102777: NEG
102778: PUSH
102779: EMPTY
102780: LIST
102781: LIST
102782: PUSH
102783: LD_INT 2
102785: PUSH
102786: LD_INT 3
102788: NEG
102789: PUSH
102790: EMPTY
102791: LIST
102792: LIST
102793: PUSH
102794: LD_INT 2
102796: NEG
102797: PUSH
102798: LD_INT 5
102800: NEG
102801: PUSH
102802: EMPTY
102803: LIST
102804: LIST
102805: PUSH
102806: LD_INT 3
102808: PUSH
102809: LD_INT 0
102811: PUSH
102812: EMPTY
102813: LIST
102814: LIST
102815: PUSH
102816: LD_INT 3
102818: PUSH
102819: LD_INT 1
102821: NEG
102822: PUSH
102823: EMPTY
102824: LIST
102825: LIST
102826: PUSH
102827: LD_INT 4
102829: PUSH
102830: LD_INT 0
102832: PUSH
102833: EMPTY
102834: LIST
102835: LIST
102836: PUSH
102837: LD_INT 4
102839: PUSH
102840: LD_INT 1
102842: PUSH
102843: EMPTY
102844: LIST
102845: LIST
102846: PUSH
102847: LD_INT 3
102849: PUSH
102850: LD_INT 1
102852: PUSH
102853: EMPTY
102854: LIST
102855: LIST
102856: PUSH
102857: LD_INT 2
102859: PUSH
102860: LD_INT 0
102862: PUSH
102863: EMPTY
102864: LIST
102865: LIST
102866: PUSH
102867: LD_INT 2
102869: PUSH
102870: LD_INT 1
102872: NEG
102873: PUSH
102874: EMPTY
102875: LIST
102876: LIST
102877: PUSH
102878: LD_INT 2
102880: PUSH
102881: LD_INT 2
102883: NEG
102884: PUSH
102885: EMPTY
102886: LIST
102887: LIST
102888: PUSH
102889: LD_INT 4
102891: PUSH
102892: LD_INT 2
102894: PUSH
102895: EMPTY
102896: LIST
102897: LIST
102898: PUSH
102899: LD_INT 4
102901: PUSH
102902: LD_INT 4
102904: PUSH
102905: EMPTY
102906: LIST
102907: LIST
102908: PUSH
102909: LD_INT 4
102911: PUSH
102912: LD_INT 3
102914: PUSH
102915: EMPTY
102916: LIST
102917: LIST
102918: PUSH
102919: LD_INT 5
102921: PUSH
102922: LD_INT 4
102924: PUSH
102925: EMPTY
102926: LIST
102927: LIST
102928: PUSH
102929: LD_INT 5
102931: PUSH
102932: LD_INT 5
102934: PUSH
102935: EMPTY
102936: LIST
102937: LIST
102938: PUSH
102939: LD_INT 4
102941: PUSH
102942: LD_INT 5
102944: PUSH
102945: EMPTY
102946: LIST
102947: LIST
102948: PUSH
102949: LD_INT 3
102951: PUSH
102952: LD_INT 4
102954: PUSH
102955: EMPTY
102956: LIST
102957: LIST
102958: PUSH
102959: LD_INT 3
102961: PUSH
102962: LD_INT 3
102964: PUSH
102965: EMPTY
102966: LIST
102967: LIST
102968: PUSH
102969: LD_INT 5
102971: PUSH
102972: LD_INT 3
102974: PUSH
102975: EMPTY
102976: LIST
102977: LIST
102978: PUSH
102979: LD_INT 3
102981: PUSH
102982: LD_INT 5
102984: PUSH
102985: EMPTY
102986: LIST
102987: LIST
102988: PUSH
102989: LD_INT 0
102991: PUSH
102992: LD_INT 3
102994: PUSH
102995: EMPTY
102996: LIST
102997: LIST
102998: PUSH
102999: LD_INT 0
103001: PUSH
103002: LD_INT 2
103004: PUSH
103005: EMPTY
103006: LIST
103007: LIST
103008: PUSH
103009: LD_INT 1
103011: PUSH
103012: LD_INT 3
103014: PUSH
103015: EMPTY
103016: LIST
103017: LIST
103018: PUSH
103019: LD_INT 1
103021: PUSH
103022: LD_INT 4
103024: PUSH
103025: EMPTY
103026: LIST
103027: LIST
103028: PUSH
103029: LD_INT 0
103031: PUSH
103032: LD_INT 4
103034: PUSH
103035: EMPTY
103036: LIST
103037: LIST
103038: PUSH
103039: LD_INT 1
103041: NEG
103042: PUSH
103043: LD_INT 3
103045: PUSH
103046: EMPTY
103047: LIST
103048: LIST
103049: PUSH
103050: LD_INT 1
103052: NEG
103053: PUSH
103054: LD_INT 2
103056: PUSH
103057: EMPTY
103058: LIST
103059: LIST
103060: PUSH
103061: LD_INT 2
103063: PUSH
103064: LD_INT 4
103066: PUSH
103067: EMPTY
103068: LIST
103069: LIST
103070: PUSH
103071: LD_INT 2
103073: NEG
103074: PUSH
103075: LD_INT 2
103077: PUSH
103078: EMPTY
103079: LIST
103080: LIST
103081: PUSH
103082: LD_INT 4
103084: NEG
103085: PUSH
103086: LD_INT 0
103088: PUSH
103089: EMPTY
103090: LIST
103091: LIST
103092: PUSH
103093: LD_INT 4
103095: NEG
103096: PUSH
103097: LD_INT 1
103099: NEG
103100: PUSH
103101: EMPTY
103102: LIST
103103: LIST
103104: PUSH
103105: LD_INT 3
103107: NEG
103108: PUSH
103109: LD_INT 0
103111: PUSH
103112: EMPTY
103113: LIST
103114: LIST
103115: PUSH
103116: LD_INT 3
103118: NEG
103119: PUSH
103120: LD_INT 1
103122: PUSH
103123: EMPTY
103124: LIST
103125: LIST
103126: PUSH
103127: LD_INT 4
103129: NEG
103130: PUSH
103131: LD_INT 1
103133: PUSH
103134: EMPTY
103135: LIST
103136: LIST
103137: PUSH
103138: LD_INT 5
103140: NEG
103141: PUSH
103142: LD_INT 0
103144: PUSH
103145: EMPTY
103146: LIST
103147: LIST
103148: PUSH
103149: LD_INT 5
103151: NEG
103152: PUSH
103153: LD_INT 1
103155: NEG
103156: PUSH
103157: EMPTY
103158: LIST
103159: LIST
103160: PUSH
103161: LD_INT 5
103163: NEG
103164: PUSH
103165: LD_INT 2
103167: NEG
103168: PUSH
103169: EMPTY
103170: LIST
103171: LIST
103172: PUSH
103173: LD_INT 3
103175: NEG
103176: PUSH
103177: LD_INT 2
103179: PUSH
103180: EMPTY
103181: LIST
103182: LIST
103183: PUSH
103184: EMPTY
103185: LIST
103186: LIST
103187: LIST
103188: LIST
103189: LIST
103190: LIST
103191: LIST
103192: LIST
103193: LIST
103194: LIST
103195: LIST
103196: LIST
103197: LIST
103198: LIST
103199: LIST
103200: LIST
103201: LIST
103202: LIST
103203: LIST
103204: LIST
103205: LIST
103206: LIST
103207: LIST
103208: LIST
103209: LIST
103210: LIST
103211: LIST
103212: LIST
103213: LIST
103214: LIST
103215: LIST
103216: LIST
103217: LIST
103218: LIST
103219: LIST
103220: LIST
103221: LIST
103222: LIST
103223: LIST
103224: LIST
103225: LIST
103226: LIST
103227: LIST
103228: LIST
103229: LIST
103230: ST_TO_ADDR
// end ; end ;
103231: GO 103234
103233: POP
// case btype of b_depot , b_warehouse :
103234: LD_VAR 0 1
103238: PUSH
103239: LD_INT 0
103241: DOUBLE
103242: EQUAL
103243: IFTRUE 103253
103245: LD_INT 1
103247: DOUBLE
103248: EQUAL
103249: IFTRUE 103253
103251: GO 103454
103253: POP
// case nation of nation_american :
103254: LD_VAR 0 5
103258: PUSH
103259: LD_INT 1
103261: DOUBLE
103262: EQUAL
103263: IFTRUE 103267
103265: GO 103323
103267: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
103268: LD_ADDR_VAR 0 9
103272: PUSH
103273: LD_VAR 0 11
103277: PUSH
103278: LD_VAR 0 12
103282: PUSH
103283: LD_VAR 0 13
103287: PUSH
103288: LD_VAR 0 14
103292: PUSH
103293: LD_VAR 0 15
103297: PUSH
103298: LD_VAR 0 16
103302: PUSH
103303: EMPTY
103304: LIST
103305: LIST
103306: LIST
103307: LIST
103308: LIST
103309: LIST
103310: PUSH
103311: LD_VAR 0 4
103315: PUSH
103316: LD_INT 1
103318: PLUS
103319: ARRAY
103320: ST_TO_ADDR
103321: GO 103452
103323: LD_INT 2
103325: DOUBLE
103326: EQUAL
103327: IFTRUE 103331
103329: GO 103387
103331: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
103332: LD_ADDR_VAR 0 9
103336: PUSH
103337: LD_VAR 0 17
103341: PUSH
103342: LD_VAR 0 18
103346: PUSH
103347: LD_VAR 0 19
103351: PUSH
103352: LD_VAR 0 20
103356: PUSH
103357: LD_VAR 0 21
103361: PUSH
103362: LD_VAR 0 22
103366: PUSH
103367: EMPTY
103368: LIST
103369: LIST
103370: LIST
103371: LIST
103372: LIST
103373: LIST
103374: PUSH
103375: LD_VAR 0 4
103379: PUSH
103380: LD_INT 1
103382: PLUS
103383: ARRAY
103384: ST_TO_ADDR
103385: GO 103452
103387: LD_INT 3
103389: DOUBLE
103390: EQUAL
103391: IFTRUE 103395
103393: GO 103451
103395: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
103396: LD_ADDR_VAR 0 9
103400: PUSH
103401: LD_VAR 0 23
103405: PUSH
103406: LD_VAR 0 24
103410: PUSH
103411: LD_VAR 0 25
103415: PUSH
103416: LD_VAR 0 26
103420: PUSH
103421: LD_VAR 0 27
103425: PUSH
103426: LD_VAR 0 28
103430: PUSH
103431: EMPTY
103432: LIST
103433: LIST
103434: LIST
103435: LIST
103436: LIST
103437: LIST
103438: PUSH
103439: LD_VAR 0 4
103443: PUSH
103444: LD_INT 1
103446: PLUS
103447: ARRAY
103448: ST_TO_ADDR
103449: GO 103452
103451: POP
103452: GO 104007
103454: LD_INT 2
103456: DOUBLE
103457: EQUAL
103458: IFTRUE 103468
103460: LD_INT 3
103462: DOUBLE
103463: EQUAL
103464: IFTRUE 103468
103466: GO 103524
103468: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
103469: LD_ADDR_VAR 0 9
103473: PUSH
103474: LD_VAR 0 29
103478: PUSH
103479: LD_VAR 0 30
103483: PUSH
103484: LD_VAR 0 31
103488: PUSH
103489: LD_VAR 0 32
103493: PUSH
103494: LD_VAR 0 33
103498: PUSH
103499: LD_VAR 0 34
103503: PUSH
103504: EMPTY
103505: LIST
103506: LIST
103507: LIST
103508: LIST
103509: LIST
103510: LIST
103511: PUSH
103512: LD_VAR 0 4
103516: PUSH
103517: LD_INT 1
103519: PLUS
103520: ARRAY
103521: ST_TO_ADDR
103522: GO 104007
103524: LD_INT 16
103526: DOUBLE
103527: EQUAL
103528: IFTRUE 103586
103530: LD_INT 17
103532: DOUBLE
103533: EQUAL
103534: IFTRUE 103586
103536: LD_INT 18
103538: DOUBLE
103539: EQUAL
103540: IFTRUE 103586
103542: LD_INT 19
103544: DOUBLE
103545: EQUAL
103546: IFTRUE 103586
103548: LD_INT 22
103550: DOUBLE
103551: EQUAL
103552: IFTRUE 103586
103554: LD_INT 20
103556: DOUBLE
103557: EQUAL
103558: IFTRUE 103586
103560: LD_INT 21
103562: DOUBLE
103563: EQUAL
103564: IFTRUE 103586
103566: LD_INT 23
103568: DOUBLE
103569: EQUAL
103570: IFTRUE 103586
103572: LD_INT 24
103574: DOUBLE
103575: EQUAL
103576: IFTRUE 103586
103578: LD_INT 25
103580: DOUBLE
103581: EQUAL
103582: IFTRUE 103586
103584: GO 103642
103586: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
103587: LD_ADDR_VAR 0 9
103591: PUSH
103592: LD_VAR 0 35
103596: PUSH
103597: LD_VAR 0 36
103601: PUSH
103602: LD_VAR 0 37
103606: PUSH
103607: LD_VAR 0 38
103611: PUSH
103612: LD_VAR 0 39
103616: PUSH
103617: LD_VAR 0 40
103621: PUSH
103622: EMPTY
103623: LIST
103624: LIST
103625: LIST
103626: LIST
103627: LIST
103628: LIST
103629: PUSH
103630: LD_VAR 0 4
103634: PUSH
103635: LD_INT 1
103637: PLUS
103638: ARRAY
103639: ST_TO_ADDR
103640: GO 104007
103642: LD_INT 6
103644: DOUBLE
103645: EQUAL
103646: IFTRUE 103698
103648: LD_INT 7
103650: DOUBLE
103651: EQUAL
103652: IFTRUE 103698
103654: LD_INT 8
103656: DOUBLE
103657: EQUAL
103658: IFTRUE 103698
103660: LD_INT 13
103662: DOUBLE
103663: EQUAL
103664: IFTRUE 103698
103666: LD_INT 12
103668: DOUBLE
103669: EQUAL
103670: IFTRUE 103698
103672: LD_INT 15
103674: DOUBLE
103675: EQUAL
103676: IFTRUE 103698
103678: LD_INT 11
103680: DOUBLE
103681: EQUAL
103682: IFTRUE 103698
103684: LD_INT 14
103686: DOUBLE
103687: EQUAL
103688: IFTRUE 103698
103690: LD_INT 10
103692: DOUBLE
103693: EQUAL
103694: IFTRUE 103698
103696: GO 103754
103698: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
103699: LD_ADDR_VAR 0 9
103703: PUSH
103704: LD_VAR 0 41
103708: PUSH
103709: LD_VAR 0 42
103713: PUSH
103714: LD_VAR 0 43
103718: PUSH
103719: LD_VAR 0 44
103723: PUSH
103724: LD_VAR 0 45
103728: PUSH
103729: LD_VAR 0 46
103733: PUSH
103734: EMPTY
103735: LIST
103736: LIST
103737: LIST
103738: LIST
103739: LIST
103740: LIST
103741: PUSH
103742: LD_VAR 0 4
103746: PUSH
103747: LD_INT 1
103749: PLUS
103750: ARRAY
103751: ST_TO_ADDR
103752: GO 104007
103754: LD_INT 36
103756: DOUBLE
103757: EQUAL
103758: IFTRUE 103762
103760: GO 103818
103762: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
103763: LD_ADDR_VAR 0 9
103767: PUSH
103768: LD_VAR 0 47
103772: PUSH
103773: LD_VAR 0 48
103777: PUSH
103778: LD_VAR 0 49
103782: PUSH
103783: LD_VAR 0 50
103787: PUSH
103788: LD_VAR 0 51
103792: PUSH
103793: LD_VAR 0 52
103797: PUSH
103798: EMPTY
103799: LIST
103800: LIST
103801: LIST
103802: LIST
103803: LIST
103804: LIST
103805: PUSH
103806: LD_VAR 0 4
103810: PUSH
103811: LD_INT 1
103813: PLUS
103814: ARRAY
103815: ST_TO_ADDR
103816: GO 104007
103818: LD_INT 4
103820: DOUBLE
103821: EQUAL
103822: IFTRUE 103844
103824: LD_INT 5
103826: DOUBLE
103827: EQUAL
103828: IFTRUE 103844
103830: LD_INT 34
103832: DOUBLE
103833: EQUAL
103834: IFTRUE 103844
103836: LD_INT 37
103838: DOUBLE
103839: EQUAL
103840: IFTRUE 103844
103842: GO 103900
103844: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
103845: LD_ADDR_VAR 0 9
103849: PUSH
103850: LD_VAR 0 53
103854: PUSH
103855: LD_VAR 0 54
103859: PUSH
103860: LD_VAR 0 55
103864: PUSH
103865: LD_VAR 0 56
103869: PUSH
103870: LD_VAR 0 57
103874: PUSH
103875: LD_VAR 0 58
103879: PUSH
103880: EMPTY
103881: LIST
103882: LIST
103883: LIST
103884: LIST
103885: LIST
103886: LIST
103887: PUSH
103888: LD_VAR 0 4
103892: PUSH
103893: LD_INT 1
103895: PLUS
103896: ARRAY
103897: ST_TO_ADDR
103898: GO 104007
103900: LD_INT 31
103902: DOUBLE
103903: EQUAL
103904: IFTRUE 103950
103906: LD_INT 32
103908: DOUBLE
103909: EQUAL
103910: IFTRUE 103950
103912: LD_INT 33
103914: DOUBLE
103915: EQUAL
103916: IFTRUE 103950
103918: LD_INT 27
103920: DOUBLE
103921: EQUAL
103922: IFTRUE 103950
103924: LD_INT 26
103926: DOUBLE
103927: EQUAL
103928: IFTRUE 103950
103930: LD_INT 28
103932: DOUBLE
103933: EQUAL
103934: IFTRUE 103950
103936: LD_INT 29
103938: DOUBLE
103939: EQUAL
103940: IFTRUE 103950
103942: LD_INT 30
103944: DOUBLE
103945: EQUAL
103946: IFTRUE 103950
103948: GO 104006
103950: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
103951: LD_ADDR_VAR 0 9
103955: PUSH
103956: LD_VAR 0 59
103960: PUSH
103961: LD_VAR 0 60
103965: PUSH
103966: LD_VAR 0 61
103970: PUSH
103971: LD_VAR 0 62
103975: PUSH
103976: LD_VAR 0 63
103980: PUSH
103981: LD_VAR 0 64
103985: PUSH
103986: EMPTY
103987: LIST
103988: LIST
103989: LIST
103990: LIST
103991: LIST
103992: LIST
103993: PUSH
103994: LD_VAR 0 4
103998: PUSH
103999: LD_INT 1
104001: PLUS
104002: ARRAY
104003: ST_TO_ADDR
104004: GO 104007
104006: POP
// temp_list2 = [ ] ;
104007: LD_ADDR_VAR 0 10
104011: PUSH
104012: EMPTY
104013: ST_TO_ADDR
// for i in temp_list do
104014: LD_ADDR_VAR 0 8
104018: PUSH
104019: LD_VAR 0 9
104023: PUSH
104024: FOR_IN
104025: IFFALSE 104077
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
104027: LD_ADDR_VAR 0 10
104031: PUSH
104032: LD_VAR 0 10
104036: PUSH
104037: LD_VAR 0 8
104041: PUSH
104042: LD_INT 1
104044: ARRAY
104045: PUSH
104046: LD_VAR 0 2
104050: PLUS
104051: PUSH
104052: LD_VAR 0 8
104056: PUSH
104057: LD_INT 2
104059: ARRAY
104060: PUSH
104061: LD_VAR 0 3
104065: PLUS
104066: PUSH
104067: EMPTY
104068: LIST
104069: LIST
104070: PUSH
104071: EMPTY
104072: LIST
104073: ADD
104074: ST_TO_ADDR
104075: GO 104024
104077: POP
104078: POP
// result = temp_list2 ;
104079: LD_ADDR_VAR 0 7
104083: PUSH
104084: LD_VAR 0 10
104088: ST_TO_ADDR
// end ;
104089: LD_VAR 0 7
104093: RET
// export function EnemyInRange ( unit , dist ) ; begin
104094: LD_INT 0
104096: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
104097: LD_ADDR_VAR 0 3
104101: PUSH
104102: LD_VAR 0 1
104106: PPUSH
104107: CALL_OW 255
104111: PPUSH
104112: LD_VAR 0 1
104116: PPUSH
104117: CALL_OW 250
104121: PPUSH
104122: LD_VAR 0 1
104126: PPUSH
104127: CALL_OW 251
104131: PPUSH
104132: LD_VAR 0 2
104136: PPUSH
104137: CALL 77351 0 4
104141: PUSH
104142: LD_INT 4
104144: ARRAY
104145: ST_TO_ADDR
// end ;
104146: LD_VAR 0 3
104150: RET
// export function PlayerSeeMe ( unit ) ; begin
104151: LD_INT 0
104153: PPUSH
// result := See ( your_side , unit ) ;
104154: LD_ADDR_VAR 0 2
104158: PUSH
104159: LD_OWVAR 2
104163: PPUSH
104164: LD_VAR 0 1
104168: PPUSH
104169: CALL_OW 292
104173: ST_TO_ADDR
// end ;
104174: LD_VAR 0 2
104178: RET
// export function ReverseDir ( unit ) ; begin
104179: LD_INT 0
104181: PPUSH
// if not unit then
104182: LD_VAR 0 1
104186: NOT
104187: IFFALSE 104191
// exit ;
104189: GO 104214
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
104191: LD_ADDR_VAR 0 2
104195: PUSH
104196: LD_VAR 0 1
104200: PPUSH
104201: CALL_OW 254
104205: PUSH
104206: LD_INT 3
104208: PLUS
104209: PUSH
104210: LD_INT 6
104212: MOD
104213: ST_TO_ADDR
// end ;
104214: LD_VAR 0 2
104218: RET
// export function ReverseArray ( array ) ; var i ; begin
104219: LD_INT 0
104221: PPUSH
104222: PPUSH
// if not array then
104223: LD_VAR 0 1
104227: NOT
104228: IFFALSE 104232
// exit ;
104230: GO 104287
// result := [ ] ;
104232: LD_ADDR_VAR 0 2
104236: PUSH
104237: EMPTY
104238: ST_TO_ADDR
// for i := array downto 1 do
104239: LD_ADDR_VAR 0 3
104243: PUSH
104244: DOUBLE
104245: LD_VAR 0 1
104249: INC
104250: ST_TO_ADDR
104251: LD_INT 1
104253: PUSH
104254: FOR_DOWNTO
104255: IFFALSE 104285
// result := Join ( result , array [ i ] ) ;
104257: LD_ADDR_VAR 0 2
104261: PUSH
104262: LD_VAR 0 2
104266: PPUSH
104267: LD_VAR 0 1
104271: PUSH
104272: LD_VAR 0 3
104276: ARRAY
104277: PPUSH
104278: CALL 109139 0 2
104282: ST_TO_ADDR
104283: GO 104254
104285: POP
104286: POP
// end ;
104287: LD_VAR 0 2
104291: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
104292: LD_INT 0
104294: PPUSH
104295: PPUSH
104296: PPUSH
104297: PPUSH
104298: PPUSH
104299: PPUSH
// if not unit or not hexes then
104300: LD_VAR 0 1
104304: NOT
104305: IFTRUE 104314
104307: PUSH
104308: LD_VAR 0 2
104312: NOT
104313: OR
104314: IFFALSE 104318
// exit ;
104316: GO 104441
// dist := 9999 ;
104318: LD_ADDR_VAR 0 5
104322: PUSH
104323: LD_INT 9999
104325: ST_TO_ADDR
// for i = 1 to hexes do
104326: LD_ADDR_VAR 0 4
104330: PUSH
104331: DOUBLE
104332: LD_INT 1
104334: DEC
104335: ST_TO_ADDR
104336: LD_VAR 0 2
104340: PUSH
104341: FOR_TO
104342: IFFALSE 104429
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
104344: LD_ADDR_VAR 0 6
104348: PUSH
104349: LD_VAR 0 1
104353: PPUSH
104354: LD_VAR 0 2
104358: PUSH
104359: LD_VAR 0 4
104363: ARRAY
104364: PUSH
104365: LD_INT 1
104367: ARRAY
104368: PPUSH
104369: LD_VAR 0 2
104373: PUSH
104374: LD_VAR 0 4
104378: ARRAY
104379: PUSH
104380: LD_INT 2
104382: ARRAY
104383: PPUSH
104384: CALL_OW 297
104388: ST_TO_ADDR
// if tdist < dist then
104389: LD_VAR 0 6
104393: PUSH
104394: LD_VAR 0 5
104398: LESS
104399: IFFALSE 104427
// begin hex := hexes [ i ] ;
104401: LD_ADDR_VAR 0 8
104405: PUSH
104406: LD_VAR 0 2
104410: PUSH
104411: LD_VAR 0 4
104415: ARRAY
104416: ST_TO_ADDR
// dist := tdist ;
104417: LD_ADDR_VAR 0 5
104421: PUSH
104422: LD_VAR 0 6
104426: ST_TO_ADDR
// end ; end ;
104427: GO 104341
104429: POP
104430: POP
// result := hex ;
104431: LD_ADDR_VAR 0 3
104435: PUSH
104436: LD_VAR 0 8
104440: ST_TO_ADDR
// end ;
104441: LD_VAR 0 3
104445: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
104446: LD_INT 0
104448: PPUSH
104449: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104450: LD_VAR 0 1
104454: NOT
104455: IFTRUE 104494
104457: PUSH
104458: LD_VAR 0 1
104462: PUSH
104463: LD_INT 21
104465: PUSH
104466: LD_INT 2
104468: PUSH
104469: EMPTY
104470: LIST
104471: LIST
104472: PUSH
104473: LD_INT 23
104475: PUSH
104476: LD_INT 2
104478: PUSH
104479: EMPTY
104480: LIST
104481: LIST
104482: PUSH
104483: EMPTY
104484: LIST
104485: LIST
104486: PPUSH
104487: CALL_OW 69
104491: IN
104492: NOT
104493: OR
104494: IFFALSE 104498
// exit ;
104496: GO 104545
// for i = 1 to 3 do
104498: LD_ADDR_VAR 0 3
104502: PUSH
104503: DOUBLE
104504: LD_INT 1
104506: DEC
104507: ST_TO_ADDR
104508: LD_INT 3
104510: PUSH
104511: FOR_TO
104512: IFFALSE 104543
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
104514: LD_VAR 0 1
104518: PPUSH
104519: CALL_OW 250
104523: PPUSH
104524: LD_VAR 0 1
104528: PPUSH
104529: CALL_OW 251
104533: PPUSH
104534: LD_INT 1
104536: PPUSH
104537: CALL_OW 453
104541: GO 104511
104543: POP
104544: POP
// end ;
104545: LD_VAR 0 2
104549: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
104550: LD_INT 0
104552: PPUSH
104553: PPUSH
104554: PPUSH
104555: PPUSH
104556: PPUSH
104557: PPUSH
// if not unit or not enemy_unit then
104558: LD_VAR 0 1
104562: NOT
104563: IFTRUE 104572
104565: PUSH
104566: LD_VAR 0 2
104570: NOT
104571: OR
104572: IFFALSE 104576
// exit ;
104574: GO 105057
// if GetLives ( i ) < 250 then
104576: LD_VAR 0 4
104580: PPUSH
104581: CALL_OW 256
104585: PUSH
104586: LD_INT 250
104588: LESS
104589: IFFALSE 104602
// begin ComAutodestruct ( i ) ;
104591: LD_VAR 0 4
104595: PPUSH
104596: CALL 104446 0 1
// exit ;
104600: GO 105057
// end ; x := GetX ( enemy_unit ) ;
104602: LD_ADDR_VAR 0 7
104606: PUSH
104607: LD_VAR 0 2
104611: PPUSH
104612: CALL_OW 250
104616: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
104617: LD_ADDR_VAR 0 8
104621: PUSH
104622: LD_VAR 0 2
104626: PPUSH
104627: CALL_OW 251
104631: ST_TO_ADDR
// if not x or not y then
104632: LD_VAR 0 7
104636: NOT
104637: IFTRUE 104646
104639: PUSH
104640: LD_VAR 0 8
104644: NOT
104645: OR
104646: IFFALSE 104650
// exit ;
104648: GO 105057
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
104650: LD_ADDR_VAR 0 6
104654: PUSH
104655: LD_VAR 0 7
104659: PPUSH
104660: LD_INT 0
104662: PPUSH
104663: LD_INT 4
104665: PPUSH
104666: CALL_OW 272
104670: PUSH
104671: LD_VAR 0 8
104675: PPUSH
104676: LD_INT 0
104678: PPUSH
104679: LD_INT 4
104681: PPUSH
104682: CALL_OW 273
104686: PUSH
104687: EMPTY
104688: LIST
104689: LIST
104690: PUSH
104691: LD_VAR 0 7
104695: PPUSH
104696: LD_INT 1
104698: PPUSH
104699: LD_INT 4
104701: PPUSH
104702: CALL_OW 272
104706: PUSH
104707: LD_VAR 0 8
104711: PPUSH
104712: LD_INT 1
104714: PPUSH
104715: LD_INT 4
104717: PPUSH
104718: CALL_OW 273
104722: PUSH
104723: EMPTY
104724: LIST
104725: LIST
104726: PUSH
104727: LD_VAR 0 7
104731: PPUSH
104732: LD_INT 2
104734: PPUSH
104735: LD_INT 4
104737: PPUSH
104738: CALL_OW 272
104742: PUSH
104743: LD_VAR 0 8
104747: PPUSH
104748: LD_INT 2
104750: PPUSH
104751: LD_INT 4
104753: PPUSH
104754: CALL_OW 273
104758: PUSH
104759: EMPTY
104760: LIST
104761: LIST
104762: PUSH
104763: LD_VAR 0 7
104767: PPUSH
104768: LD_INT 3
104770: PPUSH
104771: LD_INT 4
104773: PPUSH
104774: CALL_OW 272
104778: PUSH
104779: LD_VAR 0 8
104783: PPUSH
104784: LD_INT 3
104786: PPUSH
104787: LD_INT 4
104789: PPUSH
104790: CALL_OW 273
104794: PUSH
104795: EMPTY
104796: LIST
104797: LIST
104798: PUSH
104799: LD_VAR 0 7
104803: PPUSH
104804: LD_INT 4
104806: PPUSH
104807: LD_INT 4
104809: PPUSH
104810: CALL_OW 272
104814: PUSH
104815: LD_VAR 0 8
104819: PPUSH
104820: LD_INT 4
104822: PPUSH
104823: LD_INT 4
104825: PPUSH
104826: CALL_OW 273
104830: PUSH
104831: EMPTY
104832: LIST
104833: LIST
104834: PUSH
104835: LD_VAR 0 7
104839: PPUSH
104840: LD_INT 5
104842: PPUSH
104843: LD_INT 4
104845: PPUSH
104846: CALL_OW 272
104850: PUSH
104851: LD_VAR 0 8
104855: PPUSH
104856: LD_INT 5
104858: PPUSH
104859: LD_INT 4
104861: PPUSH
104862: CALL_OW 273
104866: PUSH
104867: EMPTY
104868: LIST
104869: LIST
104870: PUSH
104871: EMPTY
104872: LIST
104873: LIST
104874: LIST
104875: LIST
104876: LIST
104877: LIST
104878: ST_TO_ADDR
// for i = tmp downto 1 do
104879: LD_ADDR_VAR 0 4
104883: PUSH
104884: DOUBLE
104885: LD_VAR 0 6
104889: INC
104890: ST_TO_ADDR
104891: LD_INT 1
104893: PUSH
104894: FOR_DOWNTO
104895: IFFALSE 104998
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
104897: LD_VAR 0 6
104901: PUSH
104902: LD_VAR 0 4
104906: ARRAY
104907: PUSH
104908: LD_INT 1
104910: ARRAY
104911: PPUSH
104912: LD_VAR 0 6
104916: PUSH
104917: LD_VAR 0 4
104921: ARRAY
104922: PUSH
104923: LD_INT 2
104925: ARRAY
104926: PPUSH
104927: CALL_OW 488
104931: NOT
104932: IFTRUE 104974
104934: PUSH
104935: LD_VAR 0 6
104939: PUSH
104940: LD_VAR 0 4
104944: ARRAY
104945: PUSH
104946: LD_INT 1
104948: ARRAY
104949: PPUSH
104950: LD_VAR 0 6
104954: PUSH
104955: LD_VAR 0 4
104959: ARRAY
104960: PUSH
104961: LD_INT 2
104963: ARRAY
104964: PPUSH
104965: CALL_OW 428
104969: PUSH
104970: LD_INT 0
104972: NONEQUAL
104973: OR
104974: IFFALSE 104996
// tmp := Delete ( tmp , i ) ;
104976: LD_ADDR_VAR 0 6
104980: PUSH
104981: LD_VAR 0 6
104985: PPUSH
104986: LD_VAR 0 4
104990: PPUSH
104991: CALL_OW 3
104995: ST_TO_ADDR
104996: GO 104894
104998: POP
104999: POP
// j := GetClosestHex ( unit , tmp ) ;
105000: LD_ADDR_VAR 0 5
105004: PUSH
105005: LD_VAR 0 1
105009: PPUSH
105010: LD_VAR 0 6
105014: PPUSH
105015: CALL 104292 0 2
105019: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
105020: LD_VAR 0 1
105024: PPUSH
105025: LD_VAR 0 5
105029: PUSH
105030: LD_INT 1
105032: ARRAY
105033: PPUSH
105034: LD_VAR 0 5
105038: PUSH
105039: LD_INT 2
105041: ARRAY
105042: PPUSH
105043: CALL_OW 111
// result := j ;
105047: LD_ADDR_VAR 0 3
105051: PUSH
105052: LD_VAR 0 5
105056: ST_TO_ADDR
// end ;
105057: LD_VAR 0 3
105061: RET
// export function PrepareApemanSoldier ( ) ; begin
105062: LD_INT 0
105064: PPUSH
// uc_nation := 0 ;
105065: LD_ADDR_OWVAR 21
105069: PUSH
105070: LD_INT 0
105072: ST_TO_ADDR
// hc_sex := sex_male ;
105073: LD_ADDR_OWVAR 27
105077: PUSH
105078: LD_INT 1
105080: ST_TO_ADDR
// hc_name :=  ;
105081: LD_ADDR_OWVAR 26
105085: PUSH
105086: LD_STRING 
105088: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
105089: LD_ADDR_OWVAR 28
105093: PUSH
105094: LD_INT 15
105096: ST_TO_ADDR
// hc_gallery :=  ;
105097: LD_ADDR_OWVAR 33
105101: PUSH
105102: LD_STRING 
105104: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
105105: LD_ADDR_OWVAR 31
105109: PUSH
105110: LD_INT 0
105112: PPUSH
105113: LD_INT 3
105115: PPUSH
105116: CALL_OW 12
105120: PUSH
105121: LD_INT 0
105123: PPUSH
105124: LD_INT 3
105126: PPUSH
105127: CALL_OW 12
105131: PUSH
105132: LD_INT 0
105134: PUSH
105135: LD_INT 0
105137: PUSH
105138: EMPTY
105139: LIST
105140: LIST
105141: LIST
105142: LIST
105143: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
105144: LD_ADDR_OWVAR 29
105148: PUSH
105149: LD_INT 10
105151: PUSH
105152: LD_INT 12
105154: PUSH
105155: EMPTY
105156: LIST
105157: LIST
105158: ST_TO_ADDR
// end ;
105159: LD_VAR 0 1
105163: RET
// export function PrepareApemanEngineer ( ) ; begin
105164: LD_INT 0
105166: PPUSH
// uc_nation := 0 ;
105167: LD_ADDR_OWVAR 21
105171: PUSH
105172: LD_INT 0
105174: ST_TO_ADDR
// hc_sex := sex_male ;
105175: LD_ADDR_OWVAR 27
105179: PUSH
105180: LD_INT 1
105182: ST_TO_ADDR
// hc_name :=  ;
105183: LD_ADDR_OWVAR 26
105187: PUSH
105188: LD_STRING 
105190: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
105191: LD_ADDR_OWVAR 28
105195: PUSH
105196: LD_INT 16
105198: ST_TO_ADDR
// hc_gallery :=  ;
105199: LD_ADDR_OWVAR 33
105203: PUSH
105204: LD_STRING 
105206: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
105207: LD_ADDR_OWVAR 31
105211: PUSH
105212: LD_INT 0
105214: PPUSH
105215: LD_INT 3
105217: PPUSH
105218: CALL_OW 12
105222: PUSH
105223: LD_INT 0
105225: PPUSH
105226: LD_INT 3
105228: PPUSH
105229: CALL_OW 12
105233: PUSH
105234: LD_INT 0
105236: PUSH
105237: LD_INT 0
105239: PUSH
105240: EMPTY
105241: LIST
105242: LIST
105243: LIST
105244: LIST
105245: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
105246: LD_ADDR_OWVAR 29
105250: PUSH
105251: LD_INT 10
105253: PUSH
105254: LD_INT 12
105256: PUSH
105257: EMPTY
105258: LIST
105259: LIST
105260: ST_TO_ADDR
// end ;
105261: LD_VAR 0 1
105265: RET
// export function PrepareApeman ( agressivity ) ; begin
105266: LD_INT 0
105268: PPUSH
// uc_side := 0 ;
105269: LD_ADDR_OWVAR 20
105273: PUSH
105274: LD_INT 0
105276: ST_TO_ADDR
// uc_nation := 0 ;
105277: LD_ADDR_OWVAR 21
105281: PUSH
105282: LD_INT 0
105284: ST_TO_ADDR
// hc_sex := sex_male ;
105285: LD_ADDR_OWVAR 27
105289: PUSH
105290: LD_INT 1
105292: ST_TO_ADDR
// hc_class := class_apeman ;
105293: LD_ADDR_OWVAR 28
105297: PUSH
105298: LD_INT 12
105300: ST_TO_ADDR
// hc_gallery :=  ;
105301: LD_ADDR_OWVAR 33
105305: PUSH
105306: LD_STRING 
105308: ST_TO_ADDR
// hc_name :=  ;
105309: LD_ADDR_OWVAR 26
105313: PUSH
105314: LD_STRING 
105316: ST_TO_ADDR
// hc_attr := [ 10 , 12 ] ;
105317: LD_ADDR_OWVAR 29
105321: PUSH
105322: LD_INT 10
105324: PUSH
105325: LD_INT 12
105327: PUSH
105328: EMPTY
105329: LIST
105330: LIST
105331: ST_TO_ADDR
// if agressivity = 0 then
105332: LD_VAR 0 1
105336: PUSH
105337: LD_INT 0
105339: EQUAL
105340: IFFALSE 105352
// hc_agressivity := 0 else
105342: LD_ADDR_OWVAR 35
105346: PUSH
105347: LD_INT 0
105349: ST_TO_ADDR
105350: GO 105373
// hc_agressivity := rand ( - agressivity , agressivity ) ;
105352: LD_ADDR_OWVAR 35
105356: PUSH
105357: LD_VAR 0 1
105361: NEG
105362: PPUSH
105363: LD_VAR 0 1
105367: PPUSH
105368: CALL_OW 12
105372: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
105373: LD_ADDR_OWVAR 31
105377: PUSH
105378: LD_INT 0
105380: PPUSH
105381: LD_INT 3
105383: PPUSH
105384: CALL_OW 12
105388: PUSH
105389: LD_INT 0
105391: PPUSH
105392: LD_INT 3
105394: PPUSH
105395: CALL_OW 12
105399: PUSH
105400: LD_INT 0
105402: PUSH
105403: LD_INT 0
105405: PUSH
105406: EMPTY
105407: LIST
105408: LIST
105409: LIST
105410: LIST
105411: ST_TO_ADDR
// end ;
105412: LD_VAR 0 2
105416: RET
// export function PrepareTiger ( agressivity ) ; begin
105417: LD_INT 0
105419: PPUSH
// uc_side := 0 ;
105420: LD_ADDR_OWVAR 20
105424: PUSH
105425: LD_INT 0
105427: ST_TO_ADDR
// uc_nation := 0 ;
105428: LD_ADDR_OWVAR 21
105432: PUSH
105433: LD_INT 0
105435: ST_TO_ADDR
// InitHc ;
105436: CALL_OW 19
// hc_class := class_tiger ;
105440: LD_ADDR_OWVAR 28
105444: PUSH
105445: LD_INT 14
105447: ST_TO_ADDR
// hc_gallery :=  ;
105448: LD_ADDR_OWVAR 33
105452: PUSH
105453: LD_STRING 
105455: ST_TO_ADDR
// hc_name :=  ;
105456: LD_ADDR_OWVAR 26
105460: PUSH
105461: LD_STRING 
105463: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
105464: LD_ADDR_OWVAR 35
105468: PUSH
105469: LD_VAR 0 1
105473: NEG
105474: PPUSH
105475: LD_VAR 0 1
105479: PPUSH
105480: CALL_OW 12
105484: ST_TO_ADDR
// end ;
105485: LD_VAR 0 2
105489: RET
// export function PrepareEnchidna ( ) ; begin
105490: LD_INT 0
105492: PPUSH
// uc_side := 0 ;
105493: LD_ADDR_OWVAR 20
105497: PUSH
105498: LD_INT 0
105500: ST_TO_ADDR
// uc_nation := 0 ;
105501: LD_ADDR_OWVAR 21
105505: PUSH
105506: LD_INT 0
105508: ST_TO_ADDR
// InitHc ;
105509: CALL_OW 19
// hc_class := class_baggie ;
105513: LD_ADDR_OWVAR 28
105517: PUSH
105518: LD_INT 13
105520: ST_TO_ADDR
// hc_gallery :=  ;
105521: LD_ADDR_OWVAR 33
105525: PUSH
105526: LD_STRING 
105528: ST_TO_ADDR
// hc_name :=  ;
105529: LD_ADDR_OWVAR 26
105533: PUSH
105534: LD_STRING 
105536: ST_TO_ADDR
// end ;
105537: LD_VAR 0 1
105541: RET
// export function PrepareFrog ( ) ; begin
105542: LD_INT 0
105544: PPUSH
// uc_side := 0 ;
105545: LD_ADDR_OWVAR 20
105549: PUSH
105550: LD_INT 0
105552: ST_TO_ADDR
// uc_nation := 0 ;
105553: LD_ADDR_OWVAR 21
105557: PUSH
105558: LD_INT 0
105560: ST_TO_ADDR
// InitHc ;
105561: CALL_OW 19
// hc_class := class_frog ;
105565: LD_ADDR_OWVAR 28
105569: PUSH
105570: LD_INT 19
105572: ST_TO_ADDR
// hc_gallery :=  ;
105573: LD_ADDR_OWVAR 33
105577: PUSH
105578: LD_STRING 
105580: ST_TO_ADDR
// hc_name :=  ;
105581: LD_ADDR_OWVAR 26
105585: PUSH
105586: LD_STRING 
105588: ST_TO_ADDR
// end ;
105589: LD_VAR 0 1
105593: RET
// export function PrepareFish ( ) ; begin
105594: LD_INT 0
105596: PPUSH
// uc_side := 0 ;
105597: LD_ADDR_OWVAR 20
105601: PUSH
105602: LD_INT 0
105604: ST_TO_ADDR
// uc_nation := 0 ;
105605: LD_ADDR_OWVAR 21
105609: PUSH
105610: LD_INT 0
105612: ST_TO_ADDR
// InitHc ;
105613: CALL_OW 19
// hc_class := class_fish ;
105617: LD_ADDR_OWVAR 28
105621: PUSH
105622: LD_INT 20
105624: ST_TO_ADDR
// hc_gallery :=  ;
105625: LD_ADDR_OWVAR 33
105629: PUSH
105630: LD_STRING 
105632: ST_TO_ADDR
// hc_name :=  ;
105633: LD_ADDR_OWVAR 26
105637: PUSH
105638: LD_STRING 
105640: ST_TO_ADDR
// end ;
105641: LD_VAR 0 1
105645: RET
// export function PrepareBird ( ) ; begin
105646: LD_INT 0
105648: PPUSH
// uc_side := 0 ;
105649: LD_ADDR_OWVAR 20
105653: PUSH
105654: LD_INT 0
105656: ST_TO_ADDR
// uc_nation := 0 ;
105657: LD_ADDR_OWVAR 21
105661: PUSH
105662: LD_INT 0
105664: ST_TO_ADDR
// InitHc ;
105665: CALL_OW 19
// hc_class := class_phororhacos ;
105669: LD_ADDR_OWVAR 28
105673: PUSH
105674: LD_INT 18
105676: ST_TO_ADDR
// hc_gallery :=  ;
105677: LD_ADDR_OWVAR 33
105681: PUSH
105682: LD_STRING 
105684: ST_TO_ADDR
// hc_name :=  ;
105685: LD_ADDR_OWVAR 26
105689: PUSH
105690: LD_STRING 
105692: ST_TO_ADDR
// end ;
105693: LD_VAR 0 1
105697: RET
// export function PrepareHorse ( ) ; begin
105698: LD_INT 0
105700: PPUSH
// uc_side := 0 ;
105701: LD_ADDR_OWVAR 20
105705: PUSH
105706: LD_INT 0
105708: ST_TO_ADDR
// uc_nation := 0 ;
105709: LD_ADDR_OWVAR 21
105713: PUSH
105714: LD_INT 0
105716: ST_TO_ADDR
// InitHc ;
105717: CALL_OW 19
// hc_class := class_horse ;
105721: LD_ADDR_OWVAR 28
105725: PUSH
105726: LD_INT 21
105728: ST_TO_ADDR
// hc_gallery :=  ;
105729: LD_ADDR_OWVAR 33
105733: PUSH
105734: LD_STRING 
105736: ST_TO_ADDR
// hc_name :=  ;
105737: LD_ADDR_OWVAR 26
105741: PUSH
105742: LD_STRING 
105744: ST_TO_ADDR
// end ;
105745: LD_VAR 0 1
105749: RET
// export function PrepareMastodont ( ) ; begin
105750: LD_INT 0
105752: PPUSH
// uc_side := 0 ;
105753: LD_ADDR_OWVAR 20
105757: PUSH
105758: LD_INT 0
105760: ST_TO_ADDR
// uc_nation := 0 ;
105761: LD_ADDR_OWVAR 21
105765: PUSH
105766: LD_INT 0
105768: ST_TO_ADDR
// vc_chassis := class_mastodont ;
105769: LD_ADDR_OWVAR 37
105773: PUSH
105774: LD_INT 31
105776: ST_TO_ADDR
// vc_control := control_rider ;
105777: LD_ADDR_OWVAR 38
105781: PUSH
105782: LD_INT 4
105784: ST_TO_ADDR
// end ;
105785: LD_VAR 0 1
105789: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
105790: LD_INT 0
105792: PPUSH
105793: PPUSH
105794: PPUSH
// uc_side = 0 ;
105795: LD_ADDR_OWVAR 20
105799: PUSH
105800: LD_INT 0
105802: ST_TO_ADDR
// uc_nation = 0 ;
105803: LD_ADDR_OWVAR 21
105807: PUSH
105808: LD_INT 0
105810: ST_TO_ADDR
// InitHc_All ( ) ;
105811: CALL_OW 584
// InitVc ;
105815: CALL_OW 20
// if mastodonts then
105819: LD_VAR 0 6
105823: IFFALSE 105890
// for i = 1 to mastodonts do
105825: LD_ADDR_VAR 0 11
105829: PUSH
105830: DOUBLE
105831: LD_INT 1
105833: DEC
105834: ST_TO_ADDR
105835: LD_VAR 0 6
105839: PUSH
105840: FOR_TO
105841: IFFALSE 105888
// begin vc_chassis := 31 ;
105843: LD_ADDR_OWVAR 37
105847: PUSH
105848: LD_INT 31
105850: ST_TO_ADDR
// vc_control := control_rider ;
105851: LD_ADDR_OWVAR 38
105855: PUSH
105856: LD_INT 4
105858: ST_TO_ADDR
// animal := CreateVehicle ;
105859: LD_ADDR_VAR 0 12
105863: PUSH
105864: CALL_OW 45
105868: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105869: LD_VAR 0 12
105873: PPUSH
105874: LD_VAR 0 8
105878: PPUSH
105879: LD_INT 0
105881: PPUSH
105882: CALL 108032 0 3
// end ;
105886: GO 105840
105888: POP
105889: POP
// if horses then
105890: LD_VAR 0 5
105894: IFFALSE 105961
// for i = 1 to horses do
105896: LD_ADDR_VAR 0 11
105900: PUSH
105901: DOUBLE
105902: LD_INT 1
105904: DEC
105905: ST_TO_ADDR
105906: LD_VAR 0 5
105910: PUSH
105911: FOR_TO
105912: IFFALSE 105959
// begin hc_class := 21 ;
105914: LD_ADDR_OWVAR 28
105918: PUSH
105919: LD_INT 21
105921: ST_TO_ADDR
// hc_gallery :=  ;
105922: LD_ADDR_OWVAR 33
105926: PUSH
105927: LD_STRING 
105929: ST_TO_ADDR
// animal := CreateHuman ;
105930: LD_ADDR_VAR 0 12
105934: PUSH
105935: CALL_OW 44
105939: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
105940: LD_VAR 0 12
105944: PPUSH
105945: LD_VAR 0 8
105949: PPUSH
105950: LD_INT 0
105952: PPUSH
105953: CALL 108032 0 3
// end ;
105957: GO 105911
105959: POP
105960: POP
// if birds then
105961: LD_VAR 0 1
105965: IFFALSE 106032
// for i = 1 to birds do
105967: LD_ADDR_VAR 0 11
105971: PUSH
105972: DOUBLE
105973: LD_INT 1
105975: DEC
105976: ST_TO_ADDR
105977: LD_VAR 0 1
105981: PUSH
105982: FOR_TO
105983: IFFALSE 106030
// begin hc_class := 18 ;
105985: LD_ADDR_OWVAR 28
105989: PUSH
105990: LD_INT 18
105992: ST_TO_ADDR
// hc_gallery =  ;
105993: LD_ADDR_OWVAR 33
105997: PUSH
105998: LD_STRING 
106000: ST_TO_ADDR
// animal := CreateHuman ;
106001: LD_ADDR_VAR 0 12
106005: PUSH
106006: CALL_OW 44
106010: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
106011: LD_VAR 0 12
106015: PPUSH
106016: LD_VAR 0 8
106020: PPUSH
106021: LD_INT 0
106023: PPUSH
106024: CALL 108032 0 3
// end ;
106028: GO 105982
106030: POP
106031: POP
// if tigers then
106032: LD_VAR 0 2
106036: IFFALSE 106120
// for i = 1 to tigers do
106038: LD_ADDR_VAR 0 11
106042: PUSH
106043: DOUBLE
106044: LD_INT 1
106046: DEC
106047: ST_TO_ADDR
106048: LD_VAR 0 2
106052: PUSH
106053: FOR_TO
106054: IFFALSE 106118
// begin hc_class = class_tiger ;
106056: LD_ADDR_OWVAR 28
106060: PUSH
106061: LD_INT 14
106063: ST_TO_ADDR
// hc_gallery =  ;
106064: LD_ADDR_OWVAR 33
106068: PUSH
106069: LD_STRING 
106071: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
106072: LD_ADDR_OWVAR 35
106076: PUSH
106077: LD_INT 7
106079: NEG
106080: PPUSH
106081: LD_INT 7
106083: PPUSH
106084: CALL_OW 12
106088: ST_TO_ADDR
// animal := CreateHuman ;
106089: LD_ADDR_VAR 0 12
106093: PUSH
106094: CALL_OW 44
106098: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
106099: LD_VAR 0 12
106103: PPUSH
106104: LD_VAR 0 8
106108: PPUSH
106109: LD_INT 0
106111: PPUSH
106112: CALL 108032 0 3
// end ;
106116: GO 106053
106118: POP
106119: POP
// if apemans then
106120: LD_VAR 0 3
106124: IFFALSE 106247
// for i = 1 to apemans do
106126: LD_ADDR_VAR 0 11
106130: PUSH
106131: DOUBLE
106132: LD_INT 1
106134: DEC
106135: ST_TO_ADDR
106136: LD_VAR 0 3
106140: PUSH
106141: FOR_TO
106142: IFFALSE 106245
// begin hc_class = class_apeman ;
106144: LD_ADDR_OWVAR 28
106148: PUSH
106149: LD_INT 12
106151: ST_TO_ADDR
// hc_gallery =  ;
106152: LD_ADDR_OWVAR 33
106156: PUSH
106157: LD_STRING 
106159: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
106160: LD_ADDR_OWVAR 35
106164: PUSH
106165: LD_INT 2
106167: NEG
106168: PPUSH
106169: LD_INT 2
106171: PPUSH
106172: CALL_OW 12
106176: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
106177: LD_ADDR_OWVAR 31
106181: PUSH
106182: LD_INT 1
106184: PPUSH
106185: LD_INT 3
106187: PPUSH
106188: CALL_OW 12
106192: PUSH
106193: LD_INT 1
106195: PPUSH
106196: LD_INT 3
106198: PPUSH
106199: CALL_OW 12
106203: PUSH
106204: LD_INT 0
106206: PUSH
106207: LD_INT 0
106209: PUSH
106210: EMPTY
106211: LIST
106212: LIST
106213: LIST
106214: LIST
106215: ST_TO_ADDR
// animal := CreateHuman ;
106216: LD_ADDR_VAR 0 12
106220: PUSH
106221: CALL_OW 44
106225: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
106226: LD_VAR 0 12
106230: PPUSH
106231: LD_VAR 0 8
106235: PPUSH
106236: LD_INT 0
106238: PPUSH
106239: CALL 108032 0 3
// end ;
106243: GO 106141
106245: POP
106246: POP
// if enchidnas then
106247: LD_VAR 0 4
106251: IFFALSE 106318
// for i = 1 to enchidnas do
106253: LD_ADDR_VAR 0 11
106257: PUSH
106258: DOUBLE
106259: LD_INT 1
106261: DEC
106262: ST_TO_ADDR
106263: LD_VAR 0 4
106267: PUSH
106268: FOR_TO
106269: IFFALSE 106316
// begin hc_class = 13 ;
106271: LD_ADDR_OWVAR 28
106275: PUSH
106276: LD_INT 13
106278: ST_TO_ADDR
// hc_gallery =  ;
106279: LD_ADDR_OWVAR 33
106283: PUSH
106284: LD_STRING 
106286: ST_TO_ADDR
// animal := CreateHuman ;
106287: LD_ADDR_VAR 0 12
106291: PUSH
106292: CALL_OW 44
106296: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
106297: LD_VAR 0 12
106301: PPUSH
106302: LD_VAR 0 8
106306: PPUSH
106307: LD_INT 0
106309: PPUSH
106310: CALL 108032 0 3
// end ;
106314: GO 106268
106316: POP
106317: POP
// if fishes then
106318: LD_VAR 0 7
106322: IFFALSE 106389
// for i = 1 to fishes do
106324: LD_ADDR_VAR 0 11
106328: PUSH
106329: DOUBLE
106330: LD_INT 1
106332: DEC
106333: ST_TO_ADDR
106334: LD_VAR 0 7
106338: PUSH
106339: FOR_TO
106340: IFFALSE 106387
// begin hc_class = 20 ;
106342: LD_ADDR_OWVAR 28
106346: PUSH
106347: LD_INT 20
106349: ST_TO_ADDR
// hc_gallery =  ;
106350: LD_ADDR_OWVAR 33
106354: PUSH
106355: LD_STRING 
106357: ST_TO_ADDR
// animal := CreateHuman ;
106358: LD_ADDR_VAR 0 12
106362: PUSH
106363: CALL_OW 44
106367: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
106368: LD_VAR 0 12
106372: PPUSH
106373: LD_VAR 0 9
106377: PPUSH
106378: LD_INT 0
106380: PPUSH
106381: CALL 108032 0 3
// end ;
106385: GO 106339
106387: POP
106388: POP
// end ;
106389: LD_VAR 0 10
106393: RET
// export function WantHeal ( sci , unit ) ; begin
106394: LD_INT 0
106396: PPUSH
// if GetTaskList ( sci ) > 0 then
106397: LD_VAR 0 1
106401: PPUSH
106402: CALL_OW 437
106406: PUSH
106407: LD_INT 0
106409: GREATER
106410: IFFALSE 106482
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
106412: LD_VAR 0 1
106416: PPUSH
106417: CALL_OW 437
106421: PUSH
106422: LD_INT 1
106424: ARRAY
106425: PUSH
106426: LD_INT 1
106428: ARRAY
106429: PUSH
106430: LD_STRING l
106432: EQUAL
106433: IFFALSE 106460
106435: PUSH
106436: LD_VAR 0 1
106440: PPUSH
106441: CALL_OW 437
106445: PUSH
106446: LD_INT 1
106448: ARRAY
106449: PUSH
106450: LD_INT 4
106452: ARRAY
106453: PUSH
106454: LD_VAR 0 2
106458: EQUAL
106459: AND
106460: IFFALSE 106472
// result := true else
106462: LD_ADDR_VAR 0 3
106466: PUSH
106467: LD_INT 1
106469: ST_TO_ADDR
106470: GO 106480
// result := false ;
106472: LD_ADDR_VAR 0 3
106476: PUSH
106477: LD_INT 0
106479: ST_TO_ADDR
// end else
106480: GO 106490
// result := false ;
106482: LD_ADDR_VAR 0 3
106486: PUSH
106487: LD_INT 0
106489: ST_TO_ADDR
// end ;
106490: LD_VAR 0 3
106494: RET
// export function HealTarget ( sci ) ; begin
106495: LD_INT 0
106497: PPUSH
// if not sci then
106498: LD_VAR 0 1
106502: NOT
106503: IFFALSE 106507
// exit ;
106505: GO 106572
// result := 0 ;
106507: LD_ADDR_VAR 0 2
106511: PUSH
106512: LD_INT 0
106514: ST_TO_ADDR
// if GetTaskList ( sci ) then
106515: LD_VAR 0 1
106519: PPUSH
106520: CALL_OW 437
106524: IFFALSE 106572
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
106526: LD_VAR 0 1
106530: PPUSH
106531: CALL_OW 437
106535: PUSH
106536: LD_INT 1
106538: ARRAY
106539: PUSH
106540: LD_INT 1
106542: ARRAY
106543: PUSH
106544: LD_STRING l
106546: EQUAL
106547: IFFALSE 106572
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
106549: LD_ADDR_VAR 0 2
106553: PUSH
106554: LD_VAR 0 1
106558: PPUSH
106559: CALL_OW 437
106563: PUSH
106564: LD_INT 1
106566: ARRAY
106567: PUSH
106568: LD_INT 4
106570: ARRAY
106571: ST_TO_ADDR
// end ;
106572: LD_VAR 0 2
106576: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
106577: LD_INT 0
106579: PPUSH
106580: PPUSH
106581: PPUSH
106582: PPUSH
// if not base_units then
106583: LD_VAR 0 1
106587: NOT
106588: IFFALSE 106592
// exit ;
106590: GO 106679
// result := false ;
106592: LD_ADDR_VAR 0 2
106596: PUSH
106597: LD_INT 0
106599: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
106600: LD_ADDR_VAR 0 5
106604: PUSH
106605: LD_VAR 0 1
106609: PPUSH
106610: LD_INT 21
106612: PUSH
106613: LD_INT 3
106615: PUSH
106616: EMPTY
106617: LIST
106618: LIST
106619: PPUSH
106620: CALL_OW 72
106624: ST_TO_ADDR
// if not tmp then
106625: LD_VAR 0 5
106629: NOT
106630: IFFALSE 106634
// exit ;
106632: GO 106679
// for i in tmp do
106634: LD_ADDR_VAR 0 3
106638: PUSH
106639: LD_VAR 0 5
106643: PUSH
106644: FOR_IN
106645: IFFALSE 106677
// begin result := EnemyInRange ( i , 22 ) ;
106647: LD_ADDR_VAR 0 2
106651: PUSH
106652: LD_VAR 0 3
106656: PPUSH
106657: LD_INT 22
106659: PPUSH
106660: CALL 104094 0 2
106664: ST_TO_ADDR
// if result then
106665: LD_VAR 0 2
106669: IFFALSE 106675
// exit ;
106671: POP
106672: POP
106673: GO 106679
// end ;
106675: GO 106644
106677: POP
106678: POP
// end ;
106679: LD_VAR 0 2
106683: RET
// export function FilterByTag ( units , tag ) ; begin
106684: LD_INT 0
106686: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
106687: LD_ADDR_VAR 0 3
106691: PUSH
106692: LD_VAR 0 1
106696: PPUSH
106697: LD_INT 120
106699: PUSH
106700: LD_VAR 0 2
106704: PUSH
106705: EMPTY
106706: LIST
106707: LIST
106708: PPUSH
106709: CALL_OW 72
106713: ST_TO_ADDR
// end ;
106714: LD_VAR 0 3
106718: RET
// export function IsDriver ( un ) ; begin
106719: LD_INT 0
106721: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
106722: LD_ADDR_VAR 0 2
106726: PUSH
106727: LD_VAR 0 1
106731: PUSH
106732: LD_INT 55
106734: PUSH
106735: EMPTY
106736: LIST
106737: PPUSH
106738: CALL_OW 69
106742: IN
106743: ST_TO_ADDR
// end ;
106744: LD_VAR 0 2
106748: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
106749: LD_INT 0
106751: PPUSH
106752: PPUSH
// list := [ ] ;
106753: LD_ADDR_VAR 0 5
106757: PUSH
106758: EMPTY
106759: ST_TO_ADDR
// case d of 0 :
106760: LD_VAR 0 3
106764: PUSH
106765: LD_INT 0
106767: DOUBLE
106768: EQUAL
106769: IFTRUE 106773
106771: GO 106906
106773: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
106774: LD_ADDR_VAR 0 5
106778: PUSH
106779: LD_VAR 0 1
106783: PUSH
106784: LD_INT 4
106786: MINUS
106787: PUSH
106788: LD_VAR 0 2
106792: PUSH
106793: LD_INT 4
106795: MINUS
106796: PUSH
106797: LD_INT 2
106799: PUSH
106800: EMPTY
106801: LIST
106802: LIST
106803: LIST
106804: PUSH
106805: LD_VAR 0 1
106809: PUSH
106810: LD_INT 3
106812: MINUS
106813: PUSH
106814: LD_VAR 0 2
106818: PUSH
106819: LD_INT 1
106821: PUSH
106822: EMPTY
106823: LIST
106824: LIST
106825: LIST
106826: PUSH
106827: LD_VAR 0 1
106831: PUSH
106832: LD_INT 4
106834: PLUS
106835: PUSH
106836: LD_VAR 0 2
106840: PUSH
106841: LD_INT 4
106843: PUSH
106844: EMPTY
106845: LIST
106846: LIST
106847: LIST
106848: PUSH
106849: LD_VAR 0 1
106853: PUSH
106854: LD_INT 3
106856: PLUS
106857: PUSH
106858: LD_VAR 0 2
106862: PUSH
106863: LD_INT 3
106865: PLUS
106866: PUSH
106867: LD_INT 5
106869: PUSH
106870: EMPTY
106871: LIST
106872: LIST
106873: LIST
106874: PUSH
106875: LD_VAR 0 1
106879: PUSH
106880: LD_VAR 0 2
106884: PUSH
106885: LD_INT 4
106887: PLUS
106888: PUSH
106889: LD_INT 0
106891: PUSH
106892: EMPTY
106893: LIST
106894: LIST
106895: LIST
106896: PUSH
106897: EMPTY
106898: LIST
106899: LIST
106900: LIST
106901: LIST
106902: LIST
106903: ST_TO_ADDR
// end ; 1 :
106904: GO 107604
106906: LD_INT 1
106908: DOUBLE
106909: EQUAL
106910: IFTRUE 106914
106912: GO 107047
106914: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
106915: LD_ADDR_VAR 0 5
106919: PUSH
106920: LD_VAR 0 1
106924: PUSH
106925: LD_VAR 0 2
106929: PUSH
106930: LD_INT 4
106932: MINUS
106933: PUSH
106934: LD_INT 3
106936: PUSH
106937: EMPTY
106938: LIST
106939: LIST
106940: LIST
106941: PUSH
106942: LD_VAR 0 1
106946: PUSH
106947: LD_INT 3
106949: MINUS
106950: PUSH
106951: LD_VAR 0 2
106955: PUSH
106956: LD_INT 3
106958: MINUS
106959: PUSH
106960: LD_INT 2
106962: PUSH
106963: EMPTY
106964: LIST
106965: LIST
106966: LIST
106967: PUSH
106968: LD_VAR 0 1
106972: PUSH
106973: LD_INT 4
106975: MINUS
106976: PUSH
106977: LD_VAR 0 2
106981: PUSH
106982: LD_INT 1
106984: PUSH
106985: EMPTY
106986: LIST
106987: LIST
106988: LIST
106989: PUSH
106990: LD_VAR 0 1
106994: PUSH
106995: LD_VAR 0 2
106999: PUSH
107000: LD_INT 3
107002: PLUS
107003: PUSH
107004: LD_INT 0
107006: PUSH
107007: EMPTY
107008: LIST
107009: LIST
107010: LIST
107011: PUSH
107012: LD_VAR 0 1
107016: PUSH
107017: LD_INT 4
107019: PLUS
107020: PUSH
107021: LD_VAR 0 2
107025: PUSH
107026: LD_INT 4
107028: PLUS
107029: PUSH
107030: LD_INT 5
107032: PUSH
107033: EMPTY
107034: LIST
107035: LIST
107036: LIST
107037: PUSH
107038: EMPTY
107039: LIST
107040: LIST
107041: LIST
107042: LIST
107043: LIST
107044: ST_TO_ADDR
// end ; 2 :
107045: GO 107604
107047: LD_INT 2
107049: DOUBLE
107050: EQUAL
107051: IFTRUE 107055
107053: GO 107184
107055: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
107056: LD_ADDR_VAR 0 5
107060: PUSH
107061: LD_VAR 0 1
107065: PUSH
107066: LD_VAR 0 2
107070: PUSH
107071: LD_INT 3
107073: MINUS
107074: PUSH
107075: LD_INT 3
107077: PUSH
107078: EMPTY
107079: LIST
107080: LIST
107081: LIST
107082: PUSH
107083: LD_VAR 0 1
107087: PUSH
107088: LD_INT 4
107090: PLUS
107091: PUSH
107092: LD_VAR 0 2
107096: PUSH
107097: LD_INT 4
107099: PUSH
107100: EMPTY
107101: LIST
107102: LIST
107103: LIST
107104: PUSH
107105: LD_VAR 0 1
107109: PUSH
107110: LD_VAR 0 2
107114: PUSH
107115: LD_INT 4
107117: PLUS
107118: PUSH
107119: LD_INT 0
107121: PUSH
107122: EMPTY
107123: LIST
107124: LIST
107125: LIST
107126: PUSH
107127: LD_VAR 0 1
107131: PUSH
107132: LD_INT 3
107134: MINUS
107135: PUSH
107136: LD_VAR 0 2
107140: PUSH
107141: LD_INT 1
107143: PUSH
107144: EMPTY
107145: LIST
107146: LIST
107147: LIST
107148: PUSH
107149: LD_VAR 0 1
107153: PUSH
107154: LD_INT 4
107156: MINUS
107157: PUSH
107158: LD_VAR 0 2
107162: PUSH
107163: LD_INT 4
107165: MINUS
107166: PUSH
107167: LD_INT 2
107169: PUSH
107170: EMPTY
107171: LIST
107172: LIST
107173: LIST
107174: PUSH
107175: EMPTY
107176: LIST
107177: LIST
107178: LIST
107179: LIST
107180: LIST
107181: ST_TO_ADDR
// end ; 3 :
107182: GO 107604
107184: LD_INT 3
107186: DOUBLE
107187: EQUAL
107188: IFTRUE 107192
107190: GO 107325
107192: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
107193: LD_ADDR_VAR 0 5
107197: PUSH
107198: LD_VAR 0 1
107202: PUSH
107203: LD_INT 3
107205: PLUS
107206: PUSH
107207: LD_VAR 0 2
107211: PUSH
107212: LD_INT 4
107214: PUSH
107215: EMPTY
107216: LIST
107217: LIST
107218: LIST
107219: PUSH
107220: LD_VAR 0 1
107224: PUSH
107225: LD_INT 4
107227: PLUS
107228: PUSH
107229: LD_VAR 0 2
107233: PUSH
107234: LD_INT 4
107236: PLUS
107237: PUSH
107238: LD_INT 5
107240: PUSH
107241: EMPTY
107242: LIST
107243: LIST
107244: LIST
107245: PUSH
107246: LD_VAR 0 1
107250: PUSH
107251: LD_INT 4
107253: MINUS
107254: PUSH
107255: LD_VAR 0 2
107259: PUSH
107260: LD_INT 1
107262: PUSH
107263: EMPTY
107264: LIST
107265: LIST
107266: LIST
107267: PUSH
107268: LD_VAR 0 1
107272: PUSH
107273: LD_VAR 0 2
107277: PUSH
107278: LD_INT 4
107280: MINUS
107281: PUSH
107282: LD_INT 3
107284: PUSH
107285: EMPTY
107286: LIST
107287: LIST
107288: LIST
107289: PUSH
107290: LD_VAR 0 1
107294: PUSH
107295: LD_INT 3
107297: MINUS
107298: PUSH
107299: LD_VAR 0 2
107303: PUSH
107304: LD_INT 3
107306: MINUS
107307: PUSH
107308: LD_INT 2
107310: PUSH
107311: EMPTY
107312: LIST
107313: LIST
107314: LIST
107315: PUSH
107316: EMPTY
107317: LIST
107318: LIST
107319: LIST
107320: LIST
107321: LIST
107322: ST_TO_ADDR
// end ; 4 :
107323: GO 107604
107325: LD_INT 4
107327: DOUBLE
107328: EQUAL
107329: IFTRUE 107333
107331: GO 107466
107333: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
107334: LD_ADDR_VAR 0 5
107338: PUSH
107339: LD_VAR 0 1
107343: PUSH
107344: LD_VAR 0 2
107348: PUSH
107349: LD_INT 4
107351: PLUS
107352: PUSH
107353: LD_INT 0
107355: PUSH
107356: EMPTY
107357: LIST
107358: LIST
107359: LIST
107360: PUSH
107361: LD_VAR 0 1
107365: PUSH
107366: LD_INT 3
107368: PLUS
107369: PUSH
107370: LD_VAR 0 2
107374: PUSH
107375: LD_INT 3
107377: PLUS
107378: PUSH
107379: LD_INT 5
107381: PUSH
107382: EMPTY
107383: LIST
107384: LIST
107385: LIST
107386: PUSH
107387: LD_VAR 0 1
107391: PUSH
107392: LD_INT 4
107394: PLUS
107395: PUSH
107396: LD_VAR 0 2
107400: PUSH
107401: LD_INT 4
107403: PUSH
107404: EMPTY
107405: LIST
107406: LIST
107407: LIST
107408: PUSH
107409: LD_VAR 0 1
107413: PUSH
107414: LD_VAR 0 2
107418: PUSH
107419: LD_INT 3
107421: MINUS
107422: PUSH
107423: LD_INT 3
107425: PUSH
107426: EMPTY
107427: LIST
107428: LIST
107429: LIST
107430: PUSH
107431: LD_VAR 0 1
107435: PUSH
107436: LD_INT 4
107438: MINUS
107439: PUSH
107440: LD_VAR 0 2
107444: PUSH
107445: LD_INT 4
107447: MINUS
107448: PUSH
107449: LD_INT 2
107451: PUSH
107452: EMPTY
107453: LIST
107454: LIST
107455: LIST
107456: PUSH
107457: EMPTY
107458: LIST
107459: LIST
107460: LIST
107461: LIST
107462: LIST
107463: ST_TO_ADDR
// end ; 5 :
107464: GO 107604
107466: LD_INT 5
107468: DOUBLE
107469: EQUAL
107470: IFTRUE 107474
107472: GO 107603
107474: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
107475: LD_ADDR_VAR 0 5
107479: PUSH
107480: LD_VAR 0 1
107484: PUSH
107485: LD_INT 4
107487: MINUS
107488: PUSH
107489: LD_VAR 0 2
107493: PUSH
107494: LD_INT 1
107496: PUSH
107497: EMPTY
107498: LIST
107499: LIST
107500: LIST
107501: PUSH
107502: LD_VAR 0 1
107506: PUSH
107507: LD_VAR 0 2
107511: PUSH
107512: LD_INT 4
107514: MINUS
107515: PUSH
107516: LD_INT 3
107518: PUSH
107519: EMPTY
107520: LIST
107521: LIST
107522: LIST
107523: PUSH
107524: LD_VAR 0 1
107528: PUSH
107529: LD_INT 4
107531: PLUS
107532: PUSH
107533: LD_VAR 0 2
107537: PUSH
107538: LD_INT 4
107540: PLUS
107541: PUSH
107542: LD_INT 5
107544: PUSH
107545: EMPTY
107546: LIST
107547: LIST
107548: LIST
107549: PUSH
107550: LD_VAR 0 1
107554: PUSH
107555: LD_INT 3
107557: PLUS
107558: PUSH
107559: LD_VAR 0 2
107563: PUSH
107564: LD_INT 4
107566: PUSH
107567: EMPTY
107568: LIST
107569: LIST
107570: LIST
107571: PUSH
107572: LD_VAR 0 1
107576: PUSH
107577: LD_VAR 0 2
107581: PUSH
107582: LD_INT 3
107584: PLUS
107585: PUSH
107586: LD_INT 0
107588: PUSH
107589: EMPTY
107590: LIST
107591: LIST
107592: LIST
107593: PUSH
107594: EMPTY
107595: LIST
107596: LIST
107597: LIST
107598: LIST
107599: LIST
107600: ST_TO_ADDR
// end ; end ;
107601: GO 107604
107603: POP
// result := list ;
107604: LD_ADDR_VAR 0 4
107608: PUSH
107609: LD_VAR 0 5
107613: ST_TO_ADDR
// end ;
107614: LD_VAR 0 4
107618: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
107619: LD_INT 0
107621: PPUSH
107622: PPUSH
107623: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
107624: LD_VAR 0 1
107628: NOT
107629: IFTRUE 107657
107631: PUSH
107632: LD_VAR 0 2
107636: PUSH
107637: LD_INT 1
107639: PUSH
107640: LD_INT 2
107642: PUSH
107643: LD_INT 3
107645: PUSH
107646: LD_INT 4
107648: PUSH
107649: EMPTY
107650: LIST
107651: LIST
107652: LIST
107653: LIST
107654: IN
107655: NOT
107656: OR
107657: IFFALSE 107661
// exit ;
107659: GO 107744
// tmp := [ ] ;
107661: LD_ADDR_VAR 0 5
107665: PUSH
107666: EMPTY
107667: ST_TO_ADDR
// for i in units do
107668: LD_ADDR_VAR 0 4
107672: PUSH
107673: LD_VAR 0 1
107677: PUSH
107678: FOR_IN
107679: IFFALSE 107713
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
107681: LD_ADDR_VAR 0 5
107685: PUSH
107686: LD_VAR 0 5
107690: PPUSH
107691: LD_VAR 0 4
107695: PPUSH
107696: LD_VAR 0 2
107700: PPUSH
107701: CALL_OW 259
107705: PPUSH
107706: CALL 109139 0 2
107710: ST_TO_ADDR
107711: GO 107678
107713: POP
107714: POP
// if not tmp then
107715: LD_VAR 0 5
107719: NOT
107720: IFFALSE 107724
// exit ;
107722: GO 107744
// result := SortListByListDesc ( units , tmp ) ;
107724: LD_ADDR_VAR 0 3
107728: PUSH
107729: LD_VAR 0 1
107733: PPUSH
107734: LD_VAR 0 5
107738: PPUSH
107739: CALL_OW 77
107743: ST_TO_ADDR
// end ;
107744: LD_VAR 0 3
107748: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
107749: LD_INT 0
107751: PPUSH
107752: PPUSH
107753: PPUSH
// result := false ;
107754: LD_ADDR_VAR 0 3
107758: PUSH
107759: LD_INT 0
107761: ST_TO_ADDR
// if not building then
107762: LD_VAR 0 2
107766: NOT
107767: IFFALSE 107771
// exit ;
107769: GO 107915
// x := GetX ( building ) ;
107771: LD_ADDR_VAR 0 4
107775: PUSH
107776: LD_VAR 0 2
107780: PPUSH
107781: CALL_OW 250
107785: ST_TO_ADDR
// y := GetY ( building ) ;
107786: LD_ADDR_VAR 0 5
107790: PUSH
107791: LD_VAR 0 2
107795: PPUSH
107796: CALL_OW 251
107800: ST_TO_ADDR
// if not x or not y then
107801: LD_VAR 0 4
107805: NOT
107806: IFTRUE 107815
107808: PUSH
107809: LD_VAR 0 5
107813: NOT
107814: OR
107815: IFFALSE 107819
// exit ;
107817: GO 107915
// if GetTaskList ( unit ) then
107819: LD_VAR 0 1
107823: PPUSH
107824: CALL_OW 437
107828: IFFALSE 107915
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
107830: LD_STRING e
107832: PUSH
107833: LD_VAR 0 1
107837: PPUSH
107838: CALL_OW 437
107842: PUSH
107843: LD_INT 1
107845: ARRAY
107846: PUSH
107847: LD_INT 1
107849: ARRAY
107850: EQUAL
107851: IFFALSE 107878
107853: PUSH
107854: LD_VAR 0 4
107858: PUSH
107859: LD_VAR 0 1
107863: PPUSH
107864: CALL_OW 437
107868: PUSH
107869: LD_INT 1
107871: ARRAY
107872: PUSH
107873: LD_INT 2
107875: ARRAY
107876: EQUAL
107877: AND
107878: IFFALSE 107905
107880: PUSH
107881: LD_VAR 0 5
107885: PUSH
107886: LD_VAR 0 1
107890: PPUSH
107891: CALL_OW 437
107895: PUSH
107896: LD_INT 1
107898: ARRAY
107899: PUSH
107900: LD_INT 3
107902: ARRAY
107903: EQUAL
107904: AND
107905: IFFALSE 107915
// result := true end ;
107907: LD_ADDR_VAR 0 3
107911: PUSH
107912: LD_INT 1
107914: ST_TO_ADDR
// end ;
107915: LD_VAR 0 3
107919: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
107920: LD_INT 0
107922: PPUSH
// result := false ;
107923: LD_ADDR_VAR 0 4
107927: PUSH
107928: LD_INT 0
107930: ST_TO_ADDR
// if GetTaskList ( unit ) then
107931: LD_VAR 0 1
107935: PPUSH
107936: CALL_OW 437
107940: IFFALSE 108027
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
107942: LD_STRING M
107944: PUSH
107945: LD_VAR 0 1
107949: PPUSH
107950: CALL_OW 437
107954: PUSH
107955: LD_INT 1
107957: ARRAY
107958: PUSH
107959: LD_INT 1
107961: ARRAY
107962: EQUAL
107963: IFFALSE 107990
107965: PUSH
107966: LD_VAR 0 2
107970: PUSH
107971: LD_VAR 0 1
107975: PPUSH
107976: CALL_OW 437
107980: PUSH
107981: LD_INT 1
107983: ARRAY
107984: PUSH
107985: LD_INT 2
107987: ARRAY
107988: EQUAL
107989: AND
107990: IFFALSE 108017
107992: PUSH
107993: LD_VAR 0 3
107997: PUSH
107998: LD_VAR 0 1
108002: PPUSH
108003: CALL_OW 437
108007: PUSH
108008: LD_INT 1
108010: ARRAY
108011: PUSH
108012: LD_INT 3
108014: ARRAY
108015: EQUAL
108016: AND
108017: IFFALSE 108027
// result := true ;
108019: LD_ADDR_VAR 0 4
108023: PUSH
108024: LD_INT 1
108026: ST_TO_ADDR
// end ; end ;
108027: LD_VAR 0 4
108031: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
108032: LD_INT 0
108034: PPUSH
108035: PPUSH
108036: PPUSH
108037: PPUSH
// if not unit or not area then
108038: LD_VAR 0 1
108042: NOT
108043: IFTRUE 108052
108045: PUSH
108046: LD_VAR 0 2
108050: NOT
108051: OR
108052: IFFALSE 108056
// exit ;
108054: GO 108232
// tmp := AreaToList ( area , i ) ;
108056: LD_ADDR_VAR 0 6
108060: PUSH
108061: LD_VAR 0 2
108065: PPUSH
108066: LD_VAR 0 5
108070: PPUSH
108071: CALL_OW 517
108075: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
108076: LD_ADDR_VAR 0 5
108080: PUSH
108081: DOUBLE
108082: LD_INT 1
108084: DEC
108085: ST_TO_ADDR
108086: LD_VAR 0 6
108090: PUSH
108091: LD_INT 1
108093: ARRAY
108094: PUSH
108095: FOR_TO
108096: IFFALSE 108230
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
108098: LD_ADDR_VAR 0 7
108102: PUSH
108103: LD_VAR 0 6
108107: PUSH
108108: LD_INT 1
108110: ARRAY
108111: PUSH
108112: LD_VAR 0 5
108116: ARRAY
108117: PUSH
108118: LD_VAR 0 6
108122: PUSH
108123: LD_INT 2
108125: ARRAY
108126: PUSH
108127: LD_VAR 0 5
108131: ARRAY
108132: PUSH
108133: EMPTY
108134: LIST
108135: LIST
108136: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
108137: LD_INT 92
108139: PUSH
108140: LD_VAR 0 7
108144: PUSH
108145: LD_INT 1
108147: ARRAY
108148: PUSH
108149: LD_VAR 0 7
108153: PUSH
108154: LD_INT 2
108156: ARRAY
108157: PUSH
108158: LD_INT 2
108160: PUSH
108161: EMPTY
108162: LIST
108163: LIST
108164: LIST
108165: LIST
108166: PPUSH
108167: CALL_OW 69
108171: PUSH
108172: LD_INT 0
108174: EQUAL
108175: IFFALSE 108228
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
108177: LD_VAR 0 1
108181: PPUSH
108182: LD_VAR 0 7
108186: PUSH
108187: LD_INT 1
108189: ARRAY
108190: PPUSH
108191: LD_VAR 0 7
108195: PUSH
108196: LD_INT 2
108198: ARRAY
108199: PPUSH
108200: LD_VAR 0 3
108204: PPUSH
108205: CALL_OW 48
// result := IsPlaced ( unit ) ;
108209: LD_ADDR_VAR 0 4
108213: PUSH
108214: LD_VAR 0 1
108218: PPUSH
108219: CALL_OW 305
108223: ST_TO_ADDR
// exit ;
108224: POP
108225: POP
108226: GO 108232
// end ; end ;
108228: GO 108095
108230: POP
108231: POP
// end ;
108232: LD_VAR 0 4
108236: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
108237: LD_INT 0
108239: PPUSH
108240: PPUSH
108241: PPUSH
// if not side or side > 8 then
108242: LD_VAR 0 1
108246: NOT
108247: IFTRUE 108259
108249: PUSH
108250: LD_VAR 0 1
108254: PUSH
108255: LD_INT 8
108257: GREATER
108258: OR
108259: IFFALSE 108263
// exit ;
108261: GO 108450
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
108263: LD_ADDR_VAR 0 4
108267: PUSH
108268: LD_INT 22
108270: PUSH
108271: LD_VAR 0 1
108275: PUSH
108276: EMPTY
108277: LIST
108278: LIST
108279: PUSH
108280: LD_INT 21
108282: PUSH
108283: LD_INT 3
108285: PUSH
108286: EMPTY
108287: LIST
108288: LIST
108289: PUSH
108290: EMPTY
108291: LIST
108292: LIST
108293: PPUSH
108294: CALL_OW 69
108298: ST_TO_ADDR
// if not tmp then
108299: LD_VAR 0 4
108303: NOT
108304: IFFALSE 108308
// exit ;
108306: GO 108450
// enable_addtolog := true ;
108308: LD_ADDR_OWVAR 81
108312: PUSH
108313: LD_INT 1
108315: ST_TO_ADDR
// AddToLog ( [ ) ;
108316: LD_STRING [
108318: PPUSH
108319: CALL_OW 561
// for i in tmp do
108323: LD_ADDR_VAR 0 3
108327: PUSH
108328: LD_VAR 0 4
108332: PUSH
108333: FOR_IN
108334: IFFALSE 108441
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
108336: LD_STRING [
108338: PUSH
108339: LD_VAR 0 3
108343: PPUSH
108344: CALL_OW 266
108348: STR
108349: PUSH
108350: LD_STRING , 
108352: STR
108353: PUSH
108354: LD_VAR 0 3
108358: PPUSH
108359: CALL_OW 250
108363: STR
108364: PUSH
108365: LD_STRING , 
108367: STR
108368: PUSH
108369: LD_VAR 0 3
108373: PPUSH
108374: CALL_OW 251
108378: STR
108379: PUSH
108380: LD_STRING , 
108382: STR
108383: PUSH
108384: LD_VAR 0 3
108388: PPUSH
108389: CALL_OW 254
108393: STR
108394: PUSH
108395: LD_STRING , 
108397: STR
108398: PUSH
108399: LD_VAR 0 3
108403: PPUSH
108404: LD_INT 1
108406: PPUSH
108407: CALL_OW 268
108411: STR
108412: PUSH
108413: LD_STRING , 
108415: STR
108416: PUSH
108417: LD_VAR 0 3
108421: PPUSH
108422: LD_INT 2
108424: PPUSH
108425: CALL_OW 268
108429: STR
108430: PUSH
108431: LD_STRING ],
108433: STR
108434: PPUSH
108435: CALL_OW 561
// end ;
108439: GO 108333
108441: POP
108442: POP
// AddToLog ( ]; ) ;
108443: LD_STRING ];
108445: PPUSH
108446: CALL_OW 561
// end ;
108450: LD_VAR 0 2
108454: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
108455: LD_INT 0
108457: PPUSH
108458: PPUSH
108459: PPUSH
108460: PPUSH
108461: PPUSH
// if not area or not rate or not max then
108462: LD_VAR 0 1
108466: NOT
108467: IFTRUE 108476
108469: PUSH
108470: LD_VAR 0 2
108474: NOT
108475: OR
108476: IFTRUE 108485
108478: PUSH
108479: LD_VAR 0 4
108483: NOT
108484: OR
108485: IFFALSE 108489
// exit ;
108487: GO 108678
// while 1 do
108489: LD_INT 1
108491: IFFALSE 108678
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
108493: LD_ADDR_VAR 0 9
108497: PUSH
108498: LD_VAR 0 1
108502: PPUSH
108503: LD_INT 1
108505: PPUSH
108506: CALL_OW 287
108510: PUSH
108511: LD_INT 10
108513: MUL
108514: ST_TO_ADDR
// r := rate / 10 ;
108515: LD_ADDR_VAR 0 7
108519: PUSH
108520: LD_VAR 0 2
108524: PUSH
108525: LD_INT 10
108527: DIVREAL
108528: ST_TO_ADDR
// time := 1 1$00 ;
108529: LD_ADDR_VAR 0 8
108533: PUSH
108534: LD_INT 2100
108536: ST_TO_ADDR
// if amount < min then
108537: LD_VAR 0 9
108541: PUSH
108542: LD_VAR 0 3
108546: LESS
108547: IFFALSE 108565
// r := r * 2 else
108549: LD_ADDR_VAR 0 7
108553: PUSH
108554: LD_VAR 0 7
108558: PUSH
108559: LD_INT 2
108561: MUL
108562: ST_TO_ADDR
108563: GO 108591
// if amount > max then
108565: LD_VAR 0 9
108569: PUSH
108570: LD_VAR 0 4
108574: GREATER
108575: IFFALSE 108591
// r := r / 2 ;
108577: LD_ADDR_VAR 0 7
108581: PUSH
108582: LD_VAR 0 7
108586: PUSH
108587: LD_INT 2
108589: DIVREAL
108590: ST_TO_ADDR
// time := time / r ;
108591: LD_ADDR_VAR 0 8
108595: PUSH
108596: LD_VAR 0 8
108600: PUSH
108601: LD_VAR 0 7
108605: DIVREAL
108606: ST_TO_ADDR
// if time < 0 then
108607: LD_VAR 0 8
108611: PUSH
108612: LD_INT 0
108614: LESS
108615: IFFALSE 108632
// time := time * - 1 ;
108617: LD_ADDR_VAR 0 8
108621: PUSH
108622: LD_VAR 0 8
108626: PUSH
108627: LD_INT 1
108629: NEG
108630: MUL
108631: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
108632: LD_VAR 0 8
108636: PUSH
108637: LD_INT 35
108639: PPUSH
108640: LD_INT 875
108642: PPUSH
108643: CALL_OW 12
108647: PLUS
108648: PPUSH
108649: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
108653: LD_INT 1
108655: PPUSH
108656: LD_INT 5
108658: PPUSH
108659: CALL_OW 12
108663: PPUSH
108664: LD_VAR 0 1
108668: PPUSH
108669: LD_INT 1
108671: PPUSH
108672: CALL_OW 55
// end ;
108676: GO 108489
// end ;
108678: LD_VAR 0 5
108682: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
108683: LD_INT 0
108685: PPUSH
108686: PPUSH
108687: PPUSH
108688: PPUSH
108689: PPUSH
108690: PPUSH
108691: PPUSH
108692: PPUSH
// if not turrets or not factories then
108693: LD_VAR 0 1
108697: NOT
108698: IFTRUE 108707
108700: PUSH
108701: LD_VAR 0 2
108705: NOT
108706: OR
108707: IFFALSE 108711
// exit ;
108709: GO 109018
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
108711: LD_ADDR_VAR 0 10
108715: PUSH
108716: LD_INT 5
108718: PUSH
108719: LD_INT 6
108721: PUSH
108722: EMPTY
108723: LIST
108724: LIST
108725: PUSH
108726: LD_INT 2
108728: PUSH
108729: LD_INT 4
108731: PUSH
108732: EMPTY
108733: LIST
108734: LIST
108735: PUSH
108736: LD_INT 3
108738: PUSH
108739: LD_INT 5
108741: PUSH
108742: EMPTY
108743: LIST
108744: LIST
108745: PUSH
108746: EMPTY
108747: LIST
108748: LIST
108749: LIST
108750: PUSH
108751: LD_INT 24
108753: PUSH
108754: LD_INT 25
108756: PUSH
108757: EMPTY
108758: LIST
108759: LIST
108760: PUSH
108761: LD_INT 23
108763: PUSH
108764: LD_INT 27
108766: PUSH
108767: EMPTY
108768: LIST
108769: LIST
108770: PUSH
108771: EMPTY
108772: LIST
108773: LIST
108774: PUSH
108775: LD_INT 42
108777: PUSH
108778: LD_INT 43
108780: PUSH
108781: EMPTY
108782: LIST
108783: LIST
108784: PUSH
108785: LD_INT 44
108787: PUSH
108788: LD_INT 46
108790: PUSH
108791: EMPTY
108792: LIST
108793: LIST
108794: PUSH
108795: LD_INT 45
108797: PUSH
108798: LD_INT 47
108800: PUSH
108801: EMPTY
108802: LIST
108803: LIST
108804: PUSH
108805: EMPTY
108806: LIST
108807: LIST
108808: LIST
108809: PUSH
108810: EMPTY
108811: LIST
108812: LIST
108813: LIST
108814: ST_TO_ADDR
// result := [ ] ;
108815: LD_ADDR_VAR 0 3
108819: PUSH
108820: EMPTY
108821: ST_TO_ADDR
// for i in turrets do
108822: LD_ADDR_VAR 0 4
108826: PUSH
108827: LD_VAR 0 1
108831: PUSH
108832: FOR_IN
108833: IFFALSE 109016
// begin nat := GetNation ( i ) ;
108835: LD_ADDR_VAR 0 7
108839: PUSH
108840: LD_VAR 0 4
108844: PPUSH
108845: CALL_OW 248
108849: ST_TO_ADDR
// weapon := 0 ;
108850: LD_ADDR_VAR 0 8
108854: PUSH
108855: LD_INT 0
108857: ST_TO_ADDR
// if not nat then
108858: LD_VAR 0 7
108862: NOT
108863: IFFALSE 108867
// continue ;
108865: GO 108832
// for j in list [ nat ] do
108867: LD_ADDR_VAR 0 5
108871: PUSH
108872: LD_VAR 0 10
108876: PUSH
108877: LD_VAR 0 7
108881: ARRAY
108882: PUSH
108883: FOR_IN
108884: IFFALSE 108925
// if GetBWeapon ( i ) = j [ 1 ] then
108886: LD_VAR 0 4
108890: PPUSH
108891: CALL_OW 269
108895: PUSH
108896: LD_VAR 0 5
108900: PUSH
108901: LD_INT 1
108903: ARRAY
108904: EQUAL
108905: IFFALSE 108923
// begin weapon := j [ 2 ] ;
108907: LD_ADDR_VAR 0 8
108911: PUSH
108912: LD_VAR 0 5
108916: PUSH
108917: LD_INT 2
108919: ARRAY
108920: ST_TO_ADDR
// break ;
108921: GO 108925
// end ;
108923: GO 108883
108925: POP
108926: POP
// if not weapon then
108927: LD_VAR 0 8
108931: NOT
108932: IFFALSE 108936
// continue ;
108934: GO 108832
// for k in factories do
108936: LD_ADDR_VAR 0 6
108940: PUSH
108941: LD_VAR 0 2
108945: PUSH
108946: FOR_IN
108947: IFFALSE 109012
// begin weapons := AvailableWeaponList ( k ) ;
108949: LD_ADDR_VAR 0 9
108953: PUSH
108954: LD_VAR 0 6
108958: PPUSH
108959: CALL_OW 478
108963: ST_TO_ADDR
// if not weapons then
108964: LD_VAR 0 9
108968: NOT
108969: IFFALSE 108973
// continue ;
108971: GO 108946
// if weapon in weapons then
108973: LD_VAR 0 8
108977: PUSH
108978: LD_VAR 0 9
108982: IN
108983: IFFALSE 109010
// begin result := [ i , weapon ] ;
108985: LD_ADDR_VAR 0 3
108989: PUSH
108990: LD_VAR 0 4
108994: PUSH
108995: LD_VAR 0 8
108999: PUSH
109000: EMPTY
109001: LIST
109002: LIST
109003: ST_TO_ADDR
// exit ;
109004: POP
109005: POP
109006: POP
109007: POP
109008: GO 109018
// end ; end ;
109010: GO 108946
109012: POP
109013: POP
// end ;
109014: GO 108832
109016: POP
109017: POP
// end ;
109018: LD_VAR 0 3
109022: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
109023: LD_INT 0
109025: PPUSH
// if not side or side > 8 then
109026: LD_VAR 0 3
109030: NOT
109031: IFTRUE 109043
109033: PUSH
109034: LD_VAR 0 3
109038: PUSH
109039: LD_INT 8
109041: GREATER
109042: OR
109043: IFFALSE 109047
// exit ;
109045: GO 109106
// if not range then
109047: LD_VAR 0 4
109051: NOT
109052: IFFALSE 109063
// range := - 12 ;
109054: LD_ADDR_VAR 0 4
109058: PUSH
109059: LD_INT 12
109061: NEG
109062: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
109063: LD_VAR 0 1
109067: PPUSH
109068: LD_VAR 0 2
109072: PPUSH
109073: LD_VAR 0 3
109077: PPUSH
109078: LD_VAR 0 4
109082: PPUSH
109083: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
109087: LD_VAR 0 1
109091: PPUSH
109092: LD_VAR 0 2
109096: PPUSH
109097: LD_VAR 0 3
109101: PPUSH
109102: CALL_OW 331
// end ;
109106: LD_VAR 0 5
109110: RET
// export function Video ( mode ) ; begin
109111: LD_INT 0
109113: PPUSH
// ingame_video = mode ;
109114: LD_ADDR_OWVAR 52
109118: PUSH
109119: LD_VAR 0 1
109123: ST_TO_ADDR
// interface_hidden = mode ;
109124: LD_ADDR_OWVAR 54
109128: PUSH
109129: LD_VAR 0 1
109133: ST_TO_ADDR
// end ;
109134: LD_VAR 0 2
109138: RET
// export function Join ( array , element ) ; begin
109139: LD_INT 0
109141: PPUSH
// result := Replace ( array , array + 1 , element ) ;
109142: LD_ADDR_VAR 0 3
109146: PUSH
109147: LD_VAR 0 1
109151: PPUSH
109152: LD_VAR 0 1
109156: PUSH
109157: LD_INT 1
109159: PLUS
109160: PPUSH
109161: LD_VAR 0 2
109165: PPUSH
109166: CALL_OW 1
109170: ST_TO_ADDR
// end ;
109171: LD_VAR 0 3
109175: RET
// export function JoinUnion ( array , element ) ; begin
109176: LD_INT 0
109178: PPUSH
// result := array union element ;
109179: LD_ADDR_VAR 0 3
109183: PUSH
109184: LD_VAR 0 1
109188: PUSH
109189: LD_VAR 0 2
109193: UNION
109194: ST_TO_ADDR
// end ;
109195: LD_VAR 0 3
109199: RET
// export function GetBehemoths ( side ) ; begin
109200: LD_INT 0
109202: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
109203: LD_ADDR_VAR 0 2
109207: PUSH
109208: LD_INT 22
109210: PUSH
109211: LD_VAR 0 1
109215: PUSH
109216: EMPTY
109217: LIST
109218: LIST
109219: PUSH
109220: LD_INT 31
109222: PUSH
109223: LD_INT 25
109225: PUSH
109226: EMPTY
109227: LIST
109228: LIST
109229: PUSH
109230: EMPTY
109231: LIST
109232: LIST
109233: PPUSH
109234: CALL_OW 69
109238: ST_TO_ADDR
// end ;
109239: LD_VAR 0 2
109243: RET
// export function Shuffle ( array ) ; var i , index ; begin
109244: LD_INT 0
109246: PPUSH
109247: PPUSH
109248: PPUSH
// result := [ ] ;
109249: LD_ADDR_VAR 0 2
109253: PUSH
109254: EMPTY
109255: ST_TO_ADDR
// if not array then
109256: LD_VAR 0 1
109260: NOT
109261: IFFALSE 109265
// exit ;
109263: GO 109364
// Randomize ;
109265: CALL_OW 10
// for i = array downto 1 do
109269: LD_ADDR_VAR 0 3
109273: PUSH
109274: DOUBLE
109275: LD_VAR 0 1
109279: INC
109280: ST_TO_ADDR
109281: LD_INT 1
109283: PUSH
109284: FOR_DOWNTO
109285: IFFALSE 109362
// begin index := rand ( 1 , array ) ;
109287: LD_ADDR_VAR 0 4
109291: PUSH
109292: LD_INT 1
109294: PPUSH
109295: LD_VAR 0 1
109299: PPUSH
109300: CALL_OW 12
109304: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
109305: LD_ADDR_VAR 0 2
109309: PUSH
109310: LD_VAR 0 2
109314: PPUSH
109315: LD_VAR 0 2
109319: PUSH
109320: LD_INT 1
109322: PLUS
109323: PPUSH
109324: LD_VAR 0 1
109328: PUSH
109329: LD_VAR 0 4
109333: ARRAY
109334: PPUSH
109335: CALL_OW 2
109339: ST_TO_ADDR
// array := Delete ( array , index ) ;
109340: LD_ADDR_VAR 0 1
109344: PUSH
109345: LD_VAR 0 1
109349: PPUSH
109350: LD_VAR 0 4
109354: PPUSH
109355: CALL_OW 3
109359: ST_TO_ADDR
// end ;
109360: GO 109284
109362: POP
109363: POP
// end ;
109364: LD_VAR 0 2
109368: RET
// export function GetBaseMaterials ( base ) ; begin
109369: LD_INT 0
109371: PPUSH
// result := [ 0 , 0 , 0 ] ;
109372: LD_ADDR_VAR 0 2
109376: PUSH
109377: LD_INT 0
109379: PUSH
109380: LD_INT 0
109382: PUSH
109383: LD_INT 0
109385: PUSH
109386: EMPTY
109387: LIST
109388: LIST
109389: LIST
109390: ST_TO_ADDR
// if not base then
109391: LD_VAR 0 1
109395: NOT
109396: IFFALSE 109400
// exit ;
109398: GO 109449
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
109400: LD_ADDR_VAR 0 2
109404: PUSH
109405: LD_VAR 0 1
109409: PPUSH
109410: LD_INT 1
109412: PPUSH
109413: CALL_OW 275
109417: PUSH
109418: LD_VAR 0 1
109422: PPUSH
109423: LD_INT 2
109425: PPUSH
109426: CALL_OW 275
109430: PUSH
109431: LD_VAR 0 1
109435: PPUSH
109436: LD_INT 3
109438: PPUSH
109439: CALL_OW 275
109443: PUSH
109444: EMPTY
109445: LIST
109446: LIST
109447: LIST
109448: ST_TO_ADDR
// end ;
109449: LD_VAR 0 2
109453: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
109454: LD_INT 0
109456: PPUSH
109457: PPUSH
// result := array ;
109458: LD_ADDR_VAR 0 3
109462: PUSH
109463: LD_VAR 0 1
109467: ST_TO_ADDR
// if size >= result then
109468: LD_VAR 0 2
109472: PUSH
109473: LD_VAR 0 3
109477: GREATEREQUAL
109478: IFFALSE 109482
// exit ;
109480: GO 109532
// if size then
109482: LD_VAR 0 2
109486: IFFALSE 109532
// for i := array downto size do
109488: LD_ADDR_VAR 0 4
109492: PUSH
109493: DOUBLE
109494: LD_VAR 0 1
109498: INC
109499: ST_TO_ADDR
109500: LD_VAR 0 2
109504: PUSH
109505: FOR_DOWNTO
109506: IFFALSE 109530
// result := Delete ( result , result ) ;
109508: LD_ADDR_VAR 0 3
109512: PUSH
109513: LD_VAR 0 3
109517: PPUSH
109518: LD_VAR 0 3
109522: PPUSH
109523: CALL_OW 3
109527: ST_TO_ADDR
109528: GO 109505
109530: POP
109531: POP
// end ;
109532: LD_VAR 0 3
109536: RET
// export function ComExit ( unit ) ; var tmp ; begin
109537: LD_INT 0
109539: PPUSH
109540: PPUSH
// if not IsInUnit ( unit ) then
109541: LD_VAR 0 1
109545: PPUSH
109546: CALL_OW 310
109550: NOT
109551: IFFALSE 109555
// exit ;
109553: GO 109615
// tmp := IsInUnit ( unit ) ;
109555: LD_ADDR_VAR 0 3
109559: PUSH
109560: LD_VAR 0 1
109564: PPUSH
109565: CALL_OW 310
109569: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
109570: LD_VAR 0 3
109574: PPUSH
109575: CALL_OW 247
109579: PUSH
109580: LD_INT 2
109582: EQUAL
109583: IFFALSE 109596
// ComExitVehicle ( unit ) else
109585: LD_VAR 0 1
109589: PPUSH
109590: CALL_OW 121
109594: GO 109605
// ComExitBuilding ( unit ) ;
109596: LD_VAR 0 1
109600: PPUSH
109601: CALL_OW 122
// result := tmp ;
109605: LD_ADDR_VAR 0 2
109609: PUSH
109610: LD_VAR 0 3
109614: ST_TO_ADDR
// end ;
109615: LD_VAR 0 2
109619: RET
// export function ComExitAll ( units ) ; var i ; begin
109620: LD_INT 0
109622: PPUSH
109623: PPUSH
// if not units then
109624: LD_VAR 0 1
109628: NOT
109629: IFFALSE 109633
// exit ;
109631: GO 109659
// for i in units do
109633: LD_ADDR_VAR 0 3
109637: PUSH
109638: LD_VAR 0 1
109642: PUSH
109643: FOR_IN
109644: IFFALSE 109657
// ComExit ( i ) ;
109646: LD_VAR 0 3
109650: PPUSH
109651: CALL 109537 0 1
109655: GO 109643
109657: POP
109658: POP
// end ;
109659: LD_VAR 0 2
109663: RET
// export function ResetHc ; begin
109664: LD_INT 0
109666: PPUSH
// InitHc ;
109667: CALL_OW 19
// hc_importance := 0 ;
109671: LD_ADDR_OWVAR 32
109675: PUSH
109676: LD_INT 0
109678: ST_TO_ADDR
// end ;
109679: LD_VAR 0 1
109683: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
109684: LD_INT 0
109686: PPUSH
109687: PPUSH
109688: PPUSH
// _x := ( x1 + x2 ) div 2 ;
109689: LD_ADDR_VAR 0 6
109693: PUSH
109694: LD_VAR 0 1
109698: PUSH
109699: LD_VAR 0 3
109703: PLUS
109704: PUSH
109705: LD_INT 2
109707: DIV
109708: ST_TO_ADDR
// if _x < 0 then
109709: LD_VAR 0 6
109713: PUSH
109714: LD_INT 0
109716: LESS
109717: IFFALSE 109734
// _x := _x * - 1 ;
109719: LD_ADDR_VAR 0 6
109723: PUSH
109724: LD_VAR 0 6
109728: PUSH
109729: LD_INT 1
109731: NEG
109732: MUL
109733: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
109734: LD_ADDR_VAR 0 7
109738: PUSH
109739: LD_VAR 0 2
109743: PUSH
109744: LD_VAR 0 4
109748: PLUS
109749: PUSH
109750: LD_INT 2
109752: DIV
109753: ST_TO_ADDR
// if _y < 0 then
109754: LD_VAR 0 7
109758: PUSH
109759: LD_INT 0
109761: LESS
109762: IFFALSE 109779
// _y := _y * - 1 ;
109764: LD_ADDR_VAR 0 7
109768: PUSH
109769: LD_VAR 0 7
109773: PUSH
109774: LD_INT 1
109776: NEG
109777: MUL
109778: ST_TO_ADDR
// result := [ _x , _y ] ;
109779: LD_ADDR_VAR 0 5
109783: PUSH
109784: LD_VAR 0 6
109788: PUSH
109789: LD_VAR 0 7
109793: PUSH
109794: EMPTY
109795: LIST
109796: LIST
109797: ST_TO_ADDR
// end ;
109798: LD_VAR 0 5
109802: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
109803: LD_INT 0
109805: PPUSH
109806: PPUSH
109807: PPUSH
109808: PPUSH
// task := GetTaskList ( unit ) ;
109809: LD_ADDR_VAR 0 7
109813: PUSH
109814: LD_VAR 0 1
109818: PPUSH
109819: CALL_OW 437
109823: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
109824: LD_VAR 0 7
109828: NOT
109829: IFFALSE 109848
109831: PUSH
109832: LD_VAR 0 1
109836: PPUSH
109837: LD_VAR 0 2
109841: PPUSH
109842: CALL_OW 308
109846: NOT
109847: AND
109848: IFFALSE 109852
// exit ;
109850: GO 109970
// if IsInArea ( unit , area ) then
109852: LD_VAR 0 1
109856: PPUSH
109857: LD_VAR 0 2
109861: PPUSH
109862: CALL_OW 308
109866: IFFALSE 109884
// begin ComMoveToArea ( unit , goAway ) ;
109868: LD_VAR 0 1
109872: PPUSH
109873: LD_VAR 0 3
109877: PPUSH
109878: CALL_OW 113
// exit ;
109882: GO 109970
// end ; if task [ 1 ] [ 1 ] <> M then
109884: LD_VAR 0 7
109888: PUSH
109889: LD_INT 1
109891: ARRAY
109892: PUSH
109893: LD_INT 1
109895: ARRAY
109896: PUSH
109897: LD_STRING M
109899: NONEQUAL
109900: IFFALSE 109904
// exit ;
109902: GO 109970
// x := task [ 1 ] [ 2 ] ;
109904: LD_ADDR_VAR 0 5
109908: PUSH
109909: LD_VAR 0 7
109913: PUSH
109914: LD_INT 1
109916: ARRAY
109917: PUSH
109918: LD_INT 2
109920: ARRAY
109921: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
109922: LD_ADDR_VAR 0 6
109926: PUSH
109927: LD_VAR 0 7
109931: PUSH
109932: LD_INT 1
109934: ARRAY
109935: PUSH
109936: LD_INT 3
109938: ARRAY
109939: ST_TO_ADDR
// if InArea ( x , y , area ) then
109940: LD_VAR 0 5
109944: PPUSH
109945: LD_VAR 0 6
109949: PPUSH
109950: LD_VAR 0 2
109954: PPUSH
109955: CALL_OW 309
109959: IFFALSE 109970
// ComStop ( unit ) ;
109961: LD_VAR 0 1
109965: PPUSH
109966: CALL_OW 141
// end ;
109970: LD_VAR 0 4
109974: RET
// export function Abs ( value ) ; begin
109975: LD_INT 0
109977: PPUSH
// result := value ;
109978: LD_ADDR_VAR 0 2
109982: PUSH
109983: LD_VAR 0 1
109987: ST_TO_ADDR
// if value < 0 then
109988: LD_VAR 0 1
109992: PUSH
109993: LD_INT 0
109995: LESS
109996: IFFALSE 110013
// result := value * - 1 ;
109998: LD_ADDR_VAR 0 2
110002: PUSH
110003: LD_VAR 0 1
110007: PUSH
110008: LD_INT 1
110010: NEG
110011: MUL
110012: ST_TO_ADDR
// end ;
110013: LD_VAR 0 2
110017: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
110018: LD_INT 0
110020: PPUSH
110021: PPUSH
110022: PPUSH
110023: PPUSH
110024: PPUSH
110025: PPUSH
110026: PPUSH
110027: PPUSH
// if not unit or not building then
110028: LD_VAR 0 1
110032: NOT
110033: IFTRUE 110042
110035: PUSH
110036: LD_VAR 0 2
110040: NOT
110041: OR
110042: IFFALSE 110046
// exit ;
110044: GO 110274
// x := GetX ( building ) ;
110046: LD_ADDR_VAR 0 4
110050: PUSH
110051: LD_VAR 0 2
110055: PPUSH
110056: CALL_OW 250
110060: ST_TO_ADDR
// y := GetY ( building ) ;
110061: LD_ADDR_VAR 0 6
110065: PUSH
110066: LD_VAR 0 2
110070: PPUSH
110071: CALL_OW 251
110075: ST_TO_ADDR
// d := GetDir ( building ) ;
110076: LD_ADDR_VAR 0 8
110080: PUSH
110081: LD_VAR 0 2
110085: PPUSH
110086: CALL_OW 254
110090: ST_TO_ADDR
// r := 4 ;
110091: LD_ADDR_VAR 0 9
110095: PUSH
110096: LD_INT 4
110098: ST_TO_ADDR
// for i := 1 to 5 do
110099: LD_ADDR_VAR 0 10
110103: PUSH
110104: DOUBLE
110105: LD_INT 1
110107: DEC
110108: ST_TO_ADDR
110109: LD_INT 5
110111: PUSH
110112: FOR_TO
110113: IFFALSE 110272
// begin _x := ShiftX ( x , d , r + i ) ;
110115: LD_ADDR_VAR 0 5
110119: PUSH
110120: LD_VAR 0 4
110124: PPUSH
110125: LD_VAR 0 8
110129: PPUSH
110130: LD_VAR 0 9
110134: PUSH
110135: LD_VAR 0 10
110139: PLUS
110140: PPUSH
110141: CALL_OW 272
110145: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
110146: LD_ADDR_VAR 0 7
110150: PUSH
110151: LD_VAR 0 6
110155: PPUSH
110156: LD_VAR 0 8
110160: PPUSH
110161: LD_VAR 0 9
110165: PUSH
110166: LD_VAR 0 10
110170: PLUS
110171: PPUSH
110172: CALL_OW 273
110176: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
110177: LD_VAR 0 5
110181: PPUSH
110182: LD_VAR 0 7
110186: PPUSH
110187: CALL_OW 488
110191: IFFALSE 110226
110193: PUSH
110194: LD_VAR 0 5
110198: PPUSH
110199: LD_VAR 0 7
110203: PPUSH
110204: CALL_OW 428
110208: PPUSH
110209: CALL_OW 247
110213: PUSH
110214: LD_INT 3
110216: PUSH
110217: LD_INT 2
110219: PUSH
110220: EMPTY
110221: LIST
110222: LIST
110223: IN
110224: NOT
110225: AND
110226: IFFALSE 110270
// begin ComMoveXY ( unit , _x , _y ) ;
110228: LD_VAR 0 1
110232: PPUSH
110233: LD_VAR 0 5
110237: PPUSH
110238: LD_VAR 0 7
110242: PPUSH
110243: CALL_OW 111
// result := [ _x , _y ] ;
110247: LD_ADDR_VAR 0 3
110251: PUSH
110252: LD_VAR 0 5
110256: PUSH
110257: LD_VAR 0 7
110261: PUSH
110262: EMPTY
110263: LIST
110264: LIST
110265: ST_TO_ADDR
// exit ;
110266: POP
110267: POP
110268: GO 110274
// end ; end ;
110270: GO 110112
110272: POP
110273: POP
// end ;
110274: LD_VAR 0 3
110278: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
110279: LD_INT 0
110281: PPUSH
110282: PPUSH
110283: PPUSH
// result := 0 ;
110284: LD_ADDR_VAR 0 3
110288: PUSH
110289: LD_INT 0
110291: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
110292: LD_VAR 0 1
110296: PUSH
110297: LD_INT 0
110299: LESS
110300: IFTRUE 110312
110302: PUSH
110303: LD_VAR 0 1
110307: PUSH
110308: LD_INT 8
110310: GREATER
110311: OR
110312: IFTRUE 110324
110314: PUSH
110315: LD_VAR 0 2
110319: PUSH
110320: LD_INT 0
110322: LESS
110323: OR
110324: IFTRUE 110336
110326: PUSH
110327: LD_VAR 0 2
110331: PUSH
110332: LD_INT 8
110334: GREATER
110335: OR
110336: IFFALSE 110340
// exit ;
110338: GO 110415
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
110340: LD_ADDR_VAR 0 4
110344: PUSH
110345: LD_INT 22
110347: PUSH
110348: LD_VAR 0 2
110352: PUSH
110353: EMPTY
110354: LIST
110355: LIST
110356: PPUSH
110357: CALL_OW 69
110361: PUSH
110362: FOR_IN
110363: IFFALSE 110413
// begin un := UnitShoot ( i ) ;
110365: LD_ADDR_VAR 0 5
110369: PUSH
110370: LD_VAR 0 4
110374: PPUSH
110375: CALL_OW 504
110379: ST_TO_ADDR
// if GetSide ( un ) = side1 then
110380: LD_VAR 0 5
110384: PPUSH
110385: CALL_OW 255
110389: PUSH
110390: LD_VAR 0 1
110394: EQUAL
110395: IFFALSE 110411
// begin result := un ;
110397: LD_ADDR_VAR 0 3
110401: PUSH
110402: LD_VAR 0 5
110406: ST_TO_ADDR
// exit ;
110407: POP
110408: POP
110409: GO 110415
// end ; end ;
110411: GO 110362
110413: POP
110414: POP
// end ;
110415: LD_VAR 0 3
110419: RET
// export function GetCargoBay ( units ) ; begin
110420: LD_INT 0
110422: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
110423: LD_ADDR_VAR 0 2
110427: PUSH
110428: LD_VAR 0 1
110432: PPUSH
110433: LD_INT 2
110435: PUSH
110436: LD_INT 34
110438: PUSH
110439: LD_INT 12
110441: PUSH
110442: EMPTY
110443: LIST
110444: LIST
110445: PUSH
110446: LD_INT 34
110448: PUSH
110449: LD_INT 51
110451: PUSH
110452: EMPTY
110453: LIST
110454: LIST
110455: PUSH
110456: LD_INT 34
110458: PUSH
110459: LD_INT 32
110461: PUSH
110462: EMPTY
110463: LIST
110464: LIST
110465: PUSH
110466: LD_INT 34
110468: PUSH
110469: LD_INT 89
110471: PUSH
110472: EMPTY
110473: LIST
110474: LIST
110475: PUSH
110476: EMPTY
110477: LIST
110478: LIST
110479: LIST
110480: LIST
110481: LIST
110482: PPUSH
110483: CALL_OW 72
110487: ST_TO_ADDR
// end ;
110488: LD_VAR 0 2
110492: RET
// export function Negate ( value ) ; begin
110493: LD_INT 0
110495: PPUSH
// result := not value ;
110496: LD_ADDR_VAR 0 2
110500: PUSH
110501: LD_VAR 0 1
110505: NOT
110506: ST_TO_ADDR
// end ;
110507: LD_VAR 0 2
110511: RET
// export function Inc ( value ) ; begin
110512: LD_INT 0
110514: PPUSH
// result := value + 1 ;
110515: LD_ADDR_VAR 0 2
110519: PUSH
110520: LD_VAR 0 1
110524: PUSH
110525: LD_INT 1
110527: PLUS
110528: ST_TO_ADDR
// end ;
110529: LD_VAR 0 2
110533: RET
// export function Dec ( value ) ; begin
110534: LD_INT 0
110536: PPUSH
// result := value - 1 ;
110537: LD_ADDR_VAR 0 2
110541: PUSH
110542: LD_VAR 0 1
110546: PUSH
110547: LD_INT 1
110549: MINUS
110550: ST_TO_ADDR
// end ;
110551: LD_VAR 0 2
110555: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
110556: LD_INT 0
110558: PPUSH
110559: PPUSH
110560: PPUSH
110561: PPUSH
110562: PPUSH
110563: PPUSH
110564: PPUSH
110565: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
110566: LD_VAR 0 1
110570: PPUSH
110571: LD_VAR 0 2
110575: PPUSH
110576: CALL_OW 488
110580: NOT
110581: IFTRUE 110600
110583: PUSH
110584: LD_VAR 0 3
110588: PPUSH
110589: LD_VAR 0 4
110593: PPUSH
110594: CALL_OW 488
110598: NOT
110599: OR
110600: IFFALSE 110613
// begin result := - 1 ;
110602: LD_ADDR_VAR 0 5
110606: PUSH
110607: LD_INT 1
110609: NEG
110610: ST_TO_ADDR
// exit ;
110611: GO 110848
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
110613: LD_ADDR_VAR 0 12
110617: PUSH
110618: LD_VAR 0 1
110622: PPUSH
110623: LD_VAR 0 2
110627: PPUSH
110628: LD_VAR 0 3
110632: PPUSH
110633: LD_VAR 0 4
110637: PPUSH
110638: CALL 109684 0 4
110642: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
110643: LD_ADDR_VAR 0 11
110647: PUSH
110648: LD_VAR 0 1
110652: PPUSH
110653: LD_VAR 0 2
110657: PPUSH
110658: LD_VAR 0 12
110662: PUSH
110663: LD_INT 1
110665: ARRAY
110666: PPUSH
110667: LD_VAR 0 12
110671: PUSH
110672: LD_INT 2
110674: ARRAY
110675: PPUSH
110676: CALL_OW 298
110680: ST_TO_ADDR
// distance := 9999 ;
110681: LD_ADDR_VAR 0 10
110685: PUSH
110686: LD_INT 9999
110688: ST_TO_ADDR
// for i := 0 to 5 do
110689: LD_ADDR_VAR 0 6
110693: PUSH
110694: DOUBLE
110695: LD_INT 0
110697: DEC
110698: ST_TO_ADDR
110699: LD_INT 5
110701: PUSH
110702: FOR_TO
110703: IFFALSE 110846
// begin _x := ShiftX ( x1 , i , centerDist ) ;
110705: LD_ADDR_VAR 0 7
110709: PUSH
110710: LD_VAR 0 1
110714: PPUSH
110715: LD_VAR 0 6
110719: PPUSH
110720: LD_VAR 0 11
110724: PPUSH
110725: CALL_OW 272
110729: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
110730: LD_ADDR_VAR 0 8
110734: PUSH
110735: LD_VAR 0 2
110739: PPUSH
110740: LD_VAR 0 6
110744: PPUSH
110745: LD_VAR 0 11
110749: PPUSH
110750: CALL_OW 273
110754: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110755: LD_VAR 0 7
110759: PPUSH
110760: LD_VAR 0 8
110764: PPUSH
110765: CALL_OW 488
110769: NOT
110770: IFFALSE 110774
// continue ;
110772: GO 110702
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
110774: LD_ADDR_VAR 0 9
110778: PUSH
110779: LD_VAR 0 12
110783: PUSH
110784: LD_INT 1
110786: ARRAY
110787: PPUSH
110788: LD_VAR 0 12
110792: PUSH
110793: LD_INT 2
110795: ARRAY
110796: PPUSH
110797: LD_VAR 0 7
110801: PPUSH
110802: LD_VAR 0 8
110806: PPUSH
110807: CALL_OW 298
110811: ST_TO_ADDR
// if tmp < distance then
110812: LD_VAR 0 9
110816: PUSH
110817: LD_VAR 0 10
110821: LESS
110822: IFFALSE 110844
// begin result := i ;
110824: LD_ADDR_VAR 0 5
110828: PUSH
110829: LD_VAR 0 6
110833: ST_TO_ADDR
// distance := tmp ;
110834: LD_ADDR_VAR 0 10
110838: PUSH
110839: LD_VAR 0 9
110843: ST_TO_ADDR
// end ; end ;
110844: GO 110702
110846: POP
110847: POP
// end ;
110848: LD_VAR 0 5
110852: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
110853: LD_INT 0
110855: PPUSH
110856: PPUSH
// if not driver or not IsInUnit ( driver ) then
110857: LD_VAR 0 1
110861: NOT
110862: IFTRUE 110876
110864: PUSH
110865: LD_VAR 0 1
110869: PPUSH
110870: CALL_OW 310
110874: NOT
110875: OR
110876: IFFALSE 110880
// exit ;
110878: GO 110970
// vehicle := IsInUnit ( driver ) ;
110880: LD_ADDR_VAR 0 3
110884: PUSH
110885: LD_VAR 0 1
110889: PPUSH
110890: CALL_OW 310
110894: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
110895: LD_VAR 0 1
110899: PPUSH
110900: LD_STRING \
110902: PUSH
110903: LD_INT 0
110905: PUSH
110906: LD_INT 0
110908: PUSH
110909: LD_INT 0
110911: PUSH
110912: LD_INT 0
110914: PUSH
110915: LD_INT 0
110917: PUSH
110918: LD_INT 0
110920: PUSH
110921: EMPTY
110922: LIST
110923: LIST
110924: LIST
110925: LIST
110926: LIST
110927: LIST
110928: LIST
110929: PUSH
110930: LD_STRING E
110932: PUSH
110933: LD_INT 0
110935: PUSH
110936: LD_INT 0
110938: PUSH
110939: LD_VAR 0 3
110943: PUSH
110944: LD_INT 0
110946: PUSH
110947: LD_INT 0
110949: PUSH
110950: LD_INT 0
110952: PUSH
110953: EMPTY
110954: LIST
110955: LIST
110956: LIST
110957: LIST
110958: LIST
110959: LIST
110960: LIST
110961: PUSH
110962: EMPTY
110963: LIST
110964: LIST
110965: PPUSH
110966: CALL_OW 446
// end ;
110970: LD_VAR 0 2
110974: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
110975: LD_INT 0
110977: PPUSH
110978: PPUSH
// if not driver or not IsInUnit ( driver ) then
110979: LD_VAR 0 1
110983: NOT
110984: IFTRUE 110998
110986: PUSH
110987: LD_VAR 0 1
110991: PPUSH
110992: CALL_OW 310
110996: NOT
110997: OR
110998: IFFALSE 111002
// exit ;
111000: GO 111092
// vehicle := IsInUnit ( driver ) ;
111002: LD_ADDR_VAR 0 3
111006: PUSH
111007: LD_VAR 0 1
111011: PPUSH
111012: CALL_OW 310
111016: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
111017: LD_VAR 0 1
111021: PPUSH
111022: LD_STRING \
111024: PUSH
111025: LD_INT 0
111027: PUSH
111028: LD_INT 0
111030: PUSH
111031: LD_INT 0
111033: PUSH
111034: LD_INT 0
111036: PUSH
111037: LD_INT 0
111039: PUSH
111040: LD_INT 0
111042: PUSH
111043: EMPTY
111044: LIST
111045: LIST
111046: LIST
111047: LIST
111048: LIST
111049: LIST
111050: LIST
111051: PUSH
111052: LD_STRING E
111054: PUSH
111055: LD_INT 0
111057: PUSH
111058: LD_INT 0
111060: PUSH
111061: LD_VAR 0 3
111065: PUSH
111066: LD_INT 0
111068: PUSH
111069: LD_INT 0
111071: PUSH
111072: LD_INT 0
111074: PUSH
111075: EMPTY
111076: LIST
111077: LIST
111078: LIST
111079: LIST
111080: LIST
111081: LIST
111082: LIST
111083: PUSH
111084: EMPTY
111085: LIST
111086: LIST
111087: PPUSH
111088: CALL_OW 447
// end ;
111092: LD_VAR 0 2
111096: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
111097: LD_INT 0
111099: PPUSH
111100: PPUSH
111101: PPUSH
// tmp := [ ] ;
111102: LD_ADDR_VAR 0 5
111106: PUSH
111107: EMPTY
111108: ST_TO_ADDR
// for i in units do
111109: LD_ADDR_VAR 0 4
111113: PUSH
111114: LD_VAR 0 1
111118: PUSH
111119: FOR_IN
111120: IFFALSE 111158
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
111122: LD_ADDR_VAR 0 5
111126: PUSH
111127: LD_VAR 0 5
111131: PPUSH
111132: LD_VAR 0 5
111136: PUSH
111137: LD_INT 1
111139: PLUS
111140: PPUSH
111141: LD_VAR 0 4
111145: PPUSH
111146: CALL_OW 256
111150: PPUSH
111151: CALL_OW 2
111155: ST_TO_ADDR
111156: GO 111119
111158: POP
111159: POP
// if not tmp then
111160: LD_VAR 0 5
111164: NOT
111165: IFFALSE 111169
// exit ;
111167: GO 111217
// if asc then
111169: LD_VAR 0 2
111173: IFFALSE 111197
// result := SortListByListAsc ( units , tmp ) else
111175: LD_ADDR_VAR 0 3
111179: PUSH
111180: LD_VAR 0 1
111184: PPUSH
111185: LD_VAR 0 5
111189: PPUSH
111190: CALL_OW 76
111194: ST_TO_ADDR
111195: GO 111217
// result := SortListByListDesc ( units , tmp ) ;
111197: LD_ADDR_VAR 0 3
111201: PUSH
111202: LD_VAR 0 1
111206: PPUSH
111207: LD_VAR 0 5
111211: PPUSH
111212: CALL_OW 77
111216: ST_TO_ADDR
// end ;
111217: LD_VAR 0 3
111221: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
111222: LD_INT 0
111224: PPUSH
111225: PPUSH
// task := GetTaskList ( mech ) ;
111226: LD_ADDR_VAR 0 4
111230: PUSH
111231: LD_VAR 0 1
111235: PPUSH
111236: CALL_OW 437
111240: ST_TO_ADDR
// if not task then
111241: LD_VAR 0 4
111245: NOT
111246: IFFALSE 111250
// exit ;
111248: GO 111294
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
111250: LD_ADDR_VAR 0 3
111254: PUSH
111255: LD_VAR 0 4
111259: PUSH
111260: LD_INT 1
111262: ARRAY
111263: PUSH
111264: LD_INT 1
111266: ARRAY
111267: PUSH
111268: LD_STRING r
111270: EQUAL
111271: IFFALSE 111293
111273: PUSH
111274: LD_VAR 0 4
111278: PUSH
111279: LD_INT 1
111281: ARRAY
111282: PUSH
111283: LD_INT 4
111285: ARRAY
111286: PUSH
111287: LD_VAR 0 2
111291: EQUAL
111292: AND
111293: ST_TO_ADDR
// end ;
111294: LD_VAR 0 3
111298: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
111299: LD_INT 0
111301: PPUSH
// SetDir ( unit , d ) ;
111302: LD_VAR 0 1
111306: PPUSH
111307: LD_VAR 0 4
111311: PPUSH
111312: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
111316: LD_ADDR_VAR 0 6
111320: PUSH
111321: LD_VAR 0 1
111325: PPUSH
111326: LD_VAR 0 2
111330: PPUSH
111331: LD_VAR 0 3
111335: PPUSH
111336: LD_VAR 0 5
111340: PPUSH
111341: CALL_OW 48
111345: ST_TO_ADDR
// end ;
111346: LD_VAR 0 6
111350: RET
// export function ToNaturalNumber ( number ) ; begin
111351: LD_INT 0
111353: PPUSH
// result := number div 1 ;
111354: LD_ADDR_VAR 0 2
111358: PUSH
111359: LD_VAR 0 1
111363: PUSH
111364: LD_INT 1
111366: DIV
111367: ST_TO_ADDR
// if number < 0 then
111368: LD_VAR 0 1
111372: PUSH
111373: LD_INT 0
111375: LESS
111376: IFFALSE 111386
// result := 0 ;
111378: LD_ADDR_VAR 0 2
111382: PUSH
111383: LD_INT 0
111385: ST_TO_ADDR
// end ;
111386: LD_VAR 0 2
111390: RET
// export function SortByBType ( buildings , asc ) ; var b , tmp ; begin
111391: LD_INT 0
111393: PPUSH
111394: PPUSH
111395: PPUSH
// if not buildings then
111396: LD_VAR 0 1
111400: NOT
111401: IFFALSE 111405
// exit ;
111403: GO 111520
// tmp := [ ] ;
111405: LD_ADDR_VAR 0 5
111409: PUSH
111410: EMPTY
111411: ST_TO_ADDR
// for b in buildings do
111412: LD_ADDR_VAR 0 4
111416: PUSH
111417: LD_VAR 0 1
111421: PUSH
111422: FOR_IN
111423: IFFALSE 111461
// tmp := Replace ( tmp , tmp + 1 , GetBType ( b ) ) ;
111425: LD_ADDR_VAR 0 5
111429: PUSH
111430: LD_VAR 0 5
111434: PPUSH
111435: LD_VAR 0 5
111439: PUSH
111440: LD_INT 1
111442: PLUS
111443: PPUSH
111444: LD_VAR 0 4
111448: PPUSH
111449: CALL_OW 266
111453: PPUSH
111454: CALL_OW 1
111458: ST_TO_ADDR
111459: GO 111422
111461: POP
111462: POP
// if not tmp then
111463: LD_VAR 0 5
111467: NOT
111468: IFFALSE 111472
// exit ;
111470: GO 111520
// if asc then
111472: LD_VAR 0 2
111476: IFFALSE 111500
// result := SortListByListAsc ( buildings , tmp ) else
111478: LD_ADDR_VAR 0 3
111482: PUSH
111483: LD_VAR 0 1
111487: PPUSH
111488: LD_VAR 0 5
111492: PPUSH
111493: CALL_OW 76
111497: ST_TO_ADDR
111498: GO 111520
// result := SortListByListDesc ( buildings , tmp ) ;
111500: LD_ADDR_VAR 0 3
111504: PUSH
111505: LD_VAR 0 1
111509: PPUSH
111510: LD_VAR 0 5
111514: PPUSH
111515: CALL_OW 77
111519: ST_TO_ADDR
// end ;
111520: LD_VAR 0 3
111524: RET
// export function SortByClass ( units , class ) ; var un ; begin
111525: LD_INT 0
111527: PPUSH
111528: PPUSH
// if not units or not class then
111529: LD_VAR 0 1
111533: NOT
111534: IFTRUE 111543
111536: PUSH
111537: LD_VAR 0 2
111541: NOT
111542: OR
111543: IFFALSE 111547
// exit ;
111545: GO 111642
// result := [ ] ;
111547: LD_ADDR_VAR 0 3
111551: PUSH
111552: EMPTY
111553: ST_TO_ADDR
// for un in units do
111554: LD_ADDR_VAR 0 4
111558: PUSH
111559: LD_VAR 0 1
111563: PUSH
111564: FOR_IN
111565: IFFALSE 111640
// if GetClass ( un ) = class then
111567: LD_VAR 0 4
111571: PPUSH
111572: CALL_OW 257
111576: PUSH
111577: LD_VAR 0 2
111581: EQUAL
111582: IFFALSE 111609
// result := Insert ( result , 1 , un ) else
111584: LD_ADDR_VAR 0 3
111588: PUSH
111589: LD_VAR 0 3
111593: PPUSH
111594: LD_INT 1
111596: PPUSH
111597: LD_VAR 0 4
111601: PPUSH
111602: CALL_OW 2
111606: ST_TO_ADDR
111607: GO 111638
// result := Replace ( result , result + 1 , un ) ;
111609: LD_ADDR_VAR 0 3
111613: PUSH
111614: LD_VAR 0 3
111618: PPUSH
111619: LD_VAR 0 3
111623: PUSH
111624: LD_INT 1
111626: PLUS
111627: PPUSH
111628: LD_VAR 0 4
111632: PPUSH
111633: CALL_OW 1
111637: ST_TO_ADDR
111638: GO 111564
111640: POP
111641: POP
// end ;
111642: LD_VAR 0 3
111646: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
111647: LD_INT 0
111649: PPUSH
111650: PPUSH
111651: PPUSH
111652: PPUSH
111653: PPUSH
111654: PPUSH
111655: PPUSH
// result := [ ] ;
111656: LD_ADDR_VAR 0 4
111660: PUSH
111661: EMPTY
111662: ST_TO_ADDR
// if x - r < 0 then
111663: LD_VAR 0 1
111667: PUSH
111668: LD_VAR 0 3
111672: MINUS
111673: PUSH
111674: LD_INT 0
111676: LESS
111677: IFFALSE 111689
// min_x := 0 else
111679: LD_ADDR_VAR 0 8
111683: PUSH
111684: LD_INT 0
111686: ST_TO_ADDR
111687: GO 111705
// min_x := x - r ;
111689: LD_ADDR_VAR 0 8
111693: PUSH
111694: LD_VAR 0 1
111698: PUSH
111699: LD_VAR 0 3
111703: MINUS
111704: ST_TO_ADDR
// if y - r < 0 then
111705: LD_VAR 0 2
111709: PUSH
111710: LD_VAR 0 3
111714: MINUS
111715: PUSH
111716: LD_INT 0
111718: LESS
111719: IFFALSE 111731
// min_y := 0 else
111721: LD_ADDR_VAR 0 7
111725: PUSH
111726: LD_INT 0
111728: ST_TO_ADDR
111729: GO 111747
// min_y := y - r ;
111731: LD_ADDR_VAR 0 7
111735: PUSH
111736: LD_VAR 0 2
111740: PUSH
111741: LD_VAR 0 3
111745: MINUS
111746: ST_TO_ADDR
// max_x := x + r ;
111747: LD_ADDR_VAR 0 9
111751: PUSH
111752: LD_VAR 0 1
111756: PUSH
111757: LD_VAR 0 3
111761: PLUS
111762: ST_TO_ADDR
// max_y := y + r ;
111763: LD_ADDR_VAR 0 10
111767: PUSH
111768: LD_VAR 0 2
111772: PUSH
111773: LD_VAR 0 3
111777: PLUS
111778: ST_TO_ADDR
// for _x = min_x to max_x do
111779: LD_ADDR_VAR 0 5
111783: PUSH
111784: DOUBLE
111785: LD_VAR 0 8
111789: DEC
111790: ST_TO_ADDR
111791: LD_VAR 0 9
111795: PUSH
111796: FOR_TO
111797: IFFALSE 111898
// for _y = min_y to max_y do
111799: LD_ADDR_VAR 0 6
111803: PUSH
111804: DOUBLE
111805: LD_VAR 0 7
111809: DEC
111810: ST_TO_ADDR
111811: LD_VAR 0 10
111815: PUSH
111816: FOR_TO
111817: IFFALSE 111894
// begin if not ValidHex ( _x , _y ) then
111819: LD_VAR 0 5
111823: PPUSH
111824: LD_VAR 0 6
111828: PPUSH
111829: CALL_OW 488
111833: NOT
111834: IFFALSE 111838
// continue ;
111836: GO 111816
// if GetResourceTypeXY ( _x , _y ) then
111838: LD_VAR 0 5
111842: PPUSH
111843: LD_VAR 0 6
111847: PPUSH
111848: CALL_OW 283
111852: IFFALSE 111892
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
111854: LD_ADDR_VAR 0 4
111858: PUSH
111859: LD_VAR 0 4
111863: PPUSH
111864: LD_VAR 0 4
111868: PUSH
111869: LD_INT 1
111871: PLUS
111872: PPUSH
111873: LD_VAR 0 5
111877: PUSH
111878: LD_VAR 0 6
111882: PUSH
111883: EMPTY
111884: LIST
111885: LIST
111886: PPUSH
111887: CALL_OW 1
111891: ST_TO_ADDR
// end ;
111892: GO 111816
111894: POP
111895: POP
111896: GO 111796
111898: POP
111899: POP
// end ;
111900: LD_VAR 0 4
111904: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
111905: LD_INT 0
111907: PPUSH
111908: PPUSH
111909: PPUSH
111910: PPUSH
111911: PPUSH
111912: PPUSH
111913: PPUSH
111914: PPUSH
// if not units then
111915: LD_VAR 0 1
111919: NOT
111920: IFFALSE 111924
// exit ;
111922: GO 112456
// result := UnitFilter ( units , [ f_ok ] ) ;
111924: LD_ADDR_VAR 0 3
111928: PUSH
111929: LD_VAR 0 1
111933: PPUSH
111934: LD_INT 50
111936: PUSH
111937: EMPTY
111938: LIST
111939: PPUSH
111940: CALL_OW 72
111944: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
111945: LD_ADDR_VAR 0 8
111949: PUSH
111950: LD_VAR 0 1
111954: PUSH
111955: LD_INT 1
111957: ARRAY
111958: PPUSH
111959: CALL_OW 255
111963: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
111964: LD_ADDR_VAR 0 10
111968: PUSH
111969: LD_INT 29
111971: PUSH
111972: LD_INT 91
111974: PUSH
111975: LD_INT 49
111977: PUSH
111978: EMPTY
111979: LIST
111980: LIST
111981: LIST
111982: ST_TO_ADDR
// if not result then
111983: LD_VAR 0 3
111987: NOT
111988: IFFALSE 111992
// exit ;
111990: GO 112456
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
111992: LD_ADDR_VAR 0 5
111996: PUSH
111997: LD_INT 81
111999: PUSH
112000: LD_VAR 0 8
112004: PUSH
112005: EMPTY
112006: LIST
112007: LIST
112008: PPUSH
112009: CALL_OW 69
112013: ST_TO_ADDR
// for i in result do
112014: LD_ADDR_VAR 0 4
112018: PUSH
112019: LD_VAR 0 3
112023: PUSH
112024: FOR_IN
112025: IFFALSE 112454
// begin tag := GetTag ( i ) + 1 ;
112027: LD_ADDR_VAR 0 9
112031: PUSH
112032: LD_VAR 0 4
112036: PPUSH
112037: CALL_OW 110
112041: PUSH
112042: LD_INT 1
112044: PLUS
112045: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
112046: LD_ADDR_VAR 0 7
112050: PUSH
112051: LD_VAR 0 4
112055: PPUSH
112056: CALL_OW 250
112060: PPUSH
112061: LD_VAR 0 4
112065: PPUSH
112066: CALL_OW 251
112070: PPUSH
112071: LD_INT 4
112073: PPUSH
112074: CALL 111647 0 3
112078: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
112079: LD_VAR 0 4
112083: PPUSH
112084: CALL_OW 247
112088: PUSH
112089: LD_INT 2
112091: EQUAL
112092: IFFALSE 112104
112094: PUSH
112095: LD_VAR 0 7
112099: PUSH
112100: LD_INT 2
112102: GREATER
112103: AND
112104: IFFALSE 112124
112106: PUSH
112107: LD_VAR 0 4
112111: PPUSH
112112: CALL_OW 264
112116: PUSH
112117: LD_VAR 0 10
112121: IN
112122: NOT
112123: AND
112124: IFFALSE 112163
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
112126: LD_VAR 0 4
112130: PPUSH
112131: LD_VAR 0 7
112135: PUSH
112136: LD_INT 1
112138: ARRAY
112139: PUSH
112140: LD_INT 1
112142: ARRAY
112143: PPUSH
112144: LD_VAR 0 7
112148: PUSH
112149: LD_INT 1
112151: ARRAY
112152: PUSH
112153: LD_INT 2
112155: ARRAY
112156: PPUSH
112157: CALL_OW 116
112161: GO 112452
// if path > tag then
112163: LD_VAR 0 2
112167: PUSH
112168: LD_VAR 0 9
112172: GREATER
112173: IFFALSE 112381
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
112175: LD_ADDR_VAR 0 6
112179: PUSH
112180: LD_VAR 0 5
112184: PPUSH
112185: LD_INT 91
112187: PUSH
112188: LD_VAR 0 4
112192: PUSH
112193: LD_INT 8
112195: PUSH
112196: EMPTY
112197: LIST
112198: LIST
112199: LIST
112200: PPUSH
112201: CALL_OW 72
112205: ST_TO_ADDR
// if nearEnemy then
112206: LD_VAR 0 6
112210: IFFALSE 112279
// begin if GetWeapon ( i ) = ru_time_lapser then
112212: LD_VAR 0 4
112216: PPUSH
112217: CALL_OW 264
112221: PUSH
112222: LD_INT 49
112224: EQUAL
112225: IFFALSE 112253
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
112227: LD_VAR 0 4
112231: PPUSH
112232: LD_VAR 0 6
112236: PPUSH
112237: LD_VAR 0 4
112241: PPUSH
112242: CALL_OW 74
112246: PPUSH
112247: CALL_OW 112
112251: GO 112277
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
112253: LD_VAR 0 4
112257: PPUSH
112258: LD_VAR 0 6
112262: PPUSH
112263: LD_VAR 0 4
112267: PPUSH
112268: CALL_OW 74
112272: PPUSH
112273: CALL 113537 0 2
// end else
112277: GO 112379
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
112279: LD_VAR 0 4
112283: PPUSH
112284: LD_VAR 0 2
112288: PUSH
112289: LD_VAR 0 9
112293: ARRAY
112294: PUSH
112295: LD_INT 1
112297: ARRAY
112298: PPUSH
112299: LD_VAR 0 2
112303: PUSH
112304: LD_VAR 0 9
112308: ARRAY
112309: PUSH
112310: LD_INT 2
112312: ARRAY
112313: PPUSH
112314: CALL_OW 297
112318: PUSH
112319: LD_INT 6
112321: GREATER
112322: IFFALSE 112365
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
112324: LD_VAR 0 4
112328: PPUSH
112329: LD_VAR 0 2
112333: PUSH
112334: LD_VAR 0 9
112338: ARRAY
112339: PUSH
112340: LD_INT 1
112342: ARRAY
112343: PPUSH
112344: LD_VAR 0 2
112348: PUSH
112349: LD_VAR 0 9
112353: ARRAY
112354: PUSH
112355: LD_INT 2
112357: ARRAY
112358: PPUSH
112359: CALL_OW 114
112363: GO 112379
// SetTag ( i , tag ) ;
112365: LD_VAR 0 4
112369: PPUSH
112370: LD_VAR 0 9
112374: PPUSH
112375: CALL_OW 109
// end else
112379: GO 112452
// if enemy then
112381: LD_VAR 0 5
112385: IFFALSE 112452
// begin if GetWeapon ( i ) = ru_time_lapser then
112387: LD_VAR 0 4
112391: PPUSH
112392: CALL_OW 264
112396: PUSH
112397: LD_INT 49
112399: EQUAL
112400: IFFALSE 112428
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
112402: LD_VAR 0 4
112406: PPUSH
112407: LD_VAR 0 5
112411: PPUSH
112412: LD_VAR 0 4
112416: PPUSH
112417: CALL_OW 74
112421: PPUSH
112422: CALL_OW 112
112426: GO 112452
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
112428: LD_VAR 0 4
112432: PPUSH
112433: LD_VAR 0 5
112437: PPUSH
112438: LD_VAR 0 4
112442: PPUSH
112443: CALL_OW 74
112447: PPUSH
112448: CALL 113537 0 2
// end ; end ;
112452: GO 112024
112454: POP
112455: POP
// end ;
112456: LD_VAR 0 3
112460: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
112461: LD_INT 0
112463: PPUSH
112464: PPUSH
112465: PPUSH
// if not unit or IsInUnit ( unit ) then
112466: LD_VAR 0 1
112470: NOT
112471: IFTRUE 112484
112473: PUSH
112474: LD_VAR 0 1
112478: PPUSH
112479: CALL_OW 310
112483: OR
112484: IFFALSE 112488
// exit ;
112486: GO 112579
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
112488: LD_ADDR_VAR 0 4
112492: PUSH
112493: LD_VAR 0 1
112497: PPUSH
112498: CALL_OW 250
112502: PPUSH
112503: LD_VAR 0 2
112507: PPUSH
112508: LD_INT 1
112510: PPUSH
112511: CALL_OW 272
112515: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
112516: LD_ADDR_VAR 0 5
112520: PUSH
112521: LD_VAR 0 1
112525: PPUSH
112526: CALL_OW 251
112530: PPUSH
112531: LD_VAR 0 2
112535: PPUSH
112536: LD_INT 1
112538: PPUSH
112539: CALL_OW 273
112543: ST_TO_ADDR
// if ValidHex ( x , y ) then
112544: LD_VAR 0 4
112548: PPUSH
112549: LD_VAR 0 5
112553: PPUSH
112554: CALL_OW 488
112558: IFFALSE 112579
// ComTurnXY ( unit , x , y ) ;
112560: LD_VAR 0 1
112564: PPUSH
112565: LD_VAR 0 4
112569: PPUSH
112570: LD_VAR 0 5
112574: PPUSH
112575: CALL_OW 118
// end ;
112579: LD_VAR 0 3
112583: RET
// export function SeeUnits ( side , units ) ; var i ; begin
112584: LD_INT 0
112586: PPUSH
112587: PPUSH
// result := false ;
112588: LD_ADDR_VAR 0 3
112592: PUSH
112593: LD_INT 0
112595: ST_TO_ADDR
// if not units then
112596: LD_VAR 0 2
112600: NOT
112601: IFFALSE 112605
// exit ;
112603: GO 112650
// for i in units do
112605: LD_ADDR_VAR 0 4
112609: PUSH
112610: LD_VAR 0 2
112614: PUSH
112615: FOR_IN
112616: IFFALSE 112648
// if See ( side , i ) then
112618: LD_VAR 0 1
112622: PPUSH
112623: LD_VAR 0 4
112627: PPUSH
112628: CALL_OW 292
112632: IFFALSE 112646
// begin result := true ;
112634: LD_ADDR_VAR 0 3
112638: PUSH
112639: LD_INT 1
112641: ST_TO_ADDR
// exit ;
112642: POP
112643: POP
112644: GO 112650
// end ;
112646: GO 112615
112648: POP
112649: POP
// end ;
112650: LD_VAR 0 3
112654: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
112655: LD_INT 0
112657: PPUSH
112658: PPUSH
112659: PPUSH
112660: PPUSH
// if not unit or not points then
112661: LD_VAR 0 1
112665: NOT
112666: IFTRUE 112675
112668: PUSH
112669: LD_VAR 0 2
112673: NOT
112674: OR
112675: IFFALSE 112679
// exit ;
112677: GO 112769
// dist := 99999 ;
112679: LD_ADDR_VAR 0 5
112683: PUSH
112684: LD_INT 99999
112686: ST_TO_ADDR
// for i in points do
112687: LD_ADDR_VAR 0 4
112691: PUSH
112692: LD_VAR 0 2
112696: PUSH
112697: FOR_IN
112698: IFFALSE 112767
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
112700: LD_ADDR_VAR 0 6
112704: PUSH
112705: LD_VAR 0 1
112709: PPUSH
112710: LD_VAR 0 4
112714: PUSH
112715: LD_INT 1
112717: ARRAY
112718: PPUSH
112719: LD_VAR 0 4
112723: PUSH
112724: LD_INT 2
112726: ARRAY
112727: PPUSH
112728: CALL_OW 297
112732: ST_TO_ADDR
// if tmpDist < dist then
112733: LD_VAR 0 6
112737: PUSH
112738: LD_VAR 0 5
112742: LESS
112743: IFFALSE 112765
// begin result := i ;
112745: LD_ADDR_VAR 0 3
112749: PUSH
112750: LD_VAR 0 4
112754: ST_TO_ADDR
// dist := tmpDist ;
112755: LD_ADDR_VAR 0 5
112759: PUSH
112760: LD_VAR 0 6
112764: ST_TO_ADDR
// end ; end ;
112765: GO 112697
112767: POP
112768: POP
// end ;
112769: LD_VAR 0 3
112773: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
112774: LD_INT 0
112776: PPUSH
// uc_side := side ;
112777: LD_ADDR_OWVAR 20
112781: PUSH
112782: LD_VAR 0 1
112786: ST_TO_ADDR
// uc_nation := 3 ;
112787: LD_ADDR_OWVAR 21
112791: PUSH
112792: LD_INT 3
112794: ST_TO_ADDR
// vc_chassis := 25 ;
112795: LD_ADDR_OWVAR 37
112799: PUSH
112800: LD_INT 25
112802: ST_TO_ADDR
// vc_engine := engine_siberite ;
112803: LD_ADDR_OWVAR 39
112807: PUSH
112808: LD_INT 3
112810: ST_TO_ADDR
// vc_control := control_computer ;
112811: LD_ADDR_OWVAR 38
112815: PUSH
112816: LD_INT 3
112818: ST_TO_ADDR
// vc_weapon := 59 ;
112819: LD_ADDR_OWVAR 40
112823: PUSH
112824: LD_INT 59
112826: ST_TO_ADDR
// result := CreateVehicle ;
112827: LD_ADDR_VAR 0 5
112831: PUSH
112832: CALL_OW 45
112836: ST_TO_ADDR
// SetDir ( result , d ) ;
112837: LD_VAR 0 5
112841: PPUSH
112842: LD_VAR 0 4
112846: PPUSH
112847: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
112851: LD_VAR 0 5
112855: PPUSH
112856: LD_VAR 0 2
112860: PPUSH
112861: LD_VAR 0 3
112865: PPUSH
112866: LD_INT 0
112868: PPUSH
112869: CALL_OW 48
// end ;
112873: LD_VAR 0 5
112877: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
112878: LD_INT 0
112880: PPUSH
112881: PPUSH
112882: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
112883: LD_ADDR_VAR 0 2
112887: PUSH
112888: LD_INT 0
112890: PUSH
112891: LD_INT 0
112893: PUSH
112894: LD_INT 0
112896: PUSH
112897: LD_INT 0
112899: PUSH
112900: EMPTY
112901: LIST
112902: LIST
112903: LIST
112904: LIST
112905: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
112906: LD_VAR 0 1
112910: NOT
112911: IFTRUE 112944
112913: PUSH
112914: LD_VAR 0 1
112918: PPUSH
112919: CALL_OW 264
112923: PUSH
112924: LD_INT 12
112926: PUSH
112927: LD_INT 51
112929: PUSH
112930: LD_INT 32
112932: PUSH
112933: LD_INT 89
112935: PUSH
112936: EMPTY
112937: LIST
112938: LIST
112939: LIST
112940: LIST
112941: IN
112942: NOT
112943: OR
112944: IFFALSE 112948
// exit ;
112946: GO 113046
// for i := 1 to 3 do
112948: LD_ADDR_VAR 0 3
112952: PUSH
112953: DOUBLE
112954: LD_INT 1
112956: DEC
112957: ST_TO_ADDR
112958: LD_INT 3
112960: PUSH
112961: FOR_TO
112962: IFFALSE 113044
// begin tmp := GetCargo ( cargo , i ) ;
112964: LD_ADDR_VAR 0 4
112968: PUSH
112969: LD_VAR 0 1
112973: PPUSH
112974: LD_VAR 0 3
112978: PPUSH
112979: CALL_OW 289
112983: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
112984: LD_ADDR_VAR 0 2
112988: PUSH
112989: LD_VAR 0 2
112993: PPUSH
112994: LD_VAR 0 3
112998: PPUSH
112999: LD_VAR 0 4
113003: PPUSH
113004: CALL_OW 1
113008: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
113009: LD_ADDR_VAR 0 2
113013: PUSH
113014: LD_VAR 0 2
113018: PPUSH
113019: LD_INT 4
113021: PPUSH
113022: LD_VAR 0 2
113026: PUSH
113027: LD_INT 4
113029: ARRAY
113030: PUSH
113031: LD_VAR 0 4
113035: PLUS
113036: PPUSH
113037: CALL_OW 1
113041: ST_TO_ADDR
// end ;
113042: GO 112961
113044: POP
113045: POP
// end ;
113046: LD_VAR 0 2
113050: RET
// export function Length ( array ) ; begin
113051: LD_INT 0
113053: PPUSH
// result := array + 0 ;
113054: LD_ADDR_VAR 0 2
113058: PUSH
113059: LD_VAR 0 1
113063: PUSH
113064: LD_INT 0
113066: PLUS
113067: ST_TO_ADDR
// end ;
113068: LD_VAR 0 2
113072: RET
// export function PrepareArray ( array ) ; begin
113073: LD_INT 0
113075: PPUSH
// result := array diff 0 ;
113076: LD_ADDR_VAR 0 2
113080: PUSH
113081: LD_VAR 0 1
113085: PUSH
113086: LD_INT 0
113088: DIFF
113089: ST_TO_ADDR
// if not result [ 1 ] then
113090: LD_VAR 0 2
113094: PUSH
113095: LD_INT 1
113097: ARRAY
113098: NOT
113099: IFFALSE 113119
// result := Delete ( result , 1 ) ;
113101: LD_ADDR_VAR 0 2
113105: PUSH
113106: LD_VAR 0 2
113110: PPUSH
113111: LD_INT 1
113113: PPUSH
113114: CALL_OW 3
113118: ST_TO_ADDR
// end ;
113119: LD_VAR 0 2
113123: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
113124: LD_INT 0
113126: PPUSH
113127: PPUSH
113128: PPUSH
113129: PPUSH
// sibRocketRange := 25 ;
113130: LD_ADDR_VAR 0 6
113134: PUSH
113135: LD_INT 25
113137: ST_TO_ADDR
// result := false ;
113138: LD_ADDR_VAR 0 4
113142: PUSH
113143: LD_INT 0
113145: ST_TO_ADDR
// for i := 0 to 5 do
113146: LD_ADDR_VAR 0 5
113150: PUSH
113151: DOUBLE
113152: LD_INT 0
113154: DEC
113155: ST_TO_ADDR
113156: LD_INT 5
113158: PUSH
113159: FOR_TO
113160: IFFALSE 113227
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
113162: LD_VAR 0 1
113166: PPUSH
113167: LD_VAR 0 5
113171: PPUSH
113172: LD_VAR 0 6
113176: PPUSH
113177: CALL_OW 272
113181: PPUSH
113182: LD_VAR 0 2
113186: PPUSH
113187: LD_VAR 0 5
113191: PPUSH
113192: LD_VAR 0 6
113196: PPUSH
113197: CALL_OW 273
113201: PPUSH
113202: LD_VAR 0 3
113206: PPUSH
113207: CALL_OW 309
113211: IFFALSE 113225
// begin result := true ;
113213: LD_ADDR_VAR 0 4
113217: PUSH
113218: LD_INT 1
113220: ST_TO_ADDR
// exit ;
113221: POP
113222: POP
113223: GO 113229
// end ;
113225: GO 113159
113227: POP
113228: POP
// end ;
113229: LD_VAR 0 4
113233: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
113234: LD_INT 0
113236: PPUSH
113237: PPUSH
113238: PPUSH
// if btype = b_depot then
113239: LD_VAR 0 2
113243: PUSH
113244: LD_INT 0
113246: EQUAL
113247: IFFALSE 113259
// begin result := true ;
113249: LD_ADDR_VAR 0 3
113253: PUSH
113254: LD_INT 1
113256: ST_TO_ADDR
// exit ;
113257: GO 113379
// end ; pom := GetBase ( depot ) ;
113259: LD_ADDR_VAR 0 4
113263: PUSH
113264: LD_VAR 0 1
113268: PPUSH
113269: CALL_OW 274
113273: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
113274: LD_ADDR_VAR 0 5
113278: PUSH
113279: LD_VAR 0 2
113283: PPUSH
113284: LD_VAR 0 1
113288: PPUSH
113289: CALL_OW 248
113293: PPUSH
113294: CALL_OW 450
113298: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
113299: LD_ADDR_VAR 0 3
113303: PUSH
113304: LD_VAR 0 4
113308: PPUSH
113309: LD_INT 1
113311: PPUSH
113312: CALL_OW 275
113316: PUSH
113317: LD_VAR 0 5
113321: PUSH
113322: LD_INT 1
113324: ARRAY
113325: GREATEREQUAL
113326: IFFALSE 113352
113328: PUSH
113329: LD_VAR 0 4
113333: PPUSH
113334: LD_INT 2
113336: PPUSH
113337: CALL_OW 275
113341: PUSH
113342: LD_VAR 0 5
113346: PUSH
113347: LD_INT 2
113349: ARRAY
113350: GREATEREQUAL
113351: AND
113352: IFFALSE 113378
113354: PUSH
113355: LD_VAR 0 4
113359: PPUSH
113360: LD_INT 3
113362: PPUSH
113363: CALL_OW 275
113367: PUSH
113368: LD_VAR 0 5
113372: PUSH
113373: LD_INT 3
113375: ARRAY
113376: GREATEREQUAL
113377: AND
113378: ST_TO_ADDR
// end ;
113379: LD_VAR 0 3
113383: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
113384: LD_INT 0
113386: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
113387: LD_VAR 0 1
113391: PPUSH
113392: LD_VAR 0 2
113396: PPUSH
113397: LD_INT 0
113399: PPUSH
113400: LD_INT 0
113402: PPUSH
113403: LD_INT 1
113405: PPUSH
113406: LD_INT 0
113408: PPUSH
113409: CALL_OW 587
// end ;
113413: LD_VAR 0 3
113417: RET
// export function CenterOnNow ( unit ) ; begin
113418: LD_INT 0
113420: PPUSH
// result := IsInUnit ( unit ) ;
113421: LD_ADDR_VAR 0 2
113425: PUSH
113426: LD_VAR 0 1
113430: PPUSH
113431: CALL_OW 310
113435: ST_TO_ADDR
// if not result then
113436: LD_VAR 0 2
113440: NOT
113441: IFFALSE 113453
// result := unit ;
113443: LD_ADDR_VAR 0 2
113447: PUSH
113448: LD_VAR 0 1
113452: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
113453: LD_VAR 0 1
113457: PPUSH
113458: CALL_OW 87
// end ;
113462: LD_VAR 0 2
113466: RET
// export function ComMoveHex ( unit , hex ) ; begin
113467: LD_INT 0
113469: PPUSH
// if not hex then
113470: LD_VAR 0 2
113474: NOT
113475: IFFALSE 113479
// exit ;
113477: GO 113532
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
113479: LD_VAR 0 2
113483: PUSH
113484: LD_INT 1
113486: ARRAY
113487: PPUSH
113488: LD_VAR 0 2
113492: PUSH
113493: LD_INT 2
113495: ARRAY
113496: PPUSH
113497: CALL_OW 428
113501: IFFALSE 113505
// exit ;
113503: GO 113532
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
113505: LD_VAR 0 1
113509: PPUSH
113510: LD_VAR 0 2
113514: PUSH
113515: LD_INT 1
113517: ARRAY
113518: PPUSH
113519: LD_VAR 0 2
113523: PUSH
113524: LD_INT 2
113526: ARRAY
113527: PPUSH
113528: CALL_OW 111
// end ;
113532: LD_VAR 0 3
113536: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
113537: LD_INT 0
113539: PPUSH
113540: PPUSH
113541: PPUSH
// if not unit or not enemy then
113542: LD_VAR 0 1
113546: NOT
113547: IFTRUE 113556
113549: PUSH
113550: LD_VAR 0 2
113554: NOT
113555: OR
113556: IFFALSE 113560
// exit ;
113558: GO 113686
// x := GetX ( enemy ) ;
113560: LD_ADDR_VAR 0 4
113564: PUSH
113565: LD_VAR 0 2
113569: PPUSH
113570: CALL_OW 250
113574: ST_TO_ADDR
// y := GetY ( enemy ) ;
113575: LD_ADDR_VAR 0 5
113579: PUSH
113580: LD_VAR 0 2
113584: PPUSH
113585: CALL_OW 251
113589: ST_TO_ADDR
// if ValidHex ( x , y ) then
113590: LD_VAR 0 4
113594: PPUSH
113595: LD_VAR 0 5
113599: PPUSH
113600: CALL_OW 488
113604: IFFALSE 113686
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
113606: LD_VAR 0 2
113610: PPUSH
113611: CALL_OW 247
113615: PUSH
113616: LD_INT 3
113618: PUSH
113619: LD_INT 2
113621: PUSH
113622: EMPTY
113623: LIST
113624: LIST
113625: IN
113626: IFTRUE 113649
113628: PUSH
113629: LD_VAR 0 1
113633: PPUSH
113634: CALL_OW 255
113638: PPUSH
113639: LD_VAR 0 2
113643: PPUSH
113644: CALL_OW 292
113648: OR
113649: IFFALSE 113667
// ComAttackUnit ( unit , enemy ) else
113651: LD_VAR 0 1
113655: PPUSH
113656: LD_VAR 0 2
113660: PPUSH
113661: CALL_OW 115
113665: GO 113686
// ComAgressiveMove ( unit , x , y ) ;
113667: LD_VAR 0 1
113671: PPUSH
113672: LD_VAR 0 4
113676: PPUSH
113677: LD_VAR 0 5
113681: PPUSH
113682: CALL_OW 114
// end ;
113686: LD_VAR 0 3
113690: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
113691: LD_INT 0
113693: PPUSH
113694: PPUSH
113695: PPUSH
// list := AreaToList ( area , 0 ) ;
113696: LD_ADDR_VAR 0 5
113700: PUSH
113701: LD_VAR 0 1
113705: PPUSH
113706: LD_INT 0
113708: PPUSH
113709: CALL_OW 517
113713: ST_TO_ADDR
// if not list then
113714: LD_VAR 0 5
113718: NOT
113719: IFFALSE 113723
// exit ;
113721: GO 113853
// if all then
113723: LD_VAR 0 2
113727: IFFALSE 113815
// begin for i := 1 to list [ 1 ] do
113729: LD_ADDR_VAR 0 4
113733: PUSH
113734: DOUBLE
113735: LD_INT 1
113737: DEC
113738: ST_TO_ADDR
113739: LD_VAR 0 5
113743: PUSH
113744: LD_INT 1
113746: ARRAY
113747: PUSH
113748: FOR_TO
113749: IFFALSE 113811
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
113751: LD_ADDR_VAR 0 3
113755: PUSH
113756: LD_VAR 0 3
113760: PPUSH
113761: LD_VAR 0 3
113765: PUSH
113766: LD_INT 1
113768: PLUS
113769: PPUSH
113770: LD_VAR 0 5
113774: PUSH
113775: LD_INT 1
113777: ARRAY
113778: PUSH
113779: LD_VAR 0 4
113783: ARRAY
113784: PUSH
113785: LD_VAR 0 5
113789: PUSH
113790: LD_INT 2
113792: ARRAY
113793: PUSH
113794: LD_VAR 0 4
113798: ARRAY
113799: PUSH
113800: EMPTY
113801: LIST
113802: LIST
113803: PPUSH
113804: CALL_OW 1
113808: ST_TO_ADDR
113809: GO 113748
113811: POP
113812: POP
// exit ;
113813: GO 113853
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
113815: LD_ADDR_VAR 0 3
113819: PUSH
113820: LD_VAR 0 5
113824: PUSH
113825: LD_INT 1
113827: ARRAY
113828: PUSH
113829: LD_INT 1
113831: ARRAY
113832: PUSH
113833: LD_VAR 0 5
113837: PUSH
113838: LD_INT 2
113840: ARRAY
113841: PUSH
113842: LD_INT 1
113844: ARRAY
113845: PUSH
113846: EMPTY
113847: LIST
113848: LIST
113849: PUSH
113850: EMPTY
113851: LIST
113852: ST_TO_ADDR
// end ;
113853: LD_VAR 0 3
113857: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
113858: LD_INT 0
113860: PPUSH
113861: PPUSH
// list := AreaToList ( area , 0 ) ;
113862: LD_ADDR_VAR 0 4
113866: PUSH
113867: LD_VAR 0 1
113871: PPUSH
113872: LD_INT 0
113874: PPUSH
113875: CALL_OW 517
113879: ST_TO_ADDR
// if not list then
113880: LD_VAR 0 4
113884: NOT
113885: IFFALSE 113889
// exit ;
113887: GO 113930
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
113889: LD_ADDR_VAR 0 3
113893: PUSH
113894: LD_VAR 0 4
113898: PUSH
113899: LD_INT 1
113901: ARRAY
113902: PUSH
113903: LD_INT 1
113905: ARRAY
113906: PUSH
113907: LD_VAR 0 4
113911: PUSH
113912: LD_INT 2
113914: ARRAY
113915: PUSH
113916: LD_INT 1
113918: ARRAY
113919: PUSH
113920: LD_VAR 0 2
113924: PUSH
113925: EMPTY
113926: LIST
113927: LIST
113928: LIST
113929: ST_TO_ADDR
// end ;
113930: LD_VAR 0 3
113934: RET
// export function First ( array ) ; begin
113935: LD_INT 0
113937: PPUSH
// if not array then
113938: LD_VAR 0 1
113942: NOT
113943: IFFALSE 113947
// exit ;
113945: GO 113961
// result := array [ 1 ] ;
113947: LD_ADDR_VAR 0 2
113951: PUSH
113952: LD_VAR 0 1
113956: PUSH
113957: LD_INT 1
113959: ARRAY
113960: ST_TO_ADDR
// end ;
113961: LD_VAR 0 2
113965: RET
// export function Last ( array ) ; begin
113966: LD_INT 0
113968: PPUSH
// if not array then
113969: LD_VAR 0 1
113973: NOT
113974: IFFALSE 113978
// exit ;
113976: GO 113994
// result := array [ array ] ;
113978: LD_ADDR_VAR 0 2
113982: PUSH
113983: LD_VAR 0 1
113987: PUSH
113988: LD_VAR 0 1
113992: ARRAY
113993: ST_TO_ADDR
// end ;
113994: LD_VAR 0 2
113998: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
113999: LD_INT 0
114001: PPUSH
114002: PPUSH
// result := [ ] ;
114003: LD_ADDR_VAR 0 5
114007: PUSH
114008: EMPTY
114009: ST_TO_ADDR
// if not array then
114010: LD_VAR 0 1
114014: NOT
114015: IFFALSE 114019
// exit ;
114017: GO 114131
// for i := 1 to array do
114019: LD_ADDR_VAR 0 6
114023: PUSH
114024: DOUBLE
114025: LD_INT 1
114027: DEC
114028: ST_TO_ADDR
114029: LD_VAR 0 1
114033: PUSH
114034: FOR_TO
114035: IFFALSE 114129
// if array [ i ] [ index ] = value then
114037: LD_VAR 0 1
114041: PUSH
114042: LD_VAR 0 6
114046: ARRAY
114047: PUSH
114048: LD_VAR 0 2
114052: ARRAY
114053: PUSH
114054: LD_VAR 0 3
114058: EQUAL
114059: IFFALSE 114127
// begin if indexColumn then
114061: LD_VAR 0 4
114065: IFFALSE 114101
// result := Join ( result , array [ i ] [ indexColumn ] ) else
114067: LD_ADDR_VAR 0 5
114071: PUSH
114072: LD_VAR 0 5
114076: PPUSH
114077: LD_VAR 0 1
114081: PUSH
114082: LD_VAR 0 6
114086: ARRAY
114087: PUSH
114088: LD_VAR 0 4
114092: ARRAY
114093: PPUSH
114094: CALL 109139 0 2
114098: ST_TO_ADDR
114099: GO 114127
// result := Join ( result , array [ i ] ) ;
114101: LD_ADDR_VAR 0 5
114105: PUSH
114106: LD_VAR 0 5
114110: PPUSH
114111: LD_VAR 0 1
114115: PUSH
114116: LD_VAR 0 6
114120: ARRAY
114121: PPUSH
114122: CALL 109139 0 2
114126: ST_TO_ADDR
// end ;
114127: GO 114034
114129: POP
114130: POP
// end ;
114131: LD_VAR 0 5
114135: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
114136: LD_INT 0
114138: PPUSH
// if not vehicles or not parkingPoint then
114139: LD_VAR 0 1
114143: NOT
114144: IFTRUE 114153
114146: PUSH
114147: LD_VAR 0 2
114151: NOT
114152: OR
114153: IFFALSE 114157
// exit ;
114155: GO 114255
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
114157: LD_ADDR_VAR 0 1
114161: PUSH
114162: LD_VAR 0 1
114166: PPUSH
114167: LD_INT 50
114169: PUSH
114170: EMPTY
114171: LIST
114172: PUSH
114173: LD_INT 3
114175: PUSH
114176: LD_INT 92
114178: PUSH
114179: LD_VAR 0 2
114183: PUSH
114184: LD_INT 1
114186: ARRAY
114187: PUSH
114188: LD_VAR 0 2
114192: PUSH
114193: LD_INT 2
114195: ARRAY
114196: PUSH
114197: LD_INT 8
114199: PUSH
114200: EMPTY
114201: LIST
114202: LIST
114203: LIST
114204: LIST
114205: PUSH
114206: EMPTY
114207: LIST
114208: LIST
114209: PUSH
114210: EMPTY
114211: LIST
114212: LIST
114213: PPUSH
114214: CALL_OW 72
114218: ST_TO_ADDR
// if not vehicles then
114219: LD_VAR 0 1
114223: NOT
114224: IFFALSE 114228
// exit ;
114226: GO 114255
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
114228: LD_VAR 0 1
114232: PPUSH
114233: LD_VAR 0 2
114237: PUSH
114238: LD_INT 1
114240: ARRAY
114241: PPUSH
114242: LD_VAR 0 2
114246: PUSH
114247: LD_INT 2
114249: ARRAY
114250: PPUSH
114251: CALL_OW 111
// end ;
114255: LD_VAR 0 3
114259: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
114260: LD_INT 0
114262: PPUSH
114263: PPUSH
114264: PPUSH
// if not side or not area then
114265: LD_VAR 0 1
114269: NOT
114270: IFTRUE 114279
114272: PUSH
114273: LD_VAR 0 2
114277: NOT
114278: OR
114279: IFFALSE 114283
// exit ;
114281: GO 114402
// tmp := AreaToList ( area , 0 ) ;
114283: LD_ADDR_VAR 0 5
114287: PUSH
114288: LD_VAR 0 2
114292: PPUSH
114293: LD_INT 0
114295: PPUSH
114296: CALL_OW 517
114300: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
114301: LD_ADDR_VAR 0 4
114305: PUSH
114306: DOUBLE
114307: LD_INT 1
114309: DEC
114310: ST_TO_ADDR
114311: LD_VAR 0 5
114315: PUSH
114316: LD_INT 1
114318: ARRAY
114319: PUSH
114320: FOR_TO
114321: IFFALSE 114400
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
114323: LD_VAR 0 5
114327: PUSH
114328: LD_INT 1
114330: ARRAY
114331: PUSH
114332: LD_VAR 0 4
114336: ARRAY
114337: PPUSH
114338: LD_VAR 0 5
114342: PUSH
114343: LD_INT 2
114345: ARRAY
114346: PUSH
114347: LD_VAR 0 4
114351: ARRAY
114352: PPUSH
114353: CALL_OW 351
114357: IFFALSE 114398
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
114359: LD_VAR 0 5
114363: PUSH
114364: LD_INT 1
114366: ARRAY
114367: PUSH
114368: LD_VAR 0 4
114372: ARRAY
114373: PPUSH
114374: LD_VAR 0 5
114378: PUSH
114379: LD_INT 2
114381: ARRAY
114382: PUSH
114383: LD_VAR 0 4
114387: ARRAY
114388: PPUSH
114389: LD_VAR 0 1
114393: PPUSH
114394: CALL_OW 244
// end ;
114398: GO 114320
114400: POP
114401: POP
// end ;
114402: LD_VAR 0 3
114406: RET
// export function UniqueArray ( array ) ; var i ; begin
114407: LD_INT 0
114409: PPUSH
114410: PPUSH
// result := [ ] ;
114411: LD_ADDR_VAR 0 2
114415: PUSH
114416: EMPTY
114417: ST_TO_ADDR
// if not array then
114418: LD_VAR 0 1
114422: NOT
114423: IFFALSE 114427
// exit ;
114425: GO 114488
// for i := 1 to array do
114427: LD_ADDR_VAR 0 3
114431: PUSH
114432: DOUBLE
114433: LD_INT 1
114435: DEC
114436: ST_TO_ADDR
114437: LD_VAR 0 1
114441: PUSH
114442: FOR_TO
114443: IFFALSE 114486
// if not array [ i ] in result then
114445: LD_VAR 0 1
114449: PUSH
114450: LD_VAR 0 3
114454: ARRAY
114455: PUSH
114456: LD_VAR 0 2
114460: IN
114461: NOT
114462: IFFALSE 114484
// result := Join ( result , i ) ;
114464: LD_ADDR_VAR 0 2
114468: PUSH
114469: LD_VAR 0 2
114473: PPUSH
114474: LD_VAR 0 3
114478: PPUSH
114479: CALL 109139 0 2
114483: ST_TO_ADDR
114484: GO 114442
114486: POP
114487: POP
// end ; end_of_file end_of_file
114488: LD_VAR 0 2
114492: RET
// export globalGameSaveCounter ; every 0 0$1 do
114493: GO 114495
114495: DISABLE
// begin enable ;
114496: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
114497: LD_STRING updateTimer(
114499: PUSH
114500: LD_OWVAR 1
114504: STR
114505: PUSH
114506: LD_STRING );
114508: STR
114509: PPUSH
114510: CALL_OW 559
// end ;
114514: END
// every 0 0$1 do
114515: GO 114517
114517: DISABLE
// begin globalGameSaveCounter := 0 ;
114518: LD_ADDR_EXP 147
114522: PUSH
114523: LD_INT 0
114525: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
114526: LD_STRING setGameSaveCounter(0)
114528: PPUSH
114529: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
114533: LD_STRING initStreamRollete();
114535: PPUSH
114536: CALL_OW 559
// InitStreamMode ;
114540: CALL 115892 0 0
// DefineStreamItems ( false ) ;
114544: LD_INT 0
114546: PPUSH
114547: CALL 116356 0 1
// end ;
114551: END
// export function SOS_MapStart ( ) ; begin
114552: LD_INT 0
114554: PPUSH
// if streamModeActive then
114555: LD_EXP 148
114559: IFFALSE 114568
// DefineStreamItems ( true ) ;
114561: LD_INT 1
114563: PPUSH
114564: CALL 116356 0 1
// ToLua ( LFC_UNITS_CUSTOM_ICON = {}; ) ;
114568: LD_STRING LFC_UNITS_CUSTOM_ICON = {};
114570: PPUSH
114571: CALL_OW 559
// UpdateLuaVariables ( ) ;
114575: CALL 114592 0 0
// UpdateFactoryWaypoints ( ) ;
114579: CALL 129478 0 0
// UpdateWarehouseGatheringPoints ( ) ;
114583: CALL 129730 0 0
// end ;
114587: LD_VAR 0 1
114591: RET
// function UpdateLuaVariables ( ) ; begin
114592: LD_INT 0
114594: PPUSH
// if globalGameSaveCounter then
114595: LD_EXP 147
114599: IFFALSE 114633
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
114601: LD_ADDR_EXP 147
114605: PUSH
114606: LD_EXP 147
114610: PPUSH
114611: CALL 110512 0 1
114615: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
114616: LD_STRING setGameSaveCounter(
114618: PUSH
114619: LD_EXP 147
114623: STR
114624: PUSH
114625: LD_STRING )
114627: STR
114628: PPUSH
114629: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
114633: LD_STRING setGameDifficulty(
114635: PUSH
114636: LD_OWVAR 67
114640: STR
114641: PUSH
114642: LD_STRING )
114644: STR
114645: PPUSH
114646: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
114650: LD_STRING displayDifficulty(
114652: PUSH
114653: LD_OWVAR 67
114657: STR
114658: PUSH
114659: LD_STRING )
114661: STR
114662: PPUSH
114663: CALL_OW 559
// end ;
114667: LD_VAR 0 1
114671: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
114672: LD_INT 0
114674: PPUSH
// if p2 = stream_mode then
114675: LD_VAR 0 2
114679: PUSH
114680: LD_INT 100
114682: EQUAL
114683: IFFALSE 115686
// begin if not StreamModeActive then
114685: LD_EXP 148
114689: NOT
114690: IFFALSE 114700
// StreamModeActive := true ;
114692: LD_ADDR_EXP 148
114696: PUSH
114697: LD_INT 1
114699: ST_TO_ADDR
// if p3 = 0 then
114700: LD_VAR 0 3
114704: PUSH
114705: LD_INT 0
114707: EQUAL
114708: IFFALSE 114714
// InitStreamMode ;
114710: CALL 115892 0 0
// if p3 = 1 then
114714: LD_VAR 0 3
114718: PUSH
114719: LD_INT 1
114721: EQUAL
114722: IFFALSE 114732
// sRocket := true ;
114724: LD_ADDR_EXP 153
114728: PUSH
114729: LD_INT 1
114731: ST_TO_ADDR
// if p3 = 2 then
114732: LD_VAR 0 3
114736: PUSH
114737: LD_INT 2
114739: EQUAL
114740: IFFALSE 114750
// sSpeed := true ;
114742: LD_ADDR_EXP 152
114746: PUSH
114747: LD_INT 1
114749: ST_TO_ADDR
// if p3 = 3 then
114750: LD_VAR 0 3
114754: PUSH
114755: LD_INT 3
114757: EQUAL
114758: IFFALSE 114768
// sEngine := true ;
114760: LD_ADDR_EXP 154
114764: PUSH
114765: LD_INT 1
114767: ST_TO_ADDR
// if p3 = 4 then
114768: LD_VAR 0 3
114772: PUSH
114773: LD_INT 4
114775: EQUAL
114776: IFFALSE 114786
// sSpec := true ;
114778: LD_ADDR_EXP 151
114782: PUSH
114783: LD_INT 1
114785: ST_TO_ADDR
// if p3 = 5 then
114786: LD_VAR 0 3
114790: PUSH
114791: LD_INT 5
114793: EQUAL
114794: IFFALSE 114804
// sLevel := true ;
114796: LD_ADDR_EXP 155
114800: PUSH
114801: LD_INT 1
114803: ST_TO_ADDR
// if p3 = 6 then
114804: LD_VAR 0 3
114808: PUSH
114809: LD_INT 6
114811: EQUAL
114812: IFFALSE 114822
// sArmoury := true ;
114814: LD_ADDR_EXP 156
114818: PUSH
114819: LD_INT 1
114821: ST_TO_ADDR
// if p3 = 7 then
114822: LD_VAR 0 3
114826: PUSH
114827: LD_INT 7
114829: EQUAL
114830: IFFALSE 114840
// sRadar := true ;
114832: LD_ADDR_EXP 157
114836: PUSH
114837: LD_INT 1
114839: ST_TO_ADDR
// if p3 = 8 then
114840: LD_VAR 0 3
114844: PUSH
114845: LD_INT 8
114847: EQUAL
114848: IFFALSE 114858
// sBunker := true ;
114850: LD_ADDR_EXP 158
114854: PUSH
114855: LD_INT 1
114857: ST_TO_ADDR
// if p3 = 9 then
114858: LD_VAR 0 3
114862: PUSH
114863: LD_INT 9
114865: EQUAL
114866: IFFALSE 114876
// sHack := true ;
114868: LD_ADDR_EXP 159
114872: PUSH
114873: LD_INT 1
114875: ST_TO_ADDR
// if p3 = 10 then
114876: LD_VAR 0 3
114880: PUSH
114881: LD_INT 10
114883: EQUAL
114884: IFFALSE 114894
// sFire := true ;
114886: LD_ADDR_EXP 160
114890: PUSH
114891: LD_INT 1
114893: ST_TO_ADDR
// if p3 = 11 then
114894: LD_VAR 0 3
114898: PUSH
114899: LD_INT 11
114901: EQUAL
114902: IFFALSE 114912
// sRefresh := true ;
114904: LD_ADDR_EXP 161
114908: PUSH
114909: LD_INT 1
114911: ST_TO_ADDR
// if p3 = 12 then
114912: LD_VAR 0 3
114916: PUSH
114917: LD_INT 12
114919: EQUAL
114920: IFFALSE 114930
// sExp := true ;
114922: LD_ADDR_EXP 162
114926: PUSH
114927: LD_INT 1
114929: ST_TO_ADDR
// if p3 = 13 then
114930: LD_VAR 0 3
114934: PUSH
114935: LD_INT 13
114937: EQUAL
114938: IFFALSE 114948
// sDepot := true ;
114940: LD_ADDR_EXP 163
114944: PUSH
114945: LD_INT 1
114947: ST_TO_ADDR
// if p3 = 14 then
114948: LD_VAR 0 3
114952: PUSH
114953: LD_INT 14
114955: EQUAL
114956: IFFALSE 114966
// sFlag := true ;
114958: LD_ADDR_EXP 164
114962: PUSH
114963: LD_INT 1
114965: ST_TO_ADDR
// if p3 = 15 then
114966: LD_VAR 0 3
114970: PUSH
114971: LD_INT 15
114973: EQUAL
114974: IFFALSE 114984
// sKamikadze := true ;
114976: LD_ADDR_EXP 172
114980: PUSH
114981: LD_INT 1
114983: ST_TO_ADDR
// if p3 = 16 then
114984: LD_VAR 0 3
114988: PUSH
114989: LD_INT 16
114991: EQUAL
114992: IFFALSE 115002
// sTroll := true ;
114994: LD_ADDR_EXP 173
114998: PUSH
114999: LD_INT 1
115001: ST_TO_ADDR
// if p3 = 17 then
115002: LD_VAR 0 3
115006: PUSH
115007: LD_INT 17
115009: EQUAL
115010: IFFALSE 115020
// sSlow := true ;
115012: LD_ADDR_EXP 174
115016: PUSH
115017: LD_INT 1
115019: ST_TO_ADDR
// if p3 = 18 then
115020: LD_VAR 0 3
115024: PUSH
115025: LD_INT 18
115027: EQUAL
115028: IFFALSE 115038
// sLack := true ;
115030: LD_ADDR_EXP 175
115034: PUSH
115035: LD_INT 1
115037: ST_TO_ADDR
// if p3 = 19 then
115038: LD_VAR 0 3
115042: PUSH
115043: LD_INT 19
115045: EQUAL
115046: IFFALSE 115056
// sTank := true ;
115048: LD_ADDR_EXP 177
115052: PUSH
115053: LD_INT 1
115055: ST_TO_ADDR
// if p3 = 20 then
115056: LD_VAR 0 3
115060: PUSH
115061: LD_INT 20
115063: EQUAL
115064: IFFALSE 115074
// sRemote := true ;
115066: LD_ADDR_EXP 178
115070: PUSH
115071: LD_INT 1
115073: ST_TO_ADDR
// if p3 = 21 then
115074: LD_VAR 0 3
115078: PUSH
115079: LD_INT 21
115081: EQUAL
115082: IFFALSE 115092
// sPowell := true ;
115084: LD_ADDR_EXP 179
115088: PUSH
115089: LD_INT 1
115091: ST_TO_ADDR
// if p3 = 22 then
115092: LD_VAR 0 3
115096: PUSH
115097: LD_INT 22
115099: EQUAL
115100: IFFALSE 115110
// sTeleport := true ;
115102: LD_ADDR_EXP 182
115106: PUSH
115107: LD_INT 1
115109: ST_TO_ADDR
// if p3 = 23 then
115110: LD_VAR 0 3
115114: PUSH
115115: LD_INT 23
115117: EQUAL
115118: IFFALSE 115128
// sOilTower := true ;
115120: LD_ADDR_EXP 184
115124: PUSH
115125: LD_INT 1
115127: ST_TO_ADDR
// if p3 = 24 then
115128: LD_VAR 0 3
115132: PUSH
115133: LD_INT 24
115135: EQUAL
115136: IFFALSE 115146
// sShovel := true ;
115138: LD_ADDR_EXP 185
115142: PUSH
115143: LD_INT 1
115145: ST_TO_ADDR
// if p3 = 25 then
115146: LD_VAR 0 3
115150: PUSH
115151: LD_INT 25
115153: EQUAL
115154: IFFALSE 115164
// sSheik := true ;
115156: LD_ADDR_EXP 186
115160: PUSH
115161: LD_INT 1
115163: ST_TO_ADDR
// if p3 = 26 then
115164: LD_VAR 0 3
115168: PUSH
115169: LD_INT 26
115171: EQUAL
115172: IFFALSE 115182
// sEarthquake := true ;
115174: LD_ADDR_EXP 188
115178: PUSH
115179: LD_INT 1
115181: ST_TO_ADDR
// if p3 = 27 then
115182: LD_VAR 0 3
115186: PUSH
115187: LD_INT 27
115189: EQUAL
115190: IFFALSE 115200
// sAI := true ;
115192: LD_ADDR_EXP 189
115196: PUSH
115197: LD_INT 1
115199: ST_TO_ADDR
// if p3 = 28 then
115200: LD_VAR 0 3
115204: PUSH
115205: LD_INT 28
115207: EQUAL
115208: IFFALSE 115218
// sCargo := true ;
115210: LD_ADDR_EXP 192
115214: PUSH
115215: LD_INT 1
115217: ST_TO_ADDR
// if p3 = 29 then
115218: LD_VAR 0 3
115222: PUSH
115223: LD_INT 29
115225: EQUAL
115226: IFFALSE 115236
// sDLaser := true ;
115228: LD_ADDR_EXP 193
115232: PUSH
115233: LD_INT 1
115235: ST_TO_ADDR
// if p3 = 30 then
115236: LD_VAR 0 3
115240: PUSH
115241: LD_INT 30
115243: EQUAL
115244: IFFALSE 115254
// sExchange := true ;
115246: LD_ADDR_EXP 194
115250: PUSH
115251: LD_INT 1
115253: ST_TO_ADDR
// if p3 = 31 then
115254: LD_VAR 0 3
115258: PUSH
115259: LD_INT 31
115261: EQUAL
115262: IFFALSE 115272
// sFac := true ;
115264: LD_ADDR_EXP 195
115268: PUSH
115269: LD_INT 1
115271: ST_TO_ADDR
// if p3 = 32 then
115272: LD_VAR 0 3
115276: PUSH
115277: LD_INT 32
115279: EQUAL
115280: IFFALSE 115290
// sPower := true ;
115282: LD_ADDR_EXP 196
115286: PUSH
115287: LD_INT 1
115289: ST_TO_ADDR
// if p3 = 33 then
115290: LD_VAR 0 3
115294: PUSH
115295: LD_INT 33
115297: EQUAL
115298: IFFALSE 115308
// sRandom := true ;
115300: LD_ADDR_EXP 197
115304: PUSH
115305: LD_INT 1
115307: ST_TO_ADDR
// if p3 = 34 then
115308: LD_VAR 0 3
115312: PUSH
115313: LD_INT 34
115315: EQUAL
115316: IFFALSE 115326
// sShield := true ;
115318: LD_ADDR_EXP 198
115322: PUSH
115323: LD_INT 1
115325: ST_TO_ADDR
// if p3 = 35 then
115326: LD_VAR 0 3
115330: PUSH
115331: LD_INT 35
115333: EQUAL
115334: IFFALSE 115344
// sTime := true ;
115336: LD_ADDR_EXP 199
115340: PUSH
115341: LD_INT 1
115343: ST_TO_ADDR
// if p3 = 36 then
115344: LD_VAR 0 3
115348: PUSH
115349: LD_INT 36
115351: EQUAL
115352: IFFALSE 115362
// sTools := true ;
115354: LD_ADDR_EXP 200
115358: PUSH
115359: LD_INT 1
115361: ST_TO_ADDR
// if p3 = 101 then
115362: LD_VAR 0 3
115366: PUSH
115367: LD_INT 101
115369: EQUAL
115370: IFFALSE 115380
// sSold := true ;
115372: LD_ADDR_EXP 165
115376: PUSH
115377: LD_INT 1
115379: ST_TO_ADDR
// if p3 = 102 then
115380: LD_VAR 0 3
115384: PUSH
115385: LD_INT 102
115387: EQUAL
115388: IFFALSE 115398
// sDiff := true ;
115390: LD_ADDR_EXP 166
115394: PUSH
115395: LD_INT 1
115397: ST_TO_ADDR
// if p3 = 103 then
115398: LD_VAR 0 3
115402: PUSH
115403: LD_INT 103
115405: EQUAL
115406: IFFALSE 115416
// sFog := true ;
115408: LD_ADDR_EXP 169
115412: PUSH
115413: LD_INT 1
115415: ST_TO_ADDR
// if p3 = 104 then
115416: LD_VAR 0 3
115420: PUSH
115421: LD_INT 104
115423: EQUAL
115424: IFFALSE 115434
// sReset := true ;
115426: LD_ADDR_EXP 170
115430: PUSH
115431: LD_INT 1
115433: ST_TO_ADDR
// if p3 = 105 then
115434: LD_VAR 0 3
115438: PUSH
115439: LD_INT 105
115441: EQUAL
115442: IFFALSE 115452
// sSun := true ;
115444: LD_ADDR_EXP 171
115448: PUSH
115449: LD_INT 1
115451: ST_TO_ADDR
// if p3 = 106 then
115452: LD_VAR 0 3
115456: PUSH
115457: LD_INT 106
115459: EQUAL
115460: IFFALSE 115470
// sTiger := true ;
115462: LD_ADDR_EXP 167
115466: PUSH
115467: LD_INT 1
115469: ST_TO_ADDR
// if p3 = 107 then
115470: LD_VAR 0 3
115474: PUSH
115475: LD_INT 107
115477: EQUAL
115478: IFFALSE 115488
// sBomb := true ;
115480: LD_ADDR_EXP 168
115484: PUSH
115485: LD_INT 1
115487: ST_TO_ADDR
// if p3 = 108 then
115488: LD_VAR 0 3
115492: PUSH
115493: LD_INT 108
115495: EQUAL
115496: IFFALSE 115506
// sWound := true ;
115498: LD_ADDR_EXP 176
115502: PUSH
115503: LD_INT 1
115505: ST_TO_ADDR
// if p3 = 109 then
115506: LD_VAR 0 3
115510: PUSH
115511: LD_INT 109
115513: EQUAL
115514: IFFALSE 115524
// sBetray := true ;
115516: LD_ADDR_EXP 180
115520: PUSH
115521: LD_INT 1
115523: ST_TO_ADDR
// if p3 = 110 then
115524: LD_VAR 0 3
115528: PUSH
115529: LD_INT 110
115531: EQUAL
115532: IFFALSE 115542
// sContamin := true ;
115534: LD_ADDR_EXP 181
115538: PUSH
115539: LD_INT 1
115541: ST_TO_ADDR
// if p3 = 111 then
115542: LD_VAR 0 3
115546: PUSH
115547: LD_INT 111
115549: EQUAL
115550: IFFALSE 115560
// sOil := true ;
115552: LD_ADDR_EXP 183
115556: PUSH
115557: LD_INT 1
115559: ST_TO_ADDR
// if p3 = 112 then
115560: LD_VAR 0 3
115564: PUSH
115565: LD_INT 112
115567: EQUAL
115568: IFFALSE 115578
// sStu := true ;
115570: LD_ADDR_EXP 187
115574: PUSH
115575: LD_INT 1
115577: ST_TO_ADDR
// if p3 = 113 then
115578: LD_VAR 0 3
115582: PUSH
115583: LD_INT 113
115585: EQUAL
115586: IFFALSE 115596
// sBazooka := true ;
115588: LD_ADDR_EXP 190
115592: PUSH
115593: LD_INT 1
115595: ST_TO_ADDR
// if p3 = 114 then
115596: LD_VAR 0 3
115600: PUSH
115601: LD_INT 114
115603: EQUAL
115604: IFFALSE 115614
// sMortar := true ;
115606: LD_ADDR_EXP 191
115610: PUSH
115611: LD_INT 1
115613: ST_TO_ADDR
// if p3 = 115 then
115614: LD_VAR 0 3
115618: PUSH
115619: LD_INT 115
115621: EQUAL
115622: IFFALSE 115632
// sRanger := true ;
115624: LD_ADDR_EXP 201
115628: PUSH
115629: LD_INT 1
115631: ST_TO_ADDR
// if p3 = 116 then
115632: LD_VAR 0 3
115636: PUSH
115637: LD_INT 116
115639: EQUAL
115640: IFFALSE 115650
// sComputer := true ;
115642: LD_ADDR_EXP 202
115646: PUSH
115647: LD_INT 1
115649: ST_TO_ADDR
// if p3 = 117 then
115650: LD_VAR 0 3
115654: PUSH
115655: LD_INT 117
115657: EQUAL
115658: IFFALSE 115668
// s30 := true ;
115660: LD_ADDR_EXP 203
115664: PUSH
115665: LD_INT 1
115667: ST_TO_ADDR
// if p3 = 118 then
115668: LD_VAR 0 3
115672: PUSH
115673: LD_INT 118
115675: EQUAL
115676: IFFALSE 115686
// s60 := true ;
115678: LD_ADDR_EXP 204
115682: PUSH
115683: LD_INT 1
115685: ST_TO_ADDR
// end ; if p2 = hack_mode then
115686: LD_VAR 0 2
115690: PUSH
115691: LD_INT 101
115693: EQUAL
115694: IFFALSE 115822
// begin case p3 of 1 :
115696: LD_VAR 0 3
115700: PUSH
115701: LD_INT 1
115703: DOUBLE
115704: EQUAL
115705: IFTRUE 115709
115707: GO 115716
115709: POP
// hHackUnlimitedResources ; 2 :
115710: CALL 128085 0 0
115714: GO 115822
115716: LD_INT 2
115718: DOUBLE
115719: EQUAL
115720: IFTRUE 115724
115722: GO 115731
115724: POP
// hHackSetLevel10 ; 3 :
115725: CALL 128218 0 0
115729: GO 115822
115731: LD_INT 3
115733: DOUBLE
115734: EQUAL
115735: IFTRUE 115739
115737: GO 115746
115739: POP
// hHackSetLevel10YourUnits ; 4 :
115740: CALL 128303 0 0
115744: GO 115822
115746: LD_INT 4
115748: DOUBLE
115749: EQUAL
115750: IFTRUE 115754
115752: GO 115761
115754: POP
// hHackInvincible ; 5 :
115755: CALL 128751 0 0
115759: GO 115822
115761: LD_INT 5
115763: DOUBLE
115764: EQUAL
115765: IFTRUE 115769
115767: GO 115776
115769: POP
// hHackInvisible ; 6 :
115770: CALL 128862 0 0
115774: GO 115822
115776: LD_INT 6
115778: DOUBLE
115779: EQUAL
115780: IFTRUE 115784
115782: GO 115791
115784: POP
// hHackChangeYourSide ; 7 :
115785: CALL 128919 0 0
115789: GO 115822
115791: LD_INT 7
115793: DOUBLE
115794: EQUAL
115795: IFTRUE 115799
115797: GO 115806
115799: POP
// hHackChangeUnitSide ; 8 :
115800: CALL 128961 0 0
115804: GO 115822
115806: LD_INT 8
115808: DOUBLE
115809: EQUAL
115810: IFTRUE 115814
115812: GO 115821
115814: POP
// hHackFog ; end ;
115815: CALL 129062 0 0
115819: GO 115822
115821: POP
// end ; if p2 = game_save_mode then
115822: LD_VAR 0 2
115826: PUSH
115827: LD_INT 102
115829: EQUAL
115830: IFFALSE 115887
// begin if p3 = 1 then
115832: LD_VAR 0 3
115836: PUSH
115837: LD_INT 1
115839: EQUAL
115840: IFFALSE 115852
// globalGameSaveCounter := p4 ;
115842: LD_ADDR_EXP 147
115846: PUSH
115847: LD_VAR 0 4
115851: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
115852: LD_VAR 0 3
115856: PUSH
115857: LD_INT 2
115859: EQUAL
115860: IFFALSE 115868
115862: PUSH
115863: LD_EXP 147
115867: AND
115868: IFFALSE 115887
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
115870: LD_STRING setGameSaveCounter(
115872: PUSH
115873: LD_EXP 147
115877: STR
115878: PUSH
115879: LD_STRING )
115881: STR
115882: PPUSH
115883: CALL_OW 559
// end ; end ;
115887: LD_VAR 0 7
115891: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
115892: LD_INT 0
115894: PPUSH
// streamModeActive := false ;
115895: LD_ADDR_EXP 148
115899: PUSH
115900: LD_INT 0
115902: ST_TO_ADDR
// normalCounter := 36 ;
115903: LD_ADDR_EXP 149
115907: PUSH
115908: LD_INT 36
115910: ST_TO_ADDR
// hardcoreCounter := 18 ;
115911: LD_ADDR_EXP 150
115915: PUSH
115916: LD_INT 18
115918: ST_TO_ADDR
// sRocket := false ;
115919: LD_ADDR_EXP 153
115923: PUSH
115924: LD_INT 0
115926: ST_TO_ADDR
// sSpeed := false ;
115927: LD_ADDR_EXP 152
115931: PUSH
115932: LD_INT 0
115934: ST_TO_ADDR
// sEngine := false ;
115935: LD_ADDR_EXP 154
115939: PUSH
115940: LD_INT 0
115942: ST_TO_ADDR
// sSpec := false ;
115943: LD_ADDR_EXP 151
115947: PUSH
115948: LD_INT 0
115950: ST_TO_ADDR
// sLevel := false ;
115951: LD_ADDR_EXP 155
115955: PUSH
115956: LD_INT 0
115958: ST_TO_ADDR
// sArmoury := false ;
115959: LD_ADDR_EXP 156
115963: PUSH
115964: LD_INT 0
115966: ST_TO_ADDR
// sRadar := false ;
115967: LD_ADDR_EXP 157
115971: PUSH
115972: LD_INT 0
115974: ST_TO_ADDR
// sBunker := false ;
115975: LD_ADDR_EXP 158
115979: PUSH
115980: LD_INT 0
115982: ST_TO_ADDR
// sHack := false ;
115983: LD_ADDR_EXP 159
115987: PUSH
115988: LD_INT 0
115990: ST_TO_ADDR
// sFire := false ;
115991: LD_ADDR_EXP 160
115995: PUSH
115996: LD_INT 0
115998: ST_TO_ADDR
// sRefresh := false ;
115999: LD_ADDR_EXP 161
116003: PUSH
116004: LD_INT 0
116006: ST_TO_ADDR
// sExp := false ;
116007: LD_ADDR_EXP 162
116011: PUSH
116012: LD_INT 0
116014: ST_TO_ADDR
// sDepot := false ;
116015: LD_ADDR_EXP 163
116019: PUSH
116020: LD_INT 0
116022: ST_TO_ADDR
// sFlag := false ;
116023: LD_ADDR_EXP 164
116027: PUSH
116028: LD_INT 0
116030: ST_TO_ADDR
// sKamikadze := false ;
116031: LD_ADDR_EXP 172
116035: PUSH
116036: LD_INT 0
116038: ST_TO_ADDR
// sTroll := false ;
116039: LD_ADDR_EXP 173
116043: PUSH
116044: LD_INT 0
116046: ST_TO_ADDR
// sSlow := false ;
116047: LD_ADDR_EXP 174
116051: PUSH
116052: LD_INT 0
116054: ST_TO_ADDR
// sLack := false ;
116055: LD_ADDR_EXP 175
116059: PUSH
116060: LD_INT 0
116062: ST_TO_ADDR
// sTank := false ;
116063: LD_ADDR_EXP 177
116067: PUSH
116068: LD_INT 0
116070: ST_TO_ADDR
// sRemote := false ;
116071: LD_ADDR_EXP 178
116075: PUSH
116076: LD_INT 0
116078: ST_TO_ADDR
// sPowell := false ;
116079: LD_ADDR_EXP 179
116083: PUSH
116084: LD_INT 0
116086: ST_TO_ADDR
// sTeleport := false ;
116087: LD_ADDR_EXP 182
116091: PUSH
116092: LD_INT 0
116094: ST_TO_ADDR
// sOilTower := false ;
116095: LD_ADDR_EXP 184
116099: PUSH
116100: LD_INT 0
116102: ST_TO_ADDR
// sShovel := false ;
116103: LD_ADDR_EXP 185
116107: PUSH
116108: LD_INT 0
116110: ST_TO_ADDR
// sSheik := false ;
116111: LD_ADDR_EXP 186
116115: PUSH
116116: LD_INT 0
116118: ST_TO_ADDR
// sEarthquake := false ;
116119: LD_ADDR_EXP 188
116123: PUSH
116124: LD_INT 0
116126: ST_TO_ADDR
// sAI := false ;
116127: LD_ADDR_EXP 189
116131: PUSH
116132: LD_INT 0
116134: ST_TO_ADDR
// sCargo := false ;
116135: LD_ADDR_EXP 192
116139: PUSH
116140: LD_INT 0
116142: ST_TO_ADDR
// sDLaser := false ;
116143: LD_ADDR_EXP 193
116147: PUSH
116148: LD_INT 0
116150: ST_TO_ADDR
// sExchange := false ;
116151: LD_ADDR_EXP 194
116155: PUSH
116156: LD_INT 0
116158: ST_TO_ADDR
// sFac := false ;
116159: LD_ADDR_EXP 195
116163: PUSH
116164: LD_INT 0
116166: ST_TO_ADDR
// sPower := false ;
116167: LD_ADDR_EXP 196
116171: PUSH
116172: LD_INT 0
116174: ST_TO_ADDR
// sRandom := false ;
116175: LD_ADDR_EXP 197
116179: PUSH
116180: LD_INT 0
116182: ST_TO_ADDR
// sShield := false ;
116183: LD_ADDR_EXP 198
116187: PUSH
116188: LD_INT 0
116190: ST_TO_ADDR
// sTime := false ;
116191: LD_ADDR_EXP 199
116195: PUSH
116196: LD_INT 0
116198: ST_TO_ADDR
// sTools := false ;
116199: LD_ADDR_EXP 200
116203: PUSH
116204: LD_INT 0
116206: ST_TO_ADDR
// sSold := false ;
116207: LD_ADDR_EXP 165
116211: PUSH
116212: LD_INT 0
116214: ST_TO_ADDR
// sDiff := false ;
116215: LD_ADDR_EXP 166
116219: PUSH
116220: LD_INT 0
116222: ST_TO_ADDR
// sFog := false ;
116223: LD_ADDR_EXP 169
116227: PUSH
116228: LD_INT 0
116230: ST_TO_ADDR
// sReset := false ;
116231: LD_ADDR_EXP 170
116235: PUSH
116236: LD_INT 0
116238: ST_TO_ADDR
// sSun := false ;
116239: LD_ADDR_EXP 171
116243: PUSH
116244: LD_INT 0
116246: ST_TO_ADDR
// sTiger := false ;
116247: LD_ADDR_EXP 167
116251: PUSH
116252: LD_INT 0
116254: ST_TO_ADDR
// sBomb := false ;
116255: LD_ADDR_EXP 168
116259: PUSH
116260: LD_INT 0
116262: ST_TO_ADDR
// sWound := false ;
116263: LD_ADDR_EXP 176
116267: PUSH
116268: LD_INT 0
116270: ST_TO_ADDR
// sBetray := false ;
116271: LD_ADDR_EXP 180
116275: PUSH
116276: LD_INT 0
116278: ST_TO_ADDR
// sContamin := false ;
116279: LD_ADDR_EXP 181
116283: PUSH
116284: LD_INT 0
116286: ST_TO_ADDR
// sOil := false ;
116287: LD_ADDR_EXP 183
116291: PUSH
116292: LD_INT 0
116294: ST_TO_ADDR
// sStu := false ;
116295: LD_ADDR_EXP 187
116299: PUSH
116300: LD_INT 0
116302: ST_TO_ADDR
// sBazooka := false ;
116303: LD_ADDR_EXP 190
116307: PUSH
116308: LD_INT 0
116310: ST_TO_ADDR
// sMortar := false ;
116311: LD_ADDR_EXP 191
116315: PUSH
116316: LD_INT 0
116318: ST_TO_ADDR
// sRanger := false ;
116319: LD_ADDR_EXP 201
116323: PUSH
116324: LD_INT 0
116326: ST_TO_ADDR
// sComputer := false ;
116327: LD_ADDR_EXP 202
116331: PUSH
116332: LD_INT 0
116334: ST_TO_ADDR
// s30 := false ;
116335: LD_ADDR_EXP 203
116339: PUSH
116340: LD_INT 0
116342: ST_TO_ADDR
// s60 := false ;
116343: LD_ADDR_EXP 204
116347: PUSH
116348: LD_INT 0
116350: ST_TO_ADDR
// end ;
116351: LD_VAR 0 1
116355: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
116356: LD_INT 0
116358: PPUSH
116359: PPUSH
116360: PPUSH
116361: PPUSH
116362: PPUSH
116363: PPUSH
116364: PPUSH
// result := [ ] ;
116365: LD_ADDR_VAR 0 2
116369: PUSH
116370: EMPTY
116371: ST_TO_ADDR
// if campaign_id = 1 then
116372: LD_OWVAR 69
116376: PUSH
116377: LD_INT 1
116379: EQUAL
116380: IFFALSE 119546
// begin case mission_number of 1 :
116382: LD_OWVAR 70
116386: PUSH
116387: LD_INT 1
116389: DOUBLE
116390: EQUAL
116391: IFTRUE 116395
116393: GO 116471
116395: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
116396: LD_ADDR_VAR 0 2
116400: PUSH
116401: LD_INT 2
116403: PUSH
116404: LD_INT 4
116406: PUSH
116407: LD_INT 11
116409: PUSH
116410: LD_INT 12
116412: PUSH
116413: LD_INT 15
116415: PUSH
116416: LD_INT 16
116418: PUSH
116419: LD_INT 22
116421: PUSH
116422: LD_INT 23
116424: PUSH
116425: LD_INT 26
116427: PUSH
116428: EMPTY
116429: LIST
116430: LIST
116431: LIST
116432: LIST
116433: LIST
116434: LIST
116435: LIST
116436: LIST
116437: LIST
116438: PUSH
116439: LD_INT 101
116441: PUSH
116442: LD_INT 102
116444: PUSH
116445: LD_INT 106
116447: PUSH
116448: LD_INT 116
116450: PUSH
116451: LD_INT 117
116453: PUSH
116454: LD_INT 118
116456: PUSH
116457: EMPTY
116458: LIST
116459: LIST
116460: LIST
116461: LIST
116462: LIST
116463: LIST
116464: PUSH
116465: EMPTY
116466: LIST
116467: LIST
116468: ST_TO_ADDR
116469: GO 119544
116471: LD_INT 2
116473: DOUBLE
116474: EQUAL
116475: IFTRUE 116479
116477: GO 116563
116479: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
116480: LD_ADDR_VAR 0 2
116484: PUSH
116485: LD_INT 2
116487: PUSH
116488: LD_INT 4
116490: PUSH
116491: LD_INT 11
116493: PUSH
116494: LD_INT 12
116496: PUSH
116497: LD_INT 15
116499: PUSH
116500: LD_INT 16
116502: PUSH
116503: LD_INT 22
116505: PUSH
116506: LD_INT 23
116508: PUSH
116509: LD_INT 26
116511: PUSH
116512: EMPTY
116513: LIST
116514: LIST
116515: LIST
116516: LIST
116517: LIST
116518: LIST
116519: LIST
116520: LIST
116521: LIST
116522: PUSH
116523: LD_INT 101
116525: PUSH
116526: LD_INT 102
116528: PUSH
116529: LD_INT 105
116531: PUSH
116532: LD_INT 106
116534: PUSH
116535: LD_INT 108
116537: PUSH
116538: LD_INT 116
116540: PUSH
116541: LD_INT 117
116543: PUSH
116544: LD_INT 118
116546: PUSH
116547: EMPTY
116548: LIST
116549: LIST
116550: LIST
116551: LIST
116552: LIST
116553: LIST
116554: LIST
116555: LIST
116556: PUSH
116557: EMPTY
116558: LIST
116559: LIST
116560: ST_TO_ADDR
116561: GO 119544
116563: LD_INT 3
116565: DOUBLE
116566: EQUAL
116567: IFTRUE 116571
116569: GO 116659
116571: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
116572: LD_ADDR_VAR 0 2
116576: PUSH
116577: LD_INT 2
116579: PUSH
116580: LD_INT 4
116582: PUSH
116583: LD_INT 5
116585: PUSH
116586: LD_INT 11
116588: PUSH
116589: LD_INT 12
116591: PUSH
116592: LD_INT 15
116594: PUSH
116595: LD_INT 16
116597: PUSH
116598: LD_INT 22
116600: PUSH
116601: LD_INT 26
116603: PUSH
116604: LD_INT 36
116606: PUSH
116607: EMPTY
116608: LIST
116609: LIST
116610: LIST
116611: LIST
116612: LIST
116613: LIST
116614: LIST
116615: LIST
116616: LIST
116617: LIST
116618: PUSH
116619: LD_INT 101
116621: PUSH
116622: LD_INT 102
116624: PUSH
116625: LD_INT 105
116627: PUSH
116628: LD_INT 106
116630: PUSH
116631: LD_INT 108
116633: PUSH
116634: LD_INT 116
116636: PUSH
116637: LD_INT 117
116639: PUSH
116640: LD_INT 118
116642: PUSH
116643: EMPTY
116644: LIST
116645: LIST
116646: LIST
116647: LIST
116648: LIST
116649: LIST
116650: LIST
116651: LIST
116652: PUSH
116653: EMPTY
116654: LIST
116655: LIST
116656: ST_TO_ADDR
116657: GO 119544
116659: LD_INT 4
116661: DOUBLE
116662: EQUAL
116663: IFTRUE 116667
116665: GO 116763
116667: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
116668: LD_ADDR_VAR 0 2
116672: PUSH
116673: LD_INT 2
116675: PUSH
116676: LD_INT 4
116678: PUSH
116679: LD_INT 5
116681: PUSH
116682: LD_INT 8
116684: PUSH
116685: LD_INT 11
116687: PUSH
116688: LD_INT 12
116690: PUSH
116691: LD_INT 15
116693: PUSH
116694: LD_INT 16
116696: PUSH
116697: LD_INT 22
116699: PUSH
116700: LD_INT 23
116702: PUSH
116703: LD_INT 26
116705: PUSH
116706: LD_INT 36
116708: PUSH
116709: EMPTY
116710: LIST
116711: LIST
116712: LIST
116713: LIST
116714: LIST
116715: LIST
116716: LIST
116717: LIST
116718: LIST
116719: LIST
116720: LIST
116721: LIST
116722: PUSH
116723: LD_INT 101
116725: PUSH
116726: LD_INT 102
116728: PUSH
116729: LD_INT 105
116731: PUSH
116732: LD_INT 106
116734: PUSH
116735: LD_INT 108
116737: PUSH
116738: LD_INT 116
116740: PUSH
116741: LD_INT 117
116743: PUSH
116744: LD_INT 118
116746: PUSH
116747: EMPTY
116748: LIST
116749: LIST
116750: LIST
116751: LIST
116752: LIST
116753: LIST
116754: LIST
116755: LIST
116756: PUSH
116757: EMPTY
116758: LIST
116759: LIST
116760: ST_TO_ADDR
116761: GO 119544
116763: LD_INT 5
116765: DOUBLE
116766: EQUAL
116767: IFTRUE 116771
116769: GO 116883
116771: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
116772: LD_ADDR_VAR 0 2
116776: PUSH
116777: LD_INT 2
116779: PUSH
116780: LD_INT 4
116782: PUSH
116783: LD_INT 5
116785: PUSH
116786: LD_INT 6
116788: PUSH
116789: LD_INT 8
116791: PUSH
116792: LD_INT 11
116794: PUSH
116795: LD_INT 12
116797: PUSH
116798: LD_INT 15
116800: PUSH
116801: LD_INT 16
116803: PUSH
116804: LD_INT 22
116806: PUSH
116807: LD_INT 23
116809: PUSH
116810: LD_INT 25
116812: PUSH
116813: LD_INT 26
116815: PUSH
116816: LD_INT 36
116818: PUSH
116819: EMPTY
116820: LIST
116821: LIST
116822: LIST
116823: LIST
116824: LIST
116825: LIST
116826: LIST
116827: LIST
116828: LIST
116829: LIST
116830: LIST
116831: LIST
116832: LIST
116833: LIST
116834: PUSH
116835: LD_INT 101
116837: PUSH
116838: LD_INT 102
116840: PUSH
116841: LD_INT 105
116843: PUSH
116844: LD_INT 106
116846: PUSH
116847: LD_INT 108
116849: PUSH
116850: LD_INT 109
116852: PUSH
116853: LD_INT 112
116855: PUSH
116856: LD_INT 116
116858: PUSH
116859: LD_INT 117
116861: PUSH
116862: LD_INT 118
116864: PUSH
116865: EMPTY
116866: LIST
116867: LIST
116868: LIST
116869: LIST
116870: LIST
116871: LIST
116872: LIST
116873: LIST
116874: LIST
116875: LIST
116876: PUSH
116877: EMPTY
116878: LIST
116879: LIST
116880: ST_TO_ADDR
116881: GO 119544
116883: LD_INT 6
116885: DOUBLE
116886: EQUAL
116887: IFTRUE 116891
116889: GO 117023
116891: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
116892: LD_ADDR_VAR 0 2
116896: PUSH
116897: LD_INT 2
116899: PUSH
116900: LD_INT 4
116902: PUSH
116903: LD_INT 5
116905: PUSH
116906: LD_INT 6
116908: PUSH
116909: LD_INT 8
116911: PUSH
116912: LD_INT 11
116914: PUSH
116915: LD_INT 12
116917: PUSH
116918: LD_INT 15
116920: PUSH
116921: LD_INT 16
116923: PUSH
116924: LD_INT 20
116926: PUSH
116927: LD_INT 21
116929: PUSH
116930: LD_INT 22
116932: PUSH
116933: LD_INT 23
116935: PUSH
116936: LD_INT 25
116938: PUSH
116939: LD_INT 26
116941: PUSH
116942: LD_INT 30
116944: PUSH
116945: LD_INT 31
116947: PUSH
116948: LD_INT 32
116950: PUSH
116951: LD_INT 36
116953: PUSH
116954: EMPTY
116955: LIST
116956: LIST
116957: LIST
116958: LIST
116959: LIST
116960: LIST
116961: LIST
116962: LIST
116963: LIST
116964: LIST
116965: LIST
116966: LIST
116967: LIST
116968: LIST
116969: LIST
116970: LIST
116971: LIST
116972: LIST
116973: LIST
116974: PUSH
116975: LD_INT 101
116977: PUSH
116978: LD_INT 102
116980: PUSH
116981: LD_INT 105
116983: PUSH
116984: LD_INT 106
116986: PUSH
116987: LD_INT 108
116989: PUSH
116990: LD_INT 109
116992: PUSH
116993: LD_INT 112
116995: PUSH
116996: LD_INT 116
116998: PUSH
116999: LD_INT 117
117001: PUSH
117002: LD_INT 118
117004: PUSH
117005: EMPTY
117006: LIST
117007: LIST
117008: LIST
117009: LIST
117010: LIST
117011: LIST
117012: LIST
117013: LIST
117014: LIST
117015: LIST
117016: PUSH
117017: EMPTY
117018: LIST
117019: LIST
117020: ST_TO_ADDR
117021: GO 119544
117023: LD_INT 7
117025: DOUBLE
117026: EQUAL
117027: IFTRUE 117031
117029: GO 117143
117031: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
117032: LD_ADDR_VAR 0 2
117036: PUSH
117037: LD_INT 2
117039: PUSH
117040: LD_INT 4
117042: PUSH
117043: LD_INT 5
117045: PUSH
117046: LD_INT 7
117048: PUSH
117049: LD_INT 11
117051: PUSH
117052: LD_INT 12
117054: PUSH
117055: LD_INT 15
117057: PUSH
117058: LD_INT 16
117060: PUSH
117061: LD_INT 20
117063: PUSH
117064: LD_INT 21
117066: PUSH
117067: LD_INT 22
117069: PUSH
117070: LD_INT 23
117072: PUSH
117073: LD_INT 25
117075: PUSH
117076: LD_INT 26
117078: PUSH
117079: EMPTY
117080: LIST
117081: LIST
117082: LIST
117083: LIST
117084: LIST
117085: LIST
117086: LIST
117087: LIST
117088: LIST
117089: LIST
117090: LIST
117091: LIST
117092: LIST
117093: LIST
117094: PUSH
117095: LD_INT 101
117097: PUSH
117098: LD_INT 102
117100: PUSH
117101: LD_INT 103
117103: PUSH
117104: LD_INT 105
117106: PUSH
117107: LD_INT 106
117109: PUSH
117110: LD_INT 108
117112: PUSH
117113: LD_INT 112
117115: PUSH
117116: LD_INT 116
117118: PUSH
117119: LD_INT 117
117121: PUSH
117122: LD_INT 118
117124: PUSH
117125: EMPTY
117126: LIST
117127: LIST
117128: LIST
117129: LIST
117130: LIST
117131: LIST
117132: LIST
117133: LIST
117134: LIST
117135: LIST
117136: PUSH
117137: EMPTY
117138: LIST
117139: LIST
117140: ST_TO_ADDR
117141: GO 119544
117143: LD_INT 8
117145: DOUBLE
117146: EQUAL
117147: IFTRUE 117151
117149: GO 117291
117151: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
117152: LD_ADDR_VAR 0 2
117156: PUSH
117157: LD_INT 2
117159: PUSH
117160: LD_INT 4
117162: PUSH
117163: LD_INT 5
117165: PUSH
117166: LD_INT 6
117168: PUSH
117169: LD_INT 7
117171: PUSH
117172: LD_INT 8
117174: PUSH
117175: LD_INT 11
117177: PUSH
117178: LD_INT 12
117180: PUSH
117181: LD_INT 15
117183: PUSH
117184: LD_INT 16
117186: PUSH
117187: LD_INT 20
117189: PUSH
117190: LD_INT 21
117192: PUSH
117193: LD_INT 22
117195: PUSH
117196: LD_INT 23
117198: PUSH
117199: LD_INT 25
117201: PUSH
117202: LD_INT 26
117204: PUSH
117205: LD_INT 30
117207: PUSH
117208: LD_INT 31
117210: PUSH
117211: LD_INT 32
117213: PUSH
117214: LD_INT 36
117216: PUSH
117217: EMPTY
117218: LIST
117219: LIST
117220: LIST
117221: LIST
117222: LIST
117223: LIST
117224: LIST
117225: LIST
117226: LIST
117227: LIST
117228: LIST
117229: LIST
117230: LIST
117231: LIST
117232: LIST
117233: LIST
117234: LIST
117235: LIST
117236: LIST
117237: LIST
117238: PUSH
117239: LD_INT 101
117241: PUSH
117242: LD_INT 102
117244: PUSH
117245: LD_INT 103
117247: PUSH
117248: LD_INT 105
117250: PUSH
117251: LD_INT 106
117253: PUSH
117254: LD_INT 108
117256: PUSH
117257: LD_INT 109
117259: PUSH
117260: LD_INT 112
117262: PUSH
117263: LD_INT 116
117265: PUSH
117266: LD_INT 117
117268: PUSH
117269: LD_INT 118
117271: PUSH
117272: EMPTY
117273: LIST
117274: LIST
117275: LIST
117276: LIST
117277: LIST
117278: LIST
117279: LIST
117280: LIST
117281: LIST
117282: LIST
117283: LIST
117284: PUSH
117285: EMPTY
117286: LIST
117287: LIST
117288: ST_TO_ADDR
117289: GO 119544
117291: LD_INT 9
117293: DOUBLE
117294: EQUAL
117295: IFTRUE 117299
117297: GO 117447
117299: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
117300: LD_ADDR_VAR 0 2
117304: PUSH
117305: LD_INT 2
117307: PUSH
117308: LD_INT 4
117310: PUSH
117311: LD_INT 5
117313: PUSH
117314: LD_INT 6
117316: PUSH
117317: LD_INT 7
117319: PUSH
117320: LD_INT 8
117322: PUSH
117323: LD_INT 11
117325: PUSH
117326: LD_INT 12
117328: PUSH
117329: LD_INT 15
117331: PUSH
117332: LD_INT 16
117334: PUSH
117335: LD_INT 20
117337: PUSH
117338: LD_INT 21
117340: PUSH
117341: LD_INT 22
117343: PUSH
117344: LD_INT 23
117346: PUSH
117347: LD_INT 25
117349: PUSH
117350: LD_INT 26
117352: PUSH
117353: LD_INT 28
117355: PUSH
117356: LD_INT 30
117358: PUSH
117359: LD_INT 31
117361: PUSH
117362: LD_INT 32
117364: PUSH
117365: LD_INT 36
117367: PUSH
117368: EMPTY
117369: LIST
117370: LIST
117371: LIST
117372: LIST
117373: LIST
117374: LIST
117375: LIST
117376: LIST
117377: LIST
117378: LIST
117379: LIST
117380: LIST
117381: LIST
117382: LIST
117383: LIST
117384: LIST
117385: LIST
117386: LIST
117387: LIST
117388: LIST
117389: LIST
117390: PUSH
117391: LD_INT 101
117393: PUSH
117394: LD_INT 102
117396: PUSH
117397: LD_INT 103
117399: PUSH
117400: LD_INT 105
117402: PUSH
117403: LD_INT 106
117405: PUSH
117406: LD_INT 108
117408: PUSH
117409: LD_INT 109
117411: PUSH
117412: LD_INT 112
117414: PUSH
117415: LD_INT 114
117417: PUSH
117418: LD_INT 116
117420: PUSH
117421: LD_INT 117
117423: PUSH
117424: LD_INT 118
117426: PUSH
117427: EMPTY
117428: LIST
117429: LIST
117430: LIST
117431: LIST
117432: LIST
117433: LIST
117434: LIST
117435: LIST
117436: LIST
117437: LIST
117438: LIST
117439: LIST
117440: PUSH
117441: EMPTY
117442: LIST
117443: LIST
117444: ST_TO_ADDR
117445: GO 119544
117447: LD_INT 10
117449: DOUBLE
117450: EQUAL
117451: IFTRUE 117455
117453: GO 117651
117455: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
117456: LD_ADDR_VAR 0 2
117460: PUSH
117461: LD_INT 2
117463: PUSH
117464: LD_INT 4
117466: PUSH
117467: LD_INT 5
117469: PUSH
117470: LD_INT 6
117472: PUSH
117473: LD_INT 7
117475: PUSH
117476: LD_INT 8
117478: PUSH
117479: LD_INT 9
117481: PUSH
117482: LD_INT 10
117484: PUSH
117485: LD_INT 11
117487: PUSH
117488: LD_INT 12
117490: PUSH
117491: LD_INT 13
117493: PUSH
117494: LD_INT 14
117496: PUSH
117497: LD_INT 15
117499: PUSH
117500: LD_INT 16
117502: PUSH
117503: LD_INT 17
117505: PUSH
117506: LD_INT 18
117508: PUSH
117509: LD_INT 19
117511: PUSH
117512: LD_INT 20
117514: PUSH
117515: LD_INT 21
117517: PUSH
117518: LD_INT 22
117520: PUSH
117521: LD_INT 23
117523: PUSH
117524: LD_INT 24
117526: PUSH
117527: LD_INT 25
117529: PUSH
117530: LD_INT 26
117532: PUSH
117533: LD_INT 28
117535: PUSH
117536: LD_INT 30
117538: PUSH
117539: LD_INT 31
117541: PUSH
117542: LD_INT 32
117544: PUSH
117545: LD_INT 36
117547: PUSH
117548: EMPTY
117549: LIST
117550: LIST
117551: LIST
117552: LIST
117553: LIST
117554: LIST
117555: LIST
117556: LIST
117557: LIST
117558: LIST
117559: LIST
117560: LIST
117561: LIST
117562: LIST
117563: LIST
117564: LIST
117565: LIST
117566: LIST
117567: LIST
117568: LIST
117569: LIST
117570: LIST
117571: LIST
117572: LIST
117573: LIST
117574: LIST
117575: LIST
117576: LIST
117577: LIST
117578: PUSH
117579: LD_INT 101
117581: PUSH
117582: LD_INT 102
117584: PUSH
117585: LD_INT 103
117587: PUSH
117588: LD_INT 104
117590: PUSH
117591: LD_INT 105
117593: PUSH
117594: LD_INT 106
117596: PUSH
117597: LD_INT 107
117599: PUSH
117600: LD_INT 108
117602: PUSH
117603: LD_INT 109
117605: PUSH
117606: LD_INT 110
117608: PUSH
117609: LD_INT 111
117611: PUSH
117612: LD_INT 112
117614: PUSH
117615: LD_INT 114
117617: PUSH
117618: LD_INT 116
117620: PUSH
117621: LD_INT 117
117623: PUSH
117624: LD_INT 118
117626: PUSH
117627: EMPTY
117628: LIST
117629: LIST
117630: LIST
117631: LIST
117632: LIST
117633: LIST
117634: LIST
117635: LIST
117636: LIST
117637: LIST
117638: LIST
117639: LIST
117640: LIST
117641: LIST
117642: LIST
117643: LIST
117644: PUSH
117645: EMPTY
117646: LIST
117647: LIST
117648: ST_TO_ADDR
117649: GO 119544
117651: LD_INT 11
117653: DOUBLE
117654: EQUAL
117655: IFTRUE 117659
117657: GO 117863
117659: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
117660: LD_ADDR_VAR 0 2
117664: PUSH
117665: LD_INT 2
117667: PUSH
117668: LD_INT 3
117670: PUSH
117671: LD_INT 4
117673: PUSH
117674: LD_INT 5
117676: PUSH
117677: LD_INT 6
117679: PUSH
117680: LD_INT 7
117682: PUSH
117683: LD_INT 8
117685: PUSH
117686: LD_INT 9
117688: PUSH
117689: LD_INT 10
117691: PUSH
117692: LD_INT 11
117694: PUSH
117695: LD_INT 12
117697: PUSH
117698: LD_INT 13
117700: PUSH
117701: LD_INT 14
117703: PUSH
117704: LD_INT 15
117706: PUSH
117707: LD_INT 16
117709: PUSH
117710: LD_INT 17
117712: PUSH
117713: LD_INT 18
117715: PUSH
117716: LD_INT 19
117718: PUSH
117719: LD_INT 20
117721: PUSH
117722: LD_INT 21
117724: PUSH
117725: LD_INT 22
117727: PUSH
117728: LD_INT 23
117730: PUSH
117731: LD_INT 24
117733: PUSH
117734: LD_INT 25
117736: PUSH
117737: LD_INT 26
117739: PUSH
117740: LD_INT 28
117742: PUSH
117743: LD_INT 30
117745: PUSH
117746: LD_INT 31
117748: PUSH
117749: LD_INT 32
117751: PUSH
117752: LD_INT 34
117754: PUSH
117755: LD_INT 36
117757: PUSH
117758: EMPTY
117759: LIST
117760: LIST
117761: LIST
117762: LIST
117763: LIST
117764: LIST
117765: LIST
117766: LIST
117767: LIST
117768: LIST
117769: LIST
117770: LIST
117771: LIST
117772: LIST
117773: LIST
117774: LIST
117775: LIST
117776: LIST
117777: LIST
117778: LIST
117779: LIST
117780: LIST
117781: LIST
117782: LIST
117783: LIST
117784: LIST
117785: LIST
117786: LIST
117787: LIST
117788: LIST
117789: LIST
117790: PUSH
117791: LD_INT 101
117793: PUSH
117794: LD_INT 102
117796: PUSH
117797: LD_INT 103
117799: PUSH
117800: LD_INT 104
117802: PUSH
117803: LD_INT 105
117805: PUSH
117806: LD_INT 106
117808: PUSH
117809: LD_INT 107
117811: PUSH
117812: LD_INT 108
117814: PUSH
117815: LD_INT 109
117817: PUSH
117818: LD_INT 110
117820: PUSH
117821: LD_INT 111
117823: PUSH
117824: LD_INT 112
117826: PUSH
117827: LD_INT 114
117829: PUSH
117830: LD_INT 116
117832: PUSH
117833: LD_INT 117
117835: PUSH
117836: LD_INT 118
117838: PUSH
117839: EMPTY
117840: LIST
117841: LIST
117842: LIST
117843: LIST
117844: LIST
117845: LIST
117846: LIST
117847: LIST
117848: LIST
117849: LIST
117850: LIST
117851: LIST
117852: LIST
117853: LIST
117854: LIST
117855: LIST
117856: PUSH
117857: EMPTY
117858: LIST
117859: LIST
117860: ST_TO_ADDR
117861: GO 119544
117863: LD_INT 12
117865: DOUBLE
117866: EQUAL
117867: IFTRUE 117871
117869: GO 118091
117871: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
117872: LD_ADDR_VAR 0 2
117876: PUSH
117877: LD_INT 1
117879: PUSH
117880: LD_INT 2
117882: PUSH
117883: LD_INT 3
117885: PUSH
117886: LD_INT 4
117888: PUSH
117889: LD_INT 5
117891: PUSH
117892: LD_INT 6
117894: PUSH
117895: LD_INT 7
117897: PUSH
117898: LD_INT 8
117900: PUSH
117901: LD_INT 9
117903: PUSH
117904: LD_INT 10
117906: PUSH
117907: LD_INT 11
117909: PUSH
117910: LD_INT 12
117912: PUSH
117913: LD_INT 13
117915: PUSH
117916: LD_INT 14
117918: PUSH
117919: LD_INT 15
117921: PUSH
117922: LD_INT 16
117924: PUSH
117925: LD_INT 17
117927: PUSH
117928: LD_INT 18
117930: PUSH
117931: LD_INT 19
117933: PUSH
117934: LD_INT 20
117936: PUSH
117937: LD_INT 21
117939: PUSH
117940: LD_INT 22
117942: PUSH
117943: LD_INT 23
117945: PUSH
117946: LD_INT 24
117948: PUSH
117949: LD_INT 25
117951: PUSH
117952: LD_INT 26
117954: PUSH
117955: LD_INT 27
117957: PUSH
117958: LD_INT 28
117960: PUSH
117961: LD_INT 30
117963: PUSH
117964: LD_INT 31
117966: PUSH
117967: LD_INT 32
117969: PUSH
117970: LD_INT 33
117972: PUSH
117973: LD_INT 34
117975: PUSH
117976: LD_INT 36
117978: PUSH
117979: EMPTY
117980: LIST
117981: LIST
117982: LIST
117983: LIST
117984: LIST
117985: LIST
117986: LIST
117987: LIST
117988: LIST
117989: LIST
117990: LIST
117991: LIST
117992: LIST
117993: LIST
117994: LIST
117995: LIST
117996: LIST
117997: LIST
117998: LIST
117999: LIST
118000: LIST
118001: LIST
118002: LIST
118003: LIST
118004: LIST
118005: LIST
118006: LIST
118007: LIST
118008: LIST
118009: LIST
118010: LIST
118011: LIST
118012: LIST
118013: LIST
118014: PUSH
118015: LD_INT 101
118017: PUSH
118018: LD_INT 102
118020: PUSH
118021: LD_INT 103
118023: PUSH
118024: LD_INT 104
118026: PUSH
118027: LD_INT 105
118029: PUSH
118030: LD_INT 106
118032: PUSH
118033: LD_INT 107
118035: PUSH
118036: LD_INT 108
118038: PUSH
118039: LD_INT 109
118041: PUSH
118042: LD_INT 110
118044: PUSH
118045: LD_INT 111
118047: PUSH
118048: LD_INT 112
118050: PUSH
118051: LD_INT 113
118053: PUSH
118054: LD_INT 114
118056: PUSH
118057: LD_INT 116
118059: PUSH
118060: LD_INT 117
118062: PUSH
118063: LD_INT 118
118065: PUSH
118066: EMPTY
118067: LIST
118068: LIST
118069: LIST
118070: LIST
118071: LIST
118072: LIST
118073: LIST
118074: LIST
118075: LIST
118076: LIST
118077: LIST
118078: LIST
118079: LIST
118080: LIST
118081: LIST
118082: LIST
118083: LIST
118084: PUSH
118085: EMPTY
118086: LIST
118087: LIST
118088: ST_TO_ADDR
118089: GO 119544
118091: LD_INT 13
118093: DOUBLE
118094: EQUAL
118095: IFTRUE 118099
118097: GO 118307
118099: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
118100: LD_ADDR_VAR 0 2
118104: PUSH
118105: LD_INT 1
118107: PUSH
118108: LD_INT 2
118110: PUSH
118111: LD_INT 3
118113: PUSH
118114: LD_INT 4
118116: PUSH
118117: LD_INT 5
118119: PUSH
118120: LD_INT 8
118122: PUSH
118123: LD_INT 9
118125: PUSH
118126: LD_INT 10
118128: PUSH
118129: LD_INT 11
118131: PUSH
118132: LD_INT 12
118134: PUSH
118135: LD_INT 14
118137: PUSH
118138: LD_INT 15
118140: PUSH
118141: LD_INT 16
118143: PUSH
118144: LD_INT 17
118146: PUSH
118147: LD_INT 18
118149: PUSH
118150: LD_INT 19
118152: PUSH
118153: LD_INT 20
118155: PUSH
118156: LD_INT 21
118158: PUSH
118159: LD_INT 22
118161: PUSH
118162: LD_INT 23
118164: PUSH
118165: LD_INT 24
118167: PUSH
118168: LD_INT 25
118170: PUSH
118171: LD_INT 26
118173: PUSH
118174: LD_INT 27
118176: PUSH
118177: LD_INT 28
118179: PUSH
118180: LD_INT 30
118182: PUSH
118183: LD_INT 31
118185: PUSH
118186: LD_INT 32
118188: PUSH
118189: LD_INT 33
118191: PUSH
118192: LD_INT 34
118194: PUSH
118195: LD_INT 36
118197: PUSH
118198: EMPTY
118199: LIST
118200: LIST
118201: LIST
118202: LIST
118203: LIST
118204: LIST
118205: LIST
118206: LIST
118207: LIST
118208: LIST
118209: LIST
118210: LIST
118211: LIST
118212: LIST
118213: LIST
118214: LIST
118215: LIST
118216: LIST
118217: LIST
118218: LIST
118219: LIST
118220: LIST
118221: LIST
118222: LIST
118223: LIST
118224: LIST
118225: LIST
118226: LIST
118227: LIST
118228: LIST
118229: LIST
118230: PUSH
118231: LD_INT 101
118233: PUSH
118234: LD_INT 102
118236: PUSH
118237: LD_INT 103
118239: PUSH
118240: LD_INT 104
118242: PUSH
118243: LD_INT 105
118245: PUSH
118246: LD_INT 106
118248: PUSH
118249: LD_INT 107
118251: PUSH
118252: LD_INT 108
118254: PUSH
118255: LD_INT 109
118257: PUSH
118258: LD_INT 110
118260: PUSH
118261: LD_INT 111
118263: PUSH
118264: LD_INT 112
118266: PUSH
118267: LD_INT 113
118269: PUSH
118270: LD_INT 114
118272: PUSH
118273: LD_INT 116
118275: PUSH
118276: LD_INT 117
118278: PUSH
118279: LD_INT 118
118281: PUSH
118282: EMPTY
118283: LIST
118284: LIST
118285: LIST
118286: LIST
118287: LIST
118288: LIST
118289: LIST
118290: LIST
118291: LIST
118292: LIST
118293: LIST
118294: LIST
118295: LIST
118296: LIST
118297: LIST
118298: LIST
118299: LIST
118300: PUSH
118301: EMPTY
118302: LIST
118303: LIST
118304: ST_TO_ADDR
118305: GO 119544
118307: LD_INT 14
118309: DOUBLE
118310: EQUAL
118311: IFTRUE 118315
118313: GO 118539
118315: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
118316: LD_ADDR_VAR 0 2
118320: PUSH
118321: LD_INT 1
118323: PUSH
118324: LD_INT 2
118326: PUSH
118327: LD_INT 3
118329: PUSH
118330: LD_INT 4
118332: PUSH
118333: LD_INT 5
118335: PUSH
118336: LD_INT 6
118338: PUSH
118339: LD_INT 7
118341: PUSH
118342: LD_INT 8
118344: PUSH
118345: LD_INT 9
118347: PUSH
118348: LD_INT 10
118350: PUSH
118351: LD_INT 11
118353: PUSH
118354: LD_INT 12
118356: PUSH
118357: LD_INT 13
118359: PUSH
118360: LD_INT 14
118362: PUSH
118363: LD_INT 15
118365: PUSH
118366: LD_INT 16
118368: PUSH
118369: LD_INT 17
118371: PUSH
118372: LD_INT 18
118374: PUSH
118375: LD_INT 19
118377: PUSH
118378: LD_INT 20
118380: PUSH
118381: LD_INT 21
118383: PUSH
118384: LD_INT 22
118386: PUSH
118387: LD_INT 23
118389: PUSH
118390: LD_INT 24
118392: PUSH
118393: LD_INT 25
118395: PUSH
118396: LD_INT 26
118398: PUSH
118399: LD_INT 27
118401: PUSH
118402: LD_INT 28
118404: PUSH
118405: LD_INT 29
118407: PUSH
118408: LD_INT 30
118410: PUSH
118411: LD_INT 31
118413: PUSH
118414: LD_INT 32
118416: PUSH
118417: LD_INT 33
118419: PUSH
118420: LD_INT 34
118422: PUSH
118423: LD_INT 36
118425: PUSH
118426: EMPTY
118427: LIST
118428: LIST
118429: LIST
118430: LIST
118431: LIST
118432: LIST
118433: LIST
118434: LIST
118435: LIST
118436: LIST
118437: LIST
118438: LIST
118439: LIST
118440: LIST
118441: LIST
118442: LIST
118443: LIST
118444: LIST
118445: LIST
118446: LIST
118447: LIST
118448: LIST
118449: LIST
118450: LIST
118451: LIST
118452: LIST
118453: LIST
118454: LIST
118455: LIST
118456: LIST
118457: LIST
118458: LIST
118459: LIST
118460: LIST
118461: LIST
118462: PUSH
118463: LD_INT 101
118465: PUSH
118466: LD_INT 102
118468: PUSH
118469: LD_INT 103
118471: PUSH
118472: LD_INT 104
118474: PUSH
118475: LD_INT 105
118477: PUSH
118478: LD_INT 106
118480: PUSH
118481: LD_INT 107
118483: PUSH
118484: LD_INT 108
118486: PUSH
118487: LD_INT 109
118489: PUSH
118490: LD_INT 110
118492: PUSH
118493: LD_INT 111
118495: PUSH
118496: LD_INT 112
118498: PUSH
118499: LD_INT 113
118501: PUSH
118502: LD_INT 114
118504: PUSH
118505: LD_INT 116
118507: PUSH
118508: LD_INT 117
118510: PUSH
118511: LD_INT 118
118513: PUSH
118514: EMPTY
118515: LIST
118516: LIST
118517: LIST
118518: LIST
118519: LIST
118520: LIST
118521: LIST
118522: LIST
118523: LIST
118524: LIST
118525: LIST
118526: LIST
118527: LIST
118528: LIST
118529: LIST
118530: LIST
118531: LIST
118532: PUSH
118533: EMPTY
118534: LIST
118535: LIST
118536: ST_TO_ADDR
118537: GO 119544
118539: LD_INT 15
118541: DOUBLE
118542: EQUAL
118543: IFTRUE 118547
118545: GO 118771
118547: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
118548: LD_ADDR_VAR 0 2
118552: PUSH
118553: LD_INT 1
118555: PUSH
118556: LD_INT 2
118558: PUSH
118559: LD_INT 3
118561: PUSH
118562: LD_INT 4
118564: PUSH
118565: LD_INT 5
118567: PUSH
118568: LD_INT 6
118570: PUSH
118571: LD_INT 7
118573: PUSH
118574: LD_INT 8
118576: PUSH
118577: LD_INT 9
118579: PUSH
118580: LD_INT 10
118582: PUSH
118583: LD_INT 11
118585: PUSH
118586: LD_INT 12
118588: PUSH
118589: LD_INT 13
118591: PUSH
118592: LD_INT 14
118594: PUSH
118595: LD_INT 15
118597: PUSH
118598: LD_INT 16
118600: PUSH
118601: LD_INT 17
118603: PUSH
118604: LD_INT 18
118606: PUSH
118607: LD_INT 19
118609: PUSH
118610: LD_INT 20
118612: PUSH
118613: LD_INT 21
118615: PUSH
118616: LD_INT 22
118618: PUSH
118619: LD_INT 23
118621: PUSH
118622: LD_INT 24
118624: PUSH
118625: LD_INT 25
118627: PUSH
118628: LD_INT 26
118630: PUSH
118631: LD_INT 27
118633: PUSH
118634: LD_INT 28
118636: PUSH
118637: LD_INT 29
118639: PUSH
118640: LD_INT 30
118642: PUSH
118643: LD_INT 31
118645: PUSH
118646: LD_INT 32
118648: PUSH
118649: LD_INT 33
118651: PUSH
118652: LD_INT 34
118654: PUSH
118655: LD_INT 36
118657: PUSH
118658: EMPTY
118659: LIST
118660: LIST
118661: LIST
118662: LIST
118663: LIST
118664: LIST
118665: LIST
118666: LIST
118667: LIST
118668: LIST
118669: LIST
118670: LIST
118671: LIST
118672: LIST
118673: LIST
118674: LIST
118675: LIST
118676: LIST
118677: LIST
118678: LIST
118679: LIST
118680: LIST
118681: LIST
118682: LIST
118683: LIST
118684: LIST
118685: LIST
118686: LIST
118687: LIST
118688: LIST
118689: LIST
118690: LIST
118691: LIST
118692: LIST
118693: LIST
118694: PUSH
118695: LD_INT 101
118697: PUSH
118698: LD_INT 102
118700: PUSH
118701: LD_INT 103
118703: PUSH
118704: LD_INT 104
118706: PUSH
118707: LD_INT 105
118709: PUSH
118710: LD_INT 106
118712: PUSH
118713: LD_INT 107
118715: PUSH
118716: LD_INT 108
118718: PUSH
118719: LD_INT 109
118721: PUSH
118722: LD_INT 110
118724: PUSH
118725: LD_INT 111
118727: PUSH
118728: LD_INT 112
118730: PUSH
118731: LD_INT 113
118733: PUSH
118734: LD_INT 114
118736: PUSH
118737: LD_INT 116
118739: PUSH
118740: LD_INT 117
118742: PUSH
118743: LD_INT 118
118745: PUSH
118746: EMPTY
118747: LIST
118748: LIST
118749: LIST
118750: LIST
118751: LIST
118752: LIST
118753: LIST
118754: LIST
118755: LIST
118756: LIST
118757: LIST
118758: LIST
118759: LIST
118760: LIST
118761: LIST
118762: LIST
118763: LIST
118764: PUSH
118765: EMPTY
118766: LIST
118767: LIST
118768: ST_TO_ADDR
118769: GO 119544
118771: LD_INT 16
118773: DOUBLE
118774: EQUAL
118775: IFTRUE 118779
118777: GO 118915
118779: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
118780: LD_ADDR_VAR 0 2
118784: PUSH
118785: LD_INT 2
118787: PUSH
118788: LD_INT 4
118790: PUSH
118791: LD_INT 5
118793: PUSH
118794: LD_INT 7
118796: PUSH
118797: LD_INT 11
118799: PUSH
118800: LD_INT 12
118802: PUSH
118803: LD_INT 15
118805: PUSH
118806: LD_INT 16
118808: PUSH
118809: LD_INT 20
118811: PUSH
118812: LD_INT 21
118814: PUSH
118815: LD_INT 22
118817: PUSH
118818: LD_INT 23
118820: PUSH
118821: LD_INT 25
118823: PUSH
118824: LD_INT 26
118826: PUSH
118827: LD_INT 30
118829: PUSH
118830: LD_INT 31
118832: PUSH
118833: LD_INT 32
118835: PUSH
118836: LD_INT 33
118838: PUSH
118839: LD_INT 34
118841: PUSH
118842: EMPTY
118843: LIST
118844: LIST
118845: LIST
118846: LIST
118847: LIST
118848: LIST
118849: LIST
118850: LIST
118851: LIST
118852: LIST
118853: LIST
118854: LIST
118855: LIST
118856: LIST
118857: LIST
118858: LIST
118859: LIST
118860: LIST
118861: LIST
118862: PUSH
118863: LD_INT 101
118865: PUSH
118866: LD_INT 102
118868: PUSH
118869: LD_INT 103
118871: PUSH
118872: LD_INT 106
118874: PUSH
118875: LD_INT 108
118877: PUSH
118878: LD_INT 112
118880: PUSH
118881: LD_INT 113
118883: PUSH
118884: LD_INT 114
118886: PUSH
118887: LD_INT 116
118889: PUSH
118890: LD_INT 117
118892: PUSH
118893: LD_INT 118
118895: PUSH
118896: EMPTY
118897: LIST
118898: LIST
118899: LIST
118900: LIST
118901: LIST
118902: LIST
118903: LIST
118904: LIST
118905: LIST
118906: LIST
118907: LIST
118908: PUSH
118909: EMPTY
118910: LIST
118911: LIST
118912: ST_TO_ADDR
118913: GO 119544
118915: LD_INT 17
118917: DOUBLE
118918: EQUAL
118919: IFTRUE 118923
118921: GO 119147
118923: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
118924: LD_ADDR_VAR 0 2
118928: PUSH
118929: LD_INT 1
118931: PUSH
118932: LD_INT 2
118934: PUSH
118935: LD_INT 3
118937: PUSH
118938: LD_INT 4
118940: PUSH
118941: LD_INT 5
118943: PUSH
118944: LD_INT 6
118946: PUSH
118947: LD_INT 7
118949: PUSH
118950: LD_INT 8
118952: PUSH
118953: LD_INT 9
118955: PUSH
118956: LD_INT 10
118958: PUSH
118959: LD_INT 11
118961: PUSH
118962: LD_INT 12
118964: PUSH
118965: LD_INT 13
118967: PUSH
118968: LD_INT 14
118970: PUSH
118971: LD_INT 15
118973: PUSH
118974: LD_INT 16
118976: PUSH
118977: LD_INT 17
118979: PUSH
118980: LD_INT 18
118982: PUSH
118983: LD_INT 19
118985: PUSH
118986: LD_INT 20
118988: PUSH
118989: LD_INT 21
118991: PUSH
118992: LD_INT 22
118994: PUSH
118995: LD_INT 23
118997: PUSH
118998: LD_INT 24
119000: PUSH
119001: LD_INT 25
119003: PUSH
119004: LD_INT 26
119006: PUSH
119007: LD_INT 27
119009: PUSH
119010: LD_INT 28
119012: PUSH
119013: LD_INT 29
119015: PUSH
119016: LD_INT 30
119018: PUSH
119019: LD_INT 31
119021: PUSH
119022: LD_INT 32
119024: PUSH
119025: LD_INT 33
119027: PUSH
119028: LD_INT 34
119030: PUSH
119031: LD_INT 36
119033: PUSH
119034: EMPTY
119035: LIST
119036: LIST
119037: LIST
119038: LIST
119039: LIST
119040: LIST
119041: LIST
119042: LIST
119043: LIST
119044: LIST
119045: LIST
119046: LIST
119047: LIST
119048: LIST
119049: LIST
119050: LIST
119051: LIST
119052: LIST
119053: LIST
119054: LIST
119055: LIST
119056: LIST
119057: LIST
119058: LIST
119059: LIST
119060: LIST
119061: LIST
119062: LIST
119063: LIST
119064: LIST
119065: LIST
119066: LIST
119067: LIST
119068: LIST
119069: LIST
119070: PUSH
119071: LD_INT 101
119073: PUSH
119074: LD_INT 102
119076: PUSH
119077: LD_INT 103
119079: PUSH
119080: LD_INT 104
119082: PUSH
119083: LD_INT 105
119085: PUSH
119086: LD_INT 106
119088: PUSH
119089: LD_INT 107
119091: PUSH
119092: LD_INT 108
119094: PUSH
119095: LD_INT 109
119097: PUSH
119098: LD_INT 110
119100: PUSH
119101: LD_INT 111
119103: PUSH
119104: LD_INT 112
119106: PUSH
119107: LD_INT 113
119109: PUSH
119110: LD_INT 114
119112: PUSH
119113: LD_INT 116
119115: PUSH
119116: LD_INT 117
119118: PUSH
119119: LD_INT 118
119121: PUSH
119122: EMPTY
119123: LIST
119124: LIST
119125: LIST
119126: LIST
119127: LIST
119128: LIST
119129: LIST
119130: LIST
119131: LIST
119132: LIST
119133: LIST
119134: LIST
119135: LIST
119136: LIST
119137: LIST
119138: LIST
119139: LIST
119140: PUSH
119141: EMPTY
119142: LIST
119143: LIST
119144: ST_TO_ADDR
119145: GO 119544
119147: LD_INT 18
119149: DOUBLE
119150: EQUAL
119151: IFTRUE 119155
119153: GO 119303
119155: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
119156: LD_ADDR_VAR 0 2
119160: PUSH
119161: LD_INT 2
119163: PUSH
119164: LD_INT 4
119166: PUSH
119167: LD_INT 5
119169: PUSH
119170: LD_INT 7
119172: PUSH
119173: LD_INT 11
119175: PUSH
119176: LD_INT 12
119178: PUSH
119179: LD_INT 15
119181: PUSH
119182: LD_INT 16
119184: PUSH
119185: LD_INT 20
119187: PUSH
119188: LD_INT 21
119190: PUSH
119191: LD_INT 22
119193: PUSH
119194: LD_INT 23
119196: PUSH
119197: LD_INT 25
119199: PUSH
119200: LD_INT 26
119202: PUSH
119203: LD_INT 30
119205: PUSH
119206: LD_INT 31
119208: PUSH
119209: LD_INT 32
119211: PUSH
119212: LD_INT 33
119214: PUSH
119215: LD_INT 34
119217: PUSH
119218: LD_INT 35
119220: PUSH
119221: LD_INT 36
119223: PUSH
119224: EMPTY
119225: LIST
119226: LIST
119227: LIST
119228: LIST
119229: LIST
119230: LIST
119231: LIST
119232: LIST
119233: LIST
119234: LIST
119235: LIST
119236: LIST
119237: LIST
119238: LIST
119239: LIST
119240: LIST
119241: LIST
119242: LIST
119243: LIST
119244: LIST
119245: LIST
119246: PUSH
119247: LD_INT 101
119249: PUSH
119250: LD_INT 102
119252: PUSH
119253: LD_INT 103
119255: PUSH
119256: LD_INT 106
119258: PUSH
119259: LD_INT 108
119261: PUSH
119262: LD_INT 112
119264: PUSH
119265: LD_INT 113
119267: PUSH
119268: LD_INT 114
119270: PUSH
119271: LD_INT 115
119273: PUSH
119274: LD_INT 116
119276: PUSH
119277: LD_INT 117
119279: PUSH
119280: LD_INT 118
119282: PUSH
119283: EMPTY
119284: LIST
119285: LIST
119286: LIST
119287: LIST
119288: LIST
119289: LIST
119290: LIST
119291: LIST
119292: LIST
119293: LIST
119294: LIST
119295: LIST
119296: PUSH
119297: EMPTY
119298: LIST
119299: LIST
119300: ST_TO_ADDR
119301: GO 119544
119303: LD_INT 19
119305: DOUBLE
119306: EQUAL
119307: IFTRUE 119311
119309: GO 119543
119311: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
119312: LD_ADDR_VAR 0 2
119316: PUSH
119317: LD_INT 1
119319: PUSH
119320: LD_INT 2
119322: PUSH
119323: LD_INT 3
119325: PUSH
119326: LD_INT 4
119328: PUSH
119329: LD_INT 5
119331: PUSH
119332: LD_INT 6
119334: PUSH
119335: LD_INT 7
119337: PUSH
119338: LD_INT 8
119340: PUSH
119341: LD_INT 9
119343: PUSH
119344: LD_INT 10
119346: PUSH
119347: LD_INT 11
119349: PUSH
119350: LD_INT 12
119352: PUSH
119353: LD_INT 13
119355: PUSH
119356: LD_INT 14
119358: PUSH
119359: LD_INT 15
119361: PUSH
119362: LD_INT 16
119364: PUSH
119365: LD_INT 17
119367: PUSH
119368: LD_INT 18
119370: PUSH
119371: LD_INT 19
119373: PUSH
119374: LD_INT 20
119376: PUSH
119377: LD_INT 21
119379: PUSH
119380: LD_INT 22
119382: PUSH
119383: LD_INT 23
119385: PUSH
119386: LD_INT 24
119388: PUSH
119389: LD_INT 25
119391: PUSH
119392: LD_INT 26
119394: PUSH
119395: LD_INT 27
119397: PUSH
119398: LD_INT 28
119400: PUSH
119401: LD_INT 29
119403: PUSH
119404: LD_INT 30
119406: PUSH
119407: LD_INT 31
119409: PUSH
119410: LD_INT 32
119412: PUSH
119413: LD_INT 33
119415: PUSH
119416: LD_INT 34
119418: PUSH
119419: LD_INT 35
119421: PUSH
119422: LD_INT 36
119424: PUSH
119425: EMPTY
119426: LIST
119427: LIST
119428: LIST
119429: LIST
119430: LIST
119431: LIST
119432: LIST
119433: LIST
119434: LIST
119435: LIST
119436: LIST
119437: LIST
119438: LIST
119439: LIST
119440: LIST
119441: LIST
119442: LIST
119443: LIST
119444: LIST
119445: LIST
119446: LIST
119447: LIST
119448: LIST
119449: LIST
119450: LIST
119451: LIST
119452: LIST
119453: LIST
119454: LIST
119455: LIST
119456: LIST
119457: LIST
119458: LIST
119459: LIST
119460: LIST
119461: LIST
119462: PUSH
119463: LD_INT 101
119465: PUSH
119466: LD_INT 102
119468: PUSH
119469: LD_INT 103
119471: PUSH
119472: LD_INT 104
119474: PUSH
119475: LD_INT 105
119477: PUSH
119478: LD_INT 106
119480: PUSH
119481: LD_INT 107
119483: PUSH
119484: LD_INT 108
119486: PUSH
119487: LD_INT 109
119489: PUSH
119490: LD_INT 110
119492: PUSH
119493: LD_INT 111
119495: PUSH
119496: LD_INT 112
119498: PUSH
119499: LD_INT 113
119501: PUSH
119502: LD_INT 114
119504: PUSH
119505: LD_INT 115
119507: PUSH
119508: LD_INT 116
119510: PUSH
119511: LD_INT 117
119513: PUSH
119514: LD_INT 118
119516: PUSH
119517: EMPTY
119518: LIST
119519: LIST
119520: LIST
119521: LIST
119522: LIST
119523: LIST
119524: LIST
119525: LIST
119526: LIST
119527: LIST
119528: LIST
119529: LIST
119530: LIST
119531: LIST
119532: LIST
119533: LIST
119534: LIST
119535: LIST
119536: PUSH
119537: EMPTY
119538: LIST
119539: LIST
119540: ST_TO_ADDR
119541: GO 119544
119543: POP
// end else
119544: GO 119775
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
119546: LD_ADDR_VAR 0 2
119550: PUSH
119551: LD_INT 1
119553: PUSH
119554: LD_INT 2
119556: PUSH
119557: LD_INT 3
119559: PUSH
119560: LD_INT 4
119562: PUSH
119563: LD_INT 5
119565: PUSH
119566: LD_INT 6
119568: PUSH
119569: LD_INT 7
119571: PUSH
119572: LD_INT 8
119574: PUSH
119575: LD_INT 9
119577: PUSH
119578: LD_INT 10
119580: PUSH
119581: LD_INT 11
119583: PUSH
119584: LD_INT 12
119586: PUSH
119587: LD_INT 13
119589: PUSH
119590: LD_INT 14
119592: PUSH
119593: LD_INT 15
119595: PUSH
119596: LD_INT 16
119598: PUSH
119599: LD_INT 17
119601: PUSH
119602: LD_INT 18
119604: PUSH
119605: LD_INT 19
119607: PUSH
119608: LD_INT 20
119610: PUSH
119611: LD_INT 21
119613: PUSH
119614: LD_INT 22
119616: PUSH
119617: LD_INT 23
119619: PUSH
119620: LD_INT 24
119622: PUSH
119623: LD_INT 25
119625: PUSH
119626: LD_INT 26
119628: PUSH
119629: LD_INT 27
119631: PUSH
119632: LD_INT 28
119634: PUSH
119635: LD_INT 29
119637: PUSH
119638: LD_INT 30
119640: PUSH
119641: LD_INT 31
119643: PUSH
119644: LD_INT 32
119646: PUSH
119647: LD_INT 33
119649: PUSH
119650: LD_INT 34
119652: PUSH
119653: LD_INT 35
119655: PUSH
119656: LD_INT 36
119658: PUSH
119659: EMPTY
119660: LIST
119661: LIST
119662: LIST
119663: LIST
119664: LIST
119665: LIST
119666: LIST
119667: LIST
119668: LIST
119669: LIST
119670: LIST
119671: LIST
119672: LIST
119673: LIST
119674: LIST
119675: LIST
119676: LIST
119677: LIST
119678: LIST
119679: LIST
119680: LIST
119681: LIST
119682: LIST
119683: LIST
119684: LIST
119685: LIST
119686: LIST
119687: LIST
119688: LIST
119689: LIST
119690: LIST
119691: LIST
119692: LIST
119693: LIST
119694: LIST
119695: LIST
119696: PUSH
119697: LD_INT 101
119699: PUSH
119700: LD_INT 102
119702: PUSH
119703: LD_INT 103
119705: PUSH
119706: LD_INT 104
119708: PUSH
119709: LD_INT 105
119711: PUSH
119712: LD_INT 106
119714: PUSH
119715: LD_INT 107
119717: PUSH
119718: LD_INT 108
119720: PUSH
119721: LD_INT 109
119723: PUSH
119724: LD_INT 110
119726: PUSH
119727: LD_INT 111
119729: PUSH
119730: LD_INT 112
119732: PUSH
119733: LD_INT 113
119735: PUSH
119736: LD_INT 114
119738: PUSH
119739: LD_INT 115
119741: PUSH
119742: LD_INT 116
119744: PUSH
119745: LD_INT 117
119747: PUSH
119748: LD_INT 118
119750: PUSH
119751: EMPTY
119752: LIST
119753: LIST
119754: LIST
119755: LIST
119756: LIST
119757: LIST
119758: LIST
119759: LIST
119760: LIST
119761: LIST
119762: LIST
119763: LIST
119764: LIST
119765: LIST
119766: LIST
119767: LIST
119768: LIST
119769: LIST
119770: PUSH
119771: EMPTY
119772: LIST
119773: LIST
119774: ST_TO_ADDR
// if result then
119775: LD_VAR 0 2
119779: IFFALSE 120565
// begin normal :=  ;
119781: LD_ADDR_VAR 0 5
119785: PUSH
119786: LD_STRING 
119788: ST_TO_ADDR
// hardcore :=  ;
119789: LD_ADDR_VAR 0 6
119793: PUSH
119794: LD_STRING 
119796: ST_TO_ADDR
// active :=  ;
119797: LD_ADDR_VAR 0 7
119801: PUSH
119802: LD_STRING 
119804: ST_TO_ADDR
// for i = 1 to normalCounter do
119805: LD_ADDR_VAR 0 8
119809: PUSH
119810: DOUBLE
119811: LD_INT 1
119813: DEC
119814: ST_TO_ADDR
119815: LD_EXP 149
119819: PUSH
119820: FOR_TO
119821: IFFALSE 119922
// begin tmp := 0 ;
119823: LD_ADDR_VAR 0 3
119827: PUSH
119828: LD_STRING 0
119830: ST_TO_ADDR
// if result [ 1 ] then
119831: LD_VAR 0 2
119835: PUSH
119836: LD_INT 1
119838: ARRAY
119839: IFFALSE 119904
// if result [ 1 ] [ 1 ] = i then
119841: LD_VAR 0 2
119845: PUSH
119846: LD_INT 1
119848: ARRAY
119849: PUSH
119850: LD_INT 1
119852: ARRAY
119853: PUSH
119854: LD_VAR 0 8
119858: EQUAL
119859: IFFALSE 119904
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
119861: LD_ADDR_VAR 0 2
119865: PUSH
119866: LD_VAR 0 2
119870: PPUSH
119871: LD_INT 1
119873: PPUSH
119874: LD_VAR 0 2
119878: PUSH
119879: LD_INT 1
119881: ARRAY
119882: PPUSH
119883: LD_INT 1
119885: PPUSH
119886: CALL_OW 3
119890: PPUSH
119891: CALL_OW 1
119895: ST_TO_ADDR
// tmp := 1 ;
119896: LD_ADDR_VAR 0 3
119900: PUSH
119901: LD_STRING 1
119903: ST_TO_ADDR
// end ; normal := normal & tmp ;
119904: LD_ADDR_VAR 0 5
119908: PUSH
119909: LD_VAR 0 5
119913: PUSH
119914: LD_VAR 0 3
119918: STR
119919: ST_TO_ADDR
// end ;
119920: GO 119820
119922: POP
119923: POP
// for i = 1 to hardcoreCounter do
119924: LD_ADDR_VAR 0 8
119928: PUSH
119929: DOUBLE
119930: LD_INT 1
119932: DEC
119933: ST_TO_ADDR
119934: LD_EXP 150
119938: PUSH
119939: FOR_TO
119940: IFFALSE 120045
// begin tmp := 0 ;
119942: LD_ADDR_VAR 0 3
119946: PUSH
119947: LD_STRING 0
119949: ST_TO_ADDR
// if result [ 2 ] then
119950: LD_VAR 0 2
119954: PUSH
119955: LD_INT 2
119957: ARRAY
119958: IFFALSE 120027
// if result [ 2 ] [ 1 ] = 100 + i then
119960: LD_VAR 0 2
119964: PUSH
119965: LD_INT 2
119967: ARRAY
119968: PUSH
119969: LD_INT 1
119971: ARRAY
119972: PUSH
119973: LD_INT 100
119975: PUSH
119976: LD_VAR 0 8
119980: PLUS
119981: EQUAL
119982: IFFALSE 120027
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
119984: LD_ADDR_VAR 0 2
119988: PUSH
119989: LD_VAR 0 2
119993: PPUSH
119994: LD_INT 2
119996: PPUSH
119997: LD_VAR 0 2
120001: PUSH
120002: LD_INT 2
120004: ARRAY
120005: PPUSH
120006: LD_INT 1
120008: PPUSH
120009: CALL_OW 3
120013: PPUSH
120014: CALL_OW 1
120018: ST_TO_ADDR
// tmp := 1 ;
120019: LD_ADDR_VAR 0 3
120023: PUSH
120024: LD_STRING 1
120026: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
120027: LD_ADDR_VAR 0 6
120031: PUSH
120032: LD_VAR 0 6
120036: PUSH
120037: LD_VAR 0 3
120041: STR
120042: ST_TO_ADDR
// end ;
120043: GO 119939
120045: POP
120046: POP
// if isGameLoad then
120047: LD_VAR 0 1
120051: IFFALSE 120526
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
120053: LD_ADDR_VAR 0 4
120057: PUSH
120058: LD_EXP 153
120062: PUSH
120063: LD_EXP 152
120067: PUSH
120068: LD_EXP 154
120072: PUSH
120073: LD_EXP 151
120077: PUSH
120078: LD_EXP 155
120082: PUSH
120083: LD_EXP 156
120087: PUSH
120088: LD_EXP 157
120092: PUSH
120093: LD_EXP 158
120097: PUSH
120098: LD_EXP 159
120102: PUSH
120103: LD_EXP 160
120107: PUSH
120108: LD_EXP 161
120112: PUSH
120113: LD_EXP 162
120117: PUSH
120118: LD_EXP 163
120122: PUSH
120123: LD_EXP 164
120127: PUSH
120128: LD_EXP 172
120132: PUSH
120133: LD_EXP 173
120137: PUSH
120138: LD_EXP 174
120142: PUSH
120143: LD_EXP 175
120147: PUSH
120148: LD_EXP 177
120152: PUSH
120153: LD_EXP 178
120157: PUSH
120158: LD_EXP 179
120162: PUSH
120163: LD_EXP 182
120167: PUSH
120168: LD_EXP 184
120172: PUSH
120173: LD_EXP 185
120177: PUSH
120178: LD_EXP 186
120182: PUSH
120183: LD_EXP 188
120187: PUSH
120188: LD_EXP 189
120192: PUSH
120193: LD_EXP 192
120197: PUSH
120198: LD_EXP 193
120202: PUSH
120203: LD_EXP 194
120207: PUSH
120208: LD_EXP 195
120212: PUSH
120213: LD_EXP 196
120217: PUSH
120218: LD_EXP 197
120222: PUSH
120223: LD_EXP 198
120227: PUSH
120228: LD_EXP 199
120232: PUSH
120233: LD_EXP 200
120237: PUSH
120238: LD_EXP 165
120242: PUSH
120243: LD_EXP 166
120247: PUSH
120248: LD_EXP 169
120252: PUSH
120253: LD_EXP 170
120257: PUSH
120258: LD_EXP 171
120262: PUSH
120263: LD_EXP 167
120267: PUSH
120268: LD_EXP 168
120272: PUSH
120273: LD_EXP 176
120277: PUSH
120278: LD_EXP 180
120282: PUSH
120283: LD_EXP 181
120287: PUSH
120288: LD_EXP 183
120292: PUSH
120293: LD_EXP 187
120297: PUSH
120298: LD_EXP 190
120302: PUSH
120303: LD_EXP 191
120307: PUSH
120308: LD_EXP 201
120312: PUSH
120313: LD_EXP 202
120317: PUSH
120318: LD_EXP 203
120322: PUSH
120323: LD_EXP 204
120327: PUSH
120328: EMPTY
120329: LIST
120330: LIST
120331: LIST
120332: LIST
120333: LIST
120334: LIST
120335: LIST
120336: LIST
120337: LIST
120338: LIST
120339: LIST
120340: LIST
120341: LIST
120342: LIST
120343: LIST
120344: LIST
120345: LIST
120346: LIST
120347: LIST
120348: LIST
120349: LIST
120350: LIST
120351: LIST
120352: LIST
120353: LIST
120354: LIST
120355: LIST
120356: LIST
120357: LIST
120358: LIST
120359: LIST
120360: LIST
120361: LIST
120362: LIST
120363: LIST
120364: LIST
120365: LIST
120366: LIST
120367: LIST
120368: LIST
120369: LIST
120370: LIST
120371: LIST
120372: LIST
120373: LIST
120374: LIST
120375: LIST
120376: LIST
120377: LIST
120378: LIST
120379: LIST
120380: LIST
120381: LIST
120382: LIST
120383: ST_TO_ADDR
// tmp :=  ;
120384: LD_ADDR_VAR 0 3
120388: PUSH
120389: LD_STRING 
120391: ST_TO_ADDR
// for i = 1 to normalCounter do
120392: LD_ADDR_VAR 0 8
120396: PUSH
120397: DOUBLE
120398: LD_INT 1
120400: DEC
120401: ST_TO_ADDR
120402: LD_EXP 149
120406: PUSH
120407: FOR_TO
120408: IFFALSE 120444
// begin if flags [ i ] then
120410: LD_VAR 0 4
120414: PUSH
120415: LD_VAR 0 8
120419: ARRAY
120420: IFFALSE 120442
// tmp := tmp & i & ; ;
120422: LD_ADDR_VAR 0 3
120426: PUSH
120427: LD_VAR 0 3
120431: PUSH
120432: LD_VAR 0 8
120436: STR
120437: PUSH
120438: LD_STRING ;
120440: STR
120441: ST_TO_ADDR
// end ;
120442: GO 120407
120444: POP
120445: POP
// for i = 1 to hardcoreCounter do
120446: LD_ADDR_VAR 0 8
120450: PUSH
120451: DOUBLE
120452: LD_INT 1
120454: DEC
120455: ST_TO_ADDR
120456: LD_EXP 150
120460: PUSH
120461: FOR_TO
120462: IFFALSE 120508
// begin if flags [ normalCounter + i ] then
120464: LD_VAR 0 4
120468: PUSH
120469: LD_EXP 149
120473: PUSH
120474: LD_VAR 0 8
120478: PLUS
120479: ARRAY
120480: IFFALSE 120506
// tmp := tmp & ( 100 + i ) & ; ;
120482: LD_ADDR_VAR 0 3
120486: PUSH
120487: LD_VAR 0 3
120491: PUSH
120492: LD_INT 100
120494: PUSH
120495: LD_VAR 0 8
120499: PLUS
120500: STR
120501: PUSH
120502: LD_STRING ;
120504: STR
120505: ST_TO_ADDR
// end ;
120506: GO 120461
120508: POP
120509: POP
// if tmp then
120510: LD_VAR 0 3
120514: IFFALSE 120526
// active := tmp ;
120516: LD_ADDR_VAR 0 7
120520: PUSH
120521: LD_VAR 0 3
120525: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
120526: LD_STRING getStreamItemsFromMission("
120528: PUSH
120529: LD_VAR 0 5
120533: STR
120534: PUSH
120535: LD_STRING ","
120537: STR
120538: PUSH
120539: LD_VAR 0 6
120543: STR
120544: PUSH
120545: LD_STRING ","
120547: STR
120548: PUSH
120549: LD_VAR 0 7
120553: STR
120554: PUSH
120555: LD_STRING ")
120557: STR
120558: PPUSH
120559: CALL_OW 559
// end else
120563: GO 120572
// ToLua ( getStreamItemsFromMission("","","") ) ;
120565: LD_STRING getStreamItemsFromMission("","","")
120567: PPUSH
120568: CALL_OW 559
// end ;
120572: LD_VAR 0 2
120576: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
120577: LD_EXP 148
120581: IFFALSE 120589
120583: PUSH
120584: LD_EXP 153
120588: AND
120589: IFFALSE 120713
120591: GO 120593
120593: DISABLE
120594: LD_INT 0
120596: PPUSH
120597: PPUSH
// begin enable ;
120598: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
120599: LD_ADDR_VAR 0 2
120603: PUSH
120604: LD_INT 22
120606: PUSH
120607: LD_OWVAR 2
120611: PUSH
120612: EMPTY
120613: LIST
120614: LIST
120615: PUSH
120616: LD_INT 2
120618: PUSH
120619: LD_INT 34
120621: PUSH
120622: LD_INT 7
120624: PUSH
120625: EMPTY
120626: LIST
120627: LIST
120628: PUSH
120629: LD_INT 34
120631: PUSH
120632: LD_INT 45
120634: PUSH
120635: EMPTY
120636: LIST
120637: LIST
120638: PUSH
120639: LD_INT 34
120641: PUSH
120642: LD_INT 28
120644: PUSH
120645: EMPTY
120646: LIST
120647: LIST
120648: PUSH
120649: LD_INT 34
120651: PUSH
120652: LD_INT 47
120654: PUSH
120655: EMPTY
120656: LIST
120657: LIST
120658: PUSH
120659: EMPTY
120660: LIST
120661: LIST
120662: LIST
120663: LIST
120664: LIST
120665: PUSH
120666: EMPTY
120667: LIST
120668: LIST
120669: PPUSH
120670: CALL_OW 69
120674: ST_TO_ADDR
// if not tmp then
120675: LD_VAR 0 2
120679: NOT
120680: IFFALSE 120684
// exit ;
120682: GO 120713
// for i in tmp do
120684: LD_ADDR_VAR 0 1
120688: PUSH
120689: LD_VAR 0 2
120693: PUSH
120694: FOR_IN
120695: IFFALSE 120711
// begin SetLives ( i , 0 ) ;
120697: LD_VAR 0 1
120701: PPUSH
120702: LD_INT 0
120704: PPUSH
120705: CALL_OW 234
// end ;
120709: GO 120694
120711: POP
120712: POP
// end ;
120713: PPOPN 2
120715: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
120716: LD_EXP 148
120720: IFFALSE 120728
120722: PUSH
120723: LD_EXP 154
120727: AND
120728: IFFALSE 120812
120730: GO 120732
120732: DISABLE
120733: LD_INT 0
120735: PPUSH
120736: PPUSH
// begin enable ;
120737: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
120738: LD_ADDR_VAR 0 2
120742: PUSH
120743: LD_INT 22
120745: PUSH
120746: LD_OWVAR 2
120750: PUSH
120751: EMPTY
120752: LIST
120753: LIST
120754: PUSH
120755: LD_INT 32
120757: PUSH
120758: LD_INT 3
120760: PUSH
120761: EMPTY
120762: LIST
120763: LIST
120764: PUSH
120765: EMPTY
120766: LIST
120767: LIST
120768: PPUSH
120769: CALL_OW 69
120773: ST_TO_ADDR
// if not tmp then
120774: LD_VAR 0 2
120778: NOT
120779: IFFALSE 120783
// exit ;
120781: GO 120812
// for i in tmp do
120783: LD_ADDR_VAR 0 1
120787: PUSH
120788: LD_VAR 0 2
120792: PUSH
120793: FOR_IN
120794: IFFALSE 120810
// begin SetLives ( i , 0 ) ;
120796: LD_VAR 0 1
120800: PPUSH
120801: LD_INT 0
120803: PPUSH
120804: CALL_OW 234
// end ;
120808: GO 120793
120810: POP
120811: POP
// end ;
120812: PPOPN 2
120814: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
120815: LD_EXP 148
120819: IFFALSE 120827
120821: PUSH
120822: LD_EXP 151
120826: AND
120827: IFFALSE 120920
120829: GO 120831
120831: DISABLE
120832: LD_INT 0
120834: PPUSH
// begin enable ;
120835: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
120836: LD_ADDR_VAR 0 1
120840: PUSH
120841: LD_INT 22
120843: PUSH
120844: LD_OWVAR 2
120848: PUSH
120849: EMPTY
120850: LIST
120851: LIST
120852: PUSH
120853: LD_INT 2
120855: PUSH
120856: LD_INT 25
120858: PUSH
120859: LD_INT 5
120861: PUSH
120862: EMPTY
120863: LIST
120864: LIST
120865: PUSH
120866: LD_INT 25
120868: PUSH
120869: LD_INT 9
120871: PUSH
120872: EMPTY
120873: LIST
120874: LIST
120875: PUSH
120876: LD_INT 25
120878: PUSH
120879: LD_INT 8
120881: PUSH
120882: EMPTY
120883: LIST
120884: LIST
120885: PUSH
120886: EMPTY
120887: LIST
120888: LIST
120889: LIST
120890: LIST
120891: PUSH
120892: EMPTY
120893: LIST
120894: LIST
120895: PPUSH
120896: CALL_OW 69
120900: PUSH
120901: FOR_IN
120902: IFFALSE 120918
// begin SetClass ( i , 1 ) ;
120904: LD_VAR 0 1
120908: PPUSH
120909: LD_INT 1
120911: PPUSH
120912: CALL_OW 336
// end ;
120916: GO 120901
120918: POP
120919: POP
// end ;
120920: PPOPN 1
120922: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
120923: LD_EXP 148
120927: IFFALSE 120935
120929: PUSH
120930: LD_EXP 152
120934: AND
120935: IFFALSE 120947
120937: PUSH
120938: LD_OWVAR 65
120942: PUSH
120943: LD_INT 7
120945: LESS
120946: AND
120947: IFFALSE 120961
120949: GO 120951
120951: DISABLE
// begin enable ;
120952: ENABLE
// game_speed := 7 ;
120953: LD_ADDR_OWVAR 65
120957: PUSH
120958: LD_INT 7
120960: ST_TO_ADDR
// end ;
120961: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
120962: LD_EXP 148
120966: IFFALSE 120974
120968: PUSH
120969: LD_EXP 155
120973: AND
120974: IFFALSE 121176
120976: GO 120978
120978: DISABLE
120979: LD_INT 0
120981: PPUSH
120982: PPUSH
120983: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
120984: LD_ADDR_VAR 0 3
120988: PUSH
120989: LD_INT 81
120991: PUSH
120992: LD_OWVAR 2
120996: PUSH
120997: EMPTY
120998: LIST
120999: LIST
121000: PUSH
121001: LD_INT 21
121003: PUSH
121004: LD_INT 1
121006: PUSH
121007: EMPTY
121008: LIST
121009: LIST
121010: PUSH
121011: EMPTY
121012: LIST
121013: LIST
121014: PPUSH
121015: CALL_OW 69
121019: ST_TO_ADDR
// if not tmp then
121020: LD_VAR 0 3
121024: NOT
121025: IFFALSE 121029
// exit ;
121027: GO 121176
// if tmp > 5 then
121029: LD_VAR 0 3
121033: PUSH
121034: LD_INT 5
121036: GREATER
121037: IFFALSE 121049
// k := 5 else
121039: LD_ADDR_VAR 0 2
121043: PUSH
121044: LD_INT 5
121046: ST_TO_ADDR
121047: GO 121059
// k := tmp ;
121049: LD_ADDR_VAR 0 2
121053: PUSH
121054: LD_VAR 0 3
121058: ST_TO_ADDR
// for i := 1 to k do
121059: LD_ADDR_VAR 0 1
121063: PUSH
121064: DOUBLE
121065: LD_INT 1
121067: DEC
121068: ST_TO_ADDR
121069: LD_VAR 0 2
121073: PUSH
121074: FOR_TO
121075: IFFALSE 121174
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
121077: LD_VAR 0 3
121081: PUSH
121082: LD_VAR 0 1
121086: ARRAY
121087: PPUSH
121088: LD_VAR 0 1
121092: PUSH
121093: LD_INT 4
121095: MOD
121096: PUSH
121097: LD_INT 1
121099: PLUS
121100: PPUSH
121101: CALL_OW 259
121105: PUSH
121106: LD_INT 10
121108: LESS
121109: IFFALSE 121172
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
121111: LD_VAR 0 3
121115: PUSH
121116: LD_VAR 0 1
121120: ARRAY
121121: PPUSH
121122: LD_VAR 0 1
121126: PUSH
121127: LD_INT 4
121129: MOD
121130: PUSH
121131: LD_INT 1
121133: PLUS
121134: PPUSH
121135: LD_VAR 0 3
121139: PUSH
121140: LD_VAR 0 1
121144: ARRAY
121145: PPUSH
121146: LD_VAR 0 1
121150: PUSH
121151: LD_INT 4
121153: MOD
121154: PUSH
121155: LD_INT 1
121157: PLUS
121158: PPUSH
121159: CALL_OW 259
121163: PUSH
121164: LD_INT 1
121166: PLUS
121167: PPUSH
121168: CALL_OW 237
121172: GO 121074
121174: POP
121175: POP
// end ;
121176: PPOPN 3
121178: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
121179: LD_EXP 148
121183: IFFALSE 121191
121185: PUSH
121186: LD_EXP 156
121190: AND
121191: IFFALSE 121211
121193: GO 121195
121195: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
121196: LD_INT 4
121198: PPUSH
121199: LD_OWVAR 2
121203: PPUSH
121204: LD_INT 0
121206: PPUSH
121207: CALL_OW 324
121211: END
// every 0 0$1 trigger StreamModeActive and sShovel do
121212: LD_EXP 148
121216: IFFALSE 121224
121218: PUSH
121219: LD_EXP 185
121223: AND
121224: IFFALSE 121244
121226: GO 121228
121228: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
121229: LD_INT 19
121231: PPUSH
121232: LD_OWVAR 2
121236: PPUSH
121237: LD_INT 0
121239: PPUSH
121240: CALL_OW 324
121244: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
121245: LD_EXP 148
121249: IFFALSE 121257
121251: PUSH
121252: LD_EXP 157
121256: AND
121257: IFFALSE 121359
121259: GO 121261
121261: DISABLE
121262: LD_INT 0
121264: PPUSH
121265: PPUSH
// begin enable ;
121266: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
121267: LD_ADDR_VAR 0 2
121271: PUSH
121272: LD_INT 22
121274: PUSH
121275: LD_OWVAR 2
121279: PUSH
121280: EMPTY
121281: LIST
121282: LIST
121283: PUSH
121284: LD_INT 2
121286: PUSH
121287: LD_INT 34
121289: PUSH
121290: LD_INT 11
121292: PUSH
121293: EMPTY
121294: LIST
121295: LIST
121296: PUSH
121297: LD_INT 34
121299: PUSH
121300: LD_INT 30
121302: PUSH
121303: EMPTY
121304: LIST
121305: LIST
121306: PUSH
121307: EMPTY
121308: LIST
121309: LIST
121310: LIST
121311: PUSH
121312: EMPTY
121313: LIST
121314: LIST
121315: PPUSH
121316: CALL_OW 69
121320: ST_TO_ADDR
// if not tmp then
121321: LD_VAR 0 2
121325: NOT
121326: IFFALSE 121330
// exit ;
121328: GO 121359
// for i in tmp do
121330: LD_ADDR_VAR 0 1
121334: PUSH
121335: LD_VAR 0 2
121339: PUSH
121340: FOR_IN
121341: IFFALSE 121357
// begin SetLives ( i , 0 ) ;
121343: LD_VAR 0 1
121347: PPUSH
121348: LD_INT 0
121350: PPUSH
121351: CALL_OW 234
// end ;
121355: GO 121340
121357: POP
121358: POP
// end ;
121359: PPOPN 2
121361: END
// every 0 0$1 trigger StreamModeActive and sBunker do
121362: LD_EXP 148
121366: IFFALSE 121374
121368: PUSH
121369: LD_EXP 158
121373: AND
121374: IFFALSE 121394
121376: GO 121378
121378: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
121379: LD_INT 32
121381: PPUSH
121382: LD_OWVAR 2
121386: PPUSH
121387: LD_INT 0
121389: PPUSH
121390: CALL_OW 324
121394: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
121395: LD_EXP 148
121399: IFFALSE 121407
121401: PUSH
121402: LD_EXP 159
121406: AND
121407: IFFALSE 121590
121409: GO 121411
121411: DISABLE
121412: LD_INT 0
121414: PPUSH
121415: PPUSH
121416: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
121417: LD_ADDR_VAR 0 2
121421: PUSH
121422: LD_INT 22
121424: PUSH
121425: LD_OWVAR 2
121429: PUSH
121430: EMPTY
121431: LIST
121432: LIST
121433: PUSH
121434: LD_INT 33
121436: PUSH
121437: LD_INT 3
121439: PUSH
121440: EMPTY
121441: LIST
121442: LIST
121443: PUSH
121444: EMPTY
121445: LIST
121446: LIST
121447: PPUSH
121448: CALL_OW 69
121452: ST_TO_ADDR
// if not tmp then
121453: LD_VAR 0 2
121457: NOT
121458: IFFALSE 121462
// exit ;
121460: GO 121590
// side := 0 ;
121462: LD_ADDR_VAR 0 3
121466: PUSH
121467: LD_INT 0
121469: ST_TO_ADDR
// for i := 1 to 8 do
121470: LD_ADDR_VAR 0 1
121474: PUSH
121475: DOUBLE
121476: LD_INT 1
121478: DEC
121479: ST_TO_ADDR
121480: LD_INT 8
121482: PUSH
121483: FOR_TO
121484: IFFALSE 121534
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
121486: LD_OWVAR 2
121490: PUSH
121491: LD_VAR 0 1
121495: NONEQUAL
121496: IFFALSE 121518
121498: PUSH
121499: LD_OWVAR 2
121503: PPUSH
121504: LD_VAR 0 1
121508: PPUSH
121509: CALL_OW 81
121513: PUSH
121514: LD_INT 2
121516: EQUAL
121517: AND
121518: IFFALSE 121532
// begin side := i ;
121520: LD_ADDR_VAR 0 3
121524: PUSH
121525: LD_VAR 0 1
121529: ST_TO_ADDR
// break ;
121530: GO 121534
// end ;
121532: GO 121483
121534: POP
121535: POP
// if not side then
121536: LD_VAR 0 3
121540: NOT
121541: IFFALSE 121545
// exit ;
121543: GO 121590
// for i := 1 to tmp do
121545: LD_ADDR_VAR 0 1
121549: PUSH
121550: DOUBLE
121551: LD_INT 1
121553: DEC
121554: ST_TO_ADDR
121555: LD_VAR 0 2
121559: PUSH
121560: FOR_TO
121561: IFFALSE 121588
// if Prob ( 60 ) then
121563: LD_INT 60
121565: PPUSH
121566: CALL_OW 13
121570: IFFALSE 121586
// SetSide ( i , side ) ;
121572: LD_VAR 0 1
121576: PPUSH
121577: LD_VAR 0 3
121581: PPUSH
121582: CALL_OW 235
121586: GO 121560
121588: POP
121589: POP
// end ;
121590: PPOPN 3
121592: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
121593: LD_EXP 148
121597: IFFALSE 121605
121599: PUSH
121600: LD_EXP 161
121604: AND
121605: IFFALSE 121724
121607: GO 121609
121609: DISABLE
121610: LD_INT 0
121612: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
121613: LD_ADDR_VAR 0 1
121617: PUSH
121618: LD_INT 22
121620: PUSH
121621: LD_OWVAR 2
121625: PUSH
121626: EMPTY
121627: LIST
121628: LIST
121629: PUSH
121630: LD_INT 21
121632: PUSH
121633: LD_INT 1
121635: PUSH
121636: EMPTY
121637: LIST
121638: LIST
121639: PUSH
121640: LD_INT 3
121642: PUSH
121643: LD_INT 23
121645: PUSH
121646: LD_INT 0
121648: PUSH
121649: EMPTY
121650: LIST
121651: LIST
121652: PUSH
121653: EMPTY
121654: LIST
121655: LIST
121656: PUSH
121657: EMPTY
121658: LIST
121659: LIST
121660: LIST
121661: PPUSH
121662: CALL_OW 69
121666: PUSH
121667: FOR_IN
121668: IFFALSE 121722
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
121670: LD_VAR 0 1
121674: PPUSH
121675: CALL_OW 257
121679: PUSH
121680: LD_INT 1
121682: PUSH
121683: LD_INT 2
121685: PUSH
121686: LD_INT 3
121688: PUSH
121689: LD_INT 4
121691: PUSH
121692: EMPTY
121693: LIST
121694: LIST
121695: LIST
121696: LIST
121697: IN
121698: IFFALSE 121720
// SetClass ( un , rand ( 1 , 4 ) ) ;
121700: LD_VAR 0 1
121704: PPUSH
121705: LD_INT 1
121707: PPUSH
121708: LD_INT 4
121710: PPUSH
121711: CALL_OW 12
121715: PPUSH
121716: CALL_OW 336
121720: GO 121667
121722: POP
121723: POP
// end ;
121724: PPOPN 1
121726: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
121727: LD_EXP 148
121731: IFFALSE 121739
121733: PUSH
121734: LD_EXP 160
121738: AND
121739: IFFALSE 121818
121741: GO 121743
121743: DISABLE
121744: LD_INT 0
121746: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
121747: LD_ADDR_VAR 0 1
121751: PUSH
121752: LD_INT 22
121754: PUSH
121755: LD_OWVAR 2
121759: PUSH
121760: EMPTY
121761: LIST
121762: LIST
121763: PUSH
121764: LD_INT 21
121766: PUSH
121767: LD_INT 3
121769: PUSH
121770: EMPTY
121771: LIST
121772: LIST
121773: PUSH
121774: EMPTY
121775: LIST
121776: LIST
121777: PPUSH
121778: CALL_OW 69
121782: ST_TO_ADDR
// if not tmp then
121783: LD_VAR 0 1
121787: NOT
121788: IFFALSE 121792
// exit ;
121790: GO 121818
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
121792: LD_VAR 0 1
121796: PUSH
121797: LD_INT 1
121799: PPUSH
121800: LD_VAR 0 1
121804: PPUSH
121805: CALL_OW 12
121809: ARRAY
121810: PPUSH
121811: LD_INT 100
121813: PPUSH
121814: CALL_OW 234
// end ;
121818: PPOPN 1
121820: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
121821: LD_EXP 148
121825: IFFALSE 121833
121827: PUSH
121828: LD_EXP 162
121832: AND
121833: IFFALSE 121931
121835: GO 121837
121837: DISABLE
121838: LD_INT 0
121840: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
121841: LD_ADDR_VAR 0 1
121845: PUSH
121846: LD_INT 22
121848: PUSH
121849: LD_OWVAR 2
121853: PUSH
121854: EMPTY
121855: LIST
121856: LIST
121857: PUSH
121858: LD_INT 21
121860: PUSH
121861: LD_INT 1
121863: PUSH
121864: EMPTY
121865: LIST
121866: LIST
121867: PUSH
121868: EMPTY
121869: LIST
121870: LIST
121871: PPUSH
121872: CALL_OW 69
121876: ST_TO_ADDR
// if not tmp then
121877: LD_VAR 0 1
121881: NOT
121882: IFFALSE 121886
// exit ;
121884: GO 121931
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
121886: LD_VAR 0 1
121890: PUSH
121891: LD_INT 1
121893: PPUSH
121894: LD_VAR 0 1
121898: PPUSH
121899: CALL_OW 12
121903: ARRAY
121904: PPUSH
121905: LD_INT 1
121907: PPUSH
121908: LD_INT 4
121910: PPUSH
121911: CALL_OW 12
121915: PPUSH
121916: LD_INT 3000
121918: PPUSH
121919: LD_INT 9000
121921: PPUSH
121922: CALL_OW 12
121926: PPUSH
121927: CALL_OW 492
// end ;
121931: PPOPN 1
121933: END
// every 0 0$1 trigger StreamModeActive and sDepot do
121934: LD_EXP 148
121938: IFFALSE 121946
121940: PUSH
121941: LD_EXP 163
121945: AND
121946: IFFALSE 121966
121948: GO 121950
121950: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
121951: LD_INT 1
121953: PPUSH
121954: LD_OWVAR 2
121958: PPUSH
121959: LD_INT 0
121961: PPUSH
121962: CALL_OW 324
121966: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
121967: LD_EXP 148
121971: IFFALSE 121979
121973: PUSH
121974: LD_EXP 164
121978: AND
121979: IFFALSE 122062
121981: GO 121983
121983: DISABLE
121984: LD_INT 0
121986: PPUSH
121987: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
121988: LD_ADDR_VAR 0 2
121992: PUSH
121993: LD_INT 22
121995: PUSH
121996: LD_OWVAR 2
122000: PUSH
122001: EMPTY
122002: LIST
122003: LIST
122004: PUSH
122005: LD_INT 21
122007: PUSH
122008: LD_INT 3
122010: PUSH
122011: EMPTY
122012: LIST
122013: LIST
122014: PUSH
122015: EMPTY
122016: LIST
122017: LIST
122018: PPUSH
122019: CALL_OW 69
122023: ST_TO_ADDR
// if not tmp then
122024: LD_VAR 0 2
122028: NOT
122029: IFFALSE 122033
// exit ;
122031: GO 122062
// for i in tmp do
122033: LD_ADDR_VAR 0 1
122037: PUSH
122038: LD_VAR 0 2
122042: PUSH
122043: FOR_IN
122044: IFFALSE 122060
// SetBLevel ( i , 10 ) ;
122046: LD_VAR 0 1
122050: PPUSH
122051: LD_INT 10
122053: PPUSH
122054: CALL_OW 241
122058: GO 122043
122060: POP
122061: POP
// end ;
122062: PPOPN 2
122064: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
122065: LD_EXP 148
122069: IFFALSE 122077
122071: PUSH
122072: LD_EXP 165
122076: AND
122077: IFFALSE 122188
122079: GO 122081
122081: DISABLE
122082: LD_INT 0
122084: PPUSH
122085: PPUSH
122086: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
122087: LD_ADDR_VAR 0 3
122091: PUSH
122092: LD_INT 22
122094: PUSH
122095: LD_OWVAR 2
122099: PUSH
122100: EMPTY
122101: LIST
122102: LIST
122103: PUSH
122104: LD_INT 25
122106: PUSH
122107: LD_INT 1
122109: PUSH
122110: EMPTY
122111: LIST
122112: LIST
122113: PUSH
122114: EMPTY
122115: LIST
122116: LIST
122117: PPUSH
122118: CALL_OW 69
122122: ST_TO_ADDR
// if not tmp then
122123: LD_VAR 0 3
122127: NOT
122128: IFFALSE 122132
// exit ;
122130: GO 122188
// un := tmp [ rand ( 1 , tmp ) ] ;
122132: LD_ADDR_VAR 0 2
122136: PUSH
122137: LD_VAR 0 3
122141: PUSH
122142: LD_INT 1
122144: PPUSH
122145: LD_VAR 0 3
122149: PPUSH
122150: CALL_OW 12
122154: ARRAY
122155: ST_TO_ADDR
// if Crawls ( un ) then
122156: LD_VAR 0 2
122160: PPUSH
122161: CALL_OW 318
122165: IFFALSE 122176
// ComWalk ( un ) ;
122167: LD_VAR 0 2
122171: PPUSH
122172: CALL_OW 138
// SetClass ( un , class_sniper ) ;
122176: LD_VAR 0 2
122180: PPUSH
122181: LD_INT 5
122183: PPUSH
122184: CALL_OW 336
// end ;
122188: PPOPN 3
122190: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
122191: LD_EXP 148
122195: IFFALSE 122203
122197: PUSH
122198: LD_EXP 166
122202: AND
122203: IFFALSE 122215
122205: PUSH
122206: LD_OWVAR 67
122210: PUSH
122211: LD_INT 4
122213: LESS
122214: AND
122215: IFFALSE 122234
122217: GO 122219
122219: DISABLE
// begin Difficulty := Difficulty + 1 ;
122220: LD_ADDR_OWVAR 67
122224: PUSH
122225: LD_OWVAR 67
122229: PUSH
122230: LD_INT 1
122232: PLUS
122233: ST_TO_ADDR
// end ;
122234: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
122235: LD_EXP 148
122239: IFFALSE 122247
122241: PUSH
122242: LD_EXP 167
122246: AND
122247: IFFALSE 122350
122249: GO 122251
122251: DISABLE
122252: LD_INT 0
122254: PPUSH
// begin for i := 1 to 5 do
122255: LD_ADDR_VAR 0 1
122259: PUSH
122260: DOUBLE
122261: LD_INT 1
122263: DEC
122264: ST_TO_ADDR
122265: LD_INT 5
122267: PUSH
122268: FOR_TO
122269: IFFALSE 122348
// begin uc_nation := nation_nature ;
122271: LD_ADDR_OWVAR 21
122275: PUSH
122276: LD_INT 0
122278: ST_TO_ADDR
// uc_side := 0 ;
122279: LD_ADDR_OWVAR 20
122283: PUSH
122284: LD_INT 0
122286: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
122287: LD_ADDR_OWVAR 29
122291: PUSH
122292: LD_INT 12
122294: PUSH
122295: LD_INT 12
122297: PUSH
122298: EMPTY
122299: LIST
122300: LIST
122301: ST_TO_ADDR
// hc_agressivity := 20 ;
122302: LD_ADDR_OWVAR 35
122306: PUSH
122307: LD_INT 20
122309: ST_TO_ADDR
// hc_class := class_tiger ;
122310: LD_ADDR_OWVAR 28
122314: PUSH
122315: LD_INT 14
122317: ST_TO_ADDR
// hc_gallery :=  ;
122318: LD_ADDR_OWVAR 33
122322: PUSH
122323: LD_STRING 
122325: ST_TO_ADDR
// hc_name :=  ;
122326: LD_ADDR_OWVAR 26
122330: PUSH
122331: LD_STRING 
122333: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
122334: CALL_OW 44
122338: PPUSH
122339: LD_INT 0
122341: PPUSH
122342: CALL_OW 51
// end ;
122346: GO 122268
122348: POP
122349: POP
// end ;
122350: PPOPN 1
122352: END
// every 0 0$1 trigger StreamModeActive and sBomb do
122353: LD_EXP 148
122357: IFFALSE 122365
122359: PUSH
122360: LD_EXP 168
122364: AND
122365: IFFALSE 122374
122367: GO 122369
122369: DISABLE
// StreamSibBomb ;
122370: CALL 122375 0 0
122374: END
// export function StreamSibBomb ; var i , x , y ; begin
122375: LD_INT 0
122377: PPUSH
122378: PPUSH
122379: PPUSH
122380: PPUSH
// result := false ;
122381: LD_ADDR_VAR 0 1
122385: PUSH
122386: LD_INT 0
122388: ST_TO_ADDR
// for i := 1 to 16 do
122389: LD_ADDR_VAR 0 2
122393: PUSH
122394: DOUBLE
122395: LD_INT 1
122397: DEC
122398: ST_TO_ADDR
122399: LD_INT 16
122401: PUSH
122402: FOR_TO
122403: IFFALSE 122602
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
122405: LD_ADDR_VAR 0 3
122409: PUSH
122410: LD_INT 10
122412: PUSH
122413: LD_INT 20
122415: PUSH
122416: LD_INT 30
122418: PUSH
122419: LD_INT 40
122421: PUSH
122422: LD_INT 50
122424: PUSH
122425: LD_INT 60
122427: PUSH
122428: LD_INT 70
122430: PUSH
122431: LD_INT 80
122433: PUSH
122434: LD_INT 90
122436: PUSH
122437: LD_INT 100
122439: PUSH
122440: LD_INT 110
122442: PUSH
122443: LD_INT 120
122445: PUSH
122446: LD_INT 130
122448: PUSH
122449: LD_INT 140
122451: PUSH
122452: LD_INT 150
122454: PUSH
122455: EMPTY
122456: LIST
122457: LIST
122458: LIST
122459: LIST
122460: LIST
122461: LIST
122462: LIST
122463: LIST
122464: LIST
122465: LIST
122466: LIST
122467: LIST
122468: LIST
122469: LIST
122470: LIST
122471: PUSH
122472: LD_INT 1
122474: PPUSH
122475: LD_INT 15
122477: PPUSH
122478: CALL_OW 12
122482: ARRAY
122483: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
122484: LD_ADDR_VAR 0 4
122488: PUSH
122489: LD_INT 10
122491: PUSH
122492: LD_INT 20
122494: PUSH
122495: LD_INT 30
122497: PUSH
122498: LD_INT 40
122500: PUSH
122501: LD_INT 50
122503: PUSH
122504: LD_INT 60
122506: PUSH
122507: LD_INT 70
122509: PUSH
122510: LD_INT 80
122512: PUSH
122513: LD_INT 90
122515: PUSH
122516: LD_INT 100
122518: PUSH
122519: LD_INT 110
122521: PUSH
122522: LD_INT 120
122524: PUSH
122525: LD_INT 130
122527: PUSH
122528: LD_INT 140
122530: PUSH
122531: LD_INT 150
122533: PUSH
122534: EMPTY
122535: LIST
122536: LIST
122537: LIST
122538: LIST
122539: LIST
122540: LIST
122541: LIST
122542: LIST
122543: LIST
122544: LIST
122545: LIST
122546: LIST
122547: LIST
122548: LIST
122549: LIST
122550: PUSH
122551: LD_INT 1
122553: PPUSH
122554: LD_INT 15
122556: PPUSH
122557: CALL_OW 12
122561: ARRAY
122562: ST_TO_ADDR
// if ValidHex ( x , y ) then
122563: LD_VAR 0 3
122567: PPUSH
122568: LD_VAR 0 4
122572: PPUSH
122573: CALL_OW 488
122577: IFFALSE 122600
// begin result := [ x , y ] ;
122579: LD_ADDR_VAR 0 1
122583: PUSH
122584: LD_VAR 0 3
122588: PUSH
122589: LD_VAR 0 4
122593: PUSH
122594: EMPTY
122595: LIST
122596: LIST
122597: ST_TO_ADDR
// break ;
122598: GO 122602
// end ; end ;
122600: GO 122402
122602: POP
122603: POP
// if result then
122604: LD_VAR 0 1
122608: IFFALSE 122668
// begin ToLua ( playSibBomb() ) ;
122610: LD_STRING playSibBomb()
122612: PPUSH
122613: CALL_OW 559
// wait ( 0 0$14 ) ;
122617: LD_INT 490
122619: PPUSH
122620: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
122624: LD_VAR 0 1
122628: PUSH
122629: LD_INT 1
122631: ARRAY
122632: PPUSH
122633: LD_VAR 0 1
122637: PUSH
122638: LD_INT 2
122640: ARRAY
122641: PPUSH
122642: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
122646: LD_VAR 0 1
122650: PUSH
122651: LD_INT 1
122653: ARRAY
122654: PPUSH
122655: LD_VAR 0 1
122659: PUSH
122660: LD_INT 2
122662: ARRAY
122663: PPUSH
122664: CALL_OW 429
// end ; end ;
122668: LD_VAR 0 1
122672: RET
// every 0 0$1 trigger StreamModeActive and sReset do
122673: LD_EXP 148
122677: IFFALSE 122685
122679: PUSH
122680: LD_EXP 170
122684: AND
122685: IFFALSE 122697
122687: GO 122689
122689: DISABLE
// YouLost (  ) ;
122690: LD_STRING 
122692: PPUSH
122693: CALL_OW 104
122697: END
// every 0 0$1 trigger StreamModeActive and sFog do
122698: LD_EXP 148
122702: IFFALSE 122710
122704: PUSH
122705: LD_EXP 169
122709: AND
122710: IFFALSE 122724
122712: GO 122714
122714: DISABLE
// FogOff ( your_side ) ;
122715: LD_OWVAR 2
122719: PPUSH
122720: CALL_OW 344
122724: END
// every 0 0$1 trigger StreamModeActive and sSun do
122725: LD_EXP 148
122729: IFFALSE 122737
122731: PUSH
122732: LD_EXP 171
122736: AND
122737: IFFALSE 122765
122739: GO 122741
122741: DISABLE
// begin solar_recharge_percent := 0 ;
122742: LD_ADDR_OWVAR 79
122746: PUSH
122747: LD_INT 0
122749: ST_TO_ADDR
// wait ( 5 5$00 ) ;
122750: LD_INT 10500
122752: PPUSH
122753: CALL_OW 67
// solar_recharge_percent := 100 ;
122757: LD_ADDR_OWVAR 79
122761: PUSH
122762: LD_INT 100
122764: ST_TO_ADDR
// end ;
122765: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
122766: LD_EXP 148
122770: IFFALSE 122778
122772: PUSH
122773: LD_EXP 172
122777: AND
122778: IFFALSE 123017
122780: GO 122782
122782: DISABLE
122783: LD_INT 0
122785: PPUSH
122786: PPUSH
122787: PPUSH
// begin tmp := [ ] ;
122788: LD_ADDR_VAR 0 3
122792: PUSH
122793: EMPTY
122794: ST_TO_ADDR
// for i := 1 to 6 do
122795: LD_ADDR_VAR 0 1
122799: PUSH
122800: DOUBLE
122801: LD_INT 1
122803: DEC
122804: ST_TO_ADDR
122805: LD_INT 6
122807: PUSH
122808: FOR_TO
122809: IFFALSE 122914
// begin uc_nation := nation_nature ;
122811: LD_ADDR_OWVAR 21
122815: PUSH
122816: LD_INT 0
122818: ST_TO_ADDR
// uc_side := 0 ;
122819: LD_ADDR_OWVAR 20
122823: PUSH
122824: LD_INT 0
122826: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
122827: LD_ADDR_OWVAR 29
122831: PUSH
122832: LD_INT 12
122834: PUSH
122835: LD_INT 12
122837: PUSH
122838: EMPTY
122839: LIST
122840: LIST
122841: ST_TO_ADDR
// hc_agressivity := 20 ;
122842: LD_ADDR_OWVAR 35
122846: PUSH
122847: LD_INT 20
122849: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
122850: LD_ADDR_OWVAR 28
122854: PUSH
122855: LD_INT 17
122857: ST_TO_ADDR
// hc_gallery :=  ;
122858: LD_ADDR_OWVAR 33
122862: PUSH
122863: LD_STRING 
122865: ST_TO_ADDR
// hc_name :=  ;
122866: LD_ADDR_OWVAR 26
122870: PUSH
122871: LD_STRING 
122873: ST_TO_ADDR
// un := CreateHuman ;
122874: LD_ADDR_VAR 0 2
122878: PUSH
122879: CALL_OW 44
122883: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
122884: LD_VAR 0 2
122888: PPUSH
122889: LD_INT 1
122891: PPUSH
122892: CALL_OW 51
// tmp := tmp ^ un ;
122896: LD_ADDR_VAR 0 3
122900: PUSH
122901: LD_VAR 0 3
122905: PUSH
122906: LD_VAR 0 2
122910: ADD
122911: ST_TO_ADDR
// end ;
122912: GO 122808
122914: POP
122915: POP
// repeat wait ( 0 0$1 ) ;
122916: LD_INT 35
122918: PPUSH
122919: CALL_OW 67
// for un in tmp do
122923: LD_ADDR_VAR 0 2
122927: PUSH
122928: LD_VAR 0 3
122932: PUSH
122933: FOR_IN
122934: IFFALSE 123008
// begin if IsDead ( un ) then
122936: LD_VAR 0 2
122940: PPUSH
122941: CALL_OW 301
122945: IFFALSE 122965
// begin tmp := tmp diff un ;
122947: LD_ADDR_VAR 0 3
122951: PUSH
122952: LD_VAR 0 3
122956: PUSH
122957: LD_VAR 0 2
122961: DIFF
122962: ST_TO_ADDR
// continue ;
122963: GO 122933
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
122965: LD_VAR 0 2
122969: PPUSH
122970: LD_INT 3
122972: PUSH
122973: LD_INT 22
122975: PUSH
122976: LD_INT 0
122978: PUSH
122979: EMPTY
122980: LIST
122981: LIST
122982: PUSH
122983: EMPTY
122984: LIST
122985: LIST
122986: PPUSH
122987: CALL_OW 69
122991: PPUSH
122992: LD_VAR 0 2
122996: PPUSH
122997: CALL_OW 74
123001: PPUSH
123002: CALL_OW 115
// end ;
123006: GO 122933
123008: POP
123009: POP
// until not tmp ;
123010: LD_VAR 0 3
123014: NOT
123015: IFFALSE 122916
// end ;
123017: PPOPN 3
123019: END
// every 0 0$1 trigger StreamModeActive and sTroll do
123020: LD_EXP 148
123024: IFFALSE 123032
123026: PUSH
123027: LD_EXP 173
123031: AND
123032: IFFALSE 123086
123034: GO 123036
123036: DISABLE
// begin ToLua ( displayTroll(); ) ;
123037: LD_STRING displayTroll();
123039: PPUSH
123040: CALL_OW 559
// wait ( 3 3$00 ) ;
123044: LD_INT 6300
123046: PPUSH
123047: CALL_OW 67
// ToLua ( hideTroll(); ) ;
123051: LD_STRING hideTroll();
123053: PPUSH
123054: CALL_OW 559
// wait ( 1 1$00 ) ;
123058: LD_INT 2100
123060: PPUSH
123061: CALL_OW 67
// ToLua ( displayTroll(); ) ;
123065: LD_STRING displayTroll();
123067: PPUSH
123068: CALL_OW 559
// wait ( 1 1$00 ) ;
123072: LD_INT 2100
123074: PPUSH
123075: CALL_OW 67
// ToLua ( hideTroll(); ) ;
123079: LD_STRING hideTroll();
123081: PPUSH
123082: CALL_OW 559
// end ;
123086: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
123087: LD_EXP 148
123091: IFFALSE 123099
123093: PUSH
123094: LD_EXP 174
123098: AND
123099: IFFALSE 123162
123101: GO 123103
123103: DISABLE
123104: LD_INT 0
123106: PPUSH
// begin p := 0 ;
123107: LD_ADDR_VAR 0 1
123111: PUSH
123112: LD_INT 0
123114: ST_TO_ADDR
// repeat game_speed := 1 ;
123115: LD_ADDR_OWVAR 65
123119: PUSH
123120: LD_INT 1
123122: ST_TO_ADDR
// wait ( 0 0$1 ) ;
123123: LD_INT 35
123125: PPUSH
123126: CALL_OW 67
// p := p + 1 ;
123130: LD_ADDR_VAR 0 1
123134: PUSH
123135: LD_VAR 0 1
123139: PUSH
123140: LD_INT 1
123142: PLUS
123143: ST_TO_ADDR
// until p >= 60 ;
123144: LD_VAR 0 1
123148: PUSH
123149: LD_INT 60
123151: GREATEREQUAL
123152: IFFALSE 123115
// game_speed := 4 ;
123154: LD_ADDR_OWVAR 65
123158: PUSH
123159: LD_INT 4
123161: ST_TO_ADDR
// end ;
123162: PPOPN 1
123164: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
123165: LD_EXP 148
123169: IFFALSE 123177
123171: PUSH
123172: LD_EXP 175
123176: AND
123177: IFFALSE 123323
123179: GO 123181
123181: DISABLE
123182: LD_INT 0
123184: PPUSH
123185: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
123186: LD_ADDR_VAR 0 1
123190: PUSH
123191: LD_INT 22
123193: PUSH
123194: LD_OWVAR 2
123198: PUSH
123199: EMPTY
123200: LIST
123201: LIST
123202: PUSH
123203: LD_INT 2
123205: PUSH
123206: LD_INT 30
123208: PUSH
123209: LD_INT 0
123211: PUSH
123212: EMPTY
123213: LIST
123214: LIST
123215: PUSH
123216: LD_INT 30
123218: PUSH
123219: LD_INT 1
123221: PUSH
123222: EMPTY
123223: LIST
123224: LIST
123225: PUSH
123226: EMPTY
123227: LIST
123228: LIST
123229: LIST
123230: PUSH
123231: EMPTY
123232: LIST
123233: LIST
123234: PPUSH
123235: CALL_OW 69
123239: ST_TO_ADDR
// if not depot then
123240: LD_VAR 0 1
123244: NOT
123245: IFFALSE 123249
// exit ;
123247: GO 123323
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
123249: LD_ADDR_VAR 0 2
123253: PUSH
123254: LD_VAR 0 1
123258: PUSH
123259: LD_INT 1
123261: PPUSH
123262: LD_VAR 0 1
123266: PPUSH
123267: CALL_OW 12
123271: ARRAY
123272: PPUSH
123273: CALL_OW 274
123277: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
123278: LD_VAR 0 2
123282: PPUSH
123283: LD_INT 1
123285: PPUSH
123286: LD_INT 0
123288: PPUSH
123289: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
123293: LD_VAR 0 2
123297: PPUSH
123298: LD_INT 2
123300: PPUSH
123301: LD_INT 0
123303: PPUSH
123304: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
123308: LD_VAR 0 2
123312: PPUSH
123313: LD_INT 3
123315: PPUSH
123316: LD_INT 0
123318: PPUSH
123319: CALL_OW 277
// end ;
123323: PPOPN 2
123325: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
123326: LD_EXP 148
123330: IFFALSE 123338
123332: PUSH
123333: LD_EXP 176
123337: AND
123338: IFFALSE 123435
123340: GO 123342
123342: DISABLE
123343: LD_INT 0
123345: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
123346: LD_ADDR_VAR 0 1
123350: PUSH
123351: LD_INT 22
123353: PUSH
123354: LD_OWVAR 2
123358: PUSH
123359: EMPTY
123360: LIST
123361: LIST
123362: PUSH
123363: LD_INT 21
123365: PUSH
123366: LD_INT 1
123368: PUSH
123369: EMPTY
123370: LIST
123371: LIST
123372: PUSH
123373: LD_INT 3
123375: PUSH
123376: LD_INT 23
123378: PUSH
123379: LD_INT 0
123381: PUSH
123382: EMPTY
123383: LIST
123384: LIST
123385: PUSH
123386: EMPTY
123387: LIST
123388: LIST
123389: PUSH
123390: EMPTY
123391: LIST
123392: LIST
123393: LIST
123394: PPUSH
123395: CALL_OW 69
123399: ST_TO_ADDR
// if not tmp then
123400: LD_VAR 0 1
123404: NOT
123405: IFFALSE 123409
// exit ;
123407: GO 123435
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
123409: LD_VAR 0 1
123413: PUSH
123414: LD_INT 1
123416: PPUSH
123417: LD_VAR 0 1
123421: PPUSH
123422: CALL_OW 12
123426: ARRAY
123427: PPUSH
123428: LD_INT 200
123430: PPUSH
123431: CALL_OW 234
// end ;
123435: PPOPN 1
123437: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
123438: LD_EXP 148
123442: IFFALSE 123450
123444: PUSH
123445: LD_EXP 177
123449: AND
123450: IFFALSE 123529
123452: GO 123454
123454: DISABLE
123455: LD_INT 0
123457: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
123458: LD_ADDR_VAR 0 1
123462: PUSH
123463: LD_INT 22
123465: PUSH
123466: LD_OWVAR 2
123470: PUSH
123471: EMPTY
123472: LIST
123473: LIST
123474: PUSH
123475: LD_INT 21
123477: PUSH
123478: LD_INT 2
123480: PUSH
123481: EMPTY
123482: LIST
123483: LIST
123484: PUSH
123485: EMPTY
123486: LIST
123487: LIST
123488: PPUSH
123489: CALL_OW 69
123493: ST_TO_ADDR
// if not tmp then
123494: LD_VAR 0 1
123498: NOT
123499: IFFALSE 123503
// exit ;
123501: GO 123529
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
123503: LD_VAR 0 1
123507: PUSH
123508: LD_INT 1
123510: PPUSH
123511: LD_VAR 0 1
123515: PPUSH
123516: CALL_OW 12
123520: ARRAY
123521: PPUSH
123522: LD_INT 60
123524: PPUSH
123525: CALL_OW 234
// end ;
123529: PPOPN 1
123531: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
123532: LD_EXP 148
123536: IFFALSE 123544
123538: PUSH
123539: LD_EXP 178
123543: AND
123544: IFFALSE 123643
123546: GO 123548
123548: DISABLE
123549: LD_INT 0
123551: PPUSH
123552: PPUSH
// begin enable ;
123553: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
123554: LD_ADDR_VAR 0 1
123558: PUSH
123559: LD_INT 22
123561: PUSH
123562: LD_OWVAR 2
123566: PUSH
123567: EMPTY
123568: LIST
123569: LIST
123570: PUSH
123571: LD_INT 61
123573: PUSH
123574: EMPTY
123575: LIST
123576: PUSH
123577: LD_INT 33
123579: PUSH
123580: LD_INT 2
123582: PUSH
123583: EMPTY
123584: LIST
123585: LIST
123586: PUSH
123587: EMPTY
123588: LIST
123589: LIST
123590: LIST
123591: PPUSH
123592: CALL_OW 69
123596: ST_TO_ADDR
// if not tmp then
123597: LD_VAR 0 1
123601: NOT
123602: IFFALSE 123606
// exit ;
123604: GO 123643
// for i in tmp do
123606: LD_ADDR_VAR 0 2
123610: PUSH
123611: LD_VAR 0 1
123615: PUSH
123616: FOR_IN
123617: IFFALSE 123641
// if IsControledBy ( i ) then
123619: LD_VAR 0 2
123623: PPUSH
123624: CALL_OW 312
123628: IFFALSE 123639
// ComUnlink ( i ) ;
123630: LD_VAR 0 2
123634: PPUSH
123635: CALL_OW 136
123639: GO 123616
123641: POP
123642: POP
// end ;
123643: PPOPN 2
123645: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
123646: LD_EXP 148
123650: IFFALSE 123658
123652: PUSH
123653: LD_EXP 179
123657: AND
123658: IFFALSE 123798
123660: GO 123662
123662: DISABLE
123663: LD_INT 0
123665: PPUSH
123666: PPUSH
// begin ToLua ( displayPowell(); ) ;
123667: LD_STRING displayPowell();
123669: PPUSH
123670: CALL_OW 559
// uc_side := 0 ;
123674: LD_ADDR_OWVAR 20
123678: PUSH
123679: LD_INT 0
123681: ST_TO_ADDR
// uc_nation := 2 ;
123682: LD_ADDR_OWVAR 21
123686: PUSH
123687: LD_INT 2
123689: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
123690: LD_ADDR_OWVAR 37
123694: PUSH
123695: LD_INT 14
123697: ST_TO_ADDR
// vc_engine := engine_siberite ;
123698: LD_ADDR_OWVAR 39
123702: PUSH
123703: LD_INT 3
123705: ST_TO_ADDR
// vc_control := control_apeman ;
123706: LD_ADDR_OWVAR 38
123710: PUSH
123711: LD_INT 5
123713: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
123714: LD_ADDR_OWVAR 40
123718: PUSH
123719: LD_INT 29
123721: ST_TO_ADDR
// un := CreateVehicle ;
123722: LD_ADDR_VAR 0 2
123726: PUSH
123727: CALL_OW 45
123731: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
123732: LD_VAR 0 2
123736: PPUSH
123737: LD_INT 1
123739: PPUSH
123740: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
123744: LD_INT 35
123746: PPUSH
123747: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
123751: LD_VAR 0 2
123755: PPUSH
123756: LD_INT 22
123758: PUSH
123759: LD_OWVAR 2
123763: PUSH
123764: EMPTY
123765: LIST
123766: LIST
123767: PPUSH
123768: CALL_OW 69
123772: PPUSH
123773: LD_VAR 0 2
123777: PPUSH
123778: CALL_OW 74
123782: PPUSH
123783: CALL_OW 115
// until IsDead ( un ) ;
123787: LD_VAR 0 2
123791: PPUSH
123792: CALL_OW 301
123796: IFFALSE 123744
// end ;
123798: PPOPN 2
123800: END
// every 0 0$1 trigger StreamModeActive and sStu do
123801: LD_EXP 148
123805: IFFALSE 123813
123807: PUSH
123808: LD_EXP 187
123812: AND
123813: IFFALSE 123829
123815: GO 123817
123817: DISABLE
// begin ToLua ( displayStucuk(); ) ;
123818: LD_STRING displayStucuk();
123820: PPUSH
123821: CALL_OW 559
// ResetFog ;
123825: CALL_OW 335
// end ;
123829: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
123830: LD_EXP 148
123834: IFFALSE 123842
123836: PUSH
123837: LD_EXP 180
123841: AND
123842: IFFALSE 123983
123844: GO 123846
123846: DISABLE
123847: LD_INT 0
123849: PPUSH
123850: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
123851: LD_ADDR_VAR 0 2
123855: PUSH
123856: LD_INT 22
123858: PUSH
123859: LD_OWVAR 2
123863: PUSH
123864: EMPTY
123865: LIST
123866: LIST
123867: PUSH
123868: LD_INT 21
123870: PUSH
123871: LD_INT 1
123873: PUSH
123874: EMPTY
123875: LIST
123876: LIST
123877: PUSH
123878: EMPTY
123879: LIST
123880: LIST
123881: PPUSH
123882: CALL_OW 69
123886: ST_TO_ADDR
// if not tmp then
123887: LD_VAR 0 2
123891: NOT
123892: IFFALSE 123896
// exit ;
123894: GO 123983
// un := tmp [ rand ( 1 , tmp ) ] ;
123896: LD_ADDR_VAR 0 1
123900: PUSH
123901: LD_VAR 0 2
123905: PUSH
123906: LD_INT 1
123908: PPUSH
123909: LD_VAR 0 2
123913: PPUSH
123914: CALL_OW 12
123918: ARRAY
123919: ST_TO_ADDR
// SetSide ( un , 0 ) ;
123920: LD_VAR 0 1
123924: PPUSH
123925: LD_INT 0
123927: PPUSH
123928: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
123932: LD_VAR 0 1
123936: PPUSH
123937: LD_OWVAR 3
123941: PUSH
123942: LD_VAR 0 1
123946: DIFF
123947: PPUSH
123948: LD_VAR 0 1
123952: PPUSH
123953: CALL_OW 74
123957: PPUSH
123958: CALL_OW 115
// wait ( 0 0$20 ) ;
123962: LD_INT 700
123964: PPUSH
123965: CALL_OW 67
// SetSide ( un , your_side ) ;
123969: LD_VAR 0 1
123973: PPUSH
123974: LD_OWVAR 2
123978: PPUSH
123979: CALL_OW 235
// end ;
123983: PPOPN 2
123985: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
123986: LD_EXP 148
123990: IFFALSE 123998
123992: PUSH
123993: LD_EXP 181
123997: AND
123998: IFFALSE 124104
124000: GO 124002
124002: DISABLE
124003: LD_INT 0
124005: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
124006: LD_ADDR_VAR 0 1
124010: PUSH
124011: LD_INT 22
124013: PUSH
124014: LD_OWVAR 2
124018: PUSH
124019: EMPTY
124020: LIST
124021: LIST
124022: PUSH
124023: LD_INT 2
124025: PUSH
124026: LD_INT 30
124028: PUSH
124029: LD_INT 0
124031: PUSH
124032: EMPTY
124033: LIST
124034: LIST
124035: PUSH
124036: LD_INT 30
124038: PUSH
124039: LD_INT 1
124041: PUSH
124042: EMPTY
124043: LIST
124044: LIST
124045: PUSH
124046: EMPTY
124047: LIST
124048: LIST
124049: LIST
124050: PUSH
124051: EMPTY
124052: LIST
124053: LIST
124054: PPUSH
124055: CALL_OW 69
124059: ST_TO_ADDR
// if not depot then
124060: LD_VAR 0 1
124064: NOT
124065: IFFALSE 124069
// exit ;
124067: GO 124104
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
124069: LD_VAR 0 1
124073: PUSH
124074: LD_INT 1
124076: ARRAY
124077: PPUSH
124078: CALL_OW 250
124082: PPUSH
124083: LD_VAR 0 1
124087: PUSH
124088: LD_INT 1
124090: ARRAY
124091: PPUSH
124092: CALL_OW 251
124096: PPUSH
124097: LD_INT 70
124099: PPUSH
124100: CALL_OW 495
// end ;
124104: PPOPN 1
124106: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
124107: LD_EXP 148
124111: IFFALSE 124119
124113: PUSH
124114: LD_EXP 182
124118: AND
124119: IFFALSE 124330
124121: GO 124123
124123: DISABLE
124124: LD_INT 0
124126: PPUSH
124127: PPUSH
124128: PPUSH
124129: PPUSH
124130: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
124131: LD_ADDR_VAR 0 5
124135: PUSH
124136: LD_INT 22
124138: PUSH
124139: LD_OWVAR 2
124143: PUSH
124144: EMPTY
124145: LIST
124146: LIST
124147: PUSH
124148: LD_INT 21
124150: PUSH
124151: LD_INT 1
124153: PUSH
124154: EMPTY
124155: LIST
124156: LIST
124157: PUSH
124158: EMPTY
124159: LIST
124160: LIST
124161: PPUSH
124162: CALL_OW 69
124166: ST_TO_ADDR
// if not tmp then
124167: LD_VAR 0 5
124171: NOT
124172: IFFALSE 124176
// exit ;
124174: GO 124330
// for i in tmp do
124176: LD_ADDR_VAR 0 1
124180: PUSH
124181: LD_VAR 0 5
124185: PUSH
124186: FOR_IN
124187: IFFALSE 124328
// begin d := rand ( 0 , 5 ) ;
124189: LD_ADDR_VAR 0 4
124193: PUSH
124194: LD_INT 0
124196: PPUSH
124197: LD_INT 5
124199: PPUSH
124200: CALL_OW 12
124204: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
124205: LD_ADDR_VAR 0 2
124209: PUSH
124210: LD_VAR 0 1
124214: PPUSH
124215: CALL_OW 250
124219: PPUSH
124220: LD_VAR 0 4
124224: PPUSH
124225: LD_INT 3
124227: PPUSH
124228: LD_INT 12
124230: PPUSH
124231: CALL_OW 12
124235: PPUSH
124236: CALL_OW 272
124240: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
124241: LD_ADDR_VAR 0 3
124245: PUSH
124246: LD_VAR 0 1
124250: PPUSH
124251: CALL_OW 251
124255: PPUSH
124256: LD_VAR 0 4
124260: PPUSH
124261: LD_INT 3
124263: PPUSH
124264: LD_INT 12
124266: PPUSH
124267: CALL_OW 12
124271: PPUSH
124272: CALL_OW 273
124276: ST_TO_ADDR
// if ValidHex ( x , y ) then
124277: LD_VAR 0 2
124281: PPUSH
124282: LD_VAR 0 3
124286: PPUSH
124287: CALL_OW 488
124291: IFFALSE 124326
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
124293: LD_VAR 0 1
124297: PPUSH
124298: LD_VAR 0 2
124302: PPUSH
124303: LD_VAR 0 3
124307: PPUSH
124308: LD_INT 3
124310: PPUSH
124311: LD_INT 6
124313: PPUSH
124314: CALL_OW 12
124318: PPUSH
124319: LD_INT 1
124321: PPUSH
124322: CALL_OW 483
// end ;
124326: GO 124186
124328: POP
124329: POP
// end ;
124330: PPOPN 5
124332: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
124333: LD_EXP 148
124337: IFFALSE 124345
124339: PUSH
124340: LD_EXP 183
124344: AND
124345: IFFALSE 124439
124347: GO 124349
124349: DISABLE
124350: LD_INT 0
124352: PPUSH
124353: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
124354: LD_ADDR_VAR 0 2
124358: PUSH
124359: LD_INT 22
124361: PUSH
124362: LD_OWVAR 2
124366: PUSH
124367: EMPTY
124368: LIST
124369: LIST
124370: PUSH
124371: LD_INT 32
124373: PUSH
124374: LD_INT 1
124376: PUSH
124377: EMPTY
124378: LIST
124379: LIST
124380: PUSH
124381: LD_INT 21
124383: PUSH
124384: LD_INT 2
124386: PUSH
124387: EMPTY
124388: LIST
124389: LIST
124390: PUSH
124391: EMPTY
124392: LIST
124393: LIST
124394: LIST
124395: PPUSH
124396: CALL_OW 69
124400: ST_TO_ADDR
// if not tmp then
124401: LD_VAR 0 2
124405: NOT
124406: IFFALSE 124410
// exit ;
124408: GO 124439
// for i in tmp do
124410: LD_ADDR_VAR 0 1
124414: PUSH
124415: LD_VAR 0 2
124419: PUSH
124420: FOR_IN
124421: IFFALSE 124437
// SetFuel ( i , 0 ) ;
124423: LD_VAR 0 1
124427: PPUSH
124428: LD_INT 0
124430: PPUSH
124431: CALL_OW 240
124435: GO 124420
124437: POP
124438: POP
// end ;
124439: PPOPN 2
124441: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
124442: LD_EXP 148
124446: IFFALSE 124454
124448: PUSH
124449: LD_EXP 184
124453: AND
124454: IFFALSE 124520
124456: GO 124458
124458: DISABLE
124459: LD_INT 0
124461: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
124462: LD_ADDR_VAR 0 1
124466: PUSH
124467: LD_INT 22
124469: PUSH
124470: LD_OWVAR 2
124474: PUSH
124475: EMPTY
124476: LIST
124477: LIST
124478: PUSH
124479: LD_INT 30
124481: PUSH
124482: LD_INT 29
124484: PUSH
124485: EMPTY
124486: LIST
124487: LIST
124488: PUSH
124489: EMPTY
124490: LIST
124491: LIST
124492: PPUSH
124493: CALL_OW 69
124497: ST_TO_ADDR
// if not tmp then
124498: LD_VAR 0 1
124502: NOT
124503: IFFALSE 124507
// exit ;
124505: GO 124520
// DestroyUnit ( tmp [ 1 ] ) ;
124507: LD_VAR 0 1
124511: PUSH
124512: LD_INT 1
124514: ARRAY
124515: PPUSH
124516: CALL_OW 65
// end ;
124520: PPOPN 1
124522: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
124523: LD_EXP 148
124527: IFFALSE 124535
124529: PUSH
124530: LD_EXP 186
124534: AND
124535: IFFALSE 124664
124537: GO 124539
124539: DISABLE
124540: LD_INT 0
124542: PPUSH
// begin uc_side := 0 ;
124543: LD_ADDR_OWVAR 20
124547: PUSH
124548: LD_INT 0
124550: ST_TO_ADDR
// uc_nation := nation_arabian ;
124551: LD_ADDR_OWVAR 21
124555: PUSH
124556: LD_INT 2
124558: ST_TO_ADDR
// hc_gallery :=  ;
124559: LD_ADDR_OWVAR 33
124563: PUSH
124564: LD_STRING 
124566: ST_TO_ADDR
// hc_name :=  ;
124567: LD_ADDR_OWVAR 26
124571: PUSH
124572: LD_STRING 
124574: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
124575: LD_INT 1
124577: PPUSH
124578: LD_INT 11
124580: PPUSH
124581: LD_INT 10
124583: PPUSH
124584: CALL_OW 380
// un := CreateHuman ;
124588: LD_ADDR_VAR 0 1
124592: PUSH
124593: CALL_OW 44
124597: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
124598: LD_VAR 0 1
124602: PPUSH
124603: LD_INT 1
124605: PPUSH
124606: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
124610: LD_INT 35
124612: PPUSH
124613: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
124617: LD_VAR 0 1
124621: PPUSH
124622: LD_INT 22
124624: PUSH
124625: LD_OWVAR 2
124629: PUSH
124630: EMPTY
124631: LIST
124632: LIST
124633: PPUSH
124634: CALL_OW 69
124638: PPUSH
124639: LD_VAR 0 1
124643: PPUSH
124644: CALL_OW 74
124648: PPUSH
124649: CALL_OW 115
// until IsDead ( un ) ;
124653: LD_VAR 0 1
124657: PPUSH
124658: CALL_OW 301
124662: IFFALSE 124610
// end ;
124664: PPOPN 1
124666: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
124667: LD_EXP 148
124671: IFFALSE 124679
124673: PUSH
124674: LD_EXP 188
124678: AND
124679: IFFALSE 124691
124681: GO 124683
124683: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
124684: LD_STRING earthquake(getX(game), 0, 32)
124686: PPUSH
124687: CALL_OW 559
124691: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
124692: LD_EXP 148
124696: IFFALSE 124704
124698: PUSH
124699: LD_EXP 189
124703: AND
124704: IFFALSE 124795
124706: GO 124708
124708: DISABLE
124709: LD_INT 0
124711: PPUSH
// begin enable ;
124712: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
124713: LD_ADDR_VAR 0 1
124717: PUSH
124718: LD_INT 22
124720: PUSH
124721: LD_OWVAR 2
124725: PUSH
124726: EMPTY
124727: LIST
124728: LIST
124729: PUSH
124730: LD_INT 21
124732: PUSH
124733: LD_INT 2
124735: PUSH
124736: EMPTY
124737: LIST
124738: LIST
124739: PUSH
124740: LD_INT 33
124742: PUSH
124743: LD_INT 3
124745: PUSH
124746: EMPTY
124747: LIST
124748: LIST
124749: PUSH
124750: EMPTY
124751: LIST
124752: LIST
124753: LIST
124754: PPUSH
124755: CALL_OW 69
124759: ST_TO_ADDR
// if not tmp then
124760: LD_VAR 0 1
124764: NOT
124765: IFFALSE 124769
// exit ;
124767: GO 124795
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
124769: LD_VAR 0 1
124773: PUSH
124774: LD_INT 1
124776: PPUSH
124777: LD_VAR 0 1
124781: PPUSH
124782: CALL_OW 12
124786: ARRAY
124787: PPUSH
124788: LD_INT 1
124790: PPUSH
124791: CALL_OW 234
// end ;
124795: PPOPN 1
124797: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
124798: LD_EXP 148
124802: IFFALSE 124810
124804: PUSH
124805: LD_EXP 190
124809: AND
124810: IFFALSE 124951
124812: GO 124814
124814: DISABLE
124815: LD_INT 0
124817: PPUSH
124818: PPUSH
124819: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
124820: LD_ADDR_VAR 0 3
124824: PUSH
124825: LD_INT 22
124827: PUSH
124828: LD_OWVAR 2
124832: PUSH
124833: EMPTY
124834: LIST
124835: LIST
124836: PUSH
124837: LD_INT 25
124839: PUSH
124840: LD_INT 1
124842: PUSH
124843: EMPTY
124844: LIST
124845: LIST
124846: PUSH
124847: EMPTY
124848: LIST
124849: LIST
124850: PPUSH
124851: CALL_OW 69
124855: ST_TO_ADDR
// if not tmp then
124856: LD_VAR 0 3
124860: NOT
124861: IFFALSE 124865
// exit ;
124863: GO 124951
// un := tmp [ rand ( 1 , tmp ) ] ;
124865: LD_ADDR_VAR 0 2
124869: PUSH
124870: LD_VAR 0 3
124874: PUSH
124875: LD_INT 1
124877: PPUSH
124878: LD_VAR 0 3
124882: PPUSH
124883: CALL_OW 12
124887: ARRAY
124888: ST_TO_ADDR
// if Crawls ( un ) then
124889: LD_VAR 0 2
124893: PPUSH
124894: CALL_OW 318
124898: IFFALSE 124909
// ComWalk ( un ) ;
124900: LD_VAR 0 2
124904: PPUSH
124905: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
124909: LD_VAR 0 2
124913: PPUSH
124914: LD_INT 9
124916: PPUSH
124917: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
124921: LD_INT 28
124923: PPUSH
124924: LD_OWVAR 2
124928: PPUSH
124929: LD_INT 2
124931: PPUSH
124932: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
124936: LD_INT 29
124938: PPUSH
124939: LD_OWVAR 2
124943: PPUSH
124944: LD_INT 2
124946: PPUSH
124947: CALL_OW 322
// end ;
124951: PPOPN 3
124953: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
124954: LD_EXP 148
124958: IFFALSE 124966
124960: PUSH
124961: LD_EXP 191
124965: AND
124966: IFFALSE 125077
124968: GO 124970
124970: DISABLE
124971: LD_INT 0
124973: PPUSH
124974: PPUSH
124975: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
124976: LD_ADDR_VAR 0 3
124980: PUSH
124981: LD_INT 22
124983: PUSH
124984: LD_OWVAR 2
124988: PUSH
124989: EMPTY
124990: LIST
124991: LIST
124992: PUSH
124993: LD_INT 25
124995: PUSH
124996: LD_INT 1
124998: PUSH
124999: EMPTY
125000: LIST
125001: LIST
125002: PUSH
125003: EMPTY
125004: LIST
125005: LIST
125006: PPUSH
125007: CALL_OW 69
125011: ST_TO_ADDR
// if not tmp then
125012: LD_VAR 0 3
125016: NOT
125017: IFFALSE 125021
// exit ;
125019: GO 125077
// un := tmp [ rand ( 1 , tmp ) ] ;
125021: LD_ADDR_VAR 0 2
125025: PUSH
125026: LD_VAR 0 3
125030: PUSH
125031: LD_INT 1
125033: PPUSH
125034: LD_VAR 0 3
125038: PPUSH
125039: CALL_OW 12
125043: ARRAY
125044: ST_TO_ADDR
// if Crawls ( un ) then
125045: LD_VAR 0 2
125049: PPUSH
125050: CALL_OW 318
125054: IFFALSE 125065
// ComWalk ( un ) ;
125056: LD_VAR 0 2
125060: PPUSH
125061: CALL_OW 138
// SetClass ( un , class_mortar ) ;
125065: LD_VAR 0 2
125069: PPUSH
125070: LD_INT 8
125072: PPUSH
125073: CALL_OW 336
// end ;
125077: PPOPN 3
125079: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
125080: LD_EXP 148
125084: IFFALSE 125092
125086: PUSH
125087: LD_EXP 192
125091: AND
125092: IFFALSE 125236
125094: GO 125096
125096: DISABLE
125097: LD_INT 0
125099: PPUSH
125100: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
125101: LD_ADDR_VAR 0 2
125105: PUSH
125106: LD_INT 22
125108: PUSH
125109: LD_OWVAR 2
125113: PUSH
125114: EMPTY
125115: LIST
125116: LIST
125117: PUSH
125118: LD_INT 21
125120: PUSH
125121: LD_INT 2
125123: PUSH
125124: EMPTY
125125: LIST
125126: LIST
125127: PUSH
125128: LD_INT 2
125130: PUSH
125131: LD_INT 34
125133: PUSH
125134: LD_INT 12
125136: PUSH
125137: EMPTY
125138: LIST
125139: LIST
125140: PUSH
125141: LD_INT 34
125143: PUSH
125144: LD_INT 51
125146: PUSH
125147: EMPTY
125148: LIST
125149: LIST
125150: PUSH
125151: LD_INT 34
125153: PUSH
125154: LD_INT 32
125156: PUSH
125157: EMPTY
125158: LIST
125159: LIST
125160: PUSH
125161: EMPTY
125162: LIST
125163: LIST
125164: LIST
125165: LIST
125166: PUSH
125167: EMPTY
125168: LIST
125169: LIST
125170: LIST
125171: PPUSH
125172: CALL_OW 69
125176: ST_TO_ADDR
// if not tmp then
125177: LD_VAR 0 2
125181: NOT
125182: IFFALSE 125186
// exit ;
125184: GO 125236
// for i in tmp do
125186: LD_ADDR_VAR 0 1
125190: PUSH
125191: LD_VAR 0 2
125195: PUSH
125196: FOR_IN
125197: IFFALSE 125234
// if GetCargo ( i , mat_artifact ) = 0 then
125199: LD_VAR 0 1
125203: PPUSH
125204: LD_INT 4
125206: PPUSH
125207: CALL_OW 289
125211: PUSH
125212: LD_INT 0
125214: EQUAL
125215: IFFALSE 125232
// SetCargo ( i , mat_siberit , 100 ) ;
125217: LD_VAR 0 1
125221: PPUSH
125222: LD_INT 3
125224: PPUSH
125225: LD_INT 100
125227: PPUSH
125228: CALL_OW 290
125232: GO 125196
125234: POP
125235: POP
// end ;
125236: PPOPN 2
125238: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
125239: LD_EXP 148
125243: IFFALSE 125251
125245: PUSH
125246: LD_EXP 193
125250: AND
125251: IFFALSE 125434
125253: GO 125255
125255: DISABLE
125256: LD_INT 0
125258: PPUSH
125259: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
125260: LD_ADDR_VAR 0 2
125264: PUSH
125265: LD_INT 22
125267: PUSH
125268: LD_OWVAR 2
125272: PUSH
125273: EMPTY
125274: LIST
125275: LIST
125276: PPUSH
125277: CALL_OW 69
125281: ST_TO_ADDR
// if not tmp then
125282: LD_VAR 0 2
125286: NOT
125287: IFFALSE 125291
// exit ;
125289: GO 125434
// for i := 1 to 2 do
125291: LD_ADDR_VAR 0 1
125295: PUSH
125296: DOUBLE
125297: LD_INT 1
125299: DEC
125300: ST_TO_ADDR
125301: LD_INT 2
125303: PUSH
125304: FOR_TO
125305: IFFALSE 125432
// begin uc_side := your_side ;
125307: LD_ADDR_OWVAR 20
125311: PUSH
125312: LD_OWVAR 2
125316: ST_TO_ADDR
// uc_nation := nation_american ;
125317: LD_ADDR_OWVAR 21
125321: PUSH
125322: LD_INT 1
125324: ST_TO_ADDR
// vc_chassis := us_morphling ;
125325: LD_ADDR_OWVAR 37
125329: PUSH
125330: LD_INT 5
125332: ST_TO_ADDR
// vc_engine := engine_siberite ;
125333: LD_ADDR_OWVAR 39
125337: PUSH
125338: LD_INT 3
125340: ST_TO_ADDR
// vc_control := control_computer ;
125341: LD_ADDR_OWVAR 38
125345: PUSH
125346: LD_INT 3
125348: ST_TO_ADDR
// vc_weapon := us_double_laser ;
125349: LD_ADDR_OWVAR 40
125353: PUSH
125354: LD_INT 10
125356: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
125357: LD_VAR 0 2
125361: PUSH
125362: LD_INT 1
125364: ARRAY
125365: PPUSH
125366: CALL_OW 310
125370: NOT
125371: IFFALSE 125418
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
125373: CALL_OW 45
125377: PPUSH
125378: LD_VAR 0 2
125382: PUSH
125383: LD_INT 1
125385: ARRAY
125386: PPUSH
125387: CALL_OW 250
125391: PPUSH
125392: LD_VAR 0 2
125396: PUSH
125397: LD_INT 1
125399: ARRAY
125400: PPUSH
125401: CALL_OW 251
125405: PPUSH
125406: LD_INT 12
125408: PPUSH
125409: LD_INT 1
125411: PPUSH
125412: CALL_OW 50
125416: GO 125430
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
125418: CALL_OW 45
125422: PPUSH
125423: LD_INT 1
125425: PPUSH
125426: CALL_OW 51
// end ;
125430: GO 125304
125432: POP
125433: POP
// end ;
125434: PPOPN 2
125436: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
125437: LD_EXP 148
125441: IFFALSE 125449
125443: PUSH
125444: LD_EXP 194
125448: AND
125449: IFFALSE 125671
125451: GO 125453
125453: DISABLE
125454: LD_INT 0
125456: PPUSH
125457: PPUSH
125458: PPUSH
125459: PPUSH
125460: PPUSH
125461: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
125462: LD_ADDR_VAR 0 6
125466: PUSH
125467: LD_INT 22
125469: PUSH
125470: LD_OWVAR 2
125474: PUSH
125475: EMPTY
125476: LIST
125477: LIST
125478: PUSH
125479: LD_INT 21
125481: PUSH
125482: LD_INT 1
125484: PUSH
125485: EMPTY
125486: LIST
125487: LIST
125488: PUSH
125489: LD_INT 3
125491: PUSH
125492: LD_INT 23
125494: PUSH
125495: LD_INT 0
125497: PUSH
125498: EMPTY
125499: LIST
125500: LIST
125501: PUSH
125502: EMPTY
125503: LIST
125504: LIST
125505: PUSH
125506: EMPTY
125507: LIST
125508: LIST
125509: LIST
125510: PPUSH
125511: CALL_OW 69
125515: ST_TO_ADDR
// if not tmp then
125516: LD_VAR 0 6
125520: NOT
125521: IFFALSE 125525
// exit ;
125523: GO 125671
// s1 := rand ( 1 , 4 ) ;
125525: LD_ADDR_VAR 0 2
125529: PUSH
125530: LD_INT 1
125532: PPUSH
125533: LD_INT 4
125535: PPUSH
125536: CALL_OW 12
125540: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
125541: LD_ADDR_VAR 0 4
125545: PUSH
125546: LD_VAR 0 6
125550: PUSH
125551: LD_INT 1
125553: ARRAY
125554: PPUSH
125555: LD_VAR 0 2
125559: PPUSH
125560: CALL_OW 259
125564: ST_TO_ADDR
// if s1 = 1 then
125565: LD_VAR 0 2
125569: PUSH
125570: LD_INT 1
125572: EQUAL
125573: IFFALSE 125593
// s2 := rand ( 2 , 4 ) else
125575: LD_ADDR_VAR 0 3
125579: PUSH
125580: LD_INT 2
125582: PPUSH
125583: LD_INT 4
125585: PPUSH
125586: CALL_OW 12
125590: ST_TO_ADDR
125591: GO 125601
// s2 := 1 ;
125593: LD_ADDR_VAR 0 3
125597: PUSH
125598: LD_INT 1
125600: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
125601: LD_ADDR_VAR 0 5
125605: PUSH
125606: LD_VAR 0 6
125610: PUSH
125611: LD_INT 1
125613: ARRAY
125614: PPUSH
125615: LD_VAR 0 3
125619: PPUSH
125620: CALL_OW 259
125624: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
125625: LD_VAR 0 6
125629: PUSH
125630: LD_INT 1
125632: ARRAY
125633: PPUSH
125634: LD_VAR 0 2
125638: PPUSH
125639: LD_VAR 0 5
125643: PPUSH
125644: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
125648: LD_VAR 0 6
125652: PUSH
125653: LD_INT 1
125655: ARRAY
125656: PPUSH
125657: LD_VAR 0 3
125661: PPUSH
125662: LD_VAR 0 4
125666: PPUSH
125667: CALL_OW 237
// end ;
125671: PPOPN 6
125673: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
125674: LD_EXP 148
125678: IFFALSE 125686
125680: PUSH
125681: LD_EXP 195
125685: AND
125686: IFFALSE 125765
125688: GO 125690
125690: DISABLE
125691: LD_INT 0
125693: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
125694: LD_ADDR_VAR 0 1
125698: PUSH
125699: LD_INT 22
125701: PUSH
125702: LD_OWVAR 2
125706: PUSH
125707: EMPTY
125708: LIST
125709: LIST
125710: PUSH
125711: LD_INT 30
125713: PUSH
125714: LD_INT 3
125716: PUSH
125717: EMPTY
125718: LIST
125719: LIST
125720: PUSH
125721: EMPTY
125722: LIST
125723: LIST
125724: PPUSH
125725: CALL_OW 69
125729: ST_TO_ADDR
// if not tmp then
125730: LD_VAR 0 1
125734: NOT
125735: IFFALSE 125739
// exit ;
125737: GO 125765
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
125739: LD_VAR 0 1
125743: PUSH
125744: LD_INT 1
125746: PPUSH
125747: LD_VAR 0 1
125751: PPUSH
125752: CALL_OW 12
125756: ARRAY
125757: PPUSH
125758: LD_INT 1
125760: PPUSH
125761: CALL_OW 234
// end ;
125765: PPOPN 1
125767: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
125768: LD_EXP 148
125772: IFFALSE 125780
125774: PUSH
125775: LD_EXP 196
125779: AND
125780: IFFALSE 125892
125782: GO 125784
125784: DISABLE
125785: LD_INT 0
125787: PPUSH
125788: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
125789: LD_ADDR_VAR 0 2
125793: PUSH
125794: LD_INT 22
125796: PUSH
125797: LD_OWVAR 2
125801: PUSH
125802: EMPTY
125803: LIST
125804: LIST
125805: PUSH
125806: LD_INT 2
125808: PUSH
125809: LD_INT 30
125811: PUSH
125812: LD_INT 27
125814: PUSH
125815: EMPTY
125816: LIST
125817: LIST
125818: PUSH
125819: LD_INT 30
125821: PUSH
125822: LD_INT 26
125824: PUSH
125825: EMPTY
125826: LIST
125827: LIST
125828: PUSH
125829: LD_INT 30
125831: PUSH
125832: LD_INT 28
125834: PUSH
125835: EMPTY
125836: LIST
125837: LIST
125838: PUSH
125839: EMPTY
125840: LIST
125841: LIST
125842: LIST
125843: LIST
125844: PUSH
125845: EMPTY
125846: LIST
125847: LIST
125848: PPUSH
125849: CALL_OW 69
125853: ST_TO_ADDR
// if not tmp then
125854: LD_VAR 0 2
125858: NOT
125859: IFFALSE 125863
// exit ;
125861: GO 125892
// for i in tmp do
125863: LD_ADDR_VAR 0 1
125867: PUSH
125868: LD_VAR 0 2
125872: PUSH
125873: FOR_IN
125874: IFFALSE 125890
// SetLives ( i , 1 ) ;
125876: LD_VAR 0 1
125880: PPUSH
125881: LD_INT 1
125883: PPUSH
125884: CALL_OW 234
125888: GO 125873
125890: POP
125891: POP
// end ;
125892: PPOPN 2
125894: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
125895: LD_EXP 148
125899: IFFALSE 125907
125901: PUSH
125902: LD_EXP 197
125906: AND
125907: IFFALSE 126194
125909: GO 125911
125911: DISABLE
125912: LD_INT 0
125914: PPUSH
125915: PPUSH
125916: PPUSH
// begin i := rand ( 1 , 7 ) ;
125917: LD_ADDR_VAR 0 1
125921: PUSH
125922: LD_INT 1
125924: PPUSH
125925: LD_INT 7
125927: PPUSH
125928: CALL_OW 12
125932: ST_TO_ADDR
// case i of 1 :
125933: LD_VAR 0 1
125937: PUSH
125938: LD_INT 1
125940: DOUBLE
125941: EQUAL
125942: IFTRUE 125946
125944: GO 125956
125946: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
125947: LD_STRING earthquake(getX(game), 0, 32)
125949: PPUSH
125950: CALL_OW 559
125954: GO 126194
125956: LD_INT 2
125958: DOUBLE
125959: EQUAL
125960: IFTRUE 125964
125962: GO 125978
125964: POP
// begin ToLua ( displayStucuk(); ) ;
125965: LD_STRING displayStucuk();
125967: PPUSH
125968: CALL_OW 559
// ResetFog ;
125972: CALL_OW 335
// end ; 3 :
125976: GO 126194
125978: LD_INT 3
125980: DOUBLE
125981: EQUAL
125982: IFTRUE 125986
125984: GO 126090
125986: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
125987: LD_ADDR_VAR 0 2
125991: PUSH
125992: LD_INT 22
125994: PUSH
125995: LD_OWVAR 2
125999: PUSH
126000: EMPTY
126001: LIST
126002: LIST
126003: PUSH
126004: LD_INT 25
126006: PUSH
126007: LD_INT 1
126009: PUSH
126010: EMPTY
126011: LIST
126012: LIST
126013: PUSH
126014: EMPTY
126015: LIST
126016: LIST
126017: PPUSH
126018: CALL_OW 69
126022: ST_TO_ADDR
// if not tmp then
126023: LD_VAR 0 2
126027: NOT
126028: IFFALSE 126032
// exit ;
126030: GO 126194
// un := tmp [ rand ( 1 , tmp ) ] ;
126032: LD_ADDR_VAR 0 3
126036: PUSH
126037: LD_VAR 0 2
126041: PUSH
126042: LD_INT 1
126044: PPUSH
126045: LD_VAR 0 2
126049: PPUSH
126050: CALL_OW 12
126054: ARRAY
126055: ST_TO_ADDR
// if Crawls ( un ) then
126056: LD_VAR 0 3
126060: PPUSH
126061: CALL_OW 318
126065: IFFALSE 126076
// ComWalk ( un ) ;
126067: LD_VAR 0 3
126071: PPUSH
126072: CALL_OW 138
// SetClass ( un , class_mortar ) ;
126076: LD_VAR 0 3
126080: PPUSH
126081: LD_INT 8
126083: PPUSH
126084: CALL_OW 336
// end ; 4 :
126088: GO 126194
126090: LD_INT 4
126092: DOUBLE
126093: EQUAL
126094: IFTRUE 126098
126096: GO 126172
126098: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
126099: LD_ADDR_VAR 0 2
126103: PUSH
126104: LD_INT 22
126106: PUSH
126107: LD_OWVAR 2
126111: PUSH
126112: EMPTY
126113: LIST
126114: LIST
126115: PUSH
126116: LD_INT 30
126118: PUSH
126119: LD_INT 29
126121: PUSH
126122: EMPTY
126123: LIST
126124: LIST
126125: PUSH
126126: EMPTY
126127: LIST
126128: LIST
126129: PPUSH
126130: CALL_OW 69
126134: ST_TO_ADDR
// if not tmp then
126135: LD_VAR 0 2
126139: NOT
126140: IFFALSE 126144
// exit ;
126142: GO 126194
// CenterNowOnUnits ( tmp [ 1 ] ) ;
126144: LD_VAR 0 2
126148: PUSH
126149: LD_INT 1
126151: ARRAY
126152: PPUSH
126153: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
126157: LD_VAR 0 2
126161: PUSH
126162: LD_INT 1
126164: ARRAY
126165: PPUSH
126166: CALL_OW 65
// end ; 5 .. 7 :
126170: GO 126194
126172: LD_INT 5
126174: DOUBLE
126175: GREATEREQUAL
126176: IFFALSE 126184
126178: LD_INT 7
126180: DOUBLE
126181: LESSEQUAL
126182: IFTRUE 126186
126184: GO 126193
126186: POP
// StreamSibBomb ; end ;
126187: CALL 122375 0 0
126191: GO 126194
126193: POP
// end ;
126194: PPOPN 3
126196: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
126197: LD_EXP 148
126201: IFFALSE 126209
126203: PUSH
126204: LD_EXP 198
126208: AND
126209: IFFALSE 126365
126211: GO 126213
126213: DISABLE
126214: LD_INT 0
126216: PPUSH
126217: PPUSH
126218: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
126219: LD_ADDR_VAR 0 2
126223: PUSH
126224: LD_INT 81
126226: PUSH
126227: LD_OWVAR 2
126231: PUSH
126232: EMPTY
126233: LIST
126234: LIST
126235: PUSH
126236: LD_INT 2
126238: PUSH
126239: LD_INT 21
126241: PUSH
126242: LD_INT 1
126244: PUSH
126245: EMPTY
126246: LIST
126247: LIST
126248: PUSH
126249: LD_INT 21
126251: PUSH
126252: LD_INT 2
126254: PUSH
126255: EMPTY
126256: LIST
126257: LIST
126258: PUSH
126259: EMPTY
126260: LIST
126261: LIST
126262: LIST
126263: PUSH
126264: EMPTY
126265: LIST
126266: LIST
126267: PPUSH
126268: CALL_OW 69
126272: ST_TO_ADDR
// if not tmp then
126273: LD_VAR 0 2
126277: NOT
126278: IFFALSE 126282
// exit ;
126280: GO 126365
// p := 0 ;
126282: LD_ADDR_VAR 0 3
126286: PUSH
126287: LD_INT 0
126289: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
126290: LD_INT 35
126292: PPUSH
126293: CALL_OW 67
// p := p + 1 ;
126297: LD_ADDR_VAR 0 3
126301: PUSH
126302: LD_VAR 0 3
126306: PUSH
126307: LD_INT 1
126309: PLUS
126310: ST_TO_ADDR
// for i in tmp do
126311: LD_ADDR_VAR 0 1
126315: PUSH
126316: LD_VAR 0 2
126320: PUSH
126321: FOR_IN
126322: IFFALSE 126353
// if GetLives ( i ) < 1000 then
126324: LD_VAR 0 1
126328: PPUSH
126329: CALL_OW 256
126333: PUSH
126334: LD_INT 1000
126336: LESS
126337: IFFALSE 126351
// SetLives ( i , 1000 ) ;
126339: LD_VAR 0 1
126343: PPUSH
126344: LD_INT 1000
126346: PPUSH
126347: CALL_OW 234
126351: GO 126321
126353: POP
126354: POP
// until p > 20 ;
126355: LD_VAR 0 3
126359: PUSH
126360: LD_INT 20
126362: GREATER
126363: IFFALSE 126290
// end ;
126365: PPOPN 3
126367: END
// every 0 0$1 trigger StreamModeActive and sTime do
126368: LD_EXP 148
126372: IFFALSE 126380
126374: PUSH
126375: LD_EXP 199
126379: AND
126380: IFFALSE 126415
126382: GO 126384
126384: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
126385: LD_INT 28
126387: PPUSH
126388: LD_OWVAR 2
126392: PPUSH
126393: LD_INT 2
126395: PPUSH
126396: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
126400: LD_INT 30
126402: PPUSH
126403: LD_OWVAR 2
126407: PPUSH
126408: LD_INT 2
126410: PPUSH
126411: CALL_OW 322
// end ;
126415: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
126416: LD_EXP 148
126420: IFFALSE 126428
126422: PUSH
126423: LD_EXP 200
126427: AND
126428: IFFALSE 126549
126430: GO 126432
126432: DISABLE
126433: LD_INT 0
126435: PPUSH
126436: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
126437: LD_ADDR_VAR 0 2
126441: PUSH
126442: LD_INT 22
126444: PUSH
126445: LD_OWVAR 2
126449: PUSH
126450: EMPTY
126451: LIST
126452: LIST
126453: PUSH
126454: LD_INT 21
126456: PUSH
126457: LD_INT 1
126459: PUSH
126460: EMPTY
126461: LIST
126462: LIST
126463: PUSH
126464: LD_INT 3
126466: PUSH
126467: LD_INT 23
126469: PUSH
126470: LD_INT 0
126472: PUSH
126473: EMPTY
126474: LIST
126475: LIST
126476: PUSH
126477: EMPTY
126478: LIST
126479: LIST
126480: PUSH
126481: EMPTY
126482: LIST
126483: LIST
126484: LIST
126485: PPUSH
126486: CALL_OW 69
126490: ST_TO_ADDR
// if not tmp then
126491: LD_VAR 0 2
126495: NOT
126496: IFFALSE 126500
// exit ;
126498: GO 126549
// for i in tmp do
126500: LD_ADDR_VAR 0 1
126504: PUSH
126505: LD_VAR 0 2
126509: PUSH
126510: FOR_IN
126511: IFFALSE 126547
// begin if Crawls ( i ) then
126513: LD_VAR 0 1
126517: PPUSH
126518: CALL_OW 318
126522: IFFALSE 126533
// ComWalk ( i ) ;
126524: LD_VAR 0 1
126528: PPUSH
126529: CALL_OW 138
// SetClass ( i , 2 ) ;
126533: LD_VAR 0 1
126537: PPUSH
126538: LD_INT 2
126540: PPUSH
126541: CALL_OW 336
// end ;
126545: GO 126510
126547: POP
126548: POP
// end ;
126549: PPOPN 2
126551: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
126552: LD_EXP 148
126556: IFFALSE 126564
126558: PUSH
126559: LD_EXP 201
126563: AND
126564: IFFALSE 126854
126566: GO 126568
126568: DISABLE
126569: LD_INT 0
126571: PPUSH
126572: PPUSH
126573: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
126574: LD_OWVAR 2
126578: PPUSH
126579: LD_INT 9
126581: PPUSH
126582: LD_INT 1
126584: PPUSH
126585: LD_INT 1
126587: PPUSH
126588: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
126592: LD_INT 9
126594: PPUSH
126595: LD_OWVAR 2
126599: PPUSH
126600: CALL_OW 343
// uc_side := 9 ;
126604: LD_ADDR_OWVAR 20
126608: PUSH
126609: LD_INT 9
126611: ST_TO_ADDR
// uc_nation := 2 ;
126612: LD_ADDR_OWVAR 21
126616: PUSH
126617: LD_INT 2
126619: ST_TO_ADDR
// hc_name := Dark Warrior ;
126620: LD_ADDR_OWVAR 26
126624: PUSH
126625: LD_STRING Dark Warrior
126627: ST_TO_ADDR
// hc_gallery :=  ;
126628: LD_ADDR_OWVAR 33
126632: PUSH
126633: LD_STRING 
126635: ST_TO_ADDR
// hc_noskilllimit := true ;
126636: LD_ADDR_OWVAR 76
126640: PUSH
126641: LD_INT 1
126643: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
126644: LD_ADDR_OWVAR 31
126648: PUSH
126649: LD_INT 30
126651: PUSH
126652: LD_INT 30
126654: PUSH
126655: LD_INT 30
126657: PUSH
126658: LD_INT 30
126660: PUSH
126661: EMPTY
126662: LIST
126663: LIST
126664: LIST
126665: LIST
126666: ST_TO_ADDR
// un := CreateHuman ;
126667: LD_ADDR_VAR 0 3
126671: PUSH
126672: CALL_OW 44
126676: ST_TO_ADDR
// hc_noskilllimit := false ;
126677: LD_ADDR_OWVAR 76
126681: PUSH
126682: LD_INT 0
126684: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
126685: LD_VAR 0 3
126689: PPUSH
126690: LD_INT 1
126692: PPUSH
126693: CALL_OW 51
// ToLua ( playRanger() ) ;
126697: LD_STRING playRanger()
126699: PPUSH
126700: CALL_OW 559
// p := 0 ;
126704: LD_ADDR_VAR 0 2
126708: PUSH
126709: LD_INT 0
126711: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
126712: LD_INT 35
126714: PPUSH
126715: CALL_OW 67
// p := p + 1 ;
126719: LD_ADDR_VAR 0 2
126723: PUSH
126724: LD_VAR 0 2
126728: PUSH
126729: LD_INT 1
126731: PLUS
126732: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
126733: LD_VAR 0 3
126737: PPUSH
126738: CALL_OW 256
126742: PUSH
126743: LD_INT 1000
126745: LESS
126746: IFFALSE 126760
// SetLives ( un , 1000 ) ;
126748: LD_VAR 0 3
126752: PPUSH
126753: LD_INT 1000
126755: PPUSH
126756: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
126760: LD_VAR 0 3
126764: PPUSH
126765: LD_INT 81
126767: PUSH
126768: LD_OWVAR 2
126772: PUSH
126773: EMPTY
126774: LIST
126775: LIST
126776: PUSH
126777: LD_INT 91
126779: PUSH
126780: LD_VAR 0 3
126784: PUSH
126785: LD_INT 30
126787: PUSH
126788: EMPTY
126789: LIST
126790: LIST
126791: LIST
126792: PUSH
126793: EMPTY
126794: LIST
126795: LIST
126796: PPUSH
126797: CALL_OW 69
126801: PPUSH
126802: LD_VAR 0 3
126806: PPUSH
126807: CALL_OW 74
126811: PPUSH
126812: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
126816: LD_VAR 0 2
126820: PUSH
126821: LD_INT 80
126823: GREATER
126824: IFTRUE 126837
126826: PUSH
126827: LD_VAR 0 3
126831: PPUSH
126832: CALL_OW 301
126836: OR
126837: IFFALSE 126712
// if un then
126839: LD_VAR 0 3
126843: IFFALSE 126854
// RemoveUnit ( un ) ;
126845: LD_VAR 0 3
126849: PPUSH
126850: CALL_OW 64
// end ;
126854: PPOPN 3
126856: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
126857: LD_EXP 202
126861: IFFALSE 126977
126863: GO 126865
126865: DISABLE
126866: LD_INT 0
126868: PPUSH
126869: PPUSH
126870: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
126871: LD_ADDR_VAR 0 2
126875: PUSH
126876: LD_INT 81
126878: PUSH
126879: LD_OWVAR 2
126883: PUSH
126884: EMPTY
126885: LIST
126886: LIST
126887: PUSH
126888: LD_INT 21
126890: PUSH
126891: LD_INT 1
126893: PUSH
126894: EMPTY
126895: LIST
126896: LIST
126897: PUSH
126898: EMPTY
126899: LIST
126900: LIST
126901: PPUSH
126902: CALL_OW 69
126906: ST_TO_ADDR
// ToLua ( playComputer() ) ;
126907: LD_STRING playComputer()
126909: PPUSH
126910: CALL_OW 559
// if not tmp then
126914: LD_VAR 0 2
126918: NOT
126919: IFFALSE 126923
// exit ;
126921: GO 126977
// for i in tmp do
126923: LD_ADDR_VAR 0 1
126927: PUSH
126928: LD_VAR 0 2
126932: PUSH
126933: FOR_IN
126934: IFFALSE 126975
// for j := 1 to 4 do
126936: LD_ADDR_VAR 0 3
126940: PUSH
126941: DOUBLE
126942: LD_INT 1
126944: DEC
126945: ST_TO_ADDR
126946: LD_INT 4
126948: PUSH
126949: FOR_TO
126950: IFFALSE 126971
// SetSkill ( i , j , 10 ) ;
126952: LD_VAR 0 1
126956: PPUSH
126957: LD_VAR 0 3
126961: PPUSH
126962: LD_INT 10
126964: PPUSH
126965: CALL_OW 237
126969: GO 126949
126971: POP
126972: POP
126973: GO 126933
126975: POP
126976: POP
// end ;
126977: PPOPN 3
126979: END
// every 0 0$1 trigger s30 do var i , tmp ;
126980: LD_EXP 203
126984: IFFALSE 127053
126986: GO 126988
126988: DISABLE
126989: LD_INT 0
126991: PPUSH
126992: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
126993: LD_ADDR_VAR 0 2
126997: PUSH
126998: LD_INT 22
127000: PUSH
127001: LD_OWVAR 2
127005: PUSH
127006: EMPTY
127007: LIST
127008: LIST
127009: PPUSH
127010: CALL_OW 69
127014: ST_TO_ADDR
// if not tmp then
127015: LD_VAR 0 2
127019: NOT
127020: IFFALSE 127024
// exit ;
127022: GO 127053
// for i in tmp do
127024: LD_ADDR_VAR 0 1
127028: PUSH
127029: LD_VAR 0 2
127033: PUSH
127034: FOR_IN
127035: IFFALSE 127051
// SetLives ( i , 300 ) ;
127037: LD_VAR 0 1
127041: PPUSH
127042: LD_INT 300
127044: PPUSH
127045: CALL_OW 234
127049: GO 127034
127051: POP
127052: POP
// end ;
127053: PPOPN 2
127055: END
// every 0 0$1 trigger s60 do var i , tmp ;
127056: LD_EXP 204
127060: IFFALSE 127129
127062: GO 127064
127064: DISABLE
127065: LD_INT 0
127067: PPUSH
127068: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
127069: LD_ADDR_VAR 0 2
127073: PUSH
127074: LD_INT 22
127076: PUSH
127077: LD_OWVAR 2
127081: PUSH
127082: EMPTY
127083: LIST
127084: LIST
127085: PPUSH
127086: CALL_OW 69
127090: ST_TO_ADDR
// if not tmp then
127091: LD_VAR 0 2
127095: NOT
127096: IFFALSE 127100
// exit ;
127098: GO 127129
// for i in tmp do
127100: LD_ADDR_VAR 0 1
127104: PUSH
127105: LD_VAR 0 2
127109: PUSH
127110: FOR_IN
127111: IFFALSE 127127
// SetLives ( i , 600 ) ;
127113: LD_VAR 0 1
127117: PPUSH
127118: LD_INT 600
127120: PPUSH
127121: CALL_OW 234
127125: GO 127110
127127: POP
127128: POP
// end ;
127129: PPOPN 2
127131: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
127132: LD_INT 0
127134: PPUSH
// case cmd of 301 :
127135: LD_VAR 0 1
127139: PUSH
127140: LD_INT 301
127142: DOUBLE
127143: EQUAL
127144: IFTRUE 127148
127146: GO 127180
127148: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
127149: LD_VAR 0 6
127153: PPUSH
127154: LD_VAR 0 7
127158: PPUSH
127159: LD_VAR 0 8
127163: PPUSH
127164: LD_VAR 0 4
127168: PPUSH
127169: LD_VAR 0 5
127173: PPUSH
127174: CALL 128393 0 5
127178: GO 127301
127180: LD_INT 302
127182: DOUBLE
127183: EQUAL
127184: IFTRUE 127188
127186: GO 127225
127188: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
127189: LD_VAR 0 6
127193: PPUSH
127194: LD_VAR 0 7
127198: PPUSH
127199: LD_VAR 0 8
127203: PPUSH
127204: LD_VAR 0 9
127208: PPUSH
127209: LD_VAR 0 4
127213: PPUSH
127214: LD_VAR 0 5
127218: PPUSH
127219: CALL 128484 0 6
127223: GO 127301
127225: LD_INT 303
127227: DOUBLE
127228: EQUAL
127229: IFTRUE 127233
127231: GO 127270
127233: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
127234: LD_VAR 0 6
127238: PPUSH
127239: LD_VAR 0 7
127243: PPUSH
127244: LD_VAR 0 8
127248: PPUSH
127249: LD_VAR 0 9
127253: PPUSH
127254: LD_VAR 0 4
127258: PPUSH
127259: LD_VAR 0 5
127263: PPUSH
127264: CALL 127306 0 6
127268: GO 127301
127270: LD_INT 304
127272: DOUBLE
127273: EQUAL
127274: IFTRUE 127278
127276: GO 127300
127278: POP
// hHackTeleport ( unit , x , y ) ; end ;
127279: LD_VAR 0 2
127283: PPUSH
127284: LD_VAR 0 4
127288: PPUSH
127289: LD_VAR 0 5
127293: PPUSH
127294: CALL 129077 0 3
127298: GO 127301
127300: POP
// end ;
127301: LD_VAR 0 12
127305: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
127306: LD_INT 0
127308: PPUSH
127309: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
127310: LD_VAR 0 1
127314: PUSH
127315: LD_INT 1
127317: LESS
127318: IFTRUE 127330
127320: PUSH
127321: LD_VAR 0 1
127325: PUSH
127326: LD_INT 3
127328: GREATER
127329: OR
127330: IFTRUE 127348
127332: PUSH
127333: LD_VAR 0 5
127337: PPUSH
127338: LD_VAR 0 6
127342: PPUSH
127343: CALL_OW 428
127347: OR
127348: IFFALSE 127352
// exit ;
127350: GO 128080
// uc_side := your_side ;
127352: LD_ADDR_OWVAR 20
127356: PUSH
127357: LD_OWVAR 2
127361: ST_TO_ADDR
// uc_nation := nation ;
127362: LD_ADDR_OWVAR 21
127366: PUSH
127367: LD_VAR 0 1
127371: ST_TO_ADDR
// bc_level = 1 ;
127372: LD_ADDR_OWVAR 43
127376: PUSH
127377: LD_INT 1
127379: ST_TO_ADDR
// case btype of 1 :
127380: LD_VAR 0 2
127384: PUSH
127385: LD_INT 1
127387: DOUBLE
127388: EQUAL
127389: IFTRUE 127393
127391: GO 127404
127393: POP
// bc_type := b_depot ; 2 :
127394: LD_ADDR_OWVAR 42
127398: PUSH
127399: LD_INT 0
127401: ST_TO_ADDR
127402: GO 128024
127404: LD_INT 2
127406: DOUBLE
127407: EQUAL
127408: IFTRUE 127412
127410: GO 127423
127412: POP
// bc_type := b_warehouse ; 3 :
127413: LD_ADDR_OWVAR 42
127417: PUSH
127418: LD_INT 1
127420: ST_TO_ADDR
127421: GO 128024
127423: LD_INT 3
127425: DOUBLE
127426: EQUAL
127427: IFTRUE 127431
127429: GO 127442
127431: POP
// bc_type := b_lab ; 4 .. 9 :
127432: LD_ADDR_OWVAR 42
127436: PUSH
127437: LD_INT 6
127439: ST_TO_ADDR
127440: GO 128024
127442: LD_INT 4
127444: DOUBLE
127445: GREATEREQUAL
127446: IFFALSE 127454
127448: LD_INT 9
127450: DOUBLE
127451: LESSEQUAL
127452: IFTRUE 127456
127454: GO 127516
127456: POP
// begin bc_type := b_lab_half ;
127457: LD_ADDR_OWVAR 42
127461: PUSH
127462: LD_INT 7
127464: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
127465: LD_ADDR_OWVAR 44
127469: PUSH
127470: LD_INT 10
127472: PUSH
127473: LD_INT 11
127475: PUSH
127476: LD_INT 12
127478: PUSH
127479: LD_INT 15
127481: PUSH
127482: LD_INT 14
127484: PUSH
127485: LD_INT 13
127487: PUSH
127488: EMPTY
127489: LIST
127490: LIST
127491: LIST
127492: LIST
127493: LIST
127494: LIST
127495: PUSH
127496: LD_VAR 0 2
127500: PUSH
127501: LD_INT 3
127503: MINUS
127504: ARRAY
127505: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
127506: LD_ADDR_OWVAR 45
127510: PUSH
127511: LD_INT 9
127513: ST_TO_ADDR
// end ; 10 .. 13 :
127514: GO 128024
127516: LD_INT 10
127518: DOUBLE
127519: GREATEREQUAL
127520: IFFALSE 127528
127522: LD_INT 13
127524: DOUBLE
127525: LESSEQUAL
127526: IFTRUE 127530
127528: GO 127607
127530: POP
// begin bc_type := b_lab_full ;
127531: LD_ADDR_OWVAR 42
127535: PUSH
127536: LD_INT 8
127538: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
127539: LD_ADDR_OWVAR 44
127543: PUSH
127544: LD_INT 10
127546: PUSH
127547: LD_INT 12
127549: PUSH
127550: LD_INT 14
127552: PUSH
127553: LD_INT 13
127555: PUSH
127556: EMPTY
127557: LIST
127558: LIST
127559: LIST
127560: LIST
127561: PUSH
127562: LD_VAR 0 2
127566: PUSH
127567: LD_INT 9
127569: MINUS
127570: ARRAY
127571: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
127572: LD_ADDR_OWVAR 45
127576: PUSH
127577: LD_INT 11
127579: PUSH
127580: LD_INT 15
127582: PUSH
127583: LD_INT 12
127585: PUSH
127586: LD_INT 15
127588: PUSH
127589: EMPTY
127590: LIST
127591: LIST
127592: LIST
127593: LIST
127594: PUSH
127595: LD_VAR 0 2
127599: PUSH
127600: LD_INT 9
127602: MINUS
127603: ARRAY
127604: ST_TO_ADDR
// end ; 14 :
127605: GO 128024
127607: LD_INT 14
127609: DOUBLE
127610: EQUAL
127611: IFTRUE 127615
127613: GO 127626
127615: POP
// bc_type := b_workshop ; 15 :
127616: LD_ADDR_OWVAR 42
127620: PUSH
127621: LD_INT 2
127623: ST_TO_ADDR
127624: GO 128024
127626: LD_INT 15
127628: DOUBLE
127629: EQUAL
127630: IFTRUE 127634
127632: GO 127645
127634: POP
// bc_type := b_factory ; 16 :
127635: LD_ADDR_OWVAR 42
127639: PUSH
127640: LD_INT 3
127642: ST_TO_ADDR
127643: GO 128024
127645: LD_INT 16
127647: DOUBLE
127648: EQUAL
127649: IFTRUE 127653
127651: GO 127664
127653: POP
// bc_type := b_ext_gun ; 17 :
127654: LD_ADDR_OWVAR 42
127658: PUSH
127659: LD_INT 17
127661: ST_TO_ADDR
127662: GO 128024
127664: LD_INT 17
127666: DOUBLE
127667: EQUAL
127668: IFTRUE 127672
127670: GO 127700
127672: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
127673: LD_ADDR_OWVAR 42
127677: PUSH
127678: LD_INT 19
127680: PUSH
127681: LD_INT 23
127683: PUSH
127684: LD_INT 19
127686: PUSH
127687: EMPTY
127688: LIST
127689: LIST
127690: LIST
127691: PUSH
127692: LD_VAR 0 1
127696: ARRAY
127697: ST_TO_ADDR
127698: GO 128024
127700: LD_INT 18
127702: DOUBLE
127703: EQUAL
127704: IFTRUE 127708
127706: GO 127719
127708: POP
// bc_type := b_ext_radar ; 19 :
127709: LD_ADDR_OWVAR 42
127713: PUSH
127714: LD_INT 20
127716: ST_TO_ADDR
127717: GO 128024
127719: LD_INT 19
127721: DOUBLE
127722: EQUAL
127723: IFTRUE 127727
127725: GO 127738
127727: POP
// bc_type := b_ext_radio ; 20 :
127728: LD_ADDR_OWVAR 42
127732: PUSH
127733: LD_INT 22
127735: ST_TO_ADDR
127736: GO 128024
127738: LD_INT 20
127740: DOUBLE
127741: EQUAL
127742: IFTRUE 127746
127744: GO 127757
127746: POP
// bc_type := b_ext_siberium ; 21 :
127747: LD_ADDR_OWVAR 42
127751: PUSH
127752: LD_INT 21
127754: ST_TO_ADDR
127755: GO 128024
127757: LD_INT 21
127759: DOUBLE
127760: EQUAL
127761: IFTRUE 127765
127763: GO 127776
127765: POP
// bc_type := b_ext_computer ; 22 :
127766: LD_ADDR_OWVAR 42
127770: PUSH
127771: LD_INT 24
127773: ST_TO_ADDR
127774: GO 128024
127776: LD_INT 22
127778: DOUBLE
127779: EQUAL
127780: IFTRUE 127784
127782: GO 127795
127784: POP
// bc_type := b_ext_track ; 23 :
127785: LD_ADDR_OWVAR 42
127789: PUSH
127790: LD_INT 16
127792: ST_TO_ADDR
127793: GO 128024
127795: LD_INT 23
127797: DOUBLE
127798: EQUAL
127799: IFTRUE 127803
127801: GO 127814
127803: POP
// bc_type := b_ext_laser ; 24 :
127804: LD_ADDR_OWVAR 42
127808: PUSH
127809: LD_INT 25
127811: ST_TO_ADDR
127812: GO 128024
127814: LD_INT 24
127816: DOUBLE
127817: EQUAL
127818: IFTRUE 127822
127820: GO 127833
127822: POP
// bc_type := b_control_tower ; 25 :
127823: LD_ADDR_OWVAR 42
127827: PUSH
127828: LD_INT 36
127830: ST_TO_ADDR
127831: GO 128024
127833: LD_INT 25
127835: DOUBLE
127836: EQUAL
127837: IFTRUE 127841
127839: GO 127852
127841: POP
// bc_type := b_breastwork ; 26 :
127842: LD_ADDR_OWVAR 42
127846: PUSH
127847: LD_INT 31
127849: ST_TO_ADDR
127850: GO 128024
127852: LD_INT 26
127854: DOUBLE
127855: EQUAL
127856: IFTRUE 127860
127858: GO 127871
127860: POP
// bc_type := b_bunker ; 27 :
127861: LD_ADDR_OWVAR 42
127865: PUSH
127866: LD_INT 32
127868: ST_TO_ADDR
127869: GO 128024
127871: LD_INT 27
127873: DOUBLE
127874: EQUAL
127875: IFTRUE 127879
127877: GO 127890
127879: POP
// bc_type := b_turret ; 28 :
127880: LD_ADDR_OWVAR 42
127884: PUSH
127885: LD_INT 33
127887: ST_TO_ADDR
127888: GO 128024
127890: LD_INT 28
127892: DOUBLE
127893: EQUAL
127894: IFTRUE 127898
127896: GO 127909
127898: POP
// bc_type := b_armoury ; 29 :
127899: LD_ADDR_OWVAR 42
127903: PUSH
127904: LD_INT 4
127906: ST_TO_ADDR
127907: GO 128024
127909: LD_INT 29
127911: DOUBLE
127912: EQUAL
127913: IFTRUE 127917
127915: GO 127928
127917: POP
// bc_type := b_barracks ; 30 :
127918: LD_ADDR_OWVAR 42
127922: PUSH
127923: LD_INT 5
127925: ST_TO_ADDR
127926: GO 128024
127928: LD_INT 30
127930: DOUBLE
127931: EQUAL
127932: IFTRUE 127936
127934: GO 127947
127936: POP
// bc_type := b_solar_power ; 31 :
127937: LD_ADDR_OWVAR 42
127941: PUSH
127942: LD_INT 27
127944: ST_TO_ADDR
127945: GO 128024
127947: LD_INT 31
127949: DOUBLE
127950: EQUAL
127951: IFTRUE 127955
127953: GO 127966
127955: POP
// bc_type := b_oil_power ; 32 :
127956: LD_ADDR_OWVAR 42
127960: PUSH
127961: LD_INT 26
127963: ST_TO_ADDR
127964: GO 128024
127966: LD_INT 32
127968: DOUBLE
127969: EQUAL
127970: IFTRUE 127974
127972: GO 127985
127974: POP
// bc_type := b_siberite_power ; 33 :
127975: LD_ADDR_OWVAR 42
127979: PUSH
127980: LD_INT 28
127982: ST_TO_ADDR
127983: GO 128024
127985: LD_INT 33
127987: DOUBLE
127988: EQUAL
127989: IFTRUE 127993
127991: GO 128004
127993: POP
// bc_type := b_oil_mine ; 34 :
127994: LD_ADDR_OWVAR 42
127998: PUSH
127999: LD_INT 29
128001: ST_TO_ADDR
128002: GO 128024
128004: LD_INT 34
128006: DOUBLE
128007: EQUAL
128008: IFTRUE 128012
128010: GO 128023
128012: POP
// bc_type := b_siberite_mine ; end ;
128013: LD_ADDR_OWVAR 42
128017: PUSH
128018: LD_INT 30
128020: ST_TO_ADDR
128021: GO 128024
128023: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
128024: LD_ADDR_VAR 0 8
128028: PUSH
128029: LD_VAR 0 5
128033: PPUSH
128034: LD_VAR 0 6
128038: PPUSH
128039: LD_VAR 0 3
128043: PPUSH
128044: CALL_OW 47
128048: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
128049: LD_OWVAR 42
128053: PUSH
128054: LD_INT 32
128056: PUSH
128057: LD_INT 33
128059: PUSH
128060: EMPTY
128061: LIST
128062: LIST
128063: IN
128064: IFFALSE 128080
// PlaceWeaponTurret ( b , weapon ) ;
128066: LD_VAR 0 8
128070: PPUSH
128071: LD_VAR 0 4
128075: PPUSH
128076: CALL_OW 431
// end ;
128080: LD_VAR 0 7
128084: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
128085: LD_INT 0
128087: PPUSH
128088: PPUSH
128089: PPUSH
128090: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
128091: LD_ADDR_VAR 0 4
128095: PUSH
128096: LD_INT 22
128098: PUSH
128099: LD_OWVAR 2
128103: PUSH
128104: EMPTY
128105: LIST
128106: LIST
128107: PUSH
128108: LD_INT 2
128110: PUSH
128111: LD_INT 30
128113: PUSH
128114: LD_INT 0
128116: PUSH
128117: EMPTY
128118: LIST
128119: LIST
128120: PUSH
128121: LD_INT 30
128123: PUSH
128124: LD_INT 1
128126: PUSH
128127: EMPTY
128128: LIST
128129: LIST
128130: PUSH
128131: EMPTY
128132: LIST
128133: LIST
128134: LIST
128135: PUSH
128136: EMPTY
128137: LIST
128138: LIST
128139: PPUSH
128140: CALL_OW 69
128144: ST_TO_ADDR
// if not tmp then
128145: LD_VAR 0 4
128149: NOT
128150: IFFALSE 128154
// exit ;
128152: GO 128213
// for i in tmp do
128154: LD_ADDR_VAR 0 2
128158: PUSH
128159: LD_VAR 0 4
128163: PUSH
128164: FOR_IN
128165: IFFALSE 128211
// for j = 1 to 3 do
128167: LD_ADDR_VAR 0 3
128171: PUSH
128172: DOUBLE
128173: LD_INT 1
128175: DEC
128176: ST_TO_ADDR
128177: LD_INT 3
128179: PUSH
128180: FOR_TO
128181: IFFALSE 128207
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
128183: LD_VAR 0 2
128187: PPUSH
128188: CALL_OW 274
128192: PPUSH
128193: LD_VAR 0 3
128197: PPUSH
128198: LD_INT 99999
128200: PPUSH
128201: CALL_OW 277
128205: GO 128180
128207: POP
128208: POP
128209: GO 128164
128211: POP
128212: POP
// end ;
128213: LD_VAR 0 1
128217: RET
// export function hHackSetLevel10 ; var i , j ; begin
128218: LD_INT 0
128220: PPUSH
128221: PPUSH
128222: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
128223: LD_ADDR_VAR 0 2
128227: PUSH
128228: LD_INT 21
128230: PUSH
128231: LD_INT 1
128233: PUSH
128234: EMPTY
128235: LIST
128236: LIST
128237: PPUSH
128238: CALL_OW 69
128242: PUSH
128243: FOR_IN
128244: IFFALSE 128296
// if IsSelected ( i ) then
128246: LD_VAR 0 2
128250: PPUSH
128251: CALL_OW 306
128255: IFFALSE 128294
// begin for j := 1 to 4 do
128257: LD_ADDR_VAR 0 3
128261: PUSH
128262: DOUBLE
128263: LD_INT 1
128265: DEC
128266: ST_TO_ADDR
128267: LD_INT 4
128269: PUSH
128270: FOR_TO
128271: IFFALSE 128292
// SetSkill ( i , j , 10 ) ;
128273: LD_VAR 0 2
128277: PPUSH
128278: LD_VAR 0 3
128282: PPUSH
128283: LD_INT 10
128285: PPUSH
128286: CALL_OW 237
128290: GO 128270
128292: POP
128293: POP
// end ;
128294: GO 128243
128296: POP
128297: POP
// end ;
128298: LD_VAR 0 1
128302: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
128303: LD_INT 0
128305: PPUSH
128306: PPUSH
128307: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
128308: LD_ADDR_VAR 0 2
128312: PUSH
128313: LD_INT 22
128315: PUSH
128316: LD_OWVAR 2
128320: PUSH
128321: EMPTY
128322: LIST
128323: LIST
128324: PUSH
128325: LD_INT 21
128327: PUSH
128328: LD_INT 1
128330: PUSH
128331: EMPTY
128332: LIST
128333: LIST
128334: PUSH
128335: EMPTY
128336: LIST
128337: LIST
128338: PPUSH
128339: CALL_OW 69
128343: PUSH
128344: FOR_IN
128345: IFFALSE 128386
// begin for j := 1 to 4 do
128347: LD_ADDR_VAR 0 3
128351: PUSH
128352: DOUBLE
128353: LD_INT 1
128355: DEC
128356: ST_TO_ADDR
128357: LD_INT 4
128359: PUSH
128360: FOR_TO
128361: IFFALSE 128382
// SetSkill ( i , j , 10 ) ;
128363: LD_VAR 0 2
128367: PPUSH
128368: LD_VAR 0 3
128372: PPUSH
128373: LD_INT 10
128375: PPUSH
128376: CALL_OW 237
128380: GO 128360
128382: POP
128383: POP
// end ;
128384: GO 128344
128386: POP
128387: POP
// end ;
128388: LD_VAR 0 1
128392: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
128393: LD_INT 0
128395: PPUSH
// uc_side := your_side ;
128396: LD_ADDR_OWVAR 20
128400: PUSH
128401: LD_OWVAR 2
128405: ST_TO_ADDR
// uc_nation := nation ;
128406: LD_ADDR_OWVAR 21
128410: PUSH
128411: LD_VAR 0 1
128415: ST_TO_ADDR
// InitHc ;
128416: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
128420: LD_INT 0
128422: PPUSH
128423: LD_VAR 0 2
128427: PPUSH
128428: LD_VAR 0 3
128432: PPUSH
128433: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
128437: LD_VAR 0 4
128441: PPUSH
128442: LD_VAR 0 5
128446: PPUSH
128447: CALL_OW 428
128451: PUSH
128452: LD_INT 0
128454: EQUAL
128455: IFFALSE 128479
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
128457: CALL_OW 44
128461: PPUSH
128462: LD_VAR 0 4
128466: PPUSH
128467: LD_VAR 0 5
128471: PPUSH
128472: LD_INT 1
128474: PPUSH
128475: CALL_OW 48
// end ;
128479: LD_VAR 0 6
128483: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
128484: LD_INT 0
128486: PPUSH
128487: PPUSH
// uc_side := your_side ;
128488: LD_ADDR_OWVAR 20
128492: PUSH
128493: LD_OWVAR 2
128497: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
128498: LD_VAR 0 1
128502: PUSH
128503: LD_INT 1
128505: PUSH
128506: LD_INT 2
128508: PUSH
128509: LD_INT 3
128511: PUSH
128512: LD_INT 4
128514: PUSH
128515: LD_INT 5
128517: PUSH
128518: EMPTY
128519: LIST
128520: LIST
128521: LIST
128522: LIST
128523: LIST
128524: IN
128525: IFFALSE 128537
// uc_nation := nation_american else
128527: LD_ADDR_OWVAR 21
128531: PUSH
128532: LD_INT 1
128534: ST_TO_ADDR
128535: GO 128580
// if chassis in [ 11 , 12 , 13 , 14 ] then
128537: LD_VAR 0 1
128541: PUSH
128542: LD_INT 11
128544: PUSH
128545: LD_INT 12
128547: PUSH
128548: LD_INT 13
128550: PUSH
128551: LD_INT 14
128553: PUSH
128554: EMPTY
128555: LIST
128556: LIST
128557: LIST
128558: LIST
128559: IN
128560: IFFALSE 128572
// uc_nation := nation_arabian else
128562: LD_ADDR_OWVAR 21
128566: PUSH
128567: LD_INT 2
128569: ST_TO_ADDR
128570: GO 128580
// uc_nation := nation_russian ;
128572: LD_ADDR_OWVAR 21
128576: PUSH
128577: LD_INT 3
128579: ST_TO_ADDR
// vc_chassis := chassis ;
128580: LD_ADDR_OWVAR 37
128584: PUSH
128585: LD_VAR 0 1
128589: ST_TO_ADDR
// vc_engine := engine ;
128590: LD_ADDR_OWVAR 39
128594: PUSH
128595: LD_VAR 0 2
128599: ST_TO_ADDR
// vc_control := control ;
128600: LD_ADDR_OWVAR 38
128604: PUSH
128605: LD_VAR 0 3
128609: ST_TO_ADDR
// vc_weapon := weapon ;
128610: LD_ADDR_OWVAR 40
128614: PUSH
128615: LD_VAR 0 4
128619: ST_TO_ADDR
// un := CreateVehicle ;
128620: LD_ADDR_VAR 0 8
128624: PUSH
128625: CALL_OW 45
128629: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
128630: LD_VAR 0 8
128634: PPUSH
128635: LD_INT 0
128637: PPUSH
128638: LD_INT 5
128640: PPUSH
128641: CALL_OW 12
128645: PPUSH
128646: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
128650: LD_VAR 0 8
128654: PPUSH
128655: LD_VAR 0 5
128659: PPUSH
128660: LD_VAR 0 6
128664: PPUSH
128665: LD_INT 1
128667: PPUSH
128668: CALL_OW 48
// end ;
128672: LD_VAR 0 7
128676: RET
// export hInvincible ; every 1 do
128677: GO 128679
128679: DISABLE
// hInvincible := [ ] ;
128680: LD_ADDR_EXP 205
128684: PUSH
128685: EMPTY
128686: ST_TO_ADDR
128687: END
// every 10 do var i ;
128688: GO 128690
128690: DISABLE
128691: LD_INT 0
128693: PPUSH
// begin enable ;
128694: ENABLE
// if not hInvincible then
128695: LD_EXP 205
128699: NOT
128700: IFFALSE 128704
// exit ;
128702: GO 128748
// for i in hInvincible do
128704: LD_ADDR_VAR 0 1
128708: PUSH
128709: LD_EXP 205
128713: PUSH
128714: FOR_IN
128715: IFFALSE 128746
// if GetLives ( i ) < 1000 then
128717: LD_VAR 0 1
128721: PPUSH
128722: CALL_OW 256
128726: PUSH
128727: LD_INT 1000
128729: LESS
128730: IFFALSE 128744
// SetLives ( i , 1000 ) ;
128732: LD_VAR 0 1
128736: PPUSH
128737: LD_INT 1000
128739: PPUSH
128740: CALL_OW 234
128744: GO 128714
128746: POP
128747: POP
// end ;
128748: PPOPN 1
128750: END
// export function hHackInvincible ; var i ; begin
128751: LD_INT 0
128753: PPUSH
128754: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
128755: LD_ADDR_VAR 0 2
128759: PUSH
128760: LD_INT 2
128762: PUSH
128763: LD_INT 21
128765: PUSH
128766: LD_INT 1
128768: PUSH
128769: EMPTY
128770: LIST
128771: LIST
128772: PUSH
128773: LD_INT 21
128775: PUSH
128776: LD_INT 2
128778: PUSH
128779: EMPTY
128780: LIST
128781: LIST
128782: PUSH
128783: EMPTY
128784: LIST
128785: LIST
128786: LIST
128787: PPUSH
128788: CALL_OW 69
128792: PUSH
128793: FOR_IN
128794: IFFALSE 128855
// if IsSelected ( i ) then
128796: LD_VAR 0 2
128800: PPUSH
128801: CALL_OW 306
128805: IFFALSE 128853
// begin if i in hInvincible then
128807: LD_VAR 0 2
128811: PUSH
128812: LD_EXP 205
128816: IN
128817: IFFALSE 128837
// hInvincible := hInvincible diff i else
128819: LD_ADDR_EXP 205
128823: PUSH
128824: LD_EXP 205
128828: PUSH
128829: LD_VAR 0 2
128833: DIFF
128834: ST_TO_ADDR
128835: GO 128853
// hInvincible := hInvincible union i ;
128837: LD_ADDR_EXP 205
128841: PUSH
128842: LD_EXP 205
128846: PUSH
128847: LD_VAR 0 2
128851: UNION
128852: ST_TO_ADDR
// end ;
128853: GO 128793
128855: POP
128856: POP
// end ;
128857: LD_VAR 0 1
128861: RET
// export function hHackInvisible ; var i , j ; begin
128862: LD_INT 0
128864: PPUSH
128865: PPUSH
128866: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
128867: LD_ADDR_VAR 0 2
128871: PUSH
128872: LD_INT 21
128874: PUSH
128875: LD_INT 1
128877: PUSH
128878: EMPTY
128879: LIST
128880: LIST
128881: PPUSH
128882: CALL_OW 69
128886: PUSH
128887: FOR_IN
128888: IFFALSE 128912
// if IsSelected ( i ) then
128890: LD_VAR 0 2
128894: PPUSH
128895: CALL_OW 306
128899: IFFALSE 128910
// ComForceInvisible ( i ) ;
128901: LD_VAR 0 2
128905: PPUSH
128906: CALL_OW 496
128910: GO 128887
128912: POP
128913: POP
// end ;
128914: LD_VAR 0 1
128918: RET
// export function hHackChangeYourSide ; begin
128919: LD_INT 0
128921: PPUSH
// if your_side = 8 then
128922: LD_OWVAR 2
128926: PUSH
128927: LD_INT 8
128929: EQUAL
128930: IFFALSE 128942
// your_side := 0 else
128932: LD_ADDR_OWVAR 2
128936: PUSH
128937: LD_INT 0
128939: ST_TO_ADDR
128940: GO 128956
// your_side := your_side + 1 ;
128942: LD_ADDR_OWVAR 2
128946: PUSH
128947: LD_OWVAR 2
128951: PUSH
128952: LD_INT 1
128954: PLUS
128955: ST_TO_ADDR
// end ;
128956: LD_VAR 0 1
128960: RET
// export function hHackChangeUnitSide ; var i , j ; begin
128961: LD_INT 0
128963: PPUSH
128964: PPUSH
128965: PPUSH
// for i in all_units do
128966: LD_ADDR_VAR 0 2
128970: PUSH
128971: LD_OWVAR 3
128975: PUSH
128976: FOR_IN
128977: IFFALSE 129055
// if IsSelected ( i ) then
128979: LD_VAR 0 2
128983: PPUSH
128984: CALL_OW 306
128988: IFFALSE 129053
// begin j := GetSide ( i ) ;
128990: LD_ADDR_VAR 0 3
128994: PUSH
128995: LD_VAR 0 2
128999: PPUSH
129000: CALL_OW 255
129004: ST_TO_ADDR
// if j = 8 then
129005: LD_VAR 0 3
129009: PUSH
129010: LD_INT 8
129012: EQUAL
129013: IFFALSE 129025
// j := 0 else
129015: LD_ADDR_VAR 0 3
129019: PUSH
129020: LD_INT 0
129022: ST_TO_ADDR
129023: GO 129039
// j := j + 1 ;
129025: LD_ADDR_VAR 0 3
129029: PUSH
129030: LD_VAR 0 3
129034: PUSH
129035: LD_INT 1
129037: PLUS
129038: ST_TO_ADDR
// SetSide ( i , j ) ;
129039: LD_VAR 0 2
129043: PPUSH
129044: LD_VAR 0 3
129048: PPUSH
129049: CALL_OW 235
// end ;
129053: GO 128976
129055: POP
129056: POP
// end ;
129057: LD_VAR 0 1
129061: RET
// export function hHackFog ; begin
129062: LD_INT 0
129064: PPUSH
// FogOff ( true ) ;
129065: LD_INT 1
129067: PPUSH
129068: CALL_OW 344
// end ;
129072: LD_VAR 0 1
129076: RET
// export function hHackTeleport ( unit , x , y ) ; begin
129077: LD_INT 0
129079: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
129080: LD_VAR 0 1
129084: PPUSH
129085: LD_VAR 0 2
129089: PPUSH
129090: LD_VAR 0 3
129094: PPUSH
129095: LD_INT 1
129097: PPUSH
129098: LD_INT 1
129100: PPUSH
129101: CALL_OW 483
// CenterOnXY ( x , y ) ;
129105: LD_VAR 0 2
129109: PPUSH
129110: LD_VAR 0 3
129114: PPUSH
129115: CALL_OW 84
// end ;
129119: LD_VAR 0 4
129123: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
129124: LD_INT 0
129126: PPUSH
129127: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
129128: LD_VAR 0 1
129132: NOT
129133: IFTRUE 129152
129135: PUSH
129136: LD_VAR 0 2
129140: PPUSH
129141: LD_VAR 0 3
129145: PPUSH
129146: CALL_OW 488
129150: NOT
129151: OR
129152: IFTRUE 129187
129154: PUSH
129155: LD_VAR 0 1
129159: PPUSH
129160: CALL_OW 266
129164: PUSH
129165: LD_INT 3
129167: NONEQUAL
129168: IFFALSE 129186
129170: PUSH
129171: LD_VAR 0 1
129175: PPUSH
129176: CALL_OW 247
129180: PUSH
129181: LD_INT 1
129183: EQUAL
129184: NOT
129185: AND
129186: OR
129187: IFFALSE 129191
// exit ;
129189: GO 129473
// if GetType ( factory ) = unit_human then
129191: LD_VAR 0 1
129195: PPUSH
129196: CALL_OW 247
129200: PUSH
129201: LD_INT 1
129203: EQUAL
129204: IFFALSE 129221
// factory := IsInUnit ( factory ) ;
129206: LD_ADDR_VAR 0 1
129210: PUSH
129211: LD_VAR 0 1
129215: PPUSH
129216: CALL_OW 310
129220: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
129221: LD_VAR 0 1
129225: PPUSH
129226: CALL_OW 266
129230: PUSH
129231: LD_INT 3
129233: NONEQUAL
129234: IFFALSE 129238
// exit ;
129236: GO 129473
// for i := 1 to Count ( factoryWaypoints ) do
129238: LD_ADDR_VAR 0 5
129242: PUSH
129243: DOUBLE
129244: LD_INT 1
129246: DEC
129247: ST_TO_ADDR
129248: LD_EXP 206
129252: PPUSH
129253: CALL 73163 0 1
129257: PUSH
129258: FOR_TO
129259: IFFALSE 129421
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
129261: LD_VAR 0 2
129265: PPUSH
129266: LD_VAR 0 3
129270: PPUSH
129271: CALL_OW 428
129275: PUSH
129276: LD_EXP 206
129280: PUSH
129281: LD_VAR 0 5
129285: ARRAY
129286: PUSH
129287: LD_INT 2
129289: ARRAY
129290: EQUAL
129291: IFFALSE 129323
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
129293: LD_ADDR_EXP 206
129297: PUSH
129298: LD_EXP 206
129302: PPUSH
129303: LD_VAR 0 5
129307: PPUSH
129308: CALL_OW 3
129312: ST_TO_ADDR
// UpdateFactoryWaypoints ;
129313: CALL 129478 0 0
// exit ;
129317: POP
129318: POP
129319: GO 129473
// end else
129321: GO 129419
// if factory = factoryWaypoints [ i ] [ 2 ] then
129323: LD_VAR 0 1
129327: PUSH
129328: LD_EXP 206
129332: PUSH
129333: LD_VAR 0 5
129337: ARRAY
129338: PUSH
129339: LD_INT 2
129341: ARRAY
129342: EQUAL
129343: IFFALSE 129419
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
129345: LD_ADDR_EXP 206
129349: PUSH
129350: LD_EXP 206
129354: PPUSH
129355: LD_VAR 0 5
129359: PPUSH
129360: CALL_OW 3
129364: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
129365: LD_ADDR_EXP 206
129369: PUSH
129370: LD_EXP 206
129374: PPUSH
129375: LD_VAR 0 1
129379: PPUSH
129380: CALL_OW 255
129384: PUSH
129385: LD_VAR 0 1
129389: PUSH
129390: LD_VAR 0 2
129394: PUSH
129395: LD_VAR 0 3
129399: PUSH
129400: EMPTY
129401: LIST
129402: LIST
129403: LIST
129404: LIST
129405: PPUSH
129406: CALL 109139 0 2
129410: ST_TO_ADDR
// UpdateFactoryWaypoints ;
129411: CALL 129478 0 0
// exit ;
129415: POP
129416: POP
129417: GO 129473
// end ; end ;
129419: GO 129258
129421: POP
129422: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
129423: LD_ADDR_EXP 206
129427: PUSH
129428: LD_EXP 206
129432: PPUSH
129433: LD_VAR 0 1
129437: PPUSH
129438: CALL_OW 255
129442: PUSH
129443: LD_VAR 0 1
129447: PUSH
129448: LD_VAR 0 2
129452: PUSH
129453: LD_VAR 0 3
129457: PUSH
129458: EMPTY
129459: LIST
129460: LIST
129461: LIST
129462: LIST
129463: PPUSH
129464: CALL 109139 0 2
129468: ST_TO_ADDR
// UpdateFactoryWaypoints ;
129469: CALL 129478 0 0
// end ;
129473: LD_VAR 0 4
129477: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
129478: LD_INT 0
129480: PPUSH
129481: PPUSH
129482: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
129483: LD_STRING resetFactoryWaypoint();
129485: PPUSH
129486: CALL_OW 559
// if factoryWaypoints then
129490: LD_EXP 206
129494: IFFALSE 129615
// begin list := factoryWaypoints ;
129496: LD_ADDR_VAR 0 3
129500: PUSH
129501: LD_EXP 206
129505: ST_TO_ADDR
// for i := 1 to list do
129506: LD_ADDR_VAR 0 2
129510: PUSH
129511: DOUBLE
129512: LD_INT 1
129514: DEC
129515: ST_TO_ADDR
129516: LD_VAR 0 3
129520: PUSH
129521: FOR_TO
129522: IFFALSE 129613
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
129524: LD_STRING setFactoryWaypointXY(
129526: PUSH
129527: LD_VAR 0 3
129531: PUSH
129532: LD_VAR 0 2
129536: ARRAY
129537: PUSH
129538: LD_INT 1
129540: ARRAY
129541: STR
129542: PUSH
129543: LD_STRING ,
129545: STR
129546: PUSH
129547: LD_VAR 0 3
129551: PUSH
129552: LD_VAR 0 2
129556: ARRAY
129557: PUSH
129558: LD_INT 2
129560: ARRAY
129561: STR
129562: PUSH
129563: LD_STRING ,
129565: STR
129566: PUSH
129567: LD_VAR 0 3
129571: PUSH
129572: LD_VAR 0 2
129576: ARRAY
129577: PUSH
129578: LD_INT 3
129580: ARRAY
129581: STR
129582: PUSH
129583: LD_STRING ,
129585: STR
129586: PUSH
129587: LD_VAR 0 3
129591: PUSH
129592: LD_VAR 0 2
129596: ARRAY
129597: PUSH
129598: LD_INT 4
129600: ARRAY
129601: STR
129602: PUSH
129603: LD_STRING )
129605: STR
129606: PPUSH
129607: CALL_OW 559
129611: GO 129521
129613: POP
129614: POP
// end ; end ;
129615: LD_VAR 0 1
129619: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
129620: LD_INT 0
129622: PPUSH
// if HexInfo ( x , y ) = warehouse then
129623: LD_VAR 0 2
129627: PPUSH
129628: LD_VAR 0 3
129632: PPUSH
129633: CALL_OW 428
129637: PUSH
129638: LD_VAR 0 1
129642: EQUAL
129643: IFFALSE 129670
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
129645: LD_ADDR_EXP 208
129649: PUSH
129650: LD_EXP 208
129654: PPUSH
129655: LD_VAR 0 1
129659: PPUSH
129660: LD_INT 0
129662: PPUSH
129663: CALL_OW 1
129667: ST_TO_ADDR
129668: GO 129721
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
129670: LD_ADDR_EXP 208
129674: PUSH
129675: LD_EXP 208
129679: PPUSH
129680: LD_VAR 0 1
129684: PPUSH
129685: LD_VAR 0 1
129689: PPUSH
129690: CALL_OW 255
129694: PUSH
129695: LD_VAR 0 1
129699: PUSH
129700: LD_VAR 0 2
129704: PUSH
129705: LD_VAR 0 3
129709: PUSH
129710: EMPTY
129711: LIST
129712: LIST
129713: LIST
129714: LIST
129715: PPUSH
129716: CALL_OW 1
129720: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
129721: CALL 129730 0 0
// end ;
129725: LD_VAR 0 4
129729: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
129730: LD_INT 0
129732: PPUSH
129733: PPUSH
129734: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
129735: LD_STRING resetWarehouseGatheringPoints();
129737: PPUSH
129738: CALL_OW 559
// if warehouseGatheringPoints then
129742: LD_EXP 208
129746: IFFALSE 129872
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
129748: LD_ADDR_VAR 0 3
129752: PUSH
129753: LD_EXP 208
129757: PPUSH
129758: CALL 113073 0 1
129762: ST_TO_ADDR
// for i := 1 to list do
129763: LD_ADDR_VAR 0 2
129767: PUSH
129768: DOUBLE
129769: LD_INT 1
129771: DEC
129772: ST_TO_ADDR
129773: LD_VAR 0 3
129777: PUSH
129778: FOR_TO
129779: IFFALSE 129870
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
129781: LD_STRING setWarehouseGatheringPointXY(
129783: PUSH
129784: LD_VAR 0 3
129788: PUSH
129789: LD_VAR 0 2
129793: ARRAY
129794: PUSH
129795: LD_INT 1
129797: ARRAY
129798: STR
129799: PUSH
129800: LD_STRING ,
129802: STR
129803: PUSH
129804: LD_VAR 0 3
129808: PUSH
129809: LD_VAR 0 2
129813: ARRAY
129814: PUSH
129815: LD_INT 2
129817: ARRAY
129818: STR
129819: PUSH
129820: LD_STRING ,
129822: STR
129823: PUSH
129824: LD_VAR 0 3
129828: PUSH
129829: LD_VAR 0 2
129833: ARRAY
129834: PUSH
129835: LD_INT 3
129837: ARRAY
129838: STR
129839: PUSH
129840: LD_STRING ,
129842: STR
129843: PUSH
129844: LD_VAR 0 3
129848: PUSH
129849: LD_VAR 0 2
129853: ARRAY
129854: PUSH
129855: LD_INT 4
129857: ARRAY
129858: STR
129859: PUSH
129860: LD_STRING )
129862: STR
129863: PPUSH
129864: CALL_OW 559
129868: GO 129778
129870: POP
129871: POP
// end ; end ;
129872: LD_VAR 0 1
129876: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
129877: LD_EXP 208
129881: IFFALSE 130576
129883: GO 129885
129885: DISABLE
129886: LD_INT 0
129888: PPUSH
129889: PPUSH
129890: PPUSH
129891: PPUSH
129892: PPUSH
129893: PPUSH
129894: PPUSH
129895: PPUSH
129896: PPUSH
// begin enable ;
129897: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
129898: LD_ADDR_VAR 0 3
129902: PUSH
129903: LD_EXP 208
129907: PPUSH
129908: CALL 113073 0 1
129912: ST_TO_ADDR
// if not list then
129913: LD_VAR 0 3
129917: NOT
129918: IFFALSE 129922
// exit ;
129920: GO 130576
// for i := 1 to list do
129922: LD_ADDR_VAR 0 1
129926: PUSH
129927: DOUBLE
129928: LD_INT 1
129930: DEC
129931: ST_TO_ADDR
129932: LD_VAR 0 3
129936: PUSH
129937: FOR_TO
129938: IFFALSE 130574
// begin depot := list [ i ] [ 2 ] ;
129940: LD_ADDR_VAR 0 8
129944: PUSH
129945: LD_VAR 0 3
129949: PUSH
129950: LD_VAR 0 1
129954: ARRAY
129955: PUSH
129956: LD_INT 2
129958: ARRAY
129959: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
129960: LD_ADDR_VAR 0 5
129964: PUSH
129965: LD_VAR 0 3
129969: PUSH
129970: LD_VAR 0 1
129974: ARRAY
129975: PUSH
129976: LD_INT 1
129978: ARRAY
129979: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
129980: LD_VAR 0 8
129984: PPUSH
129985: CALL_OW 301
129989: IFTRUE 130008
129991: PUSH
129992: LD_VAR 0 5
129996: PUSH
129997: LD_VAR 0 8
130001: PPUSH
130002: CALL_OW 255
130006: NONEQUAL
130007: OR
130008: IFFALSE 130037
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
130010: LD_ADDR_EXP 208
130014: PUSH
130015: LD_EXP 208
130019: PPUSH
130020: LD_VAR 0 8
130024: PPUSH
130025: LD_INT 0
130027: PPUSH
130028: CALL_OW 1
130032: ST_TO_ADDR
// exit ;
130033: POP
130034: POP
130035: GO 130576
// end ; x := list [ i ] [ 3 ] ;
130037: LD_ADDR_VAR 0 6
130041: PUSH
130042: LD_VAR 0 3
130046: PUSH
130047: LD_VAR 0 1
130051: ARRAY
130052: PUSH
130053: LD_INT 3
130055: ARRAY
130056: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
130057: LD_ADDR_VAR 0 7
130061: PUSH
130062: LD_VAR 0 3
130066: PUSH
130067: LD_VAR 0 1
130071: ARRAY
130072: PUSH
130073: LD_INT 4
130075: ARRAY
130076: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
130077: LD_ADDR_VAR 0 9
130081: PUSH
130082: LD_VAR 0 6
130086: PPUSH
130087: LD_VAR 0 7
130091: PPUSH
130092: LD_INT 16
130094: PPUSH
130095: CALL 111647 0 3
130099: ST_TO_ADDR
// if not cratesNearbyPoint then
130100: LD_VAR 0 9
130104: NOT
130105: IFFALSE 130111
// exit ;
130107: POP
130108: POP
130109: GO 130576
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
130111: LD_ADDR_VAR 0 4
130115: PUSH
130116: LD_INT 22
130118: PUSH
130119: LD_VAR 0 5
130123: PUSH
130124: EMPTY
130125: LIST
130126: LIST
130127: PUSH
130128: LD_INT 3
130130: PUSH
130131: LD_INT 60
130133: PUSH
130134: EMPTY
130135: LIST
130136: PUSH
130137: EMPTY
130138: LIST
130139: LIST
130140: PUSH
130141: LD_INT 91
130143: PUSH
130144: LD_VAR 0 8
130148: PUSH
130149: LD_INT 6
130151: PUSH
130152: EMPTY
130153: LIST
130154: LIST
130155: LIST
130156: PUSH
130157: LD_INT 2
130159: PUSH
130160: LD_INT 25
130162: PUSH
130163: LD_INT 2
130165: PUSH
130166: EMPTY
130167: LIST
130168: LIST
130169: PUSH
130170: LD_INT 25
130172: PUSH
130173: LD_INT 16
130175: PUSH
130176: EMPTY
130177: LIST
130178: LIST
130179: PUSH
130180: EMPTY
130181: LIST
130182: LIST
130183: LIST
130184: PUSH
130185: EMPTY
130186: LIST
130187: LIST
130188: LIST
130189: LIST
130190: PPUSH
130191: CALL_OW 69
130195: PUSH
130196: LD_VAR 0 8
130200: PPUSH
130201: CALL_OW 313
130205: PPUSH
130206: LD_INT 3
130208: PUSH
130209: LD_INT 60
130211: PUSH
130212: EMPTY
130213: LIST
130214: PUSH
130215: EMPTY
130216: LIST
130217: LIST
130218: PUSH
130219: LD_INT 2
130221: PUSH
130222: LD_INT 25
130224: PUSH
130225: LD_INT 2
130227: PUSH
130228: EMPTY
130229: LIST
130230: LIST
130231: PUSH
130232: LD_INT 25
130234: PUSH
130235: LD_INT 16
130237: PUSH
130238: EMPTY
130239: LIST
130240: LIST
130241: PUSH
130242: EMPTY
130243: LIST
130244: LIST
130245: LIST
130246: PUSH
130247: EMPTY
130248: LIST
130249: LIST
130250: PPUSH
130251: CALL_OW 72
130255: UNION
130256: ST_TO_ADDR
// if tmp then
130257: LD_VAR 0 4
130261: IFFALSE 130341
// begin tmp := ShrinkArray ( tmp , 3 ) ;
130263: LD_ADDR_VAR 0 4
130267: PUSH
130268: LD_VAR 0 4
130272: PPUSH
130273: LD_INT 3
130275: PPUSH
130276: CALL 109454 0 2
130280: ST_TO_ADDR
// for j in tmp do
130281: LD_ADDR_VAR 0 2
130285: PUSH
130286: LD_VAR 0 4
130290: PUSH
130291: FOR_IN
130292: IFFALSE 130335
// begin if IsInUnit ( j ) then
130294: LD_VAR 0 2
130298: PPUSH
130299: CALL_OW 310
130303: IFFALSE 130314
// ComExit ( j ) ;
130305: LD_VAR 0 2
130309: PPUSH
130310: CALL 109537 0 1
// AddComCollect ( j , x , y ) ;
130314: LD_VAR 0 2
130318: PPUSH
130319: LD_VAR 0 6
130323: PPUSH
130324: LD_VAR 0 7
130328: PPUSH
130329: CALL_OW 177
// end ;
130333: GO 130291
130335: POP
130336: POP
// exit ;
130337: POP
130338: POP
130339: GO 130576
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
130341: LD_ADDR_VAR 0 4
130345: PUSH
130346: LD_INT 22
130348: PUSH
130349: LD_VAR 0 5
130353: PUSH
130354: EMPTY
130355: LIST
130356: LIST
130357: PUSH
130358: LD_INT 91
130360: PUSH
130361: LD_VAR 0 8
130365: PUSH
130366: LD_INT 8
130368: PUSH
130369: EMPTY
130370: LIST
130371: LIST
130372: LIST
130373: PUSH
130374: LD_INT 2
130376: PUSH
130377: LD_INT 34
130379: PUSH
130380: LD_INT 12
130382: PUSH
130383: EMPTY
130384: LIST
130385: LIST
130386: PUSH
130387: LD_INT 34
130389: PUSH
130390: LD_INT 51
130392: PUSH
130393: EMPTY
130394: LIST
130395: LIST
130396: PUSH
130397: LD_INT 34
130399: PUSH
130400: LD_INT 32
130402: PUSH
130403: EMPTY
130404: LIST
130405: LIST
130406: PUSH
130407: LD_INT 34
130409: PUSH
130410: LD_INT 89
130412: PUSH
130413: EMPTY
130414: LIST
130415: LIST
130416: PUSH
130417: EMPTY
130418: LIST
130419: LIST
130420: LIST
130421: LIST
130422: LIST
130423: PUSH
130424: EMPTY
130425: LIST
130426: LIST
130427: LIST
130428: PPUSH
130429: CALL_OW 69
130433: ST_TO_ADDR
// if tmp then
130434: LD_VAR 0 4
130438: IFFALSE 130572
// begin for j in tmp do
130440: LD_ADDR_VAR 0 2
130444: PUSH
130445: LD_VAR 0 4
130449: PUSH
130450: FOR_IN
130451: IFFALSE 130570
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
130453: LD_VAR 0 2
130457: PPUSH
130458: CALL_OW 262
130462: PUSH
130463: LD_INT 3
130465: EQUAL
130466: IFTRUE 130483
130468: PUSH
130469: LD_VAR 0 2
130473: PPUSH
130474: CALL_OW 261
130478: PUSH
130479: LD_INT 20
130481: GREATER
130482: OR
130483: IFFALSE 130497
130485: PUSH
130486: LD_VAR 0 2
130490: PPUSH
130491: CALL_OW 314
130495: NOT
130496: AND
130497: IFFALSE 130527
130499: PUSH
130500: LD_VAR 0 2
130504: PPUSH
130505: CALL_OW 263
130509: PUSH
130510: LD_INT 1
130512: NONEQUAL
130513: IFTRUE 130526
130515: PUSH
130516: LD_VAR 0 2
130520: PPUSH
130521: CALL_OW 311
130525: OR
130526: AND
130527: IFFALSE 130568
// begin ComCollect ( j , x , y ) ;
130529: LD_VAR 0 2
130533: PPUSH
130534: LD_VAR 0 6
130538: PPUSH
130539: LD_VAR 0 7
130543: PPUSH
130544: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
130548: LD_VAR 0 2
130552: PPUSH
130553: LD_VAR 0 8
130557: PPUSH
130558: CALL_OW 172
// exit ;
130562: POP
130563: POP
130564: POP
130565: POP
130566: GO 130576
// end ;
130568: GO 130450
130570: POP
130571: POP
// end ; end ;
130572: GO 129937
130574: POP
130575: POP
// end ; end_of_file
130576: PPOPN 9
130578: END
// export function SOS_UnitDestroyed ( un ) ; begin
130579: LD_INT 0
130581: PPUSH
// ComRadiation ( un ) ;
130582: LD_VAR 0 1
130586: PPUSH
130587: CALL 131749 0 1
// end ;
130591: LD_VAR 0 2
130595: RET
// export function SOS_UnitKamikazed ( un ) ; begin
130596: LD_INT 0
130598: PPUSH
// ComRadiation ( un ) ;
130599: LD_VAR 0 1
130603: PPUSH
130604: CALL 131749 0 1
// end ;
130608: LD_VAR 0 2
130612: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
130613: LD_INT 0
130615: PPUSH
// end ;
130616: LD_VAR 0 4
130620: RET
// export function SOS_Command ( cmd ) ; begin
130621: LD_INT 0
130623: PPUSH
// end ;
130624: LD_VAR 0 2
130628: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
130629: LD_INT 0
130631: PPUSH
// end ;
130632: LD_VAR 0 6
130636: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex , weapon ; begin
130637: LD_INT 0
130639: PPUSH
130640: PPUSH
130641: PPUSH
130642: PPUSH
130643: PPUSH
// if not vehicle or not factory then
130644: LD_VAR 0 1
130648: NOT
130649: IFTRUE 130658
130651: PUSH
130652: LD_VAR 0 2
130656: NOT
130657: OR
130658: IFFALSE 130662
// exit ;
130660: GO 131324
// weapon := GetWeapon ( vehicle ) ;
130662: LD_ADDR_VAR 0 7
130666: PUSH
130667: LD_VAR 0 1
130671: PPUSH
130672: CALL_OW 264
130676: ST_TO_ADDR
// if weapon = ar_miner then
130677: LD_VAR 0 7
130681: PUSH
130682: LD_INT 81
130684: EQUAL
130685: IFFALSE 130742
// begin minersList := Replace ( minersList , minersList + 1 , vehicle ) ;
130687: LD_ADDR_EXP 217
130691: PUSH
130692: LD_EXP 217
130696: PPUSH
130697: LD_EXP 217
130701: PUSH
130702: LD_INT 1
130704: PLUS
130705: PPUSH
130706: LD_VAR 0 1
130710: PPUSH
130711: CALL_OW 1
130715: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
130716: LD_ADDR_EXP 218
130720: PUSH
130721: LD_EXP 218
130725: PPUSH
130726: LD_EXP 218
130730: PUSH
130731: LD_INT 1
130733: PLUS
130734: PPUSH
130735: EMPTY
130736: PPUSH
130737: CALL_OW 1
130741: ST_TO_ADDR
// end ; if not factoryWaypoints then
130742: LD_EXP 206
130746: NOT
130747: IFFALSE 130751
// exit ;
130749: GO 131324
// for i := 1 to Count ( factoryWaypoints ) do
130751: LD_ADDR_VAR 0 4
130755: PUSH
130756: DOUBLE
130757: LD_INT 1
130759: DEC
130760: ST_TO_ADDR
130761: LD_EXP 206
130765: PPUSH
130766: CALL 73163 0 1
130770: PUSH
130771: FOR_TO
130772: IFFALSE 131322
// if factoryWaypoints [ i ] [ 2 ] = factory then
130774: LD_EXP 206
130778: PUSH
130779: LD_VAR 0 4
130783: ARRAY
130784: PUSH
130785: LD_INT 2
130787: ARRAY
130788: PUSH
130789: LD_VAR 0 2
130793: EQUAL
130794: IFFALSE 131320
// begin if GetControl ( vehicle ) = control_manual then
130796: LD_VAR 0 1
130800: PPUSH
130801: CALL_OW 263
130805: PUSH
130806: LD_INT 1
130808: EQUAL
130809: IFFALSE 131173
// begin driver := IsDrivenBy ( vehicle ) ;
130811: LD_ADDR_VAR 0 5
130815: PUSH
130816: LD_VAR 0 1
130820: PPUSH
130821: CALL_OW 311
130825: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
130826: LD_VAR 0 5
130830: PUSH
130831: LD_EXP 207
130835: IN
130836: IFTRUE 130850
130838: PUSH
130839: LD_VAR 0 1
130843: PUSH
130844: LD_EXP 207
130848: IN
130849: OR
130850: IFFALSE 130856
// exit ;
130852: POP
130853: POP
130854: GO 131324
// if not HasTask ( driver ) then
130856: LD_VAR 0 5
130860: PPUSH
130861: CALL_OW 314
130865: NOT
130866: IFFALSE 131171
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
130868: LD_ADDR_EXP 207
130872: PUSH
130873: LD_EXP 207
130877: PPUSH
130878: LD_VAR 0 5
130882: PPUSH
130883: CALL 109139 0 2
130887: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
130888: LD_ADDR_EXP 207
130892: PUSH
130893: LD_EXP 207
130897: PPUSH
130898: LD_VAR 0 1
130902: PPUSH
130903: CALL 109139 0 2
130907: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
130908: LD_ADDR_VAR 0 6
130912: PUSH
130913: LD_EXP 206
130917: PUSH
130918: LD_VAR 0 4
130922: ARRAY
130923: PUSH
130924: LD_INT 3
130926: ARRAY
130927: PPUSH
130928: LD_EXP 206
130932: PUSH
130933: LD_VAR 0 4
130937: ARRAY
130938: PUSH
130939: LD_INT 4
130941: ARRAY
130942: PPUSH
130943: CALL_OW 428
130947: ST_TO_ADDR
// if hex then
130948: LD_VAR 0 6
130952: IFFALSE 130970
// ComMoveUnit ( driver , hex ) else
130954: LD_VAR 0 5
130958: PPUSH
130959: LD_VAR 0 6
130963: PPUSH
130964: CALL_OW 112
130968: GO 131054
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
130970: LD_VAR 0 1
130974: PPUSH
130975: LD_EXP 206
130979: PUSH
130980: LD_VAR 0 4
130984: ARRAY
130985: PUSH
130986: LD_INT 3
130988: ARRAY
130989: PPUSH
130990: LD_EXP 206
130994: PUSH
130995: LD_VAR 0 4
130999: ARRAY
131000: PUSH
131001: LD_INT 4
131003: ARRAY
131004: PPUSH
131005: CALL_OW 297
131009: PUSH
131010: LD_INT 0
131012: GREATER
131013: IFFALSE 131054
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
131015: LD_VAR 0 5
131019: PPUSH
131020: LD_EXP 206
131024: PUSH
131025: LD_VAR 0 4
131029: ARRAY
131030: PUSH
131031: LD_INT 3
131033: ARRAY
131034: PPUSH
131035: LD_EXP 206
131039: PUSH
131040: LD_VAR 0 4
131044: ARRAY
131045: PUSH
131046: LD_INT 4
131048: ARRAY
131049: PPUSH
131050: CALL_OW 111
// AddComExitVehicle ( driver ) ;
131054: LD_VAR 0 5
131058: PPUSH
131059: CALL_OW 181
// if Multiplayer then
131063: LD_OWVAR 4
131067: IFFALSE 131116
// begin repeat wait ( 10 ) ;
131069: LD_INT 10
131071: PPUSH
131072: CALL_OW 67
// until not IsInUnit ( driver ) ;
131076: LD_VAR 0 5
131080: PPUSH
131081: CALL_OW 310
131085: NOT
131086: IFFALSE 131069
// if not HasTask ( driver ) then
131088: LD_VAR 0 5
131092: PPUSH
131093: CALL_OW 314
131097: NOT
131098: IFFALSE 131114
// ComEnterUnit ( driver , factory ) ;
131100: LD_VAR 0 5
131104: PPUSH
131105: LD_VAR 0 2
131109: PPUSH
131110: CALL_OW 120
// end else
131114: GO 131130
// AddComEnterUnit ( driver , factory ) ;
131116: LD_VAR 0 5
131120: PPUSH
131121: LD_VAR 0 2
131125: PPUSH
131126: CALL_OW 180
// wait ( 0 0$1 ) ;
131130: LD_INT 35
131132: PPUSH
131133: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
131137: LD_ADDR_EXP 207
131141: PUSH
131142: LD_EXP 207
131146: PUSH
131147: LD_VAR 0 5
131151: DIFF
131152: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
131153: LD_ADDR_EXP 207
131157: PUSH
131158: LD_EXP 207
131162: PUSH
131163: LD_VAR 0 1
131167: DIFF
131168: ST_TO_ADDR
// break ;
131169: GO 131322
// end ; end else
131171: GO 131320
// if GetControl ( vehicle ) = control_remote then
131173: LD_VAR 0 1
131177: PPUSH
131178: CALL_OW 263
131182: PUSH
131183: LD_INT 2
131185: EQUAL
131186: IFFALSE 131272
// begin wait ( 0 0$2 ) ;
131188: LD_INT 70
131190: PPUSH
131191: CALL_OW 67
// repeat wait ( 10 ) ;
131195: LD_INT 10
131197: PPUSH
131198: CALL_OW 67
// Connect ( vehicle ) ;
131202: LD_VAR 0 1
131206: PPUSH
131207: CALL 79441 0 1
// until IsControledBy ( vehicle ) ;
131211: LD_VAR 0 1
131215: PPUSH
131216: CALL_OW 312
131220: IFFALSE 131195
// wait ( 10 ) ;
131222: LD_INT 10
131224: PPUSH
131225: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
131229: LD_VAR 0 1
131233: PPUSH
131234: LD_EXP 206
131238: PUSH
131239: LD_VAR 0 4
131243: ARRAY
131244: PUSH
131245: LD_INT 3
131247: ARRAY
131248: PPUSH
131249: LD_EXP 206
131253: PUSH
131254: LD_VAR 0 4
131258: ARRAY
131259: PUSH
131260: LD_INT 4
131262: ARRAY
131263: PPUSH
131264: CALL_OW 111
// break ;
131268: GO 131322
// end else
131270: GO 131320
// begin wait ( 0 0$3 ) ;
131272: LD_INT 105
131274: PPUSH
131275: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
131279: LD_VAR 0 1
131283: PPUSH
131284: LD_EXP 206
131288: PUSH
131289: LD_VAR 0 4
131293: ARRAY
131294: PUSH
131295: LD_INT 3
131297: ARRAY
131298: PPUSH
131299: LD_EXP 206
131303: PUSH
131304: LD_VAR 0 4
131308: ARRAY
131309: PUSH
131310: LD_INT 4
131312: ARRAY
131313: PPUSH
131314: CALL_OW 111
// break ;
131318: GO 131322
// end ; end ;
131320: GO 130771
131322: POP
131323: POP
// end ;
131324: LD_VAR 0 3
131328: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
131329: LD_INT 0
131331: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
131332: LD_VAR 0 1
131336: PUSH
131337: LD_INT 250
131339: EQUAL
131340: IFFALSE 131357
131342: PUSH
131343: LD_VAR 0 2
131347: PPUSH
131348: CALL_OW 264
131352: PUSH
131353: LD_INT 81
131355: EQUAL
131356: AND
131357: IFFALSE 131378
// MinerPlaceMine ( unit , x , y ) ;
131359: LD_VAR 0 2
131363: PPUSH
131364: LD_VAR 0 4
131368: PPUSH
131369: LD_VAR 0 5
131373: PPUSH
131374: CALL 134724 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
131378: LD_VAR 0 1
131382: PUSH
131383: LD_INT 251
131385: EQUAL
131386: IFFALSE 131403
131388: PUSH
131389: LD_VAR 0 2
131393: PPUSH
131394: CALL_OW 264
131398: PUSH
131399: LD_INT 81
131401: EQUAL
131402: AND
131403: IFFALSE 131424
// MinerDetonateMine ( unit , x , y ) ;
131405: LD_VAR 0 2
131409: PPUSH
131410: LD_VAR 0 4
131414: PPUSH
131415: LD_VAR 0 5
131419: PPUSH
131420: CALL 135131 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
131424: LD_VAR 0 1
131428: PUSH
131429: LD_INT 252
131431: EQUAL
131432: IFFALSE 131449
131434: PUSH
131435: LD_VAR 0 2
131439: PPUSH
131440: CALL_OW 264
131444: PUSH
131445: LD_INT 81
131447: EQUAL
131448: AND
131449: IFFALSE 131470
// MinerCreateMinefield ( unit , x , y ) ;
131451: LD_VAR 0 2
131455: PPUSH
131456: LD_VAR 0 4
131460: PPUSH
131461: LD_VAR 0 5
131465: PPUSH
131466: CALL 135363 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
131470: LD_VAR 0 1
131474: PUSH
131475: LD_INT 253
131477: EQUAL
131478: IFFALSE 131495
131480: PUSH
131481: LD_VAR 0 2
131485: PPUSH
131486: CALL_OW 257
131490: PUSH
131491: LD_INT 5
131493: EQUAL
131494: AND
131495: IFFALSE 131516
// ComBinocular ( unit , x , y ) ;
131497: LD_VAR 0 2
131501: PPUSH
131502: LD_VAR 0 4
131506: PPUSH
131507: LD_VAR 0 5
131511: PPUSH
131512: CALL 135738 0 3
// if selectedUnit then
131516: LD_VAR 0 3
131520: IFFALSE 131580
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
131522: LD_VAR 0 1
131526: PUSH
131527: LD_INT 254
131529: EQUAL
131530: IFFALSE 131547
131532: PUSH
131533: LD_VAR 0 2
131537: PPUSH
131538: CALL_OW 264
131542: PUSH
131543: LD_INT 99
131545: EQUAL
131546: AND
131547: IFFALSE 131564
131549: PUSH
131550: LD_VAR 0 3
131554: PPUSH
131555: CALL_OW 263
131559: PUSH
131560: LD_INT 3
131562: EQUAL
131563: AND
131564: IFFALSE 131580
// HackDestroyVehicle ( unit , selectedUnit ) ;
131566: LD_VAR 0 2
131570: PPUSH
131571: LD_VAR 0 3
131575: PPUSH
131576: CALL 133914 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
131580: LD_VAR 0 1
131584: PUSH
131585: LD_INT 255
131587: EQUAL
131588: IFFALSE 131612
131590: PUSH
131591: LD_VAR 0 2
131595: PPUSH
131596: CALL_OW 264
131600: PUSH
131601: LD_INT 14
131603: PUSH
131604: LD_INT 53
131606: PUSH
131607: EMPTY
131608: LIST
131609: LIST
131610: IN
131611: AND
131612: IFFALSE 131630
131614: PUSH
131615: LD_VAR 0 4
131619: PPUSH
131620: LD_VAR 0 5
131624: PPUSH
131625: CALL_OW 488
131629: AND
131630: IFFALSE 131654
// CutTreeXYR ( unit , x , y , 12 ) ;
131632: LD_VAR 0 2
131636: PPUSH
131637: LD_VAR 0 4
131641: PPUSH
131642: LD_VAR 0 5
131646: PPUSH
131647: LD_INT 12
131649: PPUSH
131650: CALL 131845 0 4
// if cmd = 256 then
131654: LD_VAR 0 1
131658: PUSH
131659: LD_INT 256
131661: EQUAL
131662: IFFALSE 131683
// SetFactoryWaypoint ( unit , x , y ) ;
131664: LD_VAR 0 2
131668: PPUSH
131669: LD_VAR 0 4
131673: PPUSH
131674: LD_VAR 0 5
131678: PPUSH
131679: CALL 129124 0 3
// if cmd = 257 then
131683: LD_VAR 0 1
131687: PUSH
131688: LD_INT 257
131690: EQUAL
131691: IFFALSE 131712
// SetWarehouseGatheringPoint ( unit , x , y ) ;
131693: LD_VAR 0 2
131697: PPUSH
131698: LD_VAR 0 4
131702: PPUSH
131703: LD_VAR 0 5
131707: PPUSH
131708: CALL 129620 0 3
// if cmd = 258 then
131712: LD_VAR 0 1
131716: PUSH
131717: LD_INT 258
131719: EQUAL
131720: IFFALSE 131744
// BurnTreeXYR ( unit , x , y , 8 ) ;
131722: LD_VAR 0 2
131726: PPUSH
131727: LD_VAR 0 4
131731: PPUSH
131732: LD_VAR 0 5
131736: PPUSH
131737: LD_INT 8
131739: PPUSH
131740: CALL 132267 0 4
// end ;
131744: LD_VAR 0 6
131748: RET
// export function ComRadiation ( un ) ; var eff ; begin
131749: LD_INT 0
131751: PPUSH
131752: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
131753: LD_VAR 0 1
131757: PPUSH
131758: CALL_OW 264
131762: PUSH
131763: LD_INT 91
131765: NONEQUAL
131766: IFFALSE 131770
// exit ;
131768: GO 131840
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
131770: LD_INT 68
131772: PPUSH
131773: LD_VAR 0 1
131777: PPUSH
131778: CALL_OW 255
131782: PPUSH
131783: CALL_OW 321
131787: PUSH
131788: LD_INT 2
131790: EQUAL
131791: IFFALSE 131803
// eff := 50 else
131793: LD_ADDR_VAR 0 3
131797: PUSH
131798: LD_INT 50
131800: ST_TO_ADDR
131801: GO 131811
// eff := 25 ;
131803: LD_ADDR_VAR 0 3
131807: PUSH
131808: LD_INT 25
131810: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
131811: LD_VAR 0 1
131815: PPUSH
131816: CALL_OW 250
131820: PPUSH
131821: LD_VAR 0 1
131825: PPUSH
131826: CALL_OW 251
131830: PPUSH
131831: LD_VAR 0 3
131835: PPUSH
131836: CALL_OW 495
// end ;
131840: LD_VAR 0 2
131844: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
131845: LD_INT 0
131847: PPUSH
131848: PPUSH
131849: PPUSH
131850: PPUSH
131851: PPUSH
131852: PPUSH
131853: PPUSH
131854: PPUSH
131855: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
131856: LD_VAR 0 1
131860: PPUSH
131861: CALL_OW 302
131865: NOT
131866: IFTRUE 131885
131868: PUSH
131869: LD_VAR 0 2
131873: PPUSH
131874: LD_VAR 0 3
131878: PPUSH
131879: CALL_OW 488
131883: NOT
131884: OR
131885: IFTRUE 131894
131887: PUSH
131888: LD_VAR 0 4
131892: NOT
131893: OR
131894: IFFALSE 131898
// exit ;
131896: GO 132262
// if Count ( GetTaskList ( bulldozer ) ) > 10 then
131898: LD_VAR 0 1
131902: PPUSH
131903: CALL_OW 437
131907: PPUSH
131908: CALL 73163 0 1
131912: PUSH
131913: LD_INT 10
131915: GREATER
131916: IFFALSE 131920
// exit ;
131918: GO 132262
// list := [ ] ;
131920: LD_ADDR_VAR 0 13
131924: PUSH
131925: EMPTY
131926: ST_TO_ADDR
// if x - r < 0 then
131927: LD_VAR 0 2
131931: PUSH
131932: LD_VAR 0 4
131936: MINUS
131937: PUSH
131938: LD_INT 0
131940: LESS
131941: IFFALSE 131953
// min_x := 0 else
131943: LD_ADDR_VAR 0 7
131947: PUSH
131948: LD_INT 0
131950: ST_TO_ADDR
131951: GO 131969
// min_x := x - r ;
131953: LD_ADDR_VAR 0 7
131957: PUSH
131958: LD_VAR 0 2
131962: PUSH
131963: LD_VAR 0 4
131967: MINUS
131968: ST_TO_ADDR
// if y - r < 0 then
131969: LD_VAR 0 3
131973: PUSH
131974: LD_VAR 0 4
131978: MINUS
131979: PUSH
131980: LD_INT 0
131982: LESS
131983: IFFALSE 131995
// min_y := 0 else
131985: LD_ADDR_VAR 0 8
131989: PUSH
131990: LD_INT 0
131992: ST_TO_ADDR
131993: GO 132011
// min_y := y - r ;
131995: LD_ADDR_VAR 0 8
131999: PUSH
132000: LD_VAR 0 3
132004: PUSH
132005: LD_VAR 0 4
132009: MINUS
132010: ST_TO_ADDR
// max_x := x + r ;
132011: LD_ADDR_VAR 0 9
132015: PUSH
132016: LD_VAR 0 2
132020: PUSH
132021: LD_VAR 0 4
132025: PLUS
132026: ST_TO_ADDR
// max_y := y + r ;
132027: LD_ADDR_VAR 0 10
132031: PUSH
132032: LD_VAR 0 3
132036: PUSH
132037: LD_VAR 0 4
132041: PLUS
132042: ST_TO_ADDR
// for _x = min_x to max_x do
132043: LD_ADDR_VAR 0 11
132047: PUSH
132048: DOUBLE
132049: LD_VAR 0 7
132053: DEC
132054: ST_TO_ADDR
132055: LD_VAR 0 9
132059: PUSH
132060: FOR_TO
132061: IFFALSE 132180
// for _y = min_y to max_y do
132063: LD_ADDR_VAR 0 12
132067: PUSH
132068: DOUBLE
132069: LD_VAR 0 8
132073: DEC
132074: ST_TO_ADDR
132075: LD_VAR 0 10
132079: PUSH
132080: FOR_TO
132081: IFFALSE 132176
// begin if not ValidHex ( _x , _y ) then
132083: LD_VAR 0 11
132087: PPUSH
132088: LD_VAR 0 12
132092: PPUSH
132093: CALL_OW 488
132097: NOT
132098: IFFALSE 132102
// continue ;
132100: GO 132080
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
132102: LD_VAR 0 11
132106: PPUSH
132107: LD_VAR 0 12
132111: PPUSH
132112: CALL_OW 351
132116: IFFALSE 132134
132118: PUSH
132119: LD_VAR 0 11
132123: PPUSH
132124: LD_VAR 0 12
132128: PPUSH
132129: CALL_OW 554
132133: AND
132134: IFFALSE 132174
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
132136: LD_ADDR_VAR 0 13
132140: PUSH
132141: LD_VAR 0 13
132145: PPUSH
132146: LD_VAR 0 13
132150: PUSH
132151: LD_INT 1
132153: PLUS
132154: PPUSH
132155: LD_VAR 0 11
132159: PUSH
132160: LD_VAR 0 12
132164: PUSH
132165: EMPTY
132166: LIST
132167: LIST
132168: PPUSH
132169: CALL_OW 2
132173: ST_TO_ADDR
// end ;
132174: GO 132080
132176: POP
132177: POP
132178: GO 132060
132180: POP
132181: POP
// if not list then
132182: LD_VAR 0 13
132186: NOT
132187: IFFALSE 132191
// exit ;
132189: GO 132262
// for i in list do
132191: LD_ADDR_VAR 0 6
132195: PUSH
132196: LD_VAR 0 13
132200: PUSH
132201: FOR_IN
132202: IFFALSE 132260
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
132204: LD_VAR 0 1
132208: PPUSH
132209: LD_STRING M
132211: PUSH
132212: LD_VAR 0 6
132216: PUSH
132217: LD_INT 1
132219: ARRAY
132220: PUSH
132221: LD_VAR 0 6
132225: PUSH
132226: LD_INT 2
132228: ARRAY
132229: PUSH
132230: LD_INT 0
132232: PUSH
132233: LD_INT 0
132235: PUSH
132236: LD_INT 0
132238: PUSH
132239: LD_INT 0
132241: PUSH
132242: EMPTY
132243: LIST
132244: LIST
132245: LIST
132246: LIST
132247: LIST
132248: LIST
132249: LIST
132250: PUSH
132251: EMPTY
132252: LIST
132253: PPUSH
132254: CALL_OW 447
132258: GO 132201
132260: POP
132261: POP
// end ;
132262: LD_VAR 0 5
132266: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
132267: LD_INT 0
132269: PPUSH
132270: PPUSH
132271: PPUSH
132272: PPUSH
132273: PPUSH
132274: PPUSH
132275: PPUSH
132276: PPUSH
132277: PPUSH
132278: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
132279: LD_VAR 0 1
132283: PPUSH
132284: CALL_OW 302
132288: NOT
132289: IFTRUE 132308
132291: PUSH
132292: LD_VAR 0 2
132296: PPUSH
132297: LD_VAR 0 3
132301: PPUSH
132302: CALL_OW 488
132306: NOT
132307: OR
132308: IFTRUE 132317
132310: PUSH
132311: LD_VAR 0 4
132315: NOT
132316: OR
132317: IFFALSE 132321
// exit ;
132319: GO 132860
// if Count ( GetTaskList ( flame ) ) > 10 then
132321: LD_VAR 0 1
132325: PPUSH
132326: CALL_OW 437
132330: PPUSH
132331: CALL 73163 0 1
132335: PUSH
132336: LD_INT 10
132338: GREATER
132339: IFFALSE 132343
// exit ;
132341: GO 132860
// list := [ ] ;
132343: LD_ADDR_VAR 0 13
132347: PUSH
132348: EMPTY
132349: ST_TO_ADDR
// if x - r < 0 then
132350: LD_VAR 0 2
132354: PUSH
132355: LD_VAR 0 4
132359: MINUS
132360: PUSH
132361: LD_INT 0
132363: LESS
132364: IFFALSE 132376
// min_x := 0 else
132366: LD_ADDR_VAR 0 7
132370: PUSH
132371: LD_INT 0
132373: ST_TO_ADDR
132374: GO 132392
// min_x := x - r ;
132376: LD_ADDR_VAR 0 7
132380: PUSH
132381: LD_VAR 0 2
132385: PUSH
132386: LD_VAR 0 4
132390: MINUS
132391: ST_TO_ADDR
// if y - r < 0 then
132392: LD_VAR 0 3
132396: PUSH
132397: LD_VAR 0 4
132401: MINUS
132402: PUSH
132403: LD_INT 0
132405: LESS
132406: IFFALSE 132418
// min_y := 0 else
132408: LD_ADDR_VAR 0 8
132412: PUSH
132413: LD_INT 0
132415: ST_TO_ADDR
132416: GO 132434
// min_y := y - r ;
132418: LD_ADDR_VAR 0 8
132422: PUSH
132423: LD_VAR 0 3
132427: PUSH
132428: LD_VAR 0 4
132432: MINUS
132433: ST_TO_ADDR
// max_x := x + r ;
132434: LD_ADDR_VAR 0 9
132438: PUSH
132439: LD_VAR 0 2
132443: PUSH
132444: LD_VAR 0 4
132448: PLUS
132449: ST_TO_ADDR
// max_y := y + r ;
132450: LD_ADDR_VAR 0 10
132454: PUSH
132455: LD_VAR 0 3
132459: PUSH
132460: LD_VAR 0 4
132464: PLUS
132465: ST_TO_ADDR
// for _x = min_x to max_x do
132466: LD_ADDR_VAR 0 11
132470: PUSH
132471: DOUBLE
132472: LD_VAR 0 7
132476: DEC
132477: ST_TO_ADDR
132478: LD_VAR 0 9
132482: PUSH
132483: FOR_TO
132484: IFFALSE 132603
// for _y = min_y to max_y do
132486: LD_ADDR_VAR 0 12
132490: PUSH
132491: DOUBLE
132492: LD_VAR 0 8
132496: DEC
132497: ST_TO_ADDR
132498: LD_VAR 0 10
132502: PUSH
132503: FOR_TO
132504: IFFALSE 132599
// begin if not ValidHex ( _x , _y ) then
132506: LD_VAR 0 11
132510: PPUSH
132511: LD_VAR 0 12
132515: PPUSH
132516: CALL_OW 488
132520: NOT
132521: IFFALSE 132525
// continue ;
132523: GO 132503
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
132525: LD_VAR 0 11
132529: PPUSH
132530: LD_VAR 0 12
132534: PPUSH
132535: CALL_OW 351
132539: IFFALSE 132557
132541: PUSH
132542: LD_VAR 0 11
132546: PPUSH
132547: LD_VAR 0 12
132551: PPUSH
132552: CALL_OW 554
132556: AND
132557: IFFALSE 132597
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
132559: LD_ADDR_VAR 0 13
132563: PUSH
132564: LD_VAR 0 13
132568: PPUSH
132569: LD_VAR 0 13
132573: PUSH
132574: LD_INT 1
132576: PLUS
132577: PPUSH
132578: LD_VAR 0 11
132582: PUSH
132583: LD_VAR 0 12
132587: PUSH
132588: EMPTY
132589: LIST
132590: LIST
132591: PPUSH
132592: CALL_OW 2
132596: ST_TO_ADDR
// end ;
132597: GO 132503
132599: POP
132600: POP
132601: GO 132483
132603: POP
132604: POP
// if not list then
132605: LD_VAR 0 13
132609: NOT
132610: IFFALSE 132614
// exit ;
132612: GO 132860
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
132614: LD_ADDR_VAR 0 13
132618: PUSH
132619: LD_VAR 0 1
132623: PPUSH
132624: LD_VAR 0 13
132628: PPUSH
132629: LD_INT 1
132631: PPUSH
132632: LD_INT 1
132634: PPUSH
132635: CALL 76569 0 4
132639: ST_TO_ADDR
// ComStop ( flame ) ;
132640: LD_VAR 0 1
132644: PPUSH
132645: CALL_OW 141
// for i in list do
132649: LD_ADDR_VAR 0 6
132653: PUSH
132654: LD_VAR 0 13
132658: PUSH
132659: FOR_IN
132660: IFFALSE 132691
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
132662: LD_VAR 0 1
132666: PPUSH
132667: LD_VAR 0 6
132671: PUSH
132672: LD_INT 1
132674: ARRAY
132675: PPUSH
132676: LD_VAR 0 6
132680: PUSH
132681: LD_INT 2
132683: ARRAY
132684: PPUSH
132685: CALL_OW 176
132689: GO 132659
132691: POP
132692: POP
// repeat wait ( 0 0$1 ) ;
132693: LD_INT 35
132695: PPUSH
132696: CALL_OW 67
// task := GetTaskList ( flame ) ;
132700: LD_ADDR_VAR 0 14
132704: PUSH
132705: LD_VAR 0 1
132709: PPUSH
132710: CALL_OW 437
132714: ST_TO_ADDR
// if not task then
132715: LD_VAR 0 14
132719: NOT
132720: IFFALSE 132724
// exit ;
132722: GO 132860
// if task [ 1 ] [ 1 ] <> | then
132724: LD_VAR 0 14
132728: PUSH
132729: LD_INT 1
132731: ARRAY
132732: PUSH
132733: LD_INT 1
132735: ARRAY
132736: PUSH
132737: LD_STRING |
132739: NONEQUAL
132740: IFFALSE 132744
// exit ;
132742: GO 132860
// _x := task [ 1 ] [ 2 ] ;
132744: LD_ADDR_VAR 0 11
132748: PUSH
132749: LD_VAR 0 14
132753: PUSH
132754: LD_INT 1
132756: ARRAY
132757: PUSH
132758: LD_INT 2
132760: ARRAY
132761: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
132762: LD_ADDR_VAR 0 12
132766: PUSH
132767: LD_VAR 0 14
132771: PUSH
132772: LD_INT 1
132774: ARRAY
132775: PUSH
132776: LD_INT 3
132778: ARRAY
132779: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
132780: LD_VAR 0 11
132784: PPUSH
132785: LD_VAR 0 12
132789: PPUSH
132790: CALL_OW 351
132794: NOT
132795: IFTRUE 132814
132797: PUSH
132798: LD_VAR 0 11
132802: PPUSH
132803: LD_VAR 0 12
132807: PPUSH
132808: CALL_OW 554
132812: NOT
132813: OR
132814: IFFALSE 132848
// begin task := Delete ( task , 1 ) ;
132816: LD_ADDR_VAR 0 14
132820: PUSH
132821: LD_VAR 0 14
132825: PPUSH
132826: LD_INT 1
132828: PPUSH
132829: CALL_OW 3
132833: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
132834: LD_VAR 0 1
132838: PPUSH
132839: LD_VAR 0 14
132843: PPUSH
132844: CALL_OW 446
// end ; until not HasTask ( flame ) ;
132848: LD_VAR 0 1
132852: PPUSH
132853: CALL_OW 314
132857: NOT
132858: IFFALSE 132693
// end ;
132860: LD_VAR 0 5
132864: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
132865: LD_EXP 210
132869: NOT
132870: IFFALSE 132920
132872: GO 132874
132874: DISABLE
// begin initHack := true ;
132875: LD_ADDR_EXP 210
132879: PUSH
132880: LD_INT 1
132882: ST_TO_ADDR
// hackTanks := [ ] ;
132883: LD_ADDR_EXP 211
132887: PUSH
132888: EMPTY
132889: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
132890: LD_ADDR_EXP 212
132894: PUSH
132895: EMPTY
132896: ST_TO_ADDR
// hackLimit := 3 ;
132897: LD_ADDR_EXP 213
132901: PUSH
132902: LD_INT 3
132904: ST_TO_ADDR
// hackDist := 12 ;
132905: LD_ADDR_EXP 214
132909: PUSH
132910: LD_INT 12
132912: ST_TO_ADDR
// hackCounter := [ ] ;
132913: LD_ADDR_EXP 215
132917: PUSH
132918: EMPTY
132919: ST_TO_ADDR
// end ;
132920: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
132921: LD_EXP 210
132925: IFFALSE 132943
132927: PUSH
132928: LD_INT 34
132930: PUSH
132931: LD_INT 99
132933: PUSH
132934: EMPTY
132935: LIST
132936: LIST
132937: PPUSH
132938: CALL_OW 69
132942: AND
132943: IFFALSE 133196
132945: GO 132947
132947: DISABLE
132948: LD_INT 0
132950: PPUSH
132951: PPUSH
// begin enable ;
132952: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
132953: LD_ADDR_VAR 0 1
132957: PUSH
132958: LD_INT 34
132960: PUSH
132961: LD_INT 99
132963: PUSH
132964: EMPTY
132965: LIST
132966: LIST
132967: PPUSH
132968: CALL_OW 69
132972: PUSH
132973: FOR_IN
132974: IFFALSE 133194
// begin if not i in hackTanks then
132976: LD_VAR 0 1
132980: PUSH
132981: LD_EXP 211
132985: IN
132986: NOT
132987: IFFALSE 133070
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
132989: LD_ADDR_EXP 211
132993: PUSH
132994: LD_EXP 211
132998: PPUSH
132999: LD_EXP 211
133003: PUSH
133004: LD_INT 1
133006: PLUS
133007: PPUSH
133008: LD_VAR 0 1
133012: PPUSH
133013: CALL_OW 1
133017: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
133018: LD_ADDR_EXP 212
133022: PUSH
133023: LD_EXP 212
133027: PPUSH
133028: LD_EXP 212
133032: PUSH
133033: LD_INT 1
133035: PLUS
133036: PPUSH
133037: EMPTY
133038: PPUSH
133039: CALL_OW 1
133043: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
133044: LD_ADDR_EXP 215
133048: PUSH
133049: LD_EXP 215
133053: PPUSH
133054: LD_EXP 215
133058: PUSH
133059: LD_INT 1
133061: PLUS
133062: PPUSH
133063: EMPTY
133064: PPUSH
133065: CALL_OW 1
133069: ST_TO_ADDR
// end ; if not IsOk ( i ) then
133070: LD_VAR 0 1
133074: PPUSH
133075: CALL_OW 302
133079: NOT
133080: IFFALSE 133093
// begin HackUnlinkAll ( i ) ;
133082: LD_VAR 0 1
133086: PPUSH
133087: CALL 133199 0 1
// continue ;
133091: GO 132973
// end ; HackCheckCapturedStatus ( i ) ;
133093: LD_VAR 0 1
133097: PPUSH
133098: CALL 133644 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
133102: LD_ADDR_VAR 0 2
133106: PUSH
133107: LD_INT 81
133109: PUSH
133110: LD_VAR 0 1
133114: PPUSH
133115: CALL_OW 255
133119: PUSH
133120: EMPTY
133121: LIST
133122: LIST
133123: PUSH
133124: LD_INT 33
133126: PUSH
133127: LD_INT 3
133129: PUSH
133130: EMPTY
133131: LIST
133132: LIST
133133: PUSH
133134: LD_INT 91
133136: PUSH
133137: LD_VAR 0 1
133141: PUSH
133142: LD_EXP 214
133146: PUSH
133147: EMPTY
133148: LIST
133149: LIST
133150: LIST
133151: PUSH
133152: LD_INT 50
133154: PUSH
133155: EMPTY
133156: LIST
133157: PUSH
133158: EMPTY
133159: LIST
133160: LIST
133161: LIST
133162: LIST
133163: PPUSH
133164: CALL_OW 69
133168: ST_TO_ADDR
// if not tmp then
133169: LD_VAR 0 2
133173: NOT
133174: IFFALSE 133178
// continue ;
133176: GO 132973
// HackLink ( i , tmp ) ;
133178: LD_VAR 0 1
133182: PPUSH
133183: LD_VAR 0 2
133187: PPUSH
133188: CALL 133335 0 2
// end ;
133192: GO 132973
133194: POP
133195: POP
// end ;
133196: PPOPN 2
133198: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
133199: LD_INT 0
133201: PPUSH
133202: PPUSH
133203: PPUSH
// if not hack in hackTanks then
133204: LD_VAR 0 1
133208: PUSH
133209: LD_EXP 211
133213: IN
133214: NOT
133215: IFFALSE 133219
// exit ;
133217: GO 133330
// index := GetElementIndex ( hackTanks , hack ) ;
133219: LD_ADDR_VAR 0 4
133223: PUSH
133224: LD_EXP 211
133228: PPUSH
133229: LD_VAR 0 1
133233: PPUSH
133234: CALL 75864 0 2
133238: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
133239: LD_EXP 212
133243: PUSH
133244: LD_VAR 0 4
133248: ARRAY
133249: IFFALSE 133330
// begin for i in hackTanksCaptured [ index ] do
133251: LD_ADDR_VAR 0 3
133255: PUSH
133256: LD_EXP 212
133260: PUSH
133261: LD_VAR 0 4
133265: ARRAY
133266: PUSH
133267: FOR_IN
133268: IFFALSE 133294
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
133270: LD_VAR 0 3
133274: PUSH
133275: LD_INT 1
133277: ARRAY
133278: PPUSH
133279: LD_VAR 0 3
133283: PUSH
133284: LD_INT 2
133286: ARRAY
133287: PPUSH
133288: CALL_OW 235
133292: GO 133267
133294: POP
133295: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
133296: LD_ADDR_EXP 212
133300: PUSH
133301: LD_EXP 212
133305: PPUSH
133306: LD_VAR 0 4
133310: PPUSH
133311: EMPTY
133312: PPUSH
133313: CALL_OW 1
133317: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
133318: LD_VAR 0 1
133322: PPUSH
133323: LD_INT 0
133325: PPUSH
133326: CALL_OW 505
// end ; end ;
133330: LD_VAR 0 2
133334: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
133335: LD_INT 0
133337: PPUSH
133338: PPUSH
133339: PPUSH
// if not hack in hackTanks or not vehicles then
133340: LD_VAR 0 1
133344: PUSH
133345: LD_EXP 211
133349: IN
133350: NOT
133351: IFTRUE 133360
133353: PUSH
133354: LD_VAR 0 2
133358: NOT
133359: OR
133360: IFFALSE 133364
// exit ;
133362: GO 133639
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
133364: LD_ADDR_VAR 0 2
133368: PUSH
133369: LD_VAR 0 1
133373: PPUSH
133374: LD_VAR 0 2
133378: PPUSH
133379: LD_INT 1
133381: PPUSH
133382: LD_INT 1
133384: PPUSH
133385: CALL 76516 0 4
133389: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
133390: LD_ADDR_VAR 0 5
133394: PUSH
133395: LD_EXP 211
133399: PPUSH
133400: LD_VAR 0 1
133404: PPUSH
133405: CALL 75864 0 2
133409: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
133410: LD_EXP 212
133414: PUSH
133415: LD_VAR 0 5
133419: ARRAY
133420: PUSH
133421: LD_EXP 213
133425: LESS
133426: IFFALSE 133615
// begin for i := 1 to vehicles do
133428: LD_ADDR_VAR 0 4
133432: PUSH
133433: DOUBLE
133434: LD_INT 1
133436: DEC
133437: ST_TO_ADDR
133438: LD_VAR 0 2
133442: PUSH
133443: FOR_TO
133444: IFFALSE 133613
// begin if hackTanksCaptured [ index ] = hackLimit then
133446: LD_EXP 212
133450: PUSH
133451: LD_VAR 0 5
133455: ARRAY
133456: PUSH
133457: LD_EXP 213
133461: EQUAL
133462: IFFALSE 133466
// break ;
133464: GO 133613
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
133466: LD_ADDR_EXP 215
133470: PUSH
133471: LD_EXP 215
133475: PPUSH
133476: LD_VAR 0 5
133480: PPUSH
133481: LD_EXP 215
133485: PUSH
133486: LD_VAR 0 5
133490: ARRAY
133491: PUSH
133492: LD_INT 1
133494: PLUS
133495: PPUSH
133496: CALL_OW 1
133500: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
133501: LD_ADDR_EXP 212
133505: PUSH
133506: LD_EXP 212
133510: PPUSH
133511: LD_VAR 0 5
133515: PUSH
133516: LD_EXP 212
133520: PUSH
133521: LD_VAR 0 5
133525: ARRAY
133526: PUSH
133527: LD_INT 1
133529: PLUS
133530: PUSH
133531: EMPTY
133532: LIST
133533: LIST
133534: PPUSH
133535: LD_VAR 0 2
133539: PUSH
133540: LD_VAR 0 4
133544: ARRAY
133545: PUSH
133546: LD_VAR 0 2
133550: PUSH
133551: LD_VAR 0 4
133555: ARRAY
133556: PPUSH
133557: CALL_OW 255
133561: PUSH
133562: EMPTY
133563: LIST
133564: LIST
133565: PPUSH
133566: CALL 76081 0 3
133570: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
133571: LD_VAR 0 2
133575: PUSH
133576: LD_VAR 0 4
133580: ARRAY
133581: PPUSH
133582: LD_VAR 0 1
133586: PPUSH
133587: CALL_OW 255
133591: PPUSH
133592: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
133596: LD_VAR 0 2
133600: PUSH
133601: LD_VAR 0 4
133605: ARRAY
133606: PPUSH
133607: CALL_OW 141
// end ;
133611: GO 133443
133613: POP
133614: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
133615: LD_VAR 0 1
133619: PPUSH
133620: LD_EXP 212
133624: PUSH
133625: LD_VAR 0 5
133629: ARRAY
133630: PUSH
133631: LD_INT 0
133633: PLUS
133634: PPUSH
133635: CALL_OW 505
// end ;
133639: LD_VAR 0 3
133643: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
133644: LD_INT 0
133646: PPUSH
133647: PPUSH
133648: PPUSH
133649: PPUSH
// if not hack in hackTanks then
133650: LD_VAR 0 1
133654: PUSH
133655: LD_EXP 211
133659: IN
133660: NOT
133661: IFFALSE 133665
// exit ;
133663: GO 133909
// index := GetElementIndex ( hackTanks , hack ) ;
133665: LD_ADDR_VAR 0 4
133669: PUSH
133670: LD_EXP 211
133674: PPUSH
133675: LD_VAR 0 1
133679: PPUSH
133680: CALL 75864 0 2
133684: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
133685: LD_ADDR_VAR 0 3
133689: PUSH
133690: DOUBLE
133691: LD_EXP 212
133695: PUSH
133696: LD_VAR 0 4
133700: ARRAY
133701: INC
133702: ST_TO_ADDR
133703: LD_INT 1
133705: PUSH
133706: FOR_DOWNTO
133707: IFFALSE 133883
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
133709: LD_ADDR_VAR 0 5
133713: PUSH
133714: LD_EXP 212
133718: PUSH
133719: LD_VAR 0 4
133723: ARRAY
133724: PUSH
133725: LD_VAR 0 3
133729: ARRAY
133730: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
133731: LD_VAR 0 5
133735: PUSH
133736: LD_INT 1
133738: ARRAY
133739: PPUSH
133740: CALL_OW 302
133744: NOT
133745: IFTRUE 133773
133747: PUSH
133748: LD_VAR 0 5
133752: PUSH
133753: LD_INT 1
133755: ARRAY
133756: PPUSH
133757: CALL_OW 255
133761: PUSH
133762: LD_VAR 0 1
133766: PPUSH
133767: CALL_OW 255
133771: NONEQUAL
133772: OR
133773: IFFALSE 133881
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
133775: LD_VAR 0 5
133779: PUSH
133780: LD_INT 1
133782: ARRAY
133783: PPUSH
133784: CALL_OW 305
133788: IFFALSE 133816
133790: PUSH
133791: LD_VAR 0 5
133795: PUSH
133796: LD_INT 1
133798: ARRAY
133799: PPUSH
133800: CALL_OW 255
133804: PUSH
133805: LD_VAR 0 1
133809: PPUSH
133810: CALL_OW 255
133814: EQUAL
133815: AND
133816: IFFALSE 133840
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
133818: LD_VAR 0 5
133822: PUSH
133823: LD_INT 1
133825: ARRAY
133826: PPUSH
133827: LD_VAR 0 5
133831: PUSH
133832: LD_INT 2
133834: ARRAY
133835: PPUSH
133836: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
133840: LD_ADDR_EXP 212
133844: PUSH
133845: LD_EXP 212
133849: PPUSH
133850: LD_VAR 0 4
133854: PPUSH
133855: LD_EXP 212
133859: PUSH
133860: LD_VAR 0 4
133864: ARRAY
133865: PPUSH
133866: LD_VAR 0 3
133870: PPUSH
133871: CALL_OW 3
133875: PPUSH
133876: CALL_OW 1
133880: ST_TO_ADDR
// end ; end ;
133881: GO 133706
133883: POP
133884: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
133885: LD_VAR 0 1
133889: PPUSH
133890: LD_EXP 212
133894: PUSH
133895: LD_VAR 0 4
133899: ARRAY
133900: PUSH
133901: LD_INT 0
133903: PLUS
133904: PPUSH
133905: CALL_OW 505
// end ;
133909: LD_VAR 0 2
133913: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
133914: LD_INT 0
133916: PPUSH
133917: PPUSH
133918: PPUSH
133919: PPUSH
// if not hack in hackTanks then
133920: LD_VAR 0 1
133924: PUSH
133925: LD_EXP 211
133929: IN
133930: NOT
133931: IFFALSE 133935
// exit ;
133933: GO 134020
// index := GetElementIndex ( hackTanks , hack ) ;
133935: LD_ADDR_VAR 0 5
133939: PUSH
133940: LD_EXP 211
133944: PPUSH
133945: LD_VAR 0 1
133949: PPUSH
133950: CALL 75864 0 2
133954: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
133955: LD_ADDR_VAR 0 4
133959: PUSH
133960: DOUBLE
133961: LD_INT 1
133963: DEC
133964: ST_TO_ADDR
133965: LD_EXP 212
133969: PUSH
133970: LD_VAR 0 5
133974: ARRAY
133975: PUSH
133976: FOR_TO
133977: IFFALSE 134018
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
133979: LD_EXP 212
133983: PUSH
133984: LD_VAR 0 5
133988: ARRAY
133989: PUSH
133990: LD_VAR 0 4
133994: ARRAY
133995: PUSH
133996: LD_INT 1
133998: ARRAY
133999: PUSH
134000: LD_VAR 0 2
134004: EQUAL
134005: IFFALSE 134016
// KillUnit ( vehicle ) ;
134007: LD_VAR 0 2
134011: PPUSH
134012: CALL_OW 66
134016: GO 133976
134018: POP
134019: POP
// end ;
134020: LD_VAR 0 3
134024: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do var i ;
134025: LD_EXP 216
134029: NOT
134030: IFFALSE 134163
134032: GO 134034
134034: DISABLE
134035: LD_INT 0
134037: PPUSH
// begin initMiner := true ;
134038: LD_ADDR_EXP 216
134042: PUSH
134043: LD_INT 1
134045: ST_TO_ADDR
// minersList := [ ] ;
134046: LD_ADDR_EXP 217
134050: PUSH
134051: EMPTY
134052: ST_TO_ADDR
// minerMinesList := [ ] ;
134053: LD_ADDR_EXP 218
134057: PUSH
134058: EMPTY
134059: ST_TO_ADDR
// minesLimitPerVehicle := 10 ;
134060: LD_ADDR_EXP 219
134064: PUSH
134065: LD_INT 10
134067: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
134068: LD_ADDR_VAR 0 1
134072: PUSH
134073: LD_INT 34
134075: PUSH
134076: LD_INT 81
134078: PUSH
134079: EMPTY
134080: LIST
134081: LIST
134082: PPUSH
134083: CALL_OW 69
134087: PUSH
134088: FOR_IN
134089: IFFALSE 134161
// begin if not i in minersList then
134091: LD_VAR 0 1
134095: PUSH
134096: LD_EXP 217
134100: IN
134101: NOT
134102: IFFALSE 134159
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
134104: LD_ADDR_EXP 217
134108: PUSH
134109: LD_EXP 217
134113: PPUSH
134114: LD_EXP 217
134118: PUSH
134119: LD_INT 1
134121: PLUS
134122: PPUSH
134123: LD_VAR 0 1
134127: PPUSH
134128: CALL_OW 1
134132: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
134133: LD_ADDR_EXP 218
134137: PUSH
134138: LD_EXP 218
134142: PPUSH
134143: LD_EXP 218
134147: PUSH
134148: LD_INT 1
134150: PLUS
134151: PPUSH
134152: EMPTY
134153: PPUSH
134154: CALL_OW 1
134158: ST_TO_ADDR
// end end ;
134159: GO 134088
134161: POP
134162: POP
// end ;
134163: PPOPN 1
134165: END
// every 0 0$1 trigger initMiner and ( Count ( minerMinesList ) or FilterAllUnits ( [ f_weapon , ar_miner ] ) ) do var i , j , side , tmp ;
134166: LD_EXP 216
134170: IFFALSE 134201
134172: PUSH
134173: LD_EXP 218
134177: PPUSH
134178: CALL 73163 0 1
134182: IFTRUE 134200
134184: PUSH
134185: LD_INT 34
134187: PUSH
134188: LD_INT 81
134190: PUSH
134191: EMPTY
134192: LIST
134193: LIST
134194: PPUSH
134195: CALL_OW 69
134199: OR
134200: AND
134201: IFFALSE 134721
134203: GO 134205
134205: DISABLE
134206: LD_INT 0
134208: PPUSH
134209: PPUSH
134210: PPUSH
134211: PPUSH
// begin enable ;
134212: ENABLE
// for i := minerMinesList downto 1 do
134213: LD_ADDR_VAR 0 1
134217: PUSH
134218: DOUBLE
134219: LD_EXP 218
134223: INC
134224: ST_TO_ADDR
134225: LD_INT 1
134227: PUSH
134228: FOR_DOWNTO
134229: IFFALSE 134719
// begin side := GetSide ( minersList [ i ] ) ;
134231: LD_ADDR_VAR 0 3
134235: PUSH
134236: LD_EXP 217
134240: PUSH
134241: LD_VAR 0 1
134245: ARRAY
134246: PPUSH
134247: CALL_OW 255
134251: ST_TO_ADDR
// if IsLive ( minersList [ i ] ) and side in [ your_side , 9 ] then
134252: LD_EXP 217
134256: PUSH
134257: LD_VAR 0 1
134261: ARRAY
134262: PPUSH
134263: CALL_OW 300
134267: IFFALSE 134288
134269: PUSH
134270: LD_VAR 0 3
134274: PUSH
134275: LD_OWVAR 2
134279: PUSH
134280: LD_INT 9
134282: PUSH
134283: EMPTY
134284: LIST
134285: LIST
134286: IN
134287: AND
134288: IFFALSE 134321
// SetUnitDisplayNumber ( minersList [ i ] , Count ( minerMinesList [ i ] ) ) ;
134290: LD_EXP 217
134294: PUSH
134295: LD_VAR 0 1
134299: ARRAY
134300: PPUSH
134301: LD_EXP 218
134305: PUSH
134306: LD_VAR 0 1
134310: ARRAY
134311: PPUSH
134312: CALL 73163 0 1
134316: PPUSH
134317: CALL_OW 505
// if not minerMinesList [ i ] then
134321: LD_EXP 218
134325: PUSH
134326: LD_VAR 0 1
134330: ARRAY
134331: NOT
134332: IFFALSE 134336
// continue ;
134334: GO 134228
// for j := minerMinesList [ i ] downto 1 do
134336: LD_ADDR_VAR 0 2
134340: PUSH
134341: DOUBLE
134342: LD_EXP 218
134346: PUSH
134347: LD_VAR 0 1
134351: ARRAY
134352: INC
134353: ST_TO_ADDR
134354: LD_INT 1
134356: PUSH
134357: FOR_DOWNTO
134358: IFFALSE 134715
// begin if IsDead ( minersList [ i ] ) or not IsPlaced ( minersList [ i ] ) then
134360: LD_EXP 217
134364: PUSH
134365: LD_VAR 0 1
134369: ARRAY
134370: PPUSH
134371: CALL_OW 301
134375: IFTRUE 134395
134377: PUSH
134378: LD_EXP 217
134382: PUSH
134383: LD_VAR 0 1
134387: ARRAY
134388: PPUSH
134389: CALL_OW 305
134393: NOT
134394: OR
134395: IFFALSE 134486
// begin RemoveMineXY ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
134397: LD_EXP 218
134401: PUSH
134402: LD_VAR 0 1
134406: ARRAY
134407: PUSH
134408: LD_VAR 0 2
134412: ARRAY
134413: PUSH
134414: LD_INT 1
134416: ARRAY
134417: PPUSH
134418: LD_EXP 218
134422: PUSH
134423: LD_VAR 0 1
134427: ARRAY
134428: PUSH
134429: LD_VAR 0 2
134433: ARRAY
134434: PUSH
134435: LD_INT 2
134437: ARRAY
134438: PPUSH
134439: CALL_OW 612
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
134443: LD_ADDR_EXP 218
134447: PUSH
134448: LD_EXP 218
134452: PPUSH
134453: LD_VAR 0 1
134457: PPUSH
134458: LD_EXP 218
134462: PUSH
134463: LD_VAR 0 1
134467: ARRAY
134468: PPUSH
134469: LD_VAR 0 2
134473: PPUSH
134474: CALL_OW 3
134478: PPUSH
134479: CALL_OW 1
134483: ST_TO_ADDR
// continue ;
134484: GO 134357
// end ; tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
134486: LD_ADDR_VAR 0 4
134490: PUSH
134491: LD_EXP 218
134495: PUSH
134496: LD_VAR 0 1
134500: ARRAY
134501: PUSH
134502: LD_VAR 0 2
134506: ARRAY
134507: PUSH
134508: LD_INT 1
134510: ARRAY
134511: PPUSH
134512: LD_EXP 218
134516: PUSH
134517: LD_VAR 0 1
134521: ARRAY
134522: PUSH
134523: LD_VAR 0 2
134527: ARRAY
134528: PUSH
134529: LD_INT 2
134531: ARRAY
134532: PPUSH
134533: CALL_OW 428
134537: ST_TO_ADDR
// if not tmp then
134538: LD_VAR 0 4
134542: NOT
134543: IFFALSE 134547
// continue ;
134545: GO 134357
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
134547: LD_VAR 0 4
134551: PUSH
134552: LD_INT 81
134554: PUSH
134555: LD_VAR 0 3
134559: PUSH
134560: EMPTY
134561: LIST
134562: LIST
134563: PPUSH
134564: CALL_OW 69
134568: IN
134569: IFFALSE 134619
134571: PUSH
134572: LD_EXP 218
134576: PUSH
134577: LD_VAR 0 1
134581: ARRAY
134582: PUSH
134583: LD_VAR 0 2
134587: ARRAY
134588: PUSH
134589: LD_INT 1
134591: ARRAY
134592: PPUSH
134593: LD_EXP 218
134597: PUSH
134598: LD_VAR 0 1
134602: ARRAY
134603: PUSH
134604: LD_VAR 0 2
134608: ARRAY
134609: PUSH
134610: LD_INT 2
134612: ARRAY
134613: PPUSH
134614: CALL_OW 458
134618: AND
134619: IFFALSE 134713
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
134621: LD_EXP 218
134625: PUSH
134626: LD_VAR 0 1
134630: ARRAY
134631: PUSH
134632: LD_VAR 0 2
134636: ARRAY
134637: PUSH
134638: LD_INT 1
134640: ARRAY
134641: PPUSH
134642: LD_EXP 218
134646: PUSH
134647: LD_VAR 0 1
134651: ARRAY
134652: PUSH
134653: LD_VAR 0 2
134657: ARRAY
134658: PUSH
134659: LD_INT 2
134661: ARRAY
134662: PPUSH
134663: LD_VAR 0 3
134667: PPUSH
134668: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
134672: LD_ADDR_EXP 218
134676: PUSH
134677: LD_EXP 218
134681: PPUSH
134682: LD_VAR 0 1
134686: PPUSH
134687: LD_EXP 218
134691: PUSH
134692: LD_VAR 0 1
134696: ARRAY
134697: PPUSH
134698: LD_VAR 0 2
134702: PPUSH
134703: CALL_OW 3
134707: PPUSH
134708: CALL_OW 1
134712: ST_TO_ADDR
// end ; end ;
134713: GO 134357
134715: POP
134716: POP
// end ;
134717: GO 134228
134719: POP
134720: POP
// end ;
134721: PPOPN 4
134723: END
// export function MinerPlaceMine ( unit , x , y ) ; var index , side , i ; begin
134724: LD_INT 0
134726: PPUSH
134727: PPUSH
134728: PPUSH
134729: PPUSH
// result := false ;
134730: LD_ADDR_VAR 0 4
134734: PUSH
134735: LD_INT 0
134737: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
134738: LD_VAR 0 1
134742: PPUSH
134743: CALL_OW 264
134747: PUSH
134748: LD_INT 81
134750: EQUAL
134751: NOT
134752: IFFALSE 134756
// exit ;
134754: GO 135126
// side := GetSide ( unit ) ;
134756: LD_ADDR_VAR 0 6
134760: PUSH
134761: LD_VAR 0 1
134765: PPUSH
134766: CALL_OW 255
134770: ST_TO_ADDR
// index := GetElementIndex ( minersList , unit ) ;
134771: LD_ADDR_VAR 0 5
134775: PUSH
134776: LD_EXP 217
134780: PPUSH
134781: LD_VAR 0 1
134785: PPUSH
134786: CALL 75864 0 2
134790: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
134791: LD_EXP 218
134795: PUSH
134796: LD_VAR 0 5
134800: ARRAY
134801: PUSH
134802: LD_EXP 219
134806: GREATEREQUAL
134807: IFFALSE 134811
// exit ;
134809: GO 135126
// ComMoveXY ( unit , x , y ) ;
134811: LD_VAR 0 1
134815: PPUSH
134816: LD_VAR 0 2
134820: PPUSH
134821: LD_VAR 0 3
134825: PPUSH
134826: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
134830: LD_INT 35
134832: PPUSH
134833: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
134837: LD_VAR 0 1
134841: PPUSH
134842: LD_VAR 0 2
134846: PPUSH
134847: LD_VAR 0 3
134851: PPUSH
134852: CALL 107920 0 3
134856: NOT
134857: IFFALSE 134870
134859: PUSH
134860: LD_VAR 0 1
134864: PPUSH
134865: CALL_OW 314
134869: AND
134870: IFFALSE 134874
// exit ;
134872: GO 135126
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
134874: LD_VAR 0 2
134878: PPUSH
134879: LD_VAR 0 3
134883: PPUSH
134884: CALL_OW 428
134888: PUSH
134889: LD_VAR 0 1
134893: EQUAL
134894: IFFALSE 134908
134896: PUSH
134897: LD_VAR 0 1
134901: PPUSH
134902: CALL_OW 314
134906: NOT
134907: AND
134908: IFFALSE 134830
// if MineAtPos ( x , y ) then
134910: LD_VAR 0 2
134914: PPUSH
134915: LD_VAR 0 3
134919: PPUSH
134920: CALL_OW 458
134924: IFFALSE 134928
// exit ;
134926: GO 135126
// if your_side = side then
134928: LD_OWVAR 2
134932: PUSH
134933: LD_VAR 0 6
134937: EQUAL
134938: IFFALSE 134957
// PlaySoundXY ( x , y , PlantMine ) ;
134940: LD_VAR 0 2
134944: PPUSH
134945: LD_VAR 0 3
134949: PPUSH
134950: LD_STRING PlantMine
134952: PPUSH
134953: CALL_OW 366
// repeat wait ( 1 ) ;
134957: LD_INT 1
134959: PPUSH
134960: CALL_OW 67
// until PlaceMine ( x , y , side , 0 ) ;
134964: LD_VAR 0 2
134968: PPUSH
134969: LD_VAR 0 3
134973: PPUSH
134974: LD_VAR 0 6
134978: PPUSH
134979: LD_INT 0
134981: PPUSH
134982: CALL_OW 454
134986: IFFALSE 134957
// if MineAtPos ( x , y ) then
134988: LD_VAR 0 2
134992: PPUSH
134993: LD_VAR 0 3
134997: PPUSH
134998: CALL_OW 458
135002: IFFALSE 135118
// begin for i in minerMinesList [ index ] do
135004: LD_ADDR_VAR 0 7
135008: PUSH
135009: LD_EXP 218
135013: PUSH
135014: LD_VAR 0 5
135018: ARRAY
135019: PUSH
135020: FOR_IN
135021: IFFALSE 135063
// if i [ 1 ] = x and i [ 2 ] = y then
135023: LD_VAR 0 7
135027: PUSH
135028: LD_INT 1
135030: ARRAY
135031: PUSH
135032: LD_VAR 0 2
135036: EQUAL
135037: IFFALSE 135055
135039: PUSH
135040: LD_VAR 0 7
135044: PUSH
135045: LD_INT 2
135047: ARRAY
135048: PUSH
135049: LD_VAR 0 3
135053: EQUAL
135054: AND
135055: IFFALSE 135061
// exit ;
135057: POP
135058: POP
135059: GO 135126
135061: GO 135020
135063: POP
135064: POP
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
135065: LD_ADDR_EXP 218
135069: PUSH
135070: LD_EXP 218
135074: PPUSH
135075: LD_VAR 0 5
135079: PUSH
135080: LD_EXP 218
135084: PUSH
135085: LD_VAR 0 5
135089: ARRAY
135090: PUSH
135091: LD_INT 1
135093: PLUS
135094: PUSH
135095: EMPTY
135096: LIST
135097: LIST
135098: PPUSH
135099: LD_VAR 0 2
135103: PUSH
135104: LD_VAR 0 3
135108: PUSH
135109: EMPTY
135110: LIST
135111: LIST
135112: PPUSH
135113: CALL 76081 0 3
135117: ST_TO_ADDR
// end ; result := true ;
135118: LD_ADDR_VAR 0 4
135122: PUSH
135123: LD_INT 1
135125: ST_TO_ADDR
// end ;
135126: LD_VAR 0 4
135130: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
135131: LD_INT 0
135133: PPUSH
135134: PPUSH
135135: PPUSH
// if not unit in minersList then
135136: LD_VAR 0 1
135140: PUSH
135141: LD_EXP 217
135145: IN
135146: NOT
135147: IFFALSE 135151
// exit ;
135149: GO 135358
// index := GetElementIndex ( minersList , unit ) ;
135151: LD_ADDR_VAR 0 6
135155: PUSH
135156: LD_EXP 217
135160: PPUSH
135161: LD_VAR 0 1
135165: PPUSH
135166: CALL 75864 0 2
135170: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
135171: LD_ADDR_VAR 0 5
135175: PUSH
135176: DOUBLE
135177: LD_EXP 218
135181: PUSH
135182: LD_VAR 0 6
135186: ARRAY
135187: INC
135188: ST_TO_ADDR
135189: LD_INT 1
135191: PUSH
135192: FOR_DOWNTO
135193: IFFALSE 135356
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
135195: LD_EXP 218
135199: PUSH
135200: LD_VAR 0 6
135204: ARRAY
135205: PUSH
135206: LD_VAR 0 5
135210: ARRAY
135211: PUSH
135212: LD_INT 1
135214: ARRAY
135215: PPUSH
135216: LD_EXP 218
135220: PUSH
135221: LD_VAR 0 6
135225: ARRAY
135226: PUSH
135227: LD_VAR 0 5
135231: ARRAY
135232: PUSH
135233: LD_INT 2
135235: ARRAY
135236: PPUSH
135237: LD_VAR 0 2
135241: PPUSH
135242: LD_VAR 0 3
135246: PPUSH
135247: CALL_OW 298
135251: PUSH
135252: LD_INT 6
135254: LESS
135255: IFFALSE 135354
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
135257: LD_EXP 218
135261: PUSH
135262: LD_VAR 0 6
135266: ARRAY
135267: PUSH
135268: LD_VAR 0 5
135272: ARRAY
135273: PUSH
135274: LD_INT 1
135276: ARRAY
135277: PPUSH
135278: LD_EXP 218
135282: PUSH
135283: LD_VAR 0 6
135287: ARRAY
135288: PUSH
135289: LD_VAR 0 5
135293: ARRAY
135294: PUSH
135295: LD_INT 2
135297: ARRAY
135298: PPUSH
135299: LD_VAR 0 1
135303: PPUSH
135304: CALL_OW 255
135308: PPUSH
135309: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
135313: LD_ADDR_EXP 218
135317: PUSH
135318: LD_EXP 218
135322: PPUSH
135323: LD_VAR 0 6
135327: PPUSH
135328: LD_EXP 218
135332: PUSH
135333: LD_VAR 0 6
135337: ARRAY
135338: PPUSH
135339: LD_VAR 0 5
135343: PPUSH
135344: CALL_OW 3
135348: PPUSH
135349: CALL_OW 1
135353: ST_TO_ADDR
// end ; end ;
135354: GO 135192
135356: POP
135357: POP
// end ;
135358: LD_VAR 0 4
135362: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
135363: LD_INT 0
135365: PPUSH
135366: PPUSH
135367: PPUSH
135368: PPUSH
135369: PPUSH
135370: PPUSH
135371: PPUSH
135372: PPUSH
135373: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
135374: LD_VAR 0 1
135378: PPUSH
135379: CALL_OW 264
135383: PUSH
135384: LD_INT 81
135386: EQUAL
135387: NOT
135388: IFTRUE 135403
135390: PUSH
135391: LD_VAR 0 1
135395: PUSH
135396: LD_EXP 217
135400: IN
135401: NOT
135402: OR
135403: IFFALSE 135407
// exit ;
135405: GO 135733
// index := GetElementIndex ( minersList , unit ) ;
135407: LD_ADDR_VAR 0 6
135411: PUSH
135412: LD_EXP 217
135416: PPUSH
135417: LD_VAR 0 1
135421: PPUSH
135422: CALL 75864 0 2
135426: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
135427: LD_ADDR_VAR 0 8
135431: PUSH
135432: LD_EXP 219
135436: PUSH
135437: LD_EXP 218
135441: PUSH
135442: LD_VAR 0 6
135446: ARRAY
135447: MINUS
135448: ST_TO_ADDR
// if not minesFreeAmount then
135449: LD_VAR 0 8
135453: NOT
135454: IFFALSE 135458
// exit ;
135456: GO 135733
// tmp := [ ] ;
135458: LD_ADDR_VAR 0 7
135462: PUSH
135463: EMPTY
135464: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
135465: LD_ADDR_VAR 0 5
135469: PUSH
135470: DOUBLE
135471: LD_INT 1
135473: DEC
135474: ST_TO_ADDR
135475: LD_VAR 0 8
135479: PUSH
135480: FOR_TO
135481: IFFALSE 135680
// begin _d := rand ( 0 , 5 ) ;
135483: LD_ADDR_VAR 0 11
135487: PUSH
135488: LD_INT 0
135490: PPUSH
135491: LD_INT 5
135493: PPUSH
135494: CALL_OW 12
135498: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
135499: LD_ADDR_VAR 0 12
135503: PUSH
135504: LD_INT 2
135506: PPUSH
135507: LD_INT 6
135509: PPUSH
135510: CALL_OW 12
135514: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
135515: LD_ADDR_VAR 0 9
135519: PUSH
135520: LD_VAR 0 2
135524: PPUSH
135525: LD_VAR 0 11
135529: PPUSH
135530: LD_VAR 0 12
135534: PPUSH
135535: CALL_OW 272
135539: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
135540: LD_ADDR_VAR 0 10
135544: PUSH
135545: LD_VAR 0 3
135549: PPUSH
135550: LD_VAR 0 11
135554: PPUSH
135555: LD_VAR 0 12
135559: PPUSH
135560: CALL_OW 273
135564: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
135565: LD_VAR 0 9
135569: PPUSH
135570: LD_VAR 0 10
135574: PPUSH
135575: CALL_OW 488
135579: IFFALSE 135603
135581: PUSH
135582: LD_VAR 0 9
135586: PUSH
135587: LD_VAR 0 10
135591: PUSH
135592: EMPTY
135593: LIST
135594: LIST
135595: PUSH
135596: LD_VAR 0 7
135600: IN
135601: NOT
135602: AND
135603: IFFALSE 135622
135605: PUSH
135606: LD_VAR 0 9
135610: PPUSH
135611: LD_VAR 0 10
135615: PPUSH
135616: CALL_OW 458
135620: NOT
135621: AND
135622: IFFALSE 135664
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
135624: LD_ADDR_VAR 0 7
135628: PUSH
135629: LD_VAR 0 7
135633: PPUSH
135634: LD_VAR 0 7
135638: PUSH
135639: LD_INT 1
135641: PLUS
135642: PPUSH
135643: LD_VAR 0 9
135647: PUSH
135648: LD_VAR 0 10
135652: PUSH
135653: EMPTY
135654: LIST
135655: LIST
135656: PPUSH
135657: CALL_OW 1
135661: ST_TO_ADDR
135662: GO 135678
// i := i - 1 ;
135664: LD_ADDR_VAR 0 5
135668: PUSH
135669: LD_VAR 0 5
135673: PUSH
135674: LD_INT 1
135676: MINUS
135677: ST_TO_ADDR
// end ;
135678: GO 135480
135680: POP
135681: POP
// for i in tmp do
135682: LD_ADDR_VAR 0 5
135686: PUSH
135687: LD_VAR 0 7
135691: PUSH
135692: FOR_IN
135693: IFFALSE 135731
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
135695: LD_VAR 0 1
135699: PPUSH
135700: LD_VAR 0 5
135704: PUSH
135705: LD_INT 1
135707: ARRAY
135708: PPUSH
135709: LD_VAR 0 5
135713: PUSH
135714: LD_INT 2
135716: ARRAY
135717: PPUSH
135718: CALL 134724 0 3
135722: NOT
135723: IFFALSE 135729
// exit ;
135725: POP
135726: POP
135727: GO 135733
135729: GO 135692
135731: POP
135732: POP
// end ;
135733: LD_VAR 0 4
135737: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
135738: LD_INT 0
135740: PPUSH
135741: PPUSH
135742: PPUSH
135743: PPUSH
135744: PPUSH
135745: PPUSH
135746: PPUSH
135747: PPUSH
135748: PPUSH
// if GetClass ( unit ) <> class_sniper then
135749: LD_VAR 0 1
135753: PPUSH
135754: CALL_OW 257
135758: PUSH
135759: LD_INT 5
135761: NONEQUAL
135762: IFFALSE 135766
// exit ;
135764: GO 136236
// dist := 8 ;
135766: LD_ADDR_VAR 0 5
135770: PUSH
135771: LD_INT 8
135773: ST_TO_ADDR
// viewRange := 12 ;
135774: LD_ADDR_VAR 0 8
135778: PUSH
135779: LD_INT 12
135781: ST_TO_ADDR
// side := GetSide ( unit ) ;
135782: LD_ADDR_VAR 0 6
135786: PUSH
135787: LD_VAR 0 1
135791: PPUSH
135792: CALL_OW 255
135796: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
135797: LD_INT 61
135799: PPUSH
135800: LD_VAR 0 6
135804: PPUSH
135805: CALL_OW 321
135809: PUSH
135810: LD_INT 2
135812: EQUAL
135813: IFFALSE 135823
// viewRange := 16 ;
135815: LD_ADDR_VAR 0 8
135819: PUSH
135820: LD_INT 16
135822: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
135823: LD_VAR 0 1
135827: PPUSH
135828: LD_VAR 0 2
135832: PPUSH
135833: LD_VAR 0 3
135837: PPUSH
135838: CALL_OW 297
135842: PUSH
135843: LD_VAR 0 5
135847: GREATER
135848: IFFALSE 135927
// begin ComMoveXY ( unit , x , y ) ;
135850: LD_VAR 0 1
135854: PPUSH
135855: LD_VAR 0 2
135859: PPUSH
135860: LD_VAR 0 3
135864: PPUSH
135865: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
135869: LD_INT 35
135871: PPUSH
135872: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
135876: LD_VAR 0 1
135880: PPUSH
135881: LD_VAR 0 2
135885: PPUSH
135886: LD_VAR 0 3
135890: PPUSH
135891: CALL 107920 0 3
135895: NOT
135896: IFFALSE 135900
// exit ;
135898: GO 136236
// until GetDistUnitXY ( unit , x , y ) < dist ;
135900: LD_VAR 0 1
135904: PPUSH
135905: LD_VAR 0 2
135909: PPUSH
135910: LD_VAR 0 3
135914: PPUSH
135915: CALL_OW 297
135919: PUSH
135920: LD_VAR 0 5
135924: LESS
135925: IFFALSE 135869
// end ; ComTurnXY ( unit , x , y ) ;
135927: LD_VAR 0 1
135931: PPUSH
135932: LD_VAR 0 2
135936: PPUSH
135937: LD_VAR 0 3
135941: PPUSH
135942: CALL_OW 118
// repeat if Multiplayer then
135946: LD_OWVAR 4
135950: IFFALSE 135961
// wait ( 35 ) else
135952: LD_INT 35
135954: PPUSH
135955: CALL_OW 67
135959: GO 135968
// wait ( 5 ) ;
135961: LD_INT 5
135963: PPUSH
135964: CALL_OW 67
// _d := GetDir ( unit ) ;
135968: LD_ADDR_VAR 0 11
135972: PUSH
135973: LD_VAR 0 1
135977: PPUSH
135978: CALL_OW 254
135982: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
135983: LD_ADDR_VAR 0 7
135987: PUSH
135988: LD_VAR 0 1
135992: PPUSH
135993: CALL_OW 250
135997: PPUSH
135998: LD_VAR 0 1
136002: PPUSH
136003: CALL_OW 251
136007: PPUSH
136008: LD_VAR 0 2
136012: PPUSH
136013: LD_VAR 0 3
136017: PPUSH
136018: CALL 110556 0 4
136022: ST_TO_ADDR
// until dir = _d ;
136023: LD_VAR 0 7
136027: PUSH
136028: LD_VAR 0 11
136032: EQUAL
136033: IFFALSE 135946
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
136035: LD_ADDR_VAR 0 9
136039: PUSH
136040: LD_VAR 0 1
136044: PPUSH
136045: CALL_OW 250
136049: PPUSH
136050: LD_VAR 0 7
136054: PPUSH
136055: LD_VAR 0 5
136059: PPUSH
136060: CALL_OW 272
136064: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
136065: LD_ADDR_VAR 0 10
136069: PUSH
136070: LD_VAR 0 1
136074: PPUSH
136075: CALL_OW 251
136079: PPUSH
136080: LD_VAR 0 7
136084: PPUSH
136085: LD_VAR 0 5
136089: PPUSH
136090: CALL_OW 273
136094: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
136095: LD_VAR 0 9
136099: PPUSH
136100: LD_VAR 0 10
136104: PPUSH
136105: CALL_OW 488
136109: NOT
136110: IFFALSE 136114
// exit ;
136112: GO 136236
// ComAnimCustom ( unit , 1 ) ;
136114: LD_VAR 0 1
136118: PPUSH
136119: LD_INT 1
136121: PPUSH
136122: CALL_OW 592
// p := 0 ;
136126: LD_ADDR_VAR 0 12
136130: PUSH
136131: LD_INT 0
136133: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
136134: LD_VAR 0 9
136138: PPUSH
136139: LD_VAR 0 10
136143: PPUSH
136144: LD_VAR 0 6
136148: PPUSH
136149: LD_VAR 0 8
136153: PPUSH
136154: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
136158: LD_INT 35
136160: PPUSH
136161: CALL_OW 67
// p := Inc ( p ) ;
136165: LD_ADDR_VAR 0 12
136169: PUSH
136170: LD_VAR 0 12
136174: PPUSH
136175: CALL 110512 0 1
136179: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
136180: LD_VAR 0 12
136184: PUSH
136185: LD_INT 3
136187: EQUAL
136188: IFTRUE 136202
136190: PUSH
136191: LD_VAR 0 1
136195: PPUSH
136196: CALL_OW 302
136200: NOT
136201: OR
136202: IFTRUE 136215
136204: PUSH
136205: LD_VAR 0 1
136209: PPUSH
136210: CALL_OW 301
136214: OR
136215: IFFALSE 136158
// RemoveSeeing ( _x , _y , side ) ;
136217: LD_VAR 0 9
136221: PPUSH
136222: LD_VAR 0 10
136226: PPUSH
136227: LD_VAR 0 6
136231: PPUSH
136232: CALL_OW 331
// end ;
136236: LD_VAR 0 4
136240: RET
// function RevealDetectorMine ( unit ) ; var side , r , x , y , min_x , min_y , max_x , max_y , _x , _y ; begin
136241: LD_INT 0
136243: PPUSH
136244: PPUSH
136245: PPUSH
136246: PPUSH
136247: PPUSH
136248: PPUSH
136249: PPUSH
136250: PPUSH
136251: PPUSH
136252: PPUSH
136253: PPUSH
// if not unit then
136254: LD_VAR 0 1
136258: NOT
136259: IFFALSE 136263
// exit ;
136261: GO 136534
// side := GetSide ( unit ) ;
136263: LD_ADDR_VAR 0 3
136267: PUSH
136268: LD_VAR 0 1
136272: PPUSH
136273: CALL_OW 255
136277: ST_TO_ADDR
// x := GetX ( unit ) ;
136278: LD_ADDR_VAR 0 5
136282: PUSH
136283: LD_VAR 0 1
136287: PPUSH
136288: CALL_OW 250
136292: ST_TO_ADDR
// y := GetY ( unit ) ;
136293: LD_ADDR_VAR 0 6
136297: PUSH
136298: LD_VAR 0 1
136302: PPUSH
136303: CALL_OW 251
136307: ST_TO_ADDR
// r := 8 ;
136308: LD_ADDR_VAR 0 4
136312: PUSH
136313: LD_INT 8
136315: ST_TO_ADDR
// if x - r < 0 then
136316: LD_VAR 0 5
136320: PUSH
136321: LD_VAR 0 4
136325: MINUS
136326: PUSH
136327: LD_INT 0
136329: LESS
136330: IFFALSE 136342
// min_x := 0 else
136332: LD_ADDR_VAR 0 7
136336: PUSH
136337: LD_INT 0
136339: ST_TO_ADDR
136340: GO 136358
// min_x := x - r ;
136342: LD_ADDR_VAR 0 7
136346: PUSH
136347: LD_VAR 0 5
136351: PUSH
136352: LD_VAR 0 4
136356: MINUS
136357: ST_TO_ADDR
// if y - r < 0 then
136358: LD_VAR 0 6
136362: PUSH
136363: LD_VAR 0 4
136367: MINUS
136368: PUSH
136369: LD_INT 0
136371: LESS
136372: IFFALSE 136384
// min_y := 0 else
136374: LD_ADDR_VAR 0 8
136378: PUSH
136379: LD_INT 0
136381: ST_TO_ADDR
136382: GO 136400
// min_y := y - r ;
136384: LD_ADDR_VAR 0 8
136388: PUSH
136389: LD_VAR 0 6
136393: PUSH
136394: LD_VAR 0 4
136398: MINUS
136399: ST_TO_ADDR
// max_x := x + r ;
136400: LD_ADDR_VAR 0 9
136404: PUSH
136405: LD_VAR 0 5
136409: PUSH
136410: LD_VAR 0 4
136414: PLUS
136415: ST_TO_ADDR
// max_y := y + r ;
136416: LD_ADDR_VAR 0 10
136420: PUSH
136421: LD_VAR 0 6
136425: PUSH
136426: LD_VAR 0 4
136430: PLUS
136431: ST_TO_ADDR
// for _x = min_x to max_x do
136432: LD_ADDR_VAR 0 11
136436: PUSH
136437: DOUBLE
136438: LD_VAR 0 7
136442: DEC
136443: ST_TO_ADDR
136444: LD_VAR 0 9
136448: PUSH
136449: FOR_TO
136450: IFFALSE 136532
// for _y = min_y to max_y do
136452: LD_ADDR_VAR 0 12
136456: PUSH
136457: DOUBLE
136458: LD_VAR 0 8
136462: DEC
136463: ST_TO_ADDR
136464: LD_VAR 0 10
136468: PUSH
136469: FOR_TO
136470: IFFALSE 136528
// begin if not ValidHex ( _x , _y ) then
136472: LD_VAR 0 11
136476: PPUSH
136477: LD_VAR 0 12
136481: PPUSH
136482: CALL_OW 488
136486: NOT
136487: IFFALSE 136491
// continue ;
136489: GO 136469
// if MineAtPos ( _x , _y ) then
136491: LD_VAR 0 11
136495: PPUSH
136496: LD_VAR 0 12
136500: PPUSH
136501: CALL_OW 458
136505: IFFALSE 136526
// ViewMineAtPos ( _x , _y , side ) ;
136507: LD_VAR 0 11
136511: PPUSH
136512: LD_VAR 0 12
136516: PPUSH
136517: LD_VAR 0 3
136521: PPUSH
136522: CALL_OW 457
// end ;
136526: GO 136469
136528: POP
136529: POP
136530: GO 136449
136532: POP
136533: POP
// end ;
136534: LD_VAR 0 2
136538: RET
// function DetectMine ( units ) ; var i , x , y , scaners , timer , side ; begin
136539: LD_INT 0
136541: PPUSH
136542: PPUSH
136543: PPUSH
136544: PPUSH
136545: PPUSH
136546: PPUSH
136547: PPUSH
// if not units then
136548: LD_VAR 0 1
136552: NOT
136553: IFFALSE 136557
// exit ;
136555: GO 137021
// scaners := [ ] ;
136557: LD_ADDR_VAR 0 6
136561: PUSH
136562: EMPTY
136563: ST_TO_ADDR
// for i in units do
136564: LD_ADDR_VAR 0 3
136568: PUSH
136569: LD_VAR 0 1
136573: PUSH
136574: FOR_IN
136575: IFFALSE 136732
// begin if GetWeapon ( i ) <> us_radar or not IsOk ( i ) or GetTag ( i ) = tMineDetector then
136577: LD_VAR 0 3
136581: PPUSH
136582: CALL_OW 264
136586: PUSH
136587: LD_INT 11
136589: NONEQUAL
136590: IFTRUE 136604
136592: PUSH
136593: LD_VAR 0 3
136597: PPUSH
136598: CALL_OW 302
136602: NOT
136603: OR
136604: IFTRUE 136621
136606: PUSH
136607: LD_VAR 0 3
136611: PPUSH
136612: CALL_OW 110
136616: PUSH
136617: LD_INT 502
136619: EQUAL
136620: OR
136621: IFFALSE 136625
// continue ;
136623: GO 136574
// ComStop ( i ) ;
136625: LD_VAR 0 3
136629: PPUSH
136630: CALL_OW 141
// x := GetX ( i ) ;
136634: LD_ADDR_VAR 0 4
136638: PUSH
136639: LD_VAR 0 3
136643: PPUSH
136644: CALL_OW 250
136648: ST_TO_ADDR
// y := GetY ( i ) ;
136649: LD_ADDR_VAR 0 5
136653: PUSH
136654: LD_VAR 0 3
136658: PPUSH
136659: CALL_OW 251
136663: ST_TO_ADDR
// if GetSide ( i ) = your_side then
136664: LD_VAR 0 3
136668: PPUSH
136669: CALL_OW 255
136673: PUSH
136674: LD_OWVAR 2
136678: EQUAL
136679: IFFALSE 136698
// PlaySoundXY ( x , y , mineDetector ) ;
136681: LD_VAR 0 4
136685: PPUSH
136686: LD_VAR 0 5
136690: PPUSH
136691: LD_STRING mineDetector
136693: PPUSH
136694: CALL_OW 366
// scaners := Join ( scaners , i ) ;
136698: LD_ADDR_VAR 0 6
136702: PUSH
136703: LD_VAR 0 6
136707: PPUSH
136708: LD_VAR 0 3
136712: PPUSH
136713: CALL 109139 0 2
136717: ST_TO_ADDR
// SetTag ( i , tMineDetector ) ;
136718: LD_VAR 0 3
136722: PPUSH
136723: LD_INT 502
136725: PPUSH
136726: CALL_OW 109
// end ;
136730: GO 136574
136732: POP
136733: POP
// if not scaners then
136734: LD_VAR 0 6
136738: NOT
136739: IFFALSE 136743
// exit ;
136741: GO 137021
// wait ( 3 ) ;
136743: LD_INT 3
136745: PPUSH
136746: CALL_OW 67
// timer := 6 ;
136750: LD_ADDR_VAR 0 7
136754: PUSH
136755: LD_INT 6
136757: ST_TO_ADDR
// repeat for i in scaners do
136758: LD_ADDR_VAR 0 3
136762: PUSH
136763: LD_VAR 0 6
136767: PUSH
136768: FOR_IN
136769: IFFALSE 136919
// begin side := GetSide ( i ) ;
136771: LD_ADDR_VAR 0 8
136775: PUSH
136776: LD_VAR 0 3
136780: PPUSH
136781: CALL_OW 255
136785: ST_TO_ADDR
// if not IsOk ( i ) or HasTask ( i ) or ( GetControl ( i ) = control_manual and not IsDrivenBy ( i ) ) then
136786: LD_VAR 0 3
136790: PPUSH
136791: CALL_OW 302
136795: NOT
136796: IFTRUE 136809
136798: PUSH
136799: LD_VAR 0 3
136803: PPUSH
136804: CALL_OW 314
136808: OR
136809: IFTRUE 136840
136811: PUSH
136812: LD_VAR 0 3
136816: PPUSH
136817: CALL_OW 263
136821: PUSH
136822: LD_INT 1
136824: EQUAL
136825: IFFALSE 136839
136827: PUSH
136828: LD_VAR 0 3
136832: PPUSH
136833: CALL_OW 311
136837: NOT
136838: AND
136839: OR
136840: IFFALSE 136884
// begin SetUnitDisplayNumber ( i , 0 ) ;
136842: LD_VAR 0 3
136846: PPUSH
136847: LD_INT 0
136849: PPUSH
136850: CALL_OW 505
// SetTag ( i , 0 ) ;
136854: LD_VAR 0 3
136858: PPUSH
136859: LD_INT 0
136861: PPUSH
136862: CALL_OW 109
// scaners := scaners diff i ;
136866: LD_ADDR_VAR 0 6
136870: PUSH
136871: LD_VAR 0 6
136875: PUSH
136876: LD_VAR 0 3
136880: DIFF
136881: ST_TO_ADDR
// continue ;
136882: GO 136768
// end ; if side in [ your_side , 9 ] then
136884: LD_VAR 0 8
136888: PUSH
136889: LD_OWVAR 2
136893: PUSH
136894: LD_INT 9
136896: PUSH
136897: EMPTY
136898: LIST
136899: LIST
136900: IN
136901: IFFALSE 136917
// SetUnitDisplayNumber ( i , timer ) ;
136903: LD_VAR 0 3
136907: PPUSH
136908: LD_VAR 0 7
136912: PPUSH
136913: CALL_OW 505
// end ;
136917: GO 136768
136919: POP
136920: POP
// if not scaners then
136921: LD_VAR 0 6
136925: NOT
136926: IFFALSE 136930
// exit ;
136928: GO 137021
// timer := Dec ( timer ) ;
136930: LD_ADDR_VAR 0 7
136934: PUSH
136935: LD_VAR 0 7
136939: PPUSH
136940: CALL 110534 0 1
136944: ST_TO_ADDR
// wait ( 0 0$1 ) ;
136945: LD_INT 35
136947: PPUSH
136948: CALL_OW 67
// until timer = 0 ;
136952: LD_VAR 0 7
136956: PUSH
136957: LD_INT 0
136959: EQUAL
136960: IFFALSE 136758
// if not scaners then
136962: LD_VAR 0 6
136966: NOT
136967: IFFALSE 136971
// exit ;
136969: GO 137021
// for i in scaners do
136971: LD_ADDR_VAR 0 3
136975: PUSH
136976: LD_VAR 0 6
136980: PUSH
136981: FOR_IN
136982: IFFALSE 137019
// begin SetUnitDisplayNumber ( i , 0 ) ;
136984: LD_VAR 0 3
136988: PPUSH
136989: LD_INT 0
136991: PPUSH
136992: CALL_OW 505
// SetTag ( i , 0 ) ;
136996: LD_VAR 0 3
137000: PPUSH
137001: LD_INT 0
137003: PPUSH
137004: CALL_OW 109
// RevealDetectorMine ( i ) ;
137008: LD_VAR 0 3
137012: PPUSH
137013: CALL 136241 0 1
// end ;
137017: GO 136981
137019: POP
137020: POP
// end ;
137021: LD_VAR 0 2
137025: RET
// export function SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ; begin
137026: LD_INT 0
137028: PPUSH
// if p1 = mine_detector_mode then
137029: LD_VAR 0 2
137033: PUSH
137034: LD_INT 103
137036: EQUAL
137037: IFFALSE 137048
// DetectMine ( units ) ;
137039: LD_VAR 0 1
137043: PPUSH
137044: CALL 136539 0 1
// end ; end_of_file
137048: LD_VAR 0 7
137052: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
137053: LD_INT 0
137055: PPUSH
137056: PPUSH
137057: PPUSH
137058: PPUSH
137059: PPUSH
137060: PPUSH
137061: PPUSH
137062: PPUSH
137063: PPUSH
137064: PPUSH
137065: PPUSH
137066: PPUSH
137067: PPUSH
137068: PPUSH
137069: PPUSH
137070: PPUSH
137071: PPUSH
137072: PPUSH
137073: PPUSH
137074: PPUSH
137075: PPUSH
137076: PPUSH
137077: PPUSH
137078: PPUSH
137079: PPUSH
137080: PPUSH
137081: PPUSH
137082: PPUSH
137083: PPUSH
137084: PPUSH
137085: PPUSH
137086: PPUSH
137087: PPUSH
137088: PPUSH
// if not list then
137089: LD_VAR 0 1
137093: NOT
137094: IFFALSE 137098
// exit ;
137096: GO 141817
// base := list [ 1 ] ;
137098: LD_ADDR_VAR 0 3
137102: PUSH
137103: LD_VAR 0 1
137107: PUSH
137108: LD_INT 1
137110: ARRAY
137111: ST_TO_ADDR
// group := list [ 2 ] ;
137112: LD_ADDR_VAR 0 4
137116: PUSH
137117: LD_VAR 0 1
137121: PUSH
137122: LD_INT 2
137124: ARRAY
137125: ST_TO_ADDR
// path := list [ 3 ] ;
137126: LD_ADDR_VAR 0 5
137130: PUSH
137131: LD_VAR 0 1
137135: PUSH
137136: LD_INT 3
137138: ARRAY
137139: ST_TO_ADDR
// flags := list [ 4 ] ;
137140: LD_ADDR_VAR 0 6
137144: PUSH
137145: LD_VAR 0 1
137149: PUSH
137150: LD_INT 4
137152: ARRAY
137153: ST_TO_ADDR
// mined := [ ] ;
137154: LD_ADDR_VAR 0 27
137158: PUSH
137159: EMPTY
137160: ST_TO_ADDR
// bombed := [ ] ;
137161: LD_ADDR_VAR 0 28
137165: PUSH
137166: EMPTY
137167: ST_TO_ADDR
// healers := [ ] ;
137168: LD_ADDR_VAR 0 31
137172: PUSH
137173: EMPTY
137174: ST_TO_ADDR
// to_heal := [ ] ;
137175: LD_ADDR_VAR 0 30
137179: PUSH
137180: EMPTY
137181: ST_TO_ADDR
// repairs := [ ] ;
137182: LD_ADDR_VAR 0 33
137186: PUSH
137187: EMPTY
137188: ST_TO_ADDR
// to_repair := [ ] ;
137189: LD_ADDR_VAR 0 32
137193: PUSH
137194: EMPTY
137195: ST_TO_ADDR
// if not group or not path then
137196: LD_VAR 0 4
137200: NOT
137201: IFTRUE 137210
137203: PUSH
137204: LD_VAR 0 5
137208: NOT
137209: OR
137210: IFFALSE 137214
// exit ;
137212: GO 141817
// side := GetSide ( group [ 1 ] ) ;
137214: LD_ADDR_VAR 0 35
137218: PUSH
137219: LD_VAR 0 4
137223: PUSH
137224: LD_INT 1
137226: ARRAY
137227: PPUSH
137228: CALL_OW 255
137232: ST_TO_ADDR
// if flags then
137233: LD_VAR 0 6
137237: IFFALSE 137381
// begin f_ignore_area := flags [ 1 ] ;
137239: LD_ADDR_VAR 0 17
137243: PUSH
137244: LD_VAR 0 6
137248: PUSH
137249: LD_INT 1
137251: ARRAY
137252: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
137253: LD_ADDR_VAR 0 18
137257: PUSH
137258: LD_VAR 0 6
137262: PUSH
137263: LD_INT 2
137265: ARRAY
137266: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
137267: LD_ADDR_VAR 0 19
137271: PUSH
137272: LD_VAR 0 6
137276: PUSH
137277: LD_INT 3
137279: ARRAY
137280: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
137281: LD_ADDR_VAR 0 20
137285: PUSH
137286: LD_VAR 0 6
137290: PUSH
137291: LD_INT 4
137293: ARRAY
137294: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
137295: LD_ADDR_VAR 0 21
137299: PUSH
137300: LD_VAR 0 6
137304: PUSH
137305: LD_INT 5
137307: ARRAY
137308: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
137309: LD_ADDR_VAR 0 22
137313: PUSH
137314: LD_VAR 0 6
137318: PUSH
137319: LD_INT 6
137321: ARRAY
137322: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
137323: LD_ADDR_VAR 0 23
137327: PUSH
137328: LD_VAR 0 6
137332: PUSH
137333: LD_INT 7
137335: ARRAY
137336: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
137337: LD_ADDR_VAR 0 24
137341: PUSH
137342: LD_VAR 0 6
137346: PUSH
137347: LD_INT 8
137349: ARRAY
137350: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
137351: LD_ADDR_VAR 0 25
137355: PUSH
137356: LD_VAR 0 6
137360: PUSH
137361: LD_INT 9
137363: ARRAY
137364: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
137365: LD_ADDR_VAR 0 26
137369: PUSH
137370: LD_VAR 0 6
137374: PUSH
137375: LD_INT 10
137377: ARRAY
137378: ST_TO_ADDR
// end else
137379: GO 137461
// begin f_ignore_area := false ;
137381: LD_ADDR_VAR 0 17
137385: PUSH
137386: LD_INT 0
137388: ST_TO_ADDR
// f_capture := false ;
137389: LD_ADDR_VAR 0 18
137393: PUSH
137394: LD_INT 0
137396: ST_TO_ADDR
// f_ignore_civ := false ;
137397: LD_ADDR_VAR 0 19
137401: PUSH
137402: LD_INT 0
137404: ST_TO_ADDR
// f_murder := false ;
137405: LD_ADDR_VAR 0 20
137409: PUSH
137410: LD_INT 0
137412: ST_TO_ADDR
// f_mines := false ;
137413: LD_ADDR_VAR 0 21
137417: PUSH
137418: LD_INT 0
137420: ST_TO_ADDR
// f_repair := false ;
137421: LD_ADDR_VAR 0 22
137425: PUSH
137426: LD_INT 0
137428: ST_TO_ADDR
// f_heal := false ;
137429: LD_ADDR_VAR 0 23
137433: PUSH
137434: LD_INT 0
137436: ST_TO_ADDR
// f_spacetime := false ;
137437: LD_ADDR_VAR 0 24
137441: PUSH
137442: LD_INT 0
137444: ST_TO_ADDR
// f_attack_depot := false ;
137445: LD_ADDR_VAR 0 25
137449: PUSH
137450: LD_INT 0
137452: ST_TO_ADDR
// f_crawl := false ;
137453: LD_ADDR_VAR 0 26
137457: PUSH
137458: LD_INT 0
137460: ST_TO_ADDR
// end ; if f_heal then
137461: LD_VAR 0 23
137465: IFFALSE 137492
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
137467: LD_ADDR_VAR 0 31
137471: PUSH
137472: LD_VAR 0 4
137476: PPUSH
137477: LD_INT 25
137479: PUSH
137480: LD_INT 4
137482: PUSH
137483: EMPTY
137484: LIST
137485: LIST
137486: PPUSH
137487: CALL_OW 72
137491: ST_TO_ADDR
// if f_repair then
137492: LD_VAR 0 22
137496: IFFALSE 137523
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
137498: LD_ADDR_VAR 0 33
137502: PUSH
137503: LD_VAR 0 4
137507: PPUSH
137508: LD_INT 25
137510: PUSH
137511: LD_INT 3
137513: PUSH
137514: EMPTY
137515: LIST
137516: LIST
137517: PPUSH
137518: CALL_OW 72
137522: ST_TO_ADDR
// units_path := [ ] ;
137523: LD_ADDR_VAR 0 16
137527: PUSH
137528: EMPTY
137529: ST_TO_ADDR
// for i = 1 to group do
137530: LD_ADDR_VAR 0 7
137534: PUSH
137535: DOUBLE
137536: LD_INT 1
137538: DEC
137539: ST_TO_ADDR
137540: LD_VAR 0 4
137544: PUSH
137545: FOR_TO
137546: IFFALSE 137575
// units_path := Replace ( units_path , i , path ) ;
137548: LD_ADDR_VAR 0 16
137552: PUSH
137553: LD_VAR 0 16
137557: PPUSH
137558: LD_VAR 0 7
137562: PPUSH
137563: LD_VAR 0 5
137567: PPUSH
137568: CALL_OW 1
137572: ST_TO_ADDR
137573: GO 137545
137575: POP
137576: POP
// repeat for i = group downto 1 do
137577: LD_ADDR_VAR 0 7
137581: PUSH
137582: DOUBLE
137583: LD_VAR 0 4
137587: INC
137588: ST_TO_ADDR
137589: LD_INT 1
137591: PUSH
137592: FOR_DOWNTO
137593: IFFALSE 141769
// begin wait ( 5 ) ;
137595: LD_INT 5
137597: PPUSH
137598: CALL_OW 67
// tmp := [ ] ;
137602: LD_ADDR_VAR 0 14
137606: PUSH
137607: EMPTY
137608: ST_TO_ADDR
// attacking := false ;
137609: LD_ADDR_VAR 0 29
137613: PUSH
137614: LD_INT 0
137616: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
137617: LD_VAR 0 4
137621: PUSH
137622: LD_VAR 0 7
137626: ARRAY
137627: PPUSH
137628: CALL_OW 301
137632: IFTRUE 137647
137634: PUSH
137635: LD_VAR 0 4
137639: PUSH
137640: LD_VAR 0 7
137644: ARRAY
137645: NOT
137646: OR
137647: IFFALSE 137756
// begin if GetType ( group [ i ] ) = unit_human then
137649: LD_VAR 0 4
137653: PUSH
137654: LD_VAR 0 7
137658: ARRAY
137659: PPUSH
137660: CALL_OW 247
137664: PUSH
137665: LD_INT 1
137667: EQUAL
137668: IFFALSE 137714
// begin to_heal := to_heal diff group [ i ] ;
137670: LD_ADDR_VAR 0 30
137674: PUSH
137675: LD_VAR 0 30
137679: PUSH
137680: LD_VAR 0 4
137684: PUSH
137685: LD_VAR 0 7
137689: ARRAY
137690: DIFF
137691: ST_TO_ADDR
// healers := healers diff group [ i ] ;
137692: LD_ADDR_VAR 0 31
137696: PUSH
137697: LD_VAR 0 31
137701: PUSH
137702: LD_VAR 0 4
137706: PUSH
137707: LD_VAR 0 7
137711: ARRAY
137712: DIFF
137713: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
137714: LD_ADDR_VAR 0 4
137718: PUSH
137719: LD_VAR 0 4
137723: PPUSH
137724: LD_VAR 0 7
137728: PPUSH
137729: CALL_OW 3
137733: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
137734: LD_ADDR_VAR 0 16
137738: PUSH
137739: LD_VAR 0 16
137743: PPUSH
137744: LD_VAR 0 7
137748: PPUSH
137749: CALL_OW 3
137753: ST_TO_ADDR
// continue ;
137754: GO 137592
// end ; if f_repair then
137756: LD_VAR 0 22
137760: IFFALSE 138257
// begin if GetType ( group [ i ] ) = unit_vehicle then
137762: LD_VAR 0 4
137766: PUSH
137767: LD_VAR 0 7
137771: ARRAY
137772: PPUSH
137773: CALL_OW 247
137777: PUSH
137778: LD_INT 2
137780: EQUAL
137781: IFFALSE 137975
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
137783: LD_VAR 0 4
137787: PUSH
137788: LD_VAR 0 7
137792: ARRAY
137793: PPUSH
137794: CALL_OW 256
137798: PUSH
137799: LD_INT 700
137801: LESS
137802: IFFALSE 137823
137804: PUSH
137805: LD_VAR 0 4
137809: PUSH
137810: LD_VAR 0 7
137814: ARRAY
137815: PUSH
137816: LD_VAR 0 32
137820: IN
137821: NOT
137822: AND
137823: IFFALSE 137847
// to_repair := to_repair union group [ i ] ;
137825: LD_ADDR_VAR 0 32
137829: PUSH
137830: LD_VAR 0 32
137834: PUSH
137835: LD_VAR 0 4
137839: PUSH
137840: LD_VAR 0 7
137844: ARRAY
137845: UNION
137846: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
137847: LD_VAR 0 4
137851: PUSH
137852: LD_VAR 0 7
137856: ARRAY
137857: PPUSH
137858: CALL_OW 256
137862: PUSH
137863: LD_INT 1000
137865: EQUAL
137866: IFFALSE 137886
137868: PUSH
137869: LD_VAR 0 4
137873: PUSH
137874: LD_VAR 0 7
137878: ARRAY
137879: PUSH
137880: LD_VAR 0 32
137884: IN
137885: AND
137886: IFFALSE 137910
// to_repair := to_repair diff group [ i ] ;
137888: LD_ADDR_VAR 0 32
137892: PUSH
137893: LD_VAR 0 32
137897: PUSH
137898: LD_VAR 0 4
137902: PUSH
137903: LD_VAR 0 7
137907: ARRAY
137908: DIFF
137909: ST_TO_ADDR
// if group [ i ] in to_repair then
137910: LD_VAR 0 4
137914: PUSH
137915: LD_VAR 0 7
137919: ARRAY
137920: PUSH
137921: LD_VAR 0 32
137925: IN
137926: IFFALSE 137973
// begin if not IsInArea ( group [ i ] , f_repair ) then
137928: LD_VAR 0 4
137932: PUSH
137933: LD_VAR 0 7
137937: ARRAY
137938: PPUSH
137939: LD_VAR 0 22
137943: PPUSH
137944: CALL_OW 308
137948: NOT
137949: IFFALSE 137971
// ComMoveToArea ( group [ i ] , f_repair ) ;
137951: LD_VAR 0 4
137955: PUSH
137956: LD_VAR 0 7
137960: ARRAY
137961: PPUSH
137962: LD_VAR 0 22
137966: PPUSH
137967: CALL_OW 113
// continue ;
137971: GO 137592
// end ; end else
137973: GO 138257
// if group [ i ] in repairs then
137975: LD_VAR 0 4
137979: PUSH
137980: LD_VAR 0 7
137984: ARRAY
137985: PUSH
137986: LD_VAR 0 33
137990: IN
137991: IFFALSE 138257
// begin if IsInUnit ( group [ i ] ) then
137993: LD_VAR 0 4
137997: PUSH
137998: LD_VAR 0 7
138002: ARRAY
138003: PPUSH
138004: CALL_OW 310
138008: IFFALSE 138078
// begin z := IsInUnit ( group [ i ] ) ;
138010: LD_ADDR_VAR 0 13
138014: PUSH
138015: LD_VAR 0 4
138019: PUSH
138020: LD_VAR 0 7
138024: ARRAY
138025: PPUSH
138026: CALL_OW 310
138030: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
138031: LD_VAR 0 13
138035: PUSH
138036: LD_VAR 0 32
138040: IN
138041: IFFALSE 138059
138043: PUSH
138044: LD_VAR 0 13
138048: PPUSH
138049: LD_VAR 0 22
138053: PPUSH
138054: CALL_OW 308
138058: AND
138059: IFFALSE 138076
// ComExitVehicle ( group [ i ] ) ;
138061: LD_VAR 0 4
138065: PUSH
138066: LD_VAR 0 7
138070: ARRAY
138071: PPUSH
138072: CALL_OW 121
// end else
138076: GO 138257
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
138078: LD_ADDR_VAR 0 13
138082: PUSH
138083: LD_VAR 0 4
138087: PPUSH
138088: LD_INT 95
138090: PUSH
138091: LD_VAR 0 22
138095: PUSH
138096: EMPTY
138097: LIST
138098: LIST
138099: PUSH
138100: LD_INT 58
138102: PUSH
138103: EMPTY
138104: LIST
138105: PUSH
138106: EMPTY
138107: LIST
138108: LIST
138109: PPUSH
138110: CALL_OW 72
138114: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
138115: LD_VAR 0 4
138119: PUSH
138120: LD_VAR 0 7
138124: ARRAY
138125: PPUSH
138126: CALL_OW 314
138130: NOT
138131: IFFALSE 138255
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
138133: LD_ADDR_VAR 0 10
138137: PUSH
138138: LD_VAR 0 13
138142: PPUSH
138143: LD_VAR 0 4
138147: PUSH
138148: LD_VAR 0 7
138152: ARRAY
138153: PPUSH
138154: CALL_OW 74
138158: ST_TO_ADDR
// if not x then
138159: LD_VAR 0 10
138163: NOT
138164: IFFALSE 138168
// continue ;
138166: GO 137592
// if GetLives ( x ) < 1000 then
138168: LD_VAR 0 10
138172: PPUSH
138173: CALL_OW 256
138177: PUSH
138178: LD_INT 1000
138180: LESS
138181: IFFALSE 138205
// ComRepairVehicle ( group [ i ] , x ) else
138183: LD_VAR 0 4
138187: PUSH
138188: LD_VAR 0 7
138192: ARRAY
138193: PPUSH
138194: LD_VAR 0 10
138198: PPUSH
138199: CALL_OW 129
138203: GO 138255
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
138205: LD_VAR 0 23
138209: IFFALSE 138232
138211: PUSH
138212: LD_VAR 0 4
138216: PUSH
138217: LD_VAR 0 7
138221: ARRAY
138222: PPUSH
138223: CALL_OW 256
138227: PUSH
138228: LD_INT 1000
138230: LESS
138231: AND
138232: NOT
138233: IFFALSE 138255
// ComEnterUnit ( group [ i ] , x ) ;
138235: LD_VAR 0 4
138239: PUSH
138240: LD_VAR 0 7
138244: ARRAY
138245: PPUSH
138246: LD_VAR 0 10
138250: PPUSH
138251: CALL_OW 120
// end ; continue ;
138255: GO 137592
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
138257: LD_VAR 0 23
138261: IFFALSE 138284
138263: PUSH
138264: LD_VAR 0 4
138268: PUSH
138269: LD_VAR 0 7
138273: ARRAY
138274: PPUSH
138275: CALL_OW 247
138279: PUSH
138280: LD_INT 1
138282: EQUAL
138283: AND
138284: IFFALSE 138768
// begin if group [ i ] in healers then
138286: LD_VAR 0 4
138290: PUSH
138291: LD_VAR 0 7
138295: ARRAY
138296: PUSH
138297: LD_VAR 0 31
138301: IN
138302: IFFALSE 138579
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
138304: LD_VAR 0 4
138308: PUSH
138309: LD_VAR 0 7
138313: ARRAY
138314: PPUSH
138315: LD_VAR 0 23
138319: PPUSH
138320: CALL_OW 308
138324: NOT
138325: IFFALSE 138345
138327: PUSH
138328: LD_VAR 0 4
138332: PUSH
138333: LD_VAR 0 7
138337: ARRAY
138338: PPUSH
138339: CALL_OW 314
138343: NOT
138344: AND
138345: IFFALSE 138369
// ComMoveToArea ( group [ i ] , f_heal ) else
138347: LD_VAR 0 4
138351: PUSH
138352: LD_VAR 0 7
138356: ARRAY
138357: PPUSH
138358: LD_VAR 0 23
138362: PPUSH
138363: CALL_OW 113
138367: GO 138577
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
138369: LD_VAR 0 4
138373: PUSH
138374: LD_VAR 0 7
138378: ARRAY
138379: PPUSH
138380: CALL 106495 0 1
138384: PPUSH
138385: CALL_OW 256
138389: PUSH
138390: LD_INT 1000
138392: EQUAL
138393: IFFALSE 138412
// ComStop ( group [ i ] ) else
138395: LD_VAR 0 4
138399: PUSH
138400: LD_VAR 0 7
138404: ARRAY
138405: PPUSH
138406: CALL_OW 141
138410: GO 138577
// if not HasTask ( group [ i ] ) and to_heal then
138412: LD_VAR 0 4
138416: PUSH
138417: LD_VAR 0 7
138421: ARRAY
138422: PPUSH
138423: CALL_OW 314
138427: NOT
138428: IFFALSE 138436
138430: PUSH
138431: LD_VAR 0 30
138435: AND
138436: IFFALSE 138577
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
138438: LD_ADDR_VAR 0 13
138442: PUSH
138443: LD_VAR 0 30
138447: PPUSH
138448: LD_INT 3
138450: PUSH
138451: LD_INT 54
138453: PUSH
138454: EMPTY
138455: LIST
138456: PUSH
138457: EMPTY
138458: LIST
138459: LIST
138460: PPUSH
138461: CALL_OW 72
138465: PPUSH
138466: LD_VAR 0 4
138470: PUSH
138471: LD_VAR 0 7
138475: ARRAY
138476: PPUSH
138477: CALL_OW 74
138481: ST_TO_ADDR
// if z then
138482: LD_VAR 0 13
138486: IFFALSE 138577
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
138488: LD_INT 91
138490: PUSH
138491: LD_VAR 0 13
138495: PUSH
138496: LD_INT 10
138498: PUSH
138499: EMPTY
138500: LIST
138501: LIST
138502: LIST
138503: PUSH
138504: LD_INT 81
138506: PUSH
138507: LD_VAR 0 13
138511: PPUSH
138512: CALL_OW 255
138516: PUSH
138517: EMPTY
138518: LIST
138519: LIST
138520: PUSH
138521: EMPTY
138522: LIST
138523: LIST
138524: PPUSH
138525: CALL_OW 69
138529: PUSH
138530: LD_INT 0
138532: EQUAL
138533: IFFALSE 138557
// ComHeal ( group [ i ] , z ) else
138535: LD_VAR 0 4
138539: PUSH
138540: LD_VAR 0 7
138544: ARRAY
138545: PPUSH
138546: LD_VAR 0 13
138550: PPUSH
138551: CALL_OW 128
138555: GO 138577
// ComMoveToArea ( group [ i ] , f_heal ) ;
138557: LD_VAR 0 4
138561: PUSH
138562: LD_VAR 0 7
138566: ARRAY
138567: PPUSH
138568: LD_VAR 0 23
138572: PPUSH
138573: CALL_OW 113
// end ; continue ;
138577: GO 137592
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
138579: LD_VAR 0 4
138583: PUSH
138584: LD_VAR 0 7
138588: ARRAY
138589: PPUSH
138590: CALL_OW 256
138594: PUSH
138595: LD_INT 700
138597: LESS
138598: IFFALSE 138619
138600: PUSH
138601: LD_VAR 0 4
138605: PUSH
138606: LD_VAR 0 7
138610: ARRAY
138611: PUSH
138612: LD_VAR 0 30
138616: IN
138617: NOT
138618: AND
138619: IFFALSE 138643
// to_heal := to_heal union group [ i ] ;
138621: LD_ADDR_VAR 0 30
138625: PUSH
138626: LD_VAR 0 30
138630: PUSH
138631: LD_VAR 0 4
138635: PUSH
138636: LD_VAR 0 7
138640: ARRAY
138641: UNION
138642: ST_TO_ADDR
// if group [ i ] in to_heal then
138643: LD_VAR 0 4
138647: PUSH
138648: LD_VAR 0 7
138652: ARRAY
138653: PUSH
138654: LD_VAR 0 30
138658: IN
138659: IFFALSE 138768
// begin if GetLives ( group [ i ] ) = 1000 then
138661: LD_VAR 0 4
138665: PUSH
138666: LD_VAR 0 7
138670: ARRAY
138671: PPUSH
138672: CALL_OW 256
138676: PUSH
138677: LD_INT 1000
138679: EQUAL
138680: IFFALSE 138706
// to_heal := to_heal diff group [ i ] else
138682: LD_ADDR_VAR 0 30
138686: PUSH
138687: LD_VAR 0 30
138691: PUSH
138692: LD_VAR 0 4
138696: PUSH
138697: LD_VAR 0 7
138701: ARRAY
138702: DIFF
138703: ST_TO_ADDR
138704: GO 138768
// begin if not IsInArea ( group [ i ] , to_heal ) then
138706: LD_VAR 0 4
138710: PUSH
138711: LD_VAR 0 7
138715: ARRAY
138716: PPUSH
138717: LD_VAR 0 30
138721: PPUSH
138722: CALL_OW 308
138726: NOT
138727: IFFALSE 138751
// ComMoveToArea ( group [ i ] , f_heal ) else
138729: LD_VAR 0 4
138733: PUSH
138734: LD_VAR 0 7
138738: ARRAY
138739: PPUSH
138740: LD_VAR 0 23
138744: PPUSH
138745: CALL_OW 113
138749: GO 138766
// ComHold ( group [ i ] ) ;
138751: LD_VAR 0 4
138755: PUSH
138756: LD_VAR 0 7
138760: ARRAY
138761: PPUSH
138762: CALL_OW 140
// continue ;
138766: GO 137592
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
138768: LD_VAR 0 4
138772: PUSH
138773: LD_VAR 0 7
138777: ARRAY
138778: PPUSH
138779: LD_INT 10
138781: PPUSH
138782: CALL 104094 0 2
138786: NOT
138787: IFFALSE 138805
138789: PUSH
138790: LD_VAR 0 16
138794: PUSH
138795: LD_VAR 0 7
138799: ARRAY
138800: PUSH
138801: EMPTY
138802: EQUAL
138803: NOT
138804: AND
138805: IFFALSE 139071
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
138807: LD_VAR 0 4
138811: PUSH
138812: LD_VAR 0 7
138816: ARRAY
138817: PPUSH
138818: CALL_OW 262
138822: PUSH
138823: LD_INT 1
138825: PUSH
138826: LD_INT 2
138828: PUSH
138829: EMPTY
138830: LIST
138831: LIST
138832: IN
138833: IFFALSE 138874
// if GetFuel ( group [ i ] ) < 10 then
138835: LD_VAR 0 4
138839: PUSH
138840: LD_VAR 0 7
138844: ARRAY
138845: PPUSH
138846: CALL_OW 261
138850: PUSH
138851: LD_INT 10
138853: LESS
138854: IFFALSE 138874
// SetFuel ( group [ i ] , 12 ) ;
138856: LD_VAR 0 4
138860: PUSH
138861: LD_VAR 0 7
138865: ARRAY
138866: PPUSH
138867: LD_INT 12
138869: PPUSH
138870: CALL_OW 240
// if units_path [ i ] then
138874: LD_VAR 0 16
138878: PUSH
138879: LD_VAR 0 7
138883: ARRAY
138884: IFFALSE 139069
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
138886: LD_VAR 0 4
138890: PUSH
138891: LD_VAR 0 7
138895: ARRAY
138896: PPUSH
138897: LD_VAR 0 16
138901: PUSH
138902: LD_VAR 0 7
138906: ARRAY
138907: PUSH
138908: LD_INT 1
138910: ARRAY
138911: PUSH
138912: LD_INT 1
138914: ARRAY
138915: PPUSH
138916: LD_VAR 0 16
138920: PUSH
138921: LD_VAR 0 7
138925: ARRAY
138926: PUSH
138927: LD_INT 1
138929: ARRAY
138930: PUSH
138931: LD_INT 2
138933: ARRAY
138934: PPUSH
138935: CALL_OW 297
138939: PUSH
138940: LD_INT 6
138942: GREATER
138943: IFFALSE 139018
// begin if not HasTask ( group [ i ] ) then
138945: LD_VAR 0 4
138949: PUSH
138950: LD_VAR 0 7
138954: ARRAY
138955: PPUSH
138956: CALL_OW 314
138960: NOT
138961: IFFALSE 139016
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
138963: LD_VAR 0 4
138967: PUSH
138968: LD_VAR 0 7
138972: ARRAY
138973: PPUSH
138974: LD_VAR 0 16
138978: PUSH
138979: LD_VAR 0 7
138983: ARRAY
138984: PUSH
138985: LD_INT 1
138987: ARRAY
138988: PUSH
138989: LD_INT 1
138991: ARRAY
138992: PPUSH
138993: LD_VAR 0 16
138997: PUSH
138998: LD_VAR 0 7
139002: ARRAY
139003: PUSH
139004: LD_INT 1
139006: ARRAY
139007: PUSH
139008: LD_INT 2
139010: ARRAY
139011: PPUSH
139012: CALL_OW 114
// end else
139016: GO 139069
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
139018: LD_ADDR_VAR 0 15
139022: PUSH
139023: LD_VAR 0 16
139027: PUSH
139028: LD_VAR 0 7
139032: ARRAY
139033: PPUSH
139034: LD_INT 1
139036: PPUSH
139037: CALL_OW 3
139041: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
139042: LD_ADDR_VAR 0 16
139046: PUSH
139047: LD_VAR 0 16
139051: PPUSH
139052: LD_VAR 0 7
139056: PPUSH
139057: LD_VAR 0 15
139061: PPUSH
139062: CALL_OW 1
139066: ST_TO_ADDR
// continue ;
139067: GO 137592
// end ; end ; end else
139069: GO 141767
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
139071: LD_ADDR_VAR 0 14
139075: PUSH
139076: LD_INT 81
139078: PUSH
139079: LD_VAR 0 4
139083: PUSH
139084: LD_VAR 0 7
139088: ARRAY
139089: PPUSH
139090: CALL_OW 255
139094: PUSH
139095: EMPTY
139096: LIST
139097: LIST
139098: PPUSH
139099: CALL_OW 69
139103: ST_TO_ADDR
// if not tmp then
139104: LD_VAR 0 14
139108: NOT
139109: IFFALSE 139113
// continue ;
139111: GO 137592
// if f_ignore_area then
139113: LD_VAR 0 17
139117: IFFALSE 139205
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
139119: LD_ADDR_VAR 0 15
139123: PUSH
139124: LD_VAR 0 14
139128: PPUSH
139129: LD_INT 3
139131: PUSH
139132: LD_INT 92
139134: PUSH
139135: LD_VAR 0 17
139139: PUSH
139140: LD_INT 1
139142: ARRAY
139143: PUSH
139144: LD_VAR 0 17
139148: PUSH
139149: LD_INT 2
139151: ARRAY
139152: PUSH
139153: LD_VAR 0 17
139157: PUSH
139158: LD_INT 3
139160: ARRAY
139161: PUSH
139162: EMPTY
139163: LIST
139164: LIST
139165: LIST
139166: LIST
139167: PUSH
139168: EMPTY
139169: LIST
139170: LIST
139171: PPUSH
139172: CALL_OW 72
139176: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
139177: LD_VAR 0 14
139181: PUSH
139182: LD_VAR 0 15
139186: DIFF
139187: IFFALSE 139205
// tmp := tmp diff tmp2 ;
139189: LD_ADDR_VAR 0 14
139193: PUSH
139194: LD_VAR 0 14
139198: PUSH
139199: LD_VAR 0 15
139203: DIFF
139204: ST_TO_ADDR
// end ; if not f_murder then
139205: LD_VAR 0 20
139209: NOT
139210: IFFALSE 139268
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
139212: LD_ADDR_VAR 0 15
139216: PUSH
139217: LD_VAR 0 14
139221: PPUSH
139222: LD_INT 3
139224: PUSH
139225: LD_INT 50
139227: PUSH
139228: EMPTY
139229: LIST
139230: PUSH
139231: EMPTY
139232: LIST
139233: LIST
139234: PPUSH
139235: CALL_OW 72
139239: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
139240: LD_VAR 0 14
139244: PUSH
139245: LD_VAR 0 15
139249: DIFF
139250: IFFALSE 139268
// tmp := tmp diff tmp2 ;
139252: LD_ADDR_VAR 0 14
139256: PUSH
139257: LD_VAR 0 14
139261: PUSH
139262: LD_VAR 0 15
139266: DIFF
139267: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
139268: LD_ADDR_VAR 0 14
139272: PUSH
139273: LD_VAR 0 4
139277: PUSH
139278: LD_VAR 0 7
139282: ARRAY
139283: PPUSH
139284: LD_VAR 0 14
139288: PPUSH
139289: LD_INT 1
139291: PPUSH
139292: LD_INT 1
139294: PPUSH
139295: CALL 76516 0 4
139299: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
139300: LD_VAR 0 4
139304: PUSH
139305: LD_VAR 0 7
139309: ARRAY
139310: PPUSH
139311: CALL_OW 257
139315: PUSH
139316: LD_INT 1
139318: EQUAL
139319: IFFALSE 139779
// begin if WantPlant ( group [ i ] ) then
139321: LD_VAR 0 4
139325: PUSH
139326: LD_VAR 0 7
139330: ARRAY
139331: PPUSH
139332: CALL 76017 0 1
139336: IFFALSE 139340
// continue ;
139338: GO 137592
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
139340: LD_VAR 0 18
139344: IFFALSE 139364
139346: PUSH
139347: LD_VAR 0 4
139351: PUSH
139352: LD_VAR 0 7
139356: ARRAY
139357: PPUSH
139358: CALL_OW 310
139362: NOT
139363: AND
139364: IFFALSE 139407
139366: PUSH
139367: LD_VAR 0 14
139371: PUSH
139372: LD_INT 1
139374: ARRAY
139375: PUSH
139376: LD_VAR 0 14
139380: PPUSH
139381: LD_INT 21
139383: PUSH
139384: LD_INT 2
139386: PUSH
139387: EMPTY
139388: LIST
139389: LIST
139390: PUSH
139391: LD_INT 58
139393: PUSH
139394: EMPTY
139395: LIST
139396: PUSH
139397: EMPTY
139398: LIST
139399: LIST
139400: PPUSH
139401: CALL_OW 72
139405: IN
139406: AND
139407: IFFALSE 139443
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
139409: LD_VAR 0 4
139413: PUSH
139414: LD_VAR 0 7
139418: ARRAY
139419: PPUSH
139420: LD_VAR 0 14
139424: PUSH
139425: LD_INT 1
139427: ARRAY
139428: PPUSH
139429: CALL_OW 120
// attacking := true ;
139433: LD_ADDR_VAR 0 29
139437: PUSH
139438: LD_INT 1
139440: ST_TO_ADDR
// continue ;
139441: GO 137592
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
139443: LD_VAR 0 26
139447: IFFALSE 139470
139449: PUSH
139450: LD_VAR 0 4
139454: PUSH
139455: LD_VAR 0 7
139459: ARRAY
139460: PPUSH
139461: CALL_OW 257
139465: PUSH
139466: LD_INT 1
139468: EQUAL
139469: AND
139470: IFFALSE 139493
139472: PUSH
139473: LD_VAR 0 4
139477: PUSH
139478: LD_VAR 0 7
139482: ARRAY
139483: PPUSH
139484: CALL_OW 256
139488: PUSH
139489: LD_INT 800
139491: LESS
139492: AND
139493: IFFALSE 139513
139495: PUSH
139496: LD_VAR 0 4
139500: PUSH
139501: LD_VAR 0 7
139505: ARRAY
139506: PPUSH
139507: CALL_OW 318
139511: NOT
139512: AND
139513: IFFALSE 139530
// ComCrawl ( group [ i ] ) ;
139515: LD_VAR 0 4
139519: PUSH
139520: LD_VAR 0 7
139524: ARRAY
139525: PPUSH
139526: CALL_OW 137
// if f_mines then
139530: LD_VAR 0 21
139534: IFFALSE 139779
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
139536: LD_VAR 0 14
139540: PUSH
139541: LD_INT 1
139543: ARRAY
139544: PPUSH
139545: CALL_OW 247
139549: PUSH
139550: LD_INT 3
139552: EQUAL
139553: IFFALSE 139572
139555: PUSH
139556: LD_VAR 0 14
139560: PUSH
139561: LD_INT 1
139563: ARRAY
139564: PUSH
139565: LD_VAR 0 27
139569: IN
139570: NOT
139571: AND
139572: IFFALSE 139779
// begin x := GetX ( tmp [ 1 ] ) ;
139574: LD_ADDR_VAR 0 10
139578: PUSH
139579: LD_VAR 0 14
139583: PUSH
139584: LD_INT 1
139586: ARRAY
139587: PPUSH
139588: CALL_OW 250
139592: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
139593: LD_ADDR_VAR 0 11
139597: PUSH
139598: LD_VAR 0 14
139602: PUSH
139603: LD_INT 1
139605: ARRAY
139606: PPUSH
139607: CALL_OW 251
139611: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
139612: LD_ADDR_VAR 0 12
139616: PUSH
139617: LD_VAR 0 4
139621: PUSH
139622: LD_VAR 0 7
139626: ARRAY
139627: PPUSH
139628: CALL 104179 0 1
139632: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
139633: LD_VAR 0 4
139637: PUSH
139638: LD_VAR 0 7
139642: ARRAY
139643: PPUSH
139644: LD_VAR 0 10
139648: PPUSH
139649: LD_VAR 0 11
139653: PPUSH
139654: LD_VAR 0 14
139658: PUSH
139659: LD_INT 1
139661: ARRAY
139662: PPUSH
139663: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
139667: LD_VAR 0 4
139671: PUSH
139672: LD_VAR 0 7
139676: ARRAY
139677: PPUSH
139678: LD_VAR 0 10
139682: PPUSH
139683: LD_VAR 0 12
139687: PPUSH
139688: LD_INT 7
139690: PPUSH
139691: CALL_OW 272
139695: PPUSH
139696: LD_VAR 0 11
139700: PPUSH
139701: LD_VAR 0 12
139705: PPUSH
139706: LD_INT 7
139708: PPUSH
139709: CALL_OW 273
139713: PPUSH
139714: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
139718: LD_VAR 0 4
139722: PUSH
139723: LD_VAR 0 7
139727: ARRAY
139728: PPUSH
139729: LD_INT 71
139731: PPUSH
139732: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
139736: LD_ADDR_VAR 0 27
139740: PUSH
139741: LD_VAR 0 27
139745: PPUSH
139746: LD_VAR 0 27
139750: PUSH
139751: LD_INT 1
139753: PLUS
139754: PPUSH
139755: LD_VAR 0 14
139759: PUSH
139760: LD_INT 1
139762: ARRAY
139763: PPUSH
139764: CALL_OW 1
139768: ST_TO_ADDR
// attacking := true ;
139769: LD_ADDR_VAR 0 29
139773: PUSH
139774: LD_INT 1
139776: ST_TO_ADDR
// continue ;
139777: GO 137592
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
139779: LD_VAR 0 4
139783: PUSH
139784: LD_VAR 0 7
139788: ARRAY
139789: PPUSH
139790: CALL_OW 257
139794: PUSH
139795: LD_INT 17
139797: EQUAL
139798: IFFALSE 139822
139800: PUSH
139801: LD_VAR 0 4
139805: PUSH
139806: LD_VAR 0 7
139810: ARRAY
139811: PPUSH
139812: CALL_OW 110
139816: PUSH
139817: LD_INT 71
139819: EQUAL
139820: NOT
139821: AND
139822: IFFALSE 139968
// begin attacking := false ;
139824: LD_ADDR_VAR 0 29
139828: PUSH
139829: LD_INT 0
139831: ST_TO_ADDR
// k := 5 ;
139832: LD_ADDR_VAR 0 9
139836: PUSH
139837: LD_INT 5
139839: ST_TO_ADDR
// if tmp < k then
139840: LD_VAR 0 14
139844: PUSH
139845: LD_VAR 0 9
139849: LESS
139850: IFFALSE 139862
// k := tmp ;
139852: LD_ADDR_VAR 0 9
139856: PUSH
139857: LD_VAR 0 14
139861: ST_TO_ADDR
// for j = 1 to k do
139862: LD_ADDR_VAR 0 8
139866: PUSH
139867: DOUBLE
139868: LD_INT 1
139870: DEC
139871: ST_TO_ADDR
139872: LD_VAR 0 9
139876: PUSH
139877: FOR_TO
139878: IFFALSE 139966
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
139880: LD_VAR 0 14
139884: PUSH
139885: LD_VAR 0 8
139889: ARRAY
139890: PUSH
139891: LD_VAR 0 14
139895: PPUSH
139896: LD_INT 58
139898: PUSH
139899: EMPTY
139900: LIST
139901: PPUSH
139902: CALL_OW 72
139906: IN
139907: NOT
139908: IFFALSE 139964
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
139910: LD_VAR 0 4
139914: PUSH
139915: LD_VAR 0 7
139919: ARRAY
139920: PPUSH
139921: LD_VAR 0 14
139925: PUSH
139926: LD_VAR 0 8
139930: ARRAY
139931: PPUSH
139932: CALL_OW 115
// attacking := true ;
139936: LD_ADDR_VAR 0 29
139940: PUSH
139941: LD_INT 1
139943: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
139944: LD_VAR 0 4
139948: PUSH
139949: LD_VAR 0 7
139953: ARRAY
139954: PPUSH
139955: LD_INT 71
139957: PPUSH
139958: CALL_OW 109
// continue ;
139962: GO 139877
// end ; end ;
139964: GO 139877
139966: POP
139967: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
139968: LD_VAR 0 4
139972: PUSH
139973: LD_VAR 0 7
139977: ARRAY
139978: PPUSH
139979: CALL_OW 257
139983: PUSH
139984: LD_INT 8
139986: EQUAL
139987: IFTRUE 140025
139989: PUSH
139990: LD_VAR 0 4
139994: PUSH
139995: LD_VAR 0 7
139999: ARRAY
140000: PPUSH
140001: CALL_OW 264
140005: PUSH
140006: LD_INT 28
140008: PUSH
140009: LD_INT 45
140011: PUSH
140012: LD_INT 7
140014: PUSH
140015: LD_INT 47
140017: PUSH
140018: EMPTY
140019: LIST
140020: LIST
140021: LIST
140022: LIST
140023: IN
140024: OR
140025: IFFALSE 140281
// begin attacking := false ;
140027: LD_ADDR_VAR 0 29
140031: PUSH
140032: LD_INT 0
140034: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
140035: LD_VAR 0 14
140039: PUSH
140040: LD_INT 1
140042: ARRAY
140043: PPUSH
140044: CALL_OW 266
140048: PUSH
140049: LD_INT 32
140051: PUSH
140052: LD_INT 31
140054: PUSH
140055: LD_INT 33
140057: PUSH
140058: LD_INT 4
140060: PUSH
140061: LD_INT 5
140063: PUSH
140064: EMPTY
140065: LIST
140066: LIST
140067: LIST
140068: LIST
140069: LIST
140070: IN
140071: IFFALSE 140257
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
140073: LD_ADDR_VAR 0 9
140077: PUSH
140078: LD_VAR 0 14
140082: PUSH
140083: LD_INT 1
140085: ARRAY
140086: PPUSH
140087: CALL_OW 266
140091: PPUSH
140092: LD_VAR 0 14
140096: PUSH
140097: LD_INT 1
140099: ARRAY
140100: PPUSH
140101: CALL_OW 250
140105: PPUSH
140106: LD_VAR 0 14
140110: PUSH
140111: LD_INT 1
140113: ARRAY
140114: PPUSH
140115: CALL_OW 251
140119: PPUSH
140120: LD_VAR 0 14
140124: PUSH
140125: LD_INT 1
140127: ARRAY
140128: PPUSH
140129: CALL_OW 254
140133: PPUSH
140134: LD_VAR 0 14
140138: PUSH
140139: LD_INT 1
140141: ARRAY
140142: PPUSH
140143: CALL_OW 248
140147: PPUSH
140148: LD_INT 0
140150: PPUSH
140151: CALL 85537 0 6
140155: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
140156: LD_ADDR_VAR 0 8
140160: PUSH
140161: LD_VAR 0 4
140165: PUSH
140166: LD_VAR 0 7
140170: ARRAY
140171: PPUSH
140172: LD_VAR 0 9
140176: PPUSH
140177: CALL 104292 0 2
140181: ST_TO_ADDR
// if j then
140182: LD_VAR 0 8
140186: IFFALSE 140255
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
140188: LD_VAR 0 8
140192: PUSH
140193: LD_INT 1
140195: ARRAY
140196: PPUSH
140197: LD_VAR 0 8
140201: PUSH
140202: LD_INT 2
140204: ARRAY
140205: PPUSH
140206: CALL_OW 488
140210: IFFALSE 140255
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
140212: LD_VAR 0 4
140216: PUSH
140217: LD_VAR 0 7
140221: ARRAY
140222: PPUSH
140223: LD_VAR 0 8
140227: PUSH
140228: LD_INT 1
140230: ARRAY
140231: PPUSH
140232: LD_VAR 0 8
140236: PUSH
140237: LD_INT 2
140239: ARRAY
140240: PPUSH
140241: CALL_OW 116
// attacking := true ;
140245: LD_ADDR_VAR 0 29
140249: PUSH
140250: LD_INT 1
140252: ST_TO_ADDR
// continue ;
140253: GO 137592
// end ; end else
140255: GO 140281
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
140257: LD_VAR 0 4
140261: PUSH
140262: LD_VAR 0 7
140266: ARRAY
140267: PPUSH
140268: LD_VAR 0 14
140272: PUSH
140273: LD_INT 1
140275: ARRAY
140276: PPUSH
140277: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
140281: LD_VAR 0 4
140285: PUSH
140286: LD_VAR 0 7
140290: ARRAY
140291: PPUSH
140292: CALL_OW 265
140296: PUSH
140297: LD_INT 11
140299: EQUAL
140300: IFFALSE 140578
// begin k := 10 ;
140302: LD_ADDR_VAR 0 9
140306: PUSH
140307: LD_INT 10
140309: ST_TO_ADDR
// x := 0 ;
140310: LD_ADDR_VAR 0 10
140314: PUSH
140315: LD_INT 0
140317: ST_TO_ADDR
// if tmp < k then
140318: LD_VAR 0 14
140322: PUSH
140323: LD_VAR 0 9
140327: LESS
140328: IFFALSE 140340
// k := tmp ;
140330: LD_ADDR_VAR 0 9
140334: PUSH
140335: LD_VAR 0 14
140339: ST_TO_ADDR
// for j = k downto 1 do
140340: LD_ADDR_VAR 0 8
140344: PUSH
140345: DOUBLE
140346: LD_VAR 0 9
140350: INC
140351: ST_TO_ADDR
140352: LD_INT 1
140354: PUSH
140355: FOR_DOWNTO
140356: IFFALSE 140431
// begin if GetType ( tmp [ j ] ) = unit_human then
140358: LD_VAR 0 14
140362: PUSH
140363: LD_VAR 0 8
140367: ARRAY
140368: PPUSH
140369: CALL_OW 247
140373: PUSH
140374: LD_INT 1
140376: EQUAL
140377: IFFALSE 140429
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
140379: LD_VAR 0 4
140383: PUSH
140384: LD_VAR 0 7
140388: ARRAY
140389: PPUSH
140390: LD_VAR 0 14
140394: PUSH
140395: LD_VAR 0 8
140399: ARRAY
140400: PPUSH
140401: CALL 104550 0 2
// x := tmp [ j ] ;
140405: LD_ADDR_VAR 0 10
140409: PUSH
140410: LD_VAR 0 14
140414: PUSH
140415: LD_VAR 0 8
140419: ARRAY
140420: ST_TO_ADDR
// attacking := true ;
140421: LD_ADDR_VAR 0 29
140425: PUSH
140426: LD_INT 1
140428: ST_TO_ADDR
// end ; end ;
140429: GO 140355
140431: POP
140432: POP
// if not x then
140433: LD_VAR 0 10
140437: NOT
140438: IFFALSE 140578
// begin attacking := true ;
140440: LD_ADDR_VAR 0 29
140444: PUSH
140445: LD_INT 1
140447: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
140448: LD_VAR 0 4
140452: PUSH
140453: LD_VAR 0 7
140457: ARRAY
140458: PPUSH
140459: CALL_OW 250
140463: PPUSH
140464: LD_VAR 0 4
140468: PUSH
140469: LD_VAR 0 7
140473: ARRAY
140474: PPUSH
140475: CALL_OW 251
140479: PPUSH
140480: CALL_OW 546
140484: PUSH
140485: LD_INT 2
140487: ARRAY
140488: PUSH
140489: LD_VAR 0 14
140493: PUSH
140494: LD_INT 1
140496: ARRAY
140497: PPUSH
140498: CALL_OW 250
140502: PPUSH
140503: LD_VAR 0 14
140507: PUSH
140508: LD_INT 1
140510: ARRAY
140511: PPUSH
140512: CALL_OW 251
140516: PPUSH
140517: CALL_OW 546
140521: PUSH
140522: LD_INT 2
140524: ARRAY
140525: EQUAL
140526: IFFALSE 140554
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
140528: LD_VAR 0 4
140532: PUSH
140533: LD_VAR 0 7
140537: ARRAY
140538: PPUSH
140539: LD_VAR 0 14
140543: PUSH
140544: LD_INT 1
140546: ARRAY
140547: PPUSH
140548: CALL 104550 0 2
140552: GO 140578
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
140554: LD_VAR 0 4
140558: PUSH
140559: LD_VAR 0 7
140563: ARRAY
140564: PPUSH
140565: LD_VAR 0 14
140569: PUSH
140570: LD_INT 1
140572: ARRAY
140573: PPUSH
140574: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
140578: LD_VAR 0 4
140582: PUSH
140583: LD_VAR 0 7
140587: ARRAY
140588: PPUSH
140589: CALL_OW 264
140593: PUSH
140594: LD_INT 29
140596: EQUAL
140597: IFFALSE 140967
// begin if WantsToAttack ( group [ i ] ) in bombed then
140599: LD_VAR 0 4
140603: PUSH
140604: LD_VAR 0 7
140608: ARRAY
140609: PPUSH
140610: CALL_OW 319
140614: PUSH
140615: LD_VAR 0 28
140619: IN
140620: IFFALSE 140624
// continue ;
140622: GO 137592
// k := 8 ;
140624: LD_ADDR_VAR 0 9
140628: PUSH
140629: LD_INT 8
140631: ST_TO_ADDR
// x := 0 ;
140632: LD_ADDR_VAR 0 10
140636: PUSH
140637: LD_INT 0
140639: ST_TO_ADDR
// if tmp < k then
140640: LD_VAR 0 14
140644: PUSH
140645: LD_VAR 0 9
140649: LESS
140650: IFFALSE 140662
// k := tmp ;
140652: LD_ADDR_VAR 0 9
140656: PUSH
140657: LD_VAR 0 14
140661: ST_TO_ADDR
// for j = 1 to k do
140662: LD_ADDR_VAR 0 8
140666: PUSH
140667: DOUBLE
140668: LD_INT 1
140670: DEC
140671: ST_TO_ADDR
140672: LD_VAR 0 9
140676: PUSH
140677: FOR_TO
140678: IFFALSE 140812
// begin if GetType ( tmp [ j ] ) = unit_building then
140680: LD_VAR 0 14
140684: PUSH
140685: LD_VAR 0 8
140689: ARRAY
140690: PPUSH
140691: CALL_OW 247
140695: PUSH
140696: LD_INT 3
140698: EQUAL
140699: IFFALSE 140810
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
140701: LD_VAR 0 14
140705: PUSH
140706: LD_VAR 0 8
140710: ARRAY
140711: PUSH
140712: LD_VAR 0 28
140716: IN
140717: NOT
140718: IFFALSE 140737
140720: PUSH
140721: LD_VAR 0 14
140725: PUSH
140726: LD_VAR 0 8
140730: ARRAY
140731: PPUSH
140732: CALL_OW 313
140736: AND
140737: IFFALSE 140810
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
140739: LD_VAR 0 4
140743: PUSH
140744: LD_VAR 0 7
140748: ARRAY
140749: PPUSH
140750: LD_VAR 0 14
140754: PUSH
140755: LD_VAR 0 8
140759: ARRAY
140760: PPUSH
140761: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
140765: LD_ADDR_VAR 0 28
140769: PUSH
140770: LD_VAR 0 28
140774: PPUSH
140775: LD_VAR 0 28
140779: PUSH
140780: LD_INT 1
140782: PLUS
140783: PPUSH
140784: LD_VAR 0 14
140788: PUSH
140789: LD_VAR 0 8
140793: ARRAY
140794: PPUSH
140795: CALL_OW 1
140799: ST_TO_ADDR
// attacking := true ;
140800: LD_ADDR_VAR 0 29
140804: PUSH
140805: LD_INT 1
140807: ST_TO_ADDR
// break ;
140808: GO 140812
// end ; end ;
140810: GO 140677
140812: POP
140813: POP
// if not attacking and f_attack_depot then
140814: LD_VAR 0 29
140818: NOT
140819: IFFALSE 140827
140821: PUSH
140822: LD_VAR 0 25
140826: AND
140827: IFFALSE 140922
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
140829: LD_ADDR_VAR 0 13
140833: PUSH
140834: LD_VAR 0 14
140838: PPUSH
140839: LD_INT 2
140841: PUSH
140842: LD_INT 30
140844: PUSH
140845: LD_INT 0
140847: PUSH
140848: EMPTY
140849: LIST
140850: LIST
140851: PUSH
140852: LD_INT 30
140854: PUSH
140855: LD_INT 1
140857: PUSH
140858: EMPTY
140859: LIST
140860: LIST
140861: PUSH
140862: EMPTY
140863: LIST
140864: LIST
140865: LIST
140866: PPUSH
140867: CALL_OW 72
140871: ST_TO_ADDR
// if z then
140872: LD_VAR 0 13
140876: IFFALSE 140922
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
140878: LD_VAR 0 4
140882: PUSH
140883: LD_VAR 0 7
140887: ARRAY
140888: PPUSH
140889: LD_VAR 0 13
140893: PPUSH
140894: LD_VAR 0 4
140898: PUSH
140899: LD_VAR 0 7
140903: ARRAY
140904: PPUSH
140905: CALL_OW 74
140909: PPUSH
140910: CALL_OW 115
// attacking := true ;
140914: LD_ADDR_VAR 0 29
140918: PUSH
140919: LD_INT 1
140921: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
140922: LD_VAR 0 4
140926: PUSH
140927: LD_VAR 0 7
140931: ARRAY
140932: PPUSH
140933: CALL_OW 256
140937: PUSH
140938: LD_INT 500
140940: LESS
140941: IFFALSE 140967
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
140943: LD_VAR 0 4
140947: PUSH
140948: LD_VAR 0 7
140952: ARRAY
140953: PPUSH
140954: LD_VAR 0 14
140958: PUSH
140959: LD_INT 1
140961: ARRAY
140962: PPUSH
140963: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
140967: LD_VAR 0 4
140971: PUSH
140972: LD_VAR 0 7
140976: ARRAY
140977: PPUSH
140978: CALL_OW 264
140982: PUSH
140983: LD_INT 49
140985: EQUAL
140986: IFFALSE 141107
// begin if not HasTask ( group [ i ] ) then
140988: LD_VAR 0 4
140992: PUSH
140993: LD_VAR 0 7
140997: ARRAY
140998: PPUSH
140999: CALL_OW 314
141003: NOT
141004: IFFALSE 141107
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
141006: LD_ADDR_VAR 0 9
141010: PUSH
141011: LD_INT 81
141013: PUSH
141014: LD_VAR 0 4
141018: PUSH
141019: LD_VAR 0 7
141023: ARRAY
141024: PPUSH
141025: CALL_OW 255
141029: PUSH
141030: EMPTY
141031: LIST
141032: LIST
141033: PPUSH
141034: CALL_OW 69
141038: PPUSH
141039: LD_VAR 0 4
141043: PUSH
141044: LD_VAR 0 7
141048: ARRAY
141049: PPUSH
141050: CALL_OW 74
141054: ST_TO_ADDR
// if k then
141055: LD_VAR 0 9
141059: IFFALSE 141107
// if GetDistUnits ( group [ i ] , k ) > 10 then
141061: LD_VAR 0 4
141065: PUSH
141066: LD_VAR 0 7
141070: ARRAY
141071: PPUSH
141072: LD_VAR 0 9
141076: PPUSH
141077: CALL_OW 296
141081: PUSH
141082: LD_INT 10
141084: GREATER
141085: IFFALSE 141107
// ComMoveUnit ( group [ i ] , k ) ;
141087: LD_VAR 0 4
141091: PUSH
141092: LD_VAR 0 7
141096: ARRAY
141097: PPUSH
141098: LD_VAR 0 9
141102: PPUSH
141103: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
141107: LD_VAR 0 4
141111: PUSH
141112: LD_VAR 0 7
141116: ARRAY
141117: PPUSH
141118: CALL_OW 256
141122: PUSH
141123: LD_INT 250
141125: LESS
141126: IFFALSE 141170
141128: PUSH
141129: LD_VAR 0 4
141133: PUSH
141134: LD_VAR 0 7
141138: ARRAY
141139: PUSH
141140: LD_INT 21
141142: PUSH
141143: LD_INT 2
141145: PUSH
141146: EMPTY
141147: LIST
141148: LIST
141149: PUSH
141150: LD_INT 23
141152: PUSH
141153: LD_INT 2
141155: PUSH
141156: EMPTY
141157: LIST
141158: LIST
141159: PUSH
141160: EMPTY
141161: LIST
141162: LIST
141163: PPUSH
141164: CALL_OW 69
141168: IN
141169: AND
141170: IFFALSE 141297
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
141172: LD_ADDR_VAR 0 9
141176: PUSH
141177: LD_OWVAR 3
141181: PUSH
141182: LD_VAR 0 4
141186: PUSH
141187: LD_VAR 0 7
141191: ARRAY
141192: DIFF
141193: PPUSH
141194: LD_VAR 0 4
141198: PUSH
141199: LD_VAR 0 7
141203: ARRAY
141204: PPUSH
141205: CALL_OW 74
141209: ST_TO_ADDR
// if not k then
141210: LD_VAR 0 9
141214: NOT
141215: IFFALSE 141219
// continue ;
141217: GO 137592
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
141219: LD_VAR 0 9
141223: PUSH
141224: LD_INT 81
141226: PUSH
141227: LD_VAR 0 4
141231: PUSH
141232: LD_VAR 0 7
141236: ARRAY
141237: PPUSH
141238: CALL_OW 255
141242: PUSH
141243: EMPTY
141244: LIST
141245: LIST
141246: PPUSH
141247: CALL_OW 69
141251: IN
141252: IFFALSE 141280
141254: PUSH
141255: LD_VAR 0 9
141259: PPUSH
141260: LD_VAR 0 4
141264: PUSH
141265: LD_VAR 0 7
141269: ARRAY
141270: PPUSH
141271: CALL_OW 296
141275: PUSH
141276: LD_INT 5
141278: LESS
141279: AND
141280: IFFALSE 141297
// ComAutodestruct ( group [ i ] ) ;
141282: LD_VAR 0 4
141286: PUSH
141287: LD_VAR 0 7
141291: ARRAY
141292: PPUSH
141293: CALL 104446 0 1
// end ; if f_attack_depot then
141297: LD_VAR 0 25
141301: IFFALSE 141413
// begin k := 6 ;
141303: LD_ADDR_VAR 0 9
141307: PUSH
141308: LD_INT 6
141310: ST_TO_ADDR
// if tmp < k then
141311: LD_VAR 0 14
141315: PUSH
141316: LD_VAR 0 9
141320: LESS
141321: IFFALSE 141333
// k := tmp ;
141323: LD_ADDR_VAR 0 9
141327: PUSH
141328: LD_VAR 0 14
141332: ST_TO_ADDR
// for j = 1 to k do
141333: LD_ADDR_VAR 0 8
141337: PUSH
141338: DOUBLE
141339: LD_INT 1
141341: DEC
141342: ST_TO_ADDR
141343: LD_VAR 0 9
141347: PUSH
141348: FOR_TO
141349: IFFALSE 141411
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
141351: LD_VAR 0 8
141355: PPUSH
141356: CALL_OW 266
141360: PUSH
141361: LD_INT 0
141363: PUSH
141364: LD_INT 1
141366: PUSH
141367: EMPTY
141368: LIST
141369: LIST
141370: IN
141371: IFFALSE 141409
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
141373: LD_VAR 0 4
141377: PUSH
141378: LD_VAR 0 7
141382: ARRAY
141383: PPUSH
141384: LD_VAR 0 14
141388: PUSH
141389: LD_VAR 0 8
141393: ARRAY
141394: PPUSH
141395: CALL_OW 115
// attacking := true ;
141399: LD_ADDR_VAR 0 29
141403: PUSH
141404: LD_INT 1
141406: ST_TO_ADDR
// break ;
141407: GO 141411
// end ;
141409: GO 141348
141411: POP
141412: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
141413: LD_VAR 0 4
141417: PUSH
141418: LD_VAR 0 7
141422: ARRAY
141423: PPUSH
141424: CALL_OW 302
141428: IFFALSE 141437
141430: PUSH
141431: LD_VAR 0 29
141435: NOT
141436: AND
141437: IFFALSE 141767
// begin if GetTag ( group [ i ] ) = 71 then
141439: LD_VAR 0 4
141443: PUSH
141444: LD_VAR 0 7
141448: ARRAY
141449: PPUSH
141450: CALL_OW 110
141454: PUSH
141455: LD_INT 71
141457: EQUAL
141458: IFFALSE 141499
// begin if HasTask ( group [ i ] ) then
141460: LD_VAR 0 4
141464: PUSH
141465: LD_VAR 0 7
141469: ARRAY
141470: PPUSH
141471: CALL_OW 314
141475: IFFALSE 141481
// continue else
141477: GO 137592
141479: GO 141499
// SetTag ( group [ i ] , 0 ) ;
141481: LD_VAR 0 4
141485: PUSH
141486: LD_VAR 0 7
141490: ARRAY
141491: PPUSH
141492: LD_INT 0
141494: PPUSH
141495: CALL_OW 109
// end ; k := 8 ;
141499: LD_ADDR_VAR 0 9
141503: PUSH
141504: LD_INT 8
141506: ST_TO_ADDR
// x := 0 ;
141507: LD_ADDR_VAR 0 10
141511: PUSH
141512: LD_INT 0
141514: ST_TO_ADDR
// if tmp < k then
141515: LD_VAR 0 14
141519: PUSH
141520: LD_VAR 0 9
141524: LESS
141525: IFFALSE 141537
// k := tmp ;
141527: LD_ADDR_VAR 0 9
141531: PUSH
141532: LD_VAR 0 14
141536: ST_TO_ADDR
// for j = 1 to k do
141537: LD_ADDR_VAR 0 8
141541: PUSH
141542: DOUBLE
141543: LD_INT 1
141545: DEC
141546: ST_TO_ADDR
141547: LD_VAR 0 9
141551: PUSH
141552: FOR_TO
141553: IFFALSE 141659
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
141555: LD_VAR 0 14
141559: PUSH
141560: LD_VAR 0 8
141564: ARRAY
141565: PPUSH
141566: CALL_OW 247
141570: PUSH
141571: LD_INT 1
141573: EQUAL
141574: IFFALSE 141637
141576: PUSH
141577: LD_VAR 0 14
141581: PUSH
141582: LD_VAR 0 8
141586: ARRAY
141587: PPUSH
141588: CALL_OW 256
141592: PUSH
141593: LD_INT 250
141595: LESS
141596: IFFALSE 141604
141598: PUSH
141599: LD_VAR 0 20
141603: AND
141604: IFTRUE 141636
141606: PUSH
141607: LD_VAR 0 20
141611: NOT
141612: IFFALSE 141635
141614: PUSH
141615: LD_VAR 0 14
141619: PUSH
141620: LD_VAR 0 8
141624: ARRAY
141625: PPUSH
141626: CALL_OW 256
141630: PUSH
141631: LD_INT 250
141633: GREATEREQUAL
141634: AND
141635: OR
141636: AND
141637: IFFALSE 141657
// begin x := tmp [ j ] ;
141639: LD_ADDR_VAR 0 10
141643: PUSH
141644: LD_VAR 0 14
141648: PUSH
141649: LD_VAR 0 8
141653: ARRAY
141654: ST_TO_ADDR
// break ;
141655: GO 141659
// end ;
141657: GO 141552
141659: POP
141660: POP
// if x then
141661: LD_VAR 0 10
141665: IFFALSE 141689
// ComAttackUnit ( group [ i ] , x ) else
141667: LD_VAR 0 4
141671: PUSH
141672: LD_VAR 0 7
141676: ARRAY
141677: PPUSH
141678: LD_VAR 0 10
141682: PPUSH
141683: CALL_OW 115
141687: GO 141713
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
141689: LD_VAR 0 4
141693: PUSH
141694: LD_VAR 0 7
141698: ARRAY
141699: PPUSH
141700: LD_VAR 0 14
141704: PUSH
141705: LD_INT 1
141707: ARRAY
141708: PPUSH
141709: CALL_OW 115
// if not HasTask ( group [ i ] ) then
141713: LD_VAR 0 4
141717: PUSH
141718: LD_VAR 0 7
141722: ARRAY
141723: PPUSH
141724: CALL_OW 314
141728: NOT
141729: IFFALSE 141767
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
141731: LD_VAR 0 4
141735: PUSH
141736: LD_VAR 0 7
141740: ARRAY
141741: PPUSH
141742: LD_VAR 0 14
141746: PPUSH
141747: LD_VAR 0 4
141751: PUSH
141752: LD_VAR 0 7
141756: ARRAY
141757: PPUSH
141758: CALL_OW 74
141762: PPUSH
141763: CALL_OW 115
// end ; end ; end ;
141767: GO 137592
141769: POP
141770: POP
// wait ( 0 0$2 ) ;
141771: LD_INT 70
141773: PPUSH
141774: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
141778: LD_VAR 0 4
141782: NOT
141783: IFTRUE 141794
141785: PUSH
141786: LD_VAR 0 4
141790: PUSH
141791: EMPTY
141792: EQUAL
141793: OR
141794: IFTRUE 141815
141796: PUSH
141797: LD_INT 81
141799: PUSH
141800: LD_VAR 0 35
141804: PUSH
141805: EMPTY
141806: LIST
141807: LIST
141808: PPUSH
141809: CALL_OW 69
141813: NOT
141814: OR
141815: IFFALSE 137577
// end ;
141817: LD_VAR 0 2
141821: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
141822: LD_INT 0
141824: PPUSH
141825: PPUSH
141826: PPUSH
141827: PPUSH
141828: PPUSH
141829: PPUSH
// if not base or not mc_bases [ base ] or not solds then
141830: LD_VAR 0 1
141834: NOT
141835: IFTRUE 141850
141837: PUSH
141838: LD_EXP 102
141842: PUSH
141843: LD_VAR 0 1
141847: ARRAY
141848: NOT
141849: OR
141850: IFTRUE 141859
141852: PUSH
141853: LD_VAR 0 2
141857: NOT
141858: OR
141859: IFFALSE 141863
// exit ;
141861: GO 142421
// side := mc_sides [ base ] ;
141863: LD_ADDR_VAR 0 6
141867: PUSH
141868: LD_EXP 128
141872: PUSH
141873: LD_VAR 0 1
141877: ARRAY
141878: ST_TO_ADDR
// if not side then
141879: LD_VAR 0 6
141883: NOT
141884: IFFALSE 141888
// exit ;
141886: GO 142421
// for i in solds do
141888: LD_ADDR_VAR 0 7
141892: PUSH
141893: LD_VAR 0 2
141897: PUSH
141898: FOR_IN
141899: IFFALSE 141960
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
141901: LD_VAR 0 7
141905: PPUSH
141906: CALL_OW 310
141910: PPUSH
141911: CALL_OW 266
141915: PUSH
141916: LD_INT 32
141918: PUSH
141919: LD_INT 31
141921: PUSH
141922: EMPTY
141923: LIST
141924: LIST
141925: IN
141926: IFFALSE 141946
// solds := solds diff i else
141928: LD_ADDR_VAR 0 2
141932: PUSH
141933: LD_VAR 0 2
141937: PUSH
141938: LD_VAR 0 7
141942: DIFF
141943: ST_TO_ADDR
141944: GO 141958
// SetTag ( i , 18 ) ;
141946: LD_VAR 0 7
141950: PPUSH
141951: LD_INT 18
141953: PPUSH
141954: CALL_OW 109
141958: GO 141898
141960: POP
141961: POP
// if not solds then
141962: LD_VAR 0 2
141966: NOT
141967: IFFALSE 141971
// exit ;
141969: GO 142421
// repeat wait ( 0 0$2 ) ;
141971: LD_INT 70
141973: PPUSH
141974: CALL_OW 67
// enemy := mc_scan [ base ] ;
141978: LD_ADDR_VAR 0 4
141982: PUSH
141983: LD_EXP 125
141987: PUSH
141988: LD_VAR 0 1
141992: ARRAY
141993: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
141994: LD_EXP 102
141998: PUSH
141999: LD_VAR 0 1
142003: ARRAY
142004: NOT
142005: IFTRUE 142022
142007: PUSH
142008: LD_EXP 102
142012: PUSH
142013: LD_VAR 0 1
142017: ARRAY
142018: PUSH
142019: EMPTY
142020: EQUAL
142021: OR
142022: IFFALSE 142059
// begin for i in solds do
142024: LD_ADDR_VAR 0 7
142028: PUSH
142029: LD_VAR 0 2
142033: PUSH
142034: FOR_IN
142035: IFFALSE 142048
// ComStop ( i ) ;
142037: LD_VAR 0 7
142041: PPUSH
142042: CALL_OW 141
142046: GO 142034
142048: POP
142049: POP
// solds := [ ] ;
142050: LD_ADDR_VAR 0 2
142054: PUSH
142055: EMPTY
142056: ST_TO_ADDR
// exit ;
142057: GO 142421
// end ; for i in solds do
142059: LD_ADDR_VAR 0 7
142063: PUSH
142064: LD_VAR 0 2
142068: PUSH
142069: FOR_IN
142070: IFFALSE 142391
// begin if IsInUnit ( i ) then
142072: LD_VAR 0 7
142076: PPUSH
142077: CALL_OW 310
142081: IFFALSE 142092
// ComExitBuilding ( i ) ;
142083: LD_VAR 0 7
142087: PPUSH
142088: CALL_OW 122
// if GetLives ( i ) > 500 then
142092: LD_VAR 0 7
142096: PPUSH
142097: CALL_OW 256
142101: PUSH
142102: LD_INT 500
142104: GREATER
142105: IFFALSE 142158
// begin e := NearestUnitToUnit ( enemy , i ) ;
142107: LD_ADDR_VAR 0 5
142111: PUSH
142112: LD_VAR 0 4
142116: PPUSH
142117: LD_VAR 0 7
142121: PPUSH
142122: CALL_OW 74
142126: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
142127: LD_VAR 0 7
142131: PPUSH
142132: LD_VAR 0 5
142136: PPUSH
142137: CALL_OW 250
142141: PPUSH
142142: LD_VAR 0 5
142146: PPUSH
142147: CALL_OW 251
142151: PPUSH
142152: CALL_OW 114
// end else
142156: GO 142389
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
142158: LD_VAR 0 7
142162: PPUSH
142163: LD_EXP 102
142167: PUSH
142168: LD_VAR 0 1
142172: ARRAY
142173: PPUSH
142174: LD_INT 2
142176: PUSH
142177: LD_INT 30
142179: PUSH
142180: LD_INT 0
142182: PUSH
142183: EMPTY
142184: LIST
142185: LIST
142186: PUSH
142187: LD_INT 30
142189: PUSH
142190: LD_INT 1
142192: PUSH
142193: EMPTY
142194: LIST
142195: LIST
142196: PUSH
142197: LD_INT 30
142199: PUSH
142200: LD_INT 6
142202: PUSH
142203: EMPTY
142204: LIST
142205: LIST
142206: PUSH
142207: EMPTY
142208: LIST
142209: LIST
142210: LIST
142211: LIST
142212: PPUSH
142213: CALL_OW 72
142217: PPUSH
142218: LD_VAR 0 7
142222: PPUSH
142223: CALL_OW 74
142227: PPUSH
142228: CALL_OW 296
142232: PUSH
142233: LD_INT 10
142235: GREATER
142236: IFFALSE 142389
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
142238: LD_ADDR_VAR 0 8
142242: PUSH
142243: LD_EXP 102
142247: PUSH
142248: LD_VAR 0 1
142252: ARRAY
142253: PPUSH
142254: LD_INT 2
142256: PUSH
142257: LD_INT 30
142259: PUSH
142260: LD_INT 0
142262: PUSH
142263: EMPTY
142264: LIST
142265: LIST
142266: PUSH
142267: LD_INT 30
142269: PUSH
142270: LD_INT 1
142272: PUSH
142273: EMPTY
142274: LIST
142275: LIST
142276: PUSH
142277: LD_INT 30
142279: PUSH
142280: LD_INT 6
142282: PUSH
142283: EMPTY
142284: LIST
142285: LIST
142286: PUSH
142287: EMPTY
142288: LIST
142289: LIST
142290: LIST
142291: LIST
142292: PPUSH
142293: CALL_OW 72
142297: PPUSH
142298: LD_VAR 0 7
142302: PPUSH
142303: CALL_OW 74
142307: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
142308: LD_VAR 0 7
142312: PPUSH
142313: LD_VAR 0 8
142317: PPUSH
142318: CALL_OW 250
142322: PPUSH
142323: LD_INT 3
142325: PPUSH
142326: LD_INT 5
142328: PPUSH
142329: CALL_OW 272
142333: PPUSH
142334: LD_VAR 0 8
142338: PPUSH
142339: CALL_OW 251
142343: PPUSH
142344: LD_INT 3
142346: PPUSH
142347: LD_INT 5
142349: PPUSH
142350: CALL_OW 273
142354: PPUSH
142355: CALL_OW 111
// SetTag ( i , 0 ) ;
142359: LD_VAR 0 7
142363: PPUSH
142364: LD_INT 0
142366: PPUSH
142367: CALL_OW 109
// solds := solds diff i ;
142371: LD_ADDR_VAR 0 2
142375: PUSH
142376: LD_VAR 0 2
142380: PUSH
142381: LD_VAR 0 7
142385: DIFF
142386: ST_TO_ADDR
// continue ;
142387: GO 142069
// end ; end ;
142389: GO 142069
142391: POP
142392: POP
// until not solds or not enemy ;
142393: LD_VAR 0 2
142397: NOT
142398: IFTRUE 142407
142400: PUSH
142401: LD_VAR 0 4
142405: NOT
142406: OR
142407: IFFALSE 141971
// MC_Reset ( base , 18 ) ;
142409: LD_VAR 0 1
142413: PPUSH
142414: LD_INT 18
142416: PPUSH
142417: CALL 44046 0 2
// end ;
142421: LD_VAR 0 3
142425: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
142426: LD_INT 0
142428: PPUSH
142429: PPUSH
142430: PPUSH
142431: PPUSH
142432: PPUSH
142433: PPUSH
142434: PPUSH
142435: PPUSH
142436: PPUSH
142437: PPUSH
142438: PPUSH
142439: PPUSH
142440: PPUSH
142441: PPUSH
142442: PPUSH
142443: PPUSH
142444: PPUSH
142445: PPUSH
142446: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
142447: LD_ADDR_VAR 0 12
142451: PUSH
142452: LD_EXP 102
142456: PUSH
142457: LD_VAR 0 1
142461: ARRAY
142462: PPUSH
142463: LD_INT 25
142465: PUSH
142466: LD_INT 3
142468: PUSH
142469: EMPTY
142470: LIST
142471: LIST
142472: PPUSH
142473: CALL_OW 72
142477: ST_TO_ADDR
// if mc_remote_driver [ base ] then
142478: LD_EXP 142
142482: PUSH
142483: LD_VAR 0 1
142487: ARRAY
142488: IFFALSE 142512
// mechs := mechs diff mc_remote_driver [ base ] ;
142490: LD_ADDR_VAR 0 12
142494: PUSH
142495: LD_VAR 0 12
142499: PUSH
142500: LD_EXP 142
142504: PUSH
142505: LD_VAR 0 1
142509: ARRAY
142510: DIFF
142511: ST_TO_ADDR
// for i in mechs do
142512: LD_ADDR_VAR 0 4
142516: PUSH
142517: LD_VAR 0 12
142521: PUSH
142522: FOR_IN
142523: IFFALSE 142558
// if GetTag ( i ) > 0 then
142525: LD_VAR 0 4
142529: PPUSH
142530: CALL_OW 110
142534: PUSH
142535: LD_INT 0
142537: GREATER
142538: IFFALSE 142556
// mechs := mechs diff i ;
142540: LD_ADDR_VAR 0 12
142544: PUSH
142545: LD_VAR 0 12
142549: PUSH
142550: LD_VAR 0 4
142554: DIFF
142555: ST_TO_ADDR
142556: GO 142522
142558: POP
142559: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
142560: LD_ADDR_VAR 0 8
142564: PUSH
142565: LD_EXP 102
142569: PUSH
142570: LD_VAR 0 1
142574: ARRAY
142575: PPUSH
142576: LD_INT 2
142578: PUSH
142579: LD_INT 25
142581: PUSH
142582: LD_INT 1
142584: PUSH
142585: EMPTY
142586: LIST
142587: LIST
142588: PUSH
142589: LD_INT 25
142591: PUSH
142592: LD_INT 5
142594: PUSH
142595: EMPTY
142596: LIST
142597: LIST
142598: PUSH
142599: LD_INT 25
142601: PUSH
142602: LD_INT 8
142604: PUSH
142605: EMPTY
142606: LIST
142607: LIST
142608: PUSH
142609: LD_INT 25
142611: PUSH
142612: LD_INT 9
142614: PUSH
142615: EMPTY
142616: LIST
142617: LIST
142618: PUSH
142619: EMPTY
142620: LIST
142621: LIST
142622: LIST
142623: LIST
142624: LIST
142625: PPUSH
142626: CALL_OW 72
142630: ST_TO_ADDR
// if not defenders and not solds then
142631: LD_VAR 0 2
142635: NOT
142636: IFFALSE 142645
142638: PUSH
142639: LD_VAR 0 8
142643: NOT
142644: AND
142645: IFFALSE 142649
// exit ;
142647: GO 144471
// depot_under_attack := false ;
142649: LD_ADDR_VAR 0 16
142653: PUSH
142654: LD_INT 0
142656: ST_TO_ADDR
// sold_defenders := [ ] ;
142657: LD_ADDR_VAR 0 17
142661: PUSH
142662: EMPTY
142663: ST_TO_ADDR
// if mechs then
142664: LD_VAR 0 12
142668: IFFALSE 142823
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
142670: LD_ADDR_VAR 0 4
142674: PUSH
142675: LD_VAR 0 2
142679: PPUSH
142680: LD_INT 21
142682: PUSH
142683: LD_INT 2
142685: PUSH
142686: EMPTY
142687: LIST
142688: LIST
142689: PPUSH
142690: CALL_OW 72
142694: PUSH
142695: FOR_IN
142696: IFFALSE 142821
// begin if GetTag ( i ) <> 20 then
142698: LD_VAR 0 4
142702: PPUSH
142703: CALL_OW 110
142707: PUSH
142708: LD_INT 20
142710: NONEQUAL
142711: IFFALSE 142725
// SetTag ( i , 20 ) ;
142713: LD_VAR 0 4
142717: PPUSH
142718: LD_INT 20
142720: PPUSH
142721: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
142725: LD_VAR 0 4
142729: PPUSH
142730: CALL_OW 263
142734: PUSH
142735: LD_INT 1
142737: EQUAL
142738: IFFALSE 142752
142740: PUSH
142741: LD_VAR 0 4
142745: PPUSH
142746: CALL_OW 311
142750: NOT
142751: AND
142752: IFFALSE 142819
// begin un := mechs [ 1 ] ;
142754: LD_ADDR_VAR 0 10
142758: PUSH
142759: LD_VAR 0 12
142763: PUSH
142764: LD_INT 1
142766: ARRAY
142767: ST_TO_ADDR
// ComExit ( un ) ;
142768: LD_VAR 0 10
142772: PPUSH
142773: CALL 109537 0 1
// AddComEnterUnit ( un , i ) ;
142777: LD_VAR 0 10
142781: PPUSH
142782: LD_VAR 0 4
142786: PPUSH
142787: CALL_OW 180
// SetTag ( un , 19 ) ;
142791: LD_VAR 0 10
142795: PPUSH
142796: LD_INT 19
142798: PPUSH
142799: CALL_OW 109
// mechs := mechs diff un ;
142803: LD_ADDR_VAR 0 12
142807: PUSH
142808: LD_VAR 0 12
142812: PUSH
142813: LD_VAR 0 10
142817: DIFF
142818: ST_TO_ADDR
// end ; end ;
142819: GO 142695
142821: POP
142822: POP
// if solds then
142823: LD_VAR 0 8
142827: IFFALSE 142886
// for i in solds do
142829: LD_ADDR_VAR 0 4
142833: PUSH
142834: LD_VAR 0 8
142838: PUSH
142839: FOR_IN
142840: IFFALSE 142884
// if not GetTag ( i ) then
142842: LD_VAR 0 4
142846: PPUSH
142847: CALL_OW 110
142851: NOT
142852: IFFALSE 142882
// begin defenders := defenders union i ;
142854: LD_ADDR_VAR 0 2
142858: PUSH
142859: LD_VAR 0 2
142863: PUSH
142864: LD_VAR 0 4
142868: UNION
142869: ST_TO_ADDR
// SetTag ( i , 18 ) ;
142870: LD_VAR 0 4
142874: PPUSH
142875: LD_INT 18
142877: PPUSH
142878: CALL_OW 109
// end ;
142882: GO 142839
142884: POP
142885: POP
// repeat wait ( 0 0$2 ) ;
142886: LD_INT 70
142888: PPUSH
142889: CALL_OW 67
// enemy := mc_scan [ base ] ;
142893: LD_ADDR_VAR 0 21
142897: PUSH
142898: LD_EXP 125
142902: PUSH
142903: LD_VAR 0 1
142907: ARRAY
142908: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
142909: LD_EXP 102
142913: PUSH
142914: LD_VAR 0 1
142918: ARRAY
142919: NOT
142920: IFTRUE 142937
142922: PUSH
142923: LD_EXP 102
142927: PUSH
142928: LD_VAR 0 1
142932: ARRAY
142933: PUSH
142934: EMPTY
142935: EQUAL
142936: OR
142937: IFFALSE 142974
// begin for i in defenders do
142939: LD_ADDR_VAR 0 4
142943: PUSH
142944: LD_VAR 0 2
142948: PUSH
142949: FOR_IN
142950: IFFALSE 142963
// ComStop ( i ) ;
142952: LD_VAR 0 4
142956: PPUSH
142957: CALL_OW 141
142961: GO 142949
142963: POP
142964: POP
// defenders := [ ] ;
142965: LD_ADDR_VAR 0 2
142969: PUSH
142970: EMPTY
142971: ST_TO_ADDR
// exit ;
142972: GO 144471
// end ; for i in defenders do
142974: LD_ADDR_VAR 0 4
142978: PUSH
142979: LD_VAR 0 2
142983: PUSH
142984: FOR_IN
142985: IFFALSE 143919
// begin e := NearestUnitToUnit ( enemy , i ) ;
142987: LD_ADDR_VAR 0 13
142991: PUSH
142992: LD_VAR 0 21
142996: PPUSH
142997: LD_VAR 0 4
143001: PPUSH
143002: CALL_OW 74
143006: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
143007: LD_ADDR_VAR 0 7
143011: PUSH
143012: LD_EXP 102
143016: PUSH
143017: LD_VAR 0 1
143021: ARRAY
143022: PPUSH
143023: LD_INT 2
143025: PUSH
143026: LD_INT 30
143028: PUSH
143029: LD_INT 0
143031: PUSH
143032: EMPTY
143033: LIST
143034: LIST
143035: PUSH
143036: LD_INT 30
143038: PUSH
143039: LD_INT 1
143041: PUSH
143042: EMPTY
143043: LIST
143044: LIST
143045: PUSH
143046: EMPTY
143047: LIST
143048: LIST
143049: LIST
143050: PPUSH
143051: CALL_OW 72
143055: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
143056: LD_ADDR_VAR 0 16
143060: PUSH
143061: LD_VAR 0 7
143065: NOT
143066: IFTRUE 143096
143068: PUSH
143069: LD_VAR 0 7
143073: PPUSH
143074: LD_INT 3
143076: PUSH
143077: LD_INT 24
143079: PUSH
143080: LD_INT 600
143082: PUSH
143083: EMPTY
143084: LIST
143085: LIST
143086: PUSH
143087: EMPTY
143088: LIST
143089: LIST
143090: PPUSH
143091: CALL_OW 72
143095: OR
143096: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
143097: LD_VAR 0 4
143101: PPUSH
143102: CALL_OW 247
143106: PUSH
143107: LD_INT 2
143109: DOUBLE
143110: EQUAL
143111: IFTRUE 143115
143113: GO 143531
143115: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
143116: LD_VAR 0 4
143120: PPUSH
143121: CALL_OW 256
143125: PUSH
143126: LD_INT 1000
143128: EQUAL
143129: IFFALSE 143175
143131: PUSH
143132: LD_VAR 0 4
143136: PPUSH
143137: LD_VAR 0 13
143141: PPUSH
143142: CALL_OW 296
143146: PUSH
143147: LD_INT 40
143149: LESS
143150: IFTRUE 143174
143152: PUSH
143153: LD_VAR 0 13
143157: PPUSH
143158: LD_EXP 127
143162: PUSH
143163: LD_VAR 0 1
143167: ARRAY
143168: PPUSH
143169: CALL_OW 308
143173: OR
143174: AND
143175: IFFALSE 143301
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
143177: LD_VAR 0 4
143181: PPUSH
143182: CALL_OW 262
143186: PUSH
143187: LD_INT 1
143189: EQUAL
143190: IFFALSE 143207
143192: PUSH
143193: LD_VAR 0 4
143197: PPUSH
143198: CALL_OW 261
143202: PUSH
143203: LD_INT 30
143205: LESS
143206: AND
143207: IFFALSE 143215
143209: PUSH
143210: LD_VAR 0 7
143214: AND
143215: IFFALSE 143285
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
143217: LD_VAR 0 4
143221: PPUSH
143222: LD_VAR 0 7
143226: PPUSH
143227: LD_VAR 0 4
143231: PPUSH
143232: CALL_OW 74
143236: PPUSH
143237: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
143241: LD_VAR 0 4
143245: PPUSH
143246: LD_VAR 0 7
143250: PPUSH
143251: LD_VAR 0 4
143255: PPUSH
143256: CALL_OW 74
143260: PPUSH
143261: CALL_OW 296
143265: PUSH
143266: LD_INT 6
143268: LESS
143269: IFFALSE 143283
// SetFuel ( i , 100 ) ;
143271: LD_VAR 0 4
143275: PPUSH
143276: LD_INT 100
143278: PPUSH
143279: CALL_OW 240
// end else
143283: GO 143299
// ComAttackUnit ( i , e ) ;
143285: LD_VAR 0 4
143289: PPUSH
143290: LD_VAR 0 13
143294: PPUSH
143295: CALL_OW 115
// end else
143299: GO 143408
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
143301: LD_VAR 0 13
143305: PPUSH
143306: LD_EXP 127
143310: PUSH
143311: LD_VAR 0 1
143315: ARRAY
143316: PPUSH
143317: CALL_OW 308
143321: NOT
143322: IFFALSE 143344
143324: PUSH
143325: LD_VAR 0 4
143329: PPUSH
143330: LD_VAR 0 13
143334: PPUSH
143335: CALL_OW 296
143339: PUSH
143340: LD_INT 40
143342: GREATEREQUAL
143343: AND
143344: IFTRUE 143361
143346: PUSH
143347: LD_VAR 0 4
143351: PPUSH
143352: CALL_OW 256
143356: PUSH
143357: LD_INT 650
143359: LESSEQUAL
143360: OR
143361: IFFALSE 143386
143363: PUSH
143364: LD_VAR 0 4
143368: PPUSH
143369: LD_EXP 126
143373: PUSH
143374: LD_VAR 0 1
143378: ARRAY
143379: PPUSH
143380: CALL_OW 308
143384: NOT
143385: AND
143386: IFFALSE 143408
// ComMoveToArea ( i , mc_parking [ base ] ) ;
143388: LD_VAR 0 4
143392: PPUSH
143393: LD_EXP 126
143397: PUSH
143398: LD_VAR 0 1
143402: ARRAY
143403: PPUSH
143404: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
143408: LD_VAR 0 4
143412: PPUSH
143413: CALL_OW 256
143417: PUSH
143418: LD_INT 1000
143420: LESS
143421: IFFALSE 143438
143423: PUSH
143424: LD_VAR 0 4
143428: PPUSH
143429: CALL_OW 263
143433: PUSH
143434: LD_INT 1
143436: EQUAL
143437: AND
143438: IFFALSE 143451
143440: PUSH
143441: LD_VAR 0 4
143445: PPUSH
143446: CALL_OW 311
143450: AND
143451: IFFALSE 143475
143453: PUSH
143454: LD_VAR 0 4
143458: PPUSH
143459: LD_EXP 126
143463: PUSH
143464: LD_VAR 0 1
143468: ARRAY
143469: PPUSH
143470: CALL_OW 308
143474: AND
143475: IFFALSE 143529
// begin mech := IsDrivenBy ( i ) ;
143477: LD_ADDR_VAR 0 9
143481: PUSH
143482: LD_VAR 0 4
143486: PPUSH
143487: CALL_OW 311
143491: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
143492: LD_VAR 0 9
143496: PPUSH
143497: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
143501: LD_VAR 0 9
143505: PPUSH
143506: LD_VAR 0 4
143510: PPUSH
143511: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
143515: LD_VAR 0 9
143519: PPUSH
143520: LD_VAR 0 4
143524: PPUSH
143525: CALL_OW 180
// end ; end ; unit_human :
143529: GO 143890
143531: LD_INT 1
143533: DOUBLE
143534: EQUAL
143535: IFTRUE 143539
143537: GO 143889
143539: POP
// begin b := IsInUnit ( i ) ;
143540: LD_ADDR_VAR 0 18
143544: PUSH
143545: LD_VAR 0 4
143549: PPUSH
143550: CALL_OW 310
143554: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
143555: LD_ADDR_VAR 0 19
143559: PUSH
143560: LD_VAR 0 18
143564: NOT
143565: IFTRUE 143589
143567: PUSH
143568: LD_VAR 0 18
143572: PPUSH
143573: CALL_OW 266
143577: PUSH
143578: LD_INT 32
143580: PUSH
143581: LD_INT 31
143583: PUSH
143584: EMPTY
143585: LIST
143586: LIST
143587: IN
143588: OR
143589: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
143590: LD_VAR 0 18
143594: PPUSH
143595: CALL_OW 266
143599: PUSH
143600: LD_INT 5
143602: EQUAL
143603: IFFALSE 143635
143605: PUSH
143606: LD_VAR 0 4
143610: PPUSH
143611: CALL_OW 257
143615: PUSH
143616: LD_INT 1
143618: PUSH
143619: LD_INT 2
143621: PUSH
143622: LD_INT 3
143624: PUSH
143625: LD_INT 4
143627: PUSH
143628: EMPTY
143629: LIST
143630: LIST
143631: LIST
143632: LIST
143633: IN
143634: AND
143635: IFFALSE 143672
// begin class := AllowSpecClass ( i ) ;
143637: LD_ADDR_VAR 0 20
143641: PUSH
143642: LD_VAR 0 4
143646: PPUSH
143647: CALL 72847 0 1
143651: ST_TO_ADDR
// if class then
143652: LD_VAR 0 20
143656: IFFALSE 143672
// ComChangeProfession ( i , class ) ;
143658: LD_VAR 0 4
143662: PPUSH
143663: LD_VAR 0 20
143667: PPUSH
143668: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
143672: LD_VAR 0 16
143676: IFTRUE 143703
143678: PUSH
143679: LD_VAR 0 2
143683: PPUSH
143684: LD_INT 21
143686: PUSH
143687: LD_INT 2
143689: PUSH
143690: EMPTY
143691: LIST
143692: LIST
143693: PPUSH
143694: CALL_OW 72
143698: PUSH
143699: LD_INT 1
143701: LESSEQUAL
143702: OR
143703: IFFALSE 143711
143705: PUSH
143706: LD_VAR 0 19
143710: AND
143711: IFFALSE 143726
143713: PUSH
143714: LD_VAR 0 4
143718: PUSH
143719: LD_VAR 0 17
143723: IN
143724: NOT
143725: AND
143726: IFFALSE 143821
// begin if b then
143728: LD_VAR 0 18
143732: IFFALSE 143783
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
143734: LD_VAR 0 18
143738: PPUSH
143739: LD_VAR 0 21
143743: PPUSH
143744: LD_VAR 0 18
143748: PPUSH
143749: CALL_OW 74
143753: PPUSH
143754: CALL_OW 296
143758: PUSH
143759: LD_INT 10
143761: LESS
143762: IFFALSE 143779
143764: PUSH
143765: LD_VAR 0 18
143769: PPUSH
143770: CALL_OW 461
143774: PUSH
143775: LD_INT 7
143777: NONEQUAL
143778: AND
143779: IFFALSE 143783
// continue ;
143781: GO 142984
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
143783: LD_ADDR_VAR 0 17
143787: PUSH
143788: LD_VAR 0 17
143792: PPUSH
143793: LD_VAR 0 17
143797: PUSH
143798: LD_INT 1
143800: PLUS
143801: PPUSH
143802: LD_VAR 0 4
143806: PPUSH
143807: CALL_OW 1
143811: ST_TO_ADDR
// ComExitBuilding ( i ) ;
143812: LD_VAR 0 4
143816: PPUSH
143817: CALL_OW 122
// end ; if sold_defenders then
143821: LD_VAR 0 17
143825: IFFALSE 143887
// if i in sold_defenders then
143827: LD_VAR 0 4
143831: PUSH
143832: LD_VAR 0 17
143836: IN
143837: IFFALSE 143887
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
143839: LD_VAR 0 4
143843: PPUSH
143844: CALL_OW 314
143848: NOT
143849: IFFALSE 143871
143851: PUSH
143852: LD_VAR 0 4
143856: PPUSH
143857: LD_VAR 0 13
143861: PPUSH
143862: CALL_OW 296
143866: PUSH
143867: LD_INT 30
143869: LESS
143870: AND
143871: IFFALSE 143887
// ComAttackUnit ( i , e ) ;
143873: LD_VAR 0 4
143877: PPUSH
143878: LD_VAR 0 13
143882: PPUSH
143883: CALL_OW 115
// end ; end ; end ;
143887: GO 143890
143889: POP
// if IsDead ( i ) then
143890: LD_VAR 0 4
143894: PPUSH
143895: CALL_OW 301
143899: IFFALSE 143917
// defenders := defenders diff i ;
143901: LD_ADDR_VAR 0 2
143905: PUSH
143906: LD_VAR 0 2
143910: PUSH
143911: LD_VAR 0 4
143915: DIFF
143916: ST_TO_ADDR
// end ;
143917: GO 142984
143919: POP
143920: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
143921: LD_VAR 0 21
143925: NOT
143926: IFTRUE 143935
143928: PUSH
143929: LD_VAR 0 2
143933: NOT
143934: OR
143935: IFTRUE 143950
143937: PUSH
143938: LD_EXP 102
143942: PUSH
143943: LD_VAR 0 1
143947: ARRAY
143948: NOT
143949: OR
143950: IFFALSE 142886
// MC_Reset ( base , 18 ) ;
143952: LD_VAR 0 1
143956: PPUSH
143957: LD_INT 18
143959: PPUSH
143960: CALL 44046 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
143964: LD_ADDR_VAR 0 2
143968: PUSH
143969: LD_VAR 0 2
143973: PUSH
143974: LD_VAR 0 2
143978: PPUSH
143979: LD_INT 2
143981: PUSH
143982: LD_INT 25
143984: PUSH
143985: LD_INT 1
143987: PUSH
143988: EMPTY
143989: LIST
143990: LIST
143991: PUSH
143992: LD_INT 25
143994: PUSH
143995: LD_INT 5
143997: PUSH
143998: EMPTY
143999: LIST
144000: LIST
144001: PUSH
144002: LD_INT 25
144004: PUSH
144005: LD_INT 8
144007: PUSH
144008: EMPTY
144009: LIST
144010: LIST
144011: PUSH
144012: LD_INT 25
144014: PUSH
144015: LD_INT 9
144017: PUSH
144018: EMPTY
144019: LIST
144020: LIST
144021: PUSH
144022: EMPTY
144023: LIST
144024: LIST
144025: LIST
144026: LIST
144027: LIST
144028: PPUSH
144029: CALL_OW 72
144033: DIFF
144034: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
144035: LD_VAR 0 21
144039: NOT
144040: IFFALSE 144063
144042: PUSH
144043: LD_VAR 0 2
144047: PPUSH
144048: LD_INT 21
144050: PUSH
144051: LD_INT 2
144053: PUSH
144054: EMPTY
144055: LIST
144056: LIST
144057: PPUSH
144058: CALL_OW 72
144062: AND
144063: IFFALSE 144407
// begin tmp := FilterByTag ( defenders , 19 ) ;
144065: LD_ADDR_VAR 0 11
144069: PUSH
144070: LD_VAR 0 2
144074: PPUSH
144075: LD_INT 19
144077: PPUSH
144078: CALL 106684 0 2
144082: ST_TO_ADDR
// if tmp then
144083: LD_VAR 0 11
144087: IFFALSE 144157
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
144089: LD_ADDR_VAR 0 11
144093: PUSH
144094: LD_VAR 0 11
144098: PPUSH
144099: LD_INT 25
144101: PUSH
144102: LD_INT 3
144104: PUSH
144105: EMPTY
144106: LIST
144107: LIST
144108: PPUSH
144109: CALL_OW 72
144113: ST_TO_ADDR
// if tmp then
144114: LD_VAR 0 11
144118: IFFALSE 144157
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
144120: LD_ADDR_EXP 114
144124: PUSH
144125: LD_EXP 114
144129: PPUSH
144130: LD_VAR 0 1
144134: PPUSH
144135: LD_EXP 114
144139: PUSH
144140: LD_VAR 0 1
144144: ARRAY
144145: PUSH
144146: LD_VAR 0 11
144150: UNION
144151: PPUSH
144152: CALL_OW 1
144156: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
144157: LD_VAR 0 1
144161: PPUSH
144162: LD_INT 19
144164: PPUSH
144165: CALL 44046 0 2
// repeat wait ( 0 0$1 ) ;
144169: LD_INT 35
144171: PPUSH
144172: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
144176: LD_EXP 102
144180: PUSH
144181: LD_VAR 0 1
144185: ARRAY
144186: NOT
144187: IFTRUE 144204
144189: PUSH
144190: LD_EXP 102
144194: PUSH
144195: LD_VAR 0 1
144199: ARRAY
144200: PUSH
144201: EMPTY
144202: EQUAL
144203: OR
144204: IFFALSE 144241
// begin for i in defenders do
144206: LD_ADDR_VAR 0 4
144210: PUSH
144211: LD_VAR 0 2
144215: PUSH
144216: FOR_IN
144217: IFFALSE 144230
// ComStop ( i ) ;
144219: LD_VAR 0 4
144223: PPUSH
144224: CALL_OW 141
144228: GO 144216
144230: POP
144231: POP
// defenders := [ ] ;
144232: LD_ADDR_VAR 0 2
144236: PUSH
144237: EMPTY
144238: ST_TO_ADDR
// exit ;
144239: GO 144471
// end ; for i in defenders do
144241: LD_ADDR_VAR 0 4
144245: PUSH
144246: LD_VAR 0 2
144250: PUSH
144251: FOR_IN
144252: IFFALSE 144341
// begin if not IsInArea ( i , mc_parking [ base ] ) then
144254: LD_VAR 0 4
144258: PPUSH
144259: LD_EXP 126
144263: PUSH
144264: LD_VAR 0 1
144268: ARRAY
144269: PPUSH
144270: CALL_OW 308
144274: NOT
144275: IFFALSE 144299
// ComMoveToArea ( i , mc_parking [ base ] ) else
144277: LD_VAR 0 4
144281: PPUSH
144282: LD_EXP 126
144286: PUSH
144287: LD_VAR 0 1
144291: ARRAY
144292: PPUSH
144293: CALL_OW 113
144297: GO 144339
// if GetControl ( i ) = control_manual then
144299: LD_VAR 0 4
144303: PPUSH
144304: CALL_OW 263
144308: PUSH
144309: LD_INT 1
144311: EQUAL
144312: IFFALSE 144339
// if IsDrivenBy ( i ) then
144314: LD_VAR 0 4
144318: PPUSH
144319: CALL_OW 311
144323: IFFALSE 144339
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
144325: LD_VAR 0 4
144329: PPUSH
144330: CALL_OW 311
144334: PPUSH
144335: CALL_OW 121
// end ;
144339: GO 144251
144341: POP
144342: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
144343: LD_VAR 0 2
144347: PPUSH
144348: LD_INT 95
144350: PUSH
144351: LD_EXP 126
144355: PUSH
144356: LD_VAR 0 1
144360: ARRAY
144361: PUSH
144362: EMPTY
144363: LIST
144364: LIST
144365: PPUSH
144366: CALL_OW 72
144370: PUSH
144371: LD_VAR 0 2
144375: EQUAL
144376: IFTRUE 144390
144378: PUSH
144379: LD_EXP 125
144383: PUSH
144384: LD_VAR 0 1
144388: ARRAY
144389: OR
144390: IFTRUE 144405
144392: PUSH
144393: LD_EXP 102
144397: PUSH
144398: LD_VAR 0 1
144402: ARRAY
144403: NOT
144404: OR
144405: IFFALSE 144169
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
144407: LD_ADDR_EXP 124
144411: PUSH
144412: LD_EXP 124
144416: PPUSH
144417: LD_VAR 0 1
144421: PPUSH
144422: LD_VAR 0 2
144426: PPUSH
144427: LD_INT 21
144429: PUSH
144430: LD_INT 2
144432: PUSH
144433: EMPTY
144434: LIST
144435: LIST
144436: PPUSH
144437: CALL_OW 72
144441: PPUSH
144442: CALL_OW 1
144446: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
144447: LD_VAR 0 1
144451: PPUSH
144452: LD_INT 19
144454: PPUSH
144455: CALL 44046 0 2
// MC_Reset ( base , 20 ) ;
144459: LD_VAR 0 1
144463: PPUSH
144464: LD_INT 20
144466: PPUSH
144467: CALL 44046 0 2
// end ; end_of_file
144471: LD_VAR 0 3
144475: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
144476: LD_VAR 0 1
144480: PUSH
144481: LD_INT 200
144483: DOUBLE
144484: GREATEREQUAL
144485: IFFALSE 144493
144487: LD_INT 299
144489: DOUBLE
144490: LESSEQUAL
144491: IFTRUE 144495
144493: GO 144527
144495: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
144496: LD_VAR 0 1
144500: PPUSH
144501: LD_VAR 0 2
144505: PPUSH
144506: LD_VAR 0 3
144510: PPUSH
144511: LD_VAR 0 4
144515: PPUSH
144516: LD_VAR 0 5
144520: PPUSH
144521: CALL 131329 0 5
144525: GO 144604
144527: LD_INT 300
144529: DOUBLE
144530: GREATEREQUAL
144531: IFFALSE 144539
144533: LD_INT 399
144535: DOUBLE
144536: LESSEQUAL
144537: IFTRUE 144541
144539: GO 144603
144541: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
144542: LD_VAR 0 1
144546: PPUSH
144547: LD_VAR 0 2
144551: PPUSH
144552: LD_VAR 0 3
144556: PPUSH
144557: LD_VAR 0 4
144561: PPUSH
144562: LD_VAR 0 5
144566: PPUSH
144567: LD_VAR 0 6
144571: PPUSH
144572: LD_VAR 0 7
144576: PPUSH
144577: LD_VAR 0 8
144581: PPUSH
144582: LD_VAR 0 9
144586: PPUSH
144587: LD_VAR 0 10
144591: PPUSH
144592: LD_VAR 0 11
144596: PPUSH
144597: CALL 127132 0 11
144601: GO 144604
144603: POP
// end ;
144604: PPOPN 11
144606: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
144607: LD_VAR 0 1
144611: PPUSH
144612: LD_VAR 0 2
144616: PPUSH
144617: LD_VAR 0 3
144621: PPUSH
144622: LD_VAR 0 4
144626: PPUSH
144627: LD_VAR 0 5
144631: PPUSH
144632: CALL 130629 0 5
// end ; end_of_file
144636: PPOPN 5
144638: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
144639: LD_VAR 0 1
144643: PPUSH
144644: LD_VAR 0 2
144648: PPUSH
144649: LD_VAR 0 3
144653: PPUSH
144654: LD_VAR 0 4
144658: PPUSH
144659: LD_VAR 0 5
144663: PPUSH
144664: LD_VAR 0 6
144668: PPUSH
144669: CALL 114672 0 6
// end ;
144673: PPOPN 6
144675: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
144676: LD_INT 0
144678: PPUSH
// begin if not units then
144679: LD_VAR 0 1
144683: NOT
144684: IFFALSE 144688
// exit ;
144686: GO 144722
// SOS_CommPanelCommandWeapon ( units , p1 , p2 , p3 , p4 , p5 ) ;
144688: LD_VAR 0 1
144692: PPUSH
144693: LD_VAR 0 2
144697: PPUSH
144698: LD_VAR 0 3
144702: PPUSH
144703: LD_VAR 0 4
144707: PPUSH
144708: LD_VAR 0 5
144712: PPUSH
144713: LD_VAR 0 6
144717: PPUSH
144718: CALL 137026 0 6
// end ;
144722: PPOPN 7
144724: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
144725: CALL 114552 0 0
// end ;
144729: PPOPN 1
144731: END
