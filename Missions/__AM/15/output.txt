// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33908 0 0
// InitNature ;
  19: CALL 33732 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10881 0 0
// PrepareRussian ;
  40: CALL 6874 0 0
// PrepareLegion ;
  44: CALL 4114 0 0
// PreparePowell ;
  48: CALL 2868 0 0
// PrepareAmerican ;
  52: CALL 1640 0 0
// Action ;
  56: CALL 14788 0 0
// MC_Start ( ) ;
  60: CALL 36020 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 58185 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 58278 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57628 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 57443 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 58185 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 58278 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 22
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 52
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 22
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 52
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_INT 24
 792: PUSH
 793: LD_INT 3
 795: PUSH
 796: LD_INT 3
 798: PUSH
 799: LD_INT 47
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: LIST
 806: LIST
 807: PUSH
 808: LD_INT 24
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 3
 816: PUSH
 817: LD_INT 47
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: LIST
 835: PPUSH
 836: CALL 57443 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 840: LD_INT 2
 842: PPUSH
 843: LD_INT 5
 845: PPUSH
 846: CALL 57628 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 850: LD_INT 2
 852: PPUSH
 853: LD_INT 0
 855: PPUSH
 856: CALL 58058 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 860: LD_INT 3
 862: PPUSH
 863: LD_INT 10
 865: PUSH
 866: LD_INT 12
 868: PUSH
 869: LD_INT 15
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: LIST
 876: PUSH
 877: LD_OWVAR 67
 881: ARRAY
 882: PPUSH
 883: LD_INT 27
 885: PPUSH
 886: CALL 57125 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 890: LD_INT 3
 892: PPUSH
 893: LD_INT 10
 895: PUSH
 896: LD_INT 11
 898: PUSH
 899: LD_INT 13
 901: PUSH
 902: LD_INT 15
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: PPUSH
 911: CALL 58185 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 915: LD_INT 3
 917: PPUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: PPUSH
 924: CALL 58278 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 928: LD_ADDR_EXP 128
 932: PUSH
 933: LD_EXP 128
 937: PPUSH
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 22
 943: PUSH
 944: LD_INT 8
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: PUSH
 951: LD_INT 25
 953: PUSH
 954: LD_INT 15
 956: PUSH
 957: EMPTY
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PPUSH
 965: CALL_OW 69
 969: PPUSH
 970: CALL_OW 1
 974: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 975: LD_INT 3
 977: PPUSH
 978: LD_INT 13
 980: PUSH
 981: LD_INT 2
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 31
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 13
 998: PUSH
 999: LD_INT 2
1001: PUSH
1002: LD_INT 1
1004: PUSH
1005: LD_INT 31
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 13
1016: PUSH
1017: LD_INT 3
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 32
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PPUSH
1037: CALL 57443 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1041: LD_INT 4
1043: PPUSH
1044: LD_INT 10
1046: PUSH
1047: LD_INT 12
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: PPUSH
1054: CALL 58185 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1058: LD_INT 4
1060: PPUSH
1061: LD_INT 9
1063: PUSH
1064: EMPTY
1065: LIST
1066: PPUSH
1067: CALL 58278 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1071: LD_INT 4
1073: PPUSH
1074: LD_INT 26
1076: PUSH
1077: LD_INT 74
1079: PUSH
1080: LD_INT 107
1082: PUSH
1083: LD_INT 0
1085: PUSH
1086: EMPTY
1087: LIST
1088: LIST
1089: LIST
1090: LIST
1091: PUSH
1092: LD_INT 32
1094: PUSH
1095: LD_INT 77
1097: PUSH
1098: LD_INT 101
1100: PUSH
1101: LD_INT 4
1103: PUSH
1104: EMPTY
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 32
1112: PUSH
1113: LD_INT 69
1115: PUSH
1116: LD_INT 86
1118: PUSH
1119: LD_INT 4
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 77
1133: PUSH
1134: LD_INT 110
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 27
1148: PUSH
1149: LD_INT 42
1151: PUSH
1152: LD_INT 79
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: LD_INT 29
1166: PUSH
1167: LD_INT 86
1169: PUSH
1170: LD_INT 105
1172: PUSH
1173: LD_INT 2
1175: PUSH
1176: EMPTY
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PUSH
1182: LD_INT 30
1184: PUSH
1185: LD_INT 40
1187: PUSH
1188: LD_INT 75
1190: PUSH
1191: LD_INT 1
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: LIST
1198: LIST
1199: PUSH
1200: LD_INT 32
1202: PUSH
1203: LD_INT 80
1205: PUSH
1206: LD_INT 106
1208: PUSH
1209: LD_INT 4
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 32
1220: PUSH
1221: LD_INT 75
1223: PUSH
1224: LD_INT 114
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: PUSH
1236: LD_INT 32
1238: PUSH
1239: LD_INT 82
1241: PUSH
1242: LD_INT 110
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_INT 32
1256: PUSH
1257: LD_INT 62
1259: PUSH
1260: LD_INT 78
1262: PUSH
1263: LD_INT 4
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: PUSH
1272: LD_INT 4
1274: PUSH
1275: LD_INT 39
1277: PUSH
1278: LD_INT 61
1280: PUSH
1281: LD_INT 3
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: LIST
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: PPUSH
1304: CALL 57335 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1308: LD_INT 4
1310: PPUSH
1311: LD_INT 5
1313: PUSH
1314: LD_INT 6
1316: PUSH
1317: LD_INT 7
1319: PUSH
1320: LD_INT 9
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: PPUSH
1329: CALL 58596 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1333: LD_INT 4
1335: PPUSH
1336: LD_INT 40
1338: PUSH
1339: LD_INT 75
1341: PUSH
1342: LD_INT 1
1344: PUSH
1345: EMPTY
1346: LIST
1347: LIST
1348: LIST
1349: PUSH
1350: LD_INT 86
1352: PUSH
1353: LD_INT 105
1355: PUSH
1356: LD_INT 0
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PPUSH
1368: CALL 57767 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1372: LD_INT 4
1374: PPUSH
1375: LD_INT 2
1377: PPUSH
1378: CALL 58058 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 0
1387: PPUSH
1388: CALL 58058 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1392: LD_INT 4
1394: PPUSH
1395: LD_INT 54
1397: PPUSH
1398: LD_INT 85
1400: PPUSH
1401: LD_INT 2
1403: PPUSH
1404: LD_INT 19
1406: PUSH
1407: LD_INT 16
1409: PUSH
1410: LD_INT 17
1412: PUSH
1413: LD_INT 18
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: PPUSH
1422: CALL 58390 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1426: LD_INT 4
1428: PPUSH
1429: LD_INT 3
1431: PUSH
1432: LD_INT 1
1434: PUSH
1435: LD_INT 1
1437: PUSH
1438: LD_INT 5
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: PUSH
1447: LD_INT 4
1449: PUSH
1450: LD_INT 1
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: LD_INT 6
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: PUSH
1465: LD_INT 4
1467: PUSH
1468: LD_INT 1
1470: PUSH
1471: LD_INT 1
1473: PUSH
1474: LD_INT 7
1476: PUSH
1477: EMPTY
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: PUSH
1483: LD_INT 4
1485: PUSH
1486: LD_INT 1
1488: PUSH
1489: LD_INT 1
1491: PUSH
1492: LD_INT 6
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: LIST
1499: LIST
1500: PUSH
1501: EMPTY
1502: LIST
1503: LIST
1504: LIST
1505: LIST
1506: PPUSH
1507: CALL 57443 0 2
// MC_SetTame ( 4 , powellApe ) ;
1511: LD_INT 4
1513: PPUSH
1514: LD_INT 13
1516: PPUSH
1517: CALL 58009 0 2
// end ;
1521: LD_VAR 0 1
1525: RET
// every 0 0$1 trigger debug do var i , tmp ;
1526: LD_EXP 1
1530: IFFALSE 1637
1532: GO 1534
1534: DISABLE
1535: LD_INT 0
1537: PPUSH
1538: PPUSH
// begin enable ;
1539: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1540: LD_ADDR_VAR 0 2
1544: PUSH
1545: LD_INT 22
1547: PUSH
1548: LD_INT 1
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 3
1557: PUSH
1558: LD_INT 21
1560: PUSH
1561: LD_INT 3
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PUSH
1572: LD_INT 3
1574: PUSH
1575: LD_INT 24
1577: PUSH
1578: LD_INT 999
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PUSH
1585: EMPTY
1586: LIST
1587: LIST
1588: PUSH
1589: EMPTY
1590: LIST
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 69
1598: ST_TO_ADDR
// if not tmp then
1599: LD_VAR 0 2
1603: NOT
1604: IFFALSE 1608
// exit ;
1606: GO 1637
// for i in tmp do
1608: LD_ADDR_VAR 0 1
1612: PUSH
1613: LD_VAR 0 2
1617: PUSH
1618: FOR_IN
1619: IFFALSE 1635
// SetLives ( i , 1000 ) ;
1621: LD_VAR 0 1
1625: PPUSH
1626: LD_INT 1000
1628: PPUSH
1629: CALL_OW 234
1633: GO 1618
1635: POP
1636: POP
// end ; end_of_file
1637: PPOPN 2
1639: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1640: LD_INT 0
1642: PPUSH
// uc_side := 1 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 1
1650: ST_TO_ADDR
// uc_nation := 1 ;
1651: LD_ADDR_OWVAR 21
1655: PUSH
1656: LD_INT 1
1658: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1659: LD_ADDR_EXP 36
1663: PUSH
1664: LD_STRING JMM
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 14_
1675: PPUSH
1676: CALL 63701 0 3
1680: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1681: LD_EXP 4
1685: NOT
1686: PUSH
1687: LD_EXP 4
1691: PUSH
1692: LD_INT 1
1694: ARRAY
1695: PUSH
1696: LD_INT 1
1698: ARRAY
1699: NOT
1700: OR
1701: IFFALSE 1724
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1703: LD_INT 3
1705: PPUSH
1706: LD_INT 3
1708: PPUSH
1709: LD_INT 1
1711: PPUSH
1712: LD_INT 5
1714: PPUSH
1715: LD_INT 100
1717: PPUSH
1718: CALL 70667 0 5
1722: GO 1783
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1724: LD_EXP 4
1728: PUSH
1729: LD_INT 1
1731: ARRAY
1732: PUSH
1733: LD_INT 1
1735: ARRAY
1736: PPUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 2
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: PPUSH
1750: LD_EXP 4
1754: PUSH
1755: LD_INT 3
1757: ARRAY
1758: PUSH
1759: LD_INT 1
1761: ARRAY
1762: PPUSH
1763: LD_EXP 4
1767: PUSH
1768: LD_INT 4
1770: ARRAY
1771: PUSH
1772: LD_INT 1
1774: ARRAY
1775: PPUSH
1776: LD_INT 30
1778: PPUSH
1779: CALL 70667 0 5
// JMMNewVeh := CreateVehicle ;
1783: LD_ADDR_EXP 53
1787: PUSH
1788: CALL_OW 45
1792: ST_TO_ADDR
// if not JMMNewVeh then
1793: LD_EXP 53
1797: NOT
1798: IFFALSE 1829
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1800: LD_INT 3
1802: PPUSH
1803: LD_INT 3
1805: PPUSH
1806: LD_INT 1
1808: PPUSH
1809: LD_INT 5
1811: PPUSH
1812: LD_INT 100
1814: PPUSH
1815: CALL 70667 0 5
// JMMNewVeh := CreateVehicle ;
1819: LD_ADDR_EXP 53
1823: PUSH
1824: CALL_OW 45
1828: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1829: LD_EXP 53
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1841: LD_EXP 53
1845: PPUSH
1846: LD_INT 79
1848: PPUSH
1849: LD_INT 91
1851: PPUSH
1852: LD_INT 0
1854: PPUSH
1855: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1859: LD_EXP 36
1863: PPUSH
1864: LD_EXP 53
1868: PPUSH
1869: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1873: LD_EXP 6
1877: PUSH
1878: LD_EXP 2
1882: NOT
1883: AND
1884: IFFALSE 2142
// begin if not JMMGirlVeh then
1886: LD_EXP 5
1890: NOT
1891: IFFALSE 1914
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1893: LD_INT 3
1895: PPUSH
1896: LD_INT 3
1898: PPUSH
1899: LD_INT 1
1901: PPUSH
1902: LD_INT 9
1904: PPUSH
1905: LD_INT 100
1907: PPUSH
1908: CALL 70667 0 5
1912: GO 1973
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1914: LD_EXP 5
1918: PUSH
1919: LD_INT 1
1921: ARRAY
1922: PUSH
1923: LD_INT 1
1925: ARRAY
1926: PPUSH
1927: LD_EXP 5
1931: PUSH
1932: LD_INT 2
1934: ARRAY
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PPUSH
1940: LD_EXP 5
1944: PUSH
1945: LD_INT 3
1947: ARRAY
1948: PUSH
1949: LD_INT 1
1951: ARRAY
1952: PPUSH
1953: LD_EXP 5
1957: PUSH
1958: LD_INT 4
1960: ARRAY
1961: PUSH
1962: LD_INT 1
1964: ARRAY
1965: PPUSH
1966: LD_INT 30
1968: PPUSH
1969: CALL 70667 0 5
// GirlNewVeh := CreateVehicle ;
1973: LD_ADDR_EXP 54
1977: PUSH
1978: CALL_OW 45
1982: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1983: LD_EXP 54
1987: PPUSH
1988: LD_INT 4
1990: PPUSH
1991: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1995: LD_EXP 54
1999: PPUSH
2000: LD_INT 82
2002: PPUSH
2003: LD_INT 96
2005: PPUSH
2006: LD_INT 0
2008: PPUSH
2009: CALL_OW 48
// if JMMGirl = 1 then
2013: LD_EXP 7
2017: PUSH
2018: LD_INT 1
2020: EQUAL
2021: IFFALSE 2056
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2023: LD_ADDR_EXP 37
2027: PUSH
2028: LD_STRING Joan
2030: PPUSH
2031: LD_INT 1
2033: PPUSH
2034: LD_STRING 14_
2036: PPUSH
2037: CALL 63701 0 3
2041: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2042: LD_EXP 37
2046: PPUSH
2047: LD_EXP 54
2051: PPUSH
2052: CALL_OW 52
// end ; if JMMGirl = 2 then
2056: LD_EXP 7
2060: PUSH
2061: LD_INT 2
2063: EQUAL
2064: IFFALSE 2099
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_STRING Lisa
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_STRING 14_
2079: PPUSH
2080: CALL 63701 0 3
2084: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2085: LD_EXP 39
2089: PPUSH
2090: LD_EXP 54
2094: PPUSH
2095: CALL_OW 52
// end ; if JMMGirl = 3 then
2099: LD_EXP 7
2103: PUSH
2104: LD_INT 3
2106: EQUAL
2107: IFFALSE 2142
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2109: LD_ADDR_EXP 51
2113: PUSH
2114: LD_STRING Connie
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_STRING 14_
2122: PPUSH
2123: CALL 63701 0 3
2127: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2128: LD_EXP 51
2132: PPUSH
2133: LD_EXP 54
2137: PPUSH
2138: CALL_OW 52
// end ; end ; end ;
2142: LD_VAR 0 1
2146: RET
// export function PrepareStevensSquad ; var tmp ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// uc_side := 1 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// uc_nation := 1 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 1
2166: ST_TO_ADDR
// tmp := [ ] ;
2167: LD_ADDR_VAR 0 2
2171: PUSH
2172: EMPTY
2173: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2174: LD_ADDR_EXP 38
2178: PUSH
2179: LD_STRING Stevens
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13f_
2190: PPUSH
2191: CALL 63701 0 3
2195: ST_TO_ADDR
// if not Stevens then
2196: LD_EXP 38
2200: NOT
2201: IFFALSE 2257
// begin hc_name = Baker Smith ;
2203: LD_ADDR_OWVAR 26
2207: PUSH
2208: LD_STRING Baker Smith
2210: ST_TO_ADDR
// hc_gallery =  ;
2211: LD_ADDR_OWVAR 33
2215: PUSH
2216: LD_STRING 
2218: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2219: LD_INT 1
2221: PPUSH
2222: LD_INT 10
2224: PPUSH
2225: CALL_OW 384
// Baker = CreateHuman ;
2229: LD_ADDR_EXP 52
2233: PUSH
2234: CALL_OW 44
2238: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2239: LD_ADDR_VAR 0 2
2243: PUSH
2244: LD_VAR 0 2
2248: PUSH
2249: LD_EXP 52
2253: ADD
2254: ST_TO_ADDR
// end else
2255: GO 2273
// tmp := tmp ^ Stevens ;
2257: LD_ADDR_VAR 0 2
2261: PUSH
2262: LD_VAR 0 2
2266: PUSH
2267: LD_EXP 38
2271: ADD
2272: ST_TO_ADDR
// if not Lisa then
2273: LD_EXP 39
2277: NOT
2278: IFFALSE 2324
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2280: LD_ADDR_EXP 39
2284: PUSH
2285: LD_STRING Lisa
2287: PPUSH
2288: LD_EXP 1
2292: NOT
2293: PPUSH
2294: LD_STRING 13f_
2296: PPUSH
2297: CALL 63701 0 3
2301: ST_TO_ADDR
// if Lisa then
2302: LD_EXP 39
2306: IFFALSE 2324
// tmp := tmp ^ Lisa ;
2308: LD_ADDR_VAR 0 2
2312: PUSH
2313: LD_VAR 0 2
2317: PUSH
2318: LD_EXP 39
2322: ADD
2323: ST_TO_ADDR
// end ; if not Donaldson then
2324: LD_EXP 40
2328: NOT
2329: IFFALSE 2375
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2331: LD_ADDR_EXP 40
2335: PUSH
2336: LD_STRING Donaldson
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_STRING 13f_
2347: PPUSH
2348: CALL 63701 0 3
2352: ST_TO_ADDR
// if Donaldson then
2353: LD_EXP 40
2357: IFFALSE 2375
// tmp := tmp ^ Donaldson ;
2359: LD_ADDR_VAR 0 2
2363: PUSH
2364: LD_VAR 0 2
2368: PUSH
2369: LD_EXP 40
2373: ADD
2374: ST_TO_ADDR
// end ; if not Bobby then
2375: LD_EXP 41
2379: NOT
2380: IFFALSE 2426
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2382: LD_ADDR_EXP 41
2386: PUSH
2387: LD_STRING Bobby
2389: PPUSH
2390: LD_EXP 1
2394: NOT
2395: PPUSH
2396: LD_STRING 13f_
2398: PPUSH
2399: CALL 63701 0 3
2403: ST_TO_ADDR
// if Bobby then
2404: LD_EXP 41
2408: IFFALSE 2426
// tmp := tmp ^ Bobby ;
2410: LD_ADDR_VAR 0 2
2414: PUSH
2415: LD_VAR 0 2
2419: PUSH
2420: LD_EXP 41
2424: ADD
2425: ST_TO_ADDR
// end ; if not Cyrus then
2426: LD_EXP 42
2430: NOT
2431: IFFALSE 2477
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2433: LD_ADDR_EXP 42
2437: PUSH
2438: LD_STRING Cyrus
2440: PPUSH
2441: LD_EXP 1
2445: NOT
2446: PPUSH
2447: LD_STRING 13f_
2449: PPUSH
2450: CALL 63701 0 3
2454: ST_TO_ADDR
// if Cyrus then
2455: LD_EXP 42
2459: IFFALSE 2477
// tmp := tmp ^ Cyrus ;
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 2
2470: PUSH
2471: LD_EXP 42
2475: ADD
2476: ST_TO_ADDR
// end ; if not Brown then
2477: LD_EXP 44
2481: NOT
2482: IFFALSE 2528
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2484: LD_ADDR_EXP 44
2488: PUSH
2489: LD_STRING Brown
2491: PPUSH
2492: LD_EXP 1
2496: NOT
2497: PPUSH
2498: LD_STRING 13f_
2500: PPUSH
2501: CALL 63701 0 3
2505: ST_TO_ADDR
// if Brown then
2506: LD_EXP 44
2510: IFFALSE 2528
// tmp := tmp ^ Brown ;
2512: LD_ADDR_VAR 0 2
2516: PUSH
2517: LD_VAR 0 2
2521: PUSH
2522: LD_EXP 44
2526: ADD
2527: ST_TO_ADDR
// end ; if not Gladstone then
2528: LD_EXP 45
2532: NOT
2533: IFFALSE 2579
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2535: LD_ADDR_EXP 45
2539: PUSH
2540: LD_STRING Gladstone
2542: PPUSH
2543: LD_EXP 1
2547: NOT
2548: PPUSH
2549: LD_STRING 13f_
2551: PPUSH
2552: CALL 63701 0 3
2556: ST_TO_ADDR
// if Gladstone then
2557: LD_EXP 45
2561: IFFALSE 2579
// tmp := tmp ^ Gladstone ;
2563: LD_ADDR_VAR 0 2
2567: PUSH
2568: LD_VAR 0 2
2572: PUSH
2573: LD_EXP 45
2577: ADD
2578: ST_TO_ADDR
// end ; if not Houten then
2579: LD_EXP 46
2583: NOT
2584: IFFALSE 2630
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2586: LD_ADDR_EXP 46
2590: PUSH
2591: LD_STRING Houten
2593: PPUSH
2594: LD_EXP 1
2598: NOT
2599: PPUSH
2600: LD_STRING 13f_
2602: PPUSH
2603: CALL 63701 0 3
2607: ST_TO_ADDR
// if Houten then
2608: LD_EXP 46
2612: IFFALSE 2630
// tmp := tmp ^ Houten ;
2614: LD_ADDR_VAR 0 2
2618: PUSH
2619: LD_VAR 0 2
2623: PUSH
2624: LD_EXP 46
2628: ADD
2629: ST_TO_ADDR
// end ; if not Cornel then
2630: LD_EXP 47
2634: NOT
2635: IFFALSE 2681
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2637: LD_ADDR_EXP 47
2641: PUSH
2642: LD_STRING Cornel
2644: PPUSH
2645: LD_EXP 1
2649: NOT
2650: PPUSH
2651: LD_STRING 13f_
2653: PPUSH
2654: CALL 63701 0 3
2658: ST_TO_ADDR
// if Cornel then
2659: LD_EXP 47
2663: IFFALSE 2681
// tmp := tmp ^ Cornel ;
2665: LD_ADDR_VAR 0 2
2669: PUSH
2670: LD_VAR 0 2
2674: PUSH
2675: LD_EXP 47
2679: ADD
2680: ST_TO_ADDR
// end ; if not Gary then
2681: LD_EXP 48
2685: NOT
2686: IFFALSE 2732
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2688: LD_ADDR_EXP 48
2692: PUSH
2693: LD_STRING Gary
2695: PPUSH
2696: LD_EXP 1
2700: NOT
2701: PPUSH
2702: LD_STRING 13f_
2704: PPUSH
2705: CALL 63701 0 3
2709: ST_TO_ADDR
// if Gary then
2710: LD_EXP 48
2714: IFFALSE 2732
// tmp := tmp ^ Gary ;
2716: LD_ADDR_VAR 0 2
2720: PUSH
2721: LD_VAR 0 2
2725: PUSH
2726: LD_EXP 48
2730: ADD
2731: ST_TO_ADDR
// end ; if not Frank then
2732: LD_EXP 49
2736: NOT
2737: IFFALSE 2783
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2739: LD_ADDR_EXP 49
2743: PUSH
2744: LD_STRING Frank
2746: PPUSH
2747: LD_EXP 1
2751: NOT
2752: PPUSH
2753: LD_STRING 13f_
2755: PPUSH
2756: CALL 63701 0 3
2760: ST_TO_ADDR
// if Frank then
2761: LD_EXP 49
2765: IFFALSE 2783
// tmp := tmp ^ Frank ;
2767: LD_ADDR_VAR 0 2
2771: PUSH
2772: LD_VAR 0 2
2776: PUSH
2777: LD_EXP 49
2781: ADD
2782: ST_TO_ADDR
// end ; if not Kikuchi then
2783: LD_EXP 50
2787: NOT
2788: IFFALSE 2834
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2790: LD_ADDR_EXP 50
2794: PUSH
2795: LD_STRING Kikuchi
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_STRING 13f_
2806: PPUSH
2807: CALL 63701 0 3
2811: ST_TO_ADDR
// if Kikuchi then
2812: LD_EXP 50
2816: IFFALSE 2834
// tmp := tmp ^ Kikuchi ;
2818: LD_ADDR_VAR 0 2
2822: PUSH
2823: LD_VAR 0 2
2827: PUSH
2828: LD_EXP 50
2832: ADD
2833: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2834: LD_ADDR_VAR 0 2
2838: PUSH
2839: LD_VAR 0 2
2843: PUSH
2844: LD_STRING 13_other_survivors
2846: PPUSH
2847: CALL_OW 31
2851: UNION
2852: ST_TO_ADDR
// result := tmp ;
2853: LD_ADDR_VAR 0 1
2857: PUSH
2858: LD_VAR 0 2
2862: ST_TO_ADDR
// end ; end_of_file
2863: LD_VAR 0 1
2867: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2868: LD_INT 0
2870: PPUSH
2871: PPUSH
2872: PPUSH
2873: PPUSH
2874: PPUSH
2875: PPUSH
2876: PPUSH
2877: PPUSH
2878: PPUSH
2879: PPUSH
// uc_side := 4 ;
2880: LD_ADDR_OWVAR 20
2884: PUSH
2885: LD_INT 4
2887: ST_TO_ADDR
// uc_nation := 1 ;
2888: LD_ADDR_OWVAR 21
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2896: LD_INT 387
2898: PPUSH
2899: CALL_OW 274
2903: PPUSH
2904: LD_INT 1
2906: PPUSH
2907: LD_INT 2500
2909: PPUSH
2910: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2914: LD_INT 387
2916: PPUSH
2917: CALL_OW 274
2921: PPUSH
2922: LD_INT 2
2924: PPUSH
2925: LD_INT 400
2927: PPUSH
2928: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2932: LD_INT 387
2934: PPUSH
2935: CALL_OW 274
2939: PPUSH
2940: LD_INT 3
2942: PPUSH
2943: LD_INT 10
2945: PPUSH
2946: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2950: LD_ADDR_EXP 55
2954: PUSH
2955: LD_STRING Powell
2957: PPUSH
2958: CALL_OW 25
2962: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2963: LD_EXP 55
2967: PPUSH
2968: LD_INT 57
2970: PPUSH
2971: LD_INT 94
2973: PPUSH
2974: LD_INT 0
2976: PPUSH
2977: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2981: LD_EXP 55
2985: PPUSH
2986: LD_INT 58
2988: PPUSH
2989: LD_INT 94
2991: PPUSH
2992: CALL_OW 118
// vip := [ ] ;
2996: LD_ADDR_EXP 56
3000: PUSH
3001: EMPTY
3002: ST_TO_ADDR
// tmp := [ ] ;
3003: LD_ADDR_VAR 0 6
3007: PUSH
3008: EMPTY
3009: ST_TO_ADDR
// if JMMGirl <> 2 then
3010: LD_EXP 7
3014: PUSH
3015: LD_INT 2
3017: NONEQUAL
3018: IFFALSE 3042
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3020: LD_ADDR_EXP 39
3024: PUSH
3025: LD_STRING Lisa
3027: PPUSH
3028: LD_EXP 1
3032: NOT
3033: PPUSH
3034: LD_STRING 13s_
3036: PPUSH
3037: CALL 63701 0 3
3041: ST_TO_ADDR
// if Lisa then
3042: LD_EXP 39
3046: IFFALSE 3064
// tmp := tmp ^ Lisa ;
3048: LD_ADDR_VAR 0 6
3052: PUSH
3053: LD_VAR 0 6
3057: PUSH
3058: LD_EXP 39
3062: ADD
3063: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3064: LD_ADDR_EXP 40
3068: PUSH
3069: LD_STRING Donaldson
3071: PPUSH
3072: LD_EXP 1
3076: NOT
3077: PPUSH
3078: LD_STRING 13s_
3080: PPUSH
3081: CALL 63701 0 3
3085: ST_TO_ADDR
// if Donaldson then
3086: LD_EXP 40
3090: IFFALSE 3108
// tmp := tmp ^ Donaldson ;
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: LD_VAR 0 6
3101: PUSH
3102: LD_EXP 40
3106: ADD
3107: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3108: LD_ADDR_EXP 41
3112: PUSH
3113: LD_STRING Bobby
3115: PPUSH
3116: LD_EXP 1
3120: NOT
3121: PPUSH
3122: LD_STRING 13s_
3124: PPUSH
3125: CALL 63701 0 3
3129: ST_TO_ADDR
// if Bobby then
3130: LD_EXP 41
3134: IFFALSE 3152
// tmp := tmp ^ Bobby ;
3136: LD_ADDR_VAR 0 6
3140: PUSH
3141: LD_VAR 0 6
3145: PUSH
3146: LD_EXP 41
3150: ADD
3151: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3152: LD_ADDR_EXP 42
3156: PUSH
3157: LD_STRING Cyrus
3159: PPUSH
3160: LD_EXP 1
3164: NOT
3165: PPUSH
3166: LD_STRING 13s_
3168: PPUSH
3169: CALL 63701 0 3
3173: ST_TO_ADDR
// if Cyrus then
3174: LD_EXP 42
3178: IFFALSE 3196
// tmp := tmp ^ Cyrus ;
3180: LD_ADDR_VAR 0 6
3184: PUSH
3185: LD_VAR 0 6
3189: PUSH
3190: LD_EXP 42
3194: ADD
3195: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3196: LD_ADDR_EXP 43
3200: PUSH
3201: LD_STRING Denis
3203: PPUSH
3204: LD_EXP 1
3208: NOT
3209: PPUSH
3210: LD_STRING 13s_
3212: PPUSH
3213: CALL 63701 0 3
3217: ST_TO_ADDR
// if not Denis then
3218: LD_EXP 43
3222: NOT
3223: IFFALSE 3247
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3225: LD_ADDR_EXP 43
3229: PUSH
3230: LD_STRING Denis
3232: PPUSH
3233: LD_EXP 1
3237: NOT
3238: PPUSH
3239: LD_STRING 13f_
3241: PPUSH
3242: CALL 63701 0 3
3246: ST_TO_ADDR
// if Denis then
3247: LD_EXP 43
3251: IFFALSE 3269
// tmp := tmp ^ Denis ;
3253: LD_ADDR_VAR 0 6
3257: PUSH
3258: LD_VAR 0 6
3262: PUSH
3263: LD_EXP 43
3267: ADD
3268: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3269: LD_ADDR_EXP 44
3273: PUSH
3274: LD_STRING Brown
3276: PPUSH
3277: LD_EXP 1
3281: NOT
3282: PPUSH
3283: LD_STRING 13s_
3285: PPUSH
3286: CALL 63701 0 3
3290: ST_TO_ADDR
// if Brown then
3291: LD_EXP 44
3295: IFFALSE 3313
// tmp := tmp ^ Brown ;
3297: LD_ADDR_VAR 0 6
3301: PUSH
3302: LD_VAR 0 6
3306: PUSH
3307: LD_EXP 44
3311: ADD
3312: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3313: LD_ADDR_EXP 45
3317: PUSH
3318: LD_STRING Gladstone
3320: PPUSH
3321: LD_EXP 1
3325: NOT
3326: PPUSH
3327: LD_STRING 13s_
3329: PPUSH
3330: CALL 63701 0 3
3334: ST_TO_ADDR
// if Gladstone then
3335: LD_EXP 45
3339: IFFALSE 3357
// tmp := tmp ^ Gladstone ;
3341: LD_ADDR_VAR 0 6
3345: PUSH
3346: LD_VAR 0 6
3350: PUSH
3351: LD_EXP 45
3355: ADD
3356: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3357: LD_ADDR_EXP 46
3361: PUSH
3362: LD_STRING Houten
3364: PPUSH
3365: LD_EXP 1
3369: NOT
3370: PPUSH
3371: LD_STRING 13s_
3373: PPUSH
3374: CALL 63701 0 3
3378: ST_TO_ADDR
// if Houten then
3379: LD_EXP 46
3383: IFFALSE 3401
// tmp := tmp ^ Houten ;
3385: LD_ADDR_VAR 0 6
3389: PUSH
3390: LD_VAR 0 6
3394: PUSH
3395: LD_EXP 46
3399: ADD
3400: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3401: LD_ADDR_EXP 47
3405: PUSH
3406: LD_STRING Cornel
3408: PPUSH
3409: LD_EXP 1
3413: NOT
3414: PPUSH
3415: LD_STRING 13s_
3417: PPUSH
3418: CALL 63701 0 3
3422: ST_TO_ADDR
// if Cornel then
3423: LD_EXP 47
3427: IFFALSE 3445
// tmp := tmp ^ Cornel ;
3429: LD_ADDR_VAR 0 6
3433: PUSH
3434: LD_VAR 0 6
3438: PUSH
3439: LD_EXP 47
3443: ADD
3444: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3445: LD_ADDR_EXP 48
3449: PUSH
3450: LD_STRING Gary
3452: PPUSH
3453: LD_EXP 1
3457: NOT
3458: PPUSH
3459: LD_STRING 13s_
3461: PPUSH
3462: CALL 63701 0 3
3466: ST_TO_ADDR
// if Gary then
3467: LD_EXP 48
3471: IFFALSE 3489
// tmp := tmp ^ Gary ;
3473: LD_ADDR_VAR 0 6
3477: PUSH
3478: LD_VAR 0 6
3482: PUSH
3483: LD_EXP 48
3487: ADD
3488: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3489: LD_ADDR_EXP 49
3493: PUSH
3494: LD_STRING Frank
3496: PPUSH
3497: LD_EXP 1
3501: NOT
3502: PPUSH
3503: LD_STRING 13s_
3505: PPUSH
3506: CALL 63701 0 3
3510: ST_TO_ADDR
// if Frank then
3511: LD_EXP 49
3515: IFFALSE 3533
// tmp := tmp ^ Frank ;
3517: LD_ADDR_VAR 0 6
3521: PUSH
3522: LD_VAR 0 6
3526: PUSH
3527: LD_EXP 49
3531: ADD
3532: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3533: LD_ADDR_EXP 50
3537: PUSH
3538: LD_STRING Kikuchi
3540: PPUSH
3541: LD_EXP 1
3545: NOT
3546: PPUSH
3547: LD_STRING 13s_
3549: PPUSH
3550: CALL 63701 0 3
3554: ST_TO_ADDR
// if Kikuchi then
3555: LD_EXP 50
3559: IFFALSE 3577
// tmp := tmp ^ Kikuchi ;
3561: LD_ADDR_VAR 0 6
3565: PUSH
3566: LD_VAR 0 6
3570: PUSH
3571: LD_EXP 50
3575: ADD
3576: ST_TO_ADDR
// vip := tmp ;
3577: LD_ADDR_EXP 56
3581: PUSH
3582: LD_VAR 0 6
3586: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3587: LD_ADDR_VAR 0 6
3591: PUSH
3592: LD_VAR 0 6
3596: PUSH
3597: LD_STRING 13s_others
3599: PPUSH
3600: CALL_OW 31
3604: UNION
3605: ST_TO_ADDR
// if tmp < 20 then
3606: LD_VAR 0 6
3610: PUSH
3611: LD_INT 20
3613: LESS
3614: IFFALSE 3681
// for i = 1 to 20 - tmp do
3616: LD_ADDR_VAR 0 2
3620: PUSH
3621: DOUBLE
3622: LD_INT 1
3624: DEC
3625: ST_TO_ADDR
3626: LD_INT 20
3628: PUSH
3629: LD_VAR 0 6
3633: MINUS
3634: PUSH
3635: FOR_TO
3636: IFFALSE 3679
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3638: LD_INT 1
3640: PPUSH
3641: LD_VAR 0 2
3645: PUSH
3646: LD_INT 4
3648: MOD
3649: PUSH
3650: LD_INT 1
3652: PLUS
3653: PPUSH
3654: LD_INT 5
3656: PPUSH
3657: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: CALL_OW 44
3675: ADD
3676: ST_TO_ADDR
// end ;
3677: GO 3635
3679: POP
3680: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3681: LD_ADDR_VAR 0 7
3685: PUSH
3686: LD_INT 22
3688: PUSH
3689: LD_INT 4
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 30
3698: PUSH
3699: LD_INT 0
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PPUSH
3710: CALL_OW 69
3714: PUSH
3715: LD_INT 1
3717: ARRAY
3718: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3719: LD_ADDR_VAR 0 8
3723: PUSH
3724: LD_INT 22
3726: PUSH
3727: LD_INT 4
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: LD_INT 30
3736: PUSH
3737: LD_INT 6
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PPUSH
3748: CALL_OW 69
3752: PUSH
3753: LD_INT 1
3755: ARRAY
3756: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3757: LD_ADDR_VAR 0 9
3761: PUSH
3762: LD_INT 22
3764: PUSH
3765: LD_INT 4
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 30
3774: PUSH
3775: LD_INT 4
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3795: LD_ADDR_VAR 0 10
3799: PUSH
3800: LD_INT 22
3802: PUSH
3803: LD_INT 4
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PUSH
3810: LD_INT 30
3812: PUSH
3813: LD_INT 2
3815: PUSH
3816: EMPTY
3817: LIST
3818: LIST
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PPUSH
3824: CALL_OW 69
3828: PUSH
3829: LD_INT 1
3831: ARRAY
3832: ST_TO_ADDR
// for i in tmp do
3833: LD_ADDR_VAR 0 2
3837: PUSH
3838: LD_VAR 0 6
3842: PUSH
3843: FOR_IN
3844: IFFALSE 3970
// begin cl := GetClass ( i ) ;
3846: LD_ADDR_VAR 0 5
3850: PUSH
3851: LD_VAR 0 2
3855: PPUSH
3856: CALL_OW 257
3860: ST_TO_ADDR
// if cl > 4 then
3861: LD_VAR 0 5
3865: PUSH
3866: LD_INT 4
3868: GREATER
3869: IFFALSE 3879
// cl := 1 ;
3871: LD_ADDR_VAR 0 5
3875: PUSH
3876: LD_INT 1
3878: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3879: LD_ADDR_VAR 0 3
3883: PUSH
3884: LD_VAR 0 9
3888: PUSH
3889: LD_VAR 0 7
3893: PUSH
3894: LD_VAR 0 10
3898: PUSH
3899: LD_VAR 0 8
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_VAR 0 5
3914: ARRAY
3915: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3916: LD_VAR 0 3
3920: PPUSH
3921: CALL_OW 313
3925: PUSH
3926: LD_INT 5
3928: LESS
3929: IFFALSE 3947
// PlaceHumanInUnit ( i , b ) else
3931: LD_VAR 0 2
3935: PPUSH
3936: LD_VAR 0 3
3940: PPUSH
3941: CALL_OW 52
3945: GO 3968
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3947: LD_VAR 0 2
3951: PPUSH
3952: LD_INT 58
3954: PPUSH
3955: LD_INT 91
3957: PPUSH
3958: LD_INT 6
3960: PPUSH
3961: LD_INT 0
3963: PPUSH
3964: CALL_OW 50
// end ;
3968: GO 3843
3970: POP
3971: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3972: LD_INT 2
3974: PPUSH
3975: LD_INT 1
3977: PPUSH
3978: LD_INT 1
3980: PPUSH
3981: LD_INT 12
3983: PPUSH
3984: LD_INT 100
3986: PPUSH
3987: CALL 70667 0 5
// veh := CreateVehicle ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: CALL_OW 45
4000: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4001: LD_VAR 0 4
4005: PPUSH
4006: LD_INT 4
4008: PPUSH
4009: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4013: LD_VAR 0 4
4017: PPUSH
4018: LD_INT 49
4020: PPUSH
4021: LD_INT 88
4023: PPUSH
4024: LD_INT 0
4026: PPUSH
4027: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4031: LD_VAR 0 4
4035: PPUSH
4036: LD_INT 1
4038: PPUSH
4039: LD_INT 100
4041: PPUSH
4042: CALL_OW 290
// uc_side := 0 ;
4046: LD_ADDR_OWVAR 20
4050: PUSH
4051: LD_INT 0
4053: ST_TO_ADDR
// uc_nation := 0 ;
4054: LD_ADDR_OWVAR 21
4058: PUSH
4059: LD_INT 0
4061: ST_TO_ADDR
// for i = 1 to 4 do
4062: LD_ADDR_VAR 0 2
4066: PUSH
4067: DOUBLE
4068: LD_INT 1
4070: DEC
4071: ST_TO_ADDR
4072: LD_INT 4
4074: PUSH
4075: FOR_TO
4076: IFFALSE 4107
// begin InitHc ;
4078: CALL_OW 19
// hc_class := class_apeman ;
4082: LD_ADDR_OWVAR 28
4086: PUSH
4087: LD_INT 12
4089: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4090: CALL_OW 44
4094: PPUSH
4095: LD_INT 13
4097: PPUSH
4098: LD_INT 0
4100: PPUSH
4101: CALL_OW 49
// end ;
4105: GO 4075
4107: POP
4108: POP
// end ; end_of_file
4109: LD_VAR 0 1
4113: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4114: LD_INT 0
4116: PPUSH
4117: PPUSH
4118: PPUSH
4119: PPUSH
4120: PPUSH
// side := 8 ;
4121: LD_ADDR_VAR 0 3
4125: PUSH
4126: LD_INT 8
4128: ST_TO_ADDR
// uc_side := side ;
4129: LD_ADDR_OWVAR 20
4133: PUSH
4134: LD_VAR 0 3
4138: ST_TO_ADDR
// uc_nation := 2 ;
4139: LD_ADDR_OWVAR 21
4143: PUSH
4144: LD_INT 2
4146: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4147: LD_ADDR_VAR 0 2
4151: PUSH
4152: LD_INT 22
4154: PUSH
4155: LD_VAR 0 3
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PUSH
4164: LD_INT 21
4166: PUSH
4167: LD_INT 3
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PPUSH
4178: CALL_OW 69
4182: PUSH
4183: FOR_IN
4184: IFFALSE 4200
// SetBLevel ( i , 10 ) ;
4186: LD_VAR 0 2
4190: PPUSH
4191: LD_INT 10
4193: PPUSH
4194: CALL_OW 241
4198: GO 4183
4200: POP
4201: POP
// if KurtStatus then
4202: LD_EXP 3
4206: IFFALSE 4229
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4208: LD_ADDR_EXP 57
4212: PUSH
4213: LD_STRING Kurt
4215: PPUSH
4216: LD_INT 0
4218: PPUSH
4219: LD_STRING 
4221: PPUSH
4222: CALL 63701 0 3
4226: ST_TO_ADDR
4227: GO 4251
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4229: LD_ADDR_EXP 57
4233: PUSH
4234: LD_STRING AltKurt
4236: PPUSH
4237: LD_EXP 1
4241: NOT
4242: PPUSH
4243: LD_STRING 
4245: PPUSH
4246: CALL 63701 0 3
4250: ST_TO_ADDR
// if not Kurt then
4251: LD_EXP 57
4255: NOT
4256: IFFALSE 4282
// begin InitHc ;
4258: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 10
4267: PPUSH
4268: CALL_OW 381
// Kurt := CreateHuman ;
4272: LD_ADDR_EXP 57
4276: PUSH
4277: CALL_OW 44
4281: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4282: LD_EXP 57
4286: PPUSH
4287: LD_INT 324
4289: PPUSH
4290: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4294: LD_ADDR_EXP 58
4298: PUSH
4299: LD_STRING Kozlov
4301: PPUSH
4302: LD_INT 0
4304: PPUSH
4305: LD_STRING 
4307: PPUSH
4308: CALL 63701 0 3
4312: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4313: LD_EXP 58
4317: PPUSH
4318: LD_INT 22
4320: PUSH
4321: LD_INT 8
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PUSH
4328: LD_INT 23
4330: PUSH
4331: LD_INT 3
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: PUSH
4338: LD_INT 30
4340: PUSH
4341: LD_INT 8
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: LIST
4352: PPUSH
4353: CALL_OW 69
4357: PUSH
4358: LD_INT 1
4360: ARRAY
4361: PPUSH
4362: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4366: LD_EXP 58
4370: PPUSH
4371: LD_INT 3
4373: PPUSH
4374: LD_INT 10
4376: PPUSH
4377: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4381: LD_ADDR_VAR 0 5
4385: PUSH
4386: LD_INT 22
4388: PUSH
4389: LD_VAR 0 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: LD_INT 30
4400: PUSH
4401: LD_INT 32
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 58
4410: PUSH
4411: EMPTY
4412: LIST
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: LIST
4418: PPUSH
4419: CALL_OW 69
4423: ST_TO_ADDR
// for i = 1 to 10 do
4424: LD_ADDR_VAR 0 2
4428: PUSH
4429: DOUBLE
4430: LD_INT 1
4432: DEC
4433: ST_TO_ADDR
4434: LD_INT 10
4436: PUSH
4437: FOR_TO
4438: IFFALSE 4510
// begin uc_nation := nation_nature ;
4440: LD_ADDR_OWVAR 21
4444: PUSH
4445: LD_INT 0
4447: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4448: LD_ADDR_OWVAR 28
4452: PUSH
4453: LD_INT 15
4455: ST_TO_ADDR
// hc_gallery :=  ;
4456: LD_ADDR_OWVAR 33
4460: PUSH
4461: LD_STRING 
4463: ST_TO_ADDR
// hc_name :=  ;
4464: LD_ADDR_OWVAR 26
4468: PUSH
4469: LD_STRING 
4471: ST_TO_ADDR
// un := CreateHuman ;
4472: LD_ADDR_VAR 0 4
4476: PUSH
4477: CALL_OW 44
4481: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4482: LD_VAR 0 4
4486: PPUSH
4487: LD_VAR 0 5
4491: PUSH
4492: LD_VAR 0 5
4496: PUSH
4497: LD_VAR 0 2
4501: MINUS
4502: ARRAY
4503: PPUSH
4504: CALL_OW 52
// end ;
4508: GO 4437
4510: POP
4511: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4512: LD_ADDR_VAR 0 5
4516: PUSH
4517: LD_STRING 12_kurt_squad
4519: PPUSH
4520: CALL_OW 31
4524: ST_TO_ADDR
// if tmp then
4525: LD_VAR 0 5
4529: IFFALSE 4563
// for i in tmp do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: LD_VAR 0 5
4540: PUSH
4541: FOR_IN
4542: IFFALSE 4561
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4544: LD_VAR 0 2
4548: PPUSH
4549: LD_INT 5
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 49
4559: GO 4541
4561: POP
4562: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4563: LD_INT 324
4565: PPUSH
4566: LD_INT 5
4568: PPUSH
4569: LD_STRING 
4571: PPUSH
4572: LD_INT 8
4574: PUSH
4575: LD_INT 9
4577: PUSH
4578: LD_INT 10
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: LIST
4585: PUSH
4586: LD_OWVAR 67
4590: ARRAY
4591: PPUSH
4592: LD_INT 3000
4594: PUSH
4595: LD_INT 500
4597: PUSH
4598: LD_INT 150
4600: PUSH
4601: EMPTY
4602: LIST
4603: LIST
4604: LIST
4605: PPUSH
4606: LD_INT 16
4608: PUSH
4609: LD_INT 6
4611: PUSH
4612: LD_INT 6
4614: PUSH
4615: LD_INT 8
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: LIST
4623: PPUSH
4624: CALL 74076 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4628: LD_ADDR_EXP 99
4632: PUSH
4633: LD_EXP 99
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 22
4643: PUSH
4644: LD_VAR 0 3
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: PUSH
4653: LD_INT 23
4655: PUSH
4656: LD_INT 2
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: LD_INT 3
4665: PUSH
4666: LD_INT 21
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: LIST
4684: PPUSH
4685: CALL_OW 69
4689: PUSH
4690: LD_EXP 57
4694: DIFF
4695: PPUSH
4696: CALL_OW 1
4700: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4701: LD_INT 1
4703: PPUSH
4704: LD_INT 7
4706: PPUSH
4707: CALL_OW 383
// Friend := CreateHuman ;
4711: LD_ADDR_EXP 59
4715: PUSH
4716: CALL_OW 44
4720: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4721: LD_INT 14
4723: PPUSH
4724: LD_INT 3
4726: PPUSH
4727: LD_INT 1
4729: PPUSH
4730: LD_INT 29
4732: PPUSH
4733: LD_INT 100
4735: PPUSH
4736: CALL 70667 0 5
// powellBomb := CreateVehicle ;
4740: LD_ADDR_EXP 60
4744: PUSH
4745: CALL_OW 45
4749: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4750: LD_EXP 60
4754: PPUSH
4755: LD_INT 90
4757: PPUSH
4758: LD_INT 51
4760: PPUSH
4761: LD_INT 0
4763: PPUSH
4764: CALL_OW 48
// end ;
4768: LD_VAR 0 1
4772: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4773: LD_INT 0
4775: PPUSH
4776: PPUSH
4777: PPUSH
// if IsLive ( kozlov_fac ) then
4778: LD_INT 332
4780: PPUSH
4781: CALL_OW 300
4785: IFFALSE 4789
// exit ;
4787: GO 5356
// ComExitBuilding ( Kozlov ) ;
4789: LD_EXP 58
4793: PPUSH
4794: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4798: LD_EXP 58
4802: PPUSH
4803: CALL_OW 257
4807: PUSH
4808: LD_INT 2
4810: NONEQUAL
4811: IFFALSE 4846
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 324
4820: PPUSH
4821: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4825: LD_EXP 58
4829: PPUSH
4830: LD_INT 2
4832: PPUSH
4833: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4837: LD_EXP 58
4841: PPUSH
4842: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4846: LD_EXP 58
4850: PPUSH
4851: LD_INT 2
4853: PPUSH
4854: LD_INT 93
4856: PPUSH
4857: LD_INT 32
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4867: LD_INT 35
4869: PPUSH
4870: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4874: LD_INT 22
4876: PUSH
4877: LD_INT 8
4879: PUSH
4880: EMPTY
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 30
4886: PUSH
4887: LD_INT 3
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: PUSH
4894: LD_INT 23
4896: PUSH
4897: LD_INT 3
4899: PUSH
4900: EMPTY
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 57
4906: PUSH
4907: EMPTY
4908: LIST
4909: PUSH
4910: EMPTY
4911: LIST
4912: LIST
4913: LIST
4914: LIST
4915: PPUSH
4916: CALL_OW 69
4920: IFFALSE 4867
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4922: LD_ADDR_VAR 0 2
4926: PUSH
4927: LD_INT 22
4929: PUSH
4930: LD_INT 8
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: LD_INT 30
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 23
4949: PUSH
4950: LD_INT 3
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: PUSH
4957: LD_INT 57
4959: PUSH
4960: EMPTY
4961: LIST
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: PPUSH
4969: CALL_OW 69
4973: PUSH
4974: LD_INT 1
4976: ARRAY
4977: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4978: LD_INT 22
4980: PUSH
4981: LD_INT 8
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 23
4990: PUSH
4991: LD_INT 3
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 30
5000: PUSH
5001: LD_INT 21
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 69
5017: NOT
5018: IFFALSE 5096
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5020: LD_EXP 58
5024: PPUSH
5025: LD_INT 21
5027: PPUSH
5028: LD_INT 97
5030: PPUSH
5031: LD_INT 36
5033: PPUSH
5034: LD_INT 5
5036: PPUSH
5037: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5041: LD_INT 35
5043: PPUSH
5044: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5048: LD_INT 22
5050: PUSH
5051: LD_INT 8
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: PUSH
5058: LD_INT 23
5060: PUSH
5061: LD_INT 3
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 30
5070: PUSH
5071: LD_INT 21
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: LD_INT 57
5080: PUSH
5081: EMPTY
5082: LIST
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: LIST
5088: LIST
5089: PPUSH
5090: CALL_OW 69
5094: IFFALSE 5041
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5096: LD_INT 22
5098: PUSH
5099: LD_INT 8
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: LD_INT 23
5108: PUSH
5109: LD_INT 3
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_INT 30
5118: PUSH
5119: LD_INT 18
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: LIST
5130: PPUSH
5131: CALL_OW 69
5135: NOT
5136: IFFALSE 5214
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5138: LD_EXP 58
5142: PPUSH
5143: LD_INT 18
5145: PPUSH
5146: LD_INT 89
5148: PPUSH
5149: LD_INT 32
5151: PPUSH
5152: LD_INT 1
5154: PPUSH
5155: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5159: LD_INT 35
5161: PPUSH
5162: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5166: LD_INT 22
5168: PUSH
5169: LD_INT 8
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: LD_INT 23
5178: PUSH
5179: LD_INT 3
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: PUSH
5186: LD_INT 30
5188: PUSH
5189: LD_INT 18
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 57
5198: PUSH
5199: EMPTY
5200: LIST
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: PPUSH
5208: CALL_OW 69
5212: IFFALSE 5159
// end ; lab := kozlov_lab ;
5214: LD_ADDR_VAR 0 3
5218: PUSH
5219: LD_INT 336
5221: ST_TO_ADDR
// if not lab then
5222: LD_VAR 0 3
5226: NOT
5227: IFFALSE 5231
// exit ;
5229: GO 5356
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5231: LD_EXP 58
5235: PPUSH
5236: LD_VAR 0 3
5240: PUSH
5241: LD_INT 1
5243: ARRAY
5244: PPUSH
5245: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5249: LD_EXP 58
5253: PPUSH
5254: LD_INT 4
5256: PPUSH
5257: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5261: LD_VAR 0 3
5265: PUSH
5266: LD_INT 1
5268: ARRAY
5269: PPUSH
5270: LD_INT 25
5272: PPUSH
5273: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5277: LD_INT 35
5279: PPUSH
5280: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5284: LD_INT 25
5286: PPUSH
5287: LD_INT 8
5289: PPUSH
5290: CALL_OW 321
5294: PUSH
5295: LD_INT 2
5297: EQUAL
5298: IFFALSE 5277
// ComExitBuilding ( Kozlov ) ;
5300: LD_EXP 58
5304: PPUSH
5305: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5309: LD_EXP 58
5313: PPUSH
5314: LD_VAR 0 2
5318: PPUSH
5319: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5323: LD_EXP 58
5327: PPUSH
5328: LD_INT 3
5330: PPUSH
5331: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5335: LD_VAR 0 2
5339: PPUSH
5340: LD_INT 23
5342: PPUSH
5343: LD_INT 3
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: LD_INT 48
5351: PPUSH
5352: CALL_OW 125
// end ;
5356: LD_VAR 0 1
5360: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5361: LD_EXP 22
5365: NOT
5366: PUSH
5367: LD_EXP 15
5371: PUSH
5372: LD_INT 6
5374: GREATEREQUAL
5375: AND
5376: IFFALSE 5457
5378: GO 5380
5380: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5381: LD_INT 3
5383: PPUSH
5384: LD_INT 3
5386: PPUSH
5387: CALL 57628 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 14
5396: PUSH
5397: LD_INT 1
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 28
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 14
5414: PUSH
5415: LD_INT 1
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: LD_INT 28
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 14
5432: PUSH
5433: LD_INT 1
5435: PUSH
5436: LD_INT 1
5438: PUSH
5439: LD_INT 28
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: LIST
5446: LIST
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: LIST
5452: PPUSH
5453: CALL 57491 0 2
// end ;
5457: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5458: LD_EXP 22
5462: NOT
5463: PUSH
5464: LD_EXP 15
5468: PUSH
5469: LD_INT 6
5471: GREATEREQUAL
5472: AND
5473: PUSH
5474: LD_INT 3
5476: PPUSH
5477: LD_INT 1
5479: PPUSH
5480: CALL 58909 0 2
5484: NOT
5485: AND
5486: IFFALSE 6326
5488: GO 5490
5490: DISABLE
5491: LD_INT 0
5493: PPUSH
5494: PPUSH
5495: PPUSH
// begin enable ;
5496: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5497: LD_INT 22
5499: PUSH
5500: LD_INT 8
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: PUSH
5507: LD_INT 23
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 30
5519: PUSH
5520: LD_INT 3
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: LIST
5531: PPUSH
5532: CALL_OW 69
5536: NOT
5537: IFFALSE 5541
// exit ;
5539: GO 6326
// if Prob ( 40 ) then
5541: LD_INT 40
5543: PPUSH
5544: CALL_OW 13
5548: IFFALSE 5675
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5550: LD_INT 3
5552: PPUSH
5553: LD_INT 14
5555: PUSH
5556: LD_INT 1
5558: PUSH
5559: LD_INT 2
5561: PUSH
5562: LD_INT 28
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: PUSH
5571: LD_INT 14
5573: PUSH
5574: LD_INT 1
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 28
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 14
5591: PUSH
5592: LD_INT 1
5594: PUSH
5595: LD_INT 2
5597: PUSH
5598: LD_INT 28
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: LD_INT 14
5609: PUSH
5610: LD_INT 1
5612: PUSH
5613: LD_INT 2
5615: PUSH
5616: LD_INT 28
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: LIST
5623: LIST
5624: PUSH
5625: LD_INT 14
5627: PUSH
5628: LD_INT 1
5630: PUSH
5631: LD_INT 2
5633: PUSH
5634: LD_INT 28
5636: PUSH
5637: EMPTY
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: PUSH
5643: LD_INT 14
5645: PUSH
5646: LD_INT 1
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: LD_INT 26
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: LIST
5659: LIST
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: PPUSH
5669: CALL 57491 0 2
// end else
5673: GO 5866
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5675: LD_INT 3
5677: PPUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 27
5689: PUSH
5690: LD_INT 26
5692: PUSH
5693: LD_INT 26
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: PUSH
5701: LD_OWVAR 67
5705: ARRAY
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 14
5715: PUSH
5716: LD_INT 1
5718: PUSH
5719: LD_INT 2
5721: PUSH
5722: LD_INT 27
5724: PUSH
5725: LD_INT 26
5727: PUSH
5728: LD_INT 26
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: LIST
5735: PUSH
5736: LD_OWVAR 67
5740: ARRAY
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 14
5750: PUSH
5751: LD_INT 1
5753: PUSH
5754: LD_INT 2
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: LD_INT 29
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: PUSH
5771: LD_OWVAR 67
5775: ARRAY
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 13
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 29
5797: PUSH
5798: LD_INT 29
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: PUSH
5806: LD_OWVAR 67
5810: ARRAY
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_INT 13
5820: PUSH
5821: LD_INT 1
5823: PUSH
5824: LD_INT 2
5826: PUSH
5827: LD_INT 29
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 26
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: PPUSH
5862: CALL 57491 0 2
// end ; repeat wait ( 0 0$1 ) ;
5866: LD_INT 35
5868: PPUSH
5869: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5873: LD_INT 3
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 58909 0 2
5883: PUSH
5884: LD_INT 6
5886: GREATEREQUAL
5887: IFFALSE 5866
// wait ( 0 0$30 ) ;
5889: LD_INT 1050
5891: PPUSH
5892: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5896: LD_ADDR_VAR 0 2
5900: PUSH
5901: LD_INT 3
5903: PPUSH
5904: LD_INT 1
5906: PPUSH
5907: CALL 58909 0 2
5911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5912: LD_ADDR_EXP 118
5916: PUSH
5917: LD_EXP 118
5921: PPUSH
5922: LD_INT 3
5924: PPUSH
5925: LD_EXP 118
5929: PUSH
5930: LD_INT 3
5932: ARRAY
5933: PUSH
5934: LD_VAR 0 2
5938: DIFF
5939: PPUSH
5940: CALL_OW 1
5944: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5945: LD_ADDR_VAR 0 3
5949: PUSH
5950: LD_INT 0
5952: PPUSH
5953: LD_INT 2
5955: PPUSH
5956: CALL_OW 12
5960: ST_TO_ADDR
// if target then
5961: LD_VAR 0 3
5965: IFFALSE 6093
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5967: LD_ADDR_VAR 0 2
5971: PUSH
5972: LD_VAR 0 2
5976: PPUSH
5977: LD_INT 24
5979: PUSH
5980: LD_INT 250
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PPUSH
5987: CALL_OW 72
5991: ST_TO_ADDR
// for i in tmp do
5992: LD_ADDR_VAR 0 1
5996: PUSH
5997: LD_VAR 0 2
6001: PUSH
6002: FOR_IN
6003: IFFALSE 6043
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6005: LD_VAR 0 1
6009: PPUSH
6010: LD_INT 89
6012: PPUSH
6013: LD_INT 71
6015: PPUSH
6016: CALL_OW 297
6020: PUSH
6021: LD_INT 9
6023: GREATER
6024: IFFALSE 6041
// ComMoveXY ( i , 89 , 71 ) ;
6026: LD_VAR 0 1
6030: PPUSH
6031: LD_INT 89
6033: PPUSH
6034: LD_INT 71
6036: PPUSH
6037: CALL_OW 111
6041: GO 6002
6043: POP
6044: POP
// wait ( 0 0$1 ) ;
6045: LD_INT 35
6047: PPUSH
6048: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6052: LD_VAR 0 2
6056: PPUSH
6057: LD_INT 92
6059: PUSH
6060: LD_INT 89
6062: PUSH
6063: LD_INT 71
6065: PUSH
6066: LD_INT 9
6068: PUSH
6069: EMPTY
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 72
6079: PUSH
6080: LD_VAR 0 2
6084: PUSH
6085: LD_INT 1
6087: MINUS
6088: GREATEREQUAL
6089: IFFALSE 5967
// end else
6091: GO 6217
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6093: LD_ADDR_VAR 0 2
6097: PUSH
6098: LD_VAR 0 2
6102: PPUSH
6103: LD_INT 24
6105: PUSH
6106: LD_INT 250
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: PPUSH
6113: CALL_OW 72
6117: ST_TO_ADDR
// for i in tmp do
6118: LD_ADDR_VAR 0 1
6122: PUSH
6123: LD_VAR 0 2
6127: PUSH
6128: FOR_IN
6129: IFFALSE 6169
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6131: LD_VAR 0 1
6135: PPUSH
6136: LD_INT 125
6138: PPUSH
6139: LD_INT 129
6141: PPUSH
6142: CALL_OW 297
6146: PUSH
6147: LD_INT 9
6149: GREATER
6150: IFFALSE 6167
// ComMoveXY ( i , 125 , 129 ) ;
6152: LD_VAR 0 1
6156: PPUSH
6157: LD_INT 125
6159: PPUSH
6160: LD_INT 129
6162: PPUSH
6163: CALL_OW 111
6167: GO 6128
6169: POP
6170: POP
// wait ( 0 0$1 ) ;
6171: LD_INT 35
6173: PPUSH
6174: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6178: LD_VAR 0 2
6182: PPUSH
6183: LD_INT 92
6185: PUSH
6186: LD_INT 125
6188: PUSH
6189: LD_INT 129
6191: PUSH
6192: LD_INT 9
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: PPUSH
6201: CALL_OW 72
6205: PUSH
6206: LD_VAR 0 2
6210: PUSH
6211: LD_INT 1
6213: MINUS
6214: GREATEREQUAL
6215: IFFALSE 6093
// end ; repeat wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// for i in tmp do
6224: LD_ADDR_VAR 0 1
6228: PUSH
6229: LD_VAR 0 2
6233: PUSH
6234: FOR_IN
6235: IFFALSE 6317
// begin if GetLives ( i ) > 251 then
6237: LD_VAR 0 1
6241: PPUSH
6242: CALL_OW 256
6246: PUSH
6247: LD_INT 251
6249: GREATER
6250: IFFALSE 6288
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6252: LD_VAR 0 1
6256: PPUSH
6257: LD_INT 81
6259: PUSH
6260: LD_INT 8
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PPUSH
6267: CALL_OW 69
6271: PPUSH
6272: LD_VAR 0 1
6276: PPUSH
6277: CALL_OW 74
6281: PPUSH
6282: CALL_OW 115
6286: GO 6315
// if IsDead ( i ) then
6288: LD_VAR 0 1
6292: PPUSH
6293: CALL_OW 301
6297: IFFALSE 6315
// tmp := tmp diff i ;
6299: LD_ADDR_VAR 0 2
6303: PUSH
6304: LD_VAR 0 2
6308: PUSH
6309: LD_VAR 0 1
6313: DIFF
6314: ST_TO_ADDR
// end ;
6315: GO 6234
6317: POP
6318: POP
// until not tmp ;
6319: LD_VAR 0 2
6323: NOT
6324: IFFALSE 6217
// end ;
6326: PPOPN 3
6328: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6329: LD_EXP 22
6333: NOT
6334: PUSH
6335: LD_EXP 15
6339: PUSH
6340: LD_INT 6
6342: GREATEREQUAL
6343: AND
6344: PUSH
6345: LD_OWVAR 67
6349: PUSH
6350: LD_INT 1
6352: GREATER
6353: AND
6354: IFFALSE 6871
6356: GO 6358
6358: DISABLE
6359: LD_INT 0
6361: PPUSH
6362: PPUSH
6363: PPUSH
// begin enable ;
6364: ENABLE
// tmp := [ ] ;
6365: LD_ADDR_VAR 0 3
6369: PUSH
6370: EMPTY
6371: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6372: LD_ADDR_VAR 0 1
6376: PUSH
6377: DOUBLE
6378: LD_INT 1
6380: DEC
6381: ST_TO_ADDR
6382: LD_INT 4
6384: PUSH
6385: LD_INT 6
6387: PUSH
6388: LD_INT 7
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: LIST
6395: PUSH
6396: LD_OWVAR 67
6400: ARRAY
6401: PUSH
6402: FOR_TO
6403: IFFALSE 6563
// begin uc_side := 8 ;
6405: LD_ADDR_OWVAR 20
6409: PUSH
6410: LD_INT 8
6412: ST_TO_ADDR
// uc_nation := 2 ;
6413: LD_ADDR_OWVAR 21
6417: PUSH
6418: LD_INT 2
6420: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6421: LD_INT 13
6423: PUSH
6424: LD_INT 14
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 2
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: PPUSH
6443: LD_INT 1
6445: PPUSH
6446: LD_INT 5
6448: PPUSH
6449: LD_INT 27
6451: PUSH
6452: LD_INT 28
6454: PUSH
6455: LD_INT 26
6457: PUSH
6458: LD_INT 25
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: PUSH
6467: LD_INT 1
6469: PPUSH
6470: LD_INT 4
6472: PPUSH
6473: CALL_OW 12
6477: ARRAY
6478: PPUSH
6479: LD_INT 88
6481: PPUSH
6482: CALL 70667 0 5
// un := CreateVehicle ;
6486: LD_ADDR_VAR 0 2
6490: PUSH
6491: CALL_OW 45
6495: ST_TO_ADDR
// tmp := tmp ^ un ;
6496: LD_ADDR_VAR 0 3
6500: PUSH
6501: LD_VAR 0 3
6505: PUSH
6506: LD_VAR 0 2
6510: ADD
6511: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6512: LD_VAR 0 2
6516: PPUSH
6517: LD_INT 3
6519: PPUSH
6520: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6524: LD_VAR 0 2
6528: PPUSH
6529: LD_INT 30
6531: PPUSH
6532: LD_INT 0
6534: PPUSH
6535: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6539: LD_VAR 0 2
6543: PPUSH
6544: LD_INT 16
6546: PPUSH
6547: LD_INT 11
6549: PPUSH
6550: CALL_OW 111
// wait ( 0 0$2 ) ;
6554: LD_INT 70
6556: PPUSH
6557: CALL_OW 67
// end ;
6561: GO 6402
6563: POP
6564: POP
// for i = 1 to Difficulty do
6565: LD_ADDR_VAR 0 1
6569: PUSH
6570: DOUBLE
6571: LD_INT 1
6573: DEC
6574: ST_TO_ADDR
6575: LD_OWVAR 67
6579: PUSH
6580: FOR_TO
6581: IFFALSE 6706
// begin uc_side := 8 ;
6583: LD_ADDR_OWVAR 20
6587: PUSH
6588: LD_INT 8
6590: ST_TO_ADDR
// uc_nation := 2 ;
6591: LD_ADDR_OWVAR 21
6595: PUSH
6596: LD_INT 2
6598: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6599: LD_INT 0
6601: PPUSH
6602: LD_INT 8
6604: PPUSH
6605: LD_INT 8
6607: PUSH
6608: LD_INT 8
6610: PUSH
6611: LD_INT 9
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: PUSH
6619: LD_OWVAR 67
6623: ARRAY
6624: PPUSH
6625: CALL_OW 380
// un := CreateHuman ;
6629: LD_ADDR_VAR 0 2
6633: PUSH
6634: CALL_OW 44
6638: ST_TO_ADDR
// tmp := tmp ^ un ;
6639: LD_ADDR_VAR 0 3
6643: PUSH
6644: LD_VAR 0 3
6648: PUSH
6649: LD_VAR 0 2
6653: ADD
6654: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 3
6662: PPUSH
6663: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 30
6674: PPUSH
6675: LD_INT 0
6677: PPUSH
6678: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6682: LD_VAR 0 2
6686: PPUSH
6687: LD_INT 16
6689: PPUSH
6690: LD_INT 11
6692: PPUSH
6693: CALL_OW 111
// wait ( 0 0$2 ) ;
6697: LD_INT 70
6699: PPUSH
6700: CALL_OW 67
// end ;
6704: GO 6580
6706: POP
6707: POP
// repeat wait ( 0 0$1 ) ;
6708: LD_INT 35
6710: PPUSH
6711: CALL_OW 67
// for i in tmp do
6715: LD_ADDR_VAR 0 1
6719: PUSH
6720: LD_VAR 0 3
6724: PUSH
6725: FOR_IN
6726: IFFALSE 6862
// begin if GetLives ( i ) > 250 then
6728: LD_VAR 0 1
6732: PPUSH
6733: CALL_OW 256
6737: PUSH
6738: LD_INT 250
6740: GREATER
6741: IFFALSE 6833
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6743: LD_INT 81
6745: PUSH
6746: LD_INT 8
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 91
6755: PUSH
6756: LD_VAR 0 1
6760: PUSH
6761: LD_INT 10
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: LIST
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: PPUSH
6773: CALL_OW 69
6777: NOT
6778: IFFALSE 6797
// ComAgressiveMove ( i , 67 , 110 ) else
6780: LD_VAR 0 1
6784: PPUSH
6785: LD_INT 67
6787: PPUSH
6788: LD_INT 110
6790: PPUSH
6791: CALL_OW 114
6795: GO 6831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6797: LD_VAR 0 1
6801: PPUSH
6802: LD_INT 81
6804: PUSH
6805: LD_INT 8
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: PPUSH
6812: CALL_OW 69
6816: PPUSH
6817: LD_VAR 0 1
6821: PPUSH
6822: CALL_OW 74
6826: PPUSH
6827: CALL_OW 115
// end else
6831: GO 6860
// if IsDead ( i ) then
6833: LD_VAR 0 1
6837: PPUSH
6838: CALL_OW 301
6842: IFFALSE 6860
// tmp := tmp diff i ;
6844: LD_ADDR_VAR 0 3
6848: PUSH
6849: LD_VAR 0 3
6853: PUSH
6854: LD_VAR 0 1
6858: DIFF
6859: ST_TO_ADDR
// end ;
6860: GO 6725
6862: POP
6863: POP
// until not tmp ;
6864: LD_VAR 0 3
6868: NOT
6869: IFFALSE 6708
// end ; end_of_file
6871: PPOPN 3
6873: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6874: LD_INT 0
6876: PPUSH
6877: PPUSH
6878: PPUSH
6879: PPUSH
6880: PPUSH
6881: PPUSH
6882: PPUSH
6883: PPUSH
6884: PPUSH
// side := 3 ;
6885: LD_ADDR_VAR 0 6
6889: PUSH
6890: LD_INT 3
6892: ST_TO_ADDR
// uc_side := side ;
6893: LD_ADDR_OWVAR 20
6897: PUSH
6898: LD_VAR 0 6
6902: ST_TO_ADDR
// uc_nation := 3 ;
6903: LD_ADDR_OWVAR 21
6907: PUSH
6908: LD_INT 3
6910: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6911: LD_ADDR_VAR 0 2
6915: PUSH
6916: LD_INT 22
6918: PUSH
6919: LD_VAR 0 6
6923: PUSH
6924: EMPTY
6925: LIST
6926: LIST
6927: PUSH
6928: LD_INT 21
6930: PUSH
6931: LD_INT 3
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: PUSH
6938: EMPTY
6939: LIST
6940: LIST
6941: PPUSH
6942: CALL_OW 69
6946: PUSH
6947: FOR_IN
6948: IFFALSE 6964
// SetBLevel ( i , 10 ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_INT 10
6957: PPUSH
6958: CALL_OW 241
6962: GO 6947
6964: POP
6965: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6966: LD_ADDR_VAR 0 9
6970: PUSH
6971: LD_INT 22
6973: PUSH
6974: LD_VAR 0 6
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: PUSH
6983: LD_INT 30
6985: PUSH
6986: LD_INT 34
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: PPUSH
6997: CALL_OW 69
7001: ST_TO_ADDR
// if teleport then
7002: LD_VAR 0 9
7006: IFFALSE 7027
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7008: LD_VAR 0 9
7012: PUSH
7013: LD_INT 1
7015: ARRAY
7016: PPUSH
7017: LD_INT 123
7019: PPUSH
7020: LD_INT 122
7022: PPUSH
7023: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7027: LD_ADDR_EXP 61
7031: PUSH
7032: LD_STRING Platonov
7034: PPUSH
7035: CALL_OW 25
7039: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7040: LD_ADDR_EXP 62
7044: PUSH
7045: LD_STRING Kovalyuk
7047: PPUSH
7048: CALL_OW 25
7052: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7053: LD_ADDR_EXP 64
7057: PUSH
7058: LD_STRING Yakotich
7060: PPUSH
7061: CALL_OW 25
7065: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7066: LD_ADDR_EXP 63
7070: PUSH
7071: LD_STRING Bystrov
7073: PPUSH
7074: CALL_OW 25
7078: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7079: LD_ADDR_EXP 65
7083: PUSH
7084: LD_STRING Gleb
7086: PPUSH
7087: CALL_OW 25
7091: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7092: LD_STRING 03_Cornel
7094: PPUSH
7095: CALL_OW 28
7099: IFFALSE 7147
// begin Bierezov := NewCharacter ( Mikhail ) ;
7101: LD_ADDR_EXP 66
7105: PUSH
7106: LD_STRING Mikhail
7108: PPUSH
7109: CALL_OW 25
7113: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7114: LD_EXP 66
7118: PPUSH
7119: LD_INT 197
7121: PPUSH
7122: LD_INT 111
7124: PPUSH
7125: LD_INT 9
7127: PPUSH
7128: LD_INT 0
7130: PPUSH
7131: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7135: LD_EXP 66
7139: PPUSH
7140: LD_INT 3
7142: PPUSH
7143: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7147: LD_EXP 61
7151: PPUSH
7152: LD_INT 126
7154: PPUSH
7155: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7159: LD_EXP 62
7163: PPUSH
7164: LD_INT 134
7166: PPUSH
7167: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7171: LD_EXP 64
7175: PPUSH
7176: LD_INT 197
7178: PPUSH
7179: LD_INT 111
7181: PPUSH
7182: LD_INT 9
7184: PPUSH
7185: LD_INT 0
7187: PPUSH
7188: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7192: LD_EXP 63
7196: PPUSH
7197: LD_INT 197
7199: PPUSH
7200: LD_INT 111
7202: PPUSH
7203: LD_INT 9
7205: PPUSH
7206: LD_INT 0
7208: PPUSH
7209: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7213: LD_EXP 65
7217: PPUSH
7218: LD_INT 197
7220: PPUSH
7221: LD_INT 111
7223: PPUSH
7224: LD_INT 9
7226: PPUSH
7227: LD_INT 0
7229: PPUSH
7230: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7234: LD_ADDR_VAR 0 5
7238: PUSH
7239: LD_INT 126
7241: PPUSH
7242: LD_INT 4
7244: PPUSH
7245: LD_STRING zhukov
7247: PPUSH
7248: LD_INT 9
7250: PUSH
7251: LD_INT 10
7253: PUSH
7254: LD_INT 10
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: ARRAY
7267: PPUSH
7268: LD_INT 90000
7270: PUSH
7271: LD_INT 1000
7273: PUSH
7274: LD_INT 300
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: LIST
7281: PPUSH
7282: LD_INT 21
7284: PUSH
7285: LD_INT 8
7287: PUSH
7288: LD_INT 13
7290: PUSH
7291: LD_INT 8
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: LIST
7298: LIST
7299: PPUSH
7300: CALL 74076 0 6
7304: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7305: LD_ADDR_VAR 0 4
7309: PUSH
7310: LD_INT 267
7312: PPUSH
7313: CALL_OW 274
7317: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7318: LD_VAR 0 4
7322: PPUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_INT 5000
7328: PPUSH
7329: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7333: LD_VAR 0 4
7337: PPUSH
7338: LD_INT 2
7340: PPUSH
7341: LD_INT 200
7343: PPUSH
7344: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7348: LD_VAR 0 4
7352: PPUSH
7353: LD_INT 3
7355: PPUSH
7356: LD_INT 200
7358: PPUSH
7359: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7363: LD_ADDR_EXP 99
7367: PUSH
7368: LD_EXP 99
7372: PPUSH
7373: LD_INT 2
7375: PPUSH
7376: LD_VAR 0 5
7380: PUSH
7381: LD_INT 22
7383: PUSH
7384: LD_VAR 0 6
7388: PUSH
7389: EMPTY
7390: LIST
7391: LIST
7392: PUSH
7393: LD_INT 3
7395: PUSH
7396: LD_INT 21
7398: PUSH
7399: LD_INT 2
7401: PUSH
7402: EMPTY
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: PPUSH
7414: CALL_OW 69
7418: UNION
7419: PUSH
7420: LD_EXP 61
7424: DIFF
7425: PPUSH
7426: CALL_OW 1
7430: ST_TO_ADDR
// behemoths := [ ] ;
7431: LD_ADDR_EXP 69
7435: PUSH
7436: EMPTY
7437: ST_TO_ADDR
// behemothBuilders := [ ] ;
7438: LD_ADDR_EXP 70
7442: PUSH
7443: EMPTY
7444: ST_TO_ADDR
// if Kovalyuk then
7445: LD_EXP 62
7449: IFFALSE 7471
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7451: LD_ADDR_EXP 70
7455: PUSH
7456: LD_EXP 70
7460: PPUSH
7461: LD_EXP 62
7465: PPUSH
7466: CALL 106412 0 2
7470: ST_TO_ADDR
// j := 3 ;
7471: LD_ADDR_VAR 0 3
7475: PUSH
7476: LD_INT 3
7478: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7479: LD_ADDR_VAR 0 2
7483: PUSH
7484: LD_INT 22
7486: PUSH
7487: LD_INT 3
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 25
7496: PUSH
7497: LD_INT 3
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: PPUSH
7508: CALL_OW 69
7512: PUSH
7513: LD_EXP 62
7517: DIFF
7518: PUSH
7519: FOR_IN
7520: IFFALSE 7570
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7522: LD_ADDR_EXP 70
7526: PUSH
7527: LD_EXP 70
7531: PPUSH
7532: LD_VAR 0 2
7536: PPUSH
7537: CALL 106412 0 2
7541: ST_TO_ADDR
// j := j - 1 ;
7542: LD_ADDR_VAR 0 3
7546: PUSH
7547: LD_VAR 0 3
7551: PUSH
7552: LD_INT 1
7554: MINUS
7555: ST_TO_ADDR
// if j = 0 then
7556: LD_VAR 0 3
7560: PUSH
7561: LD_INT 0
7563: EQUAL
7564: IFFALSE 7568
// break ;
7566: GO 7570
// end ;
7568: GO 7519
7570: POP
7571: POP
// end ;
7572: LD_VAR 0 1
7576: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7577: LD_INT 0
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7584: LD_ADDR_VAR 0 4
7588: PUSH
7589: LD_INT 209
7591: PUSH
7592: LD_INT 149
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PUSH
7599: LD_INT 219
7601: PUSH
7602: LD_INT 154
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: LD_INT 223
7611: PUSH
7612: LD_INT 149
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: LD_INT 232
7621: PUSH
7622: LD_INT 155
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: ST_TO_ADDR
// if not behemothBuilders then
7635: LD_EXP 70
7639: NOT
7640: IFFALSE 7644
// exit ;
7642: GO 7748
// j := 1 ;
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_INT 1
7651: ST_TO_ADDR
// for i in behemothBuilders do
7652: LD_ADDR_VAR 0 2
7656: PUSH
7657: LD_EXP 70
7661: PUSH
7662: FOR_IN
7663: IFFALSE 7746
// begin if IsInUnit ( i ) then
7665: LD_VAR 0 2
7669: PPUSH
7670: CALL_OW 310
7674: IFFALSE 7685
// ComExitBuilding ( i ) ;
7676: LD_VAR 0 2
7680: PPUSH
7681: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7685: LD_VAR 0 2
7689: PPUSH
7690: LD_INT 37
7692: PPUSH
7693: LD_VAR 0 4
7697: PUSH
7698: LD_VAR 0 3
7702: ARRAY
7703: PUSH
7704: LD_INT 1
7706: ARRAY
7707: PPUSH
7708: LD_VAR 0 4
7712: PUSH
7713: LD_VAR 0 3
7717: ARRAY
7718: PUSH
7719: LD_INT 2
7721: ARRAY
7722: PPUSH
7723: LD_INT 0
7725: PPUSH
7726: CALL_OW 230
// j := j + 1 ;
7730: LD_ADDR_VAR 0 3
7734: PUSH
7735: LD_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: PLUS
7743: ST_TO_ADDR
// end ;
7744: GO 7662
7746: POP
7747: POP
// end ;
7748: LD_VAR 0 1
7752: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7753: LD_INT 24
7755: PPUSH
7756: LD_INT 30
7758: PUSH
7759: LD_INT 37
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: PPUSH
7766: CALL_OW 70
7770: IFFALSE 7783
7772: GO 7774
7774: DISABLE
// behemothUnderConstruct := true ;
7775: LD_ADDR_EXP 26
7779: PUSH
7780: LD_INT 1
7782: ST_TO_ADDR
7783: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7784: LD_INT 3
7786: PPUSH
7787: CALL 106460 0 1
7791: PUSH
7792: LD_INT 22
7794: PUSH
7795: LD_INT 3
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PUSH
7802: LD_INT 30
7804: PUSH
7805: LD_INT 37
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: NOT
7821: AND
7822: IFFALSE 8008
7824: GO 7826
7826: DISABLE
7827: LD_INT 0
7829: PPUSH
7830: PPUSH
// begin enable ;
7831: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7832: LD_ADDR_VAR 0 2
7836: PUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL 106460 0 1
7844: ST_TO_ADDR
// for i in tmp do
7845: LD_ADDR_VAR 0 1
7849: PUSH
7850: LD_VAR 0 2
7854: PUSH
7855: FOR_IN
7856: IFFALSE 8006
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7858: LD_VAR 0 1
7862: PPUSH
7863: LD_INT 9
7865: PPUSH
7866: CALL_OW 308
7870: PUSH
7871: LD_VAR 0 1
7875: PPUSH
7876: CALL_OW 110
7880: PUSH
7881: LD_INT 2
7883: EQUAL
7884: NOT
7885: AND
7886: IFFALSE 7900
// SetTag ( i , 2 ) ;
7888: LD_VAR 0 1
7892: PPUSH
7893: LD_INT 2
7895: PPUSH
7896: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7900: LD_INT 81
7902: PUSH
7903: LD_INT 3
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: LD_INT 91
7912: PUSH
7913: LD_VAR 0 1
7917: PUSH
7918: LD_INT 12
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 69
7934: NOT
7935: PUSH
7936: LD_VAR 0 1
7940: PPUSH
7941: CALL_OW 110
7945: PUSH
7946: LD_INT 2
7948: EQUAL
7949: NOT
7950: AND
7951: IFFALSE 7970
// ComAgressiveMove ( i , 64 , 93 ) else
7953: LD_VAR 0 1
7957: PPUSH
7958: LD_INT 64
7960: PPUSH
7961: LD_INT 93
7963: PPUSH
7964: CALL_OW 114
7968: GO 8004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7970: LD_VAR 0 1
7974: PPUSH
7975: LD_INT 81
7977: PUSH
7978: LD_INT 3
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PPUSH
7985: CALL_OW 69
7989: PPUSH
7990: LD_VAR 0 1
7994: PPUSH
7995: CALL_OW 74
7999: PPUSH
8000: CALL_OW 115
// end ;
8004: GO 7855
8006: POP
8007: POP
// end ;
8008: PPOPN 2
8010: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8011: LD_INT 0
8013: PPUSH
8014: PPUSH
8015: PPUSH
// result := [ ] ;
8016: LD_ADDR_VAR 0 2
8020: PUSH
8021: EMPTY
8022: ST_TO_ADDR
// uc_side := 6 ;
8023: LD_ADDR_OWVAR 20
8027: PUSH
8028: LD_INT 6
8030: ST_TO_ADDR
// uc_nation := 3 ;
8031: LD_ADDR_OWVAR 21
8035: PUSH
8036: LD_INT 3
8038: ST_TO_ADDR
// case strength of 1 :
8039: LD_VAR 0 1
8043: PUSH
8044: LD_INT 1
8046: DOUBLE
8047: EQUAL
8048: IFTRUE 8052
8050: GO 8190
8052: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8053: LD_ADDR_VAR 0 3
8057: PUSH
8058: DOUBLE
8059: LD_INT 1
8061: DEC
8062: ST_TO_ADDR
8063: LD_INT 4
8065: PUSH
8066: LD_INT 5
8068: PUSH
8069: LD_INT 6
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: LIST
8076: PUSH
8077: LD_OWVAR 67
8081: ARRAY
8082: PUSH
8083: FOR_TO
8084: IFFALSE 8186
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8086: LD_INT 22
8088: PUSH
8089: LD_INT 24
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PUSH
8096: LD_VAR 0 3
8100: PUSH
8101: LD_INT 2
8103: MOD
8104: PUSH
8105: LD_INT 1
8107: PLUS
8108: ARRAY
8109: PPUSH
8110: LD_INT 1
8112: PUSH
8113: LD_INT 3
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PUSH
8120: LD_INT 1
8122: PPUSH
8123: LD_INT 2
8125: PPUSH
8126: CALL_OW 12
8130: ARRAY
8131: PPUSH
8132: LD_INT 3
8134: PPUSH
8135: LD_INT 43
8137: PUSH
8138: LD_INT 44
8140: PUSH
8141: LD_INT 45
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 1
8151: PPUSH
8152: LD_INT 3
8154: PPUSH
8155: CALL_OW 12
8159: ARRAY
8160: PPUSH
8161: LD_INT 80
8163: PPUSH
8164: CALL 70667 0 5
// result := result union CreateVehicle ;
8168: LD_ADDR_VAR 0 2
8172: PUSH
8173: LD_VAR 0 2
8177: PUSH
8178: CALL_OW 45
8182: UNION
8183: ST_TO_ADDR
// end ;
8184: GO 8083
8186: POP
8187: POP
// end ; 2 :
8188: GO 9134
8190: LD_INT 2
8192: DOUBLE
8193: EQUAL
8194: IFTRUE 8198
8196: GO 8354
8198: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8199: LD_ADDR_VAR 0 3
8203: PUSH
8204: DOUBLE
8205: LD_INT 1
8207: DEC
8208: ST_TO_ADDR
8209: LD_INT 6
8211: PUSH
8212: LD_INT 6
8214: PUSH
8215: LD_INT 7
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PUSH
8223: LD_OWVAR 67
8227: ARRAY
8228: PUSH
8229: FOR_TO
8230: IFFALSE 8350
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8232: LD_INT 22
8234: PUSH
8235: LD_INT 24
8237: PUSH
8238: LD_INT 24
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: PUSH
8246: LD_VAR 0 3
8250: PUSH
8251: LD_INT 3
8253: MOD
8254: PUSH
8255: LD_INT 1
8257: PLUS
8258: ARRAY
8259: PPUSH
8260: LD_INT 1
8262: PUSH
8263: LD_INT 3
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: PUSH
8270: LD_INT 1
8272: PPUSH
8273: LD_INT 2
8275: PPUSH
8276: CALL_OW 12
8280: ARRAY
8281: PPUSH
8282: LD_INT 3
8284: PPUSH
8285: LD_INT 43
8287: PUSH
8288: LD_INT 44
8290: PUSH
8291: LD_INT 45
8293: PUSH
8294: LD_INT 44
8296: PUSH
8297: LD_INT 46
8299: PUSH
8300: LD_INT 46
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: LIST
8307: LIST
8308: LIST
8309: LIST
8310: PUSH
8311: LD_VAR 0 3
8315: PUSH
8316: LD_INT 6
8318: MOD
8319: PUSH
8320: LD_INT 1
8322: PLUS
8323: ARRAY
8324: PPUSH
8325: LD_INT 80
8327: PPUSH
8328: CALL 70667 0 5
// result := result union CreateVehicle ;
8332: LD_ADDR_VAR 0 2
8336: PUSH
8337: LD_VAR 0 2
8341: PUSH
8342: CALL_OW 45
8346: UNION
8347: ST_TO_ADDR
// end ;
8348: GO 8229
8350: POP
8351: POP
// end ; 3 :
8352: GO 9134
8354: LD_INT 3
8356: DOUBLE
8357: EQUAL
8358: IFTRUE 8362
8360: GO 8518
8362: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8363: LD_ADDR_VAR 0 3
8367: PUSH
8368: DOUBLE
8369: LD_INT 1
8371: DEC
8372: ST_TO_ADDR
8373: LD_INT 6
8375: PUSH
8376: LD_INT 7
8378: PUSH
8379: LD_INT 8
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_OWVAR 67
8391: ARRAY
8392: PUSH
8393: FOR_TO
8394: IFFALSE 8514
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8396: LD_INT 22
8398: PUSH
8399: LD_INT 24
8401: PUSH
8402: LD_INT 24
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: LIST
8409: PUSH
8410: LD_VAR 0 3
8414: PUSH
8415: LD_INT 3
8417: MOD
8418: PUSH
8419: LD_INT 1
8421: PLUS
8422: ARRAY
8423: PPUSH
8424: LD_INT 1
8426: PUSH
8427: LD_INT 3
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 1
8436: PPUSH
8437: LD_INT 2
8439: PPUSH
8440: CALL_OW 12
8444: ARRAY
8445: PPUSH
8446: LD_INT 3
8448: PPUSH
8449: LD_INT 43
8451: PUSH
8452: LD_INT 47
8454: PUSH
8455: LD_INT 45
8457: PUSH
8458: LD_INT 45
8460: PUSH
8461: LD_INT 46
8463: PUSH
8464: LD_INT 46
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: LIST
8471: LIST
8472: LIST
8473: LIST
8474: PUSH
8475: LD_VAR 0 3
8479: PUSH
8480: LD_INT 6
8482: MOD
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: ARRAY
8488: PPUSH
8489: LD_INT 80
8491: PPUSH
8492: CALL 70667 0 5
// result := result union CreateVehicle ;
8496: LD_ADDR_VAR 0 2
8500: PUSH
8501: LD_VAR 0 2
8505: PUSH
8506: CALL_OW 45
8510: UNION
8511: ST_TO_ADDR
// end ;
8512: GO 8393
8514: POP
8515: POP
// end ; 4 :
8516: GO 9134
8518: LD_INT 4
8520: DOUBLE
8521: EQUAL
8522: IFTRUE 8526
8524: GO 9133
8526: POP
// begin uc_nation := 3 ;
8527: LD_ADDR_OWVAR 21
8531: PUSH
8532: LD_INT 3
8534: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: DOUBLE
8541: LD_INT 1
8543: DEC
8544: ST_TO_ADDR
8545: LD_INT 7
8547: PUSH
8548: LD_INT 8
8550: PUSH
8551: LD_INT 9
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: PUSH
8559: LD_OWVAR 67
8563: ARRAY
8564: PUSH
8565: FOR_TO
8566: IFFALSE 8686
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8568: LD_INT 22
8570: PUSH
8571: LD_INT 24
8573: PUSH
8574: LD_INT 24
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_VAR 0 3
8586: PUSH
8587: LD_INT 3
8589: MOD
8590: PUSH
8591: LD_INT 1
8593: PLUS
8594: ARRAY
8595: PPUSH
8596: LD_INT 1
8598: PUSH
8599: LD_INT 3
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_INT 1
8608: PPUSH
8609: LD_INT 2
8611: PPUSH
8612: CALL_OW 12
8616: ARRAY
8617: PPUSH
8618: LD_INT 3
8620: PPUSH
8621: LD_INT 45
8623: PUSH
8624: LD_INT 47
8626: PUSH
8627: LD_INT 47
8629: PUSH
8630: LD_INT 45
8632: PUSH
8633: LD_INT 46
8635: PUSH
8636: LD_INT 46
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: PUSH
8647: LD_VAR 0 3
8651: PUSH
8652: LD_INT 6
8654: MOD
8655: PUSH
8656: LD_INT 1
8658: PLUS
8659: ARRAY
8660: PPUSH
8661: LD_INT 80
8663: PPUSH
8664: CALL 70667 0 5
// result := result union CreateVehicle ;
8668: LD_ADDR_VAR 0 2
8672: PUSH
8673: LD_VAR 0 2
8677: PUSH
8678: CALL_OW 45
8682: UNION
8683: ST_TO_ADDR
// end ;
8684: GO 8565
8686: POP
8687: POP
// if not KappaStatus then
8688: LD_EXP 2
8692: NOT
8693: IFFALSE 8928
// begin uc_nation := 1 ;
8695: LD_ADDR_OWVAR 21
8699: PUSH
8700: LD_INT 1
8702: ST_TO_ADDR
// for i = 1 to 3 do
8703: LD_ADDR_VAR 0 3
8707: PUSH
8708: DOUBLE
8709: LD_INT 1
8711: DEC
8712: ST_TO_ADDR
8713: LD_INT 3
8715: PUSH
8716: FOR_TO
8717: IFFALSE 8853
// begin j := rand ( 0 , 1 ) ;
8719: LD_ADDR_VAR 0 4
8723: PUSH
8724: LD_INT 0
8726: PPUSH
8727: LD_INT 1
8729: PPUSH
8730: CALL_OW 12
8734: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8735: LD_INT 3
8737: PUSH
8738: LD_INT 5
8740: PUSH
8741: LD_INT 5
8743: PUSH
8744: LD_INT 4
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: PUSH
8753: LD_VAR 0 4
8757: PUSH
8758: LD_INT 1
8760: PPUSH
8761: LD_INT 3
8763: PPUSH
8764: CALL_OW 12
8768: PLUS
8769: ARRAY
8770: PPUSH
8771: LD_INT 1
8773: PUSH
8774: LD_INT 3
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 1
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: CALL_OW 12
8791: ARRAY
8792: PPUSH
8793: LD_INT 3
8795: PPUSH
8796: LD_INT 9
8798: PUSH
8799: LD_INT 7
8801: PUSH
8802: LD_INT 6
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: LIST
8809: PUSH
8810: LD_VAR 0 4
8814: PUSH
8815: LD_INT 1
8817: PPUSH
8818: LD_INT 2
8820: PPUSH
8821: CALL_OW 12
8825: PLUS
8826: ARRAY
8827: PPUSH
8828: LD_INT 85
8830: PPUSH
8831: CALL 70667 0 5
// result := result union CreateVehicle ;
8835: LD_ADDR_VAR 0 2
8839: PUSH
8840: LD_VAR 0 2
8844: PUSH
8845: CALL_OW 45
8849: UNION
8850: ST_TO_ADDR
// end ;
8851: GO 8716
8853: POP
8854: POP
// if vsevolodFirstAttack then
8855: LD_EXP 24
8859: IFFALSE 8926
// begin vsevolodFirstAttack := false ;
8861: LD_ADDR_EXP 24
8865: PUSH
8866: LD_INT 0
8868: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8869: LD_INT 5
8871: PPUSH
8872: LD_INT 3
8874: PPUSH
8875: LD_INT 1
8877: PPUSH
8878: LD_INT 6
8880: PPUSH
8881: LD_INT 100
8883: PPUSH
8884: CALL 70667 0 5
// sewiVeh := CreateVehicle ;
8888: LD_ADDR_EXP 68
8892: PUSH
8893: CALL_OW 45
8897: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8898: LD_EXP 68
8902: PPUSH
8903: LD_INT 1
8905: PPUSH
8906: CALL_OW 242
// result := result union sewiVeh ;
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_VAR 0 2
8919: PUSH
8920: LD_EXP 68
8924: UNION
8925: ST_TO_ADDR
// end ; end else
8926: GO 9131
// if vsevolodFirstAttack then
8928: LD_EXP 24
8932: IFFALSE 9131
// begin vsevolodFirstAttack := false ;
8934: LD_ADDR_EXP 24
8938: PUSH
8939: LD_INT 0
8941: ST_TO_ADDR
// uc_nation := 3 ;
8942: LD_ADDR_OWVAR 21
8946: PUSH
8947: LD_INT 3
8949: ST_TO_ADDR
// for i = 1 to 3 do
8950: LD_ADDR_VAR 0 3
8954: PUSH
8955: DOUBLE
8956: LD_INT 1
8958: DEC
8959: ST_TO_ADDR
8960: LD_INT 3
8962: PUSH
8963: FOR_TO
8964: IFFALSE 9072
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8966: LD_INT 22
8968: PUSH
8969: LD_INT 24
8971: PUSH
8972: LD_INT 24
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: LIST
8979: PUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_INT 3
8987: MOD
8988: PUSH
8989: LD_INT 1
8991: PLUS
8992: ARRAY
8993: PPUSH
8994: LD_INT 1
8996: PUSH
8997: LD_INT 3
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PUSH
9004: LD_INT 1
9006: PPUSH
9007: LD_INT 2
9009: PPUSH
9010: CALL_OW 12
9014: ARRAY
9015: PPUSH
9016: LD_INT 3
9018: PPUSH
9019: LD_INT 45
9021: PUSH
9022: LD_INT 47
9024: PUSH
9025: LD_INT 47
9027: PUSH
9028: EMPTY
9029: LIST
9030: LIST
9031: LIST
9032: PUSH
9033: LD_VAR 0 3
9037: PUSH
9038: LD_INT 3
9040: MOD
9041: PUSH
9042: LD_INT 1
9044: PLUS
9045: ARRAY
9046: PPUSH
9047: LD_INT 80
9049: PPUSH
9050: CALL 70667 0 5
// result := result union CreateVehicle ;
9054: LD_ADDR_VAR 0 2
9058: PUSH
9059: LD_VAR 0 2
9063: PUSH
9064: CALL_OW 45
9068: UNION
9069: ST_TO_ADDR
// end ;
9070: GO 8963
9072: POP
9073: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9074: LD_INT 24
9076: PPUSH
9077: LD_INT 3
9079: PPUSH
9080: LD_INT 1
9082: PPUSH
9083: LD_INT 47
9085: PPUSH
9086: LD_INT 100
9088: PPUSH
9089: CALL 70667 0 5
// sewiVeh := CreateVehicle ;
9093: LD_ADDR_EXP 68
9097: PUSH
9098: CALL_OW 45
9102: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9103: LD_EXP 68
9107: PPUSH
9108: LD_INT 1
9110: PPUSH
9111: CALL_OW 242
// result := result union sewiVeh ;
9115: LD_ADDR_VAR 0 2
9119: PUSH
9120: LD_VAR 0 2
9124: PUSH
9125: LD_EXP 68
9129: UNION
9130: ST_TO_ADDR
// end ; end ; end ;
9131: GO 9134
9133: POP
// end ;
9134: LD_VAR 0 2
9138: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9139: LD_EXP 16
9143: IFFALSE 9891
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
9152: PPUSH
9153: PPUSH
9154: PPUSH
9155: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9156: LD_ADDR_VAR 0 4
9160: PUSH
9161: LD_INT 11
9163: PUSH
9164: LD_INT 12
9166: PUSH
9167: EMPTY
9168: LIST
9169: LIST
9170: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9171: LD_ADDR_VAR 0 3
9175: PUSH
9176: LD_INT 8400
9178: PUSH
9179: LD_INT 7350
9181: PUSH
9182: LD_INT 6650
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: LIST
9189: PUSH
9190: LD_OWVAR 67
9194: ARRAY
9195: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9196: LD_ADDR_VAR 0 6
9200: PUSH
9201: LD_INT 70
9203: PUSH
9204: LD_INT 118
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: LD_INT 78
9213: PUSH
9214: LD_INT 31
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: ST_TO_ADDR
// repeat if missionStage = 2 then
9225: LD_EXP 15
9229: PUSH
9230: LD_INT 2
9232: EQUAL
9233: IFFALSE 9244
// wait ( 1 1$30 ) else
9235: LD_INT 3150
9237: PPUSH
9238: CALL_OW 67
9242: GO 9253
// wait ( time ) ;
9244: LD_VAR 0 3
9248: PPUSH
9249: CALL_OW 67
// if missionStage = 6 then
9253: LD_EXP 15
9257: PUSH
9258: LD_INT 6
9260: EQUAL
9261: IFFALSE 9289
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9263: LD_INT 51
9265: PPUSH
9266: LD_INT 6
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9276: LD_INT 57
9278: PPUSH
9279: LD_INT 6
9281: PPUSH
9282: LD_INT 2
9284: PPUSH
9285: CALL_OW 322
// end ; if missionStage = 8 then
9289: LD_EXP 15
9293: PUSH
9294: LD_INT 8
9296: EQUAL
9297: IFFALSE 9325
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9299: LD_INT 52
9301: PPUSH
9302: LD_INT 6
9304: PPUSH
9305: LD_INT 2
9307: PPUSH
9308: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9312: LD_INT 58
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 2
9320: PPUSH
9321: CALL_OW 322
// end ; if missionStage = 10 then
9325: LD_EXP 15
9329: PUSH
9330: LD_INT 10
9332: EQUAL
9333: IFFALSE 9361
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9335: LD_INT 53
9337: PPUSH
9338: LD_INT 6
9340: PPUSH
9341: LD_INT 2
9343: PPUSH
9344: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9348: LD_INT 59
9350: PPUSH
9351: LD_INT 6
9353: PPUSH
9354: LD_INT 2
9356: PPUSH
9357: CALL_OW 322
// end ; if activeAttacks then
9361: LD_EXP 16
9365: IFFALSE 9885
// begin if missionStage = 2 then
9367: LD_EXP 15
9371: PUSH
9372: LD_INT 2
9374: EQUAL
9375: IFFALSE 9385
// strength := 1 ;
9377: LD_ADDR_VAR 0 5
9381: PUSH
9382: LD_INT 1
9384: ST_TO_ADDR
// if missionStage > 2 then
9385: LD_EXP 15
9389: PUSH
9390: LD_INT 2
9392: GREATER
9393: IFFALSE 9403
// strength := 2 ;
9395: LD_ADDR_VAR 0 5
9399: PUSH
9400: LD_INT 2
9402: ST_TO_ADDR
// if missionStage > 6 then
9403: LD_EXP 15
9407: PUSH
9408: LD_INT 6
9410: GREATER
9411: IFFALSE 9421
// strength := 3 ;
9413: LD_ADDR_VAR 0 5
9417: PUSH
9418: LD_INT 3
9420: ST_TO_ADDR
// if missionStage > 10 then
9421: LD_EXP 15
9425: PUSH
9426: LD_INT 10
9428: GREATER
9429: IFFALSE 9439
// strength := 4 ;
9431: LD_ADDR_VAR 0 5
9435: PUSH
9436: LD_INT 4
9438: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9439: LD_ADDR_VAR 0 2
9443: PUSH
9444: LD_VAR 0 5
9448: PPUSH
9449: CALL 8011 0 1
9453: ST_TO_ADDR
// for i in tmp do
9454: LD_ADDR_VAR 0 1
9458: PUSH
9459: LD_VAR 0 2
9463: PUSH
9464: FOR_IN
9465: IFFALSE 9565
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9467: LD_VAR 0 1
9471: PPUSH
9472: LD_VAR 0 4
9476: PUSH
9477: LD_INT 1
9479: PPUSH
9480: LD_INT 2
9482: PPUSH
9483: CALL_OW 12
9487: ARRAY
9488: PPUSH
9489: LD_INT 0
9491: PPUSH
9492: CALL_OW 49
// if i = sewiVeh then
9496: LD_VAR 0 1
9500: PUSH
9501: LD_EXP 68
9505: EQUAL
9506: IFFALSE 9541
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9508: LD_ADDR_EXP 67
9512: PUSH
9513: LD_STRING Vsevolod
9515: PPUSH
9516: LD_INT 0
9518: PPUSH
9519: LD_STRING 
9521: PPUSH
9522: CALL 63701 0 3
9526: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9527: LD_EXP 67
9531: PPUSH
9532: LD_VAR 0 1
9536: PPUSH
9537: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9541: LD_VAR 0 1
9545: PPUSH
9546: LD_INT 111
9548: PPUSH
9549: LD_INT 197
9551: PPUSH
9552: CALL_OW 111
// wait ( 0 0$2 ) ;
9556: LD_INT 70
9558: PPUSH
9559: CALL_OW 67
// end ;
9563: GO 9464
9565: POP
9566: POP
// repeat wait ( 0 0$1 ) ;
9567: LD_INT 35
9569: PPUSH
9570: CALL_OW 67
// for i in tmp do
9574: LD_ADDR_VAR 0 1
9578: PUSH
9579: LD_VAR 0 2
9583: PUSH
9584: FOR_IN
9585: IFFALSE 9866
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9587: LD_INT 81
9589: PUSH
9590: LD_INT 6
9592: PUSH
9593: EMPTY
9594: LIST
9595: LIST
9596: PUSH
9597: LD_INT 91
9599: PUSH
9600: LD_VAR 0 1
9604: PUSH
9605: LD_INT 12
9607: PUSH
9608: EMPTY
9609: LIST
9610: LIST
9611: LIST
9612: PUSH
9613: EMPTY
9614: LIST
9615: LIST
9616: PPUSH
9617: CALL_OW 69
9621: IFFALSE 9679
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9623: LD_VAR 0 1
9627: PPUSH
9628: LD_INT 81
9630: PUSH
9631: LD_INT 6
9633: PUSH
9634: EMPTY
9635: LIST
9636: LIST
9637: PUSH
9638: LD_INT 91
9640: PUSH
9641: LD_VAR 0 1
9645: PUSH
9646: LD_INT 12
9648: PUSH
9649: EMPTY
9650: LIST
9651: LIST
9652: LIST
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: PPUSH
9658: CALL_OW 69
9662: PPUSH
9663: LD_VAR 0 1
9667: PPUSH
9668: CALL_OW 74
9672: PPUSH
9673: CALL_OW 115
9677: GO 9864
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9679: LD_INT 9
9681: PPUSH
9682: LD_INT 81
9684: PUSH
9685: LD_INT 6
9687: PUSH
9688: EMPTY
9689: LIST
9690: LIST
9691: PPUSH
9692: CALL_OW 70
9696: IFFALSE 9830
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9698: LD_VAR 0 1
9702: PPUSH
9703: LD_VAR 0 6
9707: PUSH
9708: LD_INT 1
9710: ARRAY
9711: PUSH
9712: LD_INT 1
9714: ARRAY
9715: PPUSH
9716: LD_VAR 0 6
9720: PUSH
9721: LD_INT 1
9723: ARRAY
9724: PUSH
9725: LD_INT 2
9727: ARRAY
9728: PPUSH
9729: CALL_OW 297
9733: PUSH
9734: LD_INT 10
9736: GREATER
9737: PUSH
9738: LD_VAR 0 1
9742: PPUSH
9743: LD_INT 9
9745: PPUSH
9746: CALL_OW 308
9750: NOT
9751: AND
9752: IFFALSE 9791
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9754: LD_VAR 0 1
9758: PPUSH
9759: LD_VAR 0 6
9763: PUSH
9764: LD_INT 1
9766: ARRAY
9767: PUSH
9768: LD_INT 1
9770: ARRAY
9771: PPUSH
9772: LD_VAR 0 6
9776: PUSH
9777: LD_INT 1
9779: ARRAY
9780: PUSH
9781: LD_INT 2
9783: ARRAY
9784: PPUSH
9785: CALL_OW 114
9789: GO 9828
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9791: LD_VAR 0 1
9795: PPUSH
9796: LD_INT 9
9798: PPUSH
9799: LD_INT 81
9801: PUSH
9802: LD_INT 6
9804: PUSH
9805: EMPTY
9806: LIST
9807: LIST
9808: PPUSH
9809: CALL_OW 70
9813: PPUSH
9814: LD_VAR 0 1
9818: PPUSH
9819: CALL_OW 74
9823: PPUSH
9824: CALL_OW 115
// end else
9828: GO 9864
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9830: LD_VAR 0 1
9834: PPUSH
9835: LD_INT 81
9837: PUSH
9838: LD_INT 6
9840: PUSH
9841: EMPTY
9842: LIST
9843: LIST
9844: PPUSH
9845: CALL_OW 69
9849: PPUSH
9850: LD_VAR 0 1
9854: PPUSH
9855: CALL_OW 74
9859: PPUSH
9860: CALL_OW 115
// end ;
9864: GO 9584
9866: POP
9867: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9868: LD_INT 22
9870: PUSH
9871: LD_INT 6
9873: PUSH
9874: EMPTY
9875: LIST
9876: LIST
9877: PPUSH
9878: CALL_OW 69
9882: NOT
9883: IFFALSE 9567
// end ; until russianDestroyed ;
9885: LD_EXP 21
9889: IFFALSE 9225
// end ;
9891: PPOPN 6
9893: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9894: LD_EXP 21
9898: NOT
9899: PUSH
9900: LD_EXP 15
9904: PUSH
9905: LD_INT 6
9907: GREATEREQUAL
9908: AND
9909: PUSH
9910: LD_INT 2
9912: PPUSH
9913: LD_INT 1
9915: PPUSH
9916: CALL 58909 0 2
9920: NOT
9921: AND
9922: IFFALSE 10878
9924: GO 9926
9926: DISABLE
9927: LD_INT 0
9929: PPUSH
9930: PPUSH
9931: PPUSH
9932: PPUSH
// begin enable ;
9933: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9934: LD_INT 22
9936: PUSH
9937: LD_INT 3
9939: PUSH
9940: EMPTY
9941: LIST
9942: LIST
9943: PUSH
9944: LD_INT 30
9946: PUSH
9947: LD_INT 3
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: PPUSH
9958: CALL_OW 69
9962: NOT
9963: IFFALSE 9967
// exit ;
9965: GO 10878
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9967: LD_ADDR_VAR 0 4
9971: PUSH
9972: LD_INT 22
9974: PUSH
9975: LD_INT 3
9977: PUSH
9978: EMPTY
9979: LIST
9980: LIST
9981: PUSH
9982: LD_INT 30
9984: PUSH
9985: LD_INT 34
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PUSH
9992: EMPTY
9993: LIST
9994: LIST
9995: PPUSH
9996: CALL_OW 69
10000: ST_TO_ADDR
// if Prob ( 40 ) then
10001: LD_INT 40
10003: PPUSH
10004: CALL_OW 13
10008: IFFALSE 10135
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10010: LD_INT 2
10012: PPUSH
10013: LD_INT 22
10015: PUSH
10016: LD_INT 3
10018: PUSH
10019: LD_INT 3
10021: PUSH
10022: LD_INT 49
10024: PUSH
10025: EMPTY
10026: LIST
10027: LIST
10028: LIST
10029: LIST
10030: PUSH
10031: LD_INT 22
10033: PUSH
10034: LD_INT 3
10036: PUSH
10037: LD_INT 3
10039: PUSH
10040: LD_INT 49
10042: PUSH
10043: EMPTY
10044: LIST
10045: LIST
10046: LIST
10047: LIST
10048: PUSH
10049: LD_INT 22
10051: PUSH
10052: LD_INT 3
10054: PUSH
10055: LD_INT 3
10057: PUSH
10058: LD_INT 49
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_INT 24
10069: PUSH
10070: LD_INT 3
10072: PUSH
10073: LD_INT 3
10075: PUSH
10076: LD_INT 46
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 24
10087: PUSH
10088: LD_INT 3
10090: PUSH
10091: LD_INT 3
10093: PUSH
10094: LD_INT 46
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_INT 24
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 3
10111: PUSH
10112: LD_INT 46
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PUSH
10121: EMPTY
10122: LIST
10123: LIST
10124: LIST
10125: LIST
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL 57491 0 2
// end else
10133: GO 10258
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10135: LD_INT 2
10137: PPUSH
10138: LD_INT 24
10140: PUSH
10141: LD_INT 3
10143: PUSH
10144: LD_INT 3
10146: PUSH
10147: LD_INT 47
10149: PUSH
10150: EMPTY
10151: LIST
10152: LIST
10153: LIST
10154: LIST
10155: PUSH
10156: LD_INT 24
10158: PUSH
10159: LD_INT 3
10161: PUSH
10162: LD_INT 3
10164: PUSH
10165: LD_INT 47
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: LIST
10172: LIST
10173: PUSH
10174: LD_INT 24
10176: PUSH
10177: LD_INT 3
10179: PUSH
10180: LD_INT 3
10182: PUSH
10183: LD_INT 47
10185: PUSH
10186: EMPTY
10187: LIST
10188: LIST
10189: LIST
10190: LIST
10191: PUSH
10192: LD_INT 24
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: LD_INT 3
10200: PUSH
10201: LD_INT 46
10203: PUSH
10204: EMPTY
10205: LIST
10206: LIST
10207: LIST
10208: LIST
10209: PUSH
10210: LD_INT 24
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 3
10218: PUSH
10219: LD_INT 46
10221: PUSH
10222: EMPTY
10223: LIST
10224: LIST
10225: LIST
10226: LIST
10227: PUSH
10228: LD_INT 24
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 3
10236: PUSH
10237: LD_INT 46
10239: PUSH
10240: EMPTY
10241: LIST
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: LIST
10250: LIST
10251: LIST
10252: LIST
10253: PPUSH
10254: CALL 57491 0 2
// end ; if Difficulty > 1 then
10258: LD_OWVAR 67
10262: PUSH
10263: LD_INT 1
10265: GREATER
10266: IFFALSE 10296
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10268: LD_INT 2
10270: PPUSH
10271: LD_INT 24
10273: PUSH
10274: LD_INT 3
10276: PUSH
10277: LD_INT 3
10279: PUSH
10280: LD_INT 47
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: LIST
10287: LIST
10288: PUSH
10289: EMPTY
10290: LIST
10291: PPUSH
10292: CALL 57491 0 2
// repeat wait ( 0 0$1 ) ;
10296: LD_INT 35
10298: PPUSH
10299: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10303: LD_INT 2
10305: PPUSH
10306: LD_INT 1
10308: PPUSH
10309: CALL 58909 0 2
10313: PUSH
10314: LD_INT 6
10316: PUSH
10317: LD_INT 7
10319: PUSH
10320: LD_INT 7
10322: PUSH
10323: EMPTY
10324: LIST
10325: LIST
10326: LIST
10327: PUSH
10328: LD_OWVAR 67
10332: ARRAY
10333: GREATEREQUAL
10334: IFFALSE 10296
// wait ( 0 0$30 ) ;
10336: LD_INT 1050
10338: PPUSH
10339: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10343: LD_ADDR_VAR 0 2
10347: PUSH
10348: LD_INT 2
10350: PPUSH
10351: LD_INT 1
10353: PPUSH
10354: CALL 58909 0 2
10358: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10359: LD_ADDR_EXP 118
10363: PUSH
10364: LD_EXP 118
10368: PPUSH
10369: LD_INT 2
10371: PPUSH
10372: LD_EXP 118
10376: PUSH
10377: LD_INT 2
10379: ARRAY
10380: PUSH
10381: LD_VAR 0 2
10385: DIFF
10386: PPUSH
10387: CALL_OW 1
10391: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10392: LD_ADDR_VAR 0 3
10396: PUSH
10397: LD_INT 0
10399: PPUSH
10400: LD_INT 1
10402: PPUSH
10403: CALL_OW 12
10407: ST_TO_ADDR
// if target then
10408: LD_VAR 0 3
10412: IFFALSE 10540
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10414: LD_ADDR_VAR 0 2
10418: PUSH
10419: LD_VAR 0 2
10423: PPUSH
10424: LD_INT 24
10426: PUSH
10427: LD_INT 250
10429: PUSH
10430: EMPTY
10431: LIST
10432: LIST
10433: PPUSH
10434: CALL_OW 72
10438: ST_TO_ADDR
// for i in tmp do
10439: LD_ADDR_VAR 0 1
10443: PUSH
10444: LD_VAR 0 2
10448: PUSH
10449: FOR_IN
10450: IFFALSE 10490
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10452: LD_VAR 0 1
10456: PPUSH
10457: LD_INT 139
10459: PPUSH
10460: LD_INT 89
10462: PPUSH
10463: CALL_OW 297
10467: PUSH
10468: LD_INT 9
10470: GREATER
10471: IFFALSE 10488
// ComMoveXY ( i , 139 , 89 ) ;
10473: LD_VAR 0 1
10477: PPUSH
10478: LD_INT 139
10480: PPUSH
10481: LD_INT 89
10483: PPUSH
10484: CALL_OW 111
10488: GO 10449
10490: POP
10491: POP
// wait ( 0 0$1 ) ;
10492: LD_INT 35
10494: PPUSH
10495: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10499: LD_VAR 0 2
10503: PPUSH
10504: LD_INT 92
10506: PUSH
10507: LD_INT 139
10509: PUSH
10510: LD_INT 89
10512: PUSH
10513: LD_INT 9
10515: PUSH
10516: EMPTY
10517: LIST
10518: LIST
10519: LIST
10520: LIST
10521: PPUSH
10522: CALL_OW 72
10526: PUSH
10527: LD_VAR 0 2
10531: PUSH
10532: LD_INT 1
10534: MINUS
10535: GREATEREQUAL
10536: IFFALSE 10414
// end else
10538: GO 10682
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10540: LD_VAR 0 2
10544: PPUSH
10545: LD_VAR 0 4
10549: PUSH
10550: LD_INT 1
10552: ARRAY
10553: PPUSH
10554: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10558: LD_ADDR_VAR 0 2
10562: PUSH
10563: LD_VAR 0 2
10567: PPUSH
10568: LD_INT 24
10570: PUSH
10571: LD_INT 250
10573: PUSH
10574: EMPTY
10575: LIST
10576: LIST
10577: PPUSH
10578: CALL_OW 72
10582: ST_TO_ADDR
// for i in tmp do
10583: LD_ADDR_VAR 0 1
10587: PUSH
10588: LD_VAR 0 2
10592: PUSH
10593: FOR_IN
10594: IFFALSE 10634
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10596: LD_VAR 0 1
10600: PPUSH
10601: LD_INT 124
10603: PPUSH
10604: LD_INT 139
10606: PPUSH
10607: CALL_OW 297
10611: PUSH
10612: LD_INT 9
10614: GREATER
10615: IFFALSE 10632
// ComMoveXY ( i , 124 , 139 ) ;
10617: LD_VAR 0 1
10621: PPUSH
10622: LD_INT 124
10624: PPUSH
10625: LD_INT 139
10627: PPUSH
10628: CALL_OW 111
10632: GO 10593
10634: POP
10635: POP
// wait ( 0 0$1 ) ;
10636: LD_INT 35
10638: PPUSH
10639: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10643: LD_VAR 0 2
10647: PPUSH
10648: LD_INT 92
10650: PUSH
10651: LD_INT 124
10653: PUSH
10654: LD_INT 139
10656: PUSH
10657: LD_INT 9
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: PPUSH
10666: CALL_OW 72
10670: PUSH
10671: LD_VAR 0 2
10675: PUSH
10676: LD_INT 1
10678: MINUS
10679: GREATEREQUAL
10680: IFFALSE 10558
// end ; repeat wait ( 0 0$1 ) ;
10682: LD_INT 35
10684: PPUSH
10685: CALL_OW 67
// for i in tmp do
10689: LD_ADDR_VAR 0 1
10693: PUSH
10694: LD_VAR 0 2
10698: PUSH
10699: FOR_IN
10700: IFFALSE 10869
// begin if GetLives ( i ) > 251 then
10702: LD_VAR 0 1
10706: PPUSH
10707: CALL_OW 256
10711: PUSH
10712: LD_INT 251
10714: GREATER
10715: IFFALSE 10840
// begin if GetWeapon ( i ) = ru_time_lapser then
10717: LD_VAR 0 1
10721: PPUSH
10722: CALL_OW 264
10726: PUSH
10727: LD_INT 49
10729: EQUAL
10730: IFFALSE 10786
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10732: LD_VAR 0 1
10736: PPUSH
10737: LD_INT 2
10739: PUSH
10740: LD_INT 22
10742: PUSH
10743: LD_INT 1
10745: PUSH
10746: EMPTY
10747: LIST
10748: LIST
10749: PUSH
10750: LD_INT 22
10752: PUSH
10753: LD_INT 8
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PUSH
10760: EMPTY
10761: LIST
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 69
10769: PPUSH
10770: LD_VAR 0 1
10774: PPUSH
10775: CALL_OW 74
10779: PPUSH
10780: CALL_OW 112
10784: GO 10838
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10786: LD_VAR 0 1
10790: PPUSH
10791: LD_INT 2
10793: PUSH
10794: LD_INT 22
10796: PUSH
10797: LD_INT 1
10799: PUSH
10800: EMPTY
10801: LIST
10802: LIST
10803: PUSH
10804: LD_INT 22
10806: PUSH
10807: LD_INT 8
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: EMPTY
10815: LIST
10816: LIST
10817: LIST
10818: PPUSH
10819: CALL_OW 69
10823: PPUSH
10824: LD_VAR 0 1
10828: PPUSH
10829: CALL_OW 74
10833: PPUSH
10834: CALL_OW 115
// end else
10838: GO 10867
// if IsDead ( i ) then
10840: LD_VAR 0 1
10844: PPUSH
10845: CALL_OW 301
10849: IFFALSE 10867
// tmp := tmp diff i ;
10851: LD_ADDR_VAR 0 2
10855: PUSH
10856: LD_VAR 0 2
10860: PUSH
10861: LD_VAR 0 1
10865: DIFF
10866: ST_TO_ADDR
// end ;
10867: GO 10699
10869: POP
10870: POP
// until not tmp ;
10871: LD_VAR 0 2
10875: NOT
10876: IFFALSE 10682
// end ; end_of_file
10878: PPOPN 4
10880: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10881: LD_INT 0
10883: PPUSH
10884: PPUSH
10885: PPUSH
10886: PPUSH
10887: PPUSH
10888: PPUSH
// side := 7 ;
10889: LD_ADDR_VAR 0 5
10893: PUSH
10894: LD_INT 7
10896: ST_TO_ADDR
// uc_side := side ;
10897: LD_ADDR_OWVAR 20
10901: PUSH
10902: LD_VAR 0 5
10906: ST_TO_ADDR
// uc_nation := 1 ;
10907: LD_ADDR_OWVAR 21
10911: PUSH
10912: LD_INT 1
10914: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10915: LD_ADDR_VAR 0 2
10919: PUSH
10920: LD_INT 22
10922: PUSH
10923: LD_VAR 0 5
10927: PUSH
10928: EMPTY
10929: LIST
10930: LIST
10931: PUSH
10932: LD_INT 21
10934: PUSH
10935: LD_INT 3
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PUSH
10942: EMPTY
10943: LIST
10944: LIST
10945: PPUSH
10946: CALL_OW 69
10950: PUSH
10951: FOR_IN
10952: IFFALSE 10968
// SetBLevel ( i , 10 ) ;
10954: LD_VAR 0 2
10958: PPUSH
10959: LD_INT 10
10961: PPUSH
10962: CALL_OW 241
10966: GO 10951
10968: POP
10969: POP
// base := GetBase ( al_depot ) ;
10970: LD_ADDR_VAR 0 4
10974: PUSH
10975: LD_INT 2
10977: PPUSH
10978: CALL_OW 274
10982: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10983: LD_ADDR_VAR 0 6
10987: PUSH
10988: LD_INT 22
10990: PUSH
10991: LD_VAR 0 5
10995: PUSH
10996: EMPTY
10997: LIST
10998: LIST
10999: PUSH
11000: LD_INT 30
11002: PUSH
11003: LD_INT 34
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PUSH
11010: EMPTY
11011: LIST
11012: LIST
11013: PPUSH
11014: CALL_OW 69
11018: ST_TO_ADDR
// if teleport then
11019: LD_VAR 0 6
11023: IFFALSE 11044
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11025: LD_VAR 0 6
11029: PUSH
11030: LD_INT 1
11032: ARRAY
11033: PPUSH
11034: LD_INT 262
11036: PPUSH
11037: LD_INT 119
11039: PPUSH
11040: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11044: LD_VAR 0 4
11048: PPUSH
11049: LD_INT 1
11051: PPUSH
11052: LD_INT 19500
11054: PPUSH
11055: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11059: LD_VAR 0 4
11063: PPUSH
11064: LD_INT 2
11066: PPUSH
11067: LD_INT 200
11069: PPUSH
11070: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11074: LD_VAR 0 4
11078: PPUSH
11079: LD_INT 3
11081: PPUSH
11082: LD_INT 650
11084: PPUSH
11085: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11089: LD_ADDR_EXP 71
11093: PUSH
11094: LD_STRING Roth
11096: PPUSH
11097: CALL_OW 25
11101: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11102: LD_ADDR_EXP 72
11106: PUSH
11107: LD_STRING Simms
11109: PPUSH
11110: LD_EXP 1
11114: NOT
11115: PPUSH
11116: LD_STRING 10c_
11118: PPUSH
11119: CALL 63701 0 3
11123: ST_TO_ADDR
// if not Simms then
11124: LD_EXP 72
11128: NOT
11129: IFFALSE 11159
// begin uc_nation := 1 ;
11131: LD_ADDR_OWVAR 21
11135: PUSH
11136: LD_INT 1
11138: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11139: LD_INT 2
11141: PPUSH
11142: LD_INT 10
11144: PPUSH
11145: CALL_OW 384
// Simms := CreateHuman ;
11149: LD_ADDR_EXP 72
11153: PUSH
11154: CALL_OW 44
11158: ST_TO_ADDR
// end ; uc_nation := 3 ;
11159: LD_ADDR_OWVAR 21
11163: PUSH
11164: LD_INT 3
11166: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11167: LD_ADDR_EXP 73
11171: PUSH
11172: LD_STRING Kirilenkova
11174: PPUSH
11175: CALL_OW 25
11179: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11180: LD_ADDR_EXP 87
11184: PUSH
11185: LD_STRING Oblukov
11187: PPUSH
11188: CALL_OW 25
11192: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11193: LD_ADDR_EXP 74
11197: PUSH
11198: LD_STRING Dolgov
11200: PPUSH
11201: CALL_OW 25
11205: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11206: LD_ADDR_EXP 75
11210: PUSH
11211: LD_STRING Petrosyan
11213: PPUSH
11214: CALL_OW 25
11218: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11219: LD_ADDR_EXP 86
11223: PUSH
11224: LD_STRING Scholtze
11226: PPUSH
11227: CALL_OW 25
11231: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11232: LD_ADDR_EXP 85
11236: PUSH
11237: LD_STRING Kapitsova
11239: PPUSH
11240: CALL_OW 25
11244: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11245: LD_ADDR_EXP 76
11249: PUSH
11250: LD_STRING Petrovova
11252: PPUSH
11253: CALL_OW 25
11257: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11258: LD_ADDR_EXP 77
11262: PUSH
11263: LD_STRING Kuzmov
11265: PPUSH
11266: CALL_OW 25
11270: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11271: LD_ADDR_EXP 84
11275: PUSH
11276: LD_STRING Karamazov
11278: PPUSH
11279: CALL_OW 25
11283: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11284: LD_STRING 13_Lipshchin_1
11286: PPUSH
11287: LD_INT 0
11289: PPUSH
11290: CALL_OW 30
11294: IFFALSE 11309
// Lipshchin := NewCharacter ( Lipshchin ) ;
11296: LD_ADDR_EXP 78
11300: PUSH
11301: LD_STRING Lipshchin
11303: PPUSH
11304: CALL_OW 25
11308: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11309: LD_STRING 13_Titov_1
11311: PPUSH
11312: LD_INT 0
11314: PPUSH
11315: CALL_OW 30
11319: IFFALSE 11334
// Titov := NewCharacter ( Titov ) ;
11321: LD_ADDR_EXP 80
11325: PUSH
11326: LD_STRING Titov
11328: PPUSH
11329: CALL_OW 25
11333: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11334: LD_STRING 13_Gnyevko_1
11336: PPUSH
11337: LD_INT 0
11339: PPUSH
11340: CALL_OW 30
11344: IFFALSE 11359
// Gnyevko := NewCharacter ( Gnyevko ) ;
11346: LD_ADDR_EXP 79
11350: PUSH
11351: LD_STRING Gnyevko
11353: PPUSH
11354: CALL_OW 25
11358: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11359: LD_STRING 13_Xavier_1
11361: PPUSH
11362: LD_INT 0
11364: PPUSH
11365: CALL_OW 30
11369: IFFALSE 11384
// Xavier := NewCharacter ( Xavier2 ) ;
11371: LD_ADDR_EXP 81
11375: PUSH
11376: LD_STRING Xavier2
11378: PPUSH
11379: CALL_OW 25
11383: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11384: LD_STRING 13_Belkov_1
11386: PPUSH
11387: LD_INT 0
11389: PPUSH
11390: CALL_OW 30
11394: IFFALSE 11409
// Belkov := NewCharacter ( Belkov ) ;
11396: LD_ADDR_EXP 82
11400: PUSH
11401: LD_STRING Belkov
11403: PPUSH
11404: CALL_OW 25
11408: ST_TO_ADDR
// if not BurlakStatus then
11409: LD_EXP 9
11413: NOT
11414: IFFALSE 11429
// Burlak = NewCharacter ( Burlak ) ;
11416: LD_ADDR_EXP 83
11420: PUSH
11421: LD_STRING Burlak
11423: PPUSH
11424: CALL_OW 25
11428: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11429: LD_ADDR_VAR 0 3
11433: PUSH
11434: LD_EXP 71
11438: PUSH
11439: LD_EXP 73
11443: PUSH
11444: LD_EXP 87
11448: PUSH
11449: LD_EXP 74
11453: PUSH
11454: LD_EXP 75
11458: PUSH
11459: LD_EXP 86
11463: PUSH
11464: LD_EXP 85
11468: PUSH
11469: LD_EXP 76
11473: PUSH
11474: LD_EXP 77
11478: PUSH
11479: LD_EXP 84
11483: PUSH
11484: EMPTY
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: LIST
11490: LIST
11491: LIST
11492: LIST
11493: LIST
11494: LIST
11495: ST_TO_ADDR
// if Simms then
11496: LD_EXP 72
11500: IFFALSE 11518
// tmp := tmp ^ Simms ;
11502: LD_ADDR_VAR 0 3
11506: PUSH
11507: LD_VAR 0 3
11511: PUSH
11512: LD_EXP 72
11516: ADD
11517: ST_TO_ADDR
// if Titov then
11518: LD_EXP 80
11522: IFFALSE 11540
// tmp := tmp ^ Titov ;
11524: LD_ADDR_VAR 0 3
11528: PUSH
11529: LD_VAR 0 3
11533: PUSH
11534: LD_EXP 80
11538: ADD
11539: ST_TO_ADDR
// if Lipshchin then
11540: LD_EXP 78
11544: IFFALSE 11562
// tmp := tmp ^ Lipshchin ;
11546: LD_ADDR_VAR 0 3
11550: PUSH
11551: LD_VAR 0 3
11555: PUSH
11556: LD_EXP 78
11560: ADD
11561: ST_TO_ADDR
// if Gnyevko then
11562: LD_EXP 79
11566: IFFALSE 11584
// tmp := tmp ^ Gnyevko ;
11568: LD_ADDR_VAR 0 3
11572: PUSH
11573: LD_VAR 0 3
11577: PUSH
11578: LD_EXP 79
11582: ADD
11583: ST_TO_ADDR
// if Xavier then
11584: LD_EXP 81
11588: IFFALSE 11606
// tmp := tmp ^ Xavier ;
11590: LD_ADDR_VAR 0 3
11594: PUSH
11595: LD_VAR 0 3
11599: PUSH
11600: LD_EXP 81
11604: ADD
11605: ST_TO_ADDR
// if Belkov then
11606: LD_EXP 82
11610: IFFALSE 11628
// tmp := tmp ^ Belkov ;
11612: LD_ADDR_VAR 0 3
11616: PUSH
11617: LD_VAR 0 3
11621: PUSH
11622: LD_EXP 82
11626: ADD
11627: ST_TO_ADDR
// if Burlak then
11628: LD_EXP 83
11632: IFFALSE 11650
// tmp := tmp ^ Burlak ;
11634: LD_ADDR_VAR 0 3
11638: PUSH
11639: LD_VAR 0 3
11643: PUSH
11644: LD_EXP 83
11648: ADD
11649: ST_TO_ADDR
// for i = 1 to 8 do
11650: LD_ADDR_VAR 0 2
11654: PUSH
11655: DOUBLE
11656: LD_INT 1
11658: DEC
11659: ST_TO_ADDR
11660: LD_INT 8
11662: PUSH
11663: FOR_TO
11664: IFFALSE 11730
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11666: LD_ADDR_OWVAR 21
11670: PUSH
11671: LD_INT 1
11673: PUSH
11674: LD_INT 3
11676: PUSH
11677: EMPTY
11678: LIST
11679: LIST
11680: PUSH
11681: LD_INT 1
11683: PPUSH
11684: LD_INT 2
11686: PPUSH
11687: CALL_OW 12
11691: ARRAY
11692: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11693: LD_INT 0
11695: PPUSH
11696: LD_VAR 0 2
11700: PUSH
11701: LD_INT 2
11703: DIV
11704: PPUSH
11705: LD_INT 10
11707: PPUSH
11708: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11712: LD_ADDR_VAR 0 3
11716: PUSH
11717: LD_VAR 0 3
11721: PUSH
11722: CALL_OW 44
11726: ADD
11727: ST_TO_ADDR
// end ;
11728: GO 11663
11730: POP
11731: POP
// for i in tmp do
11732: LD_ADDR_VAR 0 2
11736: PUSH
11737: LD_VAR 0 3
11741: PUSH
11742: FOR_IN
11743: IFFALSE 11768
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11745: LD_VAR 0 2
11749: PPUSH
11750: LD_INT 260
11752: PPUSH
11753: LD_INT 235
11755: PPUSH
11756: LD_INT 8
11758: PPUSH
11759: LD_INT 0
11761: PPUSH
11762: CALL_OW 50
11766: GO 11742
11768: POP
11769: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11770: LD_ADDR_EXP 99
11774: PUSH
11775: LD_EXP 99
11779: PPUSH
11780: LD_INT 1
11782: PPUSH
11783: LD_INT 22
11785: PUSH
11786: LD_VAR 0 5
11790: PUSH
11791: EMPTY
11792: LIST
11793: LIST
11794: PUSH
11795: LD_INT 3
11797: PUSH
11798: LD_INT 21
11800: PUSH
11801: LD_INT 2
11803: PUSH
11804: EMPTY
11805: LIST
11806: LIST
11807: PUSH
11808: EMPTY
11809: LIST
11810: LIST
11811: PUSH
11812: EMPTY
11813: LIST
11814: LIST
11815: PPUSH
11816: CALL_OW 69
11820: PUSH
11821: LD_EXP 71
11825: PUSH
11826: LD_EXP 72
11830: PUSH
11831: EMPTY
11832: LIST
11833: LIST
11834: DIFF
11835: PPUSH
11836: CALL_OW 1
11840: ST_TO_ADDR
// uc_side := 0 ;
11841: LD_ADDR_OWVAR 20
11845: PUSH
11846: LD_INT 0
11848: ST_TO_ADDR
// uc_nation := 0 ;
11849: LD_ADDR_OWVAR 21
11853: PUSH
11854: LD_INT 0
11856: ST_TO_ADDR
// for i = 1 to 5 do
11857: LD_ADDR_VAR 0 2
11861: PUSH
11862: DOUBLE
11863: LD_INT 1
11865: DEC
11866: ST_TO_ADDR
11867: LD_INT 5
11869: PUSH
11870: FOR_TO
11871: IFFALSE 11908
// begin InitHc ;
11873: CALL_OW 19
// hc_class := class_apeman ;
11877: LD_ADDR_OWVAR 28
11881: PUSH
11882: LD_INT 12
11884: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11885: CALL_OW 44
11889: PPUSH
11890: LD_INT 299
11892: PPUSH
11893: LD_INT 229
11895: PPUSH
11896: LD_INT 10
11898: PPUSH
11899: LD_INT 0
11901: PPUSH
11902: CALL_OW 50
// end ;
11906: GO 11870
11908: POP
11909: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11910: LD_EXP 71
11914: PPUSH
11915: LD_INT 259
11917: PPUSH
11918: LD_INT 235
11920: PPUSH
11921: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11925: LD_EXP 71
11929: PPUSH
11930: LD_INT 262
11932: PPUSH
11933: LD_INT 235
11935: PPUSH
11936: CALL_OW 178
// if Simms then
11940: LD_EXP 72
11944: IFFALSE 11975
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11946: LD_EXP 72
11950: PPUSH
11951: LD_INT 262
11953: PPUSH
11954: LD_INT 235
11956: PPUSH
11957: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11961: LD_EXP 72
11965: PPUSH
11966: LD_EXP 71
11970: PPUSH
11971: CALL_OW 179
// end ; end ;
11975: LD_VAR 0 1
11979: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11980: LD_EXP 31
11984: PUSH
11985: LD_EXP 23
11989: NOT
11990: AND
11991: IFFALSE 12167
11993: GO 11995
11995: DISABLE
11996: LD_INT 0
11998: PPUSH
11999: PPUSH
12000: PPUSH
// begin enable ;
12001: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12002: LD_ADDR_VAR 0 2
12006: PUSH
12007: LD_INT 81
12009: PUSH
12010: LD_INT 7
12012: PUSH
12013: EMPTY
12014: LIST
12015: LIST
12016: PUSH
12017: LD_INT 2
12019: PUSH
12020: LD_INT 32
12022: PUSH
12023: LD_INT 3
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: PUSH
12030: LD_INT 30
12032: PUSH
12033: LD_INT 30
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PUSH
12040: LD_INT 30
12042: PUSH
12043: LD_INT 28
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: LD_INT 34
12052: PUSH
12053: LD_INT 49
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PUSH
12060: LD_INT 34
12062: PUSH
12063: LD_INT 10
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 34
12072: PUSH
12073: LD_INT 8
12075: PUSH
12076: EMPTY
12077: LIST
12078: LIST
12079: PUSH
12080: EMPTY
12081: LIST
12082: LIST
12083: LIST
12084: LIST
12085: LIST
12086: LIST
12087: LIST
12088: PUSH
12089: EMPTY
12090: LIST
12091: LIST
12092: PPUSH
12093: CALL_OW 69
12097: ST_TO_ADDR
// if not tmp then
12098: LD_VAR 0 2
12102: NOT
12103: IFFALSE 12107
// exit ;
12105: GO 12167
// target := tmp [ rand ( 1 , tmp ) ] ;
12107: LD_ADDR_VAR 0 3
12111: PUSH
12112: LD_VAR 0 2
12116: PUSH
12117: LD_INT 1
12119: PPUSH
12120: LD_VAR 0 2
12124: PPUSH
12125: CALL_OW 12
12129: ARRAY
12130: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12131: LD_VAR 0 3
12135: PPUSH
12136: CALL_OW 255
12140: PUSH
12141: LD_INT 1
12143: EQUAL
12144: IFFALSE 12155
// CenterNowOnUnits ( target ) ;
12146: LD_VAR 0 3
12150: PPUSH
12151: CALL_OW 87
// SetLives ( target , 0 ) ;
12155: LD_VAR 0 3
12159: PPUSH
12160: LD_INT 0
12162: PPUSH
12163: CALL_OW 234
// end ;
12167: PPOPN 3
12169: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12170: LD_EXP 23
12174: NOT
12175: PUSH
12176: LD_EXP 31
12180: AND
12181: IFFALSE 12703
12183: GO 12185
12185: DISABLE
12186: LD_INT 0
12188: PPUSH
12189: PPUSH
12190: PPUSH
// begin uc_side := 7 ;
12191: LD_ADDR_OWVAR 20
12195: PUSH
12196: LD_INT 7
12198: ST_TO_ADDR
// uc_nation := 1 ;
12199: LD_ADDR_OWVAR 21
12203: PUSH
12204: LD_INT 1
12206: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12207: LD_ADDR_VAR 0 3
12211: PUSH
12212: LD_INT 125
12214: PUSH
12215: LD_INT 163
12217: PUSH
12218: EMPTY
12219: LIST
12220: LIST
12221: PUSH
12222: LD_INT 185
12224: PUSH
12225: LD_INT 168
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 111
12234: PUSH
12235: LD_INT 97
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: PPUSH
12247: CALL 106504 0 1
12251: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12252: LD_ADDR_EXP 88
12256: PUSH
12257: EMPTY
12258: ST_TO_ADDR
// for i = 1 to Difficulty do
12259: LD_ADDR_VAR 0 1
12263: PUSH
12264: DOUBLE
12265: LD_INT 1
12267: DEC
12268: ST_TO_ADDR
12269: LD_OWVAR 67
12273: PUSH
12274: FOR_TO
12275: IFFALSE 12433
// begin InitHc ;
12277: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12281: LD_INT 0
12283: PPUSH
12284: LD_INT 8
12286: PPUSH
12287: CALL_OW 381
// un := CreateHuman ;
12291: LD_ADDR_VAR 0 2
12295: PUSH
12296: CALL_OW 44
12300: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12301: LD_VAR 0 2
12305: PPUSH
12306: LD_INT 258
12308: PPUSH
12309: LD_INT 267
12311: PPUSH
12312: LD_INT 4
12314: PPUSH
12315: LD_INT 0
12317: PPUSH
12318: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12322: LD_ADDR_EXP 88
12326: PUSH
12327: LD_EXP 88
12331: PUSH
12332: LD_VAR 0 2
12336: UNION
12337: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12338: LD_VAR 0 2
12342: PPUSH
12343: LD_VAR 0 3
12347: PUSH
12348: LD_VAR 0 1
12352: ARRAY
12353: PUSH
12354: LD_INT 1
12356: ARRAY
12357: PPUSH
12358: LD_VAR 0 3
12362: PUSH
12363: LD_VAR 0 1
12367: ARRAY
12368: PUSH
12369: LD_INT 2
12371: ARRAY
12372: PPUSH
12373: LD_INT 4
12375: PPUSH
12376: LD_INT 1
12378: PPUSH
12379: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12383: LD_VAR 0 2
12387: PPUSH
12388: LD_VAR 0 3
12392: PUSH
12393: LD_VAR 0 1
12397: ARRAY
12398: PUSH
12399: LD_INT 1
12401: ARRAY
12402: PPUSH
12403: LD_VAR 0 3
12407: PUSH
12408: LD_VAR 0 1
12412: ARRAY
12413: PUSH
12414: LD_INT 2
12416: ARRAY
12417: PPUSH
12418: CALL_OW 171
// AddComInvisible ( un ) ;
12422: LD_VAR 0 2
12426: PPUSH
12427: CALL_OW 212
// end ;
12431: GO 12274
12433: POP
12434: POP
// repeat wait ( 0 0$20 ) ;
12435: LD_INT 700
12437: PPUSH
12438: CALL_OW 67
// for i in allianceSpecialForce do
12442: LD_ADDR_VAR 0 1
12446: PUSH
12447: LD_EXP 88
12451: PUSH
12452: FOR_IN
12453: IFFALSE 12688
// begin if IsInvisible ( i ) then
12455: LD_VAR 0 1
12459: PPUSH
12460: CALL_OW 571
12464: IFFALSE 12657
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12466: LD_ADDR_VAR 0 3
12470: PUSH
12471: LD_INT 22
12473: PUSH
12474: LD_INT 1
12476: PUSH
12477: EMPTY
12478: LIST
12479: LIST
12480: PUSH
12481: LD_INT 50
12483: PUSH
12484: EMPTY
12485: LIST
12486: PUSH
12487: LD_INT 56
12489: PUSH
12490: EMPTY
12491: LIST
12492: PUSH
12493: LD_INT 91
12495: PUSH
12496: LD_VAR 0 1
12500: PUSH
12501: LD_INT 25
12503: PUSH
12504: LD_INT 30
12506: PUSH
12507: LD_INT 35
12509: PUSH
12510: EMPTY
12511: LIST
12512: LIST
12513: LIST
12514: PUSH
12515: LD_OWVAR 67
12519: ARRAY
12520: PUSH
12521: EMPTY
12522: LIST
12523: LIST
12524: LIST
12525: PUSH
12526: LD_INT 2
12528: PUSH
12529: LD_INT 25
12531: PUSH
12532: LD_INT 1
12534: PUSH
12535: EMPTY
12536: LIST
12537: LIST
12538: PUSH
12539: LD_INT 25
12541: PUSH
12542: LD_INT 2
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 3
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 25
12561: PUSH
12562: LD_INT 4
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 25
12571: PUSH
12572: LD_INT 5
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 25
12581: PUSH
12582: LD_INT 8
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PUSH
12589: EMPTY
12590: LIST
12591: LIST
12592: LIST
12593: LIST
12594: LIST
12595: LIST
12596: LIST
12597: PUSH
12598: EMPTY
12599: LIST
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: PPUSH
12605: CALL_OW 69
12609: ST_TO_ADDR
// if not tmp then
12610: LD_VAR 0 3
12614: NOT
12615: IFFALSE 12619
// continue ;
12617: GO 12452
// if Prob ( 30 * Difficulty ) then
12619: LD_INT 30
12621: PUSH
12622: LD_OWVAR 67
12626: MUL
12627: PPUSH
12628: CALL_OW 13
12632: IFFALSE 12657
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12634: LD_VAR 0 3
12638: PUSH
12639: LD_INT 1
12641: PPUSH
12642: LD_VAR 0 3
12646: PPUSH
12647: CALL_OW 12
12651: ARRAY
12652: PPUSH
12653: CALL 30114 0 1
// end ; if IsDead ( i ) then
12657: LD_VAR 0 1
12661: PPUSH
12662: CALL_OW 301
12666: IFFALSE 12686
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12668: LD_ADDR_EXP 88
12672: PUSH
12673: LD_EXP 88
12677: PUSH
12678: LD_VAR 0 1
12682: DIFF
12683: ST_TO_ADDR
// continue ;
12684: GO 12452
// end ; end ;
12686: GO 12452
12688: POP
12689: POP
// until allianceDestroyed or not allianceSpecialForce ;
12690: LD_EXP 23
12694: PUSH
12695: LD_EXP 88
12699: NOT
12700: OR
12701: IFFALSE 12435
// end ;
12703: PPOPN 3
12705: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12706: LD_EXP 23
12710: NOT
12711: PUSH
12712: LD_EXP 31
12716: AND
12717: PUSH
12718: LD_INT 1
12720: PPUSH
12721: LD_INT 1
12723: PPUSH
12724: CALL 58909 0 2
12728: NOT
12729: AND
12730: IFFALSE 13697
12732: GO 12734
12734: DISABLE
12735: LD_INT 0
12737: PPUSH
12738: PPUSH
12739: PPUSH
12740: PPUSH
// begin enable ;
12741: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12742: LD_INT 22
12744: PUSH
12745: LD_INT 7
12747: PUSH
12748: EMPTY
12749: LIST
12750: LIST
12751: PUSH
12752: LD_INT 30
12754: PUSH
12755: LD_INT 3
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: PPUSH
12766: CALL_OW 69
12770: NOT
12771: IFFALSE 12775
// exit ;
12773: GO 13697
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12775: LD_ADDR_VAR 0 4
12779: PUSH
12780: LD_INT 22
12782: PUSH
12783: LD_INT 7
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 30
12792: PUSH
12793: LD_INT 34
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PPUSH
12804: CALL_OW 69
12808: ST_TO_ADDR
// if Prob ( 40 ) then
12809: LD_INT 40
12811: PPUSH
12812: CALL_OW 13
12816: IFFALSE 12943
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12818: LD_INT 1
12820: PPUSH
12821: LD_INT 5
12823: PUSH
12824: LD_INT 3
12826: PUSH
12827: LD_INT 2
12829: PUSH
12830: LD_INT 6
12832: PUSH
12833: EMPTY
12834: LIST
12835: LIST
12836: LIST
12837: LIST
12838: PUSH
12839: LD_INT 5
12841: PUSH
12842: LD_INT 3
12844: PUSH
12845: LD_INT 2
12847: PUSH
12848: LD_INT 6
12850: PUSH
12851: EMPTY
12852: LIST
12853: LIST
12854: LIST
12855: LIST
12856: PUSH
12857: LD_INT 5
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: LD_INT 2
12865: PUSH
12866: LD_INT 6
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: PUSH
12875: LD_INT 24
12877: PUSH
12878: LD_INT 3
12880: PUSH
12881: LD_INT 3
12883: PUSH
12884: LD_INT 45
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: PUSH
12893: LD_INT 24
12895: PUSH
12896: LD_INT 3
12898: PUSH
12899: LD_INT 3
12901: PUSH
12902: LD_INT 47
12904: PUSH
12905: EMPTY
12906: LIST
12907: LIST
12908: LIST
12909: LIST
12910: PUSH
12911: LD_INT 24
12913: PUSH
12914: LD_INT 3
12916: PUSH
12917: LD_INT 3
12919: PUSH
12920: LD_INT 45
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PUSH
12929: EMPTY
12930: LIST
12931: LIST
12932: LIST
12933: LIST
12934: LIST
12935: LIST
12936: PPUSH
12937: CALL 57491 0 2
// end else
12941: GO 13066
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12943: LD_INT 1
12945: PPUSH
12946: LD_INT 24
12948: PUSH
12949: LD_INT 3
12951: PUSH
12952: LD_INT 3
12954: PUSH
12955: LD_INT 47
12957: PUSH
12958: EMPTY
12959: LIST
12960: LIST
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 24
12966: PUSH
12967: LD_INT 3
12969: PUSH
12970: LD_INT 3
12972: PUSH
12973: LD_INT 47
12975: PUSH
12976: EMPTY
12977: LIST
12978: LIST
12979: LIST
12980: LIST
12981: PUSH
12982: LD_INT 5
12984: PUSH
12985: LD_INT 3
12987: PUSH
12988: LD_INT 2
12990: PUSH
12991: LD_INT 9
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: PUSH
13000: LD_INT 5
13002: PUSH
13003: LD_INT 3
13005: PUSH
13006: LD_INT 2
13008: PUSH
13009: LD_INT 9
13011: PUSH
13012: EMPTY
13013: LIST
13014: LIST
13015: LIST
13016: LIST
13017: PUSH
13018: LD_INT 24
13020: PUSH
13021: LD_INT 1
13023: PUSH
13024: LD_INT 3
13026: PUSH
13027: LD_INT 45
13029: PUSH
13030: EMPTY
13031: LIST
13032: LIST
13033: LIST
13034: LIST
13035: PUSH
13036: LD_INT 24
13038: PUSH
13039: LD_INT 1
13041: PUSH
13042: LD_INT 3
13044: PUSH
13045: LD_INT 45
13047: PUSH
13048: EMPTY
13049: LIST
13050: LIST
13051: LIST
13052: LIST
13053: PUSH
13054: EMPTY
13055: LIST
13056: LIST
13057: LIST
13058: LIST
13059: LIST
13060: LIST
13061: PPUSH
13062: CALL 57491 0 2
// end ; if Difficulty > 1 then
13066: LD_OWVAR 67
13070: PUSH
13071: LD_INT 1
13073: GREATER
13074: IFFALSE 13104
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13076: LD_INT 1
13078: PPUSH
13079: LD_INT 24
13081: PUSH
13082: LD_INT 3
13084: PUSH
13085: LD_INT 3
13087: PUSH
13088: LD_INT 47
13090: PUSH
13091: EMPTY
13092: LIST
13093: LIST
13094: LIST
13095: LIST
13096: PUSH
13097: EMPTY
13098: LIST
13099: PPUSH
13100: CALL 57491 0 2
// repeat wait ( 0 0$1 ) ;
13104: LD_INT 35
13106: PPUSH
13107: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13111: LD_INT 1
13113: PPUSH
13114: LD_INT 1
13116: PPUSH
13117: CALL 58909 0 2
13121: PUSH
13122: LD_INT 6
13124: PUSH
13125: LD_INT 7
13127: PUSH
13128: LD_INT 7
13130: PUSH
13131: EMPTY
13132: LIST
13133: LIST
13134: LIST
13135: PUSH
13136: LD_OWVAR 67
13140: ARRAY
13141: GREATEREQUAL
13142: IFFALSE 13104
// wait ( 0 0$40 ) ;
13144: LD_INT 1400
13146: PPUSH
13147: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13151: LD_ADDR_VAR 0 2
13155: PUSH
13156: LD_INT 1
13158: PPUSH
13159: LD_INT 1
13161: PPUSH
13162: CALL 58909 0 2
13166: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13167: LD_ADDR_EXP 118
13171: PUSH
13172: LD_EXP 118
13176: PPUSH
13177: LD_INT 1
13179: PPUSH
13180: LD_EXP 118
13184: PUSH
13185: LD_INT 1
13187: ARRAY
13188: PUSH
13189: LD_VAR 0 2
13193: DIFF
13194: PPUSH
13195: CALL_OW 1
13199: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13200: LD_ADDR_VAR 0 3
13204: PUSH
13205: LD_INT 0
13207: PPUSH
13208: LD_INT 1
13210: PPUSH
13211: CALL_OW 12
13215: ST_TO_ADDR
// if target then
13216: LD_VAR 0 3
13220: IFFALSE 13386
// begin for i in tmp do
13222: LD_ADDR_VAR 0 1
13226: PUSH
13227: LD_VAR 0 2
13231: PUSH
13232: FOR_IN
13233: IFFALSE 13258
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13235: LD_VAR 0 1
13239: PPUSH
13240: LD_INT 179
13242: PPUSH
13243: LD_INT 209
13245: PPUSH
13246: LD_INT 8
13248: PPUSH
13249: LD_INT 1
13251: PPUSH
13252: CALL_OW 483
13256: GO 13232
13258: POP
13259: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13260: LD_ADDR_VAR 0 2
13264: PUSH
13265: LD_VAR 0 2
13269: PPUSH
13270: LD_INT 24
13272: PUSH
13273: LD_INT 250
13275: PUSH
13276: EMPTY
13277: LIST
13278: LIST
13279: PPUSH
13280: CALL_OW 72
13284: ST_TO_ADDR
// for i in tmp do
13285: LD_ADDR_VAR 0 1
13289: PUSH
13290: LD_VAR 0 2
13294: PUSH
13295: FOR_IN
13296: IFFALSE 13336
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13298: LD_VAR 0 1
13302: PPUSH
13303: LD_INT 179
13305: PPUSH
13306: LD_INT 209
13308: PPUSH
13309: CALL_OW 297
13313: PUSH
13314: LD_INT 9
13316: GREATER
13317: IFFALSE 13334
// ComMoveXY ( i , 179 , 209 ) ;
13319: LD_VAR 0 1
13323: PPUSH
13324: LD_INT 179
13326: PPUSH
13327: LD_INT 209
13329: PPUSH
13330: CALL_OW 111
13334: GO 13295
13336: POP
13337: POP
// wait ( 0 0$1 ) ;
13338: LD_INT 35
13340: PPUSH
13341: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13345: LD_VAR 0 2
13349: PPUSH
13350: LD_INT 92
13352: PUSH
13353: LD_INT 179
13355: PUSH
13356: LD_INT 209
13358: PUSH
13359: LD_INT 9
13361: PUSH
13362: EMPTY
13363: LIST
13364: LIST
13365: LIST
13366: LIST
13367: PPUSH
13368: CALL_OW 72
13372: PUSH
13373: LD_VAR 0 2
13377: PUSH
13378: LD_INT 1
13380: MINUS
13381: GREATEREQUAL
13382: IFFALSE 13260
// end else
13384: GO 13548
// begin for i in tmp do
13386: LD_ADDR_VAR 0 1
13390: PUSH
13391: LD_VAR 0 2
13395: PUSH
13396: FOR_IN
13397: IFFALSE 13422
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13399: LD_VAR 0 1
13403: PPUSH
13404: LD_INT 285
13406: PPUSH
13407: LD_INT 163
13409: PPUSH
13410: LD_INT 8
13412: PPUSH
13413: LD_INT 1
13415: PPUSH
13416: CALL_OW 483
13420: GO 13396
13422: POP
13423: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13424: LD_ADDR_VAR 0 2
13428: PUSH
13429: LD_VAR 0 2
13433: PPUSH
13434: LD_INT 24
13436: PUSH
13437: LD_INT 250
13439: PUSH
13440: EMPTY
13441: LIST
13442: LIST
13443: PPUSH
13444: CALL_OW 72
13448: ST_TO_ADDR
// for i in tmp do
13449: LD_ADDR_VAR 0 1
13453: PUSH
13454: LD_VAR 0 2
13458: PUSH
13459: FOR_IN
13460: IFFALSE 13500
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13462: LD_VAR 0 1
13466: PPUSH
13467: LD_INT 285
13469: PPUSH
13470: LD_INT 163
13472: PPUSH
13473: CALL_OW 297
13477: PUSH
13478: LD_INT 9
13480: GREATER
13481: IFFALSE 13498
// ComMoveXY ( i , 285 , 163 ) ;
13483: LD_VAR 0 1
13487: PPUSH
13488: LD_INT 285
13490: PPUSH
13491: LD_INT 163
13493: PPUSH
13494: CALL_OW 111
13498: GO 13459
13500: POP
13501: POP
// wait ( 0 0$1 ) ;
13502: LD_INT 35
13504: PPUSH
13505: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13509: LD_VAR 0 2
13513: PPUSH
13514: LD_INT 92
13516: PUSH
13517: LD_INT 285
13519: PUSH
13520: LD_INT 163
13522: PUSH
13523: LD_INT 9
13525: PUSH
13526: EMPTY
13527: LIST
13528: LIST
13529: LIST
13530: LIST
13531: PPUSH
13532: CALL_OW 72
13536: PUSH
13537: LD_VAR 0 2
13541: PUSH
13542: LD_INT 1
13544: MINUS
13545: GREATEREQUAL
13546: IFFALSE 13424
// end ; repeat wait ( 0 0$1 ) ;
13548: LD_INT 35
13550: PPUSH
13551: CALL_OW 67
// for i in tmp do
13555: LD_ADDR_VAR 0 1
13559: PUSH
13560: LD_VAR 0 2
13564: PUSH
13565: FOR_IN
13566: IFFALSE 13688
// if GetLives ( i ) > 251 then
13568: LD_VAR 0 1
13572: PPUSH
13573: CALL_OW 256
13577: PUSH
13578: LD_INT 251
13580: GREATER
13581: IFFALSE 13670
// begin if GetWeapon ( i ) = ru_time_lapser then
13583: LD_VAR 0 1
13587: PPUSH
13588: CALL_OW 264
13592: PUSH
13593: LD_INT 49
13595: EQUAL
13596: IFFALSE 13634
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13598: LD_VAR 0 1
13602: PPUSH
13603: LD_INT 81
13605: PUSH
13606: LD_INT 7
13608: PUSH
13609: EMPTY
13610: LIST
13611: LIST
13612: PPUSH
13613: CALL_OW 69
13617: PPUSH
13618: LD_VAR 0 1
13622: PPUSH
13623: CALL_OW 74
13627: PPUSH
13628: CALL_OW 112
13632: GO 13668
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13634: LD_VAR 0 1
13638: PPUSH
13639: LD_INT 81
13641: PUSH
13642: LD_INT 7
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: PPUSH
13649: CALL_OW 69
13653: PPUSH
13654: LD_VAR 0 1
13658: PPUSH
13659: CALL_OW 74
13663: PPUSH
13664: CALL_OW 115
// end else
13668: GO 13686
// tmp := tmp diff i ;
13670: LD_ADDR_VAR 0 2
13674: PUSH
13675: LD_VAR 0 2
13679: PUSH
13680: LD_VAR 0 1
13684: DIFF
13685: ST_TO_ADDR
13686: GO 13565
13688: POP
13689: POP
// until not tmp ;
13690: LD_VAR 0 2
13694: NOT
13695: IFFALSE 13548
// end ; end_of_file
13697: PPOPN 4
13699: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13700: LD_INT 0
13702: PPUSH
13703: PPUSH
13704: PPUSH
13705: PPUSH
// missionStage := 13 ;
13706: LD_ADDR_EXP 15
13710: PUSH
13711: LD_INT 13
13713: ST_TO_ADDR
// uc_side := 2 ;
13714: LD_ADDR_OWVAR 20
13718: PUSH
13719: LD_INT 2
13721: ST_TO_ADDR
// uc_nation := 2 ;
13722: LD_ADDR_OWVAR 21
13726: PUSH
13727: LD_INT 2
13729: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13730: LD_ADDR_EXP 89
13734: PUSH
13735: LD_STRING Omar
13737: PPUSH
13738: CALL_OW 25
13742: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13743: LD_EXP 89
13747: PPUSH
13748: LD_INT 4
13750: PPUSH
13751: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13755: LD_EXP 89
13759: PPUSH
13760: LD_INT 242
13762: PPUSH
13763: LD_INT 75
13765: PPUSH
13766: LD_INT 0
13768: PPUSH
13769: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13773: LD_ADDR_EXP 90
13777: PUSH
13778: LD_STRING Heike
13780: PPUSH
13781: CALL_OW 25
13785: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13786: LD_INT 14
13788: PPUSH
13789: LD_INT 3
13791: PPUSH
13792: LD_INT 1
13794: PPUSH
13795: LD_INT 27
13797: PPUSH
13798: LD_INT 100
13800: PPUSH
13801: CALL 70667 0 5
// veh := CreateVehicle ;
13805: LD_ADDR_VAR 0 3
13809: PUSH
13810: CALL_OW 45
13814: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13815: LD_VAR 0 3
13819: PPUSH
13820: LD_INT 1
13822: PPUSH
13823: CALL_OW 242
// SetDir ( veh , 4 ) ;
13827: LD_VAR 0 3
13831: PPUSH
13832: LD_INT 4
13834: PPUSH
13835: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13839: LD_VAR 0 3
13843: PPUSH
13844: LD_INT 241
13846: PPUSH
13847: LD_INT 72
13849: PPUSH
13850: LD_INT 0
13852: PPUSH
13853: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13857: LD_EXP 90
13861: PPUSH
13862: LD_VAR 0 3
13866: PPUSH
13867: CALL_OW 52
// if KhatamStatus then
13871: LD_EXP 8
13875: IFFALSE 13926
// begin Khatam := NewCharacter ( Khatam ) ;
13877: LD_ADDR_EXP 91
13881: PUSH
13882: LD_STRING Khatam
13884: PPUSH
13885: CALL_OW 25
13889: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13890: LD_EXP 91
13894: PPUSH
13895: LD_INT 245
13897: PPUSH
13898: LD_INT 78
13900: PPUSH
13901: LD_INT 3
13903: PPUSH
13904: LD_INT 0
13906: PPUSH
13907: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13911: LD_EXP 91
13915: PPUSH
13916: LD_INT 4
13918: PPUSH
13919: LD_INT 10
13921: PPUSH
13922: CALL_OW 237
// end ; for i = 1 to Difficulty do
13926: LD_ADDR_VAR 0 2
13930: PUSH
13931: DOUBLE
13932: LD_INT 1
13934: DEC
13935: ST_TO_ADDR
13936: LD_OWVAR 67
13940: PUSH
13941: FOR_TO
13942: IFFALSE 14008
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13944: LD_INT 0
13946: PPUSH
13947: LD_INT 7
13949: PUSH
13950: LD_OWVAR 67
13954: PLUS
13955: PPUSH
13956: CALL_OW 384
// un := CreateHuman ;
13960: LD_ADDR_VAR 0 4
13964: PUSH
13965: CALL_OW 44
13969: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13970: LD_VAR 0 4
13974: PPUSH
13975: LD_INT 28
13977: PUSH
13978: LD_INT 29
13980: PUSH
13981: EMPTY
13982: LIST
13983: LIST
13984: PUSH
13985: LD_VAR 0 2
13989: PUSH
13990: LD_INT 2
13992: MOD
13993: PUSH
13994: LD_INT 1
13996: PLUS
13997: ARRAY
13998: PPUSH
13999: LD_INT 0
14001: PPUSH
14002: CALL_OW 49
// end ;
14006: GO 13941
14008: POP
14009: POP
// for i = 1 to 6 do
14010: LD_ADDR_VAR 0 2
14014: PUSH
14015: DOUBLE
14016: LD_INT 1
14018: DEC
14019: ST_TO_ADDR
14020: LD_INT 6
14022: PUSH
14023: FOR_TO
14024: IFFALSE 14069
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14026: LD_INT 0
14028: PPUSH
14029: LD_INT 7
14031: PUSH
14032: LD_OWVAR 67
14036: PLUS
14037: PPUSH
14038: CALL_OW 381
// un := CreateHuman ;
14042: LD_ADDR_VAR 0 4
14046: PUSH
14047: CALL_OW 44
14051: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14052: LD_VAR 0 4
14056: PPUSH
14057: LD_INT 28
14059: PPUSH
14060: LD_INT 0
14062: PPUSH
14063: CALL_OW 49
// end ;
14067: GO 14023
14069: POP
14070: POP
// for i = 1 to 3 do
14071: LD_ADDR_VAR 0 2
14075: PUSH
14076: DOUBLE
14077: LD_INT 1
14079: DEC
14080: ST_TO_ADDR
14081: LD_INT 3
14083: PUSH
14084: FOR_TO
14085: IFFALSE 14133
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14087: LD_INT 0
14089: PPUSH
14090: LD_INT 8
14092: PPUSH
14093: LD_INT 7
14095: PUSH
14096: LD_OWVAR 67
14100: PLUS
14101: PPUSH
14102: CALL_OW 380
// un := CreateHuman ;
14106: LD_ADDR_VAR 0 4
14110: PUSH
14111: CALL_OW 44
14115: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14116: LD_VAR 0 4
14120: PPUSH
14121: LD_INT 28
14123: PPUSH
14124: LD_INT 0
14126: PPUSH
14127: CALL_OW 49
// end ;
14131: GO 14084
14133: POP
14134: POP
// for i = 1 to 3 do
14135: LD_ADDR_VAR 0 2
14139: PUSH
14140: DOUBLE
14141: LD_INT 1
14143: DEC
14144: ST_TO_ADDR
14145: LD_INT 3
14147: PUSH
14148: FOR_TO
14149: IFFALSE 14239
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14151: LD_INT 14
14153: PPUSH
14154: LD_INT 2
14156: PPUSH
14157: LD_INT 1
14159: PPUSH
14160: LD_INT 28
14162: PPUSH
14163: LD_INT 80
14165: PPUSH
14166: CALL 70667 0 5
// veh := CreateVehicle ;
14170: LD_ADDR_VAR 0 3
14174: PUSH
14175: CALL_OW 45
14179: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14180: LD_VAR 0 3
14184: PPUSH
14185: LD_INT 3
14187: PPUSH
14188: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14192: LD_VAR 0 3
14196: PPUSH
14197: LD_INT 29
14199: PPUSH
14200: LD_INT 0
14202: PPUSH
14203: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14207: LD_INT 0
14209: PPUSH
14210: LD_INT 7
14212: PUSH
14213: LD_OWVAR 67
14217: PLUS
14218: PPUSH
14219: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14223: CALL_OW 44
14227: PPUSH
14228: LD_VAR 0 3
14232: PPUSH
14233: CALL_OW 52
// end ;
14237: GO 14148
14239: POP
14240: POP
// for i = 1 to 5 + Difficulty do
14241: LD_ADDR_VAR 0 2
14245: PUSH
14246: DOUBLE
14247: LD_INT 1
14249: DEC
14250: ST_TO_ADDR
14251: LD_INT 5
14253: PUSH
14254: LD_OWVAR 67
14258: PLUS
14259: PUSH
14260: FOR_TO
14261: IFFALSE 14388
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14263: LD_INT 14
14265: PPUSH
14266: LD_INT 1
14268: PPUSH
14269: LD_INT 3
14271: PPUSH
14272: CALL_OW 12
14276: PPUSH
14277: LD_INT 1
14279: PPUSH
14280: LD_INT 28
14282: PUSH
14283: LD_INT 26
14285: PUSH
14286: LD_INT 27
14288: PUSH
14289: LD_INT 25
14291: PUSH
14292: EMPTY
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: PUSH
14298: LD_VAR 0 2
14302: PUSH
14303: LD_INT 4
14305: MOD
14306: PUSH
14307: LD_INT 1
14309: PLUS
14310: ARRAY
14311: PPUSH
14312: LD_INT 80
14314: PPUSH
14315: CALL 70667 0 5
// veh := CreateVehicle ;
14319: LD_ADDR_VAR 0 3
14323: PUSH
14324: CALL_OW 45
14328: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14329: LD_VAR 0 3
14333: PPUSH
14334: LD_INT 4
14336: PPUSH
14337: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14341: LD_VAR 0 3
14345: PPUSH
14346: LD_INT 28
14348: PPUSH
14349: LD_INT 0
14351: PPUSH
14352: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14356: LD_INT 0
14358: PPUSH
14359: LD_INT 7
14361: PUSH
14362: LD_OWVAR 67
14366: PLUS
14367: PPUSH
14368: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14372: CALL_OW 44
14376: PPUSH
14377: LD_VAR 0 3
14381: PPUSH
14382: CALL_OW 52
// end ;
14386: GO 14260
14388: POP
14389: POP
// for i = 1 to 3 do
14390: LD_ADDR_VAR 0 2
14394: PUSH
14395: DOUBLE
14396: LD_INT 1
14398: DEC
14399: ST_TO_ADDR
14400: LD_INT 3
14402: PUSH
14403: FOR_TO
14404: IFFALSE 14464
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14406: LD_INT 14
14408: PPUSH
14409: LD_INT 3
14411: PPUSH
14412: LD_INT 5
14414: PPUSH
14415: LD_INT 29
14417: PPUSH
14418: LD_INT 80
14420: PPUSH
14421: CALL 70667 0 5
// veh := CreateVehicle ;
14425: LD_ADDR_VAR 0 3
14429: PUSH
14430: CALL_OW 45
14434: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14435: LD_VAR 0 3
14439: PPUSH
14440: LD_INT 4
14442: PPUSH
14443: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14447: LD_VAR 0 3
14451: PPUSH
14452: LD_INT 28
14454: PPUSH
14455: LD_INT 0
14457: PPUSH
14458: CALL_OW 49
// end ;
14462: GO 14403
14464: POP
14465: POP
// end ;
14466: LD_VAR 0 1
14470: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14471: LD_INT 22
14473: PUSH
14474: LD_INT 2
14476: PUSH
14477: EMPTY
14478: LIST
14479: LIST
14480: PPUSH
14481: CALL_OW 69
14485: IFFALSE 14785
14487: GO 14489
14489: DISABLE
14490: LD_INT 0
14492: PPUSH
14493: PPUSH
14494: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14495: LD_ADDR_VAR 0 3
14499: PUSH
14500: LD_INT 22
14502: PUSH
14503: LD_INT 2
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: PUSH
14510: LD_INT 25
14512: PUSH
14513: LD_INT 4
14515: PUSH
14516: EMPTY
14517: LIST
14518: LIST
14519: PUSH
14520: EMPTY
14521: LIST
14522: LIST
14523: PPUSH
14524: CALL_OW 69
14528: PUSH
14529: LD_EXP 91
14533: DIFF
14534: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14535: LD_ADDR_VAR 0 2
14539: PUSH
14540: LD_INT 22
14542: PUSH
14543: LD_INT 2
14545: PUSH
14546: EMPTY
14547: LIST
14548: LIST
14549: PPUSH
14550: CALL_OW 69
14554: PUSH
14555: LD_EXP 91
14559: PUSH
14560: LD_VAR 0 3
14564: UNION
14565: DIFF
14566: ST_TO_ADDR
// if Khatam then
14567: LD_EXP 91
14571: IFFALSE 14588
// ComMoveXY ( Khatam , 211 , 92 ) ;
14573: LD_EXP 91
14577: PPUSH
14578: LD_INT 211
14580: PPUSH
14581: LD_INT 92
14583: PPUSH
14584: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14588: LD_INT 197
14590: PPUSH
14591: LD_INT 80
14593: PPUSH
14594: LD_INT 2
14596: PPUSH
14597: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14601: LD_INT 213
14603: PPUSH
14604: LD_INT 90
14606: PPUSH
14607: LD_INT 2
14609: PPUSH
14610: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14614: LD_INT 215
14616: PPUSH
14617: LD_INT 129
14619: PPUSH
14620: LD_INT 2
14622: PPUSH
14623: CALL_OW 441
// if sci then
14627: LD_VAR 0 3
14631: IFFALSE 14652
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14633: LD_VAR 0 3
14637: PUSH
14638: LD_INT 1
14640: ARRAY
14641: PPUSH
14642: LD_INT 197
14644: PPUSH
14645: LD_INT 80
14647: PPUSH
14648: CALL_OW 158
// if sci > 1 then
14652: LD_VAR 0 3
14656: PUSH
14657: LD_INT 1
14659: GREATER
14660: IFFALSE 14681
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14662: LD_VAR 0 3
14666: PUSH
14667: LD_INT 2
14669: ARRAY
14670: PPUSH
14671: LD_INT 213
14673: PPUSH
14674: LD_INT 90
14676: PPUSH
14677: CALL_OW 158
// if sci > 2 then
14681: LD_VAR 0 3
14685: PUSH
14686: LD_INT 2
14688: GREATER
14689: IFFALSE 14710
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14691: LD_VAR 0 3
14695: PUSH
14696: LD_INT 3
14698: ARRAY
14699: PPUSH
14700: LD_INT 215
14702: PPUSH
14703: LD_INT 129
14705: PPUSH
14706: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14710: LD_INT 35
14712: PPUSH
14713: CALL_OW 67
// for i in tmp do
14717: LD_ADDR_VAR 0 1
14721: PUSH
14722: LD_VAR 0 2
14726: PUSH
14727: FOR_IN
14728: IFFALSE 14766
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14730: LD_VAR 0 1
14734: PPUSH
14735: LD_INT 81
14737: PUSH
14738: LD_INT 2
14740: PUSH
14741: EMPTY
14742: LIST
14743: LIST
14744: PPUSH
14745: CALL_OW 69
14749: PPUSH
14750: LD_VAR 0 1
14754: PPUSH
14755: CALL_OW 74
14759: PPUSH
14760: CALL_OW 115
14764: GO 14727
14766: POP
14767: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14768: LD_INT 22
14770: PUSH
14771: LD_INT 2
14773: PUSH
14774: EMPTY
14775: LIST
14776: LIST
14777: PPUSH
14778: CALL_OW 69
14782: NOT
14783: IFFALSE 14710
// end ; end_of_file
14785: PPOPN 3
14787: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14788: LD_INT 0
14790: PPUSH
14791: PPUSH
14792: PPUSH
14793: PPUSH
14794: PPUSH
14795: PPUSH
14796: PPUSH
14797: PPUSH
14798: PPUSH
// Video ( true ) ;
14799: LD_INT 1
14801: PPUSH
14802: CALL 106384 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14806: LD_ADDR_VAR 0 5
14810: PUSH
14811: LD_INT 7
14813: PPUSH
14814: LD_INT 0
14816: PPUSH
14817: CALL_OW 517
14821: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14822: LD_ADDR_VAR 0 2
14826: PUSH
14827: DOUBLE
14828: LD_INT 1
14830: DEC
14831: ST_TO_ADDR
14832: LD_VAR 0 5
14836: PUSH
14837: LD_INT 1
14839: ARRAY
14840: PUSH
14841: FOR_TO
14842: IFFALSE 14887
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14844: LD_VAR 0 5
14848: PUSH
14849: LD_INT 1
14851: ARRAY
14852: PUSH
14853: LD_VAR 0 2
14857: ARRAY
14858: PPUSH
14859: LD_VAR 0 5
14863: PUSH
14864: LD_INT 2
14866: ARRAY
14867: PUSH
14868: LD_VAR 0 2
14872: ARRAY
14873: PPUSH
14874: LD_INT 1
14876: PPUSH
14877: LD_INT 15
14879: NEG
14880: PPUSH
14881: CALL 106298 0 4
14885: GO 14841
14887: POP
14888: POP
// CenterNowOnUnits ( Powell ) ;
14889: LD_EXP 55
14893: PPUSH
14894: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14898: LD_ADDR_VAR 0 5
14902: PUSH
14903: LD_EXP 53
14907: PUSH
14908: EMPTY
14909: LIST
14910: ST_TO_ADDR
// if GirlNewVeh then
14911: LD_EXP 54
14915: IFFALSE 14933
// tmp := tmp ^ GirlNewVeh ;
14917: LD_ADDR_VAR 0 5
14921: PUSH
14922: LD_VAR 0 5
14926: PUSH
14927: LD_EXP 54
14931: ADD
14932: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14933: LD_VAR 0 5
14937: PPUSH
14938: LD_INT 60
14940: PPUSH
14941: LD_INT 109
14943: PPUSH
14944: CALL_OW 111
// if KappaStatus then
14948: LD_EXP 2
14952: IFFALSE 15004
// begin Say ( JMM , D1nT-JMM-1 ) ;
14954: LD_EXP 36
14958: PPUSH
14959: LD_STRING D1nT-JMM-1
14961: PPUSH
14962: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14966: LD_EXP 55
14970: PPUSH
14971: LD_STRING D1T-Pow-1
14973: PPUSH
14974: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14978: LD_EXP 36
14982: PPUSH
14983: LD_STRING D1T-JMM-2
14985: PPUSH
14986: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14990: LD_EXP 55
14994: PPUSH
14995: LD_STRING D1T-Pow-2
14997: PPUSH
14998: CALL_OW 88
// end else
15002: GO 15210
// if JMMGirlStatus then
15004: LD_EXP 6
15008: IFFALSE 15153
// begin Say ( JMM , D1T-JMM-1 ) ;
15010: LD_EXP 36
15014: PPUSH
15015: LD_STRING D1T-JMM-1
15017: PPUSH
15018: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15022: LD_EXP 55
15026: PPUSH
15027: LD_STRING D1T-Pow-1
15029: PPUSH
15030: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15034: LD_EXP 36
15038: PPUSH
15039: LD_STRING D1T-JMM-3
15041: PPUSH
15042: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15046: LD_EXP 55
15050: PPUSH
15051: LD_STRING D1T-Pow-3
15053: PPUSH
15054: CALL_OW 88
// if JMMGirl then
15058: LD_EXP 7
15062: IFFALSE 15151
// begin case JMMGirl of 1 :
15064: LD_EXP 7
15068: PUSH
15069: LD_INT 1
15071: DOUBLE
15072: EQUAL
15073: IFTRUE 15077
15075: GO 15092
15077: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15078: LD_EXP 37
15082: PPUSH
15083: LD_STRING D1T-Joan-3
15085: PPUSH
15086: CALL_OW 88
15090: GO 15139
15092: LD_INT 2
15094: DOUBLE
15095: EQUAL
15096: IFTRUE 15100
15098: GO 15115
15100: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15101: LD_EXP 39
15105: PPUSH
15106: LD_STRING D1T-Lisa-3
15108: PPUSH
15109: CALL_OW 88
15113: GO 15139
15115: LD_INT 3
15117: DOUBLE
15118: EQUAL
15119: IFTRUE 15123
15121: GO 15138
15123: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15124: LD_EXP 51
15128: PPUSH
15129: LD_STRING D1T-Con-3
15131: PPUSH
15132: CALL_OW 88
15136: GO 15139
15138: POP
// Say ( Powell , D1T-Pow-4 ) ;
15139: LD_EXP 55
15143: PPUSH
15144: LD_STRING D1T-Pow-4
15146: PPUSH
15147: CALL_OW 88
// end ; end else
15151: GO 15210
// if not FastEnd then
15153: LD_EXP 11
15157: NOT
15158: IFFALSE 15186
// begin Say ( JMM , D1T-JMM-4 ) ;
15160: LD_EXP 36
15164: PPUSH
15165: LD_STRING D1T-JMM-4
15167: PPUSH
15168: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15172: LD_EXP 55
15176: PPUSH
15177: LD_STRING D1T-Pow-5
15179: PPUSH
15180: CALL_OW 88
// end else
15184: GO 15210
// begin Say ( JMM , D1nT-JMM-1 ) ;
15186: LD_EXP 36
15190: PPUSH
15191: LD_STRING D1nT-JMM-1
15193: PPUSH
15194: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15198: LD_EXP 55
15202: PPUSH
15203: LD_STRING D1nT-Pow-1
15205: PPUSH
15206: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15210: LD_INT 35
15212: PPUSH
15213: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15217: LD_EXP 53
15221: PPUSH
15222: CALL_OW 314
15226: NOT
15227: IFFALSE 15210
// ComExitVehicle ( JMM ) ;
15229: LD_EXP 36
15233: PPUSH
15234: CALL_OW 121
// wait ( 3 ) ;
15238: LD_INT 3
15240: PPUSH
15241: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15245: LD_EXP 36
15249: PPUSH
15250: LD_INT 60
15252: PPUSH
15253: LD_INT 94
15255: PPUSH
15256: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15260: LD_EXP 36
15264: PPUSH
15265: LD_EXP 55
15269: PPUSH
15270: CALL_OW 179
// if Joan then
15274: LD_EXP 37
15278: IFFALSE 15332
// begin ComExitVehicle ( Joan ) ;
15280: LD_EXP 37
15284: PPUSH
15285: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15289: LD_EXP 37
15293: PPUSH
15294: LD_INT 35
15296: PPUSH
15297: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15301: LD_EXP 37
15305: PPUSH
15306: LD_INT 65
15308: PPUSH
15309: LD_INT 104
15311: PPUSH
15312: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15316: LD_EXP 37
15320: PPUSH
15321: LD_EXP 36
15325: PPUSH
15326: CALL_OW 179
// end else
15330: GO 15466
// if Lisa and JMMGirl = 2 then
15332: LD_EXP 39
15336: PUSH
15337: LD_EXP 7
15341: PUSH
15342: LD_INT 2
15344: EQUAL
15345: AND
15346: IFFALSE 15400
// begin ComExitVehicle ( Lisa ) ;
15348: LD_EXP 39
15352: PPUSH
15353: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15357: LD_EXP 39
15361: PPUSH
15362: LD_INT 35
15364: PPUSH
15365: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15369: LD_EXP 39
15373: PPUSH
15374: LD_INT 65
15376: PPUSH
15377: LD_INT 104
15379: PPUSH
15380: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15384: LD_EXP 39
15388: PPUSH
15389: LD_EXP 36
15393: PPUSH
15394: CALL_OW 179
// end else
15398: GO 15466
// if Connie and JMMGirl = 3 then
15400: LD_EXP 51
15404: PUSH
15405: LD_EXP 7
15409: PUSH
15410: LD_INT 3
15412: EQUAL
15413: AND
15414: IFFALSE 15466
// begin ComExitVehicle ( Connie ) ;
15416: LD_EXP 51
15420: PPUSH
15421: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15425: LD_EXP 51
15429: PPUSH
15430: LD_INT 35
15432: PPUSH
15433: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15437: LD_EXP 51
15441: PPUSH
15442: LD_INT 65
15444: PPUSH
15445: LD_INT 104
15447: PPUSH
15448: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15452: LD_EXP 51
15456: PPUSH
15457: LD_EXP 36
15461: PPUSH
15462: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15466: LD_INT 35
15468: PPUSH
15469: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15473: LD_EXP 36
15477: PPUSH
15478: LD_EXP 55
15482: PPUSH
15483: CALL_OW 296
15487: PUSH
15488: LD_INT 6
15490: LESS
15491: IFFALSE 15466
// wait ( 0 0$0.5 ) ;
15493: LD_INT 18
15495: PPUSH
15496: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15500: LD_EXP 36
15504: PPUSH
15505: LD_STRING D1-JMM-1
15507: PPUSH
15508: CALL_OW 88
// async ;
15512: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15513: LD_EXP 55
15517: PPUSH
15518: LD_STRING D1-Pow-1
15520: PPUSH
15521: CALL_OW 88
// if not dialogue_skipped then
15525: LD_OWVAR 59
15529: NOT
15530: IFFALSE 15539
// wait ( 0 0$2 ) ;
15532: LD_INT 70
15534: PPUSH
15535: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15539: LD_INT 170
15541: PPUSH
15542: LD_INT 99
15544: PPUSH
15545: LD_INT 1
15547: PPUSH
15548: LD_INT 6
15550: NEG
15551: PPUSH
15552: CALL 106298 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15556: LD_INT 174
15558: PPUSH
15559: LD_INT 115
15561: PPUSH
15562: LD_INT 1
15564: PPUSH
15565: LD_INT 6
15567: NEG
15568: PPUSH
15569: CALL 106298 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15573: LD_INT 169
15575: PPUSH
15576: LD_INT 71
15578: PPUSH
15579: LD_INT 1
15581: PPUSH
15582: LD_INT 6
15584: NEG
15585: PPUSH
15586: CALL 106298 0 4
// if not dialogue_skipped then
15590: LD_OWVAR 59
15594: NOT
15595: IFFALSE 15614
// begin CenterOnXY ( 170 , 99 ) ;
15597: LD_INT 170
15599: PPUSH
15600: LD_INT 99
15602: PPUSH
15603: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15607: LD_INT 80
15609: PPUSH
15610: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15614: LD_INT 75
15616: PPUSH
15617: LD_INT 53
15619: PPUSH
15620: LD_INT 1
15622: PPUSH
15623: LD_INT 9
15625: NEG
15626: PPUSH
15627: CALL 106298 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15631: LD_INT 54
15633: PPUSH
15634: LD_INT 42
15636: PPUSH
15637: LD_INT 1
15639: PPUSH
15640: LD_INT 9
15642: NEG
15643: PPUSH
15644: CALL 106298 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15648: LD_INT 62
15650: PPUSH
15651: LD_INT 51
15653: PPUSH
15654: LD_INT 1
15656: PPUSH
15657: LD_INT 9
15659: NEG
15660: PPUSH
15661: CALL 106298 0 4
// if not dialogue_skipped then
15665: LD_OWVAR 59
15669: NOT
15670: IFFALSE 15689
// begin CenterOnXY ( 75 , 53 ) ;
15672: LD_INT 75
15674: PPUSH
15675: LD_INT 53
15677: PPUSH
15678: CALL_OW 84
// wait ( 0 0$4 ) ;
15682: LD_INT 140
15684: PPUSH
15685: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15689: LD_EXP 55
15693: PPUSH
15694: CALL_OW 87
// if not dialogue_skipped then
15698: LD_OWVAR 59
15702: NOT
15703: IFFALSE 15712
// wait ( 0 0$2 ) ;
15705: LD_INT 70
15707: PPUSH
15708: CALL_OW 67
// sync ;
15712: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15713: LD_EXP 36
15717: PPUSH
15718: LD_STRING D1-JMM-2
15720: PPUSH
15721: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15725: LD_EXP 55
15729: PPUSH
15730: LD_STRING D1-Pow-2
15732: PPUSH
15733: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15737: LD_EXP 36
15741: PPUSH
15742: LD_STRING D1-JMM-3
15744: PPUSH
15745: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15749: LD_EXP 55
15753: PPUSH
15754: LD_STRING D1-Pow-3
15756: PPUSH
15757: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15761: LD_EXP 36
15765: PPUSH
15766: LD_STRING D1-JMM-4
15768: PPUSH
15769: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15773: LD_EXP 55
15777: PPUSH
15778: LD_STRING D1-Pow-4
15780: PPUSH
15781: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15785: LD_EXP 36
15789: PPUSH
15790: LD_STRING D1-JMM-5
15792: PPUSH
15793: CALL_OW 88
// async ;
15797: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15798: LD_EXP 55
15802: PPUSH
15803: LD_STRING D1-Pow-5
15805: PPUSH
15806: CALL_OW 88
// if not dialogue_skipped then
15810: LD_OWVAR 59
15814: NOT
15815: IFFALSE 15824
// wait ( 0 0$3.6 ) ;
15817: LD_INT 126
15819: PPUSH
15820: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15824: LD_INT 134
15826: PPUSH
15827: LD_INT 210
15829: PPUSH
15830: LD_INT 1
15832: PPUSH
15833: LD_INT 11
15835: NEG
15836: PPUSH
15837: CALL 106298 0 4
// if not dialogue_skipped then
15841: LD_OWVAR 59
15845: NOT
15846: IFFALSE 15865
// begin CenterOnXY ( 134 , 210 ) ;
15848: LD_INT 134
15850: PPUSH
15851: LD_INT 210
15853: PPUSH
15854: CALL_OW 84
// wait ( 0 0$2 ) ;
15858: LD_INT 70
15860: PPUSH
15861: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15865: LD_INT 101
15867: PPUSH
15868: LD_INT 159
15870: PPUSH
15871: LD_INT 1
15873: PPUSH
15874: LD_INT 10
15876: NEG
15877: PPUSH
15878: CALL 106298 0 4
// if not dialogue_skipped then
15882: LD_OWVAR 59
15886: NOT
15887: IFFALSE 15906
// begin CenterOnXY ( 101 , 159 ) ;
15889: LD_INT 101
15891: PPUSH
15892: LD_INT 159
15894: PPUSH
15895: CALL_OW 84
// wait ( 0 0$2 ) ;
15899: LD_INT 70
15901: PPUSH
15902: CALL_OW 67
// end ; sync ;
15906: SYNC
// CenterNowOnUnits ( Powell ) ;
15907: LD_EXP 55
15911: PPUSH
15912: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15916: LD_ADDR_VAR 0 6
15920: PUSH
15921: LD_INT 1
15923: PUSH
15924: LD_INT 2
15926: PUSH
15927: LD_INT 3
15929: PUSH
15930: LD_INT 4
15932: PUSH
15933: LD_INT 5
15935: PUSH
15936: LD_INT 6
15938: PUSH
15939: EMPTY
15940: LIST
15941: LIST
15942: LIST
15943: LIST
15944: LIST
15945: LIST
15946: ST_TO_ADDR
// if not dialogue_skipped then
15947: LD_OWVAR 59
15951: NOT
15952: IFFALSE 16121
// begin game_speed := 4 ;
15954: LD_ADDR_OWVAR 65
15958: PUSH
15959: LD_INT 4
15961: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15962: LD_INT 210
15964: PPUSH
15965: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15969: LD_ADDR_VAR 0 7
15973: PUSH
15974: LD_STRING Q1
15976: PPUSH
15977: LD_VAR 0 6
15981: PPUSH
15982: CALL_OW 98
15986: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15987: LD_ADDR_VAR 0 7
15991: PUSH
15992: LD_STRING Q1
15994: PPUSH
15995: LD_VAR 0 6
15999: PPUSH
16000: CALL_OW 98
16004: ST_TO_ADDR
// options = options diff dec ;
16005: LD_ADDR_VAR 0 6
16009: PUSH
16010: LD_VAR 0 6
16014: PUSH
16015: LD_VAR 0 7
16019: DIFF
16020: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16021: LD_VAR 0 7
16025: PPUSH
16026: LD_VAR 0 6
16030: PPUSH
16031: CALL 17424 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16035: LD_VAR 0 7
16039: PUSH
16040: LD_INT 5
16042: PUSH
16043: LD_INT 6
16045: PUSH
16046: EMPTY
16047: LIST
16048: LIST
16049: IN
16050: PUSH
16051: LD_VAR 0 6
16055: PUSH
16056: LD_INT 2
16058: EQUAL
16059: OR
16060: IFFALSE 15987
// if not ( dec in [ 5 , 6 ] ) then
16062: LD_VAR 0 7
16066: PUSH
16067: LD_INT 5
16069: PUSH
16070: LD_INT 6
16072: PUSH
16073: EMPTY
16074: LIST
16075: LIST
16076: IN
16077: NOT
16078: IFFALSE 16121
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16080: LD_ADDR_VAR 0 7
16084: PUSH
16085: LD_STRING Q1a
16087: PPUSH
16088: LD_INT 1
16090: PUSH
16091: LD_INT 2
16093: PUSH
16094: EMPTY
16095: LIST
16096: LIST
16097: PPUSH
16098: CALL_OW 98
16102: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16103: LD_VAR 0 7
16107: PUSH
16108: LD_INT 4
16110: PLUS
16111: PPUSH
16112: LD_VAR 0 6
16116: PPUSH
16117: CALL 17424 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16121: LD_INT 81
16123: PPUSH
16124: LD_INT 127
16126: PPUSH
16127: CALL_OW 84
// amount := 5 ;
16131: LD_ADDR_VAR 0 8
16135: PUSH
16136: LD_INT 5
16138: ST_TO_ADDR
// macmilan_squad := [ ] ;
16139: LD_ADDR_VAR 0 9
16143: PUSH
16144: EMPTY
16145: ST_TO_ADDR
// if vip < amount then
16146: LD_EXP 56
16150: PUSH
16151: LD_VAR 0 8
16155: LESS
16156: IFFALSE 16200
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16158: LD_ADDR_VAR 0 5
16162: PUSH
16163: LD_EXP 56
16167: PUSH
16168: LD_INT 22
16170: PUSH
16171: LD_INT 4
16173: PUSH
16174: EMPTY
16175: LIST
16176: LIST
16177: PUSH
16178: LD_INT 21
16180: PUSH
16181: LD_INT 1
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: PUSH
16188: EMPTY
16189: LIST
16190: LIST
16191: PPUSH
16192: CALL_OW 69
16196: UNION
16197: ST_TO_ADDR
16198: GO 16210
// tmp := vip ;
16200: LD_ADDR_VAR 0 5
16204: PUSH
16205: LD_EXP 56
16209: ST_TO_ADDR
// tmp := tmp diff Powell ;
16210: LD_ADDR_VAR 0 5
16214: PUSH
16215: LD_VAR 0 5
16219: PUSH
16220: LD_EXP 55
16224: DIFF
16225: ST_TO_ADDR
// if tmp < amount then
16226: LD_VAR 0 5
16230: PUSH
16231: LD_VAR 0 8
16235: LESS
16236: IFFALSE 16248
// amount := tmp ;
16238: LD_ADDR_VAR 0 8
16242: PUSH
16243: LD_VAR 0 5
16247: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16248: LD_VAR 0 5
16252: PUSH
16253: LD_INT 1
16255: ARRAY
16256: PPUSH
16257: CALL_OW 257
16261: PUSH
16262: LD_INT 2
16264: NONEQUAL
16265: IFFALSE 16327
// begin if IsInUnit ( tmp [ 1 ] ) then
16267: LD_VAR 0 5
16271: PUSH
16272: LD_INT 1
16274: ARRAY
16275: PPUSH
16276: CALL_OW 310
16280: IFFALSE 16295
// ComExitBuilding ( tmp [ 1 ] ) ;
16282: LD_VAR 0 5
16286: PUSH
16287: LD_INT 1
16289: ARRAY
16290: PPUSH
16291: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16295: LD_VAR 0 5
16299: PUSH
16300: LD_INT 1
16302: ARRAY
16303: PPUSH
16304: LD_INT 387
16306: PPUSH
16307: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16311: LD_VAR 0 5
16315: PUSH
16316: LD_INT 1
16318: ARRAY
16319: PPUSH
16320: LD_INT 2
16322: PPUSH
16323: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16327: LD_EXP 36
16331: PPUSH
16332: LD_INT 82
16334: PPUSH
16335: LD_INT 129
16337: PPUSH
16338: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16342: LD_EXP 36
16346: PPUSH
16347: LD_EXP 55
16351: PPUSH
16352: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16356: LD_INT 22
16358: PUSH
16359: LD_INT 1
16361: PUSH
16362: EMPTY
16363: LIST
16364: LIST
16365: PPUSH
16366: CALL_OW 69
16370: PUSH
16371: LD_EXP 36
16375: DIFF
16376: PPUSH
16377: LD_INT 84
16379: PPUSH
16380: LD_INT 128
16382: PPUSH
16383: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16387: LD_INT 22
16389: PUSH
16390: LD_INT 1
16392: PUSH
16393: EMPTY
16394: LIST
16395: LIST
16396: PPUSH
16397: CALL_OW 69
16401: PUSH
16402: LD_EXP 36
16406: DIFF
16407: PPUSH
16408: LD_EXP 36
16412: PPUSH
16413: CALL_OW 179
// for i = 1 to amount do
16417: LD_ADDR_VAR 0 2
16421: PUSH
16422: DOUBLE
16423: LD_INT 1
16425: DEC
16426: ST_TO_ADDR
16427: LD_VAR 0 8
16431: PUSH
16432: FOR_TO
16433: IFFALSE 16601
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16435: LD_ADDR_VAR 0 9
16439: PUSH
16440: LD_VAR 0 9
16444: PUSH
16445: LD_VAR 0 5
16449: PUSH
16450: LD_VAR 0 2
16454: ARRAY
16455: ADD
16456: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16457: LD_VAR 0 5
16461: PUSH
16462: LD_VAR 0 2
16466: ARRAY
16467: PPUSH
16468: CALL_OW 310
16472: IFFALSE 16489
// AddComExitBuilding ( tmp [ i ] ) ;
16474: LD_VAR 0 5
16478: PUSH
16479: LD_VAR 0 2
16483: ARRAY
16484: PPUSH
16485: CALL_OW 182
// if i = 2 and JMMNewVeh then
16489: LD_VAR 0 2
16493: PUSH
16494: LD_INT 2
16496: EQUAL
16497: PUSH
16498: LD_EXP 53
16502: AND
16503: IFFALSE 16561
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16505: LD_VAR 0 5
16509: PUSH
16510: LD_VAR 0 2
16514: ARRAY
16515: PPUSH
16516: LD_EXP 53
16520: PPUSH
16521: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16525: LD_VAR 0 5
16529: PUSH
16530: LD_VAR 0 2
16534: ARRAY
16535: PPUSH
16536: LD_INT 86
16538: PPUSH
16539: LD_INT 133
16541: PPUSH
16542: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16546: LD_VAR 0 5
16550: PUSH
16551: LD_VAR 0 2
16555: ARRAY
16556: PPUSH
16557: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16561: LD_VAR 0 5
16565: PUSH
16566: LD_VAR 0 2
16570: ARRAY
16571: PPUSH
16572: LD_INT 8
16574: PPUSH
16575: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16579: LD_VAR 0 5
16583: PUSH
16584: LD_VAR 0 2
16588: ARRAY
16589: PPUSH
16590: LD_EXP 36
16594: PPUSH
16595: CALL_OW 179
// end ;
16599: GO 16432
16601: POP
16602: POP
// if GirlNewVeh then
16603: LD_EXP 54
16607: IFFALSE 16621
// SetSide ( GirlNewVeh , 4 ) ;
16609: LD_EXP 54
16613: PPUSH
16614: LD_INT 4
16616: PPUSH
16617: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16621: LD_INT 35
16623: PPUSH
16624: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16628: LD_VAR 0 9
16632: PPUSH
16633: LD_INT 95
16635: PUSH
16636: LD_INT 9
16638: PUSH
16639: EMPTY
16640: LIST
16641: LIST
16642: PPUSH
16643: CALL_OW 72
16647: PUSH
16648: LD_INT 0
16650: EQUAL
16651: PUSH
16652: LD_EXP 36
16656: PPUSH
16657: LD_INT 9
16659: PPUSH
16660: CALL_OW 308
16664: NOT
16665: AND
16666: IFFALSE 16621
// wait ( 0 0$2 ) ;
16668: LD_INT 70
16670: PPUSH
16671: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16675: LD_VAR 0 9
16679: PPUSH
16680: LD_INT 1
16682: PPUSH
16683: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16687: LD_INT 21
16689: PUSH
16690: LD_INT 2
16692: PUSH
16693: EMPTY
16694: LIST
16695: LIST
16696: PUSH
16697: LD_INT 92
16699: PUSH
16700: LD_INT 83
16702: PUSH
16703: LD_INT 130
16705: PUSH
16706: LD_INT 10
16708: PUSH
16709: EMPTY
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: PUSH
16715: EMPTY
16716: LIST
16717: LIST
16718: PPUSH
16719: CALL_OW 69
16723: PPUSH
16724: LD_INT 1
16726: PPUSH
16727: CALL_OW 235
// Video ( false ) ;
16731: LD_INT 0
16733: PPUSH
16734: CALL 106384 0 1
// ChangeMissionObjectives ( M1 ) ;
16738: LD_STRING M1
16740: PPUSH
16741: CALL_OW 337
// SaveForQuickRestart ;
16745: CALL_OW 22
// missionStart := true ;
16749: LD_ADDR_EXP 13
16753: PUSH
16754: LD_INT 1
16756: ST_TO_ADDR
// missionStage := 2 ;
16757: LD_ADDR_EXP 15
16761: PUSH
16762: LD_INT 2
16764: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16765: LD_INT 105
16767: PPUSH
16768: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16772: LD_ADDR_VAR 0 5
16776: PUSH
16777: LD_INT 22
16779: PUSH
16780: LD_INT 4
16782: PUSH
16783: EMPTY
16784: LIST
16785: LIST
16786: PUSH
16787: LD_INT 21
16789: PUSH
16790: LD_INT 1
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PUSH
16797: EMPTY
16798: LIST
16799: LIST
16800: PPUSH
16801: CALL_OW 69
16805: PUSH
16806: LD_EXP 55
16810: DIFF
16811: ST_TO_ADDR
// if not tmp then
16812: LD_VAR 0 5
16816: NOT
16817: IFFALSE 16832
// tmp := [ Powell ] ;
16819: LD_ADDR_VAR 0 5
16823: PUSH
16824: LD_EXP 55
16828: PUSH
16829: EMPTY
16830: LIST
16831: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16832: LD_ADDR_EXP 99
16836: PUSH
16837: LD_EXP 99
16841: PPUSH
16842: LD_INT 4
16844: PPUSH
16845: LD_INT 22
16847: PUSH
16848: LD_INT 4
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PUSH
16855: LD_INT 23
16857: PUSH
16858: LD_INT 1
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: PUSH
16865: LD_INT 3
16867: PUSH
16868: LD_INT 21
16870: PUSH
16871: LD_INT 2
16873: PUSH
16874: EMPTY
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PUSH
16882: EMPTY
16883: LIST
16884: LIST
16885: LIST
16886: PPUSH
16887: CALL_OW 69
16891: PUSH
16892: LD_EXP 55
16896: DIFF
16897: PPUSH
16898: CALL_OW 1
16902: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16903: LD_ADDR_VAR 0 4
16907: PUSH
16908: LD_INT 22
16910: PUSH
16911: LD_INT 4
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: LD_INT 34
16920: PUSH
16921: LD_INT 12
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: EMPTY
16929: LIST
16930: LIST
16931: PPUSH
16932: CALL_OW 69
16936: PUSH
16937: LD_INT 1
16939: ARRAY
16940: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16941: LD_VAR 0 5
16945: PUSH
16946: LD_INT 1
16948: ARRAY
16949: PPUSH
16950: CALL_OW 310
16954: IFFALSE 16969
// ComExitBuilding ( tmp [ 1 ] ) ;
16956: LD_VAR 0 5
16960: PUSH
16961: LD_INT 1
16963: ARRAY
16964: PPUSH
16965: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16969: LD_VAR 0 5
16973: PUSH
16974: LD_INT 1
16976: ARRAY
16977: PPUSH
16978: LD_VAR 0 4
16982: PPUSH
16983: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16987: LD_VAR 0 5
16991: PUSH
16992: LD_INT 1
16994: ARRAY
16995: PPUSH
16996: LD_INT 80
16998: PPUSH
16999: LD_INT 136
17001: PPUSH
17002: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17006: LD_VAR 0 5
17010: PUSH
17011: LD_INT 1
17013: ARRAY
17014: PPUSH
17015: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17019: LD_VAR 0 5
17023: PUSH
17024: LD_INT 1
17026: ARRAY
17027: PPUSH
17028: LD_INT 59
17030: PPUSH
17031: LD_INT 112
17033: PPUSH
17034: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17038: LD_VAR 0 5
17042: PUSH
17043: LD_INT 1
17045: ARRAY
17046: PPUSH
17047: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
17051: LD_EXP 39
17055: PUSH
17056: LD_EXP 56
17060: IN
17061: PUSH
17062: LD_EXP 39
17066: PPUSH
17067: CALL_OW 255
17071: PUSH
17072: LD_INT 1
17074: EQUAL
17075: AND
17076: IFFALSE 17092
// Say ( Lisa , D3nW-Lisa-1 ) else
17078: LD_EXP 39
17082: PPUSH
17083: LD_STRING D3nW-Lisa-1
17085: PPUSH
17086: CALL_OW 88
17090: GO 17336
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17092: LD_EXP 42
17096: PUSH
17097: LD_EXP 56
17101: IN
17102: PUSH
17103: LD_EXP 42
17107: PPUSH
17108: CALL_OW 255
17112: PUSH
17113: LD_INT 1
17115: EQUAL
17116: AND
17117: IFFALSE 17133
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17119: LD_EXP 42
17123: PPUSH
17124: LD_STRING D3nW-Cyrus-1
17126: PPUSH
17127: CALL_OW 88
17131: GO 17336
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17133: LD_EXP 41
17137: PUSH
17138: LD_EXP 56
17142: IN
17143: PUSH
17144: LD_EXP 41
17148: PPUSH
17149: CALL_OW 255
17153: PUSH
17154: LD_INT 1
17156: EQUAL
17157: AND
17158: IFFALSE 17174
// Say ( Bobby , D3nW-Bobby-1 ) else
17160: LD_EXP 41
17164: PPUSH
17165: LD_STRING D3nW-Bobby-1
17167: PPUSH
17168: CALL_OW 88
17172: GO 17336
// if Gary in vip and GetSide ( Gary ) = 1 then
17174: LD_EXP 48
17178: PUSH
17179: LD_EXP 56
17183: IN
17184: PUSH
17185: LD_EXP 48
17189: PPUSH
17190: CALL_OW 255
17194: PUSH
17195: LD_INT 1
17197: EQUAL
17198: AND
17199: IFFALSE 17215
// Say ( Gary , D3nW-Gary-1 ) else
17201: LD_EXP 48
17205: PPUSH
17206: LD_STRING D3nW-Gary-1
17208: PPUSH
17209: CALL_OW 88
17213: GO 17336
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17215: LD_EXP 40
17219: PUSH
17220: LD_EXP 56
17224: IN
17225: PUSH
17226: LD_EXP 40
17230: PPUSH
17231: CALL_OW 255
17235: PUSH
17236: LD_INT 1
17238: EQUAL
17239: AND
17240: IFFALSE 17256
// Say ( Donaldson , D3nW-Don-1 ) else
17242: LD_EXP 40
17246: PPUSH
17247: LD_STRING D3nW-Don-1
17249: PPUSH
17250: CALL_OW 88
17254: GO 17336
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17256: LD_EXP 47
17260: PUSH
17261: LD_EXP 56
17265: IN
17266: PUSH
17267: LD_EXP 47
17271: PPUSH
17272: CALL_OW 255
17276: PUSH
17277: LD_INT 1
17279: EQUAL
17280: AND
17281: IFFALSE 17297
// Say ( Cornel , D3nW-Corn-1 ) else
17283: LD_EXP 47
17287: PPUSH
17288: LD_STRING D3nW-Corn-1
17290: PPUSH
17291: CALL_OW 88
17295: GO 17336
// if Frank in vip and GetSide ( Frank ) = 1 then
17297: LD_EXP 49
17301: PUSH
17302: LD_EXP 56
17306: IN
17307: PUSH
17308: LD_EXP 49
17312: PPUSH
17313: CALL_OW 255
17317: PUSH
17318: LD_INT 1
17320: EQUAL
17321: AND
17322: IFFALSE 17336
// Say ( Frank , D3nW-Frank-1 ) ;
17324: LD_EXP 49
17328: PPUSH
17329: LD_STRING D3nW-Frank-1
17331: PPUSH
17332: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17336: LD_EXP 36
17340: PPUSH
17341: LD_STRING D3nW-JMM-1
17343: PPUSH
17344: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17348: LD_EXP 36
17352: PPUSH
17353: LD_STRING D3nW-JMM-1a
17355: PPUSH
17356: CALL_OW 88
// t := 0 0$00 ;
17360: LD_ADDR_VAR 0 3
17364: PUSH
17365: LD_INT 0
17367: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17368: LD_INT 35
17370: PPUSH
17371: CALL_OW 67
// t := t + 0 0$1 ;
17375: LD_ADDR_VAR 0 3
17379: PUSH
17380: LD_VAR 0 3
17384: PUSH
17385: LD_INT 35
17387: PLUS
17388: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17389: LD_INT 59
17391: PPUSH
17392: LD_INT 112
17394: PPUSH
17395: CALL_OW 428
17399: PUSH
17400: LD_VAR 0 3
17404: PUSH
17405: LD_INT 2100
17407: GREATER
17408: OR
17409: IFFALSE 17368
// activeAttacks := true ;
17411: LD_ADDR_EXP 16
17415: PUSH
17416: LD_INT 1
17418: ST_TO_ADDR
// end ;
17419: LD_VAR 0 1
17423: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17424: LD_INT 0
17426: PPUSH
// case question of 1 :
17427: LD_VAR 0 1
17431: PUSH
17432: LD_INT 1
17434: DOUBLE
17435: EQUAL
17436: IFTRUE 17440
17438: GO 17491
17440: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17441: LD_EXP 36
17445: PPUSH
17446: LD_STRING D2Mot-JMM-1
17448: PPUSH
17449: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17453: LD_EXP 55
17457: PPUSH
17458: LD_STRING D2Mot-Pow-1
17460: PPUSH
17461: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17465: LD_EXP 36
17469: PPUSH
17470: LD_STRING D2Mot-JMM-2
17472: PPUSH
17473: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17477: LD_EXP 55
17481: PPUSH
17482: LD_STRING D2Mot-Pow-2
17484: PPUSH
17485: CALL_OW 88
// end ; 2 :
17489: GO 17834
17491: LD_INT 2
17493: DOUBLE
17494: EQUAL
17495: IFTRUE 17499
17497: GO 17575
17499: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17500: LD_EXP 36
17504: PPUSH
17505: LD_STRING D2Rus-JMM-1
17507: PPUSH
17508: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17512: LD_EXP 55
17516: PPUSH
17517: LD_STRING D2Rus-Pow-1
17519: PPUSH
17520: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17524: LD_EXP 36
17528: PPUSH
17529: LD_STRING D2Rus-JMM-2
17531: PPUSH
17532: CALL_OW 88
// if not ( 3 in list_of_q ) then
17536: LD_INT 3
17538: PUSH
17539: LD_VAR 0 2
17543: IN
17544: NOT
17545: IFFALSE 17561
// Say ( Powell , D2Rus-Pow-2 ) else
17547: LD_EXP 55
17551: PPUSH
17552: LD_STRING D2Rus-Pow-2
17554: PPUSH
17555: CALL_OW 88
17559: GO 17573
// Say ( Powell , D2Rus-Pow-2a ) ;
17561: LD_EXP 55
17565: PPUSH
17566: LD_STRING D2Rus-Pow-2a
17568: PPUSH
17569: CALL_OW 88
// end ; 3 :
17573: GO 17834
17575: LD_INT 3
17577: DOUBLE
17578: EQUAL
17579: IFTRUE 17583
17581: GO 17668
17583: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17584: LD_EXP 36
17588: PPUSH
17589: LD_STRING D2Leg-JMM-1
17591: PPUSH
17592: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17596: LD_EXP 55
17600: PPUSH
17601: LD_STRING D2Leg-Pow-1
17603: PPUSH
17604: CALL_OW 88
// if 2 in list_of_q then
17608: LD_INT 2
17610: PUSH
17611: LD_VAR 0 2
17615: IN
17616: IFFALSE 17642
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17618: LD_EXP 36
17622: PPUSH
17623: LD_STRING D2Leg-JMM-2
17625: PPUSH
17626: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17630: LD_EXP 55
17634: PPUSH
17635: LD_STRING D2Leg-Pow-2
17637: PPUSH
17638: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17642: LD_EXP 36
17646: PPUSH
17647: LD_STRING D2Leg-JMM-3
17649: PPUSH
17650: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17654: LD_EXP 55
17658: PPUSH
17659: LD_STRING D2Leg-Pow-3
17661: PPUSH
17662: CALL_OW 88
// end ; 4 :
17666: GO 17834
17668: LD_INT 4
17670: DOUBLE
17671: EQUAL
17672: IFTRUE 17676
17674: GO 17751
17676: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17677: LD_EXP 36
17681: PPUSH
17682: LD_STRING D2Ar-JMM-1
17684: PPUSH
17685: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17689: LD_EXP 55
17693: PPUSH
17694: LD_STRING D2Ar-Pow-1
17696: PPUSH
17697: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17701: LD_EXP 36
17705: PPUSH
17706: LD_STRING D2Ar-JMM-2
17708: PPUSH
17709: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17713: LD_EXP 55
17717: PPUSH
17718: LD_STRING D2Ar-Pow-2
17720: PPUSH
17721: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17725: LD_EXP 36
17729: PPUSH
17730: LD_STRING D2Ar-JMM-3
17732: PPUSH
17733: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17737: LD_EXP 55
17741: PPUSH
17742: LD_STRING D2Ar-Pow-3
17744: PPUSH
17745: CALL_OW 88
// end ; 5 :
17749: GO 17834
17751: LD_INT 5
17753: DOUBLE
17754: EQUAL
17755: IFTRUE 17759
17757: GO 17774
17759: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17760: LD_EXP 36
17764: PPUSH
17765: LD_STRING D2Conf-JMM-1
17767: PPUSH
17768: CALL_OW 88
17772: GO 17834
17774: LD_INT 6
17776: DOUBLE
17777: EQUAL
17778: IFTRUE 17782
17780: GO 17833
17782: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17783: LD_EXP 36
17787: PPUSH
17788: LD_STRING D2Com-JMM-1
17790: PPUSH
17791: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17795: LD_EXP 55
17799: PPUSH
17800: LD_STRING D2Com-Pow-1
17802: PPUSH
17803: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17807: LD_EXP 36
17811: PPUSH
17812: LD_STRING D2Com-JMM-2
17814: PPUSH
17815: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17819: LD_EXP 55
17823: PPUSH
17824: LD_STRING D2Com-Pow-2
17826: PPUSH
17827: CALL_OW 88
// end ; end ;
17831: GO 17834
17833: POP
// end ;
17834: LD_VAR 0 3
17838: RET
// every 0 0$5 trigger missionStart do var tmp ;
17839: LD_EXP 13
17843: IFFALSE 18126
17845: GO 17847
17847: DISABLE
17848: LD_INT 0
17850: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17851: LD_INT 35
17853: PPUSH
17854: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17858: LD_INT 14
17860: PPUSH
17861: LD_INT 22
17863: PUSH
17864: LD_INT 1
17866: PUSH
17867: EMPTY
17868: LIST
17869: LIST
17870: PPUSH
17871: CALL_OW 70
17875: PUSH
17876: LD_EXP 15
17880: PUSH
17881: LD_INT 2
17883: PUSH
17884: LD_INT 3
17886: PUSH
17887: LD_INT 4
17889: PUSH
17890: LD_INT 5
17892: PUSH
17893: EMPTY
17894: LIST
17895: LIST
17896: LIST
17897: LIST
17898: IN
17899: AND
17900: IFFALSE 18116
// begin powellAnger := powellAnger + 1 ;
17902: LD_ADDR_EXP 17
17906: PUSH
17907: LD_EXP 17
17911: PUSH
17912: LD_INT 1
17914: PLUS
17915: ST_TO_ADDR
// Video ( true ) ;
17916: LD_INT 1
17918: PPUSH
17919: CALL 106384 0 1
// CenterNowOnUnits ( tmp ) ;
17923: LD_VAR 0 1
17927: PPUSH
17928: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17932: LD_INT 14
17934: PPUSH
17935: LD_INT 22
17937: PUSH
17938: LD_INT 1
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: PPUSH
17945: CALL_OW 70
17949: PPUSH
17950: LD_INT 86
17952: PPUSH
17953: LD_INT 133
17955: PPUSH
17956: CALL_OW 111
// async ;
17960: ASYNC
// case powellAnger of 1 :
17961: LD_EXP 17
17965: PUSH
17966: LD_INT 1
17968: DOUBLE
17969: EQUAL
17970: IFTRUE 17974
17972: GO 17989
17974: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17975: LD_EXP 55
17979: PPUSH
17980: LD_STRING DBack1-Pow-1
17982: PPUSH
17983: CALL_OW 88
17987: GO 18036
17989: LD_INT 2
17991: DOUBLE
17992: EQUAL
17993: IFTRUE 17997
17995: GO 18012
17997: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17998: LD_EXP 55
18002: PPUSH
18003: LD_STRING DBack2-Pow-1
18005: PPUSH
18006: CALL_OW 88
18010: GO 18036
18012: LD_INT 3
18014: DOUBLE
18015: EQUAL
18016: IFTRUE 18020
18018: GO 18035
18020: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18021: LD_EXP 55
18025: PPUSH
18026: LD_STRING DBack3-Pow-1
18028: PPUSH
18029: CALL_OW 88
18033: GO 18036
18035: POP
// sync ;
18036: SYNC
// repeat wait ( 0 0$1 ) ;
18037: LD_INT 35
18039: PPUSH
18040: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18044: LD_INT 14
18046: PPUSH
18047: LD_INT 22
18049: PUSH
18050: LD_INT 1
18052: PUSH
18053: EMPTY
18054: LIST
18055: LIST
18056: PPUSH
18057: CALL_OW 70
18061: PPUSH
18062: LD_INT 86
18064: PPUSH
18065: LD_INT 133
18067: PPUSH
18068: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18072: LD_INT 14
18074: PPUSH
18075: LD_INT 22
18077: PUSH
18078: LD_INT 1
18080: PUSH
18081: EMPTY
18082: LIST
18083: LIST
18084: PPUSH
18085: CALL_OW 70
18089: NOT
18090: IFFALSE 18037
// if powellAnger >= 3 then
18092: LD_EXP 17
18096: PUSH
18097: LD_INT 3
18099: GREATEREQUAL
18100: IFFALSE 18109
// YouLost ( Dismissed ) ;
18102: LD_STRING Dismissed
18104: PPUSH
18105: CALL_OW 104
// Video ( false ) ;
18109: LD_INT 0
18111: PPUSH
18112: CALL 106384 0 1
// end ; until missionStage > 5 ;
18116: LD_EXP 15
18120: PUSH
18121: LD_INT 5
18123: GREATER
18124: IFFALSE 17851
// end ;
18126: PPOPN 1
18128: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18129: LD_EXP 13
18133: PUSH
18134: LD_INT 22
18136: PUSH
18137: LD_INT 4
18139: PUSH
18140: EMPTY
18141: LIST
18142: LIST
18143: PUSH
18144: LD_INT 21
18146: PUSH
18147: LD_INT 2
18149: PUSH
18150: EMPTY
18151: LIST
18152: LIST
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: PPUSH
18158: CALL_OW 69
18162: PUSH
18163: LD_INT 4
18165: GREATEREQUAL
18166: AND
18167: PUSH
18168: LD_EXP 15
18172: PUSH
18173: LD_INT 2
18175: EQUAL
18176: AND
18177: IFFALSE 20000
18179: GO 18181
18181: DISABLE
18182: LD_INT 0
18184: PPUSH
18185: PPUSH
18186: PPUSH
18187: PPUSH
18188: PPUSH
18189: PPUSH
18190: PPUSH
18191: PPUSH
// begin missionStage := 3 ;
18192: LD_ADDR_EXP 15
18196: PUSH
18197: LD_INT 3
18199: ST_TO_ADDR
// retreat := false ;
18200: LD_ADDR_VAR 0 4
18204: PUSH
18205: LD_INT 0
18207: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18208: LD_ADDR_VAR 0 5
18212: PUSH
18213: LD_INT 22
18215: PUSH
18216: LD_INT 4
18218: PUSH
18219: EMPTY
18220: LIST
18221: LIST
18222: PUSH
18223: LD_INT 30
18225: PUSH
18226: LD_INT 4
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: PPUSH
18237: CALL_OW 69
18241: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18242: LD_ADDR_VAR 0 6
18246: PUSH
18247: LD_INT 22
18249: PUSH
18250: LD_INT 4
18252: PUSH
18253: EMPTY
18254: LIST
18255: LIST
18256: PUSH
18257: LD_INT 30
18259: PUSH
18260: LD_INT 5
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: PUSH
18267: EMPTY
18268: LIST
18269: LIST
18270: PPUSH
18271: CALL_OW 69
18275: ST_TO_ADDR
// if not bar then
18276: LD_VAR 0 6
18280: NOT
18281: IFFALSE 18334
// begin repeat wait ( 0 0$1 ) ;
18283: LD_INT 35
18285: PPUSH
18286: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18290: LD_INT 22
18292: PUSH
18293: LD_INT 4
18295: PUSH
18296: EMPTY
18297: LIST
18298: LIST
18299: PUSH
18300: LD_INT 3
18302: PUSH
18303: LD_INT 57
18305: PUSH
18306: EMPTY
18307: LIST
18308: PUSH
18309: EMPTY
18310: LIST
18311: LIST
18312: PUSH
18313: LD_INT 30
18315: PUSH
18316: LD_INT 5
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: EMPTY
18324: LIST
18325: LIST
18326: LIST
18327: PPUSH
18328: CALL_OW 69
18332: IFFALSE 18283
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18334: LD_ADDR_VAR 0 6
18338: PUSH
18339: LD_INT 22
18341: PUSH
18342: LD_INT 4
18344: PUSH
18345: EMPTY
18346: LIST
18347: LIST
18348: PUSH
18349: LD_INT 30
18351: PUSH
18352: LD_INT 5
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PUSH
18359: EMPTY
18360: LIST
18361: LIST
18362: PPUSH
18363: CALL_OW 69
18367: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18368: LD_INT 35
18370: PPUSH
18371: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18375: LD_EXP 118
18379: PUSH
18380: LD_INT 4
18382: ARRAY
18383: PUSH
18384: LD_INT 4
18386: GREATEREQUAL
18387: IFFALSE 18368
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18389: LD_ADDR_VAR 0 2
18393: PUSH
18394: LD_INT 22
18396: PUSH
18397: LD_INT 4
18399: PUSH
18400: EMPTY
18401: LIST
18402: LIST
18403: PUSH
18404: LD_INT 2
18406: PUSH
18407: LD_INT 25
18409: PUSH
18410: LD_INT 1
18412: PUSH
18413: EMPTY
18414: LIST
18415: LIST
18416: PUSH
18417: LD_INT 25
18419: PUSH
18420: LD_INT 2
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: PUSH
18427: LD_INT 25
18429: PUSH
18430: LD_INT 3
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PUSH
18437: LD_INT 25
18439: PUSH
18440: LD_INT 4
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 25
18449: PUSH
18450: LD_INT 5
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: EMPTY
18458: LIST
18459: LIST
18460: LIST
18461: LIST
18462: LIST
18463: LIST
18464: PUSH
18465: EMPTY
18466: LIST
18467: LIST
18468: PPUSH
18469: CALL_OW 69
18473: PUSH
18474: LD_EXP 55
18478: PUSH
18479: LD_EXP 56
18483: ADD
18484: DIFF
18485: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18486: LD_ADDR_VAR 0 3
18490: PUSH
18491: LD_VAR 0 2
18495: PPUSH
18496: LD_INT 26
18498: PUSH
18499: LD_INT 1
18501: PUSH
18502: EMPTY
18503: LIST
18504: LIST
18505: PPUSH
18506: CALL_OW 72
18510: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18511: LD_ADDR_VAR 0 2
18515: PUSH
18516: LD_VAR 0 2
18520: PUSH
18521: LD_VAR 0 3
18525: DIFF
18526: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18527: LD_ADDR_VAR 0 2
18531: PUSH
18532: LD_VAR 0 2
18536: PPUSH
18537: LD_INT 1
18539: PPUSH
18540: CALL 105037 0 2
18544: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18545: LD_ADDR_VAR 0 3
18549: PUSH
18550: LD_VAR 0 3
18554: PPUSH
18555: LD_INT 1
18557: PPUSH
18558: CALL 105037 0 2
18562: ST_TO_ADDR
// for i = 1 to 4 do
18563: LD_ADDR_VAR 0 1
18567: PUSH
18568: DOUBLE
18569: LD_INT 1
18571: DEC
18572: ST_TO_ADDR
18573: LD_INT 4
18575: PUSH
18576: FOR_TO
18577: IFFALSE 18743
// begin if tmp2 then
18579: LD_VAR 0 3
18583: IFFALSE 18664
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18585: LD_ADDR_EXP 18
18589: PUSH
18590: LD_EXP 18
18594: PPUSH
18595: LD_INT 1
18597: PPUSH
18598: LD_EXP 18
18602: PUSH
18603: LD_INT 1
18605: ARRAY
18606: PUSH
18607: LD_VAR 0 3
18611: PUSH
18612: LD_VAR 0 3
18616: ARRAY
18617: ADD
18618: PPUSH
18619: CALL_OW 1
18623: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18624: LD_VAR 0 3
18628: PUSH
18629: LD_VAR 0 3
18633: ARRAY
18634: PPUSH
18635: LD_INT 1
18637: PPUSH
18638: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18642: LD_ADDR_VAR 0 3
18646: PUSH
18647: LD_VAR 0 3
18651: PPUSH
18652: LD_VAR 0 3
18656: PPUSH
18657: CALL_OW 3
18661: ST_TO_ADDR
// end else
18662: GO 18741
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18664: LD_ADDR_EXP 18
18668: PUSH
18669: LD_EXP 18
18673: PPUSH
18674: LD_INT 1
18676: PPUSH
18677: LD_EXP 18
18681: PUSH
18682: LD_INT 1
18684: ARRAY
18685: PUSH
18686: LD_VAR 0 2
18690: PUSH
18691: LD_VAR 0 2
18695: ARRAY
18696: ADD
18697: PPUSH
18698: CALL_OW 1
18702: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18703: LD_VAR 0 2
18707: PUSH
18708: LD_VAR 0 2
18712: ARRAY
18713: PPUSH
18714: LD_INT 1
18716: PPUSH
18717: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18721: LD_ADDR_VAR 0 2
18725: PUSH
18726: LD_VAR 0 2
18730: PPUSH
18731: LD_VAR 0 2
18735: PPUSH
18736: CALL_OW 3
18740: ST_TO_ADDR
// end ; end ;
18741: GO 18576
18743: POP
18744: POP
// if tmp2 then
18745: LD_VAR 0 3
18749: IFFALSE 18767
// tmp := tmp union tmp2 ;
18751: LD_ADDR_VAR 0 2
18755: PUSH
18756: LD_VAR 0 2
18760: PUSH
18761: LD_VAR 0 3
18765: UNION
18766: ST_TO_ADDR
// for i = 1 to 4 do
18767: LD_ADDR_VAR 0 1
18771: PUSH
18772: DOUBLE
18773: LD_INT 1
18775: DEC
18776: ST_TO_ADDR
18777: LD_INT 4
18779: PUSH
18780: FOR_TO
18781: IFFALSE 18830
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18783: LD_ADDR_EXP 18
18787: PUSH
18788: LD_EXP 18
18792: PPUSH
18793: LD_INT 2
18795: PPUSH
18796: LD_EXP 18
18800: PUSH
18801: LD_INT 2
18803: ARRAY
18804: PUSH
18805: LD_VAR 0 2
18809: PUSH
18810: LD_VAR 0 2
18814: PUSH
18815: LD_VAR 0 1
18819: MINUS
18820: ARRAY
18821: ADD
18822: PPUSH
18823: CALL_OW 1
18827: ST_TO_ADDR
18828: GO 18780
18830: POP
18831: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18832: LD_ADDR_EXP 99
18836: PUSH
18837: LD_EXP 99
18841: PPUSH
18842: LD_INT 4
18844: PPUSH
18845: LD_EXP 99
18849: PUSH
18850: LD_INT 4
18852: ARRAY
18853: PUSH
18854: LD_EXP 18
18858: PUSH
18859: LD_INT 1
18861: ARRAY
18862: DIFF
18863: PPUSH
18864: CALL_OW 1
18868: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18869: LD_VAR 0 5
18873: PUSH
18874: LD_INT 1
18876: ARRAY
18877: PPUSH
18878: CALL_OW 313
18882: IFFALSE 18937
// begin for i in UnitsInside ( arm [ 1 ] ) do
18884: LD_ADDR_VAR 0 1
18888: PUSH
18889: LD_VAR 0 5
18893: PUSH
18894: LD_INT 1
18896: ARRAY
18897: PPUSH
18898: CALL_OW 313
18902: PUSH
18903: FOR_IN
18904: IFFALSE 18935
// begin ComExitBuilding ( i ) ;
18906: LD_VAR 0 1
18910: PPUSH
18911: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18915: LD_VAR 0 1
18919: PPUSH
18920: LD_VAR 0 6
18924: PUSH
18925: LD_INT 1
18927: ARRAY
18928: PPUSH
18929: CALL_OW 180
// end ;
18933: GO 18903
18935: POP
18936: POP
// end ; wait ( 0 0$3 ) ;
18937: LD_INT 105
18939: PPUSH
18940: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18944: LD_ADDR_VAR 0 1
18948: PUSH
18949: LD_EXP 18
18953: PUSH
18954: LD_INT 1
18956: ARRAY
18957: PUSH
18958: FOR_IN
18959: IFFALSE 19066
// begin if IsInUnit ( i ) then
18961: LD_VAR 0 1
18965: PPUSH
18966: CALL_OW 310
18970: IFFALSE 18981
// ComExitBuilding ( i ) ;
18972: LD_VAR 0 1
18976: PPUSH
18977: CALL_OW 122
// if GetClass ( i ) <> 1 then
18981: LD_VAR 0 1
18985: PPUSH
18986: CALL_OW 257
18990: PUSH
18991: LD_INT 1
18993: NONEQUAL
18994: IFFALSE 19035
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
18996: LD_VAR 0 1
19000: PPUSH
19001: LD_VAR 0 5
19005: PUSH
19006: LD_INT 1
19008: ARRAY
19009: PPUSH
19010: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19014: LD_VAR 0 1
19018: PPUSH
19019: LD_INT 1
19021: PPUSH
19022: CALL_OW 183
// AddComExitBuilding ( i ) ;
19026: LD_VAR 0 1
19030: PPUSH
19031: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19035: LD_VAR 0 1
19039: PPUSH
19040: LD_INT 60
19042: PPUSH
19043: LD_INT 94
19045: PPUSH
19046: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19050: LD_VAR 0 1
19054: PPUSH
19055: LD_EXP 55
19059: PPUSH
19060: CALL_OW 179
// end ;
19064: GO 18958
19066: POP
19067: POP
// wait ( 0 0$15 ) ;
19068: LD_INT 525
19070: PPUSH
19071: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19075: LD_EXP 55
19079: PPUSH
19080: LD_STRING D4-Pow-1
19082: PPUSH
19083: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19087: LD_ADDR_VAR 0 2
19091: PUSH
19092: LD_EXP 18
19096: PUSH
19097: LD_INT 1
19099: ARRAY
19100: PPUSH
19101: LD_INT 26
19103: PUSH
19104: LD_INT 1
19106: PUSH
19107: EMPTY
19108: LIST
19109: LIST
19110: PPUSH
19111: CALL_OW 72
19115: ST_TO_ADDR
// if tmp then
19116: LD_VAR 0 2
19120: IFFALSE 19138
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19122: LD_VAR 0 2
19126: PUSH
19127: LD_INT 1
19129: ARRAY
19130: PPUSH
19131: LD_STRING D4-Sol1-1
19133: PPUSH
19134: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19138: LD_EXP 55
19142: PPUSH
19143: LD_STRING D4-Pow-2
19145: PPUSH
19146: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19150: LD_ADDR_VAR 0 1
19154: PUSH
19155: DOUBLE
19156: LD_INT 1
19158: DEC
19159: ST_TO_ADDR
19160: LD_EXP 18
19164: PUSH
19165: LD_INT 1
19167: ARRAY
19168: PUSH
19169: FOR_TO
19170: IFFALSE 19263
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19172: LD_EXP 18
19176: PUSH
19177: LD_INT 1
19179: ARRAY
19180: PUSH
19181: LD_VAR 0 1
19185: ARRAY
19186: PPUSH
19187: LD_EXP 118
19191: PUSH
19192: LD_INT 4
19194: ARRAY
19195: PUSH
19196: LD_INT 1
19198: ARRAY
19199: PPUSH
19200: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19204: LD_ADDR_EXP 118
19208: PUSH
19209: LD_EXP 118
19213: PPUSH
19214: LD_INT 4
19216: PPUSH
19217: LD_EXP 118
19221: PUSH
19222: LD_INT 4
19224: ARRAY
19225: PPUSH
19226: LD_INT 1
19228: PPUSH
19229: CALL_OW 3
19233: PPUSH
19234: CALL_OW 1
19238: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19239: LD_INT 8
19241: PPUSH
19242: LD_EXP 18
19246: PUSH
19247: LD_INT 1
19249: ARRAY
19250: PUSH
19251: LD_VAR 0 1
19255: ARRAY
19256: PPUSH
19257: CALL_OW 471
// end ;
19261: GO 19169
19263: POP
19264: POP
// repeat wait ( 0 0$1 ) ;
19265: LD_INT 35
19267: PPUSH
19268: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19272: LD_EXP 18
19276: PUSH
19277: LD_INT 1
19279: ARRAY
19280: PPUSH
19281: LD_INT 55
19283: PUSH
19284: EMPTY
19285: LIST
19286: PPUSH
19287: CALL_OW 72
19291: PUSH
19292: LD_INT 4
19294: GREATEREQUAL
19295: IFFALSE 19265
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19297: LD_EXP 18
19301: PUSH
19302: LD_INT 1
19304: ARRAY
19305: PPUSH
19306: LD_INT 69
19308: PPUSH
19309: LD_INT 94
19311: PPUSH
19312: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19316: LD_EXP 18
19320: PUSH
19321: LD_INT 1
19323: ARRAY
19324: PPUSH
19325: LD_INT 82
19327: PPUSH
19328: LD_INT 83
19330: PPUSH
19331: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19335: LD_EXP 18
19339: PUSH
19340: LD_INT 1
19342: ARRAY
19343: PPUSH
19344: LD_INT 77
19346: PPUSH
19347: LD_INT 69
19349: PPUSH
19350: CALL_OW 174
// repeat wait ( 3 ) ;
19354: LD_INT 3
19356: PPUSH
19357: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19361: LD_ADDR_VAR 0 1
19365: PUSH
19366: LD_EXP 18
19370: PUSH
19371: LD_INT 1
19373: ARRAY
19374: PUSH
19375: FOR_IN
19376: IFFALSE 19512
// begin if GetLives ( i ) < 990 then
19378: LD_VAR 0 1
19382: PPUSH
19383: CALL_OW 256
19387: PUSH
19388: LD_INT 990
19390: LESS
19391: IFFALSE 19405
// SetLives ( i , 1000 ) ;
19393: LD_VAR 0 1
19397: PPUSH
19398: LD_INT 1000
19400: PPUSH
19401: CALL_OW 234
// if not IsInUnit ( i ) then
19405: LD_VAR 0 1
19409: PPUSH
19410: CALL_OW 310
19414: NOT
19415: IFFALSE 19510
// begin if not HasTask ( i ) then
19417: LD_VAR 0 1
19421: PPUSH
19422: CALL_OW 314
19426: NOT
19427: IFFALSE 19444
// ComMoveXY ( i , 64 , 93 ) ;
19429: LD_VAR 0 1
19433: PPUSH
19434: LD_INT 64
19436: PPUSH
19437: LD_INT 93
19439: PPUSH
19440: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19444: LD_VAR 0 4
19448: NOT
19449: PUSH
19450: LD_VAR 0 1
19454: PPUSH
19455: CALL_OW 258
19459: PUSH
19460: LD_INT 1
19462: EQUAL
19463: AND
19464: IFFALSE 19510
// begin retreat := true ;
19466: LD_ADDR_VAR 0 4
19470: PUSH
19471: LD_INT 1
19473: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19474: LD_VAR 0 1
19478: PPUSH
19479: LD_INT 2
19481: PPUSH
19482: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19486: LD_VAR 0 1
19490: PPUSH
19491: LD_STRING D4a-Sol1-1
19493: PPUSH
19494: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19498: LD_EXP 55
19502: PPUSH
19503: LD_STRING D4a-Pow-1
19505: PPUSH
19506: CALL_OW 88
// end ; end ; end ;
19510: GO 19375
19512: POP
19513: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19514: LD_EXP 18
19518: PUSH
19519: LD_INT 1
19521: ARRAY
19522: PPUSH
19523: LD_INT 95
19525: PUSH
19526: LD_INT 9
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: PUSH
19533: LD_INT 3
19535: PUSH
19536: LD_INT 55
19538: PUSH
19539: EMPTY
19540: LIST
19541: PUSH
19542: EMPTY
19543: LIST
19544: LIST
19545: PUSH
19546: EMPTY
19547: LIST
19548: LIST
19549: PPUSH
19550: CALL_OW 72
19554: PUSH
19555: LD_INT 4
19557: GREATEREQUAL
19558: IFFALSE 19354
// for i in powellSquadAttack [ 1 ] do
19560: LD_ADDR_VAR 0 1
19564: PUSH
19565: LD_EXP 18
19569: PUSH
19570: LD_INT 1
19572: ARRAY
19573: PUSH
19574: FOR_IN
19575: IFFALSE 19711
// begin if GetTag ( i ) = 2 then
19577: LD_VAR 0 1
19581: PPUSH
19582: CALL_OW 110
19586: PUSH
19587: LD_INT 2
19589: EQUAL
19590: IFFALSE 19652
// begin ComMoveXY ( i , 60 , 94 ) ;
19592: LD_VAR 0 1
19596: PPUSH
19597: LD_INT 60
19599: PPUSH
19600: LD_INT 94
19602: PPUSH
19603: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19607: LD_VAR 0 1
19611: PPUSH
19612: LD_EXP 55
19616: PPUSH
19617: CALL_OW 179
// wait ( 0 0$3 ) ;
19621: LD_INT 105
19623: PPUSH
19624: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19628: LD_VAR 0 1
19632: PPUSH
19633: LD_STRING D4a-Sol1-2
19635: PPUSH
19636: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19640: LD_EXP 55
19644: PPUSH
19645: LD_STRING D4a-Pow-2
19647: PPUSH
19648: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19652: LD_VAR 0 1
19656: PPUSH
19657: LD_INT 0
19659: PPUSH
19660: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19664: LD_ADDR_EXP 99
19668: PUSH
19669: LD_EXP 99
19673: PPUSH
19674: LD_INT 4
19676: PPUSH
19677: LD_EXP 99
19681: PUSH
19682: LD_INT 4
19684: ARRAY
19685: PUSH
19686: LD_VAR 0 1
19690: UNION
19691: PPUSH
19692: CALL_OW 1
19696: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19697: LD_INT 8
19699: PPUSH
19700: LD_VAR 0 1
19704: PPUSH
19705: CALL_OW 472
// end ;
19709: GO 19574
19711: POP
19712: POP
// wait ( 4 4$00 ) ;
19713: LD_INT 8400
19715: PPUSH
19716: CALL_OW 67
// uc_side := 6 ;
19720: LD_ADDR_OWVAR 20
19724: PUSH
19725: LD_INT 6
19727: ST_TO_ADDR
// uc_nation := 3 ;
19728: LD_ADDR_OWVAR 21
19732: PUSH
19733: LD_INT 3
19735: ST_TO_ADDR
// ru := [ ] ;
19736: LD_ADDR_VAR 0 7
19740: PUSH
19741: EMPTY
19742: ST_TO_ADDR
// for i = 1 to 4 do
19743: LD_ADDR_VAR 0 1
19747: PUSH
19748: DOUBLE
19749: LD_INT 1
19751: DEC
19752: ST_TO_ADDR
19753: LD_INT 4
19755: PUSH
19756: FOR_TO
19757: IFFALSE 19858
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19759: LD_INT 22
19761: PPUSH
19762: LD_INT 1
19764: PPUSH
19765: LD_INT 3
19767: PPUSH
19768: LD_INT 43
19770: PUSH
19771: LD_INT 44
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: PUSH
19778: LD_INT 1
19780: PPUSH
19781: LD_INT 2
19783: PPUSH
19784: CALL_OW 12
19788: ARRAY
19789: PPUSH
19790: LD_INT 89
19792: PPUSH
19793: CALL 70667 0 5
// un := CreateVehicle ;
19797: LD_ADDR_VAR 0 8
19801: PUSH
19802: CALL_OW 45
19806: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19807: LD_VAR 0 8
19811: PPUSH
19812: LD_INT 4
19814: PPUSH
19815: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19819: LD_VAR 0 8
19823: PPUSH
19824: LD_INT 136
19826: PPUSH
19827: LD_INT 90
19829: PPUSH
19830: LD_INT 8
19832: PPUSH
19833: LD_INT 0
19835: PPUSH
19836: CALL_OW 50
// ru := ru ^ un ;
19840: LD_ADDR_VAR 0 7
19844: PUSH
19845: LD_VAR 0 7
19849: PUSH
19850: LD_VAR 0 8
19854: ADD
19855: ST_TO_ADDR
// end ;
19856: GO 19756
19858: POP
19859: POP
// if ru then
19860: LD_VAR 0 7
19864: IFFALSE 19881
// ComAgressiveMove ( ru , 80 , 92 ) ;
19866: LD_VAR 0 7
19870: PPUSH
19871: LD_INT 80
19873: PPUSH
19874: LD_INT 92
19876: PPUSH
19877: CALL_OW 114
// wait ( 8 8$00 ) ;
19881: LD_INT 16800
19883: PPUSH
19884: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19888: LD_INT 4
19890: PPUSH
19891: LD_INT 3
19893: PUSH
19894: LD_INT 1
19896: PUSH
19897: LD_INT 1
19899: PUSH
19900: LD_INT 5
19902: PUSH
19903: EMPTY
19904: LIST
19905: LIST
19906: LIST
19907: LIST
19908: PUSH
19909: LD_INT 4
19911: PUSH
19912: LD_INT 1
19914: PUSH
19915: LD_INT 1
19917: PUSH
19918: LD_INT 6
19920: PUSH
19921: EMPTY
19922: LIST
19923: LIST
19924: LIST
19925: LIST
19926: PUSH
19927: LD_INT 4
19929: PUSH
19930: LD_INT 1
19932: PUSH
19933: LD_INT 1
19935: PUSH
19936: LD_INT 7
19938: PUSH
19939: EMPTY
19940: LIST
19941: LIST
19942: LIST
19943: LIST
19944: PUSH
19945: LD_INT 3
19947: PUSH
19948: LD_INT 1
19950: PUSH
19951: LD_INT 1
19953: PUSH
19954: LD_INT 7
19956: PUSH
19957: EMPTY
19958: LIST
19959: LIST
19960: LIST
19961: LIST
19962: PUSH
19963: LD_INT 3
19965: PUSH
19966: LD_INT 1
19968: PUSH
19969: LD_INT 1
19971: PUSH
19972: LD_INT 5
19974: PUSH
19975: EMPTY
19976: LIST
19977: LIST
19978: LIST
19979: LIST
19980: PUSH
19981: EMPTY
19982: LIST
19983: LIST
19984: LIST
19985: LIST
19986: LIST
19987: PPUSH
19988: CALL 57443 0 2
// missionStage := 4 ;
19992: LD_ADDR_EXP 15
19996: PUSH
19997: LD_INT 4
19999: ST_TO_ADDR
// end ;
20000: PPOPN 8
20002: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20003: LD_EXP 15
20007: PUSH
20008: LD_INT 4
20010: EQUAL
20011: PUSH
20012: LD_INT 22
20014: PUSH
20015: LD_INT 4
20017: PUSH
20018: EMPTY
20019: LIST
20020: LIST
20021: PUSH
20022: LD_INT 21
20024: PUSH
20025: LD_INT 2
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: EMPTY
20033: LIST
20034: LIST
20035: PPUSH
20036: CALL_OW 69
20040: PUSH
20041: LD_INT 5
20043: GREATEREQUAL
20044: AND
20045: IFFALSE 24138
20047: GO 20049
20049: DISABLE
20050: LD_INT 0
20052: PPUSH
20053: PPUSH
20054: PPUSH
20055: PPUSH
20056: PPUSH
20057: PPUSH
20058: PPUSH
20059: PPUSH
20060: PPUSH
20061: PPUSH
20062: PPUSH
20063: PPUSH
20064: PPUSH
// begin missionStage := 5 ;
20065: LD_ADDR_EXP 15
20069: PUSH
20070: LD_INT 5
20072: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20073: LD_ADDR_VAR 0 10
20077: PUSH
20078: LD_INT 22
20080: PUSH
20081: LD_INT 4
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: LD_INT 2
20090: PUSH
20091: LD_INT 30
20093: PUSH
20094: LD_INT 4
20096: PUSH
20097: EMPTY
20098: LIST
20099: LIST
20100: PUSH
20101: LD_INT 30
20103: PUSH
20104: LD_INT 5
20106: PUSH
20107: EMPTY
20108: LIST
20109: LIST
20110: PUSH
20111: EMPTY
20112: LIST
20113: LIST
20114: LIST
20115: PUSH
20116: EMPTY
20117: LIST
20118: LIST
20119: PPUSH
20120: CALL_OW 69
20124: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20125: LD_ADDR_VAR 0 6
20129: PUSH
20130: LD_INT 22
20132: PUSH
20133: LD_INT 4
20135: PUSH
20136: EMPTY
20137: LIST
20138: LIST
20139: PUSH
20140: LD_INT 21
20142: PUSH
20143: LD_INT 1
20145: PUSH
20146: EMPTY
20147: LIST
20148: LIST
20149: PUSH
20150: LD_INT 3
20152: PUSH
20153: LD_INT 25
20155: PUSH
20156: LD_INT 16
20158: PUSH
20159: EMPTY
20160: LIST
20161: LIST
20162: PUSH
20163: EMPTY
20164: LIST
20165: LIST
20166: PUSH
20167: LD_INT 3
20169: PUSH
20170: LD_INT 25
20172: PUSH
20173: LD_INT 12
20175: PUSH
20176: EMPTY
20177: LIST
20178: LIST
20179: PUSH
20180: EMPTY
20181: LIST
20182: LIST
20183: PUSH
20184: EMPTY
20185: LIST
20186: LIST
20187: LIST
20188: LIST
20189: PPUSH
20190: CALL_OW 69
20194: PUSH
20195: LD_EXP 55
20199: DIFF
20200: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20201: LD_ADDR_VAR 0 9
20205: PUSH
20206: LD_INT 22
20208: PUSH
20209: LD_INT 4
20211: PUSH
20212: EMPTY
20213: LIST
20214: LIST
20215: PUSH
20216: LD_INT 30
20218: PUSH
20219: LD_INT 3
20221: PUSH
20222: EMPTY
20223: LIST
20224: LIST
20225: PUSH
20226: EMPTY
20227: LIST
20228: LIST
20229: PPUSH
20230: CALL_OW 69
20234: PUSH
20235: LD_INT 1
20237: ARRAY
20238: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20239: LD_INT 35
20241: PPUSH
20242: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20246: LD_EXP 118
20250: PUSH
20251: LD_INT 4
20253: ARRAY
20254: PUSH
20255: LD_INT 5
20257: GREATEREQUAL
20258: PUSH
20259: LD_EXP 118
20263: PUSH
20264: LD_INT 4
20266: ARRAY
20267: PPUSH
20268: LD_INT 58
20270: PUSH
20271: EMPTY
20272: LIST
20273: PPUSH
20274: CALL_OW 72
20278: PUSH
20279: LD_INT 5
20281: GREATEREQUAL
20282: AND
20283: IFFALSE 20239
// powellAllowRetreat := false ;
20285: LD_ADDR_EXP 19
20289: PUSH
20290: LD_INT 0
20292: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20293: LD_INT 700
20295: PPUSH
20296: CALL_OW 67
// activeAttacks := false ;
20300: LD_ADDR_EXP 16
20304: PUSH
20305: LD_INT 0
20307: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20308: LD_INT 35
20310: PPUSH
20311: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20315: LD_INT 22
20317: PUSH
20318: LD_INT 6
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: PPUSH
20325: CALL_OW 69
20329: PUSH
20330: LD_INT 0
20332: EQUAL
20333: IFFALSE 20308
// tmp := mc_vehicles [ 4 ] ;
20335: LD_ADDR_VAR 0 3
20339: PUSH
20340: LD_EXP 118
20344: PUSH
20345: LD_INT 4
20347: ARRAY
20348: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20349: LD_ADDR_VAR 0 1
20353: PUSH
20354: DOUBLE
20355: LD_INT 1
20357: DEC
20358: ST_TO_ADDR
20359: LD_EXP 18
20363: PUSH
20364: FOR_TO
20365: IFFALSE 20626
// begin for j in powellSquadAttack [ i ] do
20367: LD_ADDR_VAR 0 2
20371: PUSH
20372: LD_EXP 18
20376: PUSH
20377: LD_VAR 0 1
20381: ARRAY
20382: PUSH
20383: FOR_IN
20384: IFFALSE 20622
// begin forces := forces diff j ;
20386: LD_ADDR_VAR 0 6
20390: PUSH
20391: LD_VAR 0 6
20395: PUSH
20396: LD_VAR 0 2
20400: DIFF
20401: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20402: LD_VAR 0 2
20406: PPUSH
20407: LD_INT 1
20409: PPUSH
20410: CALL_OW 109
// wait ( 0 0$2 ) ;
20414: LD_INT 70
20416: PPUSH
20417: CALL_OW 67
// if IsInUnit ( j ) then
20421: LD_VAR 0 2
20425: PPUSH
20426: CALL_OW 310
20430: IFFALSE 20441
// ComExitBuilding ( j ) ;
20432: LD_VAR 0 2
20436: PPUSH
20437: CALL_OW 122
// if GetClass ( j ) <> 1 then
20441: LD_VAR 0 2
20445: PPUSH
20446: CALL_OW 257
20450: PUSH
20451: LD_INT 1
20453: NONEQUAL
20454: IFFALSE 20534
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20456: LD_VAR 0 10
20460: PUSH
20461: LD_INT 1
20463: ARRAY
20464: PPUSH
20465: CALL_OW 313
20469: PUSH
20470: LD_INT 5
20472: GREATEREQUAL
20473: IFFALSE 20495
// AddComEnterUnit ( j , arm [ 2 ] ) else
20475: LD_VAR 0 2
20479: PPUSH
20480: LD_VAR 0 10
20484: PUSH
20485: LD_INT 2
20487: ARRAY
20488: PPUSH
20489: CALL_OW 180
20493: GO 20513
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20495: LD_VAR 0 2
20499: PPUSH
20500: LD_VAR 0 10
20504: PUSH
20505: LD_INT 1
20507: ARRAY
20508: PPUSH
20509: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20513: LD_VAR 0 2
20517: PPUSH
20518: LD_INT 1
20520: PPUSH
20521: CALL_OW 183
// AddComExitBuilding ( j ) ;
20525: LD_VAR 0 2
20529: PPUSH
20530: CALL_OW 182
// end ; if i = 2 then
20534: LD_VAR 0 1
20538: PUSH
20539: LD_INT 2
20541: EQUAL
20542: IFFALSE 20559
// AddComMoveXY ( j , 61 , 93 ) ;
20544: LD_VAR 0 2
20548: PPUSH
20549: LD_INT 61
20551: PPUSH
20552: LD_INT 93
20554: PPUSH
20555: CALL_OW 171
// if i = 1 then
20559: LD_VAR 0 1
20563: PUSH
20564: LD_INT 1
20566: EQUAL
20567: IFFALSE 20620
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20569: LD_VAR 0 2
20573: PPUSH
20574: LD_VAR 0 3
20578: PUSH
20579: LD_INT 1
20581: ARRAY
20582: PPUSH
20583: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20587: LD_ADDR_VAR 0 3
20591: PUSH
20592: LD_VAR 0 3
20596: PPUSH
20597: LD_INT 1
20599: PPUSH
20600: CALL_OW 3
20604: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20605: LD_VAR 0 2
20609: PPUSH
20610: LD_INT 69
20612: PPUSH
20613: LD_INT 94
20615: PPUSH
20616: CALL_OW 171
// end ; end ;
20620: GO 20383
20622: POP
20623: POP
// end ;
20624: GO 20364
20626: POP
20627: POP
// wait ( 0 0$55 ) ;
20628: LD_INT 1925
20630: PPUSH
20631: CALL_OW 67
// MC_Kill ( 4 ) ;
20635: LD_INT 4
20637: PPUSH
20638: CALL 34143 0 1
// tmp := UnitsInside ( fac ) ;
20642: LD_ADDR_VAR 0 3
20646: PUSH
20647: LD_VAR 0 9
20651: PPUSH
20652: CALL_OW 313
20656: ST_TO_ADDR
// if tmp then
20657: LD_VAR 0 3
20661: IFFALSE 20782
// for i in tmp do
20663: LD_ADDR_VAR 0 1
20667: PUSH
20668: LD_VAR 0 3
20672: PUSH
20673: FOR_IN
20674: IFFALSE 20780
// begin ComExitBuilding ( i ) ;
20676: LD_VAR 0 1
20680: PPUSH
20681: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20685: LD_VAR 0 10
20689: PUSH
20690: LD_INT 2
20692: ARRAY
20693: PPUSH
20694: CALL_OW 313
20698: PUSH
20699: LD_INT 6
20701: LESS
20702: IFFALSE 20724
// AddComEnterUnit ( i , arm [ 2 ] ) else
20704: LD_VAR 0 1
20708: PPUSH
20709: LD_VAR 0 10
20713: PUSH
20714: LD_INT 2
20716: ARRAY
20717: PPUSH
20718: CALL_OW 180
20722: GO 20778
// if UnitsInside ( arm [ 1 ] ) < 6 then
20724: LD_VAR 0 10
20728: PUSH
20729: LD_INT 1
20731: ARRAY
20732: PPUSH
20733: CALL_OW 313
20737: PUSH
20738: LD_INT 6
20740: LESS
20741: IFFALSE 20763
// AddComEnterUnit ( i , arm [ 1 ] ) else
20743: LD_VAR 0 1
20747: PPUSH
20748: LD_VAR 0 10
20752: PUSH
20753: LD_INT 1
20755: ARRAY
20756: PPUSH
20757: CALL_OW 180
20761: GO 20778
// AddComMoveXY ( i , 37 , 68 ) ;
20763: LD_VAR 0 1
20767: PPUSH
20768: LD_INT 37
20770: PPUSH
20771: LD_INT 68
20773: PPUSH
20774: CALL_OW 171
// end ;
20778: GO 20673
20780: POP
20781: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20782: LD_ADDR_VAR 0 11
20786: PUSH
20787: LD_VAR 0 6
20791: PPUSH
20792: LD_INT 26
20794: PUSH
20795: LD_INT 1
20797: PUSH
20798: EMPTY
20799: LIST
20800: LIST
20801: PPUSH
20802: CALL_OW 72
20806: PUSH
20807: LD_EXP 56
20811: DIFF
20812: ST_TO_ADDR
// if not speaker then
20813: LD_VAR 0 11
20817: NOT
20818: IFFALSE 20845
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20820: LD_ADDR_VAR 0 11
20824: PUSH
20825: LD_VAR 0 6
20829: PPUSH
20830: LD_INT 26
20832: PUSH
20833: LD_INT 1
20835: PUSH
20836: EMPTY
20837: LIST
20838: LIST
20839: PPUSH
20840: CALL_OW 72
20844: ST_TO_ADDR
// if speaker then
20845: LD_VAR 0 11
20849: IFFALSE 20865
// speaker := speaker [ 1 ] ;
20851: LD_ADDR_VAR 0 11
20855: PUSH
20856: LD_VAR 0 11
20860: PUSH
20861: LD_INT 1
20863: ARRAY
20864: ST_TO_ADDR
// Video ( true ) ;
20865: LD_INT 1
20867: PPUSH
20868: CALL 106384 0 1
// CenterNowOnUnits ( Powell ) ;
20872: LD_EXP 55
20876: PPUSH
20877: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20881: LD_ADDR_VAR 0 3
20885: PUSH
20886: LD_VAR 0 6
20890: PPUSH
20891: LD_INT 3
20893: PUSH
20894: LD_INT 25
20896: PUSH
20897: LD_INT 1
20899: PUSH
20900: EMPTY
20901: LIST
20902: LIST
20903: PUSH
20904: EMPTY
20905: LIST
20906: LIST
20907: PPUSH
20908: CALL_OW 72
20912: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20913: LD_ADDR_VAR 0 12
20917: PUSH
20918: LD_INT 22
20920: PUSH
20921: LD_INT 4
20923: PUSH
20924: EMPTY
20925: LIST
20926: LIST
20927: PUSH
20928: LD_INT 30
20930: PUSH
20931: LD_INT 32
20933: PUSH
20934: EMPTY
20935: LIST
20936: LIST
20937: PUSH
20938: LD_INT 58
20940: PUSH
20941: EMPTY
20942: LIST
20943: PUSH
20944: EMPTY
20945: LIST
20946: LIST
20947: LIST
20948: PPUSH
20949: CALL_OW 69
20953: ST_TO_ADDR
// for i = 1 to 6 do
20954: LD_ADDR_VAR 0 1
20958: PUSH
20959: DOUBLE
20960: LD_INT 1
20962: DEC
20963: ST_TO_ADDR
20964: LD_INT 6
20966: PUSH
20967: FOR_TO
20968: IFFALSE 21109
// begin if IsInUnit ( tmp [ i ] ) then
20970: LD_VAR 0 3
20974: PUSH
20975: LD_VAR 0 1
20979: ARRAY
20980: PPUSH
20981: CALL_OW 310
20985: IFFALSE 21002
// ComExitBuilding ( tmp [ i ] ) ;
20987: LD_VAR 0 3
20991: PUSH
20992: LD_VAR 0 1
20996: ARRAY
20997: PPUSH
20998: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21002: LD_VAR 0 3
21006: PUSH
21007: LD_VAR 0 1
21011: ARRAY
21012: PPUSH
21013: LD_VAR 0 10
21017: PUSH
21018: LD_INT 1
21020: ARRAY
21021: PPUSH
21022: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21026: LD_VAR 0 3
21030: PUSH
21031: LD_VAR 0 1
21035: ARRAY
21036: PPUSH
21037: LD_INT 1
21039: PPUSH
21040: CALL_OW 183
// if emp_towers then
21044: LD_VAR 0 12
21048: IFFALSE 21107
// begin AddComExitBuilding ( tmp [ i ] ) ;
21050: LD_VAR 0 3
21054: PUSH
21055: LD_VAR 0 1
21059: ARRAY
21060: PPUSH
21061: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21065: LD_VAR 0 3
21069: PUSH
21070: LD_VAR 0 1
21074: ARRAY
21075: PPUSH
21076: LD_VAR 0 12
21080: PUSH
21081: LD_INT 1
21083: ARRAY
21084: PPUSH
21085: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21089: LD_ADDR_VAR 0 12
21093: PUSH
21094: LD_VAR 0 12
21098: PPUSH
21099: LD_INT 1
21101: PPUSH
21102: CALL_OW 3
21106: ST_TO_ADDR
// end ; end ;
21107: GO 20967
21109: POP
21110: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21111: LD_ADDR_VAR 0 3
21115: PUSH
21116: LD_EXP 18
21120: PUSH
21121: LD_INT 1
21123: ARRAY
21124: PUSH
21125: LD_EXP 18
21129: PUSH
21130: LD_INT 2
21132: ARRAY
21133: ADD
21134: PPUSH
21135: LD_INT 26
21137: PUSH
21138: LD_INT 1
21140: PUSH
21141: EMPTY
21142: LIST
21143: LIST
21144: PPUSH
21145: CALL_OW 72
21149: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21150: LD_ADDR_VAR 0 1
21154: PUSH
21155: LD_EXP 18
21159: PUSH
21160: LD_INT 2
21162: ARRAY
21163: PUSH
21164: FOR_IN
21165: IFFALSE 21183
// ComTurnUnit ( i , Powell ) ;
21167: LD_VAR 0 1
21171: PPUSH
21172: LD_EXP 55
21176: PPUSH
21177: CALL_OW 119
21181: GO 21164
21183: POP
21184: POP
// Say ( Powell , D5-Pow-1 ) ;
21185: LD_EXP 55
21189: PPUSH
21190: LD_STRING D5-Pow-1
21192: PPUSH
21193: CALL_OW 88
// if tmp then
21197: LD_VAR 0 3
21201: IFFALSE 21219
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21203: LD_VAR 0 3
21207: PUSH
21208: LD_INT 1
21210: ARRAY
21211: PPUSH
21212: LD_STRING D5-Sol2-1
21214: PPUSH
21215: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21219: LD_EXP 55
21223: PPUSH
21224: LD_STRING D5-Pow-2
21226: PPUSH
21227: CALL_OW 88
// if tmp > 1 then
21231: LD_VAR 0 3
21235: PUSH
21236: LD_INT 1
21238: GREATER
21239: IFFALSE 21257
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21241: LD_VAR 0 3
21245: PUSH
21246: LD_INT 2
21248: ARRAY
21249: PPUSH
21250: LD_STRING D5-Sol2-2
21252: PPUSH
21253: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21257: LD_EXP 55
21261: PPUSH
21262: LD_STRING D5-Pow-3
21264: PPUSH
21265: CALL_OW 88
// wait ( 0 0$1 ) ;
21269: LD_INT 35
21271: PPUSH
21272: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21276: LD_ADDR_VAR 0 3
21280: PUSH
21281: LD_EXP 18
21285: PUSH
21286: LD_INT 1
21288: ARRAY
21289: PUSH
21290: LD_EXP 18
21294: PUSH
21295: LD_INT 2
21297: ARRAY
21298: UNION
21299: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21300: LD_VAR 0 3
21304: PPUSH
21305: LD_INT 80
21307: PPUSH
21308: LD_INT 67
21310: PPUSH
21311: CALL_OW 114
// wait ( 0 0$2 ) ;
21315: LD_INT 70
21317: PPUSH
21318: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21322: LD_INT 79
21324: PPUSH
21325: LD_INT 72
21327: PPUSH
21328: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21332: LD_INT 35
21334: PPUSH
21335: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21339: LD_VAR 0 3
21343: PPUSH
21344: LD_INT 3
21346: PUSH
21347: LD_INT 24
21349: PUSH
21350: LD_INT 1000
21352: PUSH
21353: EMPTY
21354: LIST
21355: LIST
21356: PUSH
21357: EMPTY
21358: LIST
21359: LIST
21360: PPUSH
21361: CALL_OW 72
21365: IFFALSE 21332
// Say ( Powell , D5a-Pow-1 ) ;
21367: LD_EXP 55
21371: PPUSH
21372: LD_STRING D5a-Pow-1
21374: PPUSH
21375: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21379: LD_EXP 55
21383: PPUSH
21384: LD_STRING D5a-Pow-1a
21386: PPUSH
21387: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21391: LD_INT 10
21393: PPUSH
21394: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21398: LD_EXP 55
21402: PPUSH
21403: LD_STRING D5a-Pow-1b
21405: PPUSH
21406: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21410: LD_EXP 55
21414: PPUSH
21415: LD_STRING D5a-Pow-1c
21417: PPUSH
21418: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21422: LD_EXP 55
21426: PPUSH
21427: LD_STRING D5a-Pow-1d
21429: PPUSH
21430: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21434: LD_INT 35
21436: PPUSH
21437: CALL_OW 67
// if not HasTask ( tmp ) then
21441: LD_VAR 0 3
21445: PPUSH
21446: CALL_OW 314
21450: NOT
21451: IFFALSE 21468
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21453: LD_VAR 0 3
21457: PPUSH
21458: LD_INT 80
21460: PPUSH
21461: LD_INT 67
21463: PPUSH
21464: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21468: LD_VAR 0 3
21472: PPUSH
21473: LD_INT 24
21475: PUSH
21476: LD_INT 1
21478: PUSH
21479: EMPTY
21480: LIST
21481: LIST
21482: PPUSH
21483: CALL_OW 72
21487: NOT
21488: IFFALSE 21434
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21490: LD_ADDR_VAR 0 3
21494: PUSH
21495: LD_INT 22
21497: PUSH
21498: LD_INT 4
21500: PUSH
21501: EMPTY
21502: LIST
21503: LIST
21504: PUSH
21505: LD_INT 92
21507: PUSH
21508: LD_INT 60
21510: PUSH
21511: LD_INT 93
21513: PUSH
21514: LD_INT 10
21516: PUSH
21517: EMPTY
21518: LIST
21519: LIST
21520: LIST
21521: LIST
21522: PUSH
21523: LD_INT 3
21525: PUSH
21526: LD_INT 54
21528: PUSH
21529: EMPTY
21530: LIST
21531: PUSH
21532: EMPTY
21533: LIST
21534: LIST
21535: PUSH
21536: EMPTY
21537: LIST
21538: LIST
21539: LIST
21540: PPUSH
21541: CALL_OW 69
21545: PUSH
21546: LD_EXP 55
21550: DIFF
21551: ST_TO_ADDR
// if tmp then
21552: LD_VAR 0 3
21556: IFFALSE 21590
// for i in tmp do
21558: LD_ADDR_VAR 0 1
21562: PUSH
21563: LD_VAR 0 3
21567: PUSH
21568: FOR_IN
21569: IFFALSE 21588
// ComMoveXY ( i , 36 , 67 ) ;
21571: LD_VAR 0 1
21575: PPUSH
21576: LD_INT 36
21578: PPUSH
21579: LD_INT 67
21581: PPUSH
21582: CALL_OW 111
21586: GO 21568
21588: POP
21589: POP
// wait ( 0 0$3 ) ;
21590: LD_INT 105
21592: PPUSH
21593: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21597: LD_VAR 0 11
21601: PPUSH
21602: LD_STRING D6-Sol3-1
21604: PPUSH
21605: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21609: LD_EXP 55
21613: PPUSH
21614: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21618: LD_EXP 55
21622: PPUSH
21623: LD_STRING D6-Pow-1
21625: PPUSH
21626: CALL_OW 88
// tmp := [ ] ;
21630: LD_ADDR_VAR 0 3
21634: PUSH
21635: EMPTY
21636: ST_TO_ADDR
// for i = 1 to 2 do
21637: LD_ADDR_VAR 0 1
21641: PUSH
21642: DOUBLE
21643: LD_INT 1
21645: DEC
21646: ST_TO_ADDR
21647: LD_INT 2
21649: PUSH
21650: FOR_TO
21651: IFFALSE 21765
// begin uc_side := 8 ;
21653: LD_ADDR_OWVAR 20
21657: PUSH
21658: LD_INT 8
21660: ST_TO_ADDR
// uc_nation := 2 ;
21661: LD_ADDR_OWVAR 21
21665: PUSH
21666: LD_INT 2
21668: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21669: LD_INT 14
21671: PPUSH
21672: LD_INT 3
21674: PPUSH
21675: LD_INT 2
21677: PPUSH
21678: LD_INT 29
21680: PPUSH
21681: LD_INT 100
21683: PPUSH
21684: CALL 70667 0 5
// veh := CreateVehicle ;
21688: LD_ADDR_VAR 0 13
21692: PUSH
21693: CALL_OW 45
21697: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21698: LD_VAR 0 13
21702: PPUSH
21703: LD_INT 4
21705: PPUSH
21706: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21710: LD_VAR 0 13
21714: PPUSH
21715: LD_INT 99
21717: PPUSH
21718: LD_INT 83
21720: PPUSH
21721: LD_INT 6
21723: PPUSH
21724: LD_INT 0
21726: PPUSH
21727: CALL_OW 50
// wait ( 3 ) ;
21731: LD_INT 3
21733: PPUSH
21734: CALL_OW 67
// Connect ( veh ) ;
21738: LD_VAR 0 13
21742: PPUSH
21743: CALL 73722 0 1
// tmp := tmp ^ veh ;
21747: LD_ADDR_VAR 0 3
21751: PUSH
21752: LD_VAR 0 3
21756: PUSH
21757: LD_VAR 0 13
21761: ADD
21762: ST_TO_ADDR
// end ;
21763: GO 21650
21765: POP
21766: POP
// wait ( 0 0$1 ) ;
21767: LD_INT 35
21769: PPUSH
21770: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21774: LD_INT 99
21776: PPUSH
21777: LD_INT 83
21779: PPUSH
21780: LD_INT 1
21782: PPUSH
21783: LD_INT 10
21785: PPUSH
21786: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21790: LD_INT 99
21792: PPUSH
21793: LD_INT 83
21795: PPUSH
21796: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21800: LD_VAR 0 11
21804: PPUSH
21805: LD_STRING D6-Sol3-2
21807: PPUSH
21808: CALL_OW 88
// async ;
21812: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21813: LD_EXP 55
21817: PPUSH
21818: LD_STRING D6-Pow-2
21820: PPUSH
21821: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21825: LD_VAR 0 3
21829: PUSH
21830: LD_INT 1
21832: ARRAY
21833: PPUSH
21834: LD_VAR 0 9
21838: PPUSH
21839: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21843: LD_VAR 0 3
21847: PUSH
21848: LD_INT 2
21850: ARRAY
21851: PPUSH
21852: LD_INT 22
21854: PUSH
21855: LD_INT 4
21857: PUSH
21858: EMPTY
21859: LIST
21860: LIST
21861: PUSH
21862: LD_INT 21
21864: PUSH
21865: LD_INT 3
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PPUSH
21876: CALL_OW 69
21880: PPUSH
21881: LD_VAR 0 3
21885: PUSH
21886: LD_INT 2
21888: ARRAY
21889: PPUSH
21890: CALL_OW 74
21894: PPUSH
21895: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21899: LD_EXP 55
21903: PPUSH
21904: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21908: LD_INT 99
21910: PPUSH
21911: LD_INT 83
21913: PPUSH
21914: LD_INT 1
21916: PPUSH
21917: CALL_OW 331
// repeat wait ( 4 ) ;
21921: LD_INT 4
21923: PPUSH
21924: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21928: LD_VAR 0 3
21932: PUSH
21933: LD_INT 1
21935: ARRAY
21936: PPUSH
21937: CALL_OW 256
21941: PUSH
21942: LD_INT 1000
21944: LESS
21945: IFFALSE 21963
// SetLives ( tmp [ 1 ] , 1000 ) ;
21947: LD_VAR 0 3
21951: PUSH
21952: LD_INT 1
21954: ARRAY
21955: PPUSH
21956: LD_INT 1000
21958: PPUSH
21959: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21963: LD_INT 22
21965: PUSH
21966: LD_INT 4
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: PUSH
21973: LD_INT 30
21975: PUSH
21976: LD_INT 3
21978: PUSH
21979: EMPTY
21980: LIST
21981: LIST
21982: PUSH
21983: EMPTY
21984: LIST
21985: LIST
21986: PPUSH
21987: CALL_OW 69
21991: PUSH
21992: LD_INT 0
21994: EQUAL
21995: IFFALSE 21921
// sync ;
21997: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21998: LD_EXP 55
22002: PPUSH
22003: LD_STRING D6a-Pow-1
22005: PPUSH
22006: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22010: LD_VAR 0 11
22014: PPUSH
22015: LD_STRING D6a-Sol3-1
22017: PPUSH
22018: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22022: LD_EXP 55
22026: PPUSH
22027: LD_STRING D6a-Pow-2
22029: PPUSH
22030: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22034: LD_VAR 0 11
22038: PPUSH
22039: LD_STRING D6a-Sol3-2
22041: PPUSH
22042: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22046: LD_EXP 55
22050: PPUSH
22051: LD_STRING D6a-Pow-3
22053: PPUSH
22054: CALL_OW 88
// powellCenterCameraMode := true ;
22058: LD_ADDR_EXP 20
22062: PUSH
22063: LD_INT 1
22065: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22066: LD_ADDR_VAR 0 1
22070: PUSH
22071: LD_INT 22
22073: PUSH
22074: LD_INT 8
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: PUSH
22081: LD_INT 25
22083: PUSH
22084: LD_INT 2
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: EMPTY
22092: LIST
22093: LIST
22094: PPUSH
22095: CALL_OW 69
22099: PUSH
22100: FOR_IN
22101: IFFALSE 22156
// begin SetTag ( i , 1 ) ;
22103: LD_VAR 0 1
22107: PPUSH
22108: LD_INT 1
22110: PPUSH
22111: CALL_OW 109
// ComExitBuilding ( i ) ;
22115: LD_VAR 0 1
22119: PPUSH
22120: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22124: LD_VAR 0 1
22128: PPUSH
22129: LD_INT 35
22131: PPUSH
22132: LD_INT 6
22134: PPUSH
22135: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22139: LD_VAR 0 1
22143: PPUSH
22144: LD_INT 53
22146: PPUSH
22147: LD_INT 4
22149: PPUSH
22150: CALL_OW 171
// end ;
22154: GO 22100
22156: POP
22157: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22158: LD_ADDR_VAR 0 3
22162: PUSH
22163: LD_INT 22
22165: PUSH
22166: LD_INT 4
22168: PUSH
22169: EMPTY
22170: LIST
22171: LIST
22172: PUSH
22173: LD_INT 21
22175: PUSH
22176: LD_INT 2
22178: PUSH
22179: EMPTY
22180: LIST
22181: LIST
22182: PUSH
22183: LD_INT 3
22185: PUSH
22186: LD_INT 34
22188: PUSH
22189: LD_INT 12
22191: PUSH
22192: EMPTY
22193: LIST
22194: LIST
22195: PUSH
22196: EMPTY
22197: LIST
22198: LIST
22199: PUSH
22200: EMPTY
22201: LIST
22202: LIST
22203: LIST
22204: PPUSH
22205: CALL_OW 69
22209: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22210: LD_EXP 55
22214: PPUSH
22215: LD_VAR 0 3
22219: PPUSH
22220: LD_EXP 55
22224: PPUSH
22225: CALL_OW 74
22229: PPUSH
22230: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22234: LD_EXP 55
22238: PPUSH
22239: LD_INT 100
22241: PPUSH
22242: LD_INT 88
22244: PPUSH
22245: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22249: LD_EXP 55
22253: PPUSH
22254: LD_INT 100
22256: PPUSH
22257: LD_INT 75
22259: PPUSH
22260: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22264: LD_EXP 55
22268: PPUSH
22269: LD_INT 88
22271: PPUSH
22272: LD_INT 53
22274: PPUSH
22275: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22279: LD_INT 8
22281: PPUSH
22282: LD_EXP 55
22286: PPUSH
22287: CALL_OW 471
// repeat wait ( 3 ) ;
22291: LD_INT 3
22293: PPUSH
22294: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22298: LD_INT 22
22300: PUSH
22301: LD_INT 4
22303: PUSH
22304: EMPTY
22305: LIST
22306: LIST
22307: PUSH
22308: LD_INT 92
22310: PUSH
22311: LD_INT 100
22313: PUSH
22314: LD_INT 75
22316: PUSH
22317: LD_INT 6
22319: PUSH
22320: EMPTY
22321: LIST
22322: LIST
22323: LIST
22324: LIST
22325: PUSH
22326: EMPTY
22327: LIST
22328: LIST
22329: PPUSH
22330: CALL_OW 69
22334: IFFALSE 22291
// async ;
22336: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22337: LD_EXP 55
22341: PPUSH
22342: LD_STRING D6b-Pow-1
22344: PPUSH
22345: CALL_OW 88
// repeat wait ( 3 ) ;
22349: LD_INT 3
22351: PPUSH
22352: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22356: LD_EXP 55
22360: PPUSH
22361: CALL_OW 310
22365: PPUSH
22366: CALL_OW 256
22370: PUSH
22371: LD_INT 1000
22373: LESS
22374: IFFALSE 22393
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22376: LD_EXP 55
22380: PPUSH
22381: CALL_OW 310
22385: PPUSH
22386: LD_INT 1000
22388: PPUSH
22389: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22393: LD_EXP 55
22397: PPUSH
22398: CALL_OW 256
22402: PUSH
22403: LD_INT 1000
22405: LESS
22406: IFFALSE 22420
// SetLives ( Powell , 1000 ) ;
22408: LD_EXP 55
22412: PPUSH
22413: LD_INT 1000
22415: PPUSH
22416: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22420: LD_EXP 55
22424: PPUSH
22425: LD_EXP 60
22429: PPUSH
22430: CALL_OW 296
22434: PUSH
22435: LD_INT 5
22437: LESS
22438: PUSH
22439: LD_EXP 55
22443: PPUSH
22444: CALL_OW 310
22448: PPUSH
22449: LD_EXP 60
22453: PPUSH
22454: CALL_OW 296
22458: PUSH
22459: LD_INT 5
22461: LESS
22462: OR
22463: IFFALSE 22482
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22465: LD_EXP 55
22469: PPUSH
22470: CALL_OW 310
22474: PPUSH
22475: LD_INT 100
22477: PPUSH
22478: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22482: LD_EXP 55
22486: PPUSH
22487: CALL_OW 310
22491: NOT
22492: IFFALSE 22349
// game_speed := 4 ;
22494: LD_ADDR_OWVAR 65
22498: PUSH
22499: LD_INT 4
22501: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22502: LD_EXP 55
22506: PPUSH
22507: LD_STRING D6b-Pow-1a
22509: PPUSH
22510: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22514: LD_EXP 55
22518: PPUSH
22519: LD_EXP 60
22523: PPUSH
22524: CALL_OW 180
// sync ;
22528: SYNC
// repeat wait ( 0 0$1 ) ;
22529: LD_INT 35
22531: PPUSH
22532: CALL_OW 67
// until IsInUnit ( Powell ) ;
22536: LD_EXP 55
22540: PPUSH
22541: CALL_OW 310
22545: IFFALSE 22529
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22547: LD_INT 8
22549: PPUSH
22550: LD_EXP 55
22554: PPUSH
22555: CALL_OW 310
22559: PPUSH
22560: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22564: LD_EXP 55
22568: PPUSH
22569: LD_INT 91
22571: PPUSH
22572: LD_INT 44
22574: PPUSH
22575: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22579: LD_EXP 55
22583: PPUSH
22584: LD_INT 96
22586: PPUSH
22587: LD_INT 44
22589: PPUSH
22590: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22594: LD_EXP 55
22598: PPUSH
22599: LD_INT 96
22601: PPUSH
22602: LD_INT 41
22604: PPUSH
22605: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22609: LD_EXP 55
22613: PPUSH
22614: LD_INT 92
22616: PPUSH
22617: LD_INT 39
22619: PPUSH
22620: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22624: LD_EXP 55
22628: PPUSH
22629: LD_INT 88
22631: PPUSH
22632: LD_INT 41
22634: PPUSH
22635: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22639: LD_EXP 55
22643: PPUSH
22644: LD_INT 91
22646: PPUSH
22647: LD_INT 44
22649: PPUSH
22650: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22654: LD_EXP 55
22658: PPUSH
22659: LD_INT 96
22661: PPUSH
22662: LD_INT 44
22664: PPUSH
22665: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22669: LD_EXP 55
22673: PPUSH
22674: LD_INT 96
22676: PPUSH
22677: LD_INT 41
22679: PPUSH
22680: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22684: LD_EXP 55
22688: PPUSH
22689: LD_INT 92
22691: PPUSH
22692: LD_INT 39
22694: PPUSH
22695: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22699: LD_EXP 55
22703: PPUSH
22704: LD_INT 88
22706: PPUSH
22707: LD_INT 41
22709: PPUSH
22710: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22714: LD_EXP 55
22718: PPUSH
22719: LD_INT 91
22721: PPUSH
22722: LD_INT 44
22724: PPUSH
22725: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22729: LD_EXP 55
22733: PPUSH
22734: LD_INT 93
22736: PPUSH
22737: LD_INT 39
22739: PPUSH
22740: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22744: LD_EXP 55
22748: PPUSH
22749: LD_INT 93
22751: PPUSH
22752: LD_INT 36
22754: PPUSH
22755: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22759: LD_INT 122
22761: PPUSH
22762: CALL_OW 67
// game_speed := 4 ;
22766: LD_ADDR_OWVAR 65
22770: PUSH
22771: LD_INT 4
22773: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22774: LD_EXP 55
22778: PPUSH
22779: LD_STRING D6b-Pow-1b
22781: PPUSH
22782: CALL_OW 88
// tmp := [ ] ;
22786: LD_ADDR_VAR 0 3
22790: PUSH
22791: EMPTY
22792: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22793: LD_ADDR_VAR 0 5
22797: PUSH
22798: LD_INT 78
22800: PUSH
22801: LD_INT 47
22803: PUSH
22804: EMPTY
22805: LIST
22806: LIST
22807: PUSH
22808: LD_INT 106
22810: PUSH
22811: LD_INT 53
22813: PUSH
22814: EMPTY
22815: LIST
22816: LIST
22817: PUSH
22818: EMPTY
22819: LIST
22820: LIST
22821: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22822: LD_ADDR_VAR 0 1
22826: PUSH
22827: LD_INT 22
22829: PUSH
22830: LD_INT 8
22832: PUSH
22833: EMPTY
22834: LIST
22835: LIST
22836: PUSH
22837: LD_INT 21
22839: PUSH
22840: LD_INT 3
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PUSH
22847: LD_INT 92
22849: PUSH
22850: LD_INT 90
22852: PUSH
22853: LD_INT 52
22855: PUSH
22856: LD_INT 12
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: LIST
22869: PPUSH
22870: CALL_OW 69
22874: PUSH
22875: FOR_IN
22876: IFFALSE 22901
// tmp := tmp ^ UnitsInside ( i ) ;
22878: LD_ADDR_VAR 0 3
22882: PUSH
22883: LD_VAR 0 3
22887: PUSH
22888: LD_VAR 0 1
22892: PPUSH
22893: CALL_OW 313
22897: ADD
22898: ST_TO_ADDR
22899: GO 22875
22901: POP
22902: POP
// for i in tmp do
22903: LD_ADDR_VAR 0 1
22907: PUSH
22908: LD_VAR 0 3
22912: PUSH
22913: FOR_IN
22914: IFFALSE 23076
// begin dist := 9999 ;
22916: LD_ADDR_VAR 0 8
22920: PUSH
22921: LD_INT 9999
22923: ST_TO_ADDR
// _xy := [ ] ;
22924: LD_ADDR_VAR 0 7
22928: PUSH
22929: EMPTY
22930: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22931: LD_VAR 0 1
22935: PPUSH
22936: LD_INT 1
22938: PPUSH
22939: CALL_OW 109
// ComExitBuilding ( i ) ;
22943: LD_VAR 0 1
22947: PPUSH
22948: CALL_OW 122
// for j in xy do
22952: LD_ADDR_VAR 0 2
22956: PUSH
22957: LD_VAR 0 5
22961: PUSH
22962: FOR_IN
22963: IFFALSE 23045
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22965: LD_VAR 0 1
22969: PPUSH
22970: LD_VAR 0 2
22974: PUSH
22975: LD_INT 1
22977: ARRAY
22978: PPUSH
22979: LD_VAR 0 2
22983: PUSH
22984: LD_INT 2
22986: ARRAY
22987: PPUSH
22988: CALL_OW 297
22992: PUSH
22993: LD_VAR 0 8
22997: LESS
22998: IFFALSE 23043
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23000: LD_ADDR_VAR 0 8
23004: PUSH
23005: LD_VAR 0 1
23009: PPUSH
23010: LD_VAR 0 2
23014: PUSH
23015: LD_INT 1
23017: ARRAY
23018: PPUSH
23019: LD_VAR 0 2
23023: PUSH
23024: LD_INT 2
23026: ARRAY
23027: PPUSH
23028: CALL_OW 297
23032: ST_TO_ADDR
// _xy := j ;
23033: LD_ADDR_VAR 0 7
23037: PUSH
23038: LD_VAR 0 2
23042: ST_TO_ADDR
// end ;
23043: GO 22962
23045: POP
23046: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23047: LD_VAR 0 1
23051: PPUSH
23052: LD_VAR 0 7
23056: PUSH
23057: LD_INT 1
23059: ARRAY
23060: PPUSH
23061: LD_VAR 0 7
23065: PUSH
23066: LD_INT 2
23068: ARRAY
23069: PPUSH
23070: CALL_OW 171
// end ;
23074: GO 22913
23076: POP
23077: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23078: LD_ADDR_VAR 0 4
23082: PUSH
23083: LD_VAR 0 3
23087: PPUSH
23088: LD_INT 26
23090: PUSH
23091: LD_INT 1
23093: PUSH
23094: EMPTY
23095: LIST
23096: LIST
23097: PUSH
23098: LD_INT 25
23100: PUSH
23101: LD_INT 1
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: PUSH
23108: EMPTY
23109: LIST
23110: LIST
23111: PPUSH
23112: CALL_OW 72
23116: ST_TO_ADDR
// if tmp2 < 2 then
23117: LD_VAR 0 4
23121: PUSH
23122: LD_INT 2
23124: LESS
23125: IFFALSE 23194
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23127: LD_ADDR_VAR 0 4
23131: PUSH
23132: LD_INT 22
23134: PUSH
23135: LD_INT 8
23137: PUSH
23138: EMPTY
23139: LIST
23140: LIST
23141: PUSH
23142: LD_INT 26
23144: PUSH
23145: LD_INT 1
23147: PUSH
23148: EMPTY
23149: LIST
23150: LIST
23151: PUSH
23152: LD_INT 3
23154: PUSH
23155: LD_INT 25
23157: PUSH
23158: LD_INT 15
23160: PUSH
23161: EMPTY
23162: LIST
23163: LIST
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: LIST
23173: PPUSH
23174: CALL_OW 69
23178: PUSH
23179: LD_EXP 57
23183: PUSH
23184: LD_EXP 58
23188: PUSH
23189: EMPTY
23190: LIST
23191: LIST
23192: DIFF
23193: ST_TO_ADDR
// if tmp2 then
23194: LD_VAR 0 4
23198: IFFALSE 23216
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23200: LD_VAR 0 4
23204: PUSH
23205: LD_INT 1
23207: ARRAY
23208: PPUSH
23209: LD_STRING D6b-ArSol1-1
23211: PPUSH
23212: CALL_OW 88
// async ;
23216: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23217: LD_EXP 55
23221: PPUSH
23222: LD_STRING D6b-Pow-2
23224: PPUSH
23225: CALL_OW 88
// wait ( 0 0$1 ) ;
23229: LD_INT 35
23231: PPUSH
23232: CALL_OW 67
// if tmp2 > 1 then
23236: LD_VAR 0 4
23240: PUSH
23241: LD_INT 1
23243: GREATER
23244: IFFALSE 23262
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23246: LD_VAR 0 4
23250: PUSH
23251: LD_INT 2
23253: ARRAY
23254: PPUSH
23255: LD_STRING D6b-ArSol2-1
23257: PPUSH
23258: CALL_OW 88
// sync ;
23262: SYNC
// repeat wait ( 5 ) ;
23263: LD_INT 5
23265: PPUSH
23266: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23270: LD_INT 93
23272: PPUSH
23273: LD_INT 36
23275: PPUSH
23276: CALL_OW 428
23280: PPUSH
23281: CALL_OW 255
23285: PUSH
23286: LD_INT 4
23288: EQUAL
23289: IFFALSE 23263
// DialogueOn ;
23291: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23295: LD_INT 10
23297: PPUSH
23298: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23302: LD_EXP 55
23306: PPUSH
23307: LD_STRING D6b-Pow-2a
23309: PPUSH
23310: CALL_OW 88
// DialogueOff ;
23314: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23318: LD_EXP 55
23322: PPUSH
23323: CALL_OW 310
23327: PPUSH
23328: LD_INT 332
23330: PPUSH
23331: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23335: LD_INT 93
23337: PPUSH
23338: LD_INT 35
23340: PPUSH
23341: LD_INT 1
23343: PPUSH
23344: LD_INT 6
23346: NEG
23347: PPUSH
23348: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23352: LD_INT 35
23354: PPUSH
23355: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23359: LD_INT 332
23361: PPUSH
23362: CALL_OW 256
23366: PUSH
23367: LD_INT 1000
23369: LESS
23370: PUSH
23371: LD_INT 332
23373: PPUSH
23374: CALL_OW 300
23378: AND
23379: IFFALSE 23391
// SetLives ( kozlov_fac , 0 ) ;
23381: LD_INT 332
23383: PPUSH
23384: LD_INT 0
23386: PPUSH
23387: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23391: LD_INT 332
23393: PPUSH
23394: CALL_OW 301
23398: PUSH
23399: LD_EXP 55
23403: PPUSH
23404: CALL_OW 301
23408: OR
23409: IFFALSE 23352
// game_speed := 4 ;
23411: LD_ADDR_OWVAR 65
23415: PUSH
23416: LD_INT 4
23418: ST_TO_ADDR
// powellCenterCameraMode := false ;
23419: LD_ADDR_EXP 20
23423: PUSH
23424: LD_INT 0
23426: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23427: LD_ADDR_VAR 0 1
23431: PUSH
23432: LD_VAR 0 3
23436: PUSH
23437: LD_INT 22
23439: PUSH
23440: LD_INT 8
23442: PUSH
23443: EMPTY
23444: LIST
23445: LIST
23446: PUSH
23447: LD_INT 25
23449: PUSH
23450: LD_INT 2
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PUSH
23457: EMPTY
23458: LIST
23459: LIST
23460: PPUSH
23461: CALL_OW 69
23465: UNION
23466: PUSH
23467: FOR_IN
23468: IFFALSE 23484
// SetTag ( i , 0 ) ;
23470: LD_VAR 0 1
23474: PPUSH
23475: LD_INT 0
23477: PPUSH
23478: CALL_OW 109
23482: GO 23467
23484: POP
23485: POP
// wait ( 0 0$3 ) ;
23486: LD_INT 105
23488: PPUSH
23489: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23493: LD_INT 93
23495: PPUSH
23496: LD_INT 35
23498: PPUSH
23499: LD_INT 1
23501: PPUSH
23502: CALL_OW 331
// DialogueOn ;
23506: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23510: LD_VAR 0 11
23514: PPUSH
23515: LD_STRING D6c-Sol3-1
23517: PPUSH
23518: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23522: LD_INT 10
23524: PPUSH
23525: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23529: LD_EXP 36
23533: PPUSH
23534: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23538: LD_EXP 36
23542: PPUSH
23543: LD_STRING D6c-JMM-1
23545: PPUSH
23546: CALL_OW 88
// if Cyrus then
23550: LD_EXP 42
23554: IFFALSE 23568
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23556: LD_EXP 42
23560: PPUSH
23561: LD_STRING D6c-Cyrus-1
23563: PPUSH
23564: CALL_OW 88
// if Bobby then
23568: LD_EXP 41
23572: IFFALSE 23586
// Say ( Bobby , D6c-Bobby-1 ) ;
23574: LD_EXP 41
23578: PPUSH
23579: LD_STRING D6c-Bobby-1
23581: PPUSH
23582: CALL_OW 88
// if Cornel then
23586: LD_EXP 47
23590: IFFALSE 23604
// Say ( Cornel , D6c-Corn-1 ) ;
23592: LD_EXP 47
23596: PPUSH
23597: LD_STRING D6c-Corn-1
23599: PPUSH
23600: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23604: LD_ADDR_VAR 0 4
23608: PUSH
23609: LD_INT 2
23611: PUSH
23612: LD_INT 22
23614: PUSH
23615: LD_INT 1
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PUSH
23622: LD_INT 22
23624: PUSH
23625: LD_INT 4
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: EMPTY
23633: LIST
23634: LIST
23635: LIST
23636: PUSH
23637: LD_INT 26
23639: PUSH
23640: LD_INT 1
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 3
23649: PUSH
23650: LD_INT 25
23652: PUSH
23653: LD_INT 16
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 25
23662: PUSH
23663: LD_INT 12
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: LIST
23674: PUSH
23675: EMPTY
23676: LIST
23677: LIST
23678: LIST
23679: PPUSH
23680: CALL_OW 69
23684: PUSH
23685: LD_VAR 0 11
23689: PUSH
23690: LD_EXP 36
23694: UNION
23695: PUSH
23696: LD_EXP 56
23700: UNION
23701: PUSH
23702: EMPTY
23703: LIST
23704: DIFF
23705: ST_TO_ADDR
// if tmp2 then
23706: LD_VAR 0 4
23710: IFFALSE 23728
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23712: LD_VAR 0 4
23716: PUSH
23717: LD_INT 1
23719: ARRAY
23720: PPUSH
23721: LD_STRING D6c-Sol1-1
23723: PPUSH
23724: CALL_OW 88
// if Lisa then
23728: LD_EXP 39
23732: IFFALSE 23746
// Say ( Lisa , D6c-Lisa-1 ) ;
23734: LD_EXP 39
23738: PPUSH
23739: LD_STRING D6c-Lisa-1
23741: PPUSH
23742: CALL_OW 88
// if Gary then
23746: LD_EXP 48
23750: IFFALSE 23764
// Say ( Gary , D6c-Gary-1 ) ;
23752: LD_EXP 48
23756: PPUSH
23757: LD_STRING D6c-Gary-1
23759: PPUSH
23760: CALL_OW 88
// if Donaldson then
23764: LD_EXP 40
23768: IFFALSE 23782
// Say ( Donaldson , D6c-Don-1 ) ;
23770: LD_EXP 40
23774: PPUSH
23775: LD_STRING D6c-Don-1
23777: PPUSH
23778: CALL_OW 88
// if tmp2 > 1 then
23782: LD_VAR 0 4
23786: PUSH
23787: LD_INT 1
23789: GREATER
23790: IFFALSE 23808
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23792: LD_VAR 0 4
23796: PUSH
23797: LD_INT 2
23799: ARRAY
23800: PPUSH
23801: LD_STRING D6c-Sol2-1
23803: PPUSH
23804: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23808: LD_VAR 0 11
23812: PPUSH
23813: LD_STRING D6c-Sol3-2
23815: PPUSH
23816: CALL_OW 88
// dwait ( 0 0$1 ) ;
23820: LD_INT 35
23822: PPUSH
23823: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23827: LD_EXP 36
23831: PPUSH
23832: LD_STRING D6c-JMM-2
23834: PPUSH
23835: CALL_OW 88
// DialogueOff ;
23839: CALL_OW 7
// Video ( false ) ;
23843: LD_INT 0
23845: PPUSH
23846: CALL 106384 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23850: LD_INT 22
23852: PUSH
23853: LD_INT 4
23855: PUSH
23856: EMPTY
23857: LIST
23858: LIST
23859: PPUSH
23860: CALL_OW 69
23864: PPUSH
23865: LD_INT 1
23867: PPUSH
23868: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23872: LD_INT 4
23874: PPUSH
23875: LD_INT 4
23877: PPUSH
23878: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23882: LD_ADDR_VAR 0 1
23886: PUSH
23887: LD_INT 4
23889: PPUSH
23890: LD_INT 1
23892: PPUSH
23893: LD_INT 2
23895: PPUSH
23896: CALL 63764 0 3
23900: PUSH
23901: FOR_IN
23902: IFFALSE 23939
// if GetTech ( i , 1 ) <> state_researched then
23904: LD_VAR 0 1
23908: PPUSH
23909: LD_INT 1
23911: PPUSH
23912: CALL_OW 321
23916: PUSH
23917: LD_INT 2
23919: NONEQUAL
23920: IFFALSE 23937
// SetTech ( i , 1 , state_researched ) ;
23922: LD_VAR 0 1
23926: PPUSH
23927: LD_INT 1
23929: PPUSH
23930: LD_INT 2
23932: PPUSH
23933: CALL_OW 322
23937: GO 23901
23939: POP
23940: POP
// missionStage := 6 ;
23941: LD_ADDR_EXP 15
23945: PUSH
23946: LD_INT 6
23948: ST_TO_ADDR
// activeAttacks := true ;
23949: LD_ADDR_EXP 16
23953: PUSH
23954: LD_INT 1
23956: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23957: LD_STRING M2
23959: PPUSH
23960: CALL_OW 337
// SaveForQuickRestart ;
23964: CALL_OW 22
// wait ( 0 0$40 ) ;
23968: LD_INT 1400
23970: PPUSH
23971: CALL_OW 67
// DialogueOn ;
23975: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23979: LD_EXP 59
23983: PPUSH
23984: LD_STRING D7-Friend-1
23986: PPUSH
23987: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23991: LD_EXP 36
23995: PPUSH
23996: LD_STRING D7-JMM-1
23998: PPUSH
23999: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24003: LD_EXP 59
24007: PPUSH
24008: LD_STRING D7-Friend-2
24010: PPUSH
24011: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24015: LD_EXP 36
24019: PPUSH
24020: LD_STRING D7-JMM-2
24022: PPUSH
24023: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24027: LD_EXP 59
24031: PPUSH
24032: LD_STRING D7-Friend-3
24034: PPUSH
24035: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24039: LD_EXP 36
24043: PPUSH
24044: LD_STRING D7-JMM-3
24046: PPUSH
24047: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24051: LD_EXP 59
24055: PPUSH
24056: LD_STRING D7-Friend-4
24058: PPUSH
24059: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24063: LD_EXP 36
24067: PPUSH
24068: LD_STRING D7-JMM-4
24070: PPUSH
24071: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24075: LD_EXP 59
24079: PPUSH
24080: LD_STRING D7-Friend-5
24082: PPUSH
24083: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24087: LD_EXP 36
24091: PPUSH
24092: LD_STRING D7-JMM-5
24094: PPUSH
24095: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24099: LD_EXP 59
24103: PPUSH
24104: LD_STRING D7-Friend-6
24106: PPUSH
24107: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24111: LD_EXP 36
24115: PPUSH
24116: LD_STRING D7-JMM-6
24118: PPUSH
24119: CALL_OW 88
// DialogueOff ;
24123: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24127: LD_STRING Mlegion
24129: PPUSH
24130: CALL_OW 337
// RebuildKozlovFactory ;
24134: CALL 4773 0 0
// end ;
24138: PPOPN 13
24140: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24141: LD_EXP 20
24145: PUSH
24146: LD_EXP 55
24150: PPUSH
24151: CALL_OW 300
24155: AND
24156: IFFALSE 24198
24158: GO 24160
24160: DISABLE
// begin enable ;
24161: ENABLE
// if IsInUnit ( Powell ) then
24162: LD_EXP 55
24166: PPUSH
24167: CALL_OW 310
24171: IFFALSE 24189
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24173: LD_EXP 55
24177: PPUSH
24178: CALL_OW 310
24182: PPUSH
24183: CALL_OW 85
24187: GO 24198
// CenterOnUnits ( Powell ) ;
24189: LD_EXP 55
24193: PPUSH
24194: CALL_OW 85
// end ;
24198: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24199: LD_INT 22
24201: PUSH
24202: LD_INT 8
24204: PUSH
24205: EMPTY
24206: LIST
24207: LIST
24208: PUSH
24209: LD_INT 34
24211: PUSH
24212: LD_INT 48
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: PUSH
24219: EMPTY
24220: LIST
24221: LIST
24222: PPUSH
24223: CALL_OW 69
24227: IFFALSE 24490
24229: GO 24231
24231: DISABLE
24232: LD_INT 0
24234: PPUSH
24235: PPUSH
// begin if missionStage < 9 then
24236: LD_EXP 15
24240: PUSH
24241: LD_INT 9
24243: LESS
24244: IFFALSE 24254
// missionStage := 9 ;
24246: LD_ADDR_EXP 15
24250: PUSH
24251: LD_INT 9
24253: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24254: LD_ADDR_VAR 0 1
24258: PUSH
24259: LD_INT 22
24261: PUSH
24262: LD_INT 8
24264: PUSH
24265: EMPTY
24266: LIST
24267: LIST
24268: PUSH
24269: LD_INT 34
24271: PUSH
24272: LD_INT 48
24274: PUSH
24275: EMPTY
24276: LIST
24277: LIST
24278: PUSH
24279: EMPTY
24280: LIST
24281: LIST
24282: PPUSH
24283: CALL_OW 69
24287: PUSH
24288: LD_INT 1
24290: ARRAY
24291: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24292: LD_INT 175
24294: PPUSH
24295: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24299: LD_EXP 12
24303: PUSH
24304: LD_EXP 3
24308: PUSH
24309: LD_INT 0
24311: PUSH
24312: LD_INT 2
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: IN
24319: OR
24320: IFFALSE 24343
// target := [ 68 , 108 , 1 ] else
24322: LD_ADDR_VAR 0 2
24326: PUSH
24327: LD_INT 68
24329: PUSH
24330: LD_INT 108
24332: PUSH
24333: LD_INT 1
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: LIST
24340: ST_TO_ADDR
24341: GO 24362
// target := [ 181 , 88 , 2 ] ;
24343: LD_ADDR_VAR 0 2
24347: PUSH
24348: LD_INT 181
24350: PUSH
24351: LD_INT 88
24353: PUSH
24354: LD_INT 2
24356: PUSH
24357: EMPTY
24358: LIST
24359: LIST
24360: LIST
24361: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24362: LD_VAR 0 1
24366: PPUSH
24367: LD_VAR 0 2
24371: PUSH
24372: LD_INT 1
24374: ARRAY
24375: PPUSH
24376: LD_VAR 0 2
24380: PUSH
24381: LD_INT 2
24383: ARRAY
24384: PPUSH
24385: CALL_OW 176
// if target [ 3 ] = 1 then
24389: LD_VAR 0 2
24393: PUSH
24394: LD_INT 3
24396: ARRAY
24397: PUSH
24398: LD_INT 1
24400: EQUAL
24401: IFFALSE 24417
// SayRadio ( Kurt , D12-Kurt-1 ) else
24403: LD_EXP 57
24407: PPUSH
24408: LD_STRING D12-Kurt-1
24410: PPUSH
24411: CALL_OW 94
24415: GO 24441
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24417: LD_EXP 57
24421: PPUSH
24422: LD_STRING D12a-Kurt-1
24424: PPUSH
24425: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24429: LD_EXP 71
24433: PPUSH
24434: LD_STRING D12a-Roth-1
24436: PPUSH
24437: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24441: LD_INT 350
24443: PPUSH
24444: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24448: LD_VAR 0 1
24452: PPUSH
24453: LD_INT 22
24455: PUSH
24456: LD_INT 8
24458: PUSH
24459: EMPTY
24460: LIST
24461: LIST
24462: PUSH
24463: LD_INT 30
24465: PUSH
24466: LD_INT 3
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: PUSH
24473: EMPTY
24474: LIST
24475: LIST
24476: PPUSH
24477: CALL_OW 69
24481: PUSH
24482: LD_INT 1
24484: ARRAY
24485: PPUSH
24486: CALL_OW 228
// end ;
24490: PPOPN 2
24492: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24493: LD_INT 22
24495: PUSH
24496: LD_INT 8
24498: PUSH
24499: EMPTY
24500: LIST
24501: LIST
24502: PUSH
24503: LD_INT 21
24505: PUSH
24506: LD_INT 1
24508: PUSH
24509: EMPTY
24510: LIST
24511: LIST
24512: PUSH
24513: LD_INT 23
24515: PUSH
24516: LD_INT 2
24518: PUSH
24519: EMPTY
24520: LIST
24521: LIST
24522: PUSH
24523: EMPTY
24524: LIST
24525: LIST
24526: LIST
24527: PPUSH
24528: CALL_OW 69
24532: PUSH
24533: LD_INT 8
24535: PUSH
24536: LD_INT 7
24538: PUSH
24539: LD_INT 6
24541: PUSH
24542: EMPTY
24543: LIST
24544: LIST
24545: LIST
24546: PUSH
24547: LD_OWVAR 67
24551: ARRAY
24552: LESSEQUAL
24553: PUSH
24554: LD_INT 22
24556: PUSH
24557: LD_INT 8
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: PUSH
24564: LD_INT 34
24566: PUSH
24567: LD_INT 48
24569: PUSH
24570: EMPTY
24571: LIST
24572: LIST
24573: PUSH
24574: EMPTY
24575: LIST
24576: LIST
24577: PPUSH
24578: CALL_OW 69
24582: NOT
24583: AND
24584: PUSH
24585: LD_EXP 57
24589: PPUSH
24590: CALL_OW 302
24594: AND
24595: IFFALSE 24912
24597: GO 24599
24599: DISABLE
// begin DialogueOn ;
24600: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24604: LD_EXP 36
24608: PPUSH
24609: LD_STRING D13-JMM-1
24611: PPUSH
24612: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24616: LD_EXP 57
24620: PPUSH
24621: LD_STRING D13-Kurt-1
24623: PPUSH
24624: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24628: LD_EXP 36
24632: PPUSH
24633: LD_STRING D13-JMM-2
24635: PPUSH
24636: CALL_OW 88
// if FakeInfo then
24640: LD_EXP 12
24644: IFFALSE 24664
// begin Say ( Kurt , D13-Kurt-2 ) ;
24646: LD_EXP 57
24650: PPUSH
24651: LD_STRING D13-Kurt-2
24653: PPUSH
24654: CALL_OW 88
// DialogueOff ;
24658: CALL_OW 7
// exit ;
24662: GO 24912
// end ; if not KurtStatus then
24664: LD_EXP 3
24668: NOT
24669: IFFALSE 24685
// Say ( Kurt , D13-Kurt-2b ) else
24671: LD_EXP 57
24675: PPUSH
24676: LD_STRING D13-Kurt-2b
24678: PPUSH
24679: CALL_OW 88
24683: GO 24697
// Say ( Kurt , D13-Kurt-2a ) ;
24685: LD_EXP 57
24689: PPUSH
24690: LD_STRING D13-Kurt-2a
24692: PPUSH
24693: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24697: LD_EXP 57
24701: PPUSH
24702: LD_STRING D13-Kurt-2a
24704: PPUSH
24705: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24709: LD_EXP 36
24713: PPUSH
24714: LD_STRING D13-JMM-3
24716: PPUSH
24717: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24721: LD_EXP 57
24725: PPUSH
24726: LD_STRING D13-Kurt-3
24728: PPUSH
24729: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24733: LD_EXP 36
24737: PPUSH
24738: LD_STRING D13-JMM-4
24740: PPUSH
24741: CALL_OW 88
// DialogueOff ;
24745: CALL_OW 7
// MC_Kill ( 3 ) ;
24749: LD_INT 3
24751: PPUSH
24752: CALL 34143 0 1
// KillUnit ( Kozlov ) ;
24756: LD_EXP 58
24760: PPUSH
24761: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24765: LD_INT 22
24767: PUSH
24768: LD_INT 8
24770: PUSH
24771: EMPTY
24772: LIST
24773: LIST
24774: PUSH
24775: LD_INT 21
24777: PUSH
24778: LD_INT 3
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 23
24787: PUSH
24788: LD_INT 3
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 30
24797: PUSH
24798: LD_INT 3
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: LIST
24809: LIST
24810: PPUSH
24811: CALL_OW 69
24815: PUSH
24816: LD_INT 1
24818: ARRAY
24819: PPUSH
24820: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24824: LD_INT 8
24826: PPUSH
24827: LD_INT 1
24829: PPUSH
24830: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24834: LD_INT 22
24836: PUSH
24837: LD_INT 8
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PPUSH
24844: CALL_OW 69
24848: PPUSH
24849: LD_INT 1
24851: PPUSH
24852: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24856: LD_INT 8
24858: PPUSH
24859: LD_INT 1
24861: PPUSH
24862: LD_INT 1
24864: PPUSH
24865: LD_INT 1
24867: PPUSH
24868: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24872: LD_EXP 59
24876: PPUSH
24877: LD_INT 37
24879: PPUSH
24880: LD_INT 1
24882: PPUSH
24883: LD_INT 0
24885: PPUSH
24886: CALL_OW 48
// wait ( 0 0$1 ) ;
24890: LD_INT 35
24892: PPUSH
24893: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24897: LD_EXP 59
24901: PPUSH
24902: LD_INT 60
24904: PPUSH
24905: LD_INT 95
24907: PPUSH
24908: CALL_OW 111
// end ;
24912: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24913: LD_INT 22
24915: PUSH
24916: LD_INT 8
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: PUSH
24923: LD_INT 21
24925: PUSH
24926: LD_INT 1
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PUSH
24933: EMPTY
24934: LIST
24935: LIST
24936: PPUSH
24937: CALL_OW 69
24941: PUSH
24942: LD_INT 0
24944: EQUAL
24945: IFFALSE 24965
24947: GO 24949
24949: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24950: LD_STRING MlegionOut
24952: PPUSH
24953: CALL_OW 337
// legionDestroyed := true ;
24957: LD_ADDR_EXP 22
24961: PUSH
24962: LD_INT 1
24964: ST_TO_ADDR
// end ;
24965: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24966: LD_INT 1
24968: PPUSH
24969: LD_EXP 59
24973: PPUSH
24974: CALL_OW 292
24978: IFFALSE 25278
24980: GO 24982
24982: DISABLE
24983: LD_INT 0
24985: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24986: LD_EXP 59
24990: PPUSH
24991: CALL_OW 87
// DialogueOn ;
24995: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24999: LD_EXP 36
25003: PPUSH
25004: LD_STRING D14-JMM-1
25006: PPUSH
25007: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25011: LD_EXP 59
25015: PPUSH
25016: LD_STRING D14-Friend-1
25018: PPUSH
25019: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25023: LD_EXP 36
25027: PPUSH
25028: LD_STRING D14-JMM-2
25030: PPUSH
25031: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25035: LD_EXP 59
25039: PPUSH
25040: LD_STRING D14-Friend-2
25042: PPUSH
25043: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25047: LD_EXP 36
25051: PPUSH
25052: LD_STRING D14-JMM-3
25054: PPUSH
25055: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25059: LD_EXP 59
25063: PPUSH
25064: LD_STRING D14-Friend-3
25066: PPUSH
25067: CALL_OW 88
// DialogueOff ;
25071: CALL_OW 7
// dec = Query ( Q14 ) ;
25075: LD_ADDR_VAR 0 1
25079: PUSH
25080: LD_STRING Q14
25082: PPUSH
25083: CALL_OW 97
25087: ST_TO_ADDR
// if dec = 1 then
25088: LD_VAR 0 1
25092: PUSH
25093: LD_INT 1
25095: EQUAL
25096: IFFALSE 25130
// begin DialogueOn ;
25098: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25102: LD_EXP 36
25106: PPUSH
25107: LD_STRING D14a-JMM-1
25109: PPUSH
25110: CALL_OW 88
// DialogueOff ;
25114: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25118: LD_EXP 59
25122: PPUSH
25123: LD_INT 1
25125: PPUSH
25126: CALL_OW 235
// end ; if dec = 2 then
25130: LD_VAR 0 1
25134: PUSH
25135: LD_INT 2
25137: EQUAL
25138: IFFALSE 25184
// begin DialogueOn ;
25140: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25144: LD_EXP 36
25148: PPUSH
25149: LD_STRING D14b-JMM-1
25151: PPUSH
25152: CALL_OW 88
// DialogueOff ;
25156: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25160: LD_EXP 59
25164: PPUSH
25165: LD_INT 9
25167: PPUSH
25168: LD_INT 2
25170: PPUSH
25171: CALL_OW 111
// AddComHold ( Friend ) ;
25175: LD_EXP 59
25179: PPUSH
25180: CALL_OW 200
// end ; if dec = 3 then
25184: LD_VAR 0 1
25188: PUSH
25189: LD_INT 3
25191: EQUAL
25192: IFFALSE 25278
// begin DialogueOn ;
25194: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25198: LD_EXP 36
25202: PPUSH
25203: LD_STRING D14c-JMM-1
25205: PPUSH
25206: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25210: LD_EXP 59
25214: PPUSH
25215: LD_STRING D14c-Friend-1
25217: PPUSH
25218: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25222: LD_EXP 36
25226: PPUSH
25227: LD_STRING D14c-JMM-2
25229: PPUSH
25230: CALL_OW 88
// DialogueOff ;
25234: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25238: LD_INT 8
25240: PPUSH
25241: LD_INT 1
25243: PPUSH
25244: LD_INT 2
25246: PPUSH
25247: LD_INT 1
25249: PPUSH
25250: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25254: LD_EXP 59
25258: PPUSH
25259: LD_INT 9
25261: PPUSH
25262: LD_INT 2
25264: PPUSH
25265: CALL_OW 111
// AddComHold ( Friend ) ;
25269: LD_EXP 59
25273: PPUSH
25274: CALL_OW 200
// end ; end ;
25278: PPOPN 1
25280: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25281: LD_INT 9
25283: PPUSH
25284: LD_INT 2
25286: PPUSH
25287: CALL_OW 428
25291: PUSH
25292: LD_EXP 59
25296: EQUAL
25297: PUSH
25298: LD_EXP 59
25302: PPUSH
25303: CALL_OW 255
25307: PUSH
25308: LD_INT 8
25310: EQUAL
25311: AND
25312: IFFALSE 25326
25314: GO 25316
25316: DISABLE
// RemoveUnit ( Friend ) ;
25317: LD_EXP 59
25321: PPUSH
25322: CALL_OW 64
25326: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25327: LD_EXP 14
25331: PUSH
25332: LD_INT 31500
25334: GREATEREQUAL
25335: PUSH
25336: LD_EXP 7
25340: AND
25341: PUSH
25342: LD_EXP 2
25346: AND
25347: IFFALSE 25777
25349: GO 25351
25351: DISABLE
25352: LD_INT 0
25354: PPUSH
25355: PPUSH
25356: PPUSH
// begin missionStage := 7 ;
25357: LD_ADDR_EXP 15
25361: PUSH
25362: LD_INT 7
25364: ST_TO_ADDR
// uc_side = 1 ;
25365: LD_ADDR_OWVAR 20
25369: PUSH
25370: LD_INT 1
25372: ST_TO_ADDR
// uc_nation = 1 ;
25373: LD_ADDR_OWVAR 21
25377: PUSH
25378: LD_INT 1
25380: ST_TO_ADDR
// for i = 1 to 5 do
25381: LD_ADDR_VAR 0 1
25385: PUSH
25386: DOUBLE
25387: LD_INT 1
25389: DEC
25390: ST_TO_ADDR
25391: LD_INT 5
25393: PUSH
25394: FOR_TO
25395: IFFALSE 25491
// begin vc_engine = 3 ;
25397: LD_ADDR_OWVAR 39
25401: PUSH
25402: LD_INT 3
25404: ST_TO_ADDR
// vc_control = 3 ;
25405: LD_ADDR_OWVAR 38
25409: PUSH
25410: LD_INT 3
25412: ST_TO_ADDR
// vc_chassis = 3 ;
25413: LD_ADDR_OWVAR 37
25417: PUSH
25418: LD_INT 3
25420: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25421: LD_ADDR_OWVAR 40
25425: PUSH
25426: LD_INT 5
25428: PUSH
25429: LD_INT 9
25431: PUSH
25432: LD_INT 7
25434: PUSH
25435: EMPTY
25436: LIST
25437: LIST
25438: LIST
25439: PUSH
25440: LD_INT 1
25442: PPUSH
25443: LD_INT 3
25445: PPUSH
25446: CALL_OW 12
25450: ARRAY
25451: ST_TO_ADDR
// veh = CreateVehicle ;
25452: LD_ADDR_VAR 0 2
25456: PUSH
25457: CALL_OW 45
25461: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25462: LD_VAR 0 2
25466: PPUSH
25467: LD_INT 1
25469: PPUSH
25470: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25474: LD_VAR 0 2
25478: PPUSH
25479: LD_INT 19
25481: PPUSH
25482: LD_INT 0
25484: PPUSH
25485: CALL_OW 49
// end ;
25489: GO 25394
25491: POP
25492: POP
// vc_engine = 3 ;
25493: LD_ADDR_OWVAR 39
25497: PUSH
25498: LD_INT 3
25500: ST_TO_ADDR
// vc_control = 1 ;
25501: LD_ADDR_OWVAR 38
25505: PUSH
25506: LD_INT 1
25508: ST_TO_ADDR
// vc_chassis = 3 ;
25509: LD_ADDR_OWVAR 37
25513: PUSH
25514: LD_INT 3
25516: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25517: LD_ADDR_OWVAR 40
25521: PUSH
25522: LD_INT 5
25524: PUSH
25525: LD_INT 9
25527: PUSH
25528: LD_INT 7
25530: PUSH
25531: EMPTY
25532: LIST
25533: LIST
25534: LIST
25535: PUSH
25536: LD_INT 1
25538: PPUSH
25539: LD_INT 3
25541: PPUSH
25542: CALL_OW 12
25546: ARRAY
25547: ST_TO_ADDR
// vehG = CreateVehicle ;
25548: LD_ADDR_VAR 0 3
25552: PUSH
25553: CALL_OW 45
25557: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25558: LD_VAR 0 3
25562: PPUSH
25563: LD_INT 1
25565: PPUSH
25566: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25570: LD_VAR 0 3
25574: PPUSH
25575: LD_INT 19
25577: PPUSH
25578: LD_INT 0
25580: PPUSH
25581: CALL_OW 49
// if JMMGirl = 1 then
25585: LD_EXP 7
25589: PUSH
25590: LD_INT 1
25592: EQUAL
25593: IFFALSE 25649
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25595: LD_ADDR_EXP 37
25599: PUSH
25600: LD_STRING Joan
25602: PPUSH
25603: LD_INT 1
25605: PPUSH
25606: LD_STRING 14_
25608: PPUSH
25609: CALL 63701 0 3
25613: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25614: LD_EXP 37
25618: PPUSH
25619: LD_VAR 0 3
25623: PPUSH
25624: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25628: LD_VAR 0 3
25632: PPUSH
25633: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25637: LD_EXP 37
25641: PPUSH
25642: LD_STRING D10BW-Joan-1
25644: PPUSH
25645: CALL_OW 94
// end ; if JMMGirl = 2 then
25649: LD_EXP 7
25653: PUSH
25654: LD_INT 2
25656: EQUAL
25657: IFFALSE 25713
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25659: LD_ADDR_EXP 39
25663: PUSH
25664: LD_STRING Lisa
25666: PPUSH
25667: LD_INT 1
25669: PPUSH
25670: LD_STRING 14_
25672: PPUSH
25673: CALL 63701 0 3
25677: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25678: LD_EXP 39
25682: PPUSH
25683: LD_VAR 0 3
25687: PPUSH
25688: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25692: LD_VAR 0 3
25696: PPUSH
25697: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25701: LD_EXP 39
25705: PPUSH
25706: LD_STRING D10BW-Lisa-1
25708: PPUSH
25709: CALL_OW 94
// end ; if JMMGirl = 3 then
25713: LD_EXP 7
25717: PUSH
25718: LD_INT 3
25720: EQUAL
25721: IFFALSE 25777
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25723: LD_ADDR_EXP 51
25727: PUSH
25728: LD_STRING Connie
25730: PPUSH
25731: LD_INT 1
25733: PPUSH
25734: LD_STRING 14_
25736: PPUSH
25737: CALL 63701 0 3
25741: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25742: LD_EXP 51
25746: PPUSH
25747: LD_VAR 0 3
25751: PPUSH
25752: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25756: LD_VAR 0 3
25760: PPUSH
25761: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25765: LD_EXP 39
25769: PPUSH
25770: LD_STRING D10BW-Con-1
25772: PPUSH
25773: CALL_OW 94
// end ; end ;
25777: PPOPN 3
25779: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25780: LD_EXP 14
25784: PUSH
25785: LD_INT 94500
25787: GREATEREQUAL
25788: IFFALSE 26200
25790: GO 25792
25792: DISABLE
25793: LD_INT 0
25795: PPUSH
25796: PPUSH
25797: PPUSH
// begin tmp := PrepareStevensSquad ;
25798: LD_ADDR_VAR 0 3
25802: PUSH
25803: CALL 2147 0 0
25807: ST_TO_ADDR
// if not tmp then
25808: LD_VAR 0 3
25812: NOT
25813: IFFALSE 25817
// exit ;
25815: GO 26200
// uc_side := 1 ;
25817: LD_ADDR_OWVAR 20
25821: PUSH
25822: LD_INT 1
25824: ST_TO_ADDR
// uc_nation := 1 ;
25825: LD_ADDR_OWVAR 21
25829: PUSH
25830: LD_INT 1
25832: ST_TO_ADDR
// for i in tmp do
25833: LD_ADDR_VAR 0 1
25837: PUSH
25838: LD_VAR 0 3
25842: PUSH
25843: FOR_IN
25844: IFFALSE 25941
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25846: LD_INT 3
25848: PPUSH
25849: LD_INT 3
25851: PPUSH
25852: LD_INT 1
25854: PPUSH
25855: LD_INT 5
25857: PUSH
25858: LD_INT 9
25860: PUSH
25861: LD_INT 7
25863: PUSH
25864: EMPTY
25865: LIST
25866: LIST
25867: LIST
25868: PUSH
25869: LD_INT 1
25871: PPUSH
25872: LD_INT 3
25874: PPUSH
25875: CALL_OW 12
25879: ARRAY
25880: PPUSH
25881: LD_INT 40
25883: PPUSH
25884: CALL 70667 0 5
// veh := CreateVehicle ;
25888: LD_ADDR_VAR 0 2
25892: PUSH
25893: CALL_OW 45
25897: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25898: LD_VAR 0 2
25902: PPUSH
25903: LD_INT 1
25905: PPUSH
25906: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25910: LD_VAR 0 2
25914: PPUSH
25915: LD_INT 19
25917: PPUSH
25918: LD_INT 0
25920: PPUSH
25921: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25925: LD_VAR 0 1
25929: PPUSH
25930: LD_VAR 0 2
25934: PPUSH
25935: CALL_OW 52
// end ;
25939: GO 25843
25941: POP
25942: POP
// missionStage := 8 ;
25943: LD_ADDR_EXP 15
25947: PUSH
25948: LD_INT 8
25950: ST_TO_ADDR
// DialogueOn ;
25951: CALL_OW 6
// if Stevens then
25955: LD_EXP 38
25959: IFFALSE 26073
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25961: LD_EXP 38
25965: PPUSH
25966: CALL_OW 310
25970: PPUSH
25971: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25975: LD_EXP 38
25979: PPUSH
25980: LD_STRING D8-Huck-1
25982: PPUSH
25983: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25987: LD_EXP 36
25991: PPUSH
25992: LD_STRING D8-JMM-1
25994: PPUSH
25995: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25999: LD_EXP 38
26003: PPUSH
26004: LD_STRING D8-Huck-2
26006: PPUSH
26007: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26011: LD_EXP 36
26015: PPUSH
26016: LD_STRING D8-JMM-2
26018: PPUSH
26019: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26023: LD_EXP 38
26027: PPUSH
26028: LD_STRING D8-Huck-3
26030: PPUSH
26031: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26035: LD_EXP 36
26039: PPUSH
26040: LD_STRING D8-JMM-3
26042: PPUSH
26043: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26047: LD_EXP 38
26051: PPUSH
26052: LD_STRING D8-Huck-4
26054: PPUSH
26055: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26059: LD_EXP 36
26063: PPUSH
26064: LD_STRING D8-JMM-4
26066: PPUSH
26067: CALL_OW 88
// end else
26071: GO 26183
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26073: LD_EXP 52
26077: PPUSH
26078: CALL_OW 310
26082: PPUSH
26083: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26087: LD_EXP 52
26091: PPUSH
26092: LD_STRING D8-Huck-1
26094: PPUSH
26095: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26099: LD_EXP 36
26103: PPUSH
26104: LD_STRING D8-JMM-1a
26106: PPUSH
26107: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26111: LD_EXP 52
26115: PPUSH
26116: LD_STRING D8-Huck-2
26118: PPUSH
26119: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26123: LD_EXP 36
26127: PPUSH
26128: LD_STRING D8-JMM-2
26130: PPUSH
26131: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26135: LD_EXP 52
26139: PPUSH
26140: LD_STRING D8-Huck-3
26142: PPUSH
26143: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26147: LD_EXP 36
26151: PPUSH
26152: LD_STRING D8-JMM-3
26154: PPUSH
26155: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26159: LD_EXP 52
26163: PPUSH
26164: LD_STRING D8-Huck-4
26166: PPUSH
26167: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26171: LD_EXP 36
26175: PPUSH
26176: LD_STRING D8-JMM-4
26178: PPUSH
26179: CALL_OW 88
// end ; DialogueOff ;
26183: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26187: LD_INT 25
26189: PPUSH
26190: LD_INT 1
26192: PPUSH
26193: LD_INT 1
26195: PPUSH
26196: CALL_OW 322
// end ;
26200: PPOPN 3
26202: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26203: LD_INT 1
26205: PPUSH
26206: LD_EXP 68
26210: PPUSH
26211: CALL_OW 292
26215: IFFALSE 26466
26217: GO 26219
26219: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26220: LD_EXP 68
26224: PPUSH
26225: CALL_OW 87
// DialogueOn ;
26229: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26233: LD_EXP 36
26237: PPUSH
26238: LD_STRING D10nB-JMM-1
26240: PPUSH
26241: CALL_OW 88
// if BurlakStatus = 1 then
26245: LD_EXP 9
26249: PUSH
26250: LD_INT 1
26252: EQUAL
26253: IFFALSE 26267
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26255: LD_EXP 67
26259: PPUSH
26260: LD_STRING D10nB-Vse-1a
26262: PPUSH
26263: CALL_OW 94
// end ; if BurlakStatus = 0 then
26267: LD_EXP 9
26271: PUSH
26272: LD_INT 0
26274: EQUAL
26275: IFFALSE 26289
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26277: LD_EXP 67
26281: PPUSH
26282: LD_STRING D10nB-Vse-1
26284: PPUSH
26285: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26289: LD_EXP 36
26293: PPUSH
26294: LD_STRING D10nB-JMM-2
26296: PPUSH
26297: CALL_OW 88
// if KappaStatus then
26301: LD_EXP 2
26305: IFFALSE 26319
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26307: LD_EXP 67
26311: PPUSH
26312: LD_STRING D10nB-Vse-5a
26314: PPUSH
26315: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26319: LD_EXP 2
26323: NOT
26324: PUSH
26325: LD_EXP 6
26329: PUSH
26330: LD_INT 0
26332: EQUAL
26333: AND
26334: IFFALSE 26462
// begin if JMMGirl = 1 then
26336: LD_EXP 7
26340: PUSH
26341: LD_INT 1
26343: EQUAL
26344: IFFALSE 26394
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26346: LD_EXP 67
26350: PPUSH
26351: LD_STRING D10nB-Vse-2
26353: PPUSH
26354: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26358: LD_EXP 36
26362: PPUSH
26363: LD_STRING D10nB-JMM-3
26365: PPUSH
26366: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26370: LD_EXP 67
26374: PPUSH
26375: LD_STRING D10nB-Vse-3
26377: PPUSH
26378: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26382: LD_EXP 36
26386: PPUSH
26387: LD_STRING D10nB-JMM-4
26389: PPUSH
26390: CALL_OW 88
// end ; if JMMGirl = 2 then
26394: LD_EXP 7
26398: PUSH
26399: LD_INT 2
26401: EQUAL
26402: IFFALSE 26428
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26404: LD_EXP 67
26408: PPUSH
26409: LD_STRING D10nB-Vse-4
26411: PPUSH
26412: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26416: LD_EXP 36
26420: PPUSH
26421: LD_STRING D10nB-JMM-5
26423: PPUSH
26424: CALL_OW 88
// end ; if JMMGirl = 3 then
26428: LD_EXP 7
26432: PUSH
26433: LD_INT 3
26435: EQUAL
26436: IFFALSE 26462
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26438: LD_EXP 67
26442: PPUSH
26443: LD_STRING D10nB-Vse-5
26445: PPUSH
26446: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26450: LD_EXP 36
26454: PPUSH
26455: LD_STRING D10nB-JMM-6
26457: PPUSH
26458: CALL_OW 88
// end ; end ; DialogueOff ;
26462: CALL_OW 7
// end ;
26466: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26467: LD_EXP 14
26471: PUSH
26472: LD_INT 115500
26474: GREATEREQUAL
26475: IFFALSE 26834
26477: GO 26479
26479: DISABLE
26480: LD_INT 0
26482: PPUSH
// begin missionStage := 10 ;
26483: LD_ADDR_EXP 15
26487: PUSH
26488: LD_INT 10
26490: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26491: LD_ADDR_VAR 0 1
26495: PUSH
26496: LD_INT 22
26498: PUSH
26499: LD_INT 1
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PUSH
26506: LD_INT 26
26508: PUSH
26509: LD_INT 1
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 3
26518: PUSH
26519: LD_INT 25
26521: PUSH
26522: LD_INT 12
26524: PUSH
26525: EMPTY
26526: LIST
26527: LIST
26528: PUSH
26529: EMPTY
26530: LIST
26531: LIST
26532: PUSH
26533: LD_INT 3
26535: PUSH
26536: LD_INT 25
26538: PUSH
26539: LD_INT 16
26541: PUSH
26542: EMPTY
26543: LIST
26544: LIST
26545: PUSH
26546: EMPTY
26547: LIST
26548: LIST
26549: PUSH
26550: EMPTY
26551: LIST
26552: LIST
26553: LIST
26554: LIST
26555: PPUSH
26556: CALL_OW 69
26560: PUSH
26561: LD_EXP 36
26565: PUSH
26566: LD_EXP 38
26570: PUSH
26571: LD_EXP 52
26575: PUSH
26576: LD_EXP 39
26580: PUSH
26581: LD_EXP 40
26585: PUSH
26586: LD_EXP 41
26590: PUSH
26591: LD_EXP 42
26595: PUSH
26596: LD_EXP 43
26600: PUSH
26601: LD_EXP 44
26605: PUSH
26606: LD_EXP 45
26610: PUSH
26611: LD_EXP 46
26615: PUSH
26616: LD_EXP 47
26620: PUSH
26621: LD_EXP 48
26625: PUSH
26626: LD_EXP 49
26630: PUSH
26631: LD_EXP 50
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: LIST
26643: LIST
26644: LIST
26645: LIST
26646: LIST
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: LIST
26652: DIFF
26653: ST_TO_ADDR
// if not tmp and Brown then
26654: LD_VAR 0 1
26658: NOT
26659: PUSH
26660: LD_EXP 44
26664: AND
26665: IFFALSE 26680
// tmp := [ Brown ] ;
26667: LD_ADDR_VAR 0 1
26671: PUSH
26672: LD_EXP 44
26676: PUSH
26677: EMPTY
26678: LIST
26679: ST_TO_ADDR
// DialogueOn ;
26680: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26684: LD_VAR 0 1
26688: PUSH
26689: LD_INT 1
26691: ARRAY
26692: PPUSH
26693: LD_STRING D11-Sol1-1
26695: PPUSH
26696: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26700: LD_EXP 61
26704: PPUSH
26705: LD_STRING D11-Pla-1
26707: PPUSH
26708: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26712: LD_EXP 62
26716: PPUSH
26717: LD_STRING D11-Kov-1
26719: PPUSH
26720: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26724: LD_EXP 61
26728: PPUSH
26729: LD_STRING D11-Pla-2
26731: PPUSH
26732: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26736: LD_VAR 0 1
26740: PUSH
26741: LD_INT 1
26743: ARRAY
26744: PPUSH
26745: LD_STRING D11-Sol1-2
26747: PPUSH
26748: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26752: LD_EXP 36
26756: PPUSH
26757: LD_STRING D11-JMM-2
26759: PPUSH
26760: CALL_OW 88
// DialogueOff ;
26764: CALL_OW 7
// allowBehemothConstruct := true ;
26768: LD_ADDR_EXP 25
26772: PUSH
26773: LD_INT 1
26775: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26776: LD_STRING M4
26778: PPUSH
26779: CALL_OW 337
// BuildBehemoths ;
26783: CALL 7577 0 0
// repeat wait ( 15 15$00 ) ;
26787: LD_INT 31500
26789: PPUSH
26790: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26794: LD_EXP 27
26798: IFFALSE 26802
// break ;
26800: GO 26834
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26802: LD_INT 267
26804: PPUSH
26805: CALL_OW 274
26809: PPUSH
26810: LD_INT 1
26812: PPUSH
26813: CALL_OW 275
26817: PUSH
26818: LD_INT 1000
26820: GREATEREQUAL
26821: IFFALSE 26827
// BuildBehemoths ;
26823: CALL 7577 0 0
// until not behemothBuilders ;
26827: LD_EXP 70
26831: NOT
26832: IFFALSE 26787
// end ;
26834: PPOPN 1
26836: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26837: LD_EXP 70
26841: NOT
26842: PUSH
26843: LD_EXP 28
26847: NOT
26848: AND
26849: PUSH
26850: LD_EXP 25
26854: AND
26855: IFFALSE 26875
26857: GO 26859
26859: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26860: LD_STRING M4a
26862: PPUSH
26863: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26867: LD_ADDR_EXP 27
26871: PUSH
26872: LD_INT 1
26874: ST_TO_ADDR
// end ;
26875: END
// every 0 0$1 trigger behemothDone do
26876: LD_EXP 28
26880: IFFALSE 26892
26882: GO 26884
26884: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26885: LD_STRING M4b
26887: PPUSH
26888: CALL_OW 337
26892: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26893: LD_EXP 29
26897: NOT
26898: IFFALSE 27094
26900: GO 26902
26902: DISABLE
26903: LD_INT 0
26905: PPUSH
26906: PPUSH
// begin enable ;
26907: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26908: LD_ADDR_VAR 0 1
26912: PUSH
26913: LD_INT 3
26915: PPUSH
26916: CALL 106460 0 1
26920: ST_TO_ADDR
// if not tmp and not behemothDone then
26921: LD_VAR 0 1
26925: NOT
26926: PUSH
26927: LD_EXP 28
26931: NOT
26932: AND
26933: IFFALSE 26969
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26935: LD_ADDR_VAR 0 1
26939: PUSH
26940: LD_INT 22
26942: PUSH
26943: LD_INT 3
26945: PUSH
26946: EMPTY
26947: LIST
26948: LIST
26949: PUSH
26950: LD_INT 30
26952: PUSH
26953: LD_INT 37
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: EMPTY
26961: LIST
26962: LIST
26963: PPUSH
26964: CALL_OW 69
26968: ST_TO_ADDR
// if not tmp then
26969: LD_VAR 0 1
26973: NOT
26974: IFFALSE 26978
// exit ;
26976: GO 27094
// for i in tmp do
26978: LD_ADDR_VAR 0 2
26982: PUSH
26983: LD_VAR 0 1
26987: PUSH
26988: FOR_IN
26989: IFFALSE 27092
// if See ( 1 , i ) then
26991: LD_INT 1
26993: PPUSH
26994: LD_VAR 0 2
26998: PPUSH
26999: CALL_OW 292
27003: IFFALSE 27090
// begin if GetType ( i ) = unit_building then
27005: LD_VAR 0 2
27009: PPUSH
27010: CALL_OW 247
27014: PUSH
27015: LD_INT 3
27017: EQUAL
27018: IFFALSE 27056
// begin CenterNowOnUnits ( i ) ;
27020: LD_VAR 0 2
27024: PPUSH
27025: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27029: LD_EXP 36
27033: PPUSH
27034: LD_STRING D17a-JMM-1
27036: PPUSH
27037: CALL_OW 88
// seeBehemoth := true ;
27041: LD_ADDR_EXP 29
27045: PUSH
27046: LD_INT 1
27048: ST_TO_ADDR
// disable ;
27049: DISABLE
// exit ;
27050: POP
27051: POP
27052: GO 27094
// end else
27054: GO 27090
// begin CenterNowOnUnits ( i ) ;
27056: LD_VAR 0 2
27060: PPUSH
27061: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27065: LD_EXP 36
27069: PPUSH
27070: LD_STRING D17b-JMM-1
27072: PPUSH
27073: CALL_OW 88
// seeBehemoth := true ;
27077: LD_ADDR_EXP 29
27081: PUSH
27082: LD_INT 1
27084: ST_TO_ADDR
// disable ;
27085: DISABLE
// exit ;
27086: POP
27087: POP
27088: GO 27094
// end ; end ;
27090: GO 26988
27092: POP
27093: POP
// end ;
27094: PPOPN 2
27096: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27097: LD_EXP 14
27101: PUSH
27102: LD_INT 116550
27104: GREATEREQUAL
27105: IFFALSE 28281
27107: GO 27109
27109: DISABLE
27110: LD_INT 0
27112: PPUSH
27113: PPUSH
27114: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27115: LD_INT 2
27117: PPUSH
27118: LD_INT 23
27120: PUSH
27121: LD_INT 3
27123: PUSH
27124: LD_INT 3
27126: PUSH
27127: LD_INT 48
27129: PUSH
27130: EMPTY
27131: LIST
27132: LIST
27133: LIST
27134: LIST
27135: PUSH
27136: EMPTY
27137: LIST
27138: PPUSH
27139: CALL 57491 0 2
// repeat wait ( 0 0$1 ) ;
27143: LD_INT 35
27145: PPUSH
27146: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27150: LD_INT 22
27152: PUSH
27153: LD_INT 3
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: PUSH
27160: LD_INT 34
27162: PUSH
27163: LD_INT 48
27165: PUSH
27166: EMPTY
27167: LIST
27168: LIST
27169: PUSH
27170: EMPTY
27171: LIST
27172: LIST
27173: PPUSH
27174: CALL_OW 69
27178: IFFALSE 27143
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27180: LD_ADDR_VAR 0 1
27184: PUSH
27185: LD_INT 22
27187: PUSH
27188: LD_INT 3
27190: PUSH
27191: EMPTY
27192: LIST
27193: LIST
27194: PUSH
27195: LD_INT 34
27197: PUSH
27198: LD_INT 48
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: EMPTY
27206: LIST
27207: LIST
27208: PPUSH
27209: CALL_OW 69
27213: PUSH
27214: LD_INT 1
27216: ARRAY
27217: ST_TO_ADDR
// missionStage := 12 ;
27218: LD_ADDR_EXP 15
27222: PUSH
27223: LD_INT 12
27225: ST_TO_ADDR
// platonovHasBomb := true ;
27226: LD_ADDR_EXP 30
27230: PUSH
27231: LD_INT 1
27233: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27234: LD_VAR 0 1
27238: PPUSH
27239: LD_INT 181
27241: PPUSH
27242: LD_INT 86
27244: PPUSH
27245: CALL_OW 171
// AddComHold ( bomb ) ;
27249: LD_VAR 0 1
27253: PPUSH
27254: CALL_OW 200
// wait ( 0 0$10 ) ;
27258: LD_INT 350
27260: PPUSH
27261: CALL_OW 67
// DialogueOn ;
27265: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27269: LD_EXP 61
27273: PPUSH
27274: LD_STRING D15-Pla-1
27276: PPUSH
27277: CALL_OW 94
// dec = Query ( Q15a ) ;
27281: LD_ADDR_VAR 0 2
27285: PUSH
27286: LD_STRING Q15a
27288: PPUSH
27289: CALL_OW 97
27293: ST_TO_ADDR
// if dec = 1 then
27294: LD_VAR 0 2
27298: PUSH
27299: LD_INT 1
27301: EQUAL
27302: IFFALSE 27325
// begin Say ( JMM , D15a-JMM-1 ) ;
27304: LD_EXP 36
27308: PPUSH
27309: LD_STRING D15a-JMM-1
27311: PPUSH
27312: CALL_OW 88
// YouLost ( Surrender ) ;
27316: LD_STRING Surrender
27318: PPUSH
27319: CALL_OW 104
// exit ;
27323: GO 28281
// end ; if dec = 2 then
27325: LD_VAR 0 2
27329: PUSH
27330: LD_INT 2
27332: EQUAL
27333: IFFALSE 27402
// begin Say ( JMM , D15b-JMM-1 ) ;
27335: LD_EXP 36
27339: PPUSH
27340: LD_STRING D15b-JMM-1
27342: PPUSH
27343: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27347: LD_EXP 61
27351: PPUSH
27352: LD_STRING D15b-Pla-1
27354: PPUSH
27355: CALL_OW 94
// DialogueOff ;
27359: CALL_OW 7
// wait ( 3 3$00 ) ;
27363: LD_INT 6300
27365: PPUSH
27366: CALL_OW 67
// DialogueOn ;
27370: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27374: LD_EXP 36
27378: PPUSH
27379: LD_STRING D15d-JMM-1a
27381: PPUSH
27382: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27386: LD_EXP 61
27390: PPUSH
27391: LD_STRING D15d-Pla-1
27393: PPUSH
27394: CALL_OW 94
// DialogueOff ;
27398: CALL_OW 7
// end ; if dec = 3 then
27402: LD_VAR 0 2
27406: PUSH
27407: LD_INT 3
27409: EQUAL
27410: IFFALSE 27464
// begin Say ( JMM , D15c-JMM-1 ) ;
27412: LD_EXP 36
27416: PPUSH
27417: LD_STRING D15c-JMM-1
27419: PPUSH
27420: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27424: LD_EXP 61
27428: PPUSH
27429: LD_STRING D15c-Pla-1
27431: PPUSH
27432: CALL_OW 94
// DialogueOff ;
27436: CALL_OW 7
// wait ( 0 0$15 ) ;
27440: LD_INT 525
27442: PPUSH
27443: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27447: LD_VAR 0 1
27451: PPUSH
27452: LD_INT 60
27454: PPUSH
27455: LD_INT 95
27457: PPUSH
27458: CALL_OW 116
// exit ;
27462: GO 28281
// end ; if dec = 4 then
27464: LD_VAR 0 2
27468: PUSH
27469: LD_INT 4
27471: EQUAL
27472: IFFALSE 27502
// begin Say ( JMM , D15d-JMM-1 ) ;
27474: LD_EXP 36
27478: PPUSH
27479: LD_STRING D15d-JMM-1
27481: PPUSH
27482: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27486: LD_EXP 61
27490: PPUSH
27491: LD_STRING D15d-Pla-1
27493: PPUSH
27494: CALL_OW 94
// DialogueOff ;
27498: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27502: LD_EXP 59
27506: PPUSH
27507: CALL_OW 302
27511: PUSH
27512: LD_EXP 59
27516: PPUSH
27517: CALL_OW 255
27521: PUSH
27522: LD_INT 1
27524: EQUAL
27525: AND
27526: PUSH
27527: LD_INT 22
27529: PUSH
27530: LD_INT 1
27532: PUSH
27533: EMPTY
27534: LIST
27535: LIST
27536: PUSH
27537: LD_INT 34
27539: PUSH
27540: LD_INT 8
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: EMPTY
27548: LIST
27549: LIST
27550: PPUSH
27551: CALL_OW 69
27555: NOT
27556: AND
27557: IFFALSE 28182
// begin SetSide ( Friend , 8 ) ;
27559: LD_EXP 59
27563: PPUSH
27564: LD_INT 8
27566: PPUSH
27567: CALL_OW 235
// if IsInUnit ( Friend ) then
27571: LD_EXP 59
27575: PPUSH
27576: CALL_OW 310
27580: IFFALSE 27591
// ComExitBuilding ( Friend ) ;
27582: LD_EXP 59
27586: PPUSH
27587: CALL_OW 122
// if IsDriver ( Friend ) then
27591: LD_EXP 59
27595: PPUSH
27596: CALL 104137 0 1
27600: IFFALSE 27611
// ComExitVehicle ( Friend ) ;
27602: LD_EXP 59
27606: PPUSH
27607: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27611: LD_EXP 59
27615: PPUSH
27616: LD_INT 9
27618: PPUSH
27619: LD_INT 2
27621: PPUSH
27622: CALL_OW 171
// wait ( 0 0$05 ) ;
27626: LD_INT 175
27628: PPUSH
27629: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27633: LD_EXP 59
27637: PPUSH
27638: CALL_OW 87
// DialogueOn ;
27642: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27646: LD_EXP 36
27650: PPUSH
27651: LD_STRING D16-JMM-1
27653: PPUSH
27654: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27658: LD_EXP 59
27662: PPUSH
27663: LD_STRING D16-Friend-1
27665: PPUSH
27666: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27670: LD_EXP 36
27674: PPUSH
27675: LD_STRING D16-JMM-2
27677: PPUSH
27678: CALL_OW 88
// DialogueOff ;
27682: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27686: LD_EXP 59
27690: PPUSH
27691: LD_INT 1
27693: PPUSH
27694: CALL_OW 235
// ComHold ( Friend ) ;
27698: LD_EXP 59
27702: PPUSH
27703: CALL_OW 140
// wait ( 0 0$20 ) ;
27707: LD_INT 700
27709: PPUSH
27710: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27714: LD_EXP 59
27718: PPUSH
27719: LD_INT 9
27721: PPUSH
27722: LD_INT 2
27724: PPUSH
27725: CALL_OW 297
27729: PUSH
27730: LD_INT 30
27732: LESS
27733: IFFALSE 27802
// begin SetSide ( Friend , 8 ) ;
27735: LD_EXP 59
27739: PPUSH
27740: LD_INT 8
27742: PPUSH
27743: CALL_OW 235
// if IsInUnit ( Friend ) then
27747: LD_EXP 59
27751: PPUSH
27752: CALL_OW 310
27756: IFFALSE 27767
// ComExitBuilding ( Friend ) ;
27758: LD_EXP 59
27762: PPUSH
27763: CALL_OW 122
// if IsDriver ( Friend ) then
27767: LD_EXP 59
27771: PPUSH
27772: CALL 104137 0 1
27776: IFFALSE 27787
// ComExitVehicle ( Friend ) ;
27778: LD_EXP 59
27782: PPUSH
27783: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27787: LD_EXP 59
27791: PPUSH
27792: LD_INT 9
27794: PPUSH
27795: LD_INT 2
27797: PPUSH
27798: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27802: LD_INT 1050
27804: PPUSH
27805: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27809: LD_INT 22
27811: PUSH
27812: LD_INT 1
27814: PUSH
27815: EMPTY
27816: LIST
27817: LIST
27818: PUSH
27819: LD_INT 34
27821: PUSH
27822: LD_INT 8
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: PUSH
27829: EMPTY
27830: LIST
27831: LIST
27832: PPUSH
27833: CALL_OW 69
27837: NOT
27838: IFFALSE 28160
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27840: LD_ADDR_VAR 0 3
27844: PUSH
27845: LD_INT 22
27847: PUSH
27848: LD_INT 1
27850: PUSH
27851: EMPTY
27852: LIST
27853: LIST
27854: PUSH
27855: LD_INT 26
27857: PUSH
27858: LD_INT 1
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 3
27867: PUSH
27868: LD_INT 25
27870: PUSH
27871: LD_INT 12
27873: PUSH
27874: EMPTY
27875: LIST
27876: LIST
27877: PUSH
27878: LD_INT 25
27880: PUSH
27881: LD_INT 16
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: LIST
27892: PUSH
27893: EMPTY
27894: LIST
27895: LIST
27896: LIST
27897: PPUSH
27898: CALL_OW 69
27902: PUSH
27903: LD_EXP 36
27907: PUSH
27908: LD_EXP 38
27912: PUSH
27913: LD_EXP 52
27917: PUSH
27918: LD_EXP 39
27922: PUSH
27923: LD_EXP 40
27927: PUSH
27928: LD_EXP 41
27932: PUSH
27933: LD_EXP 42
27937: PUSH
27938: LD_EXP 43
27942: PUSH
27943: LD_EXP 44
27947: PUSH
27948: LD_EXP 45
27952: PUSH
27953: LD_EXP 46
27957: PUSH
27958: LD_EXP 47
27962: PUSH
27963: LD_EXP 48
27967: PUSH
27968: LD_EXP 49
27972: PUSH
27973: LD_EXP 50
27977: PUSH
27978: EMPTY
27979: LIST
27980: LIST
27981: LIST
27982: LIST
27983: LIST
27984: LIST
27985: LIST
27986: LIST
27987: LIST
27988: LIST
27989: LIST
27990: LIST
27991: LIST
27992: LIST
27993: LIST
27994: DIFF
27995: ST_TO_ADDR
// DialogueOn ;
27996: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28000: LD_EXP 61
28004: PPUSH
28005: LD_STRING D16a-Pla-1
28007: PPUSH
28008: CALL_OW 94
// if Stevens then
28012: LD_EXP 38
28016: IFFALSE 28032
// Say ( Stevens , D16a-Huck-1 ) else
28018: LD_EXP 38
28022: PPUSH
28023: LD_STRING D16a-Huck-1
28025: PPUSH
28026: CALL_OW 88
28030: GO 28074
// if Baker then
28032: LD_EXP 52
28036: IFFALSE 28052
// Say ( Baker , D16a-Huck-1 ) else
28038: LD_EXP 52
28042: PPUSH
28043: LD_STRING D16a-Huck-1
28045: PPUSH
28046: CALL_OW 88
28050: GO 28074
// if tmp then
28052: LD_VAR 0 3
28056: IFFALSE 28074
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28058: LD_VAR 0 3
28062: PUSH
28063: LD_INT 1
28065: ARRAY
28066: PPUSH
28067: LD_STRING D16a-Sol1-1
28069: PPUSH
28070: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28074: LD_EXP 59
28078: PPUSH
28079: CALL_OW 255
28083: PUSH
28084: LD_INT 8
28086: EQUAL
28087: IFFALSE 28103
// Say ( JMM , D16a-JMM-1 ) else
28089: LD_EXP 36
28093: PPUSH
28094: LD_STRING D16a-JMM-1
28096: PPUSH
28097: CALL_OW 88
28101: GO 28139
// begin Say ( JMM , D16a-JMM-1a ) ;
28103: LD_EXP 36
28107: PPUSH
28108: LD_STRING D16a-JMM-1a
28110: PPUSH
28111: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28115: LD_EXP 59
28119: PPUSH
28120: LD_STRING D16a-Friend-1
28122: PPUSH
28123: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28127: LD_EXP 59
28131: PPUSH
28132: LD_INT 3
28134: PPUSH
28135: CALL_OW 235
// end ; DialogueOff ;
28139: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28143: LD_VAR 0 1
28147: PPUSH
28148: LD_INT 60
28150: PPUSH
28151: LD_INT 95
28153: PPUSH
28154: CALL_OW 116
// end else
28158: GO 28180
// begin DialogueOn ;
28160: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28164: LD_EXP 61
28168: PPUSH
28169: LD_STRING D16c-Pla-
28171: PPUSH
28172: CALL_OW 94
// DialogueOff ;
28176: CALL_OW 7
// end ; end else
28180: GO 28281
// begin wait ( 3 3$00 ) ;
28182: LD_INT 6300
28184: PPUSH
28185: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28189: LD_INT 22
28191: PUSH
28192: LD_INT 1
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 34
28201: PUSH
28202: LD_INT 8
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PPUSH
28213: CALL_OW 69
28217: NOT
28218: IFFALSE 28261
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28220: LD_EXP 61
28224: PPUSH
28225: LD_STRING D16b-Pla-1
28227: PPUSH
28228: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28232: LD_EXP 36
28236: PPUSH
28237: LD_STRING D16b-JMM-
28239: PPUSH
28240: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28244: LD_VAR 0 1
28248: PPUSH
28249: LD_INT 60
28251: PPUSH
28252: LD_INT 95
28254: PPUSH
28255: CALL_OW 116
// end else
28259: GO 28281
// begin DialogueOn ;
28261: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28265: LD_EXP 61
28269: PPUSH
28270: LD_STRING D16c-Pla-
28272: PPUSH
28273: CALL_OW 94
// DialogueOff ;
28277: CALL_OW 7
// end ; end ; end ;
28281: PPOPN 3
28283: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28284: LD_EXP 14
28288: PUSH
28289: LD_INT 126000
28291: GREATEREQUAL
28292: PUSH
28293: LD_EXP 23
28297: NOT
28298: AND
28299: PUSH
28300: LD_EXP 71
28304: PPUSH
28305: CALL_OW 302
28309: AND
28310: IFFALSE 28668
28312: GO 28314
28314: DISABLE
28315: LD_INT 0
28317: PPUSH
// begin missionStage = 11 ;
28318: LD_ADDR_EXP 15
28322: PUSH
28323: LD_INT 11
28325: ST_TO_ADDR
// DialogueOn ;
28326: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28330: LD_EXP 71
28334: PPUSH
28335: LD_STRING D9-Roth-1
28337: PPUSH
28338: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28342: LD_EXP 36
28346: PPUSH
28347: LD_STRING D9-JMM-1
28349: PPUSH
28350: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28354: LD_EXP 71
28358: PPUSH
28359: LD_STRING D9-Roth-2
28361: PPUSH
28362: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28366: LD_EXP 71
28370: PPUSH
28371: LD_STRING D9-Roth-2a
28373: PPUSH
28374: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28378: LD_EXP 61
28382: PPUSH
28383: LD_STRING D9-Pla-2
28385: PPUSH
28386: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28390: LD_EXP 71
28394: PPUSH
28395: LD_STRING D9-Roth-3
28397: PPUSH
28398: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28402: LD_EXP 61
28406: PPUSH
28407: LD_STRING D9-Pla-3
28409: PPUSH
28410: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28414: LD_EXP 71
28418: PPUSH
28419: LD_STRING D9-Roth-4
28421: PPUSH
28422: CALL_OW 94
// dec = Query ( Q9 ) ;
28426: LD_ADDR_VAR 0 1
28430: PUSH
28431: LD_STRING Q9
28433: PPUSH
28434: CALL_OW 97
28438: ST_TO_ADDR
// if dec = 1 then
28439: LD_VAR 0 1
28443: PUSH
28444: LD_INT 1
28446: EQUAL
28447: IFFALSE 28461
// SayRadio ( Roth , D9a-Roth-1 ) ;
28449: LD_EXP 71
28453: PPUSH
28454: LD_STRING D9a-Roth-1
28456: PPUSH
28457: CALL_OW 94
// if dec = 2 then
28461: LD_VAR 0 1
28465: PUSH
28466: LD_INT 2
28468: EQUAL
28469: IFFALSE 28495
// begin Say ( JMM , D9b-JMM-1 ) ;
28471: LD_EXP 36
28475: PPUSH
28476: LD_STRING D9b-JMM-1
28478: PPUSH
28479: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28483: LD_EXP 71
28487: PPUSH
28488: LD_STRING D9b-Roth-1
28490: PPUSH
28491: CALL_OW 94
// end ; if dec = 3 then
28495: LD_VAR 0 1
28499: PUSH
28500: LD_INT 3
28502: EQUAL
28503: IFFALSE 28565
// begin Say ( JMM , D9c-JMM-1 ) ;
28505: LD_EXP 36
28509: PPUSH
28510: LD_STRING D9c-JMM-1
28512: PPUSH
28513: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28517: LD_EXP 71
28521: PPUSH
28522: LD_STRING D9c-Roth-1
28524: PPUSH
28525: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28529: LD_EXP 36
28533: PPUSH
28534: LD_STRING D9c-JMM-2
28536: PPUSH
28537: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28541: LD_EXP 71
28545: PPUSH
28546: LD_STRING D9c-Roth-2
28548: PPUSH
28549: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28553: LD_EXP 36
28557: PPUSH
28558: LD_STRING D9c-JMM-3
28560: PPUSH
28561: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28565: LD_EXP 71
28569: PPUSH
28570: LD_STRING D9c-Roth-3
28572: PPUSH
28573: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28577: LD_EXP 71
28581: PPUSH
28582: LD_STRING D9cont-Roth-1
28584: PPUSH
28585: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28589: LD_EXP 36
28593: PPUSH
28594: LD_STRING D9cont-JMM-1
28596: PPUSH
28597: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28601: LD_EXP 71
28605: PPUSH
28606: LD_STRING D9cont-Roth-2
28608: PPUSH
28609: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28613: LD_EXP 36
28617: PPUSH
28618: LD_STRING D9cont-JMM-2
28620: PPUSH
28621: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28625: LD_EXP 71
28629: PPUSH
28630: LD_STRING D9cont-Roth-3
28632: PPUSH
28633: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28637: LD_EXP 36
28641: PPUSH
28642: LD_STRING D9cont-JMM-3
28644: PPUSH
28645: CALL_OW 88
// DialogueOff ;
28649: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28653: LD_STRING M3
28655: PPUSH
28656: CALL_OW 337
// allianceActive := true ;
28660: LD_ADDR_EXP 31
28664: PUSH
28665: LD_INT 1
28667: ST_TO_ADDR
// end ;
28668: PPOPN 1
28670: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28671: LD_EXP 61
28675: PPUSH
28676: CALL_OW 301
28680: PUSH
28681: LD_EXP 64
28685: PPUSH
28686: CALL_OW 301
28690: AND
28691: PUSH
28692: LD_INT 22
28694: PUSH
28695: LD_INT 3
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PUSH
28702: LD_INT 21
28704: PUSH
28705: LD_INT 1
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 50
28714: PUSH
28715: EMPTY
28716: LIST
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: LIST
28722: PPUSH
28723: CALL_OW 69
28727: PUSH
28728: LD_INT 7
28730: PUSH
28731: LD_INT 8
28733: PUSH
28734: LD_INT 9
28736: PUSH
28737: EMPTY
28738: LIST
28739: LIST
28740: LIST
28741: PUSH
28742: LD_OWVAR 67
28746: ARRAY
28747: LESS
28748: AND
28749: IFFALSE 29520
28751: GO 28753
28753: DISABLE
28754: LD_INT 0
28756: PPUSH
28757: PPUSH
28758: PPUSH
28759: PPUSH
// begin MC_Kill ( 1 ) ;
28760: LD_INT 1
28762: PPUSH
28763: CALL 34143 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28767: LD_INT 1
28769: PPUSH
28770: LD_INT 3
28772: PPUSH
28773: LD_INT 1
28775: PPUSH
28776: LD_INT 1
28778: PPUSH
28779: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28783: LD_ADDR_VAR 0 1
28787: PUSH
28788: LD_INT 22
28790: PUSH
28791: LD_INT 3
28793: PUSH
28794: EMPTY
28795: LIST
28796: LIST
28797: PUSH
28798: LD_INT 21
28800: PUSH
28801: LD_INT 1
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 24
28810: PUSH
28811: LD_INT 900
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: PUSH
28818: EMPTY
28819: LIST
28820: LIST
28821: LIST
28822: PPUSH
28823: CALL_OW 69
28827: PUSH
28828: FOR_IN
28829: IFFALSE 28860
// if GetSex ( i ) = sex_male then
28831: LD_VAR 0 1
28835: PPUSH
28836: CALL_OW 258
28840: PUSH
28841: LD_INT 1
28843: EQUAL
28844: IFFALSE 28858
// begin tmp = i ;
28846: LD_ADDR_VAR 0 2
28850: PUSH
28851: LD_VAR 0 1
28855: ST_TO_ADDR
// break ;
28856: GO 28860
// end ;
28858: GO 28828
28860: POP
28861: POP
// if tmp = 0 then
28862: LD_VAR 0 2
28866: PUSH
28867: LD_INT 0
28869: EQUAL
28870: IFFALSE 28924
// begin uc_side = 3 ;
28872: LD_ADDR_OWVAR 20
28876: PUSH
28877: LD_INT 3
28879: ST_TO_ADDR
// uc_nation = 3 ;
28880: LD_ADDR_OWVAR 21
28884: PUSH
28885: LD_INT 3
28887: ST_TO_ADDR
// hc_name =  ;
28888: LD_ADDR_OWVAR 26
28892: PUSH
28893: LD_STRING 
28895: ST_TO_ADDR
// hc_gallery =  ;
28896: LD_ADDR_OWVAR 33
28900: PUSH
28901: LD_STRING 
28903: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28904: LD_INT 1
28906: PPUSH
28907: LD_INT 10
28909: PPUSH
28910: CALL_OW 381
// tmp = CreateHuman ;
28914: LD_ADDR_VAR 0 2
28918: PUSH
28919: CALL_OW 44
28923: ST_TO_ADDR
// end ; DialogueOn ;
28924: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28928: LD_VAR 0 2
28932: PPUSH
28933: LD_STRING DSurrenderRussians-RSol1-1a
28935: PPUSH
28936: CALL_OW 88
// DialogueOff ;
28940: CALL_OW 7
// russianDestroyed := true ;
28944: LD_ADDR_EXP 21
28948: PUSH
28949: LD_INT 1
28951: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28952: LD_INT 22
28954: PUSH
28955: LD_INT 3
28957: PUSH
28958: EMPTY
28959: LIST
28960: LIST
28961: PUSH
28962: LD_INT 21
28964: PUSH
28965: LD_INT 1
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: EMPTY
28973: LIST
28974: LIST
28975: PPUSH
28976: CALL_OW 69
28980: PPUSH
28981: CALL_OW 122
// wait ( 0 0$1 ) ;
28985: LD_INT 35
28987: PPUSH
28988: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28992: LD_INT 22
28994: PUSH
28995: LD_INT 3
28997: PUSH
28998: EMPTY
28999: LIST
29000: LIST
29001: PUSH
29002: LD_INT 21
29004: PUSH
29005: LD_INT 1
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: EMPTY
29013: LIST
29014: LIST
29015: PPUSH
29016: CALL_OW 69
29020: PPUSH
29021: LD_INT 25
29023: PPUSH
29024: CALL_OW 173
// wait ( 0 0$10 ) ;
29028: LD_INT 350
29030: PPUSH
29031: CALL_OW 67
// PrepareOmarInvasion ;
29035: CALL 13700 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29039: LD_ADDR_VAR 0 2
29043: PUSH
29044: LD_EXP 89
29048: PPUSH
29049: CALL_OW 250
29053: PUSH
29054: LD_EXP 89
29058: PPUSH
29059: CALL_OW 251
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29068: LD_VAR 0 2
29072: PUSH
29073: LD_INT 1
29075: ARRAY
29076: PPUSH
29077: LD_VAR 0 2
29081: PUSH
29082: LD_INT 2
29084: ARRAY
29085: PPUSH
29086: LD_INT 1
29088: PPUSH
29089: LD_INT 8
29091: NEG
29092: PPUSH
29093: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29097: LD_EXP 89
29101: PPUSH
29102: CALL_OW 87
// DialogueOn ;
29106: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29110: LD_EXP 36
29114: PPUSH
29115: LD_STRING D19-JMM-1
29117: PPUSH
29118: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29122: LD_ADDR_VAR 0 3
29126: PUSH
29127: LD_INT 22
29129: PUSH
29130: LD_INT 1
29132: PUSH
29133: EMPTY
29134: LIST
29135: LIST
29136: PUSH
29137: LD_INT 26
29139: PUSH
29140: LD_INT 1
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: PUSH
29147: LD_INT 2
29149: PUSH
29150: LD_INT 25
29152: PUSH
29153: LD_INT 1
29155: PUSH
29156: EMPTY
29157: LIST
29158: LIST
29159: PUSH
29160: LD_INT 25
29162: PUSH
29163: LD_INT 2
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 25
29172: PUSH
29173: LD_INT 3
29175: PUSH
29176: EMPTY
29177: LIST
29178: LIST
29179: PUSH
29180: LD_INT 25
29182: PUSH
29183: LD_INT 4
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 25
29192: PUSH
29193: LD_INT 5
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PUSH
29200: LD_INT 25
29202: PUSH
29203: LD_INT 8
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: EMPTY
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: LIST
29223: PPUSH
29224: CALL_OW 69
29228: PUSH
29229: LD_EXP 36
29233: PUSH
29234: LD_EXP 37
29238: PUSH
29239: LD_EXP 38
29243: PUSH
29244: LD_EXP 39
29248: PUSH
29249: LD_EXP 40
29253: PUSH
29254: LD_EXP 41
29258: PUSH
29259: LD_EXP 42
29263: PUSH
29264: LD_EXP 43
29268: PUSH
29269: LD_EXP 44
29273: PUSH
29274: LD_EXP 45
29278: PUSH
29279: LD_EXP 46
29283: PUSH
29284: LD_EXP 47
29288: PUSH
29289: LD_EXP 48
29293: PUSH
29294: LD_EXP 49
29298: PUSH
29299: LD_EXP 50
29303: PUSH
29304: LD_EXP 51
29308: PUSH
29309: LD_EXP 52
29313: PUSH
29314: EMPTY
29315: LIST
29316: LIST
29317: LIST
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: LIST
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: LIST
29332: DIFF
29333: ST_TO_ADDR
// if tmp2 then
29334: LD_VAR 0 3
29338: IFFALSE 29356
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29340: LD_VAR 0 3
29344: PUSH
29345: LD_INT 1
29347: ARRAY
29348: PPUSH
29349: LD_STRING D19-Sol1-1
29351: PPUSH
29352: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29356: LD_EXP 36
29360: PPUSH
29361: LD_STRING D19-JMM-2
29363: PPUSH
29364: CALL_OW 88
// DialogueOff ;
29368: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29372: LD_VAR 0 2
29376: PUSH
29377: LD_INT 1
29379: ARRAY
29380: PPUSH
29381: LD_VAR 0 2
29385: PUSH
29386: LD_INT 2
29388: ARRAY
29389: PPUSH
29390: LD_INT 1
29392: PPUSH
29393: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29397: LD_STRING M5
29399: PPUSH
29400: CALL_OW 337
// omarOnMotherLode := false ;
29404: LD_ADDR_VAR 0 4
29408: PUSH
29409: LD_INT 0
29411: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29412: LD_INT 35
29414: PPUSH
29415: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29419: LD_EXP 89
29423: PPUSH
29424: LD_INT 215
29426: PPUSH
29427: LD_INT 100
29429: PPUSH
29430: CALL_OW 297
29434: PUSH
29435: LD_INT 10
29437: LESS
29438: PUSH
29439: LD_VAR 0 4
29443: NOT
29444: AND
29445: IFFALSE 29479
// begin omarOnMotherLode := true ;
29447: LD_ADDR_VAR 0 4
29451: PUSH
29452: LD_INT 1
29454: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29455: LD_EXP 36
29459: PPUSH
29460: LD_STRING D19b-JMM-1
29462: PPUSH
29463: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29467: LD_EXP 89
29471: PPUSH
29472: LD_STRING DOmarContam-Omar-1
29474: PPUSH
29475: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29479: LD_EXP 89
29483: PPUSH
29484: CALL_OW 301
29488: IFFALSE 29412
// Say ( JMM , D19a-JMM-1 ) ;
29490: LD_EXP 36
29494: PPUSH
29495: LD_STRING D19a-JMM-1
29497: PPUSH
29498: CALL_OW 88
// if Heike then
29502: LD_EXP 90
29506: IFFALSE 29520
// Say ( Heike , D19a-Hke-1 ) ;
29508: LD_EXP 90
29512: PPUSH
29513: LD_STRING D19a-Hke-1
29515: PPUSH
29516: CALL_OW 88
// end ;
29520: PPOPN 4
29522: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29523: LD_INT 22
29525: PUSH
29526: LD_INT 3
29528: PUSH
29529: EMPTY
29530: LIST
29531: LIST
29532: PUSH
29533: LD_INT 21
29535: PUSH
29536: LD_INT 1
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: PUSH
29543: EMPTY
29544: LIST
29545: LIST
29546: PPUSH
29547: CALL_OW 69
29551: PUSH
29552: LD_EXP 21
29556: AND
29557: IFFALSE 29625
29559: GO 29561
29561: DISABLE
29562: LD_INT 0
29564: PPUSH
29565: PPUSH
// begin enable ;
29566: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29567: LD_ADDR_VAR 0 2
29571: PUSH
29572: LD_INT 25
29574: PPUSH
29575: LD_INT 22
29577: PUSH
29578: LD_INT 3
29580: PUSH
29581: EMPTY
29582: LIST
29583: LIST
29584: PPUSH
29585: CALL_OW 70
29589: ST_TO_ADDR
// if not tmp then
29590: LD_VAR 0 2
29594: NOT
29595: IFFALSE 29599
// exit ;
29597: GO 29625
// for i in tmp do
29599: LD_ADDR_VAR 0 1
29603: PUSH
29604: LD_VAR 0 2
29608: PUSH
29609: FOR_IN
29610: IFFALSE 29623
// RemoveUnit ( i ) ;
29612: LD_VAR 0 1
29616: PPUSH
29617: CALL_OW 64
29621: GO 29609
29623: POP
29624: POP
// end ;
29625: PPOPN 2
29627: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29628: LD_INT 22
29630: PUSH
29631: LD_INT 7
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 21
29640: PUSH
29641: LD_INT 1
29643: PUSH
29644: EMPTY
29645: LIST
29646: LIST
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PPUSH
29652: CALL_OW 69
29656: PUSH
29657: LD_INT 6
29659: LESS
29660: IFFALSE 30111
29662: GO 29664
29664: DISABLE
29665: LD_INT 0
29667: PPUSH
29668: PPUSH
// begin MC_Kill ( 1 ) ;
29669: LD_INT 1
29671: PPUSH
29672: CALL 34143 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29676: LD_INT 7
29678: PPUSH
29679: LD_INT 1
29681: PPUSH
29682: LD_INT 1
29684: PPUSH
29685: LD_INT 1
29687: PPUSH
29688: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29692: LD_ADDR_VAR 0 1
29696: PUSH
29697: LD_INT 22
29699: PUSH
29700: LD_INT 7
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: LD_INT 26
29709: PUSH
29710: LD_INT 1
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PPUSH
29721: CALL_OW 69
29725: PUSH
29726: LD_EXP 71
29730: DIFF
29731: ST_TO_ADDR
// if tmp then
29732: LD_VAR 0 1
29736: IFFALSE 29754
// tmp := tmp [ 1 ] else
29738: LD_ADDR_VAR 0 1
29742: PUSH
29743: LD_VAR 0 1
29747: PUSH
29748: LD_INT 1
29750: ARRAY
29751: ST_TO_ADDR
29752: GO 29790
// begin uc_side := 7 ;
29754: LD_ADDR_OWVAR 20
29758: PUSH
29759: LD_INT 7
29761: ST_TO_ADDR
// uc_nation := 1 ;
29762: LD_ADDR_OWVAR 21
29766: PUSH
29767: LD_INT 1
29769: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29770: LD_INT 1
29772: PPUSH
29773: LD_INT 8
29775: PPUSH
29776: CALL_OW 384
// tmp := CreateHuman ;
29780: LD_ADDR_VAR 0 1
29784: PUSH
29785: CALL_OW 44
29789: ST_TO_ADDR
// end ; DialogueOn ;
29790: CALL_OW 6
// if IsOK ( Roth ) then
29794: LD_EXP 71
29798: PPUSH
29799: CALL_OW 302
29803: IFFALSE 29817
// Say ( JMM , DAb-JMM-1 ) ;
29805: LD_EXP 36
29809: PPUSH
29810: LD_STRING DAb-JMM-1
29812: PPUSH
29813: CALL_OW 88
// if IsOK ( Roth ) then
29817: LD_EXP 71
29821: PPUSH
29822: CALL_OW 302
29826: IFFALSE 29850
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29828: LD_EXP 71
29832: PPUSH
29833: LD_STRING DSurrenderAlliance-Roth-1
29835: PPUSH
29836: CALL_OW 88
// RothCaptured := true ;
29840: LD_ADDR_EXP 33
29844: PUSH
29845: LD_INT 1
29847: ST_TO_ADDR
// end else
29848: GO 29862
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29850: LD_VAR 0 1
29854: PPUSH
29855: LD_STRING DSurrenderAlliance-Sci1-1
29857: PPUSH
29858: CALL_OW 88
// DialogueOff ;
29862: CALL_OW 7
// allianceDestroyed := true ;
29866: LD_ADDR_EXP 23
29870: PUSH
29871: LD_INT 1
29873: ST_TO_ADDR
// if trueAmericans then
29874: LD_EXP 35
29878: IFFALSE 29954
// begin if trueAmericans = 1 then
29880: LD_EXP 35
29884: PUSH
29885: LD_INT 1
29887: EQUAL
29888: IFFALSE 29904
// Say ( JMM , DAb-JMM-1a ) else
29890: LD_EXP 36
29894: PPUSH
29895: LD_STRING DAb-JMM-1a
29897: PPUSH
29898: CALL_OW 88
29902: GO 29916
// Say ( JMM , DAb-JMM-1b ) ;
29904: LD_EXP 36
29908: PPUSH
29909: LD_STRING DAb-JMM-1b
29911: PPUSH
29912: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29916: LD_EXP 35
29920: PPUSH
29921: CALL_OW 87
// for i in trueAmericans do
29925: LD_ADDR_VAR 0 2
29929: PUSH
29930: LD_EXP 35
29934: PUSH
29935: FOR_IN
29936: IFFALSE 29952
// SetSide ( i , 1 ) ;
29938: LD_VAR 0 2
29942: PPUSH
29943: LD_INT 1
29945: PPUSH
29946: CALL_OW 235
29950: GO 29935
29952: POP
29953: POP
// end ; repeat wait ( 0 0$1 ) ;
29954: LD_INT 35
29956: PPUSH
29957: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29961: LD_ADDR_VAR 0 2
29965: PUSH
29966: LD_INT 22
29968: PUSH
29969: LD_INT 7
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 21
29978: PUSH
29979: LD_INT 1
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: EMPTY
29987: LIST
29988: LIST
29989: PPUSH
29990: CALL_OW 69
29994: PUSH
29995: FOR_IN
29996: IFFALSE 30078
// begin if IsInUnit ( i ) then
29998: LD_VAR 0 2
30002: PPUSH
30003: CALL_OW 310
30007: IFFALSE 30018
// ComExitBuilding ( i ) ;
30009: LD_VAR 0 2
30013: PPUSH
30014: CALL_OW 122
// if IsDriver ( i ) then
30018: LD_VAR 0 2
30022: PPUSH
30023: CALL 104137 0 1
30027: IFFALSE 30038
// ComExitVehicle ( i ) ;
30029: LD_VAR 0 2
30033: PPUSH
30034: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30038: LD_VAR 0 2
30042: PPUSH
30043: LD_INT 26
30045: PPUSH
30046: CALL_OW 308
30050: NOT
30051: IFFALSE 30067
// AddComMoveToArea ( i , allianceEscapeArea ) else
30053: LD_VAR 0 2
30057: PPUSH
30058: LD_INT 26
30060: PPUSH
30061: CALL_OW 173
30065: GO 30076
// RemoveUnit ( i ) ;
30067: LD_VAR 0 2
30071: PPUSH
30072: CALL_OW 64
// end ;
30076: GO 29995
30078: POP
30079: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30080: LD_INT 22
30082: PUSH
30083: LD_INT 7
30085: PUSH
30086: EMPTY
30087: LIST
30088: LIST
30089: PUSH
30090: LD_INT 21
30092: PUSH
30093: LD_INT 1
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PPUSH
30104: CALL_OW 69
30108: NOT
30109: IFFALSE 29954
// end ;
30111: PPOPN 2
30113: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30114: LD_INT 0
30116: PPUSH
30117: PPUSH
// if not unit then
30118: LD_VAR 0 1
30122: NOT
30123: IFFALSE 30127
// exit ;
30125: GO 31625
// DoNotAttack ( 7 , unit ) ;
30127: LD_INT 7
30129: PPUSH
30130: LD_VAR 0 1
30134: PPUSH
30135: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30139: LD_VAR 0 1
30143: PPUSH
30144: LD_INT 260
30146: PPUSH
30147: LD_INT 235
30149: PPUSH
30150: LD_INT 3
30152: PPUSH
30153: LD_INT 1
30155: PPUSH
30156: CALL_OW 483
// SetSide ( unit , 4 ) ;
30160: LD_VAR 0 1
30164: PPUSH
30165: LD_INT 4
30167: PPUSH
30168: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30172: LD_ADDR_EXP 34
30176: PUSH
30177: LD_EXP 34
30181: PUSH
30182: LD_INT 1
30184: PLUS
30185: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30186: LD_INT 70
30188: PPUSH
30189: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30193: LD_INT 260
30195: PPUSH
30196: LD_INT 235
30198: PPUSH
30199: LD_INT 1
30201: PPUSH
30202: LD_INT 8
30204: NEG
30205: PPUSH
30206: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30210: LD_VAR 0 1
30214: PPUSH
30215: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30219: LD_VAR 0 1
30223: PPUSH
30224: LD_EXP 71
30228: PPUSH
30229: CALL_OW 119
// DialogueOn ;
30233: CALL_OW 6
// case unit of JMM :
30237: LD_VAR 0 1
30241: PUSH
30242: LD_EXP 36
30246: DOUBLE
30247: EQUAL
30248: IFTRUE 30252
30250: GO 30267
30252: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30253: LD_EXP 36
30257: PPUSH
30258: LD_STRING DA1-JMM-1
30260: PPUSH
30261: CALL_OW 91
30265: GO 30709
30267: LD_EXP 37
30271: DOUBLE
30272: EQUAL
30273: IFTRUE 30277
30275: GO 30292
30277: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30278: LD_EXP 37
30282: PPUSH
30283: LD_STRING DA1-Joan-1
30285: PPUSH
30286: CALL_OW 91
30290: GO 30709
30292: LD_EXP 39
30296: DOUBLE
30297: EQUAL
30298: IFTRUE 30302
30300: GO 30317
30302: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30303: LD_EXP 39
30307: PPUSH
30308: LD_STRING DA1-Lisa-1
30310: PPUSH
30311: CALL_OW 91
30315: GO 30709
30317: LD_EXP 40
30321: DOUBLE
30322: EQUAL
30323: IFTRUE 30327
30325: GO 30342
30327: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30328: LD_EXP 40
30332: PPUSH
30333: LD_STRING DA1-Don-1
30335: PPUSH
30336: CALL_OW 91
30340: GO 30709
30342: LD_EXP 47
30346: DOUBLE
30347: EQUAL
30348: IFTRUE 30352
30350: GO 30367
30352: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30353: LD_EXP 47
30357: PPUSH
30358: LD_STRING DA1-Corn-1
30360: PPUSH
30361: CALL_OW 91
30365: GO 30709
30367: LD_EXP 43
30371: DOUBLE
30372: EQUAL
30373: IFTRUE 30377
30375: GO 30392
30377: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30378: LD_EXP 43
30382: PPUSH
30383: LD_STRING DA1-Den-1
30385: PPUSH
30386: CALL_OW 91
30390: GO 30709
30392: LD_EXP 41
30396: DOUBLE
30397: EQUAL
30398: IFTRUE 30402
30400: GO 30417
30402: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30403: LD_EXP 41
30407: PPUSH
30408: LD_STRING DA1-Bobby-1
30410: PPUSH
30411: CALL_OW 91
30415: GO 30709
30417: LD_EXP 45
30421: DOUBLE
30422: EQUAL
30423: IFTRUE 30427
30425: GO 30442
30427: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30428: LD_EXP 45
30432: PPUSH
30433: LD_STRING DA1-Glad-1
30435: PPUSH
30436: CALL_OW 91
30440: GO 30709
30442: LD_EXP 42
30446: DOUBLE
30447: EQUAL
30448: IFTRUE 30452
30450: GO 30467
30452: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30453: LD_EXP 42
30457: PPUSH
30458: LD_STRING DA1-Cyrus-1
30460: PPUSH
30461: CALL_OW 91
30465: GO 30709
30467: LD_EXP 38
30471: DOUBLE
30472: EQUAL
30473: IFTRUE 30477
30475: GO 30492
30477: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30478: LD_EXP 38
30482: PPUSH
30483: LD_STRING DA1-Huck-1
30485: PPUSH
30486: CALL_OW 91
30490: GO 30709
30492: LD_EXP 52
30496: DOUBLE
30497: EQUAL
30498: IFTRUE 30502
30500: GO 30517
30502: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30503: LD_EXP 52
30507: PPUSH
30508: LD_STRING DA1-Huck-1
30510: PPUSH
30511: CALL_OW 91
30515: GO 30709
30517: LD_EXP 44
30521: DOUBLE
30522: EQUAL
30523: IFTRUE 30527
30525: GO 30542
30527: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30528: LD_EXP 44
30532: PPUSH
30533: LD_STRING DA1-Brown-1
30535: PPUSH
30536: CALL_OW 91
30540: GO 30709
30542: LD_EXP 48
30546: DOUBLE
30547: EQUAL
30548: IFTRUE 30552
30550: GO 30567
30552: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30553: LD_EXP 48
30557: PPUSH
30558: LD_STRING DA1-Gary-1
30560: PPUSH
30561: CALL_OW 91
30565: GO 30709
30567: LD_EXP 51
30571: DOUBLE
30572: EQUAL
30573: IFTRUE 30577
30575: GO 30592
30577: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30578: LD_EXP 51
30582: PPUSH
30583: LD_STRING DA1-Con-1
30585: PPUSH
30586: CALL_OW 91
30590: GO 30709
30592: LD_EXP 57
30596: DOUBLE
30597: EQUAL
30598: IFTRUE 30602
30600: GO 30617
30602: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30603: LD_EXP 57
30607: PPUSH
30608: LD_STRING DA1-Kurt-1
30610: PPUSH
30611: CALL_OW 91
30615: GO 30709
30617: LD_EXP 50
30621: DOUBLE
30622: EQUAL
30623: IFTRUE 30627
30625: GO 30642
30627: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30628: LD_EXP 50
30632: PPUSH
30633: LD_STRING DA1-Yam-1
30635: PPUSH
30636: CALL_OW 91
30640: GO 30709
30642: LD_EXP 49
30646: DOUBLE
30647: EQUAL
30648: IFTRUE 30652
30650: GO 30667
30652: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30653: LD_EXP 49
30657: PPUSH
30658: LD_STRING DA1-Frank-1
30660: PPUSH
30661: CALL_OW 91
30665: GO 30709
30667: POP
// begin if GetSex ( unit ) = sex_male then
30668: LD_VAR 0 1
30672: PPUSH
30673: CALL_OW 258
30677: PUSH
30678: LD_INT 1
30680: EQUAL
30681: IFFALSE 30697
// ForceSay ( unit , DA1-Sol1-1 ) else
30683: LD_VAR 0 1
30687: PPUSH
30688: LD_STRING DA1-Sol1-1
30690: PPUSH
30691: CALL_OW 91
30695: GO 30709
// ForceSay ( unit , DA1-FSol1-1 ) ;
30697: LD_VAR 0 1
30701: PPUSH
30702: LD_STRING DA1-FSol1-1
30704: PPUSH
30705: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30709: LD_EXP 71
30713: PPUSH
30714: LD_STRING DA-Roth-1
30716: PPUSH
30717: CALL_OW 88
// if capturedUnit = 1 then
30721: LD_EXP 34
30725: PUSH
30726: LD_INT 1
30728: EQUAL
30729: IFFALSE 30757
// begin Say ( Simms , DA-Sim-1 ) ;
30731: LD_EXP 72
30735: PPUSH
30736: LD_STRING DA-Sim-1
30738: PPUSH
30739: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30743: LD_EXP 71
30747: PPUSH
30748: LD_STRING DA-Roth-2
30750: PPUSH
30751: CALL_OW 88
// end else
30755: GO 30769
// Say ( Simms , DA-Sim-2 ) ;
30757: LD_EXP 72
30761: PPUSH
30762: LD_STRING DA-Sim-2
30764: PPUSH
30765: CALL_OW 88
// case unit of JMM :
30769: LD_VAR 0 1
30773: PUSH
30774: LD_EXP 36
30778: DOUBLE
30779: EQUAL
30780: IFTRUE 30784
30782: GO 30799
30784: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30785: LD_EXP 36
30789: PPUSH
30790: LD_STRING DA1-JMM-1a
30792: PPUSH
30793: CALL_OW 91
30797: GO 31306
30799: LD_EXP 37
30803: DOUBLE
30804: EQUAL
30805: IFTRUE 30809
30807: GO 30824
30809: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30810: LD_EXP 37
30814: PPUSH
30815: LD_STRING DA1-Joan-1a
30817: PPUSH
30818: CALL_OW 91
30822: GO 31306
30824: LD_EXP 39
30828: DOUBLE
30829: EQUAL
30830: IFTRUE 30834
30832: GO 30849
30834: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30835: LD_EXP 39
30839: PPUSH
30840: LD_STRING DA1-Lisa-1a
30842: PPUSH
30843: CALL_OW 91
30847: GO 31306
30849: LD_EXP 40
30853: DOUBLE
30854: EQUAL
30855: IFTRUE 30859
30857: GO 30874
30859: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30860: LD_EXP 40
30864: PPUSH
30865: LD_STRING DA1-Don-1a
30867: PPUSH
30868: CALL_OW 91
30872: GO 31306
30874: LD_EXP 47
30878: DOUBLE
30879: EQUAL
30880: IFTRUE 30884
30882: GO 30899
30884: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30885: LD_EXP 47
30889: PPUSH
30890: LD_STRING DA1-Corn-1a
30892: PPUSH
30893: CALL_OW 91
30897: GO 31306
30899: LD_EXP 43
30903: DOUBLE
30904: EQUAL
30905: IFTRUE 30909
30907: GO 30924
30909: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30910: LD_EXP 43
30914: PPUSH
30915: LD_STRING DA1-Den-1a
30917: PPUSH
30918: CALL_OW 91
30922: GO 31306
30924: LD_EXP 41
30928: DOUBLE
30929: EQUAL
30930: IFTRUE 30934
30932: GO 30949
30934: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30935: LD_EXP 41
30939: PPUSH
30940: LD_STRING DA1-Bobby-1a
30942: PPUSH
30943: CALL_OW 91
30947: GO 31306
30949: LD_EXP 45
30953: DOUBLE
30954: EQUAL
30955: IFTRUE 30959
30957: GO 30974
30959: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30960: LD_EXP 45
30964: PPUSH
30965: LD_STRING DA1-Glad-1a
30967: PPUSH
30968: CALL_OW 91
30972: GO 31306
30974: LD_EXP 42
30978: DOUBLE
30979: EQUAL
30980: IFTRUE 30984
30982: GO 30999
30984: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30985: LD_EXP 42
30989: PPUSH
30990: LD_STRING DA1-Cyrus-1a
30992: PPUSH
30993: CALL_OW 91
30997: GO 31306
30999: LD_EXP 38
31003: DOUBLE
31004: EQUAL
31005: IFTRUE 31009
31007: GO 31024
31009: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31010: LD_EXP 38
31014: PPUSH
31015: LD_STRING DA1-Huck-1a
31017: PPUSH
31018: CALL_OW 91
31022: GO 31306
31024: LD_EXP 52
31028: DOUBLE
31029: EQUAL
31030: IFTRUE 31034
31032: GO 31049
31034: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31035: LD_EXP 52
31039: PPUSH
31040: LD_STRING DA1-Huck-1a
31042: PPUSH
31043: CALL_OW 91
31047: GO 31306
31049: LD_EXP 44
31053: DOUBLE
31054: EQUAL
31055: IFTRUE 31059
31057: GO 31074
31059: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31060: LD_EXP 44
31064: PPUSH
31065: LD_STRING DA1-Brown-1a
31067: PPUSH
31068: CALL_OW 91
31072: GO 31306
31074: LD_EXP 48
31078: DOUBLE
31079: EQUAL
31080: IFTRUE 31084
31082: GO 31099
31084: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31085: LD_EXP 48
31089: PPUSH
31090: LD_STRING DA1-Gary-1a
31092: PPUSH
31093: CALL_OW 91
31097: GO 31306
31099: LD_EXP 51
31103: DOUBLE
31104: EQUAL
31105: IFTRUE 31109
31107: GO 31124
31109: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31110: LD_EXP 51
31114: PPUSH
31115: LD_STRING DA1-Con-1a
31117: PPUSH
31118: CALL_OW 91
31122: GO 31306
31124: LD_EXP 57
31128: DOUBLE
31129: EQUAL
31130: IFTRUE 31134
31132: GO 31149
31134: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31135: LD_EXP 57
31139: PPUSH
31140: LD_STRING DA1-Kurt-1a
31142: PPUSH
31143: CALL_OW 91
31147: GO 31306
31149: LD_EXP 50
31153: DOUBLE
31154: EQUAL
31155: IFTRUE 31159
31157: GO 31174
31159: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31160: LD_EXP 50
31164: PPUSH
31165: LD_STRING DA1-Yam-1a
31167: PPUSH
31168: CALL_OW 91
31172: GO 31306
31174: LD_EXP 49
31178: DOUBLE
31179: EQUAL
31180: IFTRUE 31184
31182: GO 31199
31184: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31185: LD_EXP 49
31189: PPUSH
31190: LD_STRING DA1-Frank-1a
31192: PPUSH
31193: CALL_OW 91
31197: GO 31306
31199: POP
// begin join := rand ( 0 , 1 ) ;
31200: LD_ADDR_VAR 0 3
31204: PUSH
31205: LD_INT 0
31207: PPUSH
31208: LD_INT 1
31210: PPUSH
31211: CALL_OW 12
31215: ST_TO_ADDR
// if join then
31216: LD_VAR 0 3
31220: IFFALSE 31265
// begin if GetSex ( unit ) = sex_male then
31222: LD_VAR 0 1
31226: PPUSH
31227: CALL_OW 258
31231: PUSH
31232: LD_INT 1
31234: EQUAL
31235: IFFALSE 31251
// ForceSay ( unit , DA1-Sol1-1b ) else
31237: LD_VAR 0 1
31241: PPUSH
31242: LD_STRING DA1-Sol1-1b
31244: PPUSH
31245: CALL_OW 91
31249: GO 31263
// ForceSay ( unit , DA1-FSol1-1b ) ;
31251: LD_VAR 0 1
31255: PPUSH
31256: LD_STRING DA1-FSol1-1b
31258: PPUSH
31259: CALL_OW 91
// end else
31263: GO 31306
// begin if GetSex ( unit ) = sex_male then
31265: LD_VAR 0 1
31269: PPUSH
31270: CALL_OW 258
31274: PUSH
31275: LD_INT 1
31277: EQUAL
31278: IFFALSE 31294
// ForceSay ( unit , DA1-Sol1-1a ) else
31280: LD_VAR 0 1
31284: PPUSH
31285: LD_STRING DA1-Sol1-1a
31287: PPUSH
31288: CALL_OW 91
31292: GO 31306
// ForceSay ( unit , DA1-FSol1-1a ) ;
31294: LD_VAR 0 1
31298: PPUSH
31299: LD_STRING DA1-FSol1-1a
31301: PPUSH
31302: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31306: LD_VAR 0 1
31310: PUSH
31311: LD_EXP 36
31315: EQUAL
31316: IFFALSE 31327
// begin YouLost ( JMMCaptured ) ;
31318: LD_STRING JMMCaptured
31320: PPUSH
31321: CALL_OW 104
// exit ;
31325: GO 31625
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31327: LD_VAR 0 1
31331: PUSH
31332: LD_EXP 40
31336: PUSH
31337: LD_EXP 43
31341: PUSH
31342: LD_EXP 41
31346: PUSH
31347: LD_EXP 38
31351: PUSH
31352: LD_EXP 52
31356: PUSH
31357: LD_EXP 44
31361: PUSH
31362: LD_EXP 50
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: IN
31376: PUSH
31377: LD_VAR 0 3
31381: OR
31382: IFFALSE 31481
// begin Say ( Roth , DA-Roth-3 ) ;
31384: LD_EXP 71
31388: PPUSH
31389: LD_STRING DA-Roth-3
31391: PPUSH
31392: CALL_OW 88
// SetSide ( unit , 7 ) ;
31396: LD_VAR 0 1
31400: PPUSH
31401: LD_INT 7
31403: PPUSH
31404: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31408: LD_ADDR_EXP 99
31412: PUSH
31413: LD_EXP 99
31417: PPUSH
31418: LD_INT 1
31420: PPUSH
31421: LD_EXP 99
31425: PUSH
31426: LD_INT 1
31428: ARRAY
31429: PUSH
31430: LD_VAR 0 1
31434: ADD
31435: PPUSH
31436: CALL_OW 1
31440: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31441: LD_INT 260
31443: PPUSH
31444: LD_INT 235
31446: PPUSH
31447: LD_INT 1
31449: PPUSH
31450: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31454: LD_VAR 0 1
31458: PPUSH
31459: LD_INT 1000
31461: PPUSH
31462: CALL_OW 234
// DialogueOff ;
31466: CALL_OW 7
// ComFree ( unit ) ;
31470: LD_VAR 0 1
31474: PPUSH
31475: CALL_OW 139
// end else
31479: GO 31562
// begin Say ( Roth , DA-Roth-3a ) ;
31481: LD_EXP 71
31485: PPUSH
31486: LD_STRING DA-Roth-3a
31488: PPUSH
31489: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31493: LD_ADDR_EXP 35
31497: PUSH
31498: LD_EXP 35
31502: PUSH
31503: LD_VAR 0 1
31507: ADD
31508: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31509: LD_INT 260
31511: PPUSH
31512: LD_INT 235
31514: PPUSH
31515: LD_INT 1
31517: PPUSH
31518: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31522: LD_VAR 0 1
31526: PPUSH
31527: LD_INT 1000
31529: PPUSH
31530: CALL_OW 234
// DialogueOff ;
31534: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31538: LD_VAR 0 1
31542: PPUSH
31543: LD_INT 272
31545: PPUSH
31546: LD_INT 254
31548: PPUSH
31549: CALL_OW 111
// AddComHold ( unit ) ;
31553: LD_VAR 0 1
31557: PPUSH
31558: CALL_OW 200
// end ; if capturedUnit = 1 then
31562: LD_EXP 34
31566: PUSH
31567: LD_INT 1
31569: EQUAL
31570: IFFALSE 31625
// begin DialogueOn ;
31572: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31576: LD_EXP 36
31580: PPUSH
31581: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31585: LD_EXP 36
31589: PPUSH
31590: LD_STRING DAa-JMM-1
31592: PPUSH
31593: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31597: LD_EXP 36
31601: PPUSH
31602: LD_STRING DAa-JMM-1a
31604: PPUSH
31605: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31609: LD_EXP 36
31613: PPUSH
31614: LD_STRING DAa-JMM-1b
31616: PPUSH
31617: CALL_OW 88
// DialogueOff ;
31621: CALL_OW 7
// end ; end ;
31625: LD_VAR 0 2
31629: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
31630: LD_EXP 15
31634: PUSH
31635: LD_INT 13
31637: GREATEREQUAL
31638: PUSH
31639: LD_INT 22
31641: PUSH
31642: LD_INT 2
31644: PUSH
31645: EMPTY
31646: LIST
31647: LIST
31648: PUSH
31649: LD_INT 21
31651: PUSH
31652: LD_INT 1
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PPUSH
31663: CALL_OW 69
31667: PUSH
31668: LD_INT 0
31670: EQUAL
31671: AND
31672: PUSH
31673: LD_INT 22
31675: PUSH
31676: LD_INT 2
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 21
31685: PUSH
31686: LD_INT 2
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 50
31695: PUSH
31696: EMPTY
31697: LIST
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: LIST
31703: PPUSH
31704: CALL_OW 69
31708: PUSH
31709: LD_INT 0
31711: EQUAL
31712: AND
31713: PUSH
31714: LD_EXP 21
31718: AND
31719: PUSH
31720: LD_EXP 22
31724: AND
31725: PUSH
31726: LD_EXP 23
31730: AND
31731: IFFALSE 32335
31733: GO 31735
31735: DISABLE
31736: LD_INT 0
31738: PPUSH
31739: PPUSH
31740: PPUSH
// begin m1 := false ;
31741: LD_ADDR_VAR 0 1
31745: PUSH
31746: LD_INT 0
31748: ST_TO_ADDR
// m2 := false ;
31749: LD_ADDR_VAR 0 2
31753: PUSH
31754: LD_INT 0
31756: ST_TO_ADDR
// m3 := false ;
31757: LD_ADDR_VAR 0 3
31761: PUSH
31762: LD_INT 0
31764: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
31765: LD_EXP 36
31769: PPUSH
31770: CALL_OW 87
// music_class := 5 ;
31774: LD_ADDR_OWVAR 72
31778: PUSH
31779: LD_INT 5
31781: ST_TO_ADDR
// music_nat := 5 ;
31782: LD_ADDR_OWVAR 71
31786: PUSH
31787: LD_INT 5
31789: ST_TO_ADDR
// DialogueOn ;
31790: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
31794: LD_EXP 36
31798: PPUSH
31799: LD_STRING D20-JMM-1
31801: PPUSH
31802: CALL_OW 88
// if IsOK ( Joan ) then
31806: LD_EXP 37
31810: PPUSH
31811: CALL_OW 302
31815: IFFALSE 31829
// Say ( Joan , D20-Joan-1 ) ;
31817: LD_EXP 37
31821: PPUSH
31822: LD_STRING D20-Joan-1
31824: PPUSH
31825: CALL_OW 88
// if IsOk ( Lisa ) then
31829: LD_EXP 39
31833: PPUSH
31834: CALL_OW 302
31838: IFFALSE 31852
// Say ( Lisa , D20-Lisa-1 ) ;
31840: LD_EXP 39
31844: PPUSH
31845: LD_STRING D20-Lisa-1
31847: PPUSH
31848: CALL_OW 88
// if IsOk ( Donaldson ) then
31852: LD_EXP 40
31856: PPUSH
31857: CALL_OW 302
31861: IFFALSE 31875
// Say ( Donaldson , D20-Don-1 ) ;
31863: LD_EXP 40
31867: PPUSH
31868: LD_STRING D20-Don-1
31870: PPUSH
31871: CALL_OW 88
// if IsOK ( Cornel ) then
31875: LD_EXP 47
31879: PPUSH
31880: CALL_OW 302
31884: IFFALSE 31898
// Say ( Cornel , D20-Corn-1 ) ;
31886: LD_EXP 47
31890: PPUSH
31891: LD_STRING D20-Corn-1
31893: PPUSH
31894: CALL_OW 88
// if IsOk ( Denis ) then
31898: LD_EXP 43
31902: PPUSH
31903: CALL_OW 302
31907: IFFALSE 31921
// Say ( Denis , D20-Den-1 ) ;
31909: LD_EXP 43
31913: PPUSH
31914: LD_STRING D20-Den-1
31916: PPUSH
31917: CALL_OW 88
// if IsOk ( Bobby ) then
31921: LD_EXP 41
31925: PPUSH
31926: CALL_OW 302
31930: IFFALSE 31944
// Say ( Bobby , D20-Bobby-1 ) ;
31932: LD_EXP 41
31936: PPUSH
31937: LD_STRING D20-Bobby-1
31939: PPUSH
31940: CALL_OW 88
// if IsOk ( Gladstone ) then
31944: LD_EXP 45
31948: PPUSH
31949: CALL_OW 302
31953: IFFALSE 31967
// Say ( Gladstone , D20-Glad-1 ) ;
31955: LD_EXP 45
31959: PPUSH
31960: LD_STRING D20-Glad-1
31962: PPUSH
31963: CALL_OW 88
// if IsOk ( Cyrus ) then
31967: LD_EXP 42
31971: PPUSH
31972: CALL_OW 302
31976: IFFALSE 31990
// Say ( Cyrus , D20-Cyrus-1 ) ;
31978: LD_EXP 42
31982: PPUSH
31983: LD_STRING D20-Cyrus-1
31985: PPUSH
31986: CALL_OW 88
// if IsOk ( Stevens ) then
31990: LD_EXP 38
31994: PPUSH
31995: CALL_OW 302
31999: IFFALSE 32013
// Say ( Stevens , D20-Huck-1 ) ;
32001: LD_EXP 38
32005: PPUSH
32006: LD_STRING D20-Huck-1
32008: PPUSH
32009: CALL_OW 88
// if IsOk ( Brown ) then
32013: LD_EXP 44
32017: PPUSH
32018: CALL_OW 302
32022: IFFALSE 32036
// Say ( Brown , D20-Brown-1 ) ;
32024: LD_EXP 44
32028: PPUSH
32029: LD_STRING D20-Brown-1
32031: PPUSH
32032: CALL_OW 88
// if IsOk ( Gary ) then
32036: LD_EXP 48
32040: PPUSH
32041: CALL_OW 302
32045: IFFALSE 32059
// Say ( Gary , D20-Gary-1 ) ;
32047: LD_EXP 48
32051: PPUSH
32052: LD_STRING D20-Gary-1
32054: PPUSH
32055: CALL_OW 88
// if IsOk ( Connie ) then
32059: LD_EXP 51
32063: PPUSH
32064: CALL_OW 302
32068: IFFALSE 32082
// Say ( Connie , D20-Con-1 ) ;
32070: LD_EXP 51
32074: PPUSH
32075: LD_STRING D20-Con-1
32077: PPUSH
32078: CALL_OW 88
// if IsOk ( Kurt ) then
32082: LD_EXP 57
32086: PPUSH
32087: CALL_OW 302
32091: IFFALSE 32105
// Say ( Kurt , D20-Kurt-1 ) ;
32093: LD_EXP 57
32097: PPUSH
32098: LD_STRING D20-Kurt-1
32100: PPUSH
32101: CALL_OW 88
// if IsOk ( Kikuchi ) then
32105: LD_EXP 50
32109: PPUSH
32110: CALL_OW 302
32114: IFFALSE 32128
// Say ( Kikuchi , D20-Yam-1 ) ;
32116: LD_EXP 50
32120: PPUSH
32121: LD_STRING D20-Yam-1
32123: PPUSH
32124: CALL_OW 88
// if IsOk ( Frank ) then
32128: LD_EXP 49
32132: PPUSH
32133: CALL_OW 302
32137: IFFALSE 32151
// Say ( Frank , D20-Frank-1 ) ;
32139: LD_EXP 49
32143: PPUSH
32144: LD_STRING D20-Frank-1
32146: PPUSH
32147: CALL_OW 88
// DialogueOff ;
32151: CALL_OW 7
// if RothCaptured then
32155: LD_EXP 33
32159: IFFALSE 32181
// begin m1 := true ;
32161: LD_ADDR_VAR 0 1
32165: PUSH
32166: LD_INT 1
32168: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32169: LD_STRING Roth
32171: PPUSH
32172: LD_INT 1
32174: PPUSH
32175: CALL_OW 101
// end else
32179: GO 32192
// AddMedal ( Roth , - 1 ) ;
32181: LD_STRING Roth
32183: PPUSH
32184: LD_INT 1
32186: NEG
32187: PPUSH
32188: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32192: LD_EXP 27
32196: IFFALSE 32218
// begin m2 := true ;
32198: LD_ADDR_VAR 0 2
32202: PUSH
32203: LD_INT 1
32205: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32206: LD_STRING Project
32208: PPUSH
32209: LD_INT 1
32211: PPUSH
32212: CALL_OW 101
// end else
32216: GO 32229
// AddMedal ( Project , - 1 ) ;
32218: LD_STRING Project
32220: PPUSH
32221: LD_INT 1
32223: NEG
32224: PPUSH
32225: CALL_OW 101
// if lostCounter = 0 then
32229: LD_EXP 32
32233: PUSH
32234: LD_INT 0
32236: EQUAL
32237: IFFALSE 32259
// begin m3 := true ;
32239: LD_ADDR_VAR 0 3
32243: PUSH
32244: LD_INT 1
32246: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
32247: LD_STRING NoLosses
32249: PPUSH
32250: LD_INT 1
32252: PPUSH
32253: CALL_OW 101
// end else
32257: GO 32270
// AddMedal ( NoLosses , - 1 ) ;
32259: LD_STRING NoLosses
32261: PPUSH
32262: LD_INT 1
32264: NEG
32265: PPUSH
32266: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
32270: LD_VAR 0 1
32274: PUSH
32275: LD_VAR 0 2
32279: AND
32280: PUSH
32281: LD_VAR 0 3
32285: AND
32286: PUSH
32287: LD_OWVAR 67
32291: PUSH
32292: LD_INT 3
32294: EQUAL
32295: AND
32296: IFFALSE 32308
// SetAchievementEX ( ACH_AMER , 15 ) ;
32298: LD_STRING ACH_AMER
32300: PPUSH
32301: LD_INT 15
32303: PPUSH
32304: CALL_OW 564
// GiveMedals ( MAIN ) ;
32308: LD_STRING MAIN
32310: PPUSH
32311: CALL_OW 102
// music_class := 4 ;
32315: LD_ADDR_OWVAR 72
32319: PUSH
32320: LD_INT 4
32322: ST_TO_ADDR
// music_nat := 1 ;
32323: LD_ADDR_OWVAR 71
32327: PUSH
32328: LD_INT 1
32330: ST_TO_ADDR
// YouWin ;
32331: CALL_OW 103
// end ; end_of_file
32335: PPOPN 3
32337: END
// export function CustomEvent ( event ) ; begin
32338: LD_INT 0
32340: PPUSH
// end ;
32341: LD_VAR 0 2
32345: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32346: LD_VAR 0 1
32350: PUSH
32351: LD_INT 1
32353: EQUAL
32354: PUSH
32355: LD_VAR 0 2
32359: PUSH
32360: LD_INT 4
32362: EQUAL
32363: AND
32364: PUSH
32365: LD_EXP 55
32369: PPUSH
32370: CALL_OW 300
32374: AND
32375: IFFALSE 32391
// begin wait ( 0 0$2 ) ;
32377: LD_INT 70
32379: PPUSH
32380: CALL_OW 67
// YouLost ( Dismissed ) ;
32384: LD_STRING Dismissed
32386: PPUSH
32387: CALL_OW 104
// end ; end ;
32391: PPOPN 2
32393: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32394: LD_VAR 0 2
32398: PPUSH
32399: LD_VAR 0 3
32403: PPUSH
32404: LD_INT 18
32406: PPUSH
32407: CALL_OW 309
32411: IFFALSE 32420
// YouLost ( Motherlode3 ) ;
32413: LD_STRING Motherlode3
32415: PPUSH
32416: CALL_OW 104
// end ;
32420: PPOPN 3
32422: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32423: LD_EXP 27
32427: NOT
32428: IFFALSE 32438
// behemothDone := true ;
32430: LD_ADDR_EXP 28
32434: PUSH
32435: LD_INT 1
32437: ST_TO_ADDR
// end ;
32438: PPOPN 1
32440: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32441: LD_VAR 0 1
32445: PPUSH
32446: CALL_OW 255
32450: PUSH
32451: LD_INT 1
32453: EQUAL
32454: PUSH
32455: LD_EXP 30
32459: AND
32460: PUSH
32461: LD_INT 22
32463: PUSH
32464: LD_INT 3
32466: PUSH
32467: EMPTY
32468: LIST
32469: LIST
32470: PUSH
32471: LD_INT 34
32473: PUSH
32474: LD_INT 48
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: EMPTY
32482: LIST
32483: LIST
32484: PPUSH
32485: CALL_OW 69
32489: AND
32490: PUSH
32491: LD_INT 22
32493: PUSH
32494: LD_INT 1
32496: PUSH
32497: EMPTY
32498: LIST
32499: LIST
32500: PUSH
32501: LD_INT 34
32503: PUSH
32504: LD_INT 8
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PPUSH
32515: CALL_OW 69
32519: NOT
32520: AND
32521: IFFALSE 32573
// begin wait ( 0 0$5 ) ;
32523: LD_INT 175
32525: PPUSH
32526: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32530: LD_INT 22
32532: PUSH
32533: LD_INT 3
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 34
32542: PUSH
32543: LD_INT 48
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: EMPTY
32551: LIST
32552: LIST
32553: PPUSH
32554: CALL_OW 69
32558: PUSH
32559: LD_INT 1
32561: ARRAY
32562: PPUSH
32563: LD_INT 60
32565: PPUSH
32566: LD_INT 95
32568: PPUSH
32569: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32573: LD_VAR 0 2
32577: PPUSH
32578: LD_VAR 0 3
32582: PPUSH
32583: LD_INT 18
32585: PPUSH
32586: CALL_OW 309
32590: IFFALSE 32650
// begin if GetSide ( unit ) = 1 then
32592: LD_VAR 0 1
32596: PPUSH
32597: CALL_OW 255
32601: PUSH
32602: LD_INT 1
32604: EQUAL
32605: IFFALSE 32621
// begin wait ( 0 0$6 ) ;
32607: LD_INT 210
32609: PPUSH
32610: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32614: LD_STRING Motherlode2
32616: PPUSH
32617: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32621: LD_VAR 0 1
32625: PPUSH
32626: CALL_OW 255
32630: PUSH
32631: LD_INT 8
32633: EQUAL
32634: IFFALSE 32650
// begin wait ( 0 0$6 ) ;
32636: LD_INT 210
32638: PPUSH
32639: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32643: LD_STRING Motherlode1
32645: PPUSH
32646: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32650: LD_VAR 0 1
32654: PPUSH
32655: CALL_OW 255
32659: PUSH
32660: LD_INT 3
32662: EQUAL
32663: IFFALSE 32684
// begin wait ( 0 0$5 ) ;
32665: LD_INT 175
32667: PPUSH
32668: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32672: LD_EXP 61
32676: PPUSH
32677: LD_STRING D18-Pla-1
32679: PPUSH
32680: CALL_OW 94
// end ; end ;
32684: PPOPN 3
32686: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32687: LD_VAR 0 1
32691: PUSH
32692: LD_EXP 70
32696: IN
32697: IFFALSE 32717
// begin behemothBuilders := behemothBuilders diff un ;
32699: LD_ADDR_EXP 70
32703: PUSH
32704: LD_EXP 70
32708: PUSH
32709: LD_VAR 0 1
32713: DIFF
32714: ST_TO_ADDR
// exit ;
32715: GO 32815
// end ; if un = JMM then
32717: LD_VAR 0 1
32721: PUSH
32722: LD_EXP 36
32726: EQUAL
32727: IFFALSE 32738
// begin YouLost ( JMM ) ;
32729: LD_STRING JMM
32731: PPUSH
32732: CALL_OW 104
// exit ;
32736: GO 32815
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32738: LD_VAR 0 1
32742: PUSH
32743: LD_INT 22
32745: PUSH
32746: LD_INT 1
32748: PUSH
32749: EMPTY
32750: LIST
32751: LIST
32752: PUSH
32753: LD_INT 3
32755: PUSH
32756: LD_INT 25
32758: PUSH
32759: LD_INT 16
32761: PUSH
32762: EMPTY
32763: LIST
32764: LIST
32765: PUSH
32766: LD_INT 25
32768: PUSH
32769: LD_INT 12
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: EMPTY
32777: LIST
32778: LIST
32779: LIST
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PPUSH
32785: CALL_OW 69
32789: IN
32790: IFFALSE 32806
// lostCounter := lostCounter + 1 ;
32792: LD_ADDR_EXP 32
32796: PUSH
32797: LD_EXP 32
32801: PUSH
32802: LD_INT 1
32804: PLUS
32805: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32806: LD_VAR 0 1
32810: PPUSH
32811: CALL 60883 0 1
// end ;
32815: PPOPN 1
32817: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32818: LD_VAR 0 1
32822: PPUSH
32823: LD_VAR 0 2
32827: PPUSH
32828: CALL 63083 0 2
// end ;
32832: PPOPN 2
32834: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32835: LD_VAR 0 1
32839: PPUSH
32840: CALL 62151 0 1
// end ;
32844: PPOPN 1
32846: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32847: LD_VAR 0 1
32851: PUSH
32852: LD_INT 22
32854: PUSH
32855: LD_INT 8
32857: PUSH
32858: EMPTY
32859: LIST
32860: LIST
32861: PUSH
32862: LD_INT 30
32864: PUSH
32865: LD_INT 2
32867: PUSH
32868: EMPTY
32869: LIST
32870: LIST
32871: PUSH
32872: LD_INT 23
32874: PUSH
32875: LD_INT 3
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: LIST
32886: PPUSH
32887: CALL_OW 69
32891: IN
32892: IFFALSE 32919
// begin ComUpgrade ( building ) ;
32894: LD_VAR 0 1
32898: PPUSH
32899: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32903: LD_EXP 58
32907: PPUSH
32908: LD_VAR 0 1
32912: PPUSH
32913: CALL 73640 0 2
// exit ;
32917: GO 32928
// end ; MCE_BuildingComplete ( building ) ;
32919: LD_VAR 0 1
32923: PPUSH
32924: CALL 62392 0 1
// end ;
32928: PPOPN 1
32930: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32931: LD_VAR 0 1
32935: PPUSH
32936: LD_VAR 0 2
32940: PPUSH
32941: CALL 60579 0 2
// end ;
32945: PPOPN 2
32947: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32948: LD_VAR 0 1
32952: PPUSH
32953: LD_VAR 0 2
32957: PPUSH
32958: LD_VAR 0 3
32962: PPUSH
32963: LD_VAR 0 4
32967: PPUSH
32968: LD_VAR 0 5
32972: PPUSH
32973: CALL 60199 0 5
// end ;
32977: PPOPN 5
32979: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32980: LD_VAR 0 1
32984: PPUSH
32985: LD_VAR 0 2
32989: PPUSH
32990: CALL 59795 0 2
// end ;
32994: PPOPN 2
32996: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32997: LD_VAR 0 1
33001: PPUSH
33002: LD_VAR 0 2
33006: PPUSH
33007: LD_VAR 0 3
33011: PPUSH
33012: LD_VAR 0 4
33016: PPUSH
33017: CALL 59633 0 4
// end ;
33021: PPOPN 4
33023: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33024: LD_VAR 0 1
33028: PPUSH
33029: LD_VAR 0 2
33033: PPUSH
33034: LD_VAR 0 3
33038: PPUSH
33039: CALL 59408 0 3
// end ;
33043: PPOPN 3
33045: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33046: LD_VAR 0 1
33050: PPUSH
33051: LD_VAR 0 2
33055: PPUSH
33056: CALL 59293 0 2
// end ;
33060: PPOPN 2
33062: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33063: LD_VAR 0 1
33067: PPUSH
33068: LD_VAR 0 2
33072: PPUSH
33073: CALL 63344 0 2
// end ;
33077: PPOPN 2
33079: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33080: LD_VAR 0 1
33084: PPUSH
33085: CALL_OW 255
33089: PUSH
33090: LD_INT 4
33092: EQUAL
33093: PUSH
33094: LD_VAR 0 1
33098: PUSH
33099: LD_EXP 18
33103: PUSH
33104: LD_INT 1
33106: ARRAY
33107: IN
33108: AND
33109: PUSH
33110: LD_EXP 19
33114: AND
33115: IFFALSE 33134
// begin ComMoveXY ( driver , 61 , 93 ) ;
33117: LD_VAR 0 1
33121: PPUSH
33122: LD_INT 61
33124: PPUSH
33125: LD_INT 93
33127: PPUSH
33128: CALL_OW 111
// exit ;
33132: GO 33158
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33134: LD_VAR 0 1
33138: PPUSH
33139: LD_VAR 0 2
33143: PPUSH
33144: LD_VAR 0 3
33148: PPUSH
33149: LD_VAR 0 4
33153: PPUSH
33154: CALL 63560 0 4
// end ;
33158: PPOPN 4
33160: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33161: LD_VAR 0 1
33165: PPUSH
33166: LD_VAR 0 2
33170: PPUSH
33171: CALL 59102 0 2
// end ;
33175: PPOPN 2
33177: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33178: LD_VAR 0 1
33182: PPUSH
33183: CALL 106812 0 1
// end ; end_of_file
33187: PPOPN 1
33189: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33190: LD_EXP 15
33194: PUSH
33195: LD_INT 2
33197: EQUAL
33198: IFFALSE 33677
33200: GO 33202
33202: DISABLE
33203: LD_INT 0
33205: PPUSH
// begin time := 0 0$40 ;
33206: LD_ADDR_VAR 0 1
33210: PUSH
33211: LD_INT 1400
33213: ST_TO_ADDR
// repeat wait ( time ) ;
33214: LD_VAR 0 1
33218: PPUSH
33219: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33223: LD_INT 1
33225: PPUSH
33226: LD_INT 5
33228: PPUSH
33229: CALL_OW 12
33233: PPUSH
33234: LD_INT 106
33236: PPUSH
33237: LD_INT 150
33239: PPUSH
33240: LD_INT 19
33242: PPUSH
33243: LD_INT 1
33245: PPUSH
33246: CALL_OW 56
// time := time + 0 0$9 ;
33250: LD_ADDR_VAR 0 1
33254: PUSH
33255: LD_VAR 0 1
33259: PUSH
33260: LD_INT 315
33262: PLUS
33263: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33264: LD_INT 455
33266: PPUSH
33267: LD_INT 840
33269: PPUSH
33270: CALL_OW 12
33274: PPUSH
33275: CALL_OW 67
// if Prob ( 50 ) then
33279: LD_INT 50
33281: PPUSH
33282: CALL_OW 13
33286: IFFALSE 33315
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33288: LD_INT 1
33290: PPUSH
33291: LD_INT 5
33293: PPUSH
33294: CALL_OW 12
33298: PPUSH
33299: LD_INT 62
33301: PPUSH
33302: LD_INT 108
33304: PPUSH
33305: LD_INT 10
33307: PPUSH
33308: LD_INT 1
33310: PPUSH
33311: CALL_OW 56
// until missionStage > 4 ;
33315: LD_EXP 15
33319: PUSH
33320: LD_INT 4
33322: GREATER
33323: IFFALSE 33214
// repeat wait ( 0 0$1 ) ;
33325: LD_INT 35
33327: PPUSH
33328: CALL_OW 67
// until missionStage = 6 ;
33332: LD_EXP 15
33336: PUSH
33337: LD_INT 6
33339: EQUAL
33340: IFFALSE 33325
// time := 0 0$50 ;
33342: LD_ADDR_VAR 0 1
33346: PUSH
33347: LD_INT 1750
33349: ST_TO_ADDR
// repeat wait ( time ) ;
33350: LD_VAR 0 1
33354: PPUSH
33355: CALL_OW 67
// if Prob ( 50 ) then
33359: LD_INT 50
33361: PPUSH
33362: CALL_OW 13
33366: IFFALSE 33395
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33368: LD_INT 1
33370: PPUSH
33371: LD_INT 5
33373: PPUSH
33374: CALL_OW 12
33378: PPUSH
33379: LD_INT 106
33381: PPUSH
33382: LD_INT 89
33384: PPUSH
33385: LD_INT 45
33387: PPUSH
33388: LD_INT 1
33390: PPUSH
33391: CALL_OW 56
// time := time + 0 0$3 ;
33395: LD_ADDR_VAR 0 1
33399: PUSH
33400: LD_VAR 0 1
33404: PUSH
33405: LD_INT 105
33407: PLUS
33408: ST_TO_ADDR
// if Prob ( 30 ) then
33409: LD_INT 30
33411: PPUSH
33412: CALL_OW 13
33416: IFFALSE 33462
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33418: LD_INT 525
33420: PPUSH
33421: LD_INT 735
33423: PPUSH
33424: CALL_OW 12
33428: PPUSH
33429: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33433: LD_INT 1
33435: PPUSH
33436: LD_INT 5
33438: PPUSH
33439: CALL_OW 12
33443: PPUSH
33444: LD_INT 21
33446: PPUSH
33447: LD_INT 26
33449: PPUSH
33450: LD_INT 12
33452: PPUSH
33453: LD_INT 1
33455: PPUSH
33456: CALL_OW 56
// end else
33460: GO 33498
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33462: LD_INT 700
33464: PPUSH
33465: LD_INT 1225
33467: PPUSH
33468: CALL_OW 12
33472: PPUSH
33473: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33477: LD_INT 1
33479: PPUSH
33480: LD_INT 5
33482: PPUSH
33483: CALL_OW 12
33487: PPUSH
33488: LD_INT 16
33490: PPUSH
33491: LD_INT 1
33493: PPUSH
33494: CALL_OW 55
// end ; if Prob ( 50 ) then
33498: LD_INT 50
33500: PPUSH
33501: CALL_OW 13
33505: IFFALSE 33551
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33507: LD_INT 700
33509: PPUSH
33510: LD_INT 1050
33512: PPUSH
33513: CALL_OW 12
33517: PPUSH
33518: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33522: LD_INT 1
33524: PPUSH
33525: LD_INT 5
33527: PPUSH
33528: CALL_OW 12
33532: PPUSH
33533: LD_INT 181
33535: PPUSH
33536: LD_INT 218
33538: PPUSH
33539: LD_INT 16
33541: PPUSH
33542: LD_INT 1
33544: PPUSH
33545: CALL_OW 56
// end else
33549: GO 33587
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33551: LD_INT 350
33553: PPUSH
33554: LD_INT 525
33556: PPUSH
33557: CALL_OW 12
33561: PPUSH
33562: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33566: LD_INT 1
33568: PPUSH
33569: LD_INT 5
33571: PPUSH
33572: CALL_OW 12
33576: PPUSH
33577: LD_INT 15
33579: PPUSH
33580: LD_INT 1
33582: PPUSH
33583: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33587: LD_INT 45
33589: PUSH
33590: LD_INT 32
33592: PUSH
33593: LD_INT 25
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: LIST
33600: PUSH
33601: LD_OWVAR 67
33605: ARRAY
33606: PPUSH
33607: CALL_OW 13
33611: IFFALSE 33655
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33613: LD_INT 525
33615: PPUSH
33616: LD_INT 875
33618: PPUSH
33619: CALL_OW 12
33623: PPUSH
33624: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33628: LD_INT 1
33630: PPUSH
33631: LD_INT 5
33633: PPUSH
33634: CALL_OW 12
33638: PPUSH
33639: LD_INT 103
33641: PPUSH
33642: LD_INT 140
33644: PPUSH
33645: LD_INT 20
33647: PPUSH
33648: LD_INT 1
33650: PPUSH
33651: CALL_OW 56
// end ; if time > 2 2$20 then
33655: LD_VAR 0 1
33659: PUSH
33660: LD_INT 4900
33662: GREATER
33663: IFFALSE 33673
// time := 0 0$50 ;
33665: LD_ADDR_VAR 0 1
33669: PUSH
33670: LD_INT 1750
33672: ST_TO_ADDR
// until false ;
33673: LD_INT 0
33675: IFFALSE 33350
// end ; end_of_file
33677: PPOPN 1
33679: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33680: LD_EXP 13
33684: PUSH
33685: LD_EXP 15
33689: PUSH
33690: LD_INT 6
33692: GREATEREQUAL
33693: AND
33694: IFFALSE 33731
33696: GO 33698
33698: DISABLE
// begin enable ;
33699: ENABLE
// missionTime := missionTime + 0 0$1 ;
33700: LD_ADDR_EXP 14
33704: PUSH
33705: LD_EXP 14
33709: PUSH
33710: LD_INT 35
33712: PLUS
33713: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33714: LD_ADDR_OWVAR 47
33718: PUSH
33719: LD_STRING #Am15-1
33721: PUSH
33722: LD_EXP 14
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: ST_TO_ADDR
// end ; end_of_file
33731: END
// export function InitNature ; begin
33732: LD_INT 0
33734: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33735: LD_INT 3
33737: PPUSH
33738: LD_INT 3
33740: PPUSH
33741: LD_INT 2
33743: PPUSH
33744: LD_INT 1
33746: PPUSH
33747: LD_INT 1
33749: PPUSH
33750: LD_INT 0
33752: PPUSH
33753: LD_INT 0
33755: PPUSH
33756: LD_INT 20
33758: PPUSH
33759: LD_INT 0
33761: PPUSH
33762: CALL 98481 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33766: LD_INT 2
33768: PPUSH
33769: LD_INT 1
33771: PPUSH
33772: LD_INT 1
33774: PPUSH
33775: LD_INT 1
33777: PPUSH
33778: LD_INT 1
33780: PPUSH
33781: LD_INT 0
33783: PPUSH
33784: LD_INT 0
33786: PPUSH
33787: LD_INT 21
33789: PPUSH
33790: LD_INT 0
33792: PPUSH
33793: CALL 98481 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33797: LD_INT 4
33799: PPUSH
33800: LD_INT 1
33802: PPUSH
33803: LD_INT 2
33805: PPUSH
33806: LD_INT 4
33808: PPUSH
33809: LD_INT 2
33811: PPUSH
33812: LD_INT 1
33814: PPUSH
33815: LD_INT 0
33817: PPUSH
33818: LD_INT 22
33820: PPUSH
33821: LD_INT 0
33823: PPUSH
33824: CALL 98481 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33828: LD_INT 0
33830: PPUSH
33831: LD_INT 0
33833: PPUSH
33834: LD_INT 0
33836: PPUSH
33837: LD_INT 0
33839: PPUSH
33840: LD_INT 0
33842: PPUSH
33843: LD_INT 0
33845: PPUSH
33846: LD_INT 9
33848: PPUSH
33849: LD_INT 0
33851: PPUSH
33852: LD_INT 23
33854: PPUSH
33855: CALL 98481 0 9
// end ; end_of_file
33859: LD_VAR 0 1
33863: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33864: GO 33866
33866: DISABLE
// begin ru_radar := 98 ;
33867: LD_ADDR_EXP 92
33871: PUSH
33872: LD_INT 98
33874: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33875: LD_ADDR_EXP 93
33879: PUSH
33880: LD_INT 89
33882: ST_TO_ADDR
// us_hack := 99 ;
33883: LD_ADDR_EXP 94
33887: PUSH
33888: LD_INT 99
33890: ST_TO_ADDR
// us_artillery := 97 ;
33891: LD_ADDR_EXP 95
33895: PUSH
33896: LD_INT 97
33898: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33899: LD_ADDR_EXP 96
33903: PUSH
33904: LD_INT 91
33906: ST_TO_ADDR
// end ; end_of_file
33907: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33908: LD_INT 0
33910: PPUSH
33911: PPUSH
// skirmish := false ;
33912: LD_ADDR_EXP 97
33916: PUSH
33917: LD_INT 0
33919: ST_TO_ADDR
// debug_mc := false ;
33920: LD_ADDR_EXP 98
33924: PUSH
33925: LD_INT 0
33927: ST_TO_ADDR
// mc_bases := [ ] ;
33928: LD_ADDR_EXP 99
33932: PUSH
33933: EMPTY
33934: ST_TO_ADDR
// mc_sides := [ ] ;
33935: LD_ADDR_EXP 125
33939: PUSH
33940: EMPTY
33941: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33942: LD_ADDR_EXP 100
33946: PUSH
33947: EMPTY
33948: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33949: LD_ADDR_EXP 101
33953: PUSH
33954: EMPTY
33955: ST_TO_ADDR
// mc_need_heal := [ ] ;
33956: LD_ADDR_EXP 102
33960: PUSH
33961: EMPTY
33962: ST_TO_ADDR
// mc_healers := [ ] ;
33963: LD_ADDR_EXP 103
33967: PUSH
33968: EMPTY
33969: ST_TO_ADDR
// mc_build_list := [ ] ;
33970: LD_ADDR_EXP 104
33974: PUSH
33975: EMPTY
33976: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33977: LD_ADDR_EXP 131
33981: PUSH
33982: EMPTY
33983: ST_TO_ADDR
// mc_builders := [ ] ;
33984: LD_ADDR_EXP 105
33988: PUSH
33989: EMPTY
33990: ST_TO_ADDR
// mc_construct_list := [ ] ;
33991: LD_ADDR_EXP 106
33995: PUSH
33996: EMPTY
33997: ST_TO_ADDR
// mc_turret_list := [ ] ;
33998: LD_ADDR_EXP 107
34002: PUSH
34003: EMPTY
34004: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34005: LD_ADDR_EXP 108
34009: PUSH
34010: EMPTY
34011: ST_TO_ADDR
// mc_miners := [ ] ;
34012: LD_ADDR_EXP 113
34016: PUSH
34017: EMPTY
34018: ST_TO_ADDR
// mc_mines := [ ] ;
34019: LD_ADDR_EXP 112
34023: PUSH
34024: EMPTY
34025: ST_TO_ADDR
// mc_minefields := [ ] ;
34026: LD_ADDR_EXP 114
34030: PUSH
34031: EMPTY
34032: ST_TO_ADDR
// mc_crates := [ ] ;
34033: LD_ADDR_EXP 115
34037: PUSH
34038: EMPTY
34039: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34040: LD_ADDR_EXP 116
34044: PUSH
34045: EMPTY
34046: ST_TO_ADDR
// mc_crates_area := [ ] ;
34047: LD_ADDR_EXP 117
34051: PUSH
34052: EMPTY
34053: ST_TO_ADDR
// mc_vehicles := [ ] ;
34054: LD_ADDR_EXP 118
34058: PUSH
34059: EMPTY
34060: ST_TO_ADDR
// mc_attack := [ ] ;
34061: LD_ADDR_EXP 119
34065: PUSH
34066: EMPTY
34067: ST_TO_ADDR
// mc_produce := [ ] ;
34068: LD_ADDR_EXP 120
34072: PUSH
34073: EMPTY
34074: ST_TO_ADDR
// mc_defender := [ ] ;
34075: LD_ADDR_EXP 121
34079: PUSH
34080: EMPTY
34081: ST_TO_ADDR
// mc_parking := [ ] ;
34082: LD_ADDR_EXP 123
34086: PUSH
34087: EMPTY
34088: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34089: LD_ADDR_EXP 109
34093: PUSH
34094: EMPTY
34095: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34096: LD_ADDR_EXP 111
34100: PUSH
34101: EMPTY
34102: ST_TO_ADDR
// mc_scan := [ ] ;
34103: LD_ADDR_EXP 122
34107: PUSH
34108: EMPTY
34109: ST_TO_ADDR
// mc_scan_area := [ ] ;
34110: LD_ADDR_EXP 124
34114: PUSH
34115: EMPTY
34116: ST_TO_ADDR
// mc_tech := [ ] ;
34117: LD_ADDR_EXP 126
34121: PUSH
34122: EMPTY
34123: ST_TO_ADDR
// mc_class := [ ] ;
34124: LD_ADDR_EXP 140
34128: PUSH
34129: EMPTY
34130: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34131: LD_ADDR_EXP 141
34135: PUSH
34136: EMPTY
34137: ST_TO_ADDR
// end ;
34138: LD_VAR 0 1
34142: RET
// export function MC_Kill ( base ) ; begin
34143: LD_INT 0
34145: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34146: LD_ADDR_EXP 99
34150: PUSH
34151: LD_EXP 99
34155: PPUSH
34156: LD_VAR 0 1
34160: PPUSH
34161: EMPTY
34162: PPUSH
34163: CALL_OW 1
34167: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34168: LD_ADDR_EXP 100
34172: PUSH
34173: LD_EXP 100
34177: PPUSH
34178: LD_VAR 0 1
34182: PPUSH
34183: EMPTY
34184: PPUSH
34185: CALL_OW 1
34189: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34190: LD_ADDR_EXP 101
34194: PUSH
34195: LD_EXP 101
34199: PPUSH
34200: LD_VAR 0 1
34204: PPUSH
34205: EMPTY
34206: PPUSH
34207: CALL_OW 1
34211: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34212: LD_ADDR_EXP 102
34216: PUSH
34217: LD_EXP 102
34221: PPUSH
34222: LD_VAR 0 1
34226: PPUSH
34227: EMPTY
34228: PPUSH
34229: CALL_OW 1
34233: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34234: LD_ADDR_EXP 103
34238: PUSH
34239: LD_EXP 103
34243: PPUSH
34244: LD_VAR 0 1
34248: PPUSH
34249: EMPTY
34250: PPUSH
34251: CALL_OW 1
34255: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34256: LD_ADDR_EXP 104
34260: PUSH
34261: LD_EXP 104
34265: PPUSH
34266: LD_VAR 0 1
34270: PPUSH
34271: EMPTY
34272: PPUSH
34273: CALL_OW 1
34277: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34278: LD_ADDR_EXP 105
34282: PUSH
34283: LD_EXP 105
34287: PPUSH
34288: LD_VAR 0 1
34292: PPUSH
34293: EMPTY
34294: PPUSH
34295: CALL_OW 1
34299: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34300: LD_ADDR_EXP 106
34304: PUSH
34305: LD_EXP 106
34309: PPUSH
34310: LD_VAR 0 1
34314: PPUSH
34315: EMPTY
34316: PPUSH
34317: CALL_OW 1
34321: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34322: LD_ADDR_EXP 107
34326: PUSH
34327: LD_EXP 107
34331: PPUSH
34332: LD_VAR 0 1
34336: PPUSH
34337: EMPTY
34338: PPUSH
34339: CALL_OW 1
34343: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34344: LD_ADDR_EXP 108
34348: PUSH
34349: LD_EXP 108
34353: PPUSH
34354: LD_VAR 0 1
34358: PPUSH
34359: EMPTY
34360: PPUSH
34361: CALL_OW 1
34365: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34366: LD_ADDR_EXP 109
34370: PUSH
34371: LD_EXP 109
34375: PPUSH
34376: LD_VAR 0 1
34380: PPUSH
34381: EMPTY
34382: PPUSH
34383: CALL_OW 1
34387: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34388: LD_ADDR_EXP 110
34392: PUSH
34393: LD_EXP 110
34397: PPUSH
34398: LD_VAR 0 1
34402: PPUSH
34403: LD_INT 0
34405: PPUSH
34406: CALL_OW 1
34410: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34411: LD_ADDR_EXP 111
34415: PUSH
34416: LD_EXP 111
34420: PPUSH
34421: LD_VAR 0 1
34425: PPUSH
34426: EMPTY
34427: PPUSH
34428: CALL_OW 1
34432: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34433: LD_ADDR_EXP 112
34437: PUSH
34438: LD_EXP 112
34442: PPUSH
34443: LD_VAR 0 1
34447: PPUSH
34448: EMPTY
34449: PPUSH
34450: CALL_OW 1
34454: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34455: LD_ADDR_EXP 113
34459: PUSH
34460: LD_EXP 113
34464: PPUSH
34465: LD_VAR 0 1
34469: PPUSH
34470: EMPTY
34471: PPUSH
34472: CALL_OW 1
34476: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34477: LD_ADDR_EXP 114
34481: PUSH
34482: LD_EXP 114
34486: PPUSH
34487: LD_VAR 0 1
34491: PPUSH
34492: EMPTY
34493: PPUSH
34494: CALL_OW 1
34498: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34499: LD_ADDR_EXP 115
34503: PUSH
34504: LD_EXP 115
34508: PPUSH
34509: LD_VAR 0 1
34513: PPUSH
34514: EMPTY
34515: PPUSH
34516: CALL_OW 1
34520: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34521: LD_ADDR_EXP 116
34525: PUSH
34526: LD_EXP 116
34530: PPUSH
34531: LD_VAR 0 1
34535: PPUSH
34536: EMPTY
34537: PPUSH
34538: CALL_OW 1
34542: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34543: LD_ADDR_EXP 117
34547: PUSH
34548: LD_EXP 117
34552: PPUSH
34553: LD_VAR 0 1
34557: PPUSH
34558: EMPTY
34559: PPUSH
34560: CALL_OW 1
34564: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34565: LD_ADDR_EXP 118
34569: PUSH
34570: LD_EXP 118
34574: PPUSH
34575: LD_VAR 0 1
34579: PPUSH
34580: EMPTY
34581: PPUSH
34582: CALL_OW 1
34586: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34587: LD_ADDR_EXP 119
34591: PUSH
34592: LD_EXP 119
34596: PPUSH
34597: LD_VAR 0 1
34601: PPUSH
34602: EMPTY
34603: PPUSH
34604: CALL_OW 1
34608: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34609: LD_ADDR_EXP 120
34613: PUSH
34614: LD_EXP 120
34618: PPUSH
34619: LD_VAR 0 1
34623: PPUSH
34624: EMPTY
34625: PPUSH
34626: CALL_OW 1
34630: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34631: LD_ADDR_EXP 121
34635: PUSH
34636: LD_EXP 121
34640: PPUSH
34641: LD_VAR 0 1
34645: PPUSH
34646: EMPTY
34647: PPUSH
34648: CALL_OW 1
34652: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34653: LD_ADDR_EXP 122
34657: PUSH
34658: LD_EXP 122
34662: PPUSH
34663: LD_VAR 0 1
34667: PPUSH
34668: EMPTY
34669: PPUSH
34670: CALL_OW 1
34674: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34675: LD_ADDR_EXP 123
34679: PUSH
34680: LD_EXP 123
34684: PPUSH
34685: LD_VAR 0 1
34689: PPUSH
34690: EMPTY
34691: PPUSH
34692: CALL_OW 1
34696: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34697: LD_ADDR_EXP 124
34701: PUSH
34702: LD_EXP 124
34706: PPUSH
34707: LD_VAR 0 1
34711: PPUSH
34712: EMPTY
34713: PPUSH
34714: CALL_OW 1
34718: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34719: LD_ADDR_EXP 126
34723: PUSH
34724: LD_EXP 126
34728: PPUSH
34729: LD_VAR 0 1
34733: PPUSH
34734: EMPTY
34735: PPUSH
34736: CALL_OW 1
34740: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34741: LD_ADDR_EXP 128
34745: PUSH
34746: LD_EXP 128
34750: PPUSH
34751: LD_VAR 0 1
34755: PPUSH
34756: EMPTY
34757: PPUSH
34758: CALL_OW 1
34762: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34763: LD_ADDR_EXP 129
34767: PUSH
34768: LD_EXP 129
34772: PPUSH
34773: LD_VAR 0 1
34777: PPUSH
34778: EMPTY
34779: PPUSH
34780: CALL_OW 1
34784: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34785: LD_ADDR_EXP 130
34789: PUSH
34790: LD_EXP 130
34794: PPUSH
34795: LD_VAR 0 1
34799: PPUSH
34800: EMPTY
34801: PPUSH
34802: CALL_OW 1
34806: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34807: LD_ADDR_EXP 131
34811: PUSH
34812: LD_EXP 131
34816: PPUSH
34817: LD_VAR 0 1
34821: PPUSH
34822: EMPTY
34823: PPUSH
34824: CALL_OW 1
34828: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34829: LD_ADDR_EXP 132
34833: PUSH
34834: LD_EXP 132
34838: PPUSH
34839: LD_VAR 0 1
34843: PPUSH
34844: EMPTY
34845: PPUSH
34846: CALL_OW 1
34850: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34851: LD_ADDR_EXP 133
34855: PUSH
34856: LD_EXP 133
34860: PPUSH
34861: LD_VAR 0 1
34865: PPUSH
34866: EMPTY
34867: PPUSH
34868: CALL_OW 1
34872: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34873: LD_ADDR_EXP 134
34877: PUSH
34878: LD_EXP 134
34882: PPUSH
34883: LD_VAR 0 1
34887: PPUSH
34888: EMPTY
34889: PPUSH
34890: CALL_OW 1
34894: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34895: LD_ADDR_EXP 135
34899: PUSH
34900: LD_EXP 135
34904: PPUSH
34905: LD_VAR 0 1
34909: PPUSH
34910: EMPTY
34911: PPUSH
34912: CALL_OW 1
34916: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34917: LD_ADDR_EXP 136
34921: PUSH
34922: LD_EXP 136
34926: PPUSH
34927: LD_VAR 0 1
34931: PPUSH
34932: EMPTY
34933: PPUSH
34934: CALL_OW 1
34938: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34939: LD_ADDR_EXP 137
34943: PUSH
34944: LD_EXP 137
34948: PPUSH
34949: LD_VAR 0 1
34953: PPUSH
34954: EMPTY
34955: PPUSH
34956: CALL_OW 1
34960: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34961: LD_ADDR_EXP 138
34965: PUSH
34966: LD_EXP 138
34970: PPUSH
34971: LD_VAR 0 1
34975: PPUSH
34976: EMPTY
34977: PPUSH
34978: CALL_OW 1
34982: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34983: LD_ADDR_EXP 139
34987: PUSH
34988: LD_EXP 139
34992: PPUSH
34993: LD_VAR 0 1
34997: PPUSH
34998: EMPTY
34999: PPUSH
35000: CALL_OW 1
35004: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35005: LD_ADDR_EXP 140
35009: PUSH
35010: LD_EXP 140
35014: PPUSH
35015: LD_VAR 0 1
35019: PPUSH
35020: EMPTY
35021: PPUSH
35022: CALL_OW 1
35026: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35027: LD_ADDR_EXP 141
35031: PUSH
35032: LD_EXP 141
35036: PPUSH
35037: LD_VAR 0 1
35041: PPUSH
35042: LD_INT 0
35044: PPUSH
35045: CALL_OW 1
35049: ST_TO_ADDR
// end ;
35050: LD_VAR 0 2
35054: RET
// export function MC_Add ( side , units ) ; var base ; begin
35055: LD_INT 0
35057: PPUSH
35058: PPUSH
// base := mc_bases + 1 ;
35059: LD_ADDR_VAR 0 4
35063: PUSH
35064: LD_EXP 99
35068: PUSH
35069: LD_INT 1
35071: PLUS
35072: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35073: LD_ADDR_EXP 125
35077: PUSH
35078: LD_EXP 125
35082: PPUSH
35083: LD_VAR 0 4
35087: PPUSH
35088: LD_VAR 0 1
35092: PPUSH
35093: CALL_OW 1
35097: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35098: LD_ADDR_EXP 99
35102: PUSH
35103: LD_EXP 99
35107: PPUSH
35108: LD_VAR 0 4
35112: PPUSH
35113: LD_VAR 0 2
35117: PPUSH
35118: CALL_OW 1
35122: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35123: LD_ADDR_EXP 100
35127: PUSH
35128: LD_EXP 100
35132: PPUSH
35133: LD_VAR 0 4
35137: PPUSH
35138: EMPTY
35139: PPUSH
35140: CALL_OW 1
35144: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35145: LD_ADDR_EXP 101
35149: PUSH
35150: LD_EXP 101
35154: PPUSH
35155: LD_VAR 0 4
35159: PPUSH
35160: EMPTY
35161: PPUSH
35162: CALL_OW 1
35166: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35167: LD_ADDR_EXP 102
35171: PUSH
35172: LD_EXP 102
35176: PPUSH
35177: LD_VAR 0 4
35181: PPUSH
35182: EMPTY
35183: PPUSH
35184: CALL_OW 1
35188: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35189: LD_ADDR_EXP 103
35193: PUSH
35194: LD_EXP 103
35198: PPUSH
35199: LD_VAR 0 4
35203: PPUSH
35204: EMPTY
35205: PPUSH
35206: CALL_OW 1
35210: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35211: LD_ADDR_EXP 104
35215: PUSH
35216: LD_EXP 104
35220: PPUSH
35221: LD_VAR 0 4
35225: PPUSH
35226: EMPTY
35227: PPUSH
35228: CALL_OW 1
35232: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35233: LD_ADDR_EXP 105
35237: PUSH
35238: LD_EXP 105
35242: PPUSH
35243: LD_VAR 0 4
35247: PPUSH
35248: EMPTY
35249: PPUSH
35250: CALL_OW 1
35254: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35255: LD_ADDR_EXP 106
35259: PUSH
35260: LD_EXP 106
35264: PPUSH
35265: LD_VAR 0 4
35269: PPUSH
35270: EMPTY
35271: PPUSH
35272: CALL_OW 1
35276: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35277: LD_ADDR_EXP 107
35281: PUSH
35282: LD_EXP 107
35286: PPUSH
35287: LD_VAR 0 4
35291: PPUSH
35292: EMPTY
35293: PPUSH
35294: CALL_OW 1
35298: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35299: LD_ADDR_EXP 108
35303: PUSH
35304: LD_EXP 108
35308: PPUSH
35309: LD_VAR 0 4
35313: PPUSH
35314: EMPTY
35315: PPUSH
35316: CALL_OW 1
35320: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35321: LD_ADDR_EXP 109
35325: PUSH
35326: LD_EXP 109
35330: PPUSH
35331: LD_VAR 0 4
35335: PPUSH
35336: EMPTY
35337: PPUSH
35338: CALL_OW 1
35342: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35343: LD_ADDR_EXP 110
35347: PUSH
35348: LD_EXP 110
35352: PPUSH
35353: LD_VAR 0 4
35357: PPUSH
35358: LD_INT 0
35360: PPUSH
35361: CALL_OW 1
35365: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35366: LD_ADDR_EXP 111
35370: PUSH
35371: LD_EXP 111
35375: PPUSH
35376: LD_VAR 0 4
35380: PPUSH
35381: EMPTY
35382: PPUSH
35383: CALL_OW 1
35387: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35388: LD_ADDR_EXP 112
35392: PUSH
35393: LD_EXP 112
35397: PPUSH
35398: LD_VAR 0 4
35402: PPUSH
35403: EMPTY
35404: PPUSH
35405: CALL_OW 1
35409: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35410: LD_ADDR_EXP 113
35414: PUSH
35415: LD_EXP 113
35419: PPUSH
35420: LD_VAR 0 4
35424: PPUSH
35425: EMPTY
35426: PPUSH
35427: CALL_OW 1
35431: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35432: LD_ADDR_EXP 114
35436: PUSH
35437: LD_EXP 114
35441: PPUSH
35442: LD_VAR 0 4
35446: PPUSH
35447: EMPTY
35448: PPUSH
35449: CALL_OW 1
35453: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35454: LD_ADDR_EXP 115
35458: PUSH
35459: LD_EXP 115
35463: PPUSH
35464: LD_VAR 0 4
35468: PPUSH
35469: EMPTY
35470: PPUSH
35471: CALL_OW 1
35475: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35476: LD_ADDR_EXP 116
35480: PUSH
35481: LD_EXP 116
35485: PPUSH
35486: LD_VAR 0 4
35490: PPUSH
35491: EMPTY
35492: PPUSH
35493: CALL_OW 1
35497: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35498: LD_ADDR_EXP 117
35502: PUSH
35503: LD_EXP 117
35507: PPUSH
35508: LD_VAR 0 4
35512: PPUSH
35513: EMPTY
35514: PPUSH
35515: CALL_OW 1
35519: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35520: LD_ADDR_EXP 118
35524: PUSH
35525: LD_EXP 118
35529: PPUSH
35530: LD_VAR 0 4
35534: PPUSH
35535: EMPTY
35536: PPUSH
35537: CALL_OW 1
35541: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35542: LD_ADDR_EXP 119
35546: PUSH
35547: LD_EXP 119
35551: PPUSH
35552: LD_VAR 0 4
35556: PPUSH
35557: EMPTY
35558: PPUSH
35559: CALL_OW 1
35563: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35564: LD_ADDR_EXP 120
35568: PUSH
35569: LD_EXP 120
35573: PPUSH
35574: LD_VAR 0 4
35578: PPUSH
35579: EMPTY
35580: PPUSH
35581: CALL_OW 1
35585: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35586: LD_ADDR_EXP 121
35590: PUSH
35591: LD_EXP 121
35595: PPUSH
35596: LD_VAR 0 4
35600: PPUSH
35601: EMPTY
35602: PPUSH
35603: CALL_OW 1
35607: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35608: LD_ADDR_EXP 122
35612: PUSH
35613: LD_EXP 122
35617: PPUSH
35618: LD_VAR 0 4
35622: PPUSH
35623: EMPTY
35624: PPUSH
35625: CALL_OW 1
35629: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35630: LD_ADDR_EXP 123
35634: PUSH
35635: LD_EXP 123
35639: PPUSH
35640: LD_VAR 0 4
35644: PPUSH
35645: EMPTY
35646: PPUSH
35647: CALL_OW 1
35651: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35652: LD_ADDR_EXP 124
35656: PUSH
35657: LD_EXP 124
35661: PPUSH
35662: LD_VAR 0 4
35666: PPUSH
35667: EMPTY
35668: PPUSH
35669: CALL_OW 1
35673: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35674: LD_ADDR_EXP 126
35678: PUSH
35679: LD_EXP 126
35683: PPUSH
35684: LD_VAR 0 4
35688: PPUSH
35689: EMPTY
35690: PPUSH
35691: CALL_OW 1
35695: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35696: LD_ADDR_EXP 128
35700: PUSH
35701: LD_EXP 128
35705: PPUSH
35706: LD_VAR 0 4
35710: PPUSH
35711: EMPTY
35712: PPUSH
35713: CALL_OW 1
35717: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35718: LD_ADDR_EXP 129
35722: PUSH
35723: LD_EXP 129
35727: PPUSH
35728: LD_VAR 0 4
35732: PPUSH
35733: EMPTY
35734: PPUSH
35735: CALL_OW 1
35739: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35740: LD_ADDR_EXP 130
35744: PUSH
35745: LD_EXP 130
35749: PPUSH
35750: LD_VAR 0 4
35754: PPUSH
35755: EMPTY
35756: PPUSH
35757: CALL_OW 1
35761: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35762: LD_ADDR_EXP 131
35766: PUSH
35767: LD_EXP 131
35771: PPUSH
35772: LD_VAR 0 4
35776: PPUSH
35777: EMPTY
35778: PPUSH
35779: CALL_OW 1
35783: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35784: LD_ADDR_EXP 132
35788: PUSH
35789: LD_EXP 132
35793: PPUSH
35794: LD_VAR 0 4
35798: PPUSH
35799: EMPTY
35800: PPUSH
35801: CALL_OW 1
35805: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35806: LD_ADDR_EXP 133
35810: PUSH
35811: LD_EXP 133
35815: PPUSH
35816: LD_VAR 0 4
35820: PPUSH
35821: EMPTY
35822: PPUSH
35823: CALL_OW 1
35827: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35828: LD_ADDR_EXP 134
35832: PUSH
35833: LD_EXP 134
35837: PPUSH
35838: LD_VAR 0 4
35842: PPUSH
35843: EMPTY
35844: PPUSH
35845: CALL_OW 1
35849: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35850: LD_ADDR_EXP 135
35854: PUSH
35855: LD_EXP 135
35859: PPUSH
35860: LD_VAR 0 4
35864: PPUSH
35865: EMPTY
35866: PPUSH
35867: CALL_OW 1
35871: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35872: LD_ADDR_EXP 136
35876: PUSH
35877: LD_EXP 136
35881: PPUSH
35882: LD_VAR 0 4
35886: PPUSH
35887: EMPTY
35888: PPUSH
35889: CALL_OW 1
35893: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35894: LD_ADDR_EXP 137
35898: PUSH
35899: LD_EXP 137
35903: PPUSH
35904: LD_VAR 0 4
35908: PPUSH
35909: EMPTY
35910: PPUSH
35911: CALL_OW 1
35915: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35916: LD_ADDR_EXP 138
35920: PUSH
35921: LD_EXP 138
35925: PPUSH
35926: LD_VAR 0 4
35930: PPUSH
35931: EMPTY
35932: PPUSH
35933: CALL_OW 1
35937: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35938: LD_ADDR_EXP 139
35942: PUSH
35943: LD_EXP 139
35947: PPUSH
35948: LD_VAR 0 4
35952: PPUSH
35953: EMPTY
35954: PPUSH
35955: CALL_OW 1
35959: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35960: LD_ADDR_EXP 140
35964: PUSH
35965: LD_EXP 140
35969: PPUSH
35970: LD_VAR 0 4
35974: PPUSH
35975: EMPTY
35976: PPUSH
35977: CALL_OW 1
35981: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35982: LD_ADDR_EXP 141
35986: PUSH
35987: LD_EXP 141
35991: PPUSH
35992: LD_VAR 0 4
35996: PPUSH
35997: LD_INT 0
35999: PPUSH
36000: CALL_OW 1
36004: ST_TO_ADDR
// result := base ;
36005: LD_ADDR_VAR 0 3
36009: PUSH
36010: LD_VAR 0 4
36014: ST_TO_ADDR
// end ;
36015: LD_VAR 0 3
36019: RET
// export function MC_Start ( ) ; var i ; begin
36020: LD_INT 0
36022: PPUSH
36023: PPUSH
// for i = 1 to mc_bases do
36024: LD_ADDR_VAR 0 2
36028: PUSH
36029: DOUBLE
36030: LD_INT 1
36032: DEC
36033: ST_TO_ADDR
36034: LD_EXP 99
36038: PUSH
36039: FOR_TO
36040: IFFALSE 37117
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36042: LD_ADDR_EXP 99
36046: PUSH
36047: LD_EXP 99
36051: PPUSH
36052: LD_VAR 0 2
36056: PPUSH
36057: LD_EXP 99
36061: PUSH
36062: LD_VAR 0 2
36066: ARRAY
36067: PUSH
36068: LD_INT 0
36070: DIFF
36071: PPUSH
36072: CALL_OW 1
36076: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36077: LD_ADDR_EXP 100
36081: PUSH
36082: LD_EXP 100
36086: PPUSH
36087: LD_VAR 0 2
36091: PPUSH
36092: EMPTY
36093: PPUSH
36094: CALL_OW 1
36098: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36099: LD_ADDR_EXP 101
36103: PUSH
36104: LD_EXP 101
36108: PPUSH
36109: LD_VAR 0 2
36113: PPUSH
36114: EMPTY
36115: PPUSH
36116: CALL_OW 1
36120: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36121: LD_ADDR_EXP 102
36125: PUSH
36126: LD_EXP 102
36130: PPUSH
36131: LD_VAR 0 2
36135: PPUSH
36136: EMPTY
36137: PPUSH
36138: CALL_OW 1
36142: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36143: LD_ADDR_EXP 103
36147: PUSH
36148: LD_EXP 103
36152: PPUSH
36153: LD_VAR 0 2
36157: PPUSH
36158: EMPTY
36159: PUSH
36160: EMPTY
36161: PUSH
36162: EMPTY
36163: LIST
36164: LIST
36165: PPUSH
36166: CALL_OW 1
36170: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36171: LD_ADDR_EXP 104
36175: PUSH
36176: LD_EXP 104
36180: PPUSH
36181: LD_VAR 0 2
36185: PPUSH
36186: EMPTY
36187: PPUSH
36188: CALL_OW 1
36192: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36193: LD_ADDR_EXP 131
36197: PUSH
36198: LD_EXP 131
36202: PPUSH
36203: LD_VAR 0 2
36207: PPUSH
36208: EMPTY
36209: PPUSH
36210: CALL_OW 1
36214: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36215: LD_ADDR_EXP 105
36219: PUSH
36220: LD_EXP 105
36224: PPUSH
36225: LD_VAR 0 2
36229: PPUSH
36230: EMPTY
36231: PPUSH
36232: CALL_OW 1
36236: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36237: LD_ADDR_EXP 106
36241: PUSH
36242: LD_EXP 106
36246: PPUSH
36247: LD_VAR 0 2
36251: PPUSH
36252: EMPTY
36253: PPUSH
36254: CALL_OW 1
36258: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36259: LD_ADDR_EXP 107
36263: PUSH
36264: LD_EXP 107
36268: PPUSH
36269: LD_VAR 0 2
36273: PPUSH
36274: LD_EXP 99
36278: PUSH
36279: LD_VAR 0 2
36283: ARRAY
36284: PPUSH
36285: LD_INT 2
36287: PUSH
36288: LD_INT 30
36290: PUSH
36291: LD_INT 32
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 30
36300: PUSH
36301: LD_INT 33
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: EMPTY
36309: LIST
36310: LIST
36311: LIST
36312: PPUSH
36313: CALL_OW 72
36317: PPUSH
36318: CALL_OW 1
36322: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36323: LD_ADDR_EXP 108
36327: PUSH
36328: LD_EXP 108
36332: PPUSH
36333: LD_VAR 0 2
36337: PPUSH
36338: LD_EXP 99
36342: PUSH
36343: LD_VAR 0 2
36347: ARRAY
36348: PPUSH
36349: LD_INT 2
36351: PUSH
36352: LD_INT 30
36354: PUSH
36355: LD_INT 32
36357: PUSH
36358: EMPTY
36359: LIST
36360: LIST
36361: PUSH
36362: LD_INT 30
36364: PUSH
36365: LD_INT 31
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 58
36379: PUSH
36380: EMPTY
36381: LIST
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PPUSH
36387: CALL_OW 72
36391: PPUSH
36392: CALL_OW 1
36396: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36397: LD_ADDR_EXP 109
36401: PUSH
36402: LD_EXP 109
36406: PPUSH
36407: LD_VAR 0 2
36411: PPUSH
36412: EMPTY
36413: PPUSH
36414: CALL_OW 1
36418: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36419: LD_ADDR_EXP 113
36423: PUSH
36424: LD_EXP 113
36428: PPUSH
36429: LD_VAR 0 2
36433: PPUSH
36434: EMPTY
36435: PPUSH
36436: CALL_OW 1
36440: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36441: LD_ADDR_EXP 112
36445: PUSH
36446: LD_EXP 112
36450: PPUSH
36451: LD_VAR 0 2
36455: PPUSH
36456: EMPTY
36457: PPUSH
36458: CALL_OW 1
36462: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36463: LD_ADDR_EXP 114
36467: PUSH
36468: LD_EXP 114
36472: PPUSH
36473: LD_VAR 0 2
36477: PPUSH
36478: EMPTY
36479: PPUSH
36480: CALL_OW 1
36484: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36485: LD_ADDR_EXP 115
36489: PUSH
36490: LD_EXP 115
36494: PPUSH
36495: LD_VAR 0 2
36499: PPUSH
36500: EMPTY
36501: PPUSH
36502: CALL_OW 1
36506: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36507: LD_ADDR_EXP 116
36511: PUSH
36512: LD_EXP 116
36516: PPUSH
36517: LD_VAR 0 2
36521: PPUSH
36522: EMPTY
36523: PPUSH
36524: CALL_OW 1
36528: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36529: LD_ADDR_EXP 117
36533: PUSH
36534: LD_EXP 117
36538: PPUSH
36539: LD_VAR 0 2
36543: PPUSH
36544: EMPTY
36545: PPUSH
36546: CALL_OW 1
36550: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36551: LD_ADDR_EXP 118
36555: PUSH
36556: LD_EXP 118
36560: PPUSH
36561: LD_VAR 0 2
36565: PPUSH
36566: EMPTY
36567: PPUSH
36568: CALL_OW 1
36572: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36573: LD_ADDR_EXP 119
36577: PUSH
36578: LD_EXP 119
36582: PPUSH
36583: LD_VAR 0 2
36587: PPUSH
36588: EMPTY
36589: PPUSH
36590: CALL_OW 1
36594: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36595: LD_ADDR_EXP 120
36599: PUSH
36600: LD_EXP 120
36604: PPUSH
36605: LD_VAR 0 2
36609: PPUSH
36610: EMPTY
36611: PPUSH
36612: CALL_OW 1
36616: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36617: LD_ADDR_EXP 121
36621: PUSH
36622: LD_EXP 121
36626: PPUSH
36627: LD_VAR 0 2
36631: PPUSH
36632: EMPTY
36633: PPUSH
36634: CALL_OW 1
36638: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36639: LD_ADDR_EXP 110
36643: PUSH
36644: LD_EXP 110
36648: PPUSH
36649: LD_VAR 0 2
36653: PPUSH
36654: LD_INT 0
36656: PPUSH
36657: CALL_OW 1
36661: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36662: LD_ADDR_EXP 123
36666: PUSH
36667: LD_EXP 123
36671: PPUSH
36672: LD_VAR 0 2
36676: PPUSH
36677: LD_INT 0
36679: PPUSH
36680: CALL_OW 1
36684: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36685: LD_ADDR_EXP 111
36689: PUSH
36690: LD_EXP 111
36694: PPUSH
36695: LD_VAR 0 2
36699: PPUSH
36700: EMPTY
36701: PPUSH
36702: CALL_OW 1
36706: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36707: LD_ADDR_EXP 122
36711: PUSH
36712: LD_EXP 122
36716: PPUSH
36717: LD_VAR 0 2
36721: PPUSH
36722: LD_INT 0
36724: PPUSH
36725: CALL_OW 1
36729: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36730: LD_ADDR_EXP 124
36734: PUSH
36735: LD_EXP 124
36739: PPUSH
36740: LD_VAR 0 2
36744: PPUSH
36745: EMPTY
36746: PPUSH
36747: CALL_OW 1
36751: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36752: LD_ADDR_EXP 127
36756: PUSH
36757: LD_EXP 127
36761: PPUSH
36762: LD_VAR 0 2
36766: PPUSH
36767: LD_INT 0
36769: PPUSH
36770: CALL_OW 1
36774: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36775: LD_ADDR_EXP 128
36779: PUSH
36780: LD_EXP 128
36784: PPUSH
36785: LD_VAR 0 2
36789: PPUSH
36790: EMPTY
36791: PPUSH
36792: CALL_OW 1
36796: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36797: LD_ADDR_EXP 129
36801: PUSH
36802: LD_EXP 129
36806: PPUSH
36807: LD_VAR 0 2
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36819: LD_ADDR_EXP 130
36823: PUSH
36824: LD_EXP 130
36828: PPUSH
36829: LD_VAR 0 2
36833: PPUSH
36834: EMPTY
36835: PPUSH
36836: CALL_OW 1
36840: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36841: LD_ADDR_EXP 132
36845: PUSH
36846: LD_EXP 132
36850: PPUSH
36851: LD_VAR 0 2
36855: PPUSH
36856: LD_EXP 99
36860: PUSH
36861: LD_VAR 0 2
36865: ARRAY
36866: PPUSH
36867: LD_INT 2
36869: PUSH
36870: LD_INT 30
36872: PUSH
36873: LD_INT 6
36875: PUSH
36876: EMPTY
36877: LIST
36878: LIST
36879: PUSH
36880: LD_INT 30
36882: PUSH
36883: LD_INT 7
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: PUSH
36890: LD_INT 30
36892: PUSH
36893: LD_INT 8
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: LIST
36904: LIST
36905: PPUSH
36906: CALL_OW 72
36910: PPUSH
36911: CALL_OW 1
36915: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36916: LD_ADDR_EXP 133
36920: PUSH
36921: LD_EXP 133
36925: PPUSH
36926: LD_VAR 0 2
36930: PPUSH
36931: EMPTY
36932: PPUSH
36933: CALL_OW 1
36937: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36938: LD_ADDR_EXP 134
36942: PUSH
36943: LD_EXP 134
36947: PPUSH
36948: LD_VAR 0 2
36952: PPUSH
36953: EMPTY
36954: PPUSH
36955: CALL_OW 1
36959: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36960: LD_ADDR_EXP 135
36964: PUSH
36965: LD_EXP 135
36969: PPUSH
36970: LD_VAR 0 2
36974: PPUSH
36975: EMPTY
36976: PPUSH
36977: CALL_OW 1
36981: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
36982: LD_ADDR_EXP 136
36986: PUSH
36987: LD_EXP 136
36991: PPUSH
36992: LD_VAR 0 2
36996: PPUSH
36997: EMPTY
36998: PPUSH
36999: CALL_OW 1
37003: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37004: LD_ADDR_EXP 137
37008: PUSH
37009: LD_EXP 137
37013: PPUSH
37014: LD_VAR 0 2
37018: PPUSH
37019: EMPTY
37020: PPUSH
37021: CALL_OW 1
37025: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37026: LD_ADDR_EXP 138
37030: PUSH
37031: LD_EXP 138
37035: PPUSH
37036: LD_VAR 0 2
37040: PPUSH
37041: EMPTY
37042: PPUSH
37043: CALL_OW 1
37047: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37048: LD_ADDR_EXP 139
37052: PUSH
37053: LD_EXP 139
37057: PPUSH
37058: LD_VAR 0 2
37062: PPUSH
37063: EMPTY
37064: PPUSH
37065: CALL_OW 1
37069: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37070: LD_ADDR_EXP 140
37074: PUSH
37075: LD_EXP 140
37079: PPUSH
37080: LD_VAR 0 2
37084: PPUSH
37085: EMPTY
37086: PPUSH
37087: CALL_OW 1
37091: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37092: LD_ADDR_EXP 141
37096: PUSH
37097: LD_EXP 141
37101: PPUSH
37102: LD_VAR 0 2
37106: PPUSH
37107: LD_INT 0
37109: PPUSH
37110: CALL_OW 1
37114: ST_TO_ADDR
// end ;
37115: GO 36039
37117: POP
37118: POP
// MC_InitSides ( ) ;
37119: CALL 37405 0 0
// MC_InitResearch ( ) ;
37123: CALL 37144 0 0
// CustomInitMacro ( ) ;
37127: CALL 444 0 0
// skirmish := true ;
37131: LD_ADDR_EXP 97
37135: PUSH
37136: LD_INT 1
37138: ST_TO_ADDR
// end ;
37139: LD_VAR 0 1
37143: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37144: LD_INT 0
37146: PPUSH
37147: PPUSH
37148: PPUSH
37149: PPUSH
37150: PPUSH
37151: PPUSH
// if not mc_bases then
37152: LD_EXP 99
37156: NOT
37157: IFFALSE 37161
// exit ;
37159: GO 37400
// for i = 1 to 8 do
37161: LD_ADDR_VAR 0 2
37165: PUSH
37166: DOUBLE
37167: LD_INT 1
37169: DEC
37170: ST_TO_ADDR
37171: LD_INT 8
37173: PUSH
37174: FOR_TO
37175: IFFALSE 37201
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37177: LD_ADDR_EXP 126
37181: PUSH
37182: LD_EXP 126
37186: PPUSH
37187: LD_VAR 0 2
37191: PPUSH
37192: EMPTY
37193: PPUSH
37194: CALL_OW 1
37198: ST_TO_ADDR
37199: GO 37174
37201: POP
37202: POP
// tmp := [ ] ;
37203: LD_ADDR_VAR 0 5
37207: PUSH
37208: EMPTY
37209: ST_TO_ADDR
// for i = 1 to mc_sides do
37210: LD_ADDR_VAR 0 2
37214: PUSH
37215: DOUBLE
37216: LD_INT 1
37218: DEC
37219: ST_TO_ADDR
37220: LD_EXP 125
37224: PUSH
37225: FOR_TO
37226: IFFALSE 37284
// if not mc_sides [ i ] in tmp then
37228: LD_EXP 125
37232: PUSH
37233: LD_VAR 0 2
37237: ARRAY
37238: PUSH
37239: LD_VAR 0 5
37243: IN
37244: NOT
37245: IFFALSE 37282
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37247: LD_ADDR_VAR 0 5
37251: PUSH
37252: LD_VAR 0 5
37256: PPUSH
37257: LD_VAR 0 5
37261: PUSH
37262: LD_INT 1
37264: PLUS
37265: PPUSH
37266: LD_EXP 125
37270: PUSH
37271: LD_VAR 0 2
37275: ARRAY
37276: PPUSH
37277: CALL_OW 2
37281: ST_TO_ADDR
37282: GO 37225
37284: POP
37285: POP
// if not tmp then
37286: LD_VAR 0 5
37290: NOT
37291: IFFALSE 37295
// exit ;
37293: GO 37400
// for j in tmp do
37295: LD_ADDR_VAR 0 3
37299: PUSH
37300: LD_VAR 0 5
37304: PUSH
37305: FOR_IN
37306: IFFALSE 37398
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37308: LD_ADDR_VAR 0 6
37312: PUSH
37313: LD_INT 22
37315: PUSH
37316: LD_VAR 0 3
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PPUSH
37325: CALL_OW 69
37329: ST_TO_ADDR
// if not un then
37330: LD_VAR 0 6
37334: NOT
37335: IFFALSE 37339
// continue ;
37337: GO 37305
// nation := GetNation ( un [ 1 ] ) ;
37339: LD_ADDR_VAR 0 4
37343: PUSH
37344: LD_VAR 0 6
37348: PUSH
37349: LD_INT 1
37351: ARRAY
37352: PPUSH
37353: CALL_OW 248
37357: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37358: LD_ADDR_EXP 126
37362: PUSH
37363: LD_EXP 126
37367: PPUSH
37368: LD_VAR 0 3
37372: PPUSH
37373: LD_VAR 0 3
37377: PPUSH
37378: LD_VAR 0 4
37382: PPUSH
37383: LD_INT 1
37385: PPUSH
37386: CALL 63764 0 3
37390: PPUSH
37391: CALL_OW 1
37395: ST_TO_ADDR
// end ;
37396: GO 37305
37398: POP
37399: POP
// end ;
37400: LD_VAR 0 1
37404: RET
// export function MC_InitSides ( ) ; var i ; begin
37405: LD_INT 0
37407: PPUSH
37408: PPUSH
// if not mc_bases then
37409: LD_EXP 99
37413: NOT
37414: IFFALSE 37418
// exit ;
37416: GO 37492
// for i = 1 to mc_bases do
37418: LD_ADDR_VAR 0 2
37422: PUSH
37423: DOUBLE
37424: LD_INT 1
37426: DEC
37427: ST_TO_ADDR
37428: LD_EXP 99
37432: PUSH
37433: FOR_TO
37434: IFFALSE 37490
// if mc_bases [ i ] then
37436: LD_EXP 99
37440: PUSH
37441: LD_VAR 0 2
37445: ARRAY
37446: IFFALSE 37488
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37448: LD_ADDR_EXP 125
37452: PUSH
37453: LD_EXP 125
37457: PPUSH
37458: LD_VAR 0 2
37462: PPUSH
37463: LD_EXP 99
37467: PUSH
37468: LD_VAR 0 2
37472: ARRAY
37473: PUSH
37474: LD_INT 1
37476: ARRAY
37477: PPUSH
37478: CALL_OW 255
37482: PPUSH
37483: CALL_OW 1
37487: ST_TO_ADDR
37488: GO 37433
37490: POP
37491: POP
// end ;
37492: LD_VAR 0 1
37496: RET
// every 0 0$01 trigger skirmish do
37497: LD_EXP 97
37501: IFFALSE 37655
37503: GO 37505
37505: DISABLE
// begin enable ;
37506: ENABLE
// MC_CheckBuildings ( ) ;
37507: CALL 42153 0 0
// MC_CheckPeopleLife ( ) ;
37511: CALL 42278 0 0
// RaiseSailEvent ( 100 ) ;
37515: LD_INT 100
37517: PPUSH
37518: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37522: LD_INT 103
37524: PPUSH
37525: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37529: LD_INT 104
37531: PPUSH
37532: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37536: LD_INT 105
37538: PPUSH
37539: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37543: LD_INT 106
37545: PPUSH
37546: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37550: LD_INT 107
37552: PPUSH
37553: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37557: LD_INT 108
37559: PPUSH
37560: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37564: LD_INT 109
37566: PPUSH
37567: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37571: LD_INT 110
37573: PPUSH
37574: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37578: LD_INT 111
37580: PPUSH
37581: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37585: LD_INT 112
37587: PPUSH
37588: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37592: LD_INT 113
37594: PPUSH
37595: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37599: LD_INT 120
37601: PPUSH
37602: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37606: LD_INT 121
37608: PPUSH
37609: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37613: LD_INT 122
37615: PPUSH
37616: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37620: LD_INT 123
37622: PPUSH
37623: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37627: LD_INT 124
37629: PPUSH
37630: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37634: LD_INT 125
37636: PPUSH
37637: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37641: LD_INT 126
37643: PPUSH
37644: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37648: LD_INT 200
37650: PPUSH
37651: CALL_OW 427
// end ;
37655: END
// on SailEvent ( event ) do begin if event < 100 then
37656: LD_VAR 0 1
37660: PUSH
37661: LD_INT 100
37663: LESS
37664: IFFALSE 37675
// CustomEvent ( event ) ;
37666: LD_VAR 0 1
37670: PPUSH
37671: CALL 32338 0 1
// if event = 100 then
37675: LD_VAR 0 1
37679: PUSH
37680: LD_INT 100
37682: EQUAL
37683: IFFALSE 37689
// MC_ClassManager ( ) ;
37685: CALL 38081 0 0
// if event = 101 then
37689: LD_VAR 0 1
37693: PUSH
37694: LD_INT 101
37696: EQUAL
37697: IFFALSE 37703
// MC_RepairBuildings ( ) ;
37699: CALL 42874 0 0
// if event = 102 then
37703: LD_VAR 0 1
37707: PUSH
37708: LD_INT 102
37710: EQUAL
37711: IFFALSE 37717
// MC_Heal ( ) ;
37713: CALL 43606 0 0
// if event = 103 then
37717: LD_VAR 0 1
37721: PUSH
37722: LD_INT 103
37724: EQUAL
37725: IFFALSE 37731
// MC_Build ( ) ;
37727: CALL 44028 0 0
// if event = 104 then
37731: LD_VAR 0 1
37735: PUSH
37736: LD_INT 104
37738: EQUAL
37739: IFFALSE 37745
// MC_TurretWeapon ( ) ;
37741: CALL 45641 0 0
// if event = 105 then
37745: LD_VAR 0 1
37749: PUSH
37750: LD_INT 105
37752: EQUAL
37753: IFFALSE 37759
// MC_BuildUpgrade ( ) ;
37755: CALL 45192 0 0
// if event = 106 then
37759: LD_VAR 0 1
37763: PUSH
37764: LD_INT 106
37766: EQUAL
37767: IFFALSE 37773
// MC_PlantMines ( ) ;
37769: CALL 46071 0 0
// if event = 107 then
37773: LD_VAR 0 1
37777: PUSH
37778: LD_INT 107
37780: EQUAL
37781: IFFALSE 37787
// MC_CollectCrates ( ) ;
37783: CALL 47105 0 0
// if event = 108 then
37787: LD_VAR 0 1
37791: PUSH
37792: LD_INT 108
37794: EQUAL
37795: IFFALSE 37801
// MC_LinkRemoteControl ( ) ;
37797: CALL 48881 0 0
// if event = 109 then
37801: LD_VAR 0 1
37805: PUSH
37806: LD_INT 109
37808: EQUAL
37809: IFFALSE 37815
// MC_ProduceVehicle ( ) ;
37811: CALL 49062 0 0
// if event = 110 then
37815: LD_VAR 0 1
37819: PUSH
37820: LD_INT 110
37822: EQUAL
37823: IFFALSE 37829
// MC_SendAttack ( ) ;
37825: CALL 49528 0 0
// if event = 111 then
37829: LD_VAR 0 1
37833: PUSH
37834: LD_INT 111
37836: EQUAL
37837: IFFALSE 37843
// MC_Defend ( ) ;
37839: CALL 49636 0 0
// if event = 112 then
37843: LD_VAR 0 1
37847: PUSH
37848: LD_INT 112
37850: EQUAL
37851: IFFALSE 37857
// MC_Research ( ) ;
37853: CALL 50241 0 0
// if event = 113 then
37857: LD_VAR 0 1
37861: PUSH
37862: LD_INT 113
37864: EQUAL
37865: IFFALSE 37871
// MC_MinesTrigger ( ) ;
37867: CALL 51355 0 0
// if event = 120 then
37871: LD_VAR 0 1
37875: PUSH
37876: LD_INT 120
37878: EQUAL
37879: IFFALSE 37885
// MC_RepairVehicle ( ) ;
37881: CALL 51454 0 0
// if event = 121 then
37885: LD_VAR 0 1
37889: PUSH
37890: LD_INT 121
37892: EQUAL
37893: IFFALSE 37899
// MC_TameApe ( ) ;
37895: CALL 52184 0 0
// if event = 122 then
37899: LD_VAR 0 1
37903: PUSH
37904: LD_INT 122
37906: EQUAL
37907: IFFALSE 37913
// MC_ChangeApeClass ( ) ;
37909: CALL 53013 0 0
// if event = 123 then
37913: LD_VAR 0 1
37917: PUSH
37918: LD_INT 123
37920: EQUAL
37921: IFFALSE 37927
// MC_Bazooka ( ) ;
37923: CALL 53663 0 0
// if event = 124 then
37927: LD_VAR 0 1
37931: PUSH
37932: LD_INT 124
37934: EQUAL
37935: IFFALSE 37941
// MC_TeleportExit ( ) ;
37937: CALL 53861 0 0
// if event = 125 then
37941: LD_VAR 0 1
37945: PUSH
37946: LD_INT 125
37948: EQUAL
37949: IFFALSE 37955
// MC_Deposits ( ) ;
37951: CALL 54508 0 0
// if event = 126 then
37955: LD_VAR 0 1
37959: PUSH
37960: LD_INT 126
37962: EQUAL
37963: IFFALSE 37969
// MC_RemoteDriver ( ) ;
37965: CALL 55133 0 0
// if event = 200 then
37969: LD_VAR 0 1
37973: PUSH
37974: LD_INT 200
37976: EQUAL
37977: IFFALSE 37983
// MC_Idle ( ) ;
37979: CALL 56866 0 0
// end ;
37983: PPOPN 1
37985: END
// export function MC_Reset ( base , tag ) ; var i ; begin
37986: LD_INT 0
37988: PPUSH
37989: PPUSH
// if not mc_bases [ base ] or not tag then
37990: LD_EXP 99
37994: PUSH
37995: LD_VAR 0 1
37999: ARRAY
38000: NOT
38001: PUSH
38002: LD_VAR 0 2
38006: NOT
38007: OR
38008: IFFALSE 38012
// exit ;
38010: GO 38076
// for i in mc_bases [ base ] union mc_ape [ base ] do
38012: LD_ADDR_VAR 0 4
38016: PUSH
38017: LD_EXP 99
38021: PUSH
38022: LD_VAR 0 1
38026: ARRAY
38027: PUSH
38028: LD_EXP 128
38032: PUSH
38033: LD_VAR 0 1
38037: ARRAY
38038: UNION
38039: PUSH
38040: FOR_IN
38041: IFFALSE 38074
// if GetTag ( i ) = tag then
38043: LD_VAR 0 4
38047: PPUSH
38048: CALL_OW 110
38052: PUSH
38053: LD_VAR 0 2
38057: EQUAL
38058: IFFALSE 38072
// SetTag ( i , 0 ) ;
38060: LD_VAR 0 4
38064: PPUSH
38065: LD_INT 0
38067: PPUSH
38068: CALL_OW 109
38072: GO 38040
38074: POP
38075: POP
// end ;
38076: LD_VAR 0 3
38080: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38081: LD_INT 0
38083: PPUSH
38084: PPUSH
38085: PPUSH
38086: PPUSH
38087: PPUSH
38088: PPUSH
38089: PPUSH
38090: PPUSH
// if not mc_bases then
38091: LD_EXP 99
38095: NOT
38096: IFFALSE 38100
// exit ;
38098: GO 38558
// for i = 1 to mc_bases do
38100: LD_ADDR_VAR 0 2
38104: PUSH
38105: DOUBLE
38106: LD_INT 1
38108: DEC
38109: ST_TO_ADDR
38110: LD_EXP 99
38114: PUSH
38115: FOR_TO
38116: IFFALSE 38556
// begin tmp := MC_ClassCheckReq ( i ) ;
38118: LD_ADDR_VAR 0 4
38122: PUSH
38123: LD_VAR 0 2
38127: PPUSH
38128: CALL 38563 0 1
38132: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38133: LD_ADDR_EXP 140
38137: PUSH
38138: LD_EXP 140
38142: PPUSH
38143: LD_VAR 0 2
38147: PPUSH
38148: LD_VAR 0 4
38152: PPUSH
38153: CALL_OW 1
38157: ST_TO_ADDR
// if not tmp then
38158: LD_VAR 0 4
38162: NOT
38163: IFFALSE 38167
// continue ;
38165: GO 38115
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38167: LD_ADDR_VAR 0 6
38171: PUSH
38172: LD_EXP 99
38176: PUSH
38177: LD_VAR 0 2
38181: ARRAY
38182: PPUSH
38183: LD_INT 2
38185: PUSH
38186: LD_INT 30
38188: PUSH
38189: LD_INT 4
38191: PUSH
38192: EMPTY
38193: LIST
38194: LIST
38195: PUSH
38196: LD_INT 30
38198: PUSH
38199: LD_INT 5
38201: PUSH
38202: EMPTY
38203: LIST
38204: LIST
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: LIST
38210: PPUSH
38211: CALL_OW 72
38215: PUSH
38216: LD_EXP 99
38220: PUSH
38221: LD_VAR 0 2
38225: ARRAY
38226: PPUSH
38227: LD_INT 2
38229: PUSH
38230: LD_INT 30
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 30
38242: PUSH
38243: LD_INT 1
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: LIST
38254: PPUSH
38255: CALL_OW 72
38259: PUSH
38260: LD_EXP 99
38264: PUSH
38265: LD_VAR 0 2
38269: ARRAY
38270: PPUSH
38271: LD_INT 30
38273: PUSH
38274: LD_INT 3
38276: PUSH
38277: EMPTY
38278: LIST
38279: LIST
38280: PPUSH
38281: CALL_OW 72
38285: PUSH
38286: LD_EXP 99
38290: PUSH
38291: LD_VAR 0 2
38295: ARRAY
38296: PPUSH
38297: LD_INT 2
38299: PUSH
38300: LD_INT 30
38302: PUSH
38303: LD_INT 6
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 30
38312: PUSH
38313: LD_INT 7
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 30
38322: PUSH
38323: LD_INT 8
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: EMPTY
38331: LIST
38332: LIST
38333: LIST
38334: LIST
38335: PPUSH
38336: CALL_OW 72
38340: PUSH
38341: EMPTY
38342: LIST
38343: LIST
38344: LIST
38345: LIST
38346: ST_TO_ADDR
// for j = 1 to 4 do
38347: LD_ADDR_VAR 0 3
38351: PUSH
38352: DOUBLE
38353: LD_INT 1
38355: DEC
38356: ST_TO_ADDR
38357: LD_INT 4
38359: PUSH
38360: FOR_TO
38361: IFFALSE 38552
// begin if not tmp [ j ] then
38363: LD_VAR 0 4
38367: PUSH
38368: LD_VAR 0 3
38372: ARRAY
38373: NOT
38374: IFFALSE 38378
// continue ;
38376: GO 38360
// for p in tmp [ j ] do
38378: LD_ADDR_VAR 0 5
38382: PUSH
38383: LD_VAR 0 4
38387: PUSH
38388: LD_VAR 0 3
38392: ARRAY
38393: PUSH
38394: FOR_IN
38395: IFFALSE 38548
// begin if not b [ j ] then
38397: LD_VAR 0 6
38401: PUSH
38402: LD_VAR 0 3
38406: ARRAY
38407: NOT
38408: IFFALSE 38412
// break ;
38410: GO 38548
// e := 0 ;
38412: LD_ADDR_VAR 0 7
38416: PUSH
38417: LD_INT 0
38419: ST_TO_ADDR
// for k in b [ j ] do
38420: LD_ADDR_VAR 0 8
38424: PUSH
38425: LD_VAR 0 6
38429: PUSH
38430: LD_VAR 0 3
38434: ARRAY
38435: PUSH
38436: FOR_IN
38437: IFFALSE 38464
// if IsNotFull ( k ) then
38439: LD_VAR 0 8
38443: PPUSH
38444: CALL 68055 0 1
38448: IFFALSE 38462
// begin e := k ;
38450: LD_ADDR_VAR 0 7
38454: PUSH
38455: LD_VAR 0 8
38459: ST_TO_ADDR
// break ;
38460: GO 38464
// end ;
38462: GO 38436
38464: POP
38465: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38466: LD_VAR 0 7
38470: PUSH
38471: LD_VAR 0 5
38475: PPUSH
38476: LD_VAR 0 7
38480: PPUSH
38481: CALL 105174 0 2
38485: NOT
38486: AND
38487: IFFALSE 38546
// begin if IsInUnit ( p ) then
38489: LD_VAR 0 5
38493: PPUSH
38494: CALL_OW 310
38498: IFFALSE 38509
// ComExitBuilding ( p ) ;
38500: LD_VAR 0 5
38504: PPUSH
38505: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38509: LD_VAR 0 5
38513: PPUSH
38514: LD_VAR 0 7
38518: PPUSH
38519: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38523: LD_VAR 0 5
38527: PPUSH
38528: LD_VAR 0 3
38532: PPUSH
38533: CALL_OW 183
// AddComExitBuilding ( p ) ;
38537: LD_VAR 0 5
38541: PPUSH
38542: CALL_OW 182
// end ; end ;
38546: GO 38394
38548: POP
38549: POP
// end ;
38550: GO 38360
38552: POP
38553: POP
// end ;
38554: GO 38115
38556: POP
38557: POP
// end ;
38558: LD_VAR 0 1
38562: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38563: LD_INT 0
38565: PPUSH
38566: PPUSH
38567: PPUSH
38568: PPUSH
38569: PPUSH
38570: PPUSH
38571: PPUSH
38572: PPUSH
38573: PPUSH
38574: PPUSH
38575: PPUSH
38576: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38577: LD_VAR 0 1
38581: NOT
38582: PUSH
38583: LD_EXP 99
38587: PUSH
38588: LD_VAR 0 1
38592: ARRAY
38593: NOT
38594: OR
38595: PUSH
38596: LD_EXP 99
38600: PUSH
38601: LD_VAR 0 1
38605: ARRAY
38606: PPUSH
38607: LD_INT 2
38609: PUSH
38610: LD_INT 30
38612: PUSH
38613: LD_INT 0
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 30
38622: PUSH
38623: LD_INT 1
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: LIST
38634: PPUSH
38635: CALL_OW 72
38639: NOT
38640: OR
38641: IFFALSE 38645
// exit ;
38643: GO 42148
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38645: LD_ADDR_VAR 0 4
38649: PUSH
38650: LD_EXP 99
38654: PUSH
38655: LD_VAR 0 1
38659: ARRAY
38660: PPUSH
38661: LD_INT 2
38663: PUSH
38664: LD_INT 25
38666: PUSH
38667: LD_INT 1
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 25
38676: PUSH
38677: LD_INT 2
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: LD_INT 25
38686: PUSH
38687: LD_INT 3
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 25
38696: PUSH
38697: LD_INT 4
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 25
38706: PUSH
38707: LD_INT 5
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 25
38716: PUSH
38717: LD_INT 8
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 25
38726: PUSH
38727: LD_INT 9
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: PPUSH
38744: CALL_OW 72
38748: ST_TO_ADDR
// if not tmp then
38749: LD_VAR 0 4
38753: NOT
38754: IFFALSE 38758
// exit ;
38756: GO 42148
// for i in tmp do
38758: LD_ADDR_VAR 0 3
38762: PUSH
38763: LD_VAR 0 4
38767: PUSH
38768: FOR_IN
38769: IFFALSE 38800
// if GetTag ( i ) then
38771: LD_VAR 0 3
38775: PPUSH
38776: CALL_OW 110
38780: IFFALSE 38798
// tmp := tmp diff i ;
38782: LD_ADDR_VAR 0 4
38786: PUSH
38787: LD_VAR 0 4
38791: PUSH
38792: LD_VAR 0 3
38796: DIFF
38797: ST_TO_ADDR
38798: GO 38768
38800: POP
38801: POP
// if not tmp then
38802: LD_VAR 0 4
38806: NOT
38807: IFFALSE 38811
// exit ;
38809: GO 42148
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38811: LD_ADDR_VAR 0 5
38815: PUSH
38816: LD_EXP 99
38820: PUSH
38821: LD_VAR 0 1
38825: ARRAY
38826: PPUSH
38827: LD_INT 2
38829: PUSH
38830: LD_INT 25
38832: PUSH
38833: LD_INT 1
38835: PUSH
38836: EMPTY
38837: LIST
38838: LIST
38839: PUSH
38840: LD_INT 25
38842: PUSH
38843: LD_INT 5
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 25
38852: PUSH
38853: LD_INT 8
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 25
38862: PUSH
38863: LD_INT 9
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: PPUSH
38877: CALL_OW 72
38881: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38882: LD_ADDR_VAR 0 6
38886: PUSH
38887: LD_EXP 99
38891: PUSH
38892: LD_VAR 0 1
38896: ARRAY
38897: PPUSH
38898: LD_INT 25
38900: PUSH
38901: LD_INT 2
38903: PUSH
38904: EMPTY
38905: LIST
38906: LIST
38907: PPUSH
38908: CALL_OW 72
38912: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38913: LD_ADDR_VAR 0 7
38917: PUSH
38918: LD_EXP 99
38922: PUSH
38923: LD_VAR 0 1
38927: ARRAY
38928: PPUSH
38929: LD_INT 25
38931: PUSH
38932: LD_INT 3
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PPUSH
38939: CALL_OW 72
38943: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38944: LD_ADDR_VAR 0 8
38948: PUSH
38949: LD_EXP 99
38953: PUSH
38954: LD_VAR 0 1
38958: ARRAY
38959: PPUSH
38960: LD_INT 25
38962: PUSH
38963: LD_INT 4
38965: PUSH
38966: EMPTY
38967: LIST
38968: LIST
38969: PUSH
38970: LD_INT 24
38972: PUSH
38973: LD_INT 251
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: EMPTY
38981: LIST
38982: LIST
38983: PPUSH
38984: CALL_OW 72
38988: ST_TO_ADDR
// if mc_scan [ base ] then
38989: LD_EXP 122
38993: PUSH
38994: LD_VAR 0 1
38998: ARRAY
38999: IFFALSE 39460
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39001: LD_ADDR_EXP 141
39005: PUSH
39006: LD_EXP 141
39010: PPUSH
39011: LD_VAR 0 1
39015: PPUSH
39016: LD_INT 4
39018: PPUSH
39019: CALL_OW 1
39023: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39024: LD_ADDR_VAR 0 12
39028: PUSH
39029: LD_EXP 99
39033: PUSH
39034: LD_VAR 0 1
39038: ARRAY
39039: PPUSH
39040: LD_INT 2
39042: PUSH
39043: LD_INT 30
39045: PUSH
39046: LD_INT 4
39048: PUSH
39049: EMPTY
39050: LIST
39051: LIST
39052: PUSH
39053: LD_INT 30
39055: PUSH
39056: LD_INT 5
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: PUSH
39063: EMPTY
39064: LIST
39065: LIST
39066: LIST
39067: PPUSH
39068: CALL_OW 72
39072: ST_TO_ADDR
// if not b then
39073: LD_VAR 0 12
39077: NOT
39078: IFFALSE 39082
// exit ;
39080: GO 42148
// p := [ ] ;
39082: LD_ADDR_VAR 0 11
39086: PUSH
39087: EMPTY
39088: ST_TO_ADDR
// if sci >= 2 then
39089: LD_VAR 0 8
39093: PUSH
39094: LD_INT 2
39096: GREATEREQUAL
39097: IFFALSE 39128
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39099: LD_ADDR_VAR 0 8
39103: PUSH
39104: LD_VAR 0 8
39108: PUSH
39109: LD_INT 1
39111: ARRAY
39112: PUSH
39113: LD_VAR 0 8
39117: PUSH
39118: LD_INT 2
39120: ARRAY
39121: PUSH
39122: EMPTY
39123: LIST
39124: LIST
39125: ST_TO_ADDR
39126: GO 39189
// if sci = 1 then
39128: LD_VAR 0 8
39132: PUSH
39133: LD_INT 1
39135: EQUAL
39136: IFFALSE 39157
// sci := [ sci [ 1 ] ] else
39138: LD_ADDR_VAR 0 8
39142: PUSH
39143: LD_VAR 0 8
39147: PUSH
39148: LD_INT 1
39150: ARRAY
39151: PUSH
39152: EMPTY
39153: LIST
39154: ST_TO_ADDR
39155: GO 39189
// if sci = 0 then
39157: LD_VAR 0 8
39161: PUSH
39162: LD_INT 0
39164: EQUAL
39165: IFFALSE 39189
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39167: LD_ADDR_VAR 0 11
39171: PUSH
39172: LD_VAR 0 4
39176: PPUSH
39177: LD_INT 4
39179: PPUSH
39180: CALL 105037 0 2
39184: PUSH
39185: LD_INT 1
39187: ARRAY
39188: ST_TO_ADDR
// if eng > 4 then
39189: LD_VAR 0 6
39193: PUSH
39194: LD_INT 4
39196: GREATER
39197: IFFALSE 39243
// for i = eng downto 4 do
39199: LD_ADDR_VAR 0 3
39203: PUSH
39204: DOUBLE
39205: LD_VAR 0 6
39209: INC
39210: ST_TO_ADDR
39211: LD_INT 4
39213: PUSH
39214: FOR_DOWNTO
39215: IFFALSE 39241
// eng := eng diff eng [ i ] ;
39217: LD_ADDR_VAR 0 6
39221: PUSH
39222: LD_VAR 0 6
39226: PUSH
39227: LD_VAR 0 6
39231: PUSH
39232: LD_VAR 0 3
39236: ARRAY
39237: DIFF
39238: ST_TO_ADDR
39239: GO 39214
39241: POP
39242: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39243: LD_ADDR_VAR 0 4
39247: PUSH
39248: LD_VAR 0 4
39252: PUSH
39253: LD_VAR 0 5
39257: PUSH
39258: LD_VAR 0 6
39262: UNION
39263: PUSH
39264: LD_VAR 0 7
39268: UNION
39269: PUSH
39270: LD_VAR 0 8
39274: UNION
39275: DIFF
39276: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39277: LD_ADDR_VAR 0 13
39281: PUSH
39282: LD_EXP 99
39286: PUSH
39287: LD_VAR 0 1
39291: ARRAY
39292: PPUSH
39293: LD_INT 2
39295: PUSH
39296: LD_INT 30
39298: PUSH
39299: LD_INT 32
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PUSH
39306: LD_INT 30
39308: PUSH
39309: LD_INT 31
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: EMPTY
39317: LIST
39318: LIST
39319: LIST
39320: PPUSH
39321: CALL_OW 72
39325: PUSH
39326: LD_EXP 99
39330: PUSH
39331: LD_VAR 0 1
39335: ARRAY
39336: PPUSH
39337: LD_INT 2
39339: PUSH
39340: LD_INT 30
39342: PUSH
39343: LD_INT 4
39345: PUSH
39346: EMPTY
39347: LIST
39348: LIST
39349: PUSH
39350: LD_INT 30
39352: PUSH
39353: LD_INT 5
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: LIST
39364: PPUSH
39365: CALL_OW 72
39369: PUSH
39370: LD_INT 6
39372: MUL
39373: PLUS
39374: ST_TO_ADDR
// if bcount < tmp then
39375: LD_VAR 0 13
39379: PUSH
39380: LD_VAR 0 4
39384: LESS
39385: IFFALSE 39431
// for i = tmp downto bcount do
39387: LD_ADDR_VAR 0 3
39391: PUSH
39392: DOUBLE
39393: LD_VAR 0 4
39397: INC
39398: ST_TO_ADDR
39399: LD_VAR 0 13
39403: PUSH
39404: FOR_DOWNTO
39405: IFFALSE 39429
// tmp := Delete ( tmp , tmp ) ;
39407: LD_ADDR_VAR 0 4
39411: PUSH
39412: LD_VAR 0 4
39416: PPUSH
39417: LD_VAR 0 4
39421: PPUSH
39422: CALL_OW 3
39426: ST_TO_ADDR
39427: GO 39404
39429: POP
39430: POP
// result := [ tmp , 0 , 0 , p ] ;
39431: LD_ADDR_VAR 0 2
39435: PUSH
39436: LD_VAR 0 4
39440: PUSH
39441: LD_INT 0
39443: PUSH
39444: LD_INT 0
39446: PUSH
39447: LD_VAR 0 11
39451: PUSH
39452: EMPTY
39453: LIST
39454: LIST
39455: LIST
39456: LIST
39457: ST_TO_ADDR
// exit ;
39458: GO 42148
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39460: LD_EXP 99
39464: PUSH
39465: LD_VAR 0 1
39469: ARRAY
39470: PPUSH
39471: LD_INT 2
39473: PUSH
39474: LD_INT 30
39476: PUSH
39477: LD_INT 6
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 30
39486: PUSH
39487: LD_INT 7
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 30
39496: PUSH
39497: LD_INT 8
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: EMPTY
39505: LIST
39506: LIST
39507: LIST
39508: LIST
39509: PPUSH
39510: CALL_OW 72
39514: NOT
39515: PUSH
39516: LD_EXP 99
39520: PUSH
39521: LD_VAR 0 1
39525: ARRAY
39526: PPUSH
39527: LD_INT 30
39529: PUSH
39530: LD_INT 3
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: PPUSH
39537: CALL_OW 72
39541: NOT
39542: AND
39543: IFFALSE 39615
// begin if eng = tmp then
39545: LD_VAR 0 6
39549: PUSH
39550: LD_VAR 0 4
39554: EQUAL
39555: IFFALSE 39559
// exit ;
39557: GO 42148
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39559: LD_ADDR_EXP 141
39563: PUSH
39564: LD_EXP 141
39568: PPUSH
39569: LD_VAR 0 1
39573: PPUSH
39574: LD_INT 1
39576: PPUSH
39577: CALL_OW 1
39581: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39582: LD_ADDR_VAR 0 2
39586: PUSH
39587: LD_INT 0
39589: PUSH
39590: LD_VAR 0 4
39594: PUSH
39595: LD_VAR 0 6
39599: DIFF
39600: PUSH
39601: LD_INT 0
39603: PUSH
39604: LD_INT 0
39606: PUSH
39607: EMPTY
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: ST_TO_ADDR
// exit ;
39613: GO 42148
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39615: LD_EXP 126
39619: PUSH
39620: LD_EXP 125
39624: PUSH
39625: LD_VAR 0 1
39629: ARRAY
39630: ARRAY
39631: PUSH
39632: LD_EXP 99
39636: PUSH
39637: LD_VAR 0 1
39641: ARRAY
39642: PPUSH
39643: LD_INT 2
39645: PUSH
39646: LD_INT 30
39648: PUSH
39649: LD_INT 6
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 30
39658: PUSH
39659: LD_INT 7
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: LD_INT 30
39668: PUSH
39669: LD_INT 8
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: LIST
39680: LIST
39681: PPUSH
39682: CALL_OW 72
39686: AND
39687: PUSH
39688: LD_EXP 99
39692: PUSH
39693: LD_VAR 0 1
39697: ARRAY
39698: PPUSH
39699: LD_INT 30
39701: PUSH
39702: LD_INT 3
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: PPUSH
39709: CALL_OW 72
39713: NOT
39714: AND
39715: IFFALSE 39929
// begin if sci >= 6 then
39717: LD_VAR 0 8
39721: PUSH
39722: LD_INT 6
39724: GREATEREQUAL
39725: IFFALSE 39729
// exit ;
39727: GO 42148
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39729: LD_ADDR_EXP 141
39733: PUSH
39734: LD_EXP 141
39738: PPUSH
39739: LD_VAR 0 1
39743: PPUSH
39744: LD_INT 2
39746: PPUSH
39747: CALL_OW 1
39751: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39752: LD_ADDR_VAR 0 9
39756: PUSH
39757: LD_VAR 0 4
39761: PUSH
39762: LD_VAR 0 8
39766: DIFF
39767: PPUSH
39768: LD_INT 4
39770: PPUSH
39771: CALL 105037 0 2
39775: ST_TO_ADDR
// p := [ ] ;
39776: LD_ADDR_VAR 0 11
39780: PUSH
39781: EMPTY
39782: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39783: LD_VAR 0 8
39787: PUSH
39788: LD_INT 6
39790: LESS
39791: PUSH
39792: LD_VAR 0 9
39796: PUSH
39797: LD_INT 6
39799: GREATER
39800: AND
39801: IFFALSE 39882
// begin for i = 1 to 6 - sci do
39803: LD_ADDR_VAR 0 3
39807: PUSH
39808: DOUBLE
39809: LD_INT 1
39811: DEC
39812: ST_TO_ADDR
39813: LD_INT 6
39815: PUSH
39816: LD_VAR 0 8
39820: MINUS
39821: PUSH
39822: FOR_TO
39823: IFFALSE 39878
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39825: LD_ADDR_VAR 0 11
39829: PUSH
39830: LD_VAR 0 11
39834: PPUSH
39835: LD_VAR 0 11
39839: PUSH
39840: LD_INT 1
39842: PLUS
39843: PPUSH
39844: LD_VAR 0 9
39848: PUSH
39849: LD_INT 1
39851: ARRAY
39852: PPUSH
39853: CALL_OW 2
39857: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39858: LD_ADDR_VAR 0 9
39862: PUSH
39863: LD_VAR 0 9
39867: PPUSH
39868: LD_INT 1
39870: PPUSH
39871: CALL_OW 3
39875: ST_TO_ADDR
// end ;
39876: GO 39822
39878: POP
39879: POP
// end else
39880: GO 39902
// if sort then
39882: LD_VAR 0 9
39886: IFFALSE 39902
// p := sort [ 1 ] ;
39888: LD_ADDR_VAR 0 11
39892: PUSH
39893: LD_VAR 0 9
39897: PUSH
39898: LD_INT 1
39900: ARRAY
39901: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39902: LD_ADDR_VAR 0 2
39906: PUSH
39907: LD_INT 0
39909: PUSH
39910: LD_INT 0
39912: PUSH
39913: LD_INT 0
39915: PUSH
39916: LD_VAR 0 11
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: LIST
39925: LIST
39926: ST_TO_ADDR
// exit ;
39927: GO 42148
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39929: LD_EXP 126
39933: PUSH
39934: LD_EXP 125
39938: PUSH
39939: LD_VAR 0 1
39943: ARRAY
39944: ARRAY
39945: PUSH
39946: LD_EXP 99
39950: PUSH
39951: LD_VAR 0 1
39955: ARRAY
39956: PPUSH
39957: LD_INT 2
39959: PUSH
39960: LD_INT 30
39962: PUSH
39963: LD_INT 6
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 30
39972: PUSH
39973: LD_INT 7
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 30
39982: PUSH
39983: LD_INT 8
39985: PUSH
39986: EMPTY
39987: LIST
39988: LIST
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: PPUSH
39996: CALL_OW 72
40000: AND
40001: PUSH
40002: LD_EXP 99
40006: PUSH
40007: LD_VAR 0 1
40011: ARRAY
40012: PPUSH
40013: LD_INT 30
40015: PUSH
40016: LD_INT 3
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PPUSH
40023: CALL_OW 72
40027: AND
40028: IFFALSE 40762
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40030: LD_ADDR_EXP 141
40034: PUSH
40035: LD_EXP 141
40039: PPUSH
40040: LD_VAR 0 1
40044: PPUSH
40045: LD_INT 3
40047: PPUSH
40048: CALL_OW 1
40052: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40053: LD_ADDR_VAR 0 2
40057: PUSH
40058: LD_INT 0
40060: PUSH
40061: LD_INT 0
40063: PUSH
40064: LD_INT 0
40066: PUSH
40067: LD_INT 0
40069: PUSH
40070: EMPTY
40071: LIST
40072: LIST
40073: LIST
40074: LIST
40075: ST_TO_ADDR
// if not eng then
40076: LD_VAR 0 6
40080: NOT
40081: IFFALSE 40144
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40083: LD_ADDR_VAR 0 11
40087: PUSH
40088: LD_VAR 0 4
40092: PPUSH
40093: LD_INT 2
40095: PPUSH
40096: CALL 105037 0 2
40100: PUSH
40101: LD_INT 1
40103: ARRAY
40104: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40105: LD_ADDR_VAR 0 2
40109: PUSH
40110: LD_VAR 0 2
40114: PPUSH
40115: LD_INT 2
40117: PPUSH
40118: LD_VAR 0 11
40122: PPUSH
40123: CALL_OW 1
40127: ST_TO_ADDR
// tmp := tmp diff p ;
40128: LD_ADDR_VAR 0 4
40132: PUSH
40133: LD_VAR 0 4
40137: PUSH
40138: LD_VAR 0 11
40142: DIFF
40143: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40144: LD_VAR 0 4
40148: PUSH
40149: LD_VAR 0 8
40153: PUSH
40154: LD_INT 6
40156: LESS
40157: AND
40158: IFFALSE 40346
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40160: LD_ADDR_VAR 0 9
40164: PUSH
40165: LD_VAR 0 4
40169: PUSH
40170: LD_VAR 0 8
40174: PUSH
40175: LD_VAR 0 7
40179: UNION
40180: DIFF
40181: PPUSH
40182: LD_INT 4
40184: PPUSH
40185: CALL 105037 0 2
40189: ST_TO_ADDR
// p := [ ] ;
40190: LD_ADDR_VAR 0 11
40194: PUSH
40195: EMPTY
40196: ST_TO_ADDR
// if sort then
40197: LD_VAR 0 9
40201: IFFALSE 40317
// for i = 1 to 6 - sci do
40203: LD_ADDR_VAR 0 3
40207: PUSH
40208: DOUBLE
40209: LD_INT 1
40211: DEC
40212: ST_TO_ADDR
40213: LD_INT 6
40215: PUSH
40216: LD_VAR 0 8
40220: MINUS
40221: PUSH
40222: FOR_TO
40223: IFFALSE 40315
// begin if i = sort then
40225: LD_VAR 0 3
40229: PUSH
40230: LD_VAR 0 9
40234: EQUAL
40235: IFFALSE 40239
// break ;
40237: GO 40315
// if GetClass ( i ) = 4 then
40239: LD_VAR 0 3
40243: PPUSH
40244: CALL_OW 257
40248: PUSH
40249: LD_INT 4
40251: EQUAL
40252: IFFALSE 40256
// continue ;
40254: GO 40222
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40256: LD_ADDR_VAR 0 11
40260: PUSH
40261: LD_VAR 0 11
40265: PPUSH
40266: LD_VAR 0 11
40270: PUSH
40271: LD_INT 1
40273: PLUS
40274: PPUSH
40275: LD_VAR 0 9
40279: PUSH
40280: LD_VAR 0 3
40284: ARRAY
40285: PPUSH
40286: CALL_OW 2
40290: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40291: LD_ADDR_VAR 0 4
40295: PUSH
40296: LD_VAR 0 4
40300: PUSH
40301: LD_VAR 0 9
40305: PUSH
40306: LD_VAR 0 3
40310: ARRAY
40311: DIFF
40312: ST_TO_ADDR
// end ;
40313: GO 40222
40315: POP
40316: POP
// if p then
40317: LD_VAR 0 11
40321: IFFALSE 40346
// result := Replace ( result , 4 , p ) ;
40323: LD_ADDR_VAR 0 2
40327: PUSH
40328: LD_VAR 0 2
40332: PPUSH
40333: LD_INT 4
40335: PPUSH
40336: LD_VAR 0 11
40340: PPUSH
40341: CALL_OW 1
40345: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40346: LD_VAR 0 4
40350: PUSH
40351: LD_VAR 0 7
40355: PUSH
40356: LD_INT 6
40358: LESS
40359: AND
40360: IFFALSE 40548
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40362: LD_ADDR_VAR 0 9
40366: PUSH
40367: LD_VAR 0 4
40371: PUSH
40372: LD_VAR 0 8
40376: PUSH
40377: LD_VAR 0 7
40381: UNION
40382: DIFF
40383: PPUSH
40384: LD_INT 3
40386: PPUSH
40387: CALL 105037 0 2
40391: ST_TO_ADDR
// p := [ ] ;
40392: LD_ADDR_VAR 0 11
40396: PUSH
40397: EMPTY
40398: ST_TO_ADDR
// if sort then
40399: LD_VAR 0 9
40403: IFFALSE 40519
// for i = 1 to 6 - mech do
40405: LD_ADDR_VAR 0 3
40409: PUSH
40410: DOUBLE
40411: LD_INT 1
40413: DEC
40414: ST_TO_ADDR
40415: LD_INT 6
40417: PUSH
40418: LD_VAR 0 7
40422: MINUS
40423: PUSH
40424: FOR_TO
40425: IFFALSE 40517
// begin if i = sort then
40427: LD_VAR 0 3
40431: PUSH
40432: LD_VAR 0 9
40436: EQUAL
40437: IFFALSE 40441
// break ;
40439: GO 40517
// if GetClass ( i ) = 3 then
40441: LD_VAR 0 3
40445: PPUSH
40446: CALL_OW 257
40450: PUSH
40451: LD_INT 3
40453: EQUAL
40454: IFFALSE 40458
// continue ;
40456: GO 40424
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40458: LD_ADDR_VAR 0 11
40462: PUSH
40463: LD_VAR 0 11
40467: PPUSH
40468: LD_VAR 0 11
40472: PUSH
40473: LD_INT 1
40475: PLUS
40476: PPUSH
40477: LD_VAR 0 9
40481: PUSH
40482: LD_VAR 0 3
40486: ARRAY
40487: PPUSH
40488: CALL_OW 2
40492: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40493: LD_ADDR_VAR 0 4
40497: PUSH
40498: LD_VAR 0 4
40502: PUSH
40503: LD_VAR 0 9
40507: PUSH
40508: LD_VAR 0 3
40512: ARRAY
40513: DIFF
40514: ST_TO_ADDR
// end ;
40515: GO 40424
40517: POP
40518: POP
// if p then
40519: LD_VAR 0 11
40523: IFFALSE 40548
// result := Replace ( result , 3 , p ) ;
40525: LD_ADDR_VAR 0 2
40529: PUSH
40530: LD_VAR 0 2
40534: PPUSH
40535: LD_INT 3
40537: PPUSH
40538: LD_VAR 0 11
40542: PPUSH
40543: CALL_OW 1
40547: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40548: LD_VAR 0 4
40552: PUSH
40553: LD_INT 6
40555: GREATER
40556: PUSH
40557: LD_VAR 0 6
40561: PUSH
40562: LD_INT 6
40564: LESS
40565: AND
40566: IFFALSE 40760
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40568: LD_ADDR_VAR 0 9
40572: PUSH
40573: LD_VAR 0 4
40577: PUSH
40578: LD_VAR 0 8
40582: PUSH
40583: LD_VAR 0 7
40587: UNION
40588: PUSH
40589: LD_VAR 0 6
40593: UNION
40594: DIFF
40595: PPUSH
40596: LD_INT 2
40598: PPUSH
40599: CALL 105037 0 2
40603: ST_TO_ADDR
// p := [ ] ;
40604: LD_ADDR_VAR 0 11
40608: PUSH
40609: EMPTY
40610: ST_TO_ADDR
// if sort then
40611: LD_VAR 0 9
40615: IFFALSE 40731
// for i = 1 to 6 - eng do
40617: LD_ADDR_VAR 0 3
40621: PUSH
40622: DOUBLE
40623: LD_INT 1
40625: DEC
40626: ST_TO_ADDR
40627: LD_INT 6
40629: PUSH
40630: LD_VAR 0 6
40634: MINUS
40635: PUSH
40636: FOR_TO
40637: IFFALSE 40729
// begin if i = sort then
40639: LD_VAR 0 3
40643: PUSH
40644: LD_VAR 0 9
40648: EQUAL
40649: IFFALSE 40653
// break ;
40651: GO 40729
// if GetClass ( i ) = 2 then
40653: LD_VAR 0 3
40657: PPUSH
40658: CALL_OW 257
40662: PUSH
40663: LD_INT 2
40665: EQUAL
40666: IFFALSE 40670
// continue ;
40668: GO 40636
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40670: LD_ADDR_VAR 0 11
40674: PUSH
40675: LD_VAR 0 11
40679: PPUSH
40680: LD_VAR 0 11
40684: PUSH
40685: LD_INT 1
40687: PLUS
40688: PPUSH
40689: LD_VAR 0 9
40693: PUSH
40694: LD_VAR 0 3
40698: ARRAY
40699: PPUSH
40700: CALL_OW 2
40704: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40705: LD_ADDR_VAR 0 4
40709: PUSH
40710: LD_VAR 0 4
40714: PUSH
40715: LD_VAR 0 9
40719: PUSH
40720: LD_VAR 0 3
40724: ARRAY
40725: DIFF
40726: ST_TO_ADDR
// end ;
40727: GO 40636
40729: POP
40730: POP
// if p then
40731: LD_VAR 0 11
40735: IFFALSE 40760
// result := Replace ( result , 2 , p ) ;
40737: LD_ADDR_VAR 0 2
40741: PUSH
40742: LD_VAR 0 2
40746: PPUSH
40747: LD_INT 2
40749: PPUSH
40750: LD_VAR 0 11
40754: PPUSH
40755: CALL_OW 1
40759: ST_TO_ADDR
// end ; exit ;
40760: GO 42148
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40762: LD_EXP 126
40766: PUSH
40767: LD_EXP 125
40771: PUSH
40772: LD_VAR 0 1
40776: ARRAY
40777: ARRAY
40778: NOT
40779: PUSH
40780: LD_EXP 99
40784: PUSH
40785: LD_VAR 0 1
40789: ARRAY
40790: PPUSH
40791: LD_INT 30
40793: PUSH
40794: LD_INT 3
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PPUSH
40801: CALL_OW 72
40805: AND
40806: PUSH
40807: LD_EXP 104
40811: PUSH
40812: LD_VAR 0 1
40816: ARRAY
40817: AND
40818: IFFALSE 41426
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40820: LD_ADDR_EXP 141
40824: PUSH
40825: LD_EXP 141
40829: PPUSH
40830: LD_VAR 0 1
40834: PPUSH
40835: LD_INT 5
40837: PPUSH
40838: CALL_OW 1
40842: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40843: LD_ADDR_VAR 0 2
40847: PUSH
40848: LD_INT 0
40850: PUSH
40851: LD_INT 0
40853: PUSH
40854: LD_INT 0
40856: PUSH
40857: LD_INT 0
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: LIST
40864: LIST
40865: ST_TO_ADDR
// if sci > 1 then
40866: LD_VAR 0 8
40870: PUSH
40871: LD_INT 1
40873: GREATER
40874: IFFALSE 40902
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40876: LD_ADDR_VAR 0 4
40880: PUSH
40881: LD_VAR 0 4
40885: PUSH
40886: LD_VAR 0 8
40890: PUSH
40891: LD_VAR 0 8
40895: PUSH
40896: LD_INT 1
40898: ARRAY
40899: DIFF
40900: DIFF
40901: ST_TO_ADDR
// if tmp and not sci then
40902: LD_VAR 0 4
40906: PUSH
40907: LD_VAR 0 8
40911: NOT
40912: AND
40913: IFFALSE 40982
// begin sort := SortBySkill ( tmp , 4 ) ;
40915: LD_ADDR_VAR 0 9
40919: PUSH
40920: LD_VAR 0 4
40924: PPUSH
40925: LD_INT 4
40927: PPUSH
40928: CALL 105037 0 2
40932: ST_TO_ADDR
// if sort then
40933: LD_VAR 0 9
40937: IFFALSE 40953
// p := sort [ 1 ] ;
40939: LD_ADDR_VAR 0 11
40943: PUSH
40944: LD_VAR 0 9
40948: PUSH
40949: LD_INT 1
40951: ARRAY
40952: ST_TO_ADDR
// if p then
40953: LD_VAR 0 11
40957: IFFALSE 40982
// result := Replace ( result , 4 , p ) ;
40959: LD_ADDR_VAR 0 2
40963: PUSH
40964: LD_VAR 0 2
40968: PPUSH
40969: LD_INT 4
40971: PPUSH
40972: LD_VAR 0 11
40976: PPUSH
40977: CALL_OW 1
40981: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40982: LD_ADDR_VAR 0 4
40986: PUSH
40987: LD_VAR 0 4
40991: PUSH
40992: LD_VAR 0 7
40996: DIFF
40997: ST_TO_ADDR
// if tmp and mech < 6 then
40998: LD_VAR 0 4
41002: PUSH
41003: LD_VAR 0 7
41007: PUSH
41008: LD_INT 6
41010: LESS
41011: AND
41012: IFFALSE 41200
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41014: LD_ADDR_VAR 0 9
41018: PUSH
41019: LD_VAR 0 4
41023: PUSH
41024: LD_VAR 0 8
41028: PUSH
41029: LD_VAR 0 7
41033: UNION
41034: DIFF
41035: PPUSH
41036: LD_INT 3
41038: PPUSH
41039: CALL 105037 0 2
41043: ST_TO_ADDR
// p := [ ] ;
41044: LD_ADDR_VAR 0 11
41048: PUSH
41049: EMPTY
41050: ST_TO_ADDR
// if sort then
41051: LD_VAR 0 9
41055: IFFALSE 41171
// for i = 1 to 6 - mech do
41057: LD_ADDR_VAR 0 3
41061: PUSH
41062: DOUBLE
41063: LD_INT 1
41065: DEC
41066: ST_TO_ADDR
41067: LD_INT 6
41069: PUSH
41070: LD_VAR 0 7
41074: MINUS
41075: PUSH
41076: FOR_TO
41077: IFFALSE 41169
// begin if i = sort then
41079: LD_VAR 0 3
41083: PUSH
41084: LD_VAR 0 9
41088: EQUAL
41089: IFFALSE 41093
// break ;
41091: GO 41169
// if GetClass ( i ) = 3 then
41093: LD_VAR 0 3
41097: PPUSH
41098: CALL_OW 257
41102: PUSH
41103: LD_INT 3
41105: EQUAL
41106: IFFALSE 41110
// continue ;
41108: GO 41076
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41110: LD_ADDR_VAR 0 11
41114: PUSH
41115: LD_VAR 0 11
41119: PPUSH
41120: LD_VAR 0 11
41124: PUSH
41125: LD_INT 1
41127: PLUS
41128: PPUSH
41129: LD_VAR 0 9
41133: PUSH
41134: LD_VAR 0 3
41138: ARRAY
41139: PPUSH
41140: CALL_OW 2
41144: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41145: LD_ADDR_VAR 0 4
41149: PUSH
41150: LD_VAR 0 4
41154: PUSH
41155: LD_VAR 0 9
41159: PUSH
41160: LD_VAR 0 3
41164: ARRAY
41165: DIFF
41166: ST_TO_ADDR
// end ;
41167: GO 41076
41169: POP
41170: POP
// if p then
41171: LD_VAR 0 11
41175: IFFALSE 41200
// result := Replace ( result , 3 , p ) ;
41177: LD_ADDR_VAR 0 2
41181: PUSH
41182: LD_VAR 0 2
41186: PPUSH
41187: LD_INT 3
41189: PPUSH
41190: LD_VAR 0 11
41194: PPUSH
41195: CALL_OW 1
41199: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41200: LD_ADDR_VAR 0 4
41204: PUSH
41205: LD_VAR 0 4
41209: PUSH
41210: LD_VAR 0 6
41214: DIFF
41215: ST_TO_ADDR
// if tmp and eng < 6 then
41216: LD_VAR 0 4
41220: PUSH
41221: LD_VAR 0 6
41225: PUSH
41226: LD_INT 6
41228: LESS
41229: AND
41230: IFFALSE 41424
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41232: LD_ADDR_VAR 0 9
41236: PUSH
41237: LD_VAR 0 4
41241: PUSH
41242: LD_VAR 0 8
41246: PUSH
41247: LD_VAR 0 7
41251: UNION
41252: PUSH
41253: LD_VAR 0 6
41257: UNION
41258: DIFF
41259: PPUSH
41260: LD_INT 2
41262: PPUSH
41263: CALL 105037 0 2
41267: ST_TO_ADDR
// p := [ ] ;
41268: LD_ADDR_VAR 0 11
41272: PUSH
41273: EMPTY
41274: ST_TO_ADDR
// if sort then
41275: LD_VAR 0 9
41279: IFFALSE 41395
// for i = 1 to 6 - eng do
41281: LD_ADDR_VAR 0 3
41285: PUSH
41286: DOUBLE
41287: LD_INT 1
41289: DEC
41290: ST_TO_ADDR
41291: LD_INT 6
41293: PUSH
41294: LD_VAR 0 6
41298: MINUS
41299: PUSH
41300: FOR_TO
41301: IFFALSE 41393
// begin if i = sort then
41303: LD_VAR 0 3
41307: PUSH
41308: LD_VAR 0 9
41312: EQUAL
41313: IFFALSE 41317
// break ;
41315: GO 41393
// if GetClass ( i ) = 2 then
41317: LD_VAR 0 3
41321: PPUSH
41322: CALL_OW 257
41326: PUSH
41327: LD_INT 2
41329: EQUAL
41330: IFFALSE 41334
// continue ;
41332: GO 41300
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41334: LD_ADDR_VAR 0 11
41338: PUSH
41339: LD_VAR 0 11
41343: PPUSH
41344: LD_VAR 0 11
41348: PUSH
41349: LD_INT 1
41351: PLUS
41352: PPUSH
41353: LD_VAR 0 9
41357: PUSH
41358: LD_VAR 0 3
41362: ARRAY
41363: PPUSH
41364: CALL_OW 2
41368: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41369: LD_ADDR_VAR 0 4
41373: PUSH
41374: LD_VAR 0 4
41378: PUSH
41379: LD_VAR 0 9
41383: PUSH
41384: LD_VAR 0 3
41388: ARRAY
41389: DIFF
41390: ST_TO_ADDR
// end ;
41391: GO 41300
41393: POP
41394: POP
// if p then
41395: LD_VAR 0 11
41399: IFFALSE 41424
// result := Replace ( result , 2 , p ) ;
41401: LD_ADDR_VAR 0 2
41405: PUSH
41406: LD_VAR 0 2
41410: PPUSH
41411: LD_INT 2
41413: PPUSH
41414: LD_VAR 0 11
41418: PPUSH
41419: CALL_OW 1
41423: ST_TO_ADDR
// end ; exit ;
41424: GO 42148
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41426: LD_EXP 126
41430: PUSH
41431: LD_EXP 125
41435: PUSH
41436: LD_VAR 0 1
41440: ARRAY
41441: ARRAY
41442: NOT
41443: PUSH
41444: LD_EXP 99
41448: PUSH
41449: LD_VAR 0 1
41453: ARRAY
41454: PPUSH
41455: LD_INT 30
41457: PUSH
41458: LD_INT 3
41460: PUSH
41461: EMPTY
41462: LIST
41463: LIST
41464: PPUSH
41465: CALL_OW 72
41469: AND
41470: PUSH
41471: LD_EXP 104
41475: PUSH
41476: LD_VAR 0 1
41480: ARRAY
41481: NOT
41482: AND
41483: IFFALSE 42148
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41485: LD_ADDR_EXP 141
41489: PUSH
41490: LD_EXP 141
41494: PPUSH
41495: LD_VAR 0 1
41499: PPUSH
41500: LD_INT 6
41502: PPUSH
41503: CALL_OW 1
41507: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41508: LD_ADDR_VAR 0 2
41512: PUSH
41513: LD_INT 0
41515: PUSH
41516: LD_INT 0
41518: PUSH
41519: LD_INT 0
41521: PUSH
41522: LD_INT 0
41524: PUSH
41525: EMPTY
41526: LIST
41527: LIST
41528: LIST
41529: LIST
41530: ST_TO_ADDR
// if sci >= 1 then
41531: LD_VAR 0 8
41535: PUSH
41536: LD_INT 1
41538: GREATEREQUAL
41539: IFFALSE 41561
// tmp := tmp diff sci [ 1 ] ;
41541: LD_ADDR_VAR 0 4
41545: PUSH
41546: LD_VAR 0 4
41550: PUSH
41551: LD_VAR 0 8
41555: PUSH
41556: LD_INT 1
41558: ARRAY
41559: DIFF
41560: ST_TO_ADDR
// if tmp and not sci then
41561: LD_VAR 0 4
41565: PUSH
41566: LD_VAR 0 8
41570: NOT
41571: AND
41572: IFFALSE 41641
// begin sort := SortBySkill ( tmp , 4 ) ;
41574: LD_ADDR_VAR 0 9
41578: PUSH
41579: LD_VAR 0 4
41583: PPUSH
41584: LD_INT 4
41586: PPUSH
41587: CALL 105037 0 2
41591: ST_TO_ADDR
// if sort then
41592: LD_VAR 0 9
41596: IFFALSE 41612
// p := sort [ 1 ] ;
41598: LD_ADDR_VAR 0 11
41602: PUSH
41603: LD_VAR 0 9
41607: PUSH
41608: LD_INT 1
41610: ARRAY
41611: ST_TO_ADDR
// if p then
41612: LD_VAR 0 11
41616: IFFALSE 41641
// result := Replace ( result , 4 , p ) ;
41618: LD_ADDR_VAR 0 2
41622: PUSH
41623: LD_VAR 0 2
41627: PPUSH
41628: LD_INT 4
41630: PPUSH
41631: LD_VAR 0 11
41635: PPUSH
41636: CALL_OW 1
41640: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41641: LD_ADDR_VAR 0 4
41645: PUSH
41646: LD_VAR 0 4
41650: PUSH
41651: LD_VAR 0 7
41655: DIFF
41656: ST_TO_ADDR
// if tmp and mech < 6 then
41657: LD_VAR 0 4
41661: PUSH
41662: LD_VAR 0 7
41666: PUSH
41667: LD_INT 6
41669: LESS
41670: AND
41671: IFFALSE 41853
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41673: LD_ADDR_VAR 0 9
41677: PUSH
41678: LD_VAR 0 4
41682: PUSH
41683: LD_VAR 0 7
41687: DIFF
41688: PPUSH
41689: LD_INT 3
41691: PPUSH
41692: CALL 105037 0 2
41696: ST_TO_ADDR
// p := [ ] ;
41697: LD_ADDR_VAR 0 11
41701: PUSH
41702: EMPTY
41703: ST_TO_ADDR
// if sort then
41704: LD_VAR 0 9
41708: IFFALSE 41824
// for i = 1 to 6 - mech do
41710: LD_ADDR_VAR 0 3
41714: PUSH
41715: DOUBLE
41716: LD_INT 1
41718: DEC
41719: ST_TO_ADDR
41720: LD_INT 6
41722: PUSH
41723: LD_VAR 0 7
41727: MINUS
41728: PUSH
41729: FOR_TO
41730: IFFALSE 41822
// begin if i = sort then
41732: LD_VAR 0 3
41736: PUSH
41737: LD_VAR 0 9
41741: EQUAL
41742: IFFALSE 41746
// break ;
41744: GO 41822
// if GetClass ( i ) = 3 then
41746: LD_VAR 0 3
41750: PPUSH
41751: CALL_OW 257
41755: PUSH
41756: LD_INT 3
41758: EQUAL
41759: IFFALSE 41763
// continue ;
41761: GO 41729
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41763: LD_ADDR_VAR 0 11
41767: PUSH
41768: LD_VAR 0 11
41772: PPUSH
41773: LD_VAR 0 11
41777: PUSH
41778: LD_INT 1
41780: PLUS
41781: PPUSH
41782: LD_VAR 0 9
41786: PUSH
41787: LD_VAR 0 3
41791: ARRAY
41792: PPUSH
41793: CALL_OW 2
41797: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41798: LD_ADDR_VAR 0 4
41802: PUSH
41803: LD_VAR 0 4
41807: PUSH
41808: LD_VAR 0 9
41812: PUSH
41813: LD_VAR 0 3
41817: ARRAY
41818: DIFF
41819: ST_TO_ADDR
// end ;
41820: GO 41729
41822: POP
41823: POP
// if p then
41824: LD_VAR 0 11
41828: IFFALSE 41853
// result := Replace ( result , 3 , p ) ;
41830: LD_ADDR_VAR 0 2
41834: PUSH
41835: LD_VAR 0 2
41839: PPUSH
41840: LD_INT 3
41842: PPUSH
41843: LD_VAR 0 11
41847: PPUSH
41848: CALL_OW 1
41852: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41853: LD_ADDR_VAR 0 4
41857: PUSH
41858: LD_VAR 0 4
41862: PUSH
41863: LD_VAR 0 6
41867: DIFF
41868: ST_TO_ADDR
// if tmp and eng < 4 then
41869: LD_VAR 0 4
41873: PUSH
41874: LD_VAR 0 6
41878: PUSH
41879: LD_INT 4
41881: LESS
41882: AND
41883: IFFALSE 42073
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41885: LD_ADDR_VAR 0 9
41889: PUSH
41890: LD_VAR 0 4
41894: PUSH
41895: LD_VAR 0 7
41899: PUSH
41900: LD_VAR 0 6
41904: UNION
41905: DIFF
41906: PPUSH
41907: LD_INT 2
41909: PPUSH
41910: CALL 105037 0 2
41914: ST_TO_ADDR
// p := [ ] ;
41915: LD_ADDR_VAR 0 11
41919: PUSH
41920: EMPTY
41921: ST_TO_ADDR
// if sort then
41922: LD_VAR 0 9
41926: IFFALSE 42042
// for i = 1 to 4 - eng do
41928: LD_ADDR_VAR 0 3
41932: PUSH
41933: DOUBLE
41934: LD_INT 1
41936: DEC
41937: ST_TO_ADDR
41938: LD_INT 4
41940: PUSH
41941: LD_VAR 0 6
41945: MINUS
41946: PUSH
41947: FOR_TO
41948: IFFALSE 42040
// begin if i = sort then
41950: LD_VAR 0 3
41954: PUSH
41955: LD_VAR 0 9
41959: EQUAL
41960: IFFALSE 41964
// break ;
41962: GO 42040
// if GetClass ( i ) = 2 then
41964: LD_VAR 0 3
41968: PPUSH
41969: CALL_OW 257
41973: PUSH
41974: LD_INT 2
41976: EQUAL
41977: IFFALSE 41981
// continue ;
41979: GO 41947
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41981: LD_ADDR_VAR 0 11
41985: PUSH
41986: LD_VAR 0 11
41990: PPUSH
41991: LD_VAR 0 11
41995: PUSH
41996: LD_INT 1
41998: PLUS
41999: PPUSH
42000: LD_VAR 0 9
42004: PUSH
42005: LD_VAR 0 3
42009: ARRAY
42010: PPUSH
42011: CALL_OW 2
42015: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42016: LD_ADDR_VAR 0 4
42020: PUSH
42021: LD_VAR 0 4
42025: PUSH
42026: LD_VAR 0 9
42030: PUSH
42031: LD_VAR 0 3
42035: ARRAY
42036: DIFF
42037: ST_TO_ADDR
// end ;
42038: GO 41947
42040: POP
42041: POP
// if p then
42042: LD_VAR 0 11
42046: IFFALSE 42071
// result := Replace ( result , 2 , p ) ;
42048: LD_ADDR_VAR 0 2
42052: PUSH
42053: LD_VAR 0 2
42057: PPUSH
42058: LD_INT 2
42060: PPUSH
42061: LD_VAR 0 11
42065: PPUSH
42066: CALL_OW 1
42070: ST_TO_ADDR
// end else
42071: GO 42117
// for i = eng downto 5 do
42073: LD_ADDR_VAR 0 3
42077: PUSH
42078: DOUBLE
42079: LD_VAR 0 6
42083: INC
42084: ST_TO_ADDR
42085: LD_INT 5
42087: PUSH
42088: FOR_DOWNTO
42089: IFFALSE 42115
// tmp := tmp union eng [ i ] ;
42091: LD_ADDR_VAR 0 4
42095: PUSH
42096: LD_VAR 0 4
42100: PUSH
42101: LD_VAR 0 6
42105: PUSH
42106: LD_VAR 0 3
42110: ARRAY
42111: UNION
42112: ST_TO_ADDR
42113: GO 42088
42115: POP
42116: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42117: LD_ADDR_VAR 0 2
42121: PUSH
42122: LD_VAR 0 2
42126: PPUSH
42127: LD_INT 1
42129: PPUSH
42130: LD_VAR 0 4
42134: PUSH
42135: LD_VAR 0 5
42139: DIFF
42140: PPUSH
42141: CALL_OW 1
42145: ST_TO_ADDR
// exit ;
42146: GO 42148
// end ; end ;
42148: LD_VAR 0 2
42152: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42153: LD_INT 0
42155: PPUSH
42156: PPUSH
42157: PPUSH
// if not mc_bases then
42158: LD_EXP 99
42162: NOT
42163: IFFALSE 42167
// exit ;
42165: GO 42273
// for i = 1 to mc_bases do
42167: LD_ADDR_VAR 0 2
42171: PUSH
42172: DOUBLE
42173: LD_INT 1
42175: DEC
42176: ST_TO_ADDR
42177: LD_EXP 99
42181: PUSH
42182: FOR_TO
42183: IFFALSE 42264
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42185: LD_ADDR_VAR 0 3
42189: PUSH
42190: LD_EXP 99
42194: PUSH
42195: LD_VAR 0 2
42199: ARRAY
42200: PPUSH
42201: LD_INT 21
42203: PUSH
42204: LD_INT 3
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 3
42213: PUSH
42214: LD_INT 24
42216: PUSH
42217: LD_INT 1000
42219: PUSH
42220: EMPTY
42221: LIST
42222: LIST
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PPUSH
42232: CALL_OW 72
42236: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42237: LD_ADDR_EXP 100
42241: PUSH
42242: LD_EXP 100
42246: PPUSH
42247: LD_VAR 0 2
42251: PPUSH
42252: LD_VAR 0 3
42256: PPUSH
42257: CALL_OW 1
42261: ST_TO_ADDR
// end ;
42262: GO 42182
42264: POP
42265: POP
// RaiseSailEvent ( 101 ) ;
42266: LD_INT 101
42268: PPUSH
42269: CALL_OW 427
// end ;
42273: LD_VAR 0 1
42277: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42278: LD_INT 0
42280: PPUSH
42281: PPUSH
42282: PPUSH
42283: PPUSH
42284: PPUSH
42285: PPUSH
42286: PPUSH
// if not mc_bases then
42287: LD_EXP 99
42291: NOT
42292: IFFALSE 42296
// exit ;
42294: GO 42869
// for i = 1 to mc_bases do
42296: LD_ADDR_VAR 0 2
42300: PUSH
42301: DOUBLE
42302: LD_INT 1
42304: DEC
42305: ST_TO_ADDR
42306: LD_EXP 99
42310: PUSH
42311: FOR_TO
42312: IFFALSE 42860
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42314: LD_ADDR_VAR 0 5
42318: PUSH
42319: LD_EXP 99
42323: PUSH
42324: LD_VAR 0 2
42328: ARRAY
42329: PUSH
42330: LD_EXP 128
42334: PUSH
42335: LD_VAR 0 2
42339: ARRAY
42340: UNION
42341: PPUSH
42342: LD_INT 21
42344: PUSH
42345: LD_INT 1
42347: PUSH
42348: EMPTY
42349: LIST
42350: LIST
42351: PUSH
42352: LD_INT 1
42354: PUSH
42355: LD_INT 3
42357: PUSH
42358: LD_INT 54
42360: PUSH
42361: EMPTY
42362: LIST
42363: PUSH
42364: EMPTY
42365: LIST
42366: LIST
42367: PUSH
42368: LD_INT 3
42370: PUSH
42371: LD_INT 24
42373: PUSH
42374: LD_INT 800
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: EMPTY
42386: LIST
42387: LIST
42388: LIST
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PPUSH
42394: CALL_OW 72
42398: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42399: LD_ADDR_VAR 0 6
42403: PUSH
42404: LD_EXP 99
42408: PUSH
42409: LD_VAR 0 2
42413: ARRAY
42414: PPUSH
42415: LD_INT 21
42417: PUSH
42418: LD_INT 1
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 1
42427: PUSH
42428: LD_INT 3
42430: PUSH
42431: LD_INT 54
42433: PUSH
42434: EMPTY
42435: LIST
42436: PUSH
42437: EMPTY
42438: LIST
42439: LIST
42440: PUSH
42441: LD_INT 3
42443: PUSH
42444: LD_INT 24
42446: PUSH
42447: LD_INT 250
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PUSH
42454: EMPTY
42455: LIST
42456: LIST
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: LIST
42462: PUSH
42463: EMPTY
42464: LIST
42465: LIST
42466: PPUSH
42467: CALL_OW 72
42471: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42472: LD_ADDR_VAR 0 7
42476: PUSH
42477: LD_VAR 0 5
42481: PUSH
42482: LD_VAR 0 6
42486: DIFF
42487: ST_TO_ADDR
// if not need_heal_1 then
42488: LD_VAR 0 6
42492: NOT
42493: IFFALSE 42526
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42495: LD_ADDR_EXP 102
42499: PUSH
42500: LD_EXP 102
42504: PPUSH
42505: LD_VAR 0 2
42509: PUSH
42510: LD_INT 1
42512: PUSH
42513: EMPTY
42514: LIST
42515: LIST
42516: PPUSH
42517: EMPTY
42518: PPUSH
42519: CALL 70789 0 3
42523: ST_TO_ADDR
42524: GO 42596
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42526: LD_ADDR_EXP 102
42530: PUSH
42531: LD_EXP 102
42535: PPUSH
42536: LD_VAR 0 2
42540: PUSH
42541: LD_INT 1
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PPUSH
42548: LD_EXP 102
42552: PUSH
42553: LD_VAR 0 2
42557: ARRAY
42558: PUSH
42559: LD_INT 1
42561: ARRAY
42562: PPUSH
42563: LD_INT 3
42565: PUSH
42566: LD_INT 24
42568: PUSH
42569: LD_INT 1000
42571: PUSH
42572: EMPTY
42573: LIST
42574: LIST
42575: PUSH
42576: EMPTY
42577: LIST
42578: LIST
42579: PPUSH
42580: CALL_OW 72
42584: PUSH
42585: LD_VAR 0 6
42589: UNION
42590: PPUSH
42591: CALL 70789 0 3
42595: ST_TO_ADDR
// if not need_heal_2 then
42596: LD_VAR 0 7
42600: NOT
42601: IFFALSE 42634
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42603: LD_ADDR_EXP 102
42607: PUSH
42608: LD_EXP 102
42612: PPUSH
42613: LD_VAR 0 2
42617: PUSH
42618: LD_INT 2
42620: PUSH
42621: EMPTY
42622: LIST
42623: LIST
42624: PPUSH
42625: EMPTY
42626: PPUSH
42627: CALL 70789 0 3
42631: ST_TO_ADDR
42632: GO 42666
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42634: LD_ADDR_EXP 102
42638: PUSH
42639: LD_EXP 102
42643: PPUSH
42644: LD_VAR 0 2
42648: PUSH
42649: LD_INT 2
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PPUSH
42656: LD_VAR 0 7
42660: PPUSH
42661: CALL 70789 0 3
42665: ST_TO_ADDR
// if need_heal_2 then
42666: LD_VAR 0 7
42670: IFFALSE 42842
// for j in need_heal_2 do
42672: LD_ADDR_VAR 0 3
42676: PUSH
42677: LD_VAR 0 7
42681: PUSH
42682: FOR_IN
42683: IFFALSE 42840
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42685: LD_ADDR_VAR 0 5
42689: PUSH
42690: LD_EXP 99
42694: PUSH
42695: LD_VAR 0 2
42699: ARRAY
42700: PPUSH
42701: LD_INT 2
42703: PUSH
42704: LD_INT 30
42706: PUSH
42707: LD_INT 6
42709: PUSH
42710: EMPTY
42711: LIST
42712: LIST
42713: PUSH
42714: LD_INT 30
42716: PUSH
42717: LD_INT 7
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 30
42726: PUSH
42727: LD_INT 8
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: LD_INT 30
42736: PUSH
42737: LD_INT 0
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 30
42746: PUSH
42747: LD_INT 1
42749: PUSH
42750: EMPTY
42751: LIST
42752: LIST
42753: PUSH
42754: LD_INT 25
42756: PUSH
42757: LD_INT 4
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: LIST
42768: LIST
42769: LIST
42770: LIST
42771: LIST
42772: PPUSH
42773: CALL_OW 72
42777: ST_TO_ADDR
// if tmp then
42778: LD_VAR 0 5
42782: IFFALSE 42838
// begin k := NearestUnitToUnit ( tmp , j ) ;
42784: LD_ADDR_VAR 0 4
42788: PUSH
42789: LD_VAR 0 5
42793: PPUSH
42794: LD_VAR 0 3
42798: PPUSH
42799: CALL_OW 74
42803: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42804: LD_VAR 0 3
42808: PPUSH
42809: LD_VAR 0 4
42813: PPUSH
42814: CALL_OW 296
42818: PUSH
42819: LD_INT 7
42821: GREATER
42822: IFFALSE 42838
// ComMoveUnit ( j , k ) ;
42824: LD_VAR 0 3
42828: PPUSH
42829: LD_VAR 0 4
42833: PPUSH
42834: CALL_OW 112
// end ; end ;
42838: GO 42682
42840: POP
42841: POP
// if not need_heal_1 and not need_heal_2 then
42842: LD_VAR 0 6
42846: NOT
42847: PUSH
42848: LD_VAR 0 7
42852: NOT
42853: AND
42854: IFFALSE 42858
// continue ;
42856: GO 42311
// end ;
42858: GO 42311
42860: POP
42861: POP
// RaiseSailEvent ( 102 ) ;
42862: LD_INT 102
42864: PPUSH
42865: CALL_OW 427
// end ;
42869: LD_VAR 0 1
42873: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
42874: LD_INT 0
42876: PPUSH
42877: PPUSH
42878: PPUSH
42879: PPUSH
42880: PPUSH
42881: PPUSH
// if not mc_bases then
42882: LD_EXP 99
42886: NOT
42887: IFFALSE 42891
// exit ;
42889: GO 43601
// for i = 1 to mc_bases do
42891: LD_ADDR_VAR 0 2
42895: PUSH
42896: DOUBLE
42897: LD_INT 1
42899: DEC
42900: ST_TO_ADDR
42901: LD_EXP 99
42905: PUSH
42906: FOR_TO
42907: IFFALSE 43599
// begin if not mc_building_need_repair [ i ] then
42909: LD_EXP 100
42913: PUSH
42914: LD_VAR 0 2
42918: ARRAY
42919: NOT
42920: IFFALSE 43094
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
42922: LD_ADDR_VAR 0 6
42926: PUSH
42927: LD_EXP 118
42931: PUSH
42932: LD_VAR 0 2
42936: ARRAY
42937: PPUSH
42938: LD_INT 3
42940: PUSH
42941: LD_INT 24
42943: PUSH
42944: LD_INT 1000
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: LD_INT 34
42960: PUSH
42961: LD_INT 13
42963: PUSH
42964: EMPTY
42965: LIST
42966: LIST
42967: PUSH
42968: LD_INT 34
42970: PUSH
42971: LD_INT 52
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PUSH
42978: EMPTY
42979: LIST
42980: LIST
42981: LIST
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PPUSH
42987: CALL_OW 72
42991: ST_TO_ADDR
// if cranes then
42992: LD_VAR 0 6
42996: IFFALSE 43058
// for j in cranes do
42998: LD_ADDR_VAR 0 3
43002: PUSH
43003: LD_VAR 0 6
43007: PUSH
43008: FOR_IN
43009: IFFALSE 43056
// if not IsInArea ( j , mc_parking [ i ] ) then
43011: LD_VAR 0 3
43015: PPUSH
43016: LD_EXP 123
43020: PUSH
43021: LD_VAR 0 2
43025: ARRAY
43026: PPUSH
43027: CALL_OW 308
43031: NOT
43032: IFFALSE 43054
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43034: LD_VAR 0 3
43038: PPUSH
43039: LD_EXP 123
43043: PUSH
43044: LD_VAR 0 2
43048: ARRAY
43049: PPUSH
43050: CALL_OW 113
43054: GO 43008
43056: POP
43057: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43058: LD_ADDR_EXP 101
43062: PUSH
43063: LD_EXP 101
43067: PPUSH
43068: LD_VAR 0 2
43072: PPUSH
43073: EMPTY
43074: PPUSH
43075: CALL_OW 1
43079: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43080: LD_VAR 0 2
43084: PPUSH
43085: LD_INT 101
43087: PPUSH
43088: CALL 37986 0 2
// continue ;
43092: GO 42906
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43094: LD_ADDR_EXP 105
43098: PUSH
43099: LD_EXP 105
43103: PPUSH
43104: LD_VAR 0 2
43108: PPUSH
43109: EMPTY
43110: PPUSH
43111: CALL_OW 1
43115: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43116: LD_VAR 0 2
43120: PPUSH
43121: LD_INT 103
43123: PPUSH
43124: CALL 37986 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43128: LD_ADDR_VAR 0 5
43132: PUSH
43133: LD_EXP 99
43137: PUSH
43138: LD_VAR 0 2
43142: ARRAY
43143: PUSH
43144: LD_EXP 128
43148: PUSH
43149: LD_VAR 0 2
43153: ARRAY
43154: UNION
43155: PPUSH
43156: LD_INT 2
43158: PUSH
43159: LD_INT 25
43161: PUSH
43162: LD_INT 2
43164: PUSH
43165: EMPTY
43166: LIST
43167: LIST
43168: PUSH
43169: LD_INT 25
43171: PUSH
43172: LD_INT 16
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: EMPTY
43180: LIST
43181: LIST
43182: LIST
43183: PUSH
43184: EMPTY
43185: LIST
43186: PPUSH
43187: CALL_OW 72
43191: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43192: LD_ADDR_VAR 0 6
43196: PUSH
43197: LD_EXP 118
43201: PUSH
43202: LD_VAR 0 2
43206: ARRAY
43207: PPUSH
43208: LD_INT 2
43210: PUSH
43211: LD_INT 34
43213: PUSH
43214: LD_INT 13
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 34
43223: PUSH
43224: LD_INT 52
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: LIST
43235: PPUSH
43236: CALL_OW 72
43240: ST_TO_ADDR
// if cranes then
43241: LD_VAR 0 6
43245: IFFALSE 43381
// begin for j in cranes do
43247: LD_ADDR_VAR 0 3
43251: PUSH
43252: LD_VAR 0 6
43256: PUSH
43257: FOR_IN
43258: IFFALSE 43379
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43260: LD_VAR 0 3
43264: PPUSH
43265: CALL_OW 256
43269: PUSH
43270: LD_INT 500
43272: GREATEREQUAL
43273: PUSH
43274: LD_VAR 0 3
43278: PPUSH
43279: CALL_OW 314
43283: NOT
43284: AND
43285: IFFALSE 43319
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43287: LD_VAR 0 3
43291: PPUSH
43292: LD_EXP 100
43296: PUSH
43297: LD_VAR 0 2
43301: ARRAY
43302: PPUSH
43303: LD_VAR 0 3
43307: PPUSH
43308: CALL_OW 74
43312: PPUSH
43313: CALL_OW 130
43317: GO 43377
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43319: LD_VAR 0 3
43323: PPUSH
43324: CALL_OW 256
43328: PUSH
43329: LD_INT 500
43331: LESS
43332: PUSH
43333: LD_VAR 0 3
43337: PPUSH
43338: LD_EXP 123
43342: PUSH
43343: LD_VAR 0 2
43347: ARRAY
43348: PPUSH
43349: CALL_OW 308
43353: NOT
43354: AND
43355: IFFALSE 43377
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43357: LD_VAR 0 3
43361: PPUSH
43362: LD_EXP 123
43366: PUSH
43367: LD_VAR 0 2
43371: ARRAY
43372: PPUSH
43373: CALL_OW 113
43377: GO 43257
43379: POP
43380: POP
// end ; if not tmp then
43381: LD_VAR 0 5
43385: NOT
43386: IFFALSE 43390
// continue ;
43388: GO 42906
// for j in tmp do
43390: LD_ADDR_VAR 0 3
43394: PUSH
43395: LD_VAR 0 5
43399: PUSH
43400: FOR_IN
43401: IFFALSE 43595
// begin if mc_need_heal [ i ] then
43403: LD_EXP 102
43407: PUSH
43408: LD_VAR 0 2
43412: ARRAY
43413: IFFALSE 43461
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43415: LD_VAR 0 3
43419: PUSH
43420: LD_EXP 102
43424: PUSH
43425: LD_VAR 0 2
43429: ARRAY
43430: PUSH
43431: LD_INT 1
43433: ARRAY
43434: IN
43435: PUSH
43436: LD_VAR 0 3
43440: PUSH
43441: LD_EXP 102
43445: PUSH
43446: LD_VAR 0 2
43450: ARRAY
43451: PUSH
43452: LD_INT 2
43454: ARRAY
43455: IN
43456: OR
43457: IFFALSE 43461
// continue ;
43459: GO 43400
// if IsInUnit ( j ) then
43461: LD_VAR 0 3
43465: PPUSH
43466: CALL_OW 310
43470: IFFALSE 43481
// ComExitBuilding ( j ) ;
43472: LD_VAR 0 3
43476: PPUSH
43477: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43481: LD_VAR 0 3
43485: PUSH
43486: LD_EXP 101
43490: PUSH
43491: LD_VAR 0 2
43495: ARRAY
43496: IN
43497: NOT
43498: IFFALSE 43556
// begin SetTag ( j , 101 ) ;
43500: LD_VAR 0 3
43504: PPUSH
43505: LD_INT 101
43507: PPUSH
43508: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43512: LD_ADDR_EXP 101
43516: PUSH
43517: LD_EXP 101
43521: PPUSH
43522: LD_VAR 0 2
43526: PUSH
43527: LD_EXP 101
43531: PUSH
43532: LD_VAR 0 2
43536: ARRAY
43537: PUSH
43538: LD_INT 1
43540: PLUS
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PPUSH
43546: LD_VAR 0 3
43550: PPUSH
43551: CALL 70789 0 3
43555: ST_TO_ADDR
// end ; wait ( 1 ) ;
43556: LD_INT 1
43558: PPUSH
43559: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43563: LD_VAR 0 3
43567: PPUSH
43568: LD_EXP 100
43572: PUSH
43573: LD_VAR 0 2
43577: ARRAY
43578: PPUSH
43579: LD_VAR 0 3
43583: PPUSH
43584: CALL_OW 74
43588: PPUSH
43589: CALL_OW 130
// end ;
43593: GO 43400
43595: POP
43596: POP
// end ;
43597: GO 42906
43599: POP
43600: POP
// end ;
43601: LD_VAR 0 1
43605: RET
// export function MC_Heal ; var i , j , tmp ; begin
43606: LD_INT 0
43608: PPUSH
43609: PPUSH
43610: PPUSH
43611: PPUSH
// if not mc_bases then
43612: LD_EXP 99
43616: NOT
43617: IFFALSE 43621
// exit ;
43619: GO 44023
// for i = 1 to mc_bases do
43621: LD_ADDR_VAR 0 2
43625: PUSH
43626: DOUBLE
43627: LD_INT 1
43629: DEC
43630: ST_TO_ADDR
43631: LD_EXP 99
43635: PUSH
43636: FOR_TO
43637: IFFALSE 44021
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43639: LD_EXP 102
43643: PUSH
43644: LD_VAR 0 2
43648: ARRAY
43649: PUSH
43650: LD_INT 1
43652: ARRAY
43653: NOT
43654: PUSH
43655: LD_EXP 102
43659: PUSH
43660: LD_VAR 0 2
43664: ARRAY
43665: PUSH
43666: LD_INT 2
43668: ARRAY
43669: NOT
43670: AND
43671: IFFALSE 43709
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43673: LD_ADDR_EXP 103
43677: PUSH
43678: LD_EXP 103
43682: PPUSH
43683: LD_VAR 0 2
43687: PPUSH
43688: EMPTY
43689: PPUSH
43690: CALL_OW 1
43694: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43695: LD_VAR 0 2
43699: PPUSH
43700: LD_INT 102
43702: PPUSH
43703: CALL 37986 0 2
// continue ;
43707: GO 43636
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43709: LD_ADDR_VAR 0 4
43713: PUSH
43714: LD_EXP 99
43718: PUSH
43719: LD_VAR 0 2
43723: ARRAY
43724: PPUSH
43725: LD_INT 25
43727: PUSH
43728: LD_INT 4
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PPUSH
43735: CALL_OW 72
43739: ST_TO_ADDR
// if not tmp then
43740: LD_VAR 0 4
43744: NOT
43745: IFFALSE 43749
// continue ;
43747: GO 43636
// if mc_taming [ i ] then
43749: LD_EXP 130
43753: PUSH
43754: LD_VAR 0 2
43758: ARRAY
43759: IFFALSE 43783
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43761: LD_ADDR_EXP 130
43765: PUSH
43766: LD_EXP 130
43770: PPUSH
43771: LD_VAR 0 2
43775: PPUSH
43776: EMPTY
43777: PPUSH
43778: CALL_OW 1
43782: ST_TO_ADDR
// for j in tmp do
43783: LD_ADDR_VAR 0 3
43787: PUSH
43788: LD_VAR 0 4
43792: PUSH
43793: FOR_IN
43794: IFFALSE 44017
// begin if IsInUnit ( j ) then
43796: LD_VAR 0 3
43800: PPUSH
43801: CALL_OW 310
43805: IFFALSE 43816
// ComExitBuilding ( j ) ;
43807: LD_VAR 0 3
43811: PPUSH
43812: CALL_OW 122
// if not j in mc_healers [ i ] then
43816: LD_VAR 0 3
43820: PUSH
43821: LD_EXP 103
43825: PUSH
43826: LD_VAR 0 2
43830: ARRAY
43831: IN
43832: NOT
43833: IFFALSE 43879
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43835: LD_ADDR_EXP 103
43839: PUSH
43840: LD_EXP 103
43844: PPUSH
43845: LD_VAR 0 2
43849: PUSH
43850: LD_EXP 103
43854: PUSH
43855: LD_VAR 0 2
43859: ARRAY
43860: PUSH
43861: LD_INT 1
43863: PLUS
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PPUSH
43869: LD_VAR 0 3
43873: PPUSH
43874: CALL 70789 0 3
43878: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43879: LD_VAR 0 3
43883: PPUSH
43884: CALL_OW 110
43888: PUSH
43889: LD_INT 102
43891: NONEQUAL
43892: IFFALSE 43906
// SetTag ( j , 102 ) ;
43894: LD_VAR 0 3
43898: PPUSH
43899: LD_INT 102
43901: PPUSH
43902: CALL_OW 109
// Wait ( 3 ) ;
43906: LD_INT 3
43908: PPUSH
43909: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43913: LD_EXP 102
43917: PUSH
43918: LD_VAR 0 2
43922: ARRAY
43923: PUSH
43924: LD_INT 1
43926: ARRAY
43927: IFFALSE 43959
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43929: LD_VAR 0 3
43933: PPUSH
43934: LD_EXP 102
43938: PUSH
43939: LD_VAR 0 2
43943: ARRAY
43944: PUSH
43945: LD_INT 1
43947: ARRAY
43948: PUSH
43949: LD_INT 1
43951: ARRAY
43952: PPUSH
43953: CALL_OW 128
43957: GO 44015
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43959: LD_VAR 0 3
43963: PPUSH
43964: CALL_OW 314
43968: NOT
43969: PUSH
43970: LD_EXP 102
43974: PUSH
43975: LD_VAR 0 2
43979: ARRAY
43980: PUSH
43981: LD_INT 2
43983: ARRAY
43984: AND
43985: IFFALSE 44015
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
43987: LD_VAR 0 3
43991: PPUSH
43992: LD_EXP 102
43996: PUSH
43997: LD_VAR 0 2
44001: ARRAY
44002: PUSH
44003: LD_INT 2
44005: ARRAY
44006: PUSH
44007: LD_INT 1
44009: ARRAY
44010: PPUSH
44011: CALL_OW 128
// end ;
44015: GO 43793
44017: POP
44018: POP
// end ;
44019: GO 43636
44021: POP
44022: POP
// end ;
44023: LD_VAR 0 1
44027: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44028: LD_INT 0
44030: PPUSH
44031: PPUSH
44032: PPUSH
44033: PPUSH
44034: PPUSH
// if not mc_bases then
44035: LD_EXP 99
44039: NOT
44040: IFFALSE 44044
// exit ;
44042: GO 45187
// for i = 1 to mc_bases do
44044: LD_ADDR_VAR 0 2
44048: PUSH
44049: DOUBLE
44050: LD_INT 1
44052: DEC
44053: ST_TO_ADDR
44054: LD_EXP 99
44058: PUSH
44059: FOR_TO
44060: IFFALSE 45185
// begin if mc_scan [ i ] then
44062: LD_EXP 122
44066: PUSH
44067: LD_VAR 0 2
44071: ARRAY
44072: IFFALSE 44076
// continue ;
44074: GO 44059
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
44076: LD_EXP 104
44080: PUSH
44081: LD_VAR 0 2
44085: ARRAY
44086: NOT
44087: PUSH
44088: LD_EXP 106
44092: PUSH
44093: LD_VAR 0 2
44097: ARRAY
44098: NOT
44099: AND
44100: PUSH
44101: LD_EXP 105
44105: PUSH
44106: LD_VAR 0 2
44110: ARRAY
44111: AND
44112: IFFALSE 44150
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44114: LD_ADDR_EXP 105
44118: PUSH
44119: LD_EXP 105
44123: PPUSH
44124: LD_VAR 0 2
44128: PPUSH
44129: EMPTY
44130: PPUSH
44131: CALL_OW 1
44135: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44136: LD_VAR 0 2
44140: PPUSH
44141: LD_INT 103
44143: PPUSH
44144: CALL 37986 0 2
// continue ;
44148: GO 44059
// end ; if mc_construct_list [ i ] then
44150: LD_EXP 106
44154: PUSH
44155: LD_VAR 0 2
44159: ARRAY
44160: IFFALSE 44380
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44162: LD_ADDR_VAR 0 4
44166: PUSH
44167: LD_EXP 99
44171: PUSH
44172: LD_VAR 0 2
44176: ARRAY
44177: PPUSH
44178: LD_INT 25
44180: PUSH
44181: LD_INT 2
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PPUSH
44188: CALL_OW 72
44192: PUSH
44193: LD_EXP 101
44197: PUSH
44198: LD_VAR 0 2
44202: ARRAY
44203: DIFF
44204: ST_TO_ADDR
// if not tmp then
44205: LD_VAR 0 4
44209: NOT
44210: IFFALSE 44214
// continue ;
44212: GO 44059
// for j in tmp do
44214: LD_ADDR_VAR 0 3
44218: PUSH
44219: LD_VAR 0 4
44223: PUSH
44224: FOR_IN
44225: IFFALSE 44376
// begin if not mc_builders [ i ] then
44227: LD_EXP 105
44231: PUSH
44232: LD_VAR 0 2
44236: ARRAY
44237: NOT
44238: IFFALSE 44296
// begin SetTag ( j , 103 ) ;
44240: LD_VAR 0 3
44244: PPUSH
44245: LD_INT 103
44247: PPUSH
44248: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44252: LD_ADDR_EXP 105
44256: PUSH
44257: LD_EXP 105
44261: PPUSH
44262: LD_VAR 0 2
44266: PUSH
44267: LD_EXP 105
44271: PUSH
44272: LD_VAR 0 2
44276: ARRAY
44277: PUSH
44278: LD_INT 1
44280: PLUS
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PPUSH
44286: LD_VAR 0 3
44290: PPUSH
44291: CALL 70789 0 3
44295: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44296: LD_VAR 0 3
44300: PPUSH
44301: CALL_OW 310
44305: IFFALSE 44316
// ComExitBuilding ( j ) ;
44307: LD_VAR 0 3
44311: PPUSH
44312: CALL_OW 122
// wait ( 3 ) ;
44316: LD_INT 3
44318: PPUSH
44319: CALL_OW 67
// if not mc_construct_list [ i ] then
44323: LD_EXP 106
44327: PUSH
44328: LD_VAR 0 2
44332: ARRAY
44333: NOT
44334: IFFALSE 44338
// break ;
44336: GO 44376
// if not HasTask ( j ) then
44338: LD_VAR 0 3
44342: PPUSH
44343: CALL_OW 314
44347: NOT
44348: IFFALSE 44374
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44350: LD_VAR 0 3
44354: PPUSH
44355: LD_EXP 106
44359: PUSH
44360: LD_VAR 0 2
44364: ARRAY
44365: PUSH
44366: LD_INT 1
44368: ARRAY
44369: PPUSH
44370: CALL 73640 0 2
// end ;
44374: GO 44224
44376: POP
44377: POP
// end else
44378: GO 45183
// if mc_build_list [ i ] then
44380: LD_EXP 104
44384: PUSH
44385: LD_VAR 0 2
44389: ARRAY
44390: IFFALSE 45183
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44392: LD_ADDR_VAR 0 5
44396: PUSH
44397: LD_EXP 99
44401: PUSH
44402: LD_VAR 0 2
44406: ARRAY
44407: PPUSH
44408: LD_INT 2
44410: PUSH
44411: LD_INT 30
44413: PUSH
44414: LD_INT 0
44416: PUSH
44417: EMPTY
44418: LIST
44419: LIST
44420: PUSH
44421: LD_INT 30
44423: PUSH
44424: LD_INT 1
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: LIST
44435: PPUSH
44436: CALL_OW 72
44440: ST_TO_ADDR
// if depot then
44441: LD_VAR 0 5
44445: IFFALSE 44463
// depot := depot [ 1 ] else
44447: LD_ADDR_VAR 0 5
44451: PUSH
44452: LD_VAR 0 5
44456: PUSH
44457: LD_INT 1
44459: ARRAY
44460: ST_TO_ADDR
44461: GO 44471
// depot := 0 ;
44463: LD_ADDR_VAR 0 5
44467: PUSH
44468: LD_INT 0
44470: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44471: LD_EXP 104
44475: PUSH
44476: LD_VAR 0 2
44480: ARRAY
44481: PUSH
44482: LD_INT 1
44484: ARRAY
44485: PUSH
44486: LD_INT 1
44488: ARRAY
44489: PPUSH
44490: CALL 73470 0 1
44494: PUSH
44495: LD_EXP 99
44499: PUSH
44500: LD_VAR 0 2
44504: ARRAY
44505: PPUSH
44506: LD_INT 2
44508: PUSH
44509: LD_INT 30
44511: PUSH
44512: LD_INT 2
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: LD_INT 30
44521: PUSH
44522: LD_INT 3
44524: PUSH
44525: EMPTY
44526: LIST
44527: LIST
44528: PUSH
44529: EMPTY
44530: LIST
44531: LIST
44532: LIST
44533: PPUSH
44534: CALL_OW 72
44538: NOT
44539: AND
44540: IFFALSE 44645
// begin for j = 1 to mc_build_list [ i ] do
44542: LD_ADDR_VAR 0 3
44546: PUSH
44547: DOUBLE
44548: LD_INT 1
44550: DEC
44551: ST_TO_ADDR
44552: LD_EXP 104
44556: PUSH
44557: LD_VAR 0 2
44561: ARRAY
44562: PUSH
44563: FOR_TO
44564: IFFALSE 44643
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44566: LD_EXP 104
44570: PUSH
44571: LD_VAR 0 2
44575: ARRAY
44576: PUSH
44577: LD_VAR 0 3
44581: ARRAY
44582: PUSH
44583: LD_INT 1
44585: ARRAY
44586: PUSH
44587: LD_INT 2
44589: EQUAL
44590: IFFALSE 44641
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44592: LD_ADDR_EXP 104
44596: PUSH
44597: LD_EXP 104
44601: PPUSH
44602: LD_VAR 0 2
44606: PPUSH
44607: LD_EXP 104
44611: PUSH
44612: LD_VAR 0 2
44616: ARRAY
44617: PPUSH
44618: LD_VAR 0 3
44622: PPUSH
44623: LD_INT 1
44625: PPUSH
44626: LD_INT 0
44628: PPUSH
44629: CALL 70207 0 4
44633: PPUSH
44634: CALL_OW 1
44638: ST_TO_ADDR
// break ;
44639: GO 44643
// end ;
44641: GO 44563
44643: POP
44644: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44645: LD_EXP 104
44649: PUSH
44650: LD_VAR 0 2
44654: ARRAY
44655: PUSH
44656: LD_INT 1
44658: ARRAY
44659: PUSH
44660: LD_INT 1
44662: ARRAY
44663: PUSH
44664: LD_INT 0
44666: EQUAL
44667: PUSH
44668: LD_VAR 0 5
44672: PUSH
44673: LD_VAR 0 5
44677: PPUSH
44678: LD_EXP 104
44682: PUSH
44683: LD_VAR 0 2
44687: ARRAY
44688: PUSH
44689: LD_INT 1
44691: ARRAY
44692: PUSH
44693: LD_INT 1
44695: ARRAY
44696: PPUSH
44697: LD_EXP 104
44701: PUSH
44702: LD_VAR 0 2
44706: ARRAY
44707: PUSH
44708: LD_INT 1
44710: ARRAY
44711: PUSH
44712: LD_INT 2
44714: ARRAY
44715: PPUSH
44716: LD_EXP 104
44720: PUSH
44721: LD_VAR 0 2
44725: ARRAY
44726: PUSH
44727: LD_INT 1
44729: ARRAY
44730: PUSH
44731: LD_INT 3
44733: ARRAY
44734: PPUSH
44735: LD_EXP 104
44739: PUSH
44740: LD_VAR 0 2
44744: ARRAY
44745: PUSH
44746: LD_INT 1
44748: ARRAY
44749: PUSH
44750: LD_INT 4
44752: ARRAY
44753: PPUSH
44754: CALL 78204 0 5
44758: AND
44759: OR
44760: IFFALSE 45041
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44762: LD_ADDR_VAR 0 4
44766: PUSH
44767: LD_EXP 99
44771: PUSH
44772: LD_VAR 0 2
44776: ARRAY
44777: PPUSH
44778: LD_INT 25
44780: PUSH
44781: LD_INT 2
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: PPUSH
44788: CALL_OW 72
44792: PUSH
44793: LD_EXP 101
44797: PUSH
44798: LD_VAR 0 2
44802: ARRAY
44803: DIFF
44804: ST_TO_ADDR
// if not tmp then
44805: LD_VAR 0 4
44809: NOT
44810: IFFALSE 44814
// continue ;
44812: GO 44059
// for j in tmp do
44814: LD_ADDR_VAR 0 3
44818: PUSH
44819: LD_VAR 0 4
44823: PUSH
44824: FOR_IN
44825: IFFALSE 45037
// begin if not mc_builders [ i ] then
44827: LD_EXP 105
44831: PUSH
44832: LD_VAR 0 2
44836: ARRAY
44837: NOT
44838: IFFALSE 44896
// begin SetTag ( j , 103 ) ;
44840: LD_VAR 0 3
44844: PPUSH
44845: LD_INT 103
44847: PPUSH
44848: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44852: LD_ADDR_EXP 105
44856: PUSH
44857: LD_EXP 105
44861: PPUSH
44862: LD_VAR 0 2
44866: PUSH
44867: LD_EXP 105
44871: PUSH
44872: LD_VAR 0 2
44876: ARRAY
44877: PUSH
44878: LD_INT 1
44880: PLUS
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: PPUSH
44886: LD_VAR 0 3
44890: PPUSH
44891: CALL 70789 0 3
44895: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44896: LD_VAR 0 3
44900: PPUSH
44901: CALL_OW 310
44905: IFFALSE 44916
// ComExitBuilding ( j ) ;
44907: LD_VAR 0 3
44911: PPUSH
44912: CALL_OW 122
// wait ( 3 ) ;
44916: LD_INT 3
44918: PPUSH
44919: CALL_OW 67
// if not mc_build_list [ i ] then
44923: LD_EXP 104
44927: PUSH
44928: LD_VAR 0 2
44932: ARRAY
44933: NOT
44934: IFFALSE 44938
// break ;
44936: GO 45037
// if not HasTask ( j ) then
44938: LD_VAR 0 3
44942: PPUSH
44943: CALL_OW 314
44947: NOT
44948: IFFALSE 45035
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44950: LD_VAR 0 3
44954: PPUSH
44955: LD_EXP 104
44959: PUSH
44960: LD_VAR 0 2
44964: ARRAY
44965: PUSH
44966: LD_INT 1
44968: ARRAY
44969: PUSH
44970: LD_INT 1
44972: ARRAY
44973: PPUSH
44974: LD_EXP 104
44978: PUSH
44979: LD_VAR 0 2
44983: ARRAY
44984: PUSH
44985: LD_INT 1
44987: ARRAY
44988: PUSH
44989: LD_INT 2
44991: ARRAY
44992: PPUSH
44993: LD_EXP 104
44997: PUSH
44998: LD_VAR 0 2
45002: ARRAY
45003: PUSH
45004: LD_INT 1
45006: ARRAY
45007: PUSH
45008: LD_INT 3
45010: ARRAY
45011: PPUSH
45012: LD_EXP 104
45016: PUSH
45017: LD_VAR 0 2
45021: ARRAY
45022: PUSH
45023: LD_INT 1
45025: ARRAY
45026: PUSH
45027: LD_INT 4
45029: ARRAY
45030: PPUSH
45031: CALL_OW 145
// end ;
45035: GO 44824
45037: POP
45038: POP
// end else
45039: GO 45183
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45041: LD_EXP 99
45045: PUSH
45046: LD_VAR 0 2
45050: ARRAY
45051: PPUSH
45052: LD_EXP 104
45056: PUSH
45057: LD_VAR 0 2
45061: ARRAY
45062: PUSH
45063: LD_INT 1
45065: ARRAY
45066: PUSH
45067: LD_INT 1
45069: ARRAY
45070: PPUSH
45071: LD_EXP 104
45075: PUSH
45076: LD_VAR 0 2
45080: ARRAY
45081: PUSH
45082: LD_INT 1
45084: ARRAY
45085: PUSH
45086: LD_INT 2
45088: ARRAY
45089: PPUSH
45090: LD_EXP 104
45094: PUSH
45095: LD_VAR 0 2
45099: ARRAY
45100: PUSH
45101: LD_INT 1
45103: ARRAY
45104: PUSH
45105: LD_INT 3
45107: ARRAY
45108: PPUSH
45109: LD_EXP 104
45113: PUSH
45114: LD_VAR 0 2
45118: ARRAY
45119: PUSH
45120: LD_INT 1
45122: ARRAY
45123: PUSH
45124: LD_INT 4
45126: ARRAY
45127: PPUSH
45128: CALL 77540 0 5
45132: NOT
45133: IFFALSE 45183
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45135: LD_ADDR_EXP 104
45139: PUSH
45140: LD_EXP 104
45144: PPUSH
45145: LD_VAR 0 2
45149: PPUSH
45150: LD_EXP 104
45154: PUSH
45155: LD_VAR 0 2
45159: ARRAY
45160: PPUSH
45161: LD_INT 1
45163: PPUSH
45164: LD_INT 1
45166: NEG
45167: PPUSH
45168: LD_INT 0
45170: PPUSH
45171: CALL 70207 0 4
45175: PPUSH
45176: CALL_OW 1
45180: ST_TO_ADDR
// continue ;
45181: GO 44059
// end ; end ; end ;
45183: GO 44059
45185: POP
45186: POP
// end ;
45187: LD_VAR 0 1
45191: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45192: LD_INT 0
45194: PPUSH
45195: PPUSH
45196: PPUSH
45197: PPUSH
45198: PPUSH
45199: PPUSH
// if not mc_bases then
45200: LD_EXP 99
45204: NOT
45205: IFFALSE 45209
// exit ;
45207: GO 45636
// for i = 1 to mc_bases do
45209: LD_ADDR_VAR 0 2
45213: PUSH
45214: DOUBLE
45215: LD_INT 1
45217: DEC
45218: ST_TO_ADDR
45219: LD_EXP 99
45223: PUSH
45224: FOR_TO
45225: IFFALSE 45634
// begin tmp := mc_build_upgrade [ i ] ;
45227: LD_ADDR_VAR 0 4
45231: PUSH
45232: LD_EXP 131
45236: PUSH
45237: LD_VAR 0 2
45241: ARRAY
45242: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45243: LD_ADDR_VAR 0 6
45247: PUSH
45248: LD_EXP 132
45252: PUSH
45253: LD_VAR 0 2
45257: ARRAY
45258: PPUSH
45259: LD_INT 2
45261: PUSH
45262: LD_INT 30
45264: PUSH
45265: LD_INT 6
45267: PUSH
45268: EMPTY
45269: LIST
45270: LIST
45271: PUSH
45272: LD_INT 30
45274: PUSH
45275: LD_INT 7
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: LIST
45286: PPUSH
45287: CALL_OW 72
45291: ST_TO_ADDR
// if not tmp and not lab then
45292: LD_VAR 0 4
45296: NOT
45297: PUSH
45298: LD_VAR 0 6
45302: NOT
45303: AND
45304: IFFALSE 45308
// continue ;
45306: GO 45224
// if tmp then
45308: LD_VAR 0 4
45312: IFFALSE 45432
// for j in tmp do
45314: LD_ADDR_VAR 0 3
45318: PUSH
45319: LD_VAR 0 4
45323: PUSH
45324: FOR_IN
45325: IFFALSE 45430
// begin if UpgradeCost ( j ) then
45327: LD_VAR 0 3
45331: PPUSH
45332: CALL 77200 0 1
45336: IFFALSE 45428
// begin ComUpgrade ( j ) ;
45338: LD_VAR 0 3
45342: PPUSH
45343: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45347: LD_ADDR_EXP 131
45351: PUSH
45352: LD_EXP 131
45356: PPUSH
45357: LD_VAR 0 2
45361: PPUSH
45362: LD_EXP 131
45366: PUSH
45367: LD_VAR 0 2
45371: ARRAY
45372: PUSH
45373: LD_VAR 0 3
45377: DIFF
45378: PPUSH
45379: CALL_OW 1
45383: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45384: LD_ADDR_EXP 106
45388: PUSH
45389: LD_EXP 106
45393: PPUSH
45394: LD_VAR 0 2
45398: PUSH
45399: LD_EXP 106
45403: PUSH
45404: LD_VAR 0 2
45408: ARRAY
45409: PUSH
45410: LD_INT 1
45412: PLUS
45413: PUSH
45414: EMPTY
45415: LIST
45416: LIST
45417: PPUSH
45418: LD_VAR 0 3
45422: PPUSH
45423: CALL 70789 0 3
45427: ST_TO_ADDR
// end ; end ;
45428: GO 45324
45430: POP
45431: POP
// if not lab or not mc_lab_upgrade [ i ] then
45432: LD_VAR 0 6
45436: NOT
45437: PUSH
45438: LD_EXP 133
45442: PUSH
45443: LD_VAR 0 2
45447: ARRAY
45448: NOT
45449: OR
45450: IFFALSE 45454
// continue ;
45452: GO 45224
// for j in lab do
45454: LD_ADDR_VAR 0 3
45458: PUSH
45459: LD_VAR 0 6
45463: PUSH
45464: FOR_IN
45465: IFFALSE 45630
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45467: LD_VAR 0 3
45471: PPUSH
45472: CALL_OW 266
45476: PUSH
45477: LD_INT 6
45479: PUSH
45480: LD_INT 7
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: IN
45487: PUSH
45488: LD_VAR 0 3
45492: PPUSH
45493: CALL_OW 461
45497: PUSH
45498: LD_INT 1
45500: NONEQUAL
45501: AND
45502: IFFALSE 45628
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45504: LD_VAR 0 3
45508: PPUSH
45509: LD_EXP 133
45513: PUSH
45514: LD_VAR 0 2
45518: ARRAY
45519: PUSH
45520: LD_INT 1
45522: ARRAY
45523: PPUSH
45524: CALL 77405 0 2
45528: IFFALSE 45628
// begin ComCancel ( j ) ;
45530: LD_VAR 0 3
45534: PPUSH
45535: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45539: LD_VAR 0 3
45543: PPUSH
45544: LD_EXP 133
45548: PUSH
45549: LD_VAR 0 2
45553: ARRAY
45554: PUSH
45555: LD_INT 1
45557: ARRAY
45558: PPUSH
45559: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45563: LD_VAR 0 3
45567: PUSH
45568: LD_EXP 106
45572: PUSH
45573: LD_VAR 0 2
45577: ARRAY
45578: IN
45579: NOT
45580: IFFALSE 45626
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45582: LD_ADDR_EXP 106
45586: PUSH
45587: LD_EXP 106
45591: PPUSH
45592: LD_VAR 0 2
45596: PUSH
45597: LD_EXP 106
45601: PUSH
45602: LD_VAR 0 2
45606: ARRAY
45607: PUSH
45608: LD_INT 1
45610: PLUS
45611: PUSH
45612: EMPTY
45613: LIST
45614: LIST
45615: PPUSH
45616: LD_VAR 0 3
45620: PPUSH
45621: CALL 70789 0 3
45625: ST_TO_ADDR
// break ;
45626: GO 45630
// end ; end ; end ;
45628: GO 45464
45630: POP
45631: POP
// end ;
45632: GO 45224
45634: POP
45635: POP
// end ;
45636: LD_VAR 0 1
45640: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45641: LD_INT 0
45643: PPUSH
45644: PPUSH
45645: PPUSH
45646: PPUSH
45647: PPUSH
45648: PPUSH
45649: PPUSH
45650: PPUSH
45651: PPUSH
// if not mc_bases then
45652: LD_EXP 99
45656: NOT
45657: IFFALSE 45661
// exit ;
45659: GO 46066
// for i = 1 to mc_bases do
45661: LD_ADDR_VAR 0 2
45665: PUSH
45666: DOUBLE
45667: LD_INT 1
45669: DEC
45670: ST_TO_ADDR
45671: LD_EXP 99
45675: PUSH
45676: FOR_TO
45677: IFFALSE 46064
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45679: LD_EXP 107
45683: PUSH
45684: LD_VAR 0 2
45688: ARRAY
45689: NOT
45690: PUSH
45691: LD_EXP 99
45695: PUSH
45696: LD_VAR 0 2
45700: ARRAY
45701: PPUSH
45702: LD_INT 30
45704: PUSH
45705: LD_INT 3
45707: PUSH
45708: EMPTY
45709: LIST
45710: LIST
45711: PPUSH
45712: CALL_OW 72
45716: NOT
45717: OR
45718: IFFALSE 45722
// continue ;
45720: GO 45676
// busy := false ;
45722: LD_ADDR_VAR 0 8
45726: PUSH
45727: LD_INT 0
45729: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45730: LD_ADDR_VAR 0 4
45734: PUSH
45735: LD_EXP 99
45739: PUSH
45740: LD_VAR 0 2
45744: ARRAY
45745: PPUSH
45746: LD_INT 30
45748: PUSH
45749: LD_INT 3
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PPUSH
45756: CALL_OW 72
45760: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45761: LD_ADDR_VAR 0 6
45765: PUSH
45766: LD_EXP 107
45770: PUSH
45771: LD_VAR 0 2
45775: ARRAY
45776: PPUSH
45777: LD_INT 2
45779: PUSH
45780: LD_INT 30
45782: PUSH
45783: LD_INT 32
45785: PUSH
45786: EMPTY
45787: LIST
45788: LIST
45789: PUSH
45790: LD_INT 30
45792: PUSH
45793: LD_INT 33
45795: PUSH
45796: EMPTY
45797: LIST
45798: LIST
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: LIST
45804: PPUSH
45805: CALL_OW 72
45809: ST_TO_ADDR
// if not t then
45810: LD_VAR 0 6
45814: NOT
45815: IFFALSE 45819
// continue ;
45817: GO 45676
// for j in tmp do
45819: LD_ADDR_VAR 0 3
45823: PUSH
45824: LD_VAR 0 4
45828: PUSH
45829: FOR_IN
45830: IFFALSE 45860
// if not BuildingStatus ( j ) = bs_idle then
45832: LD_VAR 0 3
45836: PPUSH
45837: CALL_OW 461
45841: PUSH
45842: LD_INT 2
45844: EQUAL
45845: NOT
45846: IFFALSE 45858
// begin busy := true ;
45848: LD_ADDR_VAR 0 8
45852: PUSH
45853: LD_INT 1
45855: ST_TO_ADDR
// break ;
45856: GO 45860
// end ;
45858: GO 45829
45860: POP
45861: POP
// if busy then
45862: LD_VAR 0 8
45866: IFFALSE 45870
// continue ;
45868: GO 45676
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45870: LD_ADDR_VAR 0 7
45874: PUSH
45875: LD_VAR 0 6
45879: PPUSH
45880: LD_INT 35
45882: PUSH
45883: LD_INT 0
45885: PUSH
45886: EMPTY
45887: LIST
45888: LIST
45889: PPUSH
45890: CALL_OW 72
45894: ST_TO_ADDR
// if tw then
45895: LD_VAR 0 7
45899: IFFALSE 45976
// begin tw := tw [ 1 ] ;
45901: LD_ADDR_VAR 0 7
45905: PUSH
45906: LD_VAR 0 7
45910: PUSH
45911: LD_INT 1
45913: ARRAY
45914: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45915: LD_ADDR_VAR 0 9
45919: PUSH
45920: LD_VAR 0 7
45924: PPUSH
45925: LD_EXP 124
45929: PUSH
45930: LD_VAR 0 2
45934: ARRAY
45935: PPUSH
45936: CALL 75759 0 2
45940: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45941: LD_EXP 138
45945: PUSH
45946: LD_VAR 0 2
45950: ARRAY
45951: IFFALSE 45974
// if not weapon in mc_allowed_tower_weapons [ i ] then
45953: LD_VAR 0 9
45957: PUSH
45958: LD_EXP 138
45962: PUSH
45963: LD_VAR 0 2
45967: ARRAY
45968: IN
45969: NOT
45970: IFFALSE 45974
// continue ;
45972: GO 45676
// end else
45974: GO 46039
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45976: LD_ADDR_VAR 0 5
45980: PUSH
45981: LD_EXP 107
45985: PUSH
45986: LD_VAR 0 2
45990: ARRAY
45991: PPUSH
45992: LD_VAR 0 4
45996: PPUSH
45997: CALL 105960 0 2
46001: ST_TO_ADDR
// if not tmp2 then
46002: LD_VAR 0 5
46006: NOT
46007: IFFALSE 46011
// continue ;
46009: GO 45676
// tw := tmp2 [ 1 ] ;
46011: LD_ADDR_VAR 0 7
46015: PUSH
46016: LD_VAR 0 5
46020: PUSH
46021: LD_INT 1
46023: ARRAY
46024: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46025: LD_ADDR_VAR 0 9
46029: PUSH
46030: LD_VAR 0 5
46034: PUSH
46035: LD_INT 2
46037: ARRAY
46038: ST_TO_ADDR
// end ; if not weapon then
46039: LD_VAR 0 9
46043: NOT
46044: IFFALSE 46048
// continue ;
46046: GO 45676
// ComPlaceWeapon ( tw , weapon ) ;
46048: LD_VAR 0 7
46052: PPUSH
46053: LD_VAR 0 9
46057: PPUSH
46058: CALL_OW 148
// end ;
46062: GO 45676
46064: POP
46065: POP
// end ;
46066: LD_VAR 0 1
46070: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46071: LD_INT 0
46073: PPUSH
46074: PPUSH
46075: PPUSH
46076: PPUSH
46077: PPUSH
46078: PPUSH
// if not mc_bases then
46079: LD_EXP 99
46083: NOT
46084: IFFALSE 46088
// exit ;
46086: GO 47100
// for i = 1 to mc_bases do
46088: LD_ADDR_VAR 0 2
46092: PUSH
46093: DOUBLE
46094: LD_INT 1
46096: DEC
46097: ST_TO_ADDR
46098: LD_EXP 99
46102: PUSH
46103: FOR_TO
46104: IFFALSE 47098
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
46106: LD_EXP 112
46110: PUSH
46111: LD_VAR 0 2
46115: ARRAY
46116: NOT
46117: PUSH
46118: LD_EXP 112
46122: PUSH
46123: LD_VAR 0 2
46127: ARRAY
46128: PUSH
46129: LD_EXP 113
46133: PUSH
46134: LD_VAR 0 2
46138: ARRAY
46139: EQUAL
46140: OR
46141: IFFALSE 46145
// continue ;
46143: GO 46103
// if mc_miners [ i ] then
46145: LD_EXP 113
46149: PUSH
46150: LD_VAR 0 2
46154: ARRAY
46155: IFFALSE 46785
// begin k := 1 ;
46157: LD_ADDR_VAR 0 4
46161: PUSH
46162: LD_INT 1
46164: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
46165: LD_ADDR_VAR 0 3
46169: PUSH
46170: DOUBLE
46171: LD_EXP 113
46175: PUSH
46176: LD_VAR 0 2
46180: ARRAY
46181: INC
46182: ST_TO_ADDR
46183: LD_INT 1
46185: PUSH
46186: FOR_DOWNTO
46187: IFFALSE 46783
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46189: LD_EXP 113
46193: PUSH
46194: LD_VAR 0 2
46198: ARRAY
46199: PUSH
46200: LD_VAR 0 3
46204: ARRAY
46205: PPUSH
46206: CALL_OW 301
46210: PUSH
46211: LD_EXP 113
46215: PUSH
46216: LD_VAR 0 2
46220: ARRAY
46221: PUSH
46222: LD_VAR 0 3
46226: ARRAY
46227: PPUSH
46228: CALL_OW 257
46232: PUSH
46233: LD_INT 1
46235: NONEQUAL
46236: OR
46237: IFFALSE 46300
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46239: LD_ADDR_VAR 0 5
46243: PUSH
46244: LD_EXP 113
46248: PUSH
46249: LD_VAR 0 2
46253: ARRAY
46254: PUSH
46255: LD_EXP 113
46259: PUSH
46260: LD_VAR 0 2
46264: ARRAY
46265: PUSH
46266: LD_VAR 0 3
46270: ARRAY
46271: DIFF
46272: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46273: LD_ADDR_EXP 113
46277: PUSH
46278: LD_EXP 113
46282: PPUSH
46283: LD_VAR 0 2
46287: PPUSH
46288: LD_VAR 0 5
46292: PPUSH
46293: CALL_OW 1
46297: ST_TO_ADDR
// continue ;
46298: GO 46186
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
46300: LD_EXP 113
46304: PUSH
46305: LD_VAR 0 2
46309: ARRAY
46310: PUSH
46311: LD_VAR 0 3
46315: ARRAY
46316: PPUSH
46317: CALL 70725 0 1
46321: PUSH
46322: LD_EXP 113
46326: PUSH
46327: LD_VAR 0 2
46331: ARRAY
46332: PUSH
46333: LD_VAR 0 3
46337: ARRAY
46338: PPUSH
46339: CALL_OW 255
46343: PPUSH
46344: LD_EXP 112
46348: PUSH
46349: LD_VAR 0 2
46353: ARRAY
46354: PUSH
46355: LD_VAR 0 4
46359: ARRAY
46360: PUSH
46361: LD_INT 1
46363: ARRAY
46364: PPUSH
46365: LD_EXP 112
46369: PUSH
46370: LD_VAR 0 2
46374: ARRAY
46375: PUSH
46376: LD_VAR 0 4
46380: ARRAY
46381: PUSH
46382: LD_INT 2
46384: ARRAY
46385: PPUSH
46386: LD_INT 15
46388: PPUSH
46389: CALL 71685 0 4
46393: PUSH
46394: LD_INT 4
46396: ARRAY
46397: PUSH
46398: LD_EXP 113
46402: PUSH
46403: LD_VAR 0 2
46407: ARRAY
46408: PUSH
46409: LD_VAR 0 3
46413: ARRAY
46414: PPUSH
46415: LD_INT 10
46417: PPUSH
46418: CALL 73382 0 2
46422: PUSH
46423: LD_INT 4
46425: ARRAY
46426: OR
46427: AND
46428: IFFALSE 46451
// ComStop ( mc_miners [ i ] [ j ] ) ;
46430: LD_EXP 113
46434: PUSH
46435: LD_VAR 0 2
46439: ARRAY
46440: PUSH
46441: LD_VAR 0 3
46445: ARRAY
46446: PPUSH
46447: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
46451: LD_EXP 113
46455: PUSH
46456: LD_VAR 0 2
46460: ARRAY
46461: PUSH
46462: LD_VAR 0 3
46466: ARRAY
46467: PPUSH
46468: CALL_OW 257
46472: PUSH
46473: LD_INT 1
46475: EQUAL
46476: PUSH
46477: LD_EXP 113
46481: PUSH
46482: LD_VAR 0 2
46486: ARRAY
46487: PUSH
46488: LD_VAR 0 3
46492: ARRAY
46493: PPUSH
46494: CALL_OW 459
46498: NOT
46499: AND
46500: PUSH
46501: LD_EXP 113
46505: PUSH
46506: LD_VAR 0 2
46510: ARRAY
46511: PUSH
46512: LD_VAR 0 3
46516: ARRAY
46517: PPUSH
46518: CALL_OW 255
46522: PPUSH
46523: LD_EXP 112
46527: PUSH
46528: LD_VAR 0 2
46532: ARRAY
46533: PUSH
46534: LD_VAR 0 4
46538: ARRAY
46539: PUSH
46540: LD_INT 1
46542: ARRAY
46543: PPUSH
46544: LD_EXP 112
46548: PUSH
46549: LD_VAR 0 2
46553: ARRAY
46554: PUSH
46555: LD_VAR 0 4
46559: ARRAY
46560: PUSH
46561: LD_INT 2
46563: ARRAY
46564: PPUSH
46565: LD_INT 15
46567: PPUSH
46568: CALL 71685 0 4
46572: PUSH
46573: LD_INT 4
46575: ARRAY
46576: PUSH
46577: LD_INT 0
46579: EQUAL
46580: AND
46581: PUSH
46582: LD_EXP 113
46586: PUSH
46587: LD_VAR 0 2
46591: ARRAY
46592: PUSH
46593: LD_VAR 0 3
46597: ARRAY
46598: PPUSH
46599: CALL_OW 314
46603: NOT
46604: AND
46605: IFFALSE 46781
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46607: LD_EXP 113
46611: PUSH
46612: LD_VAR 0 2
46616: ARRAY
46617: PUSH
46618: LD_VAR 0 3
46622: ARRAY
46623: PPUSH
46624: CALL_OW 310
46628: IFFALSE 46651
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46630: LD_EXP 113
46634: PUSH
46635: LD_VAR 0 2
46639: ARRAY
46640: PUSH
46641: LD_VAR 0 3
46645: ARRAY
46646: PPUSH
46647: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46651: LD_EXP 113
46655: PUSH
46656: LD_VAR 0 2
46660: ARRAY
46661: PUSH
46662: LD_VAR 0 3
46666: ARRAY
46667: PPUSH
46668: CALL_OW 314
46672: NOT
46673: IFFALSE 46741
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46675: LD_EXP 113
46679: PUSH
46680: LD_VAR 0 2
46684: ARRAY
46685: PUSH
46686: LD_VAR 0 3
46690: ARRAY
46691: PPUSH
46692: LD_EXP 112
46696: PUSH
46697: LD_VAR 0 2
46701: ARRAY
46702: PUSH
46703: LD_VAR 0 4
46707: ARRAY
46708: PUSH
46709: LD_INT 1
46711: ARRAY
46712: PPUSH
46713: LD_EXP 112
46717: PUSH
46718: LD_VAR 0 2
46722: ARRAY
46723: PUSH
46724: LD_VAR 0 4
46728: ARRAY
46729: PUSH
46730: LD_INT 2
46732: ARRAY
46733: PPUSH
46734: LD_INT 0
46736: PPUSH
46737: CALL_OW 193
// k := k + 1 ;
46741: LD_ADDR_VAR 0 4
46745: PUSH
46746: LD_VAR 0 4
46750: PUSH
46751: LD_INT 1
46753: PLUS
46754: ST_TO_ADDR
// if k > mc_mines [ i ] then
46755: LD_VAR 0 4
46759: PUSH
46760: LD_EXP 112
46764: PUSH
46765: LD_VAR 0 2
46769: ARRAY
46770: GREATER
46771: IFFALSE 46781
// k := 1 ;
46773: LD_ADDR_VAR 0 4
46777: PUSH
46778: LD_INT 1
46780: ST_TO_ADDR
// end ; end ;
46781: GO 46186
46783: POP
46784: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46785: LD_ADDR_VAR 0 5
46789: PUSH
46790: LD_EXP 99
46794: PUSH
46795: LD_VAR 0 2
46799: ARRAY
46800: PPUSH
46801: LD_INT 2
46803: PUSH
46804: LD_INT 30
46806: PUSH
46807: LD_INT 4
46809: PUSH
46810: EMPTY
46811: LIST
46812: LIST
46813: PUSH
46814: LD_INT 30
46816: PUSH
46817: LD_INT 5
46819: PUSH
46820: EMPTY
46821: LIST
46822: LIST
46823: PUSH
46824: LD_INT 30
46826: PUSH
46827: LD_INT 32
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: PUSH
46834: EMPTY
46835: LIST
46836: LIST
46837: LIST
46838: LIST
46839: PPUSH
46840: CALL_OW 72
46844: ST_TO_ADDR
// if not tmp then
46845: LD_VAR 0 5
46849: NOT
46850: IFFALSE 46854
// continue ;
46852: GO 46103
// list := [ ] ;
46854: LD_ADDR_VAR 0 6
46858: PUSH
46859: EMPTY
46860: ST_TO_ADDR
// for j in tmp do
46861: LD_ADDR_VAR 0 3
46865: PUSH
46866: LD_VAR 0 5
46870: PUSH
46871: FOR_IN
46872: IFFALSE 46941
// begin for k in UnitsInside ( j ) do
46874: LD_ADDR_VAR 0 4
46878: PUSH
46879: LD_VAR 0 3
46883: PPUSH
46884: CALL_OW 313
46888: PUSH
46889: FOR_IN
46890: IFFALSE 46937
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46892: LD_VAR 0 4
46896: PPUSH
46897: CALL_OW 257
46901: PUSH
46902: LD_INT 1
46904: EQUAL
46905: PUSH
46906: LD_VAR 0 4
46910: PPUSH
46911: CALL_OW 459
46915: NOT
46916: AND
46917: IFFALSE 46935
// list := list ^ k ;
46919: LD_ADDR_VAR 0 6
46923: PUSH
46924: LD_VAR 0 6
46928: PUSH
46929: LD_VAR 0 4
46933: ADD
46934: ST_TO_ADDR
46935: GO 46889
46937: POP
46938: POP
// end ;
46939: GO 46871
46941: POP
46942: POP
// list := list diff mc_miners [ i ] ;
46943: LD_ADDR_VAR 0 6
46947: PUSH
46948: LD_VAR 0 6
46952: PUSH
46953: LD_EXP 113
46957: PUSH
46958: LD_VAR 0 2
46962: ARRAY
46963: DIFF
46964: ST_TO_ADDR
// if not list then
46965: LD_VAR 0 6
46969: NOT
46970: IFFALSE 46974
// continue ;
46972: GO 46103
// k := mc_mines [ i ] - mc_miners [ i ] ;
46974: LD_ADDR_VAR 0 4
46978: PUSH
46979: LD_EXP 112
46983: PUSH
46984: LD_VAR 0 2
46988: ARRAY
46989: PUSH
46990: LD_EXP 113
46994: PUSH
46995: LD_VAR 0 2
46999: ARRAY
47000: MINUS
47001: ST_TO_ADDR
// if k > list then
47002: LD_VAR 0 4
47006: PUSH
47007: LD_VAR 0 6
47011: GREATER
47012: IFFALSE 47024
// k := list ;
47014: LD_ADDR_VAR 0 4
47018: PUSH
47019: LD_VAR 0 6
47023: ST_TO_ADDR
// for j = 1 to k do
47024: LD_ADDR_VAR 0 3
47028: PUSH
47029: DOUBLE
47030: LD_INT 1
47032: DEC
47033: ST_TO_ADDR
47034: LD_VAR 0 4
47038: PUSH
47039: FOR_TO
47040: IFFALSE 47094
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47042: LD_ADDR_EXP 113
47046: PUSH
47047: LD_EXP 113
47051: PPUSH
47052: LD_VAR 0 2
47056: PUSH
47057: LD_EXP 113
47061: PUSH
47062: LD_VAR 0 2
47066: ARRAY
47067: PUSH
47068: LD_INT 1
47070: PLUS
47071: PUSH
47072: EMPTY
47073: LIST
47074: LIST
47075: PPUSH
47076: LD_VAR 0 6
47080: PUSH
47081: LD_VAR 0 3
47085: ARRAY
47086: PPUSH
47087: CALL 70789 0 3
47091: ST_TO_ADDR
47092: GO 47039
47094: POP
47095: POP
// end ;
47096: GO 46103
47098: POP
47099: POP
// end ;
47100: LD_VAR 0 1
47104: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47105: LD_INT 0
47107: PPUSH
47108: PPUSH
47109: PPUSH
47110: PPUSH
47111: PPUSH
47112: PPUSH
47113: PPUSH
47114: PPUSH
47115: PPUSH
47116: PPUSH
// if not mc_bases then
47117: LD_EXP 99
47121: NOT
47122: IFFALSE 47126
// exit ;
47124: GO 48876
// for i = 1 to mc_bases do
47126: LD_ADDR_VAR 0 2
47130: PUSH
47131: DOUBLE
47132: LD_INT 1
47134: DEC
47135: ST_TO_ADDR
47136: LD_EXP 99
47140: PUSH
47141: FOR_TO
47142: IFFALSE 48874
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47144: LD_EXP 99
47148: PUSH
47149: LD_VAR 0 2
47153: ARRAY
47154: NOT
47155: PUSH
47156: LD_EXP 106
47160: PUSH
47161: LD_VAR 0 2
47165: ARRAY
47166: OR
47167: IFFALSE 47171
// continue ;
47169: GO 47141
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47171: LD_EXP 115
47175: PUSH
47176: LD_VAR 0 2
47180: ARRAY
47181: NOT
47182: PUSH
47183: LD_EXP 116
47187: PUSH
47188: LD_VAR 0 2
47192: ARRAY
47193: AND
47194: IFFALSE 47232
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47196: LD_ADDR_EXP 116
47200: PUSH
47201: LD_EXP 116
47205: PPUSH
47206: LD_VAR 0 2
47210: PPUSH
47211: EMPTY
47212: PPUSH
47213: CALL_OW 1
47217: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47218: LD_VAR 0 2
47222: PPUSH
47223: LD_INT 107
47225: PPUSH
47226: CALL 37986 0 2
// continue ;
47230: GO 47141
// end ; target := [ ] ;
47232: LD_ADDR_VAR 0 6
47236: PUSH
47237: EMPTY
47238: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47239: LD_ADDR_VAR 0 3
47243: PUSH
47244: DOUBLE
47245: LD_EXP 115
47249: PUSH
47250: LD_VAR 0 2
47254: ARRAY
47255: INC
47256: ST_TO_ADDR
47257: LD_INT 1
47259: PUSH
47260: FOR_DOWNTO
47261: IFFALSE 47521
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47263: LD_EXP 115
47267: PUSH
47268: LD_VAR 0 2
47272: ARRAY
47273: PUSH
47274: LD_VAR 0 3
47278: ARRAY
47279: PUSH
47280: LD_INT 2
47282: ARRAY
47283: PPUSH
47284: LD_EXP 115
47288: PUSH
47289: LD_VAR 0 2
47293: ARRAY
47294: PUSH
47295: LD_VAR 0 3
47299: ARRAY
47300: PUSH
47301: LD_INT 3
47303: ARRAY
47304: PPUSH
47305: CALL_OW 488
47309: PUSH
47310: LD_EXP 115
47314: PUSH
47315: LD_VAR 0 2
47319: ARRAY
47320: PUSH
47321: LD_VAR 0 3
47325: ARRAY
47326: PUSH
47327: LD_INT 2
47329: ARRAY
47330: PPUSH
47331: LD_EXP 115
47335: PUSH
47336: LD_VAR 0 2
47340: ARRAY
47341: PUSH
47342: LD_VAR 0 3
47346: ARRAY
47347: PUSH
47348: LD_INT 3
47350: ARRAY
47351: PPUSH
47352: CALL_OW 284
47356: PUSH
47357: LD_INT 0
47359: EQUAL
47360: AND
47361: IFFALSE 47416
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47363: LD_ADDR_VAR 0 5
47367: PUSH
47368: LD_EXP 115
47372: PUSH
47373: LD_VAR 0 2
47377: ARRAY
47378: PPUSH
47379: LD_VAR 0 3
47383: PPUSH
47384: CALL_OW 3
47388: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47389: LD_ADDR_EXP 115
47393: PUSH
47394: LD_EXP 115
47398: PPUSH
47399: LD_VAR 0 2
47403: PPUSH
47404: LD_VAR 0 5
47408: PPUSH
47409: CALL_OW 1
47413: ST_TO_ADDR
// continue ;
47414: GO 47260
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47416: LD_EXP 99
47420: PUSH
47421: LD_VAR 0 2
47425: ARRAY
47426: PUSH
47427: LD_INT 1
47429: ARRAY
47430: PPUSH
47431: CALL_OW 255
47435: PPUSH
47436: LD_EXP 115
47440: PUSH
47441: LD_VAR 0 2
47445: ARRAY
47446: PUSH
47447: LD_VAR 0 3
47451: ARRAY
47452: PUSH
47453: LD_INT 2
47455: ARRAY
47456: PPUSH
47457: LD_EXP 115
47461: PUSH
47462: LD_VAR 0 2
47466: ARRAY
47467: PUSH
47468: LD_VAR 0 3
47472: ARRAY
47473: PUSH
47474: LD_INT 3
47476: ARRAY
47477: PPUSH
47478: LD_INT 30
47480: PPUSH
47481: CALL 71685 0 4
47485: PUSH
47486: LD_INT 4
47488: ARRAY
47489: PUSH
47490: LD_INT 0
47492: EQUAL
47493: IFFALSE 47519
// begin target := mc_crates [ i ] [ j ] ;
47495: LD_ADDR_VAR 0 6
47499: PUSH
47500: LD_EXP 115
47504: PUSH
47505: LD_VAR 0 2
47509: ARRAY
47510: PUSH
47511: LD_VAR 0 3
47515: ARRAY
47516: ST_TO_ADDR
// break ;
47517: GO 47521
// end ; end ;
47519: GO 47260
47521: POP
47522: POP
// if not target then
47523: LD_VAR 0 6
47527: NOT
47528: IFFALSE 47532
// continue ;
47530: GO 47141
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47532: LD_ADDR_VAR 0 7
47536: PUSH
47537: LD_EXP 118
47541: PUSH
47542: LD_VAR 0 2
47546: ARRAY
47547: PPUSH
47548: LD_INT 2
47550: PUSH
47551: LD_INT 3
47553: PUSH
47554: LD_INT 58
47556: PUSH
47557: EMPTY
47558: LIST
47559: PUSH
47560: EMPTY
47561: LIST
47562: LIST
47563: PUSH
47564: LD_INT 61
47566: PUSH
47567: EMPTY
47568: LIST
47569: PUSH
47570: LD_INT 33
47572: PUSH
47573: LD_INT 5
47575: PUSH
47576: EMPTY
47577: LIST
47578: LIST
47579: PUSH
47580: LD_INT 33
47582: PUSH
47583: LD_INT 3
47585: PUSH
47586: EMPTY
47587: LIST
47588: LIST
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: LIST
47594: LIST
47595: LIST
47596: PUSH
47597: LD_INT 2
47599: PUSH
47600: LD_INT 34
47602: PUSH
47603: LD_INT 32
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: PUSH
47610: LD_INT 34
47612: PUSH
47613: LD_INT 51
47615: PUSH
47616: EMPTY
47617: LIST
47618: LIST
47619: PUSH
47620: LD_INT 34
47622: PUSH
47623: LD_INT 12
47625: PUSH
47626: EMPTY
47627: LIST
47628: LIST
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: LIST
47634: LIST
47635: PUSH
47636: EMPTY
47637: LIST
47638: LIST
47639: PPUSH
47640: CALL_OW 72
47644: ST_TO_ADDR
// if not cargo then
47645: LD_VAR 0 7
47649: NOT
47650: IFFALSE 48293
// begin if mc_crates_collector [ i ] < 5 then
47652: LD_EXP 116
47656: PUSH
47657: LD_VAR 0 2
47661: ARRAY
47662: PUSH
47663: LD_INT 5
47665: LESS
47666: IFFALSE 48032
// begin if mc_ape [ i ] then
47668: LD_EXP 128
47672: PUSH
47673: LD_VAR 0 2
47677: ARRAY
47678: IFFALSE 47725
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47680: LD_ADDR_VAR 0 5
47684: PUSH
47685: LD_EXP 128
47689: PUSH
47690: LD_VAR 0 2
47694: ARRAY
47695: PPUSH
47696: LD_INT 25
47698: PUSH
47699: LD_INT 16
47701: PUSH
47702: EMPTY
47703: LIST
47704: LIST
47705: PUSH
47706: LD_INT 24
47708: PUSH
47709: LD_INT 750
47711: PUSH
47712: EMPTY
47713: LIST
47714: LIST
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PPUSH
47720: CALL_OW 72
47724: ST_TO_ADDR
// if not tmp then
47725: LD_VAR 0 5
47729: NOT
47730: IFFALSE 47777
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47732: LD_ADDR_VAR 0 5
47736: PUSH
47737: LD_EXP 99
47741: PUSH
47742: LD_VAR 0 2
47746: ARRAY
47747: PPUSH
47748: LD_INT 25
47750: PUSH
47751: LD_INT 2
47753: PUSH
47754: EMPTY
47755: LIST
47756: LIST
47757: PUSH
47758: LD_INT 24
47760: PUSH
47761: LD_INT 750
47763: PUSH
47764: EMPTY
47765: LIST
47766: LIST
47767: PUSH
47768: EMPTY
47769: LIST
47770: LIST
47771: PPUSH
47772: CALL_OW 72
47776: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47777: LD_EXP 128
47781: PUSH
47782: LD_VAR 0 2
47786: ARRAY
47787: PUSH
47788: LD_EXP 99
47792: PUSH
47793: LD_VAR 0 2
47797: ARRAY
47798: PPUSH
47799: LD_INT 25
47801: PUSH
47802: LD_INT 2
47804: PUSH
47805: EMPTY
47806: LIST
47807: LIST
47808: PUSH
47809: LD_INT 24
47811: PUSH
47812: LD_INT 750
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PPUSH
47823: CALL_OW 72
47827: AND
47828: PUSH
47829: LD_VAR 0 5
47833: PUSH
47834: LD_INT 5
47836: LESS
47837: AND
47838: IFFALSE 47920
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47840: LD_ADDR_VAR 0 3
47844: PUSH
47845: LD_EXP 99
47849: PUSH
47850: LD_VAR 0 2
47854: ARRAY
47855: PPUSH
47856: LD_INT 25
47858: PUSH
47859: LD_INT 2
47861: PUSH
47862: EMPTY
47863: LIST
47864: LIST
47865: PUSH
47866: LD_INT 24
47868: PUSH
47869: LD_INT 750
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: PUSH
47876: EMPTY
47877: LIST
47878: LIST
47879: PPUSH
47880: CALL_OW 72
47884: PUSH
47885: FOR_IN
47886: IFFALSE 47918
// begin tmp := tmp union j ;
47888: LD_ADDR_VAR 0 5
47892: PUSH
47893: LD_VAR 0 5
47897: PUSH
47898: LD_VAR 0 3
47902: UNION
47903: ST_TO_ADDR
// if tmp >= 5 then
47904: LD_VAR 0 5
47908: PUSH
47909: LD_INT 5
47911: GREATEREQUAL
47912: IFFALSE 47916
// break ;
47914: GO 47918
// end ;
47916: GO 47885
47918: POP
47919: POP
// end ; if not tmp then
47920: LD_VAR 0 5
47924: NOT
47925: IFFALSE 47929
// continue ;
47927: GO 47141
// for j in tmp do
47929: LD_ADDR_VAR 0 3
47933: PUSH
47934: LD_VAR 0 5
47938: PUSH
47939: FOR_IN
47940: IFFALSE 48030
// if not GetTag ( j ) then
47942: LD_VAR 0 3
47946: PPUSH
47947: CALL_OW 110
47951: NOT
47952: IFFALSE 48028
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47954: LD_ADDR_EXP 116
47958: PUSH
47959: LD_EXP 116
47963: PPUSH
47964: LD_VAR 0 2
47968: PUSH
47969: LD_EXP 116
47973: PUSH
47974: LD_VAR 0 2
47978: ARRAY
47979: PUSH
47980: LD_INT 1
47982: PLUS
47983: PUSH
47984: EMPTY
47985: LIST
47986: LIST
47987: PPUSH
47988: LD_VAR 0 3
47992: PPUSH
47993: CALL 70789 0 3
47997: ST_TO_ADDR
// SetTag ( j , 107 ) ;
47998: LD_VAR 0 3
48002: PPUSH
48003: LD_INT 107
48005: PPUSH
48006: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48010: LD_EXP 116
48014: PUSH
48015: LD_VAR 0 2
48019: ARRAY
48020: PUSH
48021: LD_INT 5
48023: GREATEREQUAL
48024: IFFALSE 48028
// break ;
48026: GO 48030
// end ;
48028: GO 47939
48030: POP
48031: POP
// end ; if mc_crates_collector [ i ] and target then
48032: LD_EXP 116
48036: PUSH
48037: LD_VAR 0 2
48041: ARRAY
48042: PUSH
48043: LD_VAR 0 6
48047: AND
48048: IFFALSE 48291
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48050: LD_EXP 116
48054: PUSH
48055: LD_VAR 0 2
48059: ARRAY
48060: PUSH
48061: LD_VAR 0 6
48065: PUSH
48066: LD_INT 1
48068: ARRAY
48069: LESS
48070: IFFALSE 48090
// tmp := mc_crates_collector [ i ] else
48072: LD_ADDR_VAR 0 5
48076: PUSH
48077: LD_EXP 116
48081: PUSH
48082: LD_VAR 0 2
48086: ARRAY
48087: ST_TO_ADDR
48088: GO 48104
// tmp := target [ 1 ] ;
48090: LD_ADDR_VAR 0 5
48094: PUSH
48095: LD_VAR 0 6
48099: PUSH
48100: LD_INT 1
48102: ARRAY
48103: ST_TO_ADDR
// k := 0 ;
48104: LD_ADDR_VAR 0 4
48108: PUSH
48109: LD_INT 0
48111: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48112: LD_ADDR_VAR 0 3
48116: PUSH
48117: LD_EXP 116
48121: PUSH
48122: LD_VAR 0 2
48126: ARRAY
48127: PUSH
48128: FOR_IN
48129: IFFALSE 48289
// begin k := k + 1 ;
48131: LD_ADDR_VAR 0 4
48135: PUSH
48136: LD_VAR 0 4
48140: PUSH
48141: LD_INT 1
48143: PLUS
48144: ST_TO_ADDR
// if k > tmp then
48145: LD_VAR 0 4
48149: PUSH
48150: LD_VAR 0 5
48154: GREATER
48155: IFFALSE 48159
// break ;
48157: GO 48289
// if not GetClass ( j ) in [ 2 , 16 ] then
48159: LD_VAR 0 3
48163: PPUSH
48164: CALL_OW 257
48168: PUSH
48169: LD_INT 2
48171: PUSH
48172: LD_INT 16
48174: PUSH
48175: EMPTY
48176: LIST
48177: LIST
48178: IN
48179: NOT
48180: IFFALSE 48233
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48182: LD_ADDR_EXP 116
48186: PUSH
48187: LD_EXP 116
48191: PPUSH
48192: LD_VAR 0 2
48196: PPUSH
48197: LD_EXP 116
48201: PUSH
48202: LD_VAR 0 2
48206: ARRAY
48207: PUSH
48208: LD_VAR 0 3
48212: DIFF
48213: PPUSH
48214: CALL_OW 1
48218: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48219: LD_VAR 0 3
48223: PPUSH
48224: LD_INT 0
48226: PPUSH
48227: CALL_OW 109
// continue ;
48231: GO 48128
// end ; if IsInUnit ( j ) then
48233: LD_VAR 0 3
48237: PPUSH
48238: CALL_OW 310
48242: IFFALSE 48253
// ComExitBuilding ( j ) ;
48244: LD_VAR 0 3
48248: PPUSH
48249: CALL_OW 122
// wait ( 3 ) ;
48253: LD_INT 3
48255: PPUSH
48256: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48260: LD_VAR 0 3
48264: PPUSH
48265: LD_VAR 0 6
48269: PUSH
48270: LD_INT 2
48272: ARRAY
48273: PPUSH
48274: LD_VAR 0 6
48278: PUSH
48279: LD_INT 3
48281: ARRAY
48282: PPUSH
48283: CALL_OW 117
// end ;
48287: GO 48128
48289: POP
48290: POP
// end ; end else
48291: GO 48872
// begin for j in cargo do
48293: LD_ADDR_VAR 0 3
48297: PUSH
48298: LD_VAR 0 7
48302: PUSH
48303: FOR_IN
48304: IFFALSE 48870
// begin if GetTag ( j ) <> 0 then
48306: LD_VAR 0 3
48310: PPUSH
48311: CALL_OW 110
48315: PUSH
48316: LD_INT 0
48318: NONEQUAL
48319: IFFALSE 48323
// continue ;
48321: GO 48303
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48323: LD_VAR 0 3
48327: PPUSH
48328: CALL_OW 256
48332: PUSH
48333: LD_INT 1000
48335: LESS
48336: PUSH
48337: LD_VAR 0 3
48341: PPUSH
48342: LD_EXP 123
48346: PUSH
48347: LD_VAR 0 2
48351: ARRAY
48352: PPUSH
48353: CALL_OW 308
48357: NOT
48358: AND
48359: IFFALSE 48381
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48361: LD_VAR 0 3
48365: PPUSH
48366: LD_EXP 123
48370: PUSH
48371: LD_VAR 0 2
48375: ARRAY
48376: PPUSH
48377: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48381: LD_VAR 0 3
48385: PPUSH
48386: CALL_OW 256
48390: PUSH
48391: LD_INT 1000
48393: LESS
48394: PUSH
48395: LD_VAR 0 3
48399: PPUSH
48400: LD_EXP 123
48404: PUSH
48405: LD_VAR 0 2
48409: ARRAY
48410: PPUSH
48411: CALL_OW 308
48415: AND
48416: IFFALSE 48420
// continue ;
48418: GO 48303
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48420: LD_VAR 0 3
48424: PPUSH
48425: CALL_OW 262
48429: PUSH
48430: LD_INT 2
48432: EQUAL
48433: PUSH
48434: LD_VAR 0 3
48438: PPUSH
48439: CALL_OW 261
48443: PUSH
48444: LD_INT 15
48446: LESS
48447: AND
48448: IFFALSE 48452
// continue ;
48450: GO 48303
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48452: LD_VAR 0 3
48456: PPUSH
48457: CALL_OW 262
48461: PUSH
48462: LD_INT 1
48464: EQUAL
48465: PUSH
48466: LD_VAR 0 3
48470: PPUSH
48471: CALL_OW 261
48475: PUSH
48476: LD_INT 10
48478: LESS
48479: AND
48480: IFFALSE 48809
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48482: LD_ADDR_VAR 0 8
48486: PUSH
48487: LD_EXP 99
48491: PUSH
48492: LD_VAR 0 2
48496: ARRAY
48497: PPUSH
48498: LD_INT 2
48500: PUSH
48501: LD_INT 30
48503: PUSH
48504: LD_INT 0
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: PUSH
48511: LD_INT 30
48513: PUSH
48514: LD_INT 1
48516: PUSH
48517: EMPTY
48518: LIST
48519: LIST
48520: PUSH
48521: EMPTY
48522: LIST
48523: LIST
48524: LIST
48525: PPUSH
48526: CALL_OW 72
48530: ST_TO_ADDR
// if not depot then
48531: LD_VAR 0 8
48535: NOT
48536: IFFALSE 48540
// continue ;
48538: GO 48303
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48540: LD_VAR 0 3
48544: PPUSH
48545: LD_VAR 0 8
48549: PPUSH
48550: LD_VAR 0 3
48554: PPUSH
48555: CALL_OW 74
48559: PPUSH
48560: CALL_OW 296
48564: PUSH
48565: LD_INT 6
48567: LESS
48568: IFFALSE 48584
// SetFuel ( j , 100 ) else
48570: LD_VAR 0 3
48574: PPUSH
48575: LD_INT 100
48577: PPUSH
48578: CALL_OW 240
48582: GO 48809
// if GetFuel ( j ) = 0 then
48584: LD_VAR 0 3
48588: PPUSH
48589: CALL_OW 261
48593: PUSH
48594: LD_INT 0
48596: EQUAL
48597: IFFALSE 48809
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48599: LD_ADDR_EXP 118
48603: PUSH
48604: LD_EXP 118
48608: PPUSH
48609: LD_VAR 0 2
48613: PPUSH
48614: LD_EXP 118
48618: PUSH
48619: LD_VAR 0 2
48623: ARRAY
48624: PUSH
48625: LD_VAR 0 3
48629: DIFF
48630: PPUSH
48631: CALL_OW 1
48635: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48636: LD_VAR 0 3
48640: PPUSH
48641: CALL_OW 263
48645: PUSH
48646: LD_INT 1
48648: EQUAL
48649: IFFALSE 48665
// ComExitVehicle ( IsInUnit ( j ) ) ;
48651: LD_VAR 0 3
48655: PPUSH
48656: CALL_OW 310
48660: PPUSH
48661: CALL_OW 121
// if GetControl ( j ) = control_remote then
48665: LD_VAR 0 3
48669: PPUSH
48670: CALL_OW 263
48674: PUSH
48675: LD_INT 2
48677: EQUAL
48678: IFFALSE 48689
// ComUnlink ( j ) ;
48680: LD_VAR 0 3
48684: PPUSH
48685: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
48689: LD_ADDR_VAR 0 9
48693: PUSH
48694: LD_VAR 0 2
48698: PPUSH
48699: LD_INT 3
48701: PPUSH
48702: CALL 57946 0 2
48706: ST_TO_ADDR
// if fac then
48707: LD_VAR 0 9
48711: IFFALSE 48807
// begin for k in fac do
48713: LD_ADDR_VAR 0 4
48717: PUSH
48718: LD_VAR 0 9
48722: PUSH
48723: FOR_IN
48724: IFFALSE 48805
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48726: LD_ADDR_VAR 0 10
48730: PUSH
48731: LD_VAR 0 9
48735: PPUSH
48736: LD_VAR 0 3
48740: PPUSH
48741: CALL_OW 265
48745: PPUSH
48746: LD_VAR 0 3
48750: PPUSH
48751: CALL_OW 262
48755: PPUSH
48756: LD_VAR 0 3
48760: PPUSH
48761: CALL_OW 263
48765: PPUSH
48766: LD_VAR 0 3
48770: PPUSH
48771: CALL_OW 264
48775: PPUSH
48776: CALL 68321 0 5
48780: ST_TO_ADDR
// if components then
48781: LD_VAR 0 10
48785: IFFALSE 48803
// begin MC_InsertProduceList ( i , components ) ;
48787: LD_VAR 0 2
48791: PPUSH
48792: LD_VAR 0 10
48796: PPUSH
48797: CALL 57491 0 2
// break ;
48801: GO 48805
// end ; end ;
48803: GO 48723
48805: POP
48806: POP
// end ; continue ;
48807: GO 48303
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48809: LD_VAR 0 3
48813: PPUSH
48814: LD_INT 1
48816: PPUSH
48817: CALL_OW 289
48821: PUSH
48822: LD_INT 100
48824: LESS
48825: PUSH
48826: LD_VAR 0 3
48830: PPUSH
48831: CALL_OW 314
48835: NOT
48836: AND
48837: IFFALSE 48866
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48839: LD_VAR 0 3
48843: PPUSH
48844: LD_VAR 0 6
48848: PUSH
48849: LD_INT 2
48851: ARRAY
48852: PPUSH
48853: LD_VAR 0 6
48857: PUSH
48858: LD_INT 3
48860: ARRAY
48861: PPUSH
48862: CALL_OW 117
// break ;
48866: GO 48870
// end ;
48868: GO 48303
48870: POP
48871: POP
// end ; end ;
48872: GO 47141
48874: POP
48875: POP
// end ;
48876: LD_VAR 0 1
48880: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48881: LD_INT 0
48883: PPUSH
48884: PPUSH
48885: PPUSH
48886: PPUSH
// if not mc_bases then
48887: LD_EXP 99
48891: NOT
48892: IFFALSE 48896
// exit ;
48894: GO 49057
// for i = 1 to mc_bases do
48896: LD_ADDR_VAR 0 2
48900: PUSH
48901: DOUBLE
48902: LD_INT 1
48904: DEC
48905: ST_TO_ADDR
48906: LD_EXP 99
48910: PUSH
48911: FOR_TO
48912: IFFALSE 49055
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48914: LD_ADDR_VAR 0 4
48918: PUSH
48919: LD_EXP 118
48923: PUSH
48924: LD_VAR 0 2
48928: ARRAY
48929: PUSH
48930: LD_EXP 121
48934: PUSH
48935: LD_VAR 0 2
48939: ARRAY
48940: UNION
48941: PPUSH
48942: LD_INT 33
48944: PUSH
48945: LD_INT 2
48947: PUSH
48948: EMPTY
48949: LIST
48950: LIST
48951: PPUSH
48952: CALL_OW 72
48956: ST_TO_ADDR
// if tmp then
48957: LD_VAR 0 4
48961: IFFALSE 49053
// for j in tmp do
48963: LD_ADDR_VAR 0 3
48967: PUSH
48968: LD_VAR 0 4
48972: PUSH
48973: FOR_IN
48974: IFFALSE 49051
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48976: LD_VAR 0 3
48980: PPUSH
48981: CALL_OW 312
48985: NOT
48986: PUSH
48987: LD_VAR 0 3
48991: PPUSH
48992: CALL_OW 256
48996: PUSH
48997: LD_INT 250
48999: GREATEREQUAL
49000: AND
49001: IFFALSE 49014
// Connect ( j ) else
49003: LD_VAR 0 3
49007: PPUSH
49008: CALL 73722 0 1
49012: GO 49049
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49014: LD_VAR 0 3
49018: PPUSH
49019: CALL_OW 256
49023: PUSH
49024: LD_INT 250
49026: LESS
49027: PUSH
49028: LD_VAR 0 3
49032: PPUSH
49033: CALL_OW 312
49037: AND
49038: IFFALSE 49049
// ComUnlink ( j ) ;
49040: LD_VAR 0 3
49044: PPUSH
49045: CALL_OW 136
49049: GO 48973
49051: POP
49052: POP
// end ;
49053: GO 48911
49055: POP
49056: POP
// end ;
49057: LD_VAR 0 1
49061: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49062: LD_INT 0
49064: PPUSH
49065: PPUSH
49066: PPUSH
49067: PPUSH
49068: PPUSH
// if not mc_bases then
49069: LD_EXP 99
49073: NOT
49074: IFFALSE 49078
// exit ;
49076: GO 49523
// for i = 1 to mc_bases do
49078: LD_ADDR_VAR 0 2
49082: PUSH
49083: DOUBLE
49084: LD_INT 1
49086: DEC
49087: ST_TO_ADDR
49088: LD_EXP 99
49092: PUSH
49093: FOR_TO
49094: IFFALSE 49521
// begin if not mc_produce [ i ] then
49096: LD_EXP 120
49100: PUSH
49101: LD_VAR 0 2
49105: ARRAY
49106: NOT
49107: IFFALSE 49111
// continue ;
49109: GO 49093
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49111: LD_ADDR_VAR 0 5
49115: PUSH
49116: LD_EXP 99
49120: PUSH
49121: LD_VAR 0 2
49125: ARRAY
49126: PPUSH
49127: LD_INT 30
49129: PUSH
49130: LD_INT 3
49132: PUSH
49133: EMPTY
49134: LIST
49135: LIST
49136: PPUSH
49137: CALL_OW 72
49141: ST_TO_ADDR
// if not fac then
49142: LD_VAR 0 5
49146: NOT
49147: IFFALSE 49151
// continue ;
49149: GO 49093
// for j in fac do
49151: LD_ADDR_VAR 0 3
49155: PUSH
49156: LD_VAR 0 5
49160: PUSH
49161: FOR_IN
49162: IFFALSE 49517
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49164: LD_VAR 0 3
49168: PPUSH
49169: CALL_OW 461
49173: PUSH
49174: LD_INT 2
49176: NONEQUAL
49177: PUSH
49178: LD_VAR 0 3
49182: PPUSH
49183: LD_INT 15
49185: PPUSH
49186: CALL 73382 0 2
49190: PUSH
49191: LD_INT 4
49193: ARRAY
49194: OR
49195: IFFALSE 49199
// continue ;
49197: GO 49161
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49199: LD_VAR 0 3
49203: PPUSH
49204: LD_EXP 120
49208: PUSH
49209: LD_VAR 0 2
49213: ARRAY
49214: PUSH
49215: LD_INT 1
49217: ARRAY
49218: PUSH
49219: LD_INT 1
49221: ARRAY
49222: PPUSH
49223: LD_EXP 120
49227: PUSH
49228: LD_VAR 0 2
49232: ARRAY
49233: PUSH
49234: LD_INT 1
49236: ARRAY
49237: PUSH
49238: LD_INT 2
49240: ARRAY
49241: PPUSH
49242: LD_EXP 120
49246: PUSH
49247: LD_VAR 0 2
49251: ARRAY
49252: PUSH
49253: LD_INT 1
49255: ARRAY
49256: PUSH
49257: LD_INT 3
49259: ARRAY
49260: PPUSH
49261: LD_EXP 120
49265: PUSH
49266: LD_VAR 0 2
49270: ARRAY
49271: PUSH
49272: LD_INT 1
49274: ARRAY
49275: PUSH
49276: LD_INT 4
49278: ARRAY
49279: PPUSH
49280: CALL_OW 448
49284: PUSH
49285: LD_VAR 0 3
49289: PPUSH
49290: LD_EXP 120
49294: PUSH
49295: LD_VAR 0 2
49299: ARRAY
49300: PUSH
49301: LD_INT 1
49303: ARRAY
49304: PUSH
49305: LD_INT 1
49307: ARRAY
49308: PUSH
49309: LD_EXP 120
49313: PUSH
49314: LD_VAR 0 2
49318: ARRAY
49319: PUSH
49320: LD_INT 1
49322: ARRAY
49323: PUSH
49324: LD_INT 2
49326: ARRAY
49327: PUSH
49328: LD_EXP 120
49332: PUSH
49333: LD_VAR 0 2
49337: ARRAY
49338: PUSH
49339: LD_INT 1
49341: ARRAY
49342: PUSH
49343: LD_INT 3
49345: ARRAY
49346: PUSH
49347: LD_EXP 120
49351: PUSH
49352: LD_VAR 0 2
49356: ARRAY
49357: PUSH
49358: LD_INT 1
49360: ARRAY
49361: PUSH
49362: LD_INT 4
49364: ARRAY
49365: PUSH
49366: EMPTY
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: PPUSH
49372: CALL 77053 0 2
49376: AND
49377: IFFALSE 49515
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49379: LD_VAR 0 3
49383: PPUSH
49384: LD_EXP 120
49388: PUSH
49389: LD_VAR 0 2
49393: ARRAY
49394: PUSH
49395: LD_INT 1
49397: ARRAY
49398: PUSH
49399: LD_INT 1
49401: ARRAY
49402: PPUSH
49403: LD_EXP 120
49407: PUSH
49408: LD_VAR 0 2
49412: ARRAY
49413: PUSH
49414: LD_INT 1
49416: ARRAY
49417: PUSH
49418: LD_INT 2
49420: ARRAY
49421: PPUSH
49422: LD_EXP 120
49426: PUSH
49427: LD_VAR 0 2
49431: ARRAY
49432: PUSH
49433: LD_INT 1
49435: ARRAY
49436: PUSH
49437: LD_INT 3
49439: ARRAY
49440: PPUSH
49441: LD_EXP 120
49445: PUSH
49446: LD_VAR 0 2
49450: ARRAY
49451: PUSH
49452: LD_INT 1
49454: ARRAY
49455: PUSH
49456: LD_INT 4
49458: ARRAY
49459: PPUSH
49460: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49464: LD_ADDR_VAR 0 4
49468: PUSH
49469: LD_EXP 120
49473: PUSH
49474: LD_VAR 0 2
49478: ARRAY
49479: PPUSH
49480: LD_INT 1
49482: PPUSH
49483: CALL_OW 3
49487: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49488: LD_ADDR_EXP 120
49492: PUSH
49493: LD_EXP 120
49497: PPUSH
49498: LD_VAR 0 2
49502: PPUSH
49503: LD_VAR 0 4
49507: PPUSH
49508: CALL_OW 1
49512: ST_TO_ADDR
// break ;
49513: GO 49517
// end ; end ;
49515: GO 49161
49517: POP
49518: POP
// end ;
49519: GO 49093
49521: POP
49522: POP
// end ;
49523: LD_VAR 0 1
49527: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49528: LD_INT 0
49530: PPUSH
49531: PPUSH
49532: PPUSH
// if not mc_bases then
49533: LD_EXP 99
49537: NOT
49538: IFFALSE 49542
// exit ;
49540: GO 49631
// for i = 1 to mc_bases do
49542: LD_ADDR_VAR 0 2
49546: PUSH
49547: DOUBLE
49548: LD_INT 1
49550: DEC
49551: ST_TO_ADDR
49552: LD_EXP 99
49556: PUSH
49557: FOR_TO
49558: IFFALSE 49629
// begin if mc_attack [ i ] then
49560: LD_EXP 119
49564: PUSH
49565: LD_VAR 0 2
49569: ARRAY
49570: IFFALSE 49627
// begin tmp := mc_attack [ i ] [ 1 ] ;
49572: LD_ADDR_VAR 0 3
49576: PUSH
49577: LD_EXP 119
49581: PUSH
49582: LD_VAR 0 2
49586: ARRAY
49587: PUSH
49588: LD_INT 1
49590: ARRAY
49591: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49592: LD_ADDR_EXP 119
49596: PUSH
49597: LD_EXP 119
49601: PPUSH
49602: LD_VAR 0 2
49606: PPUSH
49607: EMPTY
49608: PPUSH
49609: CALL_OW 1
49613: ST_TO_ADDR
// Attack ( tmp ) ;
49614: LD_VAR 0 3
49618: PPUSH
49619: CALL 99266 0 1
// exit ;
49623: POP
49624: POP
49625: GO 49631
// end ; end ;
49627: GO 49557
49629: POP
49630: POP
// end ;
49631: LD_VAR 0 1
49635: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49636: LD_INT 0
49638: PPUSH
49639: PPUSH
49640: PPUSH
49641: PPUSH
49642: PPUSH
49643: PPUSH
49644: PPUSH
// if not mc_bases then
49645: LD_EXP 99
49649: NOT
49650: IFFALSE 49654
// exit ;
49652: GO 50236
// for i = 1 to mc_bases do
49654: LD_ADDR_VAR 0 2
49658: PUSH
49659: DOUBLE
49660: LD_INT 1
49662: DEC
49663: ST_TO_ADDR
49664: LD_EXP 99
49668: PUSH
49669: FOR_TO
49670: IFFALSE 50234
// begin if not mc_bases [ i ] then
49672: LD_EXP 99
49676: PUSH
49677: LD_VAR 0 2
49681: ARRAY
49682: NOT
49683: IFFALSE 49687
// continue ;
49685: GO 49669
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49687: LD_ADDR_VAR 0 7
49691: PUSH
49692: LD_EXP 99
49696: PUSH
49697: LD_VAR 0 2
49701: ARRAY
49702: PUSH
49703: LD_INT 1
49705: ARRAY
49706: PPUSH
49707: CALL 67625 0 1
49711: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49712: LD_ADDR_EXP 122
49716: PUSH
49717: LD_EXP 122
49721: PPUSH
49722: LD_VAR 0 2
49726: PPUSH
49727: LD_EXP 99
49731: PUSH
49732: LD_VAR 0 2
49736: ARRAY
49737: PUSH
49738: LD_INT 1
49740: ARRAY
49741: PPUSH
49742: CALL_OW 255
49746: PPUSH
49747: LD_EXP 124
49751: PUSH
49752: LD_VAR 0 2
49756: ARRAY
49757: PPUSH
49758: CALL 65328 0 2
49762: PPUSH
49763: CALL_OW 1
49767: ST_TO_ADDR
// if not mc_scan [ i ] then
49768: LD_EXP 122
49772: PUSH
49773: LD_VAR 0 2
49777: ARRAY
49778: NOT
49779: IFFALSE 49934
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49781: LD_ADDR_VAR 0 4
49785: PUSH
49786: LD_EXP 99
49790: PUSH
49791: LD_VAR 0 2
49795: ARRAY
49796: PPUSH
49797: LD_INT 2
49799: PUSH
49800: LD_INT 25
49802: PUSH
49803: LD_INT 5
49805: PUSH
49806: EMPTY
49807: LIST
49808: LIST
49809: PUSH
49810: LD_INT 25
49812: PUSH
49813: LD_INT 8
49815: PUSH
49816: EMPTY
49817: LIST
49818: LIST
49819: PUSH
49820: LD_INT 25
49822: PUSH
49823: LD_INT 9
49825: PUSH
49826: EMPTY
49827: LIST
49828: LIST
49829: PUSH
49830: EMPTY
49831: LIST
49832: LIST
49833: LIST
49834: LIST
49835: PPUSH
49836: CALL_OW 72
49840: ST_TO_ADDR
// if not tmp then
49841: LD_VAR 0 4
49845: NOT
49846: IFFALSE 49850
// continue ;
49848: GO 49669
// for j in tmp do
49850: LD_ADDR_VAR 0 3
49854: PUSH
49855: LD_VAR 0 4
49859: PUSH
49860: FOR_IN
49861: IFFALSE 49932
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49863: LD_VAR 0 3
49867: PPUSH
49868: CALL_OW 310
49872: PPUSH
49873: CALL_OW 266
49877: PUSH
49878: LD_INT 5
49880: EQUAL
49881: PUSH
49882: LD_VAR 0 3
49886: PPUSH
49887: CALL_OW 257
49891: PUSH
49892: LD_INT 1
49894: EQUAL
49895: AND
49896: PUSH
49897: LD_VAR 0 3
49901: PPUSH
49902: CALL_OW 459
49906: NOT
49907: AND
49908: PUSH
49909: LD_VAR 0 7
49913: AND
49914: IFFALSE 49930
// ComChangeProfession ( j , class ) ;
49916: LD_VAR 0 3
49920: PPUSH
49921: LD_VAR 0 7
49925: PPUSH
49926: CALL_OW 123
49930: GO 49860
49932: POP
49933: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49934: LD_EXP 122
49938: PUSH
49939: LD_VAR 0 2
49943: ARRAY
49944: PUSH
49945: LD_EXP 121
49949: PUSH
49950: LD_VAR 0 2
49954: ARRAY
49955: NOT
49956: AND
49957: PUSH
49958: LD_EXP 99
49962: PUSH
49963: LD_VAR 0 2
49967: ARRAY
49968: PPUSH
49969: LD_INT 30
49971: PUSH
49972: LD_INT 32
49974: PUSH
49975: EMPTY
49976: LIST
49977: LIST
49978: PPUSH
49979: CALL_OW 72
49983: NOT
49984: AND
49985: PUSH
49986: LD_EXP 99
49990: PUSH
49991: LD_VAR 0 2
49995: ARRAY
49996: PPUSH
49997: LD_INT 2
49999: PUSH
50000: LD_INT 30
50002: PUSH
50003: LD_INT 4
50005: PUSH
50006: EMPTY
50007: LIST
50008: LIST
50009: PUSH
50010: LD_INT 30
50012: PUSH
50013: LD_INT 5
50015: PUSH
50016: EMPTY
50017: LIST
50018: LIST
50019: PUSH
50020: EMPTY
50021: LIST
50022: LIST
50023: LIST
50024: PPUSH
50025: CALL_OW 72
50029: NOT
50030: AND
50031: IFFALSE 50163
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50033: LD_ADDR_VAR 0 4
50037: PUSH
50038: LD_EXP 99
50042: PUSH
50043: LD_VAR 0 2
50047: ARRAY
50048: PPUSH
50049: LD_INT 2
50051: PUSH
50052: LD_INT 25
50054: PUSH
50055: LD_INT 1
50057: PUSH
50058: EMPTY
50059: LIST
50060: LIST
50061: PUSH
50062: LD_INT 25
50064: PUSH
50065: LD_INT 5
50067: PUSH
50068: EMPTY
50069: LIST
50070: LIST
50071: PUSH
50072: LD_INT 25
50074: PUSH
50075: LD_INT 8
50077: PUSH
50078: EMPTY
50079: LIST
50080: LIST
50081: PUSH
50082: LD_INT 25
50084: PUSH
50085: LD_INT 9
50087: PUSH
50088: EMPTY
50089: LIST
50090: LIST
50091: PUSH
50092: EMPTY
50093: LIST
50094: LIST
50095: LIST
50096: LIST
50097: LIST
50098: PPUSH
50099: CALL_OW 72
50103: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50104: LD_ADDR_VAR 0 4
50108: PUSH
50109: LD_VAR 0 4
50113: PUSH
50114: LD_VAR 0 4
50118: PPUSH
50119: LD_INT 18
50121: PPUSH
50122: CALL 104049 0 2
50126: DIFF
50127: ST_TO_ADDR
// if tmp then
50128: LD_VAR 0 4
50132: IFFALSE 50163
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50134: LD_VAR 0 2
50138: PPUSH
50139: LD_VAR 0 4
50143: PPUSH
50144: LD_EXP 124
50148: PUSH
50149: LD_VAR 0 2
50153: ARRAY
50154: PPUSH
50155: CALL 65363 0 3
// exit ;
50159: POP
50160: POP
50161: GO 50236
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50163: LD_EXP 122
50167: PUSH
50168: LD_VAR 0 2
50172: ARRAY
50173: PUSH
50174: LD_EXP 121
50178: PUSH
50179: LD_VAR 0 2
50183: ARRAY
50184: AND
50185: IFFALSE 50232
// begin tmp := mc_defender [ i ] ;
50187: LD_ADDR_VAR 0 4
50191: PUSH
50192: LD_EXP 121
50196: PUSH
50197: LD_VAR 0 2
50201: ARRAY
50202: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50203: LD_VAR 0 2
50207: PPUSH
50208: LD_VAR 0 4
50212: PPUSH
50213: LD_EXP 122
50217: PUSH
50218: LD_VAR 0 2
50222: ARRAY
50223: PPUSH
50224: CALL 65924 0 3
// exit ;
50228: POP
50229: POP
50230: GO 50236
// end ; end ;
50232: GO 49669
50234: POP
50235: POP
// end ;
50236: LD_VAR 0 1
50240: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50241: LD_INT 0
50243: PPUSH
50244: PPUSH
50245: PPUSH
50246: PPUSH
50247: PPUSH
50248: PPUSH
50249: PPUSH
50250: PPUSH
50251: PPUSH
50252: PPUSH
50253: PPUSH
// if not mc_bases then
50254: LD_EXP 99
50258: NOT
50259: IFFALSE 50263
// exit ;
50261: GO 51350
// for i = 1 to mc_bases do
50263: LD_ADDR_VAR 0 2
50267: PUSH
50268: DOUBLE
50269: LD_INT 1
50271: DEC
50272: ST_TO_ADDR
50273: LD_EXP 99
50277: PUSH
50278: FOR_TO
50279: IFFALSE 51348
// begin tmp := mc_lab [ i ] ;
50281: LD_ADDR_VAR 0 6
50285: PUSH
50286: LD_EXP 132
50290: PUSH
50291: LD_VAR 0 2
50295: ARRAY
50296: ST_TO_ADDR
// if not tmp then
50297: LD_VAR 0 6
50301: NOT
50302: IFFALSE 50306
// continue ;
50304: GO 50278
// idle_lab := 0 ;
50306: LD_ADDR_VAR 0 11
50310: PUSH
50311: LD_INT 0
50313: ST_TO_ADDR
// for j in tmp do
50314: LD_ADDR_VAR 0 3
50318: PUSH
50319: LD_VAR 0 6
50323: PUSH
50324: FOR_IN
50325: IFFALSE 51344
// begin researching := false ;
50327: LD_ADDR_VAR 0 10
50331: PUSH
50332: LD_INT 0
50334: ST_TO_ADDR
// side := GetSide ( j ) ;
50335: LD_ADDR_VAR 0 4
50339: PUSH
50340: LD_VAR 0 3
50344: PPUSH
50345: CALL_OW 255
50349: ST_TO_ADDR
// if not mc_tech [ side ] then
50350: LD_EXP 126
50354: PUSH
50355: LD_VAR 0 4
50359: ARRAY
50360: NOT
50361: IFFALSE 50365
// continue ;
50363: GO 50324
// if BuildingStatus ( j ) = bs_idle then
50365: LD_VAR 0 3
50369: PPUSH
50370: CALL_OW 461
50374: PUSH
50375: LD_INT 2
50377: EQUAL
50378: IFFALSE 50566
// begin if idle_lab and UnitsInside ( j ) < 6 then
50380: LD_VAR 0 11
50384: PUSH
50385: LD_VAR 0 3
50389: PPUSH
50390: CALL_OW 313
50394: PUSH
50395: LD_INT 6
50397: LESS
50398: AND
50399: IFFALSE 50470
// begin tmp2 := UnitsInside ( idle_lab ) ;
50401: LD_ADDR_VAR 0 9
50405: PUSH
50406: LD_VAR 0 11
50410: PPUSH
50411: CALL_OW 313
50415: ST_TO_ADDR
// if tmp2 then
50416: LD_VAR 0 9
50420: IFFALSE 50462
// for x in tmp2 do
50422: LD_ADDR_VAR 0 7
50426: PUSH
50427: LD_VAR 0 9
50431: PUSH
50432: FOR_IN
50433: IFFALSE 50460
// begin ComExitBuilding ( x ) ;
50435: LD_VAR 0 7
50439: PPUSH
50440: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50444: LD_VAR 0 7
50448: PPUSH
50449: LD_VAR 0 3
50453: PPUSH
50454: CALL_OW 180
// end ;
50458: GO 50432
50460: POP
50461: POP
// idle_lab := 0 ;
50462: LD_ADDR_VAR 0 11
50466: PUSH
50467: LD_INT 0
50469: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50470: LD_ADDR_VAR 0 5
50474: PUSH
50475: LD_EXP 126
50479: PUSH
50480: LD_VAR 0 4
50484: ARRAY
50485: PUSH
50486: FOR_IN
50487: IFFALSE 50547
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50489: LD_VAR 0 3
50493: PPUSH
50494: LD_VAR 0 5
50498: PPUSH
50499: CALL_OW 430
50503: PUSH
50504: LD_VAR 0 4
50508: PPUSH
50509: LD_VAR 0 5
50513: PPUSH
50514: CALL 64433 0 2
50518: AND
50519: IFFALSE 50545
// begin researching := true ;
50521: LD_ADDR_VAR 0 10
50525: PUSH
50526: LD_INT 1
50528: ST_TO_ADDR
// ComResearch ( j , t ) ;
50529: LD_VAR 0 3
50533: PPUSH
50534: LD_VAR 0 5
50538: PPUSH
50539: CALL_OW 124
// break ;
50543: GO 50547
// end ;
50545: GO 50486
50547: POP
50548: POP
// if not researching then
50549: LD_VAR 0 10
50553: NOT
50554: IFFALSE 50566
// idle_lab := j ;
50556: LD_ADDR_VAR 0 11
50560: PUSH
50561: LD_VAR 0 3
50565: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50566: LD_VAR 0 3
50570: PPUSH
50571: CALL_OW 461
50575: PUSH
50576: LD_INT 10
50578: EQUAL
50579: IFFALSE 51167
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50581: LD_EXP 128
50585: PUSH
50586: LD_VAR 0 2
50590: ARRAY
50591: NOT
50592: PUSH
50593: LD_EXP 129
50597: PUSH
50598: LD_VAR 0 2
50602: ARRAY
50603: NOT
50604: AND
50605: PUSH
50606: LD_EXP 126
50610: PUSH
50611: LD_VAR 0 4
50615: ARRAY
50616: PUSH
50617: LD_INT 1
50619: GREATER
50620: AND
50621: IFFALSE 50752
// begin ComCancel ( j ) ;
50623: LD_VAR 0 3
50627: PPUSH
50628: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50632: LD_ADDR_EXP 126
50636: PUSH
50637: LD_EXP 126
50641: PPUSH
50642: LD_VAR 0 4
50646: PPUSH
50647: LD_EXP 126
50651: PUSH
50652: LD_VAR 0 4
50656: ARRAY
50657: PPUSH
50658: LD_EXP 126
50662: PUSH
50663: LD_VAR 0 4
50667: ARRAY
50668: PUSH
50669: LD_INT 1
50671: MINUS
50672: PPUSH
50673: LD_EXP 126
50677: PUSH
50678: LD_VAR 0 4
50682: ARRAY
50683: PPUSH
50684: LD_INT 0
50686: PPUSH
50687: CALL 70207 0 4
50691: PPUSH
50692: CALL_OW 1
50696: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50697: LD_ADDR_EXP 126
50701: PUSH
50702: LD_EXP 126
50706: PPUSH
50707: LD_VAR 0 4
50711: PPUSH
50712: LD_EXP 126
50716: PUSH
50717: LD_VAR 0 4
50721: ARRAY
50722: PPUSH
50723: LD_EXP 126
50727: PUSH
50728: LD_VAR 0 4
50732: ARRAY
50733: PPUSH
50734: LD_INT 1
50736: PPUSH
50737: LD_INT 0
50739: PPUSH
50740: CALL 70207 0 4
50744: PPUSH
50745: CALL_OW 1
50749: ST_TO_ADDR
// continue ;
50750: GO 50324
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50752: LD_EXP 128
50756: PUSH
50757: LD_VAR 0 2
50761: ARRAY
50762: PUSH
50763: LD_EXP 129
50767: PUSH
50768: LD_VAR 0 2
50772: ARRAY
50773: NOT
50774: AND
50775: IFFALSE 50902
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50777: LD_ADDR_EXP 129
50781: PUSH
50782: LD_EXP 129
50786: PPUSH
50787: LD_VAR 0 2
50791: PUSH
50792: LD_EXP 129
50796: PUSH
50797: LD_VAR 0 2
50801: ARRAY
50802: PUSH
50803: LD_INT 1
50805: PLUS
50806: PUSH
50807: EMPTY
50808: LIST
50809: LIST
50810: PPUSH
50811: LD_EXP 128
50815: PUSH
50816: LD_VAR 0 2
50820: ARRAY
50821: PUSH
50822: LD_INT 1
50824: ARRAY
50825: PPUSH
50826: CALL 70789 0 3
50830: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50831: LD_EXP 128
50835: PUSH
50836: LD_VAR 0 2
50840: ARRAY
50841: PUSH
50842: LD_INT 1
50844: ARRAY
50845: PPUSH
50846: LD_INT 112
50848: PPUSH
50849: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50853: LD_ADDR_VAR 0 9
50857: PUSH
50858: LD_EXP 128
50862: PUSH
50863: LD_VAR 0 2
50867: ARRAY
50868: PPUSH
50869: LD_INT 1
50871: PPUSH
50872: CALL_OW 3
50876: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50877: LD_ADDR_EXP 128
50881: PUSH
50882: LD_EXP 128
50886: PPUSH
50887: LD_VAR 0 2
50891: PPUSH
50892: LD_VAR 0 9
50896: PPUSH
50897: CALL_OW 1
50901: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50902: LD_EXP 128
50906: PUSH
50907: LD_VAR 0 2
50911: ARRAY
50912: PUSH
50913: LD_EXP 129
50917: PUSH
50918: LD_VAR 0 2
50922: ARRAY
50923: AND
50924: PUSH
50925: LD_EXP 129
50929: PUSH
50930: LD_VAR 0 2
50934: ARRAY
50935: PUSH
50936: LD_INT 1
50938: ARRAY
50939: PPUSH
50940: CALL_OW 310
50944: NOT
50945: AND
50946: PUSH
50947: LD_VAR 0 3
50951: PPUSH
50952: CALL_OW 313
50956: PUSH
50957: LD_INT 6
50959: EQUAL
50960: AND
50961: IFFALSE 51017
// begin tmp2 := UnitsInside ( j ) ;
50963: LD_ADDR_VAR 0 9
50967: PUSH
50968: LD_VAR 0 3
50972: PPUSH
50973: CALL_OW 313
50977: ST_TO_ADDR
// if tmp2 = 6 then
50978: LD_VAR 0 9
50982: PUSH
50983: LD_INT 6
50985: EQUAL
50986: IFFALSE 51017
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
50988: LD_VAR 0 9
50992: PUSH
50993: LD_INT 1
50995: ARRAY
50996: PPUSH
50997: LD_INT 112
50999: PPUSH
51000: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51004: LD_VAR 0 9
51008: PUSH
51009: LD_INT 1
51011: ARRAY
51012: PPUSH
51013: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51017: LD_EXP 129
51021: PUSH
51022: LD_VAR 0 2
51026: ARRAY
51027: PUSH
51028: LD_EXP 129
51032: PUSH
51033: LD_VAR 0 2
51037: ARRAY
51038: PUSH
51039: LD_INT 1
51041: ARRAY
51042: PPUSH
51043: CALL_OW 314
51047: NOT
51048: AND
51049: PUSH
51050: LD_EXP 129
51054: PUSH
51055: LD_VAR 0 2
51059: ARRAY
51060: PUSH
51061: LD_INT 1
51063: ARRAY
51064: PPUSH
51065: CALL_OW 310
51069: NOT
51070: AND
51071: IFFALSE 51097
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51073: LD_EXP 129
51077: PUSH
51078: LD_VAR 0 2
51082: ARRAY
51083: PUSH
51084: LD_INT 1
51086: ARRAY
51087: PPUSH
51088: LD_VAR 0 3
51092: PPUSH
51093: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51097: LD_EXP 129
51101: PUSH
51102: LD_VAR 0 2
51106: ARRAY
51107: PUSH
51108: LD_INT 1
51110: ARRAY
51111: PPUSH
51112: CALL_OW 310
51116: PUSH
51117: LD_EXP 129
51121: PUSH
51122: LD_VAR 0 2
51126: ARRAY
51127: PUSH
51128: LD_INT 1
51130: ARRAY
51131: PPUSH
51132: CALL_OW 310
51136: PPUSH
51137: CALL_OW 461
51141: PUSH
51142: LD_INT 3
51144: NONEQUAL
51145: AND
51146: IFFALSE 51167
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51148: LD_EXP 129
51152: PUSH
51153: LD_VAR 0 2
51157: ARRAY
51158: PUSH
51159: LD_INT 1
51161: ARRAY
51162: PPUSH
51163: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51167: LD_VAR 0 3
51171: PPUSH
51172: CALL_OW 461
51176: PUSH
51177: LD_INT 6
51179: EQUAL
51180: PUSH
51181: LD_VAR 0 6
51185: PUSH
51186: LD_INT 1
51188: GREATER
51189: AND
51190: IFFALSE 51342
// begin sci := [ ] ;
51192: LD_ADDR_VAR 0 8
51196: PUSH
51197: EMPTY
51198: ST_TO_ADDR
// for x in ( tmp diff j ) do
51199: LD_ADDR_VAR 0 7
51203: PUSH
51204: LD_VAR 0 6
51208: PUSH
51209: LD_VAR 0 3
51213: DIFF
51214: PUSH
51215: FOR_IN
51216: IFFALSE 51268
// begin if sci = 6 then
51218: LD_VAR 0 8
51222: PUSH
51223: LD_INT 6
51225: EQUAL
51226: IFFALSE 51230
// break ;
51228: GO 51268
// if BuildingStatus ( x ) = bs_idle then
51230: LD_VAR 0 7
51234: PPUSH
51235: CALL_OW 461
51239: PUSH
51240: LD_INT 2
51242: EQUAL
51243: IFFALSE 51266
// sci := sci ^ UnitsInside ( x ) ;
51245: LD_ADDR_VAR 0 8
51249: PUSH
51250: LD_VAR 0 8
51254: PUSH
51255: LD_VAR 0 7
51259: PPUSH
51260: CALL_OW 313
51264: ADD
51265: ST_TO_ADDR
// end ;
51266: GO 51215
51268: POP
51269: POP
// if not sci then
51270: LD_VAR 0 8
51274: NOT
51275: IFFALSE 51279
// continue ;
51277: GO 50324
// for x in sci do
51279: LD_ADDR_VAR 0 7
51283: PUSH
51284: LD_VAR 0 8
51288: PUSH
51289: FOR_IN
51290: IFFALSE 51340
// if IsInUnit ( x ) and not HasTask ( x ) then
51292: LD_VAR 0 7
51296: PPUSH
51297: CALL_OW 310
51301: PUSH
51302: LD_VAR 0 7
51306: PPUSH
51307: CALL_OW 314
51311: NOT
51312: AND
51313: IFFALSE 51338
// begin ComExitBuilding ( x ) ;
51315: LD_VAR 0 7
51319: PPUSH
51320: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51324: LD_VAR 0 7
51328: PPUSH
51329: LD_VAR 0 3
51333: PPUSH
51334: CALL_OW 180
// end ;
51338: GO 51289
51340: POP
51341: POP
// end ; end ;
51342: GO 50324
51344: POP
51345: POP
// end ;
51346: GO 50278
51348: POP
51349: POP
// end ;
51350: LD_VAR 0 1
51354: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51355: LD_INT 0
51357: PPUSH
51358: PPUSH
// if not mc_bases then
51359: LD_EXP 99
51363: NOT
51364: IFFALSE 51368
// exit ;
51366: GO 51449
// for i = 1 to mc_bases do
51368: LD_ADDR_VAR 0 2
51372: PUSH
51373: DOUBLE
51374: LD_INT 1
51376: DEC
51377: ST_TO_ADDR
51378: LD_EXP 99
51382: PUSH
51383: FOR_TO
51384: IFFALSE 51447
// if mc_mines [ i ] and mc_miners [ i ] then
51386: LD_EXP 112
51390: PUSH
51391: LD_VAR 0 2
51395: ARRAY
51396: PUSH
51397: LD_EXP 113
51401: PUSH
51402: LD_VAR 0 2
51406: ARRAY
51407: AND
51408: IFFALSE 51445
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51410: LD_EXP 113
51414: PUSH
51415: LD_VAR 0 2
51419: ARRAY
51420: PUSH
51421: LD_INT 1
51423: ARRAY
51424: PPUSH
51425: CALL_OW 255
51429: PPUSH
51430: LD_EXP 112
51434: PUSH
51435: LD_VAR 0 2
51439: ARRAY
51440: PPUSH
51441: CALL 67778 0 2
51445: GO 51383
51447: POP
51448: POP
// end ;
51449: LD_VAR 0 1
51453: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51454: LD_INT 0
51456: PPUSH
51457: PPUSH
51458: PPUSH
51459: PPUSH
51460: PPUSH
51461: PPUSH
51462: PPUSH
51463: PPUSH
// if not mc_bases or not mc_parking then
51464: LD_EXP 99
51468: NOT
51469: PUSH
51470: LD_EXP 123
51474: NOT
51475: OR
51476: IFFALSE 51480
// exit ;
51478: GO 52179
// for i = 1 to mc_bases do
51480: LD_ADDR_VAR 0 2
51484: PUSH
51485: DOUBLE
51486: LD_INT 1
51488: DEC
51489: ST_TO_ADDR
51490: LD_EXP 99
51494: PUSH
51495: FOR_TO
51496: IFFALSE 52177
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51498: LD_EXP 99
51502: PUSH
51503: LD_VAR 0 2
51507: ARRAY
51508: NOT
51509: PUSH
51510: LD_EXP 123
51514: PUSH
51515: LD_VAR 0 2
51519: ARRAY
51520: NOT
51521: OR
51522: IFFALSE 51526
// continue ;
51524: GO 51495
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51526: LD_ADDR_VAR 0 5
51530: PUSH
51531: LD_EXP 99
51535: PUSH
51536: LD_VAR 0 2
51540: ARRAY
51541: PUSH
51542: LD_INT 1
51544: ARRAY
51545: PPUSH
51546: CALL_OW 255
51550: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51551: LD_ADDR_VAR 0 6
51555: PUSH
51556: LD_EXP 99
51560: PUSH
51561: LD_VAR 0 2
51565: ARRAY
51566: PPUSH
51567: LD_INT 30
51569: PUSH
51570: LD_INT 3
51572: PUSH
51573: EMPTY
51574: LIST
51575: LIST
51576: PPUSH
51577: CALL_OW 72
51581: ST_TO_ADDR
// if not fac then
51582: LD_VAR 0 6
51586: NOT
51587: IFFALSE 51638
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51589: LD_ADDR_VAR 0 6
51593: PUSH
51594: LD_EXP 99
51598: PUSH
51599: LD_VAR 0 2
51603: ARRAY
51604: PPUSH
51605: LD_INT 2
51607: PUSH
51608: LD_INT 30
51610: PUSH
51611: LD_INT 0
51613: PUSH
51614: EMPTY
51615: LIST
51616: LIST
51617: PUSH
51618: LD_INT 30
51620: PUSH
51621: LD_INT 1
51623: PUSH
51624: EMPTY
51625: LIST
51626: LIST
51627: PUSH
51628: EMPTY
51629: LIST
51630: LIST
51631: LIST
51632: PPUSH
51633: CALL_OW 72
51637: ST_TO_ADDR
// if not fac then
51638: LD_VAR 0 6
51642: NOT
51643: IFFALSE 51647
// continue ;
51645: GO 51495
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51647: LD_ADDR_VAR 0 7
51651: PUSH
51652: LD_EXP 123
51656: PUSH
51657: LD_VAR 0 2
51661: ARRAY
51662: PPUSH
51663: LD_INT 22
51665: PUSH
51666: LD_VAR 0 5
51670: PUSH
51671: EMPTY
51672: LIST
51673: LIST
51674: PUSH
51675: LD_INT 21
51677: PUSH
51678: LD_INT 2
51680: PUSH
51681: EMPTY
51682: LIST
51683: LIST
51684: PUSH
51685: LD_INT 3
51687: PUSH
51688: LD_INT 24
51690: PUSH
51691: LD_INT 1000
51693: PUSH
51694: EMPTY
51695: LIST
51696: LIST
51697: PUSH
51698: EMPTY
51699: LIST
51700: LIST
51701: PUSH
51702: EMPTY
51703: LIST
51704: LIST
51705: LIST
51706: PPUSH
51707: CALL_OW 70
51711: ST_TO_ADDR
// for j in fac do
51712: LD_ADDR_VAR 0 3
51716: PUSH
51717: LD_VAR 0 6
51721: PUSH
51722: FOR_IN
51723: IFFALSE 51804
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51725: LD_ADDR_VAR 0 7
51729: PUSH
51730: LD_VAR 0 7
51734: PUSH
51735: LD_INT 22
51737: PUSH
51738: LD_VAR 0 5
51742: PUSH
51743: EMPTY
51744: LIST
51745: LIST
51746: PUSH
51747: LD_INT 91
51749: PUSH
51750: LD_VAR 0 3
51754: PUSH
51755: LD_INT 15
51757: PUSH
51758: EMPTY
51759: LIST
51760: LIST
51761: LIST
51762: PUSH
51763: LD_INT 21
51765: PUSH
51766: LD_INT 2
51768: PUSH
51769: EMPTY
51770: LIST
51771: LIST
51772: PUSH
51773: LD_INT 3
51775: PUSH
51776: LD_INT 24
51778: PUSH
51779: LD_INT 1000
51781: PUSH
51782: EMPTY
51783: LIST
51784: LIST
51785: PUSH
51786: EMPTY
51787: LIST
51788: LIST
51789: PUSH
51790: EMPTY
51791: LIST
51792: LIST
51793: LIST
51794: LIST
51795: PPUSH
51796: CALL_OW 69
51800: UNION
51801: ST_TO_ADDR
51802: GO 51722
51804: POP
51805: POP
// if not vehs then
51806: LD_VAR 0 7
51810: NOT
51811: IFFALSE 51837
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51813: LD_ADDR_EXP 111
51817: PUSH
51818: LD_EXP 111
51822: PPUSH
51823: LD_VAR 0 2
51827: PPUSH
51828: EMPTY
51829: PPUSH
51830: CALL_OW 1
51834: ST_TO_ADDR
// continue ;
51835: GO 51495
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51837: LD_ADDR_VAR 0 8
51841: PUSH
51842: LD_EXP 99
51846: PUSH
51847: LD_VAR 0 2
51851: ARRAY
51852: PPUSH
51853: LD_INT 30
51855: PUSH
51856: LD_INT 3
51858: PUSH
51859: EMPTY
51860: LIST
51861: LIST
51862: PPUSH
51863: CALL_OW 72
51867: ST_TO_ADDR
// if tmp then
51868: LD_VAR 0 8
51872: IFFALSE 51975
// begin for j in tmp do
51874: LD_ADDR_VAR 0 3
51878: PUSH
51879: LD_VAR 0 8
51883: PUSH
51884: FOR_IN
51885: IFFALSE 51973
// for k in UnitsInside ( j ) do
51887: LD_ADDR_VAR 0 4
51891: PUSH
51892: LD_VAR 0 3
51896: PPUSH
51897: CALL_OW 313
51901: PUSH
51902: FOR_IN
51903: IFFALSE 51969
// if k then
51905: LD_VAR 0 4
51909: IFFALSE 51967
// if not k in mc_repair_vehicle [ i ] then
51911: LD_VAR 0 4
51915: PUSH
51916: LD_EXP 111
51920: PUSH
51921: LD_VAR 0 2
51925: ARRAY
51926: IN
51927: NOT
51928: IFFALSE 51967
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51930: LD_ADDR_EXP 111
51934: PUSH
51935: LD_EXP 111
51939: PPUSH
51940: LD_VAR 0 2
51944: PPUSH
51945: LD_EXP 111
51949: PUSH
51950: LD_VAR 0 2
51954: ARRAY
51955: PUSH
51956: LD_VAR 0 4
51960: UNION
51961: PPUSH
51962: CALL_OW 1
51966: ST_TO_ADDR
51967: GO 51902
51969: POP
51970: POP
51971: GO 51884
51973: POP
51974: POP
// end ; if not mc_repair_vehicle [ i ] then
51975: LD_EXP 111
51979: PUSH
51980: LD_VAR 0 2
51984: ARRAY
51985: NOT
51986: IFFALSE 51990
// continue ;
51988: GO 51495
// for j in mc_repair_vehicle [ i ] do
51990: LD_ADDR_VAR 0 3
51994: PUSH
51995: LD_EXP 111
51999: PUSH
52000: LD_VAR 0 2
52004: ARRAY
52005: PUSH
52006: FOR_IN
52007: IFFALSE 52173
// begin if GetClass ( j ) <> 3 then
52009: LD_VAR 0 3
52013: PPUSH
52014: CALL_OW 257
52018: PUSH
52019: LD_INT 3
52021: NONEQUAL
52022: IFFALSE 52063
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52024: LD_ADDR_EXP 111
52028: PUSH
52029: LD_EXP 111
52033: PPUSH
52034: LD_VAR 0 2
52038: PPUSH
52039: LD_EXP 111
52043: PUSH
52044: LD_VAR 0 2
52048: ARRAY
52049: PUSH
52050: LD_VAR 0 3
52054: DIFF
52055: PPUSH
52056: CALL_OW 1
52060: ST_TO_ADDR
// continue ;
52061: GO 52006
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52063: LD_VAR 0 3
52067: PPUSH
52068: CALL_OW 311
52072: NOT
52073: PUSH
52074: LD_VAR 0 3
52078: PUSH
52079: LD_EXP 102
52083: PUSH
52084: LD_VAR 0 2
52088: ARRAY
52089: PUSH
52090: LD_INT 1
52092: ARRAY
52093: IN
52094: NOT
52095: AND
52096: PUSH
52097: LD_VAR 0 3
52101: PUSH
52102: LD_EXP 102
52106: PUSH
52107: LD_VAR 0 2
52111: ARRAY
52112: PUSH
52113: LD_INT 2
52115: ARRAY
52116: IN
52117: NOT
52118: AND
52119: IFFALSE 52171
// begin if IsInUnit ( j ) then
52121: LD_VAR 0 3
52125: PPUSH
52126: CALL_OW 310
52130: IFFALSE 52141
// ComExitBuilding ( j ) ;
52132: LD_VAR 0 3
52136: PPUSH
52137: CALL_OW 122
// if not HasTask ( j ) then
52141: LD_VAR 0 3
52145: PPUSH
52146: CALL_OW 314
52150: NOT
52151: IFFALSE 52171
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52153: LD_VAR 0 3
52157: PPUSH
52158: LD_VAR 0 7
52162: PUSH
52163: LD_INT 1
52165: ARRAY
52166: PPUSH
52167: CALL_OW 189
// end ; end ;
52171: GO 52006
52173: POP
52174: POP
// end ;
52175: GO 51495
52177: POP
52178: POP
// end ;
52179: LD_VAR 0 1
52183: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52184: LD_INT 0
52186: PPUSH
52187: PPUSH
52188: PPUSH
52189: PPUSH
52190: PPUSH
52191: PPUSH
52192: PPUSH
52193: PPUSH
52194: PPUSH
52195: PPUSH
52196: PPUSH
// if not mc_bases then
52197: LD_EXP 99
52201: NOT
52202: IFFALSE 52206
// exit ;
52204: GO 53008
// for i = 1 to mc_bases do
52206: LD_ADDR_VAR 0 2
52210: PUSH
52211: DOUBLE
52212: LD_INT 1
52214: DEC
52215: ST_TO_ADDR
52216: LD_EXP 99
52220: PUSH
52221: FOR_TO
52222: IFFALSE 53006
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52224: LD_EXP 127
52228: PUSH
52229: LD_VAR 0 2
52233: ARRAY
52234: NOT
52235: PUSH
52236: LD_EXP 102
52240: PUSH
52241: LD_VAR 0 2
52245: ARRAY
52246: PUSH
52247: LD_INT 1
52249: ARRAY
52250: OR
52251: PUSH
52252: LD_EXP 102
52256: PUSH
52257: LD_VAR 0 2
52261: ARRAY
52262: PUSH
52263: LD_INT 2
52265: ARRAY
52266: OR
52267: PUSH
52268: LD_EXP 125
52272: PUSH
52273: LD_VAR 0 2
52277: ARRAY
52278: PPUSH
52279: LD_INT 1
52281: PPUSH
52282: CALL_OW 325
52286: NOT
52287: OR
52288: PUSH
52289: LD_EXP 122
52293: PUSH
52294: LD_VAR 0 2
52298: ARRAY
52299: OR
52300: IFFALSE 52304
// continue ;
52302: GO 52221
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52304: LD_ADDR_VAR 0 8
52308: PUSH
52309: LD_EXP 99
52313: PUSH
52314: LD_VAR 0 2
52318: ARRAY
52319: PPUSH
52320: LD_INT 25
52322: PUSH
52323: LD_INT 4
52325: PUSH
52326: EMPTY
52327: LIST
52328: LIST
52329: PUSH
52330: LD_INT 50
52332: PUSH
52333: EMPTY
52334: LIST
52335: PUSH
52336: LD_INT 3
52338: PUSH
52339: LD_INT 60
52341: PUSH
52342: EMPTY
52343: LIST
52344: PUSH
52345: EMPTY
52346: LIST
52347: LIST
52348: PUSH
52349: EMPTY
52350: LIST
52351: LIST
52352: LIST
52353: PPUSH
52354: CALL_OW 72
52358: PUSH
52359: LD_EXP 103
52363: PUSH
52364: LD_VAR 0 2
52368: ARRAY
52369: DIFF
52370: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52371: LD_ADDR_VAR 0 9
52375: PUSH
52376: LD_EXP 99
52380: PUSH
52381: LD_VAR 0 2
52385: ARRAY
52386: PPUSH
52387: LD_INT 2
52389: PUSH
52390: LD_INT 30
52392: PUSH
52393: LD_INT 0
52395: PUSH
52396: EMPTY
52397: LIST
52398: LIST
52399: PUSH
52400: LD_INT 30
52402: PUSH
52403: LD_INT 1
52405: PUSH
52406: EMPTY
52407: LIST
52408: LIST
52409: PUSH
52410: EMPTY
52411: LIST
52412: LIST
52413: LIST
52414: PPUSH
52415: CALL_OW 72
52419: ST_TO_ADDR
// if not tmp or not dep then
52420: LD_VAR 0 8
52424: NOT
52425: PUSH
52426: LD_VAR 0 9
52430: NOT
52431: OR
52432: IFFALSE 52436
// continue ;
52434: GO 52221
// side := GetSide ( tmp [ 1 ] ) ;
52436: LD_ADDR_VAR 0 11
52440: PUSH
52441: LD_VAR 0 8
52445: PUSH
52446: LD_INT 1
52448: ARRAY
52449: PPUSH
52450: CALL_OW 255
52454: ST_TO_ADDR
// dep := dep [ 1 ] ;
52455: LD_ADDR_VAR 0 9
52459: PUSH
52460: LD_VAR 0 9
52464: PUSH
52465: LD_INT 1
52467: ARRAY
52468: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52469: LD_ADDR_VAR 0 7
52473: PUSH
52474: LD_EXP 127
52478: PUSH
52479: LD_VAR 0 2
52483: ARRAY
52484: PPUSH
52485: LD_INT 22
52487: PUSH
52488: LD_INT 0
52490: PUSH
52491: EMPTY
52492: LIST
52493: LIST
52494: PUSH
52495: LD_INT 25
52497: PUSH
52498: LD_INT 12
52500: PUSH
52501: EMPTY
52502: LIST
52503: LIST
52504: PUSH
52505: EMPTY
52506: LIST
52507: LIST
52508: PPUSH
52509: CALL_OW 70
52513: PUSH
52514: LD_INT 22
52516: PUSH
52517: LD_INT 0
52519: PUSH
52520: EMPTY
52521: LIST
52522: LIST
52523: PUSH
52524: LD_INT 25
52526: PUSH
52527: LD_INT 12
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: PUSH
52534: LD_INT 91
52536: PUSH
52537: LD_VAR 0 9
52541: PUSH
52542: LD_INT 20
52544: PUSH
52545: EMPTY
52546: LIST
52547: LIST
52548: LIST
52549: PUSH
52550: EMPTY
52551: LIST
52552: LIST
52553: LIST
52554: PPUSH
52555: CALL_OW 69
52559: UNION
52560: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52561: LD_ADDR_VAR 0 10
52565: PUSH
52566: LD_EXP 127
52570: PUSH
52571: LD_VAR 0 2
52575: ARRAY
52576: PPUSH
52577: LD_INT 81
52579: PUSH
52580: LD_VAR 0 11
52584: PUSH
52585: EMPTY
52586: LIST
52587: LIST
52588: PPUSH
52589: CALL_OW 70
52593: ST_TO_ADDR
// if not apes or danger_at_area then
52594: LD_VAR 0 7
52598: NOT
52599: PUSH
52600: LD_VAR 0 10
52604: OR
52605: IFFALSE 52655
// begin if mc_taming [ i ] then
52607: LD_EXP 130
52611: PUSH
52612: LD_VAR 0 2
52616: ARRAY
52617: IFFALSE 52653
// begin MC_Reset ( i , 121 ) ;
52619: LD_VAR 0 2
52623: PPUSH
52624: LD_INT 121
52626: PPUSH
52627: CALL 37986 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52631: LD_ADDR_EXP 130
52635: PUSH
52636: LD_EXP 130
52640: PPUSH
52641: LD_VAR 0 2
52645: PPUSH
52646: EMPTY
52647: PPUSH
52648: CALL_OW 1
52652: ST_TO_ADDR
// end ; continue ;
52653: GO 52221
// end ; for j in tmp do
52655: LD_ADDR_VAR 0 3
52659: PUSH
52660: LD_VAR 0 8
52664: PUSH
52665: FOR_IN
52666: IFFALSE 53002
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52668: LD_VAR 0 3
52672: PUSH
52673: LD_EXP 130
52677: PUSH
52678: LD_VAR 0 2
52682: ARRAY
52683: IN
52684: NOT
52685: PUSH
52686: LD_EXP 130
52690: PUSH
52691: LD_VAR 0 2
52695: ARRAY
52696: PUSH
52697: LD_INT 3
52699: LESS
52700: AND
52701: IFFALSE 52759
// begin SetTag ( j , 121 ) ;
52703: LD_VAR 0 3
52707: PPUSH
52708: LD_INT 121
52710: PPUSH
52711: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52715: LD_ADDR_EXP 130
52719: PUSH
52720: LD_EXP 130
52724: PPUSH
52725: LD_VAR 0 2
52729: PUSH
52730: LD_EXP 130
52734: PUSH
52735: LD_VAR 0 2
52739: ARRAY
52740: PUSH
52741: LD_INT 1
52743: PLUS
52744: PUSH
52745: EMPTY
52746: LIST
52747: LIST
52748: PPUSH
52749: LD_VAR 0 3
52753: PPUSH
52754: CALL 70789 0 3
52758: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52759: LD_VAR 0 3
52763: PUSH
52764: LD_EXP 130
52768: PUSH
52769: LD_VAR 0 2
52773: ARRAY
52774: IN
52775: IFFALSE 53000
// begin if GetClass ( j ) <> 4 then
52777: LD_VAR 0 3
52781: PPUSH
52782: CALL_OW 257
52786: PUSH
52787: LD_INT 4
52789: NONEQUAL
52790: IFFALSE 52843
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52792: LD_ADDR_EXP 130
52796: PUSH
52797: LD_EXP 130
52801: PPUSH
52802: LD_VAR 0 2
52806: PPUSH
52807: LD_EXP 130
52811: PUSH
52812: LD_VAR 0 2
52816: ARRAY
52817: PUSH
52818: LD_VAR 0 3
52822: DIFF
52823: PPUSH
52824: CALL_OW 1
52828: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52829: LD_VAR 0 3
52833: PPUSH
52834: LD_INT 0
52836: PPUSH
52837: CALL_OW 109
// continue ;
52841: GO 52665
// end ; if IsInUnit ( j ) then
52843: LD_VAR 0 3
52847: PPUSH
52848: CALL_OW 310
52852: IFFALSE 52863
// ComExitBuilding ( j ) ;
52854: LD_VAR 0 3
52858: PPUSH
52859: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52863: LD_ADDR_VAR 0 6
52867: PUSH
52868: LD_VAR 0 7
52872: PPUSH
52873: LD_VAR 0 3
52877: PPUSH
52878: CALL_OW 74
52882: ST_TO_ADDR
// if not ape then
52883: LD_VAR 0 6
52887: NOT
52888: IFFALSE 52892
// break ;
52890: GO 53002
// x := GetX ( ape ) ;
52892: LD_ADDR_VAR 0 4
52896: PUSH
52897: LD_VAR 0 6
52901: PPUSH
52902: CALL_OW 250
52906: ST_TO_ADDR
// y := GetY ( ape ) ;
52907: LD_ADDR_VAR 0 5
52911: PUSH
52912: LD_VAR 0 6
52916: PPUSH
52917: CALL_OW 251
52921: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52922: LD_VAR 0 4
52926: PPUSH
52927: LD_VAR 0 5
52931: PPUSH
52932: CALL_OW 488
52936: NOT
52937: PUSH
52938: LD_VAR 0 11
52942: PPUSH
52943: LD_VAR 0 4
52947: PPUSH
52948: LD_VAR 0 5
52952: PPUSH
52953: LD_INT 20
52955: PPUSH
52956: CALL 71685 0 4
52960: PUSH
52961: LD_INT 4
52963: ARRAY
52964: OR
52965: IFFALSE 52969
// break ;
52967: GO 53002
// if not HasTask ( j ) then
52969: LD_VAR 0 3
52973: PPUSH
52974: CALL_OW 314
52978: NOT
52979: IFFALSE 53000
// ComTameXY ( j , x , y ) ;
52981: LD_VAR 0 3
52985: PPUSH
52986: LD_VAR 0 4
52990: PPUSH
52991: LD_VAR 0 5
52995: PPUSH
52996: CALL_OW 131
// end ; end ;
53000: GO 52665
53002: POP
53003: POP
// end ;
53004: GO 52221
53006: POP
53007: POP
// end ;
53008: LD_VAR 0 1
53012: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53013: LD_INT 0
53015: PPUSH
53016: PPUSH
53017: PPUSH
53018: PPUSH
53019: PPUSH
53020: PPUSH
53021: PPUSH
53022: PPUSH
// if not mc_bases then
53023: LD_EXP 99
53027: NOT
53028: IFFALSE 53032
// exit ;
53030: GO 53658
// for i = 1 to mc_bases do
53032: LD_ADDR_VAR 0 2
53036: PUSH
53037: DOUBLE
53038: LD_INT 1
53040: DEC
53041: ST_TO_ADDR
53042: LD_EXP 99
53046: PUSH
53047: FOR_TO
53048: IFFALSE 53656
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53050: LD_EXP 128
53054: PUSH
53055: LD_VAR 0 2
53059: ARRAY
53060: NOT
53061: PUSH
53062: LD_EXP 128
53066: PUSH
53067: LD_VAR 0 2
53071: ARRAY
53072: PPUSH
53073: LD_INT 25
53075: PUSH
53076: LD_INT 12
53078: PUSH
53079: EMPTY
53080: LIST
53081: LIST
53082: PPUSH
53083: CALL_OW 72
53087: NOT
53088: OR
53089: IFFALSE 53093
// continue ;
53091: GO 53047
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53093: LD_ADDR_VAR 0 5
53097: PUSH
53098: LD_EXP 128
53102: PUSH
53103: LD_VAR 0 2
53107: ARRAY
53108: PUSH
53109: LD_INT 1
53111: ARRAY
53112: PPUSH
53113: CALL_OW 255
53117: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53118: LD_VAR 0 5
53122: PPUSH
53123: LD_INT 2
53125: PPUSH
53126: CALL_OW 325
53130: IFFALSE 53383
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53132: LD_ADDR_VAR 0 4
53136: PUSH
53137: LD_EXP 128
53141: PUSH
53142: LD_VAR 0 2
53146: ARRAY
53147: PPUSH
53148: LD_INT 25
53150: PUSH
53151: LD_INT 16
53153: PUSH
53154: EMPTY
53155: LIST
53156: LIST
53157: PPUSH
53158: CALL_OW 72
53162: ST_TO_ADDR
// if tmp < 6 then
53163: LD_VAR 0 4
53167: PUSH
53168: LD_INT 6
53170: LESS
53171: IFFALSE 53383
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53173: LD_ADDR_VAR 0 6
53177: PUSH
53178: LD_EXP 99
53182: PUSH
53183: LD_VAR 0 2
53187: ARRAY
53188: PPUSH
53189: LD_INT 2
53191: PUSH
53192: LD_INT 30
53194: PUSH
53195: LD_INT 0
53197: PUSH
53198: EMPTY
53199: LIST
53200: LIST
53201: PUSH
53202: LD_INT 30
53204: PUSH
53205: LD_INT 1
53207: PUSH
53208: EMPTY
53209: LIST
53210: LIST
53211: PUSH
53212: EMPTY
53213: LIST
53214: LIST
53215: LIST
53216: PPUSH
53217: CALL_OW 72
53221: ST_TO_ADDR
// if depot then
53222: LD_VAR 0 6
53226: IFFALSE 53383
// begin selected := 0 ;
53228: LD_ADDR_VAR 0 7
53232: PUSH
53233: LD_INT 0
53235: ST_TO_ADDR
// for j in depot do
53236: LD_ADDR_VAR 0 3
53240: PUSH
53241: LD_VAR 0 6
53245: PUSH
53246: FOR_IN
53247: IFFALSE 53278
// begin if UnitsInside ( j ) < 6 then
53249: LD_VAR 0 3
53253: PPUSH
53254: CALL_OW 313
53258: PUSH
53259: LD_INT 6
53261: LESS
53262: IFFALSE 53276
// begin selected := j ;
53264: LD_ADDR_VAR 0 7
53268: PUSH
53269: LD_VAR 0 3
53273: ST_TO_ADDR
// break ;
53274: GO 53278
// end ; end ;
53276: GO 53246
53278: POP
53279: POP
// if selected then
53280: LD_VAR 0 7
53284: IFFALSE 53383
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53286: LD_ADDR_VAR 0 3
53290: PUSH
53291: LD_EXP 128
53295: PUSH
53296: LD_VAR 0 2
53300: ARRAY
53301: PPUSH
53302: LD_INT 25
53304: PUSH
53305: LD_INT 12
53307: PUSH
53308: EMPTY
53309: LIST
53310: LIST
53311: PPUSH
53312: CALL_OW 72
53316: PUSH
53317: FOR_IN
53318: IFFALSE 53381
// if not HasTask ( j ) then
53320: LD_VAR 0 3
53324: PPUSH
53325: CALL_OW 314
53329: NOT
53330: IFFALSE 53379
// begin if not IsInUnit ( j ) then
53332: LD_VAR 0 3
53336: PPUSH
53337: CALL_OW 310
53341: NOT
53342: IFFALSE 53358
// ComEnterUnit ( j , selected ) ;
53344: LD_VAR 0 3
53348: PPUSH
53349: LD_VAR 0 7
53353: PPUSH
53354: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53358: LD_VAR 0 3
53362: PPUSH
53363: LD_INT 16
53365: PPUSH
53366: CALL_OW 183
// AddComExitBuilding ( j ) ;
53370: LD_VAR 0 3
53374: PPUSH
53375: CALL_OW 182
// end ;
53379: GO 53317
53381: POP
53382: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53383: LD_VAR 0 5
53387: PPUSH
53388: LD_INT 11
53390: PPUSH
53391: CALL_OW 325
53395: IFFALSE 53654
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53397: LD_ADDR_VAR 0 4
53401: PUSH
53402: LD_EXP 128
53406: PUSH
53407: LD_VAR 0 2
53411: ARRAY
53412: PPUSH
53413: LD_INT 25
53415: PUSH
53416: LD_INT 16
53418: PUSH
53419: EMPTY
53420: LIST
53421: LIST
53422: PPUSH
53423: CALL_OW 72
53427: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53428: LD_VAR 0 4
53432: PUSH
53433: LD_INT 6
53435: GREATEREQUAL
53436: PUSH
53437: LD_VAR 0 5
53441: PPUSH
53442: LD_INT 2
53444: PPUSH
53445: CALL_OW 325
53449: NOT
53450: OR
53451: IFFALSE 53654
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53453: LD_ADDR_VAR 0 8
53457: PUSH
53458: LD_EXP 99
53462: PUSH
53463: LD_VAR 0 2
53467: ARRAY
53468: PPUSH
53469: LD_INT 2
53471: PUSH
53472: LD_INT 30
53474: PUSH
53475: LD_INT 4
53477: PUSH
53478: EMPTY
53479: LIST
53480: LIST
53481: PUSH
53482: LD_INT 30
53484: PUSH
53485: LD_INT 5
53487: PUSH
53488: EMPTY
53489: LIST
53490: LIST
53491: PUSH
53492: EMPTY
53493: LIST
53494: LIST
53495: LIST
53496: PPUSH
53497: CALL_OW 72
53501: ST_TO_ADDR
// if barracks then
53502: LD_VAR 0 8
53506: IFFALSE 53654
// begin selected := 0 ;
53508: LD_ADDR_VAR 0 7
53512: PUSH
53513: LD_INT 0
53515: ST_TO_ADDR
// for j in barracks do
53516: LD_ADDR_VAR 0 3
53520: PUSH
53521: LD_VAR 0 8
53525: PUSH
53526: FOR_IN
53527: IFFALSE 53558
// begin if UnitsInside ( j ) < 6 then
53529: LD_VAR 0 3
53533: PPUSH
53534: CALL_OW 313
53538: PUSH
53539: LD_INT 6
53541: LESS
53542: IFFALSE 53556
// begin selected := j ;
53544: LD_ADDR_VAR 0 7
53548: PUSH
53549: LD_VAR 0 3
53553: ST_TO_ADDR
// break ;
53554: GO 53558
// end ; end ;
53556: GO 53526
53558: POP
53559: POP
// if selected then
53560: LD_VAR 0 7
53564: IFFALSE 53654
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53566: LD_ADDR_VAR 0 3
53570: PUSH
53571: LD_EXP 128
53575: PUSH
53576: LD_VAR 0 2
53580: ARRAY
53581: PPUSH
53582: LD_INT 25
53584: PUSH
53585: LD_INT 12
53587: PUSH
53588: EMPTY
53589: LIST
53590: LIST
53591: PPUSH
53592: CALL_OW 72
53596: PUSH
53597: FOR_IN
53598: IFFALSE 53652
// if not IsInUnit ( j ) and not HasTask ( j ) then
53600: LD_VAR 0 3
53604: PPUSH
53605: CALL_OW 310
53609: NOT
53610: PUSH
53611: LD_VAR 0 3
53615: PPUSH
53616: CALL_OW 314
53620: NOT
53621: AND
53622: IFFALSE 53650
// begin ComEnterUnit ( j , selected ) ;
53624: LD_VAR 0 3
53628: PPUSH
53629: LD_VAR 0 7
53633: PPUSH
53634: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53638: LD_VAR 0 3
53642: PPUSH
53643: LD_INT 15
53645: PPUSH
53646: CALL_OW 183
// end ;
53650: GO 53597
53652: POP
53653: POP
// end ; end ; end ; end ; end ;
53654: GO 53047
53656: POP
53657: POP
// end ;
53658: LD_VAR 0 1
53662: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53663: LD_INT 0
53665: PPUSH
53666: PPUSH
53667: PPUSH
53668: PPUSH
// if not mc_bases then
53669: LD_EXP 99
53673: NOT
53674: IFFALSE 53678
// exit ;
53676: GO 53856
// for i = 1 to mc_bases do
53678: LD_ADDR_VAR 0 2
53682: PUSH
53683: DOUBLE
53684: LD_INT 1
53686: DEC
53687: ST_TO_ADDR
53688: LD_EXP 99
53692: PUSH
53693: FOR_TO
53694: IFFALSE 53854
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53696: LD_ADDR_VAR 0 4
53700: PUSH
53701: LD_EXP 99
53705: PUSH
53706: LD_VAR 0 2
53710: ARRAY
53711: PPUSH
53712: LD_INT 25
53714: PUSH
53715: LD_INT 9
53717: PUSH
53718: EMPTY
53719: LIST
53720: LIST
53721: PPUSH
53722: CALL_OW 72
53726: ST_TO_ADDR
// if not tmp then
53727: LD_VAR 0 4
53731: NOT
53732: IFFALSE 53736
// continue ;
53734: GO 53693
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53736: LD_EXP 125
53740: PUSH
53741: LD_VAR 0 2
53745: ARRAY
53746: PPUSH
53747: LD_INT 29
53749: PPUSH
53750: CALL_OW 325
53754: NOT
53755: PUSH
53756: LD_EXP 125
53760: PUSH
53761: LD_VAR 0 2
53765: ARRAY
53766: PPUSH
53767: LD_INT 28
53769: PPUSH
53770: CALL_OW 325
53774: NOT
53775: AND
53776: IFFALSE 53780
// continue ;
53778: GO 53693
// for j in tmp do
53780: LD_ADDR_VAR 0 3
53784: PUSH
53785: LD_VAR 0 4
53789: PUSH
53790: FOR_IN
53791: IFFALSE 53850
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53793: LD_VAR 0 3
53797: PUSH
53798: LD_EXP 102
53802: PUSH
53803: LD_VAR 0 2
53807: ARRAY
53808: PUSH
53809: LD_INT 1
53811: ARRAY
53812: IN
53813: NOT
53814: PUSH
53815: LD_VAR 0 3
53819: PUSH
53820: LD_EXP 102
53824: PUSH
53825: LD_VAR 0 2
53829: ARRAY
53830: PUSH
53831: LD_INT 2
53833: ARRAY
53834: IN
53835: NOT
53836: AND
53837: IFFALSE 53848
// ComSpaceTimeShoot ( j ) ;
53839: LD_VAR 0 3
53843: PPUSH
53844: CALL 64524 0 1
53848: GO 53790
53850: POP
53851: POP
// end ;
53852: GO 53693
53854: POP
53855: POP
// end ;
53856: LD_VAR 0 1
53860: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53861: LD_INT 0
53863: PPUSH
53864: PPUSH
53865: PPUSH
53866: PPUSH
53867: PPUSH
53868: PPUSH
53869: PPUSH
53870: PPUSH
53871: PPUSH
// if not mc_bases then
53872: LD_EXP 99
53876: NOT
53877: IFFALSE 53881
// exit ;
53879: GO 54503
// for i = 1 to mc_bases do
53881: LD_ADDR_VAR 0 2
53885: PUSH
53886: DOUBLE
53887: LD_INT 1
53889: DEC
53890: ST_TO_ADDR
53891: LD_EXP 99
53895: PUSH
53896: FOR_TO
53897: IFFALSE 54501
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53899: LD_EXP 134
53903: PUSH
53904: LD_VAR 0 2
53908: ARRAY
53909: NOT
53910: PUSH
53911: LD_INT 38
53913: PPUSH
53914: LD_EXP 125
53918: PUSH
53919: LD_VAR 0 2
53923: ARRAY
53924: PPUSH
53925: CALL_OW 321
53929: PUSH
53930: LD_INT 2
53932: NONEQUAL
53933: OR
53934: IFFALSE 53938
// continue ;
53936: GO 53896
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53938: LD_ADDR_VAR 0 8
53942: PUSH
53943: LD_EXP 99
53947: PUSH
53948: LD_VAR 0 2
53952: ARRAY
53953: PPUSH
53954: LD_INT 30
53956: PUSH
53957: LD_INT 34
53959: PUSH
53960: EMPTY
53961: LIST
53962: LIST
53963: PPUSH
53964: CALL_OW 72
53968: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53969: LD_ADDR_VAR 0 9
53973: PUSH
53974: LD_EXP 99
53978: PUSH
53979: LD_VAR 0 2
53983: ARRAY
53984: PPUSH
53985: LD_INT 25
53987: PUSH
53988: LD_INT 4
53990: PUSH
53991: EMPTY
53992: LIST
53993: LIST
53994: PPUSH
53995: CALL_OW 72
53999: PPUSH
54000: LD_INT 0
54002: PPUSH
54003: CALL 104049 0 2
54007: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54008: LD_VAR 0 9
54012: NOT
54013: PUSH
54014: LD_VAR 0 8
54018: NOT
54019: OR
54020: PUSH
54021: LD_EXP 99
54025: PUSH
54026: LD_VAR 0 2
54030: ARRAY
54031: PPUSH
54032: LD_INT 124
54034: PPUSH
54035: CALL 104049 0 2
54039: OR
54040: IFFALSE 54044
// continue ;
54042: GO 53896
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54044: LD_EXP 135
54048: PUSH
54049: LD_VAR 0 2
54053: ARRAY
54054: PUSH
54055: LD_EXP 134
54059: PUSH
54060: LD_VAR 0 2
54064: ARRAY
54065: LESS
54066: PUSH
54067: LD_EXP 135
54071: PUSH
54072: LD_VAR 0 2
54076: ARRAY
54077: PUSH
54078: LD_VAR 0 8
54082: LESS
54083: AND
54084: IFFALSE 54499
// begin tmp := sci [ 1 ] ;
54086: LD_ADDR_VAR 0 7
54090: PUSH
54091: LD_VAR 0 9
54095: PUSH
54096: LD_INT 1
54098: ARRAY
54099: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54100: LD_VAR 0 7
54104: PPUSH
54105: LD_INT 124
54107: PPUSH
54108: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54112: LD_ADDR_VAR 0 3
54116: PUSH
54117: DOUBLE
54118: LD_EXP 134
54122: PUSH
54123: LD_VAR 0 2
54127: ARRAY
54128: INC
54129: ST_TO_ADDR
54130: LD_EXP 134
54134: PUSH
54135: LD_VAR 0 2
54139: ARRAY
54140: PUSH
54141: FOR_DOWNTO
54142: IFFALSE 54485
// begin if IsInUnit ( tmp ) then
54144: LD_VAR 0 7
54148: PPUSH
54149: CALL_OW 310
54153: IFFALSE 54164
// ComExitBuilding ( tmp ) ;
54155: LD_VAR 0 7
54159: PPUSH
54160: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54164: LD_INT 35
54166: PPUSH
54167: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54171: LD_VAR 0 7
54175: PPUSH
54176: CALL_OW 310
54180: NOT
54181: PUSH
54182: LD_VAR 0 7
54186: PPUSH
54187: CALL_OW 314
54191: NOT
54192: AND
54193: IFFALSE 54164
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54195: LD_ADDR_VAR 0 6
54199: PUSH
54200: LD_VAR 0 7
54204: PPUSH
54205: CALL_OW 250
54209: PUSH
54210: LD_VAR 0 7
54214: PPUSH
54215: CALL_OW 251
54219: PUSH
54220: EMPTY
54221: LIST
54222: LIST
54223: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54224: LD_INT 35
54226: PPUSH
54227: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54231: LD_ADDR_VAR 0 4
54235: PUSH
54236: LD_EXP 134
54240: PUSH
54241: LD_VAR 0 2
54245: ARRAY
54246: PUSH
54247: LD_VAR 0 3
54251: ARRAY
54252: PUSH
54253: LD_INT 1
54255: ARRAY
54256: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54257: LD_ADDR_VAR 0 5
54261: PUSH
54262: LD_EXP 134
54266: PUSH
54267: LD_VAR 0 2
54271: ARRAY
54272: PUSH
54273: LD_VAR 0 3
54277: ARRAY
54278: PUSH
54279: LD_INT 2
54281: ARRAY
54282: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54283: LD_VAR 0 7
54287: PPUSH
54288: LD_INT 10
54290: PPUSH
54291: CALL 73382 0 2
54295: PUSH
54296: LD_INT 4
54298: ARRAY
54299: IFFALSE 54337
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54301: LD_VAR 0 7
54305: PPUSH
54306: LD_VAR 0 6
54310: PUSH
54311: LD_INT 1
54313: ARRAY
54314: PPUSH
54315: LD_VAR 0 6
54319: PUSH
54320: LD_INT 2
54322: ARRAY
54323: PPUSH
54324: CALL_OW 111
// wait ( 0 0$10 ) ;
54328: LD_INT 350
54330: PPUSH
54331: CALL_OW 67
// end else
54335: GO 54363
// begin ComMoveXY ( tmp , x , y ) ;
54337: LD_VAR 0 7
54341: PPUSH
54342: LD_VAR 0 4
54346: PPUSH
54347: LD_VAR 0 5
54351: PPUSH
54352: CALL_OW 111
// wait ( 0 0$3 ) ;
54356: LD_INT 105
54358: PPUSH
54359: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54363: LD_VAR 0 7
54367: PPUSH
54368: LD_VAR 0 4
54372: PPUSH
54373: LD_VAR 0 5
54377: PPUSH
54378: CALL_OW 307
54382: IFFALSE 54224
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54384: LD_VAR 0 7
54388: PPUSH
54389: LD_VAR 0 4
54393: PPUSH
54394: LD_VAR 0 5
54398: PPUSH
54399: LD_VAR 0 8
54403: PUSH
54404: LD_VAR 0 3
54408: ARRAY
54409: PPUSH
54410: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54414: LD_INT 35
54416: PPUSH
54417: CALL_OW 67
// until not HasTask ( tmp ) ;
54421: LD_VAR 0 7
54425: PPUSH
54426: CALL_OW 314
54430: NOT
54431: IFFALSE 54414
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54433: LD_ADDR_EXP 135
54437: PUSH
54438: LD_EXP 135
54442: PPUSH
54443: LD_VAR 0 2
54447: PUSH
54448: LD_EXP 135
54452: PUSH
54453: LD_VAR 0 2
54457: ARRAY
54458: PUSH
54459: LD_INT 1
54461: PLUS
54462: PUSH
54463: EMPTY
54464: LIST
54465: LIST
54466: PPUSH
54467: LD_VAR 0 8
54471: PUSH
54472: LD_VAR 0 3
54476: ARRAY
54477: PPUSH
54478: CALL 70789 0 3
54482: ST_TO_ADDR
// end ;
54483: GO 54141
54485: POP
54486: POP
// MC_Reset ( i , 124 ) ;
54487: LD_VAR 0 2
54491: PPUSH
54492: LD_INT 124
54494: PPUSH
54495: CALL 37986 0 2
// end ; end ;
54499: GO 53896
54501: POP
54502: POP
// end ;
54503: LD_VAR 0 1
54507: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54508: LD_INT 0
54510: PPUSH
54511: PPUSH
54512: PPUSH
// if not mc_bases then
54513: LD_EXP 99
54517: NOT
54518: IFFALSE 54522
// exit ;
54520: GO 55128
// for i = 1 to mc_bases do
54522: LD_ADDR_VAR 0 2
54526: PUSH
54527: DOUBLE
54528: LD_INT 1
54530: DEC
54531: ST_TO_ADDR
54532: LD_EXP 99
54536: PUSH
54537: FOR_TO
54538: IFFALSE 55126
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54540: LD_ADDR_VAR 0 3
54544: PUSH
54545: LD_EXP 99
54549: PUSH
54550: LD_VAR 0 2
54554: ARRAY
54555: PPUSH
54556: LD_INT 25
54558: PUSH
54559: LD_INT 4
54561: PUSH
54562: EMPTY
54563: LIST
54564: LIST
54565: PPUSH
54566: CALL_OW 72
54570: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54571: LD_VAR 0 3
54575: NOT
54576: PUSH
54577: LD_EXP 136
54581: PUSH
54582: LD_VAR 0 2
54586: ARRAY
54587: NOT
54588: OR
54589: PUSH
54590: LD_EXP 99
54594: PUSH
54595: LD_VAR 0 2
54599: ARRAY
54600: PPUSH
54601: LD_INT 2
54603: PUSH
54604: LD_INT 30
54606: PUSH
54607: LD_INT 0
54609: PUSH
54610: EMPTY
54611: LIST
54612: LIST
54613: PUSH
54614: LD_INT 30
54616: PUSH
54617: LD_INT 1
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: PUSH
54624: EMPTY
54625: LIST
54626: LIST
54627: LIST
54628: PPUSH
54629: CALL_OW 72
54633: NOT
54634: OR
54635: IFFALSE 54685
// begin if mc_deposits_finder [ i ] then
54637: LD_EXP 137
54641: PUSH
54642: LD_VAR 0 2
54646: ARRAY
54647: IFFALSE 54683
// begin MC_Reset ( i , 125 ) ;
54649: LD_VAR 0 2
54653: PPUSH
54654: LD_INT 125
54656: PPUSH
54657: CALL 37986 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54661: LD_ADDR_EXP 137
54665: PUSH
54666: LD_EXP 137
54670: PPUSH
54671: LD_VAR 0 2
54675: PPUSH
54676: EMPTY
54677: PPUSH
54678: CALL_OW 1
54682: ST_TO_ADDR
// end ; continue ;
54683: GO 54537
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54685: LD_EXP 136
54689: PUSH
54690: LD_VAR 0 2
54694: ARRAY
54695: PUSH
54696: LD_INT 1
54698: ARRAY
54699: PUSH
54700: LD_INT 3
54702: ARRAY
54703: PUSH
54704: LD_INT 1
54706: EQUAL
54707: PUSH
54708: LD_INT 20
54710: PPUSH
54711: LD_EXP 125
54715: PUSH
54716: LD_VAR 0 2
54720: ARRAY
54721: PPUSH
54722: CALL_OW 321
54726: PUSH
54727: LD_INT 2
54729: NONEQUAL
54730: AND
54731: IFFALSE 54781
// begin if mc_deposits_finder [ i ] then
54733: LD_EXP 137
54737: PUSH
54738: LD_VAR 0 2
54742: ARRAY
54743: IFFALSE 54779
// begin MC_Reset ( i , 125 ) ;
54745: LD_VAR 0 2
54749: PPUSH
54750: LD_INT 125
54752: PPUSH
54753: CALL 37986 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54757: LD_ADDR_EXP 137
54761: PUSH
54762: LD_EXP 137
54766: PPUSH
54767: LD_VAR 0 2
54771: PPUSH
54772: EMPTY
54773: PPUSH
54774: CALL_OW 1
54778: ST_TO_ADDR
// end ; continue ;
54779: GO 54537
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54781: LD_EXP 136
54785: PUSH
54786: LD_VAR 0 2
54790: ARRAY
54791: PUSH
54792: LD_INT 1
54794: ARRAY
54795: PUSH
54796: LD_INT 1
54798: ARRAY
54799: PPUSH
54800: LD_EXP 136
54804: PUSH
54805: LD_VAR 0 2
54809: ARRAY
54810: PUSH
54811: LD_INT 1
54813: ARRAY
54814: PUSH
54815: LD_INT 2
54817: ARRAY
54818: PPUSH
54819: LD_EXP 125
54823: PUSH
54824: LD_VAR 0 2
54828: ARRAY
54829: PPUSH
54830: CALL_OW 440
54834: IFFALSE 54877
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54836: LD_ADDR_EXP 136
54840: PUSH
54841: LD_EXP 136
54845: PPUSH
54846: LD_VAR 0 2
54850: PPUSH
54851: LD_EXP 136
54855: PUSH
54856: LD_VAR 0 2
54860: ARRAY
54861: PPUSH
54862: LD_INT 1
54864: PPUSH
54865: CALL_OW 3
54869: PPUSH
54870: CALL_OW 1
54874: ST_TO_ADDR
54875: GO 55124
// begin if not mc_deposits_finder [ i ] then
54877: LD_EXP 137
54881: PUSH
54882: LD_VAR 0 2
54886: ARRAY
54887: NOT
54888: IFFALSE 54940
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54890: LD_ADDR_EXP 137
54894: PUSH
54895: LD_EXP 137
54899: PPUSH
54900: LD_VAR 0 2
54904: PPUSH
54905: LD_VAR 0 3
54909: PUSH
54910: LD_INT 1
54912: ARRAY
54913: PUSH
54914: EMPTY
54915: LIST
54916: PPUSH
54917: CALL_OW 1
54921: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54922: LD_VAR 0 3
54926: PUSH
54927: LD_INT 1
54929: ARRAY
54930: PPUSH
54931: LD_INT 125
54933: PPUSH
54934: CALL_OW 109
// end else
54938: GO 55124
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54940: LD_EXP 137
54944: PUSH
54945: LD_VAR 0 2
54949: ARRAY
54950: PUSH
54951: LD_INT 1
54953: ARRAY
54954: PPUSH
54955: CALL_OW 310
54959: IFFALSE 54982
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54961: LD_EXP 137
54965: PUSH
54966: LD_VAR 0 2
54970: ARRAY
54971: PUSH
54972: LD_INT 1
54974: ARRAY
54975: PPUSH
54976: CALL_OW 122
54980: GO 55124
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
54982: LD_EXP 137
54986: PUSH
54987: LD_VAR 0 2
54991: ARRAY
54992: PUSH
54993: LD_INT 1
54995: ARRAY
54996: PPUSH
54997: CALL_OW 314
55001: NOT
55002: PUSH
55003: LD_EXP 137
55007: PUSH
55008: LD_VAR 0 2
55012: ARRAY
55013: PUSH
55014: LD_INT 1
55016: ARRAY
55017: PPUSH
55018: LD_EXP 136
55022: PUSH
55023: LD_VAR 0 2
55027: ARRAY
55028: PUSH
55029: LD_INT 1
55031: ARRAY
55032: PUSH
55033: LD_INT 1
55035: ARRAY
55036: PPUSH
55037: LD_EXP 136
55041: PUSH
55042: LD_VAR 0 2
55046: ARRAY
55047: PUSH
55048: LD_INT 1
55050: ARRAY
55051: PUSH
55052: LD_INT 2
55054: ARRAY
55055: PPUSH
55056: CALL_OW 297
55060: PUSH
55061: LD_INT 6
55063: GREATER
55064: AND
55065: IFFALSE 55124
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55067: LD_EXP 137
55071: PUSH
55072: LD_VAR 0 2
55076: ARRAY
55077: PUSH
55078: LD_INT 1
55080: ARRAY
55081: PPUSH
55082: LD_EXP 136
55086: PUSH
55087: LD_VAR 0 2
55091: ARRAY
55092: PUSH
55093: LD_INT 1
55095: ARRAY
55096: PUSH
55097: LD_INT 1
55099: ARRAY
55100: PPUSH
55101: LD_EXP 136
55105: PUSH
55106: LD_VAR 0 2
55110: ARRAY
55111: PUSH
55112: LD_INT 1
55114: ARRAY
55115: PUSH
55116: LD_INT 2
55118: ARRAY
55119: PPUSH
55120: CALL_OW 111
// end ; end ; end ;
55124: GO 54537
55126: POP
55127: POP
// end ;
55128: LD_VAR 0 1
55132: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55133: LD_INT 0
55135: PPUSH
55136: PPUSH
55137: PPUSH
55138: PPUSH
55139: PPUSH
55140: PPUSH
55141: PPUSH
55142: PPUSH
55143: PPUSH
55144: PPUSH
55145: PPUSH
// if not mc_bases then
55146: LD_EXP 99
55150: NOT
55151: IFFALSE 55155
// exit ;
55153: GO 55879
// for i = 1 to mc_bases do
55155: LD_ADDR_VAR 0 2
55159: PUSH
55160: DOUBLE
55161: LD_INT 1
55163: DEC
55164: ST_TO_ADDR
55165: LD_EXP 99
55169: PUSH
55170: FOR_TO
55171: IFFALSE 55877
// begin if not mc_bases [ i ] then
55173: LD_EXP 99
55177: PUSH
55178: LD_VAR 0 2
55182: ARRAY
55183: NOT
55184: IFFALSE 55188
// continue ;
55186: GO 55170
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55188: LD_ADDR_VAR 0 7
55192: PUSH
55193: LD_EXP 99
55197: PUSH
55198: LD_VAR 0 2
55202: ARRAY
55203: PUSH
55204: LD_INT 1
55206: ARRAY
55207: PPUSH
55208: CALL_OW 248
55212: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55213: LD_VAR 0 7
55217: PUSH
55218: LD_INT 3
55220: EQUAL
55221: PUSH
55222: LD_EXP 118
55226: PUSH
55227: LD_VAR 0 2
55231: ARRAY
55232: PUSH
55233: LD_EXP 121
55237: PUSH
55238: LD_VAR 0 2
55242: ARRAY
55243: UNION
55244: PPUSH
55245: LD_INT 33
55247: PUSH
55248: LD_INT 2
55250: PUSH
55251: EMPTY
55252: LIST
55253: LIST
55254: PPUSH
55255: CALL_OW 72
55259: NOT
55260: OR
55261: IFFALSE 55265
// continue ;
55263: GO 55170
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55265: LD_ADDR_VAR 0 9
55269: PUSH
55270: LD_EXP 99
55274: PUSH
55275: LD_VAR 0 2
55279: ARRAY
55280: PPUSH
55281: LD_INT 30
55283: PUSH
55284: LD_INT 36
55286: PUSH
55287: EMPTY
55288: LIST
55289: LIST
55290: PPUSH
55291: CALL_OW 72
55295: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55296: LD_ADDR_VAR 0 10
55300: PUSH
55301: LD_EXP 118
55305: PUSH
55306: LD_VAR 0 2
55310: ARRAY
55311: PPUSH
55312: LD_INT 34
55314: PUSH
55315: LD_INT 31
55317: PUSH
55318: EMPTY
55319: LIST
55320: LIST
55321: PPUSH
55322: CALL_OW 72
55326: ST_TO_ADDR
// if not cts and not mcts then
55327: LD_VAR 0 9
55331: NOT
55332: PUSH
55333: LD_VAR 0 10
55337: NOT
55338: AND
55339: IFFALSE 55343
// continue ;
55341: GO 55170
// x := cts ;
55343: LD_ADDR_VAR 0 11
55347: PUSH
55348: LD_VAR 0 9
55352: ST_TO_ADDR
// if not x then
55353: LD_VAR 0 11
55357: NOT
55358: IFFALSE 55370
// x := mcts ;
55360: LD_ADDR_VAR 0 11
55364: PUSH
55365: LD_VAR 0 10
55369: ST_TO_ADDR
// if mc_remote_driver [ i ] then
55370: LD_EXP 139
55374: PUSH
55375: LD_VAR 0 2
55379: ARRAY
55380: IFFALSE 55649
// for j in mc_remote_driver [ i ] do
55382: LD_ADDR_VAR 0 3
55386: PUSH
55387: LD_EXP 139
55391: PUSH
55392: LD_VAR 0 2
55396: ARRAY
55397: PUSH
55398: FOR_IN
55399: IFFALSE 55647
// begin if GetClass ( j ) <> 3 then
55401: LD_VAR 0 3
55405: PPUSH
55406: CALL_OW 257
55410: PUSH
55411: LD_INT 3
55413: NONEQUAL
55414: IFFALSE 55467
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55416: LD_ADDR_EXP 139
55420: PUSH
55421: LD_EXP 139
55425: PPUSH
55426: LD_VAR 0 2
55430: PPUSH
55431: LD_EXP 139
55435: PUSH
55436: LD_VAR 0 2
55440: ARRAY
55441: PUSH
55442: LD_VAR 0 3
55446: DIFF
55447: PPUSH
55448: CALL_OW 1
55452: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55453: LD_VAR 0 3
55457: PPUSH
55458: LD_INT 0
55460: PPUSH
55461: CALL_OW 109
// continue ;
55465: GO 55398
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55467: LD_VAR 0 3
55471: PPUSH
55472: CALL_OW 310
55476: NOT
55477: PUSH
55478: LD_VAR 0 3
55482: PPUSH
55483: CALL_OW 310
55487: PPUSH
55488: CALL_OW 266
55492: PUSH
55493: LD_INT 36
55495: NONEQUAL
55496: PUSH
55497: LD_VAR 0 3
55501: PPUSH
55502: CALL 104137 0 1
55506: NOT
55507: AND
55508: OR
55509: IFFALSE 55645
// begin if IsInUnit ( j ) then
55511: LD_VAR 0 3
55515: PPUSH
55516: CALL_OW 310
55520: IFFALSE 55531
// ComExitBuilding ( j ) ;
55522: LD_VAR 0 3
55526: PPUSH
55527: CALL_OW 122
// ct := 0 ;
55531: LD_ADDR_VAR 0 8
55535: PUSH
55536: LD_INT 0
55538: ST_TO_ADDR
// for k in x do
55539: LD_ADDR_VAR 0 4
55543: PUSH
55544: LD_VAR 0 11
55548: PUSH
55549: FOR_IN
55550: IFFALSE 55623
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55552: LD_VAR 0 4
55556: PPUSH
55557: CALL_OW 264
55561: PUSH
55562: LD_INT 31
55564: EQUAL
55565: PUSH
55566: LD_VAR 0 4
55570: PPUSH
55571: CALL_OW 311
55575: NOT
55576: AND
55577: PUSH
55578: LD_VAR 0 4
55582: PPUSH
55583: CALL_OW 266
55587: PUSH
55588: LD_INT 36
55590: EQUAL
55591: PUSH
55592: LD_VAR 0 4
55596: PPUSH
55597: CALL_OW 313
55601: PUSH
55602: LD_INT 3
55604: LESS
55605: AND
55606: OR
55607: IFFALSE 55621
// begin ct := k ;
55609: LD_ADDR_VAR 0 8
55613: PUSH
55614: LD_VAR 0 4
55618: ST_TO_ADDR
// break ;
55619: GO 55623
// end ;
55621: GO 55549
55623: POP
55624: POP
// if ct then
55625: LD_VAR 0 8
55629: IFFALSE 55645
// ComEnterUnit ( j , ct ) ;
55631: LD_VAR 0 3
55635: PPUSH
55636: LD_VAR 0 8
55640: PPUSH
55641: CALL_OW 120
// end ; end ;
55645: GO 55398
55647: POP
55648: POP
// places := 0 ;
55649: LD_ADDR_VAR 0 5
55653: PUSH
55654: LD_INT 0
55656: ST_TO_ADDR
// for j = 1 to x do
55657: LD_ADDR_VAR 0 3
55661: PUSH
55662: DOUBLE
55663: LD_INT 1
55665: DEC
55666: ST_TO_ADDR
55667: LD_VAR 0 11
55671: PUSH
55672: FOR_TO
55673: IFFALSE 55728
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55675: LD_VAR 0 11
55679: PUSH
55680: LD_VAR 0 3
55684: ARRAY
55685: PPUSH
55686: CALL_OW 264
55690: PUSH
55691: LD_INT 31
55693: EQUAL
55694: IFFALSE 55712
// places := places + 1 else
55696: LD_ADDR_VAR 0 5
55700: PUSH
55701: LD_VAR 0 5
55705: PUSH
55706: LD_INT 1
55708: PLUS
55709: ST_TO_ADDR
55710: GO 55726
// places := places + 3 ;
55712: LD_ADDR_VAR 0 5
55716: PUSH
55717: LD_VAR 0 5
55721: PUSH
55722: LD_INT 3
55724: PLUS
55725: ST_TO_ADDR
55726: GO 55672
55728: POP
55729: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55730: LD_ADDR_VAR 0 6
55734: PUSH
55735: LD_EXP 99
55739: PUSH
55740: LD_VAR 0 2
55744: ARRAY
55745: PPUSH
55746: LD_INT 25
55748: PUSH
55749: LD_INT 3
55751: PUSH
55752: EMPTY
55753: LIST
55754: LIST
55755: PPUSH
55756: CALL_OW 72
55760: PUSH
55761: LD_EXP 139
55765: PUSH
55766: LD_VAR 0 2
55770: ARRAY
55771: DIFF
55772: PPUSH
55773: LD_INT 3
55775: PPUSH
55776: CALL 105037 0 2
55780: ST_TO_ADDR
// if not tmp then
55781: LD_VAR 0 6
55785: NOT
55786: IFFALSE 55790
// continue ;
55788: GO 55170
// places := places - mc_remote_driver [ i ] ;
55790: LD_ADDR_VAR 0 5
55794: PUSH
55795: LD_VAR 0 5
55799: PUSH
55800: LD_EXP 139
55804: PUSH
55805: LD_VAR 0 2
55809: ARRAY
55810: MINUS
55811: ST_TO_ADDR
// if places then
55812: LD_VAR 0 5
55816: IFFALSE 55875
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
55818: LD_ADDR_EXP 139
55822: PUSH
55823: LD_EXP 139
55827: PPUSH
55828: LD_VAR 0 2
55832: PPUSH
55833: LD_EXP 139
55837: PUSH
55838: LD_VAR 0 2
55842: ARRAY
55843: PUSH
55844: LD_VAR 0 6
55848: PUSH
55849: LD_INT 1
55851: ARRAY
55852: UNION
55853: PPUSH
55854: CALL_OW 1
55858: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
55859: LD_VAR 0 6
55863: PUSH
55864: LD_INT 1
55866: ARRAY
55867: PPUSH
55868: LD_INT 126
55870: PPUSH
55871: CALL_OW 109
// end ; end ;
55875: GO 55170
55877: POP
55878: POP
// end ;
55879: LD_VAR 0 1
55883: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
55884: LD_INT 0
55886: PPUSH
55887: PPUSH
55888: PPUSH
55889: PPUSH
55890: PPUSH
55891: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
55892: LD_VAR 0 1
55896: NOT
55897: PUSH
55898: LD_VAR 0 2
55902: NOT
55903: OR
55904: PUSH
55905: LD_VAR 0 3
55909: NOT
55910: OR
55911: PUSH
55912: LD_VAR 0 4
55916: PUSH
55917: LD_INT 1
55919: PUSH
55920: LD_INT 2
55922: PUSH
55923: LD_INT 3
55925: PUSH
55926: LD_INT 4
55928: PUSH
55929: LD_INT 5
55931: PUSH
55932: LD_INT 8
55934: PUSH
55935: LD_INT 9
55937: PUSH
55938: LD_INT 15
55940: PUSH
55941: LD_INT 16
55943: PUSH
55944: EMPTY
55945: LIST
55946: LIST
55947: LIST
55948: LIST
55949: LIST
55950: LIST
55951: LIST
55952: LIST
55953: LIST
55954: IN
55955: NOT
55956: OR
55957: IFFALSE 55961
// exit ;
55959: GO 56861
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
55961: LD_ADDR_VAR 0 2
55965: PUSH
55966: LD_VAR 0 2
55970: PPUSH
55971: LD_INT 21
55973: PUSH
55974: LD_INT 3
55976: PUSH
55977: EMPTY
55978: LIST
55979: LIST
55980: PUSH
55981: LD_INT 24
55983: PUSH
55984: LD_INT 250
55986: PUSH
55987: EMPTY
55988: LIST
55989: LIST
55990: PUSH
55991: EMPTY
55992: LIST
55993: LIST
55994: PPUSH
55995: CALL_OW 72
55999: ST_TO_ADDR
// case class of 1 , 15 :
56000: LD_VAR 0 4
56004: PUSH
56005: LD_INT 1
56007: DOUBLE
56008: EQUAL
56009: IFTRUE 56019
56011: LD_INT 15
56013: DOUBLE
56014: EQUAL
56015: IFTRUE 56019
56017: GO 56104
56019: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56020: LD_ADDR_VAR 0 8
56024: PUSH
56025: LD_VAR 0 2
56029: PPUSH
56030: LD_INT 2
56032: PUSH
56033: LD_INT 30
56035: PUSH
56036: LD_INT 32
56038: PUSH
56039: EMPTY
56040: LIST
56041: LIST
56042: PUSH
56043: LD_INT 30
56045: PUSH
56046: LD_INT 31
56048: PUSH
56049: EMPTY
56050: LIST
56051: LIST
56052: PUSH
56053: EMPTY
56054: LIST
56055: LIST
56056: LIST
56057: PPUSH
56058: CALL_OW 72
56062: PUSH
56063: LD_VAR 0 2
56067: PPUSH
56068: LD_INT 2
56070: PUSH
56071: LD_INT 30
56073: PUSH
56074: LD_INT 4
56076: PUSH
56077: EMPTY
56078: LIST
56079: LIST
56080: PUSH
56081: LD_INT 30
56083: PUSH
56084: LD_INT 5
56086: PUSH
56087: EMPTY
56088: LIST
56089: LIST
56090: PUSH
56091: EMPTY
56092: LIST
56093: LIST
56094: LIST
56095: PPUSH
56096: CALL_OW 72
56100: ADD
56101: ST_TO_ADDR
56102: GO 56350
56104: LD_INT 2
56106: DOUBLE
56107: EQUAL
56108: IFTRUE 56118
56110: LD_INT 16
56112: DOUBLE
56113: EQUAL
56114: IFTRUE 56118
56116: GO 56164
56118: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56119: LD_ADDR_VAR 0 8
56123: PUSH
56124: LD_VAR 0 2
56128: PPUSH
56129: LD_INT 2
56131: PUSH
56132: LD_INT 30
56134: PUSH
56135: LD_INT 0
56137: PUSH
56138: EMPTY
56139: LIST
56140: LIST
56141: PUSH
56142: LD_INT 30
56144: PUSH
56145: LD_INT 1
56147: PUSH
56148: EMPTY
56149: LIST
56150: LIST
56151: PUSH
56152: EMPTY
56153: LIST
56154: LIST
56155: LIST
56156: PPUSH
56157: CALL_OW 72
56161: ST_TO_ADDR
56162: GO 56350
56164: LD_INT 3
56166: DOUBLE
56167: EQUAL
56168: IFTRUE 56172
56170: GO 56218
56172: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56173: LD_ADDR_VAR 0 8
56177: PUSH
56178: LD_VAR 0 2
56182: PPUSH
56183: LD_INT 2
56185: PUSH
56186: LD_INT 30
56188: PUSH
56189: LD_INT 2
56191: PUSH
56192: EMPTY
56193: LIST
56194: LIST
56195: PUSH
56196: LD_INT 30
56198: PUSH
56199: LD_INT 3
56201: PUSH
56202: EMPTY
56203: LIST
56204: LIST
56205: PUSH
56206: EMPTY
56207: LIST
56208: LIST
56209: LIST
56210: PPUSH
56211: CALL_OW 72
56215: ST_TO_ADDR
56216: GO 56350
56218: LD_INT 4
56220: DOUBLE
56221: EQUAL
56222: IFTRUE 56226
56224: GO 56283
56226: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56227: LD_ADDR_VAR 0 8
56231: PUSH
56232: LD_VAR 0 2
56236: PPUSH
56237: LD_INT 2
56239: PUSH
56240: LD_INT 30
56242: PUSH
56243: LD_INT 6
56245: PUSH
56246: EMPTY
56247: LIST
56248: LIST
56249: PUSH
56250: LD_INT 30
56252: PUSH
56253: LD_INT 7
56255: PUSH
56256: EMPTY
56257: LIST
56258: LIST
56259: PUSH
56260: LD_INT 30
56262: PUSH
56263: LD_INT 8
56265: PUSH
56266: EMPTY
56267: LIST
56268: LIST
56269: PUSH
56270: EMPTY
56271: LIST
56272: LIST
56273: LIST
56274: LIST
56275: PPUSH
56276: CALL_OW 72
56280: ST_TO_ADDR
56281: GO 56350
56283: LD_INT 5
56285: DOUBLE
56286: EQUAL
56287: IFTRUE 56303
56289: LD_INT 8
56291: DOUBLE
56292: EQUAL
56293: IFTRUE 56303
56295: LD_INT 9
56297: DOUBLE
56298: EQUAL
56299: IFTRUE 56303
56301: GO 56349
56303: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56304: LD_ADDR_VAR 0 8
56308: PUSH
56309: LD_VAR 0 2
56313: PPUSH
56314: LD_INT 2
56316: PUSH
56317: LD_INT 30
56319: PUSH
56320: LD_INT 4
56322: PUSH
56323: EMPTY
56324: LIST
56325: LIST
56326: PUSH
56327: LD_INT 30
56329: PUSH
56330: LD_INT 5
56332: PUSH
56333: EMPTY
56334: LIST
56335: LIST
56336: PUSH
56337: EMPTY
56338: LIST
56339: LIST
56340: LIST
56341: PPUSH
56342: CALL_OW 72
56346: ST_TO_ADDR
56347: GO 56350
56349: POP
// if not tmp then
56350: LD_VAR 0 8
56354: NOT
56355: IFFALSE 56359
// exit ;
56357: GO 56861
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56359: LD_VAR 0 4
56363: PUSH
56364: LD_INT 1
56366: PUSH
56367: LD_INT 15
56369: PUSH
56370: EMPTY
56371: LIST
56372: LIST
56373: IN
56374: PUSH
56375: LD_EXP 108
56379: PUSH
56380: LD_VAR 0 1
56384: ARRAY
56385: AND
56386: IFFALSE 56542
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56388: LD_ADDR_VAR 0 9
56392: PUSH
56393: LD_EXP 108
56397: PUSH
56398: LD_VAR 0 1
56402: ARRAY
56403: PUSH
56404: LD_INT 1
56406: ARRAY
56407: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56408: LD_VAR 0 9
56412: PUSH
56413: LD_EXP 109
56417: PUSH
56418: LD_VAR 0 1
56422: ARRAY
56423: IN
56424: NOT
56425: IFFALSE 56540
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56427: LD_ADDR_EXP 109
56431: PUSH
56432: LD_EXP 109
56436: PPUSH
56437: LD_VAR 0 1
56441: PUSH
56442: LD_EXP 109
56446: PUSH
56447: LD_VAR 0 1
56451: ARRAY
56452: PUSH
56453: LD_INT 1
56455: PLUS
56456: PUSH
56457: EMPTY
56458: LIST
56459: LIST
56460: PPUSH
56461: LD_VAR 0 9
56465: PPUSH
56466: CALL 70789 0 3
56470: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
56471: LD_ADDR_EXP 108
56475: PUSH
56476: LD_EXP 108
56480: PPUSH
56481: LD_VAR 0 1
56485: PPUSH
56486: LD_EXP 108
56490: PUSH
56491: LD_VAR 0 1
56495: ARRAY
56496: PUSH
56497: LD_VAR 0 9
56501: DIFF
56502: PPUSH
56503: CALL_OW 1
56507: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
56508: LD_VAR 0 3
56512: PPUSH
56513: LD_EXP 109
56517: PUSH
56518: LD_VAR 0 1
56522: ARRAY
56523: PUSH
56524: LD_EXP 109
56528: PUSH
56529: LD_VAR 0 1
56533: ARRAY
56534: ARRAY
56535: PPUSH
56536: CALL_OW 120
// end ; exit ;
56540: GO 56861
// end ; if tmp > 1 then
56542: LD_VAR 0 8
56546: PUSH
56547: LD_INT 1
56549: GREATER
56550: IFFALSE 56654
// for i = 2 to tmp do
56552: LD_ADDR_VAR 0 6
56556: PUSH
56557: DOUBLE
56558: LD_INT 2
56560: DEC
56561: ST_TO_ADDR
56562: LD_VAR 0 8
56566: PUSH
56567: FOR_TO
56568: IFFALSE 56652
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56570: LD_VAR 0 8
56574: PUSH
56575: LD_VAR 0 6
56579: ARRAY
56580: PPUSH
56581: CALL_OW 461
56585: PUSH
56586: LD_INT 6
56588: EQUAL
56589: IFFALSE 56650
// begin x := tmp [ i ] ;
56591: LD_ADDR_VAR 0 9
56595: PUSH
56596: LD_VAR 0 8
56600: PUSH
56601: LD_VAR 0 6
56605: ARRAY
56606: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56607: LD_ADDR_VAR 0 8
56611: PUSH
56612: LD_VAR 0 8
56616: PPUSH
56617: LD_VAR 0 6
56621: PPUSH
56622: CALL_OW 3
56626: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56627: LD_ADDR_VAR 0 8
56631: PUSH
56632: LD_VAR 0 8
56636: PPUSH
56637: LD_INT 1
56639: PPUSH
56640: LD_VAR 0 9
56644: PPUSH
56645: CALL_OW 2
56649: ST_TO_ADDR
// end ;
56650: GO 56567
56652: POP
56653: POP
// for i in tmp do
56654: LD_ADDR_VAR 0 6
56658: PUSH
56659: LD_VAR 0 8
56663: PUSH
56664: FOR_IN
56665: IFFALSE 56734
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56667: LD_VAR 0 6
56671: PPUSH
56672: CALL_OW 313
56676: PUSH
56677: LD_INT 6
56679: LESS
56680: PUSH
56681: LD_VAR 0 6
56685: PPUSH
56686: CALL_OW 266
56690: PUSH
56691: LD_INT 31
56693: PUSH
56694: LD_INT 32
56696: PUSH
56697: EMPTY
56698: LIST
56699: LIST
56700: IN
56701: NOT
56702: AND
56703: PUSH
56704: LD_VAR 0 6
56708: PPUSH
56709: CALL_OW 313
56713: PUSH
56714: LD_INT 0
56716: EQUAL
56717: OR
56718: IFFALSE 56732
// begin j := i ;
56720: LD_ADDR_VAR 0 7
56724: PUSH
56725: LD_VAR 0 6
56729: ST_TO_ADDR
// break ;
56730: GO 56734
// end ; end ;
56732: GO 56664
56734: POP
56735: POP
// if j then
56736: LD_VAR 0 7
56740: IFFALSE 56758
// ComEnterUnit ( unit , j ) else
56742: LD_VAR 0 3
56746: PPUSH
56747: LD_VAR 0 7
56751: PPUSH
56752: CALL_OW 120
56756: GO 56861
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56758: LD_ADDR_VAR 0 10
56762: PUSH
56763: LD_VAR 0 2
56767: PPUSH
56768: LD_INT 2
56770: PUSH
56771: LD_INT 30
56773: PUSH
56774: LD_INT 0
56776: PUSH
56777: EMPTY
56778: LIST
56779: LIST
56780: PUSH
56781: LD_INT 30
56783: PUSH
56784: LD_INT 1
56786: PUSH
56787: EMPTY
56788: LIST
56789: LIST
56790: PUSH
56791: EMPTY
56792: LIST
56793: LIST
56794: LIST
56795: PPUSH
56796: CALL_OW 72
56800: ST_TO_ADDR
// if depot then
56801: LD_VAR 0 10
56805: IFFALSE 56861
// begin depot := NearestUnitToUnit ( depot , unit ) ;
56807: LD_ADDR_VAR 0 10
56811: PUSH
56812: LD_VAR 0 10
56816: PPUSH
56817: LD_VAR 0 3
56821: PPUSH
56822: CALL_OW 74
56826: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
56827: LD_VAR 0 3
56831: PPUSH
56832: LD_VAR 0 10
56836: PPUSH
56837: CALL_OW 296
56841: PUSH
56842: LD_INT 10
56844: GREATER
56845: IFFALSE 56861
// ComStandNearbyBuilding ( unit , depot ) ;
56847: LD_VAR 0 3
56851: PPUSH
56852: LD_VAR 0 10
56856: PPUSH
56857: CALL 65141 0 2
// end ; end ; end ;
56861: LD_VAR 0 5
56865: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
56866: LD_INT 0
56868: PPUSH
56869: PPUSH
56870: PPUSH
56871: PPUSH
// if not mc_bases then
56872: LD_EXP 99
56876: NOT
56877: IFFALSE 56881
// exit ;
56879: GO 57120
// for i = 1 to mc_bases do
56881: LD_ADDR_VAR 0 2
56885: PUSH
56886: DOUBLE
56887: LD_INT 1
56889: DEC
56890: ST_TO_ADDR
56891: LD_EXP 99
56895: PUSH
56896: FOR_TO
56897: IFFALSE 57118
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
56899: LD_ADDR_VAR 0 4
56903: PUSH
56904: LD_EXP 99
56908: PUSH
56909: LD_VAR 0 2
56913: ARRAY
56914: PPUSH
56915: LD_INT 21
56917: PUSH
56918: LD_INT 1
56920: PUSH
56921: EMPTY
56922: LIST
56923: LIST
56924: PPUSH
56925: CALL_OW 72
56929: PUSH
56930: LD_EXP 128
56934: PUSH
56935: LD_VAR 0 2
56939: ARRAY
56940: UNION
56941: ST_TO_ADDR
// if not tmp then
56942: LD_VAR 0 4
56946: NOT
56947: IFFALSE 56951
// continue ;
56949: GO 56896
// for j in tmp do
56951: LD_ADDR_VAR 0 3
56955: PUSH
56956: LD_VAR 0 4
56960: PUSH
56961: FOR_IN
56962: IFFALSE 57114
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
56964: LD_VAR 0 3
56968: PPUSH
56969: CALL_OW 110
56973: NOT
56974: PUSH
56975: LD_VAR 0 3
56979: PPUSH
56980: CALL_OW 314
56984: NOT
56985: AND
56986: PUSH
56987: LD_VAR 0 3
56991: PPUSH
56992: CALL_OW 311
56996: NOT
56997: AND
56998: PUSH
56999: LD_VAR 0 3
57003: PPUSH
57004: CALL_OW 310
57008: NOT
57009: AND
57010: PUSH
57011: LD_VAR 0 3
57015: PUSH
57016: LD_EXP 102
57020: PUSH
57021: LD_VAR 0 2
57025: ARRAY
57026: PUSH
57027: LD_INT 1
57029: ARRAY
57030: IN
57031: NOT
57032: AND
57033: PUSH
57034: LD_VAR 0 3
57038: PUSH
57039: LD_EXP 102
57043: PUSH
57044: LD_VAR 0 2
57048: ARRAY
57049: PUSH
57050: LD_INT 2
57052: ARRAY
57053: IN
57054: NOT
57055: AND
57056: PUSH
57057: LD_VAR 0 3
57061: PUSH
57062: LD_EXP 111
57066: PUSH
57067: LD_VAR 0 2
57071: ARRAY
57072: IN
57073: NOT
57074: AND
57075: IFFALSE 57112
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57077: LD_VAR 0 2
57081: PPUSH
57082: LD_EXP 99
57086: PUSH
57087: LD_VAR 0 2
57091: ARRAY
57092: PPUSH
57093: LD_VAR 0 3
57097: PPUSH
57098: LD_VAR 0 3
57102: PPUSH
57103: CALL_OW 257
57107: PPUSH
57108: CALL 55884 0 4
// end ;
57112: GO 56961
57114: POP
57115: POP
// end ;
57116: GO 56896
57118: POP
57119: POP
// end ;
57120: LD_VAR 0 1
57124: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57125: LD_INT 0
57127: PPUSH
57128: PPUSH
57129: PPUSH
57130: PPUSH
57131: PPUSH
57132: PPUSH
// if not mc_bases [ base ] then
57133: LD_EXP 99
57137: PUSH
57138: LD_VAR 0 1
57142: ARRAY
57143: NOT
57144: IFFALSE 57148
// exit ;
57146: GO 57330
// tmp := [ ] ;
57148: LD_ADDR_VAR 0 6
57152: PUSH
57153: EMPTY
57154: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57155: LD_ADDR_VAR 0 7
57159: PUSH
57160: LD_VAR 0 3
57164: PPUSH
57165: LD_INT 0
57167: PPUSH
57168: CALL_OW 517
57172: ST_TO_ADDR
// if not list then
57173: LD_VAR 0 7
57177: NOT
57178: IFFALSE 57182
// exit ;
57180: GO 57330
// for i = 1 to amount do
57182: LD_ADDR_VAR 0 5
57186: PUSH
57187: DOUBLE
57188: LD_INT 1
57190: DEC
57191: ST_TO_ADDR
57192: LD_VAR 0 2
57196: PUSH
57197: FOR_TO
57198: IFFALSE 57278
// begin x := rand ( 1 , list [ 1 ] ) ;
57200: LD_ADDR_VAR 0 8
57204: PUSH
57205: LD_INT 1
57207: PPUSH
57208: LD_VAR 0 7
57212: PUSH
57213: LD_INT 1
57215: ARRAY
57216: PPUSH
57217: CALL_OW 12
57221: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57222: LD_ADDR_VAR 0 6
57226: PUSH
57227: LD_VAR 0 6
57231: PPUSH
57232: LD_VAR 0 5
57236: PPUSH
57237: LD_VAR 0 7
57241: PUSH
57242: LD_INT 1
57244: ARRAY
57245: PUSH
57246: LD_VAR 0 8
57250: ARRAY
57251: PUSH
57252: LD_VAR 0 7
57256: PUSH
57257: LD_INT 2
57259: ARRAY
57260: PUSH
57261: LD_VAR 0 8
57265: ARRAY
57266: PUSH
57267: EMPTY
57268: LIST
57269: LIST
57270: PPUSH
57271: CALL_OW 1
57275: ST_TO_ADDR
// end ;
57276: GO 57197
57278: POP
57279: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57280: LD_ADDR_EXP 112
57284: PUSH
57285: LD_EXP 112
57289: PPUSH
57290: LD_VAR 0 1
57294: PPUSH
57295: LD_VAR 0 6
57299: PPUSH
57300: CALL_OW 1
57304: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57305: LD_ADDR_EXP 114
57309: PUSH
57310: LD_EXP 114
57314: PPUSH
57315: LD_VAR 0 1
57319: PPUSH
57320: LD_VAR 0 3
57324: PPUSH
57325: CALL_OW 1
57329: ST_TO_ADDR
// end ;
57330: LD_VAR 0 4
57334: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57335: LD_INT 0
57337: PPUSH
// if not mc_bases [ base ] then
57338: LD_EXP 99
57342: PUSH
57343: LD_VAR 0 1
57347: ARRAY
57348: NOT
57349: IFFALSE 57353
// exit ;
57351: GO 57378
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57353: LD_ADDR_EXP 104
57357: PUSH
57358: LD_EXP 104
57362: PPUSH
57363: LD_VAR 0 1
57367: PPUSH
57368: LD_VAR 0 2
57372: PPUSH
57373: CALL_OW 1
57377: ST_TO_ADDR
// end ;
57378: LD_VAR 0 3
57382: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57383: LD_INT 0
57385: PPUSH
// if not mc_bases [ base ] then
57386: LD_EXP 99
57390: PUSH
57391: LD_VAR 0 1
57395: ARRAY
57396: NOT
57397: IFFALSE 57401
// exit ;
57399: GO 57438
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57401: LD_ADDR_EXP 104
57405: PUSH
57406: LD_EXP 104
57410: PPUSH
57411: LD_VAR 0 1
57415: PPUSH
57416: LD_EXP 104
57420: PUSH
57421: LD_VAR 0 1
57425: ARRAY
57426: PUSH
57427: LD_VAR 0 2
57431: UNION
57432: PPUSH
57433: CALL_OW 1
57437: ST_TO_ADDR
// end ;
57438: LD_VAR 0 3
57442: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57443: LD_INT 0
57445: PPUSH
// if not mc_bases [ base ] then
57446: LD_EXP 99
57450: PUSH
57451: LD_VAR 0 1
57455: ARRAY
57456: NOT
57457: IFFALSE 57461
// exit ;
57459: GO 57486
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57461: LD_ADDR_EXP 120
57465: PUSH
57466: LD_EXP 120
57470: PPUSH
57471: LD_VAR 0 1
57475: PPUSH
57476: LD_VAR 0 2
57480: PPUSH
57481: CALL_OW 1
57485: ST_TO_ADDR
// end ;
57486: LD_VAR 0 3
57490: RET
// export function MC_InsertProduceList ( base , components ) ; begin
57491: LD_INT 0
57493: PPUSH
// if not mc_bases [ base ] then
57494: LD_EXP 99
57498: PUSH
57499: LD_VAR 0 1
57503: ARRAY
57504: NOT
57505: IFFALSE 57509
// exit ;
57507: GO 57546
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
57509: LD_ADDR_EXP 120
57513: PUSH
57514: LD_EXP 120
57518: PPUSH
57519: LD_VAR 0 1
57523: PPUSH
57524: LD_EXP 120
57528: PUSH
57529: LD_VAR 0 1
57533: ARRAY
57534: PUSH
57535: LD_VAR 0 2
57539: ADD
57540: PPUSH
57541: CALL_OW 1
57545: ST_TO_ADDR
// end ;
57546: LD_VAR 0 3
57550: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57551: LD_INT 0
57553: PPUSH
// if not mc_bases [ base ] then
57554: LD_EXP 99
57558: PUSH
57559: LD_VAR 0 1
57563: ARRAY
57564: NOT
57565: IFFALSE 57569
// exit ;
57567: GO 57623
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57569: LD_ADDR_EXP 121
57573: PUSH
57574: LD_EXP 121
57578: PPUSH
57579: LD_VAR 0 1
57583: PPUSH
57584: LD_VAR 0 2
57588: PPUSH
57589: CALL_OW 1
57593: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57594: LD_ADDR_EXP 110
57598: PUSH
57599: LD_EXP 110
57603: PPUSH
57604: LD_VAR 0 1
57608: PPUSH
57609: LD_VAR 0 2
57613: PUSH
57614: LD_INT 0
57616: PLUS
57617: PPUSH
57618: CALL_OW 1
57622: ST_TO_ADDR
// end ;
57623: LD_VAR 0 3
57627: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57628: LD_INT 0
57630: PPUSH
// if not mc_bases [ base ] then
57631: LD_EXP 99
57635: PUSH
57636: LD_VAR 0 1
57640: ARRAY
57641: NOT
57642: IFFALSE 57646
// exit ;
57644: GO 57671
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57646: LD_ADDR_EXP 110
57650: PUSH
57651: LD_EXP 110
57655: PPUSH
57656: LD_VAR 0 1
57660: PPUSH
57661: LD_VAR 0 2
57665: PPUSH
57666: CALL_OW 1
57670: ST_TO_ADDR
// end ;
57671: LD_VAR 0 3
57675: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57676: LD_INT 0
57678: PPUSH
57679: PPUSH
57680: PPUSH
57681: PPUSH
// if not mc_bases [ base ] then
57682: LD_EXP 99
57686: PUSH
57687: LD_VAR 0 1
57691: ARRAY
57692: NOT
57693: IFFALSE 57697
// exit ;
57695: GO 57762
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57697: LD_ADDR_EXP 119
57701: PUSH
57702: LD_EXP 119
57706: PPUSH
57707: LD_VAR 0 1
57711: PUSH
57712: LD_EXP 119
57716: PUSH
57717: LD_VAR 0 1
57721: ARRAY
57722: PUSH
57723: LD_INT 1
57725: PLUS
57726: PUSH
57727: EMPTY
57728: LIST
57729: LIST
57730: PPUSH
57731: LD_VAR 0 1
57735: PUSH
57736: LD_VAR 0 2
57740: PUSH
57741: LD_VAR 0 3
57745: PUSH
57746: LD_VAR 0 4
57750: PUSH
57751: EMPTY
57752: LIST
57753: LIST
57754: LIST
57755: LIST
57756: PPUSH
57757: CALL 70789 0 3
57761: ST_TO_ADDR
// end ;
57762: LD_VAR 0 5
57766: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
57767: LD_INT 0
57769: PPUSH
// if not mc_bases [ base ] then
57770: LD_EXP 99
57774: PUSH
57775: LD_VAR 0 1
57779: ARRAY
57780: NOT
57781: IFFALSE 57785
// exit ;
57783: GO 57810
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
57785: LD_ADDR_EXP 136
57789: PUSH
57790: LD_EXP 136
57794: PPUSH
57795: LD_VAR 0 1
57799: PPUSH
57800: LD_VAR 0 2
57804: PPUSH
57805: CALL_OW 1
57809: ST_TO_ADDR
// end ;
57810: LD_VAR 0 3
57814: RET
// export function MC_GetMinesField ( base ) ; begin
57815: LD_INT 0
57817: PPUSH
// result := mc_mines [ base ] ;
57818: LD_ADDR_VAR 0 2
57822: PUSH
57823: LD_EXP 112
57827: PUSH
57828: LD_VAR 0 1
57832: ARRAY
57833: ST_TO_ADDR
// end ;
57834: LD_VAR 0 2
57838: RET
// export function MC_GetProduceList ( base ) ; begin
57839: LD_INT 0
57841: PPUSH
// result := mc_produce [ base ] ;
57842: LD_ADDR_VAR 0 2
57846: PUSH
57847: LD_EXP 120
57851: PUSH
57852: LD_VAR 0 1
57856: ARRAY
57857: ST_TO_ADDR
// end ;
57858: LD_VAR 0 2
57862: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
57863: LD_INT 0
57865: PPUSH
57866: PPUSH
// if not mc_bases then
57867: LD_EXP 99
57871: NOT
57872: IFFALSE 57876
// exit ;
57874: GO 57941
// if mc_bases [ base ] then
57876: LD_EXP 99
57880: PUSH
57881: LD_VAR 0 1
57885: ARRAY
57886: IFFALSE 57941
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57888: LD_ADDR_VAR 0 3
57892: PUSH
57893: LD_EXP 99
57897: PUSH
57898: LD_VAR 0 1
57902: ARRAY
57903: PPUSH
57904: LD_INT 30
57906: PUSH
57907: LD_VAR 0 2
57911: PUSH
57912: EMPTY
57913: LIST
57914: LIST
57915: PPUSH
57916: CALL_OW 72
57920: ST_TO_ADDR
// if result then
57921: LD_VAR 0 3
57925: IFFALSE 57941
// result := result [ 1 ] ;
57927: LD_ADDR_VAR 0 3
57931: PUSH
57932: LD_VAR 0 3
57936: PUSH
57937: LD_INT 1
57939: ARRAY
57940: ST_TO_ADDR
// end ; end ;
57941: LD_VAR 0 3
57945: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
57946: LD_INT 0
57948: PPUSH
57949: PPUSH
// if not mc_bases then
57950: LD_EXP 99
57954: NOT
57955: IFFALSE 57959
// exit ;
57957: GO 58004
// if mc_bases [ base ] then
57959: LD_EXP 99
57963: PUSH
57964: LD_VAR 0 1
57968: ARRAY
57969: IFFALSE 58004
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57971: LD_ADDR_VAR 0 3
57975: PUSH
57976: LD_EXP 99
57980: PUSH
57981: LD_VAR 0 1
57985: ARRAY
57986: PPUSH
57987: LD_INT 30
57989: PUSH
57990: LD_VAR 0 2
57994: PUSH
57995: EMPTY
57996: LIST
57997: LIST
57998: PPUSH
57999: CALL_OW 72
58003: ST_TO_ADDR
// end ;
58004: LD_VAR 0 3
58008: RET
// export function MC_SetTame ( base , area ) ; begin
58009: LD_INT 0
58011: PPUSH
// if not mc_bases or not base then
58012: LD_EXP 99
58016: NOT
58017: PUSH
58018: LD_VAR 0 1
58022: NOT
58023: OR
58024: IFFALSE 58028
// exit ;
58026: GO 58053
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58028: LD_ADDR_EXP 127
58032: PUSH
58033: LD_EXP 127
58037: PPUSH
58038: LD_VAR 0 1
58042: PPUSH
58043: LD_VAR 0 2
58047: PPUSH
58048: CALL_OW 1
58052: ST_TO_ADDR
// end ;
58053: LD_VAR 0 3
58057: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58058: LD_INT 0
58060: PPUSH
58061: PPUSH
// if not mc_bases or not base then
58062: LD_EXP 99
58066: NOT
58067: PUSH
58068: LD_VAR 0 1
58072: NOT
58073: OR
58074: IFFALSE 58078
// exit ;
58076: GO 58180
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58078: LD_ADDR_VAR 0 4
58082: PUSH
58083: LD_EXP 99
58087: PUSH
58088: LD_VAR 0 1
58092: ARRAY
58093: PPUSH
58094: LD_INT 30
58096: PUSH
58097: LD_VAR 0 2
58101: PUSH
58102: EMPTY
58103: LIST
58104: LIST
58105: PPUSH
58106: CALL_OW 72
58110: ST_TO_ADDR
// if not tmp then
58111: LD_VAR 0 4
58115: NOT
58116: IFFALSE 58120
// exit ;
58118: GO 58180
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58120: LD_ADDR_EXP 131
58124: PUSH
58125: LD_EXP 131
58129: PPUSH
58130: LD_VAR 0 1
58134: PPUSH
58135: LD_EXP 131
58139: PUSH
58140: LD_VAR 0 1
58144: ARRAY
58145: PPUSH
58146: LD_EXP 131
58150: PUSH
58151: LD_VAR 0 1
58155: ARRAY
58156: PUSH
58157: LD_INT 1
58159: PLUS
58160: PPUSH
58161: LD_VAR 0 4
58165: PUSH
58166: LD_INT 1
58168: ARRAY
58169: PPUSH
58170: CALL_OW 2
58174: PPUSH
58175: CALL_OW 1
58179: ST_TO_ADDR
// end ;
58180: LD_VAR 0 3
58184: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58185: LD_INT 0
58187: PPUSH
58188: PPUSH
// if not mc_bases or not base or not kinds then
58189: LD_EXP 99
58193: NOT
58194: PUSH
58195: LD_VAR 0 1
58199: NOT
58200: OR
58201: PUSH
58202: LD_VAR 0 2
58206: NOT
58207: OR
58208: IFFALSE 58212
// exit ;
58210: GO 58273
// for i in kinds do
58212: LD_ADDR_VAR 0 4
58216: PUSH
58217: LD_VAR 0 2
58221: PUSH
58222: FOR_IN
58223: IFFALSE 58271
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58225: LD_ADDR_EXP 133
58229: PUSH
58230: LD_EXP 133
58234: PPUSH
58235: LD_VAR 0 1
58239: PUSH
58240: LD_EXP 133
58244: PUSH
58245: LD_VAR 0 1
58249: ARRAY
58250: PUSH
58251: LD_INT 1
58253: PLUS
58254: PUSH
58255: EMPTY
58256: LIST
58257: LIST
58258: PPUSH
58259: LD_VAR 0 4
58263: PPUSH
58264: CALL 70789 0 3
58268: ST_TO_ADDR
58269: GO 58222
58271: POP
58272: POP
// end ;
58273: LD_VAR 0 3
58277: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58278: LD_INT 0
58280: PPUSH
// if not mc_bases or not base or not areas then
58281: LD_EXP 99
58285: NOT
58286: PUSH
58287: LD_VAR 0 1
58291: NOT
58292: OR
58293: PUSH
58294: LD_VAR 0 2
58298: NOT
58299: OR
58300: IFFALSE 58304
// exit ;
58302: GO 58329
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58304: LD_ADDR_EXP 117
58308: PUSH
58309: LD_EXP 117
58313: PPUSH
58314: LD_VAR 0 1
58318: PPUSH
58319: LD_VAR 0 2
58323: PPUSH
58324: CALL_OW 1
58328: ST_TO_ADDR
// end ;
58329: LD_VAR 0 3
58333: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58334: LD_INT 0
58336: PPUSH
// if not mc_bases or not base or not teleports_exit then
58337: LD_EXP 99
58341: NOT
58342: PUSH
58343: LD_VAR 0 1
58347: NOT
58348: OR
58349: PUSH
58350: LD_VAR 0 2
58354: NOT
58355: OR
58356: IFFALSE 58360
// exit ;
58358: GO 58385
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58360: LD_ADDR_EXP 134
58364: PUSH
58365: LD_EXP 134
58369: PPUSH
58370: LD_VAR 0 1
58374: PPUSH
58375: LD_VAR 0 2
58379: PPUSH
58380: CALL_OW 1
58384: ST_TO_ADDR
// end ;
58385: LD_VAR 0 3
58389: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58390: LD_INT 0
58392: PPUSH
58393: PPUSH
58394: PPUSH
// if not mc_bases or not base or not ext_list then
58395: LD_EXP 99
58399: NOT
58400: PUSH
58401: LD_VAR 0 1
58405: NOT
58406: OR
58407: PUSH
58408: LD_VAR 0 5
58412: NOT
58413: OR
58414: IFFALSE 58418
// exit ;
58416: GO 58591
// tmp := GetFacExtXYD ( x , y , d ) ;
58418: LD_ADDR_VAR 0 8
58422: PUSH
58423: LD_VAR 0 2
58427: PPUSH
58428: LD_VAR 0 3
58432: PPUSH
58433: LD_VAR 0 4
58437: PPUSH
58438: CALL 104167 0 3
58442: ST_TO_ADDR
// if not tmp then
58443: LD_VAR 0 8
58447: NOT
58448: IFFALSE 58452
// exit ;
58450: GO 58591
// for i in tmp do
58452: LD_ADDR_VAR 0 7
58456: PUSH
58457: LD_VAR 0 8
58461: PUSH
58462: FOR_IN
58463: IFFALSE 58589
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58465: LD_ADDR_EXP 104
58469: PUSH
58470: LD_EXP 104
58474: PPUSH
58475: LD_VAR 0 1
58479: PPUSH
58480: LD_EXP 104
58484: PUSH
58485: LD_VAR 0 1
58489: ARRAY
58490: PPUSH
58491: LD_EXP 104
58495: PUSH
58496: LD_VAR 0 1
58500: ARRAY
58501: PUSH
58502: LD_INT 1
58504: PLUS
58505: PPUSH
58506: LD_VAR 0 5
58510: PUSH
58511: LD_INT 1
58513: ARRAY
58514: PUSH
58515: LD_VAR 0 7
58519: PUSH
58520: LD_INT 1
58522: ARRAY
58523: PUSH
58524: LD_VAR 0 7
58528: PUSH
58529: LD_INT 2
58531: ARRAY
58532: PUSH
58533: LD_VAR 0 7
58537: PUSH
58538: LD_INT 3
58540: ARRAY
58541: PUSH
58542: EMPTY
58543: LIST
58544: LIST
58545: LIST
58546: LIST
58547: PPUSH
58548: CALL_OW 2
58552: PPUSH
58553: CALL_OW 1
58557: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
58558: LD_ADDR_VAR 0 5
58562: PUSH
58563: LD_VAR 0 5
58567: PPUSH
58568: LD_INT 1
58570: PPUSH
58571: CALL_OW 3
58575: ST_TO_ADDR
// if not ext_list then
58576: LD_VAR 0 5
58580: NOT
58581: IFFALSE 58587
// exit ;
58583: POP
58584: POP
58585: GO 58591
// end ;
58587: GO 58462
58589: POP
58590: POP
// end ;
58591: LD_VAR 0 6
58595: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
58596: LD_INT 0
58598: PPUSH
// if not mc_bases or not base or not weapon_list then
58599: LD_EXP 99
58603: NOT
58604: PUSH
58605: LD_VAR 0 1
58609: NOT
58610: OR
58611: PUSH
58612: LD_VAR 0 2
58616: NOT
58617: OR
58618: IFFALSE 58622
// exit ;
58620: GO 58647
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
58622: LD_ADDR_EXP 138
58626: PUSH
58627: LD_EXP 138
58631: PPUSH
58632: LD_VAR 0 1
58636: PPUSH
58637: LD_VAR 0 2
58641: PPUSH
58642: CALL_OW 1
58646: ST_TO_ADDR
// end ;
58647: LD_VAR 0 3
58651: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58652: LD_INT 0
58654: PPUSH
// if not mc_bases or not base or not tech_list then
58655: LD_EXP 99
58659: NOT
58660: PUSH
58661: LD_VAR 0 1
58665: NOT
58666: OR
58667: PUSH
58668: LD_VAR 0 2
58672: NOT
58673: OR
58674: IFFALSE 58678
// exit ;
58676: GO 58703
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58678: LD_ADDR_EXP 126
58682: PUSH
58683: LD_EXP 126
58687: PPUSH
58688: LD_VAR 0 1
58692: PPUSH
58693: LD_VAR 0 2
58697: PPUSH
58698: CALL_OW 1
58702: ST_TO_ADDR
// end ;
58703: LD_VAR 0 3
58707: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58708: LD_INT 0
58710: PPUSH
// if not mc_bases or not parking_area or not base then
58711: LD_EXP 99
58715: NOT
58716: PUSH
58717: LD_VAR 0 2
58721: NOT
58722: OR
58723: PUSH
58724: LD_VAR 0 1
58728: NOT
58729: OR
58730: IFFALSE 58734
// exit ;
58732: GO 58759
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58734: LD_ADDR_EXP 123
58738: PUSH
58739: LD_EXP 123
58743: PPUSH
58744: LD_VAR 0 1
58748: PPUSH
58749: LD_VAR 0 2
58753: PPUSH
58754: CALL_OW 1
58758: ST_TO_ADDR
// end ;
58759: LD_VAR 0 3
58763: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
58764: LD_INT 0
58766: PPUSH
// if not mc_bases or not base or not scan_area then
58767: LD_EXP 99
58771: NOT
58772: PUSH
58773: LD_VAR 0 1
58777: NOT
58778: OR
58779: PUSH
58780: LD_VAR 0 2
58784: NOT
58785: OR
58786: IFFALSE 58790
// exit ;
58788: GO 58815
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
58790: LD_ADDR_EXP 124
58794: PUSH
58795: LD_EXP 124
58799: PPUSH
58800: LD_VAR 0 1
58804: PPUSH
58805: LD_VAR 0 2
58809: PPUSH
58810: CALL_OW 1
58814: ST_TO_ADDR
// end ;
58815: LD_VAR 0 3
58819: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
58820: LD_INT 0
58822: PPUSH
58823: PPUSH
// if not mc_bases or not base then
58824: LD_EXP 99
58828: NOT
58829: PUSH
58830: LD_VAR 0 1
58834: NOT
58835: OR
58836: IFFALSE 58840
// exit ;
58838: GO 58904
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
58840: LD_ADDR_VAR 0 3
58844: PUSH
58845: LD_INT 1
58847: PUSH
58848: LD_INT 2
58850: PUSH
58851: LD_INT 3
58853: PUSH
58854: LD_INT 4
58856: PUSH
58857: LD_INT 11
58859: PUSH
58860: EMPTY
58861: LIST
58862: LIST
58863: LIST
58864: LIST
58865: LIST
58866: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
58867: LD_ADDR_EXP 126
58871: PUSH
58872: LD_EXP 126
58876: PPUSH
58877: LD_VAR 0 1
58881: PPUSH
58882: LD_EXP 126
58886: PUSH
58887: LD_VAR 0 1
58891: ARRAY
58892: PUSH
58893: LD_VAR 0 3
58897: DIFF
58898: PPUSH
58899: CALL_OW 1
58903: ST_TO_ADDR
// end ;
58904: LD_VAR 0 2
58908: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
58909: LD_INT 0
58911: PPUSH
// result := mc_vehicles [ base ] ;
58912: LD_ADDR_VAR 0 3
58916: PUSH
58917: LD_EXP 118
58921: PUSH
58922: LD_VAR 0 1
58926: ARRAY
58927: ST_TO_ADDR
// if onlyCombat then
58928: LD_VAR 0 2
58932: IFFALSE 59097
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
58934: LD_ADDR_VAR 0 3
58938: PUSH
58939: LD_VAR 0 3
58943: PUSH
58944: LD_VAR 0 3
58948: PPUSH
58949: LD_INT 2
58951: PUSH
58952: LD_INT 34
58954: PUSH
58955: LD_INT 12
58957: PUSH
58958: EMPTY
58959: LIST
58960: LIST
58961: PUSH
58962: LD_INT 34
58964: PUSH
58965: LD_INT 51
58967: PUSH
58968: EMPTY
58969: LIST
58970: LIST
58971: PUSH
58972: LD_INT 34
58974: PUSH
58975: LD_EXP 93
58979: PUSH
58980: EMPTY
58981: LIST
58982: LIST
58983: PUSH
58984: LD_INT 34
58986: PUSH
58987: LD_INT 32
58989: PUSH
58990: EMPTY
58991: LIST
58992: LIST
58993: PUSH
58994: LD_INT 34
58996: PUSH
58997: LD_INT 13
58999: PUSH
59000: EMPTY
59001: LIST
59002: LIST
59003: PUSH
59004: LD_INT 34
59006: PUSH
59007: LD_INT 52
59009: PUSH
59010: EMPTY
59011: LIST
59012: LIST
59013: PUSH
59014: LD_INT 34
59016: PUSH
59017: LD_INT 14
59019: PUSH
59020: EMPTY
59021: LIST
59022: LIST
59023: PUSH
59024: LD_INT 34
59026: PUSH
59027: LD_INT 53
59029: PUSH
59030: EMPTY
59031: LIST
59032: LIST
59033: PUSH
59034: LD_INT 34
59036: PUSH
59037: LD_EXP 92
59041: PUSH
59042: EMPTY
59043: LIST
59044: LIST
59045: PUSH
59046: LD_INT 34
59048: PUSH
59049: LD_INT 31
59051: PUSH
59052: EMPTY
59053: LIST
59054: LIST
59055: PUSH
59056: LD_INT 34
59058: PUSH
59059: LD_INT 48
59061: PUSH
59062: EMPTY
59063: LIST
59064: LIST
59065: PUSH
59066: LD_INT 34
59068: PUSH
59069: LD_INT 8
59071: PUSH
59072: EMPTY
59073: LIST
59074: LIST
59075: PUSH
59076: EMPTY
59077: LIST
59078: LIST
59079: LIST
59080: LIST
59081: LIST
59082: LIST
59083: LIST
59084: LIST
59085: LIST
59086: LIST
59087: LIST
59088: LIST
59089: LIST
59090: PPUSH
59091: CALL_OW 72
59095: DIFF
59096: ST_TO_ADDR
// end ; end_of_file
59097: LD_VAR 0 3
59101: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59102: LD_INT 0
59104: PPUSH
59105: PPUSH
59106: PPUSH
// if not mc_bases or not skirmish then
59107: LD_EXP 99
59111: NOT
59112: PUSH
59113: LD_EXP 97
59117: NOT
59118: OR
59119: IFFALSE 59123
// exit ;
59121: GO 59288
// for i = 1 to mc_bases do
59123: LD_ADDR_VAR 0 4
59127: PUSH
59128: DOUBLE
59129: LD_INT 1
59131: DEC
59132: ST_TO_ADDR
59133: LD_EXP 99
59137: PUSH
59138: FOR_TO
59139: IFFALSE 59286
// begin if sci in mc_bases [ i ] then
59141: LD_VAR 0 2
59145: PUSH
59146: LD_EXP 99
59150: PUSH
59151: LD_VAR 0 4
59155: ARRAY
59156: IN
59157: IFFALSE 59284
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59159: LD_ADDR_EXP 128
59163: PUSH
59164: LD_EXP 128
59168: PPUSH
59169: LD_VAR 0 4
59173: PUSH
59174: LD_EXP 128
59178: PUSH
59179: LD_VAR 0 4
59183: ARRAY
59184: PUSH
59185: LD_INT 1
59187: PLUS
59188: PUSH
59189: EMPTY
59190: LIST
59191: LIST
59192: PPUSH
59193: LD_VAR 0 1
59197: PPUSH
59198: CALL 70789 0 3
59202: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59203: LD_ADDR_VAR 0 5
59207: PUSH
59208: LD_EXP 99
59212: PUSH
59213: LD_VAR 0 4
59217: ARRAY
59218: PPUSH
59219: LD_INT 2
59221: PUSH
59222: LD_INT 30
59224: PUSH
59225: LD_INT 0
59227: PUSH
59228: EMPTY
59229: LIST
59230: LIST
59231: PUSH
59232: LD_INT 30
59234: PUSH
59235: LD_INT 1
59237: PUSH
59238: EMPTY
59239: LIST
59240: LIST
59241: PUSH
59242: EMPTY
59243: LIST
59244: LIST
59245: LIST
59246: PPUSH
59247: CALL_OW 72
59251: PPUSH
59252: LD_VAR 0 1
59256: PPUSH
59257: CALL_OW 74
59261: ST_TO_ADDR
// if tmp then
59262: LD_VAR 0 5
59266: IFFALSE 59282
// ComStandNearbyBuilding ( ape , tmp ) ;
59268: LD_VAR 0 1
59272: PPUSH
59273: LD_VAR 0 5
59277: PPUSH
59278: CALL 65141 0 2
// break ;
59282: GO 59286
// end ; end ;
59284: GO 59138
59286: POP
59287: POP
// end ;
59288: LD_VAR 0 3
59292: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59293: LD_INT 0
59295: PPUSH
59296: PPUSH
59297: PPUSH
// if not mc_bases or not skirmish then
59298: LD_EXP 99
59302: NOT
59303: PUSH
59304: LD_EXP 97
59308: NOT
59309: OR
59310: IFFALSE 59314
// exit ;
59312: GO 59403
// for i = 1 to mc_bases do
59314: LD_ADDR_VAR 0 4
59318: PUSH
59319: DOUBLE
59320: LD_INT 1
59322: DEC
59323: ST_TO_ADDR
59324: LD_EXP 99
59328: PUSH
59329: FOR_TO
59330: IFFALSE 59401
// begin if building in mc_busy_turret_list [ i ] then
59332: LD_VAR 0 1
59336: PUSH
59337: LD_EXP 109
59341: PUSH
59342: LD_VAR 0 4
59346: ARRAY
59347: IN
59348: IFFALSE 59399
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59350: LD_ADDR_VAR 0 5
59354: PUSH
59355: LD_EXP 109
59359: PUSH
59360: LD_VAR 0 4
59364: ARRAY
59365: PUSH
59366: LD_VAR 0 1
59370: DIFF
59371: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59372: LD_ADDR_EXP 109
59376: PUSH
59377: LD_EXP 109
59381: PPUSH
59382: LD_VAR 0 4
59386: PPUSH
59387: LD_VAR 0 5
59391: PPUSH
59392: CALL_OW 1
59396: ST_TO_ADDR
// break ;
59397: GO 59401
// end ; end ;
59399: GO 59329
59401: POP
59402: POP
// end ;
59403: LD_VAR 0 3
59407: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59408: LD_INT 0
59410: PPUSH
59411: PPUSH
59412: PPUSH
// if not mc_bases or not skirmish then
59413: LD_EXP 99
59417: NOT
59418: PUSH
59419: LD_EXP 97
59423: NOT
59424: OR
59425: IFFALSE 59429
// exit ;
59427: GO 59628
// for i = 1 to mc_bases do
59429: LD_ADDR_VAR 0 5
59433: PUSH
59434: DOUBLE
59435: LD_INT 1
59437: DEC
59438: ST_TO_ADDR
59439: LD_EXP 99
59443: PUSH
59444: FOR_TO
59445: IFFALSE 59626
// if building in mc_bases [ i ] then
59447: LD_VAR 0 1
59451: PUSH
59452: LD_EXP 99
59456: PUSH
59457: LD_VAR 0 5
59461: ARRAY
59462: IN
59463: IFFALSE 59624
// begin tmp := mc_bases [ i ] diff building ;
59465: LD_ADDR_VAR 0 6
59469: PUSH
59470: LD_EXP 99
59474: PUSH
59475: LD_VAR 0 5
59479: ARRAY
59480: PUSH
59481: LD_VAR 0 1
59485: DIFF
59486: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
59487: LD_ADDR_EXP 99
59491: PUSH
59492: LD_EXP 99
59496: PPUSH
59497: LD_VAR 0 5
59501: PPUSH
59502: LD_VAR 0 6
59506: PPUSH
59507: CALL_OW 1
59511: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
59512: LD_VAR 0 1
59516: PUSH
59517: LD_EXP 107
59521: PUSH
59522: LD_VAR 0 5
59526: ARRAY
59527: IN
59528: IFFALSE 59567
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
59530: LD_ADDR_EXP 107
59534: PUSH
59535: LD_EXP 107
59539: PPUSH
59540: LD_VAR 0 5
59544: PPUSH
59545: LD_EXP 107
59549: PUSH
59550: LD_VAR 0 5
59554: ARRAY
59555: PUSH
59556: LD_VAR 0 1
59560: DIFF
59561: PPUSH
59562: CALL_OW 1
59566: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
59567: LD_VAR 0 1
59571: PUSH
59572: LD_EXP 108
59576: PUSH
59577: LD_VAR 0 5
59581: ARRAY
59582: IN
59583: IFFALSE 59622
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
59585: LD_ADDR_EXP 108
59589: PUSH
59590: LD_EXP 108
59594: PPUSH
59595: LD_VAR 0 5
59599: PPUSH
59600: LD_EXP 108
59604: PUSH
59605: LD_VAR 0 5
59609: ARRAY
59610: PUSH
59611: LD_VAR 0 1
59615: DIFF
59616: PPUSH
59617: CALL_OW 1
59621: ST_TO_ADDR
// break ;
59622: GO 59626
// end ;
59624: GO 59444
59626: POP
59627: POP
// end ;
59628: LD_VAR 0 4
59632: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
59633: LD_INT 0
59635: PPUSH
59636: PPUSH
59637: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
59638: LD_EXP 99
59642: NOT
59643: PUSH
59644: LD_EXP 97
59648: NOT
59649: OR
59650: PUSH
59651: LD_VAR 0 3
59655: PUSH
59656: LD_EXP 125
59660: IN
59661: NOT
59662: OR
59663: IFFALSE 59667
// exit ;
59665: GO 59790
// for i = 1 to mc_vehicles do
59667: LD_ADDR_VAR 0 6
59671: PUSH
59672: DOUBLE
59673: LD_INT 1
59675: DEC
59676: ST_TO_ADDR
59677: LD_EXP 118
59681: PUSH
59682: FOR_TO
59683: IFFALSE 59788
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59685: LD_VAR 0 2
59689: PUSH
59690: LD_EXP 118
59694: PUSH
59695: LD_VAR 0 6
59699: ARRAY
59700: IN
59701: PUSH
59702: LD_VAR 0 1
59706: PUSH
59707: LD_EXP 118
59711: PUSH
59712: LD_VAR 0 6
59716: ARRAY
59717: IN
59718: OR
59719: IFFALSE 59786
// begin tmp := mc_vehicles [ i ] diff old ;
59721: LD_ADDR_VAR 0 7
59725: PUSH
59726: LD_EXP 118
59730: PUSH
59731: LD_VAR 0 6
59735: ARRAY
59736: PUSH
59737: LD_VAR 0 2
59741: DIFF
59742: ST_TO_ADDR
// tmp := tmp diff new ;
59743: LD_ADDR_VAR 0 7
59747: PUSH
59748: LD_VAR 0 7
59752: PUSH
59753: LD_VAR 0 1
59757: DIFF
59758: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59759: LD_ADDR_EXP 118
59763: PUSH
59764: LD_EXP 118
59768: PPUSH
59769: LD_VAR 0 6
59773: PPUSH
59774: LD_VAR 0 7
59778: PPUSH
59779: CALL_OW 1
59783: ST_TO_ADDR
// break ;
59784: GO 59788
// end ;
59786: GO 59682
59788: POP
59789: POP
// end ;
59790: LD_VAR 0 5
59794: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
59795: LD_INT 0
59797: PPUSH
59798: PPUSH
59799: PPUSH
59800: PPUSH
// if not mc_bases or not skirmish then
59801: LD_EXP 99
59805: NOT
59806: PUSH
59807: LD_EXP 97
59811: NOT
59812: OR
59813: IFFALSE 59817
// exit ;
59815: GO 60194
// side := GetSide ( vehicle ) ;
59817: LD_ADDR_VAR 0 5
59821: PUSH
59822: LD_VAR 0 1
59826: PPUSH
59827: CALL_OW 255
59831: ST_TO_ADDR
// for i = 1 to mc_bases do
59832: LD_ADDR_VAR 0 4
59836: PUSH
59837: DOUBLE
59838: LD_INT 1
59840: DEC
59841: ST_TO_ADDR
59842: LD_EXP 99
59846: PUSH
59847: FOR_TO
59848: IFFALSE 60192
// begin if factory in mc_bases [ i ] then
59850: LD_VAR 0 2
59854: PUSH
59855: LD_EXP 99
59859: PUSH
59860: LD_VAR 0 4
59864: ARRAY
59865: IN
59866: IFFALSE 60190
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
59868: LD_EXP 121
59872: PUSH
59873: LD_VAR 0 4
59877: ARRAY
59878: PUSH
59879: LD_EXP 110
59883: PUSH
59884: LD_VAR 0 4
59888: ARRAY
59889: LESS
59890: PUSH
59891: LD_VAR 0 1
59895: PPUSH
59896: CALL_OW 264
59900: PUSH
59901: LD_INT 31
59903: PUSH
59904: LD_INT 32
59906: PUSH
59907: LD_INT 51
59909: PUSH
59910: LD_EXP 93
59914: PUSH
59915: LD_INT 12
59917: PUSH
59918: LD_INT 30
59920: PUSH
59921: LD_EXP 92
59925: PUSH
59926: LD_INT 11
59928: PUSH
59929: LD_INT 53
59931: PUSH
59932: LD_INT 14
59934: PUSH
59935: LD_EXP 96
59939: PUSH
59940: LD_INT 29
59942: PUSH
59943: LD_EXP 94
59947: PUSH
59948: LD_INT 13
59950: PUSH
59951: LD_INT 52
59953: PUSH
59954: LD_INT 48
59956: PUSH
59957: LD_INT 8
59959: PUSH
59960: EMPTY
59961: LIST
59962: LIST
59963: LIST
59964: LIST
59965: LIST
59966: LIST
59967: LIST
59968: LIST
59969: LIST
59970: LIST
59971: LIST
59972: LIST
59973: LIST
59974: LIST
59975: LIST
59976: LIST
59977: LIST
59978: IN
59979: NOT
59980: AND
59981: IFFALSE 60029
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
59983: LD_ADDR_EXP 121
59987: PUSH
59988: LD_EXP 121
59992: PPUSH
59993: LD_VAR 0 4
59997: PUSH
59998: LD_EXP 121
60002: PUSH
60003: LD_VAR 0 4
60007: ARRAY
60008: PUSH
60009: LD_INT 1
60011: PLUS
60012: PUSH
60013: EMPTY
60014: LIST
60015: LIST
60016: PPUSH
60017: LD_VAR 0 1
60021: PPUSH
60022: CALL 70789 0 3
60026: ST_TO_ADDR
60027: GO 60073
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60029: LD_ADDR_EXP 118
60033: PUSH
60034: LD_EXP 118
60038: PPUSH
60039: LD_VAR 0 4
60043: PUSH
60044: LD_EXP 118
60048: PUSH
60049: LD_VAR 0 4
60053: ARRAY
60054: PUSH
60055: LD_INT 1
60057: PLUS
60058: PUSH
60059: EMPTY
60060: LIST
60061: LIST
60062: PPUSH
60063: LD_VAR 0 1
60067: PPUSH
60068: CALL 70789 0 3
60072: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60073: LD_VAR 0 1
60077: PPUSH
60078: CALL_OW 263
60082: PUSH
60083: LD_INT 2
60085: EQUAL
60086: IFFALSE 60106
// begin repeat wait ( 0 0$1 ) ;
60088: LD_INT 35
60090: PPUSH
60091: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60095: LD_VAR 0 1
60099: PPUSH
60100: CALL_OW 312
60104: IFFALSE 60088
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60106: LD_VAR 0 1
60110: PPUSH
60111: LD_EXP 123
60115: PUSH
60116: LD_VAR 0 4
60120: ARRAY
60121: PPUSH
60122: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60126: LD_VAR 0 1
60130: PPUSH
60131: CALL_OW 263
60135: PUSH
60136: LD_INT 1
60138: NONEQUAL
60139: IFFALSE 60143
// break ;
60141: GO 60192
// repeat wait ( 0 0$1 ) ;
60143: LD_INT 35
60145: PPUSH
60146: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60150: LD_VAR 0 1
60154: PPUSH
60155: LD_EXP 123
60159: PUSH
60160: LD_VAR 0 4
60164: ARRAY
60165: PPUSH
60166: CALL_OW 308
60170: IFFALSE 60143
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60172: LD_VAR 0 1
60176: PPUSH
60177: CALL_OW 311
60181: PPUSH
60182: CALL_OW 121
// exit ;
60186: POP
60187: POP
60188: GO 60194
// end ; end ;
60190: GO 59847
60192: POP
60193: POP
// end ;
60194: LD_VAR 0 3
60198: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60199: LD_INT 0
60201: PPUSH
60202: PPUSH
60203: PPUSH
60204: PPUSH
// if not mc_bases or not skirmish then
60205: LD_EXP 99
60209: NOT
60210: PUSH
60211: LD_EXP 97
60215: NOT
60216: OR
60217: IFFALSE 60221
// exit ;
60219: GO 60574
// repeat wait ( 0 0$1 ) ;
60221: LD_INT 35
60223: PPUSH
60224: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60228: LD_VAR 0 2
60232: PPUSH
60233: LD_VAR 0 3
60237: PPUSH
60238: CALL_OW 284
60242: IFFALSE 60221
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60244: LD_VAR 0 2
60248: PPUSH
60249: LD_VAR 0 3
60253: PPUSH
60254: CALL_OW 283
60258: PUSH
60259: LD_INT 4
60261: EQUAL
60262: IFFALSE 60266
// exit ;
60264: GO 60574
// for i = 1 to mc_bases do
60266: LD_ADDR_VAR 0 7
60270: PUSH
60271: DOUBLE
60272: LD_INT 1
60274: DEC
60275: ST_TO_ADDR
60276: LD_EXP 99
60280: PUSH
60281: FOR_TO
60282: IFFALSE 60572
// begin if mc_crates_area [ i ] then
60284: LD_EXP 117
60288: PUSH
60289: LD_VAR 0 7
60293: ARRAY
60294: IFFALSE 60405
// for j in mc_crates_area [ i ] do
60296: LD_ADDR_VAR 0 8
60300: PUSH
60301: LD_EXP 117
60305: PUSH
60306: LD_VAR 0 7
60310: ARRAY
60311: PUSH
60312: FOR_IN
60313: IFFALSE 60403
// if InArea ( x , y , j ) then
60315: LD_VAR 0 2
60319: PPUSH
60320: LD_VAR 0 3
60324: PPUSH
60325: LD_VAR 0 8
60329: PPUSH
60330: CALL_OW 309
60334: IFFALSE 60401
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60336: LD_ADDR_EXP 115
60340: PUSH
60341: LD_EXP 115
60345: PPUSH
60346: LD_VAR 0 7
60350: PUSH
60351: LD_EXP 115
60355: PUSH
60356: LD_VAR 0 7
60360: ARRAY
60361: PUSH
60362: LD_INT 1
60364: PLUS
60365: PUSH
60366: EMPTY
60367: LIST
60368: LIST
60369: PPUSH
60370: LD_VAR 0 4
60374: PUSH
60375: LD_VAR 0 2
60379: PUSH
60380: LD_VAR 0 3
60384: PUSH
60385: EMPTY
60386: LIST
60387: LIST
60388: LIST
60389: PPUSH
60390: CALL 70789 0 3
60394: ST_TO_ADDR
// exit ;
60395: POP
60396: POP
60397: POP
60398: POP
60399: GO 60574
// end ;
60401: GO 60312
60403: POP
60404: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60405: LD_ADDR_VAR 0 9
60409: PUSH
60410: LD_EXP 99
60414: PUSH
60415: LD_VAR 0 7
60419: ARRAY
60420: PPUSH
60421: LD_INT 2
60423: PUSH
60424: LD_INT 30
60426: PUSH
60427: LD_INT 0
60429: PUSH
60430: EMPTY
60431: LIST
60432: LIST
60433: PUSH
60434: LD_INT 30
60436: PUSH
60437: LD_INT 1
60439: PUSH
60440: EMPTY
60441: LIST
60442: LIST
60443: PUSH
60444: EMPTY
60445: LIST
60446: LIST
60447: LIST
60448: PPUSH
60449: CALL_OW 72
60453: ST_TO_ADDR
// if not depot then
60454: LD_VAR 0 9
60458: NOT
60459: IFFALSE 60463
// continue ;
60461: GO 60281
// for j in depot do
60463: LD_ADDR_VAR 0 8
60467: PUSH
60468: LD_VAR 0 9
60472: PUSH
60473: FOR_IN
60474: IFFALSE 60568
// if GetDistUnitXY ( j , x , y ) < 30 then
60476: LD_VAR 0 8
60480: PPUSH
60481: LD_VAR 0 2
60485: PPUSH
60486: LD_VAR 0 3
60490: PPUSH
60491: CALL_OW 297
60495: PUSH
60496: LD_INT 30
60498: LESS
60499: IFFALSE 60566
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60501: LD_ADDR_EXP 115
60505: PUSH
60506: LD_EXP 115
60510: PPUSH
60511: LD_VAR 0 7
60515: PUSH
60516: LD_EXP 115
60520: PUSH
60521: LD_VAR 0 7
60525: ARRAY
60526: PUSH
60527: LD_INT 1
60529: PLUS
60530: PUSH
60531: EMPTY
60532: LIST
60533: LIST
60534: PPUSH
60535: LD_VAR 0 4
60539: PUSH
60540: LD_VAR 0 2
60544: PUSH
60545: LD_VAR 0 3
60549: PUSH
60550: EMPTY
60551: LIST
60552: LIST
60553: LIST
60554: PPUSH
60555: CALL 70789 0 3
60559: ST_TO_ADDR
// exit ;
60560: POP
60561: POP
60562: POP
60563: POP
60564: GO 60574
// end ;
60566: GO 60473
60568: POP
60569: POP
// end ;
60570: GO 60281
60572: POP
60573: POP
// end ;
60574: LD_VAR 0 6
60578: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
60579: LD_INT 0
60581: PPUSH
60582: PPUSH
60583: PPUSH
60584: PPUSH
// if not mc_bases or not skirmish then
60585: LD_EXP 99
60589: NOT
60590: PUSH
60591: LD_EXP 97
60595: NOT
60596: OR
60597: IFFALSE 60601
// exit ;
60599: GO 60878
// side := GetSide ( lab ) ;
60601: LD_ADDR_VAR 0 4
60605: PUSH
60606: LD_VAR 0 2
60610: PPUSH
60611: CALL_OW 255
60615: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
60616: LD_VAR 0 4
60620: PUSH
60621: LD_EXP 125
60625: IN
60626: NOT
60627: PUSH
60628: LD_EXP 126
60632: NOT
60633: OR
60634: PUSH
60635: LD_EXP 99
60639: NOT
60640: OR
60641: IFFALSE 60645
// exit ;
60643: GO 60878
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60645: LD_ADDR_EXP 126
60649: PUSH
60650: LD_EXP 126
60654: PPUSH
60655: LD_VAR 0 4
60659: PPUSH
60660: LD_EXP 126
60664: PUSH
60665: LD_VAR 0 4
60669: ARRAY
60670: PUSH
60671: LD_VAR 0 1
60675: DIFF
60676: PPUSH
60677: CALL_OW 1
60681: ST_TO_ADDR
// for i = 1 to mc_bases do
60682: LD_ADDR_VAR 0 5
60686: PUSH
60687: DOUBLE
60688: LD_INT 1
60690: DEC
60691: ST_TO_ADDR
60692: LD_EXP 99
60696: PUSH
60697: FOR_TO
60698: IFFALSE 60876
// begin if lab in mc_bases [ i ] then
60700: LD_VAR 0 2
60704: PUSH
60705: LD_EXP 99
60709: PUSH
60710: LD_VAR 0 5
60714: ARRAY
60715: IN
60716: IFFALSE 60874
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60718: LD_VAR 0 1
60722: PUSH
60723: LD_INT 11
60725: PUSH
60726: LD_INT 4
60728: PUSH
60729: LD_INT 3
60731: PUSH
60732: LD_INT 2
60734: PUSH
60735: EMPTY
60736: LIST
60737: LIST
60738: LIST
60739: LIST
60740: IN
60741: PUSH
60742: LD_EXP 129
60746: PUSH
60747: LD_VAR 0 5
60751: ARRAY
60752: AND
60753: IFFALSE 60874
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60755: LD_ADDR_VAR 0 6
60759: PUSH
60760: LD_EXP 129
60764: PUSH
60765: LD_VAR 0 5
60769: ARRAY
60770: PUSH
60771: LD_INT 1
60773: ARRAY
60774: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60775: LD_ADDR_EXP 129
60779: PUSH
60780: LD_EXP 129
60784: PPUSH
60785: LD_VAR 0 5
60789: PPUSH
60790: EMPTY
60791: PPUSH
60792: CALL_OW 1
60796: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
60797: LD_VAR 0 6
60801: PPUSH
60802: LD_INT 0
60804: PPUSH
60805: CALL_OW 109
// ComExitBuilding ( tmp ) ;
60809: LD_VAR 0 6
60813: PPUSH
60814: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
60818: LD_ADDR_EXP 128
60822: PUSH
60823: LD_EXP 128
60827: PPUSH
60828: LD_VAR 0 5
60832: PPUSH
60833: LD_EXP 128
60837: PUSH
60838: LD_VAR 0 5
60842: ARRAY
60843: PPUSH
60844: LD_INT 1
60846: PPUSH
60847: LD_VAR 0 6
60851: PPUSH
60852: CALL_OW 2
60856: PPUSH
60857: CALL_OW 1
60861: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
60862: LD_VAR 0 5
60866: PPUSH
60867: LD_INT 112
60869: PPUSH
60870: CALL 37986 0 2
// end ; end ; end ;
60874: GO 60697
60876: POP
60877: POP
// end ;
60878: LD_VAR 0 3
60882: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
60883: LD_INT 0
60885: PPUSH
60886: PPUSH
60887: PPUSH
60888: PPUSH
60889: PPUSH
60890: PPUSH
60891: PPUSH
60892: PPUSH
// if not mc_bases or not skirmish then
60893: LD_EXP 99
60897: NOT
60898: PUSH
60899: LD_EXP 97
60903: NOT
60904: OR
60905: IFFALSE 60909
// exit ;
60907: GO 62146
// for i = 1 to mc_bases do
60909: LD_ADDR_VAR 0 3
60913: PUSH
60914: DOUBLE
60915: LD_INT 1
60917: DEC
60918: ST_TO_ADDR
60919: LD_EXP 99
60923: PUSH
60924: FOR_TO
60925: IFFALSE 62144
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
60927: LD_VAR 0 1
60931: PUSH
60932: LD_EXP 99
60936: PUSH
60937: LD_VAR 0 3
60941: ARRAY
60942: IN
60943: PUSH
60944: LD_VAR 0 1
60948: PUSH
60949: LD_EXP 106
60953: PUSH
60954: LD_VAR 0 3
60958: ARRAY
60959: IN
60960: OR
60961: PUSH
60962: LD_VAR 0 1
60966: PUSH
60967: LD_EXP 121
60971: PUSH
60972: LD_VAR 0 3
60976: ARRAY
60977: IN
60978: OR
60979: PUSH
60980: LD_VAR 0 1
60984: PUSH
60985: LD_EXP 118
60989: PUSH
60990: LD_VAR 0 3
60994: ARRAY
60995: IN
60996: OR
60997: PUSH
60998: LD_VAR 0 1
61002: PUSH
61003: LD_EXP 128
61007: PUSH
61008: LD_VAR 0 3
61012: ARRAY
61013: IN
61014: OR
61015: PUSH
61016: LD_VAR 0 1
61020: PUSH
61021: LD_EXP 129
61025: PUSH
61026: LD_VAR 0 3
61030: ARRAY
61031: IN
61032: OR
61033: IFFALSE 62142
// begin if un in mc_ape [ i ] then
61035: LD_VAR 0 1
61039: PUSH
61040: LD_EXP 128
61044: PUSH
61045: LD_VAR 0 3
61049: ARRAY
61050: IN
61051: IFFALSE 61090
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61053: LD_ADDR_EXP 128
61057: PUSH
61058: LD_EXP 128
61062: PPUSH
61063: LD_VAR 0 3
61067: PPUSH
61068: LD_EXP 128
61072: PUSH
61073: LD_VAR 0 3
61077: ARRAY
61078: PUSH
61079: LD_VAR 0 1
61083: DIFF
61084: PPUSH
61085: CALL_OW 1
61089: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61090: LD_VAR 0 1
61094: PUSH
61095: LD_EXP 129
61099: PUSH
61100: LD_VAR 0 3
61104: ARRAY
61105: IN
61106: IFFALSE 61130
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61108: LD_ADDR_EXP 129
61112: PUSH
61113: LD_EXP 129
61117: PPUSH
61118: LD_VAR 0 3
61122: PPUSH
61123: EMPTY
61124: PPUSH
61125: CALL_OW 1
61129: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
61130: LD_VAR 0 1
61134: PPUSH
61135: CALL_OW 247
61139: PUSH
61140: LD_INT 2
61142: EQUAL
61143: PUSH
61144: LD_VAR 0 1
61148: PPUSH
61149: CALL_OW 110
61153: PUSH
61154: LD_INT 20
61156: EQUAL
61157: PUSH
61158: LD_VAR 0 1
61162: PUSH
61163: LD_EXP 121
61167: PUSH
61168: LD_VAR 0 3
61172: ARRAY
61173: IN
61174: OR
61175: PUSH
61176: LD_VAR 0 1
61180: PPUSH
61181: CALL_OW 264
61185: PUSH
61186: LD_INT 12
61188: PUSH
61189: LD_INT 51
61191: PUSH
61192: LD_EXP 93
61196: PUSH
61197: LD_INT 32
61199: PUSH
61200: LD_INT 13
61202: PUSH
61203: LD_INT 52
61205: PUSH
61206: EMPTY
61207: LIST
61208: LIST
61209: LIST
61210: LIST
61211: LIST
61212: LIST
61213: IN
61214: OR
61215: AND
61216: IFFALSE 61394
// begin if un in mc_defender [ i ] then
61218: LD_VAR 0 1
61222: PUSH
61223: LD_EXP 121
61227: PUSH
61228: LD_VAR 0 3
61232: ARRAY
61233: IN
61234: IFFALSE 61273
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61236: LD_ADDR_EXP 121
61240: PUSH
61241: LD_EXP 121
61245: PPUSH
61246: LD_VAR 0 3
61250: PPUSH
61251: LD_EXP 121
61255: PUSH
61256: LD_VAR 0 3
61260: ARRAY
61261: PUSH
61262: LD_VAR 0 1
61266: DIFF
61267: PPUSH
61268: CALL_OW 1
61272: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61273: LD_ADDR_VAR 0 8
61277: PUSH
61278: LD_VAR 0 3
61282: PPUSH
61283: LD_INT 3
61285: PPUSH
61286: CALL 57946 0 2
61290: ST_TO_ADDR
// if fac then
61291: LD_VAR 0 8
61295: IFFALSE 61394
// begin for j in fac do
61297: LD_ADDR_VAR 0 4
61301: PUSH
61302: LD_VAR 0 8
61306: PUSH
61307: FOR_IN
61308: IFFALSE 61392
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61310: LD_ADDR_VAR 0 9
61314: PUSH
61315: LD_VAR 0 8
61319: PPUSH
61320: LD_VAR 0 1
61324: PPUSH
61325: CALL_OW 265
61329: PPUSH
61330: LD_VAR 0 1
61334: PPUSH
61335: CALL_OW 262
61339: PPUSH
61340: LD_VAR 0 1
61344: PPUSH
61345: CALL_OW 263
61349: PPUSH
61350: LD_VAR 0 1
61354: PPUSH
61355: CALL_OW 264
61359: PPUSH
61360: CALL 68321 0 5
61364: ST_TO_ADDR
// if components then
61365: LD_VAR 0 9
61369: IFFALSE 61390
// begin MC_InsertProduceList ( i , [ components ] ) ;
61371: LD_VAR 0 3
61375: PPUSH
61376: LD_VAR 0 9
61380: PUSH
61381: EMPTY
61382: LIST
61383: PPUSH
61384: CALL 57491 0 2
// break ;
61388: GO 61392
// end ; end ;
61390: GO 61307
61392: POP
61393: POP
// end ; end ; if GetType ( un ) = unit_building then
61394: LD_VAR 0 1
61398: PPUSH
61399: CALL_OW 247
61403: PUSH
61404: LD_INT 3
61406: EQUAL
61407: IFFALSE 61810
// begin btype := GetBType ( un ) ;
61409: LD_ADDR_VAR 0 5
61413: PUSH
61414: LD_VAR 0 1
61418: PPUSH
61419: CALL_OW 266
61423: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
61424: LD_VAR 0 5
61428: PUSH
61429: LD_INT 29
61431: PUSH
61432: LD_INT 30
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: IN
61439: IFFALSE 61512
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
61441: LD_VAR 0 1
61445: PPUSH
61446: CALL_OW 250
61450: PPUSH
61451: LD_VAR 0 1
61455: PPUSH
61456: CALL_OW 251
61460: PPUSH
61461: LD_VAR 0 1
61465: PPUSH
61466: CALL_OW 255
61470: PPUSH
61471: CALL_OW 440
61475: NOT
61476: IFFALSE 61512
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
61478: LD_VAR 0 1
61482: PPUSH
61483: CALL_OW 250
61487: PPUSH
61488: LD_VAR 0 1
61492: PPUSH
61493: CALL_OW 251
61497: PPUSH
61498: LD_VAR 0 1
61502: PPUSH
61503: CALL_OW 255
61507: PPUSH
61508: CALL_OW 441
// end ; if btype = b_warehouse then
61512: LD_VAR 0 5
61516: PUSH
61517: LD_INT 1
61519: EQUAL
61520: IFFALSE 61538
// begin btype := b_depot ;
61522: LD_ADDR_VAR 0 5
61526: PUSH
61527: LD_INT 0
61529: ST_TO_ADDR
// pos := 1 ;
61530: LD_ADDR_VAR 0 6
61534: PUSH
61535: LD_INT 1
61537: ST_TO_ADDR
// end ; if btype = b_factory then
61538: LD_VAR 0 5
61542: PUSH
61543: LD_INT 3
61545: EQUAL
61546: IFFALSE 61564
// begin btype := b_workshop ;
61548: LD_ADDR_VAR 0 5
61552: PUSH
61553: LD_INT 2
61555: ST_TO_ADDR
// pos := 1 ;
61556: LD_ADDR_VAR 0 6
61560: PUSH
61561: LD_INT 1
61563: ST_TO_ADDR
// end ; if btype = b_barracks then
61564: LD_VAR 0 5
61568: PUSH
61569: LD_INT 5
61571: EQUAL
61572: IFFALSE 61582
// btype := b_armoury ;
61574: LD_ADDR_VAR 0 5
61578: PUSH
61579: LD_INT 4
61581: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
61582: LD_VAR 0 5
61586: PUSH
61587: LD_INT 7
61589: PUSH
61590: LD_INT 8
61592: PUSH
61593: EMPTY
61594: LIST
61595: LIST
61596: IN
61597: IFFALSE 61607
// btype := b_lab ;
61599: LD_ADDR_VAR 0 5
61603: PUSH
61604: LD_INT 6
61606: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
61607: LD_ADDR_EXP 104
61611: PUSH
61612: LD_EXP 104
61616: PPUSH
61617: LD_VAR 0 3
61621: PUSH
61622: LD_EXP 104
61626: PUSH
61627: LD_VAR 0 3
61631: ARRAY
61632: PUSH
61633: LD_INT 1
61635: PLUS
61636: PUSH
61637: EMPTY
61638: LIST
61639: LIST
61640: PPUSH
61641: LD_VAR 0 5
61645: PUSH
61646: LD_VAR 0 1
61650: PPUSH
61651: CALL_OW 250
61655: PUSH
61656: LD_VAR 0 1
61660: PPUSH
61661: CALL_OW 251
61665: PUSH
61666: LD_VAR 0 1
61670: PPUSH
61671: CALL_OW 254
61675: PUSH
61676: EMPTY
61677: LIST
61678: LIST
61679: LIST
61680: LIST
61681: PPUSH
61682: CALL 70789 0 3
61686: ST_TO_ADDR
// if pos = 1 then
61687: LD_VAR 0 6
61691: PUSH
61692: LD_INT 1
61694: EQUAL
61695: IFFALSE 61810
// begin tmp := mc_build_list [ i ] ;
61697: LD_ADDR_VAR 0 7
61701: PUSH
61702: LD_EXP 104
61706: PUSH
61707: LD_VAR 0 3
61711: ARRAY
61712: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61713: LD_VAR 0 7
61717: PPUSH
61718: LD_INT 2
61720: PUSH
61721: LD_INT 30
61723: PUSH
61724: LD_INT 0
61726: PUSH
61727: EMPTY
61728: LIST
61729: LIST
61730: PUSH
61731: LD_INT 30
61733: PUSH
61734: LD_INT 1
61736: PUSH
61737: EMPTY
61738: LIST
61739: LIST
61740: PUSH
61741: EMPTY
61742: LIST
61743: LIST
61744: LIST
61745: PPUSH
61746: CALL_OW 72
61750: IFFALSE 61760
// pos := 2 ;
61752: LD_ADDR_VAR 0 6
61756: PUSH
61757: LD_INT 2
61759: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
61760: LD_ADDR_VAR 0 7
61764: PUSH
61765: LD_VAR 0 7
61769: PPUSH
61770: LD_VAR 0 6
61774: PPUSH
61775: LD_VAR 0 7
61779: PPUSH
61780: CALL 71115 0 3
61784: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
61785: LD_ADDR_EXP 104
61789: PUSH
61790: LD_EXP 104
61794: PPUSH
61795: LD_VAR 0 3
61799: PPUSH
61800: LD_VAR 0 7
61804: PPUSH
61805: CALL_OW 1
61809: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
61810: LD_VAR 0 1
61814: PUSH
61815: LD_EXP 99
61819: PUSH
61820: LD_VAR 0 3
61824: ARRAY
61825: IN
61826: IFFALSE 61865
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
61828: LD_ADDR_EXP 99
61832: PUSH
61833: LD_EXP 99
61837: PPUSH
61838: LD_VAR 0 3
61842: PPUSH
61843: LD_EXP 99
61847: PUSH
61848: LD_VAR 0 3
61852: ARRAY
61853: PUSH
61854: LD_VAR 0 1
61858: DIFF
61859: PPUSH
61860: CALL_OW 1
61864: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
61865: LD_VAR 0 1
61869: PUSH
61870: LD_EXP 106
61874: PUSH
61875: LD_VAR 0 3
61879: ARRAY
61880: IN
61881: IFFALSE 61920
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
61883: LD_ADDR_EXP 106
61887: PUSH
61888: LD_EXP 106
61892: PPUSH
61893: LD_VAR 0 3
61897: PPUSH
61898: LD_EXP 106
61902: PUSH
61903: LD_VAR 0 3
61907: ARRAY
61908: PUSH
61909: LD_VAR 0 1
61913: DIFF
61914: PPUSH
61915: CALL_OW 1
61919: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
61920: LD_VAR 0 1
61924: PUSH
61925: LD_EXP 118
61929: PUSH
61930: LD_VAR 0 3
61934: ARRAY
61935: IN
61936: IFFALSE 61975
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
61938: LD_ADDR_EXP 118
61942: PUSH
61943: LD_EXP 118
61947: PPUSH
61948: LD_VAR 0 3
61952: PPUSH
61953: LD_EXP 118
61957: PUSH
61958: LD_VAR 0 3
61962: ARRAY
61963: PUSH
61964: LD_VAR 0 1
61968: DIFF
61969: PPUSH
61970: CALL_OW 1
61974: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
61975: LD_VAR 0 1
61979: PUSH
61980: LD_EXP 121
61984: PUSH
61985: LD_VAR 0 3
61989: ARRAY
61990: IN
61991: IFFALSE 62030
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61993: LD_ADDR_EXP 121
61997: PUSH
61998: LD_EXP 121
62002: PPUSH
62003: LD_VAR 0 3
62007: PPUSH
62008: LD_EXP 121
62012: PUSH
62013: LD_VAR 0 3
62017: ARRAY
62018: PUSH
62019: LD_VAR 0 1
62023: DIFF
62024: PPUSH
62025: CALL_OW 1
62029: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
62030: LD_VAR 0 1
62034: PUSH
62035: LD_EXP 108
62039: PUSH
62040: LD_VAR 0 3
62044: ARRAY
62045: IN
62046: IFFALSE 62085
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
62048: LD_ADDR_EXP 108
62052: PUSH
62053: LD_EXP 108
62057: PPUSH
62058: LD_VAR 0 3
62062: PPUSH
62063: LD_EXP 108
62067: PUSH
62068: LD_VAR 0 3
62072: ARRAY
62073: PUSH
62074: LD_VAR 0 1
62078: DIFF
62079: PPUSH
62080: CALL_OW 1
62084: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
62085: LD_VAR 0 1
62089: PUSH
62090: LD_EXP 107
62094: PUSH
62095: LD_VAR 0 3
62099: ARRAY
62100: IN
62101: IFFALSE 62140
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62103: LD_ADDR_EXP 107
62107: PUSH
62108: LD_EXP 107
62112: PPUSH
62113: LD_VAR 0 3
62117: PPUSH
62118: LD_EXP 107
62122: PUSH
62123: LD_VAR 0 3
62127: ARRAY
62128: PUSH
62129: LD_VAR 0 1
62133: DIFF
62134: PPUSH
62135: CALL_OW 1
62139: ST_TO_ADDR
// end ; break ;
62140: GO 62144
// end ;
62142: GO 60924
62144: POP
62145: POP
// end ;
62146: LD_VAR 0 2
62150: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62151: LD_INT 0
62153: PPUSH
62154: PPUSH
62155: PPUSH
// if not mc_bases or not skirmish then
62156: LD_EXP 99
62160: NOT
62161: PUSH
62162: LD_EXP 97
62166: NOT
62167: OR
62168: IFFALSE 62172
// exit ;
62170: GO 62387
// for i = 1 to mc_bases do
62172: LD_ADDR_VAR 0 3
62176: PUSH
62177: DOUBLE
62178: LD_INT 1
62180: DEC
62181: ST_TO_ADDR
62182: LD_EXP 99
62186: PUSH
62187: FOR_TO
62188: IFFALSE 62385
// begin if building in mc_construct_list [ i ] then
62190: LD_VAR 0 1
62194: PUSH
62195: LD_EXP 106
62199: PUSH
62200: LD_VAR 0 3
62204: ARRAY
62205: IN
62206: IFFALSE 62383
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62208: LD_ADDR_EXP 106
62212: PUSH
62213: LD_EXP 106
62217: PPUSH
62218: LD_VAR 0 3
62222: PPUSH
62223: LD_EXP 106
62227: PUSH
62228: LD_VAR 0 3
62232: ARRAY
62233: PUSH
62234: LD_VAR 0 1
62238: DIFF
62239: PPUSH
62240: CALL_OW 1
62244: ST_TO_ADDR
// if building in mc_lab [ i ] then
62245: LD_VAR 0 1
62249: PUSH
62250: LD_EXP 132
62254: PUSH
62255: LD_VAR 0 3
62259: ARRAY
62260: IN
62261: IFFALSE 62316
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62263: LD_ADDR_EXP 133
62267: PUSH
62268: LD_EXP 133
62272: PPUSH
62273: LD_VAR 0 3
62277: PPUSH
62278: LD_EXP 133
62282: PUSH
62283: LD_VAR 0 3
62287: ARRAY
62288: PPUSH
62289: LD_INT 1
62291: PPUSH
62292: LD_EXP 133
62296: PUSH
62297: LD_VAR 0 3
62301: ARRAY
62302: PPUSH
62303: LD_INT 0
62305: PPUSH
62306: CALL 70207 0 4
62310: PPUSH
62311: CALL_OW 1
62315: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62316: LD_VAR 0 1
62320: PUSH
62321: LD_EXP 99
62325: PUSH
62326: LD_VAR 0 3
62330: ARRAY
62331: IN
62332: NOT
62333: IFFALSE 62379
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62335: LD_ADDR_EXP 99
62339: PUSH
62340: LD_EXP 99
62344: PPUSH
62345: LD_VAR 0 3
62349: PUSH
62350: LD_EXP 99
62354: PUSH
62355: LD_VAR 0 3
62359: ARRAY
62360: PUSH
62361: LD_INT 1
62363: PLUS
62364: PUSH
62365: EMPTY
62366: LIST
62367: LIST
62368: PPUSH
62369: LD_VAR 0 1
62373: PPUSH
62374: CALL 70789 0 3
62378: ST_TO_ADDR
// exit ;
62379: POP
62380: POP
62381: GO 62387
// end ; end ;
62383: GO 62187
62385: POP
62386: POP
// end ;
62387: LD_VAR 0 2
62391: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
62392: LD_INT 0
62394: PPUSH
62395: PPUSH
62396: PPUSH
62397: PPUSH
62398: PPUSH
62399: PPUSH
62400: PPUSH
// if not mc_bases or not skirmish then
62401: LD_EXP 99
62405: NOT
62406: PUSH
62407: LD_EXP 97
62411: NOT
62412: OR
62413: IFFALSE 62417
// exit ;
62415: GO 63078
// for i = 1 to mc_bases do
62417: LD_ADDR_VAR 0 3
62421: PUSH
62422: DOUBLE
62423: LD_INT 1
62425: DEC
62426: ST_TO_ADDR
62427: LD_EXP 99
62431: PUSH
62432: FOR_TO
62433: IFFALSE 63076
// begin if building in mc_construct_list [ i ] then
62435: LD_VAR 0 1
62439: PUSH
62440: LD_EXP 106
62444: PUSH
62445: LD_VAR 0 3
62449: ARRAY
62450: IN
62451: IFFALSE 63074
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62453: LD_ADDR_EXP 106
62457: PUSH
62458: LD_EXP 106
62462: PPUSH
62463: LD_VAR 0 3
62467: PPUSH
62468: LD_EXP 106
62472: PUSH
62473: LD_VAR 0 3
62477: ARRAY
62478: PUSH
62479: LD_VAR 0 1
62483: DIFF
62484: PPUSH
62485: CALL_OW 1
62489: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62490: LD_ADDR_EXP 99
62494: PUSH
62495: LD_EXP 99
62499: PPUSH
62500: LD_VAR 0 3
62504: PUSH
62505: LD_EXP 99
62509: PUSH
62510: LD_VAR 0 3
62514: ARRAY
62515: PUSH
62516: LD_INT 1
62518: PLUS
62519: PUSH
62520: EMPTY
62521: LIST
62522: LIST
62523: PPUSH
62524: LD_VAR 0 1
62528: PPUSH
62529: CALL 70789 0 3
62533: ST_TO_ADDR
// btype := GetBType ( building ) ;
62534: LD_ADDR_VAR 0 5
62538: PUSH
62539: LD_VAR 0 1
62543: PPUSH
62544: CALL_OW 266
62548: ST_TO_ADDR
// side := GetSide ( building ) ;
62549: LD_ADDR_VAR 0 8
62553: PUSH
62554: LD_VAR 0 1
62558: PPUSH
62559: CALL_OW 255
62563: ST_TO_ADDR
// if btype = b_lab then
62564: LD_VAR 0 5
62568: PUSH
62569: LD_INT 6
62571: EQUAL
62572: IFFALSE 62622
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
62574: LD_ADDR_EXP 132
62578: PUSH
62579: LD_EXP 132
62583: PPUSH
62584: LD_VAR 0 3
62588: PUSH
62589: LD_EXP 132
62593: PUSH
62594: LD_VAR 0 3
62598: ARRAY
62599: PUSH
62600: LD_INT 1
62602: PLUS
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: PPUSH
62608: LD_VAR 0 1
62612: PPUSH
62613: CALL 70789 0 3
62617: ST_TO_ADDR
// exit ;
62618: POP
62619: POP
62620: GO 63078
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
62622: LD_VAR 0 5
62626: PUSH
62627: LD_INT 0
62629: PUSH
62630: LD_INT 2
62632: PUSH
62633: LD_INT 4
62635: PUSH
62636: EMPTY
62637: LIST
62638: LIST
62639: LIST
62640: IN
62641: IFFALSE 62765
// begin if btype = b_armoury then
62643: LD_VAR 0 5
62647: PUSH
62648: LD_INT 4
62650: EQUAL
62651: IFFALSE 62661
// btype := b_barracks ;
62653: LD_ADDR_VAR 0 5
62657: PUSH
62658: LD_INT 5
62660: ST_TO_ADDR
// if btype = b_depot then
62661: LD_VAR 0 5
62665: PUSH
62666: LD_INT 0
62668: EQUAL
62669: IFFALSE 62679
// btype := b_warehouse ;
62671: LD_ADDR_VAR 0 5
62675: PUSH
62676: LD_INT 1
62678: ST_TO_ADDR
// if btype = b_workshop then
62679: LD_VAR 0 5
62683: PUSH
62684: LD_INT 2
62686: EQUAL
62687: IFFALSE 62697
// btype := b_factory ;
62689: LD_ADDR_VAR 0 5
62693: PUSH
62694: LD_INT 3
62696: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
62697: LD_VAR 0 5
62701: PPUSH
62702: LD_VAR 0 8
62706: PPUSH
62707: CALL_OW 323
62711: PUSH
62712: LD_INT 1
62714: EQUAL
62715: IFFALSE 62761
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
62717: LD_ADDR_EXP 131
62721: PUSH
62722: LD_EXP 131
62726: PPUSH
62727: LD_VAR 0 3
62731: PUSH
62732: LD_EXP 131
62736: PUSH
62737: LD_VAR 0 3
62741: ARRAY
62742: PUSH
62743: LD_INT 1
62745: PLUS
62746: PUSH
62747: EMPTY
62748: LIST
62749: LIST
62750: PPUSH
62751: LD_VAR 0 1
62755: PPUSH
62756: CALL 70789 0 3
62760: ST_TO_ADDR
// exit ;
62761: POP
62762: POP
62763: GO 63078
// end ; if btype in [ b_bunker , b_turret ] then
62765: LD_VAR 0 5
62769: PUSH
62770: LD_INT 32
62772: PUSH
62773: LD_INT 33
62775: PUSH
62776: EMPTY
62777: LIST
62778: LIST
62779: IN
62780: IFFALSE 63070
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
62782: LD_ADDR_EXP 107
62786: PUSH
62787: LD_EXP 107
62791: PPUSH
62792: LD_VAR 0 3
62796: PUSH
62797: LD_EXP 107
62801: PUSH
62802: LD_VAR 0 3
62806: ARRAY
62807: PUSH
62808: LD_INT 1
62810: PLUS
62811: PUSH
62812: EMPTY
62813: LIST
62814: LIST
62815: PPUSH
62816: LD_VAR 0 1
62820: PPUSH
62821: CALL 70789 0 3
62825: ST_TO_ADDR
// if btype = b_bunker then
62826: LD_VAR 0 5
62830: PUSH
62831: LD_INT 32
62833: EQUAL
62834: IFFALSE 63070
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62836: LD_ADDR_EXP 108
62840: PUSH
62841: LD_EXP 108
62845: PPUSH
62846: LD_VAR 0 3
62850: PUSH
62851: LD_EXP 108
62855: PUSH
62856: LD_VAR 0 3
62860: ARRAY
62861: PUSH
62862: LD_INT 1
62864: PLUS
62865: PUSH
62866: EMPTY
62867: LIST
62868: LIST
62869: PPUSH
62870: LD_VAR 0 1
62874: PPUSH
62875: CALL 70789 0 3
62879: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
62880: LD_ADDR_VAR 0 6
62884: PUSH
62885: LD_EXP 99
62889: PUSH
62890: LD_VAR 0 3
62894: ARRAY
62895: PPUSH
62896: LD_INT 25
62898: PUSH
62899: LD_INT 1
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: PUSH
62906: LD_INT 3
62908: PUSH
62909: LD_INT 54
62911: PUSH
62912: EMPTY
62913: LIST
62914: PUSH
62915: EMPTY
62916: LIST
62917: LIST
62918: PUSH
62919: EMPTY
62920: LIST
62921: LIST
62922: PPUSH
62923: CALL_OW 72
62927: ST_TO_ADDR
// if tmp then
62928: LD_VAR 0 6
62932: IFFALSE 62938
// exit ;
62934: POP
62935: POP
62936: GO 63078
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62938: LD_ADDR_VAR 0 6
62942: PUSH
62943: LD_EXP 99
62947: PUSH
62948: LD_VAR 0 3
62952: ARRAY
62953: PPUSH
62954: LD_INT 2
62956: PUSH
62957: LD_INT 30
62959: PUSH
62960: LD_INT 4
62962: PUSH
62963: EMPTY
62964: LIST
62965: LIST
62966: PUSH
62967: LD_INT 30
62969: PUSH
62970: LD_INT 5
62972: PUSH
62973: EMPTY
62974: LIST
62975: LIST
62976: PUSH
62977: EMPTY
62978: LIST
62979: LIST
62980: LIST
62981: PPUSH
62982: CALL_OW 72
62986: ST_TO_ADDR
// if not tmp then
62987: LD_VAR 0 6
62991: NOT
62992: IFFALSE 62998
// exit ;
62994: POP
62995: POP
62996: GO 63078
// for j in tmp do
62998: LD_ADDR_VAR 0 4
63002: PUSH
63003: LD_VAR 0 6
63007: PUSH
63008: FOR_IN
63009: IFFALSE 63068
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
63011: LD_ADDR_VAR 0 7
63015: PUSH
63016: LD_VAR 0 4
63020: PPUSH
63021: CALL_OW 313
63025: PPUSH
63026: LD_INT 25
63028: PUSH
63029: LD_INT 1
63031: PUSH
63032: EMPTY
63033: LIST
63034: LIST
63035: PPUSH
63036: CALL_OW 72
63040: ST_TO_ADDR
// if units then
63041: LD_VAR 0 7
63045: IFFALSE 63066
// begin ComExitBuilding ( units [ 1 ] ) ;
63047: LD_VAR 0 7
63051: PUSH
63052: LD_INT 1
63054: ARRAY
63055: PPUSH
63056: CALL_OW 122
// exit ;
63060: POP
63061: POP
63062: POP
63063: POP
63064: GO 63078
// end ; end ;
63066: GO 63008
63068: POP
63069: POP
// end ; end ; exit ;
63070: POP
63071: POP
63072: GO 63078
// end ; end ;
63074: GO 62432
63076: POP
63077: POP
// end ;
63078: LD_VAR 0 2
63082: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
63083: LD_INT 0
63085: PPUSH
63086: PPUSH
63087: PPUSH
63088: PPUSH
63089: PPUSH
63090: PPUSH
63091: PPUSH
// if not mc_bases or not skirmish then
63092: LD_EXP 99
63096: NOT
63097: PUSH
63098: LD_EXP 97
63102: NOT
63103: OR
63104: IFFALSE 63108
// exit ;
63106: GO 63339
// btype := GetBType ( building ) ;
63108: LD_ADDR_VAR 0 6
63112: PUSH
63113: LD_VAR 0 1
63117: PPUSH
63118: CALL_OW 266
63122: ST_TO_ADDR
// x := GetX ( building ) ;
63123: LD_ADDR_VAR 0 7
63127: PUSH
63128: LD_VAR 0 1
63132: PPUSH
63133: CALL_OW 250
63137: ST_TO_ADDR
// y := GetY ( building ) ;
63138: LD_ADDR_VAR 0 8
63142: PUSH
63143: LD_VAR 0 1
63147: PPUSH
63148: CALL_OW 251
63152: ST_TO_ADDR
// d := GetDir ( building ) ;
63153: LD_ADDR_VAR 0 9
63157: PUSH
63158: LD_VAR 0 1
63162: PPUSH
63163: CALL_OW 254
63167: ST_TO_ADDR
// for i = 1 to mc_bases do
63168: LD_ADDR_VAR 0 4
63172: PUSH
63173: DOUBLE
63174: LD_INT 1
63176: DEC
63177: ST_TO_ADDR
63178: LD_EXP 99
63182: PUSH
63183: FOR_TO
63184: IFFALSE 63337
// begin if not mc_build_list [ i ] then
63186: LD_EXP 104
63190: PUSH
63191: LD_VAR 0 4
63195: ARRAY
63196: NOT
63197: IFFALSE 63201
// continue ;
63199: GO 63183
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63201: LD_VAR 0 6
63205: PUSH
63206: LD_VAR 0 7
63210: PUSH
63211: LD_VAR 0 8
63215: PUSH
63216: LD_VAR 0 9
63220: PUSH
63221: EMPTY
63222: LIST
63223: LIST
63224: LIST
63225: LIST
63226: PPUSH
63227: LD_EXP 104
63231: PUSH
63232: LD_VAR 0 4
63236: ARRAY
63237: PUSH
63238: LD_INT 1
63240: ARRAY
63241: PPUSH
63242: CALL 76958 0 2
63246: IFFALSE 63335
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63248: LD_ADDR_EXP 104
63252: PUSH
63253: LD_EXP 104
63257: PPUSH
63258: LD_VAR 0 4
63262: PPUSH
63263: LD_EXP 104
63267: PUSH
63268: LD_VAR 0 4
63272: ARRAY
63273: PPUSH
63274: LD_INT 1
63276: PPUSH
63277: CALL_OW 3
63281: PPUSH
63282: CALL_OW 1
63286: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63287: LD_ADDR_EXP 106
63291: PUSH
63292: LD_EXP 106
63296: PPUSH
63297: LD_VAR 0 4
63301: PUSH
63302: LD_EXP 106
63306: PUSH
63307: LD_VAR 0 4
63311: ARRAY
63312: PUSH
63313: LD_INT 1
63315: PLUS
63316: PUSH
63317: EMPTY
63318: LIST
63319: LIST
63320: PPUSH
63321: LD_VAR 0 1
63325: PPUSH
63326: CALL 70789 0 3
63330: ST_TO_ADDR
// exit ;
63331: POP
63332: POP
63333: GO 63339
// end ; end ;
63335: GO 63183
63337: POP
63338: POP
// end ;
63339: LD_VAR 0 3
63343: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
63344: LD_INT 0
63346: PPUSH
63347: PPUSH
63348: PPUSH
// if not mc_bases or not skirmish then
63349: LD_EXP 99
63353: NOT
63354: PUSH
63355: LD_EXP 97
63359: NOT
63360: OR
63361: IFFALSE 63365
// exit ;
63363: GO 63555
// for i = 1 to mc_bases do
63365: LD_ADDR_VAR 0 4
63369: PUSH
63370: DOUBLE
63371: LD_INT 1
63373: DEC
63374: ST_TO_ADDR
63375: LD_EXP 99
63379: PUSH
63380: FOR_TO
63381: IFFALSE 63468
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
63383: LD_VAR 0 1
63387: PUSH
63388: LD_EXP 107
63392: PUSH
63393: LD_VAR 0 4
63397: ARRAY
63398: IN
63399: PUSH
63400: LD_VAR 0 1
63404: PUSH
63405: LD_EXP 108
63409: PUSH
63410: LD_VAR 0 4
63414: ARRAY
63415: IN
63416: NOT
63417: AND
63418: IFFALSE 63466
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63420: LD_ADDR_EXP 108
63424: PUSH
63425: LD_EXP 108
63429: PPUSH
63430: LD_VAR 0 4
63434: PUSH
63435: LD_EXP 108
63439: PUSH
63440: LD_VAR 0 4
63444: ARRAY
63445: PUSH
63446: LD_INT 1
63448: PLUS
63449: PUSH
63450: EMPTY
63451: LIST
63452: LIST
63453: PPUSH
63454: LD_VAR 0 1
63458: PPUSH
63459: CALL 70789 0 3
63463: ST_TO_ADDR
// break ;
63464: GO 63468
// end ; end ;
63466: GO 63380
63468: POP
63469: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
63470: LD_VAR 0 1
63474: PPUSH
63475: CALL_OW 257
63479: PUSH
63480: LD_EXP 125
63484: IN
63485: PUSH
63486: LD_VAR 0 1
63490: PPUSH
63491: CALL_OW 266
63495: PUSH
63496: LD_INT 5
63498: EQUAL
63499: AND
63500: PUSH
63501: LD_VAR 0 2
63505: PPUSH
63506: CALL_OW 110
63510: PUSH
63511: LD_INT 18
63513: NONEQUAL
63514: AND
63515: IFFALSE 63555
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
63517: LD_VAR 0 2
63521: PPUSH
63522: CALL_OW 257
63526: PUSH
63527: LD_INT 5
63529: PUSH
63530: LD_INT 8
63532: PUSH
63533: LD_INT 9
63535: PUSH
63536: EMPTY
63537: LIST
63538: LIST
63539: LIST
63540: IN
63541: IFFALSE 63555
// SetClass ( unit , 1 ) ;
63543: LD_VAR 0 2
63547: PPUSH
63548: LD_INT 1
63550: PPUSH
63551: CALL_OW 336
// end ;
63555: LD_VAR 0 3
63559: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
63560: LD_INT 0
63562: PPUSH
63563: PPUSH
// if not mc_bases or not skirmish then
63564: LD_EXP 99
63568: NOT
63569: PUSH
63570: LD_EXP 97
63574: NOT
63575: OR
63576: IFFALSE 63580
// exit ;
63578: GO 63696
// if GetLives ( abandoned_vehicle ) > 250 then
63580: LD_VAR 0 2
63584: PPUSH
63585: CALL_OW 256
63589: PUSH
63590: LD_INT 250
63592: GREATER
63593: IFFALSE 63597
// exit ;
63595: GO 63696
// for i = 1 to mc_bases do
63597: LD_ADDR_VAR 0 6
63601: PUSH
63602: DOUBLE
63603: LD_INT 1
63605: DEC
63606: ST_TO_ADDR
63607: LD_EXP 99
63611: PUSH
63612: FOR_TO
63613: IFFALSE 63694
// begin if driver in mc_bases [ i ] then
63615: LD_VAR 0 1
63619: PUSH
63620: LD_EXP 99
63624: PUSH
63625: LD_VAR 0 6
63629: ARRAY
63630: IN
63631: IFFALSE 63692
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
63633: LD_VAR 0 1
63637: PPUSH
63638: LD_EXP 99
63642: PUSH
63643: LD_VAR 0 6
63647: ARRAY
63648: PPUSH
63649: LD_INT 2
63651: PUSH
63652: LD_INT 30
63654: PUSH
63655: LD_INT 0
63657: PUSH
63658: EMPTY
63659: LIST
63660: LIST
63661: PUSH
63662: LD_INT 30
63664: PUSH
63665: LD_INT 1
63667: PUSH
63668: EMPTY
63669: LIST
63670: LIST
63671: PUSH
63672: EMPTY
63673: LIST
63674: LIST
63675: LIST
63676: PPUSH
63677: CALL_OW 72
63681: PUSH
63682: LD_INT 1
63684: ARRAY
63685: PPUSH
63686: CALL_OW 112
// break ;
63690: GO 63694
// end ; end ;
63692: GO 63612
63694: POP
63695: POP
// end ; end_of_file
63696: LD_VAR 0 5
63700: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
63701: LD_INT 0
63703: PPUSH
63704: PPUSH
// if exist_mode then
63705: LD_VAR 0 2
63709: IFFALSE 63734
// unit := CreateCharacter ( prefix & ident ) else
63711: LD_ADDR_VAR 0 5
63715: PUSH
63716: LD_VAR 0 3
63720: PUSH
63721: LD_VAR 0 1
63725: STR
63726: PPUSH
63727: CALL_OW 34
63731: ST_TO_ADDR
63732: GO 63749
// unit := NewCharacter ( ident ) ;
63734: LD_ADDR_VAR 0 5
63738: PUSH
63739: LD_VAR 0 1
63743: PPUSH
63744: CALL_OW 25
63748: ST_TO_ADDR
// result := unit ;
63749: LD_ADDR_VAR 0 4
63753: PUSH
63754: LD_VAR 0 5
63758: ST_TO_ADDR
// end ;
63759: LD_VAR 0 4
63763: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
63764: LD_INT 0
63766: PPUSH
63767: PPUSH
// if not side or not nation then
63768: LD_VAR 0 1
63772: NOT
63773: PUSH
63774: LD_VAR 0 2
63778: NOT
63779: OR
63780: IFFALSE 63784
// exit ;
63782: GO 64428
// case nation of nation_american :
63784: LD_VAR 0 2
63788: PUSH
63789: LD_INT 1
63791: DOUBLE
63792: EQUAL
63793: IFTRUE 63797
63795: GO 63971
63797: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
63798: LD_ADDR_VAR 0 4
63802: PUSH
63803: LD_INT 35
63805: PUSH
63806: LD_INT 45
63808: PUSH
63809: LD_INT 46
63811: PUSH
63812: LD_INT 47
63814: PUSH
63815: LD_INT 1
63817: PUSH
63818: LD_INT 2
63820: PUSH
63821: LD_INT 6
63823: PUSH
63824: LD_INT 15
63826: PUSH
63827: LD_INT 16
63829: PUSH
63830: LD_INT 7
63832: PUSH
63833: LD_INT 12
63835: PUSH
63836: LD_INT 13
63838: PUSH
63839: LD_INT 10
63841: PUSH
63842: LD_INT 14
63844: PUSH
63845: LD_INT 20
63847: PUSH
63848: LD_INT 21
63850: PUSH
63851: LD_INT 22
63853: PUSH
63854: LD_INT 25
63856: PUSH
63857: LD_INT 32
63859: PUSH
63860: LD_INT 27
63862: PUSH
63863: LD_INT 36
63865: PUSH
63866: LD_INT 69
63868: PUSH
63869: LD_INT 39
63871: PUSH
63872: LD_INT 34
63874: PUSH
63875: LD_INT 40
63877: PUSH
63878: LD_INT 48
63880: PUSH
63881: LD_INT 49
63883: PUSH
63884: LD_INT 50
63886: PUSH
63887: LD_INT 51
63889: PUSH
63890: LD_INT 52
63892: PUSH
63893: LD_INT 53
63895: PUSH
63896: LD_INT 54
63898: PUSH
63899: LD_INT 55
63901: PUSH
63902: LD_INT 56
63904: PUSH
63905: LD_INT 57
63907: PUSH
63908: LD_INT 58
63910: PUSH
63911: LD_INT 59
63913: PUSH
63914: LD_INT 60
63916: PUSH
63917: LD_INT 61
63919: PUSH
63920: LD_INT 62
63922: PUSH
63923: LD_INT 80
63925: PUSH
63926: EMPTY
63927: LIST
63928: LIST
63929: LIST
63930: LIST
63931: LIST
63932: LIST
63933: LIST
63934: LIST
63935: LIST
63936: LIST
63937: LIST
63938: LIST
63939: LIST
63940: LIST
63941: LIST
63942: LIST
63943: LIST
63944: LIST
63945: LIST
63946: LIST
63947: LIST
63948: LIST
63949: LIST
63950: LIST
63951: LIST
63952: LIST
63953: LIST
63954: LIST
63955: LIST
63956: LIST
63957: LIST
63958: LIST
63959: LIST
63960: LIST
63961: LIST
63962: LIST
63963: LIST
63964: LIST
63965: LIST
63966: LIST
63967: LIST
63968: ST_TO_ADDR
63969: GO 64352
63971: LD_INT 2
63973: DOUBLE
63974: EQUAL
63975: IFTRUE 63979
63977: GO 64161
63979: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
63980: LD_ADDR_VAR 0 4
63984: PUSH
63985: LD_INT 35
63987: PUSH
63988: LD_INT 45
63990: PUSH
63991: LD_INT 46
63993: PUSH
63994: LD_INT 47
63996: PUSH
63997: LD_INT 70
63999: PUSH
64000: LD_INT 1
64002: PUSH
64003: LD_INT 11
64005: PUSH
64006: LD_INT 3
64008: PUSH
64009: LD_INT 4
64011: PUSH
64012: LD_INT 5
64014: PUSH
64015: LD_INT 6
64017: PUSH
64018: LD_INT 15
64020: PUSH
64021: LD_INT 18
64023: PUSH
64024: LD_INT 7
64026: PUSH
64027: LD_INT 17
64029: PUSH
64030: LD_INT 8
64032: PUSH
64033: LD_INT 20
64035: PUSH
64036: LD_INT 21
64038: PUSH
64039: LD_INT 22
64041: PUSH
64042: LD_INT 72
64044: PUSH
64045: LD_INT 26
64047: PUSH
64048: LD_INT 69
64050: PUSH
64051: LD_INT 39
64053: PUSH
64054: LD_INT 40
64056: PUSH
64057: LD_INT 41
64059: PUSH
64060: LD_INT 42
64062: PUSH
64063: LD_INT 43
64065: PUSH
64066: LD_INT 48
64068: PUSH
64069: LD_INT 49
64071: PUSH
64072: LD_INT 50
64074: PUSH
64075: LD_INT 51
64077: PUSH
64078: LD_INT 52
64080: PUSH
64081: LD_INT 53
64083: PUSH
64084: LD_INT 54
64086: PUSH
64087: LD_INT 55
64089: PUSH
64090: LD_INT 56
64092: PUSH
64093: LD_INT 60
64095: PUSH
64096: LD_INT 61
64098: PUSH
64099: LD_INT 62
64101: PUSH
64102: LD_INT 66
64104: PUSH
64105: LD_INT 67
64107: PUSH
64108: LD_INT 68
64110: PUSH
64111: LD_INT 81
64113: PUSH
64114: EMPTY
64115: LIST
64116: LIST
64117: LIST
64118: LIST
64119: LIST
64120: LIST
64121: LIST
64122: LIST
64123: LIST
64124: LIST
64125: LIST
64126: LIST
64127: LIST
64128: LIST
64129: LIST
64130: LIST
64131: LIST
64132: LIST
64133: LIST
64134: LIST
64135: LIST
64136: LIST
64137: LIST
64138: LIST
64139: LIST
64140: LIST
64141: LIST
64142: LIST
64143: LIST
64144: LIST
64145: LIST
64146: LIST
64147: LIST
64148: LIST
64149: LIST
64150: LIST
64151: LIST
64152: LIST
64153: LIST
64154: LIST
64155: LIST
64156: LIST
64157: LIST
64158: ST_TO_ADDR
64159: GO 64352
64161: LD_INT 3
64163: DOUBLE
64164: EQUAL
64165: IFTRUE 64169
64167: GO 64351
64169: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64170: LD_ADDR_VAR 0 4
64174: PUSH
64175: LD_INT 46
64177: PUSH
64178: LD_INT 47
64180: PUSH
64181: LD_INT 1
64183: PUSH
64184: LD_INT 2
64186: PUSH
64187: LD_INT 11
64189: PUSH
64190: LD_INT 9
64192: PUSH
64193: LD_INT 20
64195: PUSH
64196: LD_INT 19
64198: PUSH
64199: LD_INT 21
64201: PUSH
64202: LD_INT 24
64204: PUSH
64205: LD_INT 22
64207: PUSH
64208: LD_INT 25
64210: PUSH
64211: LD_INT 28
64213: PUSH
64214: LD_INT 29
64216: PUSH
64217: LD_INT 30
64219: PUSH
64220: LD_INT 31
64222: PUSH
64223: LD_INT 37
64225: PUSH
64226: LD_INT 38
64228: PUSH
64229: LD_INT 32
64231: PUSH
64232: LD_INT 27
64234: PUSH
64235: LD_INT 33
64237: PUSH
64238: LD_INT 69
64240: PUSH
64241: LD_INT 39
64243: PUSH
64244: LD_INT 34
64246: PUSH
64247: LD_INT 40
64249: PUSH
64250: LD_INT 71
64252: PUSH
64253: LD_INT 23
64255: PUSH
64256: LD_INT 44
64258: PUSH
64259: LD_INT 48
64261: PUSH
64262: LD_INT 49
64264: PUSH
64265: LD_INT 50
64267: PUSH
64268: LD_INT 51
64270: PUSH
64271: LD_INT 52
64273: PUSH
64274: LD_INT 53
64276: PUSH
64277: LD_INT 54
64279: PUSH
64280: LD_INT 55
64282: PUSH
64283: LD_INT 56
64285: PUSH
64286: LD_INT 57
64288: PUSH
64289: LD_INT 58
64291: PUSH
64292: LD_INT 59
64294: PUSH
64295: LD_INT 63
64297: PUSH
64298: LD_INT 64
64300: PUSH
64301: LD_INT 65
64303: PUSH
64304: EMPTY
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: LIST
64322: LIST
64323: LIST
64324: LIST
64325: LIST
64326: LIST
64327: LIST
64328: LIST
64329: LIST
64330: LIST
64331: LIST
64332: LIST
64333: LIST
64334: LIST
64335: LIST
64336: LIST
64337: LIST
64338: LIST
64339: LIST
64340: LIST
64341: LIST
64342: LIST
64343: LIST
64344: LIST
64345: LIST
64346: LIST
64347: LIST
64348: ST_TO_ADDR
64349: GO 64352
64351: POP
// if state > - 1 and state < 3 then
64352: LD_VAR 0 3
64356: PUSH
64357: LD_INT 1
64359: NEG
64360: GREATER
64361: PUSH
64362: LD_VAR 0 3
64366: PUSH
64367: LD_INT 3
64369: LESS
64370: AND
64371: IFFALSE 64428
// for i in result do
64373: LD_ADDR_VAR 0 5
64377: PUSH
64378: LD_VAR 0 4
64382: PUSH
64383: FOR_IN
64384: IFFALSE 64426
// if GetTech ( i , side ) <> state then
64386: LD_VAR 0 5
64390: PPUSH
64391: LD_VAR 0 1
64395: PPUSH
64396: CALL_OW 321
64400: PUSH
64401: LD_VAR 0 3
64405: NONEQUAL
64406: IFFALSE 64424
// result := result diff i ;
64408: LD_ADDR_VAR 0 4
64412: PUSH
64413: LD_VAR 0 4
64417: PUSH
64418: LD_VAR 0 5
64422: DIFF
64423: ST_TO_ADDR
64424: GO 64383
64426: POP
64427: POP
// end ;
64428: LD_VAR 0 4
64432: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64433: LD_INT 0
64435: PPUSH
64436: PPUSH
64437: PPUSH
// result := true ;
64438: LD_ADDR_VAR 0 3
64442: PUSH
64443: LD_INT 1
64445: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64446: LD_ADDR_VAR 0 5
64450: PUSH
64451: LD_VAR 0 2
64455: PPUSH
64456: CALL_OW 480
64460: ST_TO_ADDR
// if not tmp then
64461: LD_VAR 0 5
64465: NOT
64466: IFFALSE 64470
// exit ;
64468: GO 64519
// for i in tmp do
64470: LD_ADDR_VAR 0 4
64474: PUSH
64475: LD_VAR 0 5
64479: PUSH
64480: FOR_IN
64481: IFFALSE 64517
// if GetTech ( i , side ) <> state_researched then
64483: LD_VAR 0 4
64487: PPUSH
64488: LD_VAR 0 1
64492: PPUSH
64493: CALL_OW 321
64497: PUSH
64498: LD_INT 2
64500: NONEQUAL
64501: IFFALSE 64515
// begin result := false ;
64503: LD_ADDR_VAR 0 3
64507: PUSH
64508: LD_INT 0
64510: ST_TO_ADDR
// exit ;
64511: POP
64512: POP
64513: GO 64519
// end ;
64515: GO 64480
64517: POP
64518: POP
// end ;
64519: LD_VAR 0 3
64523: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64524: LD_INT 0
64526: PPUSH
64527: PPUSH
64528: PPUSH
64529: PPUSH
64530: PPUSH
64531: PPUSH
64532: PPUSH
64533: PPUSH
64534: PPUSH
64535: PPUSH
64536: PPUSH
64537: PPUSH
64538: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64539: LD_VAR 0 1
64543: NOT
64544: PUSH
64545: LD_VAR 0 1
64549: PPUSH
64550: CALL_OW 257
64554: PUSH
64555: LD_INT 9
64557: NONEQUAL
64558: OR
64559: IFFALSE 64563
// exit ;
64561: GO 65136
// side := GetSide ( unit ) ;
64563: LD_ADDR_VAR 0 9
64567: PUSH
64568: LD_VAR 0 1
64572: PPUSH
64573: CALL_OW 255
64577: ST_TO_ADDR
// tech_space := tech_spacanom ;
64578: LD_ADDR_VAR 0 12
64582: PUSH
64583: LD_INT 29
64585: ST_TO_ADDR
// tech_time := tech_taurad ;
64586: LD_ADDR_VAR 0 13
64590: PUSH
64591: LD_INT 28
64593: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64594: LD_ADDR_VAR 0 11
64598: PUSH
64599: LD_VAR 0 1
64603: PPUSH
64604: CALL_OW 310
64608: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64609: LD_VAR 0 11
64613: PPUSH
64614: CALL_OW 247
64618: PUSH
64619: LD_INT 2
64621: EQUAL
64622: IFFALSE 64626
// exit ;
64624: GO 65136
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64626: LD_ADDR_VAR 0 8
64630: PUSH
64631: LD_INT 81
64633: PUSH
64634: LD_VAR 0 9
64638: PUSH
64639: EMPTY
64640: LIST
64641: LIST
64642: PUSH
64643: LD_INT 3
64645: PUSH
64646: LD_INT 21
64648: PUSH
64649: LD_INT 3
64651: PUSH
64652: EMPTY
64653: LIST
64654: LIST
64655: PUSH
64656: EMPTY
64657: LIST
64658: LIST
64659: PUSH
64660: EMPTY
64661: LIST
64662: LIST
64663: PPUSH
64664: CALL_OW 69
64668: ST_TO_ADDR
// if not tmp then
64669: LD_VAR 0 8
64673: NOT
64674: IFFALSE 64678
// exit ;
64676: GO 65136
// if in_unit then
64678: LD_VAR 0 11
64682: IFFALSE 64706
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
64684: LD_ADDR_VAR 0 10
64688: PUSH
64689: LD_VAR 0 8
64693: PPUSH
64694: LD_VAR 0 11
64698: PPUSH
64699: CALL_OW 74
64703: ST_TO_ADDR
64704: GO 64726
// enemy := NearestUnitToUnit ( tmp , unit ) ;
64706: LD_ADDR_VAR 0 10
64710: PUSH
64711: LD_VAR 0 8
64715: PPUSH
64716: LD_VAR 0 1
64720: PPUSH
64721: CALL_OW 74
64725: ST_TO_ADDR
// if not enemy then
64726: LD_VAR 0 10
64730: NOT
64731: IFFALSE 64735
// exit ;
64733: GO 65136
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
64735: LD_VAR 0 11
64739: PUSH
64740: LD_VAR 0 11
64744: PPUSH
64745: LD_VAR 0 10
64749: PPUSH
64750: CALL_OW 296
64754: PUSH
64755: LD_INT 13
64757: GREATER
64758: AND
64759: PUSH
64760: LD_VAR 0 1
64764: PPUSH
64765: LD_VAR 0 10
64769: PPUSH
64770: CALL_OW 296
64774: PUSH
64775: LD_INT 12
64777: GREATER
64778: OR
64779: IFFALSE 64783
// exit ;
64781: GO 65136
// missile := [ 1 ] ;
64783: LD_ADDR_VAR 0 14
64787: PUSH
64788: LD_INT 1
64790: PUSH
64791: EMPTY
64792: LIST
64793: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64794: LD_VAR 0 9
64798: PPUSH
64799: LD_VAR 0 12
64803: PPUSH
64804: CALL_OW 325
64808: IFFALSE 64837
// missile := Insert ( missile , missile + 1 , 2 ) ;
64810: LD_ADDR_VAR 0 14
64814: PUSH
64815: LD_VAR 0 14
64819: PPUSH
64820: LD_VAR 0 14
64824: PUSH
64825: LD_INT 1
64827: PLUS
64828: PPUSH
64829: LD_INT 2
64831: PPUSH
64832: CALL_OW 2
64836: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64837: LD_VAR 0 9
64841: PPUSH
64842: LD_VAR 0 13
64846: PPUSH
64847: CALL_OW 325
64851: PUSH
64852: LD_VAR 0 10
64856: PPUSH
64857: CALL_OW 255
64861: PPUSH
64862: LD_VAR 0 13
64866: PPUSH
64867: CALL_OW 325
64871: NOT
64872: AND
64873: IFFALSE 64902
// missile := Insert ( missile , missile + 1 , 3 ) ;
64875: LD_ADDR_VAR 0 14
64879: PUSH
64880: LD_VAR 0 14
64884: PPUSH
64885: LD_VAR 0 14
64889: PUSH
64890: LD_INT 1
64892: PLUS
64893: PPUSH
64894: LD_INT 3
64896: PPUSH
64897: CALL_OW 2
64901: ST_TO_ADDR
// if missile < 2 then
64902: LD_VAR 0 14
64906: PUSH
64907: LD_INT 2
64909: LESS
64910: IFFALSE 64914
// exit ;
64912: GO 65136
// x := GetX ( enemy ) ;
64914: LD_ADDR_VAR 0 4
64918: PUSH
64919: LD_VAR 0 10
64923: PPUSH
64924: CALL_OW 250
64928: ST_TO_ADDR
// y := GetY ( enemy ) ;
64929: LD_ADDR_VAR 0 5
64933: PUSH
64934: LD_VAR 0 10
64938: PPUSH
64939: CALL_OW 251
64943: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64944: LD_ADDR_VAR 0 6
64948: PUSH
64949: LD_VAR 0 4
64953: PUSH
64954: LD_INT 1
64956: NEG
64957: PPUSH
64958: LD_INT 1
64960: PPUSH
64961: CALL_OW 12
64965: PLUS
64966: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64967: LD_ADDR_VAR 0 7
64971: PUSH
64972: LD_VAR 0 5
64976: PUSH
64977: LD_INT 1
64979: NEG
64980: PPUSH
64981: LD_INT 1
64983: PPUSH
64984: CALL_OW 12
64988: PLUS
64989: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64990: LD_VAR 0 6
64994: PPUSH
64995: LD_VAR 0 7
64999: PPUSH
65000: CALL_OW 488
65004: NOT
65005: IFFALSE 65027
// begin _x := x ;
65007: LD_ADDR_VAR 0 6
65011: PUSH
65012: LD_VAR 0 4
65016: ST_TO_ADDR
// _y := y ;
65017: LD_ADDR_VAR 0 7
65021: PUSH
65022: LD_VAR 0 5
65026: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65027: LD_ADDR_VAR 0 3
65031: PUSH
65032: LD_INT 1
65034: PPUSH
65035: LD_VAR 0 14
65039: PPUSH
65040: CALL_OW 12
65044: ST_TO_ADDR
// case i of 1 :
65045: LD_VAR 0 3
65049: PUSH
65050: LD_INT 1
65052: DOUBLE
65053: EQUAL
65054: IFTRUE 65058
65056: GO 65075
65058: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65059: LD_VAR 0 1
65063: PPUSH
65064: LD_VAR 0 10
65068: PPUSH
65069: CALL_OW 115
65073: GO 65136
65075: LD_INT 2
65077: DOUBLE
65078: EQUAL
65079: IFTRUE 65083
65081: GO 65105
65083: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65084: LD_VAR 0 1
65088: PPUSH
65089: LD_VAR 0 6
65093: PPUSH
65094: LD_VAR 0 7
65098: PPUSH
65099: CALL_OW 153
65103: GO 65136
65105: LD_INT 3
65107: DOUBLE
65108: EQUAL
65109: IFTRUE 65113
65111: GO 65135
65113: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65114: LD_VAR 0 1
65118: PPUSH
65119: LD_VAR 0 6
65123: PPUSH
65124: LD_VAR 0 7
65128: PPUSH
65129: CALL_OW 154
65133: GO 65136
65135: POP
// end ;
65136: LD_VAR 0 2
65140: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65141: LD_INT 0
65143: PPUSH
65144: PPUSH
65145: PPUSH
65146: PPUSH
65147: PPUSH
65148: PPUSH
// if not unit or not building then
65149: LD_VAR 0 1
65153: NOT
65154: PUSH
65155: LD_VAR 0 2
65159: NOT
65160: OR
65161: IFFALSE 65165
// exit ;
65163: GO 65323
// x := GetX ( building ) ;
65165: LD_ADDR_VAR 0 5
65169: PUSH
65170: LD_VAR 0 2
65174: PPUSH
65175: CALL_OW 250
65179: ST_TO_ADDR
// y := GetY ( building ) ;
65180: LD_ADDR_VAR 0 6
65184: PUSH
65185: LD_VAR 0 2
65189: PPUSH
65190: CALL_OW 251
65194: ST_TO_ADDR
// for i = 0 to 5 do
65195: LD_ADDR_VAR 0 4
65199: PUSH
65200: DOUBLE
65201: LD_INT 0
65203: DEC
65204: ST_TO_ADDR
65205: LD_INT 5
65207: PUSH
65208: FOR_TO
65209: IFFALSE 65321
// begin _x := ShiftX ( x , i , 3 ) ;
65211: LD_ADDR_VAR 0 7
65215: PUSH
65216: LD_VAR 0 5
65220: PPUSH
65221: LD_VAR 0 4
65225: PPUSH
65226: LD_INT 3
65228: PPUSH
65229: CALL_OW 272
65233: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65234: LD_ADDR_VAR 0 8
65238: PUSH
65239: LD_VAR 0 6
65243: PPUSH
65244: LD_VAR 0 4
65248: PPUSH
65249: LD_INT 3
65251: PPUSH
65252: CALL_OW 273
65256: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65257: LD_VAR 0 7
65261: PPUSH
65262: LD_VAR 0 8
65266: PPUSH
65267: CALL_OW 488
65271: NOT
65272: IFFALSE 65276
// continue ;
65274: GO 65208
// if HexInfo ( _x , _y ) = 0 then
65276: LD_VAR 0 7
65280: PPUSH
65281: LD_VAR 0 8
65285: PPUSH
65286: CALL_OW 428
65290: PUSH
65291: LD_INT 0
65293: EQUAL
65294: IFFALSE 65319
// begin ComMoveXY ( unit , _x , _y ) ;
65296: LD_VAR 0 1
65300: PPUSH
65301: LD_VAR 0 7
65305: PPUSH
65306: LD_VAR 0 8
65310: PPUSH
65311: CALL_OW 111
// exit ;
65315: POP
65316: POP
65317: GO 65323
// end ; end ;
65319: GO 65208
65321: POP
65322: POP
// end ;
65323: LD_VAR 0 3
65327: RET
// export function ScanBase ( side , base_area ) ; begin
65328: LD_INT 0
65330: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65331: LD_ADDR_VAR 0 3
65335: PUSH
65336: LD_VAR 0 2
65340: PPUSH
65341: LD_INT 81
65343: PUSH
65344: LD_VAR 0 1
65348: PUSH
65349: EMPTY
65350: LIST
65351: LIST
65352: PPUSH
65353: CALL_OW 70
65357: ST_TO_ADDR
// end ;
65358: LD_VAR 0 3
65362: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
65363: LD_INT 0
65365: PPUSH
65366: PPUSH
65367: PPUSH
65368: PPUSH
65369: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
65370: LD_VAR 0 1
65374: NOT
65375: PUSH
65376: LD_EXP 99
65380: PUSH
65381: LD_VAR 0 1
65385: ARRAY
65386: NOT
65387: OR
65388: PUSH
65389: LD_VAR 0 2
65393: NOT
65394: OR
65395: PUSH
65396: LD_VAR 0 3
65400: NOT
65401: OR
65402: IFFALSE 65406
// exit ;
65404: GO 65919
// side := mc_sides [ base ] ;
65406: LD_ADDR_VAR 0 6
65410: PUSH
65411: LD_EXP 125
65415: PUSH
65416: LD_VAR 0 1
65420: ARRAY
65421: ST_TO_ADDR
// if not side then
65422: LD_VAR 0 6
65426: NOT
65427: IFFALSE 65431
// exit ;
65429: GO 65919
// for i in solds do
65431: LD_ADDR_VAR 0 7
65435: PUSH
65436: LD_VAR 0 2
65440: PUSH
65441: FOR_IN
65442: IFFALSE 65503
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
65444: LD_VAR 0 7
65448: PPUSH
65449: CALL_OW 310
65453: PPUSH
65454: CALL_OW 266
65458: PUSH
65459: LD_INT 32
65461: PUSH
65462: LD_INT 31
65464: PUSH
65465: EMPTY
65466: LIST
65467: LIST
65468: IN
65469: IFFALSE 65489
// solds := solds diff i else
65471: LD_ADDR_VAR 0 2
65475: PUSH
65476: LD_VAR 0 2
65480: PUSH
65481: LD_VAR 0 7
65485: DIFF
65486: ST_TO_ADDR
65487: GO 65501
// SetTag ( i , 18 ) ;
65489: LD_VAR 0 7
65493: PPUSH
65494: LD_INT 18
65496: PPUSH
65497: CALL_OW 109
65501: GO 65441
65503: POP
65504: POP
// if not solds then
65505: LD_VAR 0 2
65509: NOT
65510: IFFALSE 65514
// exit ;
65512: GO 65919
// repeat wait ( 0 0$1 ) ;
65514: LD_INT 35
65516: PPUSH
65517: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
65521: LD_ADDR_VAR 0 5
65525: PUSH
65526: LD_VAR 0 6
65530: PPUSH
65531: LD_VAR 0 3
65535: PPUSH
65536: CALL 65328 0 2
65540: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
65541: LD_EXP 99
65545: PUSH
65546: LD_VAR 0 1
65550: ARRAY
65551: NOT
65552: PUSH
65553: LD_EXP 99
65557: PUSH
65558: LD_VAR 0 1
65562: ARRAY
65563: PUSH
65564: EMPTY
65565: EQUAL
65566: OR
65567: IFFALSE 65604
// begin for i in solds do
65569: LD_ADDR_VAR 0 7
65573: PUSH
65574: LD_VAR 0 2
65578: PUSH
65579: FOR_IN
65580: IFFALSE 65593
// ComStop ( i ) ;
65582: LD_VAR 0 7
65586: PPUSH
65587: CALL_OW 141
65591: GO 65579
65593: POP
65594: POP
// solds := [ ] ;
65595: LD_ADDR_VAR 0 2
65599: PUSH
65600: EMPTY
65601: ST_TO_ADDR
// exit ;
65602: GO 65919
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
65604: LD_VAR 0 5
65608: NOT
65609: PUSH
65610: LD_VAR 0 5
65614: PUSH
65615: LD_INT 3
65617: GREATER
65618: OR
65619: PUSH
65620: LD_EXP 121
65624: PUSH
65625: LD_VAR 0 1
65629: ARRAY
65630: OR
65631: IFFALSE 65672
// begin for i in solds do
65633: LD_ADDR_VAR 0 7
65637: PUSH
65638: LD_VAR 0 2
65642: PUSH
65643: FOR_IN
65644: IFFALSE 65668
// if HasTask ( i ) then
65646: LD_VAR 0 7
65650: PPUSH
65651: CALL_OW 314
65655: IFFALSE 65666
// ComStop ( i ) ;
65657: LD_VAR 0 7
65661: PPUSH
65662: CALL_OW 141
65666: GO 65643
65668: POP
65669: POP
// break ;
65670: GO 65907
// end ; for i in solds do
65672: LD_ADDR_VAR 0 7
65676: PUSH
65677: LD_VAR 0 2
65681: PUSH
65682: FOR_IN
65683: IFFALSE 65899
// begin if IsInUnit ( i ) then
65685: LD_VAR 0 7
65689: PPUSH
65690: CALL_OW 310
65694: IFFALSE 65705
// ComExitBuilding ( i ) ;
65696: LD_VAR 0 7
65700: PPUSH
65701: CALL_OW 122
// if GetLives ( i ) > 333 then
65705: LD_VAR 0 7
65709: PPUSH
65710: CALL_OW 256
65714: PUSH
65715: LD_INT 333
65717: GREATER
65718: IFFALSE 65746
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
65720: LD_VAR 0 7
65724: PPUSH
65725: LD_VAR 0 5
65729: PPUSH
65730: LD_VAR 0 7
65734: PPUSH
65735: CALL_OW 74
65739: PPUSH
65740: CALL_OW 115
65744: GO 65897
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
65746: LD_ADDR_VAR 0 8
65750: PUSH
65751: LD_EXP 99
65755: PUSH
65756: LD_VAR 0 1
65760: ARRAY
65761: PPUSH
65762: LD_INT 2
65764: PUSH
65765: LD_INT 30
65767: PUSH
65768: LD_INT 0
65770: PUSH
65771: EMPTY
65772: LIST
65773: LIST
65774: PUSH
65775: LD_INT 30
65777: PUSH
65778: LD_INT 1
65780: PUSH
65781: EMPTY
65782: LIST
65783: LIST
65784: PUSH
65785: LD_INT 30
65787: PUSH
65788: LD_INT 6
65790: PUSH
65791: EMPTY
65792: LIST
65793: LIST
65794: PUSH
65795: EMPTY
65796: LIST
65797: LIST
65798: LIST
65799: LIST
65800: PPUSH
65801: CALL_OW 72
65805: PPUSH
65806: LD_VAR 0 7
65810: PPUSH
65811: CALL_OW 74
65815: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
65816: LD_VAR 0 7
65820: PPUSH
65821: LD_VAR 0 8
65825: PPUSH
65826: CALL_OW 250
65830: PPUSH
65831: LD_INT 3
65833: PPUSH
65834: LD_INT 5
65836: PPUSH
65837: CALL_OW 272
65841: PPUSH
65842: LD_VAR 0 8
65846: PPUSH
65847: CALL_OW 251
65851: PPUSH
65852: LD_INT 3
65854: PPUSH
65855: LD_INT 5
65857: PPUSH
65858: CALL_OW 273
65862: PPUSH
65863: CALL_OW 111
// SetTag ( i , 0 ) ;
65867: LD_VAR 0 7
65871: PPUSH
65872: LD_INT 0
65874: PPUSH
65875: CALL_OW 109
// solds := solds diff i ;
65879: LD_ADDR_VAR 0 2
65883: PUSH
65884: LD_VAR 0 2
65888: PUSH
65889: LD_VAR 0 7
65893: DIFF
65894: ST_TO_ADDR
// continue ;
65895: GO 65682
// end ; end ;
65897: GO 65682
65899: POP
65900: POP
// until solds ;
65901: LD_VAR 0 2
65905: IFFALSE 65514
// MC_Reset ( base , 18 ) ;
65907: LD_VAR 0 1
65911: PPUSH
65912: LD_INT 18
65914: PPUSH
65915: CALL 37986 0 2
// end ;
65919: LD_VAR 0 4
65923: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
65924: LD_INT 0
65926: PPUSH
65927: PPUSH
65928: PPUSH
65929: PPUSH
65930: PPUSH
65931: PPUSH
65932: PPUSH
65933: PPUSH
65934: PPUSH
65935: PPUSH
65936: PPUSH
65937: PPUSH
65938: PPUSH
65939: PPUSH
65940: PPUSH
65941: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65942: LD_ADDR_VAR 0 12
65946: PUSH
65947: LD_EXP 99
65951: PUSH
65952: LD_VAR 0 1
65956: ARRAY
65957: PPUSH
65958: LD_INT 25
65960: PUSH
65961: LD_INT 3
65963: PUSH
65964: EMPTY
65965: LIST
65966: LIST
65967: PPUSH
65968: CALL_OW 72
65972: ST_TO_ADDR
// if mc_remote_driver [ base ] then
65973: LD_EXP 139
65977: PUSH
65978: LD_VAR 0 1
65982: ARRAY
65983: IFFALSE 66007
// mechs := mechs diff mc_remote_driver [ base ] ;
65985: LD_ADDR_VAR 0 12
65989: PUSH
65990: LD_VAR 0 12
65994: PUSH
65995: LD_EXP 139
65999: PUSH
66000: LD_VAR 0 1
66004: ARRAY
66005: DIFF
66006: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66007: LD_ADDR_VAR 0 8
66011: PUSH
66012: LD_EXP 99
66016: PUSH
66017: LD_VAR 0 1
66021: ARRAY
66022: PPUSH
66023: LD_INT 2
66025: PUSH
66026: LD_INT 25
66028: PUSH
66029: LD_INT 1
66031: PUSH
66032: EMPTY
66033: LIST
66034: LIST
66035: PUSH
66036: LD_INT 25
66038: PUSH
66039: LD_INT 5
66041: PUSH
66042: EMPTY
66043: LIST
66044: LIST
66045: PUSH
66046: LD_INT 25
66048: PUSH
66049: LD_INT 8
66051: PUSH
66052: EMPTY
66053: LIST
66054: LIST
66055: PUSH
66056: LD_INT 25
66058: PUSH
66059: LD_INT 9
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: PUSH
66066: EMPTY
66067: LIST
66068: LIST
66069: LIST
66070: LIST
66071: LIST
66072: PPUSH
66073: CALL_OW 72
66077: ST_TO_ADDR
// if not defenders and not solds then
66078: LD_VAR 0 2
66082: NOT
66083: PUSH
66084: LD_VAR 0 8
66088: NOT
66089: AND
66090: IFFALSE 66094
// exit ;
66092: GO 67620
// depot_under_attack := false ;
66094: LD_ADDR_VAR 0 16
66098: PUSH
66099: LD_INT 0
66101: ST_TO_ADDR
// sold_defenders := [ ] ;
66102: LD_ADDR_VAR 0 17
66106: PUSH
66107: EMPTY
66108: ST_TO_ADDR
// if mechs then
66109: LD_VAR 0 12
66113: IFFALSE 66242
// for i in defenders do
66115: LD_ADDR_VAR 0 5
66119: PUSH
66120: LD_VAR 0 2
66124: PUSH
66125: FOR_IN
66126: IFFALSE 66240
// begin SetTag ( i , 20 ) ;
66128: LD_VAR 0 5
66132: PPUSH
66133: LD_INT 20
66135: PPUSH
66136: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
66140: LD_VAR 0 5
66144: PPUSH
66145: CALL_OW 263
66149: PUSH
66150: LD_INT 1
66152: EQUAL
66153: PUSH
66154: LD_VAR 0 5
66158: PPUSH
66159: CALL_OW 311
66163: NOT
66164: AND
66165: PUSH
66166: LD_VAR 0 12
66170: AND
66171: IFFALSE 66238
// begin un := mechs [ 1 ] ;
66173: LD_ADDR_VAR 0 10
66177: PUSH
66178: LD_VAR 0 12
66182: PUSH
66183: LD_INT 1
66185: ARRAY
66186: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66187: LD_VAR 0 10
66191: PPUSH
66192: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66196: LD_VAR 0 10
66200: PPUSH
66201: LD_VAR 0 5
66205: PPUSH
66206: CALL_OW 180
// SetTag ( un , 19 ) ;
66210: LD_VAR 0 10
66214: PPUSH
66215: LD_INT 19
66217: PPUSH
66218: CALL_OW 109
// mechs := mechs diff un ;
66222: LD_ADDR_VAR 0 12
66226: PUSH
66227: LD_VAR 0 12
66231: PUSH
66232: LD_VAR 0 10
66236: DIFF
66237: ST_TO_ADDR
// end ; end ;
66238: GO 66125
66240: POP
66241: POP
// if solds then
66242: LD_VAR 0 8
66246: IFFALSE 66305
// for i in solds do
66248: LD_ADDR_VAR 0 5
66252: PUSH
66253: LD_VAR 0 8
66257: PUSH
66258: FOR_IN
66259: IFFALSE 66303
// if not GetTag ( i ) then
66261: LD_VAR 0 5
66265: PPUSH
66266: CALL_OW 110
66270: NOT
66271: IFFALSE 66301
// begin defenders := defenders union i ;
66273: LD_ADDR_VAR 0 2
66277: PUSH
66278: LD_VAR 0 2
66282: PUSH
66283: LD_VAR 0 5
66287: UNION
66288: ST_TO_ADDR
// SetTag ( i , 18 ) ;
66289: LD_VAR 0 5
66293: PPUSH
66294: LD_INT 18
66296: PPUSH
66297: CALL_OW 109
// end ;
66301: GO 66258
66303: POP
66304: POP
// repeat wait ( 0 0$1 ) ;
66305: LD_INT 35
66307: PPUSH
66308: CALL_OW 67
// enemy := mc_scan [ base ] ;
66312: LD_ADDR_VAR 0 3
66316: PUSH
66317: LD_EXP 122
66321: PUSH
66322: LD_VAR 0 1
66326: ARRAY
66327: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66328: LD_EXP 99
66332: PUSH
66333: LD_VAR 0 1
66337: ARRAY
66338: NOT
66339: PUSH
66340: LD_EXP 99
66344: PUSH
66345: LD_VAR 0 1
66349: ARRAY
66350: PUSH
66351: EMPTY
66352: EQUAL
66353: OR
66354: IFFALSE 66391
// begin for i in defenders do
66356: LD_ADDR_VAR 0 5
66360: PUSH
66361: LD_VAR 0 2
66365: PUSH
66366: FOR_IN
66367: IFFALSE 66380
// ComStop ( i ) ;
66369: LD_VAR 0 5
66373: PPUSH
66374: CALL_OW 141
66378: GO 66366
66380: POP
66381: POP
// defenders := [ ] ;
66382: LD_ADDR_VAR 0 2
66386: PUSH
66387: EMPTY
66388: ST_TO_ADDR
// exit ;
66389: GO 67620
// end ; for i in defenders do
66391: LD_ADDR_VAR 0 5
66395: PUSH
66396: LD_VAR 0 2
66400: PUSH
66401: FOR_IN
66402: IFFALSE 67132
// begin e := NearestUnitToUnit ( enemy , i ) ;
66404: LD_ADDR_VAR 0 13
66408: PUSH
66409: LD_VAR 0 3
66413: PPUSH
66414: LD_VAR 0 5
66418: PPUSH
66419: CALL_OW 74
66423: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
66424: LD_ADDR_VAR 0 16
66428: PUSH
66429: LD_EXP 99
66433: PUSH
66434: LD_VAR 0 1
66438: ARRAY
66439: PPUSH
66440: LD_INT 2
66442: PUSH
66443: LD_INT 30
66445: PUSH
66446: LD_INT 0
66448: PUSH
66449: EMPTY
66450: LIST
66451: LIST
66452: PUSH
66453: LD_INT 30
66455: PUSH
66456: LD_INT 1
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: LIST
66467: PPUSH
66468: CALL_OW 72
66472: NOT
66473: PUSH
66474: LD_EXP 99
66478: PUSH
66479: LD_VAR 0 1
66483: ARRAY
66484: PPUSH
66485: LD_INT 2
66487: PUSH
66488: LD_INT 30
66490: PUSH
66491: LD_INT 0
66493: PUSH
66494: EMPTY
66495: LIST
66496: LIST
66497: PUSH
66498: LD_INT 30
66500: PUSH
66501: LD_INT 1
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: LIST
66512: PPUSH
66513: CALL_OW 72
66517: PPUSH
66518: CALL_OW 256
66522: PUSH
66523: LD_INT 600
66525: LESS
66526: OR
66527: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
66528: LD_VAR 0 5
66532: PPUSH
66533: CALL_OW 247
66537: PUSH
66538: LD_INT 2
66540: DOUBLE
66541: EQUAL
66542: IFTRUE 66546
66544: GO 66838
66546: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
66547: LD_VAR 0 5
66551: PPUSH
66552: CALL_OW 256
66556: PUSH
66557: LD_INT 650
66559: GREATER
66560: PUSH
66561: LD_VAR 0 5
66565: PPUSH
66566: LD_VAR 0 13
66570: PPUSH
66571: CALL_OW 296
66575: PUSH
66576: LD_INT 40
66578: LESS
66579: PUSH
66580: LD_VAR 0 13
66584: PPUSH
66585: LD_EXP 124
66589: PUSH
66590: LD_VAR 0 1
66594: ARRAY
66595: PPUSH
66596: CALL_OW 308
66600: OR
66601: AND
66602: IFFALSE 66620
// ComAttackUnit ( i , e ) else
66604: LD_VAR 0 5
66608: PPUSH
66609: LD_VAR 0 13
66613: PPUSH
66614: CALL_OW 115
66618: GO 66721
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
66620: LD_VAR 0 13
66624: PPUSH
66625: LD_EXP 124
66629: PUSH
66630: LD_VAR 0 1
66634: ARRAY
66635: PPUSH
66636: CALL_OW 308
66640: NOT
66641: PUSH
66642: LD_VAR 0 5
66646: PPUSH
66647: LD_VAR 0 13
66651: PPUSH
66652: CALL_OW 296
66656: PUSH
66657: LD_INT 40
66659: GREATEREQUAL
66660: AND
66661: PUSH
66662: LD_VAR 0 5
66666: PPUSH
66667: CALL_OW 256
66671: PUSH
66672: LD_INT 650
66674: LESSEQUAL
66675: OR
66676: PUSH
66677: LD_VAR 0 5
66681: PPUSH
66682: LD_EXP 123
66686: PUSH
66687: LD_VAR 0 1
66691: ARRAY
66692: PPUSH
66693: CALL_OW 308
66697: NOT
66698: AND
66699: IFFALSE 66721
// ComMoveToArea ( i , mc_parking [ base ] ) ;
66701: LD_VAR 0 5
66705: PPUSH
66706: LD_EXP 123
66710: PUSH
66711: LD_VAR 0 1
66715: ARRAY
66716: PPUSH
66717: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
66721: LD_VAR 0 5
66725: PPUSH
66726: CALL_OW 256
66730: PUSH
66731: LD_INT 998
66733: LESS
66734: PUSH
66735: LD_VAR 0 5
66739: PPUSH
66740: CALL_OW 263
66744: PUSH
66745: LD_INT 1
66747: EQUAL
66748: AND
66749: PUSH
66750: LD_VAR 0 5
66754: PPUSH
66755: CALL_OW 311
66759: AND
66760: PUSH
66761: LD_VAR 0 5
66765: PPUSH
66766: LD_EXP 123
66770: PUSH
66771: LD_VAR 0 1
66775: ARRAY
66776: PPUSH
66777: CALL_OW 308
66781: AND
66782: IFFALSE 66836
// begin mech := IsDrivenBy ( i ) ;
66784: LD_ADDR_VAR 0 9
66788: PUSH
66789: LD_VAR 0 5
66793: PPUSH
66794: CALL_OW 311
66798: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
66799: LD_VAR 0 9
66803: PPUSH
66804: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
66808: LD_VAR 0 9
66812: PPUSH
66813: LD_VAR 0 5
66817: PPUSH
66818: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
66822: LD_VAR 0 9
66826: PPUSH
66827: LD_VAR 0 5
66831: PPUSH
66832: CALL_OW 180
// end ; end ; unit_human :
66836: GO 67103
66838: LD_INT 1
66840: DOUBLE
66841: EQUAL
66842: IFTRUE 66846
66844: GO 67102
66846: POP
// begin b := IsInUnit ( i ) ;
66847: LD_ADDR_VAR 0 18
66851: PUSH
66852: LD_VAR 0 5
66856: PPUSH
66857: CALL_OW 310
66861: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
66862: LD_ADDR_VAR 0 19
66866: PUSH
66867: LD_VAR 0 18
66871: NOT
66872: PUSH
66873: LD_VAR 0 18
66877: PPUSH
66878: CALL_OW 266
66882: PUSH
66883: LD_INT 32
66885: PUSH
66886: LD_INT 31
66888: PUSH
66889: EMPTY
66890: LIST
66891: LIST
66892: IN
66893: OR
66894: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
66895: LD_VAR 0 16
66899: PUSH
66900: LD_VAR 0 2
66904: PPUSH
66905: LD_INT 21
66907: PUSH
66908: LD_INT 2
66910: PUSH
66911: EMPTY
66912: LIST
66913: LIST
66914: PPUSH
66915: CALL_OW 72
66919: PUSH
66920: LD_INT 1
66922: LESSEQUAL
66923: OR
66924: PUSH
66925: LD_VAR 0 19
66929: AND
66930: PUSH
66931: LD_VAR 0 5
66935: PUSH
66936: LD_VAR 0 17
66940: IN
66941: NOT
66942: AND
66943: IFFALSE 67036
// begin if b then
66945: LD_VAR 0 18
66949: IFFALSE 66998
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
66951: LD_VAR 0 18
66955: PPUSH
66956: LD_VAR 0 3
66960: PPUSH
66961: LD_VAR 0 18
66965: PPUSH
66966: CALL_OW 74
66970: PPUSH
66971: CALL_OW 296
66975: PUSH
66976: LD_INT 10
66978: LESS
66979: PUSH
66980: LD_VAR 0 18
66984: PPUSH
66985: CALL_OW 461
66989: PUSH
66990: LD_INT 7
66992: NONEQUAL
66993: AND
66994: IFFALSE 66998
// continue ;
66996: GO 66401
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
66998: LD_ADDR_VAR 0 17
67002: PUSH
67003: LD_VAR 0 17
67007: PPUSH
67008: LD_VAR 0 17
67012: PUSH
67013: LD_INT 1
67015: PLUS
67016: PPUSH
67017: LD_VAR 0 5
67021: PPUSH
67022: CALL_OW 1
67026: ST_TO_ADDR
// ComExitBuilding ( i ) ;
67027: LD_VAR 0 5
67031: PPUSH
67032: CALL_OW 122
// end ; if sold_defenders then
67036: LD_VAR 0 17
67040: IFFALSE 67100
// if i in sold_defenders then
67042: LD_VAR 0 5
67046: PUSH
67047: LD_VAR 0 17
67051: IN
67052: IFFALSE 67100
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
67054: LD_VAR 0 5
67058: PPUSH
67059: CALL_OW 314
67063: NOT
67064: PUSH
67065: LD_VAR 0 5
67069: PPUSH
67070: LD_VAR 0 13
67074: PPUSH
67075: CALL_OW 296
67079: PUSH
67080: LD_INT 30
67082: LESS
67083: AND
67084: IFFALSE 67100
// ComAttackUnit ( i , e ) ;
67086: LD_VAR 0 5
67090: PPUSH
67091: LD_VAR 0 13
67095: PPUSH
67096: CALL_OW 115
// end ; end ; end ;
67100: GO 67103
67102: POP
// if IsDead ( i ) then
67103: LD_VAR 0 5
67107: PPUSH
67108: CALL_OW 301
67112: IFFALSE 67130
// defenders := defenders diff i ;
67114: LD_ADDR_VAR 0 2
67118: PUSH
67119: LD_VAR 0 2
67123: PUSH
67124: LD_VAR 0 5
67128: DIFF
67129: ST_TO_ADDR
// end ;
67130: GO 66401
67132: POP
67133: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
67134: LD_VAR 0 3
67138: NOT
67139: PUSH
67140: LD_VAR 0 2
67144: NOT
67145: OR
67146: PUSH
67147: LD_EXP 99
67151: PUSH
67152: LD_VAR 0 1
67156: ARRAY
67157: NOT
67158: OR
67159: IFFALSE 66305
// MC_Reset ( base , 18 ) ;
67161: LD_VAR 0 1
67165: PPUSH
67166: LD_INT 18
67168: PPUSH
67169: CALL 37986 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67173: LD_ADDR_VAR 0 2
67177: PUSH
67178: LD_VAR 0 2
67182: PUSH
67183: LD_VAR 0 2
67187: PPUSH
67188: LD_INT 2
67190: PUSH
67191: LD_INT 25
67193: PUSH
67194: LD_INT 1
67196: PUSH
67197: EMPTY
67198: LIST
67199: LIST
67200: PUSH
67201: LD_INT 25
67203: PUSH
67204: LD_INT 5
67206: PUSH
67207: EMPTY
67208: LIST
67209: LIST
67210: PUSH
67211: LD_INT 25
67213: PUSH
67214: LD_INT 8
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 25
67223: PUSH
67224: LD_INT 9
67226: PUSH
67227: EMPTY
67228: LIST
67229: LIST
67230: PUSH
67231: EMPTY
67232: LIST
67233: LIST
67234: LIST
67235: LIST
67236: LIST
67237: PPUSH
67238: CALL_OW 72
67242: DIFF
67243: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
67244: LD_VAR 0 3
67248: NOT
67249: PUSH
67250: LD_VAR 0 2
67254: PPUSH
67255: LD_INT 21
67257: PUSH
67258: LD_INT 2
67260: PUSH
67261: EMPTY
67262: LIST
67263: LIST
67264: PPUSH
67265: CALL_OW 72
67269: AND
67270: IFFALSE 67608
// begin tmp := FilterByTag ( defenders , 19 ) ;
67272: LD_ADDR_VAR 0 11
67276: PUSH
67277: LD_VAR 0 2
67281: PPUSH
67282: LD_INT 19
67284: PPUSH
67285: CALL 104049 0 2
67289: ST_TO_ADDR
// if tmp then
67290: LD_VAR 0 11
67294: IFFALSE 67364
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
67296: LD_ADDR_VAR 0 11
67300: PUSH
67301: LD_VAR 0 11
67305: PPUSH
67306: LD_INT 25
67308: PUSH
67309: LD_INT 3
67311: PUSH
67312: EMPTY
67313: LIST
67314: LIST
67315: PPUSH
67316: CALL_OW 72
67320: ST_TO_ADDR
// if tmp then
67321: LD_VAR 0 11
67325: IFFALSE 67364
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
67327: LD_ADDR_EXP 111
67331: PUSH
67332: LD_EXP 111
67336: PPUSH
67337: LD_VAR 0 1
67341: PPUSH
67342: LD_EXP 111
67346: PUSH
67347: LD_VAR 0 1
67351: ARRAY
67352: PUSH
67353: LD_VAR 0 11
67357: UNION
67358: PPUSH
67359: CALL_OW 1
67363: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
67364: LD_VAR 0 1
67368: PPUSH
67369: LD_INT 19
67371: PPUSH
67372: CALL 37986 0 2
// repeat wait ( 0 0$1 ) ;
67376: LD_INT 35
67378: PPUSH
67379: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67383: LD_EXP 99
67387: PUSH
67388: LD_VAR 0 1
67392: ARRAY
67393: NOT
67394: PUSH
67395: LD_EXP 99
67399: PUSH
67400: LD_VAR 0 1
67404: ARRAY
67405: PUSH
67406: EMPTY
67407: EQUAL
67408: OR
67409: IFFALSE 67446
// begin for i in defenders do
67411: LD_ADDR_VAR 0 5
67415: PUSH
67416: LD_VAR 0 2
67420: PUSH
67421: FOR_IN
67422: IFFALSE 67435
// ComStop ( i ) ;
67424: LD_VAR 0 5
67428: PPUSH
67429: CALL_OW 141
67433: GO 67421
67435: POP
67436: POP
// defenders := [ ] ;
67437: LD_ADDR_VAR 0 2
67441: PUSH
67442: EMPTY
67443: ST_TO_ADDR
// exit ;
67444: GO 67620
// end ; for i in defenders do
67446: LD_ADDR_VAR 0 5
67450: PUSH
67451: LD_VAR 0 2
67455: PUSH
67456: FOR_IN
67457: IFFALSE 67546
// begin if not IsInArea ( i , mc_parking [ base ] ) then
67459: LD_VAR 0 5
67463: PPUSH
67464: LD_EXP 123
67468: PUSH
67469: LD_VAR 0 1
67473: ARRAY
67474: PPUSH
67475: CALL_OW 308
67479: NOT
67480: IFFALSE 67504
// ComMoveToArea ( i , mc_parking [ base ] ) else
67482: LD_VAR 0 5
67486: PPUSH
67487: LD_EXP 123
67491: PUSH
67492: LD_VAR 0 1
67496: ARRAY
67497: PPUSH
67498: CALL_OW 113
67502: GO 67544
// if GetControl ( i ) = control_manual then
67504: LD_VAR 0 5
67508: PPUSH
67509: CALL_OW 263
67513: PUSH
67514: LD_INT 1
67516: EQUAL
67517: IFFALSE 67544
// if IsDrivenBy ( i ) then
67519: LD_VAR 0 5
67523: PPUSH
67524: CALL_OW 311
67528: IFFALSE 67544
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
67530: LD_VAR 0 5
67534: PPUSH
67535: CALL_OW 311
67539: PPUSH
67540: CALL_OW 121
// end ;
67544: GO 67456
67546: POP
67547: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
67548: LD_VAR 0 2
67552: PPUSH
67553: LD_INT 95
67555: PUSH
67556: LD_EXP 123
67560: PUSH
67561: LD_VAR 0 1
67565: ARRAY
67566: PUSH
67567: EMPTY
67568: LIST
67569: LIST
67570: PPUSH
67571: CALL_OW 72
67575: PUSH
67576: LD_VAR 0 2
67580: EQUAL
67581: PUSH
67582: LD_EXP 122
67586: PUSH
67587: LD_VAR 0 1
67591: ARRAY
67592: OR
67593: PUSH
67594: LD_EXP 99
67598: PUSH
67599: LD_VAR 0 1
67603: ARRAY
67604: NOT
67605: OR
67606: IFFALSE 67376
// end ; MC_Reset ( base , 20 ) ;
67608: LD_VAR 0 1
67612: PPUSH
67613: LD_INT 20
67615: PPUSH
67616: CALL 37986 0 2
// end ;
67620: LD_VAR 0 4
67624: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67625: LD_INT 0
67627: PPUSH
67628: PPUSH
67629: PPUSH
67630: PPUSH
// result := false ;
67631: LD_ADDR_VAR 0 2
67635: PUSH
67636: LD_INT 0
67638: ST_TO_ADDR
// side := GetSide ( unit ) ;
67639: LD_ADDR_VAR 0 3
67643: PUSH
67644: LD_VAR 0 1
67648: PPUSH
67649: CALL_OW 255
67653: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67654: LD_ADDR_VAR 0 4
67658: PUSH
67659: LD_VAR 0 1
67663: PPUSH
67664: CALL_OW 248
67668: ST_TO_ADDR
// case nat of 1 :
67669: LD_VAR 0 4
67673: PUSH
67674: LD_INT 1
67676: DOUBLE
67677: EQUAL
67678: IFTRUE 67682
67680: GO 67693
67682: POP
// tech := tech_lassight ; 2 :
67683: LD_ADDR_VAR 0 5
67687: PUSH
67688: LD_INT 12
67690: ST_TO_ADDR
67691: GO 67732
67693: LD_INT 2
67695: DOUBLE
67696: EQUAL
67697: IFTRUE 67701
67699: GO 67712
67701: POP
// tech := tech_mortar ; 3 :
67702: LD_ADDR_VAR 0 5
67706: PUSH
67707: LD_INT 41
67709: ST_TO_ADDR
67710: GO 67732
67712: LD_INT 3
67714: DOUBLE
67715: EQUAL
67716: IFTRUE 67720
67718: GO 67731
67720: POP
// tech := tech_bazooka ; end ;
67721: LD_ADDR_VAR 0 5
67725: PUSH
67726: LD_INT 44
67728: ST_TO_ADDR
67729: GO 67732
67731: POP
// if Researched ( side , tech ) then
67732: LD_VAR 0 3
67736: PPUSH
67737: LD_VAR 0 5
67741: PPUSH
67742: CALL_OW 325
67746: IFFALSE 67773
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67748: LD_ADDR_VAR 0 2
67752: PUSH
67753: LD_INT 5
67755: PUSH
67756: LD_INT 8
67758: PUSH
67759: LD_INT 9
67761: PUSH
67762: EMPTY
67763: LIST
67764: LIST
67765: LIST
67766: PUSH
67767: LD_VAR 0 4
67771: ARRAY
67772: ST_TO_ADDR
// end ;
67773: LD_VAR 0 2
67777: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67778: LD_INT 0
67780: PPUSH
67781: PPUSH
67782: PPUSH
// if not mines then
67783: LD_VAR 0 2
67787: NOT
67788: IFFALSE 67792
// exit ;
67790: GO 67936
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67792: LD_ADDR_VAR 0 5
67796: PUSH
67797: LD_INT 81
67799: PUSH
67800: LD_VAR 0 1
67804: PUSH
67805: EMPTY
67806: LIST
67807: LIST
67808: PUSH
67809: LD_INT 3
67811: PUSH
67812: LD_INT 21
67814: PUSH
67815: LD_INT 3
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: PPUSH
67830: CALL_OW 69
67834: ST_TO_ADDR
// for i in mines do
67835: LD_ADDR_VAR 0 4
67839: PUSH
67840: LD_VAR 0 2
67844: PUSH
67845: FOR_IN
67846: IFFALSE 67934
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67848: LD_VAR 0 4
67852: PUSH
67853: LD_INT 1
67855: ARRAY
67856: PPUSH
67857: LD_VAR 0 4
67861: PUSH
67862: LD_INT 2
67864: ARRAY
67865: PPUSH
67866: CALL_OW 458
67870: NOT
67871: IFFALSE 67875
// continue ;
67873: GO 67845
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67875: LD_VAR 0 4
67879: PUSH
67880: LD_INT 1
67882: ARRAY
67883: PPUSH
67884: LD_VAR 0 4
67888: PUSH
67889: LD_INT 2
67891: ARRAY
67892: PPUSH
67893: CALL_OW 428
67897: PUSH
67898: LD_VAR 0 5
67902: IN
67903: IFFALSE 67932
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67905: LD_VAR 0 4
67909: PUSH
67910: LD_INT 1
67912: ARRAY
67913: PPUSH
67914: LD_VAR 0 4
67918: PUSH
67919: LD_INT 2
67921: ARRAY
67922: PPUSH
67923: LD_VAR 0 1
67927: PPUSH
67928: CALL_OW 456
// end ;
67932: GO 67845
67934: POP
67935: POP
// end ;
67936: LD_VAR 0 3
67940: RET
// export function Count ( array ) ; var i ; begin
67941: LD_INT 0
67943: PPUSH
67944: PPUSH
// result := 0 ;
67945: LD_ADDR_VAR 0 2
67949: PUSH
67950: LD_INT 0
67952: ST_TO_ADDR
// for i in array do
67953: LD_ADDR_VAR 0 3
67957: PUSH
67958: LD_VAR 0 1
67962: PUSH
67963: FOR_IN
67964: IFFALSE 67988
// if i then
67966: LD_VAR 0 3
67970: IFFALSE 67986
// result := result + 1 ;
67972: LD_ADDR_VAR 0 2
67976: PUSH
67977: LD_VAR 0 2
67981: PUSH
67982: LD_INT 1
67984: PLUS
67985: ST_TO_ADDR
67986: GO 67963
67988: POP
67989: POP
// end ;
67990: LD_VAR 0 2
67994: RET
// export function IsEmpty ( building ) ; begin
67995: LD_INT 0
67997: PPUSH
// if not building then
67998: LD_VAR 0 1
68002: NOT
68003: IFFALSE 68007
// exit ;
68005: GO 68050
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68007: LD_ADDR_VAR 0 2
68011: PUSH
68012: LD_VAR 0 1
68016: PUSH
68017: LD_INT 22
68019: PUSH
68020: LD_VAR 0 1
68024: PPUSH
68025: CALL_OW 255
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: PUSH
68034: LD_INT 58
68036: PUSH
68037: EMPTY
68038: LIST
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PPUSH
68044: CALL_OW 69
68048: IN
68049: ST_TO_ADDR
// end ;
68050: LD_VAR 0 2
68054: RET
// export function IsNotFull ( building ) ; begin
68055: LD_INT 0
68057: PPUSH
// if not building then
68058: LD_VAR 0 1
68062: NOT
68063: IFFALSE 68067
// exit ;
68065: GO 68086
// result := UnitsInside ( building ) < 6 ;
68067: LD_ADDR_VAR 0 2
68071: PUSH
68072: LD_VAR 0 1
68076: PPUSH
68077: CALL_OW 313
68081: PUSH
68082: LD_INT 6
68084: LESS
68085: ST_TO_ADDR
// end ;
68086: LD_VAR 0 2
68090: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68091: LD_INT 0
68093: PPUSH
68094: PPUSH
68095: PPUSH
68096: PPUSH
// tmp := [ ] ;
68097: LD_ADDR_VAR 0 3
68101: PUSH
68102: EMPTY
68103: ST_TO_ADDR
// list := [ ] ;
68104: LD_ADDR_VAR 0 5
68108: PUSH
68109: EMPTY
68110: ST_TO_ADDR
// for i = 16 to 25 do
68111: LD_ADDR_VAR 0 4
68115: PUSH
68116: DOUBLE
68117: LD_INT 16
68119: DEC
68120: ST_TO_ADDR
68121: LD_INT 25
68123: PUSH
68124: FOR_TO
68125: IFFALSE 68198
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68127: LD_ADDR_VAR 0 3
68131: PUSH
68132: LD_VAR 0 3
68136: PUSH
68137: LD_INT 22
68139: PUSH
68140: LD_VAR 0 1
68144: PPUSH
68145: CALL_OW 255
68149: PUSH
68150: EMPTY
68151: LIST
68152: LIST
68153: PUSH
68154: LD_INT 91
68156: PUSH
68157: LD_VAR 0 1
68161: PUSH
68162: LD_INT 6
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: LIST
68169: PUSH
68170: LD_INT 30
68172: PUSH
68173: LD_VAR 0 4
68177: PUSH
68178: EMPTY
68179: LIST
68180: LIST
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: LIST
68186: PUSH
68187: EMPTY
68188: LIST
68189: PPUSH
68190: CALL_OW 69
68194: ADD
68195: ST_TO_ADDR
68196: GO 68124
68198: POP
68199: POP
// for i = 1 to tmp do
68200: LD_ADDR_VAR 0 4
68204: PUSH
68205: DOUBLE
68206: LD_INT 1
68208: DEC
68209: ST_TO_ADDR
68210: LD_VAR 0 3
68214: PUSH
68215: FOR_TO
68216: IFFALSE 68304
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68218: LD_ADDR_VAR 0 5
68222: PUSH
68223: LD_VAR 0 5
68227: PUSH
68228: LD_VAR 0 3
68232: PUSH
68233: LD_VAR 0 4
68237: ARRAY
68238: PPUSH
68239: CALL_OW 266
68243: PUSH
68244: LD_VAR 0 3
68248: PUSH
68249: LD_VAR 0 4
68253: ARRAY
68254: PPUSH
68255: CALL_OW 250
68259: PUSH
68260: LD_VAR 0 3
68264: PUSH
68265: LD_VAR 0 4
68269: ARRAY
68270: PPUSH
68271: CALL_OW 251
68275: PUSH
68276: LD_VAR 0 3
68280: PUSH
68281: LD_VAR 0 4
68285: ARRAY
68286: PPUSH
68287: CALL_OW 254
68291: PUSH
68292: EMPTY
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: PUSH
68298: EMPTY
68299: LIST
68300: ADD
68301: ST_TO_ADDR
68302: GO 68215
68304: POP
68305: POP
// result := list ;
68306: LD_ADDR_VAR 0 2
68310: PUSH
68311: LD_VAR 0 5
68315: ST_TO_ADDR
// end ;
68316: LD_VAR 0 2
68320: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68321: LD_INT 0
68323: PPUSH
68324: PPUSH
68325: PPUSH
68326: PPUSH
68327: PPUSH
68328: PPUSH
68329: PPUSH
// if not factory then
68330: LD_VAR 0 1
68334: NOT
68335: IFFALSE 68339
// exit ;
68337: GO 68932
// if control = control_apeman then
68339: LD_VAR 0 4
68343: PUSH
68344: LD_INT 5
68346: EQUAL
68347: IFFALSE 68456
// begin tmp := UnitsInside ( factory ) ;
68349: LD_ADDR_VAR 0 8
68353: PUSH
68354: LD_VAR 0 1
68358: PPUSH
68359: CALL_OW 313
68363: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68364: LD_VAR 0 8
68368: PPUSH
68369: LD_INT 25
68371: PUSH
68372: LD_INT 12
68374: PUSH
68375: EMPTY
68376: LIST
68377: LIST
68378: PPUSH
68379: CALL_OW 72
68383: NOT
68384: IFFALSE 68394
// control := control_manual ;
68386: LD_ADDR_VAR 0 4
68390: PUSH
68391: LD_INT 1
68393: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68394: LD_ADDR_VAR 0 8
68398: PUSH
68399: LD_VAR 0 1
68403: PPUSH
68404: CALL 68091 0 1
68408: ST_TO_ADDR
// if tmp then
68409: LD_VAR 0 8
68413: IFFALSE 68456
// begin for i in tmp do
68415: LD_ADDR_VAR 0 7
68419: PUSH
68420: LD_VAR 0 8
68424: PUSH
68425: FOR_IN
68426: IFFALSE 68454
// if i [ 1 ] = b_ext_radio then
68428: LD_VAR 0 7
68432: PUSH
68433: LD_INT 1
68435: ARRAY
68436: PUSH
68437: LD_INT 22
68439: EQUAL
68440: IFFALSE 68452
// begin control := control_remote ;
68442: LD_ADDR_VAR 0 4
68446: PUSH
68447: LD_INT 2
68449: ST_TO_ADDR
// break ;
68450: GO 68454
// end ;
68452: GO 68425
68454: POP
68455: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68456: LD_VAR 0 1
68460: PPUSH
68461: LD_VAR 0 2
68465: PPUSH
68466: LD_VAR 0 3
68470: PPUSH
68471: LD_VAR 0 4
68475: PPUSH
68476: LD_VAR 0 5
68480: PPUSH
68481: CALL_OW 448
68485: IFFALSE 68520
// begin result := [ chassis , engine , control , weapon ] ;
68487: LD_ADDR_VAR 0 6
68491: PUSH
68492: LD_VAR 0 2
68496: PUSH
68497: LD_VAR 0 3
68501: PUSH
68502: LD_VAR 0 4
68506: PUSH
68507: LD_VAR 0 5
68511: PUSH
68512: EMPTY
68513: LIST
68514: LIST
68515: LIST
68516: LIST
68517: ST_TO_ADDR
// exit ;
68518: GO 68932
// end ; _chassis := AvailableChassisList ( factory ) ;
68520: LD_ADDR_VAR 0 9
68524: PUSH
68525: LD_VAR 0 1
68529: PPUSH
68530: CALL_OW 475
68534: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68535: LD_ADDR_VAR 0 11
68539: PUSH
68540: LD_VAR 0 1
68544: PPUSH
68545: CALL_OW 476
68549: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68550: LD_ADDR_VAR 0 12
68554: PUSH
68555: LD_VAR 0 1
68559: PPUSH
68560: CALL_OW 477
68564: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68565: LD_ADDR_VAR 0 10
68569: PUSH
68570: LD_VAR 0 1
68574: PPUSH
68575: CALL_OW 478
68579: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68580: LD_VAR 0 9
68584: NOT
68585: PUSH
68586: LD_VAR 0 11
68590: NOT
68591: OR
68592: PUSH
68593: LD_VAR 0 12
68597: NOT
68598: OR
68599: PUSH
68600: LD_VAR 0 10
68604: NOT
68605: OR
68606: IFFALSE 68641
// begin result := [ chassis , engine , control , weapon ] ;
68608: LD_ADDR_VAR 0 6
68612: PUSH
68613: LD_VAR 0 2
68617: PUSH
68618: LD_VAR 0 3
68622: PUSH
68623: LD_VAR 0 4
68627: PUSH
68628: LD_VAR 0 5
68632: PUSH
68633: EMPTY
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: ST_TO_ADDR
// exit ;
68639: GO 68932
// end ; if not chassis in _chassis then
68641: LD_VAR 0 2
68645: PUSH
68646: LD_VAR 0 9
68650: IN
68651: NOT
68652: IFFALSE 68678
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68654: LD_ADDR_VAR 0 2
68658: PUSH
68659: LD_VAR 0 9
68663: PUSH
68664: LD_INT 1
68666: PPUSH
68667: LD_VAR 0 9
68671: PPUSH
68672: CALL_OW 12
68676: ARRAY
68677: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68678: LD_VAR 0 2
68682: PPUSH
68683: LD_VAR 0 3
68687: PPUSH
68688: CALL 68937 0 2
68692: NOT
68693: IFFALSE 68752
// repeat engine := _engine [ 1 ] ;
68695: LD_ADDR_VAR 0 3
68699: PUSH
68700: LD_VAR 0 11
68704: PUSH
68705: LD_INT 1
68707: ARRAY
68708: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68709: LD_ADDR_VAR 0 11
68713: PUSH
68714: LD_VAR 0 11
68718: PPUSH
68719: LD_INT 1
68721: PPUSH
68722: CALL_OW 3
68726: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68727: LD_VAR 0 2
68731: PPUSH
68732: LD_VAR 0 3
68736: PPUSH
68737: CALL 68937 0 2
68741: PUSH
68742: LD_VAR 0 11
68746: PUSH
68747: EMPTY
68748: EQUAL
68749: OR
68750: IFFALSE 68695
// if not control in _control then
68752: LD_VAR 0 4
68756: PUSH
68757: LD_VAR 0 12
68761: IN
68762: NOT
68763: IFFALSE 68789
// control := _control [ rand ( 1 , _control ) ] ;
68765: LD_ADDR_VAR 0 4
68769: PUSH
68770: LD_VAR 0 12
68774: PUSH
68775: LD_INT 1
68777: PPUSH
68778: LD_VAR 0 12
68782: PPUSH
68783: CALL_OW 12
68787: ARRAY
68788: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68789: LD_VAR 0 2
68793: PPUSH
68794: LD_VAR 0 5
68798: PPUSH
68799: CALL 69157 0 2
68803: NOT
68804: IFFALSE 68863
// repeat weapon := _weapon [ 1 ] ;
68806: LD_ADDR_VAR 0 5
68810: PUSH
68811: LD_VAR 0 10
68815: PUSH
68816: LD_INT 1
68818: ARRAY
68819: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68820: LD_ADDR_VAR 0 10
68824: PUSH
68825: LD_VAR 0 10
68829: PPUSH
68830: LD_INT 1
68832: PPUSH
68833: CALL_OW 3
68837: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68838: LD_VAR 0 2
68842: PPUSH
68843: LD_VAR 0 5
68847: PPUSH
68848: CALL 69157 0 2
68852: PUSH
68853: LD_VAR 0 10
68857: PUSH
68858: EMPTY
68859: EQUAL
68860: OR
68861: IFFALSE 68806
// result := [ ] ;
68863: LD_ADDR_VAR 0 6
68867: PUSH
68868: EMPTY
68869: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68870: LD_VAR 0 1
68874: PPUSH
68875: LD_VAR 0 2
68879: PPUSH
68880: LD_VAR 0 3
68884: PPUSH
68885: LD_VAR 0 4
68889: PPUSH
68890: LD_VAR 0 5
68894: PPUSH
68895: CALL_OW 448
68899: IFFALSE 68932
// result := [ chassis , engine , control , weapon ] ;
68901: LD_ADDR_VAR 0 6
68905: PUSH
68906: LD_VAR 0 2
68910: PUSH
68911: LD_VAR 0 3
68915: PUSH
68916: LD_VAR 0 4
68920: PUSH
68921: LD_VAR 0 5
68925: PUSH
68926: EMPTY
68927: LIST
68928: LIST
68929: LIST
68930: LIST
68931: ST_TO_ADDR
// end ;
68932: LD_VAR 0 6
68936: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68937: LD_INT 0
68939: PPUSH
// if not chassis or not engine then
68940: LD_VAR 0 1
68944: NOT
68945: PUSH
68946: LD_VAR 0 2
68950: NOT
68951: OR
68952: IFFALSE 68956
// exit ;
68954: GO 69152
// case engine of engine_solar :
68956: LD_VAR 0 2
68960: PUSH
68961: LD_INT 2
68963: DOUBLE
68964: EQUAL
68965: IFTRUE 68969
68967: GO 69007
68969: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
68970: LD_ADDR_VAR 0 3
68974: PUSH
68975: LD_INT 11
68977: PUSH
68978: LD_INT 12
68980: PUSH
68981: LD_INT 13
68983: PUSH
68984: LD_INT 14
68986: PUSH
68987: LD_INT 1
68989: PUSH
68990: LD_INT 2
68992: PUSH
68993: LD_INT 3
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: LIST
69000: LIST
69001: LIST
69002: LIST
69003: LIST
69004: ST_TO_ADDR
69005: GO 69136
69007: LD_INT 1
69009: DOUBLE
69010: EQUAL
69011: IFTRUE 69015
69013: GO 69077
69015: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69016: LD_ADDR_VAR 0 3
69020: PUSH
69021: LD_INT 11
69023: PUSH
69024: LD_INT 12
69026: PUSH
69027: LD_INT 13
69029: PUSH
69030: LD_INT 14
69032: PUSH
69033: LD_INT 1
69035: PUSH
69036: LD_INT 2
69038: PUSH
69039: LD_INT 3
69041: PUSH
69042: LD_INT 4
69044: PUSH
69045: LD_INT 5
69047: PUSH
69048: LD_INT 21
69050: PUSH
69051: LD_INT 23
69053: PUSH
69054: LD_INT 22
69056: PUSH
69057: LD_INT 24
69059: PUSH
69060: EMPTY
69061: LIST
69062: LIST
69063: LIST
69064: LIST
69065: LIST
69066: LIST
69067: LIST
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: ST_TO_ADDR
69075: GO 69136
69077: LD_INT 3
69079: DOUBLE
69080: EQUAL
69081: IFTRUE 69085
69083: GO 69135
69085: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69086: LD_ADDR_VAR 0 3
69090: PUSH
69091: LD_INT 13
69093: PUSH
69094: LD_INT 14
69096: PUSH
69097: LD_INT 2
69099: PUSH
69100: LD_INT 3
69102: PUSH
69103: LD_INT 4
69105: PUSH
69106: LD_INT 5
69108: PUSH
69109: LD_INT 21
69111: PUSH
69112: LD_INT 22
69114: PUSH
69115: LD_INT 23
69117: PUSH
69118: LD_INT 24
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: LIST
69125: LIST
69126: LIST
69127: LIST
69128: LIST
69129: LIST
69130: LIST
69131: LIST
69132: ST_TO_ADDR
69133: GO 69136
69135: POP
// result := ( chassis in result ) ;
69136: LD_ADDR_VAR 0 3
69140: PUSH
69141: LD_VAR 0 1
69145: PUSH
69146: LD_VAR 0 3
69150: IN
69151: ST_TO_ADDR
// end ;
69152: LD_VAR 0 3
69156: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69157: LD_INT 0
69159: PPUSH
// if not chassis or not weapon then
69160: LD_VAR 0 1
69164: NOT
69165: PUSH
69166: LD_VAR 0 2
69170: NOT
69171: OR
69172: IFFALSE 69176
// exit ;
69174: GO 70202
// case weapon of us_machine_gun :
69176: LD_VAR 0 2
69180: PUSH
69181: LD_INT 2
69183: DOUBLE
69184: EQUAL
69185: IFTRUE 69189
69187: GO 69219
69189: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69190: LD_ADDR_VAR 0 3
69194: PUSH
69195: LD_INT 1
69197: PUSH
69198: LD_INT 2
69200: PUSH
69201: LD_INT 3
69203: PUSH
69204: LD_INT 4
69206: PUSH
69207: LD_INT 5
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: LIST
69214: LIST
69215: LIST
69216: ST_TO_ADDR
69217: GO 70186
69219: LD_INT 3
69221: DOUBLE
69222: EQUAL
69223: IFTRUE 69227
69225: GO 69257
69227: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69228: LD_ADDR_VAR 0 3
69232: PUSH
69233: LD_INT 1
69235: PUSH
69236: LD_INT 2
69238: PUSH
69239: LD_INT 3
69241: PUSH
69242: LD_INT 4
69244: PUSH
69245: LD_INT 5
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: LIST
69252: LIST
69253: LIST
69254: ST_TO_ADDR
69255: GO 70186
69257: LD_INT 11
69259: DOUBLE
69260: EQUAL
69261: IFTRUE 69265
69263: GO 69295
69265: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69266: LD_ADDR_VAR 0 3
69270: PUSH
69271: LD_INT 1
69273: PUSH
69274: LD_INT 2
69276: PUSH
69277: LD_INT 3
69279: PUSH
69280: LD_INT 4
69282: PUSH
69283: LD_INT 5
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: LIST
69290: LIST
69291: LIST
69292: ST_TO_ADDR
69293: GO 70186
69295: LD_INT 4
69297: DOUBLE
69298: EQUAL
69299: IFTRUE 69303
69301: GO 69329
69303: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69304: LD_ADDR_VAR 0 3
69308: PUSH
69309: LD_INT 2
69311: PUSH
69312: LD_INT 3
69314: PUSH
69315: LD_INT 4
69317: PUSH
69318: LD_INT 5
69320: PUSH
69321: EMPTY
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: ST_TO_ADDR
69327: GO 70186
69329: LD_INT 5
69331: DOUBLE
69332: EQUAL
69333: IFTRUE 69337
69335: GO 69363
69337: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69338: LD_ADDR_VAR 0 3
69342: PUSH
69343: LD_INT 2
69345: PUSH
69346: LD_INT 3
69348: PUSH
69349: LD_INT 4
69351: PUSH
69352: LD_INT 5
69354: PUSH
69355: EMPTY
69356: LIST
69357: LIST
69358: LIST
69359: LIST
69360: ST_TO_ADDR
69361: GO 70186
69363: LD_INT 9
69365: DOUBLE
69366: EQUAL
69367: IFTRUE 69371
69369: GO 69397
69371: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69372: LD_ADDR_VAR 0 3
69376: PUSH
69377: LD_INT 2
69379: PUSH
69380: LD_INT 3
69382: PUSH
69383: LD_INT 4
69385: PUSH
69386: LD_INT 5
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: LIST
69393: LIST
69394: ST_TO_ADDR
69395: GO 70186
69397: LD_INT 7
69399: DOUBLE
69400: EQUAL
69401: IFTRUE 69405
69403: GO 69431
69405: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69406: LD_ADDR_VAR 0 3
69410: PUSH
69411: LD_INT 2
69413: PUSH
69414: LD_INT 3
69416: PUSH
69417: LD_INT 4
69419: PUSH
69420: LD_INT 5
69422: PUSH
69423: EMPTY
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: ST_TO_ADDR
69429: GO 70186
69431: LD_INT 12
69433: DOUBLE
69434: EQUAL
69435: IFTRUE 69439
69437: GO 69465
69439: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69440: LD_ADDR_VAR 0 3
69444: PUSH
69445: LD_INT 2
69447: PUSH
69448: LD_INT 3
69450: PUSH
69451: LD_INT 4
69453: PUSH
69454: LD_INT 5
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: LIST
69461: LIST
69462: ST_TO_ADDR
69463: GO 70186
69465: LD_INT 13
69467: DOUBLE
69468: EQUAL
69469: IFTRUE 69473
69471: GO 69499
69473: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69474: LD_ADDR_VAR 0 3
69478: PUSH
69479: LD_INT 2
69481: PUSH
69482: LD_INT 3
69484: PUSH
69485: LD_INT 4
69487: PUSH
69488: LD_INT 5
69490: PUSH
69491: EMPTY
69492: LIST
69493: LIST
69494: LIST
69495: LIST
69496: ST_TO_ADDR
69497: GO 70186
69499: LD_INT 14
69501: DOUBLE
69502: EQUAL
69503: IFTRUE 69507
69505: GO 69525
69507: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69508: LD_ADDR_VAR 0 3
69512: PUSH
69513: LD_INT 4
69515: PUSH
69516: LD_INT 5
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: ST_TO_ADDR
69523: GO 70186
69525: LD_INT 6
69527: DOUBLE
69528: EQUAL
69529: IFTRUE 69533
69531: GO 69551
69533: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69534: LD_ADDR_VAR 0 3
69538: PUSH
69539: LD_INT 4
69541: PUSH
69542: LD_INT 5
69544: PUSH
69545: EMPTY
69546: LIST
69547: LIST
69548: ST_TO_ADDR
69549: GO 70186
69551: LD_INT 10
69553: DOUBLE
69554: EQUAL
69555: IFTRUE 69559
69557: GO 69577
69559: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69560: LD_ADDR_VAR 0 3
69564: PUSH
69565: LD_INT 4
69567: PUSH
69568: LD_INT 5
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: ST_TO_ADDR
69575: GO 70186
69577: LD_INT 22
69579: DOUBLE
69580: EQUAL
69581: IFTRUE 69585
69583: GO 69611
69585: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69586: LD_ADDR_VAR 0 3
69590: PUSH
69591: LD_INT 11
69593: PUSH
69594: LD_INT 12
69596: PUSH
69597: LD_INT 13
69599: PUSH
69600: LD_INT 14
69602: PUSH
69603: EMPTY
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: ST_TO_ADDR
69609: GO 70186
69611: LD_INT 23
69613: DOUBLE
69614: EQUAL
69615: IFTRUE 69619
69617: GO 69645
69619: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69620: LD_ADDR_VAR 0 3
69624: PUSH
69625: LD_INT 11
69627: PUSH
69628: LD_INT 12
69630: PUSH
69631: LD_INT 13
69633: PUSH
69634: LD_INT 14
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: ST_TO_ADDR
69643: GO 70186
69645: LD_INT 24
69647: DOUBLE
69648: EQUAL
69649: IFTRUE 69653
69651: GO 69679
69653: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69654: LD_ADDR_VAR 0 3
69658: PUSH
69659: LD_INT 11
69661: PUSH
69662: LD_INT 12
69664: PUSH
69665: LD_INT 13
69667: PUSH
69668: LD_INT 14
69670: PUSH
69671: EMPTY
69672: LIST
69673: LIST
69674: LIST
69675: LIST
69676: ST_TO_ADDR
69677: GO 70186
69679: LD_INT 30
69681: DOUBLE
69682: EQUAL
69683: IFTRUE 69687
69685: GO 69713
69687: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69688: LD_ADDR_VAR 0 3
69692: PUSH
69693: LD_INT 11
69695: PUSH
69696: LD_INT 12
69698: PUSH
69699: LD_INT 13
69701: PUSH
69702: LD_INT 14
69704: PUSH
69705: EMPTY
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: ST_TO_ADDR
69711: GO 70186
69713: LD_INT 25
69715: DOUBLE
69716: EQUAL
69717: IFTRUE 69721
69719: GO 69739
69721: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69722: LD_ADDR_VAR 0 3
69726: PUSH
69727: LD_INT 13
69729: PUSH
69730: LD_INT 14
69732: PUSH
69733: EMPTY
69734: LIST
69735: LIST
69736: ST_TO_ADDR
69737: GO 70186
69739: LD_INT 27
69741: DOUBLE
69742: EQUAL
69743: IFTRUE 69747
69745: GO 69765
69747: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69748: LD_ADDR_VAR 0 3
69752: PUSH
69753: LD_INT 13
69755: PUSH
69756: LD_INT 14
69758: PUSH
69759: EMPTY
69760: LIST
69761: LIST
69762: ST_TO_ADDR
69763: GO 70186
69765: LD_INT 28
69767: DOUBLE
69768: EQUAL
69769: IFTRUE 69773
69771: GO 69791
69773: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69774: LD_ADDR_VAR 0 3
69778: PUSH
69779: LD_INT 13
69781: PUSH
69782: LD_INT 14
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: ST_TO_ADDR
69789: GO 70186
69791: LD_INT 29
69793: DOUBLE
69794: EQUAL
69795: IFTRUE 69799
69797: GO 69817
69799: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69800: LD_ADDR_VAR 0 3
69804: PUSH
69805: LD_INT 13
69807: PUSH
69808: LD_INT 14
69810: PUSH
69811: EMPTY
69812: LIST
69813: LIST
69814: ST_TO_ADDR
69815: GO 70186
69817: LD_INT 31
69819: DOUBLE
69820: EQUAL
69821: IFTRUE 69825
69823: GO 69843
69825: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69826: LD_ADDR_VAR 0 3
69830: PUSH
69831: LD_INT 13
69833: PUSH
69834: LD_INT 14
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: ST_TO_ADDR
69841: GO 70186
69843: LD_INT 26
69845: DOUBLE
69846: EQUAL
69847: IFTRUE 69851
69849: GO 69869
69851: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69852: LD_ADDR_VAR 0 3
69856: PUSH
69857: LD_INT 13
69859: PUSH
69860: LD_INT 14
69862: PUSH
69863: EMPTY
69864: LIST
69865: LIST
69866: ST_TO_ADDR
69867: GO 70186
69869: LD_INT 42
69871: DOUBLE
69872: EQUAL
69873: IFTRUE 69877
69875: GO 69903
69877: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69878: LD_ADDR_VAR 0 3
69882: PUSH
69883: LD_INT 21
69885: PUSH
69886: LD_INT 22
69888: PUSH
69889: LD_INT 23
69891: PUSH
69892: LD_INT 24
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: LIST
69899: LIST
69900: ST_TO_ADDR
69901: GO 70186
69903: LD_INT 43
69905: DOUBLE
69906: EQUAL
69907: IFTRUE 69911
69909: GO 69937
69911: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69912: LD_ADDR_VAR 0 3
69916: PUSH
69917: LD_INT 21
69919: PUSH
69920: LD_INT 22
69922: PUSH
69923: LD_INT 23
69925: PUSH
69926: LD_INT 24
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: LIST
69933: LIST
69934: ST_TO_ADDR
69935: GO 70186
69937: LD_INT 44
69939: DOUBLE
69940: EQUAL
69941: IFTRUE 69945
69943: GO 69971
69945: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
69946: LD_ADDR_VAR 0 3
69950: PUSH
69951: LD_INT 21
69953: PUSH
69954: LD_INT 22
69956: PUSH
69957: LD_INT 23
69959: PUSH
69960: LD_INT 24
69962: PUSH
69963: EMPTY
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: ST_TO_ADDR
69969: GO 70186
69971: LD_INT 45
69973: DOUBLE
69974: EQUAL
69975: IFTRUE 69979
69977: GO 70005
69979: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
69980: LD_ADDR_VAR 0 3
69984: PUSH
69985: LD_INT 21
69987: PUSH
69988: LD_INT 22
69990: PUSH
69991: LD_INT 23
69993: PUSH
69994: LD_INT 24
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: LIST
70001: LIST
70002: ST_TO_ADDR
70003: GO 70186
70005: LD_INT 49
70007: DOUBLE
70008: EQUAL
70009: IFTRUE 70013
70011: GO 70039
70013: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70014: LD_ADDR_VAR 0 3
70018: PUSH
70019: LD_INT 21
70021: PUSH
70022: LD_INT 22
70024: PUSH
70025: LD_INT 23
70027: PUSH
70028: LD_INT 24
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: LIST
70035: LIST
70036: ST_TO_ADDR
70037: GO 70186
70039: LD_INT 51
70041: DOUBLE
70042: EQUAL
70043: IFTRUE 70047
70045: GO 70073
70047: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70048: LD_ADDR_VAR 0 3
70052: PUSH
70053: LD_INT 21
70055: PUSH
70056: LD_INT 22
70058: PUSH
70059: LD_INT 23
70061: PUSH
70062: LD_INT 24
70064: PUSH
70065: EMPTY
70066: LIST
70067: LIST
70068: LIST
70069: LIST
70070: ST_TO_ADDR
70071: GO 70186
70073: LD_INT 52
70075: DOUBLE
70076: EQUAL
70077: IFTRUE 70081
70079: GO 70107
70081: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70082: LD_ADDR_VAR 0 3
70086: PUSH
70087: LD_INT 21
70089: PUSH
70090: LD_INT 22
70092: PUSH
70093: LD_INT 23
70095: PUSH
70096: LD_INT 24
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: LIST
70103: LIST
70104: ST_TO_ADDR
70105: GO 70186
70107: LD_INT 53
70109: DOUBLE
70110: EQUAL
70111: IFTRUE 70115
70113: GO 70133
70115: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70116: LD_ADDR_VAR 0 3
70120: PUSH
70121: LD_INT 23
70123: PUSH
70124: LD_INT 24
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: ST_TO_ADDR
70131: GO 70186
70133: LD_INT 46
70135: DOUBLE
70136: EQUAL
70137: IFTRUE 70141
70139: GO 70159
70141: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70142: LD_ADDR_VAR 0 3
70146: PUSH
70147: LD_INT 23
70149: PUSH
70150: LD_INT 24
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: ST_TO_ADDR
70157: GO 70186
70159: LD_INT 47
70161: DOUBLE
70162: EQUAL
70163: IFTRUE 70167
70165: GO 70185
70167: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70168: LD_ADDR_VAR 0 3
70172: PUSH
70173: LD_INT 23
70175: PUSH
70176: LD_INT 24
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: ST_TO_ADDR
70183: GO 70186
70185: POP
// result := ( chassis in result ) ;
70186: LD_ADDR_VAR 0 3
70190: PUSH
70191: LD_VAR 0 1
70195: PUSH
70196: LD_VAR 0 3
70200: IN
70201: ST_TO_ADDR
// end ;
70202: LD_VAR 0 3
70206: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70207: LD_INT 0
70209: PPUSH
70210: PPUSH
70211: PPUSH
70212: PPUSH
70213: PPUSH
70214: PPUSH
70215: PPUSH
// result := array ;
70216: LD_ADDR_VAR 0 5
70220: PUSH
70221: LD_VAR 0 1
70225: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70226: LD_VAR 0 1
70230: NOT
70231: PUSH
70232: LD_VAR 0 2
70236: NOT
70237: OR
70238: PUSH
70239: LD_VAR 0 3
70243: NOT
70244: OR
70245: PUSH
70246: LD_VAR 0 2
70250: PUSH
70251: LD_VAR 0 1
70255: GREATER
70256: OR
70257: PUSH
70258: LD_VAR 0 3
70262: PUSH
70263: LD_VAR 0 1
70267: GREATER
70268: OR
70269: IFFALSE 70273
// exit ;
70271: GO 70569
// if direction then
70273: LD_VAR 0 4
70277: IFFALSE 70341
// begin d := 1 ;
70279: LD_ADDR_VAR 0 9
70283: PUSH
70284: LD_INT 1
70286: ST_TO_ADDR
// if i_from > i_to then
70287: LD_VAR 0 2
70291: PUSH
70292: LD_VAR 0 3
70296: GREATER
70297: IFFALSE 70323
// length := ( array - i_from ) + i_to else
70299: LD_ADDR_VAR 0 11
70303: PUSH
70304: LD_VAR 0 1
70308: PUSH
70309: LD_VAR 0 2
70313: MINUS
70314: PUSH
70315: LD_VAR 0 3
70319: PLUS
70320: ST_TO_ADDR
70321: GO 70339
// length := i_to - i_from ;
70323: LD_ADDR_VAR 0 11
70327: PUSH
70328: LD_VAR 0 3
70332: PUSH
70333: LD_VAR 0 2
70337: MINUS
70338: ST_TO_ADDR
// end else
70339: GO 70402
// begin d := - 1 ;
70341: LD_ADDR_VAR 0 9
70345: PUSH
70346: LD_INT 1
70348: NEG
70349: ST_TO_ADDR
// if i_from > i_to then
70350: LD_VAR 0 2
70354: PUSH
70355: LD_VAR 0 3
70359: GREATER
70360: IFFALSE 70380
// length := i_from - i_to else
70362: LD_ADDR_VAR 0 11
70366: PUSH
70367: LD_VAR 0 2
70371: PUSH
70372: LD_VAR 0 3
70376: MINUS
70377: ST_TO_ADDR
70378: GO 70402
// length := ( array - i_to ) + i_from ;
70380: LD_ADDR_VAR 0 11
70384: PUSH
70385: LD_VAR 0 1
70389: PUSH
70390: LD_VAR 0 3
70394: MINUS
70395: PUSH
70396: LD_VAR 0 2
70400: PLUS
70401: ST_TO_ADDR
// end ; if not length then
70402: LD_VAR 0 11
70406: NOT
70407: IFFALSE 70411
// exit ;
70409: GO 70569
// tmp := array ;
70411: LD_ADDR_VAR 0 10
70415: PUSH
70416: LD_VAR 0 1
70420: ST_TO_ADDR
// for i = 1 to length do
70421: LD_ADDR_VAR 0 6
70425: PUSH
70426: DOUBLE
70427: LD_INT 1
70429: DEC
70430: ST_TO_ADDR
70431: LD_VAR 0 11
70435: PUSH
70436: FOR_TO
70437: IFFALSE 70557
// begin for j = 1 to array do
70439: LD_ADDR_VAR 0 7
70443: PUSH
70444: DOUBLE
70445: LD_INT 1
70447: DEC
70448: ST_TO_ADDR
70449: LD_VAR 0 1
70453: PUSH
70454: FOR_TO
70455: IFFALSE 70543
// begin k := j + d ;
70457: LD_ADDR_VAR 0 8
70461: PUSH
70462: LD_VAR 0 7
70466: PUSH
70467: LD_VAR 0 9
70471: PLUS
70472: ST_TO_ADDR
// if k > array then
70473: LD_VAR 0 8
70477: PUSH
70478: LD_VAR 0 1
70482: GREATER
70483: IFFALSE 70493
// k := 1 ;
70485: LD_ADDR_VAR 0 8
70489: PUSH
70490: LD_INT 1
70492: ST_TO_ADDR
// if not k then
70493: LD_VAR 0 8
70497: NOT
70498: IFFALSE 70510
// k := array ;
70500: LD_ADDR_VAR 0 8
70504: PUSH
70505: LD_VAR 0 1
70509: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70510: LD_ADDR_VAR 0 10
70514: PUSH
70515: LD_VAR 0 10
70519: PPUSH
70520: LD_VAR 0 8
70524: PPUSH
70525: LD_VAR 0 1
70529: PUSH
70530: LD_VAR 0 7
70534: ARRAY
70535: PPUSH
70536: CALL_OW 1
70540: ST_TO_ADDR
// end ;
70541: GO 70454
70543: POP
70544: POP
// array := tmp ;
70545: LD_ADDR_VAR 0 1
70549: PUSH
70550: LD_VAR 0 10
70554: ST_TO_ADDR
// end ;
70555: GO 70436
70557: POP
70558: POP
// result := array ;
70559: LD_ADDR_VAR 0 5
70563: PUSH
70564: LD_VAR 0 1
70568: ST_TO_ADDR
// end ;
70569: LD_VAR 0 5
70573: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70574: LD_INT 0
70576: PPUSH
70577: PPUSH
// result := 0 ;
70578: LD_ADDR_VAR 0 3
70582: PUSH
70583: LD_INT 0
70585: ST_TO_ADDR
// if not array or not value in array then
70586: LD_VAR 0 1
70590: NOT
70591: PUSH
70592: LD_VAR 0 2
70596: PUSH
70597: LD_VAR 0 1
70601: IN
70602: NOT
70603: OR
70604: IFFALSE 70608
// exit ;
70606: GO 70662
// for i = 1 to array do
70608: LD_ADDR_VAR 0 4
70612: PUSH
70613: DOUBLE
70614: LD_INT 1
70616: DEC
70617: ST_TO_ADDR
70618: LD_VAR 0 1
70622: PUSH
70623: FOR_TO
70624: IFFALSE 70660
// if value = array [ i ] then
70626: LD_VAR 0 2
70630: PUSH
70631: LD_VAR 0 1
70635: PUSH
70636: LD_VAR 0 4
70640: ARRAY
70641: EQUAL
70642: IFFALSE 70658
// begin result := i ;
70644: LD_ADDR_VAR 0 3
70648: PUSH
70649: LD_VAR 0 4
70653: ST_TO_ADDR
// exit ;
70654: POP
70655: POP
70656: GO 70662
// end ;
70658: GO 70623
70660: POP
70661: POP
// end ;
70662: LD_VAR 0 3
70666: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70667: LD_INT 0
70669: PPUSH
// vc_chassis := chassis ;
70670: LD_ADDR_OWVAR 37
70674: PUSH
70675: LD_VAR 0 1
70679: ST_TO_ADDR
// vc_engine := engine ;
70680: LD_ADDR_OWVAR 39
70684: PUSH
70685: LD_VAR 0 2
70689: ST_TO_ADDR
// vc_control := control ;
70690: LD_ADDR_OWVAR 38
70694: PUSH
70695: LD_VAR 0 3
70699: ST_TO_ADDR
// vc_weapon := weapon ;
70700: LD_ADDR_OWVAR 40
70704: PUSH
70705: LD_VAR 0 4
70709: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70710: LD_ADDR_OWVAR 41
70714: PUSH
70715: LD_VAR 0 5
70719: ST_TO_ADDR
// end ;
70720: LD_VAR 0 6
70724: RET
// export function WantPlant ( unit ) ; var task ; begin
70725: LD_INT 0
70727: PPUSH
70728: PPUSH
// result := false ;
70729: LD_ADDR_VAR 0 2
70733: PUSH
70734: LD_INT 0
70736: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70737: LD_ADDR_VAR 0 3
70741: PUSH
70742: LD_VAR 0 1
70746: PPUSH
70747: CALL_OW 437
70751: ST_TO_ADDR
// if task then
70752: LD_VAR 0 3
70756: IFFALSE 70784
// if task [ 1 ] [ 1 ] = p then
70758: LD_VAR 0 3
70762: PUSH
70763: LD_INT 1
70765: ARRAY
70766: PUSH
70767: LD_INT 1
70769: ARRAY
70770: PUSH
70771: LD_STRING p
70773: EQUAL
70774: IFFALSE 70784
// result := true ;
70776: LD_ADDR_VAR 0 2
70780: PUSH
70781: LD_INT 1
70783: ST_TO_ADDR
// end ;
70784: LD_VAR 0 2
70788: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70789: LD_INT 0
70791: PPUSH
70792: PPUSH
70793: PPUSH
70794: PPUSH
// if pos < 1 then
70795: LD_VAR 0 2
70799: PUSH
70800: LD_INT 1
70802: LESS
70803: IFFALSE 70807
// exit ;
70805: GO 71110
// if pos = 1 then
70807: LD_VAR 0 2
70811: PUSH
70812: LD_INT 1
70814: EQUAL
70815: IFFALSE 70848
// result := Replace ( arr , pos [ 1 ] , value ) else
70817: LD_ADDR_VAR 0 4
70821: PUSH
70822: LD_VAR 0 1
70826: PPUSH
70827: LD_VAR 0 2
70831: PUSH
70832: LD_INT 1
70834: ARRAY
70835: PPUSH
70836: LD_VAR 0 3
70840: PPUSH
70841: CALL_OW 1
70845: ST_TO_ADDR
70846: GO 71110
// begin tmp := arr ;
70848: LD_ADDR_VAR 0 6
70852: PUSH
70853: LD_VAR 0 1
70857: ST_TO_ADDR
// s_arr := [ tmp ] ;
70858: LD_ADDR_VAR 0 7
70862: PUSH
70863: LD_VAR 0 6
70867: PUSH
70868: EMPTY
70869: LIST
70870: ST_TO_ADDR
// for i = 1 to pos - 1 do
70871: LD_ADDR_VAR 0 5
70875: PUSH
70876: DOUBLE
70877: LD_INT 1
70879: DEC
70880: ST_TO_ADDR
70881: LD_VAR 0 2
70885: PUSH
70886: LD_INT 1
70888: MINUS
70889: PUSH
70890: FOR_TO
70891: IFFALSE 70936
// begin tmp := tmp [ pos [ i ] ] ;
70893: LD_ADDR_VAR 0 6
70897: PUSH
70898: LD_VAR 0 6
70902: PUSH
70903: LD_VAR 0 2
70907: PUSH
70908: LD_VAR 0 5
70912: ARRAY
70913: ARRAY
70914: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70915: LD_ADDR_VAR 0 7
70919: PUSH
70920: LD_VAR 0 7
70924: PUSH
70925: LD_VAR 0 6
70929: PUSH
70930: EMPTY
70931: LIST
70932: ADD
70933: ST_TO_ADDR
// end ;
70934: GO 70890
70936: POP
70937: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
70938: LD_ADDR_VAR 0 6
70942: PUSH
70943: LD_VAR 0 6
70947: PPUSH
70948: LD_VAR 0 2
70952: PUSH
70953: LD_VAR 0 2
70957: ARRAY
70958: PPUSH
70959: LD_VAR 0 3
70963: PPUSH
70964: CALL_OW 1
70968: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
70969: LD_ADDR_VAR 0 7
70973: PUSH
70974: LD_VAR 0 7
70978: PPUSH
70979: LD_VAR 0 7
70983: PPUSH
70984: LD_VAR 0 6
70988: PPUSH
70989: CALL_OW 1
70993: ST_TO_ADDR
// for i = s_arr downto 2 do
70994: LD_ADDR_VAR 0 5
70998: PUSH
70999: DOUBLE
71000: LD_VAR 0 7
71004: INC
71005: ST_TO_ADDR
71006: LD_INT 2
71008: PUSH
71009: FOR_DOWNTO
71010: IFFALSE 71094
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71012: LD_ADDR_VAR 0 6
71016: PUSH
71017: LD_VAR 0 7
71021: PUSH
71022: LD_VAR 0 5
71026: PUSH
71027: LD_INT 1
71029: MINUS
71030: ARRAY
71031: PPUSH
71032: LD_VAR 0 2
71036: PUSH
71037: LD_VAR 0 5
71041: PUSH
71042: LD_INT 1
71044: MINUS
71045: ARRAY
71046: PPUSH
71047: LD_VAR 0 7
71051: PUSH
71052: LD_VAR 0 5
71056: ARRAY
71057: PPUSH
71058: CALL_OW 1
71062: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71063: LD_ADDR_VAR 0 7
71067: PUSH
71068: LD_VAR 0 7
71072: PPUSH
71073: LD_VAR 0 5
71077: PUSH
71078: LD_INT 1
71080: MINUS
71081: PPUSH
71082: LD_VAR 0 6
71086: PPUSH
71087: CALL_OW 1
71091: ST_TO_ADDR
// end ;
71092: GO 71009
71094: POP
71095: POP
// result := s_arr [ 1 ] ;
71096: LD_ADDR_VAR 0 4
71100: PUSH
71101: LD_VAR 0 7
71105: PUSH
71106: LD_INT 1
71108: ARRAY
71109: ST_TO_ADDR
// end ; end ;
71110: LD_VAR 0 4
71114: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71115: LD_INT 0
71117: PPUSH
71118: PPUSH
// if not list then
71119: LD_VAR 0 1
71123: NOT
71124: IFFALSE 71128
// exit ;
71126: GO 71219
// i := list [ pos1 ] ;
71128: LD_ADDR_VAR 0 5
71132: PUSH
71133: LD_VAR 0 1
71137: PUSH
71138: LD_VAR 0 2
71142: ARRAY
71143: ST_TO_ADDR
// if not i then
71144: LD_VAR 0 5
71148: NOT
71149: IFFALSE 71153
// exit ;
71151: GO 71219
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71153: LD_ADDR_VAR 0 1
71157: PUSH
71158: LD_VAR 0 1
71162: PPUSH
71163: LD_VAR 0 2
71167: PPUSH
71168: LD_VAR 0 1
71172: PUSH
71173: LD_VAR 0 3
71177: ARRAY
71178: PPUSH
71179: CALL_OW 1
71183: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71184: LD_ADDR_VAR 0 1
71188: PUSH
71189: LD_VAR 0 1
71193: PPUSH
71194: LD_VAR 0 3
71198: PPUSH
71199: LD_VAR 0 5
71203: PPUSH
71204: CALL_OW 1
71208: ST_TO_ADDR
// result := list ;
71209: LD_ADDR_VAR 0 4
71213: PUSH
71214: LD_VAR 0 1
71218: ST_TO_ADDR
// end ;
71219: LD_VAR 0 4
71223: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71224: LD_INT 0
71226: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71227: LD_ADDR_VAR 0 5
71231: PUSH
71232: LD_VAR 0 1
71236: PPUSH
71237: CALL_OW 250
71241: PPUSH
71242: LD_VAR 0 1
71246: PPUSH
71247: CALL_OW 251
71251: PPUSH
71252: LD_VAR 0 2
71256: PPUSH
71257: LD_VAR 0 3
71261: PPUSH
71262: LD_VAR 0 4
71266: PPUSH
71267: CALL 71277 0 5
71271: ST_TO_ADDR
// end ;
71272: LD_VAR 0 5
71276: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71277: LD_INT 0
71279: PPUSH
71280: PPUSH
71281: PPUSH
71282: PPUSH
// if not list then
71283: LD_VAR 0 3
71287: NOT
71288: IFFALSE 71292
// exit ;
71290: GO 71680
// result := [ ] ;
71292: LD_ADDR_VAR 0 6
71296: PUSH
71297: EMPTY
71298: ST_TO_ADDR
// for i in list do
71299: LD_ADDR_VAR 0 7
71303: PUSH
71304: LD_VAR 0 3
71308: PUSH
71309: FOR_IN
71310: IFFALSE 71512
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71312: LD_ADDR_VAR 0 9
71316: PUSH
71317: LD_VAR 0 7
71321: PPUSH
71322: LD_VAR 0 1
71326: PPUSH
71327: LD_VAR 0 2
71331: PPUSH
71332: CALL_OW 297
71336: ST_TO_ADDR
// if not result then
71337: LD_VAR 0 6
71341: NOT
71342: IFFALSE 71368
// result := [ [ i , tmp ] ] else
71344: LD_ADDR_VAR 0 6
71348: PUSH
71349: LD_VAR 0 7
71353: PUSH
71354: LD_VAR 0 9
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PUSH
71363: EMPTY
71364: LIST
71365: ST_TO_ADDR
71366: GO 71510
// begin if result [ result ] [ 2 ] < tmp then
71368: LD_VAR 0 6
71372: PUSH
71373: LD_VAR 0 6
71377: ARRAY
71378: PUSH
71379: LD_INT 2
71381: ARRAY
71382: PUSH
71383: LD_VAR 0 9
71387: LESS
71388: IFFALSE 71430
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71390: LD_ADDR_VAR 0 6
71394: PUSH
71395: LD_VAR 0 6
71399: PPUSH
71400: LD_VAR 0 6
71404: PUSH
71405: LD_INT 1
71407: PLUS
71408: PPUSH
71409: LD_VAR 0 7
71413: PUSH
71414: LD_VAR 0 9
71418: PUSH
71419: EMPTY
71420: LIST
71421: LIST
71422: PPUSH
71423: CALL_OW 2
71427: ST_TO_ADDR
71428: GO 71510
// for j = 1 to result do
71430: LD_ADDR_VAR 0 8
71434: PUSH
71435: DOUBLE
71436: LD_INT 1
71438: DEC
71439: ST_TO_ADDR
71440: LD_VAR 0 6
71444: PUSH
71445: FOR_TO
71446: IFFALSE 71508
// begin if tmp < result [ j ] [ 2 ] then
71448: LD_VAR 0 9
71452: PUSH
71453: LD_VAR 0 6
71457: PUSH
71458: LD_VAR 0 8
71462: ARRAY
71463: PUSH
71464: LD_INT 2
71466: ARRAY
71467: LESS
71468: IFFALSE 71506
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71470: LD_ADDR_VAR 0 6
71474: PUSH
71475: LD_VAR 0 6
71479: PPUSH
71480: LD_VAR 0 8
71484: PPUSH
71485: LD_VAR 0 7
71489: PUSH
71490: LD_VAR 0 9
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: PPUSH
71499: CALL_OW 2
71503: ST_TO_ADDR
// break ;
71504: GO 71508
// end ; end ;
71506: GO 71445
71508: POP
71509: POP
// end ; end ;
71510: GO 71309
71512: POP
71513: POP
// if result and not asc then
71514: LD_VAR 0 6
71518: PUSH
71519: LD_VAR 0 4
71523: NOT
71524: AND
71525: IFFALSE 71600
// begin tmp := result ;
71527: LD_ADDR_VAR 0 9
71531: PUSH
71532: LD_VAR 0 6
71536: ST_TO_ADDR
// for i = tmp downto 1 do
71537: LD_ADDR_VAR 0 7
71541: PUSH
71542: DOUBLE
71543: LD_VAR 0 9
71547: INC
71548: ST_TO_ADDR
71549: LD_INT 1
71551: PUSH
71552: FOR_DOWNTO
71553: IFFALSE 71598
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71555: LD_ADDR_VAR 0 6
71559: PUSH
71560: LD_VAR 0 6
71564: PPUSH
71565: LD_VAR 0 9
71569: PUSH
71570: LD_VAR 0 7
71574: MINUS
71575: PUSH
71576: LD_INT 1
71578: PLUS
71579: PPUSH
71580: LD_VAR 0 9
71584: PUSH
71585: LD_VAR 0 7
71589: ARRAY
71590: PPUSH
71591: CALL_OW 1
71595: ST_TO_ADDR
71596: GO 71552
71598: POP
71599: POP
// end ; tmp := [ ] ;
71600: LD_ADDR_VAR 0 9
71604: PUSH
71605: EMPTY
71606: ST_TO_ADDR
// if mode then
71607: LD_VAR 0 5
71611: IFFALSE 71680
// begin for i = 1 to result do
71613: LD_ADDR_VAR 0 7
71617: PUSH
71618: DOUBLE
71619: LD_INT 1
71621: DEC
71622: ST_TO_ADDR
71623: LD_VAR 0 6
71627: PUSH
71628: FOR_TO
71629: IFFALSE 71668
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71631: LD_ADDR_VAR 0 9
71635: PUSH
71636: LD_VAR 0 9
71640: PPUSH
71641: LD_VAR 0 7
71645: PPUSH
71646: LD_VAR 0 6
71650: PUSH
71651: LD_VAR 0 7
71655: ARRAY
71656: PUSH
71657: LD_INT 1
71659: ARRAY
71660: PPUSH
71661: CALL_OW 1
71665: ST_TO_ADDR
71666: GO 71628
71668: POP
71669: POP
// result := tmp ;
71670: LD_ADDR_VAR 0 6
71674: PUSH
71675: LD_VAR 0 9
71679: ST_TO_ADDR
// end ; end ;
71680: LD_VAR 0 6
71684: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71685: LD_INT 0
71687: PPUSH
71688: PPUSH
71689: PPUSH
71690: PPUSH
71691: PPUSH
71692: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71693: LD_ADDR_VAR 0 5
71697: PUSH
71698: LD_INT 0
71700: PUSH
71701: LD_INT 0
71703: PUSH
71704: LD_INT 0
71706: PUSH
71707: EMPTY
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: ST_TO_ADDR
// if not x or not y then
71715: LD_VAR 0 2
71719: NOT
71720: PUSH
71721: LD_VAR 0 3
71725: NOT
71726: OR
71727: IFFALSE 71731
// exit ;
71729: GO 73377
// if not range then
71731: LD_VAR 0 4
71735: NOT
71736: IFFALSE 71746
// range := 10 ;
71738: LD_ADDR_VAR 0 4
71742: PUSH
71743: LD_INT 10
71745: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71746: LD_ADDR_VAR 0 8
71750: PUSH
71751: LD_INT 81
71753: PUSH
71754: LD_VAR 0 1
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: LD_INT 92
71765: PUSH
71766: LD_VAR 0 2
71770: PUSH
71771: LD_VAR 0 3
71775: PUSH
71776: LD_VAR 0 4
71780: PUSH
71781: EMPTY
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: PUSH
71787: LD_INT 3
71789: PUSH
71790: LD_INT 21
71792: PUSH
71793: LD_INT 3
71795: PUSH
71796: EMPTY
71797: LIST
71798: LIST
71799: PUSH
71800: EMPTY
71801: LIST
71802: LIST
71803: PUSH
71804: EMPTY
71805: LIST
71806: LIST
71807: LIST
71808: PPUSH
71809: CALL_OW 69
71813: ST_TO_ADDR
// if not tmp then
71814: LD_VAR 0 8
71818: NOT
71819: IFFALSE 71823
// exit ;
71821: GO 73377
// for i in tmp do
71823: LD_ADDR_VAR 0 6
71827: PUSH
71828: LD_VAR 0 8
71832: PUSH
71833: FOR_IN
71834: IFFALSE 73352
// begin points := [ 0 , 0 , 0 ] ;
71836: LD_ADDR_VAR 0 9
71840: PUSH
71841: LD_INT 0
71843: PUSH
71844: LD_INT 0
71846: PUSH
71847: LD_INT 0
71849: PUSH
71850: EMPTY
71851: LIST
71852: LIST
71853: LIST
71854: ST_TO_ADDR
// bpoints := 1 ;
71855: LD_ADDR_VAR 0 10
71859: PUSH
71860: LD_INT 1
71862: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71863: LD_VAR 0 6
71867: PPUSH
71868: CALL_OW 247
71872: PUSH
71873: LD_INT 1
71875: DOUBLE
71876: EQUAL
71877: IFTRUE 71881
71879: GO 72459
71881: POP
// begin if GetClass ( i ) = 1 then
71882: LD_VAR 0 6
71886: PPUSH
71887: CALL_OW 257
71891: PUSH
71892: LD_INT 1
71894: EQUAL
71895: IFFALSE 71916
// points := [ 10 , 5 , 3 ] ;
71897: LD_ADDR_VAR 0 9
71901: PUSH
71902: LD_INT 10
71904: PUSH
71905: LD_INT 5
71907: PUSH
71908: LD_INT 3
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: LIST
71915: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71916: LD_VAR 0 6
71920: PPUSH
71921: CALL_OW 257
71925: PUSH
71926: LD_INT 2
71928: PUSH
71929: LD_INT 3
71931: PUSH
71932: LD_INT 4
71934: PUSH
71935: EMPTY
71936: LIST
71937: LIST
71938: LIST
71939: IN
71940: IFFALSE 71961
// points := [ 3 , 2 , 1 ] ;
71942: LD_ADDR_VAR 0 9
71946: PUSH
71947: LD_INT 3
71949: PUSH
71950: LD_INT 2
71952: PUSH
71953: LD_INT 1
71955: PUSH
71956: EMPTY
71957: LIST
71958: LIST
71959: LIST
71960: ST_TO_ADDR
// if GetClass ( i ) = 5 then
71961: LD_VAR 0 6
71965: PPUSH
71966: CALL_OW 257
71970: PUSH
71971: LD_INT 5
71973: EQUAL
71974: IFFALSE 71995
// points := [ 130 , 5 , 2 ] ;
71976: LD_ADDR_VAR 0 9
71980: PUSH
71981: LD_INT 130
71983: PUSH
71984: LD_INT 5
71986: PUSH
71987: LD_INT 2
71989: PUSH
71990: EMPTY
71991: LIST
71992: LIST
71993: LIST
71994: ST_TO_ADDR
// if GetClass ( i ) = 8 then
71995: LD_VAR 0 6
71999: PPUSH
72000: CALL_OW 257
72004: PUSH
72005: LD_INT 8
72007: EQUAL
72008: IFFALSE 72029
// points := [ 35 , 35 , 30 ] ;
72010: LD_ADDR_VAR 0 9
72014: PUSH
72015: LD_INT 35
72017: PUSH
72018: LD_INT 35
72020: PUSH
72021: LD_INT 30
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: LIST
72028: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72029: LD_VAR 0 6
72033: PPUSH
72034: CALL_OW 257
72038: PUSH
72039: LD_INT 9
72041: EQUAL
72042: IFFALSE 72063
// points := [ 20 , 55 , 40 ] ;
72044: LD_ADDR_VAR 0 9
72048: PUSH
72049: LD_INT 20
72051: PUSH
72052: LD_INT 55
72054: PUSH
72055: LD_INT 40
72057: PUSH
72058: EMPTY
72059: LIST
72060: LIST
72061: LIST
72062: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72063: LD_VAR 0 6
72067: PPUSH
72068: CALL_OW 257
72072: PUSH
72073: LD_INT 12
72075: PUSH
72076: LD_INT 16
72078: PUSH
72079: EMPTY
72080: LIST
72081: LIST
72082: IN
72083: IFFALSE 72104
// points := [ 5 , 3 , 2 ] ;
72085: LD_ADDR_VAR 0 9
72089: PUSH
72090: LD_INT 5
72092: PUSH
72093: LD_INT 3
72095: PUSH
72096: LD_INT 2
72098: PUSH
72099: EMPTY
72100: LIST
72101: LIST
72102: LIST
72103: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72104: LD_VAR 0 6
72108: PPUSH
72109: CALL_OW 257
72113: PUSH
72114: LD_INT 17
72116: EQUAL
72117: IFFALSE 72138
// points := [ 100 , 50 , 75 ] ;
72119: LD_ADDR_VAR 0 9
72123: PUSH
72124: LD_INT 100
72126: PUSH
72127: LD_INT 50
72129: PUSH
72130: LD_INT 75
72132: PUSH
72133: EMPTY
72134: LIST
72135: LIST
72136: LIST
72137: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72138: LD_VAR 0 6
72142: PPUSH
72143: CALL_OW 257
72147: PUSH
72148: LD_INT 15
72150: EQUAL
72151: IFFALSE 72172
// points := [ 10 , 5 , 3 ] ;
72153: LD_ADDR_VAR 0 9
72157: PUSH
72158: LD_INT 10
72160: PUSH
72161: LD_INT 5
72163: PUSH
72164: LD_INT 3
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: LIST
72171: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72172: LD_VAR 0 6
72176: PPUSH
72177: CALL_OW 257
72181: PUSH
72182: LD_INT 14
72184: EQUAL
72185: IFFALSE 72206
// points := [ 10 , 0 , 0 ] ;
72187: LD_ADDR_VAR 0 9
72191: PUSH
72192: LD_INT 10
72194: PUSH
72195: LD_INT 0
72197: PUSH
72198: LD_INT 0
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: LIST
72205: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72206: LD_VAR 0 6
72210: PPUSH
72211: CALL_OW 257
72215: PUSH
72216: LD_INT 11
72218: EQUAL
72219: IFFALSE 72240
// points := [ 30 , 10 , 5 ] ;
72221: LD_ADDR_VAR 0 9
72225: PUSH
72226: LD_INT 30
72228: PUSH
72229: LD_INT 10
72231: PUSH
72232: LD_INT 5
72234: PUSH
72235: EMPTY
72236: LIST
72237: LIST
72238: LIST
72239: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72240: LD_VAR 0 1
72244: PPUSH
72245: LD_INT 5
72247: PPUSH
72248: CALL_OW 321
72252: PUSH
72253: LD_INT 2
72255: EQUAL
72256: IFFALSE 72273
// bpoints := bpoints * 1.8 ;
72258: LD_ADDR_VAR 0 10
72262: PUSH
72263: LD_VAR 0 10
72267: PUSH
72268: LD_REAL  1.80000000000000E+0000
72271: MUL
72272: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72273: LD_VAR 0 6
72277: PPUSH
72278: CALL_OW 257
72282: PUSH
72283: LD_INT 1
72285: PUSH
72286: LD_INT 2
72288: PUSH
72289: LD_INT 3
72291: PUSH
72292: LD_INT 4
72294: PUSH
72295: EMPTY
72296: LIST
72297: LIST
72298: LIST
72299: LIST
72300: IN
72301: PUSH
72302: LD_VAR 0 1
72306: PPUSH
72307: LD_INT 51
72309: PPUSH
72310: CALL_OW 321
72314: PUSH
72315: LD_INT 2
72317: EQUAL
72318: AND
72319: IFFALSE 72336
// bpoints := bpoints * 1.2 ;
72321: LD_ADDR_VAR 0 10
72325: PUSH
72326: LD_VAR 0 10
72330: PUSH
72331: LD_REAL  1.20000000000000E+0000
72334: MUL
72335: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72336: LD_VAR 0 6
72340: PPUSH
72341: CALL_OW 257
72345: PUSH
72346: LD_INT 5
72348: PUSH
72349: LD_INT 7
72351: PUSH
72352: LD_INT 9
72354: PUSH
72355: EMPTY
72356: LIST
72357: LIST
72358: LIST
72359: IN
72360: PUSH
72361: LD_VAR 0 1
72365: PPUSH
72366: LD_INT 52
72368: PPUSH
72369: CALL_OW 321
72373: PUSH
72374: LD_INT 2
72376: EQUAL
72377: AND
72378: IFFALSE 72395
// bpoints := bpoints * 1.5 ;
72380: LD_ADDR_VAR 0 10
72384: PUSH
72385: LD_VAR 0 10
72389: PUSH
72390: LD_REAL  1.50000000000000E+0000
72393: MUL
72394: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72395: LD_VAR 0 1
72399: PPUSH
72400: LD_INT 66
72402: PPUSH
72403: CALL_OW 321
72407: PUSH
72408: LD_INT 2
72410: EQUAL
72411: IFFALSE 72428
// bpoints := bpoints * 1.1 ;
72413: LD_ADDR_VAR 0 10
72417: PUSH
72418: LD_VAR 0 10
72422: PUSH
72423: LD_REAL  1.10000000000000E+0000
72426: MUL
72427: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72428: LD_ADDR_VAR 0 10
72432: PUSH
72433: LD_VAR 0 10
72437: PUSH
72438: LD_VAR 0 6
72442: PPUSH
72443: LD_INT 1
72445: PPUSH
72446: CALL_OW 259
72450: PUSH
72451: LD_REAL  1.15000000000000E+0000
72454: MUL
72455: MUL
72456: ST_TO_ADDR
// end ; unit_vehicle :
72457: GO 73281
72459: LD_INT 2
72461: DOUBLE
72462: EQUAL
72463: IFTRUE 72467
72465: GO 73269
72467: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72468: LD_VAR 0 6
72472: PPUSH
72473: CALL_OW 264
72477: PUSH
72478: LD_INT 2
72480: PUSH
72481: LD_INT 42
72483: PUSH
72484: LD_INT 24
72486: PUSH
72487: EMPTY
72488: LIST
72489: LIST
72490: LIST
72491: IN
72492: IFFALSE 72513
// points := [ 25 , 5 , 3 ] ;
72494: LD_ADDR_VAR 0 9
72498: PUSH
72499: LD_INT 25
72501: PUSH
72502: LD_INT 5
72504: PUSH
72505: LD_INT 3
72507: PUSH
72508: EMPTY
72509: LIST
72510: LIST
72511: LIST
72512: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72513: LD_VAR 0 6
72517: PPUSH
72518: CALL_OW 264
72522: PUSH
72523: LD_INT 4
72525: PUSH
72526: LD_INT 43
72528: PUSH
72529: LD_INT 25
72531: PUSH
72532: EMPTY
72533: LIST
72534: LIST
72535: LIST
72536: IN
72537: IFFALSE 72558
// points := [ 40 , 15 , 5 ] ;
72539: LD_ADDR_VAR 0 9
72543: PUSH
72544: LD_INT 40
72546: PUSH
72547: LD_INT 15
72549: PUSH
72550: LD_INT 5
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: LIST
72557: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72558: LD_VAR 0 6
72562: PPUSH
72563: CALL_OW 264
72567: PUSH
72568: LD_INT 3
72570: PUSH
72571: LD_INT 23
72573: PUSH
72574: EMPTY
72575: LIST
72576: LIST
72577: IN
72578: IFFALSE 72599
// points := [ 7 , 25 , 8 ] ;
72580: LD_ADDR_VAR 0 9
72584: PUSH
72585: LD_INT 7
72587: PUSH
72588: LD_INT 25
72590: PUSH
72591: LD_INT 8
72593: PUSH
72594: EMPTY
72595: LIST
72596: LIST
72597: LIST
72598: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72599: LD_VAR 0 6
72603: PPUSH
72604: CALL_OW 264
72608: PUSH
72609: LD_INT 5
72611: PUSH
72612: LD_INT 27
72614: PUSH
72615: LD_INT 44
72617: PUSH
72618: EMPTY
72619: LIST
72620: LIST
72621: LIST
72622: IN
72623: IFFALSE 72644
// points := [ 14 , 50 , 16 ] ;
72625: LD_ADDR_VAR 0 9
72629: PUSH
72630: LD_INT 14
72632: PUSH
72633: LD_INT 50
72635: PUSH
72636: LD_INT 16
72638: PUSH
72639: EMPTY
72640: LIST
72641: LIST
72642: LIST
72643: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72644: LD_VAR 0 6
72648: PPUSH
72649: CALL_OW 264
72653: PUSH
72654: LD_INT 6
72656: PUSH
72657: LD_INT 46
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: IN
72664: IFFALSE 72685
// points := [ 32 , 120 , 70 ] ;
72666: LD_ADDR_VAR 0 9
72670: PUSH
72671: LD_INT 32
72673: PUSH
72674: LD_INT 120
72676: PUSH
72677: LD_INT 70
72679: PUSH
72680: EMPTY
72681: LIST
72682: LIST
72683: LIST
72684: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
72685: LD_VAR 0 6
72689: PPUSH
72690: CALL_OW 264
72694: PUSH
72695: LD_INT 7
72697: PUSH
72698: LD_INT 28
72700: PUSH
72701: LD_INT 45
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: LIST
72708: IN
72709: IFFALSE 72730
// points := [ 35 , 20 , 45 ] ;
72711: LD_ADDR_VAR 0 9
72715: PUSH
72716: LD_INT 35
72718: PUSH
72719: LD_INT 20
72721: PUSH
72722: LD_INT 45
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: LIST
72729: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72730: LD_VAR 0 6
72734: PPUSH
72735: CALL_OW 264
72739: PUSH
72740: LD_INT 47
72742: PUSH
72743: EMPTY
72744: LIST
72745: IN
72746: IFFALSE 72767
// points := [ 67 , 45 , 75 ] ;
72748: LD_ADDR_VAR 0 9
72752: PUSH
72753: LD_INT 67
72755: PUSH
72756: LD_INT 45
72758: PUSH
72759: LD_INT 75
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: LIST
72766: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72767: LD_VAR 0 6
72771: PPUSH
72772: CALL_OW 264
72776: PUSH
72777: LD_INT 26
72779: PUSH
72780: EMPTY
72781: LIST
72782: IN
72783: IFFALSE 72804
// points := [ 120 , 30 , 80 ] ;
72785: LD_ADDR_VAR 0 9
72789: PUSH
72790: LD_INT 120
72792: PUSH
72793: LD_INT 30
72795: PUSH
72796: LD_INT 80
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: LIST
72803: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72804: LD_VAR 0 6
72808: PPUSH
72809: CALL_OW 264
72813: PUSH
72814: LD_INT 22
72816: PUSH
72817: EMPTY
72818: LIST
72819: IN
72820: IFFALSE 72841
// points := [ 40 , 1 , 1 ] ;
72822: LD_ADDR_VAR 0 9
72826: PUSH
72827: LD_INT 40
72829: PUSH
72830: LD_INT 1
72832: PUSH
72833: LD_INT 1
72835: PUSH
72836: EMPTY
72837: LIST
72838: LIST
72839: LIST
72840: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72841: LD_VAR 0 6
72845: PPUSH
72846: CALL_OW 264
72850: PUSH
72851: LD_INT 29
72853: PUSH
72854: EMPTY
72855: LIST
72856: IN
72857: IFFALSE 72878
// points := [ 70 , 200 , 400 ] ;
72859: LD_ADDR_VAR 0 9
72863: PUSH
72864: LD_INT 70
72866: PUSH
72867: LD_INT 200
72869: PUSH
72870: LD_INT 400
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: LIST
72877: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72878: LD_VAR 0 6
72882: PPUSH
72883: CALL_OW 264
72887: PUSH
72888: LD_INT 14
72890: PUSH
72891: LD_INT 53
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: IN
72898: IFFALSE 72919
// points := [ 40 , 10 , 20 ] ;
72900: LD_ADDR_VAR 0 9
72904: PUSH
72905: LD_INT 40
72907: PUSH
72908: LD_INT 10
72910: PUSH
72911: LD_INT 20
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: LIST
72918: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
72919: LD_VAR 0 6
72923: PPUSH
72924: CALL_OW 264
72928: PUSH
72929: LD_INT 9
72931: PUSH
72932: EMPTY
72933: LIST
72934: IN
72935: IFFALSE 72956
// points := [ 5 , 70 , 20 ] ;
72937: LD_ADDR_VAR 0 9
72941: PUSH
72942: LD_INT 5
72944: PUSH
72945: LD_INT 70
72947: PUSH
72948: LD_INT 20
72950: PUSH
72951: EMPTY
72952: LIST
72953: LIST
72954: LIST
72955: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
72956: LD_VAR 0 6
72960: PPUSH
72961: CALL_OW 264
72965: PUSH
72966: LD_INT 10
72968: PUSH
72969: EMPTY
72970: LIST
72971: IN
72972: IFFALSE 72993
// points := [ 35 , 110 , 70 ] ;
72974: LD_ADDR_VAR 0 9
72978: PUSH
72979: LD_INT 35
72981: PUSH
72982: LD_INT 110
72984: PUSH
72985: LD_INT 70
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: LIST
72992: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
72993: LD_VAR 0 6
72997: PPUSH
72998: CALL_OW 265
73002: PUSH
73003: LD_INT 25
73005: EQUAL
73006: IFFALSE 73027
// points := [ 80 , 65 , 100 ] ;
73008: LD_ADDR_VAR 0 9
73012: PUSH
73013: LD_INT 80
73015: PUSH
73016: LD_INT 65
73018: PUSH
73019: LD_INT 100
73021: PUSH
73022: EMPTY
73023: LIST
73024: LIST
73025: LIST
73026: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73027: LD_VAR 0 6
73031: PPUSH
73032: CALL_OW 263
73036: PUSH
73037: LD_INT 1
73039: EQUAL
73040: IFFALSE 73075
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73042: LD_ADDR_VAR 0 10
73046: PUSH
73047: LD_VAR 0 10
73051: PUSH
73052: LD_VAR 0 6
73056: PPUSH
73057: CALL_OW 311
73061: PPUSH
73062: LD_INT 3
73064: PPUSH
73065: CALL_OW 259
73069: PUSH
73070: LD_INT 4
73072: MUL
73073: MUL
73074: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73075: LD_VAR 0 6
73079: PPUSH
73080: CALL_OW 263
73084: PUSH
73085: LD_INT 2
73087: EQUAL
73088: IFFALSE 73139
// begin j := IsControledBy ( i ) ;
73090: LD_ADDR_VAR 0 7
73094: PUSH
73095: LD_VAR 0 6
73099: PPUSH
73100: CALL_OW 312
73104: ST_TO_ADDR
// if j then
73105: LD_VAR 0 7
73109: IFFALSE 73139
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73111: LD_ADDR_VAR 0 10
73115: PUSH
73116: LD_VAR 0 10
73120: PUSH
73121: LD_VAR 0 7
73125: PPUSH
73126: LD_INT 3
73128: PPUSH
73129: CALL_OW 259
73133: PUSH
73134: LD_INT 3
73136: MUL
73137: MUL
73138: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73139: LD_VAR 0 6
73143: PPUSH
73144: CALL_OW 264
73148: PUSH
73149: LD_INT 5
73151: PUSH
73152: LD_INT 6
73154: PUSH
73155: LD_INT 46
73157: PUSH
73158: LD_INT 44
73160: PUSH
73161: LD_INT 47
73163: PUSH
73164: LD_INT 45
73166: PUSH
73167: LD_INT 28
73169: PUSH
73170: LD_INT 7
73172: PUSH
73173: LD_INT 27
73175: PUSH
73176: LD_INT 29
73178: PUSH
73179: EMPTY
73180: LIST
73181: LIST
73182: LIST
73183: LIST
73184: LIST
73185: LIST
73186: LIST
73187: LIST
73188: LIST
73189: LIST
73190: IN
73191: PUSH
73192: LD_VAR 0 1
73196: PPUSH
73197: LD_INT 52
73199: PPUSH
73200: CALL_OW 321
73204: PUSH
73205: LD_INT 2
73207: EQUAL
73208: AND
73209: IFFALSE 73226
// bpoints := bpoints * 1.2 ;
73211: LD_ADDR_VAR 0 10
73215: PUSH
73216: LD_VAR 0 10
73220: PUSH
73221: LD_REAL  1.20000000000000E+0000
73224: MUL
73225: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73226: LD_VAR 0 6
73230: PPUSH
73231: CALL_OW 264
73235: PUSH
73236: LD_INT 6
73238: PUSH
73239: LD_INT 46
73241: PUSH
73242: LD_INT 47
73244: PUSH
73245: EMPTY
73246: LIST
73247: LIST
73248: LIST
73249: IN
73250: IFFALSE 73267
// bpoints := bpoints * 1.2 ;
73252: LD_ADDR_VAR 0 10
73256: PUSH
73257: LD_VAR 0 10
73261: PUSH
73262: LD_REAL  1.20000000000000E+0000
73265: MUL
73266: ST_TO_ADDR
// end ; unit_building :
73267: GO 73281
73269: LD_INT 3
73271: DOUBLE
73272: EQUAL
73273: IFTRUE 73277
73275: GO 73280
73277: POP
// ; end ;
73278: GO 73281
73280: POP
// for j = 1 to 3 do
73281: LD_ADDR_VAR 0 7
73285: PUSH
73286: DOUBLE
73287: LD_INT 1
73289: DEC
73290: ST_TO_ADDR
73291: LD_INT 3
73293: PUSH
73294: FOR_TO
73295: IFFALSE 73348
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73297: LD_ADDR_VAR 0 5
73301: PUSH
73302: LD_VAR 0 5
73306: PPUSH
73307: LD_VAR 0 7
73311: PPUSH
73312: LD_VAR 0 5
73316: PUSH
73317: LD_VAR 0 7
73321: ARRAY
73322: PUSH
73323: LD_VAR 0 9
73327: PUSH
73328: LD_VAR 0 7
73332: ARRAY
73333: PUSH
73334: LD_VAR 0 10
73338: MUL
73339: PLUS
73340: PPUSH
73341: CALL_OW 1
73345: ST_TO_ADDR
73346: GO 73294
73348: POP
73349: POP
// end ;
73350: GO 71833
73352: POP
73353: POP
// result := Replace ( result , 4 , tmp ) ;
73354: LD_ADDR_VAR 0 5
73358: PUSH
73359: LD_VAR 0 5
73363: PPUSH
73364: LD_INT 4
73366: PPUSH
73367: LD_VAR 0 8
73371: PPUSH
73372: CALL_OW 1
73376: ST_TO_ADDR
// end ;
73377: LD_VAR 0 5
73381: RET
// export function DangerAtRange ( unit , range ) ; begin
73382: LD_INT 0
73384: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73385: LD_ADDR_VAR 0 3
73389: PUSH
73390: LD_VAR 0 1
73394: PPUSH
73395: CALL_OW 255
73399: PPUSH
73400: LD_VAR 0 1
73404: PPUSH
73405: CALL_OW 250
73409: PPUSH
73410: LD_VAR 0 1
73414: PPUSH
73415: CALL_OW 251
73419: PPUSH
73420: LD_VAR 0 2
73424: PPUSH
73425: CALL 71685 0 4
73429: ST_TO_ADDR
// end ;
73430: LD_VAR 0 3
73434: RET
// export function DangerInArea ( side , area ) ; begin
73435: LD_INT 0
73437: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73438: LD_ADDR_VAR 0 3
73442: PUSH
73443: LD_VAR 0 2
73447: PPUSH
73448: LD_INT 81
73450: PUSH
73451: LD_VAR 0 1
73455: PUSH
73456: EMPTY
73457: LIST
73458: LIST
73459: PPUSH
73460: CALL_OW 70
73464: ST_TO_ADDR
// end ;
73465: LD_VAR 0 3
73469: RET
// export function IsExtension ( b ) ; begin
73470: LD_INT 0
73472: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73473: LD_ADDR_VAR 0 2
73477: PUSH
73478: LD_VAR 0 1
73482: PUSH
73483: LD_INT 23
73485: PUSH
73486: LD_INT 20
73488: PUSH
73489: LD_INT 22
73491: PUSH
73492: LD_INT 17
73494: PUSH
73495: LD_INT 24
73497: PUSH
73498: LD_INT 21
73500: PUSH
73501: LD_INT 19
73503: PUSH
73504: LD_INT 16
73506: PUSH
73507: LD_INT 25
73509: PUSH
73510: LD_INT 18
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: IN
73525: ST_TO_ADDR
// end ;
73526: LD_VAR 0 2
73530: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
73531: LD_INT 0
73533: PPUSH
73534: PPUSH
73535: PPUSH
// result := [ ] ;
73536: LD_ADDR_VAR 0 3
73540: PUSH
73541: EMPTY
73542: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73543: LD_ADDR_VAR 0 4
73547: PUSH
73548: LD_VAR 0 2
73552: PPUSH
73553: LD_INT 21
73555: PUSH
73556: LD_INT 3
73558: PUSH
73559: EMPTY
73560: LIST
73561: LIST
73562: PPUSH
73563: CALL_OW 70
73567: ST_TO_ADDR
// if not tmp then
73568: LD_VAR 0 4
73572: NOT
73573: IFFALSE 73577
// exit ;
73575: GO 73635
// for i in tmp do
73577: LD_ADDR_VAR 0 5
73581: PUSH
73582: LD_VAR 0 4
73586: PUSH
73587: FOR_IN
73588: IFFALSE 73623
// if GetBase ( i ) <> base then
73590: LD_VAR 0 5
73594: PPUSH
73595: CALL_OW 274
73599: PUSH
73600: LD_VAR 0 1
73604: NONEQUAL
73605: IFFALSE 73621
// ComLinkToBase ( base , i ) ;
73607: LD_VAR 0 1
73611: PPUSH
73612: LD_VAR 0 5
73616: PPUSH
73617: CALL_OW 169
73621: GO 73587
73623: POP
73624: POP
// result := tmp ;
73625: LD_ADDR_VAR 0 3
73629: PUSH
73630: LD_VAR 0 4
73634: ST_TO_ADDR
// end ;
73635: LD_VAR 0 3
73639: RET
// export function ComComplete ( unit , b ) ; var i ; begin
73640: LD_INT 0
73642: PPUSH
73643: PPUSH
// if BuildingStatus ( b ) = bs_build then
73644: LD_VAR 0 2
73648: PPUSH
73649: CALL_OW 461
73653: PUSH
73654: LD_INT 1
73656: EQUAL
73657: IFFALSE 73717
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73659: LD_VAR 0 1
73663: PPUSH
73664: LD_STRING h
73666: PUSH
73667: LD_VAR 0 2
73671: PPUSH
73672: CALL_OW 250
73676: PUSH
73677: LD_VAR 0 2
73681: PPUSH
73682: CALL_OW 251
73686: PUSH
73687: LD_VAR 0 2
73691: PUSH
73692: LD_INT 0
73694: PUSH
73695: LD_INT 0
73697: PUSH
73698: LD_INT 0
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: LIST
73705: LIST
73706: LIST
73707: LIST
73708: LIST
73709: PUSH
73710: EMPTY
73711: LIST
73712: PPUSH
73713: CALL_OW 446
// end ;
73717: LD_VAR 0 3
73721: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73722: LD_INT 0
73724: PPUSH
73725: PPUSH
73726: PPUSH
73727: PPUSH
73728: PPUSH
73729: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
73730: LD_VAR 0 1
73734: NOT
73735: PUSH
73736: LD_VAR 0 1
73740: PPUSH
73741: CALL_OW 263
73745: PUSH
73746: LD_INT 2
73748: EQUAL
73749: NOT
73750: OR
73751: IFFALSE 73755
// exit ;
73753: GO 74071
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73755: LD_ADDR_VAR 0 6
73759: PUSH
73760: LD_INT 22
73762: PUSH
73763: LD_VAR 0 1
73767: PPUSH
73768: CALL_OW 255
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 2
73779: PUSH
73780: LD_INT 30
73782: PUSH
73783: LD_INT 36
73785: PUSH
73786: EMPTY
73787: LIST
73788: LIST
73789: PUSH
73790: LD_INT 34
73792: PUSH
73793: LD_INT 31
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: LIST
73804: PUSH
73805: EMPTY
73806: LIST
73807: LIST
73808: PPUSH
73809: CALL_OW 69
73813: ST_TO_ADDR
// if not tmp then
73814: LD_VAR 0 6
73818: NOT
73819: IFFALSE 73823
// exit ;
73821: GO 74071
// result := [ ] ;
73823: LD_ADDR_VAR 0 2
73827: PUSH
73828: EMPTY
73829: ST_TO_ADDR
// for i in tmp do
73830: LD_ADDR_VAR 0 3
73834: PUSH
73835: LD_VAR 0 6
73839: PUSH
73840: FOR_IN
73841: IFFALSE 73912
// begin t := UnitsInside ( i ) ;
73843: LD_ADDR_VAR 0 4
73847: PUSH
73848: LD_VAR 0 3
73852: PPUSH
73853: CALL_OW 313
73857: ST_TO_ADDR
// if t then
73858: LD_VAR 0 4
73862: IFFALSE 73910
// for j in t do
73864: LD_ADDR_VAR 0 7
73868: PUSH
73869: LD_VAR 0 4
73873: PUSH
73874: FOR_IN
73875: IFFALSE 73908
// result := Insert ( result , result + 1 , j ) ;
73877: LD_ADDR_VAR 0 2
73881: PUSH
73882: LD_VAR 0 2
73886: PPUSH
73887: LD_VAR 0 2
73891: PUSH
73892: LD_INT 1
73894: PLUS
73895: PPUSH
73896: LD_VAR 0 7
73900: PPUSH
73901: CALL_OW 2
73905: ST_TO_ADDR
73906: GO 73874
73908: POP
73909: POP
// end ;
73910: GO 73840
73912: POP
73913: POP
// if not result then
73914: LD_VAR 0 2
73918: NOT
73919: IFFALSE 73923
// exit ;
73921: GO 74071
// mech := result [ 1 ] ;
73923: LD_ADDR_VAR 0 5
73927: PUSH
73928: LD_VAR 0 2
73932: PUSH
73933: LD_INT 1
73935: ARRAY
73936: ST_TO_ADDR
// if result > 1 then
73937: LD_VAR 0 2
73941: PUSH
73942: LD_INT 1
73944: GREATER
73945: IFFALSE 74057
// for i = 2 to result do
73947: LD_ADDR_VAR 0 3
73951: PUSH
73952: DOUBLE
73953: LD_INT 2
73955: DEC
73956: ST_TO_ADDR
73957: LD_VAR 0 2
73961: PUSH
73962: FOR_TO
73963: IFFALSE 74055
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
73965: LD_ADDR_VAR 0 4
73969: PUSH
73970: LD_VAR 0 2
73974: PUSH
73975: LD_VAR 0 3
73979: ARRAY
73980: PPUSH
73981: LD_INT 3
73983: PPUSH
73984: CALL_OW 259
73988: PUSH
73989: LD_VAR 0 2
73993: PUSH
73994: LD_VAR 0 3
73998: ARRAY
73999: PPUSH
74000: CALL_OW 432
74004: MINUS
74005: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74006: LD_VAR 0 4
74010: PUSH
74011: LD_VAR 0 5
74015: PPUSH
74016: LD_INT 3
74018: PPUSH
74019: CALL_OW 259
74023: PUSH
74024: LD_VAR 0 5
74028: PPUSH
74029: CALL_OW 432
74033: MINUS
74034: GREATEREQUAL
74035: IFFALSE 74053
// mech := result [ i ] ;
74037: LD_ADDR_VAR 0 5
74041: PUSH
74042: LD_VAR 0 2
74046: PUSH
74047: LD_VAR 0 3
74051: ARRAY
74052: ST_TO_ADDR
// end ;
74053: GO 73962
74055: POP
74056: POP
// ComLinkTo ( vehicle , mech ) ;
74057: LD_VAR 0 1
74061: PPUSH
74062: LD_VAR 0 5
74066: PPUSH
74067: CALL_OW 135
// end ;
74071: LD_VAR 0 2
74075: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74076: LD_INT 0
74078: PPUSH
74079: PPUSH
74080: PPUSH
74081: PPUSH
74082: PPUSH
74083: PPUSH
74084: PPUSH
74085: PPUSH
74086: PPUSH
74087: PPUSH
74088: PPUSH
74089: PPUSH
74090: PPUSH
// result := [ ] ;
74091: LD_ADDR_VAR 0 7
74095: PUSH
74096: EMPTY
74097: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74098: LD_VAR 0 1
74102: PPUSH
74103: CALL_OW 266
74107: PUSH
74108: LD_INT 0
74110: PUSH
74111: LD_INT 1
74113: PUSH
74114: EMPTY
74115: LIST
74116: LIST
74117: IN
74118: NOT
74119: IFFALSE 74123
// exit ;
74121: GO 75754
// if name then
74123: LD_VAR 0 3
74127: IFFALSE 74143
// SetBName ( base_dep , name ) ;
74129: LD_VAR 0 1
74133: PPUSH
74134: LD_VAR 0 3
74138: PPUSH
74139: CALL_OW 500
// base := GetBase ( base_dep ) ;
74143: LD_ADDR_VAR 0 15
74147: PUSH
74148: LD_VAR 0 1
74152: PPUSH
74153: CALL_OW 274
74157: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74158: LD_ADDR_VAR 0 16
74162: PUSH
74163: LD_VAR 0 1
74167: PPUSH
74168: CALL_OW 255
74172: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74173: LD_ADDR_VAR 0 17
74177: PUSH
74178: LD_VAR 0 1
74182: PPUSH
74183: CALL_OW 248
74187: ST_TO_ADDR
// if sources then
74188: LD_VAR 0 5
74192: IFFALSE 74239
// for i = 1 to 3 do
74194: LD_ADDR_VAR 0 8
74198: PUSH
74199: DOUBLE
74200: LD_INT 1
74202: DEC
74203: ST_TO_ADDR
74204: LD_INT 3
74206: PUSH
74207: FOR_TO
74208: IFFALSE 74237
// AddResourceType ( base , i , sources [ i ] ) ;
74210: LD_VAR 0 15
74214: PPUSH
74215: LD_VAR 0 8
74219: PPUSH
74220: LD_VAR 0 5
74224: PUSH
74225: LD_VAR 0 8
74229: ARRAY
74230: PPUSH
74231: CALL_OW 276
74235: GO 74207
74237: POP
74238: POP
// buildings := GetBaseBuildings ( base , area ) ;
74239: LD_ADDR_VAR 0 18
74243: PUSH
74244: LD_VAR 0 15
74248: PPUSH
74249: LD_VAR 0 2
74253: PPUSH
74254: CALL 73531 0 2
74258: ST_TO_ADDR
// InitHc ;
74259: CALL_OW 19
// InitUc ;
74263: CALL_OW 18
// uc_side := side ;
74267: LD_ADDR_OWVAR 20
74271: PUSH
74272: LD_VAR 0 16
74276: ST_TO_ADDR
// uc_nation := nation ;
74277: LD_ADDR_OWVAR 21
74281: PUSH
74282: LD_VAR 0 17
74286: ST_TO_ADDR
// if buildings then
74287: LD_VAR 0 18
74291: IFFALSE 75613
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74293: LD_ADDR_VAR 0 19
74297: PUSH
74298: LD_VAR 0 18
74302: PPUSH
74303: LD_INT 2
74305: PUSH
74306: LD_INT 30
74308: PUSH
74309: LD_INT 29
74311: PUSH
74312: EMPTY
74313: LIST
74314: LIST
74315: PUSH
74316: LD_INT 30
74318: PUSH
74319: LD_INT 30
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: EMPTY
74327: LIST
74328: LIST
74329: LIST
74330: PPUSH
74331: CALL_OW 72
74335: ST_TO_ADDR
// if tmp then
74336: LD_VAR 0 19
74340: IFFALSE 74388
// for i in tmp do
74342: LD_ADDR_VAR 0 8
74346: PUSH
74347: LD_VAR 0 19
74351: PUSH
74352: FOR_IN
74353: IFFALSE 74386
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74355: LD_VAR 0 8
74359: PPUSH
74360: CALL_OW 250
74364: PPUSH
74365: LD_VAR 0 8
74369: PPUSH
74370: CALL_OW 251
74374: PPUSH
74375: LD_VAR 0 16
74379: PPUSH
74380: CALL_OW 441
74384: GO 74352
74386: POP
74387: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74388: LD_VAR 0 18
74392: PPUSH
74393: LD_INT 2
74395: PUSH
74396: LD_INT 30
74398: PUSH
74399: LD_INT 32
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: LD_INT 30
74408: PUSH
74409: LD_INT 33
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PUSH
74416: EMPTY
74417: LIST
74418: LIST
74419: LIST
74420: PPUSH
74421: CALL_OW 72
74425: IFFALSE 74513
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74427: LD_ADDR_VAR 0 8
74431: PUSH
74432: LD_VAR 0 18
74436: PPUSH
74437: LD_INT 2
74439: PUSH
74440: LD_INT 30
74442: PUSH
74443: LD_INT 32
74445: PUSH
74446: EMPTY
74447: LIST
74448: LIST
74449: PUSH
74450: LD_INT 30
74452: PUSH
74453: LD_INT 33
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: EMPTY
74461: LIST
74462: LIST
74463: LIST
74464: PPUSH
74465: CALL_OW 72
74469: PUSH
74470: FOR_IN
74471: IFFALSE 74511
// begin if not GetBWeapon ( i ) then
74473: LD_VAR 0 8
74477: PPUSH
74478: CALL_OW 269
74482: NOT
74483: IFFALSE 74509
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74485: LD_VAR 0 8
74489: PPUSH
74490: LD_VAR 0 8
74494: PPUSH
74495: LD_VAR 0 2
74499: PPUSH
74500: CALL 75759 0 2
74504: PPUSH
74505: CALL_OW 431
// end ;
74509: GO 74470
74511: POP
74512: POP
// end ; for i = 1 to personel do
74513: LD_ADDR_VAR 0 8
74517: PUSH
74518: DOUBLE
74519: LD_INT 1
74521: DEC
74522: ST_TO_ADDR
74523: LD_VAR 0 6
74527: PUSH
74528: FOR_TO
74529: IFFALSE 75593
// begin if i > 4 then
74531: LD_VAR 0 8
74535: PUSH
74536: LD_INT 4
74538: GREATER
74539: IFFALSE 74543
// break ;
74541: GO 75593
// case i of 1 :
74543: LD_VAR 0 8
74547: PUSH
74548: LD_INT 1
74550: DOUBLE
74551: EQUAL
74552: IFTRUE 74556
74554: GO 74636
74556: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74557: LD_ADDR_VAR 0 12
74561: PUSH
74562: LD_VAR 0 18
74566: PPUSH
74567: LD_INT 22
74569: PUSH
74570: LD_VAR 0 16
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: PUSH
74579: LD_INT 58
74581: PUSH
74582: EMPTY
74583: LIST
74584: PUSH
74585: LD_INT 2
74587: PUSH
74588: LD_INT 30
74590: PUSH
74591: LD_INT 32
74593: PUSH
74594: EMPTY
74595: LIST
74596: LIST
74597: PUSH
74598: LD_INT 30
74600: PUSH
74601: LD_INT 4
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 30
74610: PUSH
74611: LD_INT 5
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: EMPTY
74619: LIST
74620: LIST
74621: LIST
74622: LIST
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: LIST
74628: PPUSH
74629: CALL_OW 72
74633: ST_TO_ADDR
74634: GO 74858
74636: LD_INT 2
74638: DOUBLE
74639: EQUAL
74640: IFTRUE 74644
74642: GO 74706
74644: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74645: LD_ADDR_VAR 0 12
74649: PUSH
74650: LD_VAR 0 18
74654: PPUSH
74655: LD_INT 22
74657: PUSH
74658: LD_VAR 0 16
74662: PUSH
74663: EMPTY
74664: LIST
74665: LIST
74666: PUSH
74667: LD_INT 2
74669: PUSH
74670: LD_INT 30
74672: PUSH
74673: LD_INT 0
74675: PUSH
74676: EMPTY
74677: LIST
74678: LIST
74679: PUSH
74680: LD_INT 30
74682: PUSH
74683: LD_INT 1
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: EMPTY
74691: LIST
74692: LIST
74693: LIST
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PPUSH
74699: CALL_OW 72
74703: ST_TO_ADDR
74704: GO 74858
74706: LD_INT 3
74708: DOUBLE
74709: EQUAL
74710: IFTRUE 74714
74712: GO 74776
74714: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74715: LD_ADDR_VAR 0 12
74719: PUSH
74720: LD_VAR 0 18
74724: PPUSH
74725: LD_INT 22
74727: PUSH
74728: LD_VAR 0 16
74732: PUSH
74733: EMPTY
74734: LIST
74735: LIST
74736: PUSH
74737: LD_INT 2
74739: PUSH
74740: LD_INT 30
74742: PUSH
74743: LD_INT 2
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: PUSH
74750: LD_INT 30
74752: PUSH
74753: LD_INT 3
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: PUSH
74760: EMPTY
74761: LIST
74762: LIST
74763: LIST
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PPUSH
74769: CALL_OW 72
74773: ST_TO_ADDR
74774: GO 74858
74776: LD_INT 4
74778: DOUBLE
74779: EQUAL
74780: IFTRUE 74784
74782: GO 74857
74784: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74785: LD_ADDR_VAR 0 12
74789: PUSH
74790: LD_VAR 0 18
74794: PPUSH
74795: LD_INT 22
74797: PUSH
74798: LD_VAR 0 16
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 2
74809: PUSH
74810: LD_INT 30
74812: PUSH
74813: LD_INT 6
74815: PUSH
74816: EMPTY
74817: LIST
74818: LIST
74819: PUSH
74820: LD_INT 30
74822: PUSH
74823: LD_INT 7
74825: PUSH
74826: EMPTY
74827: LIST
74828: LIST
74829: PUSH
74830: LD_INT 30
74832: PUSH
74833: LD_INT 8
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PUSH
74840: EMPTY
74841: LIST
74842: LIST
74843: LIST
74844: LIST
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PPUSH
74850: CALL_OW 72
74854: ST_TO_ADDR
74855: GO 74858
74857: POP
// if i = 1 then
74858: LD_VAR 0 8
74862: PUSH
74863: LD_INT 1
74865: EQUAL
74866: IFFALSE 74977
// begin tmp := [ ] ;
74868: LD_ADDR_VAR 0 19
74872: PUSH
74873: EMPTY
74874: ST_TO_ADDR
// for j in f do
74875: LD_ADDR_VAR 0 9
74879: PUSH
74880: LD_VAR 0 12
74884: PUSH
74885: FOR_IN
74886: IFFALSE 74959
// if GetBType ( j ) = b_bunker then
74888: LD_VAR 0 9
74892: PPUSH
74893: CALL_OW 266
74897: PUSH
74898: LD_INT 32
74900: EQUAL
74901: IFFALSE 74928
// tmp := Insert ( tmp , 1 , j ) else
74903: LD_ADDR_VAR 0 19
74907: PUSH
74908: LD_VAR 0 19
74912: PPUSH
74913: LD_INT 1
74915: PPUSH
74916: LD_VAR 0 9
74920: PPUSH
74921: CALL_OW 2
74925: ST_TO_ADDR
74926: GO 74957
// tmp := Insert ( tmp , tmp + 1 , j ) ;
74928: LD_ADDR_VAR 0 19
74932: PUSH
74933: LD_VAR 0 19
74937: PPUSH
74938: LD_VAR 0 19
74942: PUSH
74943: LD_INT 1
74945: PLUS
74946: PPUSH
74947: LD_VAR 0 9
74951: PPUSH
74952: CALL_OW 2
74956: ST_TO_ADDR
74957: GO 74885
74959: POP
74960: POP
// if tmp then
74961: LD_VAR 0 19
74965: IFFALSE 74977
// f := tmp ;
74967: LD_ADDR_VAR 0 12
74971: PUSH
74972: LD_VAR 0 19
74976: ST_TO_ADDR
// end ; x := personel [ i ] ;
74977: LD_ADDR_VAR 0 13
74981: PUSH
74982: LD_VAR 0 6
74986: PUSH
74987: LD_VAR 0 8
74991: ARRAY
74992: ST_TO_ADDR
// if x = - 1 then
74993: LD_VAR 0 13
74997: PUSH
74998: LD_INT 1
75000: NEG
75001: EQUAL
75002: IFFALSE 75211
// begin for j in f do
75004: LD_ADDR_VAR 0 9
75008: PUSH
75009: LD_VAR 0 12
75013: PUSH
75014: FOR_IN
75015: IFFALSE 75207
// repeat InitHc ;
75017: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75021: LD_VAR 0 9
75025: PPUSH
75026: CALL_OW 266
75030: PUSH
75031: LD_INT 5
75033: EQUAL
75034: IFFALSE 75104
// begin if UnitsInside ( j ) < 3 then
75036: LD_VAR 0 9
75040: PPUSH
75041: CALL_OW 313
75045: PUSH
75046: LD_INT 3
75048: LESS
75049: IFFALSE 75085
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75051: LD_INT 0
75053: PPUSH
75054: LD_INT 5
75056: PUSH
75057: LD_INT 8
75059: PUSH
75060: LD_INT 9
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: LIST
75067: PUSH
75068: LD_VAR 0 17
75072: ARRAY
75073: PPUSH
75074: LD_VAR 0 4
75078: PPUSH
75079: CALL_OW 380
75083: GO 75102
// PrepareHuman ( false , i , skill ) ;
75085: LD_INT 0
75087: PPUSH
75088: LD_VAR 0 8
75092: PPUSH
75093: LD_VAR 0 4
75097: PPUSH
75098: CALL_OW 380
// end else
75102: GO 75121
// PrepareHuman ( false , i , skill ) ;
75104: LD_INT 0
75106: PPUSH
75107: LD_VAR 0 8
75111: PPUSH
75112: LD_VAR 0 4
75116: PPUSH
75117: CALL_OW 380
// un := CreateHuman ;
75121: LD_ADDR_VAR 0 14
75125: PUSH
75126: CALL_OW 44
75130: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75131: LD_ADDR_VAR 0 7
75135: PUSH
75136: LD_VAR 0 7
75140: PPUSH
75141: LD_INT 1
75143: PPUSH
75144: LD_VAR 0 14
75148: PPUSH
75149: CALL_OW 2
75153: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75154: LD_VAR 0 14
75158: PPUSH
75159: LD_VAR 0 9
75163: PPUSH
75164: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75168: LD_VAR 0 9
75172: PPUSH
75173: CALL_OW 313
75177: PUSH
75178: LD_INT 6
75180: EQUAL
75181: PUSH
75182: LD_VAR 0 9
75186: PPUSH
75187: CALL_OW 266
75191: PUSH
75192: LD_INT 32
75194: PUSH
75195: LD_INT 31
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: IN
75202: OR
75203: IFFALSE 75017
75205: GO 75014
75207: POP
75208: POP
// end else
75209: GO 75591
// for j = 1 to x do
75211: LD_ADDR_VAR 0 9
75215: PUSH
75216: DOUBLE
75217: LD_INT 1
75219: DEC
75220: ST_TO_ADDR
75221: LD_VAR 0 13
75225: PUSH
75226: FOR_TO
75227: IFFALSE 75589
// begin InitHc ;
75229: CALL_OW 19
// if not f then
75233: LD_VAR 0 12
75237: NOT
75238: IFFALSE 75327
// begin PrepareHuman ( false , i , skill ) ;
75240: LD_INT 0
75242: PPUSH
75243: LD_VAR 0 8
75247: PPUSH
75248: LD_VAR 0 4
75252: PPUSH
75253: CALL_OW 380
// un := CreateHuman ;
75257: LD_ADDR_VAR 0 14
75261: PUSH
75262: CALL_OW 44
75266: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75267: LD_ADDR_VAR 0 7
75271: PUSH
75272: LD_VAR 0 7
75276: PPUSH
75277: LD_INT 1
75279: PPUSH
75280: LD_VAR 0 14
75284: PPUSH
75285: CALL_OW 2
75289: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75290: LD_VAR 0 14
75294: PPUSH
75295: LD_VAR 0 1
75299: PPUSH
75300: CALL_OW 250
75304: PPUSH
75305: LD_VAR 0 1
75309: PPUSH
75310: CALL_OW 251
75314: PPUSH
75315: LD_INT 10
75317: PPUSH
75318: LD_INT 0
75320: PPUSH
75321: CALL_OW 50
// continue ;
75325: GO 75226
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75327: LD_VAR 0 12
75331: PUSH
75332: LD_INT 1
75334: ARRAY
75335: PPUSH
75336: CALL_OW 313
75340: PUSH
75341: LD_VAR 0 12
75345: PUSH
75346: LD_INT 1
75348: ARRAY
75349: PPUSH
75350: CALL_OW 266
75354: PUSH
75355: LD_INT 32
75357: PUSH
75358: LD_INT 31
75360: PUSH
75361: EMPTY
75362: LIST
75363: LIST
75364: IN
75365: AND
75366: PUSH
75367: LD_VAR 0 12
75371: PUSH
75372: LD_INT 1
75374: ARRAY
75375: PPUSH
75376: CALL_OW 313
75380: PUSH
75381: LD_INT 6
75383: EQUAL
75384: OR
75385: IFFALSE 75405
// f := Delete ( f , 1 ) ;
75387: LD_ADDR_VAR 0 12
75391: PUSH
75392: LD_VAR 0 12
75396: PPUSH
75397: LD_INT 1
75399: PPUSH
75400: CALL_OW 3
75404: ST_TO_ADDR
// if not f then
75405: LD_VAR 0 12
75409: NOT
75410: IFFALSE 75428
// begin x := x + 2 ;
75412: LD_ADDR_VAR 0 13
75416: PUSH
75417: LD_VAR 0 13
75421: PUSH
75422: LD_INT 2
75424: PLUS
75425: ST_TO_ADDR
// continue ;
75426: GO 75226
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75428: LD_VAR 0 12
75432: PUSH
75433: LD_INT 1
75435: ARRAY
75436: PPUSH
75437: CALL_OW 266
75441: PUSH
75442: LD_INT 5
75444: EQUAL
75445: IFFALSE 75519
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75447: LD_VAR 0 12
75451: PUSH
75452: LD_INT 1
75454: ARRAY
75455: PPUSH
75456: CALL_OW 313
75460: PUSH
75461: LD_INT 3
75463: LESS
75464: IFFALSE 75500
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75466: LD_INT 0
75468: PPUSH
75469: LD_INT 5
75471: PUSH
75472: LD_INT 8
75474: PUSH
75475: LD_INT 9
75477: PUSH
75478: EMPTY
75479: LIST
75480: LIST
75481: LIST
75482: PUSH
75483: LD_VAR 0 17
75487: ARRAY
75488: PPUSH
75489: LD_VAR 0 4
75493: PPUSH
75494: CALL_OW 380
75498: GO 75517
// PrepareHuman ( false , i , skill ) ;
75500: LD_INT 0
75502: PPUSH
75503: LD_VAR 0 8
75507: PPUSH
75508: LD_VAR 0 4
75512: PPUSH
75513: CALL_OW 380
// end else
75517: GO 75536
// PrepareHuman ( false , i , skill ) ;
75519: LD_INT 0
75521: PPUSH
75522: LD_VAR 0 8
75526: PPUSH
75527: LD_VAR 0 4
75531: PPUSH
75532: CALL_OW 380
// un := CreateHuman ;
75536: LD_ADDR_VAR 0 14
75540: PUSH
75541: CALL_OW 44
75545: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75546: LD_ADDR_VAR 0 7
75550: PUSH
75551: LD_VAR 0 7
75555: PPUSH
75556: LD_INT 1
75558: PPUSH
75559: LD_VAR 0 14
75563: PPUSH
75564: CALL_OW 2
75568: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75569: LD_VAR 0 14
75573: PPUSH
75574: LD_VAR 0 12
75578: PUSH
75579: LD_INT 1
75581: ARRAY
75582: PPUSH
75583: CALL_OW 52
// end ;
75587: GO 75226
75589: POP
75590: POP
// end ;
75591: GO 74528
75593: POP
75594: POP
// result := result ^ buildings ;
75595: LD_ADDR_VAR 0 7
75599: PUSH
75600: LD_VAR 0 7
75604: PUSH
75605: LD_VAR 0 18
75609: ADD
75610: ST_TO_ADDR
// end else
75611: GO 75754
// begin for i = 1 to personel do
75613: LD_ADDR_VAR 0 8
75617: PUSH
75618: DOUBLE
75619: LD_INT 1
75621: DEC
75622: ST_TO_ADDR
75623: LD_VAR 0 6
75627: PUSH
75628: FOR_TO
75629: IFFALSE 75752
// begin if i > 4 then
75631: LD_VAR 0 8
75635: PUSH
75636: LD_INT 4
75638: GREATER
75639: IFFALSE 75643
// break ;
75641: GO 75752
// x := personel [ i ] ;
75643: LD_ADDR_VAR 0 13
75647: PUSH
75648: LD_VAR 0 6
75652: PUSH
75653: LD_VAR 0 8
75657: ARRAY
75658: ST_TO_ADDR
// if x = - 1 then
75659: LD_VAR 0 13
75663: PUSH
75664: LD_INT 1
75666: NEG
75667: EQUAL
75668: IFFALSE 75672
// continue ;
75670: GO 75628
// PrepareHuman ( false , i , skill ) ;
75672: LD_INT 0
75674: PPUSH
75675: LD_VAR 0 8
75679: PPUSH
75680: LD_VAR 0 4
75684: PPUSH
75685: CALL_OW 380
// un := CreateHuman ;
75689: LD_ADDR_VAR 0 14
75693: PUSH
75694: CALL_OW 44
75698: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75699: LD_VAR 0 14
75703: PPUSH
75704: LD_VAR 0 1
75708: PPUSH
75709: CALL_OW 250
75713: PPUSH
75714: LD_VAR 0 1
75718: PPUSH
75719: CALL_OW 251
75723: PPUSH
75724: LD_INT 10
75726: PPUSH
75727: LD_INT 0
75729: PPUSH
75730: CALL_OW 50
// result := result ^ un ;
75734: LD_ADDR_VAR 0 7
75738: PUSH
75739: LD_VAR 0 7
75743: PUSH
75744: LD_VAR 0 14
75748: ADD
75749: ST_TO_ADDR
// end ;
75750: GO 75628
75752: POP
75753: POP
// end ; end ;
75754: LD_VAR 0 7
75758: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75759: LD_INT 0
75761: PPUSH
75762: PPUSH
75763: PPUSH
75764: PPUSH
75765: PPUSH
75766: PPUSH
75767: PPUSH
75768: PPUSH
75769: PPUSH
75770: PPUSH
75771: PPUSH
75772: PPUSH
75773: PPUSH
75774: PPUSH
75775: PPUSH
75776: PPUSH
// result := false ;
75777: LD_ADDR_VAR 0 3
75781: PUSH
75782: LD_INT 0
75784: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75785: LD_VAR 0 1
75789: NOT
75790: PUSH
75791: LD_VAR 0 1
75795: PPUSH
75796: CALL_OW 266
75800: PUSH
75801: LD_INT 32
75803: PUSH
75804: LD_INT 33
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: IN
75811: NOT
75812: OR
75813: IFFALSE 75817
// exit ;
75815: GO 76953
// nat := GetNation ( tower ) ;
75817: LD_ADDR_VAR 0 12
75821: PUSH
75822: LD_VAR 0 1
75826: PPUSH
75827: CALL_OW 248
75831: ST_TO_ADDR
// side := GetSide ( tower ) ;
75832: LD_ADDR_VAR 0 16
75836: PUSH
75837: LD_VAR 0 1
75841: PPUSH
75842: CALL_OW 255
75846: ST_TO_ADDR
// x := GetX ( tower ) ;
75847: LD_ADDR_VAR 0 10
75851: PUSH
75852: LD_VAR 0 1
75856: PPUSH
75857: CALL_OW 250
75861: ST_TO_ADDR
// y := GetY ( tower ) ;
75862: LD_ADDR_VAR 0 11
75866: PUSH
75867: LD_VAR 0 1
75871: PPUSH
75872: CALL_OW 251
75876: ST_TO_ADDR
// if not x or not y then
75877: LD_VAR 0 10
75881: NOT
75882: PUSH
75883: LD_VAR 0 11
75887: NOT
75888: OR
75889: IFFALSE 75893
// exit ;
75891: GO 76953
// weapon := 0 ;
75893: LD_ADDR_VAR 0 18
75897: PUSH
75898: LD_INT 0
75900: ST_TO_ADDR
// fac_list := [ ] ;
75901: LD_ADDR_VAR 0 17
75905: PUSH
75906: EMPTY
75907: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
75908: LD_ADDR_VAR 0 6
75912: PUSH
75913: LD_VAR 0 1
75917: PPUSH
75918: CALL_OW 274
75922: PPUSH
75923: LD_VAR 0 2
75927: PPUSH
75928: CALL 73531 0 2
75932: PPUSH
75933: LD_INT 30
75935: PUSH
75936: LD_INT 3
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: PPUSH
75943: CALL_OW 72
75947: ST_TO_ADDR
// if not factories then
75948: LD_VAR 0 6
75952: NOT
75953: IFFALSE 75957
// exit ;
75955: GO 76953
// for i in factories do
75957: LD_ADDR_VAR 0 8
75961: PUSH
75962: LD_VAR 0 6
75966: PUSH
75967: FOR_IN
75968: IFFALSE 75993
// fac_list := fac_list union AvailableWeaponList ( i ) ;
75970: LD_ADDR_VAR 0 17
75974: PUSH
75975: LD_VAR 0 17
75979: PUSH
75980: LD_VAR 0 8
75984: PPUSH
75985: CALL_OW 478
75989: UNION
75990: ST_TO_ADDR
75991: GO 75967
75993: POP
75994: POP
// if not fac_list then
75995: LD_VAR 0 17
75999: NOT
76000: IFFALSE 76004
// exit ;
76002: GO 76953
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76004: LD_ADDR_VAR 0 5
76008: PUSH
76009: LD_INT 4
76011: PUSH
76012: LD_INT 5
76014: PUSH
76015: LD_INT 9
76017: PUSH
76018: LD_INT 10
76020: PUSH
76021: LD_INT 6
76023: PUSH
76024: LD_INT 7
76026: PUSH
76027: LD_INT 11
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: LIST
76034: LIST
76035: LIST
76036: LIST
76037: LIST
76038: PUSH
76039: LD_INT 27
76041: PUSH
76042: LD_INT 28
76044: PUSH
76045: LD_INT 26
76047: PUSH
76048: LD_INT 30
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: LIST
76055: LIST
76056: PUSH
76057: LD_INT 43
76059: PUSH
76060: LD_INT 44
76062: PUSH
76063: LD_INT 46
76065: PUSH
76066: LD_INT 45
76068: PUSH
76069: LD_INT 47
76071: PUSH
76072: LD_INT 49
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: LIST
76079: LIST
76080: LIST
76081: LIST
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: LIST
76087: PUSH
76088: LD_VAR 0 12
76092: ARRAY
76093: ST_TO_ADDR
// for i in list do
76094: LD_ADDR_VAR 0 8
76098: PUSH
76099: LD_VAR 0 5
76103: PUSH
76104: FOR_IN
76105: IFFALSE 76138
// if not i in fac_list then
76107: LD_VAR 0 8
76111: PUSH
76112: LD_VAR 0 17
76116: IN
76117: NOT
76118: IFFALSE 76136
// list := list diff i ;
76120: LD_ADDR_VAR 0 5
76124: PUSH
76125: LD_VAR 0 5
76129: PUSH
76130: LD_VAR 0 8
76134: DIFF
76135: ST_TO_ADDR
76136: GO 76104
76138: POP
76139: POP
// if not list then
76140: LD_VAR 0 5
76144: NOT
76145: IFFALSE 76149
// exit ;
76147: GO 76953
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76149: LD_VAR 0 12
76153: PUSH
76154: LD_INT 3
76156: EQUAL
76157: PUSH
76158: LD_INT 49
76160: PUSH
76161: LD_VAR 0 5
76165: IN
76166: AND
76167: PUSH
76168: LD_INT 31
76170: PPUSH
76171: LD_VAR 0 16
76175: PPUSH
76176: CALL_OW 321
76180: PUSH
76181: LD_INT 2
76183: EQUAL
76184: AND
76185: IFFALSE 76245
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76187: LD_INT 22
76189: PUSH
76190: LD_VAR 0 16
76194: PUSH
76195: EMPTY
76196: LIST
76197: LIST
76198: PUSH
76199: LD_INT 35
76201: PUSH
76202: LD_INT 49
76204: PUSH
76205: EMPTY
76206: LIST
76207: LIST
76208: PUSH
76209: LD_INT 91
76211: PUSH
76212: LD_VAR 0 1
76216: PUSH
76217: LD_INT 10
76219: PUSH
76220: EMPTY
76221: LIST
76222: LIST
76223: LIST
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: LIST
76229: PPUSH
76230: CALL_OW 69
76234: NOT
76235: IFFALSE 76245
// weapon := ru_time_lapser ;
76237: LD_ADDR_VAR 0 18
76241: PUSH
76242: LD_INT 49
76244: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76245: LD_VAR 0 12
76249: PUSH
76250: LD_INT 1
76252: PUSH
76253: LD_INT 2
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: IN
76260: PUSH
76261: LD_INT 11
76263: PUSH
76264: LD_VAR 0 5
76268: IN
76269: PUSH
76270: LD_INT 30
76272: PUSH
76273: LD_VAR 0 5
76277: IN
76278: OR
76279: AND
76280: PUSH
76281: LD_INT 6
76283: PPUSH
76284: LD_VAR 0 16
76288: PPUSH
76289: CALL_OW 321
76293: PUSH
76294: LD_INT 2
76296: EQUAL
76297: AND
76298: IFFALSE 76463
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76300: LD_INT 22
76302: PUSH
76303: LD_VAR 0 16
76307: PUSH
76308: EMPTY
76309: LIST
76310: LIST
76311: PUSH
76312: LD_INT 2
76314: PUSH
76315: LD_INT 35
76317: PUSH
76318: LD_INT 11
76320: PUSH
76321: EMPTY
76322: LIST
76323: LIST
76324: PUSH
76325: LD_INT 35
76327: PUSH
76328: LD_INT 30
76330: PUSH
76331: EMPTY
76332: LIST
76333: LIST
76334: PUSH
76335: EMPTY
76336: LIST
76337: LIST
76338: LIST
76339: PUSH
76340: LD_INT 91
76342: PUSH
76343: LD_VAR 0 1
76347: PUSH
76348: LD_INT 18
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: LIST
76355: PUSH
76356: EMPTY
76357: LIST
76358: LIST
76359: LIST
76360: PPUSH
76361: CALL_OW 69
76365: NOT
76366: PUSH
76367: LD_INT 22
76369: PUSH
76370: LD_VAR 0 16
76374: PUSH
76375: EMPTY
76376: LIST
76377: LIST
76378: PUSH
76379: LD_INT 2
76381: PUSH
76382: LD_INT 30
76384: PUSH
76385: LD_INT 32
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 30
76394: PUSH
76395: LD_INT 33
76397: PUSH
76398: EMPTY
76399: LIST
76400: LIST
76401: PUSH
76402: EMPTY
76403: LIST
76404: LIST
76405: LIST
76406: PUSH
76407: LD_INT 91
76409: PUSH
76410: LD_VAR 0 1
76414: PUSH
76415: LD_INT 12
76417: PUSH
76418: EMPTY
76419: LIST
76420: LIST
76421: LIST
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: LIST
76427: PUSH
76428: EMPTY
76429: LIST
76430: PPUSH
76431: CALL_OW 69
76435: PUSH
76436: LD_INT 2
76438: GREATER
76439: AND
76440: IFFALSE 76463
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76442: LD_ADDR_VAR 0 18
76446: PUSH
76447: LD_INT 11
76449: PUSH
76450: LD_INT 30
76452: PUSH
76453: EMPTY
76454: LIST
76455: LIST
76456: PUSH
76457: LD_VAR 0 12
76461: ARRAY
76462: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76463: LD_VAR 0 18
76467: NOT
76468: PUSH
76469: LD_INT 40
76471: PPUSH
76472: LD_VAR 0 16
76476: PPUSH
76477: CALL_OW 321
76481: PUSH
76482: LD_INT 2
76484: EQUAL
76485: AND
76486: PUSH
76487: LD_INT 7
76489: PUSH
76490: LD_VAR 0 5
76494: IN
76495: PUSH
76496: LD_INT 28
76498: PUSH
76499: LD_VAR 0 5
76503: IN
76504: OR
76505: PUSH
76506: LD_INT 45
76508: PUSH
76509: LD_VAR 0 5
76513: IN
76514: OR
76515: AND
76516: IFFALSE 76770
// begin hex := GetHexInfo ( x , y ) ;
76518: LD_ADDR_VAR 0 4
76522: PUSH
76523: LD_VAR 0 10
76527: PPUSH
76528: LD_VAR 0 11
76532: PPUSH
76533: CALL_OW 546
76537: ST_TO_ADDR
// if hex [ 1 ] then
76538: LD_VAR 0 4
76542: PUSH
76543: LD_INT 1
76545: ARRAY
76546: IFFALSE 76550
// exit ;
76548: GO 76953
// height := hex [ 2 ] ;
76550: LD_ADDR_VAR 0 15
76554: PUSH
76555: LD_VAR 0 4
76559: PUSH
76560: LD_INT 2
76562: ARRAY
76563: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76564: LD_ADDR_VAR 0 14
76568: PUSH
76569: LD_INT 0
76571: PUSH
76572: LD_INT 2
76574: PUSH
76575: LD_INT 3
76577: PUSH
76578: LD_INT 5
76580: PUSH
76581: EMPTY
76582: LIST
76583: LIST
76584: LIST
76585: LIST
76586: ST_TO_ADDR
// for i in tmp do
76587: LD_ADDR_VAR 0 8
76591: PUSH
76592: LD_VAR 0 14
76596: PUSH
76597: FOR_IN
76598: IFFALSE 76768
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76600: LD_ADDR_VAR 0 9
76604: PUSH
76605: LD_VAR 0 10
76609: PPUSH
76610: LD_VAR 0 8
76614: PPUSH
76615: LD_INT 5
76617: PPUSH
76618: CALL_OW 272
76622: PUSH
76623: LD_VAR 0 11
76627: PPUSH
76628: LD_VAR 0 8
76632: PPUSH
76633: LD_INT 5
76635: PPUSH
76636: CALL_OW 273
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76645: LD_VAR 0 9
76649: PUSH
76650: LD_INT 1
76652: ARRAY
76653: PPUSH
76654: LD_VAR 0 9
76658: PUSH
76659: LD_INT 2
76661: ARRAY
76662: PPUSH
76663: CALL_OW 488
76667: IFFALSE 76766
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76669: LD_ADDR_VAR 0 4
76673: PUSH
76674: LD_VAR 0 9
76678: PUSH
76679: LD_INT 1
76681: ARRAY
76682: PPUSH
76683: LD_VAR 0 9
76687: PUSH
76688: LD_INT 2
76690: ARRAY
76691: PPUSH
76692: CALL_OW 546
76696: ST_TO_ADDR
// if hex [ 1 ] then
76697: LD_VAR 0 4
76701: PUSH
76702: LD_INT 1
76704: ARRAY
76705: IFFALSE 76709
// continue ;
76707: GO 76597
// h := hex [ 2 ] ;
76709: LD_ADDR_VAR 0 13
76713: PUSH
76714: LD_VAR 0 4
76718: PUSH
76719: LD_INT 2
76721: ARRAY
76722: ST_TO_ADDR
// if h + 7 < height then
76723: LD_VAR 0 13
76727: PUSH
76728: LD_INT 7
76730: PLUS
76731: PUSH
76732: LD_VAR 0 15
76736: LESS
76737: IFFALSE 76766
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76739: LD_ADDR_VAR 0 18
76743: PUSH
76744: LD_INT 7
76746: PUSH
76747: LD_INT 28
76749: PUSH
76750: LD_INT 45
76752: PUSH
76753: EMPTY
76754: LIST
76755: LIST
76756: LIST
76757: PUSH
76758: LD_VAR 0 12
76762: ARRAY
76763: ST_TO_ADDR
// break ;
76764: GO 76768
// end ; end ; end ;
76766: GO 76597
76768: POP
76769: POP
// end ; if not weapon then
76770: LD_VAR 0 18
76774: NOT
76775: IFFALSE 76835
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76777: LD_ADDR_VAR 0 5
76781: PUSH
76782: LD_VAR 0 5
76786: PUSH
76787: LD_INT 11
76789: PUSH
76790: LD_INT 30
76792: PUSH
76793: LD_INT 49
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: LIST
76800: DIFF
76801: ST_TO_ADDR
// if not list then
76802: LD_VAR 0 5
76806: NOT
76807: IFFALSE 76811
// exit ;
76809: GO 76953
// weapon := list [ rand ( 1 , list ) ] ;
76811: LD_ADDR_VAR 0 18
76815: PUSH
76816: LD_VAR 0 5
76820: PUSH
76821: LD_INT 1
76823: PPUSH
76824: LD_VAR 0 5
76828: PPUSH
76829: CALL_OW 12
76833: ARRAY
76834: ST_TO_ADDR
// end ; if weapon then
76835: LD_VAR 0 18
76839: IFFALSE 76953
// begin tmp := CostOfWeapon ( weapon ) ;
76841: LD_ADDR_VAR 0 14
76845: PUSH
76846: LD_VAR 0 18
76850: PPUSH
76851: CALL_OW 451
76855: ST_TO_ADDR
// j := GetBase ( tower ) ;
76856: LD_ADDR_VAR 0 9
76860: PUSH
76861: LD_VAR 0 1
76865: PPUSH
76866: CALL_OW 274
76870: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76871: LD_VAR 0 9
76875: PPUSH
76876: LD_INT 1
76878: PPUSH
76879: CALL_OW 275
76883: PUSH
76884: LD_VAR 0 14
76888: PUSH
76889: LD_INT 1
76891: ARRAY
76892: GREATEREQUAL
76893: PUSH
76894: LD_VAR 0 9
76898: PPUSH
76899: LD_INT 2
76901: PPUSH
76902: CALL_OW 275
76906: PUSH
76907: LD_VAR 0 14
76911: PUSH
76912: LD_INT 2
76914: ARRAY
76915: GREATEREQUAL
76916: AND
76917: PUSH
76918: LD_VAR 0 9
76922: PPUSH
76923: LD_INT 3
76925: PPUSH
76926: CALL_OW 275
76930: PUSH
76931: LD_VAR 0 14
76935: PUSH
76936: LD_INT 3
76938: ARRAY
76939: GREATEREQUAL
76940: AND
76941: IFFALSE 76953
// result := weapon ;
76943: LD_ADDR_VAR 0 3
76947: PUSH
76948: LD_VAR 0 18
76952: ST_TO_ADDR
// end ; end ;
76953: LD_VAR 0 3
76957: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
76958: LD_INT 0
76960: PPUSH
76961: PPUSH
// result := true ;
76962: LD_ADDR_VAR 0 3
76966: PUSH
76967: LD_INT 1
76969: ST_TO_ADDR
// if array1 = array2 then
76970: LD_VAR 0 1
76974: PUSH
76975: LD_VAR 0 2
76979: EQUAL
76980: IFFALSE 77040
// begin for i = 1 to array1 do
76982: LD_ADDR_VAR 0 4
76986: PUSH
76987: DOUBLE
76988: LD_INT 1
76990: DEC
76991: ST_TO_ADDR
76992: LD_VAR 0 1
76996: PUSH
76997: FOR_TO
76998: IFFALSE 77036
// if array1 [ i ] <> array2 [ i ] then
77000: LD_VAR 0 1
77004: PUSH
77005: LD_VAR 0 4
77009: ARRAY
77010: PUSH
77011: LD_VAR 0 2
77015: PUSH
77016: LD_VAR 0 4
77020: ARRAY
77021: NONEQUAL
77022: IFFALSE 77034
// begin result := false ;
77024: LD_ADDR_VAR 0 3
77028: PUSH
77029: LD_INT 0
77031: ST_TO_ADDR
// break ;
77032: GO 77036
// end ;
77034: GO 76997
77036: POP
77037: POP
// end else
77038: GO 77048
// result := false ;
77040: LD_ADDR_VAR 0 3
77044: PUSH
77045: LD_INT 0
77047: ST_TO_ADDR
// end ;
77048: LD_VAR 0 3
77052: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77053: LD_INT 0
77055: PPUSH
77056: PPUSH
77057: PPUSH
// pom := GetBase ( fac ) ;
77058: LD_ADDR_VAR 0 5
77062: PUSH
77063: LD_VAR 0 1
77067: PPUSH
77068: CALL_OW 274
77072: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77073: LD_ADDR_VAR 0 4
77077: PUSH
77078: LD_VAR 0 2
77082: PUSH
77083: LD_INT 1
77085: ARRAY
77086: PPUSH
77087: LD_VAR 0 2
77091: PUSH
77092: LD_INT 2
77094: ARRAY
77095: PPUSH
77096: LD_VAR 0 2
77100: PUSH
77101: LD_INT 3
77103: ARRAY
77104: PPUSH
77105: LD_VAR 0 2
77109: PUSH
77110: LD_INT 4
77112: ARRAY
77113: PPUSH
77114: CALL_OW 449
77118: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77119: LD_ADDR_VAR 0 3
77123: PUSH
77124: LD_VAR 0 5
77128: PPUSH
77129: LD_INT 1
77131: PPUSH
77132: CALL_OW 275
77136: PUSH
77137: LD_VAR 0 4
77141: PUSH
77142: LD_INT 1
77144: ARRAY
77145: GREATEREQUAL
77146: PUSH
77147: LD_VAR 0 5
77151: PPUSH
77152: LD_INT 2
77154: PPUSH
77155: CALL_OW 275
77159: PUSH
77160: LD_VAR 0 4
77164: PUSH
77165: LD_INT 2
77167: ARRAY
77168: GREATEREQUAL
77169: AND
77170: PUSH
77171: LD_VAR 0 5
77175: PPUSH
77176: LD_INT 3
77178: PPUSH
77179: CALL_OW 275
77183: PUSH
77184: LD_VAR 0 4
77188: PUSH
77189: LD_INT 3
77191: ARRAY
77192: GREATEREQUAL
77193: AND
77194: ST_TO_ADDR
// end ;
77195: LD_VAR 0 3
77199: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77200: LD_INT 0
77202: PPUSH
77203: PPUSH
77204: PPUSH
77205: PPUSH
// pom := GetBase ( building ) ;
77206: LD_ADDR_VAR 0 3
77210: PUSH
77211: LD_VAR 0 1
77215: PPUSH
77216: CALL_OW 274
77220: ST_TO_ADDR
// if not pom then
77221: LD_VAR 0 3
77225: NOT
77226: IFFALSE 77230
// exit ;
77228: GO 77400
// btype := GetBType ( building ) ;
77230: LD_ADDR_VAR 0 5
77234: PUSH
77235: LD_VAR 0 1
77239: PPUSH
77240: CALL_OW 266
77244: ST_TO_ADDR
// if btype = b_armoury then
77245: LD_VAR 0 5
77249: PUSH
77250: LD_INT 4
77252: EQUAL
77253: IFFALSE 77263
// btype := b_barracks ;
77255: LD_ADDR_VAR 0 5
77259: PUSH
77260: LD_INT 5
77262: ST_TO_ADDR
// if btype = b_depot then
77263: LD_VAR 0 5
77267: PUSH
77268: LD_INT 0
77270: EQUAL
77271: IFFALSE 77281
// btype := b_warehouse ;
77273: LD_ADDR_VAR 0 5
77277: PUSH
77278: LD_INT 1
77280: ST_TO_ADDR
// if btype = b_workshop then
77281: LD_VAR 0 5
77285: PUSH
77286: LD_INT 2
77288: EQUAL
77289: IFFALSE 77299
// btype := b_factory ;
77291: LD_ADDR_VAR 0 5
77295: PUSH
77296: LD_INT 3
77298: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77299: LD_ADDR_VAR 0 4
77303: PUSH
77304: LD_VAR 0 5
77308: PPUSH
77309: LD_VAR 0 1
77313: PPUSH
77314: CALL_OW 248
77318: PPUSH
77319: CALL_OW 450
77323: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77324: LD_ADDR_VAR 0 2
77328: PUSH
77329: LD_VAR 0 3
77333: PPUSH
77334: LD_INT 1
77336: PPUSH
77337: CALL_OW 275
77341: PUSH
77342: LD_VAR 0 4
77346: PUSH
77347: LD_INT 1
77349: ARRAY
77350: GREATEREQUAL
77351: PUSH
77352: LD_VAR 0 3
77356: PPUSH
77357: LD_INT 2
77359: PPUSH
77360: CALL_OW 275
77364: PUSH
77365: LD_VAR 0 4
77369: PUSH
77370: LD_INT 2
77372: ARRAY
77373: GREATEREQUAL
77374: AND
77375: PUSH
77376: LD_VAR 0 3
77380: PPUSH
77381: LD_INT 3
77383: PPUSH
77384: CALL_OW 275
77388: PUSH
77389: LD_VAR 0 4
77393: PUSH
77394: LD_INT 3
77396: ARRAY
77397: GREATEREQUAL
77398: AND
77399: ST_TO_ADDR
// end ;
77400: LD_VAR 0 2
77404: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77405: LD_INT 0
77407: PPUSH
77408: PPUSH
77409: PPUSH
// pom := GetBase ( building ) ;
77410: LD_ADDR_VAR 0 4
77414: PUSH
77415: LD_VAR 0 1
77419: PPUSH
77420: CALL_OW 274
77424: ST_TO_ADDR
// if not pom then
77425: LD_VAR 0 4
77429: NOT
77430: IFFALSE 77434
// exit ;
77432: GO 77535
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77434: LD_ADDR_VAR 0 5
77438: PUSH
77439: LD_VAR 0 2
77443: PPUSH
77444: LD_VAR 0 1
77448: PPUSH
77449: CALL_OW 248
77453: PPUSH
77454: CALL_OW 450
77458: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77459: LD_ADDR_VAR 0 3
77463: PUSH
77464: LD_VAR 0 4
77468: PPUSH
77469: LD_INT 1
77471: PPUSH
77472: CALL_OW 275
77476: PUSH
77477: LD_VAR 0 5
77481: PUSH
77482: LD_INT 1
77484: ARRAY
77485: GREATEREQUAL
77486: PUSH
77487: LD_VAR 0 4
77491: PPUSH
77492: LD_INT 2
77494: PPUSH
77495: CALL_OW 275
77499: PUSH
77500: LD_VAR 0 5
77504: PUSH
77505: LD_INT 2
77507: ARRAY
77508: GREATEREQUAL
77509: AND
77510: PUSH
77511: LD_VAR 0 4
77515: PPUSH
77516: LD_INT 3
77518: PPUSH
77519: CALL_OW 275
77523: PUSH
77524: LD_VAR 0 5
77528: PUSH
77529: LD_INT 3
77531: ARRAY
77532: GREATEREQUAL
77533: AND
77534: ST_TO_ADDR
// end ;
77535: LD_VAR 0 3
77539: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
77540: LD_INT 0
77542: PPUSH
77543: PPUSH
77544: PPUSH
77545: PPUSH
77546: PPUSH
77547: PPUSH
77548: PPUSH
77549: PPUSH
77550: PPUSH
77551: PPUSH
// result := false ;
77552: LD_ADDR_VAR 0 6
77556: PUSH
77557: LD_INT 0
77559: ST_TO_ADDR
// if not base or not btype or not x or not y then
77560: LD_VAR 0 1
77564: NOT
77565: PUSH
77566: LD_VAR 0 2
77570: NOT
77571: OR
77572: PUSH
77573: LD_VAR 0 3
77577: NOT
77578: OR
77579: PUSH
77580: LD_VAR 0 4
77584: NOT
77585: OR
77586: IFFALSE 77590
// exit ;
77588: GO 78199
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
77590: LD_ADDR_VAR 0 12
77594: PUSH
77595: LD_VAR 0 2
77599: PPUSH
77600: LD_VAR 0 3
77604: PPUSH
77605: LD_VAR 0 4
77609: PPUSH
77610: LD_VAR 0 5
77614: PPUSH
77615: LD_VAR 0 1
77619: PUSH
77620: LD_INT 1
77622: ARRAY
77623: PPUSH
77624: CALL_OW 248
77628: PPUSH
77629: LD_INT 0
77631: PPUSH
77632: CALL 79036 0 6
77636: ST_TO_ADDR
// if not hexes then
77637: LD_VAR 0 12
77641: NOT
77642: IFFALSE 77646
// exit ;
77644: GO 78199
// for i = 1 to hexes do
77646: LD_ADDR_VAR 0 7
77650: PUSH
77651: DOUBLE
77652: LD_INT 1
77654: DEC
77655: ST_TO_ADDR
77656: LD_VAR 0 12
77660: PUSH
77661: FOR_TO
77662: IFFALSE 78197
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77664: LD_ADDR_VAR 0 11
77668: PUSH
77669: LD_VAR 0 12
77673: PUSH
77674: LD_VAR 0 7
77678: ARRAY
77679: PUSH
77680: LD_INT 1
77682: ARRAY
77683: PPUSH
77684: LD_VAR 0 12
77688: PUSH
77689: LD_VAR 0 7
77693: ARRAY
77694: PUSH
77695: LD_INT 2
77697: ARRAY
77698: PPUSH
77699: CALL_OW 428
77703: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77704: LD_VAR 0 12
77708: PUSH
77709: LD_VAR 0 7
77713: ARRAY
77714: PUSH
77715: LD_INT 1
77717: ARRAY
77718: PPUSH
77719: LD_VAR 0 12
77723: PUSH
77724: LD_VAR 0 7
77728: ARRAY
77729: PUSH
77730: LD_INT 2
77732: ARRAY
77733: PPUSH
77734: CALL_OW 351
77738: PUSH
77739: LD_VAR 0 12
77743: PUSH
77744: LD_VAR 0 7
77748: ARRAY
77749: PUSH
77750: LD_INT 1
77752: ARRAY
77753: PPUSH
77754: LD_VAR 0 12
77758: PUSH
77759: LD_VAR 0 7
77763: ARRAY
77764: PUSH
77765: LD_INT 2
77767: ARRAY
77768: PPUSH
77769: CALL_OW 488
77773: NOT
77774: OR
77775: PUSH
77776: LD_VAR 0 11
77780: PPUSH
77781: CALL_OW 247
77785: PUSH
77786: LD_INT 3
77788: EQUAL
77789: OR
77790: IFFALSE 77796
// exit ;
77792: POP
77793: POP
77794: GO 78199
// if not tmp or not tmp in base then
77796: LD_VAR 0 11
77800: NOT
77801: PUSH
77802: LD_VAR 0 11
77806: PUSH
77807: LD_VAR 0 1
77811: IN
77812: NOT
77813: OR
77814: IFFALSE 77818
// continue ;
77816: GO 77661
// result := true ;
77818: LD_ADDR_VAR 0 6
77822: PUSH
77823: LD_INT 1
77825: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77826: LD_ADDR_VAR 0 15
77830: PUSH
77831: LD_VAR 0 1
77835: PPUSH
77836: LD_INT 22
77838: PUSH
77839: LD_VAR 0 11
77843: PPUSH
77844: CALL_OW 255
77848: PUSH
77849: EMPTY
77850: LIST
77851: LIST
77852: PUSH
77853: LD_INT 2
77855: PUSH
77856: LD_INT 30
77858: PUSH
77859: LD_INT 0
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: PUSH
77866: LD_INT 30
77868: PUSH
77869: LD_INT 1
77871: PUSH
77872: EMPTY
77873: LIST
77874: LIST
77875: PUSH
77876: EMPTY
77877: LIST
77878: LIST
77879: LIST
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: PPUSH
77885: CALL_OW 72
77889: ST_TO_ADDR
// if dep then
77890: LD_VAR 0 15
77894: IFFALSE 78030
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
77896: LD_ADDR_VAR 0 14
77900: PUSH
77901: LD_VAR 0 15
77905: PUSH
77906: LD_INT 1
77908: ARRAY
77909: PPUSH
77910: CALL_OW 250
77914: PPUSH
77915: LD_VAR 0 15
77919: PUSH
77920: LD_INT 1
77922: ARRAY
77923: PPUSH
77924: CALL_OW 254
77928: PPUSH
77929: LD_INT 5
77931: PPUSH
77932: CALL_OW 272
77936: PUSH
77937: LD_VAR 0 15
77941: PUSH
77942: LD_INT 1
77944: ARRAY
77945: PPUSH
77946: CALL_OW 251
77950: PPUSH
77951: LD_VAR 0 15
77955: PUSH
77956: LD_INT 1
77958: ARRAY
77959: PPUSH
77960: CALL_OW 254
77964: PPUSH
77965: LD_INT 5
77967: PPUSH
77968: CALL_OW 273
77972: PUSH
77973: EMPTY
77974: LIST
77975: LIST
77976: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
77977: LD_VAR 0 14
77981: PUSH
77982: LD_INT 1
77984: ARRAY
77985: PPUSH
77986: LD_VAR 0 14
77990: PUSH
77991: LD_INT 2
77993: ARRAY
77994: PPUSH
77995: CALL_OW 488
77999: IFFALSE 78030
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78001: LD_VAR 0 11
78005: PPUSH
78006: LD_VAR 0 14
78010: PUSH
78011: LD_INT 1
78013: ARRAY
78014: PPUSH
78015: LD_VAR 0 14
78019: PUSH
78020: LD_INT 2
78022: ARRAY
78023: PPUSH
78024: CALL_OW 111
// continue ;
78028: GO 77661
// end ; end ; r := GetDir ( tmp ) ;
78030: LD_ADDR_VAR 0 13
78034: PUSH
78035: LD_VAR 0 11
78039: PPUSH
78040: CALL_OW 254
78044: ST_TO_ADDR
// if r = 5 then
78045: LD_VAR 0 13
78049: PUSH
78050: LD_INT 5
78052: EQUAL
78053: IFFALSE 78063
// r := 0 ;
78055: LD_ADDR_VAR 0 13
78059: PUSH
78060: LD_INT 0
78062: ST_TO_ADDR
// for j = r to 5 do
78063: LD_ADDR_VAR 0 8
78067: PUSH
78068: DOUBLE
78069: LD_VAR 0 13
78073: DEC
78074: ST_TO_ADDR
78075: LD_INT 5
78077: PUSH
78078: FOR_TO
78079: IFFALSE 78193
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78081: LD_ADDR_VAR 0 9
78085: PUSH
78086: LD_VAR 0 11
78090: PPUSH
78091: CALL_OW 250
78095: PPUSH
78096: LD_VAR 0 8
78100: PPUSH
78101: LD_INT 2
78103: PPUSH
78104: CALL_OW 272
78108: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78109: LD_ADDR_VAR 0 10
78113: PUSH
78114: LD_VAR 0 11
78118: PPUSH
78119: CALL_OW 251
78123: PPUSH
78124: LD_VAR 0 8
78128: PPUSH
78129: LD_INT 2
78131: PPUSH
78132: CALL_OW 273
78136: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78137: LD_VAR 0 9
78141: PPUSH
78142: LD_VAR 0 10
78146: PPUSH
78147: CALL_OW 488
78151: PUSH
78152: LD_VAR 0 9
78156: PPUSH
78157: LD_VAR 0 10
78161: PPUSH
78162: CALL_OW 428
78166: NOT
78167: AND
78168: IFFALSE 78191
// begin ComMoveXY ( tmp , _x , _y ) ;
78170: LD_VAR 0 11
78174: PPUSH
78175: LD_VAR 0 9
78179: PPUSH
78180: LD_VAR 0 10
78184: PPUSH
78185: CALL_OW 111
// break ;
78189: GO 78193
// end ; end ;
78191: GO 78078
78193: POP
78194: POP
// end ;
78195: GO 77661
78197: POP
78198: POP
// end ;
78199: LD_VAR 0 6
78203: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
78204: LD_INT 0
78206: PPUSH
78207: PPUSH
78208: PPUSH
78209: PPUSH
78210: PPUSH
78211: PPUSH
78212: PPUSH
78213: PPUSH
78214: PPUSH
78215: PPUSH
// result := false ;
78216: LD_ADDR_VAR 0 6
78220: PUSH
78221: LD_INT 0
78223: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78224: LD_VAR 0 1
78228: NOT
78229: PUSH
78230: LD_VAR 0 1
78234: PPUSH
78235: CALL_OW 266
78239: PUSH
78240: LD_INT 0
78242: PUSH
78243: LD_INT 1
78245: PUSH
78246: EMPTY
78247: LIST
78248: LIST
78249: IN
78250: NOT
78251: OR
78252: PUSH
78253: LD_VAR 0 2
78257: NOT
78258: OR
78259: PUSH
78260: LD_VAR 0 5
78264: PUSH
78265: LD_INT 0
78267: PUSH
78268: LD_INT 1
78270: PUSH
78271: LD_INT 2
78273: PUSH
78274: LD_INT 3
78276: PUSH
78277: LD_INT 4
78279: PUSH
78280: LD_INT 5
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: LIST
78287: LIST
78288: LIST
78289: LIST
78290: IN
78291: NOT
78292: OR
78293: PUSH
78294: LD_VAR 0 3
78298: PPUSH
78299: LD_VAR 0 4
78303: PPUSH
78304: CALL_OW 488
78308: NOT
78309: OR
78310: IFFALSE 78314
// exit ;
78312: GO 79031
// pom := GetBase ( depot ) ;
78314: LD_ADDR_VAR 0 10
78318: PUSH
78319: LD_VAR 0 1
78323: PPUSH
78324: CALL_OW 274
78328: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78329: LD_ADDR_VAR 0 11
78333: PUSH
78334: LD_VAR 0 2
78338: PPUSH
78339: LD_VAR 0 1
78343: PPUSH
78344: CALL_OW 248
78348: PPUSH
78349: CALL_OW 450
78353: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
78354: LD_VAR 0 10
78358: PPUSH
78359: LD_INT 1
78361: PPUSH
78362: CALL_OW 275
78366: PUSH
78367: LD_VAR 0 11
78371: PUSH
78372: LD_INT 1
78374: ARRAY
78375: GREATEREQUAL
78376: PUSH
78377: LD_VAR 0 10
78381: PPUSH
78382: LD_INT 2
78384: PPUSH
78385: CALL_OW 275
78389: PUSH
78390: LD_VAR 0 11
78394: PUSH
78395: LD_INT 2
78397: ARRAY
78398: GREATEREQUAL
78399: AND
78400: PUSH
78401: LD_VAR 0 10
78405: PPUSH
78406: LD_INT 3
78408: PPUSH
78409: CALL_OW 275
78413: PUSH
78414: LD_VAR 0 11
78418: PUSH
78419: LD_INT 3
78421: ARRAY
78422: GREATEREQUAL
78423: AND
78424: NOT
78425: IFFALSE 78429
// exit ;
78427: GO 79031
// if GetBType ( depot ) = b_depot then
78429: LD_VAR 0 1
78433: PPUSH
78434: CALL_OW 266
78438: PUSH
78439: LD_INT 0
78441: EQUAL
78442: IFFALSE 78454
// dist := 28 else
78444: LD_ADDR_VAR 0 14
78448: PUSH
78449: LD_INT 28
78451: ST_TO_ADDR
78452: GO 78462
// dist := 36 ;
78454: LD_ADDR_VAR 0 14
78458: PUSH
78459: LD_INT 36
78461: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
78462: LD_VAR 0 1
78466: PPUSH
78467: LD_VAR 0 3
78471: PPUSH
78472: LD_VAR 0 4
78476: PPUSH
78477: CALL_OW 297
78481: PUSH
78482: LD_VAR 0 14
78486: GREATER
78487: IFFALSE 78491
// exit ;
78489: GO 79031
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
78491: LD_ADDR_VAR 0 12
78495: PUSH
78496: LD_VAR 0 2
78500: PPUSH
78501: LD_VAR 0 3
78505: PPUSH
78506: LD_VAR 0 4
78510: PPUSH
78511: LD_VAR 0 5
78515: PPUSH
78516: LD_VAR 0 1
78520: PPUSH
78521: CALL_OW 248
78525: PPUSH
78526: LD_INT 0
78528: PPUSH
78529: CALL 79036 0 6
78533: ST_TO_ADDR
// if not hexes then
78534: LD_VAR 0 12
78538: NOT
78539: IFFALSE 78543
// exit ;
78541: GO 79031
// hex := GetHexInfo ( x , y ) ;
78543: LD_ADDR_VAR 0 15
78547: PUSH
78548: LD_VAR 0 3
78552: PPUSH
78553: LD_VAR 0 4
78557: PPUSH
78558: CALL_OW 546
78562: ST_TO_ADDR
// if hex [ 1 ] then
78563: LD_VAR 0 15
78567: PUSH
78568: LD_INT 1
78570: ARRAY
78571: IFFALSE 78575
// exit ;
78573: GO 79031
// height := hex [ 2 ] ;
78575: LD_ADDR_VAR 0 13
78579: PUSH
78580: LD_VAR 0 15
78584: PUSH
78585: LD_INT 2
78587: ARRAY
78588: ST_TO_ADDR
// for i = 1 to hexes do
78589: LD_ADDR_VAR 0 7
78593: PUSH
78594: DOUBLE
78595: LD_INT 1
78597: DEC
78598: ST_TO_ADDR
78599: LD_VAR 0 12
78603: PUSH
78604: FOR_TO
78605: IFFALSE 78935
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
78607: LD_VAR 0 12
78611: PUSH
78612: LD_VAR 0 7
78616: ARRAY
78617: PUSH
78618: LD_INT 1
78620: ARRAY
78621: PPUSH
78622: LD_VAR 0 12
78626: PUSH
78627: LD_VAR 0 7
78631: ARRAY
78632: PUSH
78633: LD_INT 2
78635: ARRAY
78636: PPUSH
78637: CALL_OW 488
78641: NOT
78642: PUSH
78643: LD_VAR 0 12
78647: PUSH
78648: LD_VAR 0 7
78652: ARRAY
78653: PUSH
78654: LD_INT 1
78656: ARRAY
78657: PPUSH
78658: LD_VAR 0 12
78662: PUSH
78663: LD_VAR 0 7
78667: ARRAY
78668: PUSH
78669: LD_INT 2
78671: ARRAY
78672: PPUSH
78673: CALL_OW 428
78677: PUSH
78678: LD_INT 0
78680: GREATER
78681: OR
78682: PUSH
78683: LD_VAR 0 12
78687: PUSH
78688: LD_VAR 0 7
78692: ARRAY
78693: PUSH
78694: LD_INT 1
78696: ARRAY
78697: PPUSH
78698: LD_VAR 0 12
78702: PUSH
78703: LD_VAR 0 7
78707: ARRAY
78708: PUSH
78709: LD_INT 2
78711: ARRAY
78712: PPUSH
78713: CALL_OW 351
78717: OR
78718: IFFALSE 78724
// exit ;
78720: POP
78721: POP
78722: GO 79031
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78724: LD_ADDR_VAR 0 8
78728: PUSH
78729: LD_VAR 0 12
78733: PUSH
78734: LD_VAR 0 7
78738: ARRAY
78739: PUSH
78740: LD_INT 1
78742: ARRAY
78743: PPUSH
78744: LD_VAR 0 12
78748: PUSH
78749: LD_VAR 0 7
78753: ARRAY
78754: PUSH
78755: LD_INT 2
78757: ARRAY
78758: PPUSH
78759: CALL_OW 546
78763: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
78764: LD_VAR 0 8
78768: PUSH
78769: LD_INT 1
78771: ARRAY
78772: PUSH
78773: LD_VAR 0 8
78777: PUSH
78778: LD_INT 2
78780: ARRAY
78781: PUSH
78782: LD_VAR 0 13
78786: PUSH
78787: LD_INT 2
78789: PLUS
78790: GREATER
78791: OR
78792: PUSH
78793: LD_VAR 0 8
78797: PUSH
78798: LD_INT 2
78800: ARRAY
78801: PUSH
78802: LD_VAR 0 13
78806: PUSH
78807: LD_INT 2
78809: MINUS
78810: LESS
78811: OR
78812: PUSH
78813: LD_VAR 0 8
78817: PUSH
78818: LD_INT 3
78820: ARRAY
78821: PUSH
78822: LD_INT 0
78824: PUSH
78825: LD_INT 8
78827: PUSH
78828: LD_INT 9
78830: PUSH
78831: LD_INT 10
78833: PUSH
78834: LD_INT 11
78836: PUSH
78837: LD_INT 12
78839: PUSH
78840: LD_INT 13
78842: PUSH
78843: LD_INT 16
78845: PUSH
78846: LD_INT 17
78848: PUSH
78849: LD_INT 18
78851: PUSH
78852: LD_INT 19
78854: PUSH
78855: LD_INT 20
78857: PUSH
78858: LD_INT 21
78860: PUSH
78861: EMPTY
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: LIST
78870: LIST
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: IN
78876: NOT
78877: OR
78878: PUSH
78879: LD_VAR 0 8
78883: PUSH
78884: LD_INT 5
78886: ARRAY
78887: NOT
78888: OR
78889: PUSH
78890: LD_VAR 0 8
78894: PUSH
78895: LD_INT 6
78897: ARRAY
78898: PUSH
78899: LD_INT 1
78901: PUSH
78902: LD_INT 2
78904: PUSH
78905: LD_INT 7
78907: PUSH
78908: LD_INT 9
78910: PUSH
78911: LD_INT 10
78913: PUSH
78914: LD_INT 11
78916: PUSH
78917: EMPTY
78918: LIST
78919: LIST
78920: LIST
78921: LIST
78922: LIST
78923: LIST
78924: IN
78925: NOT
78926: OR
78927: IFFALSE 78933
// exit ;
78929: POP
78930: POP
78931: GO 79031
// end ;
78933: GO 78604
78935: POP
78936: POP
// side := GetSide ( depot ) ;
78937: LD_ADDR_VAR 0 9
78941: PUSH
78942: LD_VAR 0 1
78946: PPUSH
78947: CALL_OW 255
78951: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
78952: LD_VAR 0 9
78956: PPUSH
78957: LD_VAR 0 3
78961: PPUSH
78962: LD_VAR 0 4
78966: PPUSH
78967: LD_INT 20
78969: PPUSH
78970: CALL 71685 0 4
78974: PUSH
78975: LD_INT 4
78977: ARRAY
78978: IFFALSE 78982
// exit ;
78980: GO 79031
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
78982: LD_VAR 0 2
78986: PUSH
78987: LD_INT 29
78989: PUSH
78990: LD_INT 30
78992: PUSH
78993: EMPTY
78994: LIST
78995: LIST
78996: IN
78997: PUSH
78998: LD_VAR 0 3
79002: PPUSH
79003: LD_VAR 0 4
79007: PPUSH
79008: LD_VAR 0 9
79012: PPUSH
79013: CALL_OW 440
79017: NOT
79018: AND
79019: IFFALSE 79023
// exit ;
79021: GO 79031
// result := true ;
79023: LD_ADDR_VAR 0 6
79027: PUSH
79028: LD_INT 1
79030: ST_TO_ADDR
// end ;
79031: LD_VAR 0 6
79035: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
79036: LD_INT 0
79038: PPUSH
79039: PPUSH
79040: PPUSH
79041: PPUSH
79042: PPUSH
79043: PPUSH
79044: PPUSH
79045: PPUSH
79046: PPUSH
79047: PPUSH
79048: PPUSH
79049: PPUSH
79050: PPUSH
79051: PPUSH
79052: PPUSH
79053: PPUSH
79054: PPUSH
79055: PPUSH
79056: PPUSH
79057: PPUSH
79058: PPUSH
79059: PPUSH
79060: PPUSH
79061: PPUSH
79062: PPUSH
79063: PPUSH
79064: PPUSH
79065: PPUSH
79066: PPUSH
79067: PPUSH
79068: PPUSH
79069: PPUSH
79070: PPUSH
79071: PPUSH
79072: PPUSH
79073: PPUSH
79074: PPUSH
79075: PPUSH
79076: PPUSH
79077: PPUSH
79078: PPUSH
79079: PPUSH
79080: PPUSH
79081: PPUSH
79082: PPUSH
79083: PPUSH
79084: PPUSH
79085: PPUSH
79086: PPUSH
79087: PPUSH
79088: PPUSH
79089: PPUSH
79090: PPUSH
79091: PPUSH
79092: PPUSH
79093: PPUSH
79094: PPUSH
79095: PPUSH
// result = [ ] ;
79096: LD_ADDR_VAR 0 7
79100: PUSH
79101: EMPTY
79102: ST_TO_ADDR
// temp_list = [ ] ;
79103: LD_ADDR_VAR 0 9
79107: PUSH
79108: EMPTY
79109: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79110: LD_VAR 0 4
79114: PUSH
79115: LD_INT 0
79117: PUSH
79118: LD_INT 1
79120: PUSH
79121: LD_INT 2
79123: PUSH
79124: LD_INT 3
79126: PUSH
79127: LD_INT 4
79129: PUSH
79130: LD_INT 5
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: LIST
79137: LIST
79138: LIST
79139: LIST
79140: IN
79141: NOT
79142: PUSH
79143: LD_VAR 0 1
79147: PUSH
79148: LD_INT 0
79150: PUSH
79151: LD_INT 1
79153: PUSH
79154: EMPTY
79155: LIST
79156: LIST
79157: IN
79158: PUSH
79159: LD_VAR 0 5
79163: PUSH
79164: LD_INT 1
79166: PUSH
79167: LD_INT 2
79169: PUSH
79170: LD_INT 3
79172: PUSH
79173: EMPTY
79174: LIST
79175: LIST
79176: LIST
79177: IN
79178: NOT
79179: AND
79180: OR
79181: IFFALSE 79185
// exit ;
79183: GO 97576
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79185: LD_VAR 0 1
79189: PUSH
79190: LD_INT 6
79192: PUSH
79193: LD_INT 7
79195: PUSH
79196: LD_INT 8
79198: PUSH
79199: LD_INT 13
79201: PUSH
79202: LD_INT 12
79204: PUSH
79205: LD_INT 15
79207: PUSH
79208: LD_INT 11
79210: PUSH
79211: LD_INT 14
79213: PUSH
79214: LD_INT 10
79216: PUSH
79217: EMPTY
79218: LIST
79219: LIST
79220: LIST
79221: LIST
79222: LIST
79223: LIST
79224: LIST
79225: LIST
79226: LIST
79227: IN
79228: IFFALSE 79238
// btype = b_lab ;
79230: LD_ADDR_VAR 0 1
79234: PUSH
79235: LD_INT 6
79237: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79238: LD_VAR 0 6
79242: PUSH
79243: LD_INT 0
79245: PUSH
79246: LD_INT 1
79248: PUSH
79249: LD_INT 2
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: LIST
79256: IN
79257: NOT
79258: PUSH
79259: LD_VAR 0 1
79263: PUSH
79264: LD_INT 0
79266: PUSH
79267: LD_INT 1
79269: PUSH
79270: LD_INT 2
79272: PUSH
79273: LD_INT 3
79275: PUSH
79276: LD_INT 6
79278: PUSH
79279: LD_INT 36
79281: PUSH
79282: LD_INT 4
79284: PUSH
79285: LD_INT 5
79287: PUSH
79288: LD_INT 31
79290: PUSH
79291: LD_INT 32
79293: PUSH
79294: LD_INT 33
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: LIST
79301: LIST
79302: LIST
79303: LIST
79304: LIST
79305: LIST
79306: LIST
79307: LIST
79308: LIST
79309: IN
79310: NOT
79311: PUSH
79312: LD_VAR 0 6
79316: PUSH
79317: LD_INT 1
79319: EQUAL
79320: AND
79321: OR
79322: PUSH
79323: LD_VAR 0 1
79327: PUSH
79328: LD_INT 2
79330: PUSH
79331: LD_INT 3
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: IN
79338: NOT
79339: PUSH
79340: LD_VAR 0 6
79344: PUSH
79345: LD_INT 2
79347: EQUAL
79348: AND
79349: OR
79350: IFFALSE 79360
// mode = 0 ;
79352: LD_ADDR_VAR 0 6
79356: PUSH
79357: LD_INT 0
79359: ST_TO_ADDR
// case mode of 0 :
79360: LD_VAR 0 6
79364: PUSH
79365: LD_INT 0
79367: DOUBLE
79368: EQUAL
79369: IFTRUE 79373
79371: GO 90826
79373: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79374: LD_ADDR_VAR 0 11
79378: PUSH
79379: LD_INT 0
79381: PUSH
79382: LD_INT 0
79384: PUSH
79385: EMPTY
79386: LIST
79387: LIST
79388: PUSH
79389: LD_INT 0
79391: PUSH
79392: LD_INT 1
79394: NEG
79395: PUSH
79396: EMPTY
79397: LIST
79398: LIST
79399: PUSH
79400: LD_INT 1
79402: PUSH
79403: LD_INT 0
79405: PUSH
79406: EMPTY
79407: LIST
79408: LIST
79409: PUSH
79410: LD_INT 1
79412: PUSH
79413: LD_INT 1
79415: PUSH
79416: EMPTY
79417: LIST
79418: LIST
79419: PUSH
79420: LD_INT 0
79422: PUSH
79423: LD_INT 1
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PUSH
79430: LD_INT 1
79432: NEG
79433: PUSH
79434: LD_INT 0
79436: PUSH
79437: EMPTY
79438: LIST
79439: LIST
79440: PUSH
79441: LD_INT 1
79443: NEG
79444: PUSH
79445: LD_INT 1
79447: NEG
79448: PUSH
79449: EMPTY
79450: LIST
79451: LIST
79452: PUSH
79453: LD_INT 1
79455: NEG
79456: PUSH
79457: LD_INT 2
79459: NEG
79460: PUSH
79461: EMPTY
79462: LIST
79463: LIST
79464: PUSH
79465: LD_INT 0
79467: PUSH
79468: LD_INT 2
79470: NEG
79471: PUSH
79472: EMPTY
79473: LIST
79474: LIST
79475: PUSH
79476: LD_INT 1
79478: PUSH
79479: LD_INT 1
79481: NEG
79482: PUSH
79483: EMPTY
79484: LIST
79485: LIST
79486: PUSH
79487: LD_INT 1
79489: PUSH
79490: LD_INT 2
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 0
79499: PUSH
79500: LD_INT 2
79502: PUSH
79503: EMPTY
79504: LIST
79505: LIST
79506: PUSH
79507: LD_INT 1
79509: NEG
79510: PUSH
79511: LD_INT 1
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 1
79520: PUSH
79521: LD_INT 3
79523: PUSH
79524: EMPTY
79525: LIST
79526: LIST
79527: PUSH
79528: LD_INT 0
79530: PUSH
79531: LD_INT 3
79533: PUSH
79534: EMPTY
79535: LIST
79536: LIST
79537: PUSH
79538: LD_INT 1
79540: NEG
79541: PUSH
79542: LD_INT 2
79544: PUSH
79545: EMPTY
79546: LIST
79547: LIST
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: LIST
79553: LIST
79554: LIST
79555: LIST
79556: LIST
79557: LIST
79558: LIST
79559: LIST
79560: LIST
79561: LIST
79562: LIST
79563: LIST
79564: LIST
79565: LIST
79566: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79567: LD_ADDR_VAR 0 12
79571: PUSH
79572: LD_INT 0
79574: PUSH
79575: LD_INT 0
79577: PUSH
79578: EMPTY
79579: LIST
79580: LIST
79581: PUSH
79582: LD_INT 0
79584: PUSH
79585: LD_INT 1
79587: NEG
79588: PUSH
79589: EMPTY
79590: LIST
79591: LIST
79592: PUSH
79593: LD_INT 1
79595: PUSH
79596: LD_INT 0
79598: PUSH
79599: EMPTY
79600: LIST
79601: LIST
79602: PUSH
79603: LD_INT 1
79605: PUSH
79606: LD_INT 1
79608: PUSH
79609: EMPTY
79610: LIST
79611: LIST
79612: PUSH
79613: LD_INT 0
79615: PUSH
79616: LD_INT 1
79618: PUSH
79619: EMPTY
79620: LIST
79621: LIST
79622: PUSH
79623: LD_INT 1
79625: NEG
79626: PUSH
79627: LD_INT 0
79629: PUSH
79630: EMPTY
79631: LIST
79632: LIST
79633: PUSH
79634: LD_INT 1
79636: NEG
79637: PUSH
79638: LD_INT 1
79640: NEG
79641: PUSH
79642: EMPTY
79643: LIST
79644: LIST
79645: PUSH
79646: LD_INT 1
79648: PUSH
79649: LD_INT 1
79651: NEG
79652: PUSH
79653: EMPTY
79654: LIST
79655: LIST
79656: PUSH
79657: LD_INT 2
79659: PUSH
79660: LD_INT 0
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: PUSH
79667: LD_INT 2
79669: PUSH
79670: LD_INT 1
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: LD_INT 1
79679: NEG
79680: PUSH
79681: LD_INT 1
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 2
79690: NEG
79691: PUSH
79692: LD_INT 0
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 2
79701: NEG
79702: PUSH
79703: LD_INT 1
79705: NEG
79706: PUSH
79707: EMPTY
79708: LIST
79709: LIST
79710: PUSH
79711: LD_INT 2
79713: NEG
79714: PUSH
79715: LD_INT 1
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 3
79724: NEG
79725: PUSH
79726: LD_INT 0
79728: PUSH
79729: EMPTY
79730: LIST
79731: LIST
79732: PUSH
79733: LD_INT 3
79735: NEG
79736: PUSH
79737: LD_INT 1
79739: NEG
79740: PUSH
79741: EMPTY
79742: LIST
79743: LIST
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: LIST
79749: LIST
79750: LIST
79751: LIST
79752: LIST
79753: LIST
79754: LIST
79755: LIST
79756: LIST
79757: LIST
79758: LIST
79759: LIST
79760: LIST
79761: LIST
79762: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
79763: LD_ADDR_VAR 0 13
79767: PUSH
79768: LD_INT 0
79770: PUSH
79771: LD_INT 0
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 0
79780: PUSH
79781: LD_INT 1
79783: NEG
79784: PUSH
79785: EMPTY
79786: LIST
79787: LIST
79788: PUSH
79789: LD_INT 1
79791: PUSH
79792: LD_INT 0
79794: PUSH
79795: EMPTY
79796: LIST
79797: LIST
79798: PUSH
79799: LD_INT 1
79801: PUSH
79802: LD_INT 1
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 0
79811: PUSH
79812: LD_INT 1
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 1
79821: NEG
79822: PUSH
79823: LD_INT 0
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 1
79832: NEG
79833: PUSH
79834: LD_INT 1
79836: NEG
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PUSH
79842: LD_INT 1
79844: NEG
79845: PUSH
79846: LD_INT 2
79848: NEG
79849: PUSH
79850: EMPTY
79851: LIST
79852: LIST
79853: PUSH
79854: LD_INT 2
79856: PUSH
79857: LD_INT 1
79859: PUSH
79860: EMPTY
79861: LIST
79862: LIST
79863: PUSH
79864: LD_INT 2
79866: PUSH
79867: LD_INT 2
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 1
79876: PUSH
79877: LD_INT 2
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: LD_INT 2
79886: NEG
79887: PUSH
79888: LD_INT 1
79890: NEG
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 2
79898: NEG
79899: PUSH
79900: LD_INT 2
79902: NEG
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: PUSH
79908: LD_INT 2
79910: NEG
79911: PUSH
79912: LD_INT 3
79914: NEG
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 3
79922: NEG
79923: PUSH
79924: LD_INT 2
79926: NEG
79927: PUSH
79928: EMPTY
79929: LIST
79930: LIST
79931: PUSH
79932: LD_INT 3
79934: NEG
79935: PUSH
79936: LD_INT 3
79938: NEG
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: LIST
79948: LIST
79949: LIST
79950: LIST
79951: LIST
79952: LIST
79953: LIST
79954: LIST
79955: LIST
79956: LIST
79957: LIST
79958: LIST
79959: LIST
79960: LIST
79961: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
79962: LD_ADDR_VAR 0 14
79966: PUSH
79967: LD_INT 0
79969: PUSH
79970: LD_INT 0
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 0
79979: PUSH
79980: LD_INT 1
79982: NEG
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: LD_INT 1
79990: PUSH
79991: LD_INT 0
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: PUSH
79998: LD_INT 1
80000: PUSH
80001: LD_INT 1
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: LD_INT 0
80010: PUSH
80011: LD_INT 1
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 1
80020: NEG
80021: PUSH
80022: LD_INT 0
80024: PUSH
80025: EMPTY
80026: LIST
80027: LIST
80028: PUSH
80029: LD_INT 1
80031: NEG
80032: PUSH
80033: LD_INT 1
80035: NEG
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: PUSH
80041: LD_INT 1
80043: NEG
80044: PUSH
80045: LD_INT 2
80047: NEG
80048: PUSH
80049: EMPTY
80050: LIST
80051: LIST
80052: PUSH
80053: LD_INT 0
80055: PUSH
80056: LD_INT 2
80058: NEG
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: LD_INT 1
80066: PUSH
80067: LD_INT 1
80069: NEG
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 1
80077: PUSH
80078: LD_INT 2
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 0
80087: PUSH
80088: LD_INT 2
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 1
80097: NEG
80098: PUSH
80099: LD_INT 1
80101: PUSH
80102: EMPTY
80103: LIST
80104: LIST
80105: PUSH
80106: LD_INT 1
80108: NEG
80109: PUSH
80110: LD_INT 3
80112: NEG
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 0
80120: PUSH
80121: LD_INT 3
80123: NEG
80124: PUSH
80125: EMPTY
80126: LIST
80127: LIST
80128: PUSH
80129: LD_INT 1
80131: PUSH
80132: LD_INT 2
80134: NEG
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: EMPTY
80141: LIST
80142: LIST
80143: LIST
80144: LIST
80145: LIST
80146: LIST
80147: LIST
80148: LIST
80149: LIST
80150: LIST
80151: LIST
80152: LIST
80153: LIST
80154: LIST
80155: LIST
80156: LIST
80157: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80158: LD_ADDR_VAR 0 15
80162: PUSH
80163: LD_INT 0
80165: PUSH
80166: LD_INT 0
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: PUSH
80173: LD_INT 0
80175: PUSH
80176: LD_INT 1
80178: NEG
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: PUSH
80184: LD_INT 1
80186: PUSH
80187: LD_INT 0
80189: PUSH
80190: EMPTY
80191: LIST
80192: LIST
80193: PUSH
80194: LD_INT 1
80196: PUSH
80197: LD_INT 1
80199: PUSH
80200: EMPTY
80201: LIST
80202: LIST
80203: PUSH
80204: LD_INT 0
80206: PUSH
80207: LD_INT 1
80209: PUSH
80210: EMPTY
80211: LIST
80212: LIST
80213: PUSH
80214: LD_INT 1
80216: NEG
80217: PUSH
80218: LD_INT 0
80220: PUSH
80221: EMPTY
80222: LIST
80223: LIST
80224: PUSH
80225: LD_INT 1
80227: NEG
80228: PUSH
80229: LD_INT 1
80231: NEG
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 1
80239: PUSH
80240: LD_INT 1
80242: NEG
80243: PUSH
80244: EMPTY
80245: LIST
80246: LIST
80247: PUSH
80248: LD_INT 2
80250: PUSH
80251: LD_INT 0
80253: PUSH
80254: EMPTY
80255: LIST
80256: LIST
80257: PUSH
80258: LD_INT 2
80260: PUSH
80261: LD_INT 1
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: LD_INT 1
80270: NEG
80271: PUSH
80272: LD_INT 1
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 2
80281: NEG
80282: PUSH
80283: LD_INT 0
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 2
80292: NEG
80293: PUSH
80294: LD_INT 1
80296: NEG
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 2
80304: PUSH
80305: LD_INT 1
80307: NEG
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PUSH
80313: LD_INT 3
80315: PUSH
80316: LD_INT 0
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 3
80325: PUSH
80326: LD_INT 1
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: EMPTY
80334: LIST
80335: LIST
80336: LIST
80337: LIST
80338: LIST
80339: LIST
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80351: LD_ADDR_VAR 0 16
80355: PUSH
80356: LD_INT 0
80358: PUSH
80359: LD_INT 0
80361: PUSH
80362: EMPTY
80363: LIST
80364: LIST
80365: PUSH
80366: LD_INT 0
80368: PUSH
80369: LD_INT 1
80371: NEG
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: PUSH
80377: LD_INT 1
80379: PUSH
80380: LD_INT 0
80382: PUSH
80383: EMPTY
80384: LIST
80385: LIST
80386: PUSH
80387: LD_INT 1
80389: PUSH
80390: LD_INT 1
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 0
80399: PUSH
80400: LD_INT 1
80402: PUSH
80403: EMPTY
80404: LIST
80405: LIST
80406: PUSH
80407: LD_INT 1
80409: NEG
80410: PUSH
80411: LD_INT 0
80413: PUSH
80414: EMPTY
80415: LIST
80416: LIST
80417: PUSH
80418: LD_INT 1
80420: NEG
80421: PUSH
80422: LD_INT 1
80424: NEG
80425: PUSH
80426: EMPTY
80427: LIST
80428: LIST
80429: PUSH
80430: LD_INT 1
80432: NEG
80433: PUSH
80434: LD_INT 2
80436: NEG
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: PUSH
80442: LD_INT 2
80444: PUSH
80445: LD_INT 1
80447: PUSH
80448: EMPTY
80449: LIST
80450: LIST
80451: PUSH
80452: LD_INT 2
80454: PUSH
80455: LD_INT 2
80457: PUSH
80458: EMPTY
80459: LIST
80460: LIST
80461: PUSH
80462: LD_INT 1
80464: PUSH
80465: LD_INT 2
80467: PUSH
80468: EMPTY
80469: LIST
80470: LIST
80471: PUSH
80472: LD_INT 2
80474: NEG
80475: PUSH
80476: LD_INT 1
80478: NEG
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 2
80486: NEG
80487: PUSH
80488: LD_INT 2
80490: NEG
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: PUSH
80496: LD_INT 3
80498: PUSH
80499: LD_INT 2
80501: PUSH
80502: EMPTY
80503: LIST
80504: LIST
80505: PUSH
80506: LD_INT 3
80508: PUSH
80509: LD_INT 3
80511: PUSH
80512: EMPTY
80513: LIST
80514: LIST
80515: PUSH
80516: LD_INT 2
80518: PUSH
80519: LD_INT 3
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: EMPTY
80527: LIST
80528: LIST
80529: LIST
80530: LIST
80531: LIST
80532: LIST
80533: LIST
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80544: LD_ADDR_VAR 0 17
80548: PUSH
80549: LD_INT 0
80551: PUSH
80552: LD_INT 0
80554: PUSH
80555: EMPTY
80556: LIST
80557: LIST
80558: PUSH
80559: LD_INT 0
80561: PUSH
80562: LD_INT 1
80564: NEG
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PUSH
80570: LD_INT 1
80572: PUSH
80573: LD_INT 0
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: LD_INT 1
80582: PUSH
80583: LD_INT 1
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 0
80592: PUSH
80593: LD_INT 1
80595: PUSH
80596: EMPTY
80597: LIST
80598: LIST
80599: PUSH
80600: LD_INT 1
80602: NEG
80603: PUSH
80604: LD_INT 0
80606: PUSH
80607: EMPTY
80608: LIST
80609: LIST
80610: PUSH
80611: LD_INT 1
80613: NEG
80614: PUSH
80615: LD_INT 1
80617: NEG
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PUSH
80623: LD_INT 1
80625: NEG
80626: PUSH
80627: LD_INT 2
80629: NEG
80630: PUSH
80631: EMPTY
80632: LIST
80633: LIST
80634: PUSH
80635: LD_INT 0
80637: PUSH
80638: LD_INT 2
80640: NEG
80641: PUSH
80642: EMPTY
80643: LIST
80644: LIST
80645: PUSH
80646: LD_INT 1
80648: PUSH
80649: LD_INT 1
80651: NEG
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 2
80659: PUSH
80660: LD_INT 0
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: LD_INT 2
80669: PUSH
80670: LD_INT 1
80672: PUSH
80673: EMPTY
80674: LIST
80675: LIST
80676: PUSH
80677: LD_INT 2
80679: PUSH
80680: LD_INT 2
80682: PUSH
80683: EMPTY
80684: LIST
80685: LIST
80686: PUSH
80687: LD_INT 1
80689: PUSH
80690: LD_INT 2
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 0
80699: PUSH
80700: LD_INT 2
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: PUSH
80707: LD_INT 1
80709: NEG
80710: PUSH
80711: LD_INT 1
80713: PUSH
80714: EMPTY
80715: LIST
80716: LIST
80717: PUSH
80718: LD_INT 2
80720: NEG
80721: PUSH
80722: LD_INT 0
80724: PUSH
80725: EMPTY
80726: LIST
80727: LIST
80728: PUSH
80729: LD_INT 2
80731: NEG
80732: PUSH
80733: LD_INT 1
80735: NEG
80736: PUSH
80737: EMPTY
80738: LIST
80739: LIST
80740: PUSH
80741: LD_INT 2
80743: NEG
80744: PUSH
80745: LD_INT 2
80747: NEG
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: LIST
80757: LIST
80758: LIST
80759: LIST
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: LIST
80765: LIST
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80774: LD_ADDR_VAR 0 18
80778: PUSH
80779: LD_INT 0
80781: PUSH
80782: LD_INT 0
80784: PUSH
80785: EMPTY
80786: LIST
80787: LIST
80788: PUSH
80789: LD_INT 0
80791: PUSH
80792: LD_INT 1
80794: NEG
80795: PUSH
80796: EMPTY
80797: LIST
80798: LIST
80799: PUSH
80800: LD_INT 1
80802: PUSH
80803: LD_INT 0
80805: PUSH
80806: EMPTY
80807: LIST
80808: LIST
80809: PUSH
80810: LD_INT 1
80812: PUSH
80813: LD_INT 1
80815: PUSH
80816: EMPTY
80817: LIST
80818: LIST
80819: PUSH
80820: LD_INT 0
80822: PUSH
80823: LD_INT 1
80825: PUSH
80826: EMPTY
80827: LIST
80828: LIST
80829: PUSH
80830: LD_INT 1
80832: NEG
80833: PUSH
80834: LD_INT 0
80836: PUSH
80837: EMPTY
80838: LIST
80839: LIST
80840: PUSH
80841: LD_INT 1
80843: NEG
80844: PUSH
80845: LD_INT 1
80847: NEG
80848: PUSH
80849: EMPTY
80850: LIST
80851: LIST
80852: PUSH
80853: LD_INT 1
80855: NEG
80856: PUSH
80857: LD_INT 2
80859: NEG
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 0
80867: PUSH
80868: LD_INT 2
80870: NEG
80871: PUSH
80872: EMPTY
80873: LIST
80874: LIST
80875: PUSH
80876: LD_INT 1
80878: PUSH
80879: LD_INT 1
80881: NEG
80882: PUSH
80883: EMPTY
80884: LIST
80885: LIST
80886: PUSH
80887: LD_INT 2
80889: PUSH
80890: LD_INT 0
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: LD_INT 2
80899: PUSH
80900: LD_INT 1
80902: PUSH
80903: EMPTY
80904: LIST
80905: LIST
80906: PUSH
80907: LD_INT 2
80909: PUSH
80910: LD_INT 2
80912: PUSH
80913: EMPTY
80914: LIST
80915: LIST
80916: PUSH
80917: LD_INT 1
80919: PUSH
80920: LD_INT 2
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 0
80929: PUSH
80930: LD_INT 2
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 1
80939: NEG
80940: PUSH
80941: LD_INT 1
80943: PUSH
80944: EMPTY
80945: LIST
80946: LIST
80947: PUSH
80948: LD_INT 2
80950: NEG
80951: PUSH
80952: LD_INT 0
80954: PUSH
80955: EMPTY
80956: LIST
80957: LIST
80958: PUSH
80959: LD_INT 2
80961: NEG
80962: PUSH
80963: LD_INT 1
80965: NEG
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: LD_INT 2
80973: NEG
80974: PUSH
80975: LD_INT 2
80977: NEG
80978: PUSH
80979: EMPTY
80980: LIST
80981: LIST
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: LIST
80987: LIST
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: LIST
80995: LIST
80996: LIST
80997: LIST
80998: LIST
80999: LIST
81000: LIST
81001: LIST
81002: LIST
81003: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81004: LD_ADDR_VAR 0 19
81008: PUSH
81009: LD_INT 0
81011: PUSH
81012: LD_INT 0
81014: PUSH
81015: EMPTY
81016: LIST
81017: LIST
81018: PUSH
81019: LD_INT 0
81021: PUSH
81022: LD_INT 1
81024: NEG
81025: PUSH
81026: EMPTY
81027: LIST
81028: LIST
81029: PUSH
81030: LD_INT 1
81032: PUSH
81033: LD_INT 0
81035: PUSH
81036: EMPTY
81037: LIST
81038: LIST
81039: PUSH
81040: LD_INT 1
81042: PUSH
81043: LD_INT 1
81045: PUSH
81046: EMPTY
81047: LIST
81048: LIST
81049: PUSH
81050: LD_INT 0
81052: PUSH
81053: LD_INT 1
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 1
81062: NEG
81063: PUSH
81064: LD_INT 0
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: LD_INT 1
81073: NEG
81074: PUSH
81075: LD_INT 1
81077: NEG
81078: PUSH
81079: EMPTY
81080: LIST
81081: LIST
81082: PUSH
81083: LD_INT 1
81085: NEG
81086: PUSH
81087: LD_INT 2
81089: NEG
81090: PUSH
81091: EMPTY
81092: LIST
81093: LIST
81094: PUSH
81095: LD_INT 0
81097: PUSH
81098: LD_INT 2
81100: NEG
81101: PUSH
81102: EMPTY
81103: LIST
81104: LIST
81105: PUSH
81106: LD_INT 1
81108: PUSH
81109: LD_INT 1
81111: NEG
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 2
81119: PUSH
81120: LD_INT 0
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: PUSH
81127: LD_INT 2
81129: PUSH
81130: LD_INT 1
81132: PUSH
81133: EMPTY
81134: LIST
81135: LIST
81136: PUSH
81137: LD_INT 2
81139: PUSH
81140: LD_INT 2
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PUSH
81147: LD_INT 1
81149: PUSH
81150: LD_INT 2
81152: PUSH
81153: EMPTY
81154: LIST
81155: LIST
81156: PUSH
81157: LD_INT 0
81159: PUSH
81160: LD_INT 2
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PUSH
81167: LD_INT 1
81169: NEG
81170: PUSH
81171: LD_INT 1
81173: PUSH
81174: EMPTY
81175: LIST
81176: LIST
81177: PUSH
81178: LD_INT 2
81180: NEG
81181: PUSH
81182: LD_INT 0
81184: PUSH
81185: EMPTY
81186: LIST
81187: LIST
81188: PUSH
81189: LD_INT 2
81191: NEG
81192: PUSH
81193: LD_INT 1
81195: NEG
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: PUSH
81201: LD_INT 2
81203: NEG
81204: PUSH
81205: LD_INT 2
81207: NEG
81208: PUSH
81209: EMPTY
81210: LIST
81211: LIST
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: LIST
81217: LIST
81218: LIST
81219: LIST
81220: LIST
81221: LIST
81222: LIST
81223: LIST
81224: LIST
81225: LIST
81226: LIST
81227: LIST
81228: LIST
81229: LIST
81230: LIST
81231: LIST
81232: LIST
81233: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81234: LD_ADDR_VAR 0 20
81238: PUSH
81239: LD_INT 0
81241: PUSH
81242: LD_INT 0
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 0
81251: PUSH
81252: LD_INT 1
81254: NEG
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: LD_INT 1
81262: PUSH
81263: LD_INT 0
81265: PUSH
81266: EMPTY
81267: LIST
81268: LIST
81269: PUSH
81270: LD_INT 1
81272: PUSH
81273: LD_INT 1
81275: PUSH
81276: EMPTY
81277: LIST
81278: LIST
81279: PUSH
81280: LD_INT 0
81282: PUSH
81283: LD_INT 1
81285: PUSH
81286: EMPTY
81287: LIST
81288: LIST
81289: PUSH
81290: LD_INT 1
81292: NEG
81293: PUSH
81294: LD_INT 0
81296: PUSH
81297: EMPTY
81298: LIST
81299: LIST
81300: PUSH
81301: LD_INT 1
81303: NEG
81304: PUSH
81305: LD_INT 1
81307: NEG
81308: PUSH
81309: EMPTY
81310: LIST
81311: LIST
81312: PUSH
81313: LD_INT 1
81315: NEG
81316: PUSH
81317: LD_INT 2
81319: NEG
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PUSH
81325: LD_INT 0
81327: PUSH
81328: LD_INT 2
81330: NEG
81331: PUSH
81332: EMPTY
81333: LIST
81334: LIST
81335: PUSH
81336: LD_INT 1
81338: PUSH
81339: LD_INT 1
81341: NEG
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 2
81349: PUSH
81350: LD_INT 0
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 2
81359: PUSH
81360: LD_INT 1
81362: PUSH
81363: EMPTY
81364: LIST
81365: LIST
81366: PUSH
81367: LD_INT 2
81369: PUSH
81370: LD_INT 2
81372: PUSH
81373: EMPTY
81374: LIST
81375: LIST
81376: PUSH
81377: LD_INT 1
81379: PUSH
81380: LD_INT 2
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: PUSH
81387: LD_INT 0
81389: PUSH
81390: LD_INT 2
81392: PUSH
81393: EMPTY
81394: LIST
81395: LIST
81396: PUSH
81397: LD_INT 1
81399: NEG
81400: PUSH
81401: LD_INT 1
81403: PUSH
81404: EMPTY
81405: LIST
81406: LIST
81407: PUSH
81408: LD_INT 2
81410: NEG
81411: PUSH
81412: LD_INT 0
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 2
81421: NEG
81422: PUSH
81423: LD_INT 1
81425: NEG
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 2
81433: NEG
81434: PUSH
81435: LD_INT 2
81437: NEG
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: LIST
81456: LIST
81457: LIST
81458: LIST
81459: LIST
81460: LIST
81461: LIST
81462: LIST
81463: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81464: LD_ADDR_VAR 0 21
81468: PUSH
81469: LD_INT 0
81471: PUSH
81472: LD_INT 0
81474: PUSH
81475: EMPTY
81476: LIST
81477: LIST
81478: PUSH
81479: LD_INT 0
81481: PUSH
81482: LD_INT 1
81484: NEG
81485: PUSH
81486: EMPTY
81487: LIST
81488: LIST
81489: PUSH
81490: LD_INT 1
81492: PUSH
81493: LD_INT 0
81495: PUSH
81496: EMPTY
81497: LIST
81498: LIST
81499: PUSH
81500: LD_INT 1
81502: PUSH
81503: LD_INT 1
81505: PUSH
81506: EMPTY
81507: LIST
81508: LIST
81509: PUSH
81510: LD_INT 0
81512: PUSH
81513: LD_INT 1
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 1
81522: NEG
81523: PUSH
81524: LD_INT 0
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 1
81533: NEG
81534: PUSH
81535: LD_INT 1
81537: NEG
81538: PUSH
81539: EMPTY
81540: LIST
81541: LIST
81542: PUSH
81543: LD_INT 1
81545: NEG
81546: PUSH
81547: LD_INT 2
81549: NEG
81550: PUSH
81551: EMPTY
81552: LIST
81553: LIST
81554: PUSH
81555: LD_INT 0
81557: PUSH
81558: LD_INT 2
81560: NEG
81561: PUSH
81562: EMPTY
81563: LIST
81564: LIST
81565: PUSH
81566: LD_INT 1
81568: PUSH
81569: LD_INT 1
81571: NEG
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 2
81579: PUSH
81580: LD_INT 0
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 2
81589: PUSH
81590: LD_INT 1
81592: PUSH
81593: EMPTY
81594: LIST
81595: LIST
81596: PUSH
81597: LD_INT 2
81599: PUSH
81600: LD_INT 2
81602: PUSH
81603: EMPTY
81604: LIST
81605: LIST
81606: PUSH
81607: LD_INT 1
81609: PUSH
81610: LD_INT 2
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: PUSH
81617: LD_INT 0
81619: PUSH
81620: LD_INT 2
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 1
81629: NEG
81630: PUSH
81631: LD_INT 1
81633: PUSH
81634: EMPTY
81635: LIST
81636: LIST
81637: PUSH
81638: LD_INT 2
81640: NEG
81641: PUSH
81642: LD_INT 0
81644: PUSH
81645: EMPTY
81646: LIST
81647: LIST
81648: PUSH
81649: LD_INT 2
81651: NEG
81652: PUSH
81653: LD_INT 1
81655: NEG
81656: PUSH
81657: EMPTY
81658: LIST
81659: LIST
81660: PUSH
81661: LD_INT 2
81663: NEG
81664: PUSH
81665: LD_INT 2
81667: NEG
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: LIST
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: LIST
81686: LIST
81687: LIST
81688: LIST
81689: LIST
81690: LIST
81691: LIST
81692: LIST
81693: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81694: LD_ADDR_VAR 0 22
81698: PUSH
81699: LD_INT 0
81701: PUSH
81702: LD_INT 0
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: PUSH
81709: LD_INT 0
81711: PUSH
81712: LD_INT 1
81714: NEG
81715: PUSH
81716: EMPTY
81717: LIST
81718: LIST
81719: PUSH
81720: LD_INT 1
81722: PUSH
81723: LD_INT 0
81725: PUSH
81726: EMPTY
81727: LIST
81728: LIST
81729: PUSH
81730: LD_INT 1
81732: PUSH
81733: LD_INT 1
81735: PUSH
81736: EMPTY
81737: LIST
81738: LIST
81739: PUSH
81740: LD_INT 0
81742: PUSH
81743: LD_INT 1
81745: PUSH
81746: EMPTY
81747: LIST
81748: LIST
81749: PUSH
81750: LD_INT 1
81752: NEG
81753: PUSH
81754: LD_INT 0
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 1
81763: NEG
81764: PUSH
81765: LD_INT 1
81767: NEG
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: LD_INT 1
81775: NEG
81776: PUSH
81777: LD_INT 2
81779: NEG
81780: PUSH
81781: EMPTY
81782: LIST
81783: LIST
81784: PUSH
81785: LD_INT 0
81787: PUSH
81788: LD_INT 2
81790: NEG
81791: PUSH
81792: EMPTY
81793: LIST
81794: LIST
81795: PUSH
81796: LD_INT 1
81798: PUSH
81799: LD_INT 1
81801: NEG
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 2
81809: PUSH
81810: LD_INT 0
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 2
81819: PUSH
81820: LD_INT 1
81822: PUSH
81823: EMPTY
81824: LIST
81825: LIST
81826: PUSH
81827: LD_INT 2
81829: PUSH
81830: LD_INT 2
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: PUSH
81837: LD_INT 1
81839: PUSH
81840: LD_INT 2
81842: PUSH
81843: EMPTY
81844: LIST
81845: LIST
81846: PUSH
81847: LD_INT 0
81849: PUSH
81850: LD_INT 2
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PUSH
81857: LD_INT 1
81859: NEG
81860: PUSH
81861: LD_INT 1
81863: PUSH
81864: EMPTY
81865: LIST
81866: LIST
81867: PUSH
81868: LD_INT 2
81870: NEG
81871: PUSH
81872: LD_INT 0
81874: PUSH
81875: EMPTY
81876: LIST
81877: LIST
81878: PUSH
81879: LD_INT 2
81881: NEG
81882: PUSH
81883: LD_INT 1
81885: NEG
81886: PUSH
81887: EMPTY
81888: LIST
81889: LIST
81890: PUSH
81891: LD_INT 2
81893: NEG
81894: PUSH
81895: LD_INT 2
81897: NEG
81898: PUSH
81899: EMPTY
81900: LIST
81901: LIST
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: LIST
81907: LIST
81908: LIST
81909: LIST
81910: LIST
81911: LIST
81912: LIST
81913: LIST
81914: LIST
81915: LIST
81916: LIST
81917: LIST
81918: LIST
81919: LIST
81920: LIST
81921: LIST
81922: LIST
81923: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
81924: LD_ADDR_VAR 0 23
81928: PUSH
81929: LD_INT 0
81931: PUSH
81932: LD_INT 0
81934: PUSH
81935: EMPTY
81936: LIST
81937: LIST
81938: PUSH
81939: LD_INT 0
81941: PUSH
81942: LD_INT 1
81944: NEG
81945: PUSH
81946: EMPTY
81947: LIST
81948: LIST
81949: PUSH
81950: LD_INT 1
81952: PUSH
81953: LD_INT 0
81955: PUSH
81956: EMPTY
81957: LIST
81958: LIST
81959: PUSH
81960: LD_INT 1
81962: PUSH
81963: LD_INT 1
81965: PUSH
81966: EMPTY
81967: LIST
81968: LIST
81969: PUSH
81970: LD_INT 0
81972: PUSH
81973: LD_INT 1
81975: PUSH
81976: EMPTY
81977: LIST
81978: LIST
81979: PUSH
81980: LD_INT 1
81982: NEG
81983: PUSH
81984: LD_INT 0
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 1
81993: NEG
81994: PUSH
81995: LD_INT 1
81997: NEG
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: LD_INT 1
82005: NEG
82006: PUSH
82007: LD_INT 2
82009: NEG
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: LD_INT 0
82017: PUSH
82018: LD_INT 2
82020: NEG
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PUSH
82026: LD_INT 1
82028: PUSH
82029: LD_INT 1
82031: NEG
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 2
82039: PUSH
82040: LD_INT 0
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 2
82049: PUSH
82050: LD_INT 1
82052: PUSH
82053: EMPTY
82054: LIST
82055: LIST
82056: PUSH
82057: LD_INT 2
82059: PUSH
82060: LD_INT 2
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PUSH
82067: LD_INT 1
82069: PUSH
82070: LD_INT 2
82072: PUSH
82073: EMPTY
82074: LIST
82075: LIST
82076: PUSH
82077: LD_INT 0
82079: PUSH
82080: LD_INT 2
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 1
82089: NEG
82090: PUSH
82091: LD_INT 1
82093: PUSH
82094: EMPTY
82095: LIST
82096: LIST
82097: PUSH
82098: LD_INT 2
82100: NEG
82101: PUSH
82102: LD_INT 0
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 2
82111: NEG
82112: PUSH
82113: LD_INT 1
82115: NEG
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 2
82123: NEG
82124: PUSH
82125: LD_INT 2
82127: NEG
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 2
82135: NEG
82136: PUSH
82137: LD_INT 3
82139: NEG
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PUSH
82145: LD_INT 1
82147: NEG
82148: PUSH
82149: LD_INT 3
82151: NEG
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PUSH
82157: LD_INT 1
82159: PUSH
82160: LD_INT 2
82162: NEG
82163: PUSH
82164: EMPTY
82165: LIST
82166: LIST
82167: PUSH
82168: LD_INT 2
82170: PUSH
82171: LD_INT 1
82173: NEG
82174: PUSH
82175: EMPTY
82176: LIST
82177: LIST
82178: PUSH
82179: EMPTY
82180: LIST
82181: LIST
82182: LIST
82183: LIST
82184: LIST
82185: LIST
82186: LIST
82187: LIST
82188: LIST
82189: LIST
82190: LIST
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: LIST
82197: LIST
82198: LIST
82199: LIST
82200: LIST
82201: LIST
82202: LIST
82203: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82204: LD_ADDR_VAR 0 24
82208: PUSH
82209: LD_INT 0
82211: PUSH
82212: LD_INT 0
82214: PUSH
82215: EMPTY
82216: LIST
82217: LIST
82218: PUSH
82219: LD_INT 0
82221: PUSH
82222: LD_INT 1
82224: NEG
82225: PUSH
82226: EMPTY
82227: LIST
82228: LIST
82229: PUSH
82230: LD_INT 1
82232: PUSH
82233: LD_INT 0
82235: PUSH
82236: EMPTY
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 1
82242: PUSH
82243: LD_INT 1
82245: PUSH
82246: EMPTY
82247: LIST
82248: LIST
82249: PUSH
82250: LD_INT 0
82252: PUSH
82253: LD_INT 1
82255: PUSH
82256: EMPTY
82257: LIST
82258: LIST
82259: PUSH
82260: LD_INT 1
82262: NEG
82263: PUSH
82264: LD_INT 0
82266: PUSH
82267: EMPTY
82268: LIST
82269: LIST
82270: PUSH
82271: LD_INT 1
82273: NEG
82274: PUSH
82275: LD_INT 1
82277: NEG
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: PUSH
82283: LD_INT 1
82285: NEG
82286: PUSH
82287: LD_INT 2
82289: NEG
82290: PUSH
82291: EMPTY
82292: LIST
82293: LIST
82294: PUSH
82295: LD_INT 0
82297: PUSH
82298: LD_INT 2
82300: NEG
82301: PUSH
82302: EMPTY
82303: LIST
82304: LIST
82305: PUSH
82306: LD_INT 1
82308: PUSH
82309: LD_INT 1
82311: NEG
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: PUSH
82317: LD_INT 2
82319: PUSH
82320: LD_INT 0
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: PUSH
82327: LD_INT 2
82329: PUSH
82330: LD_INT 1
82332: PUSH
82333: EMPTY
82334: LIST
82335: LIST
82336: PUSH
82337: LD_INT 2
82339: PUSH
82340: LD_INT 2
82342: PUSH
82343: EMPTY
82344: LIST
82345: LIST
82346: PUSH
82347: LD_INT 1
82349: PUSH
82350: LD_INT 2
82352: PUSH
82353: EMPTY
82354: LIST
82355: LIST
82356: PUSH
82357: LD_INT 0
82359: PUSH
82360: LD_INT 2
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 1
82369: NEG
82370: PUSH
82371: LD_INT 1
82373: PUSH
82374: EMPTY
82375: LIST
82376: LIST
82377: PUSH
82378: LD_INT 2
82380: NEG
82381: PUSH
82382: LD_INT 0
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: PUSH
82389: LD_INT 2
82391: NEG
82392: PUSH
82393: LD_INT 1
82395: NEG
82396: PUSH
82397: EMPTY
82398: LIST
82399: LIST
82400: PUSH
82401: LD_INT 2
82403: NEG
82404: PUSH
82405: LD_INT 2
82407: NEG
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 1
82415: PUSH
82416: LD_INT 2
82418: NEG
82419: PUSH
82420: EMPTY
82421: LIST
82422: LIST
82423: PUSH
82424: LD_INT 2
82426: PUSH
82427: LD_INT 1
82429: NEG
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: PUSH
82435: LD_INT 3
82437: PUSH
82438: LD_INT 1
82440: PUSH
82441: EMPTY
82442: LIST
82443: LIST
82444: PUSH
82445: LD_INT 3
82447: PUSH
82448: LD_INT 2
82450: PUSH
82451: EMPTY
82452: LIST
82453: LIST
82454: PUSH
82455: EMPTY
82456: LIST
82457: LIST
82458: LIST
82459: LIST
82460: LIST
82461: LIST
82462: LIST
82463: LIST
82464: LIST
82465: LIST
82466: LIST
82467: LIST
82468: LIST
82469: LIST
82470: LIST
82471: LIST
82472: LIST
82473: LIST
82474: LIST
82475: LIST
82476: LIST
82477: LIST
82478: LIST
82479: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
82480: LD_ADDR_VAR 0 25
82484: PUSH
82485: LD_INT 0
82487: PUSH
82488: LD_INT 0
82490: PUSH
82491: EMPTY
82492: LIST
82493: LIST
82494: PUSH
82495: LD_INT 0
82497: PUSH
82498: LD_INT 1
82500: NEG
82501: PUSH
82502: EMPTY
82503: LIST
82504: LIST
82505: PUSH
82506: LD_INT 1
82508: PUSH
82509: LD_INT 0
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: PUSH
82516: LD_INT 1
82518: PUSH
82519: LD_INT 1
82521: PUSH
82522: EMPTY
82523: LIST
82524: LIST
82525: PUSH
82526: LD_INT 0
82528: PUSH
82529: LD_INT 1
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: PUSH
82536: LD_INT 1
82538: NEG
82539: PUSH
82540: LD_INT 0
82542: PUSH
82543: EMPTY
82544: LIST
82545: LIST
82546: PUSH
82547: LD_INT 1
82549: NEG
82550: PUSH
82551: LD_INT 1
82553: NEG
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: PUSH
82559: LD_INT 1
82561: NEG
82562: PUSH
82563: LD_INT 2
82565: NEG
82566: PUSH
82567: EMPTY
82568: LIST
82569: LIST
82570: PUSH
82571: LD_INT 0
82573: PUSH
82574: LD_INT 2
82576: NEG
82577: PUSH
82578: EMPTY
82579: LIST
82580: LIST
82581: PUSH
82582: LD_INT 1
82584: PUSH
82585: LD_INT 1
82587: NEG
82588: PUSH
82589: EMPTY
82590: LIST
82591: LIST
82592: PUSH
82593: LD_INT 2
82595: PUSH
82596: LD_INT 0
82598: PUSH
82599: EMPTY
82600: LIST
82601: LIST
82602: PUSH
82603: LD_INT 2
82605: PUSH
82606: LD_INT 1
82608: PUSH
82609: EMPTY
82610: LIST
82611: LIST
82612: PUSH
82613: LD_INT 2
82615: PUSH
82616: LD_INT 2
82618: PUSH
82619: EMPTY
82620: LIST
82621: LIST
82622: PUSH
82623: LD_INT 1
82625: PUSH
82626: LD_INT 2
82628: PUSH
82629: EMPTY
82630: LIST
82631: LIST
82632: PUSH
82633: LD_INT 0
82635: PUSH
82636: LD_INT 2
82638: PUSH
82639: EMPTY
82640: LIST
82641: LIST
82642: PUSH
82643: LD_INT 1
82645: NEG
82646: PUSH
82647: LD_INT 1
82649: PUSH
82650: EMPTY
82651: LIST
82652: LIST
82653: PUSH
82654: LD_INT 2
82656: NEG
82657: PUSH
82658: LD_INT 0
82660: PUSH
82661: EMPTY
82662: LIST
82663: LIST
82664: PUSH
82665: LD_INT 2
82667: NEG
82668: PUSH
82669: LD_INT 1
82671: NEG
82672: PUSH
82673: EMPTY
82674: LIST
82675: LIST
82676: PUSH
82677: LD_INT 2
82679: NEG
82680: PUSH
82681: LD_INT 2
82683: NEG
82684: PUSH
82685: EMPTY
82686: LIST
82687: LIST
82688: PUSH
82689: LD_INT 3
82691: PUSH
82692: LD_INT 1
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_INT 3
82701: PUSH
82702: LD_INT 2
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: PUSH
82709: LD_INT 2
82711: PUSH
82712: LD_INT 3
82714: PUSH
82715: EMPTY
82716: LIST
82717: LIST
82718: PUSH
82719: LD_INT 1
82721: PUSH
82722: LD_INT 3
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: EMPTY
82730: LIST
82731: LIST
82732: LIST
82733: LIST
82734: LIST
82735: LIST
82736: LIST
82737: LIST
82738: LIST
82739: LIST
82740: LIST
82741: LIST
82742: LIST
82743: LIST
82744: LIST
82745: LIST
82746: LIST
82747: LIST
82748: LIST
82749: LIST
82750: LIST
82751: LIST
82752: LIST
82753: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
82754: LD_ADDR_VAR 0 26
82758: PUSH
82759: LD_INT 0
82761: PUSH
82762: LD_INT 0
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 0
82771: PUSH
82772: LD_INT 1
82774: NEG
82775: PUSH
82776: EMPTY
82777: LIST
82778: LIST
82779: PUSH
82780: LD_INT 1
82782: PUSH
82783: LD_INT 0
82785: PUSH
82786: EMPTY
82787: LIST
82788: LIST
82789: PUSH
82790: LD_INT 1
82792: PUSH
82793: LD_INT 1
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 0
82802: PUSH
82803: LD_INT 1
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 1
82812: NEG
82813: PUSH
82814: LD_INT 0
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 1
82823: NEG
82824: PUSH
82825: LD_INT 1
82827: NEG
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 1
82835: NEG
82836: PUSH
82837: LD_INT 2
82839: NEG
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: LD_INT 0
82847: PUSH
82848: LD_INT 2
82850: NEG
82851: PUSH
82852: EMPTY
82853: LIST
82854: LIST
82855: PUSH
82856: LD_INT 1
82858: PUSH
82859: LD_INT 1
82861: NEG
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 2
82869: PUSH
82870: LD_INT 0
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 2
82879: PUSH
82880: LD_INT 1
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 2
82889: PUSH
82890: LD_INT 2
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 1
82899: PUSH
82900: LD_INT 2
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 0
82909: PUSH
82910: LD_INT 2
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: LD_INT 1
82919: NEG
82920: PUSH
82921: LD_INT 1
82923: PUSH
82924: EMPTY
82925: LIST
82926: LIST
82927: PUSH
82928: LD_INT 2
82930: NEG
82931: PUSH
82932: LD_INT 0
82934: PUSH
82935: EMPTY
82936: LIST
82937: LIST
82938: PUSH
82939: LD_INT 2
82941: NEG
82942: PUSH
82943: LD_INT 1
82945: NEG
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: LD_INT 2
82953: NEG
82954: PUSH
82955: LD_INT 2
82957: NEG
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: PUSH
82963: LD_INT 2
82965: PUSH
82966: LD_INT 3
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: PUSH
82973: LD_INT 1
82975: PUSH
82976: LD_INT 3
82978: PUSH
82979: EMPTY
82980: LIST
82981: LIST
82982: PUSH
82983: LD_INT 1
82985: NEG
82986: PUSH
82987: LD_INT 2
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: PUSH
82994: LD_INT 2
82996: NEG
82997: PUSH
82998: LD_INT 1
83000: PUSH
83001: EMPTY
83002: LIST
83003: LIST
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: LIST
83009: LIST
83010: LIST
83011: LIST
83012: LIST
83013: LIST
83014: LIST
83015: LIST
83016: LIST
83017: LIST
83018: LIST
83019: LIST
83020: LIST
83021: LIST
83022: LIST
83023: LIST
83024: LIST
83025: LIST
83026: LIST
83027: LIST
83028: LIST
83029: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83030: LD_ADDR_VAR 0 27
83034: PUSH
83035: LD_INT 0
83037: PUSH
83038: LD_INT 0
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 0
83047: PUSH
83048: LD_INT 1
83050: NEG
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 1
83058: PUSH
83059: LD_INT 0
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: LD_INT 1
83068: PUSH
83069: LD_INT 1
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 0
83078: PUSH
83079: LD_INT 1
83081: PUSH
83082: EMPTY
83083: LIST
83084: LIST
83085: PUSH
83086: LD_INT 1
83088: NEG
83089: PUSH
83090: LD_INT 0
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 1
83099: NEG
83100: PUSH
83101: LD_INT 1
83103: NEG
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PUSH
83109: LD_INT 1
83111: NEG
83112: PUSH
83113: LD_INT 2
83115: NEG
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PUSH
83121: LD_INT 0
83123: PUSH
83124: LD_INT 2
83126: NEG
83127: PUSH
83128: EMPTY
83129: LIST
83130: LIST
83131: PUSH
83132: LD_INT 1
83134: PUSH
83135: LD_INT 1
83137: NEG
83138: PUSH
83139: EMPTY
83140: LIST
83141: LIST
83142: PUSH
83143: LD_INT 2
83145: PUSH
83146: LD_INT 0
83148: PUSH
83149: EMPTY
83150: LIST
83151: LIST
83152: PUSH
83153: LD_INT 2
83155: PUSH
83156: LD_INT 1
83158: PUSH
83159: EMPTY
83160: LIST
83161: LIST
83162: PUSH
83163: LD_INT 2
83165: PUSH
83166: LD_INT 2
83168: PUSH
83169: EMPTY
83170: LIST
83171: LIST
83172: PUSH
83173: LD_INT 1
83175: PUSH
83176: LD_INT 2
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 0
83185: PUSH
83186: LD_INT 2
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: PUSH
83193: LD_INT 1
83195: NEG
83196: PUSH
83197: LD_INT 1
83199: PUSH
83200: EMPTY
83201: LIST
83202: LIST
83203: PUSH
83204: LD_INT 2
83206: NEG
83207: PUSH
83208: LD_INT 0
83210: PUSH
83211: EMPTY
83212: LIST
83213: LIST
83214: PUSH
83215: LD_INT 2
83217: NEG
83218: PUSH
83219: LD_INT 1
83221: NEG
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: PUSH
83227: LD_INT 2
83229: NEG
83230: PUSH
83231: LD_INT 2
83233: NEG
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 1
83241: NEG
83242: PUSH
83243: LD_INT 2
83245: PUSH
83246: EMPTY
83247: LIST
83248: LIST
83249: PUSH
83250: LD_INT 2
83252: NEG
83253: PUSH
83254: LD_INT 1
83256: PUSH
83257: EMPTY
83258: LIST
83259: LIST
83260: PUSH
83261: LD_INT 3
83263: NEG
83264: PUSH
83265: LD_INT 1
83267: NEG
83268: PUSH
83269: EMPTY
83270: LIST
83271: LIST
83272: PUSH
83273: LD_INT 3
83275: NEG
83276: PUSH
83277: LD_INT 2
83279: NEG
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: EMPTY
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: LIST
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: LIST
83301: LIST
83302: LIST
83303: LIST
83304: LIST
83305: LIST
83306: LIST
83307: LIST
83308: LIST
83309: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83310: LD_ADDR_VAR 0 28
83314: PUSH
83315: LD_INT 0
83317: PUSH
83318: LD_INT 0
83320: PUSH
83321: EMPTY
83322: LIST
83323: LIST
83324: PUSH
83325: LD_INT 0
83327: PUSH
83328: LD_INT 1
83330: NEG
83331: PUSH
83332: EMPTY
83333: LIST
83334: LIST
83335: PUSH
83336: LD_INT 1
83338: PUSH
83339: LD_INT 0
83341: PUSH
83342: EMPTY
83343: LIST
83344: LIST
83345: PUSH
83346: LD_INT 1
83348: PUSH
83349: LD_INT 1
83351: PUSH
83352: EMPTY
83353: LIST
83354: LIST
83355: PUSH
83356: LD_INT 0
83358: PUSH
83359: LD_INT 1
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 1
83368: NEG
83369: PUSH
83370: LD_INT 0
83372: PUSH
83373: EMPTY
83374: LIST
83375: LIST
83376: PUSH
83377: LD_INT 1
83379: NEG
83380: PUSH
83381: LD_INT 1
83383: NEG
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: PUSH
83389: LD_INT 1
83391: NEG
83392: PUSH
83393: LD_INT 2
83395: NEG
83396: PUSH
83397: EMPTY
83398: LIST
83399: LIST
83400: PUSH
83401: LD_INT 0
83403: PUSH
83404: LD_INT 2
83406: NEG
83407: PUSH
83408: EMPTY
83409: LIST
83410: LIST
83411: PUSH
83412: LD_INT 1
83414: PUSH
83415: LD_INT 1
83417: NEG
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: PUSH
83423: LD_INT 2
83425: PUSH
83426: LD_INT 0
83428: PUSH
83429: EMPTY
83430: LIST
83431: LIST
83432: PUSH
83433: LD_INT 2
83435: PUSH
83436: LD_INT 1
83438: PUSH
83439: EMPTY
83440: LIST
83441: LIST
83442: PUSH
83443: LD_INT 2
83445: PUSH
83446: LD_INT 2
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: PUSH
83453: LD_INT 1
83455: PUSH
83456: LD_INT 2
83458: PUSH
83459: EMPTY
83460: LIST
83461: LIST
83462: PUSH
83463: LD_INT 0
83465: PUSH
83466: LD_INT 2
83468: PUSH
83469: EMPTY
83470: LIST
83471: LIST
83472: PUSH
83473: LD_INT 1
83475: NEG
83476: PUSH
83477: LD_INT 1
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 2
83486: NEG
83487: PUSH
83488: LD_INT 0
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 2
83497: NEG
83498: PUSH
83499: LD_INT 1
83501: NEG
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PUSH
83507: LD_INT 2
83509: NEG
83510: PUSH
83511: LD_INT 2
83513: NEG
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: LD_INT 2
83521: NEG
83522: PUSH
83523: LD_INT 3
83525: NEG
83526: PUSH
83527: EMPTY
83528: LIST
83529: LIST
83530: PUSH
83531: LD_INT 1
83533: NEG
83534: PUSH
83535: LD_INT 3
83537: NEG
83538: PUSH
83539: EMPTY
83540: LIST
83541: LIST
83542: PUSH
83543: LD_INT 3
83545: NEG
83546: PUSH
83547: LD_INT 1
83549: NEG
83550: PUSH
83551: EMPTY
83552: LIST
83553: LIST
83554: PUSH
83555: LD_INT 3
83557: NEG
83558: PUSH
83559: LD_INT 2
83561: NEG
83562: PUSH
83563: EMPTY
83564: LIST
83565: LIST
83566: PUSH
83567: EMPTY
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: LIST
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: LIST
83589: LIST
83590: LIST
83591: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83592: LD_ADDR_VAR 0 29
83596: PUSH
83597: LD_INT 0
83599: PUSH
83600: LD_INT 0
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: PUSH
83607: LD_INT 0
83609: PUSH
83610: LD_INT 1
83612: NEG
83613: PUSH
83614: EMPTY
83615: LIST
83616: LIST
83617: PUSH
83618: LD_INT 1
83620: PUSH
83621: LD_INT 0
83623: PUSH
83624: EMPTY
83625: LIST
83626: LIST
83627: PUSH
83628: LD_INT 1
83630: PUSH
83631: LD_INT 1
83633: PUSH
83634: EMPTY
83635: LIST
83636: LIST
83637: PUSH
83638: LD_INT 0
83640: PUSH
83641: LD_INT 1
83643: PUSH
83644: EMPTY
83645: LIST
83646: LIST
83647: PUSH
83648: LD_INT 1
83650: NEG
83651: PUSH
83652: LD_INT 0
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 1
83661: NEG
83662: PUSH
83663: LD_INT 1
83665: NEG
83666: PUSH
83667: EMPTY
83668: LIST
83669: LIST
83670: PUSH
83671: LD_INT 1
83673: NEG
83674: PUSH
83675: LD_INT 2
83677: NEG
83678: PUSH
83679: EMPTY
83680: LIST
83681: LIST
83682: PUSH
83683: LD_INT 0
83685: PUSH
83686: LD_INT 2
83688: NEG
83689: PUSH
83690: EMPTY
83691: LIST
83692: LIST
83693: PUSH
83694: LD_INT 1
83696: PUSH
83697: LD_INT 1
83699: NEG
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: PUSH
83705: LD_INT 2
83707: PUSH
83708: LD_INT 0
83710: PUSH
83711: EMPTY
83712: LIST
83713: LIST
83714: PUSH
83715: LD_INT 2
83717: PUSH
83718: LD_INT 1
83720: PUSH
83721: EMPTY
83722: LIST
83723: LIST
83724: PUSH
83725: LD_INT 1
83727: PUSH
83728: LD_INT 2
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: PUSH
83735: LD_INT 0
83737: PUSH
83738: LD_INT 2
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PUSH
83745: LD_INT 1
83747: NEG
83748: PUSH
83749: LD_INT 1
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 2
83758: NEG
83759: PUSH
83760: LD_INT 1
83762: NEG
83763: PUSH
83764: EMPTY
83765: LIST
83766: LIST
83767: PUSH
83768: LD_INT 2
83770: NEG
83771: PUSH
83772: LD_INT 2
83774: NEG
83775: PUSH
83776: EMPTY
83777: LIST
83778: LIST
83779: PUSH
83780: LD_INT 2
83782: NEG
83783: PUSH
83784: LD_INT 3
83786: NEG
83787: PUSH
83788: EMPTY
83789: LIST
83790: LIST
83791: PUSH
83792: LD_INT 2
83794: PUSH
83795: LD_INT 1
83797: NEG
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 3
83805: PUSH
83806: LD_INT 1
83808: PUSH
83809: EMPTY
83810: LIST
83811: LIST
83812: PUSH
83813: LD_INT 1
83815: PUSH
83816: LD_INT 3
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: PUSH
83823: LD_INT 1
83825: NEG
83826: PUSH
83827: LD_INT 2
83829: PUSH
83830: EMPTY
83831: LIST
83832: LIST
83833: PUSH
83834: LD_INT 3
83836: NEG
83837: PUSH
83838: LD_INT 2
83840: NEG
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PUSH
83846: EMPTY
83847: LIST
83848: LIST
83849: LIST
83850: LIST
83851: LIST
83852: LIST
83853: LIST
83854: LIST
83855: LIST
83856: LIST
83857: LIST
83858: LIST
83859: LIST
83860: LIST
83861: LIST
83862: LIST
83863: LIST
83864: LIST
83865: LIST
83866: LIST
83867: LIST
83868: LIST
83869: LIST
83870: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83871: LD_ADDR_VAR 0 30
83875: PUSH
83876: LD_INT 0
83878: PUSH
83879: LD_INT 0
83881: PUSH
83882: EMPTY
83883: LIST
83884: LIST
83885: PUSH
83886: LD_INT 0
83888: PUSH
83889: LD_INT 1
83891: NEG
83892: PUSH
83893: EMPTY
83894: LIST
83895: LIST
83896: PUSH
83897: LD_INT 1
83899: PUSH
83900: LD_INT 0
83902: PUSH
83903: EMPTY
83904: LIST
83905: LIST
83906: PUSH
83907: LD_INT 1
83909: PUSH
83910: LD_INT 1
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: PUSH
83917: LD_INT 0
83919: PUSH
83920: LD_INT 1
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: PUSH
83927: LD_INT 1
83929: NEG
83930: PUSH
83931: LD_INT 0
83933: PUSH
83934: EMPTY
83935: LIST
83936: LIST
83937: PUSH
83938: LD_INT 1
83940: NEG
83941: PUSH
83942: LD_INT 1
83944: NEG
83945: PUSH
83946: EMPTY
83947: LIST
83948: LIST
83949: PUSH
83950: LD_INT 1
83952: NEG
83953: PUSH
83954: LD_INT 2
83956: NEG
83957: PUSH
83958: EMPTY
83959: LIST
83960: LIST
83961: PUSH
83962: LD_INT 0
83964: PUSH
83965: LD_INT 2
83967: NEG
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PUSH
83973: LD_INT 1
83975: PUSH
83976: LD_INT 1
83978: NEG
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: PUSH
83984: LD_INT 2
83986: PUSH
83987: LD_INT 0
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 2
83996: PUSH
83997: LD_INT 1
83999: PUSH
84000: EMPTY
84001: LIST
84002: LIST
84003: PUSH
84004: LD_INT 2
84006: PUSH
84007: LD_INT 2
84009: PUSH
84010: EMPTY
84011: LIST
84012: LIST
84013: PUSH
84014: LD_INT 1
84016: PUSH
84017: LD_INT 2
84019: PUSH
84020: EMPTY
84021: LIST
84022: LIST
84023: PUSH
84024: LD_INT 1
84026: NEG
84027: PUSH
84028: LD_INT 1
84030: PUSH
84031: EMPTY
84032: LIST
84033: LIST
84034: PUSH
84035: LD_INT 2
84037: NEG
84038: PUSH
84039: LD_INT 0
84041: PUSH
84042: EMPTY
84043: LIST
84044: LIST
84045: PUSH
84046: LD_INT 2
84048: NEG
84049: PUSH
84050: LD_INT 1
84052: NEG
84053: PUSH
84054: EMPTY
84055: LIST
84056: LIST
84057: PUSH
84058: LD_INT 1
84060: NEG
84061: PUSH
84062: LD_INT 3
84064: NEG
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: PUSH
84070: LD_INT 1
84072: PUSH
84073: LD_INT 2
84075: NEG
84076: PUSH
84077: EMPTY
84078: LIST
84079: LIST
84080: PUSH
84081: LD_INT 3
84083: PUSH
84084: LD_INT 2
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 2
84093: PUSH
84094: LD_INT 3
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PUSH
84101: LD_INT 2
84103: NEG
84104: PUSH
84105: LD_INT 1
84107: PUSH
84108: EMPTY
84109: LIST
84110: LIST
84111: PUSH
84112: LD_INT 3
84114: NEG
84115: PUSH
84116: LD_INT 1
84118: NEG
84119: PUSH
84120: EMPTY
84121: LIST
84122: LIST
84123: PUSH
84124: EMPTY
84125: LIST
84126: LIST
84127: LIST
84128: LIST
84129: LIST
84130: LIST
84131: LIST
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84149: LD_ADDR_VAR 0 31
84153: PUSH
84154: LD_INT 0
84156: PUSH
84157: LD_INT 0
84159: PUSH
84160: EMPTY
84161: LIST
84162: LIST
84163: PUSH
84164: LD_INT 0
84166: PUSH
84167: LD_INT 1
84169: NEG
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: PUSH
84175: LD_INT 1
84177: PUSH
84178: LD_INT 0
84180: PUSH
84181: EMPTY
84182: LIST
84183: LIST
84184: PUSH
84185: LD_INT 1
84187: PUSH
84188: LD_INT 1
84190: PUSH
84191: EMPTY
84192: LIST
84193: LIST
84194: PUSH
84195: LD_INT 0
84197: PUSH
84198: LD_INT 1
84200: PUSH
84201: EMPTY
84202: LIST
84203: LIST
84204: PUSH
84205: LD_INT 1
84207: NEG
84208: PUSH
84209: LD_INT 0
84211: PUSH
84212: EMPTY
84213: LIST
84214: LIST
84215: PUSH
84216: LD_INT 1
84218: NEG
84219: PUSH
84220: LD_INT 1
84222: NEG
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PUSH
84228: LD_INT 1
84230: NEG
84231: PUSH
84232: LD_INT 2
84234: NEG
84235: PUSH
84236: EMPTY
84237: LIST
84238: LIST
84239: PUSH
84240: LD_INT 1
84242: PUSH
84243: LD_INT 1
84245: NEG
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: PUSH
84251: LD_INT 2
84253: PUSH
84254: LD_INT 0
84256: PUSH
84257: EMPTY
84258: LIST
84259: LIST
84260: PUSH
84261: LD_INT 2
84263: PUSH
84264: LD_INT 1
84266: PUSH
84267: EMPTY
84268: LIST
84269: LIST
84270: PUSH
84271: LD_INT 2
84273: PUSH
84274: LD_INT 2
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: PUSH
84281: LD_INT 1
84283: PUSH
84284: LD_INT 2
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: PUSH
84291: LD_INT 0
84293: PUSH
84294: LD_INT 2
84296: PUSH
84297: EMPTY
84298: LIST
84299: LIST
84300: PUSH
84301: LD_INT 1
84303: NEG
84304: PUSH
84305: LD_INT 1
84307: PUSH
84308: EMPTY
84309: LIST
84310: LIST
84311: PUSH
84312: LD_INT 2
84314: NEG
84315: PUSH
84316: LD_INT 1
84318: NEG
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: PUSH
84324: LD_INT 2
84326: NEG
84327: PUSH
84328: LD_INT 2
84330: NEG
84331: PUSH
84332: EMPTY
84333: LIST
84334: LIST
84335: PUSH
84336: LD_INT 2
84338: NEG
84339: PUSH
84340: LD_INT 3
84342: NEG
84343: PUSH
84344: EMPTY
84345: LIST
84346: LIST
84347: PUSH
84348: LD_INT 2
84350: PUSH
84351: LD_INT 1
84353: NEG
84354: PUSH
84355: EMPTY
84356: LIST
84357: LIST
84358: PUSH
84359: LD_INT 3
84361: PUSH
84362: LD_INT 1
84364: PUSH
84365: EMPTY
84366: LIST
84367: LIST
84368: PUSH
84369: LD_INT 1
84371: PUSH
84372: LD_INT 3
84374: PUSH
84375: EMPTY
84376: LIST
84377: LIST
84378: PUSH
84379: LD_INT 1
84381: NEG
84382: PUSH
84383: LD_INT 2
84385: PUSH
84386: EMPTY
84387: LIST
84388: LIST
84389: PUSH
84390: LD_INT 3
84392: NEG
84393: PUSH
84394: LD_INT 2
84396: NEG
84397: PUSH
84398: EMPTY
84399: LIST
84400: LIST
84401: PUSH
84402: EMPTY
84403: LIST
84404: LIST
84405: LIST
84406: LIST
84407: LIST
84408: LIST
84409: LIST
84410: LIST
84411: LIST
84412: LIST
84413: LIST
84414: LIST
84415: LIST
84416: LIST
84417: LIST
84418: LIST
84419: LIST
84420: LIST
84421: LIST
84422: LIST
84423: LIST
84424: LIST
84425: LIST
84426: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84427: LD_ADDR_VAR 0 32
84431: PUSH
84432: LD_INT 0
84434: PUSH
84435: LD_INT 0
84437: PUSH
84438: EMPTY
84439: LIST
84440: LIST
84441: PUSH
84442: LD_INT 0
84444: PUSH
84445: LD_INT 1
84447: NEG
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: PUSH
84453: LD_INT 1
84455: PUSH
84456: LD_INT 0
84458: PUSH
84459: EMPTY
84460: LIST
84461: LIST
84462: PUSH
84463: LD_INT 1
84465: PUSH
84466: LD_INT 1
84468: PUSH
84469: EMPTY
84470: LIST
84471: LIST
84472: PUSH
84473: LD_INT 0
84475: PUSH
84476: LD_INT 1
84478: PUSH
84479: EMPTY
84480: LIST
84481: LIST
84482: PUSH
84483: LD_INT 1
84485: NEG
84486: PUSH
84487: LD_INT 0
84489: PUSH
84490: EMPTY
84491: LIST
84492: LIST
84493: PUSH
84494: LD_INT 1
84496: NEG
84497: PUSH
84498: LD_INT 1
84500: NEG
84501: PUSH
84502: EMPTY
84503: LIST
84504: LIST
84505: PUSH
84506: LD_INT 1
84508: NEG
84509: PUSH
84510: LD_INT 2
84512: NEG
84513: PUSH
84514: EMPTY
84515: LIST
84516: LIST
84517: PUSH
84518: LD_INT 0
84520: PUSH
84521: LD_INT 2
84523: NEG
84524: PUSH
84525: EMPTY
84526: LIST
84527: LIST
84528: PUSH
84529: LD_INT 1
84531: PUSH
84532: LD_INT 1
84534: NEG
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: PUSH
84540: LD_INT 2
84542: PUSH
84543: LD_INT 1
84545: PUSH
84546: EMPTY
84547: LIST
84548: LIST
84549: PUSH
84550: LD_INT 2
84552: PUSH
84553: LD_INT 2
84555: PUSH
84556: EMPTY
84557: LIST
84558: LIST
84559: PUSH
84560: LD_INT 1
84562: PUSH
84563: LD_INT 2
84565: PUSH
84566: EMPTY
84567: LIST
84568: LIST
84569: PUSH
84570: LD_INT 0
84572: PUSH
84573: LD_INT 2
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: PUSH
84580: LD_INT 1
84582: NEG
84583: PUSH
84584: LD_INT 1
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: PUSH
84591: LD_INT 2
84593: NEG
84594: PUSH
84595: LD_INT 0
84597: PUSH
84598: EMPTY
84599: LIST
84600: LIST
84601: PUSH
84602: LD_INT 2
84604: NEG
84605: PUSH
84606: LD_INT 1
84608: NEG
84609: PUSH
84610: EMPTY
84611: LIST
84612: LIST
84613: PUSH
84614: LD_INT 1
84616: NEG
84617: PUSH
84618: LD_INT 3
84620: NEG
84621: PUSH
84622: EMPTY
84623: LIST
84624: LIST
84625: PUSH
84626: LD_INT 1
84628: PUSH
84629: LD_INT 2
84631: NEG
84632: PUSH
84633: EMPTY
84634: LIST
84635: LIST
84636: PUSH
84637: LD_INT 3
84639: PUSH
84640: LD_INT 2
84642: PUSH
84643: EMPTY
84644: LIST
84645: LIST
84646: PUSH
84647: LD_INT 2
84649: PUSH
84650: LD_INT 3
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: PUSH
84657: LD_INT 2
84659: NEG
84660: PUSH
84661: LD_INT 1
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: PUSH
84668: LD_INT 3
84670: NEG
84671: PUSH
84672: LD_INT 1
84674: NEG
84675: PUSH
84676: EMPTY
84677: LIST
84678: LIST
84679: PUSH
84680: EMPTY
84681: LIST
84682: LIST
84683: LIST
84684: LIST
84685: LIST
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: LIST
84691: LIST
84692: LIST
84693: LIST
84694: LIST
84695: LIST
84696: LIST
84697: LIST
84698: LIST
84699: LIST
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84705: LD_ADDR_VAR 0 33
84709: PUSH
84710: LD_INT 0
84712: PUSH
84713: LD_INT 0
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 0
84722: PUSH
84723: LD_INT 1
84725: NEG
84726: PUSH
84727: EMPTY
84728: LIST
84729: LIST
84730: PUSH
84731: LD_INT 1
84733: PUSH
84734: LD_INT 0
84736: PUSH
84737: EMPTY
84738: LIST
84739: LIST
84740: PUSH
84741: LD_INT 1
84743: PUSH
84744: LD_INT 1
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: PUSH
84751: LD_INT 0
84753: PUSH
84754: LD_INT 1
84756: PUSH
84757: EMPTY
84758: LIST
84759: LIST
84760: PUSH
84761: LD_INT 1
84763: NEG
84764: PUSH
84765: LD_INT 0
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: PUSH
84772: LD_INT 1
84774: NEG
84775: PUSH
84776: LD_INT 1
84778: NEG
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 1
84786: NEG
84787: PUSH
84788: LD_INT 2
84790: NEG
84791: PUSH
84792: EMPTY
84793: LIST
84794: LIST
84795: PUSH
84796: LD_INT 1
84798: PUSH
84799: LD_INT 1
84801: NEG
84802: PUSH
84803: EMPTY
84804: LIST
84805: LIST
84806: PUSH
84807: LD_INT 2
84809: PUSH
84810: LD_INT 0
84812: PUSH
84813: EMPTY
84814: LIST
84815: LIST
84816: PUSH
84817: LD_INT 2
84819: PUSH
84820: LD_INT 1
84822: PUSH
84823: EMPTY
84824: LIST
84825: LIST
84826: PUSH
84827: LD_INT 1
84829: PUSH
84830: LD_INT 2
84832: PUSH
84833: EMPTY
84834: LIST
84835: LIST
84836: PUSH
84837: LD_INT 0
84839: PUSH
84840: LD_INT 2
84842: PUSH
84843: EMPTY
84844: LIST
84845: LIST
84846: PUSH
84847: LD_INT 1
84849: NEG
84850: PUSH
84851: LD_INT 1
84853: PUSH
84854: EMPTY
84855: LIST
84856: LIST
84857: PUSH
84858: LD_INT 2
84860: NEG
84861: PUSH
84862: LD_INT 0
84864: PUSH
84865: EMPTY
84866: LIST
84867: LIST
84868: PUSH
84869: LD_INT 2
84871: NEG
84872: PUSH
84873: LD_INT 1
84875: NEG
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PUSH
84881: LD_INT 2
84883: NEG
84884: PUSH
84885: LD_INT 2
84887: NEG
84888: PUSH
84889: EMPTY
84890: LIST
84891: LIST
84892: PUSH
84893: LD_INT 2
84895: NEG
84896: PUSH
84897: LD_INT 3
84899: NEG
84900: PUSH
84901: EMPTY
84902: LIST
84903: LIST
84904: PUSH
84905: LD_INT 2
84907: PUSH
84908: LD_INT 1
84910: NEG
84911: PUSH
84912: EMPTY
84913: LIST
84914: LIST
84915: PUSH
84916: LD_INT 3
84918: PUSH
84919: LD_INT 1
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 1
84928: PUSH
84929: LD_INT 3
84931: PUSH
84932: EMPTY
84933: LIST
84934: LIST
84935: PUSH
84936: LD_INT 1
84938: NEG
84939: PUSH
84940: LD_INT 2
84942: PUSH
84943: EMPTY
84944: LIST
84945: LIST
84946: PUSH
84947: LD_INT 3
84949: NEG
84950: PUSH
84951: LD_INT 2
84953: NEG
84954: PUSH
84955: EMPTY
84956: LIST
84957: LIST
84958: PUSH
84959: EMPTY
84960: LIST
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: LIST
84971: LIST
84972: LIST
84973: LIST
84974: LIST
84975: LIST
84976: LIST
84977: LIST
84978: LIST
84979: LIST
84980: LIST
84981: LIST
84982: LIST
84983: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84984: LD_ADDR_VAR 0 34
84988: PUSH
84989: LD_INT 0
84991: PUSH
84992: LD_INT 0
84994: PUSH
84995: EMPTY
84996: LIST
84997: LIST
84998: PUSH
84999: LD_INT 0
85001: PUSH
85002: LD_INT 1
85004: NEG
85005: PUSH
85006: EMPTY
85007: LIST
85008: LIST
85009: PUSH
85010: LD_INT 1
85012: PUSH
85013: LD_INT 0
85015: PUSH
85016: EMPTY
85017: LIST
85018: LIST
85019: PUSH
85020: LD_INT 1
85022: PUSH
85023: LD_INT 1
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_INT 0
85032: PUSH
85033: LD_INT 1
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PUSH
85040: LD_INT 1
85042: NEG
85043: PUSH
85044: LD_INT 0
85046: PUSH
85047: EMPTY
85048: LIST
85049: LIST
85050: PUSH
85051: LD_INT 1
85053: NEG
85054: PUSH
85055: LD_INT 1
85057: NEG
85058: PUSH
85059: EMPTY
85060: LIST
85061: LIST
85062: PUSH
85063: LD_INT 1
85065: NEG
85066: PUSH
85067: LD_INT 2
85069: NEG
85070: PUSH
85071: EMPTY
85072: LIST
85073: LIST
85074: PUSH
85075: LD_INT 0
85077: PUSH
85078: LD_INT 2
85080: NEG
85081: PUSH
85082: EMPTY
85083: LIST
85084: LIST
85085: PUSH
85086: LD_INT 1
85088: PUSH
85089: LD_INT 1
85091: NEG
85092: PUSH
85093: EMPTY
85094: LIST
85095: LIST
85096: PUSH
85097: LD_INT 2
85099: PUSH
85100: LD_INT 1
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: PUSH
85107: LD_INT 2
85109: PUSH
85110: LD_INT 2
85112: PUSH
85113: EMPTY
85114: LIST
85115: LIST
85116: PUSH
85117: LD_INT 1
85119: PUSH
85120: LD_INT 2
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: PUSH
85127: LD_INT 1
85129: NEG
85130: PUSH
85131: LD_INT 1
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: PUSH
85138: LD_INT 2
85140: NEG
85141: PUSH
85142: LD_INT 0
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_INT 2
85151: NEG
85152: PUSH
85153: LD_INT 1
85155: NEG
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 2
85163: NEG
85164: PUSH
85165: LD_INT 2
85167: NEG
85168: PUSH
85169: EMPTY
85170: LIST
85171: LIST
85172: PUSH
85173: LD_INT 1
85175: NEG
85176: PUSH
85177: LD_INT 3
85179: NEG
85180: PUSH
85181: EMPTY
85182: LIST
85183: LIST
85184: PUSH
85185: LD_INT 1
85187: PUSH
85188: LD_INT 2
85190: NEG
85191: PUSH
85192: EMPTY
85193: LIST
85194: LIST
85195: PUSH
85196: LD_INT 3
85198: PUSH
85199: LD_INT 2
85201: PUSH
85202: EMPTY
85203: LIST
85204: LIST
85205: PUSH
85206: LD_INT 2
85208: PUSH
85209: LD_INT 3
85211: PUSH
85212: EMPTY
85213: LIST
85214: LIST
85215: PUSH
85216: LD_INT 2
85218: NEG
85219: PUSH
85220: LD_INT 1
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: PUSH
85227: LD_INT 3
85229: NEG
85230: PUSH
85231: LD_INT 1
85233: NEG
85234: PUSH
85235: EMPTY
85236: LIST
85237: LIST
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: LIST
85243: LIST
85244: LIST
85245: LIST
85246: LIST
85247: LIST
85248: LIST
85249: LIST
85250: LIST
85251: LIST
85252: LIST
85253: LIST
85254: LIST
85255: LIST
85256: LIST
85257: LIST
85258: LIST
85259: LIST
85260: LIST
85261: LIST
85262: LIST
85263: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85264: LD_ADDR_VAR 0 35
85268: PUSH
85269: LD_INT 0
85271: PUSH
85272: LD_INT 0
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 0
85281: PUSH
85282: LD_INT 1
85284: NEG
85285: PUSH
85286: EMPTY
85287: LIST
85288: LIST
85289: PUSH
85290: LD_INT 1
85292: PUSH
85293: LD_INT 0
85295: PUSH
85296: EMPTY
85297: LIST
85298: LIST
85299: PUSH
85300: LD_INT 1
85302: PUSH
85303: LD_INT 1
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PUSH
85310: LD_INT 0
85312: PUSH
85313: LD_INT 1
85315: PUSH
85316: EMPTY
85317: LIST
85318: LIST
85319: PUSH
85320: LD_INT 1
85322: NEG
85323: PUSH
85324: LD_INT 0
85326: PUSH
85327: EMPTY
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 1
85333: NEG
85334: PUSH
85335: LD_INT 1
85337: NEG
85338: PUSH
85339: EMPTY
85340: LIST
85341: LIST
85342: PUSH
85343: LD_INT 2
85345: PUSH
85346: LD_INT 1
85348: PUSH
85349: EMPTY
85350: LIST
85351: LIST
85352: PUSH
85353: LD_INT 2
85355: NEG
85356: PUSH
85357: LD_INT 1
85359: NEG
85360: PUSH
85361: EMPTY
85362: LIST
85363: LIST
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: LIST
85369: LIST
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85376: LD_ADDR_VAR 0 36
85380: PUSH
85381: LD_INT 0
85383: PUSH
85384: LD_INT 0
85386: PUSH
85387: EMPTY
85388: LIST
85389: LIST
85390: PUSH
85391: LD_INT 0
85393: PUSH
85394: LD_INT 1
85396: NEG
85397: PUSH
85398: EMPTY
85399: LIST
85400: LIST
85401: PUSH
85402: LD_INT 1
85404: PUSH
85405: LD_INT 0
85407: PUSH
85408: EMPTY
85409: LIST
85410: LIST
85411: PUSH
85412: LD_INT 1
85414: PUSH
85415: LD_INT 1
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: PUSH
85422: LD_INT 0
85424: PUSH
85425: LD_INT 1
85427: PUSH
85428: EMPTY
85429: LIST
85430: LIST
85431: PUSH
85432: LD_INT 1
85434: NEG
85435: PUSH
85436: LD_INT 0
85438: PUSH
85439: EMPTY
85440: LIST
85441: LIST
85442: PUSH
85443: LD_INT 1
85445: NEG
85446: PUSH
85447: LD_INT 1
85449: NEG
85450: PUSH
85451: EMPTY
85452: LIST
85453: LIST
85454: PUSH
85455: LD_INT 1
85457: NEG
85458: PUSH
85459: LD_INT 2
85461: NEG
85462: PUSH
85463: EMPTY
85464: LIST
85465: LIST
85466: PUSH
85467: LD_INT 1
85469: PUSH
85470: LD_INT 2
85472: PUSH
85473: EMPTY
85474: LIST
85475: LIST
85476: PUSH
85477: EMPTY
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85488: LD_ADDR_VAR 0 37
85492: PUSH
85493: LD_INT 0
85495: PUSH
85496: LD_INT 0
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PUSH
85503: LD_INT 0
85505: PUSH
85506: LD_INT 1
85508: NEG
85509: PUSH
85510: EMPTY
85511: LIST
85512: LIST
85513: PUSH
85514: LD_INT 1
85516: PUSH
85517: LD_INT 0
85519: PUSH
85520: EMPTY
85521: LIST
85522: LIST
85523: PUSH
85524: LD_INT 1
85526: PUSH
85527: LD_INT 1
85529: PUSH
85530: EMPTY
85531: LIST
85532: LIST
85533: PUSH
85534: LD_INT 0
85536: PUSH
85537: LD_INT 1
85539: PUSH
85540: EMPTY
85541: LIST
85542: LIST
85543: PUSH
85544: LD_INT 1
85546: NEG
85547: PUSH
85548: LD_INT 0
85550: PUSH
85551: EMPTY
85552: LIST
85553: LIST
85554: PUSH
85555: LD_INT 1
85557: NEG
85558: PUSH
85559: LD_INT 1
85561: NEG
85562: PUSH
85563: EMPTY
85564: LIST
85565: LIST
85566: PUSH
85567: LD_INT 1
85569: PUSH
85570: LD_INT 1
85572: NEG
85573: PUSH
85574: EMPTY
85575: LIST
85576: LIST
85577: PUSH
85578: LD_INT 1
85580: NEG
85581: PUSH
85582: LD_INT 1
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: PUSH
85589: EMPTY
85590: LIST
85591: LIST
85592: LIST
85593: LIST
85594: LIST
85595: LIST
85596: LIST
85597: LIST
85598: LIST
85599: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85600: LD_ADDR_VAR 0 38
85604: PUSH
85605: LD_INT 0
85607: PUSH
85608: LD_INT 0
85610: PUSH
85611: EMPTY
85612: LIST
85613: LIST
85614: PUSH
85615: LD_INT 0
85617: PUSH
85618: LD_INT 1
85620: NEG
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: PUSH
85626: LD_INT 1
85628: PUSH
85629: LD_INT 0
85631: PUSH
85632: EMPTY
85633: LIST
85634: LIST
85635: PUSH
85636: LD_INT 1
85638: PUSH
85639: LD_INT 1
85641: PUSH
85642: EMPTY
85643: LIST
85644: LIST
85645: PUSH
85646: LD_INT 0
85648: PUSH
85649: LD_INT 1
85651: PUSH
85652: EMPTY
85653: LIST
85654: LIST
85655: PUSH
85656: LD_INT 1
85658: NEG
85659: PUSH
85660: LD_INT 0
85662: PUSH
85663: EMPTY
85664: LIST
85665: LIST
85666: PUSH
85667: LD_INT 1
85669: NEG
85670: PUSH
85671: LD_INT 1
85673: NEG
85674: PUSH
85675: EMPTY
85676: LIST
85677: LIST
85678: PUSH
85679: LD_INT 2
85681: PUSH
85682: LD_INT 1
85684: PUSH
85685: EMPTY
85686: LIST
85687: LIST
85688: PUSH
85689: LD_INT 2
85691: NEG
85692: PUSH
85693: LD_INT 1
85695: NEG
85696: PUSH
85697: EMPTY
85698: LIST
85699: LIST
85700: PUSH
85701: EMPTY
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85712: LD_ADDR_VAR 0 39
85716: PUSH
85717: LD_INT 0
85719: PUSH
85720: LD_INT 0
85722: PUSH
85723: EMPTY
85724: LIST
85725: LIST
85726: PUSH
85727: LD_INT 0
85729: PUSH
85730: LD_INT 1
85732: NEG
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 1
85740: PUSH
85741: LD_INT 0
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 1
85750: PUSH
85751: LD_INT 1
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 0
85760: PUSH
85761: LD_INT 1
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: LD_INT 1
85770: NEG
85771: PUSH
85772: LD_INT 0
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 1
85781: NEG
85782: PUSH
85783: LD_INT 1
85785: NEG
85786: PUSH
85787: EMPTY
85788: LIST
85789: LIST
85790: PUSH
85791: LD_INT 1
85793: NEG
85794: PUSH
85795: LD_INT 2
85797: NEG
85798: PUSH
85799: EMPTY
85800: LIST
85801: LIST
85802: PUSH
85803: LD_INT 1
85805: PUSH
85806: LD_INT 2
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: PUSH
85813: EMPTY
85814: LIST
85815: LIST
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: LIST
85823: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85824: LD_ADDR_VAR 0 40
85828: PUSH
85829: LD_INT 0
85831: PUSH
85832: LD_INT 0
85834: PUSH
85835: EMPTY
85836: LIST
85837: LIST
85838: PUSH
85839: LD_INT 0
85841: PUSH
85842: LD_INT 1
85844: NEG
85845: PUSH
85846: EMPTY
85847: LIST
85848: LIST
85849: PUSH
85850: LD_INT 1
85852: PUSH
85853: LD_INT 0
85855: PUSH
85856: EMPTY
85857: LIST
85858: LIST
85859: PUSH
85860: LD_INT 1
85862: PUSH
85863: LD_INT 1
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PUSH
85870: LD_INT 0
85872: PUSH
85873: LD_INT 1
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: PUSH
85880: LD_INT 1
85882: NEG
85883: PUSH
85884: LD_INT 0
85886: PUSH
85887: EMPTY
85888: LIST
85889: LIST
85890: PUSH
85891: LD_INT 1
85893: NEG
85894: PUSH
85895: LD_INT 1
85897: NEG
85898: PUSH
85899: EMPTY
85900: LIST
85901: LIST
85902: PUSH
85903: LD_INT 1
85905: PUSH
85906: LD_INT 1
85908: NEG
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: LD_INT 1
85916: NEG
85917: PUSH
85918: LD_INT 1
85920: PUSH
85921: EMPTY
85922: LIST
85923: LIST
85924: PUSH
85925: EMPTY
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85936: LD_ADDR_VAR 0 41
85940: PUSH
85941: LD_INT 0
85943: PUSH
85944: LD_INT 0
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 0
85953: PUSH
85954: LD_INT 1
85956: NEG
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: PUSH
85962: LD_INT 1
85964: PUSH
85965: LD_INT 0
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 1
85974: PUSH
85975: LD_INT 1
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 0
85984: PUSH
85985: LD_INT 1
85987: PUSH
85988: EMPTY
85989: LIST
85990: LIST
85991: PUSH
85992: LD_INT 1
85994: NEG
85995: PUSH
85996: LD_INT 0
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: LD_INT 1
86005: NEG
86006: PUSH
86007: LD_INT 1
86009: NEG
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 1
86017: NEG
86018: PUSH
86019: LD_INT 2
86021: NEG
86022: PUSH
86023: EMPTY
86024: LIST
86025: LIST
86026: PUSH
86027: LD_INT 1
86029: PUSH
86030: LD_INT 1
86032: NEG
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PUSH
86038: LD_INT 2
86040: PUSH
86041: LD_INT 0
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: LD_INT 2
86050: PUSH
86051: LD_INT 1
86053: PUSH
86054: EMPTY
86055: LIST
86056: LIST
86057: PUSH
86058: LD_INT 2
86060: PUSH
86061: LD_INT 2
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: PUSH
86068: LD_INT 1
86070: PUSH
86071: LD_INT 2
86073: PUSH
86074: EMPTY
86075: LIST
86076: LIST
86077: PUSH
86078: LD_INT 1
86080: NEG
86081: PUSH
86082: LD_INT 1
86084: PUSH
86085: EMPTY
86086: LIST
86087: LIST
86088: PUSH
86089: LD_INT 2
86091: NEG
86092: PUSH
86093: LD_INT 0
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 2
86102: NEG
86103: PUSH
86104: LD_INT 1
86106: NEG
86107: PUSH
86108: EMPTY
86109: LIST
86110: LIST
86111: PUSH
86112: LD_INT 2
86114: NEG
86115: PUSH
86116: LD_INT 2
86118: NEG
86119: PUSH
86120: EMPTY
86121: LIST
86122: LIST
86123: PUSH
86124: LD_INT 2
86126: NEG
86127: PUSH
86128: LD_INT 3
86130: NEG
86131: PUSH
86132: EMPTY
86133: LIST
86134: LIST
86135: PUSH
86136: LD_INT 2
86138: PUSH
86139: LD_INT 1
86141: NEG
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 3
86149: PUSH
86150: LD_INT 0
86152: PUSH
86153: EMPTY
86154: LIST
86155: LIST
86156: PUSH
86157: LD_INT 3
86159: PUSH
86160: LD_INT 1
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: PUSH
86167: LD_INT 3
86169: PUSH
86170: LD_INT 2
86172: PUSH
86173: EMPTY
86174: LIST
86175: LIST
86176: PUSH
86177: LD_INT 3
86179: PUSH
86180: LD_INT 3
86182: PUSH
86183: EMPTY
86184: LIST
86185: LIST
86186: PUSH
86187: LD_INT 2
86189: PUSH
86190: LD_INT 3
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 2
86199: NEG
86200: PUSH
86201: LD_INT 1
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: PUSH
86208: LD_INT 3
86210: NEG
86211: PUSH
86212: LD_INT 0
86214: PUSH
86215: EMPTY
86216: LIST
86217: LIST
86218: PUSH
86219: LD_INT 3
86221: NEG
86222: PUSH
86223: LD_INT 1
86225: NEG
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: PUSH
86231: LD_INT 3
86233: NEG
86234: PUSH
86235: LD_INT 2
86237: NEG
86238: PUSH
86239: EMPTY
86240: LIST
86241: LIST
86242: PUSH
86243: LD_INT 3
86245: NEG
86246: PUSH
86247: LD_INT 3
86249: NEG
86250: PUSH
86251: EMPTY
86252: LIST
86253: LIST
86254: PUSH
86255: EMPTY
86256: LIST
86257: LIST
86258: LIST
86259: LIST
86260: LIST
86261: LIST
86262: LIST
86263: LIST
86264: LIST
86265: LIST
86266: LIST
86267: LIST
86268: LIST
86269: LIST
86270: LIST
86271: LIST
86272: LIST
86273: LIST
86274: LIST
86275: LIST
86276: LIST
86277: LIST
86278: LIST
86279: LIST
86280: LIST
86281: LIST
86282: LIST
86283: LIST
86284: LIST
86285: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86286: LD_ADDR_VAR 0 42
86290: PUSH
86291: LD_INT 0
86293: PUSH
86294: LD_INT 0
86296: PUSH
86297: EMPTY
86298: LIST
86299: LIST
86300: PUSH
86301: LD_INT 0
86303: PUSH
86304: LD_INT 1
86306: NEG
86307: PUSH
86308: EMPTY
86309: LIST
86310: LIST
86311: PUSH
86312: LD_INT 1
86314: PUSH
86315: LD_INT 0
86317: PUSH
86318: EMPTY
86319: LIST
86320: LIST
86321: PUSH
86322: LD_INT 1
86324: PUSH
86325: LD_INT 1
86327: PUSH
86328: EMPTY
86329: LIST
86330: LIST
86331: PUSH
86332: LD_INT 0
86334: PUSH
86335: LD_INT 1
86337: PUSH
86338: EMPTY
86339: LIST
86340: LIST
86341: PUSH
86342: LD_INT 1
86344: NEG
86345: PUSH
86346: LD_INT 0
86348: PUSH
86349: EMPTY
86350: LIST
86351: LIST
86352: PUSH
86353: LD_INT 1
86355: NEG
86356: PUSH
86357: LD_INT 1
86359: NEG
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: PUSH
86365: LD_INT 1
86367: NEG
86368: PUSH
86369: LD_INT 2
86371: NEG
86372: PUSH
86373: EMPTY
86374: LIST
86375: LIST
86376: PUSH
86377: LD_INT 0
86379: PUSH
86380: LD_INT 2
86382: NEG
86383: PUSH
86384: EMPTY
86385: LIST
86386: LIST
86387: PUSH
86388: LD_INT 1
86390: PUSH
86391: LD_INT 1
86393: NEG
86394: PUSH
86395: EMPTY
86396: LIST
86397: LIST
86398: PUSH
86399: LD_INT 2
86401: PUSH
86402: LD_INT 1
86404: PUSH
86405: EMPTY
86406: LIST
86407: LIST
86408: PUSH
86409: LD_INT 2
86411: PUSH
86412: LD_INT 2
86414: PUSH
86415: EMPTY
86416: LIST
86417: LIST
86418: PUSH
86419: LD_INT 1
86421: PUSH
86422: LD_INT 2
86424: PUSH
86425: EMPTY
86426: LIST
86427: LIST
86428: PUSH
86429: LD_INT 0
86431: PUSH
86432: LD_INT 2
86434: PUSH
86435: EMPTY
86436: LIST
86437: LIST
86438: PUSH
86439: LD_INT 1
86441: NEG
86442: PUSH
86443: LD_INT 1
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: PUSH
86450: LD_INT 2
86452: NEG
86453: PUSH
86454: LD_INT 1
86456: NEG
86457: PUSH
86458: EMPTY
86459: LIST
86460: LIST
86461: PUSH
86462: LD_INT 2
86464: NEG
86465: PUSH
86466: LD_INT 2
86468: NEG
86469: PUSH
86470: EMPTY
86471: LIST
86472: LIST
86473: PUSH
86474: LD_INT 2
86476: NEG
86477: PUSH
86478: LD_INT 3
86480: NEG
86481: PUSH
86482: EMPTY
86483: LIST
86484: LIST
86485: PUSH
86486: LD_INT 1
86488: NEG
86489: PUSH
86490: LD_INT 3
86492: NEG
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: PUSH
86498: LD_INT 0
86500: PUSH
86501: LD_INT 3
86503: NEG
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 1
86511: PUSH
86512: LD_INT 2
86514: NEG
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 3
86522: PUSH
86523: LD_INT 2
86525: PUSH
86526: EMPTY
86527: LIST
86528: LIST
86529: PUSH
86530: LD_INT 3
86532: PUSH
86533: LD_INT 3
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 2
86542: PUSH
86543: LD_INT 3
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: PUSH
86550: LD_INT 1
86552: PUSH
86553: LD_INT 3
86555: PUSH
86556: EMPTY
86557: LIST
86558: LIST
86559: PUSH
86560: LD_INT 0
86562: PUSH
86563: LD_INT 3
86565: PUSH
86566: EMPTY
86567: LIST
86568: LIST
86569: PUSH
86570: LD_INT 1
86572: NEG
86573: PUSH
86574: LD_INT 2
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 3
86583: NEG
86584: PUSH
86585: LD_INT 2
86587: NEG
86588: PUSH
86589: EMPTY
86590: LIST
86591: LIST
86592: PUSH
86593: LD_INT 3
86595: NEG
86596: PUSH
86597: LD_INT 3
86599: NEG
86600: PUSH
86601: EMPTY
86602: LIST
86603: LIST
86604: PUSH
86605: EMPTY
86606: LIST
86607: LIST
86608: LIST
86609: LIST
86610: LIST
86611: LIST
86612: LIST
86613: LIST
86614: LIST
86615: LIST
86616: LIST
86617: LIST
86618: LIST
86619: LIST
86620: LIST
86621: LIST
86622: LIST
86623: LIST
86624: LIST
86625: LIST
86626: LIST
86627: LIST
86628: LIST
86629: LIST
86630: LIST
86631: LIST
86632: LIST
86633: LIST
86634: LIST
86635: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86636: LD_ADDR_VAR 0 43
86640: PUSH
86641: LD_INT 0
86643: PUSH
86644: LD_INT 0
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 0
86653: PUSH
86654: LD_INT 1
86656: NEG
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: PUSH
86662: LD_INT 1
86664: PUSH
86665: LD_INT 0
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PUSH
86672: LD_INT 1
86674: PUSH
86675: LD_INT 1
86677: PUSH
86678: EMPTY
86679: LIST
86680: LIST
86681: PUSH
86682: LD_INT 0
86684: PUSH
86685: LD_INT 1
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: PUSH
86692: LD_INT 1
86694: NEG
86695: PUSH
86696: LD_INT 0
86698: PUSH
86699: EMPTY
86700: LIST
86701: LIST
86702: PUSH
86703: LD_INT 1
86705: NEG
86706: PUSH
86707: LD_INT 1
86709: NEG
86710: PUSH
86711: EMPTY
86712: LIST
86713: LIST
86714: PUSH
86715: LD_INT 1
86717: NEG
86718: PUSH
86719: LD_INT 2
86721: NEG
86722: PUSH
86723: EMPTY
86724: LIST
86725: LIST
86726: PUSH
86727: LD_INT 0
86729: PUSH
86730: LD_INT 2
86732: NEG
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: LD_INT 1
86740: PUSH
86741: LD_INT 1
86743: NEG
86744: PUSH
86745: EMPTY
86746: LIST
86747: LIST
86748: PUSH
86749: LD_INT 2
86751: PUSH
86752: LD_INT 0
86754: PUSH
86755: EMPTY
86756: LIST
86757: LIST
86758: PUSH
86759: LD_INT 2
86761: PUSH
86762: LD_INT 1
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: LD_INT 1
86771: PUSH
86772: LD_INT 2
86774: PUSH
86775: EMPTY
86776: LIST
86777: LIST
86778: PUSH
86779: LD_INT 0
86781: PUSH
86782: LD_INT 2
86784: PUSH
86785: EMPTY
86786: LIST
86787: LIST
86788: PUSH
86789: LD_INT 1
86791: NEG
86792: PUSH
86793: LD_INT 1
86795: PUSH
86796: EMPTY
86797: LIST
86798: LIST
86799: PUSH
86800: LD_INT 2
86802: NEG
86803: PUSH
86804: LD_INT 0
86806: PUSH
86807: EMPTY
86808: LIST
86809: LIST
86810: PUSH
86811: LD_INT 2
86813: NEG
86814: PUSH
86815: LD_INT 1
86817: NEG
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PUSH
86823: LD_INT 1
86825: NEG
86826: PUSH
86827: LD_INT 3
86829: NEG
86830: PUSH
86831: EMPTY
86832: LIST
86833: LIST
86834: PUSH
86835: LD_INT 0
86837: PUSH
86838: LD_INT 3
86840: NEG
86841: PUSH
86842: EMPTY
86843: LIST
86844: LIST
86845: PUSH
86846: LD_INT 1
86848: PUSH
86849: LD_INT 2
86851: NEG
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 2
86859: PUSH
86860: LD_INT 1
86862: NEG
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 3
86870: PUSH
86871: LD_INT 0
86873: PUSH
86874: EMPTY
86875: LIST
86876: LIST
86877: PUSH
86878: LD_INT 3
86880: PUSH
86881: LD_INT 1
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: PUSH
86888: LD_INT 1
86890: PUSH
86891: LD_INT 3
86893: PUSH
86894: EMPTY
86895: LIST
86896: LIST
86897: PUSH
86898: LD_INT 0
86900: PUSH
86901: LD_INT 3
86903: PUSH
86904: EMPTY
86905: LIST
86906: LIST
86907: PUSH
86908: LD_INT 1
86910: NEG
86911: PUSH
86912: LD_INT 2
86914: PUSH
86915: EMPTY
86916: LIST
86917: LIST
86918: PUSH
86919: LD_INT 2
86921: NEG
86922: PUSH
86923: LD_INT 1
86925: PUSH
86926: EMPTY
86927: LIST
86928: LIST
86929: PUSH
86930: LD_INT 3
86932: NEG
86933: PUSH
86934: LD_INT 0
86936: PUSH
86937: EMPTY
86938: LIST
86939: LIST
86940: PUSH
86941: LD_INT 3
86943: NEG
86944: PUSH
86945: LD_INT 1
86947: NEG
86948: PUSH
86949: EMPTY
86950: LIST
86951: LIST
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: LIST
86957: LIST
86958: LIST
86959: LIST
86960: LIST
86961: LIST
86962: LIST
86963: LIST
86964: LIST
86965: LIST
86966: LIST
86967: LIST
86968: LIST
86969: LIST
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: LIST
86976: LIST
86977: LIST
86978: LIST
86979: LIST
86980: LIST
86981: LIST
86982: LIST
86983: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86984: LD_ADDR_VAR 0 44
86988: PUSH
86989: LD_INT 0
86991: PUSH
86992: LD_INT 0
86994: PUSH
86995: EMPTY
86996: LIST
86997: LIST
86998: PUSH
86999: LD_INT 0
87001: PUSH
87002: LD_INT 1
87004: NEG
87005: PUSH
87006: EMPTY
87007: LIST
87008: LIST
87009: PUSH
87010: LD_INT 1
87012: PUSH
87013: LD_INT 0
87015: PUSH
87016: EMPTY
87017: LIST
87018: LIST
87019: PUSH
87020: LD_INT 1
87022: PUSH
87023: LD_INT 1
87025: PUSH
87026: EMPTY
87027: LIST
87028: LIST
87029: PUSH
87030: LD_INT 0
87032: PUSH
87033: LD_INT 1
87035: PUSH
87036: EMPTY
87037: LIST
87038: LIST
87039: PUSH
87040: LD_INT 1
87042: NEG
87043: PUSH
87044: LD_INT 0
87046: PUSH
87047: EMPTY
87048: LIST
87049: LIST
87050: PUSH
87051: LD_INT 1
87053: NEG
87054: PUSH
87055: LD_INT 1
87057: NEG
87058: PUSH
87059: EMPTY
87060: LIST
87061: LIST
87062: PUSH
87063: LD_INT 1
87065: NEG
87066: PUSH
87067: LD_INT 2
87069: NEG
87070: PUSH
87071: EMPTY
87072: LIST
87073: LIST
87074: PUSH
87075: LD_INT 1
87077: PUSH
87078: LD_INT 1
87080: NEG
87081: PUSH
87082: EMPTY
87083: LIST
87084: LIST
87085: PUSH
87086: LD_INT 2
87088: PUSH
87089: LD_INT 0
87091: PUSH
87092: EMPTY
87093: LIST
87094: LIST
87095: PUSH
87096: LD_INT 2
87098: PUSH
87099: LD_INT 1
87101: PUSH
87102: EMPTY
87103: LIST
87104: LIST
87105: PUSH
87106: LD_INT 2
87108: PUSH
87109: LD_INT 2
87111: PUSH
87112: EMPTY
87113: LIST
87114: LIST
87115: PUSH
87116: LD_INT 1
87118: PUSH
87119: LD_INT 2
87121: PUSH
87122: EMPTY
87123: LIST
87124: LIST
87125: PUSH
87126: LD_INT 1
87128: NEG
87129: PUSH
87130: LD_INT 1
87132: PUSH
87133: EMPTY
87134: LIST
87135: LIST
87136: PUSH
87137: LD_INT 2
87139: NEG
87140: PUSH
87141: LD_INT 0
87143: PUSH
87144: EMPTY
87145: LIST
87146: LIST
87147: PUSH
87148: LD_INT 2
87150: NEG
87151: PUSH
87152: LD_INT 1
87154: NEG
87155: PUSH
87156: EMPTY
87157: LIST
87158: LIST
87159: PUSH
87160: LD_INT 2
87162: NEG
87163: PUSH
87164: LD_INT 2
87166: NEG
87167: PUSH
87168: EMPTY
87169: LIST
87170: LIST
87171: PUSH
87172: LD_INT 2
87174: NEG
87175: PUSH
87176: LD_INT 3
87178: NEG
87179: PUSH
87180: EMPTY
87181: LIST
87182: LIST
87183: PUSH
87184: LD_INT 2
87186: PUSH
87187: LD_INT 1
87189: NEG
87190: PUSH
87191: EMPTY
87192: LIST
87193: LIST
87194: PUSH
87195: LD_INT 3
87197: PUSH
87198: LD_INT 0
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 3
87207: PUSH
87208: LD_INT 1
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: PUSH
87215: LD_INT 3
87217: PUSH
87218: LD_INT 2
87220: PUSH
87221: EMPTY
87222: LIST
87223: LIST
87224: PUSH
87225: LD_INT 3
87227: PUSH
87228: LD_INT 3
87230: PUSH
87231: EMPTY
87232: LIST
87233: LIST
87234: PUSH
87235: LD_INT 2
87237: PUSH
87238: LD_INT 3
87240: PUSH
87241: EMPTY
87242: LIST
87243: LIST
87244: PUSH
87245: LD_INT 2
87247: NEG
87248: PUSH
87249: LD_INT 1
87251: PUSH
87252: EMPTY
87253: LIST
87254: LIST
87255: PUSH
87256: LD_INT 3
87258: NEG
87259: PUSH
87260: LD_INT 0
87262: PUSH
87263: EMPTY
87264: LIST
87265: LIST
87266: PUSH
87267: LD_INT 3
87269: NEG
87270: PUSH
87271: LD_INT 1
87273: NEG
87274: PUSH
87275: EMPTY
87276: LIST
87277: LIST
87278: PUSH
87279: LD_INT 3
87281: NEG
87282: PUSH
87283: LD_INT 2
87285: NEG
87286: PUSH
87287: EMPTY
87288: LIST
87289: LIST
87290: PUSH
87291: LD_INT 3
87293: NEG
87294: PUSH
87295: LD_INT 3
87297: NEG
87298: PUSH
87299: EMPTY
87300: LIST
87301: LIST
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: LIST
87307: LIST
87308: LIST
87309: LIST
87310: LIST
87311: LIST
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: LIST
87320: LIST
87321: LIST
87322: LIST
87323: LIST
87324: LIST
87325: LIST
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87334: LD_ADDR_VAR 0 45
87338: PUSH
87339: LD_INT 0
87341: PUSH
87342: LD_INT 0
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: PUSH
87349: LD_INT 0
87351: PUSH
87352: LD_INT 1
87354: NEG
87355: PUSH
87356: EMPTY
87357: LIST
87358: LIST
87359: PUSH
87360: LD_INT 1
87362: PUSH
87363: LD_INT 0
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: PUSH
87370: LD_INT 1
87372: PUSH
87373: LD_INT 1
87375: PUSH
87376: EMPTY
87377: LIST
87378: LIST
87379: PUSH
87380: LD_INT 0
87382: PUSH
87383: LD_INT 1
87385: PUSH
87386: EMPTY
87387: LIST
87388: LIST
87389: PUSH
87390: LD_INT 1
87392: NEG
87393: PUSH
87394: LD_INT 0
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: PUSH
87401: LD_INT 1
87403: NEG
87404: PUSH
87405: LD_INT 1
87407: NEG
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 1
87415: NEG
87416: PUSH
87417: LD_INT 2
87419: NEG
87420: PUSH
87421: EMPTY
87422: LIST
87423: LIST
87424: PUSH
87425: LD_INT 0
87427: PUSH
87428: LD_INT 2
87430: NEG
87431: PUSH
87432: EMPTY
87433: LIST
87434: LIST
87435: PUSH
87436: LD_INT 1
87438: PUSH
87439: LD_INT 1
87441: NEG
87442: PUSH
87443: EMPTY
87444: LIST
87445: LIST
87446: PUSH
87447: LD_INT 2
87449: PUSH
87450: LD_INT 1
87452: PUSH
87453: EMPTY
87454: LIST
87455: LIST
87456: PUSH
87457: LD_INT 2
87459: PUSH
87460: LD_INT 2
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: LD_INT 1
87469: PUSH
87470: LD_INT 2
87472: PUSH
87473: EMPTY
87474: LIST
87475: LIST
87476: PUSH
87477: LD_INT 0
87479: PUSH
87480: LD_INT 2
87482: PUSH
87483: EMPTY
87484: LIST
87485: LIST
87486: PUSH
87487: LD_INT 1
87489: NEG
87490: PUSH
87491: LD_INT 1
87493: PUSH
87494: EMPTY
87495: LIST
87496: LIST
87497: PUSH
87498: LD_INT 2
87500: NEG
87501: PUSH
87502: LD_INT 1
87504: NEG
87505: PUSH
87506: EMPTY
87507: LIST
87508: LIST
87509: PUSH
87510: LD_INT 2
87512: NEG
87513: PUSH
87514: LD_INT 2
87516: NEG
87517: PUSH
87518: EMPTY
87519: LIST
87520: LIST
87521: PUSH
87522: LD_INT 2
87524: NEG
87525: PUSH
87526: LD_INT 3
87528: NEG
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: PUSH
87534: LD_INT 1
87536: NEG
87537: PUSH
87538: LD_INT 3
87540: NEG
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: PUSH
87546: LD_INT 0
87548: PUSH
87549: LD_INT 3
87551: NEG
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 1
87559: PUSH
87560: LD_INT 2
87562: NEG
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PUSH
87568: LD_INT 3
87570: PUSH
87571: LD_INT 2
87573: PUSH
87574: EMPTY
87575: LIST
87576: LIST
87577: PUSH
87578: LD_INT 3
87580: PUSH
87581: LD_INT 3
87583: PUSH
87584: EMPTY
87585: LIST
87586: LIST
87587: PUSH
87588: LD_INT 2
87590: PUSH
87591: LD_INT 3
87593: PUSH
87594: EMPTY
87595: LIST
87596: LIST
87597: PUSH
87598: LD_INT 1
87600: PUSH
87601: LD_INT 3
87603: PUSH
87604: EMPTY
87605: LIST
87606: LIST
87607: PUSH
87608: LD_INT 0
87610: PUSH
87611: LD_INT 3
87613: PUSH
87614: EMPTY
87615: LIST
87616: LIST
87617: PUSH
87618: LD_INT 1
87620: NEG
87621: PUSH
87622: LD_INT 2
87624: PUSH
87625: EMPTY
87626: LIST
87627: LIST
87628: PUSH
87629: LD_INT 3
87631: NEG
87632: PUSH
87633: LD_INT 2
87635: NEG
87636: PUSH
87637: EMPTY
87638: LIST
87639: LIST
87640: PUSH
87641: LD_INT 3
87643: NEG
87644: PUSH
87645: LD_INT 3
87647: NEG
87648: PUSH
87649: EMPTY
87650: LIST
87651: LIST
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: LIST
87657: LIST
87658: LIST
87659: LIST
87660: LIST
87661: LIST
87662: LIST
87663: LIST
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87684: LD_ADDR_VAR 0 46
87688: PUSH
87689: LD_INT 0
87691: PUSH
87692: LD_INT 0
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 0
87701: PUSH
87702: LD_INT 1
87704: NEG
87705: PUSH
87706: EMPTY
87707: LIST
87708: LIST
87709: PUSH
87710: LD_INT 1
87712: PUSH
87713: LD_INT 0
87715: PUSH
87716: EMPTY
87717: LIST
87718: LIST
87719: PUSH
87720: LD_INT 1
87722: PUSH
87723: LD_INT 1
87725: PUSH
87726: EMPTY
87727: LIST
87728: LIST
87729: PUSH
87730: LD_INT 0
87732: PUSH
87733: LD_INT 1
87735: PUSH
87736: EMPTY
87737: LIST
87738: LIST
87739: PUSH
87740: LD_INT 1
87742: NEG
87743: PUSH
87744: LD_INT 0
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: LD_INT 1
87753: NEG
87754: PUSH
87755: LD_INT 1
87757: NEG
87758: PUSH
87759: EMPTY
87760: LIST
87761: LIST
87762: PUSH
87763: LD_INT 1
87765: NEG
87766: PUSH
87767: LD_INT 2
87769: NEG
87770: PUSH
87771: EMPTY
87772: LIST
87773: LIST
87774: PUSH
87775: LD_INT 0
87777: PUSH
87778: LD_INT 2
87780: NEG
87781: PUSH
87782: EMPTY
87783: LIST
87784: LIST
87785: PUSH
87786: LD_INT 1
87788: PUSH
87789: LD_INT 1
87791: NEG
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: PUSH
87797: LD_INT 2
87799: PUSH
87800: LD_INT 0
87802: PUSH
87803: EMPTY
87804: LIST
87805: LIST
87806: PUSH
87807: LD_INT 2
87809: PUSH
87810: LD_INT 1
87812: PUSH
87813: EMPTY
87814: LIST
87815: LIST
87816: PUSH
87817: LD_INT 1
87819: PUSH
87820: LD_INT 2
87822: PUSH
87823: EMPTY
87824: LIST
87825: LIST
87826: PUSH
87827: LD_INT 0
87829: PUSH
87830: LD_INT 2
87832: PUSH
87833: EMPTY
87834: LIST
87835: LIST
87836: PUSH
87837: LD_INT 1
87839: NEG
87840: PUSH
87841: LD_INT 1
87843: PUSH
87844: EMPTY
87845: LIST
87846: LIST
87847: PUSH
87848: LD_INT 2
87850: NEG
87851: PUSH
87852: LD_INT 0
87854: PUSH
87855: EMPTY
87856: LIST
87857: LIST
87858: PUSH
87859: LD_INT 2
87861: NEG
87862: PUSH
87863: LD_INT 1
87865: NEG
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: PUSH
87871: LD_INT 1
87873: NEG
87874: PUSH
87875: LD_INT 3
87877: NEG
87878: PUSH
87879: EMPTY
87880: LIST
87881: LIST
87882: PUSH
87883: LD_INT 0
87885: PUSH
87886: LD_INT 3
87888: NEG
87889: PUSH
87890: EMPTY
87891: LIST
87892: LIST
87893: PUSH
87894: LD_INT 1
87896: PUSH
87897: LD_INT 2
87899: NEG
87900: PUSH
87901: EMPTY
87902: LIST
87903: LIST
87904: PUSH
87905: LD_INT 2
87907: PUSH
87908: LD_INT 1
87910: NEG
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: PUSH
87916: LD_INT 3
87918: PUSH
87919: LD_INT 0
87921: PUSH
87922: EMPTY
87923: LIST
87924: LIST
87925: PUSH
87926: LD_INT 3
87928: PUSH
87929: LD_INT 1
87931: PUSH
87932: EMPTY
87933: LIST
87934: LIST
87935: PUSH
87936: LD_INT 1
87938: PUSH
87939: LD_INT 3
87941: PUSH
87942: EMPTY
87943: LIST
87944: LIST
87945: PUSH
87946: LD_INT 0
87948: PUSH
87949: LD_INT 3
87951: PUSH
87952: EMPTY
87953: LIST
87954: LIST
87955: PUSH
87956: LD_INT 1
87958: NEG
87959: PUSH
87960: LD_INT 2
87962: PUSH
87963: EMPTY
87964: LIST
87965: LIST
87966: PUSH
87967: LD_INT 2
87969: NEG
87970: PUSH
87971: LD_INT 1
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 3
87980: NEG
87981: PUSH
87982: LD_INT 0
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 3
87991: NEG
87992: PUSH
87993: LD_INT 1
87995: NEG
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: LIST
88005: LIST
88006: LIST
88007: LIST
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88032: LD_ADDR_VAR 0 47
88036: PUSH
88037: LD_INT 0
88039: PUSH
88040: LD_INT 0
88042: PUSH
88043: EMPTY
88044: LIST
88045: LIST
88046: PUSH
88047: LD_INT 0
88049: PUSH
88050: LD_INT 1
88052: NEG
88053: PUSH
88054: EMPTY
88055: LIST
88056: LIST
88057: PUSH
88058: LD_INT 1
88060: PUSH
88061: LD_INT 0
88063: PUSH
88064: EMPTY
88065: LIST
88066: LIST
88067: PUSH
88068: LD_INT 1
88070: PUSH
88071: LD_INT 1
88073: PUSH
88074: EMPTY
88075: LIST
88076: LIST
88077: PUSH
88078: LD_INT 0
88080: PUSH
88081: LD_INT 1
88083: PUSH
88084: EMPTY
88085: LIST
88086: LIST
88087: PUSH
88088: LD_INT 1
88090: NEG
88091: PUSH
88092: LD_INT 0
88094: PUSH
88095: EMPTY
88096: LIST
88097: LIST
88098: PUSH
88099: LD_INT 1
88101: NEG
88102: PUSH
88103: LD_INT 1
88105: NEG
88106: PUSH
88107: EMPTY
88108: LIST
88109: LIST
88110: PUSH
88111: LD_INT 1
88113: NEG
88114: PUSH
88115: LD_INT 2
88117: NEG
88118: PUSH
88119: EMPTY
88120: LIST
88121: LIST
88122: PUSH
88123: LD_INT 0
88125: PUSH
88126: LD_INT 2
88128: NEG
88129: PUSH
88130: EMPTY
88131: LIST
88132: LIST
88133: PUSH
88134: LD_INT 1
88136: PUSH
88137: LD_INT 1
88139: NEG
88140: PUSH
88141: EMPTY
88142: LIST
88143: LIST
88144: PUSH
88145: LD_INT 2
88147: NEG
88148: PUSH
88149: LD_INT 1
88151: NEG
88152: PUSH
88153: EMPTY
88154: LIST
88155: LIST
88156: PUSH
88157: LD_INT 2
88159: NEG
88160: PUSH
88161: LD_INT 2
88163: NEG
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PUSH
88169: EMPTY
88170: LIST
88171: LIST
88172: LIST
88173: LIST
88174: LIST
88175: LIST
88176: LIST
88177: LIST
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88183: LD_ADDR_VAR 0 48
88187: PUSH
88188: LD_INT 0
88190: PUSH
88191: LD_INT 0
88193: PUSH
88194: EMPTY
88195: LIST
88196: LIST
88197: PUSH
88198: LD_INT 0
88200: PUSH
88201: LD_INT 1
88203: NEG
88204: PUSH
88205: EMPTY
88206: LIST
88207: LIST
88208: PUSH
88209: LD_INT 1
88211: PUSH
88212: LD_INT 0
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: PUSH
88219: LD_INT 1
88221: PUSH
88222: LD_INT 1
88224: PUSH
88225: EMPTY
88226: LIST
88227: LIST
88228: PUSH
88229: LD_INT 0
88231: PUSH
88232: LD_INT 1
88234: PUSH
88235: EMPTY
88236: LIST
88237: LIST
88238: PUSH
88239: LD_INT 1
88241: NEG
88242: PUSH
88243: LD_INT 0
88245: PUSH
88246: EMPTY
88247: LIST
88248: LIST
88249: PUSH
88250: LD_INT 1
88252: NEG
88253: PUSH
88254: LD_INT 1
88256: NEG
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: PUSH
88262: LD_INT 1
88264: NEG
88265: PUSH
88266: LD_INT 2
88268: NEG
88269: PUSH
88270: EMPTY
88271: LIST
88272: LIST
88273: PUSH
88274: LD_INT 0
88276: PUSH
88277: LD_INT 2
88279: NEG
88280: PUSH
88281: EMPTY
88282: LIST
88283: LIST
88284: PUSH
88285: LD_INT 1
88287: PUSH
88288: LD_INT 1
88290: NEG
88291: PUSH
88292: EMPTY
88293: LIST
88294: LIST
88295: PUSH
88296: LD_INT 2
88298: PUSH
88299: LD_INT 0
88301: PUSH
88302: EMPTY
88303: LIST
88304: LIST
88305: PUSH
88306: LD_INT 2
88308: PUSH
88309: LD_INT 1
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: PUSH
88316: EMPTY
88317: LIST
88318: LIST
88319: LIST
88320: LIST
88321: LIST
88322: LIST
88323: LIST
88324: LIST
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88330: LD_ADDR_VAR 0 49
88334: PUSH
88335: LD_INT 0
88337: PUSH
88338: LD_INT 0
88340: PUSH
88341: EMPTY
88342: LIST
88343: LIST
88344: PUSH
88345: LD_INT 0
88347: PUSH
88348: LD_INT 1
88350: NEG
88351: PUSH
88352: EMPTY
88353: LIST
88354: LIST
88355: PUSH
88356: LD_INT 1
88358: PUSH
88359: LD_INT 0
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: PUSH
88366: LD_INT 1
88368: PUSH
88369: LD_INT 1
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: PUSH
88376: LD_INT 0
88378: PUSH
88379: LD_INT 1
88381: PUSH
88382: EMPTY
88383: LIST
88384: LIST
88385: PUSH
88386: LD_INT 1
88388: NEG
88389: PUSH
88390: LD_INT 0
88392: PUSH
88393: EMPTY
88394: LIST
88395: LIST
88396: PUSH
88397: LD_INT 1
88399: NEG
88400: PUSH
88401: LD_INT 1
88403: NEG
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 1
88411: PUSH
88412: LD_INT 1
88414: NEG
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: PUSH
88420: LD_INT 2
88422: PUSH
88423: LD_INT 0
88425: PUSH
88426: EMPTY
88427: LIST
88428: LIST
88429: PUSH
88430: LD_INT 2
88432: PUSH
88433: LD_INT 1
88435: PUSH
88436: EMPTY
88437: LIST
88438: LIST
88439: PUSH
88440: LD_INT 2
88442: PUSH
88443: LD_INT 2
88445: PUSH
88446: EMPTY
88447: LIST
88448: LIST
88449: PUSH
88450: LD_INT 1
88452: PUSH
88453: LD_INT 2
88455: PUSH
88456: EMPTY
88457: LIST
88458: LIST
88459: PUSH
88460: EMPTY
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88474: LD_ADDR_VAR 0 50
88478: PUSH
88479: LD_INT 0
88481: PUSH
88482: LD_INT 0
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PUSH
88489: LD_INT 0
88491: PUSH
88492: LD_INT 1
88494: NEG
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 1
88502: PUSH
88503: LD_INT 0
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 1
88512: PUSH
88513: LD_INT 1
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 0
88522: PUSH
88523: LD_INT 1
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 1
88532: NEG
88533: PUSH
88534: LD_INT 0
88536: PUSH
88537: EMPTY
88538: LIST
88539: LIST
88540: PUSH
88541: LD_INT 1
88543: NEG
88544: PUSH
88545: LD_INT 1
88547: NEG
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: PUSH
88553: LD_INT 2
88555: PUSH
88556: LD_INT 1
88558: PUSH
88559: EMPTY
88560: LIST
88561: LIST
88562: PUSH
88563: LD_INT 2
88565: PUSH
88566: LD_INT 2
88568: PUSH
88569: EMPTY
88570: LIST
88571: LIST
88572: PUSH
88573: LD_INT 1
88575: PUSH
88576: LD_INT 2
88578: PUSH
88579: EMPTY
88580: LIST
88581: LIST
88582: PUSH
88583: LD_INT 0
88585: PUSH
88586: LD_INT 2
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: PUSH
88593: LD_INT 1
88595: NEG
88596: PUSH
88597: LD_INT 1
88599: PUSH
88600: EMPTY
88601: LIST
88602: LIST
88603: PUSH
88604: EMPTY
88605: LIST
88606: LIST
88607: LIST
88608: LIST
88609: LIST
88610: LIST
88611: LIST
88612: LIST
88613: LIST
88614: LIST
88615: LIST
88616: LIST
88617: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
88618: LD_ADDR_VAR 0 51
88622: PUSH
88623: LD_INT 0
88625: PUSH
88626: LD_INT 0
88628: PUSH
88629: EMPTY
88630: LIST
88631: LIST
88632: PUSH
88633: LD_INT 0
88635: PUSH
88636: LD_INT 1
88638: NEG
88639: PUSH
88640: EMPTY
88641: LIST
88642: LIST
88643: PUSH
88644: LD_INT 1
88646: PUSH
88647: LD_INT 0
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: PUSH
88654: LD_INT 1
88656: PUSH
88657: LD_INT 1
88659: PUSH
88660: EMPTY
88661: LIST
88662: LIST
88663: PUSH
88664: LD_INT 0
88666: PUSH
88667: LD_INT 1
88669: PUSH
88670: EMPTY
88671: LIST
88672: LIST
88673: PUSH
88674: LD_INT 1
88676: NEG
88677: PUSH
88678: LD_INT 0
88680: PUSH
88681: EMPTY
88682: LIST
88683: LIST
88684: PUSH
88685: LD_INT 1
88687: NEG
88688: PUSH
88689: LD_INT 1
88691: NEG
88692: PUSH
88693: EMPTY
88694: LIST
88695: LIST
88696: PUSH
88697: LD_INT 1
88699: PUSH
88700: LD_INT 2
88702: PUSH
88703: EMPTY
88704: LIST
88705: LIST
88706: PUSH
88707: LD_INT 0
88709: PUSH
88710: LD_INT 2
88712: PUSH
88713: EMPTY
88714: LIST
88715: LIST
88716: PUSH
88717: LD_INT 1
88719: NEG
88720: PUSH
88721: LD_INT 1
88723: PUSH
88724: EMPTY
88725: LIST
88726: LIST
88727: PUSH
88728: LD_INT 2
88730: NEG
88731: PUSH
88732: LD_INT 0
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PUSH
88739: LD_INT 2
88741: NEG
88742: PUSH
88743: LD_INT 1
88745: NEG
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: PUSH
88751: EMPTY
88752: LIST
88753: LIST
88754: LIST
88755: LIST
88756: LIST
88757: LIST
88758: LIST
88759: LIST
88760: LIST
88761: LIST
88762: LIST
88763: LIST
88764: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88765: LD_ADDR_VAR 0 52
88769: PUSH
88770: LD_INT 0
88772: PUSH
88773: LD_INT 0
88775: PUSH
88776: EMPTY
88777: LIST
88778: LIST
88779: PUSH
88780: LD_INT 0
88782: PUSH
88783: LD_INT 1
88785: NEG
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: LD_INT 1
88793: PUSH
88794: LD_INT 0
88796: PUSH
88797: EMPTY
88798: LIST
88799: LIST
88800: PUSH
88801: LD_INT 1
88803: PUSH
88804: LD_INT 1
88806: PUSH
88807: EMPTY
88808: LIST
88809: LIST
88810: PUSH
88811: LD_INT 0
88813: PUSH
88814: LD_INT 1
88816: PUSH
88817: EMPTY
88818: LIST
88819: LIST
88820: PUSH
88821: LD_INT 1
88823: NEG
88824: PUSH
88825: LD_INT 0
88827: PUSH
88828: EMPTY
88829: LIST
88830: LIST
88831: PUSH
88832: LD_INT 1
88834: NEG
88835: PUSH
88836: LD_INT 1
88838: NEG
88839: PUSH
88840: EMPTY
88841: LIST
88842: LIST
88843: PUSH
88844: LD_INT 1
88846: NEG
88847: PUSH
88848: LD_INT 2
88850: NEG
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: PUSH
88856: LD_INT 1
88858: NEG
88859: PUSH
88860: LD_INT 1
88862: PUSH
88863: EMPTY
88864: LIST
88865: LIST
88866: PUSH
88867: LD_INT 2
88869: NEG
88870: PUSH
88871: LD_INT 0
88873: PUSH
88874: EMPTY
88875: LIST
88876: LIST
88877: PUSH
88878: LD_INT 2
88880: NEG
88881: PUSH
88882: LD_INT 1
88884: NEG
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 2
88892: NEG
88893: PUSH
88894: LD_INT 2
88896: NEG
88897: PUSH
88898: EMPTY
88899: LIST
88900: LIST
88901: PUSH
88902: EMPTY
88903: LIST
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88916: LD_ADDR_VAR 0 53
88920: PUSH
88921: LD_INT 0
88923: PUSH
88924: LD_INT 0
88926: PUSH
88927: EMPTY
88928: LIST
88929: LIST
88930: PUSH
88931: LD_INT 0
88933: PUSH
88934: LD_INT 1
88936: NEG
88937: PUSH
88938: EMPTY
88939: LIST
88940: LIST
88941: PUSH
88942: LD_INT 1
88944: PUSH
88945: LD_INT 0
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: PUSH
88952: LD_INT 1
88954: PUSH
88955: LD_INT 1
88957: PUSH
88958: EMPTY
88959: LIST
88960: LIST
88961: PUSH
88962: LD_INT 0
88964: PUSH
88965: LD_INT 1
88967: PUSH
88968: EMPTY
88969: LIST
88970: LIST
88971: PUSH
88972: LD_INT 1
88974: NEG
88975: PUSH
88976: LD_INT 0
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PUSH
88983: LD_INT 1
88985: NEG
88986: PUSH
88987: LD_INT 1
88989: NEG
88990: PUSH
88991: EMPTY
88992: LIST
88993: LIST
88994: PUSH
88995: LD_INT 1
88997: NEG
88998: PUSH
88999: LD_INT 2
89001: NEG
89002: PUSH
89003: EMPTY
89004: LIST
89005: LIST
89006: PUSH
89007: LD_INT 0
89009: PUSH
89010: LD_INT 2
89012: NEG
89013: PUSH
89014: EMPTY
89015: LIST
89016: LIST
89017: PUSH
89018: LD_INT 1
89020: PUSH
89021: LD_INT 1
89023: NEG
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PUSH
89029: LD_INT 2
89031: PUSH
89032: LD_INT 0
89034: PUSH
89035: EMPTY
89036: LIST
89037: LIST
89038: PUSH
89039: LD_INT 2
89041: PUSH
89042: LD_INT 1
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 2
89051: PUSH
89052: LD_INT 2
89054: PUSH
89055: EMPTY
89056: LIST
89057: LIST
89058: PUSH
89059: LD_INT 1
89061: PUSH
89062: LD_INT 2
89064: PUSH
89065: EMPTY
89066: LIST
89067: LIST
89068: PUSH
89069: LD_INT 0
89071: PUSH
89072: LD_INT 2
89074: PUSH
89075: EMPTY
89076: LIST
89077: LIST
89078: PUSH
89079: LD_INT 1
89081: NEG
89082: PUSH
89083: LD_INT 1
89085: PUSH
89086: EMPTY
89087: LIST
89088: LIST
89089: PUSH
89090: LD_INT 2
89092: NEG
89093: PUSH
89094: LD_INT 0
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: PUSH
89101: LD_INT 2
89103: NEG
89104: PUSH
89105: LD_INT 1
89107: NEG
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: PUSH
89113: LD_INT 2
89115: NEG
89116: PUSH
89117: LD_INT 2
89119: NEG
89120: PUSH
89121: EMPTY
89122: LIST
89123: LIST
89124: PUSH
89125: EMPTY
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89146: LD_ADDR_VAR 0 54
89150: PUSH
89151: LD_INT 0
89153: PUSH
89154: LD_INT 0
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: PUSH
89161: LD_INT 0
89163: PUSH
89164: LD_INT 1
89166: NEG
89167: PUSH
89168: EMPTY
89169: LIST
89170: LIST
89171: PUSH
89172: LD_INT 1
89174: PUSH
89175: LD_INT 0
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 1
89184: PUSH
89185: LD_INT 1
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: PUSH
89192: LD_INT 0
89194: PUSH
89195: LD_INT 1
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PUSH
89202: LD_INT 1
89204: NEG
89205: PUSH
89206: LD_INT 0
89208: PUSH
89209: EMPTY
89210: LIST
89211: LIST
89212: PUSH
89213: LD_INT 1
89215: NEG
89216: PUSH
89217: LD_INT 1
89219: NEG
89220: PUSH
89221: EMPTY
89222: LIST
89223: LIST
89224: PUSH
89225: LD_INT 1
89227: NEG
89228: PUSH
89229: LD_INT 2
89231: NEG
89232: PUSH
89233: EMPTY
89234: LIST
89235: LIST
89236: PUSH
89237: LD_INT 0
89239: PUSH
89240: LD_INT 2
89242: NEG
89243: PUSH
89244: EMPTY
89245: LIST
89246: LIST
89247: PUSH
89248: LD_INT 1
89250: PUSH
89251: LD_INT 1
89253: NEG
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: PUSH
89259: LD_INT 2
89261: PUSH
89262: LD_INT 0
89264: PUSH
89265: EMPTY
89266: LIST
89267: LIST
89268: PUSH
89269: LD_INT 2
89271: PUSH
89272: LD_INT 1
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: PUSH
89279: LD_INT 2
89281: PUSH
89282: LD_INT 2
89284: PUSH
89285: EMPTY
89286: LIST
89287: LIST
89288: PUSH
89289: LD_INT 1
89291: PUSH
89292: LD_INT 2
89294: PUSH
89295: EMPTY
89296: LIST
89297: LIST
89298: PUSH
89299: LD_INT 0
89301: PUSH
89302: LD_INT 2
89304: PUSH
89305: EMPTY
89306: LIST
89307: LIST
89308: PUSH
89309: LD_INT 1
89311: NEG
89312: PUSH
89313: LD_INT 1
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 2
89322: NEG
89323: PUSH
89324: LD_INT 0
89326: PUSH
89327: EMPTY
89328: LIST
89329: LIST
89330: PUSH
89331: LD_INT 2
89333: NEG
89334: PUSH
89335: LD_INT 1
89337: NEG
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: PUSH
89343: LD_INT 2
89345: NEG
89346: PUSH
89347: LD_INT 2
89349: NEG
89350: PUSH
89351: EMPTY
89352: LIST
89353: LIST
89354: PUSH
89355: EMPTY
89356: LIST
89357: LIST
89358: LIST
89359: LIST
89360: LIST
89361: LIST
89362: LIST
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: LIST
89373: LIST
89374: LIST
89375: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89376: LD_ADDR_VAR 0 55
89380: PUSH
89381: LD_INT 0
89383: PUSH
89384: LD_INT 0
89386: PUSH
89387: EMPTY
89388: LIST
89389: LIST
89390: PUSH
89391: LD_INT 0
89393: PUSH
89394: LD_INT 1
89396: NEG
89397: PUSH
89398: EMPTY
89399: LIST
89400: LIST
89401: PUSH
89402: LD_INT 1
89404: PUSH
89405: LD_INT 0
89407: PUSH
89408: EMPTY
89409: LIST
89410: LIST
89411: PUSH
89412: LD_INT 1
89414: PUSH
89415: LD_INT 1
89417: PUSH
89418: EMPTY
89419: LIST
89420: LIST
89421: PUSH
89422: LD_INT 0
89424: PUSH
89425: LD_INT 1
89427: PUSH
89428: EMPTY
89429: LIST
89430: LIST
89431: PUSH
89432: LD_INT 1
89434: NEG
89435: PUSH
89436: LD_INT 0
89438: PUSH
89439: EMPTY
89440: LIST
89441: LIST
89442: PUSH
89443: LD_INT 1
89445: NEG
89446: PUSH
89447: LD_INT 1
89449: NEG
89450: PUSH
89451: EMPTY
89452: LIST
89453: LIST
89454: PUSH
89455: LD_INT 1
89457: NEG
89458: PUSH
89459: LD_INT 2
89461: NEG
89462: PUSH
89463: EMPTY
89464: LIST
89465: LIST
89466: PUSH
89467: LD_INT 0
89469: PUSH
89470: LD_INT 2
89472: NEG
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: PUSH
89478: LD_INT 1
89480: PUSH
89481: LD_INT 1
89483: NEG
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 2
89491: PUSH
89492: LD_INT 0
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: LD_INT 2
89501: PUSH
89502: LD_INT 1
89504: PUSH
89505: EMPTY
89506: LIST
89507: LIST
89508: PUSH
89509: LD_INT 2
89511: PUSH
89512: LD_INT 2
89514: PUSH
89515: EMPTY
89516: LIST
89517: LIST
89518: PUSH
89519: LD_INT 1
89521: PUSH
89522: LD_INT 2
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: LD_INT 0
89531: PUSH
89532: LD_INT 2
89534: PUSH
89535: EMPTY
89536: LIST
89537: LIST
89538: PUSH
89539: LD_INT 1
89541: NEG
89542: PUSH
89543: LD_INT 1
89545: PUSH
89546: EMPTY
89547: LIST
89548: LIST
89549: PUSH
89550: LD_INT 2
89552: NEG
89553: PUSH
89554: LD_INT 0
89556: PUSH
89557: EMPTY
89558: LIST
89559: LIST
89560: PUSH
89561: LD_INT 2
89563: NEG
89564: PUSH
89565: LD_INT 1
89567: NEG
89568: PUSH
89569: EMPTY
89570: LIST
89571: LIST
89572: PUSH
89573: LD_INT 2
89575: NEG
89576: PUSH
89577: LD_INT 2
89579: NEG
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: PUSH
89585: EMPTY
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: LIST
89597: LIST
89598: LIST
89599: LIST
89600: LIST
89601: LIST
89602: LIST
89603: LIST
89604: LIST
89605: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89606: LD_ADDR_VAR 0 56
89610: PUSH
89611: LD_INT 0
89613: PUSH
89614: LD_INT 0
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 0
89623: PUSH
89624: LD_INT 1
89626: NEG
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 1
89634: PUSH
89635: LD_INT 0
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: PUSH
89642: LD_INT 1
89644: PUSH
89645: LD_INT 1
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 0
89654: PUSH
89655: LD_INT 1
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: PUSH
89662: LD_INT 1
89664: NEG
89665: PUSH
89666: LD_INT 0
89668: PUSH
89669: EMPTY
89670: LIST
89671: LIST
89672: PUSH
89673: LD_INT 1
89675: NEG
89676: PUSH
89677: LD_INT 1
89679: NEG
89680: PUSH
89681: EMPTY
89682: LIST
89683: LIST
89684: PUSH
89685: LD_INT 1
89687: NEG
89688: PUSH
89689: LD_INT 2
89691: NEG
89692: PUSH
89693: EMPTY
89694: LIST
89695: LIST
89696: PUSH
89697: LD_INT 0
89699: PUSH
89700: LD_INT 2
89702: NEG
89703: PUSH
89704: EMPTY
89705: LIST
89706: LIST
89707: PUSH
89708: LD_INT 1
89710: PUSH
89711: LD_INT 1
89713: NEG
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: PUSH
89719: LD_INT 2
89721: PUSH
89722: LD_INT 0
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 2
89731: PUSH
89732: LD_INT 1
89734: PUSH
89735: EMPTY
89736: LIST
89737: LIST
89738: PUSH
89739: LD_INT 2
89741: PUSH
89742: LD_INT 2
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: PUSH
89749: LD_INT 1
89751: PUSH
89752: LD_INT 2
89754: PUSH
89755: EMPTY
89756: LIST
89757: LIST
89758: PUSH
89759: LD_INT 0
89761: PUSH
89762: LD_INT 2
89764: PUSH
89765: EMPTY
89766: LIST
89767: LIST
89768: PUSH
89769: LD_INT 1
89771: NEG
89772: PUSH
89773: LD_INT 1
89775: PUSH
89776: EMPTY
89777: LIST
89778: LIST
89779: PUSH
89780: LD_INT 2
89782: NEG
89783: PUSH
89784: LD_INT 0
89786: PUSH
89787: EMPTY
89788: LIST
89789: LIST
89790: PUSH
89791: LD_INT 2
89793: NEG
89794: PUSH
89795: LD_INT 1
89797: NEG
89798: PUSH
89799: EMPTY
89800: LIST
89801: LIST
89802: PUSH
89803: LD_INT 2
89805: NEG
89806: PUSH
89807: LD_INT 2
89809: NEG
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: PUSH
89815: EMPTY
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: LIST
89821: LIST
89822: LIST
89823: LIST
89824: LIST
89825: LIST
89826: LIST
89827: LIST
89828: LIST
89829: LIST
89830: LIST
89831: LIST
89832: LIST
89833: LIST
89834: LIST
89835: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89836: LD_ADDR_VAR 0 57
89840: PUSH
89841: LD_INT 0
89843: PUSH
89844: LD_INT 0
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: PUSH
89851: LD_INT 0
89853: PUSH
89854: LD_INT 1
89856: NEG
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: PUSH
89862: LD_INT 1
89864: PUSH
89865: LD_INT 0
89867: PUSH
89868: EMPTY
89869: LIST
89870: LIST
89871: PUSH
89872: LD_INT 1
89874: PUSH
89875: LD_INT 1
89877: PUSH
89878: EMPTY
89879: LIST
89880: LIST
89881: PUSH
89882: LD_INT 0
89884: PUSH
89885: LD_INT 1
89887: PUSH
89888: EMPTY
89889: LIST
89890: LIST
89891: PUSH
89892: LD_INT 1
89894: NEG
89895: PUSH
89896: LD_INT 0
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 1
89905: NEG
89906: PUSH
89907: LD_INT 1
89909: NEG
89910: PUSH
89911: EMPTY
89912: LIST
89913: LIST
89914: PUSH
89915: LD_INT 1
89917: NEG
89918: PUSH
89919: LD_INT 2
89921: NEG
89922: PUSH
89923: EMPTY
89924: LIST
89925: LIST
89926: PUSH
89927: LD_INT 0
89929: PUSH
89930: LD_INT 2
89932: NEG
89933: PUSH
89934: EMPTY
89935: LIST
89936: LIST
89937: PUSH
89938: LD_INT 1
89940: PUSH
89941: LD_INT 1
89943: NEG
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: PUSH
89949: LD_INT 2
89951: PUSH
89952: LD_INT 0
89954: PUSH
89955: EMPTY
89956: LIST
89957: LIST
89958: PUSH
89959: LD_INT 2
89961: PUSH
89962: LD_INT 1
89964: PUSH
89965: EMPTY
89966: LIST
89967: LIST
89968: PUSH
89969: LD_INT 2
89971: PUSH
89972: LD_INT 2
89974: PUSH
89975: EMPTY
89976: LIST
89977: LIST
89978: PUSH
89979: LD_INT 1
89981: PUSH
89982: LD_INT 2
89984: PUSH
89985: EMPTY
89986: LIST
89987: LIST
89988: PUSH
89989: LD_INT 0
89991: PUSH
89992: LD_INT 2
89994: PUSH
89995: EMPTY
89996: LIST
89997: LIST
89998: PUSH
89999: LD_INT 1
90001: NEG
90002: PUSH
90003: LD_INT 1
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: PUSH
90010: LD_INT 2
90012: NEG
90013: PUSH
90014: LD_INT 0
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: LD_INT 2
90023: NEG
90024: PUSH
90025: LD_INT 1
90027: NEG
90028: PUSH
90029: EMPTY
90030: LIST
90031: LIST
90032: PUSH
90033: LD_INT 2
90035: NEG
90036: PUSH
90037: LD_INT 2
90039: NEG
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90066: LD_ADDR_VAR 0 58
90070: PUSH
90071: LD_INT 0
90073: PUSH
90074: LD_INT 0
90076: PUSH
90077: EMPTY
90078: LIST
90079: LIST
90080: PUSH
90081: LD_INT 0
90083: PUSH
90084: LD_INT 1
90086: NEG
90087: PUSH
90088: EMPTY
90089: LIST
90090: LIST
90091: PUSH
90092: LD_INT 1
90094: PUSH
90095: LD_INT 0
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: PUSH
90102: LD_INT 1
90104: PUSH
90105: LD_INT 1
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: LD_INT 0
90114: PUSH
90115: LD_INT 1
90117: PUSH
90118: EMPTY
90119: LIST
90120: LIST
90121: PUSH
90122: LD_INT 1
90124: NEG
90125: PUSH
90126: LD_INT 0
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 1
90135: NEG
90136: PUSH
90137: LD_INT 1
90139: NEG
90140: PUSH
90141: EMPTY
90142: LIST
90143: LIST
90144: PUSH
90145: LD_INT 1
90147: NEG
90148: PUSH
90149: LD_INT 2
90151: NEG
90152: PUSH
90153: EMPTY
90154: LIST
90155: LIST
90156: PUSH
90157: LD_INT 0
90159: PUSH
90160: LD_INT 2
90162: NEG
90163: PUSH
90164: EMPTY
90165: LIST
90166: LIST
90167: PUSH
90168: LD_INT 1
90170: PUSH
90171: LD_INT 1
90173: NEG
90174: PUSH
90175: EMPTY
90176: LIST
90177: LIST
90178: PUSH
90179: LD_INT 2
90181: PUSH
90182: LD_INT 0
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: PUSH
90189: LD_INT 2
90191: PUSH
90192: LD_INT 1
90194: PUSH
90195: EMPTY
90196: LIST
90197: LIST
90198: PUSH
90199: LD_INT 2
90201: PUSH
90202: LD_INT 2
90204: PUSH
90205: EMPTY
90206: LIST
90207: LIST
90208: PUSH
90209: LD_INT 1
90211: PUSH
90212: LD_INT 2
90214: PUSH
90215: EMPTY
90216: LIST
90217: LIST
90218: PUSH
90219: LD_INT 0
90221: PUSH
90222: LD_INT 2
90224: PUSH
90225: EMPTY
90226: LIST
90227: LIST
90228: PUSH
90229: LD_INT 1
90231: NEG
90232: PUSH
90233: LD_INT 1
90235: PUSH
90236: EMPTY
90237: LIST
90238: LIST
90239: PUSH
90240: LD_INT 2
90242: NEG
90243: PUSH
90244: LD_INT 0
90246: PUSH
90247: EMPTY
90248: LIST
90249: LIST
90250: PUSH
90251: LD_INT 2
90253: NEG
90254: PUSH
90255: LD_INT 1
90257: NEG
90258: PUSH
90259: EMPTY
90260: LIST
90261: LIST
90262: PUSH
90263: LD_INT 2
90265: NEG
90266: PUSH
90267: LD_INT 2
90269: NEG
90270: PUSH
90271: EMPTY
90272: LIST
90273: LIST
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90296: LD_ADDR_VAR 0 59
90300: PUSH
90301: LD_INT 0
90303: PUSH
90304: LD_INT 0
90306: PUSH
90307: EMPTY
90308: LIST
90309: LIST
90310: PUSH
90311: LD_INT 0
90313: PUSH
90314: LD_INT 1
90316: NEG
90317: PUSH
90318: EMPTY
90319: LIST
90320: LIST
90321: PUSH
90322: LD_INT 1
90324: PUSH
90325: LD_INT 0
90327: PUSH
90328: EMPTY
90329: LIST
90330: LIST
90331: PUSH
90332: LD_INT 1
90334: PUSH
90335: LD_INT 1
90337: PUSH
90338: EMPTY
90339: LIST
90340: LIST
90341: PUSH
90342: LD_INT 0
90344: PUSH
90345: LD_INT 1
90347: PUSH
90348: EMPTY
90349: LIST
90350: LIST
90351: PUSH
90352: LD_INT 1
90354: NEG
90355: PUSH
90356: LD_INT 0
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: PUSH
90363: LD_INT 1
90365: NEG
90366: PUSH
90367: LD_INT 1
90369: NEG
90370: PUSH
90371: EMPTY
90372: LIST
90373: LIST
90374: PUSH
90375: EMPTY
90376: LIST
90377: LIST
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90384: LD_ADDR_VAR 0 60
90388: PUSH
90389: LD_INT 0
90391: PUSH
90392: LD_INT 0
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: LD_INT 0
90401: PUSH
90402: LD_INT 1
90404: NEG
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PUSH
90410: LD_INT 1
90412: PUSH
90413: LD_INT 0
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PUSH
90420: LD_INT 1
90422: PUSH
90423: LD_INT 1
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: LD_INT 0
90432: PUSH
90433: LD_INT 1
90435: PUSH
90436: EMPTY
90437: LIST
90438: LIST
90439: PUSH
90440: LD_INT 1
90442: NEG
90443: PUSH
90444: LD_INT 0
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: PUSH
90451: LD_INT 1
90453: NEG
90454: PUSH
90455: LD_INT 1
90457: NEG
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: LIST
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90472: LD_ADDR_VAR 0 61
90476: PUSH
90477: LD_INT 0
90479: PUSH
90480: LD_INT 0
90482: PUSH
90483: EMPTY
90484: LIST
90485: LIST
90486: PUSH
90487: LD_INT 0
90489: PUSH
90490: LD_INT 1
90492: NEG
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: PUSH
90498: LD_INT 1
90500: PUSH
90501: LD_INT 0
90503: PUSH
90504: EMPTY
90505: LIST
90506: LIST
90507: PUSH
90508: LD_INT 1
90510: PUSH
90511: LD_INT 1
90513: PUSH
90514: EMPTY
90515: LIST
90516: LIST
90517: PUSH
90518: LD_INT 0
90520: PUSH
90521: LD_INT 1
90523: PUSH
90524: EMPTY
90525: LIST
90526: LIST
90527: PUSH
90528: LD_INT 1
90530: NEG
90531: PUSH
90532: LD_INT 0
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: LD_INT 1
90541: NEG
90542: PUSH
90543: LD_INT 1
90545: NEG
90546: PUSH
90547: EMPTY
90548: LIST
90549: LIST
90550: PUSH
90551: EMPTY
90552: LIST
90553: LIST
90554: LIST
90555: LIST
90556: LIST
90557: LIST
90558: LIST
90559: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90560: LD_ADDR_VAR 0 62
90564: PUSH
90565: LD_INT 0
90567: PUSH
90568: LD_INT 0
90570: PUSH
90571: EMPTY
90572: LIST
90573: LIST
90574: PUSH
90575: LD_INT 0
90577: PUSH
90578: LD_INT 1
90580: NEG
90581: PUSH
90582: EMPTY
90583: LIST
90584: LIST
90585: PUSH
90586: LD_INT 1
90588: PUSH
90589: LD_INT 0
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 1
90598: PUSH
90599: LD_INT 1
90601: PUSH
90602: EMPTY
90603: LIST
90604: LIST
90605: PUSH
90606: LD_INT 0
90608: PUSH
90609: LD_INT 1
90611: PUSH
90612: EMPTY
90613: LIST
90614: LIST
90615: PUSH
90616: LD_INT 1
90618: NEG
90619: PUSH
90620: LD_INT 0
90622: PUSH
90623: EMPTY
90624: LIST
90625: LIST
90626: PUSH
90627: LD_INT 1
90629: NEG
90630: PUSH
90631: LD_INT 1
90633: NEG
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: EMPTY
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90648: LD_ADDR_VAR 0 63
90652: PUSH
90653: LD_INT 0
90655: PUSH
90656: LD_INT 0
90658: PUSH
90659: EMPTY
90660: LIST
90661: LIST
90662: PUSH
90663: LD_INT 0
90665: PUSH
90666: LD_INT 1
90668: NEG
90669: PUSH
90670: EMPTY
90671: LIST
90672: LIST
90673: PUSH
90674: LD_INT 1
90676: PUSH
90677: LD_INT 0
90679: PUSH
90680: EMPTY
90681: LIST
90682: LIST
90683: PUSH
90684: LD_INT 1
90686: PUSH
90687: LD_INT 1
90689: PUSH
90690: EMPTY
90691: LIST
90692: LIST
90693: PUSH
90694: LD_INT 0
90696: PUSH
90697: LD_INT 1
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: PUSH
90704: LD_INT 1
90706: NEG
90707: PUSH
90708: LD_INT 0
90710: PUSH
90711: EMPTY
90712: LIST
90713: LIST
90714: PUSH
90715: LD_INT 1
90717: NEG
90718: PUSH
90719: LD_INT 1
90721: NEG
90722: PUSH
90723: EMPTY
90724: LIST
90725: LIST
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: LIST
90731: LIST
90732: LIST
90733: LIST
90734: LIST
90735: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90736: LD_ADDR_VAR 0 64
90740: PUSH
90741: LD_INT 0
90743: PUSH
90744: LD_INT 0
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: PUSH
90751: LD_INT 0
90753: PUSH
90754: LD_INT 1
90756: NEG
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: PUSH
90762: LD_INT 1
90764: PUSH
90765: LD_INT 0
90767: PUSH
90768: EMPTY
90769: LIST
90770: LIST
90771: PUSH
90772: LD_INT 1
90774: PUSH
90775: LD_INT 1
90777: PUSH
90778: EMPTY
90779: LIST
90780: LIST
90781: PUSH
90782: LD_INT 0
90784: PUSH
90785: LD_INT 1
90787: PUSH
90788: EMPTY
90789: LIST
90790: LIST
90791: PUSH
90792: LD_INT 1
90794: NEG
90795: PUSH
90796: LD_INT 0
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 1
90805: NEG
90806: PUSH
90807: LD_INT 1
90809: NEG
90810: PUSH
90811: EMPTY
90812: LIST
90813: LIST
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: LIST
90819: LIST
90820: LIST
90821: LIST
90822: LIST
90823: ST_TO_ADDR
// end ; 1 :
90824: GO 96721
90826: LD_INT 1
90828: DOUBLE
90829: EQUAL
90830: IFTRUE 90834
90832: GO 93457
90834: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
90835: LD_ADDR_VAR 0 11
90839: PUSH
90840: LD_INT 1
90842: NEG
90843: PUSH
90844: LD_INT 3
90846: NEG
90847: PUSH
90848: EMPTY
90849: LIST
90850: LIST
90851: PUSH
90852: LD_INT 0
90854: PUSH
90855: LD_INT 3
90857: NEG
90858: PUSH
90859: EMPTY
90860: LIST
90861: LIST
90862: PUSH
90863: LD_INT 1
90865: PUSH
90866: LD_INT 2
90868: NEG
90869: PUSH
90870: EMPTY
90871: LIST
90872: LIST
90873: PUSH
90874: EMPTY
90875: LIST
90876: LIST
90877: LIST
90878: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
90879: LD_ADDR_VAR 0 12
90883: PUSH
90884: LD_INT 2
90886: PUSH
90887: LD_INT 1
90889: NEG
90890: PUSH
90891: EMPTY
90892: LIST
90893: LIST
90894: PUSH
90895: LD_INT 3
90897: PUSH
90898: LD_INT 0
90900: PUSH
90901: EMPTY
90902: LIST
90903: LIST
90904: PUSH
90905: LD_INT 3
90907: PUSH
90908: LD_INT 1
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: EMPTY
90916: LIST
90917: LIST
90918: LIST
90919: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90920: LD_ADDR_VAR 0 13
90924: PUSH
90925: LD_INT 3
90927: PUSH
90928: LD_INT 2
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 3
90937: PUSH
90938: LD_INT 3
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: LD_INT 2
90947: PUSH
90948: LD_INT 3
90950: PUSH
90951: EMPTY
90952: LIST
90953: LIST
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: LIST
90959: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90960: LD_ADDR_VAR 0 14
90964: PUSH
90965: LD_INT 1
90967: PUSH
90968: LD_INT 3
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: PUSH
90975: LD_INT 0
90977: PUSH
90978: LD_INT 3
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: LD_INT 1
90987: NEG
90988: PUSH
90989: LD_INT 2
90991: PUSH
90992: EMPTY
90993: LIST
90994: LIST
90995: PUSH
90996: EMPTY
90997: LIST
90998: LIST
90999: LIST
91000: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91001: LD_ADDR_VAR 0 15
91005: PUSH
91006: LD_INT 2
91008: NEG
91009: PUSH
91010: LD_INT 1
91012: PUSH
91013: EMPTY
91014: LIST
91015: LIST
91016: PUSH
91017: LD_INT 3
91019: NEG
91020: PUSH
91021: LD_INT 0
91023: PUSH
91024: EMPTY
91025: LIST
91026: LIST
91027: PUSH
91028: LD_INT 3
91030: NEG
91031: PUSH
91032: LD_INT 1
91034: NEG
91035: PUSH
91036: EMPTY
91037: LIST
91038: LIST
91039: PUSH
91040: EMPTY
91041: LIST
91042: LIST
91043: LIST
91044: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91045: LD_ADDR_VAR 0 16
91049: PUSH
91050: LD_INT 2
91052: NEG
91053: PUSH
91054: LD_INT 3
91056: NEG
91057: PUSH
91058: EMPTY
91059: LIST
91060: LIST
91061: PUSH
91062: LD_INT 3
91064: NEG
91065: PUSH
91066: LD_INT 2
91068: NEG
91069: PUSH
91070: EMPTY
91071: LIST
91072: LIST
91073: PUSH
91074: LD_INT 3
91076: NEG
91077: PUSH
91078: LD_INT 3
91080: NEG
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: EMPTY
91087: LIST
91088: LIST
91089: LIST
91090: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91091: LD_ADDR_VAR 0 17
91095: PUSH
91096: LD_INT 1
91098: NEG
91099: PUSH
91100: LD_INT 3
91102: NEG
91103: PUSH
91104: EMPTY
91105: LIST
91106: LIST
91107: PUSH
91108: LD_INT 0
91110: PUSH
91111: LD_INT 3
91113: NEG
91114: PUSH
91115: EMPTY
91116: LIST
91117: LIST
91118: PUSH
91119: LD_INT 1
91121: PUSH
91122: LD_INT 2
91124: NEG
91125: PUSH
91126: EMPTY
91127: LIST
91128: LIST
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: LIST
91134: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91135: LD_ADDR_VAR 0 18
91139: PUSH
91140: LD_INT 2
91142: PUSH
91143: LD_INT 1
91145: NEG
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: PUSH
91151: LD_INT 3
91153: PUSH
91154: LD_INT 0
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: PUSH
91161: LD_INT 3
91163: PUSH
91164: LD_INT 1
91166: PUSH
91167: EMPTY
91168: LIST
91169: LIST
91170: PUSH
91171: EMPTY
91172: LIST
91173: LIST
91174: LIST
91175: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91176: LD_ADDR_VAR 0 19
91180: PUSH
91181: LD_INT 3
91183: PUSH
91184: LD_INT 2
91186: PUSH
91187: EMPTY
91188: LIST
91189: LIST
91190: PUSH
91191: LD_INT 3
91193: PUSH
91194: LD_INT 3
91196: PUSH
91197: EMPTY
91198: LIST
91199: LIST
91200: PUSH
91201: LD_INT 2
91203: PUSH
91204: LD_INT 3
91206: PUSH
91207: EMPTY
91208: LIST
91209: LIST
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: LIST
91215: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91216: LD_ADDR_VAR 0 20
91220: PUSH
91221: LD_INT 1
91223: PUSH
91224: LD_INT 3
91226: PUSH
91227: EMPTY
91228: LIST
91229: LIST
91230: PUSH
91231: LD_INT 0
91233: PUSH
91234: LD_INT 3
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 1
91243: NEG
91244: PUSH
91245: LD_INT 2
91247: PUSH
91248: EMPTY
91249: LIST
91250: LIST
91251: PUSH
91252: EMPTY
91253: LIST
91254: LIST
91255: LIST
91256: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91257: LD_ADDR_VAR 0 21
91261: PUSH
91262: LD_INT 2
91264: NEG
91265: PUSH
91266: LD_INT 1
91268: PUSH
91269: EMPTY
91270: LIST
91271: LIST
91272: PUSH
91273: LD_INT 3
91275: NEG
91276: PUSH
91277: LD_INT 0
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: LD_INT 3
91286: NEG
91287: PUSH
91288: LD_INT 1
91290: NEG
91291: PUSH
91292: EMPTY
91293: LIST
91294: LIST
91295: PUSH
91296: EMPTY
91297: LIST
91298: LIST
91299: LIST
91300: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91301: LD_ADDR_VAR 0 22
91305: PUSH
91306: LD_INT 2
91308: NEG
91309: PUSH
91310: LD_INT 3
91312: NEG
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: PUSH
91318: LD_INT 3
91320: NEG
91321: PUSH
91322: LD_INT 2
91324: NEG
91325: PUSH
91326: EMPTY
91327: LIST
91328: LIST
91329: PUSH
91330: LD_INT 3
91332: NEG
91333: PUSH
91334: LD_INT 3
91336: NEG
91337: PUSH
91338: EMPTY
91339: LIST
91340: LIST
91341: PUSH
91342: EMPTY
91343: LIST
91344: LIST
91345: LIST
91346: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91347: LD_ADDR_VAR 0 23
91351: PUSH
91352: LD_INT 0
91354: PUSH
91355: LD_INT 3
91357: NEG
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: PUSH
91363: LD_INT 1
91365: NEG
91366: PUSH
91367: LD_INT 4
91369: NEG
91370: PUSH
91371: EMPTY
91372: LIST
91373: LIST
91374: PUSH
91375: LD_INT 1
91377: PUSH
91378: LD_INT 3
91380: NEG
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: PUSH
91386: EMPTY
91387: LIST
91388: LIST
91389: LIST
91390: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
91391: LD_ADDR_VAR 0 24
91395: PUSH
91396: LD_INT 3
91398: PUSH
91399: LD_INT 0
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 3
91408: PUSH
91409: LD_INT 1
91411: NEG
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PUSH
91417: LD_INT 4
91419: PUSH
91420: LD_INT 1
91422: PUSH
91423: EMPTY
91424: LIST
91425: LIST
91426: PUSH
91427: EMPTY
91428: LIST
91429: LIST
91430: LIST
91431: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
91432: LD_ADDR_VAR 0 25
91436: PUSH
91437: LD_INT 3
91439: PUSH
91440: LD_INT 3
91442: PUSH
91443: EMPTY
91444: LIST
91445: LIST
91446: PUSH
91447: LD_INT 4
91449: PUSH
91450: LD_INT 3
91452: PUSH
91453: EMPTY
91454: LIST
91455: LIST
91456: PUSH
91457: LD_INT 3
91459: PUSH
91460: LD_INT 4
91462: PUSH
91463: EMPTY
91464: LIST
91465: LIST
91466: PUSH
91467: EMPTY
91468: LIST
91469: LIST
91470: LIST
91471: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
91472: LD_ADDR_VAR 0 26
91476: PUSH
91477: LD_INT 0
91479: PUSH
91480: LD_INT 3
91482: PUSH
91483: EMPTY
91484: LIST
91485: LIST
91486: PUSH
91487: LD_INT 1
91489: PUSH
91490: LD_INT 4
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: PUSH
91497: LD_INT 1
91499: NEG
91500: PUSH
91501: LD_INT 3
91503: PUSH
91504: EMPTY
91505: LIST
91506: LIST
91507: PUSH
91508: EMPTY
91509: LIST
91510: LIST
91511: LIST
91512: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
91513: LD_ADDR_VAR 0 27
91517: PUSH
91518: LD_INT 3
91520: NEG
91521: PUSH
91522: LD_INT 0
91524: PUSH
91525: EMPTY
91526: LIST
91527: LIST
91528: PUSH
91529: LD_INT 3
91531: NEG
91532: PUSH
91533: LD_INT 1
91535: PUSH
91536: EMPTY
91537: LIST
91538: LIST
91539: PUSH
91540: LD_INT 4
91542: NEG
91543: PUSH
91544: LD_INT 1
91546: NEG
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: PUSH
91552: EMPTY
91553: LIST
91554: LIST
91555: LIST
91556: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
91557: LD_ADDR_VAR 0 28
91561: PUSH
91562: LD_INT 3
91564: NEG
91565: PUSH
91566: LD_INT 3
91568: NEG
91569: PUSH
91570: EMPTY
91571: LIST
91572: LIST
91573: PUSH
91574: LD_INT 3
91576: NEG
91577: PUSH
91578: LD_INT 4
91580: NEG
91581: PUSH
91582: EMPTY
91583: LIST
91584: LIST
91585: PUSH
91586: LD_INT 4
91588: NEG
91589: PUSH
91590: LD_INT 3
91592: NEG
91593: PUSH
91594: EMPTY
91595: LIST
91596: LIST
91597: PUSH
91598: EMPTY
91599: LIST
91600: LIST
91601: LIST
91602: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
91603: LD_ADDR_VAR 0 29
91607: PUSH
91608: LD_INT 1
91610: NEG
91611: PUSH
91612: LD_INT 3
91614: NEG
91615: PUSH
91616: EMPTY
91617: LIST
91618: LIST
91619: PUSH
91620: LD_INT 0
91622: PUSH
91623: LD_INT 3
91625: NEG
91626: PUSH
91627: EMPTY
91628: LIST
91629: LIST
91630: PUSH
91631: LD_INT 1
91633: PUSH
91634: LD_INT 2
91636: NEG
91637: PUSH
91638: EMPTY
91639: LIST
91640: LIST
91641: PUSH
91642: LD_INT 1
91644: NEG
91645: PUSH
91646: LD_INT 4
91648: NEG
91649: PUSH
91650: EMPTY
91651: LIST
91652: LIST
91653: PUSH
91654: LD_INT 0
91656: PUSH
91657: LD_INT 4
91659: NEG
91660: PUSH
91661: EMPTY
91662: LIST
91663: LIST
91664: PUSH
91665: LD_INT 1
91667: PUSH
91668: LD_INT 3
91670: NEG
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: PUSH
91676: LD_INT 1
91678: NEG
91679: PUSH
91680: LD_INT 5
91682: NEG
91683: PUSH
91684: EMPTY
91685: LIST
91686: LIST
91687: PUSH
91688: LD_INT 0
91690: PUSH
91691: LD_INT 5
91693: NEG
91694: PUSH
91695: EMPTY
91696: LIST
91697: LIST
91698: PUSH
91699: LD_INT 1
91701: PUSH
91702: LD_INT 4
91704: NEG
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: PUSH
91710: LD_INT 1
91712: NEG
91713: PUSH
91714: LD_INT 6
91716: NEG
91717: PUSH
91718: EMPTY
91719: LIST
91720: LIST
91721: PUSH
91722: LD_INT 0
91724: PUSH
91725: LD_INT 6
91727: NEG
91728: PUSH
91729: EMPTY
91730: LIST
91731: LIST
91732: PUSH
91733: LD_INT 1
91735: PUSH
91736: LD_INT 5
91738: NEG
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: PUSH
91744: EMPTY
91745: LIST
91746: LIST
91747: LIST
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
91758: LD_ADDR_VAR 0 30
91762: PUSH
91763: LD_INT 2
91765: PUSH
91766: LD_INT 1
91768: NEG
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: PUSH
91774: LD_INT 3
91776: PUSH
91777: LD_INT 0
91779: PUSH
91780: EMPTY
91781: LIST
91782: LIST
91783: PUSH
91784: LD_INT 3
91786: PUSH
91787: LD_INT 1
91789: PUSH
91790: EMPTY
91791: LIST
91792: LIST
91793: PUSH
91794: LD_INT 3
91796: PUSH
91797: LD_INT 1
91799: NEG
91800: PUSH
91801: EMPTY
91802: LIST
91803: LIST
91804: PUSH
91805: LD_INT 4
91807: PUSH
91808: LD_INT 0
91810: PUSH
91811: EMPTY
91812: LIST
91813: LIST
91814: PUSH
91815: LD_INT 4
91817: PUSH
91818: LD_INT 1
91820: PUSH
91821: EMPTY
91822: LIST
91823: LIST
91824: PUSH
91825: LD_INT 4
91827: PUSH
91828: LD_INT 1
91830: NEG
91831: PUSH
91832: EMPTY
91833: LIST
91834: LIST
91835: PUSH
91836: LD_INT 5
91838: PUSH
91839: LD_INT 0
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: PUSH
91846: LD_INT 5
91848: PUSH
91849: LD_INT 1
91851: PUSH
91852: EMPTY
91853: LIST
91854: LIST
91855: PUSH
91856: LD_INT 5
91858: PUSH
91859: LD_INT 1
91861: NEG
91862: PUSH
91863: EMPTY
91864: LIST
91865: LIST
91866: PUSH
91867: LD_INT 6
91869: PUSH
91870: LD_INT 0
91872: PUSH
91873: EMPTY
91874: LIST
91875: LIST
91876: PUSH
91877: LD_INT 6
91879: PUSH
91880: LD_INT 1
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: LIST
91899: LIST
91900: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
91901: LD_ADDR_VAR 0 31
91905: PUSH
91906: LD_INT 3
91908: PUSH
91909: LD_INT 2
91911: PUSH
91912: EMPTY
91913: LIST
91914: LIST
91915: PUSH
91916: LD_INT 3
91918: PUSH
91919: LD_INT 3
91921: PUSH
91922: EMPTY
91923: LIST
91924: LIST
91925: PUSH
91926: LD_INT 2
91928: PUSH
91929: LD_INT 3
91931: PUSH
91932: EMPTY
91933: LIST
91934: LIST
91935: PUSH
91936: LD_INT 4
91938: PUSH
91939: LD_INT 3
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: PUSH
91946: LD_INT 4
91948: PUSH
91949: LD_INT 4
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: PUSH
91956: LD_INT 3
91958: PUSH
91959: LD_INT 4
91961: PUSH
91962: EMPTY
91963: LIST
91964: LIST
91965: PUSH
91966: LD_INT 5
91968: PUSH
91969: LD_INT 4
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: PUSH
91976: LD_INT 5
91978: PUSH
91979: LD_INT 5
91981: PUSH
91982: EMPTY
91983: LIST
91984: LIST
91985: PUSH
91986: LD_INT 4
91988: PUSH
91989: LD_INT 5
91991: PUSH
91992: EMPTY
91993: LIST
91994: LIST
91995: PUSH
91996: LD_INT 6
91998: PUSH
91999: LD_INT 5
92001: PUSH
92002: EMPTY
92003: LIST
92004: LIST
92005: PUSH
92006: LD_INT 6
92008: PUSH
92009: LD_INT 6
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PUSH
92016: LD_INT 5
92018: PUSH
92019: LD_INT 6
92021: PUSH
92022: EMPTY
92023: LIST
92024: LIST
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92040: LD_ADDR_VAR 0 32
92044: PUSH
92045: LD_INT 1
92047: PUSH
92048: LD_INT 3
92050: PUSH
92051: EMPTY
92052: LIST
92053: LIST
92054: PUSH
92055: LD_INT 0
92057: PUSH
92058: LD_INT 3
92060: PUSH
92061: EMPTY
92062: LIST
92063: LIST
92064: PUSH
92065: LD_INT 1
92067: NEG
92068: PUSH
92069: LD_INT 2
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: LD_INT 1
92078: PUSH
92079: LD_INT 4
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 0
92088: PUSH
92089: LD_INT 4
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 1
92098: NEG
92099: PUSH
92100: LD_INT 3
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: PUSH
92107: LD_INT 1
92109: PUSH
92110: LD_INT 5
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: LD_INT 0
92119: PUSH
92120: LD_INT 5
92122: PUSH
92123: EMPTY
92124: LIST
92125: LIST
92126: PUSH
92127: LD_INT 1
92129: NEG
92130: PUSH
92131: LD_INT 4
92133: PUSH
92134: EMPTY
92135: LIST
92136: LIST
92137: PUSH
92138: LD_INT 1
92140: PUSH
92141: LD_INT 6
92143: PUSH
92144: EMPTY
92145: LIST
92146: LIST
92147: PUSH
92148: LD_INT 0
92150: PUSH
92151: LD_INT 6
92153: PUSH
92154: EMPTY
92155: LIST
92156: LIST
92157: PUSH
92158: LD_INT 1
92160: NEG
92161: PUSH
92162: LD_INT 5
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: PUSH
92169: EMPTY
92170: LIST
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92183: LD_ADDR_VAR 0 33
92187: PUSH
92188: LD_INT 2
92190: NEG
92191: PUSH
92192: LD_INT 1
92194: PUSH
92195: EMPTY
92196: LIST
92197: LIST
92198: PUSH
92199: LD_INT 3
92201: NEG
92202: PUSH
92203: LD_INT 0
92205: PUSH
92206: EMPTY
92207: LIST
92208: LIST
92209: PUSH
92210: LD_INT 3
92212: NEG
92213: PUSH
92214: LD_INT 1
92216: NEG
92217: PUSH
92218: EMPTY
92219: LIST
92220: LIST
92221: PUSH
92222: LD_INT 3
92224: NEG
92225: PUSH
92226: LD_INT 1
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: LD_INT 4
92235: NEG
92236: PUSH
92237: LD_INT 0
92239: PUSH
92240: EMPTY
92241: LIST
92242: LIST
92243: PUSH
92244: LD_INT 4
92246: NEG
92247: PUSH
92248: LD_INT 1
92250: NEG
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: PUSH
92256: LD_INT 4
92258: NEG
92259: PUSH
92260: LD_INT 1
92262: PUSH
92263: EMPTY
92264: LIST
92265: LIST
92266: PUSH
92267: LD_INT 5
92269: NEG
92270: PUSH
92271: LD_INT 0
92273: PUSH
92274: EMPTY
92275: LIST
92276: LIST
92277: PUSH
92278: LD_INT 5
92280: NEG
92281: PUSH
92282: LD_INT 1
92284: NEG
92285: PUSH
92286: EMPTY
92287: LIST
92288: LIST
92289: PUSH
92290: LD_INT 5
92292: NEG
92293: PUSH
92294: LD_INT 1
92296: PUSH
92297: EMPTY
92298: LIST
92299: LIST
92300: PUSH
92301: LD_INT 6
92303: NEG
92304: PUSH
92305: LD_INT 0
92307: PUSH
92308: EMPTY
92309: LIST
92310: LIST
92311: PUSH
92312: LD_INT 6
92314: NEG
92315: PUSH
92316: LD_INT 1
92318: NEG
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: LIST
92328: LIST
92329: LIST
92330: LIST
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92338: LD_ADDR_VAR 0 34
92342: PUSH
92343: LD_INT 2
92345: NEG
92346: PUSH
92347: LD_INT 3
92349: NEG
92350: PUSH
92351: EMPTY
92352: LIST
92353: LIST
92354: PUSH
92355: LD_INT 3
92357: NEG
92358: PUSH
92359: LD_INT 2
92361: NEG
92362: PUSH
92363: EMPTY
92364: LIST
92365: LIST
92366: PUSH
92367: LD_INT 3
92369: NEG
92370: PUSH
92371: LD_INT 3
92373: NEG
92374: PUSH
92375: EMPTY
92376: LIST
92377: LIST
92378: PUSH
92379: LD_INT 3
92381: NEG
92382: PUSH
92383: LD_INT 4
92385: NEG
92386: PUSH
92387: EMPTY
92388: LIST
92389: LIST
92390: PUSH
92391: LD_INT 4
92393: NEG
92394: PUSH
92395: LD_INT 3
92397: NEG
92398: PUSH
92399: EMPTY
92400: LIST
92401: LIST
92402: PUSH
92403: LD_INT 4
92405: NEG
92406: PUSH
92407: LD_INT 4
92409: NEG
92410: PUSH
92411: EMPTY
92412: LIST
92413: LIST
92414: PUSH
92415: LD_INT 4
92417: NEG
92418: PUSH
92419: LD_INT 5
92421: NEG
92422: PUSH
92423: EMPTY
92424: LIST
92425: LIST
92426: PUSH
92427: LD_INT 5
92429: NEG
92430: PUSH
92431: LD_INT 4
92433: NEG
92434: PUSH
92435: EMPTY
92436: LIST
92437: LIST
92438: PUSH
92439: LD_INT 5
92441: NEG
92442: PUSH
92443: LD_INT 5
92445: NEG
92446: PUSH
92447: EMPTY
92448: LIST
92449: LIST
92450: PUSH
92451: LD_INT 5
92453: NEG
92454: PUSH
92455: LD_INT 6
92457: NEG
92458: PUSH
92459: EMPTY
92460: LIST
92461: LIST
92462: PUSH
92463: LD_INT 6
92465: NEG
92466: PUSH
92467: LD_INT 5
92469: NEG
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 6
92477: NEG
92478: PUSH
92479: LD_INT 6
92481: NEG
92482: PUSH
92483: EMPTY
92484: LIST
92485: LIST
92486: PUSH
92487: EMPTY
92488: LIST
92489: LIST
92490: LIST
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: LIST
92499: LIST
92500: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
92501: LD_ADDR_VAR 0 41
92505: PUSH
92506: LD_INT 0
92508: PUSH
92509: LD_INT 2
92511: NEG
92512: PUSH
92513: EMPTY
92514: LIST
92515: LIST
92516: PUSH
92517: LD_INT 1
92519: NEG
92520: PUSH
92521: LD_INT 3
92523: NEG
92524: PUSH
92525: EMPTY
92526: LIST
92527: LIST
92528: PUSH
92529: LD_INT 1
92531: PUSH
92532: LD_INT 2
92534: NEG
92535: PUSH
92536: EMPTY
92537: LIST
92538: LIST
92539: PUSH
92540: EMPTY
92541: LIST
92542: LIST
92543: LIST
92544: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
92545: LD_ADDR_VAR 0 42
92549: PUSH
92550: LD_INT 2
92552: PUSH
92553: LD_INT 0
92555: PUSH
92556: EMPTY
92557: LIST
92558: LIST
92559: PUSH
92560: LD_INT 2
92562: PUSH
92563: LD_INT 1
92565: NEG
92566: PUSH
92567: EMPTY
92568: LIST
92569: LIST
92570: PUSH
92571: LD_INT 3
92573: PUSH
92574: LD_INT 1
92576: PUSH
92577: EMPTY
92578: LIST
92579: LIST
92580: PUSH
92581: EMPTY
92582: LIST
92583: LIST
92584: LIST
92585: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
92586: LD_ADDR_VAR 0 43
92590: PUSH
92591: LD_INT 2
92593: PUSH
92594: LD_INT 2
92596: PUSH
92597: EMPTY
92598: LIST
92599: LIST
92600: PUSH
92601: LD_INT 3
92603: PUSH
92604: LD_INT 2
92606: PUSH
92607: EMPTY
92608: LIST
92609: LIST
92610: PUSH
92611: LD_INT 2
92613: PUSH
92614: LD_INT 3
92616: PUSH
92617: EMPTY
92618: LIST
92619: LIST
92620: PUSH
92621: EMPTY
92622: LIST
92623: LIST
92624: LIST
92625: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
92626: LD_ADDR_VAR 0 44
92630: PUSH
92631: LD_INT 0
92633: PUSH
92634: LD_INT 2
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 1
92643: PUSH
92644: LD_INT 3
92646: PUSH
92647: EMPTY
92648: LIST
92649: LIST
92650: PUSH
92651: LD_INT 1
92653: NEG
92654: PUSH
92655: LD_INT 2
92657: PUSH
92658: EMPTY
92659: LIST
92660: LIST
92661: PUSH
92662: EMPTY
92663: LIST
92664: LIST
92665: LIST
92666: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
92667: LD_ADDR_VAR 0 45
92671: PUSH
92672: LD_INT 2
92674: NEG
92675: PUSH
92676: LD_INT 0
92678: PUSH
92679: EMPTY
92680: LIST
92681: LIST
92682: PUSH
92683: LD_INT 2
92685: NEG
92686: PUSH
92687: LD_INT 1
92689: PUSH
92690: EMPTY
92691: LIST
92692: LIST
92693: PUSH
92694: LD_INT 3
92696: NEG
92697: PUSH
92698: LD_INT 1
92700: NEG
92701: PUSH
92702: EMPTY
92703: LIST
92704: LIST
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: LIST
92710: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
92711: LD_ADDR_VAR 0 46
92715: PUSH
92716: LD_INT 2
92718: NEG
92719: PUSH
92720: LD_INT 2
92722: NEG
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: PUSH
92728: LD_INT 2
92730: NEG
92731: PUSH
92732: LD_INT 3
92734: NEG
92735: PUSH
92736: EMPTY
92737: LIST
92738: LIST
92739: PUSH
92740: LD_INT 3
92742: NEG
92743: PUSH
92744: LD_INT 2
92746: NEG
92747: PUSH
92748: EMPTY
92749: LIST
92750: LIST
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: LIST
92756: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
92757: LD_ADDR_VAR 0 47
92761: PUSH
92762: LD_INT 2
92764: NEG
92765: PUSH
92766: LD_INT 3
92768: NEG
92769: PUSH
92770: EMPTY
92771: LIST
92772: LIST
92773: PUSH
92774: LD_INT 1
92776: NEG
92777: PUSH
92778: LD_INT 3
92780: NEG
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: PUSH
92786: EMPTY
92787: LIST
92788: LIST
92789: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
92790: LD_ADDR_VAR 0 48
92794: PUSH
92795: LD_INT 1
92797: PUSH
92798: LD_INT 2
92800: NEG
92801: PUSH
92802: EMPTY
92803: LIST
92804: LIST
92805: PUSH
92806: LD_INT 2
92808: PUSH
92809: LD_INT 1
92811: NEG
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
92821: LD_ADDR_VAR 0 49
92825: PUSH
92826: LD_INT 3
92828: PUSH
92829: LD_INT 1
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: PUSH
92836: LD_INT 3
92838: PUSH
92839: LD_INT 2
92841: PUSH
92842: EMPTY
92843: LIST
92844: LIST
92845: PUSH
92846: EMPTY
92847: LIST
92848: LIST
92849: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
92850: LD_ADDR_VAR 0 50
92854: PUSH
92855: LD_INT 2
92857: PUSH
92858: LD_INT 3
92860: PUSH
92861: EMPTY
92862: LIST
92863: LIST
92864: PUSH
92865: LD_INT 1
92867: PUSH
92868: LD_INT 3
92870: PUSH
92871: EMPTY
92872: LIST
92873: LIST
92874: PUSH
92875: EMPTY
92876: LIST
92877: LIST
92878: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
92879: LD_ADDR_VAR 0 51
92883: PUSH
92884: LD_INT 1
92886: NEG
92887: PUSH
92888: LD_INT 2
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 2
92897: NEG
92898: PUSH
92899: LD_INT 1
92901: PUSH
92902: EMPTY
92903: LIST
92904: LIST
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
92910: LD_ADDR_VAR 0 52
92914: PUSH
92915: LD_INT 3
92917: NEG
92918: PUSH
92919: LD_INT 1
92921: NEG
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PUSH
92927: LD_INT 3
92929: NEG
92930: PUSH
92931: LD_INT 2
92933: NEG
92934: PUSH
92935: EMPTY
92936: LIST
92937: LIST
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92943: LD_ADDR_VAR 0 53
92947: PUSH
92948: LD_INT 1
92950: NEG
92951: PUSH
92952: LD_INT 3
92954: NEG
92955: PUSH
92956: EMPTY
92957: LIST
92958: LIST
92959: PUSH
92960: LD_INT 0
92962: PUSH
92963: LD_INT 3
92965: NEG
92966: PUSH
92967: EMPTY
92968: LIST
92969: LIST
92970: PUSH
92971: LD_INT 1
92973: PUSH
92974: LD_INT 2
92976: NEG
92977: PUSH
92978: EMPTY
92979: LIST
92980: LIST
92981: PUSH
92982: EMPTY
92983: LIST
92984: LIST
92985: LIST
92986: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92987: LD_ADDR_VAR 0 54
92991: PUSH
92992: LD_INT 2
92994: PUSH
92995: LD_INT 1
92997: NEG
92998: PUSH
92999: EMPTY
93000: LIST
93001: LIST
93002: PUSH
93003: LD_INT 3
93005: PUSH
93006: LD_INT 0
93008: PUSH
93009: EMPTY
93010: LIST
93011: LIST
93012: PUSH
93013: LD_INT 3
93015: PUSH
93016: LD_INT 1
93018: PUSH
93019: EMPTY
93020: LIST
93021: LIST
93022: PUSH
93023: EMPTY
93024: LIST
93025: LIST
93026: LIST
93027: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93028: LD_ADDR_VAR 0 55
93032: PUSH
93033: LD_INT 3
93035: PUSH
93036: LD_INT 2
93038: PUSH
93039: EMPTY
93040: LIST
93041: LIST
93042: PUSH
93043: LD_INT 3
93045: PUSH
93046: LD_INT 3
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: LD_INT 2
93055: PUSH
93056: LD_INT 3
93058: PUSH
93059: EMPTY
93060: LIST
93061: LIST
93062: PUSH
93063: EMPTY
93064: LIST
93065: LIST
93066: LIST
93067: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93068: LD_ADDR_VAR 0 56
93072: PUSH
93073: LD_INT 1
93075: PUSH
93076: LD_INT 3
93078: PUSH
93079: EMPTY
93080: LIST
93081: LIST
93082: PUSH
93083: LD_INT 0
93085: PUSH
93086: LD_INT 3
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: PUSH
93093: LD_INT 1
93095: NEG
93096: PUSH
93097: LD_INT 2
93099: PUSH
93100: EMPTY
93101: LIST
93102: LIST
93103: PUSH
93104: EMPTY
93105: LIST
93106: LIST
93107: LIST
93108: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93109: LD_ADDR_VAR 0 57
93113: PUSH
93114: LD_INT 2
93116: NEG
93117: PUSH
93118: LD_INT 1
93120: PUSH
93121: EMPTY
93122: LIST
93123: LIST
93124: PUSH
93125: LD_INT 3
93127: NEG
93128: PUSH
93129: LD_INT 0
93131: PUSH
93132: EMPTY
93133: LIST
93134: LIST
93135: PUSH
93136: LD_INT 3
93138: NEG
93139: PUSH
93140: LD_INT 1
93142: NEG
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: EMPTY
93149: LIST
93150: LIST
93151: LIST
93152: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93153: LD_ADDR_VAR 0 58
93157: PUSH
93158: LD_INT 2
93160: NEG
93161: PUSH
93162: LD_INT 3
93164: NEG
93165: PUSH
93166: EMPTY
93167: LIST
93168: LIST
93169: PUSH
93170: LD_INT 3
93172: NEG
93173: PUSH
93174: LD_INT 2
93176: NEG
93177: PUSH
93178: EMPTY
93179: LIST
93180: LIST
93181: PUSH
93182: LD_INT 3
93184: NEG
93185: PUSH
93186: LD_INT 3
93188: NEG
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: EMPTY
93195: LIST
93196: LIST
93197: LIST
93198: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93199: LD_ADDR_VAR 0 59
93203: PUSH
93204: LD_INT 1
93206: NEG
93207: PUSH
93208: LD_INT 2
93210: NEG
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PUSH
93216: LD_INT 0
93218: PUSH
93219: LD_INT 2
93221: NEG
93222: PUSH
93223: EMPTY
93224: LIST
93225: LIST
93226: PUSH
93227: LD_INT 1
93229: PUSH
93230: LD_INT 1
93232: NEG
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: EMPTY
93239: LIST
93240: LIST
93241: LIST
93242: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93243: LD_ADDR_VAR 0 60
93247: PUSH
93248: LD_INT 1
93250: PUSH
93251: LD_INT 1
93253: NEG
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PUSH
93259: LD_INT 2
93261: PUSH
93262: LD_INT 0
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PUSH
93269: LD_INT 2
93271: PUSH
93272: LD_INT 1
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: EMPTY
93280: LIST
93281: LIST
93282: LIST
93283: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93284: LD_ADDR_VAR 0 61
93288: PUSH
93289: LD_INT 2
93291: PUSH
93292: LD_INT 1
93294: PUSH
93295: EMPTY
93296: LIST
93297: LIST
93298: PUSH
93299: LD_INT 2
93301: PUSH
93302: LD_INT 2
93304: PUSH
93305: EMPTY
93306: LIST
93307: LIST
93308: PUSH
93309: LD_INT 1
93311: PUSH
93312: LD_INT 2
93314: PUSH
93315: EMPTY
93316: LIST
93317: LIST
93318: PUSH
93319: EMPTY
93320: LIST
93321: LIST
93322: LIST
93323: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93324: LD_ADDR_VAR 0 62
93328: PUSH
93329: LD_INT 1
93331: PUSH
93332: LD_INT 2
93334: PUSH
93335: EMPTY
93336: LIST
93337: LIST
93338: PUSH
93339: LD_INT 0
93341: PUSH
93342: LD_INT 2
93344: PUSH
93345: EMPTY
93346: LIST
93347: LIST
93348: PUSH
93349: LD_INT 1
93351: NEG
93352: PUSH
93353: LD_INT 1
93355: PUSH
93356: EMPTY
93357: LIST
93358: LIST
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: LIST
93364: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93365: LD_ADDR_VAR 0 63
93369: PUSH
93370: LD_INT 1
93372: NEG
93373: PUSH
93374: LD_INT 1
93376: PUSH
93377: EMPTY
93378: LIST
93379: LIST
93380: PUSH
93381: LD_INT 2
93383: NEG
93384: PUSH
93385: LD_INT 0
93387: PUSH
93388: EMPTY
93389: LIST
93390: LIST
93391: PUSH
93392: LD_INT 2
93394: NEG
93395: PUSH
93396: LD_INT 1
93398: NEG
93399: PUSH
93400: EMPTY
93401: LIST
93402: LIST
93403: PUSH
93404: EMPTY
93405: LIST
93406: LIST
93407: LIST
93408: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93409: LD_ADDR_VAR 0 64
93413: PUSH
93414: LD_INT 1
93416: NEG
93417: PUSH
93418: LD_INT 2
93420: NEG
93421: PUSH
93422: EMPTY
93423: LIST
93424: LIST
93425: PUSH
93426: LD_INT 2
93428: NEG
93429: PUSH
93430: LD_INT 1
93432: NEG
93433: PUSH
93434: EMPTY
93435: LIST
93436: LIST
93437: PUSH
93438: LD_INT 2
93440: NEG
93441: PUSH
93442: LD_INT 2
93444: NEG
93445: PUSH
93446: EMPTY
93447: LIST
93448: LIST
93449: PUSH
93450: EMPTY
93451: LIST
93452: LIST
93453: LIST
93454: ST_TO_ADDR
// end ; 2 :
93455: GO 96721
93457: LD_INT 2
93459: DOUBLE
93460: EQUAL
93461: IFTRUE 93465
93463: GO 96720
93465: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
93466: LD_ADDR_VAR 0 29
93470: PUSH
93471: LD_INT 4
93473: PUSH
93474: LD_INT 0
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 4
93483: PUSH
93484: LD_INT 1
93486: NEG
93487: PUSH
93488: EMPTY
93489: LIST
93490: LIST
93491: PUSH
93492: LD_INT 5
93494: PUSH
93495: LD_INT 0
93497: PUSH
93498: EMPTY
93499: LIST
93500: LIST
93501: PUSH
93502: LD_INT 5
93504: PUSH
93505: LD_INT 1
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: PUSH
93512: LD_INT 4
93514: PUSH
93515: LD_INT 1
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: PUSH
93522: LD_INT 3
93524: PUSH
93525: LD_INT 0
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 3
93534: PUSH
93535: LD_INT 1
93537: NEG
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: PUSH
93543: LD_INT 3
93545: PUSH
93546: LD_INT 2
93548: NEG
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: PUSH
93554: LD_INT 5
93556: PUSH
93557: LD_INT 2
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 3
93566: PUSH
93567: LD_INT 3
93569: PUSH
93570: EMPTY
93571: LIST
93572: LIST
93573: PUSH
93574: LD_INT 3
93576: PUSH
93577: LD_INT 2
93579: PUSH
93580: EMPTY
93581: LIST
93582: LIST
93583: PUSH
93584: LD_INT 4
93586: PUSH
93587: LD_INT 3
93589: PUSH
93590: EMPTY
93591: LIST
93592: LIST
93593: PUSH
93594: LD_INT 4
93596: PUSH
93597: LD_INT 4
93599: PUSH
93600: EMPTY
93601: LIST
93602: LIST
93603: PUSH
93604: LD_INT 3
93606: PUSH
93607: LD_INT 4
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: PUSH
93614: LD_INT 2
93616: PUSH
93617: LD_INT 3
93619: PUSH
93620: EMPTY
93621: LIST
93622: LIST
93623: PUSH
93624: LD_INT 2
93626: PUSH
93627: LD_INT 2
93629: PUSH
93630: EMPTY
93631: LIST
93632: LIST
93633: PUSH
93634: LD_INT 4
93636: PUSH
93637: LD_INT 2
93639: PUSH
93640: EMPTY
93641: LIST
93642: LIST
93643: PUSH
93644: LD_INT 2
93646: PUSH
93647: LD_INT 4
93649: PUSH
93650: EMPTY
93651: LIST
93652: LIST
93653: PUSH
93654: LD_INT 0
93656: PUSH
93657: LD_INT 4
93659: PUSH
93660: EMPTY
93661: LIST
93662: LIST
93663: PUSH
93664: LD_INT 0
93666: PUSH
93667: LD_INT 3
93669: PUSH
93670: EMPTY
93671: LIST
93672: LIST
93673: PUSH
93674: LD_INT 1
93676: PUSH
93677: LD_INT 4
93679: PUSH
93680: EMPTY
93681: LIST
93682: LIST
93683: PUSH
93684: LD_INT 1
93686: PUSH
93687: LD_INT 5
93689: PUSH
93690: EMPTY
93691: LIST
93692: LIST
93693: PUSH
93694: LD_INT 0
93696: PUSH
93697: LD_INT 5
93699: PUSH
93700: EMPTY
93701: LIST
93702: LIST
93703: PUSH
93704: LD_INT 1
93706: NEG
93707: PUSH
93708: LD_INT 4
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: LD_INT 1
93717: NEG
93718: PUSH
93719: LD_INT 3
93721: PUSH
93722: EMPTY
93723: LIST
93724: LIST
93725: PUSH
93726: LD_INT 2
93728: PUSH
93729: LD_INT 5
93731: PUSH
93732: EMPTY
93733: LIST
93734: LIST
93735: PUSH
93736: LD_INT 2
93738: NEG
93739: PUSH
93740: LD_INT 3
93742: PUSH
93743: EMPTY
93744: LIST
93745: LIST
93746: PUSH
93747: LD_INT 3
93749: NEG
93750: PUSH
93751: LD_INT 0
93753: PUSH
93754: EMPTY
93755: LIST
93756: LIST
93757: PUSH
93758: LD_INT 3
93760: NEG
93761: PUSH
93762: LD_INT 1
93764: NEG
93765: PUSH
93766: EMPTY
93767: LIST
93768: LIST
93769: PUSH
93770: LD_INT 2
93772: NEG
93773: PUSH
93774: LD_INT 0
93776: PUSH
93777: EMPTY
93778: LIST
93779: LIST
93780: PUSH
93781: LD_INT 2
93783: NEG
93784: PUSH
93785: LD_INT 1
93787: PUSH
93788: EMPTY
93789: LIST
93790: LIST
93791: PUSH
93792: LD_INT 3
93794: NEG
93795: PUSH
93796: LD_INT 1
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PUSH
93803: LD_INT 4
93805: NEG
93806: PUSH
93807: LD_INT 0
93809: PUSH
93810: EMPTY
93811: LIST
93812: LIST
93813: PUSH
93814: LD_INT 4
93816: NEG
93817: PUSH
93818: LD_INT 1
93820: NEG
93821: PUSH
93822: EMPTY
93823: LIST
93824: LIST
93825: PUSH
93826: LD_INT 4
93828: NEG
93829: PUSH
93830: LD_INT 2
93832: NEG
93833: PUSH
93834: EMPTY
93835: LIST
93836: LIST
93837: PUSH
93838: LD_INT 2
93840: NEG
93841: PUSH
93842: LD_INT 2
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: PUSH
93849: LD_INT 4
93851: NEG
93852: PUSH
93853: LD_INT 4
93855: NEG
93856: PUSH
93857: EMPTY
93858: LIST
93859: LIST
93860: PUSH
93861: LD_INT 4
93863: NEG
93864: PUSH
93865: LD_INT 5
93867: NEG
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: PUSH
93873: LD_INT 3
93875: NEG
93876: PUSH
93877: LD_INT 4
93879: NEG
93880: PUSH
93881: EMPTY
93882: LIST
93883: LIST
93884: PUSH
93885: LD_INT 3
93887: NEG
93888: PUSH
93889: LD_INT 3
93891: NEG
93892: PUSH
93893: EMPTY
93894: LIST
93895: LIST
93896: PUSH
93897: LD_INT 4
93899: NEG
93900: PUSH
93901: LD_INT 3
93903: NEG
93904: PUSH
93905: EMPTY
93906: LIST
93907: LIST
93908: PUSH
93909: LD_INT 5
93911: NEG
93912: PUSH
93913: LD_INT 4
93915: NEG
93916: PUSH
93917: EMPTY
93918: LIST
93919: LIST
93920: PUSH
93921: LD_INT 5
93923: NEG
93924: PUSH
93925: LD_INT 5
93927: NEG
93928: PUSH
93929: EMPTY
93930: LIST
93931: LIST
93932: PUSH
93933: LD_INT 3
93935: NEG
93936: PUSH
93937: LD_INT 5
93939: NEG
93940: PUSH
93941: EMPTY
93942: LIST
93943: LIST
93944: PUSH
93945: LD_INT 5
93947: NEG
93948: PUSH
93949: LD_INT 3
93951: NEG
93952: PUSH
93953: EMPTY
93954: LIST
93955: LIST
93956: PUSH
93957: EMPTY
93958: LIST
93959: LIST
93960: LIST
93961: LIST
93962: LIST
93963: LIST
93964: LIST
93965: LIST
93966: LIST
93967: LIST
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: LIST
93980: LIST
93981: LIST
93982: LIST
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: LIST
93988: LIST
93989: LIST
93990: LIST
93991: LIST
93992: LIST
93993: LIST
93994: LIST
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94004: LD_ADDR_VAR 0 30
94008: PUSH
94009: LD_INT 4
94011: PUSH
94012: LD_INT 4
94014: PUSH
94015: EMPTY
94016: LIST
94017: LIST
94018: PUSH
94019: LD_INT 4
94021: PUSH
94022: LD_INT 3
94024: PUSH
94025: EMPTY
94026: LIST
94027: LIST
94028: PUSH
94029: LD_INT 5
94031: PUSH
94032: LD_INT 4
94034: PUSH
94035: EMPTY
94036: LIST
94037: LIST
94038: PUSH
94039: LD_INT 5
94041: PUSH
94042: LD_INT 5
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: PUSH
94049: LD_INT 4
94051: PUSH
94052: LD_INT 5
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 3
94061: PUSH
94062: LD_INT 4
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: LD_INT 3
94071: PUSH
94072: LD_INT 3
94074: PUSH
94075: EMPTY
94076: LIST
94077: LIST
94078: PUSH
94079: LD_INT 5
94081: PUSH
94082: LD_INT 3
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 3
94091: PUSH
94092: LD_INT 5
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PUSH
94099: LD_INT 0
94101: PUSH
94102: LD_INT 3
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: PUSH
94109: LD_INT 0
94111: PUSH
94112: LD_INT 2
94114: PUSH
94115: EMPTY
94116: LIST
94117: LIST
94118: PUSH
94119: LD_INT 1
94121: PUSH
94122: LD_INT 3
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: LD_INT 1
94131: PUSH
94132: LD_INT 4
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: PUSH
94139: LD_INT 0
94141: PUSH
94142: LD_INT 4
94144: PUSH
94145: EMPTY
94146: LIST
94147: LIST
94148: PUSH
94149: LD_INT 1
94151: NEG
94152: PUSH
94153: LD_INT 3
94155: PUSH
94156: EMPTY
94157: LIST
94158: LIST
94159: PUSH
94160: LD_INT 1
94162: NEG
94163: PUSH
94164: LD_INT 2
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: LD_INT 2
94173: PUSH
94174: LD_INT 4
94176: PUSH
94177: EMPTY
94178: LIST
94179: LIST
94180: PUSH
94181: LD_INT 2
94183: NEG
94184: PUSH
94185: LD_INT 2
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: PUSH
94192: LD_INT 4
94194: NEG
94195: PUSH
94196: LD_INT 0
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: PUSH
94203: LD_INT 4
94205: NEG
94206: PUSH
94207: LD_INT 1
94209: NEG
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: PUSH
94215: LD_INT 3
94217: NEG
94218: PUSH
94219: LD_INT 0
94221: PUSH
94222: EMPTY
94223: LIST
94224: LIST
94225: PUSH
94226: LD_INT 3
94228: NEG
94229: PUSH
94230: LD_INT 1
94232: PUSH
94233: EMPTY
94234: LIST
94235: LIST
94236: PUSH
94237: LD_INT 4
94239: NEG
94240: PUSH
94241: LD_INT 1
94243: PUSH
94244: EMPTY
94245: LIST
94246: LIST
94247: PUSH
94248: LD_INT 5
94250: NEG
94251: PUSH
94252: LD_INT 0
94254: PUSH
94255: EMPTY
94256: LIST
94257: LIST
94258: PUSH
94259: LD_INT 5
94261: NEG
94262: PUSH
94263: LD_INT 1
94265: NEG
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: LD_INT 5
94273: NEG
94274: PUSH
94275: LD_INT 2
94277: NEG
94278: PUSH
94279: EMPTY
94280: LIST
94281: LIST
94282: PUSH
94283: LD_INT 3
94285: NEG
94286: PUSH
94287: LD_INT 2
94289: PUSH
94290: EMPTY
94291: LIST
94292: LIST
94293: PUSH
94294: LD_INT 3
94296: NEG
94297: PUSH
94298: LD_INT 3
94300: NEG
94301: PUSH
94302: EMPTY
94303: LIST
94304: LIST
94305: PUSH
94306: LD_INT 3
94308: NEG
94309: PUSH
94310: LD_INT 4
94312: NEG
94313: PUSH
94314: EMPTY
94315: LIST
94316: LIST
94317: PUSH
94318: LD_INT 2
94320: NEG
94321: PUSH
94322: LD_INT 3
94324: NEG
94325: PUSH
94326: EMPTY
94327: LIST
94328: LIST
94329: PUSH
94330: LD_INT 2
94332: NEG
94333: PUSH
94334: LD_INT 2
94336: NEG
94337: PUSH
94338: EMPTY
94339: LIST
94340: LIST
94341: PUSH
94342: LD_INT 3
94344: NEG
94345: PUSH
94346: LD_INT 2
94348: NEG
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PUSH
94354: LD_INT 4
94356: NEG
94357: PUSH
94358: LD_INT 3
94360: NEG
94361: PUSH
94362: EMPTY
94363: LIST
94364: LIST
94365: PUSH
94366: LD_INT 4
94368: NEG
94369: PUSH
94370: LD_INT 4
94372: NEG
94373: PUSH
94374: EMPTY
94375: LIST
94376: LIST
94377: PUSH
94378: LD_INT 2
94380: NEG
94381: PUSH
94382: LD_INT 4
94384: NEG
94385: PUSH
94386: EMPTY
94387: LIST
94388: LIST
94389: PUSH
94390: LD_INT 4
94392: NEG
94393: PUSH
94394: LD_INT 2
94396: NEG
94397: PUSH
94398: EMPTY
94399: LIST
94400: LIST
94401: PUSH
94402: LD_INT 0
94404: PUSH
94405: LD_INT 4
94407: NEG
94408: PUSH
94409: EMPTY
94410: LIST
94411: LIST
94412: PUSH
94413: LD_INT 0
94415: PUSH
94416: LD_INT 5
94418: NEG
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: LD_INT 1
94426: PUSH
94427: LD_INT 4
94429: NEG
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: PUSH
94435: LD_INT 1
94437: PUSH
94438: LD_INT 3
94440: NEG
94441: PUSH
94442: EMPTY
94443: LIST
94444: LIST
94445: PUSH
94446: LD_INT 0
94448: PUSH
94449: LD_INT 3
94451: NEG
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 1
94459: NEG
94460: PUSH
94461: LD_INT 4
94463: NEG
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PUSH
94469: LD_INT 1
94471: NEG
94472: PUSH
94473: LD_INT 5
94475: NEG
94476: PUSH
94477: EMPTY
94478: LIST
94479: LIST
94480: PUSH
94481: LD_INT 2
94483: PUSH
94484: LD_INT 3
94486: NEG
94487: PUSH
94488: EMPTY
94489: LIST
94490: LIST
94491: PUSH
94492: LD_INT 2
94494: NEG
94495: PUSH
94496: LD_INT 5
94498: NEG
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: PUSH
94504: EMPTY
94505: LIST
94506: LIST
94507: LIST
94508: LIST
94509: LIST
94510: LIST
94511: LIST
94512: LIST
94513: LIST
94514: LIST
94515: LIST
94516: LIST
94517: LIST
94518: LIST
94519: LIST
94520: LIST
94521: LIST
94522: LIST
94523: LIST
94524: LIST
94525: LIST
94526: LIST
94527: LIST
94528: LIST
94529: LIST
94530: LIST
94531: LIST
94532: LIST
94533: LIST
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: LIST
94549: LIST
94550: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
94551: LD_ADDR_VAR 0 31
94555: PUSH
94556: LD_INT 0
94558: PUSH
94559: LD_INT 4
94561: PUSH
94562: EMPTY
94563: LIST
94564: LIST
94565: PUSH
94566: LD_INT 0
94568: PUSH
94569: LD_INT 3
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: PUSH
94576: LD_INT 1
94578: PUSH
94579: LD_INT 4
94581: PUSH
94582: EMPTY
94583: LIST
94584: LIST
94585: PUSH
94586: LD_INT 1
94588: PUSH
94589: LD_INT 5
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: LD_INT 0
94598: PUSH
94599: LD_INT 5
94601: PUSH
94602: EMPTY
94603: LIST
94604: LIST
94605: PUSH
94606: LD_INT 1
94608: NEG
94609: PUSH
94610: LD_INT 4
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: PUSH
94617: LD_INT 1
94619: NEG
94620: PUSH
94621: LD_INT 3
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: PUSH
94628: LD_INT 2
94630: PUSH
94631: LD_INT 5
94633: PUSH
94634: EMPTY
94635: LIST
94636: LIST
94637: PUSH
94638: LD_INT 2
94640: NEG
94641: PUSH
94642: LD_INT 3
94644: PUSH
94645: EMPTY
94646: LIST
94647: LIST
94648: PUSH
94649: LD_INT 3
94651: NEG
94652: PUSH
94653: LD_INT 0
94655: PUSH
94656: EMPTY
94657: LIST
94658: LIST
94659: PUSH
94660: LD_INT 3
94662: NEG
94663: PUSH
94664: LD_INT 1
94666: NEG
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: PUSH
94672: LD_INT 2
94674: NEG
94675: PUSH
94676: LD_INT 0
94678: PUSH
94679: EMPTY
94680: LIST
94681: LIST
94682: PUSH
94683: LD_INT 2
94685: NEG
94686: PUSH
94687: LD_INT 1
94689: PUSH
94690: EMPTY
94691: LIST
94692: LIST
94693: PUSH
94694: LD_INT 3
94696: NEG
94697: PUSH
94698: LD_INT 1
94700: PUSH
94701: EMPTY
94702: LIST
94703: LIST
94704: PUSH
94705: LD_INT 4
94707: NEG
94708: PUSH
94709: LD_INT 0
94711: PUSH
94712: EMPTY
94713: LIST
94714: LIST
94715: PUSH
94716: LD_INT 4
94718: NEG
94719: PUSH
94720: LD_INT 1
94722: NEG
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: LD_INT 4
94730: NEG
94731: PUSH
94732: LD_INT 2
94734: NEG
94735: PUSH
94736: EMPTY
94737: LIST
94738: LIST
94739: PUSH
94740: LD_INT 2
94742: NEG
94743: PUSH
94744: LD_INT 2
94746: PUSH
94747: EMPTY
94748: LIST
94749: LIST
94750: PUSH
94751: LD_INT 4
94753: NEG
94754: PUSH
94755: LD_INT 4
94757: NEG
94758: PUSH
94759: EMPTY
94760: LIST
94761: LIST
94762: PUSH
94763: LD_INT 4
94765: NEG
94766: PUSH
94767: LD_INT 5
94769: NEG
94770: PUSH
94771: EMPTY
94772: LIST
94773: LIST
94774: PUSH
94775: LD_INT 3
94777: NEG
94778: PUSH
94779: LD_INT 4
94781: NEG
94782: PUSH
94783: EMPTY
94784: LIST
94785: LIST
94786: PUSH
94787: LD_INT 3
94789: NEG
94790: PUSH
94791: LD_INT 3
94793: NEG
94794: PUSH
94795: EMPTY
94796: LIST
94797: LIST
94798: PUSH
94799: LD_INT 4
94801: NEG
94802: PUSH
94803: LD_INT 3
94805: NEG
94806: PUSH
94807: EMPTY
94808: LIST
94809: LIST
94810: PUSH
94811: LD_INT 5
94813: NEG
94814: PUSH
94815: LD_INT 4
94817: NEG
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PUSH
94823: LD_INT 5
94825: NEG
94826: PUSH
94827: LD_INT 5
94829: NEG
94830: PUSH
94831: EMPTY
94832: LIST
94833: LIST
94834: PUSH
94835: LD_INT 3
94837: NEG
94838: PUSH
94839: LD_INT 5
94841: NEG
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 5
94849: NEG
94850: PUSH
94851: LD_INT 3
94853: NEG
94854: PUSH
94855: EMPTY
94856: LIST
94857: LIST
94858: PUSH
94859: LD_INT 0
94861: PUSH
94862: LD_INT 3
94864: NEG
94865: PUSH
94866: EMPTY
94867: LIST
94868: LIST
94869: PUSH
94870: LD_INT 0
94872: PUSH
94873: LD_INT 4
94875: NEG
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: LD_INT 1
94883: PUSH
94884: LD_INT 3
94886: NEG
94887: PUSH
94888: EMPTY
94889: LIST
94890: LIST
94891: PUSH
94892: LD_INT 1
94894: PUSH
94895: LD_INT 2
94897: NEG
94898: PUSH
94899: EMPTY
94900: LIST
94901: LIST
94902: PUSH
94903: LD_INT 0
94905: PUSH
94906: LD_INT 2
94908: NEG
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: PUSH
94914: LD_INT 1
94916: NEG
94917: PUSH
94918: LD_INT 3
94920: NEG
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: PUSH
94926: LD_INT 1
94928: NEG
94929: PUSH
94930: LD_INT 4
94932: NEG
94933: PUSH
94934: EMPTY
94935: LIST
94936: LIST
94937: PUSH
94938: LD_INT 2
94940: PUSH
94941: LD_INT 2
94943: NEG
94944: PUSH
94945: EMPTY
94946: LIST
94947: LIST
94948: PUSH
94949: LD_INT 2
94951: NEG
94952: PUSH
94953: LD_INT 4
94955: NEG
94956: PUSH
94957: EMPTY
94958: LIST
94959: LIST
94960: PUSH
94961: LD_INT 4
94963: PUSH
94964: LD_INT 0
94966: PUSH
94967: EMPTY
94968: LIST
94969: LIST
94970: PUSH
94971: LD_INT 4
94973: PUSH
94974: LD_INT 1
94976: NEG
94977: PUSH
94978: EMPTY
94979: LIST
94980: LIST
94981: PUSH
94982: LD_INT 5
94984: PUSH
94985: LD_INT 0
94987: PUSH
94988: EMPTY
94989: LIST
94990: LIST
94991: PUSH
94992: LD_INT 5
94994: PUSH
94995: LD_INT 1
94997: PUSH
94998: EMPTY
94999: LIST
95000: LIST
95001: PUSH
95002: LD_INT 4
95004: PUSH
95005: LD_INT 1
95007: PUSH
95008: EMPTY
95009: LIST
95010: LIST
95011: PUSH
95012: LD_INT 3
95014: PUSH
95015: LD_INT 0
95017: PUSH
95018: EMPTY
95019: LIST
95020: LIST
95021: PUSH
95022: LD_INT 3
95024: PUSH
95025: LD_INT 1
95027: NEG
95028: PUSH
95029: EMPTY
95030: LIST
95031: LIST
95032: PUSH
95033: LD_INT 3
95035: PUSH
95036: LD_INT 2
95038: NEG
95039: PUSH
95040: EMPTY
95041: LIST
95042: LIST
95043: PUSH
95044: LD_INT 5
95046: PUSH
95047: LD_INT 2
95049: PUSH
95050: EMPTY
95051: LIST
95052: LIST
95053: PUSH
95054: EMPTY
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: LIST
95062: LIST
95063: LIST
95064: LIST
95065: LIST
95066: LIST
95067: LIST
95068: LIST
95069: LIST
95070: LIST
95071: LIST
95072: LIST
95073: LIST
95074: LIST
95075: LIST
95076: LIST
95077: LIST
95078: LIST
95079: LIST
95080: LIST
95081: LIST
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: LIST
95099: LIST
95100: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95101: LD_ADDR_VAR 0 32
95105: PUSH
95106: LD_INT 4
95108: NEG
95109: PUSH
95110: LD_INT 0
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: PUSH
95117: LD_INT 4
95119: NEG
95120: PUSH
95121: LD_INT 1
95123: NEG
95124: PUSH
95125: EMPTY
95126: LIST
95127: LIST
95128: PUSH
95129: LD_INT 3
95131: NEG
95132: PUSH
95133: LD_INT 0
95135: PUSH
95136: EMPTY
95137: LIST
95138: LIST
95139: PUSH
95140: LD_INT 3
95142: NEG
95143: PUSH
95144: LD_INT 1
95146: PUSH
95147: EMPTY
95148: LIST
95149: LIST
95150: PUSH
95151: LD_INT 4
95153: NEG
95154: PUSH
95155: LD_INT 1
95157: PUSH
95158: EMPTY
95159: LIST
95160: LIST
95161: PUSH
95162: LD_INT 5
95164: NEG
95165: PUSH
95166: LD_INT 0
95168: PUSH
95169: EMPTY
95170: LIST
95171: LIST
95172: PUSH
95173: LD_INT 5
95175: NEG
95176: PUSH
95177: LD_INT 1
95179: NEG
95180: PUSH
95181: EMPTY
95182: LIST
95183: LIST
95184: PUSH
95185: LD_INT 5
95187: NEG
95188: PUSH
95189: LD_INT 2
95191: NEG
95192: PUSH
95193: EMPTY
95194: LIST
95195: LIST
95196: PUSH
95197: LD_INT 3
95199: NEG
95200: PUSH
95201: LD_INT 2
95203: PUSH
95204: EMPTY
95205: LIST
95206: LIST
95207: PUSH
95208: LD_INT 3
95210: NEG
95211: PUSH
95212: LD_INT 3
95214: NEG
95215: PUSH
95216: EMPTY
95217: LIST
95218: LIST
95219: PUSH
95220: LD_INT 3
95222: NEG
95223: PUSH
95224: LD_INT 4
95226: NEG
95227: PUSH
95228: EMPTY
95229: LIST
95230: LIST
95231: PUSH
95232: LD_INT 2
95234: NEG
95235: PUSH
95236: LD_INT 3
95238: NEG
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: PUSH
95244: LD_INT 2
95246: NEG
95247: PUSH
95248: LD_INT 2
95250: NEG
95251: PUSH
95252: EMPTY
95253: LIST
95254: LIST
95255: PUSH
95256: LD_INT 3
95258: NEG
95259: PUSH
95260: LD_INT 2
95262: NEG
95263: PUSH
95264: EMPTY
95265: LIST
95266: LIST
95267: PUSH
95268: LD_INT 4
95270: NEG
95271: PUSH
95272: LD_INT 3
95274: NEG
95275: PUSH
95276: EMPTY
95277: LIST
95278: LIST
95279: PUSH
95280: LD_INT 4
95282: NEG
95283: PUSH
95284: LD_INT 4
95286: NEG
95287: PUSH
95288: EMPTY
95289: LIST
95290: LIST
95291: PUSH
95292: LD_INT 2
95294: NEG
95295: PUSH
95296: LD_INT 4
95298: NEG
95299: PUSH
95300: EMPTY
95301: LIST
95302: LIST
95303: PUSH
95304: LD_INT 4
95306: NEG
95307: PUSH
95308: LD_INT 2
95310: NEG
95311: PUSH
95312: EMPTY
95313: LIST
95314: LIST
95315: PUSH
95316: LD_INT 0
95318: PUSH
95319: LD_INT 4
95321: NEG
95322: PUSH
95323: EMPTY
95324: LIST
95325: LIST
95326: PUSH
95327: LD_INT 0
95329: PUSH
95330: LD_INT 5
95332: NEG
95333: PUSH
95334: EMPTY
95335: LIST
95336: LIST
95337: PUSH
95338: LD_INT 1
95340: PUSH
95341: LD_INT 4
95343: NEG
95344: PUSH
95345: EMPTY
95346: LIST
95347: LIST
95348: PUSH
95349: LD_INT 1
95351: PUSH
95352: LD_INT 3
95354: NEG
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PUSH
95360: LD_INT 0
95362: PUSH
95363: LD_INT 3
95365: NEG
95366: PUSH
95367: EMPTY
95368: LIST
95369: LIST
95370: PUSH
95371: LD_INT 1
95373: NEG
95374: PUSH
95375: LD_INT 4
95377: NEG
95378: PUSH
95379: EMPTY
95380: LIST
95381: LIST
95382: PUSH
95383: LD_INT 1
95385: NEG
95386: PUSH
95387: LD_INT 5
95389: NEG
95390: PUSH
95391: EMPTY
95392: LIST
95393: LIST
95394: PUSH
95395: LD_INT 2
95397: PUSH
95398: LD_INT 3
95400: NEG
95401: PUSH
95402: EMPTY
95403: LIST
95404: LIST
95405: PUSH
95406: LD_INT 2
95408: NEG
95409: PUSH
95410: LD_INT 5
95412: NEG
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 3
95420: PUSH
95421: LD_INT 0
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 3
95430: PUSH
95431: LD_INT 1
95433: NEG
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: PUSH
95439: LD_INT 4
95441: PUSH
95442: LD_INT 0
95444: PUSH
95445: EMPTY
95446: LIST
95447: LIST
95448: PUSH
95449: LD_INT 4
95451: PUSH
95452: LD_INT 1
95454: PUSH
95455: EMPTY
95456: LIST
95457: LIST
95458: PUSH
95459: LD_INT 3
95461: PUSH
95462: LD_INT 1
95464: PUSH
95465: EMPTY
95466: LIST
95467: LIST
95468: PUSH
95469: LD_INT 2
95471: PUSH
95472: LD_INT 0
95474: PUSH
95475: EMPTY
95476: LIST
95477: LIST
95478: PUSH
95479: LD_INT 2
95481: PUSH
95482: LD_INT 1
95484: NEG
95485: PUSH
95486: EMPTY
95487: LIST
95488: LIST
95489: PUSH
95490: LD_INT 2
95492: PUSH
95493: LD_INT 2
95495: NEG
95496: PUSH
95497: EMPTY
95498: LIST
95499: LIST
95500: PUSH
95501: LD_INT 4
95503: PUSH
95504: LD_INT 2
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: PUSH
95511: LD_INT 4
95513: PUSH
95514: LD_INT 4
95516: PUSH
95517: EMPTY
95518: LIST
95519: LIST
95520: PUSH
95521: LD_INT 4
95523: PUSH
95524: LD_INT 3
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PUSH
95531: LD_INT 5
95533: PUSH
95534: LD_INT 4
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: PUSH
95541: LD_INT 5
95543: PUSH
95544: LD_INT 5
95546: PUSH
95547: EMPTY
95548: LIST
95549: LIST
95550: PUSH
95551: LD_INT 4
95553: PUSH
95554: LD_INT 5
95556: PUSH
95557: EMPTY
95558: LIST
95559: LIST
95560: PUSH
95561: LD_INT 3
95563: PUSH
95564: LD_INT 4
95566: PUSH
95567: EMPTY
95568: LIST
95569: LIST
95570: PUSH
95571: LD_INT 3
95573: PUSH
95574: LD_INT 3
95576: PUSH
95577: EMPTY
95578: LIST
95579: LIST
95580: PUSH
95581: LD_INT 5
95583: PUSH
95584: LD_INT 3
95586: PUSH
95587: EMPTY
95588: LIST
95589: LIST
95590: PUSH
95591: LD_INT 3
95593: PUSH
95594: LD_INT 5
95596: PUSH
95597: EMPTY
95598: LIST
95599: LIST
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: LIST
95614: LIST
95615: LIST
95616: LIST
95617: LIST
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: LIST
95634: LIST
95635: LIST
95636: LIST
95637: LIST
95638: LIST
95639: LIST
95640: LIST
95641: LIST
95642: LIST
95643: LIST
95644: LIST
95645: LIST
95646: LIST
95647: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
95648: LD_ADDR_VAR 0 33
95652: PUSH
95653: LD_INT 4
95655: NEG
95656: PUSH
95657: LD_INT 4
95659: NEG
95660: PUSH
95661: EMPTY
95662: LIST
95663: LIST
95664: PUSH
95665: LD_INT 4
95667: NEG
95668: PUSH
95669: LD_INT 5
95671: NEG
95672: PUSH
95673: EMPTY
95674: LIST
95675: LIST
95676: PUSH
95677: LD_INT 3
95679: NEG
95680: PUSH
95681: LD_INT 4
95683: NEG
95684: PUSH
95685: EMPTY
95686: LIST
95687: LIST
95688: PUSH
95689: LD_INT 3
95691: NEG
95692: PUSH
95693: LD_INT 3
95695: NEG
95696: PUSH
95697: EMPTY
95698: LIST
95699: LIST
95700: PUSH
95701: LD_INT 4
95703: NEG
95704: PUSH
95705: LD_INT 3
95707: NEG
95708: PUSH
95709: EMPTY
95710: LIST
95711: LIST
95712: PUSH
95713: LD_INT 5
95715: NEG
95716: PUSH
95717: LD_INT 4
95719: NEG
95720: PUSH
95721: EMPTY
95722: LIST
95723: LIST
95724: PUSH
95725: LD_INT 5
95727: NEG
95728: PUSH
95729: LD_INT 5
95731: NEG
95732: PUSH
95733: EMPTY
95734: LIST
95735: LIST
95736: PUSH
95737: LD_INT 3
95739: NEG
95740: PUSH
95741: LD_INT 5
95743: NEG
95744: PUSH
95745: EMPTY
95746: LIST
95747: LIST
95748: PUSH
95749: LD_INT 5
95751: NEG
95752: PUSH
95753: LD_INT 3
95755: NEG
95756: PUSH
95757: EMPTY
95758: LIST
95759: LIST
95760: PUSH
95761: LD_INT 0
95763: PUSH
95764: LD_INT 3
95766: NEG
95767: PUSH
95768: EMPTY
95769: LIST
95770: LIST
95771: PUSH
95772: LD_INT 0
95774: PUSH
95775: LD_INT 4
95777: NEG
95778: PUSH
95779: EMPTY
95780: LIST
95781: LIST
95782: PUSH
95783: LD_INT 1
95785: PUSH
95786: LD_INT 3
95788: NEG
95789: PUSH
95790: EMPTY
95791: LIST
95792: LIST
95793: PUSH
95794: LD_INT 1
95796: PUSH
95797: LD_INT 2
95799: NEG
95800: PUSH
95801: EMPTY
95802: LIST
95803: LIST
95804: PUSH
95805: LD_INT 0
95807: PUSH
95808: LD_INT 2
95810: NEG
95811: PUSH
95812: EMPTY
95813: LIST
95814: LIST
95815: PUSH
95816: LD_INT 1
95818: NEG
95819: PUSH
95820: LD_INT 3
95822: NEG
95823: PUSH
95824: EMPTY
95825: LIST
95826: LIST
95827: PUSH
95828: LD_INT 1
95830: NEG
95831: PUSH
95832: LD_INT 4
95834: NEG
95835: PUSH
95836: EMPTY
95837: LIST
95838: LIST
95839: PUSH
95840: LD_INT 2
95842: PUSH
95843: LD_INT 2
95845: NEG
95846: PUSH
95847: EMPTY
95848: LIST
95849: LIST
95850: PUSH
95851: LD_INT 2
95853: NEG
95854: PUSH
95855: LD_INT 4
95857: NEG
95858: PUSH
95859: EMPTY
95860: LIST
95861: LIST
95862: PUSH
95863: LD_INT 4
95865: PUSH
95866: LD_INT 0
95868: PUSH
95869: EMPTY
95870: LIST
95871: LIST
95872: PUSH
95873: LD_INT 4
95875: PUSH
95876: LD_INT 1
95878: NEG
95879: PUSH
95880: EMPTY
95881: LIST
95882: LIST
95883: PUSH
95884: LD_INT 5
95886: PUSH
95887: LD_INT 0
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: PUSH
95894: LD_INT 5
95896: PUSH
95897: LD_INT 1
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: PUSH
95904: LD_INT 4
95906: PUSH
95907: LD_INT 1
95909: PUSH
95910: EMPTY
95911: LIST
95912: LIST
95913: PUSH
95914: LD_INT 3
95916: PUSH
95917: LD_INT 0
95919: PUSH
95920: EMPTY
95921: LIST
95922: LIST
95923: PUSH
95924: LD_INT 3
95926: PUSH
95927: LD_INT 1
95929: NEG
95930: PUSH
95931: EMPTY
95932: LIST
95933: LIST
95934: PUSH
95935: LD_INT 3
95937: PUSH
95938: LD_INT 2
95940: NEG
95941: PUSH
95942: EMPTY
95943: LIST
95944: LIST
95945: PUSH
95946: LD_INT 5
95948: PUSH
95949: LD_INT 2
95951: PUSH
95952: EMPTY
95953: LIST
95954: LIST
95955: PUSH
95956: LD_INT 3
95958: PUSH
95959: LD_INT 3
95961: PUSH
95962: EMPTY
95963: LIST
95964: LIST
95965: PUSH
95966: LD_INT 3
95968: PUSH
95969: LD_INT 2
95971: PUSH
95972: EMPTY
95973: LIST
95974: LIST
95975: PUSH
95976: LD_INT 4
95978: PUSH
95979: LD_INT 3
95981: PUSH
95982: EMPTY
95983: LIST
95984: LIST
95985: PUSH
95986: LD_INT 4
95988: PUSH
95989: LD_INT 4
95991: PUSH
95992: EMPTY
95993: LIST
95994: LIST
95995: PUSH
95996: LD_INT 3
95998: PUSH
95999: LD_INT 4
96001: PUSH
96002: EMPTY
96003: LIST
96004: LIST
96005: PUSH
96006: LD_INT 2
96008: PUSH
96009: LD_INT 3
96011: PUSH
96012: EMPTY
96013: LIST
96014: LIST
96015: PUSH
96016: LD_INT 2
96018: PUSH
96019: LD_INT 2
96021: PUSH
96022: EMPTY
96023: LIST
96024: LIST
96025: PUSH
96026: LD_INT 4
96028: PUSH
96029: LD_INT 2
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: PUSH
96036: LD_INT 2
96038: PUSH
96039: LD_INT 4
96041: PUSH
96042: EMPTY
96043: LIST
96044: LIST
96045: PUSH
96046: LD_INT 0
96048: PUSH
96049: LD_INT 4
96051: PUSH
96052: EMPTY
96053: LIST
96054: LIST
96055: PUSH
96056: LD_INT 0
96058: PUSH
96059: LD_INT 3
96061: PUSH
96062: EMPTY
96063: LIST
96064: LIST
96065: PUSH
96066: LD_INT 1
96068: PUSH
96069: LD_INT 4
96071: PUSH
96072: EMPTY
96073: LIST
96074: LIST
96075: PUSH
96076: LD_INT 1
96078: PUSH
96079: LD_INT 5
96081: PUSH
96082: EMPTY
96083: LIST
96084: LIST
96085: PUSH
96086: LD_INT 0
96088: PUSH
96089: LD_INT 5
96091: PUSH
96092: EMPTY
96093: LIST
96094: LIST
96095: PUSH
96096: LD_INT 1
96098: NEG
96099: PUSH
96100: LD_INT 4
96102: PUSH
96103: EMPTY
96104: LIST
96105: LIST
96106: PUSH
96107: LD_INT 1
96109: NEG
96110: PUSH
96111: LD_INT 3
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 2
96120: PUSH
96121: LD_INT 5
96123: PUSH
96124: EMPTY
96125: LIST
96126: LIST
96127: PUSH
96128: LD_INT 2
96130: NEG
96131: PUSH
96132: LD_INT 3
96134: PUSH
96135: EMPTY
96136: LIST
96137: LIST
96138: PUSH
96139: EMPTY
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: LIST
96149: LIST
96150: LIST
96151: LIST
96152: LIST
96153: LIST
96154: LIST
96155: LIST
96156: LIST
96157: LIST
96158: LIST
96159: LIST
96160: LIST
96161: LIST
96162: LIST
96163: LIST
96164: LIST
96165: LIST
96166: LIST
96167: LIST
96168: LIST
96169: LIST
96170: LIST
96171: LIST
96172: LIST
96173: LIST
96174: LIST
96175: LIST
96176: LIST
96177: LIST
96178: LIST
96179: LIST
96180: LIST
96181: LIST
96182: LIST
96183: LIST
96184: LIST
96185: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96186: LD_ADDR_VAR 0 34
96190: PUSH
96191: LD_INT 0
96193: PUSH
96194: LD_INT 4
96196: NEG
96197: PUSH
96198: EMPTY
96199: LIST
96200: LIST
96201: PUSH
96202: LD_INT 0
96204: PUSH
96205: LD_INT 5
96207: NEG
96208: PUSH
96209: EMPTY
96210: LIST
96211: LIST
96212: PUSH
96213: LD_INT 1
96215: PUSH
96216: LD_INT 4
96218: NEG
96219: PUSH
96220: EMPTY
96221: LIST
96222: LIST
96223: PUSH
96224: LD_INT 1
96226: PUSH
96227: LD_INT 3
96229: NEG
96230: PUSH
96231: EMPTY
96232: LIST
96233: LIST
96234: PUSH
96235: LD_INT 0
96237: PUSH
96238: LD_INT 3
96240: NEG
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: PUSH
96246: LD_INT 1
96248: NEG
96249: PUSH
96250: LD_INT 4
96252: NEG
96253: PUSH
96254: EMPTY
96255: LIST
96256: LIST
96257: PUSH
96258: LD_INT 1
96260: NEG
96261: PUSH
96262: LD_INT 5
96264: NEG
96265: PUSH
96266: EMPTY
96267: LIST
96268: LIST
96269: PUSH
96270: LD_INT 2
96272: PUSH
96273: LD_INT 3
96275: NEG
96276: PUSH
96277: EMPTY
96278: LIST
96279: LIST
96280: PUSH
96281: LD_INT 2
96283: NEG
96284: PUSH
96285: LD_INT 5
96287: NEG
96288: PUSH
96289: EMPTY
96290: LIST
96291: LIST
96292: PUSH
96293: LD_INT 3
96295: PUSH
96296: LD_INT 0
96298: PUSH
96299: EMPTY
96300: LIST
96301: LIST
96302: PUSH
96303: LD_INT 3
96305: PUSH
96306: LD_INT 1
96308: NEG
96309: PUSH
96310: EMPTY
96311: LIST
96312: LIST
96313: PUSH
96314: LD_INT 4
96316: PUSH
96317: LD_INT 0
96319: PUSH
96320: EMPTY
96321: LIST
96322: LIST
96323: PUSH
96324: LD_INT 4
96326: PUSH
96327: LD_INT 1
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: PUSH
96334: LD_INT 3
96336: PUSH
96337: LD_INT 1
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 2
96346: PUSH
96347: LD_INT 0
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: PUSH
96354: LD_INT 2
96356: PUSH
96357: LD_INT 1
96359: NEG
96360: PUSH
96361: EMPTY
96362: LIST
96363: LIST
96364: PUSH
96365: LD_INT 2
96367: PUSH
96368: LD_INT 2
96370: NEG
96371: PUSH
96372: EMPTY
96373: LIST
96374: LIST
96375: PUSH
96376: LD_INT 4
96378: PUSH
96379: LD_INT 2
96381: PUSH
96382: EMPTY
96383: LIST
96384: LIST
96385: PUSH
96386: LD_INT 4
96388: PUSH
96389: LD_INT 4
96391: PUSH
96392: EMPTY
96393: LIST
96394: LIST
96395: PUSH
96396: LD_INT 4
96398: PUSH
96399: LD_INT 3
96401: PUSH
96402: EMPTY
96403: LIST
96404: LIST
96405: PUSH
96406: LD_INT 5
96408: PUSH
96409: LD_INT 4
96411: PUSH
96412: EMPTY
96413: LIST
96414: LIST
96415: PUSH
96416: LD_INT 5
96418: PUSH
96419: LD_INT 5
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: PUSH
96426: LD_INT 4
96428: PUSH
96429: LD_INT 5
96431: PUSH
96432: EMPTY
96433: LIST
96434: LIST
96435: PUSH
96436: LD_INT 3
96438: PUSH
96439: LD_INT 4
96441: PUSH
96442: EMPTY
96443: LIST
96444: LIST
96445: PUSH
96446: LD_INT 3
96448: PUSH
96449: LD_INT 3
96451: PUSH
96452: EMPTY
96453: LIST
96454: LIST
96455: PUSH
96456: LD_INT 5
96458: PUSH
96459: LD_INT 3
96461: PUSH
96462: EMPTY
96463: LIST
96464: LIST
96465: PUSH
96466: LD_INT 3
96468: PUSH
96469: LD_INT 5
96471: PUSH
96472: EMPTY
96473: LIST
96474: LIST
96475: PUSH
96476: LD_INT 0
96478: PUSH
96479: LD_INT 3
96481: PUSH
96482: EMPTY
96483: LIST
96484: LIST
96485: PUSH
96486: LD_INT 0
96488: PUSH
96489: LD_INT 2
96491: PUSH
96492: EMPTY
96493: LIST
96494: LIST
96495: PUSH
96496: LD_INT 1
96498: PUSH
96499: LD_INT 3
96501: PUSH
96502: EMPTY
96503: LIST
96504: LIST
96505: PUSH
96506: LD_INT 1
96508: PUSH
96509: LD_INT 4
96511: PUSH
96512: EMPTY
96513: LIST
96514: LIST
96515: PUSH
96516: LD_INT 0
96518: PUSH
96519: LD_INT 4
96521: PUSH
96522: EMPTY
96523: LIST
96524: LIST
96525: PUSH
96526: LD_INT 1
96528: NEG
96529: PUSH
96530: LD_INT 3
96532: PUSH
96533: EMPTY
96534: LIST
96535: LIST
96536: PUSH
96537: LD_INT 1
96539: NEG
96540: PUSH
96541: LD_INT 2
96543: PUSH
96544: EMPTY
96545: LIST
96546: LIST
96547: PUSH
96548: LD_INT 2
96550: PUSH
96551: LD_INT 4
96553: PUSH
96554: EMPTY
96555: LIST
96556: LIST
96557: PUSH
96558: LD_INT 2
96560: NEG
96561: PUSH
96562: LD_INT 2
96564: PUSH
96565: EMPTY
96566: LIST
96567: LIST
96568: PUSH
96569: LD_INT 4
96571: NEG
96572: PUSH
96573: LD_INT 0
96575: PUSH
96576: EMPTY
96577: LIST
96578: LIST
96579: PUSH
96580: LD_INT 4
96582: NEG
96583: PUSH
96584: LD_INT 1
96586: NEG
96587: PUSH
96588: EMPTY
96589: LIST
96590: LIST
96591: PUSH
96592: LD_INT 3
96594: NEG
96595: PUSH
96596: LD_INT 0
96598: PUSH
96599: EMPTY
96600: LIST
96601: LIST
96602: PUSH
96603: LD_INT 3
96605: NEG
96606: PUSH
96607: LD_INT 1
96609: PUSH
96610: EMPTY
96611: LIST
96612: LIST
96613: PUSH
96614: LD_INT 4
96616: NEG
96617: PUSH
96618: LD_INT 1
96620: PUSH
96621: EMPTY
96622: LIST
96623: LIST
96624: PUSH
96625: LD_INT 5
96627: NEG
96628: PUSH
96629: LD_INT 0
96631: PUSH
96632: EMPTY
96633: LIST
96634: LIST
96635: PUSH
96636: LD_INT 5
96638: NEG
96639: PUSH
96640: LD_INT 1
96642: NEG
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PUSH
96648: LD_INT 5
96650: NEG
96651: PUSH
96652: LD_INT 2
96654: NEG
96655: PUSH
96656: EMPTY
96657: LIST
96658: LIST
96659: PUSH
96660: LD_INT 3
96662: NEG
96663: PUSH
96664: LD_INT 2
96666: PUSH
96667: EMPTY
96668: LIST
96669: LIST
96670: PUSH
96671: EMPTY
96672: LIST
96673: LIST
96674: LIST
96675: LIST
96676: LIST
96677: LIST
96678: LIST
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: LIST
96706: LIST
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: LIST
96714: LIST
96715: LIST
96716: LIST
96717: ST_TO_ADDR
// end ; end ;
96718: GO 96721
96720: POP
// case btype of b_depot , b_warehouse :
96721: LD_VAR 0 1
96725: PUSH
96726: LD_INT 0
96728: DOUBLE
96729: EQUAL
96730: IFTRUE 96740
96732: LD_INT 1
96734: DOUBLE
96735: EQUAL
96736: IFTRUE 96740
96738: GO 96941
96740: POP
// case nation of nation_american :
96741: LD_VAR 0 5
96745: PUSH
96746: LD_INT 1
96748: DOUBLE
96749: EQUAL
96750: IFTRUE 96754
96752: GO 96810
96754: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
96755: LD_ADDR_VAR 0 9
96759: PUSH
96760: LD_VAR 0 11
96764: PUSH
96765: LD_VAR 0 12
96769: PUSH
96770: LD_VAR 0 13
96774: PUSH
96775: LD_VAR 0 14
96779: PUSH
96780: LD_VAR 0 15
96784: PUSH
96785: LD_VAR 0 16
96789: PUSH
96790: EMPTY
96791: LIST
96792: LIST
96793: LIST
96794: LIST
96795: LIST
96796: LIST
96797: PUSH
96798: LD_VAR 0 4
96802: PUSH
96803: LD_INT 1
96805: PLUS
96806: ARRAY
96807: ST_TO_ADDR
96808: GO 96939
96810: LD_INT 2
96812: DOUBLE
96813: EQUAL
96814: IFTRUE 96818
96816: GO 96874
96818: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
96819: LD_ADDR_VAR 0 9
96823: PUSH
96824: LD_VAR 0 17
96828: PUSH
96829: LD_VAR 0 18
96833: PUSH
96834: LD_VAR 0 19
96838: PUSH
96839: LD_VAR 0 20
96843: PUSH
96844: LD_VAR 0 21
96848: PUSH
96849: LD_VAR 0 22
96853: PUSH
96854: EMPTY
96855: LIST
96856: LIST
96857: LIST
96858: LIST
96859: LIST
96860: LIST
96861: PUSH
96862: LD_VAR 0 4
96866: PUSH
96867: LD_INT 1
96869: PLUS
96870: ARRAY
96871: ST_TO_ADDR
96872: GO 96939
96874: LD_INT 3
96876: DOUBLE
96877: EQUAL
96878: IFTRUE 96882
96880: GO 96938
96882: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
96883: LD_ADDR_VAR 0 9
96887: PUSH
96888: LD_VAR 0 23
96892: PUSH
96893: LD_VAR 0 24
96897: PUSH
96898: LD_VAR 0 25
96902: PUSH
96903: LD_VAR 0 26
96907: PUSH
96908: LD_VAR 0 27
96912: PUSH
96913: LD_VAR 0 28
96917: PUSH
96918: EMPTY
96919: LIST
96920: LIST
96921: LIST
96922: LIST
96923: LIST
96924: LIST
96925: PUSH
96926: LD_VAR 0 4
96930: PUSH
96931: LD_INT 1
96933: PLUS
96934: ARRAY
96935: ST_TO_ADDR
96936: GO 96939
96938: POP
96939: GO 97494
96941: LD_INT 2
96943: DOUBLE
96944: EQUAL
96945: IFTRUE 96955
96947: LD_INT 3
96949: DOUBLE
96950: EQUAL
96951: IFTRUE 96955
96953: GO 97011
96955: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
96956: LD_ADDR_VAR 0 9
96960: PUSH
96961: LD_VAR 0 29
96965: PUSH
96966: LD_VAR 0 30
96970: PUSH
96971: LD_VAR 0 31
96975: PUSH
96976: LD_VAR 0 32
96980: PUSH
96981: LD_VAR 0 33
96985: PUSH
96986: LD_VAR 0 34
96990: PUSH
96991: EMPTY
96992: LIST
96993: LIST
96994: LIST
96995: LIST
96996: LIST
96997: LIST
96998: PUSH
96999: LD_VAR 0 4
97003: PUSH
97004: LD_INT 1
97006: PLUS
97007: ARRAY
97008: ST_TO_ADDR
97009: GO 97494
97011: LD_INT 16
97013: DOUBLE
97014: EQUAL
97015: IFTRUE 97073
97017: LD_INT 17
97019: DOUBLE
97020: EQUAL
97021: IFTRUE 97073
97023: LD_INT 18
97025: DOUBLE
97026: EQUAL
97027: IFTRUE 97073
97029: LD_INT 19
97031: DOUBLE
97032: EQUAL
97033: IFTRUE 97073
97035: LD_INT 22
97037: DOUBLE
97038: EQUAL
97039: IFTRUE 97073
97041: LD_INT 20
97043: DOUBLE
97044: EQUAL
97045: IFTRUE 97073
97047: LD_INT 21
97049: DOUBLE
97050: EQUAL
97051: IFTRUE 97073
97053: LD_INT 23
97055: DOUBLE
97056: EQUAL
97057: IFTRUE 97073
97059: LD_INT 24
97061: DOUBLE
97062: EQUAL
97063: IFTRUE 97073
97065: LD_INT 25
97067: DOUBLE
97068: EQUAL
97069: IFTRUE 97073
97071: GO 97129
97073: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97074: LD_ADDR_VAR 0 9
97078: PUSH
97079: LD_VAR 0 35
97083: PUSH
97084: LD_VAR 0 36
97088: PUSH
97089: LD_VAR 0 37
97093: PUSH
97094: LD_VAR 0 38
97098: PUSH
97099: LD_VAR 0 39
97103: PUSH
97104: LD_VAR 0 40
97108: PUSH
97109: EMPTY
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: PUSH
97117: LD_VAR 0 4
97121: PUSH
97122: LD_INT 1
97124: PLUS
97125: ARRAY
97126: ST_TO_ADDR
97127: GO 97494
97129: LD_INT 6
97131: DOUBLE
97132: EQUAL
97133: IFTRUE 97185
97135: LD_INT 7
97137: DOUBLE
97138: EQUAL
97139: IFTRUE 97185
97141: LD_INT 8
97143: DOUBLE
97144: EQUAL
97145: IFTRUE 97185
97147: LD_INT 13
97149: DOUBLE
97150: EQUAL
97151: IFTRUE 97185
97153: LD_INT 12
97155: DOUBLE
97156: EQUAL
97157: IFTRUE 97185
97159: LD_INT 15
97161: DOUBLE
97162: EQUAL
97163: IFTRUE 97185
97165: LD_INT 11
97167: DOUBLE
97168: EQUAL
97169: IFTRUE 97185
97171: LD_INT 14
97173: DOUBLE
97174: EQUAL
97175: IFTRUE 97185
97177: LD_INT 10
97179: DOUBLE
97180: EQUAL
97181: IFTRUE 97185
97183: GO 97241
97185: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
97186: LD_ADDR_VAR 0 9
97190: PUSH
97191: LD_VAR 0 41
97195: PUSH
97196: LD_VAR 0 42
97200: PUSH
97201: LD_VAR 0 43
97205: PUSH
97206: LD_VAR 0 44
97210: PUSH
97211: LD_VAR 0 45
97215: PUSH
97216: LD_VAR 0 46
97220: PUSH
97221: EMPTY
97222: LIST
97223: LIST
97224: LIST
97225: LIST
97226: LIST
97227: LIST
97228: PUSH
97229: LD_VAR 0 4
97233: PUSH
97234: LD_INT 1
97236: PLUS
97237: ARRAY
97238: ST_TO_ADDR
97239: GO 97494
97241: LD_INT 36
97243: DOUBLE
97244: EQUAL
97245: IFTRUE 97249
97247: GO 97305
97249: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97250: LD_ADDR_VAR 0 9
97254: PUSH
97255: LD_VAR 0 47
97259: PUSH
97260: LD_VAR 0 48
97264: PUSH
97265: LD_VAR 0 49
97269: PUSH
97270: LD_VAR 0 50
97274: PUSH
97275: LD_VAR 0 51
97279: PUSH
97280: LD_VAR 0 52
97284: PUSH
97285: EMPTY
97286: LIST
97287: LIST
97288: LIST
97289: LIST
97290: LIST
97291: LIST
97292: PUSH
97293: LD_VAR 0 4
97297: PUSH
97298: LD_INT 1
97300: PLUS
97301: ARRAY
97302: ST_TO_ADDR
97303: GO 97494
97305: LD_INT 4
97307: DOUBLE
97308: EQUAL
97309: IFTRUE 97331
97311: LD_INT 5
97313: DOUBLE
97314: EQUAL
97315: IFTRUE 97331
97317: LD_INT 34
97319: DOUBLE
97320: EQUAL
97321: IFTRUE 97331
97323: LD_INT 37
97325: DOUBLE
97326: EQUAL
97327: IFTRUE 97331
97329: GO 97387
97331: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97332: LD_ADDR_VAR 0 9
97336: PUSH
97337: LD_VAR 0 53
97341: PUSH
97342: LD_VAR 0 54
97346: PUSH
97347: LD_VAR 0 55
97351: PUSH
97352: LD_VAR 0 56
97356: PUSH
97357: LD_VAR 0 57
97361: PUSH
97362: LD_VAR 0 58
97366: PUSH
97367: EMPTY
97368: LIST
97369: LIST
97370: LIST
97371: LIST
97372: LIST
97373: LIST
97374: PUSH
97375: LD_VAR 0 4
97379: PUSH
97380: LD_INT 1
97382: PLUS
97383: ARRAY
97384: ST_TO_ADDR
97385: GO 97494
97387: LD_INT 31
97389: DOUBLE
97390: EQUAL
97391: IFTRUE 97437
97393: LD_INT 32
97395: DOUBLE
97396: EQUAL
97397: IFTRUE 97437
97399: LD_INT 33
97401: DOUBLE
97402: EQUAL
97403: IFTRUE 97437
97405: LD_INT 27
97407: DOUBLE
97408: EQUAL
97409: IFTRUE 97437
97411: LD_INT 26
97413: DOUBLE
97414: EQUAL
97415: IFTRUE 97437
97417: LD_INT 28
97419: DOUBLE
97420: EQUAL
97421: IFTRUE 97437
97423: LD_INT 29
97425: DOUBLE
97426: EQUAL
97427: IFTRUE 97437
97429: LD_INT 30
97431: DOUBLE
97432: EQUAL
97433: IFTRUE 97437
97435: GO 97493
97437: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
97438: LD_ADDR_VAR 0 9
97442: PUSH
97443: LD_VAR 0 59
97447: PUSH
97448: LD_VAR 0 60
97452: PUSH
97453: LD_VAR 0 61
97457: PUSH
97458: LD_VAR 0 62
97462: PUSH
97463: LD_VAR 0 63
97467: PUSH
97468: LD_VAR 0 64
97472: PUSH
97473: EMPTY
97474: LIST
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: PUSH
97481: LD_VAR 0 4
97485: PUSH
97486: LD_INT 1
97488: PLUS
97489: ARRAY
97490: ST_TO_ADDR
97491: GO 97494
97493: POP
// temp_list2 = [ ] ;
97494: LD_ADDR_VAR 0 10
97498: PUSH
97499: EMPTY
97500: ST_TO_ADDR
// for i in temp_list do
97501: LD_ADDR_VAR 0 8
97505: PUSH
97506: LD_VAR 0 9
97510: PUSH
97511: FOR_IN
97512: IFFALSE 97564
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
97514: LD_ADDR_VAR 0 10
97518: PUSH
97519: LD_VAR 0 10
97523: PUSH
97524: LD_VAR 0 8
97528: PUSH
97529: LD_INT 1
97531: ARRAY
97532: PUSH
97533: LD_VAR 0 2
97537: PLUS
97538: PUSH
97539: LD_VAR 0 8
97543: PUSH
97544: LD_INT 2
97546: ARRAY
97547: PUSH
97548: LD_VAR 0 3
97552: PLUS
97553: PUSH
97554: EMPTY
97555: LIST
97556: LIST
97557: PUSH
97558: EMPTY
97559: LIST
97560: ADD
97561: ST_TO_ADDR
97562: GO 97511
97564: POP
97565: POP
// result = temp_list2 ;
97566: LD_ADDR_VAR 0 7
97570: PUSH
97571: LD_VAR 0 10
97575: ST_TO_ADDR
// end ;
97576: LD_VAR 0 7
97580: RET
// export function EnemyInRange ( unit , dist ) ; begin
97581: LD_INT 0
97583: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
97584: LD_ADDR_VAR 0 3
97588: PUSH
97589: LD_VAR 0 1
97593: PPUSH
97594: CALL_OW 255
97598: PPUSH
97599: LD_VAR 0 1
97603: PPUSH
97604: CALL_OW 250
97608: PPUSH
97609: LD_VAR 0 1
97613: PPUSH
97614: CALL_OW 251
97618: PPUSH
97619: LD_VAR 0 2
97623: PPUSH
97624: CALL 71685 0 4
97628: PUSH
97629: LD_INT 4
97631: ARRAY
97632: ST_TO_ADDR
// end ;
97633: LD_VAR 0 3
97637: RET
// export function PlayerSeeMe ( unit ) ; begin
97638: LD_INT 0
97640: PPUSH
// result := See ( your_side , unit ) ;
97641: LD_ADDR_VAR 0 2
97645: PUSH
97646: LD_OWVAR 2
97650: PPUSH
97651: LD_VAR 0 1
97655: PPUSH
97656: CALL_OW 292
97660: ST_TO_ADDR
// end ;
97661: LD_VAR 0 2
97665: RET
// export function ReverseDir ( unit ) ; begin
97666: LD_INT 0
97668: PPUSH
// if not unit then
97669: LD_VAR 0 1
97673: NOT
97674: IFFALSE 97678
// exit ;
97676: GO 97724
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
97678: LD_ADDR_VAR 0 2
97682: PUSH
97683: LD_INT 3
97685: PUSH
97686: LD_INT 4
97688: PUSH
97689: LD_INT 5
97691: PUSH
97692: LD_INT 0
97694: PUSH
97695: LD_INT 1
97697: PUSH
97698: LD_INT 2
97700: PUSH
97701: EMPTY
97702: LIST
97703: LIST
97704: LIST
97705: LIST
97706: LIST
97707: LIST
97708: PUSH
97709: LD_VAR 0 1
97713: PPUSH
97714: CALL_OW 254
97718: PUSH
97719: LD_INT 1
97721: PLUS
97722: ARRAY
97723: ST_TO_ADDR
// end ;
97724: LD_VAR 0 2
97728: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
97729: LD_INT 0
97731: PPUSH
97732: PPUSH
97733: PPUSH
97734: PPUSH
97735: PPUSH
// if not hexes then
97736: LD_VAR 0 2
97740: NOT
97741: IFFALSE 97745
// exit ;
97743: GO 97893
// dist := 9999 ;
97745: LD_ADDR_VAR 0 5
97749: PUSH
97750: LD_INT 9999
97752: ST_TO_ADDR
// for i = 1 to hexes do
97753: LD_ADDR_VAR 0 4
97757: PUSH
97758: DOUBLE
97759: LD_INT 1
97761: DEC
97762: ST_TO_ADDR
97763: LD_VAR 0 2
97767: PUSH
97768: FOR_TO
97769: IFFALSE 97881
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
97771: LD_VAR 0 1
97775: PPUSH
97776: LD_VAR 0 2
97780: PUSH
97781: LD_VAR 0 4
97785: ARRAY
97786: PUSH
97787: LD_INT 1
97789: ARRAY
97790: PPUSH
97791: LD_VAR 0 2
97795: PUSH
97796: LD_VAR 0 4
97800: ARRAY
97801: PUSH
97802: LD_INT 2
97804: ARRAY
97805: PPUSH
97806: CALL_OW 297
97810: PUSH
97811: LD_VAR 0 5
97815: LESS
97816: IFFALSE 97879
// begin hex := hexes [ i ] ;
97818: LD_ADDR_VAR 0 7
97822: PUSH
97823: LD_VAR 0 2
97827: PUSH
97828: LD_VAR 0 4
97832: ARRAY
97833: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
97834: LD_ADDR_VAR 0 5
97838: PUSH
97839: LD_VAR 0 1
97843: PPUSH
97844: LD_VAR 0 2
97848: PUSH
97849: LD_VAR 0 4
97853: ARRAY
97854: PUSH
97855: LD_INT 1
97857: ARRAY
97858: PPUSH
97859: LD_VAR 0 2
97863: PUSH
97864: LD_VAR 0 4
97868: ARRAY
97869: PUSH
97870: LD_INT 2
97872: ARRAY
97873: PPUSH
97874: CALL_OW 297
97878: ST_TO_ADDR
// end ; end ;
97879: GO 97768
97881: POP
97882: POP
// result := hex ;
97883: LD_ADDR_VAR 0 3
97887: PUSH
97888: LD_VAR 0 7
97892: ST_TO_ADDR
// end ;
97893: LD_VAR 0 3
97897: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
97898: LD_INT 0
97900: PPUSH
97901: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
97902: LD_VAR 0 1
97906: NOT
97907: PUSH
97908: LD_VAR 0 1
97912: PUSH
97913: LD_INT 21
97915: PUSH
97916: LD_INT 2
97918: PUSH
97919: EMPTY
97920: LIST
97921: LIST
97922: PUSH
97923: LD_INT 23
97925: PUSH
97926: LD_INT 2
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: PUSH
97933: EMPTY
97934: LIST
97935: LIST
97936: PPUSH
97937: CALL_OW 69
97941: IN
97942: NOT
97943: OR
97944: IFFALSE 97948
// exit ;
97946: GO 97995
// for i = 1 to 3 do
97948: LD_ADDR_VAR 0 3
97952: PUSH
97953: DOUBLE
97954: LD_INT 1
97956: DEC
97957: ST_TO_ADDR
97958: LD_INT 3
97960: PUSH
97961: FOR_TO
97962: IFFALSE 97993
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
97964: LD_VAR 0 1
97968: PPUSH
97969: CALL_OW 250
97973: PPUSH
97974: LD_VAR 0 1
97978: PPUSH
97979: CALL_OW 251
97983: PPUSH
97984: LD_INT 1
97986: PPUSH
97987: CALL_OW 453
97991: GO 97961
97993: POP
97994: POP
// end ;
97995: LD_VAR 0 2
97999: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98000: LD_INT 0
98002: PPUSH
98003: PPUSH
98004: PPUSH
98005: PPUSH
98006: PPUSH
98007: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98008: LD_VAR 0 1
98012: NOT
98013: PUSH
98014: LD_VAR 0 2
98018: NOT
98019: OR
98020: PUSH
98021: LD_VAR 0 1
98025: PPUSH
98026: CALL_OW 314
98030: OR
98031: IFFALSE 98035
// exit ;
98033: GO 98476
// x := GetX ( enemy_unit ) ;
98035: LD_ADDR_VAR 0 7
98039: PUSH
98040: LD_VAR 0 2
98044: PPUSH
98045: CALL_OW 250
98049: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98050: LD_ADDR_VAR 0 8
98054: PUSH
98055: LD_VAR 0 2
98059: PPUSH
98060: CALL_OW 251
98064: ST_TO_ADDR
// if not x or not y then
98065: LD_VAR 0 7
98069: NOT
98070: PUSH
98071: LD_VAR 0 8
98075: NOT
98076: OR
98077: IFFALSE 98081
// exit ;
98079: GO 98476
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98081: LD_ADDR_VAR 0 6
98085: PUSH
98086: LD_VAR 0 7
98090: PPUSH
98091: LD_INT 0
98093: PPUSH
98094: LD_INT 4
98096: PPUSH
98097: CALL_OW 272
98101: PUSH
98102: LD_VAR 0 8
98106: PPUSH
98107: LD_INT 0
98109: PPUSH
98110: LD_INT 4
98112: PPUSH
98113: CALL_OW 273
98117: PUSH
98118: EMPTY
98119: LIST
98120: LIST
98121: PUSH
98122: LD_VAR 0 7
98126: PPUSH
98127: LD_INT 1
98129: PPUSH
98130: LD_INT 4
98132: PPUSH
98133: CALL_OW 272
98137: PUSH
98138: LD_VAR 0 8
98142: PPUSH
98143: LD_INT 1
98145: PPUSH
98146: LD_INT 4
98148: PPUSH
98149: CALL_OW 273
98153: PUSH
98154: EMPTY
98155: LIST
98156: LIST
98157: PUSH
98158: LD_VAR 0 7
98162: PPUSH
98163: LD_INT 2
98165: PPUSH
98166: LD_INT 4
98168: PPUSH
98169: CALL_OW 272
98173: PUSH
98174: LD_VAR 0 8
98178: PPUSH
98179: LD_INT 2
98181: PPUSH
98182: LD_INT 4
98184: PPUSH
98185: CALL_OW 273
98189: PUSH
98190: EMPTY
98191: LIST
98192: LIST
98193: PUSH
98194: LD_VAR 0 7
98198: PPUSH
98199: LD_INT 3
98201: PPUSH
98202: LD_INT 4
98204: PPUSH
98205: CALL_OW 272
98209: PUSH
98210: LD_VAR 0 8
98214: PPUSH
98215: LD_INT 3
98217: PPUSH
98218: LD_INT 4
98220: PPUSH
98221: CALL_OW 273
98225: PUSH
98226: EMPTY
98227: LIST
98228: LIST
98229: PUSH
98230: LD_VAR 0 7
98234: PPUSH
98235: LD_INT 4
98237: PPUSH
98238: LD_INT 4
98240: PPUSH
98241: CALL_OW 272
98245: PUSH
98246: LD_VAR 0 8
98250: PPUSH
98251: LD_INT 4
98253: PPUSH
98254: LD_INT 4
98256: PPUSH
98257: CALL_OW 273
98261: PUSH
98262: EMPTY
98263: LIST
98264: LIST
98265: PUSH
98266: LD_VAR 0 7
98270: PPUSH
98271: LD_INT 5
98273: PPUSH
98274: LD_INT 4
98276: PPUSH
98277: CALL_OW 272
98281: PUSH
98282: LD_VAR 0 8
98286: PPUSH
98287: LD_INT 5
98289: PPUSH
98290: LD_INT 4
98292: PPUSH
98293: CALL_OW 273
98297: PUSH
98298: EMPTY
98299: LIST
98300: LIST
98301: PUSH
98302: EMPTY
98303: LIST
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: LIST
98309: ST_TO_ADDR
// for i = tmp downto 1 do
98310: LD_ADDR_VAR 0 4
98314: PUSH
98315: DOUBLE
98316: LD_VAR 0 6
98320: INC
98321: ST_TO_ADDR
98322: LD_INT 1
98324: PUSH
98325: FOR_DOWNTO
98326: IFFALSE 98427
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98328: LD_VAR 0 6
98332: PUSH
98333: LD_VAR 0 4
98337: ARRAY
98338: PUSH
98339: LD_INT 1
98341: ARRAY
98342: PPUSH
98343: LD_VAR 0 6
98347: PUSH
98348: LD_VAR 0 4
98352: ARRAY
98353: PUSH
98354: LD_INT 2
98356: ARRAY
98357: PPUSH
98358: CALL_OW 488
98362: NOT
98363: PUSH
98364: LD_VAR 0 6
98368: PUSH
98369: LD_VAR 0 4
98373: ARRAY
98374: PUSH
98375: LD_INT 1
98377: ARRAY
98378: PPUSH
98379: LD_VAR 0 6
98383: PUSH
98384: LD_VAR 0 4
98388: ARRAY
98389: PUSH
98390: LD_INT 2
98392: ARRAY
98393: PPUSH
98394: CALL_OW 428
98398: PUSH
98399: LD_INT 0
98401: NONEQUAL
98402: OR
98403: IFFALSE 98425
// tmp := Delete ( tmp , i ) ;
98405: LD_ADDR_VAR 0 6
98409: PUSH
98410: LD_VAR 0 6
98414: PPUSH
98415: LD_VAR 0 4
98419: PPUSH
98420: CALL_OW 3
98424: ST_TO_ADDR
98425: GO 98325
98427: POP
98428: POP
// j := GetClosestHex ( unit , tmp ) ;
98429: LD_ADDR_VAR 0 5
98433: PUSH
98434: LD_VAR 0 1
98438: PPUSH
98439: LD_VAR 0 6
98443: PPUSH
98444: CALL 97729 0 2
98448: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
98449: LD_VAR 0 1
98453: PPUSH
98454: LD_VAR 0 5
98458: PUSH
98459: LD_INT 1
98461: ARRAY
98462: PPUSH
98463: LD_VAR 0 5
98467: PUSH
98468: LD_INT 2
98470: ARRAY
98471: PPUSH
98472: CALL_OW 111
// end ;
98476: LD_VAR 0 3
98480: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98481: LD_INT 0
98483: PPUSH
98484: PPUSH
98485: PPUSH
// uc_side = 0 ;
98486: LD_ADDR_OWVAR 20
98490: PUSH
98491: LD_INT 0
98493: ST_TO_ADDR
// uc_nation = 0 ;
98494: LD_ADDR_OWVAR 21
98498: PUSH
98499: LD_INT 0
98501: ST_TO_ADDR
// InitHc ;
98502: CALL_OW 19
// InitVc ;
98506: CALL_OW 20
// if mastodonts then
98510: LD_VAR 0 6
98514: IFFALSE 98581
// for i = 1 to mastodonts do
98516: LD_ADDR_VAR 0 11
98520: PUSH
98521: DOUBLE
98522: LD_INT 1
98524: DEC
98525: ST_TO_ADDR
98526: LD_VAR 0 6
98530: PUSH
98531: FOR_TO
98532: IFFALSE 98579
// begin vc_chassis := 31 ;
98534: LD_ADDR_OWVAR 37
98538: PUSH
98539: LD_INT 31
98541: ST_TO_ADDR
// vc_control := control_rider ;
98542: LD_ADDR_OWVAR 38
98546: PUSH
98547: LD_INT 4
98549: ST_TO_ADDR
// animal := CreateVehicle ;
98550: LD_ADDR_VAR 0 12
98554: PUSH
98555: CALL_OW 45
98559: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98560: LD_VAR 0 12
98564: PPUSH
98565: LD_VAR 0 8
98569: PPUSH
98570: LD_INT 0
98572: PPUSH
98573: CALL 105326 0 3
// end ;
98577: GO 98531
98579: POP
98580: POP
// if horses then
98581: LD_VAR 0 5
98585: IFFALSE 98652
// for i = 1 to horses do
98587: LD_ADDR_VAR 0 11
98591: PUSH
98592: DOUBLE
98593: LD_INT 1
98595: DEC
98596: ST_TO_ADDR
98597: LD_VAR 0 5
98601: PUSH
98602: FOR_TO
98603: IFFALSE 98650
// begin hc_class := 21 ;
98605: LD_ADDR_OWVAR 28
98609: PUSH
98610: LD_INT 21
98612: ST_TO_ADDR
// hc_gallery :=  ;
98613: LD_ADDR_OWVAR 33
98617: PUSH
98618: LD_STRING 
98620: ST_TO_ADDR
// animal := CreateHuman ;
98621: LD_ADDR_VAR 0 12
98625: PUSH
98626: CALL_OW 44
98630: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98631: LD_VAR 0 12
98635: PPUSH
98636: LD_VAR 0 8
98640: PPUSH
98641: LD_INT 0
98643: PPUSH
98644: CALL 105326 0 3
// end ;
98648: GO 98602
98650: POP
98651: POP
// if birds then
98652: LD_VAR 0 1
98656: IFFALSE 98723
// for i = 1 to birds do
98658: LD_ADDR_VAR 0 11
98662: PUSH
98663: DOUBLE
98664: LD_INT 1
98666: DEC
98667: ST_TO_ADDR
98668: LD_VAR 0 1
98672: PUSH
98673: FOR_TO
98674: IFFALSE 98721
// begin hc_class = 18 ;
98676: LD_ADDR_OWVAR 28
98680: PUSH
98681: LD_INT 18
98683: ST_TO_ADDR
// hc_gallery =  ;
98684: LD_ADDR_OWVAR 33
98688: PUSH
98689: LD_STRING 
98691: ST_TO_ADDR
// animal := CreateHuman ;
98692: LD_ADDR_VAR 0 12
98696: PUSH
98697: CALL_OW 44
98701: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98702: LD_VAR 0 12
98706: PPUSH
98707: LD_VAR 0 8
98711: PPUSH
98712: LD_INT 0
98714: PPUSH
98715: CALL 105326 0 3
// end ;
98719: GO 98673
98721: POP
98722: POP
// if tigers then
98723: LD_VAR 0 2
98727: IFFALSE 98811
// for i = 1 to tigers do
98729: LD_ADDR_VAR 0 11
98733: PUSH
98734: DOUBLE
98735: LD_INT 1
98737: DEC
98738: ST_TO_ADDR
98739: LD_VAR 0 2
98743: PUSH
98744: FOR_TO
98745: IFFALSE 98809
// begin hc_class = class_tiger ;
98747: LD_ADDR_OWVAR 28
98751: PUSH
98752: LD_INT 14
98754: ST_TO_ADDR
// hc_gallery =  ;
98755: LD_ADDR_OWVAR 33
98759: PUSH
98760: LD_STRING 
98762: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
98763: LD_ADDR_OWVAR 35
98767: PUSH
98768: LD_INT 7
98770: NEG
98771: PPUSH
98772: LD_INT 7
98774: PPUSH
98775: CALL_OW 12
98779: ST_TO_ADDR
// animal := CreateHuman ;
98780: LD_ADDR_VAR 0 12
98784: PUSH
98785: CALL_OW 44
98789: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98790: LD_VAR 0 12
98794: PPUSH
98795: LD_VAR 0 8
98799: PPUSH
98800: LD_INT 0
98802: PPUSH
98803: CALL 105326 0 3
// end ;
98807: GO 98744
98809: POP
98810: POP
// if apemans then
98811: LD_VAR 0 3
98815: IFFALSE 98938
// for i = 1 to apemans do
98817: LD_ADDR_VAR 0 11
98821: PUSH
98822: DOUBLE
98823: LD_INT 1
98825: DEC
98826: ST_TO_ADDR
98827: LD_VAR 0 3
98831: PUSH
98832: FOR_TO
98833: IFFALSE 98936
// begin hc_class = class_apeman ;
98835: LD_ADDR_OWVAR 28
98839: PUSH
98840: LD_INT 12
98842: ST_TO_ADDR
// hc_gallery =  ;
98843: LD_ADDR_OWVAR 33
98847: PUSH
98848: LD_STRING 
98850: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
98851: LD_ADDR_OWVAR 35
98855: PUSH
98856: LD_INT 5
98858: NEG
98859: PPUSH
98860: LD_INT 5
98862: PPUSH
98863: CALL_OW 12
98867: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
98868: LD_ADDR_OWVAR 31
98872: PUSH
98873: LD_INT 1
98875: PPUSH
98876: LD_INT 3
98878: PPUSH
98879: CALL_OW 12
98883: PUSH
98884: LD_INT 1
98886: PPUSH
98887: LD_INT 3
98889: PPUSH
98890: CALL_OW 12
98894: PUSH
98895: LD_INT 0
98897: PUSH
98898: LD_INT 0
98900: PUSH
98901: EMPTY
98902: LIST
98903: LIST
98904: LIST
98905: LIST
98906: ST_TO_ADDR
// animal := CreateHuman ;
98907: LD_ADDR_VAR 0 12
98911: PUSH
98912: CALL_OW 44
98916: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98917: LD_VAR 0 12
98921: PPUSH
98922: LD_VAR 0 8
98926: PPUSH
98927: LD_INT 0
98929: PPUSH
98930: CALL 105326 0 3
// end ;
98934: GO 98832
98936: POP
98937: POP
// if enchidnas then
98938: LD_VAR 0 4
98942: IFFALSE 99009
// for i = 1 to enchidnas do
98944: LD_ADDR_VAR 0 11
98948: PUSH
98949: DOUBLE
98950: LD_INT 1
98952: DEC
98953: ST_TO_ADDR
98954: LD_VAR 0 4
98958: PUSH
98959: FOR_TO
98960: IFFALSE 99007
// begin hc_class = 13 ;
98962: LD_ADDR_OWVAR 28
98966: PUSH
98967: LD_INT 13
98969: ST_TO_ADDR
// hc_gallery =  ;
98970: LD_ADDR_OWVAR 33
98974: PUSH
98975: LD_STRING 
98977: ST_TO_ADDR
// animal := CreateHuman ;
98978: LD_ADDR_VAR 0 12
98982: PUSH
98983: CALL_OW 44
98987: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98988: LD_VAR 0 12
98992: PPUSH
98993: LD_VAR 0 8
98997: PPUSH
98998: LD_INT 0
99000: PPUSH
99001: CALL 105326 0 3
// end ;
99005: GO 98959
99007: POP
99008: POP
// if fishes then
99009: LD_VAR 0 7
99013: IFFALSE 99080
// for i = 1 to fishes do
99015: LD_ADDR_VAR 0 11
99019: PUSH
99020: DOUBLE
99021: LD_INT 1
99023: DEC
99024: ST_TO_ADDR
99025: LD_VAR 0 7
99029: PUSH
99030: FOR_TO
99031: IFFALSE 99078
// begin hc_class = 20 ;
99033: LD_ADDR_OWVAR 28
99037: PUSH
99038: LD_INT 20
99040: ST_TO_ADDR
// hc_gallery =  ;
99041: LD_ADDR_OWVAR 33
99045: PUSH
99046: LD_STRING 
99048: ST_TO_ADDR
// animal := CreateHuman ;
99049: LD_ADDR_VAR 0 12
99053: PUSH
99054: CALL_OW 44
99058: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99059: LD_VAR 0 12
99063: PPUSH
99064: LD_VAR 0 9
99068: PPUSH
99069: LD_INT 0
99071: PPUSH
99072: CALL 105326 0 3
// end ;
99076: GO 99030
99078: POP
99079: POP
// end ;
99080: LD_VAR 0 10
99084: RET
// export function WantHeal ( sci , unit ) ; begin
99085: LD_INT 0
99087: PPUSH
// if GetTaskList ( sci ) > 0 then
99088: LD_VAR 0 1
99092: PPUSH
99093: CALL_OW 437
99097: PUSH
99098: LD_INT 0
99100: GREATER
99101: IFFALSE 99171
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99103: LD_VAR 0 1
99107: PPUSH
99108: CALL_OW 437
99112: PUSH
99113: LD_INT 1
99115: ARRAY
99116: PUSH
99117: LD_INT 1
99119: ARRAY
99120: PUSH
99121: LD_STRING l
99123: EQUAL
99124: PUSH
99125: LD_VAR 0 1
99129: PPUSH
99130: CALL_OW 437
99134: PUSH
99135: LD_INT 1
99137: ARRAY
99138: PUSH
99139: LD_INT 4
99141: ARRAY
99142: PUSH
99143: LD_VAR 0 2
99147: EQUAL
99148: AND
99149: IFFALSE 99161
// result := true else
99151: LD_ADDR_VAR 0 3
99155: PUSH
99156: LD_INT 1
99158: ST_TO_ADDR
99159: GO 99169
// result := false ;
99161: LD_ADDR_VAR 0 3
99165: PUSH
99166: LD_INT 0
99168: ST_TO_ADDR
// end else
99169: GO 99179
// result := false ;
99171: LD_ADDR_VAR 0 3
99175: PUSH
99176: LD_INT 0
99178: ST_TO_ADDR
// end ;
99179: LD_VAR 0 3
99183: RET
// export function HealTarget ( sci ) ; begin
99184: LD_INT 0
99186: PPUSH
// if not sci then
99187: LD_VAR 0 1
99191: NOT
99192: IFFALSE 99196
// exit ;
99194: GO 99261
// result := 0 ;
99196: LD_ADDR_VAR 0 2
99200: PUSH
99201: LD_INT 0
99203: ST_TO_ADDR
// if GetTaskList ( sci ) then
99204: LD_VAR 0 1
99208: PPUSH
99209: CALL_OW 437
99213: IFFALSE 99261
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99215: LD_VAR 0 1
99219: PPUSH
99220: CALL_OW 437
99224: PUSH
99225: LD_INT 1
99227: ARRAY
99228: PUSH
99229: LD_INT 1
99231: ARRAY
99232: PUSH
99233: LD_STRING l
99235: EQUAL
99236: IFFALSE 99261
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99238: LD_ADDR_VAR 0 2
99242: PUSH
99243: LD_VAR 0 1
99247: PPUSH
99248: CALL_OW 437
99252: PUSH
99253: LD_INT 1
99255: ARRAY
99256: PUSH
99257: LD_INT 4
99259: ARRAY
99260: ST_TO_ADDR
// end ;
99261: LD_VAR 0 2
99265: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99266: LD_INT 0
99268: PPUSH
99269: PPUSH
99270: PPUSH
99271: PPUSH
99272: PPUSH
99273: PPUSH
99274: PPUSH
99275: PPUSH
99276: PPUSH
99277: PPUSH
99278: PPUSH
99279: PPUSH
99280: PPUSH
99281: PPUSH
99282: PPUSH
99283: PPUSH
99284: PPUSH
99285: PPUSH
99286: PPUSH
99287: PPUSH
99288: PPUSH
99289: PPUSH
99290: PPUSH
99291: PPUSH
99292: PPUSH
99293: PPUSH
99294: PPUSH
99295: PPUSH
99296: PPUSH
99297: PPUSH
99298: PPUSH
99299: PPUSH
99300: PPUSH
99301: PPUSH
// if not list then
99302: LD_VAR 0 1
99306: NOT
99307: IFFALSE 99311
// exit ;
99309: GO 103937
// base := list [ 1 ] ;
99311: LD_ADDR_VAR 0 3
99315: PUSH
99316: LD_VAR 0 1
99320: PUSH
99321: LD_INT 1
99323: ARRAY
99324: ST_TO_ADDR
// group := list [ 2 ] ;
99325: LD_ADDR_VAR 0 4
99329: PUSH
99330: LD_VAR 0 1
99334: PUSH
99335: LD_INT 2
99337: ARRAY
99338: ST_TO_ADDR
// path := list [ 3 ] ;
99339: LD_ADDR_VAR 0 5
99343: PUSH
99344: LD_VAR 0 1
99348: PUSH
99349: LD_INT 3
99351: ARRAY
99352: ST_TO_ADDR
// flags := list [ 4 ] ;
99353: LD_ADDR_VAR 0 6
99357: PUSH
99358: LD_VAR 0 1
99362: PUSH
99363: LD_INT 4
99365: ARRAY
99366: ST_TO_ADDR
// mined := [ ] ;
99367: LD_ADDR_VAR 0 27
99371: PUSH
99372: EMPTY
99373: ST_TO_ADDR
// bombed := [ ] ;
99374: LD_ADDR_VAR 0 28
99378: PUSH
99379: EMPTY
99380: ST_TO_ADDR
// healers := [ ] ;
99381: LD_ADDR_VAR 0 31
99385: PUSH
99386: EMPTY
99387: ST_TO_ADDR
// to_heal := [ ] ;
99388: LD_ADDR_VAR 0 30
99392: PUSH
99393: EMPTY
99394: ST_TO_ADDR
// repairs := [ ] ;
99395: LD_ADDR_VAR 0 33
99399: PUSH
99400: EMPTY
99401: ST_TO_ADDR
// to_repair := [ ] ;
99402: LD_ADDR_VAR 0 32
99406: PUSH
99407: EMPTY
99408: ST_TO_ADDR
// if not group or not path then
99409: LD_VAR 0 4
99413: NOT
99414: PUSH
99415: LD_VAR 0 5
99419: NOT
99420: OR
99421: IFFALSE 99425
// exit ;
99423: GO 103937
// side := GetSide ( group [ 1 ] ) ;
99425: LD_ADDR_VAR 0 35
99429: PUSH
99430: LD_VAR 0 4
99434: PUSH
99435: LD_INT 1
99437: ARRAY
99438: PPUSH
99439: CALL_OW 255
99443: ST_TO_ADDR
// if flags then
99444: LD_VAR 0 6
99448: IFFALSE 99592
// begin f_ignore_area := flags [ 1 ] ;
99450: LD_ADDR_VAR 0 17
99454: PUSH
99455: LD_VAR 0 6
99459: PUSH
99460: LD_INT 1
99462: ARRAY
99463: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
99464: LD_ADDR_VAR 0 18
99468: PUSH
99469: LD_VAR 0 6
99473: PUSH
99474: LD_INT 2
99476: ARRAY
99477: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
99478: LD_ADDR_VAR 0 19
99482: PUSH
99483: LD_VAR 0 6
99487: PUSH
99488: LD_INT 3
99490: ARRAY
99491: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
99492: LD_ADDR_VAR 0 20
99496: PUSH
99497: LD_VAR 0 6
99501: PUSH
99502: LD_INT 4
99504: ARRAY
99505: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
99506: LD_ADDR_VAR 0 21
99510: PUSH
99511: LD_VAR 0 6
99515: PUSH
99516: LD_INT 5
99518: ARRAY
99519: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
99520: LD_ADDR_VAR 0 22
99524: PUSH
99525: LD_VAR 0 6
99529: PUSH
99530: LD_INT 6
99532: ARRAY
99533: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
99534: LD_ADDR_VAR 0 23
99538: PUSH
99539: LD_VAR 0 6
99543: PUSH
99544: LD_INT 7
99546: ARRAY
99547: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
99548: LD_ADDR_VAR 0 24
99552: PUSH
99553: LD_VAR 0 6
99557: PUSH
99558: LD_INT 8
99560: ARRAY
99561: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
99562: LD_ADDR_VAR 0 25
99566: PUSH
99567: LD_VAR 0 6
99571: PUSH
99572: LD_INT 9
99574: ARRAY
99575: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
99576: LD_ADDR_VAR 0 26
99580: PUSH
99581: LD_VAR 0 6
99585: PUSH
99586: LD_INT 10
99588: ARRAY
99589: ST_TO_ADDR
// end else
99590: GO 99672
// begin f_ignore_area := false ;
99592: LD_ADDR_VAR 0 17
99596: PUSH
99597: LD_INT 0
99599: ST_TO_ADDR
// f_capture := false ;
99600: LD_ADDR_VAR 0 18
99604: PUSH
99605: LD_INT 0
99607: ST_TO_ADDR
// f_ignore_civ := false ;
99608: LD_ADDR_VAR 0 19
99612: PUSH
99613: LD_INT 0
99615: ST_TO_ADDR
// f_murder := false ;
99616: LD_ADDR_VAR 0 20
99620: PUSH
99621: LD_INT 0
99623: ST_TO_ADDR
// f_mines := false ;
99624: LD_ADDR_VAR 0 21
99628: PUSH
99629: LD_INT 0
99631: ST_TO_ADDR
// f_repair := false ;
99632: LD_ADDR_VAR 0 22
99636: PUSH
99637: LD_INT 0
99639: ST_TO_ADDR
// f_heal := false ;
99640: LD_ADDR_VAR 0 23
99644: PUSH
99645: LD_INT 0
99647: ST_TO_ADDR
// f_spacetime := false ;
99648: LD_ADDR_VAR 0 24
99652: PUSH
99653: LD_INT 0
99655: ST_TO_ADDR
// f_attack_depot := false ;
99656: LD_ADDR_VAR 0 25
99660: PUSH
99661: LD_INT 0
99663: ST_TO_ADDR
// f_crawl := false ;
99664: LD_ADDR_VAR 0 26
99668: PUSH
99669: LD_INT 0
99671: ST_TO_ADDR
// end ; if f_heal then
99672: LD_VAR 0 23
99676: IFFALSE 99703
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
99678: LD_ADDR_VAR 0 31
99682: PUSH
99683: LD_VAR 0 4
99687: PPUSH
99688: LD_INT 25
99690: PUSH
99691: LD_INT 4
99693: PUSH
99694: EMPTY
99695: LIST
99696: LIST
99697: PPUSH
99698: CALL_OW 72
99702: ST_TO_ADDR
// if f_repair then
99703: LD_VAR 0 22
99707: IFFALSE 99734
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
99709: LD_ADDR_VAR 0 33
99713: PUSH
99714: LD_VAR 0 4
99718: PPUSH
99719: LD_INT 25
99721: PUSH
99722: LD_INT 3
99724: PUSH
99725: EMPTY
99726: LIST
99727: LIST
99728: PPUSH
99729: CALL_OW 72
99733: ST_TO_ADDR
// units_path := [ ] ;
99734: LD_ADDR_VAR 0 16
99738: PUSH
99739: EMPTY
99740: ST_TO_ADDR
// for i = 1 to group do
99741: LD_ADDR_VAR 0 7
99745: PUSH
99746: DOUBLE
99747: LD_INT 1
99749: DEC
99750: ST_TO_ADDR
99751: LD_VAR 0 4
99755: PUSH
99756: FOR_TO
99757: IFFALSE 99786
// units_path := Replace ( units_path , i , path ) ;
99759: LD_ADDR_VAR 0 16
99763: PUSH
99764: LD_VAR 0 16
99768: PPUSH
99769: LD_VAR 0 7
99773: PPUSH
99774: LD_VAR 0 5
99778: PPUSH
99779: CALL_OW 1
99783: ST_TO_ADDR
99784: GO 99756
99786: POP
99787: POP
// repeat for i = group downto 1 do
99788: LD_ADDR_VAR 0 7
99792: PUSH
99793: DOUBLE
99794: LD_VAR 0 4
99798: INC
99799: ST_TO_ADDR
99800: LD_INT 1
99802: PUSH
99803: FOR_DOWNTO
99804: IFFALSE 103900
// begin wait ( 5 ) ;
99806: LD_INT 5
99808: PPUSH
99809: CALL_OW 67
// tmp := [ ] ;
99813: LD_ADDR_VAR 0 14
99817: PUSH
99818: EMPTY
99819: ST_TO_ADDR
// attacking := false ;
99820: LD_ADDR_VAR 0 29
99824: PUSH
99825: LD_INT 0
99827: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
99828: LD_VAR 0 4
99832: PUSH
99833: LD_VAR 0 7
99837: ARRAY
99838: PPUSH
99839: CALL_OW 301
99843: PUSH
99844: LD_VAR 0 4
99848: PUSH
99849: LD_VAR 0 7
99853: ARRAY
99854: NOT
99855: OR
99856: IFFALSE 99965
// begin if GetType ( group [ i ] ) = unit_human then
99858: LD_VAR 0 4
99862: PUSH
99863: LD_VAR 0 7
99867: ARRAY
99868: PPUSH
99869: CALL_OW 247
99873: PUSH
99874: LD_INT 1
99876: EQUAL
99877: IFFALSE 99923
// begin to_heal := to_heal diff group [ i ] ;
99879: LD_ADDR_VAR 0 30
99883: PUSH
99884: LD_VAR 0 30
99888: PUSH
99889: LD_VAR 0 4
99893: PUSH
99894: LD_VAR 0 7
99898: ARRAY
99899: DIFF
99900: ST_TO_ADDR
// healers := healers diff group [ i ] ;
99901: LD_ADDR_VAR 0 31
99905: PUSH
99906: LD_VAR 0 31
99910: PUSH
99911: LD_VAR 0 4
99915: PUSH
99916: LD_VAR 0 7
99920: ARRAY
99921: DIFF
99922: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
99923: LD_ADDR_VAR 0 4
99927: PUSH
99928: LD_VAR 0 4
99932: PPUSH
99933: LD_VAR 0 7
99937: PPUSH
99938: CALL_OW 3
99942: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
99943: LD_ADDR_VAR 0 16
99947: PUSH
99948: LD_VAR 0 16
99952: PPUSH
99953: LD_VAR 0 7
99957: PPUSH
99958: CALL_OW 3
99962: ST_TO_ADDR
// continue ;
99963: GO 99803
// end ; if f_repair then
99965: LD_VAR 0 22
99969: IFFALSE 100458
// begin if GetType ( group [ i ] ) = unit_vehicle then
99971: LD_VAR 0 4
99975: PUSH
99976: LD_VAR 0 7
99980: ARRAY
99981: PPUSH
99982: CALL_OW 247
99986: PUSH
99987: LD_INT 2
99989: EQUAL
99990: IFFALSE 100180
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
99992: LD_VAR 0 4
99996: PUSH
99997: LD_VAR 0 7
100001: ARRAY
100002: PPUSH
100003: CALL_OW 256
100007: PUSH
100008: LD_INT 700
100010: LESS
100011: PUSH
100012: LD_VAR 0 4
100016: PUSH
100017: LD_VAR 0 7
100021: ARRAY
100022: PUSH
100023: LD_VAR 0 32
100027: IN
100028: NOT
100029: AND
100030: IFFALSE 100054
// to_repair := to_repair union group [ i ] ;
100032: LD_ADDR_VAR 0 32
100036: PUSH
100037: LD_VAR 0 32
100041: PUSH
100042: LD_VAR 0 4
100046: PUSH
100047: LD_VAR 0 7
100051: ARRAY
100052: UNION
100053: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100054: LD_VAR 0 4
100058: PUSH
100059: LD_VAR 0 7
100063: ARRAY
100064: PPUSH
100065: CALL_OW 256
100069: PUSH
100070: LD_INT 1000
100072: EQUAL
100073: PUSH
100074: LD_VAR 0 4
100078: PUSH
100079: LD_VAR 0 7
100083: ARRAY
100084: PUSH
100085: LD_VAR 0 32
100089: IN
100090: AND
100091: IFFALSE 100115
// to_repair := to_repair diff group [ i ] ;
100093: LD_ADDR_VAR 0 32
100097: PUSH
100098: LD_VAR 0 32
100102: PUSH
100103: LD_VAR 0 4
100107: PUSH
100108: LD_VAR 0 7
100112: ARRAY
100113: DIFF
100114: ST_TO_ADDR
// if group [ i ] in to_repair then
100115: LD_VAR 0 4
100119: PUSH
100120: LD_VAR 0 7
100124: ARRAY
100125: PUSH
100126: LD_VAR 0 32
100130: IN
100131: IFFALSE 100178
// begin if not IsInArea ( group [ i ] , f_repair ) then
100133: LD_VAR 0 4
100137: PUSH
100138: LD_VAR 0 7
100142: ARRAY
100143: PPUSH
100144: LD_VAR 0 22
100148: PPUSH
100149: CALL_OW 308
100153: NOT
100154: IFFALSE 100176
// ComMoveToArea ( group [ i ] , f_repair ) ;
100156: LD_VAR 0 4
100160: PUSH
100161: LD_VAR 0 7
100165: ARRAY
100166: PPUSH
100167: LD_VAR 0 22
100171: PPUSH
100172: CALL_OW 113
// continue ;
100176: GO 99803
// end ; end else
100178: GO 100458
// if group [ i ] in repairs then
100180: LD_VAR 0 4
100184: PUSH
100185: LD_VAR 0 7
100189: ARRAY
100190: PUSH
100191: LD_VAR 0 33
100195: IN
100196: IFFALSE 100458
// begin if IsInUnit ( group [ i ] ) then
100198: LD_VAR 0 4
100202: PUSH
100203: LD_VAR 0 7
100207: ARRAY
100208: PPUSH
100209: CALL_OW 310
100213: IFFALSE 100281
// begin z := IsInUnit ( group [ i ] ) ;
100215: LD_ADDR_VAR 0 13
100219: PUSH
100220: LD_VAR 0 4
100224: PUSH
100225: LD_VAR 0 7
100229: ARRAY
100230: PPUSH
100231: CALL_OW 310
100235: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100236: LD_VAR 0 13
100240: PUSH
100241: LD_VAR 0 32
100245: IN
100246: PUSH
100247: LD_VAR 0 13
100251: PPUSH
100252: LD_VAR 0 22
100256: PPUSH
100257: CALL_OW 308
100261: AND
100262: IFFALSE 100279
// ComExitVehicle ( group [ i ] ) ;
100264: LD_VAR 0 4
100268: PUSH
100269: LD_VAR 0 7
100273: ARRAY
100274: PPUSH
100275: CALL_OW 121
// end else
100279: GO 100458
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100281: LD_ADDR_VAR 0 13
100285: PUSH
100286: LD_VAR 0 4
100290: PPUSH
100291: LD_INT 95
100293: PUSH
100294: LD_VAR 0 22
100298: PUSH
100299: EMPTY
100300: LIST
100301: LIST
100302: PUSH
100303: LD_INT 58
100305: PUSH
100306: EMPTY
100307: LIST
100308: PUSH
100309: EMPTY
100310: LIST
100311: LIST
100312: PPUSH
100313: CALL_OW 72
100317: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
100318: LD_VAR 0 4
100322: PUSH
100323: LD_VAR 0 7
100327: ARRAY
100328: PPUSH
100329: CALL_OW 314
100333: NOT
100334: IFFALSE 100456
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
100336: LD_ADDR_VAR 0 10
100340: PUSH
100341: LD_VAR 0 13
100345: PPUSH
100346: LD_VAR 0 4
100350: PUSH
100351: LD_VAR 0 7
100355: ARRAY
100356: PPUSH
100357: CALL_OW 74
100361: ST_TO_ADDR
// if not x then
100362: LD_VAR 0 10
100366: NOT
100367: IFFALSE 100371
// continue ;
100369: GO 99803
// if GetLives ( x ) < 1000 then
100371: LD_VAR 0 10
100375: PPUSH
100376: CALL_OW 256
100380: PUSH
100381: LD_INT 1000
100383: LESS
100384: IFFALSE 100408
// ComRepairVehicle ( group [ i ] , x ) else
100386: LD_VAR 0 4
100390: PUSH
100391: LD_VAR 0 7
100395: ARRAY
100396: PPUSH
100397: LD_VAR 0 10
100401: PPUSH
100402: CALL_OW 129
100406: GO 100456
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
100408: LD_VAR 0 23
100412: PUSH
100413: LD_VAR 0 4
100417: PUSH
100418: LD_VAR 0 7
100422: ARRAY
100423: PPUSH
100424: CALL_OW 256
100428: PUSH
100429: LD_INT 1000
100431: LESS
100432: AND
100433: NOT
100434: IFFALSE 100456
// ComEnterUnit ( group [ i ] , x ) ;
100436: LD_VAR 0 4
100440: PUSH
100441: LD_VAR 0 7
100445: ARRAY
100446: PPUSH
100447: LD_VAR 0 10
100451: PPUSH
100452: CALL_OW 120
// end ; continue ;
100456: GO 99803
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
100458: LD_VAR 0 23
100462: PUSH
100463: LD_VAR 0 4
100467: PUSH
100468: LD_VAR 0 7
100472: ARRAY
100473: PPUSH
100474: CALL_OW 247
100478: PUSH
100479: LD_INT 1
100481: EQUAL
100482: AND
100483: IFFALSE 100961
// begin if group [ i ] in healers then
100485: LD_VAR 0 4
100489: PUSH
100490: LD_VAR 0 7
100494: ARRAY
100495: PUSH
100496: LD_VAR 0 31
100500: IN
100501: IFFALSE 100774
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
100503: LD_VAR 0 4
100507: PUSH
100508: LD_VAR 0 7
100512: ARRAY
100513: PPUSH
100514: LD_VAR 0 23
100518: PPUSH
100519: CALL_OW 308
100523: NOT
100524: PUSH
100525: LD_VAR 0 4
100529: PUSH
100530: LD_VAR 0 7
100534: ARRAY
100535: PPUSH
100536: CALL_OW 314
100540: NOT
100541: AND
100542: IFFALSE 100566
// ComMoveToArea ( group [ i ] , f_heal ) else
100544: LD_VAR 0 4
100548: PUSH
100549: LD_VAR 0 7
100553: ARRAY
100554: PPUSH
100555: LD_VAR 0 23
100559: PPUSH
100560: CALL_OW 113
100564: GO 100772
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
100566: LD_VAR 0 4
100570: PUSH
100571: LD_VAR 0 7
100575: ARRAY
100576: PPUSH
100577: CALL 99184 0 1
100581: PPUSH
100582: CALL_OW 256
100586: PUSH
100587: LD_INT 1000
100589: EQUAL
100590: IFFALSE 100609
// ComStop ( group [ i ] ) else
100592: LD_VAR 0 4
100596: PUSH
100597: LD_VAR 0 7
100601: ARRAY
100602: PPUSH
100603: CALL_OW 141
100607: GO 100772
// if not HasTask ( group [ i ] ) and to_heal then
100609: LD_VAR 0 4
100613: PUSH
100614: LD_VAR 0 7
100618: ARRAY
100619: PPUSH
100620: CALL_OW 314
100624: NOT
100625: PUSH
100626: LD_VAR 0 30
100630: AND
100631: IFFALSE 100772
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
100633: LD_ADDR_VAR 0 13
100637: PUSH
100638: LD_VAR 0 30
100642: PPUSH
100643: LD_INT 3
100645: PUSH
100646: LD_INT 54
100648: PUSH
100649: EMPTY
100650: LIST
100651: PUSH
100652: EMPTY
100653: LIST
100654: LIST
100655: PPUSH
100656: CALL_OW 72
100660: PPUSH
100661: LD_VAR 0 4
100665: PUSH
100666: LD_VAR 0 7
100670: ARRAY
100671: PPUSH
100672: CALL_OW 74
100676: ST_TO_ADDR
// if z then
100677: LD_VAR 0 13
100681: IFFALSE 100772
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
100683: LD_INT 91
100685: PUSH
100686: LD_VAR 0 13
100690: PUSH
100691: LD_INT 10
100693: PUSH
100694: EMPTY
100695: LIST
100696: LIST
100697: LIST
100698: PUSH
100699: LD_INT 81
100701: PUSH
100702: LD_VAR 0 13
100706: PPUSH
100707: CALL_OW 255
100711: PUSH
100712: EMPTY
100713: LIST
100714: LIST
100715: PUSH
100716: EMPTY
100717: LIST
100718: LIST
100719: PPUSH
100720: CALL_OW 69
100724: PUSH
100725: LD_INT 0
100727: EQUAL
100728: IFFALSE 100752
// ComHeal ( group [ i ] , z ) else
100730: LD_VAR 0 4
100734: PUSH
100735: LD_VAR 0 7
100739: ARRAY
100740: PPUSH
100741: LD_VAR 0 13
100745: PPUSH
100746: CALL_OW 128
100750: GO 100772
// ComMoveToArea ( group [ i ] , f_heal ) ;
100752: LD_VAR 0 4
100756: PUSH
100757: LD_VAR 0 7
100761: ARRAY
100762: PPUSH
100763: LD_VAR 0 23
100767: PPUSH
100768: CALL_OW 113
// end ; continue ;
100772: GO 99803
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
100774: LD_VAR 0 4
100778: PUSH
100779: LD_VAR 0 7
100783: ARRAY
100784: PPUSH
100785: CALL_OW 256
100789: PUSH
100790: LD_INT 700
100792: LESS
100793: PUSH
100794: LD_VAR 0 4
100798: PUSH
100799: LD_VAR 0 7
100803: ARRAY
100804: PUSH
100805: LD_VAR 0 30
100809: IN
100810: NOT
100811: AND
100812: IFFALSE 100836
// to_heal := to_heal union group [ i ] ;
100814: LD_ADDR_VAR 0 30
100818: PUSH
100819: LD_VAR 0 30
100823: PUSH
100824: LD_VAR 0 4
100828: PUSH
100829: LD_VAR 0 7
100833: ARRAY
100834: UNION
100835: ST_TO_ADDR
// if group [ i ] in to_heal then
100836: LD_VAR 0 4
100840: PUSH
100841: LD_VAR 0 7
100845: ARRAY
100846: PUSH
100847: LD_VAR 0 30
100851: IN
100852: IFFALSE 100961
// begin if GetLives ( group [ i ] ) = 1000 then
100854: LD_VAR 0 4
100858: PUSH
100859: LD_VAR 0 7
100863: ARRAY
100864: PPUSH
100865: CALL_OW 256
100869: PUSH
100870: LD_INT 1000
100872: EQUAL
100873: IFFALSE 100899
// to_heal := to_heal diff group [ i ] else
100875: LD_ADDR_VAR 0 30
100879: PUSH
100880: LD_VAR 0 30
100884: PUSH
100885: LD_VAR 0 4
100889: PUSH
100890: LD_VAR 0 7
100894: ARRAY
100895: DIFF
100896: ST_TO_ADDR
100897: GO 100961
// begin if not IsInArea ( group [ i ] , to_heal ) then
100899: LD_VAR 0 4
100903: PUSH
100904: LD_VAR 0 7
100908: ARRAY
100909: PPUSH
100910: LD_VAR 0 30
100914: PPUSH
100915: CALL_OW 308
100919: NOT
100920: IFFALSE 100944
// ComMoveToArea ( group [ i ] , f_heal ) else
100922: LD_VAR 0 4
100926: PUSH
100927: LD_VAR 0 7
100931: ARRAY
100932: PPUSH
100933: LD_VAR 0 23
100937: PPUSH
100938: CALL_OW 113
100942: GO 100959
// ComHold ( group [ i ] ) ;
100944: LD_VAR 0 4
100948: PUSH
100949: LD_VAR 0 7
100953: ARRAY
100954: PPUSH
100955: CALL_OW 140
// continue ;
100959: GO 99803
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
100961: LD_VAR 0 4
100965: PUSH
100966: LD_VAR 0 7
100970: ARRAY
100971: PPUSH
100972: LD_INT 10
100974: PPUSH
100975: CALL 97581 0 2
100979: NOT
100980: PUSH
100981: LD_VAR 0 16
100985: PUSH
100986: LD_VAR 0 7
100990: ARRAY
100991: PUSH
100992: EMPTY
100993: EQUAL
100994: NOT
100995: AND
100996: IFFALSE 101262
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
100998: LD_VAR 0 4
101002: PUSH
101003: LD_VAR 0 7
101007: ARRAY
101008: PPUSH
101009: CALL_OW 262
101013: PUSH
101014: LD_INT 1
101016: PUSH
101017: LD_INT 2
101019: PUSH
101020: EMPTY
101021: LIST
101022: LIST
101023: IN
101024: IFFALSE 101065
// if GetFuel ( group [ i ] ) < 10 then
101026: LD_VAR 0 4
101030: PUSH
101031: LD_VAR 0 7
101035: ARRAY
101036: PPUSH
101037: CALL_OW 261
101041: PUSH
101042: LD_INT 10
101044: LESS
101045: IFFALSE 101065
// SetFuel ( group [ i ] , 12 ) ;
101047: LD_VAR 0 4
101051: PUSH
101052: LD_VAR 0 7
101056: ARRAY
101057: PPUSH
101058: LD_INT 12
101060: PPUSH
101061: CALL_OW 240
// if units_path [ i ] then
101065: LD_VAR 0 16
101069: PUSH
101070: LD_VAR 0 7
101074: ARRAY
101075: IFFALSE 101260
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101077: LD_VAR 0 4
101081: PUSH
101082: LD_VAR 0 7
101086: ARRAY
101087: PPUSH
101088: LD_VAR 0 16
101092: PUSH
101093: LD_VAR 0 7
101097: ARRAY
101098: PUSH
101099: LD_INT 1
101101: ARRAY
101102: PUSH
101103: LD_INT 1
101105: ARRAY
101106: PPUSH
101107: LD_VAR 0 16
101111: PUSH
101112: LD_VAR 0 7
101116: ARRAY
101117: PUSH
101118: LD_INT 1
101120: ARRAY
101121: PUSH
101122: LD_INT 2
101124: ARRAY
101125: PPUSH
101126: CALL_OW 297
101130: PUSH
101131: LD_INT 6
101133: GREATER
101134: IFFALSE 101209
// begin if not HasTask ( group [ i ] ) then
101136: LD_VAR 0 4
101140: PUSH
101141: LD_VAR 0 7
101145: ARRAY
101146: PPUSH
101147: CALL_OW 314
101151: NOT
101152: IFFALSE 101207
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101154: LD_VAR 0 4
101158: PUSH
101159: LD_VAR 0 7
101163: ARRAY
101164: PPUSH
101165: LD_VAR 0 16
101169: PUSH
101170: LD_VAR 0 7
101174: ARRAY
101175: PUSH
101176: LD_INT 1
101178: ARRAY
101179: PUSH
101180: LD_INT 1
101182: ARRAY
101183: PPUSH
101184: LD_VAR 0 16
101188: PUSH
101189: LD_VAR 0 7
101193: ARRAY
101194: PUSH
101195: LD_INT 1
101197: ARRAY
101198: PUSH
101199: LD_INT 2
101201: ARRAY
101202: PPUSH
101203: CALL_OW 114
// end else
101207: GO 101260
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101209: LD_ADDR_VAR 0 15
101213: PUSH
101214: LD_VAR 0 16
101218: PUSH
101219: LD_VAR 0 7
101223: ARRAY
101224: PPUSH
101225: LD_INT 1
101227: PPUSH
101228: CALL_OW 3
101232: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101233: LD_ADDR_VAR 0 16
101237: PUSH
101238: LD_VAR 0 16
101242: PPUSH
101243: LD_VAR 0 7
101247: PPUSH
101248: LD_VAR 0 15
101252: PPUSH
101253: CALL_OW 1
101257: ST_TO_ADDR
// continue ;
101258: GO 99803
// end ; end ; end else
101260: GO 103898
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101262: LD_ADDR_VAR 0 14
101266: PUSH
101267: LD_INT 81
101269: PUSH
101270: LD_VAR 0 4
101274: PUSH
101275: LD_VAR 0 7
101279: ARRAY
101280: PPUSH
101281: CALL_OW 255
101285: PUSH
101286: EMPTY
101287: LIST
101288: LIST
101289: PPUSH
101290: CALL_OW 69
101294: ST_TO_ADDR
// if not tmp then
101295: LD_VAR 0 14
101299: NOT
101300: IFFALSE 101304
// continue ;
101302: GO 99803
// if f_ignore_area then
101304: LD_VAR 0 17
101308: IFFALSE 101396
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
101310: LD_ADDR_VAR 0 15
101314: PUSH
101315: LD_VAR 0 14
101319: PPUSH
101320: LD_INT 3
101322: PUSH
101323: LD_INT 92
101325: PUSH
101326: LD_VAR 0 17
101330: PUSH
101331: LD_INT 1
101333: ARRAY
101334: PUSH
101335: LD_VAR 0 17
101339: PUSH
101340: LD_INT 2
101342: ARRAY
101343: PUSH
101344: LD_VAR 0 17
101348: PUSH
101349: LD_INT 3
101351: ARRAY
101352: PUSH
101353: EMPTY
101354: LIST
101355: LIST
101356: LIST
101357: LIST
101358: PUSH
101359: EMPTY
101360: LIST
101361: LIST
101362: PPUSH
101363: CALL_OW 72
101367: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101368: LD_VAR 0 14
101372: PUSH
101373: LD_VAR 0 15
101377: DIFF
101378: IFFALSE 101396
// tmp := tmp diff tmp2 ;
101380: LD_ADDR_VAR 0 14
101384: PUSH
101385: LD_VAR 0 14
101389: PUSH
101390: LD_VAR 0 15
101394: DIFF
101395: ST_TO_ADDR
// end ; if not f_murder then
101396: LD_VAR 0 20
101400: NOT
101401: IFFALSE 101459
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
101403: LD_ADDR_VAR 0 15
101407: PUSH
101408: LD_VAR 0 14
101412: PPUSH
101413: LD_INT 3
101415: PUSH
101416: LD_INT 50
101418: PUSH
101419: EMPTY
101420: LIST
101421: PUSH
101422: EMPTY
101423: LIST
101424: LIST
101425: PPUSH
101426: CALL_OW 72
101430: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101431: LD_VAR 0 14
101435: PUSH
101436: LD_VAR 0 15
101440: DIFF
101441: IFFALSE 101459
// tmp := tmp diff tmp2 ;
101443: LD_ADDR_VAR 0 14
101447: PUSH
101448: LD_VAR 0 14
101452: PUSH
101453: LD_VAR 0 15
101457: DIFF
101458: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
101459: LD_ADDR_VAR 0 14
101463: PUSH
101464: LD_VAR 0 4
101468: PUSH
101469: LD_VAR 0 7
101473: ARRAY
101474: PPUSH
101475: LD_VAR 0 14
101479: PPUSH
101480: LD_INT 1
101482: PPUSH
101483: LD_INT 1
101485: PPUSH
101486: CALL 71224 0 4
101490: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
101491: LD_VAR 0 4
101495: PUSH
101496: LD_VAR 0 7
101500: ARRAY
101501: PPUSH
101502: CALL_OW 257
101506: PUSH
101507: LD_INT 1
101509: EQUAL
101510: IFFALSE 101958
// begin if WantPlant ( group [ i ] ) then
101512: LD_VAR 0 4
101516: PUSH
101517: LD_VAR 0 7
101521: ARRAY
101522: PPUSH
101523: CALL 70725 0 1
101527: IFFALSE 101531
// continue ;
101529: GO 99803
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
101531: LD_VAR 0 18
101535: PUSH
101536: LD_VAR 0 4
101540: PUSH
101541: LD_VAR 0 7
101545: ARRAY
101546: PPUSH
101547: CALL_OW 310
101551: NOT
101552: AND
101553: PUSH
101554: LD_VAR 0 14
101558: PUSH
101559: LD_INT 1
101561: ARRAY
101562: PUSH
101563: LD_VAR 0 14
101567: PPUSH
101568: LD_INT 21
101570: PUSH
101571: LD_INT 2
101573: PUSH
101574: EMPTY
101575: LIST
101576: LIST
101577: PUSH
101578: LD_INT 58
101580: PUSH
101581: EMPTY
101582: LIST
101583: PUSH
101584: EMPTY
101585: LIST
101586: LIST
101587: PPUSH
101588: CALL_OW 72
101592: IN
101593: AND
101594: IFFALSE 101630
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
101596: LD_VAR 0 4
101600: PUSH
101601: LD_VAR 0 7
101605: ARRAY
101606: PPUSH
101607: LD_VAR 0 14
101611: PUSH
101612: LD_INT 1
101614: ARRAY
101615: PPUSH
101616: CALL_OW 120
// attacking := true ;
101620: LD_ADDR_VAR 0 29
101624: PUSH
101625: LD_INT 1
101627: ST_TO_ADDR
// continue ;
101628: GO 99803
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
101630: LD_VAR 0 26
101634: PUSH
101635: LD_VAR 0 4
101639: PUSH
101640: LD_VAR 0 7
101644: ARRAY
101645: PPUSH
101646: CALL_OW 257
101650: PUSH
101651: LD_INT 1
101653: EQUAL
101654: AND
101655: PUSH
101656: LD_VAR 0 4
101660: PUSH
101661: LD_VAR 0 7
101665: ARRAY
101666: PPUSH
101667: CALL_OW 256
101671: PUSH
101672: LD_INT 800
101674: LESS
101675: AND
101676: PUSH
101677: LD_VAR 0 4
101681: PUSH
101682: LD_VAR 0 7
101686: ARRAY
101687: PPUSH
101688: CALL_OW 318
101692: NOT
101693: AND
101694: IFFALSE 101711
// ComCrawl ( group [ i ] ) ;
101696: LD_VAR 0 4
101700: PUSH
101701: LD_VAR 0 7
101705: ARRAY
101706: PPUSH
101707: CALL_OW 137
// if f_mines then
101711: LD_VAR 0 21
101715: IFFALSE 101958
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
101717: LD_VAR 0 14
101721: PUSH
101722: LD_INT 1
101724: ARRAY
101725: PPUSH
101726: CALL_OW 247
101730: PUSH
101731: LD_INT 3
101733: EQUAL
101734: PUSH
101735: LD_VAR 0 14
101739: PUSH
101740: LD_INT 1
101742: ARRAY
101743: PUSH
101744: LD_VAR 0 27
101748: IN
101749: NOT
101750: AND
101751: IFFALSE 101958
// begin x := GetX ( tmp [ 1 ] ) ;
101753: LD_ADDR_VAR 0 10
101757: PUSH
101758: LD_VAR 0 14
101762: PUSH
101763: LD_INT 1
101765: ARRAY
101766: PPUSH
101767: CALL_OW 250
101771: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
101772: LD_ADDR_VAR 0 11
101776: PUSH
101777: LD_VAR 0 14
101781: PUSH
101782: LD_INT 1
101784: ARRAY
101785: PPUSH
101786: CALL_OW 251
101790: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
101791: LD_ADDR_VAR 0 12
101795: PUSH
101796: LD_VAR 0 4
101800: PUSH
101801: LD_VAR 0 7
101805: ARRAY
101806: PPUSH
101807: CALL 97666 0 1
101811: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
101812: LD_VAR 0 4
101816: PUSH
101817: LD_VAR 0 7
101821: ARRAY
101822: PPUSH
101823: LD_VAR 0 10
101827: PPUSH
101828: LD_VAR 0 11
101832: PPUSH
101833: LD_VAR 0 14
101837: PUSH
101838: LD_INT 1
101840: ARRAY
101841: PPUSH
101842: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
101846: LD_VAR 0 4
101850: PUSH
101851: LD_VAR 0 7
101855: ARRAY
101856: PPUSH
101857: LD_VAR 0 10
101861: PPUSH
101862: LD_VAR 0 12
101866: PPUSH
101867: LD_INT 7
101869: PPUSH
101870: CALL_OW 272
101874: PPUSH
101875: LD_VAR 0 11
101879: PPUSH
101880: LD_VAR 0 12
101884: PPUSH
101885: LD_INT 7
101887: PPUSH
101888: CALL_OW 273
101892: PPUSH
101893: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
101897: LD_VAR 0 4
101901: PUSH
101902: LD_VAR 0 7
101906: ARRAY
101907: PPUSH
101908: LD_INT 71
101910: PPUSH
101911: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
101915: LD_ADDR_VAR 0 27
101919: PUSH
101920: LD_VAR 0 27
101924: PPUSH
101925: LD_VAR 0 27
101929: PUSH
101930: LD_INT 1
101932: PLUS
101933: PPUSH
101934: LD_VAR 0 14
101938: PUSH
101939: LD_INT 1
101941: ARRAY
101942: PPUSH
101943: CALL_OW 1
101947: ST_TO_ADDR
// attacking := true ;
101948: LD_ADDR_VAR 0 29
101952: PUSH
101953: LD_INT 1
101955: ST_TO_ADDR
// continue ;
101956: GO 99803
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
101958: LD_VAR 0 4
101962: PUSH
101963: LD_VAR 0 7
101967: ARRAY
101968: PPUSH
101969: CALL_OW 257
101973: PUSH
101974: LD_INT 17
101976: EQUAL
101977: PUSH
101978: LD_VAR 0 4
101982: PUSH
101983: LD_VAR 0 7
101987: ARRAY
101988: PPUSH
101989: CALL_OW 110
101993: PUSH
101994: LD_INT 71
101996: EQUAL
101997: NOT
101998: AND
101999: IFFALSE 102145
// begin attacking := false ;
102001: LD_ADDR_VAR 0 29
102005: PUSH
102006: LD_INT 0
102008: ST_TO_ADDR
// k := 5 ;
102009: LD_ADDR_VAR 0 9
102013: PUSH
102014: LD_INT 5
102016: ST_TO_ADDR
// if tmp < k then
102017: LD_VAR 0 14
102021: PUSH
102022: LD_VAR 0 9
102026: LESS
102027: IFFALSE 102039
// k := tmp ;
102029: LD_ADDR_VAR 0 9
102033: PUSH
102034: LD_VAR 0 14
102038: ST_TO_ADDR
// for j = 1 to k do
102039: LD_ADDR_VAR 0 8
102043: PUSH
102044: DOUBLE
102045: LD_INT 1
102047: DEC
102048: ST_TO_ADDR
102049: LD_VAR 0 9
102053: PUSH
102054: FOR_TO
102055: IFFALSE 102143
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102057: LD_VAR 0 14
102061: PUSH
102062: LD_VAR 0 8
102066: ARRAY
102067: PUSH
102068: LD_VAR 0 14
102072: PPUSH
102073: LD_INT 58
102075: PUSH
102076: EMPTY
102077: LIST
102078: PPUSH
102079: CALL_OW 72
102083: IN
102084: NOT
102085: IFFALSE 102141
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102087: LD_VAR 0 4
102091: PUSH
102092: LD_VAR 0 7
102096: ARRAY
102097: PPUSH
102098: LD_VAR 0 14
102102: PUSH
102103: LD_VAR 0 8
102107: ARRAY
102108: PPUSH
102109: CALL_OW 115
// attacking := true ;
102113: LD_ADDR_VAR 0 29
102117: PUSH
102118: LD_INT 1
102120: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102121: LD_VAR 0 4
102125: PUSH
102126: LD_VAR 0 7
102130: ARRAY
102131: PPUSH
102132: LD_INT 71
102134: PPUSH
102135: CALL_OW 109
// continue ;
102139: GO 102054
// end ; end ;
102141: GO 102054
102143: POP
102144: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102145: LD_VAR 0 4
102149: PUSH
102150: LD_VAR 0 7
102154: ARRAY
102155: PPUSH
102156: CALL_OW 257
102160: PUSH
102161: LD_INT 8
102163: EQUAL
102164: PUSH
102165: LD_VAR 0 4
102169: PUSH
102170: LD_VAR 0 7
102174: ARRAY
102175: PPUSH
102176: CALL_OW 264
102180: PUSH
102181: LD_INT 28
102183: PUSH
102184: LD_INT 45
102186: PUSH
102187: LD_INT 7
102189: PUSH
102190: LD_INT 47
102192: PUSH
102193: EMPTY
102194: LIST
102195: LIST
102196: LIST
102197: LIST
102198: IN
102199: OR
102200: IFFALSE 102430
// begin attacking := false ;
102202: LD_ADDR_VAR 0 29
102206: PUSH
102207: LD_INT 0
102209: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102210: LD_VAR 0 14
102214: PUSH
102215: LD_INT 1
102217: ARRAY
102218: PPUSH
102219: CALL_OW 266
102223: PUSH
102224: LD_INT 32
102226: PUSH
102227: LD_INT 31
102229: PUSH
102230: LD_INT 33
102232: PUSH
102233: LD_INT 4
102235: PUSH
102236: LD_INT 5
102238: PUSH
102239: EMPTY
102240: LIST
102241: LIST
102242: LIST
102243: LIST
102244: LIST
102245: IN
102246: IFFALSE 102430
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102248: LD_ADDR_VAR 0 9
102252: PUSH
102253: LD_VAR 0 14
102257: PUSH
102258: LD_INT 1
102260: ARRAY
102261: PPUSH
102262: CALL_OW 266
102266: PPUSH
102267: LD_VAR 0 14
102271: PUSH
102272: LD_INT 1
102274: ARRAY
102275: PPUSH
102276: CALL_OW 250
102280: PPUSH
102281: LD_VAR 0 14
102285: PUSH
102286: LD_INT 1
102288: ARRAY
102289: PPUSH
102290: CALL_OW 251
102294: PPUSH
102295: LD_VAR 0 14
102299: PUSH
102300: LD_INT 1
102302: ARRAY
102303: PPUSH
102304: CALL_OW 254
102308: PPUSH
102309: LD_VAR 0 14
102313: PUSH
102314: LD_INT 1
102316: ARRAY
102317: PPUSH
102318: CALL_OW 248
102322: PPUSH
102323: LD_INT 0
102325: PPUSH
102326: CALL 79036 0 6
102330: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
102331: LD_ADDR_VAR 0 8
102335: PUSH
102336: LD_VAR 0 4
102340: PUSH
102341: LD_VAR 0 7
102345: ARRAY
102346: PPUSH
102347: LD_VAR 0 9
102351: PPUSH
102352: CALL 97729 0 2
102356: ST_TO_ADDR
// if j then
102357: LD_VAR 0 8
102361: IFFALSE 102430
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
102363: LD_VAR 0 8
102367: PUSH
102368: LD_INT 1
102370: ARRAY
102371: PPUSH
102372: LD_VAR 0 8
102376: PUSH
102377: LD_INT 2
102379: ARRAY
102380: PPUSH
102381: CALL_OW 488
102385: IFFALSE 102430
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
102387: LD_VAR 0 4
102391: PUSH
102392: LD_VAR 0 7
102396: ARRAY
102397: PPUSH
102398: LD_VAR 0 8
102402: PUSH
102403: LD_INT 1
102405: ARRAY
102406: PPUSH
102407: LD_VAR 0 8
102411: PUSH
102412: LD_INT 2
102414: ARRAY
102415: PPUSH
102416: CALL_OW 116
// attacking := true ;
102420: LD_ADDR_VAR 0 29
102424: PUSH
102425: LD_INT 1
102427: ST_TO_ADDR
// continue ;
102428: GO 99803
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
102430: LD_VAR 0 4
102434: PUSH
102435: LD_VAR 0 7
102439: ARRAY
102440: PPUSH
102441: CALL_OW 265
102445: PUSH
102446: LD_INT 11
102448: EQUAL
102449: IFFALSE 102727
// begin k := 10 ;
102451: LD_ADDR_VAR 0 9
102455: PUSH
102456: LD_INT 10
102458: ST_TO_ADDR
// x := 0 ;
102459: LD_ADDR_VAR 0 10
102463: PUSH
102464: LD_INT 0
102466: ST_TO_ADDR
// if tmp < k then
102467: LD_VAR 0 14
102471: PUSH
102472: LD_VAR 0 9
102476: LESS
102477: IFFALSE 102489
// k := tmp ;
102479: LD_ADDR_VAR 0 9
102483: PUSH
102484: LD_VAR 0 14
102488: ST_TO_ADDR
// for j = k downto 1 do
102489: LD_ADDR_VAR 0 8
102493: PUSH
102494: DOUBLE
102495: LD_VAR 0 9
102499: INC
102500: ST_TO_ADDR
102501: LD_INT 1
102503: PUSH
102504: FOR_DOWNTO
102505: IFFALSE 102580
// begin if GetType ( tmp [ j ] ) = unit_human then
102507: LD_VAR 0 14
102511: PUSH
102512: LD_VAR 0 8
102516: ARRAY
102517: PPUSH
102518: CALL_OW 247
102522: PUSH
102523: LD_INT 1
102525: EQUAL
102526: IFFALSE 102578
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
102528: LD_VAR 0 4
102532: PUSH
102533: LD_VAR 0 7
102537: ARRAY
102538: PPUSH
102539: LD_VAR 0 14
102543: PUSH
102544: LD_VAR 0 8
102548: ARRAY
102549: PPUSH
102550: CALL 98000 0 2
// x := tmp [ j ] ;
102554: LD_ADDR_VAR 0 10
102558: PUSH
102559: LD_VAR 0 14
102563: PUSH
102564: LD_VAR 0 8
102568: ARRAY
102569: ST_TO_ADDR
// attacking := true ;
102570: LD_ADDR_VAR 0 29
102574: PUSH
102575: LD_INT 1
102577: ST_TO_ADDR
// end ; end ;
102578: GO 102504
102580: POP
102581: POP
// if not x then
102582: LD_VAR 0 10
102586: NOT
102587: IFFALSE 102727
// begin attacking := true ;
102589: LD_ADDR_VAR 0 29
102593: PUSH
102594: LD_INT 1
102596: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
102597: LD_VAR 0 4
102601: PUSH
102602: LD_VAR 0 7
102606: ARRAY
102607: PPUSH
102608: CALL_OW 250
102612: PPUSH
102613: LD_VAR 0 4
102617: PUSH
102618: LD_VAR 0 7
102622: ARRAY
102623: PPUSH
102624: CALL_OW 251
102628: PPUSH
102629: CALL_OW 546
102633: PUSH
102634: LD_INT 2
102636: ARRAY
102637: PUSH
102638: LD_VAR 0 14
102642: PUSH
102643: LD_INT 1
102645: ARRAY
102646: PPUSH
102647: CALL_OW 250
102651: PPUSH
102652: LD_VAR 0 14
102656: PUSH
102657: LD_INT 1
102659: ARRAY
102660: PPUSH
102661: CALL_OW 251
102665: PPUSH
102666: CALL_OW 546
102670: PUSH
102671: LD_INT 2
102673: ARRAY
102674: EQUAL
102675: IFFALSE 102703
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
102677: LD_VAR 0 4
102681: PUSH
102682: LD_VAR 0 7
102686: ARRAY
102687: PPUSH
102688: LD_VAR 0 14
102692: PUSH
102693: LD_INT 1
102695: ARRAY
102696: PPUSH
102697: CALL 98000 0 2
102701: GO 102727
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102703: LD_VAR 0 4
102707: PUSH
102708: LD_VAR 0 7
102712: ARRAY
102713: PPUSH
102714: LD_VAR 0 14
102718: PUSH
102719: LD_INT 1
102721: ARRAY
102722: PPUSH
102723: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
102727: LD_VAR 0 4
102731: PUSH
102732: LD_VAR 0 7
102736: ARRAY
102737: PPUSH
102738: CALL_OW 264
102742: PUSH
102743: LD_INT 29
102745: EQUAL
102746: IFFALSE 103112
// begin if WantsToAttack ( group [ i ] ) in bombed then
102748: LD_VAR 0 4
102752: PUSH
102753: LD_VAR 0 7
102757: ARRAY
102758: PPUSH
102759: CALL_OW 319
102763: PUSH
102764: LD_VAR 0 28
102768: IN
102769: IFFALSE 102773
// continue ;
102771: GO 99803
// k := 8 ;
102773: LD_ADDR_VAR 0 9
102777: PUSH
102778: LD_INT 8
102780: ST_TO_ADDR
// x := 0 ;
102781: LD_ADDR_VAR 0 10
102785: PUSH
102786: LD_INT 0
102788: ST_TO_ADDR
// if tmp < k then
102789: LD_VAR 0 14
102793: PUSH
102794: LD_VAR 0 9
102798: LESS
102799: IFFALSE 102811
// k := tmp ;
102801: LD_ADDR_VAR 0 9
102805: PUSH
102806: LD_VAR 0 14
102810: ST_TO_ADDR
// for j = 1 to k do
102811: LD_ADDR_VAR 0 8
102815: PUSH
102816: DOUBLE
102817: LD_INT 1
102819: DEC
102820: ST_TO_ADDR
102821: LD_VAR 0 9
102825: PUSH
102826: FOR_TO
102827: IFFALSE 102959
// begin if GetType ( tmp [ j ] ) = unit_building then
102829: LD_VAR 0 14
102833: PUSH
102834: LD_VAR 0 8
102838: ARRAY
102839: PPUSH
102840: CALL_OW 247
102844: PUSH
102845: LD_INT 3
102847: EQUAL
102848: IFFALSE 102957
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
102850: LD_VAR 0 14
102854: PUSH
102855: LD_VAR 0 8
102859: ARRAY
102860: PUSH
102861: LD_VAR 0 28
102865: IN
102866: NOT
102867: PUSH
102868: LD_VAR 0 14
102872: PUSH
102873: LD_VAR 0 8
102877: ARRAY
102878: PPUSH
102879: CALL_OW 313
102883: AND
102884: IFFALSE 102957
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102886: LD_VAR 0 4
102890: PUSH
102891: LD_VAR 0 7
102895: ARRAY
102896: PPUSH
102897: LD_VAR 0 14
102901: PUSH
102902: LD_VAR 0 8
102906: ARRAY
102907: PPUSH
102908: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
102912: LD_ADDR_VAR 0 28
102916: PUSH
102917: LD_VAR 0 28
102921: PPUSH
102922: LD_VAR 0 28
102926: PUSH
102927: LD_INT 1
102929: PLUS
102930: PPUSH
102931: LD_VAR 0 14
102935: PUSH
102936: LD_VAR 0 8
102940: ARRAY
102941: PPUSH
102942: CALL_OW 1
102946: ST_TO_ADDR
// attacking := true ;
102947: LD_ADDR_VAR 0 29
102951: PUSH
102952: LD_INT 1
102954: ST_TO_ADDR
// break ;
102955: GO 102959
// end ; end ;
102957: GO 102826
102959: POP
102960: POP
// if not attacking and f_attack_depot then
102961: LD_VAR 0 29
102965: NOT
102966: PUSH
102967: LD_VAR 0 25
102971: AND
102972: IFFALSE 103067
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102974: LD_ADDR_VAR 0 13
102978: PUSH
102979: LD_VAR 0 14
102983: PPUSH
102984: LD_INT 2
102986: PUSH
102987: LD_INT 30
102989: PUSH
102990: LD_INT 0
102992: PUSH
102993: EMPTY
102994: LIST
102995: LIST
102996: PUSH
102997: LD_INT 30
102999: PUSH
103000: LD_INT 1
103002: PUSH
103003: EMPTY
103004: LIST
103005: LIST
103006: PUSH
103007: EMPTY
103008: LIST
103009: LIST
103010: LIST
103011: PPUSH
103012: CALL_OW 72
103016: ST_TO_ADDR
// if z then
103017: LD_VAR 0 13
103021: IFFALSE 103067
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103023: LD_VAR 0 4
103027: PUSH
103028: LD_VAR 0 7
103032: ARRAY
103033: PPUSH
103034: LD_VAR 0 13
103038: PPUSH
103039: LD_VAR 0 4
103043: PUSH
103044: LD_VAR 0 7
103048: ARRAY
103049: PPUSH
103050: CALL_OW 74
103054: PPUSH
103055: CALL_OW 115
// attacking := true ;
103059: LD_ADDR_VAR 0 29
103063: PUSH
103064: LD_INT 1
103066: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103067: LD_VAR 0 4
103071: PUSH
103072: LD_VAR 0 7
103076: ARRAY
103077: PPUSH
103078: CALL_OW 256
103082: PUSH
103083: LD_INT 500
103085: LESS
103086: IFFALSE 103112
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103088: LD_VAR 0 4
103092: PUSH
103093: LD_VAR 0 7
103097: ARRAY
103098: PPUSH
103099: LD_VAR 0 14
103103: PUSH
103104: LD_INT 1
103106: ARRAY
103107: PPUSH
103108: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103112: LD_VAR 0 4
103116: PUSH
103117: LD_VAR 0 7
103121: ARRAY
103122: PPUSH
103123: CALL_OW 264
103127: PUSH
103128: LD_INT 49
103130: EQUAL
103131: IFFALSE 103252
// begin if not HasTask ( group [ i ] ) then
103133: LD_VAR 0 4
103137: PUSH
103138: LD_VAR 0 7
103142: ARRAY
103143: PPUSH
103144: CALL_OW 314
103148: NOT
103149: IFFALSE 103252
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103151: LD_ADDR_VAR 0 9
103155: PUSH
103156: LD_INT 81
103158: PUSH
103159: LD_VAR 0 4
103163: PUSH
103164: LD_VAR 0 7
103168: ARRAY
103169: PPUSH
103170: CALL_OW 255
103174: PUSH
103175: EMPTY
103176: LIST
103177: LIST
103178: PPUSH
103179: CALL_OW 69
103183: PPUSH
103184: LD_VAR 0 4
103188: PUSH
103189: LD_VAR 0 7
103193: ARRAY
103194: PPUSH
103195: CALL_OW 74
103199: ST_TO_ADDR
// if k then
103200: LD_VAR 0 9
103204: IFFALSE 103252
// if GetDistUnits ( group [ i ] , k ) > 10 then
103206: LD_VAR 0 4
103210: PUSH
103211: LD_VAR 0 7
103215: ARRAY
103216: PPUSH
103217: LD_VAR 0 9
103221: PPUSH
103222: CALL_OW 296
103226: PUSH
103227: LD_INT 10
103229: GREATER
103230: IFFALSE 103252
// ComMoveUnit ( group [ i ] , k ) ;
103232: LD_VAR 0 4
103236: PUSH
103237: LD_VAR 0 7
103241: ARRAY
103242: PPUSH
103243: LD_VAR 0 9
103247: PPUSH
103248: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103252: LD_VAR 0 4
103256: PUSH
103257: LD_VAR 0 7
103261: ARRAY
103262: PPUSH
103263: CALL_OW 256
103267: PUSH
103268: LD_INT 250
103270: LESS
103271: PUSH
103272: LD_VAR 0 4
103276: PUSH
103277: LD_VAR 0 7
103281: ARRAY
103282: PUSH
103283: LD_INT 21
103285: PUSH
103286: LD_INT 2
103288: PUSH
103289: EMPTY
103290: LIST
103291: LIST
103292: PUSH
103293: LD_INT 23
103295: PUSH
103296: LD_INT 2
103298: PUSH
103299: EMPTY
103300: LIST
103301: LIST
103302: PUSH
103303: EMPTY
103304: LIST
103305: LIST
103306: PPUSH
103307: CALL_OW 69
103311: IN
103312: AND
103313: IFFALSE 103438
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
103315: LD_ADDR_VAR 0 9
103319: PUSH
103320: LD_OWVAR 3
103324: PUSH
103325: LD_VAR 0 4
103329: PUSH
103330: LD_VAR 0 7
103334: ARRAY
103335: DIFF
103336: PPUSH
103337: LD_VAR 0 4
103341: PUSH
103342: LD_VAR 0 7
103346: ARRAY
103347: PPUSH
103348: CALL_OW 74
103352: ST_TO_ADDR
// if not k then
103353: LD_VAR 0 9
103357: NOT
103358: IFFALSE 103362
// continue ;
103360: GO 99803
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
103362: LD_VAR 0 9
103366: PUSH
103367: LD_INT 81
103369: PUSH
103370: LD_VAR 0 4
103374: PUSH
103375: LD_VAR 0 7
103379: ARRAY
103380: PPUSH
103381: CALL_OW 255
103385: PUSH
103386: EMPTY
103387: LIST
103388: LIST
103389: PPUSH
103390: CALL_OW 69
103394: IN
103395: PUSH
103396: LD_VAR 0 9
103400: PPUSH
103401: LD_VAR 0 4
103405: PUSH
103406: LD_VAR 0 7
103410: ARRAY
103411: PPUSH
103412: CALL_OW 296
103416: PUSH
103417: LD_INT 5
103419: LESS
103420: AND
103421: IFFALSE 103438
// ComAutodestruct ( group [ i ] ) ;
103423: LD_VAR 0 4
103427: PUSH
103428: LD_VAR 0 7
103432: ARRAY
103433: PPUSH
103434: CALL 97898 0 1
// end ; if f_attack_depot then
103438: LD_VAR 0 25
103442: IFFALSE 103554
// begin k := 6 ;
103444: LD_ADDR_VAR 0 9
103448: PUSH
103449: LD_INT 6
103451: ST_TO_ADDR
// if tmp < k then
103452: LD_VAR 0 14
103456: PUSH
103457: LD_VAR 0 9
103461: LESS
103462: IFFALSE 103474
// k := tmp ;
103464: LD_ADDR_VAR 0 9
103468: PUSH
103469: LD_VAR 0 14
103473: ST_TO_ADDR
// for j = 1 to k do
103474: LD_ADDR_VAR 0 8
103478: PUSH
103479: DOUBLE
103480: LD_INT 1
103482: DEC
103483: ST_TO_ADDR
103484: LD_VAR 0 9
103488: PUSH
103489: FOR_TO
103490: IFFALSE 103552
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103492: LD_VAR 0 8
103496: PPUSH
103497: CALL_OW 266
103501: PUSH
103502: LD_INT 0
103504: PUSH
103505: LD_INT 1
103507: PUSH
103508: EMPTY
103509: LIST
103510: LIST
103511: IN
103512: IFFALSE 103550
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103514: LD_VAR 0 4
103518: PUSH
103519: LD_VAR 0 7
103523: ARRAY
103524: PPUSH
103525: LD_VAR 0 14
103529: PUSH
103530: LD_VAR 0 8
103534: ARRAY
103535: PPUSH
103536: CALL_OW 115
// attacking := true ;
103540: LD_ADDR_VAR 0 29
103544: PUSH
103545: LD_INT 1
103547: ST_TO_ADDR
// break ;
103548: GO 103552
// end ;
103550: GO 103489
103552: POP
103553: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103554: LD_VAR 0 4
103558: PUSH
103559: LD_VAR 0 7
103563: ARRAY
103564: PPUSH
103565: CALL_OW 302
103569: PUSH
103570: LD_VAR 0 29
103574: NOT
103575: AND
103576: IFFALSE 103898
// begin if GetTag ( group [ i ] ) = 71 then
103578: LD_VAR 0 4
103582: PUSH
103583: LD_VAR 0 7
103587: ARRAY
103588: PPUSH
103589: CALL_OW 110
103593: PUSH
103594: LD_INT 71
103596: EQUAL
103597: IFFALSE 103638
// begin if HasTask ( group [ i ] ) then
103599: LD_VAR 0 4
103603: PUSH
103604: LD_VAR 0 7
103608: ARRAY
103609: PPUSH
103610: CALL_OW 314
103614: IFFALSE 103620
// continue else
103616: GO 99803
103618: GO 103638
// SetTag ( group [ i ] , 0 ) ;
103620: LD_VAR 0 4
103624: PUSH
103625: LD_VAR 0 7
103629: ARRAY
103630: PPUSH
103631: LD_INT 0
103633: PPUSH
103634: CALL_OW 109
// end ; k := 8 ;
103638: LD_ADDR_VAR 0 9
103642: PUSH
103643: LD_INT 8
103645: ST_TO_ADDR
// x := 0 ;
103646: LD_ADDR_VAR 0 10
103650: PUSH
103651: LD_INT 0
103653: ST_TO_ADDR
// if tmp < k then
103654: LD_VAR 0 14
103658: PUSH
103659: LD_VAR 0 9
103663: LESS
103664: IFFALSE 103676
// k := tmp ;
103666: LD_ADDR_VAR 0 9
103670: PUSH
103671: LD_VAR 0 14
103675: ST_TO_ADDR
// for j = 1 to k do
103676: LD_ADDR_VAR 0 8
103680: PUSH
103681: DOUBLE
103682: LD_INT 1
103684: DEC
103685: ST_TO_ADDR
103686: LD_VAR 0 9
103690: PUSH
103691: FOR_TO
103692: IFFALSE 103790
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
103694: LD_VAR 0 14
103698: PUSH
103699: LD_VAR 0 8
103703: ARRAY
103704: PPUSH
103705: CALL_OW 247
103709: PUSH
103710: LD_INT 1
103712: EQUAL
103713: PUSH
103714: LD_VAR 0 14
103718: PUSH
103719: LD_VAR 0 8
103723: ARRAY
103724: PPUSH
103725: CALL_OW 256
103729: PUSH
103730: LD_INT 250
103732: LESS
103733: PUSH
103734: LD_VAR 0 20
103738: AND
103739: PUSH
103740: LD_VAR 0 20
103744: NOT
103745: PUSH
103746: LD_VAR 0 14
103750: PUSH
103751: LD_VAR 0 8
103755: ARRAY
103756: PPUSH
103757: CALL_OW 256
103761: PUSH
103762: LD_INT 250
103764: GREATEREQUAL
103765: AND
103766: OR
103767: AND
103768: IFFALSE 103788
// begin x := tmp [ j ] ;
103770: LD_ADDR_VAR 0 10
103774: PUSH
103775: LD_VAR 0 14
103779: PUSH
103780: LD_VAR 0 8
103784: ARRAY
103785: ST_TO_ADDR
// break ;
103786: GO 103790
// end ;
103788: GO 103691
103790: POP
103791: POP
// if x then
103792: LD_VAR 0 10
103796: IFFALSE 103820
// ComAttackUnit ( group [ i ] , x ) else
103798: LD_VAR 0 4
103802: PUSH
103803: LD_VAR 0 7
103807: ARRAY
103808: PPUSH
103809: LD_VAR 0 10
103813: PPUSH
103814: CALL_OW 115
103818: GO 103844
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103820: LD_VAR 0 4
103824: PUSH
103825: LD_VAR 0 7
103829: ARRAY
103830: PPUSH
103831: LD_VAR 0 14
103835: PUSH
103836: LD_INT 1
103838: ARRAY
103839: PPUSH
103840: CALL_OW 115
// if not HasTask ( group [ i ] ) then
103844: LD_VAR 0 4
103848: PUSH
103849: LD_VAR 0 7
103853: ARRAY
103854: PPUSH
103855: CALL_OW 314
103859: NOT
103860: IFFALSE 103898
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
103862: LD_VAR 0 4
103866: PUSH
103867: LD_VAR 0 7
103871: ARRAY
103872: PPUSH
103873: LD_VAR 0 14
103877: PPUSH
103878: LD_VAR 0 4
103882: PUSH
103883: LD_VAR 0 7
103887: ARRAY
103888: PPUSH
103889: CALL_OW 74
103893: PPUSH
103894: CALL_OW 115
// end ; end ; end ;
103898: GO 99803
103900: POP
103901: POP
// wait ( 0 0$1 ) ;
103902: LD_INT 35
103904: PPUSH
103905: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
103909: LD_VAR 0 4
103913: PUSH
103914: EMPTY
103915: EQUAL
103916: PUSH
103917: LD_INT 81
103919: PUSH
103920: LD_VAR 0 35
103924: PUSH
103925: EMPTY
103926: LIST
103927: LIST
103928: PPUSH
103929: CALL_OW 69
103933: NOT
103934: OR
103935: IFFALSE 99788
// end ;
103937: LD_VAR 0 2
103941: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
103942: LD_INT 0
103944: PPUSH
103945: PPUSH
103946: PPUSH
103947: PPUSH
// if not base_units then
103948: LD_VAR 0 1
103952: NOT
103953: IFFALSE 103957
// exit ;
103955: GO 104044
// result := false ;
103957: LD_ADDR_VAR 0 2
103961: PUSH
103962: LD_INT 0
103964: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
103965: LD_ADDR_VAR 0 5
103969: PUSH
103970: LD_VAR 0 1
103974: PPUSH
103975: LD_INT 21
103977: PUSH
103978: LD_INT 3
103980: PUSH
103981: EMPTY
103982: LIST
103983: LIST
103984: PPUSH
103985: CALL_OW 72
103989: ST_TO_ADDR
// if not tmp then
103990: LD_VAR 0 5
103994: NOT
103995: IFFALSE 103999
// exit ;
103997: GO 104044
// for i in tmp do
103999: LD_ADDR_VAR 0 3
104003: PUSH
104004: LD_VAR 0 5
104008: PUSH
104009: FOR_IN
104010: IFFALSE 104042
// begin result := EnemyInRange ( i , 22 ) ;
104012: LD_ADDR_VAR 0 2
104016: PUSH
104017: LD_VAR 0 3
104021: PPUSH
104022: LD_INT 22
104024: PPUSH
104025: CALL 97581 0 2
104029: ST_TO_ADDR
// if result then
104030: LD_VAR 0 2
104034: IFFALSE 104040
// exit ;
104036: POP
104037: POP
104038: GO 104044
// end ;
104040: GO 104009
104042: POP
104043: POP
// end ;
104044: LD_VAR 0 2
104048: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
104049: LD_INT 0
104051: PPUSH
104052: PPUSH
// if not units then
104053: LD_VAR 0 1
104057: NOT
104058: IFFALSE 104062
// exit ;
104060: GO 104132
// result := [ ] ;
104062: LD_ADDR_VAR 0 3
104066: PUSH
104067: EMPTY
104068: ST_TO_ADDR
// for i in units do
104069: LD_ADDR_VAR 0 4
104073: PUSH
104074: LD_VAR 0 1
104078: PUSH
104079: FOR_IN
104080: IFFALSE 104130
// if GetTag ( i ) = tag then
104082: LD_VAR 0 4
104086: PPUSH
104087: CALL_OW 110
104091: PUSH
104092: LD_VAR 0 2
104096: EQUAL
104097: IFFALSE 104128
// result := Insert ( result , result + 1 , i ) ;
104099: LD_ADDR_VAR 0 3
104103: PUSH
104104: LD_VAR 0 3
104108: PPUSH
104109: LD_VAR 0 3
104113: PUSH
104114: LD_INT 1
104116: PLUS
104117: PPUSH
104118: LD_VAR 0 4
104122: PPUSH
104123: CALL_OW 2
104127: ST_TO_ADDR
104128: GO 104079
104130: POP
104131: POP
// end ;
104132: LD_VAR 0 3
104136: RET
// export function IsDriver ( un ) ; begin
104137: LD_INT 0
104139: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104140: LD_ADDR_VAR 0 2
104144: PUSH
104145: LD_VAR 0 1
104149: PUSH
104150: LD_INT 55
104152: PUSH
104153: EMPTY
104154: LIST
104155: PPUSH
104156: CALL_OW 69
104160: IN
104161: ST_TO_ADDR
// end ;
104162: LD_VAR 0 2
104166: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104167: LD_INT 0
104169: PPUSH
104170: PPUSH
// list := [ ] ;
104171: LD_ADDR_VAR 0 5
104175: PUSH
104176: EMPTY
104177: ST_TO_ADDR
// case d of 0 :
104178: LD_VAR 0 3
104182: PUSH
104183: LD_INT 0
104185: DOUBLE
104186: EQUAL
104187: IFTRUE 104191
104189: GO 104324
104191: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104192: LD_ADDR_VAR 0 5
104196: PUSH
104197: LD_VAR 0 1
104201: PUSH
104202: LD_INT 4
104204: MINUS
104205: PUSH
104206: LD_VAR 0 2
104210: PUSH
104211: LD_INT 4
104213: MINUS
104214: PUSH
104215: LD_INT 2
104217: PUSH
104218: EMPTY
104219: LIST
104220: LIST
104221: LIST
104222: PUSH
104223: LD_VAR 0 1
104227: PUSH
104228: LD_INT 3
104230: MINUS
104231: PUSH
104232: LD_VAR 0 2
104236: PUSH
104237: LD_INT 1
104239: PUSH
104240: EMPTY
104241: LIST
104242: LIST
104243: LIST
104244: PUSH
104245: LD_VAR 0 1
104249: PUSH
104250: LD_INT 4
104252: PLUS
104253: PUSH
104254: LD_VAR 0 2
104258: PUSH
104259: LD_INT 4
104261: PUSH
104262: EMPTY
104263: LIST
104264: LIST
104265: LIST
104266: PUSH
104267: LD_VAR 0 1
104271: PUSH
104272: LD_INT 3
104274: PLUS
104275: PUSH
104276: LD_VAR 0 2
104280: PUSH
104281: LD_INT 3
104283: PLUS
104284: PUSH
104285: LD_INT 5
104287: PUSH
104288: EMPTY
104289: LIST
104290: LIST
104291: LIST
104292: PUSH
104293: LD_VAR 0 1
104297: PUSH
104298: LD_VAR 0 2
104302: PUSH
104303: LD_INT 4
104305: PLUS
104306: PUSH
104307: LD_INT 0
104309: PUSH
104310: EMPTY
104311: LIST
104312: LIST
104313: LIST
104314: PUSH
104315: EMPTY
104316: LIST
104317: LIST
104318: LIST
104319: LIST
104320: LIST
104321: ST_TO_ADDR
// end ; 1 :
104322: GO 105022
104324: LD_INT 1
104326: DOUBLE
104327: EQUAL
104328: IFTRUE 104332
104330: GO 104465
104332: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
104333: LD_ADDR_VAR 0 5
104337: PUSH
104338: LD_VAR 0 1
104342: PUSH
104343: LD_VAR 0 2
104347: PUSH
104348: LD_INT 4
104350: MINUS
104351: PUSH
104352: LD_INT 3
104354: PUSH
104355: EMPTY
104356: LIST
104357: LIST
104358: LIST
104359: PUSH
104360: LD_VAR 0 1
104364: PUSH
104365: LD_INT 3
104367: MINUS
104368: PUSH
104369: LD_VAR 0 2
104373: PUSH
104374: LD_INT 3
104376: MINUS
104377: PUSH
104378: LD_INT 2
104380: PUSH
104381: EMPTY
104382: LIST
104383: LIST
104384: LIST
104385: PUSH
104386: LD_VAR 0 1
104390: PUSH
104391: LD_INT 4
104393: MINUS
104394: PUSH
104395: LD_VAR 0 2
104399: PUSH
104400: LD_INT 1
104402: PUSH
104403: EMPTY
104404: LIST
104405: LIST
104406: LIST
104407: PUSH
104408: LD_VAR 0 1
104412: PUSH
104413: LD_VAR 0 2
104417: PUSH
104418: LD_INT 3
104420: PLUS
104421: PUSH
104422: LD_INT 0
104424: PUSH
104425: EMPTY
104426: LIST
104427: LIST
104428: LIST
104429: PUSH
104430: LD_VAR 0 1
104434: PUSH
104435: LD_INT 4
104437: PLUS
104438: PUSH
104439: LD_VAR 0 2
104443: PUSH
104444: LD_INT 4
104446: PLUS
104447: PUSH
104448: LD_INT 5
104450: PUSH
104451: EMPTY
104452: LIST
104453: LIST
104454: LIST
104455: PUSH
104456: EMPTY
104457: LIST
104458: LIST
104459: LIST
104460: LIST
104461: LIST
104462: ST_TO_ADDR
// end ; 2 :
104463: GO 105022
104465: LD_INT 2
104467: DOUBLE
104468: EQUAL
104469: IFTRUE 104473
104471: GO 104602
104473: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
104474: LD_ADDR_VAR 0 5
104478: PUSH
104479: LD_VAR 0 1
104483: PUSH
104484: LD_VAR 0 2
104488: PUSH
104489: LD_INT 3
104491: MINUS
104492: PUSH
104493: LD_INT 3
104495: PUSH
104496: EMPTY
104497: LIST
104498: LIST
104499: LIST
104500: PUSH
104501: LD_VAR 0 1
104505: PUSH
104506: LD_INT 4
104508: PLUS
104509: PUSH
104510: LD_VAR 0 2
104514: PUSH
104515: LD_INT 4
104517: PUSH
104518: EMPTY
104519: LIST
104520: LIST
104521: LIST
104522: PUSH
104523: LD_VAR 0 1
104527: PUSH
104528: LD_VAR 0 2
104532: PUSH
104533: LD_INT 4
104535: PLUS
104536: PUSH
104537: LD_INT 0
104539: PUSH
104540: EMPTY
104541: LIST
104542: LIST
104543: LIST
104544: PUSH
104545: LD_VAR 0 1
104549: PUSH
104550: LD_INT 3
104552: MINUS
104553: PUSH
104554: LD_VAR 0 2
104558: PUSH
104559: LD_INT 1
104561: PUSH
104562: EMPTY
104563: LIST
104564: LIST
104565: LIST
104566: PUSH
104567: LD_VAR 0 1
104571: PUSH
104572: LD_INT 4
104574: MINUS
104575: PUSH
104576: LD_VAR 0 2
104580: PUSH
104581: LD_INT 4
104583: MINUS
104584: PUSH
104585: LD_INT 2
104587: PUSH
104588: EMPTY
104589: LIST
104590: LIST
104591: LIST
104592: PUSH
104593: EMPTY
104594: LIST
104595: LIST
104596: LIST
104597: LIST
104598: LIST
104599: ST_TO_ADDR
// end ; 3 :
104600: GO 105022
104602: LD_INT 3
104604: DOUBLE
104605: EQUAL
104606: IFTRUE 104610
104608: GO 104743
104610: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
104611: LD_ADDR_VAR 0 5
104615: PUSH
104616: LD_VAR 0 1
104620: PUSH
104621: LD_INT 3
104623: PLUS
104624: PUSH
104625: LD_VAR 0 2
104629: PUSH
104630: LD_INT 4
104632: PUSH
104633: EMPTY
104634: LIST
104635: LIST
104636: LIST
104637: PUSH
104638: LD_VAR 0 1
104642: PUSH
104643: LD_INT 4
104645: PLUS
104646: PUSH
104647: LD_VAR 0 2
104651: PUSH
104652: LD_INT 4
104654: PLUS
104655: PUSH
104656: LD_INT 5
104658: PUSH
104659: EMPTY
104660: LIST
104661: LIST
104662: LIST
104663: PUSH
104664: LD_VAR 0 1
104668: PUSH
104669: LD_INT 4
104671: MINUS
104672: PUSH
104673: LD_VAR 0 2
104677: PUSH
104678: LD_INT 1
104680: PUSH
104681: EMPTY
104682: LIST
104683: LIST
104684: LIST
104685: PUSH
104686: LD_VAR 0 1
104690: PUSH
104691: LD_VAR 0 2
104695: PUSH
104696: LD_INT 4
104698: MINUS
104699: PUSH
104700: LD_INT 3
104702: PUSH
104703: EMPTY
104704: LIST
104705: LIST
104706: LIST
104707: PUSH
104708: LD_VAR 0 1
104712: PUSH
104713: LD_INT 3
104715: MINUS
104716: PUSH
104717: LD_VAR 0 2
104721: PUSH
104722: LD_INT 3
104724: MINUS
104725: PUSH
104726: LD_INT 2
104728: PUSH
104729: EMPTY
104730: LIST
104731: LIST
104732: LIST
104733: PUSH
104734: EMPTY
104735: LIST
104736: LIST
104737: LIST
104738: LIST
104739: LIST
104740: ST_TO_ADDR
// end ; 4 :
104741: GO 105022
104743: LD_INT 4
104745: DOUBLE
104746: EQUAL
104747: IFTRUE 104751
104749: GO 104884
104751: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
104752: LD_ADDR_VAR 0 5
104756: PUSH
104757: LD_VAR 0 1
104761: PUSH
104762: LD_VAR 0 2
104766: PUSH
104767: LD_INT 4
104769: PLUS
104770: PUSH
104771: LD_INT 0
104773: PUSH
104774: EMPTY
104775: LIST
104776: LIST
104777: LIST
104778: PUSH
104779: LD_VAR 0 1
104783: PUSH
104784: LD_INT 3
104786: PLUS
104787: PUSH
104788: LD_VAR 0 2
104792: PUSH
104793: LD_INT 3
104795: PLUS
104796: PUSH
104797: LD_INT 5
104799: PUSH
104800: EMPTY
104801: LIST
104802: LIST
104803: LIST
104804: PUSH
104805: LD_VAR 0 1
104809: PUSH
104810: LD_INT 4
104812: PLUS
104813: PUSH
104814: LD_VAR 0 2
104818: PUSH
104819: LD_INT 4
104821: PUSH
104822: EMPTY
104823: LIST
104824: LIST
104825: LIST
104826: PUSH
104827: LD_VAR 0 1
104831: PUSH
104832: LD_VAR 0 2
104836: PUSH
104837: LD_INT 3
104839: MINUS
104840: PUSH
104841: LD_INT 3
104843: PUSH
104844: EMPTY
104845: LIST
104846: LIST
104847: LIST
104848: PUSH
104849: LD_VAR 0 1
104853: PUSH
104854: LD_INT 4
104856: MINUS
104857: PUSH
104858: LD_VAR 0 2
104862: PUSH
104863: LD_INT 4
104865: MINUS
104866: PUSH
104867: LD_INT 2
104869: PUSH
104870: EMPTY
104871: LIST
104872: LIST
104873: LIST
104874: PUSH
104875: EMPTY
104876: LIST
104877: LIST
104878: LIST
104879: LIST
104880: LIST
104881: ST_TO_ADDR
// end ; 5 :
104882: GO 105022
104884: LD_INT 5
104886: DOUBLE
104887: EQUAL
104888: IFTRUE 104892
104890: GO 105021
104892: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
104893: LD_ADDR_VAR 0 5
104897: PUSH
104898: LD_VAR 0 1
104902: PUSH
104903: LD_INT 4
104905: MINUS
104906: PUSH
104907: LD_VAR 0 2
104911: PUSH
104912: LD_INT 1
104914: PUSH
104915: EMPTY
104916: LIST
104917: LIST
104918: LIST
104919: PUSH
104920: LD_VAR 0 1
104924: PUSH
104925: LD_VAR 0 2
104929: PUSH
104930: LD_INT 4
104932: MINUS
104933: PUSH
104934: LD_INT 3
104936: PUSH
104937: EMPTY
104938: LIST
104939: LIST
104940: LIST
104941: PUSH
104942: LD_VAR 0 1
104946: PUSH
104947: LD_INT 4
104949: PLUS
104950: PUSH
104951: LD_VAR 0 2
104955: PUSH
104956: LD_INT 4
104958: PLUS
104959: PUSH
104960: LD_INT 5
104962: PUSH
104963: EMPTY
104964: LIST
104965: LIST
104966: LIST
104967: PUSH
104968: LD_VAR 0 1
104972: PUSH
104973: LD_INT 3
104975: PLUS
104976: PUSH
104977: LD_VAR 0 2
104981: PUSH
104982: LD_INT 4
104984: PUSH
104985: EMPTY
104986: LIST
104987: LIST
104988: LIST
104989: PUSH
104990: LD_VAR 0 1
104994: PUSH
104995: LD_VAR 0 2
104999: PUSH
105000: LD_INT 3
105002: PLUS
105003: PUSH
105004: LD_INT 0
105006: PUSH
105007: EMPTY
105008: LIST
105009: LIST
105010: LIST
105011: PUSH
105012: EMPTY
105013: LIST
105014: LIST
105015: LIST
105016: LIST
105017: LIST
105018: ST_TO_ADDR
// end ; end ;
105019: GO 105022
105021: POP
// result := list ;
105022: LD_ADDR_VAR 0 4
105026: PUSH
105027: LD_VAR 0 5
105031: ST_TO_ADDR
// end ;
105032: LD_VAR 0 4
105036: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105037: LD_INT 0
105039: PPUSH
105040: PPUSH
105041: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105042: LD_VAR 0 1
105046: NOT
105047: PUSH
105048: LD_VAR 0 2
105052: PUSH
105053: LD_INT 1
105055: PUSH
105056: LD_INT 2
105058: PUSH
105059: LD_INT 3
105061: PUSH
105062: LD_INT 4
105064: PUSH
105065: EMPTY
105066: LIST
105067: LIST
105068: LIST
105069: LIST
105070: IN
105071: NOT
105072: OR
105073: IFFALSE 105077
// exit ;
105075: GO 105169
// tmp := [ ] ;
105077: LD_ADDR_VAR 0 5
105081: PUSH
105082: EMPTY
105083: ST_TO_ADDR
// for i in units do
105084: LD_ADDR_VAR 0 4
105088: PUSH
105089: LD_VAR 0 1
105093: PUSH
105094: FOR_IN
105095: IFFALSE 105138
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
105097: LD_ADDR_VAR 0 5
105101: PUSH
105102: LD_VAR 0 5
105106: PPUSH
105107: LD_VAR 0 5
105111: PUSH
105112: LD_INT 1
105114: PLUS
105115: PPUSH
105116: LD_VAR 0 4
105120: PPUSH
105121: LD_VAR 0 2
105125: PPUSH
105126: CALL_OW 259
105130: PPUSH
105131: CALL_OW 2
105135: ST_TO_ADDR
105136: GO 105094
105138: POP
105139: POP
// if not tmp then
105140: LD_VAR 0 5
105144: NOT
105145: IFFALSE 105149
// exit ;
105147: GO 105169
// result := SortListByListDesc ( units , tmp ) ;
105149: LD_ADDR_VAR 0 3
105153: PUSH
105154: LD_VAR 0 1
105158: PPUSH
105159: LD_VAR 0 5
105163: PPUSH
105164: CALL_OW 77
105168: ST_TO_ADDR
// end ;
105169: LD_VAR 0 3
105173: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105174: LD_INT 0
105176: PPUSH
105177: PPUSH
105178: PPUSH
// x := GetX ( building ) ;
105179: LD_ADDR_VAR 0 4
105183: PUSH
105184: LD_VAR 0 2
105188: PPUSH
105189: CALL_OW 250
105193: ST_TO_ADDR
// y := GetY ( building ) ;
105194: LD_ADDR_VAR 0 5
105198: PUSH
105199: LD_VAR 0 2
105203: PPUSH
105204: CALL_OW 251
105208: ST_TO_ADDR
// if GetTaskList ( unit ) then
105209: LD_VAR 0 1
105213: PPUSH
105214: CALL_OW 437
105218: IFFALSE 105313
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105220: LD_STRING e
105222: PUSH
105223: LD_VAR 0 1
105227: PPUSH
105228: CALL_OW 437
105232: PUSH
105233: LD_INT 1
105235: ARRAY
105236: PUSH
105237: LD_INT 1
105239: ARRAY
105240: EQUAL
105241: PUSH
105242: LD_VAR 0 4
105246: PUSH
105247: LD_VAR 0 1
105251: PPUSH
105252: CALL_OW 437
105256: PUSH
105257: LD_INT 1
105259: ARRAY
105260: PUSH
105261: LD_INT 2
105263: ARRAY
105264: EQUAL
105265: AND
105266: PUSH
105267: LD_VAR 0 5
105271: PUSH
105272: LD_VAR 0 1
105276: PPUSH
105277: CALL_OW 437
105281: PUSH
105282: LD_INT 1
105284: ARRAY
105285: PUSH
105286: LD_INT 3
105288: ARRAY
105289: EQUAL
105290: AND
105291: IFFALSE 105303
// result := true else
105293: LD_ADDR_VAR 0 3
105297: PUSH
105298: LD_INT 1
105300: ST_TO_ADDR
105301: GO 105311
// result := false ;
105303: LD_ADDR_VAR 0 3
105307: PUSH
105308: LD_INT 0
105310: ST_TO_ADDR
// end else
105311: GO 105321
// result := false ;
105313: LD_ADDR_VAR 0 3
105317: PUSH
105318: LD_INT 0
105320: ST_TO_ADDR
// end ;
105321: LD_VAR 0 3
105325: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
105326: LD_INT 0
105328: PPUSH
105329: PPUSH
105330: PPUSH
105331: PPUSH
// if not unit or not area then
105332: LD_VAR 0 1
105336: NOT
105337: PUSH
105338: LD_VAR 0 2
105342: NOT
105343: OR
105344: IFFALSE 105348
// exit ;
105346: GO 105512
// tmp := AreaToList ( area , i ) ;
105348: LD_ADDR_VAR 0 6
105352: PUSH
105353: LD_VAR 0 2
105357: PPUSH
105358: LD_VAR 0 5
105362: PPUSH
105363: CALL_OW 517
105367: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
105368: LD_ADDR_VAR 0 5
105372: PUSH
105373: DOUBLE
105374: LD_INT 1
105376: DEC
105377: ST_TO_ADDR
105378: LD_VAR 0 6
105382: PUSH
105383: LD_INT 1
105385: ARRAY
105386: PUSH
105387: FOR_TO
105388: IFFALSE 105510
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
105390: LD_ADDR_VAR 0 7
105394: PUSH
105395: LD_VAR 0 6
105399: PUSH
105400: LD_INT 1
105402: ARRAY
105403: PUSH
105404: LD_VAR 0 5
105408: ARRAY
105409: PUSH
105410: LD_VAR 0 6
105414: PUSH
105415: LD_INT 2
105417: ARRAY
105418: PUSH
105419: LD_VAR 0 5
105423: ARRAY
105424: PUSH
105425: EMPTY
105426: LIST
105427: LIST
105428: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
105429: LD_VAR 0 7
105433: PUSH
105434: LD_INT 1
105436: ARRAY
105437: PPUSH
105438: LD_VAR 0 7
105442: PUSH
105443: LD_INT 2
105445: ARRAY
105446: PPUSH
105447: CALL_OW 428
105451: PUSH
105452: LD_INT 0
105454: EQUAL
105455: IFFALSE 105508
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
105457: LD_VAR 0 1
105461: PPUSH
105462: LD_VAR 0 7
105466: PUSH
105467: LD_INT 1
105469: ARRAY
105470: PPUSH
105471: LD_VAR 0 7
105475: PUSH
105476: LD_INT 2
105478: ARRAY
105479: PPUSH
105480: LD_VAR 0 3
105484: PPUSH
105485: CALL_OW 48
// result := IsPlaced ( unit ) ;
105489: LD_ADDR_VAR 0 4
105493: PUSH
105494: LD_VAR 0 1
105498: PPUSH
105499: CALL_OW 305
105503: ST_TO_ADDR
// exit ;
105504: POP
105505: POP
105506: GO 105512
// end ; end ;
105508: GO 105387
105510: POP
105511: POP
// end ;
105512: LD_VAR 0 4
105516: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
105517: LD_INT 0
105519: PPUSH
105520: PPUSH
105521: PPUSH
// if not side or side > 8 then
105522: LD_VAR 0 1
105526: NOT
105527: PUSH
105528: LD_VAR 0 1
105532: PUSH
105533: LD_INT 8
105535: GREATER
105536: OR
105537: IFFALSE 105541
// exit ;
105539: GO 105728
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
105541: LD_ADDR_VAR 0 4
105545: PUSH
105546: LD_INT 22
105548: PUSH
105549: LD_VAR 0 1
105553: PUSH
105554: EMPTY
105555: LIST
105556: LIST
105557: PUSH
105558: LD_INT 21
105560: PUSH
105561: LD_INT 3
105563: PUSH
105564: EMPTY
105565: LIST
105566: LIST
105567: PUSH
105568: EMPTY
105569: LIST
105570: LIST
105571: PPUSH
105572: CALL_OW 69
105576: ST_TO_ADDR
// if not tmp then
105577: LD_VAR 0 4
105581: NOT
105582: IFFALSE 105586
// exit ;
105584: GO 105728
// enable_addtolog := true ;
105586: LD_ADDR_OWVAR 81
105590: PUSH
105591: LD_INT 1
105593: ST_TO_ADDR
// AddToLog ( [ ) ;
105594: LD_STRING [
105596: PPUSH
105597: CALL_OW 561
// for i in tmp do
105601: LD_ADDR_VAR 0 3
105605: PUSH
105606: LD_VAR 0 4
105610: PUSH
105611: FOR_IN
105612: IFFALSE 105719
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
105614: LD_STRING [
105616: PUSH
105617: LD_VAR 0 3
105621: PPUSH
105622: CALL_OW 266
105626: STR
105627: PUSH
105628: LD_STRING , 
105630: STR
105631: PUSH
105632: LD_VAR 0 3
105636: PPUSH
105637: CALL_OW 250
105641: STR
105642: PUSH
105643: LD_STRING , 
105645: STR
105646: PUSH
105647: LD_VAR 0 3
105651: PPUSH
105652: CALL_OW 251
105656: STR
105657: PUSH
105658: LD_STRING , 
105660: STR
105661: PUSH
105662: LD_VAR 0 3
105666: PPUSH
105667: CALL_OW 254
105671: STR
105672: PUSH
105673: LD_STRING , 
105675: STR
105676: PUSH
105677: LD_VAR 0 3
105681: PPUSH
105682: LD_INT 1
105684: PPUSH
105685: CALL_OW 268
105689: STR
105690: PUSH
105691: LD_STRING , 
105693: STR
105694: PUSH
105695: LD_VAR 0 3
105699: PPUSH
105700: LD_INT 2
105702: PPUSH
105703: CALL_OW 268
105707: STR
105708: PUSH
105709: LD_STRING ],
105711: STR
105712: PPUSH
105713: CALL_OW 561
// end ;
105717: GO 105611
105719: POP
105720: POP
// AddToLog ( ]; ) ;
105721: LD_STRING ];
105723: PPUSH
105724: CALL_OW 561
// end ;
105728: LD_VAR 0 2
105732: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
105733: LD_INT 0
105735: PPUSH
105736: PPUSH
105737: PPUSH
105738: PPUSH
105739: PPUSH
// if not area or not rate or not max then
105740: LD_VAR 0 1
105744: NOT
105745: PUSH
105746: LD_VAR 0 2
105750: NOT
105751: OR
105752: PUSH
105753: LD_VAR 0 4
105757: NOT
105758: OR
105759: IFFALSE 105763
// exit ;
105761: GO 105955
// while 1 do
105763: LD_INT 1
105765: IFFALSE 105955
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
105767: LD_ADDR_VAR 0 9
105771: PUSH
105772: LD_VAR 0 1
105776: PPUSH
105777: LD_INT 1
105779: PPUSH
105780: CALL_OW 287
105784: PUSH
105785: LD_INT 10
105787: MUL
105788: ST_TO_ADDR
// r := rate / 10 ;
105789: LD_ADDR_VAR 0 7
105793: PUSH
105794: LD_VAR 0 2
105798: PUSH
105799: LD_INT 10
105801: DIVREAL
105802: ST_TO_ADDR
// time := 1 1$00 ;
105803: LD_ADDR_VAR 0 8
105807: PUSH
105808: LD_INT 2100
105810: ST_TO_ADDR
// if amount < min then
105811: LD_VAR 0 9
105815: PUSH
105816: LD_VAR 0 3
105820: LESS
105821: IFFALSE 105839
// r := r * 2 else
105823: LD_ADDR_VAR 0 7
105827: PUSH
105828: LD_VAR 0 7
105832: PUSH
105833: LD_INT 2
105835: MUL
105836: ST_TO_ADDR
105837: GO 105865
// if amount > max then
105839: LD_VAR 0 9
105843: PUSH
105844: LD_VAR 0 4
105848: GREATER
105849: IFFALSE 105865
// r := r / 2 ;
105851: LD_ADDR_VAR 0 7
105855: PUSH
105856: LD_VAR 0 7
105860: PUSH
105861: LD_INT 2
105863: DIVREAL
105864: ST_TO_ADDR
// time := time / r ;
105865: LD_ADDR_VAR 0 8
105869: PUSH
105870: LD_VAR 0 8
105874: PUSH
105875: LD_VAR 0 7
105879: DIVREAL
105880: ST_TO_ADDR
// if time < 0 then
105881: LD_VAR 0 8
105885: PUSH
105886: LD_INT 0
105888: LESS
105889: IFFALSE 105906
// time := time * - 1 ;
105891: LD_ADDR_VAR 0 8
105895: PUSH
105896: LD_VAR 0 8
105900: PUSH
105901: LD_INT 1
105903: NEG
105904: MUL
105905: ST_TO_ADDR
// wait ( time ) ;
105906: LD_VAR 0 8
105910: PPUSH
105911: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
105915: LD_INT 35
105917: PPUSH
105918: LD_INT 875
105920: PPUSH
105921: CALL_OW 12
105925: PPUSH
105926: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
105930: LD_INT 1
105932: PPUSH
105933: LD_INT 5
105935: PPUSH
105936: CALL_OW 12
105940: PPUSH
105941: LD_VAR 0 1
105945: PPUSH
105946: LD_INT 1
105948: PPUSH
105949: CALL_OW 55
// end ;
105953: GO 105763
// end ;
105955: LD_VAR 0 5
105959: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
105960: LD_INT 0
105962: PPUSH
105963: PPUSH
105964: PPUSH
105965: PPUSH
105966: PPUSH
105967: PPUSH
105968: PPUSH
105969: PPUSH
// if not turrets or not factories then
105970: LD_VAR 0 1
105974: NOT
105975: PUSH
105976: LD_VAR 0 2
105980: NOT
105981: OR
105982: IFFALSE 105986
// exit ;
105984: GO 106293
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
105986: LD_ADDR_VAR 0 10
105990: PUSH
105991: LD_INT 5
105993: PUSH
105994: LD_INT 6
105996: PUSH
105997: EMPTY
105998: LIST
105999: LIST
106000: PUSH
106001: LD_INT 2
106003: PUSH
106004: LD_INT 4
106006: PUSH
106007: EMPTY
106008: LIST
106009: LIST
106010: PUSH
106011: LD_INT 3
106013: PUSH
106014: LD_INT 5
106016: PUSH
106017: EMPTY
106018: LIST
106019: LIST
106020: PUSH
106021: EMPTY
106022: LIST
106023: LIST
106024: LIST
106025: PUSH
106026: LD_INT 24
106028: PUSH
106029: LD_INT 25
106031: PUSH
106032: EMPTY
106033: LIST
106034: LIST
106035: PUSH
106036: LD_INT 23
106038: PUSH
106039: LD_INT 27
106041: PUSH
106042: EMPTY
106043: LIST
106044: LIST
106045: PUSH
106046: EMPTY
106047: LIST
106048: LIST
106049: PUSH
106050: LD_INT 42
106052: PUSH
106053: LD_INT 43
106055: PUSH
106056: EMPTY
106057: LIST
106058: LIST
106059: PUSH
106060: LD_INT 44
106062: PUSH
106063: LD_INT 46
106065: PUSH
106066: EMPTY
106067: LIST
106068: LIST
106069: PUSH
106070: LD_INT 45
106072: PUSH
106073: LD_INT 47
106075: PUSH
106076: EMPTY
106077: LIST
106078: LIST
106079: PUSH
106080: EMPTY
106081: LIST
106082: LIST
106083: LIST
106084: PUSH
106085: EMPTY
106086: LIST
106087: LIST
106088: LIST
106089: ST_TO_ADDR
// result := [ ] ;
106090: LD_ADDR_VAR 0 3
106094: PUSH
106095: EMPTY
106096: ST_TO_ADDR
// for i in turrets do
106097: LD_ADDR_VAR 0 4
106101: PUSH
106102: LD_VAR 0 1
106106: PUSH
106107: FOR_IN
106108: IFFALSE 106291
// begin nat := GetNation ( i ) ;
106110: LD_ADDR_VAR 0 7
106114: PUSH
106115: LD_VAR 0 4
106119: PPUSH
106120: CALL_OW 248
106124: ST_TO_ADDR
// weapon := 0 ;
106125: LD_ADDR_VAR 0 8
106129: PUSH
106130: LD_INT 0
106132: ST_TO_ADDR
// if not nat then
106133: LD_VAR 0 7
106137: NOT
106138: IFFALSE 106142
// continue ;
106140: GO 106107
// for j in list [ nat ] do
106142: LD_ADDR_VAR 0 5
106146: PUSH
106147: LD_VAR 0 10
106151: PUSH
106152: LD_VAR 0 7
106156: ARRAY
106157: PUSH
106158: FOR_IN
106159: IFFALSE 106200
// if GetBWeapon ( i ) = j [ 1 ] then
106161: LD_VAR 0 4
106165: PPUSH
106166: CALL_OW 269
106170: PUSH
106171: LD_VAR 0 5
106175: PUSH
106176: LD_INT 1
106178: ARRAY
106179: EQUAL
106180: IFFALSE 106198
// begin weapon := j [ 2 ] ;
106182: LD_ADDR_VAR 0 8
106186: PUSH
106187: LD_VAR 0 5
106191: PUSH
106192: LD_INT 2
106194: ARRAY
106195: ST_TO_ADDR
// break ;
106196: GO 106200
// end ;
106198: GO 106158
106200: POP
106201: POP
// if not weapon then
106202: LD_VAR 0 8
106206: NOT
106207: IFFALSE 106211
// continue ;
106209: GO 106107
// for k in factories do
106211: LD_ADDR_VAR 0 6
106215: PUSH
106216: LD_VAR 0 2
106220: PUSH
106221: FOR_IN
106222: IFFALSE 106287
// begin weapons := AvailableWeaponList ( k ) ;
106224: LD_ADDR_VAR 0 9
106228: PUSH
106229: LD_VAR 0 6
106233: PPUSH
106234: CALL_OW 478
106238: ST_TO_ADDR
// if not weapons then
106239: LD_VAR 0 9
106243: NOT
106244: IFFALSE 106248
// continue ;
106246: GO 106221
// if weapon in weapons then
106248: LD_VAR 0 8
106252: PUSH
106253: LD_VAR 0 9
106257: IN
106258: IFFALSE 106285
// begin result := [ i , weapon ] ;
106260: LD_ADDR_VAR 0 3
106264: PUSH
106265: LD_VAR 0 4
106269: PUSH
106270: LD_VAR 0 8
106274: PUSH
106275: EMPTY
106276: LIST
106277: LIST
106278: ST_TO_ADDR
// exit ;
106279: POP
106280: POP
106281: POP
106282: POP
106283: GO 106293
// end ; end ;
106285: GO 106221
106287: POP
106288: POP
// end ;
106289: GO 106107
106291: POP
106292: POP
// end ;
106293: LD_VAR 0 3
106297: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
106298: LD_INT 0
106300: PPUSH
// if not side or side > 8 then
106301: LD_VAR 0 3
106305: NOT
106306: PUSH
106307: LD_VAR 0 3
106311: PUSH
106312: LD_INT 8
106314: GREATER
106315: OR
106316: IFFALSE 106320
// exit ;
106318: GO 106379
// if not range then
106320: LD_VAR 0 4
106324: NOT
106325: IFFALSE 106336
// range := - 12 ;
106327: LD_ADDR_VAR 0 4
106331: PUSH
106332: LD_INT 12
106334: NEG
106335: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
106336: LD_VAR 0 1
106340: PPUSH
106341: LD_VAR 0 2
106345: PPUSH
106346: LD_VAR 0 3
106350: PPUSH
106351: LD_VAR 0 4
106355: PPUSH
106356: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
106360: LD_VAR 0 1
106364: PPUSH
106365: LD_VAR 0 2
106369: PPUSH
106370: LD_VAR 0 3
106374: PPUSH
106375: CALL_OW 331
// end ;
106379: LD_VAR 0 5
106383: RET
// export function Video ( mode ) ; begin
106384: LD_INT 0
106386: PPUSH
// ingame_video = mode ;
106387: LD_ADDR_OWVAR 52
106391: PUSH
106392: LD_VAR 0 1
106396: ST_TO_ADDR
// interface_hidden = mode ;
106397: LD_ADDR_OWVAR 54
106401: PUSH
106402: LD_VAR 0 1
106406: ST_TO_ADDR
// end ;
106407: LD_VAR 0 2
106411: RET
// export function Join ( array , element ) ; begin
106412: LD_INT 0
106414: PPUSH
// result := array ^ element ;
106415: LD_ADDR_VAR 0 3
106419: PUSH
106420: LD_VAR 0 1
106424: PUSH
106425: LD_VAR 0 2
106429: ADD
106430: ST_TO_ADDR
// end ;
106431: LD_VAR 0 3
106435: RET
// export function JoinUnion ( array , element ) ; begin
106436: LD_INT 0
106438: PPUSH
// result := array union element ;
106439: LD_ADDR_VAR 0 3
106443: PUSH
106444: LD_VAR 0 1
106448: PUSH
106449: LD_VAR 0 2
106453: UNION
106454: ST_TO_ADDR
// end ;
106455: LD_VAR 0 3
106459: RET
// export function GetBehemoths ( side ) ; begin
106460: LD_INT 0
106462: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
106463: LD_ADDR_VAR 0 2
106467: PUSH
106468: LD_INT 22
106470: PUSH
106471: LD_VAR 0 1
106475: PUSH
106476: EMPTY
106477: LIST
106478: LIST
106479: PUSH
106480: LD_INT 31
106482: PUSH
106483: LD_INT 25
106485: PUSH
106486: EMPTY
106487: LIST
106488: LIST
106489: PUSH
106490: EMPTY
106491: LIST
106492: LIST
106493: PPUSH
106494: CALL_OW 69
106498: ST_TO_ADDR
// end ;
106499: LD_VAR 0 2
106503: RET
// export function Shuffle ( array ) ; var i , index ; begin
106504: LD_INT 0
106506: PPUSH
106507: PPUSH
106508: PPUSH
// result := [ ] ;
106509: LD_ADDR_VAR 0 2
106513: PUSH
106514: EMPTY
106515: ST_TO_ADDR
// if not array then
106516: LD_VAR 0 1
106520: NOT
106521: IFFALSE 106525
// exit ;
106523: GO 106624
// Randomize ;
106525: CALL_OW 10
// for i = array downto 1 do
106529: LD_ADDR_VAR 0 3
106533: PUSH
106534: DOUBLE
106535: LD_VAR 0 1
106539: INC
106540: ST_TO_ADDR
106541: LD_INT 1
106543: PUSH
106544: FOR_DOWNTO
106545: IFFALSE 106622
// begin index := rand ( 1 , array ) ;
106547: LD_ADDR_VAR 0 4
106551: PUSH
106552: LD_INT 1
106554: PPUSH
106555: LD_VAR 0 1
106559: PPUSH
106560: CALL_OW 12
106564: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
106565: LD_ADDR_VAR 0 2
106569: PUSH
106570: LD_VAR 0 2
106574: PPUSH
106575: LD_VAR 0 2
106579: PUSH
106580: LD_INT 1
106582: PLUS
106583: PPUSH
106584: LD_VAR 0 1
106588: PUSH
106589: LD_VAR 0 4
106593: ARRAY
106594: PPUSH
106595: CALL_OW 2
106599: ST_TO_ADDR
// array := Delete ( array , index ) ;
106600: LD_ADDR_VAR 0 1
106604: PUSH
106605: LD_VAR 0 1
106609: PPUSH
106610: LD_VAR 0 4
106614: PPUSH
106615: CALL_OW 3
106619: ST_TO_ADDR
// end ;
106620: GO 106544
106622: POP
106623: POP
// end ;
106624: LD_VAR 0 2
106628: RET
// export function GetBaseMaterials ( base ) ; begin
106629: LD_INT 0
106631: PPUSH
// result := [ 0 , 0 , 0 ] ;
106632: LD_ADDR_VAR 0 2
106636: PUSH
106637: LD_INT 0
106639: PUSH
106640: LD_INT 0
106642: PUSH
106643: LD_INT 0
106645: PUSH
106646: EMPTY
106647: LIST
106648: LIST
106649: LIST
106650: ST_TO_ADDR
// if not base then
106651: LD_VAR 0 1
106655: NOT
106656: IFFALSE 106660
// exit ;
106658: GO 106709
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
106660: LD_ADDR_VAR 0 2
106664: PUSH
106665: LD_VAR 0 1
106669: PPUSH
106670: LD_INT 1
106672: PPUSH
106673: CALL_OW 275
106677: PUSH
106678: LD_VAR 0 1
106682: PPUSH
106683: LD_INT 2
106685: PPUSH
106686: CALL_OW 275
106690: PUSH
106691: LD_VAR 0 1
106695: PPUSH
106696: LD_INT 3
106698: PPUSH
106699: CALL_OW 275
106703: PUSH
106704: EMPTY
106705: LIST
106706: LIST
106707: LIST
106708: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
106709: LD_VAR 0 2
106713: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
106714: LD_INT 0
106716: PPUSH
106717: PPUSH
106718: PPUSH
106719: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106720: LD_VAR 0 1
106724: PPUSH
106725: CALL_OW 264
106729: PUSH
106730: LD_EXP 96
106734: EQUAL
106735: IFFALSE 106807
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106737: LD_INT 68
106739: PPUSH
106740: LD_VAR 0 1
106744: PPUSH
106745: CALL_OW 255
106749: PPUSH
106750: CALL_OW 321
106754: PUSH
106755: LD_INT 2
106757: EQUAL
106758: IFFALSE 106770
// eff := 70 else
106760: LD_ADDR_VAR 0 6
106764: PUSH
106765: LD_INT 70
106767: ST_TO_ADDR
106768: GO 106778
// eff := 30 ;
106770: LD_ADDR_VAR 0 6
106774: PUSH
106775: LD_INT 30
106777: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
106778: LD_VAR 0 1
106782: PPUSH
106783: CALL_OW 250
106787: PPUSH
106788: LD_VAR 0 1
106792: PPUSH
106793: CALL_OW 251
106797: PPUSH
106798: LD_VAR 0 6
106802: PPUSH
106803: CALL_OW 495
// end ; end ;
106807: LD_VAR 0 4
106811: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
106812: LD_INT 0
106814: PPUSH
106815: PPUSH
106816: PPUSH
106817: PPUSH
106818: PPUSH
106819: PPUSH
// if cmd = 124 then
106820: LD_VAR 0 1
106824: PUSH
106825: LD_INT 124
106827: EQUAL
106828: IFFALSE 107034
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
106830: LD_ADDR_VAR 0 5
106834: PUSH
106835: LD_INT 2
106837: PUSH
106838: LD_INT 34
106840: PUSH
106841: LD_INT 53
106843: PUSH
106844: EMPTY
106845: LIST
106846: LIST
106847: PUSH
106848: LD_INT 34
106850: PUSH
106851: LD_INT 14
106853: PUSH
106854: EMPTY
106855: LIST
106856: LIST
106857: PUSH
106858: EMPTY
106859: LIST
106860: LIST
106861: LIST
106862: PPUSH
106863: CALL_OW 69
106867: ST_TO_ADDR
// if not tmp then
106868: LD_VAR 0 5
106872: NOT
106873: IFFALSE 106877
// exit ;
106875: GO 107034
// for i in tmp do
106877: LD_ADDR_VAR 0 3
106881: PUSH
106882: LD_VAR 0 5
106886: PUSH
106887: FOR_IN
106888: IFFALSE 107032
// begin taskList := GetTaskList ( i ) ;
106890: LD_ADDR_VAR 0 6
106894: PUSH
106895: LD_VAR 0 3
106899: PPUSH
106900: CALL_OW 437
106904: ST_TO_ADDR
// if not taskList then
106905: LD_VAR 0 6
106909: NOT
106910: IFFALSE 106914
// continue ;
106912: GO 106887
// for j = 1 to taskList do
106914: LD_ADDR_VAR 0 4
106918: PUSH
106919: DOUBLE
106920: LD_INT 1
106922: DEC
106923: ST_TO_ADDR
106924: LD_VAR 0 6
106928: PUSH
106929: FOR_TO
106930: IFFALSE 107028
// if taskList [ j ] [ 1 ] = | then
106932: LD_VAR 0 6
106936: PUSH
106937: LD_VAR 0 4
106941: ARRAY
106942: PUSH
106943: LD_INT 1
106945: ARRAY
106946: PUSH
106947: LD_STRING |
106949: EQUAL
106950: IFFALSE 107026
// begin _taskList := Delete ( taskList , 1 ) ;
106952: LD_ADDR_VAR 0 7
106956: PUSH
106957: LD_VAR 0 6
106961: PPUSH
106962: LD_INT 1
106964: PPUSH
106965: CALL_OW 3
106969: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
106970: LD_VAR 0 3
106974: PPUSH
106975: LD_VAR 0 7
106979: PPUSH
106980: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
106984: LD_VAR 0 3
106988: PPUSH
106989: LD_VAR 0 6
106993: PUSH
106994: LD_VAR 0 4
106998: ARRAY
106999: PUSH
107000: LD_INT 2
107002: ARRAY
107003: PPUSH
107004: LD_VAR 0 6
107008: PUSH
107009: LD_VAR 0 4
107013: ARRAY
107014: PUSH
107015: LD_INT 3
107017: ARRAY
107018: PPUSH
107019: LD_INT 8
107021: PPUSH
107022: CALL 107039 0 4
// end ;
107026: GO 106929
107028: POP
107029: POP
// end ;
107030: GO 106887
107032: POP
107033: POP
// end ; end ;
107034: LD_VAR 0 2
107038: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107039: LD_INT 0
107041: PPUSH
107042: PPUSH
107043: PPUSH
107044: PPUSH
107045: PPUSH
107046: PPUSH
107047: PPUSH
107048: PPUSH
107049: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107050: LD_VAR 0 1
107054: NOT
107055: PUSH
107056: LD_VAR 0 2
107060: PPUSH
107061: LD_VAR 0 3
107065: PPUSH
107066: CALL_OW 488
107070: NOT
107071: OR
107072: PUSH
107073: LD_VAR 0 4
107077: NOT
107078: OR
107079: IFFALSE 107083
// exit ;
107081: GO 107423
// list := [ ] ;
107083: LD_ADDR_VAR 0 13
107087: PUSH
107088: EMPTY
107089: ST_TO_ADDR
// if x - r < 0 then
107090: LD_VAR 0 2
107094: PUSH
107095: LD_VAR 0 4
107099: MINUS
107100: PUSH
107101: LD_INT 0
107103: LESS
107104: IFFALSE 107116
// min_x := 0 else
107106: LD_ADDR_VAR 0 7
107110: PUSH
107111: LD_INT 0
107113: ST_TO_ADDR
107114: GO 107132
// min_x := x - r ;
107116: LD_ADDR_VAR 0 7
107120: PUSH
107121: LD_VAR 0 2
107125: PUSH
107126: LD_VAR 0 4
107130: MINUS
107131: ST_TO_ADDR
// if y - r < 0 then
107132: LD_VAR 0 3
107136: PUSH
107137: LD_VAR 0 4
107141: MINUS
107142: PUSH
107143: LD_INT 0
107145: LESS
107146: IFFALSE 107158
// min_y := 0 else
107148: LD_ADDR_VAR 0 8
107152: PUSH
107153: LD_INT 0
107155: ST_TO_ADDR
107156: GO 107174
// min_y := y - r ;
107158: LD_ADDR_VAR 0 8
107162: PUSH
107163: LD_VAR 0 3
107167: PUSH
107168: LD_VAR 0 4
107172: MINUS
107173: ST_TO_ADDR
// max_x := x + r ;
107174: LD_ADDR_VAR 0 9
107178: PUSH
107179: LD_VAR 0 2
107183: PUSH
107184: LD_VAR 0 4
107188: PLUS
107189: ST_TO_ADDR
// max_y := y + r ;
107190: LD_ADDR_VAR 0 10
107194: PUSH
107195: LD_VAR 0 3
107199: PUSH
107200: LD_VAR 0 4
107204: PLUS
107205: ST_TO_ADDR
// for _x = min_x to max_x do
107206: LD_ADDR_VAR 0 11
107210: PUSH
107211: DOUBLE
107212: LD_VAR 0 7
107216: DEC
107217: ST_TO_ADDR
107218: LD_VAR 0 9
107222: PUSH
107223: FOR_TO
107224: IFFALSE 107341
// for _y = min_y to max_y do
107226: LD_ADDR_VAR 0 12
107230: PUSH
107231: DOUBLE
107232: LD_VAR 0 8
107236: DEC
107237: ST_TO_ADDR
107238: LD_VAR 0 10
107242: PUSH
107243: FOR_TO
107244: IFFALSE 107337
// begin if not ValidHex ( _x , _y ) then
107246: LD_VAR 0 11
107250: PPUSH
107251: LD_VAR 0 12
107255: PPUSH
107256: CALL_OW 488
107260: NOT
107261: IFFALSE 107265
// continue ;
107263: GO 107243
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107265: LD_VAR 0 11
107269: PPUSH
107270: LD_VAR 0 12
107274: PPUSH
107275: CALL_OW 351
107279: PUSH
107280: LD_VAR 0 11
107284: PPUSH
107285: LD_VAR 0 12
107289: PPUSH
107290: CALL_OW 554
107294: AND
107295: IFFALSE 107335
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107297: LD_ADDR_VAR 0 13
107301: PUSH
107302: LD_VAR 0 13
107306: PPUSH
107307: LD_VAR 0 13
107311: PUSH
107312: LD_INT 1
107314: PLUS
107315: PPUSH
107316: LD_VAR 0 11
107320: PUSH
107321: LD_VAR 0 12
107325: PUSH
107326: EMPTY
107327: LIST
107328: LIST
107329: PPUSH
107330: CALL_OW 2
107334: ST_TO_ADDR
// end ;
107335: GO 107243
107337: POP
107338: POP
107339: GO 107223
107341: POP
107342: POP
// if not list then
107343: LD_VAR 0 13
107347: NOT
107348: IFFALSE 107352
// exit ;
107350: GO 107423
// for i in list do
107352: LD_ADDR_VAR 0 6
107356: PUSH
107357: LD_VAR 0 13
107361: PUSH
107362: FOR_IN
107363: IFFALSE 107421
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107365: LD_VAR 0 1
107369: PPUSH
107370: LD_STRING M
107372: PUSH
107373: LD_VAR 0 6
107377: PUSH
107378: LD_INT 1
107380: ARRAY
107381: PUSH
107382: LD_VAR 0 6
107386: PUSH
107387: LD_INT 2
107389: ARRAY
107390: PUSH
107391: LD_INT 0
107393: PUSH
107394: LD_INT 0
107396: PUSH
107397: LD_INT 0
107399: PUSH
107400: LD_INT 0
107402: PUSH
107403: EMPTY
107404: LIST
107405: LIST
107406: LIST
107407: LIST
107408: LIST
107409: LIST
107410: LIST
107411: PUSH
107412: EMPTY
107413: LIST
107414: PPUSH
107415: CALL_OW 447
107419: GO 107362
107421: POP
107422: POP
// end ;
107423: LD_VAR 0 5
107427: RET
