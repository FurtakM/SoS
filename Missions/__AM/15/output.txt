// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 38204 0 0
// InitNature ;
  19: CALL 38072 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 12274 0 0
// PrepareRussian ;
  40: CALL 7237 0 0
// PrepareLegion ;
  44: CALL 4392 0 0
// PreparePowell ;
  48: CALL 3056 0 0
// PrepareAmerican ;
  52: CALL 1816 0 0
// Action ;
  56: CALL 16994 0 0
// MC_Start ( ) ;
  60: CALL 40384 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits , amConstructCounter ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// amConstructCounter := 0 ;
 462: LD_ADDR_EXP 39
 466: PUSH
 467: LD_INT 0
 469: ST_TO_ADDR
// end ;
 470: LD_VAR 0 1
 474: RET
// export function CustomInitMacro ( ) ; begin
 475: LD_INT 0
 477: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 478: LD_ADDR_EXP 124
 482: PUSH
 483: LD_INT 2
 485: PUSH
 486: LD_INT 3
 488: PUSH
 489: LD_INT 6
 491: PUSH
 492: LD_INT 10
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 501: LD_ADDR_EXP 125
 505: PUSH
 506: LD_INT 1
 508: PUSH
 509: LD_INT 4
 511: PUSH
 512: LD_INT 5
 514: PUSH
 515: LD_INT 9
 517: PUSH
 518: EMPTY
 519: LIST
 520: LIST
 521: LIST
 522: LIST
 523: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto ] ) ;
 524: LD_INT 1
 526: PPUSH
 527: LD_INT 10
 529: PUSH
 530: LD_INT 11
 532: PUSH
 533: LD_INT 12
 535: PUSH
 536: LD_INT 15
 538: PUSH
 539: EMPTY
 540: LIST
 541: LIST
 542: LIST
 543: LIST
 544: PPUSH
 545: CALL 63166 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 549: LD_INT 1
 551: PPUSH
 552: LD_INT 17
 554: PUSH
 555: EMPTY
 556: LIST
 557: PPUSH
 558: CALL 63259 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 562: LD_INT 1
 564: PPUSH
 565: LD_INT 5
 567: PPUSH
 568: CALL 62609 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 572: LD_INT 1
 574: PPUSH
 575: LD_INT 24
 577: PUSH
 578: LD_INT 3
 580: PUSH
 581: LD_INT 3
 583: PUSH
 584: LD_INT 47
 586: PUSH
 587: EMPTY
 588: LIST
 589: LIST
 590: LIST
 591: LIST
 592: PUSH
 593: LD_INT 24
 595: PUSH
 596: LD_INT 3
 598: PUSH
 599: LD_INT 3
 601: PUSH
 602: LD_INT 47
 604: PUSH
 605: EMPTY
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: PUSH
 611: LD_INT 24
 613: PUSH
 614: LD_INT 3
 616: PUSH
 617: LD_INT 3
 619: PUSH
 620: LD_INT 47
 622: PUSH
 623: EMPTY
 624: LIST
 625: LIST
 626: LIST
 627: LIST
 628: PUSH
 629: LD_INT 24
 631: PUSH
 632: LD_INT 3
 634: PUSH
 635: LD_INT 3
 637: PUSH
 638: LD_INT 47
 640: PUSH
 641: EMPTY
 642: LIST
 643: LIST
 644: LIST
 645: LIST
 646: PUSH
 647: LD_INT 24
 649: PUSH
 650: LD_INT 3
 652: PUSH
 653: LD_INT 3
 655: PUSH
 656: LD_INT 47
 658: PUSH
 659: EMPTY
 660: LIST
 661: LIST
 662: LIST
 663: LIST
 664: PUSH
 665: EMPTY
 666: LIST
 667: LIST
 668: LIST
 669: LIST
 670: LIST
 671: PPUSH
 672: CALL 62424 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 676: LD_INT 2
 678: PPUSH
 679: LD_INT 10
 681: PUSH
 682: LD_INT 11
 684: PUSH
 685: LD_INT 12
 687: PUSH
 688: LD_INT 14
 690: PUSH
 691: EMPTY
 692: LIST
 693: LIST
 694: LIST
 695: LIST
 696: PPUSH
 697: CALL 63166 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 701: LD_INT 2
 703: PPUSH
 704: LD_INT 16
 706: PUSH
 707: EMPTY
 708: LIST
 709: PPUSH
 710: CALL 63259 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 714: LD_INT 2
 716: PPUSH
 717: LD_INT 21
 719: PUSH
 720: LD_INT 3
 722: PUSH
 723: LD_INT 3
 725: PUSH
 726: LD_INT 51
 728: PUSH
 729: EMPTY
 730: LIST
 731: LIST
 732: LIST
 733: LIST
 734: PUSH
 735: LD_INT 22
 737: PUSH
 738: LD_INT 3
 740: PUSH
 741: LD_INT 3
 743: PUSH
 744: LD_INT 52
 746: PUSH
 747: EMPTY
 748: LIST
 749: LIST
 750: LIST
 751: LIST
 752: PUSH
 753: LD_INT 22
 755: PUSH
 756: LD_INT 3
 758: PUSH
 759: LD_INT 3
 761: PUSH
 762: LD_INT 52
 764: PUSH
 765: EMPTY
 766: LIST
 767: LIST
 768: LIST
 769: LIST
 770: PUSH
 771: LD_INT 24
 773: PUSH
 774: LD_INT 3
 776: PUSH
 777: LD_INT 3
 779: PUSH
 780: LD_INT 47
 782: PUSH
 783: EMPTY
 784: LIST
 785: LIST
 786: LIST
 787: LIST
 788: PUSH
 789: LD_INT 24
 791: PUSH
 792: LD_INT 3
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 47
 800: PUSH
 801: EMPTY
 802: LIST
 803: LIST
 804: LIST
 805: LIST
 806: PUSH
 807: LD_INT 24
 809: PUSH
 810: LD_INT 3
 812: PUSH
 813: LD_INT 3
 815: PUSH
 816: LD_INT 47
 818: PUSH
 819: EMPTY
 820: LIST
 821: LIST
 822: LIST
 823: LIST
 824: PUSH
 825: LD_INT 24
 827: PUSH
 828: LD_INT 3
 830: PUSH
 831: LD_INT 3
 833: PUSH
 834: LD_INT 47
 836: PUSH
 837: EMPTY
 838: LIST
 839: LIST
 840: LIST
 841: LIST
 842: PUSH
 843: LD_INT 24
 845: PUSH
 846: LD_INT 3
 848: PUSH
 849: LD_INT 3
 851: PUSH
 852: LD_INT 47
 854: PUSH
 855: EMPTY
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: PUSH
 861: EMPTY
 862: LIST
 863: LIST
 864: LIST
 865: LIST
 866: LIST
 867: LIST
 868: LIST
 869: LIST
 870: PPUSH
 871: CALL 62424 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 875: LD_INT 2
 877: PPUSH
 878: LD_INT 5
 880: PPUSH
 881: CALL 62609 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 885: LD_INT 2
 887: PPUSH
 888: LD_INT 0
 890: PPUSH
 891: CALL 63039 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 895: LD_INT 3
 897: PPUSH
 898: LD_INT 10
 900: PUSH
 901: LD_INT 12
 903: PUSH
 904: LD_INT 14
 906: PUSH
 907: LD_INT 15
 909: PUSH
 910: EMPTY
 911: LIST
 912: LIST
 913: LIST
 914: LIST
 915: PUSH
 916: LD_OWVAR 67
 920: ARRAY
 921: PPUSH
 922: LD_INT 27
 924: PPUSH
 925: CALL 62087 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 929: LD_INT 3
 931: PPUSH
 932: LD_INT 10
 934: PUSH
 935: LD_INT 11
 937: PUSH
 938: LD_INT 13
 940: PUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: LIST
 947: LIST
 948: LIST
 949: PPUSH
 950: CALL 63166 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 954: LD_INT 3
 956: PPUSH
 957: LD_INT 15
 959: PUSH
 960: EMPTY
 961: LIST
 962: PPUSH
 963: CALL 63259 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 967: LD_ADDR_EXP 129
 971: PUSH
 972: LD_EXP 129
 976: PPUSH
 977: LD_INT 3
 979: PPUSH
 980: LD_INT 22
 982: PUSH
 983: LD_INT 8
 985: PUSH
 986: EMPTY
 987: LIST
 988: LIST
 989: PUSH
 990: LD_INT 25
 992: PUSH
 993: LD_INT 15
 995: PUSH
 996: EMPTY
 997: LIST
 998: LIST
 999: PUSH
1000: EMPTY
1001: LIST
1002: LIST
1003: PPUSH
1004: CALL_OW 69
1008: PPUSH
1009: CALL_OW 1
1013: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1014: LD_INT 3
1016: PPUSH
1017: LD_INT 13
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 1
1025: PUSH
1026: LD_INT 31
1028: PUSH
1029: EMPTY
1030: LIST
1031: LIST
1032: LIST
1033: LIST
1034: PUSH
1035: LD_INT 13
1037: PUSH
1038: LD_INT 2
1040: PUSH
1041: LD_INT 1
1043: PUSH
1044: LD_INT 31
1046: PUSH
1047: EMPTY
1048: LIST
1049: LIST
1050: LIST
1051: LIST
1052: PUSH
1053: LD_INT 13
1055: PUSH
1056: LD_INT 3
1058: PUSH
1059: LD_INT 2
1061: PUSH
1062: LD_INT 32
1064: PUSH
1065: EMPTY
1066: LIST
1067: LIST
1068: LIST
1069: LIST
1070: PUSH
1071: LD_INT 14
1073: PUSH
1074: LD_INT 1
1076: PUSH
1077: LD_INT 2
1079: PUSH
1080: LD_INT 88
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PUSH
1089: EMPTY
1090: LIST
1091: LIST
1092: LIST
1093: LIST
1094: PPUSH
1095: CALL 62424 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1099: LD_INT 4
1101: PPUSH
1102: LD_INT 10
1104: PUSH
1105: LD_INT 12
1107: PUSH
1108: EMPTY
1109: LIST
1110: LIST
1111: PPUSH
1112: CALL 63166 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1116: LD_INT 4
1118: PPUSH
1119: LD_INT 9
1121: PUSH
1122: EMPTY
1123: LIST
1124: PPUSH
1125: CALL 63259 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1129: LD_INT 4
1131: PPUSH
1132: LD_INT 26
1134: PUSH
1135: LD_INT 74
1137: PUSH
1138: LD_INT 107
1140: PUSH
1141: LD_INT 0
1143: PUSH
1144: EMPTY
1145: LIST
1146: LIST
1147: LIST
1148: LIST
1149: PUSH
1150: LD_INT 32
1152: PUSH
1153: LD_INT 77
1155: PUSH
1156: LD_INT 101
1158: PUSH
1159: LD_INT 4
1161: PUSH
1162: EMPTY
1163: LIST
1164: LIST
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 32
1170: PUSH
1171: LD_INT 69
1173: PUSH
1174: LD_INT 86
1176: PUSH
1177: LD_INT 4
1179: PUSH
1180: EMPTY
1181: LIST
1182: LIST
1183: LIST
1184: LIST
1185: PUSH
1186: LD_INT 27
1188: PUSH
1189: LD_INT 77
1191: PUSH
1192: LD_INT 110
1194: PUSH
1195: LD_INT 3
1197: PUSH
1198: EMPTY
1199: LIST
1200: LIST
1201: LIST
1202: LIST
1203: PUSH
1204: LD_INT 27
1206: PUSH
1207: LD_INT 42
1209: PUSH
1210: LD_INT 79
1212: PUSH
1213: LD_INT 5
1215: PUSH
1216: EMPTY
1217: LIST
1218: LIST
1219: LIST
1220: LIST
1221: PUSH
1222: LD_INT 29
1224: PUSH
1225: LD_INT 86
1227: PUSH
1228: LD_INT 105
1230: PUSH
1231: LD_INT 2
1233: PUSH
1234: EMPTY
1235: LIST
1236: LIST
1237: LIST
1238: LIST
1239: PUSH
1240: LD_INT 30
1242: PUSH
1243: LD_INT 40
1245: PUSH
1246: LD_INT 75
1248: PUSH
1249: LD_INT 1
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: PUSH
1258: LD_INT 32
1260: PUSH
1261: LD_INT 80
1263: PUSH
1264: LD_INT 106
1266: PUSH
1267: LD_INT 4
1269: PUSH
1270: EMPTY
1271: LIST
1272: LIST
1273: LIST
1274: LIST
1275: PUSH
1276: LD_INT 32
1278: PUSH
1279: LD_INT 75
1281: PUSH
1282: LD_INT 114
1284: PUSH
1285: LD_INT 5
1287: PUSH
1288: EMPTY
1289: LIST
1290: LIST
1291: LIST
1292: LIST
1293: PUSH
1294: LD_INT 4
1296: PUSH
1297: LD_INT 39
1299: PUSH
1300: LD_INT 61
1302: PUSH
1303: LD_INT 3
1305: PUSH
1306: EMPTY
1307: LIST
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: EMPTY
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PPUSH
1324: CALL 62316 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher ] ) ;
1328: LD_INT 4
1330: PPUSH
1331: LD_INT 5
1333: PUSH
1334: LD_INT 6
1336: PUSH
1337: LD_INT 7
1339: PUSH
1340: EMPTY
1341: LIST
1342: LIST
1343: LIST
1344: PPUSH
1345: CALL 63577 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1349: LD_INT 4
1351: PPUSH
1352: LD_INT 40
1354: PUSH
1355: LD_INT 75
1357: PUSH
1358: LD_INT 1
1360: PUSH
1361: EMPTY
1362: LIST
1363: LIST
1364: LIST
1365: PUSH
1366: LD_INT 86
1368: PUSH
1369: LD_INT 105
1371: PUSH
1372: LD_INT 0
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: PUSH
1380: EMPTY
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 62748 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 2
1393: PPUSH
1394: CALL 63039 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1398: LD_INT 4
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL 63039 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1408: LD_INT 4
1410: PPUSH
1411: LD_INT 54
1413: PPUSH
1414: LD_INT 85
1416: PPUSH
1417: LD_INT 2
1419: PPUSH
1420: LD_INT 19
1422: PUSH
1423: LD_INT 16
1425: PUSH
1426: LD_INT 17
1428: PUSH
1429: LD_INT 18
1431: PUSH
1432: EMPTY
1433: LIST
1434: LIST
1435: LIST
1436: LIST
1437: PPUSH
1438: CALL 63371 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1442: LD_INT 4
1444: PPUSH
1445: LD_INT 3
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 5
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: LD_INT 4
1465: PUSH
1466: LD_INT 1
1468: PUSH
1469: LD_INT 1
1471: PUSH
1472: LD_INT 6
1474: PUSH
1475: EMPTY
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: PUSH
1481: LD_INT 4
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 7
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: EMPTY
1518: LIST
1519: LIST
1520: LIST
1521: LIST
1522: PPUSH
1523: CALL 62424 0 2
// MC_SetTame ( 4 , powellApe ) ;
1527: LD_INT 4
1529: PPUSH
1530: LD_INT 13
1532: PPUSH
1533: CALL 62990 0 2
// end ;
1537: LD_VAR 0 1
1541: RET
// every 0 0$3 trigger powellAngerQuery and powellAnger >= 2 do
1542: LD_EXP 36
1546: PUSH
1547: LD_EXP 17
1551: PUSH
1552: LD_INT 2
1554: GREATEREQUAL
1555: AND
1556: IFFALSE 1568
1558: GO 1560
1560: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1561: LD_STRING ACH_POWELL
1563: PPUSH
1564: CALL_OW 543
1568: END
// every 0 0$3 trigger amConstructCounter >= 30 do
1569: LD_EXP 39
1573: PUSH
1574: LD_INT 30
1576: GREATEREQUAL
1577: IFFALSE 1589
1579: GO 1581
1581: DISABLE
// SetAchievement ( ACH_PROD ) ;
1582: LD_STRING ACH_PROD
1584: PPUSH
1585: CALL_OW 543
1589: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_minskill , 1 , 10 ] , [ f_minskill , 2 , 10 ] , [ f_minskill , 3 , 10 ] , [ f_minskill , 4 , 10 ] ] ] ) >= 10 do
1590: LD_INT 22
1592: PUSH
1593: LD_INT 1
1595: PUSH
1596: EMPTY
1597: LIST
1598: LIST
1599: PUSH
1600: LD_INT 21
1602: PUSH
1603: LD_INT 1
1605: PUSH
1606: EMPTY
1607: LIST
1608: LIST
1609: PUSH
1610: LD_INT 2
1612: PUSH
1613: LD_INT 28
1615: PUSH
1616: LD_INT 1
1618: PUSH
1619: LD_INT 10
1621: PUSH
1622: EMPTY
1623: LIST
1624: LIST
1625: LIST
1626: PUSH
1627: LD_INT 28
1629: PUSH
1630: LD_INT 2
1632: PUSH
1633: LD_INT 10
1635: PUSH
1636: EMPTY
1637: LIST
1638: LIST
1639: LIST
1640: PUSH
1641: LD_INT 28
1643: PUSH
1644: LD_INT 3
1646: PUSH
1647: LD_INT 10
1649: PUSH
1650: EMPTY
1651: LIST
1652: LIST
1653: LIST
1654: PUSH
1655: LD_INT 28
1657: PUSH
1658: LD_INT 4
1660: PUSH
1661: LD_INT 10
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: LIST
1668: PUSH
1669: EMPTY
1670: LIST
1671: LIST
1672: LIST
1673: LIST
1674: LIST
1675: PUSH
1676: EMPTY
1677: LIST
1678: LIST
1679: LIST
1680: PPUSH
1681: CALL_OW 69
1685: PUSH
1686: LD_INT 10
1688: GREATEREQUAL
1689: IFFALSE 1701
1691: GO 1693
1693: DISABLE
// SetAchievement ( ACH_EXP ) ;
1694: LD_STRING ACH_EXP
1696: PPUSH
1697: CALL_OW 543
1701: END
// every 0 0$1 trigger debug do var i , tmp ;
1702: LD_EXP 1
1706: IFFALSE 1813
1708: GO 1710
1710: DISABLE
1711: LD_INT 0
1713: PPUSH
1714: PPUSH
// begin enable ;
1715: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1716: LD_ADDR_VAR 0 2
1720: PUSH
1721: LD_INT 22
1723: PUSH
1724: LD_INT 1
1726: PUSH
1727: EMPTY
1728: LIST
1729: LIST
1730: PUSH
1731: LD_INT 3
1733: PUSH
1734: LD_INT 21
1736: PUSH
1737: LD_INT 3
1739: PUSH
1740: EMPTY
1741: LIST
1742: LIST
1743: PUSH
1744: EMPTY
1745: LIST
1746: LIST
1747: PUSH
1748: LD_INT 3
1750: PUSH
1751: LD_INT 24
1753: PUSH
1754: LD_INT 999
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: PUSH
1761: EMPTY
1762: LIST
1763: LIST
1764: PUSH
1765: EMPTY
1766: LIST
1767: LIST
1768: LIST
1769: PPUSH
1770: CALL_OW 69
1774: ST_TO_ADDR
// if not tmp then
1775: LD_VAR 0 2
1779: NOT
1780: IFFALSE 1784
// exit ;
1782: GO 1813
// for i in tmp do
1784: LD_ADDR_VAR 0 1
1788: PUSH
1789: LD_VAR 0 2
1793: PUSH
1794: FOR_IN
1795: IFFALSE 1811
// SetLives ( i , 1000 ) ;
1797: LD_VAR 0 1
1801: PPUSH
1802: LD_INT 1000
1804: PPUSH
1805: CALL_OW 234
1809: GO 1794
1811: POP
1812: POP
// end ; end_of_file
1813: PPOPN 2
1815: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker , Mike ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1816: LD_INT 0
1818: PPUSH
// uc_side := 1 ;
1819: LD_ADDR_OWVAR 20
1823: PUSH
1824: LD_INT 1
1826: ST_TO_ADDR
// uc_nation := 1 ;
1827: LD_ADDR_OWVAR 21
1831: PUSH
1832: LD_INT 1
1834: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1835: LD_ADDR_EXP 40
1839: PUSH
1840: LD_STRING JMM
1842: PPUSH
1843: LD_EXP 1
1847: NOT
1848: PPUSH
1849: LD_STRING 14_
1851: PPUSH
1852: CALL 68898 0 3
1856: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1857: LD_EXP 4
1861: NOT
1862: PUSH
1863: LD_EXP 4
1867: PUSH
1868: LD_INT 1
1870: ARRAY
1871: PUSH
1872: LD_INT 1
1874: ARRAY
1875: NOT
1876: OR
1877: IFFALSE 1900
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 73738 0 5
1898: GO 1959
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1900: LD_EXP 4
1904: PUSH
1905: LD_INT 1
1907: ARRAY
1908: PUSH
1909: LD_INT 1
1911: ARRAY
1912: PPUSH
1913: LD_EXP 4
1917: PUSH
1918: LD_INT 2
1920: ARRAY
1921: PUSH
1922: LD_INT 1
1924: ARRAY
1925: PPUSH
1926: LD_EXP 4
1930: PUSH
1931: LD_INT 3
1933: ARRAY
1934: PUSH
1935: LD_INT 1
1937: ARRAY
1938: PPUSH
1939: LD_EXP 4
1943: PUSH
1944: LD_INT 4
1946: ARRAY
1947: PUSH
1948: LD_INT 1
1950: ARRAY
1951: PPUSH
1952: LD_INT 30
1954: PPUSH
1955: CALL 73738 0 5
// JMMNewVeh := CreateVehicle ;
1959: LD_ADDR_EXP 58
1963: PUSH
1964: CALL_OW 45
1968: ST_TO_ADDR
// if not JMMNewVeh then
1969: LD_EXP 58
1973: NOT
1974: IFFALSE 2005
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1976: LD_INT 5
1978: PPUSH
1979: LD_INT 3
1981: PPUSH
1982: LD_INT 1
1984: PPUSH
1985: LD_INT 9
1987: PPUSH
1988: LD_INT 100
1990: PPUSH
1991: CALL 73738 0 5
// JMMNewVeh := CreateVehicle ;
1995: LD_ADDR_EXP 58
1999: PUSH
2000: CALL_OW 45
2004: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
2005: LD_EXP 58
2009: PPUSH
2010: LD_INT 4
2012: PPUSH
2013: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
2017: LD_EXP 58
2021: PPUSH
2022: LD_INT 79
2024: PPUSH
2025: LD_INT 91
2027: PPUSH
2028: LD_INT 0
2030: PPUSH
2031: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
2035: LD_EXP 40
2039: PPUSH
2040: LD_EXP 58
2044: PPUSH
2045: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
2049: LD_EXP 6
2053: PUSH
2054: LD_EXP 2
2058: NOT
2059: AND
2060: IFFALSE 2318
// begin if not JMMGirlVeh then
2062: LD_EXP 5
2066: NOT
2067: IFFALSE 2090
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
2069: LD_INT 3
2071: PPUSH
2072: LD_INT 3
2074: PPUSH
2075: LD_INT 1
2077: PPUSH
2078: LD_INT 9
2080: PPUSH
2081: LD_INT 100
2083: PPUSH
2084: CALL 73738 0 5
2088: GO 2149
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
2090: LD_EXP 5
2094: PUSH
2095: LD_INT 1
2097: ARRAY
2098: PUSH
2099: LD_INT 1
2101: ARRAY
2102: PPUSH
2103: LD_EXP 5
2107: PUSH
2108: LD_INT 2
2110: ARRAY
2111: PUSH
2112: LD_INT 1
2114: ARRAY
2115: PPUSH
2116: LD_EXP 5
2120: PUSH
2121: LD_INT 3
2123: ARRAY
2124: PUSH
2125: LD_INT 1
2127: ARRAY
2128: PPUSH
2129: LD_EXP 5
2133: PUSH
2134: LD_INT 4
2136: ARRAY
2137: PUSH
2138: LD_INT 1
2140: ARRAY
2141: PPUSH
2142: LD_INT 30
2144: PPUSH
2145: CALL 73738 0 5
// GirlNewVeh := CreateVehicle ;
2149: LD_ADDR_EXP 59
2153: PUSH
2154: CALL_OW 45
2158: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2159: LD_EXP 59
2163: PPUSH
2164: LD_INT 4
2166: PPUSH
2167: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2171: LD_EXP 59
2175: PPUSH
2176: LD_INT 82
2178: PPUSH
2179: LD_INT 96
2181: PPUSH
2182: LD_INT 0
2184: PPUSH
2185: CALL_OW 48
// if JMMGirl = 1 then
2189: LD_EXP 7
2193: PUSH
2194: LD_INT 1
2196: EQUAL
2197: IFFALSE 2232
// begin Joan := PrepareUnit ( Joan , true , 14_ ) ;
2199: LD_ADDR_EXP 41
2203: PUSH
2204: LD_STRING Joan
2206: PPUSH
2207: LD_INT 1
2209: PPUSH
2210: LD_STRING 14_
2212: PPUSH
2213: CALL 68898 0 3
2217: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2218: LD_EXP 41
2222: PPUSH
2223: LD_EXP 59
2227: PPUSH
2228: CALL_OW 52
// end ; if JMMGirl = 2 then
2232: LD_EXP 7
2236: PUSH
2237: LD_INT 2
2239: EQUAL
2240: IFFALSE 2275
// begin Lisa := PrepareUnit ( Lisa , true , 14_ ) ;
2242: LD_ADDR_EXP 43
2246: PUSH
2247: LD_STRING Lisa
2249: PPUSH
2250: LD_INT 1
2252: PPUSH
2253: LD_STRING 14_
2255: PPUSH
2256: CALL 68898 0 3
2260: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2261: LD_EXP 43
2265: PPUSH
2266: LD_EXP 59
2270: PPUSH
2271: CALL_OW 52
// end ; if JMMGirl = 3 then
2275: LD_EXP 7
2279: PUSH
2280: LD_INT 3
2282: EQUAL
2283: IFFALSE 2318
// begin Connie := PrepareUnit ( Connie , true , 14_ ) ;
2285: LD_ADDR_EXP 55
2289: PUSH
2290: LD_STRING Connie
2292: PPUSH
2293: LD_INT 1
2295: PPUSH
2296: LD_STRING 14_
2298: PPUSH
2299: CALL 68898 0 3
2303: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2304: LD_EXP 55
2308: PPUSH
2309: LD_EXP 59
2313: PPUSH
2314: CALL_OW 52
// end ; end ; end ;
2318: LD_VAR 0 1
2322: RET
// export function PrepareStevensSquad ; var tmp ; begin
2323: LD_INT 0
2325: PPUSH
2326: PPUSH
// uc_side := 1 ;
2327: LD_ADDR_OWVAR 20
2331: PUSH
2332: LD_INT 1
2334: ST_TO_ADDR
// uc_nation := 1 ;
2335: LD_ADDR_OWVAR 21
2339: PUSH
2340: LD_INT 1
2342: ST_TO_ADDR
// tmp := [ ] ;
2343: LD_ADDR_VAR 0 2
2347: PUSH
2348: EMPTY
2349: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2350: LD_ADDR_EXP 42
2354: PUSH
2355: LD_STRING Stevens
2357: PPUSH
2358: LD_EXP 1
2362: NOT
2363: PPUSH
2364: LD_STRING 13f_
2366: PPUSH
2367: CALL 68898 0 3
2371: ST_TO_ADDR
// if not Stevens then
2372: LD_EXP 42
2376: NOT
2377: IFFALSE 2445
// begin hc_name = Baker Smith ;
2379: LD_ADDR_OWVAR 26
2383: PUSH
2384: LD_STRING Baker Smith
2386: ST_TO_ADDR
// hc_gallery = us ;
2387: LD_ADDR_OWVAR 33
2391: PUSH
2392: LD_STRING us
2394: ST_TO_ADDR
// hc_face_number := 29 ;
2395: LD_ADDR_OWVAR 34
2399: PUSH
2400: LD_INT 29
2402: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2403: LD_INT 1
2405: PPUSH
2406: LD_INT 10
2408: PPUSH
2409: CALL_OW 384
// Baker = CreateHuman ;
2413: LD_ADDR_EXP 56
2417: PUSH
2418: CALL_OW 44
2422: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 56
2437: ADD
2438: ST_TO_ADDR
// InitHc ;
2439: CALL_OW 19
// end else
2443: GO 2461
// tmp := tmp ^ Stevens ;
2445: LD_ADDR_VAR 0 2
2449: PUSH
2450: LD_VAR 0 2
2454: PUSH
2455: LD_EXP 42
2459: ADD
2460: ST_TO_ADDR
// if not Lisa then
2461: LD_EXP 43
2465: NOT
2466: IFFALSE 2512
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2468: LD_ADDR_EXP 43
2472: PUSH
2473: LD_STRING Lisa
2475: PPUSH
2476: LD_EXP 1
2480: NOT
2481: PPUSH
2482: LD_STRING 13f_
2484: PPUSH
2485: CALL 68898 0 3
2489: ST_TO_ADDR
// if Lisa then
2490: LD_EXP 43
2494: IFFALSE 2512
// tmp := tmp ^ Lisa ;
2496: LD_ADDR_VAR 0 2
2500: PUSH
2501: LD_VAR 0 2
2505: PUSH
2506: LD_EXP 43
2510: ADD
2511: ST_TO_ADDR
// end ; if not Donaldson then
2512: LD_EXP 44
2516: NOT
2517: IFFALSE 2563
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2519: LD_ADDR_EXP 44
2523: PUSH
2524: LD_STRING Donaldson
2526: PPUSH
2527: LD_EXP 1
2531: NOT
2532: PPUSH
2533: LD_STRING 13f_
2535: PPUSH
2536: CALL 68898 0 3
2540: ST_TO_ADDR
// if Donaldson then
2541: LD_EXP 44
2545: IFFALSE 2563
// tmp := tmp ^ Donaldson ;
2547: LD_ADDR_VAR 0 2
2551: PUSH
2552: LD_VAR 0 2
2556: PUSH
2557: LD_EXP 44
2561: ADD
2562: ST_TO_ADDR
// end ; if not Bobby then
2563: LD_EXP 45
2567: NOT
2568: IFFALSE 2614
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2570: LD_ADDR_EXP 45
2574: PUSH
2575: LD_STRING Bobby
2577: PPUSH
2578: LD_EXP 1
2582: NOT
2583: PPUSH
2584: LD_STRING 13f_
2586: PPUSH
2587: CALL 68898 0 3
2591: ST_TO_ADDR
// if Bobby then
2592: LD_EXP 45
2596: IFFALSE 2614
// tmp := tmp ^ Bobby ;
2598: LD_ADDR_VAR 0 2
2602: PUSH
2603: LD_VAR 0 2
2607: PUSH
2608: LD_EXP 45
2612: ADD
2613: ST_TO_ADDR
// end ; if not Cyrus then
2614: LD_EXP 46
2618: NOT
2619: IFFALSE 2665
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2621: LD_ADDR_EXP 46
2625: PUSH
2626: LD_STRING Cyrus
2628: PPUSH
2629: LD_EXP 1
2633: NOT
2634: PPUSH
2635: LD_STRING 13f_
2637: PPUSH
2638: CALL 68898 0 3
2642: ST_TO_ADDR
// if Cyrus then
2643: LD_EXP 46
2647: IFFALSE 2665
// tmp := tmp ^ Cyrus ;
2649: LD_ADDR_VAR 0 2
2653: PUSH
2654: LD_VAR 0 2
2658: PUSH
2659: LD_EXP 46
2663: ADD
2664: ST_TO_ADDR
// end ; if not Brown then
2665: LD_EXP 48
2669: NOT
2670: IFFALSE 2716
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2672: LD_ADDR_EXP 48
2676: PUSH
2677: LD_STRING Brown
2679: PPUSH
2680: LD_EXP 1
2684: NOT
2685: PPUSH
2686: LD_STRING 13f_
2688: PPUSH
2689: CALL 68898 0 3
2693: ST_TO_ADDR
// if Brown then
2694: LD_EXP 48
2698: IFFALSE 2716
// tmp := tmp ^ Brown ;
2700: LD_ADDR_VAR 0 2
2704: PUSH
2705: LD_VAR 0 2
2709: PUSH
2710: LD_EXP 48
2714: ADD
2715: ST_TO_ADDR
// end ; if not Gladstone then
2716: LD_EXP 49
2720: NOT
2721: IFFALSE 2767
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2723: LD_ADDR_EXP 49
2727: PUSH
2728: LD_STRING Gladstone
2730: PPUSH
2731: LD_EXP 1
2735: NOT
2736: PPUSH
2737: LD_STRING 13f_
2739: PPUSH
2740: CALL 68898 0 3
2744: ST_TO_ADDR
// if Gladstone then
2745: LD_EXP 49
2749: IFFALSE 2767
// tmp := tmp ^ Gladstone ;
2751: LD_ADDR_VAR 0 2
2755: PUSH
2756: LD_VAR 0 2
2760: PUSH
2761: LD_EXP 49
2765: ADD
2766: ST_TO_ADDR
// end ; if not Houten then
2767: LD_EXP 50
2771: NOT
2772: IFFALSE 2818
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2774: LD_ADDR_EXP 50
2778: PUSH
2779: LD_STRING Houten
2781: PPUSH
2782: LD_EXP 1
2786: NOT
2787: PPUSH
2788: LD_STRING 13f_
2790: PPUSH
2791: CALL 68898 0 3
2795: ST_TO_ADDR
// if Houten then
2796: LD_EXP 50
2800: IFFALSE 2818
// tmp := tmp ^ Houten ;
2802: LD_ADDR_VAR 0 2
2806: PUSH
2807: LD_VAR 0 2
2811: PUSH
2812: LD_EXP 50
2816: ADD
2817: ST_TO_ADDR
// end ; if not Cornel then
2818: LD_EXP 51
2822: NOT
2823: IFFALSE 2869
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2825: LD_ADDR_EXP 51
2829: PUSH
2830: LD_STRING Cornell
2832: PPUSH
2833: LD_EXP 1
2837: NOT
2838: PPUSH
2839: LD_STRING 13f_
2841: PPUSH
2842: CALL 68898 0 3
2846: ST_TO_ADDR
// if Cornel then
2847: LD_EXP 51
2851: IFFALSE 2869
// tmp := tmp ^ Cornel ;
2853: LD_ADDR_VAR 0 2
2857: PUSH
2858: LD_VAR 0 2
2862: PUSH
2863: LD_EXP 51
2867: ADD
2868: ST_TO_ADDR
// end ; if not Gary then
2869: LD_EXP 52
2873: NOT
2874: IFFALSE 2920
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2876: LD_ADDR_EXP 52
2880: PUSH
2881: LD_STRING Gary
2883: PPUSH
2884: LD_EXP 1
2888: NOT
2889: PPUSH
2890: LD_STRING 13f_
2892: PPUSH
2893: CALL 68898 0 3
2897: ST_TO_ADDR
// if Gary then
2898: LD_EXP 52
2902: IFFALSE 2920
// tmp := tmp ^ Gary ;
2904: LD_ADDR_VAR 0 2
2908: PUSH
2909: LD_VAR 0 2
2913: PUSH
2914: LD_EXP 52
2918: ADD
2919: ST_TO_ADDR
// end ; if not Frank then
2920: LD_EXP 53
2924: NOT
2925: IFFALSE 2971
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2927: LD_ADDR_EXP 53
2931: PUSH
2932: LD_STRING Frank
2934: PPUSH
2935: LD_EXP 1
2939: NOT
2940: PPUSH
2941: LD_STRING 13f_
2943: PPUSH
2944: CALL 68898 0 3
2948: ST_TO_ADDR
// if Frank then
2949: LD_EXP 53
2953: IFFALSE 2971
// tmp := tmp ^ Frank ;
2955: LD_ADDR_VAR 0 2
2959: PUSH
2960: LD_VAR 0 2
2964: PUSH
2965: LD_EXP 53
2969: ADD
2970: ST_TO_ADDR
// end ; if not Kikuchi then
2971: LD_EXP 54
2975: NOT
2976: IFFALSE 3022
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2978: LD_ADDR_EXP 54
2982: PUSH
2983: LD_STRING Kikuchi
2985: PPUSH
2986: LD_EXP 1
2990: NOT
2991: PPUSH
2992: LD_STRING 13f_
2994: PPUSH
2995: CALL 68898 0 3
2999: ST_TO_ADDR
// if Kikuchi then
3000: LD_EXP 54
3004: IFFALSE 3022
// tmp := tmp ^ Kikuchi ;
3006: LD_ADDR_VAR 0 2
3010: PUSH
3011: LD_VAR 0 2
3015: PUSH
3016: LD_EXP 54
3020: ADD
3021: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
3022: LD_ADDR_VAR 0 2
3026: PUSH
3027: LD_VAR 0 2
3031: PUSH
3032: LD_STRING 13_other_survivors
3034: PPUSH
3035: CALL_OW 31
3039: UNION
3040: ST_TO_ADDR
// result := tmp ;
3041: LD_ADDR_VAR 0 1
3045: PUSH
3046: LD_VAR 0 2
3050: ST_TO_ADDR
// end ; end_of_file
3051: LD_VAR 0 1
3055: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , tmp , depot , lab , armoury , workshop , un ; begin
3056: LD_INT 0
3058: PPUSH
3059: PPUSH
3060: PPUSH
3061: PPUSH
3062: PPUSH
3063: PPUSH
3064: PPUSH
3065: PPUSH
3066: PPUSH
3067: PPUSH
// uc_side := 4 ;
3068: LD_ADDR_OWVAR 20
3072: PUSH
3073: LD_INT 4
3075: ST_TO_ADDR
// uc_nation := 1 ;
3076: LD_ADDR_OWVAR 21
3080: PUSH
3081: LD_INT 1
3083: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
3084: LD_INT 387
3086: PPUSH
3087: CALL_OW 274
3091: PPUSH
3092: LD_INT 1
3094: PPUSH
3095: LD_INT 3500
3097: PUSH
3098: LD_INT 3000
3100: PUSH
3101: LD_INT 2500
3103: PUSH
3104: LD_INT 2000
3106: PUSH
3107: EMPTY
3108: LIST
3109: LIST
3110: LIST
3111: LIST
3112: PUSH
3113: LD_OWVAR 67
3117: ARRAY
3118: PPUSH
3119: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3123: LD_INT 387
3125: PPUSH
3126: CALL_OW 274
3130: PPUSH
3131: LD_INT 2
3133: PPUSH
3134: LD_INT 400
3136: PPUSH
3137: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3141: LD_INT 387
3143: PPUSH
3144: CALL_OW 274
3148: PPUSH
3149: LD_INT 3
3151: PPUSH
3152: LD_INT 10
3154: PPUSH
3155: CALL_OW 277
// SetBName ( am_depot , sigma ) ;
3159: LD_INT 387
3161: PPUSH
3162: LD_STRING sigma
3164: PPUSH
3165: CALL_OW 500
// Powell := NewCharacter ( Powell ) ;
3169: LD_ADDR_EXP 60
3173: PUSH
3174: LD_STRING Powell
3176: PPUSH
3177: CALL_OW 25
3181: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3182: LD_EXP 60
3186: PPUSH
3187: LD_INT 57
3189: PPUSH
3190: LD_INT 94
3192: PPUSH
3193: LD_INT 0
3195: PPUSH
3196: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3200: LD_EXP 60
3204: PPUSH
3205: LD_INT 58
3207: PPUSH
3208: LD_INT 94
3210: PPUSH
3211: CALL_OW 118
// vip := [ ] ;
3215: LD_ADDR_EXP 61
3219: PUSH
3220: EMPTY
3221: ST_TO_ADDR
// tmp := [ ] ;
3222: LD_ADDR_VAR 0 5
3226: PUSH
3227: EMPTY
3228: ST_TO_ADDR
// if JMMGirl <> 2 then
3229: LD_EXP 7
3233: PUSH
3234: LD_INT 2
3236: NONEQUAL
3237: IFFALSE 3261
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3239: LD_ADDR_EXP 43
3243: PUSH
3244: LD_STRING Lisa
3246: PPUSH
3247: LD_EXP 1
3251: NOT
3252: PPUSH
3253: LD_STRING 13s_
3255: PPUSH
3256: CALL 68898 0 3
3260: ST_TO_ADDR
// if Lisa then
3261: LD_EXP 43
3265: IFFALSE 3283
// tmp := tmp ^ Lisa ;
3267: LD_ADDR_VAR 0 5
3271: PUSH
3272: LD_VAR 0 5
3276: PUSH
3277: LD_EXP 43
3281: ADD
3282: ST_TO_ADDR
// if JMMGirl < 3 then
3283: LD_EXP 7
3287: PUSH
3288: LD_INT 3
3290: LESS
3291: IFFALSE 3322
// begin Connie := NewCharacter ( Coonie ) ;
3293: LD_ADDR_EXP 55
3297: PUSH
3298: LD_STRING Coonie
3300: PPUSH
3301: CALL_OW 25
3305: ST_TO_ADDR
// tmp := tmp ^ Connie ;
3306: LD_ADDR_VAR 0 5
3310: PUSH
3311: LD_VAR 0 5
3315: PUSH
3316: LD_EXP 55
3320: ADD
3321: ST_TO_ADDR
// end ; Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3322: LD_ADDR_EXP 44
3326: PUSH
3327: LD_STRING Donaldson
3329: PPUSH
3330: LD_EXP 1
3334: NOT
3335: PPUSH
3336: LD_STRING 13s_
3338: PPUSH
3339: CALL 68898 0 3
3343: ST_TO_ADDR
// if Donaldson then
3344: LD_EXP 44
3348: IFFALSE 3366
// tmp := tmp ^ Donaldson ;
3350: LD_ADDR_VAR 0 5
3354: PUSH
3355: LD_VAR 0 5
3359: PUSH
3360: LD_EXP 44
3364: ADD
3365: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3366: LD_ADDR_EXP 45
3370: PUSH
3371: LD_STRING Bobby
3373: PPUSH
3374: LD_EXP 1
3378: NOT
3379: PPUSH
3380: LD_STRING 13s_
3382: PPUSH
3383: CALL 68898 0 3
3387: ST_TO_ADDR
// if Bobby then
3388: LD_EXP 45
3392: IFFALSE 3410
// tmp := tmp ^ Bobby ;
3394: LD_ADDR_VAR 0 5
3398: PUSH
3399: LD_VAR 0 5
3403: PUSH
3404: LD_EXP 45
3408: ADD
3409: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3410: LD_ADDR_EXP 46
3414: PUSH
3415: LD_STRING Cyrus
3417: PPUSH
3418: LD_EXP 1
3422: NOT
3423: PPUSH
3424: LD_STRING 13s_
3426: PPUSH
3427: CALL 68898 0 3
3431: ST_TO_ADDR
// if Cyrus then
3432: LD_EXP 46
3436: IFFALSE 3454
// tmp := tmp ^ Cyrus ;
3438: LD_ADDR_VAR 0 5
3442: PUSH
3443: LD_VAR 0 5
3447: PUSH
3448: LD_EXP 46
3452: ADD
3453: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3454: LD_ADDR_EXP 47
3458: PUSH
3459: LD_STRING Denis
3461: PPUSH
3462: LD_EXP 1
3466: NOT
3467: PPUSH
3468: LD_STRING 13s_
3470: PPUSH
3471: CALL 68898 0 3
3475: ST_TO_ADDR
// if not Denis then
3476: LD_EXP 47
3480: NOT
3481: IFFALSE 3505
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3483: LD_ADDR_EXP 47
3487: PUSH
3488: LD_STRING Denis
3490: PPUSH
3491: LD_EXP 1
3495: NOT
3496: PPUSH
3497: LD_STRING 13f_
3499: PPUSH
3500: CALL 68898 0 3
3504: ST_TO_ADDR
// if Denis then
3505: LD_EXP 47
3509: IFFALSE 3527
// tmp := tmp ^ Denis ;
3511: LD_ADDR_VAR 0 5
3515: PUSH
3516: LD_VAR 0 5
3520: PUSH
3521: LD_EXP 47
3525: ADD
3526: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3527: LD_ADDR_EXP 48
3531: PUSH
3532: LD_STRING Brown
3534: PPUSH
3535: LD_EXP 1
3539: NOT
3540: PPUSH
3541: LD_STRING 13s_
3543: PPUSH
3544: CALL 68898 0 3
3548: ST_TO_ADDR
// if Brown then
3549: LD_EXP 48
3553: IFFALSE 3571
// tmp := tmp ^ Brown ;
3555: LD_ADDR_VAR 0 5
3559: PUSH
3560: LD_VAR 0 5
3564: PUSH
3565: LD_EXP 48
3569: ADD
3570: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3571: LD_ADDR_EXP 49
3575: PUSH
3576: LD_STRING Gladstone
3578: PPUSH
3579: LD_EXP 1
3583: NOT
3584: PPUSH
3585: LD_STRING 13s_
3587: PPUSH
3588: CALL 68898 0 3
3592: ST_TO_ADDR
// if Gladstone then
3593: LD_EXP 49
3597: IFFALSE 3615
// tmp := tmp ^ Gladstone ;
3599: LD_ADDR_VAR 0 5
3603: PUSH
3604: LD_VAR 0 5
3608: PUSH
3609: LD_EXP 49
3613: ADD
3614: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3615: LD_ADDR_EXP 50
3619: PUSH
3620: LD_STRING Houten
3622: PPUSH
3623: LD_EXP 1
3627: NOT
3628: PPUSH
3629: LD_STRING 13s_
3631: PPUSH
3632: CALL 68898 0 3
3636: ST_TO_ADDR
// if Houten then
3637: LD_EXP 50
3641: IFFALSE 3659
// tmp := tmp ^ Houten ;
3643: LD_ADDR_VAR 0 5
3647: PUSH
3648: LD_VAR 0 5
3652: PUSH
3653: LD_EXP 50
3657: ADD
3658: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3659: LD_ADDR_EXP 51
3663: PUSH
3664: LD_STRING Cornel
3666: PPUSH
3667: LD_EXP 1
3671: NOT
3672: PPUSH
3673: LD_STRING 13s_
3675: PPUSH
3676: CALL 68898 0 3
3680: ST_TO_ADDR
// if Cornel then
3681: LD_EXP 51
3685: IFFALSE 3703
// tmp := tmp ^ Cornel ;
3687: LD_ADDR_VAR 0 5
3691: PUSH
3692: LD_VAR 0 5
3696: PUSH
3697: LD_EXP 51
3701: ADD
3702: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3703: LD_ADDR_EXP 52
3707: PUSH
3708: LD_STRING Gary
3710: PPUSH
3711: LD_EXP 1
3715: NOT
3716: PPUSH
3717: LD_STRING 13s_
3719: PPUSH
3720: CALL 68898 0 3
3724: ST_TO_ADDR
// if Gary then
3725: LD_EXP 52
3729: IFFALSE 3747
// tmp := tmp ^ Gary ;
3731: LD_ADDR_VAR 0 5
3735: PUSH
3736: LD_VAR 0 5
3740: PUSH
3741: LD_EXP 52
3745: ADD
3746: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3747: LD_ADDR_EXP 53
3751: PUSH
3752: LD_STRING Frank
3754: PPUSH
3755: LD_EXP 1
3759: NOT
3760: PPUSH
3761: LD_STRING 13s_
3763: PPUSH
3764: CALL 68898 0 3
3768: ST_TO_ADDR
// if Frank then
3769: LD_EXP 53
3773: IFFALSE 3791
// tmp := tmp ^ Frank ;
3775: LD_ADDR_VAR 0 5
3779: PUSH
3780: LD_VAR 0 5
3784: PUSH
3785: LD_EXP 53
3789: ADD
3790: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3791: LD_ADDR_EXP 54
3795: PUSH
3796: LD_STRING Kikuchi
3798: PPUSH
3799: LD_EXP 1
3803: NOT
3804: PPUSH
3805: LD_STRING 13s_
3807: PPUSH
3808: CALL 68898 0 3
3812: ST_TO_ADDR
// if Kikuchi then
3813: LD_EXP 54
3817: IFFALSE 3835
// tmp := tmp ^ Kikuchi ;
3819: LD_ADDR_VAR 0 5
3823: PUSH
3824: LD_VAR 0 5
3828: PUSH
3829: LD_EXP 54
3833: ADD
3834: ST_TO_ADDR
// Mike := PrepareUnit ( Mike , ( not debug ) , 10c_ ) ;
3835: LD_ADDR_EXP 57
3839: PUSH
3840: LD_STRING Mike
3842: PPUSH
3843: LD_EXP 1
3847: NOT
3848: PPUSH
3849: LD_STRING 10c_
3851: PPUSH
3852: CALL 68898 0 3
3856: ST_TO_ADDR
// if Mike then
3857: LD_EXP 57
3861: IFFALSE 3884
// PlaceUnitXYR ( Mike , 61 , 89 , 8 , false ) ;
3863: LD_EXP 57
3867: PPUSH
3868: LD_INT 61
3870: PPUSH
3871: LD_INT 89
3873: PPUSH
3874: LD_INT 8
3876: PPUSH
3877: LD_INT 0
3879: PPUSH
3880: CALL_OW 50
// vip := tmp ;
3884: LD_ADDR_EXP 61
3888: PUSH
3889: LD_VAR 0 5
3893: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3894: LD_ADDR_VAR 0 5
3898: PUSH
3899: LD_VAR 0 5
3903: PUSH
3904: LD_STRING 13s_others
3906: PPUSH
3907: CALL_OW 31
3911: UNION
3912: ST_TO_ADDR
// if tmp < 18 then
3913: LD_VAR 0 5
3917: PUSH
3918: LD_INT 18
3920: LESS
3921: IFFALSE 4014
// for i = 1 to 18 - tmp do
3923: LD_ADDR_VAR 0 2
3927: PUSH
3928: DOUBLE
3929: LD_INT 1
3931: DEC
3932: ST_TO_ADDR
3933: LD_INT 18
3935: PUSH
3936: LD_VAR 0 5
3940: MINUS
3941: PUSH
3942: FOR_TO
3943: IFFALSE 4012
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 4 ) ;
3945: LD_INT 1
3947: PPUSH
3948: LD_VAR 0 2
3952: PUSH
3953: LD_INT 4
3955: MOD
3956: PUSH
3957: LD_INT 1
3959: PLUS
3960: PPUSH
3961: LD_INT 4
3963: PPUSH
3964: CALL_OW 380
// un := CreateHuman ;
3968: LD_ADDR_VAR 0 10
3972: PUSH
3973: CALL_OW 44
3977: ST_TO_ADDR
// tmp := Join ( tmp , un ) ;
3978: LD_ADDR_VAR 0 5
3982: PUSH
3983: LD_VAR 0 5
3987: PPUSH
3988: LD_VAR 0 10
3992: PPUSH
3993: CALL 106190 0 2
3997: ST_TO_ADDR
// SetTag ( un , 1 ) ;
3998: LD_VAR 0 10
4002: PPUSH
4003: LD_INT 1
4005: PPUSH
4006: CALL_OW 109
// end ;
4010: GO 3942
4012: POP
4013: POP
// depot := HexInfo ( 53 , 94 ) ;
4014: LD_ADDR_VAR 0 6
4018: PUSH
4019: LD_INT 53
4021: PPUSH
4022: LD_INT 94
4024: PPUSH
4025: CALL_OW 428
4029: ST_TO_ADDR
// lab := HexInfo ( 56 , 101 ) ;
4030: LD_ADDR_VAR 0 7
4034: PUSH
4035: LD_INT 56
4037: PPUSH
4038: LD_INT 101
4040: PPUSH
4041: CALL_OW 428
4045: ST_TO_ADDR
// armoury := HexInfo ( 67 , 101 ) ;
4046: LD_ADDR_VAR 0 8
4050: PUSH
4051: LD_INT 67
4053: PPUSH
4054: LD_INT 101
4056: PPUSH
4057: CALL_OW 428
4061: ST_TO_ADDR
// workshop := HexInfo ( 54 , 85 ) ;
4062: LD_ADDR_VAR 0 9
4066: PUSH
4067: LD_INT 54
4069: PPUSH
4070: LD_INT 85
4072: PPUSH
4073: CALL_OW 428
4077: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] ;
4078: LD_ADDR_VAR 0 3
4082: PUSH
4083: LD_VAR 0 8
4087: PUSH
4088: LD_VAR 0 6
4092: PUSH
4093: LD_VAR 0 9
4097: PUSH
4098: LD_VAR 0 7
4102: PUSH
4103: EMPTY
4104: LIST
4105: LIST
4106: LIST
4107: LIST
4108: ST_TO_ADDR
// for i in tmp do
4109: LD_ADDR_VAR 0 2
4113: PUSH
4114: LD_VAR 0 5
4118: PUSH
4119: FOR_IN
4120: IFFALSE 4248
// begin if GetSkill ( i , 2 ) > GetSkill ( i , 1 ) then
4122: LD_VAR 0 2
4126: PPUSH
4127: LD_INT 2
4129: PPUSH
4130: CALL_OW 259
4134: PUSH
4135: LD_VAR 0 2
4139: PPUSH
4140: LD_INT 1
4142: PPUSH
4143: CALL_OW 259
4147: GREATER
4148: IFFALSE 4162
// SetClass ( i , class_engineer ) ;
4150: LD_VAR 0 2
4154: PPUSH
4155: LD_INT 2
4157: PPUSH
4158: CALL_OW 336
// if UnitsInside ( b [ 1 ] ) = 6 then
4162: LD_VAR 0 3
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PPUSH
4171: CALL_OW 313
4175: PUSH
4176: LD_INT 6
4178: EQUAL
4179: IFFALSE 4199
// b := Delete ( b , 1 ) ;
4181: LD_ADDR_VAR 0 3
4185: PUSH
4186: LD_VAR 0 3
4190: PPUSH
4191: LD_INT 1
4193: PPUSH
4194: CALL_OW 3
4198: ST_TO_ADDR
// if b then
4199: LD_VAR 0 3
4203: IFFALSE 4225
// PlaceHumanInUnit ( i , b [ 1 ] ) else
4205: LD_VAR 0 2
4209: PPUSH
4210: LD_VAR 0 3
4214: PUSH
4215: LD_INT 1
4217: ARRAY
4218: PPUSH
4219: CALL_OW 52
4223: GO 4246
// PlaceUnitXYR ( i , 61 , 89 , 8 , false ) ;
4225: LD_VAR 0 2
4229: PPUSH
4230: LD_INT 61
4232: PPUSH
4233: LD_INT 89
4235: PPUSH
4236: LD_INT 8
4238: PPUSH
4239: LD_INT 0
4241: PPUSH
4242: CALL_OW 50
// end ;
4246: GO 4119
4248: POP
4249: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4250: LD_INT 2
4252: PPUSH
4253: LD_INT 1
4255: PPUSH
4256: LD_INT 1
4258: PPUSH
4259: LD_INT 12
4261: PPUSH
4262: LD_INT 100
4264: PPUSH
4265: CALL 73738 0 5
// veh := CreateVehicle ;
4269: LD_ADDR_VAR 0 4
4273: PUSH
4274: CALL_OW 45
4278: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4279: LD_VAR 0 4
4283: PPUSH
4284: LD_INT 4
4286: PPUSH
4287: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4291: LD_VAR 0 4
4295: PPUSH
4296: LD_INT 49
4298: PPUSH
4299: LD_INT 88
4301: PPUSH
4302: LD_INT 0
4304: PPUSH
4305: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4309: LD_VAR 0 4
4313: PPUSH
4314: LD_INT 1
4316: PPUSH
4317: LD_INT 100
4319: PPUSH
4320: CALL_OW 290
// uc_side := 0 ;
4324: LD_ADDR_OWVAR 20
4328: PUSH
4329: LD_INT 0
4331: ST_TO_ADDR
// uc_nation := 0 ;
4332: LD_ADDR_OWVAR 21
4336: PUSH
4337: LD_INT 0
4339: ST_TO_ADDR
// for i := 1 to 3 do
4340: LD_ADDR_VAR 0 2
4344: PUSH
4345: DOUBLE
4346: LD_INT 1
4348: DEC
4349: ST_TO_ADDR
4350: LD_INT 3
4352: PUSH
4353: FOR_TO
4354: IFFALSE 4385
// begin InitHc ;
4356: CALL_OW 19
// hc_class := class_apeman ;
4360: LD_ADDR_OWVAR 28
4364: PUSH
4365: LD_INT 12
4367: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4368: CALL_OW 44
4372: PPUSH
4373: LD_INT 13
4375: PPUSH
4376: LD_INT 0
4378: PPUSH
4379: CALL_OW 49
// end ;
4383: GO 4353
4385: POP
4386: POP
// end ; end_of_file
4387: LD_VAR 0 1
4391: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4392: LD_INT 0
4394: PPUSH
4395: PPUSH
4396: PPUSH
4397: PPUSH
4398: PPUSH
// side := 8 ;
4399: LD_ADDR_VAR 0 3
4403: PUSH
4404: LD_INT 8
4406: ST_TO_ADDR
// uc_side := side ;
4407: LD_ADDR_OWVAR 20
4411: PUSH
4412: LD_VAR 0 3
4416: ST_TO_ADDR
// uc_nation := 2 ;
4417: LD_ADDR_OWVAR 21
4421: PUSH
4422: LD_INT 2
4424: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4425: LD_ADDR_VAR 0 2
4429: PUSH
4430: LD_INT 22
4432: PUSH
4433: LD_VAR 0 3
4437: PUSH
4438: EMPTY
4439: LIST
4440: LIST
4441: PUSH
4442: LD_INT 21
4444: PUSH
4445: LD_INT 3
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: PUSH
4452: EMPTY
4453: LIST
4454: LIST
4455: PPUSH
4456: CALL_OW 69
4460: PUSH
4461: FOR_IN
4462: IFFALSE 4478
// SetBLevel ( i , 10 ) ;
4464: LD_VAR 0 2
4468: PPUSH
4469: LD_INT 10
4471: PPUSH
4472: CALL_OW 241
4476: GO 4461
4478: POP
4479: POP
// if KurtStatus then
4480: LD_EXP 3
4484: IFFALSE 4507
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4486: LD_ADDR_EXP 62
4490: PUSH
4491: LD_STRING Kurt
4493: PPUSH
4494: LD_INT 0
4496: PPUSH
4497: LD_STRING 
4499: PPUSH
4500: CALL 68898 0 3
4504: ST_TO_ADDR
4505: GO 4529
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4507: LD_ADDR_EXP 62
4511: PUSH
4512: LD_STRING AltKurt
4514: PPUSH
4515: LD_EXP 1
4519: NOT
4520: PPUSH
4521: LD_STRING 
4523: PPUSH
4524: CALL 68898 0 3
4528: ST_TO_ADDR
// if not Kurt then
4529: LD_EXP 62
4533: NOT
4534: IFFALSE 4560
// begin InitHc ;
4536: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4540: LD_INT 1
4542: PPUSH
4543: LD_INT 10
4545: PPUSH
4546: CALL_OW 381
// Kurt := CreateHuman ;
4550: LD_ADDR_EXP 62
4554: PUSH
4555: CALL_OW 44
4559: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4560: LD_EXP 62
4564: PPUSH
4565: LD_INT 324
4567: PPUSH
4568: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4572: LD_ADDR_EXP 63
4576: PUSH
4577: LD_STRING Kozlov
4579: PPUSH
4580: LD_INT 0
4582: PPUSH
4583: LD_STRING 
4585: PPUSH
4586: CALL 68898 0 3
4590: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4591: LD_EXP 63
4595: PPUSH
4596: LD_INT 22
4598: PUSH
4599: LD_INT 8
4601: PUSH
4602: EMPTY
4603: LIST
4604: LIST
4605: PUSH
4606: LD_INT 23
4608: PUSH
4609: LD_INT 3
4611: PUSH
4612: EMPTY
4613: LIST
4614: LIST
4615: PUSH
4616: LD_INT 30
4618: PUSH
4619: LD_INT 8
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: PUSH
4626: EMPTY
4627: LIST
4628: LIST
4629: LIST
4630: PPUSH
4631: CALL_OW 69
4635: PUSH
4636: LD_INT 1
4638: ARRAY
4639: PPUSH
4640: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4644: LD_EXP 63
4648: PPUSH
4649: LD_INT 3
4651: PPUSH
4652: LD_INT 10
4654: PPUSH
4655: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4659: LD_EXP 63
4663: PPUSH
4664: LD_INT 4
4666: PPUSH
4667: LD_INT 10
4669: PPUSH
4670: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4674: LD_ADDR_VAR 0 5
4678: PUSH
4679: LD_INT 22
4681: PUSH
4682: LD_VAR 0 3
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: PUSH
4691: LD_INT 30
4693: PUSH
4694: LD_INT 32
4696: PUSH
4697: EMPTY
4698: LIST
4699: LIST
4700: PUSH
4701: LD_INT 58
4703: PUSH
4704: EMPTY
4705: LIST
4706: PUSH
4707: EMPTY
4708: LIST
4709: LIST
4710: LIST
4711: PPUSH
4712: CALL_OW 69
4716: ST_TO_ADDR
// for i = 1 to 10 do
4717: LD_ADDR_VAR 0 2
4721: PUSH
4722: DOUBLE
4723: LD_INT 1
4725: DEC
4726: ST_TO_ADDR
4727: LD_INT 10
4729: PUSH
4730: FOR_TO
4731: IFFALSE 4803
// begin uc_nation := nation_nature ;
4733: LD_ADDR_OWVAR 21
4737: PUSH
4738: LD_INT 0
4740: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4741: LD_ADDR_OWVAR 28
4745: PUSH
4746: LD_INT 15
4748: ST_TO_ADDR
// hc_gallery :=  ;
4749: LD_ADDR_OWVAR 33
4753: PUSH
4754: LD_STRING 
4756: ST_TO_ADDR
// hc_name :=  ;
4757: LD_ADDR_OWVAR 26
4761: PUSH
4762: LD_STRING 
4764: ST_TO_ADDR
// un := CreateHuman ;
4765: LD_ADDR_VAR 0 4
4769: PUSH
4770: CALL_OW 44
4774: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4775: LD_VAR 0 4
4779: PPUSH
4780: LD_VAR 0 5
4784: PUSH
4785: LD_VAR 0 5
4789: PUSH
4790: LD_VAR 0 2
4794: MINUS
4795: ARRAY
4796: PPUSH
4797: CALL_OW 52
// end ;
4801: GO 4730
4803: POP
4804: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4805: LD_ADDR_VAR 0 5
4809: PUSH
4810: LD_STRING 12_kurt_squad
4812: PPUSH
4813: CALL_OW 31
4817: ST_TO_ADDR
// if tmp then
4818: LD_VAR 0 5
4822: IFFALSE 4856
// for i in tmp do
4824: LD_ADDR_VAR 0 2
4828: PUSH
4829: LD_VAR 0 5
4833: PUSH
4834: FOR_IN
4835: IFFALSE 4854
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4837: LD_VAR 0 2
4841: PPUSH
4842: LD_INT 5
4844: PPUSH
4845: LD_INT 0
4847: PPUSH
4848: CALL_OW 49
4852: GO 4834
4854: POP
4855: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4856: LD_INT 324
4858: PPUSH
4859: LD_INT 5
4861: PPUSH
4862: LD_STRING 
4864: PPUSH
4865: LD_INT 8
4867: PUSH
4868: LD_INT 9
4870: PUSH
4871: LD_INT 10
4873: PUSH
4874: LD_INT 10
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: LIST
4881: LIST
4882: PUSH
4883: LD_OWVAR 67
4887: ARRAY
4888: PPUSH
4889: LD_INT 3000
4891: PUSH
4892: LD_INT 500
4894: PUSH
4895: LD_INT 150
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: LIST
4902: PPUSH
4903: LD_INT 16
4905: PUSH
4906: LD_INT 6
4908: PUSH
4909: LD_INT 6
4911: PUSH
4912: LD_INT 8
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: LIST
4919: LIST
4920: PPUSH
4921: CALL 77182 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4925: LD_ADDR_EXP 100
4929: PUSH
4930: LD_EXP 100
4934: PPUSH
4935: LD_INT 3
4937: PPUSH
4938: LD_INT 22
4940: PUSH
4941: LD_VAR 0 3
4945: PUSH
4946: EMPTY
4947: LIST
4948: LIST
4949: PUSH
4950: LD_INT 23
4952: PUSH
4953: LD_INT 2
4955: PUSH
4956: EMPTY
4957: LIST
4958: LIST
4959: PUSH
4960: LD_INT 3
4962: PUSH
4963: LD_INT 21
4965: PUSH
4966: LD_INT 2
4968: PUSH
4969: EMPTY
4970: LIST
4971: LIST
4972: PUSH
4973: EMPTY
4974: LIST
4975: LIST
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: LIST
4981: PPUSH
4982: CALL_OW 69
4986: PUSH
4987: LD_EXP 62
4991: DIFF
4992: PPUSH
4993: CALL_OW 1
4997: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4998: LD_INT 1
5000: PPUSH
5001: LD_INT 7
5003: PPUSH
5004: CALL_OW 383
// hc_name := Ali Hadrach ;
5008: LD_ADDR_OWVAR 26
5012: PUSH
5013: LD_STRING Ali Hadrach
5015: ST_TO_ADDR
// hc_face_number := 31 ;
5016: LD_ADDR_OWVAR 34
5020: PUSH
5021: LD_INT 31
5023: ST_TO_ADDR
// Friend := CreateHuman ;
5024: LD_ADDR_EXP 64
5028: PUSH
5029: CALL_OW 44
5033: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
5034: LD_INT 14
5036: PPUSH
5037: LD_INT 3
5039: PPUSH
5040: LD_INT 1
5042: PPUSH
5043: LD_INT 29
5045: PPUSH
5046: LD_INT 100
5048: PPUSH
5049: CALL 73738 0 5
// powellBomb := CreateVehicle ;
5053: LD_ADDR_EXP 65
5057: PUSH
5058: CALL_OW 45
5062: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
5063: LD_EXP 65
5067: PPUSH
5068: LD_INT 90
5070: PPUSH
5071: LD_INT 51
5073: PPUSH
5074: LD_INT 0
5076: PPUSH
5077: CALL_OW 48
// end ;
5081: LD_VAR 0 1
5085: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
5086: LD_INT 0
5088: PPUSH
5089: PPUSH
5090: PPUSH
// if IsLive ( kozlov_fac ) then
5091: LD_INT 332
5093: PPUSH
5094: CALL_OW 300
5098: IFFALSE 5102
// exit ;
5100: GO 5669
// ComExitBuilding ( Kozlov ) ;
5102: LD_EXP 63
5106: PPUSH
5107: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
5111: LD_EXP 63
5115: PPUSH
5116: CALL_OW 257
5120: PUSH
5121: LD_INT 2
5123: NONEQUAL
5124: IFFALSE 5159
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
5126: LD_EXP 63
5130: PPUSH
5131: LD_INT 324
5133: PPUSH
5134: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
5138: LD_EXP 63
5142: PPUSH
5143: LD_INT 2
5145: PPUSH
5146: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
5150: LD_EXP 63
5154: PPUSH
5155: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
5159: LD_EXP 63
5163: PPUSH
5164: LD_INT 2
5166: PPUSH
5167: LD_INT 93
5169: PPUSH
5170: LD_INT 32
5172: PPUSH
5173: LD_INT 3
5175: PPUSH
5176: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5180: LD_INT 35
5182: PPUSH
5183: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
5187: LD_INT 22
5189: PUSH
5190: LD_INT 8
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: PUSH
5197: LD_INT 30
5199: PUSH
5200: LD_INT 3
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: PUSH
5207: LD_INT 23
5209: PUSH
5210: LD_INT 3
5212: PUSH
5213: EMPTY
5214: LIST
5215: LIST
5216: PUSH
5217: LD_INT 57
5219: PUSH
5220: EMPTY
5221: LIST
5222: PUSH
5223: EMPTY
5224: LIST
5225: LIST
5226: LIST
5227: LIST
5228: PPUSH
5229: CALL_OW 69
5233: IFFALSE 5180
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5235: LD_ADDR_VAR 0 2
5239: PUSH
5240: LD_INT 22
5242: PUSH
5243: LD_INT 8
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: LD_INT 30
5252: PUSH
5253: LD_INT 3
5255: PUSH
5256: EMPTY
5257: LIST
5258: LIST
5259: PUSH
5260: LD_INT 23
5262: PUSH
5263: LD_INT 3
5265: PUSH
5266: EMPTY
5267: LIST
5268: LIST
5269: PUSH
5270: LD_INT 57
5272: PUSH
5273: EMPTY
5274: LIST
5275: PUSH
5276: EMPTY
5277: LIST
5278: LIST
5279: LIST
5280: LIST
5281: PPUSH
5282: CALL_OW 69
5286: PUSH
5287: LD_INT 1
5289: ARRAY
5290: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5291: LD_INT 22
5293: PUSH
5294: LD_INT 8
5296: PUSH
5297: EMPTY
5298: LIST
5299: LIST
5300: PUSH
5301: LD_INT 23
5303: PUSH
5304: LD_INT 3
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: PUSH
5311: LD_INT 30
5313: PUSH
5314: LD_INT 21
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: PUSH
5321: EMPTY
5322: LIST
5323: LIST
5324: LIST
5325: PPUSH
5326: CALL_OW 69
5330: NOT
5331: IFFALSE 5409
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5333: LD_EXP 63
5337: PPUSH
5338: LD_INT 21
5340: PPUSH
5341: LD_INT 97
5343: PPUSH
5344: LD_INT 36
5346: PPUSH
5347: LD_INT 5
5349: PPUSH
5350: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5354: LD_INT 35
5356: PPUSH
5357: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5361: LD_INT 22
5363: PUSH
5364: LD_INT 8
5366: PUSH
5367: EMPTY
5368: LIST
5369: LIST
5370: PUSH
5371: LD_INT 23
5373: PUSH
5374: LD_INT 3
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: PUSH
5381: LD_INT 30
5383: PUSH
5384: LD_INT 21
5386: PUSH
5387: EMPTY
5388: LIST
5389: LIST
5390: PUSH
5391: LD_INT 57
5393: PUSH
5394: EMPTY
5395: LIST
5396: PUSH
5397: EMPTY
5398: LIST
5399: LIST
5400: LIST
5401: LIST
5402: PPUSH
5403: CALL_OW 69
5407: IFFALSE 5354
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5409: LD_INT 22
5411: PUSH
5412: LD_INT 8
5414: PUSH
5415: EMPTY
5416: LIST
5417: LIST
5418: PUSH
5419: LD_INT 23
5421: PUSH
5422: LD_INT 3
5424: PUSH
5425: EMPTY
5426: LIST
5427: LIST
5428: PUSH
5429: LD_INT 30
5431: PUSH
5432: LD_INT 18
5434: PUSH
5435: EMPTY
5436: LIST
5437: LIST
5438: PUSH
5439: EMPTY
5440: LIST
5441: LIST
5442: LIST
5443: PPUSH
5444: CALL_OW 69
5448: NOT
5449: IFFALSE 5527
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5451: LD_EXP 63
5455: PPUSH
5456: LD_INT 18
5458: PPUSH
5459: LD_INT 89
5461: PPUSH
5462: LD_INT 32
5464: PPUSH
5465: LD_INT 1
5467: PPUSH
5468: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5472: LD_INT 35
5474: PPUSH
5475: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5479: LD_INT 22
5481: PUSH
5482: LD_INT 8
5484: PUSH
5485: EMPTY
5486: LIST
5487: LIST
5488: PUSH
5489: LD_INT 23
5491: PUSH
5492: LD_INT 3
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: PUSH
5499: LD_INT 30
5501: PUSH
5502: LD_INT 18
5504: PUSH
5505: EMPTY
5506: LIST
5507: LIST
5508: PUSH
5509: LD_INT 57
5511: PUSH
5512: EMPTY
5513: LIST
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: LIST
5519: LIST
5520: PPUSH
5521: CALL_OW 69
5525: IFFALSE 5472
// end ; lab := kozlov_lab ;
5527: LD_ADDR_VAR 0 3
5531: PUSH
5532: LD_INT 336
5534: ST_TO_ADDR
// if not lab then
5535: LD_VAR 0 3
5539: NOT
5540: IFFALSE 5544
// exit ;
5542: GO 5669
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5544: LD_EXP 63
5548: PPUSH
5549: LD_VAR 0 3
5553: PUSH
5554: LD_INT 1
5556: ARRAY
5557: PPUSH
5558: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5562: LD_EXP 63
5566: PPUSH
5567: LD_INT 4
5569: PPUSH
5570: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5574: LD_VAR 0 3
5578: PUSH
5579: LD_INT 1
5581: ARRAY
5582: PPUSH
5583: LD_INT 25
5585: PPUSH
5586: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5590: LD_INT 35
5592: PPUSH
5593: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5597: LD_INT 25
5599: PPUSH
5600: LD_INT 8
5602: PPUSH
5603: CALL_OW 321
5607: PUSH
5608: LD_INT 2
5610: EQUAL
5611: IFFALSE 5590
// ComExitBuilding ( Kozlov ) ;
5613: LD_EXP 63
5617: PPUSH
5618: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5622: LD_EXP 63
5626: PPUSH
5627: LD_VAR 0 2
5631: PPUSH
5632: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5636: LD_EXP 63
5640: PPUSH
5641: LD_INT 3
5643: PPUSH
5644: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5648: LD_VAR 0 2
5652: PPUSH
5653: LD_INT 23
5655: PPUSH
5656: LD_INT 3
5658: PPUSH
5659: LD_INT 1
5661: PPUSH
5662: LD_INT 48
5664: PPUSH
5665: CALL_OW 125
// end ;
5669: LD_VAR 0 1
5673: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5674: LD_EXP 22
5678: NOT
5679: PUSH
5680: LD_EXP 15
5684: PUSH
5685: LD_INT 6
5687: GREATEREQUAL
5688: AND
5689: IFFALSE 5770
5691: GO 5693
5693: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5694: LD_INT 3
5696: PPUSH
5697: LD_INT 3
5699: PPUSH
5700: CALL 62609 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5704: LD_INT 3
5706: PPUSH
5707: LD_INT 14
5709: PUSH
5710: LD_INT 1
5712: PUSH
5713: LD_INT 1
5715: PUSH
5716: LD_INT 28
5718: PUSH
5719: EMPTY
5720: LIST
5721: LIST
5722: LIST
5723: LIST
5724: PUSH
5725: LD_INT 14
5727: PUSH
5728: LD_INT 1
5730: PUSH
5731: LD_INT 1
5733: PUSH
5734: LD_INT 28
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: LIST
5741: LIST
5742: PUSH
5743: LD_INT 14
5745: PUSH
5746: LD_INT 1
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: LD_INT 28
5754: PUSH
5755: EMPTY
5756: LIST
5757: LIST
5758: LIST
5759: LIST
5760: PUSH
5761: EMPTY
5762: LIST
5763: LIST
5764: LIST
5765: PPUSH
5766: CALL 62472 0 2
// end ;
5770: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5771: LD_EXP 22
5775: NOT
5776: PUSH
5777: LD_EXP 15
5781: PUSH
5782: LD_INT 6
5784: GREATEREQUAL
5785: AND
5786: PUSH
5787: LD_INT 3
5789: PPUSH
5790: LD_INT 1
5792: PPUSH
5793: CALL 63890 0 2
5797: NOT
5798: AND
5799: IFFALSE 6673
5801: GO 5803
5803: DISABLE
5804: LD_INT 0
5806: PPUSH
5807: PPUSH
5808: PPUSH
// begin enable ;
5809: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5810: LD_INT 22
5812: PUSH
5813: LD_INT 8
5815: PUSH
5816: EMPTY
5817: LIST
5818: LIST
5819: PUSH
5820: LD_INT 23
5822: PUSH
5823: LD_INT 2
5825: PUSH
5826: EMPTY
5827: LIST
5828: LIST
5829: PUSH
5830: LD_INT 30
5832: PUSH
5833: LD_INT 3
5835: PUSH
5836: EMPTY
5837: LIST
5838: LIST
5839: PUSH
5840: EMPTY
5841: LIST
5842: LIST
5843: LIST
5844: PPUSH
5845: CALL_OW 69
5849: NOT
5850: IFFALSE 5854
// exit ;
5852: GO 6673
// if Prob ( 40 ) then
5854: LD_INT 40
5856: PPUSH
5857: CALL_OW 13
5861: IFFALSE 5988
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5863: LD_INT 3
5865: PPUSH
5866: LD_INT 14
5868: PUSH
5869: LD_INT 1
5871: PUSH
5872: LD_INT 2
5874: PUSH
5875: LD_INT 28
5877: PUSH
5878: EMPTY
5879: LIST
5880: LIST
5881: LIST
5882: LIST
5883: PUSH
5884: LD_INT 14
5886: PUSH
5887: LD_INT 1
5889: PUSH
5890: LD_INT 2
5892: PUSH
5893: LD_INT 28
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: PUSH
5902: LD_INT 14
5904: PUSH
5905: LD_INT 1
5907: PUSH
5908: LD_INT 2
5910: PUSH
5911: LD_INT 28
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: LIST
5918: LIST
5919: PUSH
5920: LD_INT 14
5922: PUSH
5923: LD_INT 1
5925: PUSH
5926: LD_INT 2
5928: PUSH
5929: LD_INT 28
5931: PUSH
5932: EMPTY
5933: LIST
5934: LIST
5935: LIST
5936: LIST
5937: PUSH
5938: LD_INT 14
5940: PUSH
5941: LD_INT 1
5943: PUSH
5944: LD_INT 2
5946: PUSH
5947: LD_INT 28
5949: PUSH
5950: EMPTY
5951: LIST
5952: LIST
5953: LIST
5954: LIST
5955: PUSH
5956: LD_INT 14
5958: PUSH
5959: LD_INT 1
5961: PUSH
5962: LD_INT 2
5964: PUSH
5965: LD_INT 26
5967: PUSH
5968: EMPTY
5969: LIST
5970: LIST
5971: LIST
5972: LIST
5973: PUSH
5974: EMPTY
5975: LIST
5976: LIST
5977: LIST
5978: LIST
5979: LIST
5980: LIST
5981: PPUSH
5982: CALL 62472 0 2
// end else
5986: GO 6195
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5988: LD_INT 3
5990: PPUSH
5991: LD_INT 14
5993: PUSH
5994: LD_INT 1
5996: PUSH
5997: LD_INT 2
5999: PUSH
6000: LD_INT 27
6002: PUSH
6003: LD_INT 26
6005: PUSH
6006: LD_INT 26
6008: PUSH
6009: LD_INT 28
6011: PUSH
6012: EMPTY
6013: LIST
6014: LIST
6015: LIST
6016: LIST
6017: PUSH
6018: LD_OWVAR 67
6022: ARRAY
6023: PUSH
6024: EMPTY
6025: LIST
6026: LIST
6027: LIST
6028: LIST
6029: PUSH
6030: LD_INT 14
6032: PUSH
6033: LD_INT 1
6035: PUSH
6036: LD_INT 2
6038: PUSH
6039: LD_INT 27
6041: PUSH
6042: LD_INT 26
6044: PUSH
6045: LD_INT 26
6047: PUSH
6048: LD_INT 26
6050: PUSH
6051: EMPTY
6052: LIST
6053: LIST
6054: LIST
6055: LIST
6056: PUSH
6057: LD_OWVAR 67
6061: ARRAY
6062: PUSH
6063: EMPTY
6064: LIST
6065: LIST
6066: LIST
6067: LIST
6068: PUSH
6069: LD_INT 14
6071: PUSH
6072: LD_INT 1
6074: PUSH
6075: LD_INT 2
6077: PUSH
6078: LD_INT 26
6080: PUSH
6081: LD_INT 26
6083: PUSH
6084: LD_INT 29
6086: PUSH
6087: LD_INT 29
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: LIST
6094: LIST
6095: PUSH
6096: LD_OWVAR 67
6100: ARRAY
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: LIST
6106: LIST
6107: PUSH
6108: LD_INT 13
6110: PUSH
6111: LD_INT 1
6113: PUSH
6114: LD_INT 2
6116: PUSH
6117: LD_INT 26
6119: PUSH
6120: LD_INT 29
6122: PUSH
6123: LD_INT 29
6125: PUSH
6126: LD_INT 29
6128: PUSH
6129: EMPTY
6130: LIST
6131: LIST
6132: LIST
6133: LIST
6134: PUSH
6135: LD_OWVAR 67
6139: ARRAY
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: LIST
6145: LIST
6146: PUSH
6147: LD_INT 13
6149: PUSH
6150: LD_INT 1
6152: PUSH
6153: LD_INT 2
6155: PUSH
6156: LD_INT 29
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: LIST
6163: LIST
6164: PUSH
6165: LD_INT 14
6167: PUSH
6168: LD_INT 1
6170: PUSH
6171: LD_INT 2
6173: PUSH
6174: LD_INT 26
6176: PUSH
6177: EMPTY
6178: LIST
6179: LIST
6180: LIST
6181: LIST
6182: PUSH
6183: EMPTY
6184: LIST
6185: LIST
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: PPUSH
6191: CALL 62472 0 2
// end ; repeat wait ( 0 0$1 ) ;
6195: LD_INT 35
6197: PPUSH
6198: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6202: LD_INT 3
6204: PPUSH
6205: LD_INT 1
6207: PPUSH
6208: CALL 63890 0 2
6212: PUSH
6213: LD_INT 6
6215: GREATEREQUAL
6216: IFFALSE 6195
// wait ( 0 0$30 ) ;
6218: LD_INT 1050
6220: PPUSH
6221: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6225: LD_ADDR_VAR 0 2
6229: PUSH
6230: LD_INT 3
6232: PPUSH
6233: LD_INT 1
6235: PPUSH
6236: CALL 63890 0 2
6240: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6241: LD_ADDR_EXP 119
6245: PUSH
6246: LD_EXP 119
6250: PPUSH
6251: LD_INT 3
6253: PPUSH
6254: LD_EXP 119
6258: PUSH
6259: LD_INT 3
6261: ARRAY
6262: PUSH
6263: LD_VAR 0 2
6267: DIFF
6268: PPUSH
6269: CALL_OW 1
6273: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6274: LD_ADDR_VAR 0 3
6278: PUSH
6279: LD_INT 0
6281: PPUSH
6282: LD_INT 2
6284: PPUSH
6285: CALL_OW 12
6289: ST_TO_ADDR
// if target then
6290: LD_VAR 0 3
6294: IFFALSE 6431
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6296: LD_ADDR_VAR 0 2
6300: PUSH
6301: LD_VAR 0 2
6305: PPUSH
6306: LD_INT 24
6308: PUSH
6309: LD_INT 250
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: PPUSH
6316: CALL_OW 72
6320: ST_TO_ADDR
// if not tmp then
6321: LD_VAR 0 2
6325: NOT
6326: IFFALSE 6330
// break ;
6328: GO 6429
// for i in tmp do
6330: LD_ADDR_VAR 0 1
6334: PUSH
6335: LD_VAR 0 2
6339: PUSH
6340: FOR_IN
6341: IFFALSE 6381
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6343: LD_VAR 0 1
6347: PPUSH
6348: LD_INT 89
6350: PPUSH
6351: LD_INT 71
6353: PPUSH
6354: CALL_OW 297
6358: PUSH
6359: LD_INT 9
6361: GREATER
6362: IFFALSE 6379
// ComMoveXY ( i , 89 , 71 ) ;
6364: LD_VAR 0 1
6368: PPUSH
6369: LD_INT 89
6371: PPUSH
6372: LD_INT 71
6374: PPUSH
6375: CALL_OW 111
6379: GO 6340
6381: POP
6382: POP
// wait ( 0 0$1 ) ;
6383: LD_INT 35
6385: PPUSH
6386: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6390: LD_VAR 0 2
6394: PPUSH
6395: LD_INT 92
6397: PUSH
6398: LD_INT 89
6400: PUSH
6401: LD_INT 71
6403: PUSH
6404: LD_INT 9
6406: PUSH
6407: EMPTY
6408: LIST
6409: LIST
6410: LIST
6411: LIST
6412: PPUSH
6413: CALL_OW 72
6417: PUSH
6418: LD_VAR 0 2
6422: PUSH
6423: LD_INT 1
6425: MINUS
6426: GREATEREQUAL
6427: IFFALSE 6296
// end else
6429: GO 6564
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6431: LD_ADDR_VAR 0 2
6435: PUSH
6436: LD_VAR 0 2
6440: PPUSH
6441: LD_INT 24
6443: PUSH
6444: LD_INT 250
6446: PUSH
6447: EMPTY
6448: LIST
6449: LIST
6450: PPUSH
6451: CALL_OW 72
6455: ST_TO_ADDR
// if not tmp then
6456: LD_VAR 0 2
6460: NOT
6461: IFFALSE 6465
// break ;
6463: GO 6564
// for i in tmp do
6465: LD_ADDR_VAR 0 1
6469: PUSH
6470: LD_VAR 0 2
6474: PUSH
6475: FOR_IN
6476: IFFALSE 6516
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6478: LD_VAR 0 1
6482: PPUSH
6483: LD_INT 125
6485: PPUSH
6486: LD_INT 129
6488: PPUSH
6489: CALL_OW 297
6493: PUSH
6494: LD_INT 9
6496: GREATER
6497: IFFALSE 6514
// ComMoveXY ( i , 125 , 129 ) ;
6499: LD_VAR 0 1
6503: PPUSH
6504: LD_INT 125
6506: PPUSH
6507: LD_INT 129
6509: PPUSH
6510: CALL_OW 111
6514: GO 6475
6516: POP
6517: POP
// wait ( 0 0$1 ) ;
6518: LD_INT 35
6520: PPUSH
6521: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6525: LD_VAR 0 2
6529: PPUSH
6530: LD_INT 92
6532: PUSH
6533: LD_INT 125
6535: PUSH
6536: LD_INT 129
6538: PUSH
6539: LD_INT 9
6541: PUSH
6542: EMPTY
6543: LIST
6544: LIST
6545: LIST
6546: LIST
6547: PPUSH
6548: CALL_OW 72
6552: PUSH
6553: LD_VAR 0 2
6557: PUSH
6558: LD_INT 1
6560: MINUS
6561: GREATEREQUAL
6562: IFFALSE 6431
// end ; repeat wait ( 0 0$1 ) ;
6564: LD_INT 35
6566: PPUSH
6567: CALL_OW 67
// for i in tmp do
6571: LD_ADDR_VAR 0 1
6575: PUSH
6576: LD_VAR 0 2
6580: PUSH
6581: FOR_IN
6582: IFFALSE 6664
// begin if GetLives ( i ) > 251 then
6584: LD_VAR 0 1
6588: PPUSH
6589: CALL_OW 256
6593: PUSH
6594: LD_INT 251
6596: GREATER
6597: IFFALSE 6635
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6599: LD_VAR 0 1
6603: PPUSH
6604: LD_INT 81
6606: PUSH
6607: LD_INT 8
6609: PUSH
6610: EMPTY
6611: LIST
6612: LIST
6613: PPUSH
6614: CALL_OW 69
6618: PPUSH
6619: LD_VAR 0 1
6623: PPUSH
6624: CALL_OW 74
6628: PPUSH
6629: CALL_OW 115
6633: GO 6662
// if IsDead ( i ) then
6635: LD_VAR 0 1
6639: PPUSH
6640: CALL_OW 301
6644: IFFALSE 6662
// tmp := tmp diff i ;
6646: LD_ADDR_VAR 0 2
6650: PUSH
6651: LD_VAR 0 2
6655: PUSH
6656: LD_VAR 0 1
6660: DIFF
6661: ST_TO_ADDR
// end ;
6662: GO 6581
6664: POP
6665: POP
// until not tmp ;
6666: LD_VAR 0 2
6670: NOT
6671: IFFALSE 6564
// end ;
6673: PPOPN 3
6675: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6676: LD_EXP 22
6680: NOT
6681: PUSH
6682: LD_EXP 15
6686: PUSH
6687: LD_INT 6
6689: GREATEREQUAL
6690: AND
6691: PUSH
6692: LD_OWVAR 67
6696: PUSH
6697: LD_INT 1
6699: GREATER
6700: AND
6701: IFFALSE 7234
6703: GO 6705
6705: DISABLE
6706: LD_INT 0
6708: PPUSH
6709: PPUSH
6710: PPUSH
// begin enable ;
6711: ENABLE
// tmp := [ ] ;
6712: LD_ADDR_VAR 0 3
6716: PUSH
6717: EMPTY
6718: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6719: LD_ADDR_VAR 0 1
6723: PUSH
6724: DOUBLE
6725: LD_INT 1
6727: DEC
6728: ST_TO_ADDR
6729: LD_INT 4
6731: PUSH
6732: LD_INT 6
6734: PUSH
6735: LD_INT 7
6737: PUSH
6738: LD_INT 8
6740: PUSH
6741: EMPTY
6742: LIST
6743: LIST
6744: LIST
6745: LIST
6746: PUSH
6747: LD_OWVAR 67
6751: ARRAY
6752: PUSH
6753: FOR_TO
6754: IFFALSE 6914
// begin uc_side := 8 ;
6756: LD_ADDR_OWVAR 20
6760: PUSH
6761: LD_INT 8
6763: ST_TO_ADDR
// uc_nation := 2 ;
6764: LD_ADDR_OWVAR 21
6768: PUSH
6769: LD_INT 2
6771: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6772: LD_INT 13
6774: PUSH
6775: LD_INT 14
6777: PUSH
6778: EMPTY
6779: LIST
6780: LIST
6781: PUSH
6782: LD_INT 1
6784: PPUSH
6785: LD_INT 2
6787: PPUSH
6788: CALL_OW 12
6792: ARRAY
6793: PPUSH
6794: LD_INT 1
6796: PPUSH
6797: LD_INT 5
6799: PPUSH
6800: LD_INT 27
6802: PUSH
6803: LD_INT 28
6805: PUSH
6806: LD_INT 26
6808: PUSH
6809: LD_INT 25
6811: PUSH
6812: EMPTY
6813: LIST
6814: LIST
6815: LIST
6816: LIST
6817: PUSH
6818: LD_INT 1
6820: PPUSH
6821: LD_INT 4
6823: PPUSH
6824: CALL_OW 12
6828: ARRAY
6829: PPUSH
6830: LD_INT 88
6832: PPUSH
6833: CALL 73738 0 5
// un := CreateVehicle ;
6837: LD_ADDR_VAR 0 2
6841: PUSH
6842: CALL_OW 45
6846: ST_TO_ADDR
// tmp := tmp ^ un ;
6847: LD_ADDR_VAR 0 3
6851: PUSH
6852: LD_VAR 0 3
6856: PUSH
6857: LD_VAR 0 2
6861: ADD
6862: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6863: LD_VAR 0 2
6867: PPUSH
6868: LD_INT 3
6870: PPUSH
6871: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6875: LD_VAR 0 2
6879: PPUSH
6880: LD_INT 30
6882: PPUSH
6883: LD_INT 0
6885: PPUSH
6886: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6890: LD_VAR 0 2
6894: PPUSH
6895: LD_INT 16
6897: PPUSH
6898: LD_INT 11
6900: PPUSH
6901: CALL_OW 111
// wait ( 0 0$2 ) ;
6905: LD_INT 70
6907: PPUSH
6908: CALL_OW 67
// end ;
6912: GO 6753
6914: POP
6915: POP
// for i = 1 to Difficulty do
6916: LD_ADDR_VAR 0 1
6920: PUSH
6921: DOUBLE
6922: LD_INT 1
6924: DEC
6925: ST_TO_ADDR
6926: LD_OWVAR 67
6930: PUSH
6931: FOR_TO
6932: IFFALSE 7061
// begin uc_side := 8 ;
6934: LD_ADDR_OWVAR 20
6938: PUSH
6939: LD_INT 8
6941: ST_TO_ADDR
// uc_nation := 2 ;
6942: LD_ADDR_OWVAR 21
6946: PUSH
6947: LD_INT 2
6949: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6950: LD_INT 0
6952: PPUSH
6953: LD_INT 8
6955: PPUSH
6956: LD_INT 8
6958: PUSH
6959: LD_INT 8
6961: PUSH
6962: LD_INT 9
6964: PUSH
6965: LD_INT 10
6967: PUSH
6968: EMPTY
6969: LIST
6970: LIST
6971: LIST
6972: LIST
6973: PUSH
6974: LD_OWVAR 67
6978: ARRAY
6979: PPUSH
6980: CALL_OW 380
// un := CreateHuman ;
6984: LD_ADDR_VAR 0 2
6988: PUSH
6989: CALL_OW 44
6993: ST_TO_ADDR
// tmp := tmp ^ un ;
6994: LD_ADDR_VAR 0 3
6998: PUSH
6999: LD_VAR 0 3
7003: PUSH
7004: LD_VAR 0 2
7008: ADD
7009: ST_TO_ADDR
// SetDir ( un , 3 ) ;
7010: LD_VAR 0 2
7014: PPUSH
7015: LD_INT 3
7017: PPUSH
7018: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
7022: LD_VAR 0 2
7026: PPUSH
7027: LD_INT 30
7029: PPUSH
7030: LD_INT 0
7032: PPUSH
7033: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
7037: LD_VAR 0 2
7041: PPUSH
7042: LD_INT 16
7044: PPUSH
7045: LD_INT 11
7047: PPUSH
7048: CALL_OW 111
// wait ( 0 0$2 ) ;
7052: LD_INT 70
7054: PPUSH
7055: CALL_OW 67
// end ;
7059: GO 6931
7061: POP
7062: POP
// repeat wait ( 0 0$1 ) ;
7063: LD_INT 35
7065: PPUSH
7066: CALL_OW 67
// if legionDestroyed then
7070: LD_EXP 22
7074: IFFALSE 7078
// exit ;
7076: GO 7234
// for i in tmp do
7078: LD_ADDR_VAR 0 1
7082: PUSH
7083: LD_VAR 0 3
7087: PUSH
7088: FOR_IN
7089: IFFALSE 7225
// begin if GetLives ( i ) > 250 then
7091: LD_VAR 0 1
7095: PPUSH
7096: CALL_OW 256
7100: PUSH
7101: LD_INT 250
7103: GREATER
7104: IFFALSE 7196
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
7106: LD_INT 81
7108: PUSH
7109: LD_INT 8
7111: PUSH
7112: EMPTY
7113: LIST
7114: LIST
7115: PUSH
7116: LD_INT 91
7118: PUSH
7119: LD_VAR 0 1
7123: PUSH
7124: LD_INT 10
7126: PUSH
7127: EMPTY
7128: LIST
7129: LIST
7130: LIST
7131: PUSH
7132: EMPTY
7133: LIST
7134: LIST
7135: PPUSH
7136: CALL_OW 69
7140: NOT
7141: IFFALSE 7160
// ComAgressiveMove ( i , 67 , 110 ) else
7143: LD_VAR 0 1
7147: PPUSH
7148: LD_INT 67
7150: PPUSH
7151: LD_INT 110
7153: PPUSH
7154: CALL_OW 114
7158: GO 7194
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
7160: LD_VAR 0 1
7164: PPUSH
7165: LD_INT 81
7167: PUSH
7168: LD_INT 8
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: PPUSH
7175: CALL_OW 69
7179: PPUSH
7180: LD_VAR 0 1
7184: PPUSH
7185: CALL_OW 74
7189: PPUSH
7190: CALL_OW 115
// end else
7194: GO 7223
// if IsDead ( i ) then
7196: LD_VAR 0 1
7200: PPUSH
7201: CALL_OW 301
7205: IFFALSE 7223
// tmp := tmp diff i ;
7207: LD_ADDR_VAR 0 3
7211: PUSH
7212: LD_VAR 0 3
7216: PUSH
7217: LD_VAR 0 1
7221: DIFF
7222: ST_TO_ADDR
// end ;
7223: GO 7088
7225: POP
7226: POP
// until not tmp ;
7227: LD_VAR 0 3
7231: NOT
7232: IFFALSE 7063
// end ; end_of_file
7234: PPOPN 3
7236: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , un , b , teleport ; begin
7237: LD_INT 0
7239: PPUSH
7240: PPUSH
7241: PPUSH
7242: PPUSH
7243: PPUSH
7244: PPUSH
7245: PPUSH
7246: PPUSH
7247: PPUSH
7248: PPUSH
// side := 3 ;
7249: LD_ADDR_VAR 0 6
7253: PUSH
7254: LD_INT 3
7256: ST_TO_ADDR
// uc_side := side ;
7257: LD_ADDR_OWVAR 20
7261: PUSH
7262: LD_VAR 0 6
7266: ST_TO_ADDR
// uc_nation := 3 ;
7267: LD_ADDR_OWVAR 21
7271: PUSH
7272: LD_INT 3
7274: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7275: LD_ADDR_VAR 0 2
7279: PUSH
7280: LD_INT 22
7282: PUSH
7283: LD_VAR 0 6
7287: PUSH
7288: EMPTY
7289: LIST
7290: LIST
7291: PUSH
7292: LD_INT 21
7294: PUSH
7295: LD_INT 3
7297: PUSH
7298: EMPTY
7299: LIST
7300: LIST
7301: PUSH
7302: EMPTY
7303: LIST
7304: LIST
7305: PPUSH
7306: CALL_OW 69
7310: PUSH
7311: FOR_IN
7312: IFFALSE 7328
// SetBLevel ( i , 10 ) ;
7314: LD_VAR 0 2
7318: PPUSH
7319: LD_INT 10
7321: PPUSH
7322: CALL_OW 241
7326: GO 7311
7328: POP
7329: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7330: LD_ADDR_VAR 0 10
7334: PUSH
7335: LD_INT 22
7337: PUSH
7338: LD_VAR 0 6
7342: PUSH
7343: EMPTY
7344: LIST
7345: LIST
7346: PUSH
7347: LD_INT 30
7349: PUSH
7350: LD_INT 34
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: PUSH
7357: EMPTY
7358: LIST
7359: LIST
7360: PPUSH
7361: CALL_OW 69
7365: ST_TO_ADDR
// if teleport then
7366: LD_VAR 0 10
7370: IFFALSE 7391
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7372: LD_VAR 0 10
7376: PUSH
7377: LD_INT 1
7379: ARRAY
7380: PPUSH
7381: LD_INT 123
7383: PPUSH
7384: LD_INT 122
7386: PPUSH
7387: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7391: LD_ADDR_EXP 66
7395: PUSH
7396: LD_STRING Platonov
7398: PPUSH
7399: CALL_OW 25
7403: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7404: LD_ADDR_EXP 67
7408: PUSH
7409: LD_STRING Kovalyuk
7411: PPUSH
7412: CALL_OW 25
7416: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7417: LD_ADDR_EXP 69
7421: PUSH
7422: LD_STRING Yakotich
7424: PPUSH
7425: LD_EXP 1
7429: NOT
7430: PPUSH
7431: LD_STRING 09_
7433: PPUSH
7434: CALL 68898 0 3
7438: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7439: LD_ADDR_EXP 68
7443: PUSH
7444: LD_STRING Bystrov
7446: PPUSH
7447: CALL_OW 25
7451: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7452: LD_ADDR_EXP 70
7456: PUSH
7457: LD_STRING Gleb
7459: PPUSH
7460: CALL_OW 25
7464: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7465: LD_STRING 03_Cornel
7467: PPUSH
7468: CALL_OW 28
7472: IFFALSE 7520
// begin Bierezov := NewCharacter ( Mikhail ) ;
7474: LD_ADDR_EXP 71
7478: PUSH
7479: LD_STRING Mikhail
7481: PPUSH
7482: CALL_OW 25
7486: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7487: LD_EXP 71
7491: PPUSH
7492: LD_INT 197
7494: PPUSH
7495: LD_INT 111
7497: PPUSH
7498: LD_INT 9
7500: PPUSH
7501: LD_INT 0
7503: PPUSH
7504: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7508: LD_EXP 71
7512: PPUSH
7513: LD_INT 3
7515: PPUSH
7516: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7520: LD_EXP 66
7524: PPUSH
7525: LD_INT 126
7527: PPUSH
7528: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7532: LD_EXP 67
7536: PPUSH
7537: LD_INT 134
7539: PPUSH
7540: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7544: LD_EXP 69
7548: PPUSH
7549: LD_INT 197
7551: PPUSH
7552: LD_INT 111
7554: PPUSH
7555: LD_INT 9
7557: PPUSH
7558: LD_INT 0
7560: PPUSH
7561: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7565: LD_EXP 68
7569: PPUSH
7570: LD_INT 197
7572: PPUSH
7573: LD_INT 111
7575: PPUSH
7576: LD_INT 9
7578: PPUSH
7579: LD_INT 0
7581: PPUSH
7582: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7586: LD_EXP 70
7590: PPUSH
7591: LD_INT 197
7593: PPUSH
7594: LD_INT 111
7596: PPUSH
7597: LD_INT 9
7599: PPUSH
7600: LD_INT 0
7602: PPUSH
7603: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7607: LD_ADDR_VAR 0 5
7611: PUSH
7612: LD_INT 126
7614: PPUSH
7615: LD_INT 4
7617: PPUSH
7618: LD_STRING zhukov
7620: PPUSH
7621: LD_INT 9
7623: PUSH
7624: LD_INT 10
7626: PUSH
7627: LD_INT 10
7629: PUSH
7630: LD_INT 10
7632: PUSH
7633: EMPTY
7634: LIST
7635: LIST
7636: LIST
7637: LIST
7638: PUSH
7639: LD_OWVAR 67
7643: ARRAY
7644: PPUSH
7645: LD_INT 90000
7647: PUSH
7648: LD_INT 1000
7650: PUSH
7651: LD_INT 300
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: LIST
7658: PPUSH
7659: LD_INT 18
7661: PUSH
7662: LD_INT 8
7664: PUSH
7665: LD_INT 13
7667: PUSH
7668: LD_INT 8
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: LIST
7675: LIST
7676: PPUSH
7677: CALL 77182 0 6
7681: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , tmp union [ Yakotich , Bystrov , Gleb , Bierezov ] ) ;
7682: LD_ADDR_EXP 100
7686: PUSH
7687: LD_EXP 100
7691: PPUSH
7692: LD_INT 2
7694: PPUSH
7695: LD_VAR 0 5
7699: PUSH
7700: LD_EXP 69
7704: PUSH
7705: LD_EXP 68
7709: PUSH
7710: LD_EXP 70
7714: PUSH
7715: LD_EXP 71
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: LIST
7724: LIST
7725: UNION
7726: PPUSH
7727: CALL_OW 1
7731: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7732: LD_ADDR_VAR 0 4
7736: PUSH
7737: LD_INT 267
7739: PPUSH
7740: CALL_OW 274
7744: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7745: LD_VAR 0 4
7749: PPUSH
7750: LD_INT 1
7752: PPUSH
7753: LD_INT 5000
7755: PPUSH
7756: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7760: LD_VAR 0 4
7764: PPUSH
7765: LD_INT 2
7767: PPUSH
7768: LD_INT 200
7770: PPUSH
7771: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7775: LD_VAR 0 4
7779: PPUSH
7780: LD_INT 3
7782: PPUSH
7783: LD_INT 200
7785: PPUSH
7786: CALL_OW 277
// for i := 1 to 6 do
7790: LD_ADDR_VAR 0 2
7794: PUSH
7795: DOUBLE
7796: LD_INT 1
7798: DEC
7799: ST_TO_ADDR
7800: LD_INT 6
7802: PUSH
7803: FOR_TO
7804: IFFALSE 7887
// begin PrepareSoldier ( false , [ 8 , 9 , 10 , 10 ] [ Difficulty ] ) ;
7806: LD_INT 0
7808: PPUSH
7809: LD_INT 8
7811: PUSH
7812: LD_INT 9
7814: PUSH
7815: LD_INT 10
7817: PUSH
7818: LD_INT 10
7820: PUSH
7821: EMPTY
7822: LIST
7823: LIST
7824: LIST
7825: LIST
7826: PUSH
7827: LD_OWVAR 67
7831: ARRAY
7832: PPUSH
7833: CALL_OW 381
// un := CreateHuman ;
7837: LD_ADDR_VAR 0 8
7841: PUSH
7842: CALL_OW 44
7846: ST_TO_ADDR
// if i mod 2 = 0 then
7847: LD_VAR 0 2
7851: PUSH
7852: LD_INT 2
7854: MOD
7855: PUSH
7856: LD_INT 0
7858: EQUAL
7859: IFFALSE 7873
// SetClass ( un , class_bazooker ) ;
7861: LD_VAR 0 8
7865: PPUSH
7866: LD_INT 9
7868: PPUSH
7869: CALL_OW 336
// PlaceHumanInUnit ( un , ru_specBar ) ;
7873: LD_VAR 0 8
7877: PPUSH
7878: LD_INT 460
7880: PPUSH
7881: CALL_OW 52
// end ;
7885: GO 7803
7887: POP
7888: POP
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_crane , 100 ) ;
7889: LD_INT 21
7891: PPUSH
7892: LD_INT 3
7894: PPUSH
7895: LD_INT 3
7897: PPUSH
7898: LD_INT 52
7900: PPUSH
7901: LD_INT 100
7903: PPUSH
7904: CALL 73738 0 5
// PlaceUnitXYD ( CreateVehicle , 259 , 145 , 3 , false ) ;
7908: CALL_OW 45
7912: PPUSH
7913: LD_INT 259
7915: PPUSH
7916: LD_INT 145
7918: PPUSH
7919: LD_INT 3
7921: PPUSH
7922: LD_INT 0
7924: PPUSH
7925: CALL 108330 0 5
// PlaceUnitXYD ( CreateVehicle , 245 , 139 , 3 , false ) ;
7929: CALL_OW 45
7933: PPUSH
7934: LD_INT 245
7936: PPUSH
7937: LD_INT 139
7939: PPUSH
7940: LD_INT 3
7942: PPUSH
7943: LD_INT 0
7945: PPUSH
7946: CALL 108330 0 5
// behemoths := [ ] ;
7950: LD_ADDR_EXP 74
7954: PUSH
7955: EMPTY
7956: ST_TO_ADDR
// behemothBuilders := [ ] ;
7957: LD_ADDR_EXP 75
7961: PUSH
7962: EMPTY
7963: ST_TO_ADDR
// if Kovalyuk then
7964: LD_EXP 67
7968: IFFALSE 7990
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7970: LD_ADDR_EXP 75
7974: PUSH
7975: LD_EXP 75
7979: PPUSH
7980: LD_EXP 67
7984: PPUSH
7985: CALL 106190 0 2
7989: ST_TO_ADDR
// j := 3 ;
7990: LD_ADDR_VAR 0 3
7994: PUSH
7995: LD_INT 3
7997: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7998: LD_ADDR_VAR 0 2
8002: PUSH
8003: LD_INT 22
8005: PUSH
8006: LD_INT 3
8008: PUSH
8009: EMPTY
8010: LIST
8011: LIST
8012: PUSH
8013: LD_INT 25
8015: PUSH
8016: LD_INT 3
8018: PUSH
8019: EMPTY
8020: LIST
8021: LIST
8022: PUSH
8023: EMPTY
8024: LIST
8025: LIST
8026: PPUSH
8027: CALL_OW 69
8031: PUSH
8032: LD_EXP 67
8036: DIFF
8037: PUSH
8038: FOR_IN
8039: IFFALSE 8089
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
8041: LD_ADDR_EXP 75
8045: PUSH
8046: LD_EXP 75
8050: PPUSH
8051: LD_VAR 0 2
8055: PPUSH
8056: CALL 106190 0 2
8060: ST_TO_ADDR
// j := j - 1 ;
8061: LD_ADDR_VAR 0 3
8065: PUSH
8066: LD_VAR 0 3
8070: PUSH
8071: LD_INT 1
8073: MINUS
8074: ST_TO_ADDR
// if j = 0 then
8075: LD_VAR 0 3
8079: PUSH
8080: LD_INT 0
8082: EQUAL
8083: IFFALSE 8087
// break ;
8085: GO 8089
// end ;
8087: GO 8038
8089: POP
8090: POP
// end ;
8091: LD_VAR 0 1
8095: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
8096: LD_INT 0
8098: PPUSH
8099: PPUSH
8100: PPUSH
8101: PPUSH
8102: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
8103: LD_ADDR_VAR 0 4
8107: PUSH
8108: LD_INT 209
8110: PUSH
8111: LD_INT 149
8113: PUSH
8114: EMPTY
8115: LIST
8116: LIST
8117: PUSH
8118: LD_INT 219
8120: PUSH
8121: LD_INT 154
8123: PUSH
8124: EMPTY
8125: LIST
8126: LIST
8127: PUSH
8128: LD_INT 223
8130: PUSH
8131: LD_INT 149
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PUSH
8138: LD_INT 232
8140: PUSH
8141: LD_INT 155
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: LIST
8152: LIST
8153: ST_TO_ADDR
// if not behemothBuilders then
8154: LD_EXP 75
8158: NOT
8159: IFFALSE 8163
// exit ;
8161: GO 8294
// j := 1 ;
8163: LD_ADDR_VAR 0 3
8167: PUSH
8168: LD_INT 1
8170: ST_TO_ADDR
// for i in behemothBuilders do
8171: LD_ADDR_VAR 0 2
8175: PUSH
8176: LD_EXP 75
8180: PUSH
8181: FOR_IN
8182: IFFALSE 8292
// begin if GetClass ( i ) <> class_mechanic then
8184: LD_VAR 0 2
8188: PPUSH
8189: CALL_OW 257
8193: PUSH
8194: LD_INT 3
8196: NONEQUAL
8197: IFFALSE 8211
// SetClass ( i , class_mechanic ) ;
8199: LD_VAR 0 2
8203: PPUSH
8204: LD_INT 3
8206: PPUSH
8207: CALL_OW 336
// if IsInUnit ( i ) then
8211: LD_VAR 0 2
8215: PPUSH
8216: CALL_OW 310
8220: IFFALSE 8231
// ComExitBuilding ( i ) ;
8222: LD_VAR 0 2
8226: PPUSH
8227: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
8231: LD_VAR 0 2
8235: PPUSH
8236: LD_INT 37
8238: PPUSH
8239: LD_VAR 0 4
8243: PUSH
8244: LD_VAR 0 3
8248: ARRAY
8249: PUSH
8250: LD_INT 1
8252: ARRAY
8253: PPUSH
8254: LD_VAR 0 4
8258: PUSH
8259: LD_VAR 0 3
8263: ARRAY
8264: PUSH
8265: LD_INT 2
8267: ARRAY
8268: PPUSH
8269: LD_INT 0
8271: PPUSH
8272: CALL_OW 230
// j := j + 1 ;
8276: LD_ADDR_VAR 0 3
8280: PUSH
8281: LD_VAR 0 3
8285: PUSH
8286: LD_INT 1
8288: PLUS
8289: ST_TO_ADDR
// end ;
8290: GO 8181
8292: POP
8293: POP
// end ;
8294: LD_VAR 0 1
8298: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
8299: LD_INT 24
8301: PPUSH
8302: LD_INT 30
8304: PUSH
8305: LD_INT 37
8307: PUSH
8308: EMPTY
8309: LIST
8310: LIST
8311: PPUSH
8312: CALL_OW 70
8316: IFFALSE 8329
8318: GO 8320
8320: DISABLE
// behemothUnderConstruct := true ;
8321: LD_ADDR_EXP 26
8325: PUSH
8326: LD_INT 1
8328: ST_TO_ADDR
8329: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
8330: LD_INT 3
8332: PPUSH
8333: CALL 106251 0 1
8337: PUSH
8338: LD_INT 22
8340: PUSH
8341: LD_INT 3
8343: PUSH
8344: EMPTY
8345: LIST
8346: LIST
8347: PUSH
8348: LD_INT 30
8350: PUSH
8351: LD_INT 37
8353: PUSH
8354: EMPTY
8355: LIST
8356: LIST
8357: PUSH
8358: EMPTY
8359: LIST
8360: LIST
8361: PPUSH
8362: CALL_OW 69
8366: NOT
8367: AND
8368: IFFALSE 8554
8370: GO 8372
8372: DISABLE
8373: LD_INT 0
8375: PPUSH
8376: PPUSH
// begin enable ;
8377: ENABLE
// tmp := GetBehemoths ( 3 ) ;
8378: LD_ADDR_VAR 0 2
8382: PUSH
8383: LD_INT 3
8385: PPUSH
8386: CALL 106251 0 1
8390: ST_TO_ADDR
// for i in tmp do
8391: LD_ADDR_VAR 0 1
8395: PUSH
8396: LD_VAR 0 2
8400: PUSH
8401: FOR_IN
8402: IFFALSE 8552
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8404: LD_VAR 0 1
8408: PPUSH
8409: LD_INT 9
8411: PPUSH
8412: CALL_OW 308
8416: PUSH
8417: LD_VAR 0 1
8421: PPUSH
8422: CALL_OW 110
8426: PUSH
8427: LD_INT 2
8429: EQUAL
8430: NOT
8431: AND
8432: IFFALSE 8446
// SetTag ( i , 2 ) ;
8434: LD_VAR 0 1
8438: PPUSH
8439: LD_INT 2
8441: PPUSH
8442: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8446: LD_INT 81
8448: PUSH
8449: LD_INT 3
8451: PUSH
8452: EMPTY
8453: LIST
8454: LIST
8455: PUSH
8456: LD_INT 91
8458: PUSH
8459: LD_VAR 0 1
8463: PUSH
8464: LD_INT 12
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: LIST
8471: PUSH
8472: EMPTY
8473: LIST
8474: LIST
8475: PPUSH
8476: CALL_OW 69
8480: NOT
8481: PUSH
8482: LD_VAR 0 1
8486: PPUSH
8487: CALL_OW 110
8491: PUSH
8492: LD_INT 2
8494: EQUAL
8495: NOT
8496: AND
8497: IFFALSE 8516
// ComAgressiveMove ( i , 64 , 93 ) else
8499: LD_VAR 0 1
8503: PPUSH
8504: LD_INT 64
8506: PPUSH
8507: LD_INT 93
8509: PPUSH
8510: CALL_OW 114
8514: GO 8550
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8516: LD_VAR 0 1
8520: PPUSH
8521: LD_INT 81
8523: PUSH
8524: LD_INT 3
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: PPUSH
8531: CALL_OW 69
8535: PPUSH
8536: LD_VAR 0 1
8540: PPUSH
8541: CALL_OW 74
8545: PPUSH
8546: CALL_OW 115
// end ;
8550: GO 8401
8552: POP
8553: POP
// end ;
8554: PPOPN 2
8556: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8557: LD_INT 0
8559: PPUSH
8560: PPUSH
8561: PPUSH
// result := [ ] ;
8562: LD_ADDR_VAR 0 2
8566: PUSH
8567: EMPTY
8568: ST_TO_ADDR
// uc_side := 6 ;
8569: LD_ADDR_OWVAR 20
8573: PUSH
8574: LD_INT 6
8576: ST_TO_ADDR
// uc_nation := 3 ;
8577: LD_ADDR_OWVAR 21
8581: PUSH
8582: LD_INT 3
8584: ST_TO_ADDR
// case strength of 1 :
8585: LD_VAR 0 1
8589: PUSH
8590: LD_INT 1
8592: DOUBLE
8593: EQUAL
8594: IFTRUE 8598
8596: GO 8740
8598: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8599: LD_ADDR_VAR 0 3
8603: PUSH
8604: DOUBLE
8605: LD_INT 1
8607: DEC
8608: ST_TO_ADDR
8609: LD_INT 4
8611: PUSH
8612: LD_INT 5
8614: PUSH
8615: LD_INT 6
8617: PUSH
8618: LD_INT 7
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: LIST
8625: LIST
8626: PUSH
8627: LD_OWVAR 67
8631: ARRAY
8632: PUSH
8633: FOR_TO
8634: IFFALSE 8736
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8636: LD_INT 22
8638: PUSH
8639: LD_INT 24
8641: PUSH
8642: EMPTY
8643: LIST
8644: LIST
8645: PUSH
8646: LD_VAR 0 3
8650: PUSH
8651: LD_INT 2
8653: MOD
8654: PUSH
8655: LD_INT 1
8657: PLUS
8658: ARRAY
8659: PPUSH
8660: LD_INT 1
8662: PUSH
8663: LD_INT 3
8665: PUSH
8666: EMPTY
8667: LIST
8668: LIST
8669: PUSH
8670: LD_INT 1
8672: PPUSH
8673: LD_INT 2
8675: PPUSH
8676: CALL_OW 12
8680: ARRAY
8681: PPUSH
8682: LD_INT 3
8684: PPUSH
8685: LD_INT 43
8687: PUSH
8688: LD_INT 44
8690: PUSH
8691: LD_INT 45
8693: PUSH
8694: EMPTY
8695: LIST
8696: LIST
8697: LIST
8698: PUSH
8699: LD_INT 1
8701: PPUSH
8702: LD_INT 3
8704: PPUSH
8705: CALL_OW 12
8709: ARRAY
8710: PPUSH
8711: LD_INT 80
8713: PPUSH
8714: CALL 73738 0 5
// result := result union CreateVehicle ;
8718: LD_ADDR_VAR 0 2
8722: PUSH
8723: LD_VAR 0 2
8727: PUSH
8728: CALL_OW 45
8732: UNION
8733: ST_TO_ADDR
// end ;
8734: GO 8633
8736: POP
8737: POP
// end ; 2 :
8738: GO 9735
8740: LD_INT 2
8742: DOUBLE
8743: EQUAL
8744: IFTRUE 8748
8746: GO 8916
8748: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8749: LD_ADDR_VAR 0 3
8753: PUSH
8754: DOUBLE
8755: LD_INT 1
8757: DEC
8758: ST_TO_ADDR
8759: LD_INT 5
8761: PUSH
8762: LD_INT 6
8764: PUSH
8765: LD_INT 7
8767: PUSH
8768: LD_INT 8
8770: PUSH
8771: EMPTY
8772: LIST
8773: LIST
8774: LIST
8775: LIST
8776: PUSH
8777: LD_OWVAR 67
8781: ARRAY
8782: PUSH
8783: FOR_TO
8784: IFFALSE 8912
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser ] [ i mod 8 + 1 ] , 80 ) ;
8786: LD_INT 22
8788: PUSH
8789: LD_INT 24
8791: PUSH
8792: LD_INT 24
8794: PUSH
8795: EMPTY
8796: LIST
8797: LIST
8798: LIST
8799: PUSH
8800: LD_VAR 0 3
8804: PUSH
8805: LD_INT 3
8807: MOD
8808: PUSH
8809: LD_INT 1
8811: PLUS
8812: ARRAY
8813: PPUSH
8814: LD_INT 1
8816: PUSH
8817: LD_INT 3
8819: PUSH
8820: EMPTY
8821: LIST
8822: LIST
8823: PUSH
8824: LD_INT 1
8826: PPUSH
8827: LD_INT 2
8829: PPUSH
8830: CALL_OW 12
8834: ARRAY
8835: PPUSH
8836: LD_INT 3
8838: PPUSH
8839: LD_INT 43
8841: PUSH
8842: LD_INT 44
8844: PUSH
8845: LD_INT 45
8847: PUSH
8848: LD_INT 44
8850: PUSH
8851: LD_INT 46
8853: PUSH
8854: LD_INT 46
8856: PUSH
8857: LD_INT 49
8859: PUSH
8860: LD_INT 49
8862: PUSH
8863: EMPTY
8864: LIST
8865: LIST
8866: LIST
8867: LIST
8868: LIST
8869: LIST
8870: LIST
8871: LIST
8872: PUSH
8873: LD_VAR 0 3
8877: PUSH
8878: LD_INT 8
8880: MOD
8881: PUSH
8882: LD_INT 1
8884: PLUS
8885: ARRAY
8886: PPUSH
8887: LD_INT 80
8889: PPUSH
8890: CALL 73738 0 5
// result := result union CreateVehicle ;
8894: LD_ADDR_VAR 0 2
8898: PUSH
8899: LD_VAR 0 2
8903: PUSH
8904: CALL_OW 45
8908: UNION
8909: ST_TO_ADDR
// end ;
8910: GO 8783
8912: POP
8913: POP
// end ; 3 :
8914: GO 9735
8916: LD_INT 3
8918: DOUBLE
8919: EQUAL
8920: IFTRUE 8924
8922: GO 9096
8924: POP
// begin for i = 1 to [ 6 , 7 , 8 , 9 ] [ Difficulty ] do
8925: LD_ADDR_VAR 0 3
8929: PUSH
8930: DOUBLE
8931: LD_INT 1
8933: DEC
8934: ST_TO_ADDR
8935: LD_INT 6
8937: PUSH
8938: LD_INT 7
8940: PUSH
8941: LD_INT 8
8943: PUSH
8944: LD_INT 9
8946: PUSH
8947: EMPTY
8948: LIST
8949: LIST
8950: LIST
8951: LIST
8952: PUSH
8953: LD_OWVAR 67
8957: ARRAY
8958: PUSH
8959: FOR_TO
8960: IFFALSE 9092
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
8962: LD_INT 22
8964: PUSH
8965: LD_INT 24
8967: PUSH
8968: LD_INT 24
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: LIST
8975: PUSH
8976: LD_VAR 0 3
8980: PUSH
8981: LD_INT 3
8983: MOD
8984: PUSH
8985: LD_INT 1
8987: PLUS
8988: ARRAY
8989: PPUSH
8990: LD_INT 1
8992: PUSH
8993: LD_INT 3
8995: PUSH
8996: EMPTY
8997: LIST
8998: LIST
8999: PUSH
9000: LD_INT 1
9002: PPUSH
9003: LD_INT 2
9005: PPUSH
9006: CALL_OW 12
9010: ARRAY
9011: PPUSH
9012: LD_INT 3
9014: PPUSH
9015: LD_INT 43
9017: PUSH
9018: LD_INT 47
9020: PUSH
9021: LD_INT 45
9023: PUSH
9024: LD_INT 45
9026: PUSH
9027: LD_INT 46
9029: PUSH
9030: LD_INT 46
9032: PUSH
9033: LD_INT 49
9035: PUSH
9036: LD_INT 49
9038: PUSH
9039: LD_INT 49
9041: PUSH
9042: EMPTY
9043: LIST
9044: LIST
9045: LIST
9046: LIST
9047: LIST
9048: LIST
9049: LIST
9050: LIST
9051: LIST
9052: PUSH
9053: LD_VAR 0 3
9057: PUSH
9058: LD_INT 9
9060: MOD
9061: PUSH
9062: LD_INT 1
9064: PLUS
9065: ARRAY
9066: PPUSH
9067: LD_INT 80
9069: PPUSH
9070: CALL 73738 0 5
// result := result union CreateVehicle ;
9074: LD_ADDR_VAR 0 2
9078: PUSH
9079: LD_VAR 0 2
9083: PUSH
9084: CALL_OW 45
9088: UNION
9089: ST_TO_ADDR
// end ;
9090: GO 8959
9092: POP
9093: POP
// end ; 4 :
9094: GO 9735
9096: LD_INT 4
9098: DOUBLE
9099: EQUAL
9100: IFTRUE 9104
9102: GO 9734
9104: POP
// begin uc_nation := 3 ;
9105: LD_ADDR_OWVAR 21
9109: PUSH
9110: LD_INT 3
9112: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
9113: LD_ADDR_VAR 0 3
9117: PUSH
9118: DOUBLE
9119: LD_INT 1
9121: DEC
9122: ST_TO_ADDR
9123: LD_INT 6
9125: PUSH
9126: LD_INT 8
9128: PUSH
9129: LD_INT 9
9131: PUSH
9132: LD_INT 10
9134: PUSH
9135: EMPTY
9136: LIST
9137: LIST
9138: LIST
9139: LIST
9140: PUSH
9141: LD_OWVAR 67
9145: ARRAY
9146: PUSH
9147: FOR_TO
9148: IFFALSE 9280
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun , ru_time_lapser , ru_time_lapser , ru_time_lapser ] [ i mod 9 + 1 ] , 80 ) ;
9150: LD_INT 22
9152: PUSH
9153: LD_INT 24
9155: PUSH
9156: LD_INT 24
9158: PUSH
9159: EMPTY
9160: LIST
9161: LIST
9162: LIST
9163: PUSH
9164: LD_VAR 0 3
9168: PUSH
9169: LD_INT 3
9171: MOD
9172: PUSH
9173: LD_INT 1
9175: PLUS
9176: ARRAY
9177: PPUSH
9178: LD_INT 1
9180: PUSH
9181: LD_INT 3
9183: PUSH
9184: EMPTY
9185: LIST
9186: LIST
9187: PUSH
9188: LD_INT 1
9190: PPUSH
9191: LD_INT 2
9193: PPUSH
9194: CALL_OW 12
9198: ARRAY
9199: PPUSH
9200: LD_INT 3
9202: PPUSH
9203: LD_INT 45
9205: PUSH
9206: LD_INT 47
9208: PUSH
9209: LD_INT 47
9211: PUSH
9212: LD_INT 45
9214: PUSH
9215: LD_INT 46
9217: PUSH
9218: LD_INT 46
9220: PUSH
9221: LD_INT 49
9223: PUSH
9224: LD_INT 49
9226: PUSH
9227: LD_INT 49
9229: PUSH
9230: EMPTY
9231: LIST
9232: LIST
9233: LIST
9234: LIST
9235: LIST
9236: LIST
9237: LIST
9238: LIST
9239: LIST
9240: PUSH
9241: LD_VAR 0 3
9245: PUSH
9246: LD_INT 9
9248: MOD
9249: PUSH
9250: LD_INT 1
9252: PLUS
9253: ARRAY
9254: PPUSH
9255: LD_INT 80
9257: PPUSH
9258: CALL 73738 0 5
// result := result union CreateVehicle ;
9262: LD_ADDR_VAR 0 2
9266: PUSH
9267: LD_VAR 0 2
9271: PUSH
9272: CALL_OW 45
9276: UNION
9277: ST_TO_ADDR
// end ;
9278: GO 9147
9280: POP
9281: POP
// if not KappaStatus then
9282: LD_EXP 2
9286: NOT
9287: IFFALSE 9522
// begin uc_nation := 1 ;
9289: LD_ADDR_OWVAR 21
9293: PUSH
9294: LD_INT 1
9296: ST_TO_ADDR
// for i = 1 to 3 do
9297: LD_ADDR_VAR 0 3
9301: PUSH
9302: DOUBLE
9303: LD_INT 1
9305: DEC
9306: ST_TO_ADDR
9307: LD_INT 3
9309: PUSH
9310: FOR_TO
9311: IFFALSE 9447
// begin j := rand ( 0 , 1 ) ;
9313: LD_ADDR_VAR 0 4
9317: PUSH
9318: LD_INT 0
9320: PPUSH
9321: LD_INT 1
9323: PPUSH
9324: CALL_OW 12
9328: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
9329: LD_INT 3
9331: PUSH
9332: LD_INT 5
9334: PUSH
9335: LD_INT 5
9337: PUSH
9338: LD_INT 4
9340: PUSH
9341: EMPTY
9342: LIST
9343: LIST
9344: LIST
9345: LIST
9346: PUSH
9347: LD_VAR 0 4
9351: PUSH
9352: LD_INT 1
9354: PPUSH
9355: LD_INT 3
9357: PPUSH
9358: CALL_OW 12
9362: PLUS
9363: ARRAY
9364: PPUSH
9365: LD_INT 1
9367: PUSH
9368: LD_INT 3
9370: PUSH
9371: EMPTY
9372: LIST
9373: LIST
9374: PUSH
9375: LD_INT 1
9377: PPUSH
9378: LD_INT 2
9380: PPUSH
9381: CALL_OW 12
9385: ARRAY
9386: PPUSH
9387: LD_INT 3
9389: PPUSH
9390: LD_INT 9
9392: PUSH
9393: LD_INT 7
9395: PUSH
9396: LD_INT 6
9398: PUSH
9399: EMPTY
9400: LIST
9401: LIST
9402: LIST
9403: PUSH
9404: LD_VAR 0 4
9408: PUSH
9409: LD_INT 1
9411: PPUSH
9412: LD_INT 2
9414: PPUSH
9415: CALL_OW 12
9419: PLUS
9420: ARRAY
9421: PPUSH
9422: LD_INT 85
9424: PPUSH
9425: CALL 73738 0 5
// result := result union CreateVehicle ;
9429: LD_ADDR_VAR 0 2
9433: PUSH
9434: LD_VAR 0 2
9438: PUSH
9439: CALL_OW 45
9443: UNION
9444: ST_TO_ADDR
// end ;
9445: GO 9310
9447: POP
9448: POP
// if vsevolodFirstAttack then
9449: LD_EXP 24
9453: IFFALSE 9520
// begin vsevolodFirstAttack := false ;
9455: LD_ADDR_EXP 24
9459: PUSH
9460: LD_INT 0
9462: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9463: LD_INT 5
9465: PPUSH
9466: LD_INT 3
9468: PPUSH
9469: LD_INT 1
9471: PPUSH
9472: LD_INT 6
9474: PPUSH
9475: LD_INT 100
9477: PPUSH
9478: CALL 73738 0 5
// sewiVeh := CreateVehicle ;
9482: LD_ADDR_EXP 73
9486: PUSH
9487: CALL_OW 45
9491: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9492: LD_EXP 73
9496: PPUSH
9497: LD_INT 1
9499: PPUSH
9500: CALL_OW 242
// result := result union sewiVeh ;
9504: LD_ADDR_VAR 0 2
9508: PUSH
9509: LD_VAR 0 2
9513: PUSH
9514: LD_EXP 73
9518: UNION
9519: ST_TO_ADDR
// end ; end else
9520: GO 9732
// if vsevolodFirstAttack then
9522: LD_EXP 24
9526: IFFALSE 9732
// begin vsevolodFirstAttack := false ;
9528: LD_ADDR_EXP 24
9532: PUSH
9533: LD_INT 0
9535: ST_TO_ADDR
// uc_nation := 3 ;
9536: LD_ADDR_OWVAR 21
9540: PUSH
9541: LD_INT 3
9543: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9544: LD_ADDR_VAR 0 3
9548: PUSH
9549: DOUBLE
9550: LD_INT 1
9552: DEC
9553: ST_TO_ADDR
9554: LD_INT 2
9556: PUSH
9557: LD_OWVAR 67
9561: PLUS
9562: PUSH
9563: FOR_TO
9564: IFFALSE 9672
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9566: LD_INT 22
9568: PUSH
9569: LD_INT 24
9571: PUSH
9572: LD_INT 24
9574: PUSH
9575: EMPTY
9576: LIST
9577: LIST
9578: LIST
9579: PUSH
9580: LD_VAR 0 3
9584: PUSH
9585: LD_INT 3
9587: MOD
9588: PUSH
9589: LD_INT 1
9591: PLUS
9592: ARRAY
9593: PPUSH
9594: LD_INT 1
9596: PUSH
9597: LD_INT 3
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: PUSH
9604: LD_INT 1
9606: PPUSH
9607: LD_INT 2
9609: PPUSH
9610: CALL_OW 12
9614: ARRAY
9615: PPUSH
9616: LD_INT 1
9618: PPUSH
9619: LD_INT 45
9621: PUSH
9622: LD_INT 47
9624: PUSH
9625: LD_INT 47
9627: PUSH
9628: EMPTY
9629: LIST
9630: LIST
9631: LIST
9632: PUSH
9633: LD_VAR 0 3
9637: PUSH
9638: LD_INT 3
9640: MOD
9641: PUSH
9642: LD_INT 1
9644: PLUS
9645: ARRAY
9646: PPUSH
9647: LD_INT 80
9649: PPUSH
9650: CALL 73738 0 5
// result := result union CreateVehicle ;
9654: LD_ADDR_VAR 0 2
9658: PUSH
9659: LD_VAR 0 2
9663: PUSH
9664: CALL_OW 45
9668: UNION
9669: ST_TO_ADDR
// end ;
9670: GO 9563
9672: POP
9673: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9674: LD_INT 24
9676: PPUSH
9677: LD_INT 3
9679: PPUSH
9680: LD_INT 1
9682: PPUSH
9683: LD_INT 47
9685: PPUSH
9686: LD_INT 100
9688: PPUSH
9689: CALL 73738 0 5
// sewiVeh := CreateVehicle ;
9693: LD_ADDR_EXP 73
9697: PUSH
9698: CALL_OW 45
9702: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9703: LD_EXP 73
9707: PPUSH
9708: LD_INT 6
9710: NEG
9711: PPUSH
9712: CALL_OW 242
// result := result union sewiVeh ;
9716: LD_ADDR_VAR 0 2
9720: PUSH
9721: LD_VAR 0 2
9725: PUSH
9726: LD_EXP 73
9730: UNION
9731: ST_TO_ADDR
// end ; end ; end ;
9732: GO 9735
9734: POP
// end ;
9735: LD_VAR 0 2
9739: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9740: LD_EXP 16
9744: IFFALSE 10485
9746: GO 9748
9748: DISABLE
9749: LD_INT 0
9751: PPUSH
9752: PPUSH
9753: PPUSH
9754: PPUSH
9755: PPUSH
9756: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9757: LD_ADDR_VAR 0 4
9761: PUSH
9762: LD_INT 11
9764: PUSH
9765: LD_INT 12
9767: PUSH
9768: EMPTY
9769: LIST
9770: LIST
9771: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9772: LD_ADDR_VAR 0 3
9776: PUSH
9777: LD_INT 11550
9779: PUSH
9780: LD_INT 10150
9782: PUSH
9783: LD_INT 9800
9785: PUSH
9786: LD_INT 9450
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: LIST
9793: LIST
9794: PUSH
9795: LD_OWVAR 67
9799: ARRAY
9800: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9801: LD_ADDR_VAR 0 6
9805: PUSH
9806: LD_INT 70
9808: PUSH
9809: LD_INT 118
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 78
9818: PUSH
9819: LD_INT 31
9821: PUSH
9822: EMPTY
9823: LIST
9824: LIST
9825: PUSH
9826: EMPTY
9827: LIST
9828: LIST
9829: ST_TO_ADDR
// repeat if missionStage = 2 then
9830: LD_EXP 15
9834: PUSH
9835: LD_INT 2
9837: EQUAL
9838: IFFALSE 9849
// wait ( 1 1$30 ) else
9840: LD_INT 3150
9842: PPUSH
9843: CALL_OW 67
9847: GO 9858
// wait ( time ) ;
9849: LD_VAR 0 3
9853: PPUSH
9854: CALL_OW 67
// if missionStage = 6 or Difficulty > 2 then
9858: LD_EXP 15
9862: PUSH
9863: LD_INT 6
9865: EQUAL
9866: PUSH
9867: LD_OWVAR 67
9871: PUSH
9872: LD_INT 2
9874: GREATER
9875: OR
9876: IFFALSE 9904
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9878: LD_INT 51
9880: PPUSH
9881: LD_INT 6
9883: PPUSH
9884: LD_INT 2
9886: PPUSH
9887: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9891: LD_INT 57
9893: PPUSH
9894: LD_INT 6
9896: PPUSH
9897: LD_INT 2
9899: PPUSH
9900: CALL_OW 322
// end ; if missionStage = 8 then
9904: LD_EXP 15
9908: PUSH
9909: LD_INT 8
9911: EQUAL
9912: IFFALSE 9940
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9914: LD_INT 52
9916: PPUSH
9917: LD_INT 6
9919: PPUSH
9920: LD_INT 2
9922: PPUSH
9923: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9927: LD_INT 58
9929: PPUSH
9930: LD_INT 6
9932: PPUSH
9933: LD_INT 2
9935: PPUSH
9936: CALL_OW 322
// end ; if Difficulty = 4 or missionStage = 10 then
9940: LD_OWVAR 67
9944: PUSH
9945: LD_INT 4
9947: EQUAL
9948: PUSH
9949: LD_EXP 15
9953: PUSH
9954: LD_INT 10
9956: EQUAL
9957: OR
9958: IFFALSE 9986
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9960: LD_INT 53
9962: PPUSH
9963: LD_INT 6
9965: PPUSH
9966: LD_INT 2
9968: PPUSH
9969: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9973: LD_INT 59
9975: PPUSH
9976: LD_INT 6
9978: PPUSH
9979: LD_INT 2
9981: PPUSH
9982: CALL_OW 322
// end ; if activeAttacks then
9986: LD_EXP 16
9990: IFFALSE 10479
// begin if missionStage = 2 then
9992: LD_EXP 15
9996: PUSH
9997: LD_INT 2
9999: EQUAL
10000: IFFALSE 10010
// strength := 1 ;
10002: LD_ADDR_VAR 0 5
10006: PUSH
10007: LD_INT 1
10009: ST_TO_ADDR
// if missionStage > 2 then
10010: LD_EXP 15
10014: PUSH
10015: LD_INT 2
10017: GREATER
10018: IFFALSE 10028
// strength := 2 ;
10020: LD_ADDR_VAR 0 5
10024: PUSH
10025: LD_INT 2
10027: ST_TO_ADDR
// if missionStage > 6 then
10028: LD_EXP 15
10032: PUSH
10033: LD_INT 6
10035: GREATER
10036: IFFALSE 10046
// strength := 3 ;
10038: LD_ADDR_VAR 0 5
10042: PUSH
10043: LD_INT 3
10045: ST_TO_ADDR
// if missionStage > 10 then
10046: LD_EXP 15
10050: PUSH
10051: LD_INT 10
10053: GREATER
10054: IFFALSE 10064
// strength := 4 ;
10056: LD_ADDR_VAR 0 5
10060: PUSH
10061: LD_INT 4
10063: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
10064: LD_ADDR_VAR 0 2
10068: PUSH
10069: LD_VAR 0 5
10073: PPUSH
10074: CALL 8557 0 1
10078: ST_TO_ADDR
// for i in tmp do
10079: LD_ADDR_VAR 0 1
10083: PUSH
10084: LD_VAR 0 2
10088: PUSH
10089: FOR_IN
10090: IFFALSE 10348
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
10092: LD_VAR 0 1
10096: PPUSH
10097: LD_VAR 0 4
10101: PUSH
10102: LD_INT 1
10104: PPUSH
10105: LD_INT 2
10107: PPUSH
10108: CALL_OW 12
10112: ARRAY
10113: PPUSH
10114: LD_INT 0
10116: PPUSH
10117: CALL_OW 49
// if i = sewiVeh then
10121: LD_VAR 0 1
10125: PUSH
10126: LD_EXP 73
10130: EQUAL
10131: IFFALSE 10168
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
10133: LD_ADDR_EXP 72
10137: PUSH
10138: LD_STRING Vsevolod
10140: PPUSH
10141: LD_INT 0
10143: PPUSH
10144: LD_STRING 
10146: PPUSH
10147: CALL 68898 0 3
10151: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
10152: LD_EXP 72
10156: PPUSH
10157: LD_VAR 0 1
10161: PPUSH
10162: CALL_OW 52
// end else
10166: GO 10249
// if GetControl ( i ) = control_manual then
10168: LD_VAR 0 1
10172: PPUSH
10173: CALL_OW 263
10177: PUSH
10178: LD_INT 1
10180: EQUAL
10181: IFFALSE 10249
// begin uc_side := 6 ;
10183: LD_ADDR_OWVAR 20
10187: PUSH
10188: LD_INT 6
10190: ST_TO_ADDR
// uc_nation := 3 ;
10191: LD_ADDR_OWVAR 21
10195: PUSH
10196: LD_INT 3
10198: ST_TO_ADDR
// hc_gallery :=  ;
10199: LD_ADDR_OWVAR 33
10203: PUSH
10204: LD_STRING 
10206: ST_TO_ADDR
// hc_name :=  ;
10207: LD_ADDR_OWVAR 26
10211: PUSH
10212: LD_STRING 
10214: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
10215: LD_INT 0
10217: PPUSH
10218: LD_INT 3
10220: PPUSH
10221: LD_INT 10
10223: PPUSH
10224: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
10228: CALL_OW 44
10232: PPUSH
10233: LD_VAR 0 1
10237: PPUSH
10238: CALL_OW 52
// wait ( 0 0$0.3 ) ;
10242: LD_INT 10
10244: PPUSH
10245: CALL_OW 67
// end ; case rand ( 1 , 3 ) of 1 :
10249: LD_INT 1
10251: PPUSH
10252: LD_INT 3
10254: PPUSH
10255: CALL_OW 12
10259: PUSH
10260: LD_INT 1
10262: DOUBLE
10263: EQUAL
10264: IFTRUE 10268
10266: GO 10286
10268: POP
// ComMoveXY ( i , 111 , 197 ) ; 2 :
10269: LD_VAR 0 1
10273: PPUSH
10274: LD_INT 111
10276: PPUSH
10277: LD_INT 197
10279: PPUSH
10280: CALL_OW 111
10284: GO 10339
10286: LD_INT 2
10288: DOUBLE
10289: EQUAL
10290: IFTRUE 10294
10292: GO 10312
10294: POP
// ComMoveXY ( i , 91 , 165 ) ; 3 :
10295: LD_VAR 0 1
10299: PPUSH
10300: LD_INT 91
10302: PPUSH
10303: LD_INT 165
10305: PPUSH
10306: CALL_OW 111
10310: GO 10339
10312: LD_INT 3
10314: DOUBLE
10315: EQUAL
10316: IFTRUE 10320
10318: GO 10338
10320: POP
// ComMoveXY ( i , 137 , 157 ) ; end ;
10321: LD_VAR 0 1
10325: PPUSH
10326: LD_INT 137
10328: PPUSH
10329: LD_INT 157
10331: PPUSH
10332: CALL_OW 111
10336: GO 10339
10338: POP
// wait ( 0 0$2 ) ;
10339: LD_INT 70
10341: PPUSH
10342: CALL_OW 67
// end ;
10346: GO 10089
10348: POP
10349: POP
// repeat wait ( 0 0$1 ) ;
10350: LD_INT 35
10352: PPUSH
10353: CALL_OW 67
// for i in UnitFilter ( tmp , [ f_ok ] ) do
10357: LD_ADDR_VAR 0 1
10361: PUSH
10362: LD_VAR 0 2
10366: PPUSH
10367: LD_INT 50
10369: PUSH
10370: EMPTY
10371: LIST
10372: PPUSH
10373: CALL_OW 72
10377: PUSH
10378: FOR_IN
10379: IFFALSE 10438
// AgressiveMove ( i , [ [ 108 , 153 ] , [ 105 , 149 ] , [ 85 , 131 ] , [ 64 , 105 ] ] ) ;
10381: LD_VAR 0 1
10385: PPUSH
10386: LD_INT 108
10388: PUSH
10389: LD_INT 153
10391: PUSH
10392: EMPTY
10393: LIST
10394: LIST
10395: PUSH
10396: LD_INT 105
10398: PUSH
10399: LD_INT 149
10401: PUSH
10402: EMPTY
10403: LIST
10404: LIST
10405: PUSH
10406: LD_INT 85
10408: PUSH
10409: LD_INT 131
10411: PUSH
10412: EMPTY
10413: LIST
10414: LIST
10415: PUSH
10416: LD_INT 64
10418: PUSH
10419: LD_INT 105
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: LIST
10430: LIST
10431: PPUSH
10432: CALL 108794 0 2
10436: GO 10378
10438: POP
10439: POP
// until not UnitFilter ( tmp , [ [ f_not , [ f_weapon , ru_time_lapser ] ] , [ f_ok ] ] ) ;
10440: LD_VAR 0 2
10444: PPUSH
10445: LD_INT 3
10447: PUSH
10448: LD_INT 34
10450: PUSH
10451: LD_INT 49
10453: PUSH
10454: EMPTY
10455: LIST
10456: LIST
10457: PUSH
10458: EMPTY
10459: LIST
10460: LIST
10461: PUSH
10462: LD_INT 50
10464: PUSH
10465: EMPTY
10466: LIST
10467: PUSH
10468: EMPTY
10469: LIST
10470: LIST
10471: PPUSH
10472: CALL_OW 72
10476: NOT
10477: IFFALSE 10350
// end ; until russianDestroyed ;
10479: LD_EXP 21
10483: IFFALSE 9830
// end ;
10485: PPOPN 6
10487: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 do var i , tmp , target , teleport ;
10488: LD_EXP 21
10492: NOT
10493: PUSH
10494: LD_EXP 15
10498: PUSH
10499: LD_INT 6
10501: GREATEREQUAL
10502: AND
10503: IFFALSE 11442
10505: GO 10507
10507: DISABLE
10508: LD_INT 0
10510: PPUSH
10511: PPUSH
10512: PPUSH
10513: PPUSH
// begin enable ;
10514: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10515: LD_INT 22
10517: PUSH
10518: LD_INT 3
10520: PUSH
10521: EMPTY
10522: LIST
10523: LIST
10524: PUSH
10525: LD_INT 30
10527: PUSH
10528: LD_INT 3
10530: PUSH
10531: EMPTY
10532: LIST
10533: LIST
10534: PUSH
10535: EMPTY
10536: LIST
10537: LIST
10538: PPUSH
10539: CALL_OW 69
10543: NOT
10544: IFFALSE 10548
// exit ;
10546: GO 11442
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10548: LD_ADDR_VAR 0 4
10552: PUSH
10553: LD_INT 22
10555: PUSH
10556: LD_INT 3
10558: PUSH
10559: EMPTY
10560: LIST
10561: LIST
10562: PUSH
10563: LD_INT 30
10565: PUSH
10566: LD_INT 34
10568: PUSH
10569: EMPTY
10570: LIST
10571: LIST
10572: PUSH
10573: EMPTY
10574: LIST
10575: LIST
10576: PPUSH
10577: CALL_OW 69
10581: ST_TO_ADDR
// if Prob ( 40 ) then
10582: LD_INT 40
10584: PPUSH
10585: CALL_OW 13
10589: IFFALSE 10735
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10591: LD_INT 2
10593: PPUSH
10594: LD_INT 22
10596: PUSH
10597: LD_INT 3
10599: PUSH
10600: LD_INT 3
10602: PUSH
10603: LD_INT 49
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: LIST
10610: LIST
10611: PUSH
10612: LD_INT 22
10614: PUSH
10615: LD_INT 3
10617: PUSH
10618: LD_INT 3
10620: PUSH
10621: LD_INT 49
10623: PUSH
10624: EMPTY
10625: LIST
10626: LIST
10627: LIST
10628: LIST
10629: PUSH
10630: LD_INT 22
10632: PUSH
10633: LD_INT 3
10635: PUSH
10636: LD_INT 3
10638: PUSH
10639: LD_INT 49
10641: PUSH
10642: EMPTY
10643: LIST
10644: LIST
10645: LIST
10646: LIST
10647: PUSH
10648: LD_INT 24
10650: PUSH
10651: LD_INT 3
10653: PUSH
10654: LD_INT 3
10656: PUSH
10657: LD_INT 46
10659: PUSH
10660: EMPTY
10661: LIST
10662: LIST
10663: LIST
10664: LIST
10665: PUSH
10666: LD_INT 24
10668: PUSH
10669: LD_INT 3
10671: PUSH
10672: LD_INT 3
10674: PUSH
10675: LD_INT 46
10677: PUSH
10678: EMPTY
10679: LIST
10680: LIST
10681: LIST
10682: LIST
10683: PUSH
10684: LD_INT 24
10686: PUSH
10687: LD_INT 3
10689: PUSH
10690: LD_INT 3
10692: PUSH
10693: LD_INT 46
10695: PUSH
10696: EMPTY
10697: LIST
10698: LIST
10699: LIST
10700: LIST
10701: PUSH
10702: LD_INT 24
10704: PUSH
10705: LD_INT 3
10707: PUSH
10708: LD_INT 3
10710: PUSH
10711: LD_INT 46
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: LIST
10718: LIST
10719: PUSH
10720: EMPTY
10721: LIST
10722: LIST
10723: LIST
10724: LIST
10725: LIST
10726: LIST
10727: LIST
10728: PPUSH
10729: CALL 62472 0 2
// end else
10733: GO 10877
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10735: LD_INT 2
10737: PPUSH
10738: LD_INT 24
10740: PUSH
10741: LD_INT 3
10743: PUSH
10744: LD_INT 3
10746: PUSH
10747: LD_INT 47
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: LIST
10754: LIST
10755: PUSH
10756: LD_INT 24
10758: PUSH
10759: LD_INT 3
10761: PUSH
10762: LD_INT 3
10764: PUSH
10765: LD_INT 47
10767: PUSH
10768: EMPTY
10769: LIST
10770: LIST
10771: LIST
10772: LIST
10773: PUSH
10774: LD_INT 24
10776: PUSH
10777: LD_INT 3
10779: PUSH
10780: LD_INT 3
10782: PUSH
10783: LD_INT 47
10785: PUSH
10786: EMPTY
10787: LIST
10788: LIST
10789: LIST
10790: LIST
10791: PUSH
10792: LD_INT 24
10794: PUSH
10795: LD_INT 3
10797: PUSH
10798: LD_INT 3
10800: PUSH
10801: LD_INT 46
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: PUSH
10810: LD_INT 24
10812: PUSH
10813: LD_INT 3
10815: PUSH
10816: LD_INT 3
10818: PUSH
10819: LD_INT 46
10821: PUSH
10822: EMPTY
10823: LIST
10824: LIST
10825: LIST
10826: LIST
10827: PUSH
10828: LD_INT 24
10830: PUSH
10831: LD_INT 3
10833: PUSH
10834: LD_INT 3
10836: PUSH
10837: LD_INT 46
10839: PUSH
10840: EMPTY
10841: LIST
10842: LIST
10843: LIST
10844: LIST
10845: PUSH
10846: LD_INT 24
10848: PUSH
10849: LD_INT 3
10851: PUSH
10852: LD_INT 3
10854: PUSH
10855: LD_INT 46
10857: PUSH
10858: EMPTY
10859: LIST
10860: LIST
10861: LIST
10862: LIST
10863: PUSH
10864: EMPTY
10865: LIST
10866: LIST
10867: LIST
10868: LIST
10869: LIST
10870: LIST
10871: LIST
10872: PPUSH
10873: CALL 62472 0 2
// end ; repeat wait ( 0 0$1 ) ;
10877: LD_INT 35
10879: PPUSH
10880: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= 7 ;
10884: LD_INT 2
10886: PPUSH
10887: LD_INT 1
10889: PPUSH
10890: CALL 63890 0 2
10894: PUSH
10895: LD_INT 7
10897: GREATEREQUAL
10898: IFFALSE 10877
// wait ( 0 0$10 ) ;
10900: LD_INT 350
10902: PPUSH
10903: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10907: LD_ADDR_VAR 0 2
10911: PUSH
10912: LD_INT 2
10914: PPUSH
10915: LD_INT 1
10917: PPUSH
10918: CALL 63890 0 2
10922: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10923: LD_ADDR_EXP 119
10927: PUSH
10928: LD_EXP 119
10932: PPUSH
10933: LD_INT 2
10935: PPUSH
10936: LD_EXP 119
10940: PUSH
10941: LD_INT 2
10943: ARRAY
10944: PUSH
10945: LD_VAR 0 2
10949: DIFF
10950: PPUSH
10951: CALL_OW 1
10955: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10956: LD_ADDR_VAR 0 3
10960: PUSH
10961: LD_INT 0
10963: PPUSH
10964: LD_INT 1
10966: PPUSH
10967: CALL_OW 12
10971: ST_TO_ADDR
// if target then
10972: LD_VAR 0 3
10976: IFFALSE 11104
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10978: LD_ADDR_VAR 0 2
10982: PUSH
10983: LD_VAR 0 2
10987: PPUSH
10988: LD_INT 24
10990: PUSH
10991: LD_INT 250
10993: PUSH
10994: EMPTY
10995: LIST
10996: LIST
10997: PPUSH
10998: CALL_OW 72
11002: ST_TO_ADDR
// for i in tmp do
11003: LD_ADDR_VAR 0 1
11007: PUSH
11008: LD_VAR 0 2
11012: PUSH
11013: FOR_IN
11014: IFFALSE 11054
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
11016: LD_VAR 0 1
11020: PPUSH
11021: LD_INT 139
11023: PPUSH
11024: LD_INT 89
11026: PPUSH
11027: CALL_OW 297
11031: PUSH
11032: LD_INT 9
11034: GREATER
11035: IFFALSE 11052
// ComMoveXY ( i , 139 , 89 ) ;
11037: LD_VAR 0 1
11041: PPUSH
11042: LD_INT 139
11044: PPUSH
11045: LD_INT 89
11047: PPUSH
11048: CALL_OW 111
11052: GO 11013
11054: POP
11055: POP
// wait ( 0 0$1 ) ;
11056: LD_INT 35
11058: PPUSH
11059: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
11063: LD_VAR 0 2
11067: PPUSH
11068: LD_INT 92
11070: PUSH
11071: LD_INT 139
11073: PUSH
11074: LD_INT 89
11076: PUSH
11077: LD_INT 9
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: LIST
11084: LIST
11085: PPUSH
11086: CALL_OW 72
11090: PUSH
11091: LD_VAR 0 2
11095: PUSH
11096: LD_INT 1
11098: MINUS
11099: GREATEREQUAL
11100: IFFALSE 10978
// end else
11102: GO 11246
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
11104: LD_VAR 0 2
11108: PPUSH
11109: LD_VAR 0 4
11113: PUSH
11114: LD_INT 1
11116: ARRAY
11117: PPUSH
11118: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
11122: LD_ADDR_VAR 0 2
11126: PUSH
11127: LD_VAR 0 2
11131: PPUSH
11132: LD_INT 24
11134: PUSH
11135: LD_INT 250
11137: PUSH
11138: EMPTY
11139: LIST
11140: LIST
11141: PPUSH
11142: CALL_OW 72
11146: ST_TO_ADDR
// for i in tmp do
11147: LD_ADDR_VAR 0 1
11151: PUSH
11152: LD_VAR 0 2
11156: PUSH
11157: FOR_IN
11158: IFFALSE 11198
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
11160: LD_VAR 0 1
11164: PPUSH
11165: LD_INT 124
11167: PPUSH
11168: LD_INT 139
11170: PPUSH
11171: CALL_OW 297
11175: PUSH
11176: LD_INT 9
11178: GREATER
11179: IFFALSE 11196
// ComMoveXY ( i , 124 , 139 ) ;
11181: LD_VAR 0 1
11185: PPUSH
11186: LD_INT 124
11188: PPUSH
11189: LD_INT 139
11191: PPUSH
11192: CALL_OW 111
11196: GO 11157
11198: POP
11199: POP
// wait ( 0 0$1 ) ;
11200: LD_INT 35
11202: PPUSH
11203: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
11207: LD_VAR 0 2
11211: PPUSH
11212: LD_INT 92
11214: PUSH
11215: LD_INT 124
11217: PUSH
11218: LD_INT 139
11220: PUSH
11221: LD_INT 9
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: LIST
11228: LIST
11229: PPUSH
11230: CALL_OW 72
11234: PUSH
11235: LD_VAR 0 2
11239: PUSH
11240: LD_INT 1
11242: MINUS
11243: GREATEREQUAL
11244: IFFALSE 11122
// end ; repeat wait ( 0 0$1 ) ;
11246: LD_INT 35
11248: PPUSH
11249: CALL_OW 67
// for i in tmp do
11253: LD_ADDR_VAR 0 1
11257: PUSH
11258: LD_VAR 0 2
11262: PUSH
11263: FOR_IN
11264: IFFALSE 11433
// begin if GetLives ( i ) > 251 then
11266: LD_VAR 0 1
11270: PPUSH
11271: CALL_OW 256
11275: PUSH
11276: LD_INT 251
11278: GREATER
11279: IFFALSE 11404
// begin if GetWeapon ( i ) = ru_time_lapser then
11281: LD_VAR 0 1
11285: PPUSH
11286: CALL_OW 264
11290: PUSH
11291: LD_INT 49
11293: EQUAL
11294: IFFALSE 11350
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11296: LD_VAR 0 1
11300: PPUSH
11301: LD_INT 2
11303: PUSH
11304: LD_INT 22
11306: PUSH
11307: LD_INT 1
11309: PUSH
11310: EMPTY
11311: LIST
11312: LIST
11313: PUSH
11314: LD_INT 22
11316: PUSH
11317: LD_INT 8
11319: PUSH
11320: EMPTY
11321: LIST
11322: LIST
11323: PUSH
11324: EMPTY
11325: LIST
11326: LIST
11327: LIST
11328: PPUSH
11329: CALL_OW 69
11333: PPUSH
11334: LD_VAR 0 1
11338: PPUSH
11339: CALL_OW 74
11343: PPUSH
11344: CALL_OW 112
11348: GO 11402
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11350: LD_VAR 0 1
11354: PPUSH
11355: LD_INT 2
11357: PUSH
11358: LD_INT 22
11360: PUSH
11361: LD_INT 1
11363: PUSH
11364: EMPTY
11365: LIST
11366: LIST
11367: PUSH
11368: LD_INT 22
11370: PUSH
11371: LD_INT 8
11373: PUSH
11374: EMPTY
11375: LIST
11376: LIST
11377: PUSH
11378: EMPTY
11379: LIST
11380: LIST
11381: LIST
11382: PPUSH
11383: CALL_OW 69
11387: PPUSH
11388: LD_VAR 0 1
11392: PPUSH
11393: CALL_OW 74
11397: PPUSH
11398: CALL_OW 115
// end else
11402: GO 11431
// if IsDead ( i ) then
11404: LD_VAR 0 1
11408: PPUSH
11409: CALL_OW 301
11413: IFFALSE 11431
// tmp := tmp diff i ;
11415: LD_ADDR_VAR 0 2
11419: PUSH
11420: LD_VAR 0 2
11424: PUSH
11425: LD_VAR 0 1
11429: DIFF
11430: ST_TO_ADDR
// end ;
11431: GO 11263
11433: POP
11434: POP
// until not tmp ;
11435: LD_VAR 0 2
11439: NOT
11440: IFFALSE 11246
// end ;
11442: PPOPN 4
11444: END
// export ruMobile ; every 0 0$01 trigger missionStage >= 7 and Difficulty > 1 do var i , veh , un ;
11445: LD_EXP 15
11449: PUSH
11450: LD_INT 7
11452: GREATEREQUAL
11453: PUSH
11454: LD_OWVAR 67
11458: PUSH
11459: LD_INT 1
11461: GREATER
11462: AND
11463: IFFALSE 11755
11465: GO 11467
11467: DISABLE
11468: LD_INT 0
11470: PPUSH
11471: PPUSH
11472: PPUSH
// begin ruMobile := [ ] ;
11473: LD_ADDR_EXP 76
11477: PUSH
11478: EMPTY
11479: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 ] [ Difficulty - 1 ] do
11480: LD_ADDR_VAR 0 1
11484: PUSH
11485: DOUBLE
11486: LD_INT 1
11488: DEC
11489: ST_TO_ADDR
11490: LD_INT 4
11492: PUSH
11493: LD_INT 5
11495: PUSH
11496: LD_INT 6
11498: PUSH
11499: EMPTY
11500: LIST
11501: LIST
11502: LIST
11503: PUSH
11504: LD_OWVAR 67
11508: PUSH
11509: LD_INT 1
11511: MINUS
11512: ARRAY
11513: PUSH
11514: FOR_TO
11515: IFFALSE 11753
// begin uc_side := 3 ;
11517: LD_ADDR_OWVAR 20
11521: PUSH
11522: LD_INT 3
11524: ST_TO_ADDR
// uc_nation := 1 ;
11525: LD_ADDR_OWVAR 21
11529: PUSH
11530: LD_INT 1
11532: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , [ us_laser , us_rocket_launcher ] [ i mod 2 + 1 ] , 100 ) ;
11533: LD_INT 5
11535: PPUSH
11536: LD_INT 3
11538: PPUSH
11539: LD_INT 1
11541: PPUSH
11542: LD_INT 9
11544: PUSH
11545: LD_INT 7
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_VAR 0 1
11556: PUSH
11557: LD_INT 2
11559: MOD
11560: PUSH
11561: LD_INT 1
11563: PLUS
11564: ARRAY
11565: PPUSH
11566: LD_INT 100
11568: PPUSH
11569: CALL 73738 0 5
// veh := CreateVehicle ;
11573: LD_ADDR_VAR 0 2
11577: PUSH
11578: CALL_OW 45
11582: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
11583: LD_VAR 0 2
11587: PPUSH
11588: LD_INT 3
11590: PPUSH
11591: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
11595: LD_VAR 0 2
11599: PPUSH
11600: LD_INT 29
11602: PPUSH
11603: LD_INT 0
11605: PPUSH
11606: CALL_OW 49
// uc_nation := 3 ;
11610: LD_ADDR_OWVAR 21
11614: PUSH
11615: LD_INT 3
11617: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
11618: LD_INT 0
11620: PPUSH
11621: LD_INT 10
11623: PPUSH
11624: CALL_OW 383
// un := CreateHuman ;
11628: LD_ADDR_VAR 0 3
11632: PUSH
11633: CALL_OW 44
11637: ST_TO_ADDR
// SetTag ( un , 105 ) ;
11638: LD_VAR 0 3
11642: PPUSH
11643: LD_INT 105
11645: PPUSH
11646: CALL_OW 109
// if GetSkill ( un , skill_mechanical ) < [ 8 , 9 , 10 ] [ Difficulty ] then
11650: LD_VAR 0 3
11654: PPUSH
11655: LD_INT 3
11657: PPUSH
11658: CALL_OW 259
11662: PUSH
11663: LD_INT 8
11665: PUSH
11666: LD_INT 9
11668: PUSH
11669: LD_INT 10
11671: PUSH
11672: EMPTY
11673: LIST
11674: LIST
11675: LIST
11676: PUSH
11677: LD_OWVAR 67
11681: ARRAY
11682: LESS
11683: IFFALSE 11717
// SetSkill ( un , skill_mechanical , [ 8 , 9 , 10 ] [ Difficulty ] ) ;
11685: LD_VAR 0 3
11689: PPUSH
11690: LD_INT 3
11692: PPUSH
11693: LD_INT 8
11695: PUSH
11696: LD_INT 9
11698: PUSH
11699: LD_INT 10
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: LIST
11706: PUSH
11707: LD_OWVAR 67
11711: ARRAY
11712: PPUSH
11713: CALL_OW 237
// PlaceHumanInUnit ( un , veh ) ;
11717: LD_VAR 0 3
11721: PPUSH
11722: LD_VAR 0 2
11726: PPUSH
11727: CALL_OW 52
// ruMobile := Join ( ruMobile , veh ) ;
11731: LD_ADDR_EXP 76
11735: PUSH
11736: LD_EXP 76
11740: PPUSH
11741: LD_VAR 0 2
11745: PPUSH
11746: CALL 106190 0 2
11750: ST_TO_ADDR
// end ;
11751: GO 11514
11753: POP
11754: POP
// end ;
11755: PPOPN 3
11757: END
// every 0 0$1 trigger ruMobile do var i , mech , enemy ;
11758: LD_EXP 76
11762: IFFALSE 12271
11764: GO 11766
11766: DISABLE
11767: LD_INT 0
11769: PPUSH
11770: PPUSH
11771: PPUSH
// begin enable ;
11772: ENABLE
// if not ruMobile then
11773: LD_EXP 76
11777: NOT
11778: IFFALSE 11783
// begin disable ;
11780: DISABLE
// exit ;
11781: GO 12271
// end ; for i in ruMobile do
11783: LD_ADDR_VAR 0 1
11787: PUSH
11788: LD_EXP 76
11792: PUSH
11793: FOR_IN
11794: IFFALSE 12269
// begin if not IsOk ( i ) or GetSide ( i ) <> 3 then
11796: LD_VAR 0 1
11800: PPUSH
11801: CALL_OW 302
11805: NOT
11806: PUSH
11807: LD_VAR 0 1
11811: PPUSH
11812: CALL_OW 255
11816: PUSH
11817: LD_INT 3
11819: NONEQUAL
11820: OR
11821: IFFALSE 11841
// begin ruMobile := ruMobile diff i ;
11823: LD_ADDR_EXP 76
11827: PUSH
11828: LD_EXP 76
11832: PUSH
11833: LD_VAR 0 1
11837: DIFF
11838: ST_TO_ADDR
// continue ;
11839: GO 11793
// end ; if GetTag ( i ) = 300 then
11841: LD_VAR 0 1
11845: PPUSH
11846: CALL_OW 110
11850: PUSH
11851: LD_INT 300
11853: EQUAL
11854: IFFALSE 11904
// begin ComMoveXY ( i , 160 , 81 ) ;
11856: LD_VAR 0 1
11860: PPUSH
11861: LD_INT 160
11863: PPUSH
11864: LD_INT 81
11866: PPUSH
11867: CALL_OW 111
// if GetDistUnitXY ( i , 160 , 81 ) < 8 then
11871: LD_VAR 0 1
11875: PPUSH
11876: LD_INT 160
11878: PPUSH
11879: LD_INT 81
11881: PPUSH
11882: CALL_OW 297
11886: PUSH
11887: LD_INT 8
11889: LESS
11890: IFFALSE 11904
// SetTag ( i , 301 ) ;
11892: LD_VAR 0 1
11896: PPUSH
11897: LD_INT 301
11899: PPUSH
11900: CALL_OW 109
// end ; if GetTag ( i ) = 301 then
11904: LD_VAR 0 1
11908: PPUSH
11909: CALL_OW 110
11913: PUSH
11914: LD_INT 301
11916: EQUAL
11917: IFFALSE 11960
// begin if not IsInArea ( i , ruMobileParkingArea ) then
11919: LD_VAR 0 1
11923: PPUSH
11924: LD_INT 33
11926: PPUSH
11927: CALL_OW 308
11931: NOT
11932: IFFALSE 11948
// ComMoveToArea ( i , ruMobileParkingArea ) else
11934: LD_VAR 0 1
11938: PPUSH
11939: LD_INT 33
11941: PPUSH
11942: CALL_OW 113
11946: GO 11960
// SetTag ( i , 302 ) ;
11948: LD_VAR 0 1
11952: PPUSH
11953: LD_INT 302
11955: PPUSH
11956: CALL_OW 109
// end ; if GetTag ( i ) = 302 then
11960: LD_VAR 0 1
11964: PPUSH
11965: CALL_OW 110
11969: PUSH
11970: LD_INT 302
11972: EQUAL
11973: IFFALSE 12103
// begin if GetLives ( i ) < 1000 then
11975: LD_VAR 0 1
11979: PPUSH
11980: CALL_OW 256
11984: PUSH
11985: LD_INT 1000
11987: LESS
11988: IFFALSE 12080
// begin if not IsDrivenBy ( i ) then
11990: LD_VAR 0 1
11994: PPUSH
11995: CALL_OW 311
11999: NOT
12000: IFFALSE 12004
// continue ;
12002: GO 11793
// mech := IsDrivenBy ( i ) ;
12004: LD_ADDR_VAR 0 2
12008: PUSH
12009: LD_VAR 0 1
12013: PPUSH
12014: CALL_OW 311
12018: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
12019: LD_VAR 0 2
12023: PPUSH
12024: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
12028: LD_VAR 0 2
12032: PPUSH
12033: LD_VAR 0 1
12037: PPUSH
12038: CALL_OW 189
// repeat wait ( 0 0$1 ) ;
12042: LD_INT 35
12044: PPUSH
12045: CALL_OW 67
// until GetLives ( i ) = 1000 ;
12049: LD_VAR 0 1
12053: PPUSH
12054: CALL_OW 256
12058: PUSH
12059: LD_INT 1000
12061: EQUAL
12062: IFFALSE 12042
// ComEnterUnit ( mech , i ) ;
12064: LD_VAR 0 2
12068: PPUSH
12069: LD_VAR 0 1
12073: PPUSH
12074: CALL_OW 120
// end else
12078: GO 12103
// if IsDrivenBy ( i ) then
12080: LD_VAR 0 1
12084: PPUSH
12085: CALL_OW 311
12089: IFFALSE 12103
// SetTag ( i , 0 ) ;
12091: LD_VAR 0 1
12095: PPUSH
12096: LD_INT 0
12098: PPUSH
12099: CALL_OW 109
// end ; if GetTag ( i ) < 300 then
12103: LD_VAR 0 1
12107: PPUSH
12108: CALL_OW 110
12112: PUSH
12113: LD_INT 300
12115: LESS
12116: IFFALSE 12267
// begin enemy := FilterUnitsInArea ( russianBaseArea , [ f_enemy , 3 ] ) ;
12118: LD_ADDR_VAR 0 3
12122: PUSH
12123: LD_INT 4
12125: PPUSH
12126: LD_INT 81
12128: PUSH
12129: LD_INT 3
12131: PUSH
12132: EMPTY
12133: LIST
12134: LIST
12135: PPUSH
12136: CALL_OW 70
12140: ST_TO_ADDR
// if GetLives ( i ) < 650 then
12141: LD_VAR 0 1
12145: PPUSH
12146: CALL_OW 256
12150: PUSH
12151: LD_INT 650
12153: LESS
12154: IFFALSE 12179
// begin ComStop ( i ) ;
12156: LD_VAR 0 1
12160: PPUSH
12161: CALL_OW 141
// SetTag ( i , 300 ) ;
12165: LD_VAR 0 1
12169: PPUSH
12170: LD_INT 300
12172: PPUSH
12173: CALL_OW 109
// continue ;
12177: GO 11793
// end ; if enemy then
12179: LD_VAR 0 3
12183: IFFALSE 12223
// begin if not HasTask ( i ) then
12185: LD_VAR 0 1
12189: PPUSH
12190: CALL_OW 314
12194: NOT
12195: IFFALSE 12221
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
12197: LD_VAR 0 1
12201: PPUSH
12202: LD_VAR 0 3
12206: PPUSH
12207: LD_VAR 0 1
12211: PPUSH
12212: CALL_OW 74
12216: PPUSH
12217: CALL_OW 115
// end else
12221: GO 12267
// AgressiveMove ( i , [ [ 158 , 61 ] , [ 98 , 100 ] , [ 78 , 93 ] ] ) ;
12223: LD_VAR 0 1
12227: PPUSH
12228: LD_INT 158
12230: PUSH
12231: LD_INT 61
12233: PUSH
12234: EMPTY
12235: LIST
12236: LIST
12237: PUSH
12238: LD_INT 98
12240: PUSH
12241: LD_INT 100
12243: PUSH
12244: EMPTY
12245: LIST
12246: LIST
12247: PUSH
12248: LD_INT 78
12250: PUSH
12251: LD_INT 93
12253: PUSH
12254: EMPTY
12255: LIST
12256: LIST
12257: PUSH
12258: EMPTY
12259: LIST
12260: LIST
12261: LIST
12262: PPUSH
12263: CALL 108794 0 2
// end ; end ;
12267: GO 11793
12269: POP
12270: POP
// end ; end_of_file
12271: PPOPN 3
12273: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport , b ; begin
12274: LD_INT 0
12276: PPUSH
12277: PPUSH
12278: PPUSH
12279: PPUSH
12280: PPUSH
12281: PPUSH
12282: PPUSH
// side := 7 ;
12283: LD_ADDR_VAR 0 5
12287: PUSH
12288: LD_INT 7
12290: ST_TO_ADDR
// uc_side := side ;
12291: LD_ADDR_OWVAR 20
12295: PUSH
12296: LD_VAR 0 5
12300: ST_TO_ADDR
// uc_nation := 1 ;
12301: LD_ADDR_OWVAR 21
12305: PUSH
12306: LD_INT 1
12308: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
12309: LD_ADDR_VAR 0 2
12313: PUSH
12314: LD_INT 22
12316: PUSH
12317: LD_VAR 0 5
12321: PUSH
12322: EMPTY
12323: LIST
12324: LIST
12325: PUSH
12326: LD_INT 21
12328: PUSH
12329: LD_INT 3
12331: PUSH
12332: EMPTY
12333: LIST
12334: LIST
12335: PUSH
12336: EMPTY
12337: LIST
12338: LIST
12339: PPUSH
12340: CALL_OW 69
12344: PUSH
12345: FOR_IN
12346: IFFALSE 12362
// SetBLevel ( i , 10 ) ;
12348: LD_VAR 0 2
12352: PPUSH
12353: LD_INT 10
12355: PPUSH
12356: CALL_OW 241
12360: GO 12345
12362: POP
12363: POP
// base := GetBase ( al_depot ) ;
12364: LD_ADDR_VAR 0 4
12368: PUSH
12369: LD_INT 2
12371: PPUSH
12372: CALL_OW 274
12376: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
12377: LD_ADDR_VAR 0 6
12381: PUSH
12382: LD_INT 22
12384: PUSH
12385: LD_VAR 0 5
12389: PUSH
12390: EMPTY
12391: LIST
12392: LIST
12393: PUSH
12394: LD_INT 30
12396: PUSH
12397: LD_INT 34
12399: PUSH
12400: EMPTY
12401: LIST
12402: LIST
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PPUSH
12408: CALL_OW 69
12412: ST_TO_ADDR
// if teleport then
12413: LD_VAR 0 6
12417: IFFALSE 12438
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
12419: LD_VAR 0 6
12423: PUSH
12424: LD_INT 1
12426: ARRAY
12427: PPUSH
12428: LD_INT 262
12430: PPUSH
12431: LD_INT 119
12433: PPUSH
12434: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
12438: LD_VAR 0 4
12442: PPUSH
12443: LD_INT 1
12445: PPUSH
12446: LD_INT 19500
12448: PPUSH
12449: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
12453: LD_VAR 0 4
12457: PPUSH
12458: LD_INT 2
12460: PPUSH
12461: LD_INT 200
12463: PPUSH
12464: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
12468: LD_VAR 0 4
12472: PPUSH
12473: LD_INT 3
12475: PPUSH
12476: LD_INT 650
12478: PPUSH
12479: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
12483: LD_ADDR_EXP 77
12487: PUSH
12488: LD_STRING Roth
12490: PPUSH
12491: CALL_OW 25
12495: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
12496: LD_ADDR_EXP 78
12500: PUSH
12501: LD_STRING Simms
12503: PPUSH
12504: LD_EXP 1
12508: NOT
12509: PPUSH
12510: LD_STRING 10c_
12512: PPUSH
12513: CALL 68898 0 3
12517: ST_TO_ADDR
// SetClass ( Simms , class_scientistic ) ;
12518: LD_EXP 78
12522: PPUSH
12523: LD_INT 4
12525: PPUSH
12526: CALL_OW 336
// if not Simms then
12530: LD_EXP 78
12534: NOT
12535: IFFALSE 12565
// begin uc_nation := 1 ;
12537: LD_ADDR_OWVAR 21
12541: PUSH
12542: LD_INT 1
12544: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
12545: LD_INT 2
12547: PPUSH
12548: LD_INT 10
12550: PPUSH
12551: CALL_OW 384
// Simms := CreateHuman ;
12555: LD_ADDR_EXP 78
12559: PUSH
12560: CALL_OW 44
12564: ST_TO_ADDR
// end ; uc_nation := 3 ;
12565: LD_ADDR_OWVAR 21
12569: PUSH
12570: LD_INT 3
12572: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
12573: LD_ADDR_EXP 79
12577: PUSH
12578: LD_STRING Kirilenkova
12580: PPUSH
12581: CALL_OW 25
12585: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
12586: LD_ADDR_EXP 93
12590: PUSH
12591: LD_STRING Oblukov
12593: PPUSH
12594: CALL_OW 25
12598: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
12599: LD_ADDR_EXP 80
12603: PUSH
12604: LD_STRING Dolgov
12606: PPUSH
12607: CALL_OW 25
12611: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
12612: LD_ADDR_EXP 81
12616: PUSH
12617: LD_STRING Petrosyan
12619: PPUSH
12620: CALL_OW 25
12624: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
12625: LD_ADDR_EXP 92
12629: PUSH
12630: LD_STRING Scholtze
12632: PPUSH
12633: CALL_OW 25
12637: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
12638: LD_ADDR_EXP 91
12642: PUSH
12643: LD_STRING Kapitsova
12645: PPUSH
12646: CALL_OW 25
12650: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
12651: LD_ADDR_EXP 82
12655: PUSH
12656: LD_STRING Petrovova
12658: PPUSH
12659: CALL_OW 25
12663: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
12664: LD_ADDR_EXP 83
12668: PUSH
12669: LD_STRING Kuzmov
12671: PPUSH
12672: CALL_OW 25
12676: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
12677: LD_ADDR_EXP 90
12681: PUSH
12682: LD_STRING Karamazov
12684: PPUSH
12685: CALL_OW 25
12689: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
12690: LD_STRING 13_Lipshchin_1
12692: PPUSH
12693: LD_INT 0
12695: PPUSH
12696: CALL_OW 30
12700: IFFALSE 12715
// Lipshchin := NewCharacter ( Lipshchin ) ;
12702: LD_ADDR_EXP 84
12706: PUSH
12707: LD_STRING Lipshchin
12709: PPUSH
12710: CALL_OW 25
12714: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
12715: LD_STRING 13_Titov_1
12717: PPUSH
12718: LD_INT 0
12720: PPUSH
12721: CALL_OW 30
12725: IFFALSE 12740
// Titov := NewCharacter ( Titov ) ;
12727: LD_ADDR_EXP 86
12731: PUSH
12732: LD_STRING Titov
12734: PPUSH
12735: CALL_OW 25
12739: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
12740: LD_STRING 13_Gnyevko_1
12742: PPUSH
12743: LD_INT 0
12745: PPUSH
12746: CALL_OW 30
12750: IFFALSE 12765
// Gnyevko := NewCharacter ( Gnyevko ) ;
12752: LD_ADDR_EXP 85
12756: PUSH
12757: LD_STRING Gnyevko
12759: PPUSH
12760: CALL_OW 25
12764: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
12765: LD_STRING 13_Xavier_1
12767: PPUSH
12768: LD_INT 0
12770: PPUSH
12771: CALL_OW 30
12775: IFFALSE 12790
// Xavier := NewCharacter ( Xavier2 ) ;
12777: LD_ADDR_EXP 87
12781: PUSH
12782: LD_STRING Xavier2
12784: PPUSH
12785: CALL_OW 25
12789: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
12790: LD_STRING 13_Belkov_1
12792: PPUSH
12793: LD_INT 0
12795: PPUSH
12796: CALL_OW 30
12800: IFFALSE 12815
// Belkov := NewCharacter ( Belkov ) ;
12802: LD_ADDR_EXP 88
12806: PUSH
12807: LD_STRING Belkov
12809: PPUSH
12810: CALL_OW 25
12814: ST_TO_ADDR
// if not BurlakStatus then
12815: LD_EXP 9
12819: NOT
12820: IFFALSE 12835
// Burlak = NewCharacter ( Burlak ) ;
12822: LD_ADDR_EXP 89
12826: PUSH
12827: LD_STRING Burlak
12829: PPUSH
12830: CALL_OW 25
12834: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
12835: LD_ADDR_VAR 0 3
12839: PUSH
12840: LD_EXP 77
12844: PUSH
12845: LD_EXP 79
12849: PUSH
12850: LD_EXP 93
12854: PUSH
12855: LD_EXP 80
12859: PUSH
12860: LD_EXP 81
12864: PUSH
12865: LD_EXP 92
12869: PUSH
12870: LD_EXP 91
12874: PUSH
12875: LD_EXP 82
12879: PUSH
12880: LD_EXP 83
12884: PUSH
12885: LD_EXP 90
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: LIST
12894: LIST
12895: LIST
12896: LIST
12897: LIST
12898: LIST
12899: LIST
12900: LIST
12901: ST_TO_ADDR
// if Simms then
12902: LD_EXP 78
12906: IFFALSE 12924
// tmp := tmp ^ Simms ;
12908: LD_ADDR_VAR 0 3
12912: PUSH
12913: LD_VAR 0 3
12917: PUSH
12918: LD_EXP 78
12922: ADD
12923: ST_TO_ADDR
// if Titov then
12924: LD_EXP 86
12928: IFFALSE 12946
// tmp := tmp ^ Titov ;
12930: LD_ADDR_VAR 0 3
12934: PUSH
12935: LD_VAR 0 3
12939: PUSH
12940: LD_EXP 86
12944: ADD
12945: ST_TO_ADDR
// if Lipshchin then
12946: LD_EXP 84
12950: IFFALSE 12968
// tmp := tmp ^ Lipshchin ;
12952: LD_ADDR_VAR 0 3
12956: PUSH
12957: LD_VAR 0 3
12961: PUSH
12962: LD_EXP 84
12966: ADD
12967: ST_TO_ADDR
// if Gnyevko then
12968: LD_EXP 85
12972: IFFALSE 12990
// tmp := tmp ^ Gnyevko ;
12974: LD_ADDR_VAR 0 3
12978: PUSH
12979: LD_VAR 0 3
12983: PUSH
12984: LD_EXP 85
12988: ADD
12989: ST_TO_ADDR
// if Xavier then
12990: LD_EXP 87
12994: IFFALSE 13012
// tmp := tmp ^ Xavier ;
12996: LD_ADDR_VAR 0 3
13000: PUSH
13001: LD_VAR 0 3
13005: PUSH
13006: LD_EXP 87
13010: ADD
13011: ST_TO_ADDR
// if Belkov then
13012: LD_EXP 88
13016: IFFALSE 13034
// tmp := tmp ^ Belkov ;
13018: LD_ADDR_VAR 0 3
13022: PUSH
13023: LD_VAR 0 3
13027: PUSH
13028: LD_EXP 88
13032: ADD
13033: ST_TO_ADDR
// if Burlak then
13034: LD_EXP 89
13038: IFFALSE 13056
// tmp := tmp ^ Burlak ;
13040: LD_ADDR_VAR 0 3
13044: PUSH
13045: LD_VAR 0 3
13049: PUSH
13050: LD_EXP 89
13054: ADD
13055: ST_TO_ADDR
// for i = 1 to 11 do
13056: LD_ADDR_VAR 0 2
13060: PUSH
13061: DOUBLE
13062: LD_INT 1
13064: DEC
13065: ST_TO_ADDR
13066: LD_INT 11
13068: PUSH
13069: FOR_TO
13070: IFFALSE 13138
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
13072: LD_ADDR_OWVAR 21
13076: PUSH
13077: LD_INT 1
13079: PUSH
13080: LD_INT 3
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: PUSH
13087: LD_INT 1
13089: PPUSH
13090: LD_INT 2
13092: PPUSH
13093: CALL_OW 12
13097: ARRAY
13098: ST_TO_ADDR
// PrepareHuman ( false , rand ( 1 , 4 ) , 10 ) ;
13099: LD_INT 0
13101: PPUSH
13102: LD_INT 1
13104: PPUSH
13105: LD_INT 4
13107: PPUSH
13108: CALL_OW 12
13112: PPUSH
13113: LD_INT 10
13115: PPUSH
13116: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
13120: LD_ADDR_VAR 0 3
13124: PUSH
13125: LD_VAR 0 3
13129: PUSH
13130: CALL_OW 44
13134: ADD
13135: ST_TO_ADDR
// end ;
13136: GO 13069
13138: POP
13139: POP
// for i in tmp do
13140: LD_ADDR_VAR 0 2
13144: PUSH
13145: LD_VAR 0 3
13149: PUSH
13150: FOR_IN
13151: IFFALSE 13176
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
13153: LD_VAR 0 2
13157: PPUSH
13158: LD_INT 260
13160: PPUSH
13161: LD_INT 235
13163: PPUSH
13164: LD_INT 8
13166: PPUSH
13167: LD_INT 0
13169: PPUSH
13170: CALL_OW 50
13174: GO 13150
13176: POP
13177: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
13178: LD_ADDR_EXP 100
13182: PUSH
13183: LD_EXP 100
13187: PPUSH
13188: LD_INT 1
13190: PPUSH
13191: LD_INT 22
13193: PUSH
13194: LD_VAR 0 5
13198: PUSH
13199: EMPTY
13200: LIST
13201: LIST
13202: PUSH
13203: LD_INT 3
13205: PUSH
13206: LD_INT 21
13208: PUSH
13209: LD_INT 2
13211: PUSH
13212: EMPTY
13213: LIST
13214: LIST
13215: PUSH
13216: EMPTY
13217: LIST
13218: LIST
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PPUSH
13224: CALL_OW 69
13228: PUSH
13229: LD_EXP 77
13233: PUSH
13234: LD_EXP 78
13238: PUSH
13239: EMPTY
13240: LIST
13241: LIST
13242: DIFF
13243: PPUSH
13244: CALL_OW 1
13248: ST_TO_ADDR
// uc_side := 0 ;
13249: LD_ADDR_OWVAR 20
13253: PUSH
13254: LD_INT 0
13256: ST_TO_ADDR
// uc_nation := 0 ;
13257: LD_ADDR_OWVAR 21
13261: PUSH
13262: LD_INT 0
13264: ST_TO_ADDR
// for i = 1 to 5 do
13265: LD_ADDR_VAR 0 2
13269: PUSH
13270: DOUBLE
13271: LD_INT 1
13273: DEC
13274: ST_TO_ADDR
13275: LD_INT 5
13277: PUSH
13278: FOR_TO
13279: IFFALSE 13316
// begin InitHc ;
13281: CALL_OW 19
// hc_class := class_apeman ;
13285: LD_ADDR_OWVAR 28
13289: PUSH
13290: LD_INT 12
13292: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
13293: CALL_OW 44
13297: PPUSH
13298: LD_INT 299
13300: PPUSH
13301: LD_INT 229
13303: PPUSH
13304: LD_INT 10
13306: PPUSH
13307: LD_INT 0
13309: PPUSH
13310: CALL_OW 50
// end ;
13314: GO 13278
13316: POP
13317: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
13318: LD_EXP 77
13322: PPUSH
13323: LD_INT 259
13325: PPUSH
13326: LD_INT 235
13328: PPUSH
13329: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
13333: LD_EXP 77
13337: PPUSH
13338: LD_INT 262
13340: PPUSH
13341: LD_INT 235
13343: PPUSH
13344: CALL_OW 178
// if Simms then
13348: LD_EXP 78
13352: IFFALSE 13383
// begin ComMoveXY ( Simms , 262 , 235 ) ;
13354: LD_EXP 78
13358: PPUSH
13359: LD_INT 262
13361: PPUSH
13362: LD_INT 235
13364: PPUSH
13365: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
13369: LD_EXP 78
13373: PPUSH
13374: LD_EXP 77
13378: PPUSH
13379: CALL_OW 179
// end ; uc_side := 7 ;
13383: LD_ADDR_OWVAR 20
13387: PUSH
13388: LD_INT 7
13390: ST_TO_ADDR
// uc_nation := 1 ;
13391: LD_ADDR_OWVAR 21
13395: PUSH
13396: LD_INT 1
13398: ST_TO_ADDR
// bc_type := b_control_tower ;
13399: LD_ADDR_OWVAR 42
13403: PUSH
13404: LD_INT 36
13406: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 268 , 251 , 4 ) ;
13407: LD_ADDR_VAR 0 7
13411: PUSH
13412: LD_INT 268
13414: PPUSH
13415: LD_INT 251
13417: PPUSH
13418: LD_INT 4
13420: PPUSH
13421: CALL_OW 47
13425: ST_TO_ADDR
// PrepareMechanic ( false , 10 ) ;
13426: LD_INT 0
13428: PPUSH
13429: LD_INT 10
13431: PPUSH
13432: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , b ) ;
13436: CALL_OW 44
13440: PPUSH
13441: LD_VAR 0 7
13445: PPUSH
13446: CALL_OW 52
// end ;
13450: LD_VAR 0 1
13454: RET
// every 9 9$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
13455: LD_EXP 31
13459: PUSH
13460: LD_EXP 23
13464: NOT
13465: AND
13466: IFFALSE 13694
13468: GO 13470
13470: DISABLE
13471: LD_INT 0
13473: PPUSH
13474: PPUSH
13475: PPUSH
// begin enable ;
13476: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
13477: LD_ADDR_VAR 0 2
13481: PUSH
13482: LD_INT 81
13484: PUSH
13485: LD_INT 7
13487: PUSH
13488: EMPTY
13489: LIST
13490: LIST
13491: PUSH
13492: LD_INT 2
13494: PUSH
13495: LD_INT 32
13497: PUSH
13498: LD_INT 3
13500: PUSH
13501: EMPTY
13502: LIST
13503: LIST
13504: PUSH
13505: LD_INT 30
13507: PUSH
13508: LD_INT 30
13510: PUSH
13511: EMPTY
13512: LIST
13513: LIST
13514: PUSH
13515: LD_INT 30
13517: PUSH
13518: LD_INT 28
13520: PUSH
13521: EMPTY
13522: LIST
13523: LIST
13524: PUSH
13525: LD_INT 34
13527: PUSH
13528: LD_INT 49
13530: PUSH
13531: EMPTY
13532: LIST
13533: LIST
13534: PUSH
13535: LD_INT 34
13537: PUSH
13538: LD_INT 10
13540: PUSH
13541: EMPTY
13542: LIST
13543: LIST
13544: PUSH
13545: LD_INT 34
13547: PUSH
13548: LD_INT 8
13550: PUSH
13551: EMPTY
13552: LIST
13553: LIST
13554: PUSH
13555: EMPTY
13556: LIST
13557: LIST
13558: LIST
13559: LIST
13560: LIST
13561: LIST
13562: LIST
13563: PUSH
13564: EMPTY
13565: LIST
13566: LIST
13567: PPUSH
13568: CALL_OW 69
13572: ST_TO_ADDR
// if not tmp then
13573: LD_VAR 0 2
13577: NOT
13578: IFFALSE 13582
// exit ;
13580: GO 13694
// if UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) then
13582: LD_VAR 0 2
13586: PPUSH
13587: LD_INT 34
13589: PUSH
13590: LD_INT 8
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PPUSH
13597: CALL_OW 72
13601: IFFALSE 13634
// target := UnitFilter ( tmp , [ f_weapon , us_siberium_rocket ] ) [ 1 ] else
13603: LD_ADDR_VAR 0 3
13607: PUSH
13608: LD_VAR 0 2
13612: PPUSH
13613: LD_INT 34
13615: PUSH
13616: LD_INT 8
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: PPUSH
13623: CALL_OW 72
13627: PUSH
13628: LD_INT 1
13630: ARRAY
13631: ST_TO_ADDR
13632: GO 13658
// target := tmp [ rand ( 1 , tmp ) ] ;
13634: LD_ADDR_VAR 0 3
13638: PUSH
13639: LD_VAR 0 2
13643: PUSH
13644: LD_INT 1
13646: PPUSH
13647: LD_VAR 0 2
13651: PPUSH
13652: CALL_OW 12
13656: ARRAY
13657: ST_TO_ADDR
// if GetSide ( target ) = 1 then
13658: LD_VAR 0 3
13662: PPUSH
13663: CALL_OW 255
13667: PUSH
13668: LD_INT 1
13670: EQUAL
13671: IFFALSE 13682
// CenterNowOnUnits ( target ) ;
13673: LD_VAR 0 3
13677: PPUSH
13678: CALL_OW 87
// SetLives ( target , 0 ) ;
13682: LD_VAR 0 3
13686: PPUSH
13687: LD_INT 0
13689: PPUSH
13690: CALL_OW 234
// end ;
13694: PPOPN 3
13696: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
13697: LD_EXP 23
13701: NOT
13702: PUSH
13703: LD_EXP 31
13707: AND
13708: IFFALSE 14224
13710: GO 13712
13712: DISABLE
13713: LD_INT 0
13715: PPUSH
13716: PPUSH
13717: PPUSH
// begin uc_side := 7 ;
13718: LD_ADDR_OWVAR 20
13722: PUSH
13723: LD_INT 7
13725: ST_TO_ADDR
// uc_nation := 1 ;
13726: LD_ADDR_OWVAR 21
13730: PUSH
13731: LD_INT 1
13733: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] , [ 94 , 114 ] ] ) ;
13734: LD_ADDR_VAR 0 3
13738: PUSH
13739: LD_INT 125
13741: PUSH
13742: LD_INT 163
13744: PUSH
13745: EMPTY
13746: LIST
13747: LIST
13748: PUSH
13749: LD_INT 185
13751: PUSH
13752: LD_INT 168
13754: PUSH
13755: EMPTY
13756: LIST
13757: LIST
13758: PUSH
13759: LD_INT 111
13761: PUSH
13762: LD_INT 97
13764: PUSH
13765: EMPTY
13766: LIST
13767: LIST
13768: PUSH
13769: LD_INT 94
13771: PUSH
13772: LD_INT 114
13774: PUSH
13775: EMPTY
13776: LIST
13777: LIST
13778: PUSH
13779: EMPTY
13780: LIST
13781: LIST
13782: LIST
13783: LIST
13784: PPUSH
13785: CALL 106295 0 1
13789: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
13790: LD_ADDR_EXP 94
13794: PUSH
13795: EMPTY
13796: ST_TO_ADDR
// for i = 1 to Difficulty do
13797: LD_ADDR_VAR 0 1
13801: PUSH
13802: DOUBLE
13803: LD_INT 1
13805: DEC
13806: ST_TO_ADDR
13807: LD_OWVAR 67
13811: PUSH
13812: FOR_TO
13813: IFFALSE 13971
// begin InitHc ;
13815: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
13819: LD_INT 0
13821: PPUSH
13822: LD_INT 8
13824: PPUSH
13825: CALL_OW 381
// un := CreateHuman ;
13829: LD_ADDR_VAR 0 2
13833: PUSH
13834: CALL_OW 44
13838: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
13839: LD_VAR 0 2
13843: PPUSH
13844: LD_INT 258
13846: PPUSH
13847: LD_INT 267
13849: PPUSH
13850: LD_INT 4
13852: PPUSH
13853: LD_INT 0
13855: PPUSH
13856: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
13860: LD_ADDR_EXP 94
13864: PUSH
13865: LD_EXP 94
13869: PUSH
13870: LD_VAR 0 2
13874: UNION
13875: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
13876: LD_VAR 0 2
13880: PPUSH
13881: LD_VAR 0 3
13885: PUSH
13886: LD_VAR 0 1
13890: ARRAY
13891: PUSH
13892: LD_INT 1
13894: ARRAY
13895: PPUSH
13896: LD_VAR 0 3
13900: PUSH
13901: LD_VAR 0 1
13905: ARRAY
13906: PUSH
13907: LD_INT 2
13909: ARRAY
13910: PPUSH
13911: LD_INT 4
13913: PPUSH
13914: LD_INT 1
13916: PPUSH
13917: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
13921: LD_VAR 0 2
13925: PPUSH
13926: LD_VAR 0 3
13930: PUSH
13931: LD_VAR 0 1
13935: ARRAY
13936: PUSH
13937: LD_INT 1
13939: ARRAY
13940: PPUSH
13941: LD_VAR 0 3
13945: PUSH
13946: LD_VAR 0 1
13950: ARRAY
13951: PUSH
13952: LD_INT 2
13954: ARRAY
13955: PPUSH
13956: CALL_OW 171
// AddComInvisible ( un ) ;
13960: LD_VAR 0 2
13964: PPUSH
13965: CALL_OW 212
// end ;
13969: GO 13812
13971: POP
13972: POP
// repeat wait ( 0 0$45 ) ;
13973: LD_INT 1575
13975: PPUSH
13976: CALL_OW 67
// for i in allianceSpecialForce do
13980: LD_ADDR_VAR 0 1
13984: PUSH
13985: LD_EXP 94
13989: PUSH
13990: FOR_IN
13991: IFFALSE 14209
// begin if IsInvisible ( i ) then
13993: LD_VAR 0 1
13997: PPUSH
13998: CALL_OW 571
14002: IFFALSE 14178
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , 25 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
14004: LD_ADDR_VAR 0 3
14008: PUSH
14009: LD_INT 22
14011: PUSH
14012: LD_INT 1
14014: PUSH
14015: EMPTY
14016: LIST
14017: LIST
14018: PUSH
14019: LD_INT 50
14021: PUSH
14022: EMPTY
14023: LIST
14024: PUSH
14025: LD_INT 56
14027: PUSH
14028: EMPTY
14029: LIST
14030: PUSH
14031: LD_INT 91
14033: PUSH
14034: LD_VAR 0 1
14038: PUSH
14039: LD_INT 25
14041: PUSH
14042: EMPTY
14043: LIST
14044: LIST
14045: LIST
14046: PUSH
14047: LD_INT 2
14049: PUSH
14050: LD_INT 25
14052: PUSH
14053: LD_INT 1
14055: PUSH
14056: EMPTY
14057: LIST
14058: LIST
14059: PUSH
14060: LD_INT 25
14062: PUSH
14063: LD_INT 2
14065: PUSH
14066: EMPTY
14067: LIST
14068: LIST
14069: PUSH
14070: LD_INT 25
14072: PUSH
14073: LD_INT 3
14075: PUSH
14076: EMPTY
14077: LIST
14078: LIST
14079: PUSH
14080: LD_INT 25
14082: PUSH
14083: LD_INT 4
14085: PUSH
14086: EMPTY
14087: LIST
14088: LIST
14089: PUSH
14090: LD_INT 25
14092: PUSH
14093: LD_INT 5
14095: PUSH
14096: EMPTY
14097: LIST
14098: LIST
14099: PUSH
14100: LD_INT 25
14102: PUSH
14103: LD_INT 8
14105: PUSH
14106: EMPTY
14107: LIST
14108: LIST
14109: PUSH
14110: EMPTY
14111: LIST
14112: LIST
14113: LIST
14114: LIST
14115: LIST
14116: LIST
14117: LIST
14118: PUSH
14119: EMPTY
14120: LIST
14121: LIST
14122: LIST
14123: LIST
14124: LIST
14125: PPUSH
14126: CALL_OW 69
14130: ST_TO_ADDR
// if not tmp then
14131: LD_VAR 0 3
14135: NOT
14136: IFFALSE 14140
// continue ;
14138: GO 13990
// if Prob ( 30 * Difficulty ) then
14140: LD_INT 30
14142: PUSH
14143: LD_OWVAR 67
14147: MUL
14148: PPUSH
14149: CALL_OW 13
14153: IFFALSE 14178
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
14155: LD_VAR 0 3
14159: PUSH
14160: LD_INT 1
14162: PPUSH
14163: LD_VAR 0 3
14167: PPUSH
14168: CALL_OW 12
14172: ARRAY
14173: PPUSH
14174: CALL 34081 0 1
// end ; if IsDead ( i ) then
14178: LD_VAR 0 1
14182: PPUSH
14183: CALL_OW 301
14187: IFFALSE 14207
// begin allianceSpecialForce := allianceSpecialForce diff i ;
14189: LD_ADDR_EXP 94
14193: PUSH
14194: LD_EXP 94
14198: PUSH
14199: LD_VAR 0 1
14203: DIFF
14204: ST_TO_ADDR
// continue ;
14205: GO 13990
// end ; end ;
14207: GO 13990
14209: POP
14210: POP
// until allianceDestroyed or not allianceSpecialForce ;
14211: LD_EXP 23
14215: PUSH
14216: LD_EXP 94
14220: NOT
14221: OR
14222: IFFALSE 13973
// end ;
14224: PPOPN 3
14226: END
// every 0 0$30 trigger allianceActive and FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_bweapon , us_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ] ) do var i , un , tmp , e ;
14227: LD_EXP 31
14231: PUSH
14232: LD_INT 22
14234: PUSH
14235: LD_INT 1
14237: PUSH
14238: EMPTY
14239: LIST
14240: LIST
14241: PUSH
14242: LD_INT 2
14244: PUSH
14245: LD_INT 35
14247: PUSH
14248: LD_INT 8
14250: PUSH
14251: EMPTY
14252: LIST
14253: LIST
14254: PUSH
14255: LD_INT 34
14257: PUSH
14258: LD_INT 8
14260: PUSH
14261: EMPTY
14262: LIST
14263: LIST
14264: PUSH
14265: EMPTY
14266: LIST
14267: LIST
14268: LIST
14269: PUSH
14270: EMPTY
14271: LIST
14272: LIST
14273: PPUSH
14274: CALL_OW 69
14278: AND
14279: IFFALSE 14679
14281: GO 14283
14283: DISABLE
14284: LD_INT 0
14286: PPUSH
14287: PPUSH
14288: PPUSH
14289: PPUSH
// begin for i := 1 to [ 6 , 8 , 10 , 12 ] [ Difficulty ] do
14290: LD_ADDR_VAR 0 1
14294: PUSH
14295: DOUBLE
14296: LD_INT 1
14298: DEC
14299: ST_TO_ADDR
14300: LD_INT 6
14302: PUSH
14303: LD_INT 8
14305: PUSH
14306: LD_INT 10
14308: PUSH
14309: LD_INT 12
14311: PUSH
14312: EMPTY
14313: LIST
14314: LIST
14315: LIST
14316: LIST
14317: PUSH
14318: LD_OWVAR 67
14322: ARRAY
14323: PUSH
14324: FOR_TO
14325: IFFALSE 14517
// begin uc_side := 7 ;
14327: LD_ADDR_OWVAR 20
14331: PUSH
14332: LD_INT 7
14334: ST_TO_ADDR
// uc_nation := 1 ;
14335: LD_ADDR_OWVAR 21
14339: PUSH
14340: LD_INT 1
14342: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , [ control_remote , control_computer ] [ rand ( 1 , 2 ) ] , [ us_heavy_gun , us_laser ] [ rand ( 1 , 2 ) ] , 100 ) ;
14343: LD_INT 5
14345: PPUSH
14346: LD_INT 3
14348: PPUSH
14349: LD_INT 2
14351: PUSH
14352: LD_INT 3
14354: PUSH
14355: EMPTY
14356: LIST
14357: LIST
14358: PUSH
14359: LD_INT 1
14361: PPUSH
14362: LD_INT 2
14364: PPUSH
14365: CALL_OW 12
14369: ARRAY
14370: PPUSH
14371: LD_INT 6
14373: PUSH
14374: LD_INT 9
14376: PUSH
14377: EMPTY
14378: LIST
14379: LIST
14380: PUSH
14381: LD_INT 1
14383: PPUSH
14384: LD_INT 2
14386: PPUSH
14387: CALL_OW 12
14391: ARRAY
14392: PPUSH
14393: LD_INT 100
14395: PPUSH
14396: CALL 73738 0 5
// un := CreateVehicle ;
14400: LD_ADDR_VAR 0 2
14404: PUSH
14405: CALL_OW 45
14409: ST_TO_ADDR
// SetDir ( un , 4 ) ;
14410: LD_VAR 0 2
14414: PPUSH
14415: LD_INT 4
14417: PPUSH
14418: CALL_OW 233
// PlaceUnitXYR ( un , 307 , 219 , 6 , false ) ;
14422: LD_VAR 0 2
14426: PPUSH
14427: LD_INT 307
14429: PPUSH
14430: LD_INT 219
14432: PPUSH
14433: LD_INT 6
14435: PPUSH
14436: LD_INT 0
14438: PPUSH
14439: CALL_OW 50
// if GetControl ( un ) = control_remote then
14443: LD_VAR 0 2
14447: PPUSH
14448: CALL_OW 263
14452: PUSH
14453: LD_INT 2
14455: EQUAL
14456: IFFALSE 14467
// Connect ( un ) ;
14458: LD_VAR 0 2
14462: PPUSH
14463: CALL 76829 0 1
// TeleportUnit ( un , 124 , 92 , 12 , true ) ;
14467: LD_VAR 0 2
14471: PPUSH
14472: LD_INT 124
14474: PPUSH
14475: LD_INT 92
14477: PPUSH
14478: LD_INT 12
14480: PPUSH
14481: LD_INT 1
14483: PPUSH
14484: CALL_OW 483
// tmp := Join ( tmp , un ) ;
14488: LD_ADDR_VAR 0 3
14492: PUSH
14493: LD_VAR 0 3
14497: PPUSH
14498: LD_VAR 0 2
14502: PPUSH
14503: CALL 106190 0 2
14507: ST_TO_ADDR
// wait ( 0 0$0.3 ) ;
14508: LD_INT 10
14510: PPUSH
14511: CALL_OW 67
// end ;
14515: GO 14324
14517: POP
14518: POP
// repeat wait ( 0 0$2 ) ;
14519: LD_INT 70
14521: PPUSH
14522: CALL_OW 67
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) ;
14526: LD_ADDR_VAR 0 4
14530: PUSH
14531: LD_INT 22
14533: PUSH
14534: LD_INT 1
14536: PUSH
14537: EMPTY
14538: LIST
14539: LIST
14540: PUSH
14541: LD_INT 34
14543: PUSH
14544: LD_INT 8
14546: PUSH
14547: EMPTY
14548: LIST
14549: LIST
14550: PUSH
14551: EMPTY
14552: LIST
14553: LIST
14554: PPUSH
14555: CALL_OW 69
14559: ST_TO_ADDR
// if not e then
14560: LD_VAR 0 4
14564: NOT
14565: IFFALSE 14601
// e := FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_vehicle ] ] ) ;
14567: LD_ADDR_VAR 0 4
14571: PUSH
14572: LD_INT 22
14574: PUSH
14575: LD_INT 1
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: PUSH
14582: LD_INT 21
14584: PUSH
14585: LD_INT 2
14587: PUSH
14588: EMPTY
14589: LIST
14590: LIST
14591: PUSH
14592: EMPTY
14593: LIST
14594: LIST
14595: PPUSH
14596: CALL_OW 69
14600: ST_TO_ADDR
// for i in tmp do
14601: LD_ADDR_VAR 0 1
14605: PUSH
14606: LD_VAR 0 3
14610: PUSH
14611: FOR_IN
14612: IFFALSE 14670
// if not IsOK ( i ) then
14614: LD_VAR 0 1
14618: PPUSH
14619: CALL_OW 302
14623: NOT
14624: IFFALSE 14644
// tmp := tmp diff i else
14626: LD_ADDR_VAR 0 3
14630: PUSH
14631: LD_VAR 0 3
14635: PUSH
14636: LD_VAR 0 1
14640: DIFF
14641: ST_TO_ADDR
14642: GO 14668
// ComAttackUnit ( i , NearestUnitToUnit ( e , i ) ) ;
14644: LD_VAR 0 1
14648: PPUSH
14649: LD_VAR 0 4
14653: PPUSH
14654: LD_VAR 0 1
14658: PPUSH
14659: CALL_OW 74
14663: PPUSH
14664: CALL_OW 115
14668: GO 14611
14670: POP
14671: POP
// until not tmp ;
14672: LD_VAR 0 3
14676: NOT
14677: IFFALSE 14519
// end ;
14679: PPOPN 4
14681: END
// every 8 8$20 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
14682: LD_EXP 23
14686: NOT
14687: PUSH
14688: LD_EXP 31
14692: AND
14693: IFFALSE 15643
14695: GO 14697
14697: DISABLE
14698: LD_INT 0
14700: PPUSH
14701: PPUSH
14702: PPUSH
14703: PPUSH
// begin enable ;
14704: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
14705: LD_INT 22
14707: PUSH
14708: LD_INT 7
14710: PUSH
14711: EMPTY
14712: LIST
14713: LIST
14714: PUSH
14715: LD_INT 30
14717: PUSH
14718: LD_INT 3
14720: PUSH
14721: EMPTY
14722: LIST
14723: LIST
14724: PUSH
14725: EMPTY
14726: LIST
14727: LIST
14728: PPUSH
14729: CALL_OW 69
14733: NOT
14734: IFFALSE 14738
// exit ;
14736: GO 15643
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
14738: LD_ADDR_VAR 0 4
14742: PUSH
14743: LD_INT 22
14745: PUSH
14746: LD_INT 7
14748: PUSH
14749: EMPTY
14750: LIST
14751: LIST
14752: PUSH
14753: LD_INT 30
14755: PUSH
14756: LD_INT 34
14758: PUSH
14759: EMPTY
14760: LIST
14761: LIST
14762: PUSH
14763: EMPTY
14764: LIST
14765: LIST
14766: PPUSH
14767: CALL_OW 69
14771: ST_TO_ADDR
// if Prob ( 40 ) then
14772: LD_INT 40
14774: PPUSH
14775: CALL_OW 13
14779: IFFALSE 14925
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
14781: LD_INT 1
14783: PPUSH
14784: LD_INT 5
14786: PUSH
14787: LD_INT 3
14789: PUSH
14790: LD_INT 2
14792: PUSH
14793: LD_INT 6
14795: PUSH
14796: EMPTY
14797: LIST
14798: LIST
14799: LIST
14800: LIST
14801: PUSH
14802: LD_INT 5
14804: PUSH
14805: LD_INT 3
14807: PUSH
14808: LD_INT 2
14810: PUSH
14811: LD_INT 6
14813: PUSH
14814: EMPTY
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: PUSH
14820: LD_INT 5
14822: PUSH
14823: LD_INT 3
14825: PUSH
14826: LD_INT 2
14828: PUSH
14829: LD_INT 6
14831: PUSH
14832: EMPTY
14833: LIST
14834: LIST
14835: LIST
14836: LIST
14837: PUSH
14838: LD_INT 5
14840: PUSH
14841: LD_INT 3
14843: PUSH
14844: LD_INT 2
14846: PUSH
14847: LD_INT 9
14849: PUSH
14850: EMPTY
14851: LIST
14852: LIST
14853: LIST
14854: LIST
14855: PUSH
14856: LD_INT 24
14858: PUSH
14859: LD_INT 3
14861: PUSH
14862: LD_INT 3
14864: PUSH
14865: LD_INT 45
14867: PUSH
14868: EMPTY
14869: LIST
14870: LIST
14871: LIST
14872: LIST
14873: PUSH
14874: LD_INT 24
14876: PUSH
14877: LD_INT 3
14879: PUSH
14880: LD_INT 3
14882: PUSH
14883: LD_INT 47
14885: PUSH
14886: EMPTY
14887: LIST
14888: LIST
14889: LIST
14890: LIST
14891: PUSH
14892: LD_INT 24
14894: PUSH
14895: LD_INT 3
14897: PUSH
14898: LD_INT 3
14900: PUSH
14901: LD_INT 45
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: LIST
14908: LIST
14909: PUSH
14910: EMPTY
14911: LIST
14912: LIST
14913: LIST
14914: LIST
14915: LIST
14916: LIST
14917: LIST
14918: PPUSH
14919: CALL 62472 0 2
// end else
14923: GO 15067
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
14925: LD_INT 1
14927: PPUSH
14928: LD_INT 24
14930: PUSH
14931: LD_INT 3
14933: PUSH
14934: LD_INT 3
14936: PUSH
14937: LD_INT 47
14939: PUSH
14940: EMPTY
14941: LIST
14942: LIST
14943: LIST
14944: LIST
14945: PUSH
14946: LD_INT 24
14948: PUSH
14949: LD_INT 3
14951: PUSH
14952: LD_INT 3
14954: PUSH
14955: LD_INT 47
14957: PUSH
14958: EMPTY
14959: LIST
14960: LIST
14961: LIST
14962: LIST
14963: PUSH
14964: LD_INT 5
14966: PUSH
14967: LD_INT 3
14969: PUSH
14970: LD_INT 2
14972: PUSH
14973: LD_INT 9
14975: PUSH
14976: EMPTY
14977: LIST
14978: LIST
14979: LIST
14980: LIST
14981: PUSH
14982: LD_INT 5
14984: PUSH
14985: LD_INT 3
14987: PUSH
14988: LD_INT 2
14990: PUSH
14991: LD_INT 9
14993: PUSH
14994: EMPTY
14995: LIST
14996: LIST
14997: LIST
14998: LIST
14999: PUSH
15000: LD_INT 5
15002: PUSH
15003: LD_INT 3
15005: PUSH
15006: LD_INT 2
15008: PUSH
15009: LD_INT 9
15011: PUSH
15012: EMPTY
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: PUSH
15018: LD_INT 24
15020: PUSH
15021: LD_INT 1
15023: PUSH
15024: LD_INT 3
15026: PUSH
15027: LD_INT 45
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: LIST
15034: LIST
15035: PUSH
15036: LD_INT 24
15038: PUSH
15039: LD_INT 1
15041: PUSH
15042: LD_INT 3
15044: PUSH
15045: LD_INT 45
15047: PUSH
15048: EMPTY
15049: LIST
15050: LIST
15051: LIST
15052: LIST
15053: PUSH
15054: EMPTY
15055: LIST
15056: LIST
15057: LIST
15058: LIST
15059: LIST
15060: LIST
15061: LIST
15062: PPUSH
15063: CALL 62472 0 2
// end ; repeat wait ( 0 0$1 ) ;
15067: LD_INT 35
15069: PPUSH
15070: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= 7 ;
15074: LD_INT 1
15076: PPUSH
15077: LD_INT 1
15079: PPUSH
15080: CALL 63890 0 2
15084: PUSH
15085: LD_INT 7
15087: GREATEREQUAL
15088: IFFALSE 15067
// wait ( 0 0$10 ) ;
15090: LD_INT 350
15092: PPUSH
15093: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
15097: LD_ADDR_VAR 0 2
15101: PUSH
15102: LD_INT 1
15104: PPUSH
15105: LD_INT 1
15107: PPUSH
15108: CALL 63890 0 2
15112: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
15113: LD_ADDR_EXP 119
15117: PUSH
15118: LD_EXP 119
15122: PPUSH
15123: LD_INT 1
15125: PPUSH
15126: LD_EXP 119
15130: PUSH
15131: LD_INT 1
15133: ARRAY
15134: PUSH
15135: LD_VAR 0 2
15139: DIFF
15140: PPUSH
15141: CALL_OW 1
15145: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
15146: LD_ADDR_VAR 0 3
15150: PUSH
15151: LD_INT 0
15153: PPUSH
15154: LD_INT 1
15156: PPUSH
15157: CALL_OW 12
15161: ST_TO_ADDR
// if target then
15162: LD_VAR 0 3
15166: IFFALSE 15332
// begin for i in tmp do
15168: LD_ADDR_VAR 0 1
15172: PUSH
15173: LD_VAR 0 2
15177: PUSH
15178: FOR_IN
15179: IFFALSE 15204
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
15181: LD_VAR 0 1
15185: PPUSH
15186: LD_INT 179
15188: PPUSH
15189: LD_INT 209
15191: PPUSH
15192: LD_INT 8
15194: PPUSH
15195: LD_INT 1
15197: PPUSH
15198: CALL_OW 483
15202: GO 15178
15204: POP
15205: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15206: LD_ADDR_VAR 0 2
15210: PUSH
15211: LD_VAR 0 2
15215: PPUSH
15216: LD_INT 24
15218: PUSH
15219: LD_INT 250
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PPUSH
15226: CALL_OW 72
15230: ST_TO_ADDR
// for i in tmp do
15231: LD_ADDR_VAR 0 1
15235: PUSH
15236: LD_VAR 0 2
15240: PUSH
15241: FOR_IN
15242: IFFALSE 15282
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
15244: LD_VAR 0 1
15248: PPUSH
15249: LD_INT 179
15251: PPUSH
15252: LD_INT 209
15254: PPUSH
15255: CALL_OW 297
15259: PUSH
15260: LD_INT 9
15262: GREATER
15263: IFFALSE 15280
// ComMoveXY ( i , 179 , 209 ) ;
15265: LD_VAR 0 1
15269: PPUSH
15270: LD_INT 179
15272: PPUSH
15273: LD_INT 209
15275: PPUSH
15276: CALL_OW 111
15280: GO 15241
15282: POP
15283: POP
// wait ( 0 0$1 ) ;
15284: LD_INT 35
15286: PPUSH
15287: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
15291: LD_VAR 0 2
15295: PPUSH
15296: LD_INT 92
15298: PUSH
15299: LD_INT 179
15301: PUSH
15302: LD_INT 209
15304: PUSH
15305: LD_INT 9
15307: PUSH
15308: EMPTY
15309: LIST
15310: LIST
15311: LIST
15312: LIST
15313: PPUSH
15314: CALL_OW 72
15318: PUSH
15319: LD_VAR 0 2
15323: PUSH
15324: LD_INT 1
15326: MINUS
15327: GREATEREQUAL
15328: IFFALSE 15206
// end else
15330: GO 15494
// begin for i in tmp do
15332: LD_ADDR_VAR 0 1
15336: PUSH
15337: LD_VAR 0 2
15341: PUSH
15342: FOR_IN
15343: IFFALSE 15368
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
15345: LD_VAR 0 1
15349: PPUSH
15350: LD_INT 285
15352: PPUSH
15353: LD_INT 163
15355: PPUSH
15356: LD_INT 8
15358: PPUSH
15359: LD_INT 1
15361: PPUSH
15362: CALL_OW 483
15366: GO 15342
15368: POP
15369: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
15370: LD_ADDR_VAR 0 2
15374: PUSH
15375: LD_VAR 0 2
15379: PPUSH
15380: LD_INT 24
15382: PUSH
15383: LD_INT 250
15385: PUSH
15386: EMPTY
15387: LIST
15388: LIST
15389: PPUSH
15390: CALL_OW 72
15394: ST_TO_ADDR
// for i in tmp do
15395: LD_ADDR_VAR 0 1
15399: PUSH
15400: LD_VAR 0 2
15404: PUSH
15405: FOR_IN
15406: IFFALSE 15446
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
15408: LD_VAR 0 1
15412: PPUSH
15413: LD_INT 285
15415: PPUSH
15416: LD_INT 163
15418: PPUSH
15419: CALL_OW 297
15423: PUSH
15424: LD_INT 9
15426: GREATER
15427: IFFALSE 15444
// ComMoveXY ( i , 285 , 163 ) ;
15429: LD_VAR 0 1
15433: PPUSH
15434: LD_INT 285
15436: PPUSH
15437: LD_INT 163
15439: PPUSH
15440: CALL_OW 111
15444: GO 15405
15446: POP
15447: POP
// wait ( 0 0$1 ) ;
15448: LD_INT 35
15450: PPUSH
15451: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
15455: LD_VAR 0 2
15459: PPUSH
15460: LD_INT 92
15462: PUSH
15463: LD_INT 285
15465: PUSH
15466: LD_INT 163
15468: PUSH
15469: LD_INT 9
15471: PUSH
15472: EMPTY
15473: LIST
15474: LIST
15475: LIST
15476: LIST
15477: PPUSH
15478: CALL_OW 72
15482: PUSH
15483: LD_VAR 0 2
15487: PUSH
15488: LD_INT 1
15490: MINUS
15491: GREATEREQUAL
15492: IFFALSE 15370
// end ; repeat wait ( 0 0$1 ) ;
15494: LD_INT 35
15496: PPUSH
15497: CALL_OW 67
// for i in tmp do
15501: LD_ADDR_VAR 0 1
15505: PUSH
15506: LD_VAR 0 2
15510: PUSH
15511: FOR_IN
15512: IFFALSE 15634
// if GetLives ( i ) > 251 then
15514: LD_VAR 0 1
15518: PPUSH
15519: CALL_OW 256
15523: PUSH
15524: LD_INT 251
15526: GREATER
15527: IFFALSE 15616
// begin if GetWeapon ( i ) = ru_time_lapser then
15529: LD_VAR 0 1
15533: PPUSH
15534: CALL_OW 264
15538: PUSH
15539: LD_INT 49
15541: EQUAL
15542: IFFALSE 15580
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
15544: LD_VAR 0 1
15548: PPUSH
15549: LD_INT 81
15551: PUSH
15552: LD_INT 7
15554: PUSH
15555: EMPTY
15556: LIST
15557: LIST
15558: PPUSH
15559: CALL_OW 69
15563: PPUSH
15564: LD_VAR 0 1
15568: PPUSH
15569: CALL_OW 74
15573: PPUSH
15574: CALL_OW 112
15578: GO 15614
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
15580: LD_VAR 0 1
15584: PPUSH
15585: LD_INT 81
15587: PUSH
15588: LD_INT 7
15590: PUSH
15591: EMPTY
15592: LIST
15593: LIST
15594: PPUSH
15595: CALL_OW 69
15599: PPUSH
15600: LD_VAR 0 1
15604: PPUSH
15605: CALL_OW 74
15609: PPUSH
15610: CALL_OW 115
// end else
15614: GO 15632
// tmp := tmp diff i ;
15616: LD_ADDR_VAR 0 2
15620: PUSH
15621: LD_VAR 0 2
15625: PUSH
15626: LD_VAR 0 1
15630: DIFF
15631: ST_TO_ADDR
15632: GO 15511
15634: POP
15635: POP
// until not tmp ;
15636: LD_VAR 0 2
15640: NOT
15641: IFFALSE 15494
// end ;
15643: PPOPN 4
15645: END
// every 1 1$30 trigger allianceActive and IsOk ( Roth ) and Difficulty > 2 do
15646: LD_EXP 31
15650: PUSH
15651: LD_EXP 77
15655: PPUSH
15656: CALL_OW 302
15660: AND
15661: PUSH
15662: LD_OWVAR 67
15666: PUSH
15667: LD_INT 2
15669: GREATER
15670: AND
15671: IFFALSE 15771
15673: GO 15675
15675: DISABLE
// begin enable ;
15676: ENABLE
// if GetDistUnitXY ( Roth , 245 , 234 ) > 6 then
15677: LD_EXP 77
15681: PPUSH
15682: LD_INT 245
15684: PPUSH
15685: LD_INT 234
15687: PPUSH
15688: CALL_OW 297
15692: PUSH
15693: LD_INT 6
15695: GREATER
15696: IFFALSE 15715
// ComMoveXY ( Roth , 245 , 234 ) else
15698: LD_EXP 77
15702: PPUSH
15703: LD_INT 245
15705: PPUSH
15706: LD_INT 234
15708: PPUSH
15709: CALL_OW 111
15713: GO 15771
// ComMoveHex ( Roth , [ [ 259 , 235 ] , [ 252 , 209 ] , [ 275 , 235 ] ] [ rand ( 1 , 3 ) ] ) ;
15715: LD_EXP 77
15719: PPUSH
15720: LD_INT 259
15722: PUSH
15723: LD_INT 235
15725: PUSH
15726: EMPTY
15727: LIST
15728: LIST
15729: PUSH
15730: LD_INT 252
15732: PUSH
15733: LD_INT 209
15735: PUSH
15736: EMPTY
15737: LIST
15738: LIST
15739: PUSH
15740: LD_INT 275
15742: PUSH
15743: LD_INT 235
15745: PUSH
15746: EMPTY
15747: LIST
15748: LIST
15749: PUSH
15750: EMPTY
15751: LIST
15752: LIST
15753: LIST
15754: PUSH
15755: LD_INT 1
15757: PPUSH
15758: LD_INT 3
15760: PPUSH
15761: CALL_OW 12
15765: ARRAY
15766: PPUSH
15767: CALL 110192 0 2
// end ; end_of_file
15771: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
15772: LD_INT 0
15774: PPUSH
15775: PPUSH
15776: PPUSH
15777: PPUSH
// missionStage := 13 ;
15778: LD_ADDR_EXP 15
15782: PUSH
15783: LD_INT 13
15785: ST_TO_ADDR
// uc_side := 2 ;
15786: LD_ADDR_OWVAR 20
15790: PUSH
15791: LD_INT 2
15793: ST_TO_ADDR
// uc_nation := 2 ;
15794: LD_ADDR_OWVAR 21
15798: PUSH
15799: LD_INT 2
15801: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
15802: LD_ADDR_EXP 95
15806: PUSH
15807: LD_STRING Omar
15809: PPUSH
15810: CALL_OW 25
15814: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
15815: LD_EXP 95
15819: PPUSH
15820: LD_INT 4
15822: PPUSH
15823: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
15827: LD_EXP 95
15831: PPUSH
15832: LD_INT 242
15834: PPUSH
15835: LD_INT 75
15837: PPUSH
15838: LD_INT 0
15840: PPUSH
15841: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
15845: LD_ADDR_EXP 96
15849: PUSH
15850: LD_STRING Heike
15852: PPUSH
15853: CALL_OW 25
15857: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
15858: LD_INT 14
15860: PPUSH
15861: LD_INT 3
15863: PPUSH
15864: LD_INT 1
15866: PPUSH
15867: LD_INT 27
15869: PPUSH
15870: LD_INT 100
15872: PPUSH
15873: CALL 73738 0 5
// veh := CreateVehicle ;
15877: LD_ADDR_VAR 0 3
15881: PUSH
15882: CALL_OW 45
15886: ST_TO_ADDR
// SetMark ( veh , - 2 ) ;
15887: LD_VAR 0 3
15891: PPUSH
15892: LD_INT 2
15894: NEG
15895: PPUSH
15896: CALL_OW 242
// SetDir ( veh , 4 ) ;
15900: LD_VAR 0 3
15904: PPUSH
15905: LD_INT 4
15907: PPUSH
15908: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
15912: LD_VAR 0 3
15916: PPUSH
15917: LD_INT 241
15919: PPUSH
15920: LD_INT 72
15922: PPUSH
15923: LD_INT 0
15925: PPUSH
15926: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
15930: LD_EXP 96
15934: PPUSH
15935: LD_VAR 0 3
15939: PPUSH
15940: CALL_OW 52
// if KhatamStatus then
15944: LD_EXP 8
15948: IFFALSE 16011
// begin Khatam := NewCharacter ( Khatam ) ;
15950: LD_ADDR_EXP 97
15954: PUSH
15955: LD_STRING Khatam
15957: PPUSH
15958: CALL_OW 25
15962: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
15963: LD_EXP 97
15967: PPUSH
15968: LD_INT 245
15970: PPUSH
15971: LD_INT 78
15973: PPUSH
15974: LD_INT 3
15976: PPUSH
15977: LD_INT 0
15979: PPUSH
15980: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
15984: LD_EXP 97
15988: PPUSH
15989: LD_INT 4
15991: PPUSH
15992: LD_INT 10
15994: PPUSH
15995: CALL_OW 237
// SetClass ( Khatam , class_scientistic ) ;
15999: LD_EXP 97
16003: PPUSH
16004: LD_INT 4
16006: PPUSH
16007: CALL_OW 336
// end ; for i = 1 to [ 2 , 2 , 3 , 3 ] [ Difficulty ] do
16011: LD_ADDR_VAR 0 2
16015: PUSH
16016: DOUBLE
16017: LD_INT 1
16019: DEC
16020: ST_TO_ADDR
16021: LD_INT 2
16023: PUSH
16024: LD_INT 2
16026: PUSH
16027: LD_INT 3
16029: PUSH
16030: LD_INT 3
16032: PUSH
16033: EMPTY
16034: LIST
16035: LIST
16036: LIST
16037: LIST
16038: PUSH
16039: LD_OWVAR 67
16043: ARRAY
16044: PUSH
16045: FOR_TO
16046: IFFALSE 16112
// begin PrepareScientist ( false , 6 + Difficulty ) ;
16048: LD_INT 0
16050: PPUSH
16051: LD_INT 6
16053: PUSH
16054: LD_OWVAR 67
16058: PLUS
16059: PPUSH
16060: CALL_OW 384
// un := CreateHuman ;
16064: LD_ADDR_VAR 0 4
16068: PUSH
16069: CALL_OW 44
16073: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
16074: LD_VAR 0 4
16078: PPUSH
16079: LD_INT 28
16081: PUSH
16082: LD_INT 29
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: PUSH
16089: LD_VAR 0 2
16093: PUSH
16094: LD_INT 2
16096: MOD
16097: PUSH
16098: LD_INT 1
16100: PLUS
16101: ARRAY
16102: PPUSH
16103: LD_INT 0
16105: PPUSH
16106: CALL_OW 49
// end ;
16110: GO 16045
16112: POP
16113: POP
// for i = 1 to 6 do
16114: LD_ADDR_VAR 0 2
16118: PUSH
16119: DOUBLE
16120: LD_INT 1
16122: DEC
16123: ST_TO_ADDR
16124: LD_INT 6
16126: PUSH
16127: FOR_TO
16128: IFFALSE 16173
// begin PrepareSoldier ( false , 6 + Difficulty ) ;
16130: LD_INT 0
16132: PPUSH
16133: LD_INT 6
16135: PUSH
16136: LD_OWVAR 67
16140: PLUS
16141: PPUSH
16142: CALL_OW 381
// un := CreateHuman ;
16146: LD_ADDR_VAR 0 4
16150: PUSH
16151: CALL_OW 44
16155: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16156: LD_VAR 0 4
16160: PPUSH
16161: LD_INT 32
16163: PPUSH
16164: LD_INT 0
16166: PPUSH
16167: CALL_OW 49
// end ;
16171: GO 16127
16173: POP
16174: POP
// for i = 1 to 3 do
16175: LD_ADDR_VAR 0 2
16179: PUSH
16180: DOUBLE
16181: LD_INT 1
16183: DEC
16184: ST_TO_ADDR
16185: LD_INT 3
16187: PUSH
16188: FOR_TO
16189: IFFALSE 16237
// begin PrepareHuman ( false , class_mortar , 6 + Difficulty ) ;
16191: LD_INT 0
16193: PPUSH
16194: LD_INT 8
16196: PPUSH
16197: LD_INT 6
16199: PUSH
16200: LD_OWVAR 67
16204: PLUS
16205: PPUSH
16206: CALL_OW 380
// un := CreateHuman ;
16210: LD_ADDR_VAR 0 4
16214: PUSH
16215: CALL_OW 44
16219: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea3 , false ) ;
16220: LD_VAR 0 4
16224: PPUSH
16225: LD_INT 32
16227: PPUSH
16228: LD_INT 0
16230: PPUSH
16231: CALL_OW 49
// end ;
16235: GO 16188
16237: POP
16238: POP
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
16239: LD_ADDR_VAR 0 2
16243: PUSH
16244: DOUBLE
16245: LD_INT 1
16247: DEC
16248: ST_TO_ADDR
16249: LD_INT 2
16251: PUSH
16252: LD_INT 3
16254: PUSH
16255: LD_INT 4
16257: PUSH
16258: LD_INT 4
16260: PUSH
16261: EMPTY
16262: LIST
16263: LIST
16264: LIST
16265: LIST
16266: PUSH
16267: LD_OWVAR 67
16271: ARRAY
16272: PUSH
16273: FOR_TO
16274: IFFALSE 16364
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
16276: LD_INT 14
16278: PPUSH
16279: LD_INT 2
16281: PPUSH
16282: LD_INT 1
16284: PPUSH
16285: LD_INT 28
16287: PPUSH
16288: LD_INT 80
16290: PPUSH
16291: CALL 73738 0 5
// veh := CreateVehicle ;
16295: LD_ADDR_VAR 0 3
16299: PUSH
16300: CALL_OW 45
16304: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
16305: LD_VAR 0 3
16309: PPUSH
16310: LD_INT 3
16312: PPUSH
16313: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
16317: LD_VAR 0 3
16321: PPUSH
16322: LD_INT 29
16324: PPUSH
16325: LD_INT 0
16327: PPUSH
16328: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16332: LD_INT 0
16334: PPUSH
16335: LD_INT 6
16337: PUSH
16338: LD_OWVAR 67
16342: PLUS
16343: PPUSH
16344: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16348: CALL_OW 44
16352: PPUSH
16353: LD_VAR 0 3
16357: PPUSH
16358: CALL_OW 52
// end ;
16362: GO 16273
16364: POP
16365: POP
// for i = 1 to 5 + Difficulty do
16366: LD_ADDR_VAR 0 2
16370: PUSH
16371: DOUBLE
16372: LD_INT 1
16374: DEC
16375: ST_TO_ADDR
16376: LD_INT 5
16378: PUSH
16379: LD_OWVAR 67
16383: PLUS
16384: PUSH
16385: FOR_TO
16386: IFFALSE 16513
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
16388: LD_INT 14
16390: PPUSH
16391: LD_INT 1
16393: PPUSH
16394: LD_INT 3
16396: PPUSH
16397: CALL_OW 12
16401: PPUSH
16402: LD_INT 1
16404: PPUSH
16405: LD_INT 28
16407: PUSH
16408: LD_INT 26
16410: PUSH
16411: LD_INT 27
16413: PUSH
16414: LD_INT 25
16416: PUSH
16417: EMPTY
16418: LIST
16419: LIST
16420: LIST
16421: LIST
16422: PUSH
16423: LD_VAR 0 2
16427: PUSH
16428: LD_INT 4
16430: MOD
16431: PUSH
16432: LD_INT 1
16434: PLUS
16435: ARRAY
16436: PPUSH
16437: LD_INT 80
16439: PPUSH
16440: CALL 73738 0 5
// veh := CreateVehicle ;
16444: LD_ADDR_VAR 0 3
16448: PUSH
16449: CALL_OW 45
16453: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16454: LD_VAR 0 3
16458: PPUSH
16459: LD_INT 4
16461: PPUSH
16462: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16466: LD_VAR 0 3
16470: PPUSH
16471: LD_INT 28
16473: PPUSH
16474: LD_INT 0
16476: PPUSH
16477: CALL_OW 49
// PrepareMechanic ( false , 6 + Difficulty ) ;
16481: LD_INT 0
16483: PPUSH
16484: LD_INT 6
16486: PUSH
16487: LD_OWVAR 67
16491: PLUS
16492: PPUSH
16493: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
16497: CALL_OW 44
16501: PPUSH
16502: LD_VAR 0 3
16506: PPUSH
16507: CALL_OW 52
// end ;
16511: GO 16385
16513: POP
16514: POP
// for i = 1 to Difficulty do
16515: LD_ADDR_VAR 0 2
16519: PUSH
16520: DOUBLE
16521: LD_INT 1
16523: DEC
16524: ST_TO_ADDR
16525: LD_OWVAR 67
16529: PUSH
16530: FOR_TO
16531: IFFALSE 16591
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
16533: LD_INT 14
16535: PPUSH
16536: LD_INT 3
16538: PPUSH
16539: LD_INT 5
16541: PPUSH
16542: LD_INT 29
16544: PPUSH
16545: LD_INT 80
16547: PPUSH
16548: CALL 73738 0 5
// veh := CreateVehicle ;
16552: LD_ADDR_VAR 0 3
16556: PUSH
16557: CALL_OW 45
16561: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
16562: LD_VAR 0 3
16566: PPUSH
16567: LD_INT 4
16569: PPUSH
16570: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
16574: LD_VAR 0 3
16578: PPUSH
16579: LD_INT 28
16581: PPUSH
16582: LD_INT 0
16584: PPUSH
16585: CALL_OW 49
// end ;
16589: GO 16530
16591: POP
16592: POP
// end ;
16593: LD_VAR 0 1
16597: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci , enemy ;
16598: LD_INT 22
16600: PUSH
16601: LD_INT 2
16603: PUSH
16604: EMPTY
16605: LIST
16606: LIST
16607: PPUSH
16608: CALL_OW 69
16612: IFFALSE 16991
16614: GO 16616
16616: DISABLE
16617: LD_INT 0
16619: PPUSH
16620: PPUSH
16621: PPUSH
16622: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
16623: LD_ADDR_VAR 0 3
16627: PUSH
16628: LD_INT 22
16630: PUSH
16631: LD_INT 2
16633: PUSH
16634: EMPTY
16635: LIST
16636: LIST
16637: PUSH
16638: LD_INT 25
16640: PUSH
16641: LD_INT 4
16643: PUSH
16644: EMPTY
16645: LIST
16646: LIST
16647: PUSH
16648: EMPTY
16649: LIST
16650: LIST
16651: PPUSH
16652: CALL_OW 69
16656: PUSH
16657: LD_EXP 97
16661: DIFF
16662: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
16663: LD_ADDR_VAR 0 2
16667: PUSH
16668: LD_INT 22
16670: PUSH
16671: LD_INT 2
16673: PUSH
16674: EMPTY
16675: LIST
16676: LIST
16677: PPUSH
16678: CALL_OW 69
16682: PUSH
16683: LD_EXP 97
16687: PUSH
16688: LD_VAR 0 3
16692: UNION
16693: DIFF
16694: ST_TO_ADDR
// if Khatam then
16695: LD_EXP 97
16699: IFFALSE 16716
// ComMoveXY ( Khatam , 211 , 92 ) ;
16701: LD_EXP 97
16705: PPUSH
16706: LD_INT 211
16708: PPUSH
16709: LD_INT 92
16711: PPUSH
16712: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
16716: LD_INT 197
16718: PPUSH
16719: LD_INT 80
16721: PPUSH
16722: LD_INT 2
16724: PPUSH
16725: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
16729: LD_INT 213
16731: PPUSH
16732: LD_INT 90
16734: PPUSH
16735: LD_INT 2
16737: PPUSH
16738: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
16742: LD_INT 215
16744: PPUSH
16745: LD_INT 129
16747: PPUSH
16748: LD_INT 2
16750: PPUSH
16751: CALL_OW 441
// if sci then
16755: LD_VAR 0 3
16759: IFFALSE 16780
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
16761: LD_VAR 0 3
16765: PUSH
16766: LD_INT 1
16768: ARRAY
16769: PPUSH
16770: LD_INT 197
16772: PPUSH
16773: LD_INT 80
16775: PPUSH
16776: CALL_OW 158
// if sci > 1 then
16780: LD_VAR 0 3
16784: PUSH
16785: LD_INT 1
16787: GREATER
16788: IFFALSE 16809
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
16790: LD_VAR 0 3
16794: PUSH
16795: LD_INT 2
16797: ARRAY
16798: PPUSH
16799: LD_INT 213
16801: PPUSH
16802: LD_INT 90
16804: PPUSH
16805: CALL_OW 158
// if sci > 2 then
16809: LD_VAR 0 3
16813: PUSH
16814: LD_INT 2
16816: GREATER
16817: IFFALSE 16838
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
16819: LD_VAR 0 3
16823: PUSH
16824: LD_INT 3
16826: ARRAY
16827: PPUSH
16828: LD_INT 215
16830: PPUSH
16831: LD_INT 129
16833: PPUSH
16834: CALL_OW 158
// ComAgressiveMove ( tmp , 195 , 102 ) ;
16838: LD_VAR 0 2
16842: PPUSH
16843: LD_INT 195
16845: PPUSH
16846: LD_INT 102
16848: PPUSH
16849: CALL_OW 114
// wait ( 0 0$5 ) ;
16853: LD_INT 175
16855: PPUSH
16856: CALL_OW 67
// repeat wait ( 0 0$2 ) ;
16860: LD_INT 70
16862: PPUSH
16863: CALL_OW 67
// enemy := FilterAllUnits ( [ [ f_distxy , 195 , 102 , 36 ] , [ f_side , 1 ] ] ) ;
16867: LD_ADDR_VAR 0 4
16871: PUSH
16872: LD_INT 92
16874: PUSH
16875: LD_INT 195
16877: PUSH
16878: LD_INT 102
16880: PUSH
16881: LD_INT 36
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: LIST
16888: LIST
16889: PUSH
16890: LD_INT 22
16892: PUSH
16893: LD_INT 1
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: EMPTY
16901: LIST
16902: LIST
16903: PPUSH
16904: CALL_OW 69
16908: ST_TO_ADDR
// for i in tmp do
16909: LD_ADDR_VAR 0 1
16913: PUSH
16914: LD_VAR 0 2
16918: PUSH
16919: FOR_IN
16920: IFFALSE 16971
// if enemy then
16922: LD_VAR 0 4
16926: IFFALSE 16954
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16928: LD_VAR 0 1
16932: PPUSH
16933: LD_VAR 0 4
16937: PPUSH
16938: LD_VAR 0 1
16942: PPUSH
16943: CALL_OW 74
16947: PPUSH
16948: CALL_OW 115
16952: GO 16969
// ComAgressiveMove ( i , 195 , 102 ) ;
16954: LD_VAR 0 1
16958: PPUSH
16959: LD_INT 195
16961: PPUSH
16962: LD_INT 102
16964: PPUSH
16965: CALL_OW 114
16969: GO 16919
16971: POP
16972: POP
// until not UnitFilter ( tmp , [ f_ok ] ) ;
16973: LD_VAR 0 2
16977: PPUSH
16978: LD_INT 50
16980: PUSH
16981: EMPTY
16982: LIST
16983: PPUSH
16984: CALL_OW 72
16988: NOT
16989: IFFALSE 16860
// end ; end_of_file
16991: PPOPN 4
16993: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
16994: LD_INT 0
16996: PPUSH
16997: PPUSH
16998: PPUSH
16999: PPUSH
17000: PPUSH
17001: PPUSH
17002: PPUSH
17003: PPUSH
17004: PPUSH
// Video ( true ) ;
17005: LD_INT 1
17007: PPUSH
17008: CALL 106162 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
17012: LD_ADDR_VAR 0 5
17016: PUSH
17017: LD_INT 7
17019: PPUSH
17020: LD_INT 0
17022: PPUSH
17023: CALL_OW 517
17027: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
17028: LD_ADDR_VAR 0 2
17032: PUSH
17033: DOUBLE
17034: LD_INT 1
17036: DEC
17037: ST_TO_ADDR
17038: LD_VAR 0 5
17042: PUSH
17043: LD_INT 1
17045: ARRAY
17046: PUSH
17047: FOR_TO
17048: IFFALSE 17093
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
17050: LD_VAR 0 5
17054: PUSH
17055: LD_INT 1
17057: ARRAY
17058: PUSH
17059: LD_VAR 0 2
17063: ARRAY
17064: PPUSH
17065: LD_VAR 0 5
17069: PUSH
17070: LD_INT 2
17072: ARRAY
17073: PUSH
17074: LD_VAR 0 2
17078: ARRAY
17079: PPUSH
17080: LD_INT 1
17082: PPUSH
17083: LD_INT 15
17085: NEG
17086: PPUSH
17087: CALL 106076 0 4
17091: GO 17047
17093: POP
17094: POP
// CenterNowOnUnits ( Powell ) ;
17095: LD_EXP 60
17099: PPUSH
17100: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
17104: LD_ADDR_VAR 0 5
17108: PUSH
17109: LD_EXP 58
17113: PUSH
17114: EMPTY
17115: LIST
17116: ST_TO_ADDR
// if GirlNewVeh then
17117: LD_EXP 59
17121: IFFALSE 17139
// tmp := tmp ^ GirlNewVeh ;
17123: LD_ADDR_VAR 0 5
17127: PUSH
17128: LD_VAR 0 5
17132: PUSH
17133: LD_EXP 59
17137: ADD
17138: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
17139: LD_VAR 0 5
17143: PPUSH
17144: LD_INT 60
17146: PPUSH
17147: LD_INT 109
17149: PPUSH
17150: CALL_OW 111
// if KappaStatus then
17154: LD_EXP 2
17158: IFFALSE 17210
// begin Say ( JMM , D1nT-JMM-1 ) ;
17160: LD_EXP 40
17164: PPUSH
17165: LD_STRING D1nT-JMM-1
17167: PPUSH
17168: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17172: LD_EXP 60
17176: PPUSH
17177: LD_STRING D1T-Pow-1
17179: PPUSH
17180: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
17184: LD_EXP 40
17188: PPUSH
17189: LD_STRING D1T-JMM-2
17191: PPUSH
17192: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
17196: LD_EXP 60
17200: PPUSH
17201: LD_STRING D1T-Pow-2
17203: PPUSH
17204: CALL_OW 88
// end else
17208: GO 17416
// if JMMGirlStatus then
17210: LD_EXP 6
17214: IFFALSE 17359
// begin Say ( JMM , D1T-JMM-1 ) ;
17216: LD_EXP 40
17220: PPUSH
17221: LD_STRING D1T-JMM-1
17223: PPUSH
17224: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
17228: LD_EXP 60
17232: PPUSH
17233: LD_STRING D1T-Pow-1
17235: PPUSH
17236: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
17240: LD_EXP 40
17244: PPUSH
17245: LD_STRING D1T-JMM-3
17247: PPUSH
17248: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
17252: LD_EXP 60
17256: PPUSH
17257: LD_STRING D1T-Pow-3
17259: PPUSH
17260: CALL_OW 88
// if JMMGirl then
17264: LD_EXP 7
17268: IFFALSE 17357
// begin case JMMGirl of 1 :
17270: LD_EXP 7
17274: PUSH
17275: LD_INT 1
17277: DOUBLE
17278: EQUAL
17279: IFTRUE 17283
17281: GO 17298
17283: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
17284: LD_EXP 41
17288: PPUSH
17289: LD_STRING D1T-Joan-3
17291: PPUSH
17292: CALL_OW 88
17296: GO 17345
17298: LD_INT 2
17300: DOUBLE
17301: EQUAL
17302: IFTRUE 17306
17304: GO 17321
17306: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
17307: LD_EXP 43
17311: PPUSH
17312: LD_STRING D1T-Lisa-3
17314: PPUSH
17315: CALL_OW 88
17319: GO 17345
17321: LD_INT 3
17323: DOUBLE
17324: EQUAL
17325: IFTRUE 17329
17327: GO 17344
17329: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
17330: LD_EXP 55
17334: PPUSH
17335: LD_STRING D1T-Con-3
17337: PPUSH
17338: CALL_OW 88
17342: GO 17345
17344: POP
// Say ( Powell , D1T-Pow-4 ) ;
17345: LD_EXP 60
17349: PPUSH
17350: LD_STRING D1T-Pow-4
17352: PPUSH
17353: CALL_OW 88
// end ; end else
17357: GO 17416
// if not FastEnd then
17359: LD_EXP 11
17363: NOT
17364: IFFALSE 17392
// begin Say ( JMM , D1T-JMM-4 ) ;
17366: LD_EXP 40
17370: PPUSH
17371: LD_STRING D1T-JMM-4
17373: PPUSH
17374: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
17378: LD_EXP 60
17382: PPUSH
17383: LD_STRING D1T-Pow-5
17385: PPUSH
17386: CALL_OW 88
// end else
17390: GO 17416
// begin Say ( JMM , D1nT-JMM-1 ) ;
17392: LD_EXP 40
17396: PPUSH
17397: LD_STRING D1nT-JMM-1
17399: PPUSH
17400: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
17404: LD_EXP 60
17408: PPUSH
17409: LD_STRING D1nT-Pow-1
17411: PPUSH
17412: CALL_OW 88
// end ; repeat wait ( 3 ) ;
17416: LD_INT 3
17418: PPUSH
17419: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
17423: LD_EXP 58
17427: PPUSH
17428: CALL_OW 314
17432: NOT
17433: IFFALSE 17416
// ComExitVehicle ( JMM ) ;
17435: LD_EXP 40
17439: PPUSH
17440: CALL_OW 121
// repeat wait ( 3 ) ;
17444: LD_INT 3
17446: PPUSH
17447: CALL_OW 67
// until not IsInUnit ( JMM ) ;
17451: LD_EXP 40
17455: PPUSH
17456: CALL_OW 310
17460: NOT
17461: IFFALSE 17444
// ComMoveXY ( JMM , 60 , 94 ) ;
17463: LD_EXP 40
17467: PPUSH
17468: LD_INT 60
17470: PPUSH
17471: LD_INT 94
17473: PPUSH
17474: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
17478: LD_EXP 40
17482: PPUSH
17483: LD_EXP 60
17487: PPUSH
17488: CALL_OW 179
// if Joan then
17492: LD_EXP 41
17496: IFFALSE 17550
// begin ComExitVehicle ( Joan ) ;
17498: LD_EXP 41
17502: PPUSH
17503: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
17507: LD_EXP 41
17511: PPUSH
17512: LD_INT 35
17514: PPUSH
17515: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
17519: LD_EXP 41
17523: PPUSH
17524: LD_INT 65
17526: PPUSH
17527: LD_INT 104
17529: PPUSH
17530: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
17534: LD_EXP 41
17538: PPUSH
17539: LD_EXP 40
17543: PPUSH
17544: CALL_OW 179
// end else
17548: GO 17684
// if Lisa and JMMGirl = 2 then
17550: LD_EXP 43
17554: PUSH
17555: LD_EXP 7
17559: PUSH
17560: LD_INT 2
17562: EQUAL
17563: AND
17564: IFFALSE 17618
// begin ComExitVehicle ( Lisa ) ;
17566: LD_EXP 43
17570: PPUSH
17571: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
17575: LD_EXP 43
17579: PPUSH
17580: LD_INT 35
17582: PPUSH
17583: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
17587: LD_EXP 43
17591: PPUSH
17592: LD_INT 65
17594: PPUSH
17595: LD_INT 104
17597: PPUSH
17598: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
17602: LD_EXP 43
17606: PPUSH
17607: LD_EXP 40
17611: PPUSH
17612: CALL_OW 179
// end else
17616: GO 17684
// if Connie and JMMGirl = 3 then
17618: LD_EXP 55
17622: PUSH
17623: LD_EXP 7
17627: PUSH
17628: LD_INT 3
17630: EQUAL
17631: AND
17632: IFFALSE 17684
// begin ComExitVehicle ( Connie ) ;
17634: LD_EXP 55
17638: PPUSH
17639: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
17643: LD_EXP 55
17647: PPUSH
17648: LD_INT 35
17650: PPUSH
17651: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
17655: LD_EXP 55
17659: PPUSH
17660: LD_INT 65
17662: PPUSH
17663: LD_INT 104
17665: PPUSH
17666: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
17670: LD_EXP 55
17674: PPUSH
17675: LD_EXP 40
17679: PPUSH
17680: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
17684: LD_INT 35
17686: PPUSH
17687: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 8 ;
17691: LD_EXP 40
17695: PPUSH
17696: LD_EXP 60
17700: PPUSH
17701: CALL_OW 296
17705: PUSH
17706: LD_INT 8
17708: LESS
17709: IFFALSE 17684
// wait ( 0 0$0.5 ) ;
17711: LD_INT 18
17713: PPUSH
17714: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
17718: LD_EXP 40
17722: PPUSH
17723: LD_STRING D1-JMM-1
17725: PPUSH
17726: CALL_OW 88
// async ;
17730: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
17731: LD_EXP 60
17735: PPUSH
17736: LD_STRING D1-Pow-1
17738: PPUSH
17739: CALL_OW 88
// if not dialogue_skipped then
17743: LD_OWVAR 59
17747: NOT
17748: IFFALSE 17757
// wait ( 0 0$2 ) ;
17750: LD_INT 70
17752: PPUSH
17753: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
17757: LD_INT 170
17759: PPUSH
17760: LD_INT 99
17762: PPUSH
17763: LD_INT 1
17765: PPUSH
17766: LD_INT 6
17768: NEG
17769: PPUSH
17770: CALL 106076 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
17774: LD_INT 174
17776: PPUSH
17777: LD_INT 115
17779: PPUSH
17780: LD_INT 1
17782: PPUSH
17783: LD_INT 6
17785: NEG
17786: PPUSH
17787: CALL 106076 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
17791: LD_INT 169
17793: PPUSH
17794: LD_INT 71
17796: PPUSH
17797: LD_INT 1
17799: PPUSH
17800: LD_INT 6
17802: NEG
17803: PPUSH
17804: CALL 106076 0 4
// if not dialogue_skipped then
17808: LD_OWVAR 59
17812: NOT
17813: IFFALSE 17832
// begin CenterOnXY ( 170 , 99 ) ;
17815: LD_INT 170
17817: PPUSH
17818: LD_INT 99
17820: PPUSH
17821: CALL_OW 84
// wait ( 0 0$2.3 ) ;
17825: LD_INT 80
17827: PPUSH
17828: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
17832: LD_INT 75
17834: PPUSH
17835: LD_INT 53
17837: PPUSH
17838: LD_INT 1
17840: PPUSH
17841: LD_INT 9
17843: NEG
17844: PPUSH
17845: CALL 106076 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
17849: LD_INT 54
17851: PPUSH
17852: LD_INT 42
17854: PPUSH
17855: LD_INT 1
17857: PPUSH
17858: LD_INT 9
17860: NEG
17861: PPUSH
17862: CALL 106076 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
17866: LD_INT 62
17868: PPUSH
17869: LD_INT 51
17871: PPUSH
17872: LD_INT 1
17874: PPUSH
17875: LD_INT 9
17877: NEG
17878: PPUSH
17879: CALL 106076 0 4
// if not dialogue_skipped then
17883: LD_OWVAR 59
17887: NOT
17888: IFFALSE 17907
// begin CenterOnXY ( 75 , 53 ) ;
17890: LD_INT 75
17892: PPUSH
17893: LD_INT 53
17895: PPUSH
17896: CALL_OW 84
// wait ( 0 0$4 ) ;
17900: LD_INT 140
17902: PPUSH
17903: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
17907: LD_EXP 60
17911: PPUSH
17912: CALL_OW 87
// if not dialogue_skipped then
17916: LD_OWVAR 59
17920: NOT
17921: IFFALSE 17930
// wait ( 0 0$2 ) ;
17923: LD_INT 70
17925: PPUSH
17926: CALL_OW 67
// sync ;
17930: SYNC
// Say ( JMM , D1-JMM-2 ) ;
17931: LD_EXP 40
17935: PPUSH
17936: LD_STRING D1-JMM-2
17938: PPUSH
17939: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
17943: LD_EXP 60
17947: PPUSH
17948: LD_STRING D1-Pow-2
17950: PPUSH
17951: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
17955: LD_EXP 40
17959: PPUSH
17960: LD_STRING D1-JMM-3
17962: PPUSH
17963: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
17967: LD_EXP 60
17971: PPUSH
17972: LD_STRING D1-Pow-3
17974: PPUSH
17975: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
17979: LD_EXP 40
17983: PPUSH
17984: LD_STRING D1-JMM-4
17986: PPUSH
17987: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
17991: LD_EXP 60
17995: PPUSH
17996: LD_STRING D1-Pow-4
17998: PPUSH
17999: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
18003: LD_EXP 40
18007: PPUSH
18008: LD_STRING D1-JMM-5
18010: PPUSH
18011: CALL_OW 88
// async ;
18015: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
18016: LD_EXP 60
18020: PPUSH
18021: LD_STRING D1-Pow-5
18023: PPUSH
18024: CALL_OW 88
// if not dialogue_skipped then
18028: LD_OWVAR 59
18032: NOT
18033: IFFALSE 18042
// wait ( 0 0$3.6 ) ;
18035: LD_INT 126
18037: PPUSH
18038: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
18042: LD_INT 134
18044: PPUSH
18045: LD_INT 210
18047: PPUSH
18048: LD_INT 1
18050: PPUSH
18051: LD_INT 11
18053: NEG
18054: PPUSH
18055: CALL 106076 0 4
// if not dialogue_skipped then
18059: LD_OWVAR 59
18063: NOT
18064: IFFALSE 18083
// begin CenterOnXY ( 134 , 210 ) ;
18066: LD_INT 134
18068: PPUSH
18069: LD_INT 210
18071: PPUSH
18072: CALL_OW 84
// wait ( 0 0$2 ) ;
18076: LD_INT 70
18078: PPUSH
18079: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
18083: LD_INT 101
18085: PPUSH
18086: LD_INT 159
18088: PPUSH
18089: LD_INT 1
18091: PPUSH
18092: LD_INT 10
18094: NEG
18095: PPUSH
18096: CALL 106076 0 4
// if not dialogue_skipped then
18100: LD_OWVAR 59
18104: NOT
18105: IFFALSE 18124
// begin CenterOnXY ( 101 , 159 ) ;
18107: LD_INT 101
18109: PPUSH
18110: LD_INT 159
18112: PPUSH
18113: CALL_OW 84
// wait ( 0 0$2 ) ;
18117: LD_INT 70
18119: PPUSH
18120: CALL_OW 67
// end ; sync ;
18124: SYNC
// CenterNowOnUnits ( Powell ) ;
18125: LD_EXP 60
18129: PPUSH
18130: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
18134: LD_ADDR_VAR 0 6
18138: PUSH
18139: LD_INT 1
18141: PUSH
18142: LD_INT 2
18144: PUSH
18145: LD_INT 3
18147: PUSH
18148: LD_INT 4
18150: PUSH
18151: LD_INT 5
18153: PUSH
18154: LD_INT 6
18156: PUSH
18157: EMPTY
18158: LIST
18159: LIST
18160: LIST
18161: LIST
18162: LIST
18163: LIST
18164: ST_TO_ADDR
// if not dialogue_skipped then
18165: LD_OWVAR 59
18169: NOT
18170: IFFALSE 18339
// begin game_speed := 4 ;
18172: LD_ADDR_OWVAR 65
18176: PUSH
18177: LD_INT 4
18179: ST_TO_ADDR
// wait ( 0 0$6 ) ;
18180: LD_INT 210
18182: PPUSH
18183: CALL_OW 67
// dec := SelectiveQuery ( Q1 , options ) ;
18187: LD_ADDR_VAR 0 7
18191: PUSH
18192: LD_STRING Q1
18194: PPUSH
18195: LD_VAR 0 6
18199: PPUSH
18200: CALL_OW 98
18204: ST_TO_ADDR
// repeat dec := SelectiveQuery ( Q1 , options ) ;
18205: LD_ADDR_VAR 0 7
18209: PUSH
18210: LD_STRING Q1
18212: PPUSH
18213: LD_VAR 0 6
18217: PPUSH
18218: CALL_OW 98
18222: ST_TO_ADDR
// options := options diff dec ;
18223: LD_ADDR_VAR 0 6
18227: PUSH
18228: LD_VAR 0 6
18232: PUSH
18233: LD_VAR 0 7
18237: DIFF
18238: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
18239: LD_VAR 0 7
18243: PPUSH
18244: LD_VAR 0 6
18248: PPUSH
18249: CALL 19903 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
18253: LD_VAR 0 7
18257: PUSH
18258: LD_INT 5
18260: PUSH
18261: LD_INT 6
18263: PUSH
18264: EMPTY
18265: LIST
18266: LIST
18267: IN
18268: PUSH
18269: LD_VAR 0 6
18273: PUSH
18274: LD_INT 2
18276: EQUAL
18277: OR
18278: IFFALSE 18205
// if not ( dec in [ 5 , 6 ] ) then
18280: LD_VAR 0 7
18284: PUSH
18285: LD_INT 5
18287: PUSH
18288: LD_INT 6
18290: PUSH
18291: EMPTY
18292: LIST
18293: LIST
18294: IN
18295: NOT
18296: IFFALSE 18339
// begin dec := SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
18298: LD_ADDR_VAR 0 7
18302: PUSH
18303: LD_STRING Q1a
18305: PPUSH
18306: LD_INT 1
18308: PUSH
18309: LD_INT 2
18311: PUSH
18312: EMPTY
18313: LIST
18314: LIST
18315: PPUSH
18316: CALL_OW 98
18320: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
18321: LD_VAR 0 7
18325: PUSH
18326: LD_INT 4
18328: PLUS
18329: PPUSH
18330: LD_VAR 0 6
18334: PPUSH
18335: CALL 19903 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
18339: LD_INT 81
18341: PPUSH
18342: LD_INT 127
18344: PPUSH
18345: CALL_OW 84
// amount := 8 ;
18349: LD_ADDR_VAR 0 8
18353: PUSH
18354: LD_INT 8
18356: ST_TO_ADDR
// macmilan_squad := [ ] ;
18357: LD_ADDR_VAR 0 9
18361: PUSH
18362: EMPTY
18363: ST_TO_ADDR
// if vip < amount then
18364: LD_EXP 61
18368: PUSH
18369: LD_VAR 0 8
18373: LESS
18374: IFFALSE 18418
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
18376: LD_ADDR_VAR 0 5
18380: PUSH
18381: LD_EXP 61
18385: PUSH
18386: LD_INT 22
18388: PUSH
18389: LD_INT 4
18391: PUSH
18392: EMPTY
18393: LIST
18394: LIST
18395: PUSH
18396: LD_INT 21
18398: PUSH
18399: LD_INT 1
18401: PUSH
18402: EMPTY
18403: LIST
18404: LIST
18405: PUSH
18406: EMPTY
18407: LIST
18408: LIST
18409: PPUSH
18410: CALL_OW 69
18414: UNION
18415: ST_TO_ADDR
18416: GO 18428
// tmp := vip ;
18418: LD_ADDR_VAR 0 5
18422: PUSH
18423: LD_EXP 61
18427: ST_TO_ADDR
// tmp := tmp diff Powell ;
18428: LD_ADDR_VAR 0 5
18432: PUSH
18433: LD_VAR 0 5
18437: PUSH
18438: LD_EXP 60
18442: DIFF
18443: ST_TO_ADDR
// if tmp < amount then
18444: LD_VAR 0 5
18448: PUSH
18449: LD_VAR 0 8
18453: LESS
18454: IFFALSE 18466
// amount := tmp ;
18456: LD_ADDR_VAR 0 8
18460: PUSH
18461: LD_VAR 0 5
18465: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
18466: LD_VAR 0 5
18470: PUSH
18471: LD_INT 1
18473: ARRAY
18474: PPUSH
18475: CALL_OW 257
18479: PUSH
18480: LD_INT 2
18482: NONEQUAL
18483: IFFALSE 18581
// begin if IsInUnit ( tmp [ 1 ] ) then
18485: LD_VAR 0 5
18489: PUSH
18490: LD_INT 1
18492: ARRAY
18493: PPUSH
18494: CALL_OW 310
18498: IFFALSE 18513
// ComExitBuilding ( tmp [ 1 ] ) ;
18500: LD_VAR 0 5
18504: PUSH
18505: LD_INT 1
18507: ARRAY
18508: PPUSH
18509: CALL_OW 122
// if UnitsInside ( am_depot ) = 6 then
18513: LD_INT 387
18515: PPUSH
18516: CALL_OW 313
18520: PUSH
18521: LD_INT 6
18523: EQUAL
18524: IFFALSE 18549
// begin ComExitBuilding ( UnitsInside ( am_depot ) [ 1 ] ) ;
18526: LD_INT 387
18528: PPUSH
18529: CALL_OW 313
18533: PUSH
18534: LD_INT 1
18536: ARRAY
18537: PPUSH
18538: CALL_OW 122
// wait ( 3 ) ;
18542: LD_INT 3
18544: PPUSH
18545: CALL_OW 67
// end ; AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
18549: LD_VAR 0 5
18553: PUSH
18554: LD_INT 1
18556: ARRAY
18557: PPUSH
18558: LD_INT 387
18560: PPUSH
18561: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
18565: LD_VAR 0 5
18569: PUSH
18570: LD_INT 1
18572: ARRAY
18573: PPUSH
18574: LD_INT 2
18576: PPUSH
18577: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
18581: LD_EXP 40
18585: PPUSH
18586: LD_INT 82
18588: PPUSH
18589: LD_INT 129
18591: PPUSH
18592: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
18596: LD_EXP 40
18600: PPUSH
18601: LD_EXP 60
18605: PPUSH
18606: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
18610: LD_INT 22
18612: PUSH
18613: LD_INT 1
18615: PUSH
18616: EMPTY
18617: LIST
18618: LIST
18619: PPUSH
18620: CALL_OW 69
18624: PUSH
18625: LD_EXP 40
18629: DIFF
18630: PPUSH
18631: LD_INT 84
18633: PPUSH
18634: LD_INT 128
18636: PPUSH
18637: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
18641: LD_INT 22
18643: PUSH
18644: LD_INT 1
18646: PUSH
18647: EMPTY
18648: LIST
18649: LIST
18650: PPUSH
18651: CALL_OW 69
18655: PUSH
18656: LD_EXP 40
18660: DIFF
18661: PPUSH
18662: LD_EXP 40
18666: PPUSH
18667: CALL_OW 179
// for i = 1 to amount do
18671: LD_ADDR_VAR 0 2
18675: PUSH
18676: DOUBLE
18677: LD_INT 1
18679: DEC
18680: ST_TO_ADDR
18681: LD_VAR 0 8
18685: PUSH
18686: FOR_TO
18687: IFFALSE 18855
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
18689: LD_ADDR_VAR 0 9
18693: PUSH
18694: LD_VAR 0 9
18698: PUSH
18699: LD_VAR 0 5
18703: PUSH
18704: LD_VAR 0 2
18708: ARRAY
18709: ADD
18710: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
18711: LD_VAR 0 5
18715: PUSH
18716: LD_VAR 0 2
18720: ARRAY
18721: PPUSH
18722: CALL_OW 310
18726: IFFALSE 18743
// AddComExitBuilding ( tmp [ i ] ) ;
18728: LD_VAR 0 5
18732: PUSH
18733: LD_VAR 0 2
18737: ARRAY
18738: PPUSH
18739: CALL_OW 182
// if i = 2 and JMMNewVeh then
18743: LD_VAR 0 2
18747: PUSH
18748: LD_INT 2
18750: EQUAL
18751: PUSH
18752: LD_EXP 58
18756: AND
18757: IFFALSE 18815
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
18759: LD_VAR 0 5
18763: PUSH
18764: LD_VAR 0 2
18768: ARRAY
18769: PPUSH
18770: LD_EXP 58
18774: PPUSH
18775: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
18779: LD_VAR 0 5
18783: PUSH
18784: LD_VAR 0 2
18788: ARRAY
18789: PPUSH
18790: LD_INT 86
18792: PPUSH
18793: LD_INT 133
18795: PPUSH
18796: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
18800: LD_VAR 0 5
18804: PUSH
18805: LD_VAR 0 2
18809: ARRAY
18810: PPUSH
18811: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
18815: LD_VAR 0 5
18819: PUSH
18820: LD_VAR 0 2
18824: ARRAY
18825: PPUSH
18826: LD_INT 8
18828: PPUSH
18829: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
18833: LD_VAR 0 5
18837: PUSH
18838: LD_VAR 0 2
18842: ARRAY
18843: PPUSH
18844: LD_EXP 40
18848: PPUSH
18849: CALL_OW 179
// end ;
18853: GO 18686
18855: POP
18856: POP
// if GirlNewVeh then
18857: LD_EXP 59
18861: IFFALSE 18875
// SetSide ( GirlNewVeh , 4 ) ;
18863: LD_EXP 59
18867: PPUSH
18868: LD_INT 4
18870: PPUSH
18871: CALL_OW 235
// if Mike then
18875: LD_EXP 57
18879: IFFALSE 18916
// begin macmilan_squad := Join ( macmilan_squad , Mike ) ;
18881: LD_ADDR_VAR 0 9
18885: PUSH
18886: LD_VAR 0 9
18890: PPUSH
18891: LD_EXP 57
18895: PPUSH
18896: CALL 106190 0 2
18900: ST_TO_ADDR
// ComMoveXY ( Mike , 86 , 133 ) ;
18901: LD_EXP 57
18905: PPUSH
18906: LD_INT 86
18908: PPUSH
18909: LD_INT 133
18911: PPUSH
18912: CALL_OW 111
// end ; repeat wait ( 0 0$1 ) ;
18916: LD_INT 35
18918: PPUSH
18919: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
18923: LD_VAR 0 9
18927: PPUSH
18928: LD_INT 95
18930: PUSH
18931: LD_INT 9
18933: PUSH
18934: EMPTY
18935: LIST
18936: LIST
18937: PPUSH
18938: CALL_OW 72
18942: PUSH
18943: LD_INT 0
18945: EQUAL
18946: PUSH
18947: LD_EXP 40
18951: PPUSH
18952: LD_INT 9
18954: PPUSH
18955: CALL_OW 308
18959: NOT
18960: AND
18961: IFFALSE 18916
// wait ( 0 0$2 ) ;
18963: LD_INT 70
18965: PPUSH
18966: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
18970: LD_VAR 0 9
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
18982: LD_INT 21
18984: PUSH
18985: LD_INT 2
18987: PUSH
18988: EMPTY
18989: LIST
18990: LIST
18991: PUSH
18992: LD_INT 92
18994: PUSH
18995: LD_INT 83
18997: PUSH
18998: LD_INT 130
19000: PUSH
19001: LD_INT 10
19003: PUSH
19004: EMPTY
19005: LIST
19006: LIST
19007: LIST
19008: LIST
19009: PUSH
19010: EMPTY
19011: LIST
19012: LIST
19013: PPUSH
19014: CALL_OW 69
19018: PPUSH
19019: LD_INT 1
19021: PPUSH
19022: CALL_OW 235
// tick := 0 ;
19026: LD_ADDR_OWVAR 1
19030: PUSH
19031: LD_INT 0
19033: ST_TO_ADDR
// Video ( false ) ;
19034: LD_INT 0
19036: PPUSH
19037: CALL 106162 0 1
// ChangeMissionObjectives ( M1 ) ;
19041: LD_STRING M1
19043: PPUSH
19044: CALL_OW 337
// SaveForQuickRestart ;
19048: CALL_OW 22
// missionStart := true ;
19052: LD_ADDR_EXP 13
19056: PUSH
19057: LD_INT 1
19059: ST_TO_ADDR
// missionStage := 2 ;
19060: LD_ADDR_EXP 15
19064: PUSH
19065: LD_INT 2
19067: ST_TO_ADDR
// wait ( 0 0$1 ) ;
19068: LD_INT 35
19070: PPUSH
19071: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
19075: LD_ADDR_VAR 0 5
19079: PUSH
19080: LD_INT 22
19082: PUSH
19083: LD_INT 4
19085: PUSH
19086: EMPTY
19087: LIST
19088: LIST
19089: PUSH
19090: LD_INT 21
19092: PUSH
19093: LD_INT 1
19095: PUSH
19096: EMPTY
19097: LIST
19098: LIST
19099: PUSH
19100: EMPTY
19101: LIST
19102: LIST
19103: PPUSH
19104: CALL_OW 69
19108: PUSH
19109: LD_EXP 60
19113: DIFF
19114: ST_TO_ADDR
// if not tmp then
19115: LD_VAR 0 5
19119: NOT
19120: IFFALSE 19135
// tmp := [ Powell ] ;
19122: LD_ADDR_VAR 0 5
19126: PUSH
19127: LD_EXP 60
19131: PUSH
19132: EMPTY
19133: LIST
19134: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
19135: LD_ADDR_VAR 0 4
19139: PUSH
19140: LD_INT 22
19142: PUSH
19143: LD_INT 4
19145: PUSH
19146: EMPTY
19147: LIST
19148: LIST
19149: PUSH
19150: LD_INT 34
19152: PUSH
19153: LD_INT 12
19155: PUSH
19156: EMPTY
19157: LIST
19158: LIST
19159: PUSH
19160: EMPTY
19161: LIST
19162: LIST
19163: PPUSH
19164: CALL_OW 69
19168: PUSH
19169: LD_INT 1
19171: ARRAY
19172: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
19173: LD_VAR 0 5
19177: PUSH
19178: LD_INT 1
19180: ARRAY
19181: PPUSH
19182: CALL_OW 310
19186: IFFALSE 19201
// ComExitBuilding ( tmp [ 1 ] ) ;
19188: LD_VAR 0 5
19192: PUSH
19193: LD_INT 1
19195: ARRAY
19196: PPUSH
19197: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
19201: LD_VAR 0 5
19205: PUSH
19206: LD_INT 1
19208: ARRAY
19209: PPUSH
19210: LD_VAR 0 4
19214: PPUSH
19215: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
19219: LD_VAR 0 5
19223: PUSH
19224: LD_INT 1
19226: ARRAY
19227: PPUSH
19228: LD_INT 80
19230: PPUSH
19231: LD_INT 136
19233: PPUSH
19234: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
19238: LD_VAR 0 5
19242: PUSH
19243: LD_INT 1
19245: ARRAY
19246: PPUSH
19247: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
19251: LD_VAR 0 5
19255: PUSH
19256: LD_INT 1
19258: ARRAY
19259: PPUSH
19260: LD_INT 59
19262: PPUSH
19263: LD_INT 112
19265: PPUSH
19266: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
19270: LD_VAR 0 5
19274: PUSH
19275: LD_INT 1
19277: ARRAY
19278: PPUSH
19279: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
19283: LD_EXP 41
19287: PUSH
19288: LD_EXP 41
19292: PPUSH
19293: CALL_OW 255
19297: PUSH
19298: LD_INT 1
19300: EQUAL
19301: AND
19302: IFFALSE 19328
// begin Say ( Joan , D3W-Joan-1 ) ;
19304: LD_EXP 41
19308: PPUSH
19309: LD_STRING D3W-Joan-1
19311: PPUSH
19312: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19316: LD_EXP 40
19320: PPUSH
19321: LD_STRING D3W-JMM-1
19323: PPUSH
19324: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
19328: LD_EXP 43
19332: PUSH
19333: LD_EXP 43
19337: PPUSH
19338: CALL_OW 255
19342: PUSH
19343: LD_INT 1
19345: EQUAL
19346: AND
19347: PUSH
19348: LD_EXP 43
19352: PUSH
19353: LD_EXP 61
19357: IN
19358: NOT
19359: AND
19360: IFFALSE 19386
// begin Say ( Lisa , D3W-Lisa-1 ) ;
19362: LD_EXP 43
19366: PPUSH
19367: LD_STRING D3W-Lisa-1
19369: PPUSH
19370: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19374: LD_EXP 40
19378: PPUSH
19379: LD_STRING D3W-JMM-1
19381: PPUSH
19382: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
19386: LD_EXP 55
19390: PUSH
19391: LD_EXP 55
19395: PPUSH
19396: CALL_OW 255
19400: PUSH
19401: LD_INT 1
19403: EQUAL
19404: AND
19405: IFFALSE 19431
// begin Say ( Connie , D3W-Con-1 ) ;
19407: LD_EXP 55
19411: PPUSH
19412: LD_STRING D3W-Con-1
19414: PPUSH
19415: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
19419: LD_EXP 40
19423: PPUSH
19424: LD_STRING D3W-JMM-1
19426: PPUSH
19427: CALL_OW 88
// end ; wait ( 0 0$0.5 ) ;
19431: LD_INT 18
19433: PPUSH
19434: CALL_OW 67
// if Lisa in vip and GetSide ( Lisa ) = 1 then
19438: LD_EXP 43
19442: PUSH
19443: LD_EXP 61
19447: IN
19448: PUSH
19449: LD_EXP 43
19453: PPUSH
19454: CALL_OW 255
19458: PUSH
19459: LD_INT 1
19461: EQUAL
19462: AND
19463: IFFALSE 19479
// Say ( Lisa , D3nW-Lisa-1 ) else
19465: LD_EXP 43
19469: PPUSH
19470: LD_STRING D3nW-Lisa-1
19472: PPUSH
19473: CALL_OW 88
19477: GO 19723
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
19479: LD_EXP 46
19483: PUSH
19484: LD_EXP 61
19488: IN
19489: PUSH
19490: LD_EXP 46
19494: PPUSH
19495: CALL_OW 255
19499: PUSH
19500: LD_INT 1
19502: EQUAL
19503: AND
19504: IFFALSE 19520
// Say ( Cyrus , D3nW-Cyrus-1 ) else
19506: LD_EXP 46
19510: PPUSH
19511: LD_STRING D3nW-Cyrus-1
19513: PPUSH
19514: CALL_OW 88
19518: GO 19723
// if Bobby in vip and GetSide ( Bobby ) = 1 then
19520: LD_EXP 45
19524: PUSH
19525: LD_EXP 61
19529: IN
19530: PUSH
19531: LD_EXP 45
19535: PPUSH
19536: CALL_OW 255
19540: PUSH
19541: LD_INT 1
19543: EQUAL
19544: AND
19545: IFFALSE 19561
// Say ( Bobby , D3nW-Bobby-1 ) else
19547: LD_EXP 45
19551: PPUSH
19552: LD_STRING D3nW-Bobby-1
19554: PPUSH
19555: CALL_OW 88
19559: GO 19723
// if Gary in vip and GetSide ( Gary ) = 1 then
19561: LD_EXP 52
19565: PUSH
19566: LD_EXP 61
19570: IN
19571: PUSH
19572: LD_EXP 52
19576: PPUSH
19577: CALL_OW 255
19581: PUSH
19582: LD_INT 1
19584: EQUAL
19585: AND
19586: IFFALSE 19602
// Say ( Gary , D3nW-Gary-1 ) else
19588: LD_EXP 52
19592: PPUSH
19593: LD_STRING D3nW-Gary-1
19595: PPUSH
19596: CALL_OW 88
19600: GO 19723
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
19602: LD_EXP 44
19606: PUSH
19607: LD_EXP 61
19611: IN
19612: PUSH
19613: LD_EXP 44
19617: PPUSH
19618: CALL_OW 255
19622: PUSH
19623: LD_INT 1
19625: EQUAL
19626: AND
19627: IFFALSE 19643
// Say ( Donaldson , D3nW-Don-1 ) else
19629: LD_EXP 44
19633: PPUSH
19634: LD_STRING D3nW-Don-1
19636: PPUSH
19637: CALL_OW 88
19641: GO 19723
// if Cornel in vip and GetSide ( Cornel ) = 1 then
19643: LD_EXP 51
19647: PUSH
19648: LD_EXP 61
19652: IN
19653: PUSH
19654: LD_EXP 51
19658: PPUSH
19659: CALL_OW 255
19663: PUSH
19664: LD_INT 1
19666: EQUAL
19667: AND
19668: IFFALSE 19684
// Say ( Cornel , D3nW-Corn-1 ) else
19670: LD_EXP 51
19674: PPUSH
19675: LD_STRING D3nW-Corn-1
19677: PPUSH
19678: CALL_OW 88
19682: GO 19723
// if Frank in vip and GetSide ( Frank ) = 1 then
19684: LD_EXP 53
19688: PUSH
19689: LD_EXP 61
19693: IN
19694: PUSH
19695: LD_EXP 53
19699: PPUSH
19700: CALL_OW 255
19704: PUSH
19705: LD_INT 1
19707: EQUAL
19708: AND
19709: IFFALSE 19723
// Say ( Frank , D3nW-Frank-1 ) ;
19711: LD_EXP 53
19715: PPUSH
19716: LD_STRING D3nW-Frank-1
19718: PPUSH
19719: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
19723: LD_EXP 61
19727: PPUSH
19728: LD_INT 22
19730: PUSH
19731: LD_INT 1
19733: PUSH
19734: EMPTY
19735: LIST
19736: LIST
19737: PPUSH
19738: CALL_OW 72
19742: IFFALSE 19768
// begin Say ( JMM , D3nW-JMM-1 ) ;
19744: LD_EXP 40
19748: PPUSH
19749: LD_STRING D3nW-JMM-1
19751: PPUSH
19752: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
19756: LD_EXP 40
19760: PPUSH
19761: LD_STRING D3nW-JMM-1a
19763: PPUSH
19764: CALL_OW 88
// end ; t := 0 0$00 ;
19768: LD_ADDR_VAR 0 3
19772: PUSH
19773: LD_INT 0
19775: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
19776: LD_INT 35
19778: PPUSH
19779: CALL_OW 67
// t := t + 0 0$1 ;
19783: LD_ADDR_VAR 0 3
19787: PUSH
19788: LD_VAR 0 3
19792: PUSH
19793: LD_INT 35
19795: PLUS
19796: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
19797: LD_INT 59
19799: PPUSH
19800: LD_INT 112
19802: PPUSH
19803: CALL_OW 428
19807: PUSH
19808: LD_VAR 0 3
19812: PUSH
19813: LD_INT 2100
19815: GREATER
19816: OR
19817: IFFALSE 19776
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
19819: LD_ADDR_EXP 100
19823: PUSH
19824: LD_EXP 100
19828: PPUSH
19829: LD_INT 4
19831: PPUSH
19832: LD_INT 22
19834: PUSH
19835: LD_INT 4
19837: PUSH
19838: EMPTY
19839: LIST
19840: LIST
19841: PUSH
19842: LD_INT 23
19844: PUSH
19845: LD_INT 1
19847: PUSH
19848: EMPTY
19849: LIST
19850: LIST
19851: PUSH
19852: LD_INT 3
19854: PUSH
19855: LD_INT 21
19857: PUSH
19858: LD_INT 2
19860: PUSH
19861: EMPTY
19862: LIST
19863: LIST
19864: PUSH
19865: EMPTY
19866: LIST
19867: LIST
19868: PUSH
19869: EMPTY
19870: LIST
19871: LIST
19872: LIST
19873: PPUSH
19874: CALL_OW 69
19878: PUSH
19879: LD_EXP 60
19883: DIFF
19884: PPUSH
19885: CALL_OW 1
19889: ST_TO_ADDR
// activeAttacks := true ;
19890: LD_ADDR_EXP 16
19894: PUSH
19895: LD_INT 1
19897: ST_TO_ADDR
// end ;
19898: LD_VAR 0 1
19902: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
19903: LD_INT 0
19905: PPUSH
// case question of 1 :
19906: LD_VAR 0 1
19910: PUSH
19911: LD_INT 1
19913: DOUBLE
19914: EQUAL
19915: IFTRUE 19919
19917: GO 19970
19919: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
19920: LD_EXP 40
19924: PPUSH
19925: LD_STRING D2Mot-JMM-1
19927: PPUSH
19928: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
19932: LD_EXP 60
19936: PPUSH
19937: LD_STRING D2Mot-Pow-1
19939: PPUSH
19940: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
19944: LD_EXP 40
19948: PPUSH
19949: LD_STRING D2Mot-JMM-2
19951: PPUSH
19952: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
19956: LD_EXP 60
19960: PPUSH
19961: LD_STRING D2Mot-Pow-2
19963: PPUSH
19964: CALL_OW 88
// end ; 2 :
19968: GO 20321
19970: LD_INT 2
19972: DOUBLE
19973: EQUAL
19974: IFTRUE 19978
19976: GO 20054
19978: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
19979: LD_EXP 40
19983: PPUSH
19984: LD_STRING D2Rus-JMM-1
19986: PPUSH
19987: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
19991: LD_EXP 60
19995: PPUSH
19996: LD_STRING D2Rus-Pow-1
19998: PPUSH
19999: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
20003: LD_EXP 40
20007: PPUSH
20008: LD_STRING D2Rus-JMM-2
20010: PPUSH
20011: CALL_OW 88
// if not ( 3 in list_of_q ) then
20015: LD_INT 3
20017: PUSH
20018: LD_VAR 0 2
20022: IN
20023: NOT
20024: IFFALSE 20040
// Say ( Powell , D2Rus-Pow-2 ) else
20026: LD_EXP 60
20030: PPUSH
20031: LD_STRING D2Rus-Pow-2
20033: PPUSH
20034: CALL_OW 88
20038: GO 20052
// Say ( Powell , D2Rus-Pow-2a ) ;
20040: LD_EXP 60
20044: PPUSH
20045: LD_STRING D2Rus-Pow-2a
20047: PPUSH
20048: CALL_OW 88
// end ; 3 :
20052: GO 20321
20054: LD_INT 3
20056: DOUBLE
20057: EQUAL
20058: IFTRUE 20062
20060: GO 20147
20062: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
20063: LD_EXP 40
20067: PPUSH
20068: LD_STRING D2Leg-JMM-1
20070: PPUSH
20071: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
20075: LD_EXP 60
20079: PPUSH
20080: LD_STRING D2Leg-Pow-1
20082: PPUSH
20083: CALL_OW 88
// if 2 in list_of_q then
20087: LD_INT 2
20089: PUSH
20090: LD_VAR 0 2
20094: IN
20095: IFFALSE 20121
// begin Say ( JMM , D2Leg-JMM-2 ) ;
20097: LD_EXP 40
20101: PPUSH
20102: LD_STRING D2Leg-JMM-2
20104: PPUSH
20105: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
20109: LD_EXP 60
20113: PPUSH
20114: LD_STRING D2Leg-Pow-2
20116: PPUSH
20117: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
20121: LD_EXP 40
20125: PPUSH
20126: LD_STRING D2Leg-JMM-3
20128: PPUSH
20129: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
20133: LD_EXP 60
20137: PPUSH
20138: LD_STRING D2Leg-Pow-3
20140: PPUSH
20141: CALL_OW 88
// end ; 4 :
20145: GO 20321
20147: LD_INT 4
20149: DOUBLE
20150: EQUAL
20151: IFTRUE 20155
20153: GO 20230
20155: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
20156: LD_EXP 40
20160: PPUSH
20161: LD_STRING D2Ar-JMM-1
20163: PPUSH
20164: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
20168: LD_EXP 60
20172: PPUSH
20173: LD_STRING D2Ar-Pow-1
20175: PPUSH
20176: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
20180: LD_EXP 40
20184: PPUSH
20185: LD_STRING D2Ar-JMM-2
20187: PPUSH
20188: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
20192: LD_EXP 60
20196: PPUSH
20197: LD_STRING D2Ar-Pow-2
20199: PPUSH
20200: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
20204: LD_EXP 40
20208: PPUSH
20209: LD_STRING D2Ar-JMM-3
20211: PPUSH
20212: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
20216: LD_EXP 60
20220: PPUSH
20221: LD_STRING D2Ar-Pow-3
20223: PPUSH
20224: CALL_OW 88
// end ; 5 :
20228: GO 20321
20230: LD_INT 5
20232: DOUBLE
20233: EQUAL
20234: IFTRUE 20238
20236: GO 20253
20238: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
20239: LD_EXP 40
20243: PPUSH
20244: LD_STRING D2Conf-JMM-1
20246: PPUSH
20247: CALL_OW 88
20251: GO 20321
20253: LD_INT 6
20255: DOUBLE
20256: EQUAL
20257: IFTRUE 20261
20259: GO 20320
20261: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
20262: LD_EXP 40
20266: PPUSH
20267: LD_STRING D2Com-JMM-1
20269: PPUSH
20270: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
20274: LD_EXP 60
20278: PPUSH
20279: LD_STRING D2Com-Pow-1
20281: PPUSH
20282: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
20286: LD_EXP 40
20290: PPUSH
20291: LD_STRING D2Com-JMM-2
20293: PPUSH
20294: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
20298: LD_EXP 60
20302: PPUSH
20303: LD_STRING D2Com-Pow-2
20305: PPUSH
20306: CALL_OW 88
// powellAngerQuery := true ;
20310: LD_ADDR_EXP 36
20314: PUSH
20315: LD_INT 1
20317: ST_TO_ADDR
// end ; end ;
20318: GO 20321
20320: POP
// end ;
20321: LD_VAR 0 3
20325: RET
// every 0 0$5 trigger missionStart do var tmp ;
20326: LD_EXP 13
20330: IFFALSE 20655
20332: GO 20334
20334: DISABLE
20335: LD_INT 0
20337: PPUSH
// begin repeat wait ( 0 0$1 ) ;
20338: LD_INT 35
20340: PPUSH
20341: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
20345: LD_INT 14
20347: PPUSH
20348: LD_INT 22
20350: PUSH
20351: LD_INT 1
20353: PUSH
20354: EMPTY
20355: LIST
20356: LIST
20357: PUSH
20358: LD_INT 3
20360: PUSH
20361: LD_INT 21
20363: PUSH
20364: LD_INT 3
20366: PUSH
20367: EMPTY
20368: LIST
20369: LIST
20370: PUSH
20371: EMPTY
20372: LIST
20373: LIST
20374: PUSH
20375: EMPTY
20376: LIST
20377: LIST
20378: PPUSH
20379: CALL_OW 70
20383: PUSH
20384: LD_EXP 15
20388: PUSH
20389: LD_INT 2
20391: PUSH
20392: LD_INT 3
20394: PUSH
20395: LD_INT 4
20397: PUSH
20398: LD_INT 5
20400: PUSH
20401: EMPTY
20402: LIST
20403: LIST
20404: LIST
20405: LIST
20406: IN
20407: AND
20408: IFFALSE 20645
// begin powellAnger := powellAnger + 1 ;
20410: LD_ADDR_EXP 17
20414: PUSH
20415: LD_EXP 17
20419: PUSH
20420: LD_INT 1
20422: PLUS
20423: ST_TO_ADDR
// Video ( true ) ;
20424: LD_INT 1
20426: PPUSH
20427: CALL 106162 0 1
// CenterNowOnUnits ( tmp ) ;
20431: LD_VAR 0 1
20435: PPUSH
20436: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20440: LD_INT 14
20442: PPUSH
20443: LD_INT 22
20445: PUSH
20446: LD_INT 1
20448: PUSH
20449: EMPTY
20450: LIST
20451: LIST
20452: PPUSH
20453: CALL_OW 70
20457: PPUSH
20458: LD_INT 86
20460: PPUSH
20461: LD_INT 133
20463: PPUSH
20464: CALL_OW 111
// async ;
20468: ASYNC
// case powellAnger of 1 :
20469: LD_EXP 17
20473: PUSH
20474: LD_INT 1
20476: DOUBLE
20477: EQUAL
20478: IFTRUE 20482
20480: GO 20497
20482: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
20483: LD_EXP 60
20487: PPUSH
20488: LD_STRING DBack1-Pow-1
20490: PPUSH
20491: CALL_OW 88
20495: GO 20544
20497: LD_INT 2
20499: DOUBLE
20500: EQUAL
20501: IFTRUE 20505
20503: GO 20520
20505: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
20506: LD_EXP 60
20510: PPUSH
20511: LD_STRING DBack2-Pow-1
20513: PPUSH
20514: CALL_OW 88
20518: GO 20544
20520: LD_INT 3
20522: DOUBLE
20523: EQUAL
20524: IFTRUE 20528
20526: GO 20543
20528: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
20529: LD_EXP 60
20533: PPUSH
20534: LD_STRING DBack3-Pow-1
20536: PPUSH
20537: CALL_OW 88
20541: GO 20544
20543: POP
// sync ;
20544: SYNC
// repeat wait ( 0 0$1 ) ;
20545: LD_INT 35
20547: PPUSH
20548: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
20552: LD_INT 14
20554: PPUSH
20555: LD_INT 22
20557: PUSH
20558: LD_INT 1
20560: PUSH
20561: EMPTY
20562: LIST
20563: LIST
20564: PPUSH
20565: CALL_OW 70
20569: PPUSH
20570: LD_INT 86
20572: PPUSH
20573: LD_INT 133
20575: PPUSH
20576: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20580: LD_INT 14
20582: PPUSH
20583: LD_INT 22
20585: PUSH
20586: LD_INT 1
20588: PUSH
20589: EMPTY
20590: LIST
20591: LIST
20592: PUSH
20593: LD_INT 3
20595: PUSH
20596: LD_INT 21
20598: PUSH
20599: LD_INT 3
20601: PUSH
20602: EMPTY
20603: LIST
20604: LIST
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PUSH
20610: EMPTY
20611: LIST
20612: LIST
20613: PPUSH
20614: CALL_OW 70
20618: NOT
20619: IFFALSE 20545
// if powellAnger >= 3 then
20621: LD_EXP 17
20625: PUSH
20626: LD_INT 3
20628: GREATEREQUAL
20629: IFFALSE 20638
// YouLost ( Dismissed ) ;
20631: LD_STRING Dismissed
20633: PPUSH
20634: CALL_OW 104
// Video ( false ) ;
20638: LD_INT 0
20640: PPUSH
20641: CALL 106162 0 1
// end ; until missionStage > 5 ;
20645: LD_EXP 15
20649: PUSH
20650: LD_INT 5
20652: GREATER
20653: IFFALSE 20338
// end ;
20655: PPOPN 1
20657: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un , emptyTowers , t ;
20658: LD_EXP 13
20662: PUSH
20663: LD_INT 22
20665: PUSH
20666: LD_INT 4
20668: PUSH
20669: EMPTY
20670: LIST
20671: LIST
20672: PUSH
20673: LD_INT 21
20675: PUSH
20676: LD_INT 2
20678: PUSH
20679: EMPTY
20680: LIST
20681: LIST
20682: PUSH
20683: EMPTY
20684: LIST
20685: LIST
20686: PPUSH
20687: CALL_OW 69
20691: PUSH
20692: LD_INT 4
20694: GREATEREQUAL
20695: AND
20696: PUSH
20697: LD_EXP 15
20701: PUSH
20702: LD_INT 2
20704: EQUAL
20705: AND
20706: IFFALSE 22896
20708: GO 20710
20710: DISABLE
20711: LD_INT 0
20713: PPUSH
20714: PPUSH
20715: PPUSH
20716: PPUSH
20717: PPUSH
20718: PPUSH
20719: PPUSH
20720: PPUSH
20721: PPUSH
20722: PPUSH
// begin missionStage := 3 ;
20723: LD_ADDR_EXP 15
20727: PUSH
20728: LD_INT 3
20730: ST_TO_ADDR
// retreat := false ;
20731: LD_ADDR_VAR 0 4
20735: PUSH
20736: LD_INT 0
20738: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
20739: LD_ADDR_VAR 0 5
20743: PUSH
20744: LD_INT 22
20746: PUSH
20747: LD_INT 4
20749: PUSH
20750: EMPTY
20751: LIST
20752: LIST
20753: PUSH
20754: LD_INT 30
20756: PUSH
20757: LD_INT 4
20759: PUSH
20760: EMPTY
20761: LIST
20762: LIST
20763: PUSH
20764: EMPTY
20765: LIST
20766: LIST
20767: PPUSH
20768: CALL_OW 69
20772: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
20773: LD_ADDR_VAR 0 6
20777: PUSH
20778: LD_INT 22
20780: PUSH
20781: LD_INT 4
20783: PUSH
20784: EMPTY
20785: LIST
20786: LIST
20787: PUSH
20788: LD_INT 30
20790: PUSH
20791: LD_INT 5
20793: PUSH
20794: EMPTY
20795: LIST
20796: LIST
20797: PUSH
20798: EMPTY
20799: LIST
20800: LIST
20801: PPUSH
20802: CALL_OW 69
20806: ST_TO_ADDR
// if not bar then
20807: LD_VAR 0 6
20811: NOT
20812: IFFALSE 20865
// begin repeat wait ( 0 0$1 ) ;
20814: LD_INT 35
20816: PPUSH
20817: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
20821: LD_INT 22
20823: PUSH
20824: LD_INT 4
20826: PUSH
20827: EMPTY
20828: LIST
20829: LIST
20830: PUSH
20831: LD_INT 3
20833: PUSH
20834: LD_INT 57
20836: PUSH
20837: EMPTY
20838: LIST
20839: PUSH
20840: EMPTY
20841: LIST
20842: LIST
20843: PUSH
20844: LD_INT 30
20846: PUSH
20847: LD_INT 5
20849: PUSH
20850: EMPTY
20851: LIST
20852: LIST
20853: PUSH
20854: EMPTY
20855: LIST
20856: LIST
20857: LIST
20858: PPUSH
20859: CALL_OW 69
20863: IFFALSE 20814
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
20865: LD_ADDR_VAR 0 6
20869: PUSH
20870: LD_INT 22
20872: PUSH
20873: LD_INT 4
20875: PUSH
20876: EMPTY
20877: LIST
20878: LIST
20879: PUSH
20880: LD_INT 30
20882: PUSH
20883: LD_INT 5
20885: PUSH
20886: EMPTY
20887: LIST
20888: LIST
20889: PUSH
20890: EMPTY
20891: LIST
20892: LIST
20893: PPUSH
20894: CALL_OW 69
20898: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20899: LD_INT 35
20901: PPUSH
20902: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
20906: LD_EXP 119
20910: PUSH
20911: LD_INT 4
20913: ARRAY
20914: PUSH
20915: LD_INT 4
20917: GREATEREQUAL
20918: IFFALSE 20899
// tmp := [ ] ;
20920: LD_ADDR_VAR 0 2
20924: PUSH
20925: EMPTY
20926: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) do
20927: LD_ADDR_VAR 0 1
20931: PUSH
20932: LD_INT 22
20934: PUSH
20935: LD_INT 4
20937: PUSH
20938: EMPTY
20939: LIST
20940: LIST
20941: PUSH
20942: LD_INT 2
20944: PUSH
20945: LD_INT 25
20947: PUSH
20948: LD_INT 1
20950: PUSH
20951: EMPTY
20952: LIST
20953: LIST
20954: PUSH
20955: LD_INT 25
20957: PUSH
20958: LD_INT 2
20960: PUSH
20961: EMPTY
20962: LIST
20963: LIST
20964: PUSH
20965: LD_INT 25
20967: PUSH
20968: LD_INT 3
20970: PUSH
20971: EMPTY
20972: LIST
20973: LIST
20974: PUSH
20975: LD_INT 25
20977: PUSH
20978: LD_INT 4
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: PUSH
20985: LD_INT 25
20987: PUSH
20988: LD_INT 5
20990: PUSH
20991: EMPTY
20992: LIST
20993: LIST
20994: PUSH
20995: EMPTY
20996: LIST
20997: LIST
20998: LIST
20999: LIST
21000: LIST
21001: LIST
21002: PUSH
21003: EMPTY
21004: LIST
21005: LIST
21006: PPUSH
21007: CALL_OW 69
21011: PUSH
21012: LD_EXP 60
21016: PUSH
21017: LD_EXP 61
21021: ADD
21022: DIFF
21023: PUSH
21024: FOR_IN
21025: IFFALSE 21089
// if GetTag ( i ) = 1 then
21027: LD_VAR 0 1
21031: PPUSH
21032: CALL_OW 110
21036: PUSH
21037: LD_INT 1
21039: EQUAL
21040: IFFALSE 21064
// tmp := Join ( tmp , i ) else
21042: LD_ADDR_VAR 0 2
21046: PUSH
21047: LD_VAR 0 2
21051: PPUSH
21052: LD_VAR 0 1
21056: PPUSH
21057: CALL 106190 0 2
21061: ST_TO_ADDR
21062: GO 21087
// tmp := Insert ( tmp , 1 , i ) ;
21064: LD_ADDR_VAR 0 2
21068: PUSH
21069: LD_VAR 0 2
21073: PPUSH
21074: LD_INT 1
21076: PPUSH
21077: LD_VAR 0 1
21081: PPUSH
21082: CALL_OW 2
21086: ST_TO_ADDR
21087: GO 21024
21089: POP
21090: POP
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
21091: LD_ADDR_VAR 0 3
21095: PUSH
21096: LD_VAR 0 2
21100: PPUSH
21101: LD_INT 26
21103: PUSH
21104: LD_INT 1
21106: PUSH
21107: EMPTY
21108: LIST
21109: LIST
21110: PPUSH
21111: CALL_OW 72
21115: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
21116: LD_ADDR_VAR 0 2
21120: PUSH
21121: LD_VAR 0 2
21125: PUSH
21126: LD_VAR 0 3
21130: DIFF
21131: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 3 ) ;
21132: LD_ADDR_VAR 0 2
21136: PUSH
21137: LD_VAR 0 2
21141: PPUSH
21142: LD_INT 3
21144: PPUSH
21145: CALL 104707 0 2
21149: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 3 ) ;
21150: LD_ADDR_VAR 0 3
21154: PUSH
21155: LD_VAR 0 3
21159: PPUSH
21160: LD_INT 3
21162: PPUSH
21163: CALL 104707 0 2
21167: ST_TO_ADDR
// for i := 1 to 4 do
21168: LD_ADDR_VAR 0 1
21172: PUSH
21173: DOUBLE
21174: LD_INT 1
21176: DEC
21177: ST_TO_ADDR
21178: LD_INT 4
21180: PUSH
21181: FOR_TO
21182: IFFALSE 21335
// begin if tmp2 then
21184: LD_VAR 0 3
21188: IFFALSE 21256
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
21190: LD_ADDR_EXP 18
21194: PUSH
21195: LD_EXP 18
21199: PPUSH
21200: LD_INT 1
21202: PPUSH
21203: LD_EXP 18
21207: PUSH
21208: LD_INT 1
21210: ARRAY
21211: PUSH
21212: LD_VAR 0 3
21216: PUSH
21217: LD_VAR 0 3
21221: ARRAY
21222: ADD
21223: PPUSH
21224: CALL_OW 1
21228: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
21229: LD_VAR 0 3
21233: PUSH
21234: LD_VAR 0 3
21238: ARRAY
21239: PPUSH
21240: LD_INT 1
21242: PPUSH
21243: CALL_OW 109
// tmp2 := [ ] ;
21247: LD_ADDR_VAR 0 3
21251: PUSH
21252: EMPTY
21253: ST_TO_ADDR
// end else
21254: GO 21333
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
21256: LD_ADDR_EXP 18
21260: PUSH
21261: LD_EXP 18
21265: PPUSH
21266: LD_INT 1
21268: PPUSH
21269: LD_EXP 18
21273: PUSH
21274: LD_INT 1
21276: ARRAY
21277: PUSH
21278: LD_VAR 0 2
21282: PUSH
21283: LD_VAR 0 2
21287: ARRAY
21288: ADD
21289: PPUSH
21290: CALL_OW 1
21294: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
21295: LD_VAR 0 2
21299: PUSH
21300: LD_VAR 0 2
21304: ARRAY
21305: PPUSH
21306: LD_INT 1
21308: PPUSH
21309: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
21313: LD_ADDR_VAR 0 2
21317: PUSH
21318: LD_VAR 0 2
21322: PPUSH
21323: LD_VAR 0 2
21327: PPUSH
21328: CALL_OW 3
21332: ST_TO_ADDR
// end ; end ;
21333: GO 21181
21335: POP
21336: POP
// if tmp2 then
21337: LD_VAR 0 3
21341: IFFALSE 21359
// tmp := tmp union tmp2 ;
21343: LD_ADDR_VAR 0 2
21347: PUSH
21348: LD_VAR 0 2
21352: PUSH
21353: LD_VAR 0 3
21357: UNION
21358: ST_TO_ADDR
// for i := 1 to 4 do
21359: LD_ADDR_VAR 0 1
21363: PUSH
21364: DOUBLE
21365: LD_INT 1
21367: DEC
21368: ST_TO_ADDR
21369: LD_INT 4
21371: PUSH
21372: FOR_TO
21373: IFFALSE 21422
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
21375: LD_ADDR_EXP 18
21379: PUSH
21380: LD_EXP 18
21384: PPUSH
21385: LD_INT 2
21387: PPUSH
21388: LD_EXP 18
21392: PUSH
21393: LD_INT 2
21395: ARRAY
21396: PUSH
21397: LD_VAR 0 2
21401: PUSH
21402: LD_VAR 0 2
21406: PUSH
21407: LD_VAR 0 1
21411: MINUS
21412: ARRAY
21413: ADD
21414: PPUSH
21415: CALL_OW 1
21419: ST_TO_ADDR
21420: GO 21372
21422: POP
21423: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
21424: LD_ADDR_EXP 100
21428: PUSH
21429: LD_EXP 100
21433: PPUSH
21434: LD_INT 4
21436: PPUSH
21437: LD_EXP 100
21441: PUSH
21442: LD_INT 4
21444: ARRAY
21445: PUSH
21446: LD_EXP 18
21450: PUSH
21451: LD_INT 1
21453: ARRAY
21454: DIFF
21455: PPUSH
21456: CALL_OW 1
21460: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
21461: LD_VAR 0 5
21465: PUSH
21466: LD_INT 1
21468: ARRAY
21469: PPUSH
21470: CALL_OW 313
21474: IFFALSE 21529
// begin for i in UnitsInside ( arm [ 1 ] ) do
21476: LD_ADDR_VAR 0 1
21480: PUSH
21481: LD_VAR 0 5
21485: PUSH
21486: LD_INT 1
21488: ARRAY
21489: PPUSH
21490: CALL_OW 313
21494: PUSH
21495: FOR_IN
21496: IFFALSE 21527
// begin ComExitBuilding ( i ) ;
21498: LD_VAR 0 1
21502: PPUSH
21503: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
21507: LD_VAR 0 1
21511: PPUSH
21512: LD_VAR 0 6
21516: PUSH
21517: LD_INT 1
21519: ARRAY
21520: PPUSH
21521: CALL_OW 180
// end ;
21525: GO 21495
21527: POP
21528: POP
// end ; wait ( 0 0$3 ) ;
21529: LD_INT 105
21531: PPUSH
21532: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
21536: LD_ADDR_VAR 0 1
21540: PUSH
21541: LD_EXP 18
21545: PUSH
21546: LD_INT 1
21548: ARRAY
21549: PUSH
21550: FOR_IN
21551: IFFALSE 21658
// begin if IsInUnit ( i ) then
21553: LD_VAR 0 1
21557: PPUSH
21558: CALL_OW 310
21562: IFFALSE 21573
// ComExitBuilding ( i ) ;
21564: LD_VAR 0 1
21568: PPUSH
21569: CALL_OW 122
// if GetClass ( i ) <> 1 then
21573: LD_VAR 0 1
21577: PPUSH
21578: CALL_OW 257
21582: PUSH
21583: LD_INT 1
21585: NONEQUAL
21586: IFFALSE 21627
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
21588: LD_VAR 0 1
21592: PPUSH
21593: LD_VAR 0 5
21597: PUSH
21598: LD_INT 1
21600: ARRAY
21601: PPUSH
21602: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
21606: LD_VAR 0 1
21610: PPUSH
21611: LD_INT 1
21613: PPUSH
21614: CALL_OW 183
// AddComExitBuilding ( i ) ;
21618: LD_VAR 0 1
21622: PPUSH
21623: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
21627: LD_VAR 0 1
21631: PPUSH
21632: LD_INT 60
21634: PPUSH
21635: LD_INT 94
21637: PPUSH
21638: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
21642: LD_VAR 0 1
21646: PPUSH
21647: LD_EXP 60
21651: PPUSH
21652: CALL_OW 179
// end ;
21656: GO 21550
21658: POP
21659: POP
// wait ( 0 0$10 ) ;
21660: LD_INT 350
21662: PPUSH
21663: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
21667: LD_EXP 60
21671: PPUSH
21672: LD_STRING D4-Pow-1
21674: PPUSH
21675: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
21679: LD_ADDR_VAR 0 2
21683: PUSH
21684: LD_EXP 18
21688: PUSH
21689: LD_INT 1
21691: ARRAY
21692: PPUSH
21693: LD_INT 26
21695: PUSH
21696: LD_INT 1
21698: PUSH
21699: EMPTY
21700: LIST
21701: LIST
21702: PPUSH
21703: CALL_OW 72
21707: ST_TO_ADDR
// if tmp then
21708: LD_VAR 0 2
21712: IFFALSE 21730
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
21714: LD_VAR 0 2
21718: PUSH
21719: LD_INT 1
21721: ARRAY
21722: PPUSH
21723: LD_STRING D4-Sol1-1
21725: PPUSH
21726: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
21730: LD_EXP 60
21734: PPUSH
21735: LD_STRING D4-Pow-2
21737: PPUSH
21738: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
21742: LD_ADDR_VAR 0 1
21746: PUSH
21747: DOUBLE
21748: LD_INT 1
21750: DEC
21751: ST_TO_ADDR
21752: LD_EXP 18
21756: PUSH
21757: LD_INT 1
21759: ARRAY
21760: PUSH
21761: FOR_TO
21762: IFFALSE 21855
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
21764: LD_EXP 18
21768: PUSH
21769: LD_INT 1
21771: ARRAY
21772: PUSH
21773: LD_VAR 0 1
21777: ARRAY
21778: PPUSH
21779: LD_EXP 119
21783: PUSH
21784: LD_INT 4
21786: ARRAY
21787: PUSH
21788: LD_INT 1
21790: ARRAY
21791: PPUSH
21792: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
21796: LD_ADDR_EXP 119
21800: PUSH
21801: LD_EXP 119
21805: PPUSH
21806: LD_INT 4
21808: PPUSH
21809: LD_EXP 119
21813: PUSH
21814: LD_INT 4
21816: ARRAY
21817: PPUSH
21818: LD_INT 1
21820: PPUSH
21821: CALL_OW 3
21825: PPUSH
21826: CALL_OW 1
21830: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
21831: LD_INT 8
21833: PPUSH
21834: LD_EXP 18
21838: PUSH
21839: LD_INT 1
21841: ARRAY
21842: PUSH
21843: LD_VAR 0 1
21847: ARRAY
21848: PPUSH
21849: CALL_OW 471
// end ;
21853: GO 21761
21855: POP
21856: POP
// repeat wait ( 0 0$1 ) ;
21857: LD_INT 35
21859: PPUSH
21860: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
21864: LD_EXP 18
21868: PUSH
21869: LD_INT 1
21871: ARRAY
21872: PPUSH
21873: LD_INT 55
21875: PUSH
21876: EMPTY
21877: LIST
21878: PPUSH
21879: CALL_OW 72
21883: PUSH
21884: LD_INT 4
21886: GREATEREQUAL
21887: IFFALSE 21857
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
21889: LD_EXP 18
21893: PUSH
21894: LD_INT 1
21896: ARRAY
21897: PPUSH
21898: LD_INT 69
21900: PPUSH
21901: LD_INT 94
21903: PPUSH
21904: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
21908: LD_EXP 18
21912: PUSH
21913: LD_INT 1
21915: ARRAY
21916: PPUSH
21917: LD_INT 82
21919: PPUSH
21920: LD_INT 83
21922: PPUSH
21923: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
21927: LD_EXP 18
21931: PUSH
21932: LD_INT 1
21934: ARRAY
21935: PPUSH
21936: LD_INT 77
21938: PPUSH
21939: LD_INT 69
21941: PPUSH
21942: CALL_OW 174
// repeat wait ( 3 ) ;
21946: LD_INT 3
21948: PPUSH
21949: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
21953: LD_ADDR_VAR 0 1
21957: PUSH
21958: LD_EXP 18
21962: PUSH
21963: LD_INT 1
21965: ARRAY
21966: PUSH
21967: FOR_IN
21968: IFFALSE 22104
// begin if GetLives ( i ) < 990 then
21970: LD_VAR 0 1
21974: PPUSH
21975: CALL_OW 256
21979: PUSH
21980: LD_INT 990
21982: LESS
21983: IFFALSE 21997
// SetLives ( i , 1000 ) ;
21985: LD_VAR 0 1
21989: PPUSH
21990: LD_INT 1000
21992: PPUSH
21993: CALL_OW 234
// if not IsInUnit ( i ) then
21997: LD_VAR 0 1
22001: PPUSH
22002: CALL_OW 310
22006: NOT
22007: IFFALSE 22102
// begin if not HasTask ( i ) then
22009: LD_VAR 0 1
22013: PPUSH
22014: CALL_OW 314
22018: NOT
22019: IFFALSE 22036
// ComMoveXY ( i , 64 , 93 ) ;
22021: LD_VAR 0 1
22025: PPUSH
22026: LD_INT 64
22028: PPUSH
22029: LD_INT 93
22031: PPUSH
22032: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
22036: LD_VAR 0 4
22040: NOT
22041: PUSH
22042: LD_VAR 0 1
22046: PPUSH
22047: CALL_OW 258
22051: PUSH
22052: LD_INT 1
22054: EQUAL
22055: AND
22056: IFFALSE 22102
// begin retreat := true ;
22058: LD_ADDR_VAR 0 4
22062: PUSH
22063: LD_INT 1
22065: ST_TO_ADDR
// SetTag ( i , 2 ) ;
22066: LD_VAR 0 1
22070: PPUSH
22071: LD_INT 2
22073: PPUSH
22074: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
22078: LD_VAR 0 1
22082: PPUSH
22083: LD_STRING D4a-Sol1-1
22085: PPUSH
22086: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
22090: LD_EXP 60
22094: PPUSH
22095: LD_STRING D4a-Pow-1
22097: PPUSH
22098: CALL_OW 88
// end ; end ; end ;
22102: GO 21967
22104: POP
22105: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
22106: LD_EXP 18
22110: PUSH
22111: LD_INT 1
22113: ARRAY
22114: PPUSH
22115: LD_INT 95
22117: PUSH
22118: LD_INT 9
22120: PUSH
22121: EMPTY
22122: LIST
22123: LIST
22124: PUSH
22125: LD_INT 3
22127: PUSH
22128: LD_INT 55
22130: PUSH
22131: EMPTY
22132: LIST
22133: PUSH
22134: EMPTY
22135: LIST
22136: LIST
22137: PUSH
22138: EMPTY
22139: LIST
22140: LIST
22141: PPUSH
22142: CALL_OW 72
22146: PUSH
22147: LD_INT 4
22149: GREATEREQUAL
22150: IFFALSE 21946
// for i in powellSquadAttack [ 1 ] do
22152: LD_ADDR_VAR 0 1
22156: PUSH
22157: LD_EXP 18
22161: PUSH
22162: LD_INT 1
22164: ARRAY
22165: PUSH
22166: FOR_IN
22167: IFFALSE 22303
// begin if GetTag ( i ) = 2 then
22169: LD_VAR 0 1
22173: PPUSH
22174: CALL_OW 110
22178: PUSH
22179: LD_INT 2
22181: EQUAL
22182: IFFALSE 22244
// begin ComMoveXY ( i , 60 , 94 ) ;
22184: LD_VAR 0 1
22188: PPUSH
22189: LD_INT 60
22191: PPUSH
22192: LD_INT 94
22194: PPUSH
22195: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
22199: LD_VAR 0 1
22203: PPUSH
22204: LD_EXP 60
22208: PPUSH
22209: CALL_OW 179
// wait ( 0 0$3 ) ;
22213: LD_INT 105
22215: PPUSH
22216: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
22220: LD_VAR 0 1
22224: PPUSH
22225: LD_STRING D4a-Sol1-2
22227: PPUSH
22228: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
22232: LD_EXP 60
22236: PPUSH
22237: LD_STRING D4a-Pow-2
22239: PPUSH
22240: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
22244: LD_VAR 0 1
22248: PPUSH
22249: LD_INT 0
22251: PPUSH
22252: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
22256: LD_ADDR_EXP 100
22260: PUSH
22261: LD_EXP 100
22265: PPUSH
22266: LD_INT 4
22268: PPUSH
22269: LD_EXP 100
22273: PUSH
22274: LD_INT 4
22276: ARRAY
22277: PUSH
22278: LD_VAR 0 1
22282: UNION
22283: PPUSH
22284: CALL_OW 1
22288: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
22289: LD_INT 8
22291: PPUSH
22292: LD_VAR 0 1
22296: PPUSH
22297: CALL_OW 472
// end ;
22301: GO 22166
22303: POP
22304: POP
// wait ( 2 2$00 ) ;
22305: LD_INT 4200
22307: PPUSH
22308: CALL_OW 67
// emptyTowers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
22312: LD_ADDR_VAR 0 9
22316: PUSH
22317: LD_INT 22
22319: PUSH
22320: LD_INT 4
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PUSH
22327: LD_INT 30
22329: PUSH
22330: LD_INT 32
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: PUSH
22337: LD_INT 58
22339: PUSH
22340: EMPTY
22341: LIST
22342: PUSH
22343: EMPTY
22344: LIST
22345: LIST
22346: LIST
22347: PPUSH
22348: CALL_OW 69
22352: ST_TO_ADDR
// if tmp then
22353: LD_VAR 0 2
22357: IFFALSE 22597
// begin for i := 1 to tmp do
22359: LD_ADDR_VAR 0 1
22363: PUSH
22364: DOUBLE
22365: LD_INT 1
22367: DEC
22368: ST_TO_ADDR
22369: LD_VAR 0 2
22373: PUSH
22374: FOR_TO
22375: IFFALSE 22588
// begin mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff tmp [ i ] ) ;
22377: LD_ADDR_EXP 100
22381: PUSH
22382: LD_EXP 100
22386: PPUSH
22387: LD_INT 4
22389: PPUSH
22390: LD_EXP 100
22394: PUSH
22395: LD_INT 4
22397: ARRAY
22398: PUSH
22399: LD_VAR 0 2
22403: PUSH
22404: LD_VAR 0 1
22408: ARRAY
22409: DIFF
22410: PPUSH
22411: CALL_OW 1
22415: ST_TO_ADDR
// t := IsInUnit ( tmp [ i ] ) ;
22416: LD_ADDR_VAR 0 10
22420: PUSH
22421: LD_VAR 0 2
22425: PUSH
22426: LD_VAR 0 1
22430: ARRAY
22431: PPUSH
22432: CALL_OW 310
22436: ST_TO_ADDR
// if t and GetBType ( t ) = b_bunker then
22437: LD_VAR 0 10
22441: PUSH
22442: LD_VAR 0 10
22446: PPUSH
22447: CALL_OW 266
22451: PUSH
22452: LD_INT 32
22454: EQUAL
22455: AND
22456: IFFALSE 22460
// continue ;
22458: GO 22374
// if t then
22460: LD_VAR 0 10
22464: IFFALSE 22481
// ComExitBuilding ( tmp [ i ] ) ;
22466: LD_VAR 0 2
22470: PUSH
22471: LD_VAR 0 1
22475: ARRAY
22476: PPUSH
22477: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
22481: LD_VAR 0 2
22485: PUSH
22486: LD_VAR 0 1
22490: ARRAY
22491: PPUSH
22492: LD_VAR 0 5
22496: PUSH
22497: LD_INT 1
22499: ARRAY
22500: PPUSH
22501: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
22505: LD_VAR 0 2
22509: PUSH
22510: LD_VAR 0 1
22514: ARRAY
22515: PPUSH
22516: LD_INT 1
22518: PPUSH
22519: CALL_OW 183
// if emptyTowers then
22523: LD_VAR 0 9
22527: IFFALSE 22586
// begin AddComExitBuilding ( tmp [ i ] ) ;
22529: LD_VAR 0 2
22533: PUSH
22534: LD_VAR 0 1
22538: ARRAY
22539: PPUSH
22540: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emptyTowers [ 1 ] ) ;
22544: LD_VAR 0 2
22548: PUSH
22549: LD_VAR 0 1
22553: ARRAY
22554: PPUSH
22555: LD_VAR 0 9
22559: PUSH
22560: LD_INT 1
22562: ARRAY
22563: PPUSH
22564: CALL_OW 180
// emptyTowers := Delete ( emptyTowers , 1 ) ;
22568: LD_ADDR_VAR 0 9
22572: PUSH
22573: LD_VAR 0 9
22577: PPUSH
22578: LD_INT 1
22580: PPUSH
22581: CALL_OW 3
22585: ST_TO_ADDR
// end ; end ;
22586: GO 22374
22588: POP
22589: POP
// wait ( 0 0$30 ) ;
22590: LD_INT 1050
22592: PPUSH
22593: CALL_OW 67
// end ; uc_side := 6 ;
22597: LD_ADDR_OWVAR 20
22601: PUSH
22602: LD_INT 6
22604: ST_TO_ADDR
// uc_nation := 3 ;
22605: LD_ADDR_OWVAR 21
22609: PUSH
22610: LD_INT 3
22612: ST_TO_ADDR
// ru := [ ] ;
22613: LD_ADDR_VAR 0 7
22617: PUSH
22618: EMPTY
22619: ST_TO_ADDR
// for i = 1 to 5 do
22620: LD_ADDR_VAR 0 1
22624: PUSH
22625: DOUBLE
22626: LD_INT 1
22628: DEC
22629: ST_TO_ADDR
22630: LD_INT 5
22632: PUSH
22633: FOR_TO
22634: IFFALSE 22754
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_wheeled ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
22636: LD_INT 22
22638: PUSH
22639: LD_INT 23
22641: PUSH
22642: EMPTY
22643: LIST
22644: LIST
22645: PUSH
22646: LD_INT 1
22648: PPUSH
22649: LD_INT 2
22651: PPUSH
22652: CALL_OW 12
22656: ARRAY
22657: PPUSH
22658: LD_INT 1
22660: PPUSH
22661: LD_INT 3
22663: PPUSH
22664: LD_INT 43
22666: PUSH
22667: LD_INT 44
22669: PUSH
22670: EMPTY
22671: LIST
22672: LIST
22673: PUSH
22674: LD_INT 1
22676: PPUSH
22677: LD_INT 2
22679: PPUSH
22680: CALL_OW 12
22684: ARRAY
22685: PPUSH
22686: LD_INT 89
22688: PPUSH
22689: CALL 73738 0 5
// un := CreateVehicle ;
22693: LD_ADDR_VAR 0 8
22697: PUSH
22698: CALL_OW 45
22702: ST_TO_ADDR
// SetDir ( un , 4 ) ;
22703: LD_VAR 0 8
22707: PPUSH
22708: LD_INT 4
22710: PPUSH
22711: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
22715: LD_VAR 0 8
22719: PPUSH
22720: LD_INT 136
22722: PPUSH
22723: LD_INT 90
22725: PPUSH
22726: LD_INT 8
22728: PPUSH
22729: LD_INT 0
22731: PPUSH
22732: CALL_OW 50
// ru := ru ^ un ;
22736: LD_ADDR_VAR 0 7
22740: PUSH
22741: LD_VAR 0 7
22745: PUSH
22746: LD_VAR 0 8
22750: ADD
22751: ST_TO_ADDR
// end ;
22752: GO 22633
22754: POP
22755: POP
// if ru then
22756: LD_VAR 0 7
22760: IFFALSE 22777
// ComAgressiveMove ( ru , 57 , 94 ) ;
22762: LD_VAR 0 7
22766: PPUSH
22767: LD_INT 57
22769: PPUSH
22770: LD_INT 94
22772: PPUSH
22773: CALL_OW 114
// wait ( 3 3$00 ) ;
22777: LD_INT 6300
22779: PPUSH
22780: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
22784: LD_INT 4
22786: PPUSH
22787: LD_INT 3
22789: PUSH
22790: LD_INT 1
22792: PUSH
22793: LD_INT 1
22795: PUSH
22796: LD_INT 5
22798: PUSH
22799: EMPTY
22800: LIST
22801: LIST
22802: LIST
22803: LIST
22804: PUSH
22805: LD_INT 4
22807: PUSH
22808: LD_INT 1
22810: PUSH
22811: LD_INT 1
22813: PUSH
22814: LD_INT 6
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: LIST
22821: LIST
22822: PUSH
22823: LD_INT 4
22825: PUSH
22826: LD_INT 1
22828: PUSH
22829: LD_INT 1
22831: PUSH
22832: LD_INT 7
22834: PUSH
22835: EMPTY
22836: LIST
22837: LIST
22838: LIST
22839: LIST
22840: PUSH
22841: LD_INT 3
22843: PUSH
22844: LD_INT 1
22846: PUSH
22847: LD_INT 1
22849: PUSH
22850: LD_INT 7
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: LIST
22857: LIST
22858: PUSH
22859: LD_INT 3
22861: PUSH
22862: LD_INT 1
22864: PUSH
22865: LD_INT 1
22867: PUSH
22868: LD_INT 5
22870: PUSH
22871: EMPTY
22872: LIST
22873: LIST
22874: LIST
22875: LIST
22876: PUSH
22877: EMPTY
22878: LIST
22879: LIST
22880: LIST
22881: LIST
22882: LIST
22883: PPUSH
22884: CALL 62424 0 2
// missionStage := 4 ;
22888: LD_ADDR_EXP 15
22892: PUSH
22893: LD_INT 4
22895: ST_TO_ADDR
// end ;
22896: PPOPN 10
22898: END
// every 0 0$02 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
22899: LD_EXP 15
22903: PUSH
22904: LD_INT 4
22906: EQUAL
22907: PUSH
22908: LD_INT 22
22910: PUSH
22911: LD_INT 4
22913: PUSH
22914: EMPTY
22915: LIST
22916: LIST
22917: PUSH
22918: LD_INT 21
22920: PUSH
22921: LD_INT 2
22923: PUSH
22924: EMPTY
22925: LIST
22926: LIST
22927: PUSH
22928: EMPTY
22929: LIST
22930: LIST
22931: PPUSH
22932: CALL_OW 69
22936: PUSH
22937: LD_INT 5
22939: GREATEREQUAL
22940: AND
22941: IFFALSE 27208
22943: GO 22945
22945: DISABLE
22946: LD_INT 0
22948: PPUSH
22949: PPUSH
22950: PPUSH
22951: PPUSH
22952: PPUSH
22953: PPUSH
22954: PPUSH
22955: PPUSH
22956: PPUSH
22957: PPUSH
22958: PPUSH
22959: PPUSH
22960: PPUSH
// begin wait ( 0 0$10 ) ;
22961: LD_INT 350
22963: PPUSH
22964: CALL_OW 67
// missionStage := 5 ;
22968: LD_ADDR_EXP 15
22972: PUSH
22973: LD_INT 5
22975: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
22976: LD_ADDR_VAR 0 10
22980: PUSH
22981: LD_INT 22
22983: PUSH
22984: LD_INT 4
22986: PUSH
22987: EMPTY
22988: LIST
22989: LIST
22990: PUSH
22991: LD_INT 2
22993: PUSH
22994: LD_INT 30
22996: PUSH
22997: LD_INT 4
22999: PUSH
23000: EMPTY
23001: LIST
23002: LIST
23003: PUSH
23004: LD_INT 30
23006: PUSH
23007: LD_INT 5
23009: PUSH
23010: EMPTY
23011: LIST
23012: LIST
23013: PUSH
23014: EMPTY
23015: LIST
23016: LIST
23017: LIST
23018: PUSH
23019: EMPTY
23020: LIST
23021: LIST
23022: PPUSH
23023: CALL_OW 69
23027: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
23028: LD_ADDR_VAR 0 6
23032: PUSH
23033: LD_INT 22
23035: PUSH
23036: LD_INT 4
23038: PUSH
23039: EMPTY
23040: LIST
23041: LIST
23042: PUSH
23043: LD_INT 21
23045: PUSH
23046: LD_INT 1
23048: PUSH
23049: EMPTY
23050: LIST
23051: LIST
23052: PUSH
23053: LD_INT 3
23055: PUSH
23056: LD_INT 25
23058: PUSH
23059: LD_INT 16
23061: PUSH
23062: EMPTY
23063: LIST
23064: LIST
23065: PUSH
23066: EMPTY
23067: LIST
23068: LIST
23069: PUSH
23070: LD_INT 3
23072: PUSH
23073: LD_INT 25
23075: PUSH
23076: LD_INT 12
23078: PUSH
23079: EMPTY
23080: LIST
23081: LIST
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: LIST
23091: LIST
23092: PPUSH
23093: CALL_OW 69
23097: PUSH
23098: LD_EXP 60
23102: DIFF
23103: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
23104: LD_ADDR_VAR 0 9
23108: PUSH
23109: LD_INT 22
23111: PUSH
23112: LD_INT 4
23114: PUSH
23115: EMPTY
23116: LIST
23117: LIST
23118: PUSH
23119: LD_INT 30
23121: PUSH
23122: LD_INT 3
23124: PUSH
23125: EMPTY
23126: LIST
23127: LIST
23128: PUSH
23129: EMPTY
23130: LIST
23131: LIST
23132: PPUSH
23133: CALL_OW 69
23137: PUSH
23138: LD_INT 1
23140: ARRAY
23141: ST_TO_ADDR
// repeat wait ( 0 0$10 ) ;
23142: LD_INT 350
23144: PPUSH
23145: CALL_OW 67
// if mc_vehicles [ 4 ] < 5 and BuildingStatus ( fac ) = bs_idle then
23149: LD_EXP 119
23153: PUSH
23154: LD_INT 4
23156: ARRAY
23157: PUSH
23158: LD_INT 5
23160: LESS
23161: PUSH
23162: LD_VAR 0 9
23166: PPUSH
23167: CALL_OW 461
23171: PUSH
23172: LD_INT 2
23174: EQUAL
23175: AND
23176: IFFALSE 23206
// MC_InsertProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
23178: LD_INT 4
23180: PPUSH
23181: LD_INT 3
23183: PUSH
23184: LD_INT 1
23186: PUSH
23187: LD_INT 1
23189: PUSH
23190: LD_INT 5
23192: PUSH
23193: EMPTY
23194: LIST
23195: LIST
23196: LIST
23197: LIST
23198: PUSH
23199: EMPTY
23200: LIST
23201: PPUSH
23202: CALL 62472 0 2
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
23206: LD_EXP 119
23210: PUSH
23211: LD_INT 4
23213: ARRAY
23214: PUSH
23215: LD_INT 5
23217: GREATEREQUAL
23218: PUSH
23219: LD_EXP 119
23223: PUSH
23224: LD_INT 4
23226: ARRAY
23227: PPUSH
23228: LD_INT 58
23230: PUSH
23231: EMPTY
23232: LIST
23233: PPUSH
23234: CALL_OW 72
23238: PUSH
23239: LD_INT 5
23241: GREATEREQUAL
23242: AND
23243: IFFALSE 23142
// powellAllowRetreat := false ;
23245: LD_ADDR_EXP 19
23249: PUSH
23250: LD_INT 0
23252: ST_TO_ADDR
// activeAttacks := false ;
23253: LD_ADDR_EXP 16
23257: PUSH
23258: LD_INT 0
23260: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
23261: LD_INT 35
23263: PPUSH
23264: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
23268: LD_INT 22
23270: PUSH
23271: LD_INT 6
23273: PUSH
23274: EMPTY
23275: LIST
23276: LIST
23277: PPUSH
23278: CALL_OW 69
23282: PUSH
23283: LD_INT 0
23285: EQUAL
23286: IFFALSE 23261
// tmp := mc_vehicles [ 4 ] ;
23288: LD_ADDR_VAR 0 3
23292: PUSH
23293: LD_EXP 119
23297: PUSH
23298: LD_INT 4
23300: ARRAY
23301: ST_TO_ADDR
// for i := 1 to powellSquadAttack do
23302: LD_ADDR_VAR 0 1
23306: PUSH
23307: DOUBLE
23308: LD_INT 1
23310: DEC
23311: ST_TO_ADDR
23312: LD_EXP 18
23316: PUSH
23317: FOR_TO
23318: IFFALSE 23579
// begin for j in powellSquadAttack [ i ] do
23320: LD_ADDR_VAR 0 2
23324: PUSH
23325: LD_EXP 18
23329: PUSH
23330: LD_VAR 0 1
23334: ARRAY
23335: PUSH
23336: FOR_IN
23337: IFFALSE 23575
// begin forces := forces diff j ;
23339: LD_ADDR_VAR 0 6
23343: PUSH
23344: LD_VAR 0 6
23348: PUSH
23349: LD_VAR 0 2
23353: DIFF
23354: ST_TO_ADDR
// SetTag ( j , 1 ) ;
23355: LD_VAR 0 2
23359: PPUSH
23360: LD_INT 1
23362: PPUSH
23363: CALL_OW 109
// wait ( 0 0$2 ) ;
23367: LD_INT 70
23369: PPUSH
23370: CALL_OW 67
// if IsInUnit ( j ) then
23374: LD_VAR 0 2
23378: PPUSH
23379: CALL_OW 310
23383: IFFALSE 23394
// ComExitBuilding ( j ) ;
23385: LD_VAR 0 2
23389: PPUSH
23390: CALL_OW 122
// if GetClass ( j ) <> 1 then
23394: LD_VAR 0 2
23398: PPUSH
23399: CALL_OW 257
23403: PUSH
23404: LD_INT 1
23406: NONEQUAL
23407: IFFALSE 23487
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
23409: LD_VAR 0 10
23413: PUSH
23414: LD_INT 1
23416: ARRAY
23417: PPUSH
23418: CALL_OW 313
23422: PUSH
23423: LD_INT 5
23425: GREATEREQUAL
23426: IFFALSE 23448
// AddComEnterUnit ( j , arm [ 2 ] ) else
23428: LD_VAR 0 2
23432: PPUSH
23433: LD_VAR 0 10
23437: PUSH
23438: LD_INT 2
23440: ARRAY
23441: PPUSH
23442: CALL_OW 180
23446: GO 23466
// AddComEnterUnit ( j , arm [ 1 ] ) ;
23448: LD_VAR 0 2
23452: PPUSH
23453: LD_VAR 0 10
23457: PUSH
23458: LD_INT 1
23460: ARRAY
23461: PPUSH
23462: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
23466: LD_VAR 0 2
23470: PPUSH
23471: LD_INT 1
23473: PPUSH
23474: CALL_OW 183
// AddComExitBuilding ( j ) ;
23478: LD_VAR 0 2
23482: PPUSH
23483: CALL_OW 182
// end ; if i = 2 then
23487: LD_VAR 0 1
23491: PUSH
23492: LD_INT 2
23494: EQUAL
23495: IFFALSE 23512
// AddComMoveXY ( j , 61 , 93 ) ;
23497: LD_VAR 0 2
23501: PPUSH
23502: LD_INT 61
23504: PPUSH
23505: LD_INT 93
23507: PPUSH
23508: CALL_OW 171
// if i = 1 then
23512: LD_VAR 0 1
23516: PUSH
23517: LD_INT 1
23519: EQUAL
23520: IFFALSE 23573
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
23522: LD_VAR 0 2
23526: PPUSH
23527: LD_VAR 0 3
23531: PUSH
23532: LD_INT 1
23534: ARRAY
23535: PPUSH
23536: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
23540: LD_ADDR_VAR 0 3
23544: PUSH
23545: LD_VAR 0 3
23549: PPUSH
23550: LD_INT 1
23552: PPUSH
23553: CALL_OW 3
23557: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
23558: LD_VAR 0 2
23562: PPUSH
23563: LD_INT 69
23565: PPUSH
23566: LD_INT 94
23568: PPUSH
23569: CALL_OW 171
// end ; end ;
23573: GO 23336
23575: POP
23576: POP
// end ;
23577: GO 23317
23579: POP
23580: POP
// wait ( 0 0$30 ) ;
23581: LD_INT 1050
23583: PPUSH
23584: CALL_OW 67
// MC_Kill ( 4 ) ;
23588: LD_INT 4
23590: PPUSH
23591: CALL 38461 0 1
// tmp := UnitsInside ( fac ) ;
23595: LD_ADDR_VAR 0 3
23599: PUSH
23600: LD_VAR 0 9
23604: PPUSH
23605: CALL_OW 313
23609: ST_TO_ADDR
// if tmp then
23610: LD_VAR 0 3
23614: IFFALSE 23735
// for i in tmp do
23616: LD_ADDR_VAR 0 1
23620: PUSH
23621: LD_VAR 0 3
23625: PUSH
23626: FOR_IN
23627: IFFALSE 23733
// begin ComExitBuilding ( i ) ;
23629: LD_VAR 0 1
23633: PPUSH
23634: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
23638: LD_VAR 0 10
23642: PUSH
23643: LD_INT 2
23645: ARRAY
23646: PPUSH
23647: CALL_OW 313
23651: PUSH
23652: LD_INT 6
23654: LESS
23655: IFFALSE 23677
// AddComEnterUnit ( i , arm [ 2 ] ) else
23657: LD_VAR 0 1
23661: PPUSH
23662: LD_VAR 0 10
23666: PUSH
23667: LD_INT 2
23669: ARRAY
23670: PPUSH
23671: CALL_OW 180
23675: GO 23731
// if UnitsInside ( arm [ 1 ] ) < 6 then
23677: LD_VAR 0 10
23681: PUSH
23682: LD_INT 1
23684: ARRAY
23685: PPUSH
23686: CALL_OW 313
23690: PUSH
23691: LD_INT 6
23693: LESS
23694: IFFALSE 23716
// AddComEnterUnit ( i , arm [ 1 ] ) else
23696: LD_VAR 0 1
23700: PPUSH
23701: LD_VAR 0 10
23705: PUSH
23706: LD_INT 1
23708: ARRAY
23709: PPUSH
23710: CALL_OW 180
23714: GO 23731
// AddComMoveXY ( i , 37 , 68 ) ;
23716: LD_VAR 0 1
23720: PPUSH
23721: LD_INT 37
23723: PPUSH
23724: LD_INT 68
23726: PPUSH
23727: CALL_OW 171
// end ;
23731: GO 23626
23733: POP
23734: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
23735: LD_ADDR_VAR 0 11
23739: PUSH
23740: LD_VAR 0 6
23744: PPUSH
23745: LD_INT 26
23747: PUSH
23748: LD_INT 1
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: PPUSH
23755: CALL_OW 72
23759: PUSH
23760: LD_EXP 61
23764: DIFF
23765: ST_TO_ADDR
// if not speaker then
23766: LD_VAR 0 11
23770: NOT
23771: IFFALSE 23798
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
23773: LD_ADDR_VAR 0 11
23777: PUSH
23778: LD_VAR 0 6
23782: PPUSH
23783: LD_INT 26
23785: PUSH
23786: LD_INT 1
23788: PUSH
23789: EMPTY
23790: LIST
23791: LIST
23792: PPUSH
23793: CALL_OW 72
23797: ST_TO_ADDR
// if speaker then
23798: LD_VAR 0 11
23802: IFFALSE 23818
// speaker := speaker [ 1 ] ;
23804: LD_ADDR_VAR 0 11
23808: PUSH
23809: LD_VAR 0 11
23813: PUSH
23814: LD_INT 1
23816: ARRAY
23817: ST_TO_ADDR
// Video ( true ) ;
23818: LD_INT 1
23820: PPUSH
23821: CALL 106162 0 1
// CenterNowOnUnits ( Powell ) ;
23825: LD_EXP 60
23829: PPUSH
23830: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
23834: LD_ADDR_VAR 0 3
23838: PUSH
23839: LD_VAR 0 6
23843: PPUSH
23844: LD_INT 3
23846: PUSH
23847: LD_INT 25
23849: PUSH
23850: LD_INT 1
23852: PUSH
23853: EMPTY
23854: LIST
23855: LIST
23856: PUSH
23857: EMPTY
23858: LIST
23859: LIST
23860: PPUSH
23861: CALL_OW 72
23865: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
23866: LD_ADDR_VAR 0 12
23870: PUSH
23871: LD_INT 22
23873: PUSH
23874: LD_INT 4
23876: PUSH
23877: EMPTY
23878: LIST
23879: LIST
23880: PUSH
23881: LD_INT 30
23883: PUSH
23884: LD_INT 32
23886: PUSH
23887: EMPTY
23888: LIST
23889: LIST
23890: PUSH
23891: LD_INT 58
23893: PUSH
23894: EMPTY
23895: LIST
23896: PUSH
23897: EMPTY
23898: LIST
23899: LIST
23900: LIST
23901: PPUSH
23902: CALL_OW 69
23906: ST_TO_ADDR
// for i := 1 to 4 do
23907: LD_ADDR_VAR 0 1
23911: PUSH
23912: DOUBLE
23913: LD_INT 1
23915: DEC
23916: ST_TO_ADDR
23917: LD_INT 4
23919: PUSH
23920: FOR_TO
23921: IFFALSE 24067
// begin if IsInUnit ( tmp [ i ] ) then
23923: LD_VAR 0 3
23927: PUSH
23928: LD_VAR 0 1
23932: ARRAY
23933: PPUSH
23934: CALL_OW 310
23938: IFFALSE 23955
// ComExitBuilding ( tmp [ i ] ) ;
23940: LD_VAR 0 3
23944: PUSH
23945: LD_VAR 0 1
23949: ARRAY
23950: PPUSH
23951: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
23955: LD_VAR 0 3
23959: PUSH
23960: LD_VAR 0 1
23964: ARRAY
23965: PPUSH
23966: LD_VAR 0 10
23970: PUSH
23971: LD_INT 1
23973: ARRAY
23974: PPUSH
23975: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
23979: LD_VAR 0 3
23983: PUSH
23984: LD_VAR 0 1
23988: ARRAY
23989: PPUSH
23990: LD_INT 1
23992: PPUSH
23993: CALL_OW 183
// if Count ( emp_towers ) then
23997: LD_VAR 0 12
24001: PPUSH
24002: CALL 71000 0 1
24006: IFFALSE 24065
// begin AddComExitBuilding ( tmp [ i ] ) ;
24008: LD_VAR 0 3
24012: PUSH
24013: LD_VAR 0 1
24017: ARRAY
24018: PPUSH
24019: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
24023: LD_VAR 0 3
24027: PUSH
24028: LD_VAR 0 1
24032: ARRAY
24033: PPUSH
24034: LD_VAR 0 12
24038: PUSH
24039: LD_INT 1
24041: ARRAY
24042: PPUSH
24043: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
24047: LD_ADDR_VAR 0 12
24051: PUSH
24052: LD_VAR 0 12
24056: PPUSH
24057: LD_INT 1
24059: PPUSH
24060: CALL_OW 3
24064: ST_TO_ADDR
// end ; end ;
24065: GO 23920
24067: POP
24068: POP
// wait ( 0 0$5 ) ;
24069: LD_INT 175
24071: PPUSH
24072: CALL_OW 67
// if UnitFilter ( tmp , [ f_not , [ f_inside ] ] ) then
24076: LD_VAR 0 3
24080: PPUSH
24081: LD_INT 3
24083: PUSH
24084: LD_INT 54
24086: PUSH
24087: EMPTY
24088: LIST
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: PPUSH
24094: CALL_OW 72
24098: IFFALSE 24118
// ComEnterUnit ( tmp , arm [ 1 ] ) ;
24100: LD_VAR 0 3
24104: PPUSH
24105: LD_VAR 0 10
24109: PUSH
24110: LD_INT 1
24112: ARRAY
24113: PPUSH
24114: CALL_OW 120
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
24118: LD_ADDR_VAR 0 3
24122: PUSH
24123: LD_EXP 18
24127: PUSH
24128: LD_INT 1
24130: ARRAY
24131: PUSH
24132: LD_EXP 18
24136: PUSH
24137: LD_INT 2
24139: ARRAY
24140: ADD
24141: PPUSH
24142: LD_INT 26
24144: PUSH
24145: LD_INT 1
24147: PUSH
24148: EMPTY
24149: LIST
24150: LIST
24151: PPUSH
24152: CALL_OW 72
24156: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
24157: LD_ADDR_VAR 0 1
24161: PUSH
24162: LD_EXP 18
24166: PUSH
24167: LD_INT 2
24169: ARRAY
24170: PUSH
24171: FOR_IN
24172: IFFALSE 24190
// ComTurnUnit ( i , Powell ) ;
24174: LD_VAR 0 1
24178: PPUSH
24179: LD_EXP 60
24183: PPUSH
24184: CALL_OW 119
24188: GO 24171
24190: POP
24191: POP
// Say ( Powell , D5-Pow-1 ) ;
24192: LD_EXP 60
24196: PPUSH
24197: LD_STRING D5-Pow-1
24199: PPUSH
24200: CALL_OW 88
// if tmp then
24204: LD_VAR 0 3
24208: IFFALSE 24226
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
24210: LD_VAR 0 3
24214: PUSH
24215: LD_INT 1
24217: ARRAY
24218: PPUSH
24219: LD_STRING D5-Sol2-1
24221: PPUSH
24222: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
24226: LD_EXP 60
24230: PPUSH
24231: LD_STRING D5-Pow-2
24233: PPUSH
24234: CALL_OW 88
// if tmp > 1 then
24238: LD_VAR 0 3
24242: PUSH
24243: LD_INT 1
24245: GREATER
24246: IFFALSE 24264
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
24248: LD_VAR 0 3
24252: PUSH
24253: LD_INT 2
24255: ARRAY
24256: PPUSH
24257: LD_STRING D5-Sol2-2
24259: PPUSH
24260: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
24264: LD_EXP 60
24268: PPUSH
24269: LD_STRING D5-Pow-3
24271: PPUSH
24272: CALL_OW 88
// wait ( 0 0$1 ) ;
24276: LD_INT 35
24278: PPUSH
24279: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
24283: LD_ADDR_VAR 0 3
24287: PUSH
24288: LD_EXP 18
24292: PUSH
24293: LD_INT 1
24295: ARRAY
24296: PUSH
24297: LD_EXP 18
24301: PUSH
24302: LD_INT 2
24304: ARRAY
24305: UNION
24306: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
24307: LD_VAR 0 3
24311: PPUSH
24312: LD_INT 80
24314: PPUSH
24315: LD_INT 67
24317: PPUSH
24318: CALL_OW 114
// wait ( 0 0$2 ) ;
24322: LD_INT 70
24324: PPUSH
24325: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
24329: LD_INT 79
24331: PPUSH
24332: LD_INT 72
24334: PPUSH
24335: CALL_OW 84
// repeat wait ( 0 0$2 ) ;
24339: LD_INT 70
24341: PPUSH
24342: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
24346: LD_VAR 0 3
24350: PPUSH
24351: LD_INT 3
24353: PUSH
24354: LD_INT 24
24356: PUSH
24357: LD_INT 1000
24359: PUSH
24360: EMPTY
24361: LIST
24362: LIST
24363: PUSH
24364: EMPTY
24365: LIST
24366: LIST
24367: PPUSH
24368: CALL_OW 72
24372: IFFALSE 24339
// Say ( Powell , D5a-Pow-1 ) ;
24374: LD_EXP 60
24378: PPUSH
24379: LD_STRING D5a-Pow-1
24381: PPUSH
24382: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
24386: LD_EXP 60
24390: PPUSH
24391: LD_STRING D5a-Pow-1a
24393: PPUSH
24394: CALL_OW 88
// wait ( 0 0$0.7 ) ;
24398: LD_INT 24
24400: PPUSH
24401: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
24405: LD_EXP 60
24409: PPUSH
24410: LD_STRING D5a-Pow-1b
24412: PPUSH
24413: CALL_OW 88
// wait ( 0 0$0.3 ) ;
24417: LD_INT 10
24419: PPUSH
24420: CALL_OW 67
// Say ( Powell , D5a-Pow-1c ) ;
24424: LD_EXP 60
24428: PPUSH
24429: LD_STRING D5a-Pow-1c
24431: PPUSH
24432: CALL_OW 88
// ComMoveXY ( tmp , 68 , 63 ) ;
24436: LD_VAR 0 3
24440: PPUSH
24441: LD_INT 68
24443: PPUSH
24444: LD_INT 63
24446: PPUSH
24447: CALL_OW 111
// wait ( 0 0$0.5 ) ;
24451: LD_INT 18
24453: PPUSH
24454: CALL_OW 67
// Say ( Powell , D5a-Pow-1d ) ;
24458: LD_EXP 60
24462: PPUSH
24463: LD_STRING D5a-Pow-1d
24465: PPUSH
24466: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
24470: LD_INT 35
24472: PPUSH
24473: CALL_OW 67
// if not HasTask ( tmp ) then
24477: LD_VAR 0 3
24481: PPUSH
24482: CALL_OW 314
24486: NOT
24487: IFFALSE 24504
// ComAgressiveMove ( tmp , 68 , 63 ) ;
24489: LD_VAR 0 3
24493: PPUSH
24494: LD_INT 68
24496: PPUSH
24497: LD_INT 63
24499: PPUSH
24500: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
24504: LD_VAR 0 3
24508: PPUSH
24509: LD_INT 24
24511: PUSH
24512: LD_INT 1
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: PPUSH
24519: CALL_OW 72
24523: NOT
24524: IFFALSE 24470
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
24526: LD_ADDR_VAR 0 3
24530: PUSH
24531: LD_INT 22
24533: PUSH
24534: LD_INT 4
24536: PUSH
24537: EMPTY
24538: LIST
24539: LIST
24540: PUSH
24541: LD_INT 92
24543: PUSH
24544: LD_INT 60
24546: PUSH
24547: LD_INT 93
24549: PUSH
24550: LD_INT 10
24552: PUSH
24553: EMPTY
24554: LIST
24555: LIST
24556: LIST
24557: LIST
24558: PUSH
24559: LD_INT 3
24561: PUSH
24562: LD_INT 54
24564: PUSH
24565: EMPTY
24566: LIST
24567: PUSH
24568: EMPTY
24569: LIST
24570: LIST
24571: PUSH
24572: EMPTY
24573: LIST
24574: LIST
24575: LIST
24576: PPUSH
24577: CALL_OW 69
24581: PUSH
24582: LD_EXP 60
24586: DIFF
24587: ST_TO_ADDR
// if tmp then
24588: LD_VAR 0 3
24592: IFFALSE 24626
// for i in tmp do
24594: LD_ADDR_VAR 0 1
24598: PUSH
24599: LD_VAR 0 3
24603: PUSH
24604: FOR_IN
24605: IFFALSE 24624
// ComMoveXY ( i , 36 , 67 ) ;
24607: LD_VAR 0 1
24611: PPUSH
24612: LD_INT 36
24614: PPUSH
24615: LD_INT 67
24617: PPUSH
24618: CALL_OW 111
24622: GO 24604
24624: POP
24625: POP
// wait ( 0 0$3 ) ;
24626: LD_INT 105
24628: PPUSH
24629: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
24633: LD_VAR 0 11
24637: PPUSH
24638: LD_STRING D6-Sol3-1
24640: PPUSH
24641: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
24645: LD_EXP 60
24649: PPUSH
24650: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
24654: LD_EXP 60
24658: PPUSH
24659: LD_STRING D6-Pow-1
24661: PPUSH
24662: CALL_OW 88
// tmp := [ ] ;
24666: LD_ADDR_VAR 0 3
24670: PUSH
24671: EMPTY
24672: ST_TO_ADDR
// for i = 1 to 2 do
24673: LD_ADDR_VAR 0 1
24677: PUSH
24678: DOUBLE
24679: LD_INT 1
24681: DEC
24682: ST_TO_ADDR
24683: LD_INT 2
24685: PUSH
24686: FOR_TO
24687: IFFALSE 24801
// begin uc_side := 8 ;
24689: LD_ADDR_OWVAR 20
24693: PUSH
24694: LD_INT 8
24696: ST_TO_ADDR
// uc_nation := 2 ;
24697: LD_ADDR_OWVAR 21
24701: PUSH
24702: LD_INT 2
24704: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
24705: LD_INT 14
24707: PPUSH
24708: LD_INT 3
24710: PPUSH
24711: LD_INT 2
24713: PPUSH
24714: LD_INT 29
24716: PPUSH
24717: LD_INT 100
24719: PPUSH
24720: CALL 73738 0 5
// veh := CreateVehicle ;
24724: LD_ADDR_VAR 0 13
24728: PUSH
24729: CALL_OW 45
24733: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
24734: LD_VAR 0 13
24738: PPUSH
24739: LD_INT 4
24741: PPUSH
24742: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 3 , false ) ;
24746: LD_VAR 0 13
24750: PPUSH
24751: LD_INT 99
24753: PPUSH
24754: LD_INT 83
24756: PPUSH
24757: LD_INT 3
24759: PPUSH
24760: LD_INT 0
24762: PPUSH
24763: CALL_OW 50
// wait ( 3 ) ;
24767: LD_INT 3
24769: PPUSH
24770: CALL_OW 67
// Connect ( veh ) ;
24774: LD_VAR 0 13
24778: PPUSH
24779: CALL 76829 0 1
// tmp := tmp ^ veh ;
24783: LD_ADDR_VAR 0 3
24787: PUSH
24788: LD_VAR 0 3
24792: PUSH
24793: LD_VAR 0 13
24797: ADD
24798: ST_TO_ADDR
// end ;
24799: GO 24686
24801: POP
24802: POP
// wait ( 0 0$1 ) ;
24803: LD_INT 35
24805: PPUSH
24806: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
24810: LD_INT 99
24812: PPUSH
24813: LD_INT 83
24815: PPUSH
24816: LD_INT 1
24818: PPUSH
24819: LD_INT 10
24821: PPUSH
24822: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
24826: LD_INT 99
24828: PPUSH
24829: LD_INT 83
24831: PPUSH
24832: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
24836: LD_VAR 0 11
24840: PPUSH
24841: LD_STRING D6-Sol3-2
24843: PPUSH
24844: CALL_OW 88
// async ;
24848: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
24849: LD_EXP 60
24853: PPUSH
24854: LD_STRING D6-Pow-2
24856: PPUSH
24857: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
24861: LD_VAR 0 3
24865: PUSH
24866: LD_INT 1
24868: ARRAY
24869: PPUSH
24870: LD_VAR 0 9
24874: PPUSH
24875: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
24879: LD_VAR 0 3
24883: PUSH
24884: LD_INT 2
24886: ARRAY
24887: PPUSH
24888: LD_INT 22
24890: PUSH
24891: LD_INT 4
24893: PUSH
24894: EMPTY
24895: LIST
24896: LIST
24897: PUSH
24898: LD_INT 21
24900: PUSH
24901: LD_INT 3
24903: PUSH
24904: EMPTY
24905: LIST
24906: LIST
24907: PUSH
24908: EMPTY
24909: LIST
24910: LIST
24911: PPUSH
24912: CALL_OW 69
24916: PPUSH
24917: LD_VAR 0 3
24921: PUSH
24922: LD_INT 2
24924: ARRAY
24925: PPUSH
24926: CALL_OW 74
24930: PPUSH
24931: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
24935: LD_EXP 60
24939: PPUSH
24940: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
24944: LD_INT 99
24946: PPUSH
24947: LD_INT 83
24949: PPUSH
24950: LD_INT 1
24952: PPUSH
24953: CALL_OW 331
// repeat wait ( 4 ) ;
24957: LD_INT 4
24959: PPUSH
24960: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
24964: LD_VAR 0 3
24968: PUSH
24969: LD_INT 1
24971: ARRAY
24972: PPUSH
24973: CALL_OW 256
24977: PUSH
24978: LD_INT 1000
24980: LESS
24981: IFFALSE 24999
// SetLives ( tmp [ 1 ] , 1000 ) ;
24983: LD_VAR 0 3
24987: PUSH
24988: LD_INT 1
24990: ARRAY
24991: PPUSH
24992: LD_INT 1000
24994: PPUSH
24995: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
24999: LD_INT 22
25001: PUSH
25002: LD_INT 4
25004: PUSH
25005: EMPTY
25006: LIST
25007: LIST
25008: PUSH
25009: LD_INT 30
25011: PUSH
25012: LD_INT 3
25014: PUSH
25015: EMPTY
25016: LIST
25017: LIST
25018: PUSH
25019: EMPTY
25020: LIST
25021: LIST
25022: PPUSH
25023: CALL_OW 69
25027: PUSH
25028: LD_INT 0
25030: EQUAL
25031: IFFALSE 24957
// skirmish := false ;
25033: LD_ADDR_EXP 98
25037: PUSH
25038: LD_INT 0
25040: ST_TO_ADDR
// sync ;
25041: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
25042: LD_EXP 60
25046: PPUSH
25047: LD_STRING D6a-Pow-1
25049: PPUSH
25050: CALL_OW 88
// Say ( speaker , D6a-Sol3-1 ) ;
25054: LD_VAR 0 11
25058: PPUSH
25059: LD_STRING D6a-Sol3-1
25061: PPUSH
25062: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
25066: LD_EXP 60
25070: PPUSH
25071: LD_STRING D6a-Pow-2
25073: PPUSH
25074: CALL_OW 88
// Say ( speaker , D6a-Sol3-2 ) ;
25078: LD_VAR 0 11
25082: PPUSH
25083: LD_STRING D6a-Sol3-2
25085: PPUSH
25086: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
25090: LD_EXP 60
25094: PPUSH
25095: LD_STRING D6a-Pow-3
25097: PPUSH
25098: CALL_OW 88
// powellCenterCameraMode := true ;
25102: LD_ADDR_EXP 20
25106: PUSH
25107: LD_INT 1
25109: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
25110: LD_ADDR_VAR 0 1
25114: PUSH
25115: LD_INT 22
25117: PUSH
25118: LD_INT 8
25120: PUSH
25121: EMPTY
25122: LIST
25123: LIST
25124: PUSH
25125: LD_INT 25
25127: PUSH
25128: LD_INT 2
25130: PUSH
25131: EMPTY
25132: LIST
25133: LIST
25134: PUSH
25135: EMPTY
25136: LIST
25137: LIST
25138: PPUSH
25139: CALL_OW 69
25143: PUSH
25144: FOR_IN
25145: IFFALSE 25200
// begin SetTag ( i , 1 ) ;
25147: LD_VAR 0 1
25151: PPUSH
25152: LD_INT 1
25154: PPUSH
25155: CALL_OW 109
// ComExitBuilding ( i ) ;
25159: LD_VAR 0 1
25163: PPUSH
25164: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
25168: LD_VAR 0 1
25172: PPUSH
25173: LD_INT 35
25175: PPUSH
25176: LD_INT 6
25178: PPUSH
25179: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
25183: LD_VAR 0 1
25187: PPUSH
25188: LD_INT 53
25190: PPUSH
25191: LD_INT 4
25193: PPUSH
25194: CALL_OW 171
// end ;
25198: GO 25144
25200: POP
25201: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
25202: LD_ADDR_VAR 0 3
25206: PUSH
25207: LD_INT 22
25209: PUSH
25210: LD_INT 4
25212: PUSH
25213: EMPTY
25214: LIST
25215: LIST
25216: PUSH
25217: LD_INT 21
25219: PUSH
25220: LD_INT 2
25222: PUSH
25223: EMPTY
25224: LIST
25225: LIST
25226: PUSH
25227: LD_INT 3
25229: PUSH
25230: LD_INT 34
25232: PUSH
25233: LD_INT 12
25235: PUSH
25236: EMPTY
25237: LIST
25238: LIST
25239: PUSH
25240: EMPTY
25241: LIST
25242: LIST
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: LIST
25248: PPUSH
25249: CALL_OW 69
25253: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
25254: LD_EXP 60
25258: PPUSH
25259: LD_VAR 0 3
25263: PPUSH
25264: LD_EXP 60
25268: PPUSH
25269: CALL_OW 74
25273: PPUSH
25274: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
25278: LD_EXP 60
25282: PPUSH
25283: LD_INT 100
25285: PPUSH
25286: LD_INT 88
25288: PPUSH
25289: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
25293: LD_EXP 60
25297: PPUSH
25298: LD_INT 100
25300: PPUSH
25301: LD_INT 75
25303: PPUSH
25304: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
25308: LD_EXP 60
25312: PPUSH
25313: LD_INT 88
25315: PPUSH
25316: LD_INT 53
25318: PPUSH
25319: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
25323: LD_INT 8
25325: PPUSH
25326: LD_EXP 60
25330: PPUSH
25331: CALL_OW 471
// repeat wait ( 3 ) ;
25335: LD_INT 3
25337: PPUSH
25338: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
25342: LD_INT 22
25344: PUSH
25345: LD_INT 4
25347: PUSH
25348: EMPTY
25349: LIST
25350: LIST
25351: PUSH
25352: LD_INT 92
25354: PUSH
25355: LD_INT 100
25357: PUSH
25358: LD_INT 75
25360: PUSH
25361: LD_INT 6
25363: PUSH
25364: EMPTY
25365: LIST
25366: LIST
25367: LIST
25368: LIST
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: PPUSH
25374: CALL_OW 69
25378: IFFALSE 25335
// async ;
25380: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
25381: LD_EXP 60
25385: PPUSH
25386: LD_STRING D6b-Pow-1
25388: PPUSH
25389: CALL_OW 88
// repeat wait ( 3 ) ;
25393: LD_INT 3
25395: PPUSH
25396: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
25400: LD_EXP 60
25404: PPUSH
25405: CALL_OW 310
25409: PPUSH
25410: CALL_OW 256
25414: PUSH
25415: LD_INT 1000
25417: LESS
25418: IFFALSE 25437
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
25420: LD_EXP 60
25424: PPUSH
25425: CALL_OW 310
25429: PPUSH
25430: LD_INT 1000
25432: PPUSH
25433: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
25437: LD_EXP 60
25441: PPUSH
25442: CALL_OW 256
25446: PUSH
25447: LD_INT 1000
25449: LESS
25450: IFFALSE 25464
// SetLives ( Powell , 1000 ) ;
25452: LD_EXP 60
25456: PPUSH
25457: LD_INT 1000
25459: PPUSH
25460: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
25464: LD_EXP 60
25468: PPUSH
25469: LD_EXP 65
25473: PPUSH
25474: CALL_OW 296
25478: PUSH
25479: LD_INT 5
25481: LESS
25482: PUSH
25483: LD_EXP 60
25487: PPUSH
25488: CALL_OW 310
25492: PPUSH
25493: LD_EXP 65
25497: PPUSH
25498: CALL_OW 296
25502: PUSH
25503: LD_INT 5
25505: LESS
25506: OR
25507: IFFALSE 25526
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
25509: LD_EXP 60
25513: PPUSH
25514: CALL_OW 310
25518: PPUSH
25519: LD_INT 100
25521: PPUSH
25522: CALL_OW 234
// until not IsInUnit ( Powell ) ;
25526: LD_EXP 60
25530: PPUSH
25531: CALL_OW 310
25535: NOT
25536: IFFALSE 25393
// DoNotAttack ( 8 , powellBomb ) ;
25538: LD_INT 8
25540: PPUSH
25541: LD_EXP 65
25545: PPUSH
25546: CALL_OW 471
// game_speed := 4 ;
25550: LD_ADDR_OWVAR 65
25554: PUSH
25555: LD_INT 4
25557: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
25558: LD_EXP 60
25562: PPUSH
25563: LD_STRING D6b-Pow-1a
25565: PPUSH
25566: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
25570: LD_EXP 60
25574: PPUSH
25575: LD_EXP 65
25579: PPUSH
25580: CALL_OW 180
// sync ;
25584: SYNC
// repeat wait ( 0 0$1 ) ;
25585: LD_INT 35
25587: PPUSH
25588: CALL_OW 67
// until IsInUnit ( Powell ) ;
25592: LD_EXP 60
25596: PPUSH
25597: CALL_OW 310
25601: IFFALSE 25585
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
25603: LD_INT 8
25605: PPUSH
25606: LD_EXP 60
25610: PPUSH
25611: CALL_OW 310
25615: PPUSH
25616: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
25620: LD_EXP 60
25624: PPUSH
25625: LD_INT 91
25627: PPUSH
25628: LD_INT 44
25630: PPUSH
25631: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
25635: LD_EXP 60
25639: PPUSH
25640: LD_INT 96
25642: PPUSH
25643: LD_INT 44
25645: PPUSH
25646: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
25650: LD_EXP 60
25654: PPUSH
25655: LD_INT 96
25657: PPUSH
25658: LD_INT 41
25660: PPUSH
25661: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
25665: LD_EXP 60
25669: PPUSH
25670: LD_INT 92
25672: PPUSH
25673: LD_INT 39
25675: PPUSH
25676: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
25680: LD_EXP 60
25684: PPUSH
25685: LD_INT 88
25687: PPUSH
25688: LD_INT 41
25690: PPUSH
25691: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
25695: LD_EXP 60
25699: PPUSH
25700: LD_INT 91
25702: PPUSH
25703: LD_INT 44
25705: PPUSH
25706: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
25710: LD_EXP 60
25714: PPUSH
25715: LD_INT 96
25717: PPUSH
25718: LD_INT 44
25720: PPUSH
25721: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
25725: LD_EXP 60
25729: PPUSH
25730: LD_INT 96
25732: PPUSH
25733: LD_INT 41
25735: PPUSH
25736: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
25740: LD_EXP 60
25744: PPUSH
25745: LD_INT 92
25747: PPUSH
25748: LD_INT 39
25750: PPUSH
25751: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
25755: LD_EXP 60
25759: PPUSH
25760: LD_INT 88
25762: PPUSH
25763: LD_INT 41
25765: PPUSH
25766: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
25770: LD_EXP 60
25774: PPUSH
25775: LD_INT 91
25777: PPUSH
25778: LD_INT 44
25780: PPUSH
25781: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
25785: LD_EXP 60
25789: PPUSH
25790: LD_INT 93
25792: PPUSH
25793: LD_INT 39
25795: PPUSH
25796: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
25800: LD_EXP 60
25804: PPUSH
25805: LD_INT 93
25807: PPUSH
25808: LD_INT 36
25810: PPUSH
25811: CALL_OW 171
// wait ( 0 0$3.5 ) ;
25815: LD_INT 122
25817: PPUSH
25818: CALL_OW 67
// game_speed := 4 ;
25822: LD_ADDR_OWVAR 65
25826: PUSH
25827: LD_INT 4
25829: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
25830: LD_EXP 60
25834: PPUSH
25835: LD_STRING D6b-Pow-1b
25837: PPUSH
25838: CALL_OW 88
// tmp := [ ] ;
25842: LD_ADDR_VAR 0 3
25846: PUSH
25847: EMPTY
25848: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
25849: LD_ADDR_VAR 0 5
25853: PUSH
25854: LD_INT 78
25856: PUSH
25857: LD_INT 47
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: LD_INT 106
25866: PUSH
25867: LD_INT 53
25869: PUSH
25870: EMPTY
25871: LIST
25872: LIST
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
25878: LD_ADDR_VAR 0 1
25882: PUSH
25883: LD_INT 22
25885: PUSH
25886: LD_INT 8
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: PUSH
25893: LD_INT 21
25895: PUSH
25896: LD_INT 3
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: PUSH
25903: LD_INT 92
25905: PUSH
25906: LD_INT 90
25908: PUSH
25909: LD_INT 52
25911: PUSH
25912: LD_INT 12
25914: PUSH
25915: EMPTY
25916: LIST
25917: LIST
25918: LIST
25919: LIST
25920: PUSH
25921: EMPTY
25922: LIST
25923: LIST
25924: LIST
25925: PPUSH
25926: CALL_OW 69
25930: PUSH
25931: FOR_IN
25932: IFFALSE 25957
// tmp := tmp ^ UnitsInside ( i ) ;
25934: LD_ADDR_VAR 0 3
25938: PUSH
25939: LD_VAR 0 3
25943: PUSH
25944: LD_VAR 0 1
25948: PPUSH
25949: CALL_OW 313
25953: ADD
25954: ST_TO_ADDR
25955: GO 25931
25957: POP
25958: POP
// for i in tmp do
25959: LD_ADDR_VAR 0 1
25963: PUSH
25964: LD_VAR 0 3
25968: PUSH
25969: FOR_IN
25970: IFFALSE 26132
// begin dist := 9999 ;
25972: LD_ADDR_VAR 0 8
25976: PUSH
25977: LD_INT 9999
25979: ST_TO_ADDR
// _xy := [ ] ;
25980: LD_ADDR_VAR 0 7
25984: PUSH
25985: EMPTY
25986: ST_TO_ADDR
// SetTag ( i , 1 ) ;
25987: LD_VAR 0 1
25991: PPUSH
25992: LD_INT 1
25994: PPUSH
25995: CALL_OW 109
// ComExitBuilding ( i ) ;
25999: LD_VAR 0 1
26003: PPUSH
26004: CALL_OW 122
// for j in xy do
26008: LD_ADDR_VAR 0 2
26012: PUSH
26013: LD_VAR 0 5
26017: PUSH
26018: FOR_IN
26019: IFFALSE 26101
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
26021: LD_VAR 0 1
26025: PPUSH
26026: LD_VAR 0 2
26030: PUSH
26031: LD_INT 1
26033: ARRAY
26034: PPUSH
26035: LD_VAR 0 2
26039: PUSH
26040: LD_INT 2
26042: ARRAY
26043: PPUSH
26044: CALL_OW 297
26048: PUSH
26049: LD_VAR 0 8
26053: LESS
26054: IFFALSE 26099
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
26056: LD_ADDR_VAR 0 8
26060: PUSH
26061: LD_VAR 0 1
26065: PPUSH
26066: LD_VAR 0 2
26070: PUSH
26071: LD_INT 1
26073: ARRAY
26074: PPUSH
26075: LD_VAR 0 2
26079: PUSH
26080: LD_INT 2
26082: ARRAY
26083: PPUSH
26084: CALL_OW 297
26088: ST_TO_ADDR
// _xy := j ;
26089: LD_ADDR_VAR 0 7
26093: PUSH
26094: LD_VAR 0 2
26098: ST_TO_ADDR
// end ;
26099: GO 26018
26101: POP
26102: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
26103: LD_VAR 0 1
26107: PPUSH
26108: LD_VAR 0 7
26112: PUSH
26113: LD_INT 1
26115: ARRAY
26116: PPUSH
26117: LD_VAR 0 7
26121: PUSH
26122: LD_INT 2
26124: ARRAY
26125: PPUSH
26126: CALL_OW 171
// end ;
26130: GO 25969
26132: POP
26133: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
26134: LD_ADDR_VAR 0 4
26138: PUSH
26139: LD_VAR 0 3
26143: PPUSH
26144: LD_INT 26
26146: PUSH
26147: LD_INT 1
26149: PUSH
26150: EMPTY
26151: LIST
26152: LIST
26153: PUSH
26154: LD_INT 25
26156: PUSH
26157: LD_INT 1
26159: PUSH
26160: EMPTY
26161: LIST
26162: LIST
26163: PUSH
26164: EMPTY
26165: LIST
26166: LIST
26167: PPUSH
26168: CALL_OW 72
26172: ST_TO_ADDR
// if tmp2 < 2 then
26173: LD_VAR 0 4
26177: PUSH
26178: LD_INT 2
26180: LESS
26181: IFFALSE 26250
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
26183: LD_ADDR_VAR 0 4
26187: PUSH
26188: LD_INT 22
26190: PUSH
26191: LD_INT 8
26193: PUSH
26194: EMPTY
26195: LIST
26196: LIST
26197: PUSH
26198: LD_INT 26
26200: PUSH
26201: LD_INT 1
26203: PUSH
26204: EMPTY
26205: LIST
26206: LIST
26207: PUSH
26208: LD_INT 3
26210: PUSH
26211: LD_INT 25
26213: PUSH
26214: LD_INT 15
26216: PUSH
26217: EMPTY
26218: LIST
26219: LIST
26220: PUSH
26221: EMPTY
26222: LIST
26223: LIST
26224: PUSH
26225: EMPTY
26226: LIST
26227: LIST
26228: LIST
26229: PPUSH
26230: CALL_OW 69
26234: PUSH
26235: LD_EXP 62
26239: PUSH
26240: LD_EXP 63
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: DIFF
26249: ST_TO_ADDR
// if tmp2 then
26250: LD_VAR 0 4
26254: IFFALSE 26272
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
26256: LD_VAR 0 4
26260: PUSH
26261: LD_INT 1
26263: ARRAY
26264: PPUSH
26265: LD_STRING D6b-ArSol1-1
26267: PPUSH
26268: CALL_OW 88
// async ;
26272: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
26273: LD_EXP 60
26277: PPUSH
26278: LD_STRING D6b-Pow-2
26280: PPUSH
26281: CALL_OW 88
// wait ( 0 0$0.5 ) ;
26285: LD_INT 18
26287: PPUSH
26288: CALL_OW 67
// if tmp2 > 1 then
26292: LD_VAR 0 4
26296: PUSH
26297: LD_INT 1
26299: GREATER
26300: IFFALSE 26318
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
26302: LD_VAR 0 4
26306: PUSH
26307: LD_INT 2
26309: ARRAY
26310: PPUSH
26311: LD_STRING D6b-ArSol2-1
26313: PPUSH
26314: CALL_OW 88
// sync ;
26318: SYNC
// repeat wait ( 5 ) ;
26319: LD_INT 5
26321: PPUSH
26322: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
26326: LD_INT 93
26328: PPUSH
26329: LD_INT 36
26331: PPUSH
26332: CALL_OW 428
26336: PPUSH
26337: CALL_OW 255
26341: PUSH
26342: LD_INT 4
26344: EQUAL
26345: IFFALSE 26319
// DialogueOn ;
26347: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
26351: LD_INT 10
26353: PPUSH
26354: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
26358: LD_EXP 60
26362: PPUSH
26363: LD_STRING D6b-Pow-2a
26365: PPUSH
26366: CALL_OW 88
// DialogueOff ;
26370: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
26374: LD_EXP 60
26378: PPUSH
26379: CALL_OW 310
26383: PPUSH
26384: LD_INT 332
26386: PPUSH
26387: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
26391: LD_INT 93
26393: PPUSH
26394: LD_INT 35
26396: PPUSH
26397: LD_INT 1
26399: PPUSH
26400: LD_INT 6
26402: NEG
26403: PPUSH
26404: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
26408: LD_INT 35
26410: PPUSH
26411: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
26415: LD_INT 332
26417: PPUSH
26418: CALL_OW 256
26422: PUSH
26423: LD_INT 1000
26425: LESS
26426: PUSH
26427: LD_INT 332
26429: PPUSH
26430: CALL_OW 300
26434: AND
26435: IFFALSE 26447
// SetLives ( kozlov_fac , 0 ) ;
26437: LD_INT 332
26439: PPUSH
26440: LD_INT 0
26442: PPUSH
26443: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
26447: LD_INT 332
26449: PPUSH
26450: CALL_OW 301
26454: PUSH
26455: LD_EXP 60
26459: PPUSH
26460: CALL_OW 301
26464: OR
26465: IFFALSE 26408
// game_speed := 4 ;
26467: LD_ADDR_OWVAR 65
26471: PUSH
26472: LD_INT 4
26474: ST_TO_ADDR
// powellCenterCameraMode := false ;
26475: LD_ADDR_EXP 20
26479: PUSH
26480: LD_INT 0
26482: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
26483: LD_ADDR_VAR 0 1
26487: PUSH
26488: LD_VAR 0 3
26492: PUSH
26493: LD_INT 22
26495: PUSH
26496: LD_INT 8
26498: PUSH
26499: EMPTY
26500: LIST
26501: LIST
26502: PUSH
26503: LD_INT 25
26505: PUSH
26506: LD_INT 2
26508: PUSH
26509: EMPTY
26510: LIST
26511: LIST
26512: PUSH
26513: EMPTY
26514: LIST
26515: LIST
26516: PPUSH
26517: CALL_OW 69
26521: UNION
26522: PUSH
26523: FOR_IN
26524: IFFALSE 26540
// SetTag ( i , 0 ) ;
26526: LD_VAR 0 1
26530: PPUSH
26531: LD_INT 0
26533: PPUSH
26534: CALL_OW 109
26538: GO 26523
26540: POP
26541: POP
// wait ( 0 0$3 ) ;
26542: LD_INT 105
26544: PPUSH
26545: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
26549: LD_INT 93
26551: PPUSH
26552: LD_INT 35
26554: PPUSH
26555: LD_INT 1
26557: PPUSH
26558: CALL_OW 331
// DialogueOn ;
26562: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
26566: LD_VAR 0 11
26570: PPUSH
26571: LD_STRING D6c-Sol3-1
26573: PPUSH
26574: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
26578: LD_INT 10
26580: PPUSH
26581: CALL_OW 68
// Say ( JMM , D6c-JMM-1 ) ;
26585: LD_EXP 40
26589: PPUSH
26590: LD_STRING D6c-JMM-1
26592: PPUSH
26593: CALL_OW 88
// if Cyrus then
26597: LD_EXP 46
26601: IFFALSE 26615
// Say ( Cyrus , D6c-Cyrus-1 ) ;
26603: LD_EXP 46
26607: PPUSH
26608: LD_STRING D6c-Cyrus-1
26610: PPUSH
26611: CALL_OW 88
// if Bobby then
26615: LD_EXP 45
26619: IFFALSE 26633
// Say ( Bobby , D6c-Bobby-1 ) ;
26621: LD_EXP 45
26625: PPUSH
26626: LD_STRING D6c-Bobby-1
26628: PPUSH
26629: CALL_OW 88
// if Cornel then
26633: LD_EXP 51
26637: IFFALSE 26651
// Say ( Cornel , D6c-Corn-1 ) ;
26639: LD_EXP 51
26643: PPUSH
26644: LD_STRING D6c-Corn-1
26646: PPUSH
26647: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_nation , 1 ] ] ) diff ( speaker union JMM union vip ) ;
26651: LD_ADDR_VAR 0 4
26655: PUSH
26656: LD_INT 2
26658: PUSH
26659: LD_INT 22
26661: PUSH
26662: LD_INT 1
26664: PUSH
26665: EMPTY
26666: LIST
26667: LIST
26668: PUSH
26669: LD_INT 22
26671: PUSH
26672: LD_INT 4
26674: PUSH
26675: EMPTY
26676: LIST
26677: LIST
26678: PUSH
26679: EMPTY
26680: LIST
26681: LIST
26682: LIST
26683: PUSH
26684: LD_INT 26
26686: PUSH
26687: LD_INT 1
26689: PUSH
26690: EMPTY
26691: LIST
26692: LIST
26693: PUSH
26694: LD_INT 23
26696: PUSH
26697: LD_INT 1
26699: PUSH
26700: EMPTY
26701: LIST
26702: LIST
26703: PUSH
26704: EMPTY
26705: LIST
26706: LIST
26707: LIST
26708: PPUSH
26709: CALL_OW 69
26713: PUSH
26714: LD_VAR 0 11
26718: PUSH
26719: LD_EXP 40
26723: UNION
26724: PUSH
26725: LD_EXP 61
26729: UNION
26730: DIFF
26731: ST_TO_ADDR
// if tmp2 then
26732: LD_VAR 0 4
26736: IFFALSE 26754
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
26738: LD_VAR 0 4
26742: PUSH
26743: LD_INT 1
26745: ARRAY
26746: PPUSH
26747: LD_STRING D6c-Sol1-1
26749: PPUSH
26750: CALL_OW 88
// if Lisa then
26754: LD_EXP 43
26758: IFFALSE 26772
// Say ( Lisa , D6c-Lisa-1 ) ;
26760: LD_EXP 43
26764: PPUSH
26765: LD_STRING D6c-Lisa-1
26767: PPUSH
26768: CALL_OW 88
// if Gary then
26772: LD_EXP 52
26776: IFFALSE 26790
// Say ( Gary , D6c-Gary-1 ) ;
26778: LD_EXP 52
26782: PPUSH
26783: LD_STRING D6c-Gary-1
26785: PPUSH
26786: CALL_OW 88
// if Donaldson then
26790: LD_EXP 44
26794: IFFALSE 26808
// Say ( Donaldson , D6c-Don-1 ) ;
26796: LD_EXP 44
26800: PPUSH
26801: LD_STRING D6c-Don-1
26803: PPUSH
26804: CALL_OW 88
// if tmp2 > 1 then
26808: LD_VAR 0 4
26812: PUSH
26813: LD_INT 1
26815: GREATER
26816: IFFALSE 26834
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
26818: LD_VAR 0 4
26822: PUSH
26823: LD_INT 2
26825: ARRAY
26826: PPUSH
26827: LD_STRING D6c-Sol2-1
26829: PPUSH
26830: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
26834: LD_VAR 0 11
26838: PPUSH
26839: LD_STRING D6c-Sol3-2
26841: PPUSH
26842: CALL_OW 88
// if IsInUnit ( JMM ) then
26846: LD_EXP 40
26850: PPUSH
26851: CALL_OW 310
26855: IFFALSE 26873
// CenterNowOnUnits ( IsInUnit ( JMM ) ) else
26857: LD_EXP 40
26861: PPUSH
26862: CALL_OW 310
26866: PPUSH
26867: CALL_OW 87
26871: GO 26882
// CenterNowOnUnits ( JMM ) ;
26873: LD_EXP 40
26877: PPUSH
26878: CALL_OW 87
// dwait ( 0 0$2 ) ;
26882: LD_INT 70
26884: PPUSH
26885: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
26889: LD_EXP 40
26893: PPUSH
26894: LD_STRING D6c-JMM-2
26896: PPUSH
26897: CALL_OW 88
// DialogueOff ;
26901: CALL_OW 7
// Video ( false ) ;
26905: LD_INT 0
26907: PPUSH
26908: CALL 106162 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
26912: LD_INT 22
26914: PUSH
26915: LD_INT 4
26917: PUSH
26918: EMPTY
26919: LIST
26920: LIST
26921: PPUSH
26922: CALL_OW 69
26926: PPUSH
26927: LD_INT 1
26929: PPUSH
26930: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
26934: LD_INT 4
26936: PPUSH
26937: LD_INT 4
26939: PPUSH
26940: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
26944: LD_ADDR_VAR 0 1
26948: PUSH
26949: LD_INT 4
26951: PPUSH
26952: LD_INT 1
26954: PPUSH
26955: LD_INT 2
26957: PPUSH
26958: CALL 68961 0 3
26962: PUSH
26963: FOR_IN
26964: IFFALSE 27001
// if GetTech ( i , 1 ) <> state_researched then
26966: LD_VAR 0 1
26970: PPUSH
26971: LD_INT 1
26973: PPUSH
26974: CALL_OW 321
26978: PUSH
26979: LD_INT 2
26981: NONEQUAL
26982: IFFALSE 26999
// SetTech ( i , 1 , state_researched ) ;
26984: LD_VAR 0 1
26988: PPUSH
26989: LD_INT 1
26991: PPUSH
26992: LD_INT 2
26994: PPUSH
26995: CALL_OW 322
26999: GO 26963
27001: POP
27002: POP
// missionStage := 6 ;
27003: LD_ADDR_EXP 15
27007: PUSH
27008: LD_INT 6
27010: ST_TO_ADDR
// activeAttacks := true ;
27011: LD_ADDR_EXP 16
27015: PUSH
27016: LD_INT 1
27018: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
27019: LD_STRING M2
27021: PPUSH
27022: CALL_OW 337
// SaveForQuickRestart ;
27026: CALL_OW 22
// wait ( 0 0$40 ) ;
27030: LD_INT 1400
27032: PPUSH
27033: CALL_OW 67
// DialogueOn ;
27037: CALL_OW 6
// SayRadioNoFaceNoName ( Friend , D7-Friend-1 ) ;
27041: LD_EXP 64
27045: PPUSH
27046: LD_STRING D7-Friend-1
27048: PPUSH
27049: CALL 110109 0 2
// Say ( JMM , D7-JMM-1 ) ;
27053: LD_EXP 40
27057: PPUSH
27058: LD_STRING D7-JMM-1
27060: PPUSH
27061: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-2 ) ;
27065: LD_EXP 64
27069: PPUSH
27070: LD_STRING D7-Friend-2
27072: PPUSH
27073: CALL 110109 0 2
// Say ( JMM , D7-JMM-2 ) ;
27077: LD_EXP 40
27081: PPUSH
27082: LD_STRING D7-JMM-2
27084: PPUSH
27085: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-3 ) ;
27089: LD_EXP 64
27093: PPUSH
27094: LD_STRING D7-Friend-3
27096: PPUSH
27097: CALL 110109 0 2
// Say ( JMM , D7-JMM-3 ) ;
27101: LD_EXP 40
27105: PPUSH
27106: LD_STRING D7-JMM-3
27108: PPUSH
27109: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-4 ) ;
27113: LD_EXP 64
27117: PPUSH
27118: LD_STRING D7-Friend-4
27120: PPUSH
27121: CALL 110109 0 2
// Say ( JMM , D7-JMM-4 ) ;
27125: LD_EXP 40
27129: PPUSH
27130: LD_STRING D7-JMM-4
27132: PPUSH
27133: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-5 ) ;
27137: LD_EXP 64
27141: PPUSH
27142: LD_STRING D7-Friend-5
27144: PPUSH
27145: CALL 110109 0 2
// Say ( JMM , D7-JMM-5 ) ;
27149: LD_EXP 40
27153: PPUSH
27154: LD_STRING D7-JMM-5
27156: PPUSH
27157: CALL_OW 88
// SayRadioNoFaceNoName ( Friend , D7-Friend-6 ) ;
27161: LD_EXP 64
27165: PPUSH
27166: LD_STRING D7-Friend-6
27168: PPUSH
27169: CALL 110109 0 2
// Say ( JMM , D7-JMM-6 ) ;
27173: LD_EXP 40
27177: PPUSH
27178: LD_STRING D7-JMM-6
27180: PPUSH
27181: CALL_OW 88
// DialogueOff ;
27185: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
27189: LD_STRING Mlegion
27191: PPUSH
27192: CALL_OW 337
// skirmish := true ;
27196: LD_ADDR_EXP 98
27200: PUSH
27201: LD_INT 1
27203: ST_TO_ADDR
// RebuildKozlovFactory ;
27204: CALL 5086 0 0
// end ;
27208: PPOPN 13
27210: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
27211: LD_EXP 20
27215: PUSH
27216: LD_EXP 60
27220: PPUSH
27221: CALL_OW 300
27225: AND
27226: IFFALSE 27268
27228: GO 27230
27230: DISABLE
// begin enable ;
27231: ENABLE
// if IsInUnit ( Powell ) then
27232: LD_EXP 60
27236: PPUSH
27237: CALL_OW 310
27241: IFFALSE 27259
// CenterOnUnits ( IsInUnit ( Powell ) ) else
27243: LD_EXP 60
27247: PPUSH
27248: CALL_OW 310
27252: PPUSH
27253: CALL_OW 85
27257: GO 27268
// CenterOnUnits ( Powell ) ;
27259: LD_EXP 60
27263: PPUSH
27264: CALL_OW 85
// end ;
27268: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
27269: LD_INT 22
27271: PUSH
27272: LD_INT 8
27274: PUSH
27275: EMPTY
27276: LIST
27277: LIST
27278: PUSH
27279: LD_INT 34
27281: PUSH
27282: LD_INT 48
27284: PUSH
27285: EMPTY
27286: LIST
27287: LIST
27288: PUSH
27289: EMPTY
27290: LIST
27291: LIST
27292: PPUSH
27293: CALL_OW 69
27297: IFFALSE 27571
27299: GO 27301
27301: DISABLE
27302: LD_INT 0
27304: PPUSH
27305: PPUSH
// begin if missionStage < 9 then
27306: LD_EXP 15
27310: PUSH
27311: LD_INT 9
27313: LESS
27314: IFFALSE 27324
// missionStage := 9 ;
27316: LD_ADDR_EXP 15
27320: PUSH
27321: LD_INT 9
27323: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27324: LD_ADDR_VAR 0 1
27328: PUSH
27329: LD_INT 22
27331: PUSH
27332: LD_INT 8
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: PUSH
27339: LD_INT 34
27341: PUSH
27342: LD_INT 48
27344: PUSH
27345: EMPTY
27346: LIST
27347: LIST
27348: PUSH
27349: EMPTY
27350: LIST
27351: LIST
27352: PPUSH
27353: CALL_OW 69
27357: PUSH
27358: LD_INT 1
27360: ARRAY
27361: ST_TO_ADDR
// wait ( 0 0$05 ) ;
27362: LD_INT 175
27364: PPUSH
27365: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
27369: LD_EXP 12
27373: PUSH
27374: LD_EXP 3
27378: PUSH
27379: LD_INT 0
27381: PUSH
27382: LD_INT 2
27384: PUSH
27385: EMPTY
27386: LIST
27387: LIST
27388: IN
27389: OR
27390: IFFALSE 27413
// target := [ 68 , 108 , 1 ] else
27392: LD_ADDR_VAR 0 2
27396: PUSH
27397: LD_INT 68
27399: PUSH
27400: LD_INT 108
27402: PUSH
27403: LD_INT 1
27405: PUSH
27406: EMPTY
27407: LIST
27408: LIST
27409: LIST
27410: ST_TO_ADDR
27411: GO 27432
// target := [ 181 , 88 , 2 ] ;
27413: LD_ADDR_VAR 0 2
27417: PUSH
27418: LD_INT 181
27420: PUSH
27421: LD_INT 88
27423: PUSH
27424: LD_INT 2
27426: PUSH
27427: EMPTY
27428: LIST
27429: LIST
27430: LIST
27431: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
27432: LD_VAR 0 1
27436: PPUSH
27437: LD_VAR 0 2
27441: PUSH
27442: LD_INT 1
27444: ARRAY
27445: PPUSH
27446: LD_VAR 0 2
27450: PUSH
27451: LD_INT 2
27453: ARRAY
27454: PPUSH
27455: CALL_OW 176
// if target [ 3 ] = 1 then
27459: LD_VAR 0 2
27463: PUSH
27464: LD_INT 3
27466: ARRAY
27467: PUSH
27468: LD_INT 1
27470: EQUAL
27471: IFFALSE 27487
// SayRadio ( Kurt , D12-Kurt-1 ) else
27473: LD_EXP 62
27477: PPUSH
27478: LD_STRING D12-Kurt-1
27480: PPUSH
27481: CALL_OW 94
27485: GO 27511
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
27487: LD_EXP 62
27491: PPUSH
27492: LD_STRING D12a-Kurt-1
27494: PPUSH
27495: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
27499: LD_EXP 77
27503: PPUSH
27504: LD_STRING D12a-Roth-1
27506: PPUSH
27507: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
27511: LD_INT 350
27513: PPUSH
27514: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
27518: LD_VAR 0 1
27522: PPUSH
27523: LD_INT 22
27525: PUSH
27526: LD_INT 8
27528: PUSH
27529: EMPTY
27530: LIST
27531: LIST
27532: PUSH
27533: LD_INT 23
27535: PUSH
27536: LD_INT 2
27538: PUSH
27539: EMPTY
27540: LIST
27541: LIST
27542: PUSH
27543: LD_INT 30
27545: PUSH
27546: LD_INT 3
27548: PUSH
27549: EMPTY
27550: LIST
27551: LIST
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: LIST
27557: PPUSH
27558: CALL_OW 69
27562: PUSH
27563: LD_INT 1
27565: ARRAY
27566: PPUSH
27567: CALL_OW 228
// end ;
27571: PPOPN 2
27573: END
// every 0 0$3 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
27574: LD_EXP 62
27578: PPUSH
27579: CALL_OW 256
27583: PUSH
27584: LD_INT 999
27586: LESS
27587: PUSH
27588: LD_INT 22
27590: PUSH
27591: LD_INT 8
27593: PUSH
27594: EMPTY
27595: LIST
27596: LIST
27597: PUSH
27598: LD_INT 21
27600: PUSH
27601: LD_INT 1
27603: PUSH
27604: EMPTY
27605: LIST
27606: LIST
27607: PUSH
27608: LD_INT 23
27610: PUSH
27611: LD_INT 2
27613: PUSH
27614: EMPTY
27615: LIST
27616: LIST
27617: PUSH
27618: EMPTY
27619: LIST
27620: LIST
27621: LIST
27622: PPUSH
27623: CALL_OW 69
27627: PUSH
27628: LD_INT 9
27630: PUSH
27631: LD_INT 8
27633: PUSH
27634: LD_INT 7
27636: PUSH
27637: LD_INT 6
27639: PUSH
27640: EMPTY
27641: LIST
27642: LIST
27643: LIST
27644: LIST
27645: PUSH
27646: LD_OWVAR 67
27650: ARRAY
27651: LESSEQUAL
27652: OR
27653: PUSH
27654: LD_INT 22
27656: PUSH
27657: LD_INT 8
27659: PUSH
27660: EMPTY
27661: LIST
27662: LIST
27663: PUSH
27664: LD_INT 34
27666: PUSH
27667: LD_INT 48
27669: PUSH
27670: EMPTY
27671: LIST
27672: LIST
27673: PUSH
27674: EMPTY
27675: LIST
27676: LIST
27677: PPUSH
27678: CALL_OW 69
27682: NOT
27683: AND
27684: PUSH
27685: LD_EXP 62
27689: PPUSH
27690: CALL_OW 302
27694: AND
27695: PUSH
27696: LD_INT 5
27698: PPUSH
27699: LD_INT 22
27701: PUSH
27702: LD_INT 1
27704: PUSH
27705: EMPTY
27706: LIST
27707: LIST
27708: PPUSH
27709: CALL_OW 70
27713: AND
27714: IFFALSE 28476
27716: GO 27718
27718: DISABLE
27719: LD_INT 0
27721: PPUSH
27722: PPUSH
27723: PPUSH
// begin legionDestroyed := true ;
27724: LD_ADDR_EXP 22
27728: PUSH
27729: LD_INT 1
27731: ST_TO_ADDR
// DialogueOn ;
27732: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
27736: LD_EXP 40
27740: PPUSH
27741: LD_STRING D13-JMM-1
27743: PPUSH
27744: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
27748: LD_EXP 62
27752: PPUSH
27753: LD_STRING D13-Kurt-1
27755: PPUSH
27756: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
27760: LD_EXP 40
27764: PPUSH
27765: LD_STRING D13-JMM-2
27767: PPUSH
27768: CALL_OW 88
// if FakeInfo then
27772: LD_EXP 12
27776: IFFALSE 27796
// begin Say ( Kurt , D13-Kurt-2 ) ;
27778: LD_EXP 62
27782: PPUSH
27783: LD_STRING D13-Kurt-2
27785: PPUSH
27786: CALL_OW 88
// DialogueOff ;
27790: CALL_OW 7
// exit ;
27794: GO 28476
// end ; if not KurtStatus then
27796: LD_EXP 3
27800: NOT
27801: IFFALSE 27817
// Say ( Kurt , D13-Kurt-2b ) else
27803: LD_EXP 62
27807: PPUSH
27808: LD_STRING D13-Kurt-2b
27810: PPUSH
27811: CALL_OW 88
27815: GO 27829
// Say ( Kurt , D13-Kurt-2a ) ;
27817: LD_EXP 62
27821: PPUSH
27822: LD_STRING D13-Kurt-2a
27824: PPUSH
27825: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
27829: LD_EXP 40
27833: PPUSH
27834: LD_STRING D13-JMM-3
27836: PPUSH
27837: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
27841: LD_EXP 62
27845: PPUSH
27846: LD_STRING D13-Kurt-3
27848: PPUSH
27849: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
27853: LD_EXP 40
27857: PPUSH
27858: LD_STRING D13-JMM-4
27860: PPUSH
27861: CALL_OW 88
// DialogueOff ;
27865: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
27869: LD_STRING MlegionOut
27871: PPUSH
27872: CALL_OW 337
// MC_Kill ( 3 ) ;
27876: LD_INT 3
27878: PPUSH
27879: CALL 38461 0 1
// KillUnit ( Kozlov ) ;
27883: LD_EXP 63
27887: PPUSH
27888: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
27892: LD_ADDR_VAR 0 1
27896: PUSH
27897: LD_INT 22
27899: PUSH
27900: LD_INT 8
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 23
27909: PUSH
27910: LD_INT 3
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 3
27919: PUSH
27920: LD_INT 21
27922: PUSH
27923: LD_INT 33
27925: PUSH
27926: EMPTY
27927: LIST
27928: LIST
27929: PUSH
27930: EMPTY
27931: LIST
27932: LIST
27933: PUSH
27934: EMPTY
27935: LIST
27936: LIST
27937: LIST
27938: PPUSH
27939: CALL_OW 69
27943: PUSH
27944: FOR_IN
27945: IFFALSE 27958
// KillUnit ( i ) ;
27947: LD_VAR 0 1
27951: PPUSH
27952: CALL_OW 66
27956: GO 27944
27958: POP
27959: POP
// ChangeSideFog ( 8 , 1 ) ;
27960: LD_INT 8
27962: PPUSH
27963: LD_INT 1
27965: PPUSH
27966: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
27970: LD_ADDR_VAR 0 2
27974: PUSH
27975: LD_INT 22
27977: PUSH
27978: LD_INT 8
27980: PUSH
27981: EMPTY
27982: LIST
27983: LIST
27984: PUSH
27985: LD_INT 21
27987: PUSH
27988: LD_INT 1
27990: PUSH
27991: EMPTY
27992: LIST
27993: LIST
27994: PUSH
27995: EMPTY
27996: LIST
27997: LIST
27998: PPUSH
27999: CALL_OW 69
28003: PUSH
28004: LD_EXP 63
28008: PUSH
28009: LD_EXP 62
28013: PUSH
28014: EMPTY
28015: LIST
28016: LIST
28017: DIFF
28018: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
28019: LD_VAR 0 2
28023: PUSH
28024: LD_INT 6
28026: PUSH
28027: LD_INT 5
28029: PUSH
28030: LD_INT 4
28032: PUSH
28033: LD_INT 3
28035: PUSH
28036: EMPTY
28037: LIST
28038: LIST
28039: LIST
28040: LIST
28041: PUSH
28042: LD_OWVAR 67
28046: ARRAY
28047: GREATEREQUAL
28048: IFFALSE 28200
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
28050: LD_ADDR_VAR 0 3
28054: PUSH
28055: LD_INT 6
28057: PUSH
28058: LD_INT 5
28060: PUSH
28061: LD_INT 4
28063: PUSH
28064: LD_INT 3
28066: PUSH
28067: EMPTY
28068: LIST
28069: LIST
28070: LIST
28071: LIST
28072: PUSH
28073: LD_OWVAR 67
28077: ARRAY
28078: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
28079: LD_ADDR_VAR 0 1
28083: PUSH
28084: DOUBLE
28085: LD_VAR 0 2
28089: PUSH
28090: LD_VAR 0 3
28094: PUSH
28095: LD_INT 1
28097: PLUS
28098: MINUS
28099: INC
28100: ST_TO_ADDR
28101: LD_INT 1
28103: PUSH
28104: FOR_DOWNTO
28105: IFFALSE 28196
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
28107: LD_ADDR_EXP 38
28111: PUSH
28112: LD_EXP 38
28116: PUSH
28117: LD_VAR 0 2
28121: PUSH
28122: LD_VAR 0 1
28126: ARRAY
28127: ADD
28128: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
28129: LD_VAR 0 2
28133: PUSH
28134: LD_VAR 0 1
28138: ARRAY
28139: PPUSH
28140: CALL_OW 310
28144: IFFALSE 28161
// ComExit ( tmp [ i ] ) ;
28146: LD_VAR 0 2
28150: PUSH
28151: LD_VAR 0 1
28155: ARRAY
28156: PPUSH
28157: CALL 106588 0 1
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
28161: LD_VAR 0 2
28165: PUSH
28166: LD_VAR 0 1
28170: ARRAY
28171: PPUSH
28172: LD_INT 34
28174: PUSH
28175: LD_INT 0
28177: PPUSH
28178: LD_INT 6
28180: PPUSH
28181: CALL_OW 12
28185: PLUS
28186: PPUSH
28187: LD_INT 1
28189: PPUSH
28190: CALL_OW 171
// end ;
28194: GO 28104
28196: POP
28197: POP
// end else
28198: GO 28210
// x := tmp ;
28200: LD_ADDR_VAR 0 3
28204: PUSH
28205: LD_VAR 0 2
28209: ST_TO_ADDR
// for i := tmp downto tmp - x do
28210: LD_ADDR_VAR 0 1
28214: PUSH
28215: DOUBLE
28216: LD_VAR 0 2
28220: INC
28221: ST_TO_ADDR
28222: LD_VAR 0 2
28226: PUSH
28227: LD_VAR 0 3
28231: MINUS
28232: PUSH
28233: FOR_DOWNTO
28234: IFFALSE 28306
// begin if IsInUnit ( tmp [ i ] ) then
28236: LD_VAR 0 2
28240: PUSH
28241: LD_VAR 0 1
28245: ARRAY
28246: PPUSH
28247: CALL_OW 310
28251: IFFALSE 28268
// ComExit ( tmp [ i ] ) ;
28253: LD_VAR 0 2
28257: PUSH
28258: LD_VAR 0 1
28262: ARRAY
28263: PPUSH
28264: CALL 106588 0 1
// SetSide ( tmp [ i ] , 1 ) ;
28268: LD_VAR 0 2
28272: PUSH
28273: LD_VAR 0 1
28277: ARRAY
28278: PPUSH
28279: LD_INT 1
28281: PPUSH
28282: CALL_OW 235
// SetLives ( tmp [ i ] , 1000 ) ;
28286: LD_VAR 0 2
28290: PUSH
28291: LD_VAR 0 1
28295: ARRAY
28296: PPUSH
28297: LD_INT 1000
28299: PPUSH
28300: CALL_OW 234
// end ;
28304: GO 28233
28306: POP
28307: POP
// wait ( 0 0$0.3 ) ;
28308: LD_INT 10
28310: PPUSH
28311: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_vehicle ] ] ) do
28315: LD_ADDR_VAR 0 1
28319: PUSH
28320: LD_INT 22
28322: PUSH
28323: LD_INT 8
28325: PUSH
28326: EMPTY
28327: LIST
28328: LIST
28329: PUSH
28330: LD_INT 21
28332: PUSH
28333: LD_INT 2
28335: PUSH
28336: EMPTY
28337: LIST
28338: LIST
28339: PUSH
28340: EMPTY
28341: LIST
28342: LIST
28343: PPUSH
28344: CALL_OW 69
28348: PUSH
28349: FOR_IN
28350: IFFALSE 28363
// KillUnit ( i ) ;
28352: LD_VAR 0 1
28356: PPUSH
28357: CALL_OW 66
28361: GO 28349
28363: POP
28364: POP
// SetSide ( Kurt , 1 ) ;
28365: LD_EXP 62
28369: PPUSH
28370: LD_INT 1
28372: PPUSH
28373: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
28377: LD_INT 22
28379: PUSH
28380: LD_INT 8
28382: PUSH
28383: EMPTY
28384: LIST
28385: LIST
28386: PUSH
28387: LD_INT 21
28389: PUSH
28390: LD_INT 3
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: PUSH
28397: EMPTY
28398: LIST
28399: LIST
28400: PPUSH
28401: CALL_OW 69
28405: PPUSH
28406: LD_INT 1
28408: PPUSH
28409: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
28413: LD_INT 8
28415: PPUSH
28416: LD_INT 1
28418: PPUSH
28419: LD_INT 1
28421: PPUSH
28422: LD_INT 1
28424: PPUSH
28425: CALL_OW 80
// wait ( 1 1$20 ) ;
28429: LD_INT 2800
28431: PPUSH
28432: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
28436: LD_EXP 64
28440: PPUSH
28441: LD_INT 37
28443: PPUSH
28444: LD_INT 1
28446: PPUSH
28447: LD_INT 0
28449: PPUSH
28450: CALL_OW 48
// wait ( 0 0$1 ) ;
28454: LD_INT 35
28456: PPUSH
28457: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
28461: LD_EXP 64
28465: PPUSH
28466: LD_INT 60
28468: PPUSH
28469: LD_INT 95
28471: PPUSH
28472: CALL_OW 111
// end ;
28476: PPOPN 3
28478: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
28479: LD_EXP 22
28483: NOT
28484: PUSH
28485: LD_INT 22
28487: PUSH
28488: LD_INT 8
28490: PUSH
28491: EMPTY
28492: LIST
28493: LIST
28494: PUSH
28495: LD_INT 21
28497: PUSH
28498: LD_INT 1
28500: PUSH
28501: EMPTY
28502: LIST
28503: LIST
28504: PUSH
28505: EMPTY
28506: LIST
28507: LIST
28508: PPUSH
28509: CALL_OW 69
28513: PUSH
28514: LD_INT 0
28516: EQUAL
28517: AND
28518: IFFALSE 28538
28520: GO 28522
28522: DISABLE
// begin legionDestroyed := true ;
28523: LD_ADDR_EXP 22
28527: PUSH
28528: LD_INT 1
28530: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
28531: LD_STRING MlegionOut
28533: PPUSH
28534: CALL_OW 337
// end ;
28538: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
28539: LD_EXP 38
28543: IFFALSE 28618
28545: GO 28547
28547: DISABLE
28548: LD_INT 0
28550: PPUSH
// begin enable ;
28551: ENABLE
// for i in legionEscapeUnits do
28552: LD_ADDR_VAR 0 1
28556: PUSH
28557: LD_EXP 38
28561: PUSH
28562: FOR_IN
28563: IFFALSE 28616
// begin if IsInArea ( i , legionEscapeArea ) then
28565: LD_VAR 0 1
28569: PPUSH
28570: LD_INT 31
28572: PPUSH
28573: CALL_OW 308
28577: IFFALSE 28590
// RemoveUnit ( i ) else
28579: LD_VAR 0 1
28583: PPUSH
28584: CALL_OW 64
28588: GO 28614
// if not HasTask ( i ) then
28590: LD_VAR 0 1
28594: PPUSH
28595: CALL_OW 314
28599: NOT
28600: IFFALSE 28614
// ComMoveToArea ( i , legionEscapeArea ) ;
28602: LD_VAR 0 1
28606: PPUSH
28607: LD_INT 31
28609: PPUSH
28610: CALL_OW 113
// end ;
28614: GO 28562
28616: POP
28617: POP
// end ;
28618: PPOPN 1
28620: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
28621: LD_INT 1
28623: PPUSH
28624: LD_EXP 64
28628: PPUSH
28629: CALL_OW 292
28633: IFFALSE 28931
28635: GO 28637
28637: DISABLE
28638: LD_INT 0
28640: PPUSH
// begin wait ( 0 0$2 ) ;
28641: LD_INT 70
28643: PPUSH
28644: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28648: LD_EXP 64
28652: PPUSH
28653: CALL_OW 87
// DialogueOn ;
28657: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
28661: LD_EXP 40
28665: PPUSH
28666: LD_STRING D14-JMM-1
28668: PPUSH
28669: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
28673: LD_EXP 64
28677: PPUSH
28678: LD_STRING D14-Friend-1
28680: PPUSH
28681: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
28685: LD_EXP 40
28689: PPUSH
28690: LD_STRING D14-JMM-2
28692: PPUSH
28693: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
28697: LD_EXP 64
28701: PPUSH
28702: LD_STRING D14-Friend-2
28704: PPUSH
28705: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
28709: LD_EXP 40
28713: PPUSH
28714: LD_STRING D14-JMM-3
28716: PPUSH
28717: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
28721: LD_EXP 64
28725: PPUSH
28726: LD_STRING D14-Friend-3
28728: PPUSH
28729: CALL_OW 88
// DialogueOff ;
28733: CALL_OW 7
// dec := Query ( Q14 ) ;
28737: LD_ADDR_VAR 0 1
28741: PUSH
28742: LD_STRING Q14
28744: PPUSH
28745: CALL_OW 97
28749: ST_TO_ADDR
// if dec = 1 then
28750: LD_VAR 0 1
28754: PUSH
28755: LD_INT 1
28757: EQUAL
28758: IFFALSE 28792
// begin DialogueOn ;
28760: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
28764: LD_EXP 40
28768: PPUSH
28769: LD_STRING D14a-JMM-1
28771: PPUSH
28772: CALL_OW 88
// DialogueOff ;
28776: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28780: LD_EXP 64
28784: PPUSH
28785: LD_INT 1
28787: PPUSH
28788: CALL_OW 235
// end ; if dec = 2 then
28792: LD_VAR 0 1
28796: PUSH
28797: LD_INT 2
28799: EQUAL
28800: IFFALSE 28853
// begin DialogueOn ;
28802: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
28806: LD_EXP 40
28810: PPUSH
28811: LD_STRING D14b-JMM-1
28813: PPUSH
28814: CALL_OW 88
// DialogueOff ;
28818: CALL_OW 7
// wait ( 0 0$1 ) ;
28822: LD_INT 35
28824: PPUSH
28825: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
28829: LD_EXP 64
28833: PPUSH
28834: LD_INT 9
28836: PPUSH
28837: LD_INT 2
28839: PPUSH
28840: CALL_OW 111
// AddComHold ( Friend ) ;
28844: LD_EXP 64
28848: PPUSH
28849: CALL_OW 200
// end ; if dec = 3 then
28853: LD_VAR 0 1
28857: PUSH
28858: LD_INT 3
28860: EQUAL
28861: IFFALSE 28931
// begin DialogueOn ;
28863: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
28867: LD_EXP 40
28871: PPUSH
28872: LD_STRING D14c-JMM-1
28874: PPUSH
28875: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
28879: LD_EXP 64
28883: PPUSH
28884: LD_STRING D14c-Friend-1
28886: PPUSH
28887: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
28891: LD_EXP 40
28895: PPUSH
28896: LD_STRING D14c-JMM-2
28898: PPUSH
28899: CALL_OW 88
// DialogueOff ;
28903: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
28907: LD_EXP 64
28911: PPUSH
28912: LD_INT 9
28914: PPUSH
28915: LD_INT 2
28917: PPUSH
28918: CALL_OW 111
// AddComHold ( Friend ) ;
28922: LD_EXP 64
28926: PPUSH
28927: CALL_OW 200
// end ; end ;
28931: PPOPN 1
28933: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
28934: LD_INT 9
28936: PPUSH
28937: LD_INT 2
28939: PPUSH
28940: CALL_OW 428
28944: PUSH
28945: LD_EXP 64
28949: EQUAL
28950: PUSH
28951: LD_EXP 64
28955: PPUSH
28956: CALL_OW 255
28960: PUSH
28961: LD_INT 8
28963: EQUAL
28964: AND
28965: IFFALSE 28979
28967: GO 28969
28969: DISABLE
// RemoveUnit ( Friend ) ;
28970: LD_EXP 64
28974: PPUSH
28975: CALL_OW 64
28979: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
28980: LD_EXP 14
28984: PUSH
28985: LD_INT 31500
28987: GREATEREQUAL
28988: PUSH
28989: LD_EXP 7
28993: AND
28994: PUSH
28995: LD_EXP 2
28999: AND
29000: IFFALSE 29430
29002: GO 29004
29004: DISABLE
29005: LD_INT 0
29007: PPUSH
29008: PPUSH
29009: PPUSH
// begin missionStage := 7 ;
29010: LD_ADDR_EXP 15
29014: PUSH
29015: LD_INT 7
29017: ST_TO_ADDR
// uc_side = 1 ;
29018: LD_ADDR_OWVAR 20
29022: PUSH
29023: LD_INT 1
29025: ST_TO_ADDR
// uc_nation = 1 ;
29026: LD_ADDR_OWVAR 21
29030: PUSH
29031: LD_INT 1
29033: ST_TO_ADDR
// for i = 1 to 5 do
29034: LD_ADDR_VAR 0 1
29038: PUSH
29039: DOUBLE
29040: LD_INT 1
29042: DEC
29043: ST_TO_ADDR
29044: LD_INT 5
29046: PUSH
29047: FOR_TO
29048: IFFALSE 29144
// begin vc_engine = 3 ;
29050: LD_ADDR_OWVAR 39
29054: PUSH
29055: LD_INT 3
29057: ST_TO_ADDR
// vc_control = 3 ;
29058: LD_ADDR_OWVAR 38
29062: PUSH
29063: LD_INT 3
29065: ST_TO_ADDR
// vc_chassis = 3 ;
29066: LD_ADDR_OWVAR 37
29070: PUSH
29071: LD_INT 3
29073: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29074: LD_ADDR_OWVAR 40
29078: PUSH
29079: LD_INT 5
29081: PUSH
29082: LD_INT 9
29084: PUSH
29085: LD_INT 7
29087: PUSH
29088: EMPTY
29089: LIST
29090: LIST
29091: LIST
29092: PUSH
29093: LD_INT 1
29095: PPUSH
29096: LD_INT 3
29098: PPUSH
29099: CALL_OW 12
29103: ARRAY
29104: ST_TO_ADDR
// veh = CreateVehicle ;
29105: LD_ADDR_VAR 0 2
29109: PUSH
29110: CALL_OW 45
29114: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29115: LD_VAR 0 2
29119: PPUSH
29120: LD_INT 1
29122: PPUSH
29123: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29127: LD_VAR 0 2
29131: PPUSH
29132: LD_INT 19
29134: PPUSH
29135: LD_INT 0
29137: PPUSH
29138: CALL_OW 49
// end ;
29142: GO 29047
29144: POP
29145: POP
// vc_engine = 3 ;
29146: LD_ADDR_OWVAR 39
29150: PUSH
29151: LD_INT 3
29153: ST_TO_ADDR
// vc_control = 1 ;
29154: LD_ADDR_OWVAR 38
29158: PUSH
29159: LD_INT 1
29161: ST_TO_ADDR
// vc_chassis = 3 ;
29162: LD_ADDR_OWVAR 37
29166: PUSH
29167: LD_INT 3
29169: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
29170: LD_ADDR_OWVAR 40
29174: PUSH
29175: LD_INT 5
29177: PUSH
29178: LD_INT 9
29180: PUSH
29181: LD_INT 7
29183: PUSH
29184: EMPTY
29185: LIST
29186: LIST
29187: LIST
29188: PUSH
29189: LD_INT 1
29191: PPUSH
29192: LD_INT 3
29194: PPUSH
29195: CALL_OW 12
29199: ARRAY
29200: ST_TO_ADDR
// vehG = CreateVehicle ;
29201: LD_ADDR_VAR 0 3
29205: PUSH
29206: CALL_OW 45
29210: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
29211: LD_VAR 0 3
29215: PPUSH
29216: LD_INT 1
29218: PPUSH
29219: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
29223: LD_VAR 0 3
29227: PPUSH
29228: LD_INT 19
29230: PPUSH
29231: LD_INT 0
29233: PPUSH
29234: CALL_OW 49
// if JMMGirl = 1 then
29238: LD_EXP 7
29242: PUSH
29243: LD_INT 1
29245: EQUAL
29246: IFFALSE 29302
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
29248: LD_ADDR_EXP 41
29252: PUSH
29253: LD_STRING Joan
29255: PPUSH
29256: LD_INT 1
29258: PPUSH
29259: LD_STRING 14_
29261: PPUSH
29262: CALL 68898 0 3
29266: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
29267: LD_EXP 41
29271: PPUSH
29272: LD_VAR 0 3
29276: PPUSH
29277: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29281: LD_VAR 0 3
29285: PPUSH
29286: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
29290: LD_EXP 41
29294: PPUSH
29295: LD_STRING D10BW-Joan-1
29297: PPUSH
29298: CALL_OW 94
// end ; if JMMGirl = 2 then
29302: LD_EXP 7
29306: PUSH
29307: LD_INT 2
29309: EQUAL
29310: IFFALSE 29366
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
29312: LD_ADDR_EXP 43
29316: PUSH
29317: LD_STRING Lisa
29319: PPUSH
29320: LD_INT 1
29322: PPUSH
29323: LD_STRING 14_
29325: PPUSH
29326: CALL 68898 0 3
29330: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
29331: LD_EXP 43
29335: PPUSH
29336: LD_VAR 0 3
29340: PPUSH
29341: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29345: LD_VAR 0 3
29349: PPUSH
29350: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
29354: LD_EXP 43
29358: PPUSH
29359: LD_STRING D10BW-Lisa-1
29361: PPUSH
29362: CALL_OW 94
// end ; if JMMGirl = 3 then
29366: LD_EXP 7
29370: PUSH
29371: LD_INT 3
29373: EQUAL
29374: IFFALSE 29430
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
29376: LD_ADDR_EXP 55
29380: PUSH
29381: LD_STRING Connie
29383: PPUSH
29384: LD_INT 1
29386: PPUSH
29387: LD_STRING 14_
29389: PPUSH
29390: CALL 68898 0 3
29394: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
29395: LD_EXP 55
29399: PPUSH
29400: LD_VAR 0 3
29404: PPUSH
29405: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
29409: LD_VAR 0 3
29413: PPUSH
29414: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
29418: LD_EXP 55
29422: PPUSH
29423: LD_STRING D10BW-Con-1
29425: PPUSH
29426: CALL_OW 94
// end ; end ;
29430: PPOPN 3
29432: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
29433: LD_EXP 14
29437: PUSH
29438: LD_INT 94500
29440: GREATEREQUAL
29441: IFFALSE 29853
29443: GO 29445
29445: DISABLE
29446: LD_INT 0
29448: PPUSH
29449: PPUSH
29450: PPUSH
// begin tmp := PrepareStevensSquad ;
29451: LD_ADDR_VAR 0 3
29455: PUSH
29456: CALL 2323 0 0
29460: ST_TO_ADDR
// if not tmp then
29461: LD_VAR 0 3
29465: NOT
29466: IFFALSE 29470
// exit ;
29468: GO 29853
// uc_side := 1 ;
29470: LD_ADDR_OWVAR 20
29474: PUSH
29475: LD_INT 1
29477: ST_TO_ADDR
// uc_nation := 1 ;
29478: LD_ADDR_OWVAR 21
29482: PUSH
29483: LD_INT 1
29485: ST_TO_ADDR
// for i in tmp do
29486: LD_ADDR_VAR 0 1
29490: PUSH
29491: LD_VAR 0 3
29495: PUSH
29496: FOR_IN
29497: IFFALSE 29594
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
29499: LD_INT 3
29501: PPUSH
29502: LD_INT 3
29504: PPUSH
29505: LD_INT 1
29507: PPUSH
29508: LD_INT 5
29510: PUSH
29511: LD_INT 9
29513: PUSH
29514: LD_INT 7
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: LIST
29521: PUSH
29522: LD_INT 1
29524: PPUSH
29525: LD_INT 3
29527: PPUSH
29528: CALL_OW 12
29532: ARRAY
29533: PPUSH
29534: LD_INT 40
29536: PPUSH
29537: CALL 73738 0 5
// veh := CreateVehicle ;
29541: LD_ADDR_VAR 0 2
29545: PUSH
29546: CALL_OW 45
29550: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
29551: LD_VAR 0 2
29555: PPUSH
29556: LD_INT 1
29558: PPUSH
29559: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
29563: LD_VAR 0 2
29567: PPUSH
29568: LD_INT 19
29570: PPUSH
29571: LD_INT 0
29573: PPUSH
29574: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
29578: LD_VAR 0 1
29582: PPUSH
29583: LD_VAR 0 2
29587: PPUSH
29588: CALL_OW 52
// end ;
29592: GO 29496
29594: POP
29595: POP
// missionStage := 8 ;
29596: LD_ADDR_EXP 15
29600: PUSH
29601: LD_INT 8
29603: ST_TO_ADDR
// DialogueOn ;
29604: CALL_OW 6
// if Stevens then
29608: LD_EXP 42
29612: IFFALSE 29726
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
29614: LD_EXP 42
29618: PPUSH
29619: CALL_OW 310
29623: PPUSH
29624: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
29628: LD_EXP 42
29632: PPUSH
29633: LD_STRING D8-Huck-1
29635: PPUSH
29636: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
29640: LD_EXP 40
29644: PPUSH
29645: LD_STRING D8-JMM-1
29647: PPUSH
29648: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
29652: LD_EXP 42
29656: PPUSH
29657: LD_STRING D8-Huck-2
29659: PPUSH
29660: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
29664: LD_EXP 40
29668: PPUSH
29669: LD_STRING D8-JMM-2
29671: PPUSH
29672: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
29676: LD_EXP 42
29680: PPUSH
29681: LD_STRING D8-Huck-3
29683: PPUSH
29684: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
29688: LD_EXP 40
29692: PPUSH
29693: LD_STRING D8-JMM-3
29695: PPUSH
29696: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
29700: LD_EXP 42
29704: PPUSH
29705: LD_STRING D8-Huck-4
29707: PPUSH
29708: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
29712: LD_EXP 40
29716: PPUSH
29717: LD_STRING D8-JMM-4
29719: PPUSH
29720: CALL_OW 88
// end else
29724: GO 29836
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
29726: LD_EXP 56
29730: PPUSH
29731: CALL_OW 310
29735: PPUSH
29736: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
29740: LD_EXP 56
29744: PPUSH
29745: LD_STRING D8-Huck-1
29747: PPUSH
29748: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
29752: LD_EXP 40
29756: PPUSH
29757: LD_STRING D8-JMM-1a
29759: PPUSH
29760: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
29764: LD_EXP 56
29768: PPUSH
29769: LD_STRING D8-Huck-2
29771: PPUSH
29772: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
29776: LD_EXP 40
29780: PPUSH
29781: LD_STRING D8-JMM-2
29783: PPUSH
29784: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
29788: LD_EXP 56
29792: PPUSH
29793: LD_STRING D8-Huck-3
29795: PPUSH
29796: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
29800: LD_EXP 40
29804: PPUSH
29805: LD_STRING D8-JMM-3
29807: PPUSH
29808: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
29812: LD_EXP 56
29816: PPUSH
29817: LD_STRING D8-Huck-4
29819: PPUSH
29820: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
29824: LD_EXP 40
29828: PPUSH
29829: LD_STRING D8-JMM-4
29831: PPUSH
29832: CALL_OW 88
// end ; DialogueOff ;
29836: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
29840: LD_INT 25
29842: PPUSH
29843: LD_INT 1
29845: PPUSH
29846: LD_INT 1
29848: PPUSH
29849: CALL_OW 322
// end ;
29853: PPOPN 3
29855: END
// every 0 0$1 trigger IsOk ( sewiVeh ) and See ( 1 , sewiVeh ) do
29856: LD_EXP 73
29860: PPUSH
29861: CALL_OW 302
29865: PUSH
29866: LD_INT 1
29868: PPUSH
29869: LD_EXP 73
29873: PPUSH
29874: CALL_OW 292
29878: AND
29879: IFFALSE 30130
29881: GO 29883
29883: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
29884: LD_EXP 73
29888: PPUSH
29889: CALL_OW 87
// DialogueOn ;
29893: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
29897: LD_EXP 40
29901: PPUSH
29902: LD_STRING D10nB-JMM-1
29904: PPUSH
29905: CALL_OW 88
// if BurlakStatus = 1 then
29909: LD_EXP 9
29913: PUSH
29914: LD_INT 1
29916: EQUAL
29917: IFFALSE 29931
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
29919: LD_EXP 72
29923: PPUSH
29924: LD_STRING D10nB-Vse-1a
29926: PPUSH
29927: CALL_OW 94
// end ; if BurlakStatus = 0 then
29931: LD_EXP 9
29935: PUSH
29936: LD_INT 0
29938: EQUAL
29939: IFFALSE 29953
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
29941: LD_EXP 72
29945: PPUSH
29946: LD_STRING D10nB-Vse-1
29948: PPUSH
29949: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
29953: LD_EXP 40
29957: PPUSH
29958: LD_STRING D10nB-JMM-2
29960: PPUSH
29961: CALL_OW 88
// if KappaStatus then
29965: LD_EXP 2
29969: IFFALSE 29983
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
29971: LD_EXP 72
29975: PPUSH
29976: LD_STRING D10nB-Vse-5a
29978: PPUSH
29979: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
29983: LD_EXP 2
29987: NOT
29988: PUSH
29989: LD_EXP 6
29993: PUSH
29994: LD_INT 0
29996: EQUAL
29997: AND
29998: IFFALSE 30126
// begin if JMMGirl = 1 then
30000: LD_EXP 7
30004: PUSH
30005: LD_INT 1
30007: EQUAL
30008: IFFALSE 30058
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
30010: LD_EXP 72
30014: PPUSH
30015: LD_STRING D10nB-Vse-2
30017: PPUSH
30018: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
30022: LD_EXP 40
30026: PPUSH
30027: LD_STRING D10nB-JMM-3
30029: PPUSH
30030: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
30034: LD_EXP 72
30038: PPUSH
30039: LD_STRING D10nB-Vse-3
30041: PPUSH
30042: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
30046: LD_EXP 40
30050: PPUSH
30051: LD_STRING D10nB-JMM-4
30053: PPUSH
30054: CALL_OW 88
// end ; if JMMGirl = 2 then
30058: LD_EXP 7
30062: PUSH
30063: LD_INT 2
30065: EQUAL
30066: IFFALSE 30092
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
30068: LD_EXP 72
30072: PPUSH
30073: LD_STRING D10nB-Vse-4
30075: PPUSH
30076: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
30080: LD_EXP 40
30084: PPUSH
30085: LD_STRING D10nB-JMM-5
30087: PPUSH
30088: CALL_OW 88
// end ; if JMMGirl = 3 then
30092: LD_EXP 7
30096: PUSH
30097: LD_INT 3
30099: EQUAL
30100: IFFALSE 30126
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
30102: LD_EXP 72
30106: PPUSH
30107: LD_STRING D10nB-Vse-5
30109: PPUSH
30110: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
30114: LD_EXP 40
30118: PPUSH
30119: LD_STRING D10nB-JMM-6
30121: PPUSH
30122: CALL_OW 88
// end ; end ; DialogueOff ;
30126: CALL_OW 7
// end ;
30130: END
// every 0 0$1 trigger missionTime >= 55 55$00 and IsOk ( Kovalyuk ) and IsOk ( ru_depot2 ) do var tmp ;
30131: LD_EXP 14
30135: PUSH
30136: LD_INT 115500
30138: GREATEREQUAL
30139: PUSH
30140: LD_EXP 67
30144: PPUSH
30145: CALL_OW 302
30149: AND
30150: PUSH
30151: LD_INT 267
30153: PPUSH
30154: CALL_OW 302
30158: AND
30159: IFFALSE 30535
30161: GO 30163
30163: DISABLE
30164: LD_INT 0
30166: PPUSH
// begin missionStage := 10 ;
30167: LD_ADDR_EXP 15
30171: PUSH
30172: LD_INT 10
30174: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
30175: LD_ADDR_VAR 0 1
30179: PUSH
30180: LD_INT 22
30182: PUSH
30183: LD_INT 1
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 23
30192: PUSH
30193: LD_INT 1
30195: PUSH
30196: EMPTY
30197: LIST
30198: LIST
30199: PUSH
30200: LD_INT 26
30202: PUSH
30203: LD_INT 1
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 3
30212: PUSH
30213: LD_INT 25
30215: PUSH
30216: LD_INT 12
30218: PUSH
30219: EMPTY
30220: LIST
30221: LIST
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 3
30229: PUSH
30230: LD_INT 25
30232: PUSH
30233: LD_INT 16
30235: PUSH
30236: EMPTY
30237: LIST
30238: LIST
30239: PUSH
30240: EMPTY
30241: LIST
30242: LIST
30243: PUSH
30244: EMPTY
30245: LIST
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: PPUSH
30251: CALL_OW 69
30255: PUSH
30256: LD_EXP 40
30260: PUSH
30261: LD_EXP 62
30265: PUSH
30266: LD_EXP 42
30270: PUSH
30271: LD_EXP 56
30275: PUSH
30276: LD_EXP 43
30280: PUSH
30281: LD_EXP 44
30285: PUSH
30286: LD_EXP 45
30290: PUSH
30291: LD_EXP 46
30295: PUSH
30296: LD_EXP 47
30300: PUSH
30301: LD_EXP 48
30305: PUSH
30306: LD_EXP 49
30310: PUSH
30311: LD_EXP 50
30315: PUSH
30316: LD_EXP 51
30320: PUSH
30321: LD_EXP 52
30325: PUSH
30326: LD_EXP 53
30330: PUSH
30331: LD_EXP 54
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: LIST
30343: LIST
30344: LIST
30345: LIST
30346: LIST
30347: LIST
30348: LIST
30349: LIST
30350: LIST
30351: LIST
30352: LIST
30353: DIFF
30354: ST_TO_ADDR
// if not tmp and Brown then
30355: LD_VAR 0 1
30359: NOT
30360: PUSH
30361: LD_EXP 48
30365: AND
30366: IFFALSE 30381
// tmp := [ Brown ] ;
30368: LD_ADDR_VAR 0 1
30372: PUSH
30373: LD_EXP 48
30377: PUSH
30378: EMPTY
30379: LIST
30380: ST_TO_ADDR
// DialogueOn ;
30381: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
30385: LD_VAR 0 1
30389: PUSH
30390: LD_INT 1
30392: ARRAY
30393: PPUSH
30394: LD_STRING D11-Sol1-1
30396: PPUSH
30397: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
30401: LD_EXP 66
30405: PPUSH
30406: LD_STRING D11-Pla-1
30408: PPUSH
30409: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
30413: LD_EXP 67
30417: PPUSH
30418: LD_STRING D11-Kov-1
30420: PPUSH
30421: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
30425: LD_EXP 66
30429: PPUSH
30430: LD_STRING D11-Pla-2
30432: PPUSH
30433: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
30437: LD_VAR 0 1
30441: PUSH
30442: LD_INT 1
30444: ARRAY
30445: PPUSH
30446: LD_STRING D11-Sol1-2
30448: PPUSH
30449: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
30453: LD_EXP 40
30457: PPUSH
30458: LD_STRING D11-JMM-2
30460: PPUSH
30461: CALL_OW 88
// DialogueOff ;
30465: CALL_OW 7
// allowBehemothConstruct := true ;
30469: LD_ADDR_EXP 25
30473: PUSH
30474: LD_INT 1
30476: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
30477: LD_STRING M4
30479: PPUSH
30480: CALL_OW 337
// BuildBehemoths ;
30484: CALL 8096 0 0
// repeat wait ( 15 15$00 ) ;
30488: LD_INT 31500
30490: PPUSH
30491: CALL_OW 67
// if behemothDestroyedBeforeFinish then
30495: LD_EXP 27
30499: IFFALSE 30503
// break ;
30501: GO 30535
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
30503: LD_INT 267
30505: PPUSH
30506: CALL_OW 274
30510: PPUSH
30511: LD_INT 1
30513: PPUSH
30514: CALL_OW 275
30518: PUSH
30519: LD_INT 1000
30521: GREATEREQUAL
30522: IFFALSE 30528
// BuildBehemoths ;
30524: CALL 8096 0 0
// until not behemothBuilders ;
30528: LD_EXP 75
30532: NOT
30533: IFFALSE 30488
// end ;
30535: PPOPN 1
30537: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
30538: LD_EXP 75
30542: NOT
30543: PUSH
30544: LD_EXP 28
30548: NOT
30549: AND
30550: PUSH
30551: LD_EXP 25
30555: AND
30556: IFFALSE 30576
30558: GO 30560
30560: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
30561: LD_STRING M4a
30563: PPUSH
30564: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
30568: LD_ADDR_EXP 27
30572: PUSH
30573: LD_INT 1
30575: ST_TO_ADDR
// end ;
30576: END
// every 0 0$1 trigger behemothDone do
30577: LD_EXP 28
30581: IFFALSE 30593
30583: GO 30585
30585: DISABLE
// ChangeMissionObjectives ( M4b ) ;
30586: LD_STRING M4b
30588: PPUSH
30589: CALL_OW 337
30593: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
30594: LD_EXP 29
30598: NOT
30599: IFFALSE 30795
30601: GO 30603
30603: DISABLE
30604: LD_INT 0
30606: PPUSH
30607: PPUSH
// begin enable ;
30608: ENABLE
// tmp := GetBehemoths ( 3 ) ;
30609: LD_ADDR_VAR 0 1
30613: PUSH
30614: LD_INT 3
30616: PPUSH
30617: CALL 106251 0 1
30621: ST_TO_ADDR
// if not tmp and not behemothDone then
30622: LD_VAR 0 1
30626: NOT
30627: PUSH
30628: LD_EXP 28
30632: NOT
30633: AND
30634: IFFALSE 30670
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
30636: LD_ADDR_VAR 0 1
30640: PUSH
30641: LD_INT 22
30643: PUSH
30644: LD_INT 3
30646: PUSH
30647: EMPTY
30648: LIST
30649: LIST
30650: PUSH
30651: LD_INT 30
30653: PUSH
30654: LD_INT 37
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: PUSH
30661: EMPTY
30662: LIST
30663: LIST
30664: PPUSH
30665: CALL_OW 69
30669: ST_TO_ADDR
// if not tmp then
30670: LD_VAR 0 1
30674: NOT
30675: IFFALSE 30679
// exit ;
30677: GO 30795
// for i in tmp do
30679: LD_ADDR_VAR 0 2
30683: PUSH
30684: LD_VAR 0 1
30688: PUSH
30689: FOR_IN
30690: IFFALSE 30793
// if See ( 1 , i ) then
30692: LD_INT 1
30694: PPUSH
30695: LD_VAR 0 2
30699: PPUSH
30700: CALL_OW 292
30704: IFFALSE 30791
// begin if GetType ( i ) = unit_building then
30706: LD_VAR 0 2
30710: PPUSH
30711: CALL_OW 247
30715: PUSH
30716: LD_INT 3
30718: EQUAL
30719: IFFALSE 30757
// begin disable ;
30721: DISABLE
// CenterNowOnUnits ( i ) ;
30722: LD_VAR 0 2
30726: PPUSH
30727: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
30731: LD_EXP 40
30735: PPUSH
30736: LD_STRING D17a-JMM-1
30738: PPUSH
30739: CALL_OW 88
// seeBehemoth := true ;
30743: LD_ADDR_EXP 29
30747: PUSH
30748: LD_INT 1
30750: ST_TO_ADDR
// exit ;
30751: POP
30752: POP
30753: GO 30795
// end else
30755: GO 30791
// begin disable ;
30757: DISABLE
// CenterNowOnUnits ( i ) ;
30758: LD_VAR 0 2
30762: PPUSH
30763: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
30767: LD_EXP 40
30771: PPUSH
30772: LD_STRING D17b-JMM-1
30774: PPUSH
30775: CALL_OW 88
// seeBehemoth := true ;
30779: LD_ADDR_EXP 29
30783: PUSH
30784: LD_INT 1
30786: ST_TO_ADDR
// exit ;
30787: POP
30788: POP
30789: GO 30795
// end ; end ;
30791: GO 30689
30793: POP
30794: POP
// end ;
30795: PPOPN 2
30797: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
30798: LD_EXP 14
30802: PUSH
30803: LD_INT 123200
30805: GREATEREQUAL
30806: IFFALSE 32006
30808: GO 30810
30810: DISABLE
30811: LD_INT 0
30813: PPUSH
30814: PPUSH
30815: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
30816: LD_INT 2
30818: PPUSH
30819: LD_INT 23
30821: PUSH
30822: LD_INT 3
30824: PUSH
30825: LD_INT 3
30827: PUSH
30828: LD_INT 48
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: LIST
30835: LIST
30836: PUSH
30837: EMPTY
30838: LIST
30839: PPUSH
30840: CALL 62472 0 2
// repeat wait ( 0 0$1 ) ;
30844: LD_INT 35
30846: PPUSH
30847: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
30851: LD_INT 22
30853: PUSH
30854: LD_INT 3
30856: PUSH
30857: EMPTY
30858: LIST
30859: LIST
30860: PUSH
30861: LD_INT 34
30863: PUSH
30864: LD_INT 48
30866: PUSH
30867: EMPTY
30868: LIST
30869: LIST
30870: PUSH
30871: EMPTY
30872: LIST
30873: LIST
30874: PPUSH
30875: CALL_OW 69
30879: IFFALSE 30844
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
30881: LD_ADDR_VAR 0 1
30885: PUSH
30886: LD_INT 22
30888: PUSH
30889: LD_INT 3
30891: PUSH
30892: EMPTY
30893: LIST
30894: LIST
30895: PUSH
30896: LD_INT 34
30898: PUSH
30899: LD_INT 48
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: EMPTY
30907: LIST
30908: LIST
30909: PPUSH
30910: CALL_OW 69
30914: PUSH
30915: LD_INT 1
30917: ARRAY
30918: ST_TO_ADDR
// missionStage := 12 ;
30919: LD_ADDR_EXP 15
30923: PUSH
30924: LD_INT 12
30926: ST_TO_ADDR
// platonovHasBomb := true ;
30927: LD_ADDR_EXP 30
30931: PUSH
30932: LD_INT 1
30934: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
30935: LD_VAR 0 1
30939: PPUSH
30940: LD_INT 181
30942: PPUSH
30943: LD_INT 86
30945: PPUSH
30946: CALL_OW 171
// AddComHold ( bomb ) ;
30950: LD_VAR 0 1
30954: PPUSH
30955: CALL_OW 200
// wait ( 0 0$10 ) ;
30959: LD_INT 350
30961: PPUSH
30962: CALL_OW 67
// DialogueOn ;
30966: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
30970: LD_EXP 66
30974: PPUSH
30975: LD_STRING D15-Pla-1
30977: PPUSH
30978: CALL_OW 94
// dec := Query ( Q15a ) ;
30982: LD_ADDR_VAR 0 2
30986: PUSH
30987: LD_STRING Q15a
30989: PPUSH
30990: CALL_OW 97
30994: ST_TO_ADDR
// if dec = 1 then
30995: LD_VAR 0 2
30999: PUSH
31000: LD_INT 1
31002: EQUAL
31003: IFFALSE 31026
// begin Say ( JMM , D15a-JMM-1 ) ;
31005: LD_EXP 40
31009: PPUSH
31010: LD_STRING D15a-JMM-1
31012: PPUSH
31013: CALL_OW 88
// YouLost ( Surrender ) ;
31017: LD_STRING Surrender
31019: PPUSH
31020: CALL_OW 104
// exit ;
31024: GO 32006
// end ; if dec = 2 then
31026: LD_VAR 0 2
31030: PUSH
31031: LD_INT 2
31033: EQUAL
31034: IFFALSE 31103
// begin Say ( JMM , D15b-JMM-1 ) ;
31036: LD_EXP 40
31040: PPUSH
31041: LD_STRING D15b-JMM-1
31043: PPUSH
31044: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
31048: LD_EXP 66
31052: PPUSH
31053: LD_STRING D15b-Pla-1
31055: PPUSH
31056: CALL_OW 94
// DialogueOff ;
31060: CALL_OW 7
// wait ( 3 3$00 ) ;
31064: LD_INT 6300
31066: PPUSH
31067: CALL_OW 67
// DialogueOn ;
31071: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
31075: LD_EXP 40
31079: PPUSH
31080: LD_STRING D15d-JMM-1a
31082: PPUSH
31083: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31087: LD_EXP 66
31091: PPUSH
31092: LD_STRING D15d-Pla-1
31094: PPUSH
31095: CALL_OW 94
// DialogueOff ;
31099: CALL_OW 7
// end ; if dec = 3 then
31103: LD_VAR 0 2
31107: PUSH
31108: LD_INT 3
31110: EQUAL
31111: IFFALSE 31165
// begin Say ( JMM , D15c-JMM-1 ) ;
31113: LD_EXP 40
31117: PPUSH
31118: LD_STRING D15c-JMM-1
31120: PPUSH
31121: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
31125: LD_EXP 66
31129: PPUSH
31130: LD_STRING D15c-Pla-1
31132: PPUSH
31133: CALL_OW 94
// DialogueOff ;
31137: CALL_OW 7
// wait ( 0 0$15 ) ;
31141: LD_INT 525
31143: PPUSH
31144: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
31148: LD_VAR 0 1
31152: PPUSH
31153: LD_INT 60
31155: PPUSH
31156: LD_INT 95
31158: PPUSH
31159: CALL_OW 116
// exit ;
31163: GO 32006
// end ; if dec = 4 then
31165: LD_VAR 0 2
31169: PUSH
31170: LD_INT 4
31172: EQUAL
31173: IFFALSE 31203
// begin Say ( JMM , D15d-JMM-1 ) ;
31175: LD_EXP 40
31179: PPUSH
31180: LD_STRING D15d-JMM-1
31182: PPUSH
31183: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
31187: LD_EXP 66
31191: PPUSH
31192: LD_STRING D15d-Pla-1
31194: PPUSH
31195: CALL_OW 94
// DialogueOff ;
31199: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31203: LD_EXP 64
31207: PPUSH
31208: CALL_OW 302
31212: PUSH
31213: LD_EXP 64
31217: PPUSH
31218: CALL_OW 255
31222: PUSH
31223: LD_INT 1
31225: EQUAL
31226: AND
31227: PUSH
31228: LD_INT 22
31230: PUSH
31231: LD_INT 1
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: PUSH
31238: LD_INT 34
31240: PUSH
31241: LD_INT 8
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PPUSH
31252: CALL_OW 69
31256: NOT
31257: AND
31258: IFFALSE 31907
// begin SetSide ( Friend , 8 ) ;
31260: LD_EXP 64
31264: PPUSH
31265: LD_INT 8
31267: PPUSH
31268: CALL_OW 235
// if IsInUnit ( Friend ) then
31272: LD_EXP 64
31276: PPUSH
31277: CALL_OW 310
31281: IFFALSE 31292
// ComExitBuilding ( Friend ) ;
31283: LD_EXP 64
31287: PPUSH
31288: CALL_OW 122
// if IsDriver ( Friend ) then
31292: LD_EXP 64
31296: PPUSH
31297: CALL 103807 0 1
31301: IFFALSE 31312
// ComExitVehicle ( Friend ) ;
31303: LD_EXP 64
31307: PPUSH
31308: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31312: LD_EXP 64
31316: PPUSH
31317: LD_INT 9
31319: PPUSH
31320: LD_INT 2
31322: PPUSH
31323: CALL_OW 171
// wait ( 0 0$05 ) ;
31327: LD_INT 175
31329: PPUSH
31330: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
31334: LD_EXP 64
31338: PPUSH
31339: CALL_OW 87
// DialogueOn ;
31343: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
31347: LD_EXP 40
31351: PPUSH
31352: LD_STRING D16-JMM-1
31354: PPUSH
31355: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
31359: LD_EXP 64
31363: PPUSH
31364: LD_STRING D16-Friend-1
31366: PPUSH
31367: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
31371: LD_EXP 40
31375: PPUSH
31376: LD_STRING D16-JMM-2
31378: PPUSH
31379: CALL_OW 88
// DialogueOff ;
31383: CALL_OW 7
// SetSide ( Friend , 1 ) ;
31387: LD_EXP 64
31391: PPUSH
31392: LD_INT 1
31394: PPUSH
31395: CALL_OW 235
// ComHold ( Friend ) ;
31399: LD_EXP 64
31403: PPUSH
31404: CALL_OW 140
// wait ( 0 0$20 ) ;
31408: LD_INT 700
31410: PPUSH
31411: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
31415: LD_EXP 64
31419: PPUSH
31420: LD_INT 9
31422: PPUSH
31423: LD_INT 2
31425: PPUSH
31426: CALL_OW 297
31430: PUSH
31431: LD_INT 30
31433: LESS
31434: IFFALSE 31503
// begin SetSide ( Friend , 8 ) ;
31436: LD_EXP 64
31440: PPUSH
31441: LD_INT 8
31443: PPUSH
31444: CALL_OW 235
// if IsInUnit ( Friend ) then
31448: LD_EXP 64
31452: PPUSH
31453: CALL_OW 310
31457: IFFALSE 31468
// ComExitBuilding ( Friend ) ;
31459: LD_EXP 64
31463: PPUSH
31464: CALL_OW 122
// if IsDriver ( Friend ) then
31468: LD_EXP 64
31472: PPUSH
31473: CALL 103807 0 1
31477: IFFALSE 31488
// ComExitVehicle ( Friend ) ;
31479: LD_EXP 64
31483: PPUSH
31484: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
31488: LD_EXP 64
31492: PPUSH
31493: LD_INT 9
31495: PPUSH
31496: LD_INT 2
31498: PPUSH
31499: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
31503: LD_INT 1050
31505: PPUSH
31506: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31510: LD_INT 22
31512: PUSH
31513: LD_INT 1
31515: PUSH
31516: EMPTY
31517: LIST
31518: LIST
31519: PUSH
31520: LD_INT 34
31522: PUSH
31523: LD_INT 8
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: PUSH
31530: EMPTY
31531: LIST
31532: LIST
31533: PPUSH
31534: CALL_OW 69
31538: NOT
31539: IFFALSE 31885
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
31541: LD_ADDR_VAR 0 3
31545: PUSH
31546: LD_INT 22
31548: PUSH
31549: LD_INT 1
31551: PUSH
31552: EMPTY
31553: LIST
31554: LIST
31555: PUSH
31556: LD_INT 26
31558: PUSH
31559: LD_INT 1
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: PUSH
31566: LD_INT 3
31568: PUSH
31569: LD_INT 25
31571: PUSH
31572: LD_INT 12
31574: PUSH
31575: EMPTY
31576: LIST
31577: LIST
31578: PUSH
31579: LD_INT 25
31581: PUSH
31582: LD_INT 16
31584: PUSH
31585: EMPTY
31586: LIST
31587: LIST
31588: PUSH
31589: EMPTY
31590: LIST
31591: LIST
31592: LIST
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: LIST
31598: PPUSH
31599: CALL_OW 69
31603: PUSH
31604: LD_EXP 40
31608: PUSH
31609: LD_EXP 42
31613: PUSH
31614: LD_EXP 56
31618: PUSH
31619: LD_EXP 43
31623: PUSH
31624: LD_EXP 44
31628: PUSH
31629: LD_EXP 45
31633: PUSH
31634: LD_EXP 46
31638: PUSH
31639: LD_EXP 47
31643: PUSH
31644: LD_EXP 48
31648: PUSH
31649: LD_EXP 49
31653: PUSH
31654: LD_EXP 50
31658: PUSH
31659: LD_EXP 51
31663: PUSH
31664: LD_EXP 52
31668: PUSH
31669: LD_EXP 53
31673: PUSH
31674: LD_EXP 54
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: LIST
31683: LIST
31684: LIST
31685: LIST
31686: LIST
31687: LIST
31688: LIST
31689: LIST
31690: LIST
31691: LIST
31692: LIST
31693: LIST
31694: LIST
31695: DIFF
31696: ST_TO_ADDR
// DialogueOn ;
31697: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
31701: LD_EXP 66
31705: PPUSH
31706: LD_STRING D16a-Pla-1
31708: PPUSH
31709: CALL_OW 94
// if Stevens then
31713: LD_EXP 42
31717: IFFALSE 31733
// Say ( Stevens , D16a-Huck-1 ) else
31719: LD_EXP 42
31723: PPUSH
31724: LD_STRING D16a-Huck-1
31726: PPUSH
31727: CALL_OW 88
31731: GO 31775
// if Baker then
31733: LD_EXP 56
31737: IFFALSE 31753
// Say ( Baker , D16a-Huck-1 ) else
31739: LD_EXP 56
31743: PPUSH
31744: LD_STRING D16a-Huck-1
31746: PPUSH
31747: CALL_OW 88
31751: GO 31775
// if tmp then
31753: LD_VAR 0 3
31757: IFFALSE 31775
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
31759: LD_VAR 0 3
31763: PUSH
31764: LD_INT 1
31766: ARRAY
31767: PPUSH
31768: LD_STRING D16a-Sol1-1
31770: PPUSH
31771: CALL_OW 88
// if GetSide ( Friend ) = 8 then
31775: LD_EXP 64
31779: PPUSH
31780: CALL_OW 255
31784: PUSH
31785: LD_INT 8
31787: EQUAL
31788: IFFALSE 31804
// Say ( JMM , D16a-JMM-1 ) else
31790: LD_EXP 40
31794: PPUSH
31795: LD_STRING D16a-JMM-1
31797: PPUSH
31798: CALL_OW 88
31802: GO 31864
// begin Say ( JMM , D16a-JMM-1a ) ;
31804: LD_EXP 40
31808: PPUSH
31809: LD_STRING D16a-JMM-1a
31811: PPUSH
31812: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
31816: LD_EXP 64
31820: PPUSH
31821: LD_STRING D16a-Friend-1
31823: PPUSH
31824: CALL_OW 88
// ComExitBuilding ( Friend ) ;
31828: LD_EXP 64
31832: PPUSH
31833: CALL_OW 122
// AddComMoveXY ( Friend , 191 , 103 ) ;
31837: LD_EXP 64
31841: PPUSH
31842: LD_INT 191
31844: PPUSH
31845: LD_INT 103
31847: PPUSH
31848: CALL_OW 171
// SetSide ( Friend , 3 ) ;
31852: LD_EXP 64
31856: PPUSH
31857: LD_INT 3
31859: PPUSH
31860: CALL_OW 235
// end ; DialogueOff ;
31864: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
31868: LD_VAR 0 1
31872: PPUSH
31873: LD_INT 60
31875: PPUSH
31876: LD_INT 95
31878: PPUSH
31879: CALL_OW 116
// end else
31883: GO 31905
// begin DialogueOn ;
31885: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
31889: LD_EXP 66
31893: PPUSH
31894: LD_STRING D16c-Pla-1
31896: PPUSH
31897: CALL_OW 94
// DialogueOff ;
31901: CALL_OW 7
// end ; end else
31905: GO 32006
// begin wait ( 3 3$00 ) ;
31907: LD_INT 6300
31909: PPUSH
31910: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
31914: LD_INT 22
31916: PUSH
31917: LD_INT 1
31919: PUSH
31920: EMPTY
31921: LIST
31922: LIST
31923: PUSH
31924: LD_INT 34
31926: PUSH
31927: LD_INT 8
31929: PUSH
31930: EMPTY
31931: LIST
31932: LIST
31933: PUSH
31934: EMPTY
31935: LIST
31936: LIST
31937: PPUSH
31938: CALL_OW 69
31942: NOT
31943: IFFALSE 31986
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
31945: LD_EXP 66
31949: PPUSH
31950: LD_STRING D16b-Pla-1
31952: PPUSH
31953: CALL_OW 94
// Say ( JMM , D16b-JMM-1 ) ;
31957: LD_EXP 40
31961: PPUSH
31962: LD_STRING D16b-JMM-1
31964: PPUSH
31965: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
31969: LD_VAR 0 1
31973: PPUSH
31974: LD_INT 60
31976: PPUSH
31977: LD_INT 95
31979: PPUSH
31980: CALL_OW 116
// end else
31984: GO 32006
// begin DialogueOn ;
31986: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla-1 ) ;
31990: LD_EXP 66
31994: PPUSH
31995: LD_STRING D16c-Pla-1
31997: PPUSH
31998: CALL_OW 94
// DialogueOff ;
32002: CALL_OW 7
// end ; end ; end ;
32006: PPOPN 3
32008: END
// every 0 0$10 trigger ( GetTech ( tech_SibFiss , 1 ) = state_researched or missionTime >= 60 60$00 ) and not allianceDestroyed and IsOk ( Roth ) do var dec ;
32009: LD_INT 25
32011: PPUSH
32012: LD_INT 1
32014: PPUSH
32015: CALL_OW 321
32019: PUSH
32020: LD_INT 2
32022: EQUAL
32023: PUSH
32024: LD_EXP 14
32028: PUSH
32029: LD_INT 126000
32031: GREATEREQUAL
32032: OR
32033: PUSH
32034: LD_EXP 23
32038: NOT
32039: AND
32040: PUSH
32041: LD_EXP 77
32045: PPUSH
32046: CALL_OW 302
32050: AND
32051: IFFALSE 32409
32053: GO 32055
32055: DISABLE
32056: LD_INT 0
32058: PPUSH
// begin missionStage := 11 ;
32059: LD_ADDR_EXP 15
32063: PUSH
32064: LD_INT 11
32066: ST_TO_ADDR
// DialogueOn ;
32067: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
32071: LD_EXP 77
32075: PPUSH
32076: LD_STRING D9-Roth-1
32078: PPUSH
32079: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
32083: LD_EXP 40
32087: PPUSH
32088: LD_STRING D9-JMM-1
32090: PPUSH
32091: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
32095: LD_EXP 77
32099: PPUSH
32100: LD_STRING D9-Roth-2
32102: PPUSH
32103: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
32107: LD_EXP 77
32111: PPUSH
32112: LD_STRING D9-Roth-2a
32114: PPUSH
32115: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
32119: LD_EXP 66
32123: PPUSH
32124: LD_STRING D9-Pla-2
32126: PPUSH
32127: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
32131: LD_EXP 77
32135: PPUSH
32136: LD_STRING D9-Roth-3
32138: PPUSH
32139: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
32143: LD_EXP 66
32147: PPUSH
32148: LD_STRING D9-Pla-3
32150: PPUSH
32151: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
32155: LD_EXP 77
32159: PPUSH
32160: LD_STRING D9-Roth-4
32162: PPUSH
32163: CALL_OW 94
// dec := Query ( Q9 ) ;
32167: LD_ADDR_VAR 0 1
32171: PUSH
32172: LD_STRING Q9
32174: PPUSH
32175: CALL_OW 97
32179: ST_TO_ADDR
// if dec = 1 then
32180: LD_VAR 0 1
32184: PUSH
32185: LD_INT 1
32187: EQUAL
32188: IFFALSE 32202
// SayRadio ( Roth , D9a-Roth-1 ) ;
32190: LD_EXP 77
32194: PPUSH
32195: LD_STRING D9a-Roth-1
32197: PPUSH
32198: CALL_OW 94
// if dec = 2 then
32202: LD_VAR 0 1
32206: PUSH
32207: LD_INT 2
32209: EQUAL
32210: IFFALSE 32236
// begin Say ( JMM , D9b-JMM-1 ) ;
32212: LD_EXP 40
32216: PPUSH
32217: LD_STRING D9b-JMM-1
32219: PPUSH
32220: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
32224: LD_EXP 77
32228: PPUSH
32229: LD_STRING D9b-Roth-1
32231: PPUSH
32232: CALL_OW 94
// end ; if dec = 3 then
32236: LD_VAR 0 1
32240: PUSH
32241: LD_INT 3
32243: EQUAL
32244: IFFALSE 32306
// begin Say ( JMM , D9c-JMM-1 ) ;
32246: LD_EXP 40
32250: PPUSH
32251: LD_STRING D9c-JMM-1
32253: PPUSH
32254: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
32258: LD_EXP 77
32262: PPUSH
32263: LD_STRING D9c-Roth-1
32265: PPUSH
32266: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
32270: LD_EXP 40
32274: PPUSH
32275: LD_STRING D9c-JMM-2
32277: PPUSH
32278: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
32282: LD_EXP 77
32286: PPUSH
32287: LD_STRING D9c-Roth-2
32289: PPUSH
32290: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
32294: LD_EXP 40
32298: PPUSH
32299: LD_STRING D9c-JMM-3
32301: PPUSH
32302: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
32306: LD_EXP 77
32310: PPUSH
32311: LD_STRING D9c-Roth-3
32313: PPUSH
32314: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
32318: LD_EXP 77
32322: PPUSH
32323: LD_STRING D9cont-Roth-1
32325: PPUSH
32326: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
32330: LD_EXP 40
32334: PPUSH
32335: LD_STRING D9cont-JMM-1
32337: PPUSH
32338: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
32342: LD_EXP 77
32346: PPUSH
32347: LD_STRING D9cont-Roth-2
32349: PPUSH
32350: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
32354: LD_EXP 40
32358: PPUSH
32359: LD_STRING D9cont-JMM-2
32361: PPUSH
32362: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
32366: LD_EXP 77
32370: PPUSH
32371: LD_STRING D9cont-Roth-3
32373: PPUSH
32374: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
32378: LD_EXP 40
32382: PPUSH
32383: LD_STRING D9cont-JMM-3
32385: PPUSH
32386: CALL_OW 88
// DialogueOff ;
32390: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
32394: LD_STRING M3
32396: PPUSH
32397: CALL_OW 337
// allianceActive := true ;
32401: LD_ADDR_EXP 31
32405: PUSH
32406: LD_INT 1
32408: ST_TO_ADDR
// end ;
32409: PPOPN 1
32411: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
32412: LD_INT 1
32414: PPUSH
32415: LD_INT 126
32417: PPUSH
32418: CALL_OW 292
32422: PUSH
32423: LD_EXP 66
32427: PPUSH
32428: CALL_OW 310
32432: AND
32433: IFFALSE 32586
32435: GO 32437
32437: DISABLE
32438: LD_INT 0
32440: PPUSH
// begin ComExitBuilding ( Platonov ) ;
32441: LD_EXP 66
32445: PPUSH
32446: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
32450: LD_ADDR_VAR 0 1
32454: PUSH
32455: LD_INT 4
32457: PPUSH
32458: LD_INT 22
32460: PUSH
32461: LD_INT 1
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PPUSH
32468: CALL_OW 70
32472: PPUSH
32473: LD_EXP 66
32477: PPUSH
32478: CALL_OW 74
32482: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
32483: LD_EXP 66
32487: PPUSH
32488: LD_VAR 0 1
32492: PUSH
32493: LD_INT 1
32495: ARRAY
32496: PPUSH
32497: CALL_OW 175
// SayRadio ( Platonov , D18-Pla-1 ) ;
32501: LD_EXP 66
32505: PPUSH
32506: LD_STRING D18-Pla-1
32508: PPUSH
32509: CALL_OW 94
// if FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) then
32513: LD_INT 22
32515: PUSH
32516: LD_INT 3
32518: PUSH
32519: EMPTY
32520: LIST
32521: LIST
32522: PUSH
32523: LD_INT 34
32525: PUSH
32526: LD_INT 48
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: EMPTY
32534: LIST
32535: LIST
32536: PPUSH
32537: CALL_OW 69
32541: IFFALSE 32586
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 111 , 97 ) ;
32543: LD_INT 22
32545: PUSH
32546: LD_INT 3
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 34
32555: PUSH
32556: LD_INT 48
32558: PUSH
32559: EMPTY
32560: LIST
32561: LIST
32562: PUSH
32563: EMPTY
32564: LIST
32565: LIST
32566: PPUSH
32567: CALL_OW 69
32571: PUSH
32572: LD_INT 1
32574: ARRAY
32575: PPUSH
32576: LD_INT 111
32578: PPUSH
32579: LD_INT 97
32581: PPUSH
32582: CALL_OW 116
// end ;
32586: PPOPN 1
32588: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
32589: LD_EXP 66
32593: PPUSH
32594: CALL_OW 301
32598: PUSH
32599: LD_EXP 69
32603: PPUSH
32604: CALL_OW 301
32608: AND
32609: PUSH
32610: LD_INT 22
32612: PUSH
32613: LD_INT 3
32615: PUSH
32616: EMPTY
32617: LIST
32618: LIST
32619: PUSH
32620: LD_INT 21
32622: PUSH
32623: LD_INT 1
32625: PUSH
32626: EMPTY
32627: LIST
32628: LIST
32629: PUSH
32630: LD_INT 50
32632: PUSH
32633: EMPTY
32634: LIST
32635: PUSH
32636: EMPTY
32637: LIST
32638: LIST
32639: LIST
32640: PPUSH
32641: CALL_OW 69
32645: PUSH
32646: LD_INT 7
32648: PUSH
32649: LD_INT 8
32651: PUSH
32652: LD_INT 9
32654: PUSH
32655: LD_INT 10
32657: PUSH
32658: EMPTY
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: PUSH
32664: LD_OWVAR 67
32668: ARRAY
32669: LESS
32670: AND
32671: IFFALSE 33470
32673: GO 32675
32675: DISABLE
32676: LD_INT 0
32678: PPUSH
32679: PPUSH
32680: PPUSH
32681: PPUSH
// begin MC_Kill ( 2 ) ;
32682: LD_INT 2
32684: PPUSH
32685: CALL 38461 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
32689: LD_INT 1
32691: PPUSH
32692: LD_INT 3
32694: PPUSH
32695: LD_INT 1
32697: PPUSH
32698: LD_INT 1
32700: PPUSH
32701: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] , [ f_sex , sex_male ] ] ) ;
32705: LD_ADDR_VAR 0 2
32709: PUSH
32710: LD_INT 22
32712: PUSH
32713: LD_INT 3
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 21
32722: PUSH
32723: LD_INT 1
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: LD_INT 50
32732: PUSH
32733: EMPTY
32734: LIST
32735: PUSH
32736: LD_INT 26
32738: PUSH
32739: LD_INT 1
32741: PUSH
32742: EMPTY
32743: LIST
32744: LIST
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: LIST
32750: LIST
32751: PPUSH
32752: CALL_OW 69
32756: ST_TO_ADDR
// if not tmp then
32757: LD_VAR 0 2
32761: NOT
32762: IFFALSE 32818
// begin uc_side = 3 ;
32764: LD_ADDR_OWVAR 20
32768: PUSH
32769: LD_INT 3
32771: ST_TO_ADDR
// uc_nation = 3 ;
32772: LD_ADDR_OWVAR 21
32776: PUSH
32777: LD_INT 3
32779: ST_TO_ADDR
// hc_name =  ;
32780: LD_ADDR_OWVAR 26
32784: PUSH
32785: LD_STRING 
32787: ST_TO_ADDR
// hc_gallery =  ;
32788: LD_ADDR_OWVAR 33
32792: PUSH
32793: LD_STRING 
32795: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
32796: LD_INT 1
32798: PPUSH
32799: LD_INT 10
32801: PPUSH
32802: CALL_OW 381
// tmp = CreateHuman ;
32806: LD_ADDR_VAR 0 2
32810: PUSH
32811: CALL_OW 44
32815: ST_TO_ADDR
// end else
32816: GO 32832
// tmp := tmp [ 1 ] ;
32818: LD_ADDR_VAR 0 2
32822: PUSH
32823: LD_VAR 0 2
32827: PUSH
32828: LD_INT 1
32830: ARRAY
32831: ST_TO_ADDR
// DialogueOn ;
32832: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
32836: LD_VAR 0 2
32840: PPUSH
32841: LD_STRING DSurrenderRussians-RSol1-1a
32843: PPUSH
32844: CALL_OW 94
// DialogueOff ;
32848: CALL_OW 7
// russianDestroyed := true ;
32852: LD_ADDR_EXP 21
32856: PUSH
32857: LD_INT 1
32859: ST_TO_ADDR
// for i in FilterAllUnits ( [ f_side , 6 ] ) do
32860: LD_ADDR_VAR 0 1
32864: PUSH
32865: LD_INT 22
32867: PUSH
32868: LD_INT 6
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PPUSH
32875: CALL_OW 69
32879: PUSH
32880: FOR_IN
32881: IFFALSE 32894
// KillUnit ( i ) ;
32883: LD_VAR 0 1
32887: PPUSH
32888: CALL_OW 66
32892: GO 32880
32894: POP
32895: POP
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
32896: LD_INT 22
32898: PUSH
32899: LD_INT 3
32901: PUSH
32902: EMPTY
32903: LIST
32904: LIST
32905: PUSH
32906: LD_INT 21
32908: PUSH
32909: LD_INT 1
32911: PUSH
32912: EMPTY
32913: LIST
32914: LIST
32915: PUSH
32916: EMPTY
32917: LIST
32918: LIST
32919: PPUSH
32920: CALL_OW 69
32924: PPUSH
32925: CALL_OW 122
// wait ( 0 0$1 ) ;
32929: LD_INT 35
32931: PPUSH
32932: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
32936: LD_INT 22
32938: PUSH
32939: LD_INT 3
32941: PUSH
32942: EMPTY
32943: LIST
32944: LIST
32945: PUSH
32946: LD_INT 21
32948: PUSH
32949: LD_INT 1
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: EMPTY
32957: LIST
32958: LIST
32959: PPUSH
32960: CALL_OW 69
32964: PPUSH
32965: LD_INT 25
32967: PPUSH
32968: CALL_OW 173
// wait ( 0 0$35 ) ;
32972: LD_INT 1225
32974: PPUSH
32975: CALL_OW 67
// PrepareOmarInvasion ;
32979: CALL 15772 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
32983: LD_ADDR_VAR 0 2
32987: PUSH
32988: LD_EXP 95
32992: PPUSH
32993: CALL_OW 250
32997: PUSH
32998: LD_EXP 95
33002: PPUSH
33003: CALL_OW 251
33007: PUSH
33008: EMPTY
33009: LIST
33010: LIST
33011: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
33012: LD_VAR 0 2
33016: PUSH
33017: LD_INT 1
33019: ARRAY
33020: PPUSH
33021: LD_VAR 0 2
33025: PUSH
33026: LD_INT 2
33028: ARRAY
33029: PPUSH
33030: LD_INT 1
33032: PPUSH
33033: LD_INT 8
33035: NEG
33036: PPUSH
33037: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
33041: LD_EXP 95
33045: PPUSH
33046: CALL_OW 87
// DialogueOn ;
33050: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
33054: LD_EXP 40
33058: PPUSH
33059: LD_STRING D19-JMM-1
33061: PPUSH
33062: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Kurt , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
33066: LD_ADDR_VAR 0 3
33070: PUSH
33071: LD_INT 22
33073: PUSH
33074: LD_INT 1
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 26
33083: PUSH
33084: LD_INT 1
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: LD_INT 2
33093: PUSH
33094: LD_INT 25
33096: PUSH
33097: LD_INT 1
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 25
33106: PUSH
33107: LD_INT 2
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 25
33116: PUSH
33117: LD_INT 3
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: LD_INT 25
33126: PUSH
33127: LD_INT 4
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: LD_INT 25
33136: PUSH
33137: LD_INT 5
33139: PUSH
33140: EMPTY
33141: LIST
33142: LIST
33143: PUSH
33144: LD_INT 25
33146: PUSH
33147: LD_INT 8
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: PUSH
33163: EMPTY
33164: LIST
33165: LIST
33166: LIST
33167: PPUSH
33168: CALL_OW 69
33172: PUSH
33173: LD_EXP 40
33177: PUSH
33178: LD_EXP 41
33182: PUSH
33183: LD_EXP 62
33187: PUSH
33188: LD_EXP 42
33192: PUSH
33193: LD_EXP 43
33197: PUSH
33198: LD_EXP 44
33202: PUSH
33203: LD_EXP 45
33207: PUSH
33208: LD_EXP 46
33212: PUSH
33213: LD_EXP 47
33217: PUSH
33218: LD_EXP 48
33222: PUSH
33223: LD_EXP 49
33227: PUSH
33228: LD_EXP 50
33232: PUSH
33233: LD_EXP 51
33237: PUSH
33238: LD_EXP 52
33242: PUSH
33243: LD_EXP 53
33247: PUSH
33248: LD_EXP 54
33252: PUSH
33253: LD_EXP 55
33257: PUSH
33258: LD_EXP 56
33262: PUSH
33263: EMPTY
33264: LIST
33265: LIST
33266: LIST
33267: LIST
33268: LIST
33269: LIST
33270: LIST
33271: LIST
33272: LIST
33273: LIST
33274: LIST
33275: LIST
33276: LIST
33277: LIST
33278: LIST
33279: LIST
33280: LIST
33281: LIST
33282: DIFF
33283: ST_TO_ADDR
// if tmp2 then
33284: LD_VAR 0 3
33288: IFFALSE 33306
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
33290: LD_VAR 0 3
33294: PUSH
33295: LD_INT 1
33297: ARRAY
33298: PPUSH
33299: LD_STRING D19-Sol1-1
33301: PPUSH
33302: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
33306: LD_EXP 40
33310: PPUSH
33311: LD_STRING D19-JMM-2
33313: PPUSH
33314: CALL_OW 88
// DialogueOff ;
33318: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
33322: LD_VAR 0 2
33326: PUSH
33327: LD_INT 1
33329: ARRAY
33330: PPUSH
33331: LD_VAR 0 2
33335: PUSH
33336: LD_INT 2
33338: ARRAY
33339: PPUSH
33340: LD_INT 1
33342: PPUSH
33343: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
33347: LD_STRING M5
33349: PPUSH
33350: CALL_OW 337
// omarOnMotherLode := false ;
33354: LD_ADDR_VAR 0 4
33358: PUSH
33359: LD_INT 0
33361: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
33362: LD_INT 35
33364: PPUSH
33365: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
33369: LD_EXP 95
33373: PPUSH
33374: LD_INT 215
33376: PPUSH
33377: LD_INT 100
33379: PPUSH
33380: CALL_OW 297
33384: PUSH
33385: LD_INT 10
33387: LESS
33388: PUSH
33389: LD_VAR 0 4
33393: NOT
33394: AND
33395: IFFALSE 33429
// begin omarOnMotherLode := true ;
33397: LD_ADDR_VAR 0 4
33401: PUSH
33402: LD_INT 1
33404: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
33405: LD_EXP 40
33409: PPUSH
33410: LD_STRING D19b-JMM-1
33412: PPUSH
33413: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
33417: LD_EXP 95
33421: PPUSH
33422: LD_STRING DOmarContam-Omar-1
33424: PPUSH
33425: CALL_OW 88
// end ; until IsDead ( Omar ) ;
33429: LD_EXP 95
33433: PPUSH
33434: CALL_OW 301
33438: IFFALSE 33362
// Say ( JMM , D19a-JMM-1 ) ;
33440: LD_EXP 40
33444: PPUSH
33445: LD_STRING D19a-JMM-1
33447: PPUSH
33448: CALL_OW 88
// if Heike then
33452: LD_EXP 96
33456: IFFALSE 33470
// Say ( Heike , D19a-Hke-1 ) ;
33458: LD_EXP 96
33462: PPUSH
33463: LD_STRING D19a-Hke-1
33465: PPUSH
33466: CALL_OW 88
// end ;
33470: PPOPN 4
33472: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
33473: LD_INT 22
33475: PUSH
33476: LD_INT 3
33478: PUSH
33479: EMPTY
33480: LIST
33481: LIST
33482: PUSH
33483: LD_INT 21
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PPUSH
33497: CALL_OW 69
33501: PUSH
33502: LD_EXP 21
33506: AND
33507: IFFALSE 33575
33509: GO 33511
33511: DISABLE
33512: LD_INT 0
33514: PPUSH
33515: PPUSH
// begin enable ;
33516: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
33517: LD_ADDR_VAR 0 2
33521: PUSH
33522: LD_INT 25
33524: PPUSH
33525: LD_INT 22
33527: PUSH
33528: LD_INT 3
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PPUSH
33535: CALL_OW 70
33539: ST_TO_ADDR
// if not tmp then
33540: LD_VAR 0 2
33544: NOT
33545: IFFALSE 33549
// exit ;
33547: GO 33575
// for i in tmp do
33549: LD_ADDR_VAR 0 1
33553: PUSH
33554: LD_VAR 0 2
33558: PUSH
33559: FOR_IN
33560: IFFALSE 33573
// RemoveUnit ( i ) ;
33562: LD_VAR 0 1
33566: PPUSH
33567: CALL_OW 64
33571: GO 33559
33573: POP
33574: POP
// end ;
33575: PPOPN 2
33577: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
33578: LD_INT 22
33580: PUSH
33581: LD_INT 7
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 21
33590: PUSH
33591: LD_INT 1
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PPUSH
33602: CALL_OW 69
33606: PUSH
33607: LD_INT 6
33609: LESS
33610: IFFALSE 34078
33612: GO 33614
33614: DISABLE
33615: LD_INT 0
33617: PPUSH
33618: PPUSH
// begin MC_Kill ( 1 ) ;
33619: LD_INT 1
33621: PPUSH
33622: CALL 38461 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
33626: LD_INT 7
33628: PPUSH
33629: LD_INT 1
33631: PPUSH
33632: LD_INT 1
33634: PPUSH
33635: LD_INT 1
33637: PPUSH
33638: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
33642: LD_ADDR_VAR 0 1
33646: PUSH
33647: LD_INT 22
33649: PUSH
33650: LD_INT 7
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 26
33659: PUSH
33660: LD_INT 1
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PPUSH
33671: CALL_OW 69
33675: PUSH
33676: LD_EXP 77
33680: DIFF
33681: ST_TO_ADDR
// if tmp then
33682: LD_VAR 0 1
33686: IFFALSE 33704
// tmp := tmp [ 1 ] else
33688: LD_ADDR_VAR 0 1
33692: PUSH
33693: LD_VAR 0 1
33697: PUSH
33698: LD_INT 1
33700: ARRAY
33701: ST_TO_ADDR
33702: GO 33740
// begin uc_side := 7 ;
33704: LD_ADDR_OWVAR 20
33708: PUSH
33709: LD_INT 7
33711: ST_TO_ADDR
// uc_nation := 1 ;
33712: LD_ADDR_OWVAR 21
33716: PUSH
33717: LD_INT 1
33719: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
33720: LD_INT 1
33722: PPUSH
33723: LD_INT 8
33725: PPUSH
33726: CALL_OW 384
// tmp := CreateHuman ;
33730: LD_ADDR_VAR 0 1
33734: PUSH
33735: CALL_OW 44
33739: ST_TO_ADDR
// end ; DialogueOn ;
33740: CALL_OW 6
// if IsOK ( Roth ) then
33744: LD_EXP 77
33748: PPUSH
33749: CALL_OW 302
33753: IFFALSE 33767
// Say ( JMM , DAb-JMM-1 ) ;
33755: LD_EXP 40
33759: PPUSH
33760: LD_STRING DAb-JMM-1
33762: PPUSH
33763: CALL_OW 88
// if IsOK ( Roth ) then
33767: LD_EXP 77
33771: PPUSH
33772: CALL_OW 302
33776: IFFALSE 33800
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
33778: LD_EXP 77
33782: PPUSH
33783: LD_STRING DSurrenderAlliance-Roth-1
33785: PPUSH
33786: CALL_OW 88
// RothCaptured := true ;
33790: LD_ADDR_EXP 33
33794: PUSH
33795: LD_INT 1
33797: ST_TO_ADDR
// end else
33798: GO 33812
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
33800: LD_VAR 0 1
33804: PPUSH
33805: LD_STRING DSurrenderAlliance-Sci1-1
33807: PPUSH
33808: CALL_OW 88
// DialogueOff ;
33812: CALL_OW 7
// allianceDestroyed := true ;
33816: LD_ADDR_EXP 23
33820: PUSH
33821: LD_INT 1
33823: ST_TO_ADDR
// if capturedUnit = 0 then
33824: LD_EXP 34
33828: PUSH
33829: LD_INT 0
33831: EQUAL
33832: IFFALSE 33841
// SetAchievement ( ACH_ALLIANCE ) ;
33834: LD_STRING ACH_ALLIANCE
33836: PPUSH
33837: CALL_OW 543
// if trueAmericans then
33841: LD_EXP 35
33845: IFFALSE 33921
// begin if trueAmericans = 1 then
33847: LD_EXP 35
33851: PUSH
33852: LD_INT 1
33854: EQUAL
33855: IFFALSE 33871
// Say ( JMM , DAb-JMM-1a ) else
33857: LD_EXP 40
33861: PPUSH
33862: LD_STRING DAb-JMM-1a
33864: PPUSH
33865: CALL_OW 88
33869: GO 33883
// Say ( JMM , DAb-JMM-1b ) ;
33871: LD_EXP 40
33875: PPUSH
33876: LD_STRING DAb-JMM-1b
33878: PPUSH
33879: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
33883: LD_EXP 35
33887: PPUSH
33888: CALL_OW 87
// for i in trueAmericans do
33892: LD_ADDR_VAR 0 2
33896: PUSH
33897: LD_EXP 35
33901: PUSH
33902: FOR_IN
33903: IFFALSE 33919
// SetSide ( i , 1 ) ;
33905: LD_VAR 0 2
33909: PPUSH
33910: LD_INT 1
33912: PPUSH
33913: CALL_OW 235
33917: GO 33902
33919: POP
33920: POP
// end ; repeat wait ( 0 0$1 ) ;
33921: LD_INT 35
33923: PPUSH
33924: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
33928: LD_ADDR_VAR 0 2
33932: PUSH
33933: LD_INT 22
33935: PUSH
33936: LD_INT 7
33938: PUSH
33939: EMPTY
33940: LIST
33941: LIST
33942: PUSH
33943: LD_INT 21
33945: PUSH
33946: LD_INT 1
33948: PUSH
33949: EMPTY
33950: LIST
33951: LIST
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PPUSH
33957: CALL_OW 69
33961: PUSH
33962: FOR_IN
33963: IFFALSE 34045
// begin if IsInUnit ( i ) then
33965: LD_VAR 0 2
33969: PPUSH
33970: CALL_OW 310
33974: IFFALSE 33985
// ComExitBuilding ( i ) ;
33976: LD_VAR 0 2
33980: PPUSH
33981: CALL_OW 122
// if IsDriver ( i ) then
33985: LD_VAR 0 2
33989: PPUSH
33990: CALL 103807 0 1
33994: IFFALSE 34005
// ComExitVehicle ( i ) ;
33996: LD_VAR 0 2
34000: PPUSH
34001: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
34005: LD_VAR 0 2
34009: PPUSH
34010: LD_INT 26
34012: PPUSH
34013: CALL_OW 308
34017: NOT
34018: IFFALSE 34034
// AddComMoveToArea ( i , allianceEscapeArea ) else
34020: LD_VAR 0 2
34024: PPUSH
34025: LD_INT 26
34027: PPUSH
34028: CALL_OW 173
34032: GO 34043
// RemoveUnit ( i ) ;
34034: LD_VAR 0 2
34038: PPUSH
34039: CALL_OW 64
// end ;
34043: GO 33962
34045: POP
34046: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
34047: LD_INT 22
34049: PUSH
34050: LD_INT 7
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 21
34059: PUSH
34060: LD_INT 1
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PUSH
34067: EMPTY
34068: LIST
34069: LIST
34070: PPUSH
34071: CALL_OW 69
34075: NOT
34076: IFFALSE 33921
// end ;
34078: PPOPN 2
34080: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
34081: LD_INT 0
34083: PPUSH
34084: PPUSH
// if not unit then
34085: LD_VAR 0 1
34089: NOT
34090: IFFALSE 34094
// exit ;
34092: GO 35602
// DoNotAttack ( 7 , unit ) ;
34094: LD_INT 7
34096: PPUSH
34097: LD_VAR 0 1
34101: PPUSH
34102: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
34106: LD_VAR 0 1
34110: PPUSH
34111: LD_INT 260
34113: PPUSH
34114: LD_INT 235
34116: PPUSH
34117: LD_INT 3
34119: PPUSH
34120: LD_INT 1
34122: PPUSH
34123: CALL_OW 483
// SetSide ( unit , 4 ) ;
34127: LD_VAR 0 1
34131: PPUSH
34132: LD_INT 4
34134: PPUSH
34135: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
34139: LD_ADDR_EXP 34
34143: PUSH
34144: LD_EXP 34
34148: PUSH
34149: LD_INT 1
34151: PLUS
34152: ST_TO_ADDR
// wait ( 0 0$2 ) ;
34153: LD_INT 70
34155: PPUSH
34156: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
34160: LD_INT 260
34162: PPUSH
34163: LD_INT 235
34165: PPUSH
34166: LD_INT 1
34168: PPUSH
34169: LD_INT 8
34171: NEG
34172: PPUSH
34173: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
34177: LD_VAR 0 1
34181: PPUSH
34182: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
34186: LD_VAR 0 1
34190: PPUSH
34191: LD_EXP 77
34195: PPUSH
34196: CALL_OW 119
// DialogueOn ;
34200: CALL_OW 6
// case unit of JMM :
34204: LD_VAR 0 1
34208: PUSH
34209: LD_EXP 40
34213: DOUBLE
34214: EQUAL
34215: IFTRUE 34219
34217: GO 34234
34219: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
34220: LD_EXP 40
34224: PPUSH
34225: LD_STRING DA1-JMM-1
34227: PPUSH
34228: CALL_OW 91
34232: GO 34676
34234: LD_EXP 41
34238: DOUBLE
34239: EQUAL
34240: IFTRUE 34244
34242: GO 34259
34244: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
34245: LD_EXP 41
34249: PPUSH
34250: LD_STRING DA1-Joan-1
34252: PPUSH
34253: CALL_OW 91
34257: GO 34676
34259: LD_EXP 43
34263: DOUBLE
34264: EQUAL
34265: IFTRUE 34269
34267: GO 34284
34269: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
34270: LD_EXP 43
34274: PPUSH
34275: LD_STRING DA1-Lisa-1
34277: PPUSH
34278: CALL_OW 91
34282: GO 34676
34284: LD_EXP 44
34288: DOUBLE
34289: EQUAL
34290: IFTRUE 34294
34292: GO 34309
34294: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
34295: LD_EXP 44
34299: PPUSH
34300: LD_STRING DA1-Don-1
34302: PPUSH
34303: CALL_OW 91
34307: GO 34676
34309: LD_EXP 51
34313: DOUBLE
34314: EQUAL
34315: IFTRUE 34319
34317: GO 34334
34319: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
34320: LD_EXP 51
34324: PPUSH
34325: LD_STRING DA1-Corn-1
34327: PPUSH
34328: CALL_OW 91
34332: GO 34676
34334: LD_EXP 47
34338: DOUBLE
34339: EQUAL
34340: IFTRUE 34344
34342: GO 34359
34344: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
34345: LD_EXP 47
34349: PPUSH
34350: LD_STRING DA1-Den-1
34352: PPUSH
34353: CALL_OW 91
34357: GO 34676
34359: LD_EXP 45
34363: DOUBLE
34364: EQUAL
34365: IFTRUE 34369
34367: GO 34384
34369: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
34370: LD_EXP 45
34374: PPUSH
34375: LD_STRING DA1-Bobby-1
34377: PPUSH
34378: CALL_OW 91
34382: GO 34676
34384: LD_EXP 49
34388: DOUBLE
34389: EQUAL
34390: IFTRUE 34394
34392: GO 34409
34394: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
34395: LD_EXP 49
34399: PPUSH
34400: LD_STRING DA1-Glad-1
34402: PPUSH
34403: CALL_OW 91
34407: GO 34676
34409: LD_EXP 46
34413: DOUBLE
34414: EQUAL
34415: IFTRUE 34419
34417: GO 34434
34419: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
34420: LD_EXP 46
34424: PPUSH
34425: LD_STRING DA1-Cyrus-1
34427: PPUSH
34428: CALL_OW 91
34432: GO 34676
34434: LD_EXP 42
34438: DOUBLE
34439: EQUAL
34440: IFTRUE 34444
34442: GO 34459
34444: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
34445: LD_EXP 42
34449: PPUSH
34450: LD_STRING DA1-Huck-1
34452: PPUSH
34453: CALL_OW 91
34457: GO 34676
34459: LD_EXP 56
34463: DOUBLE
34464: EQUAL
34465: IFTRUE 34469
34467: GO 34484
34469: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
34470: LD_EXP 56
34474: PPUSH
34475: LD_STRING DA1-Huck-1
34477: PPUSH
34478: CALL_OW 91
34482: GO 34676
34484: LD_EXP 48
34488: DOUBLE
34489: EQUAL
34490: IFTRUE 34494
34492: GO 34509
34494: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
34495: LD_EXP 48
34499: PPUSH
34500: LD_STRING DA1-Brown-1
34502: PPUSH
34503: CALL_OW 91
34507: GO 34676
34509: LD_EXP 52
34513: DOUBLE
34514: EQUAL
34515: IFTRUE 34519
34517: GO 34534
34519: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
34520: LD_EXP 52
34524: PPUSH
34525: LD_STRING DA1-Gary-1
34527: PPUSH
34528: CALL_OW 91
34532: GO 34676
34534: LD_EXP 55
34538: DOUBLE
34539: EQUAL
34540: IFTRUE 34544
34542: GO 34559
34544: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
34545: LD_EXP 55
34549: PPUSH
34550: LD_STRING DA1-Con-1
34552: PPUSH
34553: CALL_OW 91
34557: GO 34676
34559: LD_EXP 62
34563: DOUBLE
34564: EQUAL
34565: IFTRUE 34569
34567: GO 34584
34569: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
34570: LD_EXP 62
34574: PPUSH
34575: LD_STRING DA1-Kurt-1
34577: PPUSH
34578: CALL_OW 91
34582: GO 34676
34584: LD_EXP 54
34588: DOUBLE
34589: EQUAL
34590: IFTRUE 34594
34592: GO 34609
34594: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
34595: LD_EXP 54
34599: PPUSH
34600: LD_STRING DA1-Yam-1
34602: PPUSH
34603: CALL_OW 91
34607: GO 34676
34609: LD_EXP 53
34613: DOUBLE
34614: EQUAL
34615: IFTRUE 34619
34617: GO 34634
34619: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
34620: LD_EXP 53
34624: PPUSH
34625: LD_STRING DA1-Frank-1
34627: PPUSH
34628: CALL_OW 91
34632: GO 34676
34634: POP
// begin if GetSex ( unit ) = sex_male then
34635: LD_VAR 0 1
34639: PPUSH
34640: CALL_OW 258
34644: PUSH
34645: LD_INT 1
34647: EQUAL
34648: IFFALSE 34664
// ForceSay ( unit , DA1-Sol1-1 ) else
34650: LD_VAR 0 1
34654: PPUSH
34655: LD_STRING DA1-Sol1-1
34657: PPUSH
34658: CALL_OW 91
34662: GO 34676
// ForceSay ( unit , DA1-FSol1-1 ) ;
34664: LD_VAR 0 1
34668: PPUSH
34669: LD_STRING DA1-FSol1-1
34671: PPUSH
34672: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
34676: LD_EXP 77
34680: PPUSH
34681: LD_STRING DA-Roth-1
34683: PPUSH
34684: CALL_OW 88
// if capturedUnit = 1 then
34688: LD_EXP 34
34692: PUSH
34693: LD_INT 1
34695: EQUAL
34696: IFFALSE 34724
// begin Say ( Simms , DA-Sim-1 ) ;
34698: LD_EXP 78
34702: PPUSH
34703: LD_STRING DA-Sim-1
34705: PPUSH
34706: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
34710: LD_EXP 77
34714: PPUSH
34715: LD_STRING DA-Roth-2
34717: PPUSH
34718: CALL_OW 88
// end else
34722: GO 34736
// Say ( Simms , DA-Sim-2 ) ;
34724: LD_EXP 78
34728: PPUSH
34729: LD_STRING DA-Sim-2
34731: PPUSH
34732: CALL_OW 88
// case unit of JMM :
34736: LD_VAR 0 1
34740: PUSH
34741: LD_EXP 40
34745: DOUBLE
34746: EQUAL
34747: IFTRUE 34751
34749: GO 34766
34751: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
34752: LD_EXP 40
34756: PPUSH
34757: LD_STRING DA1-JMM-1a
34759: PPUSH
34760: CALL_OW 91
34764: GO 35283
34766: LD_EXP 41
34770: DOUBLE
34771: EQUAL
34772: IFTRUE 34776
34774: GO 34791
34776: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
34777: LD_EXP 41
34781: PPUSH
34782: LD_STRING DA1-Joan-1a
34784: PPUSH
34785: CALL_OW 91
34789: GO 35283
34791: LD_EXP 43
34795: DOUBLE
34796: EQUAL
34797: IFTRUE 34801
34799: GO 34816
34801: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
34802: LD_EXP 43
34806: PPUSH
34807: LD_STRING DA1-Lisa-1a
34809: PPUSH
34810: CALL_OW 91
34814: GO 35283
34816: LD_EXP 44
34820: DOUBLE
34821: EQUAL
34822: IFTRUE 34826
34824: GO 34841
34826: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
34827: LD_EXP 44
34831: PPUSH
34832: LD_STRING DA1-Don-1a
34834: PPUSH
34835: CALL_OW 91
34839: GO 35283
34841: LD_EXP 51
34845: DOUBLE
34846: EQUAL
34847: IFTRUE 34851
34849: GO 34866
34851: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
34852: LD_EXP 51
34856: PPUSH
34857: LD_STRING DA1-Corn-1a
34859: PPUSH
34860: CALL_OW 91
34864: GO 35283
34866: LD_EXP 47
34870: DOUBLE
34871: EQUAL
34872: IFTRUE 34876
34874: GO 34891
34876: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
34877: LD_EXP 47
34881: PPUSH
34882: LD_STRING DA1-Den-1a
34884: PPUSH
34885: CALL_OW 91
34889: GO 35283
34891: LD_EXP 45
34895: DOUBLE
34896: EQUAL
34897: IFTRUE 34901
34899: GO 34916
34901: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
34902: LD_EXP 45
34906: PPUSH
34907: LD_STRING DA1-Bobby-1a
34909: PPUSH
34910: CALL_OW 91
34914: GO 35283
34916: LD_EXP 49
34920: DOUBLE
34921: EQUAL
34922: IFTRUE 34926
34924: GO 34941
34926: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
34927: LD_EXP 49
34931: PPUSH
34932: LD_STRING DA1-Glad-1a
34934: PPUSH
34935: CALL_OW 91
34939: GO 35283
34941: LD_EXP 46
34945: DOUBLE
34946: EQUAL
34947: IFTRUE 34951
34949: GO 34966
34951: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
34952: LD_EXP 46
34956: PPUSH
34957: LD_STRING DA1-Cyrus-1a
34959: PPUSH
34960: CALL_OW 91
34964: GO 35283
34966: LD_EXP 42
34970: DOUBLE
34971: EQUAL
34972: IFTRUE 34976
34974: GO 34991
34976: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
34977: LD_EXP 42
34981: PPUSH
34982: LD_STRING DA1-Huck-1a
34984: PPUSH
34985: CALL_OW 91
34989: GO 35283
34991: LD_EXP 56
34995: DOUBLE
34996: EQUAL
34997: IFTRUE 35001
34999: GO 35016
35001: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
35002: LD_EXP 56
35006: PPUSH
35007: LD_STRING DA1-Huck-1a
35009: PPUSH
35010: CALL_OW 91
35014: GO 35283
35016: LD_EXP 48
35020: DOUBLE
35021: EQUAL
35022: IFTRUE 35026
35024: GO 35041
35026: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
35027: LD_EXP 48
35031: PPUSH
35032: LD_STRING DA1-Brown-1a
35034: PPUSH
35035: CALL_OW 91
35039: GO 35283
35041: LD_EXP 52
35045: DOUBLE
35046: EQUAL
35047: IFTRUE 35051
35049: GO 35066
35051: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
35052: LD_EXP 52
35056: PPUSH
35057: LD_STRING DA1-Gary-1a
35059: PPUSH
35060: CALL_OW 91
35064: GO 35283
35066: LD_EXP 55
35070: DOUBLE
35071: EQUAL
35072: IFTRUE 35076
35074: GO 35101
35076: POP
// if JMMGirl = 3 then
35077: LD_EXP 7
35081: PUSH
35082: LD_INT 3
35084: EQUAL
35085: IFFALSE 35099
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
35087: LD_EXP 55
35091: PPUSH
35092: LD_STRING DA1-Con-1a
35094: PPUSH
35095: CALL_OW 91
35099: GO 35283
35101: LD_EXP 62
35105: DOUBLE
35106: EQUAL
35107: IFTRUE 35111
35109: GO 35126
35111: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
35112: LD_EXP 62
35116: PPUSH
35117: LD_STRING DA1-Kurt-1a
35119: PPUSH
35120: CALL_OW 91
35124: GO 35283
35126: LD_EXP 54
35130: DOUBLE
35131: EQUAL
35132: IFTRUE 35136
35134: GO 35151
35136: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
35137: LD_EXP 54
35141: PPUSH
35142: LD_STRING DA1-Yam-1a
35144: PPUSH
35145: CALL_OW 91
35149: GO 35283
35151: LD_EXP 53
35155: DOUBLE
35156: EQUAL
35157: IFTRUE 35161
35159: GO 35176
35161: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
35162: LD_EXP 53
35166: PPUSH
35167: LD_STRING DA1-Frank-1a
35169: PPUSH
35170: CALL_OW 91
35174: GO 35283
35176: POP
// begin join := rand ( 0 , 1 ) ;
35177: LD_ADDR_VAR 0 3
35181: PUSH
35182: LD_INT 0
35184: PPUSH
35185: LD_INT 1
35187: PPUSH
35188: CALL_OW 12
35192: ST_TO_ADDR
// if join then
35193: LD_VAR 0 3
35197: IFFALSE 35242
// begin if GetSex ( unit ) = sex_male then
35199: LD_VAR 0 1
35203: PPUSH
35204: CALL_OW 258
35208: PUSH
35209: LD_INT 1
35211: EQUAL
35212: IFFALSE 35228
// ForceSay ( unit , DA1-Sol1-1b ) else
35214: LD_VAR 0 1
35218: PPUSH
35219: LD_STRING DA1-Sol1-1b
35221: PPUSH
35222: CALL_OW 91
35226: GO 35240
// ForceSay ( unit , DA1-FSol1-1b ) ;
35228: LD_VAR 0 1
35232: PPUSH
35233: LD_STRING DA1-FSol1-1b
35235: PPUSH
35236: CALL_OW 91
// end else
35240: GO 35283
// begin if GetSex ( unit ) = sex_male then
35242: LD_VAR 0 1
35246: PPUSH
35247: CALL_OW 258
35251: PUSH
35252: LD_INT 1
35254: EQUAL
35255: IFFALSE 35271
// ForceSay ( unit , DA1-Sol1-1a ) else
35257: LD_VAR 0 1
35261: PPUSH
35262: LD_STRING DA1-Sol1-1a
35264: PPUSH
35265: CALL_OW 91
35269: GO 35283
// ForceSay ( unit , DA1-FSol1-1a ) ;
35271: LD_VAR 0 1
35275: PPUSH
35276: LD_STRING DA1-FSol1-1a
35278: PPUSH
35279: CALL_OW 91
// end ; end ; end ; if unit = JMM then
35283: LD_VAR 0 1
35287: PUSH
35288: LD_EXP 40
35292: EQUAL
35293: IFFALSE 35304
// begin YouLost ( JMMCaptured ) ;
35295: LD_STRING JMMCaptured
35297: PPUSH
35298: CALL_OW 104
// exit ;
35302: GO 35602
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
35304: LD_VAR 0 1
35308: PUSH
35309: LD_EXP 44
35313: PUSH
35314: LD_EXP 47
35318: PUSH
35319: LD_EXP 45
35323: PUSH
35324: LD_EXP 42
35328: PUSH
35329: LD_EXP 56
35333: PUSH
35334: LD_EXP 48
35338: PUSH
35339: LD_EXP 54
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: IN
35353: PUSH
35354: LD_VAR 0 3
35358: OR
35359: IFFALSE 35458
// begin Say ( Roth , DA-Roth-3 ) ;
35361: LD_EXP 77
35365: PPUSH
35366: LD_STRING DA-Roth-3
35368: PPUSH
35369: CALL_OW 88
// SetSide ( unit , 7 ) ;
35373: LD_VAR 0 1
35377: PPUSH
35378: LD_INT 7
35380: PPUSH
35381: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
35385: LD_ADDR_EXP 100
35389: PUSH
35390: LD_EXP 100
35394: PPUSH
35395: LD_INT 1
35397: PPUSH
35398: LD_EXP 100
35402: PUSH
35403: LD_INT 1
35405: ARRAY
35406: PUSH
35407: LD_VAR 0 1
35411: ADD
35412: PPUSH
35413: CALL_OW 1
35417: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35418: LD_INT 260
35420: PPUSH
35421: LD_INT 235
35423: PPUSH
35424: LD_INT 1
35426: PPUSH
35427: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35431: LD_VAR 0 1
35435: PPUSH
35436: LD_INT 1000
35438: PPUSH
35439: CALL_OW 234
// DialogueOff ;
35443: CALL_OW 7
// ComFree ( unit ) ;
35447: LD_VAR 0 1
35451: PPUSH
35452: CALL_OW 139
// end else
35456: GO 35539
// begin Say ( Roth , DA-Roth-3a ) ;
35458: LD_EXP 77
35462: PPUSH
35463: LD_STRING DA-Roth-3a
35465: PPUSH
35466: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
35470: LD_ADDR_EXP 35
35474: PUSH
35475: LD_EXP 35
35479: PUSH
35480: LD_VAR 0 1
35484: ADD
35485: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
35486: LD_INT 260
35488: PPUSH
35489: LD_INT 235
35491: PPUSH
35492: LD_INT 1
35494: PPUSH
35495: CALL_OW 331
// SetLives ( unit , 1000 ) ;
35499: LD_VAR 0 1
35503: PPUSH
35504: LD_INT 1000
35506: PPUSH
35507: CALL_OW 234
// DialogueOff ;
35511: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
35515: LD_VAR 0 1
35519: PPUSH
35520: LD_INT 272
35522: PPUSH
35523: LD_INT 254
35525: PPUSH
35526: CALL_OW 111
// AddComHold ( unit ) ;
35530: LD_VAR 0 1
35534: PPUSH
35535: CALL_OW 200
// end ; if capturedUnit = 1 then
35539: LD_EXP 34
35543: PUSH
35544: LD_INT 1
35546: EQUAL
35547: IFFALSE 35602
// begin DialogueOn ;
35549: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
35553: LD_EXP 40
35557: PPUSH
35558: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
35562: LD_EXP 40
35566: PPUSH
35567: LD_STRING DAa-JMM-1
35569: PPUSH
35570: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
35574: LD_EXP 40
35578: PPUSH
35579: LD_STRING DAa-JMM-1a
35581: PPUSH
35582: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
35586: LD_EXP 40
35590: PPUSH
35591: LD_STRING DAa-JMM-1b
35593: PPUSH
35594: CALL_OW 88
// DialogueOff ;
35598: CALL_OW 7
// end ; end ;
35602: LD_VAR 0 2
35606: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
35607: LD_EXP 15
35611: PUSH
35612: LD_INT 13
35614: GREATEREQUAL
35615: PUSH
35616: LD_INT 22
35618: PUSH
35619: LD_INT 2
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 21
35628: PUSH
35629: LD_INT 1
35631: PUSH
35632: EMPTY
35633: LIST
35634: LIST
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PPUSH
35640: CALL_OW 69
35644: PUSH
35645: LD_INT 0
35647: EQUAL
35648: AND
35649: PUSH
35650: LD_INT 22
35652: PUSH
35653: LD_INT 2
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 33
35662: PUSH
35663: LD_INT 5
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: LD_INT 21
35672: PUSH
35673: LD_INT 2
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 50
35682: PUSH
35683: EMPTY
35684: LIST
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: LIST
35690: LIST
35691: PPUSH
35692: CALL_OW 69
35696: PUSH
35697: LD_INT 0
35699: EQUAL
35700: AND
35701: PUSH
35702: LD_EXP 21
35706: AND
35707: PUSH
35708: LD_EXP 22
35712: AND
35713: PUSH
35714: LD_EXP 23
35718: AND
35719: IFFALSE 36415
35721: GO 35723
35723: DISABLE
35724: LD_INT 0
35726: PPUSH
35727: PPUSH
35728: PPUSH
// begin m1 := false ;
35729: LD_ADDR_VAR 0 1
35733: PUSH
35734: LD_INT 0
35736: ST_TO_ADDR
// m2 := false ;
35737: LD_ADDR_VAR 0 2
35741: PUSH
35742: LD_INT 0
35744: ST_TO_ADDR
// m3 := false ;
35745: LD_ADDR_VAR 0 3
35749: PUSH
35750: LD_INT 0
35752: ST_TO_ADDR
// if not bombExploded then
35753: LD_EXP 37
35757: NOT
35758: IFFALSE 35767
// SetAchievement ( ACH_SIBROCKET ) ;
35760: LD_STRING ACH_SIBROCKET
35762: PPUSH
35763: CALL_OW 543
// if GetSide ( Friend ) = 1 and IsOk ( Friend ) then
35767: LD_EXP 64
35771: PPUSH
35772: CALL_OW 255
35776: PUSH
35777: LD_INT 1
35779: EQUAL
35780: PUSH
35781: LD_EXP 64
35785: PPUSH
35786: CALL_OW 302
35790: AND
35791: IFFALSE 35807
// begin wait ( 3 ) ;
35793: LD_INT 3
35795: PPUSH
35796: CALL_OW 67
// SetAchievement ( ACH_OPO ) ;
35800: LD_STRING ACH_OPO
35802: PPUSH
35803: CALL_OW 543
// end ; if tick <= 120 120$00 then
35807: LD_OWVAR 1
35811: PUSH
35812: LD_INT 252000
35814: LESSEQUAL
35815: IFFALSE 35831
// begin wait ( 3 ) ;
35817: LD_INT 3
35819: PPUSH
35820: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
35824: LD_STRING ACH_ASPEED_15
35826: PPUSH
35827: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
35831: LD_EXP 40
35835: PPUSH
35836: CALL_OW 87
// music_class := 5 ;
35840: LD_ADDR_OWVAR 72
35844: PUSH
35845: LD_INT 5
35847: ST_TO_ADDR
// music_nat := 5 ;
35848: LD_ADDR_OWVAR 71
35852: PUSH
35853: LD_INT 5
35855: ST_TO_ADDR
// DialogueOn ;
35856: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
35860: LD_EXP 40
35864: PPUSH
35865: LD_STRING D20-JMM-1
35867: PPUSH
35868: CALL_OW 88
// if IsOK ( Joan ) then
35872: LD_EXP 41
35876: PPUSH
35877: CALL_OW 302
35881: IFFALSE 35895
// Say ( Joan , D20-Joan-1 ) ;
35883: LD_EXP 41
35887: PPUSH
35888: LD_STRING D20-Joan-1
35890: PPUSH
35891: CALL_OW 88
// if IsOk ( Lisa ) then
35895: LD_EXP 43
35899: PPUSH
35900: CALL_OW 302
35904: IFFALSE 35918
// Say ( Lisa , D20-Lisa-1 ) ;
35906: LD_EXP 43
35910: PPUSH
35911: LD_STRING D20-Lisa-1
35913: PPUSH
35914: CALL_OW 88
// if IsOk ( Donaldson ) then
35918: LD_EXP 44
35922: PPUSH
35923: CALL_OW 302
35927: IFFALSE 35941
// Say ( Donaldson , D20-Don-1 ) ;
35929: LD_EXP 44
35933: PPUSH
35934: LD_STRING D20-Don-1
35936: PPUSH
35937: CALL_OW 88
// if IsOK ( Cornel ) then
35941: LD_EXP 51
35945: PPUSH
35946: CALL_OW 302
35950: IFFALSE 35964
// Say ( Cornel , D20-Corn-1 ) ;
35952: LD_EXP 51
35956: PPUSH
35957: LD_STRING D20-Corn-1
35959: PPUSH
35960: CALL_OW 88
// if IsOk ( Denis ) then
35964: LD_EXP 47
35968: PPUSH
35969: CALL_OW 302
35973: IFFALSE 35987
// Say ( Denis , D20-Den-1 ) ;
35975: LD_EXP 47
35979: PPUSH
35980: LD_STRING D20-Den-1
35982: PPUSH
35983: CALL_OW 88
// if IsOk ( Bobby ) then
35987: LD_EXP 45
35991: PPUSH
35992: CALL_OW 302
35996: IFFALSE 36010
// Say ( Bobby , D20-Bobby-1 ) ;
35998: LD_EXP 45
36002: PPUSH
36003: LD_STRING D20-Bobby-1
36005: PPUSH
36006: CALL_OW 88
// if IsOk ( Gladstone ) then
36010: LD_EXP 49
36014: PPUSH
36015: CALL_OW 302
36019: IFFALSE 36033
// Say ( Gladstone , D20-Glad-1 ) ;
36021: LD_EXP 49
36025: PPUSH
36026: LD_STRING D20-Glad-1
36028: PPUSH
36029: CALL_OW 88
// if IsOk ( Cyrus ) then
36033: LD_EXP 46
36037: PPUSH
36038: CALL_OW 302
36042: IFFALSE 36056
// Say ( Cyrus , D20-Cyrus-1 ) ;
36044: LD_EXP 46
36048: PPUSH
36049: LD_STRING D20-Cyrus-1
36051: PPUSH
36052: CALL_OW 88
// if IsOk ( Stevens ) then
36056: LD_EXP 42
36060: PPUSH
36061: CALL_OW 302
36065: IFFALSE 36079
// Say ( Stevens , D20-Huck-1 ) ;
36067: LD_EXP 42
36071: PPUSH
36072: LD_STRING D20-Huck-1
36074: PPUSH
36075: CALL_OW 88
// if IsOk ( Brown ) then
36079: LD_EXP 48
36083: PPUSH
36084: CALL_OW 302
36088: IFFALSE 36102
// Say ( Brown , D20-Brown-1 ) ;
36090: LD_EXP 48
36094: PPUSH
36095: LD_STRING D20-Brown-1
36097: PPUSH
36098: CALL_OW 88
// if IsOk ( Gary ) then
36102: LD_EXP 52
36106: PPUSH
36107: CALL_OW 302
36111: IFFALSE 36125
// Say ( Gary , D20-Gary-1 ) ;
36113: LD_EXP 52
36117: PPUSH
36118: LD_STRING D20-Gary-1
36120: PPUSH
36121: CALL_OW 88
// if IsOk ( Connie ) then
36125: LD_EXP 55
36129: PPUSH
36130: CALL_OW 302
36134: IFFALSE 36148
// Say ( Connie , D20-Con-1 ) ;
36136: LD_EXP 55
36140: PPUSH
36141: LD_STRING D20-Con-1
36143: PPUSH
36144: CALL_OW 88
// if IsOk ( Kurt ) then
36148: LD_EXP 62
36152: PPUSH
36153: CALL_OW 302
36157: IFFALSE 36171
// Say ( Kurt , D20-Kurt-1 ) ;
36159: LD_EXP 62
36163: PPUSH
36164: LD_STRING D20-Kurt-1
36166: PPUSH
36167: CALL_OW 88
// if IsOk ( Kikuchi ) then
36171: LD_EXP 54
36175: PPUSH
36176: CALL_OW 302
36180: IFFALSE 36194
// Say ( Kikuchi , D20-Yam-1 ) ;
36182: LD_EXP 54
36186: PPUSH
36187: LD_STRING D20-Yam-1
36189: PPUSH
36190: CALL_OW 88
// if IsOk ( Frank ) then
36194: LD_EXP 53
36198: PPUSH
36199: CALL_OW 302
36203: IFFALSE 36217
// Say ( Frank , D20-Frank-1 ) ;
36205: LD_EXP 53
36209: PPUSH
36210: LD_STRING D20-Frank-1
36212: PPUSH
36213: CALL_OW 88
// DialogueOff ;
36217: CALL_OW 7
// if RothCaptured then
36221: LD_EXP 33
36225: IFFALSE 36247
// begin m1 := true ;
36227: LD_ADDR_VAR 0 1
36231: PUSH
36232: LD_INT 1
36234: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
36235: LD_STRING Roth
36237: PPUSH
36238: LD_INT 1
36240: PPUSH
36241: CALL_OW 101
// end else
36245: GO 36258
// AddMedal ( Roth , - 1 ) ;
36247: LD_STRING Roth
36249: PPUSH
36250: LD_INT 1
36252: NEG
36253: PPUSH
36254: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish or not behemothDone then
36258: LD_EXP 25
36262: NOT
36263: PUSH
36264: LD_EXP 27
36268: OR
36269: PUSH
36270: LD_EXP 28
36274: NOT
36275: OR
36276: IFFALSE 36298
// begin m2 := true ;
36278: LD_ADDR_VAR 0 2
36282: PUSH
36283: LD_INT 1
36285: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
36286: LD_STRING Project
36288: PPUSH
36289: LD_INT 1
36291: PPUSH
36292: CALL_OW 101
// end else
36296: GO 36309
// AddMedal ( Project , - 1 ) ;
36298: LD_STRING Project
36300: PPUSH
36301: LD_INT 1
36303: NEG
36304: PPUSH
36305: CALL_OW 101
// if lostCounter = 0 then
36309: LD_EXP 32
36313: PUSH
36314: LD_INT 0
36316: EQUAL
36317: IFFALSE 36339
// begin m3 := true ;
36319: LD_ADDR_VAR 0 3
36323: PUSH
36324: LD_INT 1
36326: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
36327: LD_STRING NoLosses
36329: PPUSH
36330: LD_INT 1
36332: PPUSH
36333: CALL_OW 101
// end else
36337: GO 36350
// AddMedal ( NoLosses , - 1 ) ;
36339: LD_STRING NoLosses
36341: PPUSH
36342: LD_INT 1
36344: NEG
36345: PPUSH
36346: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
36350: LD_VAR 0 1
36354: PUSH
36355: LD_VAR 0 2
36359: AND
36360: PUSH
36361: LD_VAR 0 3
36365: AND
36366: PUSH
36367: LD_OWVAR 67
36371: PUSH
36372: LD_INT 3
36374: GREATEREQUAL
36375: AND
36376: IFFALSE 36388
// SetAchievementEX ( ACH_AMER , 15 ) ;
36378: LD_STRING ACH_AMER
36380: PPUSH
36381: LD_INT 15
36383: PPUSH
36384: CALL_OW 564
// GiveMedals ( MAIN ) ;
36388: LD_STRING MAIN
36390: PPUSH
36391: CALL_OW 102
// music_class := 4 ;
36395: LD_ADDR_OWVAR 72
36399: PUSH
36400: LD_INT 4
36402: ST_TO_ADDR
// music_nat := 1 ;
36403: LD_ADDR_OWVAR 71
36407: PUSH
36408: LD_INT 1
36410: ST_TO_ADDR
// YouWin ;
36411: CALL_OW 103
// end ; end_of_file
36415: PPOPN 3
36417: END
// export function CustomEvent ( event ) ; begin
36418: LD_INT 0
36420: PPUSH
// end ;
36421: LD_VAR 0 2
36425: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
36426: LD_VAR 0 1
36430: PUSH
36431: LD_INT 1
36433: EQUAL
36434: PUSH
36435: LD_VAR 0 2
36439: PUSH
36440: LD_INT 4
36442: EQUAL
36443: AND
36444: PUSH
36445: LD_EXP 60
36449: PPUSH
36450: CALL_OW 300
36454: AND
36455: IFFALSE 36471
// begin wait ( 0 0$2 ) ;
36457: LD_INT 70
36459: PPUSH
36460: CALL_OW 67
// YouLost ( Dismissed ) ;
36464: LD_STRING Dismissed
36466: PPUSH
36467: CALL_OW 104
// end ; end ;
36471: PPOPN 2
36473: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
36474: LD_VAR 0 2
36478: PPUSH
36479: LD_VAR 0 3
36483: PPUSH
36484: LD_INT 18
36486: PPUSH
36487: CALL_OW 309
36491: IFFALSE 36500
// YouLost ( Motherlode3 ) ;
36493: LD_STRING Motherlode3
36495: PPUSH
36496: CALL_OW 104
// end ;
36500: PPOPN 3
36502: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
36503: LD_EXP 27
36507: NOT
36508: IFFALSE 36518
// behemothDone := true ;
36510: LD_ADDR_EXP 28
36514: PUSH
36515: LD_INT 1
36517: ST_TO_ADDR
// end ;
36518: PPOPN 1
36520: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
36521: LD_VAR 0 1
36525: PPUSH
36526: CALL_OW 255
36530: PUSH
36531: LD_INT 1
36533: EQUAL
36534: IFFALSE 36544
// bombExploded := true ;
36536: LD_ADDR_EXP 37
36540: PUSH
36541: LD_INT 1
36543: ST_TO_ADDR
// if GetSide ( unit ) = 3 then
36544: LD_VAR 0 1
36548: PPUSH
36549: CALL_OW 255
36553: PUSH
36554: LD_INT 3
36556: EQUAL
36557: IFFALSE 36587
// MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
36559: LD_INT 2
36561: PPUSH
36562: LD_INT 23
36564: PUSH
36565: LD_INT 3
36567: PUSH
36568: LD_INT 3
36570: PUSH
36571: LD_INT 48
36573: PUSH
36574: EMPTY
36575: LIST
36576: LIST
36577: LIST
36578: LIST
36579: PUSH
36580: EMPTY
36581: LIST
36582: PPUSH
36583: CALL 62472 0 2
// if GetSide ( unit ) = 1 and GetSide ( Friend ) = 1 and IsOk ( Friend ) and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
36587: LD_VAR 0 1
36591: PPUSH
36592: CALL_OW 255
36596: PUSH
36597: LD_INT 1
36599: EQUAL
36600: PUSH
36601: LD_EXP 64
36605: PPUSH
36606: CALL_OW 255
36610: PUSH
36611: LD_INT 1
36613: EQUAL
36614: AND
36615: PUSH
36616: LD_EXP 64
36620: PPUSH
36621: CALL_OW 302
36625: AND
36626: PUSH
36627: LD_EXP 30
36631: AND
36632: PUSH
36633: LD_INT 22
36635: PUSH
36636: LD_INT 3
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: LD_INT 34
36645: PUSH
36646: LD_INT 48
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: EMPTY
36654: LIST
36655: LIST
36656: PPUSH
36657: CALL_OW 69
36661: AND
36662: PUSH
36663: LD_INT 22
36665: PUSH
36666: LD_INT 1
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: LD_INT 34
36675: PUSH
36676: LD_INT 8
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: EMPTY
36684: LIST
36685: LIST
36686: PPUSH
36687: CALL_OW 69
36691: NOT
36692: AND
36693: IFFALSE 36745
// begin wait ( 0 0$5 ) ;
36695: LD_INT 175
36697: PPUSH
36698: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
36702: LD_INT 22
36704: PUSH
36705: LD_INT 3
36707: PUSH
36708: EMPTY
36709: LIST
36710: LIST
36711: PUSH
36712: LD_INT 34
36714: PUSH
36715: LD_INT 48
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: EMPTY
36723: LIST
36724: LIST
36725: PPUSH
36726: CALL_OW 69
36730: PUSH
36731: LD_INT 1
36733: ARRAY
36734: PPUSH
36735: LD_INT 60
36737: PPUSH
36738: LD_INT 95
36740: PPUSH
36741: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) or IsInSibRocketRange ( x , y , motherLodeArea ) then
36745: LD_VAR 0 2
36749: PPUSH
36750: LD_VAR 0 3
36754: PPUSH
36755: LD_INT 18
36757: PPUSH
36758: CALL_OW 309
36762: PUSH
36763: LD_VAR 0 2
36767: PPUSH
36768: LD_VAR 0 3
36772: PPUSH
36773: LD_INT 18
36775: PPUSH
36776: CALL 109999 0 3
36780: OR
36781: IFFALSE 36828
// begin if GetSide ( unit ) = 1 then
36783: LD_VAR 0 1
36787: PPUSH
36788: CALL_OW 255
36792: PUSH
36793: LD_INT 1
36795: EQUAL
36796: IFFALSE 36814
// begin wait ( 0 0$6 ) ;
36798: LD_INT 210
36800: PPUSH
36801: CALL_OW 67
// YouLost ( Motherlode2 ) ;
36805: LD_STRING Motherlode2
36807: PPUSH
36808: CALL_OW 104
// end else
36812: GO 36828
// begin wait ( 0 0$6 ) ;
36814: LD_INT 210
36816: PPUSH
36817: CALL_OW 67
// YouLost ( Motherlode1 ) ;
36821: LD_STRING Motherlode1
36823: PPUSH
36824: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
36828: LD_VAR 0 1
36832: PPUSH
36833: CALL_OW 255
36837: PUSH
36838: LD_INT 3
36840: EQUAL
36841: IFFALSE 36862
// begin wait ( 0 0$5 ) ;
36843: LD_INT 175
36845: PPUSH
36846: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
36850: LD_EXP 66
36854: PPUSH
36855: LD_STRING D18-Pla-1
36857: PPUSH
36858: CALL_OW 94
// end ; end ;
36862: PPOPN 3
36864: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
36865: LD_VAR 0 1
36869: PPUSH
36870: CALL 126064 0 1
// if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
36874: LD_VAR 0 1
36878: PUSH
36879: LD_INT 22
36881: PUSH
36882: LD_INT 1
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 21
36891: PUSH
36892: LD_INT 1
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 23
36901: PUSH
36902: LD_INT 1
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: LIST
36913: PPUSH
36914: CALL_OW 69
36918: IN
36919: IFFALSE 36935
// lostCounter := lostCounter + 1 ;
36921: LD_ADDR_EXP 32
36925: PUSH
36926: LD_EXP 32
36930: PUSH
36931: LD_INT 1
36933: PLUS
36934: ST_TO_ADDR
// if un in behemothBuilders then
36935: LD_VAR 0 1
36939: PUSH
36940: LD_EXP 75
36944: IN
36945: IFFALSE 36965
// begin behemothBuilders := behemothBuilders diff un ;
36947: LD_ADDR_EXP 75
36951: PUSH
36952: LD_EXP 75
36956: PUSH
36957: LD_VAR 0 1
36961: DIFF
36962: ST_TO_ADDR
// exit ;
36963: GO 36995
// end ; if un = JMM then
36965: LD_VAR 0 1
36969: PUSH
36970: LD_EXP 40
36974: EQUAL
36975: IFFALSE 36986
// begin YouLost ( JMM ) ;
36977: LD_STRING JMM
36979: PPUSH
36980: CALL_OW 104
// exit ;
36984: GO 36995
// end ; MCE_UnitDestroyed ( un ) ;
36986: LD_VAR 0 1
36990: PPUSH
36991: CALL 65914 0 1
// end ;
36995: PPOPN 1
36997: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
36998: LD_VAR 0 1
37002: PPUSH
37003: LD_VAR 0 2
37007: PPUSH
37008: CALL 68246 0 2
// end ;
37012: PPOPN 2
37014: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
37015: LD_VAR 0 1
37019: PPUSH
37020: CALL 67314 0 1
// end ;
37024: PPOPN 1
37026: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
37027: LD_VAR 0 1
37031: PUSH
37032: LD_INT 22
37034: PUSH
37035: LD_INT 8
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 30
37044: PUSH
37045: LD_INT 2
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 23
37054: PUSH
37055: LD_INT 3
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: LIST
37066: PPUSH
37067: CALL_OW 69
37071: IN
37072: IFFALSE 37099
// begin ComUpgrade ( building ) ;
37074: LD_VAR 0 1
37078: PPUSH
37079: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
37083: LD_EXP 63
37087: PPUSH
37088: LD_VAR 0 1
37092: PPUSH
37093: CALL 76721 0 2
// exit ;
37097: GO 37108
// end ; MCE_BuildingComplete ( building ) ;
37099: LD_VAR 0 1
37103: PPUSH
37104: CALL 67555 0 1
// end ;
37108: PPOPN 1
37110: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
37111: LD_VAR 0 1
37115: PPUSH
37116: LD_VAR 0 2
37120: PPUSH
37121: CALL 65610 0 2
// end ;
37125: PPOPN 2
37127: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
37128: LD_VAR 0 1
37132: PPUSH
37133: LD_VAR 0 2
37137: PPUSH
37138: LD_VAR 0 3
37142: PPUSH
37143: LD_VAR 0 4
37147: PPUSH
37148: LD_VAR 0 5
37152: PPUSH
37153: CALL 65230 0 5
// end ;
37157: PPOPN 5
37159: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetSide ( vehicle ) = 1 then
37160: LD_VAR 0 1
37164: PPUSH
37165: CALL_OW 255
37169: PUSH
37170: LD_INT 1
37172: EQUAL
37173: IFFALSE 37190
// amConstructCounter := Inc ( amConstructCounter ) ;
37175: LD_ADDR_EXP 39
37179: PUSH
37180: LD_EXP 39
37184: PPUSH
37185: CALL 107551 0 1
37189: ST_TO_ADDR
// SOS_VehicleConstructed ( vehicle , factory ) ;
37190: LD_VAR 0 1
37194: PPUSH
37195: LD_VAR 0 2
37199: PPUSH
37200: CALL 126184 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
37204: LD_VAR 0 1
37208: PPUSH
37209: LD_VAR 0 2
37213: PPUSH
37214: CALL 64783 0 2
// end ;
37218: PPOPN 2
37220: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
37221: LD_VAR 0 1
37225: PPUSH
37226: LD_VAR 0 2
37230: PPUSH
37231: LD_VAR 0 3
37235: PPUSH
37236: LD_VAR 0 4
37240: PPUSH
37241: CALL 64621 0 4
// end ;
37245: PPOPN 4
37247: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
37248: LD_VAR 0 1
37252: PPUSH
37253: LD_VAR 0 2
37257: PPUSH
37258: LD_VAR 0 3
37262: PPUSH
37263: CALL 64396 0 3
// end ;
37267: PPOPN 3
37269: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
37270: LD_VAR 0 1
37274: PPUSH
37275: LD_VAR 0 2
37279: PPUSH
37280: CALL 64281 0 2
// end ;
37284: PPOPN 2
37286: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
37287: LD_VAR 0 1
37291: PPUSH
37292: LD_VAR 0 2
37296: PPUSH
37297: CALL 68541 0 2
// end ;
37301: PPOPN 2
37303: END
// on EvacuateBuilding ( building , unit ) do begin if building = ru_specBar then
37304: LD_VAR 0 1
37308: PUSH
37309: LD_INT 460
37311: EQUAL
37312: IFFALSE 37334
// ComEnterUnit ( unit , HexInfo ( 227 , 136 ) ) ;
37314: LD_VAR 0 2
37318: PPUSH
37319: LD_INT 227
37321: PPUSH
37322: LD_INT 136
37324: PPUSH
37325: CALL_OW 428
37329: PPUSH
37330: CALL_OW 120
// end ;
37334: PPOPN 2
37336: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
37337: LD_VAR 0 1
37341: PPUSH
37342: CALL_OW 255
37346: PUSH
37347: LD_INT 4
37349: EQUAL
37350: PUSH
37351: LD_VAR 0 1
37355: PUSH
37356: LD_EXP 18
37360: PUSH
37361: LD_INT 1
37363: ARRAY
37364: IN
37365: AND
37366: PUSH
37367: LD_EXP 19
37371: AND
37372: IFFALSE 37391
// begin ComMoveXY ( driver , 61 , 93 ) ;
37374: LD_VAR 0 1
37378: PPUSH
37379: LD_INT 61
37381: PPUSH
37382: LD_INT 93
37384: PPUSH
37385: CALL_OW 111
// exit ;
37389: GO 37460
// end ; if GetSide ( driver ) = 3 and GetTag ( driver ) = 105 then
37391: LD_VAR 0 1
37395: PPUSH
37396: CALL_OW 255
37400: PUSH
37401: LD_INT 3
37403: EQUAL
37404: PUSH
37405: LD_VAR 0 1
37409: PPUSH
37410: CALL_OW 110
37414: PUSH
37415: LD_INT 105
37417: EQUAL
37418: AND
37419: IFFALSE 37436
// begin ComMoveXY ( driver , 187 , 92 ) ;
37421: LD_VAR 0 1
37425: PPUSH
37426: LD_INT 187
37428: PPUSH
37429: LD_INT 92
37431: PPUSH
37432: CALL_OW 111
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
37436: LD_VAR 0 1
37440: PPUSH
37441: LD_VAR 0 2
37445: PPUSH
37446: LD_VAR 0 3
37450: PPUSH
37451: LD_VAR 0 4
37455: PPUSH
37456: CALL 68757 0 4
// end ;
37460: PPOPN 4
37462: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
37463: LD_VAR 0 1
37467: PPUSH
37468: LD_VAR 0 2
37472: PPUSH
37473: CALL 64090 0 2
// end ;
37477: PPOPN 2
37479: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
37480: LD_VAR 0 1
37484: PPUSH
37485: CALL 126168 0 1
// end ; end_of_file
37489: PPOPN 1
37491: END
// every 0 0$30 trigger missionStage = 2 do var i , time ;
37492: LD_EXP 15
37496: PUSH
37497: LD_INT 2
37499: EQUAL
37500: IFFALSE 38017
37502: GO 37504
37504: DISABLE
37505: LD_INT 0
37507: PPUSH
37508: PPUSH
// begin time := 0 0$35 ;
37509: LD_ADDR_VAR 0 2
37513: PUSH
37514: LD_INT 1225
37516: ST_TO_ADDR
// repeat wait ( time ) ;
37517: LD_VAR 0 2
37521: PPUSH
37522: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
37526: LD_INT 1
37528: PPUSH
37529: LD_INT 5
37531: PPUSH
37532: CALL_OW 12
37536: PPUSH
37537: LD_INT 106
37539: PPUSH
37540: LD_INT 150
37542: PPUSH
37543: LD_INT 19
37545: PPUSH
37546: LD_INT 1
37548: PPUSH
37549: CALL_OW 56
// wait ( rand ( 0 0$13 , 0 0$22 ) ) ;
37553: LD_INT 455
37555: PPUSH
37556: LD_INT 770
37558: PPUSH
37559: CALL_OW 12
37563: PPUSH
37564: CALL_OW 67
// if Prob ( 50 ) then
37568: LD_INT 50
37570: PPUSH
37571: CALL_OW 13
37575: IFFALSE 37604
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
37577: LD_INT 1
37579: PPUSH
37580: LD_INT 5
37582: PPUSH
37583: CALL_OW 12
37587: PPUSH
37588: LD_INT 62
37590: PPUSH
37591: LD_INT 108
37593: PPUSH
37594: LD_INT 10
37596: PPUSH
37597: LD_INT 1
37599: PPUSH
37600: CALL_OW 56
// until missionStage > 4 ;
37604: LD_EXP 15
37608: PUSH
37609: LD_INT 4
37611: GREATER
37612: IFFALSE 37517
// repeat wait ( 0 0$1 ) ;
37614: LD_INT 35
37616: PPUSH
37617: CALL_OW 67
// until missionStage = 6 ;
37621: LD_EXP 15
37625: PUSH
37626: LD_INT 6
37628: EQUAL
37629: IFFALSE 37614
// time := 0 0$20 ;
37631: LD_ADDR_VAR 0 2
37635: PUSH
37636: LD_INT 700
37638: ST_TO_ADDR
// repeat wait ( time ) ;
37639: LD_VAR 0 2
37643: PPUSH
37644: CALL_OW 67
// if Prob ( 90 ) then
37648: LD_INT 90
37650: PPUSH
37651: CALL_OW 13
37655: IFFALSE 37698
// begin time := time + 0 0$2 ;
37657: LD_ADDR_VAR 0 2
37661: PUSH
37662: LD_VAR 0 2
37666: PUSH
37667: LD_INT 70
37669: PLUS
37670: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
37671: LD_INT 1
37673: PPUSH
37674: LD_INT 5
37676: PPUSH
37677: CALL_OW 12
37681: PPUSH
37682: LD_INT 106
37684: PPUSH
37685: LD_INT 89
37687: PPUSH
37688: LD_INT 45
37690: PPUSH
37691: LD_INT 1
37693: PPUSH
37694: CALL_OW 56
// end ; if Prob ( 45 ) then
37698: LD_INT 45
37700: PPUSH
37701: CALL_OW 13
37705: IFFALSE 37761
// begin for i := 1 to 4 do
37707: LD_ADDR_VAR 0 1
37711: PUSH
37712: DOUBLE
37713: LD_INT 1
37715: DEC
37716: ST_TO_ADDR
37717: LD_INT 4
37719: PUSH
37720: FOR_TO
37721: IFFALSE 37759
// begin wait ( 0 0$5 ) ;
37723: LD_INT 175
37725: PPUSH
37726: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 113 , 117 , 25 , true ) ;
37730: LD_INT 1
37732: PPUSH
37733: LD_INT 5
37735: PPUSH
37736: CALL_OW 12
37740: PPUSH
37741: LD_INT 113
37743: PPUSH
37744: LD_INT 117
37746: PPUSH
37747: LD_INT 25
37749: PPUSH
37750: LD_INT 1
37752: PPUSH
37753: CALL_OW 56
// end ;
37757: GO 37720
37759: POP
37760: POP
// end ; if Prob ( 40 ) then
37761: LD_INT 40
37763: PPUSH
37764: CALL_OW 13
37768: IFFALSE 37814
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
37770: LD_INT 385
37772: PPUSH
37773: LD_INT 945
37775: PPUSH
37776: CALL_OW 12
37780: PPUSH
37781: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
37785: LD_INT 1
37787: PPUSH
37788: LD_INT 5
37790: PPUSH
37791: CALL_OW 12
37795: PPUSH
37796: LD_INT 21
37798: PPUSH
37799: LD_INT 26
37801: PPUSH
37802: LD_INT 12
37804: PPUSH
37805: LD_INT 1
37807: PPUSH
37808: CALL_OW 56
// end else
37812: GO 37850
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
37814: LD_INT 700
37816: PPUSH
37817: LD_INT 1225
37819: PPUSH
37820: CALL_OW 12
37824: PPUSH
37825: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
37829: LD_INT 1
37831: PPUSH
37832: LD_INT 5
37834: PPUSH
37835: CALL_OW 12
37839: PPUSH
37840: LD_INT 16
37842: PPUSH
37843: LD_INT 1
37845: PPUSH
37846: CALL_OW 55
// end ; if Prob ( 50 ) then
37850: LD_INT 50
37852: PPUSH
37853: CALL_OW 13
37857: IFFALSE 37903
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
37859: LD_INT 700
37861: PPUSH
37862: LD_INT 1050
37864: PPUSH
37865: CALL_OW 12
37869: PPUSH
37870: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 168 , 168 , 16 , true ) ;
37874: LD_INT 1
37876: PPUSH
37877: LD_INT 5
37879: PPUSH
37880: CALL_OW 12
37884: PPUSH
37885: LD_INT 168
37887: PPUSH
37888: LD_INT 168
37890: PPUSH
37891: LD_INT 16
37893: PPUSH
37894: LD_INT 1
37896: PPUSH
37897: CALL_OW 56
// end else
37901: GO 37939
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
37903: LD_INT 350
37905: PPUSH
37906: LD_INT 525
37908: PPUSH
37909: CALL_OW 12
37913: PPUSH
37914: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
37918: LD_INT 1
37920: PPUSH
37921: LD_INT 5
37923: PPUSH
37924: CALL_OW 12
37928: PPUSH
37929: LD_INT 15
37931: PPUSH
37932: LD_INT 1
37934: PPUSH
37935: CALL_OW 55
// end ; wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
37939: LD_INT 175
37941: PPUSH
37942: LD_INT 315
37944: PPUSH
37945: CALL_OW 12
37949: PPUSH
37950: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
37954: LD_INT 1
37956: PPUSH
37957: LD_INT 5
37959: PPUSH
37960: CALL_OW 12
37964: PPUSH
37965: LD_INT 103
37967: PPUSH
37968: LD_INT 140
37970: PPUSH
37971: LD_INT 20
37973: PPUSH
37974: LD_INT 1
37976: PPUSH
37977: CALL_OW 56
// time := time + 0 0$2 ;
37981: LD_ADDR_VAR 0 2
37985: PUSH
37986: LD_VAR 0 2
37990: PUSH
37991: LD_INT 70
37993: PLUS
37994: ST_TO_ADDR
// if time > 1 1$20 then
37995: LD_VAR 0 2
37999: PUSH
38000: LD_INT 2800
38002: GREATER
38003: IFFALSE 38013
// time := 0 0$30 ;
38005: LD_ADDR_VAR 0 2
38009: PUSH
38010: LD_INT 1050
38012: ST_TO_ADDR
// until false ;
38013: LD_INT 0
38015: IFFALSE 37639
// end ; end_of_file
38017: PPOPN 2
38019: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
38020: LD_EXP 13
38024: PUSH
38025: LD_EXP 15
38029: PUSH
38030: LD_INT 6
38032: GREATEREQUAL
38033: AND
38034: IFFALSE 38071
38036: GO 38038
38038: DISABLE
// begin enable ;
38039: ENABLE
// missionTime := missionTime + 0 0$1 ;
38040: LD_ADDR_EXP 14
38044: PUSH
38045: LD_EXP 14
38049: PUSH
38050: LD_INT 35
38052: PLUS
38053: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
38054: LD_ADDR_OWVAR 47
38058: PUSH
38059: LD_STRING #Am15-1
38061: PUSH
38062: LD_EXP 14
38066: PUSH
38067: EMPTY
38068: LIST
38069: LIST
38070: ST_TO_ADDR
// end ; end_of_file
38071: END
// export function InitNature ; begin
38072: LD_INT 0
38074: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
38075: LD_INT 3
38077: PPUSH
38078: LD_INT 3
38080: PPUSH
38081: LD_INT 2
38083: PPUSH
38084: LD_INT 1
38086: PPUSH
38087: LD_INT 1
38089: PPUSH
38090: LD_INT 0
38092: PPUSH
38093: LD_INT 0
38095: PPUSH
38096: LD_INT 20
38098: PPUSH
38099: LD_INT 0
38101: PPUSH
38102: CALL 102880 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
38106: LD_INT 2
38108: PPUSH
38109: LD_INT 1
38111: PPUSH
38112: LD_INT 1
38114: PPUSH
38115: LD_INT 1
38117: PPUSH
38118: LD_INT 1
38120: PPUSH
38121: LD_INT 0
38123: PPUSH
38124: LD_INT 0
38126: PPUSH
38127: LD_INT 21
38129: PPUSH
38130: LD_INT 0
38132: PPUSH
38133: CALL 102880 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
38137: LD_INT 4
38139: PPUSH
38140: LD_INT 1
38142: PPUSH
38143: LD_INT 2
38145: PPUSH
38146: LD_INT 4
38148: PPUSH
38149: LD_INT 2
38151: PPUSH
38152: LD_INT 1
38154: PPUSH
38155: LD_INT 0
38157: PPUSH
38158: LD_INT 22
38160: PPUSH
38161: LD_INT 0
38163: PPUSH
38164: CALL 102880 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
38168: LD_INT 0
38170: PPUSH
38171: LD_INT 0
38173: PPUSH
38174: LD_INT 0
38176: PPUSH
38177: LD_INT 0
38179: PPUSH
38180: LD_INT 0
38182: PPUSH
38183: LD_INT 0
38185: PPUSH
38186: LD_INT 9
38188: PPUSH
38189: LD_INT 0
38191: PPUSH
38192: LD_INT 23
38194: PPUSH
38195: CALL 102880 0 9
// end ; end_of_file
38199: LD_VAR 0 1
38203: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
38204: LD_INT 0
38206: PPUSH
38207: PPUSH
// skirmish := false ;
38208: LD_ADDR_EXP 98
38212: PUSH
38213: LD_INT 0
38215: ST_TO_ADDR
// debug_mc := false ;
38216: LD_ADDR_EXP 99
38220: PUSH
38221: LD_INT 0
38223: ST_TO_ADDR
// mc_bases := [ ] ;
38224: LD_ADDR_EXP 100
38228: PUSH
38229: EMPTY
38230: ST_TO_ADDR
// mc_sides := [ ] ;
38231: LD_ADDR_EXP 126
38235: PUSH
38236: EMPTY
38237: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
38238: LD_ADDR_EXP 101
38242: PUSH
38243: EMPTY
38244: ST_TO_ADDR
// mc_building_repairs := [ ] ;
38245: LD_ADDR_EXP 102
38249: PUSH
38250: EMPTY
38251: ST_TO_ADDR
// mc_need_heal := [ ] ;
38252: LD_ADDR_EXP 103
38256: PUSH
38257: EMPTY
38258: ST_TO_ADDR
// mc_healers := [ ] ;
38259: LD_ADDR_EXP 104
38263: PUSH
38264: EMPTY
38265: ST_TO_ADDR
// mc_build_list := [ ] ;
38266: LD_ADDR_EXP 105
38270: PUSH
38271: EMPTY
38272: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
38273: LD_ADDR_EXP 132
38277: PUSH
38278: EMPTY
38279: ST_TO_ADDR
// mc_builders := [ ] ;
38280: LD_ADDR_EXP 106
38284: PUSH
38285: EMPTY
38286: ST_TO_ADDR
// mc_construct_list := [ ] ;
38287: LD_ADDR_EXP 107
38291: PUSH
38292: EMPTY
38293: ST_TO_ADDR
// mc_turret_list := [ ] ;
38294: LD_ADDR_EXP 108
38298: PUSH
38299: EMPTY
38300: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
38301: LD_ADDR_EXP 109
38305: PUSH
38306: EMPTY
38307: ST_TO_ADDR
// mc_miners := [ ] ;
38308: LD_ADDR_EXP 114
38312: PUSH
38313: EMPTY
38314: ST_TO_ADDR
// mc_mines := [ ] ;
38315: LD_ADDR_EXP 113
38319: PUSH
38320: EMPTY
38321: ST_TO_ADDR
// mc_minefields := [ ] ;
38322: LD_ADDR_EXP 115
38326: PUSH
38327: EMPTY
38328: ST_TO_ADDR
// mc_crates := [ ] ;
38329: LD_ADDR_EXP 116
38333: PUSH
38334: EMPTY
38335: ST_TO_ADDR
// mc_crates_collector := [ ] ;
38336: LD_ADDR_EXP 117
38340: PUSH
38341: EMPTY
38342: ST_TO_ADDR
// mc_crates_area := [ ] ;
38343: LD_ADDR_EXP 118
38347: PUSH
38348: EMPTY
38349: ST_TO_ADDR
// mc_vehicles := [ ] ;
38350: LD_ADDR_EXP 119
38354: PUSH
38355: EMPTY
38356: ST_TO_ADDR
// mc_attack := [ ] ;
38357: LD_ADDR_EXP 120
38361: PUSH
38362: EMPTY
38363: ST_TO_ADDR
// mc_produce := [ ] ;
38364: LD_ADDR_EXP 121
38368: PUSH
38369: EMPTY
38370: ST_TO_ADDR
// mc_defender := [ ] ;
38371: LD_ADDR_EXP 122
38375: PUSH
38376: EMPTY
38377: ST_TO_ADDR
// mc_parking := [ ] ;
38378: LD_ADDR_EXP 124
38382: PUSH
38383: EMPTY
38384: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
38385: LD_ADDR_EXP 110
38389: PUSH
38390: EMPTY
38391: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
38392: LD_ADDR_EXP 112
38396: PUSH
38397: EMPTY
38398: ST_TO_ADDR
// mc_scan := [ ] ;
38399: LD_ADDR_EXP 123
38403: PUSH
38404: EMPTY
38405: ST_TO_ADDR
// mc_scan_area := [ ] ;
38406: LD_ADDR_EXP 125
38410: PUSH
38411: EMPTY
38412: ST_TO_ADDR
// mc_tech := [ ] ;
38413: LD_ADDR_EXP 127
38417: PUSH
38418: EMPTY
38419: ST_TO_ADDR
// mc_class := [ ] ;
38420: LD_ADDR_EXP 141
38424: PUSH
38425: EMPTY
38426: ST_TO_ADDR
// mc_class_case_use := [ ] ;
38427: LD_ADDR_EXP 142
38431: PUSH
38432: EMPTY
38433: ST_TO_ADDR
// mc_is_defending := [ ] ;
38434: LD_ADDR_EXP 143
38438: PUSH
38439: EMPTY
38440: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
38441: LD_ADDR_EXP 134
38445: PUSH
38446: EMPTY
38447: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
38448: LD_ADDR_EXP 144
38452: PUSH
38453: LD_INT 0
38455: ST_TO_ADDR
// end ;
38456: LD_VAR 0 1
38460: RET
// export function MC_Kill ( base ) ; begin
38461: LD_INT 0
38463: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
38464: LD_ADDR_EXP 100
38468: PUSH
38469: LD_EXP 100
38473: PPUSH
38474: LD_VAR 0 1
38478: PPUSH
38479: EMPTY
38480: PPUSH
38481: CALL_OW 1
38485: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
38486: LD_ADDR_EXP 101
38490: PUSH
38491: LD_EXP 101
38495: PPUSH
38496: LD_VAR 0 1
38500: PPUSH
38501: EMPTY
38502: PPUSH
38503: CALL_OW 1
38507: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
38508: LD_ADDR_EXP 102
38512: PUSH
38513: LD_EXP 102
38517: PPUSH
38518: LD_VAR 0 1
38522: PPUSH
38523: EMPTY
38524: PPUSH
38525: CALL_OW 1
38529: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
38530: LD_ADDR_EXP 103
38534: PUSH
38535: LD_EXP 103
38539: PPUSH
38540: LD_VAR 0 1
38544: PPUSH
38545: EMPTY
38546: PPUSH
38547: CALL_OW 1
38551: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
38552: LD_ADDR_EXP 104
38556: PUSH
38557: LD_EXP 104
38561: PPUSH
38562: LD_VAR 0 1
38566: PPUSH
38567: EMPTY
38568: PPUSH
38569: CALL_OW 1
38573: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
38574: LD_ADDR_EXP 105
38578: PUSH
38579: LD_EXP 105
38583: PPUSH
38584: LD_VAR 0 1
38588: PPUSH
38589: EMPTY
38590: PPUSH
38591: CALL_OW 1
38595: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
38596: LD_ADDR_EXP 106
38600: PUSH
38601: LD_EXP 106
38605: PPUSH
38606: LD_VAR 0 1
38610: PPUSH
38611: EMPTY
38612: PPUSH
38613: CALL_OW 1
38617: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
38618: LD_ADDR_EXP 107
38622: PUSH
38623: LD_EXP 107
38627: PPUSH
38628: LD_VAR 0 1
38632: PPUSH
38633: EMPTY
38634: PPUSH
38635: CALL_OW 1
38639: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
38640: LD_ADDR_EXP 108
38644: PUSH
38645: LD_EXP 108
38649: PPUSH
38650: LD_VAR 0 1
38654: PPUSH
38655: EMPTY
38656: PPUSH
38657: CALL_OW 1
38661: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
38662: LD_ADDR_EXP 109
38666: PUSH
38667: LD_EXP 109
38671: PPUSH
38672: LD_VAR 0 1
38676: PPUSH
38677: EMPTY
38678: PPUSH
38679: CALL_OW 1
38683: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
38684: LD_ADDR_EXP 110
38688: PUSH
38689: LD_EXP 110
38693: PPUSH
38694: LD_VAR 0 1
38698: PPUSH
38699: EMPTY
38700: PPUSH
38701: CALL_OW 1
38705: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
38706: LD_ADDR_EXP 111
38710: PUSH
38711: LD_EXP 111
38715: PPUSH
38716: LD_VAR 0 1
38720: PPUSH
38721: LD_INT 0
38723: PPUSH
38724: CALL_OW 1
38728: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
38729: LD_ADDR_EXP 112
38733: PUSH
38734: LD_EXP 112
38738: PPUSH
38739: LD_VAR 0 1
38743: PPUSH
38744: EMPTY
38745: PPUSH
38746: CALL_OW 1
38750: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
38751: LD_ADDR_EXP 113
38755: PUSH
38756: LD_EXP 113
38760: PPUSH
38761: LD_VAR 0 1
38765: PPUSH
38766: EMPTY
38767: PPUSH
38768: CALL_OW 1
38772: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
38773: LD_ADDR_EXP 114
38777: PUSH
38778: LD_EXP 114
38782: PPUSH
38783: LD_VAR 0 1
38787: PPUSH
38788: EMPTY
38789: PPUSH
38790: CALL_OW 1
38794: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
38795: LD_ADDR_EXP 115
38799: PUSH
38800: LD_EXP 115
38804: PPUSH
38805: LD_VAR 0 1
38809: PPUSH
38810: EMPTY
38811: PPUSH
38812: CALL_OW 1
38816: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
38817: LD_ADDR_EXP 116
38821: PUSH
38822: LD_EXP 116
38826: PPUSH
38827: LD_VAR 0 1
38831: PPUSH
38832: EMPTY
38833: PPUSH
38834: CALL_OW 1
38838: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
38839: LD_ADDR_EXP 117
38843: PUSH
38844: LD_EXP 117
38848: PPUSH
38849: LD_VAR 0 1
38853: PPUSH
38854: EMPTY
38855: PPUSH
38856: CALL_OW 1
38860: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
38861: LD_ADDR_EXP 118
38865: PUSH
38866: LD_EXP 118
38870: PPUSH
38871: LD_VAR 0 1
38875: PPUSH
38876: EMPTY
38877: PPUSH
38878: CALL_OW 1
38882: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
38883: LD_ADDR_EXP 119
38887: PUSH
38888: LD_EXP 119
38892: PPUSH
38893: LD_VAR 0 1
38897: PPUSH
38898: EMPTY
38899: PPUSH
38900: CALL_OW 1
38904: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
38905: LD_ADDR_EXP 120
38909: PUSH
38910: LD_EXP 120
38914: PPUSH
38915: LD_VAR 0 1
38919: PPUSH
38920: EMPTY
38921: PPUSH
38922: CALL_OW 1
38926: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
38927: LD_ADDR_EXP 121
38931: PUSH
38932: LD_EXP 121
38936: PPUSH
38937: LD_VAR 0 1
38941: PPUSH
38942: EMPTY
38943: PPUSH
38944: CALL_OW 1
38948: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
38949: LD_ADDR_EXP 122
38953: PUSH
38954: LD_EXP 122
38958: PPUSH
38959: LD_VAR 0 1
38963: PPUSH
38964: EMPTY
38965: PPUSH
38966: CALL_OW 1
38970: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
38971: LD_ADDR_EXP 123
38975: PUSH
38976: LD_EXP 123
38980: PPUSH
38981: LD_VAR 0 1
38985: PPUSH
38986: EMPTY
38987: PPUSH
38988: CALL_OW 1
38992: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
38993: LD_ADDR_EXP 124
38997: PUSH
38998: LD_EXP 124
39002: PPUSH
39003: LD_VAR 0 1
39007: PPUSH
39008: EMPTY
39009: PPUSH
39010: CALL_OW 1
39014: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39015: LD_ADDR_EXP 125
39019: PUSH
39020: LD_EXP 125
39024: PPUSH
39025: LD_VAR 0 1
39029: PPUSH
39030: EMPTY
39031: PPUSH
39032: CALL_OW 1
39036: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
39037: LD_ADDR_EXP 127
39041: PUSH
39042: LD_EXP 127
39046: PPUSH
39047: LD_VAR 0 1
39051: PPUSH
39052: EMPTY
39053: PPUSH
39054: CALL_OW 1
39058: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
39059: LD_ADDR_EXP 129
39063: PUSH
39064: LD_EXP 129
39068: PPUSH
39069: LD_VAR 0 1
39073: PPUSH
39074: EMPTY
39075: PPUSH
39076: CALL_OW 1
39080: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
39081: LD_ADDR_EXP 130
39085: PUSH
39086: LD_EXP 130
39090: PPUSH
39091: LD_VAR 0 1
39095: PPUSH
39096: EMPTY
39097: PPUSH
39098: CALL_OW 1
39102: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
39103: LD_ADDR_EXP 131
39107: PUSH
39108: LD_EXP 131
39112: PPUSH
39113: LD_VAR 0 1
39117: PPUSH
39118: EMPTY
39119: PPUSH
39120: CALL_OW 1
39124: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
39125: LD_ADDR_EXP 132
39129: PUSH
39130: LD_EXP 132
39134: PPUSH
39135: LD_VAR 0 1
39139: PPUSH
39140: EMPTY
39141: PPUSH
39142: CALL_OW 1
39146: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
39147: LD_ADDR_EXP 133
39151: PUSH
39152: LD_EXP 133
39156: PPUSH
39157: LD_VAR 0 1
39161: PPUSH
39162: EMPTY
39163: PPUSH
39164: CALL_OW 1
39168: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
39169: LD_ADDR_EXP 134
39173: PUSH
39174: LD_EXP 134
39178: PPUSH
39179: LD_VAR 0 1
39183: PPUSH
39184: EMPTY
39185: PPUSH
39186: CALL_OW 1
39190: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
39191: LD_ADDR_EXP 135
39195: PUSH
39196: LD_EXP 135
39200: PPUSH
39201: LD_VAR 0 1
39205: PPUSH
39206: EMPTY
39207: PPUSH
39208: CALL_OW 1
39212: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
39213: LD_ADDR_EXP 136
39217: PUSH
39218: LD_EXP 136
39222: PPUSH
39223: LD_VAR 0 1
39227: PPUSH
39228: EMPTY
39229: PPUSH
39230: CALL_OW 1
39234: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
39235: LD_ADDR_EXP 137
39239: PUSH
39240: LD_EXP 137
39244: PPUSH
39245: LD_VAR 0 1
39249: PPUSH
39250: EMPTY
39251: PPUSH
39252: CALL_OW 1
39256: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
39257: LD_ADDR_EXP 138
39261: PUSH
39262: LD_EXP 138
39266: PPUSH
39267: LD_VAR 0 1
39271: PPUSH
39272: EMPTY
39273: PPUSH
39274: CALL_OW 1
39278: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
39279: LD_ADDR_EXP 139
39283: PUSH
39284: LD_EXP 139
39288: PPUSH
39289: LD_VAR 0 1
39293: PPUSH
39294: EMPTY
39295: PPUSH
39296: CALL_OW 1
39300: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
39301: LD_ADDR_EXP 140
39305: PUSH
39306: LD_EXP 140
39310: PPUSH
39311: LD_VAR 0 1
39315: PPUSH
39316: EMPTY
39317: PPUSH
39318: CALL_OW 1
39322: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
39323: LD_ADDR_EXP 141
39327: PUSH
39328: LD_EXP 141
39332: PPUSH
39333: LD_VAR 0 1
39337: PPUSH
39338: EMPTY
39339: PPUSH
39340: CALL_OW 1
39344: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
39345: LD_ADDR_EXP 142
39349: PUSH
39350: LD_EXP 142
39354: PPUSH
39355: LD_VAR 0 1
39359: PPUSH
39360: LD_INT 0
39362: PPUSH
39363: CALL_OW 1
39367: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
39368: LD_ADDR_EXP 143
39372: PUSH
39373: LD_EXP 143
39377: PPUSH
39378: LD_VAR 0 1
39382: PPUSH
39383: LD_INT 0
39385: PPUSH
39386: CALL_OW 1
39390: ST_TO_ADDR
// end ;
39391: LD_VAR 0 2
39395: RET
// export function MC_Add ( side , units ) ; var base ; begin
39396: LD_INT 0
39398: PPUSH
39399: PPUSH
// base := mc_bases + 1 ;
39400: LD_ADDR_VAR 0 4
39404: PUSH
39405: LD_EXP 100
39409: PUSH
39410: LD_INT 1
39412: PLUS
39413: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
39414: LD_ADDR_EXP 126
39418: PUSH
39419: LD_EXP 126
39423: PPUSH
39424: LD_VAR 0 4
39428: PPUSH
39429: LD_VAR 0 1
39433: PPUSH
39434: CALL_OW 1
39438: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
39439: LD_ADDR_EXP 100
39443: PUSH
39444: LD_EXP 100
39448: PPUSH
39449: LD_VAR 0 4
39453: PPUSH
39454: LD_VAR 0 2
39458: PPUSH
39459: CALL_OW 1
39463: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
39464: LD_ADDR_EXP 101
39468: PUSH
39469: LD_EXP 101
39473: PPUSH
39474: LD_VAR 0 4
39478: PPUSH
39479: EMPTY
39480: PPUSH
39481: CALL_OW 1
39485: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
39486: LD_ADDR_EXP 102
39490: PUSH
39491: LD_EXP 102
39495: PPUSH
39496: LD_VAR 0 4
39500: PPUSH
39501: EMPTY
39502: PPUSH
39503: CALL_OW 1
39507: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
39508: LD_ADDR_EXP 103
39512: PUSH
39513: LD_EXP 103
39517: PPUSH
39518: LD_VAR 0 4
39522: PPUSH
39523: EMPTY
39524: PPUSH
39525: CALL_OW 1
39529: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
39530: LD_ADDR_EXP 104
39534: PUSH
39535: LD_EXP 104
39539: PPUSH
39540: LD_VAR 0 4
39544: PPUSH
39545: EMPTY
39546: PPUSH
39547: CALL_OW 1
39551: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
39552: LD_ADDR_EXP 105
39556: PUSH
39557: LD_EXP 105
39561: PPUSH
39562: LD_VAR 0 4
39566: PPUSH
39567: EMPTY
39568: PPUSH
39569: CALL_OW 1
39573: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
39574: LD_ADDR_EXP 106
39578: PUSH
39579: LD_EXP 106
39583: PPUSH
39584: LD_VAR 0 4
39588: PPUSH
39589: EMPTY
39590: PPUSH
39591: CALL_OW 1
39595: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
39596: LD_ADDR_EXP 107
39600: PUSH
39601: LD_EXP 107
39605: PPUSH
39606: LD_VAR 0 4
39610: PPUSH
39611: EMPTY
39612: PPUSH
39613: CALL_OW 1
39617: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
39618: LD_ADDR_EXP 108
39622: PUSH
39623: LD_EXP 108
39627: PPUSH
39628: LD_VAR 0 4
39632: PPUSH
39633: EMPTY
39634: PPUSH
39635: CALL_OW 1
39639: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
39640: LD_ADDR_EXP 109
39644: PUSH
39645: LD_EXP 109
39649: PPUSH
39650: LD_VAR 0 4
39654: PPUSH
39655: EMPTY
39656: PPUSH
39657: CALL_OW 1
39661: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
39662: LD_ADDR_EXP 110
39666: PUSH
39667: LD_EXP 110
39671: PPUSH
39672: LD_VAR 0 4
39676: PPUSH
39677: EMPTY
39678: PPUSH
39679: CALL_OW 1
39683: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
39684: LD_ADDR_EXP 111
39688: PUSH
39689: LD_EXP 111
39693: PPUSH
39694: LD_VAR 0 4
39698: PPUSH
39699: LD_INT 0
39701: PPUSH
39702: CALL_OW 1
39706: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
39707: LD_ADDR_EXP 112
39711: PUSH
39712: LD_EXP 112
39716: PPUSH
39717: LD_VAR 0 4
39721: PPUSH
39722: EMPTY
39723: PPUSH
39724: CALL_OW 1
39728: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
39729: LD_ADDR_EXP 113
39733: PUSH
39734: LD_EXP 113
39738: PPUSH
39739: LD_VAR 0 4
39743: PPUSH
39744: EMPTY
39745: PPUSH
39746: CALL_OW 1
39750: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
39751: LD_ADDR_EXP 114
39755: PUSH
39756: LD_EXP 114
39760: PPUSH
39761: LD_VAR 0 4
39765: PPUSH
39766: EMPTY
39767: PPUSH
39768: CALL_OW 1
39772: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
39773: LD_ADDR_EXP 115
39777: PUSH
39778: LD_EXP 115
39782: PPUSH
39783: LD_VAR 0 4
39787: PPUSH
39788: EMPTY
39789: PPUSH
39790: CALL_OW 1
39794: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
39795: LD_ADDR_EXP 116
39799: PUSH
39800: LD_EXP 116
39804: PPUSH
39805: LD_VAR 0 4
39809: PPUSH
39810: EMPTY
39811: PPUSH
39812: CALL_OW 1
39816: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
39817: LD_ADDR_EXP 117
39821: PUSH
39822: LD_EXP 117
39826: PPUSH
39827: LD_VAR 0 4
39831: PPUSH
39832: EMPTY
39833: PPUSH
39834: CALL_OW 1
39838: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
39839: LD_ADDR_EXP 118
39843: PUSH
39844: LD_EXP 118
39848: PPUSH
39849: LD_VAR 0 4
39853: PPUSH
39854: EMPTY
39855: PPUSH
39856: CALL_OW 1
39860: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
39861: LD_ADDR_EXP 119
39865: PUSH
39866: LD_EXP 119
39870: PPUSH
39871: LD_VAR 0 4
39875: PPUSH
39876: EMPTY
39877: PPUSH
39878: CALL_OW 1
39882: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
39883: LD_ADDR_EXP 120
39887: PUSH
39888: LD_EXP 120
39892: PPUSH
39893: LD_VAR 0 4
39897: PPUSH
39898: EMPTY
39899: PPUSH
39900: CALL_OW 1
39904: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
39905: LD_ADDR_EXP 121
39909: PUSH
39910: LD_EXP 121
39914: PPUSH
39915: LD_VAR 0 4
39919: PPUSH
39920: EMPTY
39921: PPUSH
39922: CALL_OW 1
39926: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
39927: LD_ADDR_EXP 122
39931: PUSH
39932: LD_EXP 122
39936: PPUSH
39937: LD_VAR 0 4
39941: PPUSH
39942: EMPTY
39943: PPUSH
39944: CALL_OW 1
39948: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
39949: LD_ADDR_EXP 123
39953: PUSH
39954: LD_EXP 123
39958: PPUSH
39959: LD_VAR 0 4
39963: PPUSH
39964: EMPTY
39965: PPUSH
39966: CALL_OW 1
39970: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
39971: LD_ADDR_EXP 124
39975: PUSH
39976: LD_EXP 124
39980: PPUSH
39981: LD_VAR 0 4
39985: PPUSH
39986: EMPTY
39987: PPUSH
39988: CALL_OW 1
39992: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
39993: LD_ADDR_EXP 125
39997: PUSH
39998: LD_EXP 125
40002: PPUSH
40003: LD_VAR 0 4
40007: PPUSH
40008: EMPTY
40009: PPUSH
40010: CALL_OW 1
40014: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
40015: LD_ADDR_EXP 127
40019: PUSH
40020: LD_EXP 127
40024: PPUSH
40025: LD_VAR 0 4
40029: PPUSH
40030: EMPTY
40031: PPUSH
40032: CALL_OW 1
40036: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
40037: LD_ADDR_EXP 129
40041: PUSH
40042: LD_EXP 129
40046: PPUSH
40047: LD_VAR 0 4
40051: PPUSH
40052: EMPTY
40053: PPUSH
40054: CALL_OW 1
40058: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
40059: LD_ADDR_EXP 130
40063: PUSH
40064: LD_EXP 130
40068: PPUSH
40069: LD_VAR 0 4
40073: PPUSH
40074: EMPTY
40075: PPUSH
40076: CALL_OW 1
40080: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
40081: LD_ADDR_EXP 131
40085: PUSH
40086: LD_EXP 131
40090: PPUSH
40091: LD_VAR 0 4
40095: PPUSH
40096: EMPTY
40097: PPUSH
40098: CALL_OW 1
40102: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
40103: LD_ADDR_EXP 132
40107: PUSH
40108: LD_EXP 132
40112: PPUSH
40113: LD_VAR 0 4
40117: PPUSH
40118: EMPTY
40119: PPUSH
40120: CALL_OW 1
40124: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
40125: LD_ADDR_EXP 133
40129: PUSH
40130: LD_EXP 133
40134: PPUSH
40135: LD_VAR 0 4
40139: PPUSH
40140: EMPTY
40141: PPUSH
40142: CALL_OW 1
40146: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
40147: LD_ADDR_EXP 134
40151: PUSH
40152: LD_EXP 134
40156: PPUSH
40157: LD_VAR 0 4
40161: PPUSH
40162: EMPTY
40163: PPUSH
40164: CALL_OW 1
40168: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
40169: LD_ADDR_EXP 135
40173: PUSH
40174: LD_EXP 135
40178: PPUSH
40179: LD_VAR 0 4
40183: PPUSH
40184: EMPTY
40185: PPUSH
40186: CALL_OW 1
40190: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
40191: LD_ADDR_EXP 136
40195: PUSH
40196: LD_EXP 136
40200: PPUSH
40201: LD_VAR 0 4
40205: PPUSH
40206: EMPTY
40207: PPUSH
40208: CALL_OW 1
40212: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
40213: LD_ADDR_EXP 137
40217: PUSH
40218: LD_EXP 137
40222: PPUSH
40223: LD_VAR 0 4
40227: PPUSH
40228: EMPTY
40229: PPUSH
40230: CALL_OW 1
40234: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
40235: LD_ADDR_EXP 138
40239: PUSH
40240: LD_EXP 138
40244: PPUSH
40245: LD_VAR 0 4
40249: PPUSH
40250: EMPTY
40251: PPUSH
40252: CALL_OW 1
40256: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
40257: LD_ADDR_EXP 139
40261: PUSH
40262: LD_EXP 139
40266: PPUSH
40267: LD_VAR 0 4
40271: PPUSH
40272: EMPTY
40273: PPUSH
40274: CALL_OW 1
40278: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
40279: LD_ADDR_EXP 140
40283: PUSH
40284: LD_EXP 140
40288: PPUSH
40289: LD_VAR 0 4
40293: PPUSH
40294: EMPTY
40295: PPUSH
40296: CALL_OW 1
40300: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
40301: LD_ADDR_EXP 141
40305: PUSH
40306: LD_EXP 141
40310: PPUSH
40311: LD_VAR 0 4
40315: PPUSH
40316: EMPTY
40317: PPUSH
40318: CALL_OW 1
40322: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
40323: LD_ADDR_EXP 142
40327: PUSH
40328: LD_EXP 142
40332: PPUSH
40333: LD_VAR 0 4
40337: PPUSH
40338: LD_INT 0
40340: PPUSH
40341: CALL_OW 1
40345: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
40346: LD_ADDR_EXP 143
40350: PUSH
40351: LD_EXP 143
40355: PPUSH
40356: LD_VAR 0 4
40360: PPUSH
40361: LD_INT 0
40363: PPUSH
40364: CALL_OW 1
40368: ST_TO_ADDR
// result := base ;
40369: LD_ADDR_VAR 0 3
40373: PUSH
40374: LD_VAR 0 4
40378: ST_TO_ADDR
// end ;
40379: LD_VAR 0 3
40383: RET
// export function MC_Start ( ) ; var i ; begin
40384: LD_INT 0
40386: PPUSH
40387: PPUSH
// for i = 1 to mc_bases do
40388: LD_ADDR_VAR 0 2
40392: PUSH
40393: DOUBLE
40394: LD_INT 1
40396: DEC
40397: ST_TO_ADDR
40398: LD_EXP 100
40402: PUSH
40403: FOR_TO
40404: IFFALSE 41504
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
40406: LD_ADDR_EXP 100
40410: PUSH
40411: LD_EXP 100
40415: PPUSH
40416: LD_VAR 0 2
40420: PPUSH
40421: LD_EXP 100
40425: PUSH
40426: LD_VAR 0 2
40430: ARRAY
40431: PUSH
40432: LD_INT 0
40434: DIFF
40435: PPUSH
40436: CALL_OW 1
40440: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
40441: LD_ADDR_EXP 101
40445: PUSH
40446: LD_EXP 101
40450: PPUSH
40451: LD_VAR 0 2
40455: PPUSH
40456: EMPTY
40457: PPUSH
40458: CALL_OW 1
40462: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
40463: LD_ADDR_EXP 102
40467: PUSH
40468: LD_EXP 102
40472: PPUSH
40473: LD_VAR 0 2
40477: PPUSH
40478: EMPTY
40479: PPUSH
40480: CALL_OW 1
40484: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
40485: LD_ADDR_EXP 103
40489: PUSH
40490: LD_EXP 103
40494: PPUSH
40495: LD_VAR 0 2
40499: PPUSH
40500: EMPTY
40501: PPUSH
40502: CALL_OW 1
40506: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
40507: LD_ADDR_EXP 104
40511: PUSH
40512: LD_EXP 104
40516: PPUSH
40517: LD_VAR 0 2
40521: PPUSH
40522: EMPTY
40523: PUSH
40524: EMPTY
40525: PUSH
40526: EMPTY
40527: LIST
40528: LIST
40529: PPUSH
40530: CALL_OW 1
40534: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
40535: LD_ADDR_EXP 105
40539: PUSH
40540: LD_EXP 105
40544: PPUSH
40545: LD_VAR 0 2
40549: PPUSH
40550: EMPTY
40551: PPUSH
40552: CALL_OW 1
40556: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
40557: LD_ADDR_EXP 132
40561: PUSH
40562: LD_EXP 132
40566: PPUSH
40567: LD_VAR 0 2
40571: PPUSH
40572: EMPTY
40573: PPUSH
40574: CALL_OW 1
40578: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
40579: LD_ADDR_EXP 106
40583: PUSH
40584: LD_EXP 106
40588: PPUSH
40589: LD_VAR 0 2
40593: PPUSH
40594: EMPTY
40595: PPUSH
40596: CALL_OW 1
40600: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
40601: LD_ADDR_EXP 107
40605: PUSH
40606: LD_EXP 107
40610: PPUSH
40611: LD_VAR 0 2
40615: PPUSH
40616: EMPTY
40617: PPUSH
40618: CALL_OW 1
40622: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
40623: LD_ADDR_EXP 108
40627: PUSH
40628: LD_EXP 108
40632: PPUSH
40633: LD_VAR 0 2
40637: PPUSH
40638: LD_EXP 100
40642: PUSH
40643: LD_VAR 0 2
40647: ARRAY
40648: PPUSH
40649: LD_INT 2
40651: PUSH
40652: LD_INT 30
40654: PUSH
40655: LD_INT 32
40657: PUSH
40658: EMPTY
40659: LIST
40660: LIST
40661: PUSH
40662: LD_INT 30
40664: PUSH
40665: LD_INT 33
40667: PUSH
40668: EMPTY
40669: LIST
40670: LIST
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: LIST
40676: PPUSH
40677: CALL_OW 72
40681: PPUSH
40682: CALL_OW 1
40686: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
40687: LD_ADDR_EXP 109
40691: PUSH
40692: LD_EXP 109
40696: PPUSH
40697: LD_VAR 0 2
40701: PPUSH
40702: LD_EXP 100
40706: PUSH
40707: LD_VAR 0 2
40711: ARRAY
40712: PPUSH
40713: LD_INT 2
40715: PUSH
40716: LD_INT 30
40718: PUSH
40719: LD_INT 32
40721: PUSH
40722: EMPTY
40723: LIST
40724: LIST
40725: PUSH
40726: LD_INT 30
40728: PUSH
40729: LD_INT 31
40731: PUSH
40732: EMPTY
40733: LIST
40734: LIST
40735: PUSH
40736: EMPTY
40737: LIST
40738: LIST
40739: LIST
40740: PUSH
40741: LD_INT 58
40743: PUSH
40744: EMPTY
40745: LIST
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: PPUSH
40751: CALL_OW 72
40755: PPUSH
40756: CALL_OW 1
40760: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
40761: LD_ADDR_EXP 110
40765: PUSH
40766: LD_EXP 110
40770: PPUSH
40771: LD_VAR 0 2
40775: PPUSH
40776: EMPTY
40777: PPUSH
40778: CALL_OW 1
40782: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
40783: LD_ADDR_EXP 114
40787: PUSH
40788: LD_EXP 114
40792: PPUSH
40793: LD_VAR 0 2
40797: PPUSH
40798: EMPTY
40799: PPUSH
40800: CALL_OW 1
40804: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
40805: LD_ADDR_EXP 113
40809: PUSH
40810: LD_EXP 113
40814: PPUSH
40815: LD_VAR 0 2
40819: PPUSH
40820: EMPTY
40821: PPUSH
40822: CALL_OW 1
40826: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
40827: LD_ADDR_EXP 115
40831: PUSH
40832: LD_EXP 115
40836: PPUSH
40837: LD_VAR 0 2
40841: PPUSH
40842: EMPTY
40843: PPUSH
40844: CALL_OW 1
40848: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
40849: LD_ADDR_EXP 116
40853: PUSH
40854: LD_EXP 116
40858: PPUSH
40859: LD_VAR 0 2
40863: PPUSH
40864: EMPTY
40865: PPUSH
40866: CALL_OW 1
40870: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
40871: LD_ADDR_EXP 117
40875: PUSH
40876: LD_EXP 117
40880: PPUSH
40881: LD_VAR 0 2
40885: PPUSH
40886: EMPTY
40887: PPUSH
40888: CALL_OW 1
40892: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
40893: LD_ADDR_EXP 118
40897: PUSH
40898: LD_EXP 118
40902: PPUSH
40903: LD_VAR 0 2
40907: PPUSH
40908: EMPTY
40909: PPUSH
40910: CALL_OW 1
40914: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
40915: LD_ADDR_EXP 119
40919: PUSH
40920: LD_EXP 119
40924: PPUSH
40925: LD_VAR 0 2
40929: PPUSH
40930: EMPTY
40931: PPUSH
40932: CALL_OW 1
40936: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
40937: LD_ADDR_EXP 120
40941: PUSH
40942: LD_EXP 120
40946: PPUSH
40947: LD_VAR 0 2
40951: PPUSH
40952: EMPTY
40953: PPUSH
40954: CALL_OW 1
40958: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
40959: LD_ADDR_EXP 121
40963: PUSH
40964: LD_EXP 121
40968: PPUSH
40969: LD_VAR 0 2
40973: PPUSH
40974: EMPTY
40975: PPUSH
40976: CALL_OW 1
40980: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
40981: LD_ADDR_EXP 122
40985: PUSH
40986: LD_EXP 122
40990: PPUSH
40991: LD_VAR 0 2
40995: PPUSH
40996: EMPTY
40997: PPUSH
40998: CALL_OW 1
41002: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
41003: LD_ADDR_EXP 111
41007: PUSH
41008: LD_EXP 111
41012: PPUSH
41013: LD_VAR 0 2
41017: PPUSH
41018: LD_INT 0
41020: PPUSH
41021: CALL_OW 1
41025: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
41026: LD_ADDR_EXP 124
41030: PUSH
41031: LD_EXP 124
41035: PPUSH
41036: LD_VAR 0 2
41040: PPUSH
41041: LD_INT 0
41043: PPUSH
41044: CALL_OW 1
41048: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
41049: LD_ADDR_EXP 112
41053: PUSH
41054: LD_EXP 112
41058: PPUSH
41059: LD_VAR 0 2
41063: PPUSH
41064: EMPTY
41065: PPUSH
41066: CALL_OW 1
41070: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
41071: LD_ADDR_EXP 123
41075: PUSH
41076: LD_EXP 123
41080: PPUSH
41081: LD_VAR 0 2
41085: PPUSH
41086: LD_INT 0
41088: PPUSH
41089: CALL_OW 1
41093: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
41094: LD_ADDR_EXP 125
41098: PUSH
41099: LD_EXP 125
41103: PPUSH
41104: LD_VAR 0 2
41108: PPUSH
41109: EMPTY
41110: PPUSH
41111: CALL_OW 1
41115: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
41116: LD_ADDR_EXP 128
41120: PUSH
41121: LD_EXP 128
41125: PPUSH
41126: LD_VAR 0 2
41130: PPUSH
41131: LD_INT 0
41133: PPUSH
41134: CALL_OW 1
41138: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
41139: LD_ADDR_EXP 129
41143: PUSH
41144: LD_EXP 129
41148: PPUSH
41149: LD_VAR 0 2
41153: PPUSH
41154: EMPTY
41155: PPUSH
41156: CALL_OW 1
41160: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
41161: LD_ADDR_EXP 130
41165: PUSH
41166: LD_EXP 130
41170: PPUSH
41171: LD_VAR 0 2
41175: PPUSH
41176: EMPTY
41177: PPUSH
41178: CALL_OW 1
41182: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
41183: LD_ADDR_EXP 131
41187: PUSH
41188: LD_EXP 131
41192: PPUSH
41193: LD_VAR 0 2
41197: PPUSH
41198: EMPTY
41199: PPUSH
41200: CALL_OW 1
41204: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
41205: LD_ADDR_EXP 133
41209: PUSH
41210: LD_EXP 133
41214: PPUSH
41215: LD_VAR 0 2
41219: PPUSH
41220: LD_EXP 100
41224: PUSH
41225: LD_VAR 0 2
41229: ARRAY
41230: PPUSH
41231: LD_INT 2
41233: PUSH
41234: LD_INT 30
41236: PUSH
41237: LD_INT 6
41239: PUSH
41240: EMPTY
41241: LIST
41242: LIST
41243: PUSH
41244: LD_INT 30
41246: PUSH
41247: LD_INT 7
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 30
41256: PUSH
41257: LD_INT 8
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: LIST
41268: LIST
41269: PPUSH
41270: CALL_OW 72
41274: PPUSH
41275: CALL_OW 1
41279: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
41280: LD_ADDR_EXP 134
41284: PUSH
41285: LD_EXP 134
41289: PPUSH
41290: LD_VAR 0 2
41294: PPUSH
41295: EMPTY
41296: PPUSH
41297: CALL_OW 1
41301: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
41302: LD_ADDR_EXP 135
41306: PUSH
41307: LD_EXP 135
41311: PPUSH
41312: LD_VAR 0 2
41316: PPUSH
41317: EMPTY
41318: PPUSH
41319: CALL_OW 1
41323: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
41324: LD_ADDR_EXP 136
41328: PUSH
41329: LD_EXP 136
41333: PPUSH
41334: LD_VAR 0 2
41338: PPUSH
41339: EMPTY
41340: PPUSH
41341: CALL_OW 1
41345: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
41346: LD_ADDR_EXP 137
41350: PUSH
41351: LD_EXP 137
41355: PPUSH
41356: LD_VAR 0 2
41360: PPUSH
41361: EMPTY
41362: PPUSH
41363: CALL_OW 1
41367: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
41368: LD_ADDR_EXP 138
41372: PUSH
41373: LD_EXP 138
41377: PPUSH
41378: LD_VAR 0 2
41382: PPUSH
41383: EMPTY
41384: PPUSH
41385: CALL_OW 1
41389: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
41390: LD_ADDR_EXP 139
41394: PUSH
41395: LD_EXP 139
41399: PPUSH
41400: LD_VAR 0 2
41404: PPUSH
41405: EMPTY
41406: PPUSH
41407: CALL_OW 1
41411: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
41412: LD_ADDR_EXP 140
41416: PUSH
41417: LD_EXP 140
41421: PPUSH
41422: LD_VAR 0 2
41426: PPUSH
41427: EMPTY
41428: PPUSH
41429: CALL_OW 1
41433: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
41434: LD_ADDR_EXP 141
41438: PUSH
41439: LD_EXP 141
41443: PPUSH
41444: LD_VAR 0 2
41448: PPUSH
41449: EMPTY
41450: PPUSH
41451: CALL_OW 1
41455: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
41456: LD_ADDR_EXP 142
41460: PUSH
41461: LD_EXP 142
41465: PPUSH
41466: LD_VAR 0 2
41470: PPUSH
41471: LD_INT 0
41473: PPUSH
41474: CALL_OW 1
41478: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
41479: LD_ADDR_EXP 143
41483: PUSH
41484: LD_EXP 143
41488: PPUSH
41489: LD_VAR 0 2
41493: PPUSH
41494: LD_INT 0
41496: PPUSH
41497: CALL_OW 1
41501: ST_TO_ADDR
// end ;
41502: GO 40403
41504: POP
41505: POP
// MC_InitSides ( ) ;
41506: CALL 41792 0 0
// MC_InitResearch ( ) ;
41510: CALL 41531 0 0
// CustomInitMacro ( ) ;
41514: CALL 475 0 0
// skirmish := true ;
41518: LD_ADDR_EXP 98
41522: PUSH
41523: LD_INT 1
41525: ST_TO_ADDR
// end ;
41526: LD_VAR 0 1
41530: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
41531: LD_INT 0
41533: PPUSH
41534: PPUSH
41535: PPUSH
41536: PPUSH
41537: PPUSH
41538: PPUSH
// if not mc_bases then
41539: LD_EXP 100
41543: NOT
41544: IFFALSE 41548
// exit ;
41546: GO 41787
// for i = 1 to 8 do
41548: LD_ADDR_VAR 0 2
41552: PUSH
41553: DOUBLE
41554: LD_INT 1
41556: DEC
41557: ST_TO_ADDR
41558: LD_INT 8
41560: PUSH
41561: FOR_TO
41562: IFFALSE 41588
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
41564: LD_ADDR_EXP 127
41568: PUSH
41569: LD_EXP 127
41573: PPUSH
41574: LD_VAR 0 2
41578: PPUSH
41579: EMPTY
41580: PPUSH
41581: CALL_OW 1
41585: ST_TO_ADDR
41586: GO 41561
41588: POP
41589: POP
// tmp := [ ] ;
41590: LD_ADDR_VAR 0 5
41594: PUSH
41595: EMPTY
41596: ST_TO_ADDR
// for i = 1 to mc_sides do
41597: LD_ADDR_VAR 0 2
41601: PUSH
41602: DOUBLE
41603: LD_INT 1
41605: DEC
41606: ST_TO_ADDR
41607: LD_EXP 126
41611: PUSH
41612: FOR_TO
41613: IFFALSE 41671
// if not mc_sides [ i ] in tmp then
41615: LD_EXP 126
41619: PUSH
41620: LD_VAR 0 2
41624: ARRAY
41625: PUSH
41626: LD_VAR 0 5
41630: IN
41631: NOT
41632: IFFALSE 41669
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
41634: LD_ADDR_VAR 0 5
41638: PUSH
41639: LD_VAR 0 5
41643: PPUSH
41644: LD_VAR 0 5
41648: PUSH
41649: LD_INT 1
41651: PLUS
41652: PPUSH
41653: LD_EXP 126
41657: PUSH
41658: LD_VAR 0 2
41662: ARRAY
41663: PPUSH
41664: CALL_OW 2
41668: ST_TO_ADDR
41669: GO 41612
41671: POP
41672: POP
// if not tmp then
41673: LD_VAR 0 5
41677: NOT
41678: IFFALSE 41682
// exit ;
41680: GO 41787
// for j in tmp do
41682: LD_ADDR_VAR 0 3
41686: PUSH
41687: LD_VAR 0 5
41691: PUSH
41692: FOR_IN
41693: IFFALSE 41785
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
41695: LD_ADDR_VAR 0 6
41699: PUSH
41700: LD_INT 22
41702: PUSH
41703: LD_VAR 0 3
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PPUSH
41712: CALL_OW 69
41716: ST_TO_ADDR
// if not un then
41717: LD_VAR 0 6
41721: NOT
41722: IFFALSE 41726
// continue ;
41724: GO 41692
// nation := GetNation ( un [ 1 ] ) ;
41726: LD_ADDR_VAR 0 4
41730: PUSH
41731: LD_VAR 0 6
41735: PUSH
41736: LD_INT 1
41738: ARRAY
41739: PPUSH
41740: CALL_OW 248
41744: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
41745: LD_ADDR_EXP 127
41749: PUSH
41750: LD_EXP 127
41754: PPUSH
41755: LD_VAR 0 3
41759: PPUSH
41760: LD_VAR 0 3
41764: PPUSH
41765: LD_VAR 0 4
41769: PPUSH
41770: LD_INT 1
41772: PPUSH
41773: CALL 68961 0 3
41777: PPUSH
41778: CALL_OW 1
41782: ST_TO_ADDR
// end ;
41783: GO 41692
41785: POP
41786: POP
// end ;
41787: LD_VAR 0 1
41791: RET
// export function MC_InitSides ( ) ; var i ; begin
41792: LD_INT 0
41794: PPUSH
41795: PPUSH
// if not mc_bases then
41796: LD_EXP 100
41800: NOT
41801: IFFALSE 41805
// exit ;
41803: GO 41879
// for i = 1 to mc_bases do
41805: LD_ADDR_VAR 0 2
41809: PUSH
41810: DOUBLE
41811: LD_INT 1
41813: DEC
41814: ST_TO_ADDR
41815: LD_EXP 100
41819: PUSH
41820: FOR_TO
41821: IFFALSE 41877
// if mc_bases [ i ] then
41823: LD_EXP 100
41827: PUSH
41828: LD_VAR 0 2
41832: ARRAY
41833: IFFALSE 41875
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
41835: LD_ADDR_EXP 126
41839: PUSH
41840: LD_EXP 126
41844: PPUSH
41845: LD_VAR 0 2
41849: PPUSH
41850: LD_EXP 100
41854: PUSH
41855: LD_VAR 0 2
41859: ARRAY
41860: PUSH
41861: LD_INT 1
41863: ARRAY
41864: PPUSH
41865: CALL_OW 255
41869: PPUSH
41870: CALL_OW 1
41874: ST_TO_ADDR
41875: GO 41820
41877: POP
41878: POP
// end ;
41879: LD_VAR 0 1
41883: RET
// every 0 0$03 trigger skirmish do
41884: LD_EXP 98
41888: IFFALSE 42042
41890: GO 41892
41892: DISABLE
// begin enable ;
41893: ENABLE
// MC_CheckBuildings ( ) ;
41894: CALL 46540 0 0
// MC_CheckPeopleLife ( ) ;
41898: CALL 46701 0 0
// RaiseSailEvent ( 100 ) ;
41902: LD_INT 100
41904: PPUSH
41905: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
41909: LD_INT 103
41911: PPUSH
41912: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
41916: LD_INT 104
41918: PPUSH
41919: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
41923: LD_INT 105
41925: PPUSH
41926: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
41930: LD_INT 106
41932: PPUSH
41933: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
41937: LD_INT 107
41939: PPUSH
41940: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
41944: LD_INT 108
41946: PPUSH
41947: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
41951: LD_INT 109
41953: PPUSH
41954: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
41958: LD_INT 110
41960: PPUSH
41961: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
41965: LD_INT 111
41967: PPUSH
41968: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
41972: LD_INT 112
41974: PPUSH
41975: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
41979: LD_INT 113
41981: PPUSH
41982: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
41986: LD_INT 120
41988: PPUSH
41989: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
41993: LD_INT 121
41995: PPUSH
41996: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
42000: LD_INT 122
42002: PPUSH
42003: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
42007: LD_INT 123
42009: PPUSH
42010: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
42014: LD_INT 124
42016: PPUSH
42017: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
42021: LD_INT 125
42023: PPUSH
42024: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
42028: LD_INT 126
42030: PPUSH
42031: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
42035: LD_INT 200
42037: PPUSH
42038: CALL_OW 427
// end ;
42042: END
// on SailEvent ( event ) do begin if event < 100 then
42043: LD_VAR 0 1
42047: PUSH
42048: LD_INT 100
42050: LESS
42051: IFFALSE 42062
// CustomEvent ( event ) ;
42053: LD_VAR 0 1
42057: PPUSH
42058: CALL 36418 0 1
// if event = 100 then
42062: LD_VAR 0 1
42066: PUSH
42067: LD_INT 100
42069: EQUAL
42070: IFFALSE 42076
// MC_ClassManager ( ) ;
42072: CALL 42468 0 0
// if event = 101 then
42076: LD_VAR 0 1
42080: PUSH
42081: LD_INT 101
42083: EQUAL
42084: IFFALSE 42090
// MC_RepairBuildings ( ) ;
42086: CALL 47286 0 0
// if event = 102 then
42090: LD_VAR 0 1
42094: PUSH
42095: LD_INT 102
42097: EQUAL
42098: IFFALSE 42104
// MC_Heal ( ) ;
42100: CALL 48221 0 0
// if event = 103 then
42104: LD_VAR 0 1
42108: PUSH
42109: LD_INT 103
42111: EQUAL
42112: IFFALSE 42118
// MC_Build ( ) ;
42114: CALL 48643 0 0
// if event = 104 then
42118: LD_VAR 0 1
42122: PUSH
42123: LD_INT 104
42125: EQUAL
42126: IFFALSE 42132
// MC_TurretWeapon ( ) ;
42128: CALL 50277 0 0
// if event = 105 then
42132: LD_VAR 0 1
42136: PUSH
42137: LD_INT 105
42139: EQUAL
42140: IFFALSE 42146
// MC_BuildUpgrade ( ) ;
42142: CALL 49828 0 0
// if event = 106 then
42146: LD_VAR 0 1
42150: PUSH
42151: LD_INT 106
42153: EQUAL
42154: IFFALSE 42160
// MC_PlantMines ( ) ;
42156: CALL 50707 0 0
// if event = 107 then
42160: LD_VAR 0 1
42164: PUSH
42165: LD_INT 107
42167: EQUAL
42168: IFFALSE 42174
// MC_CollectCrates ( ) ;
42170: CALL 51505 0 0
// if event = 108 then
42174: LD_VAR 0 1
42178: PUSH
42179: LD_INT 108
42181: EQUAL
42182: IFFALSE 42188
// MC_LinkRemoteControl ( ) ;
42184: CALL 53355 0 0
// if event = 109 then
42188: LD_VAR 0 1
42192: PUSH
42193: LD_INT 109
42195: EQUAL
42196: IFFALSE 42202
// MC_ProduceVehicle ( ) ;
42198: CALL 53536 0 0
// if event = 110 then
42202: LD_VAR 0 1
42206: PUSH
42207: LD_INT 110
42209: EQUAL
42210: IFFALSE 42216
// MC_SendAttack ( ) ;
42212: CALL 54002 0 0
// if event = 111 then
42216: LD_VAR 0 1
42220: PUSH
42221: LD_INT 111
42223: EQUAL
42224: IFFALSE 42230
// MC_Defend ( ) ;
42226: CALL 54110 0 0
// if event = 112 then
42230: LD_VAR 0 1
42234: PUSH
42235: LD_INT 112
42237: EQUAL
42238: IFFALSE 42244
// MC_Research ( ) ;
42240: CALL 54990 0 0
// if event = 113 then
42244: LD_VAR 0 1
42248: PUSH
42249: LD_INT 113
42251: EQUAL
42252: IFFALSE 42258
// MC_MinesTrigger ( ) ;
42254: CALL 56104 0 0
// if event = 120 then
42258: LD_VAR 0 1
42262: PUSH
42263: LD_INT 120
42265: EQUAL
42266: IFFALSE 42272
// MC_RepairVehicle ( ) ;
42268: CALL 56203 0 0
// if event = 121 then
42272: LD_VAR 0 1
42276: PUSH
42277: LD_INT 121
42279: EQUAL
42280: IFFALSE 42286
// MC_TameApe ( ) ;
42282: CALL 56972 0 0
// if event = 122 then
42286: LD_VAR 0 1
42290: PUSH
42291: LD_INT 122
42293: EQUAL
42294: IFFALSE 42300
// MC_ChangeApeClass ( ) ;
42296: CALL 57801 0 0
// if event = 123 then
42300: LD_VAR 0 1
42304: PUSH
42305: LD_INT 123
42307: EQUAL
42308: IFFALSE 42314
// MC_Bazooka ( ) ;
42310: CALL 58451 0 0
// if event = 124 then
42314: LD_VAR 0 1
42318: PUSH
42319: LD_INT 124
42321: EQUAL
42322: IFFALSE 42328
// MC_TeleportExit ( ) ;
42324: CALL 58649 0 0
// if event = 125 then
42328: LD_VAR 0 1
42332: PUSH
42333: LD_INT 125
42335: EQUAL
42336: IFFALSE 42342
// MC_Deposits ( ) ;
42338: CALL 59296 0 0
// if event = 126 then
42342: LD_VAR 0 1
42346: PUSH
42347: LD_INT 126
42349: EQUAL
42350: IFFALSE 42356
// MC_RemoteDriver ( ) ;
42352: CALL 59921 0 0
// if event = 200 then
42356: LD_VAR 0 1
42360: PUSH
42361: LD_INT 200
42363: EQUAL
42364: IFFALSE 42370
// MC_Idle ( ) ;
42366: CALL 61828 0 0
// end ;
42370: PPOPN 1
42372: END
// export function MC_Reset ( base , tag ) ; var i ; begin
42373: LD_INT 0
42375: PPUSH
42376: PPUSH
// if not mc_bases [ base ] or not tag then
42377: LD_EXP 100
42381: PUSH
42382: LD_VAR 0 1
42386: ARRAY
42387: NOT
42388: PUSH
42389: LD_VAR 0 2
42393: NOT
42394: OR
42395: IFFALSE 42399
// exit ;
42397: GO 42463
// for i in mc_bases [ base ] union mc_ape [ base ] do
42399: LD_ADDR_VAR 0 4
42403: PUSH
42404: LD_EXP 100
42408: PUSH
42409: LD_VAR 0 1
42413: ARRAY
42414: PUSH
42415: LD_EXP 129
42419: PUSH
42420: LD_VAR 0 1
42424: ARRAY
42425: UNION
42426: PUSH
42427: FOR_IN
42428: IFFALSE 42461
// if GetTag ( i ) = tag then
42430: LD_VAR 0 4
42434: PPUSH
42435: CALL_OW 110
42439: PUSH
42440: LD_VAR 0 2
42444: EQUAL
42445: IFFALSE 42459
// SetTag ( i , 0 ) ;
42447: LD_VAR 0 4
42451: PPUSH
42452: LD_INT 0
42454: PPUSH
42455: CALL_OW 109
42459: GO 42427
42461: POP
42462: POP
// end ;
42463: LD_VAR 0 3
42467: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
42468: LD_INT 0
42470: PPUSH
42471: PPUSH
42472: PPUSH
42473: PPUSH
42474: PPUSH
42475: PPUSH
42476: PPUSH
42477: PPUSH
// if not mc_bases then
42478: LD_EXP 100
42482: NOT
42483: IFFALSE 42487
// exit ;
42485: GO 42945
// for i = 1 to mc_bases do
42487: LD_ADDR_VAR 0 2
42491: PUSH
42492: DOUBLE
42493: LD_INT 1
42495: DEC
42496: ST_TO_ADDR
42497: LD_EXP 100
42501: PUSH
42502: FOR_TO
42503: IFFALSE 42943
// begin tmp := MC_ClassCheckReq ( i ) ;
42505: LD_ADDR_VAR 0 4
42509: PUSH
42510: LD_VAR 0 2
42514: PPUSH
42515: CALL 42950 0 1
42519: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
42520: LD_ADDR_EXP 141
42524: PUSH
42525: LD_EXP 141
42529: PPUSH
42530: LD_VAR 0 2
42534: PPUSH
42535: LD_VAR 0 4
42539: PPUSH
42540: CALL_OW 1
42544: ST_TO_ADDR
// if not tmp then
42545: LD_VAR 0 4
42549: NOT
42550: IFFALSE 42554
// continue ;
42552: GO 42502
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
42554: LD_ADDR_VAR 0 6
42558: PUSH
42559: LD_EXP 100
42563: PUSH
42564: LD_VAR 0 2
42568: ARRAY
42569: PPUSH
42570: LD_INT 2
42572: PUSH
42573: LD_INT 30
42575: PUSH
42576: LD_INT 4
42578: PUSH
42579: EMPTY
42580: LIST
42581: LIST
42582: PUSH
42583: LD_INT 30
42585: PUSH
42586: LD_INT 5
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: PUSH
42593: EMPTY
42594: LIST
42595: LIST
42596: LIST
42597: PPUSH
42598: CALL_OW 72
42602: PUSH
42603: LD_EXP 100
42607: PUSH
42608: LD_VAR 0 2
42612: ARRAY
42613: PPUSH
42614: LD_INT 2
42616: PUSH
42617: LD_INT 30
42619: PUSH
42620: LD_INT 0
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: PUSH
42627: LD_INT 30
42629: PUSH
42630: LD_INT 1
42632: PUSH
42633: EMPTY
42634: LIST
42635: LIST
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: LIST
42641: PPUSH
42642: CALL_OW 72
42646: PUSH
42647: LD_EXP 100
42651: PUSH
42652: LD_VAR 0 2
42656: ARRAY
42657: PPUSH
42658: LD_INT 30
42660: PUSH
42661: LD_INT 3
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PPUSH
42668: CALL_OW 72
42672: PUSH
42673: LD_EXP 100
42677: PUSH
42678: LD_VAR 0 2
42682: ARRAY
42683: PPUSH
42684: LD_INT 2
42686: PUSH
42687: LD_INT 30
42689: PUSH
42690: LD_INT 6
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 30
42699: PUSH
42700: LD_INT 7
42702: PUSH
42703: EMPTY
42704: LIST
42705: LIST
42706: PUSH
42707: LD_INT 30
42709: PUSH
42710: LD_INT 8
42712: PUSH
42713: EMPTY
42714: LIST
42715: LIST
42716: PUSH
42717: EMPTY
42718: LIST
42719: LIST
42720: LIST
42721: LIST
42722: PPUSH
42723: CALL_OW 72
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: LIST
42732: LIST
42733: ST_TO_ADDR
// for j = 1 to 4 do
42734: LD_ADDR_VAR 0 3
42738: PUSH
42739: DOUBLE
42740: LD_INT 1
42742: DEC
42743: ST_TO_ADDR
42744: LD_INT 4
42746: PUSH
42747: FOR_TO
42748: IFFALSE 42939
// begin if not tmp [ j ] then
42750: LD_VAR 0 4
42754: PUSH
42755: LD_VAR 0 3
42759: ARRAY
42760: NOT
42761: IFFALSE 42765
// continue ;
42763: GO 42747
// for p in tmp [ j ] do
42765: LD_ADDR_VAR 0 5
42769: PUSH
42770: LD_VAR 0 4
42774: PUSH
42775: LD_VAR 0 3
42779: ARRAY
42780: PUSH
42781: FOR_IN
42782: IFFALSE 42935
// begin if not b [ j ] then
42784: LD_VAR 0 6
42788: PUSH
42789: LD_VAR 0 3
42793: ARRAY
42794: NOT
42795: IFFALSE 42799
// break ;
42797: GO 42935
// e := 0 ;
42799: LD_ADDR_VAR 0 7
42803: PUSH
42804: LD_INT 0
42806: ST_TO_ADDR
// for k in b [ j ] do
42807: LD_ADDR_VAR 0 8
42811: PUSH
42812: LD_VAR 0 6
42816: PUSH
42817: LD_VAR 0 3
42821: ARRAY
42822: PUSH
42823: FOR_IN
42824: IFFALSE 42851
// if IsNotFull ( k ) then
42826: LD_VAR 0 8
42830: PPUSH
42831: CALL 71082 0 1
42835: IFFALSE 42849
// begin e := k ;
42837: LD_ADDR_VAR 0 7
42841: PUSH
42842: LD_VAR 0 8
42846: ST_TO_ADDR
// break ;
42847: GO 42851
// end ;
42849: GO 42823
42851: POP
42852: POP
// if e and not UnitGoingToBuilding ( p , e ) then
42853: LD_VAR 0 7
42857: PUSH
42858: LD_VAR 0 5
42862: PPUSH
42863: LD_VAR 0 7
42867: PPUSH
42868: CALL 104835 0 2
42872: NOT
42873: AND
42874: IFFALSE 42933
// begin if IsInUnit ( p ) then
42876: LD_VAR 0 5
42880: PPUSH
42881: CALL_OW 310
42885: IFFALSE 42896
// ComExitBuilding ( p ) ;
42887: LD_VAR 0 5
42891: PPUSH
42892: CALL_OW 122
// ComEnterUnit ( p , e ) ;
42896: LD_VAR 0 5
42900: PPUSH
42901: LD_VAR 0 7
42905: PPUSH
42906: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
42910: LD_VAR 0 5
42914: PPUSH
42915: LD_VAR 0 3
42919: PPUSH
42920: CALL_OW 183
// AddComExitBuilding ( p ) ;
42924: LD_VAR 0 5
42928: PPUSH
42929: CALL_OW 182
// end ; end ;
42933: GO 42781
42935: POP
42936: POP
// end ;
42937: GO 42747
42939: POP
42940: POP
// end ;
42941: GO 42502
42943: POP
42944: POP
// end ;
42945: LD_VAR 0 1
42949: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
42950: LD_INT 0
42952: PPUSH
42953: PPUSH
42954: PPUSH
42955: PPUSH
42956: PPUSH
42957: PPUSH
42958: PPUSH
42959: PPUSH
42960: PPUSH
42961: PPUSH
42962: PPUSH
42963: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
42964: LD_VAR 0 1
42968: NOT
42969: PUSH
42970: LD_EXP 100
42974: PUSH
42975: LD_VAR 0 1
42979: ARRAY
42980: NOT
42981: OR
42982: PUSH
42983: LD_EXP 100
42987: PUSH
42988: LD_VAR 0 1
42992: ARRAY
42993: PPUSH
42994: LD_INT 2
42996: PUSH
42997: LD_INT 30
42999: PUSH
43000: LD_INT 0
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 30
43009: PUSH
43010: LD_INT 1
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: EMPTY
43018: LIST
43019: LIST
43020: LIST
43021: PPUSH
43022: CALL_OW 72
43026: NOT
43027: OR
43028: IFFALSE 43032
// exit ;
43030: GO 46535
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43032: LD_ADDR_VAR 0 4
43036: PUSH
43037: LD_EXP 100
43041: PUSH
43042: LD_VAR 0 1
43046: ARRAY
43047: PPUSH
43048: LD_INT 2
43050: PUSH
43051: LD_INT 25
43053: PUSH
43054: LD_INT 1
43056: PUSH
43057: EMPTY
43058: LIST
43059: LIST
43060: PUSH
43061: LD_INT 25
43063: PUSH
43064: LD_INT 2
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 25
43073: PUSH
43074: LD_INT 3
43076: PUSH
43077: EMPTY
43078: LIST
43079: LIST
43080: PUSH
43081: LD_INT 25
43083: PUSH
43084: LD_INT 4
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 25
43093: PUSH
43094: LD_INT 5
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 25
43103: PUSH
43104: LD_INT 8
43106: PUSH
43107: EMPTY
43108: LIST
43109: LIST
43110: PUSH
43111: LD_INT 25
43113: PUSH
43114: LD_INT 9
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: PUSH
43121: EMPTY
43122: LIST
43123: LIST
43124: LIST
43125: LIST
43126: LIST
43127: LIST
43128: LIST
43129: LIST
43130: PPUSH
43131: CALL_OW 72
43135: ST_TO_ADDR
// if not tmp then
43136: LD_VAR 0 4
43140: NOT
43141: IFFALSE 43145
// exit ;
43143: GO 46535
// for i in tmp do
43145: LD_ADDR_VAR 0 3
43149: PUSH
43150: LD_VAR 0 4
43154: PUSH
43155: FOR_IN
43156: IFFALSE 43187
// if GetTag ( i ) then
43158: LD_VAR 0 3
43162: PPUSH
43163: CALL_OW 110
43167: IFFALSE 43185
// tmp := tmp diff i ;
43169: LD_ADDR_VAR 0 4
43173: PUSH
43174: LD_VAR 0 4
43178: PUSH
43179: LD_VAR 0 3
43183: DIFF
43184: ST_TO_ADDR
43185: GO 43155
43187: POP
43188: POP
// if not tmp then
43189: LD_VAR 0 4
43193: NOT
43194: IFFALSE 43198
// exit ;
43196: GO 46535
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
43198: LD_ADDR_VAR 0 5
43202: PUSH
43203: LD_EXP 100
43207: PUSH
43208: LD_VAR 0 1
43212: ARRAY
43213: PPUSH
43214: LD_INT 2
43216: PUSH
43217: LD_INT 25
43219: PUSH
43220: LD_INT 1
43222: PUSH
43223: EMPTY
43224: LIST
43225: LIST
43226: PUSH
43227: LD_INT 25
43229: PUSH
43230: LD_INT 5
43232: PUSH
43233: EMPTY
43234: LIST
43235: LIST
43236: PUSH
43237: LD_INT 25
43239: PUSH
43240: LD_INT 8
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: LD_INT 25
43249: PUSH
43250: LD_INT 9
43252: PUSH
43253: EMPTY
43254: LIST
43255: LIST
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: LIST
43261: LIST
43262: LIST
43263: PPUSH
43264: CALL_OW 72
43268: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
43269: LD_ADDR_VAR 0 6
43273: PUSH
43274: LD_EXP 100
43278: PUSH
43279: LD_VAR 0 1
43283: ARRAY
43284: PPUSH
43285: LD_INT 25
43287: PUSH
43288: LD_INT 2
43290: PUSH
43291: EMPTY
43292: LIST
43293: LIST
43294: PPUSH
43295: CALL_OW 72
43299: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
43300: LD_ADDR_VAR 0 7
43304: PUSH
43305: LD_EXP 100
43309: PUSH
43310: LD_VAR 0 1
43314: ARRAY
43315: PPUSH
43316: LD_INT 25
43318: PUSH
43319: LD_INT 3
43321: PUSH
43322: EMPTY
43323: LIST
43324: LIST
43325: PPUSH
43326: CALL_OW 72
43330: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
43331: LD_ADDR_VAR 0 8
43335: PUSH
43336: LD_EXP 100
43340: PUSH
43341: LD_VAR 0 1
43345: ARRAY
43346: PPUSH
43347: LD_INT 25
43349: PUSH
43350: LD_INT 4
43352: PUSH
43353: EMPTY
43354: LIST
43355: LIST
43356: PUSH
43357: LD_INT 24
43359: PUSH
43360: LD_INT 251
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: PUSH
43367: EMPTY
43368: LIST
43369: LIST
43370: PPUSH
43371: CALL_OW 72
43375: ST_TO_ADDR
// if mc_is_defending [ base ] then
43376: LD_EXP 143
43380: PUSH
43381: LD_VAR 0 1
43385: ARRAY
43386: IFFALSE 43847
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
43388: LD_ADDR_EXP 142
43392: PUSH
43393: LD_EXP 142
43397: PPUSH
43398: LD_VAR 0 1
43402: PPUSH
43403: LD_INT 4
43405: PPUSH
43406: CALL_OW 1
43410: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
43411: LD_ADDR_VAR 0 12
43415: PUSH
43416: LD_EXP 100
43420: PUSH
43421: LD_VAR 0 1
43425: ARRAY
43426: PPUSH
43427: LD_INT 2
43429: PUSH
43430: LD_INT 30
43432: PUSH
43433: LD_INT 4
43435: PUSH
43436: EMPTY
43437: LIST
43438: LIST
43439: PUSH
43440: LD_INT 30
43442: PUSH
43443: LD_INT 5
43445: PUSH
43446: EMPTY
43447: LIST
43448: LIST
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: LIST
43454: PPUSH
43455: CALL_OW 72
43459: ST_TO_ADDR
// if not b then
43460: LD_VAR 0 12
43464: NOT
43465: IFFALSE 43469
// exit ;
43467: GO 46535
// p := [ ] ;
43469: LD_ADDR_VAR 0 11
43473: PUSH
43474: EMPTY
43475: ST_TO_ADDR
// if sci >= 2 then
43476: LD_VAR 0 8
43480: PUSH
43481: LD_INT 2
43483: GREATEREQUAL
43484: IFFALSE 43515
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
43486: LD_ADDR_VAR 0 8
43490: PUSH
43491: LD_VAR 0 8
43495: PUSH
43496: LD_INT 1
43498: ARRAY
43499: PUSH
43500: LD_VAR 0 8
43504: PUSH
43505: LD_INT 2
43507: ARRAY
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: ST_TO_ADDR
43513: GO 43576
// if sci = 1 then
43515: LD_VAR 0 8
43519: PUSH
43520: LD_INT 1
43522: EQUAL
43523: IFFALSE 43544
// sci := [ sci [ 1 ] ] else
43525: LD_ADDR_VAR 0 8
43529: PUSH
43530: LD_VAR 0 8
43534: PUSH
43535: LD_INT 1
43537: ARRAY
43538: PUSH
43539: EMPTY
43540: LIST
43541: ST_TO_ADDR
43542: GO 43576
// if sci = 0 then
43544: LD_VAR 0 8
43548: PUSH
43549: LD_INT 0
43551: EQUAL
43552: IFFALSE 43576
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
43554: LD_ADDR_VAR 0 11
43558: PUSH
43559: LD_VAR 0 4
43563: PPUSH
43564: LD_INT 4
43566: PPUSH
43567: CALL 104707 0 2
43571: PUSH
43572: LD_INT 1
43574: ARRAY
43575: ST_TO_ADDR
// if eng > 4 then
43576: LD_VAR 0 6
43580: PUSH
43581: LD_INT 4
43583: GREATER
43584: IFFALSE 43630
// for i = eng downto 4 do
43586: LD_ADDR_VAR 0 3
43590: PUSH
43591: DOUBLE
43592: LD_VAR 0 6
43596: INC
43597: ST_TO_ADDR
43598: LD_INT 4
43600: PUSH
43601: FOR_DOWNTO
43602: IFFALSE 43628
// eng := eng diff eng [ i ] ;
43604: LD_ADDR_VAR 0 6
43608: PUSH
43609: LD_VAR 0 6
43613: PUSH
43614: LD_VAR 0 6
43618: PUSH
43619: LD_VAR 0 3
43623: ARRAY
43624: DIFF
43625: ST_TO_ADDR
43626: GO 43601
43628: POP
43629: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
43630: LD_ADDR_VAR 0 4
43634: PUSH
43635: LD_VAR 0 4
43639: PUSH
43640: LD_VAR 0 5
43644: PUSH
43645: LD_VAR 0 6
43649: UNION
43650: PUSH
43651: LD_VAR 0 7
43655: UNION
43656: PUSH
43657: LD_VAR 0 8
43661: UNION
43662: DIFF
43663: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
43664: LD_ADDR_VAR 0 13
43668: PUSH
43669: LD_EXP 100
43673: PUSH
43674: LD_VAR 0 1
43678: ARRAY
43679: PPUSH
43680: LD_INT 2
43682: PUSH
43683: LD_INT 30
43685: PUSH
43686: LD_INT 32
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 30
43695: PUSH
43696: LD_INT 31
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: EMPTY
43704: LIST
43705: LIST
43706: LIST
43707: PPUSH
43708: CALL_OW 72
43712: PUSH
43713: LD_EXP 100
43717: PUSH
43718: LD_VAR 0 1
43722: ARRAY
43723: PPUSH
43724: LD_INT 2
43726: PUSH
43727: LD_INT 30
43729: PUSH
43730: LD_INT 4
43732: PUSH
43733: EMPTY
43734: LIST
43735: LIST
43736: PUSH
43737: LD_INT 30
43739: PUSH
43740: LD_INT 5
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: EMPTY
43748: LIST
43749: LIST
43750: LIST
43751: PPUSH
43752: CALL_OW 72
43756: PUSH
43757: LD_INT 6
43759: MUL
43760: PLUS
43761: ST_TO_ADDR
// if bcount < tmp then
43762: LD_VAR 0 13
43766: PUSH
43767: LD_VAR 0 4
43771: LESS
43772: IFFALSE 43818
// for i = tmp downto bcount do
43774: LD_ADDR_VAR 0 3
43778: PUSH
43779: DOUBLE
43780: LD_VAR 0 4
43784: INC
43785: ST_TO_ADDR
43786: LD_VAR 0 13
43790: PUSH
43791: FOR_DOWNTO
43792: IFFALSE 43816
// tmp := Delete ( tmp , tmp ) ;
43794: LD_ADDR_VAR 0 4
43798: PUSH
43799: LD_VAR 0 4
43803: PPUSH
43804: LD_VAR 0 4
43808: PPUSH
43809: CALL_OW 3
43813: ST_TO_ADDR
43814: GO 43791
43816: POP
43817: POP
// result := [ tmp , 0 , 0 , p ] ;
43818: LD_ADDR_VAR 0 2
43822: PUSH
43823: LD_VAR 0 4
43827: PUSH
43828: LD_INT 0
43830: PUSH
43831: LD_INT 0
43833: PUSH
43834: LD_VAR 0 11
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: LIST
43843: LIST
43844: ST_TO_ADDR
// exit ;
43845: GO 46535
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
43847: LD_EXP 100
43851: PUSH
43852: LD_VAR 0 1
43856: ARRAY
43857: PPUSH
43858: LD_INT 2
43860: PUSH
43861: LD_INT 30
43863: PUSH
43864: LD_INT 6
43866: PUSH
43867: EMPTY
43868: LIST
43869: LIST
43870: PUSH
43871: LD_INT 30
43873: PUSH
43874: LD_INT 7
43876: PUSH
43877: EMPTY
43878: LIST
43879: LIST
43880: PUSH
43881: LD_INT 30
43883: PUSH
43884: LD_INT 8
43886: PUSH
43887: EMPTY
43888: LIST
43889: LIST
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: LIST
43895: LIST
43896: PPUSH
43897: CALL_OW 72
43901: NOT
43902: PUSH
43903: LD_EXP 100
43907: PUSH
43908: LD_VAR 0 1
43912: ARRAY
43913: PPUSH
43914: LD_INT 30
43916: PUSH
43917: LD_INT 3
43919: PUSH
43920: EMPTY
43921: LIST
43922: LIST
43923: PPUSH
43924: CALL_OW 72
43928: NOT
43929: AND
43930: IFFALSE 44002
// begin if eng = tmp then
43932: LD_VAR 0 6
43936: PUSH
43937: LD_VAR 0 4
43941: EQUAL
43942: IFFALSE 43946
// exit ;
43944: GO 46535
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
43946: LD_ADDR_EXP 142
43950: PUSH
43951: LD_EXP 142
43955: PPUSH
43956: LD_VAR 0 1
43960: PPUSH
43961: LD_INT 1
43963: PPUSH
43964: CALL_OW 1
43968: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
43969: LD_ADDR_VAR 0 2
43973: PUSH
43974: LD_INT 0
43976: PUSH
43977: LD_VAR 0 4
43981: PUSH
43982: LD_VAR 0 6
43986: DIFF
43987: PUSH
43988: LD_INT 0
43990: PUSH
43991: LD_INT 0
43993: PUSH
43994: EMPTY
43995: LIST
43996: LIST
43997: LIST
43998: LIST
43999: ST_TO_ADDR
// exit ;
44000: GO 46535
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44002: LD_EXP 127
44006: PUSH
44007: LD_EXP 126
44011: PUSH
44012: LD_VAR 0 1
44016: ARRAY
44017: ARRAY
44018: PUSH
44019: LD_EXP 100
44023: PUSH
44024: LD_VAR 0 1
44028: ARRAY
44029: PPUSH
44030: LD_INT 2
44032: PUSH
44033: LD_INT 30
44035: PUSH
44036: LD_INT 6
44038: PUSH
44039: EMPTY
44040: LIST
44041: LIST
44042: PUSH
44043: LD_INT 30
44045: PUSH
44046: LD_INT 7
44048: PUSH
44049: EMPTY
44050: LIST
44051: LIST
44052: PUSH
44053: LD_INT 30
44055: PUSH
44056: LD_INT 8
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: PUSH
44063: EMPTY
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: PPUSH
44069: CALL_OW 72
44073: AND
44074: PUSH
44075: LD_EXP 100
44079: PUSH
44080: LD_VAR 0 1
44084: ARRAY
44085: PPUSH
44086: LD_INT 30
44088: PUSH
44089: LD_INT 3
44091: PUSH
44092: EMPTY
44093: LIST
44094: LIST
44095: PPUSH
44096: CALL_OW 72
44100: NOT
44101: AND
44102: IFFALSE 44316
// begin if sci >= 6 then
44104: LD_VAR 0 8
44108: PUSH
44109: LD_INT 6
44111: GREATEREQUAL
44112: IFFALSE 44116
// exit ;
44114: GO 46535
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
44116: LD_ADDR_EXP 142
44120: PUSH
44121: LD_EXP 142
44125: PPUSH
44126: LD_VAR 0 1
44130: PPUSH
44131: LD_INT 2
44133: PPUSH
44134: CALL_OW 1
44138: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
44139: LD_ADDR_VAR 0 9
44143: PUSH
44144: LD_VAR 0 4
44148: PUSH
44149: LD_VAR 0 8
44153: DIFF
44154: PPUSH
44155: LD_INT 4
44157: PPUSH
44158: CALL 104707 0 2
44162: ST_TO_ADDR
// p := [ ] ;
44163: LD_ADDR_VAR 0 11
44167: PUSH
44168: EMPTY
44169: ST_TO_ADDR
// if sci < 6 and sort > 6 then
44170: LD_VAR 0 8
44174: PUSH
44175: LD_INT 6
44177: LESS
44178: PUSH
44179: LD_VAR 0 9
44183: PUSH
44184: LD_INT 6
44186: GREATER
44187: AND
44188: IFFALSE 44269
// begin for i = 1 to 6 - sci do
44190: LD_ADDR_VAR 0 3
44194: PUSH
44195: DOUBLE
44196: LD_INT 1
44198: DEC
44199: ST_TO_ADDR
44200: LD_INT 6
44202: PUSH
44203: LD_VAR 0 8
44207: MINUS
44208: PUSH
44209: FOR_TO
44210: IFFALSE 44265
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
44212: LD_ADDR_VAR 0 11
44216: PUSH
44217: LD_VAR 0 11
44221: PPUSH
44222: LD_VAR 0 11
44226: PUSH
44227: LD_INT 1
44229: PLUS
44230: PPUSH
44231: LD_VAR 0 9
44235: PUSH
44236: LD_INT 1
44238: ARRAY
44239: PPUSH
44240: CALL_OW 2
44244: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
44245: LD_ADDR_VAR 0 9
44249: PUSH
44250: LD_VAR 0 9
44254: PPUSH
44255: LD_INT 1
44257: PPUSH
44258: CALL_OW 3
44262: ST_TO_ADDR
// end ;
44263: GO 44209
44265: POP
44266: POP
// end else
44267: GO 44289
// if sort then
44269: LD_VAR 0 9
44273: IFFALSE 44289
// p := sort [ 1 ] ;
44275: LD_ADDR_VAR 0 11
44279: PUSH
44280: LD_VAR 0 9
44284: PUSH
44285: LD_INT 1
44287: ARRAY
44288: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
44289: LD_ADDR_VAR 0 2
44293: PUSH
44294: LD_INT 0
44296: PUSH
44297: LD_INT 0
44299: PUSH
44300: LD_INT 0
44302: PUSH
44303: LD_VAR 0 11
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: LIST
44312: LIST
44313: ST_TO_ADDR
// exit ;
44314: GO 46535
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
44316: LD_EXP 127
44320: PUSH
44321: LD_EXP 126
44325: PUSH
44326: LD_VAR 0 1
44330: ARRAY
44331: ARRAY
44332: PUSH
44333: LD_EXP 100
44337: PUSH
44338: LD_VAR 0 1
44342: ARRAY
44343: PPUSH
44344: LD_INT 2
44346: PUSH
44347: LD_INT 30
44349: PUSH
44350: LD_INT 6
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PUSH
44357: LD_INT 30
44359: PUSH
44360: LD_INT 7
44362: PUSH
44363: EMPTY
44364: LIST
44365: LIST
44366: PUSH
44367: LD_INT 30
44369: PUSH
44370: LD_INT 8
44372: PUSH
44373: EMPTY
44374: LIST
44375: LIST
44376: PUSH
44377: EMPTY
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: PPUSH
44383: CALL_OW 72
44387: AND
44388: PUSH
44389: LD_EXP 100
44393: PUSH
44394: LD_VAR 0 1
44398: ARRAY
44399: PPUSH
44400: LD_INT 30
44402: PUSH
44403: LD_INT 3
44405: PUSH
44406: EMPTY
44407: LIST
44408: LIST
44409: PPUSH
44410: CALL_OW 72
44414: AND
44415: IFFALSE 45149
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
44417: LD_ADDR_EXP 142
44421: PUSH
44422: LD_EXP 142
44426: PPUSH
44427: LD_VAR 0 1
44431: PPUSH
44432: LD_INT 3
44434: PPUSH
44435: CALL_OW 1
44439: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
44440: LD_ADDR_VAR 0 2
44444: PUSH
44445: LD_INT 0
44447: PUSH
44448: LD_INT 0
44450: PUSH
44451: LD_INT 0
44453: PUSH
44454: LD_INT 0
44456: PUSH
44457: EMPTY
44458: LIST
44459: LIST
44460: LIST
44461: LIST
44462: ST_TO_ADDR
// if not eng then
44463: LD_VAR 0 6
44467: NOT
44468: IFFALSE 44531
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
44470: LD_ADDR_VAR 0 11
44474: PUSH
44475: LD_VAR 0 4
44479: PPUSH
44480: LD_INT 2
44482: PPUSH
44483: CALL 104707 0 2
44487: PUSH
44488: LD_INT 1
44490: ARRAY
44491: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
44492: LD_ADDR_VAR 0 2
44496: PUSH
44497: LD_VAR 0 2
44501: PPUSH
44502: LD_INT 2
44504: PPUSH
44505: LD_VAR 0 11
44509: PPUSH
44510: CALL_OW 1
44514: ST_TO_ADDR
// tmp := tmp diff p ;
44515: LD_ADDR_VAR 0 4
44519: PUSH
44520: LD_VAR 0 4
44524: PUSH
44525: LD_VAR 0 11
44529: DIFF
44530: ST_TO_ADDR
// end ; if tmp and sci < 6 then
44531: LD_VAR 0 4
44535: PUSH
44536: LD_VAR 0 8
44540: PUSH
44541: LD_INT 6
44543: LESS
44544: AND
44545: IFFALSE 44733
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
44547: LD_ADDR_VAR 0 9
44551: PUSH
44552: LD_VAR 0 4
44556: PUSH
44557: LD_VAR 0 8
44561: PUSH
44562: LD_VAR 0 7
44566: UNION
44567: DIFF
44568: PPUSH
44569: LD_INT 4
44571: PPUSH
44572: CALL 104707 0 2
44576: ST_TO_ADDR
// p := [ ] ;
44577: LD_ADDR_VAR 0 11
44581: PUSH
44582: EMPTY
44583: ST_TO_ADDR
// if sort then
44584: LD_VAR 0 9
44588: IFFALSE 44704
// for i = 1 to 6 - sci do
44590: LD_ADDR_VAR 0 3
44594: PUSH
44595: DOUBLE
44596: LD_INT 1
44598: DEC
44599: ST_TO_ADDR
44600: LD_INT 6
44602: PUSH
44603: LD_VAR 0 8
44607: MINUS
44608: PUSH
44609: FOR_TO
44610: IFFALSE 44702
// begin if i = sort then
44612: LD_VAR 0 3
44616: PUSH
44617: LD_VAR 0 9
44621: EQUAL
44622: IFFALSE 44626
// break ;
44624: GO 44702
// if GetClass ( i ) = 4 then
44626: LD_VAR 0 3
44630: PPUSH
44631: CALL_OW 257
44635: PUSH
44636: LD_INT 4
44638: EQUAL
44639: IFFALSE 44643
// continue ;
44641: GO 44609
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44643: LD_ADDR_VAR 0 11
44647: PUSH
44648: LD_VAR 0 11
44652: PPUSH
44653: LD_VAR 0 11
44657: PUSH
44658: LD_INT 1
44660: PLUS
44661: PPUSH
44662: LD_VAR 0 9
44666: PUSH
44667: LD_VAR 0 3
44671: ARRAY
44672: PPUSH
44673: CALL_OW 2
44677: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44678: LD_ADDR_VAR 0 4
44682: PUSH
44683: LD_VAR 0 4
44687: PUSH
44688: LD_VAR 0 9
44692: PUSH
44693: LD_VAR 0 3
44697: ARRAY
44698: DIFF
44699: ST_TO_ADDR
// end ;
44700: GO 44609
44702: POP
44703: POP
// if p then
44704: LD_VAR 0 11
44708: IFFALSE 44733
// result := Replace ( result , 4 , p ) ;
44710: LD_ADDR_VAR 0 2
44714: PUSH
44715: LD_VAR 0 2
44719: PPUSH
44720: LD_INT 4
44722: PPUSH
44723: LD_VAR 0 11
44727: PPUSH
44728: CALL_OW 1
44732: ST_TO_ADDR
// end ; if tmp and mech < 6 then
44733: LD_VAR 0 4
44737: PUSH
44738: LD_VAR 0 7
44742: PUSH
44743: LD_INT 6
44745: LESS
44746: AND
44747: IFFALSE 44935
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
44749: LD_ADDR_VAR 0 9
44753: PUSH
44754: LD_VAR 0 4
44758: PUSH
44759: LD_VAR 0 8
44763: PUSH
44764: LD_VAR 0 7
44768: UNION
44769: DIFF
44770: PPUSH
44771: LD_INT 3
44773: PPUSH
44774: CALL 104707 0 2
44778: ST_TO_ADDR
// p := [ ] ;
44779: LD_ADDR_VAR 0 11
44783: PUSH
44784: EMPTY
44785: ST_TO_ADDR
// if sort then
44786: LD_VAR 0 9
44790: IFFALSE 44906
// for i = 1 to 6 - mech do
44792: LD_ADDR_VAR 0 3
44796: PUSH
44797: DOUBLE
44798: LD_INT 1
44800: DEC
44801: ST_TO_ADDR
44802: LD_INT 6
44804: PUSH
44805: LD_VAR 0 7
44809: MINUS
44810: PUSH
44811: FOR_TO
44812: IFFALSE 44904
// begin if i = sort then
44814: LD_VAR 0 3
44818: PUSH
44819: LD_VAR 0 9
44823: EQUAL
44824: IFFALSE 44828
// break ;
44826: GO 44904
// if GetClass ( i ) = 3 then
44828: LD_VAR 0 3
44832: PPUSH
44833: CALL_OW 257
44837: PUSH
44838: LD_INT 3
44840: EQUAL
44841: IFFALSE 44845
// continue ;
44843: GO 44811
// p := Insert ( p , p + 1 , sort [ i ] ) ;
44845: LD_ADDR_VAR 0 11
44849: PUSH
44850: LD_VAR 0 11
44854: PPUSH
44855: LD_VAR 0 11
44859: PUSH
44860: LD_INT 1
44862: PLUS
44863: PPUSH
44864: LD_VAR 0 9
44868: PUSH
44869: LD_VAR 0 3
44873: ARRAY
44874: PPUSH
44875: CALL_OW 2
44879: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
44880: LD_ADDR_VAR 0 4
44884: PUSH
44885: LD_VAR 0 4
44889: PUSH
44890: LD_VAR 0 9
44894: PUSH
44895: LD_VAR 0 3
44899: ARRAY
44900: DIFF
44901: ST_TO_ADDR
// end ;
44902: GO 44811
44904: POP
44905: POP
// if p then
44906: LD_VAR 0 11
44910: IFFALSE 44935
// result := Replace ( result , 3 , p ) ;
44912: LD_ADDR_VAR 0 2
44916: PUSH
44917: LD_VAR 0 2
44921: PPUSH
44922: LD_INT 3
44924: PPUSH
44925: LD_VAR 0 11
44929: PPUSH
44930: CALL_OW 1
44934: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
44935: LD_VAR 0 4
44939: PUSH
44940: LD_INT 6
44942: GREATER
44943: PUSH
44944: LD_VAR 0 6
44948: PUSH
44949: LD_INT 6
44951: LESS
44952: AND
44953: IFFALSE 45147
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
44955: LD_ADDR_VAR 0 9
44959: PUSH
44960: LD_VAR 0 4
44964: PUSH
44965: LD_VAR 0 8
44969: PUSH
44970: LD_VAR 0 7
44974: UNION
44975: PUSH
44976: LD_VAR 0 6
44980: UNION
44981: DIFF
44982: PPUSH
44983: LD_INT 2
44985: PPUSH
44986: CALL 104707 0 2
44990: ST_TO_ADDR
// p := [ ] ;
44991: LD_ADDR_VAR 0 11
44995: PUSH
44996: EMPTY
44997: ST_TO_ADDR
// if sort then
44998: LD_VAR 0 9
45002: IFFALSE 45118
// for i = 1 to 6 - eng do
45004: LD_ADDR_VAR 0 3
45008: PUSH
45009: DOUBLE
45010: LD_INT 1
45012: DEC
45013: ST_TO_ADDR
45014: LD_INT 6
45016: PUSH
45017: LD_VAR 0 6
45021: MINUS
45022: PUSH
45023: FOR_TO
45024: IFFALSE 45116
// begin if i = sort then
45026: LD_VAR 0 3
45030: PUSH
45031: LD_VAR 0 9
45035: EQUAL
45036: IFFALSE 45040
// break ;
45038: GO 45116
// if GetClass ( i ) = 2 then
45040: LD_VAR 0 3
45044: PPUSH
45045: CALL_OW 257
45049: PUSH
45050: LD_INT 2
45052: EQUAL
45053: IFFALSE 45057
// continue ;
45055: GO 45023
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45057: LD_ADDR_VAR 0 11
45061: PUSH
45062: LD_VAR 0 11
45066: PPUSH
45067: LD_VAR 0 11
45071: PUSH
45072: LD_INT 1
45074: PLUS
45075: PPUSH
45076: LD_VAR 0 9
45080: PUSH
45081: LD_VAR 0 3
45085: ARRAY
45086: PPUSH
45087: CALL_OW 2
45091: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45092: LD_ADDR_VAR 0 4
45096: PUSH
45097: LD_VAR 0 4
45101: PUSH
45102: LD_VAR 0 9
45106: PUSH
45107: LD_VAR 0 3
45111: ARRAY
45112: DIFF
45113: ST_TO_ADDR
// end ;
45114: GO 45023
45116: POP
45117: POP
// if p then
45118: LD_VAR 0 11
45122: IFFALSE 45147
// result := Replace ( result , 2 , p ) ;
45124: LD_ADDR_VAR 0 2
45128: PUSH
45129: LD_VAR 0 2
45133: PPUSH
45134: LD_INT 2
45136: PPUSH
45137: LD_VAR 0 11
45141: PPUSH
45142: CALL_OW 1
45146: ST_TO_ADDR
// end ; exit ;
45147: GO 46535
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
45149: LD_EXP 127
45153: PUSH
45154: LD_EXP 126
45158: PUSH
45159: LD_VAR 0 1
45163: ARRAY
45164: ARRAY
45165: NOT
45166: PUSH
45167: LD_EXP 100
45171: PUSH
45172: LD_VAR 0 1
45176: ARRAY
45177: PPUSH
45178: LD_INT 30
45180: PUSH
45181: LD_INT 3
45183: PUSH
45184: EMPTY
45185: LIST
45186: LIST
45187: PPUSH
45188: CALL_OW 72
45192: AND
45193: PUSH
45194: LD_EXP 105
45198: PUSH
45199: LD_VAR 0 1
45203: ARRAY
45204: AND
45205: IFFALSE 45813
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
45207: LD_ADDR_EXP 142
45211: PUSH
45212: LD_EXP 142
45216: PPUSH
45217: LD_VAR 0 1
45221: PPUSH
45222: LD_INT 5
45224: PPUSH
45225: CALL_OW 1
45229: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45230: LD_ADDR_VAR 0 2
45234: PUSH
45235: LD_INT 0
45237: PUSH
45238: LD_INT 0
45240: PUSH
45241: LD_INT 0
45243: PUSH
45244: LD_INT 0
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: LIST
45251: LIST
45252: ST_TO_ADDR
// if sci > 1 then
45253: LD_VAR 0 8
45257: PUSH
45258: LD_INT 1
45260: GREATER
45261: IFFALSE 45289
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
45263: LD_ADDR_VAR 0 4
45267: PUSH
45268: LD_VAR 0 4
45272: PUSH
45273: LD_VAR 0 8
45277: PUSH
45278: LD_VAR 0 8
45282: PUSH
45283: LD_INT 1
45285: ARRAY
45286: DIFF
45287: DIFF
45288: ST_TO_ADDR
// if tmp and not sci then
45289: LD_VAR 0 4
45293: PUSH
45294: LD_VAR 0 8
45298: NOT
45299: AND
45300: IFFALSE 45369
// begin sort := SortBySkill ( tmp , 4 ) ;
45302: LD_ADDR_VAR 0 9
45306: PUSH
45307: LD_VAR 0 4
45311: PPUSH
45312: LD_INT 4
45314: PPUSH
45315: CALL 104707 0 2
45319: ST_TO_ADDR
// if sort then
45320: LD_VAR 0 9
45324: IFFALSE 45340
// p := sort [ 1 ] ;
45326: LD_ADDR_VAR 0 11
45330: PUSH
45331: LD_VAR 0 9
45335: PUSH
45336: LD_INT 1
45338: ARRAY
45339: ST_TO_ADDR
// if p then
45340: LD_VAR 0 11
45344: IFFALSE 45369
// result := Replace ( result , 4 , p ) ;
45346: LD_ADDR_VAR 0 2
45350: PUSH
45351: LD_VAR 0 2
45355: PPUSH
45356: LD_INT 4
45358: PPUSH
45359: LD_VAR 0 11
45363: PPUSH
45364: CALL_OW 1
45368: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
45369: LD_ADDR_VAR 0 4
45373: PUSH
45374: LD_VAR 0 4
45378: PUSH
45379: LD_VAR 0 7
45383: DIFF
45384: ST_TO_ADDR
// if tmp and mech < 6 then
45385: LD_VAR 0 4
45389: PUSH
45390: LD_VAR 0 7
45394: PUSH
45395: LD_INT 6
45397: LESS
45398: AND
45399: IFFALSE 45587
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
45401: LD_ADDR_VAR 0 9
45405: PUSH
45406: LD_VAR 0 4
45410: PUSH
45411: LD_VAR 0 8
45415: PUSH
45416: LD_VAR 0 7
45420: UNION
45421: DIFF
45422: PPUSH
45423: LD_INT 3
45425: PPUSH
45426: CALL 104707 0 2
45430: ST_TO_ADDR
// p := [ ] ;
45431: LD_ADDR_VAR 0 11
45435: PUSH
45436: EMPTY
45437: ST_TO_ADDR
// if sort then
45438: LD_VAR 0 9
45442: IFFALSE 45558
// for i = 1 to 6 - mech do
45444: LD_ADDR_VAR 0 3
45448: PUSH
45449: DOUBLE
45450: LD_INT 1
45452: DEC
45453: ST_TO_ADDR
45454: LD_INT 6
45456: PUSH
45457: LD_VAR 0 7
45461: MINUS
45462: PUSH
45463: FOR_TO
45464: IFFALSE 45556
// begin if i = sort then
45466: LD_VAR 0 3
45470: PUSH
45471: LD_VAR 0 9
45475: EQUAL
45476: IFFALSE 45480
// break ;
45478: GO 45556
// if GetClass ( i ) = 3 then
45480: LD_VAR 0 3
45484: PPUSH
45485: CALL_OW 257
45489: PUSH
45490: LD_INT 3
45492: EQUAL
45493: IFFALSE 45497
// continue ;
45495: GO 45463
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45497: LD_ADDR_VAR 0 11
45501: PUSH
45502: LD_VAR 0 11
45506: PPUSH
45507: LD_VAR 0 11
45511: PUSH
45512: LD_INT 1
45514: PLUS
45515: PPUSH
45516: LD_VAR 0 9
45520: PUSH
45521: LD_VAR 0 3
45525: ARRAY
45526: PPUSH
45527: CALL_OW 2
45531: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45532: LD_ADDR_VAR 0 4
45536: PUSH
45537: LD_VAR 0 4
45541: PUSH
45542: LD_VAR 0 9
45546: PUSH
45547: LD_VAR 0 3
45551: ARRAY
45552: DIFF
45553: ST_TO_ADDR
// end ;
45554: GO 45463
45556: POP
45557: POP
// if p then
45558: LD_VAR 0 11
45562: IFFALSE 45587
// result := Replace ( result , 3 , p ) ;
45564: LD_ADDR_VAR 0 2
45568: PUSH
45569: LD_VAR 0 2
45573: PPUSH
45574: LD_INT 3
45576: PPUSH
45577: LD_VAR 0 11
45581: PPUSH
45582: CALL_OW 1
45586: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
45587: LD_ADDR_VAR 0 4
45591: PUSH
45592: LD_VAR 0 4
45596: PUSH
45597: LD_VAR 0 6
45601: DIFF
45602: ST_TO_ADDR
// if tmp and eng < 6 then
45603: LD_VAR 0 4
45607: PUSH
45608: LD_VAR 0 6
45612: PUSH
45613: LD_INT 6
45615: LESS
45616: AND
45617: IFFALSE 45811
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
45619: LD_ADDR_VAR 0 9
45623: PUSH
45624: LD_VAR 0 4
45628: PUSH
45629: LD_VAR 0 8
45633: PUSH
45634: LD_VAR 0 7
45638: UNION
45639: PUSH
45640: LD_VAR 0 6
45644: UNION
45645: DIFF
45646: PPUSH
45647: LD_INT 2
45649: PPUSH
45650: CALL 104707 0 2
45654: ST_TO_ADDR
// p := [ ] ;
45655: LD_ADDR_VAR 0 11
45659: PUSH
45660: EMPTY
45661: ST_TO_ADDR
// if sort then
45662: LD_VAR 0 9
45666: IFFALSE 45782
// for i = 1 to 6 - eng do
45668: LD_ADDR_VAR 0 3
45672: PUSH
45673: DOUBLE
45674: LD_INT 1
45676: DEC
45677: ST_TO_ADDR
45678: LD_INT 6
45680: PUSH
45681: LD_VAR 0 6
45685: MINUS
45686: PUSH
45687: FOR_TO
45688: IFFALSE 45780
// begin if i = sort then
45690: LD_VAR 0 3
45694: PUSH
45695: LD_VAR 0 9
45699: EQUAL
45700: IFFALSE 45704
// break ;
45702: GO 45780
// if GetClass ( i ) = 2 then
45704: LD_VAR 0 3
45708: PPUSH
45709: CALL_OW 257
45713: PUSH
45714: LD_INT 2
45716: EQUAL
45717: IFFALSE 45721
// continue ;
45719: GO 45687
// p := Insert ( p , p + 1 , sort [ i ] ) ;
45721: LD_ADDR_VAR 0 11
45725: PUSH
45726: LD_VAR 0 11
45730: PPUSH
45731: LD_VAR 0 11
45735: PUSH
45736: LD_INT 1
45738: PLUS
45739: PPUSH
45740: LD_VAR 0 9
45744: PUSH
45745: LD_VAR 0 3
45749: ARRAY
45750: PPUSH
45751: CALL_OW 2
45755: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
45756: LD_ADDR_VAR 0 4
45760: PUSH
45761: LD_VAR 0 4
45765: PUSH
45766: LD_VAR 0 9
45770: PUSH
45771: LD_VAR 0 3
45775: ARRAY
45776: DIFF
45777: ST_TO_ADDR
// end ;
45778: GO 45687
45780: POP
45781: POP
// if p then
45782: LD_VAR 0 11
45786: IFFALSE 45811
// result := Replace ( result , 2 , p ) ;
45788: LD_ADDR_VAR 0 2
45792: PUSH
45793: LD_VAR 0 2
45797: PPUSH
45798: LD_INT 2
45800: PPUSH
45801: LD_VAR 0 11
45805: PPUSH
45806: CALL_OW 1
45810: ST_TO_ADDR
// end ; exit ;
45811: GO 46535
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
45813: LD_EXP 127
45817: PUSH
45818: LD_EXP 126
45822: PUSH
45823: LD_VAR 0 1
45827: ARRAY
45828: ARRAY
45829: NOT
45830: PUSH
45831: LD_EXP 100
45835: PUSH
45836: LD_VAR 0 1
45840: ARRAY
45841: PPUSH
45842: LD_INT 30
45844: PUSH
45845: LD_INT 3
45847: PUSH
45848: EMPTY
45849: LIST
45850: LIST
45851: PPUSH
45852: CALL_OW 72
45856: AND
45857: PUSH
45858: LD_EXP 105
45862: PUSH
45863: LD_VAR 0 1
45867: ARRAY
45868: NOT
45869: AND
45870: IFFALSE 46535
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
45872: LD_ADDR_EXP 142
45876: PUSH
45877: LD_EXP 142
45881: PPUSH
45882: LD_VAR 0 1
45886: PPUSH
45887: LD_INT 6
45889: PPUSH
45890: CALL_OW 1
45894: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
45895: LD_ADDR_VAR 0 2
45899: PUSH
45900: LD_INT 0
45902: PUSH
45903: LD_INT 0
45905: PUSH
45906: LD_INT 0
45908: PUSH
45909: LD_INT 0
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: LIST
45916: LIST
45917: ST_TO_ADDR
// if sci >= 1 then
45918: LD_VAR 0 8
45922: PUSH
45923: LD_INT 1
45925: GREATEREQUAL
45926: IFFALSE 45948
// tmp := tmp diff sci [ 1 ] ;
45928: LD_ADDR_VAR 0 4
45932: PUSH
45933: LD_VAR 0 4
45937: PUSH
45938: LD_VAR 0 8
45942: PUSH
45943: LD_INT 1
45945: ARRAY
45946: DIFF
45947: ST_TO_ADDR
// if tmp and not sci then
45948: LD_VAR 0 4
45952: PUSH
45953: LD_VAR 0 8
45957: NOT
45958: AND
45959: IFFALSE 46028
// begin sort := SortBySkill ( tmp , 4 ) ;
45961: LD_ADDR_VAR 0 9
45965: PUSH
45966: LD_VAR 0 4
45970: PPUSH
45971: LD_INT 4
45973: PPUSH
45974: CALL 104707 0 2
45978: ST_TO_ADDR
// if sort then
45979: LD_VAR 0 9
45983: IFFALSE 45999
// p := sort [ 1 ] ;
45985: LD_ADDR_VAR 0 11
45989: PUSH
45990: LD_VAR 0 9
45994: PUSH
45995: LD_INT 1
45997: ARRAY
45998: ST_TO_ADDR
// if p then
45999: LD_VAR 0 11
46003: IFFALSE 46028
// result := Replace ( result , 4 , p ) ;
46005: LD_ADDR_VAR 0 2
46009: PUSH
46010: LD_VAR 0 2
46014: PPUSH
46015: LD_INT 4
46017: PPUSH
46018: LD_VAR 0 11
46022: PPUSH
46023: CALL_OW 1
46027: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
46028: LD_ADDR_VAR 0 4
46032: PUSH
46033: LD_VAR 0 4
46037: PUSH
46038: LD_VAR 0 7
46042: DIFF
46043: ST_TO_ADDR
// if tmp and mech < 6 then
46044: LD_VAR 0 4
46048: PUSH
46049: LD_VAR 0 7
46053: PUSH
46054: LD_INT 6
46056: LESS
46057: AND
46058: IFFALSE 46240
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
46060: LD_ADDR_VAR 0 9
46064: PUSH
46065: LD_VAR 0 4
46069: PUSH
46070: LD_VAR 0 7
46074: DIFF
46075: PPUSH
46076: LD_INT 3
46078: PPUSH
46079: CALL 104707 0 2
46083: ST_TO_ADDR
// p := [ ] ;
46084: LD_ADDR_VAR 0 11
46088: PUSH
46089: EMPTY
46090: ST_TO_ADDR
// if sort then
46091: LD_VAR 0 9
46095: IFFALSE 46211
// for i = 1 to 6 - mech do
46097: LD_ADDR_VAR 0 3
46101: PUSH
46102: DOUBLE
46103: LD_INT 1
46105: DEC
46106: ST_TO_ADDR
46107: LD_INT 6
46109: PUSH
46110: LD_VAR 0 7
46114: MINUS
46115: PUSH
46116: FOR_TO
46117: IFFALSE 46209
// begin if i = sort then
46119: LD_VAR 0 3
46123: PUSH
46124: LD_VAR 0 9
46128: EQUAL
46129: IFFALSE 46133
// break ;
46131: GO 46209
// if GetClass ( i ) = 3 then
46133: LD_VAR 0 3
46137: PPUSH
46138: CALL_OW 257
46142: PUSH
46143: LD_INT 3
46145: EQUAL
46146: IFFALSE 46150
// continue ;
46148: GO 46116
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46150: LD_ADDR_VAR 0 11
46154: PUSH
46155: LD_VAR 0 11
46159: PPUSH
46160: LD_VAR 0 11
46164: PUSH
46165: LD_INT 1
46167: PLUS
46168: PPUSH
46169: LD_VAR 0 9
46173: PUSH
46174: LD_VAR 0 3
46178: ARRAY
46179: PPUSH
46180: CALL_OW 2
46184: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46185: LD_ADDR_VAR 0 4
46189: PUSH
46190: LD_VAR 0 4
46194: PUSH
46195: LD_VAR 0 9
46199: PUSH
46200: LD_VAR 0 3
46204: ARRAY
46205: DIFF
46206: ST_TO_ADDR
// end ;
46207: GO 46116
46209: POP
46210: POP
// if p then
46211: LD_VAR 0 11
46215: IFFALSE 46240
// result := Replace ( result , 3 , p ) ;
46217: LD_ADDR_VAR 0 2
46221: PUSH
46222: LD_VAR 0 2
46226: PPUSH
46227: LD_INT 3
46229: PPUSH
46230: LD_VAR 0 11
46234: PPUSH
46235: CALL_OW 1
46239: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
46240: LD_ADDR_VAR 0 4
46244: PUSH
46245: LD_VAR 0 4
46249: PUSH
46250: LD_VAR 0 6
46254: DIFF
46255: ST_TO_ADDR
// if tmp and eng < 4 then
46256: LD_VAR 0 4
46260: PUSH
46261: LD_VAR 0 6
46265: PUSH
46266: LD_INT 4
46268: LESS
46269: AND
46270: IFFALSE 46460
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
46272: LD_ADDR_VAR 0 9
46276: PUSH
46277: LD_VAR 0 4
46281: PUSH
46282: LD_VAR 0 7
46286: PUSH
46287: LD_VAR 0 6
46291: UNION
46292: DIFF
46293: PPUSH
46294: LD_INT 2
46296: PPUSH
46297: CALL 104707 0 2
46301: ST_TO_ADDR
// p := [ ] ;
46302: LD_ADDR_VAR 0 11
46306: PUSH
46307: EMPTY
46308: ST_TO_ADDR
// if sort then
46309: LD_VAR 0 9
46313: IFFALSE 46429
// for i = 1 to 4 - eng do
46315: LD_ADDR_VAR 0 3
46319: PUSH
46320: DOUBLE
46321: LD_INT 1
46323: DEC
46324: ST_TO_ADDR
46325: LD_INT 4
46327: PUSH
46328: LD_VAR 0 6
46332: MINUS
46333: PUSH
46334: FOR_TO
46335: IFFALSE 46427
// begin if i = sort then
46337: LD_VAR 0 3
46341: PUSH
46342: LD_VAR 0 9
46346: EQUAL
46347: IFFALSE 46351
// break ;
46349: GO 46427
// if GetClass ( i ) = 2 then
46351: LD_VAR 0 3
46355: PPUSH
46356: CALL_OW 257
46360: PUSH
46361: LD_INT 2
46363: EQUAL
46364: IFFALSE 46368
// continue ;
46366: GO 46334
// p := Insert ( p , p + 1 , sort [ i ] ) ;
46368: LD_ADDR_VAR 0 11
46372: PUSH
46373: LD_VAR 0 11
46377: PPUSH
46378: LD_VAR 0 11
46382: PUSH
46383: LD_INT 1
46385: PLUS
46386: PPUSH
46387: LD_VAR 0 9
46391: PUSH
46392: LD_VAR 0 3
46396: ARRAY
46397: PPUSH
46398: CALL_OW 2
46402: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
46403: LD_ADDR_VAR 0 4
46407: PUSH
46408: LD_VAR 0 4
46412: PUSH
46413: LD_VAR 0 9
46417: PUSH
46418: LD_VAR 0 3
46422: ARRAY
46423: DIFF
46424: ST_TO_ADDR
// end ;
46425: GO 46334
46427: POP
46428: POP
// if p then
46429: LD_VAR 0 11
46433: IFFALSE 46458
// result := Replace ( result , 2 , p ) ;
46435: LD_ADDR_VAR 0 2
46439: PUSH
46440: LD_VAR 0 2
46444: PPUSH
46445: LD_INT 2
46447: PPUSH
46448: LD_VAR 0 11
46452: PPUSH
46453: CALL_OW 1
46457: ST_TO_ADDR
// end else
46458: GO 46504
// for i = eng downto 5 do
46460: LD_ADDR_VAR 0 3
46464: PUSH
46465: DOUBLE
46466: LD_VAR 0 6
46470: INC
46471: ST_TO_ADDR
46472: LD_INT 5
46474: PUSH
46475: FOR_DOWNTO
46476: IFFALSE 46502
// tmp := tmp union eng [ i ] ;
46478: LD_ADDR_VAR 0 4
46482: PUSH
46483: LD_VAR 0 4
46487: PUSH
46488: LD_VAR 0 6
46492: PUSH
46493: LD_VAR 0 3
46497: ARRAY
46498: UNION
46499: ST_TO_ADDR
46500: GO 46475
46502: POP
46503: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
46504: LD_ADDR_VAR 0 2
46508: PUSH
46509: LD_VAR 0 2
46513: PPUSH
46514: LD_INT 1
46516: PPUSH
46517: LD_VAR 0 4
46521: PUSH
46522: LD_VAR 0 5
46526: DIFF
46527: PPUSH
46528: CALL_OW 1
46532: ST_TO_ADDR
// exit ;
46533: GO 46535
// end ; end ;
46535: LD_VAR 0 2
46539: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
46540: LD_INT 0
46542: PPUSH
46543: PPUSH
46544: PPUSH
// if not mc_bases then
46545: LD_EXP 100
46549: NOT
46550: IFFALSE 46554
// exit ;
46552: GO 46696
// for i = 1 to mc_bases do
46554: LD_ADDR_VAR 0 2
46558: PUSH
46559: DOUBLE
46560: LD_INT 1
46562: DEC
46563: ST_TO_ADDR
46564: LD_EXP 100
46568: PUSH
46569: FOR_TO
46570: IFFALSE 46687
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
46572: LD_ADDR_VAR 0 3
46576: PUSH
46577: LD_EXP 100
46581: PUSH
46582: LD_VAR 0 2
46586: ARRAY
46587: PPUSH
46588: LD_INT 21
46590: PUSH
46591: LD_INT 3
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: PUSH
46598: LD_INT 3
46600: PUSH
46601: LD_INT 2
46603: PUSH
46604: LD_INT 30
46606: PUSH
46607: LD_INT 29
46609: PUSH
46610: EMPTY
46611: LIST
46612: LIST
46613: PUSH
46614: LD_INT 30
46616: PUSH
46617: LD_INT 30
46619: PUSH
46620: EMPTY
46621: LIST
46622: LIST
46623: PUSH
46624: EMPTY
46625: LIST
46626: LIST
46627: LIST
46628: PUSH
46629: EMPTY
46630: LIST
46631: LIST
46632: PUSH
46633: LD_INT 3
46635: PUSH
46636: LD_INT 24
46638: PUSH
46639: LD_INT 1000
46641: PUSH
46642: EMPTY
46643: LIST
46644: LIST
46645: PUSH
46646: EMPTY
46647: LIST
46648: LIST
46649: PUSH
46650: EMPTY
46651: LIST
46652: LIST
46653: LIST
46654: PPUSH
46655: CALL_OW 72
46659: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
46660: LD_ADDR_EXP 101
46664: PUSH
46665: LD_EXP 101
46669: PPUSH
46670: LD_VAR 0 2
46674: PPUSH
46675: LD_VAR 0 3
46679: PPUSH
46680: CALL_OW 1
46684: ST_TO_ADDR
// end ;
46685: GO 46569
46687: POP
46688: POP
// RaiseSailEvent ( 101 ) ;
46689: LD_INT 101
46691: PPUSH
46692: CALL_OW 427
// end ;
46696: LD_VAR 0 1
46700: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
46701: LD_INT 0
46703: PPUSH
46704: PPUSH
46705: PPUSH
46706: PPUSH
46707: PPUSH
46708: PPUSH
46709: PPUSH
// if not mc_bases then
46710: LD_EXP 100
46714: NOT
46715: IFFALSE 46719
// exit ;
46717: GO 47281
// for i = 1 to mc_bases do
46719: LD_ADDR_VAR 0 2
46723: PUSH
46724: DOUBLE
46725: LD_INT 1
46727: DEC
46728: ST_TO_ADDR
46729: LD_EXP 100
46733: PUSH
46734: FOR_TO
46735: IFFALSE 47272
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
46737: LD_ADDR_VAR 0 5
46741: PUSH
46742: LD_EXP 100
46746: PUSH
46747: LD_VAR 0 2
46751: ARRAY
46752: PUSH
46753: LD_EXP 129
46757: PUSH
46758: LD_VAR 0 2
46762: ARRAY
46763: UNION
46764: PPUSH
46765: LD_INT 21
46767: PUSH
46768: LD_INT 1
46770: PUSH
46771: EMPTY
46772: LIST
46773: LIST
46774: PUSH
46775: LD_INT 1
46777: PUSH
46778: LD_INT 3
46780: PUSH
46781: LD_INT 54
46783: PUSH
46784: EMPTY
46785: LIST
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: LD_INT 3
46793: PUSH
46794: LD_INT 24
46796: PUSH
46797: LD_INT 1000
46799: PUSH
46800: EMPTY
46801: LIST
46802: LIST
46803: PUSH
46804: EMPTY
46805: LIST
46806: LIST
46807: PUSH
46808: EMPTY
46809: LIST
46810: LIST
46811: LIST
46812: PUSH
46813: EMPTY
46814: LIST
46815: LIST
46816: PPUSH
46817: CALL_OW 72
46821: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
46822: LD_ADDR_VAR 0 6
46826: PUSH
46827: LD_EXP 100
46831: PUSH
46832: LD_VAR 0 2
46836: ARRAY
46837: PPUSH
46838: LD_INT 21
46840: PUSH
46841: LD_INT 1
46843: PUSH
46844: EMPTY
46845: LIST
46846: LIST
46847: PUSH
46848: LD_INT 1
46850: PUSH
46851: LD_INT 3
46853: PUSH
46854: LD_INT 54
46856: PUSH
46857: EMPTY
46858: LIST
46859: PUSH
46860: EMPTY
46861: LIST
46862: LIST
46863: PUSH
46864: LD_INT 3
46866: PUSH
46867: LD_INT 24
46869: PUSH
46870: LD_INT 250
46872: PUSH
46873: EMPTY
46874: LIST
46875: LIST
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: PUSH
46881: EMPTY
46882: LIST
46883: LIST
46884: LIST
46885: PUSH
46886: EMPTY
46887: LIST
46888: LIST
46889: PPUSH
46890: CALL_OW 72
46894: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
46895: LD_ADDR_VAR 0 7
46899: PUSH
46900: LD_VAR 0 5
46904: PUSH
46905: LD_VAR 0 6
46909: DIFF
46910: ST_TO_ADDR
// if not need_heal_1 then
46911: LD_VAR 0 6
46915: NOT
46916: IFFALSE 46949
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
46918: LD_ADDR_EXP 103
46922: PUSH
46923: LD_EXP 103
46927: PPUSH
46928: LD_VAR 0 2
46932: PUSH
46933: LD_INT 1
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: PPUSH
46940: EMPTY
46941: PPUSH
46942: CALL 73860 0 3
46946: ST_TO_ADDR
46947: GO 47019
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
46949: LD_ADDR_EXP 103
46953: PUSH
46954: LD_EXP 103
46958: PPUSH
46959: LD_VAR 0 2
46963: PUSH
46964: LD_INT 1
46966: PUSH
46967: EMPTY
46968: LIST
46969: LIST
46970: PPUSH
46971: LD_EXP 103
46975: PUSH
46976: LD_VAR 0 2
46980: ARRAY
46981: PUSH
46982: LD_INT 1
46984: ARRAY
46985: PPUSH
46986: LD_INT 3
46988: PUSH
46989: LD_INT 24
46991: PUSH
46992: LD_INT 1000
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: EMPTY
47000: LIST
47001: LIST
47002: PPUSH
47003: CALL_OW 72
47007: PUSH
47008: LD_VAR 0 6
47012: UNION
47013: PPUSH
47014: CALL 73860 0 3
47018: ST_TO_ADDR
// if not need_heal_2 then
47019: LD_VAR 0 7
47023: NOT
47024: IFFALSE 47057
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
47026: LD_ADDR_EXP 103
47030: PUSH
47031: LD_EXP 103
47035: PPUSH
47036: LD_VAR 0 2
47040: PUSH
47041: LD_INT 2
47043: PUSH
47044: EMPTY
47045: LIST
47046: LIST
47047: PPUSH
47048: EMPTY
47049: PPUSH
47050: CALL 73860 0 3
47054: ST_TO_ADDR
47055: GO 47089
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
47057: LD_ADDR_EXP 103
47061: PUSH
47062: LD_EXP 103
47066: PPUSH
47067: LD_VAR 0 2
47071: PUSH
47072: LD_INT 2
47074: PUSH
47075: EMPTY
47076: LIST
47077: LIST
47078: PPUSH
47079: LD_VAR 0 7
47083: PPUSH
47084: CALL 73860 0 3
47088: ST_TO_ADDR
// if need_heal_2 then
47089: LD_VAR 0 7
47093: IFFALSE 47254
// for j in need_heal_2 do
47095: LD_ADDR_VAR 0 3
47099: PUSH
47100: LD_VAR 0 7
47104: PUSH
47105: FOR_IN
47106: IFFALSE 47252
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47108: LD_ADDR_VAR 0 5
47112: PUSH
47113: LD_EXP 100
47117: PUSH
47118: LD_VAR 0 2
47122: ARRAY
47123: PPUSH
47124: LD_INT 2
47126: PUSH
47127: LD_INT 30
47129: PUSH
47130: LD_INT 6
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: PUSH
47137: LD_INT 30
47139: PUSH
47140: LD_INT 7
47142: PUSH
47143: EMPTY
47144: LIST
47145: LIST
47146: PUSH
47147: LD_INT 30
47149: PUSH
47150: LD_INT 8
47152: PUSH
47153: EMPTY
47154: LIST
47155: LIST
47156: PUSH
47157: LD_INT 30
47159: PUSH
47160: LD_INT 0
47162: PUSH
47163: EMPTY
47164: LIST
47165: LIST
47166: PUSH
47167: LD_INT 30
47169: PUSH
47170: LD_INT 1
47172: PUSH
47173: EMPTY
47174: LIST
47175: LIST
47176: PUSH
47177: EMPTY
47178: LIST
47179: LIST
47180: LIST
47181: LIST
47182: LIST
47183: LIST
47184: PPUSH
47185: CALL_OW 72
47189: ST_TO_ADDR
// if tmp then
47190: LD_VAR 0 5
47194: IFFALSE 47250
// begin k := NearestUnitToUnit ( tmp , j ) ;
47196: LD_ADDR_VAR 0 4
47200: PUSH
47201: LD_VAR 0 5
47205: PPUSH
47206: LD_VAR 0 3
47210: PPUSH
47211: CALL_OW 74
47215: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
47216: LD_VAR 0 3
47220: PPUSH
47221: LD_VAR 0 4
47225: PPUSH
47226: CALL_OW 296
47230: PUSH
47231: LD_INT 5
47233: GREATER
47234: IFFALSE 47250
// ComMoveToNearbyEntrance ( j , k ) ;
47236: LD_VAR 0 3
47240: PPUSH
47241: LD_VAR 0 4
47245: PPUSH
47246: CALL 107067 0 2
// end ; end ;
47250: GO 47105
47252: POP
47253: POP
// if not need_heal_1 and not need_heal_2 then
47254: LD_VAR 0 6
47258: NOT
47259: PUSH
47260: LD_VAR 0 7
47264: NOT
47265: AND
47266: IFFALSE 47270
// continue ;
47268: GO 46734
// end ;
47270: GO 46734
47272: POP
47273: POP
// RaiseSailEvent ( 102 ) ;
47274: LD_INT 102
47276: PPUSH
47277: CALL_OW 427
// end ;
47281: LD_VAR 0 1
47285: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
47286: LD_INT 0
47288: PPUSH
47289: PPUSH
47290: PPUSH
47291: PPUSH
47292: PPUSH
47293: PPUSH
47294: PPUSH
47295: PPUSH
// if not mc_bases then
47296: LD_EXP 100
47300: NOT
47301: IFFALSE 47305
// exit ;
47303: GO 48216
// for i = 1 to mc_bases do
47305: LD_ADDR_VAR 0 2
47309: PUSH
47310: DOUBLE
47311: LD_INT 1
47313: DEC
47314: ST_TO_ADDR
47315: LD_EXP 100
47319: PUSH
47320: FOR_TO
47321: IFFALSE 48214
// begin if not mc_building_need_repair [ i ] then
47323: LD_EXP 101
47327: PUSH
47328: LD_VAR 0 2
47332: ARRAY
47333: NOT
47334: IFFALSE 47519
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
47336: LD_ADDR_VAR 0 6
47340: PUSH
47341: LD_EXP 119
47345: PUSH
47346: LD_VAR 0 2
47350: ARRAY
47351: PPUSH
47352: LD_INT 3
47354: PUSH
47355: LD_INT 24
47357: PUSH
47358: LD_INT 1000
47360: PUSH
47361: EMPTY
47362: LIST
47363: LIST
47364: PUSH
47365: EMPTY
47366: LIST
47367: LIST
47368: PUSH
47369: LD_INT 2
47371: PUSH
47372: LD_INT 34
47374: PUSH
47375: LD_INT 13
47377: PUSH
47378: EMPTY
47379: LIST
47380: LIST
47381: PUSH
47382: LD_INT 34
47384: PUSH
47385: LD_INT 52
47387: PUSH
47388: EMPTY
47389: LIST
47390: LIST
47391: PUSH
47392: LD_INT 34
47394: PUSH
47395: LD_INT 88
47397: PUSH
47398: EMPTY
47399: LIST
47400: LIST
47401: PUSH
47402: EMPTY
47403: LIST
47404: LIST
47405: LIST
47406: LIST
47407: PUSH
47408: EMPTY
47409: LIST
47410: LIST
47411: PPUSH
47412: CALL_OW 72
47416: ST_TO_ADDR
// if cranes then
47417: LD_VAR 0 6
47421: IFFALSE 47483
// for j in cranes do
47423: LD_ADDR_VAR 0 3
47427: PUSH
47428: LD_VAR 0 6
47432: PUSH
47433: FOR_IN
47434: IFFALSE 47481
// if not IsInArea ( j , mc_parking [ i ] ) then
47436: LD_VAR 0 3
47440: PPUSH
47441: LD_EXP 124
47445: PUSH
47446: LD_VAR 0 2
47450: ARRAY
47451: PPUSH
47452: CALL_OW 308
47456: NOT
47457: IFFALSE 47479
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47459: LD_VAR 0 3
47463: PPUSH
47464: LD_EXP 124
47468: PUSH
47469: LD_VAR 0 2
47473: ARRAY
47474: PPUSH
47475: CALL_OW 113
47479: GO 47433
47481: POP
47482: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
47483: LD_ADDR_EXP 102
47487: PUSH
47488: LD_EXP 102
47492: PPUSH
47493: LD_VAR 0 2
47497: PPUSH
47498: EMPTY
47499: PPUSH
47500: CALL_OW 1
47504: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
47505: LD_VAR 0 2
47509: PPUSH
47510: LD_INT 101
47512: PPUSH
47513: CALL 42373 0 2
// continue ;
47517: GO 47320
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
47519: LD_ADDR_EXP 106
47523: PUSH
47524: LD_EXP 106
47528: PPUSH
47529: LD_VAR 0 2
47533: PPUSH
47534: EMPTY
47535: PPUSH
47536: CALL_OW 1
47540: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
47541: LD_VAR 0 2
47545: PPUSH
47546: LD_INT 103
47548: PPUSH
47549: CALL 42373 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
47553: LD_ADDR_VAR 0 5
47557: PUSH
47558: LD_EXP 100
47562: PUSH
47563: LD_VAR 0 2
47567: ARRAY
47568: PUSH
47569: LD_EXP 129
47573: PUSH
47574: LD_VAR 0 2
47578: ARRAY
47579: UNION
47580: PPUSH
47581: LD_INT 2
47583: PUSH
47584: LD_INT 25
47586: PUSH
47587: LD_INT 2
47589: PUSH
47590: EMPTY
47591: LIST
47592: LIST
47593: PUSH
47594: LD_INT 25
47596: PUSH
47597: LD_INT 16
47599: PUSH
47600: EMPTY
47601: LIST
47602: LIST
47603: PUSH
47604: EMPTY
47605: LIST
47606: LIST
47607: LIST
47608: PUSH
47609: EMPTY
47610: LIST
47611: PPUSH
47612: CALL_OW 72
47616: ST_TO_ADDR
// if mc_need_heal [ i ] then
47617: LD_EXP 103
47621: PUSH
47622: LD_VAR 0 2
47626: ARRAY
47627: IFFALSE 47671
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
47629: LD_ADDR_VAR 0 5
47633: PUSH
47634: LD_VAR 0 5
47638: PUSH
47639: LD_EXP 103
47643: PUSH
47644: LD_VAR 0 2
47648: ARRAY
47649: PUSH
47650: LD_INT 1
47652: ARRAY
47653: PUSH
47654: LD_EXP 103
47658: PUSH
47659: LD_VAR 0 2
47663: ARRAY
47664: PUSH
47665: LD_INT 2
47667: ARRAY
47668: UNION
47669: DIFF
47670: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
47671: LD_ADDR_VAR 0 6
47675: PUSH
47676: LD_EXP 119
47680: PUSH
47681: LD_VAR 0 2
47685: ARRAY
47686: PPUSH
47687: LD_INT 2
47689: PUSH
47690: LD_INT 34
47692: PUSH
47693: LD_INT 13
47695: PUSH
47696: EMPTY
47697: LIST
47698: LIST
47699: PUSH
47700: LD_INT 34
47702: PUSH
47703: LD_INT 52
47705: PUSH
47706: EMPTY
47707: LIST
47708: LIST
47709: PUSH
47710: LD_INT 34
47712: PUSH
47713: LD_INT 88
47715: PUSH
47716: EMPTY
47717: LIST
47718: LIST
47719: PUSH
47720: EMPTY
47721: LIST
47722: LIST
47723: LIST
47724: LIST
47725: PPUSH
47726: CALL_OW 72
47730: ST_TO_ADDR
// if cranes then
47731: LD_VAR 0 6
47735: IFFALSE 47903
// begin for j in cranes do
47737: LD_ADDR_VAR 0 3
47741: PUSH
47742: LD_VAR 0 6
47746: PUSH
47747: FOR_IN
47748: IFFALSE 47901
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
47750: LD_VAR 0 3
47754: PPUSH
47755: CALL_OW 256
47759: PUSH
47760: LD_INT 1000
47762: EQUAL
47763: PUSH
47764: LD_VAR 0 3
47768: PPUSH
47769: CALL_OW 314
47773: NOT
47774: AND
47775: IFFALSE 47841
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
47777: LD_ADDR_VAR 0 8
47781: PUSH
47782: LD_EXP 101
47786: PUSH
47787: LD_VAR 0 2
47791: ARRAY
47792: PPUSH
47793: LD_VAR 0 3
47797: PPUSH
47798: CALL_OW 74
47802: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
47803: LD_VAR 0 8
47807: PPUSH
47808: LD_INT 16
47810: PPUSH
47811: CALL 76457 0 2
47815: PUSH
47816: LD_INT 4
47818: ARRAY
47819: PUSH
47820: LD_INT 10
47822: LESS
47823: IFFALSE 47839
// ComRepairBuilding ( j , to_repair ) ;
47825: LD_VAR 0 3
47829: PPUSH
47830: LD_VAR 0 8
47834: PPUSH
47835: CALL_OW 130
// end else
47839: GO 47899
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
47841: LD_VAR 0 3
47845: PPUSH
47846: CALL_OW 256
47850: PUSH
47851: LD_INT 500
47853: LESS
47854: PUSH
47855: LD_VAR 0 3
47859: PPUSH
47860: LD_EXP 124
47864: PUSH
47865: LD_VAR 0 2
47869: ARRAY
47870: PPUSH
47871: CALL_OW 308
47875: NOT
47876: AND
47877: IFFALSE 47899
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47879: LD_VAR 0 3
47883: PPUSH
47884: LD_EXP 124
47888: PUSH
47889: LD_VAR 0 2
47893: ARRAY
47894: PPUSH
47895: CALL_OW 113
// end ;
47899: GO 47747
47901: POP
47902: POP
// end ; if tmp > 3 then
47903: LD_VAR 0 5
47907: PUSH
47908: LD_INT 3
47910: GREATER
47911: IFFALSE 47931
// tmp := ShrinkArray ( tmp , 4 ) ;
47913: LD_ADDR_VAR 0 5
47917: PUSH
47918: LD_VAR 0 5
47922: PPUSH
47923: LD_INT 4
47925: PPUSH
47926: CALL 106505 0 2
47930: ST_TO_ADDR
// if not tmp then
47931: LD_VAR 0 5
47935: NOT
47936: IFFALSE 47940
// continue ;
47938: GO 47320
// for j in tmp do
47940: LD_ADDR_VAR 0 3
47944: PUSH
47945: LD_VAR 0 5
47949: PUSH
47950: FOR_IN
47951: IFFALSE 48210
// begin if IsInUnit ( j ) then
47953: LD_VAR 0 3
47957: PPUSH
47958: CALL_OW 310
47962: IFFALSE 47973
// ComExitBuilding ( j ) ;
47964: LD_VAR 0 3
47968: PPUSH
47969: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
47973: LD_VAR 0 3
47977: PUSH
47978: LD_EXP 102
47982: PUSH
47983: LD_VAR 0 2
47987: ARRAY
47988: IN
47989: NOT
47990: IFFALSE 48048
// begin SetTag ( j , 101 ) ;
47992: LD_VAR 0 3
47996: PPUSH
47997: LD_INT 101
47999: PPUSH
48000: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
48004: LD_ADDR_EXP 102
48008: PUSH
48009: LD_EXP 102
48013: PPUSH
48014: LD_VAR 0 2
48018: PUSH
48019: LD_EXP 102
48023: PUSH
48024: LD_VAR 0 2
48028: ARRAY
48029: PUSH
48030: LD_INT 1
48032: PLUS
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PPUSH
48038: LD_VAR 0 3
48042: PPUSH
48043: CALL 73860 0 3
48047: ST_TO_ADDR
// end ; wait ( 1 ) ;
48048: LD_INT 1
48050: PPUSH
48051: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
48055: LD_ADDR_VAR 0 7
48059: PUSH
48060: LD_EXP 101
48064: PUSH
48065: LD_VAR 0 2
48069: ARRAY
48070: ST_TO_ADDR
// if mc_scan [ i ] then
48071: LD_EXP 123
48075: PUSH
48076: LD_VAR 0 2
48080: ARRAY
48081: IFFALSE 48143
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
48083: LD_ADDR_VAR 0 7
48087: PUSH
48088: LD_EXP 101
48092: PUSH
48093: LD_VAR 0 2
48097: ARRAY
48098: PPUSH
48099: LD_INT 3
48101: PUSH
48102: LD_INT 30
48104: PUSH
48105: LD_INT 32
48107: PUSH
48108: EMPTY
48109: LIST
48110: LIST
48111: PUSH
48112: LD_INT 30
48114: PUSH
48115: LD_INT 33
48117: PUSH
48118: EMPTY
48119: LIST
48120: LIST
48121: PUSH
48122: LD_INT 30
48124: PUSH
48125: LD_INT 31
48127: PUSH
48128: EMPTY
48129: LIST
48130: LIST
48131: PUSH
48132: EMPTY
48133: LIST
48134: LIST
48135: LIST
48136: LIST
48137: PPUSH
48138: CALL_OW 72
48142: ST_TO_ADDR
// if not to_repair_tmp then
48143: LD_VAR 0 7
48147: NOT
48148: IFFALSE 48152
// continue ;
48150: GO 47950
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
48152: LD_ADDR_VAR 0 8
48156: PUSH
48157: LD_VAR 0 7
48161: PPUSH
48162: LD_VAR 0 3
48166: PPUSH
48167: CALL_OW 74
48171: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
48172: LD_VAR 0 8
48176: PPUSH
48177: LD_INT 16
48179: PPUSH
48180: CALL 76457 0 2
48184: PUSH
48185: LD_INT 4
48187: ARRAY
48188: PUSH
48189: LD_INT 14
48191: LESS
48192: IFFALSE 48208
// ComRepairBuilding ( j , to_repair ) ;
48194: LD_VAR 0 3
48198: PPUSH
48199: LD_VAR 0 8
48203: PPUSH
48204: CALL_OW 130
// end ;
48208: GO 47950
48210: POP
48211: POP
// end ;
48212: GO 47320
48214: POP
48215: POP
// end ;
48216: LD_VAR 0 1
48220: RET
// export function MC_Heal ; var i , j , tmp ; begin
48221: LD_INT 0
48223: PPUSH
48224: PPUSH
48225: PPUSH
48226: PPUSH
// if not mc_bases then
48227: LD_EXP 100
48231: NOT
48232: IFFALSE 48236
// exit ;
48234: GO 48638
// for i = 1 to mc_bases do
48236: LD_ADDR_VAR 0 2
48240: PUSH
48241: DOUBLE
48242: LD_INT 1
48244: DEC
48245: ST_TO_ADDR
48246: LD_EXP 100
48250: PUSH
48251: FOR_TO
48252: IFFALSE 48636
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
48254: LD_EXP 103
48258: PUSH
48259: LD_VAR 0 2
48263: ARRAY
48264: PUSH
48265: LD_INT 1
48267: ARRAY
48268: NOT
48269: PUSH
48270: LD_EXP 103
48274: PUSH
48275: LD_VAR 0 2
48279: ARRAY
48280: PUSH
48281: LD_INT 2
48283: ARRAY
48284: NOT
48285: AND
48286: IFFALSE 48324
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
48288: LD_ADDR_EXP 104
48292: PUSH
48293: LD_EXP 104
48297: PPUSH
48298: LD_VAR 0 2
48302: PPUSH
48303: EMPTY
48304: PPUSH
48305: CALL_OW 1
48309: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
48310: LD_VAR 0 2
48314: PPUSH
48315: LD_INT 102
48317: PPUSH
48318: CALL 42373 0 2
// continue ;
48322: GO 48251
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
48324: LD_ADDR_VAR 0 4
48328: PUSH
48329: LD_EXP 100
48333: PUSH
48334: LD_VAR 0 2
48338: ARRAY
48339: PPUSH
48340: LD_INT 25
48342: PUSH
48343: LD_INT 4
48345: PUSH
48346: EMPTY
48347: LIST
48348: LIST
48349: PPUSH
48350: CALL_OW 72
48354: ST_TO_ADDR
// if not tmp then
48355: LD_VAR 0 4
48359: NOT
48360: IFFALSE 48364
// continue ;
48362: GO 48251
// if mc_taming [ i ] then
48364: LD_EXP 131
48368: PUSH
48369: LD_VAR 0 2
48373: ARRAY
48374: IFFALSE 48398
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
48376: LD_ADDR_EXP 131
48380: PUSH
48381: LD_EXP 131
48385: PPUSH
48386: LD_VAR 0 2
48390: PPUSH
48391: EMPTY
48392: PPUSH
48393: CALL_OW 1
48397: ST_TO_ADDR
// for j in tmp do
48398: LD_ADDR_VAR 0 3
48402: PUSH
48403: LD_VAR 0 4
48407: PUSH
48408: FOR_IN
48409: IFFALSE 48632
// begin if IsInUnit ( j ) then
48411: LD_VAR 0 3
48415: PPUSH
48416: CALL_OW 310
48420: IFFALSE 48431
// ComExitBuilding ( j ) ;
48422: LD_VAR 0 3
48426: PPUSH
48427: CALL_OW 122
// if not j in mc_healers [ i ] then
48431: LD_VAR 0 3
48435: PUSH
48436: LD_EXP 104
48440: PUSH
48441: LD_VAR 0 2
48445: ARRAY
48446: IN
48447: NOT
48448: IFFALSE 48494
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
48450: LD_ADDR_EXP 104
48454: PUSH
48455: LD_EXP 104
48459: PPUSH
48460: LD_VAR 0 2
48464: PUSH
48465: LD_EXP 104
48469: PUSH
48470: LD_VAR 0 2
48474: ARRAY
48475: PUSH
48476: LD_INT 1
48478: PLUS
48479: PUSH
48480: EMPTY
48481: LIST
48482: LIST
48483: PPUSH
48484: LD_VAR 0 3
48488: PPUSH
48489: CALL 73860 0 3
48493: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
48494: LD_VAR 0 3
48498: PPUSH
48499: CALL_OW 110
48503: PUSH
48504: LD_INT 102
48506: NONEQUAL
48507: IFFALSE 48521
// SetTag ( j , 102 ) ;
48509: LD_VAR 0 3
48513: PPUSH
48514: LD_INT 102
48516: PPUSH
48517: CALL_OW 109
// Wait ( 3 ) ;
48521: LD_INT 3
48523: PPUSH
48524: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
48528: LD_EXP 103
48532: PUSH
48533: LD_VAR 0 2
48537: ARRAY
48538: PUSH
48539: LD_INT 1
48541: ARRAY
48542: IFFALSE 48574
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
48544: LD_VAR 0 3
48548: PPUSH
48549: LD_EXP 103
48553: PUSH
48554: LD_VAR 0 2
48558: ARRAY
48559: PUSH
48560: LD_INT 1
48562: ARRAY
48563: PUSH
48564: LD_INT 1
48566: ARRAY
48567: PPUSH
48568: CALL_OW 128
48572: GO 48630
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
48574: LD_VAR 0 3
48578: PPUSH
48579: CALL_OW 314
48583: NOT
48584: PUSH
48585: LD_EXP 103
48589: PUSH
48590: LD_VAR 0 2
48594: ARRAY
48595: PUSH
48596: LD_INT 2
48598: ARRAY
48599: AND
48600: IFFALSE 48630
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
48602: LD_VAR 0 3
48606: PPUSH
48607: LD_EXP 103
48611: PUSH
48612: LD_VAR 0 2
48616: ARRAY
48617: PUSH
48618: LD_INT 2
48620: ARRAY
48621: PUSH
48622: LD_INT 1
48624: ARRAY
48625: PPUSH
48626: CALL_OW 128
// end ;
48630: GO 48408
48632: POP
48633: POP
// end ;
48634: GO 48251
48636: POP
48637: POP
// end ;
48638: LD_VAR 0 1
48642: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
48643: LD_INT 0
48645: PPUSH
48646: PPUSH
48647: PPUSH
48648: PPUSH
48649: PPUSH
48650: PPUSH
// if not mc_bases then
48651: LD_EXP 100
48655: NOT
48656: IFFALSE 48660
// exit ;
48658: GO 49823
// for i = 1 to mc_bases do
48660: LD_ADDR_VAR 0 2
48664: PUSH
48665: DOUBLE
48666: LD_INT 1
48668: DEC
48669: ST_TO_ADDR
48670: LD_EXP 100
48674: PUSH
48675: FOR_TO
48676: IFFALSE 49821
// begin if mc_scan [ i ] then
48678: LD_EXP 123
48682: PUSH
48683: LD_VAR 0 2
48687: ARRAY
48688: IFFALSE 48692
// continue ;
48690: GO 48675
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
48692: LD_EXP 105
48696: PUSH
48697: LD_VAR 0 2
48701: ARRAY
48702: NOT
48703: PUSH
48704: LD_EXP 107
48708: PUSH
48709: LD_VAR 0 2
48713: ARRAY
48714: NOT
48715: AND
48716: PUSH
48717: LD_EXP 106
48721: PUSH
48722: LD_VAR 0 2
48726: ARRAY
48727: AND
48728: IFFALSE 48766
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
48730: LD_ADDR_EXP 106
48734: PUSH
48735: LD_EXP 106
48739: PPUSH
48740: LD_VAR 0 2
48744: PPUSH
48745: EMPTY
48746: PPUSH
48747: CALL_OW 1
48751: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
48752: LD_VAR 0 2
48756: PPUSH
48757: LD_INT 103
48759: PPUSH
48760: CALL 42373 0 2
// continue ;
48764: GO 48675
// end ; if mc_construct_list [ i ] then
48766: LD_EXP 107
48770: PUSH
48771: LD_VAR 0 2
48775: ARRAY
48776: IFFALSE 48996
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
48778: LD_ADDR_VAR 0 5
48782: PUSH
48783: LD_EXP 100
48787: PUSH
48788: LD_VAR 0 2
48792: ARRAY
48793: PPUSH
48794: LD_INT 25
48796: PUSH
48797: LD_INT 2
48799: PUSH
48800: EMPTY
48801: LIST
48802: LIST
48803: PPUSH
48804: CALL_OW 72
48808: PUSH
48809: LD_EXP 102
48813: PUSH
48814: LD_VAR 0 2
48818: ARRAY
48819: DIFF
48820: ST_TO_ADDR
// if not tmp then
48821: LD_VAR 0 5
48825: NOT
48826: IFFALSE 48830
// continue ;
48828: GO 48675
// for j in tmp do
48830: LD_ADDR_VAR 0 3
48834: PUSH
48835: LD_VAR 0 5
48839: PUSH
48840: FOR_IN
48841: IFFALSE 48992
// begin if not mc_builders [ i ] then
48843: LD_EXP 106
48847: PUSH
48848: LD_VAR 0 2
48852: ARRAY
48853: NOT
48854: IFFALSE 48912
// begin SetTag ( j , 103 ) ;
48856: LD_VAR 0 3
48860: PPUSH
48861: LD_INT 103
48863: PPUSH
48864: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
48868: LD_ADDR_EXP 106
48872: PUSH
48873: LD_EXP 106
48877: PPUSH
48878: LD_VAR 0 2
48882: PUSH
48883: LD_EXP 106
48887: PUSH
48888: LD_VAR 0 2
48892: ARRAY
48893: PUSH
48894: LD_INT 1
48896: PLUS
48897: PUSH
48898: EMPTY
48899: LIST
48900: LIST
48901: PPUSH
48902: LD_VAR 0 3
48906: PPUSH
48907: CALL 73860 0 3
48911: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
48912: LD_VAR 0 3
48916: PPUSH
48917: CALL_OW 310
48921: IFFALSE 48932
// ComExitBuilding ( j ) ;
48923: LD_VAR 0 3
48927: PPUSH
48928: CALL_OW 122
// wait ( 3 ) ;
48932: LD_INT 3
48934: PPUSH
48935: CALL_OW 67
// if not mc_construct_list [ i ] then
48939: LD_EXP 107
48943: PUSH
48944: LD_VAR 0 2
48948: ARRAY
48949: NOT
48950: IFFALSE 48954
// break ;
48952: GO 48992
// if not HasTask ( j ) then
48954: LD_VAR 0 3
48958: PPUSH
48959: CALL_OW 314
48963: NOT
48964: IFFALSE 48990
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
48966: LD_VAR 0 3
48970: PPUSH
48971: LD_EXP 107
48975: PUSH
48976: LD_VAR 0 2
48980: ARRAY
48981: PUSH
48982: LD_INT 1
48984: ARRAY
48985: PPUSH
48986: CALL 76721 0 2
// end ;
48990: GO 48840
48992: POP
48993: POP
// end else
48994: GO 49819
// if mc_build_list [ i ] then
48996: LD_EXP 105
49000: PUSH
49001: LD_VAR 0 2
49005: ARRAY
49006: IFFALSE 49819
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
49008: LD_EXP 105
49012: PUSH
49013: LD_VAR 0 2
49017: ARRAY
49018: PUSH
49019: LD_INT 1
49021: ARRAY
49022: PUSH
49023: LD_INT 1
49025: ARRAY
49026: PPUSH
49027: CALL 76545 0 1
49031: PUSH
49032: LD_EXP 100
49036: PUSH
49037: LD_VAR 0 2
49041: ARRAY
49042: PPUSH
49043: LD_INT 2
49045: PUSH
49046: LD_INT 30
49048: PUSH
49049: LD_INT 2
49051: PUSH
49052: EMPTY
49053: LIST
49054: LIST
49055: PUSH
49056: LD_INT 30
49058: PUSH
49059: LD_INT 3
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: PUSH
49066: EMPTY
49067: LIST
49068: LIST
49069: LIST
49070: PPUSH
49071: CALL_OW 72
49075: NOT
49076: AND
49077: IFFALSE 49182
// begin for j = 1 to mc_build_list [ i ] do
49079: LD_ADDR_VAR 0 3
49083: PUSH
49084: DOUBLE
49085: LD_INT 1
49087: DEC
49088: ST_TO_ADDR
49089: LD_EXP 105
49093: PUSH
49094: LD_VAR 0 2
49098: ARRAY
49099: PUSH
49100: FOR_TO
49101: IFFALSE 49180
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
49103: LD_EXP 105
49107: PUSH
49108: LD_VAR 0 2
49112: ARRAY
49113: PUSH
49114: LD_VAR 0 3
49118: ARRAY
49119: PUSH
49120: LD_INT 1
49122: ARRAY
49123: PUSH
49124: LD_INT 2
49126: EQUAL
49127: IFFALSE 49178
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
49129: LD_ADDR_EXP 105
49133: PUSH
49134: LD_EXP 105
49138: PPUSH
49139: LD_VAR 0 2
49143: PPUSH
49144: LD_EXP 105
49148: PUSH
49149: LD_VAR 0 2
49153: ARRAY
49154: PPUSH
49155: LD_VAR 0 3
49159: PPUSH
49160: LD_INT 1
49162: PPUSH
49163: LD_INT 0
49165: PPUSH
49166: CALL 73278 0 4
49170: PPUSH
49171: CALL_OW 1
49175: ST_TO_ADDR
// break ;
49176: GO 49180
// end ;
49178: GO 49100
49180: POP
49181: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49182: LD_ADDR_VAR 0 6
49186: PUSH
49187: LD_EXP 100
49191: PUSH
49192: LD_VAR 0 2
49196: ARRAY
49197: PPUSH
49198: LD_INT 2
49200: PUSH
49201: LD_INT 30
49203: PUSH
49204: LD_INT 0
49206: PUSH
49207: EMPTY
49208: LIST
49209: LIST
49210: PUSH
49211: LD_INT 30
49213: PUSH
49214: LD_INT 1
49216: PUSH
49217: EMPTY
49218: LIST
49219: LIST
49220: PUSH
49221: EMPTY
49222: LIST
49223: LIST
49224: LIST
49225: PPUSH
49226: CALL_OW 72
49230: ST_TO_ADDR
// for k := 1 to depot do
49231: LD_ADDR_VAR 0 4
49235: PUSH
49236: DOUBLE
49237: LD_INT 1
49239: DEC
49240: ST_TO_ADDR
49241: LD_VAR 0 6
49245: PUSH
49246: FOR_TO
49247: IFFALSE 49817
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
49249: LD_EXP 105
49253: PUSH
49254: LD_VAR 0 2
49258: ARRAY
49259: PUSH
49260: LD_INT 1
49262: ARRAY
49263: PUSH
49264: LD_INT 1
49266: ARRAY
49267: PUSH
49268: LD_INT 0
49270: EQUAL
49271: PUSH
49272: LD_VAR 0 6
49276: PUSH
49277: LD_VAR 0 4
49281: ARRAY
49282: PPUSH
49283: LD_EXP 105
49287: PUSH
49288: LD_VAR 0 2
49292: ARRAY
49293: PUSH
49294: LD_INT 1
49296: ARRAY
49297: PUSH
49298: LD_INT 1
49300: ARRAY
49301: PPUSH
49302: LD_EXP 105
49306: PUSH
49307: LD_VAR 0 2
49311: ARRAY
49312: PUSH
49313: LD_INT 1
49315: ARRAY
49316: PUSH
49317: LD_INT 2
49319: ARRAY
49320: PPUSH
49321: LD_EXP 105
49325: PUSH
49326: LD_VAR 0 2
49330: ARRAY
49331: PUSH
49332: LD_INT 1
49334: ARRAY
49335: PUSH
49336: LD_INT 3
49338: ARRAY
49339: PPUSH
49340: LD_EXP 105
49344: PUSH
49345: LD_VAR 0 2
49349: ARRAY
49350: PUSH
49351: LD_INT 1
49353: ARRAY
49354: PUSH
49355: LD_INT 4
49357: ARRAY
49358: PPUSH
49359: CALL 81957 0 5
49363: OR
49364: IFFALSE 49645
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
49366: LD_ADDR_VAR 0 5
49370: PUSH
49371: LD_EXP 100
49375: PUSH
49376: LD_VAR 0 2
49380: ARRAY
49381: PPUSH
49382: LD_INT 25
49384: PUSH
49385: LD_INT 2
49387: PUSH
49388: EMPTY
49389: LIST
49390: LIST
49391: PPUSH
49392: CALL_OW 72
49396: PUSH
49397: LD_EXP 102
49401: PUSH
49402: LD_VAR 0 2
49406: ARRAY
49407: DIFF
49408: ST_TO_ADDR
// if not tmp then
49409: LD_VAR 0 5
49413: NOT
49414: IFFALSE 49418
// continue ;
49416: GO 49246
// for j in tmp do
49418: LD_ADDR_VAR 0 3
49422: PUSH
49423: LD_VAR 0 5
49427: PUSH
49428: FOR_IN
49429: IFFALSE 49641
// begin if not mc_builders [ i ] then
49431: LD_EXP 106
49435: PUSH
49436: LD_VAR 0 2
49440: ARRAY
49441: NOT
49442: IFFALSE 49500
// begin SetTag ( j , 103 ) ;
49444: LD_VAR 0 3
49448: PPUSH
49449: LD_INT 103
49451: PPUSH
49452: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
49456: LD_ADDR_EXP 106
49460: PUSH
49461: LD_EXP 106
49465: PPUSH
49466: LD_VAR 0 2
49470: PUSH
49471: LD_EXP 106
49475: PUSH
49476: LD_VAR 0 2
49480: ARRAY
49481: PUSH
49482: LD_INT 1
49484: PLUS
49485: PUSH
49486: EMPTY
49487: LIST
49488: LIST
49489: PPUSH
49490: LD_VAR 0 3
49494: PPUSH
49495: CALL 73860 0 3
49499: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
49500: LD_VAR 0 3
49504: PPUSH
49505: CALL_OW 310
49509: IFFALSE 49520
// ComExitBuilding ( j ) ;
49511: LD_VAR 0 3
49515: PPUSH
49516: CALL_OW 122
// wait ( 3 ) ;
49520: LD_INT 3
49522: PPUSH
49523: CALL_OW 67
// if not mc_build_list [ i ] then
49527: LD_EXP 105
49531: PUSH
49532: LD_VAR 0 2
49536: ARRAY
49537: NOT
49538: IFFALSE 49542
// break ;
49540: GO 49641
// if not HasTask ( j ) then
49542: LD_VAR 0 3
49546: PPUSH
49547: CALL_OW 314
49551: NOT
49552: IFFALSE 49639
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
49554: LD_VAR 0 3
49558: PPUSH
49559: LD_EXP 105
49563: PUSH
49564: LD_VAR 0 2
49568: ARRAY
49569: PUSH
49570: LD_INT 1
49572: ARRAY
49573: PUSH
49574: LD_INT 1
49576: ARRAY
49577: PPUSH
49578: LD_EXP 105
49582: PUSH
49583: LD_VAR 0 2
49587: ARRAY
49588: PUSH
49589: LD_INT 1
49591: ARRAY
49592: PUSH
49593: LD_INT 2
49595: ARRAY
49596: PPUSH
49597: LD_EXP 105
49601: PUSH
49602: LD_VAR 0 2
49606: ARRAY
49607: PUSH
49608: LD_INT 1
49610: ARRAY
49611: PUSH
49612: LD_INT 3
49614: ARRAY
49615: PPUSH
49616: LD_EXP 105
49620: PUSH
49621: LD_VAR 0 2
49625: ARRAY
49626: PUSH
49627: LD_INT 1
49629: ARRAY
49630: PUSH
49631: LD_INT 4
49633: ARRAY
49634: PPUSH
49635: CALL_OW 145
// end ;
49639: GO 49428
49641: POP
49642: POP
// end else
49643: GO 49815
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
49645: LD_EXP 100
49649: PUSH
49650: LD_VAR 0 2
49654: ARRAY
49655: PPUSH
49656: LD_EXP 105
49660: PUSH
49661: LD_VAR 0 2
49665: ARRAY
49666: PUSH
49667: LD_INT 1
49669: ARRAY
49670: PUSH
49671: LD_INT 1
49673: ARRAY
49674: PPUSH
49675: LD_EXP 105
49679: PUSH
49680: LD_VAR 0 2
49684: ARRAY
49685: PUSH
49686: LD_INT 1
49688: ARRAY
49689: PUSH
49690: LD_INT 2
49692: ARRAY
49693: PPUSH
49694: LD_EXP 105
49698: PUSH
49699: LD_VAR 0 2
49703: ARRAY
49704: PUSH
49705: LD_INT 1
49707: ARRAY
49708: PUSH
49709: LD_INT 3
49711: ARRAY
49712: PPUSH
49713: LD_EXP 105
49717: PUSH
49718: LD_VAR 0 2
49722: ARRAY
49723: PUSH
49724: LD_INT 1
49726: ARRAY
49727: PUSH
49728: LD_INT 4
49730: ARRAY
49731: PPUSH
49732: LD_EXP 100
49736: PUSH
49737: LD_VAR 0 2
49741: ARRAY
49742: PPUSH
49743: LD_INT 21
49745: PUSH
49746: LD_INT 3
49748: PUSH
49749: EMPTY
49750: LIST
49751: LIST
49752: PPUSH
49753: CALL_OW 72
49757: PPUSH
49758: EMPTY
49759: PPUSH
49760: CALL 80711 0 7
49764: NOT
49765: IFFALSE 49815
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
49767: LD_ADDR_EXP 105
49771: PUSH
49772: LD_EXP 105
49776: PPUSH
49777: LD_VAR 0 2
49781: PPUSH
49782: LD_EXP 105
49786: PUSH
49787: LD_VAR 0 2
49791: ARRAY
49792: PPUSH
49793: LD_INT 1
49795: PPUSH
49796: LD_INT 1
49798: NEG
49799: PPUSH
49800: LD_INT 0
49802: PPUSH
49803: CALL 73278 0 4
49807: PPUSH
49808: CALL_OW 1
49812: ST_TO_ADDR
// continue ;
49813: GO 49246
// end ; end ;
49815: GO 49246
49817: POP
49818: POP
// end ; end ;
49819: GO 48675
49821: POP
49822: POP
// end ;
49823: LD_VAR 0 1
49827: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
49828: LD_INT 0
49830: PPUSH
49831: PPUSH
49832: PPUSH
49833: PPUSH
49834: PPUSH
49835: PPUSH
// if not mc_bases then
49836: LD_EXP 100
49840: NOT
49841: IFFALSE 49845
// exit ;
49843: GO 50272
// for i = 1 to mc_bases do
49845: LD_ADDR_VAR 0 2
49849: PUSH
49850: DOUBLE
49851: LD_INT 1
49853: DEC
49854: ST_TO_ADDR
49855: LD_EXP 100
49859: PUSH
49860: FOR_TO
49861: IFFALSE 50270
// begin tmp := mc_build_upgrade [ i ] ;
49863: LD_ADDR_VAR 0 4
49867: PUSH
49868: LD_EXP 132
49872: PUSH
49873: LD_VAR 0 2
49877: ARRAY
49878: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
49879: LD_ADDR_VAR 0 6
49883: PUSH
49884: LD_EXP 133
49888: PUSH
49889: LD_VAR 0 2
49893: ARRAY
49894: PPUSH
49895: LD_INT 2
49897: PUSH
49898: LD_INT 30
49900: PUSH
49901: LD_INT 6
49903: PUSH
49904: EMPTY
49905: LIST
49906: LIST
49907: PUSH
49908: LD_INT 30
49910: PUSH
49911: LD_INT 7
49913: PUSH
49914: EMPTY
49915: LIST
49916: LIST
49917: PUSH
49918: EMPTY
49919: LIST
49920: LIST
49921: LIST
49922: PPUSH
49923: CALL_OW 72
49927: ST_TO_ADDR
// if not tmp and not lab then
49928: LD_VAR 0 4
49932: NOT
49933: PUSH
49934: LD_VAR 0 6
49938: NOT
49939: AND
49940: IFFALSE 49944
// continue ;
49942: GO 49860
// if tmp then
49944: LD_VAR 0 4
49948: IFFALSE 50068
// for j in tmp do
49950: LD_ADDR_VAR 0 3
49954: PUSH
49955: LD_VAR 0 4
49959: PUSH
49960: FOR_IN
49961: IFFALSE 50066
// begin if UpgradeCost ( j ) then
49963: LD_VAR 0 3
49967: PPUSH
49968: CALL 80371 0 1
49972: IFFALSE 50064
// begin ComUpgrade ( j ) ;
49974: LD_VAR 0 3
49978: PPUSH
49979: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
49983: LD_ADDR_EXP 132
49987: PUSH
49988: LD_EXP 132
49992: PPUSH
49993: LD_VAR 0 2
49997: PPUSH
49998: LD_EXP 132
50002: PUSH
50003: LD_VAR 0 2
50007: ARRAY
50008: PUSH
50009: LD_VAR 0 3
50013: DIFF
50014: PPUSH
50015: CALL_OW 1
50019: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50020: LD_ADDR_EXP 107
50024: PUSH
50025: LD_EXP 107
50029: PPUSH
50030: LD_VAR 0 2
50034: PUSH
50035: LD_EXP 107
50039: PUSH
50040: LD_VAR 0 2
50044: ARRAY
50045: PUSH
50046: LD_INT 1
50048: PLUS
50049: PUSH
50050: EMPTY
50051: LIST
50052: LIST
50053: PPUSH
50054: LD_VAR 0 3
50058: PPUSH
50059: CALL 73860 0 3
50063: ST_TO_ADDR
// end ; end ;
50064: GO 49960
50066: POP
50067: POP
// if not lab or not mc_lab_upgrade [ i ] then
50068: LD_VAR 0 6
50072: NOT
50073: PUSH
50074: LD_EXP 134
50078: PUSH
50079: LD_VAR 0 2
50083: ARRAY
50084: NOT
50085: OR
50086: IFFALSE 50090
// continue ;
50088: GO 49860
// for j in lab do
50090: LD_ADDR_VAR 0 3
50094: PUSH
50095: LD_VAR 0 6
50099: PUSH
50100: FOR_IN
50101: IFFALSE 50266
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
50103: LD_VAR 0 3
50107: PPUSH
50108: CALL_OW 266
50112: PUSH
50113: LD_INT 6
50115: PUSH
50116: LD_INT 7
50118: PUSH
50119: EMPTY
50120: LIST
50121: LIST
50122: IN
50123: PUSH
50124: LD_VAR 0 3
50128: PPUSH
50129: CALL_OW 461
50133: PUSH
50134: LD_INT 1
50136: NONEQUAL
50137: AND
50138: IFFALSE 50264
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
50140: LD_VAR 0 3
50144: PPUSH
50145: LD_EXP 134
50149: PUSH
50150: LD_VAR 0 2
50154: ARRAY
50155: PUSH
50156: LD_INT 1
50158: ARRAY
50159: PPUSH
50160: CALL 80576 0 2
50164: IFFALSE 50264
// begin ComCancel ( j ) ;
50166: LD_VAR 0 3
50170: PPUSH
50171: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
50175: LD_VAR 0 3
50179: PPUSH
50180: LD_EXP 134
50184: PUSH
50185: LD_VAR 0 2
50189: ARRAY
50190: PUSH
50191: LD_INT 1
50193: ARRAY
50194: PPUSH
50195: CALL_OW 207
// if not j in mc_construct_list [ i ] then
50199: LD_VAR 0 3
50203: PUSH
50204: LD_EXP 107
50208: PUSH
50209: LD_VAR 0 2
50213: ARRAY
50214: IN
50215: NOT
50216: IFFALSE 50262
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
50218: LD_ADDR_EXP 107
50222: PUSH
50223: LD_EXP 107
50227: PPUSH
50228: LD_VAR 0 2
50232: PUSH
50233: LD_EXP 107
50237: PUSH
50238: LD_VAR 0 2
50242: ARRAY
50243: PUSH
50244: LD_INT 1
50246: PLUS
50247: PUSH
50248: EMPTY
50249: LIST
50250: LIST
50251: PPUSH
50252: LD_VAR 0 3
50256: PPUSH
50257: CALL 73860 0 3
50261: ST_TO_ADDR
// break ;
50262: GO 50266
// end ; end ; end ;
50264: GO 50100
50266: POP
50267: POP
// end ;
50268: GO 49860
50270: POP
50271: POP
// end ;
50272: LD_VAR 0 1
50276: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
50277: LD_INT 0
50279: PPUSH
50280: PPUSH
50281: PPUSH
50282: PPUSH
50283: PPUSH
50284: PPUSH
50285: PPUSH
50286: PPUSH
50287: PPUSH
// if not mc_bases then
50288: LD_EXP 100
50292: NOT
50293: IFFALSE 50297
// exit ;
50295: GO 50702
// for i = 1 to mc_bases do
50297: LD_ADDR_VAR 0 2
50301: PUSH
50302: DOUBLE
50303: LD_INT 1
50305: DEC
50306: ST_TO_ADDR
50307: LD_EXP 100
50311: PUSH
50312: FOR_TO
50313: IFFALSE 50700
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
50315: LD_EXP 108
50319: PUSH
50320: LD_VAR 0 2
50324: ARRAY
50325: NOT
50326: PUSH
50327: LD_EXP 100
50331: PUSH
50332: LD_VAR 0 2
50336: ARRAY
50337: PPUSH
50338: LD_INT 30
50340: PUSH
50341: LD_INT 3
50343: PUSH
50344: EMPTY
50345: LIST
50346: LIST
50347: PPUSH
50348: CALL_OW 72
50352: NOT
50353: OR
50354: IFFALSE 50358
// continue ;
50356: GO 50312
// busy := false ;
50358: LD_ADDR_VAR 0 8
50362: PUSH
50363: LD_INT 0
50365: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50366: LD_ADDR_VAR 0 4
50370: PUSH
50371: LD_EXP 100
50375: PUSH
50376: LD_VAR 0 2
50380: ARRAY
50381: PPUSH
50382: LD_INT 30
50384: PUSH
50385: LD_INT 3
50387: PUSH
50388: EMPTY
50389: LIST
50390: LIST
50391: PPUSH
50392: CALL_OW 72
50396: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
50397: LD_ADDR_VAR 0 6
50401: PUSH
50402: LD_EXP 108
50406: PUSH
50407: LD_VAR 0 2
50411: ARRAY
50412: PPUSH
50413: LD_INT 2
50415: PUSH
50416: LD_INT 30
50418: PUSH
50419: LD_INT 32
50421: PUSH
50422: EMPTY
50423: LIST
50424: LIST
50425: PUSH
50426: LD_INT 30
50428: PUSH
50429: LD_INT 33
50431: PUSH
50432: EMPTY
50433: LIST
50434: LIST
50435: PUSH
50436: EMPTY
50437: LIST
50438: LIST
50439: LIST
50440: PPUSH
50441: CALL_OW 72
50445: ST_TO_ADDR
// if not t then
50446: LD_VAR 0 6
50450: NOT
50451: IFFALSE 50455
// continue ;
50453: GO 50312
// for j in tmp do
50455: LD_ADDR_VAR 0 3
50459: PUSH
50460: LD_VAR 0 4
50464: PUSH
50465: FOR_IN
50466: IFFALSE 50496
// if not BuildingStatus ( j ) = bs_idle then
50468: LD_VAR 0 3
50472: PPUSH
50473: CALL_OW 461
50477: PUSH
50478: LD_INT 2
50480: EQUAL
50481: NOT
50482: IFFALSE 50494
// begin busy := true ;
50484: LD_ADDR_VAR 0 8
50488: PUSH
50489: LD_INT 1
50491: ST_TO_ADDR
// break ;
50492: GO 50496
// end ;
50494: GO 50465
50496: POP
50497: POP
// if busy then
50498: LD_VAR 0 8
50502: IFFALSE 50506
// continue ;
50504: GO 50312
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
50506: LD_ADDR_VAR 0 7
50510: PUSH
50511: LD_VAR 0 6
50515: PPUSH
50516: LD_INT 35
50518: PUSH
50519: LD_INT 0
50521: PUSH
50522: EMPTY
50523: LIST
50524: LIST
50525: PPUSH
50526: CALL_OW 72
50530: ST_TO_ADDR
// if tw then
50531: LD_VAR 0 7
50535: IFFALSE 50612
// begin tw := tw [ 1 ] ;
50537: LD_ADDR_VAR 0 7
50541: PUSH
50542: LD_VAR 0 7
50546: PUSH
50547: LD_INT 1
50549: ARRAY
50550: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
50551: LD_ADDR_VAR 0 9
50555: PUSH
50556: LD_VAR 0 7
50560: PPUSH
50561: LD_EXP 125
50565: PUSH
50566: LD_VAR 0 2
50570: ARRAY
50571: PPUSH
50572: CALL 78868 0 2
50576: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
50577: LD_EXP 139
50581: PUSH
50582: LD_VAR 0 2
50586: ARRAY
50587: IFFALSE 50610
// if not weapon in mc_allowed_tower_weapons [ i ] then
50589: LD_VAR 0 9
50593: PUSH
50594: LD_EXP 139
50598: PUSH
50599: LD_VAR 0 2
50603: ARRAY
50604: IN
50605: NOT
50606: IFFALSE 50610
// continue ;
50608: GO 50312
// end else
50610: GO 50675
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
50612: LD_ADDR_VAR 0 5
50616: PUSH
50617: LD_EXP 108
50621: PUSH
50622: LD_VAR 0 2
50626: ARRAY
50627: PPUSH
50628: LD_VAR 0 4
50632: PPUSH
50633: CALL 105738 0 2
50637: ST_TO_ADDR
// if not tmp2 then
50638: LD_VAR 0 5
50642: NOT
50643: IFFALSE 50647
// continue ;
50645: GO 50312
// tw := tmp2 [ 1 ] ;
50647: LD_ADDR_VAR 0 7
50651: PUSH
50652: LD_VAR 0 5
50656: PUSH
50657: LD_INT 1
50659: ARRAY
50660: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
50661: LD_ADDR_VAR 0 9
50665: PUSH
50666: LD_VAR 0 5
50670: PUSH
50671: LD_INT 2
50673: ARRAY
50674: ST_TO_ADDR
// end ; if not weapon then
50675: LD_VAR 0 9
50679: NOT
50680: IFFALSE 50684
// continue ;
50682: GO 50312
// ComPlaceWeapon ( tw , weapon ) ;
50684: LD_VAR 0 7
50688: PPUSH
50689: LD_VAR 0 9
50693: PPUSH
50694: CALL_OW 148
// end ;
50698: GO 50312
50700: POP
50701: POP
// end ;
50702: LD_VAR 0 1
50706: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
50707: LD_INT 0
50709: PPUSH
50710: PPUSH
50711: PPUSH
50712: PPUSH
50713: PPUSH
50714: PPUSH
50715: PPUSH
// if not mc_bases then
50716: LD_EXP 100
50720: NOT
50721: IFFALSE 50725
// exit ;
50723: GO 51500
// for i = 1 to mc_bases do
50725: LD_ADDR_VAR 0 2
50729: PUSH
50730: DOUBLE
50731: LD_INT 1
50733: DEC
50734: ST_TO_ADDR
50735: LD_EXP 100
50739: PUSH
50740: FOR_TO
50741: IFFALSE 51498
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
50743: LD_EXP 113
50747: PUSH
50748: LD_VAR 0 2
50752: ARRAY
50753: NOT
50754: PUSH
50755: LD_EXP 113
50759: PUSH
50760: LD_VAR 0 2
50764: ARRAY
50765: PUSH
50766: LD_EXP 114
50770: PUSH
50771: LD_VAR 0 2
50775: ARRAY
50776: EQUAL
50777: OR
50778: PUSH
50779: LD_EXP 123
50783: PUSH
50784: LD_VAR 0 2
50788: ARRAY
50789: OR
50790: IFFALSE 50794
// continue ;
50792: GO 50740
// if mc_miners [ i ] then
50794: LD_EXP 114
50798: PUSH
50799: LD_VAR 0 2
50803: ARRAY
50804: IFFALSE 51185
// begin for j = mc_miners [ i ] downto 1 do
50806: LD_ADDR_VAR 0 3
50810: PUSH
50811: DOUBLE
50812: LD_EXP 114
50816: PUSH
50817: LD_VAR 0 2
50821: ARRAY
50822: INC
50823: ST_TO_ADDR
50824: LD_INT 1
50826: PUSH
50827: FOR_DOWNTO
50828: IFFALSE 51183
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
50830: LD_EXP 114
50834: PUSH
50835: LD_VAR 0 2
50839: ARRAY
50840: PUSH
50841: LD_VAR 0 3
50845: ARRAY
50846: PPUSH
50847: CALL_OW 301
50851: PUSH
50852: LD_EXP 114
50856: PUSH
50857: LD_VAR 0 2
50861: ARRAY
50862: PUSH
50863: LD_VAR 0 3
50867: ARRAY
50868: PPUSH
50869: CALL_OW 257
50873: PUSH
50874: LD_INT 1
50876: NONEQUAL
50877: OR
50878: IFFALSE 50941
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
50880: LD_ADDR_VAR 0 5
50884: PUSH
50885: LD_EXP 114
50889: PUSH
50890: LD_VAR 0 2
50894: ARRAY
50895: PUSH
50896: LD_EXP 114
50900: PUSH
50901: LD_VAR 0 2
50905: ARRAY
50906: PUSH
50907: LD_VAR 0 3
50911: ARRAY
50912: DIFF
50913: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
50914: LD_ADDR_EXP 114
50918: PUSH
50919: LD_EXP 114
50923: PPUSH
50924: LD_VAR 0 2
50928: PPUSH
50929: LD_VAR 0 5
50933: PPUSH
50934: CALL_OW 1
50938: ST_TO_ADDR
// continue ;
50939: GO 50827
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
50941: LD_EXP 114
50945: PUSH
50946: LD_VAR 0 2
50950: ARRAY
50951: PUSH
50952: LD_VAR 0 3
50956: ARRAY
50957: PPUSH
50958: CALL_OW 257
50962: PUSH
50963: LD_INT 1
50965: EQUAL
50966: PUSH
50967: LD_EXP 114
50971: PUSH
50972: LD_VAR 0 2
50976: ARRAY
50977: PUSH
50978: LD_VAR 0 3
50982: ARRAY
50983: PPUSH
50984: CALL_OW 459
50988: NOT
50989: AND
50990: PUSH
50991: LD_EXP 114
50995: PUSH
50996: LD_VAR 0 2
51000: ARRAY
51001: PUSH
51002: LD_VAR 0 3
51006: ARRAY
51007: PPUSH
51008: CALL_OW 314
51012: NOT
51013: AND
51014: IFFALSE 51181
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
51016: LD_EXP 114
51020: PUSH
51021: LD_VAR 0 2
51025: ARRAY
51026: PUSH
51027: LD_VAR 0 3
51031: ARRAY
51032: PPUSH
51033: CALL_OW 310
51037: IFFALSE 51060
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
51039: LD_EXP 114
51043: PUSH
51044: LD_VAR 0 2
51048: ARRAY
51049: PUSH
51050: LD_VAR 0 3
51054: ARRAY
51055: PPUSH
51056: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
51060: LD_EXP 114
51064: PUSH
51065: LD_VAR 0 2
51069: ARRAY
51070: PUSH
51071: LD_VAR 0 3
51075: ARRAY
51076: PPUSH
51077: CALL_OW 314
51081: NOT
51082: IFFALSE 51181
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
51084: LD_ADDR_VAR 0 7
51088: PUSH
51089: LD_VAR 0 3
51093: PUSH
51094: LD_EXP 113
51098: PUSH
51099: LD_VAR 0 2
51103: ARRAY
51104: PPUSH
51105: CALL 71000 0 1
51109: MOD
51110: PUSH
51111: LD_INT 1
51113: PLUS
51114: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
51115: LD_EXP 114
51119: PUSH
51120: LD_VAR 0 2
51124: ARRAY
51125: PUSH
51126: LD_VAR 0 3
51130: ARRAY
51131: PPUSH
51132: LD_EXP 113
51136: PUSH
51137: LD_VAR 0 2
51141: ARRAY
51142: PUSH
51143: LD_VAR 0 7
51147: ARRAY
51148: PUSH
51149: LD_INT 1
51151: ARRAY
51152: PPUSH
51153: LD_EXP 113
51157: PUSH
51158: LD_VAR 0 2
51162: ARRAY
51163: PUSH
51164: LD_VAR 0 7
51168: ARRAY
51169: PUSH
51170: LD_INT 2
51172: ARRAY
51173: PPUSH
51174: LD_INT 0
51176: PPUSH
51177: CALL_OW 193
// end ; end ; end ;
51181: GO 50827
51183: POP
51184: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
51185: LD_ADDR_VAR 0 5
51189: PUSH
51190: LD_EXP 100
51194: PUSH
51195: LD_VAR 0 2
51199: ARRAY
51200: PPUSH
51201: LD_INT 2
51203: PUSH
51204: LD_INT 30
51206: PUSH
51207: LD_INT 4
51209: PUSH
51210: EMPTY
51211: LIST
51212: LIST
51213: PUSH
51214: LD_INT 30
51216: PUSH
51217: LD_INT 5
51219: PUSH
51220: EMPTY
51221: LIST
51222: LIST
51223: PUSH
51224: LD_INT 30
51226: PUSH
51227: LD_INT 32
51229: PUSH
51230: EMPTY
51231: LIST
51232: LIST
51233: PUSH
51234: EMPTY
51235: LIST
51236: LIST
51237: LIST
51238: LIST
51239: PPUSH
51240: CALL_OW 72
51244: ST_TO_ADDR
// if not tmp then
51245: LD_VAR 0 5
51249: NOT
51250: IFFALSE 51254
// continue ;
51252: GO 50740
// list := [ ] ;
51254: LD_ADDR_VAR 0 6
51258: PUSH
51259: EMPTY
51260: ST_TO_ADDR
// for j in tmp do
51261: LD_ADDR_VAR 0 3
51265: PUSH
51266: LD_VAR 0 5
51270: PUSH
51271: FOR_IN
51272: IFFALSE 51341
// begin for k in UnitsInside ( j ) do
51274: LD_ADDR_VAR 0 4
51278: PUSH
51279: LD_VAR 0 3
51283: PPUSH
51284: CALL_OW 313
51288: PUSH
51289: FOR_IN
51290: IFFALSE 51337
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
51292: LD_VAR 0 4
51296: PPUSH
51297: CALL_OW 257
51301: PUSH
51302: LD_INT 1
51304: EQUAL
51305: PUSH
51306: LD_VAR 0 4
51310: PPUSH
51311: CALL_OW 459
51315: NOT
51316: AND
51317: IFFALSE 51335
// list := list ^ k ;
51319: LD_ADDR_VAR 0 6
51323: PUSH
51324: LD_VAR 0 6
51328: PUSH
51329: LD_VAR 0 4
51333: ADD
51334: ST_TO_ADDR
51335: GO 51289
51337: POP
51338: POP
// end ;
51339: GO 51271
51341: POP
51342: POP
// list := list diff mc_miners [ i ] ;
51343: LD_ADDR_VAR 0 6
51347: PUSH
51348: LD_VAR 0 6
51352: PUSH
51353: LD_EXP 114
51357: PUSH
51358: LD_VAR 0 2
51362: ARRAY
51363: DIFF
51364: ST_TO_ADDR
// if not list then
51365: LD_VAR 0 6
51369: NOT
51370: IFFALSE 51374
// continue ;
51372: GO 50740
// k := mc_mines [ i ] - mc_miners [ i ] ;
51374: LD_ADDR_VAR 0 4
51378: PUSH
51379: LD_EXP 113
51383: PUSH
51384: LD_VAR 0 2
51388: ARRAY
51389: PUSH
51390: LD_EXP 114
51394: PUSH
51395: LD_VAR 0 2
51399: ARRAY
51400: MINUS
51401: ST_TO_ADDR
// if k > list then
51402: LD_VAR 0 4
51406: PUSH
51407: LD_VAR 0 6
51411: GREATER
51412: IFFALSE 51424
// k := list ;
51414: LD_ADDR_VAR 0 4
51418: PUSH
51419: LD_VAR 0 6
51423: ST_TO_ADDR
// for j = 1 to k do
51424: LD_ADDR_VAR 0 3
51428: PUSH
51429: DOUBLE
51430: LD_INT 1
51432: DEC
51433: ST_TO_ADDR
51434: LD_VAR 0 4
51438: PUSH
51439: FOR_TO
51440: IFFALSE 51494
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
51442: LD_ADDR_EXP 114
51446: PUSH
51447: LD_EXP 114
51451: PPUSH
51452: LD_VAR 0 2
51456: PUSH
51457: LD_EXP 114
51461: PUSH
51462: LD_VAR 0 2
51466: ARRAY
51467: PUSH
51468: LD_INT 1
51470: PLUS
51471: PUSH
51472: EMPTY
51473: LIST
51474: LIST
51475: PPUSH
51476: LD_VAR 0 6
51480: PUSH
51481: LD_VAR 0 3
51485: ARRAY
51486: PPUSH
51487: CALL 73860 0 3
51491: ST_TO_ADDR
51492: GO 51439
51494: POP
51495: POP
// end ;
51496: GO 50740
51498: POP
51499: POP
// end ;
51500: LD_VAR 0 1
51504: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
51505: LD_INT 0
51507: PPUSH
51508: PPUSH
51509: PPUSH
51510: PPUSH
51511: PPUSH
51512: PPUSH
51513: PPUSH
51514: PPUSH
51515: PPUSH
51516: PPUSH
51517: PPUSH
// if not mc_bases then
51518: LD_EXP 100
51522: NOT
51523: IFFALSE 51527
// exit ;
51525: GO 53350
// for i = 1 to mc_bases do
51527: LD_ADDR_VAR 0 2
51531: PUSH
51532: DOUBLE
51533: LD_INT 1
51535: DEC
51536: ST_TO_ADDR
51537: LD_EXP 100
51541: PUSH
51542: FOR_TO
51543: IFFALSE 53348
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
51545: LD_EXP 100
51549: PUSH
51550: LD_VAR 0 2
51554: ARRAY
51555: NOT
51556: PUSH
51557: LD_EXP 107
51561: PUSH
51562: LD_VAR 0 2
51566: ARRAY
51567: OR
51568: IFFALSE 51572
// continue ;
51570: GO 51542
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
51572: LD_EXP 116
51576: PUSH
51577: LD_VAR 0 2
51581: ARRAY
51582: NOT
51583: PUSH
51584: LD_EXP 117
51588: PUSH
51589: LD_VAR 0 2
51593: ARRAY
51594: AND
51595: IFFALSE 51633
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
51597: LD_ADDR_EXP 117
51601: PUSH
51602: LD_EXP 117
51606: PPUSH
51607: LD_VAR 0 2
51611: PPUSH
51612: EMPTY
51613: PPUSH
51614: CALL_OW 1
51618: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
51619: LD_VAR 0 2
51623: PPUSH
51624: LD_INT 107
51626: PPUSH
51627: CALL 42373 0 2
// continue ;
51631: GO 51542
// end ; target := [ ] ;
51633: LD_ADDR_VAR 0 7
51637: PUSH
51638: EMPTY
51639: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51640: LD_ADDR_VAR 0 6
51644: PUSH
51645: LD_EXP 100
51649: PUSH
51650: LD_VAR 0 2
51654: ARRAY
51655: PUSH
51656: LD_INT 1
51658: ARRAY
51659: PPUSH
51660: CALL_OW 255
51664: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51665: LD_ADDR_VAR 0 9
51669: PUSH
51670: LD_EXP 100
51674: PUSH
51675: LD_VAR 0 2
51679: ARRAY
51680: PPUSH
51681: LD_INT 2
51683: PUSH
51684: LD_INT 30
51686: PUSH
51687: LD_INT 0
51689: PUSH
51690: EMPTY
51691: LIST
51692: LIST
51693: PUSH
51694: LD_INT 30
51696: PUSH
51697: LD_INT 1
51699: PUSH
51700: EMPTY
51701: LIST
51702: LIST
51703: PUSH
51704: EMPTY
51705: LIST
51706: LIST
51707: LIST
51708: PPUSH
51709: CALL_OW 72
51713: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
51714: LD_ADDR_VAR 0 3
51718: PUSH
51719: DOUBLE
51720: LD_EXP 116
51724: PUSH
51725: LD_VAR 0 2
51729: ARRAY
51730: INC
51731: ST_TO_ADDR
51732: LD_INT 1
51734: PUSH
51735: FOR_DOWNTO
51736: IFFALSE 51981
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
51738: LD_EXP 116
51742: PUSH
51743: LD_VAR 0 2
51747: ARRAY
51748: PUSH
51749: LD_VAR 0 3
51753: ARRAY
51754: PUSH
51755: LD_INT 2
51757: ARRAY
51758: PPUSH
51759: LD_EXP 116
51763: PUSH
51764: LD_VAR 0 2
51768: ARRAY
51769: PUSH
51770: LD_VAR 0 3
51774: ARRAY
51775: PUSH
51776: LD_INT 3
51778: ARRAY
51779: PPUSH
51780: CALL_OW 488
51784: PUSH
51785: LD_EXP 116
51789: PUSH
51790: LD_VAR 0 2
51794: ARRAY
51795: PUSH
51796: LD_VAR 0 3
51800: ARRAY
51801: PUSH
51802: LD_INT 2
51804: ARRAY
51805: PPUSH
51806: LD_EXP 116
51810: PUSH
51811: LD_VAR 0 2
51815: ARRAY
51816: PUSH
51817: LD_VAR 0 3
51821: ARRAY
51822: PUSH
51823: LD_INT 3
51825: ARRAY
51826: PPUSH
51827: CALL_OW 284
51831: PUSH
51832: LD_INT 0
51834: EQUAL
51835: AND
51836: IFFALSE 51891
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
51838: LD_ADDR_VAR 0 5
51842: PUSH
51843: LD_EXP 116
51847: PUSH
51848: LD_VAR 0 2
51852: ARRAY
51853: PPUSH
51854: LD_VAR 0 3
51858: PPUSH
51859: CALL_OW 3
51863: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
51864: LD_ADDR_EXP 116
51868: PUSH
51869: LD_EXP 116
51873: PPUSH
51874: LD_VAR 0 2
51878: PPUSH
51879: LD_VAR 0 5
51883: PPUSH
51884: CALL_OW 1
51888: ST_TO_ADDR
// continue ;
51889: GO 51735
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
51891: LD_VAR 0 6
51895: PPUSH
51896: LD_EXP 116
51900: PUSH
51901: LD_VAR 0 2
51905: ARRAY
51906: PUSH
51907: LD_VAR 0 3
51911: ARRAY
51912: PUSH
51913: LD_INT 2
51915: ARRAY
51916: PPUSH
51917: LD_EXP 116
51921: PUSH
51922: LD_VAR 0 2
51926: ARRAY
51927: PUSH
51928: LD_VAR 0 3
51932: ARRAY
51933: PUSH
51934: LD_INT 3
51936: ARRAY
51937: PPUSH
51938: LD_INT 30
51940: PPUSH
51941: CALL 74756 0 4
51945: PUSH
51946: LD_INT 4
51948: ARRAY
51949: PUSH
51950: LD_INT 0
51952: EQUAL
51953: IFFALSE 51979
// begin target := mc_crates [ i ] [ j ] ;
51955: LD_ADDR_VAR 0 7
51959: PUSH
51960: LD_EXP 116
51964: PUSH
51965: LD_VAR 0 2
51969: ARRAY
51970: PUSH
51971: LD_VAR 0 3
51975: ARRAY
51976: ST_TO_ADDR
// break ;
51977: GO 51981
// end ; end ;
51979: GO 51735
51981: POP
51982: POP
// if not target then
51983: LD_VAR 0 7
51987: NOT
51988: IFFALSE 51992
// continue ;
51990: GO 51542
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
51992: LD_ADDR_VAR 0 8
51996: PUSH
51997: LD_EXP 119
52001: PUSH
52002: LD_VAR 0 2
52006: ARRAY
52007: PPUSH
52008: LD_INT 2
52010: PUSH
52011: LD_INT 3
52013: PUSH
52014: LD_INT 58
52016: PUSH
52017: EMPTY
52018: LIST
52019: PUSH
52020: EMPTY
52021: LIST
52022: LIST
52023: PUSH
52024: LD_INT 61
52026: PUSH
52027: EMPTY
52028: LIST
52029: PUSH
52030: LD_INT 33
52032: PUSH
52033: LD_INT 5
52035: PUSH
52036: EMPTY
52037: LIST
52038: LIST
52039: PUSH
52040: LD_INT 33
52042: PUSH
52043: LD_INT 3
52045: PUSH
52046: EMPTY
52047: LIST
52048: LIST
52049: PUSH
52050: EMPTY
52051: LIST
52052: LIST
52053: LIST
52054: LIST
52055: LIST
52056: PUSH
52057: LD_INT 2
52059: PUSH
52060: LD_INT 34
52062: PUSH
52063: LD_INT 32
52065: PUSH
52066: EMPTY
52067: LIST
52068: LIST
52069: PUSH
52070: LD_INT 34
52072: PUSH
52073: LD_INT 51
52075: PUSH
52076: EMPTY
52077: LIST
52078: LIST
52079: PUSH
52080: LD_INT 34
52082: PUSH
52083: LD_INT 12
52085: PUSH
52086: EMPTY
52087: LIST
52088: LIST
52089: PUSH
52090: EMPTY
52091: LIST
52092: LIST
52093: LIST
52094: LIST
52095: PUSH
52096: EMPTY
52097: LIST
52098: LIST
52099: PPUSH
52100: CALL_OW 72
52104: ST_TO_ADDR
// if not cargo then
52105: LD_VAR 0 8
52109: NOT
52110: IFFALSE 52816
// begin if mc_crates_collector [ i ] < 5 then
52112: LD_EXP 117
52116: PUSH
52117: LD_VAR 0 2
52121: ARRAY
52122: PUSH
52123: LD_INT 5
52125: LESS
52126: IFFALSE 52492
// begin if mc_ape [ i ] then
52128: LD_EXP 129
52132: PUSH
52133: LD_VAR 0 2
52137: ARRAY
52138: IFFALSE 52185
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
52140: LD_ADDR_VAR 0 5
52144: PUSH
52145: LD_EXP 129
52149: PUSH
52150: LD_VAR 0 2
52154: ARRAY
52155: PPUSH
52156: LD_INT 25
52158: PUSH
52159: LD_INT 16
52161: PUSH
52162: EMPTY
52163: LIST
52164: LIST
52165: PUSH
52166: LD_INT 24
52168: PUSH
52169: LD_INT 750
52171: PUSH
52172: EMPTY
52173: LIST
52174: LIST
52175: PUSH
52176: EMPTY
52177: LIST
52178: LIST
52179: PPUSH
52180: CALL_OW 72
52184: ST_TO_ADDR
// if not tmp then
52185: LD_VAR 0 5
52189: NOT
52190: IFFALSE 52237
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
52192: LD_ADDR_VAR 0 5
52196: PUSH
52197: LD_EXP 100
52201: PUSH
52202: LD_VAR 0 2
52206: ARRAY
52207: PPUSH
52208: LD_INT 25
52210: PUSH
52211: LD_INT 2
52213: PUSH
52214: EMPTY
52215: LIST
52216: LIST
52217: PUSH
52218: LD_INT 24
52220: PUSH
52221: LD_INT 750
52223: PUSH
52224: EMPTY
52225: LIST
52226: LIST
52227: PUSH
52228: EMPTY
52229: LIST
52230: LIST
52231: PPUSH
52232: CALL_OW 72
52236: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
52237: LD_EXP 129
52241: PUSH
52242: LD_VAR 0 2
52246: ARRAY
52247: PUSH
52248: LD_EXP 100
52252: PUSH
52253: LD_VAR 0 2
52257: ARRAY
52258: PPUSH
52259: LD_INT 25
52261: PUSH
52262: LD_INT 2
52264: PUSH
52265: EMPTY
52266: LIST
52267: LIST
52268: PUSH
52269: LD_INT 24
52271: PUSH
52272: LD_INT 750
52274: PUSH
52275: EMPTY
52276: LIST
52277: LIST
52278: PUSH
52279: EMPTY
52280: LIST
52281: LIST
52282: PPUSH
52283: CALL_OW 72
52287: AND
52288: PUSH
52289: LD_VAR 0 5
52293: PUSH
52294: LD_INT 5
52296: LESS
52297: AND
52298: IFFALSE 52380
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
52300: LD_ADDR_VAR 0 3
52304: PUSH
52305: LD_EXP 100
52309: PUSH
52310: LD_VAR 0 2
52314: ARRAY
52315: PPUSH
52316: LD_INT 25
52318: PUSH
52319: LD_INT 2
52321: PUSH
52322: EMPTY
52323: LIST
52324: LIST
52325: PUSH
52326: LD_INT 24
52328: PUSH
52329: LD_INT 750
52331: PUSH
52332: EMPTY
52333: LIST
52334: LIST
52335: PUSH
52336: EMPTY
52337: LIST
52338: LIST
52339: PPUSH
52340: CALL_OW 72
52344: PUSH
52345: FOR_IN
52346: IFFALSE 52378
// begin tmp := tmp union j ;
52348: LD_ADDR_VAR 0 5
52352: PUSH
52353: LD_VAR 0 5
52357: PUSH
52358: LD_VAR 0 3
52362: UNION
52363: ST_TO_ADDR
// if tmp >= 5 then
52364: LD_VAR 0 5
52368: PUSH
52369: LD_INT 5
52371: GREATEREQUAL
52372: IFFALSE 52376
// break ;
52374: GO 52378
// end ;
52376: GO 52345
52378: POP
52379: POP
// end ; if not tmp then
52380: LD_VAR 0 5
52384: NOT
52385: IFFALSE 52389
// continue ;
52387: GO 51542
// for j in tmp do
52389: LD_ADDR_VAR 0 3
52393: PUSH
52394: LD_VAR 0 5
52398: PUSH
52399: FOR_IN
52400: IFFALSE 52490
// if not GetTag ( j ) then
52402: LD_VAR 0 3
52406: PPUSH
52407: CALL_OW 110
52411: NOT
52412: IFFALSE 52488
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
52414: LD_ADDR_EXP 117
52418: PUSH
52419: LD_EXP 117
52423: PPUSH
52424: LD_VAR 0 2
52428: PUSH
52429: LD_EXP 117
52433: PUSH
52434: LD_VAR 0 2
52438: ARRAY
52439: PUSH
52440: LD_INT 1
52442: PLUS
52443: PUSH
52444: EMPTY
52445: LIST
52446: LIST
52447: PPUSH
52448: LD_VAR 0 3
52452: PPUSH
52453: CALL 73860 0 3
52457: ST_TO_ADDR
// SetTag ( j , 107 ) ;
52458: LD_VAR 0 3
52462: PPUSH
52463: LD_INT 107
52465: PPUSH
52466: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
52470: LD_EXP 117
52474: PUSH
52475: LD_VAR 0 2
52479: ARRAY
52480: PUSH
52481: LD_INT 5
52483: GREATEREQUAL
52484: IFFALSE 52488
// break ;
52486: GO 52490
// end ;
52488: GO 52399
52490: POP
52491: POP
// end ; if mc_crates_collector [ i ] and target then
52492: LD_EXP 117
52496: PUSH
52497: LD_VAR 0 2
52501: ARRAY
52502: PUSH
52503: LD_VAR 0 7
52507: AND
52508: IFFALSE 52814
// begin if mc_crates_collector [ i ] < target [ 1 ] then
52510: LD_EXP 117
52514: PUSH
52515: LD_VAR 0 2
52519: ARRAY
52520: PUSH
52521: LD_VAR 0 7
52525: PUSH
52526: LD_INT 1
52528: ARRAY
52529: LESS
52530: IFFALSE 52550
// tmp := mc_crates_collector [ i ] else
52532: LD_ADDR_VAR 0 5
52536: PUSH
52537: LD_EXP 117
52541: PUSH
52542: LD_VAR 0 2
52546: ARRAY
52547: ST_TO_ADDR
52548: GO 52564
// tmp := target [ 1 ] ;
52550: LD_ADDR_VAR 0 5
52554: PUSH
52555: LD_VAR 0 7
52559: PUSH
52560: LD_INT 1
52562: ARRAY
52563: ST_TO_ADDR
// k := 0 ;
52564: LD_ADDR_VAR 0 4
52568: PUSH
52569: LD_INT 0
52571: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
52572: LD_ADDR_VAR 0 3
52576: PUSH
52577: LD_EXP 117
52581: PUSH
52582: LD_VAR 0 2
52586: ARRAY
52587: PUSH
52588: FOR_IN
52589: IFFALSE 52812
// begin k := k + 1 ;
52591: LD_ADDR_VAR 0 4
52595: PUSH
52596: LD_VAR 0 4
52600: PUSH
52601: LD_INT 1
52603: PLUS
52604: ST_TO_ADDR
// if k > tmp then
52605: LD_VAR 0 4
52609: PUSH
52610: LD_VAR 0 5
52614: GREATER
52615: IFFALSE 52619
// break ;
52617: GO 52812
// if not GetClass ( j ) in [ 2 , 16 ] then
52619: LD_VAR 0 3
52623: PPUSH
52624: CALL_OW 257
52628: PUSH
52629: LD_INT 2
52631: PUSH
52632: LD_INT 16
52634: PUSH
52635: EMPTY
52636: LIST
52637: LIST
52638: IN
52639: NOT
52640: IFFALSE 52693
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
52642: LD_ADDR_EXP 117
52646: PUSH
52647: LD_EXP 117
52651: PPUSH
52652: LD_VAR 0 2
52656: PPUSH
52657: LD_EXP 117
52661: PUSH
52662: LD_VAR 0 2
52666: ARRAY
52667: PUSH
52668: LD_VAR 0 3
52672: DIFF
52673: PPUSH
52674: CALL_OW 1
52678: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52679: LD_VAR 0 3
52683: PPUSH
52684: LD_INT 0
52686: PPUSH
52687: CALL_OW 109
// continue ;
52691: GO 52588
// end ; if IsInUnit ( j ) then
52693: LD_VAR 0 3
52697: PPUSH
52698: CALL_OW 310
52702: IFFALSE 52713
// ComExitBuilding ( j ) ;
52704: LD_VAR 0 3
52708: PPUSH
52709: CALL_OW 122
// wait ( 3 ) ;
52713: LD_INT 3
52715: PPUSH
52716: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
52720: LD_VAR 0 3
52724: PPUSH
52725: CALL_OW 314
52729: PUSH
52730: LD_VAR 0 6
52734: PPUSH
52735: LD_VAR 0 7
52739: PUSH
52740: LD_INT 2
52742: ARRAY
52743: PPUSH
52744: LD_VAR 0 7
52748: PUSH
52749: LD_INT 3
52751: ARRAY
52752: PPUSH
52753: LD_INT 30
52755: PPUSH
52756: CALL 74756 0 4
52760: PUSH
52761: LD_INT 4
52763: ARRAY
52764: AND
52765: IFFALSE 52783
// ComStandNearbyBuilding ( j , depot ) else
52767: LD_VAR 0 3
52771: PPUSH
52772: LD_VAR 0 9
52776: PPUSH
52777: CALL 70462 0 2
52781: GO 52810
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
52783: LD_VAR 0 3
52787: PPUSH
52788: LD_VAR 0 7
52792: PUSH
52793: LD_INT 2
52795: ARRAY
52796: PPUSH
52797: LD_VAR 0 7
52801: PUSH
52802: LD_INT 3
52804: ARRAY
52805: PPUSH
52806: CALL_OW 117
// end ;
52810: GO 52588
52812: POP
52813: POP
// end ; end else
52814: GO 53346
// begin for j in cargo do
52816: LD_ADDR_VAR 0 3
52820: PUSH
52821: LD_VAR 0 8
52825: PUSH
52826: FOR_IN
52827: IFFALSE 53344
// begin if GetTag ( j ) <> 0 then
52829: LD_VAR 0 3
52833: PPUSH
52834: CALL_OW 110
52838: PUSH
52839: LD_INT 0
52841: NONEQUAL
52842: IFFALSE 52846
// continue ;
52844: GO 52826
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
52846: LD_VAR 0 3
52850: PPUSH
52851: CALL_OW 256
52855: PUSH
52856: LD_INT 1000
52858: LESS
52859: PUSH
52860: LD_VAR 0 3
52864: PPUSH
52865: LD_EXP 124
52869: PUSH
52870: LD_VAR 0 2
52874: ARRAY
52875: PPUSH
52876: CALL_OW 308
52880: NOT
52881: AND
52882: IFFALSE 52904
// ComMoveToArea ( j , mc_parking [ i ] ) ;
52884: LD_VAR 0 3
52888: PPUSH
52889: LD_EXP 124
52893: PUSH
52894: LD_VAR 0 2
52898: ARRAY
52899: PPUSH
52900: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
52904: LD_VAR 0 3
52908: PPUSH
52909: CALL_OW 256
52913: PUSH
52914: LD_INT 1000
52916: LESS
52917: PUSH
52918: LD_VAR 0 3
52922: PPUSH
52923: LD_EXP 124
52927: PUSH
52928: LD_VAR 0 2
52932: ARRAY
52933: PPUSH
52934: CALL_OW 308
52938: AND
52939: IFFALSE 52943
// continue ;
52941: GO 52826
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
52943: LD_VAR 0 3
52947: PPUSH
52948: CALL_OW 262
52952: PUSH
52953: LD_INT 2
52955: EQUAL
52956: PUSH
52957: LD_VAR 0 3
52961: PPUSH
52962: CALL_OW 261
52966: PUSH
52967: LD_INT 15
52969: LESS
52970: AND
52971: IFFALSE 52975
// continue ;
52973: GO 52826
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
52975: LD_VAR 0 3
52979: PPUSH
52980: CALL_OW 262
52984: PUSH
52985: LD_INT 1
52987: EQUAL
52988: PUSH
52989: LD_VAR 0 3
52993: PPUSH
52994: CALL_OW 261
52998: PUSH
52999: LD_INT 10
53001: LESS
53002: AND
53003: IFFALSE 53283
// begin if not depot then
53005: LD_VAR 0 9
53009: NOT
53010: IFFALSE 53014
// continue ;
53012: GO 52826
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
53014: LD_VAR 0 3
53018: PPUSH
53019: LD_VAR 0 9
53023: PPUSH
53024: LD_VAR 0 3
53028: PPUSH
53029: CALL_OW 74
53033: PPUSH
53034: CALL_OW 296
53038: PUSH
53039: LD_INT 6
53041: LESS
53042: IFFALSE 53058
// SetFuel ( j , 100 ) else
53044: LD_VAR 0 3
53048: PPUSH
53049: LD_INT 100
53051: PPUSH
53052: CALL_OW 240
53056: GO 53283
// if GetFuel ( j ) = 0 then
53058: LD_VAR 0 3
53062: PPUSH
53063: CALL_OW 261
53067: PUSH
53068: LD_INT 0
53070: EQUAL
53071: IFFALSE 53283
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
53073: LD_ADDR_EXP 119
53077: PUSH
53078: LD_EXP 119
53082: PPUSH
53083: LD_VAR 0 2
53087: PPUSH
53088: LD_EXP 119
53092: PUSH
53093: LD_VAR 0 2
53097: ARRAY
53098: PUSH
53099: LD_VAR 0 3
53103: DIFF
53104: PPUSH
53105: CALL_OW 1
53109: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
53110: LD_VAR 0 3
53114: PPUSH
53115: CALL_OW 263
53119: PUSH
53120: LD_INT 1
53122: EQUAL
53123: IFFALSE 53139
// ComExitVehicle ( IsInUnit ( j ) ) ;
53125: LD_VAR 0 3
53129: PPUSH
53130: CALL_OW 310
53134: PPUSH
53135: CALL_OW 121
// if GetControl ( j ) = control_remote then
53139: LD_VAR 0 3
53143: PPUSH
53144: CALL_OW 263
53148: PUSH
53149: LD_INT 2
53151: EQUAL
53152: IFFALSE 53163
// ComUnlink ( j ) ;
53154: LD_VAR 0 3
53158: PPUSH
53159: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
53163: LD_ADDR_VAR 0 10
53167: PUSH
53168: LD_VAR 0 2
53172: PPUSH
53173: LD_INT 3
53175: PPUSH
53176: CALL 62927 0 2
53180: ST_TO_ADDR
// if fac then
53181: LD_VAR 0 10
53185: IFFALSE 53281
// begin for k in fac do
53187: LD_ADDR_VAR 0 4
53191: PUSH
53192: LD_VAR 0 10
53196: PUSH
53197: FOR_IN
53198: IFFALSE 53279
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
53200: LD_ADDR_VAR 0 11
53204: PUSH
53205: LD_VAR 0 10
53209: PPUSH
53210: LD_VAR 0 3
53214: PPUSH
53215: CALL_OW 265
53219: PPUSH
53220: LD_VAR 0 3
53224: PPUSH
53225: CALL_OW 262
53229: PPUSH
53230: LD_VAR 0 3
53234: PPUSH
53235: CALL_OW 263
53239: PPUSH
53240: LD_VAR 0 3
53244: PPUSH
53245: CALL_OW 264
53249: PPUSH
53250: CALL 71358 0 5
53254: ST_TO_ADDR
// if components then
53255: LD_VAR 0 11
53259: IFFALSE 53277
// begin MC_InsertProduceList ( i , components ) ;
53261: LD_VAR 0 2
53265: PPUSH
53266: LD_VAR 0 11
53270: PPUSH
53271: CALL 62472 0 2
// break ;
53275: GO 53279
// end ; end ;
53277: GO 53197
53279: POP
53280: POP
// end ; continue ;
53281: GO 52826
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
53283: LD_VAR 0 3
53287: PPUSH
53288: LD_INT 1
53290: PPUSH
53291: CALL_OW 289
53295: PUSH
53296: LD_INT 100
53298: LESS
53299: PUSH
53300: LD_VAR 0 3
53304: PPUSH
53305: CALL_OW 314
53309: NOT
53310: AND
53311: IFFALSE 53340
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
53313: LD_VAR 0 3
53317: PPUSH
53318: LD_VAR 0 7
53322: PUSH
53323: LD_INT 2
53325: ARRAY
53326: PPUSH
53327: LD_VAR 0 7
53331: PUSH
53332: LD_INT 3
53334: ARRAY
53335: PPUSH
53336: CALL_OW 117
// break ;
53340: GO 53344
// end ;
53342: GO 52826
53344: POP
53345: POP
// end ; end ;
53346: GO 51542
53348: POP
53349: POP
// end ;
53350: LD_VAR 0 1
53354: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
53355: LD_INT 0
53357: PPUSH
53358: PPUSH
53359: PPUSH
53360: PPUSH
// if not mc_bases then
53361: LD_EXP 100
53365: NOT
53366: IFFALSE 53370
// exit ;
53368: GO 53531
// for i = 1 to mc_bases do
53370: LD_ADDR_VAR 0 2
53374: PUSH
53375: DOUBLE
53376: LD_INT 1
53378: DEC
53379: ST_TO_ADDR
53380: LD_EXP 100
53384: PUSH
53385: FOR_TO
53386: IFFALSE 53529
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
53388: LD_ADDR_VAR 0 4
53392: PUSH
53393: LD_EXP 119
53397: PUSH
53398: LD_VAR 0 2
53402: ARRAY
53403: PUSH
53404: LD_EXP 122
53408: PUSH
53409: LD_VAR 0 2
53413: ARRAY
53414: UNION
53415: PPUSH
53416: LD_INT 33
53418: PUSH
53419: LD_INT 2
53421: PUSH
53422: EMPTY
53423: LIST
53424: LIST
53425: PPUSH
53426: CALL_OW 72
53430: ST_TO_ADDR
// if tmp then
53431: LD_VAR 0 4
53435: IFFALSE 53527
// for j in tmp do
53437: LD_ADDR_VAR 0 3
53441: PUSH
53442: LD_VAR 0 4
53446: PUSH
53447: FOR_IN
53448: IFFALSE 53525
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
53450: LD_VAR 0 3
53454: PPUSH
53455: CALL_OW 312
53459: NOT
53460: PUSH
53461: LD_VAR 0 3
53465: PPUSH
53466: CALL_OW 256
53470: PUSH
53471: LD_INT 250
53473: GREATEREQUAL
53474: AND
53475: IFFALSE 53488
// Connect ( j ) else
53477: LD_VAR 0 3
53481: PPUSH
53482: CALL 76829 0 1
53486: GO 53523
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
53488: LD_VAR 0 3
53492: PPUSH
53493: CALL_OW 256
53497: PUSH
53498: LD_INT 250
53500: LESS
53501: PUSH
53502: LD_VAR 0 3
53506: PPUSH
53507: CALL_OW 312
53511: AND
53512: IFFALSE 53523
// ComUnlink ( j ) ;
53514: LD_VAR 0 3
53518: PPUSH
53519: CALL_OW 136
53523: GO 53447
53525: POP
53526: POP
// end ;
53527: GO 53385
53529: POP
53530: POP
// end ;
53531: LD_VAR 0 1
53535: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
53536: LD_INT 0
53538: PPUSH
53539: PPUSH
53540: PPUSH
53541: PPUSH
53542: PPUSH
// if not mc_bases then
53543: LD_EXP 100
53547: NOT
53548: IFFALSE 53552
// exit ;
53550: GO 53997
// for i = 1 to mc_bases do
53552: LD_ADDR_VAR 0 2
53556: PUSH
53557: DOUBLE
53558: LD_INT 1
53560: DEC
53561: ST_TO_ADDR
53562: LD_EXP 100
53566: PUSH
53567: FOR_TO
53568: IFFALSE 53995
// begin if not mc_produce [ i ] then
53570: LD_EXP 121
53574: PUSH
53575: LD_VAR 0 2
53579: ARRAY
53580: NOT
53581: IFFALSE 53585
// continue ;
53583: GO 53567
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53585: LD_ADDR_VAR 0 5
53589: PUSH
53590: LD_EXP 100
53594: PUSH
53595: LD_VAR 0 2
53599: ARRAY
53600: PPUSH
53601: LD_INT 30
53603: PUSH
53604: LD_INT 3
53606: PUSH
53607: EMPTY
53608: LIST
53609: LIST
53610: PPUSH
53611: CALL_OW 72
53615: ST_TO_ADDR
// if not fac then
53616: LD_VAR 0 5
53620: NOT
53621: IFFALSE 53625
// continue ;
53623: GO 53567
// for j in fac do
53625: LD_ADDR_VAR 0 3
53629: PUSH
53630: LD_VAR 0 5
53634: PUSH
53635: FOR_IN
53636: IFFALSE 53991
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
53638: LD_VAR 0 3
53642: PPUSH
53643: CALL_OW 461
53647: PUSH
53648: LD_INT 2
53650: NONEQUAL
53651: PUSH
53652: LD_VAR 0 3
53656: PPUSH
53657: LD_INT 15
53659: PPUSH
53660: CALL 76457 0 2
53664: PUSH
53665: LD_INT 4
53667: ARRAY
53668: OR
53669: IFFALSE 53673
// continue ;
53671: GO 53635
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
53673: LD_VAR 0 3
53677: PPUSH
53678: LD_EXP 121
53682: PUSH
53683: LD_VAR 0 2
53687: ARRAY
53688: PUSH
53689: LD_INT 1
53691: ARRAY
53692: PUSH
53693: LD_INT 1
53695: ARRAY
53696: PPUSH
53697: LD_EXP 121
53701: PUSH
53702: LD_VAR 0 2
53706: ARRAY
53707: PUSH
53708: LD_INT 1
53710: ARRAY
53711: PUSH
53712: LD_INT 2
53714: ARRAY
53715: PPUSH
53716: LD_EXP 121
53720: PUSH
53721: LD_VAR 0 2
53725: ARRAY
53726: PUSH
53727: LD_INT 1
53729: ARRAY
53730: PUSH
53731: LD_INT 3
53733: ARRAY
53734: PPUSH
53735: LD_EXP 121
53739: PUSH
53740: LD_VAR 0 2
53744: ARRAY
53745: PUSH
53746: LD_INT 1
53748: ARRAY
53749: PUSH
53750: LD_INT 4
53752: ARRAY
53753: PPUSH
53754: CALL_OW 448
53758: PUSH
53759: LD_VAR 0 3
53763: PPUSH
53764: LD_EXP 121
53768: PUSH
53769: LD_VAR 0 2
53773: ARRAY
53774: PUSH
53775: LD_INT 1
53777: ARRAY
53778: PUSH
53779: LD_INT 1
53781: ARRAY
53782: PUSH
53783: LD_EXP 121
53787: PUSH
53788: LD_VAR 0 2
53792: ARRAY
53793: PUSH
53794: LD_INT 1
53796: ARRAY
53797: PUSH
53798: LD_INT 2
53800: ARRAY
53801: PUSH
53802: LD_EXP 121
53806: PUSH
53807: LD_VAR 0 2
53811: ARRAY
53812: PUSH
53813: LD_INT 1
53815: ARRAY
53816: PUSH
53817: LD_INT 3
53819: ARRAY
53820: PUSH
53821: LD_EXP 121
53825: PUSH
53826: LD_VAR 0 2
53830: ARRAY
53831: PUSH
53832: LD_INT 1
53834: ARRAY
53835: PUSH
53836: LD_INT 4
53838: ARRAY
53839: PUSH
53840: EMPTY
53841: LIST
53842: LIST
53843: LIST
53844: LIST
53845: PPUSH
53846: CALL 80224 0 2
53850: AND
53851: IFFALSE 53989
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
53853: LD_VAR 0 3
53857: PPUSH
53858: LD_EXP 121
53862: PUSH
53863: LD_VAR 0 2
53867: ARRAY
53868: PUSH
53869: LD_INT 1
53871: ARRAY
53872: PUSH
53873: LD_INT 1
53875: ARRAY
53876: PPUSH
53877: LD_EXP 121
53881: PUSH
53882: LD_VAR 0 2
53886: ARRAY
53887: PUSH
53888: LD_INT 1
53890: ARRAY
53891: PUSH
53892: LD_INT 2
53894: ARRAY
53895: PPUSH
53896: LD_EXP 121
53900: PUSH
53901: LD_VAR 0 2
53905: ARRAY
53906: PUSH
53907: LD_INT 1
53909: ARRAY
53910: PUSH
53911: LD_INT 3
53913: ARRAY
53914: PPUSH
53915: LD_EXP 121
53919: PUSH
53920: LD_VAR 0 2
53924: ARRAY
53925: PUSH
53926: LD_INT 1
53928: ARRAY
53929: PUSH
53930: LD_INT 4
53932: ARRAY
53933: PPUSH
53934: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
53938: LD_ADDR_VAR 0 4
53942: PUSH
53943: LD_EXP 121
53947: PUSH
53948: LD_VAR 0 2
53952: ARRAY
53953: PPUSH
53954: LD_INT 1
53956: PPUSH
53957: CALL_OW 3
53961: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
53962: LD_ADDR_EXP 121
53966: PUSH
53967: LD_EXP 121
53971: PPUSH
53972: LD_VAR 0 2
53976: PPUSH
53977: LD_VAR 0 4
53981: PPUSH
53982: CALL_OW 1
53986: ST_TO_ADDR
// break ;
53987: GO 53991
// end ; end ;
53989: GO 53635
53991: POP
53992: POP
// end ;
53993: GO 53567
53995: POP
53996: POP
// end ;
53997: LD_VAR 0 1
54001: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
54002: LD_INT 0
54004: PPUSH
54005: PPUSH
54006: PPUSH
// if not mc_bases then
54007: LD_EXP 100
54011: NOT
54012: IFFALSE 54016
// exit ;
54014: GO 54105
// for i = 1 to mc_bases do
54016: LD_ADDR_VAR 0 2
54020: PUSH
54021: DOUBLE
54022: LD_INT 1
54024: DEC
54025: ST_TO_ADDR
54026: LD_EXP 100
54030: PUSH
54031: FOR_TO
54032: IFFALSE 54103
// begin if mc_attack [ i ] then
54034: LD_EXP 120
54038: PUSH
54039: LD_VAR 0 2
54043: ARRAY
54044: IFFALSE 54101
// begin tmp := mc_attack [ i ] [ 1 ] ;
54046: LD_ADDR_VAR 0 3
54050: PUSH
54051: LD_EXP 120
54055: PUSH
54056: LD_VAR 0 2
54060: ARRAY
54061: PUSH
54062: LD_INT 1
54064: ARRAY
54065: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54066: LD_ADDR_EXP 120
54070: PUSH
54071: LD_EXP 120
54075: PPUSH
54076: LD_VAR 0 2
54080: PPUSH
54081: EMPTY
54082: PPUSH
54083: CALL_OW 1
54087: ST_TO_ADDR
// Attack ( tmp ) ;
54088: LD_VAR 0 3
54092: PPUSH
54093: CALL 130353 0 1
// exit ;
54097: POP
54098: POP
54099: GO 54105
// end ; end ;
54101: GO 54031
54103: POP
54104: POP
// end ;
54105: LD_VAR 0 1
54109: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
54110: LD_INT 0
54112: PPUSH
54113: PPUSH
54114: PPUSH
54115: PPUSH
54116: PPUSH
54117: PPUSH
54118: PPUSH
// if not mc_bases then
54119: LD_EXP 100
54123: NOT
54124: IFFALSE 54128
// exit ;
54126: GO 54985
// for i = 1 to mc_bases do
54128: LD_ADDR_VAR 0 2
54132: PUSH
54133: DOUBLE
54134: LD_INT 1
54136: DEC
54137: ST_TO_ADDR
54138: LD_EXP 100
54142: PUSH
54143: FOR_TO
54144: IFFALSE 54983
// begin if not mc_bases [ i ] then
54146: LD_EXP 100
54150: PUSH
54151: LD_VAR 0 2
54155: ARRAY
54156: NOT
54157: IFFALSE 54161
// continue ;
54159: GO 54143
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
54161: LD_ADDR_VAR 0 7
54165: PUSH
54166: LD_EXP 100
54170: PUSH
54171: LD_VAR 0 2
54175: ARRAY
54176: PUSH
54177: LD_INT 1
54179: ARRAY
54180: PPUSH
54181: CALL 70684 0 1
54185: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
54186: LD_ADDR_EXP 123
54190: PUSH
54191: LD_EXP 123
54195: PPUSH
54196: LD_VAR 0 2
54200: PPUSH
54201: LD_EXP 100
54205: PUSH
54206: LD_VAR 0 2
54210: ARRAY
54211: PUSH
54212: LD_INT 1
54214: ARRAY
54215: PPUSH
54216: CALL_OW 255
54220: PPUSH
54221: LD_EXP 125
54225: PUSH
54226: LD_VAR 0 2
54230: ARRAY
54231: PPUSH
54232: CALL 70649 0 2
54236: PPUSH
54237: CALL_OW 1
54241: ST_TO_ADDR
// if not mc_scan [ i ] then
54242: LD_EXP 123
54246: PUSH
54247: LD_VAR 0 2
54251: ARRAY
54252: NOT
54253: IFFALSE 54431
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
54255: LD_ADDR_EXP 143
54259: PUSH
54260: LD_EXP 143
54264: PPUSH
54265: LD_VAR 0 2
54269: PPUSH
54270: LD_INT 0
54272: PPUSH
54273: CALL_OW 1
54277: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54278: LD_ADDR_VAR 0 4
54282: PUSH
54283: LD_EXP 100
54287: PUSH
54288: LD_VAR 0 2
54292: ARRAY
54293: PPUSH
54294: LD_INT 2
54296: PUSH
54297: LD_INT 25
54299: PUSH
54300: LD_INT 5
54302: PUSH
54303: EMPTY
54304: LIST
54305: LIST
54306: PUSH
54307: LD_INT 25
54309: PUSH
54310: LD_INT 8
54312: PUSH
54313: EMPTY
54314: LIST
54315: LIST
54316: PUSH
54317: LD_INT 25
54319: PUSH
54320: LD_INT 9
54322: PUSH
54323: EMPTY
54324: LIST
54325: LIST
54326: PUSH
54327: EMPTY
54328: LIST
54329: LIST
54330: LIST
54331: LIST
54332: PPUSH
54333: CALL_OW 72
54337: ST_TO_ADDR
// if not tmp then
54338: LD_VAR 0 4
54342: NOT
54343: IFFALSE 54347
// continue ;
54345: GO 54143
// for j in tmp do
54347: LD_ADDR_VAR 0 3
54351: PUSH
54352: LD_VAR 0 4
54356: PUSH
54357: FOR_IN
54358: IFFALSE 54429
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
54360: LD_VAR 0 3
54364: PPUSH
54365: CALL_OW 310
54369: PPUSH
54370: CALL_OW 266
54374: PUSH
54375: LD_INT 5
54377: EQUAL
54378: PUSH
54379: LD_VAR 0 3
54383: PPUSH
54384: CALL_OW 257
54388: PUSH
54389: LD_INT 1
54391: EQUAL
54392: AND
54393: PUSH
54394: LD_VAR 0 3
54398: PPUSH
54399: CALL_OW 459
54403: NOT
54404: AND
54405: PUSH
54406: LD_VAR 0 7
54410: AND
54411: IFFALSE 54427
// ComChangeProfession ( j , class ) ;
54413: LD_VAR 0 3
54417: PPUSH
54418: LD_VAR 0 7
54422: PPUSH
54423: CALL_OW 123
54427: GO 54357
54429: POP
54430: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
54431: LD_EXP 123
54435: PUSH
54436: LD_VAR 0 2
54440: ARRAY
54441: PUSH
54442: LD_EXP 143
54446: PUSH
54447: LD_VAR 0 2
54451: ARRAY
54452: NOT
54453: AND
54454: PUSH
54455: LD_EXP 122
54459: PUSH
54460: LD_VAR 0 2
54464: ARRAY
54465: NOT
54466: AND
54467: PUSH
54468: LD_EXP 100
54472: PUSH
54473: LD_VAR 0 2
54477: ARRAY
54478: PPUSH
54479: LD_INT 50
54481: PUSH
54482: EMPTY
54483: LIST
54484: PUSH
54485: LD_INT 2
54487: PUSH
54488: LD_INT 30
54490: PUSH
54491: LD_INT 32
54493: PUSH
54494: EMPTY
54495: LIST
54496: LIST
54497: PUSH
54498: LD_INT 30
54500: PUSH
54501: LD_INT 33
54503: PUSH
54504: EMPTY
54505: LIST
54506: LIST
54507: PUSH
54508: LD_INT 30
54510: PUSH
54511: LD_INT 4
54513: PUSH
54514: EMPTY
54515: LIST
54516: LIST
54517: PUSH
54518: LD_INT 30
54520: PUSH
54521: LD_INT 5
54523: PUSH
54524: EMPTY
54525: LIST
54526: LIST
54527: PUSH
54528: EMPTY
54529: LIST
54530: LIST
54531: LIST
54532: LIST
54533: LIST
54534: PUSH
54535: EMPTY
54536: LIST
54537: LIST
54538: PPUSH
54539: CALL_OW 72
54543: PUSH
54544: LD_INT 4
54546: LESS
54547: PUSH
54548: LD_EXP 100
54552: PUSH
54553: LD_VAR 0 2
54557: ARRAY
54558: PPUSH
54559: LD_INT 3
54561: PUSH
54562: LD_INT 24
54564: PUSH
54565: LD_INT 1000
54567: PUSH
54568: EMPTY
54569: LIST
54570: LIST
54571: PUSH
54572: EMPTY
54573: LIST
54574: LIST
54575: PUSH
54576: LD_INT 2
54578: PUSH
54579: LD_INT 30
54581: PUSH
54582: LD_INT 0
54584: PUSH
54585: EMPTY
54586: LIST
54587: LIST
54588: PUSH
54589: LD_INT 30
54591: PUSH
54592: LD_INT 1
54594: PUSH
54595: EMPTY
54596: LIST
54597: LIST
54598: PUSH
54599: EMPTY
54600: LIST
54601: LIST
54602: LIST
54603: PUSH
54604: EMPTY
54605: LIST
54606: LIST
54607: PPUSH
54608: CALL_OW 72
54612: OR
54613: AND
54614: IFFALSE 54865
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
54616: LD_ADDR_EXP 143
54620: PUSH
54621: LD_EXP 143
54625: PPUSH
54626: LD_VAR 0 2
54630: PPUSH
54631: LD_INT 1
54633: PPUSH
54634: CALL_OW 1
54638: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
54639: LD_ADDR_VAR 0 4
54643: PUSH
54644: LD_EXP 100
54648: PUSH
54649: LD_VAR 0 2
54653: ARRAY
54654: PPUSH
54655: LD_INT 2
54657: PUSH
54658: LD_INT 25
54660: PUSH
54661: LD_INT 1
54663: PUSH
54664: EMPTY
54665: LIST
54666: LIST
54667: PUSH
54668: LD_INT 25
54670: PUSH
54671: LD_INT 5
54673: PUSH
54674: EMPTY
54675: LIST
54676: LIST
54677: PUSH
54678: LD_INT 25
54680: PUSH
54681: LD_INT 8
54683: PUSH
54684: EMPTY
54685: LIST
54686: LIST
54687: PUSH
54688: LD_INT 25
54690: PUSH
54691: LD_INT 9
54693: PUSH
54694: EMPTY
54695: LIST
54696: LIST
54697: PUSH
54698: EMPTY
54699: LIST
54700: LIST
54701: LIST
54702: LIST
54703: LIST
54704: PPUSH
54705: CALL_OW 72
54709: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
54710: LD_ADDR_VAR 0 4
54714: PUSH
54715: LD_VAR 0 4
54719: PUSH
54720: LD_VAR 0 4
54724: PPUSH
54725: LD_INT 18
54727: PPUSH
54728: CALL 103772 0 2
54732: DIFF
54733: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
54734: LD_VAR 0 4
54738: NOT
54739: PUSH
54740: LD_EXP 100
54744: PUSH
54745: LD_VAR 0 2
54749: ARRAY
54750: PPUSH
54751: LD_INT 2
54753: PUSH
54754: LD_INT 30
54756: PUSH
54757: LD_INT 4
54759: PUSH
54760: EMPTY
54761: LIST
54762: LIST
54763: PUSH
54764: LD_INT 30
54766: PUSH
54767: LD_INT 5
54769: PUSH
54770: EMPTY
54771: LIST
54772: LIST
54773: PUSH
54774: EMPTY
54775: LIST
54776: LIST
54777: LIST
54778: PPUSH
54779: CALL_OW 72
54783: NOT
54784: AND
54785: IFFALSE 54847
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
54787: LD_ADDR_VAR 0 4
54791: PUSH
54792: LD_EXP 100
54796: PUSH
54797: LD_VAR 0 2
54801: ARRAY
54802: PPUSH
54803: LD_INT 2
54805: PUSH
54806: LD_INT 25
54808: PUSH
54809: LD_INT 2
54811: PUSH
54812: EMPTY
54813: LIST
54814: LIST
54815: PUSH
54816: LD_INT 25
54818: PUSH
54819: LD_INT 3
54821: PUSH
54822: EMPTY
54823: LIST
54824: LIST
54825: PUSH
54826: LD_INT 25
54828: PUSH
54829: LD_INT 4
54831: PUSH
54832: EMPTY
54833: LIST
54834: LIST
54835: PUSH
54836: EMPTY
54837: LIST
54838: LIST
54839: LIST
54840: LIST
54841: PPUSH
54842: CALL_OW 72
54846: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
54847: LD_VAR 0 2
54851: PPUSH
54852: LD_VAR 0 4
54856: PPUSH
54857: CALL 135062 0 2
// exit ;
54861: POP
54862: POP
54863: GO 54985
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
54865: LD_EXP 123
54869: PUSH
54870: LD_VAR 0 2
54874: ARRAY
54875: PUSH
54876: LD_EXP 143
54880: PUSH
54881: LD_VAR 0 2
54885: ARRAY
54886: NOT
54887: AND
54888: PUSH
54889: LD_EXP 122
54893: PUSH
54894: LD_VAR 0 2
54898: ARRAY
54899: AND
54900: IFFALSE 54981
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
54902: LD_ADDR_EXP 143
54906: PUSH
54907: LD_EXP 143
54911: PPUSH
54912: LD_VAR 0 2
54916: PPUSH
54917: LD_INT 1
54919: PPUSH
54920: CALL_OW 1
54924: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
54925: LD_ADDR_VAR 0 4
54929: PUSH
54930: LD_EXP 122
54934: PUSH
54935: LD_VAR 0 2
54939: ARRAY
54940: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54941: LD_ADDR_EXP 122
54945: PUSH
54946: LD_EXP 122
54950: PPUSH
54951: LD_VAR 0 2
54955: PPUSH
54956: EMPTY
54957: PPUSH
54958: CALL_OW 1
54962: ST_TO_ADDR
// Defend ( i , tmp ) ;
54963: LD_VAR 0 2
54967: PPUSH
54968: LD_VAR 0 4
54972: PPUSH
54973: CALL 135658 0 2
// exit ;
54977: POP
54978: POP
54979: GO 54985
// end ; end ;
54981: GO 54143
54983: POP
54984: POP
// end ;
54985: LD_VAR 0 1
54989: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
54990: LD_INT 0
54992: PPUSH
54993: PPUSH
54994: PPUSH
54995: PPUSH
54996: PPUSH
54997: PPUSH
54998: PPUSH
54999: PPUSH
55000: PPUSH
55001: PPUSH
55002: PPUSH
// if not mc_bases then
55003: LD_EXP 100
55007: NOT
55008: IFFALSE 55012
// exit ;
55010: GO 56099
// for i = 1 to mc_bases do
55012: LD_ADDR_VAR 0 2
55016: PUSH
55017: DOUBLE
55018: LD_INT 1
55020: DEC
55021: ST_TO_ADDR
55022: LD_EXP 100
55026: PUSH
55027: FOR_TO
55028: IFFALSE 56097
// begin tmp := mc_lab [ i ] ;
55030: LD_ADDR_VAR 0 6
55034: PUSH
55035: LD_EXP 133
55039: PUSH
55040: LD_VAR 0 2
55044: ARRAY
55045: ST_TO_ADDR
// if not tmp then
55046: LD_VAR 0 6
55050: NOT
55051: IFFALSE 55055
// continue ;
55053: GO 55027
// idle_lab := 0 ;
55055: LD_ADDR_VAR 0 11
55059: PUSH
55060: LD_INT 0
55062: ST_TO_ADDR
// for j in tmp do
55063: LD_ADDR_VAR 0 3
55067: PUSH
55068: LD_VAR 0 6
55072: PUSH
55073: FOR_IN
55074: IFFALSE 56093
// begin researching := false ;
55076: LD_ADDR_VAR 0 10
55080: PUSH
55081: LD_INT 0
55083: ST_TO_ADDR
// side := GetSide ( j ) ;
55084: LD_ADDR_VAR 0 4
55088: PUSH
55089: LD_VAR 0 3
55093: PPUSH
55094: CALL_OW 255
55098: ST_TO_ADDR
// if not mc_tech [ side ] then
55099: LD_EXP 127
55103: PUSH
55104: LD_VAR 0 4
55108: ARRAY
55109: NOT
55110: IFFALSE 55114
// continue ;
55112: GO 55073
// if BuildingStatus ( j ) = bs_idle then
55114: LD_VAR 0 3
55118: PPUSH
55119: CALL_OW 461
55123: PUSH
55124: LD_INT 2
55126: EQUAL
55127: IFFALSE 55315
// begin if idle_lab and UnitsInside ( j ) < 6 then
55129: LD_VAR 0 11
55133: PUSH
55134: LD_VAR 0 3
55138: PPUSH
55139: CALL_OW 313
55143: PUSH
55144: LD_INT 6
55146: LESS
55147: AND
55148: IFFALSE 55219
// begin tmp2 := UnitsInside ( idle_lab ) ;
55150: LD_ADDR_VAR 0 9
55154: PUSH
55155: LD_VAR 0 11
55159: PPUSH
55160: CALL_OW 313
55164: ST_TO_ADDR
// if tmp2 then
55165: LD_VAR 0 9
55169: IFFALSE 55211
// for x in tmp2 do
55171: LD_ADDR_VAR 0 7
55175: PUSH
55176: LD_VAR 0 9
55180: PUSH
55181: FOR_IN
55182: IFFALSE 55209
// begin ComExitBuilding ( x ) ;
55184: LD_VAR 0 7
55188: PPUSH
55189: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
55193: LD_VAR 0 7
55197: PPUSH
55198: LD_VAR 0 3
55202: PPUSH
55203: CALL_OW 180
// end ;
55207: GO 55181
55209: POP
55210: POP
// idle_lab := 0 ;
55211: LD_ADDR_VAR 0 11
55215: PUSH
55216: LD_INT 0
55218: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
55219: LD_ADDR_VAR 0 5
55223: PUSH
55224: LD_EXP 127
55228: PUSH
55229: LD_VAR 0 4
55233: ARRAY
55234: PUSH
55235: FOR_IN
55236: IFFALSE 55296
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
55238: LD_VAR 0 3
55242: PPUSH
55243: LD_VAR 0 5
55247: PPUSH
55248: CALL_OW 430
55252: PUSH
55253: LD_VAR 0 4
55257: PPUSH
55258: LD_VAR 0 5
55262: PPUSH
55263: CALL 69754 0 2
55267: AND
55268: IFFALSE 55294
// begin researching := true ;
55270: LD_ADDR_VAR 0 10
55274: PUSH
55275: LD_INT 1
55277: ST_TO_ADDR
// ComResearch ( j , t ) ;
55278: LD_VAR 0 3
55282: PPUSH
55283: LD_VAR 0 5
55287: PPUSH
55288: CALL_OW 124
// break ;
55292: GO 55296
// end ;
55294: GO 55235
55296: POP
55297: POP
// if not researching then
55298: LD_VAR 0 10
55302: NOT
55303: IFFALSE 55315
// idle_lab := j ;
55305: LD_ADDR_VAR 0 11
55309: PUSH
55310: LD_VAR 0 3
55314: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
55315: LD_VAR 0 3
55319: PPUSH
55320: CALL_OW 461
55324: PUSH
55325: LD_INT 10
55327: EQUAL
55328: IFFALSE 55916
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
55330: LD_EXP 129
55334: PUSH
55335: LD_VAR 0 2
55339: ARRAY
55340: NOT
55341: PUSH
55342: LD_EXP 130
55346: PUSH
55347: LD_VAR 0 2
55351: ARRAY
55352: NOT
55353: AND
55354: PUSH
55355: LD_EXP 127
55359: PUSH
55360: LD_VAR 0 4
55364: ARRAY
55365: PUSH
55366: LD_INT 1
55368: GREATER
55369: AND
55370: IFFALSE 55501
// begin ComCancel ( j ) ;
55372: LD_VAR 0 3
55376: PPUSH
55377: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
55381: LD_ADDR_EXP 127
55385: PUSH
55386: LD_EXP 127
55390: PPUSH
55391: LD_VAR 0 4
55395: PPUSH
55396: LD_EXP 127
55400: PUSH
55401: LD_VAR 0 4
55405: ARRAY
55406: PPUSH
55407: LD_EXP 127
55411: PUSH
55412: LD_VAR 0 4
55416: ARRAY
55417: PUSH
55418: LD_INT 1
55420: MINUS
55421: PPUSH
55422: LD_EXP 127
55426: PUSH
55427: LD_VAR 0 4
55431: ARRAY
55432: PPUSH
55433: LD_INT 0
55435: PPUSH
55436: CALL 73278 0 4
55440: PPUSH
55441: CALL_OW 1
55445: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
55446: LD_ADDR_EXP 127
55450: PUSH
55451: LD_EXP 127
55455: PPUSH
55456: LD_VAR 0 4
55460: PPUSH
55461: LD_EXP 127
55465: PUSH
55466: LD_VAR 0 4
55470: ARRAY
55471: PPUSH
55472: LD_EXP 127
55476: PUSH
55477: LD_VAR 0 4
55481: ARRAY
55482: PPUSH
55483: LD_INT 1
55485: PPUSH
55486: LD_INT 0
55488: PPUSH
55489: CALL 73278 0 4
55493: PPUSH
55494: CALL_OW 1
55498: ST_TO_ADDR
// continue ;
55499: GO 55073
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
55501: LD_EXP 129
55505: PUSH
55506: LD_VAR 0 2
55510: ARRAY
55511: PUSH
55512: LD_EXP 130
55516: PUSH
55517: LD_VAR 0 2
55521: ARRAY
55522: NOT
55523: AND
55524: IFFALSE 55651
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
55526: LD_ADDR_EXP 130
55530: PUSH
55531: LD_EXP 130
55535: PPUSH
55536: LD_VAR 0 2
55540: PUSH
55541: LD_EXP 130
55545: PUSH
55546: LD_VAR 0 2
55550: ARRAY
55551: PUSH
55552: LD_INT 1
55554: PLUS
55555: PUSH
55556: EMPTY
55557: LIST
55558: LIST
55559: PPUSH
55560: LD_EXP 129
55564: PUSH
55565: LD_VAR 0 2
55569: ARRAY
55570: PUSH
55571: LD_INT 1
55573: ARRAY
55574: PPUSH
55575: CALL 73860 0 3
55579: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
55580: LD_EXP 129
55584: PUSH
55585: LD_VAR 0 2
55589: ARRAY
55590: PUSH
55591: LD_INT 1
55593: ARRAY
55594: PPUSH
55595: LD_INT 112
55597: PPUSH
55598: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
55602: LD_ADDR_VAR 0 9
55606: PUSH
55607: LD_EXP 129
55611: PUSH
55612: LD_VAR 0 2
55616: ARRAY
55617: PPUSH
55618: LD_INT 1
55620: PPUSH
55621: CALL_OW 3
55625: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
55626: LD_ADDR_EXP 129
55630: PUSH
55631: LD_EXP 129
55635: PPUSH
55636: LD_VAR 0 2
55640: PPUSH
55641: LD_VAR 0 9
55645: PPUSH
55646: CALL_OW 1
55650: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
55651: LD_EXP 129
55655: PUSH
55656: LD_VAR 0 2
55660: ARRAY
55661: PUSH
55662: LD_EXP 130
55666: PUSH
55667: LD_VAR 0 2
55671: ARRAY
55672: AND
55673: PUSH
55674: LD_EXP 130
55678: PUSH
55679: LD_VAR 0 2
55683: ARRAY
55684: PUSH
55685: LD_INT 1
55687: ARRAY
55688: PPUSH
55689: CALL_OW 310
55693: NOT
55694: AND
55695: PUSH
55696: LD_VAR 0 3
55700: PPUSH
55701: CALL_OW 313
55705: PUSH
55706: LD_INT 6
55708: EQUAL
55709: AND
55710: IFFALSE 55766
// begin tmp2 := UnitsInside ( j ) ;
55712: LD_ADDR_VAR 0 9
55716: PUSH
55717: LD_VAR 0 3
55721: PPUSH
55722: CALL_OW 313
55726: ST_TO_ADDR
// if tmp2 = 6 then
55727: LD_VAR 0 9
55731: PUSH
55732: LD_INT 6
55734: EQUAL
55735: IFFALSE 55766
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
55737: LD_VAR 0 9
55741: PUSH
55742: LD_INT 1
55744: ARRAY
55745: PPUSH
55746: LD_INT 112
55748: PPUSH
55749: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
55753: LD_VAR 0 9
55757: PUSH
55758: LD_INT 1
55760: ARRAY
55761: PPUSH
55762: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
55766: LD_EXP 130
55770: PUSH
55771: LD_VAR 0 2
55775: ARRAY
55776: PUSH
55777: LD_EXP 130
55781: PUSH
55782: LD_VAR 0 2
55786: ARRAY
55787: PUSH
55788: LD_INT 1
55790: ARRAY
55791: PPUSH
55792: CALL_OW 314
55796: NOT
55797: AND
55798: PUSH
55799: LD_EXP 130
55803: PUSH
55804: LD_VAR 0 2
55808: ARRAY
55809: PUSH
55810: LD_INT 1
55812: ARRAY
55813: PPUSH
55814: CALL_OW 310
55818: NOT
55819: AND
55820: IFFALSE 55846
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
55822: LD_EXP 130
55826: PUSH
55827: LD_VAR 0 2
55831: ARRAY
55832: PUSH
55833: LD_INT 1
55835: ARRAY
55836: PPUSH
55837: LD_VAR 0 3
55841: PPUSH
55842: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
55846: LD_EXP 130
55850: PUSH
55851: LD_VAR 0 2
55855: ARRAY
55856: PUSH
55857: LD_INT 1
55859: ARRAY
55860: PPUSH
55861: CALL_OW 310
55865: PUSH
55866: LD_EXP 130
55870: PUSH
55871: LD_VAR 0 2
55875: ARRAY
55876: PUSH
55877: LD_INT 1
55879: ARRAY
55880: PPUSH
55881: CALL_OW 310
55885: PPUSH
55886: CALL_OW 461
55890: PUSH
55891: LD_INT 3
55893: NONEQUAL
55894: AND
55895: IFFALSE 55916
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
55897: LD_EXP 130
55901: PUSH
55902: LD_VAR 0 2
55906: ARRAY
55907: PUSH
55908: LD_INT 1
55910: ARRAY
55911: PPUSH
55912: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
55916: LD_VAR 0 3
55920: PPUSH
55921: CALL_OW 461
55925: PUSH
55926: LD_INT 6
55928: EQUAL
55929: PUSH
55930: LD_VAR 0 6
55934: PUSH
55935: LD_INT 1
55937: GREATER
55938: AND
55939: IFFALSE 56091
// begin sci := [ ] ;
55941: LD_ADDR_VAR 0 8
55945: PUSH
55946: EMPTY
55947: ST_TO_ADDR
// for x in ( tmp diff j ) do
55948: LD_ADDR_VAR 0 7
55952: PUSH
55953: LD_VAR 0 6
55957: PUSH
55958: LD_VAR 0 3
55962: DIFF
55963: PUSH
55964: FOR_IN
55965: IFFALSE 56017
// begin if sci = 6 then
55967: LD_VAR 0 8
55971: PUSH
55972: LD_INT 6
55974: EQUAL
55975: IFFALSE 55979
// break ;
55977: GO 56017
// if BuildingStatus ( x ) = bs_idle then
55979: LD_VAR 0 7
55983: PPUSH
55984: CALL_OW 461
55988: PUSH
55989: LD_INT 2
55991: EQUAL
55992: IFFALSE 56015
// sci := sci ^ UnitsInside ( x ) ;
55994: LD_ADDR_VAR 0 8
55998: PUSH
55999: LD_VAR 0 8
56003: PUSH
56004: LD_VAR 0 7
56008: PPUSH
56009: CALL_OW 313
56013: ADD
56014: ST_TO_ADDR
// end ;
56015: GO 55964
56017: POP
56018: POP
// if not sci then
56019: LD_VAR 0 8
56023: NOT
56024: IFFALSE 56028
// continue ;
56026: GO 55073
// for x in sci do
56028: LD_ADDR_VAR 0 7
56032: PUSH
56033: LD_VAR 0 8
56037: PUSH
56038: FOR_IN
56039: IFFALSE 56089
// if IsInUnit ( x ) and not HasTask ( x ) then
56041: LD_VAR 0 7
56045: PPUSH
56046: CALL_OW 310
56050: PUSH
56051: LD_VAR 0 7
56055: PPUSH
56056: CALL_OW 314
56060: NOT
56061: AND
56062: IFFALSE 56087
// begin ComExitBuilding ( x ) ;
56064: LD_VAR 0 7
56068: PPUSH
56069: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
56073: LD_VAR 0 7
56077: PPUSH
56078: LD_VAR 0 3
56082: PPUSH
56083: CALL_OW 180
// end ;
56087: GO 56038
56089: POP
56090: POP
// end ; end ;
56091: GO 55073
56093: POP
56094: POP
// end ;
56095: GO 55027
56097: POP
56098: POP
// end ;
56099: LD_VAR 0 1
56103: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
56104: LD_INT 0
56106: PPUSH
56107: PPUSH
// if not mc_bases then
56108: LD_EXP 100
56112: NOT
56113: IFFALSE 56117
// exit ;
56115: GO 56198
// for i = 1 to mc_bases do
56117: LD_ADDR_VAR 0 2
56121: PUSH
56122: DOUBLE
56123: LD_INT 1
56125: DEC
56126: ST_TO_ADDR
56127: LD_EXP 100
56131: PUSH
56132: FOR_TO
56133: IFFALSE 56196
// if mc_mines [ i ] and mc_miners [ i ] then
56135: LD_EXP 113
56139: PUSH
56140: LD_VAR 0 2
56144: ARRAY
56145: PUSH
56146: LD_EXP 114
56150: PUSH
56151: LD_VAR 0 2
56155: ARRAY
56156: AND
56157: IFFALSE 56194
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
56159: LD_EXP 114
56163: PUSH
56164: LD_VAR 0 2
56168: ARRAY
56169: PUSH
56170: LD_INT 1
56172: ARRAY
56173: PPUSH
56174: CALL_OW 255
56178: PPUSH
56179: LD_EXP 113
56183: PUSH
56184: LD_VAR 0 2
56188: ARRAY
56189: PPUSH
56190: CALL 70837 0 2
56194: GO 56132
56196: POP
56197: POP
// end ;
56198: LD_VAR 0 1
56202: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
56203: LD_INT 0
56205: PPUSH
56206: PPUSH
56207: PPUSH
56208: PPUSH
56209: PPUSH
56210: PPUSH
56211: PPUSH
56212: PPUSH
// if not mc_bases or not mc_parking then
56213: LD_EXP 100
56217: NOT
56218: PUSH
56219: LD_EXP 124
56223: NOT
56224: OR
56225: IFFALSE 56229
// exit ;
56227: GO 56967
// for i = 1 to mc_bases do
56229: LD_ADDR_VAR 0 2
56233: PUSH
56234: DOUBLE
56235: LD_INT 1
56237: DEC
56238: ST_TO_ADDR
56239: LD_EXP 100
56243: PUSH
56244: FOR_TO
56245: IFFALSE 56965
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
56247: LD_EXP 100
56251: PUSH
56252: LD_VAR 0 2
56256: ARRAY
56257: NOT
56258: PUSH
56259: LD_EXP 124
56263: PUSH
56264: LD_VAR 0 2
56268: ARRAY
56269: NOT
56270: OR
56271: IFFALSE 56275
// continue ;
56273: GO 56244
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
56275: LD_ADDR_VAR 0 5
56279: PUSH
56280: LD_EXP 100
56284: PUSH
56285: LD_VAR 0 2
56289: ARRAY
56290: PUSH
56291: LD_INT 1
56293: ARRAY
56294: PPUSH
56295: CALL_OW 255
56299: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56300: LD_ADDR_VAR 0 6
56304: PUSH
56305: LD_EXP 100
56309: PUSH
56310: LD_VAR 0 2
56314: ARRAY
56315: PPUSH
56316: LD_INT 30
56318: PUSH
56319: LD_INT 3
56321: PUSH
56322: EMPTY
56323: LIST
56324: LIST
56325: PPUSH
56326: CALL_OW 72
56330: ST_TO_ADDR
// if not fac then
56331: LD_VAR 0 6
56335: NOT
56336: IFFALSE 56387
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56338: LD_ADDR_VAR 0 6
56342: PUSH
56343: LD_EXP 100
56347: PUSH
56348: LD_VAR 0 2
56352: ARRAY
56353: PPUSH
56354: LD_INT 2
56356: PUSH
56357: LD_INT 30
56359: PUSH
56360: LD_INT 0
56362: PUSH
56363: EMPTY
56364: LIST
56365: LIST
56366: PUSH
56367: LD_INT 30
56369: PUSH
56370: LD_INT 1
56372: PUSH
56373: EMPTY
56374: LIST
56375: LIST
56376: PUSH
56377: EMPTY
56378: LIST
56379: LIST
56380: LIST
56381: PPUSH
56382: CALL_OW 72
56386: ST_TO_ADDR
// if not fac then
56387: LD_VAR 0 6
56391: NOT
56392: IFFALSE 56396
// continue ;
56394: GO 56244
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
56396: LD_ADDR_VAR 0 7
56400: PUSH
56401: LD_EXP 124
56405: PUSH
56406: LD_VAR 0 2
56410: ARRAY
56411: PPUSH
56412: LD_INT 22
56414: PUSH
56415: LD_VAR 0 5
56419: PUSH
56420: EMPTY
56421: LIST
56422: LIST
56423: PUSH
56424: LD_INT 21
56426: PUSH
56427: LD_INT 2
56429: PUSH
56430: EMPTY
56431: LIST
56432: LIST
56433: PUSH
56434: LD_INT 3
56436: PUSH
56437: LD_INT 60
56439: PUSH
56440: EMPTY
56441: LIST
56442: PUSH
56443: EMPTY
56444: LIST
56445: LIST
56446: PUSH
56447: LD_INT 3
56449: PUSH
56450: LD_INT 24
56452: PUSH
56453: LD_INT 1000
56455: PUSH
56456: EMPTY
56457: LIST
56458: LIST
56459: PUSH
56460: EMPTY
56461: LIST
56462: LIST
56463: PUSH
56464: EMPTY
56465: LIST
56466: LIST
56467: LIST
56468: LIST
56469: PPUSH
56470: CALL_OW 70
56474: ST_TO_ADDR
// for j in fac do
56475: LD_ADDR_VAR 0 3
56479: PUSH
56480: LD_VAR 0 6
56484: PUSH
56485: FOR_IN
56486: IFFALSE 56581
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
56488: LD_ADDR_VAR 0 7
56492: PUSH
56493: LD_VAR 0 7
56497: PUSH
56498: LD_INT 22
56500: PUSH
56501: LD_VAR 0 5
56505: PUSH
56506: EMPTY
56507: LIST
56508: LIST
56509: PUSH
56510: LD_INT 91
56512: PUSH
56513: LD_VAR 0 3
56517: PUSH
56518: LD_INT 15
56520: PUSH
56521: EMPTY
56522: LIST
56523: LIST
56524: LIST
56525: PUSH
56526: LD_INT 21
56528: PUSH
56529: LD_INT 2
56531: PUSH
56532: EMPTY
56533: LIST
56534: LIST
56535: PUSH
56536: LD_INT 3
56538: PUSH
56539: LD_INT 60
56541: PUSH
56542: EMPTY
56543: LIST
56544: PUSH
56545: EMPTY
56546: LIST
56547: LIST
56548: PUSH
56549: LD_INT 3
56551: PUSH
56552: LD_INT 24
56554: PUSH
56555: LD_INT 1000
56557: PUSH
56558: EMPTY
56559: LIST
56560: LIST
56561: PUSH
56562: EMPTY
56563: LIST
56564: LIST
56565: PUSH
56566: EMPTY
56567: LIST
56568: LIST
56569: LIST
56570: LIST
56571: LIST
56572: PPUSH
56573: CALL_OW 69
56577: UNION
56578: ST_TO_ADDR
56579: GO 56485
56581: POP
56582: POP
// if not vehs then
56583: LD_VAR 0 7
56587: NOT
56588: IFFALSE 56614
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
56590: LD_ADDR_EXP 112
56594: PUSH
56595: LD_EXP 112
56599: PPUSH
56600: LD_VAR 0 2
56604: PPUSH
56605: EMPTY
56606: PPUSH
56607: CALL_OW 1
56611: ST_TO_ADDR
// continue ;
56612: GO 56244
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
56614: LD_ADDR_VAR 0 8
56618: PUSH
56619: LD_EXP 100
56623: PUSH
56624: LD_VAR 0 2
56628: ARRAY
56629: PPUSH
56630: LD_INT 30
56632: PUSH
56633: LD_INT 3
56635: PUSH
56636: EMPTY
56637: LIST
56638: LIST
56639: PPUSH
56640: CALL_OW 72
56644: ST_TO_ADDR
// if tmp then
56645: LD_VAR 0 8
56649: IFFALSE 56752
// begin for j in tmp do
56651: LD_ADDR_VAR 0 3
56655: PUSH
56656: LD_VAR 0 8
56660: PUSH
56661: FOR_IN
56662: IFFALSE 56750
// for k in UnitsInside ( j ) do
56664: LD_ADDR_VAR 0 4
56668: PUSH
56669: LD_VAR 0 3
56673: PPUSH
56674: CALL_OW 313
56678: PUSH
56679: FOR_IN
56680: IFFALSE 56746
// if k then
56682: LD_VAR 0 4
56686: IFFALSE 56744
// if not k in mc_repair_vehicle [ i ] then
56688: LD_VAR 0 4
56692: PUSH
56693: LD_EXP 112
56697: PUSH
56698: LD_VAR 0 2
56702: ARRAY
56703: IN
56704: NOT
56705: IFFALSE 56744
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
56707: LD_ADDR_EXP 112
56711: PUSH
56712: LD_EXP 112
56716: PPUSH
56717: LD_VAR 0 2
56721: PPUSH
56722: LD_EXP 112
56726: PUSH
56727: LD_VAR 0 2
56731: ARRAY
56732: PUSH
56733: LD_VAR 0 4
56737: UNION
56738: PPUSH
56739: CALL_OW 1
56743: ST_TO_ADDR
56744: GO 56679
56746: POP
56747: POP
56748: GO 56661
56750: POP
56751: POP
// end ; if not mc_repair_vehicle [ i ] then
56752: LD_EXP 112
56756: PUSH
56757: LD_VAR 0 2
56761: ARRAY
56762: NOT
56763: IFFALSE 56767
// continue ;
56765: GO 56244
// for j in mc_repair_vehicle [ i ] do
56767: LD_ADDR_VAR 0 3
56771: PUSH
56772: LD_EXP 112
56776: PUSH
56777: LD_VAR 0 2
56781: ARRAY
56782: PUSH
56783: FOR_IN
56784: IFFALSE 56961
// begin if GetClass ( j ) <> 3 then
56786: LD_VAR 0 3
56790: PPUSH
56791: CALL_OW 257
56795: PUSH
56796: LD_INT 3
56798: NONEQUAL
56799: IFFALSE 56840
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
56801: LD_ADDR_EXP 112
56805: PUSH
56806: LD_EXP 112
56810: PPUSH
56811: LD_VAR 0 2
56815: PPUSH
56816: LD_EXP 112
56820: PUSH
56821: LD_VAR 0 2
56825: ARRAY
56826: PUSH
56827: LD_VAR 0 3
56831: DIFF
56832: PPUSH
56833: CALL_OW 1
56837: ST_TO_ADDR
// continue ;
56838: GO 56783
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
56840: LD_VAR 0 3
56844: PPUSH
56845: CALL_OW 311
56849: NOT
56850: PUSH
56851: LD_VAR 0 3
56855: PUSH
56856: LD_EXP 103
56860: PUSH
56861: LD_VAR 0 2
56865: ARRAY
56866: PUSH
56867: LD_INT 1
56869: ARRAY
56870: IN
56871: NOT
56872: AND
56873: PUSH
56874: LD_VAR 0 3
56878: PUSH
56879: LD_EXP 103
56883: PUSH
56884: LD_VAR 0 2
56888: ARRAY
56889: PUSH
56890: LD_INT 2
56892: ARRAY
56893: IN
56894: NOT
56895: AND
56896: IFFALSE 56959
// begin if IsInUnit ( j ) then
56898: LD_VAR 0 3
56902: PPUSH
56903: CALL_OW 310
56907: IFFALSE 56920
// ComExitBuilding ( j ) else
56909: LD_VAR 0 3
56913: PPUSH
56914: CALL_OW 122
56918: GO 56959
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
56920: LD_VAR 0 3
56924: PPUSH
56925: LD_VAR 0 7
56929: PUSH
56930: LD_INT 1
56932: ARRAY
56933: PPUSH
56934: CALL 108255 0 2
56938: NOT
56939: IFFALSE 56959
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
56941: LD_VAR 0 3
56945: PPUSH
56946: LD_VAR 0 7
56950: PUSH
56951: LD_INT 1
56953: ARRAY
56954: PPUSH
56955: CALL_OW 129
// end ; end ;
56959: GO 56783
56961: POP
56962: POP
// end ;
56963: GO 56244
56965: POP
56966: POP
// end ;
56967: LD_VAR 0 1
56971: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
56972: LD_INT 0
56974: PPUSH
56975: PPUSH
56976: PPUSH
56977: PPUSH
56978: PPUSH
56979: PPUSH
56980: PPUSH
56981: PPUSH
56982: PPUSH
56983: PPUSH
56984: PPUSH
// if not mc_bases then
56985: LD_EXP 100
56989: NOT
56990: IFFALSE 56994
// exit ;
56992: GO 57796
// for i = 1 to mc_bases do
56994: LD_ADDR_VAR 0 2
56998: PUSH
56999: DOUBLE
57000: LD_INT 1
57002: DEC
57003: ST_TO_ADDR
57004: LD_EXP 100
57008: PUSH
57009: FOR_TO
57010: IFFALSE 57794
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
57012: LD_EXP 128
57016: PUSH
57017: LD_VAR 0 2
57021: ARRAY
57022: NOT
57023: PUSH
57024: LD_EXP 103
57028: PUSH
57029: LD_VAR 0 2
57033: ARRAY
57034: PUSH
57035: LD_INT 1
57037: ARRAY
57038: OR
57039: PUSH
57040: LD_EXP 103
57044: PUSH
57045: LD_VAR 0 2
57049: ARRAY
57050: PUSH
57051: LD_INT 2
57053: ARRAY
57054: OR
57055: PUSH
57056: LD_EXP 126
57060: PUSH
57061: LD_VAR 0 2
57065: ARRAY
57066: PPUSH
57067: LD_INT 1
57069: PPUSH
57070: CALL_OW 325
57074: NOT
57075: OR
57076: PUSH
57077: LD_EXP 123
57081: PUSH
57082: LD_VAR 0 2
57086: ARRAY
57087: OR
57088: IFFALSE 57092
// continue ;
57090: GO 57009
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
57092: LD_ADDR_VAR 0 8
57096: PUSH
57097: LD_EXP 100
57101: PUSH
57102: LD_VAR 0 2
57106: ARRAY
57107: PPUSH
57108: LD_INT 25
57110: PUSH
57111: LD_INT 4
57113: PUSH
57114: EMPTY
57115: LIST
57116: LIST
57117: PUSH
57118: LD_INT 50
57120: PUSH
57121: EMPTY
57122: LIST
57123: PUSH
57124: LD_INT 3
57126: PUSH
57127: LD_INT 60
57129: PUSH
57130: EMPTY
57131: LIST
57132: PUSH
57133: EMPTY
57134: LIST
57135: LIST
57136: PUSH
57137: EMPTY
57138: LIST
57139: LIST
57140: LIST
57141: PPUSH
57142: CALL_OW 72
57146: PUSH
57147: LD_EXP 104
57151: PUSH
57152: LD_VAR 0 2
57156: ARRAY
57157: DIFF
57158: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57159: LD_ADDR_VAR 0 9
57163: PUSH
57164: LD_EXP 100
57168: PUSH
57169: LD_VAR 0 2
57173: ARRAY
57174: PPUSH
57175: LD_INT 2
57177: PUSH
57178: LD_INT 30
57180: PUSH
57181: LD_INT 0
57183: PUSH
57184: EMPTY
57185: LIST
57186: LIST
57187: PUSH
57188: LD_INT 30
57190: PUSH
57191: LD_INT 1
57193: PUSH
57194: EMPTY
57195: LIST
57196: LIST
57197: PUSH
57198: EMPTY
57199: LIST
57200: LIST
57201: LIST
57202: PPUSH
57203: CALL_OW 72
57207: ST_TO_ADDR
// if not tmp or not dep then
57208: LD_VAR 0 8
57212: NOT
57213: PUSH
57214: LD_VAR 0 9
57218: NOT
57219: OR
57220: IFFALSE 57224
// continue ;
57222: GO 57009
// side := GetSide ( tmp [ 1 ] ) ;
57224: LD_ADDR_VAR 0 11
57228: PUSH
57229: LD_VAR 0 8
57233: PUSH
57234: LD_INT 1
57236: ARRAY
57237: PPUSH
57238: CALL_OW 255
57242: ST_TO_ADDR
// dep := dep [ 1 ] ;
57243: LD_ADDR_VAR 0 9
57247: PUSH
57248: LD_VAR 0 9
57252: PUSH
57253: LD_INT 1
57255: ARRAY
57256: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
57257: LD_ADDR_VAR 0 7
57261: PUSH
57262: LD_EXP 128
57266: PUSH
57267: LD_VAR 0 2
57271: ARRAY
57272: PPUSH
57273: LD_INT 22
57275: PUSH
57276: LD_INT 0
57278: PUSH
57279: EMPTY
57280: LIST
57281: LIST
57282: PUSH
57283: LD_INT 25
57285: PUSH
57286: LD_INT 12
57288: PUSH
57289: EMPTY
57290: LIST
57291: LIST
57292: PUSH
57293: EMPTY
57294: LIST
57295: LIST
57296: PPUSH
57297: CALL_OW 70
57301: PUSH
57302: LD_INT 22
57304: PUSH
57305: LD_INT 0
57307: PUSH
57308: EMPTY
57309: LIST
57310: LIST
57311: PUSH
57312: LD_INT 25
57314: PUSH
57315: LD_INT 12
57317: PUSH
57318: EMPTY
57319: LIST
57320: LIST
57321: PUSH
57322: LD_INT 91
57324: PUSH
57325: LD_VAR 0 9
57329: PUSH
57330: LD_INT 20
57332: PUSH
57333: EMPTY
57334: LIST
57335: LIST
57336: LIST
57337: PUSH
57338: EMPTY
57339: LIST
57340: LIST
57341: LIST
57342: PPUSH
57343: CALL_OW 69
57347: UNION
57348: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
57349: LD_ADDR_VAR 0 10
57353: PUSH
57354: LD_EXP 128
57358: PUSH
57359: LD_VAR 0 2
57363: ARRAY
57364: PPUSH
57365: LD_INT 81
57367: PUSH
57368: LD_VAR 0 11
57372: PUSH
57373: EMPTY
57374: LIST
57375: LIST
57376: PPUSH
57377: CALL_OW 70
57381: ST_TO_ADDR
// if not apes or danger_at_area then
57382: LD_VAR 0 7
57386: NOT
57387: PUSH
57388: LD_VAR 0 10
57392: OR
57393: IFFALSE 57443
// begin if mc_taming [ i ] then
57395: LD_EXP 131
57399: PUSH
57400: LD_VAR 0 2
57404: ARRAY
57405: IFFALSE 57441
// begin MC_Reset ( i , 121 ) ;
57407: LD_VAR 0 2
57411: PPUSH
57412: LD_INT 121
57414: PPUSH
57415: CALL 42373 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
57419: LD_ADDR_EXP 131
57423: PUSH
57424: LD_EXP 131
57428: PPUSH
57429: LD_VAR 0 2
57433: PPUSH
57434: EMPTY
57435: PPUSH
57436: CALL_OW 1
57440: ST_TO_ADDR
// end ; continue ;
57441: GO 57009
// end ; for j in tmp do
57443: LD_ADDR_VAR 0 3
57447: PUSH
57448: LD_VAR 0 8
57452: PUSH
57453: FOR_IN
57454: IFFALSE 57790
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
57456: LD_VAR 0 3
57460: PUSH
57461: LD_EXP 131
57465: PUSH
57466: LD_VAR 0 2
57470: ARRAY
57471: IN
57472: NOT
57473: PUSH
57474: LD_EXP 131
57478: PUSH
57479: LD_VAR 0 2
57483: ARRAY
57484: PUSH
57485: LD_INT 3
57487: LESS
57488: AND
57489: IFFALSE 57547
// begin SetTag ( j , 121 ) ;
57491: LD_VAR 0 3
57495: PPUSH
57496: LD_INT 121
57498: PPUSH
57499: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
57503: LD_ADDR_EXP 131
57507: PUSH
57508: LD_EXP 131
57512: PPUSH
57513: LD_VAR 0 2
57517: PUSH
57518: LD_EXP 131
57522: PUSH
57523: LD_VAR 0 2
57527: ARRAY
57528: PUSH
57529: LD_INT 1
57531: PLUS
57532: PUSH
57533: EMPTY
57534: LIST
57535: LIST
57536: PPUSH
57537: LD_VAR 0 3
57541: PPUSH
57542: CALL 73860 0 3
57546: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
57547: LD_VAR 0 3
57551: PUSH
57552: LD_EXP 131
57556: PUSH
57557: LD_VAR 0 2
57561: ARRAY
57562: IN
57563: IFFALSE 57788
// begin if GetClass ( j ) <> 4 then
57565: LD_VAR 0 3
57569: PPUSH
57570: CALL_OW 257
57574: PUSH
57575: LD_INT 4
57577: NONEQUAL
57578: IFFALSE 57631
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
57580: LD_ADDR_EXP 131
57584: PUSH
57585: LD_EXP 131
57589: PPUSH
57590: LD_VAR 0 2
57594: PPUSH
57595: LD_EXP 131
57599: PUSH
57600: LD_VAR 0 2
57604: ARRAY
57605: PUSH
57606: LD_VAR 0 3
57610: DIFF
57611: PPUSH
57612: CALL_OW 1
57616: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57617: LD_VAR 0 3
57621: PPUSH
57622: LD_INT 0
57624: PPUSH
57625: CALL_OW 109
// continue ;
57629: GO 57453
// end ; if IsInUnit ( j ) then
57631: LD_VAR 0 3
57635: PPUSH
57636: CALL_OW 310
57640: IFFALSE 57651
// ComExitBuilding ( j ) ;
57642: LD_VAR 0 3
57646: PPUSH
57647: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
57651: LD_ADDR_VAR 0 6
57655: PUSH
57656: LD_VAR 0 7
57660: PPUSH
57661: LD_VAR 0 3
57665: PPUSH
57666: CALL_OW 74
57670: ST_TO_ADDR
// if not ape then
57671: LD_VAR 0 6
57675: NOT
57676: IFFALSE 57680
// break ;
57678: GO 57790
// x := GetX ( ape ) ;
57680: LD_ADDR_VAR 0 4
57684: PUSH
57685: LD_VAR 0 6
57689: PPUSH
57690: CALL_OW 250
57694: ST_TO_ADDR
// y := GetY ( ape ) ;
57695: LD_ADDR_VAR 0 5
57699: PUSH
57700: LD_VAR 0 6
57704: PPUSH
57705: CALL_OW 251
57709: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
57710: LD_VAR 0 4
57714: PPUSH
57715: LD_VAR 0 5
57719: PPUSH
57720: CALL_OW 488
57724: NOT
57725: PUSH
57726: LD_VAR 0 11
57730: PPUSH
57731: LD_VAR 0 4
57735: PPUSH
57736: LD_VAR 0 5
57740: PPUSH
57741: LD_INT 20
57743: PPUSH
57744: CALL 74756 0 4
57748: PUSH
57749: LD_INT 4
57751: ARRAY
57752: OR
57753: IFFALSE 57757
// break ;
57755: GO 57790
// if not HasTask ( j ) then
57757: LD_VAR 0 3
57761: PPUSH
57762: CALL_OW 314
57766: NOT
57767: IFFALSE 57788
// ComTameXY ( j , x , y ) ;
57769: LD_VAR 0 3
57773: PPUSH
57774: LD_VAR 0 4
57778: PPUSH
57779: LD_VAR 0 5
57783: PPUSH
57784: CALL_OW 131
// end ; end ;
57788: GO 57453
57790: POP
57791: POP
// end ;
57792: GO 57009
57794: POP
57795: POP
// end ;
57796: LD_VAR 0 1
57800: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
57801: LD_INT 0
57803: PPUSH
57804: PPUSH
57805: PPUSH
57806: PPUSH
57807: PPUSH
57808: PPUSH
57809: PPUSH
57810: PPUSH
// if not mc_bases then
57811: LD_EXP 100
57815: NOT
57816: IFFALSE 57820
// exit ;
57818: GO 58446
// for i = 1 to mc_bases do
57820: LD_ADDR_VAR 0 2
57824: PUSH
57825: DOUBLE
57826: LD_INT 1
57828: DEC
57829: ST_TO_ADDR
57830: LD_EXP 100
57834: PUSH
57835: FOR_TO
57836: IFFALSE 58444
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
57838: LD_EXP 129
57842: PUSH
57843: LD_VAR 0 2
57847: ARRAY
57848: NOT
57849: PUSH
57850: LD_EXP 129
57854: PUSH
57855: LD_VAR 0 2
57859: ARRAY
57860: PPUSH
57861: LD_INT 25
57863: PUSH
57864: LD_INT 12
57866: PUSH
57867: EMPTY
57868: LIST
57869: LIST
57870: PPUSH
57871: CALL_OW 72
57875: NOT
57876: OR
57877: IFFALSE 57881
// continue ;
57879: GO 57835
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
57881: LD_ADDR_VAR 0 5
57885: PUSH
57886: LD_EXP 129
57890: PUSH
57891: LD_VAR 0 2
57895: ARRAY
57896: PUSH
57897: LD_INT 1
57899: ARRAY
57900: PPUSH
57901: CALL_OW 255
57905: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
57906: LD_VAR 0 5
57910: PPUSH
57911: LD_INT 2
57913: PPUSH
57914: CALL_OW 325
57918: IFFALSE 58171
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
57920: LD_ADDR_VAR 0 4
57924: PUSH
57925: LD_EXP 129
57929: PUSH
57930: LD_VAR 0 2
57934: ARRAY
57935: PPUSH
57936: LD_INT 25
57938: PUSH
57939: LD_INT 16
57941: PUSH
57942: EMPTY
57943: LIST
57944: LIST
57945: PPUSH
57946: CALL_OW 72
57950: ST_TO_ADDR
// if tmp < 6 then
57951: LD_VAR 0 4
57955: PUSH
57956: LD_INT 6
57958: LESS
57959: IFFALSE 58171
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57961: LD_ADDR_VAR 0 6
57965: PUSH
57966: LD_EXP 100
57970: PUSH
57971: LD_VAR 0 2
57975: ARRAY
57976: PPUSH
57977: LD_INT 2
57979: PUSH
57980: LD_INT 30
57982: PUSH
57983: LD_INT 0
57985: PUSH
57986: EMPTY
57987: LIST
57988: LIST
57989: PUSH
57990: LD_INT 30
57992: PUSH
57993: LD_INT 1
57995: PUSH
57996: EMPTY
57997: LIST
57998: LIST
57999: PUSH
58000: EMPTY
58001: LIST
58002: LIST
58003: LIST
58004: PPUSH
58005: CALL_OW 72
58009: ST_TO_ADDR
// if depot then
58010: LD_VAR 0 6
58014: IFFALSE 58171
// begin selected := 0 ;
58016: LD_ADDR_VAR 0 7
58020: PUSH
58021: LD_INT 0
58023: ST_TO_ADDR
// for j in depot do
58024: LD_ADDR_VAR 0 3
58028: PUSH
58029: LD_VAR 0 6
58033: PUSH
58034: FOR_IN
58035: IFFALSE 58066
// begin if UnitsInside ( j ) < 6 then
58037: LD_VAR 0 3
58041: PPUSH
58042: CALL_OW 313
58046: PUSH
58047: LD_INT 6
58049: LESS
58050: IFFALSE 58064
// begin selected := j ;
58052: LD_ADDR_VAR 0 7
58056: PUSH
58057: LD_VAR 0 3
58061: ST_TO_ADDR
// break ;
58062: GO 58066
// end ; end ;
58064: GO 58034
58066: POP
58067: POP
// if selected then
58068: LD_VAR 0 7
58072: IFFALSE 58171
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58074: LD_ADDR_VAR 0 3
58078: PUSH
58079: LD_EXP 129
58083: PUSH
58084: LD_VAR 0 2
58088: ARRAY
58089: PPUSH
58090: LD_INT 25
58092: PUSH
58093: LD_INT 12
58095: PUSH
58096: EMPTY
58097: LIST
58098: LIST
58099: PPUSH
58100: CALL_OW 72
58104: PUSH
58105: FOR_IN
58106: IFFALSE 58169
// if not HasTask ( j ) then
58108: LD_VAR 0 3
58112: PPUSH
58113: CALL_OW 314
58117: NOT
58118: IFFALSE 58167
// begin if not IsInUnit ( j ) then
58120: LD_VAR 0 3
58124: PPUSH
58125: CALL_OW 310
58129: NOT
58130: IFFALSE 58146
// ComEnterUnit ( j , selected ) ;
58132: LD_VAR 0 3
58136: PPUSH
58137: LD_VAR 0 7
58141: PPUSH
58142: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
58146: LD_VAR 0 3
58150: PPUSH
58151: LD_INT 16
58153: PPUSH
58154: CALL_OW 183
// AddComExitBuilding ( j ) ;
58158: LD_VAR 0 3
58162: PPUSH
58163: CALL_OW 182
// end ;
58167: GO 58105
58169: POP
58170: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
58171: LD_VAR 0 5
58175: PPUSH
58176: LD_INT 11
58178: PPUSH
58179: CALL_OW 325
58183: IFFALSE 58442
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
58185: LD_ADDR_VAR 0 4
58189: PUSH
58190: LD_EXP 129
58194: PUSH
58195: LD_VAR 0 2
58199: ARRAY
58200: PPUSH
58201: LD_INT 25
58203: PUSH
58204: LD_INT 16
58206: PUSH
58207: EMPTY
58208: LIST
58209: LIST
58210: PPUSH
58211: CALL_OW 72
58215: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
58216: LD_VAR 0 4
58220: PUSH
58221: LD_INT 6
58223: GREATEREQUAL
58224: PUSH
58225: LD_VAR 0 5
58229: PPUSH
58230: LD_INT 2
58232: PPUSH
58233: CALL_OW 325
58237: NOT
58238: OR
58239: IFFALSE 58442
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
58241: LD_ADDR_VAR 0 8
58245: PUSH
58246: LD_EXP 100
58250: PUSH
58251: LD_VAR 0 2
58255: ARRAY
58256: PPUSH
58257: LD_INT 2
58259: PUSH
58260: LD_INT 30
58262: PUSH
58263: LD_INT 4
58265: PUSH
58266: EMPTY
58267: LIST
58268: LIST
58269: PUSH
58270: LD_INT 30
58272: PUSH
58273: LD_INT 5
58275: PUSH
58276: EMPTY
58277: LIST
58278: LIST
58279: PUSH
58280: EMPTY
58281: LIST
58282: LIST
58283: LIST
58284: PPUSH
58285: CALL_OW 72
58289: ST_TO_ADDR
// if barracks then
58290: LD_VAR 0 8
58294: IFFALSE 58442
// begin selected := 0 ;
58296: LD_ADDR_VAR 0 7
58300: PUSH
58301: LD_INT 0
58303: ST_TO_ADDR
// for j in barracks do
58304: LD_ADDR_VAR 0 3
58308: PUSH
58309: LD_VAR 0 8
58313: PUSH
58314: FOR_IN
58315: IFFALSE 58346
// begin if UnitsInside ( j ) < 6 then
58317: LD_VAR 0 3
58321: PPUSH
58322: CALL_OW 313
58326: PUSH
58327: LD_INT 6
58329: LESS
58330: IFFALSE 58344
// begin selected := j ;
58332: LD_ADDR_VAR 0 7
58336: PUSH
58337: LD_VAR 0 3
58341: ST_TO_ADDR
// break ;
58342: GO 58346
// end ; end ;
58344: GO 58314
58346: POP
58347: POP
// if selected then
58348: LD_VAR 0 7
58352: IFFALSE 58442
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
58354: LD_ADDR_VAR 0 3
58358: PUSH
58359: LD_EXP 129
58363: PUSH
58364: LD_VAR 0 2
58368: ARRAY
58369: PPUSH
58370: LD_INT 25
58372: PUSH
58373: LD_INT 12
58375: PUSH
58376: EMPTY
58377: LIST
58378: LIST
58379: PPUSH
58380: CALL_OW 72
58384: PUSH
58385: FOR_IN
58386: IFFALSE 58440
// if not IsInUnit ( j ) and not HasTask ( j ) then
58388: LD_VAR 0 3
58392: PPUSH
58393: CALL_OW 310
58397: NOT
58398: PUSH
58399: LD_VAR 0 3
58403: PPUSH
58404: CALL_OW 314
58408: NOT
58409: AND
58410: IFFALSE 58438
// begin ComEnterUnit ( j , selected ) ;
58412: LD_VAR 0 3
58416: PPUSH
58417: LD_VAR 0 7
58421: PPUSH
58422: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
58426: LD_VAR 0 3
58430: PPUSH
58431: LD_INT 15
58433: PPUSH
58434: CALL_OW 183
// end ;
58438: GO 58385
58440: POP
58441: POP
// end ; end ; end ; end ; end ;
58442: GO 57835
58444: POP
58445: POP
// end ;
58446: LD_VAR 0 1
58450: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
58451: LD_INT 0
58453: PPUSH
58454: PPUSH
58455: PPUSH
58456: PPUSH
// if not mc_bases then
58457: LD_EXP 100
58461: NOT
58462: IFFALSE 58466
// exit ;
58464: GO 58644
// for i = 1 to mc_bases do
58466: LD_ADDR_VAR 0 2
58470: PUSH
58471: DOUBLE
58472: LD_INT 1
58474: DEC
58475: ST_TO_ADDR
58476: LD_EXP 100
58480: PUSH
58481: FOR_TO
58482: IFFALSE 58642
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
58484: LD_ADDR_VAR 0 4
58488: PUSH
58489: LD_EXP 100
58493: PUSH
58494: LD_VAR 0 2
58498: ARRAY
58499: PPUSH
58500: LD_INT 25
58502: PUSH
58503: LD_INT 9
58505: PUSH
58506: EMPTY
58507: LIST
58508: LIST
58509: PPUSH
58510: CALL_OW 72
58514: ST_TO_ADDR
// if not tmp then
58515: LD_VAR 0 4
58519: NOT
58520: IFFALSE 58524
// continue ;
58522: GO 58481
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
58524: LD_EXP 126
58528: PUSH
58529: LD_VAR 0 2
58533: ARRAY
58534: PPUSH
58535: LD_INT 29
58537: PPUSH
58538: CALL_OW 325
58542: NOT
58543: PUSH
58544: LD_EXP 126
58548: PUSH
58549: LD_VAR 0 2
58553: ARRAY
58554: PPUSH
58555: LD_INT 28
58557: PPUSH
58558: CALL_OW 325
58562: NOT
58563: AND
58564: IFFALSE 58568
// continue ;
58566: GO 58481
// for j in tmp do
58568: LD_ADDR_VAR 0 3
58572: PUSH
58573: LD_VAR 0 4
58577: PUSH
58578: FOR_IN
58579: IFFALSE 58638
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
58581: LD_VAR 0 3
58585: PUSH
58586: LD_EXP 103
58590: PUSH
58591: LD_VAR 0 2
58595: ARRAY
58596: PUSH
58597: LD_INT 1
58599: ARRAY
58600: IN
58601: NOT
58602: PUSH
58603: LD_VAR 0 3
58607: PUSH
58608: LD_EXP 103
58612: PUSH
58613: LD_VAR 0 2
58617: ARRAY
58618: PUSH
58619: LD_INT 2
58621: ARRAY
58622: IN
58623: NOT
58624: AND
58625: IFFALSE 58636
// ComSpaceTimeShoot ( j ) ;
58627: LD_VAR 0 3
58631: PPUSH
58632: CALL 69845 0 1
58636: GO 58578
58638: POP
58639: POP
// end ;
58640: GO 58481
58642: POP
58643: POP
// end ;
58644: LD_VAR 0 1
58648: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
58649: LD_INT 0
58651: PPUSH
58652: PPUSH
58653: PPUSH
58654: PPUSH
58655: PPUSH
58656: PPUSH
58657: PPUSH
58658: PPUSH
58659: PPUSH
// if not mc_bases then
58660: LD_EXP 100
58664: NOT
58665: IFFALSE 58669
// exit ;
58667: GO 59291
// for i = 1 to mc_bases do
58669: LD_ADDR_VAR 0 2
58673: PUSH
58674: DOUBLE
58675: LD_INT 1
58677: DEC
58678: ST_TO_ADDR
58679: LD_EXP 100
58683: PUSH
58684: FOR_TO
58685: IFFALSE 59289
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
58687: LD_EXP 135
58691: PUSH
58692: LD_VAR 0 2
58696: ARRAY
58697: NOT
58698: PUSH
58699: LD_INT 38
58701: PPUSH
58702: LD_EXP 126
58706: PUSH
58707: LD_VAR 0 2
58711: ARRAY
58712: PPUSH
58713: CALL_OW 321
58717: PUSH
58718: LD_INT 2
58720: NONEQUAL
58721: OR
58722: IFFALSE 58726
// continue ;
58724: GO 58684
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
58726: LD_ADDR_VAR 0 8
58730: PUSH
58731: LD_EXP 100
58735: PUSH
58736: LD_VAR 0 2
58740: ARRAY
58741: PPUSH
58742: LD_INT 30
58744: PUSH
58745: LD_INT 34
58747: PUSH
58748: EMPTY
58749: LIST
58750: LIST
58751: PPUSH
58752: CALL_OW 72
58756: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
58757: LD_ADDR_VAR 0 9
58761: PUSH
58762: LD_EXP 100
58766: PUSH
58767: LD_VAR 0 2
58771: ARRAY
58772: PPUSH
58773: LD_INT 25
58775: PUSH
58776: LD_INT 4
58778: PUSH
58779: EMPTY
58780: LIST
58781: LIST
58782: PPUSH
58783: CALL_OW 72
58787: PPUSH
58788: LD_INT 0
58790: PPUSH
58791: CALL 103772 0 2
58795: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
58796: LD_VAR 0 9
58800: NOT
58801: PUSH
58802: LD_VAR 0 8
58806: NOT
58807: OR
58808: PUSH
58809: LD_EXP 100
58813: PUSH
58814: LD_VAR 0 2
58818: ARRAY
58819: PPUSH
58820: LD_INT 124
58822: PPUSH
58823: CALL 103772 0 2
58827: OR
58828: IFFALSE 58832
// continue ;
58830: GO 58684
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
58832: LD_EXP 136
58836: PUSH
58837: LD_VAR 0 2
58841: ARRAY
58842: PUSH
58843: LD_EXP 135
58847: PUSH
58848: LD_VAR 0 2
58852: ARRAY
58853: LESS
58854: PUSH
58855: LD_EXP 136
58859: PUSH
58860: LD_VAR 0 2
58864: ARRAY
58865: PUSH
58866: LD_VAR 0 8
58870: LESS
58871: AND
58872: IFFALSE 59287
// begin tmp := sci [ 1 ] ;
58874: LD_ADDR_VAR 0 7
58878: PUSH
58879: LD_VAR 0 9
58883: PUSH
58884: LD_INT 1
58886: ARRAY
58887: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
58888: LD_VAR 0 7
58892: PPUSH
58893: LD_INT 124
58895: PPUSH
58896: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
58900: LD_ADDR_VAR 0 3
58904: PUSH
58905: DOUBLE
58906: LD_EXP 135
58910: PUSH
58911: LD_VAR 0 2
58915: ARRAY
58916: INC
58917: ST_TO_ADDR
58918: LD_EXP 135
58922: PUSH
58923: LD_VAR 0 2
58927: ARRAY
58928: PUSH
58929: FOR_DOWNTO
58930: IFFALSE 59273
// begin if IsInUnit ( tmp ) then
58932: LD_VAR 0 7
58936: PPUSH
58937: CALL_OW 310
58941: IFFALSE 58952
// ComExitBuilding ( tmp ) ;
58943: LD_VAR 0 7
58947: PPUSH
58948: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
58952: LD_INT 35
58954: PPUSH
58955: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
58959: LD_VAR 0 7
58963: PPUSH
58964: CALL_OW 310
58968: NOT
58969: PUSH
58970: LD_VAR 0 7
58974: PPUSH
58975: CALL_OW 314
58979: NOT
58980: AND
58981: IFFALSE 58952
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
58983: LD_ADDR_VAR 0 6
58987: PUSH
58988: LD_VAR 0 7
58992: PPUSH
58993: CALL_OW 250
58997: PUSH
58998: LD_VAR 0 7
59002: PPUSH
59003: CALL_OW 251
59007: PUSH
59008: EMPTY
59009: LIST
59010: LIST
59011: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
59012: LD_INT 35
59014: PPUSH
59015: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
59019: LD_ADDR_VAR 0 4
59023: PUSH
59024: LD_EXP 135
59028: PUSH
59029: LD_VAR 0 2
59033: ARRAY
59034: PUSH
59035: LD_VAR 0 3
59039: ARRAY
59040: PUSH
59041: LD_INT 1
59043: ARRAY
59044: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
59045: LD_ADDR_VAR 0 5
59049: PUSH
59050: LD_EXP 135
59054: PUSH
59055: LD_VAR 0 2
59059: ARRAY
59060: PUSH
59061: LD_VAR 0 3
59065: ARRAY
59066: PUSH
59067: LD_INT 2
59069: ARRAY
59070: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
59071: LD_VAR 0 7
59075: PPUSH
59076: LD_INT 10
59078: PPUSH
59079: CALL 76457 0 2
59083: PUSH
59084: LD_INT 4
59086: ARRAY
59087: IFFALSE 59125
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
59089: LD_VAR 0 7
59093: PPUSH
59094: LD_VAR 0 6
59098: PUSH
59099: LD_INT 1
59101: ARRAY
59102: PPUSH
59103: LD_VAR 0 6
59107: PUSH
59108: LD_INT 2
59110: ARRAY
59111: PPUSH
59112: CALL_OW 111
// wait ( 0 0$10 ) ;
59116: LD_INT 350
59118: PPUSH
59119: CALL_OW 67
// end else
59123: GO 59151
// begin ComMoveXY ( tmp , x , y ) ;
59125: LD_VAR 0 7
59129: PPUSH
59130: LD_VAR 0 4
59134: PPUSH
59135: LD_VAR 0 5
59139: PPUSH
59140: CALL_OW 111
// wait ( 0 0$3 ) ;
59144: LD_INT 105
59146: PPUSH
59147: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
59151: LD_VAR 0 7
59155: PPUSH
59156: LD_VAR 0 4
59160: PPUSH
59161: LD_VAR 0 5
59165: PPUSH
59166: CALL_OW 307
59170: IFFALSE 59012
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
59172: LD_VAR 0 7
59176: PPUSH
59177: LD_VAR 0 4
59181: PPUSH
59182: LD_VAR 0 5
59186: PPUSH
59187: LD_VAR 0 8
59191: PUSH
59192: LD_VAR 0 3
59196: ARRAY
59197: PPUSH
59198: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
59202: LD_INT 35
59204: PPUSH
59205: CALL_OW 67
// until not HasTask ( tmp ) ;
59209: LD_VAR 0 7
59213: PPUSH
59214: CALL_OW 314
59218: NOT
59219: IFFALSE 59202
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
59221: LD_ADDR_EXP 136
59225: PUSH
59226: LD_EXP 136
59230: PPUSH
59231: LD_VAR 0 2
59235: PUSH
59236: LD_EXP 136
59240: PUSH
59241: LD_VAR 0 2
59245: ARRAY
59246: PUSH
59247: LD_INT 1
59249: PLUS
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: PPUSH
59255: LD_VAR 0 8
59259: PUSH
59260: LD_VAR 0 3
59264: ARRAY
59265: PPUSH
59266: CALL 73860 0 3
59270: ST_TO_ADDR
// end ;
59271: GO 58929
59273: POP
59274: POP
// MC_Reset ( i , 124 ) ;
59275: LD_VAR 0 2
59279: PPUSH
59280: LD_INT 124
59282: PPUSH
59283: CALL 42373 0 2
// end ; end ;
59287: GO 58684
59289: POP
59290: POP
// end ;
59291: LD_VAR 0 1
59295: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
59296: LD_INT 0
59298: PPUSH
59299: PPUSH
59300: PPUSH
// if not mc_bases then
59301: LD_EXP 100
59305: NOT
59306: IFFALSE 59310
// exit ;
59308: GO 59916
// for i = 1 to mc_bases do
59310: LD_ADDR_VAR 0 2
59314: PUSH
59315: DOUBLE
59316: LD_INT 1
59318: DEC
59319: ST_TO_ADDR
59320: LD_EXP 100
59324: PUSH
59325: FOR_TO
59326: IFFALSE 59914
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
59328: LD_ADDR_VAR 0 3
59332: PUSH
59333: LD_EXP 100
59337: PUSH
59338: LD_VAR 0 2
59342: ARRAY
59343: PPUSH
59344: LD_INT 25
59346: PUSH
59347: LD_INT 4
59349: PUSH
59350: EMPTY
59351: LIST
59352: LIST
59353: PPUSH
59354: CALL_OW 72
59358: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
59359: LD_VAR 0 3
59363: NOT
59364: PUSH
59365: LD_EXP 137
59369: PUSH
59370: LD_VAR 0 2
59374: ARRAY
59375: NOT
59376: OR
59377: PUSH
59378: LD_EXP 100
59382: PUSH
59383: LD_VAR 0 2
59387: ARRAY
59388: PPUSH
59389: LD_INT 2
59391: PUSH
59392: LD_INT 30
59394: PUSH
59395: LD_INT 0
59397: PUSH
59398: EMPTY
59399: LIST
59400: LIST
59401: PUSH
59402: LD_INT 30
59404: PUSH
59405: LD_INT 1
59407: PUSH
59408: EMPTY
59409: LIST
59410: LIST
59411: PUSH
59412: EMPTY
59413: LIST
59414: LIST
59415: LIST
59416: PPUSH
59417: CALL_OW 72
59421: NOT
59422: OR
59423: IFFALSE 59473
// begin if mc_deposits_finder [ i ] then
59425: LD_EXP 138
59429: PUSH
59430: LD_VAR 0 2
59434: ARRAY
59435: IFFALSE 59471
// begin MC_Reset ( i , 125 ) ;
59437: LD_VAR 0 2
59441: PPUSH
59442: LD_INT 125
59444: PPUSH
59445: CALL 42373 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59449: LD_ADDR_EXP 138
59453: PUSH
59454: LD_EXP 138
59458: PPUSH
59459: LD_VAR 0 2
59463: PPUSH
59464: EMPTY
59465: PPUSH
59466: CALL_OW 1
59470: ST_TO_ADDR
// end ; continue ;
59471: GO 59325
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
59473: LD_EXP 137
59477: PUSH
59478: LD_VAR 0 2
59482: ARRAY
59483: PUSH
59484: LD_INT 1
59486: ARRAY
59487: PUSH
59488: LD_INT 3
59490: ARRAY
59491: PUSH
59492: LD_INT 1
59494: EQUAL
59495: PUSH
59496: LD_INT 20
59498: PPUSH
59499: LD_EXP 126
59503: PUSH
59504: LD_VAR 0 2
59508: ARRAY
59509: PPUSH
59510: CALL_OW 321
59514: PUSH
59515: LD_INT 2
59517: NONEQUAL
59518: AND
59519: IFFALSE 59569
// begin if mc_deposits_finder [ i ] then
59521: LD_EXP 138
59525: PUSH
59526: LD_VAR 0 2
59530: ARRAY
59531: IFFALSE 59567
// begin MC_Reset ( i , 125 ) ;
59533: LD_VAR 0 2
59537: PPUSH
59538: LD_INT 125
59540: PPUSH
59541: CALL 42373 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59545: LD_ADDR_EXP 138
59549: PUSH
59550: LD_EXP 138
59554: PPUSH
59555: LD_VAR 0 2
59559: PPUSH
59560: EMPTY
59561: PPUSH
59562: CALL_OW 1
59566: ST_TO_ADDR
// end ; continue ;
59567: GO 59325
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
59569: LD_EXP 137
59573: PUSH
59574: LD_VAR 0 2
59578: ARRAY
59579: PUSH
59580: LD_INT 1
59582: ARRAY
59583: PUSH
59584: LD_INT 1
59586: ARRAY
59587: PPUSH
59588: LD_EXP 137
59592: PUSH
59593: LD_VAR 0 2
59597: ARRAY
59598: PUSH
59599: LD_INT 1
59601: ARRAY
59602: PUSH
59603: LD_INT 2
59605: ARRAY
59606: PPUSH
59607: LD_EXP 126
59611: PUSH
59612: LD_VAR 0 2
59616: ARRAY
59617: PPUSH
59618: CALL_OW 440
59622: IFFALSE 59665
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
59624: LD_ADDR_EXP 137
59628: PUSH
59629: LD_EXP 137
59633: PPUSH
59634: LD_VAR 0 2
59638: PPUSH
59639: LD_EXP 137
59643: PUSH
59644: LD_VAR 0 2
59648: ARRAY
59649: PPUSH
59650: LD_INT 1
59652: PPUSH
59653: CALL_OW 3
59657: PPUSH
59658: CALL_OW 1
59662: ST_TO_ADDR
59663: GO 59912
// begin if not mc_deposits_finder [ i ] then
59665: LD_EXP 138
59669: PUSH
59670: LD_VAR 0 2
59674: ARRAY
59675: NOT
59676: IFFALSE 59728
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
59678: LD_ADDR_EXP 138
59682: PUSH
59683: LD_EXP 138
59687: PPUSH
59688: LD_VAR 0 2
59692: PPUSH
59693: LD_VAR 0 3
59697: PUSH
59698: LD_INT 1
59700: ARRAY
59701: PUSH
59702: EMPTY
59703: LIST
59704: PPUSH
59705: CALL_OW 1
59709: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
59710: LD_VAR 0 3
59714: PUSH
59715: LD_INT 1
59717: ARRAY
59718: PPUSH
59719: LD_INT 125
59721: PPUSH
59722: CALL_OW 109
// end else
59726: GO 59912
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
59728: LD_EXP 138
59732: PUSH
59733: LD_VAR 0 2
59737: ARRAY
59738: PUSH
59739: LD_INT 1
59741: ARRAY
59742: PPUSH
59743: CALL_OW 310
59747: IFFALSE 59770
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
59749: LD_EXP 138
59753: PUSH
59754: LD_VAR 0 2
59758: ARRAY
59759: PUSH
59760: LD_INT 1
59762: ARRAY
59763: PPUSH
59764: CALL_OW 122
59768: GO 59912
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
59770: LD_EXP 138
59774: PUSH
59775: LD_VAR 0 2
59779: ARRAY
59780: PUSH
59781: LD_INT 1
59783: ARRAY
59784: PPUSH
59785: CALL_OW 314
59789: NOT
59790: PUSH
59791: LD_EXP 138
59795: PUSH
59796: LD_VAR 0 2
59800: ARRAY
59801: PUSH
59802: LD_INT 1
59804: ARRAY
59805: PPUSH
59806: LD_EXP 137
59810: PUSH
59811: LD_VAR 0 2
59815: ARRAY
59816: PUSH
59817: LD_INT 1
59819: ARRAY
59820: PUSH
59821: LD_INT 1
59823: ARRAY
59824: PPUSH
59825: LD_EXP 137
59829: PUSH
59830: LD_VAR 0 2
59834: ARRAY
59835: PUSH
59836: LD_INT 1
59838: ARRAY
59839: PUSH
59840: LD_INT 2
59842: ARRAY
59843: PPUSH
59844: CALL_OW 297
59848: PUSH
59849: LD_INT 6
59851: GREATER
59852: AND
59853: IFFALSE 59912
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
59855: LD_EXP 138
59859: PUSH
59860: LD_VAR 0 2
59864: ARRAY
59865: PUSH
59866: LD_INT 1
59868: ARRAY
59869: PPUSH
59870: LD_EXP 137
59874: PUSH
59875: LD_VAR 0 2
59879: ARRAY
59880: PUSH
59881: LD_INT 1
59883: ARRAY
59884: PUSH
59885: LD_INT 1
59887: ARRAY
59888: PPUSH
59889: LD_EXP 137
59893: PUSH
59894: LD_VAR 0 2
59898: ARRAY
59899: PUSH
59900: LD_INT 1
59902: ARRAY
59903: PUSH
59904: LD_INT 2
59906: ARRAY
59907: PPUSH
59908: CALL_OW 111
// end ; end ; end ;
59912: GO 59325
59914: POP
59915: POP
// end ;
59916: LD_VAR 0 1
59920: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
59921: LD_INT 0
59923: PPUSH
59924: PPUSH
59925: PPUSH
59926: PPUSH
59927: PPUSH
59928: PPUSH
59929: PPUSH
59930: PPUSH
59931: PPUSH
59932: PPUSH
59933: PPUSH
// if not mc_bases then
59934: LD_EXP 100
59938: NOT
59939: IFFALSE 59943
// exit ;
59941: GO 60883
// for i = 1 to mc_bases do
59943: LD_ADDR_VAR 0 2
59947: PUSH
59948: DOUBLE
59949: LD_INT 1
59951: DEC
59952: ST_TO_ADDR
59953: LD_EXP 100
59957: PUSH
59958: FOR_TO
59959: IFFALSE 60881
// begin if not mc_bases [ i ] or mc_scan [ i ] then
59961: LD_EXP 100
59965: PUSH
59966: LD_VAR 0 2
59970: ARRAY
59971: NOT
59972: PUSH
59973: LD_EXP 123
59977: PUSH
59978: LD_VAR 0 2
59982: ARRAY
59983: OR
59984: IFFALSE 59988
// continue ;
59986: GO 59958
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
59988: LD_ADDR_VAR 0 7
59992: PUSH
59993: LD_EXP 100
59997: PUSH
59998: LD_VAR 0 2
60002: ARRAY
60003: PUSH
60004: LD_INT 1
60006: ARRAY
60007: PPUSH
60008: CALL_OW 248
60012: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
60013: LD_VAR 0 7
60017: PUSH
60018: LD_INT 3
60020: EQUAL
60021: PUSH
60022: LD_EXP 119
60026: PUSH
60027: LD_VAR 0 2
60031: ARRAY
60032: PUSH
60033: LD_EXP 122
60037: PUSH
60038: LD_VAR 0 2
60042: ARRAY
60043: UNION
60044: PPUSH
60045: LD_INT 33
60047: PUSH
60048: LD_INT 2
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: PPUSH
60055: CALL_OW 72
60059: NOT
60060: OR
60061: IFFALSE 60065
// continue ;
60063: GO 59958
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
60065: LD_ADDR_VAR 0 9
60069: PUSH
60070: LD_EXP 100
60074: PUSH
60075: LD_VAR 0 2
60079: ARRAY
60080: PPUSH
60081: LD_INT 30
60083: PUSH
60084: LD_INT 36
60086: PUSH
60087: EMPTY
60088: LIST
60089: LIST
60090: PPUSH
60091: CALL_OW 72
60095: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
60096: LD_ADDR_VAR 0 10
60100: PUSH
60101: LD_EXP 119
60105: PUSH
60106: LD_VAR 0 2
60110: ARRAY
60111: PPUSH
60112: LD_INT 34
60114: PUSH
60115: LD_INT 31
60117: PUSH
60118: EMPTY
60119: LIST
60120: LIST
60121: PPUSH
60122: CALL_OW 72
60126: ST_TO_ADDR
// if not cts and not mcts then
60127: LD_VAR 0 9
60131: NOT
60132: PUSH
60133: LD_VAR 0 10
60137: NOT
60138: AND
60139: IFFALSE 60143
// continue ;
60141: GO 59958
// x := cts ;
60143: LD_ADDR_VAR 0 11
60147: PUSH
60148: LD_VAR 0 9
60152: ST_TO_ADDR
// if not x then
60153: LD_VAR 0 11
60157: NOT
60158: IFFALSE 60170
// x := mcts ;
60160: LD_ADDR_VAR 0 11
60164: PUSH
60165: LD_VAR 0 10
60169: ST_TO_ADDR
// if not x then
60170: LD_VAR 0 11
60174: NOT
60175: IFFALSE 60179
// continue ;
60177: GO 59958
// if mc_remote_driver [ i ] then
60179: LD_EXP 140
60183: PUSH
60184: LD_VAR 0 2
60188: ARRAY
60189: IFFALSE 60576
// for j in mc_remote_driver [ i ] do
60191: LD_ADDR_VAR 0 3
60195: PUSH
60196: LD_EXP 140
60200: PUSH
60201: LD_VAR 0 2
60205: ARRAY
60206: PUSH
60207: FOR_IN
60208: IFFALSE 60574
// begin if GetClass ( j ) <> 3 then
60210: LD_VAR 0 3
60214: PPUSH
60215: CALL_OW 257
60219: PUSH
60220: LD_INT 3
60222: NONEQUAL
60223: IFFALSE 60276
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
60225: LD_ADDR_EXP 140
60229: PUSH
60230: LD_EXP 140
60234: PPUSH
60235: LD_VAR 0 2
60239: PPUSH
60240: LD_EXP 140
60244: PUSH
60245: LD_VAR 0 2
60249: ARRAY
60250: PUSH
60251: LD_VAR 0 3
60255: DIFF
60256: PPUSH
60257: CALL_OW 1
60261: ST_TO_ADDR
// SetTag ( j , 0 ) ;
60262: LD_VAR 0 3
60266: PPUSH
60267: LD_INT 0
60269: PPUSH
60270: CALL_OW 109
// continue ;
60274: GO 60207
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
60276: LD_EXP 119
60280: PUSH
60281: LD_VAR 0 2
60285: ARRAY
60286: PPUSH
60287: LD_INT 34
60289: PUSH
60290: LD_INT 31
60292: PUSH
60293: EMPTY
60294: LIST
60295: LIST
60296: PUSH
60297: LD_INT 58
60299: PUSH
60300: EMPTY
60301: LIST
60302: PUSH
60303: EMPTY
60304: LIST
60305: LIST
60306: PPUSH
60307: CALL_OW 72
60311: PUSH
60312: LD_VAR 0 3
60316: PPUSH
60317: CALL 103807 0 1
60321: NOT
60322: AND
60323: IFFALSE 60394
// begin if IsInUnit ( j ) then
60325: LD_VAR 0 3
60329: PPUSH
60330: CALL_OW 310
60334: IFFALSE 60345
// ComExitBuilding ( j ) ;
60336: LD_VAR 0 3
60340: PPUSH
60341: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
60345: LD_VAR 0 3
60349: PPUSH
60350: LD_EXP 119
60354: PUSH
60355: LD_VAR 0 2
60359: ARRAY
60360: PPUSH
60361: LD_INT 34
60363: PUSH
60364: LD_INT 31
60366: PUSH
60367: EMPTY
60368: LIST
60369: LIST
60370: PUSH
60371: LD_INT 58
60373: PUSH
60374: EMPTY
60375: LIST
60376: PUSH
60377: EMPTY
60378: LIST
60379: LIST
60380: PPUSH
60381: CALL_OW 72
60385: PUSH
60386: LD_INT 1
60388: ARRAY
60389: PPUSH
60390: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
60394: LD_VAR 0 3
60398: PPUSH
60399: CALL_OW 310
60403: NOT
60404: PUSH
60405: LD_VAR 0 3
60409: PPUSH
60410: CALL_OW 310
60414: PPUSH
60415: CALL_OW 266
60419: PUSH
60420: LD_INT 36
60422: NONEQUAL
60423: PUSH
60424: LD_VAR 0 3
60428: PPUSH
60429: CALL 103807 0 1
60433: NOT
60434: AND
60435: OR
60436: IFFALSE 60572
// begin if IsInUnit ( j ) then
60438: LD_VAR 0 3
60442: PPUSH
60443: CALL_OW 310
60447: IFFALSE 60458
// ComExitBuilding ( j ) ;
60449: LD_VAR 0 3
60453: PPUSH
60454: CALL_OW 122
// ct := 0 ;
60458: LD_ADDR_VAR 0 8
60462: PUSH
60463: LD_INT 0
60465: ST_TO_ADDR
// for k in x do
60466: LD_ADDR_VAR 0 4
60470: PUSH
60471: LD_VAR 0 11
60475: PUSH
60476: FOR_IN
60477: IFFALSE 60550
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
60479: LD_VAR 0 4
60483: PPUSH
60484: CALL_OW 264
60488: PUSH
60489: LD_INT 31
60491: EQUAL
60492: PUSH
60493: LD_VAR 0 4
60497: PPUSH
60498: CALL_OW 311
60502: NOT
60503: AND
60504: PUSH
60505: LD_VAR 0 4
60509: PPUSH
60510: CALL_OW 266
60514: PUSH
60515: LD_INT 36
60517: EQUAL
60518: PUSH
60519: LD_VAR 0 4
60523: PPUSH
60524: CALL_OW 313
60528: PUSH
60529: LD_INT 3
60531: LESS
60532: AND
60533: OR
60534: IFFALSE 60548
// begin ct := k ;
60536: LD_ADDR_VAR 0 8
60540: PUSH
60541: LD_VAR 0 4
60545: ST_TO_ADDR
// break ;
60546: GO 60550
// end ;
60548: GO 60476
60550: POP
60551: POP
// if ct then
60552: LD_VAR 0 8
60556: IFFALSE 60572
// ComEnterUnit ( j , ct ) ;
60558: LD_VAR 0 3
60562: PPUSH
60563: LD_VAR 0 8
60567: PPUSH
60568: CALL_OW 120
// end ; end ;
60572: GO 60207
60574: POP
60575: POP
// places := 0 ;
60576: LD_ADDR_VAR 0 5
60580: PUSH
60581: LD_INT 0
60583: ST_TO_ADDR
// for j = 1 to x do
60584: LD_ADDR_VAR 0 3
60588: PUSH
60589: DOUBLE
60590: LD_INT 1
60592: DEC
60593: ST_TO_ADDR
60594: LD_VAR 0 11
60598: PUSH
60599: FOR_TO
60600: IFFALSE 60676
// if GetWeapon ( x [ j ] ) = ar_control_tower then
60602: LD_VAR 0 11
60606: PUSH
60607: LD_VAR 0 3
60611: ARRAY
60612: PPUSH
60613: CALL_OW 264
60617: PUSH
60618: LD_INT 31
60620: EQUAL
60621: IFFALSE 60639
// places := places + 1 else
60623: LD_ADDR_VAR 0 5
60627: PUSH
60628: LD_VAR 0 5
60632: PUSH
60633: LD_INT 1
60635: PLUS
60636: ST_TO_ADDR
60637: GO 60674
// if GetBType ( x [ j ] ) = b_control_tower then
60639: LD_VAR 0 11
60643: PUSH
60644: LD_VAR 0 3
60648: ARRAY
60649: PPUSH
60650: CALL_OW 266
60654: PUSH
60655: LD_INT 36
60657: EQUAL
60658: IFFALSE 60674
// places := places + 3 ;
60660: LD_ADDR_VAR 0 5
60664: PUSH
60665: LD_VAR 0 5
60669: PUSH
60670: LD_INT 3
60672: PLUS
60673: ST_TO_ADDR
60674: GO 60599
60676: POP
60677: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
60678: LD_VAR 0 5
60682: PUSH
60683: LD_INT 0
60685: EQUAL
60686: PUSH
60687: LD_VAR 0 5
60691: PUSH
60692: LD_EXP 140
60696: PUSH
60697: LD_VAR 0 2
60701: ARRAY
60702: LESSEQUAL
60703: OR
60704: IFFALSE 60708
// continue ;
60706: GO 59958
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
60708: LD_ADDR_VAR 0 6
60712: PUSH
60713: LD_EXP 100
60717: PUSH
60718: LD_VAR 0 2
60722: ARRAY
60723: PPUSH
60724: LD_INT 25
60726: PUSH
60727: LD_INT 3
60729: PUSH
60730: EMPTY
60731: LIST
60732: LIST
60733: PPUSH
60734: CALL_OW 72
60738: PUSH
60739: LD_EXP 140
60743: PUSH
60744: LD_VAR 0 2
60748: ARRAY
60749: DIFF
60750: PPUSH
60751: LD_INT 3
60753: PPUSH
60754: CALL 104707 0 2
60758: ST_TO_ADDR
// for j in tmp do
60759: LD_ADDR_VAR 0 3
60763: PUSH
60764: LD_VAR 0 6
60768: PUSH
60769: FOR_IN
60770: IFFALSE 60805
// if GetTag ( j ) > 0 then
60772: LD_VAR 0 3
60776: PPUSH
60777: CALL_OW 110
60781: PUSH
60782: LD_INT 0
60784: GREATER
60785: IFFALSE 60803
// tmp := tmp diff j ;
60787: LD_ADDR_VAR 0 6
60791: PUSH
60792: LD_VAR 0 6
60796: PUSH
60797: LD_VAR 0 3
60801: DIFF
60802: ST_TO_ADDR
60803: GO 60769
60805: POP
60806: POP
// if not tmp then
60807: LD_VAR 0 6
60811: NOT
60812: IFFALSE 60816
// continue ;
60814: GO 59958
// if places then
60816: LD_VAR 0 5
60820: IFFALSE 60879
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
60822: LD_ADDR_EXP 140
60826: PUSH
60827: LD_EXP 140
60831: PPUSH
60832: LD_VAR 0 2
60836: PPUSH
60837: LD_EXP 140
60841: PUSH
60842: LD_VAR 0 2
60846: ARRAY
60847: PUSH
60848: LD_VAR 0 6
60852: PUSH
60853: LD_INT 1
60855: ARRAY
60856: UNION
60857: PPUSH
60858: CALL_OW 1
60862: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
60863: LD_VAR 0 6
60867: PUSH
60868: LD_INT 1
60870: ARRAY
60871: PPUSH
60872: LD_INT 126
60874: PPUSH
60875: CALL_OW 109
// end ; end ;
60879: GO 59958
60881: POP
60882: POP
// end ;
60883: LD_VAR 0 1
60887: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
60888: LD_INT 0
60890: PPUSH
60891: PPUSH
60892: PPUSH
60893: PPUSH
60894: PPUSH
60895: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
60896: LD_VAR 0 1
60900: NOT
60901: PUSH
60902: LD_VAR 0 2
60906: NOT
60907: OR
60908: PUSH
60909: LD_VAR 0 3
60913: NOT
60914: OR
60915: PUSH
60916: LD_VAR 0 4
60920: PUSH
60921: LD_INT 1
60923: PUSH
60924: LD_INT 2
60926: PUSH
60927: LD_INT 3
60929: PUSH
60930: LD_INT 4
60932: PUSH
60933: LD_INT 5
60935: PUSH
60936: LD_INT 8
60938: PUSH
60939: LD_INT 9
60941: PUSH
60942: LD_INT 15
60944: PUSH
60945: LD_INT 16
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: LIST
60952: LIST
60953: LIST
60954: LIST
60955: LIST
60956: LIST
60957: LIST
60958: IN
60959: NOT
60960: OR
60961: IFFALSE 60965
// exit ;
60963: GO 61823
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
60965: LD_ADDR_VAR 0 2
60969: PUSH
60970: LD_VAR 0 2
60974: PPUSH
60975: LD_INT 21
60977: PUSH
60978: LD_INT 3
60980: PUSH
60981: EMPTY
60982: LIST
60983: LIST
60984: PUSH
60985: LD_INT 24
60987: PUSH
60988: LD_INT 250
60990: PUSH
60991: EMPTY
60992: LIST
60993: LIST
60994: PUSH
60995: EMPTY
60996: LIST
60997: LIST
60998: PPUSH
60999: CALL_OW 72
61003: ST_TO_ADDR
// case class of 1 , 15 :
61004: LD_VAR 0 4
61008: PUSH
61009: LD_INT 1
61011: DOUBLE
61012: EQUAL
61013: IFTRUE 61023
61015: LD_INT 15
61017: DOUBLE
61018: EQUAL
61019: IFTRUE 61023
61021: GO 61108
61023: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
61024: LD_ADDR_VAR 0 8
61028: PUSH
61029: LD_VAR 0 2
61033: PPUSH
61034: LD_INT 2
61036: PUSH
61037: LD_INT 30
61039: PUSH
61040: LD_INT 32
61042: PUSH
61043: EMPTY
61044: LIST
61045: LIST
61046: PUSH
61047: LD_INT 30
61049: PUSH
61050: LD_INT 31
61052: PUSH
61053: EMPTY
61054: LIST
61055: LIST
61056: PUSH
61057: EMPTY
61058: LIST
61059: LIST
61060: LIST
61061: PPUSH
61062: CALL_OW 72
61066: PUSH
61067: LD_VAR 0 2
61071: PPUSH
61072: LD_INT 2
61074: PUSH
61075: LD_INT 30
61077: PUSH
61078: LD_INT 4
61080: PUSH
61081: EMPTY
61082: LIST
61083: LIST
61084: PUSH
61085: LD_INT 30
61087: PUSH
61088: LD_INT 5
61090: PUSH
61091: EMPTY
61092: LIST
61093: LIST
61094: PUSH
61095: EMPTY
61096: LIST
61097: LIST
61098: LIST
61099: PPUSH
61100: CALL_OW 72
61104: ADD
61105: ST_TO_ADDR
61106: GO 61354
61108: LD_INT 2
61110: DOUBLE
61111: EQUAL
61112: IFTRUE 61122
61114: LD_INT 16
61116: DOUBLE
61117: EQUAL
61118: IFTRUE 61122
61120: GO 61168
61122: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
61123: LD_ADDR_VAR 0 8
61127: PUSH
61128: LD_VAR 0 2
61132: PPUSH
61133: LD_INT 2
61135: PUSH
61136: LD_INT 30
61138: PUSH
61139: LD_INT 0
61141: PUSH
61142: EMPTY
61143: LIST
61144: LIST
61145: PUSH
61146: LD_INT 30
61148: PUSH
61149: LD_INT 1
61151: PUSH
61152: EMPTY
61153: LIST
61154: LIST
61155: PUSH
61156: EMPTY
61157: LIST
61158: LIST
61159: LIST
61160: PPUSH
61161: CALL_OW 72
61165: ST_TO_ADDR
61166: GO 61354
61168: LD_INT 3
61170: DOUBLE
61171: EQUAL
61172: IFTRUE 61176
61174: GO 61222
61176: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
61177: LD_ADDR_VAR 0 8
61181: PUSH
61182: LD_VAR 0 2
61186: PPUSH
61187: LD_INT 2
61189: PUSH
61190: LD_INT 30
61192: PUSH
61193: LD_INT 2
61195: PUSH
61196: EMPTY
61197: LIST
61198: LIST
61199: PUSH
61200: LD_INT 30
61202: PUSH
61203: LD_INT 3
61205: PUSH
61206: EMPTY
61207: LIST
61208: LIST
61209: PUSH
61210: EMPTY
61211: LIST
61212: LIST
61213: LIST
61214: PPUSH
61215: CALL_OW 72
61219: ST_TO_ADDR
61220: GO 61354
61222: LD_INT 4
61224: DOUBLE
61225: EQUAL
61226: IFTRUE 61230
61228: GO 61287
61230: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
61231: LD_ADDR_VAR 0 8
61235: PUSH
61236: LD_VAR 0 2
61240: PPUSH
61241: LD_INT 2
61243: PUSH
61244: LD_INT 30
61246: PUSH
61247: LD_INT 6
61249: PUSH
61250: EMPTY
61251: LIST
61252: LIST
61253: PUSH
61254: LD_INT 30
61256: PUSH
61257: LD_INT 7
61259: PUSH
61260: EMPTY
61261: LIST
61262: LIST
61263: PUSH
61264: LD_INT 30
61266: PUSH
61267: LD_INT 8
61269: PUSH
61270: EMPTY
61271: LIST
61272: LIST
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: LIST
61278: LIST
61279: PPUSH
61280: CALL_OW 72
61284: ST_TO_ADDR
61285: GO 61354
61287: LD_INT 5
61289: DOUBLE
61290: EQUAL
61291: IFTRUE 61307
61293: LD_INT 8
61295: DOUBLE
61296: EQUAL
61297: IFTRUE 61307
61299: LD_INT 9
61301: DOUBLE
61302: EQUAL
61303: IFTRUE 61307
61305: GO 61353
61307: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
61308: LD_ADDR_VAR 0 8
61312: PUSH
61313: LD_VAR 0 2
61317: PPUSH
61318: LD_INT 2
61320: PUSH
61321: LD_INT 30
61323: PUSH
61324: LD_INT 4
61326: PUSH
61327: EMPTY
61328: LIST
61329: LIST
61330: PUSH
61331: LD_INT 30
61333: PUSH
61334: LD_INT 5
61336: PUSH
61337: EMPTY
61338: LIST
61339: LIST
61340: PUSH
61341: EMPTY
61342: LIST
61343: LIST
61344: LIST
61345: PPUSH
61346: CALL_OW 72
61350: ST_TO_ADDR
61351: GO 61354
61353: POP
// if not tmp then
61354: LD_VAR 0 8
61358: NOT
61359: IFFALSE 61363
// exit ;
61361: GO 61823
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
61363: LD_VAR 0 4
61367: PUSH
61368: LD_INT 1
61370: PUSH
61371: LD_INT 15
61373: PUSH
61374: EMPTY
61375: LIST
61376: LIST
61377: IN
61378: PUSH
61379: LD_EXP 109
61383: PUSH
61384: LD_VAR 0 1
61388: ARRAY
61389: AND
61390: IFFALSE 61546
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
61392: LD_ADDR_VAR 0 9
61396: PUSH
61397: LD_EXP 109
61401: PUSH
61402: LD_VAR 0 1
61406: ARRAY
61407: PUSH
61408: LD_INT 1
61410: ARRAY
61411: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
61412: LD_VAR 0 9
61416: PUSH
61417: LD_EXP 110
61421: PUSH
61422: LD_VAR 0 1
61426: ARRAY
61427: IN
61428: NOT
61429: IFFALSE 61544
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
61431: LD_ADDR_EXP 110
61435: PUSH
61436: LD_EXP 110
61440: PPUSH
61441: LD_VAR 0 1
61445: PUSH
61446: LD_EXP 110
61450: PUSH
61451: LD_VAR 0 1
61455: ARRAY
61456: PUSH
61457: LD_INT 1
61459: PLUS
61460: PUSH
61461: EMPTY
61462: LIST
61463: LIST
61464: PPUSH
61465: LD_VAR 0 9
61469: PPUSH
61470: CALL 73860 0 3
61474: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
61475: LD_ADDR_EXP 109
61479: PUSH
61480: LD_EXP 109
61484: PPUSH
61485: LD_VAR 0 1
61489: PPUSH
61490: LD_EXP 109
61494: PUSH
61495: LD_VAR 0 1
61499: ARRAY
61500: PUSH
61501: LD_VAR 0 9
61505: DIFF
61506: PPUSH
61507: CALL_OW 1
61511: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
61512: LD_VAR 0 3
61516: PPUSH
61517: LD_EXP 110
61521: PUSH
61522: LD_VAR 0 1
61526: ARRAY
61527: PUSH
61528: LD_EXP 110
61532: PUSH
61533: LD_VAR 0 1
61537: ARRAY
61538: ARRAY
61539: PPUSH
61540: CALL_OW 120
// end ; exit ;
61544: GO 61823
// end ; if tmp > 1 then
61546: LD_VAR 0 8
61550: PUSH
61551: LD_INT 1
61553: GREATER
61554: IFFALSE 61658
// for i = 2 to tmp do
61556: LD_ADDR_VAR 0 6
61560: PUSH
61561: DOUBLE
61562: LD_INT 2
61564: DEC
61565: ST_TO_ADDR
61566: LD_VAR 0 8
61570: PUSH
61571: FOR_TO
61572: IFFALSE 61656
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
61574: LD_VAR 0 8
61578: PUSH
61579: LD_VAR 0 6
61583: ARRAY
61584: PPUSH
61585: CALL_OW 461
61589: PUSH
61590: LD_INT 6
61592: EQUAL
61593: IFFALSE 61654
// begin x := tmp [ i ] ;
61595: LD_ADDR_VAR 0 9
61599: PUSH
61600: LD_VAR 0 8
61604: PUSH
61605: LD_VAR 0 6
61609: ARRAY
61610: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
61611: LD_ADDR_VAR 0 8
61615: PUSH
61616: LD_VAR 0 8
61620: PPUSH
61621: LD_VAR 0 6
61625: PPUSH
61626: CALL_OW 3
61630: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
61631: LD_ADDR_VAR 0 8
61635: PUSH
61636: LD_VAR 0 8
61640: PPUSH
61641: LD_INT 1
61643: PPUSH
61644: LD_VAR 0 9
61648: PPUSH
61649: CALL_OW 2
61653: ST_TO_ADDR
// end ;
61654: GO 61571
61656: POP
61657: POP
// for i in tmp do
61658: LD_ADDR_VAR 0 6
61662: PUSH
61663: LD_VAR 0 8
61667: PUSH
61668: FOR_IN
61669: IFFALSE 61696
// begin if IsNotFull ( i ) then
61671: LD_VAR 0 6
61675: PPUSH
61676: CALL 71082 0 1
61680: IFFALSE 61694
// begin j := i ;
61682: LD_ADDR_VAR 0 7
61686: PUSH
61687: LD_VAR 0 6
61691: ST_TO_ADDR
// break ;
61692: GO 61696
// end ; end ;
61694: GO 61668
61696: POP
61697: POP
// if j then
61698: LD_VAR 0 7
61702: IFFALSE 61720
// ComEnterUnit ( unit , j ) else
61704: LD_VAR 0 3
61708: PPUSH
61709: LD_VAR 0 7
61713: PPUSH
61714: CALL_OW 120
61718: GO 61823
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61720: LD_ADDR_VAR 0 10
61724: PUSH
61725: LD_VAR 0 2
61729: PPUSH
61730: LD_INT 2
61732: PUSH
61733: LD_INT 30
61735: PUSH
61736: LD_INT 0
61738: PUSH
61739: EMPTY
61740: LIST
61741: LIST
61742: PUSH
61743: LD_INT 30
61745: PUSH
61746: LD_INT 1
61748: PUSH
61749: EMPTY
61750: LIST
61751: LIST
61752: PUSH
61753: EMPTY
61754: LIST
61755: LIST
61756: LIST
61757: PPUSH
61758: CALL_OW 72
61762: ST_TO_ADDR
// if depot then
61763: LD_VAR 0 10
61767: IFFALSE 61823
// begin depot := NearestUnitToUnit ( depot , unit ) ;
61769: LD_ADDR_VAR 0 10
61773: PUSH
61774: LD_VAR 0 10
61778: PPUSH
61779: LD_VAR 0 3
61783: PPUSH
61784: CALL_OW 74
61788: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
61789: LD_VAR 0 3
61793: PPUSH
61794: LD_VAR 0 10
61798: PPUSH
61799: CALL_OW 296
61803: PUSH
61804: LD_INT 10
61806: GREATER
61807: IFFALSE 61823
// ComStandNearbyBuilding ( unit , depot ) ;
61809: LD_VAR 0 3
61813: PPUSH
61814: LD_VAR 0 10
61818: PPUSH
61819: CALL 70462 0 2
// end ; end ; end ;
61823: LD_VAR 0 5
61827: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
61828: LD_INT 0
61830: PPUSH
61831: PPUSH
61832: PPUSH
61833: PPUSH
// if not mc_bases then
61834: LD_EXP 100
61838: NOT
61839: IFFALSE 61843
// exit ;
61841: GO 62082
// for i = 1 to mc_bases do
61843: LD_ADDR_VAR 0 2
61847: PUSH
61848: DOUBLE
61849: LD_INT 1
61851: DEC
61852: ST_TO_ADDR
61853: LD_EXP 100
61857: PUSH
61858: FOR_TO
61859: IFFALSE 62080
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
61861: LD_ADDR_VAR 0 4
61865: PUSH
61866: LD_EXP 100
61870: PUSH
61871: LD_VAR 0 2
61875: ARRAY
61876: PPUSH
61877: LD_INT 21
61879: PUSH
61880: LD_INT 1
61882: PUSH
61883: EMPTY
61884: LIST
61885: LIST
61886: PPUSH
61887: CALL_OW 72
61891: PUSH
61892: LD_EXP 129
61896: PUSH
61897: LD_VAR 0 2
61901: ARRAY
61902: UNION
61903: ST_TO_ADDR
// if not tmp then
61904: LD_VAR 0 4
61908: NOT
61909: IFFALSE 61913
// continue ;
61911: GO 61858
// for j in tmp do
61913: LD_ADDR_VAR 0 3
61917: PUSH
61918: LD_VAR 0 4
61922: PUSH
61923: FOR_IN
61924: IFFALSE 62076
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
61926: LD_VAR 0 3
61930: PPUSH
61931: CALL_OW 110
61935: NOT
61936: PUSH
61937: LD_VAR 0 3
61941: PPUSH
61942: CALL_OW 314
61946: NOT
61947: AND
61948: PUSH
61949: LD_VAR 0 3
61953: PPUSH
61954: CALL_OW 311
61958: NOT
61959: AND
61960: PUSH
61961: LD_VAR 0 3
61965: PPUSH
61966: CALL_OW 310
61970: NOT
61971: AND
61972: PUSH
61973: LD_VAR 0 3
61977: PUSH
61978: LD_EXP 103
61982: PUSH
61983: LD_VAR 0 2
61987: ARRAY
61988: PUSH
61989: LD_INT 1
61991: ARRAY
61992: IN
61993: NOT
61994: AND
61995: PUSH
61996: LD_VAR 0 3
62000: PUSH
62001: LD_EXP 103
62005: PUSH
62006: LD_VAR 0 2
62010: ARRAY
62011: PUSH
62012: LD_INT 2
62014: ARRAY
62015: IN
62016: NOT
62017: AND
62018: PUSH
62019: LD_VAR 0 3
62023: PUSH
62024: LD_EXP 112
62028: PUSH
62029: LD_VAR 0 2
62033: ARRAY
62034: IN
62035: NOT
62036: AND
62037: IFFALSE 62074
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
62039: LD_VAR 0 2
62043: PPUSH
62044: LD_EXP 100
62048: PUSH
62049: LD_VAR 0 2
62053: ARRAY
62054: PPUSH
62055: LD_VAR 0 3
62059: PPUSH
62060: LD_VAR 0 3
62064: PPUSH
62065: CALL_OW 257
62069: PPUSH
62070: CALL 60888 0 4
// end ;
62074: GO 61923
62076: POP
62077: POP
// end ;
62078: GO 61858
62080: POP
62081: POP
// end ;
62082: LD_VAR 0 1
62086: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
62087: LD_INT 0
62089: PPUSH
62090: PPUSH
62091: PPUSH
62092: PPUSH
62093: PPUSH
62094: PPUSH
// if not mc_bases [ base ] then
62095: LD_EXP 100
62099: PUSH
62100: LD_VAR 0 1
62104: ARRAY
62105: NOT
62106: IFFALSE 62110
// exit ;
62108: GO 62311
// tmp := [ ] ;
62110: LD_ADDR_VAR 0 6
62114: PUSH
62115: EMPTY
62116: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
62117: LD_ADDR_VAR 0 7
62121: PUSH
62122: LD_VAR 0 3
62126: PPUSH
62127: LD_INT 0
62129: PPUSH
62130: CALL_OW 517
62134: ST_TO_ADDR
// if not list then
62135: LD_VAR 0 7
62139: NOT
62140: IFFALSE 62144
// exit ;
62142: GO 62311
// c := Count ( list [ 1 ] ) ;
62144: LD_ADDR_VAR 0 9
62148: PUSH
62149: LD_VAR 0 7
62153: PUSH
62154: LD_INT 1
62156: ARRAY
62157: PPUSH
62158: CALL 71000 0 1
62162: ST_TO_ADDR
// if amount > c then
62163: LD_VAR 0 2
62167: PUSH
62168: LD_VAR 0 9
62172: GREATER
62173: IFFALSE 62185
// amount := c ;
62175: LD_ADDR_VAR 0 2
62179: PUSH
62180: LD_VAR 0 9
62184: ST_TO_ADDR
// for i := 1 to amount do
62185: LD_ADDR_VAR 0 5
62189: PUSH
62190: DOUBLE
62191: LD_INT 1
62193: DEC
62194: ST_TO_ADDR
62195: LD_VAR 0 2
62199: PUSH
62200: FOR_TO
62201: IFFALSE 62259
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
62203: LD_ADDR_VAR 0 6
62207: PUSH
62208: LD_VAR 0 6
62212: PPUSH
62213: LD_VAR 0 5
62217: PPUSH
62218: LD_VAR 0 7
62222: PUSH
62223: LD_INT 1
62225: ARRAY
62226: PUSH
62227: LD_VAR 0 5
62231: ARRAY
62232: PUSH
62233: LD_VAR 0 7
62237: PUSH
62238: LD_INT 2
62240: ARRAY
62241: PUSH
62242: LD_VAR 0 5
62246: ARRAY
62247: PUSH
62248: EMPTY
62249: LIST
62250: LIST
62251: PPUSH
62252: CALL_OW 1
62256: ST_TO_ADDR
62257: GO 62200
62259: POP
62260: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
62261: LD_ADDR_EXP 113
62265: PUSH
62266: LD_EXP 113
62270: PPUSH
62271: LD_VAR 0 1
62275: PPUSH
62276: LD_VAR 0 6
62280: PPUSH
62281: CALL_OW 1
62285: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
62286: LD_ADDR_EXP 115
62290: PUSH
62291: LD_EXP 115
62295: PPUSH
62296: LD_VAR 0 1
62300: PPUSH
62301: LD_VAR 0 3
62305: PPUSH
62306: CALL_OW 1
62310: ST_TO_ADDR
// end ;
62311: LD_VAR 0 4
62315: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
62316: LD_INT 0
62318: PPUSH
// if not mc_bases [ base ] then
62319: LD_EXP 100
62323: PUSH
62324: LD_VAR 0 1
62328: ARRAY
62329: NOT
62330: IFFALSE 62334
// exit ;
62332: GO 62359
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
62334: LD_ADDR_EXP 105
62338: PUSH
62339: LD_EXP 105
62343: PPUSH
62344: LD_VAR 0 1
62348: PPUSH
62349: LD_VAR 0 2
62353: PPUSH
62354: CALL_OW 1
62358: ST_TO_ADDR
// end ;
62359: LD_VAR 0 3
62363: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
62364: LD_INT 0
62366: PPUSH
// if not mc_bases [ base ] then
62367: LD_EXP 100
62371: PUSH
62372: LD_VAR 0 1
62376: ARRAY
62377: NOT
62378: IFFALSE 62382
// exit ;
62380: GO 62419
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
62382: LD_ADDR_EXP 105
62386: PUSH
62387: LD_EXP 105
62391: PPUSH
62392: LD_VAR 0 1
62396: PPUSH
62397: LD_EXP 105
62401: PUSH
62402: LD_VAR 0 1
62406: ARRAY
62407: PUSH
62408: LD_VAR 0 2
62412: UNION
62413: PPUSH
62414: CALL_OW 1
62418: ST_TO_ADDR
// end ;
62419: LD_VAR 0 3
62423: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
62424: LD_INT 0
62426: PPUSH
// if not mc_bases [ base ] then
62427: LD_EXP 100
62431: PUSH
62432: LD_VAR 0 1
62436: ARRAY
62437: NOT
62438: IFFALSE 62442
// exit ;
62440: GO 62467
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
62442: LD_ADDR_EXP 121
62446: PUSH
62447: LD_EXP 121
62451: PPUSH
62452: LD_VAR 0 1
62456: PPUSH
62457: LD_VAR 0 2
62461: PPUSH
62462: CALL_OW 1
62466: ST_TO_ADDR
// end ;
62467: LD_VAR 0 3
62471: RET
// export function MC_InsertProduceList ( base , components ) ; begin
62472: LD_INT 0
62474: PPUSH
// if not mc_bases [ base ] then
62475: LD_EXP 100
62479: PUSH
62480: LD_VAR 0 1
62484: ARRAY
62485: NOT
62486: IFFALSE 62490
// exit ;
62488: GO 62527
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
62490: LD_ADDR_EXP 121
62494: PUSH
62495: LD_EXP 121
62499: PPUSH
62500: LD_VAR 0 1
62504: PPUSH
62505: LD_EXP 121
62509: PUSH
62510: LD_VAR 0 1
62514: ARRAY
62515: PUSH
62516: LD_VAR 0 2
62520: ADD
62521: PPUSH
62522: CALL_OW 1
62526: ST_TO_ADDR
// end ;
62527: LD_VAR 0 3
62531: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
62532: LD_INT 0
62534: PPUSH
// if not mc_bases [ base ] then
62535: LD_EXP 100
62539: PUSH
62540: LD_VAR 0 1
62544: ARRAY
62545: NOT
62546: IFFALSE 62550
// exit ;
62548: GO 62604
// mc_defender := Replace ( mc_defender , base , deflist ) ;
62550: LD_ADDR_EXP 122
62554: PUSH
62555: LD_EXP 122
62559: PPUSH
62560: LD_VAR 0 1
62564: PPUSH
62565: LD_VAR 0 2
62569: PPUSH
62570: CALL_OW 1
62574: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
62575: LD_ADDR_EXP 111
62579: PUSH
62580: LD_EXP 111
62584: PPUSH
62585: LD_VAR 0 1
62589: PPUSH
62590: LD_VAR 0 2
62594: PUSH
62595: LD_INT 0
62597: PLUS
62598: PPUSH
62599: CALL_OW 1
62603: ST_TO_ADDR
// end ;
62604: LD_VAR 0 3
62608: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
62609: LD_INT 0
62611: PPUSH
// if not mc_bases [ base ] then
62612: LD_EXP 100
62616: PUSH
62617: LD_VAR 0 1
62621: ARRAY
62622: NOT
62623: IFFALSE 62627
// exit ;
62625: GO 62652
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
62627: LD_ADDR_EXP 111
62631: PUSH
62632: LD_EXP 111
62636: PPUSH
62637: LD_VAR 0 1
62641: PPUSH
62642: LD_VAR 0 2
62646: PPUSH
62647: CALL_OW 1
62651: ST_TO_ADDR
// end ;
62652: LD_VAR 0 3
62656: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
62657: LD_INT 0
62659: PPUSH
62660: PPUSH
62661: PPUSH
62662: PPUSH
// if not mc_bases [ base ] then
62663: LD_EXP 100
62667: PUSH
62668: LD_VAR 0 1
62672: ARRAY
62673: NOT
62674: IFFALSE 62678
// exit ;
62676: GO 62743
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
62678: LD_ADDR_EXP 120
62682: PUSH
62683: LD_EXP 120
62687: PPUSH
62688: LD_VAR 0 1
62692: PUSH
62693: LD_EXP 120
62697: PUSH
62698: LD_VAR 0 1
62702: ARRAY
62703: PUSH
62704: LD_INT 1
62706: PLUS
62707: PUSH
62708: EMPTY
62709: LIST
62710: LIST
62711: PPUSH
62712: LD_VAR 0 1
62716: PUSH
62717: LD_VAR 0 2
62721: PUSH
62722: LD_VAR 0 3
62726: PUSH
62727: LD_VAR 0 4
62731: PUSH
62732: EMPTY
62733: LIST
62734: LIST
62735: LIST
62736: LIST
62737: PPUSH
62738: CALL 73860 0 3
62742: ST_TO_ADDR
// end ;
62743: LD_VAR 0 5
62747: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
62748: LD_INT 0
62750: PPUSH
// if not mc_bases [ base ] then
62751: LD_EXP 100
62755: PUSH
62756: LD_VAR 0 1
62760: ARRAY
62761: NOT
62762: IFFALSE 62766
// exit ;
62764: GO 62791
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
62766: LD_ADDR_EXP 137
62770: PUSH
62771: LD_EXP 137
62775: PPUSH
62776: LD_VAR 0 1
62780: PPUSH
62781: LD_VAR 0 2
62785: PPUSH
62786: CALL_OW 1
62790: ST_TO_ADDR
// end ;
62791: LD_VAR 0 3
62795: RET
// export function MC_GetMinesField ( base ) ; begin
62796: LD_INT 0
62798: PPUSH
// result := mc_mines [ base ] ;
62799: LD_ADDR_VAR 0 2
62803: PUSH
62804: LD_EXP 113
62808: PUSH
62809: LD_VAR 0 1
62813: ARRAY
62814: ST_TO_ADDR
// end ;
62815: LD_VAR 0 2
62819: RET
// export function MC_GetProduceList ( base ) ; begin
62820: LD_INT 0
62822: PPUSH
// result := mc_produce [ base ] ;
62823: LD_ADDR_VAR 0 2
62827: PUSH
62828: LD_EXP 121
62832: PUSH
62833: LD_VAR 0 1
62837: ARRAY
62838: ST_TO_ADDR
// end ;
62839: LD_VAR 0 2
62843: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
62844: LD_INT 0
62846: PPUSH
62847: PPUSH
// if not mc_bases then
62848: LD_EXP 100
62852: NOT
62853: IFFALSE 62857
// exit ;
62855: GO 62922
// if mc_bases [ base ] then
62857: LD_EXP 100
62861: PUSH
62862: LD_VAR 0 1
62866: ARRAY
62867: IFFALSE 62922
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
62869: LD_ADDR_VAR 0 3
62873: PUSH
62874: LD_EXP 100
62878: PUSH
62879: LD_VAR 0 1
62883: ARRAY
62884: PPUSH
62885: LD_INT 30
62887: PUSH
62888: LD_VAR 0 2
62892: PUSH
62893: EMPTY
62894: LIST
62895: LIST
62896: PPUSH
62897: CALL_OW 72
62901: ST_TO_ADDR
// if result then
62902: LD_VAR 0 3
62906: IFFALSE 62922
// result := result [ 1 ] ;
62908: LD_ADDR_VAR 0 3
62912: PUSH
62913: LD_VAR 0 3
62917: PUSH
62918: LD_INT 1
62920: ARRAY
62921: ST_TO_ADDR
// end ; end ;
62922: LD_VAR 0 3
62926: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
62927: LD_INT 0
62929: PPUSH
62930: PPUSH
// if not mc_bases then
62931: LD_EXP 100
62935: NOT
62936: IFFALSE 62940
// exit ;
62938: GO 62985
// if mc_bases [ base ] then
62940: LD_EXP 100
62944: PUSH
62945: LD_VAR 0 1
62949: ARRAY
62950: IFFALSE 62985
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
62952: LD_ADDR_VAR 0 3
62956: PUSH
62957: LD_EXP 100
62961: PUSH
62962: LD_VAR 0 1
62966: ARRAY
62967: PPUSH
62968: LD_INT 30
62970: PUSH
62971: LD_VAR 0 2
62975: PUSH
62976: EMPTY
62977: LIST
62978: LIST
62979: PPUSH
62980: CALL_OW 72
62984: ST_TO_ADDR
// end ;
62985: LD_VAR 0 3
62989: RET
// export function MC_SetTame ( base , area ) ; begin
62990: LD_INT 0
62992: PPUSH
// if not mc_bases or not base then
62993: LD_EXP 100
62997: NOT
62998: PUSH
62999: LD_VAR 0 1
63003: NOT
63004: OR
63005: IFFALSE 63009
// exit ;
63007: GO 63034
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
63009: LD_ADDR_EXP 128
63013: PUSH
63014: LD_EXP 128
63018: PPUSH
63019: LD_VAR 0 1
63023: PPUSH
63024: LD_VAR 0 2
63028: PPUSH
63029: CALL_OW 1
63033: ST_TO_ADDR
// end ;
63034: LD_VAR 0 3
63038: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
63039: LD_INT 0
63041: PPUSH
63042: PPUSH
// if not mc_bases or not base then
63043: LD_EXP 100
63047: NOT
63048: PUSH
63049: LD_VAR 0 1
63053: NOT
63054: OR
63055: IFFALSE 63059
// exit ;
63057: GO 63161
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
63059: LD_ADDR_VAR 0 4
63063: PUSH
63064: LD_EXP 100
63068: PUSH
63069: LD_VAR 0 1
63073: ARRAY
63074: PPUSH
63075: LD_INT 30
63077: PUSH
63078: LD_VAR 0 2
63082: PUSH
63083: EMPTY
63084: LIST
63085: LIST
63086: PPUSH
63087: CALL_OW 72
63091: ST_TO_ADDR
// if not tmp then
63092: LD_VAR 0 4
63096: NOT
63097: IFFALSE 63101
// exit ;
63099: GO 63161
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
63101: LD_ADDR_EXP 132
63105: PUSH
63106: LD_EXP 132
63110: PPUSH
63111: LD_VAR 0 1
63115: PPUSH
63116: LD_EXP 132
63120: PUSH
63121: LD_VAR 0 1
63125: ARRAY
63126: PPUSH
63127: LD_EXP 132
63131: PUSH
63132: LD_VAR 0 1
63136: ARRAY
63137: PUSH
63138: LD_INT 1
63140: PLUS
63141: PPUSH
63142: LD_VAR 0 4
63146: PUSH
63147: LD_INT 1
63149: ARRAY
63150: PPUSH
63151: CALL_OW 2
63155: PPUSH
63156: CALL_OW 1
63160: ST_TO_ADDR
// end ;
63161: LD_VAR 0 3
63165: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
63166: LD_INT 0
63168: PPUSH
63169: PPUSH
// if not mc_bases or not base or not kinds then
63170: LD_EXP 100
63174: NOT
63175: PUSH
63176: LD_VAR 0 1
63180: NOT
63181: OR
63182: PUSH
63183: LD_VAR 0 2
63187: NOT
63188: OR
63189: IFFALSE 63193
// exit ;
63191: GO 63254
// for i in kinds do
63193: LD_ADDR_VAR 0 4
63197: PUSH
63198: LD_VAR 0 2
63202: PUSH
63203: FOR_IN
63204: IFFALSE 63252
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
63206: LD_ADDR_EXP 134
63210: PUSH
63211: LD_EXP 134
63215: PPUSH
63216: LD_VAR 0 1
63220: PUSH
63221: LD_EXP 134
63225: PUSH
63226: LD_VAR 0 1
63230: ARRAY
63231: PUSH
63232: LD_INT 1
63234: PLUS
63235: PUSH
63236: EMPTY
63237: LIST
63238: LIST
63239: PPUSH
63240: LD_VAR 0 4
63244: PPUSH
63245: CALL 73860 0 3
63249: ST_TO_ADDR
63250: GO 63203
63252: POP
63253: POP
// end ;
63254: LD_VAR 0 3
63258: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
63259: LD_INT 0
63261: PPUSH
// if not mc_bases or not base or not areas then
63262: LD_EXP 100
63266: NOT
63267: PUSH
63268: LD_VAR 0 1
63272: NOT
63273: OR
63274: PUSH
63275: LD_VAR 0 2
63279: NOT
63280: OR
63281: IFFALSE 63285
// exit ;
63283: GO 63310
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
63285: LD_ADDR_EXP 118
63289: PUSH
63290: LD_EXP 118
63294: PPUSH
63295: LD_VAR 0 1
63299: PPUSH
63300: LD_VAR 0 2
63304: PPUSH
63305: CALL_OW 1
63309: ST_TO_ADDR
// end ;
63310: LD_VAR 0 3
63314: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
63315: LD_INT 0
63317: PPUSH
// if not mc_bases or not base or not teleports_exit then
63318: LD_EXP 100
63322: NOT
63323: PUSH
63324: LD_VAR 0 1
63328: NOT
63329: OR
63330: PUSH
63331: LD_VAR 0 2
63335: NOT
63336: OR
63337: IFFALSE 63341
// exit ;
63339: GO 63366
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
63341: LD_ADDR_EXP 135
63345: PUSH
63346: LD_EXP 135
63350: PPUSH
63351: LD_VAR 0 1
63355: PPUSH
63356: LD_VAR 0 2
63360: PPUSH
63361: CALL_OW 1
63365: ST_TO_ADDR
// end ;
63366: LD_VAR 0 3
63370: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
63371: LD_INT 0
63373: PPUSH
63374: PPUSH
63375: PPUSH
// if not mc_bases or not base or not ext_list then
63376: LD_EXP 100
63380: NOT
63381: PUSH
63382: LD_VAR 0 1
63386: NOT
63387: OR
63388: PUSH
63389: LD_VAR 0 5
63393: NOT
63394: OR
63395: IFFALSE 63399
// exit ;
63397: GO 63572
// tmp := GetFacExtXYD ( x , y , d ) ;
63399: LD_ADDR_VAR 0 8
63403: PUSH
63404: LD_VAR 0 2
63408: PPUSH
63409: LD_VAR 0 3
63413: PPUSH
63414: LD_VAR 0 4
63418: PPUSH
63419: CALL 103837 0 3
63423: ST_TO_ADDR
// if not tmp then
63424: LD_VAR 0 8
63428: NOT
63429: IFFALSE 63433
// exit ;
63431: GO 63572
// for i in tmp do
63433: LD_ADDR_VAR 0 7
63437: PUSH
63438: LD_VAR 0 8
63442: PUSH
63443: FOR_IN
63444: IFFALSE 63570
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
63446: LD_ADDR_EXP 105
63450: PUSH
63451: LD_EXP 105
63455: PPUSH
63456: LD_VAR 0 1
63460: PPUSH
63461: LD_EXP 105
63465: PUSH
63466: LD_VAR 0 1
63470: ARRAY
63471: PPUSH
63472: LD_EXP 105
63476: PUSH
63477: LD_VAR 0 1
63481: ARRAY
63482: PUSH
63483: LD_INT 1
63485: PLUS
63486: PPUSH
63487: LD_VAR 0 5
63491: PUSH
63492: LD_INT 1
63494: ARRAY
63495: PUSH
63496: LD_VAR 0 7
63500: PUSH
63501: LD_INT 1
63503: ARRAY
63504: PUSH
63505: LD_VAR 0 7
63509: PUSH
63510: LD_INT 2
63512: ARRAY
63513: PUSH
63514: LD_VAR 0 7
63518: PUSH
63519: LD_INT 3
63521: ARRAY
63522: PUSH
63523: EMPTY
63524: LIST
63525: LIST
63526: LIST
63527: LIST
63528: PPUSH
63529: CALL_OW 2
63533: PPUSH
63534: CALL_OW 1
63538: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
63539: LD_ADDR_VAR 0 5
63543: PUSH
63544: LD_VAR 0 5
63548: PPUSH
63549: LD_INT 1
63551: PPUSH
63552: CALL_OW 3
63556: ST_TO_ADDR
// if not ext_list then
63557: LD_VAR 0 5
63561: NOT
63562: IFFALSE 63568
// exit ;
63564: POP
63565: POP
63566: GO 63572
// end ;
63568: GO 63443
63570: POP
63571: POP
// end ;
63572: LD_VAR 0 6
63576: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
63577: LD_INT 0
63579: PPUSH
// if not mc_bases or not base or not weapon_list then
63580: LD_EXP 100
63584: NOT
63585: PUSH
63586: LD_VAR 0 1
63590: NOT
63591: OR
63592: PUSH
63593: LD_VAR 0 2
63597: NOT
63598: OR
63599: IFFALSE 63603
// exit ;
63601: GO 63628
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
63603: LD_ADDR_EXP 139
63607: PUSH
63608: LD_EXP 139
63612: PPUSH
63613: LD_VAR 0 1
63617: PPUSH
63618: LD_VAR 0 2
63622: PPUSH
63623: CALL_OW 1
63627: ST_TO_ADDR
// end ;
63628: LD_VAR 0 3
63632: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
63633: LD_INT 0
63635: PPUSH
// if not mc_bases or not base or not tech_list then
63636: LD_EXP 100
63640: NOT
63641: PUSH
63642: LD_VAR 0 1
63646: NOT
63647: OR
63648: PUSH
63649: LD_VAR 0 2
63653: NOT
63654: OR
63655: IFFALSE 63659
// exit ;
63657: GO 63684
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
63659: LD_ADDR_EXP 127
63663: PUSH
63664: LD_EXP 127
63668: PPUSH
63669: LD_VAR 0 1
63673: PPUSH
63674: LD_VAR 0 2
63678: PPUSH
63679: CALL_OW 1
63683: ST_TO_ADDR
// end ;
63684: LD_VAR 0 3
63688: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
63689: LD_INT 0
63691: PPUSH
// if not mc_bases or not parking_area or not base then
63692: LD_EXP 100
63696: NOT
63697: PUSH
63698: LD_VAR 0 2
63702: NOT
63703: OR
63704: PUSH
63705: LD_VAR 0 1
63709: NOT
63710: OR
63711: IFFALSE 63715
// exit ;
63713: GO 63740
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
63715: LD_ADDR_EXP 124
63719: PUSH
63720: LD_EXP 124
63724: PPUSH
63725: LD_VAR 0 1
63729: PPUSH
63730: LD_VAR 0 2
63734: PPUSH
63735: CALL_OW 1
63739: ST_TO_ADDR
// end ;
63740: LD_VAR 0 3
63744: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
63745: LD_INT 0
63747: PPUSH
// if not mc_bases or not base or not scan_area then
63748: LD_EXP 100
63752: NOT
63753: PUSH
63754: LD_VAR 0 1
63758: NOT
63759: OR
63760: PUSH
63761: LD_VAR 0 2
63765: NOT
63766: OR
63767: IFFALSE 63771
// exit ;
63769: GO 63796
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
63771: LD_ADDR_EXP 125
63775: PUSH
63776: LD_EXP 125
63780: PPUSH
63781: LD_VAR 0 1
63785: PPUSH
63786: LD_VAR 0 2
63790: PPUSH
63791: CALL_OW 1
63795: ST_TO_ADDR
// end ;
63796: LD_VAR 0 3
63800: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
63801: LD_INT 0
63803: PPUSH
63804: PPUSH
// if not mc_bases or not base then
63805: LD_EXP 100
63809: NOT
63810: PUSH
63811: LD_VAR 0 1
63815: NOT
63816: OR
63817: IFFALSE 63821
// exit ;
63819: GO 63885
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
63821: LD_ADDR_VAR 0 3
63825: PUSH
63826: LD_INT 1
63828: PUSH
63829: LD_INT 2
63831: PUSH
63832: LD_INT 3
63834: PUSH
63835: LD_INT 4
63837: PUSH
63838: LD_INT 11
63840: PUSH
63841: EMPTY
63842: LIST
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
63848: LD_ADDR_EXP 127
63852: PUSH
63853: LD_EXP 127
63857: PPUSH
63858: LD_VAR 0 1
63862: PPUSH
63863: LD_EXP 127
63867: PUSH
63868: LD_VAR 0 1
63872: ARRAY
63873: PUSH
63874: LD_VAR 0 3
63878: DIFF
63879: PPUSH
63880: CALL_OW 1
63884: ST_TO_ADDR
// end ;
63885: LD_VAR 0 2
63889: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
63890: LD_INT 0
63892: PPUSH
// result := mc_vehicles [ base ] ;
63893: LD_ADDR_VAR 0 3
63897: PUSH
63898: LD_EXP 119
63902: PUSH
63903: LD_VAR 0 1
63907: ARRAY
63908: ST_TO_ADDR
// if onlyCombat then
63909: LD_VAR 0 2
63913: IFFALSE 64085
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
63915: LD_ADDR_VAR 0 3
63919: PUSH
63920: LD_VAR 0 3
63924: PUSH
63925: LD_VAR 0 3
63929: PPUSH
63930: LD_INT 2
63932: PUSH
63933: LD_INT 34
63935: PUSH
63936: LD_INT 12
63938: PUSH
63939: EMPTY
63940: LIST
63941: LIST
63942: PUSH
63943: LD_INT 34
63945: PUSH
63946: LD_INT 51
63948: PUSH
63949: EMPTY
63950: LIST
63951: LIST
63952: PUSH
63953: LD_INT 34
63955: PUSH
63956: LD_INT 89
63958: PUSH
63959: EMPTY
63960: LIST
63961: LIST
63962: PUSH
63963: LD_INT 34
63965: PUSH
63966: LD_INT 32
63968: PUSH
63969: EMPTY
63970: LIST
63971: LIST
63972: PUSH
63973: LD_INT 34
63975: PUSH
63976: LD_INT 13
63978: PUSH
63979: EMPTY
63980: LIST
63981: LIST
63982: PUSH
63983: LD_INT 34
63985: PUSH
63986: LD_INT 52
63988: PUSH
63989: EMPTY
63990: LIST
63991: LIST
63992: PUSH
63993: LD_INT 34
63995: PUSH
63996: LD_INT 88
63998: PUSH
63999: EMPTY
64000: LIST
64001: LIST
64002: PUSH
64003: LD_INT 34
64005: PUSH
64006: LD_INT 14
64008: PUSH
64009: EMPTY
64010: LIST
64011: LIST
64012: PUSH
64013: LD_INT 34
64015: PUSH
64016: LD_INT 53
64018: PUSH
64019: EMPTY
64020: LIST
64021: LIST
64022: PUSH
64023: LD_INT 34
64025: PUSH
64026: LD_INT 98
64028: PUSH
64029: EMPTY
64030: LIST
64031: LIST
64032: PUSH
64033: LD_INT 34
64035: PUSH
64036: LD_INT 31
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: PUSH
64043: LD_INT 34
64045: PUSH
64046: LD_INT 48
64048: PUSH
64049: EMPTY
64050: LIST
64051: LIST
64052: PUSH
64053: LD_INT 34
64055: PUSH
64056: LD_INT 8
64058: PUSH
64059: EMPTY
64060: LIST
64061: LIST
64062: PUSH
64063: EMPTY
64064: LIST
64065: LIST
64066: LIST
64067: LIST
64068: LIST
64069: LIST
64070: LIST
64071: LIST
64072: LIST
64073: LIST
64074: LIST
64075: LIST
64076: LIST
64077: LIST
64078: PPUSH
64079: CALL_OW 72
64083: DIFF
64084: ST_TO_ADDR
// end ; end_of_file
64085: LD_VAR 0 3
64089: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
64090: LD_INT 0
64092: PPUSH
64093: PPUSH
64094: PPUSH
// if not mc_bases or not skirmish then
64095: LD_EXP 100
64099: NOT
64100: PUSH
64101: LD_EXP 98
64105: NOT
64106: OR
64107: IFFALSE 64111
// exit ;
64109: GO 64276
// for i = 1 to mc_bases do
64111: LD_ADDR_VAR 0 4
64115: PUSH
64116: DOUBLE
64117: LD_INT 1
64119: DEC
64120: ST_TO_ADDR
64121: LD_EXP 100
64125: PUSH
64126: FOR_TO
64127: IFFALSE 64274
// begin if sci in mc_bases [ i ] then
64129: LD_VAR 0 2
64133: PUSH
64134: LD_EXP 100
64138: PUSH
64139: LD_VAR 0 4
64143: ARRAY
64144: IN
64145: IFFALSE 64272
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
64147: LD_ADDR_EXP 129
64151: PUSH
64152: LD_EXP 129
64156: PPUSH
64157: LD_VAR 0 4
64161: PUSH
64162: LD_EXP 129
64166: PUSH
64167: LD_VAR 0 4
64171: ARRAY
64172: PUSH
64173: LD_INT 1
64175: PLUS
64176: PUSH
64177: EMPTY
64178: LIST
64179: LIST
64180: PPUSH
64181: LD_VAR 0 1
64185: PPUSH
64186: CALL 73860 0 3
64190: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
64191: LD_ADDR_VAR 0 5
64195: PUSH
64196: LD_EXP 100
64200: PUSH
64201: LD_VAR 0 4
64205: ARRAY
64206: PPUSH
64207: LD_INT 2
64209: PUSH
64210: LD_INT 30
64212: PUSH
64213: LD_INT 0
64215: PUSH
64216: EMPTY
64217: LIST
64218: LIST
64219: PUSH
64220: LD_INT 30
64222: PUSH
64223: LD_INT 1
64225: PUSH
64226: EMPTY
64227: LIST
64228: LIST
64229: PUSH
64230: EMPTY
64231: LIST
64232: LIST
64233: LIST
64234: PPUSH
64235: CALL_OW 72
64239: PPUSH
64240: LD_VAR 0 1
64244: PPUSH
64245: CALL_OW 74
64249: ST_TO_ADDR
// if tmp then
64250: LD_VAR 0 5
64254: IFFALSE 64270
// ComStandNearbyBuilding ( ape , tmp ) ;
64256: LD_VAR 0 1
64260: PPUSH
64261: LD_VAR 0 5
64265: PPUSH
64266: CALL 70462 0 2
// break ;
64270: GO 64274
// end ; end ;
64272: GO 64126
64274: POP
64275: POP
// end ;
64276: LD_VAR 0 3
64280: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
64281: LD_INT 0
64283: PPUSH
64284: PPUSH
64285: PPUSH
// if not mc_bases or not skirmish then
64286: LD_EXP 100
64290: NOT
64291: PUSH
64292: LD_EXP 98
64296: NOT
64297: OR
64298: IFFALSE 64302
// exit ;
64300: GO 64391
// for i = 1 to mc_bases do
64302: LD_ADDR_VAR 0 4
64306: PUSH
64307: DOUBLE
64308: LD_INT 1
64310: DEC
64311: ST_TO_ADDR
64312: LD_EXP 100
64316: PUSH
64317: FOR_TO
64318: IFFALSE 64389
// begin if building in mc_busy_turret_list [ i ] then
64320: LD_VAR 0 1
64324: PUSH
64325: LD_EXP 110
64329: PUSH
64330: LD_VAR 0 4
64334: ARRAY
64335: IN
64336: IFFALSE 64387
// begin tmp := mc_busy_turret_list [ i ] diff building ;
64338: LD_ADDR_VAR 0 5
64342: PUSH
64343: LD_EXP 110
64347: PUSH
64348: LD_VAR 0 4
64352: ARRAY
64353: PUSH
64354: LD_VAR 0 1
64358: DIFF
64359: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
64360: LD_ADDR_EXP 110
64364: PUSH
64365: LD_EXP 110
64369: PPUSH
64370: LD_VAR 0 4
64374: PPUSH
64375: LD_VAR 0 5
64379: PPUSH
64380: CALL_OW 1
64384: ST_TO_ADDR
// break ;
64385: GO 64389
// end ; end ;
64387: GO 64317
64389: POP
64390: POP
// end ;
64391: LD_VAR 0 3
64395: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
64396: LD_INT 0
64398: PPUSH
64399: PPUSH
64400: PPUSH
// if not mc_bases or not skirmish then
64401: LD_EXP 100
64405: NOT
64406: PUSH
64407: LD_EXP 98
64411: NOT
64412: OR
64413: IFFALSE 64417
// exit ;
64415: GO 64616
// for i = 1 to mc_bases do
64417: LD_ADDR_VAR 0 5
64421: PUSH
64422: DOUBLE
64423: LD_INT 1
64425: DEC
64426: ST_TO_ADDR
64427: LD_EXP 100
64431: PUSH
64432: FOR_TO
64433: IFFALSE 64614
// if building in mc_bases [ i ] then
64435: LD_VAR 0 1
64439: PUSH
64440: LD_EXP 100
64444: PUSH
64445: LD_VAR 0 5
64449: ARRAY
64450: IN
64451: IFFALSE 64612
// begin tmp := mc_bases [ i ] diff building ;
64453: LD_ADDR_VAR 0 6
64457: PUSH
64458: LD_EXP 100
64462: PUSH
64463: LD_VAR 0 5
64467: ARRAY
64468: PUSH
64469: LD_VAR 0 1
64473: DIFF
64474: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
64475: LD_ADDR_EXP 100
64479: PUSH
64480: LD_EXP 100
64484: PPUSH
64485: LD_VAR 0 5
64489: PPUSH
64490: LD_VAR 0 6
64494: PPUSH
64495: CALL_OW 1
64499: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
64500: LD_VAR 0 1
64504: PUSH
64505: LD_EXP 108
64509: PUSH
64510: LD_VAR 0 5
64514: ARRAY
64515: IN
64516: IFFALSE 64555
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
64518: LD_ADDR_EXP 108
64522: PUSH
64523: LD_EXP 108
64527: PPUSH
64528: LD_VAR 0 5
64532: PPUSH
64533: LD_EXP 108
64537: PUSH
64538: LD_VAR 0 5
64542: ARRAY
64543: PUSH
64544: LD_VAR 0 1
64548: DIFF
64549: PPUSH
64550: CALL_OW 1
64554: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
64555: LD_VAR 0 1
64559: PUSH
64560: LD_EXP 109
64564: PUSH
64565: LD_VAR 0 5
64569: ARRAY
64570: IN
64571: IFFALSE 64610
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
64573: LD_ADDR_EXP 109
64577: PUSH
64578: LD_EXP 109
64582: PPUSH
64583: LD_VAR 0 5
64587: PPUSH
64588: LD_EXP 109
64592: PUSH
64593: LD_VAR 0 5
64597: ARRAY
64598: PUSH
64599: LD_VAR 0 1
64603: DIFF
64604: PPUSH
64605: CALL_OW 1
64609: ST_TO_ADDR
// break ;
64610: GO 64614
// end ;
64612: GO 64432
64614: POP
64615: POP
// end ;
64616: LD_VAR 0 4
64620: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
64621: LD_INT 0
64623: PPUSH
64624: PPUSH
64625: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
64626: LD_EXP 100
64630: NOT
64631: PUSH
64632: LD_EXP 98
64636: NOT
64637: OR
64638: PUSH
64639: LD_VAR 0 3
64643: PUSH
64644: LD_EXP 126
64648: IN
64649: NOT
64650: OR
64651: IFFALSE 64655
// exit ;
64653: GO 64778
// for i = 1 to mc_vehicles do
64655: LD_ADDR_VAR 0 6
64659: PUSH
64660: DOUBLE
64661: LD_INT 1
64663: DEC
64664: ST_TO_ADDR
64665: LD_EXP 119
64669: PUSH
64670: FOR_TO
64671: IFFALSE 64776
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
64673: LD_VAR 0 2
64677: PUSH
64678: LD_EXP 119
64682: PUSH
64683: LD_VAR 0 6
64687: ARRAY
64688: IN
64689: PUSH
64690: LD_VAR 0 1
64694: PUSH
64695: LD_EXP 119
64699: PUSH
64700: LD_VAR 0 6
64704: ARRAY
64705: IN
64706: OR
64707: IFFALSE 64774
// begin tmp := mc_vehicles [ i ] diff old ;
64709: LD_ADDR_VAR 0 7
64713: PUSH
64714: LD_EXP 119
64718: PUSH
64719: LD_VAR 0 6
64723: ARRAY
64724: PUSH
64725: LD_VAR 0 2
64729: DIFF
64730: ST_TO_ADDR
// tmp := tmp diff new ;
64731: LD_ADDR_VAR 0 7
64735: PUSH
64736: LD_VAR 0 7
64740: PUSH
64741: LD_VAR 0 1
64745: DIFF
64746: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
64747: LD_ADDR_EXP 119
64751: PUSH
64752: LD_EXP 119
64756: PPUSH
64757: LD_VAR 0 6
64761: PPUSH
64762: LD_VAR 0 7
64766: PPUSH
64767: CALL_OW 1
64771: ST_TO_ADDR
// break ;
64772: GO 64776
// end ;
64774: GO 64670
64776: POP
64777: POP
// end ;
64778: LD_VAR 0 5
64782: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
64783: LD_INT 0
64785: PPUSH
64786: PPUSH
64787: PPUSH
64788: PPUSH
// if not mc_bases or not skirmish then
64789: LD_EXP 100
64793: NOT
64794: PUSH
64795: LD_EXP 98
64799: NOT
64800: OR
64801: IFFALSE 64805
// exit ;
64803: GO 65225
// repeat wait ( 0 0$1 ) ;
64805: LD_INT 35
64807: PPUSH
64808: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
64812: LD_EXP 144
64816: NOT
64817: IFFALSE 64805
// mc_block_vehicle_constructed_thread := true ;
64819: LD_ADDR_EXP 144
64823: PUSH
64824: LD_INT 1
64826: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
64827: LD_ADDR_VAR 0 5
64831: PUSH
64832: LD_VAR 0 1
64836: PPUSH
64837: CALL_OW 255
64841: ST_TO_ADDR
// for i = 1 to mc_bases do
64842: LD_ADDR_VAR 0 4
64846: PUSH
64847: DOUBLE
64848: LD_INT 1
64850: DEC
64851: ST_TO_ADDR
64852: LD_EXP 100
64856: PUSH
64857: FOR_TO
64858: IFFALSE 65215
// begin if factory in mc_bases [ i ] then
64860: LD_VAR 0 2
64864: PUSH
64865: LD_EXP 100
64869: PUSH
64870: LD_VAR 0 4
64874: ARRAY
64875: IN
64876: IFFALSE 65213
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
64878: LD_EXP 122
64882: PUSH
64883: LD_VAR 0 4
64887: ARRAY
64888: PUSH
64889: LD_EXP 111
64893: PUSH
64894: LD_VAR 0 4
64898: ARRAY
64899: LESS
64900: PUSH
64901: LD_VAR 0 1
64905: PPUSH
64906: CALL_OW 264
64910: PUSH
64911: LD_INT 31
64913: PUSH
64914: LD_INT 32
64916: PUSH
64917: LD_INT 51
64919: PUSH
64920: LD_INT 89
64922: PUSH
64923: LD_INT 12
64925: PUSH
64926: LD_INT 30
64928: PUSH
64929: LD_INT 98
64931: PUSH
64932: LD_INT 11
64934: PUSH
64935: LD_INT 53
64937: PUSH
64938: LD_INT 14
64940: PUSH
64941: LD_INT 91
64943: PUSH
64944: LD_INT 29
64946: PUSH
64947: LD_INT 99
64949: PUSH
64950: LD_INT 13
64952: PUSH
64953: LD_INT 52
64955: PUSH
64956: LD_INT 88
64958: PUSH
64959: LD_INT 48
64961: PUSH
64962: LD_INT 8
64964: PUSH
64965: EMPTY
64966: LIST
64967: LIST
64968: LIST
64969: LIST
64970: LIST
64971: LIST
64972: LIST
64973: LIST
64974: LIST
64975: LIST
64976: LIST
64977: LIST
64978: LIST
64979: LIST
64980: LIST
64981: LIST
64982: LIST
64983: LIST
64984: IN
64985: NOT
64986: AND
64987: IFFALSE 65035
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
64989: LD_ADDR_EXP 122
64993: PUSH
64994: LD_EXP 122
64998: PPUSH
64999: LD_VAR 0 4
65003: PUSH
65004: LD_EXP 122
65008: PUSH
65009: LD_VAR 0 4
65013: ARRAY
65014: PUSH
65015: LD_INT 1
65017: PLUS
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: PPUSH
65023: LD_VAR 0 1
65027: PPUSH
65028: CALL 73860 0 3
65032: ST_TO_ADDR
65033: GO 65079
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
65035: LD_ADDR_EXP 119
65039: PUSH
65040: LD_EXP 119
65044: PPUSH
65045: LD_VAR 0 4
65049: PUSH
65050: LD_EXP 119
65054: PUSH
65055: LD_VAR 0 4
65059: ARRAY
65060: PUSH
65061: LD_INT 1
65063: PLUS
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PPUSH
65069: LD_VAR 0 1
65073: PPUSH
65074: CALL 73860 0 3
65078: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
65079: LD_ADDR_EXP 144
65083: PUSH
65084: LD_INT 0
65086: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
65087: LD_VAR 0 1
65091: PPUSH
65092: CALL_OW 263
65096: PUSH
65097: LD_INT 2
65099: EQUAL
65100: IFFALSE 65129
// begin repeat wait ( 0 0$3 ) ;
65102: LD_INT 105
65104: PPUSH
65105: CALL_OW 67
// Connect ( vehicle ) ;
65109: LD_VAR 0 1
65113: PPUSH
65114: CALL 76829 0 1
// until IsControledBy ( vehicle ) ;
65118: LD_VAR 0 1
65122: PPUSH
65123: CALL_OW 312
65127: IFFALSE 65102
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
65129: LD_VAR 0 1
65133: PPUSH
65134: LD_EXP 124
65138: PUSH
65139: LD_VAR 0 4
65143: ARRAY
65144: PPUSH
65145: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
65149: LD_VAR 0 1
65153: PPUSH
65154: CALL_OW 263
65158: PUSH
65159: LD_INT 1
65161: NONEQUAL
65162: IFFALSE 65166
// break ;
65164: GO 65215
// repeat wait ( 0 0$1 ) ;
65166: LD_INT 35
65168: PPUSH
65169: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
65173: LD_VAR 0 1
65177: PPUSH
65178: LD_EXP 124
65182: PUSH
65183: LD_VAR 0 4
65187: ARRAY
65188: PPUSH
65189: CALL_OW 308
65193: IFFALSE 65166
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
65195: LD_VAR 0 1
65199: PPUSH
65200: CALL_OW 311
65204: PPUSH
65205: CALL_OW 121
// exit ;
65209: POP
65210: POP
65211: GO 65225
// end ; end ;
65213: GO 64857
65215: POP
65216: POP
// mc_block_vehicle_constructed_thread := false ;
65217: LD_ADDR_EXP 144
65221: PUSH
65222: LD_INT 0
65224: ST_TO_ADDR
// end ;
65225: LD_VAR 0 3
65229: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
65230: LD_INT 0
65232: PPUSH
65233: PPUSH
65234: PPUSH
65235: PPUSH
// if not mc_bases or not skirmish then
65236: LD_EXP 100
65240: NOT
65241: PUSH
65242: LD_EXP 98
65246: NOT
65247: OR
65248: IFFALSE 65252
// exit ;
65250: GO 65605
// repeat wait ( 0 0$1 ) ;
65252: LD_INT 35
65254: PPUSH
65255: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
65259: LD_VAR 0 2
65263: PPUSH
65264: LD_VAR 0 3
65268: PPUSH
65269: CALL_OW 284
65273: IFFALSE 65252
// if GetResourceTypeXY ( x , y ) = mat_artefact then
65275: LD_VAR 0 2
65279: PPUSH
65280: LD_VAR 0 3
65284: PPUSH
65285: CALL_OW 283
65289: PUSH
65290: LD_INT 4
65292: EQUAL
65293: IFFALSE 65297
// exit ;
65295: GO 65605
// for i = 1 to mc_bases do
65297: LD_ADDR_VAR 0 7
65301: PUSH
65302: DOUBLE
65303: LD_INT 1
65305: DEC
65306: ST_TO_ADDR
65307: LD_EXP 100
65311: PUSH
65312: FOR_TO
65313: IFFALSE 65603
// begin if mc_crates_area [ i ] then
65315: LD_EXP 118
65319: PUSH
65320: LD_VAR 0 7
65324: ARRAY
65325: IFFALSE 65436
// for j in mc_crates_area [ i ] do
65327: LD_ADDR_VAR 0 8
65331: PUSH
65332: LD_EXP 118
65336: PUSH
65337: LD_VAR 0 7
65341: ARRAY
65342: PUSH
65343: FOR_IN
65344: IFFALSE 65434
// if InArea ( x , y , j ) then
65346: LD_VAR 0 2
65350: PPUSH
65351: LD_VAR 0 3
65355: PPUSH
65356: LD_VAR 0 8
65360: PPUSH
65361: CALL_OW 309
65365: IFFALSE 65432
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
65367: LD_ADDR_EXP 116
65371: PUSH
65372: LD_EXP 116
65376: PPUSH
65377: LD_VAR 0 7
65381: PUSH
65382: LD_EXP 116
65386: PUSH
65387: LD_VAR 0 7
65391: ARRAY
65392: PUSH
65393: LD_INT 1
65395: PLUS
65396: PUSH
65397: EMPTY
65398: LIST
65399: LIST
65400: PPUSH
65401: LD_VAR 0 4
65405: PUSH
65406: LD_VAR 0 2
65410: PUSH
65411: LD_VAR 0 3
65415: PUSH
65416: EMPTY
65417: LIST
65418: LIST
65419: LIST
65420: PPUSH
65421: CALL 73860 0 3
65425: ST_TO_ADDR
// exit ;
65426: POP
65427: POP
65428: POP
65429: POP
65430: GO 65605
// end ;
65432: GO 65343
65434: POP
65435: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65436: LD_ADDR_VAR 0 9
65440: PUSH
65441: LD_EXP 100
65445: PUSH
65446: LD_VAR 0 7
65450: ARRAY
65451: PPUSH
65452: LD_INT 2
65454: PUSH
65455: LD_INT 30
65457: PUSH
65458: LD_INT 0
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: PUSH
65465: LD_INT 30
65467: PUSH
65468: LD_INT 1
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: EMPTY
65476: LIST
65477: LIST
65478: LIST
65479: PPUSH
65480: CALL_OW 72
65484: ST_TO_ADDR
// if not depot then
65485: LD_VAR 0 9
65489: NOT
65490: IFFALSE 65494
// continue ;
65492: GO 65312
// for j in depot do
65494: LD_ADDR_VAR 0 8
65498: PUSH
65499: LD_VAR 0 9
65503: PUSH
65504: FOR_IN
65505: IFFALSE 65599
// if GetDistUnitXY ( j , x , y ) < 30 then
65507: LD_VAR 0 8
65511: PPUSH
65512: LD_VAR 0 2
65516: PPUSH
65517: LD_VAR 0 3
65521: PPUSH
65522: CALL_OW 297
65526: PUSH
65527: LD_INT 30
65529: LESS
65530: IFFALSE 65597
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
65532: LD_ADDR_EXP 116
65536: PUSH
65537: LD_EXP 116
65541: PPUSH
65542: LD_VAR 0 7
65546: PUSH
65547: LD_EXP 116
65551: PUSH
65552: LD_VAR 0 7
65556: ARRAY
65557: PUSH
65558: LD_INT 1
65560: PLUS
65561: PUSH
65562: EMPTY
65563: LIST
65564: LIST
65565: PPUSH
65566: LD_VAR 0 4
65570: PUSH
65571: LD_VAR 0 2
65575: PUSH
65576: LD_VAR 0 3
65580: PUSH
65581: EMPTY
65582: LIST
65583: LIST
65584: LIST
65585: PPUSH
65586: CALL 73860 0 3
65590: ST_TO_ADDR
// exit ;
65591: POP
65592: POP
65593: POP
65594: POP
65595: GO 65605
// end ;
65597: GO 65504
65599: POP
65600: POP
// end ;
65601: GO 65312
65603: POP
65604: POP
// end ;
65605: LD_VAR 0 6
65609: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
65610: LD_INT 0
65612: PPUSH
65613: PPUSH
65614: PPUSH
65615: PPUSH
// if not mc_bases or not skirmish then
65616: LD_EXP 100
65620: NOT
65621: PUSH
65622: LD_EXP 98
65626: NOT
65627: OR
65628: IFFALSE 65632
// exit ;
65630: GO 65909
// side := GetSide ( lab ) ;
65632: LD_ADDR_VAR 0 4
65636: PUSH
65637: LD_VAR 0 2
65641: PPUSH
65642: CALL_OW 255
65646: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
65647: LD_VAR 0 4
65651: PUSH
65652: LD_EXP 126
65656: IN
65657: NOT
65658: PUSH
65659: LD_EXP 127
65663: NOT
65664: OR
65665: PUSH
65666: LD_EXP 100
65670: NOT
65671: OR
65672: IFFALSE 65676
// exit ;
65674: GO 65909
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
65676: LD_ADDR_EXP 127
65680: PUSH
65681: LD_EXP 127
65685: PPUSH
65686: LD_VAR 0 4
65690: PPUSH
65691: LD_EXP 127
65695: PUSH
65696: LD_VAR 0 4
65700: ARRAY
65701: PUSH
65702: LD_VAR 0 1
65706: DIFF
65707: PPUSH
65708: CALL_OW 1
65712: ST_TO_ADDR
// for i = 1 to mc_bases do
65713: LD_ADDR_VAR 0 5
65717: PUSH
65718: DOUBLE
65719: LD_INT 1
65721: DEC
65722: ST_TO_ADDR
65723: LD_EXP 100
65727: PUSH
65728: FOR_TO
65729: IFFALSE 65907
// begin if lab in mc_bases [ i ] then
65731: LD_VAR 0 2
65735: PUSH
65736: LD_EXP 100
65740: PUSH
65741: LD_VAR 0 5
65745: ARRAY
65746: IN
65747: IFFALSE 65905
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
65749: LD_VAR 0 1
65753: PUSH
65754: LD_INT 11
65756: PUSH
65757: LD_INT 4
65759: PUSH
65760: LD_INT 3
65762: PUSH
65763: LD_INT 2
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: LIST
65770: LIST
65771: IN
65772: PUSH
65773: LD_EXP 130
65777: PUSH
65778: LD_VAR 0 5
65782: ARRAY
65783: AND
65784: IFFALSE 65905
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
65786: LD_ADDR_VAR 0 6
65790: PUSH
65791: LD_EXP 130
65795: PUSH
65796: LD_VAR 0 5
65800: ARRAY
65801: PUSH
65802: LD_INT 1
65804: ARRAY
65805: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
65806: LD_ADDR_EXP 130
65810: PUSH
65811: LD_EXP 130
65815: PPUSH
65816: LD_VAR 0 5
65820: PPUSH
65821: EMPTY
65822: PPUSH
65823: CALL_OW 1
65827: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
65828: LD_VAR 0 6
65832: PPUSH
65833: LD_INT 0
65835: PPUSH
65836: CALL_OW 109
// ComExitBuilding ( tmp ) ;
65840: LD_VAR 0 6
65844: PPUSH
65845: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
65849: LD_ADDR_EXP 129
65853: PUSH
65854: LD_EXP 129
65858: PPUSH
65859: LD_VAR 0 5
65863: PPUSH
65864: LD_EXP 129
65868: PUSH
65869: LD_VAR 0 5
65873: ARRAY
65874: PPUSH
65875: LD_INT 1
65877: PPUSH
65878: LD_VAR 0 6
65882: PPUSH
65883: CALL_OW 2
65887: PPUSH
65888: CALL_OW 1
65892: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
65893: LD_VAR 0 5
65897: PPUSH
65898: LD_INT 112
65900: PPUSH
65901: CALL 42373 0 2
// end ; end ; end ;
65905: GO 65728
65907: POP
65908: POP
// end ;
65909: LD_VAR 0 3
65913: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
65914: LD_INT 0
65916: PPUSH
65917: PPUSH
65918: PPUSH
65919: PPUSH
65920: PPUSH
65921: PPUSH
65922: PPUSH
65923: PPUSH
// if not mc_bases or not skirmish then
65924: LD_EXP 100
65928: NOT
65929: PUSH
65930: LD_EXP 98
65934: NOT
65935: OR
65936: IFFALSE 65940
// exit ;
65938: GO 67309
// for i = 1 to mc_bases do
65940: LD_ADDR_VAR 0 3
65944: PUSH
65945: DOUBLE
65946: LD_INT 1
65948: DEC
65949: ST_TO_ADDR
65950: LD_EXP 100
65954: PUSH
65955: FOR_TO
65956: IFFALSE 67307
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
65958: LD_VAR 0 1
65962: PUSH
65963: LD_EXP 100
65967: PUSH
65968: LD_VAR 0 3
65972: ARRAY
65973: IN
65974: PUSH
65975: LD_VAR 0 1
65979: PUSH
65980: LD_EXP 107
65984: PUSH
65985: LD_VAR 0 3
65989: ARRAY
65990: IN
65991: OR
65992: PUSH
65993: LD_VAR 0 1
65997: PUSH
65998: LD_EXP 122
66002: PUSH
66003: LD_VAR 0 3
66007: ARRAY
66008: IN
66009: OR
66010: PUSH
66011: LD_VAR 0 1
66015: PUSH
66016: LD_EXP 119
66020: PUSH
66021: LD_VAR 0 3
66025: ARRAY
66026: IN
66027: OR
66028: PUSH
66029: LD_VAR 0 1
66033: PUSH
66034: LD_EXP 129
66038: PUSH
66039: LD_VAR 0 3
66043: ARRAY
66044: IN
66045: OR
66046: PUSH
66047: LD_VAR 0 1
66051: PUSH
66052: LD_EXP 130
66056: PUSH
66057: LD_VAR 0 3
66061: ARRAY
66062: IN
66063: OR
66064: IFFALSE 67305
// begin if un in mc_ape [ i ] then
66066: LD_VAR 0 1
66070: PUSH
66071: LD_EXP 129
66075: PUSH
66076: LD_VAR 0 3
66080: ARRAY
66081: IN
66082: IFFALSE 66121
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
66084: LD_ADDR_EXP 129
66088: PUSH
66089: LD_EXP 129
66093: PPUSH
66094: LD_VAR 0 3
66098: PPUSH
66099: LD_EXP 129
66103: PUSH
66104: LD_VAR 0 3
66108: ARRAY
66109: PUSH
66110: LD_VAR 0 1
66114: DIFF
66115: PPUSH
66116: CALL_OW 1
66120: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
66121: LD_VAR 0 1
66125: PUSH
66126: LD_EXP 130
66130: PUSH
66131: LD_VAR 0 3
66135: ARRAY
66136: IN
66137: IFFALSE 66161
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
66139: LD_ADDR_EXP 130
66143: PUSH
66144: LD_EXP 130
66148: PPUSH
66149: LD_VAR 0 3
66153: PPUSH
66154: EMPTY
66155: PPUSH
66156: CALL_OW 1
66160: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
66161: LD_VAR 0 1
66165: PPUSH
66166: CALL_OW 247
66170: PUSH
66171: LD_INT 2
66173: EQUAL
66174: PUSH
66175: LD_VAR 0 1
66179: PPUSH
66180: CALL_OW 110
66184: PUSH
66185: LD_INT 20
66187: EQUAL
66188: PUSH
66189: LD_VAR 0 1
66193: PUSH
66194: LD_EXP 122
66198: PUSH
66199: LD_VAR 0 3
66203: ARRAY
66204: IN
66205: OR
66206: PUSH
66207: LD_VAR 0 1
66211: PPUSH
66212: CALL_OW 264
66216: PUSH
66217: LD_INT 12
66219: PUSH
66220: LD_INT 51
66222: PUSH
66223: LD_INT 89
66225: PUSH
66226: LD_INT 32
66228: PUSH
66229: LD_INT 13
66231: PUSH
66232: LD_INT 52
66234: PUSH
66235: LD_INT 31
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: LIST
66244: LIST
66245: LIST
66246: IN
66247: OR
66248: AND
66249: IFFALSE 66557
// begin if un in mc_defender [ i ] then
66251: LD_VAR 0 1
66255: PUSH
66256: LD_EXP 122
66260: PUSH
66261: LD_VAR 0 3
66265: ARRAY
66266: IN
66267: IFFALSE 66306
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
66269: LD_ADDR_EXP 122
66273: PUSH
66274: LD_EXP 122
66278: PPUSH
66279: LD_VAR 0 3
66283: PPUSH
66284: LD_EXP 122
66288: PUSH
66289: LD_VAR 0 3
66293: ARRAY
66294: PUSH
66295: LD_VAR 0 1
66299: DIFF
66300: PPUSH
66301: CALL_OW 1
66305: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
66306: LD_ADDR_VAR 0 8
66310: PUSH
66311: LD_VAR 0 3
66315: PPUSH
66316: LD_INT 3
66318: PPUSH
66319: CALL 62927 0 2
66323: ST_TO_ADDR
// if fac then
66324: LD_VAR 0 8
66328: IFFALSE 66557
// begin for j in fac do
66330: LD_ADDR_VAR 0 4
66334: PUSH
66335: LD_VAR 0 8
66339: PUSH
66340: FOR_IN
66341: IFFALSE 66555
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
66343: LD_ADDR_VAR 0 9
66347: PUSH
66348: LD_VAR 0 8
66352: PPUSH
66353: LD_VAR 0 1
66357: PPUSH
66358: CALL_OW 265
66362: PPUSH
66363: LD_VAR 0 1
66367: PPUSH
66368: CALL_OW 262
66372: PPUSH
66373: LD_VAR 0 1
66377: PPUSH
66378: CALL_OW 263
66382: PPUSH
66383: LD_VAR 0 1
66387: PPUSH
66388: CALL_OW 264
66392: PPUSH
66393: CALL 71358 0 5
66397: ST_TO_ADDR
// if components then
66398: LD_VAR 0 9
66402: IFFALSE 66553
// begin if GetWeapon ( un ) = ar_control_tower then
66404: LD_VAR 0 1
66408: PPUSH
66409: CALL_OW 264
66413: PUSH
66414: LD_INT 31
66416: EQUAL
66417: IFFALSE 66534
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
66419: LD_VAR 0 1
66423: PPUSH
66424: CALL_OW 311
66428: PPUSH
66429: LD_INT 0
66431: PPUSH
66432: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
66436: LD_ADDR_EXP 140
66440: PUSH
66441: LD_EXP 140
66445: PPUSH
66446: LD_VAR 0 3
66450: PPUSH
66451: LD_EXP 140
66455: PUSH
66456: LD_VAR 0 3
66460: ARRAY
66461: PUSH
66462: LD_VAR 0 1
66466: PPUSH
66467: CALL_OW 311
66471: DIFF
66472: PPUSH
66473: CALL_OW 1
66477: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
66478: LD_ADDR_VAR 0 7
66482: PUSH
66483: LD_EXP 121
66487: PUSH
66488: LD_VAR 0 3
66492: ARRAY
66493: PPUSH
66494: LD_INT 1
66496: PPUSH
66497: LD_VAR 0 9
66501: PPUSH
66502: CALL_OW 2
66506: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66507: LD_ADDR_EXP 121
66511: PUSH
66512: LD_EXP 121
66516: PPUSH
66517: LD_VAR 0 3
66521: PPUSH
66522: LD_VAR 0 7
66526: PPUSH
66527: CALL_OW 1
66531: ST_TO_ADDR
// end else
66532: GO 66551
// MC_InsertProduceList ( i , [ components ] ) ;
66534: LD_VAR 0 3
66538: PPUSH
66539: LD_VAR 0 9
66543: PUSH
66544: EMPTY
66545: LIST
66546: PPUSH
66547: CALL 62472 0 2
// break ;
66551: GO 66555
// end ; end ;
66553: GO 66340
66555: POP
66556: POP
// end ; end ; if GetType ( un ) = unit_building then
66557: LD_VAR 0 1
66561: PPUSH
66562: CALL_OW 247
66566: PUSH
66567: LD_INT 3
66569: EQUAL
66570: IFFALSE 66973
// begin btype := GetBType ( un ) ;
66572: LD_ADDR_VAR 0 5
66576: PUSH
66577: LD_VAR 0 1
66581: PPUSH
66582: CALL_OW 266
66586: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
66587: LD_VAR 0 5
66591: PUSH
66592: LD_INT 29
66594: PUSH
66595: LD_INT 30
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: IN
66602: IFFALSE 66675
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
66604: LD_VAR 0 1
66608: PPUSH
66609: CALL_OW 250
66613: PPUSH
66614: LD_VAR 0 1
66618: PPUSH
66619: CALL_OW 251
66623: PPUSH
66624: LD_VAR 0 1
66628: PPUSH
66629: CALL_OW 255
66633: PPUSH
66634: CALL_OW 440
66638: NOT
66639: IFFALSE 66675
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
66641: LD_VAR 0 1
66645: PPUSH
66646: CALL_OW 250
66650: PPUSH
66651: LD_VAR 0 1
66655: PPUSH
66656: CALL_OW 251
66660: PPUSH
66661: LD_VAR 0 1
66665: PPUSH
66666: CALL_OW 255
66670: PPUSH
66671: CALL_OW 441
// end ; if btype = b_warehouse then
66675: LD_VAR 0 5
66679: PUSH
66680: LD_INT 1
66682: EQUAL
66683: IFFALSE 66701
// begin btype := b_depot ;
66685: LD_ADDR_VAR 0 5
66689: PUSH
66690: LD_INT 0
66692: ST_TO_ADDR
// pos := 1 ;
66693: LD_ADDR_VAR 0 6
66697: PUSH
66698: LD_INT 1
66700: ST_TO_ADDR
// end ; if btype = b_factory then
66701: LD_VAR 0 5
66705: PUSH
66706: LD_INT 3
66708: EQUAL
66709: IFFALSE 66727
// begin btype := b_workshop ;
66711: LD_ADDR_VAR 0 5
66715: PUSH
66716: LD_INT 2
66718: ST_TO_ADDR
// pos := 1 ;
66719: LD_ADDR_VAR 0 6
66723: PUSH
66724: LD_INT 1
66726: ST_TO_ADDR
// end ; if btype = b_barracks then
66727: LD_VAR 0 5
66731: PUSH
66732: LD_INT 5
66734: EQUAL
66735: IFFALSE 66745
// btype := b_armoury ;
66737: LD_ADDR_VAR 0 5
66741: PUSH
66742: LD_INT 4
66744: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
66745: LD_VAR 0 5
66749: PUSH
66750: LD_INT 7
66752: PUSH
66753: LD_INT 8
66755: PUSH
66756: EMPTY
66757: LIST
66758: LIST
66759: IN
66760: IFFALSE 66770
// btype := b_lab ;
66762: LD_ADDR_VAR 0 5
66766: PUSH
66767: LD_INT 6
66769: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
66770: LD_ADDR_EXP 105
66774: PUSH
66775: LD_EXP 105
66779: PPUSH
66780: LD_VAR 0 3
66784: PUSH
66785: LD_EXP 105
66789: PUSH
66790: LD_VAR 0 3
66794: ARRAY
66795: PUSH
66796: LD_INT 1
66798: PLUS
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: PPUSH
66804: LD_VAR 0 5
66808: PUSH
66809: LD_VAR 0 1
66813: PPUSH
66814: CALL_OW 250
66818: PUSH
66819: LD_VAR 0 1
66823: PPUSH
66824: CALL_OW 251
66828: PUSH
66829: LD_VAR 0 1
66833: PPUSH
66834: CALL_OW 254
66838: PUSH
66839: EMPTY
66840: LIST
66841: LIST
66842: LIST
66843: LIST
66844: PPUSH
66845: CALL 73860 0 3
66849: ST_TO_ADDR
// if pos = 1 then
66850: LD_VAR 0 6
66854: PUSH
66855: LD_INT 1
66857: EQUAL
66858: IFFALSE 66973
// begin tmp := mc_build_list [ i ] ;
66860: LD_ADDR_VAR 0 7
66864: PUSH
66865: LD_EXP 105
66869: PUSH
66870: LD_VAR 0 3
66874: ARRAY
66875: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
66876: LD_VAR 0 7
66880: PPUSH
66881: LD_INT 2
66883: PUSH
66884: LD_INT 30
66886: PUSH
66887: LD_INT 0
66889: PUSH
66890: EMPTY
66891: LIST
66892: LIST
66893: PUSH
66894: LD_INT 30
66896: PUSH
66897: LD_INT 1
66899: PUSH
66900: EMPTY
66901: LIST
66902: LIST
66903: PUSH
66904: EMPTY
66905: LIST
66906: LIST
66907: LIST
66908: PPUSH
66909: CALL_OW 72
66913: IFFALSE 66923
// pos := 2 ;
66915: LD_ADDR_VAR 0 6
66919: PUSH
66920: LD_INT 2
66922: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
66923: LD_ADDR_VAR 0 7
66927: PUSH
66928: LD_VAR 0 7
66932: PPUSH
66933: LD_VAR 0 6
66937: PPUSH
66938: LD_VAR 0 7
66942: PPUSH
66943: CALL 74186 0 3
66947: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
66948: LD_ADDR_EXP 105
66952: PUSH
66953: LD_EXP 105
66957: PPUSH
66958: LD_VAR 0 3
66962: PPUSH
66963: LD_VAR 0 7
66967: PPUSH
66968: CALL_OW 1
66972: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
66973: LD_VAR 0 1
66977: PUSH
66978: LD_EXP 100
66982: PUSH
66983: LD_VAR 0 3
66987: ARRAY
66988: IN
66989: IFFALSE 67028
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
66991: LD_ADDR_EXP 100
66995: PUSH
66996: LD_EXP 100
67000: PPUSH
67001: LD_VAR 0 3
67005: PPUSH
67006: LD_EXP 100
67010: PUSH
67011: LD_VAR 0 3
67015: ARRAY
67016: PUSH
67017: LD_VAR 0 1
67021: DIFF
67022: PPUSH
67023: CALL_OW 1
67027: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
67028: LD_VAR 0 1
67032: PUSH
67033: LD_EXP 107
67037: PUSH
67038: LD_VAR 0 3
67042: ARRAY
67043: IN
67044: IFFALSE 67083
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
67046: LD_ADDR_EXP 107
67050: PUSH
67051: LD_EXP 107
67055: PPUSH
67056: LD_VAR 0 3
67060: PPUSH
67061: LD_EXP 107
67065: PUSH
67066: LD_VAR 0 3
67070: ARRAY
67071: PUSH
67072: LD_VAR 0 1
67076: DIFF
67077: PPUSH
67078: CALL_OW 1
67082: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
67083: LD_VAR 0 1
67087: PUSH
67088: LD_EXP 119
67092: PUSH
67093: LD_VAR 0 3
67097: ARRAY
67098: IN
67099: IFFALSE 67138
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
67101: LD_ADDR_EXP 119
67105: PUSH
67106: LD_EXP 119
67110: PPUSH
67111: LD_VAR 0 3
67115: PPUSH
67116: LD_EXP 119
67120: PUSH
67121: LD_VAR 0 3
67125: ARRAY
67126: PUSH
67127: LD_VAR 0 1
67131: DIFF
67132: PPUSH
67133: CALL_OW 1
67137: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
67138: LD_VAR 0 1
67142: PUSH
67143: LD_EXP 122
67147: PUSH
67148: LD_VAR 0 3
67152: ARRAY
67153: IN
67154: IFFALSE 67193
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
67156: LD_ADDR_EXP 122
67160: PUSH
67161: LD_EXP 122
67165: PPUSH
67166: LD_VAR 0 3
67170: PPUSH
67171: LD_EXP 122
67175: PUSH
67176: LD_VAR 0 3
67180: ARRAY
67181: PUSH
67182: LD_VAR 0 1
67186: DIFF
67187: PPUSH
67188: CALL_OW 1
67192: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
67193: LD_VAR 0 1
67197: PUSH
67198: LD_EXP 109
67202: PUSH
67203: LD_VAR 0 3
67207: ARRAY
67208: IN
67209: IFFALSE 67248
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
67211: LD_ADDR_EXP 109
67215: PUSH
67216: LD_EXP 109
67220: PPUSH
67221: LD_VAR 0 3
67225: PPUSH
67226: LD_EXP 109
67230: PUSH
67231: LD_VAR 0 3
67235: ARRAY
67236: PUSH
67237: LD_VAR 0 1
67241: DIFF
67242: PPUSH
67243: CALL_OW 1
67247: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
67248: LD_VAR 0 1
67252: PUSH
67253: LD_EXP 108
67257: PUSH
67258: LD_VAR 0 3
67262: ARRAY
67263: IN
67264: IFFALSE 67303
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
67266: LD_ADDR_EXP 108
67270: PUSH
67271: LD_EXP 108
67275: PPUSH
67276: LD_VAR 0 3
67280: PPUSH
67281: LD_EXP 108
67285: PUSH
67286: LD_VAR 0 3
67290: ARRAY
67291: PUSH
67292: LD_VAR 0 1
67296: DIFF
67297: PPUSH
67298: CALL_OW 1
67302: ST_TO_ADDR
// end ; break ;
67303: GO 67307
// end ;
67305: GO 65955
67307: POP
67308: POP
// end ;
67309: LD_VAR 0 2
67313: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
67314: LD_INT 0
67316: PPUSH
67317: PPUSH
67318: PPUSH
// if not mc_bases or not skirmish then
67319: LD_EXP 100
67323: NOT
67324: PUSH
67325: LD_EXP 98
67329: NOT
67330: OR
67331: IFFALSE 67335
// exit ;
67333: GO 67550
// for i = 1 to mc_bases do
67335: LD_ADDR_VAR 0 3
67339: PUSH
67340: DOUBLE
67341: LD_INT 1
67343: DEC
67344: ST_TO_ADDR
67345: LD_EXP 100
67349: PUSH
67350: FOR_TO
67351: IFFALSE 67548
// begin if building in mc_construct_list [ i ] then
67353: LD_VAR 0 1
67357: PUSH
67358: LD_EXP 107
67362: PUSH
67363: LD_VAR 0 3
67367: ARRAY
67368: IN
67369: IFFALSE 67546
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
67371: LD_ADDR_EXP 107
67375: PUSH
67376: LD_EXP 107
67380: PPUSH
67381: LD_VAR 0 3
67385: PPUSH
67386: LD_EXP 107
67390: PUSH
67391: LD_VAR 0 3
67395: ARRAY
67396: PUSH
67397: LD_VAR 0 1
67401: DIFF
67402: PPUSH
67403: CALL_OW 1
67407: ST_TO_ADDR
// if building in mc_lab [ i ] then
67408: LD_VAR 0 1
67412: PUSH
67413: LD_EXP 133
67417: PUSH
67418: LD_VAR 0 3
67422: ARRAY
67423: IN
67424: IFFALSE 67479
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
67426: LD_ADDR_EXP 134
67430: PUSH
67431: LD_EXP 134
67435: PPUSH
67436: LD_VAR 0 3
67440: PPUSH
67441: LD_EXP 134
67445: PUSH
67446: LD_VAR 0 3
67450: ARRAY
67451: PPUSH
67452: LD_INT 1
67454: PPUSH
67455: LD_EXP 134
67459: PUSH
67460: LD_VAR 0 3
67464: ARRAY
67465: PPUSH
67466: LD_INT 0
67468: PPUSH
67469: CALL 73278 0 4
67473: PPUSH
67474: CALL_OW 1
67478: ST_TO_ADDR
// if not building in mc_bases [ i ] then
67479: LD_VAR 0 1
67483: PUSH
67484: LD_EXP 100
67488: PUSH
67489: LD_VAR 0 3
67493: ARRAY
67494: IN
67495: NOT
67496: IFFALSE 67542
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
67498: LD_ADDR_EXP 100
67502: PUSH
67503: LD_EXP 100
67507: PPUSH
67508: LD_VAR 0 3
67512: PUSH
67513: LD_EXP 100
67517: PUSH
67518: LD_VAR 0 3
67522: ARRAY
67523: PUSH
67524: LD_INT 1
67526: PLUS
67527: PUSH
67528: EMPTY
67529: LIST
67530: LIST
67531: PPUSH
67532: LD_VAR 0 1
67536: PPUSH
67537: CALL 73860 0 3
67541: ST_TO_ADDR
// exit ;
67542: POP
67543: POP
67544: GO 67550
// end ; end ;
67546: GO 67350
67548: POP
67549: POP
// end ;
67550: LD_VAR 0 2
67554: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
67555: LD_INT 0
67557: PPUSH
67558: PPUSH
67559: PPUSH
67560: PPUSH
67561: PPUSH
67562: PPUSH
67563: PPUSH
// if not mc_bases or not skirmish then
67564: LD_EXP 100
67568: NOT
67569: PUSH
67570: LD_EXP 98
67574: NOT
67575: OR
67576: IFFALSE 67580
// exit ;
67578: GO 68241
// for i = 1 to mc_bases do
67580: LD_ADDR_VAR 0 3
67584: PUSH
67585: DOUBLE
67586: LD_INT 1
67588: DEC
67589: ST_TO_ADDR
67590: LD_EXP 100
67594: PUSH
67595: FOR_TO
67596: IFFALSE 68239
// begin if building in mc_construct_list [ i ] then
67598: LD_VAR 0 1
67602: PUSH
67603: LD_EXP 107
67607: PUSH
67608: LD_VAR 0 3
67612: ARRAY
67613: IN
67614: IFFALSE 68237
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
67616: LD_ADDR_EXP 107
67620: PUSH
67621: LD_EXP 107
67625: PPUSH
67626: LD_VAR 0 3
67630: PPUSH
67631: LD_EXP 107
67635: PUSH
67636: LD_VAR 0 3
67640: ARRAY
67641: PUSH
67642: LD_VAR 0 1
67646: DIFF
67647: PPUSH
67648: CALL_OW 1
67652: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
67653: LD_ADDR_EXP 100
67657: PUSH
67658: LD_EXP 100
67662: PPUSH
67663: LD_VAR 0 3
67667: PUSH
67668: LD_EXP 100
67672: PUSH
67673: LD_VAR 0 3
67677: ARRAY
67678: PUSH
67679: LD_INT 1
67681: PLUS
67682: PUSH
67683: EMPTY
67684: LIST
67685: LIST
67686: PPUSH
67687: LD_VAR 0 1
67691: PPUSH
67692: CALL 73860 0 3
67696: ST_TO_ADDR
// btype := GetBType ( building ) ;
67697: LD_ADDR_VAR 0 5
67701: PUSH
67702: LD_VAR 0 1
67706: PPUSH
67707: CALL_OW 266
67711: ST_TO_ADDR
// side := GetSide ( building ) ;
67712: LD_ADDR_VAR 0 8
67716: PUSH
67717: LD_VAR 0 1
67721: PPUSH
67722: CALL_OW 255
67726: ST_TO_ADDR
// if btype = b_lab then
67727: LD_VAR 0 5
67731: PUSH
67732: LD_INT 6
67734: EQUAL
67735: IFFALSE 67785
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
67737: LD_ADDR_EXP 133
67741: PUSH
67742: LD_EXP 133
67746: PPUSH
67747: LD_VAR 0 3
67751: PUSH
67752: LD_EXP 133
67756: PUSH
67757: LD_VAR 0 3
67761: ARRAY
67762: PUSH
67763: LD_INT 1
67765: PLUS
67766: PUSH
67767: EMPTY
67768: LIST
67769: LIST
67770: PPUSH
67771: LD_VAR 0 1
67775: PPUSH
67776: CALL 73860 0 3
67780: ST_TO_ADDR
// exit ;
67781: POP
67782: POP
67783: GO 68241
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
67785: LD_VAR 0 5
67789: PUSH
67790: LD_INT 0
67792: PUSH
67793: LD_INT 2
67795: PUSH
67796: LD_INT 4
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: LIST
67803: IN
67804: IFFALSE 67928
// begin if btype = b_armoury then
67806: LD_VAR 0 5
67810: PUSH
67811: LD_INT 4
67813: EQUAL
67814: IFFALSE 67824
// btype := b_barracks ;
67816: LD_ADDR_VAR 0 5
67820: PUSH
67821: LD_INT 5
67823: ST_TO_ADDR
// if btype = b_depot then
67824: LD_VAR 0 5
67828: PUSH
67829: LD_INT 0
67831: EQUAL
67832: IFFALSE 67842
// btype := b_warehouse ;
67834: LD_ADDR_VAR 0 5
67838: PUSH
67839: LD_INT 1
67841: ST_TO_ADDR
// if btype = b_workshop then
67842: LD_VAR 0 5
67846: PUSH
67847: LD_INT 2
67849: EQUAL
67850: IFFALSE 67860
// btype := b_factory ;
67852: LD_ADDR_VAR 0 5
67856: PUSH
67857: LD_INT 3
67859: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
67860: LD_VAR 0 5
67864: PPUSH
67865: LD_VAR 0 8
67869: PPUSH
67870: CALL_OW 323
67874: PUSH
67875: LD_INT 1
67877: EQUAL
67878: IFFALSE 67924
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
67880: LD_ADDR_EXP 132
67884: PUSH
67885: LD_EXP 132
67889: PPUSH
67890: LD_VAR 0 3
67894: PUSH
67895: LD_EXP 132
67899: PUSH
67900: LD_VAR 0 3
67904: ARRAY
67905: PUSH
67906: LD_INT 1
67908: PLUS
67909: PUSH
67910: EMPTY
67911: LIST
67912: LIST
67913: PPUSH
67914: LD_VAR 0 1
67918: PPUSH
67919: CALL 73860 0 3
67923: ST_TO_ADDR
// exit ;
67924: POP
67925: POP
67926: GO 68241
// end ; if btype in [ b_bunker , b_turret ] then
67928: LD_VAR 0 5
67932: PUSH
67933: LD_INT 32
67935: PUSH
67936: LD_INT 33
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: IN
67943: IFFALSE 68233
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
67945: LD_ADDR_EXP 108
67949: PUSH
67950: LD_EXP 108
67954: PPUSH
67955: LD_VAR 0 3
67959: PUSH
67960: LD_EXP 108
67964: PUSH
67965: LD_VAR 0 3
67969: ARRAY
67970: PUSH
67971: LD_INT 1
67973: PLUS
67974: PUSH
67975: EMPTY
67976: LIST
67977: LIST
67978: PPUSH
67979: LD_VAR 0 1
67983: PPUSH
67984: CALL 73860 0 3
67988: ST_TO_ADDR
// if btype = b_bunker then
67989: LD_VAR 0 5
67993: PUSH
67994: LD_INT 32
67996: EQUAL
67997: IFFALSE 68233
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
67999: LD_ADDR_EXP 109
68003: PUSH
68004: LD_EXP 109
68008: PPUSH
68009: LD_VAR 0 3
68013: PUSH
68014: LD_EXP 109
68018: PUSH
68019: LD_VAR 0 3
68023: ARRAY
68024: PUSH
68025: LD_INT 1
68027: PLUS
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PPUSH
68033: LD_VAR 0 1
68037: PPUSH
68038: CALL 73860 0 3
68042: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
68043: LD_ADDR_VAR 0 6
68047: PUSH
68048: LD_EXP 100
68052: PUSH
68053: LD_VAR 0 3
68057: ARRAY
68058: PPUSH
68059: LD_INT 25
68061: PUSH
68062: LD_INT 1
68064: PUSH
68065: EMPTY
68066: LIST
68067: LIST
68068: PUSH
68069: LD_INT 3
68071: PUSH
68072: LD_INT 54
68074: PUSH
68075: EMPTY
68076: LIST
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PUSH
68082: EMPTY
68083: LIST
68084: LIST
68085: PPUSH
68086: CALL_OW 72
68090: ST_TO_ADDR
// if tmp then
68091: LD_VAR 0 6
68095: IFFALSE 68101
// exit ;
68097: POP
68098: POP
68099: GO 68241
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
68101: LD_ADDR_VAR 0 6
68105: PUSH
68106: LD_EXP 100
68110: PUSH
68111: LD_VAR 0 3
68115: ARRAY
68116: PPUSH
68117: LD_INT 2
68119: PUSH
68120: LD_INT 30
68122: PUSH
68123: LD_INT 4
68125: PUSH
68126: EMPTY
68127: LIST
68128: LIST
68129: PUSH
68130: LD_INT 30
68132: PUSH
68133: LD_INT 5
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: LIST
68144: PPUSH
68145: CALL_OW 72
68149: ST_TO_ADDR
// if not tmp then
68150: LD_VAR 0 6
68154: NOT
68155: IFFALSE 68161
// exit ;
68157: POP
68158: POP
68159: GO 68241
// for j in tmp do
68161: LD_ADDR_VAR 0 4
68165: PUSH
68166: LD_VAR 0 6
68170: PUSH
68171: FOR_IN
68172: IFFALSE 68231
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
68174: LD_ADDR_VAR 0 7
68178: PUSH
68179: LD_VAR 0 4
68183: PPUSH
68184: CALL_OW 313
68188: PPUSH
68189: LD_INT 25
68191: PUSH
68192: LD_INT 1
68194: PUSH
68195: EMPTY
68196: LIST
68197: LIST
68198: PPUSH
68199: CALL_OW 72
68203: ST_TO_ADDR
// if units then
68204: LD_VAR 0 7
68208: IFFALSE 68229
// begin ComExitBuilding ( units [ 1 ] ) ;
68210: LD_VAR 0 7
68214: PUSH
68215: LD_INT 1
68217: ARRAY
68218: PPUSH
68219: CALL_OW 122
// exit ;
68223: POP
68224: POP
68225: POP
68226: POP
68227: GO 68241
// end ; end ;
68229: GO 68171
68231: POP
68232: POP
// end ; end ; exit ;
68233: POP
68234: POP
68235: GO 68241
// end ; end ;
68237: GO 67595
68239: POP
68240: POP
// end ;
68241: LD_VAR 0 2
68245: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
68246: LD_INT 0
68248: PPUSH
68249: PPUSH
68250: PPUSH
68251: PPUSH
68252: PPUSH
68253: PPUSH
68254: PPUSH
// if not mc_bases or not skirmish then
68255: LD_EXP 100
68259: NOT
68260: PUSH
68261: LD_EXP 98
68265: NOT
68266: OR
68267: IFFALSE 68271
// exit ;
68269: GO 68536
// btype := GetBType ( building ) ;
68271: LD_ADDR_VAR 0 6
68275: PUSH
68276: LD_VAR 0 1
68280: PPUSH
68281: CALL_OW 266
68285: ST_TO_ADDR
// x := GetX ( building ) ;
68286: LD_ADDR_VAR 0 7
68290: PUSH
68291: LD_VAR 0 1
68295: PPUSH
68296: CALL_OW 250
68300: ST_TO_ADDR
// y := GetY ( building ) ;
68301: LD_ADDR_VAR 0 8
68305: PUSH
68306: LD_VAR 0 1
68310: PPUSH
68311: CALL_OW 251
68315: ST_TO_ADDR
// d := GetDir ( building ) ;
68316: LD_ADDR_VAR 0 9
68320: PUSH
68321: LD_VAR 0 1
68325: PPUSH
68326: CALL_OW 254
68330: ST_TO_ADDR
// for i = 1 to mc_bases do
68331: LD_ADDR_VAR 0 4
68335: PUSH
68336: DOUBLE
68337: LD_INT 1
68339: DEC
68340: ST_TO_ADDR
68341: LD_EXP 100
68345: PUSH
68346: FOR_TO
68347: IFFALSE 68534
// begin if not mc_build_list [ i ] then
68349: LD_EXP 105
68353: PUSH
68354: LD_VAR 0 4
68358: ARRAY
68359: NOT
68360: IFFALSE 68364
// continue ;
68362: GO 68346
// for j := 1 to mc_build_list [ i ] do
68364: LD_ADDR_VAR 0 5
68368: PUSH
68369: DOUBLE
68370: LD_INT 1
68372: DEC
68373: ST_TO_ADDR
68374: LD_EXP 105
68378: PUSH
68379: LD_VAR 0 4
68383: ARRAY
68384: PUSH
68385: FOR_TO
68386: IFFALSE 68530
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
68388: LD_VAR 0 6
68392: PUSH
68393: LD_VAR 0 7
68397: PUSH
68398: LD_VAR 0 8
68402: PUSH
68403: LD_VAR 0 9
68407: PUSH
68408: EMPTY
68409: LIST
68410: LIST
68411: LIST
68412: LIST
68413: PPUSH
68414: LD_EXP 105
68418: PUSH
68419: LD_VAR 0 4
68423: ARRAY
68424: PUSH
68425: LD_VAR 0 5
68429: ARRAY
68430: PPUSH
68431: CALL 80040 0 2
68435: IFFALSE 68528
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
68437: LD_ADDR_EXP 105
68441: PUSH
68442: LD_EXP 105
68446: PPUSH
68447: LD_VAR 0 4
68451: PPUSH
68452: LD_EXP 105
68456: PUSH
68457: LD_VAR 0 4
68461: ARRAY
68462: PPUSH
68463: LD_VAR 0 5
68467: PPUSH
68468: CALL_OW 3
68472: PPUSH
68473: CALL_OW 1
68477: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
68478: LD_ADDR_EXP 107
68482: PUSH
68483: LD_EXP 107
68487: PPUSH
68488: LD_VAR 0 4
68492: PUSH
68493: LD_EXP 107
68497: PUSH
68498: LD_VAR 0 4
68502: ARRAY
68503: PUSH
68504: LD_INT 1
68506: PLUS
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: PPUSH
68512: LD_VAR 0 1
68516: PPUSH
68517: CALL 73860 0 3
68521: ST_TO_ADDR
// exit ;
68522: POP
68523: POP
68524: POP
68525: POP
68526: GO 68536
// end ;
68528: GO 68385
68530: POP
68531: POP
// end ;
68532: GO 68346
68534: POP
68535: POP
// end ;
68536: LD_VAR 0 3
68540: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
68541: LD_INT 0
68543: PPUSH
68544: PPUSH
68545: PPUSH
// if not mc_bases or not skirmish then
68546: LD_EXP 100
68550: NOT
68551: PUSH
68552: LD_EXP 98
68556: NOT
68557: OR
68558: IFFALSE 68562
// exit ;
68560: GO 68752
// for i = 1 to mc_bases do
68562: LD_ADDR_VAR 0 4
68566: PUSH
68567: DOUBLE
68568: LD_INT 1
68570: DEC
68571: ST_TO_ADDR
68572: LD_EXP 100
68576: PUSH
68577: FOR_TO
68578: IFFALSE 68665
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
68580: LD_VAR 0 1
68584: PUSH
68585: LD_EXP 108
68589: PUSH
68590: LD_VAR 0 4
68594: ARRAY
68595: IN
68596: PUSH
68597: LD_VAR 0 1
68601: PUSH
68602: LD_EXP 109
68606: PUSH
68607: LD_VAR 0 4
68611: ARRAY
68612: IN
68613: NOT
68614: AND
68615: IFFALSE 68663
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
68617: LD_ADDR_EXP 109
68621: PUSH
68622: LD_EXP 109
68626: PPUSH
68627: LD_VAR 0 4
68631: PUSH
68632: LD_EXP 109
68636: PUSH
68637: LD_VAR 0 4
68641: ARRAY
68642: PUSH
68643: LD_INT 1
68645: PLUS
68646: PUSH
68647: EMPTY
68648: LIST
68649: LIST
68650: PPUSH
68651: LD_VAR 0 1
68655: PPUSH
68656: CALL 73860 0 3
68660: ST_TO_ADDR
// break ;
68661: GO 68665
// end ; end ;
68663: GO 68577
68665: POP
68666: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
68667: LD_VAR 0 1
68671: PPUSH
68672: CALL_OW 257
68676: PUSH
68677: LD_EXP 126
68681: IN
68682: PUSH
68683: LD_VAR 0 1
68687: PPUSH
68688: CALL_OW 266
68692: PUSH
68693: LD_INT 5
68695: EQUAL
68696: AND
68697: PUSH
68698: LD_VAR 0 2
68702: PPUSH
68703: CALL_OW 110
68707: PUSH
68708: LD_INT 18
68710: NONEQUAL
68711: AND
68712: IFFALSE 68752
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
68714: LD_VAR 0 2
68718: PPUSH
68719: CALL_OW 257
68723: PUSH
68724: LD_INT 5
68726: PUSH
68727: LD_INT 8
68729: PUSH
68730: LD_INT 9
68732: PUSH
68733: EMPTY
68734: LIST
68735: LIST
68736: LIST
68737: IN
68738: IFFALSE 68752
// SetClass ( unit , 1 ) ;
68740: LD_VAR 0 2
68744: PPUSH
68745: LD_INT 1
68747: PPUSH
68748: CALL_OW 336
// end ;
68752: LD_VAR 0 3
68756: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
68757: LD_INT 0
68759: PPUSH
68760: PPUSH
// if not mc_bases or not skirmish then
68761: LD_EXP 100
68765: NOT
68766: PUSH
68767: LD_EXP 98
68771: NOT
68772: OR
68773: IFFALSE 68777
// exit ;
68775: GO 68893
// if GetLives ( abandoned_vehicle ) > 250 then
68777: LD_VAR 0 2
68781: PPUSH
68782: CALL_OW 256
68786: PUSH
68787: LD_INT 250
68789: GREATER
68790: IFFALSE 68794
// exit ;
68792: GO 68893
// for i = 1 to mc_bases do
68794: LD_ADDR_VAR 0 6
68798: PUSH
68799: DOUBLE
68800: LD_INT 1
68802: DEC
68803: ST_TO_ADDR
68804: LD_EXP 100
68808: PUSH
68809: FOR_TO
68810: IFFALSE 68891
// begin if driver in mc_bases [ i ] then
68812: LD_VAR 0 1
68816: PUSH
68817: LD_EXP 100
68821: PUSH
68822: LD_VAR 0 6
68826: ARRAY
68827: IN
68828: IFFALSE 68889
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
68830: LD_VAR 0 1
68834: PPUSH
68835: LD_EXP 100
68839: PUSH
68840: LD_VAR 0 6
68844: ARRAY
68845: PPUSH
68846: LD_INT 2
68848: PUSH
68849: LD_INT 30
68851: PUSH
68852: LD_INT 0
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: LD_INT 30
68861: PUSH
68862: LD_INT 1
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: PUSH
68869: EMPTY
68870: LIST
68871: LIST
68872: LIST
68873: PPUSH
68874: CALL_OW 72
68878: PUSH
68879: LD_INT 1
68881: ARRAY
68882: PPUSH
68883: CALL 107067 0 2
// break ;
68887: GO 68891
// end ; end ;
68889: GO 68809
68891: POP
68892: POP
// end ; end_of_file
68893: LD_VAR 0 5
68897: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
68898: LD_INT 0
68900: PPUSH
68901: PPUSH
// if exist_mode then
68902: LD_VAR 0 2
68906: IFFALSE 68931
// unit := CreateCharacter ( prefix & ident ) else
68908: LD_ADDR_VAR 0 5
68912: PUSH
68913: LD_VAR 0 3
68917: PUSH
68918: LD_VAR 0 1
68922: STR
68923: PPUSH
68924: CALL_OW 34
68928: ST_TO_ADDR
68929: GO 68946
// unit := NewCharacter ( ident ) ;
68931: LD_ADDR_VAR 0 5
68935: PUSH
68936: LD_VAR 0 1
68940: PPUSH
68941: CALL_OW 25
68945: ST_TO_ADDR
// result := unit ;
68946: LD_ADDR_VAR 0 4
68950: PUSH
68951: LD_VAR 0 5
68955: ST_TO_ADDR
// end ;
68956: LD_VAR 0 4
68960: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
68961: LD_INT 0
68963: PPUSH
68964: PPUSH
// if not side or not nation then
68965: LD_VAR 0 1
68969: NOT
68970: PUSH
68971: LD_VAR 0 2
68975: NOT
68976: OR
68977: IFFALSE 68981
// exit ;
68979: GO 69749
// case nation of nation_american :
68981: LD_VAR 0 2
68985: PUSH
68986: LD_INT 1
68988: DOUBLE
68989: EQUAL
68990: IFTRUE 68994
68992: GO 69208
68994: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
68995: LD_ADDR_VAR 0 4
68999: PUSH
69000: LD_INT 35
69002: PUSH
69003: LD_INT 45
69005: PUSH
69006: LD_INT 46
69008: PUSH
69009: LD_INT 47
69011: PUSH
69012: LD_INT 82
69014: PUSH
69015: LD_INT 83
69017: PUSH
69018: LD_INT 84
69020: PUSH
69021: LD_INT 85
69023: PUSH
69024: LD_INT 86
69026: PUSH
69027: LD_INT 1
69029: PUSH
69030: LD_INT 2
69032: PUSH
69033: LD_INT 6
69035: PUSH
69036: LD_INT 15
69038: PUSH
69039: LD_INT 16
69041: PUSH
69042: LD_INT 7
69044: PUSH
69045: LD_INT 12
69047: PUSH
69048: LD_INT 13
69050: PUSH
69051: LD_INT 10
69053: PUSH
69054: LD_INT 14
69056: PUSH
69057: LD_INT 20
69059: PUSH
69060: LD_INT 21
69062: PUSH
69063: LD_INT 22
69065: PUSH
69066: LD_INT 25
69068: PUSH
69069: LD_INT 32
69071: PUSH
69072: LD_INT 27
69074: PUSH
69075: LD_INT 36
69077: PUSH
69078: LD_INT 69
69080: PUSH
69081: LD_INT 39
69083: PUSH
69084: LD_INT 34
69086: PUSH
69087: LD_INT 40
69089: PUSH
69090: LD_INT 48
69092: PUSH
69093: LD_INT 49
69095: PUSH
69096: LD_INT 50
69098: PUSH
69099: LD_INT 51
69101: PUSH
69102: LD_INT 52
69104: PUSH
69105: LD_INT 53
69107: PUSH
69108: LD_INT 54
69110: PUSH
69111: LD_INT 55
69113: PUSH
69114: LD_INT 56
69116: PUSH
69117: LD_INT 57
69119: PUSH
69120: LD_INT 58
69122: PUSH
69123: LD_INT 59
69125: PUSH
69126: LD_INT 60
69128: PUSH
69129: LD_INT 61
69131: PUSH
69132: LD_INT 62
69134: PUSH
69135: LD_INT 80
69137: PUSH
69138: LD_INT 82
69140: PUSH
69141: LD_INT 83
69143: PUSH
69144: LD_INT 84
69146: PUSH
69147: LD_INT 85
69149: PUSH
69150: LD_INT 86
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: LIST
69157: LIST
69158: LIST
69159: LIST
69160: LIST
69161: LIST
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: LIST
69179: LIST
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: LIST
69190: LIST
69191: LIST
69192: LIST
69193: LIST
69194: LIST
69195: LIST
69196: LIST
69197: LIST
69198: LIST
69199: LIST
69200: LIST
69201: LIST
69202: LIST
69203: LIST
69204: LIST
69205: ST_TO_ADDR
69206: GO 69673
69208: LD_INT 2
69210: DOUBLE
69211: EQUAL
69212: IFTRUE 69216
69214: GO 69442
69216: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
69217: LD_ADDR_VAR 0 4
69221: PUSH
69222: LD_INT 35
69224: PUSH
69225: LD_INT 45
69227: PUSH
69228: LD_INT 46
69230: PUSH
69231: LD_INT 47
69233: PUSH
69234: LD_INT 82
69236: PUSH
69237: LD_INT 83
69239: PUSH
69240: LD_INT 84
69242: PUSH
69243: LD_INT 85
69245: PUSH
69246: LD_INT 87
69248: PUSH
69249: LD_INT 70
69251: PUSH
69252: LD_INT 1
69254: PUSH
69255: LD_INT 11
69257: PUSH
69258: LD_INT 3
69260: PUSH
69261: LD_INT 4
69263: PUSH
69264: LD_INT 5
69266: PUSH
69267: LD_INT 6
69269: PUSH
69270: LD_INT 15
69272: PUSH
69273: LD_INT 18
69275: PUSH
69276: LD_INT 7
69278: PUSH
69279: LD_INT 17
69281: PUSH
69282: LD_INT 8
69284: PUSH
69285: LD_INT 20
69287: PUSH
69288: LD_INT 21
69290: PUSH
69291: LD_INT 22
69293: PUSH
69294: LD_INT 72
69296: PUSH
69297: LD_INT 26
69299: PUSH
69300: LD_INT 69
69302: PUSH
69303: LD_INT 39
69305: PUSH
69306: LD_INT 40
69308: PUSH
69309: LD_INT 41
69311: PUSH
69312: LD_INT 42
69314: PUSH
69315: LD_INT 43
69317: PUSH
69318: LD_INT 48
69320: PUSH
69321: LD_INT 49
69323: PUSH
69324: LD_INT 50
69326: PUSH
69327: LD_INT 51
69329: PUSH
69330: LD_INT 52
69332: PUSH
69333: LD_INT 53
69335: PUSH
69336: LD_INT 54
69338: PUSH
69339: LD_INT 55
69341: PUSH
69342: LD_INT 56
69344: PUSH
69345: LD_INT 60
69347: PUSH
69348: LD_INT 61
69350: PUSH
69351: LD_INT 62
69353: PUSH
69354: LD_INT 66
69356: PUSH
69357: LD_INT 67
69359: PUSH
69360: LD_INT 68
69362: PUSH
69363: LD_INT 81
69365: PUSH
69366: LD_INT 82
69368: PUSH
69369: LD_INT 83
69371: PUSH
69372: LD_INT 84
69374: PUSH
69375: LD_INT 85
69377: PUSH
69378: LD_INT 87
69380: PUSH
69381: LD_INT 88
69383: PUSH
69384: EMPTY
69385: LIST
69386: LIST
69387: LIST
69388: LIST
69389: LIST
69390: LIST
69391: LIST
69392: LIST
69393: LIST
69394: LIST
69395: LIST
69396: LIST
69397: LIST
69398: LIST
69399: LIST
69400: LIST
69401: LIST
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: LIST
69414: LIST
69415: LIST
69416: LIST
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: LIST
69434: LIST
69435: LIST
69436: LIST
69437: LIST
69438: LIST
69439: ST_TO_ADDR
69440: GO 69673
69442: LD_INT 3
69444: DOUBLE
69445: EQUAL
69446: IFTRUE 69450
69448: GO 69672
69450: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
69451: LD_ADDR_VAR 0 4
69455: PUSH
69456: LD_INT 46
69458: PUSH
69459: LD_INT 47
69461: PUSH
69462: LD_INT 1
69464: PUSH
69465: LD_INT 2
69467: PUSH
69468: LD_INT 82
69470: PUSH
69471: LD_INT 83
69473: PUSH
69474: LD_INT 84
69476: PUSH
69477: LD_INT 85
69479: PUSH
69480: LD_INT 86
69482: PUSH
69483: LD_INT 11
69485: PUSH
69486: LD_INT 9
69488: PUSH
69489: LD_INT 20
69491: PUSH
69492: LD_INT 19
69494: PUSH
69495: LD_INT 21
69497: PUSH
69498: LD_INT 24
69500: PUSH
69501: LD_INT 22
69503: PUSH
69504: LD_INT 25
69506: PUSH
69507: LD_INT 28
69509: PUSH
69510: LD_INT 29
69512: PUSH
69513: LD_INT 30
69515: PUSH
69516: LD_INT 31
69518: PUSH
69519: LD_INT 37
69521: PUSH
69522: LD_INT 38
69524: PUSH
69525: LD_INT 32
69527: PUSH
69528: LD_INT 27
69530: PUSH
69531: LD_INT 33
69533: PUSH
69534: LD_INT 69
69536: PUSH
69537: LD_INT 39
69539: PUSH
69540: LD_INT 34
69542: PUSH
69543: LD_INT 40
69545: PUSH
69546: LD_INT 71
69548: PUSH
69549: LD_INT 23
69551: PUSH
69552: LD_INT 44
69554: PUSH
69555: LD_INT 48
69557: PUSH
69558: LD_INT 49
69560: PUSH
69561: LD_INT 50
69563: PUSH
69564: LD_INT 51
69566: PUSH
69567: LD_INT 52
69569: PUSH
69570: LD_INT 53
69572: PUSH
69573: LD_INT 54
69575: PUSH
69576: LD_INT 55
69578: PUSH
69579: LD_INT 56
69581: PUSH
69582: LD_INT 57
69584: PUSH
69585: LD_INT 58
69587: PUSH
69588: LD_INT 59
69590: PUSH
69591: LD_INT 63
69593: PUSH
69594: LD_INT 64
69596: PUSH
69597: LD_INT 65
69599: PUSH
69600: LD_INT 82
69602: PUSH
69603: LD_INT 83
69605: PUSH
69606: LD_INT 84
69608: PUSH
69609: LD_INT 85
69611: PUSH
69612: LD_INT 86
69614: PUSH
69615: EMPTY
69616: LIST
69617: LIST
69618: LIST
69619: LIST
69620: LIST
69621: LIST
69622: LIST
69623: LIST
69624: LIST
69625: LIST
69626: LIST
69627: LIST
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: LIST
69638: LIST
69639: LIST
69640: LIST
69641: LIST
69642: LIST
69643: LIST
69644: LIST
69645: LIST
69646: LIST
69647: LIST
69648: LIST
69649: LIST
69650: LIST
69651: LIST
69652: LIST
69653: LIST
69654: LIST
69655: LIST
69656: LIST
69657: LIST
69658: LIST
69659: LIST
69660: LIST
69661: LIST
69662: LIST
69663: LIST
69664: LIST
69665: LIST
69666: LIST
69667: LIST
69668: LIST
69669: ST_TO_ADDR
69670: GO 69673
69672: POP
// if state > - 1 and state < 3 then
69673: LD_VAR 0 3
69677: PUSH
69678: LD_INT 1
69680: NEG
69681: GREATER
69682: PUSH
69683: LD_VAR 0 3
69687: PUSH
69688: LD_INT 3
69690: LESS
69691: AND
69692: IFFALSE 69749
// for i in result do
69694: LD_ADDR_VAR 0 5
69698: PUSH
69699: LD_VAR 0 4
69703: PUSH
69704: FOR_IN
69705: IFFALSE 69747
// if GetTech ( i , side ) <> state then
69707: LD_VAR 0 5
69711: PPUSH
69712: LD_VAR 0 1
69716: PPUSH
69717: CALL_OW 321
69721: PUSH
69722: LD_VAR 0 3
69726: NONEQUAL
69727: IFFALSE 69745
// result := result diff i ;
69729: LD_ADDR_VAR 0 4
69733: PUSH
69734: LD_VAR 0 4
69738: PUSH
69739: LD_VAR 0 5
69743: DIFF
69744: ST_TO_ADDR
69745: GO 69704
69747: POP
69748: POP
// end ;
69749: LD_VAR 0 4
69753: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
69754: LD_INT 0
69756: PPUSH
69757: PPUSH
69758: PPUSH
// result := true ;
69759: LD_ADDR_VAR 0 3
69763: PUSH
69764: LD_INT 1
69766: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
69767: LD_ADDR_VAR 0 5
69771: PUSH
69772: LD_VAR 0 2
69776: PPUSH
69777: CALL_OW 480
69781: ST_TO_ADDR
// if not tmp then
69782: LD_VAR 0 5
69786: NOT
69787: IFFALSE 69791
// exit ;
69789: GO 69840
// for i in tmp do
69791: LD_ADDR_VAR 0 4
69795: PUSH
69796: LD_VAR 0 5
69800: PUSH
69801: FOR_IN
69802: IFFALSE 69838
// if GetTech ( i , side ) <> state_researched then
69804: LD_VAR 0 4
69808: PPUSH
69809: LD_VAR 0 1
69813: PPUSH
69814: CALL_OW 321
69818: PUSH
69819: LD_INT 2
69821: NONEQUAL
69822: IFFALSE 69836
// begin result := false ;
69824: LD_ADDR_VAR 0 3
69828: PUSH
69829: LD_INT 0
69831: ST_TO_ADDR
// exit ;
69832: POP
69833: POP
69834: GO 69840
// end ;
69836: GO 69801
69838: POP
69839: POP
// end ;
69840: LD_VAR 0 3
69844: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
69845: LD_INT 0
69847: PPUSH
69848: PPUSH
69849: PPUSH
69850: PPUSH
69851: PPUSH
69852: PPUSH
69853: PPUSH
69854: PPUSH
69855: PPUSH
69856: PPUSH
69857: PPUSH
69858: PPUSH
69859: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
69860: LD_VAR 0 1
69864: NOT
69865: PUSH
69866: LD_VAR 0 1
69870: PPUSH
69871: CALL_OW 257
69875: PUSH
69876: LD_INT 9
69878: NONEQUAL
69879: OR
69880: IFFALSE 69884
// exit ;
69882: GO 70457
// side := GetSide ( unit ) ;
69884: LD_ADDR_VAR 0 9
69888: PUSH
69889: LD_VAR 0 1
69893: PPUSH
69894: CALL_OW 255
69898: ST_TO_ADDR
// tech_space := tech_spacanom ;
69899: LD_ADDR_VAR 0 12
69903: PUSH
69904: LD_INT 29
69906: ST_TO_ADDR
// tech_time := tech_taurad ;
69907: LD_ADDR_VAR 0 13
69911: PUSH
69912: LD_INT 28
69914: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
69915: LD_ADDR_VAR 0 11
69919: PUSH
69920: LD_VAR 0 1
69924: PPUSH
69925: CALL_OW 310
69929: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
69930: LD_VAR 0 11
69934: PPUSH
69935: CALL_OW 247
69939: PUSH
69940: LD_INT 2
69942: EQUAL
69943: IFFALSE 69947
// exit ;
69945: GO 70457
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69947: LD_ADDR_VAR 0 8
69951: PUSH
69952: LD_INT 81
69954: PUSH
69955: LD_VAR 0 9
69959: PUSH
69960: EMPTY
69961: LIST
69962: LIST
69963: PUSH
69964: LD_INT 3
69966: PUSH
69967: LD_INT 21
69969: PUSH
69970: LD_INT 3
69972: PUSH
69973: EMPTY
69974: LIST
69975: LIST
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: EMPTY
69982: LIST
69983: LIST
69984: PPUSH
69985: CALL_OW 69
69989: ST_TO_ADDR
// if not tmp then
69990: LD_VAR 0 8
69994: NOT
69995: IFFALSE 69999
// exit ;
69997: GO 70457
// if in_unit then
69999: LD_VAR 0 11
70003: IFFALSE 70027
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
70005: LD_ADDR_VAR 0 10
70009: PUSH
70010: LD_VAR 0 8
70014: PPUSH
70015: LD_VAR 0 11
70019: PPUSH
70020: CALL_OW 74
70024: ST_TO_ADDR
70025: GO 70047
// enemy := NearestUnitToUnit ( tmp , unit ) ;
70027: LD_ADDR_VAR 0 10
70031: PUSH
70032: LD_VAR 0 8
70036: PPUSH
70037: LD_VAR 0 1
70041: PPUSH
70042: CALL_OW 74
70046: ST_TO_ADDR
// if not enemy then
70047: LD_VAR 0 10
70051: NOT
70052: IFFALSE 70056
// exit ;
70054: GO 70457
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
70056: LD_VAR 0 11
70060: PUSH
70061: LD_VAR 0 11
70065: PPUSH
70066: LD_VAR 0 10
70070: PPUSH
70071: CALL_OW 296
70075: PUSH
70076: LD_INT 13
70078: GREATER
70079: AND
70080: PUSH
70081: LD_VAR 0 1
70085: PPUSH
70086: LD_VAR 0 10
70090: PPUSH
70091: CALL_OW 296
70095: PUSH
70096: LD_INT 12
70098: GREATER
70099: OR
70100: IFFALSE 70104
// exit ;
70102: GO 70457
// missile := [ 1 ] ;
70104: LD_ADDR_VAR 0 14
70108: PUSH
70109: LD_INT 1
70111: PUSH
70112: EMPTY
70113: LIST
70114: ST_TO_ADDR
// if Researched ( side , tech_space ) then
70115: LD_VAR 0 9
70119: PPUSH
70120: LD_VAR 0 12
70124: PPUSH
70125: CALL_OW 325
70129: IFFALSE 70158
// missile := Replace ( missile , missile + 1 , 2 ) ;
70131: LD_ADDR_VAR 0 14
70135: PUSH
70136: LD_VAR 0 14
70140: PPUSH
70141: LD_VAR 0 14
70145: PUSH
70146: LD_INT 1
70148: PLUS
70149: PPUSH
70150: LD_INT 2
70152: PPUSH
70153: CALL_OW 1
70157: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
70158: LD_VAR 0 9
70162: PPUSH
70163: LD_VAR 0 13
70167: PPUSH
70168: CALL_OW 325
70172: PUSH
70173: LD_VAR 0 10
70177: PPUSH
70178: CALL_OW 255
70182: PPUSH
70183: LD_VAR 0 13
70187: PPUSH
70188: CALL_OW 325
70192: NOT
70193: AND
70194: IFFALSE 70223
// missile := Replace ( missile , missile + 1 , 3 ) ;
70196: LD_ADDR_VAR 0 14
70200: PUSH
70201: LD_VAR 0 14
70205: PPUSH
70206: LD_VAR 0 14
70210: PUSH
70211: LD_INT 1
70213: PLUS
70214: PPUSH
70215: LD_INT 3
70217: PPUSH
70218: CALL_OW 1
70222: ST_TO_ADDR
// if missile < 2 then
70223: LD_VAR 0 14
70227: PUSH
70228: LD_INT 2
70230: LESS
70231: IFFALSE 70235
// exit ;
70233: GO 70457
// x := GetX ( enemy ) ;
70235: LD_ADDR_VAR 0 4
70239: PUSH
70240: LD_VAR 0 10
70244: PPUSH
70245: CALL_OW 250
70249: ST_TO_ADDR
// y := GetY ( enemy ) ;
70250: LD_ADDR_VAR 0 5
70254: PUSH
70255: LD_VAR 0 10
70259: PPUSH
70260: CALL_OW 251
70264: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
70265: LD_ADDR_VAR 0 6
70269: PUSH
70270: LD_VAR 0 4
70274: PUSH
70275: LD_INT 1
70277: NEG
70278: PPUSH
70279: LD_INT 1
70281: PPUSH
70282: CALL_OW 12
70286: PLUS
70287: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
70288: LD_ADDR_VAR 0 7
70292: PUSH
70293: LD_VAR 0 5
70297: PUSH
70298: LD_INT 1
70300: NEG
70301: PPUSH
70302: LD_INT 1
70304: PPUSH
70305: CALL_OW 12
70309: PLUS
70310: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
70311: LD_VAR 0 6
70315: PPUSH
70316: LD_VAR 0 7
70320: PPUSH
70321: CALL_OW 488
70325: NOT
70326: IFFALSE 70348
// begin _x := x ;
70328: LD_ADDR_VAR 0 6
70332: PUSH
70333: LD_VAR 0 4
70337: ST_TO_ADDR
// _y := y ;
70338: LD_ADDR_VAR 0 7
70342: PUSH
70343: LD_VAR 0 5
70347: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
70348: LD_ADDR_VAR 0 3
70352: PUSH
70353: LD_INT 1
70355: PPUSH
70356: LD_VAR 0 14
70360: PPUSH
70361: CALL_OW 12
70365: ST_TO_ADDR
// case i of 1 :
70366: LD_VAR 0 3
70370: PUSH
70371: LD_INT 1
70373: DOUBLE
70374: EQUAL
70375: IFTRUE 70379
70377: GO 70396
70379: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
70380: LD_VAR 0 1
70384: PPUSH
70385: LD_VAR 0 10
70389: PPUSH
70390: CALL_OW 115
70394: GO 70457
70396: LD_INT 2
70398: DOUBLE
70399: EQUAL
70400: IFTRUE 70404
70402: GO 70426
70404: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
70405: LD_VAR 0 1
70409: PPUSH
70410: LD_VAR 0 6
70414: PPUSH
70415: LD_VAR 0 7
70419: PPUSH
70420: CALL_OW 153
70424: GO 70457
70426: LD_INT 3
70428: DOUBLE
70429: EQUAL
70430: IFTRUE 70434
70432: GO 70456
70434: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
70435: LD_VAR 0 1
70439: PPUSH
70440: LD_VAR 0 6
70444: PPUSH
70445: LD_VAR 0 7
70449: PPUSH
70450: CALL_OW 154
70454: GO 70457
70456: POP
// end ;
70457: LD_VAR 0 2
70461: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
70462: LD_INT 0
70464: PPUSH
70465: PPUSH
70466: PPUSH
70467: PPUSH
70468: PPUSH
70469: PPUSH
// if not unit or not building then
70470: LD_VAR 0 1
70474: NOT
70475: PUSH
70476: LD_VAR 0 2
70480: NOT
70481: OR
70482: IFFALSE 70486
// exit ;
70484: GO 70644
// x := GetX ( building ) ;
70486: LD_ADDR_VAR 0 5
70490: PUSH
70491: LD_VAR 0 2
70495: PPUSH
70496: CALL_OW 250
70500: ST_TO_ADDR
// y := GetY ( building ) ;
70501: LD_ADDR_VAR 0 6
70505: PUSH
70506: LD_VAR 0 2
70510: PPUSH
70511: CALL_OW 251
70515: ST_TO_ADDR
// for i = 0 to 5 do
70516: LD_ADDR_VAR 0 4
70520: PUSH
70521: DOUBLE
70522: LD_INT 0
70524: DEC
70525: ST_TO_ADDR
70526: LD_INT 5
70528: PUSH
70529: FOR_TO
70530: IFFALSE 70642
// begin _x := ShiftX ( x , i , 3 ) ;
70532: LD_ADDR_VAR 0 7
70536: PUSH
70537: LD_VAR 0 5
70541: PPUSH
70542: LD_VAR 0 4
70546: PPUSH
70547: LD_INT 3
70549: PPUSH
70550: CALL_OW 272
70554: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
70555: LD_ADDR_VAR 0 8
70559: PUSH
70560: LD_VAR 0 6
70564: PPUSH
70565: LD_VAR 0 4
70569: PPUSH
70570: LD_INT 3
70572: PPUSH
70573: CALL_OW 273
70577: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
70578: LD_VAR 0 7
70582: PPUSH
70583: LD_VAR 0 8
70587: PPUSH
70588: CALL_OW 488
70592: NOT
70593: IFFALSE 70597
// continue ;
70595: GO 70529
// if HexInfo ( _x , _y ) = 0 then
70597: LD_VAR 0 7
70601: PPUSH
70602: LD_VAR 0 8
70606: PPUSH
70607: CALL_OW 428
70611: PUSH
70612: LD_INT 0
70614: EQUAL
70615: IFFALSE 70640
// begin ComMoveXY ( unit , _x , _y ) ;
70617: LD_VAR 0 1
70621: PPUSH
70622: LD_VAR 0 7
70626: PPUSH
70627: LD_VAR 0 8
70631: PPUSH
70632: CALL_OW 111
// exit ;
70636: POP
70637: POP
70638: GO 70644
// end ; end ;
70640: GO 70529
70642: POP
70643: POP
// end ;
70644: LD_VAR 0 3
70648: RET
// export function ScanBase ( side , base_area ) ; begin
70649: LD_INT 0
70651: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
70652: LD_ADDR_VAR 0 3
70656: PUSH
70657: LD_VAR 0 2
70661: PPUSH
70662: LD_INT 81
70664: PUSH
70665: LD_VAR 0 1
70669: PUSH
70670: EMPTY
70671: LIST
70672: LIST
70673: PPUSH
70674: CALL_OW 70
70678: ST_TO_ADDR
// end ;
70679: LD_VAR 0 3
70683: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
70684: LD_INT 0
70686: PPUSH
70687: PPUSH
70688: PPUSH
70689: PPUSH
// result := false ;
70690: LD_ADDR_VAR 0 2
70694: PUSH
70695: LD_INT 0
70697: ST_TO_ADDR
// side := GetSide ( unit ) ;
70698: LD_ADDR_VAR 0 3
70702: PUSH
70703: LD_VAR 0 1
70707: PPUSH
70708: CALL_OW 255
70712: ST_TO_ADDR
// nat := GetNation ( unit ) ;
70713: LD_ADDR_VAR 0 4
70717: PUSH
70718: LD_VAR 0 1
70722: PPUSH
70723: CALL_OW 248
70727: ST_TO_ADDR
// case nat of 1 :
70728: LD_VAR 0 4
70732: PUSH
70733: LD_INT 1
70735: DOUBLE
70736: EQUAL
70737: IFTRUE 70741
70739: GO 70752
70741: POP
// tech := tech_lassight ; 2 :
70742: LD_ADDR_VAR 0 5
70746: PUSH
70747: LD_INT 12
70749: ST_TO_ADDR
70750: GO 70791
70752: LD_INT 2
70754: DOUBLE
70755: EQUAL
70756: IFTRUE 70760
70758: GO 70771
70760: POP
// tech := tech_mortar ; 3 :
70761: LD_ADDR_VAR 0 5
70765: PUSH
70766: LD_INT 41
70768: ST_TO_ADDR
70769: GO 70791
70771: LD_INT 3
70773: DOUBLE
70774: EQUAL
70775: IFTRUE 70779
70777: GO 70790
70779: POP
// tech := tech_bazooka ; end ;
70780: LD_ADDR_VAR 0 5
70784: PUSH
70785: LD_INT 44
70787: ST_TO_ADDR
70788: GO 70791
70790: POP
// if Researched ( side , tech ) then
70791: LD_VAR 0 3
70795: PPUSH
70796: LD_VAR 0 5
70800: PPUSH
70801: CALL_OW 325
70805: IFFALSE 70832
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
70807: LD_ADDR_VAR 0 2
70811: PUSH
70812: LD_INT 5
70814: PUSH
70815: LD_INT 8
70817: PUSH
70818: LD_INT 9
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: LIST
70825: PUSH
70826: LD_VAR 0 4
70830: ARRAY
70831: ST_TO_ADDR
// end ;
70832: LD_VAR 0 2
70836: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
70837: LD_INT 0
70839: PPUSH
70840: PPUSH
70841: PPUSH
// if not mines then
70842: LD_VAR 0 2
70846: NOT
70847: IFFALSE 70851
// exit ;
70849: GO 70995
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70851: LD_ADDR_VAR 0 5
70855: PUSH
70856: LD_INT 81
70858: PUSH
70859: LD_VAR 0 1
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: LD_INT 3
70870: PUSH
70871: LD_INT 21
70873: PUSH
70874: LD_INT 3
70876: PUSH
70877: EMPTY
70878: LIST
70879: LIST
70880: PUSH
70881: EMPTY
70882: LIST
70883: LIST
70884: PUSH
70885: EMPTY
70886: LIST
70887: LIST
70888: PPUSH
70889: CALL_OW 69
70893: ST_TO_ADDR
// for i in mines do
70894: LD_ADDR_VAR 0 4
70898: PUSH
70899: LD_VAR 0 2
70903: PUSH
70904: FOR_IN
70905: IFFALSE 70993
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
70907: LD_VAR 0 4
70911: PUSH
70912: LD_INT 1
70914: ARRAY
70915: PPUSH
70916: LD_VAR 0 4
70920: PUSH
70921: LD_INT 2
70923: ARRAY
70924: PPUSH
70925: CALL_OW 458
70929: NOT
70930: IFFALSE 70934
// continue ;
70932: GO 70904
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
70934: LD_VAR 0 4
70938: PUSH
70939: LD_INT 1
70941: ARRAY
70942: PPUSH
70943: LD_VAR 0 4
70947: PUSH
70948: LD_INT 2
70950: ARRAY
70951: PPUSH
70952: CALL_OW 428
70956: PUSH
70957: LD_VAR 0 5
70961: IN
70962: IFFALSE 70991
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
70964: LD_VAR 0 4
70968: PUSH
70969: LD_INT 1
70971: ARRAY
70972: PPUSH
70973: LD_VAR 0 4
70977: PUSH
70978: LD_INT 2
70980: ARRAY
70981: PPUSH
70982: LD_VAR 0 1
70986: PPUSH
70987: CALL_OW 456
// end ;
70991: GO 70904
70993: POP
70994: POP
// end ;
70995: LD_VAR 0 3
70999: RET
// export function Count ( array ) ; begin
71000: LD_INT 0
71002: PPUSH
// result := array + 0 ;
71003: LD_ADDR_VAR 0 2
71007: PUSH
71008: LD_VAR 0 1
71012: PUSH
71013: LD_INT 0
71015: PLUS
71016: ST_TO_ADDR
// end ;
71017: LD_VAR 0 2
71021: RET
// export function IsEmpty ( building ) ; begin
71022: LD_INT 0
71024: PPUSH
// if not building then
71025: LD_VAR 0 1
71029: NOT
71030: IFFALSE 71034
// exit ;
71032: GO 71077
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
71034: LD_ADDR_VAR 0 2
71038: PUSH
71039: LD_VAR 0 1
71043: PUSH
71044: LD_INT 22
71046: PUSH
71047: LD_VAR 0 1
71051: PPUSH
71052: CALL_OW 255
71056: PUSH
71057: EMPTY
71058: LIST
71059: LIST
71060: PUSH
71061: LD_INT 58
71063: PUSH
71064: EMPTY
71065: LIST
71066: PUSH
71067: EMPTY
71068: LIST
71069: LIST
71070: PPUSH
71071: CALL_OW 69
71075: IN
71076: ST_TO_ADDR
// end ;
71077: LD_VAR 0 2
71081: RET
// export function IsNotFull ( building ) ; var places ; begin
71082: LD_INT 0
71084: PPUSH
71085: PPUSH
// if not building then
71086: LD_VAR 0 1
71090: NOT
71091: IFFALSE 71095
// exit ;
71093: GO 71123
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
71095: LD_ADDR_VAR 0 2
71099: PUSH
71100: LD_VAR 0 1
71104: PPUSH
71105: LD_INT 3
71107: PUSH
71108: LD_INT 62
71110: PUSH
71111: EMPTY
71112: LIST
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PPUSH
71118: CALL_OW 72
71122: ST_TO_ADDR
// end ;
71123: LD_VAR 0 2
71127: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
71128: LD_INT 0
71130: PPUSH
71131: PPUSH
71132: PPUSH
71133: PPUSH
// tmp := [ ] ;
71134: LD_ADDR_VAR 0 3
71138: PUSH
71139: EMPTY
71140: ST_TO_ADDR
// list := [ ] ;
71141: LD_ADDR_VAR 0 5
71145: PUSH
71146: EMPTY
71147: ST_TO_ADDR
// for i = 16 to 25 do
71148: LD_ADDR_VAR 0 4
71152: PUSH
71153: DOUBLE
71154: LD_INT 16
71156: DEC
71157: ST_TO_ADDR
71158: LD_INT 25
71160: PUSH
71161: FOR_TO
71162: IFFALSE 71235
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
71164: LD_ADDR_VAR 0 3
71168: PUSH
71169: LD_VAR 0 3
71173: PUSH
71174: LD_INT 22
71176: PUSH
71177: LD_VAR 0 1
71181: PPUSH
71182: CALL_OW 255
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PUSH
71191: LD_INT 91
71193: PUSH
71194: LD_VAR 0 1
71198: PUSH
71199: LD_INT 6
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: LIST
71206: PUSH
71207: LD_INT 30
71209: PUSH
71210: LD_VAR 0 4
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: PUSH
71219: EMPTY
71220: LIST
71221: LIST
71222: LIST
71223: PUSH
71224: EMPTY
71225: LIST
71226: PPUSH
71227: CALL_OW 69
71231: ADD
71232: ST_TO_ADDR
71233: GO 71161
71235: POP
71236: POP
// for i = 1 to tmp do
71237: LD_ADDR_VAR 0 4
71241: PUSH
71242: DOUBLE
71243: LD_INT 1
71245: DEC
71246: ST_TO_ADDR
71247: LD_VAR 0 3
71251: PUSH
71252: FOR_TO
71253: IFFALSE 71341
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
71255: LD_ADDR_VAR 0 5
71259: PUSH
71260: LD_VAR 0 5
71264: PUSH
71265: LD_VAR 0 3
71269: PUSH
71270: LD_VAR 0 4
71274: ARRAY
71275: PPUSH
71276: CALL_OW 266
71280: PUSH
71281: LD_VAR 0 3
71285: PUSH
71286: LD_VAR 0 4
71290: ARRAY
71291: PPUSH
71292: CALL_OW 250
71296: PUSH
71297: LD_VAR 0 3
71301: PUSH
71302: LD_VAR 0 4
71306: ARRAY
71307: PPUSH
71308: CALL_OW 251
71312: PUSH
71313: LD_VAR 0 3
71317: PUSH
71318: LD_VAR 0 4
71322: ARRAY
71323: PPUSH
71324: CALL_OW 254
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: LIST
71333: LIST
71334: PUSH
71335: EMPTY
71336: LIST
71337: ADD
71338: ST_TO_ADDR
71339: GO 71252
71341: POP
71342: POP
// result := list ;
71343: LD_ADDR_VAR 0 2
71347: PUSH
71348: LD_VAR 0 5
71352: ST_TO_ADDR
// end ;
71353: LD_VAR 0 2
71357: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
71358: LD_INT 0
71360: PPUSH
71361: PPUSH
71362: PPUSH
71363: PPUSH
71364: PPUSH
71365: PPUSH
71366: PPUSH
// if not factory then
71367: LD_VAR 0 1
71371: NOT
71372: IFFALSE 71376
// exit ;
71374: GO 71969
// if control = control_apeman then
71376: LD_VAR 0 4
71380: PUSH
71381: LD_INT 5
71383: EQUAL
71384: IFFALSE 71493
// begin tmp := UnitsInside ( factory ) ;
71386: LD_ADDR_VAR 0 8
71390: PUSH
71391: LD_VAR 0 1
71395: PPUSH
71396: CALL_OW 313
71400: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
71401: LD_VAR 0 8
71405: PPUSH
71406: LD_INT 25
71408: PUSH
71409: LD_INT 12
71411: PUSH
71412: EMPTY
71413: LIST
71414: LIST
71415: PPUSH
71416: CALL_OW 72
71420: NOT
71421: IFFALSE 71431
// control := control_manual ;
71423: LD_ADDR_VAR 0 4
71427: PUSH
71428: LD_INT 1
71430: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
71431: LD_ADDR_VAR 0 8
71435: PUSH
71436: LD_VAR 0 1
71440: PPUSH
71441: CALL 71128 0 1
71445: ST_TO_ADDR
// if tmp then
71446: LD_VAR 0 8
71450: IFFALSE 71493
// begin for i in tmp do
71452: LD_ADDR_VAR 0 7
71456: PUSH
71457: LD_VAR 0 8
71461: PUSH
71462: FOR_IN
71463: IFFALSE 71491
// if i [ 1 ] = b_ext_radio then
71465: LD_VAR 0 7
71469: PUSH
71470: LD_INT 1
71472: ARRAY
71473: PUSH
71474: LD_INT 22
71476: EQUAL
71477: IFFALSE 71489
// begin control := control_remote ;
71479: LD_ADDR_VAR 0 4
71483: PUSH
71484: LD_INT 2
71486: ST_TO_ADDR
// break ;
71487: GO 71491
// end ;
71489: GO 71462
71491: POP
71492: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
71493: LD_VAR 0 1
71497: PPUSH
71498: LD_VAR 0 2
71502: PPUSH
71503: LD_VAR 0 3
71507: PPUSH
71508: LD_VAR 0 4
71512: PPUSH
71513: LD_VAR 0 5
71517: PPUSH
71518: CALL_OW 448
71522: IFFALSE 71557
// begin result := [ chassis , engine , control , weapon ] ;
71524: LD_ADDR_VAR 0 6
71528: PUSH
71529: LD_VAR 0 2
71533: PUSH
71534: LD_VAR 0 3
71538: PUSH
71539: LD_VAR 0 4
71543: PUSH
71544: LD_VAR 0 5
71548: PUSH
71549: EMPTY
71550: LIST
71551: LIST
71552: LIST
71553: LIST
71554: ST_TO_ADDR
// exit ;
71555: GO 71969
// end ; _chassis := AvailableChassisList ( factory ) ;
71557: LD_ADDR_VAR 0 9
71561: PUSH
71562: LD_VAR 0 1
71566: PPUSH
71567: CALL_OW 475
71571: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
71572: LD_ADDR_VAR 0 11
71576: PUSH
71577: LD_VAR 0 1
71581: PPUSH
71582: CALL_OW 476
71586: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
71587: LD_ADDR_VAR 0 12
71591: PUSH
71592: LD_VAR 0 1
71596: PPUSH
71597: CALL_OW 477
71601: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
71602: LD_ADDR_VAR 0 10
71606: PUSH
71607: LD_VAR 0 1
71611: PPUSH
71612: CALL_OW 478
71616: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
71617: LD_VAR 0 9
71621: NOT
71622: PUSH
71623: LD_VAR 0 11
71627: NOT
71628: OR
71629: PUSH
71630: LD_VAR 0 12
71634: NOT
71635: OR
71636: PUSH
71637: LD_VAR 0 10
71641: NOT
71642: OR
71643: IFFALSE 71678
// begin result := [ chassis , engine , control , weapon ] ;
71645: LD_ADDR_VAR 0 6
71649: PUSH
71650: LD_VAR 0 2
71654: PUSH
71655: LD_VAR 0 3
71659: PUSH
71660: LD_VAR 0 4
71664: PUSH
71665: LD_VAR 0 5
71669: PUSH
71670: EMPTY
71671: LIST
71672: LIST
71673: LIST
71674: LIST
71675: ST_TO_ADDR
// exit ;
71676: GO 71969
// end ; if not chassis in _chassis then
71678: LD_VAR 0 2
71682: PUSH
71683: LD_VAR 0 9
71687: IN
71688: NOT
71689: IFFALSE 71715
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
71691: LD_ADDR_VAR 0 2
71695: PUSH
71696: LD_VAR 0 9
71700: PUSH
71701: LD_INT 1
71703: PPUSH
71704: LD_VAR 0 9
71708: PPUSH
71709: CALL_OW 12
71713: ARRAY
71714: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
71715: LD_VAR 0 2
71719: PPUSH
71720: LD_VAR 0 3
71724: PPUSH
71725: CALL 71974 0 2
71729: NOT
71730: IFFALSE 71789
// repeat engine := _engine [ 1 ] ;
71732: LD_ADDR_VAR 0 3
71736: PUSH
71737: LD_VAR 0 11
71741: PUSH
71742: LD_INT 1
71744: ARRAY
71745: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
71746: LD_ADDR_VAR 0 11
71750: PUSH
71751: LD_VAR 0 11
71755: PPUSH
71756: LD_INT 1
71758: PPUSH
71759: CALL_OW 3
71763: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
71764: LD_VAR 0 2
71768: PPUSH
71769: LD_VAR 0 3
71773: PPUSH
71774: CALL 71974 0 2
71778: PUSH
71779: LD_VAR 0 11
71783: PUSH
71784: EMPTY
71785: EQUAL
71786: OR
71787: IFFALSE 71732
// if not control in _control then
71789: LD_VAR 0 4
71793: PUSH
71794: LD_VAR 0 12
71798: IN
71799: NOT
71800: IFFALSE 71826
// control := _control [ rand ( 1 , _control ) ] ;
71802: LD_ADDR_VAR 0 4
71806: PUSH
71807: LD_VAR 0 12
71811: PUSH
71812: LD_INT 1
71814: PPUSH
71815: LD_VAR 0 12
71819: PPUSH
71820: CALL_OW 12
71824: ARRAY
71825: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
71826: LD_VAR 0 2
71830: PPUSH
71831: LD_VAR 0 5
71835: PPUSH
71836: CALL 72194 0 2
71840: NOT
71841: IFFALSE 71900
// repeat weapon := _weapon [ 1 ] ;
71843: LD_ADDR_VAR 0 5
71847: PUSH
71848: LD_VAR 0 10
71852: PUSH
71853: LD_INT 1
71855: ARRAY
71856: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
71857: LD_ADDR_VAR 0 10
71861: PUSH
71862: LD_VAR 0 10
71866: PPUSH
71867: LD_INT 1
71869: PPUSH
71870: CALL_OW 3
71874: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
71875: LD_VAR 0 2
71879: PPUSH
71880: LD_VAR 0 5
71884: PPUSH
71885: CALL 72194 0 2
71889: PUSH
71890: LD_VAR 0 10
71894: PUSH
71895: EMPTY
71896: EQUAL
71897: OR
71898: IFFALSE 71843
// result := [ ] ;
71900: LD_ADDR_VAR 0 6
71904: PUSH
71905: EMPTY
71906: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
71907: LD_VAR 0 1
71911: PPUSH
71912: LD_VAR 0 2
71916: PPUSH
71917: LD_VAR 0 3
71921: PPUSH
71922: LD_VAR 0 4
71926: PPUSH
71927: LD_VAR 0 5
71931: PPUSH
71932: CALL_OW 448
71936: IFFALSE 71969
// result := [ chassis , engine , control , weapon ] ;
71938: LD_ADDR_VAR 0 6
71942: PUSH
71943: LD_VAR 0 2
71947: PUSH
71948: LD_VAR 0 3
71952: PUSH
71953: LD_VAR 0 4
71957: PUSH
71958: LD_VAR 0 5
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: LIST
71967: LIST
71968: ST_TO_ADDR
// end ;
71969: LD_VAR 0 6
71973: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
71974: LD_INT 0
71976: PPUSH
// if not chassis or not engine then
71977: LD_VAR 0 1
71981: NOT
71982: PUSH
71983: LD_VAR 0 2
71987: NOT
71988: OR
71989: IFFALSE 71993
// exit ;
71991: GO 72189
// case engine of engine_solar :
71993: LD_VAR 0 2
71997: PUSH
71998: LD_INT 2
72000: DOUBLE
72001: EQUAL
72002: IFTRUE 72006
72004: GO 72044
72006: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
72007: LD_ADDR_VAR 0 3
72011: PUSH
72012: LD_INT 11
72014: PUSH
72015: LD_INT 12
72017: PUSH
72018: LD_INT 13
72020: PUSH
72021: LD_INT 14
72023: PUSH
72024: LD_INT 1
72026: PUSH
72027: LD_INT 2
72029: PUSH
72030: LD_INT 3
72032: PUSH
72033: EMPTY
72034: LIST
72035: LIST
72036: LIST
72037: LIST
72038: LIST
72039: LIST
72040: LIST
72041: ST_TO_ADDR
72042: GO 72173
72044: LD_INT 1
72046: DOUBLE
72047: EQUAL
72048: IFTRUE 72052
72050: GO 72114
72052: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
72053: LD_ADDR_VAR 0 3
72057: PUSH
72058: LD_INT 11
72060: PUSH
72061: LD_INT 12
72063: PUSH
72064: LD_INT 13
72066: PUSH
72067: LD_INT 14
72069: PUSH
72070: LD_INT 1
72072: PUSH
72073: LD_INT 2
72075: PUSH
72076: LD_INT 3
72078: PUSH
72079: LD_INT 4
72081: PUSH
72082: LD_INT 5
72084: PUSH
72085: LD_INT 21
72087: PUSH
72088: LD_INT 23
72090: PUSH
72091: LD_INT 22
72093: PUSH
72094: LD_INT 24
72096: PUSH
72097: EMPTY
72098: LIST
72099: LIST
72100: LIST
72101: LIST
72102: LIST
72103: LIST
72104: LIST
72105: LIST
72106: LIST
72107: LIST
72108: LIST
72109: LIST
72110: LIST
72111: ST_TO_ADDR
72112: GO 72173
72114: LD_INT 3
72116: DOUBLE
72117: EQUAL
72118: IFTRUE 72122
72120: GO 72172
72122: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
72123: LD_ADDR_VAR 0 3
72127: PUSH
72128: LD_INT 13
72130: PUSH
72131: LD_INT 14
72133: PUSH
72134: LD_INT 2
72136: PUSH
72137: LD_INT 3
72139: PUSH
72140: LD_INT 4
72142: PUSH
72143: LD_INT 5
72145: PUSH
72146: LD_INT 21
72148: PUSH
72149: LD_INT 22
72151: PUSH
72152: LD_INT 23
72154: PUSH
72155: LD_INT 24
72157: PUSH
72158: EMPTY
72159: LIST
72160: LIST
72161: LIST
72162: LIST
72163: LIST
72164: LIST
72165: LIST
72166: LIST
72167: LIST
72168: LIST
72169: ST_TO_ADDR
72170: GO 72173
72172: POP
// result := ( chassis in result ) ;
72173: LD_ADDR_VAR 0 3
72177: PUSH
72178: LD_VAR 0 1
72182: PUSH
72183: LD_VAR 0 3
72187: IN
72188: ST_TO_ADDR
// end ;
72189: LD_VAR 0 3
72193: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
72194: LD_INT 0
72196: PPUSH
// if not chassis or not weapon then
72197: LD_VAR 0 1
72201: NOT
72202: PUSH
72203: LD_VAR 0 2
72207: NOT
72208: OR
72209: IFFALSE 72213
// exit ;
72211: GO 73273
// case weapon of us_machine_gun :
72213: LD_VAR 0 2
72217: PUSH
72218: LD_INT 2
72220: DOUBLE
72221: EQUAL
72222: IFTRUE 72226
72224: GO 72256
72226: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
72227: LD_ADDR_VAR 0 3
72231: PUSH
72232: LD_INT 1
72234: PUSH
72235: LD_INT 2
72237: PUSH
72238: LD_INT 3
72240: PUSH
72241: LD_INT 4
72243: PUSH
72244: LD_INT 5
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: LIST
72251: LIST
72252: LIST
72253: ST_TO_ADDR
72254: GO 73257
72256: LD_INT 3
72258: DOUBLE
72259: EQUAL
72260: IFTRUE 72264
72262: GO 72294
72264: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
72265: LD_ADDR_VAR 0 3
72269: PUSH
72270: LD_INT 1
72272: PUSH
72273: LD_INT 2
72275: PUSH
72276: LD_INT 3
72278: PUSH
72279: LD_INT 4
72281: PUSH
72282: LD_INT 5
72284: PUSH
72285: EMPTY
72286: LIST
72287: LIST
72288: LIST
72289: LIST
72290: LIST
72291: ST_TO_ADDR
72292: GO 73257
72294: LD_INT 11
72296: DOUBLE
72297: EQUAL
72298: IFTRUE 72302
72300: GO 72332
72302: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
72303: LD_ADDR_VAR 0 3
72307: PUSH
72308: LD_INT 1
72310: PUSH
72311: LD_INT 2
72313: PUSH
72314: LD_INT 3
72316: PUSH
72317: LD_INT 4
72319: PUSH
72320: LD_INT 5
72322: PUSH
72323: EMPTY
72324: LIST
72325: LIST
72326: LIST
72327: LIST
72328: LIST
72329: ST_TO_ADDR
72330: GO 73257
72332: LD_INT 4
72334: DOUBLE
72335: EQUAL
72336: IFTRUE 72340
72338: GO 72366
72340: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
72341: LD_ADDR_VAR 0 3
72345: PUSH
72346: LD_INT 2
72348: PUSH
72349: LD_INT 3
72351: PUSH
72352: LD_INT 4
72354: PUSH
72355: LD_INT 5
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: LIST
72362: LIST
72363: ST_TO_ADDR
72364: GO 73257
72366: LD_INT 5
72368: DOUBLE
72369: EQUAL
72370: IFTRUE 72374
72372: GO 72400
72374: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
72375: LD_ADDR_VAR 0 3
72379: PUSH
72380: LD_INT 2
72382: PUSH
72383: LD_INT 3
72385: PUSH
72386: LD_INT 4
72388: PUSH
72389: LD_INT 5
72391: PUSH
72392: EMPTY
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: ST_TO_ADDR
72398: GO 73257
72400: LD_INT 9
72402: DOUBLE
72403: EQUAL
72404: IFTRUE 72408
72406: GO 72434
72408: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
72409: LD_ADDR_VAR 0 3
72413: PUSH
72414: LD_INT 2
72416: PUSH
72417: LD_INT 3
72419: PUSH
72420: LD_INT 4
72422: PUSH
72423: LD_INT 5
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: LIST
72430: LIST
72431: ST_TO_ADDR
72432: GO 73257
72434: LD_INT 7
72436: DOUBLE
72437: EQUAL
72438: IFTRUE 72442
72440: GO 72468
72442: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
72443: LD_ADDR_VAR 0 3
72447: PUSH
72448: LD_INT 2
72450: PUSH
72451: LD_INT 3
72453: PUSH
72454: LD_INT 4
72456: PUSH
72457: LD_INT 5
72459: PUSH
72460: EMPTY
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: ST_TO_ADDR
72466: GO 73257
72468: LD_INT 12
72470: DOUBLE
72471: EQUAL
72472: IFTRUE 72476
72474: GO 72502
72476: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
72477: LD_ADDR_VAR 0 3
72481: PUSH
72482: LD_INT 2
72484: PUSH
72485: LD_INT 3
72487: PUSH
72488: LD_INT 4
72490: PUSH
72491: LD_INT 5
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: LIST
72498: LIST
72499: ST_TO_ADDR
72500: GO 73257
72502: LD_INT 13
72504: DOUBLE
72505: EQUAL
72506: IFTRUE 72510
72508: GO 72536
72510: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
72511: LD_ADDR_VAR 0 3
72515: PUSH
72516: LD_INT 2
72518: PUSH
72519: LD_INT 3
72521: PUSH
72522: LD_INT 4
72524: PUSH
72525: LD_INT 5
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: LIST
72532: LIST
72533: ST_TO_ADDR
72534: GO 73257
72536: LD_INT 14
72538: DOUBLE
72539: EQUAL
72540: IFTRUE 72544
72542: GO 72562
72544: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
72545: LD_ADDR_VAR 0 3
72549: PUSH
72550: LD_INT 4
72552: PUSH
72553: LD_INT 5
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: ST_TO_ADDR
72560: GO 73257
72562: LD_INT 6
72564: DOUBLE
72565: EQUAL
72566: IFTRUE 72570
72568: GO 72588
72570: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
72571: LD_ADDR_VAR 0 3
72575: PUSH
72576: LD_INT 4
72578: PUSH
72579: LD_INT 5
72581: PUSH
72582: EMPTY
72583: LIST
72584: LIST
72585: ST_TO_ADDR
72586: GO 73257
72588: LD_INT 10
72590: DOUBLE
72591: EQUAL
72592: IFTRUE 72596
72594: GO 72614
72596: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
72597: LD_ADDR_VAR 0 3
72601: PUSH
72602: LD_INT 4
72604: PUSH
72605: LD_INT 5
72607: PUSH
72608: EMPTY
72609: LIST
72610: LIST
72611: ST_TO_ADDR
72612: GO 73257
72614: LD_INT 22
72616: DOUBLE
72617: EQUAL
72618: IFTRUE 72622
72620: GO 72648
72622: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
72623: LD_ADDR_VAR 0 3
72627: PUSH
72628: LD_INT 11
72630: PUSH
72631: LD_INT 12
72633: PUSH
72634: LD_INT 13
72636: PUSH
72637: LD_INT 14
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: LIST
72644: LIST
72645: ST_TO_ADDR
72646: GO 73257
72648: LD_INT 23
72650: DOUBLE
72651: EQUAL
72652: IFTRUE 72656
72654: GO 72682
72656: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
72657: LD_ADDR_VAR 0 3
72661: PUSH
72662: LD_INT 11
72664: PUSH
72665: LD_INT 12
72667: PUSH
72668: LD_INT 13
72670: PUSH
72671: LD_INT 14
72673: PUSH
72674: EMPTY
72675: LIST
72676: LIST
72677: LIST
72678: LIST
72679: ST_TO_ADDR
72680: GO 73257
72682: LD_INT 24
72684: DOUBLE
72685: EQUAL
72686: IFTRUE 72690
72688: GO 72716
72690: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
72691: LD_ADDR_VAR 0 3
72695: PUSH
72696: LD_INT 11
72698: PUSH
72699: LD_INT 12
72701: PUSH
72702: LD_INT 13
72704: PUSH
72705: LD_INT 14
72707: PUSH
72708: EMPTY
72709: LIST
72710: LIST
72711: LIST
72712: LIST
72713: ST_TO_ADDR
72714: GO 73257
72716: LD_INT 30
72718: DOUBLE
72719: EQUAL
72720: IFTRUE 72724
72722: GO 72750
72724: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
72725: LD_ADDR_VAR 0 3
72729: PUSH
72730: LD_INT 11
72732: PUSH
72733: LD_INT 12
72735: PUSH
72736: LD_INT 13
72738: PUSH
72739: LD_INT 14
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: LIST
72746: LIST
72747: ST_TO_ADDR
72748: GO 73257
72750: LD_INT 25
72752: DOUBLE
72753: EQUAL
72754: IFTRUE 72758
72756: GO 72776
72758: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
72759: LD_ADDR_VAR 0 3
72763: PUSH
72764: LD_INT 13
72766: PUSH
72767: LD_INT 14
72769: PUSH
72770: EMPTY
72771: LIST
72772: LIST
72773: ST_TO_ADDR
72774: GO 73257
72776: LD_INT 27
72778: DOUBLE
72779: EQUAL
72780: IFTRUE 72784
72782: GO 72802
72784: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
72785: LD_ADDR_VAR 0 3
72789: PUSH
72790: LD_INT 13
72792: PUSH
72793: LD_INT 14
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: ST_TO_ADDR
72800: GO 73257
72802: LD_INT 92
72804: DOUBLE
72805: EQUAL
72806: IFTRUE 72810
72808: GO 72836
72810: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
72811: LD_ADDR_VAR 0 3
72815: PUSH
72816: LD_INT 11
72818: PUSH
72819: LD_INT 12
72821: PUSH
72822: LD_INT 13
72824: PUSH
72825: LD_INT 14
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: ST_TO_ADDR
72834: GO 73257
72836: LD_INT 28
72838: DOUBLE
72839: EQUAL
72840: IFTRUE 72844
72842: GO 72862
72844: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
72845: LD_ADDR_VAR 0 3
72849: PUSH
72850: LD_INT 13
72852: PUSH
72853: LD_INT 14
72855: PUSH
72856: EMPTY
72857: LIST
72858: LIST
72859: ST_TO_ADDR
72860: GO 73257
72862: LD_INT 29
72864: DOUBLE
72865: EQUAL
72866: IFTRUE 72870
72868: GO 72888
72870: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
72871: LD_ADDR_VAR 0 3
72875: PUSH
72876: LD_INT 13
72878: PUSH
72879: LD_INT 14
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: ST_TO_ADDR
72886: GO 73257
72888: LD_INT 31
72890: DOUBLE
72891: EQUAL
72892: IFTRUE 72896
72894: GO 72914
72896: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
72897: LD_ADDR_VAR 0 3
72901: PUSH
72902: LD_INT 13
72904: PUSH
72905: LD_INT 14
72907: PUSH
72908: EMPTY
72909: LIST
72910: LIST
72911: ST_TO_ADDR
72912: GO 73257
72914: LD_INT 26
72916: DOUBLE
72917: EQUAL
72918: IFTRUE 72922
72920: GO 72940
72922: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
72923: LD_ADDR_VAR 0 3
72927: PUSH
72928: LD_INT 13
72930: PUSH
72931: LD_INT 14
72933: PUSH
72934: EMPTY
72935: LIST
72936: LIST
72937: ST_TO_ADDR
72938: GO 73257
72940: LD_INT 42
72942: DOUBLE
72943: EQUAL
72944: IFTRUE 72948
72946: GO 72974
72948: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
72949: LD_ADDR_VAR 0 3
72953: PUSH
72954: LD_INT 21
72956: PUSH
72957: LD_INT 22
72959: PUSH
72960: LD_INT 23
72962: PUSH
72963: LD_INT 24
72965: PUSH
72966: EMPTY
72967: LIST
72968: LIST
72969: LIST
72970: LIST
72971: ST_TO_ADDR
72972: GO 73257
72974: LD_INT 43
72976: DOUBLE
72977: EQUAL
72978: IFTRUE 72982
72980: GO 73008
72982: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
72983: LD_ADDR_VAR 0 3
72987: PUSH
72988: LD_INT 21
72990: PUSH
72991: LD_INT 22
72993: PUSH
72994: LD_INT 23
72996: PUSH
72997: LD_INT 24
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: LIST
73004: LIST
73005: ST_TO_ADDR
73006: GO 73257
73008: LD_INT 44
73010: DOUBLE
73011: EQUAL
73012: IFTRUE 73016
73014: GO 73042
73016: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
73017: LD_ADDR_VAR 0 3
73021: PUSH
73022: LD_INT 21
73024: PUSH
73025: LD_INT 22
73027: PUSH
73028: LD_INT 23
73030: PUSH
73031: LD_INT 24
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: LIST
73038: LIST
73039: ST_TO_ADDR
73040: GO 73257
73042: LD_INT 45
73044: DOUBLE
73045: EQUAL
73046: IFTRUE 73050
73048: GO 73076
73050: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
73051: LD_ADDR_VAR 0 3
73055: PUSH
73056: LD_INT 21
73058: PUSH
73059: LD_INT 22
73061: PUSH
73062: LD_INT 23
73064: PUSH
73065: LD_INT 24
73067: PUSH
73068: EMPTY
73069: LIST
73070: LIST
73071: LIST
73072: LIST
73073: ST_TO_ADDR
73074: GO 73257
73076: LD_INT 49
73078: DOUBLE
73079: EQUAL
73080: IFTRUE 73084
73082: GO 73110
73084: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
73085: LD_ADDR_VAR 0 3
73089: PUSH
73090: LD_INT 21
73092: PUSH
73093: LD_INT 22
73095: PUSH
73096: LD_INT 23
73098: PUSH
73099: LD_INT 24
73101: PUSH
73102: EMPTY
73103: LIST
73104: LIST
73105: LIST
73106: LIST
73107: ST_TO_ADDR
73108: GO 73257
73110: LD_INT 51
73112: DOUBLE
73113: EQUAL
73114: IFTRUE 73118
73116: GO 73144
73118: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
73119: LD_ADDR_VAR 0 3
73123: PUSH
73124: LD_INT 21
73126: PUSH
73127: LD_INT 22
73129: PUSH
73130: LD_INT 23
73132: PUSH
73133: LD_INT 24
73135: PUSH
73136: EMPTY
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: ST_TO_ADDR
73142: GO 73257
73144: LD_INT 52
73146: DOUBLE
73147: EQUAL
73148: IFTRUE 73152
73150: GO 73178
73152: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
73153: LD_ADDR_VAR 0 3
73157: PUSH
73158: LD_INT 21
73160: PUSH
73161: LD_INT 22
73163: PUSH
73164: LD_INT 23
73166: PUSH
73167: LD_INT 24
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: LIST
73174: LIST
73175: ST_TO_ADDR
73176: GO 73257
73178: LD_INT 53
73180: DOUBLE
73181: EQUAL
73182: IFTRUE 73186
73184: GO 73204
73186: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
73187: LD_ADDR_VAR 0 3
73191: PUSH
73192: LD_INT 23
73194: PUSH
73195: LD_INT 24
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: ST_TO_ADDR
73202: GO 73257
73204: LD_INT 46
73206: DOUBLE
73207: EQUAL
73208: IFTRUE 73212
73210: GO 73230
73212: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
73213: LD_ADDR_VAR 0 3
73217: PUSH
73218: LD_INT 23
73220: PUSH
73221: LD_INT 24
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: ST_TO_ADDR
73228: GO 73257
73230: LD_INT 47
73232: DOUBLE
73233: EQUAL
73234: IFTRUE 73238
73236: GO 73256
73238: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
73239: LD_ADDR_VAR 0 3
73243: PUSH
73244: LD_INT 23
73246: PUSH
73247: LD_INT 24
73249: PUSH
73250: EMPTY
73251: LIST
73252: LIST
73253: ST_TO_ADDR
73254: GO 73257
73256: POP
// result := ( chassis in result ) ;
73257: LD_ADDR_VAR 0 3
73261: PUSH
73262: LD_VAR 0 1
73266: PUSH
73267: LD_VAR 0 3
73271: IN
73272: ST_TO_ADDR
// end ;
73273: LD_VAR 0 3
73277: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
73278: LD_INT 0
73280: PPUSH
73281: PPUSH
73282: PPUSH
73283: PPUSH
73284: PPUSH
73285: PPUSH
73286: PPUSH
// result := array ;
73287: LD_ADDR_VAR 0 5
73291: PUSH
73292: LD_VAR 0 1
73296: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
73297: LD_VAR 0 1
73301: NOT
73302: PUSH
73303: LD_VAR 0 2
73307: NOT
73308: OR
73309: PUSH
73310: LD_VAR 0 3
73314: NOT
73315: OR
73316: PUSH
73317: LD_VAR 0 2
73321: PUSH
73322: LD_VAR 0 1
73326: GREATER
73327: OR
73328: PUSH
73329: LD_VAR 0 3
73333: PUSH
73334: LD_VAR 0 1
73338: GREATER
73339: OR
73340: IFFALSE 73344
// exit ;
73342: GO 73640
// if direction then
73344: LD_VAR 0 4
73348: IFFALSE 73412
// begin d := 1 ;
73350: LD_ADDR_VAR 0 9
73354: PUSH
73355: LD_INT 1
73357: ST_TO_ADDR
// if i_from > i_to then
73358: LD_VAR 0 2
73362: PUSH
73363: LD_VAR 0 3
73367: GREATER
73368: IFFALSE 73394
// length := ( array - i_from ) + i_to else
73370: LD_ADDR_VAR 0 11
73374: PUSH
73375: LD_VAR 0 1
73379: PUSH
73380: LD_VAR 0 2
73384: MINUS
73385: PUSH
73386: LD_VAR 0 3
73390: PLUS
73391: ST_TO_ADDR
73392: GO 73410
// length := i_to - i_from ;
73394: LD_ADDR_VAR 0 11
73398: PUSH
73399: LD_VAR 0 3
73403: PUSH
73404: LD_VAR 0 2
73408: MINUS
73409: ST_TO_ADDR
// end else
73410: GO 73473
// begin d := - 1 ;
73412: LD_ADDR_VAR 0 9
73416: PUSH
73417: LD_INT 1
73419: NEG
73420: ST_TO_ADDR
// if i_from > i_to then
73421: LD_VAR 0 2
73425: PUSH
73426: LD_VAR 0 3
73430: GREATER
73431: IFFALSE 73451
// length := i_from - i_to else
73433: LD_ADDR_VAR 0 11
73437: PUSH
73438: LD_VAR 0 2
73442: PUSH
73443: LD_VAR 0 3
73447: MINUS
73448: ST_TO_ADDR
73449: GO 73473
// length := ( array - i_to ) + i_from ;
73451: LD_ADDR_VAR 0 11
73455: PUSH
73456: LD_VAR 0 1
73460: PUSH
73461: LD_VAR 0 3
73465: MINUS
73466: PUSH
73467: LD_VAR 0 2
73471: PLUS
73472: ST_TO_ADDR
// end ; if not length then
73473: LD_VAR 0 11
73477: NOT
73478: IFFALSE 73482
// exit ;
73480: GO 73640
// tmp := array ;
73482: LD_ADDR_VAR 0 10
73486: PUSH
73487: LD_VAR 0 1
73491: ST_TO_ADDR
// for i = 1 to length do
73492: LD_ADDR_VAR 0 6
73496: PUSH
73497: DOUBLE
73498: LD_INT 1
73500: DEC
73501: ST_TO_ADDR
73502: LD_VAR 0 11
73506: PUSH
73507: FOR_TO
73508: IFFALSE 73628
// begin for j = 1 to array do
73510: LD_ADDR_VAR 0 7
73514: PUSH
73515: DOUBLE
73516: LD_INT 1
73518: DEC
73519: ST_TO_ADDR
73520: LD_VAR 0 1
73524: PUSH
73525: FOR_TO
73526: IFFALSE 73614
// begin k := j + d ;
73528: LD_ADDR_VAR 0 8
73532: PUSH
73533: LD_VAR 0 7
73537: PUSH
73538: LD_VAR 0 9
73542: PLUS
73543: ST_TO_ADDR
// if k > array then
73544: LD_VAR 0 8
73548: PUSH
73549: LD_VAR 0 1
73553: GREATER
73554: IFFALSE 73564
// k := 1 ;
73556: LD_ADDR_VAR 0 8
73560: PUSH
73561: LD_INT 1
73563: ST_TO_ADDR
// if not k then
73564: LD_VAR 0 8
73568: NOT
73569: IFFALSE 73581
// k := array ;
73571: LD_ADDR_VAR 0 8
73575: PUSH
73576: LD_VAR 0 1
73580: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
73581: LD_ADDR_VAR 0 10
73585: PUSH
73586: LD_VAR 0 10
73590: PPUSH
73591: LD_VAR 0 8
73595: PPUSH
73596: LD_VAR 0 1
73600: PUSH
73601: LD_VAR 0 7
73605: ARRAY
73606: PPUSH
73607: CALL_OW 1
73611: ST_TO_ADDR
// end ;
73612: GO 73525
73614: POP
73615: POP
// array := tmp ;
73616: LD_ADDR_VAR 0 1
73620: PUSH
73621: LD_VAR 0 10
73625: ST_TO_ADDR
// end ;
73626: GO 73507
73628: POP
73629: POP
// result := array ;
73630: LD_ADDR_VAR 0 5
73634: PUSH
73635: LD_VAR 0 1
73639: ST_TO_ADDR
// end ;
73640: LD_VAR 0 5
73644: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
73645: LD_INT 0
73647: PPUSH
73648: PPUSH
// result := 0 ;
73649: LD_ADDR_VAR 0 3
73653: PUSH
73654: LD_INT 0
73656: ST_TO_ADDR
// if not array or not value in array then
73657: LD_VAR 0 1
73661: NOT
73662: PUSH
73663: LD_VAR 0 2
73667: PUSH
73668: LD_VAR 0 1
73672: IN
73673: NOT
73674: OR
73675: IFFALSE 73679
// exit ;
73677: GO 73733
// for i = 1 to array do
73679: LD_ADDR_VAR 0 4
73683: PUSH
73684: DOUBLE
73685: LD_INT 1
73687: DEC
73688: ST_TO_ADDR
73689: LD_VAR 0 1
73693: PUSH
73694: FOR_TO
73695: IFFALSE 73731
// if value = array [ i ] then
73697: LD_VAR 0 2
73701: PUSH
73702: LD_VAR 0 1
73706: PUSH
73707: LD_VAR 0 4
73711: ARRAY
73712: EQUAL
73713: IFFALSE 73729
// begin result := i ;
73715: LD_ADDR_VAR 0 3
73719: PUSH
73720: LD_VAR 0 4
73724: ST_TO_ADDR
// exit ;
73725: POP
73726: POP
73727: GO 73733
// end ;
73729: GO 73694
73731: POP
73732: POP
// end ;
73733: LD_VAR 0 3
73737: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
73738: LD_INT 0
73740: PPUSH
// vc_chassis := chassis ;
73741: LD_ADDR_OWVAR 37
73745: PUSH
73746: LD_VAR 0 1
73750: ST_TO_ADDR
// vc_engine := engine ;
73751: LD_ADDR_OWVAR 39
73755: PUSH
73756: LD_VAR 0 2
73760: ST_TO_ADDR
// vc_control := control ;
73761: LD_ADDR_OWVAR 38
73765: PUSH
73766: LD_VAR 0 3
73770: ST_TO_ADDR
// vc_weapon := weapon ;
73771: LD_ADDR_OWVAR 40
73775: PUSH
73776: LD_VAR 0 4
73780: ST_TO_ADDR
// vc_fuel_battery := fuel ;
73781: LD_ADDR_OWVAR 41
73785: PUSH
73786: LD_VAR 0 5
73790: ST_TO_ADDR
// end ;
73791: LD_VAR 0 6
73795: RET
// export function WantPlant ( unit ) ; var task ; begin
73796: LD_INT 0
73798: PPUSH
73799: PPUSH
// result := false ;
73800: LD_ADDR_VAR 0 2
73804: PUSH
73805: LD_INT 0
73807: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
73808: LD_ADDR_VAR 0 3
73812: PUSH
73813: LD_VAR 0 1
73817: PPUSH
73818: CALL_OW 437
73822: ST_TO_ADDR
// if task then
73823: LD_VAR 0 3
73827: IFFALSE 73855
// if task [ 1 ] [ 1 ] = p then
73829: LD_VAR 0 3
73833: PUSH
73834: LD_INT 1
73836: ARRAY
73837: PUSH
73838: LD_INT 1
73840: ARRAY
73841: PUSH
73842: LD_STRING p
73844: EQUAL
73845: IFFALSE 73855
// result := true ;
73847: LD_ADDR_VAR 0 2
73851: PUSH
73852: LD_INT 1
73854: ST_TO_ADDR
// end ;
73855: LD_VAR 0 2
73859: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
73860: LD_INT 0
73862: PPUSH
73863: PPUSH
73864: PPUSH
73865: PPUSH
// if pos < 1 then
73866: LD_VAR 0 2
73870: PUSH
73871: LD_INT 1
73873: LESS
73874: IFFALSE 73878
// exit ;
73876: GO 74181
// if pos = 1 then
73878: LD_VAR 0 2
73882: PUSH
73883: LD_INT 1
73885: EQUAL
73886: IFFALSE 73919
// result := Replace ( arr , pos [ 1 ] , value ) else
73888: LD_ADDR_VAR 0 4
73892: PUSH
73893: LD_VAR 0 1
73897: PPUSH
73898: LD_VAR 0 2
73902: PUSH
73903: LD_INT 1
73905: ARRAY
73906: PPUSH
73907: LD_VAR 0 3
73911: PPUSH
73912: CALL_OW 1
73916: ST_TO_ADDR
73917: GO 74181
// begin tmp := arr ;
73919: LD_ADDR_VAR 0 6
73923: PUSH
73924: LD_VAR 0 1
73928: ST_TO_ADDR
// s_arr := [ tmp ] ;
73929: LD_ADDR_VAR 0 7
73933: PUSH
73934: LD_VAR 0 6
73938: PUSH
73939: EMPTY
73940: LIST
73941: ST_TO_ADDR
// for i = 1 to pos - 1 do
73942: LD_ADDR_VAR 0 5
73946: PUSH
73947: DOUBLE
73948: LD_INT 1
73950: DEC
73951: ST_TO_ADDR
73952: LD_VAR 0 2
73956: PUSH
73957: LD_INT 1
73959: MINUS
73960: PUSH
73961: FOR_TO
73962: IFFALSE 74007
// begin tmp := tmp [ pos [ i ] ] ;
73964: LD_ADDR_VAR 0 6
73968: PUSH
73969: LD_VAR 0 6
73973: PUSH
73974: LD_VAR 0 2
73978: PUSH
73979: LD_VAR 0 5
73983: ARRAY
73984: ARRAY
73985: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
73986: LD_ADDR_VAR 0 7
73990: PUSH
73991: LD_VAR 0 7
73995: PUSH
73996: LD_VAR 0 6
74000: PUSH
74001: EMPTY
74002: LIST
74003: ADD
74004: ST_TO_ADDR
// end ;
74005: GO 73961
74007: POP
74008: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
74009: LD_ADDR_VAR 0 6
74013: PUSH
74014: LD_VAR 0 6
74018: PPUSH
74019: LD_VAR 0 2
74023: PUSH
74024: LD_VAR 0 2
74028: ARRAY
74029: PPUSH
74030: LD_VAR 0 3
74034: PPUSH
74035: CALL_OW 1
74039: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
74040: LD_ADDR_VAR 0 7
74044: PUSH
74045: LD_VAR 0 7
74049: PPUSH
74050: LD_VAR 0 7
74054: PPUSH
74055: LD_VAR 0 6
74059: PPUSH
74060: CALL_OW 1
74064: ST_TO_ADDR
// for i = s_arr downto 2 do
74065: LD_ADDR_VAR 0 5
74069: PUSH
74070: DOUBLE
74071: LD_VAR 0 7
74075: INC
74076: ST_TO_ADDR
74077: LD_INT 2
74079: PUSH
74080: FOR_DOWNTO
74081: IFFALSE 74165
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
74083: LD_ADDR_VAR 0 6
74087: PUSH
74088: LD_VAR 0 7
74092: PUSH
74093: LD_VAR 0 5
74097: PUSH
74098: LD_INT 1
74100: MINUS
74101: ARRAY
74102: PPUSH
74103: LD_VAR 0 2
74107: PUSH
74108: LD_VAR 0 5
74112: PUSH
74113: LD_INT 1
74115: MINUS
74116: ARRAY
74117: PPUSH
74118: LD_VAR 0 7
74122: PUSH
74123: LD_VAR 0 5
74127: ARRAY
74128: PPUSH
74129: CALL_OW 1
74133: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
74134: LD_ADDR_VAR 0 7
74138: PUSH
74139: LD_VAR 0 7
74143: PPUSH
74144: LD_VAR 0 5
74148: PUSH
74149: LD_INT 1
74151: MINUS
74152: PPUSH
74153: LD_VAR 0 6
74157: PPUSH
74158: CALL_OW 1
74162: ST_TO_ADDR
// end ;
74163: GO 74080
74165: POP
74166: POP
// result := s_arr [ 1 ] ;
74167: LD_ADDR_VAR 0 4
74171: PUSH
74172: LD_VAR 0 7
74176: PUSH
74177: LD_INT 1
74179: ARRAY
74180: ST_TO_ADDR
// end ; end ;
74181: LD_VAR 0 4
74185: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
74186: LD_INT 0
74188: PPUSH
74189: PPUSH
// if not list then
74190: LD_VAR 0 1
74194: NOT
74195: IFFALSE 74199
// exit ;
74197: GO 74290
// i := list [ pos1 ] ;
74199: LD_ADDR_VAR 0 5
74203: PUSH
74204: LD_VAR 0 1
74208: PUSH
74209: LD_VAR 0 2
74213: ARRAY
74214: ST_TO_ADDR
// if not i then
74215: LD_VAR 0 5
74219: NOT
74220: IFFALSE 74224
// exit ;
74222: GO 74290
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
74224: LD_ADDR_VAR 0 1
74228: PUSH
74229: LD_VAR 0 1
74233: PPUSH
74234: LD_VAR 0 2
74238: PPUSH
74239: LD_VAR 0 1
74243: PUSH
74244: LD_VAR 0 3
74248: ARRAY
74249: PPUSH
74250: CALL_OW 1
74254: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
74255: LD_ADDR_VAR 0 1
74259: PUSH
74260: LD_VAR 0 1
74264: PPUSH
74265: LD_VAR 0 3
74269: PPUSH
74270: LD_VAR 0 5
74274: PPUSH
74275: CALL_OW 1
74279: ST_TO_ADDR
// result := list ;
74280: LD_ADDR_VAR 0 4
74284: PUSH
74285: LD_VAR 0 1
74289: ST_TO_ADDR
// end ;
74290: LD_VAR 0 4
74294: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
74295: LD_INT 0
74297: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
74298: LD_ADDR_VAR 0 5
74302: PUSH
74303: LD_VAR 0 1
74307: PPUSH
74308: CALL_OW 250
74312: PPUSH
74313: LD_VAR 0 1
74317: PPUSH
74318: CALL_OW 251
74322: PPUSH
74323: LD_VAR 0 2
74327: PPUSH
74328: LD_VAR 0 3
74332: PPUSH
74333: LD_VAR 0 4
74337: PPUSH
74338: CALL 74348 0 5
74342: ST_TO_ADDR
// end ;
74343: LD_VAR 0 5
74347: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
74348: LD_INT 0
74350: PPUSH
74351: PPUSH
74352: PPUSH
74353: PPUSH
// if not list then
74354: LD_VAR 0 3
74358: NOT
74359: IFFALSE 74363
// exit ;
74361: GO 74751
// result := [ ] ;
74363: LD_ADDR_VAR 0 6
74367: PUSH
74368: EMPTY
74369: ST_TO_ADDR
// for i in list do
74370: LD_ADDR_VAR 0 7
74374: PUSH
74375: LD_VAR 0 3
74379: PUSH
74380: FOR_IN
74381: IFFALSE 74583
// begin tmp := GetDistUnitXY ( i , x , y ) ;
74383: LD_ADDR_VAR 0 9
74387: PUSH
74388: LD_VAR 0 7
74392: PPUSH
74393: LD_VAR 0 1
74397: PPUSH
74398: LD_VAR 0 2
74402: PPUSH
74403: CALL_OW 297
74407: ST_TO_ADDR
// if not result then
74408: LD_VAR 0 6
74412: NOT
74413: IFFALSE 74439
// result := [ [ i , tmp ] ] else
74415: LD_ADDR_VAR 0 6
74419: PUSH
74420: LD_VAR 0 7
74424: PUSH
74425: LD_VAR 0 9
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: PUSH
74434: EMPTY
74435: LIST
74436: ST_TO_ADDR
74437: GO 74581
// begin if result [ result ] [ 2 ] < tmp then
74439: LD_VAR 0 6
74443: PUSH
74444: LD_VAR 0 6
74448: ARRAY
74449: PUSH
74450: LD_INT 2
74452: ARRAY
74453: PUSH
74454: LD_VAR 0 9
74458: LESS
74459: IFFALSE 74501
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
74461: LD_ADDR_VAR 0 6
74465: PUSH
74466: LD_VAR 0 6
74470: PPUSH
74471: LD_VAR 0 6
74475: PUSH
74476: LD_INT 1
74478: PLUS
74479: PPUSH
74480: LD_VAR 0 7
74484: PUSH
74485: LD_VAR 0 9
74489: PUSH
74490: EMPTY
74491: LIST
74492: LIST
74493: PPUSH
74494: CALL_OW 2
74498: ST_TO_ADDR
74499: GO 74581
// for j = 1 to result do
74501: LD_ADDR_VAR 0 8
74505: PUSH
74506: DOUBLE
74507: LD_INT 1
74509: DEC
74510: ST_TO_ADDR
74511: LD_VAR 0 6
74515: PUSH
74516: FOR_TO
74517: IFFALSE 74579
// begin if tmp < result [ j ] [ 2 ] then
74519: LD_VAR 0 9
74523: PUSH
74524: LD_VAR 0 6
74528: PUSH
74529: LD_VAR 0 8
74533: ARRAY
74534: PUSH
74535: LD_INT 2
74537: ARRAY
74538: LESS
74539: IFFALSE 74577
// begin result := Insert ( result , j , [ i , tmp ] ) ;
74541: LD_ADDR_VAR 0 6
74545: PUSH
74546: LD_VAR 0 6
74550: PPUSH
74551: LD_VAR 0 8
74555: PPUSH
74556: LD_VAR 0 7
74560: PUSH
74561: LD_VAR 0 9
74565: PUSH
74566: EMPTY
74567: LIST
74568: LIST
74569: PPUSH
74570: CALL_OW 2
74574: ST_TO_ADDR
// break ;
74575: GO 74579
// end ; end ;
74577: GO 74516
74579: POP
74580: POP
// end ; end ;
74581: GO 74380
74583: POP
74584: POP
// if result and not asc then
74585: LD_VAR 0 6
74589: PUSH
74590: LD_VAR 0 4
74594: NOT
74595: AND
74596: IFFALSE 74671
// begin tmp := result ;
74598: LD_ADDR_VAR 0 9
74602: PUSH
74603: LD_VAR 0 6
74607: ST_TO_ADDR
// for i = tmp downto 1 do
74608: LD_ADDR_VAR 0 7
74612: PUSH
74613: DOUBLE
74614: LD_VAR 0 9
74618: INC
74619: ST_TO_ADDR
74620: LD_INT 1
74622: PUSH
74623: FOR_DOWNTO
74624: IFFALSE 74669
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
74626: LD_ADDR_VAR 0 6
74630: PUSH
74631: LD_VAR 0 6
74635: PPUSH
74636: LD_VAR 0 9
74640: PUSH
74641: LD_VAR 0 7
74645: MINUS
74646: PUSH
74647: LD_INT 1
74649: PLUS
74650: PPUSH
74651: LD_VAR 0 9
74655: PUSH
74656: LD_VAR 0 7
74660: ARRAY
74661: PPUSH
74662: CALL_OW 1
74666: ST_TO_ADDR
74667: GO 74623
74669: POP
74670: POP
// end ; tmp := [ ] ;
74671: LD_ADDR_VAR 0 9
74675: PUSH
74676: EMPTY
74677: ST_TO_ADDR
// if mode then
74678: LD_VAR 0 5
74682: IFFALSE 74751
// begin for i = 1 to result do
74684: LD_ADDR_VAR 0 7
74688: PUSH
74689: DOUBLE
74690: LD_INT 1
74692: DEC
74693: ST_TO_ADDR
74694: LD_VAR 0 6
74698: PUSH
74699: FOR_TO
74700: IFFALSE 74739
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
74702: LD_ADDR_VAR 0 9
74706: PUSH
74707: LD_VAR 0 9
74711: PPUSH
74712: LD_VAR 0 7
74716: PPUSH
74717: LD_VAR 0 6
74721: PUSH
74722: LD_VAR 0 7
74726: ARRAY
74727: PUSH
74728: LD_INT 1
74730: ARRAY
74731: PPUSH
74732: CALL_OW 1
74736: ST_TO_ADDR
74737: GO 74699
74739: POP
74740: POP
// result := tmp ;
74741: LD_ADDR_VAR 0 6
74745: PUSH
74746: LD_VAR 0 9
74750: ST_TO_ADDR
// end ; end ;
74751: LD_VAR 0 6
74755: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
74756: LD_INT 0
74758: PPUSH
74759: PPUSH
74760: PPUSH
74761: PPUSH
74762: PPUSH
74763: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
74764: LD_ADDR_VAR 0 5
74768: PUSH
74769: LD_INT 0
74771: PUSH
74772: LD_INT 0
74774: PUSH
74775: LD_INT 0
74777: PUSH
74778: EMPTY
74779: PUSH
74780: EMPTY
74781: LIST
74782: LIST
74783: LIST
74784: LIST
74785: ST_TO_ADDR
// if not x or not y then
74786: LD_VAR 0 2
74790: NOT
74791: PUSH
74792: LD_VAR 0 3
74796: NOT
74797: OR
74798: IFFALSE 74802
// exit ;
74800: GO 76452
// if not range then
74802: LD_VAR 0 4
74806: NOT
74807: IFFALSE 74817
// range := 10 ;
74809: LD_ADDR_VAR 0 4
74813: PUSH
74814: LD_INT 10
74816: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
74817: LD_ADDR_VAR 0 8
74821: PUSH
74822: LD_INT 81
74824: PUSH
74825: LD_VAR 0 1
74829: PUSH
74830: EMPTY
74831: LIST
74832: LIST
74833: PUSH
74834: LD_INT 92
74836: PUSH
74837: LD_VAR 0 2
74841: PUSH
74842: LD_VAR 0 3
74846: PUSH
74847: LD_VAR 0 4
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: LIST
74856: LIST
74857: PUSH
74858: LD_INT 3
74860: PUSH
74861: LD_INT 21
74863: PUSH
74864: LD_INT 3
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: EMPTY
74876: LIST
74877: LIST
74878: LIST
74879: PPUSH
74880: CALL_OW 69
74884: ST_TO_ADDR
// if not tmp then
74885: LD_VAR 0 8
74889: NOT
74890: IFFALSE 74894
// exit ;
74892: GO 76452
// for i in tmp do
74894: LD_ADDR_VAR 0 6
74898: PUSH
74899: LD_VAR 0 8
74903: PUSH
74904: FOR_IN
74905: IFFALSE 76427
// begin points := [ 0 , 0 , 0 ] ;
74907: LD_ADDR_VAR 0 9
74911: PUSH
74912: LD_INT 0
74914: PUSH
74915: LD_INT 0
74917: PUSH
74918: LD_INT 0
74920: PUSH
74921: EMPTY
74922: LIST
74923: LIST
74924: LIST
74925: ST_TO_ADDR
// bpoints := 1 ;
74926: LD_ADDR_VAR 0 10
74930: PUSH
74931: LD_INT 1
74933: ST_TO_ADDR
// case GetType ( i ) of unit_human :
74934: LD_VAR 0 6
74938: PPUSH
74939: CALL_OW 247
74943: PUSH
74944: LD_INT 1
74946: DOUBLE
74947: EQUAL
74948: IFTRUE 74952
74950: GO 75530
74952: POP
// begin if GetClass ( i ) = 1 then
74953: LD_VAR 0 6
74957: PPUSH
74958: CALL_OW 257
74962: PUSH
74963: LD_INT 1
74965: EQUAL
74966: IFFALSE 74987
// points := [ 10 , 5 , 3 ] ;
74968: LD_ADDR_VAR 0 9
74972: PUSH
74973: LD_INT 10
74975: PUSH
74976: LD_INT 5
74978: PUSH
74979: LD_INT 3
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: LIST
74986: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
74987: LD_VAR 0 6
74991: PPUSH
74992: CALL_OW 257
74996: PUSH
74997: LD_INT 2
74999: PUSH
75000: LD_INT 3
75002: PUSH
75003: LD_INT 4
75005: PUSH
75006: EMPTY
75007: LIST
75008: LIST
75009: LIST
75010: IN
75011: IFFALSE 75032
// points := [ 3 , 2 , 1 ] ;
75013: LD_ADDR_VAR 0 9
75017: PUSH
75018: LD_INT 3
75020: PUSH
75021: LD_INT 2
75023: PUSH
75024: LD_INT 1
75026: PUSH
75027: EMPTY
75028: LIST
75029: LIST
75030: LIST
75031: ST_TO_ADDR
// if GetClass ( i ) = 5 then
75032: LD_VAR 0 6
75036: PPUSH
75037: CALL_OW 257
75041: PUSH
75042: LD_INT 5
75044: EQUAL
75045: IFFALSE 75066
// points := [ 130 , 5 , 2 ] ;
75047: LD_ADDR_VAR 0 9
75051: PUSH
75052: LD_INT 130
75054: PUSH
75055: LD_INT 5
75057: PUSH
75058: LD_INT 2
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: LIST
75065: ST_TO_ADDR
// if GetClass ( i ) = 8 then
75066: LD_VAR 0 6
75070: PPUSH
75071: CALL_OW 257
75075: PUSH
75076: LD_INT 8
75078: EQUAL
75079: IFFALSE 75100
// points := [ 35 , 35 , 30 ] ;
75081: LD_ADDR_VAR 0 9
75085: PUSH
75086: LD_INT 35
75088: PUSH
75089: LD_INT 35
75091: PUSH
75092: LD_INT 30
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: LIST
75099: ST_TO_ADDR
// if GetClass ( i ) = 9 then
75100: LD_VAR 0 6
75104: PPUSH
75105: CALL_OW 257
75109: PUSH
75110: LD_INT 9
75112: EQUAL
75113: IFFALSE 75134
// points := [ 20 , 55 , 40 ] ;
75115: LD_ADDR_VAR 0 9
75119: PUSH
75120: LD_INT 20
75122: PUSH
75123: LD_INT 55
75125: PUSH
75126: LD_INT 40
75128: PUSH
75129: EMPTY
75130: LIST
75131: LIST
75132: LIST
75133: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
75134: LD_VAR 0 6
75138: PPUSH
75139: CALL_OW 257
75143: PUSH
75144: LD_INT 12
75146: PUSH
75147: LD_INT 16
75149: PUSH
75150: EMPTY
75151: LIST
75152: LIST
75153: IN
75154: IFFALSE 75175
// points := [ 5 , 3 , 2 ] ;
75156: LD_ADDR_VAR 0 9
75160: PUSH
75161: LD_INT 5
75163: PUSH
75164: LD_INT 3
75166: PUSH
75167: LD_INT 2
75169: PUSH
75170: EMPTY
75171: LIST
75172: LIST
75173: LIST
75174: ST_TO_ADDR
// if GetClass ( i ) = 17 then
75175: LD_VAR 0 6
75179: PPUSH
75180: CALL_OW 257
75184: PUSH
75185: LD_INT 17
75187: EQUAL
75188: IFFALSE 75209
// points := [ 100 , 50 , 75 ] ;
75190: LD_ADDR_VAR 0 9
75194: PUSH
75195: LD_INT 100
75197: PUSH
75198: LD_INT 50
75200: PUSH
75201: LD_INT 75
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: LIST
75208: ST_TO_ADDR
// if GetClass ( i ) = 15 then
75209: LD_VAR 0 6
75213: PPUSH
75214: CALL_OW 257
75218: PUSH
75219: LD_INT 15
75221: EQUAL
75222: IFFALSE 75243
// points := [ 10 , 5 , 3 ] ;
75224: LD_ADDR_VAR 0 9
75228: PUSH
75229: LD_INT 10
75231: PUSH
75232: LD_INT 5
75234: PUSH
75235: LD_INT 3
75237: PUSH
75238: EMPTY
75239: LIST
75240: LIST
75241: LIST
75242: ST_TO_ADDR
// if GetClass ( i ) = 14 then
75243: LD_VAR 0 6
75247: PPUSH
75248: CALL_OW 257
75252: PUSH
75253: LD_INT 14
75255: EQUAL
75256: IFFALSE 75277
// points := [ 10 , 0 , 0 ] ;
75258: LD_ADDR_VAR 0 9
75262: PUSH
75263: LD_INT 10
75265: PUSH
75266: LD_INT 0
75268: PUSH
75269: LD_INT 0
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: LIST
75276: ST_TO_ADDR
// if GetClass ( i ) = 11 then
75277: LD_VAR 0 6
75281: PPUSH
75282: CALL_OW 257
75286: PUSH
75287: LD_INT 11
75289: EQUAL
75290: IFFALSE 75311
// points := [ 30 , 10 , 5 ] ;
75292: LD_ADDR_VAR 0 9
75296: PUSH
75297: LD_INT 30
75299: PUSH
75300: LD_INT 10
75302: PUSH
75303: LD_INT 5
75305: PUSH
75306: EMPTY
75307: LIST
75308: LIST
75309: LIST
75310: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
75311: LD_VAR 0 1
75315: PPUSH
75316: LD_INT 5
75318: PPUSH
75319: CALL_OW 321
75323: PUSH
75324: LD_INT 2
75326: EQUAL
75327: IFFALSE 75344
// bpoints := bpoints * 1.8 ;
75329: LD_ADDR_VAR 0 10
75333: PUSH
75334: LD_VAR 0 10
75338: PUSH
75339: LD_REAL  1.80000000000000E+0000
75342: MUL
75343: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
75344: LD_VAR 0 6
75348: PPUSH
75349: CALL_OW 257
75353: PUSH
75354: LD_INT 1
75356: PUSH
75357: LD_INT 2
75359: PUSH
75360: LD_INT 3
75362: PUSH
75363: LD_INT 4
75365: PUSH
75366: EMPTY
75367: LIST
75368: LIST
75369: LIST
75370: LIST
75371: IN
75372: PUSH
75373: LD_VAR 0 1
75377: PPUSH
75378: LD_INT 51
75380: PPUSH
75381: CALL_OW 321
75385: PUSH
75386: LD_INT 2
75388: EQUAL
75389: AND
75390: IFFALSE 75407
// bpoints := bpoints * 1.2 ;
75392: LD_ADDR_VAR 0 10
75396: PUSH
75397: LD_VAR 0 10
75401: PUSH
75402: LD_REAL  1.20000000000000E+0000
75405: MUL
75406: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
75407: LD_VAR 0 6
75411: PPUSH
75412: CALL_OW 257
75416: PUSH
75417: LD_INT 5
75419: PUSH
75420: LD_INT 7
75422: PUSH
75423: LD_INT 9
75425: PUSH
75426: EMPTY
75427: LIST
75428: LIST
75429: LIST
75430: IN
75431: PUSH
75432: LD_VAR 0 1
75436: PPUSH
75437: LD_INT 52
75439: PPUSH
75440: CALL_OW 321
75444: PUSH
75445: LD_INT 2
75447: EQUAL
75448: AND
75449: IFFALSE 75466
// bpoints := bpoints * 1.5 ;
75451: LD_ADDR_VAR 0 10
75455: PUSH
75456: LD_VAR 0 10
75460: PUSH
75461: LD_REAL  1.50000000000000E+0000
75464: MUL
75465: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
75466: LD_VAR 0 1
75470: PPUSH
75471: LD_INT 66
75473: PPUSH
75474: CALL_OW 321
75478: PUSH
75479: LD_INT 2
75481: EQUAL
75482: IFFALSE 75499
// bpoints := bpoints * 1.1 ;
75484: LD_ADDR_VAR 0 10
75488: PUSH
75489: LD_VAR 0 10
75493: PUSH
75494: LD_REAL  1.10000000000000E+0000
75497: MUL
75498: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
75499: LD_ADDR_VAR 0 10
75503: PUSH
75504: LD_VAR 0 10
75508: PUSH
75509: LD_VAR 0 6
75513: PPUSH
75514: LD_INT 1
75516: PPUSH
75517: CALL_OW 259
75521: PUSH
75522: LD_REAL  1.15000000000000E+0000
75525: MUL
75526: MUL
75527: ST_TO_ADDR
// end ; unit_vehicle :
75528: GO 76356
75530: LD_INT 2
75532: DOUBLE
75533: EQUAL
75534: IFTRUE 75538
75536: GO 76344
75538: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
75539: LD_VAR 0 6
75543: PPUSH
75544: CALL_OW 264
75548: PUSH
75549: LD_INT 2
75551: PUSH
75552: LD_INT 42
75554: PUSH
75555: LD_INT 24
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: LIST
75562: IN
75563: IFFALSE 75584
// points := [ 25 , 5 , 3 ] ;
75565: LD_ADDR_VAR 0 9
75569: PUSH
75570: LD_INT 25
75572: PUSH
75573: LD_INT 5
75575: PUSH
75576: LD_INT 3
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: LIST
75583: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
75584: LD_VAR 0 6
75588: PPUSH
75589: CALL_OW 264
75593: PUSH
75594: LD_INT 4
75596: PUSH
75597: LD_INT 43
75599: PUSH
75600: LD_INT 25
75602: PUSH
75603: EMPTY
75604: LIST
75605: LIST
75606: LIST
75607: IN
75608: IFFALSE 75629
// points := [ 40 , 15 , 5 ] ;
75610: LD_ADDR_VAR 0 9
75614: PUSH
75615: LD_INT 40
75617: PUSH
75618: LD_INT 15
75620: PUSH
75621: LD_INT 5
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: LIST
75628: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
75629: LD_VAR 0 6
75633: PPUSH
75634: CALL_OW 264
75638: PUSH
75639: LD_INT 3
75641: PUSH
75642: LD_INT 23
75644: PUSH
75645: EMPTY
75646: LIST
75647: LIST
75648: IN
75649: IFFALSE 75670
// points := [ 7 , 25 , 8 ] ;
75651: LD_ADDR_VAR 0 9
75655: PUSH
75656: LD_INT 7
75658: PUSH
75659: LD_INT 25
75661: PUSH
75662: LD_INT 8
75664: PUSH
75665: EMPTY
75666: LIST
75667: LIST
75668: LIST
75669: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
75670: LD_VAR 0 6
75674: PPUSH
75675: CALL_OW 264
75679: PUSH
75680: LD_INT 5
75682: PUSH
75683: LD_INT 27
75685: PUSH
75686: LD_INT 44
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: LIST
75693: IN
75694: IFFALSE 75715
// points := [ 14 , 50 , 16 ] ;
75696: LD_ADDR_VAR 0 9
75700: PUSH
75701: LD_INT 14
75703: PUSH
75704: LD_INT 50
75706: PUSH
75707: LD_INT 16
75709: PUSH
75710: EMPTY
75711: LIST
75712: LIST
75713: LIST
75714: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
75715: LD_VAR 0 6
75719: PPUSH
75720: CALL_OW 264
75724: PUSH
75725: LD_INT 6
75727: PUSH
75728: LD_INT 46
75730: PUSH
75731: EMPTY
75732: LIST
75733: LIST
75734: IN
75735: IFFALSE 75756
// points := [ 32 , 120 , 70 ] ;
75737: LD_ADDR_VAR 0 9
75741: PUSH
75742: LD_INT 32
75744: PUSH
75745: LD_INT 120
75747: PUSH
75748: LD_INT 70
75750: PUSH
75751: EMPTY
75752: LIST
75753: LIST
75754: LIST
75755: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
75756: LD_VAR 0 6
75760: PPUSH
75761: CALL_OW 264
75765: PUSH
75766: LD_INT 7
75768: PUSH
75769: LD_INT 28
75771: PUSH
75772: LD_INT 45
75774: PUSH
75775: LD_INT 92
75777: PUSH
75778: EMPTY
75779: LIST
75780: LIST
75781: LIST
75782: LIST
75783: IN
75784: IFFALSE 75805
// points := [ 35 , 20 , 45 ] ;
75786: LD_ADDR_VAR 0 9
75790: PUSH
75791: LD_INT 35
75793: PUSH
75794: LD_INT 20
75796: PUSH
75797: LD_INT 45
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: LIST
75804: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
75805: LD_VAR 0 6
75809: PPUSH
75810: CALL_OW 264
75814: PUSH
75815: LD_INT 47
75817: PUSH
75818: EMPTY
75819: LIST
75820: IN
75821: IFFALSE 75842
// points := [ 67 , 45 , 75 ] ;
75823: LD_ADDR_VAR 0 9
75827: PUSH
75828: LD_INT 67
75830: PUSH
75831: LD_INT 45
75833: PUSH
75834: LD_INT 75
75836: PUSH
75837: EMPTY
75838: LIST
75839: LIST
75840: LIST
75841: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
75842: LD_VAR 0 6
75846: PPUSH
75847: CALL_OW 264
75851: PUSH
75852: LD_INT 26
75854: PUSH
75855: EMPTY
75856: LIST
75857: IN
75858: IFFALSE 75879
// points := [ 120 , 30 , 80 ] ;
75860: LD_ADDR_VAR 0 9
75864: PUSH
75865: LD_INT 120
75867: PUSH
75868: LD_INT 30
75870: PUSH
75871: LD_INT 80
75873: PUSH
75874: EMPTY
75875: LIST
75876: LIST
75877: LIST
75878: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
75879: LD_VAR 0 6
75883: PPUSH
75884: CALL_OW 264
75888: PUSH
75889: LD_INT 22
75891: PUSH
75892: EMPTY
75893: LIST
75894: IN
75895: IFFALSE 75916
// points := [ 40 , 1 , 1 ] ;
75897: LD_ADDR_VAR 0 9
75901: PUSH
75902: LD_INT 40
75904: PUSH
75905: LD_INT 1
75907: PUSH
75908: LD_INT 1
75910: PUSH
75911: EMPTY
75912: LIST
75913: LIST
75914: LIST
75915: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
75916: LD_VAR 0 6
75920: PPUSH
75921: CALL_OW 264
75925: PUSH
75926: LD_INT 29
75928: PUSH
75929: EMPTY
75930: LIST
75931: IN
75932: IFFALSE 75953
// points := [ 70 , 200 , 400 ] ;
75934: LD_ADDR_VAR 0 9
75938: PUSH
75939: LD_INT 70
75941: PUSH
75942: LD_INT 200
75944: PUSH
75945: LD_INT 400
75947: PUSH
75948: EMPTY
75949: LIST
75950: LIST
75951: LIST
75952: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
75953: LD_VAR 0 6
75957: PPUSH
75958: CALL_OW 264
75962: PUSH
75963: LD_INT 14
75965: PUSH
75966: LD_INT 53
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: IN
75973: IFFALSE 75994
// points := [ 40 , 10 , 20 ] ;
75975: LD_ADDR_VAR 0 9
75979: PUSH
75980: LD_INT 40
75982: PUSH
75983: LD_INT 10
75985: PUSH
75986: LD_INT 20
75988: PUSH
75989: EMPTY
75990: LIST
75991: LIST
75992: LIST
75993: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
75994: LD_VAR 0 6
75998: PPUSH
75999: CALL_OW 264
76003: PUSH
76004: LD_INT 9
76006: PUSH
76007: EMPTY
76008: LIST
76009: IN
76010: IFFALSE 76031
// points := [ 5 , 70 , 20 ] ;
76012: LD_ADDR_VAR 0 9
76016: PUSH
76017: LD_INT 5
76019: PUSH
76020: LD_INT 70
76022: PUSH
76023: LD_INT 20
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: LIST
76030: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
76031: LD_VAR 0 6
76035: PPUSH
76036: CALL_OW 264
76040: PUSH
76041: LD_INT 10
76043: PUSH
76044: EMPTY
76045: LIST
76046: IN
76047: IFFALSE 76068
// points := [ 35 , 110 , 70 ] ;
76049: LD_ADDR_VAR 0 9
76053: PUSH
76054: LD_INT 35
76056: PUSH
76057: LD_INT 110
76059: PUSH
76060: LD_INT 70
76062: PUSH
76063: EMPTY
76064: LIST
76065: LIST
76066: LIST
76067: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
76068: LD_VAR 0 6
76072: PPUSH
76073: CALL_OW 265
76077: PUSH
76078: LD_INT 25
76080: EQUAL
76081: IFFALSE 76102
// points := [ 80 , 65 , 100 ] ;
76083: LD_ADDR_VAR 0 9
76087: PUSH
76088: LD_INT 80
76090: PUSH
76091: LD_INT 65
76093: PUSH
76094: LD_INT 100
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: LIST
76101: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
76102: LD_VAR 0 6
76106: PPUSH
76107: CALL_OW 263
76111: PUSH
76112: LD_INT 1
76114: EQUAL
76115: IFFALSE 76150
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
76117: LD_ADDR_VAR 0 10
76121: PUSH
76122: LD_VAR 0 10
76126: PUSH
76127: LD_VAR 0 6
76131: PPUSH
76132: CALL_OW 311
76136: PPUSH
76137: LD_INT 3
76139: PPUSH
76140: CALL_OW 259
76144: PUSH
76145: LD_INT 4
76147: MUL
76148: MUL
76149: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
76150: LD_VAR 0 6
76154: PPUSH
76155: CALL_OW 263
76159: PUSH
76160: LD_INT 2
76162: EQUAL
76163: IFFALSE 76214
// begin j := IsControledBy ( i ) ;
76165: LD_ADDR_VAR 0 7
76169: PUSH
76170: LD_VAR 0 6
76174: PPUSH
76175: CALL_OW 312
76179: ST_TO_ADDR
// if j then
76180: LD_VAR 0 7
76184: IFFALSE 76214
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
76186: LD_ADDR_VAR 0 10
76190: PUSH
76191: LD_VAR 0 10
76195: PUSH
76196: LD_VAR 0 7
76200: PPUSH
76201: LD_INT 3
76203: PPUSH
76204: CALL_OW 259
76208: PUSH
76209: LD_INT 3
76211: MUL
76212: MUL
76213: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
76214: LD_VAR 0 6
76218: PPUSH
76219: CALL_OW 264
76223: PUSH
76224: LD_INT 5
76226: PUSH
76227: LD_INT 6
76229: PUSH
76230: LD_INT 46
76232: PUSH
76233: LD_INT 44
76235: PUSH
76236: LD_INT 47
76238: PUSH
76239: LD_INT 45
76241: PUSH
76242: LD_INT 28
76244: PUSH
76245: LD_INT 7
76247: PUSH
76248: LD_INT 27
76250: PUSH
76251: LD_INT 29
76253: PUSH
76254: EMPTY
76255: LIST
76256: LIST
76257: LIST
76258: LIST
76259: LIST
76260: LIST
76261: LIST
76262: LIST
76263: LIST
76264: LIST
76265: IN
76266: PUSH
76267: LD_VAR 0 1
76271: PPUSH
76272: LD_INT 52
76274: PPUSH
76275: CALL_OW 321
76279: PUSH
76280: LD_INT 2
76282: EQUAL
76283: AND
76284: IFFALSE 76301
// bpoints := bpoints * 1.2 ;
76286: LD_ADDR_VAR 0 10
76290: PUSH
76291: LD_VAR 0 10
76295: PUSH
76296: LD_REAL  1.20000000000000E+0000
76299: MUL
76300: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
76301: LD_VAR 0 6
76305: PPUSH
76306: CALL_OW 264
76310: PUSH
76311: LD_INT 6
76313: PUSH
76314: LD_INT 46
76316: PUSH
76317: LD_INT 47
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: LIST
76324: IN
76325: IFFALSE 76342
// bpoints := bpoints * 1.2 ;
76327: LD_ADDR_VAR 0 10
76331: PUSH
76332: LD_VAR 0 10
76336: PUSH
76337: LD_REAL  1.20000000000000E+0000
76340: MUL
76341: ST_TO_ADDR
// end ; unit_building :
76342: GO 76356
76344: LD_INT 3
76346: DOUBLE
76347: EQUAL
76348: IFTRUE 76352
76350: GO 76355
76352: POP
// ; end ;
76353: GO 76356
76355: POP
// for j = 1 to 3 do
76356: LD_ADDR_VAR 0 7
76360: PUSH
76361: DOUBLE
76362: LD_INT 1
76364: DEC
76365: ST_TO_ADDR
76366: LD_INT 3
76368: PUSH
76369: FOR_TO
76370: IFFALSE 76423
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
76372: LD_ADDR_VAR 0 5
76376: PUSH
76377: LD_VAR 0 5
76381: PPUSH
76382: LD_VAR 0 7
76386: PPUSH
76387: LD_VAR 0 5
76391: PUSH
76392: LD_VAR 0 7
76396: ARRAY
76397: PUSH
76398: LD_VAR 0 9
76402: PUSH
76403: LD_VAR 0 7
76407: ARRAY
76408: PUSH
76409: LD_VAR 0 10
76413: MUL
76414: PLUS
76415: PPUSH
76416: CALL_OW 1
76420: ST_TO_ADDR
76421: GO 76369
76423: POP
76424: POP
// end ;
76425: GO 74904
76427: POP
76428: POP
// result := Replace ( result , 4 , tmp ) ;
76429: LD_ADDR_VAR 0 5
76433: PUSH
76434: LD_VAR 0 5
76438: PPUSH
76439: LD_INT 4
76441: PPUSH
76442: LD_VAR 0 8
76446: PPUSH
76447: CALL_OW 1
76451: ST_TO_ADDR
// end ;
76452: LD_VAR 0 5
76456: RET
// export function DangerAtRange ( unit , range ) ; begin
76457: LD_INT 0
76459: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
76460: LD_ADDR_VAR 0 3
76464: PUSH
76465: LD_VAR 0 1
76469: PPUSH
76470: CALL_OW 255
76474: PPUSH
76475: LD_VAR 0 1
76479: PPUSH
76480: CALL_OW 250
76484: PPUSH
76485: LD_VAR 0 1
76489: PPUSH
76490: CALL_OW 251
76494: PPUSH
76495: LD_VAR 0 2
76499: PPUSH
76500: CALL 74756 0 4
76504: ST_TO_ADDR
// end ;
76505: LD_VAR 0 3
76509: RET
// export function DangerInArea ( side , area ) ; begin
76510: LD_INT 0
76512: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
76513: LD_ADDR_VAR 0 3
76517: PUSH
76518: LD_VAR 0 2
76522: PPUSH
76523: LD_INT 81
76525: PUSH
76526: LD_VAR 0 1
76530: PUSH
76531: EMPTY
76532: LIST
76533: LIST
76534: PPUSH
76535: CALL_OW 70
76539: ST_TO_ADDR
// end ;
76540: LD_VAR 0 3
76544: RET
// export function IsExtension ( b ) ; begin
76545: LD_INT 0
76547: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
76548: LD_ADDR_VAR 0 2
76552: PUSH
76553: LD_VAR 0 1
76557: PUSH
76558: LD_INT 23
76560: PUSH
76561: LD_INT 20
76563: PUSH
76564: LD_INT 22
76566: PUSH
76567: LD_INT 17
76569: PUSH
76570: LD_INT 24
76572: PUSH
76573: LD_INT 21
76575: PUSH
76576: LD_INT 19
76578: PUSH
76579: LD_INT 16
76581: PUSH
76582: LD_INT 25
76584: PUSH
76585: LD_INT 18
76587: PUSH
76588: EMPTY
76589: LIST
76590: LIST
76591: LIST
76592: LIST
76593: LIST
76594: LIST
76595: LIST
76596: LIST
76597: LIST
76598: LIST
76599: IN
76600: ST_TO_ADDR
// end ;
76601: LD_VAR 0 2
76605: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
76606: LD_INT 0
76608: PPUSH
76609: PPUSH
76610: PPUSH
// result := [ ] ;
76611: LD_ADDR_VAR 0 4
76615: PUSH
76616: EMPTY
76617: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
76618: LD_ADDR_VAR 0 5
76622: PUSH
76623: LD_VAR 0 2
76627: PPUSH
76628: LD_INT 21
76630: PUSH
76631: LD_INT 3
76633: PUSH
76634: EMPTY
76635: LIST
76636: LIST
76637: PPUSH
76638: CALL_OW 70
76642: ST_TO_ADDR
// if not tmp then
76643: LD_VAR 0 5
76647: NOT
76648: IFFALSE 76652
// exit ;
76650: GO 76716
// if checkLink then
76652: LD_VAR 0 3
76656: IFFALSE 76706
// begin for i in tmp do
76658: LD_ADDR_VAR 0 6
76662: PUSH
76663: LD_VAR 0 5
76667: PUSH
76668: FOR_IN
76669: IFFALSE 76704
// if GetBase ( i ) <> base then
76671: LD_VAR 0 6
76675: PPUSH
76676: CALL_OW 274
76680: PUSH
76681: LD_VAR 0 1
76685: NONEQUAL
76686: IFFALSE 76702
// ComLinkToBase ( base , i ) ;
76688: LD_VAR 0 1
76692: PPUSH
76693: LD_VAR 0 6
76697: PPUSH
76698: CALL_OW 169
76702: GO 76668
76704: POP
76705: POP
// end ; result := tmp ;
76706: LD_ADDR_VAR 0 4
76710: PUSH
76711: LD_VAR 0 5
76715: ST_TO_ADDR
// end ;
76716: LD_VAR 0 4
76720: RET
// export function ComComplete ( units , b ) ; var i ; begin
76721: LD_INT 0
76723: PPUSH
76724: PPUSH
// if not units then
76725: LD_VAR 0 1
76729: NOT
76730: IFFALSE 76734
// exit ;
76732: GO 76824
// for i in units do
76734: LD_ADDR_VAR 0 4
76738: PUSH
76739: LD_VAR 0 1
76743: PUSH
76744: FOR_IN
76745: IFFALSE 76822
// if BuildingStatus ( b ) = bs_build then
76747: LD_VAR 0 2
76751: PPUSH
76752: CALL_OW 461
76756: PUSH
76757: LD_INT 1
76759: EQUAL
76760: IFFALSE 76820
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
76762: LD_VAR 0 4
76766: PPUSH
76767: LD_STRING h
76769: PUSH
76770: LD_VAR 0 2
76774: PPUSH
76775: CALL_OW 250
76779: PUSH
76780: LD_VAR 0 2
76784: PPUSH
76785: CALL_OW 251
76789: PUSH
76790: LD_VAR 0 2
76794: PUSH
76795: LD_INT 0
76797: PUSH
76798: LD_INT 0
76800: PUSH
76801: LD_INT 0
76803: PUSH
76804: EMPTY
76805: LIST
76806: LIST
76807: LIST
76808: LIST
76809: LIST
76810: LIST
76811: LIST
76812: PUSH
76813: EMPTY
76814: LIST
76815: PPUSH
76816: CALL_OW 446
76820: GO 76744
76822: POP
76823: POP
// end ;
76824: LD_VAR 0 3
76828: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
76829: LD_INT 0
76831: PPUSH
76832: PPUSH
76833: PPUSH
76834: PPUSH
76835: PPUSH
76836: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
76837: LD_VAR 0 1
76841: NOT
76842: PUSH
76843: LD_VAR 0 1
76847: PPUSH
76848: CALL_OW 263
76852: PUSH
76853: LD_INT 2
76855: NONEQUAL
76856: OR
76857: IFFALSE 76861
// exit ;
76859: GO 77177
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
76861: LD_ADDR_VAR 0 6
76865: PUSH
76866: LD_INT 22
76868: PUSH
76869: LD_VAR 0 1
76873: PPUSH
76874: CALL_OW 255
76878: PUSH
76879: EMPTY
76880: LIST
76881: LIST
76882: PUSH
76883: LD_INT 2
76885: PUSH
76886: LD_INT 30
76888: PUSH
76889: LD_INT 36
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 34
76898: PUSH
76899: LD_INT 31
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: EMPTY
76907: LIST
76908: LIST
76909: LIST
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PPUSH
76915: CALL_OW 69
76919: ST_TO_ADDR
// if not tmp then
76920: LD_VAR 0 6
76924: NOT
76925: IFFALSE 76929
// exit ;
76927: GO 77177
// result := [ ] ;
76929: LD_ADDR_VAR 0 2
76933: PUSH
76934: EMPTY
76935: ST_TO_ADDR
// for i in tmp do
76936: LD_ADDR_VAR 0 3
76940: PUSH
76941: LD_VAR 0 6
76945: PUSH
76946: FOR_IN
76947: IFFALSE 77018
// begin t := UnitsInside ( i ) ;
76949: LD_ADDR_VAR 0 4
76953: PUSH
76954: LD_VAR 0 3
76958: PPUSH
76959: CALL_OW 313
76963: ST_TO_ADDR
// if t then
76964: LD_VAR 0 4
76968: IFFALSE 77016
// for j in t do
76970: LD_ADDR_VAR 0 7
76974: PUSH
76975: LD_VAR 0 4
76979: PUSH
76980: FOR_IN
76981: IFFALSE 77014
// result := Replace ( result , result + 1 , j ) ;
76983: LD_ADDR_VAR 0 2
76987: PUSH
76988: LD_VAR 0 2
76992: PPUSH
76993: LD_VAR 0 2
76997: PUSH
76998: LD_INT 1
77000: PLUS
77001: PPUSH
77002: LD_VAR 0 7
77006: PPUSH
77007: CALL_OW 1
77011: ST_TO_ADDR
77012: GO 76980
77014: POP
77015: POP
// end ;
77016: GO 76946
77018: POP
77019: POP
// if not result then
77020: LD_VAR 0 2
77024: NOT
77025: IFFALSE 77029
// exit ;
77027: GO 77177
// mech := result [ 1 ] ;
77029: LD_ADDR_VAR 0 5
77033: PUSH
77034: LD_VAR 0 2
77038: PUSH
77039: LD_INT 1
77041: ARRAY
77042: ST_TO_ADDR
// if result > 1 then
77043: LD_VAR 0 2
77047: PUSH
77048: LD_INT 1
77050: GREATER
77051: IFFALSE 77163
// begin for i = 2 to result do
77053: LD_ADDR_VAR 0 3
77057: PUSH
77058: DOUBLE
77059: LD_INT 2
77061: DEC
77062: ST_TO_ADDR
77063: LD_VAR 0 2
77067: PUSH
77068: FOR_TO
77069: IFFALSE 77161
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
77071: LD_ADDR_VAR 0 4
77075: PUSH
77076: LD_VAR 0 2
77080: PUSH
77081: LD_VAR 0 3
77085: ARRAY
77086: PPUSH
77087: LD_INT 3
77089: PPUSH
77090: CALL_OW 259
77094: PUSH
77095: LD_VAR 0 2
77099: PUSH
77100: LD_VAR 0 3
77104: ARRAY
77105: PPUSH
77106: CALL_OW 432
77110: MINUS
77111: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
77112: LD_VAR 0 4
77116: PUSH
77117: LD_VAR 0 5
77121: PPUSH
77122: LD_INT 3
77124: PPUSH
77125: CALL_OW 259
77129: PUSH
77130: LD_VAR 0 5
77134: PPUSH
77135: CALL_OW 432
77139: MINUS
77140: GREATEREQUAL
77141: IFFALSE 77159
// mech := result [ i ] ;
77143: LD_ADDR_VAR 0 5
77147: PUSH
77148: LD_VAR 0 2
77152: PUSH
77153: LD_VAR 0 3
77157: ARRAY
77158: ST_TO_ADDR
// end ;
77159: GO 77068
77161: POP
77162: POP
// end ; ComLinkTo ( vehicle , mech ) ;
77163: LD_VAR 0 1
77167: PPUSH
77168: LD_VAR 0 5
77172: PPUSH
77173: CALL_OW 135
// end ;
77177: LD_VAR 0 2
77181: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
77182: LD_INT 0
77184: PPUSH
77185: PPUSH
77186: PPUSH
77187: PPUSH
77188: PPUSH
77189: PPUSH
77190: PPUSH
77191: PPUSH
77192: PPUSH
77193: PPUSH
77194: PPUSH
77195: PPUSH
77196: PPUSH
// result := [ ] ;
77197: LD_ADDR_VAR 0 7
77201: PUSH
77202: EMPTY
77203: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
77204: LD_VAR 0 1
77208: PPUSH
77209: CALL_OW 266
77213: PUSH
77214: LD_INT 0
77216: PUSH
77217: LD_INT 1
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: IN
77224: NOT
77225: IFFALSE 77229
// exit ;
77227: GO 78863
// if name then
77229: LD_VAR 0 3
77233: IFFALSE 77249
// SetBName ( base_dep , name ) ;
77235: LD_VAR 0 1
77239: PPUSH
77240: LD_VAR 0 3
77244: PPUSH
77245: CALL_OW 500
// base := GetBase ( base_dep ) ;
77249: LD_ADDR_VAR 0 15
77253: PUSH
77254: LD_VAR 0 1
77258: PPUSH
77259: CALL_OW 274
77263: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
77264: LD_ADDR_VAR 0 16
77268: PUSH
77269: LD_VAR 0 1
77273: PPUSH
77274: CALL_OW 255
77278: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
77279: LD_ADDR_VAR 0 17
77283: PUSH
77284: LD_VAR 0 1
77288: PPUSH
77289: CALL_OW 248
77293: ST_TO_ADDR
// if sources then
77294: LD_VAR 0 5
77298: IFFALSE 77345
// for i = 1 to 3 do
77300: LD_ADDR_VAR 0 8
77304: PUSH
77305: DOUBLE
77306: LD_INT 1
77308: DEC
77309: ST_TO_ADDR
77310: LD_INT 3
77312: PUSH
77313: FOR_TO
77314: IFFALSE 77343
// AddResourceType ( base , i , sources [ i ] ) ;
77316: LD_VAR 0 15
77320: PPUSH
77321: LD_VAR 0 8
77325: PPUSH
77326: LD_VAR 0 5
77330: PUSH
77331: LD_VAR 0 8
77335: ARRAY
77336: PPUSH
77337: CALL_OW 276
77341: GO 77313
77343: POP
77344: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
77345: LD_ADDR_VAR 0 18
77349: PUSH
77350: LD_VAR 0 15
77354: PPUSH
77355: LD_VAR 0 2
77359: PPUSH
77360: LD_INT 1
77362: PPUSH
77363: CALL 76606 0 3
77367: ST_TO_ADDR
// InitHc ;
77368: CALL_OW 19
// InitUc ;
77372: CALL_OW 18
// uc_side := side ;
77376: LD_ADDR_OWVAR 20
77380: PUSH
77381: LD_VAR 0 16
77385: ST_TO_ADDR
// uc_nation := nation ;
77386: LD_ADDR_OWVAR 21
77390: PUSH
77391: LD_VAR 0 17
77395: ST_TO_ADDR
// if buildings then
77396: LD_VAR 0 18
77400: IFFALSE 78722
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
77402: LD_ADDR_VAR 0 19
77406: PUSH
77407: LD_VAR 0 18
77411: PPUSH
77412: LD_INT 2
77414: PUSH
77415: LD_INT 30
77417: PUSH
77418: LD_INT 29
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: LD_INT 30
77427: PUSH
77428: LD_INT 30
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: LIST
77439: PPUSH
77440: CALL_OW 72
77444: ST_TO_ADDR
// if tmp then
77445: LD_VAR 0 19
77449: IFFALSE 77497
// for i in tmp do
77451: LD_ADDR_VAR 0 8
77455: PUSH
77456: LD_VAR 0 19
77460: PUSH
77461: FOR_IN
77462: IFFALSE 77495
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
77464: LD_VAR 0 8
77468: PPUSH
77469: CALL_OW 250
77473: PPUSH
77474: LD_VAR 0 8
77478: PPUSH
77479: CALL_OW 251
77483: PPUSH
77484: LD_VAR 0 16
77488: PPUSH
77489: CALL_OW 441
77493: GO 77461
77495: POP
77496: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
77497: LD_VAR 0 18
77501: PPUSH
77502: LD_INT 2
77504: PUSH
77505: LD_INT 30
77507: PUSH
77508: LD_INT 32
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PUSH
77515: LD_INT 30
77517: PUSH
77518: LD_INT 33
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: EMPTY
77526: LIST
77527: LIST
77528: LIST
77529: PPUSH
77530: CALL_OW 72
77534: IFFALSE 77622
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
77536: LD_ADDR_VAR 0 8
77540: PUSH
77541: LD_VAR 0 18
77545: PPUSH
77546: LD_INT 2
77548: PUSH
77549: LD_INT 30
77551: PUSH
77552: LD_INT 32
77554: PUSH
77555: EMPTY
77556: LIST
77557: LIST
77558: PUSH
77559: LD_INT 30
77561: PUSH
77562: LD_INT 33
77564: PUSH
77565: EMPTY
77566: LIST
77567: LIST
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: LIST
77573: PPUSH
77574: CALL_OW 72
77578: PUSH
77579: FOR_IN
77580: IFFALSE 77620
// begin if not GetBWeapon ( i ) then
77582: LD_VAR 0 8
77586: PPUSH
77587: CALL_OW 269
77591: NOT
77592: IFFALSE 77618
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
77594: LD_VAR 0 8
77598: PPUSH
77599: LD_VAR 0 8
77603: PPUSH
77604: LD_VAR 0 2
77608: PPUSH
77609: CALL 78868 0 2
77613: PPUSH
77614: CALL_OW 431
// end ;
77618: GO 77579
77620: POP
77621: POP
// end ; for i = 1 to personel do
77622: LD_ADDR_VAR 0 8
77626: PUSH
77627: DOUBLE
77628: LD_INT 1
77630: DEC
77631: ST_TO_ADDR
77632: LD_VAR 0 6
77636: PUSH
77637: FOR_TO
77638: IFFALSE 78702
// begin if i > 4 then
77640: LD_VAR 0 8
77644: PUSH
77645: LD_INT 4
77647: GREATER
77648: IFFALSE 77652
// break ;
77650: GO 78702
// case i of 1 :
77652: LD_VAR 0 8
77656: PUSH
77657: LD_INT 1
77659: DOUBLE
77660: EQUAL
77661: IFTRUE 77665
77663: GO 77745
77665: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
77666: LD_ADDR_VAR 0 12
77670: PUSH
77671: LD_VAR 0 18
77675: PPUSH
77676: LD_INT 22
77678: PUSH
77679: LD_VAR 0 16
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: LD_INT 58
77690: PUSH
77691: EMPTY
77692: LIST
77693: PUSH
77694: LD_INT 2
77696: PUSH
77697: LD_INT 30
77699: PUSH
77700: LD_INT 32
77702: PUSH
77703: EMPTY
77704: LIST
77705: LIST
77706: PUSH
77707: LD_INT 30
77709: PUSH
77710: LD_INT 4
77712: PUSH
77713: EMPTY
77714: LIST
77715: LIST
77716: PUSH
77717: LD_INT 30
77719: PUSH
77720: LD_INT 5
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: LIST
77737: PPUSH
77738: CALL_OW 72
77742: ST_TO_ADDR
77743: GO 77967
77745: LD_INT 2
77747: DOUBLE
77748: EQUAL
77749: IFTRUE 77753
77751: GO 77815
77753: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
77754: LD_ADDR_VAR 0 12
77758: PUSH
77759: LD_VAR 0 18
77763: PPUSH
77764: LD_INT 22
77766: PUSH
77767: LD_VAR 0 16
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: LD_INT 2
77778: PUSH
77779: LD_INT 30
77781: PUSH
77782: LD_INT 0
77784: PUSH
77785: EMPTY
77786: LIST
77787: LIST
77788: PUSH
77789: LD_INT 30
77791: PUSH
77792: LD_INT 1
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: EMPTY
77800: LIST
77801: LIST
77802: LIST
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PPUSH
77808: CALL_OW 72
77812: ST_TO_ADDR
77813: GO 77967
77815: LD_INT 3
77817: DOUBLE
77818: EQUAL
77819: IFTRUE 77823
77821: GO 77885
77823: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
77824: LD_ADDR_VAR 0 12
77828: PUSH
77829: LD_VAR 0 18
77833: PPUSH
77834: LD_INT 22
77836: PUSH
77837: LD_VAR 0 16
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: PUSH
77846: LD_INT 2
77848: PUSH
77849: LD_INT 30
77851: PUSH
77852: LD_INT 2
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: LD_INT 30
77861: PUSH
77862: LD_INT 3
77864: PUSH
77865: EMPTY
77866: LIST
77867: LIST
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: LIST
77873: PUSH
77874: EMPTY
77875: LIST
77876: LIST
77877: PPUSH
77878: CALL_OW 72
77882: ST_TO_ADDR
77883: GO 77967
77885: LD_INT 4
77887: DOUBLE
77888: EQUAL
77889: IFTRUE 77893
77891: GO 77966
77893: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
77894: LD_ADDR_VAR 0 12
77898: PUSH
77899: LD_VAR 0 18
77903: PPUSH
77904: LD_INT 22
77906: PUSH
77907: LD_VAR 0 16
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 2
77918: PUSH
77919: LD_INT 30
77921: PUSH
77922: LD_INT 6
77924: PUSH
77925: EMPTY
77926: LIST
77927: LIST
77928: PUSH
77929: LD_INT 30
77931: PUSH
77932: LD_INT 7
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 30
77941: PUSH
77942: LD_INT 8
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PUSH
77949: EMPTY
77950: LIST
77951: LIST
77952: LIST
77953: LIST
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PPUSH
77959: CALL_OW 72
77963: ST_TO_ADDR
77964: GO 77967
77966: POP
// if i = 1 then
77967: LD_VAR 0 8
77971: PUSH
77972: LD_INT 1
77974: EQUAL
77975: IFFALSE 78086
// begin tmp := [ ] ;
77977: LD_ADDR_VAR 0 19
77981: PUSH
77982: EMPTY
77983: ST_TO_ADDR
// for j in f do
77984: LD_ADDR_VAR 0 9
77988: PUSH
77989: LD_VAR 0 12
77993: PUSH
77994: FOR_IN
77995: IFFALSE 78068
// if GetBType ( j ) = b_bunker then
77997: LD_VAR 0 9
78001: PPUSH
78002: CALL_OW 266
78006: PUSH
78007: LD_INT 32
78009: EQUAL
78010: IFFALSE 78037
// tmp := Insert ( tmp , 1 , j ) else
78012: LD_ADDR_VAR 0 19
78016: PUSH
78017: LD_VAR 0 19
78021: PPUSH
78022: LD_INT 1
78024: PPUSH
78025: LD_VAR 0 9
78029: PPUSH
78030: CALL_OW 2
78034: ST_TO_ADDR
78035: GO 78066
// tmp := Insert ( tmp , tmp + 1 , j ) ;
78037: LD_ADDR_VAR 0 19
78041: PUSH
78042: LD_VAR 0 19
78046: PPUSH
78047: LD_VAR 0 19
78051: PUSH
78052: LD_INT 1
78054: PLUS
78055: PPUSH
78056: LD_VAR 0 9
78060: PPUSH
78061: CALL_OW 2
78065: ST_TO_ADDR
78066: GO 77994
78068: POP
78069: POP
// if tmp then
78070: LD_VAR 0 19
78074: IFFALSE 78086
// f := tmp ;
78076: LD_ADDR_VAR 0 12
78080: PUSH
78081: LD_VAR 0 19
78085: ST_TO_ADDR
// end ; x := personel [ i ] ;
78086: LD_ADDR_VAR 0 13
78090: PUSH
78091: LD_VAR 0 6
78095: PUSH
78096: LD_VAR 0 8
78100: ARRAY
78101: ST_TO_ADDR
// if x = - 1 then
78102: LD_VAR 0 13
78106: PUSH
78107: LD_INT 1
78109: NEG
78110: EQUAL
78111: IFFALSE 78320
// begin for j in f do
78113: LD_ADDR_VAR 0 9
78117: PUSH
78118: LD_VAR 0 12
78122: PUSH
78123: FOR_IN
78124: IFFALSE 78316
// repeat InitHc ;
78126: CALL_OW 19
// if GetBType ( j ) = b_barracks then
78130: LD_VAR 0 9
78134: PPUSH
78135: CALL_OW 266
78139: PUSH
78140: LD_INT 5
78142: EQUAL
78143: IFFALSE 78213
// begin if UnitsInside ( j ) < 3 then
78145: LD_VAR 0 9
78149: PPUSH
78150: CALL_OW 313
78154: PUSH
78155: LD_INT 3
78157: LESS
78158: IFFALSE 78194
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
78160: LD_INT 0
78162: PPUSH
78163: LD_INT 5
78165: PUSH
78166: LD_INT 8
78168: PUSH
78169: LD_INT 9
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: LIST
78176: PUSH
78177: LD_VAR 0 17
78181: ARRAY
78182: PPUSH
78183: LD_VAR 0 4
78187: PPUSH
78188: CALL_OW 380
78192: GO 78211
// PrepareHuman ( false , i , skill ) ;
78194: LD_INT 0
78196: PPUSH
78197: LD_VAR 0 8
78201: PPUSH
78202: LD_VAR 0 4
78206: PPUSH
78207: CALL_OW 380
// end else
78211: GO 78230
// PrepareHuman ( false , i , skill ) ;
78213: LD_INT 0
78215: PPUSH
78216: LD_VAR 0 8
78220: PPUSH
78221: LD_VAR 0 4
78225: PPUSH
78226: CALL_OW 380
// un := CreateHuman ;
78230: LD_ADDR_VAR 0 14
78234: PUSH
78235: CALL_OW 44
78239: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
78240: LD_ADDR_VAR 0 7
78244: PUSH
78245: LD_VAR 0 7
78249: PPUSH
78250: LD_INT 1
78252: PPUSH
78253: LD_VAR 0 14
78257: PPUSH
78258: CALL_OW 2
78262: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
78263: LD_VAR 0 14
78267: PPUSH
78268: LD_VAR 0 9
78272: PPUSH
78273: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
78277: LD_VAR 0 9
78281: PPUSH
78282: CALL_OW 313
78286: PUSH
78287: LD_INT 6
78289: EQUAL
78290: PUSH
78291: LD_VAR 0 9
78295: PPUSH
78296: CALL_OW 266
78300: PUSH
78301: LD_INT 32
78303: PUSH
78304: LD_INT 31
78306: PUSH
78307: EMPTY
78308: LIST
78309: LIST
78310: IN
78311: OR
78312: IFFALSE 78126
78314: GO 78123
78316: POP
78317: POP
// end else
78318: GO 78700
// for j = 1 to x do
78320: LD_ADDR_VAR 0 9
78324: PUSH
78325: DOUBLE
78326: LD_INT 1
78328: DEC
78329: ST_TO_ADDR
78330: LD_VAR 0 13
78334: PUSH
78335: FOR_TO
78336: IFFALSE 78698
// begin InitHc ;
78338: CALL_OW 19
// if not f then
78342: LD_VAR 0 12
78346: NOT
78347: IFFALSE 78436
// begin PrepareHuman ( false , i , skill ) ;
78349: LD_INT 0
78351: PPUSH
78352: LD_VAR 0 8
78356: PPUSH
78357: LD_VAR 0 4
78361: PPUSH
78362: CALL_OW 380
// un := CreateHuman ;
78366: LD_ADDR_VAR 0 14
78370: PUSH
78371: CALL_OW 44
78375: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
78376: LD_ADDR_VAR 0 7
78380: PUSH
78381: LD_VAR 0 7
78385: PPUSH
78386: LD_INT 1
78388: PPUSH
78389: LD_VAR 0 14
78393: PPUSH
78394: CALL_OW 2
78398: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
78399: LD_VAR 0 14
78403: PPUSH
78404: LD_VAR 0 1
78408: PPUSH
78409: CALL_OW 250
78413: PPUSH
78414: LD_VAR 0 1
78418: PPUSH
78419: CALL_OW 251
78423: PPUSH
78424: LD_INT 10
78426: PPUSH
78427: LD_INT 0
78429: PPUSH
78430: CALL_OW 50
// continue ;
78434: GO 78335
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
78436: LD_VAR 0 12
78440: PUSH
78441: LD_INT 1
78443: ARRAY
78444: PPUSH
78445: CALL_OW 313
78449: PUSH
78450: LD_VAR 0 12
78454: PUSH
78455: LD_INT 1
78457: ARRAY
78458: PPUSH
78459: CALL_OW 266
78463: PUSH
78464: LD_INT 32
78466: PUSH
78467: LD_INT 31
78469: PUSH
78470: EMPTY
78471: LIST
78472: LIST
78473: IN
78474: AND
78475: PUSH
78476: LD_VAR 0 12
78480: PUSH
78481: LD_INT 1
78483: ARRAY
78484: PPUSH
78485: CALL_OW 313
78489: PUSH
78490: LD_INT 6
78492: EQUAL
78493: OR
78494: IFFALSE 78514
// f := Delete ( f , 1 ) ;
78496: LD_ADDR_VAR 0 12
78500: PUSH
78501: LD_VAR 0 12
78505: PPUSH
78506: LD_INT 1
78508: PPUSH
78509: CALL_OW 3
78513: ST_TO_ADDR
// if not f then
78514: LD_VAR 0 12
78518: NOT
78519: IFFALSE 78537
// begin x := x + 2 ;
78521: LD_ADDR_VAR 0 13
78525: PUSH
78526: LD_VAR 0 13
78530: PUSH
78531: LD_INT 2
78533: PLUS
78534: ST_TO_ADDR
// continue ;
78535: GO 78335
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
78537: LD_VAR 0 12
78541: PUSH
78542: LD_INT 1
78544: ARRAY
78545: PPUSH
78546: CALL_OW 266
78550: PUSH
78551: LD_INT 5
78553: EQUAL
78554: IFFALSE 78628
// begin if UnitsInside ( f [ 1 ] ) < 3 then
78556: LD_VAR 0 12
78560: PUSH
78561: LD_INT 1
78563: ARRAY
78564: PPUSH
78565: CALL_OW 313
78569: PUSH
78570: LD_INT 3
78572: LESS
78573: IFFALSE 78609
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
78575: LD_INT 0
78577: PPUSH
78578: LD_INT 5
78580: PUSH
78581: LD_INT 8
78583: PUSH
78584: LD_INT 9
78586: PUSH
78587: EMPTY
78588: LIST
78589: LIST
78590: LIST
78591: PUSH
78592: LD_VAR 0 17
78596: ARRAY
78597: PPUSH
78598: LD_VAR 0 4
78602: PPUSH
78603: CALL_OW 380
78607: GO 78626
// PrepareHuman ( false , i , skill ) ;
78609: LD_INT 0
78611: PPUSH
78612: LD_VAR 0 8
78616: PPUSH
78617: LD_VAR 0 4
78621: PPUSH
78622: CALL_OW 380
// end else
78626: GO 78645
// PrepareHuman ( false , i , skill ) ;
78628: LD_INT 0
78630: PPUSH
78631: LD_VAR 0 8
78635: PPUSH
78636: LD_VAR 0 4
78640: PPUSH
78641: CALL_OW 380
// un := CreateHuman ;
78645: LD_ADDR_VAR 0 14
78649: PUSH
78650: CALL_OW 44
78654: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
78655: LD_ADDR_VAR 0 7
78659: PUSH
78660: LD_VAR 0 7
78664: PPUSH
78665: LD_INT 1
78667: PPUSH
78668: LD_VAR 0 14
78672: PPUSH
78673: CALL_OW 2
78677: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
78678: LD_VAR 0 14
78682: PPUSH
78683: LD_VAR 0 12
78687: PUSH
78688: LD_INT 1
78690: ARRAY
78691: PPUSH
78692: CALL_OW 52
// end ;
78696: GO 78335
78698: POP
78699: POP
// end ;
78700: GO 77637
78702: POP
78703: POP
// result := result ^ buildings ;
78704: LD_ADDR_VAR 0 7
78708: PUSH
78709: LD_VAR 0 7
78713: PUSH
78714: LD_VAR 0 18
78718: ADD
78719: ST_TO_ADDR
// end else
78720: GO 78863
// begin for i = 1 to personel do
78722: LD_ADDR_VAR 0 8
78726: PUSH
78727: DOUBLE
78728: LD_INT 1
78730: DEC
78731: ST_TO_ADDR
78732: LD_VAR 0 6
78736: PUSH
78737: FOR_TO
78738: IFFALSE 78861
// begin if i > 4 then
78740: LD_VAR 0 8
78744: PUSH
78745: LD_INT 4
78747: GREATER
78748: IFFALSE 78752
// break ;
78750: GO 78861
// x := personel [ i ] ;
78752: LD_ADDR_VAR 0 13
78756: PUSH
78757: LD_VAR 0 6
78761: PUSH
78762: LD_VAR 0 8
78766: ARRAY
78767: ST_TO_ADDR
// if x = - 1 then
78768: LD_VAR 0 13
78772: PUSH
78773: LD_INT 1
78775: NEG
78776: EQUAL
78777: IFFALSE 78781
// continue ;
78779: GO 78737
// PrepareHuman ( false , i , skill ) ;
78781: LD_INT 0
78783: PPUSH
78784: LD_VAR 0 8
78788: PPUSH
78789: LD_VAR 0 4
78793: PPUSH
78794: CALL_OW 380
// un := CreateHuman ;
78798: LD_ADDR_VAR 0 14
78802: PUSH
78803: CALL_OW 44
78807: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
78808: LD_VAR 0 14
78812: PPUSH
78813: LD_VAR 0 1
78817: PPUSH
78818: CALL_OW 250
78822: PPUSH
78823: LD_VAR 0 1
78827: PPUSH
78828: CALL_OW 251
78832: PPUSH
78833: LD_INT 10
78835: PPUSH
78836: LD_INT 0
78838: PPUSH
78839: CALL_OW 50
// result := result ^ un ;
78843: LD_ADDR_VAR 0 7
78847: PUSH
78848: LD_VAR 0 7
78852: PUSH
78853: LD_VAR 0 14
78857: ADD
78858: ST_TO_ADDR
// end ;
78859: GO 78737
78861: POP
78862: POP
// end ; end ;
78863: LD_VAR 0 7
78867: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
78868: LD_INT 0
78870: PPUSH
78871: PPUSH
78872: PPUSH
78873: PPUSH
78874: PPUSH
78875: PPUSH
78876: PPUSH
78877: PPUSH
78878: PPUSH
78879: PPUSH
78880: PPUSH
78881: PPUSH
78882: PPUSH
78883: PPUSH
78884: PPUSH
78885: PPUSH
// result := false ;
78886: LD_ADDR_VAR 0 3
78890: PUSH
78891: LD_INT 0
78893: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
78894: LD_VAR 0 1
78898: NOT
78899: PUSH
78900: LD_VAR 0 1
78904: PPUSH
78905: CALL_OW 266
78909: PUSH
78910: LD_INT 32
78912: PUSH
78913: LD_INT 33
78915: PUSH
78916: EMPTY
78917: LIST
78918: LIST
78919: IN
78920: NOT
78921: OR
78922: IFFALSE 78926
// exit ;
78924: GO 80035
// nat := GetNation ( tower ) ;
78926: LD_ADDR_VAR 0 12
78930: PUSH
78931: LD_VAR 0 1
78935: PPUSH
78936: CALL_OW 248
78940: ST_TO_ADDR
// side := GetSide ( tower ) ;
78941: LD_ADDR_VAR 0 16
78945: PUSH
78946: LD_VAR 0 1
78950: PPUSH
78951: CALL_OW 255
78955: ST_TO_ADDR
// x := GetX ( tower ) ;
78956: LD_ADDR_VAR 0 10
78960: PUSH
78961: LD_VAR 0 1
78965: PPUSH
78966: CALL_OW 250
78970: ST_TO_ADDR
// y := GetY ( tower ) ;
78971: LD_ADDR_VAR 0 11
78975: PUSH
78976: LD_VAR 0 1
78980: PPUSH
78981: CALL_OW 251
78985: ST_TO_ADDR
// if not x or not y then
78986: LD_VAR 0 10
78990: NOT
78991: PUSH
78992: LD_VAR 0 11
78996: NOT
78997: OR
78998: IFFALSE 79002
// exit ;
79000: GO 80035
// weapon := 0 ;
79002: LD_ADDR_VAR 0 18
79006: PUSH
79007: LD_INT 0
79009: ST_TO_ADDR
// fac_list := [ ] ;
79010: LD_ADDR_VAR 0 17
79014: PUSH
79015: EMPTY
79016: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
79017: LD_ADDR_VAR 0 6
79021: PUSH
79022: LD_VAR 0 1
79026: PPUSH
79027: CALL_OW 274
79031: PPUSH
79032: LD_VAR 0 2
79036: PPUSH
79037: LD_INT 0
79039: PPUSH
79040: CALL 76606 0 3
79044: PPUSH
79045: LD_INT 30
79047: PUSH
79048: LD_INT 3
79050: PUSH
79051: EMPTY
79052: LIST
79053: LIST
79054: PPUSH
79055: CALL_OW 72
79059: ST_TO_ADDR
// if not factories then
79060: LD_VAR 0 6
79064: NOT
79065: IFFALSE 79069
// exit ;
79067: GO 80035
// for i in factories do
79069: LD_ADDR_VAR 0 8
79073: PUSH
79074: LD_VAR 0 6
79078: PUSH
79079: FOR_IN
79080: IFFALSE 79105
// fac_list := fac_list union AvailableWeaponList ( i ) ;
79082: LD_ADDR_VAR 0 17
79086: PUSH
79087: LD_VAR 0 17
79091: PUSH
79092: LD_VAR 0 8
79096: PPUSH
79097: CALL_OW 478
79101: UNION
79102: ST_TO_ADDR
79103: GO 79079
79105: POP
79106: POP
// if not fac_list then
79107: LD_VAR 0 17
79111: NOT
79112: IFFALSE 79116
// exit ;
79114: GO 80035
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
79116: LD_ADDR_VAR 0 5
79120: PUSH
79121: LD_INT 4
79123: PUSH
79124: LD_INT 5
79126: PUSH
79127: LD_INT 9
79129: PUSH
79130: LD_INT 10
79132: PUSH
79133: LD_INT 6
79135: PUSH
79136: LD_INT 7
79138: PUSH
79139: LD_INT 11
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: LIST
79146: LIST
79147: LIST
79148: LIST
79149: LIST
79150: PUSH
79151: LD_INT 27
79153: PUSH
79154: LD_INT 28
79156: PUSH
79157: LD_INT 26
79159: PUSH
79160: LD_INT 30
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: LIST
79167: LIST
79168: PUSH
79169: LD_INT 43
79171: PUSH
79172: LD_INT 44
79174: PUSH
79175: LD_INT 46
79177: PUSH
79178: LD_INT 45
79180: PUSH
79181: LD_INT 47
79183: PUSH
79184: LD_INT 49
79186: PUSH
79187: EMPTY
79188: LIST
79189: LIST
79190: LIST
79191: LIST
79192: LIST
79193: LIST
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: LIST
79199: PUSH
79200: LD_VAR 0 12
79204: ARRAY
79205: ST_TO_ADDR
// list := list isect fac_list ;
79206: LD_ADDR_VAR 0 5
79210: PUSH
79211: LD_VAR 0 5
79215: PUSH
79216: LD_VAR 0 17
79220: ISECT
79221: ST_TO_ADDR
// if not list then
79222: LD_VAR 0 5
79226: NOT
79227: IFFALSE 79231
// exit ;
79229: GO 80035
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
79231: LD_VAR 0 12
79235: PUSH
79236: LD_INT 3
79238: EQUAL
79239: PUSH
79240: LD_INT 49
79242: PUSH
79243: LD_VAR 0 5
79247: IN
79248: AND
79249: PUSH
79250: LD_INT 31
79252: PPUSH
79253: LD_VAR 0 16
79257: PPUSH
79258: CALL_OW 321
79262: PUSH
79263: LD_INT 2
79265: EQUAL
79266: AND
79267: IFFALSE 79327
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
79269: LD_INT 22
79271: PUSH
79272: LD_VAR 0 16
79276: PUSH
79277: EMPTY
79278: LIST
79279: LIST
79280: PUSH
79281: LD_INT 35
79283: PUSH
79284: LD_INT 49
79286: PUSH
79287: EMPTY
79288: LIST
79289: LIST
79290: PUSH
79291: LD_INT 91
79293: PUSH
79294: LD_VAR 0 1
79298: PUSH
79299: LD_INT 10
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: LIST
79306: PUSH
79307: EMPTY
79308: LIST
79309: LIST
79310: LIST
79311: PPUSH
79312: CALL_OW 69
79316: NOT
79317: IFFALSE 79327
// weapon := ru_time_lapser ;
79319: LD_ADDR_VAR 0 18
79323: PUSH
79324: LD_INT 49
79326: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
79327: LD_VAR 0 12
79331: PUSH
79332: LD_INT 1
79334: PUSH
79335: LD_INT 2
79337: PUSH
79338: EMPTY
79339: LIST
79340: LIST
79341: IN
79342: PUSH
79343: LD_INT 11
79345: PUSH
79346: LD_VAR 0 5
79350: IN
79351: PUSH
79352: LD_INT 30
79354: PUSH
79355: LD_VAR 0 5
79359: IN
79360: OR
79361: AND
79362: PUSH
79363: LD_INT 6
79365: PPUSH
79366: LD_VAR 0 16
79370: PPUSH
79371: CALL_OW 321
79375: PUSH
79376: LD_INT 2
79378: EQUAL
79379: AND
79380: IFFALSE 79545
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
79382: LD_INT 22
79384: PUSH
79385: LD_VAR 0 16
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PUSH
79394: LD_INT 2
79396: PUSH
79397: LD_INT 35
79399: PUSH
79400: LD_INT 11
79402: PUSH
79403: EMPTY
79404: LIST
79405: LIST
79406: PUSH
79407: LD_INT 35
79409: PUSH
79410: LD_INT 30
79412: PUSH
79413: EMPTY
79414: LIST
79415: LIST
79416: PUSH
79417: EMPTY
79418: LIST
79419: LIST
79420: LIST
79421: PUSH
79422: LD_INT 91
79424: PUSH
79425: LD_VAR 0 1
79429: PUSH
79430: LD_INT 18
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: LIST
79437: PUSH
79438: EMPTY
79439: LIST
79440: LIST
79441: LIST
79442: PPUSH
79443: CALL_OW 69
79447: NOT
79448: PUSH
79449: LD_INT 22
79451: PUSH
79452: LD_VAR 0 16
79456: PUSH
79457: EMPTY
79458: LIST
79459: LIST
79460: PUSH
79461: LD_INT 2
79463: PUSH
79464: LD_INT 30
79466: PUSH
79467: LD_INT 32
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: PUSH
79474: LD_INT 30
79476: PUSH
79477: LD_INT 33
79479: PUSH
79480: EMPTY
79481: LIST
79482: LIST
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: LIST
79488: PUSH
79489: LD_INT 91
79491: PUSH
79492: LD_VAR 0 1
79496: PUSH
79497: LD_INT 12
79499: PUSH
79500: EMPTY
79501: LIST
79502: LIST
79503: LIST
79504: PUSH
79505: EMPTY
79506: LIST
79507: LIST
79508: LIST
79509: PUSH
79510: EMPTY
79511: LIST
79512: PPUSH
79513: CALL_OW 69
79517: PUSH
79518: LD_INT 2
79520: GREATER
79521: AND
79522: IFFALSE 79545
// weapon := [ us_radar , ar_radar ] [ nat ] ;
79524: LD_ADDR_VAR 0 18
79528: PUSH
79529: LD_INT 11
79531: PUSH
79532: LD_INT 30
79534: PUSH
79535: EMPTY
79536: LIST
79537: LIST
79538: PUSH
79539: LD_VAR 0 12
79543: ARRAY
79544: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
79545: LD_VAR 0 18
79549: NOT
79550: PUSH
79551: LD_INT 40
79553: PPUSH
79554: LD_VAR 0 16
79558: PPUSH
79559: CALL_OW 321
79563: PUSH
79564: LD_INT 2
79566: EQUAL
79567: AND
79568: PUSH
79569: LD_INT 7
79571: PUSH
79572: LD_VAR 0 5
79576: IN
79577: PUSH
79578: LD_INT 28
79580: PUSH
79581: LD_VAR 0 5
79585: IN
79586: OR
79587: PUSH
79588: LD_INT 45
79590: PUSH
79591: LD_VAR 0 5
79595: IN
79596: OR
79597: AND
79598: IFFALSE 79852
// begin hex := GetHexInfo ( x , y ) ;
79600: LD_ADDR_VAR 0 4
79604: PUSH
79605: LD_VAR 0 10
79609: PPUSH
79610: LD_VAR 0 11
79614: PPUSH
79615: CALL_OW 546
79619: ST_TO_ADDR
// if hex [ 1 ] then
79620: LD_VAR 0 4
79624: PUSH
79625: LD_INT 1
79627: ARRAY
79628: IFFALSE 79632
// exit ;
79630: GO 80035
// height := hex [ 2 ] ;
79632: LD_ADDR_VAR 0 15
79636: PUSH
79637: LD_VAR 0 4
79641: PUSH
79642: LD_INT 2
79644: ARRAY
79645: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
79646: LD_ADDR_VAR 0 14
79650: PUSH
79651: LD_INT 0
79653: PUSH
79654: LD_INT 2
79656: PUSH
79657: LD_INT 3
79659: PUSH
79660: LD_INT 5
79662: PUSH
79663: EMPTY
79664: LIST
79665: LIST
79666: LIST
79667: LIST
79668: ST_TO_ADDR
// for i in tmp do
79669: LD_ADDR_VAR 0 8
79673: PUSH
79674: LD_VAR 0 14
79678: PUSH
79679: FOR_IN
79680: IFFALSE 79850
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
79682: LD_ADDR_VAR 0 9
79686: PUSH
79687: LD_VAR 0 10
79691: PPUSH
79692: LD_VAR 0 8
79696: PPUSH
79697: LD_INT 5
79699: PPUSH
79700: CALL_OW 272
79704: PUSH
79705: LD_VAR 0 11
79709: PPUSH
79710: LD_VAR 0 8
79714: PPUSH
79715: LD_INT 5
79717: PPUSH
79718: CALL_OW 273
79722: PUSH
79723: EMPTY
79724: LIST
79725: LIST
79726: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
79727: LD_VAR 0 9
79731: PUSH
79732: LD_INT 1
79734: ARRAY
79735: PPUSH
79736: LD_VAR 0 9
79740: PUSH
79741: LD_INT 2
79743: ARRAY
79744: PPUSH
79745: CALL_OW 488
79749: IFFALSE 79848
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
79751: LD_ADDR_VAR 0 4
79755: PUSH
79756: LD_VAR 0 9
79760: PUSH
79761: LD_INT 1
79763: ARRAY
79764: PPUSH
79765: LD_VAR 0 9
79769: PUSH
79770: LD_INT 2
79772: ARRAY
79773: PPUSH
79774: CALL_OW 546
79778: ST_TO_ADDR
// if hex [ 1 ] then
79779: LD_VAR 0 4
79783: PUSH
79784: LD_INT 1
79786: ARRAY
79787: IFFALSE 79791
// continue ;
79789: GO 79679
// h := hex [ 2 ] ;
79791: LD_ADDR_VAR 0 13
79795: PUSH
79796: LD_VAR 0 4
79800: PUSH
79801: LD_INT 2
79803: ARRAY
79804: ST_TO_ADDR
// if h + 7 < height then
79805: LD_VAR 0 13
79809: PUSH
79810: LD_INT 7
79812: PLUS
79813: PUSH
79814: LD_VAR 0 15
79818: LESS
79819: IFFALSE 79848
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
79821: LD_ADDR_VAR 0 18
79825: PUSH
79826: LD_INT 7
79828: PUSH
79829: LD_INT 28
79831: PUSH
79832: LD_INT 45
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: LIST
79839: PUSH
79840: LD_VAR 0 12
79844: ARRAY
79845: ST_TO_ADDR
// break ;
79846: GO 79850
// end ; end ; end ;
79848: GO 79679
79850: POP
79851: POP
// end ; if not weapon then
79852: LD_VAR 0 18
79856: NOT
79857: IFFALSE 79917
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
79859: LD_ADDR_VAR 0 5
79863: PUSH
79864: LD_VAR 0 5
79868: PUSH
79869: LD_INT 11
79871: PUSH
79872: LD_INT 30
79874: PUSH
79875: LD_INT 49
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: LIST
79882: DIFF
79883: ST_TO_ADDR
// if not list then
79884: LD_VAR 0 5
79888: NOT
79889: IFFALSE 79893
// exit ;
79891: GO 80035
// weapon := list [ rand ( 1 , list ) ] ;
79893: LD_ADDR_VAR 0 18
79897: PUSH
79898: LD_VAR 0 5
79902: PUSH
79903: LD_INT 1
79905: PPUSH
79906: LD_VAR 0 5
79910: PPUSH
79911: CALL_OW 12
79915: ARRAY
79916: ST_TO_ADDR
// end ; if weapon then
79917: LD_VAR 0 18
79921: IFFALSE 80035
// begin tmp := CostOfWeapon ( weapon ) ;
79923: LD_ADDR_VAR 0 14
79927: PUSH
79928: LD_VAR 0 18
79932: PPUSH
79933: CALL_OW 451
79937: ST_TO_ADDR
// j := GetBase ( tower ) ;
79938: LD_ADDR_VAR 0 9
79942: PUSH
79943: LD_VAR 0 1
79947: PPUSH
79948: CALL_OW 274
79952: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
79953: LD_VAR 0 9
79957: PPUSH
79958: LD_INT 1
79960: PPUSH
79961: CALL_OW 275
79965: PUSH
79966: LD_VAR 0 14
79970: PUSH
79971: LD_INT 1
79973: ARRAY
79974: GREATEREQUAL
79975: PUSH
79976: LD_VAR 0 9
79980: PPUSH
79981: LD_INT 2
79983: PPUSH
79984: CALL_OW 275
79988: PUSH
79989: LD_VAR 0 14
79993: PUSH
79994: LD_INT 2
79996: ARRAY
79997: GREATEREQUAL
79998: AND
79999: PUSH
80000: LD_VAR 0 9
80004: PPUSH
80005: LD_INT 3
80007: PPUSH
80008: CALL_OW 275
80012: PUSH
80013: LD_VAR 0 14
80017: PUSH
80018: LD_INT 3
80020: ARRAY
80021: GREATEREQUAL
80022: AND
80023: IFFALSE 80035
// result := weapon ;
80025: LD_ADDR_VAR 0 3
80029: PUSH
80030: LD_VAR 0 18
80034: ST_TO_ADDR
// end ; end ;
80035: LD_VAR 0 3
80039: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
80040: LD_INT 0
80042: PPUSH
80043: PPUSH
// result := true ;
80044: LD_ADDR_VAR 0 3
80048: PUSH
80049: LD_INT 1
80051: ST_TO_ADDR
// if array1 = array2 then
80052: LD_VAR 0 1
80056: PUSH
80057: LD_VAR 0 2
80061: EQUAL
80062: IFFALSE 80122
// begin for i = 1 to array1 do
80064: LD_ADDR_VAR 0 4
80068: PUSH
80069: DOUBLE
80070: LD_INT 1
80072: DEC
80073: ST_TO_ADDR
80074: LD_VAR 0 1
80078: PUSH
80079: FOR_TO
80080: IFFALSE 80118
// if array1 [ i ] <> array2 [ i ] then
80082: LD_VAR 0 1
80086: PUSH
80087: LD_VAR 0 4
80091: ARRAY
80092: PUSH
80093: LD_VAR 0 2
80097: PUSH
80098: LD_VAR 0 4
80102: ARRAY
80103: NONEQUAL
80104: IFFALSE 80116
// begin result := false ;
80106: LD_ADDR_VAR 0 3
80110: PUSH
80111: LD_INT 0
80113: ST_TO_ADDR
// break ;
80114: GO 80118
// end ;
80116: GO 80079
80118: POP
80119: POP
// end else
80120: GO 80130
// result := false ;
80122: LD_ADDR_VAR 0 3
80126: PUSH
80127: LD_INT 0
80129: ST_TO_ADDR
// end ;
80130: LD_VAR 0 3
80134: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
80135: LD_INT 0
80137: PPUSH
80138: PPUSH
// if not array1 or not array2 then
80139: LD_VAR 0 1
80143: NOT
80144: PUSH
80145: LD_VAR 0 2
80149: NOT
80150: OR
80151: IFFALSE 80155
// exit ;
80153: GO 80219
// result := true ;
80155: LD_ADDR_VAR 0 3
80159: PUSH
80160: LD_INT 1
80162: ST_TO_ADDR
// for i = 1 to array1 do
80163: LD_ADDR_VAR 0 4
80167: PUSH
80168: DOUBLE
80169: LD_INT 1
80171: DEC
80172: ST_TO_ADDR
80173: LD_VAR 0 1
80177: PUSH
80178: FOR_TO
80179: IFFALSE 80217
// if array1 [ i ] <> array2 [ i ] then
80181: LD_VAR 0 1
80185: PUSH
80186: LD_VAR 0 4
80190: ARRAY
80191: PUSH
80192: LD_VAR 0 2
80196: PUSH
80197: LD_VAR 0 4
80201: ARRAY
80202: NONEQUAL
80203: IFFALSE 80215
// begin result := false ;
80205: LD_ADDR_VAR 0 3
80209: PUSH
80210: LD_INT 0
80212: ST_TO_ADDR
// break ;
80213: GO 80217
// end ;
80215: GO 80178
80217: POP
80218: POP
// end ;
80219: LD_VAR 0 3
80223: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
80224: LD_INT 0
80226: PPUSH
80227: PPUSH
80228: PPUSH
// pom := GetBase ( fac ) ;
80229: LD_ADDR_VAR 0 5
80233: PUSH
80234: LD_VAR 0 1
80238: PPUSH
80239: CALL_OW 274
80243: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
80244: LD_ADDR_VAR 0 4
80248: PUSH
80249: LD_VAR 0 2
80253: PUSH
80254: LD_INT 1
80256: ARRAY
80257: PPUSH
80258: LD_VAR 0 2
80262: PUSH
80263: LD_INT 2
80265: ARRAY
80266: PPUSH
80267: LD_VAR 0 2
80271: PUSH
80272: LD_INT 3
80274: ARRAY
80275: PPUSH
80276: LD_VAR 0 2
80280: PUSH
80281: LD_INT 4
80283: ARRAY
80284: PPUSH
80285: CALL_OW 449
80289: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
80290: LD_ADDR_VAR 0 3
80294: PUSH
80295: LD_VAR 0 5
80299: PPUSH
80300: LD_INT 1
80302: PPUSH
80303: CALL_OW 275
80307: PUSH
80308: LD_VAR 0 4
80312: PUSH
80313: LD_INT 1
80315: ARRAY
80316: GREATEREQUAL
80317: PUSH
80318: LD_VAR 0 5
80322: PPUSH
80323: LD_INT 2
80325: PPUSH
80326: CALL_OW 275
80330: PUSH
80331: LD_VAR 0 4
80335: PUSH
80336: LD_INT 2
80338: ARRAY
80339: GREATEREQUAL
80340: AND
80341: PUSH
80342: LD_VAR 0 5
80346: PPUSH
80347: LD_INT 3
80349: PPUSH
80350: CALL_OW 275
80354: PUSH
80355: LD_VAR 0 4
80359: PUSH
80360: LD_INT 3
80362: ARRAY
80363: GREATEREQUAL
80364: AND
80365: ST_TO_ADDR
// end ;
80366: LD_VAR 0 3
80370: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
80371: LD_INT 0
80373: PPUSH
80374: PPUSH
80375: PPUSH
80376: PPUSH
// pom := GetBase ( building ) ;
80377: LD_ADDR_VAR 0 3
80381: PUSH
80382: LD_VAR 0 1
80386: PPUSH
80387: CALL_OW 274
80391: ST_TO_ADDR
// if not pom then
80392: LD_VAR 0 3
80396: NOT
80397: IFFALSE 80401
// exit ;
80399: GO 80571
// btype := GetBType ( building ) ;
80401: LD_ADDR_VAR 0 5
80405: PUSH
80406: LD_VAR 0 1
80410: PPUSH
80411: CALL_OW 266
80415: ST_TO_ADDR
// if btype = b_armoury then
80416: LD_VAR 0 5
80420: PUSH
80421: LD_INT 4
80423: EQUAL
80424: IFFALSE 80434
// btype := b_barracks ;
80426: LD_ADDR_VAR 0 5
80430: PUSH
80431: LD_INT 5
80433: ST_TO_ADDR
// if btype = b_depot then
80434: LD_VAR 0 5
80438: PUSH
80439: LD_INT 0
80441: EQUAL
80442: IFFALSE 80452
// btype := b_warehouse ;
80444: LD_ADDR_VAR 0 5
80448: PUSH
80449: LD_INT 1
80451: ST_TO_ADDR
// if btype = b_workshop then
80452: LD_VAR 0 5
80456: PUSH
80457: LD_INT 2
80459: EQUAL
80460: IFFALSE 80470
// btype := b_factory ;
80462: LD_ADDR_VAR 0 5
80466: PUSH
80467: LD_INT 3
80469: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
80470: LD_ADDR_VAR 0 4
80474: PUSH
80475: LD_VAR 0 5
80479: PPUSH
80480: LD_VAR 0 1
80484: PPUSH
80485: CALL_OW 248
80489: PPUSH
80490: CALL_OW 450
80494: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
80495: LD_ADDR_VAR 0 2
80499: PUSH
80500: LD_VAR 0 3
80504: PPUSH
80505: LD_INT 1
80507: PPUSH
80508: CALL_OW 275
80512: PUSH
80513: LD_VAR 0 4
80517: PUSH
80518: LD_INT 1
80520: ARRAY
80521: GREATEREQUAL
80522: PUSH
80523: LD_VAR 0 3
80527: PPUSH
80528: LD_INT 2
80530: PPUSH
80531: CALL_OW 275
80535: PUSH
80536: LD_VAR 0 4
80540: PUSH
80541: LD_INT 2
80543: ARRAY
80544: GREATEREQUAL
80545: AND
80546: PUSH
80547: LD_VAR 0 3
80551: PPUSH
80552: LD_INT 3
80554: PPUSH
80555: CALL_OW 275
80559: PUSH
80560: LD_VAR 0 4
80564: PUSH
80565: LD_INT 3
80567: ARRAY
80568: GREATEREQUAL
80569: AND
80570: ST_TO_ADDR
// end ;
80571: LD_VAR 0 2
80575: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
80576: LD_INT 0
80578: PPUSH
80579: PPUSH
80580: PPUSH
// pom := GetBase ( building ) ;
80581: LD_ADDR_VAR 0 4
80585: PUSH
80586: LD_VAR 0 1
80590: PPUSH
80591: CALL_OW 274
80595: ST_TO_ADDR
// if not pom then
80596: LD_VAR 0 4
80600: NOT
80601: IFFALSE 80605
// exit ;
80603: GO 80706
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
80605: LD_ADDR_VAR 0 5
80609: PUSH
80610: LD_VAR 0 2
80614: PPUSH
80615: LD_VAR 0 1
80619: PPUSH
80620: CALL_OW 248
80624: PPUSH
80625: CALL_OW 450
80629: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
80630: LD_ADDR_VAR 0 3
80634: PUSH
80635: LD_VAR 0 4
80639: PPUSH
80640: LD_INT 1
80642: PPUSH
80643: CALL_OW 275
80647: PUSH
80648: LD_VAR 0 5
80652: PUSH
80653: LD_INT 1
80655: ARRAY
80656: GREATEREQUAL
80657: PUSH
80658: LD_VAR 0 4
80662: PPUSH
80663: LD_INT 2
80665: PPUSH
80666: CALL_OW 275
80670: PUSH
80671: LD_VAR 0 5
80675: PUSH
80676: LD_INT 2
80678: ARRAY
80679: GREATEREQUAL
80680: AND
80681: PUSH
80682: LD_VAR 0 4
80686: PPUSH
80687: LD_INT 3
80689: PPUSH
80690: CALL_OW 275
80694: PUSH
80695: LD_VAR 0 5
80699: PUSH
80700: LD_INT 3
80702: ARRAY
80703: GREATEREQUAL
80704: AND
80705: ST_TO_ADDR
// end ;
80706: LD_VAR 0 3
80710: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
80711: LD_INT 0
80713: PPUSH
80714: PPUSH
80715: PPUSH
80716: PPUSH
80717: PPUSH
80718: PPUSH
80719: PPUSH
80720: PPUSH
80721: PPUSH
80722: PPUSH
80723: PPUSH
// result := false ;
80724: LD_ADDR_VAR 0 8
80728: PUSH
80729: LD_INT 0
80731: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
80732: LD_VAR 0 5
80736: NOT
80737: PUSH
80738: LD_VAR 0 1
80742: NOT
80743: OR
80744: PUSH
80745: LD_VAR 0 2
80749: NOT
80750: OR
80751: PUSH
80752: LD_VAR 0 3
80756: NOT
80757: OR
80758: IFFALSE 80762
// exit ;
80760: GO 81576
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
80762: LD_ADDR_VAR 0 14
80766: PUSH
80767: LD_VAR 0 1
80771: PPUSH
80772: LD_VAR 0 2
80776: PPUSH
80777: LD_VAR 0 3
80781: PPUSH
80782: LD_VAR 0 4
80786: PPUSH
80787: LD_VAR 0 5
80791: PUSH
80792: LD_INT 1
80794: ARRAY
80795: PPUSH
80796: CALL_OW 248
80800: PPUSH
80801: LD_INT 0
80803: PPUSH
80804: CALL 82809 0 6
80808: ST_TO_ADDR
// if not hexes then
80809: LD_VAR 0 14
80813: NOT
80814: IFFALSE 80818
// exit ;
80816: GO 81576
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
80818: LD_ADDR_VAR 0 17
80822: PUSH
80823: LD_VAR 0 5
80827: PPUSH
80828: LD_INT 22
80830: PUSH
80831: LD_VAR 0 13
80835: PPUSH
80836: CALL_OW 255
80840: PUSH
80841: EMPTY
80842: LIST
80843: LIST
80844: PUSH
80845: LD_INT 2
80847: PUSH
80848: LD_INT 30
80850: PUSH
80851: LD_INT 0
80853: PUSH
80854: EMPTY
80855: LIST
80856: LIST
80857: PUSH
80858: LD_INT 30
80860: PUSH
80861: LD_INT 1
80863: PUSH
80864: EMPTY
80865: LIST
80866: LIST
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: LIST
80872: PUSH
80873: EMPTY
80874: LIST
80875: LIST
80876: PPUSH
80877: CALL_OW 72
80881: ST_TO_ADDR
// for i = 1 to hexes do
80882: LD_ADDR_VAR 0 9
80886: PUSH
80887: DOUBLE
80888: LD_INT 1
80890: DEC
80891: ST_TO_ADDR
80892: LD_VAR 0 14
80896: PUSH
80897: FOR_TO
80898: IFFALSE 81574
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80900: LD_ADDR_VAR 0 13
80904: PUSH
80905: LD_VAR 0 14
80909: PUSH
80910: LD_VAR 0 9
80914: ARRAY
80915: PUSH
80916: LD_INT 1
80918: ARRAY
80919: PPUSH
80920: LD_VAR 0 14
80924: PUSH
80925: LD_VAR 0 9
80929: ARRAY
80930: PUSH
80931: LD_INT 2
80933: ARRAY
80934: PPUSH
80935: CALL_OW 428
80939: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
80940: LD_VAR 0 14
80944: PUSH
80945: LD_VAR 0 9
80949: ARRAY
80950: PUSH
80951: LD_INT 1
80953: ARRAY
80954: PPUSH
80955: LD_VAR 0 14
80959: PUSH
80960: LD_VAR 0 9
80964: ARRAY
80965: PUSH
80966: LD_INT 2
80968: ARRAY
80969: PPUSH
80970: CALL_OW 351
80974: PUSH
80975: LD_VAR 0 14
80979: PUSH
80980: LD_VAR 0 9
80984: ARRAY
80985: PUSH
80986: LD_INT 1
80988: ARRAY
80989: PPUSH
80990: LD_VAR 0 14
80994: PUSH
80995: LD_VAR 0 9
80999: ARRAY
81000: PUSH
81001: LD_INT 2
81003: ARRAY
81004: PPUSH
81005: CALL_OW 488
81009: NOT
81010: OR
81011: PUSH
81012: LD_VAR 0 13
81016: PPUSH
81017: CALL_OW 247
81021: PUSH
81022: LD_INT 3
81024: EQUAL
81025: OR
81026: IFFALSE 81032
// exit ;
81028: POP
81029: POP
81030: GO 81576
// if not tmp then
81032: LD_VAR 0 13
81036: NOT
81037: IFFALSE 81041
// continue ;
81039: GO 80897
// result := true ;
81041: LD_ADDR_VAR 0 8
81045: PUSH
81046: LD_INT 1
81048: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
81049: LD_VAR 0 6
81053: PUSH
81054: LD_VAR 0 13
81058: PPUSH
81059: CALL_OW 247
81063: PUSH
81064: LD_INT 2
81066: EQUAL
81067: AND
81068: PUSH
81069: LD_VAR 0 13
81073: PPUSH
81074: CALL_OW 263
81078: PUSH
81079: LD_INT 1
81081: EQUAL
81082: AND
81083: IFFALSE 81247
// begin if IsDrivenBy ( tmp ) then
81085: LD_VAR 0 13
81089: PPUSH
81090: CALL_OW 311
81094: IFFALSE 81098
// continue ;
81096: GO 80897
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
81098: LD_VAR 0 6
81102: PPUSH
81103: LD_INT 3
81105: PUSH
81106: LD_INT 60
81108: PUSH
81109: EMPTY
81110: LIST
81111: PUSH
81112: EMPTY
81113: LIST
81114: LIST
81115: PUSH
81116: LD_INT 3
81118: PUSH
81119: LD_INT 55
81121: PUSH
81122: EMPTY
81123: LIST
81124: PUSH
81125: EMPTY
81126: LIST
81127: LIST
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PPUSH
81133: CALL_OW 72
81137: IFFALSE 81245
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
81139: LD_ADDR_VAR 0 18
81143: PUSH
81144: LD_VAR 0 6
81148: PPUSH
81149: LD_INT 3
81151: PUSH
81152: LD_INT 60
81154: PUSH
81155: EMPTY
81156: LIST
81157: PUSH
81158: EMPTY
81159: LIST
81160: LIST
81161: PUSH
81162: LD_INT 3
81164: PUSH
81165: LD_INT 55
81167: PUSH
81168: EMPTY
81169: LIST
81170: PUSH
81171: EMPTY
81172: LIST
81173: LIST
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: PPUSH
81179: CALL_OW 72
81183: PUSH
81184: LD_INT 1
81186: ARRAY
81187: ST_TO_ADDR
// if IsInUnit ( driver ) then
81188: LD_VAR 0 18
81192: PPUSH
81193: CALL_OW 310
81197: IFFALSE 81208
// ComExit ( driver ) ;
81199: LD_VAR 0 18
81203: PPUSH
81204: CALL 106588 0 1
// AddComEnterUnit ( driver , tmp ) ;
81208: LD_VAR 0 18
81212: PPUSH
81213: LD_VAR 0 13
81217: PPUSH
81218: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
81222: LD_VAR 0 18
81226: PPUSH
81227: LD_VAR 0 7
81231: PPUSH
81232: CALL_OW 173
// AddComExitVehicle ( driver ) ;
81236: LD_VAR 0 18
81240: PPUSH
81241: CALL_OW 181
// end ; continue ;
81245: GO 80897
// end ; if not cleaners or not tmp in cleaners then
81247: LD_VAR 0 6
81251: NOT
81252: PUSH
81253: LD_VAR 0 13
81257: PUSH
81258: LD_VAR 0 6
81262: IN
81263: NOT
81264: OR
81265: IFFALSE 81572
// begin if dep then
81267: LD_VAR 0 17
81271: IFFALSE 81407
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
81273: LD_ADDR_VAR 0 16
81277: PUSH
81278: LD_VAR 0 17
81282: PUSH
81283: LD_INT 1
81285: ARRAY
81286: PPUSH
81287: CALL_OW 250
81291: PPUSH
81292: LD_VAR 0 17
81296: PUSH
81297: LD_INT 1
81299: ARRAY
81300: PPUSH
81301: CALL_OW 254
81305: PPUSH
81306: LD_INT 5
81308: PPUSH
81309: CALL_OW 272
81313: PUSH
81314: LD_VAR 0 17
81318: PUSH
81319: LD_INT 1
81321: ARRAY
81322: PPUSH
81323: CALL_OW 251
81327: PPUSH
81328: LD_VAR 0 17
81332: PUSH
81333: LD_INT 1
81335: ARRAY
81336: PPUSH
81337: CALL_OW 254
81341: PPUSH
81342: LD_INT 5
81344: PPUSH
81345: CALL_OW 273
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
81354: LD_VAR 0 16
81358: PUSH
81359: LD_INT 1
81361: ARRAY
81362: PPUSH
81363: LD_VAR 0 16
81367: PUSH
81368: LD_INT 2
81370: ARRAY
81371: PPUSH
81372: CALL_OW 488
81376: IFFALSE 81407
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
81378: LD_VAR 0 13
81382: PPUSH
81383: LD_VAR 0 16
81387: PUSH
81388: LD_INT 1
81390: ARRAY
81391: PPUSH
81392: LD_VAR 0 16
81396: PUSH
81397: LD_INT 2
81399: ARRAY
81400: PPUSH
81401: CALL_OW 111
// continue ;
81405: GO 80897
// end ; end ; r := GetDir ( tmp ) ;
81407: LD_ADDR_VAR 0 15
81411: PUSH
81412: LD_VAR 0 13
81416: PPUSH
81417: CALL_OW 254
81421: ST_TO_ADDR
// if r = 5 then
81422: LD_VAR 0 15
81426: PUSH
81427: LD_INT 5
81429: EQUAL
81430: IFFALSE 81440
// r := 0 ;
81432: LD_ADDR_VAR 0 15
81436: PUSH
81437: LD_INT 0
81439: ST_TO_ADDR
// for j = r to 5 do
81440: LD_ADDR_VAR 0 10
81444: PUSH
81445: DOUBLE
81446: LD_VAR 0 15
81450: DEC
81451: ST_TO_ADDR
81452: LD_INT 5
81454: PUSH
81455: FOR_TO
81456: IFFALSE 81570
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
81458: LD_ADDR_VAR 0 11
81462: PUSH
81463: LD_VAR 0 13
81467: PPUSH
81468: CALL_OW 250
81472: PPUSH
81473: LD_VAR 0 10
81477: PPUSH
81478: LD_INT 2
81480: PPUSH
81481: CALL_OW 272
81485: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
81486: LD_ADDR_VAR 0 12
81490: PUSH
81491: LD_VAR 0 13
81495: PPUSH
81496: CALL_OW 251
81500: PPUSH
81501: LD_VAR 0 10
81505: PPUSH
81506: LD_INT 2
81508: PPUSH
81509: CALL_OW 273
81513: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
81514: LD_VAR 0 11
81518: PPUSH
81519: LD_VAR 0 12
81523: PPUSH
81524: CALL_OW 488
81528: PUSH
81529: LD_VAR 0 11
81533: PPUSH
81534: LD_VAR 0 12
81538: PPUSH
81539: CALL_OW 428
81543: NOT
81544: AND
81545: IFFALSE 81568
// begin ComMoveXY ( tmp , _x , _y ) ;
81547: LD_VAR 0 13
81551: PPUSH
81552: LD_VAR 0 11
81556: PPUSH
81557: LD_VAR 0 12
81561: PPUSH
81562: CALL_OW 111
// break ;
81566: GO 81570
// end ; end ;
81568: GO 81455
81570: POP
81571: POP
// end ; end ;
81572: GO 80897
81574: POP
81575: POP
// end ;
81576: LD_VAR 0 8
81580: RET
// export function BuildingTechInvented ( side , btype ) ; begin
81581: LD_INT 0
81583: PPUSH
// result := true ;
81584: LD_ADDR_VAR 0 3
81588: PUSH
81589: LD_INT 1
81591: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
81592: LD_VAR 0 2
81596: PUSH
81597: LD_INT 24
81599: DOUBLE
81600: EQUAL
81601: IFTRUE 81611
81603: LD_INT 33
81605: DOUBLE
81606: EQUAL
81607: IFTRUE 81611
81609: GO 81636
81611: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
81612: LD_ADDR_VAR 0 3
81616: PUSH
81617: LD_INT 32
81619: PPUSH
81620: LD_VAR 0 1
81624: PPUSH
81625: CALL_OW 321
81629: PUSH
81630: LD_INT 2
81632: EQUAL
81633: ST_TO_ADDR
81634: GO 81952
81636: LD_INT 20
81638: DOUBLE
81639: EQUAL
81640: IFTRUE 81644
81642: GO 81669
81644: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
81645: LD_ADDR_VAR 0 3
81649: PUSH
81650: LD_INT 6
81652: PPUSH
81653: LD_VAR 0 1
81657: PPUSH
81658: CALL_OW 321
81662: PUSH
81663: LD_INT 2
81665: EQUAL
81666: ST_TO_ADDR
81667: GO 81952
81669: LD_INT 22
81671: DOUBLE
81672: EQUAL
81673: IFTRUE 81683
81675: LD_INT 36
81677: DOUBLE
81678: EQUAL
81679: IFTRUE 81683
81681: GO 81708
81683: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
81684: LD_ADDR_VAR 0 3
81688: PUSH
81689: LD_INT 15
81691: PPUSH
81692: LD_VAR 0 1
81696: PPUSH
81697: CALL_OW 321
81701: PUSH
81702: LD_INT 2
81704: EQUAL
81705: ST_TO_ADDR
81706: GO 81952
81708: LD_INT 30
81710: DOUBLE
81711: EQUAL
81712: IFTRUE 81716
81714: GO 81741
81716: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
81717: LD_ADDR_VAR 0 3
81721: PUSH
81722: LD_INT 20
81724: PPUSH
81725: LD_VAR 0 1
81729: PPUSH
81730: CALL_OW 321
81734: PUSH
81735: LD_INT 2
81737: EQUAL
81738: ST_TO_ADDR
81739: GO 81952
81741: LD_INT 28
81743: DOUBLE
81744: EQUAL
81745: IFTRUE 81755
81747: LD_INT 21
81749: DOUBLE
81750: EQUAL
81751: IFTRUE 81755
81753: GO 81780
81755: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
81756: LD_ADDR_VAR 0 3
81760: PUSH
81761: LD_INT 21
81763: PPUSH
81764: LD_VAR 0 1
81768: PPUSH
81769: CALL_OW 321
81773: PUSH
81774: LD_INT 2
81776: EQUAL
81777: ST_TO_ADDR
81778: GO 81952
81780: LD_INT 16
81782: DOUBLE
81783: EQUAL
81784: IFTRUE 81788
81786: GO 81813
81788: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
81789: LD_ADDR_VAR 0 3
81793: PUSH
81794: LD_INT 84
81796: PPUSH
81797: LD_VAR 0 1
81801: PPUSH
81802: CALL_OW 321
81806: PUSH
81807: LD_INT 2
81809: EQUAL
81810: ST_TO_ADDR
81811: GO 81952
81813: LD_INT 19
81815: DOUBLE
81816: EQUAL
81817: IFTRUE 81827
81819: LD_INT 23
81821: DOUBLE
81822: EQUAL
81823: IFTRUE 81827
81825: GO 81852
81827: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
81828: LD_ADDR_VAR 0 3
81832: PUSH
81833: LD_INT 83
81835: PPUSH
81836: LD_VAR 0 1
81840: PPUSH
81841: CALL_OW 321
81845: PUSH
81846: LD_INT 2
81848: EQUAL
81849: ST_TO_ADDR
81850: GO 81952
81852: LD_INT 17
81854: DOUBLE
81855: EQUAL
81856: IFTRUE 81860
81858: GO 81885
81860: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
81861: LD_ADDR_VAR 0 3
81865: PUSH
81866: LD_INT 39
81868: PPUSH
81869: LD_VAR 0 1
81873: PPUSH
81874: CALL_OW 321
81878: PUSH
81879: LD_INT 2
81881: EQUAL
81882: ST_TO_ADDR
81883: GO 81952
81885: LD_INT 18
81887: DOUBLE
81888: EQUAL
81889: IFTRUE 81893
81891: GO 81918
81893: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
81894: LD_ADDR_VAR 0 3
81898: PUSH
81899: LD_INT 40
81901: PPUSH
81902: LD_VAR 0 1
81906: PPUSH
81907: CALL_OW 321
81911: PUSH
81912: LD_INT 2
81914: EQUAL
81915: ST_TO_ADDR
81916: GO 81952
81918: LD_INT 27
81920: DOUBLE
81921: EQUAL
81922: IFTRUE 81926
81924: GO 81951
81926: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
81927: LD_ADDR_VAR 0 3
81931: PUSH
81932: LD_INT 35
81934: PPUSH
81935: LD_VAR 0 1
81939: PPUSH
81940: CALL_OW 321
81944: PUSH
81945: LD_INT 2
81947: EQUAL
81948: ST_TO_ADDR
81949: GO 81952
81951: POP
// end ;
81952: LD_VAR 0 3
81956: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
81957: LD_INT 0
81959: PPUSH
81960: PPUSH
81961: PPUSH
81962: PPUSH
81963: PPUSH
81964: PPUSH
81965: PPUSH
81966: PPUSH
81967: PPUSH
81968: PPUSH
81969: PPUSH
// result := false ;
81970: LD_ADDR_VAR 0 6
81974: PUSH
81975: LD_INT 0
81977: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
81978: LD_VAR 0 1
81982: NOT
81983: PUSH
81984: LD_VAR 0 1
81988: PPUSH
81989: CALL_OW 266
81993: PUSH
81994: LD_INT 0
81996: PUSH
81997: LD_INT 1
81999: PUSH
82000: EMPTY
82001: LIST
82002: LIST
82003: IN
82004: NOT
82005: OR
82006: PUSH
82007: LD_VAR 0 2
82011: NOT
82012: OR
82013: PUSH
82014: LD_VAR 0 5
82018: PUSH
82019: LD_INT 0
82021: PUSH
82022: LD_INT 1
82024: PUSH
82025: LD_INT 2
82027: PUSH
82028: LD_INT 3
82030: PUSH
82031: LD_INT 4
82033: PUSH
82034: LD_INT 5
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: IN
82045: NOT
82046: OR
82047: PUSH
82048: LD_VAR 0 3
82052: PPUSH
82053: LD_VAR 0 4
82057: PPUSH
82058: CALL_OW 488
82062: NOT
82063: OR
82064: IFFALSE 82068
// exit ;
82066: GO 82804
// side := GetSide ( depot ) ;
82068: LD_ADDR_VAR 0 9
82072: PUSH
82073: LD_VAR 0 1
82077: PPUSH
82078: CALL_OW 255
82082: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
82083: LD_VAR 0 9
82087: PPUSH
82088: LD_VAR 0 2
82092: PPUSH
82093: CALL 81581 0 2
82097: NOT
82098: IFFALSE 82102
// exit ;
82100: GO 82804
// pom := GetBase ( depot ) ;
82102: LD_ADDR_VAR 0 10
82106: PUSH
82107: LD_VAR 0 1
82111: PPUSH
82112: CALL_OW 274
82116: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
82117: LD_ADDR_VAR 0 11
82121: PUSH
82122: LD_VAR 0 2
82126: PPUSH
82127: LD_VAR 0 1
82131: PPUSH
82132: CALL_OW 248
82136: PPUSH
82137: CALL_OW 450
82141: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
82142: LD_VAR 0 10
82146: PPUSH
82147: LD_INT 1
82149: PPUSH
82150: CALL_OW 275
82154: PUSH
82155: LD_VAR 0 11
82159: PUSH
82160: LD_INT 1
82162: ARRAY
82163: GREATEREQUAL
82164: PUSH
82165: LD_VAR 0 10
82169: PPUSH
82170: LD_INT 2
82172: PPUSH
82173: CALL_OW 275
82177: PUSH
82178: LD_VAR 0 11
82182: PUSH
82183: LD_INT 2
82185: ARRAY
82186: GREATEREQUAL
82187: AND
82188: PUSH
82189: LD_VAR 0 10
82193: PPUSH
82194: LD_INT 3
82196: PPUSH
82197: CALL_OW 275
82201: PUSH
82202: LD_VAR 0 11
82206: PUSH
82207: LD_INT 3
82209: ARRAY
82210: GREATEREQUAL
82211: AND
82212: NOT
82213: IFFALSE 82217
// exit ;
82215: GO 82804
// if GetBType ( depot ) = b_depot then
82217: LD_VAR 0 1
82221: PPUSH
82222: CALL_OW 266
82226: PUSH
82227: LD_INT 0
82229: EQUAL
82230: IFFALSE 82242
// dist := 28 else
82232: LD_ADDR_VAR 0 14
82236: PUSH
82237: LD_INT 28
82239: ST_TO_ADDR
82240: GO 82250
// dist := 36 ;
82242: LD_ADDR_VAR 0 14
82246: PUSH
82247: LD_INT 36
82249: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
82250: LD_VAR 0 1
82254: PPUSH
82255: LD_VAR 0 3
82259: PPUSH
82260: LD_VAR 0 4
82264: PPUSH
82265: CALL_OW 297
82269: PUSH
82270: LD_VAR 0 14
82274: GREATER
82275: IFFALSE 82279
// exit ;
82277: GO 82804
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
82279: LD_ADDR_VAR 0 12
82283: PUSH
82284: LD_VAR 0 2
82288: PPUSH
82289: LD_VAR 0 3
82293: PPUSH
82294: LD_VAR 0 4
82298: PPUSH
82299: LD_VAR 0 5
82303: PPUSH
82304: LD_VAR 0 1
82308: PPUSH
82309: CALL_OW 248
82313: PPUSH
82314: LD_INT 0
82316: PPUSH
82317: CALL 82809 0 6
82321: ST_TO_ADDR
// if not hexes then
82322: LD_VAR 0 12
82326: NOT
82327: IFFALSE 82331
// exit ;
82329: GO 82804
// hex := GetHexInfo ( x , y ) ;
82331: LD_ADDR_VAR 0 15
82335: PUSH
82336: LD_VAR 0 3
82340: PPUSH
82341: LD_VAR 0 4
82345: PPUSH
82346: CALL_OW 546
82350: ST_TO_ADDR
// if hex [ 1 ] then
82351: LD_VAR 0 15
82355: PUSH
82356: LD_INT 1
82358: ARRAY
82359: IFFALSE 82363
// exit ;
82361: GO 82804
// height := hex [ 2 ] ;
82363: LD_ADDR_VAR 0 13
82367: PUSH
82368: LD_VAR 0 15
82372: PUSH
82373: LD_INT 2
82375: ARRAY
82376: ST_TO_ADDR
// for i = 1 to hexes do
82377: LD_ADDR_VAR 0 7
82381: PUSH
82382: DOUBLE
82383: LD_INT 1
82385: DEC
82386: ST_TO_ADDR
82387: LD_VAR 0 12
82391: PUSH
82392: FOR_TO
82393: IFFALSE 82723
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
82395: LD_VAR 0 12
82399: PUSH
82400: LD_VAR 0 7
82404: ARRAY
82405: PUSH
82406: LD_INT 1
82408: ARRAY
82409: PPUSH
82410: LD_VAR 0 12
82414: PUSH
82415: LD_VAR 0 7
82419: ARRAY
82420: PUSH
82421: LD_INT 2
82423: ARRAY
82424: PPUSH
82425: CALL_OW 488
82429: NOT
82430: PUSH
82431: LD_VAR 0 12
82435: PUSH
82436: LD_VAR 0 7
82440: ARRAY
82441: PUSH
82442: LD_INT 1
82444: ARRAY
82445: PPUSH
82446: LD_VAR 0 12
82450: PUSH
82451: LD_VAR 0 7
82455: ARRAY
82456: PUSH
82457: LD_INT 2
82459: ARRAY
82460: PPUSH
82461: CALL_OW 428
82465: PUSH
82466: LD_INT 0
82468: GREATER
82469: OR
82470: PUSH
82471: LD_VAR 0 12
82475: PUSH
82476: LD_VAR 0 7
82480: ARRAY
82481: PUSH
82482: LD_INT 1
82484: ARRAY
82485: PPUSH
82486: LD_VAR 0 12
82490: PUSH
82491: LD_VAR 0 7
82495: ARRAY
82496: PUSH
82497: LD_INT 2
82499: ARRAY
82500: PPUSH
82501: CALL_OW 351
82505: OR
82506: IFFALSE 82512
// exit ;
82508: POP
82509: POP
82510: GO 82804
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82512: LD_ADDR_VAR 0 8
82516: PUSH
82517: LD_VAR 0 12
82521: PUSH
82522: LD_VAR 0 7
82526: ARRAY
82527: PUSH
82528: LD_INT 1
82530: ARRAY
82531: PPUSH
82532: LD_VAR 0 12
82536: PUSH
82537: LD_VAR 0 7
82541: ARRAY
82542: PUSH
82543: LD_INT 2
82545: ARRAY
82546: PPUSH
82547: CALL_OW 546
82551: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
82552: LD_VAR 0 8
82556: PUSH
82557: LD_INT 1
82559: ARRAY
82560: PUSH
82561: LD_VAR 0 8
82565: PUSH
82566: LD_INT 2
82568: ARRAY
82569: PUSH
82570: LD_VAR 0 13
82574: PUSH
82575: LD_INT 2
82577: PLUS
82578: GREATER
82579: OR
82580: PUSH
82581: LD_VAR 0 8
82585: PUSH
82586: LD_INT 2
82588: ARRAY
82589: PUSH
82590: LD_VAR 0 13
82594: PUSH
82595: LD_INT 2
82597: MINUS
82598: LESS
82599: OR
82600: PUSH
82601: LD_VAR 0 8
82605: PUSH
82606: LD_INT 3
82608: ARRAY
82609: PUSH
82610: LD_INT 0
82612: PUSH
82613: LD_INT 8
82615: PUSH
82616: LD_INT 9
82618: PUSH
82619: LD_INT 10
82621: PUSH
82622: LD_INT 11
82624: PUSH
82625: LD_INT 12
82627: PUSH
82628: LD_INT 13
82630: PUSH
82631: LD_INT 16
82633: PUSH
82634: LD_INT 17
82636: PUSH
82637: LD_INT 18
82639: PUSH
82640: LD_INT 19
82642: PUSH
82643: LD_INT 20
82645: PUSH
82646: LD_INT 21
82648: PUSH
82649: EMPTY
82650: LIST
82651: LIST
82652: LIST
82653: LIST
82654: LIST
82655: LIST
82656: LIST
82657: LIST
82658: LIST
82659: LIST
82660: LIST
82661: LIST
82662: LIST
82663: IN
82664: NOT
82665: OR
82666: PUSH
82667: LD_VAR 0 8
82671: PUSH
82672: LD_INT 5
82674: ARRAY
82675: NOT
82676: OR
82677: PUSH
82678: LD_VAR 0 8
82682: PUSH
82683: LD_INT 6
82685: ARRAY
82686: PUSH
82687: LD_INT 1
82689: PUSH
82690: LD_INT 2
82692: PUSH
82693: LD_INT 7
82695: PUSH
82696: LD_INT 9
82698: PUSH
82699: LD_INT 10
82701: PUSH
82702: LD_INT 11
82704: PUSH
82705: EMPTY
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: IN
82713: NOT
82714: OR
82715: IFFALSE 82721
// exit ;
82717: POP
82718: POP
82719: GO 82804
// end ;
82721: GO 82392
82723: POP
82724: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
82725: LD_VAR 0 9
82729: PPUSH
82730: LD_VAR 0 3
82734: PPUSH
82735: LD_VAR 0 4
82739: PPUSH
82740: LD_INT 20
82742: PPUSH
82743: CALL 74756 0 4
82747: PUSH
82748: LD_INT 4
82750: ARRAY
82751: IFFALSE 82755
// exit ;
82753: GO 82804
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
82755: LD_VAR 0 2
82759: PUSH
82760: LD_INT 29
82762: PUSH
82763: LD_INT 30
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: IN
82770: PUSH
82771: LD_VAR 0 3
82775: PPUSH
82776: LD_VAR 0 4
82780: PPUSH
82781: LD_VAR 0 9
82785: PPUSH
82786: CALL_OW 440
82790: NOT
82791: AND
82792: IFFALSE 82796
// exit ;
82794: GO 82804
// result := true ;
82796: LD_ADDR_VAR 0 6
82800: PUSH
82801: LD_INT 1
82803: ST_TO_ADDR
// end ;
82804: LD_VAR 0 6
82808: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
82809: LD_INT 0
82811: PPUSH
82812: PPUSH
82813: PPUSH
82814: PPUSH
82815: PPUSH
82816: PPUSH
82817: PPUSH
82818: PPUSH
82819: PPUSH
82820: PPUSH
82821: PPUSH
82822: PPUSH
82823: PPUSH
82824: PPUSH
82825: PPUSH
82826: PPUSH
82827: PPUSH
82828: PPUSH
82829: PPUSH
82830: PPUSH
82831: PPUSH
82832: PPUSH
82833: PPUSH
82834: PPUSH
82835: PPUSH
82836: PPUSH
82837: PPUSH
82838: PPUSH
82839: PPUSH
82840: PPUSH
82841: PPUSH
82842: PPUSH
82843: PPUSH
82844: PPUSH
82845: PPUSH
82846: PPUSH
82847: PPUSH
82848: PPUSH
82849: PPUSH
82850: PPUSH
82851: PPUSH
82852: PPUSH
82853: PPUSH
82854: PPUSH
82855: PPUSH
82856: PPUSH
82857: PPUSH
82858: PPUSH
82859: PPUSH
82860: PPUSH
82861: PPUSH
82862: PPUSH
82863: PPUSH
82864: PPUSH
82865: PPUSH
82866: PPUSH
82867: PPUSH
82868: PPUSH
// result = [ ] ;
82869: LD_ADDR_VAR 0 7
82873: PUSH
82874: EMPTY
82875: ST_TO_ADDR
// temp_list = [ ] ;
82876: LD_ADDR_VAR 0 9
82880: PUSH
82881: EMPTY
82882: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
82883: LD_VAR 0 4
82887: PUSH
82888: LD_INT 0
82890: PUSH
82891: LD_INT 1
82893: PUSH
82894: LD_INT 2
82896: PUSH
82897: LD_INT 3
82899: PUSH
82900: LD_INT 4
82902: PUSH
82903: LD_INT 5
82905: PUSH
82906: EMPTY
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: LIST
82912: LIST
82913: IN
82914: NOT
82915: PUSH
82916: LD_VAR 0 1
82920: PUSH
82921: LD_INT 0
82923: PUSH
82924: LD_INT 1
82926: PUSH
82927: EMPTY
82928: LIST
82929: LIST
82930: IN
82931: PUSH
82932: LD_VAR 0 5
82936: PUSH
82937: LD_INT 1
82939: PUSH
82940: LD_INT 2
82942: PUSH
82943: LD_INT 3
82945: PUSH
82946: EMPTY
82947: LIST
82948: LIST
82949: LIST
82950: IN
82951: NOT
82952: AND
82953: OR
82954: IFFALSE 82958
// exit ;
82956: GO 101349
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
82958: LD_VAR 0 1
82962: PUSH
82963: LD_INT 6
82965: PUSH
82966: LD_INT 7
82968: PUSH
82969: LD_INT 8
82971: PUSH
82972: LD_INT 13
82974: PUSH
82975: LD_INT 12
82977: PUSH
82978: LD_INT 15
82980: PUSH
82981: LD_INT 11
82983: PUSH
82984: LD_INT 14
82986: PUSH
82987: LD_INT 10
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: IN
83001: IFFALSE 83011
// btype = b_lab ;
83003: LD_ADDR_VAR 0 1
83007: PUSH
83008: LD_INT 6
83010: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
83011: LD_VAR 0 6
83015: PUSH
83016: LD_INT 0
83018: PUSH
83019: LD_INT 1
83021: PUSH
83022: LD_INT 2
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: LIST
83029: IN
83030: NOT
83031: PUSH
83032: LD_VAR 0 1
83036: PUSH
83037: LD_INT 0
83039: PUSH
83040: LD_INT 1
83042: PUSH
83043: LD_INT 2
83045: PUSH
83046: LD_INT 3
83048: PUSH
83049: LD_INT 6
83051: PUSH
83052: LD_INT 36
83054: PUSH
83055: LD_INT 4
83057: PUSH
83058: LD_INT 5
83060: PUSH
83061: LD_INT 31
83063: PUSH
83064: LD_INT 32
83066: PUSH
83067: LD_INT 33
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: LIST
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: IN
83083: NOT
83084: PUSH
83085: LD_VAR 0 6
83089: PUSH
83090: LD_INT 1
83092: EQUAL
83093: AND
83094: OR
83095: PUSH
83096: LD_VAR 0 1
83100: PUSH
83101: LD_INT 2
83103: PUSH
83104: LD_INT 3
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: IN
83111: NOT
83112: PUSH
83113: LD_VAR 0 6
83117: PUSH
83118: LD_INT 2
83120: EQUAL
83121: AND
83122: OR
83123: IFFALSE 83133
// mode = 0 ;
83125: LD_ADDR_VAR 0 6
83129: PUSH
83130: LD_INT 0
83132: ST_TO_ADDR
// case mode of 0 :
83133: LD_VAR 0 6
83137: PUSH
83138: LD_INT 0
83140: DOUBLE
83141: EQUAL
83142: IFTRUE 83146
83144: GO 94599
83146: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
83147: LD_ADDR_VAR 0 11
83151: PUSH
83152: LD_INT 0
83154: PUSH
83155: LD_INT 0
83157: PUSH
83158: EMPTY
83159: LIST
83160: LIST
83161: PUSH
83162: LD_INT 0
83164: PUSH
83165: LD_INT 1
83167: NEG
83168: PUSH
83169: EMPTY
83170: LIST
83171: LIST
83172: PUSH
83173: LD_INT 1
83175: PUSH
83176: LD_INT 0
83178: PUSH
83179: EMPTY
83180: LIST
83181: LIST
83182: PUSH
83183: LD_INT 1
83185: PUSH
83186: LD_INT 1
83188: PUSH
83189: EMPTY
83190: LIST
83191: LIST
83192: PUSH
83193: LD_INT 0
83195: PUSH
83196: LD_INT 1
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 1
83205: NEG
83206: PUSH
83207: LD_INT 0
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 1
83216: NEG
83217: PUSH
83218: LD_INT 1
83220: NEG
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: PUSH
83226: LD_INT 1
83228: NEG
83229: PUSH
83230: LD_INT 2
83232: NEG
83233: PUSH
83234: EMPTY
83235: LIST
83236: LIST
83237: PUSH
83238: LD_INT 0
83240: PUSH
83241: LD_INT 2
83243: NEG
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: PUSH
83249: LD_INT 1
83251: PUSH
83252: LD_INT 1
83254: NEG
83255: PUSH
83256: EMPTY
83257: LIST
83258: LIST
83259: PUSH
83260: LD_INT 1
83262: PUSH
83263: LD_INT 2
83265: PUSH
83266: EMPTY
83267: LIST
83268: LIST
83269: PUSH
83270: LD_INT 0
83272: PUSH
83273: LD_INT 2
83275: PUSH
83276: EMPTY
83277: LIST
83278: LIST
83279: PUSH
83280: LD_INT 1
83282: NEG
83283: PUSH
83284: LD_INT 1
83286: PUSH
83287: EMPTY
83288: LIST
83289: LIST
83290: PUSH
83291: LD_INT 1
83293: PUSH
83294: LD_INT 3
83296: PUSH
83297: EMPTY
83298: LIST
83299: LIST
83300: PUSH
83301: LD_INT 0
83303: PUSH
83304: LD_INT 3
83306: PUSH
83307: EMPTY
83308: LIST
83309: LIST
83310: PUSH
83311: LD_INT 1
83313: NEG
83314: PUSH
83315: LD_INT 2
83317: PUSH
83318: EMPTY
83319: LIST
83320: LIST
83321: PUSH
83322: EMPTY
83323: LIST
83324: LIST
83325: LIST
83326: LIST
83327: LIST
83328: LIST
83329: LIST
83330: LIST
83331: LIST
83332: LIST
83333: LIST
83334: LIST
83335: LIST
83336: LIST
83337: LIST
83338: LIST
83339: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
83340: LD_ADDR_VAR 0 12
83344: PUSH
83345: LD_INT 0
83347: PUSH
83348: LD_INT 0
83350: PUSH
83351: EMPTY
83352: LIST
83353: LIST
83354: PUSH
83355: LD_INT 0
83357: PUSH
83358: LD_INT 1
83360: NEG
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 1
83368: PUSH
83369: LD_INT 0
83371: PUSH
83372: EMPTY
83373: LIST
83374: LIST
83375: PUSH
83376: LD_INT 1
83378: PUSH
83379: LD_INT 1
83381: PUSH
83382: EMPTY
83383: LIST
83384: LIST
83385: PUSH
83386: LD_INT 0
83388: PUSH
83389: LD_INT 1
83391: PUSH
83392: EMPTY
83393: LIST
83394: LIST
83395: PUSH
83396: LD_INT 1
83398: NEG
83399: PUSH
83400: LD_INT 0
83402: PUSH
83403: EMPTY
83404: LIST
83405: LIST
83406: PUSH
83407: LD_INT 1
83409: NEG
83410: PUSH
83411: LD_INT 1
83413: NEG
83414: PUSH
83415: EMPTY
83416: LIST
83417: LIST
83418: PUSH
83419: LD_INT 1
83421: PUSH
83422: LD_INT 1
83424: NEG
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 2
83432: PUSH
83433: LD_INT 0
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 2
83442: PUSH
83443: LD_INT 1
83445: PUSH
83446: EMPTY
83447: LIST
83448: LIST
83449: PUSH
83450: LD_INT 1
83452: NEG
83453: PUSH
83454: LD_INT 1
83456: PUSH
83457: EMPTY
83458: LIST
83459: LIST
83460: PUSH
83461: LD_INT 2
83463: NEG
83464: PUSH
83465: LD_INT 0
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: PUSH
83472: LD_INT 2
83474: NEG
83475: PUSH
83476: LD_INT 1
83478: NEG
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 2
83486: NEG
83487: PUSH
83488: LD_INT 1
83490: PUSH
83491: EMPTY
83492: LIST
83493: LIST
83494: PUSH
83495: LD_INT 3
83497: NEG
83498: PUSH
83499: LD_INT 0
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: PUSH
83506: LD_INT 3
83508: NEG
83509: PUSH
83510: LD_INT 1
83512: NEG
83513: PUSH
83514: EMPTY
83515: LIST
83516: LIST
83517: PUSH
83518: EMPTY
83519: LIST
83520: LIST
83521: LIST
83522: LIST
83523: LIST
83524: LIST
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
83536: LD_ADDR_VAR 0 13
83540: PUSH
83541: LD_INT 0
83543: PUSH
83544: LD_INT 0
83546: PUSH
83547: EMPTY
83548: LIST
83549: LIST
83550: PUSH
83551: LD_INT 0
83553: PUSH
83554: LD_INT 1
83556: NEG
83557: PUSH
83558: EMPTY
83559: LIST
83560: LIST
83561: PUSH
83562: LD_INT 1
83564: PUSH
83565: LD_INT 0
83567: PUSH
83568: EMPTY
83569: LIST
83570: LIST
83571: PUSH
83572: LD_INT 1
83574: PUSH
83575: LD_INT 1
83577: PUSH
83578: EMPTY
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 0
83584: PUSH
83585: LD_INT 1
83587: PUSH
83588: EMPTY
83589: LIST
83590: LIST
83591: PUSH
83592: LD_INT 1
83594: NEG
83595: PUSH
83596: LD_INT 0
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 1
83605: NEG
83606: PUSH
83607: LD_INT 1
83609: NEG
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: PUSH
83615: LD_INT 1
83617: NEG
83618: PUSH
83619: LD_INT 2
83621: NEG
83622: PUSH
83623: EMPTY
83624: LIST
83625: LIST
83626: PUSH
83627: LD_INT 2
83629: PUSH
83630: LD_INT 1
83632: PUSH
83633: EMPTY
83634: LIST
83635: LIST
83636: PUSH
83637: LD_INT 2
83639: PUSH
83640: LD_INT 2
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: PUSH
83647: LD_INT 1
83649: PUSH
83650: LD_INT 2
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PUSH
83657: LD_INT 2
83659: NEG
83660: PUSH
83661: LD_INT 1
83663: NEG
83664: PUSH
83665: EMPTY
83666: LIST
83667: LIST
83668: PUSH
83669: LD_INT 2
83671: NEG
83672: PUSH
83673: LD_INT 2
83675: NEG
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 2
83683: NEG
83684: PUSH
83685: LD_INT 3
83687: NEG
83688: PUSH
83689: EMPTY
83690: LIST
83691: LIST
83692: PUSH
83693: LD_INT 3
83695: NEG
83696: PUSH
83697: LD_INT 2
83699: NEG
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: PUSH
83705: LD_INT 3
83707: NEG
83708: PUSH
83709: LD_INT 3
83711: NEG
83712: PUSH
83713: EMPTY
83714: LIST
83715: LIST
83716: PUSH
83717: EMPTY
83718: LIST
83719: LIST
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: LIST
83729: LIST
83730: LIST
83731: LIST
83732: LIST
83733: LIST
83734: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
83735: LD_ADDR_VAR 0 14
83739: PUSH
83740: LD_INT 0
83742: PUSH
83743: LD_INT 0
83745: PUSH
83746: EMPTY
83747: LIST
83748: LIST
83749: PUSH
83750: LD_INT 0
83752: PUSH
83753: LD_INT 1
83755: NEG
83756: PUSH
83757: EMPTY
83758: LIST
83759: LIST
83760: PUSH
83761: LD_INT 1
83763: PUSH
83764: LD_INT 0
83766: PUSH
83767: EMPTY
83768: LIST
83769: LIST
83770: PUSH
83771: LD_INT 1
83773: PUSH
83774: LD_INT 1
83776: PUSH
83777: EMPTY
83778: LIST
83779: LIST
83780: PUSH
83781: LD_INT 0
83783: PUSH
83784: LD_INT 1
83786: PUSH
83787: EMPTY
83788: LIST
83789: LIST
83790: PUSH
83791: LD_INT 1
83793: NEG
83794: PUSH
83795: LD_INT 0
83797: PUSH
83798: EMPTY
83799: LIST
83800: LIST
83801: PUSH
83802: LD_INT 1
83804: NEG
83805: PUSH
83806: LD_INT 1
83808: NEG
83809: PUSH
83810: EMPTY
83811: LIST
83812: LIST
83813: PUSH
83814: LD_INT 1
83816: NEG
83817: PUSH
83818: LD_INT 2
83820: NEG
83821: PUSH
83822: EMPTY
83823: LIST
83824: LIST
83825: PUSH
83826: LD_INT 0
83828: PUSH
83829: LD_INT 2
83831: NEG
83832: PUSH
83833: EMPTY
83834: LIST
83835: LIST
83836: PUSH
83837: LD_INT 1
83839: PUSH
83840: LD_INT 1
83842: NEG
83843: PUSH
83844: EMPTY
83845: LIST
83846: LIST
83847: PUSH
83848: LD_INT 1
83850: PUSH
83851: LD_INT 2
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PUSH
83858: LD_INT 0
83860: PUSH
83861: LD_INT 2
83863: PUSH
83864: EMPTY
83865: LIST
83866: LIST
83867: PUSH
83868: LD_INT 1
83870: NEG
83871: PUSH
83872: LD_INT 1
83874: PUSH
83875: EMPTY
83876: LIST
83877: LIST
83878: PUSH
83879: LD_INT 1
83881: NEG
83882: PUSH
83883: LD_INT 3
83885: NEG
83886: PUSH
83887: EMPTY
83888: LIST
83889: LIST
83890: PUSH
83891: LD_INT 0
83893: PUSH
83894: LD_INT 3
83896: NEG
83897: PUSH
83898: EMPTY
83899: LIST
83900: LIST
83901: PUSH
83902: LD_INT 1
83904: PUSH
83905: LD_INT 2
83907: NEG
83908: PUSH
83909: EMPTY
83910: LIST
83911: LIST
83912: PUSH
83913: EMPTY
83914: LIST
83915: LIST
83916: LIST
83917: LIST
83918: LIST
83919: LIST
83920: LIST
83921: LIST
83922: LIST
83923: LIST
83924: LIST
83925: LIST
83926: LIST
83927: LIST
83928: LIST
83929: LIST
83930: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
83931: LD_ADDR_VAR 0 15
83935: PUSH
83936: LD_INT 0
83938: PUSH
83939: LD_INT 0
83941: PUSH
83942: EMPTY
83943: LIST
83944: LIST
83945: PUSH
83946: LD_INT 0
83948: PUSH
83949: LD_INT 1
83951: NEG
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: PUSH
83957: LD_INT 1
83959: PUSH
83960: LD_INT 0
83962: PUSH
83963: EMPTY
83964: LIST
83965: LIST
83966: PUSH
83967: LD_INT 1
83969: PUSH
83970: LD_INT 1
83972: PUSH
83973: EMPTY
83974: LIST
83975: LIST
83976: PUSH
83977: LD_INT 0
83979: PUSH
83980: LD_INT 1
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: LD_INT 1
83989: NEG
83990: PUSH
83991: LD_INT 0
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: PUSH
83998: LD_INT 1
84000: NEG
84001: PUSH
84002: LD_INT 1
84004: NEG
84005: PUSH
84006: EMPTY
84007: LIST
84008: LIST
84009: PUSH
84010: LD_INT 1
84012: PUSH
84013: LD_INT 1
84015: NEG
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: LD_INT 2
84023: PUSH
84024: LD_INT 0
84026: PUSH
84027: EMPTY
84028: LIST
84029: LIST
84030: PUSH
84031: LD_INT 2
84033: PUSH
84034: LD_INT 1
84036: PUSH
84037: EMPTY
84038: LIST
84039: LIST
84040: PUSH
84041: LD_INT 1
84043: NEG
84044: PUSH
84045: LD_INT 1
84047: PUSH
84048: EMPTY
84049: LIST
84050: LIST
84051: PUSH
84052: LD_INT 2
84054: NEG
84055: PUSH
84056: LD_INT 0
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 2
84065: NEG
84066: PUSH
84067: LD_INT 1
84069: NEG
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: LD_INT 2
84077: PUSH
84078: LD_INT 1
84080: NEG
84081: PUSH
84082: EMPTY
84083: LIST
84084: LIST
84085: PUSH
84086: LD_INT 3
84088: PUSH
84089: LD_INT 0
84091: PUSH
84092: EMPTY
84093: LIST
84094: LIST
84095: PUSH
84096: LD_INT 3
84098: PUSH
84099: LD_INT 1
84101: PUSH
84102: EMPTY
84103: LIST
84104: LIST
84105: PUSH
84106: EMPTY
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: LIST
84112: LIST
84113: LIST
84114: LIST
84115: LIST
84116: LIST
84117: LIST
84118: LIST
84119: LIST
84120: LIST
84121: LIST
84122: LIST
84123: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
84124: LD_ADDR_VAR 0 16
84128: PUSH
84129: LD_INT 0
84131: PUSH
84132: LD_INT 0
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PUSH
84139: LD_INT 0
84141: PUSH
84142: LD_INT 1
84144: NEG
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: PUSH
84150: LD_INT 1
84152: PUSH
84153: LD_INT 0
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: PUSH
84160: LD_INT 1
84162: PUSH
84163: LD_INT 1
84165: PUSH
84166: EMPTY
84167: LIST
84168: LIST
84169: PUSH
84170: LD_INT 0
84172: PUSH
84173: LD_INT 1
84175: PUSH
84176: EMPTY
84177: LIST
84178: LIST
84179: PUSH
84180: LD_INT 1
84182: NEG
84183: PUSH
84184: LD_INT 0
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 1
84193: NEG
84194: PUSH
84195: LD_INT 1
84197: NEG
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: PUSH
84203: LD_INT 1
84205: NEG
84206: PUSH
84207: LD_INT 2
84209: NEG
84210: PUSH
84211: EMPTY
84212: LIST
84213: LIST
84214: PUSH
84215: LD_INT 2
84217: PUSH
84218: LD_INT 1
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: PUSH
84225: LD_INT 2
84227: PUSH
84228: LD_INT 2
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: LD_INT 1
84237: PUSH
84238: LD_INT 2
84240: PUSH
84241: EMPTY
84242: LIST
84243: LIST
84244: PUSH
84245: LD_INT 2
84247: NEG
84248: PUSH
84249: LD_INT 1
84251: NEG
84252: PUSH
84253: EMPTY
84254: LIST
84255: LIST
84256: PUSH
84257: LD_INT 2
84259: NEG
84260: PUSH
84261: LD_INT 2
84263: NEG
84264: PUSH
84265: EMPTY
84266: LIST
84267: LIST
84268: PUSH
84269: LD_INT 3
84271: PUSH
84272: LD_INT 2
84274: PUSH
84275: EMPTY
84276: LIST
84277: LIST
84278: PUSH
84279: LD_INT 3
84281: PUSH
84282: LD_INT 3
84284: PUSH
84285: EMPTY
84286: LIST
84287: LIST
84288: PUSH
84289: LD_INT 2
84291: PUSH
84292: LD_INT 3
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: LIST
84303: LIST
84304: LIST
84305: LIST
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84317: LD_ADDR_VAR 0 17
84321: PUSH
84322: LD_INT 0
84324: PUSH
84325: LD_INT 0
84327: PUSH
84328: EMPTY
84329: LIST
84330: LIST
84331: PUSH
84332: LD_INT 0
84334: PUSH
84335: LD_INT 1
84337: NEG
84338: PUSH
84339: EMPTY
84340: LIST
84341: LIST
84342: PUSH
84343: LD_INT 1
84345: PUSH
84346: LD_INT 0
84348: PUSH
84349: EMPTY
84350: LIST
84351: LIST
84352: PUSH
84353: LD_INT 1
84355: PUSH
84356: LD_INT 1
84358: PUSH
84359: EMPTY
84360: LIST
84361: LIST
84362: PUSH
84363: LD_INT 0
84365: PUSH
84366: LD_INT 1
84368: PUSH
84369: EMPTY
84370: LIST
84371: LIST
84372: PUSH
84373: LD_INT 1
84375: NEG
84376: PUSH
84377: LD_INT 0
84379: PUSH
84380: EMPTY
84381: LIST
84382: LIST
84383: PUSH
84384: LD_INT 1
84386: NEG
84387: PUSH
84388: LD_INT 1
84390: NEG
84391: PUSH
84392: EMPTY
84393: LIST
84394: LIST
84395: PUSH
84396: LD_INT 1
84398: NEG
84399: PUSH
84400: LD_INT 2
84402: NEG
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: PUSH
84408: LD_INT 0
84410: PUSH
84411: LD_INT 2
84413: NEG
84414: PUSH
84415: EMPTY
84416: LIST
84417: LIST
84418: PUSH
84419: LD_INT 1
84421: PUSH
84422: LD_INT 1
84424: NEG
84425: PUSH
84426: EMPTY
84427: LIST
84428: LIST
84429: PUSH
84430: LD_INT 2
84432: PUSH
84433: LD_INT 0
84435: PUSH
84436: EMPTY
84437: LIST
84438: LIST
84439: PUSH
84440: LD_INT 2
84442: PUSH
84443: LD_INT 1
84445: PUSH
84446: EMPTY
84447: LIST
84448: LIST
84449: PUSH
84450: LD_INT 2
84452: PUSH
84453: LD_INT 2
84455: PUSH
84456: EMPTY
84457: LIST
84458: LIST
84459: PUSH
84460: LD_INT 1
84462: PUSH
84463: LD_INT 2
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: PUSH
84470: LD_INT 0
84472: PUSH
84473: LD_INT 2
84475: PUSH
84476: EMPTY
84477: LIST
84478: LIST
84479: PUSH
84480: LD_INT 1
84482: NEG
84483: PUSH
84484: LD_INT 1
84486: PUSH
84487: EMPTY
84488: LIST
84489: LIST
84490: PUSH
84491: LD_INT 2
84493: NEG
84494: PUSH
84495: LD_INT 0
84497: PUSH
84498: EMPTY
84499: LIST
84500: LIST
84501: PUSH
84502: LD_INT 2
84504: NEG
84505: PUSH
84506: LD_INT 1
84508: NEG
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: PUSH
84514: LD_INT 2
84516: NEG
84517: PUSH
84518: LD_INT 2
84520: NEG
84521: PUSH
84522: EMPTY
84523: LIST
84524: LIST
84525: PUSH
84526: EMPTY
84527: LIST
84528: LIST
84529: LIST
84530: LIST
84531: LIST
84532: LIST
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84547: LD_ADDR_VAR 0 18
84551: PUSH
84552: LD_INT 0
84554: PUSH
84555: LD_INT 0
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: PUSH
84562: LD_INT 0
84564: PUSH
84565: LD_INT 1
84567: NEG
84568: PUSH
84569: EMPTY
84570: LIST
84571: LIST
84572: PUSH
84573: LD_INT 1
84575: PUSH
84576: LD_INT 0
84578: PUSH
84579: EMPTY
84580: LIST
84581: LIST
84582: PUSH
84583: LD_INT 1
84585: PUSH
84586: LD_INT 1
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: PUSH
84593: LD_INT 0
84595: PUSH
84596: LD_INT 1
84598: PUSH
84599: EMPTY
84600: LIST
84601: LIST
84602: PUSH
84603: LD_INT 1
84605: NEG
84606: PUSH
84607: LD_INT 0
84609: PUSH
84610: EMPTY
84611: LIST
84612: LIST
84613: PUSH
84614: LD_INT 1
84616: NEG
84617: PUSH
84618: LD_INT 1
84620: NEG
84621: PUSH
84622: EMPTY
84623: LIST
84624: LIST
84625: PUSH
84626: LD_INT 1
84628: NEG
84629: PUSH
84630: LD_INT 2
84632: NEG
84633: PUSH
84634: EMPTY
84635: LIST
84636: LIST
84637: PUSH
84638: LD_INT 0
84640: PUSH
84641: LD_INT 2
84643: NEG
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: PUSH
84649: LD_INT 1
84651: PUSH
84652: LD_INT 1
84654: NEG
84655: PUSH
84656: EMPTY
84657: LIST
84658: LIST
84659: PUSH
84660: LD_INT 2
84662: PUSH
84663: LD_INT 0
84665: PUSH
84666: EMPTY
84667: LIST
84668: LIST
84669: PUSH
84670: LD_INT 2
84672: PUSH
84673: LD_INT 1
84675: PUSH
84676: EMPTY
84677: LIST
84678: LIST
84679: PUSH
84680: LD_INT 2
84682: PUSH
84683: LD_INT 2
84685: PUSH
84686: EMPTY
84687: LIST
84688: LIST
84689: PUSH
84690: LD_INT 1
84692: PUSH
84693: LD_INT 2
84695: PUSH
84696: EMPTY
84697: LIST
84698: LIST
84699: PUSH
84700: LD_INT 0
84702: PUSH
84703: LD_INT 2
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 1
84712: NEG
84713: PUSH
84714: LD_INT 1
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 2
84723: NEG
84724: PUSH
84725: LD_INT 0
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: LD_INT 2
84734: NEG
84735: PUSH
84736: LD_INT 1
84738: NEG
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 2
84746: NEG
84747: PUSH
84748: LD_INT 2
84750: NEG
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: PUSH
84756: EMPTY
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: LIST
84767: LIST
84768: LIST
84769: LIST
84770: LIST
84771: LIST
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
84777: LD_ADDR_VAR 0 19
84781: PUSH
84782: LD_INT 0
84784: PUSH
84785: LD_INT 0
84787: PUSH
84788: EMPTY
84789: LIST
84790: LIST
84791: PUSH
84792: LD_INT 0
84794: PUSH
84795: LD_INT 1
84797: NEG
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_INT 1
84805: PUSH
84806: LD_INT 0
84808: PUSH
84809: EMPTY
84810: LIST
84811: LIST
84812: PUSH
84813: LD_INT 1
84815: PUSH
84816: LD_INT 1
84818: PUSH
84819: EMPTY
84820: LIST
84821: LIST
84822: PUSH
84823: LD_INT 0
84825: PUSH
84826: LD_INT 1
84828: PUSH
84829: EMPTY
84830: LIST
84831: LIST
84832: PUSH
84833: LD_INT 1
84835: NEG
84836: PUSH
84837: LD_INT 0
84839: PUSH
84840: EMPTY
84841: LIST
84842: LIST
84843: PUSH
84844: LD_INT 1
84846: NEG
84847: PUSH
84848: LD_INT 1
84850: NEG
84851: PUSH
84852: EMPTY
84853: LIST
84854: LIST
84855: PUSH
84856: LD_INT 1
84858: NEG
84859: PUSH
84860: LD_INT 2
84862: NEG
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: PUSH
84868: LD_INT 0
84870: PUSH
84871: LD_INT 2
84873: NEG
84874: PUSH
84875: EMPTY
84876: LIST
84877: LIST
84878: PUSH
84879: LD_INT 1
84881: PUSH
84882: LD_INT 1
84884: NEG
84885: PUSH
84886: EMPTY
84887: LIST
84888: LIST
84889: PUSH
84890: LD_INT 2
84892: PUSH
84893: LD_INT 0
84895: PUSH
84896: EMPTY
84897: LIST
84898: LIST
84899: PUSH
84900: LD_INT 2
84902: PUSH
84903: LD_INT 1
84905: PUSH
84906: EMPTY
84907: LIST
84908: LIST
84909: PUSH
84910: LD_INT 2
84912: PUSH
84913: LD_INT 2
84915: PUSH
84916: EMPTY
84917: LIST
84918: LIST
84919: PUSH
84920: LD_INT 1
84922: PUSH
84923: LD_INT 2
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: PUSH
84930: LD_INT 0
84932: PUSH
84933: LD_INT 2
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: PUSH
84940: LD_INT 1
84942: NEG
84943: PUSH
84944: LD_INT 1
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: PUSH
84951: LD_INT 2
84953: NEG
84954: PUSH
84955: LD_INT 0
84957: PUSH
84958: EMPTY
84959: LIST
84960: LIST
84961: PUSH
84962: LD_INT 2
84964: NEG
84965: PUSH
84966: LD_INT 1
84968: NEG
84969: PUSH
84970: EMPTY
84971: LIST
84972: LIST
84973: PUSH
84974: LD_INT 2
84976: NEG
84977: PUSH
84978: LD_INT 2
84980: NEG
84981: PUSH
84982: EMPTY
84983: LIST
84984: LIST
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: LIST
84990: LIST
84991: LIST
84992: LIST
84993: LIST
84994: LIST
84995: LIST
84996: LIST
84997: LIST
84998: LIST
84999: LIST
85000: LIST
85001: LIST
85002: LIST
85003: LIST
85004: LIST
85005: LIST
85006: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85007: LD_ADDR_VAR 0 20
85011: PUSH
85012: LD_INT 0
85014: PUSH
85015: LD_INT 0
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: LD_INT 0
85024: PUSH
85025: LD_INT 1
85027: NEG
85028: PUSH
85029: EMPTY
85030: LIST
85031: LIST
85032: PUSH
85033: LD_INT 1
85035: PUSH
85036: LD_INT 0
85038: PUSH
85039: EMPTY
85040: LIST
85041: LIST
85042: PUSH
85043: LD_INT 1
85045: PUSH
85046: LD_INT 1
85048: PUSH
85049: EMPTY
85050: LIST
85051: LIST
85052: PUSH
85053: LD_INT 0
85055: PUSH
85056: LD_INT 1
85058: PUSH
85059: EMPTY
85060: LIST
85061: LIST
85062: PUSH
85063: LD_INT 1
85065: NEG
85066: PUSH
85067: LD_INT 0
85069: PUSH
85070: EMPTY
85071: LIST
85072: LIST
85073: PUSH
85074: LD_INT 1
85076: NEG
85077: PUSH
85078: LD_INT 1
85080: NEG
85081: PUSH
85082: EMPTY
85083: LIST
85084: LIST
85085: PUSH
85086: LD_INT 1
85088: NEG
85089: PUSH
85090: LD_INT 2
85092: NEG
85093: PUSH
85094: EMPTY
85095: LIST
85096: LIST
85097: PUSH
85098: LD_INT 0
85100: PUSH
85101: LD_INT 2
85103: NEG
85104: PUSH
85105: EMPTY
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 1
85111: PUSH
85112: LD_INT 1
85114: NEG
85115: PUSH
85116: EMPTY
85117: LIST
85118: LIST
85119: PUSH
85120: LD_INT 2
85122: PUSH
85123: LD_INT 0
85125: PUSH
85126: EMPTY
85127: LIST
85128: LIST
85129: PUSH
85130: LD_INT 2
85132: PUSH
85133: LD_INT 1
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 2
85142: PUSH
85143: LD_INT 2
85145: PUSH
85146: EMPTY
85147: LIST
85148: LIST
85149: PUSH
85150: LD_INT 1
85152: PUSH
85153: LD_INT 2
85155: PUSH
85156: EMPTY
85157: LIST
85158: LIST
85159: PUSH
85160: LD_INT 0
85162: PUSH
85163: LD_INT 2
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: PUSH
85170: LD_INT 1
85172: NEG
85173: PUSH
85174: LD_INT 1
85176: PUSH
85177: EMPTY
85178: LIST
85179: LIST
85180: PUSH
85181: LD_INT 2
85183: NEG
85184: PUSH
85185: LD_INT 0
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PUSH
85192: LD_INT 2
85194: NEG
85195: PUSH
85196: LD_INT 1
85198: NEG
85199: PUSH
85200: EMPTY
85201: LIST
85202: LIST
85203: PUSH
85204: LD_INT 2
85206: NEG
85207: PUSH
85208: LD_INT 2
85210: NEG
85211: PUSH
85212: EMPTY
85213: LIST
85214: LIST
85215: PUSH
85216: EMPTY
85217: LIST
85218: LIST
85219: LIST
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: LIST
85225: LIST
85226: LIST
85227: LIST
85228: LIST
85229: LIST
85230: LIST
85231: LIST
85232: LIST
85233: LIST
85234: LIST
85235: LIST
85236: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85237: LD_ADDR_VAR 0 21
85241: PUSH
85242: LD_INT 0
85244: PUSH
85245: LD_INT 0
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: PUSH
85252: LD_INT 0
85254: PUSH
85255: LD_INT 1
85257: NEG
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 1
85265: PUSH
85266: LD_INT 0
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 1
85275: PUSH
85276: LD_INT 1
85278: PUSH
85279: EMPTY
85280: LIST
85281: LIST
85282: PUSH
85283: LD_INT 0
85285: PUSH
85286: LD_INT 1
85288: PUSH
85289: EMPTY
85290: LIST
85291: LIST
85292: PUSH
85293: LD_INT 1
85295: NEG
85296: PUSH
85297: LD_INT 0
85299: PUSH
85300: EMPTY
85301: LIST
85302: LIST
85303: PUSH
85304: LD_INT 1
85306: NEG
85307: PUSH
85308: LD_INT 1
85310: NEG
85311: PUSH
85312: EMPTY
85313: LIST
85314: LIST
85315: PUSH
85316: LD_INT 1
85318: NEG
85319: PUSH
85320: LD_INT 2
85322: NEG
85323: PUSH
85324: EMPTY
85325: LIST
85326: LIST
85327: PUSH
85328: LD_INT 0
85330: PUSH
85331: LD_INT 2
85333: NEG
85334: PUSH
85335: EMPTY
85336: LIST
85337: LIST
85338: PUSH
85339: LD_INT 1
85341: PUSH
85342: LD_INT 1
85344: NEG
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: LD_INT 2
85352: PUSH
85353: LD_INT 0
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 2
85362: PUSH
85363: LD_INT 1
85365: PUSH
85366: EMPTY
85367: LIST
85368: LIST
85369: PUSH
85370: LD_INT 2
85372: PUSH
85373: LD_INT 2
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: PUSH
85380: LD_INT 1
85382: PUSH
85383: LD_INT 2
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PUSH
85390: LD_INT 0
85392: PUSH
85393: LD_INT 2
85395: PUSH
85396: EMPTY
85397: LIST
85398: LIST
85399: PUSH
85400: LD_INT 1
85402: NEG
85403: PUSH
85404: LD_INT 1
85406: PUSH
85407: EMPTY
85408: LIST
85409: LIST
85410: PUSH
85411: LD_INT 2
85413: NEG
85414: PUSH
85415: LD_INT 0
85417: PUSH
85418: EMPTY
85419: LIST
85420: LIST
85421: PUSH
85422: LD_INT 2
85424: NEG
85425: PUSH
85426: LD_INT 1
85428: NEG
85429: PUSH
85430: EMPTY
85431: LIST
85432: LIST
85433: PUSH
85434: LD_INT 2
85436: NEG
85437: PUSH
85438: LD_INT 2
85440: NEG
85441: PUSH
85442: EMPTY
85443: LIST
85444: LIST
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: LIST
85450: LIST
85451: LIST
85452: LIST
85453: LIST
85454: LIST
85455: LIST
85456: LIST
85457: LIST
85458: LIST
85459: LIST
85460: LIST
85461: LIST
85462: LIST
85463: LIST
85464: LIST
85465: LIST
85466: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
85467: LD_ADDR_VAR 0 22
85471: PUSH
85472: LD_INT 0
85474: PUSH
85475: LD_INT 0
85477: PUSH
85478: EMPTY
85479: LIST
85480: LIST
85481: PUSH
85482: LD_INT 0
85484: PUSH
85485: LD_INT 1
85487: NEG
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: LD_INT 1
85495: PUSH
85496: LD_INT 0
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PUSH
85503: LD_INT 1
85505: PUSH
85506: LD_INT 1
85508: PUSH
85509: EMPTY
85510: LIST
85511: LIST
85512: PUSH
85513: LD_INT 0
85515: PUSH
85516: LD_INT 1
85518: PUSH
85519: EMPTY
85520: LIST
85521: LIST
85522: PUSH
85523: LD_INT 1
85525: NEG
85526: PUSH
85527: LD_INT 0
85529: PUSH
85530: EMPTY
85531: LIST
85532: LIST
85533: PUSH
85534: LD_INT 1
85536: NEG
85537: PUSH
85538: LD_INT 1
85540: NEG
85541: PUSH
85542: EMPTY
85543: LIST
85544: LIST
85545: PUSH
85546: LD_INT 1
85548: NEG
85549: PUSH
85550: LD_INT 2
85552: NEG
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 0
85560: PUSH
85561: LD_INT 2
85563: NEG
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 1
85571: PUSH
85572: LD_INT 1
85574: NEG
85575: PUSH
85576: EMPTY
85577: LIST
85578: LIST
85579: PUSH
85580: LD_INT 2
85582: PUSH
85583: LD_INT 0
85585: PUSH
85586: EMPTY
85587: LIST
85588: LIST
85589: PUSH
85590: LD_INT 2
85592: PUSH
85593: LD_INT 1
85595: PUSH
85596: EMPTY
85597: LIST
85598: LIST
85599: PUSH
85600: LD_INT 2
85602: PUSH
85603: LD_INT 2
85605: PUSH
85606: EMPTY
85607: LIST
85608: LIST
85609: PUSH
85610: LD_INT 1
85612: PUSH
85613: LD_INT 2
85615: PUSH
85616: EMPTY
85617: LIST
85618: LIST
85619: PUSH
85620: LD_INT 0
85622: PUSH
85623: LD_INT 2
85625: PUSH
85626: EMPTY
85627: LIST
85628: LIST
85629: PUSH
85630: LD_INT 1
85632: NEG
85633: PUSH
85634: LD_INT 1
85636: PUSH
85637: EMPTY
85638: LIST
85639: LIST
85640: PUSH
85641: LD_INT 2
85643: NEG
85644: PUSH
85645: LD_INT 0
85647: PUSH
85648: EMPTY
85649: LIST
85650: LIST
85651: PUSH
85652: LD_INT 2
85654: NEG
85655: PUSH
85656: LD_INT 1
85658: NEG
85659: PUSH
85660: EMPTY
85661: LIST
85662: LIST
85663: PUSH
85664: LD_INT 2
85666: NEG
85667: PUSH
85668: LD_INT 2
85670: NEG
85671: PUSH
85672: EMPTY
85673: LIST
85674: LIST
85675: PUSH
85676: EMPTY
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: LIST
85684: LIST
85685: LIST
85686: LIST
85687: LIST
85688: LIST
85689: LIST
85690: LIST
85691: LIST
85692: LIST
85693: LIST
85694: LIST
85695: LIST
85696: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
85697: LD_ADDR_VAR 0 23
85701: PUSH
85702: LD_INT 0
85704: PUSH
85705: LD_INT 0
85707: PUSH
85708: EMPTY
85709: LIST
85710: LIST
85711: PUSH
85712: LD_INT 0
85714: PUSH
85715: LD_INT 1
85717: NEG
85718: PUSH
85719: EMPTY
85720: LIST
85721: LIST
85722: PUSH
85723: LD_INT 1
85725: PUSH
85726: LD_INT 0
85728: PUSH
85729: EMPTY
85730: LIST
85731: LIST
85732: PUSH
85733: LD_INT 1
85735: PUSH
85736: LD_INT 1
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: PUSH
85743: LD_INT 0
85745: PUSH
85746: LD_INT 1
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: PUSH
85753: LD_INT 1
85755: NEG
85756: PUSH
85757: LD_INT 0
85759: PUSH
85760: EMPTY
85761: LIST
85762: LIST
85763: PUSH
85764: LD_INT 1
85766: NEG
85767: PUSH
85768: LD_INT 1
85770: NEG
85771: PUSH
85772: EMPTY
85773: LIST
85774: LIST
85775: PUSH
85776: LD_INT 1
85778: NEG
85779: PUSH
85780: LD_INT 2
85782: NEG
85783: PUSH
85784: EMPTY
85785: LIST
85786: LIST
85787: PUSH
85788: LD_INT 0
85790: PUSH
85791: LD_INT 2
85793: NEG
85794: PUSH
85795: EMPTY
85796: LIST
85797: LIST
85798: PUSH
85799: LD_INT 1
85801: PUSH
85802: LD_INT 1
85804: NEG
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 2
85812: PUSH
85813: LD_INT 0
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 2
85822: PUSH
85823: LD_INT 1
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: LD_INT 2
85832: PUSH
85833: LD_INT 2
85835: PUSH
85836: EMPTY
85837: LIST
85838: LIST
85839: PUSH
85840: LD_INT 1
85842: PUSH
85843: LD_INT 2
85845: PUSH
85846: EMPTY
85847: LIST
85848: LIST
85849: PUSH
85850: LD_INT 0
85852: PUSH
85853: LD_INT 2
85855: PUSH
85856: EMPTY
85857: LIST
85858: LIST
85859: PUSH
85860: LD_INT 1
85862: NEG
85863: PUSH
85864: LD_INT 1
85866: PUSH
85867: EMPTY
85868: LIST
85869: LIST
85870: PUSH
85871: LD_INT 2
85873: NEG
85874: PUSH
85875: LD_INT 0
85877: PUSH
85878: EMPTY
85879: LIST
85880: LIST
85881: PUSH
85882: LD_INT 2
85884: NEG
85885: PUSH
85886: LD_INT 1
85888: NEG
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PUSH
85894: LD_INT 2
85896: NEG
85897: PUSH
85898: LD_INT 2
85900: NEG
85901: PUSH
85902: EMPTY
85903: LIST
85904: LIST
85905: PUSH
85906: LD_INT 2
85908: NEG
85909: PUSH
85910: LD_INT 3
85912: NEG
85913: PUSH
85914: EMPTY
85915: LIST
85916: LIST
85917: PUSH
85918: LD_INT 1
85920: NEG
85921: PUSH
85922: LD_INT 3
85924: NEG
85925: PUSH
85926: EMPTY
85927: LIST
85928: LIST
85929: PUSH
85930: LD_INT 1
85932: PUSH
85933: LD_INT 2
85935: NEG
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PUSH
85941: LD_INT 2
85943: PUSH
85944: LD_INT 1
85946: NEG
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: LIST
85956: LIST
85957: LIST
85958: LIST
85959: LIST
85960: LIST
85961: LIST
85962: LIST
85963: LIST
85964: LIST
85965: LIST
85966: LIST
85967: LIST
85968: LIST
85969: LIST
85970: LIST
85971: LIST
85972: LIST
85973: LIST
85974: LIST
85975: LIST
85976: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
85977: LD_ADDR_VAR 0 24
85981: PUSH
85982: LD_INT 0
85984: PUSH
85985: LD_INT 0
85987: PUSH
85988: EMPTY
85989: LIST
85990: LIST
85991: PUSH
85992: LD_INT 0
85994: PUSH
85995: LD_INT 1
85997: NEG
85998: PUSH
85999: EMPTY
86000: LIST
86001: LIST
86002: PUSH
86003: LD_INT 1
86005: PUSH
86006: LD_INT 0
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: PUSH
86013: LD_INT 1
86015: PUSH
86016: LD_INT 1
86018: PUSH
86019: EMPTY
86020: LIST
86021: LIST
86022: PUSH
86023: LD_INT 0
86025: PUSH
86026: LD_INT 1
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: PUSH
86033: LD_INT 1
86035: NEG
86036: PUSH
86037: LD_INT 0
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: LD_INT 1
86046: NEG
86047: PUSH
86048: LD_INT 1
86050: NEG
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: PUSH
86056: LD_INT 1
86058: NEG
86059: PUSH
86060: LD_INT 2
86062: NEG
86063: PUSH
86064: EMPTY
86065: LIST
86066: LIST
86067: PUSH
86068: LD_INT 0
86070: PUSH
86071: LD_INT 2
86073: NEG
86074: PUSH
86075: EMPTY
86076: LIST
86077: LIST
86078: PUSH
86079: LD_INT 1
86081: PUSH
86082: LD_INT 1
86084: NEG
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: PUSH
86090: LD_INT 2
86092: PUSH
86093: LD_INT 0
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 2
86102: PUSH
86103: LD_INT 1
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 2
86112: PUSH
86113: LD_INT 2
86115: PUSH
86116: EMPTY
86117: LIST
86118: LIST
86119: PUSH
86120: LD_INT 1
86122: PUSH
86123: LD_INT 2
86125: PUSH
86126: EMPTY
86127: LIST
86128: LIST
86129: PUSH
86130: LD_INT 0
86132: PUSH
86133: LD_INT 2
86135: PUSH
86136: EMPTY
86137: LIST
86138: LIST
86139: PUSH
86140: LD_INT 1
86142: NEG
86143: PUSH
86144: LD_INT 1
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: LD_INT 2
86153: NEG
86154: PUSH
86155: LD_INT 0
86157: PUSH
86158: EMPTY
86159: LIST
86160: LIST
86161: PUSH
86162: LD_INT 2
86164: NEG
86165: PUSH
86166: LD_INT 1
86168: NEG
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: LD_INT 2
86176: NEG
86177: PUSH
86178: LD_INT 2
86180: NEG
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 1
86188: PUSH
86189: LD_INT 2
86191: NEG
86192: PUSH
86193: EMPTY
86194: LIST
86195: LIST
86196: PUSH
86197: LD_INT 2
86199: PUSH
86200: LD_INT 1
86202: NEG
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: PUSH
86208: LD_INT 3
86210: PUSH
86211: LD_INT 1
86213: PUSH
86214: EMPTY
86215: LIST
86216: LIST
86217: PUSH
86218: LD_INT 3
86220: PUSH
86221: LD_INT 2
86223: PUSH
86224: EMPTY
86225: LIST
86226: LIST
86227: PUSH
86228: EMPTY
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: LIST
86249: LIST
86250: LIST
86251: LIST
86252: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
86253: LD_ADDR_VAR 0 25
86257: PUSH
86258: LD_INT 0
86260: PUSH
86261: LD_INT 0
86263: PUSH
86264: EMPTY
86265: LIST
86266: LIST
86267: PUSH
86268: LD_INT 0
86270: PUSH
86271: LD_INT 1
86273: NEG
86274: PUSH
86275: EMPTY
86276: LIST
86277: LIST
86278: PUSH
86279: LD_INT 1
86281: PUSH
86282: LD_INT 0
86284: PUSH
86285: EMPTY
86286: LIST
86287: LIST
86288: PUSH
86289: LD_INT 1
86291: PUSH
86292: LD_INT 1
86294: PUSH
86295: EMPTY
86296: LIST
86297: LIST
86298: PUSH
86299: LD_INT 0
86301: PUSH
86302: LD_INT 1
86304: PUSH
86305: EMPTY
86306: LIST
86307: LIST
86308: PUSH
86309: LD_INT 1
86311: NEG
86312: PUSH
86313: LD_INT 0
86315: PUSH
86316: EMPTY
86317: LIST
86318: LIST
86319: PUSH
86320: LD_INT 1
86322: NEG
86323: PUSH
86324: LD_INT 1
86326: NEG
86327: PUSH
86328: EMPTY
86329: LIST
86330: LIST
86331: PUSH
86332: LD_INT 1
86334: NEG
86335: PUSH
86336: LD_INT 2
86338: NEG
86339: PUSH
86340: EMPTY
86341: LIST
86342: LIST
86343: PUSH
86344: LD_INT 0
86346: PUSH
86347: LD_INT 2
86349: NEG
86350: PUSH
86351: EMPTY
86352: LIST
86353: LIST
86354: PUSH
86355: LD_INT 1
86357: PUSH
86358: LD_INT 1
86360: NEG
86361: PUSH
86362: EMPTY
86363: LIST
86364: LIST
86365: PUSH
86366: LD_INT 2
86368: PUSH
86369: LD_INT 0
86371: PUSH
86372: EMPTY
86373: LIST
86374: LIST
86375: PUSH
86376: LD_INT 2
86378: PUSH
86379: LD_INT 1
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PUSH
86386: LD_INT 2
86388: PUSH
86389: LD_INT 2
86391: PUSH
86392: EMPTY
86393: LIST
86394: LIST
86395: PUSH
86396: LD_INT 1
86398: PUSH
86399: LD_INT 2
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 0
86408: PUSH
86409: LD_INT 2
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 1
86418: NEG
86419: PUSH
86420: LD_INT 1
86422: PUSH
86423: EMPTY
86424: LIST
86425: LIST
86426: PUSH
86427: LD_INT 2
86429: NEG
86430: PUSH
86431: LD_INT 0
86433: PUSH
86434: EMPTY
86435: LIST
86436: LIST
86437: PUSH
86438: LD_INT 2
86440: NEG
86441: PUSH
86442: LD_INT 1
86444: NEG
86445: PUSH
86446: EMPTY
86447: LIST
86448: LIST
86449: PUSH
86450: LD_INT 2
86452: NEG
86453: PUSH
86454: LD_INT 2
86456: NEG
86457: PUSH
86458: EMPTY
86459: LIST
86460: LIST
86461: PUSH
86462: LD_INT 3
86464: PUSH
86465: LD_INT 1
86467: PUSH
86468: EMPTY
86469: LIST
86470: LIST
86471: PUSH
86472: LD_INT 3
86474: PUSH
86475: LD_INT 2
86477: PUSH
86478: EMPTY
86479: LIST
86480: LIST
86481: PUSH
86482: LD_INT 2
86484: PUSH
86485: LD_INT 3
86487: PUSH
86488: EMPTY
86489: LIST
86490: LIST
86491: PUSH
86492: LD_INT 1
86494: PUSH
86495: LD_INT 3
86497: PUSH
86498: EMPTY
86499: LIST
86500: LIST
86501: PUSH
86502: EMPTY
86503: LIST
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
86527: LD_ADDR_VAR 0 26
86531: PUSH
86532: LD_INT 0
86534: PUSH
86535: LD_INT 0
86537: PUSH
86538: EMPTY
86539: LIST
86540: LIST
86541: PUSH
86542: LD_INT 0
86544: PUSH
86545: LD_INT 1
86547: NEG
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: PUSH
86553: LD_INT 1
86555: PUSH
86556: LD_INT 0
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: PUSH
86563: LD_INT 1
86565: PUSH
86566: LD_INT 1
86568: PUSH
86569: EMPTY
86570: LIST
86571: LIST
86572: PUSH
86573: LD_INT 0
86575: PUSH
86576: LD_INT 1
86578: PUSH
86579: EMPTY
86580: LIST
86581: LIST
86582: PUSH
86583: LD_INT 1
86585: NEG
86586: PUSH
86587: LD_INT 0
86589: PUSH
86590: EMPTY
86591: LIST
86592: LIST
86593: PUSH
86594: LD_INT 1
86596: NEG
86597: PUSH
86598: LD_INT 1
86600: NEG
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 1
86608: NEG
86609: PUSH
86610: LD_INT 2
86612: NEG
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PUSH
86618: LD_INT 0
86620: PUSH
86621: LD_INT 2
86623: NEG
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: LD_INT 1
86631: PUSH
86632: LD_INT 1
86634: NEG
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: PUSH
86640: LD_INT 2
86642: PUSH
86643: LD_INT 0
86645: PUSH
86646: EMPTY
86647: LIST
86648: LIST
86649: PUSH
86650: LD_INT 2
86652: PUSH
86653: LD_INT 1
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: PUSH
86660: LD_INT 2
86662: PUSH
86663: LD_INT 2
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: PUSH
86670: LD_INT 1
86672: PUSH
86673: LD_INT 2
86675: PUSH
86676: EMPTY
86677: LIST
86678: LIST
86679: PUSH
86680: LD_INT 0
86682: PUSH
86683: LD_INT 2
86685: PUSH
86686: EMPTY
86687: LIST
86688: LIST
86689: PUSH
86690: LD_INT 1
86692: NEG
86693: PUSH
86694: LD_INT 1
86696: PUSH
86697: EMPTY
86698: LIST
86699: LIST
86700: PUSH
86701: LD_INT 2
86703: NEG
86704: PUSH
86705: LD_INT 0
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: PUSH
86712: LD_INT 2
86714: NEG
86715: PUSH
86716: LD_INT 1
86718: NEG
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: PUSH
86724: LD_INT 2
86726: NEG
86727: PUSH
86728: LD_INT 2
86730: NEG
86731: PUSH
86732: EMPTY
86733: LIST
86734: LIST
86735: PUSH
86736: LD_INT 2
86738: PUSH
86739: LD_INT 3
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: PUSH
86746: LD_INT 1
86748: PUSH
86749: LD_INT 3
86751: PUSH
86752: EMPTY
86753: LIST
86754: LIST
86755: PUSH
86756: LD_INT 1
86758: NEG
86759: PUSH
86760: LD_INT 2
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: LD_INT 2
86769: NEG
86770: PUSH
86771: LD_INT 1
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: LIST
86782: LIST
86783: LIST
86784: LIST
86785: LIST
86786: LIST
86787: LIST
86788: LIST
86789: LIST
86790: LIST
86791: LIST
86792: LIST
86793: LIST
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: LIST
86800: LIST
86801: LIST
86802: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
86803: LD_ADDR_VAR 0 27
86807: PUSH
86808: LD_INT 0
86810: PUSH
86811: LD_INT 0
86813: PUSH
86814: EMPTY
86815: LIST
86816: LIST
86817: PUSH
86818: LD_INT 0
86820: PUSH
86821: LD_INT 1
86823: NEG
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: PUSH
86829: LD_INT 1
86831: PUSH
86832: LD_INT 0
86834: PUSH
86835: EMPTY
86836: LIST
86837: LIST
86838: PUSH
86839: LD_INT 1
86841: PUSH
86842: LD_INT 1
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: LD_INT 0
86851: PUSH
86852: LD_INT 1
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 1
86861: NEG
86862: PUSH
86863: LD_INT 0
86865: PUSH
86866: EMPTY
86867: LIST
86868: LIST
86869: PUSH
86870: LD_INT 1
86872: NEG
86873: PUSH
86874: LD_INT 1
86876: NEG
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: PUSH
86882: LD_INT 1
86884: NEG
86885: PUSH
86886: LD_INT 2
86888: NEG
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PUSH
86894: LD_INT 0
86896: PUSH
86897: LD_INT 2
86899: NEG
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: PUSH
86905: LD_INT 1
86907: PUSH
86908: LD_INT 1
86910: NEG
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: PUSH
86916: LD_INT 2
86918: PUSH
86919: LD_INT 0
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: PUSH
86926: LD_INT 2
86928: PUSH
86929: LD_INT 1
86931: PUSH
86932: EMPTY
86933: LIST
86934: LIST
86935: PUSH
86936: LD_INT 2
86938: PUSH
86939: LD_INT 2
86941: PUSH
86942: EMPTY
86943: LIST
86944: LIST
86945: PUSH
86946: LD_INT 1
86948: PUSH
86949: LD_INT 2
86951: PUSH
86952: EMPTY
86953: LIST
86954: LIST
86955: PUSH
86956: LD_INT 0
86958: PUSH
86959: LD_INT 2
86961: PUSH
86962: EMPTY
86963: LIST
86964: LIST
86965: PUSH
86966: LD_INT 1
86968: NEG
86969: PUSH
86970: LD_INT 1
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: LD_INT 2
86979: NEG
86980: PUSH
86981: LD_INT 0
86983: PUSH
86984: EMPTY
86985: LIST
86986: LIST
86987: PUSH
86988: LD_INT 2
86990: NEG
86991: PUSH
86992: LD_INT 1
86994: NEG
86995: PUSH
86996: EMPTY
86997: LIST
86998: LIST
86999: PUSH
87000: LD_INT 2
87002: NEG
87003: PUSH
87004: LD_INT 2
87006: NEG
87007: PUSH
87008: EMPTY
87009: LIST
87010: LIST
87011: PUSH
87012: LD_INT 1
87014: NEG
87015: PUSH
87016: LD_INT 2
87018: PUSH
87019: EMPTY
87020: LIST
87021: LIST
87022: PUSH
87023: LD_INT 2
87025: NEG
87026: PUSH
87027: LD_INT 1
87029: PUSH
87030: EMPTY
87031: LIST
87032: LIST
87033: PUSH
87034: LD_INT 3
87036: NEG
87037: PUSH
87038: LD_INT 1
87040: NEG
87041: PUSH
87042: EMPTY
87043: LIST
87044: LIST
87045: PUSH
87046: LD_INT 3
87048: NEG
87049: PUSH
87050: LD_INT 2
87052: NEG
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: PUSH
87058: EMPTY
87059: LIST
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
87083: LD_ADDR_VAR 0 28
87087: PUSH
87088: LD_INT 0
87090: PUSH
87091: LD_INT 0
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: PUSH
87098: LD_INT 0
87100: PUSH
87101: LD_INT 1
87103: NEG
87104: PUSH
87105: EMPTY
87106: LIST
87107: LIST
87108: PUSH
87109: LD_INT 1
87111: PUSH
87112: LD_INT 0
87114: PUSH
87115: EMPTY
87116: LIST
87117: LIST
87118: PUSH
87119: LD_INT 1
87121: PUSH
87122: LD_INT 1
87124: PUSH
87125: EMPTY
87126: LIST
87127: LIST
87128: PUSH
87129: LD_INT 0
87131: PUSH
87132: LD_INT 1
87134: PUSH
87135: EMPTY
87136: LIST
87137: LIST
87138: PUSH
87139: LD_INT 1
87141: NEG
87142: PUSH
87143: LD_INT 0
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 1
87152: NEG
87153: PUSH
87154: LD_INT 1
87156: NEG
87157: PUSH
87158: EMPTY
87159: LIST
87160: LIST
87161: PUSH
87162: LD_INT 1
87164: NEG
87165: PUSH
87166: LD_INT 2
87168: NEG
87169: PUSH
87170: EMPTY
87171: LIST
87172: LIST
87173: PUSH
87174: LD_INT 0
87176: PUSH
87177: LD_INT 2
87179: NEG
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: LD_INT 1
87187: PUSH
87188: LD_INT 1
87190: NEG
87191: PUSH
87192: EMPTY
87193: LIST
87194: LIST
87195: PUSH
87196: LD_INT 2
87198: PUSH
87199: LD_INT 0
87201: PUSH
87202: EMPTY
87203: LIST
87204: LIST
87205: PUSH
87206: LD_INT 2
87208: PUSH
87209: LD_INT 1
87211: PUSH
87212: EMPTY
87213: LIST
87214: LIST
87215: PUSH
87216: LD_INT 2
87218: PUSH
87219: LD_INT 2
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: PUSH
87226: LD_INT 1
87228: PUSH
87229: LD_INT 2
87231: PUSH
87232: EMPTY
87233: LIST
87234: LIST
87235: PUSH
87236: LD_INT 0
87238: PUSH
87239: LD_INT 2
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: PUSH
87246: LD_INT 1
87248: NEG
87249: PUSH
87250: LD_INT 1
87252: PUSH
87253: EMPTY
87254: LIST
87255: LIST
87256: PUSH
87257: LD_INT 2
87259: NEG
87260: PUSH
87261: LD_INT 0
87263: PUSH
87264: EMPTY
87265: LIST
87266: LIST
87267: PUSH
87268: LD_INT 2
87270: NEG
87271: PUSH
87272: LD_INT 1
87274: NEG
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 2
87282: NEG
87283: PUSH
87284: LD_INT 2
87286: NEG
87287: PUSH
87288: EMPTY
87289: LIST
87290: LIST
87291: PUSH
87292: LD_INT 2
87294: NEG
87295: PUSH
87296: LD_INT 3
87298: NEG
87299: PUSH
87300: EMPTY
87301: LIST
87302: LIST
87303: PUSH
87304: LD_INT 1
87306: NEG
87307: PUSH
87308: LD_INT 3
87310: NEG
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 3
87318: NEG
87319: PUSH
87320: LD_INT 1
87322: NEG
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PUSH
87328: LD_INT 3
87330: NEG
87331: PUSH
87332: LD_INT 2
87334: NEG
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: EMPTY
87341: LIST
87342: LIST
87343: LIST
87344: LIST
87345: LIST
87346: LIST
87347: LIST
87348: LIST
87349: LIST
87350: LIST
87351: LIST
87352: LIST
87353: LIST
87354: LIST
87355: LIST
87356: LIST
87357: LIST
87358: LIST
87359: LIST
87360: LIST
87361: LIST
87362: LIST
87363: LIST
87364: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87365: LD_ADDR_VAR 0 29
87369: PUSH
87370: LD_INT 0
87372: PUSH
87373: LD_INT 0
87375: PUSH
87376: EMPTY
87377: LIST
87378: LIST
87379: PUSH
87380: LD_INT 0
87382: PUSH
87383: LD_INT 1
87385: NEG
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: PUSH
87391: LD_INT 1
87393: PUSH
87394: LD_INT 0
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: PUSH
87401: LD_INT 1
87403: PUSH
87404: LD_INT 1
87406: PUSH
87407: EMPTY
87408: LIST
87409: LIST
87410: PUSH
87411: LD_INT 0
87413: PUSH
87414: LD_INT 1
87416: PUSH
87417: EMPTY
87418: LIST
87419: LIST
87420: PUSH
87421: LD_INT 1
87423: NEG
87424: PUSH
87425: LD_INT 0
87427: PUSH
87428: EMPTY
87429: LIST
87430: LIST
87431: PUSH
87432: LD_INT 1
87434: NEG
87435: PUSH
87436: LD_INT 1
87438: NEG
87439: PUSH
87440: EMPTY
87441: LIST
87442: LIST
87443: PUSH
87444: LD_INT 1
87446: NEG
87447: PUSH
87448: LD_INT 2
87450: NEG
87451: PUSH
87452: EMPTY
87453: LIST
87454: LIST
87455: PUSH
87456: LD_INT 0
87458: PUSH
87459: LD_INT 2
87461: NEG
87462: PUSH
87463: EMPTY
87464: LIST
87465: LIST
87466: PUSH
87467: LD_INT 1
87469: PUSH
87470: LD_INT 1
87472: NEG
87473: PUSH
87474: EMPTY
87475: LIST
87476: LIST
87477: PUSH
87478: LD_INT 2
87480: PUSH
87481: LD_INT 0
87483: PUSH
87484: EMPTY
87485: LIST
87486: LIST
87487: PUSH
87488: LD_INT 2
87490: PUSH
87491: LD_INT 1
87493: PUSH
87494: EMPTY
87495: LIST
87496: LIST
87497: PUSH
87498: LD_INT 1
87500: PUSH
87501: LD_INT 2
87503: PUSH
87504: EMPTY
87505: LIST
87506: LIST
87507: PUSH
87508: LD_INT 0
87510: PUSH
87511: LD_INT 2
87513: PUSH
87514: EMPTY
87515: LIST
87516: LIST
87517: PUSH
87518: LD_INT 1
87520: NEG
87521: PUSH
87522: LD_INT 1
87524: PUSH
87525: EMPTY
87526: LIST
87527: LIST
87528: PUSH
87529: LD_INT 2
87531: NEG
87532: PUSH
87533: LD_INT 1
87535: NEG
87536: PUSH
87537: EMPTY
87538: LIST
87539: LIST
87540: PUSH
87541: LD_INT 2
87543: NEG
87544: PUSH
87545: LD_INT 2
87547: NEG
87548: PUSH
87549: EMPTY
87550: LIST
87551: LIST
87552: PUSH
87553: LD_INT 2
87555: NEG
87556: PUSH
87557: LD_INT 3
87559: NEG
87560: PUSH
87561: EMPTY
87562: LIST
87563: LIST
87564: PUSH
87565: LD_INT 2
87567: PUSH
87568: LD_INT 1
87570: NEG
87571: PUSH
87572: EMPTY
87573: LIST
87574: LIST
87575: PUSH
87576: LD_INT 3
87578: PUSH
87579: LD_INT 1
87581: PUSH
87582: EMPTY
87583: LIST
87584: LIST
87585: PUSH
87586: LD_INT 1
87588: PUSH
87589: LD_INT 3
87591: PUSH
87592: EMPTY
87593: LIST
87594: LIST
87595: PUSH
87596: LD_INT 1
87598: NEG
87599: PUSH
87600: LD_INT 2
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: PUSH
87607: LD_INT 3
87609: NEG
87610: PUSH
87611: LD_INT 2
87613: NEG
87614: PUSH
87615: EMPTY
87616: LIST
87617: LIST
87618: PUSH
87619: EMPTY
87620: LIST
87621: LIST
87622: LIST
87623: LIST
87624: LIST
87625: LIST
87626: LIST
87627: LIST
87628: LIST
87629: LIST
87630: LIST
87631: LIST
87632: LIST
87633: LIST
87634: LIST
87635: LIST
87636: LIST
87637: LIST
87638: LIST
87639: LIST
87640: LIST
87641: LIST
87642: LIST
87643: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
87644: LD_ADDR_VAR 0 30
87648: PUSH
87649: LD_INT 0
87651: PUSH
87652: LD_INT 0
87654: PUSH
87655: EMPTY
87656: LIST
87657: LIST
87658: PUSH
87659: LD_INT 0
87661: PUSH
87662: LD_INT 1
87664: NEG
87665: PUSH
87666: EMPTY
87667: LIST
87668: LIST
87669: PUSH
87670: LD_INT 1
87672: PUSH
87673: LD_INT 0
87675: PUSH
87676: EMPTY
87677: LIST
87678: LIST
87679: PUSH
87680: LD_INT 1
87682: PUSH
87683: LD_INT 1
87685: PUSH
87686: EMPTY
87687: LIST
87688: LIST
87689: PUSH
87690: LD_INT 0
87692: PUSH
87693: LD_INT 1
87695: PUSH
87696: EMPTY
87697: LIST
87698: LIST
87699: PUSH
87700: LD_INT 1
87702: NEG
87703: PUSH
87704: LD_INT 0
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 1
87713: NEG
87714: PUSH
87715: LD_INT 1
87717: NEG
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: PUSH
87723: LD_INT 1
87725: NEG
87726: PUSH
87727: LD_INT 2
87729: NEG
87730: PUSH
87731: EMPTY
87732: LIST
87733: LIST
87734: PUSH
87735: LD_INT 0
87737: PUSH
87738: LD_INT 2
87740: NEG
87741: PUSH
87742: EMPTY
87743: LIST
87744: LIST
87745: PUSH
87746: LD_INT 1
87748: PUSH
87749: LD_INT 1
87751: NEG
87752: PUSH
87753: EMPTY
87754: LIST
87755: LIST
87756: PUSH
87757: LD_INT 2
87759: PUSH
87760: LD_INT 0
87762: PUSH
87763: EMPTY
87764: LIST
87765: LIST
87766: PUSH
87767: LD_INT 2
87769: PUSH
87770: LD_INT 1
87772: PUSH
87773: EMPTY
87774: LIST
87775: LIST
87776: PUSH
87777: LD_INT 2
87779: PUSH
87780: LD_INT 2
87782: PUSH
87783: EMPTY
87784: LIST
87785: LIST
87786: PUSH
87787: LD_INT 1
87789: PUSH
87790: LD_INT 2
87792: PUSH
87793: EMPTY
87794: LIST
87795: LIST
87796: PUSH
87797: LD_INT 1
87799: NEG
87800: PUSH
87801: LD_INT 1
87803: PUSH
87804: EMPTY
87805: LIST
87806: LIST
87807: PUSH
87808: LD_INT 2
87810: NEG
87811: PUSH
87812: LD_INT 0
87814: PUSH
87815: EMPTY
87816: LIST
87817: LIST
87818: PUSH
87819: LD_INT 2
87821: NEG
87822: PUSH
87823: LD_INT 1
87825: NEG
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: PUSH
87831: LD_INT 1
87833: NEG
87834: PUSH
87835: LD_INT 3
87837: NEG
87838: PUSH
87839: EMPTY
87840: LIST
87841: LIST
87842: PUSH
87843: LD_INT 1
87845: PUSH
87846: LD_INT 2
87848: NEG
87849: PUSH
87850: EMPTY
87851: LIST
87852: LIST
87853: PUSH
87854: LD_INT 3
87856: PUSH
87857: LD_INT 2
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: LD_INT 2
87866: PUSH
87867: LD_INT 3
87869: PUSH
87870: EMPTY
87871: LIST
87872: LIST
87873: PUSH
87874: LD_INT 2
87876: NEG
87877: PUSH
87878: LD_INT 1
87880: PUSH
87881: EMPTY
87882: LIST
87883: LIST
87884: PUSH
87885: LD_INT 3
87887: NEG
87888: PUSH
87889: LD_INT 1
87891: NEG
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: LIST
87908: LIST
87909: LIST
87910: LIST
87911: LIST
87912: LIST
87913: LIST
87914: LIST
87915: LIST
87916: LIST
87917: LIST
87918: LIST
87919: LIST
87920: LIST
87921: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
87922: LD_ADDR_VAR 0 31
87926: PUSH
87927: LD_INT 0
87929: PUSH
87930: LD_INT 0
87932: PUSH
87933: EMPTY
87934: LIST
87935: LIST
87936: PUSH
87937: LD_INT 0
87939: PUSH
87940: LD_INT 1
87942: NEG
87943: PUSH
87944: EMPTY
87945: LIST
87946: LIST
87947: PUSH
87948: LD_INT 1
87950: PUSH
87951: LD_INT 0
87953: PUSH
87954: EMPTY
87955: LIST
87956: LIST
87957: PUSH
87958: LD_INT 1
87960: PUSH
87961: LD_INT 1
87963: PUSH
87964: EMPTY
87965: LIST
87966: LIST
87967: PUSH
87968: LD_INT 0
87970: PUSH
87971: LD_INT 1
87973: PUSH
87974: EMPTY
87975: LIST
87976: LIST
87977: PUSH
87978: LD_INT 1
87980: NEG
87981: PUSH
87982: LD_INT 0
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: PUSH
87989: LD_INT 1
87991: NEG
87992: PUSH
87993: LD_INT 1
87995: NEG
87996: PUSH
87997: EMPTY
87998: LIST
87999: LIST
88000: PUSH
88001: LD_INT 1
88003: NEG
88004: PUSH
88005: LD_INT 2
88007: NEG
88008: PUSH
88009: EMPTY
88010: LIST
88011: LIST
88012: PUSH
88013: LD_INT 1
88015: PUSH
88016: LD_INT 1
88018: NEG
88019: PUSH
88020: EMPTY
88021: LIST
88022: LIST
88023: PUSH
88024: LD_INT 2
88026: PUSH
88027: LD_INT 0
88029: PUSH
88030: EMPTY
88031: LIST
88032: LIST
88033: PUSH
88034: LD_INT 2
88036: PUSH
88037: LD_INT 1
88039: PUSH
88040: EMPTY
88041: LIST
88042: LIST
88043: PUSH
88044: LD_INT 2
88046: PUSH
88047: LD_INT 2
88049: PUSH
88050: EMPTY
88051: LIST
88052: LIST
88053: PUSH
88054: LD_INT 1
88056: PUSH
88057: LD_INT 2
88059: PUSH
88060: EMPTY
88061: LIST
88062: LIST
88063: PUSH
88064: LD_INT 0
88066: PUSH
88067: LD_INT 2
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: PUSH
88074: LD_INT 1
88076: NEG
88077: PUSH
88078: LD_INT 1
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: LD_INT 2
88087: NEG
88088: PUSH
88089: LD_INT 1
88091: NEG
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: PUSH
88097: LD_INT 2
88099: NEG
88100: PUSH
88101: LD_INT 2
88103: NEG
88104: PUSH
88105: EMPTY
88106: LIST
88107: LIST
88108: PUSH
88109: LD_INT 2
88111: NEG
88112: PUSH
88113: LD_INT 3
88115: NEG
88116: PUSH
88117: EMPTY
88118: LIST
88119: LIST
88120: PUSH
88121: LD_INT 2
88123: PUSH
88124: LD_INT 1
88126: NEG
88127: PUSH
88128: EMPTY
88129: LIST
88130: LIST
88131: PUSH
88132: LD_INT 3
88134: PUSH
88135: LD_INT 1
88137: PUSH
88138: EMPTY
88139: LIST
88140: LIST
88141: PUSH
88142: LD_INT 1
88144: PUSH
88145: LD_INT 3
88147: PUSH
88148: EMPTY
88149: LIST
88150: LIST
88151: PUSH
88152: LD_INT 1
88154: NEG
88155: PUSH
88156: LD_INT 2
88158: PUSH
88159: EMPTY
88160: LIST
88161: LIST
88162: PUSH
88163: LD_INT 3
88165: NEG
88166: PUSH
88167: LD_INT 2
88169: NEG
88170: PUSH
88171: EMPTY
88172: LIST
88173: LIST
88174: PUSH
88175: EMPTY
88176: LIST
88177: LIST
88178: LIST
88179: LIST
88180: LIST
88181: LIST
88182: LIST
88183: LIST
88184: LIST
88185: LIST
88186: LIST
88187: LIST
88188: LIST
88189: LIST
88190: LIST
88191: LIST
88192: LIST
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88200: LD_ADDR_VAR 0 32
88204: PUSH
88205: LD_INT 0
88207: PUSH
88208: LD_INT 0
88210: PUSH
88211: EMPTY
88212: LIST
88213: LIST
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: LD_INT 1
88220: NEG
88221: PUSH
88222: EMPTY
88223: LIST
88224: LIST
88225: PUSH
88226: LD_INT 1
88228: PUSH
88229: LD_INT 0
88231: PUSH
88232: EMPTY
88233: LIST
88234: LIST
88235: PUSH
88236: LD_INT 1
88238: PUSH
88239: LD_INT 1
88241: PUSH
88242: EMPTY
88243: LIST
88244: LIST
88245: PUSH
88246: LD_INT 0
88248: PUSH
88249: LD_INT 1
88251: PUSH
88252: EMPTY
88253: LIST
88254: LIST
88255: PUSH
88256: LD_INT 1
88258: NEG
88259: PUSH
88260: LD_INT 0
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 1
88269: NEG
88270: PUSH
88271: LD_INT 1
88273: NEG
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: PUSH
88279: LD_INT 1
88281: NEG
88282: PUSH
88283: LD_INT 2
88285: NEG
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: PUSH
88291: LD_INT 0
88293: PUSH
88294: LD_INT 2
88296: NEG
88297: PUSH
88298: EMPTY
88299: LIST
88300: LIST
88301: PUSH
88302: LD_INT 1
88304: PUSH
88305: LD_INT 1
88307: NEG
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: LD_INT 2
88315: PUSH
88316: LD_INT 1
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: LD_INT 2
88325: PUSH
88326: LD_INT 2
88328: PUSH
88329: EMPTY
88330: LIST
88331: LIST
88332: PUSH
88333: LD_INT 1
88335: PUSH
88336: LD_INT 2
88338: PUSH
88339: EMPTY
88340: LIST
88341: LIST
88342: PUSH
88343: LD_INT 0
88345: PUSH
88346: LD_INT 2
88348: PUSH
88349: EMPTY
88350: LIST
88351: LIST
88352: PUSH
88353: LD_INT 1
88355: NEG
88356: PUSH
88357: LD_INT 1
88359: PUSH
88360: EMPTY
88361: LIST
88362: LIST
88363: PUSH
88364: LD_INT 2
88366: NEG
88367: PUSH
88368: LD_INT 0
88370: PUSH
88371: EMPTY
88372: LIST
88373: LIST
88374: PUSH
88375: LD_INT 2
88377: NEG
88378: PUSH
88379: LD_INT 1
88381: NEG
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: PUSH
88387: LD_INT 1
88389: NEG
88390: PUSH
88391: LD_INT 3
88393: NEG
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: LD_INT 1
88401: PUSH
88402: LD_INT 2
88404: NEG
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 3
88412: PUSH
88413: LD_INT 2
88415: PUSH
88416: EMPTY
88417: LIST
88418: LIST
88419: PUSH
88420: LD_INT 2
88422: PUSH
88423: LD_INT 3
88425: PUSH
88426: EMPTY
88427: LIST
88428: LIST
88429: PUSH
88430: LD_INT 2
88432: NEG
88433: PUSH
88434: LD_INT 1
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: PUSH
88441: LD_INT 3
88443: NEG
88444: PUSH
88445: LD_INT 1
88447: NEG
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: EMPTY
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
88478: LD_ADDR_VAR 0 33
88482: PUSH
88483: LD_INT 0
88485: PUSH
88486: LD_INT 0
88488: PUSH
88489: EMPTY
88490: LIST
88491: LIST
88492: PUSH
88493: LD_INT 0
88495: PUSH
88496: LD_INT 1
88498: NEG
88499: PUSH
88500: EMPTY
88501: LIST
88502: LIST
88503: PUSH
88504: LD_INT 1
88506: PUSH
88507: LD_INT 0
88509: PUSH
88510: EMPTY
88511: LIST
88512: LIST
88513: PUSH
88514: LD_INT 1
88516: PUSH
88517: LD_INT 1
88519: PUSH
88520: EMPTY
88521: LIST
88522: LIST
88523: PUSH
88524: LD_INT 0
88526: PUSH
88527: LD_INT 1
88529: PUSH
88530: EMPTY
88531: LIST
88532: LIST
88533: PUSH
88534: LD_INT 1
88536: NEG
88537: PUSH
88538: LD_INT 0
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: LD_INT 1
88547: NEG
88548: PUSH
88549: LD_INT 1
88551: NEG
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: PUSH
88557: LD_INT 1
88559: NEG
88560: PUSH
88561: LD_INT 2
88563: NEG
88564: PUSH
88565: EMPTY
88566: LIST
88567: LIST
88568: PUSH
88569: LD_INT 1
88571: PUSH
88572: LD_INT 1
88574: NEG
88575: PUSH
88576: EMPTY
88577: LIST
88578: LIST
88579: PUSH
88580: LD_INT 2
88582: PUSH
88583: LD_INT 0
88585: PUSH
88586: EMPTY
88587: LIST
88588: LIST
88589: PUSH
88590: LD_INT 2
88592: PUSH
88593: LD_INT 1
88595: PUSH
88596: EMPTY
88597: LIST
88598: LIST
88599: PUSH
88600: LD_INT 1
88602: PUSH
88603: LD_INT 2
88605: PUSH
88606: EMPTY
88607: LIST
88608: LIST
88609: PUSH
88610: LD_INT 0
88612: PUSH
88613: LD_INT 2
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: PUSH
88620: LD_INT 1
88622: NEG
88623: PUSH
88624: LD_INT 1
88626: PUSH
88627: EMPTY
88628: LIST
88629: LIST
88630: PUSH
88631: LD_INT 2
88633: NEG
88634: PUSH
88635: LD_INT 0
88637: PUSH
88638: EMPTY
88639: LIST
88640: LIST
88641: PUSH
88642: LD_INT 2
88644: NEG
88645: PUSH
88646: LD_INT 1
88648: NEG
88649: PUSH
88650: EMPTY
88651: LIST
88652: LIST
88653: PUSH
88654: LD_INT 2
88656: NEG
88657: PUSH
88658: LD_INT 2
88660: NEG
88661: PUSH
88662: EMPTY
88663: LIST
88664: LIST
88665: PUSH
88666: LD_INT 2
88668: NEG
88669: PUSH
88670: LD_INT 3
88672: NEG
88673: PUSH
88674: EMPTY
88675: LIST
88676: LIST
88677: PUSH
88678: LD_INT 2
88680: PUSH
88681: LD_INT 1
88683: NEG
88684: PUSH
88685: EMPTY
88686: LIST
88687: LIST
88688: PUSH
88689: LD_INT 3
88691: PUSH
88692: LD_INT 1
88694: PUSH
88695: EMPTY
88696: LIST
88697: LIST
88698: PUSH
88699: LD_INT 1
88701: PUSH
88702: LD_INT 3
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: PUSH
88709: LD_INT 1
88711: NEG
88712: PUSH
88713: LD_INT 2
88715: PUSH
88716: EMPTY
88717: LIST
88718: LIST
88719: PUSH
88720: LD_INT 3
88722: NEG
88723: PUSH
88724: LD_INT 2
88726: NEG
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: LIST
88736: LIST
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: LIST
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: LIST
88755: LIST
88756: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
88757: LD_ADDR_VAR 0 34
88761: PUSH
88762: LD_INT 0
88764: PUSH
88765: LD_INT 0
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 0
88774: PUSH
88775: LD_INT 1
88777: NEG
88778: PUSH
88779: EMPTY
88780: LIST
88781: LIST
88782: PUSH
88783: LD_INT 1
88785: PUSH
88786: LD_INT 0
88788: PUSH
88789: EMPTY
88790: LIST
88791: LIST
88792: PUSH
88793: LD_INT 1
88795: PUSH
88796: LD_INT 1
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: PUSH
88803: LD_INT 0
88805: PUSH
88806: LD_INT 1
88808: PUSH
88809: EMPTY
88810: LIST
88811: LIST
88812: PUSH
88813: LD_INT 1
88815: NEG
88816: PUSH
88817: LD_INT 0
88819: PUSH
88820: EMPTY
88821: LIST
88822: LIST
88823: PUSH
88824: LD_INT 1
88826: NEG
88827: PUSH
88828: LD_INT 1
88830: NEG
88831: PUSH
88832: EMPTY
88833: LIST
88834: LIST
88835: PUSH
88836: LD_INT 1
88838: NEG
88839: PUSH
88840: LD_INT 2
88842: NEG
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 0
88850: PUSH
88851: LD_INT 2
88853: NEG
88854: PUSH
88855: EMPTY
88856: LIST
88857: LIST
88858: PUSH
88859: LD_INT 1
88861: PUSH
88862: LD_INT 1
88864: NEG
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 2
88872: PUSH
88873: LD_INT 1
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: LD_INT 2
88882: PUSH
88883: LD_INT 2
88885: PUSH
88886: EMPTY
88887: LIST
88888: LIST
88889: PUSH
88890: LD_INT 1
88892: PUSH
88893: LD_INT 2
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 1
88902: NEG
88903: PUSH
88904: LD_INT 1
88906: PUSH
88907: EMPTY
88908: LIST
88909: LIST
88910: PUSH
88911: LD_INT 2
88913: NEG
88914: PUSH
88915: LD_INT 0
88917: PUSH
88918: EMPTY
88919: LIST
88920: LIST
88921: PUSH
88922: LD_INT 2
88924: NEG
88925: PUSH
88926: LD_INT 1
88928: NEG
88929: PUSH
88930: EMPTY
88931: LIST
88932: LIST
88933: PUSH
88934: LD_INT 2
88936: NEG
88937: PUSH
88938: LD_INT 2
88940: NEG
88941: PUSH
88942: EMPTY
88943: LIST
88944: LIST
88945: PUSH
88946: LD_INT 1
88948: NEG
88949: PUSH
88950: LD_INT 3
88952: NEG
88953: PUSH
88954: EMPTY
88955: LIST
88956: LIST
88957: PUSH
88958: LD_INT 1
88960: PUSH
88961: LD_INT 2
88963: NEG
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: PUSH
88969: LD_INT 3
88971: PUSH
88972: LD_INT 2
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: PUSH
88979: LD_INT 2
88981: PUSH
88982: LD_INT 3
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PUSH
88989: LD_INT 2
88991: NEG
88992: PUSH
88993: LD_INT 1
88995: PUSH
88996: EMPTY
88997: LIST
88998: LIST
88999: PUSH
89000: LD_INT 3
89002: NEG
89003: PUSH
89004: LD_INT 1
89006: NEG
89007: PUSH
89008: EMPTY
89009: LIST
89010: LIST
89011: PUSH
89012: EMPTY
89013: LIST
89014: LIST
89015: LIST
89016: LIST
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: LIST
89034: LIST
89035: LIST
89036: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
89037: LD_ADDR_VAR 0 35
89041: PUSH
89042: LD_INT 0
89044: PUSH
89045: LD_INT 0
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 0
89054: PUSH
89055: LD_INT 1
89057: NEG
89058: PUSH
89059: EMPTY
89060: LIST
89061: LIST
89062: PUSH
89063: LD_INT 1
89065: PUSH
89066: LD_INT 0
89068: PUSH
89069: EMPTY
89070: LIST
89071: LIST
89072: PUSH
89073: LD_INT 1
89075: PUSH
89076: LD_INT 1
89078: PUSH
89079: EMPTY
89080: LIST
89081: LIST
89082: PUSH
89083: LD_INT 0
89085: PUSH
89086: LD_INT 1
89088: PUSH
89089: EMPTY
89090: LIST
89091: LIST
89092: PUSH
89093: LD_INT 1
89095: NEG
89096: PUSH
89097: LD_INT 0
89099: PUSH
89100: EMPTY
89101: LIST
89102: LIST
89103: PUSH
89104: LD_INT 1
89106: NEG
89107: PUSH
89108: LD_INT 1
89110: NEG
89111: PUSH
89112: EMPTY
89113: LIST
89114: LIST
89115: PUSH
89116: LD_INT 2
89118: PUSH
89119: LD_INT 1
89121: PUSH
89122: EMPTY
89123: LIST
89124: LIST
89125: PUSH
89126: LD_INT 2
89128: NEG
89129: PUSH
89130: LD_INT 1
89132: NEG
89133: PUSH
89134: EMPTY
89135: LIST
89136: LIST
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: LIST
89146: LIST
89147: LIST
89148: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
89149: LD_ADDR_VAR 0 36
89153: PUSH
89154: LD_INT 0
89156: PUSH
89157: LD_INT 0
89159: PUSH
89160: EMPTY
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 0
89166: PUSH
89167: LD_INT 1
89169: NEG
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: PUSH
89175: LD_INT 1
89177: PUSH
89178: LD_INT 0
89180: PUSH
89181: EMPTY
89182: LIST
89183: LIST
89184: PUSH
89185: LD_INT 1
89187: PUSH
89188: LD_INT 1
89190: PUSH
89191: EMPTY
89192: LIST
89193: LIST
89194: PUSH
89195: LD_INT 0
89197: PUSH
89198: LD_INT 1
89200: PUSH
89201: EMPTY
89202: LIST
89203: LIST
89204: PUSH
89205: LD_INT 1
89207: NEG
89208: PUSH
89209: LD_INT 0
89211: PUSH
89212: EMPTY
89213: LIST
89214: LIST
89215: PUSH
89216: LD_INT 1
89218: NEG
89219: PUSH
89220: LD_INT 1
89222: NEG
89223: PUSH
89224: EMPTY
89225: LIST
89226: LIST
89227: PUSH
89228: LD_INT 1
89230: NEG
89231: PUSH
89232: LD_INT 2
89234: NEG
89235: PUSH
89236: EMPTY
89237: LIST
89238: LIST
89239: PUSH
89240: LD_INT 1
89242: PUSH
89243: LD_INT 2
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
89261: LD_ADDR_VAR 0 37
89265: PUSH
89266: LD_INT 0
89268: PUSH
89269: LD_INT 0
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: PUSH
89276: LD_INT 0
89278: PUSH
89279: LD_INT 1
89281: NEG
89282: PUSH
89283: EMPTY
89284: LIST
89285: LIST
89286: PUSH
89287: LD_INT 1
89289: PUSH
89290: LD_INT 0
89292: PUSH
89293: EMPTY
89294: LIST
89295: LIST
89296: PUSH
89297: LD_INT 1
89299: PUSH
89300: LD_INT 1
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: PUSH
89307: LD_INT 0
89309: PUSH
89310: LD_INT 1
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: PUSH
89317: LD_INT 1
89319: NEG
89320: PUSH
89321: LD_INT 0
89323: PUSH
89324: EMPTY
89325: LIST
89326: LIST
89327: PUSH
89328: LD_INT 1
89330: NEG
89331: PUSH
89332: LD_INT 1
89334: NEG
89335: PUSH
89336: EMPTY
89337: LIST
89338: LIST
89339: PUSH
89340: LD_INT 1
89342: PUSH
89343: LD_INT 1
89345: NEG
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: PUSH
89351: LD_INT 1
89353: NEG
89354: PUSH
89355: LD_INT 1
89357: PUSH
89358: EMPTY
89359: LIST
89360: LIST
89361: PUSH
89362: EMPTY
89363: LIST
89364: LIST
89365: LIST
89366: LIST
89367: LIST
89368: LIST
89369: LIST
89370: LIST
89371: LIST
89372: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
89373: LD_ADDR_VAR 0 38
89377: PUSH
89378: LD_INT 0
89380: PUSH
89381: LD_INT 0
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: PUSH
89388: LD_INT 0
89390: PUSH
89391: LD_INT 1
89393: NEG
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: LD_INT 1
89401: PUSH
89402: LD_INT 0
89404: PUSH
89405: EMPTY
89406: LIST
89407: LIST
89408: PUSH
89409: LD_INT 1
89411: PUSH
89412: LD_INT 1
89414: PUSH
89415: EMPTY
89416: LIST
89417: LIST
89418: PUSH
89419: LD_INT 0
89421: PUSH
89422: LD_INT 1
89424: PUSH
89425: EMPTY
89426: LIST
89427: LIST
89428: PUSH
89429: LD_INT 1
89431: NEG
89432: PUSH
89433: LD_INT 0
89435: PUSH
89436: EMPTY
89437: LIST
89438: LIST
89439: PUSH
89440: LD_INT 1
89442: NEG
89443: PUSH
89444: LD_INT 1
89446: NEG
89447: PUSH
89448: EMPTY
89449: LIST
89450: LIST
89451: PUSH
89452: LD_INT 2
89454: PUSH
89455: LD_INT 1
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: PUSH
89462: LD_INT 2
89464: NEG
89465: PUSH
89466: LD_INT 1
89468: NEG
89469: PUSH
89470: EMPTY
89471: LIST
89472: LIST
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
89485: LD_ADDR_VAR 0 39
89489: PUSH
89490: LD_INT 0
89492: PUSH
89493: LD_INT 0
89495: PUSH
89496: EMPTY
89497: LIST
89498: LIST
89499: PUSH
89500: LD_INT 0
89502: PUSH
89503: LD_INT 1
89505: NEG
89506: PUSH
89507: EMPTY
89508: LIST
89509: LIST
89510: PUSH
89511: LD_INT 1
89513: PUSH
89514: LD_INT 0
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 1
89523: PUSH
89524: LD_INT 1
89526: PUSH
89527: EMPTY
89528: LIST
89529: LIST
89530: PUSH
89531: LD_INT 0
89533: PUSH
89534: LD_INT 1
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: LD_INT 1
89543: NEG
89544: PUSH
89545: LD_INT 0
89547: PUSH
89548: EMPTY
89549: LIST
89550: LIST
89551: PUSH
89552: LD_INT 1
89554: NEG
89555: PUSH
89556: LD_INT 1
89558: NEG
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: PUSH
89564: LD_INT 1
89566: NEG
89567: PUSH
89568: LD_INT 2
89570: NEG
89571: PUSH
89572: EMPTY
89573: LIST
89574: LIST
89575: PUSH
89576: LD_INT 1
89578: PUSH
89579: LD_INT 2
89581: PUSH
89582: EMPTY
89583: LIST
89584: LIST
89585: PUSH
89586: EMPTY
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: LIST
89596: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
89597: LD_ADDR_VAR 0 40
89601: PUSH
89602: LD_INT 0
89604: PUSH
89605: LD_INT 0
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: PUSH
89612: LD_INT 0
89614: PUSH
89615: LD_INT 1
89617: NEG
89618: PUSH
89619: EMPTY
89620: LIST
89621: LIST
89622: PUSH
89623: LD_INT 1
89625: PUSH
89626: LD_INT 0
89628: PUSH
89629: EMPTY
89630: LIST
89631: LIST
89632: PUSH
89633: LD_INT 1
89635: PUSH
89636: LD_INT 1
89638: PUSH
89639: EMPTY
89640: LIST
89641: LIST
89642: PUSH
89643: LD_INT 0
89645: PUSH
89646: LD_INT 1
89648: PUSH
89649: EMPTY
89650: LIST
89651: LIST
89652: PUSH
89653: LD_INT 1
89655: NEG
89656: PUSH
89657: LD_INT 0
89659: PUSH
89660: EMPTY
89661: LIST
89662: LIST
89663: PUSH
89664: LD_INT 1
89666: NEG
89667: PUSH
89668: LD_INT 1
89670: NEG
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 1
89678: PUSH
89679: LD_INT 1
89681: NEG
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 1
89689: NEG
89690: PUSH
89691: LD_INT 1
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: EMPTY
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89709: LD_ADDR_VAR 0 41
89713: PUSH
89714: LD_INT 0
89716: PUSH
89717: LD_INT 0
89719: PUSH
89720: EMPTY
89721: LIST
89722: LIST
89723: PUSH
89724: LD_INT 0
89726: PUSH
89727: LD_INT 1
89729: NEG
89730: PUSH
89731: EMPTY
89732: LIST
89733: LIST
89734: PUSH
89735: LD_INT 1
89737: PUSH
89738: LD_INT 0
89740: PUSH
89741: EMPTY
89742: LIST
89743: LIST
89744: PUSH
89745: LD_INT 1
89747: PUSH
89748: LD_INT 1
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: PUSH
89755: LD_INT 0
89757: PUSH
89758: LD_INT 1
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 1
89767: NEG
89768: PUSH
89769: LD_INT 0
89771: PUSH
89772: EMPTY
89773: LIST
89774: LIST
89775: PUSH
89776: LD_INT 1
89778: NEG
89779: PUSH
89780: LD_INT 1
89782: NEG
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: PUSH
89788: LD_INT 1
89790: NEG
89791: PUSH
89792: LD_INT 2
89794: NEG
89795: PUSH
89796: EMPTY
89797: LIST
89798: LIST
89799: PUSH
89800: LD_INT 1
89802: PUSH
89803: LD_INT 1
89805: NEG
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 2
89813: PUSH
89814: LD_INT 0
89816: PUSH
89817: EMPTY
89818: LIST
89819: LIST
89820: PUSH
89821: LD_INT 2
89823: PUSH
89824: LD_INT 1
89826: PUSH
89827: EMPTY
89828: LIST
89829: LIST
89830: PUSH
89831: LD_INT 2
89833: PUSH
89834: LD_INT 2
89836: PUSH
89837: EMPTY
89838: LIST
89839: LIST
89840: PUSH
89841: LD_INT 1
89843: PUSH
89844: LD_INT 2
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: PUSH
89851: LD_INT 1
89853: NEG
89854: PUSH
89855: LD_INT 1
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: PUSH
89862: LD_INT 2
89864: NEG
89865: PUSH
89866: LD_INT 0
89868: PUSH
89869: EMPTY
89870: LIST
89871: LIST
89872: PUSH
89873: LD_INT 2
89875: NEG
89876: PUSH
89877: LD_INT 1
89879: NEG
89880: PUSH
89881: EMPTY
89882: LIST
89883: LIST
89884: PUSH
89885: LD_INT 2
89887: NEG
89888: PUSH
89889: LD_INT 2
89891: NEG
89892: PUSH
89893: EMPTY
89894: LIST
89895: LIST
89896: PUSH
89897: LD_INT 2
89899: NEG
89900: PUSH
89901: LD_INT 3
89903: NEG
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: PUSH
89909: LD_INT 2
89911: PUSH
89912: LD_INT 1
89914: NEG
89915: PUSH
89916: EMPTY
89917: LIST
89918: LIST
89919: PUSH
89920: LD_INT 3
89922: PUSH
89923: LD_INT 0
89925: PUSH
89926: EMPTY
89927: LIST
89928: LIST
89929: PUSH
89930: LD_INT 3
89932: PUSH
89933: LD_INT 1
89935: PUSH
89936: EMPTY
89937: LIST
89938: LIST
89939: PUSH
89940: LD_INT 3
89942: PUSH
89943: LD_INT 2
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: PUSH
89950: LD_INT 3
89952: PUSH
89953: LD_INT 3
89955: PUSH
89956: EMPTY
89957: LIST
89958: LIST
89959: PUSH
89960: LD_INT 2
89962: PUSH
89963: LD_INT 3
89965: PUSH
89966: EMPTY
89967: LIST
89968: LIST
89969: PUSH
89970: LD_INT 2
89972: NEG
89973: PUSH
89974: LD_INT 1
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: PUSH
89981: LD_INT 3
89983: NEG
89984: PUSH
89985: LD_INT 0
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 3
89994: NEG
89995: PUSH
89996: LD_INT 1
89998: NEG
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PUSH
90004: LD_INT 3
90006: NEG
90007: PUSH
90008: LD_INT 2
90010: NEG
90011: PUSH
90012: EMPTY
90013: LIST
90014: LIST
90015: PUSH
90016: LD_INT 3
90018: NEG
90019: PUSH
90020: LD_INT 3
90022: NEG
90023: PUSH
90024: EMPTY
90025: LIST
90026: LIST
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90059: LD_ADDR_VAR 0 42
90063: PUSH
90064: LD_INT 0
90066: PUSH
90067: LD_INT 0
90069: PUSH
90070: EMPTY
90071: LIST
90072: LIST
90073: PUSH
90074: LD_INT 0
90076: PUSH
90077: LD_INT 1
90079: NEG
90080: PUSH
90081: EMPTY
90082: LIST
90083: LIST
90084: PUSH
90085: LD_INT 1
90087: PUSH
90088: LD_INT 0
90090: PUSH
90091: EMPTY
90092: LIST
90093: LIST
90094: PUSH
90095: LD_INT 1
90097: PUSH
90098: LD_INT 1
90100: PUSH
90101: EMPTY
90102: LIST
90103: LIST
90104: PUSH
90105: LD_INT 0
90107: PUSH
90108: LD_INT 1
90110: PUSH
90111: EMPTY
90112: LIST
90113: LIST
90114: PUSH
90115: LD_INT 1
90117: NEG
90118: PUSH
90119: LD_INT 0
90121: PUSH
90122: EMPTY
90123: LIST
90124: LIST
90125: PUSH
90126: LD_INT 1
90128: NEG
90129: PUSH
90130: LD_INT 1
90132: NEG
90133: PUSH
90134: EMPTY
90135: LIST
90136: LIST
90137: PUSH
90138: LD_INT 1
90140: NEG
90141: PUSH
90142: LD_INT 2
90144: NEG
90145: PUSH
90146: EMPTY
90147: LIST
90148: LIST
90149: PUSH
90150: LD_INT 0
90152: PUSH
90153: LD_INT 2
90155: NEG
90156: PUSH
90157: EMPTY
90158: LIST
90159: LIST
90160: PUSH
90161: LD_INT 1
90163: PUSH
90164: LD_INT 1
90166: NEG
90167: PUSH
90168: EMPTY
90169: LIST
90170: LIST
90171: PUSH
90172: LD_INT 2
90174: PUSH
90175: LD_INT 1
90177: PUSH
90178: EMPTY
90179: LIST
90180: LIST
90181: PUSH
90182: LD_INT 2
90184: PUSH
90185: LD_INT 2
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: PUSH
90192: LD_INT 1
90194: PUSH
90195: LD_INT 2
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: LD_INT 0
90204: PUSH
90205: LD_INT 2
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 1
90214: NEG
90215: PUSH
90216: LD_INT 1
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 2
90225: NEG
90226: PUSH
90227: LD_INT 1
90229: NEG
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 2
90237: NEG
90238: PUSH
90239: LD_INT 2
90241: NEG
90242: PUSH
90243: EMPTY
90244: LIST
90245: LIST
90246: PUSH
90247: LD_INT 2
90249: NEG
90250: PUSH
90251: LD_INT 3
90253: NEG
90254: PUSH
90255: EMPTY
90256: LIST
90257: LIST
90258: PUSH
90259: LD_INT 1
90261: NEG
90262: PUSH
90263: LD_INT 3
90265: NEG
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: PUSH
90271: LD_INT 0
90273: PUSH
90274: LD_INT 3
90276: NEG
90277: PUSH
90278: EMPTY
90279: LIST
90280: LIST
90281: PUSH
90282: LD_INT 1
90284: PUSH
90285: LD_INT 2
90287: NEG
90288: PUSH
90289: EMPTY
90290: LIST
90291: LIST
90292: PUSH
90293: LD_INT 3
90295: PUSH
90296: LD_INT 2
90298: PUSH
90299: EMPTY
90300: LIST
90301: LIST
90302: PUSH
90303: LD_INT 3
90305: PUSH
90306: LD_INT 3
90308: PUSH
90309: EMPTY
90310: LIST
90311: LIST
90312: PUSH
90313: LD_INT 2
90315: PUSH
90316: LD_INT 3
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: PUSH
90323: LD_INT 1
90325: PUSH
90326: LD_INT 3
90328: PUSH
90329: EMPTY
90330: LIST
90331: LIST
90332: PUSH
90333: LD_INT 0
90335: PUSH
90336: LD_INT 3
90338: PUSH
90339: EMPTY
90340: LIST
90341: LIST
90342: PUSH
90343: LD_INT 1
90345: NEG
90346: PUSH
90347: LD_INT 2
90349: PUSH
90350: EMPTY
90351: LIST
90352: LIST
90353: PUSH
90354: LD_INT 3
90356: NEG
90357: PUSH
90358: LD_INT 2
90360: NEG
90361: PUSH
90362: EMPTY
90363: LIST
90364: LIST
90365: PUSH
90366: LD_INT 3
90368: NEG
90369: PUSH
90370: LD_INT 3
90372: NEG
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: PUSH
90378: EMPTY
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: LIST
90396: LIST
90397: LIST
90398: LIST
90399: LIST
90400: LIST
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90409: LD_ADDR_VAR 0 43
90413: PUSH
90414: LD_INT 0
90416: PUSH
90417: LD_INT 0
90419: PUSH
90420: EMPTY
90421: LIST
90422: LIST
90423: PUSH
90424: LD_INT 0
90426: PUSH
90427: LD_INT 1
90429: NEG
90430: PUSH
90431: EMPTY
90432: LIST
90433: LIST
90434: PUSH
90435: LD_INT 1
90437: PUSH
90438: LD_INT 0
90440: PUSH
90441: EMPTY
90442: LIST
90443: LIST
90444: PUSH
90445: LD_INT 1
90447: PUSH
90448: LD_INT 1
90450: PUSH
90451: EMPTY
90452: LIST
90453: LIST
90454: PUSH
90455: LD_INT 0
90457: PUSH
90458: LD_INT 1
90460: PUSH
90461: EMPTY
90462: LIST
90463: LIST
90464: PUSH
90465: LD_INT 1
90467: NEG
90468: PUSH
90469: LD_INT 0
90471: PUSH
90472: EMPTY
90473: LIST
90474: LIST
90475: PUSH
90476: LD_INT 1
90478: NEG
90479: PUSH
90480: LD_INT 1
90482: NEG
90483: PUSH
90484: EMPTY
90485: LIST
90486: LIST
90487: PUSH
90488: LD_INT 1
90490: NEG
90491: PUSH
90492: LD_INT 2
90494: NEG
90495: PUSH
90496: EMPTY
90497: LIST
90498: LIST
90499: PUSH
90500: LD_INT 0
90502: PUSH
90503: LD_INT 2
90505: NEG
90506: PUSH
90507: EMPTY
90508: LIST
90509: LIST
90510: PUSH
90511: LD_INT 1
90513: PUSH
90514: LD_INT 1
90516: NEG
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PUSH
90522: LD_INT 2
90524: PUSH
90525: LD_INT 0
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: PUSH
90532: LD_INT 2
90534: PUSH
90535: LD_INT 1
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PUSH
90542: LD_INT 1
90544: PUSH
90545: LD_INT 2
90547: PUSH
90548: EMPTY
90549: LIST
90550: LIST
90551: PUSH
90552: LD_INT 0
90554: PUSH
90555: LD_INT 2
90557: PUSH
90558: EMPTY
90559: LIST
90560: LIST
90561: PUSH
90562: LD_INT 1
90564: NEG
90565: PUSH
90566: LD_INT 1
90568: PUSH
90569: EMPTY
90570: LIST
90571: LIST
90572: PUSH
90573: LD_INT 2
90575: NEG
90576: PUSH
90577: LD_INT 0
90579: PUSH
90580: EMPTY
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 2
90586: NEG
90587: PUSH
90588: LD_INT 1
90590: NEG
90591: PUSH
90592: EMPTY
90593: LIST
90594: LIST
90595: PUSH
90596: LD_INT 1
90598: NEG
90599: PUSH
90600: LD_INT 3
90602: NEG
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: PUSH
90608: LD_INT 0
90610: PUSH
90611: LD_INT 3
90613: NEG
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: LD_INT 1
90621: PUSH
90622: LD_INT 2
90624: NEG
90625: PUSH
90626: EMPTY
90627: LIST
90628: LIST
90629: PUSH
90630: LD_INT 2
90632: PUSH
90633: LD_INT 1
90635: NEG
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: LD_INT 3
90643: PUSH
90644: LD_INT 0
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: PUSH
90651: LD_INT 3
90653: PUSH
90654: LD_INT 1
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 1
90663: PUSH
90664: LD_INT 3
90666: PUSH
90667: EMPTY
90668: LIST
90669: LIST
90670: PUSH
90671: LD_INT 0
90673: PUSH
90674: LD_INT 3
90676: PUSH
90677: EMPTY
90678: LIST
90679: LIST
90680: PUSH
90681: LD_INT 1
90683: NEG
90684: PUSH
90685: LD_INT 2
90687: PUSH
90688: EMPTY
90689: LIST
90690: LIST
90691: PUSH
90692: LD_INT 2
90694: NEG
90695: PUSH
90696: LD_INT 1
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: LD_INT 3
90705: NEG
90706: PUSH
90707: LD_INT 0
90709: PUSH
90710: EMPTY
90711: LIST
90712: LIST
90713: PUSH
90714: LD_INT 3
90716: NEG
90717: PUSH
90718: LD_INT 1
90720: NEG
90721: PUSH
90722: EMPTY
90723: LIST
90724: LIST
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: LIST
90730: LIST
90731: LIST
90732: LIST
90733: LIST
90734: LIST
90735: LIST
90736: LIST
90737: LIST
90738: LIST
90739: LIST
90740: LIST
90741: LIST
90742: LIST
90743: LIST
90744: LIST
90745: LIST
90746: LIST
90747: LIST
90748: LIST
90749: LIST
90750: LIST
90751: LIST
90752: LIST
90753: LIST
90754: LIST
90755: LIST
90756: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90757: LD_ADDR_VAR 0 44
90761: PUSH
90762: LD_INT 0
90764: PUSH
90765: LD_INT 0
90767: PUSH
90768: EMPTY
90769: LIST
90770: LIST
90771: PUSH
90772: LD_INT 0
90774: PUSH
90775: LD_INT 1
90777: NEG
90778: PUSH
90779: EMPTY
90780: LIST
90781: LIST
90782: PUSH
90783: LD_INT 1
90785: PUSH
90786: LD_INT 0
90788: PUSH
90789: EMPTY
90790: LIST
90791: LIST
90792: PUSH
90793: LD_INT 1
90795: PUSH
90796: LD_INT 1
90798: PUSH
90799: EMPTY
90800: LIST
90801: LIST
90802: PUSH
90803: LD_INT 0
90805: PUSH
90806: LD_INT 1
90808: PUSH
90809: EMPTY
90810: LIST
90811: LIST
90812: PUSH
90813: LD_INT 1
90815: NEG
90816: PUSH
90817: LD_INT 0
90819: PUSH
90820: EMPTY
90821: LIST
90822: LIST
90823: PUSH
90824: LD_INT 1
90826: NEG
90827: PUSH
90828: LD_INT 1
90830: NEG
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 1
90838: NEG
90839: PUSH
90840: LD_INT 2
90842: NEG
90843: PUSH
90844: EMPTY
90845: LIST
90846: LIST
90847: PUSH
90848: LD_INT 1
90850: PUSH
90851: LD_INT 1
90853: NEG
90854: PUSH
90855: EMPTY
90856: LIST
90857: LIST
90858: PUSH
90859: LD_INT 2
90861: PUSH
90862: LD_INT 0
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: LD_INT 2
90871: PUSH
90872: LD_INT 1
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 2
90881: PUSH
90882: LD_INT 2
90884: PUSH
90885: EMPTY
90886: LIST
90887: LIST
90888: PUSH
90889: LD_INT 1
90891: PUSH
90892: LD_INT 2
90894: PUSH
90895: EMPTY
90896: LIST
90897: LIST
90898: PUSH
90899: LD_INT 1
90901: NEG
90902: PUSH
90903: LD_INT 1
90905: PUSH
90906: EMPTY
90907: LIST
90908: LIST
90909: PUSH
90910: LD_INT 2
90912: NEG
90913: PUSH
90914: LD_INT 0
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: PUSH
90921: LD_INT 2
90923: NEG
90924: PUSH
90925: LD_INT 1
90927: NEG
90928: PUSH
90929: EMPTY
90930: LIST
90931: LIST
90932: PUSH
90933: LD_INT 2
90935: NEG
90936: PUSH
90937: LD_INT 2
90939: NEG
90940: PUSH
90941: EMPTY
90942: LIST
90943: LIST
90944: PUSH
90945: LD_INT 2
90947: NEG
90948: PUSH
90949: LD_INT 3
90951: NEG
90952: PUSH
90953: EMPTY
90954: LIST
90955: LIST
90956: PUSH
90957: LD_INT 2
90959: PUSH
90960: LD_INT 1
90962: NEG
90963: PUSH
90964: EMPTY
90965: LIST
90966: LIST
90967: PUSH
90968: LD_INT 3
90970: PUSH
90971: LD_INT 0
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PUSH
90978: LD_INT 3
90980: PUSH
90981: LD_INT 1
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PUSH
90988: LD_INT 3
90990: PUSH
90991: LD_INT 2
90993: PUSH
90994: EMPTY
90995: LIST
90996: LIST
90997: PUSH
90998: LD_INT 3
91000: PUSH
91001: LD_INT 3
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 2
91010: PUSH
91011: LD_INT 3
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: PUSH
91018: LD_INT 2
91020: NEG
91021: PUSH
91022: LD_INT 1
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: LD_INT 3
91031: NEG
91032: PUSH
91033: LD_INT 0
91035: PUSH
91036: EMPTY
91037: LIST
91038: LIST
91039: PUSH
91040: LD_INT 3
91042: NEG
91043: PUSH
91044: LD_INT 1
91046: NEG
91047: PUSH
91048: EMPTY
91049: LIST
91050: LIST
91051: PUSH
91052: LD_INT 3
91054: NEG
91055: PUSH
91056: LD_INT 2
91058: NEG
91059: PUSH
91060: EMPTY
91061: LIST
91062: LIST
91063: PUSH
91064: LD_INT 3
91066: NEG
91067: PUSH
91068: LD_INT 3
91070: NEG
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: PUSH
91076: EMPTY
91077: LIST
91078: LIST
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: LIST
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: LIST
91106: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91107: LD_ADDR_VAR 0 45
91111: PUSH
91112: LD_INT 0
91114: PUSH
91115: LD_INT 0
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 0
91124: PUSH
91125: LD_INT 1
91127: NEG
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: PUSH
91133: LD_INT 1
91135: PUSH
91136: LD_INT 0
91138: PUSH
91139: EMPTY
91140: LIST
91141: LIST
91142: PUSH
91143: LD_INT 1
91145: PUSH
91146: LD_INT 1
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 0
91155: PUSH
91156: LD_INT 1
91158: PUSH
91159: EMPTY
91160: LIST
91161: LIST
91162: PUSH
91163: LD_INT 1
91165: NEG
91166: PUSH
91167: LD_INT 0
91169: PUSH
91170: EMPTY
91171: LIST
91172: LIST
91173: PUSH
91174: LD_INT 1
91176: NEG
91177: PUSH
91178: LD_INT 1
91180: NEG
91181: PUSH
91182: EMPTY
91183: LIST
91184: LIST
91185: PUSH
91186: LD_INT 1
91188: NEG
91189: PUSH
91190: LD_INT 2
91192: NEG
91193: PUSH
91194: EMPTY
91195: LIST
91196: LIST
91197: PUSH
91198: LD_INT 0
91200: PUSH
91201: LD_INT 2
91203: NEG
91204: PUSH
91205: EMPTY
91206: LIST
91207: LIST
91208: PUSH
91209: LD_INT 1
91211: PUSH
91212: LD_INT 1
91214: NEG
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: PUSH
91220: LD_INT 2
91222: PUSH
91223: LD_INT 1
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 2
91232: PUSH
91233: LD_INT 2
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: PUSH
91240: LD_INT 1
91242: PUSH
91243: LD_INT 2
91245: PUSH
91246: EMPTY
91247: LIST
91248: LIST
91249: PUSH
91250: LD_INT 0
91252: PUSH
91253: LD_INT 2
91255: PUSH
91256: EMPTY
91257: LIST
91258: LIST
91259: PUSH
91260: LD_INT 1
91262: NEG
91263: PUSH
91264: LD_INT 1
91266: PUSH
91267: EMPTY
91268: LIST
91269: LIST
91270: PUSH
91271: LD_INT 2
91273: NEG
91274: PUSH
91275: LD_INT 1
91277: NEG
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PUSH
91283: LD_INT 2
91285: NEG
91286: PUSH
91287: LD_INT 2
91289: NEG
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: PUSH
91295: LD_INT 2
91297: NEG
91298: PUSH
91299: LD_INT 3
91301: NEG
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 1
91309: NEG
91310: PUSH
91311: LD_INT 3
91313: NEG
91314: PUSH
91315: EMPTY
91316: LIST
91317: LIST
91318: PUSH
91319: LD_INT 0
91321: PUSH
91322: LD_INT 3
91324: NEG
91325: PUSH
91326: EMPTY
91327: LIST
91328: LIST
91329: PUSH
91330: LD_INT 1
91332: PUSH
91333: LD_INT 2
91335: NEG
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PUSH
91341: LD_INT 3
91343: PUSH
91344: LD_INT 2
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: PUSH
91351: LD_INT 3
91353: PUSH
91354: LD_INT 3
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: PUSH
91361: LD_INT 2
91363: PUSH
91364: LD_INT 3
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: LD_INT 1
91373: PUSH
91374: LD_INT 3
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PUSH
91381: LD_INT 0
91383: PUSH
91384: LD_INT 3
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: PUSH
91391: LD_INT 1
91393: NEG
91394: PUSH
91395: LD_INT 2
91397: PUSH
91398: EMPTY
91399: LIST
91400: LIST
91401: PUSH
91402: LD_INT 3
91404: NEG
91405: PUSH
91406: LD_INT 2
91408: NEG
91409: PUSH
91410: EMPTY
91411: LIST
91412: LIST
91413: PUSH
91414: LD_INT 3
91416: NEG
91417: PUSH
91418: LD_INT 3
91420: NEG
91421: PUSH
91422: EMPTY
91423: LIST
91424: LIST
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91457: LD_ADDR_VAR 0 46
91461: PUSH
91462: LD_INT 0
91464: PUSH
91465: LD_INT 0
91467: PUSH
91468: EMPTY
91469: LIST
91470: LIST
91471: PUSH
91472: LD_INT 0
91474: PUSH
91475: LD_INT 1
91477: NEG
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PUSH
91483: LD_INT 1
91485: PUSH
91486: LD_INT 0
91488: PUSH
91489: EMPTY
91490: LIST
91491: LIST
91492: PUSH
91493: LD_INT 1
91495: PUSH
91496: LD_INT 1
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: PUSH
91503: LD_INT 0
91505: PUSH
91506: LD_INT 1
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: PUSH
91513: LD_INT 1
91515: NEG
91516: PUSH
91517: LD_INT 0
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: PUSH
91524: LD_INT 1
91526: NEG
91527: PUSH
91528: LD_INT 1
91530: NEG
91531: PUSH
91532: EMPTY
91533: LIST
91534: LIST
91535: PUSH
91536: LD_INT 1
91538: NEG
91539: PUSH
91540: LD_INT 2
91542: NEG
91543: PUSH
91544: EMPTY
91545: LIST
91546: LIST
91547: PUSH
91548: LD_INT 0
91550: PUSH
91551: LD_INT 2
91553: NEG
91554: PUSH
91555: EMPTY
91556: LIST
91557: LIST
91558: PUSH
91559: LD_INT 1
91561: PUSH
91562: LD_INT 1
91564: NEG
91565: PUSH
91566: EMPTY
91567: LIST
91568: LIST
91569: PUSH
91570: LD_INT 2
91572: PUSH
91573: LD_INT 0
91575: PUSH
91576: EMPTY
91577: LIST
91578: LIST
91579: PUSH
91580: LD_INT 2
91582: PUSH
91583: LD_INT 1
91585: PUSH
91586: EMPTY
91587: LIST
91588: LIST
91589: PUSH
91590: LD_INT 1
91592: PUSH
91593: LD_INT 2
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: PUSH
91600: LD_INT 0
91602: PUSH
91603: LD_INT 2
91605: PUSH
91606: EMPTY
91607: LIST
91608: LIST
91609: PUSH
91610: LD_INT 1
91612: NEG
91613: PUSH
91614: LD_INT 1
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: PUSH
91621: LD_INT 2
91623: NEG
91624: PUSH
91625: LD_INT 0
91627: PUSH
91628: EMPTY
91629: LIST
91630: LIST
91631: PUSH
91632: LD_INT 2
91634: NEG
91635: PUSH
91636: LD_INT 1
91638: NEG
91639: PUSH
91640: EMPTY
91641: LIST
91642: LIST
91643: PUSH
91644: LD_INT 1
91646: NEG
91647: PUSH
91648: LD_INT 3
91650: NEG
91651: PUSH
91652: EMPTY
91653: LIST
91654: LIST
91655: PUSH
91656: LD_INT 0
91658: PUSH
91659: LD_INT 3
91661: NEG
91662: PUSH
91663: EMPTY
91664: LIST
91665: LIST
91666: PUSH
91667: LD_INT 1
91669: PUSH
91670: LD_INT 2
91672: NEG
91673: PUSH
91674: EMPTY
91675: LIST
91676: LIST
91677: PUSH
91678: LD_INT 2
91680: PUSH
91681: LD_INT 1
91683: NEG
91684: PUSH
91685: EMPTY
91686: LIST
91687: LIST
91688: PUSH
91689: LD_INT 3
91691: PUSH
91692: LD_INT 0
91694: PUSH
91695: EMPTY
91696: LIST
91697: LIST
91698: PUSH
91699: LD_INT 3
91701: PUSH
91702: LD_INT 1
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: PUSH
91709: LD_INT 1
91711: PUSH
91712: LD_INT 3
91714: PUSH
91715: EMPTY
91716: LIST
91717: LIST
91718: PUSH
91719: LD_INT 0
91721: PUSH
91722: LD_INT 3
91724: PUSH
91725: EMPTY
91726: LIST
91727: LIST
91728: PUSH
91729: LD_INT 1
91731: NEG
91732: PUSH
91733: LD_INT 2
91735: PUSH
91736: EMPTY
91737: LIST
91738: LIST
91739: PUSH
91740: LD_INT 2
91742: NEG
91743: PUSH
91744: LD_INT 1
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: PUSH
91751: LD_INT 3
91753: NEG
91754: PUSH
91755: LD_INT 0
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: LD_INT 3
91764: NEG
91765: PUSH
91766: LD_INT 1
91768: NEG
91769: PUSH
91770: EMPTY
91771: LIST
91772: LIST
91773: PUSH
91774: EMPTY
91775: LIST
91776: LIST
91777: LIST
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: LIST
91798: LIST
91799: LIST
91800: LIST
91801: LIST
91802: LIST
91803: LIST
91804: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91805: LD_ADDR_VAR 0 47
91809: PUSH
91810: LD_INT 0
91812: PUSH
91813: LD_INT 0
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: LD_INT 0
91822: PUSH
91823: LD_INT 1
91825: NEG
91826: PUSH
91827: EMPTY
91828: LIST
91829: LIST
91830: PUSH
91831: LD_INT 1
91833: PUSH
91834: LD_INT 0
91836: PUSH
91837: EMPTY
91838: LIST
91839: LIST
91840: PUSH
91841: LD_INT 1
91843: PUSH
91844: LD_INT 1
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: PUSH
91851: LD_INT 0
91853: PUSH
91854: LD_INT 1
91856: PUSH
91857: EMPTY
91858: LIST
91859: LIST
91860: PUSH
91861: LD_INT 1
91863: NEG
91864: PUSH
91865: LD_INT 0
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: PUSH
91872: LD_INT 1
91874: NEG
91875: PUSH
91876: LD_INT 1
91878: NEG
91879: PUSH
91880: EMPTY
91881: LIST
91882: LIST
91883: PUSH
91884: LD_INT 1
91886: NEG
91887: PUSH
91888: LD_INT 2
91890: NEG
91891: PUSH
91892: EMPTY
91893: LIST
91894: LIST
91895: PUSH
91896: LD_INT 0
91898: PUSH
91899: LD_INT 2
91901: NEG
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: LD_INT 1
91909: PUSH
91910: LD_INT 1
91912: NEG
91913: PUSH
91914: EMPTY
91915: LIST
91916: LIST
91917: PUSH
91918: LD_INT 2
91920: NEG
91921: PUSH
91922: LD_INT 1
91924: NEG
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: PUSH
91930: LD_INT 2
91932: NEG
91933: PUSH
91934: LD_INT 2
91936: NEG
91937: PUSH
91938: EMPTY
91939: LIST
91940: LIST
91941: PUSH
91942: EMPTY
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: LIST
91951: LIST
91952: LIST
91953: LIST
91954: LIST
91955: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
91956: LD_ADDR_VAR 0 48
91960: PUSH
91961: LD_INT 0
91963: PUSH
91964: LD_INT 0
91966: PUSH
91967: EMPTY
91968: LIST
91969: LIST
91970: PUSH
91971: LD_INT 0
91973: PUSH
91974: LD_INT 1
91976: NEG
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: PUSH
91982: LD_INT 1
91984: PUSH
91985: LD_INT 0
91987: PUSH
91988: EMPTY
91989: LIST
91990: LIST
91991: PUSH
91992: LD_INT 1
91994: PUSH
91995: LD_INT 1
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: PUSH
92002: LD_INT 0
92004: PUSH
92005: LD_INT 1
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: PUSH
92012: LD_INT 1
92014: NEG
92015: PUSH
92016: LD_INT 0
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 1
92025: NEG
92026: PUSH
92027: LD_INT 1
92029: NEG
92030: PUSH
92031: EMPTY
92032: LIST
92033: LIST
92034: PUSH
92035: LD_INT 1
92037: NEG
92038: PUSH
92039: LD_INT 2
92041: NEG
92042: PUSH
92043: EMPTY
92044: LIST
92045: LIST
92046: PUSH
92047: LD_INT 0
92049: PUSH
92050: LD_INT 2
92052: NEG
92053: PUSH
92054: EMPTY
92055: LIST
92056: LIST
92057: PUSH
92058: LD_INT 1
92060: PUSH
92061: LD_INT 1
92063: NEG
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: PUSH
92069: LD_INT 2
92071: PUSH
92072: LD_INT 0
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: PUSH
92079: LD_INT 2
92081: PUSH
92082: LD_INT 1
92084: PUSH
92085: EMPTY
92086: LIST
92087: LIST
92088: PUSH
92089: EMPTY
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: LIST
92095: LIST
92096: LIST
92097: LIST
92098: LIST
92099: LIST
92100: LIST
92101: LIST
92102: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92103: LD_ADDR_VAR 0 49
92107: PUSH
92108: LD_INT 0
92110: PUSH
92111: LD_INT 0
92113: PUSH
92114: EMPTY
92115: LIST
92116: LIST
92117: PUSH
92118: LD_INT 0
92120: PUSH
92121: LD_INT 1
92123: NEG
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: PUSH
92129: LD_INT 1
92131: PUSH
92132: LD_INT 0
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: LD_INT 1
92141: PUSH
92142: LD_INT 1
92144: PUSH
92145: EMPTY
92146: LIST
92147: LIST
92148: PUSH
92149: LD_INT 0
92151: PUSH
92152: LD_INT 1
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: LD_INT 1
92161: NEG
92162: PUSH
92163: LD_INT 0
92165: PUSH
92166: EMPTY
92167: LIST
92168: LIST
92169: PUSH
92170: LD_INT 1
92172: NEG
92173: PUSH
92174: LD_INT 1
92176: NEG
92177: PUSH
92178: EMPTY
92179: LIST
92180: LIST
92181: PUSH
92182: LD_INT 1
92184: PUSH
92185: LD_INT 1
92187: NEG
92188: PUSH
92189: EMPTY
92190: LIST
92191: LIST
92192: PUSH
92193: LD_INT 2
92195: PUSH
92196: LD_INT 0
92198: PUSH
92199: EMPTY
92200: LIST
92201: LIST
92202: PUSH
92203: LD_INT 2
92205: PUSH
92206: LD_INT 1
92208: PUSH
92209: EMPTY
92210: LIST
92211: LIST
92212: PUSH
92213: LD_INT 2
92215: PUSH
92216: LD_INT 2
92218: PUSH
92219: EMPTY
92220: LIST
92221: LIST
92222: PUSH
92223: LD_INT 1
92225: PUSH
92226: LD_INT 2
92228: PUSH
92229: EMPTY
92230: LIST
92231: LIST
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: LIST
92237: LIST
92238: LIST
92239: LIST
92240: LIST
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92247: LD_ADDR_VAR 0 50
92251: PUSH
92252: LD_INT 0
92254: PUSH
92255: LD_INT 0
92257: PUSH
92258: EMPTY
92259: LIST
92260: LIST
92261: PUSH
92262: LD_INT 0
92264: PUSH
92265: LD_INT 1
92267: NEG
92268: PUSH
92269: EMPTY
92270: LIST
92271: LIST
92272: PUSH
92273: LD_INT 1
92275: PUSH
92276: LD_INT 0
92278: PUSH
92279: EMPTY
92280: LIST
92281: LIST
92282: PUSH
92283: LD_INT 1
92285: PUSH
92286: LD_INT 1
92288: PUSH
92289: EMPTY
92290: LIST
92291: LIST
92292: PUSH
92293: LD_INT 0
92295: PUSH
92296: LD_INT 1
92298: PUSH
92299: EMPTY
92300: LIST
92301: LIST
92302: PUSH
92303: LD_INT 1
92305: NEG
92306: PUSH
92307: LD_INT 0
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: PUSH
92314: LD_INT 1
92316: NEG
92317: PUSH
92318: LD_INT 1
92320: NEG
92321: PUSH
92322: EMPTY
92323: LIST
92324: LIST
92325: PUSH
92326: LD_INT 2
92328: PUSH
92329: LD_INT 1
92331: PUSH
92332: EMPTY
92333: LIST
92334: LIST
92335: PUSH
92336: LD_INT 2
92338: PUSH
92339: LD_INT 2
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: PUSH
92346: LD_INT 1
92348: PUSH
92349: LD_INT 2
92351: PUSH
92352: EMPTY
92353: LIST
92354: LIST
92355: PUSH
92356: LD_INT 0
92358: PUSH
92359: LD_INT 2
92361: PUSH
92362: EMPTY
92363: LIST
92364: LIST
92365: PUSH
92366: LD_INT 1
92368: NEG
92369: PUSH
92370: LD_INT 1
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: PUSH
92377: EMPTY
92378: LIST
92379: LIST
92380: LIST
92381: LIST
92382: LIST
92383: LIST
92384: LIST
92385: LIST
92386: LIST
92387: LIST
92388: LIST
92389: LIST
92390: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92391: LD_ADDR_VAR 0 51
92395: PUSH
92396: LD_INT 0
92398: PUSH
92399: LD_INT 0
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: PUSH
92406: LD_INT 0
92408: PUSH
92409: LD_INT 1
92411: NEG
92412: PUSH
92413: EMPTY
92414: LIST
92415: LIST
92416: PUSH
92417: LD_INT 1
92419: PUSH
92420: LD_INT 0
92422: PUSH
92423: EMPTY
92424: LIST
92425: LIST
92426: PUSH
92427: LD_INT 1
92429: PUSH
92430: LD_INT 1
92432: PUSH
92433: EMPTY
92434: LIST
92435: LIST
92436: PUSH
92437: LD_INT 0
92439: PUSH
92440: LD_INT 1
92442: PUSH
92443: EMPTY
92444: LIST
92445: LIST
92446: PUSH
92447: LD_INT 1
92449: NEG
92450: PUSH
92451: LD_INT 0
92453: PUSH
92454: EMPTY
92455: LIST
92456: LIST
92457: PUSH
92458: LD_INT 1
92460: NEG
92461: PUSH
92462: LD_INT 1
92464: NEG
92465: PUSH
92466: EMPTY
92467: LIST
92468: LIST
92469: PUSH
92470: LD_INT 1
92472: PUSH
92473: LD_INT 2
92475: PUSH
92476: EMPTY
92477: LIST
92478: LIST
92479: PUSH
92480: LD_INT 0
92482: PUSH
92483: LD_INT 2
92485: PUSH
92486: EMPTY
92487: LIST
92488: LIST
92489: PUSH
92490: LD_INT 1
92492: NEG
92493: PUSH
92494: LD_INT 1
92496: PUSH
92497: EMPTY
92498: LIST
92499: LIST
92500: PUSH
92501: LD_INT 2
92503: NEG
92504: PUSH
92505: LD_INT 0
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 2
92514: NEG
92515: PUSH
92516: LD_INT 1
92518: NEG
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: EMPTY
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: LIST
92530: LIST
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: LIST
92537: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92538: LD_ADDR_VAR 0 52
92542: PUSH
92543: LD_INT 0
92545: PUSH
92546: LD_INT 0
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: LD_INT 0
92555: PUSH
92556: LD_INT 1
92558: NEG
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 1
92566: PUSH
92567: LD_INT 0
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: PUSH
92574: LD_INT 1
92576: PUSH
92577: LD_INT 1
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 0
92586: PUSH
92587: LD_INT 1
92589: PUSH
92590: EMPTY
92591: LIST
92592: LIST
92593: PUSH
92594: LD_INT 1
92596: NEG
92597: PUSH
92598: LD_INT 0
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 1
92607: NEG
92608: PUSH
92609: LD_INT 1
92611: NEG
92612: PUSH
92613: EMPTY
92614: LIST
92615: LIST
92616: PUSH
92617: LD_INT 1
92619: NEG
92620: PUSH
92621: LD_INT 2
92623: NEG
92624: PUSH
92625: EMPTY
92626: LIST
92627: LIST
92628: PUSH
92629: LD_INT 1
92631: NEG
92632: PUSH
92633: LD_INT 1
92635: PUSH
92636: EMPTY
92637: LIST
92638: LIST
92639: PUSH
92640: LD_INT 2
92642: NEG
92643: PUSH
92644: LD_INT 0
92646: PUSH
92647: EMPTY
92648: LIST
92649: LIST
92650: PUSH
92651: LD_INT 2
92653: NEG
92654: PUSH
92655: LD_INT 1
92657: NEG
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: PUSH
92663: LD_INT 2
92665: NEG
92666: PUSH
92667: LD_INT 2
92669: NEG
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: EMPTY
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92689: LD_ADDR_VAR 0 53
92693: PUSH
92694: LD_INT 0
92696: PUSH
92697: LD_INT 0
92699: PUSH
92700: EMPTY
92701: LIST
92702: LIST
92703: PUSH
92704: LD_INT 0
92706: PUSH
92707: LD_INT 1
92709: NEG
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: PUSH
92715: LD_INT 1
92717: PUSH
92718: LD_INT 0
92720: PUSH
92721: EMPTY
92722: LIST
92723: LIST
92724: PUSH
92725: LD_INT 1
92727: PUSH
92728: LD_INT 1
92730: PUSH
92731: EMPTY
92732: LIST
92733: LIST
92734: PUSH
92735: LD_INT 0
92737: PUSH
92738: LD_INT 1
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: LD_INT 1
92747: NEG
92748: PUSH
92749: LD_INT 0
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: PUSH
92756: LD_INT 1
92758: NEG
92759: PUSH
92760: LD_INT 1
92762: NEG
92763: PUSH
92764: EMPTY
92765: LIST
92766: LIST
92767: PUSH
92768: LD_INT 1
92770: NEG
92771: PUSH
92772: LD_INT 2
92774: NEG
92775: PUSH
92776: EMPTY
92777: LIST
92778: LIST
92779: PUSH
92780: LD_INT 0
92782: PUSH
92783: LD_INT 2
92785: NEG
92786: PUSH
92787: EMPTY
92788: LIST
92789: LIST
92790: PUSH
92791: LD_INT 1
92793: PUSH
92794: LD_INT 1
92796: NEG
92797: PUSH
92798: EMPTY
92799: LIST
92800: LIST
92801: PUSH
92802: LD_INT 2
92804: PUSH
92805: LD_INT 0
92807: PUSH
92808: EMPTY
92809: LIST
92810: LIST
92811: PUSH
92812: LD_INT 2
92814: PUSH
92815: LD_INT 1
92817: PUSH
92818: EMPTY
92819: LIST
92820: LIST
92821: PUSH
92822: LD_INT 2
92824: PUSH
92825: LD_INT 2
92827: PUSH
92828: EMPTY
92829: LIST
92830: LIST
92831: PUSH
92832: LD_INT 1
92834: PUSH
92835: LD_INT 2
92837: PUSH
92838: EMPTY
92839: LIST
92840: LIST
92841: PUSH
92842: LD_INT 0
92844: PUSH
92845: LD_INT 2
92847: PUSH
92848: EMPTY
92849: LIST
92850: LIST
92851: PUSH
92852: LD_INT 1
92854: NEG
92855: PUSH
92856: LD_INT 1
92858: PUSH
92859: EMPTY
92860: LIST
92861: LIST
92862: PUSH
92863: LD_INT 2
92865: NEG
92866: PUSH
92867: LD_INT 0
92869: PUSH
92870: EMPTY
92871: LIST
92872: LIST
92873: PUSH
92874: LD_INT 2
92876: NEG
92877: PUSH
92878: LD_INT 1
92880: NEG
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: PUSH
92886: LD_INT 2
92888: NEG
92889: PUSH
92890: LD_INT 2
92892: NEG
92893: PUSH
92894: EMPTY
92895: LIST
92896: LIST
92897: PUSH
92898: EMPTY
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92919: LD_ADDR_VAR 0 54
92923: PUSH
92924: LD_INT 0
92926: PUSH
92927: LD_INT 0
92929: PUSH
92930: EMPTY
92931: LIST
92932: LIST
92933: PUSH
92934: LD_INT 0
92936: PUSH
92937: LD_INT 1
92939: NEG
92940: PUSH
92941: EMPTY
92942: LIST
92943: LIST
92944: PUSH
92945: LD_INT 1
92947: PUSH
92948: LD_INT 0
92950: PUSH
92951: EMPTY
92952: LIST
92953: LIST
92954: PUSH
92955: LD_INT 1
92957: PUSH
92958: LD_INT 1
92960: PUSH
92961: EMPTY
92962: LIST
92963: LIST
92964: PUSH
92965: LD_INT 0
92967: PUSH
92968: LD_INT 1
92970: PUSH
92971: EMPTY
92972: LIST
92973: LIST
92974: PUSH
92975: LD_INT 1
92977: NEG
92978: PUSH
92979: LD_INT 0
92981: PUSH
92982: EMPTY
92983: LIST
92984: LIST
92985: PUSH
92986: LD_INT 1
92988: NEG
92989: PUSH
92990: LD_INT 1
92992: NEG
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: PUSH
92998: LD_INT 1
93000: NEG
93001: PUSH
93002: LD_INT 2
93004: NEG
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: PUSH
93010: LD_INT 0
93012: PUSH
93013: LD_INT 2
93015: NEG
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: PUSH
93021: LD_INT 1
93023: PUSH
93024: LD_INT 1
93026: NEG
93027: PUSH
93028: EMPTY
93029: LIST
93030: LIST
93031: PUSH
93032: LD_INT 2
93034: PUSH
93035: LD_INT 0
93037: PUSH
93038: EMPTY
93039: LIST
93040: LIST
93041: PUSH
93042: LD_INT 2
93044: PUSH
93045: LD_INT 1
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: LD_INT 2
93054: PUSH
93055: LD_INT 2
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: PUSH
93062: LD_INT 1
93064: PUSH
93065: LD_INT 2
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 0
93074: PUSH
93075: LD_INT 2
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: LD_INT 1
93084: NEG
93085: PUSH
93086: LD_INT 1
93088: PUSH
93089: EMPTY
93090: LIST
93091: LIST
93092: PUSH
93093: LD_INT 2
93095: NEG
93096: PUSH
93097: LD_INT 0
93099: PUSH
93100: EMPTY
93101: LIST
93102: LIST
93103: PUSH
93104: LD_INT 2
93106: NEG
93107: PUSH
93108: LD_INT 1
93110: NEG
93111: PUSH
93112: EMPTY
93113: LIST
93114: LIST
93115: PUSH
93116: LD_INT 2
93118: NEG
93119: PUSH
93120: LD_INT 2
93122: NEG
93123: PUSH
93124: EMPTY
93125: LIST
93126: LIST
93127: PUSH
93128: EMPTY
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: LIST
93147: LIST
93148: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93149: LD_ADDR_VAR 0 55
93153: PUSH
93154: LD_INT 0
93156: PUSH
93157: LD_INT 0
93159: PUSH
93160: EMPTY
93161: LIST
93162: LIST
93163: PUSH
93164: LD_INT 0
93166: PUSH
93167: LD_INT 1
93169: NEG
93170: PUSH
93171: EMPTY
93172: LIST
93173: LIST
93174: PUSH
93175: LD_INT 1
93177: PUSH
93178: LD_INT 0
93180: PUSH
93181: EMPTY
93182: LIST
93183: LIST
93184: PUSH
93185: LD_INT 1
93187: PUSH
93188: LD_INT 1
93190: PUSH
93191: EMPTY
93192: LIST
93193: LIST
93194: PUSH
93195: LD_INT 0
93197: PUSH
93198: LD_INT 1
93200: PUSH
93201: EMPTY
93202: LIST
93203: LIST
93204: PUSH
93205: LD_INT 1
93207: NEG
93208: PUSH
93209: LD_INT 0
93211: PUSH
93212: EMPTY
93213: LIST
93214: LIST
93215: PUSH
93216: LD_INT 1
93218: NEG
93219: PUSH
93220: LD_INT 1
93222: NEG
93223: PUSH
93224: EMPTY
93225: LIST
93226: LIST
93227: PUSH
93228: LD_INT 1
93230: NEG
93231: PUSH
93232: LD_INT 2
93234: NEG
93235: PUSH
93236: EMPTY
93237: LIST
93238: LIST
93239: PUSH
93240: LD_INT 0
93242: PUSH
93243: LD_INT 2
93245: NEG
93246: PUSH
93247: EMPTY
93248: LIST
93249: LIST
93250: PUSH
93251: LD_INT 1
93253: PUSH
93254: LD_INT 1
93256: NEG
93257: PUSH
93258: EMPTY
93259: LIST
93260: LIST
93261: PUSH
93262: LD_INT 2
93264: PUSH
93265: LD_INT 0
93267: PUSH
93268: EMPTY
93269: LIST
93270: LIST
93271: PUSH
93272: LD_INT 2
93274: PUSH
93275: LD_INT 1
93277: PUSH
93278: EMPTY
93279: LIST
93280: LIST
93281: PUSH
93282: LD_INT 2
93284: PUSH
93285: LD_INT 2
93287: PUSH
93288: EMPTY
93289: LIST
93290: LIST
93291: PUSH
93292: LD_INT 1
93294: PUSH
93295: LD_INT 2
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 0
93304: PUSH
93305: LD_INT 2
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: PUSH
93312: LD_INT 1
93314: NEG
93315: PUSH
93316: LD_INT 1
93318: PUSH
93319: EMPTY
93320: LIST
93321: LIST
93322: PUSH
93323: LD_INT 2
93325: NEG
93326: PUSH
93327: LD_INT 0
93329: PUSH
93330: EMPTY
93331: LIST
93332: LIST
93333: PUSH
93334: LD_INT 2
93336: NEG
93337: PUSH
93338: LD_INT 1
93340: NEG
93341: PUSH
93342: EMPTY
93343: LIST
93344: LIST
93345: PUSH
93346: LD_INT 2
93348: NEG
93349: PUSH
93350: LD_INT 2
93352: NEG
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: EMPTY
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93379: LD_ADDR_VAR 0 56
93383: PUSH
93384: LD_INT 0
93386: PUSH
93387: LD_INT 0
93389: PUSH
93390: EMPTY
93391: LIST
93392: LIST
93393: PUSH
93394: LD_INT 0
93396: PUSH
93397: LD_INT 1
93399: NEG
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: PUSH
93405: LD_INT 1
93407: PUSH
93408: LD_INT 0
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: PUSH
93415: LD_INT 1
93417: PUSH
93418: LD_INT 1
93420: PUSH
93421: EMPTY
93422: LIST
93423: LIST
93424: PUSH
93425: LD_INT 0
93427: PUSH
93428: LD_INT 1
93430: PUSH
93431: EMPTY
93432: LIST
93433: LIST
93434: PUSH
93435: LD_INT 1
93437: NEG
93438: PUSH
93439: LD_INT 0
93441: PUSH
93442: EMPTY
93443: LIST
93444: LIST
93445: PUSH
93446: LD_INT 1
93448: NEG
93449: PUSH
93450: LD_INT 1
93452: NEG
93453: PUSH
93454: EMPTY
93455: LIST
93456: LIST
93457: PUSH
93458: LD_INT 1
93460: NEG
93461: PUSH
93462: LD_INT 2
93464: NEG
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: PUSH
93470: LD_INT 0
93472: PUSH
93473: LD_INT 2
93475: NEG
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 1
93483: PUSH
93484: LD_INT 1
93486: NEG
93487: PUSH
93488: EMPTY
93489: LIST
93490: LIST
93491: PUSH
93492: LD_INT 2
93494: PUSH
93495: LD_INT 0
93497: PUSH
93498: EMPTY
93499: LIST
93500: LIST
93501: PUSH
93502: LD_INT 2
93504: PUSH
93505: LD_INT 1
93507: PUSH
93508: EMPTY
93509: LIST
93510: LIST
93511: PUSH
93512: LD_INT 2
93514: PUSH
93515: LD_INT 2
93517: PUSH
93518: EMPTY
93519: LIST
93520: LIST
93521: PUSH
93522: LD_INT 1
93524: PUSH
93525: LD_INT 2
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 0
93534: PUSH
93535: LD_INT 2
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: LD_INT 1
93544: NEG
93545: PUSH
93546: LD_INT 1
93548: PUSH
93549: EMPTY
93550: LIST
93551: LIST
93552: PUSH
93553: LD_INT 2
93555: NEG
93556: PUSH
93557: LD_INT 0
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 2
93566: NEG
93567: PUSH
93568: LD_INT 1
93570: NEG
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: LD_INT 2
93578: NEG
93579: PUSH
93580: LD_INT 2
93582: NEG
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: EMPTY
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: LIST
93608: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93609: LD_ADDR_VAR 0 57
93613: PUSH
93614: LD_INT 0
93616: PUSH
93617: LD_INT 0
93619: PUSH
93620: EMPTY
93621: LIST
93622: LIST
93623: PUSH
93624: LD_INT 0
93626: PUSH
93627: LD_INT 1
93629: NEG
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: PUSH
93635: LD_INT 1
93637: PUSH
93638: LD_INT 0
93640: PUSH
93641: EMPTY
93642: LIST
93643: LIST
93644: PUSH
93645: LD_INT 1
93647: PUSH
93648: LD_INT 1
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: PUSH
93655: LD_INT 0
93657: PUSH
93658: LD_INT 1
93660: PUSH
93661: EMPTY
93662: LIST
93663: LIST
93664: PUSH
93665: LD_INT 1
93667: NEG
93668: PUSH
93669: LD_INT 0
93671: PUSH
93672: EMPTY
93673: LIST
93674: LIST
93675: PUSH
93676: LD_INT 1
93678: NEG
93679: PUSH
93680: LD_INT 1
93682: NEG
93683: PUSH
93684: EMPTY
93685: LIST
93686: LIST
93687: PUSH
93688: LD_INT 1
93690: NEG
93691: PUSH
93692: LD_INT 2
93694: NEG
93695: PUSH
93696: EMPTY
93697: LIST
93698: LIST
93699: PUSH
93700: LD_INT 0
93702: PUSH
93703: LD_INT 2
93705: NEG
93706: PUSH
93707: EMPTY
93708: LIST
93709: LIST
93710: PUSH
93711: LD_INT 1
93713: PUSH
93714: LD_INT 1
93716: NEG
93717: PUSH
93718: EMPTY
93719: LIST
93720: LIST
93721: PUSH
93722: LD_INT 2
93724: PUSH
93725: LD_INT 0
93727: PUSH
93728: EMPTY
93729: LIST
93730: LIST
93731: PUSH
93732: LD_INT 2
93734: PUSH
93735: LD_INT 1
93737: PUSH
93738: EMPTY
93739: LIST
93740: LIST
93741: PUSH
93742: LD_INT 2
93744: PUSH
93745: LD_INT 2
93747: PUSH
93748: EMPTY
93749: LIST
93750: LIST
93751: PUSH
93752: LD_INT 1
93754: PUSH
93755: LD_INT 2
93757: PUSH
93758: EMPTY
93759: LIST
93760: LIST
93761: PUSH
93762: LD_INT 0
93764: PUSH
93765: LD_INT 2
93767: PUSH
93768: EMPTY
93769: LIST
93770: LIST
93771: PUSH
93772: LD_INT 1
93774: NEG
93775: PUSH
93776: LD_INT 1
93778: PUSH
93779: EMPTY
93780: LIST
93781: LIST
93782: PUSH
93783: LD_INT 2
93785: NEG
93786: PUSH
93787: LD_INT 0
93789: PUSH
93790: EMPTY
93791: LIST
93792: LIST
93793: PUSH
93794: LD_INT 2
93796: NEG
93797: PUSH
93798: LD_INT 1
93800: NEG
93801: PUSH
93802: EMPTY
93803: LIST
93804: LIST
93805: PUSH
93806: LD_INT 2
93808: NEG
93809: PUSH
93810: LD_INT 2
93812: NEG
93813: PUSH
93814: EMPTY
93815: LIST
93816: LIST
93817: PUSH
93818: EMPTY
93819: LIST
93820: LIST
93821: LIST
93822: LIST
93823: LIST
93824: LIST
93825: LIST
93826: LIST
93827: LIST
93828: LIST
93829: LIST
93830: LIST
93831: LIST
93832: LIST
93833: LIST
93834: LIST
93835: LIST
93836: LIST
93837: LIST
93838: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93839: LD_ADDR_VAR 0 58
93843: PUSH
93844: LD_INT 0
93846: PUSH
93847: LD_INT 0
93849: PUSH
93850: EMPTY
93851: LIST
93852: LIST
93853: PUSH
93854: LD_INT 0
93856: PUSH
93857: LD_INT 1
93859: NEG
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: LD_INT 1
93867: PUSH
93868: LD_INT 0
93870: PUSH
93871: EMPTY
93872: LIST
93873: LIST
93874: PUSH
93875: LD_INT 1
93877: PUSH
93878: LD_INT 1
93880: PUSH
93881: EMPTY
93882: LIST
93883: LIST
93884: PUSH
93885: LD_INT 0
93887: PUSH
93888: LD_INT 1
93890: PUSH
93891: EMPTY
93892: LIST
93893: LIST
93894: PUSH
93895: LD_INT 1
93897: NEG
93898: PUSH
93899: LD_INT 0
93901: PUSH
93902: EMPTY
93903: LIST
93904: LIST
93905: PUSH
93906: LD_INT 1
93908: NEG
93909: PUSH
93910: LD_INT 1
93912: NEG
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: PUSH
93918: LD_INT 1
93920: NEG
93921: PUSH
93922: LD_INT 2
93924: NEG
93925: PUSH
93926: EMPTY
93927: LIST
93928: LIST
93929: PUSH
93930: LD_INT 0
93932: PUSH
93933: LD_INT 2
93935: NEG
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: LD_INT 1
93943: PUSH
93944: LD_INT 1
93946: NEG
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PUSH
93952: LD_INT 2
93954: PUSH
93955: LD_INT 0
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: LD_INT 2
93964: PUSH
93965: LD_INT 1
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: LD_INT 2
93974: PUSH
93975: LD_INT 2
93977: PUSH
93978: EMPTY
93979: LIST
93980: LIST
93981: PUSH
93982: LD_INT 1
93984: PUSH
93985: LD_INT 2
93987: PUSH
93988: EMPTY
93989: LIST
93990: LIST
93991: PUSH
93992: LD_INT 0
93994: PUSH
93995: LD_INT 2
93997: PUSH
93998: EMPTY
93999: LIST
94000: LIST
94001: PUSH
94002: LD_INT 1
94004: NEG
94005: PUSH
94006: LD_INT 1
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: PUSH
94013: LD_INT 2
94015: NEG
94016: PUSH
94017: LD_INT 0
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: PUSH
94024: LD_INT 2
94026: NEG
94027: PUSH
94028: LD_INT 1
94030: NEG
94031: PUSH
94032: EMPTY
94033: LIST
94034: LIST
94035: PUSH
94036: LD_INT 2
94038: NEG
94039: PUSH
94040: LD_INT 2
94042: NEG
94043: PUSH
94044: EMPTY
94045: LIST
94046: LIST
94047: PUSH
94048: EMPTY
94049: LIST
94050: LIST
94051: LIST
94052: LIST
94053: LIST
94054: LIST
94055: LIST
94056: LIST
94057: LIST
94058: LIST
94059: LIST
94060: LIST
94061: LIST
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94069: LD_ADDR_VAR 0 59
94073: PUSH
94074: LD_INT 0
94076: PUSH
94077: LD_INT 0
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 0
94086: PUSH
94087: LD_INT 1
94089: NEG
94090: PUSH
94091: EMPTY
94092: LIST
94093: LIST
94094: PUSH
94095: LD_INT 1
94097: PUSH
94098: LD_INT 0
94100: PUSH
94101: EMPTY
94102: LIST
94103: LIST
94104: PUSH
94105: LD_INT 1
94107: PUSH
94108: LD_INT 1
94110: PUSH
94111: EMPTY
94112: LIST
94113: LIST
94114: PUSH
94115: LD_INT 0
94117: PUSH
94118: LD_INT 1
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: PUSH
94125: LD_INT 1
94127: NEG
94128: PUSH
94129: LD_INT 0
94131: PUSH
94132: EMPTY
94133: LIST
94134: LIST
94135: PUSH
94136: LD_INT 1
94138: NEG
94139: PUSH
94140: LD_INT 1
94142: NEG
94143: PUSH
94144: EMPTY
94145: LIST
94146: LIST
94147: PUSH
94148: EMPTY
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94157: LD_ADDR_VAR 0 60
94161: PUSH
94162: LD_INT 0
94164: PUSH
94165: LD_INT 0
94167: PUSH
94168: EMPTY
94169: LIST
94170: LIST
94171: PUSH
94172: LD_INT 0
94174: PUSH
94175: LD_INT 1
94177: NEG
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: LD_INT 1
94185: PUSH
94186: LD_INT 0
94188: PUSH
94189: EMPTY
94190: LIST
94191: LIST
94192: PUSH
94193: LD_INT 1
94195: PUSH
94196: LD_INT 1
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: PUSH
94203: LD_INT 0
94205: PUSH
94206: LD_INT 1
94208: PUSH
94209: EMPTY
94210: LIST
94211: LIST
94212: PUSH
94213: LD_INT 1
94215: NEG
94216: PUSH
94217: LD_INT 0
94219: PUSH
94220: EMPTY
94221: LIST
94222: LIST
94223: PUSH
94224: LD_INT 1
94226: NEG
94227: PUSH
94228: LD_INT 1
94230: NEG
94231: PUSH
94232: EMPTY
94233: LIST
94234: LIST
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: LIST
94240: LIST
94241: LIST
94242: LIST
94243: LIST
94244: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94245: LD_ADDR_VAR 0 61
94249: PUSH
94250: LD_INT 0
94252: PUSH
94253: LD_INT 0
94255: PUSH
94256: EMPTY
94257: LIST
94258: LIST
94259: PUSH
94260: LD_INT 0
94262: PUSH
94263: LD_INT 1
94265: NEG
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: LD_INT 1
94273: PUSH
94274: LD_INT 0
94276: PUSH
94277: EMPTY
94278: LIST
94279: LIST
94280: PUSH
94281: LD_INT 1
94283: PUSH
94284: LD_INT 1
94286: PUSH
94287: EMPTY
94288: LIST
94289: LIST
94290: PUSH
94291: LD_INT 0
94293: PUSH
94294: LD_INT 1
94296: PUSH
94297: EMPTY
94298: LIST
94299: LIST
94300: PUSH
94301: LD_INT 1
94303: NEG
94304: PUSH
94305: LD_INT 0
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: PUSH
94312: LD_INT 1
94314: NEG
94315: PUSH
94316: LD_INT 1
94318: NEG
94319: PUSH
94320: EMPTY
94321: LIST
94322: LIST
94323: PUSH
94324: EMPTY
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94333: LD_ADDR_VAR 0 62
94337: PUSH
94338: LD_INT 0
94340: PUSH
94341: LD_INT 0
94343: PUSH
94344: EMPTY
94345: LIST
94346: LIST
94347: PUSH
94348: LD_INT 0
94350: PUSH
94351: LD_INT 1
94353: NEG
94354: PUSH
94355: EMPTY
94356: LIST
94357: LIST
94358: PUSH
94359: LD_INT 1
94361: PUSH
94362: LD_INT 0
94364: PUSH
94365: EMPTY
94366: LIST
94367: LIST
94368: PUSH
94369: LD_INT 1
94371: PUSH
94372: LD_INT 1
94374: PUSH
94375: EMPTY
94376: LIST
94377: LIST
94378: PUSH
94379: LD_INT 0
94381: PUSH
94382: LD_INT 1
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: PUSH
94389: LD_INT 1
94391: NEG
94392: PUSH
94393: LD_INT 0
94395: PUSH
94396: EMPTY
94397: LIST
94398: LIST
94399: PUSH
94400: LD_INT 1
94402: NEG
94403: PUSH
94404: LD_INT 1
94406: NEG
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: PUSH
94412: EMPTY
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94421: LD_ADDR_VAR 0 63
94425: PUSH
94426: LD_INT 0
94428: PUSH
94429: LD_INT 0
94431: PUSH
94432: EMPTY
94433: LIST
94434: LIST
94435: PUSH
94436: LD_INT 0
94438: PUSH
94439: LD_INT 1
94441: NEG
94442: PUSH
94443: EMPTY
94444: LIST
94445: LIST
94446: PUSH
94447: LD_INT 1
94449: PUSH
94450: LD_INT 0
94452: PUSH
94453: EMPTY
94454: LIST
94455: LIST
94456: PUSH
94457: LD_INT 1
94459: PUSH
94460: LD_INT 1
94462: PUSH
94463: EMPTY
94464: LIST
94465: LIST
94466: PUSH
94467: LD_INT 0
94469: PUSH
94470: LD_INT 1
94472: PUSH
94473: EMPTY
94474: LIST
94475: LIST
94476: PUSH
94477: LD_INT 1
94479: NEG
94480: PUSH
94481: LD_INT 0
94483: PUSH
94484: EMPTY
94485: LIST
94486: LIST
94487: PUSH
94488: LD_INT 1
94490: NEG
94491: PUSH
94492: LD_INT 1
94494: NEG
94495: PUSH
94496: EMPTY
94497: LIST
94498: LIST
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: LIST
94508: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
94509: LD_ADDR_VAR 0 64
94513: PUSH
94514: LD_INT 0
94516: PUSH
94517: LD_INT 0
94519: PUSH
94520: EMPTY
94521: LIST
94522: LIST
94523: PUSH
94524: LD_INT 0
94526: PUSH
94527: LD_INT 1
94529: NEG
94530: PUSH
94531: EMPTY
94532: LIST
94533: LIST
94534: PUSH
94535: LD_INT 1
94537: PUSH
94538: LD_INT 0
94540: PUSH
94541: EMPTY
94542: LIST
94543: LIST
94544: PUSH
94545: LD_INT 1
94547: PUSH
94548: LD_INT 1
94550: PUSH
94551: EMPTY
94552: LIST
94553: LIST
94554: PUSH
94555: LD_INT 0
94557: PUSH
94558: LD_INT 1
94560: PUSH
94561: EMPTY
94562: LIST
94563: LIST
94564: PUSH
94565: LD_INT 1
94567: NEG
94568: PUSH
94569: LD_INT 0
94571: PUSH
94572: EMPTY
94573: LIST
94574: LIST
94575: PUSH
94576: LD_INT 1
94578: NEG
94579: PUSH
94580: LD_INT 1
94582: NEG
94583: PUSH
94584: EMPTY
94585: LIST
94586: LIST
94587: PUSH
94588: EMPTY
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: ST_TO_ADDR
// end ; 1 :
94597: GO 100494
94599: LD_INT 1
94601: DOUBLE
94602: EQUAL
94603: IFTRUE 94607
94605: GO 97230
94607: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94608: LD_ADDR_VAR 0 11
94612: PUSH
94613: LD_INT 1
94615: NEG
94616: PUSH
94617: LD_INT 3
94619: NEG
94620: PUSH
94621: EMPTY
94622: LIST
94623: LIST
94624: PUSH
94625: LD_INT 0
94627: PUSH
94628: LD_INT 3
94630: NEG
94631: PUSH
94632: EMPTY
94633: LIST
94634: LIST
94635: PUSH
94636: LD_INT 1
94638: PUSH
94639: LD_INT 2
94641: NEG
94642: PUSH
94643: EMPTY
94644: LIST
94645: LIST
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: LIST
94651: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94652: LD_ADDR_VAR 0 12
94656: PUSH
94657: LD_INT 2
94659: PUSH
94660: LD_INT 1
94662: NEG
94663: PUSH
94664: EMPTY
94665: LIST
94666: LIST
94667: PUSH
94668: LD_INT 3
94670: PUSH
94671: LD_INT 0
94673: PUSH
94674: EMPTY
94675: LIST
94676: LIST
94677: PUSH
94678: LD_INT 3
94680: PUSH
94681: LD_INT 1
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: EMPTY
94689: LIST
94690: LIST
94691: LIST
94692: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94693: LD_ADDR_VAR 0 13
94697: PUSH
94698: LD_INT 3
94700: PUSH
94701: LD_INT 2
94703: PUSH
94704: EMPTY
94705: LIST
94706: LIST
94707: PUSH
94708: LD_INT 3
94710: PUSH
94711: LD_INT 3
94713: PUSH
94714: EMPTY
94715: LIST
94716: LIST
94717: PUSH
94718: LD_INT 2
94720: PUSH
94721: LD_INT 3
94723: PUSH
94724: EMPTY
94725: LIST
94726: LIST
94727: PUSH
94728: EMPTY
94729: LIST
94730: LIST
94731: LIST
94732: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94733: LD_ADDR_VAR 0 14
94737: PUSH
94738: LD_INT 1
94740: PUSH
94741: LD_INT 3
94743: PUSH
94744: EMPTY
94745: LIST
94746: LIST
94747: PUSH
94748: LD_INT 0
94750: PUSH
94751: LD_INT 3
94753: PUSH
94754: EMPTY
94755: LIST
94756: LIST
94757: PUSH
94758: LD_INT 1
94760: NEG
94761: PUSH
94762: LD_INT 2
94764: PUSH
94765: EMPTY
94766: LIST
94767: LIST
94768: PUSH
94769: EMPTY
94770: LIST
94771: LIST
94772: LIST
94773: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94774: LD_ADDR_VAR 0 15
94778: PUSH
94779: LD_INT 2
94781: NEG
94782: PUSH
94783: LD_INT 1
94785: PUSH
94786: EMPTY
94787: LIST
94788: LIST
94789: PUSH
94790: LD_INT 3
94792: NEG
94793: PUSH
94794: LD_INT 0
94796: PUSH
94797: EMPTY
94798: LIST
94799: LIST
94800: PUSH
94801: LD_INT 3
94803: NEG
94804: PUSH
94805: LD_INT 1
94807: NEG
94808: PUSH
94809: EMPTY
94810: LIST
94811: LIST
94812: PUSH
94813: EMPTY
94814: LIST
94815: LIST
94816: LIST
94817: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94818: LD_ADDR_VAR 0 16
94822: PUSH
94823: LD_INT 2
94825: NEG
94826: PUSH
94827: LD_INT 3
94829: NEG
94830: PUSH
94831: EMPTY
94832: LIST
94833: LIST
94834: PUSH
94835: LD_INT 3
94837: NEG
94838: PUSH
94839: LD_INT 2
94841: NEG
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 3
94849: NEG
94850: PUSH
94851: LD_INT 3
94853: NEG
94854: PUSH
94855: EMPTY
94856: LIST
94857: LIST
94858: PUSH
94859: EMPTY
94860: LIST
94861: LIST
94862: LIST
94863: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94864: LD_ADDR_VAR 0 17
94868: PUSH
94869: LD_INT 1
94871: NEG
94872: PUSH
94873: LD_INT 3
94875: NEG
94876: PUSH
94877: EMPTY
94878: LIST
94879: LIST
94880: PUSH
94881: LD_INT 0
94883: PUSH
94884: LD_INT 3
94886: NEG
94887: PUSH
94888: EMPTY
94889: LIST
94890: LIST
94891: PUSH
94892: LD_INT 1
94894: PUSH
94895: LD_INT 2
94897: NEG
94898: PUSH
94899: EMPTY
94900: LIST
94901: LIST
94902: PUSH
94903: EMPTY
94904: LIST
94905: LIST
94906: LIST
94907: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94908: LD_ADDR_VAR 0 18
94912: PUSH
94913: LD_INT 2
94915: PUSH
94916: LD_INT 1
94918: NEG
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: PUSH
94924: LD_INT 3
94926: PUSH
94927: LD_INT 0
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: PUSH
94934: LD_INT 3
94936: PUSH
94937: LD_INT 1
94939: PUSH
94940: EMPTY
94941: LIST
94942: LIST
94943: PUSH
94944: EMPTY
94945: LIST
94946: LIST
94947: LIST
94948: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94949: LD_ADDR_VAR 0 19
94953: PUSH
94954: LD_INT 3
94956: PUSH
94957: LD_INT 2
94959: PUSH
94960: EMPTY
94961: LIST
94962: LIST
94963: PUSH
94964: LD_INT 3
94966: PUSH
94967: LD_INT 3
94969: PUSH
94970: EMPTY
94971: LIST
94972: LIST
94973: PUSH
94974: LD_INT 2
94976: PUSH
94977: LD_INT 3
94979: PUSH
94980: EMPTY
94981: LIST
94982: LIST
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: LIST
94988: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94989: LD_ADDR_VAR 0 20
94993: PUSH
94994: LD_INT 1
94996: PUSH
94997: LD_INT 3
94999: PUSH
95000: EMPTY
95001: LIST
95002: LIST
95003: PUSH
95004: LD_INT 0
95006: PUSH
95007: LD_INT 3
95009: PUSH
95010: EMPTY
95011: LIST
95012: LIST
95013: PUSH
95014: LD_INT 1
95016: NEG
95017: PUSH
95018: LD_INT 2
95020: PUSH
95021: EMPTY
95022: LIST
95023: LIST
95024: PUSH
95025: EMPTY
95026: LIST
95027: LIST
95028: LIST
95029: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
95030: LD_ADDR_VAR 0 21
95034: PUSH
95035: LD_INT 2
95037: NEG
95038: PUSH
95039: LD_INT 1
95041: PUSH
95042: EMPTY
95043: LIST
95044: LIST
95045: PUSH
95046: LD_INT 3
95048: NEG
95049: PUSH
95050: LD_INT 0
95052: PUSH
95053: EMPTY
95054: LIST
95055: LIST
95056: PUSH
95057: LD_INT 3
95059: NEG
95060: PUSH
95061: LD_INT 1
95063: NEG
95064: PUSH
95065: EMPTY
95066: LIST
95067: LIST
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: LIST
95073: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
95074: LD_ADDR_VAR 0 22
95078: PUSH
95079: LD_INT 2
95081: NEG
95082: PUSH
95083: LD_INT 3
95085: NEG
95086: PUSH
95087: EMPTY
95088: LIST
95089: LIST
95090: PUSH
95091: LD_INT 3
95093: NEG
95094: PUSH
95095: LD_INT 2
95097: NEG
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 3
95105: NEG
95106: PUSH
95107: LD_INT 3
95109: NEG
95110: PUSH
95111: EMPTY
95112: LIST
95113: LIST
95114: PUSH
95115: EMPTY
95116: LIST
95117: LIST
95118: LIST
95119: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
95120: LD_ADDR_VAR 0 23
95124: PUSH
95125: LD_INT 0
95127: PUSH
95128: LD_INT 3
95130: NEG
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: LD_INT 1
95138: NEG
95139: PUSH
95140: LD_INT 4
95142: NEG
95143: PUSH
95144: EMPTY
95145: LIST
95146: LIST
95147: PUSH
95148: LD_INT 1
95150: PUSH
95151: LD_INT 3
95153: NEG
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: PUSH
95159: EMPTY
95160: LIST
95161: LIST
95162: LIST
95163: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
95164: LD_ADDR_VAR 0 24
95168: PUSH
95169: LD_INT 3
95171: PUSH
95172: LD_INT 0
95174: PUSH
95175: EMPTY
95176: LIST
95177: LIST
95178: PUSH
95179: LD_INT 3
95181: PUSH
95182: LD_INT 1
95184: NEG
95185: PUSH
95186: EMPTY
95187: LIST
95188: LIST
95189: PUSH
95190: LD_INT 4
95192: PUSH
95193: LD_INT 1
95195: PUSH
95196: EMPTY
95197: LIST
95198: LIST
95199: PUSH
95200: EMPTY
95201: LIST
95202: LIST
95203: LIST
95204: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
95205: LD_ADDR_VAR 0 25
95209: PUSH
95210: LD_INT 3
95212: PUSH
95213: LD_INT 3
95215: PUSH
95216: EMPTY
95217: LIST
95218: LIST
95219: PUSH
95220: LD_INT 4
95222: PUSH
95223: LD_INT 3
95225: PUSH
95226: EMPTY
95227: LIST
95228: LIST
95229: PUSH
95230: LD_INT 3
95232: PUSH
95233: LD_INT 4
95235: PUSH
95236: EMPTY
95237: LIST
95238: LIST
95239: PUSH
95240: EMPTY
95241: LIST
95242: LIST
95243: LIST
95244: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
95245: LD_ADDR_VAR 0 26
95249: PUSH
95250: LD_INT 0
95252: PUSH
95253: LD_INT 3
95255: PUSH
95256: EMPTY
95257: LIST
95258: LIST
95259: PUSH
95260: LD_INT 1
95262: PUSH
95263: LD_INT 4
95265: PUSH
95266: EMPTY
95267: LIST
95268: LIST
95269: PUSH
95270: LD_INT 1
95272: NEG
95273: PUSH
95274: LD_INT 3
95276: PUSH
95277: EMPTY
95278: LIST
95279: LIST
95280: PUSH
95281: EMPTY
95282: LIST
95283: LIST
95284: LIST
95285: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
95286: LD_ADDR_VAR 0 27
95290: PUSH
95291: LD_INT 3
95293: NEG
95294: PUSH
95295: LD_INT 0
95297: PUSH
95298: EMPTY
95299: LIST
95300: LIST
95301: PUSH
95302: LD_INT 3
95304: NEG
95305: PUSH
95306: LD_INT 1
95308: PUSH
95309: EMPTY
95310: LIST
95311: LIST
95312: PUSH
95313: LD_INT 4
95315: NEG
95316: PUSH
95317: LD_INT 1
95319: NEG
95320: PUSH
95321: EMPTY
95322: LIST
95323: LIST
95324: PUSH
95325: EMPTY
95326: LIST
95327: LIST
95328: LIST
95329: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
95330: LD_ADDR_VAR 0 28
95334: PUSH
95335: LD_INT 3
95337: NEG
95338: PUSH
95339: LD_INT 3
95341: NEG
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: LD_INT 3
95349: NEG
95350: PUSH
95351: LD_INT 4
95353: NEG
95354: PUSH
95355: EMPTY
95356: LIST
95357: LIST
95358: PUSH
95359: LD_INT 4
95361: NEG
95362: PUSH
95363: LD_INT 3
95365: NEG
95366: PUSH
95367: EMPTY
95368: LIST
95369: LIST
95370: PUSH
95371: EMPTY
95372: LIST
95373: LIST
95374: LIST
95375: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
95376: LD_ADDR_VAR 0 29
95380: PUSH
95381: LD_INT 1
95383: NEG
95384: PUSH
95385: LD_INT 3
95387: NEG
95388: PUSH
95389: EMPTY
95390: LIST
95391: LIST
95392: PUSH
95393: LD_INT 0
95395: PUSH
95396: LD_INT 3
95398: NEG
95399: PUSH
95400: EMPTY
95401: LIST
95402: LIST
95403: PUSH
95404: LD_INT 1
95406: PUSH
95407: LD_INT 2
95409: NEG
95410: PUSH
95411: EMPTY
95412: LIST
95413: LIST
95414: PUSH
95415: LD_INT 1
95417: NEG
95418: PUSH
95419: LD_INT 4
95421: NEG
95422: PUSH
95423: EMPTY
95424: LIST
95425: LIST
95426: PUSH
95427: LD_INT 0
95429: PUSH
95430: LD_INT 4
95432: NEG
95433: PUSH
95434: EMPTY
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 1
95440: PUSH
95441: LD_INT 3
95443: NEG
95444: PUSH
95445: EMPTY
95446: LIST
95447: LIST
95448: PUSH
95449: LD_INT 1
95451: NEG
95452: PUSH
95453: LD_INT 5
95455: NEG
95456: PUSH
95457: EMPTY
95458: LIST
95459: LIST
95460: PUSH
95461: LD_INT 0
95463: PUSH
95464: LD_INT 5
95466: NEG
95467: PUSH
95468: EMPTY
95469: LIST
95470: LIST
95471: PUSH
95472: LD_INT 1
95474: PUSH
95475: LD_INT 4
95477: NEG
95478: PUSH
95479: EMPTY
95480: LIST
95481: LIST
95482: PUSH
95483: LD_INT 1
95485: NEG
95486: PUSH
95487: LD_INT 6
95489: NEG
95490: PUSH
95491: EMPTY
95492: LIST
95493: LIST
95494: PUSH
95495: LD_INT 0
95497: PUSH
95498: LD_INT 6
95500: NEG
95501: PUSH
95502: EMPTY
95503: LIST
95504: LIST
95505: PUSH
95506: LD_INT 1
95508: PUSH
95509: LD_INT 5
95511: NEG
95512: PUSH
95513: EMPTY
95514: LIST
95515: LIST
95516: PUSH
95517: EMPTY
95518: LIST
95519: LIST
95520: LIST
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
95531: LD_ADDR_VAR 0 30
95535: PUSH
95536: LD_INT 2
95538: PUSH
95539: LD_INT 1
95541: NEG
95542: PUSH
95543: EMPTY
95544: LIST
95545: LIST
95546: PUSH
95547: LD_INT 3
95549: PUSH
95550: LD_INT 0
95552: PUSH
95553: EMPTY
95554: LIST
95555: LIST
95556: PUSH
95557: LD_INT 3
95559: PUSH
95560: LD_INT 1
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: PUSH
95567: LD_INT 3
95569: PUSH
95570: LD_INT 1
95572: NEG
95573: PUSH
95574: EMPTY
95575: LIST
95576: LIST
95577: PUSH
95578: LD_INT 4
95580: PUSH
95581: LD_INT 0
95583: PUSH
95584: EMPTY
95585: LIST
95586: LIST
95587: PUSH
95588: LD_INT 4
95590: PUSH
95591: LD_INT 1
95593: PUSH
95594: EMPTY
95595: LIST
95596: LIST
95597: PUSH
95598: LD_INT 4
95600: PUSH
95601: LD_INT 1
95603: NEG
95604: PUSH
95605: EMPTY
95606: LIST
95607: LIST
95608: PUSH
95609: LD_INT 5
95611: PUSH
95612: LD_INT 0
95614: PUSH
95615: EMPTY
95616: LIST
95617: LIST
95618: PUSH
95619: LD_INT 5
95621: PUSH
95622: LD_INT 1
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: PUSH
95629: LD_INT 5
95631: PUSH
95632: LD_INT 1
95634: NEG
95635: PUSH
95636: EMPTY
95637: LIST
95638: LIST
95639: PUSH
95640: LD_INT 6
95642: PUSH
95643: LD_INT 0
95645: PUSH
95646: EMPTY
95647: LIST
95648: LIST
95649: PUSH
95650: LD_INT 6
95652: PUSH
95653: LD_INT 1
95655: PUSH
95656: EMPTY
95657: LIST
95658: LIST
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: LIST
95664: LIST
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
95674: LD_ADDR_VAR 0 31
95678: PUSH
95679: LD_INT 3
95681: PUSH
95682: LD_INT 2
95684: PUSH
95685: EMPTY
95686: LIST
95687: LIST
95688: PUSH
95689: LD_INT 3
95691: PUSH
95692: LD_INT 3
95694: PUSH
95695: EMPTY
95696: LIST
95697: LIST
95698: PUSH
95699: LD_INT 2
95701: PUSH
95702: LD_INT 3
95704: PUSH
95705: EMPTY
95706: LIST
95707: LIST
95708: PUSH
95709: LD_INT 4
95711: PUSH
95712: LD_INT 3
95714: PUSH
95715: EMPTY
95716: LIST
95717: LIST
95718: PUSH
95719: LD_INT 4
95721: PUSH
95722: LD_INT 4
95724: PUSH
95725: EMPTY
95726: LIST
95727: LIST
95728: PUSH
95729: LD_INT 3
95731: PUSH
95732: LD_INT 4
95734: PUSH
95735: EMPTY
95736: LIST
95737: LIST
95738: PUSH
95739: LD_INT 5
95741: PUSH
95742: LD_INT 4
95744: PUSH
95745: EMPTY
95746: LIST
95747: LIST
95748: PUSH
95749: LD_INT 5
95751: PUSH
95752: LD_INT 5
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: PUSH
95759: LD_INT 4
95761: PUSH
95762: LD_INT 5
95764: PUSH
95765: EMPTY
95766: LIST
95767: LIST
95768: PUSH
95769: LD_INT 6
95771: PUSH
95772: LD_INT 5
95774: PUSH
95775: EMPTY
95776: LIST
95777: LIST
95778: PUSH
95779: LD_INT 6
95781: PUSH
95782: LD_INT 6
95784: PUSH
95785: EMPTY
95786: LIST
95787: LIST
95788: PUSH
95789: LD_INT 5
95791: PUSH
95792: LD_INT 6
95794: PUSH
95795: EMPTY
95796: LIST
95797: LIST
95798: PUSH
95799: EMPTY
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
95813: LD_ADDR_VAR 0 32
95817: PUSH
95818: LD_INT 1
95820: PUSH
95821: LD_INT 3
95823: PUSH
95824: EMPTY
95825: LIST
95826: LIST
95827: PUSH
95828: LD_INT 0
95830: PUSH
95831: LD_INT 3
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: PUSH
95838: LD_INT 1
95840: NEG
95841: PUSH
95842: LD_INT 2
95844: PUSH
95845: EMPTY
95846: LIST
95847: LIST
95848: PUSH
95849: LD_INT 1
95851: PUSH
95852: LD_INT 4
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 0
95861: PUSH
95862: LD_INT 4
95864: PUSH
95865: EMPTY
95866: LIST
95867: LIST
95868: PUSH
95869: LD_INT 1
95871: NEG
95872: PUSH
95873: LD_INT 3
95875: PUSH
95876: EMPTY
95877: LIST
95878: LIST
95879: PUSH
95880: LD_INT 1
95882: PUSH
95883: LD_INT 5
95885: PUSH
95886: EMPTY
95887: LIST
95888: LIST
95889: PUSH
95890: LD_INT 0
95892: PUSH
95893: LD_INT 5
95895: PUSH
95896: EMPTY
95897: LIST
95898: LIST
95899: PUSH
95900: LD_INT 1
95902: NEG
95903: PUSH
95904: LD_INT 4
95906: PUSH
95907: EMPTY
95908: LIST
95909: LIST
95910: PUSH
95911: LD_INT 1
95913: PUSH
95914: LD_INT 6
95916: PUSH
95917: EMPTY
95918: LIST
95919: LIST
95920: PUSH
95921: LD_INT 0
95923: PUSH
95924: LD_INT 6
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: PUSH
95931: LD_INT 1
95933: NEG
95934: PUSH
95935: LD_INT 5
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: PUSH
95942: EMPTY
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: LIST
95953: LIST
95954: LIST
95955: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
95956: LD_ADDR_VAR 0 33
95960: PUSH
95961: LD_INT 2
95963: NEG
95964: PUSH
95965: LD_INT 1
95967: PUSH
95968: EMPTY
95969: LIST
95970: LIST
95971: PUSH
95972: LD_INT 3
95974: NEG
95975: PUSH
95976: LD_INT 0
95978: PUSH
95979: EMPTY
95980: LIST
95981: LIST
95982: PUSH
95983: LD_INT 3
95985: NEG
95986: PUSH
95987: LD_INT 1
95989: NEG
95990: PUSH
95991: EMPTY
95992: LIST
95993: LIST
95994: PUSH
95995: LD_INT 3
95997: NEG
95998: PUSH
95999: LD_INT 1
96001: PUSH
96002: EMPTY
96003: LIST
96004: LIST
96005: PUSH
96006: LD_INT 4
96008: NEG
96009: PUSH
96010: LD_INT 0
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: PUSH
96017: LD_INT 4
96019: NEG
96020: PUSH
96021: LD_INT 1
96023: NEG
96024: PUSH
96025: EMPTY
96026: LIST
96027: LIST
96028: PUSH
96029: LD_INT 4
96031: NEG
96032: PUSH
96033: LD_INT 1
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: PUSH
96040: LD_INT 5
96042: NEG
96043: PUSH
96044: LD_INT 0
96046: PUSH
96047: EMPTY
96048: LIST
96049: LIST
96050: PUSH
96051: LD_INT 5
96053: NEG
96054: PUSH
96055: LD_INT 1
96057: NEG
96058: PUSH
96059: EMPTY
96060: LIST
96061: LIST
96062: PUSH
96063: LD_INT 5
96065: NEG
96066: PUSH
96067: LD_INT 1
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: PUSH
96074: LD_INT 6
96076: NEG
96077: PUSH
96078: LD_INT 0
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: PUSH
96085: LD_INT 6
96087: NEG
96088: PUSH
96089: LD_INT 1
96091: NEG
96092: PUSH
96093: EMPTY
96094: LIST
96095: LIST
96096: PUSH
96097: EMPTY
96098: LIST
96099: LIST
96100: LIST
96101: LIST
96102: LIST
96103: LIST
96104: LIST
96105: LIST
96106: LIST
96107: LIST
96108: LIST
96109: LIST
96110: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
96111: LD_ADDR_VAR 0 34
96115: PUSH
96116: LD_INT 2
96118: NEG
96119: PUSH
96120: LD_INT 3
96122: NEG
96123: PUSH
96124: EMPTY
96125: LIST
96126: LIST
96127: PUSH
96128: LD_INT 3
96130: NEG
96131: PUSH
96132: LD_INT 2
96134: NEG
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 3
96142: NEG
96143: PUSH
96144: LD_INT 3
96146: NEG
96147: PUSH
96148: EMPTY
96149: LIST
96150: LIST
96151: PUSH
96152: LD_INT 3
96154: NEG
96155: PUSH
96156: LD_INT 4
96158: NEG
96159: PUSH
96160: EMPTY
96161: LIST
96162: LIST
96163: PUSH
96164: LD_INT 4
96166: NEG
96167: PUSH
96168: LD_INT 3
96170: NEG
96171: PUSH
96172: EMPTY
96173: LIST
96174: LIST
96175: PUSH
96176: LD_INT 4
96178: NEG
96179: PUSH
96180: LD_INT 4
96182: NEG
96183: PUSH
96184: EMPTY
96185: LIST
96186: LIST
96187: PUSH
96188: LD_INT 4
96190: NEG
96191: PUSH
96192: LD_INT 5
96194: NEG
96195: PUSH
96196: EMPTY
96197: LIST
96198: LIST
96199: PUSH
96200: LD_INT 5
96202: NEG
96203: PUSH
96204: LD_INT 4
96206: NEG
96207: PUSH
96208: EMPTY
96209: LIST
96210: LIST
96211: PUSH
96212: LD_INT 5
96214: NEG
96215: PUSH
96216: LD_INT 5
96218: NEG
96219: PUSH
96220: EMPTY
96221: LIST
96222: LIST
96223: PUSH
96224: LD_INT 5
96226: NEG
96227: PUSH
96228: LD_INT 6
96230: NEG
96231: PUSH
96232: EMPTY
96233: LIST
96234: LIST
96235: PUSH
96236: LD_INT 6
96238: NEG
96239: PUSH
96240: LD_INT 5
96242: NEG
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: LD_INT 6
96250: NEG
96251: PUSH
96252: LD_INT 6
96254: NEG
96255: PUSH
96256: EMPTY
96257: LIST
96258: LIST
96259: PUSH
96260: EMPTY
96261: LIST
96262: LIST
96263: LIST
96264: LIST
96265: LIST
96266: LIST
96267: LIST
96268: LIST
96269: LIST
96270: LIST
96271: LIST
96272: LIST
96273: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
96274: LD_ADDR_VAR 0 41
96278: PUSH
96279: LD_INT 0
96281: PUSH
96282: LD_INT 2
96284: NEG
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: PUSH
96290: LD_INT 1
96292: NEG
96293: PUSH
96294: LD_INT 3
96296: NEG
96297: PUSH
96298: EMPTY
96299: LIST
96300: LIST
96301: PUSH
96302: LD_INT 1
96304: PUSH
96305: LD_INT 2
96307: NEG
96308: PUSH
96309: EMPTY
96310: LIST
96311: LIST
96312: PUSH
96313: EMPTY
96314: LIST
96315: LIST
96316: LIST
96317: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
96318: LD_ADDR_VAR 0 42
96322: PUSH
96323: LD_INT 2
96325: PUSH
96326: LD_INT 0
96328: PUSH
96329: EMPTY
96330: LIST
96331: LIST
96332: PUSH
96333: LD_INT 2
96335: PUSH
96336: LD_INT 1
96338: NEG
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 3
96346: PUSH
96347: LD_INT 1
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: PUSH
96354: EMPTY
96355: LIST
96356: LIST
96357: LIST
96358: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
96359: LD_ADDR_VAR 0 43
96363: PUSH
96364: LD_INT 2
96366: PUSH
96367: LD_INT 2
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: PUSH
96374: LD_INT 3
96376: PUSH
96377: LD_INT 2
96379: PUSH
96380: EMPTY
96381: LIST
96382: LIST
96383: PUSH
96384: LD_INT 2
96386: PUSH
96387: LD_INT 3
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PUSH
96394: EMPTY
96395: LIST
96396: LIST
96397: LIST
96398: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
96399: LD_ADDR_VAR 0 44
96403: PUSH
96404: LD_INT 0
96406: PUSH
96407: LD_INT 2
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: PUSH
96414: LD_INT 1
96416: PUSH
96417: LD_INT 3
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: PUSH
96424: LD_INT 1
96426: NEG
96427: PUSH
96428: LD_INT 2
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: PUSH
96435: EMPTY
96436: LIST
96437: LIST
96438: LIST
96439: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
96440: LD_ADDR_VAR 0 45
96444: PUSH
96445: LD_INT 2
96447: NEG
96448: PUSH
96449: LD_INT 0
96451: PUSH
96452: EMPTY
96453: LIST
96454: LIST
96455: PUSH
96456: LD_INT 2
96458: NEG
96459: PUSH
96460: LD_INT 1
96462: PUSH
96463: EMPTY
96464: LIST
96465: LIST
96466: PUSH
96467: LD_INT 3
96469: NEG
96470: PUSH
96471: LD_INT 1
96473: NEG
96474: PUSH
96475: EMPTY
96476: LIST
96477: LIST
96478: PUSH
96479: EMPTY
96480: LIST
96481: LIST
96482: LIST
96483: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
96484: LD_ADDR_VAR 0 46
96488: PUSH
96489: LD_INT 2
96491: NEG
96492: PUSH
96493: LD_INT 2
96495: NEG
96496: PUSH
96497: EMPTY
96498: LIST
96499: LIST
96500: PUSH
96501: LD_INT 2
96503: NEG
96504: PUSH
96505: LD_INT 3
96507: NEG
96508: PUSH
96509: EMPTY
96510: LIST
96511: LIST
96512: PUSH
96513: LD_INT 3
96515: NEG
96516: PUSH
96517: LD_INT 2
96519: NEG
96520: PUSH
96521: EMPTY
96522: LIST
96523: LIST
96524: PUSH
96525: EMPTY
96526: LIST
96527: LIST
96528: LIST
96529: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
96530: LD_ADDR_VAR 0 47
96534: PUSH
96535: LD_INT 2
96537: NEG
96538: PUSH
96539: LD_INT 3
96541: NEG
96542: PUSH
96543: EMPTY
96544: LIST
96545: LIST
96546: PUSH
96547: LD_INT 1
96549: NEG
96550: PUSH
96551: LD_INT 3
96553: NEG
96554: PUSH
96555: EMPTY
96556: LIST
96557: LIST
96558: PUSH
96559: EMPTY
96560: LIST
96561: LIST
96562: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
96563: LD_ADDR_VAR 0 48
96567: PUSH
96568: LD_INT 1
96570: PUSH
96571: LD_INT 2
96573: NEG
96574: PUSH
96575: EMPTY
96576: LIST
96577: LIST
96578: PUSH
96579: LD_INT 2
96581: PUSH
96582: LD_INT 1
96584: NEG
96585: PUSH
96586: EMPTY
96587: LIST
96588: LIST
96589: PUSH
96590: EMPTY
96591: LIST
96592: LIST
96593: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
96594: LD_ADDR_VAR 0 49
96598: PUSH
96599: LD_INT 3
96601: PUSH
96602: LD_INT 1
96604: PUSH
96605: EMPTY
96606: LIST
96607: LIST
96608: PUSH
96609: LD_INT 3
96611: PUSH
96612: LD_INT 2
96614: PUSH
96615: EMPTY
96616: LIST
96617: LIST
96618: PUSH
96619: EMPTY
96620: LIST
96621: LIST
96622: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
96623: LD_ADDR_VAR 0 50
96627: PUSH
96628: LD_INT 2
96630: PUSH
96631: LD_INT 3
96633: PUSH
96634: EMPTY
96635: LIST
96636: LIST
96637: PUSH
96638: LD_INT 1
96640: PUSH
96641: LD_INT 3
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PUSH
96648: EMPTY
96649: LIST
96650: LIST
96651: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
96652: LD_ADDR_VAR 0 51
96656: PUSH
96657: LD_INT 1
96659: NEG
96660: PUSH
96661: LD_INT 2
96663: PUSH
96664: EMPTY
96665: LIST
96666: LIST
96667: PUSH
96668: LD_INT 2
96670: NEG
96671: PUSH
96672: LD_INT 1
96674: PUSH
96675: EMPTY
96676: LIST
96677: LIST
96678: PUSH
96679: EMPTY
96680: LIST
96681: LIST
96682: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
96683: LD_ADDR_VAR 0 52
96687: PUSH
96688: LD_INT 3
96690: NEG
96691: PUSH
96692: LD_INT 1
96694: NEG
96695: PUSH
96696: EMPTY
96697: LIST
96698: LIST
96699: PUSH
96700: LD_INT 3
96702: NEG
96703: PUSH
96704: LD_INT 2
96706: NEG
96707: PUSH
96708: EMPTY
96709: LIST
96710: LIST
96711: PUSH
96712: EMPTY
96713: LIST
96714: LIST
96715: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
96716: LD_ADDR_VAR 0 53
96720: PUSH
96721: LD_INT 1
96723: NEG
96724: PUSH
96725: LD_INT 3
96727: NEG
96728: PUSH
96729: EMPTY
96730: LIST
96731: LIST
96732: PUSH
96733: LD_INT 0
96735: PUSH
96736: LD_INT 3
96738: NEG
96739: PUSH
96740: EMPTY
96741: LIST
96742: LIST
96743: PUSH
96744: LD_INT 1
96746: PUSH
96747: LD_INT 2
96749: NEG
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: PUSH
96755: EMPTY
96756: LIST
96757: LIST
96758: LIST
96759: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
96760: LD_ADDR_VAR 0 54
96764: PUSH
96765: LD_INT 2
96767: PUSH
96768: LD_INT 1
96770: NEG
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: PUSH
96776: LD_INT 3
96778: PUSH
96779: LD_INT 0
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: PUSH
96786: LD_INT 3
96788: PUSH
96789: LD_INT 1
96791: PUSH
96792: EMPTY
96793: LIST
96794: LIST
96795: PUSH
96796: EMPTY
96797: LIST
96798: LIST
96799: LIST
96800: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
96801: LD_ADDR_VAR 0 55
96805: PUSH
96806: LD_INT 3
96808: PUSH
96809: LD_INT 2
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: PUSH
96816: LD_INT 3
96818: PUSH
96819: LD_INT 3
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: PUSH
96826: LD_INT 2
96828: PUSH
96829: LD_INT 3
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: PUSH
96836: EMPTY
96837: LIST
96838: LIST
96839: LIST
96840: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
96841: LD_ADDR_VAR 0 56
96845: PUSH
96846: LD_INT 1
96848: PUSH
96849: LD_INT 3
96851: PUSH
96852: EMPTY
96853: LIST
96854: LIST
96855: PUSH
96856: LD_INT 0
96858: PUSH
96859: LD_INT 3
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: LD_INT 1
96868: NEG
96869: PUSH
96870: LD_INT 2
96872: PUSH
96873: EMPTY
96874: LIST
96875: LIST
96876: PUSH
96877: EMPTY
96878: LIST
96879: LIST
96880: LIST
96881: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
96882: LD_ADDR_VAR 0 57
96886: PUSH
96887: LD_INT 2
96889: NEG
96890: PUSH
96891: LD_INT 1
96893: PUSH
96894: EMPTY
96895: LIST
96896: LIST
96897: PUSH
96898: LD_INT 3
96900: NEG
96901: PUSH
96902: LD_INT 0
96904: PUSH
96905: EMPTY
96906: LIST
96907: LIST
96908: PUSH
96909: LD_INT 3
96911: NEG
96912: PUSH
96913: LD_INT 1
96915: NEG
96916: PUSH
96917: EMPTY
96918: LIST
96919: LIST
96920: PUSH
96921: EMPTY
96922: LIST
96923: LIST
96924: LIST
96925: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
96926: LD_ADDR_VAR 0 58
96930: PUSH
96931: LD_INT 2
96933: NEG
96934: PUSH
96935: LD_INT 3
96937: NEG
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: PUSH
96943: LD_INT 3
96945: NEG
96946: PUSH
96947: LD_INT 2
96949: NEG
96950: PUSH
96951: EMPTY
96952: LIST
96953: LIST
96954: PUSH
96955: LD_INT 3
96957: NEG
96958: PUSH
96959: LD_INT 3
96961: NEG
96962: PUSH
96963: EMPTY
96964: LIST
96965: LIST
96966: PUSH
96967: EMPTY
96968: LIST
96969: LIST
96970: LIST
96971: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
96972: LD_ADDR_VAR 0 59
96976: PUSH
96977: LD_INT 1
96979: NEG
96980: PUSH
96981: LD_INT 2
96983: NEG
96984: PUSH
96985: EMPTY
96986: LIST
96987: LIST
96988: PUSH
96989: LD_INT 0
96991: PUSH
96992: LD_INT 2
96994: NEG
96995: PUSH
96996: EMPTY
96997: LIST
96998: LIST
96999: PUSH
97000: LD_INT 1
97002: PUSH
97003: LD_INT 1
97005: NEG
97006: PUSH
97007: EMPTY
97008: LIST
97009: LIST
97010: PUSH
97011: EMPTY
97012: LIST
97013: LIST
97014: LIST
97015: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
97016: LD_ADDR_VAR 0 60
97020: PUSH
97021: LD_INT 1
97023: PUSH
97024: LD_INT 1
97026: NEG
97027: PUSH
97028: EMPTY
97029: LIST
97030: LIST
97031: PUSH
97032: LD_INT 2
97034: PUSH
97035: LD_INT 0
97037: PUSH
97038: EMPTY
97039: LIST
97040: LIST
97041: PUSH
97042: LD_INT 2
97044: PUSH
97045: LD_INT 1
97047: PUSH
97048: EMPTY
97049: LIST
97050: LIST
97051: PUSH
97052: EMPTY
97053: LIST
97054: LIST
97055: LIST
97056: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
97057: LD_ADDR_VAR 0 61
97061: PUSH
97062: LD_INT 2
97064: PUSH
97065: LD_INT 1
97067: PUSH
97068: EMPTY
97069: LIST
97070: LIST
97071: PUSH
97072: LD_INT 2
97074: PUSH
97075: LD_INT 2
97077: PUSH
97078: EMPTY
97079: LIST
97080: LIST
97081: PUSH
97082: LD_INT 1
97084: PUSH
97085: LD_INT 2
97087: PUSH
97088: EMPTY
97089: LIST
97090: LIST
97091: PUSH
97092: EMPTY
97093: LIST
97094: LIST
97095: LIST
97096: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
97097: LD_ADDR_VAR 0 62
97101: PUSH
97102: LD_INT 1
97104: PUSH
97105: LD_INT 2
97107: PUSH
97108: EMPTY
97109: LIST
97110: LIST
97111: PUSH
97112: LD_INT 0
97114: PUSH
97115: LD_INT 2
97117: PUSH
97118: EMPTY
97119: LIST
97120: LIST
97121: PUSH
97122: LD_INT 1
97124: NEG
97125: PUSH
97126: LD_INT 1
97128: PUSH
97129: EMPTY
97130: LIST
97131: LIST
97132: PUSH
97133: EMPTY
97134: LIST
97135: LIST
97136: LIST
97137: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
97138: LD_ADDR_VAR 0 63
97142: PUSH
97143: LD_INT 1
97145: NEG
97146: PUSH
97147: LD_INT 1
97149: PUSH
97150: EMPTY
97151: LIST
97152: LIST
97153: PUSH
97154: LD_INT 2
97156: NEG
97157: PUSH
97158: LD_INT 0
97160: PUSH
97161: EMPTY
97162: LIST
97163: LIST
97164: PUSH
97165: LD_INT 2
97167: NEG
97168: PUSH
97169: LD_INT 1
97171: NEG
97172: PUSH
97173: EMPTY
97174: LIST
97175: LIST
97176: PUSH
97177: EMPTY
97178: LIST
97179: LIST
97180: LIST
97181: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
97182: LD_ADDR_VAR 0 64
97186: PUSH
97187: LD_INT 1
97189: NEG
97190: PUSH
97191: LD_INT 2
97193: NEG
97194: PUSH
97195: EMPTY
97196: LIST
97197: LIST
97198: PUSH
97199: LD_INT 2
97201: NEG
97202: PUSH
97203: LD_INT 1
97205: NEG
97206: PUSH
97207: EMPTY
97208: LIST
97209: LIST
97210: PUSH
97211: LD_INT 2
97213: NEG
97214: PUSH
97215: LD_INT 2
97217: NEG
97218: PUSH
97219: EMPTY
97220: LIST
97221: LIST
97222: PUSH
97223: EMPTY
97224: LIST
97225: LIST
97226: LIST
97227: ST_TO_ADDR
// end ; 2 :
97228: GO 100494
97230: LD_INT 2
97232: DOUBLE
97233: EQUAL
97234: IFTRUE 97238
97236: GO 100493
97238: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
97239: LD_ADDR_VAR 0 29
97243: PUSH
97244: LD_INT 4
97246: PUSH
97247: LD_INT 0
97249: PUSH
97250: EMPTY
97251: LIST
97252: LIST
97253: PUSH
97254: LD_INT 4
97256: PUSH
97257: LD_INT 1
97259: NEG
97260: PUSH
97261: EMPTY
97262: LIST
97263: LIST
97264: PUSH
97265: LD_INT 5
97267: PUSH
97268: LD_INT 0
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PUSH
97275: LD_INT 5
97277: PUSH
97278: LD_INT 1
97280: PUSH
97281: EMPTY
97282: LIST
97283: LIST
97284: PUSH
97285: LD_INT 4
97287: PUSH
97288: LD_INT 1
97290: PUSH
97291: EMPTY
97292: LIST
97293: LIST
97294: PUSH
97295: LD_INT 3
97297: PUSH
97298: LD_INT 0
97300: PUSH
97301: EMPTY
97302: LIST
97303: LIST
97304: PUSH
97305: LD_INT 3
97307: PUSH
97308: LD_INT 1
97310: NEG
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: PUSH
97316: LD_INT 3
97318: PUSH
97319: LD_INT 2
97321: NEG
97322: PUSH
97323: EMPTY
97324: LIST
97325: LIST
97326: PUSH
97327: LD_INT 5
97329: PUSH
97330: LD_INT 2
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PUSH
97337: LD_INT 3
97339: PUSH
97340: LD_INT 3
97342: PUSH
97343: EMPTY
97344: LIST
97345: LIST
97346: PUSH
97347: LD_INT 3
97349: PUSH
97350: LD_INT 2
97352: PUSH
97353: EMPTY
97354: LIST
97355: LIST
97356: PUSH
97357: LD_INT 4
97359: PUSH
97360: LD_INT 3
97362: PUSH
97363: EMPTY
97364: LIST
97365: LIST
97366: PUSH
97367: LD_INT 4
97369: PUSH
97370: LD_INT 4
97372: PUSH
97373: EMPTY
97374: LIST
97375: LIST
97376: PUSH
97377: LD_INT 3
97379: PUSH
97380: LD_INT 4
97382: PUSH
97383: EMPTY
97384: LIST
97385: LIST
97386: PUSH
97387: LD_INT 2
97389: PUSH
97390: LD_INT 3
97392: PUSH
97393: EMPTY
97394: LIST
97395: LIST
97396: PUSH
97397: LD_INT 2
97399: PUSH
97400: LD_INT 2
97402: PUSH
97403: EMPTY
97404: LIST
97405: LIST
97406: PUSH
97407: LD_INT 4
97409: PUSH
97410: LD_INT 2
97412: PUSH
97413: EMPTY
97414: LIST
97415: LIST
97416: PUSH
97417: LD_INT 2
97419: PUSH
97420: LD_INT 4
97422: PUSH
97423: EMPTY
97424: LIST
97425: LIST
97426: PUSH
97427: LD_INT 0
97429: PUSH
97430: LD_INT 4
97432: PUSH
97433: EMPTY
97434: LIST
97435: LIST
97436: PUSH
97437: LD_INT 0
97439: PUSH
97440: LD_INT 3
97442: PUSH
97443: EMPTY
97444: LIST
97445: LIST
97446: PUSH
97447: LD_INT 1
97449: PUSH
97450: LD_INT 4
97452: PUSH
97453: EMPTY
97454: LIST
97455: LIST
97456: PUSH
97457: LD_INT 1
97459: PUSH
97460: LD_INT 5
97462: PUSH
97463: EMPTY
97464: LIST
97465: LIST
97466: PUSH
97467: LD_INT 0
97469: PUSH
97470: LD_INT 5
97472: PUSH
97473: EMPTY
97474: LIST
97475: LIST
97476: PUSH
97477: LD_INT 1
97479: NEG
97480: PUSH
97481: LD_INT 4
97483: PUSH
97484: EMPTY
97485: LIST
97486: LIST
97487: PUSH
97488: LD_INT 1
97490: NEG
97491: PUSH
97492: LD_INT 3
97494: PUSH
97495: EMPTY
97496: LIST
97497: LIST
97498: PUSH
97499: LD_INT 2
97501: PUSH
97502: LD_INT 5
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: PUSH
97509: LD_INT 2
97511: NEG
97512: PUSH
97513: LD_INT 3
97515: PUSH
97516: EMPTY
97517: LIST
97518: LIST
97519: PUSH
97520: LD_INT 3
97522: NEG
97523: PUSH
97524: LD_INT 0
97526: PUSH
97527: EMPTY
97528: LIST
97529: LIST
97530: PUSH
97531: LD_INT 3
97533: NEG
97534: PUSH
97535: LD_INT 1
97537: NEG
97538: PUSH
97539: EMPTY
97540: LIST
97541: LIST
97542: PUSH
97543: LD_INT 2
97545: NEG
97546: PUSH
97547: LD_INT 0
97549: PUSH
97550: EMPTY
97551: LIST
97552: LIST
97553: PUSH
97554: LD_INT 2
97556: NEG
97557: PUSH
97558: LD_INT 1
97560: PUSH
97561: EMPTY
97562: LIST
97563: LIST
97564: PUSH
97565: LD_INT 3
97567: NEG
97568: PUSH
97569: LD_INT 1
97571: PUSH
97572: EMPTY
97573: LIST
97574: LIST
97575: PUSH
97576: LD_INT 4
97578: NEG
97579: PUSH
97580: LD_INT 0
97582: PUSH
97583: EMPTY
97584: LIST
97585: LIST
97586: PUSH
97587: LD_INT 4
97589: NEG
97590: PUSH
97591: LD_INT 1
97593: NEG
97594: PUSH
97595: EMPTY
97596: LIST
97597: LIST
97598: PUSH
97599: LD_INT 4
97601: NEG
97602: PUSH
97603: LD_INT 2
97605: NEG
97606: PUSH
97607: EMPTY
97608: LIST
97609: LIST
97610: PUSH
97611: LD_INT 2
97613: NEG
97614: PUSH
97615: LD_INT 2
97617: PUSH
97618: EMPTY
97619: LIST
97620: LIST
97621: PUSH
97622: LD_INT 4
97624: NEG
97625: PUSH
97626: LD_INT 4
97628: NEG
97629: PUSH
97630: EMPTY
97631: LIST
97632: LIST
97633: PUSH
97634: LD_INT 4
97636: NEG
97637: PUSH
97638: LD_INT 5
97640: NEG
97641: PUSH
97642: EMPTY
97643: LIST
97644: LIST
97645: PUSH
97646: LD_INT 3
97648: NEG
97649: PUSH
97650: LD_INT 4
97652: NEG
97653: PUSH
97654: EMPTY
97655: LIST
97656: LIST
97657: PUSH
97658: LD_INT 3
97660: NEG
97661: PUSH
97662: LD_INT 3
97664: NEG
97665: PUSH
97666: EMPTY
97667: LIST
97668: LIST
97669: PUSH
97670: LD_INT 4
97672: NEG
97673: PUSH
97674: LD_INT 3
97676: NEG
97677: PUSH
97678: EMPTY
97679: LIST
97680: LIST
97681: PUSH
97682: LD_INT 5
97684: NEG
97685: PUSH
97686: LD_INT 4
97688: NEG
97689: PUSH
97690: EMPTY
97691: LIST
97692: LIST
97693: PUSH
97694: LD_INT 5
97696: NEG
97697: PUSH
97698: LD_INT 5
97700: NEG
97701: PUSH
97702: EMPTY
97703: LIST
97704: LIST
97705: PUSH
97706: LD_INT 3
97708: NEG
97709: PUSH
97710: LD_INT 5
97712: NEG
97713: PUSH
97714: EMPTY
97715: LIST
97716: LIST
97717: PUSH
97718: LD_INT 5
97720: NEG
97721: PUSH
97722: LD_INT 3
97724: NEG
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: PUSH
97730: EMPTY
97731: LIST
97732: LIST
97733: LIST
97734: LIST
97735: LIST
97736: LIST
97737: LIST
97738: LIST
97739: LIST
97740: LIST
97741: LIST
97742: LIST
97743: LIST
97744: LIST
97745: LIST
97746: LIST
97747: LIST
97748: LIST
97749: LIST
97750: LIST
97751: LIST
97752: LIST
97753: LIST
97754: LIST
97755: LIST
97756: LIST
97757: LIST
97758: LIST
97759: LIST
97760: LIST
97761: LIST
97762: LIST
97763: LIST
97764: LIST
97765: LIST
97766: LIST
97767: LIST
97768: LIST
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: LIST
97776: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
97777: LD_ADDR_VAR 0 30
97781: PUSH
97782: LD_INT 4
97784: PUSH
97785: LD_INT 4
97787: PUSH
97788: EMPTY
97789: LIST
97790: LIST
97791: PUSH
97792: LD_INT 4
97794: PUSH
97795: LD_INT 3
97797: PUSH
97798: EMPTY
97799: LIST
97800: LIST
97801: PUSH
97802: LD_INT 5
97804: PUSH
97805: LD_INT 4
97807: PUSH
97808: EMPTY
97809: LIST
97810: LIST
97811: PUSH
97812: LD_INT 5
97814: PUSH
97815: LD_INT 5
97817: PUSH
97818: EMPTY
97819: LIST
97820: LIST
97821: PUSH
97822: LD_INT 4
97824: PUSH
97825: LD_INT 5
97827: PUSH
97828: EMPTY
97829: LIST
97830: LIST
97831: PUSH
97832: LD_INT 3
97834: PUSH
97835: LD_INT 4
97837: PUSH
97838: EMPTY
97839: LIST
97840: LIST
97841: PUSH
97842: LD_INT 3
97844: PUSH
97845: LD_INT 3
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: PUSH
97852: LD_INT 5
97854: PUSH
97855: LD_INT 3
97857: PUSH
97858: EMPTY
97859: LIST
97860: LIST
97861: PUSH
97862: LD_INT 3
97864: PUSH
97865: LD_INT 5
97867: PUSH
97868: EMPTY
97869: LIST
97870: LIST
97871: PUSH
97872: LD_INT 0
97874: PUSH
97875: LD_INT 3
97877: PUSH
97878: EMPTY
97879: LIST
97880: LIST
97881: PUSH
97882: LD_INT 0
97884: PUSH
97885: LD_INT 2
97887: PUSH
97888: EMPTY
97889: LIST
97890: LIST
97891: PUSH
97892: LD_INT 1
97894: PUSH
97895: LD_INT 3
97897: PUSH
97898: EMPTY
97899: LIST
97900: LIST
97901: PUSH
97902: LD_INT 1
97904: PUSH
97905: LD_INT 4
97907: PUSH
97908: EMPTY
97909: LIST
97910: LIST
97911: PUSH
97912: LD_INT 0
97914: PUSH
97915: LD_INT 4
97917: PUSH
97918: EMPTY
97919: LIST
97920: LIST
97921: PUSH
97922: LD_INT 1
97924: NEG
97925: PUSH
97926: LD_INT 3
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: PUSH
97933: LD_INT 1
97935: NEG
97936: PUSH
97937: LD_INT 2
97939: PUSH
97940: EMPTY
97941: LIST
97942: LIST
97943: PUSH
97944: LD_INT 2
97946: PUSH
97947: LD_INT 4
97949: PUSH
97950: EMPTY
97951: LIST
97952: LIST
97953: PUSH
97954: LD_INT 2
97956: NEG
97957: PUSH
97958: LD_INT 2
97960: PUSH
97961: EMPTY
97962: LIST
97963: LIST
97964: PUSH
97965: LD_INT 4
97967: NEG
97968: PUSH
97969: LD_INT 0
97971: PUSH
97972: EMPTY
97973: LIST
97974: LIST
97975: PUSH
97976: LD_INT 4
97978: NEG
97979: PUSH
97980: LD_INT 1
97982: NEG
97983: PUSH
97984: EMPTY
97985: LIST
97986: LIST
97987: PUSH
97988: LD_INT 3
97990: NEG
97991: PUSH
97992: LD_INT 0
97994: PUSH
97995: EMPTY
97996: LIST
97997: LIST
97998: PUSH
97999: LD_INT 3
98001: NEG
98002: PUSH
98003: LD_INT 1
98005: PUSH
98006: EMPTY
98007: LIST
98008: LIST
98009: PUSH
98010: LD_INT 4
98012: NEG
98013: PUSH
98014: LD_INT 1
98016: PUSH
98017: EMPTY
98018: LIST
98019: LIST
98020: PUSH
98021: LD_INT 5
98023: NEG
98024: PUSH
98025: LD_INT 0
98027: PUSH
98028: EMPTY
98029: LIST
98030: LIST
98031: PUSH
98032: LD_INT 5
98034: NEG
98035: PUSH
98036: LD_INT 1
98038: NEG
98039: PUSH
98040: EMPTY
98041: LIST
98042: LIST
98043: PUSH
98044: LD_INT 5
98046: NEG
98047: PUSH
98048: LD_INT 2
98050: NEG
98051: PUSH
98052: EMPTY
98053: LIST
98054: LIST
98055: PUSH
98056: LD_INT 3
98058: NEG
98059: PUSH
98060: LD_INT 2
98062: PUSH
98063: EMPTY
98064: LIST
98065: LIST
98066: PUSH
98067: LD_INT 3
98069: NEG
98070: PUSH
98071: LD_INT 3
98073: NEG
98074: PUSH
98075: EMPTY
98076: LIST
98077: LIST
98078: PUSH
98079: LD_INT 3
98081: NEG
98082: PUSH
98083: LD_INT 4
98085: NEG
98086: PUSH
98087: EMPTY
98088: LIST
98089: LIST
98090: PUSH
98091: LD_INT 2
98093: NEG
98094: PUSH
98095: LD_INT 3
98097: NEG
98098: PUSH
98099: EMPTY
98100: LIST
98101: LIST
98102: PUSH
98103: LD_INT 2
98105: NEG
98106: PUSH
98107: LD_INT 2
98109: NEG
98110: PUSH
98111: EMPTY
98112: LIST
98113: LIST
98114: PUSH
98115: LD_INT 3
98117: NEG
98118: PUSH
98119: LD_INT 2
98121: NEG
98122: PUSH
98123: EMPTY
98124: LIST
98125: LIST
98126: PUSH
98127: LD_INT 4
98129: NEG
98130: PUSH
98131: LD_INT 3
98133: NEG
98134: PUSH
98135: EMPTY
98136: LIST
98137: LIST
98138: PUSH
98139: LD_INT 4
98141: NEG
98142: PUSH
98143: LD_INT 4
98145: NEG
98146: PUSH
98147: EMPTY
98148: LIST
98149: LIST
98150: PUSH
98151: LD_INT 2
98153: NEG
98154: PUSH
98155: LD_INT 4
98157: NEG
98158: PUSH
98159: EMPTY
98160: LIST
98161: LIST
98162: PUSH
98163: LD_INT 4
98165: NEG
98166: PUSH
98167: LD_INT 2
98169: NEG
98170: PUSH
98171: EMPTY
98172: LIST
98173: LIST
98174: PUSH
98175: LD_INT 0
98177: PUSH
98178: LD_INT 4
98180: NEG
98181: PUSH
98182: EMPTY
98183: LIST
98184: LIST
98185: PUSH
98186: LD_INT 0
98188: PUSH
98189: LD_INT 5
98191: NEG
98192: PUSH
98193: EMPTY
98194: LIST
98195: LIST
98196: PUSH
98197: LD_INT 1
98199: PUSH
98200: LD_INT 4
98202: NEG
98203: PUSH
98204: EMPTY
98205: LIST
98206: LIST
98207: PUSH
98208: LD_INT 1
98210: PUSH
98211: LD_INT 3
98213: NEG
98214: PUSH
98215: EMPTY
98216: LIST
98217: LIST
98218: PUSH
98219: LD_INT 0
98221: PUSH
98222: LD_INT 3
98224: NEG
98225: PUSH
98226: EMPTY
98227: LIST
98228: LIST
98229: PUSH
98230: LD_INT 1
98232: NEG
98233: PUSH
98234: LD_INT 4
98236: NEG
98237: PUSH
98238: EMPTY
98239: LIST
98240: LIST
98241: PUSH
98242: LD_INT 1
98244: NEG
98245: PUSH
98246: LD_INT 5
98248: NEG
98249: PUSH
98250: EMPTY
98251: LIST
98252: LIST
98253: PUSH
98254: LD_INT 2
98256: PUSH
98257: LD_INT 3
98259: NEG
98260: PUSH
98261: EMPTY
98262: LIST
98263: LIST
98264: PUSH
98265: LD_INT 2
98267: NEG
98268: PUSH
98269: LD_INT 5
98271: NEG
98272: PUSH
98273: EMPTY
98274: LIST
98275: LIST
98276: PUSH
98277: EMPTY
98278: LIST
98279: LIST
98280: LIST
98281: LIST
98282: LIST
98283: LIST
98284: LIST
98285: LIST
98286: LIST
98287: LIST
98288: LIST
98289: LIST
98290: LIST
98291: LIST
98292: LIST
98293: LIST
98294: LIST
98295: LIST
98296: LIST
98297: LIST
98298: LIST
98299: LIST
98300: LIST
98301: LIST
98302: LIST
98303: LIST
98304: LIST
98305: LIST
98306: LIST
98307: LIST
98308: LIST
98309: LIST
98310: LIST
98311: LIST
98312: LIST
98313: LIST
98314: LIST
98315: LIST
98316: LIST
98317: LIST
98318: LIST
98319: LIST
98320: LIST
98321: LIST
98322: LIST
98323: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
98324: LD_ADDR_VAR 0 31
98328: PUSH
98329: LD_INT 0
98331: PUSH
98332: LD_INT 4
98334: PUSH
98335: EMPTY
98336: LIST
98337: LIST
98338: PUSH
98339: LD_INT 0
98341: PUSH
98342: LD_INT 3
98344: PUSH
98345: EMPTY
98346: LIST
98347: LIST
98348: PUSH
98349: LD_INT 1
98351: PUSH
98352: LD_INT 4
98354: PUSH
98355: EMPTY
98356: LIST
98357: LIST
98358: PUSH
98359: LD_INT 1
98361: PUSH
98362: LD_INT 5
98364: PUSH
98365: EMPTY
98366: LIST
98367: LIST
98368: PUSH
98369: LD_INT 0
98371: PUSH
98372: LD_INT 5
98374: PUSH
98375: EMPTY
98376: LIST
98377: LIST
98378: PUSH
98379: LD_INT 1
98381: NEG
98382: PUSH
98383: LD_INT 4
98385: PUSH
98386: EMPTY
98387: LIST
98388: LIST
98389: PUSH
98390: LD_INT 1
98392: NEG
98393: PUSH
98394: LD_INT 3
98396: PUSH
98397: EMPTY
98398: LIST
98399: LIST
98400: PUSH
98401: LD_INT 2
98403: PUSH
98404: LD_INT 5
98406: PUSH
98407: EMPTY
98408: LIST
98409: LIST
98410: PUSH
98411: LD_INT 2
98413: NEG
98414: PUSH
98415: LD_INT 3
98417: PUSH
98418: EMPTY
98419: LIST
98420: LIST
98421: PUSH
98422: LD_INT 3
98424: NEG
98425: PUSH
98426: LD_INT 0
98428: PUSH
98429: EMPTY
98430: LIST
98431: LIST
98432: PUSH
98433: LD_INT 3
98435: NEG
98436: PUSH
98437: LD_INT 1
98439: NEG
98440: PUSH
98441: EMPTY
98442: LIST
98443: LIST
98444: PUSH
98445: LD_INT 2
98447: NEG
98448: PUSH
98449: LD_INT 0
98451: PUSH
98452: EMPTY
98453: LIST
98454: LIST
98455: PUSH
98456: LD_INT 2
98458: NEG
98459: PUSH
98460: LD_INT 1
98462: PUSH
98463: EMPTY
98464: LIST
98465: LIST
98466: PUSH
98467: LD_INT 3
98469: NEG
98470: PUSH
98471: LD_INT 1
98473: PUSH
98474: EMPTY
98475: LIST
98476: LIST
98477: PUSH
98478: LD_INT 4
98480: NEG
98481: PUSH
98482: LD_INT 0
98484: PUSH
98485: EMPTY
98486: LIST
98487: LIST
98488: PUSH
98489: LD_INT 4
98491: NEG
98492: PUSH
98493: LD_INT 1
98495: NEG
98496: PUSH
98497: EMPTY
98498: LIST
98499: LIST
98500: PUSH
98501: LD_INT 4
98503: NEG
98504: PUSH
98505: LD_INT 2
98507: NEG
98508: PUSH
98509: EMPTY
98510: LIST
98511: LIST
98512: PUSH
98513: LD_INT 2
98515: NEG
98516: PUSH
98517: LD_INT 2
98519: PUSH
98520: EMPTY
98521: LIST
98522: LIST
98523: PUSH
98524: LD_INT 4
98526: NEG
98527: PUSH
98528: LD_INT 4
98530: NEG
98531: PUSH
98532: EMPTY
98533: LIST
98534: LIST
98535: PUSH
98536: LD_INT 4
98538: NEG
98539: PUSH
98540: LD_INT 5
98542: NEG
98543: PUSH
98544: EMPTY
98545: LIST
98546: LIST
98547: PUSH
98548: LD_INT 3
98550: NEG
98551: PUSH
98552: LD_INT 4
98554: NEG
98555: PUSH
98556: EMPTY
98557: LIST
98558: LIST
98559: PUSH
98560: LD_INT 3
98562: NEG
98563: PUSH
98564: LD_INT 3
98566: NEG
98567: PUSH
98568: EMPTY
98569: LIST
98570: LIST
98571: PUSH
98572: LD_INT 4
98574: NEG
98575: PUSH
98576: LD_INT 3
98578: NEG
98579: PUSH
98580: EMPTY
98581: LIST
98582: LIST
98583: PUSH
98584: LD_INT 5
98586: NEG
98587: PUSH
98588: LD_INT 4
98590: NEG
98591: PUSH
98592: EMPTY
98593: LIST
98594: LIST
98595: PUSH
98596: LD_INT 5
98598: NEG
98599: PUSH
98600: LD_INT 5
98602: NEG
98603: PUSH
98604: EMPTY
98605: LIST
98606: LIST
98607: PUSH
98608: LD_INT 3
98610: NEG
98611: PUSH
98612: LD_INT 5
98614: NEG
98615: PUSH
98616: EMPTY
98617: LIST
98618: LIST
98619: PUSH
98620: LD_INT 5
98622: NEG
98623: PUSH
98624: LD_INT 3
98626: NEG
98627: PUSH
98628: EMPTY
98629: LIST
98630: LIST
98631: PUSH
98632: LD_INT 0
98634: PUSH
98635: LD_INT 3
98637: NEG
98638: PUSH
98639: EMPTY
98640: LIST
98641: LIST
98642: PUSH
98643: LD_INT 0
98645: PUSH
98646: LD_INT 4
98648: NEG
98649: PUSH
98650: EMPTY
98651: LIST
98652: LIST
98653: PUSH
98654: LD_INT 1
98656: PUSH
98657: LD_INT 3
98659: NEG
98660: PUSH
98661: EMPTY
98662: LIST
98663: LIST
98664: PUSH
98665: LD_INT 1
98667: PUSH
98668: LD_INT 2
98670: NEG
98671: PUSH
98672: EMPTY
98673: LIST
98674: LIST
98675: PUSH
98676: LD_INT 0
98678: PUSH
98679: LD_INT 2
98681: NEG
98682: PUSH
98683: EMPTY
98684: LIST
98685: LIST
98686: PUSH
98687: LD_INT 1
98689: NEG
98690: PUSH
98691: LD_INT 3
98693: NEG
98694: PUSH
98695: EMPTY
98696: LIST
98697: LIST
98698: PUSH
98699: LD_INT 1
98701: NEG
98702: PUSH
98703: LD_INT 4
98705: NEG
98706: PUSH
98707: EMPTY
98708: LIST
98709: LIST
98710: PUSH
98711: LD_INT 2
98713: PUSH
98714: LD_INT 2
98716: NEG
98717: PUSH
98718: EMPTY
98719: LIST
98720: LIST
98721: PUSH
98722: LD_INT 2
98724: NEG
98725: PUSH
98726: LD_INT 4
98728: NEG
98729: PUSH
98730: EMPTY
98731: LIST
98732: LIST
98733: PUSH
98734: LD_INT 4
98736: PUSH
98737: LD_INT 0
98739: PUSH
98740: EMPTY
98741: LIST
98742: LIST
98743: PUSH
98744: LD_INT 4
98746: PUSH
98747: LD_INT 1
98749: NEG
98750: PUSH
98751: EMPTY
98752: LIST
98753: LIST
98754: PUSH
98755: LD_INT 5
98757: PUSH
98758: LD_INT 0
98760: PUSH
98761: EMPTY
98762: LIST
98763: LIST
98764: PUSH
98765: LD_INT 5
98767: PUSH
98768: LD_INT 1
98770: PUSH
98771: EMPTY
98772: LIST
98773: LIST
98774: PUSH
98775: LD_INT 4
98777: PUSH
98778: LD_INT 1
98780: PUSH
98781: EMPTY
98782: LIST
98783: LIST
98784: PUSH
98785: LD_INT 3
98787: PUSH
98788: LD_INT 0
98790: PUSH
98791: EMPTY
98792: LIST
98793: LIST
98794: PUSH
98795: LD_INT 3
98797: PUSH
98798: LD_INT 1
98800: NEG
98801: PUSH
98802: EMPTY
98803: LIST
98804: LIST
98805: PUSH
98806: LD_INT 3
98808: PUSH
98809: LD_INT 2
98811: NEG
98812: PUSH
98813: EMPTY
98814: LIST
98815: LIST
98816: PUSH
98817: LD_INT 5
98819: PUSH
98820: LD_INT 2
98822: PUSH
98823: EMPTY
98824: LIST
98825: LIST
98826: PUSH
98827: EMPTY
98828: LIST
98829: LIST
98830: LIST
98831: LIST
98832: LIST
98833: LIST
98834: LIST
98835: LIST
98836: LIST
98837: LIST
98838: LIST
98839: LIST
98840: LIST
98841: LIST
98842: LIST
98843: LIST
98844: LIST
98845: LIST
98846: LIST
98847: LIST
98848: LIST
98849: LIST
98850: LIST
98851: LIST
98852: LIST
98853: LIST
98854: LIST
98855: LIST
98856: LIST
98857: LIST
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: LIST
98864: LIST
98865: LIST
98866: LIST
98867: LIST
98868: LIST
98869: LIST
98870: LIST
98871: LIST
98872: LIST
98873: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
98874: LD_ADDR_VAR 0 32
98878: PUSH
98879: LD_INT 4
98881: NEG
98882: PUSH
98883: LD_INT 0
98885: PUSH
98886: EMPTY
98887: LIST
98888: LIST
98889: PUSH
98890: LD_INT 4
98892: NEG
98893: PUSH
98894: LD_INT 1
98896: NEG
98897: PUSH
98898: EMPTY
98899: LIST
98900: LIST
98901: PUSH
98902: LD_INT 3
98904: NEG
98905: PUSH
98906: LD_INT 0
98908: PUSH
98909: EMPTY
98910: LIST
98911: LIST
98912: PUSH
98913: LD_INT 3
98915: NEG
98916: PUSH
98917: LD_INT 1
98919: PUSH
98920: EMPTY
98921: LIST
98922: LIST
98923: PUSH
98924: LD_INT 4
98926: NEG
98927: PUSH
98928: LD_INT 1
98930: PUSH
98931: EMPTY
98932: LIST
98933: LIST
98934: PUSH
98935: LD_INT 5
98937: NEG
98938: PUSH
98939: LD_INT 0
98941: PUSH
98942: EMPTY
98943: LIST
98944: LIST
98945: PUSH
98946: LD_INT 5
98948: NEG
98949: PUSH
98950: LD_INT 1
98952: NEG
98953: PUSH
98954: EMPTY
98955: LIST
98956: LIST
98957: PUSH
98958: LD_INT 5
98960: NEG
98961: PUSH
98962: LD_INT 2
98964: NEG
98965: PUSH
98966: EMPTY
98967: LIST
98968: LIST
98969: PUSH
98970: LD_INT 3
98972: NEG
98973: PUSH
98974: LD_INT 2
98976: PUSH
98977: EMPTY
98978: LIST
98979: LIST
98980: PUSH
98981: LD_INT 3
98983: NEG
98984: PUSH
98985: LD_INT 3
98987: NEG
98988: PUSH
98989: EMPTY
98990: LIST
98991: LIST
98992: PUSH
98993: LD_INT 3
98995: NEG
98996: PUSH
98997: LD_INT 4
98999: NEG
99000: PUSH
99001: EMPTY
99002: LIST
99003: LIST
99004: PUSH
99005: LD_INT 2
99007: NEG
99008: PUSH
99009: LD_INT 3
99011: NEG
99012: PUSH
99013: EMPTY
99014: LIST
99015: LIST
99016: PUSH
99017: LD_INT 2
99019: NEG
99020: PUSH
99021: LD_INT 2
99023: NEG
99024: PUSH
99025: EMPTY
99026: LIST
99027: LIST
99028: PUSH
99029: LD_INT 3
99031: NEG
99032: PUSH
99033: LD_INT 2
99035: NEG
99036: PUSH
99037: EMPTY
99038: LIST
99039: LIST
99040: PUSH
99041: LD_INT 4
99043: NEG
99044: PUSH
99045: LD_INT 3
99047: NEG
99048: PUSH
99049: EMPTY
99050: LIST
99051: LIST
99052: PUSH
99053: LD_INT 4
99055: NEG
99056: PUSH
99057: LD_INT 4
99059: NEG
99060: PUSH
99061: EMPTY
99062: LIST
99063: LIST
99064: PUSH
99065: LD_INT 2
99067: NEG
99068: PUSH
99069: LD_INT 4
99071: NEG
99072: PUSH
99073: EMPTY
99074: LIST
99075: LIST
99076: PUSH
99077: LD_INT 4
99079: NEG
99080: PUSH
99081: LD_INT 2
99083: NEG
99084: PUSH
99085: EMPTY
99086: LIST
99087: LIST
99088: PUSH
99089: LD_INT 0
99091: PUSH
99092: LD_INT 4
99094: NEG
99095: PUSH
99096: EMPTY
99097: LIST
99098: LIST
99099: PUSH
99100: LD_INT 0
99102: PUSH
99103: LD_INT 5
99105: NEG
99106: PUSH
99107: EMPTY
99108: LIST
99109: LIST
99110: PUSH
99111: LD_INT 1
99113: PUSH
99114: LD_INT 4
99116: NEG
99117: PUSH
99118: EMPTY
99119: LIST
99120: LIST
99121: PUSH
99122: LD_INT 1
99124: PUSH
99125: LD_INT 3
99127: NEG
99128: PUSH
99129: EMPTY
99130: LIST
99131: LIST
99132: PUSH
99133: LD_INT 0
99135: PUSH
99136: LD_INT 3
99138: NEG
99139: PUSH
99140: EMPTY
99141: LIST
99142: LIST
99143: PUSH
99144: LD_INT 1
99146: NEG
99147: PUSH
99148: LD_INT 4
99150: NEG
99151: PUSH
99152: EMPTY
99153: LIST
99154: LIST
99155: PUSH
99156: LD_INT 1
99158: NEG
99159: PUSH
99160: LD_INT 5
99162: NEG
99163: PUSH
99164: EMPTY
99165: LIST
99166: LIST
99167: PUSH
99168: LD_INT 2
99170: PUSH
99171: LD_INT 3
99173: NEG
99174: PUSH
99175: EMPTY
99176: LIST
99177: LIST
99178: PUSH
99179: LD_INT 2
99181: NEG
99182: PUSH
99183: LD_INT 5
99185: NEG
99186: PUSH
99187: EMPTY
99188: LIST
99189: LIST
99190: PUSH
99191: LD_INT 3
99193: PUSH
99194: LD_INT 0
99196: PUSH
99197: EMPTY
99198: LIST
99199: LIST
99200: PUSH
99201: LD_INT 3
99203: PUSH
99204: LD_INT 1
99206: NEG
99207: PUSH
99208: EMPTY
99209: LIST
99210: LIST
99211: PUSH
99212: LD_INT 4
99214: PUSH
99215: LD_INT 0
99217: PUSH
99218: EMPTY
99219: LIST
99220: LIST
99221: PUSH
99222: LD_INT 4
99224: PUSH
99225: LD_INT 1
99227: PUSH
99228: EMPTY
99229: LIST
99230: LIST
99231: PUSH
99232: LD_INT 3
99234: PUSH
99235: LD_INT 1
99237: PUSH
99238: EMPTY
99239: LIST
99240: LIST
99241: PUSH
99242: LD_INT 2
99244: PUSH
99245: LD_INT 0
99247: PUSH
99248: EMPTY
99249: LIST
99250: LIST
99251: PUSH
99252: LD_INT 2
99254: PUSH
99255: LD_INT 1
99257: NEG
99258: PUSH
99259: EMPTY
99260: LIST
99261: LIST
99262: PUSH
99263: LD_INT 2
99265: PUSH
99266: LD_INT 2
99268: NEG
99269: PUSH
99270: EMPTY
99271: LIST
99272: LIST
99273: PUSH
99274: LD_INT 4
99276: PUSH
99277: LD_INT 2
99279: PUSH
99280: EMPTY
99281: LIST
99282: LIST
99283: PUSH
99284: LD_INT 4
99286: PUSH
99287: LD_INT 4
99289: PUSH
99290: EMPTY
99291: LIST
99292: LIST
99293: PUSH
99294: LD_INT 4
99296: PUSH
99297: LD_INT 3
99299: PUSH
99300: EMPTY
99301: LIST
99302: LIST
99303: PUSH
99304: LD_INT 5
99306: PUSH
99307: LD_INT 4
99309: PUSH
99310: EMPTY
99311: LIST
99312: LIST
99313: PUSH
99314: LD_INT 5
99316: PUSH
99317: LD_INT 5
99319: PUSH
99320: EMPTY
99321: LIST
99322: LIST
99323: PUSH
99324: LD_INT 4
99326: PUSH
99327: LD_INT 5
99329: PUSH
99330: EMPTY
99331: LIST
99332: LIST
99333: PUSH
99334: LD_INT 3
99336: PUSH
99337: LD_INT 4
99339: PUSH
99340: EMPTY
99341: LIST
99342: LIST
99343: PUSH
99344: LD_INT 3
99346: PUSH
99347: LD_INT 3
99349: PUSH
99350: EMPTY
99351: LIST
99352: LIST
99353: PUSH
99354: LD_INT 5
99356: PUSH
99357: LD_INT 3
99359: PUSH
99360: EMPTY
99361: LIST
99362: LIST
99363: PUSH
99364: LD_INT 3
99366: PUSH
99367: LD_INT 5
99369: PUSH
99370: EMPTY
99371: LIST
99372: LIST
99373: PUSH
99374: EMPTY
99375: LIST
99376: LIST
99377: LIST
99378: LIST
99379: LIST
99380: LIST
99381: LIST
99382: LIST
99383: LIST
99384: LIST
99385: LIST
99386: LIST
99387: LIST
99388: LIST
99389: LIST
99390: LIST
99391: LIST
99392: LIST
99393: LIST
99394: LIST
99395: LIST
99396: LIST
99397: LIST
99398: LIST
99399: LIST
99400: LIST
99401: LIST
99402: LIST
99403: LIST
99404: LIST
99405: LIST
99406: LIST
99407: LIST
99408: LIST
99409: LIST
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: LIST
99415: LIST
99416: LIST
99417: LIST
99418: LIST
99419: LIST
99420: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
99421: LD_ADDR_VAR 0 33
99425: PUSH
99426: LD_INT 4
99428: NEG
99429: PUSH
99430: LD_INT 4
99432: NEG
99433: PUSH
99434: EMPTY
99435: LIST
99436: LIST
99437: PUSH
99438: LD_INT 4
99440: NEG
99441: PUSH
99442: LD_INT 5
99444: NEG
99445: PUSH
99446: EMPTY
99447: LIST
99448: LIST
99449: PUSH
99450: LD_INT 3
99452: NEG
99453: PUSH
99454: LD_INT 4
99456: NEG
99457: PUSH
99458: EMPTY
99459: LIST
99460: LIST
99461: PUSH
99462: LD_INT 3
99464: NEG
99465: PUSH
99466: LD_INT 3
99468: NEG
99469: PUSH
99470: EMPTY
99471: LIST
99472: LIST
99473: PUSH
99474: LD_INT 4
99476: NEG
99477: PUSH
99478: LD_INT 3
99480: NEG
99481: PUSH
99482: EMPTY
99483: LIST
99484: LIST
99485: PUSH
99486: LD_INT 5
99488: NEG
99489: PUSH
99490: LD_INT 4
99492: NEG
99493: PUSH
99494: EMPTY
99495: LIST
99496: LIST
99497: PUSH
99498: LD_INT 5
99500: NEG
99501: PUSH
99502: LD_INT 5
99504: NEG
99505: PUSH
99506: EMPTY
99507: LIST
99508: LIST
99509: PUSH
99510: LD_INT 3
99512: NEG
99513: PUSH
99514: LD_INT 5
99516: NEG
99517: PUSH
99518: EMPTY
99519: LIST
99520: LIST
99521: PUSH
99522: LD_INT 5
99524: NEG
99525: PUSH
99526: LD_INT 3
99528: NEG
99529: PUSH
99530: EMPTY
99531: LIST
99532: LIST
99533: PUSH
99534: LD_INT 0
99536: PUSH
99537: LD_INT 3
99539: NEG
99540: PUSH
99541: EMPTY
99542: LIST
99543: LIST
99544: PUSH
99545: LD_INT 0
99547: PUSH
99548: LD_INT 4
99550: NEG
99551: PUSH
99552: EMPTY
99553: LIST
99554: LIST
99555: PUSH
99556: LD_INT 1
99558: PUSH
99559: LD_INT 3
99561: NEG
99562: PUSH
99563: EMPTY
99564: LIST
99565: LIST
99566: PUSH
99567: LD_INT 1
99569: PUSH
99570: LD_INT 2
99572: NEG
99573: PUSH
99574: EMPTY
99575: LIST
99576: LIST
99577: PUSH
99578: LD_INT 0
99580: PUSH
99581: LD_INT 2
99583: NEG
99584: PUSH
99585: EMPTY
99586: LIST
99587: LIST
99588: PUSH
99589: LD_INT 1
99591: NEG
99592: PUSH
99593: LD_INT 3
99595: NEG
99596: PUSH
99597: EMPTY
99598: LIST
99599: LIST
99600: PUSH
99601: LD_INT 1
99603: NEG
99604: PUSH
99605: LD_INT 4
99607: NEG
99608: PUSH
99609: EMPTY
99610: LIST
99611: LIST
99612: PUSH
99613: LD_INT 2
99615: PUSH
99616: LD_INT 2
99618: NEG
99619: PUSH
99620: EMPTY
99621: LIST
99622: LIST
99623: PUSH
99624: LD_INT 2
99626: NEG
99627: PUSH
99628: LD_INT 4
99630: NEG
99631: PUSH
99632: EMPTY
99633: LIST
99634: LIST
99635: PUSH
99636: LD_INT 4
99638: PUSH
99639: LD_INT 0
99641: PUSH
99642: EMPTY
99643: LIST
99644: LIST
99645: PUSH
99646: LD_INT 4
99648: PUSH
99649: LD_INT 1
99651: NEG
99652: PUSH
99653: EMPTY
99654: LIST
99655: LIST
99656: PUSH
99657: LD_INT 5
99659: PUSH
99660: LD_INT 0
99662: PUSH
99663: EMPTY
99664: LIST
99665: LIST
99666: PUSH
99667: LD_INT 5
99669: PUSH
99670: LD_INT 1
99672: PUSH
99673: EMPTY
99674: LIST
99675: LIST
99676: PUSH
99677: LD_INT 4
99679: PUSH
99680: LD_INT 1
99682: PUSH
99683: EMPTY
99684: LIST
99685: LIST
99686: PUSH
99687: LD_INT 3
99689: PUSH
99690: LD_INT 0
99692: PUSH
99693: EMPTY
99694: LIST
99695: LIST
99696: PUSH
99697: LD_INT 3
99699: PUSH
99700: LD_INT 1
99702: NEG
99703: PUSH
99704: EMPTY
99705: LIST
99706: LIST
99707: PUSH
99708: LD_INT 3
99710: PUSH
99711: LD_INT 2
99713: NEG
99714: PUSH
99715: EMPTY
99716: LIST
99717: LIST
99718: PUSH
99719: LD_INT 5
99721: PUSH
99722: LD_INT 2
99724: PUSH
99725: EMPTY
99726: LIST
99727: LIST
99728: PUSH
99729: LD_INT 3
99731: PUSH
99732: LD_INT 3
99734: PUSH
99735: EMPTY
99736: LIST
99737: LIST
99738: PUSH
99739: LD_INT 3
99741: PUSH
99742: LD_INT 2
99744: PUSH
99745: EMPTY
99746: LIST
99747: LIST
99748: PUSH
99749: LD_INT 4
99751: PUSH
99752: LD_INT 3
99754: PUSH
99755: EMPTY
99756: LIST
99757: LIST
99758: PUSH
99759: LD_INT 4
99761: PUSH
99762: LD_INT 4
99764: PUSH
99765: EMPTY
99766: LIST
99767: LIST
99768: PUSH
99769: LD_INT 3
99771: PUSH
99772: LD_INT 4
99774: PUSH
99775: EMPTY
99776: LIST
99777: LIST
99778: PUSH
99779: LD_INT 2
99781: PUSH
99782: LD_INT 3
99784: PUSH
99785: EMPTY
99786: LIST
99787: LIST
99788: PUSH
99789: LD_INT 2
99791: PUSH
99792: LD_INT 2
99794: PUSH
99795: EMPTY
99796: LIST
99797: LIST
99798: PUSH
99799: LD_INT 4
99801: PUSH
99802: LD_INT 2
99804: PUSH
99805: EMPTY
99806: LIST
99807: LIST
99808: PUSH
99809: LD_INT 2
99811: PUSH
99812: LD_INT 4
99814: PUSH
99815: EMPTY
99816: LIST
99817: LIST
99818: PUSH
99819: LD_INT 0
99821: PUSH
99822: LD_INT 4
99824: PUSH
99825: EMPTY
99826: LIST
99827: LIST
99828: PUSH
99829: LD_INT 0
99831: PUSH
99832: LD_INT 3
99834: PUSH
99835: EMPTY
99836: LIST
99837: LIST
99838: PUSH
99839: LD_INT 1
99841: PUSH
99842: LD_INT 4
99844: PUSH
99845: EMPTY
99846: LIST
99847: LIST
99848: PUSH
99849: LD_INT 1
99851: PUSH
99852: LD_INT 5
99854: PUSH
99855: EMPTY
99856: LIST
99857: LIST
99858: PUSH
99859: LD_INT 0
99861: PUSH
99862: LD_INT 5
99864: PUSH
99865: EMPTY
99866: LIST
99867: LIST
99868: PUSH
99869: LD_INT 1
99871: NEG
99872: PUSH
99873: LD_INT 4
99875: PUSH
99876: EMPTY
99877: LIST
99878: LIST
99879: PUSH
99880: LD_INT 1
99882: NEG
99883: PUSH
99884: LD_INT 3
99886: PUSH
99887: EMPTY
99888: LIST
99889: LIST
99890: PUSH
99891: LD_INT 2
99893: PUSH
99894: LD_INT 5
99896: PUSH
99897: EMPTY
99898: LIST
99899: LIST
99900: PUSH
99901: LD_INT 2
99903: NEG
99904: PUSH
99905: LD_INT 3
99907: PUSH
99908: EMPTY
99909: LIST
99910: LIST
99911: PUSH
99912: EMPTY
99913: LIST
99914: LIST
99915: LIST
99916: LIST
99917: LIST
99918: LIST
99919: LIST
99920: LIST
99921: LIST
99922: LIST
99923: LIST
99924: LIST
99925: LIST
99926: LIST
99927: LIST
99928: LIST
99929: LIST
99930: LIST
99931: LIST
99932: LIST
99933: LIST
99934: LIST
99935: LIST
99936: LIST
99937: LIST
99938: LIST
99939: LIST
99940: LIST
99941: LIST
99942: LIST
99943: LIST
99944: LIST
99945: LIST
99946: LIST
99947: LIST
99948: LIST
99949: LIST
99950: LIST
99951: LIST
99952: LIST
99953: LIST
99954: LIST
99955: LIST
99956: LIST
99957: LIST
99958: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
99959: LD_ADDR_VAR 0 34
99963: PUSH
99964: LD_INT 0
99966: PUSH
99967: LD_INT 4
99969: NEG
99970: PUSH
99971: EMPTY
99972: LIST
99973: LIST
99974: PUSH
99975: LD_INT 0
99977: PUSH
99978: LD_INT 5
99980: NEG
99981: PUSH
99982: EMPTY
99983: LIST
99984: LIST
99985: PUSH
99986: LD_INT 1
99988: PUSH
99989: LD_INT 4
99991: NEG
99992: PUSH
99993: EMPTY
99994: LIST
99995: LIST
99996: PUSH
99997: LD_INT 1
99999: PUSH
100000: LD_INT 3
100002: NEG
100003: PUSH
100004: EMPTY
100005: LIST
100006: LIST
100007: PUSH
100008: LD_INT 0
100010: PUSH
100011: LD_INT 3
100013: NEG
100014: PUSH
100015: EMPTY
100016: LIST
100017: LIST
100018: PUSH
100019: LD_INT 1
100021: NEG
100022: PUSH
100023: LD_INT 4
100025: NEG
100026: PUSH
100027: EMPTY
100028: LIST
100029: LIST
100030: PUSH
100031: LD_INT 1
100033: NEG
100034: PUSH
100035: LD_INT 5
100037: NEG
100038: PUSH
100039: EMPTY
100040: LIST
100041: LIST
100042: PUSH
100043: LD_INT 2
100045: PUSH
100046: LD_INT 3
100048: NEG
100049: PUSH
100050: EMPTY
100051: LIST
100052: LIST
100053: PUSH
100054: LD_INT 2
100056: NEG
100057: PUSH
100058: LD_INT 5
100060: NEG
100061: PUSH
100062: EMPTY
100063: LIST
100064: LIST
100065: PUSH
100066: LD_INT 3
100068: PUSH
100069: LD_INT 0
100071: PUSH
100072: EMPTY
100073: LIST
100074: LIST
100075: PUSH
100076: LD_INT 3
100078: PUSH
100079: LD_INT 1
100081: NEG
100082: PUSH
100083: EMPTY
100084: LIST
100085: LIST
100086: PUSH
100087: LD_INT 4
100089: PUSH
100090: LD_INT 0
100092: PUSH
100093: EMPTY
100094: LIST
100095: LIST
100096: PUSH
100097: LD_INT 4
100099: PUSH
100100: LD_INT 1
100102: PUSH
100103: EMPTY
100104: LIST
100105: LIST
100106: PUSH
100107: LD_INT 3
100109: PUSH
100110: LD_INT 1
100112: PUSH
100113: EMPTY
100114: LIST
100115: LIST
100116: PUSH
100117: LD_INT 2
100119: PUSH
100120: LD_INT 0
100122: PUSH
100123: EMPTY
100124: LIST
100125: LIST
100126: PUSH
100127: LD_INT 2
100129: PUSH
100130: LD_INT 1
100132: NEG
100133: PUSH
100134: EMPTY
100135: LIST
100136: LIST
100137: PUSH
100138: LD_INT 2
100140: PUSH
100141: LD_INT 2
100143: NEG
100144: PUSH
100145: EMPTY
100146: LIST
100147: LIST
100148: PUSH
100149: LD_INT 4
100151: PUSH
100152: LD_INT 2
100154: PUSH
100155: EMPTY
100156: LIST
100157: LIST
100158: PUSH
100159: LD_INT 4
100161: PUSH
100162: LD_INT 4
100164: PUSH
100165: EMPTY
100166: LIST
100167: LIST
100168: PUSH
100169: LD_INT 4
100171: PUSH
100172: LD_INT 3
100174: PUSH
100175: EMPTY
100176: LIST
100177: LIST
100178: PUSH
100179: LD_INT 5
100181: PUSH
100182: LD_INT 4
100184: PUSH
100185: EMPTY
100186: LIST
100187: LIST
100188: PUSH
100189: LD_INT 5
100191: PUSH
100192: LD_INT 5
100194: PUSH
100195: EMPTY
100196: LIST
100197: LIST
100198: PUSH
100199: LD_INT 4
100201: PUSH
100202: LD_INT 5
100204: PUSH
100205: EMPTY
100206: LIST
100207: LIST
100208: PUSH
100209: LD_INT 3
100211: PUSH
100212: LD_INT 4
100214: PUSH
100215: EMPTY
100216: LIST
100217: LIST
100218: PUSH
100219: LD_INT 3
100221: PUSH
100222: LD_INT 3
100224: PUSH
100225: EMPTY
100226: LIST
100227: LIST
100228: PUSH
100229: LD_INT 5
100231: PUSH
100232: LD_INT 3
100234: PUSH
100235: EMPTY
100236: LIST
100237: LIST
100238: PUSH
100239: LD_INT 3
100241: PUSH
100242: LD_INT 5
100244: PUSH
100245: EMPTY
100246: LIST
100247: LIST
100248: PUSH
100249: LD_INT 0
100251: PUSH
100252: LD_INT 3
100254: PUSH
100255: EMPTY
100256: LIST
100257: LIST
100258: PUSH
100259: LD_INT 0
100261: PUSH
100262: LD_INT 2
100264: PUSH
100265: EMPTY
100266: LIST
100267: LIST
100268: PUSH
100269: LD_INT 1
100271: PUSH
100272: LD_INT 3
100274: PUSH
100275: EMPTY
100276: LIST
100277: LIST
100278: PUSH
100279: LD_INT 1
100281: PUSH
100282: LD_INT 4
100284: PUSH
100285: EMPTY
100286: LIST
100287: LIST
100288: PUSH
100289: LD_INT 0
100291: PUSH
100292: LD_INT 4
100294: PUSH
100295: EMPTY
100296: LIST
100297: LIST
100298: PUSH
100299: LD_INT 1
100301: NEG
100302: PUSH
100303: LD_INT 3
100305: PUSH
100306: EMPTY
100307: LIST
100308: LIST
100309: PUSH
100310: LD_INT 1
100312: NEG
100313: PUSH
100314: LD_INT 2
100316: PUSH
100317: EMPTY
100318: LIST
100319: LIST
100320: PUSH
100321: LD_INT 2
100323: PUSH
100324: LD_INT 4
100326: PUSH
100327: EMPTY
100328: LIST
100329: LIST
100330: PUSH
100331: LD_INT 2
100333: NEG
100334: PUSH
100335: LD_INT 2
100337: PUSH
100338: EMPTY
100339: LIST
100340: LIST
100341: PUSH
100342: LD_INT 4
100344: NEG
100345: PUSH
100346: LD_INT 0
100348: PUSH
100349: EMPTY
100350: LIST
100351: LIST
100352: PUSH
100353: LD_INT 4
100355: NEG
100356: PUSH
100357: LD_INT 1
100359: NEG
100360: PUSH
100361: EMPTY
100362: LIST
100363: LIST
100364: PUSH
100365: LD_INT 3
100367: NEG
100368: PUSH
100369: LD_INT 0
100371: PUSH
100372: EMPTY
100373: LIST
100374: LIST
100375: PUSH
100376: LD_INT 3
100378: NEG
100379: PUSH
100380: LD_INT 1
100382: PUSH
100383: EMPTY
100384: LIST
100385: LIST
100386: PUSH
100387: LD_INT 4
100389: NEG
100390: PUSH
100391: LD_INT 1
100393: PUSH
100394: EMPTY
100395: LIST
100396: LIST
100397: PUSH
100398: LD_INT 5
100400: NEG
100401: PUSH
100402: LD_INT 0
100404: PUSH
100405: EMPTY
100406: LIST
100407: LIST
100408: PUSH
100409: LD_INT 5
100411: NEG
100412: PUSH
100413: LD_INT 1
100415: NEG
100416: PUSH
100417: EMPTY
100418: LIST
100419: LIST
100420: PUSH
100421: LD_INT 5
100423: NEG
100424: PUSH
100425: LD_INT 2
100427: NEG
100428: PUSH
100429: EMPTY
100430: LIST
100431: LIST
100432: PUSH
100433: LD_INT 3
100435: NEG
100436: PUSH
100437: LD_INT 2
100439: PUSH
100440: EMPTY
100441: LIST
100442: LIST
100443: PUSH
100444: EMPTY
100445: LIST
100446: LIST
100447: LIST
100448: LIST
100449: LIST
100450: LIST
100451: LIST
100452: LIST
100453: LIST
100454: LIST
100455: LIST
100456: LIST
100457: LIST
100458: LIST
100459: LIST
100460: LIST
100461: LIST
100462: LIST
100463: LIST
100464: LIST
100465: LIST
100466: LIST
100467: LIST
100468: LIST
100469: LIST
100470: LIST
100471: LIST
100472: LIST
100473: LIST
100474: LIST
100475: LIST
100476: LIST
100477: LIST
100478: LIST
100479: LIST
100480: LIST
100481: LIST
100482: LIST
100483: LIST
100484: LIST
100485: LIST
100486: LIST
100487: LIST
100488: LIST
100489: LIST
100490: ST_TO_ADDR
// end ; end ;
100491: GO 100494
100493: POP
// case btype of b_depot , b_warehouse :
100494: LD_VAR 0 1
100498: PUSH
100499: LD_INT 0
100501: DOUBLE
100502: EQUAL
100503: IFTRUE 100513
100505: LD_INT 1
100507: DOUBLE
100508: EQUAL
100509: IFTRUE 100513
100511: GO 100714
100513: POP
// case nation of nation_american :
100514: LD_VAR 0 5
100518: PUSH
100519: LD_INT 1
100521: DOUBLE
100522: EQUAL
100523: IFTRUE 100527
100525: GO 100583
100527: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
100528: LD_ADDR_VAR 0 9
100532: PUSH
100533: LD_VAR 0 11
100537: PUSH
100538: LD_VAR 0 12
100542: PUSH
100543: LD_VAR 0 13
100547: PUSH
100548: LD_VAR 0 14
100552: PUSH
100553: LD_VAR 0 15
100557: PUSH
100558: LD_VAR 0 16
100562: PUSH
100563: EMPTY
100564: LIST
100565: LIST
100566: LIST
100567: LIST
100568: LIST
100569: LIST
100570: PUSH
100571: LD_VAR 0 4
100575: PUSH
100576: LD_INT 1
100578: PLUS
100579: ARRAY
100580: ST_TO_ADDR
100581: GO 100712
100583: LD_INT 2
100585: DOUBLE
100586: EQUAL
100587: IFTRUE 100591
100589: GO 100647
100591: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
100592: LD_ADDR_VAR 0 9
100596: PUSH
100597: LD_VAR 0 17
100601: PUSH
100602: LD_VAR 0 18
100606: PUSH
100607: LD_VAR 0 19
100611: PUSH
100612: LD_VAR 0 20
100616: PUSH
100617: LD_VAR 0 21
100621: PUSH
100622: LD_VAR 0 22
100626: PUSH
100627: EMPTY
100628: LIST
100629: LIST
100630: LIST
100631: LIST
100632: LIST
100633: LIST
100634: PUSH
100635: LD_VAR 0 4
100639: PUSH
100640: LD_INT 1
100642: PLUS
100643: ARRAY
100644: ST_TO_ADDR
100645: GO 100712
100647: LD_INT 3
100649: DOUBLE
100650: EQUAL
100651: IFTRUE 100655
100653: GO 100711
100655: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
100656: LD_ADDR_VAR 0 9
100660: PUSH
100661: LD_VAR 0 23
100665: PUSH
100666: LD_VAR 0 24
100670: PUSH
100671: LD_VAR 0 25
100675: PUSH
100676: LD_VAR 0 26
100680: PUSH
100681: LD_VAR 0 27
100685: PUSH
100686: LD_VAR 0 28
100690: PUSH
100691: EMPTY
100692: LIST
100693: LIST
100694: LIST
100695: LIST
100696: LIST
100697: LIST
100698: PUSH
100699: LD_VAR 0 4
100703: PUSH
100704: LD_INT 1
100706: PLUS
100707: ARRAY
100708: ST_TO_ADDR
100709: GO 100712
100711: POP
100712: GO 101267
100714: LD_INT 2
100716: DOUBLE
100717: EQUAL
100718: IFTRUE 100728
100720: LD_INT 3
100722: DOUBLE
100723: EQUAL
100724: IFTRUE 100728
100726: GO 100784
100728: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
100729: LD_ADDR_VAR 0 9
100733: PUSH
100734: LD_VAR 0 29
100738: PUSH
100739: LD_VAR 0 30
100743: PUSH
100744: LD_VAR 0 31
100748: PUSH
100749: LD_VAR 0 32
100753: PUSH
100754: LD_VAR 0 33
100758: PUSH
100759: LD_VAR 0 34
100763: PUSH
100764: EMPTY
100765: LIST
100766: LIST
100767: LIST
100768: LIST
100769: LIST
100770: LIST
100771: PUSH
100772: LD_VAR 0 4
100776: PUSH
100777: LD_INT 1
100779: PLUS
100780: ARRAY
100781: ST_TO_ADDR
100782: GO 101267
100784: LD_INT 16
100786: DOUBLE
100787: EQUAL
100788: IFTRUE 100846
100790: LD_INT 17
100792: DOUBLE
100793: EQUAL
100794: IFTRUE 100846
100796: LD_INT 18
100798: DOUBLE
100799: EQUAL
100800: IFTRUE 100846
100802: LD_INT 19
100804: DOUBLE
100805: EQUAL
100806: IFTRUE 100846
100808: LD_INT 22
100810: DOUBLE
100811: EQUAL
100812: IFTRUE 100846
100814: LD_INT 20
100816: DOUBLE
100817: EQUAL
100818: IFTRUE 100846
100820: LD_INT 21
100822: DOUBLE
100823: EQUAL
100824: IFTRUE 100846
100826: LD_INT 23
100828: DOUBLE
100829: EQUAL
100830: IFTRUE 100846
100832: LD_INT 24
100834: DOUBLE
100835: EQUAL
100836: IFTRUE 100846
100838: LD_INT 25
100840: DOUBLE
100841: EQUAL
100842: IFTRUE 100846
100844: GO 100902
100846: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
100847: LD_ADDR_VAR 0 9
100851: PUSH
100852: LD_VAR 0 35
100856: PUSH
100857: LD_VAR 0 36
100861: PUSH
100862: LD_VAR 0 37
100866: PUSH
100867: LD_VAR 0 38
100871: PUSH
100872: LD_VAR 0 39
100876: PUSH
100877: LD_VAR 0 40
100881: PUSH
100882: EMPTY
100883: LIST
100884: LIST
100885: LIST
100886: LIST
100887: LIST
100888: LIST
100889: PUSH
100890: LD_VAR 0 4
100894: PUSH
100895: LD_INT 1
100897: PLUS
100898: ARRAY
100899: ST_TO_ADDR
100900: GO 101267
100902: LD_INT 6
100904: DOUBLE
100905: EQUAL
100906: IFTRUE 100958
100908: LD_INT 7
100910: DOUBLE
100911: EQUAL
100912: IFTRUE 100958
100914: LD_INT 8
100916: DOUBLE
100917: EQUAL
100918: IFTRUE 100958
100920: LD_INT 13
100922: DOUBLE
100923: EQUAL
100924: IFTRUE 100958
100926: LD_INT 12
100928: DOUBLE
100929: EQUAL
100930: IFTRUE 100958
100932: LD_INT 15
100934: DOUBLE
100935: EQUAL
100936: IFTRUE 100958
100938: LD_INT 11
100940: DOUBLE
100941: EQUAL
100942: IFTRUE 100958
100944: LD_INT 14
100946: DOUBLE
100947: EQUAL
100948: IFTRUE 100958
100950: LD_INT 10
100952: DOUBLE
100953: EQUAL
100954: IFTRUE 100958
100956: GO 101014
100958: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
100959: LD_ADDR_VAR 0 9
100963: PUSH
100964: LD_VAR 0 41
100968: PUSH
100969: LD_VAR 0 42
100973: PUSH
100974: LD_VAR 0 43
100978: PUSH
100979: LD_VAR 0 44
100983: PUSH
100984: LD_VAR 0 45
100988: PUSH
100989: LD_VAR 0 46
100993: PUSH
100994: EMPTY
100995: LIST
100996: LIST
100997: LIST
100998: LIST
100999: LIST
101000: LIST
101001: PUSH
101002: LD_VAR 0 4
101006: PUSH
101007: LD_INT 1
101009: PLUS
101010: ARRAY
101011: ST_TO_ADDR
101012: GO 101267
101014: LD_INT 36
101016: DOUBLE
101017: EQUAL
101018: IFTRUE 101022
101020: GO 101078
101022: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
101023: LD_ADDR_VAR 0 9
101027: PUSH
101028: LD_VAR 0 47
101032: PUSH
101033: LD_VAR 0 48
101037: PUSH
101038: LD_VAR 0 49
101042: PUSH
101043: LD_VAR 0 50
101047: PUSH
101048: LD_VAR 0 51
101052: PUSH
101053: LD_VAR 0 52
101057: PUSH
101058: EMPTY
101059: LIST
101060: LIST
101061: LIST
101062: LIST
101063: LIST
101064: LIST
101065: PUSH
101066: LD_VAR 0 4
101070: PUSH
101071: LD_INT 1
101073: PLUS
101074: ARRAY
101075: ST_TO_ADDR
101076: GO 101267
101078: LD_INT 4
101080: DOUBLE
101081: EQUAL
101082: IFTRUE 101104
101084: LD_INT 5
101086: DOUBLE
101087: EQUAL
101088: IFTRUE 101104
101090: LD_INT 34
101092: DOUBLE
101093: EQUAL
101094: IFTRUE 101104
101096: LD_INT 37
101098: DOUBLE
101099: EQUAL
101100: IFTRUE 101104
101102: GO 101160
101104: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
101105: LD_ADDR_VAR 0 9
101109: PUSH
101110: LD_VAR 0 53
101114: PUSH
101115: LD_VAR 0 54
101119: PUSH
101120: LD_VAR 0 55
101124: PUSH
101125: LD_VAR 0 56
101129: PUSH
101130: LD_VAR 0 57
101134: PUSH
101135: LD_VAR 0 58
101139: PUSH
101140: EMPTY
101141: LIST
101142: LIST
101143: LIST
101144: LIST
101145: LIST
101146: LIST
101147: PUSH
101148: LD_VAR 0 4
101152: PUSH
101153: LD_INT 1
101155: PLUS
101156: ARRAY
101157: ST_TO_ADDR
101158: GO 101267
101160: LD_INT 31
101162: DOUBLE
101163: EQUAL
101164: IFTRUE 101210
101166: LD_INT 32
101168: DOUBLE
101169: EQUAL
101170: IFTRUE 101210
101172: LD_INT 33
101174: DOUBLE
101175: EQUAL
101176: IFTRUE 101210
101178: LD_INT 27
101180: DOUBLE
101181: EQUAL
101182: IFTRUE 101210
101184: LD_INT 26
101186: DOUBLE
101187: EQUAL
101188: IFTRUE 101210
101190: LD_INT 28
101192: DOUBLE
101193: EQUAL
101194: IFTRUE 101210
101196: LD_INT 29
101198: DOUBLE
101199: EQUAL
101200: IFTRUE 101210
101202: LD_INT 30
101204: DOUBLE
101205: EQUAL
101206: IFTRUE 101210
101208: GO 101266
101210: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
101211: LD_ADDR_VAR 0 9
101215: PUSH
101216: LD_VAR 0 59
101220: PUSH
101221: LD_VAR 0 60
101225: PUSH
101226: LD_VAR 0 61
101230: PUSH
101231: LD_VAR 0 62
101235: PUSH
101236: LD_VAR 0 63
101240: PUSH
101241: LD_VAR 0 64
101245: PUSH
101246: EMPTY
101247: LIST
101248: LIST
101249: LIST
101250: LIST
101251: LIST
101252: LIST
101253: PUSH
101254: LD_VAR 0 4
101258: PUSH
101259: LD_INT 1
101261: PLUS
101262: ARRAY
101263: ST_TO_ADDR
101264: GO 101267
101266: POP
// temp_list2 = [ ] ;
101267: LD_ADDR_VAR 0 10
101271: PUSH
101272: EMPTY
101273: ST_TO_ADDR
// for i in temp_list do
101274: LD_ADDR_VAR 0 8
101278: PUSH
101279: LD_VAR 0 9
101283: PUSH
101284: FOR_IN
101285: IFFALSE 101337
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
101287: LD_ADDR_VAR 0 10
101291: PUSH
101292: LD_VAR 0 10
101296: PUSH
101297: LD_VAR 0 8
101301: PUSH
101302: LD_INT 1
101304: ARRAY
101305: PUSH
101306: LD_VAR 0 2
101310: PLUS
101311: PUSH
101312: LD_VAR 0 8
101316: PUSH
101317: LD_INT 2
101319: ARRAY
101320: PUSH
101321: LD_VAR 0 3
101325: PLUS
101326: PUSH
101327: EMPTY
101328: LIST
101329: LIST
101330: PUSH
101331: EMPTY
101332: LIST
101333: ADD
101334: ST_TO_ADDR
101335: GO 101284
101337: POP
101338: POP
// result = temp_list2 ;
101339: LD_ADDR_VAR 0 7
101343: PUSH
101344: LD_VAR 0 10
101348: ST_TO_ADDR
// end ;
101349: LD_VAR 0 7
101353: RET
// export function EnemyInRange ( unit , dist ) ; begin
101354: LD_INT 0
101356: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
101357: LD_ADDR_VAR 0 3
101361: PUSH
101362: LD_VAR 0 1
101366: PPUSH
101367: CALL_OW 255
101371: PPUSH
101372: LD_VAR 0 1
101376: PPUSH
101377: CALL_OW 250
101381: PPUSH
101382: LD_VAR 0 1
101386: PPUSH
101387: CALL_OW 251
101391: PPUSH
101392: LD_VAR 0 2
101396: PPUSH
101397: CALL 74756 0 4
101401: PUSH
101402: LD_INT 4
101404: ARRAY
101405: ST_TO_ADDR
// end ;
101406: LD_VAR 0 3
101410: RET
// export function PlayerSeeMe ( unit ) ; begin
101411: LD_INT 0
101413: PPUSH
// result := See ( your_side , unit ) ;
101414: LD_ADDR_VAR 0 2
101418: PUSH
101419: LD_OWVAR 2
101423: PPUSH
101424: LD_VAR 0 1
101428: PPUSH
101429: CALL_OW 292
101433: ST_TO_ADDR
// end ;
101434: LD_VAR 0 2
101438: RET
// export function ReverseDir ( unit ) ; begin
101439: LD_INT 0
101441: PPUSH
// if not unit then
101442: LD_VAR 0 1
101446: NOT
101447: IFFALSE 101451
// exit ;
101449: GO 101474
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
101451: LD_ADDR_VAR 0 2
101455: PUSH
101456: LD_VAR 0 1
101460: PPUSH
101461: CALL_OW 254
101465: PUSH
101466: LD_INT 3
101468: PLUS
101469: PUSH
101470: LD_INT 6
101472: MOD
101473: ST_TO_ADDR
// end ;
101474: LD_VAR 0 2
101478: RET
// export function ReverseArray ( array ) ; var i ; begin
101479: LD_INT 0
101481: PPUSH
101482: PPUSH
// if not array then
101483: LD_VAR 0 1
101487: NOT
101488: IFFALSE 101492
// exit ;
101490: GO 101547
// result := [ ] ;
101492: LD_ADDR_VAR 0 2
101496: PUSH
101497: EMPTY
101498: ST_TO_ADDR
// for i := array downto 1 do
101499: LD_ADDR_VAR 0 3
101503: PUSH
101504: DOUBLE
101505: LD_VAR 0 1
101509: INC
101510: ST_TO_ADDR
101511: LD_INT 1
101513: PUSH
101514: FOR_DOWNTO
101515: IFFALSE 101545
// result := Join ( result , array [ i ] ) ;
101517: LD_ADDR_VAR 0 2
101521: PUSH
101522: LD_VAR 0 2
101526: PPUSH
101527: LD_VAR 0 1
101531: PUSH
101532: LD_VAR 0 3
101536: ARRAY
101537: PPUSH
101538: CALL 106190 0 2
101542: ST_TO_ADDR
101543: GO 101514
101545: POP
101546: POP
// end ;
101547: LD_VAR 0 2
101551: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
101552: LD_INT 0
101554: PPUSH
101555: PPUSH
101556: PPUSH
101557: PPUSH
101558: PPUSH
101559: PPUSH
// if not unit or not hexes then
101560: LD_VAR 0 1
101564: NOT
101565: PUSH
101566: LD_VAR 0 2
101570: NOT
101571: OR
101572: IFFALSE 101576
// exit ;
101574: GO 101699
// dist := 9999 ;
101576: LD_ADDR_VAR 0 5
101580: PUSH
101581: LD_INT 9999
101583: ST_TO_ADDR
// for i = 1 to hexes do
101584: LD_ADDR_VAR 0 4
101588: PUSH
101589: DOUBLE
101590: LD_INT 1
101592: DEC
101593: ST_TO_ADDR
101594: LD_VAR 0 2
101598: PUSH
101599: FOR_TO
101600: IFFALSE 101687
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
101602: LD_ADDR_VAR 0 6
101606: PUSH
101607: LD_VAR 0 1
101611: PPUSH
101612: LD_VAR 0 2
101616: PUSH
101617: LD_VAR 0 4
101621: ARRAY
101622: PUSH
101623: LD_INT 1
101625: ARRAY
101626: PPUSH
101627: LD_VAR 0 2
101631: PUSH
101632: LD_VAR 0 4
101636: ARRAY
101637: PUSH
101638: LD_INT 2
101640: ARRAY
101641: PPUSH
101642: CALL_OW 297
101646: ST_TO_ADDR
// if tdist < dist then
101647: LD_VAR 0 6
101651: PUSH
101652: LD_VAR 0 5
101656: LESS
101657: IFFALSE 101685
// begin hex := hexes [ i ] ;
101659: LD_ADDR_VAR 0 8
101663: PUSH
101664: LD_VAR 0 2
101668: PUSH
101669: LD_VAR 0 4
101673: ARRAY
101674: ST_TO_ADDR
// dist := tdist ;
101675: LD_ADDR_VAR 0 5
101679: PUSH
101680: LD_VAR 0 6
101684: ST_TO_ADDR
// end ; end ;
101685: GO 101599
101687: POP
101688: POP
// result := hex ;
101689: LD_ADDR_VAR 0 3
101693: PUSH
101694: LD_VAR 0 8
101698: ST_TO_ADDR
// end ;
101699: LD_VAR 0 3
101703: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
101704: LD_INT 0
101706: PPUSH
101707: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
101708: LD_VAR 0 1
101712: NOT
101713: PUSH
101714: LD_VAR 0 1
101718: PUSH
101719: LD_INT 21
101721: PUSH
101722: LD_INT 2
101724: PUSH
101725: EMPTY
101726: LIST
101727: LIST
101728: PUSH
101729: LD_INT 23
101731: PUSH
101732: LD_INT 2
101734: PUSH
101735: EMPTY
101736: LIST
101737: LIST
101738: PUSH
101739: EMPTY
101740: LIST
101741: LIST
101742: PPUSH
101743: CALL_OW 69
101747: IN
101748: NOT
101749: OR
101750: IFFALSE 101754
// exit ;
101752: GO 101801
// for i = 1 to 3 do
101754: LD_ADDR_VAR 0 3
101758: PUSH
101759: DOUBLE
101760: LD_INT 1
101762: DEC
101763: ST_TO_ADDR
101764: LD_INT 3
101766: PUSH
101767: FOR_TO
101768: IFFALSE 101799
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
101770: LD_VAR 0 1
101774: PPUSH
101775: CALL_OW 250
101779: PPUSH
101780: LD_VAR 0 1
101784: PPUSH
101785: CALL_OW 251
101789: PPUSH
101790: LD_INT 1
101792: PPUSH
101793: CALL_OW 453
101797: GO 101767
101799: POP
101800: POP
// end ;
101801: LD_VAR 0 2
101805: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
101806: LD_INT 0
101808: PPUSH
101809: PPUSH
101810: PPUSH
101811: PPUSH
101812: PPUSH
101813: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
101814: LD_VAR 0 1
101818: NOT
101819: PUSH
101820: LD_VAR 0 2
101824: NOT
101825: OR
101826: PUSH
101827: LD_VAR 0 1
101831: PPUSH
101832: CALL_OW 314
101836: OR
101837: IFFALSE 101841
// exit ;
101839: GO 102308
// if GetLives ( i ) < 250 then
101841: LD_VAR 0 4
101845: PPUSH
101846: CALL_OW 256
101850: PUSH
101851: LD_INT 250
101853: LESS
101854: IFFALSE 101867
// begin ComAutodestruct ( i ) ;
101856: LD_VAR 0 4
101860: PPUSH
101861: CALL 101704 0 1
// exit ;
101865: GO 102308
// end ; x := GetX ( enemy_unit ) ;
101867: LD_ADDR_VAR 0 7
101871: PUSH
101872: LD_VAR 0 2
101876: PPUSH
101877: CALL_OW 250
101881: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
101882: LD_ADDR_VAR 0 8
101886: PUSH
101887: LD_VAR 0 2
101891: PPUSH
101892: CALL_OW 251
101896: ST_TO_ADDR
// if not x or not y then
101897: LD_VAR 0 7
101901: NOT
101902: PUSH
101903: LD_VAR 0 8
101907: NOT
101908: OR
101909: IFFALSE 101913
// exit ;
101911: GO 102308
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
101913: LD_ADDR_VAR 0 6
101917: PUSH
101918: LD_VAR 0 7
101922: PPUSH
101923: LD_INT 0
101925: PPUSH
101926: LD_INT 4
101928: PPUSH
101929: CALL_OW 272
101933: PUSH
101934: LD_VAR 0 8
101938: PPUSH
101939: LD_INT 0
101941: PPUSH
101942: LD_INT 4
101944: PPUSH
101945: CALL_OW 273
101949: PUSH
101950: EMPTY
101951: LIST
101952: LIST
101953: PUSH
101954: LD_VAR 0 7
101958: PPUSH
101959: LD_INT 1
101961: PPUSH
101962: LD_INT 4
101964: PPUSH
101965: CALL_OW 272
101969: PUSH
101970: LD_VAR 0 8
101974: PPUSH
101975: LD_INT 1
101977: PPUSH
101978: LD_INT 4
101980: PPUSH
101981: CALL_OW 273
101985: PUSH
101986: EMPTY
101987: LIST
101988: LIST
101989: PUSH
101990: LD_VAR 0 7
101994: PPUSH
101995: LD_INT 2
101997: PPUSH
101998: LD_INT 4
102000: PPUSH
102001: CALL_OW 272
102005: PUSH
102006: LD_VAR 0 8
102010: PPUSH
102011: LD_INT 2
102013: PPUSH
102014: LD_INT 4
102016: PPUSH
102017: CALL_OW 273
102021: PUSH
102022: EMPTY
102023: LIST
102024: LIST
102025: PUSH
102026: LD_VAR 0 7
102030: PPUSH
102031: LD_INT 3
102033: PPUSH
102034: LD_INT 4
102036: PPUSH
102037: CALL_OW 272
102041: PUSH
102042: LD_VAR 0 8
102046: PPUSH
102047: LD_INT 3
102049: PPUSH
102050: LD_INT 4
102052: PPUSH
102053: CALL_OW 273
102057: PUSH
102058: EMPTY
102059: LIST
102060: LIST
102061: PUSH
102062: LD_VAR 0 7
102066: PPUSH
102067: LD_INT 4
102069: PPUSH
102070: LD_INT 4
102072: PPUSH
102073: CALL_OW 272
102077: PUSH
102078: LD_VAR 0 8
102082: PPUSH
102083: LD_INT 4
102085: PPUSH
102086: LD_INT 4
102088: PPUSH
102089: CALL_OW 273
102093: PUSH
102094: EMPTY
102095: LIST
102096: LIST
102097: PUSH
102098: LD_VAR 0 7
102102: PPUSH
102103: LD_INT 5
102105: PPUSH
102106: LD_INT 4
102108: PPUSH
102109: CALL_OW 272
102113: PUSH
102114: LD_VAR 0 8
102118: PPUSH
102119: LD_INT 5
102121: PPUSH
102122: LD_INT 4
102124: PPUSH
102125: CALL_OW 273
102129: PUSH
102130: EMPTY
102131: LIST
102132: LIST
102133: PUSH
102134: EMPTY
102135: LIST
102136: LIST
102137: LIST
102138: LIST
102139: LIST
102140: LIST
102141: ST_TO_ADDR
// for i = tmp downto 1 do
102142: LD_ADDR_VAR 0 4
102146: PUSH
102147: DOUBLE
102148: LD_VAR 0 6
102152: INC
102153: ST_TO_ADDR
102154: LD_INT 1
102156: PUSH
102157: FOR_DOWNTO
102158: IFFALSE 102259
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
102160: LD_VAR 0 6
102164: PUSH
102165: LD_VAR 0 4
102169: ARRAY
102170: PUSH
102171: LD_INT 1
102173: ARRAY
102174: PPUSH
102175: LD_VAR 0 6
102179: PUSH
102180: LD_VAR 0 4
102184: ARRAY
102185: PUSH
102186: LD_INT 2
102188: ARRAY
102189: PPUSH
102190: CALL_OW 488
102194: NOT
102195: PUSH
102196: LD_VAR 0 6
102200: PUSH
102201: LD_VAR 0 4
102205: ARRAY
102206: PUSH
102207: LD_INT 1
102209: ARRAY
102210: PPUSH
102211: LD_VAR 0 6
102215: PUSH
102216: LD_VAR 0 4
102220: ARRAY
102221: PUSH
102222: LD_INT 2
102224: ARRAY
102225: PPUSH
102226: CALL_OW 428
102230: PUSH
102231: LD_INT 0
102233: NONEQUAL
102234: OR
102235: IFFALSE 102257
// tmp := Delete ( tmp , i ) ;
102237: LD_ADDR_VAR 0 6
102241: PUSH
102242: LD_VAR 0 6
102246: PPUSH
102247: LD_VAR 0 4
102251: PPUSH
102252: CALL_OW 3
102256: ST_TO_ADDR
102257: GO 102157
102259: POP
102260: POP
// j := GetClosestHex ( unit , tmp ) ;
102261: LD_ADDR_VAR 0 5
102265: PUSH
102266: LD_VAR 0 1
102270: PPUSH
102271: LD_VAR 0 6
102275: PPUSH
102276: CALL 101552 0 2
102280: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
102281: LD_VAR 0 1
102285: PPUSH
102286: LD_VAR 0 5
102290: PUSH
102291: LD_INT 1
102293: ARRAY
102294: PPUSH
102295: LD_VAR 0 5
102299: PUSH
102300: LD_INT 2
102302: ARRAY
102303: PPUSH
102304: CALL_OW 111
// end ;
102308: LD_VAR 0 3
102312: RET
// export function PrepareApemanSoldier ( ) ; begin
102313: LD_INT 0
102315: PPUSH
// uc_nation := 0 ;
102316: LD_ADDR_OWVAR 21
102320: PUSH
102321: LD_INT 0
102323: ST_TO_ADDR
// hc_sex := sex_male ;
102324: LD_ADDR_OWVAR 27
102328: PUSH
102329: LD_INT 1
102331: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
102332: LD_ADDR_OWVAR 28
102336: PUSH
102337: LD_INT 15
102339: ST_TO_ADDR
// hc_gallery :=  ;
102340: LD_ADDR_OWVAR 33
102344: PUSH
102345: LD_STRING 
102347: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
102348: LD_ADDR_OWVAR 31
102352: PUSH
102353: LD_INT 0
102355: PPUSH
102356: LD_INT 3
102358: PPUSH
102359: CALL_OW 12
102363: PUSH
102364: LD_INT 0
102366: PPUSH
102367: LD_INT 3
102369: PPUSH
102370: CALL_OW 12
102374: PUSH
102375: LD_INT 0
102377: PUSH
102378: LD_INT 0
102380: PUSH
102381: EMPTY
102382: LIST
102383: LIST
102384: LIST
102385: LIST
102386: ST_TO_ADDR
// end ;
102387: LD_VAR 0 1
102391: RET
// export function PrepareApemanEngineer ( ) ; begin
102392: LD_INT 0
102394: PPUSH
// uc_nation := 0 ;
102395: LD_ADDR_OWVAR 21
102399: PUSH
102400: LD_INT 0
102402: ST_TO_ADDR
// hc_sex := sex_male ;
102403: LD_ADDR_OWVAR 27
102407: PUSH
102408: LD_INT 1
102410: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
102411: LD_ADDR_OWVAR 28
102415: PUSH
102416: LD_INT 16
102418: ST_TO_ADDR
// hc_gallery :=  ;
102419: LD_ADDR_OWVAR 33
102423: PUSH
102424: LD_STRING 
102426: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
102427: LD_ADDR_OWVAR 31
102431: PUSH
102432: LD_INT 0
102434: PPUSH
102435: LD_INT 3
102437: PPUSH
102438: CALL_OW 12
102442: PUSH
102443: LD_INT 0
102445: PPUSH
102446: LD_INT 3
102448: PPUSH
102449: CALL_OW 12
102453: PUSH
102454: LD_INT 0
102456: PUSH
102457: LD_INT 0
102459: PUSH
102460: EMPTY
102461: LIST
102462: LIST
102463: LIST
102464: LIST
102465: ST_TO_ADDR
// end ;
102466: LD_VAR 0 1
102470: RET
// export function PrepareApeman ( agressivity ) ; begin
102471: LD_INT 0
102473: PPUSH
// uc_side := 0 ;
102474: LD_ADDR_OWVAR 20
102478: PUSH
102479: LD_INT 0
102481: ST_TO_ADDR
// uc_nation := 0 ;
102482: LD_ADDR_OWVAR 21
102486: PUSH
102487: LD_INT 0
102489: ST_TO_ADDR
// hc_sex := sex_male ;
102490: LD_ADDR_OWVAR 27
102494: PUSH
102495: LD_INT 1
102497: ST_TO_ADDR
// hc_class := class_apeman ;
102498: LD_ADDR_OWVAR 28
102502: PUSH
102503: LD_INT 12
102505: ST_TO_ADDR
// hc_gallery :=  ;
102506: LD_ADDR_OWVAR 33
102510: PUSH
102511: LD_STRING 
102513: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
102514: LD_ADDR_OWVAR 35
102518: PUSH
102519: LD_VAR 0 1
102523: NEG
102524: PPUSH
102525: LD_VAR 0 1
102529: PPUSH
102530: CALL_OW 12
102534: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
102535: LD_ADDR_OWVAR 31
102539: PUSH
102540: LD_INT 0
102542: PPUSH
102543: LD_INT 3
102545: PPUSH
102546: CALL_OW 12
102550: PUSH
102551: LD_INT 0
102553: PPUSH
102554: LD_INT 3
102556: PPUSH
102557: CALL_OW 12
102561: PUSH
102562: LD_INT 0
102564: PUSH
102565: LD_INT 0
102567: PUSH
102568: EMPTY
102569: LIST
102570: LIST
102571: LIST
102572: LIST
102573: ST_TO_ADDR
// end ;
102574: LD_VAR 0 2
102578: RET
// export function PrepareTiger ( agressivity ) ; begin
102579: LD_INT 0
102581: PPUSH
// uc_side := 0 ;
102582: LD_ADDR_OWVAR 20
102586: PUSH
102587: LD_INT 0
102589: ST_TO_ADDR
// uc_nation := 0 ;
102590: LD_ADDR_OWVAR 21
102594: PUSH
102595: LD_INT 0
102597: ST_TO_ADDR
// hc_class := class_tiger ;
102598: LD_ADDR_OWVAR 28
102602: PUSH
102603: LD_INT 14
102605: ST_TO_ADDR
// hc_gallery :=  ;
102606: LD_ADDR_OWVAR 33
102610: PUSH
102611: LD_STRING 
102613: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
102614: LD_ADDR_OWVAR 35
102618: PUSH
102619: LD_VAR 0 1
102623: NEG
102624: PPUSH
102625: LD_VAR 0 1
102629: PPUSH
102630: CALL_OW 12
102634: ST_TO_ADDR
// end ;
102635: LD_VAR 0 2
102639: RET
// export function PrepareEnchidna ( ) ; begin
102640: LD_INT 0
102642: PPUSH
// uc_side := 0 ;
102643: LD_ADDR_OWVAR 20
102647: PUSH
102648: LD_INT 0
102650: ST_TO_ADDR
// uc_nation := 0 ;
102651: LD_ADDR_OWVAR 21
102655: PUSH
102656: LD_INT 0
102658: ST_TO_ADDR
// hc_class := class_baggie ;
102659: LD_ADDR_OWVAR 28
102663: PUSH
102664: LD_INT 13
102666: ST_TO_ADDR
// hc_gallery :=  ;
102667: LD_ADDR_OWVAR 33
102671: PUSH
102672: LD_STRING 
102674: ST_TO_ADDR
// end ;
102675: LD_VAR 0 1
102679: RET
// export function PrepareFrog ( ) ; begin
102680: LD_INT 0
102682: PPUSH
// uc_side := 0 ;
102683: LD_ADDR_OWVAR 20
102687: PUSH
102688: LD_INT 0
102690: ST_TO_ADDR
// uc_nation := 0 ;
102691: LD_ADDR_OWVAR 21
102695: PUSH
102696: LD_INT 0
102698: ST_TO_ADDR
// hc_class := class_frog ;
102699: LD_ADDR_OWVAR 28
102703: PUSH
102704: LD_INT 19
102706: ST_TO_ADDR
// hc_gallery :=  ;
102707: LD_ADDR_OWVAR 33
102711: PUSH
102712: LD_STRING 
102714: ST_TO_ADDR
// end ;
102715: LD_VAR 0 1
102719: RET
// export function PrepareFish ( ) ; begin
102720: LD_INT 0
102722: PPUSH
// uc_side := 0 ;
102723: LD_ADDR_OWVAR 20
102727: PUSH
102728: LD_INT 0
102730: ST_TO_ADDR
// uc_nation := 0 ;
102731: LD_ADDR_OWVAR 21
102735: PUSH
102736: LD_INT 0
102738: ST_TO_ADDR
// hc_class := class_fish ;
102739: LD_ADDR_OWVAR 28
102743: PUSH
102744: LD_INT 20
102746: ST_TO_ADDR
// hc_gallery :=  ;
102747: LD_ADDR_OWVAR 33
102751: PUSH
102752: LD_STRING 
102754: ST_TO_ADDR
// end ;
102755: LD_VAR 0 1
102759: RET
// export function PrepareBird ( ) ; begin
102760: LD_INT 0
102762: PPUSH
// uc_side := 0 ;
102763: LD_ADDR_OWVAR 20
102767: PUSH
102768: LD_INT 0
102770: ST_TO_ADDR
// uc_nation := 0 ;
102771: LD_ADDR_OWVAR 21
102775: PUSH
102776: LD_INT 0
102778: ST_TO_ADDR
// hc_class := class_phororhacos ;
102779: LD_ADDR_OWVAR 28
102783: PUSH
102784: LD_INT 18
102786: ST_TO_ADDR
// hc_gallery :=  ;
102787: LD_ADDR_OWVAR 33
102791: PUSH
102792: LD_STRING 
102794: ST_TO_ADDR
// end ;
102795: LD_VAR 0 1
102799: RET
// export function PrepareHorse ( ) ; begin
102800: LD_INT 0
102802: PPUSH
// uc_side := 0 ;
102803: LD_ADDR_OWVAR 20
102807: PUSH
102808: LD_INT 0
102810: ST_TO_ADDR
// uc_nation := 0 ;
102811: LD_ADDR_OWVAR 21
102815: PUSH
102816: LD_INT 0
102818: ST_TO_ADDR
// hc_class := class_horse ;
102819: LD_ADDR_OWVAR 28
102823: PUSH
102824: LD_INT 21
102826: ST_TO_ADDR
// hc_gallery :=  ;
102827: LD_ADDR_OWVAR 33
102831: PUSH
102832: LD_STRING 
102834: ST_TO_ADDR
// end ;
102835: LD_VAR 0 1
102839: RET
// export function PrepareMastodont ( ) ; begin
102840: LD_INT 0
102842: PPUSH
// uc_side := 0 ;
102843: LD_ADDR_OWVAR 20
102847: PUSH
102848: LD_INT 0
102850: ST_TO_ADDR
// uc_nation := 0 ;
102851: LD_ADDR_OWVAR 21
102855: PUSH
102856: LD_INT 0
102858: ST_TO_ADDR
// vc_chassis := class_mastodont ;
102859: LD_ADDR_OWVAR 37
102863: PUSH
102864: LD_INT 31
102866: ST_TO_ADDR
// vc_control := control_rider ;
102867: LD_ADDR_OWVAR 38
102871: PUSH
102872: LD_INT 4
102874: ST_TO_ADDR
// end ;
102875: LD_VAR 0 1
102879: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
102880: LD_INT 0
102882: PPUSH
102883: PPUSH
102884: PPUSH
// uc_side = 0 ;
102885: LD_ADDR_OWVAR 20
102889: PUSH
102890: LD_INT 0
102892: ST_TO_ADDR
// uc_nation = 0 ;
102893: LD_ADDR_OWVAR 21
102897: PUSH
102898: LD_INT 0
102900: ST_TO_ADDR
// InitHc_All ( ) ;
102901: CALL_OW 584
// InitVc ;
102905: CALL_OW 20
// if mastodonts then
102909: LD_VAR 0 6
102913: IFFALSE 102980
// for i = 1 to mastodonts do
102915: LD_ADDR_VAR 0 11
102919: PUSH
102920: DOUBLE
102921: LD_INT 1
102923: DEC
102924: ST_TO_ADDR
102925: LD_VAR 0 6
102929: PUSH
102930: FOR_TO
102931: IFFALSE 102978
// begin vc_chassis := 31 ;
102933: LD_ADDR_OWVAR 37
102937: PUSH
102938: LD_INT 31
102940: ST_TO_ADDR
// vc_control := control_rider ;
102941: LD_ADDR_OWVAR 38
102945: PUSH
102946: LD_INT 4
102948: ST_TO_ADDR
// animal := CreateVehicle ;
102949: LD_ADDR_VAR 0 12
102953: PUSH
102954: CALL_OW 45
102958: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
102959: LD_VAR 0 12
102963: PPUSH
102964: LD_VAR 0 8
102968: PPUSH
102969: LD_INT 0
102971: PPUSH
102972: CALL 105108 0 3
// end ;
102976: GO 102930
102978: POP
102979: POP
// if horses then
102980: LD_VAR 0 5
102984: IFFALSE 103051
// for i = 1 to horses do
102986: LD_ADDR_VAR 0 11
102990: PUSH
102991: DOUBLE
102992: LD_INT 1
102994: DEC
102995: ST_TO_ADDR
102996: LD_VAR 0 5
103000: PUSH
103001: FOR_TO
103002: IFFALSE 103049
// begin hc_class := 21 ;
103004: LD_ADDR_OWVAR 28
103008: PUSH
103009: LD_INT 21
103011: ST_TO_ADDR
// hc_gallery :=  ;
103012: LD_ADDR_OWVAR 33
103016: PUSH
103017: LD_STRING 
103019: ST_TO_ADDR
// animal := CreateHuman ;
103020: LD_ADDR_VAR 0 12
103024: PUSH
103025: CALL_OW 44
103029: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103030: LD_VAR 0 12
103034: PPUSH
103035: LD_VAR 0 8
103039: PPUSH
103040: LD_INT 0
103042: PPUSH
103043: CALL 105108 0 3
// end ;
103047: GO 103001
103049: POP
103050: POP
// if birds then
103051: LD_VAR 0 1
103055: IFFALSE 103122
// for i = 1 to birds do
103057: LD_ADDR_VAR 0 11
103061: PUSH
103062: DOUBLE
103063: LD_INT 1
103065: DEC
103066: ST_TO_ADDR
103067: LD_VAR 0 1
103071: PUSH
103072: FOR_TO
103073: IFFALSE 103120
// begin hc_class = 18 ;
103075: LD_ADDR_OWVAR 28
103079: PUSH
103080: LD_INT 18
103082: ST_TO_ADDR
// hc_gallery =  ;
103083: LD_ADDR_OWVAR 33
103087: PUSH
103088: LD_STRING 
103090: ST_TO_ADDR
// animal := CreateHuman ;
103091: LD_ADDR_VAR 0 12
103095: PUSH
103096: CALL_OW 44
103100: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103101: LD_VAR 0 12
103105: PPUSH
103106: LD_VAR 0 8
103110: PPUSH
103111: LD_INT 0
103113: PPUSH
103114: CALL 105108 0 3
// end ;
103118: GO 103072
103120: POP
103121: POP
// if tigers then
103122: LD_VAR 0 2
103126: IFFALSE 103210
// for i = 1 to tigers do
103128: LD_ADDR_VAR 0 11
103132: PUSH
103133: DOUBLE
103134: LD_INT 1
103136: DEC
103137: ST_TO_ADDR
103138: LD_VAR 0 2
103142: PUSH
103143: FOR_TO
103144: IFFALSE 103208
// begin hc_class = class_tiger ;
103146: LD_ADDR_OWVAR 28
103150: PUSH
103151: LD_INT 14
103153: ST_TO_ADDR
// hc_gallery =  ;
103154: LD_ADDR_OWVAR 33
103158: PUSH
103159: LD_STRING 
103161: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
103162: LD_ADDR_OWVAR 35
103166: PUSH
103167: LD_INT 7
103169: NEG
103170: PPUSH
103171: LD_INT 7
103173: PPUSH
103174: CALL_OW 12
103178: ST_TO_ADDR
// animal := CreateHuman ;
103179: LD_ADDR_VAR 0 12
103183: PUSH
103184: CALL_OW 44
103188: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103189: LD_VAR 0 12
103193: PPUSH
103194: LD_VAR 0 8
103198: PPUSH
103199: LD_INT 0
103201: PPUSH
103202: CALL 105108 0 3
// end ;
103206: GO 103143
103208: POP
103209: POP
// if apemans then
103210: LD_VAR 0 3
103214: IFFALSE 103337
// for i = 1 to apemans do
103216: LD_ADDR_VAR 0 11
103220: PUSH
103221: DOUBLE
103222: LD_INT 1
103224: DEC
103225: ST_TO_ADDR
103226: LD_VAR 0 3
103230: PUSH
103231: FOR_TO
103232: IFFALSE 103335
// begin hc_class = class_apeman ;
103234: LD_ADDR_OWVAR 28
103238: PUSH
103239: LD_INT 12
103241: ST_TO_ADDR
// hc_gallery =  ;
103242: LD_ADDR_OWVAR 33
103246: PUSH
103247: LD_STRING 
103249: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
103250: LD_ADDR_OWVAR 35
103254: PUSH
103255: LD_INT 2
103257: NEG
103258: PPUSH
103259: LD_INT 2
103261: PPUSH
103262: CALL_OW 12
103266: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
103267: LD_ADDR_OWVAR 31
103271: PUSH
103272: LD_INT 1
103274: PPUSH
103275: LD_INT 3
103277: PPUSH
103278: CALL_OW 12
103282: PUSH
103283: LD_INT 1
103285: PPUSH
103286: LD_INT 3
103288: PPUSH
103289: CALL_OW 12
103293: PUSH
103294: LD_INT 0
103296: PUSH
103297: LD_INT 0
103299: PUSH
103300: EMPTY
103301: LIST
103302: LIST
103303: LIST
103304: LIST
103305: ST_TO_ADDR
// animal := CreateHuman ;
103306: LD_ADDR_VAR 0 12
103310: PUSH
103311: CALL_OW 44
103315: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103316: LD_VAR 0 12
103320: PPUSH
103321: LD_VAR 0 8
103325: PPUSH
103326: LD_INT 0
103328: PPUSH
103329: CALL 105108 0 3
// end ;
103333: GO 103231
103335: POP
103336: POP
// if enchidnas then
103337: LD_VAR 0 4
103341: IFFALSE 103408
// for i = 1 to enchidnas do
103343: LD_ADDR_VAR 0 11
103347: PUSH
103348: DOUBLE
103349: LD_INT 1
103351: DEC
103352: ST_TO_ADDR
103353: LD_VAR 0 4
103357: PUSH
103358: FOR_TO
103359: IFFALSE 103406
// begin hc_class = 13 ;
103361: LD_ADDR_OWVAR 28
103365: PUSH
103366: LD_INT 13
103368: ST_TO_ADDR
// hc_gallery =  ;
103369: LD_ADDR_OWVAR 33
103373: PUSH
103374: LD_STRING 
103376: ST_TO_ADDR
// animal := CreateHuman ;
103377: LD_ADDR_VAR 0 12
103381: PUSH
103382: CALL_OW 44
103386: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
103387: LD_VAR 0 12
103391: PPUSH
103392: LD_VAR 0 8
103396: PPUSH
103397: LD_INT 0
103399: PPUSH
103400: CALL 105108 0 3
// end ;
103404: GO 103358
103406: POP
103407: POP
// if fishes then
103408: LD_VAR 0 7
103412: IFFALSE 103479
// for i = 1 to fishes do
103414: LD_ADDR_VAR 0 11
103418: PUSH
103419: DOUBLE
103420: LD_INT 1
103422: DEC
103423: ST_TO_ADDR
103424: LD_VAR 0 7
103428: PUSH
103429: FOR_TO
103430: IFFALSE 103477
// begin hc_class = 20 ;
103432: LD_ADDR_OWVAR 28
103436: PUSH
103437: LD_INT 20
103439: ST_TO_ADDR
// hc_gallery =  ;
103440: LD_ADDR_OWVAR 33
103444: PUSH
103445: LD_STRING 
103447: ST_TO_ADDR
// animal := CreateHuman ;
103448: LD_ADDR_VAR 0 12
103452: PUSH
103453: CALL_OW 44
103457: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
103458: LD_VAR 0 12
103462: PPUSH
103463: LD_VAR 0 9
103467: PPUSH
103468: LD_INT 0
103470: PPUSH
103471: CALL 105108 0 3
// end ;
103475: GO 103429
103477: POP
103478: POP
// end ;
103479: LD_VAR 0 10
103483: RET
// export function WantHeal ( sci , unit ) ; begin
103484: LD_INT 0
103486: PPUSH
// if GetTaskList ( sci ) > 0 then
103487: LD_VAR 0 1
103491: PPUSH
103492: CALL_OW 437
103496: PUSH
103497: LD_INT 0
103499: GREATER
103500: IFFALSE 103570
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
103502: LD_VAR 0 1
103506: PPUSH
103507: CALL_OW 437
103511: PUSH
103512: LD_INT 1
103514: ARRAY
103515: PUSH
103516: LD_INT 1
103518: ARRAY
103519: PUSH
103520: LD_STRING l
103522: EQUAL
103523: PUSH
103524: LD_VAR 0 1
103528: PPUSH
103529: CALL_OW 437
103533: PUSH
103534: LD_INT 1
103536: ARRAY
103537: PUSH
103538: LD_INT 4
103540: ARRAY
103541: PUSH
103542: LD_VAR 0 2
103546: EQUAL
103547: AND
103548: IFFALSE 103560
// result := true else
103550: LD_ADDR_VAR 0 3
103554: PUSH
103555: LD_INT 1
103557: ST_TO_ADDR
103558: GO 103568
// result := false ;
103560: LD_ADDR_VAR 0 3
103564: PUSH
103565: LD_INT 0
103567: ST_TO_ADDR
// end else
103568: GO 103578
// result := false ;
103570: LD_ADDR_VAR 0 3
103574: PUSH
103575: LD_INT 0
103577: ST_TO_ADDR
// end ;
103578: LD_VAR 0 3
103582: RET
// export function HealTarget ( sci ) ; begin
103583: LD_INT 0
103585: PPUSH
// if not sci then
103586: LD_VAR 0 1
103590: NOT
103591: IFFALSE 103595
// exit ;
103593: GO 103660
// result := 0 ;
103595: LD_ADDR_VAR 0 2
103599: PUSH
103600: LD_INT 0
103602: ST_TO_ADDR
// if GetTaskList ( sci ) then
103603: LD_VAR 0 1
103607: PPUSH
103608: CALL_OW 437
103612: IFFALSE 103660
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
103614: LD_VAR 0 1
103618: PPUSH
103619: CALL_OW 437
103623: PUSH
103624: LD_INT 1
103626: ARRAY
103627: PUSH
103628: LD_INT 1
103630: ARRAY
103631: PUSH
103632: LD_STRING l
103634: EQUAL
103635: IFFALSE 103660
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
103637: LD_ADDR_VAR 0 2
103641: PUSH
103642: LD_VAR 0 1
103646: PPUSH
103647: CALL_OW 437
103651: PUSH
103652: LD_INT 1
103654: ARRAY
103655: PUSH
103656: LD_INT 4
103658: ARRAY
103659: ST_TO_ADDR
// end ;
103660: LD_VAR 0 2
103664: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
103665: LD_INT 0
103667: PPUSH
103668: PPUSH
103669: PPUSH
103670: PPUSH
// if not base_units then
103671: LD_VAR 0 1
103675: NOT
103676: IFFALSE 103680
// exit ;
103678: GO 103767
// result := false ;
103680: LD_ADDR_VAR 0 2
103684: PUSH
103685: LD_INT 0
103687: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
103688: LD_ADDR_VAR 0 5
103692: PUSH
103693: LD_VAR 0 1
103697: PPUSH
103698: LD_INT 21
103700: PUSH
103701: LD_INT 3
103703: PUSH
103704: EMPTY
103705: LIST
103706: LIST
103707: PPUSH
103708: CALL_OW 72
103712: ST_TO_ADDR
// if not tmp then
103713: LD_VAR 0 5
103717: NOT
103718: IFFALSE 103722
// exit ;
103720: GO 103767
// for i in tmp do
103722: LD_ADDR_VAR 0 3
103726: PUSH
103727: LD_VAR 0 5
103731: PUSH
103732: FOR_IN
103733: IFFALSE 103765
// begin result := EnemyInRange ( i , 22 ) ;
103735: LD_ADDR_VAR 0 2
103739: PUSH
103740: LD_VAR 0 3
103744: PPUSH
103745: LD_INT 22
103747: PPUSH
103748: CALL 101354 0 2
103752: ST_TO_ADDR
// if result then
103753: LD_VAR 0 2
103757: IFFALSE 103763
// exit ;
103759: POP
103760: POP
103761: GO 103767
// end ;
103763: GO 103732
103765: POP
103766: POP
// end ;
103767: LD_VAR 0 2
103771: RET
// export function FilterByTag ( units , tag ) ; begin
103772: LD_INT 0
103774: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
103775: LD_ADDR_VAR 0 3
103779: PUSH
103780: LD_VAR 0 1
103784: PPUSH
103785: LD_INT 120
103787: PUSH
103788: LD_VAR 0 2
103792: PUSH
103793: EMPTY
103794: LIST
103795: LIST
103796: PPUSH
103797: CALL_OW 72
103801: ST_TO_ADDR
// end ;
103802: LD_VAR 0 3
103806: RET
// export function IsDriver ( un ) ; begin
103807: LD_INT 0
103809: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
103810: LD_ADDR_VAR 0 2
103814: PUSH
103815: LD_VAR 0 1
103819: PUSH
103820: LD_INT 55
103822: PUSH
103823: EMPTY
103824: LIST
103825: PPUSH
103826: CALL_OW 69
103830: IN
103831: ST_TO_ADDR
// end ;
103832: LD_VAR 0 2
103836: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
103837: LD_INT 0
103839: PPUSH
103840: PPUSH
// list := [ ] ;
103841: LD_ADDR_VAR 0 5
103845: PUSH
103846: EMPTY
103847: ST_TO_ADDR
// case d of 0 :
103848: LD_VAR 0 3
103852: PUSH
103853: LD_INT 0
103855: DOUBLE
103856: EQUAL
103857: IFTRUE 103861
103859: GO 103994
103861: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
103862: LD_ADDR_VAR 0 5
103866: PUSH
103867: LD_VAR 0 1
103871: PUSH
103872: LD_INT 4
103874: MINUS
103875: PUSH
103876: LD_VAR 0 2
103880: PUSH
103881: LD_INT 4
103883: MINUS
103884: PUSH
103885: LD_INT 2
103887: PUSH
103888: EMPTY
103889: LIST
103890: LIST
103891: LIST
103892: PUSH
103893: LD_VAR 0 1
103897: PUSH
103898: LD_INT 3
103900: MINUS
103901: PUSH
103902: LD_VAR 0 2
103906: PUSH
103907: LD_INT 1
103909: PUSH
103910: EMPTY
103911: LIST
103912: LIST
103913: LIST
103914: PUSH
103915: LD_VAR 0 1
103919: PUSH
103920: LD_INT 4
103922: PLUS
103923: PUSH
103924: LD_VAR 0 2
103928: PUSH
103929: LD_INT 4
103931: PUSH
103932: EMPTY
103933: LIST
103934: LIST
103935: LIST
103936: PUSH
103937: LD_VAR 0 1
103941: PUSH
103942: LD_INT 3
103944: PLUS
103945: PUSH
103946: LD_VAR 0 2
103950: PUSH
103951: LD_INT 3
103953: PLUS
103954: PUSH
103955: LD_INT 5
103957: PUSH
103958: EMPTY
103959: LIST
103960: LIST
103961: LIST
103962: PUSH
103963: LD_VAR 0 1
103967: PUSH
103968: LD_VAR 0 2
103972: PUSH
103973: LD_INT 4
103975: PLUS
103976: PUSH
103977: LD_INT 0
103979: PUSH
103980: EMPTY
103981: LIST
103982: LIST
103983: LIST
103984: PUSH
103985: EMPTY
103986: LIST
103987: LIST
103988: LIST
103989: LIST
103990: LIST
103991: ST_TO_ADDR
// end ; 1 :
103992: GO 104692
103994: LD_INT 1
103996: DOUBLE
103997: EQUAL
103998: IFTRUE 104002
104000: GO 104135
104002: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
104003: LD_ADDR_VAR 0 5
104007: PUSH
104008: LD_VAR 0 1
104012: PUSH
104013: LD_VAR 0 2
104017: PUSH
104018: LD_INT 4
104020: MINUS
104021: PUSH
104022: LD_INT 3
104024: PUSH
104025: EMPTY
104026: LIST
104027: LIST
104028: LIST
104029: PUSH
104030: LD_VAR 0 1
104034: PUSH
104035: LD_INT 3
104037: MINUS
104038: PUSH
104039: LD_VAR 0 2
104043: PUSH
104044: LD_INT 3
104046: MINUS
104047: PUSH
104048: LD_INT 2
104050: PUSH
104051: EMPTY
104052: LIST
104053: LIST
104054: LIST
104055: PUSH
104056: LD_VAR 0 1
104060: PUSH
104061: LD_INT 4
104063: MINUS
104064: PUSH
104065: LD_VAR 0 2
104069: PUSH
104070: LD_INT 1
104072: PUSH
104073: EMPTY
104074: LIST
104075: LIST
104076: LIST
104077: PUSH
104078: LD_VAR 0 1
104082: PUSH
104083: LD_VAR 0 2
104087: PUSH
104088: LD_INT 3
104090: PLUS
104091: PUSH
104092: LD_INT 0
104094: PUSH
104095: EMPTY
104096: LIST
104097: LIST
104098: LIST
104099: PUSH
104100: LD_VAR 0 1
104104: PUSH
104105: LD_INT 4
104107: PLUS
104108: PUSH
104109: LD_VAR 0 2
104113: PUSH
104114: LD_INT 4
104116: PLUS
104117: PUSH
104118: LD_INT 5
104120: PUSH
104121: EMPTY
104122: LIST
104123: LIST
104124: LIST
104125: PUSH
104126: EMPTY
104127: LIST
104128: LIST
104129: LIST
104130: LIST
104131: LIST
104132: ST_TO_ADDR
// end ; 2 :
104133: GO 104692
104135: LD_INT 2
104137: DOUBLE
104138: EQUAL
104139: IFTRUE 104143
104141: GO 104272
104143: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
104144: LD_ADDR_VAR 0 5
104148: PUSH
104149: LD_VAR 0 1
104153: PUSH
104154: LD_VAR 0 2
104158: PUSH
104159: LD_INT 3
104161: MINUS
104162: PUSH
104163: LD_INT 3
104165: PUSH
104166: EMPTY
104167: LIST
104168: LIST
104169: LIST
104170: PUSH
104171: LD_VAR 0 1
104175: PUSH
104176: LD_INT 4
104178: PLUS
104179: PUSH
104180: LD_VAR 0 2
104184: PUSH
104185: LD_INT 4
104187: PUSH
104188: EMPTY
104189: LIST
104190: LIST
104191: LIST
104192: PUSH
104193: LD_VAR 0 1
104197: PUSH
104198: LD_VAR 0 2
104202: PUSH
104203: LD_INT 4
104205: PLUS
104206: PUSH
104207: LD_INT 0
104209: PUSH
104210: EMPTY
104211: LIST
104212: LIST
104213: LIST
104214: PUSH
104215: LD_VAR 0 1
104219: PUSH
104220: LD_INT 3
104222: MINUS
104223: PUSH
104224: LD_VAR 0 2
104228: PUSH
104229: LD_INT 1
104231: PUSH
104232: EMPTY
104233: LIST
104234: LIST
104235: LIST
104236: PUSH
104237: LD_VAR 0 1
104241: PUSH
104242: LD_INT 4
104244: MINUS
104245: PUSH
104246: LD_VAR 0 2
104250: PUSH
104251: LD_INT 4
104253: MINUS
104254: PUSH
104255: LD_INT 2
104257: PUSH
104258: EMPTY
104259: LIST
104260: LIST
104261: LIST
104262: PUSH
104263: EMPTY
104264: LIST
104265: LIST
104266: LIST
104267: LIST
104268: LIST
104269: ST_TO_ADDR
// end ; 3 :
104270: GO 104692
104272: LD_INT 3
104274: DOUBLE
104275: EQUAL
104276: IFTRUE 104280
104278: GO 104413
104280: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
104281: LD_ADDR_VAR 0 5
104285: PUSH
104286: LD_VAR 0 1
104290: PUSH
104291: LD_INT 3
104293: PLUS
104294: PUSH
104295: LD_VAR 0 2
104299: PUSH
104300: LD_INT 4
104302: PUSH
104303: EMPTY
104304: LIST
104305: LIST
104306: LIST
104307: PUSH
104308: LD_VAR 0 1
104312: PUSH
104313: LD_INT 4
104315: PLUS
104316: PUSH
104317: LD_VAR 0 2
104321: PUSH
104322: LD_INT 4
104324: PLUS
104325: PUSH
104326: LD_INT 5
104328: PUSH
104329: EMPTY
104330: LIST
104331: LIST
104332: LIST
104333: PUSH
104334: LD_VAR 0 1
104338: PUSH
104339: LD_INT 4
104341: MINUS
104342: PUSH
104343: LD_VAR 0 2
104347: PUSH
104348: LD_INT 1
104350: PUSH
104351: EMPTY
104352: LIST
104353: LIST
104354: LIST
104355: PUSH
104356: LD_VAR 0 1
104360: PUSH
104361: LD_VAR 0 2
104365: PUSH
104366: LD_INT 4
104368: MINUS
104369: PUSH
104370: LD_INT 3
104372: PUSH
104373: EMPTY
104374: LIST
104375: LIST
104376: LIST
104377: PUSH
104378: LD_VAR 0 1
104382: PUSH
104383: LD_INT 3
104385: MINUS
104386: PUSH
104387: LD_VAR 0 2
104391: PUSH
104392: LD_INT 3
104394: MINUS
104395: PUSH
104396: LD_INT 2
104398: PUSH
104399: EMPTY
104400: LIST
104401: LIST
104402: LIST
104403: PUSH
104404: EMPTY
104405: LIST
104406: LIST
104407: LIST
104408: LIST
104409: LIST
104410: ST_TO_ADDR
// end ; 4 :
104411: GO 104692
104413: LD_INT 4
104415: DOUBLE
104416: EQUAL
104417: IFTRUE 104421
104419: GO 104554
104421: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
104422: LD_ADDR_VAR 0 5
104426: PUSH
104427: LD_VAR 0 1
104431: PUSH
104432: LD_VAR 0 2
104436: PUSH
104437: LD_INT 4
104439: PLUS
104440: PUSH
104441: LD_INT 0
104443: PUSH
104444: EMPTY
104445: LIST
104446: LIST
104447: LIST
104448: PUSH
104449: LD_VAR 0 1
104453: PUSH
104454: LD_INT 3
104456: PLUS
104457: PUSH
104458: LD_VAR 0 2
104462: PUSH
104463: LD_INT 3
104465: PLUS
104466: PUSH
104467: LD_INT 5
104469: PUSH
104470: EMPTY
104471: LIST
104472: LIST
104473: LIST
104474: PUSH
104475: LD_VAR 0 1
104479: PUSH
104480: LD_INT 4
104482: PLUS
104483: PUSH
104484: LD_VAR 0 2
104488: PUSH
104489: LD_INT 4
104491: PUSH
104492: EMPTY
104493: LIST
104494: LIST
104495: LIST
104496: PUSH
104497: LD_VAR 0 1
104501: PUSH
104502: LD_VAR 0 2
104506: PUSH
104507: LD_INT 3
104509: MINUS
104510: PUSH
104511: LD_INT 3
104513: PUSH
104514: EMPTY
104515: LIST
104516: LIST
104517: LIST
104518: PUSH
104519: LD_VAR 0 1
104523: PUSH
104524: LD_INT 4
104526: MINUS
104527: PUSH
104528: LD_VAR 0 2
104532: PUSH
104533: LD_INT 4
104535: MINUS
104536: PUSH
104537: LD_INT 2
104539: PUSH
104540: EMPTY
104541: LIST
104542: LIST
104543: LIST
104544: PUSH
104545: EMPTY
104546: LIST
104547: LIST
104548: LIST
104549: LIST
104550: LIST
104551: ST_TO_ADDR
// end ; 5 :
104552: GO 104692
104554: LD_INT 5
104556: DOUBLE
104557: EQUAL
104558: IFTRUE 104562
104560: GO 104691
104562: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
104563: LD_ADDR_VAR 0 5
104567: PUSH
104568: LD_VAR 0 1
104572: PUSH
104573: LD_INT 4
104575: MINUS
104576: PUSH
104577: LD_VAR 0 2
104581: PUSH
104582: LD_INT 1
104584: PUSH
104585: EMPTY
104586: LIST
104587: LIST
104588: LIST
104589: PUSH
104590: LD_VAR 0 1
104594: PUSH
104595: LD_VAR 0 2
104599: PUSH
104600: LD_INT 4
104602: MINUS
104603: PUSH
104604: LD_INT 3
104606: PUSH
104607: EMPTY
104608: LIST
104609: LIST
104610: LIST
104611: PUSH
104612: LD_VAR 0 1
104616: PUSH
104617: LD_INT 4
104619: PLUS
104620: PUSH
104621: LD_VAR 0 2
104625: PUSH
104626: LD_INT 4
104628: PLUS
104629: PUSH
104630: LD_INT 5
104632: PUSH
104633: EMPTY
104634: LIST
104635: LIST
104636: LIST
104637: PUSH
104638: LD_VAR 0 1
104642: PUSH
104643: LD_INT 3
104645: PLUS
104646: PUSH
104647: LD_VAR 0 2
104651: PUSH
104652: LD_INT 4
104654: PUSH
104655: EMPTY
104656: LIST
104657: LIST
104658: LIST
104659: PUSH
104660: LD_VAR 0 1
104664: PUSH
104665: LD_VAR 0 2
104669: PUSH
104670: LD_INT 3
104672: PLUS
104673: PUSH
104674: LD_INT 0
104676: PUSH
104677: EMPTY
104678: LIST
104679: LIST
104680: LIST
104681: PUSH
104682: EMPTY
104683: LIST
104684: LIST
104685: LIST
104686: LIST
104687: LIST
104688: ST_TO_ADDR
// end ; end ;
104689: GO 104692
104691: POP
// result := list ;
104692: LD_ADDR_VAR 0 4
104696: PUSH
104697: LD_VAR 0 5
104701: ST_TO_ADDR
// end ;
104702: LD_VAR 0 4
104706: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
104707: LD_INT 0
104709: PPUSH
104710: PPUSH
104711: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
104712: LD_VAR 0 1
104716: NOT
104717: PUSH
104718: LD_VAR 0 2
104722: PUSH
104723: LD_INT 1
104725: PUSH
104726: LD_INT 2
104728: PUSH
104729: LD_INT 3
104731: PUSH
104732: LD_INT 4
104734: PUSH
104735: EMPTY
104736: LIST
104737: LIST
104738: LIST
104739: LIST
104740: IN
104741: NOT
104742: OR
104743: IFFALSE 104747
// exit ;
104745: GO 104830
// tmp := [ ] ;
104747: LD_ADDR_VAR 0 5
104751: PUSH
104752: EMPTY
104753: ST_TO_ADDR
// for i in units do
104754: LD_ADDR_VAR 0 4
104758: PUSH
104759: LD_VAR 0 1
104763: PUSH
104764: FOR_IN
104765: IFFALSE 104799
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
104767: LD_ADDR_VAR 0 5
104771: PUSH
104772: LD_VAR 0 5
104776: PPUSH
104777: LD_VAR 0 4
104781: PPUSH
104782: LD_VAR 0 2
104786: PPUSH
104787: CALL_OW 259
104791: PPUSH
104792: CALL 106190 0 2
104796: ST_TO_ADDR
104797: GO 104764
104799: POP
104800: POP
// if not tmp then
104801: LD_VAR 0 5
104805: NOT
104806: IFFALSE 104810
// exit ;
104808: GO 104830
// result := SortListByListDesc ( units , tmp ) ;
104810: LD_ADDR_VAR 0 3
104814: PUSH
104815: LD_VAR 0 1
104819: PPUSH
104820: LD_VAR 0 5
104824: PPUSH
104825: CALL_OW 77
104829: ST_TO_ADDR
// end ;
104830: LD_VAR 0 3
104834: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
104835: LD_INT 0
104837: PPUSH
104838: PPUSH
104839: PPUSH
// result := false ;
104840: LD_ADDR_VAR 0 3
104844: PUSH
104845: LD_INT 0
104847: ST_TO_ADDR
// if not building then
104848: LD_VAR 0 2
104852: NOT
104853: IFFALSE 104857
// exit ;
104855: GO 104995
// x := GetX ( building ) ;
104857: LD_ADDR_VAR 0 4
104861: PUSH
104862: LD_VAR 0 2
104866: PPUSH
104867: CALL_OW 250
104871: ST_TO_ADDR
// y := GetY ( building ) ;
104872: LD_ADDR_VAR 0 5
104876: PUSH
104877: LD_VAR 0 2
104881: PPUSH
104882: CALL_OW 251
104886: ST_TO_ADDR
// if not x or not y then
104887: LD_VAR 0 4
104891: NOT
104892: PUSH
104893: LD_VAR 0 5
104897: NOT
104898: OR
104899: IFFALSE 104903
// exit ;
104901: GO 104995
// if GetTaskList ( unit ) then
104903: LD_VAR 0 1
104907: PPUSH
104908: CALL_OW 437
104912: IFFALSE 104995
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104914: LD_STRING e
104916: PUSH
104917: LD_VAR 0 1
104921: PPUSH
104922: CALL_OW 437
104926: PUSH
104927: LD_INT 1
104929: ARRAY
104930: PUSH
104931: LD_INT 1
104933: ARRAY
104934: EQUAL
104935: PUSH
104936: LD_VAR 0 4
104940: PUSH
104941: LD_VAR 0 1
104945: PPUSH
104946: CALL_OW 437
104950: PUSH
104951: LD_INT 1
104953: ARRAY
104954: PUSH
104955: LD_INT 2
104957: ARRAY
104958: EQUAL
104959: AND
104960: PUSH
104961: LD_VAR 0 5
104965: PUSH
104966: LD_VAR 0 1
104970: PPUSH
104971: CALL_OW 437
104975: PUSH
104976: LD_INT 1
104978: ARRAY
104979: PUSH
104980: LD_INT 3
104982: ARRAY
104983: EQUAL
104984: AND
104985: IFFALSE 104995
// result := true end ;
104987: LD_ADDR_VAR 0 3
104991: PUSH
104992: LD_INT 1
104994: ST_TO_ADDR
// end ;
104995: LD_VAR 0 3
104999: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
105000: LD_INT 0
105002: PPUSH
// result := false ;
105003: LD_ADDR_VAR 0 4
105007: PUSH
105008: LD_INT 0
105010: ST_TO_ADDR
// if GetTaskList ( unit ) then
105011: LD_VAR 0 1
105015: PPUSH
105016: CALL_OW 437
105020: IFFALSE 105103
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105022: LD_STRING M
105024: PUSH
105025: LD_VAR 0 1
105029: PPUSH
105030: CALL_OW 437
105034: PUSH
105035: LD_INT 1
105037: ARRAY
105038: PUSH
105039: LD_INT 1
105041: ARRAY
105042: EQUAL
105043: PUSH
105044: LD_VAR 0 2
105048: PUSH
105049: LD_VAR 0 1
105053: PPUSH
105054: CALL_OW 437
105058: PUSH
105059: LD_INT 1
105061: ARRAY
105062: PUSH
105063: LD_INT 2
105065: ARRAY
105066: EQUAL
105067: AND
105068: PUSH
105069: LD_VAR 0 3
105073: PUSH
105074: LD_VAR 0 1
105078: PPUSH
105079: CALL_OW 437
105083: PUSH
105084: LD_INT 1
105086: ARRAY
105087: PUSH
105088: LD_INT 3
105090: ARRAY
105091: EQUAL
105092: AND
105093: IFFALSE 105103
// result := true ;
105095: LD_ADDR_VAR 0 4
105099: PUSH
105100: LD_INT 1
105102: ST_TO_ADDR
// end ; end ;
105103: LD_VAR 0 4
105107: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
105108: LD_INT 0
105110: PPUSH
105111: PPUSH
105112: PPUSH
105113: PPUSH
// if not unit or not area then
105114: LD_VAR 0 1
105118: NOT
105119: PUSH
105120: LD_VAR 0 2
105124: NOT
105125: OR
105126: IFFALSE 105130
// exit ;
105128: GO 105293
// tmp := AreaToList ( area , i ) ;
105130: LD_ADDR_VAR 0 6
105134: PUSH
105135: LD_VAR 0 2
105139: PPUSH
105140: LD_VAR 0 5
105144: PPUSH
105145: CALL_OW 517
105149: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
105150: LD_ADDR_VAR 0 5
105154: PUSH
105155: DOUBLE
105156: LD_INT 1
105158: DEC
105159: ST_TO_ADDR
105160: LD_VAR 0 6
105164: PUSH
105165: LD_INT 1
105167: ARRAY
105168: PUSH
105169: FOR_TO
105170: IFFALSE 105291
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
105172: LD_ADDR_VAR 0 7
105176: PUSH
105177: LD_VAR 0 6
105181: PUSH
105182: LD_INT 1
105184: ARRAY
105185: PUSH
105186: LD_VAR 0 5
105190: ARRAY
105191: PUSH
105192: LD_VAR 0 6
105196: PUSH
105197: LD_INT 2
105199: ARRAY
105200: PUSH
105201: LD_VAR 0 5
105205: ARRAY
105206: PUSH
105207: EMPTY
105208: LIST
105209: LIST
105210: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
105211: LD_INT 92
105213: PUSH
105214: LD_VAR 0 7
105218: PUSH
105219: LD_INT 1
105221: ARRAY
105222: PUSH
105223: LD_VAR 0 7
105227: PUSH
105228: LD_INT 2
105230: ARRAY
105231: PUSH
105232: LD_INT 3
105234: PUSH
105235: EMPTY
105236: LIST
105237: LIST
105238: LIST
105239: LIST
105240: PPUSH
105241: CALL_OW 69
105245: PUSH
105246: LD_INT 0
105248: EQUAL
105249: IFFALSE 105289
// begin PlaceUnitArea ( unit , area , mode ) ;
105251: LD_VAR 0 1
105255: PPUSH
105256: LD_VAR 0 2
105260: PPUSH
105261: LD_VAR 0 3
105265: PPUSH
105266: CALL_OW 49
// result := IsPlaced ( unit ) ;
105270: LD_ADDR_VAR 0 4
105274: PUSH
105275: LD_VAR 0 1
105279: PPUSH
105280: CALL_OW 305
105284: ST_TO_ADDR
// exit ;
105285: POP
105286: POP
105287: GO 105293
// end ; end ;
105289: GO 105169
105291: POP
105292: POP
// end ;
105293: LD_VAR 0 4
105297: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
105298: LD_INT 0
105300: PPUSH
105301: PPUSH
105302: PPUSH
// if not side or side > 8 then
105303: LD_VAR 0 1
105307: NOT
105308: PUSH
105309: LD_VAR 0 1
105313: PUSH
105314: LD_INT 8
105316: GREATER
105317: OR
105318: IFFALSE 105322
// exit ;
105320: GO 105509
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
105322: LD_ADDR_VAR 0 4
105326: PUSH
105327: LD_INT 22
105329: PUSH
105330: LD_VAR 0 1
105334: PUSH
105335: EMPTY
105336: LIST
105337: LIST
105338: PUSH
105339: LD_INT 21
105341: PUSH
105342: LD_INT 3
105344: PUSH
105345: EMPTY
105346: LIST
105347: LIST
105348: PUSH
105349: EMPTY
105350: LIST
105351: LIST
105352: PPUSH
105353: CALL_OW 69
105357: ST_TO_ADDR
// if not tmp then
105358: LD_VAR 0 4
105362: NOT
105363: IFFALSE 105367
// exit ;
105365: GO 105509
// enable_addtolog := true ;
105367: LD_ADDR_OWVAR 81
105371: PUSH
105372: LD_INT 1
105374: ST_TO_ADDR
// AddToLog ( [ ) ;
105375: LD_STRING [
105377: PPUSH
105378: CALL_OW 561
// for i in tmp do
105382: LD_ADDR_VAR 0 3
105386: PUSH
105387: LD_VAR 0 4
105391: PUSH
105392: FOR_IN
105393: IFFALSE 105500
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
105395: LD_STRING [
105397: PUSH
105398: LD_VAR 0 3
105402: PPUSH
105403: CALL_OW 266
105407: STR
105408: PUSH
105409: LD_STRING , 
105411: STR
105412: PUSH
105413: LD_VAR 0 3
105417: PPUSH
105418: CALL_OW 250
105422: STR
105423: PUSH
105424: LD_STRING , 
105426: STR
105427: PUSH
105428: LD_VAR 0 3
105432: PPUSH
105433: CALL_OW 251
105437: STR
105438: PUSH
105439: LD_STRING , 
105441: STR
105442: PUSH
105443: LD_VAR 0 3
105447: PPUSH
105448: CALL_OW 254
105452: STR
105453: PUSH
105454: LD_STRING , 
105456: STR
105457: PUSH
105458: LD_VAR 0 3
105462: PPUSH
105463: LD_INT 1
105465: PPUSH
105466: CALL_OW 268
105470: STR
105471: PUSH
105472: LD_STRING , 
105474: STR
105475: PUSH
105476: LD_VAR 0 3
105480: PPUSH
105481: LD_INT 2
105483: PPUSH
105484: CALL_OW 268
105488: STR
105489: PUSH
105490: LD_STRING ],
105492: STR
105493: PPUSH
105494: CALL_OW 561
// end ;
105498: GO 105392
105500: POP
105501: POP
// AddToLog ( ]; ) ;
105502: LD_STRING ];
105504: PPUSH
105505: CALL_OW 561
// end ;
105509: LD_VAR 0 2
105513: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
105514: LD_INT 0
105516: PPUSH
105517: PPUSH
105518: PPUSH
105519: PPUSH
105520: PPUSH
// if not area or not rate or not max then
105521: LD_VAR 0 1
105525: NOT
105526: PUSH
105527: LD_VAR 0 2
105531: NOT
105532: OR
105533: PUSH
105534: LD_VAR 0 4
105538: NOT
105539: OR
105540: IFFALSE 105544
// exit ;
105542: GO 105733
// while 1 do
105544: LD_INT 1
105546: IFFALSE 105733
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
105548: LD_ADDR_VAR 0 9
105552: PUSH
105553: LD_VAR 0 1
105557: PPUSH
105558: LD_INT 1
105560: PPUSH
105561: CALL_OW 287
105565: PUSH
105566: LD_INT 10
105568: MUL
105569: ST_TO_ADDR
// r := rate / 10 ;
105570: LD_ADDR_VAR 0 7
105574: PUSH
105575: LD_VAR 0 2
105579: PUSH
105580: LD_INT 10
105582: DIVREAL
105583: ST_TO_ADDR
// time := 1 1$00 ;
105584: LD_ADDR_VAR 0 8
105588: PUSH
105589: LD_INT 2100
105591: ST_TO_ADDR
// if amount < min then
105592: LD_VAR 0 9
105596: PUSH
105597: LD_VAR 0 3
105601: LESS
105602: IFFALSE 105620
// r := r * 2 else
105604: LD_ADDR_VAR 0 7
105608: PUSH
105609: LD_VAR 0 7
105613: PUSH
105614: LD_INT 2
105616: MUL
105617: ST_TO_ADDR
105618: GO 105646
// if amount > max then
105620: LD_VAR 0 9
105624: PUSH
105625: LD_VAR 0 4
105629: GREATER
105630: IFFALSE 105646
// r := r / 2 ;
105632: LD_ADDR_VAR 0 7
105636: PUSH
105637: LD_VAR 0 7
105641: PUSH
105642: LD_INT 2
105644: DIVREAL
105645: ST_TO_ADDR
// time := time / r ;
105646: LD_ADDR_VAR 0 8
105650: PUSH
105651: LD_VAR 0 8
105655: PUSH
105656: LD_VAR 0 7
105660: DIVREAL
105661: ST_TO_ADDR
// if time < 0 then
105662: LD_VAR 0 8
105666: PUSH
105667: LD_INT 0
105669: LESS
105670: IFFALSE 105687
// time := time * - 1 ;
105672: LD_ADDR_VAR 0 8
105676: PUSH
105677: LD_VAR 0 8
105681: PUSH
105682: LD_INT 1
105684: NEG
105685: MUL
105686: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
105687: LD_VAR 0 8
105691: PUSH
105692: LD_INT 35
105694: PPUSH
105695: LD_INT 875
105697: PPUSH
105698: CALL_OW 12
105702: PLUS
105703: PPUSH
105704: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
105708: LD_INT 1
105710: PPUSH
105711: LD_INT 5
105713: PPUSH
105714: CALL_OW 12
105718: PPUSH
105719: LD_VAR 0 1
105723: PPUSH
105724: LD_INT 1
105726: PPUSH
105727: CALL_OW 55
// end ;
105731: GO 105544
// end ;
105733: LD_VAR 0 5
105737: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
105738: LD_INT 0
105740: PPUSH
105741: PPUSH
105742: PPUSH
105743: PPUSH
105744: PPUSH
105745: PPUSH
105746: PPUSH
105747: PPUSH
// if not turrets or not factories then
105748: LD_VAR 0 1
105752: NOT
105753: PUSH
105754: LD_VAR 0 2
105758: NOT
105759: OR
105760: IFFALSE 105764
// exit ;
105762: GO 106071
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
105764: LD_ADDR_VAR 0 10
105768: PUSH
105769: LD_INT 5
105771: PUSH
105772: LD_INT 6
105774: PUSH
105775: EMPTY
105776: LIST
105777: LIST
105778: PUSH
105779: LD_INT 2
105781: PUSH
105782: LD_INT 4
105784: PUSH
105785: EMPTY
105786: LIST
105787: LIST
105788: PUSH
105789: LD_INT 3
105791: PUSH
105792: LD_INT 5
105794: PUSH
105795: EMPTY
105796: LIST
105797: LIST
105798: PUSH
105799: EMPTY
105800: LIST
105801: LIST
105802: LIST
105803: PUSH
105804: LD_INT 24
105806: PUSH
105807: LD_INT 25
105809: PUSH
105810: EMPTY
105811: LIST
105812: LIST
105813: PUSH
105814: LD_INT 23
105816: PUSH
105817: LD_INT 27
105819: PUSH
105820: EMPTY
105821: LIST
105822: LIST
105823: PUSH
105824: EMPTY
105825: LIST
105826: LIST
105827: PUSH
105828: LD_INT 42
105830: PUSH
105831: LD_INT 43
105833: PUSH
105834: EMPTY
105835: LIST
105836: LIST
105837: PUSH
105838: LD_INT 44
105840: PUSH
105841: LD_INT 46
105843: PUSH
105844: EMPTY
105845: LIST
105846: LIST
105847: PUSH
105848: LD_INT 45
105850: PUSH
105851: LD_INT 47
105853: PUSH
105854: EMPTY
105855: LIST
105856: LIST
105857: PUSH
105858: EMPTY
105859: LIST
105860: LIST
105861: LIST
105862: PUSH
105863: EMPTY
105864: LIST
105865: LIST
105866: LIST
105867: ST_TO_ADDR
// result := [ ] ;
105868: LD_ADDR_VAR 0 3
105872: PUSH
105873: EMPTY
105874: ST_TO_ADDR
// for i in turrets do
105875: LD_ADDR_VAR 0 4
105879: PUSH
105880: LD_VAR 0 1
105884: PUSH
105885: FOR_IN
105886: IFFALSE 106069
// begin nat := GetNation ( i ) ;
105888: LD_ADDR_VAR 0 7
105892: PUSH
105893: LD_VAR 0 4
105897: PPUSH
105898: CALL_OW 248
105902: ST_TO_ADDR
// weapon := 0 ;
105903: LD_ADDR_VAR 0 8
105907: PUSH
105908: LD_INT 0
105910: ST_TO_ADDR
// if not nat then
105911: LD_VAR 0 7
105915: NOT
105916: IFFALSE 105920
// continue ;
105918: GO 105885
// for j in list [ nat ] do
105920: LD_ADDR_VAR 0 5
105924: PUSH
105925: LD_VAR 0 10
105929: PUSH
105930: LD_VAR 0 7
105934: ARRAY
105935: PUSH
105936: FOR_IN
105937: IFFALSE 105978
// if GetBWeapon ( i ) = j [ 1 ] then
105939: LD_VAR 0 4
105943: PPUSH
105944: CALL_OW 269
105948: PUSH
105949: LD_VAR 0 5
105953: PUSH
105954: LD_INT 1
105956: ARRAY
105957: EQUAL
105958: IFFALSE 105976
// begin weapon := j [ 2 ] ;
105960: LD_ADDR_VAR 0 8
105964: PUSH
105965: LD_VAR 0 5
105969: PUSH
105970: LD_INT 2
105972: ARRAY
105973: ST_TO_ADDR
// break ;
105974: GO 105978
// end ;
105976: GO 105936
105978: POP
105979: POP
// if not weapon then
105980: LD_VAR 0 8
105984: NOT
105985: IFFALSE 105989
// continue ;
105987: GO 105885
// for k in factories do
105989: LD_ADDR_VAR 0 6
105993: PUSH
105994: LD_VAR 0 2
105998: PUSH
105999: FOR_IN
106000: IFFALSE 106065
// begin weapons := AvailableWeaponList ( k ) ;
106002: LD_ADDR_VAR 0 9
106006: PUSH
106007: LD_VAR 0 6
106011: PPUSH
106012: CALL_OW 478
106016: ST_TO_ADDR
// if not weapons then
106017: LD_VAR 0 9
106021: NOT
106022: IFFALSE 106026
// continue ;
106024: GO 105999
// if weapon in weapons then
106026: LD_VAR 0 8
106030: PUSH
106031: LD_VAR 0 9
106035: IN
106036: IFFALSE 106063
// begin result := [ i , weapon ] ;
106038: LD_ADDR_VAR 0 3
106042: PUSH
106043: LD_VAR 0 4
106047: PUSH
106048: LD_VAR 0 8
106052: PUSH
106053: EMPTY
106054: LIST
106055: LIST
106056: ST_TO_ADDR
// exit ;
106057: POP
106058: POP
106059: POP
106060: POP
106061: GO 106071
// end ; end ;
106063: GO 105999
106065: POP
106066: POP
// end ;
106067: GO 105885
106069: POP
106070: POP
// end ;
106071: LD_VAR 0 3
106075: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
106076: LD_INT 0
106078: PPUSH
// if not side or side > 8 then
106079: LD_VAR 0 3
106083: NOT
106084: PUSH
106085: LD_VAR 0 3
106089: PUSH
106090: LD_INT 8
106092: GREATER
106093: OR
106094: IFFALSE 106098
// exit ;
106096: GO 106157
// if not range then
106098: LD_VAR 0 4
106102: NOT
106103: IFFALSE 106114
// range := - 12 ;
106105: LD_ADDR_VAR 0 4
106109: PUSH
106110: LD_INT 12
106112: NEG
106113: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
106114: LD_VAR 0 1
106118: PPUSH
106119: LD_VAR 0 2
106123: PPUSH
106124: LD_VAR 0 3
106128: PPUSH
106129: LD_VAR 0 4
106133: PPUSH
106134: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
106138: LD_VAR 0 1
106142: PPUSH
106143: LD_VAR 0 2
106147: PPUSH
106148: LD_VAR 0 3
106152: PPUSH
106153: CALL_OW 331
// end ;
106157: LD_VAR 0 5
106161: RET
// export function Video ( mode ) ; begin
106162: LD_INT 0
106164: PPUSH
// ingame_video = mode ;
106165: LD_ADDR_OWVAR 52
106169: PUSH
106170: LD_VAR 0 1
106174: ST_TO_ADDR
// interface_hidden = mode ;
106175: LD_ADDR_OWVAR 54
106179: PUSH
106180: LD_VAR 0 1
106184: ST_TO_ADDR
// end ;
106185: LD_VAR 0 2
106189: RET
// export function Join ( array , element ) ; begin
106190: LD_INT 0
106192: PPUSH
// result := Replace ( array , array + 1 , element ) ;
106193: LD_ADDR_VAR 0 3
106197: PUSH
106198: LD_VAR 0 1
106202: PPUSH
106203: LD_VAR 0 1
106207: PUSH
106208: LD_INT 1
106210: PLUS
106211: PPUSH
106212: LD_VAR 0 2
106216: PPUSH
106217: CALL_OW 1
106221: ST_TO_ADDR
// end ;
106222: LD_VAR 0 3
106226: RET
// export function JoinUnion ( array , element ) ; begin
106227: LD_INT 0
106229: PPUSH
// result := array union element ;
106230: LD_ADDR_VAR 0 3
106234: PUSH
106235: LD_VAR 0 1
106239: PUSH
106240: LD_VAR 0 2
106244: UNION
106245: ST_TO_ADDR
// end ;
106246: LD_VAR 0 3
106250: RET
// export function GetBehemoths ( side ) ; begin
106251: LD_INT 0
106253: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
106254: LD_ADDR_VAR 0 2
106258: PUSH
106259: LD_INT 22
106261: PUSH
106262: LD_VAR 0 1
106266: PUSH
106267: EMPTY
106268: LIST
106269: LIST
106270: PUSH
106271: LD_INT 31
106273: PUSH
106274: LD_INT 25
106276: PUSH
106277: EMPTY
106278: LIST
106279: LIST
106280: PUSH
106281: EMPTY
106282: LIST
106283: LIST
106284: PPUSH
106285: CALL_OW 69
106289: ST_TO_ADDR
// end ;
106290: LD_VAR 0 2
106294: RET
// export function Shuffle ( array ) ; var i , index ; begin
106295: LD_INT 0
106297: PPUSH
106298: PPUSH
106299: PPUSH
// result := [ ] ;
106300: LD_ADDR_VAR 0 2
106304: PUSH
106305: EMPTY
106306: ST_TO_ADDR
// if not array then
106307: LD_VAR 0 1
106311: NOT
106312: IFFALSE 106316
// exit ;
106314: GO 106415
// Randomize ;
106316: CALL_OW 10
// for i = array downto 1 do
106320: LD_ADDR_VAR 0 3
106324: PUSH
106325: DOUBLE
106326: LD_VAR 0 1
106330: INC
106331: ST_TO_ADDR
106332: LD_INT 1
106334: PUSH
106335: FOR_DOWNTO
106336: IFFALSE 106413
// begin index := rand ( 1 , array ) ;
106338: LD_ADDR_VAR 0 4
106342: PUSH
106343: LD_INT 1
106345: PPUSH
106346: LD_VAR 0 1
106350: PPUSH
106351: CALL_OW 12
106355: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
106356: LD_ADDR_VAR 0 2
106360: PUSH
106361: LD_VAR 0 2
106365: PPUSH
106366: LD_VAR 0 2
106370: PUSH
106371: LD_INT 1
106373: PLUS
106374: PPUSH
106375: LD_VAR 0 1
106379: PUSH
106380: LD_VAR 0 4
106384: ARRAY
106385: PPUSH
106386: CALL_OW 2
106390: ST_TO_ADDR
// array := Delete ( array , index ) ;
106391: LD_ADDR_VAR 0 1
106395: PUSH
106396: LD_VAR 0 1
106400: PPUSH
106401: LD_VAR 0 4
106405: PPUSH
106406: CALL_OW 3
106410: ST_TO_ADDR
// end ;
106411: GO 106335
106413: POP
106414: POP
// end ;
106415: LD_VAR 0 2
106419: RET
// export function GetBaseMaterials ( base ) ; begin
106420: LD_INT 0
106422: PPUSH
// result := [ 0 , 0 , 0 ] ;
106423: LD_ADDR_VAR 0 2
106427: PUSH
106428: LD_INT 0
106430: PUSH
106431: LD_INT 0
106433: PUSH
106434: LD_INT 0
106436: PUSH
106437: EMPTY
106438: LIST
106439: LIST
106440: LIST
106441: ST_TO_ADDR
// if not base then
106442: LD_VAR 0 1
106446: NOT
106447: IFFALSE 106451
// exit ;
106449: GO 106500
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
106451: LD_ADDR_VAR 0 2
106455: PUSH
106456: LD_VAR 0 1
106460: PPUSH
106461: LD_INT 1
106463: PPUSH
106464: CALL_OW 275
106468: PUSH
106469: LD_VAR 0 1
106473: PPUSH
106474: LD_INT 2
106476: PPUSH
106477: CALL_OW 275
106481: PUSH
106482: LD_VAR 0 1
106486: PPUSH
106487: LD_INT 3
106489: PPUSH
106490: CALL_OW 275
106494: PUSH
106495: EMPTY
106496: LIST
106497: LIST
106498: LIST
106499: ST_TO_ADDR
// end ;
106500: LD_VAR 0 2
106504: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
106505: LD_INT 0
106507: PPUSH
106508: PPUSH
// result := array ;
106509: LD_ADDR_VAR 0 3
106513: PUSH
106514: LD_VAR 0 1
106518: ST_TO_ADDR
// if size >= result then
106519: LD_VAR 0 2
106523: PUSH
106524: LD_VAR 0 3
106528: GREATEREQUAL
106529: IFFALSE 106533
// exit ;
106531: GO 106583
// if size then
106533: LD_VAR 0 2
106537: IFFALSE 106583
// for i := array downto size do
106539: LD_ADDR_VAR 0 4
106543: PUSH
106544: DOUBLE
106545: LD_VAR 0 1
106549: INC
106550: ST_TO_ADDR
106551: LD_VAR 0 2
106555: PUSH
106556: FOR_DOWNTO
106557: IFFALSE 106581
// result := Delete ( result , result ) ;
106559: LD_ADDR_VAR 0 3
106563: PUSH
106564: LD_VAR 0 3
106568: PPUSH
106569: LD_VAR 0 3
106573: PPUSH
106574: CALL_OW 3
106578: ST_TO_ADDR
106579: GO 106556
106581: POP
106582: POP
// end ;
106583: LD_VAR 0 3
106587: RET
// export function ComExit ( unit ) ; var tmp ; begin
106588: LD_INT 0
106590: PPUSH
106591: PPUSH
// if not IsInUnit ( unit ) then
106592: LD_VAR 0 1
106596: PPUSH
106597: CALL_OW 310
106601: NOT
106602: IFFALSE 106606
// exit ;
106604: GO 106666
// tmp := IsInUnit ( unit ) ;
106606: LD_ADDR_VAR 0 3
106610: PUSH
106611: LD_VAR 0 1
106615: PPUSH
106616: CALL_OW 310
106620: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
106621: LD_VAR 0 3
106625: PPUSH
106626: CALL_OW 247
106630: PUSH
106631: LD_INT 2
106633: EQUAL
106634: IFFALSE 106647
// ComExitVehicle ( unit ) else
106636: LD_VAR 0 1
106640: PPUSH
106641: CALL_OW 121
106645: GO 106656
// ComExitBuilding ( unit ) ;
106647: LD_VAR 0 1
106651: PPUSH
106652: CALL_OW 122
// result := tmp ;
106656: LD_ADDR_VAR 0 2
106660: PUSH
106661: LD_VAR 0 3
106665: ST_TO_ADDR
// end ;
106666: LD_VAR 0 2
106670: RET
// export function ComExitAll ( units ) ; var i ; begin
106671: LD_INT 0
106673: PPUSH
106674: PPUSH
// if not units then
106675: LD_VAR 0 1
106679: NOT
106680: IFFALSE 106684
// exit ;
106682: GO 106710
// for i in units do
106684: LD_ADDR_VAR 0 3
106688: PUSH
106689: LD_VAR 0 1
106693: PUSH
106694: FOR_IN
106695: IFFALSE 106708
// ComExit ( i ) ;
106697: LD_VAR 0 3
106701: PPUSH
106702: CALL 106588 0 1
106706: GO 106694
106708: POP
106709: POP
// end ;
106710: LD_VAR 0 2
106714: RET
// export function ResetHc ; begin
106715: LD_INT 0
106717: PPUSH
// InitHc ;
106718: CALL_OW 19
// hc_importance := 0 ;
106722: LD_ADDR_OWVAR 32
106726: PUSH
106727: LD_INT 0
106729: ST_TO_ADDR
// end ;
106730: LD_VAR 0 1
106734: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
106735: LD_INT 0
106737: PPUSH
106738: PPUSH
106739: PPUSH
// _x := ( x1 + x2 ) div 2 ;
106740: LD_ADDR_VAR 0 6
106744: PUSH
106745: LD_VAR 0 1
106749: PUSH
106750: LD_VAR 0 3
106754: PLUS
106755: PUSH
106756: LD_INT 2
106758: DIV
106759: ST_TO_ADDR
// if _x < 0 then
106760: LD_VAR 0 6
106764: PUSH
106765: LD_INT 0
106767: LESS
106768: IFFALSE 106785
// _x := _x * - 1 ;
106770: LD_ADDR_VAR 0 6
106774: PUSH
106775: LD_VAR 0 6
106779: PUSH
106780: LD_INT 1
106782: NEG
106783: MUL
106784: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
106785: LD_ADDR_VAR 0 7
106789: PUSH
106790: LD_VAR 0 2
106794: PUSH
106795: LD_VAR 0 4
106799: PLUS
106800: PUSH
106801: LD_INT 2
106803: DIV
106804: ST_TO_ADDR
// if _y < 0 then
106805: LD_VAR 0 7
106809: PUSH
106810: LD_INT 0
106812: LESS
106813: IFFALSE 106830
// _y := _y * - 1 ;
106815: LD_ADDR_VAR 0 7
106819: PUSH
106820: LD_VAR 0 7
106824: PUSH
106825: LD_INT 1
106827: NEG
106828: MUL
106829: ST_TO_ADDR
// result := [ _x , _y ] ;
106830: LD_ADDR_VAR 0 5
106834: PUSH
106835: LD_VAR 0 6
106839: PUSH
106840: LD_VAR 0 7
106844: PUSH
106845: EMPTY
106846: LIST
106847: LIST
106848: ST_TO_ADDR
// end ;
106849: LD_VAR 0 5
106853: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
106854: LD_INT 0
106856: PPUSH
106857: PPUSH
106858: PPUSH
106859: PPUSH
// task := GetTaskList ( unit ) ;
106860: LD_ADDR_VAR 0 7
106864: PUSH
106865: LD_VAR 0 1
106869: PPUSH
106870: CALL_OW 437
106874: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
106875: LD_VAR 0 7
106879: NOT
106880: PUSH
106881: LD_VAR 0 1
106885: PPUSH
106886: LD_VAR 0 2
106890: PPUSH
106891: CALL_OW 308
106895: NOT
106896: AND
106897: IFFALSE 106901
// exit ;
106899: GO 107019
// if IsInArea ( unit , area ) then
106901: LD_VAR 0 1
106905: PPUSH
106906: LD_VAR 0 2
106910: PPUSH
106911: CALL_OW 308
106915: IFFALSE 106933
// begin ComMoveToArea ( unit , goAway ) ;
106917: LD_VAR 0 1
106921: PPUSH
106922: LD_VAR 0 3
106926: PPUSH
106927: CALL_OW 113
// exit ;
106931: GO 107019
// end ; if task [ 1 ] [ 1 ] <> M then
106933: LD_VAR 0 7
106937: PUSH
106938: LD_INT 1
106940: ARRAY
106941: PUSH
106942: LD_INT 1
106944: ARRAY
106945: PUSH
106946: LD_STRING M
106948: NONEQUAL
106949: IFFALSE 106953
// exit ;
106951: GO 107019
// x := task [ 1 ] [ 2 ] ;
106953: LD_ADDR_VAR 0 5
106957: PUSH
106958: LD_VAR 0 7
106962: PUSH
106963: LD_INT 1
106965: ARRAY
106966: PUSH
106967: LD_INT 2
106969: ARRAY
106970: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
106971: LD_ADDR_VAR 0 6
106975: PUSH
106976: LD_VAR 0 7
106980: PUSH
106981: LD_INT 1
106983: ARRAY
106984: PUSH
106985: LD_INT 3
106987: ARRAY
106988: ST_TO_ADDR
// if InArea ( x , y , area ) then
106989: LD_VAR 0 5
106993: PPUSH
106994: LD_VAR 0 6
106998: PPUSH
106999: LD_VAR 0 2
107003: PPUSH
107004: CALL_OW 309
107008: IFFALSE 107019
// ComStop ( unit ) ;
107010: LD_VAR 0 1
107014: PPUSH
107015: CALL_OW 141
// end ;
107019: LD_VAR 0 4
107023: RET
// export function Abs ( value ) ; begin
107024: LD_INT 0
107026: PPUSH
// result := value ;
107027: LD_ADDR_VAR 0 2
107031: PUSH
107032: LD_VAR 0 1
107036: ST_TO_ADDR
// if value < 0 then
107037: LD_VAR 0 1
107041: PUSH
107042: LD_INT 0
107044: LESS
107045: IFFALSE 107062
// result := value * - 1 ;
107047: LD_ADDR_VAR 0 2
107051: PUSH
107052: LD_VAR 0 1
107056: PUSH
107057: LD_INT 1
107059: NEG
107060: MUL
107061: ST_TO_ADDR
// end ;
107062: LD_VAR 0 2
107066: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
107067: LD_INT 0
107069: PPUSH
107070: PPUSH
107071: PPUSH
107072: PPUSH
107073: PPUSH
107074: PPUSH
107075: PPUSH
107076: PPUSH
// if not unit or not building then
107077: LD_VAR 0 1
107081: NOT
107082: PUSH
107083: LD_VAR 0 2
107087: NOT
107088: OR
107089: IFFALSE 107093
// exit ;
107091: GO 107319
// x := GetX ( building ) ;
107093: LD_ADDR_VAR 0 4
107097: PUSH
107098: LD_VAR 0 2
107102: PPUSH
107103: CALL_OW 250
107107: ST_TO_ADDR
// y := GetY ( building ) ;
107108: LD_ADDR_VAR 0 6
107112: PUSH
107113: LD_VAR 0 2
107117: PPUSH
107118: CALL_OW 251
107122: ST_TO_ADDR
// d := GetDir ( building ) ;
107123: LD_ADDR_VAR 0 8
107127: PUSH
107128: LD_VAR 0 2
107132: PPUSH
107133: CALL_OW 254
107137: ST_TO_ADDR
// r := 4 ;
107138: LD_ADDR_VAR 0 9
107142: PUSH
107143: LD_INT 4
107145: ST_TO_ADDR
// for i := 1 to 5 do
107146: LD_ADDR_VAR 0 10
107150: PUSH
107151: DOUBLE
107152: LD_INT 1
107154: DEC
107155: ST_TO_ADDR
107156: LD_INT 5
107158: PUSH
107159: FOR_TO
107160: IFFALSE 107317
// begin _x := ShiftX ( x , d , r + i ) ;
107162: LD_ADDR_VAR 0 5
107166: PUSH
107167: LD_VAR 0 4
107171: PPUSH
107172: LD_VAR 0 8
107176: PPUSH
107177: LD_VAR 0 9
107181: PUSH
107182: LD_VAR 0 10
107186: PLUS
107187: PPUSH
107188: CALL_OW 272
107192: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
107193: LD_ADDR_VAR 0 7
107197: PUSH
107198: LD_VAR 0 6
107202: PPUSH
107203: LD_VAR 0 8
107207: PPUSH
107208: LD_VAR 0 9
107212: PUSH
107213: LD_VAR 0 10
107217: PLUS
107218: PPUSH
107219: CALL_OW 273
107223: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
107224: LD_VAR 0 5
107228: PPUSH
107229: LD_VAR 0 7
107233: PPUSH
107234: CALL_OW 488
107238: PUSH
107239: LD_VAR 0 5
107243: PPUSH
107244: LD_VAR 0 7
107248: PPUSH
107249: CALL_OW 428
107253: PPUSH
107254: CALL_OW 247
107258: PUSH
107259: LD_INT 3
107261: PUSH
107262: LD_INT 2
107264: PUSH
107265: EMPTY
107266: LIST
107267: LIST
107268: IN
107269: NOT
107270: AND
107271: IFFALSE 107315
// begin ComMoveXY ( unit , _x , _y ) ;
107273: LD_VAR 0 1
107277: PPUSH
107278: LD_VAR 0 5
107282: PPUSH
107283: LD_VAR 0 7
107287: PPUSH
107288: CALL_OW 111
// result := [ _x , _y ] ;
107292: LD_ADDR_VAR 0 3
107296: PUSH
107297: LD_VAR 0 5
107301: PUSH
107302: LD_VAR 0 7
107306: PUSH
107307: EMPTY
107308: LIST
107309: LIST
107310: ST_TO_ADDR
// exit ;
107311: POP
107312: POP
107313: GO 107319
// end ; end ;
107315: GO 107159
107317: POP
107318: POP
// end ;
107319: LD_VAR 0 3
107323: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
107324: LD_INT 0
107326: PPUSH
107327: PPUSH
107328: PPUSH
// result := 0 ;
107329: LD_ADDR_VAR 0 3
107333: PUSH
107334: LD_INT 0
107336: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
107337: LD_VAR 0 1
107341: PUSH
107342: LD_INT 0
107344: LESS
107345: PUSH
107346: LD_VAR 0 1
107350: PUSH
107351: LD_INT 8
107353: GREATER
107354: OR
107355: PUSH
107356: LD_VAR 0 2
107360: PUSH
107361: LD_INT 0
107363: LESS
107364: OR
107365: PUSH
107366: LD_VAR 0 2
107370: PUSH
107371: LD_INT 8
107373: GREATER
107374: OR
107375: IFFALSE 107379
// exit ;
107377: GO 107454
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
107379: LD_ADDR_VAR 0 4
107383: PUSH
107384: LD_INT 22
107386: PUSH
107387: LD_VAR 0 2
107391: PUSH
107392: EMPTY
107393: LIST
107394: LIST
107395: PPUSH
107396: CALL_OW 69
107400: PUSH
107401: FOR_IN
107402: IFFALSE 107452
// begin un := UnitShoot ( i ) ;
107404: LD_ADDR_VAR 0 5
107408: PUSH
107409: LD_VAR 0 4
107413: PPUSH
107414: CALL_OW 504
107418: ST_TO_ADDR
// if GetSide ( un ) = side1 then
107419: LD_VAR 0 5
107423: PPUSH
107424: CALL_OW 255
107428: PUSH
107429: LD_VAR 0 1
107433: EQUAL
107434: IFFALSE 107450
// begin result := un ;
107436: LD_ADDR_VAR 0 3
107440: PUSH
107441: LD_VAR 0 5
107445: ST_TO_ADDR
// exit ;
107446: POP
107447: POP
107448: GO 107454
// end ; end ;
107450: GO 107401
107452: POP
107453: POP
// end ;
107454: LD_VAR 0 3
107458: RET
// export function GetCargoBay ( units ) ; begin
107459: LD_INT 0
107461: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
107462: LD_ADDR_VAR 0 2
107466: PUSH
107467: LD_VAR 0 1
107471: PPUSH
107472: LD_INT 2
107474: PUSH
107475: LD_INT 34
107477: PUSH
107478: LD_INT 12
107480: PUSH
107481: EMPTY
107482: LIST
107483: LIST
107484: PUSH
107485: LD_INT 34
107487: PUSH
107488: LD_INT 51
107490: PUSH
107491: EMPTY
107492: LIST
107493: LIST
107494: PUSH
107495: LD_INT 34
107497: PUSH
107498: LD_INT 32
107500: PUSH
107501: EMPTY
107502: LIST
107503: LIST
107504: PUSH
107505: LD_INT 34
107507: PUSH
107508: LD_INT 89
107510: PUSH
107511: EMPTY
107512: LIST
107513: LIST
107514: PUSH
107515: EMPTY
107516: LIST
107517: LIST
107518: LIST
107519: LIST
107520: LIST
107521: PPUSH
107522: CALL_OW 72
107526: ST_TO_ADDR
// end ;
107527: LD_VAR 0 2
107531: RET
// export function Negate ( value ) ; begin
107532: LD_INT 0
107534: PPUSH
// result := not value ;
107535: LD_ADDR_VAR 0 2
107539: PUSH
107540: LD_VAR 0 1
107544: NOT
107545: ST_TO_ADDR
// end ;
107546: LD_VAR 0 2
107550: RET
// export function Inc ( value ) ; begin
107551: LD_INT 0
107553: PPUSH
// result := value + 1 ;
107554: LD_ADDR_VAR 0 2
107558: PUSH
107559: LD_VAR 0 1
107563: PUSH
107564: LD_INT 1
107566: PLUS
107567: ST_TO_ADDR
// end ;
107568: LD_VAR 0 2
107572: RET
// export function Dec ( value ) ; begin
107573: LD_INT 0
107575: PPUSH
// result := value - 1 ;
107576: LD_ADDR_VAR 0 2
107580: PUSH
107581: LD_VAR 0 1
107585: PUSH
107586: LD_INT 1
107588: MINUS
107589: ST_TO_ADDR
// end ;
107590: LD_VAR 0 2
107594: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
107595: LD_INT 0
107597: PPUSH
107598: PPUSH
107599: PPUSH
107600: PPUSH
107601: PPUSH
107602: PPUSH
107603: PPUSH
107604: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
107605: LD_VAR 0 1
107609: PPUSH
107610: LD_VAR 0 2
107614: PPUSH
107615: CALL_OW 488
107619: NOT
107620: PUSH
107621: LD_VAR 0 3
107625: PPUSH
107626: LD_VAR 0 4
107630: PPUSH
107631: CALL_OW 488
107635: NOT
107636: OR
107637: IFFALSE 107650
// begin result := - 1 ;
107639: LD_ADDR_VAR 0 5
107643: PUSH
107644: LD_INT 1
107646: NEG
107647: ST_TO_ADDR
// exit ;
107648: GO 107885
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
107650: LD_ADDR_VAR 0 12
107654: PUSH
107655: LD_VAR 0 1
107659: PPUSH
107660: LD_VAR 0 2
107664: PPUSH
107665: LD_VAR 0 3
107669: PPUSH
107670: LD_VAR 0 4
107674: PPUSH
107675: CALL 106735 0 4
107679: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
107680: LD_ADDR_VAR 0 11
107684: PUSH
107685: LD_VAR 0 1
107689: PPUSH
107690: LD_VAR 0 2
107694: PPUSH
107695: LD_VAR 0 12
107699: PUSH
107700: LD_INT 1
107702: ARRAY
107703: PPUSH
107704: LD_VAR 0 12
107708: PUSH
107709: LD_INT 2
107711: ARRAY
107712: PPUSH
107713: CALL_OW 298
107717: ST_TO_ADDR
// distance := 9999 ;
107718: LD_ADDR_VAR 0 10
107722: PUSH
107723: LD_INT 9999
107725: ST_TO_ADDR
// for i := 0 to 5 do
107726: LD_ADDR_VAR 0 6
107730: PUSH
107731: DOUBLE
107732: LD_INT 0
107734: DEC
107735: ST_TO_ADDR
107736: LD_INT 5
107738: PUSH
107739: FOR_TO
107740: IFFALSE 107883
// begin _x := ShiftX ( x1 , i , centerDist ) ;
107742: LD_ADDR_VAR 0 7
107746: PUSH
107747: LD_VAR 0 1
107751: PPUSH
107752: LD_VAR 0 6
107756: PPUSH
107757: LD_VAR 0 11
107761: PPUSH
107762: CALL_OW 272
107766: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
107767: LD_ADDR_VAR 0 8
107771: PUSH
107772: LD_VAR 0 2
107776: PPUSH
107777: LD_VAR 0 6
107781: PPUSH
107782: LD_VAR 0 11
107786: PPUSH
107787: CALL_OW 273
107791: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107792: LD_VAR 0 7
107796: PPUSH
107797: LD_VAR 0 8
107801: PPUSH
107802: CALL_OW 488
107806: NOT
107807: IFFALSE 107811
// continue ;
107809: GO 107739
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
107811: LD_ADDR_VAR 0 9
107815: PUSH
107816: LD_VAR 0 12
107820: PUSH
107821: LD_INT 1
107823: ARRAY
107824: PPUSH
107825: LD_VAR 0 12
107829: PUSH
107830: LD_INT 2
107832: ARRAY
107833: PPUSH
107834: LD_VAR 0 7
107838: PPUSH
107839: LD_VAR 0 8
107843: PPUSH
107844: CALL_OW 298
107848: ST_TO_ADDR
// if tmp < distance then
107849: LD_VAR 0 9
107853: PUSH
107854: LD_VAR 0 10
107858: LESS
107859: IFFALSE 107881
// begin result := i ;
107861: LD_ADDR_VAR 0 5
107865: PUSH
107866: LD_VAR 0 6
107870: ST_TO_ADDR
// distance := tmp ;
107871: LD_ADDR_VAR 0 10
107875: PUSH
107876: LD_VAR 0 9
107880: ST_TO_ADDR
// end ; end ;
107881: GO 107739
107883: POP
107884: POP
// end ;
107885: LD_VAR 0 5
107889: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
107890: LD_INT 0
107892: PPUSH
107893: PPUSH
// if not driver or not IsInUnit ( driver ) then
107894: LD_VAR 0 1
107898: NOT
107899: PUSH
107900: LD_VAR 0 1
107904: PPUSH
107905: CALL_OW 310
107909: NOT
107910: OR
107911: IFFALSE 107915
// exit ;
107913: GO 108005
// vehicle := IsInUnit ( driver ) ;
107915: LD_ADDR_VAR 0 3
107919: PUSH
107920: LD_VAR 0 1
107924: PPUSH
107925: CALL_OW 310
107929: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
107930: LD_VAR 0 1
107934: PPUSH
107935: LD_STRING \
107937: PUSH
107938: LD_INT 0
107940: PUSH
107941: LD_INT 0
107943: PUSH
107944: LD_INT 0
107946: PUSH
107947: LD_INT 0
107949: PUSH
107950: LD_INT 0
107952: PUSH
107953: LD_INT 0
107955: PUSH
107956: EMPTY
107957: LIST
107958: LIST
107959: LIST
107960: LIST
107961: LIST
107962: LIST
107963: LIST
107964: PUSH
107965: LD_STRING E
107967: PUSH
107968: LD_INT 0
107970: PUSH
107971: LD_INT 0
107973: PUSH
107974: LD_VAR 0 3
107978: PUSH
107979: LD_INT 0
107981: PUSH
107982: LD_INT 0
107984: PUSH
107985: LD_INT 0
107987: PUSH
107988: EMPTY
107989: LIST
107990: LIST
107991: LIST
107992: LIST
107993: LIST
107994: LIST
107995: LIST
107996: PUSH
107997: EMPTY
107998: LIST
107999: LIST
108000: PPUSH
108001: CALL_OW 446
// end ;
108005: LD_VAR 0 2
108009: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
108010: LD_INT 0
108012: PPUSH
108013: PPUSH
// if not driver or not IsInUnit ( driver ) then
108014: LD_VAR 0 1
108018: NOT
108019: PUSH
108020: LD_VAR 0 1
108024: PPUSH
108025: CALL_OW 310
108029: NOT
108030: OR
108031: IFFALSE 108035
// exit ;
108033: GO 108125
// vehicle := IsInUnit ( driver ) ;
108035: LD_ADDR_VAR 0 3
108039: PUSH
108040: LD_VAR 0 1
108044: PPUSH
108045: CALL_OW 310
108049: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
108050: LD_VAR 0 1
108054: PPUSH
108055: LD_STRING \
108057: PUSH
108058: LD_INT 0
108060: PUSH
108061: LD_INT 0
108063: PUSH
108064: LD_INT 0
108066: PUSH
108067: LD_INT 0
108069: PUSH
108070: LD_INT 0
108072: PUSH
108073: LD_INT 0
108075: PUSH
108076: EMPTY
108077: LIST
108078: LIST
108079: LIST
108080: LIST
108081: LIST
108082: LIST
108083: LIST
108084: PUSH
108085: LD_STRING E
108087: PUSH
108088: LD_INT 0
108090: PUSH
108091: LD_INT 0
108093: PUSH
108094: LD_VAR 0 3
108098: PUSH
108099: LD_INT 0
108101: PUSH
108102: LD_INT 0
108104: PUSH
108105: LD_INT 0
108107: PUSH
108108: EMPTY
108109: LIST
108110: LIST
108111: LIST
108112: LIST
108113: LIST
108114: LIST
108115: LIST
108116: PUSH
108117: EMPTY
108118: LIST
108119: LIST
108120: PPUSH
108121: CALL_OW 447
// end ;
108125: LD_VAR 0 2
108129: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
108130: LD_INT 0
108132: PPUSH
108133: PPUSH
108134: PPUSH
// tmp := [ ] ;
108135: LD_ADDR_VAR 0 5
108139: PUSH
108140: EMPTY
108141: ST_TO_ADDR
// for i in units do
108142: LD_ADDR_VAR 0 4
108146: PUSH
108147: LD_VAR 0 1
108151: PUSH
108152: FOR_IN
108153: IFFALSE 108191
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
108155: LD_ADDR_VAR 0 5
108159: PUSH
108160: LD_VAR 0 5
108164: PPUSH
108165: LD_VAR 0 5
108169: PUSH
108170: LD_INT 1
108172: PLUS
108173: PPUSH
108174: LD_VAR 0 4
108178: PPUSH
108179: CALL_OW 256
108183: PPUSH
108184: CALL_OW 2
108188: ST_TO_ADDR
108189: GO 108152
108191: POP
108192: POP
// if not tmp then
108193: LD_VAR 0 5
108197: NOT
108198: IFFALSE 108202
// exit ;
108200: GO 108250
// if asc then
108202: LD_VAR 0 2
108206: IFFALSE 108230
// result := SortListByListAsc ( units , tmp ) else
108208: LD_ADDR_VAR 0 3
108212: PUSH
108213: LD_VAR 0 1
108217: PPUSH
108218: LD_VAR 0 5
108222: PPUSH
108223: CALL_OW 76
108227: ST_TO_ADDR
108228: GO 108250
// result := SortListByListDesc ( units , tmp ) ;
108230: LD_ADDR_VAR 0 3
108234: PUSH
108235: LD_VAR 0 1
108239: PPUSH
108240: LD_VAR 0 5
108244: PPUSH
108245: CALL_OW 77
108249: ST_TO_ADDR
// end ;
108250: LD_VAR 0 3
108254: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
108255: LD_INT 0
108257: PPUSH
108258: PPUSH
// task := GetTaskList ( mech ) ;
108259: LD_ADDR_VAR 0 4
108263: PUSH
108264: LD_VAR 0 1
108268: PPUSH
108269: CALL_OW 437
108273: ST_TO_ADDR
// if not task then
108274: LD_VAR 0 4
108278: NOT
108279: IFFALSE 108283
// exit ;
108281: GO 108325
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
108283: LD_ADDR_VAR 0 3
108287: PUSH
108288: LD_VAR 0 4
108292: PUSH
108293: LD_INT 1
108295: ARRAY
108296: PUSH
108297: LD_INT 1
108299: ARRAY
108300: PUSH
108301: LD_STRING r
108303: EQUAL
108304: PUSH
108305: LD_VAR 0 4
108309: PUSH
108310: LD_INT 1
108312: ARRAY
108313: PUSH
108314: LD_INT 4
108316: ARRAY
108317: PUSH
108318: LD_VAR 0 2
108322: EQUAL
108323: AND
108324: ST_TO_ADDR
// end ;
108325: LD_VAR 0 3
108329: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
108330: LD_INT 0
108332: PPUSH
// SetDir ( unit , d ) ;
108333: LD_VAR 0 1
108337: PPUSH
108338: LD_VAR 0 4
108342: PPUSH
108343: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
108347: LD_VAR 0 1
108351: PPUSH
108352: LD_VAR 0 2
108356: PPUSH
108357: LD_VAR 0 3
108361: PPUSH
108362: LD_VAR 0 5
108366: PPUSH
108367: CALL_OW 48
// end ;
108371: LD_VAR 0 6
108375: RET
// export function ToNaturalNumber ( number ) ; begin
108376: LD_INT 0
108378: PPUSH
// result := number div 1 ;
108379: LD_ADDR_VAR 0 2
108383: PUSH
108384: LD_VAR 0 1
108388: PUSH
108389: LD_INT 1
108391: DIV
108392: ST_TO_ADDR
// if number < 0 then
108393: LD_VAR 0 1
108397: PUSH
108398: LD_INT 0
108400: LESS
108401: IFFALSE 108411
// result := 0 ;
108403: LD_ADDR_VAR 0 2
108407: PUSH
108408: LD_INT 0
108410: ST_TO_ADDR
// end ;
108411: LD_VAR 0 2
108415: RET
// export function SortByClass ( units , class ) ; var un ; begin
108416: LD_INT 0
108418: PPUSH
108419: PPUSH
// if not units or not class then
108420: LD_VAR 0 1
108424: NOT
108425: PUSH
108426: LD_VAR 0 2
108430: NOT
108431: OR
108432: IFFALSE 108436
// exit ;
108434: GO 108531
// result := [ ] ;
108436: LD_ADDR_VAR 0 3
108440: PUSH
108441: EMPTY
108442: ST_TO_ADDR
// for un in units do
108443: LD_ADDR_VAR 0 4
108447: PUSH
108448: LD_VAR 0 1
108452: PUSH
108453: FOR_IN
108454: IFFALSE 108529
// if GetClass ( un ) = class then
108456: LD_VAR 0 4
108460: PPUSH
108461: CALL_OW 257
108465: PUSH
108466: LD_VAR 0 2
108470: EQUAL
108471: IFFALSE 108498
// result := Insert ( result , 1 , un ) else
108473: LD_ADDR_VAR 0 3
108477: PUSH
108478: LD_VAR 0 3
108482: PPUSH
108483: LD_INT 1
108485: PPUSH
108486: LD_VAR 0 4
108490: PPUSH
108491: CALL_OW 2
108495: ST_TO_ADDR
108496: GO 108527
// result := Replace ( result , result + 1 , un ) ;
108498: LD_ADDR_VAR 0 3
108502: PUSH
108503: LD_VAR 0 3
108507: PPUSH
108508: LD_VAR 0 3
108512: PUSH
108513: LD_INT 1
108515: PLUS
108516: PPUSH
108517: LD_VAR 0 4
108521: PPUSH
108522: CALL_OW 1
108526: ST_TO_ADDR
108527: GO 108453
108529: POP
108530: POP
// end ;
108531: LD_VAR 0 3
108535: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
108536: LD_INT 0
108538: PPUSH
108539: PPUSH
108540: PPUSH
108541: PPUSH
108542: PPUSH
108543: PPUSH
108544: PPUSH
// result := [ ] ;
108545: LD_ADDR_VAR 0 4
108549: PUSH
108550: EMPTY
108551: ST_TO_ADDR
// if x - r < 0 then
108552: LD_VAR 0 1
108556: PUSH
108557: LD_VAR 0 3
108561: MINUS
108562: PUSH
108563: LD_INT 0
108565: LESS
108566: IFFALSE 108578
// min_x := 0 else
108568: LD_ADDR_VAR 0 8
108572: PUSH
108573: LD_INT 0
108575: ST_TO_ADDR
108576: GO 108594
// min_x := x - r ;
108578: LD_ADDR_VAR 0 8
108582: PUSH
108583: LD_VAR 0 1
108587: PUSH
108588: LD_VAR 0 3
108592: MINUS
108593: ST_TO_ADDR
// if y - r < 0 then
108594: LD_VAR 0 2
108598: PUSH
108599: LD_VAR 0 3
108603: MINUS
108604: PUSH
108605: LD_INT 0
108607: LESS
108608: IFFALSE 108620
// min_y := 0 else
108610: LD_ADDR_VAR 0 7
108614: PUSH
108615: LD_INT 0
108617: ST_TO_ADDR
108618: GO 108636
// min_y := y - r ;
108620: LD_ADDR_VAR 0 7
108624: PUSH
108625: LD_VAR 0 2
108629: PUSH
108630: LD_VAR 0 3
108634: MINUS
108635: ST_TO_ADDR
// max_x := x + r ;
108636: LD_ADDR_VAR 0 9
108640: PUSH
108641: LD_VAR 0 1
108645: PUSH
108646: LD_VAR 0 3
108650: PLUS
108651: ST_TO_ADDR
// max_y := y + r ;
108652: LD_ADDR_VAR 0 10
108656: PUSH
108657: LD_VAR 0 2
108661: PUSH
108662: LD_VAR 0 3
108666: PLUS
108667: ST_TO_ADDR
// for _x = min_x to max_x do
108668: LD_ADDR_VAR 0 5
108672: PUSH
108673: DOUBLE
108674: LD_VAR 0 8
108678: DEC
108679: ST_TO_ADDR
108680: LD_VAR 0 9
108684: PUSH
108685: FOR_TO
108686: IFFALSE 108787
// for _y = min_y to max_y do
108688: LD_ADDR_VAR 0 6
108692: PUSH
108693: DOUBLE
108694: LD_VAR 0 7
108698: DEC
108699: ST_TO_ADDR
108700: LD_VAR 0 10
108704: PUSH
108705: FOR_TO
108706: IFFALSE 108783
// begin if not ValidHex ( _x , _y ) then
108708: LD_VAR 0 5
108712: PPUSH
108713: LD_VAR 0 6
108717: PPUSH
108718: CALL_OW 488
108722: NOT
108723: IFFALSE 108727
// continue ;
108725: GO 108705
// if GetResourceTypeXY ( _x , _y ) then
108727: LD_VAR 0 5
108731: PPUSH
108732: LD_VAR 0 6
108736: PPUSH
108737: CALL_OW 283
108741: IFFALSE 108781
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
108743: LD_ADDR_VAR 0 4
108747: PUSH
108748: LD_VAR 0 4
108752: PPUSH
108753: LD_VAR 0 4
108757: PUSH
108758: LD_INT 1
108760: PLUS
108761: PPUSH
108762: LD_VAR 0 5
108766: PUSH
108767: LD_VAR 0 6
108771: PUSH
108772: EMPTY
108773: LIST
108774: LIST
108775: PPUSH
108776: CALL_OW 1
108780: ST_TO_ADDR
// end ;
108781: GO 108705
108783: POP
108784: POP
108785: GO 108685
108787: POP
108788: POP
// end ;
108789: LD_VAR 0 4
108793: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
108794: LD_INT 0
108796: PPUSH
108797: PPUSH
108798: PPUSH
108799: PPUSH
108800: PPUSH
108801: PPUSH
108802: PPUSH
108803: PPUSH
// if not units then
108804: LD_VAR 0 1
108808: NOT
108809: IFFALSE 108813
// exit ;
108811: GO 109337
// result := UnitFilter ( units , [ f_ok ] ) ;
108813: LD_ADDR_VAR 0 3
108817: PUSH
108818: LD_VAR 0 1
108822: PPUSH
108823: LD_INT 50
108825: PUSH
108826: EMPTY
108827: LIST
108828: PPUSH
108829: CALL_OW 72
108833: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
108834: LD_ADDR_VAR 0 8
108838: PUSH
108839: LD_VAR 0 1
108843: PUSH
108844: LD_INT 1
108846: ARRAY
108847: PPUSH
108848: CALL_OW 255
108852: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
108853: LD_ADDR_VAR 0 10
108857: PUSH
108858: LD_INT 29
108860: PUSH
108861: LD_INT 91
108863: PUSH
108864: LD_INT 49
108866: PUSH
108867: EMPTY
108868: LIST
108869: LIST
108870: LIST
108871: ST_TO_ADDR
// if not result then
108872: LD_VAR 0 3
108876: NOT
108877: IFFALSE 108881
// exit ;
108879: GO 109337
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
108881: LD_ADDR_VAR 0 5
108885: PUSH
108886: LD_INT 81
108888: PUSH
108889: LD_VAR 0 8
108893: PUSH
108894: EMPTY
108895: LIST
108896: LIST
108897: PPUSH
108898: CALL_OW 69
108902: ST_TO_ADDR
// for i in result do
108903: LD_ADDR_VAR 0 4
108907: PUSH
108908: LD_VAR 0 3
108912: PUSH
108913: FOR_IN
108914: IFFALSE 109335
// begin tag := GetTag ( i ) + 1 ;
108916: LD_ADDR_VAR 0 9
108920: PUSH
108921: LD_VAR 0 4
108925: PPUSH
108926: CALL_OW 110
108930: PUSH
108931: LD_INT 1
108933: PLUS
108934: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
108935: LD_ADDR_VAR 0 7
108939: PUSH
108940: LD_VAR 0 4
108944: PPUSH
108945: CALL_OW 250
108949: PPUSH
108950: LD_VAR 0 4
108954: PPUSH
108955: CALL_OW 251
108959: PPUSH
108960: LD_INT 6
108962: PPUSH
108963: CALL 108536 0 3
108967: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
108968: LD_VAR 0 4
108972: PPUSH
108973: CALL_OW 247
108977: PUSH
108978: LD_INT 2
108980: EQUAL
108981: PUSH
108982: LD_VAR 0 7
108986: AND
108987: PUSH
108988: LD_VAR 0 4
108992: PPUSH
108993: CALL_OW 264
108997: PUSH
108998: LD_VAR 0 10
109002: IN
109003: NOT
109004: AND
109005: IFFALSE 109044
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
109007: LD_VAR 0 4
109011: PPUSH
109012: LD_VAR 0 7
109016: PUSH
109017: LD_INT 1
109019: ARRAY
109020: PUSH
109021: LD_INT 1
109023: ARRAY
109024: PPUSH
109025: LD_VAR 0 7
109029: PUSH
109030: LD_INT 1
109032: ARRAY
109033: PUSH
109034: LD_INT 2
109036: ARRAY
109037: PPUSH
109038: CALL_OW 116
109042: GO 109333
// if path > tag then
109044: LD_VAR 0 2
109048: PUSH
109049: LD_VAR 0 9
109053: GREATER
109054: IFFALSE 109262
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
109056: LD_ADDR_VAR 0 6
109060: PUSH
109061: LD_VAR 0 5
109065: PPUSH
109066: LD_INT 91
109068: PUSH
109069: LD_VAR 0 4
109073: PUSH
109074: LD_INT 8
109076: PUSH
109077: EMPTY
109078: LIST
109079: LIST
109080: LIST
109081: PPUSH
109082: CALL_OW 72
109086: ST_TO_ADDR
// if nearEnemy then
109087: LD_VAR 0 6
109091: IFFALSE 109160
// begin if GetWeapon ( i ) = ru_time_lapser then
109093: LD_VAR 0 4
109097: PPUSH
109098: CALL_OW 264
109102: PUSH
109103: LD_INT 49
109105: EQUAL
109106: IFFALSE 109134
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
109108: LD_VAR 0 4
109112: PPUSH
109113: LD_VAR 0 6
109117: PPUSH
109118: LD_VAR 0 4
109122: PPUSH
109123: CALL_OW 74
109127: PPUSH
109128: CALL_OW 112
109132: GO 109158
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
109134: LD_VAR 0 4
109138: PPUSH
109139: LD_VAR 0 6
109143: PPUSH
109144: LD_VAR 0 4
109148: PPUSH
109149: CALL_OW 74
109153: PPUSH
109154: CALL_OW 115
// end else
109158: GO 109260
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
109160: LD_VAR 0 4
109164: PPUSH
109165: LD_VAR 0 2
109169: PUSH
109170: LD_VAR 0 9
109174: ARRAY
109175: PUSH
109176: LD_INT 1
109178: ARRAY
109179: PPUSH
109180: LD_VAR 0 2
109184: PUSH
109185: LD_VAR 0 9
109189: ARRAY
109190: PUSH
109191: LD_INT 2
109193: ARRAY
109194: PPUSH
109195: CALL_OW 297
109199: PUSH
109200: LD_INT 6
109202: GREATER
109203: IFFALSE 109246
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
109205: LD_VAR 0 4
109209: PPUSH
109210: LD_VAR 0 2
109214: PUSH
109215: LD_VAR 0 9
109219: ARRAY
109220: PUSH
109221: LD_INT 1
109223: ARRAY
109224: PPUSH
109225: LD_VAR 0 2
109229: PUSH
109230: LD_VAR 0 9
109234: ARRAY
109235: PUSH
109236: LD_INT 2
109238: ARRAY
109239: PPUSH
109240: CALL_OW 114
109244: GO 109260
// SetTag ( i , tag ) ;
109246: LD_VAR 0 4
109250: PPUSH
109251: LD_VAR 0 9
109255: PPUSH
109256: CALL_OW 109
// end else
109260: GO 109333
// if enemy then
109262: LD_VAR 0 5
109266: IFFALSE 109333
// begin if GetWeapon ( i ) = ru_time_lapser then
109268: LD_VAR 0 4
109272: PPUSH
109273: CALL_OW 264
109277: PUSH
109278: LD_INT 49
109280: EQUAL
109281: IFFALSE 109309
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
109283: LD_VAR 0 4
109287: PPUSH
109288: LD_VAR 0 5
109292: PPUSH
109293: LD_VAR 0 4
109297: PPUSH
109298: CALL_OW 74
109302: PPUSH
109303: CALL_OW 112
109307: GO 109333
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
109309: LD_VAR 0 4
109313: PPUSH
109314: LD_VAR 0 5
109318: PPUSH
109319: LD_VAR 0 4
109323: PPUSH
109324: CALL_OW 74
109328: PPUSH
109329: CALL_OW 115
// end ; end ;
109333: GO 108913
109335: POP
109336: POP
// end ;
109337: LD_VAR 0 3
109341: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
109342: LD_INT 0
109344: PPUSH
109345: PPUSH
109346: PPUSH
// if not unit or IsInUnit ( unit ) then
109347: LD_VAR 0 1
109351: NOT
109352: PUSH
109353: LD_VAR 0 1
109357: PPUSH
109358: CALL_OW 310
109362: OR
109363: IFFALSE 109367
// exit ;
109365: GO 109458
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
109367: LD_ADDR_VAR 0 4
109371: PUSH
109372: LD_VAR 0 1
109376: PPUSH
109377: CALL_OW 250
109381: PPUSH
109382: LD_VAR 0 2
109386: PPUSH
109387: LD_INT 1
109389: PPUSH
109390: CALL_OW 272
109394: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
109395: LD_ADDR_VAR 0 5
109399: PUSH
109400: LD_VAR 0 1
109404: PPUSH
109405: CALL_OW 251
109409: PPUSH
109410: LD_VAR 0 2
109414: PPUSH
109415: LD_INT 1
109417: PPUSH
109418: CALL_OW 273
109422: ST_TO_ADDR
// if ValidHex ( x , y ) then
109423: LD_VAR 0 4
109427: PPUSH
109428: LD_VAR 0 5
109432: PPUSH
109433: CALL_OW 488
109437: IFFALSE 109458
// ComTurnXY ( unit , x , y ) ;
109439: LD_VAR 0 1
109443: PPUSH
109444: LD_VAR 0 4
109448: PPUSH
109449: LD_VAR 0 5
109453: PPUSH
109454: CALL_OW 118
// end ;
109458: LD_VAR 0 3
109462: RET
// export function SeeUnits ( side , units ) ; var i ; begin
109463: LD_INT 0
109465: PPUSH
109466: PPUSH
// result := false ;
109467: LD_ADDR_VAR 0 3
109471: PUSH
109472: LD_INT 0
109474: ST_TO_ADDR
// if not units then
109475: LD_VAR 0 2
109479: NOT
109480: IFFALSE 109484
// exit ;
109482: GO 109529
// for i in units do
109484: LD_ADDR_VAR 0 4
109488: PUSH
109489: LD_VAR 0 2
109493: PUSH
109494: FOR_IN
109495: IFFALSE 109527
// if See ( side , i ) then
109497: LD_VAR 0 1
109501: PPUSH
109502: LD_VAR 0 4
109506: PPUSH
109507: CALL_OW 292
109511: IFFALSE 109525
// begin result := true ;
109513: LD_ADDR_VAR 0 3
109517: PUSH
109518: LD_INT 1
109520: ST_TO_ADDR
// exit ;
109521: POP
109522: POP
109523: GO 109529
// end ;
109525: GO 109494
109527: POP
109528: POP
// end ;
109529: LD_VAR 0 3
109533: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
109534: LD_INT 0
109536: PPUSH
109537: PPUSH
109538: PPUSH
109539: PPUSH
// if not unit or not points then
109540: LD_VAR 0 1
109544: NOT
109545: PUSH
109546: LD_VAR 0 2
109550: NOT
109551: OR
109552: IFFALSE 109556
// exit ;
109554: GO 109646
// dist := 99999 ;
109556: LD_ADDR_VAR 0 5
109560: PUSH
109561: LD_INT 99999
109563: ST_TO_ADDR
// for i in points do
109564: LD_ADDR_VAR 0 4
109568: PUSH
109569: LD_VAR 0 2
109573: PUSH
109574: FOR_IN
109575: IFFALSE 109644
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
109577: LD_ADDR_VAR 0 6
109581: PUSH
109582: LD_VAR 0 1
109586: PPUSH
109587: LD_VAR 0 4
109591: PUSH
109592: LD_INT 1
109594: ARRAY
109595: PPUSH
109596: LD_VAR 0 4
109600: PUSH
109601: LD_INT 2
109603: ARRAY
109604: PPUSH
109605: CALL_OW 297
109609: ST_TO_ADDR
// if tmpDist < dist then
109610: LD_VAR 0 6
109614: PUSH
109615: LD_VAR 0 5
109619: LESS
109620: IFFALSE 109642
// begin result := i ;
109622: LD_ADDR_VAR 0 3
109626: PUSH
109627: LD_VAR 0 4
109631: ST_TO_ADDR
// dist := tmpDist ;
109632: LD_ADDR_VAR 0 5
109636: PUSH
109637: LD_VAR 0 6
109641: ST_TO_ADDR
// end ; end ;
109642: GO 109574
109644: POP
109645: POP
// end ;
109646: LD_VAR 0 3
109650: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
109651: LD_INT 0
109653: PPUSH
// uc_side := side ;
109654: LD_ADDR_OWVAR 20
109658: PUSH
109659: LD_VAR 0 1
109663: ST_TO_ADDR
// uc_nation := 3 ;
109664: LD_ADDR_OWVAR 21
109668: PUSH
109669: LD_INT 3
109671: ST_TO_ADDR
// vc_chassis := 25 ;
109672: LD_ADDR_OWVAR 37
109676: PUSH
109677: LD_INT 25
109679: ST_TO_ADDR
// vc_engine := engine_siberite ;
109680: LD_ADDR_OWVAR 39
109684: PUSH
109685: LD_INT 3
109687: ST_TO_ADDR
// vc_control := control_computer ;
109688: LD_ADDR_OWVAR 38
109692: PUSH
109693: LD_INT 3
109695: ST_TO_ADDR
// vc_weapon := 59 ;
109696: LD_ADDR_OWVAR 40
109700: PUSH
109701: LD_INT 59
109703: ST_TO_ADDR
// result := CreateVehicle ;
109704: LD_ADDR_VAR 0 5
109708: PUSH
109709: CALL_OW 45
109713: ST_TO_ADDR
// SetDir ( result , d ) ;
109714: LD_VAR 0 5
109718: PPUSH
109719: LD_VAR 0 4
109723: PPUSH
109724: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
109728: LD_VAR 0 5
109732: PPUSH
109733: LD_VAR 0 2
109737: PPUSH
109738: LD_VAR 0 3
109742: PPUSH
109743: LD_INT 0
109745: PPUSH
109746: CALL_OW 48
// end ;
109750: LD_VAR 0 5
109754: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
109755: LD_INT 0
109757: PPUSH
109758: PPUSH
109759: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
109760: LD_ADDR_VAR 0 2
109764: PUSH
109765: LD_INT 0
109767: PUSH
109768: LD_INT 0
109770: PUSH
109771: LD_INT 0
109773: PUSH
109774: LD_INT 0
109776: PUSH
109777: EMPTY
109778: LIST
109779: LIST
109780: LIST
109781: LIST
109782: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
109783: LD_VAR 0 1
109787: NOT
109788: PUSH
109789: LD_VAR 0 1
109793: PPUSH
109794: CALL_OW 264
109798: PUSH
109799: LD_INT 12
109801: PUSH
109802: LD_INT 51
109804: PUSH
109805: LD_INT 32
109807: PUSH
109808: LD_INT 89
109810: PUSH
109811: EMPTY
109812: LIST
109813: LIST
109814: LIST
109815: LIST
109816: IN
109817: NOT
109818: OR
109819: IFFALSE 109823
// exit ;
109821: GO 109921
// for i := 1 to 3 do
109823: LD_ADDR_VAR 0 3
109827: PUSH
109828: DOUBLE
109829: LD_INT 1
109831: DEC
109832: ST_TO_ADDR
109833: LD_INT 3
109835: PUSH
109836: FOR_TO
109837: IFFALSE 109919
// begin tmp := GetCargo ( cargo , i ) ;
109839: LD_ADDR_VAR 0 4
109843: PUSH
109844: LD_VAR 0 1
109848: PPUSH
109849: LD_VAR 0 3
109853: PPUSH
109854: CALL_OW 289
109858: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
109859: LD_ADDR_VAR 0 2
109863: PUSH
109864: LD_VAR 0 2
109868: PPUSH
109869: LD_VAR 0 3
109873: PPUSH
109874: LD_VAR 0 4
109878: PPUSH
109879: CALL_OW 1
109883: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
109884: LD_ADDR_VAR 0 2
109888: PUSH
109889: LD_VAR 0 2
109893: PPUSH
109894: LD_INT 4
109896: PPUSH
109897: LD_VAR 0 2
109901: PUSH
109902: LD_INT 4
109904: ARRAY
109905: PUSH
109906: LD_VAR 0 4
109910: PLUS
109911: PPUSH
109912: CALL_OW 1
109916: ST_TO_ADDR
// end ;
109917: GO 109836
109919: POP
109920: POP
// end ;
109921: LD_VAR 0 2
109925: RET
// export function Length ( array ) ; begin
109926: LD_INT 0
109928: PPUSH
// result := array + 0 ;
109929: LD_ADDR_VAR 0 2
109933: PUSH
109934: LD_VAR 0 1
109938: PUSH
109939: LD_INT 0
109941: PLUS
109942: ST_TO_ADDR
// end ;
109943: LD_VAR 0 2
109947: RET
// export function PrepareArray ( array ) ; begin
109948: LD_INT 0
109950: PPUSH
// result := array diff 0 ;
109951: LD_ADDR_VAR 0 2
109955: PUSH
109956: LD_VAR 0 1
109960: PUSH
109961: LD_INT 0
109963: DIFF
109964: ST_TO_ADDR
// if not result [ 1 ] then
109965: LD_VAR 0 2
109969: PUSH
109970: LD_INT 1
109972: ARRAY
109973: NOT
109974: IFFALSE 109994
// result := Delete ( result , 1 ) ;
109976: LD_ADDR_VAR 0 2
109980: PUSH
109981: LD_VAR 0 2
109985: PPUSH
109986: LD_INT 1
109988: PPUSH
109989: CALL_OW 3
109993: ST_TO_ADDR
// end ;
109994: LD_VAR 0 2
109998: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
109999: LD_INT 0
110001: PPUSH
110002: PPUSH
110003: PPUSH
110004: PPUSH
// sibRocketRange := 25 ;
110005: LD_ADDR_VAR 0 6
110009: PUSH
110010: LD_INT 25
110012: ST_TO_ADDR
// result := false ;
110013: LD_ADDR_VAR 0 4
110017: PUSH
110018: LD_INT 0
110020: ST_TO_ADDR
// for i := 0 to 5 do
110021: LD_ADDR_VAR 0 5
110025: PUSH
110026: DOUBLE
110027: LD_INT 0
110029: DEC
110030: ST_TO_ADDR
110031: LD_INT 5
110033: PUSH
110034: FOR_TO
110035: IFFALSE 110102
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
110037: LD_VAR 0 1
110041: PPUSH
110042: LD_VAR 0 5
110046: PPUSH
110047: LD_VAR 0 6
110051: PPUSH
110052: CALL_OW 272
110056: PPUSH
110057: LD_VAR 0 2
110061: PPUSH
110062: LD_VAR 0 5
110066: PPUSH
110067: LD_VAR 0 6
110071: PPUSH
110072: CALL_OW 273
110076: PPUSH
110077: LD_VAR 0 3
110081: PPUSH
110082: CALL_OW 309
110086: IFFALSE 110100
// begin result := true ;
110088: LD_ADDR_VAR 0 4
110092: PUSH
110093: LD_INT 1
110095: ST_TO_ADDR
// exit ;
110096: POP
110097: POP
110098: GO 110104
// end ;
110100: GO 110034
110102: POP
110103: POP
// end ;
110104: LD_VAR 0 4
110108: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
110109: LD_INT 0
110111: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
110112: LD_VAR 0 1
110116: PPUSH
110117: LD_VAR 0 2
110121: PPUSH
110122: LD_INT 0
110124: PPUSH
110125: LD_INT 0
110127: PPUSH
110128: LD_INT 1
110130: PPUSH
110131: LD_INT 0
110133: PPUSH
110134: CALL_OW 587
// end ;
110138: LD_VAR 0 3
110142: RET
// export function CenterOnNow ( unit ) ; begin
110143: LD_INT 0
110145: PPUSH
// result := IsInUnit ( unit ) ;
110146: LD_ADDR_VAR 0 2
110150: PUSH
110151: LD_VAR 0 1
110155: PPUSH
110156: CALL_OW 310
110160: ST_TO_ADDR
// if not result then
110161: LD_VAR 0 2
110165: NOT
110166: IFFALSE 110178
// result := unit ;
110168: LD_ADDR_VAR 0 2
110172: PUSH
110173: LD_VAR 0 1
110177: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
110178: LD_VAR 0 1
110182: PPUSH
110183: CALL_OW 87
// end ;
110187: LD_VAR 0 2
110191: RET
// export function ComMoveHex ( unit , hex ) ; begin
110192: LD_INT 0
110194: PPUSH
// if not hex then
110195: LD_VAR 0 2
110199: NOT
110200: IFFALSE 110204
// exit ;
110202: GO 110257
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
110204: LD_VAR 0 2
110208: PUSH
110209: LD_INT 1
110211: ARRAY
110212: PPUSH
110213: LD_VAR 0 2
110217: PUSH
110218: LD_INT 2
110220: ARRAY
110221: PPUSH
110222: CALL_OW 428
110226: IFFALSE 110230
// exit ;
110228: GO 110257
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
110230: LD_VAR 0 1
110234: PPUSH
110235: LD_VAR 0 2
110239: PUSH
110240: LD_INT 1
110242: ARRAY
110243: PPUSH
110244: LD_VAR 0 2
110248: PUSH
110249: LD_INT 2
110251: ARRAY
110252: PPUSH
110253: CALL_OW 111
// end ; end_of_file end_of_file
110257: LD_VAR 0 3
110261: RET
// export globalGameSaveCounter ; every 0 0$1 do
110262: GO 110264
110264: DISABLE
// begin enable ;
110265: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
110266: LD_STRING updateTimer(
110268: PUSH
110269: LD_OWVAR 1
110273: STR
110274: PUSH
110275: LD_STRING );
110277: STR
110278: PPUSH
110279: CALL_OW 559
// end ;
110283: END
// every 0 0$1 do
110284: GO 110286
110286: DISABLE
// begin globalGameSaveCounter := 0 ;
110287: LD_ADDR_EXP 145
110291: PUSH
110292: LD_INT 0
110294: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
110295: LD_STRING setGameSaveCounter(0)
110297: PPUSH
110298: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
110302: LD_STRING initStreamRollete();
110304: PPUSH
110305: CALL_OW 559
// InitStreamMode ;
110309: CALL 111635 0 0
// DefineStreamItems ( false ) ;
110313: LD_INT 0
110315: PPUSH
110316: CALL 112099 0 1
// end ;
110320: END
// export function SOS_MapStart ( ) ; begin
110321: LD_INT 0
110323: PPUSH
// if streamModeActive then
110324: LD_EXP 146
110328: IFFALSE 110337
// DefineStreamItems ( true ) ;
110330: LD_INT 1
110332: PPUSH
110333: CALL 112099 0 1
// UpdateLuaVariables ( ) ;
110337: CALL 110354 0 0
// UpdateFactoryWaypoints ( ) ;
110341: CALL 124968 0 0
// UpdateWarehouseGatheringPoints ( ) ;
110345: CALL 125225 0 0
// end ;
110349: LD_VAR 0 1
110353: RET
// function UpdateLuaVariables ( ) ; begin
110354: LD_INT 0
110356: PPUSH
// if globalGameSaveCounter then
110357: LD_EXP 145
110361: IFFALSE 110395
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
110363: LD_ADDR_EXP 145
110367: PUSH
110368: LD_EXP 145
110372: PPUSH
110373: CALL 107551 0 1
110377: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
110378: LD_STRING setGameSaveCounter(
110380: PUSH
110381: LD_EXP 145
110385: STR
110386: PUSH
110387: LD_STRING )
110389: STR
110390: PPUSH
110391: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
110395: LD_STRING setGameDifficulty(
110397: PUSH
110398: LD_OWVAR 67
110402: STR
110403: PUSH
110404: LD_STRING )
110406: STR
110407: PPUSH
110408: CALL_OW 559
// end ;
110412: LD_VAR 0 1
110416: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
110417: LD_INT 0
110419: PPUSH
// if p2 = stream_mode then
110420: LD_VAR 0 2
110424: PUSH
110425: LD_INT 100
110427: EQUAL
110428: IFFALSE 111431
// begin if not StreamModeActive then
110430: LD_EXP 146
110434: NOT
110435: IFFALSE 110445
// StreamModeActive := true ;
110437: LD_ADDR_EXP 146
110441: PUSH
110442: LD_INT 1
110444: ST_TO_ADDR
// if p3 = 0 then
110445: LD_VAR 0 3
110449: PUSH
110450: LD_INT 0
110452: EQUAL
110453: IFFALSE 110459
// InitStreamMode ;
110455: CALL 111635 0 0
// if p3 = 1 then
110459: LD_VAR 0 3
110463: PUSH
110464: LD_INT 1
110466: EQUAL
110467: IFFALSE 110477
// sRocket := true ;
110469: LD_ADDR_EXP 151
110473: PUSH
110474: LD_INT 1
110476: ST_TO_ADDR
// if p3 = 2 then
110477: LD_VAR 0 3
110481: PUSH
110482: LD_INT 2
110484: EQUAL
110485: IFFALSE 110495
// sSpeed := true ;
110487: LD_ADDR_EXP 150
110491: PUSH
110492: LD_INT 1
110494: ST_TO_ADDR
// if p3 = 3 then
110495: LD_VAR 0 3
110499: PUSH
110500: LD_INT 3
110502: EQUAL
110503: IFFALSE 110513
// sEngine := true ;
110505: LD_ADDR_EXP 152
110509: PUSH
110510: LD_INT 1
110512: ST_TO_ADDR
// if p3 = 4 then
110513: LD_VAR 0 3
110517: PUSH
110518: LD_INT 4
110520: EQUAL
110521: IFFALSE 110531
// sSpec := true ;
110523: LD_ADDR_EXP 149
110527: PUSH
110528: LD_INT 1
110530: ST_TO_ADDR
// if p3 = 5 then
110531: LD_VAR 0 3
110535: PUSH
110536: LD_INT 5
110538: EQUAL
110539: IFFALSE 110549
// sLevel := true ;
110541: LD_ADDR_EXP 153
110545: PUSH
110546: LD_INT 1
110548: ST_TO_ADDR
// if p3 = 6 then
110549: LD_VAR 0 3
110553: PUSH
110554: LD_INT 6
110556: EQUAL
110557: IFFALSE 110567
// sArmoury := true ;
110559: LD_ADDR_EXP 154
110563: PUSH
110564: LD_INT 1
110566: ST_TO_ADDR
// if p3 = 7 then
110567: LD_VAR 0 3
110571: PUSH
110572: LD_INT 7
110574: EQUAL
110575: IFFALSE 110585
// sRadar := true ;
110577: LD_ADDR_EXP 155
110581: PUSH
110582: LD_INT 1
110584: ST_TO_ADDR
// if p3 = 8 then
110585: LD_VAR 0 3
110589: PUSH
110590: LD_INT 8
110592: EQUAL
110593: IFFALSE 110603
// sBunker := true ;
110595: LD_ADDR_EXP 156
110599: PUSH
110600: LD_INT 1
110602: ST_TO_ADDR
// if p3 = 9 then
110603: LD_VAR 0 3
110607: PUSH
110608: LD_INT 9
110610: EQUAL
110611: IFFALSE 110621
// sHack := true ;
110613: LD_ADDR_EXP 157
110617: PUSH
110618: LD_INT 1
110620: ST_TO_ADDR
// if p3 = 10 then
110621: LD_VAR 0 3
110625: PUSH
110626: LD_INT 10
110628: EQUAL
110629: IFFALSE 110639
// sFire := true ;
110631: LD_ADDR_EXP 158
110635: PUSH
110636: LD_INT 1
110638: ST_TO_ADDR
// if p3 = 11 then
110639: LD_VAR 0 3
110643: PUSH
110644: LD_INT 11
110646: EQUAL
110647: IFFALSE 110657
// sRefresh := true ;
110649: LD_ADDR_EXP 159
110653: PUSH
110654: LD_INT 1
110656: ST_TO_ADDR
// if p3 = 12 then
110657: LD_VAR 0 3
110661: PUSH
110662: LD_INT 12
110664: EQUAL
110665: IFFALSE 110675
// sExp := true ;
110667: LD_ADDR_EXP 160
110671: PUSH
110672: LD_INT 1
110674: ST_TO_ADDR
// if p3 = 13 then
110675: LD_VAR 0 3
110679: PUSH
110680: LD_INT 13
110682: EQUAL
110683: IFFALSE 110693
// sDepot := true ;
110685: LD_ADDR_EXP 161
110689: PUSH
110690: LD_INT 1
110692: ST_TO_ADDR
// if p3 = 14 then
110693: LD_VAR 0 3
110697: PUSH
110698: LD_INT 14
110700: EQUAL
110701: IFFALSE 110711
// sFlag := true ;
110703: LD_ADDR_EXP 162
110707: PUSH
110708: LD_INT 1
110710: ST_TO_ADDR
// if p3 = 15 then
110711: LD_VAR 0 3
110715: PUSH
110716: LD_INT 15
110718: EQUAL
110719: IFFALSE 110729
// sKamikadze := true ;
110721: LD_ADDR_EXP 170
110725: PUSH
110726: LD_INT 1
110728: ST_TO_ADDR
// if p3 = 16 then
110729: LD_VAR 0 3
110733: PUSH
110734: LD_INT 16
110736: EQUAL
110737: IFFALSE 110747
// sTroll := true ;
110739: LD_ADDR_EXP 171
110743: PUSH
110744: LD_INT 1
110746: ST_TO_ADDR
// if p3 = 17 then
110747: LD_VAR 0 3
110751: PUSH
110752: LD_INT 17
110754: EQUAL
110755: IFFALSE 110765
// sSlow := true ;
110757: LD_ADDR_EXP 172
110761: PUSH
110762: LD_INT 1
110764: ST_TO_ADDR
// if p3 = 18 then
110765: LD_VAR 0 3
110769: PUSH
110770: LD_INT 18
110772: EQUAL
110773: IFFALSE 110783
// sLack := true ;
110775: LD_ADDR_EXP 173
110779: PUSH
110780: LD_INT 1
110782: ST_TO_ADDR
// if p3 = 19 then
110783: LD_VAR 0 3
110787: PUSH
110788: LD_INT 19
110790: EQUAL
110791: IFFALSE 110801
// sTank := true ;
110793: LD_ADDR_EXP 175
110797: PUSH
110798: LD_INT 1
110800: ST_TO_ADDR
// if p3 = 20 then
110801: LD_VAR 0 3
110805: PUSH
110806: LD_INT 20
110808: EQUAL
110809: IFFALSE 110819
// sRemote := true ;
110811: LD_ADDR_EXP 176
110815: PUSH
110816: LD_INT 1
110818: ST_TO_ADDR
// if p3 = 21 then
110819: LD_VAR 0 3
110823: PUSH
110824: LD_INT 21
110826: EQUAL
110827: IFFALSE 110837
// sPowell := true ;
110829: LD_ADDR_EXP 177
110833: PUSH
110834: LD_INT 1
110836: ST_TO_ADDR
// if p3 = 22 then
110837: LD_VAR 0 3
110841: PUSH
110842: LD_INT 22
110844: EQUAL
110845: IFFALSE 110855
// sTeleport := true ;
110847: LD_ADDR_EXP 180
110851: PUSH
110852: LD_INT 1
110854: ST_TO_ADDR
// if p3 = 23 then
110855: LD_VAR 0 3
110859: PUSH
110860: LD_INT 23
110862: EQUAL
110863: IFFALSE 110873
// sOilTower := true ;
110865: LD_ADDR_EXP 182
110869: PUSH
110870: LD_INT 1
110872: ST_TO_ADDR
// if p3 = 24 then
110873: LD_VAR 0 3
110877: PUSH
110878: LD_INT 24
110880: EQUAL
110881: IFFALSE 110891
// sShovel := true ;
110883: LD_ADDR_EXP 183
110887: PUSH
110888: LD_INT 1
110890: ST_TO_ADDR
// if p3 = 25 then
110891: LD_VAR 0 3
110895: PUSH
110896: LD_INT 25
110898: EQUAL
110899: IFFALSE 110909
// sSheik := true ;
110901: LD_ADDR_EXP 184
110905: PUSH
110906: LD_INT 1
110908: ST_TO_ADDR
// if p3 = 26 then
110909: LD_VAR 0 3
110913: PUSH
110914: LD_INT 26
110916: EQUAL
110917: IFFALSE 110927
// sEarthquake := true ;
110919: LD_ADDR_EXP 186
110923: PUSH
110924: LD_INT 1
110926: ST_TO_ADDR
// if p3 = 27 then
110927: LD_VAR 0 3
110931: PUSH
110932: LD_INT 27
110934: EQUAL
110935: IFFALSE 110945
// sAI := true ;
110937: LD_ADDR_EXP 187
110941: PUSH
110942: LD_INT 1
110944: ST_TO_ADDR
// if p3 = 28 then
110945: LD_VAR 0 3
110949: PUSH
110950: LD_INT 28
110952: EQUAL
110953: IFFALSE 110963
// sCargo := true ;
110955: LD_ADDR_EXP 190
110959: PUSH
110960: LD_INT 1
110962: ST_TO_ADDR
// if p3 = 29 then
110963: LD_VAR 0 3
110967: PUSH
110968: LD_INT 29
110970: EQUAL
110971: IFFALSE 110981
// sDLaser := true ;
110973: LD_ADDR_EXP 191
110977: PUSH
110978: LD_INT 1
110980: ST_TO_ADDR
// if p3 = 30 then
110981: LD_VAR 0 3
110985: PUSH
110986: LD_INT 30
110988: EQUAL
110989: IFFALSE 110999
// sExchange := true ;
110991: LD_ADDR_EXP 192
110995: PUSH
110996: LD_INT 1
110998: ST_TO_ADDR
// if p3 = 31 then
110999: LD_VAR 0 3
111003: PUSH
111004: LD_INT 31
111006: EQUAL
111007: IFFALSE 111017
// sFac := true ;
111009: LD_ADDR_EXP 193
111013: PUSH
111014: LD_INT 1
111016: ST_TO_ADDR
// if p3 = 32 then
111017: LD_VAR 0 3
111021: PUSH
111022: LD_INT 32
111024: EQUAL
111025: IFFALSE 111035
// sPower := true ;
111027: LD_ADDR_EXP 194
111031: PUSH
111032: LD_INT 1
111034: ST_TO_ADDR
// if p3 = 33 then
111035: LD_VAR 0 3
111039: PUSH
111040: LD_INT 33
111042: EQUAL
111043: IFFALSE 111053
// sRandom := true ;
111045: LD_ADDR_EXP 195
111049: PUSH
111050: LD_INT 1
111052: ST_TO_ADDR
// if p3 = 34 then
111053: LD_VAR 0 3
111057: PUSH
111058: LD_INT 34
111060: EQUAL
111061: IFFALSE 111071
// sShield := true ;
111063: LD_ADDR_EXP 196
111067: PUSH
111068: LD_INT 1
111070: ST_TO_ADDR
// if p3 = 35 then
111071: LD_VAR 0 3
111075: PUSH
111076: LD_INT 35
111078: EQUAL
111079: IFFALSE 111089
// sTime := true ;
111081: LD_ADDR_EXP 197
111085: PUSH
111086: LD_INT 1
111088: ST_TO_ADDR
// if p3 = 36 then
111089: LD_VAR 0 3
111093: PUSH
111094: LD_INT 36
111096: EQUAL
111097: IFFALSE 111107
// sTools := true ;
111099: LD_ADDR_EXP 198
111103: PUSH
111104: LD_INT 1
111106: ST_TO_ADDR
// if p3 = 101 then
111107: LD_VAR 0 3
111111: PUSH
111112: LD_INT 101
111114: EQUAL
111115: IFFALSE 111125
// sSold := true ;
111117: LD_ADDR_EXP 163
111121: PUSH
111122: LD_INT 1
111124: ST_TO_ADDR
// if p3 = 102 then
111125: LD_VAR 0 3
111129: PUSH
111130: LD_INT 102
111132: EQUAL
111133: IFFALSE 111143
// sDiff := true ;
111135: LD_ADDR_EXP 164
111139: PUSH
111140: LD_INT 1
111142: ST_TO_ADDR
// if p3 = 103 then
111143: LD_VAR 0 3
111147: PUSH
111148: LD_INT 103
111150: EQUAL
111151: IFFALSE 111161
// sFog := true ;
111153: LD_ADDR_EXP 167
111157: PUSH
111158: LD_INT 1
111160: ST_TO_ADDR
// if p3 = 104 then
111161: LD_VAR 0 3
111165: PUSH
111166: LD_INT 104
111168: EQUAL
111169: IFFALSE 111179
// sReset := true ;
111171: LD_ADDR_EXP 168
111175: PUSH
111176: LD_INT 1
111178: ST_TO_ADDR
// if p3 = 105 then
111179: LD_VAR 0 3
111183: PUSH
111184: LD_INT 105
111186: EQUAL
111187: IFFALSE 111197
// sSun := true ;
111189: LD_ADDR_EXP 169
111193: PUSH
111194: LD_INT 1
111196: ST_TO_ADDR
// if p3 = 106 then
111197: LD_VAR 0 3
111201: PUSH
111202: LD_INT 106
111204: EQUAL
111205: IFFALSE 111215
// sTiger := true ;
111207: LD_ADDR_EXP 165
111211: PUSH
111212: LD_INT 1
111214: ST_TO_ADDR
// if p3 = 107 then
111215: LD_VAR 0 3
111219: PUSH
111220: LD_INT 107
111222: EQUAL
111223: IFFALSE 111233
// sBomb := true ;
111225: LD_ADDR_EXP 166
111229: PUSH
111230: LD_INT 1
111232: ST_TO_ADDR
// if p3 = 108 then
111233: LD_VAR 0 3
111237: PUSH
111238: LD_INT 108
111240: EQUAL
111241: IFFALSE 111251
// sWound := true ;
111243: LD_ADDR_EXP 174
111247: PUSH
111248: LD_INT 1
111250: ST_TO_ADDR
// if p3 = 109 then
111251: LD_VAR 0 3
111255: PUSH
111256: LD_INT 109
111258: EQUAL
111259: IFFALSE 111269
// sBetray := true ;
111261: LD_ADDR_EXP 178
111265: PUSH
111266: LD_INT 1
111268: ST_TO_ADDR
// if p3 = 110 then
111269: LD_VAR 0 3
111273: PUSH
111274: LD_INT 110
111276: EQUAL
111277: IFFALSE 111287
// sContamin := true ;
111279: LD_ADDR_EXP 179
111283: PUSH
111284: LD_INT 1
111286: ST_TO_ADDR
// if p3 = 111 then
111287: LD_VAR 0 3
111291: PUSH
111292: LD_INT 111
111294: EQUAL
111295: IFFALSE 111305
// sOil := true ;
111297: LD_ADDR_EXP 181
111301: PUSH
111302: LD_INT 1
111304: ST_TO_ADDR
// if p3 = 112 then
111305: LD_VAR 0 3
111309: PUSH
111310: LD_INT 112
111312: EQUAL
111313: IFFALSE 111323
// sStu := true ;
111315: LD_ADDR_EXP 185
111319: PUSH
111320: LD_INT 1
111322: ST_TO_ADDR
// if p3 = 113 then
111323: LD_VAR 0 3
111327: PUSH
111328: LD_INT 113
111330: EQUAL
111331: IFFALSE 111341
// sBazooka := true ;
111333: LD_ADDR_EXP 188
111337: PUSH
111338: LD_INT 1
111340: ST_TO_ADDR
// if p3 = 114 then
111341: LD_VAR 0 3
111345: PUSH
111346: LD_INT 114
111348: EQUAL
111349: IFFALSE 111359
// sMortar := true ;
111351: LD_ADDR_EXP 189
111355: PUSH
111356: LD_INT 1
111358: ST_TO_ADDR
// if p3 = 115 then
111359: LD_VAR 0 3
111363: PUSH
111364: LD_INT 115
111366: EQUAL
111367: IFFALSE 111377
// sRanger := true ;
111369: LD_ADDR_EXP 199
111373: PUSH
111374: LD_INT 1
111376: ST_TO_ADDR
// if p3 = 116 then
111377: LD_VAR 0 3
111381: PUSH
111382: LD_INT 116
111384: EQUAL
111385: IFFALSE 111395
// sComputer := true ;
111387: LD_ADDR_EXP 200
111391: PUSH
111392: LD_INT 1
111394: ST_TO_ADDR
// if p3 = 117 then
111395: LD_VAR 0 3
111399: PUSH
111400: LD_INT 117
111402: EQUAL
111403: IFFALSE 111413
// s30 := true ;
111405: LD_ADDR_EXP 201
111409: PUSH
111410: LD_INT 1
111412: ST_TO_ADDR
// if p3 = 118 then
111413: LD_VAR 0 3
111417: PUSH
111418: LD_INT 118
111420: EQUAL
111421: IFFALSE 111431
// s60 := true ;
111423: LD_ADDR_EXP 202
111427: PUSH
111428: LD_INT 1
111430: ST_TO_ADDR
// end ; if p2 = hack_mode then
111431: LD_VAR 0 2
111435: PUSH
111436: LD_INT 101
111438: EQUAL
111439: IFFALSE 111567
// begin case p3 of 1 :
111441: LD_VAR 0 3
111445: PUSH
111446: LD_INT 1
111448: DOUBLE
111449: EQUAL
111450: IFTRUE 111454
111452: GO 111461
111454: POP
// hHackUnlimitedResources ; 2 :
111455: CALL 123714 0 0
111459: GO 111567
111461: LD_INT 2
111463: DOUBLE
111464: EQUAL
111465: IFTRUE 111469
111467: GO 111476
111469: POP
// hHackSetLevel10 ; 3 :
111470: CALL 123847 0 0
111474: GO 111567
111476: LD_INT 3
111478: DOUBLE
111479: EQUAL
111480: IFTRUE 111484
111482: GO 111491
111484: POP
// hHackSetLevel10YourUnits ; 4 :
111485: CALL 123932 0 0
111489: GO 111567
111491: LD_INT 4
111493: DOUBLE
111494: EQUAL
111495: IFTRUE 111499
111497: GO 111506
111499: POP
// hHackInvincible ; 5 :
111500: CALL 124380 0 0
111504: GO 111567
111506: LD_INT 5
111508: DOUBLE
111509: EQUAL
111510: IFTRUE 111514
111512: GO 111521
111514: POP
// hHackInvisible ; 6 :
111515: CALL 124491 0 0
111519: GO 111567
111521: LD_INT 6
111523: DOUBLE
111524: EQUAL
111525: IFTRUE 111529
111527: GO 111536
111529: POP
// hHackChangeYourSide ; 7 :
111530: CALL 124548 0 0
111534: GO 111567
111536: LD_INT 7
111538: DOUBLE
111539: EQUAL
111540: IFTRUE 111544
111542: GO 111551
111544: POP
// hHackChangeUnitSide ; 8 :
111545: CALL 124590 0 0
111549: GO 111567
111551: LD_INT 8
111553: DOUBLE
111554: EQUAL
111555: IFTRUE 111559
111557: GO 111566
111559: POP
// hHackFog ; end ;
111560: CALL 124691 0 0
111564: GO 111567
111566: POP
// end ; if p2 = game_save_mode then
111567: LD_VAR 0 2
111571: PUSH
111572: LD_INT 102
111574: EQUAL
111575: IFFALSE 111630
// begin if p3 = 1 then
111577: LD_VAR 0 3
111581: PUSH
111582: LD_INT 1
111584: EQUAL
111585: IFFALSE 111597
// globalGameSaveCounter := p4 ;
111587: LD_ADDR_EXP 145
111591: PUSH
111592: LD_VAR 0 4
111596: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
111597: LD_VAR 0 3
111601: PUSH
111602: LD_INT 2
111604: EQUAL
111605: PUSH
111606: LD_EXP 145
111610: AND
111611: IFFALSE 111630
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
111613: LD_STRING setGameSaveCounter(
111615: PUSH
111616: LD_EXP 145
111620: STR
111621: PUSH
111622: LD_STRING )
111624: STR
111625: PPUSH
111626: CALL_OW 559
// end ; end ;
111630: LD_VAR 0 7
111634: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
111635: LD_INT 0
111637: PPUSH
// streamModeActive := false ;
111638: LD_ADDR_EXP 146
111642: PUSH
111643: LD_INT 0
111645: ST_TO_ADDR
// normalCounter := 36 ;
111646: LD_ADDR_EXP 147
111650: PUSH
111651: LD_INT 36
111653: ST_TO_ADDR
// hardcoreCounter := 18 ;
111654: LD_ADDR_EXP 148
111658: PUSH
111659: LD_INT 18
111661: ST_TO_ADDR
// sRocket := false ;
111662: LD_ADDR_EXP 151
111666: PUSH
111667: LD_INT 0
111669: ST_TO_ADDR
// sSpeed := false ;
111670: LD_ADDR_EXP 150
111674: PUSH
111675: LD_INT 0
111677: ST_TO_ADDR
// sEngine := false ;
111678: LD_ADDR_EXP 152
111682: PUSH
111683: LD_INT 0
111685: ST_TO_ADDR
// sSpec := false ;
111686: LD_ADDR_EXP 149
111690: PUSH
111691: LD_INT 0
111693: ST_TO_ADDR
// sLevel := false ;
111694: LD_ADDR_EXP 153
111698: PUSH
111699: LD_INT 0
111701: ST_TO_ADDR
// sArmoury := false ;
111702: LD_ADDR_EXP 154
111706: PUSH
111707: LD_INT 0
111709: ST_TO_ADDR
// sRadar := false ;
111710: LD_ADDR_EXP 155
111714: PUSH
111715: LD_INT 0
111717: ST_TO_ADDR
// sBunker := false ;
111718: LD_ADDR_EXP 156
111722: PUSH
111723: LD_INT 0
111725: ST_TO_ADDR
// sHack := false ;
111726: LD_ADDR_EXP 157
111730: PUSH
111731: LD_INT 0
111733: ST_TO_ADDR
// sFire := false ;
111734: LD_ADDR_EXP 158
111738: PUSH
111739: LD_INT 0
111741: ST_TO_ADDR
// sRefresh := false ;
111742: LD_ADDR_EXP 159
111746: PUSH
111747: LD_INT 0
111749: ST_TO_ADDR
// sExp := false ;
111750: LD_ADDR_EXP 160
111754: PUSH
111755: LD_INT 0
111757: ST_TO_ADDR
// sDepot := false ;
111758: LD_ADDR_EXP 161
111762: PUSH
111763: LD_INT 0
111765: ST_TO_ADDR
// sFlag := false ;
111766: LD_ADDR_EXP 162
111770: PUSH
111771: LD_INT 0
111773: ST_TO_ADDR
// sKamikadze := false ;
111774: LD_ADDR_EXP 170
111778: PUSH
111779: LD_INT 0
111781: ST_TO_ADDR
// sTroll := false ;
111782: LD_ADDR_EXP 171
111786: PUSH
111787: LD_INT 0
111789: ST_TO_ADDR
// sSlow := false ;
111790: LD_ADDR_EXP 172
111794: PUSH
111795: LD_INT 0
111797: ST_TO_ADDR
// sLack := false ;
111798: LD_ADDR_EXP 173
111802: PUSH
111803: LD_INT 0
111805: ST_TO_ADDR
// sTank := false ;
111806: LD_ADDR_EXP 175
111810: PUSH
111811: LD_INT 0
111813: ST_TO_ADDR
// sRemote := false ;
111814: LD_ADDR_EXP 176
111818: PUSH
111819: LD_INT 0
111821: ST_TO_ADDR
// sPowell := false ;
111822: LD_ADDR_EXP 177
111826: PUSH
111827: LD_INT 0
111829: ST_TO_ADDR
// sTeleport := false ;
111830: LD_ADDR_EXP 180
111834: PUSH
111835: LD_INT 0
111837: ST_TO_ADDR
// sOilTower := false ;
111838: LD_ADDR_EXP 182
111842: PUSH
111843: LD_INT 0
111845: ST_TO_ADDR
// sShovel := false ;
111846: LD_ADDR_EXP 183
111850: PUSH
111851: LD_INT 0
111853: ST_TO_ADDR
// sSheik := false ;
111854: LD_ADDR_EXP 184
111858: PUSH
111859: LD_INT 0
111861: ST_TO_ADDR
// sEarthquake := false ;
111862: LD_ADDR_EXP 186
111866: PUSH
111867: LD_INT 0
111869: ST_TO_ADDR
// sAI := false ;
111870: LD_ADDR_EXP 187
111874: PUSH
111875: LD_INT 0
111877: ST_TO_ADDR
// sCargo := false ;
111878: LD_ADDR_EXP 190
111882: PUSH
111883: LD_INT 0
111885: ST_TO_ADDR
// sDLaser := false ;
111886: LD_ADDR_EXP 191
111890: PUSH
111891: LD_INT 0
111893: ST_TO_ADDR
// sExchange := false ;
111894: LD_ADDR_EXP 192
111898: PUSH
111899: LD_INT 0
111901: ST_TO_ADDR
// sFac := false ;
111902: LD_ADDR_EXP 193
111906: PUSH
111907: LD_INT 0
111909: ST_TO_ADDR
// sPower := false ;
111910: LD_ADDR_EXP 194
111914: PUSH
111915: LD_INT 0
111917: ST_TO_ADDR
// sRandom := false ;
111918: LD_ADDR_EXP 195
111922: PUSH
111923: LD_INT 0
111925: ST_TO_ADDR
// sShield := false ;
111926: LD_ADDR_EXP 196
111930: PUSH
111931: LD_INT 0
111933: ST_TO_ADDR
// sTime := false ;
111934: LD_ADDR_EXP 197
111938: PUSH
111939: LD_INT 0
111941: ST_TO_ADDR
// sTools := false ;
111942: LD_ADDR_EXP 198
111946: PUSH
111947: LD_INT 0
111949: ST_TO_ADDR
// sSold := false ;
111950: LD_ADDR_EXP 163
111954: PUSH
111955: LD_INT 0
111957: ST_TO_ADDR
// sDiff := false ;
111958: LD_ADDR_EXP 164
111962: PUSH
111963: LD_INT 0
111965: ST_TO_ADDR
// sFog := false ;
111966: LD_ADDR_EXP 167
111970: PUSH
111971: LD_INT 0
111973: ST_TO_ADDR
// sReset := false ;
111974: LD_ADDR_EXP 168
111978: PUSH
111979: LD_INT 0
111981: ST_TO_ADDR
// sSun := false ;
111982: LD_ADDR_EXP 169
111986: PUSH
111987: LD_INT 0
111989: ST_TO_ADDR
// sTiger := false ;
111990: LD_ADDR_EXP 165
111994: PUSH
111995: LD_INT 0
111997: ST_TO_ADDR
// sBomb := false ;
111998: LD_ADDR_EXP 166
112002: PUSH
112003: LD_INT 0
112005: ST_TO_ADDR
// sWound := false ;
112006: LD_ADDR_EXP 174
112010: PUSH
112011: LD_INT 0
112013: ST_TO_ADDR
// sBetray := false ;
112014: LD_ADDR_EXP 178
112018: PUSH
112019: LD_INT 0
112021: ST_TO_ADDR
// sContamin := false ;
112022: LD_ADDR_EXP 179
112026: PUSH
112027: LD_INT 0
112029: ST_TO_ADDR
// sOil := false ;
112030: LD_ADDR_EXP 181
112034: PUSH
112035: LD_INT 0
112037: ST_TO_ADDR
// sStu := false ;
112038: LD_ADDR_EXP 185
112042: PUSH
112043: LD_INT 0
112045: ST_TO_ADDR
// sBazooka := false ;
112046: LD_ADDR_EXP 188
112050: PUSH
112051: LD_INT 0
112053: ST_TO_ADDR
// sMortar := false ;
112054: LD_ADDR_EXP 189
112058: PUSH
112059: LD_INT 0
112061: ST_TO_ADDR
// sRanger := false ;
112062: LD_ADDR_EXP 199
112066: PUSH
112067: LD_INT 0
112069: ST_TO_ADDR
// sComputer := false ;
112070: LD_ADDR_EXP 200
112074: PUSH
112075: LD_INT 0
112077: ST_TO_ADDR
// s30 := false ;
112078: LD_ADDR_EXP 201
112082: PUSH
112083: LD_INT 0
112085: ST_TO_ADDR
// s60 := false ;
112086: LD_ADDR_EXP 202
112090: PUSH
112091: LD_INT 0
112093: ST_TO_ADDR
// end ;
112094: LD_VAR 0 1
112098: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
112099: LD_INT 0
112101: PPUSH
112102: PPUSH
112103: PPUSH
112104: PPUSH
112105: PPUSH
112106: PPUSH
112107: PPUSH
// result := [ ] ;
112108: LD_ADDR_VAR 0 2
112112: PUSH
112113: EMPTY
112114: ST_TO_ADDR
// if campaign_id = 1 then
112115: LD_OWVAR 69
112119: PUSH
112120: LD_INT 1
112122: EQUAL
112123: IFFALSE 115289
// begin case mission_number of 1 :
112125: LD_OWVAR 70
112129: PUSH
112130: LD_INT 1
112132: DOUBLE
112133: EQUAL
112134: IFTRUE 112138
112136: GO 112214
112138: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
112139: LD_ADDR_VAR 0 2
112143: PUSH
112144: LD_INT 2
112146: PUSH
112147: LD_INT 4
112149: PUSH
112150: LD_INT 11
112152: PUSH
112153: LD_INT 12
112155: PUSH
112156: LD_INT 15
112158: PUSH
112159: LD_INT 16
112161: PUSH
112162: LD_INT 22
112164: PUSH
112165: LD_INT 23
112167: PUSH
112168: LD_INT 26
112170: PUSH
112171: EMPTY
112172: LIST
112173: LIST
112174: LIST
112175: LIST
112176: LIST
112177: LIST
112178: LIST
112179: LIST
112180: LIST
112181: PUSH
112182: LD_INT 101
112184: PUSH
112185: LD_INT 102
112187: PUSH
112188: LD_INT 106
112190: PUSH
112191: LD_INT 116
112193: PUSH
112194: LD_INT 117
112196: PUSH
112197: LD_INT 118
112199: PUSH
112200: EMPTY
112201: LIST
112202: LIST
112203: LIST
112204: LIST
112205: LIST
112206: LIST
112207: PUSH
112208: EMPTY
112209: LIST
112210: LIST
112211: ST_TO_ADDR
112212: GO 115287
112214: LD_INT 2
112216: DOUBLE
112217: EQUAL
112218: IFTRUE 112222
112220: GO 112306
112222: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
112223: LD_ADDR_VAR 0 2
112227: PUSH
112228: LD_INT 2
112230: PUSH
112231: LD_INT 4
112233: PUSH
112234: LD_INT 11
112236: PUSH
112237: LD_INT 12
112239: PUSH
112240: LD_INT 15
112242: PUSH
112243: LD_INT 16
112245: PUSH
112246: LD_INT 22
112248: PUSH
112249: LD_INT 23
112251: PUSH
112252: LD_INT 26
112254: PUSH
112255: EMPTY
112256: LIST
112257: LIST
112258: LIST
112259: LIST
112260: LIST
112261: LIST
112262: LIST
112263: LIST
112264: LIST
112265: PUSH
112266: LD_INT 101
112268: PUSH
112269: LD_INT 102
112271: PUSH
112272: LD_INT 105
112274: PUSH
112275: LD_INT 106
112277: PUSH
112278: LD_INT 108
112280: PUSH
112281: LD_INT 116
112283: PUSH
112284: LD_INT 117
112286: PUSH
112287: LD_INT 118
112289: PUSH
112290: EMPTY
112291: LIST
112292: LIST
112293: LIST
112294: LIST
112295: LIST
112296: LIST
112297: LIST
112298: LIST
112299: PUSH
112300: EMPTY
112301: LIST
112302: LIST
112303: ST_TO_ADDR
112304: GO 115287
112306: LD_INT 3
112308: DOUBLE
112309: EQUAL
112310: IFTRUE 112314
112312: GO 112402
112314: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
112315: LD_ADDR_VAR 0 2
112319: PUSH
112320: LD_INT 2
112322: PUSH
112323: LD_INT 4
112325: PUSH
112326: LD_INT 5
112328: PUSH
112329: LD_INT 11
112331: PUSH
112332: LD_INT 12
112334: PUSH
112335: LD_INT 15
112337: PUSH
112338: LD_INT 16
112340: PUSH
112341: LD_INT 22
112343: PUSH
112344: LD_INT 26
112346: PUSH
112347: LD_INT 36
112349: PUSH
112350: EMPTY
112351: LIST
112352: LIST
112353: LIST
112354: LIST
112355: LIST
112356: LIST
112357: LIST
112358: LIST
112359: LIST
112360: LIST
112361: PUSH
112362: LD_INT 101
112364: PUSH
112365: LD_INT 102
112367: PUSH
112368: LD_INT 105
112370: PUSH
112371: LD_INT 106
112373: PUSH
112374: LD_INT 108
112376: PUSH
112377: LD_INT 116
112379: PUSH
112380: LD_INT 117
112382: PUSH
112383: LD_INT 118
112385: PUSH
112386: EMPTY
112387: LIST
112388: LIST
112389: LIST
112390: LIST
112391: LIST
112392: LIST
112393: LIST
112394: LIST
112395: PUSH
112396: EMPTY
112397: LIST
112398: LIST
112399: ST_TO_ADDR
112400: GO 115287
112402: LD_INT 4
112404: DOUBLE
112405: EQUAL
112406: IFTRUE 112410
112408: GO 112506
112410: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
112411: LD_ADDR_VAR 0 2
112415: PUSH
112416: LD_INT 2
112418: PUSH
112419: LD_INT 4
112421: PUSH
112422: LD_INT 5
112424: PUSH
112425: LD_INT 8
112427: PUSH
112428: LD_INT 11
112430: PUSH
112431: LD_INT 12
112433: PUSH
112434: LD_INT 15
112436: PUSH
112437: LD_INT 16
112439: PUSH
112440: LD_INT 22
112442: PUSH
112443: LD_INT 23
112445: PUSH
112446: LD_INT 26
112448: PUSH
112449: LD_INT 36
112451: PUSH
112452: EMPTY
112453: LIST
112454: LIST
112455: LIST
112456: LIST
112457: LIST
112458: LIST
112459: LIST
112460: LIST
112461: LIST
112462: LIST
112463: LIST
112464: LIST
112465: PUSH
112466: LD_INT 101
112468: PUSH
112469: LD_INT 102
112471: PUSH
112472: LD_INT 105
112474: PUSH
112475: LD_INT 106
112477: PUSH
112478: LD_INT 108
112480: PUSH
112481: LD_INT 116
112483: PUSH
112484: LD_INT 117
112486: PUSH
112487: LD_INT 118
112489: PUSH
112490: EMPTY
112491: LIST
112492: LIST
112493: LIST
112494: LIST
112495: LIST
112496: LIST
112497: LIST
112498: LIST
112499: PUSH
112500: EMPTY
112501: LIST
112502: LIST
112503: ST_TO_ADDR
112504: GO 115287
112506: LD_INT 5
112508: DOUBLE
112509: EQUAL
112510: IFTRUE 112514
112512: GO 112626
112514: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
112515: LD_ADDR_VAR 0 2
112519: PUSH
112520: LD_INT 2
112522: PUSH
112523: LD_INT 4
112525: PUSH
112526: LD_INT 5
112528: PUSH
112529: LD_INT 6
112531: PUSH
112532: LD_INT 8
112534: PUSH
112535: LD_INT 11
112537: PUSH
112538: LD_INT 12
112540: PUSH
112541: LD_INT 15
112543: PUSH
112544: LD_INT 16
112546: PUSH
112547: LD_INT 22
112549: PUSH
112550: LD_INT 23
112552: PUSH
112553: LD_INT 25
112555: PUSH
112556: LD_INT 26
112558: PUSH
112559: LD_INT 36
112561: PUSH
112562: EMPTY
112563: LIST
112564: LIST
112565: LIST
112566: LIST
112567: LIST
112568: LIST
112569: LIST
112570: LIST
112571: LIST
112572: LIST
112573: LIST
112574: LIST
112575: LIST
112576: LIST
112577: PUSH
112578: LD_INT 101
112580: PUSH
112581: LD_INT 102
112583: PUSH
112584: LD_INT 105
112586: PUSH
112587: LD_INT 106
112589: PUSH
112590: LD_INT 108
112592: PUSH
112593: LD_INT 109
112595: PUSH
112596: LD_INT 112
112598: PUSH
112599: LD_INT 116
112601: PUSH
112602: LD_INT 117
112604: PUSH
112605: LD_INT 118
112607: PUSH
112608: EMPTY
112609: LIST
112610: LIST
112611: LIST
112612: LIST
112613: LIST
112614: LIST
112615: LIST
112616: LIST
112617: LIST
112618: LIST
112619: PUSH
112620: EMPTY
112621: LIST
112622: LIST
112623: ST_TO_ADDR
112624: GO 115287
112626: LD_INT 6
112628: DOUBLE
112629: EQUAL
112630: IFTRUE 112634
112632: GO 112766
112634: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
112635: LD_ADDR_VAR 0 2
112639: PUSH
112640: LD_INT 2
112642: PUSH
112643: LD_INT 4
112645: PUSH
112646: LD_INT 5
112648: PUSH
112649: LD_INT 6
112651: PUSH
112652: LD_INT 8
112654: PUSH
112655: LD_INT 11
112657: PUSH
112658: LD_INT 12
112660: PUSH
112661: LD_INT 15
112663: PUSH
112664: LD_INT 16
112666: PUSH
112667: LD_INT 20
112669: PUSH
112670: LD_INT 21
112672: PUSH
112673: LD_INT 22
112675: PUSH
112676: LD_INT 23
112678: PUSH
112679: LD_INT 25
112681: PUSH
112682: LD_INT 26
112684: PUSH
112685: LD_INT 30
112687: PUSH
112688: LD_INT 31
112690: PUSH
112691: LD_INT 32
112693: PUSH
112694: LD_INT 36
112696: PUSH
112697: EMPTY
112698: LIST
112699: LIST
112700: LIST
112701: LIST
112702: LIST
112703: LIST
112704: LIST
112705: LIST
112706: LIST
112707: LIST
112708: LIST
112709: LIST
112710: LIST
112711: LIST
112712: LIST
112713: LIST
112714: LIST
112715: LIST
112716: LIST
112717: PUSH
112718: LD_INT 101
112720: PUSH
112721: LD_INT 102
112723: PUSH
112724: LD_INT 105
112726: PUSH
112727: LD_INT 106
112729: PUSH
112730: LD_INT 108
112732: PUSH
112733: LD_INT 109
112735: PUSH
112736: LD_INT 112
112738: PUSH
112739: LD_INT 116
112741: PUSH
112742: LD_INT 117
112744: PUSH
112745: LD_INT 118
112747: PUSH
112748: EMPTY
112749: LIST
112750: LIST
112751: LIST
112752: LIST
112753: LIST
112754: LIST
112755: LIST
112756: LIST
112757: LIST
112758: LIST
112759: PUSH
112760: EMPTY
112761: LIST
112762: LIST
112763: ST_TO_ADDR
112764: GO 115287
112766: LD_INT 7
112768: DOUBLE
112769: EQUAL
112770: IFTRUE 112774
112772: GO 112886
112774: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
112775: LD_ADDR_VAR 0 2
112779: PUSH
112780: LD_INT 2
112782: PUSH
112783: LD_INT 4
112785: PUSH
112786: LD_INT 5
112788: PUSH
112789: LD_INT 7
112791: PUSH
112792: LD_INT 11
112794: PUSH
112795: LD_INT 12
112797: PUSH
112798: LD_INT 15
112800: PUSH
112801: LD_INT 16
112803: PUSH
112804: LD_INT 20
112806: PUSH
112807: LD_INT 21
112809: PUSH
112810: LD_INT 22
112812: PUSH
112813: LD_INT 23
112815: PUSH
112816: LD_INT 25
112818: PUSH
112819: LD_INT 26
112821: PUSH
112822: EMPTY
112823: LIST
112824: LIST
112825: LIST
112826: LIST
112827: LIST
112828: LIST
112829: LIST
112830: LIST
112831: LIST
112832: LIST
112833: LIST
112834: LIST
112835: LIST
112836: LIST
112837: PUSH
112838: LD_INT 101
112840: PUSH
112841: LD_INT 102
112843: PUSH
112844: LD_INT 103
112846: PUSH
112847: LD_INT 105
112849: PUSH
112850: LD_INT 106
112852: PUSH
112853: LD_INT 108
112855: PUSH
112856: LD_INT 112
112858: PUSH
112859: LD_INT 116
112861: PUSH
112862: LD_INT 117
112864: PUSH
112865: LD_INT 118
112867: PUSH
112868: EMPTY
112869: LIST
112870: LIST
112871: LIST
112872: LIST
112873: LIST
112874: LIST
112875: LIST
112876: LIST
112877: LIST
112878: LIST
112879: PUSH
112880: EMPTY
112881: LIST
112882: LIST
112883: ST_TO_ADDR
112884: GO 115287
112886: LD_INT 8
112888: DOUBLE
112889: EQUAL
112890: IFTRUE 112894
112892: GO 113034
112894: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
112895: LD_ADDR_VAR 0 2
112899: PUSH
112900: LD_INT 2
112902: PUSH
112903: LD_INT 4
112905: PUSH
112906: LD_INT 5
112908: PUSH
112909: LD_INT 6
112911: PUSH
112912: LD_INT 7
112914: PUSH
112915: LD_INT 8
112917: PUSH
112918: LD_INT 11
112920: PUSH
112921: LD_INT 12
112923: PUSH
112924: LD_INT 15
112926: PUSH
112927: LD_INT 16
112929: PUSH
112930: LD_INT 20
112932: PUSH
112933: LD_INT 21
112935: PUSH
112936: LD_INT 22
112938: PUSH
112939: LD_INT 23
112941: PUSH
112942: LD_INT 25
112944: PUSH
112945: LD_INT 26
112947: PUSH
112948: LD_INT 30
112950: PUSH
112951: LD_INT 31
112953: PUSH
112954: LD_INT 32
112956: PUSH
112957: LD_INT 36
112959: PUSH
112960: EMPTY
112961: LIST
112962: LIST
112963: LIST
112964: LIST
112965: LIST
112966: LIST
112967: LIST
112968: LIST
112969: LIST
112970: LIST
112971: LIST
112972: LIST
112973: LIST
112974: LIST
112975: LIST
112976: LIST
112977: LIST
112978: LIST
112979: LIST
112980: LIST
112981: PUSH
112982: LD_INT 101
112984: PUSH
112985: LD_INT 102
112987: PUSH
112988: LD_INT 103
112990: PUSH
112991: LD_INT 105
112993: PUSH
112994: LD_INT 106
112996: PUSH
112997: LD_INT 108
112999: PUSH
113000: LD_INT 109
113002: PUSH
113003: LD_INT 112
113005: PUSH
113006: LD_INT 116
113008: PUSH
113009: LD_INT 117
113011: PUSH
113012: LD_INT 118
113014: PUSH
113015: EMPTY
113016: LIST
113017: LIST
113018: LIST
113019: LIST
113020: LIST
113021: LIST
113022: LIST
113023: LIST
113024: LIST
113025: LIST
113026: LIST
113027: PUSH
113028: EMPTY
113029: LIST
113030: LIST
113031: ST_TO_ADDR
113032: GO 115287
113034: LD_INT 9
113036: DOUBLE
113037: EQUAL
113038: IFTRUE 113042
113040: GO 113190
113042: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
113043: LD_ADDR_VAR 0 2
113047: PUSH
113048: LD_INT 2
113050: PUSH
113051: LD_INT 4
113053: PUSH
113054: LD_INT 5
113056: PUSH
113057: LD_INT 6
113059: PUSH
113060: LD_INT 7
113062: PUSH
113063: LD_INT 8
113065: PUSH
113066: LD_INT 11
113068: PUSH
113069: LD_INT 12
113071: PUSH
113072: LD_INT 15
113074: PUSH
113075: LD_INT 16
113077: PUSH
113078: LD_INT 20
113080: PUSH
113081: LD_INT 21
113083: PUSH
113084: LD_INT 22
113086: PUSH
113087: LD_INT 23
113089: PUSH
113090: LD_INT 25
113092: PUSH
113093: LD_INT 26
113095: PUSH
113096: LD_INT 28
113098: PUSH
113099: LD_INT 30
113101: PUSH
113102: LD_INT 31
113104: PUSH
113105: LD_INT 32
113107: PUSH
113108: LD_INT 36
113110: PUSH
113111: EMPTY
113112: LIST
113113: LIST
113114: LIST
113115: LIST
113116: LIST
113117: LIST
113118: LIST
113119: LIST
113120: LIST
113121: LIST
113122: LIST
113123: LIST
113124: LIST
113125: LIST
113126: LIST
113127: LIST
113128: LIST
113129: LIST
113130: LIST
113131: LIST
113132: LIST
113133: PUSH
113134: LD_INT 101
113136: PUSH
113137: LD_INT 102
113139: PUSH
113140: LD_INT 103
113142: PUSH
113143: LD_INT 105
113145: PUSH
113146: LD_INT 106
113148: PUSH
113149: LD_INT 108
113151: PUSH
113152: LD_INT 109
113154: PUSH
113155: LD_INT 112
113157: PUSH
113158: LD_INT 114
113160: PUSH
113161: LD_INT 116
113163: PUSH
113164: LD_INT 117
113166: PUSH
113167: LD_INT 118
113169: PUSH
113170: EMPTY
113171: LIST
113172: LIST
113173: LIST
113174: LIST
113175: LIST
113176: LIST
113177: LIST
113178: LIST
113179: LIST
113180: LIST
113181: LIST
113182: LIST
113183: PUSH
113184: EMPTY
113185: LIST
113186: LIST
113187: ST_TO_ADDR
113188: GO 115287
113190: LD_INT 10
113192: DOUBLE
113193: EQUAL
113194: IFTRUE 113198
113196: GO 113394
113198: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
113199: LD_ADDR_VAR 0 2
113203: PUSH
113204: LD_INT 2
113206: PUSH
113207: LD_INT 4
113209: PUSH
113210: LD_INT 5
113212: PUSH
113213: LD_INT 6
113215: PUSH
113216: LD_INT 7
113218: PUSH
113219: LD_INT 8
113221: PUSH
113222: LD_INT 9
113224: PUSH
113225: LD_INT 10
113227: PUSH
113228: LD_INT 11
113230: PUSH
113231: LD_INT 12
113233: PUSH
113234: LD_INT 13
113236: PUSH
113237: LD_INT 14
113239: PUSH
113240: LD_INT 15
113242: PUSH
113243: LD_INT 16
113245: PUSH
113246: LD_INT 17
113248: PUSH
113249: LD_INT 18
113251: PUSH
113252: LD_INT 19
113254: PUSH
113255: LD_INT 20
113257: PUSH
113258: LD_INT 21
113260: PUSH
113261: LD_INT 22
113263: PUSH
113264: LD_INT 23
113266: PUSH
113267: LD_INT 24
113269: PUSH
113270: LD_INT 25
113272: PUSH
113273: LD_INT 26
113275: PUSH
113276: LD_INT 28
113278: PUSH
113279: LD_INT 30
113281: PUSH
113282: LD_INT 31
113284: PUSH
113285: LD_INT 32
113287: PUSH
113288: LD_INT 36
113290: PUSH
113291: EMPTY
113292: LIST
113293: LIST
113294: LIST
113295: LIST
113296: LIST
113297: LIST
113298: LIST
113299: LIST
113300: LIST
113301: LIST
113302: LIST
113303: LIST
113304: LIST
113305: LIST
113306: LIST
113307: LIST
113308: LIST
113309: LIST
113310: LIST
113311: LIST
113312: LIST
113313: LIST
113314: LIST
113315: LIST
113316: LIST
113317: LIST
113318: LIST
113319: LIST
113320: LIST
113321: PUSH
113322: LD_INT 101
113324: PUSH
113325: LD_INT 102
113327: PUSH
113328: LD_INT 103
113330: PUSH
113331: LD_INT 104
113333: PUSH
113334: LD_INT 105
113336: PUSH
113337: LD_INT 106
113339: PUSH
113340: LD_INT 107
113342: PUSH
113343: LD_INT 108
113345: PUSH
113346: LD_INT 109
113348: PUSH
113349: LD_INT 110
113351: PUSH
113352: LD_INT 111
113354: PUSH
113355: LD_INT 112
113357: PUSH
113358: LD_INT 114
113360: PUSH
113361: LD_INT 116
113363: PUSH
113364: LD_INT 117
113366: PUSH
113367: LD_INT 118
113369: PUSH
113370: EMPTY
113371: LIST
113372: LIST
113373: LIST
113374: LIST
113375: LIST
113376: LIST
113377: LIST
113378: LIST
113379: LIST
113380: LIST
113381: LIST
113382: LIST
113383: LIST
113384: LIST
113385: LIST
113386: LIST
113387: PUSH
113388: EMPTY
113389: LIST
113390: LIST
113391: ST_TO_ADDR
113392: GO 115287
113394: LD_INT 11
113396: DOUBLE
113397: EQUAL
113398: IFTRUE 113402
113400: GO 113606
113402: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
113403: LD_ADDR_VAR 0 2
113407: PUSH
113408: LD_INT 2
113410: PUSH
113411: LD_INT 3
113413: PUSH
113414: LD_INT 4
113416: PUSH
113417: LD_INT 5
113419: PUSH
113420: LD_INT 6
113422: PUSH
113423: LD_INT 7
113425: PUSH
113426: LD_INT 8
113428: PUSH
113429: LD_INT 9
113431: PUSH
113432: LD_INT 10
113434: PUSH
113435: LD_INT 11
113437: PUSH
113438: LD_INT 12
113440: PUSH
113441: LD_INT 13
113443: PUSH
113444: LD_INT 14
113446: PUSH
113447: LD_INT 15
113449: PUSH
113450: LD_INT 16
113452: PUSH
113453: LD_INT 17
113455: PUSH
113456: LD_INT 18
113458: PUSH
113459: LD_INT 19
113461: PUSH
113462: LD_INT 20
113464: PUSH
113465: LD_INT 21
113467: PUSH
113468: LD_INT 22
113470: PUSH
113471: LD_INT 23
113473: PUSH
113474: LD_INT 24
113476: PUSH
113477: LD_INT 25
113479: PUSH
113480: LD_INT 26
113482: PUSH
113483: LD_INT 28
113485: PUSH
113486: LD_INT 30
113488: PUSH
113489: LD_INT 31
113491: PUSH
113492: LD_INT 32
113494: PUSH
113495: LD_INT 34
113497: PUSH
113498: LD_INT 36
113500: PUSH
113501: EMPTY
113502: LIST
113503: LIST
113504: LIST
113505: LIST
113506: LIST
113507: LIST
113508: LIST
113509: LIST
113510: LIST
113511: LIST
113512: LIST
113513: LIST
113514: LIST
113515: LIST
113516: LIST
113517: LIST
113518: LIST
113519: LIST
113520: LIST
113521: LIST
113522: LIST
113523: LIST
113524: LIST
113525: LIST
113526: LIST
113527: LIST
113528: LIST
113529: LIST
113530: LIST
113531: LIST
113532: LIST
113533: PUSH
113534: LD_INT 101
113536: PUSH
113537: LD_INT 102
113539: PUSH
113540: LD_INT 103
113542: PUSH
113543: LD_INT 104
113545: PUSH
113546: LD_INT 105
113548: PUSH
113549: LD_INT 106
113551: PUSH
113552: LD_INT 107
113554: PUSH
113555: LD_INT 108
113557: PUSH
113558: LD_INT 109
113560: PUSH
113561: LD_INT 110
113563: PUSH
113564: LD_INT 111
113566: PUSH
113567: LD_INT 112
113569: PUSH
113570: LD_INT 114
113572: PUSH
113573: LD_INT 116
113575: PUSH
113576: LD_INT 117
113578: PUSH
113579: LD_INT 118
113581: PUSH
113582: EMPTY
113583: LIST
113584: LIST
113585: LIST
113586: LIST
113587: LIST
113588: LIST
113589: LIST
113590: LIST
113591: LIST
113592: LIST
113593: LIST
113594: LIST
113595: LIST
113596: LIST
113597: LIST
113598: LIST
113599: PUSH
113600: EMPTY
113601: LIST
113602: LIST
113603: ST_TO_ADDR
113604: GO 115287
113606: LD_INT 12
113608: DOUBLE
113609: EQUAL
113610: IFTRUE 113614
113612: GO 113834
113614: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
113615: LD_ADDR_VAR 0 2
113619: PUSH
113620: LD_INT 1
113622: PUSH
113623: LD_INT 2
113625: PUSH
113626: LD_INT 3
113628: PUSH
113629: LD_INT 4
113631: PUSH
113632: LD_INT 5
113634: PUSH
113635: LD_INT 6
113637: PUSH
113638: LD_INT 7
113640: PUSH
113641: LD_INT 8
113643: PUSH
113644: LD_INT 9
113646: PUSH
113647: LD_INT 10
113649: PUSH
113650: LD_INT 11
113652: PUSH
113653: LD_INT 12
113655: PUSH
113656: LD_INT 13
113658: PUSH
113659: LD_INT 14
113661: PUSH
113662: LD_INT 15
113664: PUSH
113665: LD_INT 16
113667: PUSH
113668: LD_INT 17
113670: PUSH
113671: LD_INT 18
113673: PUSH
113674: LD_INT 19
113676: PUSH
113677: LD_INT 20
113679: PUSH
113680: LD_INT 21
113682: PUSH
113683: LD_INT 22
113685: PUSH
113686: LD_INT 23
113688: PUSH
113689: LD_INT 24
113691: PUSH
113692: LD_INT 25
113694: PUSH
113695: LD_INT 26
113697: PUSH
113698: LD_INT 27
113700: PUSH
113701: LD_INT 28
113703: PUSH
113704: LD_INT 30
113706: PUSH
113707: LD_INT 31
113709: PUSH
113710: LD_INT 32
113712: PUSH
113713: LD_INT 33
113715: PUSH
113716: LD_INT 34
113718: PUSH
113719: LD_INT 36
113721: PUSH
113722: EMPTY
113723: LIST
113724: LIST
113725: LIST
113726: LIST
113727: LIST
113728: LIST
113729: LIST
113730: LIST
113731: LIST
113732: LIST
113733: LIST
113734: LIST
113735: LIST
113736: LIST
113737: LIST
113738: LIST
113739: LIST
113740: LIST
113741: LIST
113742: LIST
113743: LIST
113744: LIST
113745: LIST
113746: LIST
113747: LIST
113748: LIST
113749: LIST
113750: LIST
113751: LIST
113752: LIST
113753: LIST
113754: LIST
113755: LIST
113756: LIST
113757: PUSH
113758: LD_INT 101
113760: PUSH
113761: LD_INT 102
113763: PUSH
113764: LD_INT 103
113766: PUSH
113767: LD_INT 104
113769: PUSH
113770: LD_INT 105
113772: PUSH
113773: LD_INT 106
113775: PUSH
113776: LD_INT 107
113778: PUSH
113779: LD_INT 108
113781: PUSH
113782: LD_INT 109
113784: PUSH
113785: LD_INT 110
113787: PUSH
113788: LD_INT 111
113790: PUSH
113791: LD_INT 112
113793: PUSH
113794: LD_INT 113
113796: PUSH
113797: LD_INT 114
113799: PUSH
113800: LD_INT 116
113802: PUSH
113803: LD_INT 117
113805: PUSH
113806: LD_INT 118
113808: PUSH
113809: EMPTY
113810: LIST
113811: LIST
113812: LIST
113813: LIST
113814: LIST
113815: LIST
113816: LIST
113817: LIST
113818: LIST
113819: LIST
113820: LIST
113821: LIST
113822: LIST
113823: LIST
113824: LIST
113825: LIST
113826: LIST
113827: PUSH
113828: EMPTY
113829: LIST
113830: LIST
113831: ST_TO_ADDR
113832: GO 115287
113834: LD_INT 13
113836: DOUBLE
113837: EQUAL
113838: IFTRUE 113842
113840: GO 114050
113842: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
113843: LD_ADDR_VAR 0 2
113847: PUSH
113848: LD_INT 1
113850: PUSH
113851: LD_INT 2
113853: PUSH
113854: LD_INT 3
113856: PUSH
113857: LD_INT 4
113859: PUSH
113860: LD_INT 5
113862: PUSH
113863: LD_INT 8
113865: PUSH
113866: LD_INT 9
113868: PUSH
113869: LD_INT 10
113871: PUSH
113872: LD_INT 11
113874: PUSH
113875: LD_INT 12
113877: PUSH
113878: LD_INT 14
113880: PUSH
113881: LD_INT 15
113883: PUSH
113884: LD_INT 16
113886: PUSH
113887: LD_INT 17
113889: PUSH
113890: LD_INT 18
113892: PUSH
113893: LD_INT 19
113895: PUSH
113896: LD_INT 20
113898: PUSH
113899: LD_INT 21
113901: PUSH
113902: LD_INT 22
113904: PUSH
113905: LD_INT 23
113907: PUSH
113908: LD_INT 24
113910: PUSH
113911: LD_INT 25
113913: PUSH
113914: LD_INT 26
113916: PUSH
113917: LD_INT 27
113919: PUSH
113920: LD_INT 28
113922: PUSH
113923: LD_INT 30
113925: PUSH
113926: LD_INT 31
113928: PUSH
113929: LD_INT 32
113931: PUSH
113932: LD_INT 33
113934: PUSH
113935: LD_INT 34
113937: PUSH
113938: LD_INT 36
113940: PUSH
113941: EMPTY
113942: LIST
113943: LIST
113944: LIST
113945: LIST
113946: LIST
113947: LIST
113948: LIST
113949: LIST
113950: LIST
113951: LIST
113952: LIST
113953: LIST
113954: LIST
113955: LIST
113956: LIST
113957: LIST
113958: LIST
113959: LIST
113960: LIST
113961: LIST
113962: LIST
113963: LIST
113964: LIST
113965: LIST
113966: LIST
113967: LIST
113968: LIST
113969: LIST
113970: LIST
113971: LIST
113972: LIST
113973: PUSH
113974: LD_INT 101
113976: PUSH
113977: LD_INT 102
113979: PUSH
113980: LD_INT 103
113982: PUSH
113983: LD_INT 104
113985: PUSH
113986: LD_INT 105
113988: PUSH
113989: LD_INT 106
113991: PUSH
113992: LD_INT 107
113994: PUSH
113995: LD_INT 108
113997: PUSH
113998: LD_INT 109
114000: PUSH
114001: LD_INT 110
114003: PUSH
114004: LD_INT 111
114006: PUSH
114007: LD_INT 112
114009: PUSH
114010: LD_INT 113
114012: PUSH
114013: LD_INT 114
114015: PUSH
114016: LD_INT 116
114018: PUSH
114019: LD_INT 117
114021: PUSH
114022: LD_INT 118
114024: PUSH
114025: EMPTY
114026: LIST
114027: LIST
114028: LIST
114029: LIST
114030: LIST
114031: LIST
114032: LIST
114033: LIST
114034: LIST
114035: LIST
114036: LIST
114037: LIST
114038: LIST
114039: LIST
114040: LIST
114041: LIST
114042: LIST
114043: PUSH
114044: EMPTY
114045: LIST
114046: LIST
114047: ST_TO_ADDR
114048: GO 115287
114050: LD_INT 14
114052: DOUBLE
114053: EQUAL
114054: IFTRUE 114058
114056: GO 114282
114058: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
114059: LD_ADDR_VAR 0 2
114063: PUSH
114064: LD_INT 1
114066: PUSH
114067: LD_INT 2
114069: PUSH
114070: LD_INT 3
114072: PUSH
114073: LD_INT 4
114075: PUSH
114076: LD_INT 5
114078: PUSH
114079: LD_INT 6
114081: PUSH
114082: LD_INT 7
114084: PUSH
114085: LD_INT 8
114087: PUSH
114088: LD_INT 9
114090: PUSH
114091: LD_INT 10
114093: PUSH
114094: LD_INT 11
114096: PUSH
114097: LD_INT 12
114099: PUSH
114100: LD_INT 13
114102: PUSH
114103: LD_INT 14
114105: PUSH
114106: LD_INT 15
114108: PUSH
114109: LD_INT 16
114111: PUSH
114112: LD_INT 17
114114: PUSH
114115: LD_INT 18
114117: PUSH
114118: LD_INT 19
114120: PUSH
114121: LD_INT 20
114123: PUSH
114124: LD_INT 21
114126: PUSH
114127: LD_INT 22
114129: PUSH
114130: LD_INT 23
114132: PUSH
114133: LD_INT 24
114135: PUSH
114136: LD_INT 25
114138: PUSH
114139: LD_INT 26
114141: PUSH
114142: LD_INT 27
114144: PUSH
114145: LD_INT 28
114147: PUSH
114148: LD_INT 29
114150: PUSH
114151: LD_INT 30
114153: PUSH
114154: LD_INT 31
114156: PUSH
114157: LD_INT 32
114159: PUSH
114160: LD_INT 33
114162: PUSH
114163: LD_INT 34
114165: PUSH
114166: LD_INT 36
114168: PUSH
114169: EMPTY
114170: LIST
114171: LIST
114172: LIST
114173: LIST
114174: LIST
114175: LIST
114176: LIST
114177: LIST
114178: LIST
114179: LIST
114180: LIST
114181: LIST
114182: LIST
114183: LIST
114184: LIST
114185: LIST
114186: LIST
114187: LIST
114188: LIST
114189: LIST
114190: LIST
114191: LIST
114192: LIST
114193: LIST
114194: LIST
114195: LIST
114196: LIST
114197: LIST
114198: LIST
114199: LIST
114200: LIST
114201: LIST
114202: LIST
114203: LIST
114204: LIST
114205: PUSH
114206: LD_INT 101
114208: PUSH
114209: LD_INT 102
114211: PUSH
114212: LD_INT 103
114214: PUSH
114215: LD_INT 104
114217: PUSH
114218: LD_INT 105
114220: PUSH
114221: LD_INT 106
114223: PUSH
114224: LD_INT 107
114226: PUSH
114227: LD_INT 108
114229: PUSH
114230: LD_INT 109
114232: PUSH
114233: LD_INT 110
114235: PUSH
114236: LD_INT 111
114238: PUSH
114239: LD_INT 112
114241: PUSH
114242: LD_INT 113
114244: PUSH
114245: LD_INT 114
114247: PUSH
114248: LD_INT 116
114250: PUSH
114251: LD_INT 117
114253: PUSH
114254: LD_INT 118
114256: PUSH
114257: EMPTY
114258: LIST
114259: LIST
114260: LIST
114261: LIST
114262: LIST
114263: LIST
114264: LIST
114265: LIST
114266: LIST
114267: LIST
114268: LIST
114269: LIST
114270: LIST
114271: LIST
114272: LIST
114273: LIST
114274: LIST
114275: PUSH
114276: EMPTY
114277: LIST
114278: LIST
114279: ST_TO_ADDR
114280: GO 115287
114282: LD_INT 15
114284: DOUBLE
114285: EQUAL
114286: IFTRUE 114290
114288: GO 114514
114290: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
114291: LD_ADDR_VAR 0 2
114295: PUSH
114296: LD_INT 1
114298: PUSH
114299: LD_INT 2
114301: PUSH
114302: LD_INT 3
114304: PUSH
114305: LD_INT 4
114307: PUSH
114308: LD_INT 5
114310: PUSH
114311: LD_INT 6
114313: PUSH
114314: LD_INT 7
114316: PUSH
114317: LD_INT 8
114319: PUSH
114320: LD_INT 9
114322: PUSH
114323: LD_INT 10
114325: PUSH
114326: LD_INT 11
114328: PUSH
114329: LD_INT 12
114331: PUSH
114332: LD_INT 13
114334: PUSH
114335: LD_INT 14
114337: PUSH
114338: LD_INT 15
114340: PUSH
114341: LD_INT 16
114343: PUSH
114344: LD_INT 17
114346: PUSH
114347: LD_INT 18
114349: PUSH
114350: LD_INT 19
114352: PUSH
114353: LD_INT 20
114355: PUSH
114356: LD_INT 21
114358: PUSH
114359: LD_INT 22
114361: PUSH
114362: LD_INT 23
114364: PUSH
114365: LD_INT 24
114367: PUSH
114368: LD_INT 25
114370: PUSH
114371: LD_INT 26
114373: PUSH
114374: LD_INT 27
114376: PUSH
114377: LD_INT 28
114379: PUSH
114380: LD_INT 29
114382: PUSH
114383: LD_INT 30
114385: PUSH
114386: LD_INT 31
114388: PUSH
114389: LD_INT 32
114391: PUSH
114392: LD_INT 33
114394: PUSH
114395: LD_INT 34
114397: PUSH
114398: LD_INT 36
114400: PUSH
114401: EMPTY
114402: LIST
114403: LIST
114404: LIST
114405: LIST
114406: LIST
114407: LIST
114408: LIST
114409: LIST
114410: LIST
114411: LIST
114412: LIST
114413: LIST
114414: LIST
114415: LIST
114416: LIST
114417: LIST
114418: LIST
114419: LIST
114420: LIST
114421: LIST
114422: LIST
114423: LIST
114424: LIST
114425: LIST
114426: LIST
114427: LIST
114428: LIST
114429: LIST
114430: LIST
114431: LIST
114432: LIST
114433: LIST
114434: LIST
114435: LIST
114436: LIST
114437: PUSH
114438: LD_INT 101
114440: PUSH
114441: LD_INT 102
114443: PUSH
114444: LD_INT 103
114446: PUSH
114447: LD_INT 104
114449: PUSH
114450: LD_INT 105
114452: PUSH
114453: LD_INT 106
114455: PUSH
114456: LD_INT 107
114458: PUSH
114459: LD_INT 108
114461: PUSH
114462: LD_INT 109
114464: PUSH
114465: LD_INT 110
114467: PUSH
114468: LD_INT 111
114470: PUSH
114471: LD_INT 112
114473: PUSH
114474: LD_INT 113
114476: PUSH
114477: LD_INT 114
114479: PUSH
114480: LD_INT 116
114482: PUSH
114483: LD_INT 117
114485: PUSH
114486: LD_INT 118
114488: PUSH
114489: EMPTY
114490: LIST
114491: LIST
114492: LIST
114493: LIST
114494: LIST
114495: LIST
114496: LIST
114497: LIST
114498: LIST
114499: LIST
114500: LIST
114501: LIST
114502: LIST
114503: LIST
114504: LIST
114505: LIST
114506: LIST
114507: PUSH
114508: EMPTY
114509: LIST
114510: LIST
114511: ST_TO_ADDR
114512: GO 115287
114514: LD_INT 16
114516: DOUBLE
114517: EQUAL
114518: IFTRUE 114522
114520: GO 114658
114522: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
114523: LD_ADDR_VAR 0 2
114527: PUSH
114528: LD_INT 2
114530: PUSH
114531: LD_INT 4
114533: PUSH
114534: LD_INT 5
114536: PUSH
114537: LD_INT 7
114539: PUSH
114540: LD_INT 11
114542: PUSH
114543: LD_INT 12
114545: PUSH
114546: LD_INT 15
114548: PUSH
114549: LD_INT 16
114551: PUSH
114552: LD_INT 20
114554: PUSH
114555: LD_INT 21
114557: PUSH
114558: LD_INT 22
114560: PUSH
114561: LD_INT 23
114563: PUSH
114564: LD_INT 25
114566: PUSH
114567: LD_INT 26
114569: PUSH
114570: LD_INT 30
114572: PUSH
114573: LD_INT 31
114575: PUSH
114576: LD_INT 32
114578: PUSH
114579: LD_INT 33
114581: PUSH
114582: LD_INT 34
114584: PUSH
114585: EMPTY
114586: LIST
114587: LIST
114588: LIST
114589: LIST
114590: LIST
114591: LIST
114592: LIST
114593: LIST
114594: LIST
114595: LIST
114596: LIST
114597: LIST
114598: LIST
114599: LIST
114600: LIST
114601: LIST
114602: LIST
114603: LIST
114604: LIST
114605: PUSH
114606: LD_INT 101
114608: PUSH
114609: LD_INT 102
114611: PUSH
114612: LD_INT 103
114614: PUSH
114615: LD_INT 106
114617: PUSH
114618: LD_INT 108
114620: PUSH
114621: LD_INT 112
114623: PUSH
114624: LD_INT 113
114626: PUSH
114627: LD_INT 114
114629: PUSH
114630: LD_INT 116
114632: PUSH
114633: LD_INT 117
114635: PUSH
114636: LD_INT 118
114638: PUSH
114639: EMPTY
114640: LIST
114641: LIST
114642: LIST
114643: LIST
114644: LIST
114645: LIST
114646: LIST
114647: LIST
114648: LIST
114649: LIST
114650: LIST
114651: PUSH
114652: EMPTY
114653: LIST
114654: LIST
114655: ST_TO_ADDR
114656: GO 115287
114658: LD_INT 17
114660: DOUBLE
114661: EQUAL
114662: IFTRUE 114666
114664: GO 114890
114666: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
114667: LD_ADDR_VAR 0 2
114671: PUSH
114672: LD_INT 1
114674: PUSH
114675: LD_INT 2
114677: PUSH
114678: LD_INT 3
114680: PUSH
114681: LD_INT 4
114683: PUSH
114684: LD_INT 5
114686: PUSH
114687: LD_INT 6
114689: PUSH
114690: LD_INT 7
114692: PUSH
114693: LD_INT 8
114695: PUSH
114696: LD_INT 9
114698: PUSH
114699: LD_INT 10
114701: PUSH
114702: LD_INT 11
114704: PUSH
114705: LD_INT 12
114707: PUSH
114708: LD_INT 13
114710: PUSH
114711: LD_INT 14
114713: PUSH
114714: LD_INT 15
114716: PUSH
114717: LD_INT 16
114719: PUSH
114720: LD_INT 17
114722: PUSH
114723: LD_INT 18
114725: PUSH
114726: LD_INT 19
114728: PUSH
114729: LD_INT 20
114731: PUSH
114732: LD_INT 21
114734: PUSH
114735: LD_INT 22
114737: PUSH
114738: LD_INT 23
114740: PUSH
114741: LD_INT 24
114743: PUSH
114744: LD_INT 25
114746: PUSH
114747: LD_INT 26
114749: PUSH
114750: LD_INT 27
114752: PUSH
114753: LD_INT 28
114755: PUSH
114756: LD_INT 29
114758: PUSH
114759: LD_INT 30
114761: PUSH
114762: LD_INT 31
114764: PUSH
114765: LD_INT 32
114767: PUSH
114768: LD_INT 33
114770: PUSH
114771: LD_INT 34
114773: PUSH
114774: LD_INT 36
114776: PUSH
114777: EMPTY
114778: LIST
114779: LIST
114780: LIST
114781: LIST
114782: LIST
114783: LIST
114784: LIST
114785: LIST
114786: LIST
114787: LIST
114788: LIST
114789: LIST
114790: LIST
114791: LIST
114792: LIST
114793: LIST
114794: LIST
114795: LIST
114796: LIST
114797: LIST
114798: LIST
114799: LIST
114800: LIST
114801: LIST
114802: LIST
114803: LIST
114804: LIST
114805: LIST
114806: LIST
114807: LIST
114808: LIST
114809: LIST
114810: LIST
114811: LIST
114812: LIST
114813: PUSH
114814: LD_INT 101
114816: PUSH
114817: LD_INT 102
114819: PUSH
114820: LD_INT 103
114822: PUSH
114823: LD_INT 104
114825: PUSH
114826: LD_INT 105
114828: PUSH
114829: LD_INT 106
114831: PUSH
114832: LD_INT 107
114834: PUSH
114835: LD_INT 108
114837: PUSH
114838: LD_INT 109
114840: PUSH
114841: LD_INT 110
114843: PUSH
114844: LD_INT 111
114846: PUSH
114847: LD_INT 112
114849: PUSH
114850: LD_INT 113
114852: PUSH
114853: LD_INT 114
114855: PUSH
114856: LD_INT 116
114858: PUSH
114859: LD_INT 117
114861: PUSH
114862: LD_INT 118
114864: PUSH
114865: EMPTY
114866: LIST
114867: LIST
114868: LIST
114869: LIST
114870: LIST
114871: LIST
114872: LIST
114873: LIST
114874: LIST
114875: LIST
114876: LIST
114877: LIST
114878: LIST
114879: LIST
114880: LIST
114881: LIST
114882: LIST
114883: PUSH
114884: EMPTY
114885: LIST
114886: LIST
114887: ST_TO_ADDR
114888: GO 115287
114890: LD_INT 18
114892: DOUBLE
114893: EQUAL
114894: IFTRUE 114898
114896: GO 115046
114898: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
114899: LD_ADDR_VAR 0 2
114903: PUSH
114904: LD_INT 2
114906: PUSH
114907: LD_INT 4
114909: PUSH
114910: LD_INT 5
114912: PUSH
114913: LD_INT 7
114915: PUSH
114916: LD_INT 11
114918: PUSH
114919: LD_INT 12
114921: PUSH
114922: LD_INT 15
114924: PUSH
114925: LD_INT 16
114927: PUSH
114928: LD_INT 20
114930: PUSH
114931: LD_INT 21
114933: PUSH
114934: LD_INT 22
114936: PUSH
114937: LD_INT 23
114939: PUSH
114940: LD_INT 25
114942: PUSH
114943: LD_INT 26
114945: PUSH
114946: LD_INT 30
114948: PUSH
114949: LD_INT 31
114951: PUSH
114952: LD_INT 32
114954: PUSH
114955: LD_INT 33
114957: PUSH
114958: LD_INT 34
114960: PUSH
114961: LD_INT 35
114963: PUSH
114964: LD_INT 36
114966: PUSH
114967: EMPTY
114968: LIST
114969: LIST
114970: LIST
114971: LIST
114972: LIST
114973: LIST
114974: LIST
114975: LIST
114976: LIST
114977: LIST
114978: LIST
114979: LIST
114980: LIST
114981: LIST
114982: LIST
114983: LIST
114984: LIST
114985: LIST
114986: LIST
114987: LIST
114988: LIST
114989: PUSH
114990: LD_INT 101
114992: PUSH
114993: LD_INT 102
114995: PUSH
114996: LD_INT 103
114998: PUSH
114999: LD_INT 106
115001: PUSH
115002: LD_INT 108
115004: PUSH
115005: LD_INT 112
115007: PUSH
115008: LD_INT 113
115010: PUSH
115011: LD_INT 114
115013: PUSH
115014: LD_INT 115
115016: PUSH
115017: LD_INT 116
115019: PUSH
115020: LD_INT 117
115022: PUSH
115023: LD_INT 118
115025: PUSH
115026: EMPTY
115027: LIST
115028: LIST
115029: LIST
115030: LIST
115031: LIST
115032: LIST
115033: LIST
115034: LIST
115035: LIST
115036: LIST
115037: LIST
115038: LIST
115039: PUSH
115040: EMPTY
115041: LIST
115042: LIST
115043: ST_TO_ADDR
115044: GO 115287
115046: LD_INT 19
115048: DOUBLE
115049: EQUAL
115050: IFTRUE 115054
115052: GO 115286
115054: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
115055: LD_ADDR_VAR 0 2
115059: PUSH
115060: LD_INT 1
115062: PUSH
115063: LD_INT 2
115065: PUSH
115066: LD_INT 3
115068: PUSH
115069: LD_INT 4
115071: PUSH
115072: LD_INT 5
115074: PUSH
115075: LD_INT 6
115077: PUSH
115078: LD_INT 7
115080: PUSH
115081: LD_INT 8
115083: PUSH
115084: LD_INT 9
115086: PUSH
115087: LD_INT 10
115089: PUSH
115090: LD_INT 11
115092: PUSH
115093: LD_INT 12
115095: PUSH
115096: LD_INT 13
115098: PUSH
115099: LD_INT 14
115101: PUSH
115102: LD_INT 15
115104: PUSH
115105: LD_INT 16
115107: PUSH
115108: LD_INT 17
115110: PUSH
115111: LD_INT 18
115113: PUSH
115114: LD_INT 19
115116: PUSH
115117: LD_INT 20
115119: PUSH
115120: LD_INT 21
115122: PUSH
115123: LD_INT 22
115125: PUSH
115126: LD_INT 23
115128: PUSH
115129: LD_INT 24
115131: PUSH
115132: LD_INT 25
115134: PUSH
115135: LD_INT 26
115137: PUSH
115138: LD_INT 27
115140: PUSH
115141: LD_INT 28
115143: PUSH
115144: LD_INT 29
115146: PUSH
115147: LD_INT 30
115149: PUSH
115150: LD_INT 31
115152: PUSH
115153: LD_INT 32
115155: PUSH
115156: LD_INT 33
115158: PUSH
115159: LD_INT 34
115161: PUSH
115162: LD_INT 35
115164: PUSH
115165: LD_INT 36
115167: PUSH
115168: EMPTY
115169: LIST
115170: LIST
115171: LIST
115172: LIST
115173: LIST
115174: LIST
115175: LIST
115176: LIST
115177: LIST
115178: LIST
115179: LIST
115180: LIST
115181: LIST
115182: LIST
115183: LIST
115184: LIST
115185: LIST
115186: LIST
115187: LIST
115188: LIST
115189: LIST
115190: LIST
115191: LIST
115192: LIST
115193: LIST
115194: LIST
115195: LIST
115196: LIST
115197: LIST
115198: LIST
115199: LIST
115200: LIST
115201: LIST
115202: LIST
115203: LIST
115204: LIST
115205: PUSH
115206: LD_INT 101
115208: PUSH
115209: LD_INT 102
115211: PUSH
115212: LD_INT 103
115214: PUSH
115215: LD_INT 104
115217: PUSH
115218: LD_INT 105
115220: PUSH
115221: LD_INT 106
115223: PUSH
115224: LD_INT 107
115226: PUSH
115227: LD_INT 108
115229: PUSH
115230: LD_INT 109
115232: PUSH
115233: LD_INT 110
115235: PUSH
115236: LD_INT 111
115238: PUSH
115239: LD_INT 112
115241: PUSH
115242: LD_INT 113
115244: PUSH
115245: LD_INT 114
115247: PUSH
115248: LD_INT 115
115250: PUSH
115251: LD_INT 116
115253: PUSH
115254: LD_INT 117
115256: PUSH
115257: LD_INT 118
115259: PUSH
115260: EMPTY
115261: LIST
115262: LIST
115263: LIST
115264: LIST
115265: LIST
115266: LIST
115267: LIST
115268: LIST
115269: LIST
115270: LIST
115271: LIST
115272: LIST
115273: LIST
115274: LIST
115275: LIST
115276: LIST
115277: LIST
115278: LIST
115279: PUSH
115280: EMPTY
115281: LIST
115282: LIST
115283: ST_TO_ADDR
115284: GO 115287
115286: POP
// end else
115287: GO 115518
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
115289: LD_ADDR_VAR 0 2
115293: PUSH
115294: LD_INT 1
115296: PUSH
115297: LD_INT 2
115299: PUSH
115300: LD_INT 3
115302: PUSH
115303: LD_INT 4
115305: PUSH
115306: LD_INT 5
115308: PUSH
115309: LD_INT 6
115311: PUSH
115312: LD_INT 7
115314: PUSH
115315: LD_INT 8
115317: PUSH
115318: LD_INT 9
115320: PUSH
115321: LD_INT 10
115323: PUSH
115324: LD_INT 11
115326: PUSH
115327: LD_INT 12
115329: PUSH
115330: LD_INT 13
115332: PUSH
115333: LD_INT 14
115335: PUSH
115336: LD_INT 15
115338: PUSH
115339: LD_INT 16
115341: PUSH
115342: LD_INT 17
115344: PUSH
115345: LD_INT 18
115347: PUSH
115348: LD_INT 19
115350: PUSH
115351: LD_INT 20
115353: PUSH
115354: LD_INT 21
115356: PUSH
115357: LD_INT 22
115359: PUSH
115360: LD_INT 23
115362: PUSH
115363: LD_INT 24
115365: PUSH
115366: LD_INT 25
115368: PUSH
115369: LD_INT 26
115371: PUSH
115372: LD_INT 27
115374: PUSH
115375: LD_INT 28
115377: PUSH
115378: LD_INT 29
115380: PUSH
115381: LD_INT 30
115383: PUSH
115384: LD_INT 31
115386: PUSH
115387: LD_INT 32
115389: PUSH
115390: LD_INT 33
115392: PUSH
115393: LD_INT 34
115395: PUSH
115396: LD_INT 35
115398: PUSH
115399: LD_INT 36
115401: PUSH
115402: EMPTY
115403: LIST
115404: LIST
115405: LIST
115406: LIST
115407: LIST
115408: LIST
115409: LIST
115410: LIST
115411: LIST
115412: LIST
115413: LIST
115414: LIST
115415: LIST
115416: LIST
115417: LIST
115418: LIST
115419: LIST
115420: LIST
115421: LIST
115422: LIST
115423: LIST
115424: LIST
115425: LIST
115426: LIST
115427: LIST
115428: LIST
115429: LIST
115430: LIST
115431: LIST
115432: LIST
115433: LIST
115434: LIST
115435: LIST
115436: LIST
115437: LIST
115438: LIST
115439: PUSH
115440: LD_INT 101
115442: PUSH
115443: LD_INT 102
115445: PUSH
115446: LD_INT 103
115448: PUSH
115449: LD_INT 104
115451: PUSH
115452: LD_INT 105
115454: PUSH
115455: LD_INT 106
115457: PUSH
115458: LD_INT 107
115460: PUSH
115461: LD_INT 108
115463: PUSH
115464: LD_INT 109
115466: PUSH
115467: LD_INT 110
115469: PUSH
115470: LD_INT 111
115472: PUSH
115473: LD_INT 112
115475: PUSH
115476: LD_INT 113
115478: PUSH
115479: LD_INT 114
115481: PUSH
115482: LD_INT 115
115484: PUSH
115485: LD_INT 116
115487: PUSH
115488: LD_INT 117
115490: PUSH
115491: LD_INT 118
115493: PUSH
115494: EMPTY
115495: LIST
115496: LIST
115497: LIST
115498: LIST
115499: LIST
115500: LIST
115501: LIST
115502: LIST
115503: LIST
115504: LIST
115505: LIST
115506: LIST
115507: LIST
115508: LIST
115509: LIST
115510: LIST
115511: LIST
115512: LIST
115513: PUSH
115514: EMPTY
115515: LIST
115516: LIST
115517: ST_TO_ADDR
// if result then
115518: LD_VAR 0 2
115522: IFFALSE 116308
// begin normal :=  ;
115524: LD_ADDR_VAR 0 5
115528: PUSH
115529: LD_STRING 
115531: ST_TO_ADDR
// hardcore :=  ;
115532: LD_ADDR_VAR 0 6
115536: PUSH
115537: LD_STRING 
115539: ST_TO_ADDR
// active :=  ;
115540: LD_ADDR_VAR 0 7
115544: PUSH
115545: LD_STRING 
115547: ST_TO_ADDR
// for i = 1 to normalCounter do
115548: LD_ADDR_VAR 0 8
115552: PUSH
115553: DOUBLE
115554: LD_INT 1
115556: DEC
115557: ST_TO_ADDR
115558: LD_EXP 147
115562: PUSH
115563: FOR_TO
115564: IFFALSE 115665
// begin tmp := 0 ;
115566: LD_ADDR_VAR 0 3
115570: PUSH
115571: LD_STRING 0
115573: ST_TO_ADDR
// if result [ 1 ] then
115574: LD_VAR 0 2
115578: PUSH
115579: LD_INT 1
115581: ARRAY
115582: IFFALSE 115647
// if result [ 1 ] [ 1 ] = i then
115584: LD_VAR 0 2
115588: PUSH
115589: LD_INT 1
115591: ARRAY
115592: PUSH
115593: LD_INT 1
115595: ARRAY
115596: PUSH
115597: LD_VAR 0 8
115601: EQUAL
115602: IFFALSE 115647
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
115604: LD_ADDR_VAR 0 2
115608: PUSH
115609: LD_VAR 0 2
115613: PPUSH
115614: LD_INT 1
115616: PPUSH
115617: LD_VAR 0 2
115621: PUSH
115622: LD_INT 1
115624: ARRAY
115625: PPUSH
115626: LD_INT 1
115628: PPUSH
115629: CALL_OW 3
115633: PPUSH
115634: CALL_OW 1
115638: ST_TO_ADDR
// tmp := 1 ;
115639: LD_ADDR_VAR 0 3
115643: PUSH
115644: LD_STRING 1
115646: ST_TO_ADDR
// end ; normal := normal & tmp ;
115647: LD_ADDR_VAR 0 5
115651: PUSH
115652: LD_VAR 0 5
115656: PUSH
115657: LD_VAR 0 3
115661: STR
115662: ST_TO_ADDR
// end ;
115663: GO 115563
115665: POP
115666: POP
// for i = 1 to hardcoreCounter do
115667: LD_ADDR_VAR 0 8
115671: PUSH
115672: DOUBLE
115673: LD_INT 1
115675: DEC
115676: ST_TO_ADDR
115677: LD_EXP 148
115681: PUSH
115682: FOR_TO
115683: IFFALSE 115788
// begin tmp := 0 ;
115685: LD_ADDR_VAR 0 3
115689: PUSH
115690: LD_STRING 0
115692: ST_TO_ADDR
// if result [ 2 ] then
115693: LD_VAR 0 2
115697: PUSH
115698: LD_INT 2
115700: ARRAY
115701: IFFALSE 115770
// if result [ 2 ] [ 1 ] = 100 + i then
115703: LD_VAR 0 2
115707: PUSH
115708: LD_INT 2
115710: ARRAY
115711: PUSH
115712: LD_INT 1
115714: ARRAY
115715: PUSH
115716: LD_INT 100
115718: PUSH
115719: LD_VAR 0 8
115723: PLUS
115724: EQUAL
115725: IFFALSE 115770
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
115727: LD_ADDR_VAR 0 2
115731: PUSH
115732: LD_VAR 0 2
115736: PPUSH
115737: LD_INT 2
115739: PPUSH
115740: LD_VAR 0 2
115744: PUSH
115745: LD_INT 2
115747: ARRAY
115748: PPUSH
115749: LD_INT 1
115751: PPUSH
115752: CALL_OW 3
115756: PPUSH
115757: CALL_OW 1
115761: ST_TO_ADDR
// tmp := 1 ;
115762: LD_ADDR_VAR 0 3
115766: PUSH
115767: LD_STRING 1
115769: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
115770: LD_ADDR_VAR 0 6
115774: PUSH
115775: LD_VAR 0 6
115779: PUSH
115780: LD_VAR 0 3
115784: STR
115785: ST_TO_ADDR
// end ;
115786: GO 115682
115788: POP
115789: POP
// if isGameLoad then
115790: LD_VAR 0 1
115794: IFFALSE 116269
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
115796: LD_ADDR_VAR 0 4
115800: PUSH
115801: LD_EXP 151
115805: PUSH
115806: LD_EXP 150
115810: PUSH
115811: LD_EXP 152
115815: PUSH
115816: LD_EXP 149
115820: PUSH
115821: LD_EXP 153
115825: PUSH
115826: LD_EXP 154
115830: PUSH
115831: LD_EXP 155
115835: PUSH
115836: LD_EXP 156
115840: PUSH
115841: LD_EXP 157
115845: PUSH
115846: LD_EXP 158
115850: PUSH
115851: LD_EXP 159
115855: PUSH
115856: LD_EXP 160
115860: PUSH
115861: LD_EXP 161
115865: PUSH
115866: LD_EXP 162
115870: PUSH
115871: LD_EXP 170
115875: PUSH
115876: LD_EXP 171
115880: PUSH
115881: LD_EXP 172
115885: PUSH
115886: LD_EXP 173
115890: PUSH
115891: LD_EXP 175
115895: PUSH
115896: LD_EXP 176
115900: PUSH
115901: LD_EXP 177
115905: PUSH
115906: LD_EXP 180
115910: PUSH
115911: LD_EXP 182
115915: PUSH
115916: LD_EXP 183
115920: PUSH
115921: LD_EXP 184
115925: PUSH
115926: LD_EXP 186
115930: PUSH
115931: LD_EXP 187
115935: PUSH
115936: LD_EXP 190
115940: PUSH
115941: LD_EXP 191
115945: PUSH
115946: LD_EXP 192
115950: PUSH
115951: LD_EXP 193
115955: PUSH
115956: LD_EXP 194
115960: PUSH
115961: LD_EXP 195
115965: PUSH
115966: LD_EXP 196
115970: PUSH
115971: LD_EXP 197
115975: PUSH
115976: LD_EXP 198
115980: PUSH
115981: LD_EXP 163
115985: PUSH
115986: LD_EXP 164
115990: PUSH
115991: LD_EXP 167
115995: PUSH
115996: LD_EXP 168
116000: PUSH
116001: LD_EXP 169
116005: PUSH
116006: LD_EXP 165
116010: PUSH
116011: LD_EXP 166
116015: PUSH
116016: LD_EXP 174
116020: PUSH
116021: LD_EXP 178
116025: PUSH
116026: LD_EXP 179
116030: PUSH
116031: LD_EXP 181
116035: PUSH
116036: LD_EXP 185
116040: PUSH
116041: LD_EXP 188
116045: PUSH
116046: LD_EXP 189
116050: PUSH
116051: LD_EXP 199
116055: PUSH
116056: LD_EXP 200
116060: PUSH
116061: LD_EXP 201
116065: PUSH
116066: LD_EXP 202
116070: PUSH
116071: EMPTY
116072: LIST
116073: LIST
116074: LIST
116075: LIST
116076: LIST
116077: LIST
116078: LIST
116079: LIST
116080: LIST
116081: LIST
116082: LIST
116083: LIST
116084: LIST
116085: LIST
116086: LIST
116087: LIST
116088: LIST
116089: LIST
116090: LIST
116091: LIST
116092: LIST
116093: LIST
116094: LIST
116095: LIST
116096: LIST
116097: LIST
116098: LIST
116099: LIST
116100: LIST
116101: LIST
116102: LIST
116103: LIST
116104: LIST
116105: LIST
116106: LIST
116107: LIST
116108: LIST
116109: LIST
116110: LIST
116111: LIST
116112: LIST
116113: LIST
116114: LIST
116115: LIST
116116: LIST
116117: LIST
116118: LIST
116119: LIST
116120: LIST
116121: LIST
116122: LIST
116123: LIST
116124: LIST
116125: LIST
116126: ST_TO_ADDR
// tmp :=  ;
116127: LD_ADDR_VAR 0 3
116131: PUSH
116132: LD_STRING 
116134: ST_TO_ADDR
// for i = 1 to normalCounter do
116135: LD_ADDR_VAR 0 8
116139: PUSH
116140: DOUBLE
116141: LD_INT 1
116143: DEC
116144: ST_TO_ADDR
116145: LD_EXP 147
116149: PUSH
116150: FOR_TO
116151: IFFALSE 116187
// begin if flags [ i ] then
116153: LD_VAR 0 4
116157: PUSH
116158: LD_VAR 0 8
116162: ARRAY
116163: IFFALSE 116185
// tmp := tmp & i & ; ;
116165: LD_ADDR_VAR 0 3
116169: PUSH
116170: LD_VAR 0 3
116174: PUSH
116175: LD_VAR 0 8
116179: STR
116180: PUSH
116181: LD_STRING ;
116183: STR
116184: ST_TO_ADDR
// end ;
116185: GO 116150
116187: POP
116188: POP
// for i = 1 to hardcoreCounter do
116189: LD_ADDR_VAR 0 8
116193: PUSH
116194: DOUBLE
116195: LD_INT 1
116197: DEC
116198: ST_TO_ADDR
116199: LD_EXP 148
116203: PUSH
116204: FOR_TO
116205: IFFALSE 116251
// begin if flags [ normalCounter + i ] then
116207: LD_VAR 0 4
116211: PUSH
116212: LD_EXP 147
116216: PUSH
116217: LD_VAR 0 8
116221: PLUS
116222: ARRAY
116223: IFFALSE 116249
// tmp := tmp & ( 100 + i ) & ; ;
116225: LD_ADDR_VAR 0 3
116229: PUSH
116230: LD_VAR 0 3
116234: PUSH
116235: LD_INT 100
116237: PUSH
116238: LD_VAR 0 8
116242: PLUS
116243: STR
116244: PUSH
116245: LD_STRING ;
116247: STR
116248: ST_TO_ADDR
// end ;
116249: GO 116204
116251: POP
116252: POP
// if tmp then
116253: LD_VAR 0 3
116257: IFFALSE 116269
// active := tmp ;
116259: LD_ADDR_VAR 0 7
116263: PUSH
116264: LD_VAR 0 3
116268: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
116269: LD_STRING getStreamItemsFromMission("
116271: PUSH
116272: LD_VAR 0 5
116276: STR
116277: PUSH
116278: LD_STRING ","
116280: STR
116281: PUSH
116282: LD_VAR 0 6
116286: STR
116287: PUSH
116288: LD_STRING ","
116290: STR
116291: PUSH
116292: LD_VAR 0 7
116296: STR
116297: PUSH
116298: LD_STRING ")
116300: STR
116301: PPUSH
116302: CALL_OW 559
// end else
116306: GO 116315
// ToLua ( getStreamItemsFromMission("","","") ) ;
116308: LD_STRING getStreamItemsFromMission("","","")
116310: PPUSH
116311: CALL_OW 559
// end ;
116315: LD_VAR 0 2
116319: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
116320: LD_EXP 146
116324: PUSH
116325: LD_EXP 151
116329: AND
116330: IFFALSE 116454
116332: GO 116334
116334: DISABLE
116335: LD_INT 0
116337: PPUSH
116338: PPUSH
// begin enable ;
116339: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
116340: LD_ADDR_VAR 0 2
116344: PUSH
116345: LD_INT 22
116347: PUSH
116348: LD_OWVAR 2
116352: PUSH
116353: EMPTY
116354: LIST
116355: LIST
116356: PUSH
116357: LD_INT 2
116359: PUSH
116360: LD_INT 34
116362: PUSH
116363: LD_INT 7
116365: PUSH
116366: EMPTY
116367: LIST
116368: LIST
116369: PUSH
116370: LD_INT 34
116372: PUSH
116373: LD_INT 45
116375: PUSH
116376: EMPTY
116377: LIST
116378: LIST
116379: PUSH
116380: LD_INT 34
116382: PUSH
116383: LD_INT 28
116385: PUSH
116386: EMPTY
116387: LIST
116388: LIST
116389: PUSH
116390: LD_INT 34
116392: PUSH
116393: LD_INT 47
116395: PUSH
116396: EMPTY
116397: LIST
116398: LIST
116399: PUSH
116400: EMPTY
116401: LIST
116402: LIST
116403: LIST
116404: LIST
116405: LIST
116406: PUSH
116407: EMPTY
116408: LIST
116409: LIST
116410: PPUSH
116411: CALL_OW 69
116415: ST_TO_ADDR
// if not tmp then
116416: LD_VAR 0 2
116420: NOT
116421: IFFALSE 116425
// exit ;
116423: GO 116454
// for i in tmp do
116425: LD_ADDR_VAR 0 1
116429: PUSH
116430: LD_VAR 0 2
116434: PUSH
116435: FOR_IN
116436: IFFALSE 116452
// begin SetLives ( i , 0 ) ;
116438: LD_VAR 0 1
116442: PPUSH
116443: LD_INT 0
116445: PPUSH
116446: CALL_OW 234
// end ;
116450: GO 116435
116452: POP
116453: POP
// end ;
116454: PPOPN 2
116456: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
116457: LD_EXP 146
116461: PUSH
116462: LD_EXP 152
116466: AND
116467: IFFALSE 116551
116469: GO 116471
116471: DISABLE
116472: LD_INT 0
116474: PPUSH
116475: PPUSH
// begin enable ;
116476: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
116477: LD_ADDR_VAR 0 2
116481: PUSH
116482: LD_INT 22
116484: PUSH
116485: LD_OWVAR 2
116489: PUSH
116490: EMPTY
116491: LIST
116492: LIST
116493: PUSH
116494: LD_INT 32
116496: PUSH
116497: LD_INT 3
116499: PUSH
116500: EMPTY
116501: LIST
116502: LIST
116503: PUSH
116504: EMPTY
116505: LIST
116506: LIST
116507: PPUSH
116508: CALL_OW 69
116512: ST_TO_ADDR
// if not tmp then
116513: LD_VAR 0 2
116517: NOT
116518: IFFALSE 116522
// exit ;
116520: GO 116551
// for i in tmp do
116522: LD_ADDR_VAR 0 1
116526: PUSH
116527: LD_VAR 0 2
116531: PUSH
116532: FOR_IN
116533: IFFALSE 116549
// begin SetLives ( i , 0 ) ;
116535: LD_VAR 0 1
116539: PPUSH
116540: LD_INT 0
116542: PPUSH
116543: CALL_OW 234
// end ;
116547: GO 116532
116549: POP
116550: POP
// end ;
116551: PPOPN 2
116553: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
116554: LD_EXP 146
116558: PUSH
116559: LD_EXP 149
116563: AND
116564: IFFALSE 116657
116566: GO 116568
116568: DISABLE
116569: LD_INT 0
116571: PPUSH
// begin enable ;
116572: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
116573: LD_ADDR_VAR 0 1
116577: PUSH
116578: LD_INT 22
116580: PUSH
116581: LD_OWVAR 2
116585: PUSH
116586: EMPTY
116587: LIST
116588: LIST
116589: PUSH
116590: LD_INT 2
116592: PUSH
116593: LD_INT 25
116595: PUSH
116596: LD_INT 5
116598: PUSH
116599: EMPTY
116600: LIST
116601: LIST
116602: PUSH
116603: LD_INT 25
116605: PUSH
116606: LD_INT 9
116608: PUSH
116609: EMPTY
116610: LIST
116611: LIST
116612: PUSH
116613: LD_INT 25
116615: PUSH
116616: LD_INT 8
116618: PUSH
116619: EMPTY
116620: LIST
116621: LIST
116622: PUSH
116623: EMPTY
116624: LIST
116625: LIST
116626: LIST
116627: LIST
116628: PUSH
116629: EMPTY
116630: LIST
116631: LIST
116632: PPUSH
116633: CALL_OW 69
116637: PUSH
116638: FOR_IN
116639: IFFALSE 116655
// begin SetClass ( i , 1 ) ;
116641: LD_VAR 0 1
116645: PPUSH
116646: LD_INT 1
116648: PPUSH
116649: CALL_OW 336
// end ;
116653: GO 116638
116655: POP
116656: POP
// end ;
116657: PPOPN 1
116659: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
116660: LD_EXP 146
116664: PUSH
116665: LD_EXP 150
116669: AND
116670: PUSH
116671: LD_OWVAR 65
116675: PUSH
116676: LD_INT 7
116678: LESS
116679: AND
116680: IFFALSE 116694
116682: GO 116684
116684: DISABLE
// begin enable ;
116685: ENABLE
// game_speed := 7 ;
116686: LD_ADDR_OWVAR 65
116690: PUSH
116691: LD_INT 7
116693: ST_TO_ADDR
// end ;
116694: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
116695: LD_EXP 146
116699: PUSH
116700: LD_EXP 153
116704: AND
116705: IFFALSE 116907
116707: GO 116709
116709: DISABLE
116710: LD_INT 0
116712: PPUSH
116713: PPUSH
116714: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
116715: LD_ADDR_VAR 0 3
116719: PUSH
116720: LD_INT 81
116722: PUSH
116723: LD_OWVAR 2
116727: PUSH
116728: EMPTY
116729: LIST
116730: LIST
116731: PUSH
116732: LD_INT 21
116734: PUSH
116735: LD_INT 1
116737: PUSH
116738: EMPTY
116739: LIST
116740: LIST
116741: PUSH
116742: EMPTY
116743: LIST
116744: LIST
116745: PPUSH
116746: CALL_OW 69
116750: ST_TO_ADDR
// if not tmp then
116751: LD_VAR 0 3
116755: NOT
116756: IFFALSE 116760
// exit ;
116758: GO 116907
// if tmp > 5 then
116760: LD_VAR 0 3
116764: PUSH
116765: LD_INT 5
116767: GREATER
116768: IFFALSE 116780
// k := 5 else
116770: LD_ADDR_VAR 0 2
116774: PUSH
116775: LD_INT 5
116777: ST_TO_ADDR
116778: GO 116790
// k := tmp ;
116780: LD_ADDR_VAR 0 2
116784: PUSH
116785: LD_VAR 0 3
116789: ST_TO_ADDR
// for i := 1 to k do
116790: LD_ADDR_VAR 0 1
116794: PUSH
116795: DOUBLE
116796: LD_INT 1
116798: DEC
116799: ST_TO_ADDR
116800: LD_VAR 0 2
116804: PUSH
116805: FOR_TO
116806: IFFALSE 116905
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
116808: LD_VAR 0 3
116812: PUSH
116813: LD_VAR 0 1
116817: ARRAY
116818: PPUSH
116819: LD_VAR 0 1
116823: PUSH
116824: LD_INT 4
116826: MOD
116827: PUSH
116828: LD_INT 1
116830: PLUS
116831: PPUSH
116832: CALL_OW 259
116836: PUSH
116837: LD_INT 10
116839: LESS
116840: IFFALSE 116903
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
116842: LD_VAR 0 3
116846: PUSH
116847: LD_VAR 0 1
116851: ARRAY
116852: PPUSH
116853: LD_VAR 0 1
116857: PUSH
116858: LD_INT 4
116860: MOD
116861: PUSH
116862: LD_INT 1
116864: PLUS
116865: PPUSH
116866: LD_VAR 0 3
116870: PUSH
116871: LD_VAR 0 1
116875: ARRAY
116876: PPUSH
116877: LD_VAR 0 1
116881: PUSH
116882: LD_INT 4
116884: MOD
116885: PUSH
116886: LD_INT 1
116888: PLUS
116889: PPUSH
116890: CALL_OW 259
116894: PUSH
116895: LD_INT 1
116897: PLUS
116898: PPUSH
116899: CALL_OW 237
116903: GO 116805
116905: POP
116906: POP
// end ;
116907: PPOPN 3
116909: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
116910: LD_EXP 146
116914: PUSH
116915: LD_EXP 154
116919: AND
116920: IFFALSE 116940
116922: GO 116924
116924: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
116925: LD_INT 4
116927: PPUSH
116928: LD_OWVAR 2
116932: PPUSH
116933: LD_INT 0
116935: PPUSH
116936: CALL_OW 324
116940: END
// every 0 0$1 trigger StreamModeActive and sShovel do
116941: LD_EXP 146
116945: PUSH
116946: LD_EXP 183
116950: AND
116951: IFFALSE 116971
116953: GO 116955
116955: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
116956: LD_INT 19
116958: PPUSH
116959: LD_OWVAR 2
116963: PPUSH
116964: LD_INT 0
116966: PPUSH
116967: CALL_OW 324
116971: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
116972: LD_EXP 146
116976: PUSH
116977: LD_EXP 155
116981: AND
116982: IFFALSE 117084
116984: GO 116986
116986: DISABLE
116987: LD_INT 0
116989: PPUSH
116990: PPUSH
// begin enable ;
116991: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
116992: LD_ADDR_VAR 0 2
116996: PUSH
116997: LD_INT 22
116999: PUSH
117000: LD_OWVAR 2
117004: PUSH
117005: EMPTY
117006: LIST
117007: LIST
117008: PUSH
117009: LD_INT 2
117011: PUSH
117012: LD_INT 34
117014: PUSH
117015: LD_INT 11
117017: PUSH
117018: EMPTY
117019: LIST
117020: LIST
117021: PUSH
117022: LD_INT 34
117024: PUSH
117025: LD_INT 30
117027: PUSH
117028: EMPTY
117029: LIST
117030: LIST
117031: PUSH
117032: EMPTY
117033: LIST
117034: LIST
117035: LIST
117036: PUSH
117037: EMPTY
117038: LIST
117039: LIST
117040: PPUSH
117041: CALL_OW 69
117045: ST_TO_ADDR
// if not tmp then
117046: LD_VAR 0 2
117050: NOT
117051: IFFALSE 117055
// exit ;
117053: GO 117084
// for i in tmp do
117055: LD_ADDR_VAR 0 1
117059: PUSH
117060: LD_VAR 0 2
117064: PUSH
117065: FOR_IN
117066: IFFALSE 117082
// begin SetLives ( i , 0 ) ;
117068: LD_VAR 0 1
117072: PPUSH
117073: LD_INT 0
117075: PPUSH
117076: CALL_OW 234
// end ;
117080: GO 117065
117082: POP
117083: POP
// end ;
117084: PPOPN 2
117086: END
// every 0 0$1 trigger StreamModeActive and sBunker do
117087: LD_EXP 146
117091: PUSH
117092: LD_EXP 156
117096: AND
117097: IFFALSE 117117
117099: GO 117101
117101: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
117102: LD_INT 32
117104: PPUSH
117105: LD_OWVAR 2
117109: PPUSH
117110: LD_INT 0
117112: PPUSH
117113: CALL_OW 324
117117: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
117118: LD_EXP 146
117122: PUSH
117123: LD_EXP 157
117127: AND
117128: IFFALSE 117309
117130: GO 117132
117132: DISABLE
117133: LD_INT 0
117135: PPUSH
117136: PPUSH
117137: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
117138: LD_ADDR_VAR 0 2
117142: PUSH
117143: LD_INT 22
117145: PUSH
117146: LD_OWVAR 2
117150: PUSH
117151: EMPTY
117152: LIST
117153: LIST
117154: PUSH
117155: LD_INT 33
117157: PUSH
117158: LD_INT 3
117160: PUSH
117161: EMPTY
117162: LIST
117163: LIST
117164: PUSH
117165: EMPTY
117166: LIST
117167: LIST
117168: PPUSH
117169: CALL_OW 69
117173: ST_TO_ADDR
// if not tmp then
117174: LD_VAR 0 2
117178: NOT
117179: IFFALSE 117183
// exit ;
117181: GO 117309
// side := 0 ;
117183: LD_ADDR_VAR 0 3
117187: PUSH
117188: LD_INT 0
117190: ST_TO_ADDR
// for i := 1 to 8 do
117191: LD_ADDR_VAR 0 1
117195: PUSH
117196: DOUBLE
117197: LD_INT 1
117199: DEC
117200: ST_TO_ADDR
117201: LD_INT 8
117203: PUSH
117204: FOR_TO
117205: IFFALSE 117253
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
117207: LD_OWVAR 2
117211: PUSH
117212: LD_VAR 0 1
117216: NONEQUAL
117217: PUSH
117218: LD_OWVAR 2
117222: PPUSH
117223: LD_VAR 0 1
117227: PPUSH
117228: CALL_OW 81
117232: PUSH
117233: LD_INT 2
117235: EQUAL
117236: AND
117237: IFFALSE 117251
// begin side := i ;
117239: LD_ADDR_VAR 0 3
117243: PUSH
117244: LD_VAR 0 1
117248: ST_TO_ADDR
// break ;
117249: GO 117253
// end ;
117251: GO 117204
117253: POP
117254: POP
// if not side then
117255: LD_VAR 0 3
117259: NOT
117260: IFFALSE 117264
// exit ;
117262: GO 117309
// for i := 1 to tmp do
117264: LD_ADDR_VAR 0 1
117268: PUSH
117269: DOUBLE
117270: LD_INT 1
117272: DEC
117273: ST_TO_ADDR
117274: LD_VAR 0 2
117278: PUSH
117279: FOR_TO
117280: IFFALSE 117307
// if Prob ( 60 ) then
117282: LD_INT 60
117284: PPUSH
117285: CALL_OW 13
117289: IFFALSE 117305
// SetSide ( i , side ) ;
117291: LD_VAR 0 1
117295: PPUSH
117296: LD_VAR 0 3
117300: PPUSH
117301: CALL_OW 235
117305: GO 117279
117307: POP
117308: POP
// end ;
117309: PPOPN 3
117311: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
117312: LD_EXP 146
117316: PUSH
117317: LD_EXP 159
117321: AND
117322: IFFALSE 117441
117324: GO 117326
117326: DISABLE
117327: LD_INT 0
117329: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
117330: LD_ADDR_VAR 0 1
117334: PUSH
117335: LD_INT 22
117337: PUSH
117338: LD_OWVAR 2
117342: PUSH
117343: EMPTY
117344: LIST
117345: LIST
117346: PUSH
117347: LD_INT 21
117349: PUSH
117350: LD_INT 1
117352: PUSH
117353: EMPTY
117354: LIST
117355: LIST
117356: PUSH
117357: LD_INT 3
117359: PUSH
117360: LD_INT 23
117362: PUSH
117363: LD_INT 0
117365: PUSH
117366: EMPTY
117367: LIST
117368: LIST
117369: PUSH
117370: EMPTY
117371: LIST
117372: LIST
117373: PUSH
117374: EMPTY
117375: LIST
117376: LIST
117377: LIST
117378: PPUSH
117379: CALL_OW 69
117383: PUSH
117384: FOR_IN
117385: IFFALSE 117439
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
117387: LD_VAR 0 1
117391: PPUSH
117392: CALL_OW 257
117396: PUSH
117397: LD_INT 1
117399: PUSH
117400: LD_INT 2
117402: PUSH
117403: LD_INT 3
117405: PUSH
117406: LD_INT 4
117408: PUSH
117409: EMPTY
117410: LIST
117411: LIST
117412: LIST
117413: LIST
117414: IN
117415: IFFALSE 117437
// SetClass ( un , rand ( 1 , 4 ) ) ;
117417: LD_VAR 0 1
117421: PPUSH
117422: LD_INT 1
117424: PPUSH
117425: LD_INT 4
117427: PPUSH
117428: CALL_OW 12
117432: PPUSH
117433: CALL_OW 336
117437: GO 117384
117439: POP
117440: POP
// end ;
117441: PPOPN 1
117443: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
117444: LD_EXP 146
117448: PUSH
117449: LD_EXP 158
117453: AND
117454: IFFALSE 117533
117456: GO 117458
117458: DISABLE
117459: LD_INT 0
117461: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
117462: LD_ADDR_VAR 0 1
117466: PUSH
117467: LD_INT 22
117469: PUSH
117470: LD_OWVAR 2
117474: PUSH
117475: EMPTY
117476: LIST
117477: LIST
117478: PUSH
117479: LD_INT 21
117481: PUSH
117482: LD_INT 3
117484: PUSH
117485: EMPTY
117486: LIST
117487: LIST
117488: PUSH
117489: EMPTY
117490: LIST
117491: LIST
117492: PPUSH
117493: CALL_OW 69
117497: ST_TO_ADDR
// if not tmp then
117498: LD_VAR 0 1
117502: NOT
117503: IFFALSE 117507
// exit ;
117505: GO 117533
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
117507: LD_VAR 0 1
117511: PUSH
117512: LD_INT 1
117514: PPUSH
117515: LD_VAR 0 1
117519: PPUSH
117520: CALL_OW 12
117524: ARRAY
117525: PPUSH
117526: LD_INT 100
117528: PPUSH
117529: CALL_OW 234
// end ;
117533: PPOPN 1
117535: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
117536: LD_EXP 146
117540: PUSH
117541: LD_EXP 160
117545: AND
117546: IFFALSE 117644
117548: GO 117550
117550: DISABLE
117551: LD_INT 0
117553: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
117554: LD_ADDR_VAR 0 1
117558: PUSH
117559: LD_INT 22
117561: PUSH
117562: LD_OWVAR 2
117566: PUSH
117567: EMPTY
117568: LIST
117569: LIST
117570: PUSH
117571: LD_INT 21
117573: PUSH
117574: LD_INT 1
117576: PUSH
117577: EMPTY
117578: LIST
117579: LIST
117580: PUSH
117581: EMPTY
117582: LIST
117583: LIST
117584: PPUSH
117585: CALL_OW 69
117589: ST_TO_ADDR
// if not tmp then
117590: LD_VAR 0 1
117594: NOT
117595: IFFALSE 117599
// exit ;
117597: GO 117644
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
117599: LD_VAR 0 1
117603: PUSH
117604: LD_INT 1
117606: PPUSH
117607: LD_VAR 0 1
117611: PPUSH
117612: CALL_OW 12
117616: ARRAY
117617: PPUSH
117618: LD_INT 1
117620: PPUSH
117621: LD_INT 4
117623: PPUSH
117624: CALL_OW 12
117628: PPUSH
117629: LD_INT 3000
117631: PPUSH
117632: LD_INT 9000
117634: PPUSH
117635: CALL_OW 12
117639: PPUSH
117640: CALL_OW 492
// end ;
117644: PPOPN 1
117646: END
// every 0 0$1 trigger StreamModeActive and sDepot do
117647: LD_EXP 146
117651: PUSH
117652: LD_EXP 161
117656: AND
117657: IFFALSE 117677
117659: GO 117661
117661: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
117662: LD_INT 1
117664: PPUSH
117665: LD_OWVAR 2
117669: PPUSH
117670: LD_INT 0
117672: PPUSH
117673: CALL_OW 324
117677: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
117678: LD_EXP 146
117682: PUSH
117683: LD_EXP 162
117687: AND
117688: IFFALSE 117771
117690: GO 117692
117692: DISABLE
117693: LD_INT 0
117695: PPUSH
117696: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
117697: LD_ADDR_VAR 0 2
117701: PUSH
117702: LD_INT 22
117704: PUSH
117705: LD_OWVAR 2
117709: PUSH
117710: EMPTY
117711: LIST
117712: LIST
117713: PUSH
117714: LD_INT 21
117716: PUSH
117717: LD_INT 3
117719: PUSH
117720: EMPTY
117721: LIST
117722: LIST
117723: PUSH
117724: EMPTY
117725: LIST
117726: LIST
117727: PPUSH
117728: CALL_OW 69
117732: ST_TO_ADDR
// if not tmp then
117733: LD_VAR 0 2
117737: NOT
117738: IFFALSE 117742
// exit ;
117740: GO 117771
// for i in tmp do
117742: LD_ADDR_VAR 0 1
117746: PUSH
117747: LD_VAR 0 2
117751: PUSH
117752: FOR_IN
117753: IFFALSE 117769
// SetBLevel ( i , 10 ) ;
117755: LD_VAR 0 1
117759: PPUSH
117760: LD_INT 10
117762: PPUSH
117763: CALL_OW 241
117767: GO 117752
117769: POP
117770: POP
// end ;
117771: PPOPN 2
117773: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
117774: LD_EXP 146
117778: PUSH
117779: LD_EXP 163
117783: AND
117784: IFFALSE 117895
117786: GO 117788
117788: DISABLE
117789: LD_INT 0
117791: PPUSH
117792: PPUSH
117793: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117794: LD_ADDR_VAR 0 3
117798: PUSH
117799: LD_INT 22
117801: PUSH
117802: LD_OWVAR 2
117806: PUSH
117807: EMPTY
117808: LIST
117809: LIST
117810: PUSH
117811: LD_INT 25
117813: PUSH
117814: LD_INT 1
117816: PUSH
117817: EMPTY
117818: LIST
117819: LIST
117820: PUSH
117821: EMPTY
117822: LIST
117823: LIST
117824: PPUSH
117825: CALL_OW 69
117829: ST_TO_ADDR
// if not tmp then
117830: LD_VAR 0 3
117834: NOT
117835: IFFALSE 117839
// exit ;
117837: GO 117895
// un := tmp [ rand ( 1 , tmp ) ] ;
117839: LD_ADDR_VAR 0 2
117843: PUSH
117844: LD_VAR 0 3
117848: PUSH
117849: LD_INT 1
117851: PPUSH
117852: LD_VAR 0 3
117856: PPUSH
117857: CALL_OW 12
117861: ARRAY
117862: ST_TO_ADDR
// if Crawls ( un ) then
117863: LD_VAR 0 2
117867: PPUSH
117868: CALL_OW 318
117872: IFFALSE 117883
// ComWalk ( un ) ;
117874: LD_VAR 0 2
117878: PPUSH
117879: CALL_OW 138
// SetClass ( un , class_sniper ) ;
117883: LD_VAR 0 2
117887: PPUSH
117888: LD_INT 5
117890: PPUSH
117891: CALL_OW 336
// end ;
117895: PPOPN 3
117897: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
117898: LD_EXP 146
117902: PUSH
117903: LD_EXP 164
117907: AND
117908: PUSH
117909: LD_OWVAR 67
117913: PUSH
117914: LD_INT 4
117916: LESS
117917: AND
117918: IFFALSE 117937
117920: GO 117922
117922: DISABLE
// begin Difficulty := Difficulty + 1 ;
117923: LD_ADDR_OWVAR 67
117927: PUSH
117928: LD_OWVAR 67
117932: PUSH
117933: LD_INT 1
117935: PLUS
117936: ST_TO_ADDR
// end ;
117937: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
117938: LD_EXP 146
117942: PUSH
117943: LD_EXP 165
117947: AND
117948: IFFALSE 118051
117950: GO 117952
117952: DISABLE
117953: LD_INT 0
117955: PPUSH
// begin for i := 1 to 5 do
117956: LD_ADDR_VAR 0 1
117960: PUSH
117961: DOUBLE
117962: LD_INT 1
117964: DEC
117965: ST_TO_ADDR
117966: LD_INT 5
117968: PUSH
117969: FOR_TO
117970: IFFALSE 118049
// begin uc_nation := nation_nature ;
117972: LD_ADDR_OWVAR 21
117976: PUSH
117977: LD_INT 0
117979: ST_TO_ADDR
// uc_side := 0 ;
117980: LD_ADDR_OWVAR 20
117984: PUSH
117985: LD_INT 0
117987: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
117988: LD_ADDR_OWVAR 29
117992: PUSH
117993: LD_INT 12
117995: PUSH
117996: LD_INT 12
117998: PUSH
117999: EMPTY
118000: LIST
118001: LIST
118002: ST_TO_ADDR
// hc_agressivity := 20 ;
118003: LD_ADDR_OWVAR 35
118007: PUSH
118008: LD_INT 20
118010: ST_TO_ADDR
// hc_class := class_tiger ;
118011: LD_ADDR_OWVAR 28
118015: PUSH
118016: LD_INT 14
118018: ST_TO_ADDR
// hc_gallery :=  ;
118019: LD_ADDR_OWVAR 33
118023: PUSH
118024: LD_STRING 
118026: ST_TO_ADDR
// hc_name :=  ;
118027: LD_ADDR_OWVAR 26
118031: PUSH
118032: LD_STRING 
118034: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
118035: CALL_OW 44
118039: PPUSH
118040: LD_INT 0
118042: PPUSH
118043: CALL_OW 51
// end ;
118047: GO 117969
118049: POP
118050: POP
// end ;
118051: PPOPN 1
118053: END
// every 0 0$1 trigger StreamModeActive and sBomb do
118054: LD_EXP 146
118058: PUSH
118059: LD_EXP 166
118063: AND
118064: IFFALSE 118073
118066: GO 118068
118068: DISABLE
// StreamSibBomb ;
118069: CALL 118074 0 0
118073: END
// export function StreamSibBomb ; var i , x , y ; begin
118074: LD_INT 0
118076: PPUSH
118077: PPUSH
118078: PPUSH
118079: PPUSH
// result := false ;
118080: LD_ADDR_VAR 0 1
118084: PUSH
118085: LD_INT 0
118087: ST_TO_ADDR
// for i := 1 to 16 do
118088: LD_ADDR_VAR 0 2
118092: PUSH
118093: DOUBLE
118094: LD_INT 1
118096: DEC
118097: ST_TO_ADDR
118098: LD_INT 16
118100: PUSH
118101: FOR_TO
118102: IFFALSE 118301
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
118104: LD_ADDR_VAR 0 3
118108: PUSH
118109: LD_INT 10
118111: PUSH
118112: LD_INT 20
118114: PUSH
118115: LD_INT 30
118117: PUSH
118118: LD_INT 40
118120: PUSH
118121: LD_INT 50
118123: PUSH
118124: LD_INT 60
118126: PUSH
118127: LD_INT 70
118129: PUSH
118130: LD_INT 80
118132: PUSH
118133: LD_INT 90
118135: PUSH
118136: LD_INT 100
118138: PUSH
118139: LD_INT 110
118141: PUSH
118142: LD_INT 120
118144: PUSH
118145: LD_INT 130
118147: PUSH
118148: LD_INT 140
118150: PUSH
118151: LD_INT 150
118153: PUSH
118154: EMPTY
118155: LIST
118156: LIST
118157: LIST
118158: LIST
118159: LIST
118160: LIST
118161: LIST
118162: LIST
118163: LIST
118164: LIST
118165: LIST
118166: LIST
118167: LIST
118168: LIST
118169: LIST
118170: PUSH
118171: LD_INT 1
118173: PPUSH
118174: LD_INT 15
118176: PPUSH
118177: CALL_OW 12
118181: ARRAY
118182: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
118183: LD_ADDR_VAR 0 4
118187: PUSH
118188: LD_INT 10
118190: PUSH
118191: LD_INT 20
118193: PUSH
118194: LD_INT 30
118196: PUSH
118197: LD_INT 40
118199: PUSH
118200: LD_INT 50
118202: PUSH
118203: LD_INT 60
118205: PUSH
118206: LD_INT 70
118208: PUSH
118209: LD_INT 80
118211: PUSH
118212: LD_INT 90
118214: PUSH
118215: LD_INT 100
118217: PUSH
118218: LD_INT 110
118220: PUSH
118221: LD_INT 120
118223: PUSH
118224: LD_INT 130
118226: PUSH
118227: LD_INT 140
118229: PUSH
118230: LD_INT 150
118232: PUSH
118233: EMPTY
118234: LIST
118235: LIST
118236: LIST
118237: LIST
118238: LIST
118239: LIST
118240: LIST
118241: LIST
118242: LIST
118243: LIST
118244: LIST
118245: LIST
118246: LIST
118247: LIST
118248: LIST
118249: PUSH
118250: LD_INT 1
118252: PPUSH
118253: LD_INT 15
118255: PPUSH
118256: CALL_OW 12
118260: ARRAY
118261: ST_TO_ADDR
// if ValidHex ( x , y ) then
118262: LD_VAR 0 3
118266: PPUSH
118267: LD_VAR 0 4
118271: PPUSH
118272: CALL_OW 488
118276: IFFALSE 118299
// begin result := [ x , y ] ;
118278: LD_ADDR_VAR 0 1
118282: PUSH
118283: LD_VAR 0 3
118287: PUSH
118288: LD_VAR 0 4
118292: PUSH
118293: EMPTY
118294: LIST
118295: LIST
118296: ST_TO_ADDR
// break ;
118297: GO 118301
// end ; end ;
118299: GO 118101
118301: POP
118302: POP
// if result then
118303: LD_VAR 0 1
118307: IFFALSE 118367
// begin ToLua ( playSibBomb() ) ;
118309: LD_STRING playSibBomb()
118311: PPUSH
118312: CALL_OW 559
// wait ( 0 0$14 ) ;
118316: LD_INT 490
118318: PPUSH
118319: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
118323: LD_VAR 0 1
118327: PUSH
118328: LD_INT 1
118330: ARRAY
118331: PPUSH
118332: LD_VAR 0 1
118336: PUSH
118337: LD_INT 2
118339: ARRAY
118340: PPUSH
118341: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
118345: LD_VAR 0 1
118349: PUSH
118350: LD_INT 1
118352: ARRAY
118353: PPUSH
118354: LD_VAR 0 1
118358: PUSH
118359: LD_INT 2
118361: ARRAY
118362: PPUSH
118363: CALL_OW 429
// end ; end ;
118367: LD_VAR 0 1
118371: RET
// every 0 0$1 trigger StreamModeActive and sReset do
118372: LD_EXP 146
118376: PUSH
118377: LD_EXP 168
118381: AND
118382: IFFALSE 118394
118384: GO 118386
118386: DISABLE
// YouLost (  ) ;
118387: LD_STRING 
118389: PPUSH
118390: CALL_OW 104
118394: END
// every 0 0$1 trigger StreamModeActive and sFog do
118395: LD_EXP 146
118399: PUSH
118400: LD_EXP 167
118404: AND
118405: IFFALSE 118419
118407: GO 118409
118409: DISABLE
// FogOff ( your_side ) ;
118410: LD_OWVAR 2
118414: PPUSH
118415: CALL_OW 344
118419: END
// every 0 0$1 trigger StreamModeActive and sSun do
118420: LD_EXP 146
118424: PUSH
118425: LD_EXP 169
118429: AND
118430: IFFALSE 118458
118432: GO 118434
118434: DISABLE
// begin solar_recharge_percent := 0 ;
118435: LD_ADDR_OWVAR 79
118439: PUSH
118440: LD_INT 0
118442: ST_TO_ADDR
// wait ( 5 5$00 ) ;
118443: LD_INT 10500
118445: PPUSH
118446: CALL_OW 67
// solar_recharge_percent := 100 ;
118450: LD_ADDR_OWVAR 79
118454: PUSH
118455: LD_INT 100
118457: ST_TO_ADDR
// end ;
118458: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
118459: LD_EXP 146
118463: PUSH
118464: LD_EXP 170
118468: AND
118469: IFFALSE 118708
118471: GO 118473
118473: DISABLE
118474: LD_INT 0
118476: PPUSH
118477: PPUSH
118478: PPUSH
// begin tmp := [ ] ;
118479: LD_ADDR_VAR 0 3
118483: PUSH
118484: EMPTY
118485: ST_TO_ADDR
// for i := 1 to 6 do
118486: LD_ADDR_VAR 0 1
118490: PUSH
118491: DOUBLE
118492: LD_INT 1
118494: DEC
118495: ST_TO_ADDR
118496: LD_INT 6
118498: PUSH
118499: FOR_TO
118500: IFFALSE 118605
// begin uc_nation := nation_nature ;
118502: LD_ADDR_OWVAR 21
118506: PUSH
118507: LD_INT 0
118509: ST_TO_ADDR
// uc_side := 0 ;
118510: LD_ADDR_OWVAR 20
118514: PUSH
118515: LD_INT 0
118517: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
118518: LD_ADDR_OWVAR 29
118522: PUSH
118523: LD_INT 12
118525: PUSH
118526: LD_INT 12
118528: PUSH
118529: EMPTY
118530: LIST
118531: LIST
118532: ST_TO_ADDR
// hc_agressivity := 20 ;
118533: LD_ADDR_OWVAR 35
118537: PUSH
118538: LD_INT 20
118540: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
118541: LD_ADDR_OWVAR 28
118545: PUSH
118546: LD_INT 17
118548: ST_TO_ADDR
// hc_gallery :=  ;
118549: LD_ADDR_OWVAR 33
118553: PUSH
118554: LD_STRING 
118556: ST_TO_ADDR
// hc_name :=  ;
118557: LD_ADDR_OWVAR 26
118561: PUSH
118562: LD_STRING 
118564: ST_TO_ADDR
// un := CreateHuman ;
118565: LD_ADDR_VAR 0 2
118569: PUSH
118570: CALL_OW 44
118574: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
118575: LD_VAR 0 2
118579: PPUSH
118580: LD_INT 1
118582: PPUSH
118583: CALL_OW 51
// tmp := tmp ^ un ;
118587: LD_ADDR_VAR 0 3
118591: PUSH
118592: LD_VAR 0 3
118596: PUSH
118597: LD_VAR 0 2
118601: ADD
118602: ST_TO_ADDR
// end ;
118603: GO 118499
118605: POP
118606: POP
// repeat wait ( 0 0$1 ) ;
118607: LD_INT 35
118609: PPUSH
118610: CALL_OW 67
// for un in tmp do
118614: LD_ADDR_VAR 0 2
118618: PUSH
118619: LD_VAR 0 3
118623: PUSH
118624: FOR_IN
118625: IFFALSE 118699
// begin if IsDead ( un ) then
118627: LD_VAR 0 2
118631: PPUSH
118632: CALL_OW 301
118636: IFFALSE 118656
// begin tmp := tmp diff un ;
118638: LD_ADDR_VAR 0 3
118642: PUSH
118643: LD_VAR 0 3
118647: PUSH
118648: LD_VAR 0 2
118652: DIFF
118653: ST_TO_ADDR
// continue ;
118654: GO 118624
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
118656: LD_VAR 0 2
118660: PPUSH
118661: LD_INT 3
118663: PUSH
118664: LD_INT 22
118666: PUSH
118667: LD_INT 0
118669: PUSH
118670: EMPTY
118671: LIST
118672: LIST
118673: PUSH
118674: EMPTY
118675: LIST
118676: LIST
118677: PPUSH
118678: CALL_OW 69
118682: PPUSH
118683: LD_VAR 0 2
118687: PPUSH
118688: CALL_OW 74
118692: PPUSH
118693: CALL_OW 115
// end ;
118697: GO 118624
118699: POP
118700: POP
// until not tmp ;
118701: LD_VAR 0 3
118705: NOT
118706: IFFALSE 118607
// end ;
118708: PPOPN 3
118710: END
// every 0 0$1 trigger StreamModeActive and sTroll do
118711: LD_EXP 146
118715: PUSH
118716: LD_EXP 171
118720: AND
118721: IFFALSE 118775
118723: GO 118725
118725: DISABLE
// begin ToLua ( displayTroll(); ) ;
118726: LD_STRING displayTroll();
118728: PPUSH
118729: CALL_OW 559
// wait ( 3 3$00 ) ;
118733: LD_INT 6300
118735: PPUSH
118736: CALL_OW 67
// ToLua ( hideTroll(); ) ;
118740: LD_STRING hideTroll();
118742: PPUSH
118743: CALL_OW 559
// wait ( 1 1$00 ) ;
118747: LD_INT 2100
118749: PPUSH
118750: CALL_OW 67
// ToLua ( displayTroll(); ) ;
118754: LD_STRING displayTroll();
118756: PPUSH
118757: CALL_OW 559
// wait ( 1 1$00 ) ;
118761: LD_INT 2100
118763: PPUSH
118764: CALL_OW 67
// ToLua ( hideTroll(); ) ;
118768: LD_STRING hideTroll();
118770: PPUSH
118771: CALL_OW 559
// end ;
118775: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
118776: LD_EXP 146
118780: PUSH
118781: LD_EXP 172
118785: AND
118786: IFFALSE 118849
118788: GO 118790
118790: DISABLE
118791: LD_INT 0
118793: PPUSH
// begin p := 0 ;
118794: LD_ADDR_VAR 0 1
118798: PUSH
118799: LD_INT 0
118801: ST_TO_ADDR
// repeat game_speed := 1 ;
118802: LD_ADDR_OWVAR 65
118806: PUSH
118807: LD_INT 1
118809: ST_TO_ADDR
// wait ( 0 0$1 ) ;
118810: LD_INT 35
118812: PPUSH
118813: CALL_OW 67
// p := p + 1 ;
118817: LD_ADDR_VAR 0 1
118821: PUSH
118822: LD_VAR 0 1
118826: PUSH
118827: LD_INT 1
118829: PLUS
118830: ST_TO_ADDR
// until p >= 60 ;
118831: LD_VAR 0 1
118835: PUSH
118836: LD_INT 60
118838: GREATEREQUAL
118839: IFFALSE 118802
// game_speed := 4 ;
118841: LD_ADDR_OWVAR 65
118845: PUSH
118846: LD_INT 4
118848: ST_TO_ADDR
// end ;
118849: PPOPN 1
118851: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
118852: LD_EXP 146
118856: PUSH
118857: LD_EXP 173
118861: AND
118862: IFFALSE 119008
118864: GO 118866
118866: DISABLE
118867: LD_INT 0
118869: PPUSH
118870: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
118871: LD_ADDR_VAR 0 1
118875: PUSH
118876: LD_INT 22
118878: PUSH
118879: LD_OWVAR 2
118883: PUSH
118884: EMPTY
118885: LIST
118886: LIST
118887: PUSH
118888: LD_INT 2
118890: PUSH
118891: LD_INT 30
118893: PUSH
118894: LD_INT 0
118896: PUSH
118897: EMPTY
118898: LIST
118899: LIST
118900: PUSH
118901: LD_INT 30
118903: PUSH
118904: LD_INT 1
118906: PUSH
118907: EMPTY
118908: LIST
118909: LIST
118910: PUSH
118911: EMPTY
118912: LIST
118913: LIST
118914: LIST
118915: PUSH
118916: EMPTY
118917: LIST
118918: LIST
118919: PPUSH
118920: CALL_OW 69
118924: ST_TO_ADDR
// if not depot then
118925: LD_VAR 0 1
118929: NOT
118930: IFFALSE 118934
// exit ;
118932: GO 119008
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
118934: LD_ADDR_VAR 0 2
118938: PUSH
118939: LD_VAR 0 1
118943: PUSH
118944: LD_INT 1
118946: PPUSH
118947: LD_VAR 0 1
118951: PPUSH
118952: CALL_OW 12
118956: ARRAY
118957: PPUSH
118958: CALL_OW 274
118962: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
118963: LD_VAR 0 2
118967: PPUSH
118968: LD_INT 1
118970: PPUSH
118971: LD_INT 0
118973: PPUSH
118974: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
118978: LD_VAR 0 2
118982: PPUSH
118983: LD_INT 2
118985: PPUSH
118986: LD_INT 0
118988: PPUSH
118989: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
118993: LD_VAR 0 2
118997: PPUSH
118998: LD_INT 3
119000: PPUSH
119001: LD_INT 0
119003: PPUSH
119004: CALL_OW 277
// end ;
119008: PPOPN 2
119010: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
119011: LD_EXP 146
119015: PUSH
119016: LD_EXP 174
119020: AND
119021: IFFALSE 119118
119023: GO 119025
119025: DISABLE
119026: LD_INT 0
119028: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
119029: LD_ADDR_VAR 0 1
119033: PUSH
119034: LD_INT 22
119036: PUSH
119037: LD_OWVAR 2
119041: PUSH
119042: EMPTY
119043: LIST
119044: LIST
119045: PUSH
119046: LD_INT 21
119048: PUSH
119049: LD_INT 1
119051: PUSH
119052: EMPTY
119053: LIST
119054: LIST
119055: PUSH
119056: LD_INT 3
119058: PUSH
119059: LD_INT 23
119061: PUSH
119062: LD_INT 0
119064: PUSH
119065: EMPTY
119066: LIST
119067: LIST
119068: PUSH
119069: EMPTY
119070: LIST
119071: LIST
119072: PUSH
119073: EMPTY
119074: LIST
119075: LIST
119076: LIST
119077: PPUSH
119078: CALL_OW 69
119082: ST_TO_ADDR
// if not tmp then
119083: LD_VAR 0 1
119087: NOT
119088: IFFALSE 119092
// exit ;
119090: GO 119118
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
119092: LD_VAR 0 1
119096: PUSH
119097: LD_INT 1
119099: PPUSH
119100: LD_VAR 0 1
119104: PPUSH
119105: CALL_OW 12
119109: ARRAY
119110: PPUSH
119111: LD_INT 200
119113: PPUSH
119114: CALL_OW 234
// end ;
119118: PPOPN 1
119120: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
119121: LD_EXP 146
119125: PUSH
119126: LD_EXP 175
119130: AND
119131: IFFALSE 119210
119133: GO 119135
119135: DISABLE
119136: LD_INT 0
119138: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
119139: LD_ADDR_VAR 0 1
119143: PUSH
119144: LD_INT 22
119146: PUSH
119147: LD_OWVAR 2
119151: PUSH
119152: EMPTY
119153: LIST
119154: LIST
119155: PUSH
119156: LD_INT 21
119158: PUSH
119159: LD_INT 2
119161: PUSH
119162: EMPTY
119163: LIST
119164: LIST
119165: PUSH
119166: EMPTY
119167: LIST
119168: LIST
119169: PPUSH
119170: CALL_OW 69
119174: ST_TO_ADDR
// if not tmp then
119175: LD_VAR 0 1
119179: NOT
119180: IFFALSE 119184
// exit ;
119182: GO 119210
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
119184: LD_VAR 0 1
119188: PUSH
119189: LD_INT 1
119191: PPUSH
119192: LD_VAR 0 1
119196: PPUSH
119197: CALL_OW 12
119201: ARRAY
119202: PPUSH
119203: LD_INT 60
119205: PPUSH
119206: CALL_OW 234
// end ;
119210: PPOPN 1
119212: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
119213: LD_EXP 146
119217: PUSH
119218: LD_EXP 176
119222: AND
119223: IFFALSE 119322
119225: GO 119227
119227: DISABLE
119228: LD_INT 0
119230: PPUSH
119231: PPUSH
// begin enable ;
119232: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
119233: LD_ADDR_VAR 0 1
119237: PUSH
119238: LD_INT 22
119240: PUSH
119241: LD_OWVAR 2
119245: PUSH
119246: EMPTY
119247: LIST
119248: LIST
119249: PUSH
119250: LD_INT 61
119252: PUSH
119253: EMPTY
119254: LIST
119255: PUSH
119256: LD_INT 33
119258: PUSH
119259: LD_INT 2
119261: PUSH
119262: EMPTY
119263: LIST
119264: LIST
119265: PUSH
119266: EMPTY
119267: LIST
119268: LIST
119269: LIST
119270: PPUSH
119271: CALL_OW 69
119275: ST_TO_ADDR
// if not tmp then
119276: LD_VAR 0 1
119280: NOT
119281: IFFALSE 119285
// exit ;
119283: GO 119322
// for i in tmp do
119285: LD_ADDR_VAR 0 2
119289: PUSH
119290: LD_VAR 0 1
119294: PUSH
119295: FOR_IN
119296: IFFALSE 119320
// if IsControledBy ( i ) then
119298: LD_VAR 0 2
119302: PPUSH
119303: CALL_OW 312
119307: IFFALSE 119318
// ComUnlink ( i ) ;
119309: LD_VAR 0 2
119313: PPUSH
119314: CALL_OW 136
119318: GO 119295
119320: POP
119321: POP
// end ;
119322: PPOPN 2
119324: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
119325: LD_EXP 146
119329: PUSH
119330: LD_EXP 177
119334: AND
119335: IFFALSE 119475
119337: GO 119339
119339: DISABLE
119340: LD_INT 0
119342: PPUSH
119343: PPUSH
// begin ToLua ( displayPowell(); ) ;
119344: LD_STRING displayPowell();
119346: PPUSH
119347: CALL_OW 559
// uc_side := 0 ;
119351: LD_ADDR_OWVAR 20
119355: PUSH
119356: LD_INT 0
119358: ST_TO_ADDR
// uc_nation := 2 ;
119359: LD_ADDR_OWVAR 21
119363: PUSH
119364: LD_INT 2
119366: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
119367: LD_ADDR_OWVAR 37
119371: PUSH
119372: LD_INT 14
119374: ST_TO_ADDR
// vc_engine := engine_siberite ;
119375: LD_ADDR_OWVAR 39
119379: PUSH
119380: LD_INT 3
119382: ST_TO_ADDR
// vc_control := control_apeman ;
119383: LD_ADDR_OWVAR 38
119387: PUSH
119388: LD_INT 5
119390: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
119391: LD_ADDR_OWVAR 40
119395: PUSH
119396: LD_INT 29
119398: ST_TO_ADDR
// un := CreateVehicle ;
119399: LD_ADDR_VAR 0 2
119403: PUSH
119404: CALL_OW 45
119408: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
119409: LD_VAR 0 2
119413: PPUSH
119414: LD_INT 1
119416: PPUSH
119417: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
119421: LD_INT 35
119423: PPUSH
119424: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
119428: LD_VAR 0 2
119432: PPUSH
119433: LD_INT 22
119435: PUSH
119436: LD_OWVAR 2
119440: PUSH
119441: EMPTY
119442: LIST
119443: LIST
119444: PPUSH
119445: CALL_OW 69
119449: PPUSH
119450: LD_VAR 0 2
119454: PPUSH
119455: CALL_OW 74
119459: PPUSH
119460: CALL_OW 115
// until IsDead ( un ) ;
119464: LD_VAR 0 2
119468: PPUSH
119469: CALL_OW 301
119473: IFFALSE 119421
// end ;
119475: PPOPN 2
119477: END
// every 0 0$1 trigger StreamModeActive and sStu do
119478: LD_EXP 146
119482: PUSH
119483: LD_EXP 185
119487: AND
119488: IFFALSE 119504
119490: GO 119492
119492: DISABLE
// begin ToLua ( displayStucuk(); ) ;
119493: LD_STRING displayStucuk();
119495: PPUSH
119496: CALL_OW 559
// ResetFog ;
119500: CALL_OW 335
// end ;
119504: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
119505: LD_EXP 146
119509: PUSH
119510: LD_EXP 178
119514: AND
119515: IFFALSE 119656
119517: GO 119519
119519: DISABLE
119520: LD_INT 0
119522: PPUSH
119523: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
119524: LD_ADDR_VAR 0 2
119528: PUSH
119529: LD_INT 22
119531: PUSH
119532: LD_OWVAR 2
119536: PUSH
119537: EMPTY
119538: LIST
119539: LIST
119540: PUSH
119541: LD_INT 21
119543: PUSH
119544: LD_INT 1
119546: PUSH
119547: EMPTY
119548: LIST
119549: LIST
119550: PUSH
119551: EMPTY
119552: LIST
119553: LIST
119554: PPUSH
119555: CALL_OW 69
119559: ST_TO_ADDR
// if not tmp then
119560: LD_VAR 0 2
119564: NOT
119565: IFFALSE 119569
// exit ;
119567: GO 119656
// un := tmp [ rand ( 1 , tmp ) ] ;
119569: LD_ADDR_VAR 0 1
119573: PUSH
119574: LD_VAR 0 2
119578: PUSH
119579: LD_INT 1
119581: PPUSH
119582: LD_VAR 0 2
119586: PPUSH
119587: CALL_OW 12
119591: ARRAY
119592: ST_TO_ADDR
// SetSide ( un , 0 ) ;
119593: LD_VAR 0 1
119597: PPUSH
119598: LD_INT 0
119600: PPUSH
119601: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
119605: LD_VAR 0 1
119609: PPUSH
119610: LD_OWVAR 3
119614: PUSH
119615: LD_VAR 0 1
119619: DIFF
119620: PPUSH
119621: LD_VAR 0 1
119625: PPUSH
119626: CALL_OW 74
119630: PPUSH
119631: CALL_OW 115
// wait ( 0 0$20 ) ;
119635: LD_INT 700
119637: PPUSH
119638: CALL_OW 67
// SetSide ( un , your_side ) ;
119642: LD_VAR 0 1
119646: PPUSH
119647: LD_OWVAR 2
119651: PPUSH
119652: CALL_OW 235
// end ;
119656: PPOPN 2
119658: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
119659: LD_EXP 146
119663: PUSH
119664: LD_EXP 179
119668: AND
119669: IFFALSE 119775
119671: GO 119673
119673: DISABLE
119674: LD_INT 0
119676: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
119677: LD_ADDR_VAR 0 1
119681: PUSH
119682: LD_INT 22
119684: PUSH
119685: LD_OWVAR 2
119689: PUSH
119690: EMPTY
119691: LIST
119692: LIST
119693: PUSH
119694: LD_INT 2
119696: PUSH
119697: LD_INT 30
119699: PUSH
119700: LD_INT 0
119702: PUSH
119703: EMPTY
119704: LIST
119705: LIST
119706: PUSH
119707: LD_INT 30
119709: PUSH
119710: LD_INT 1
119712: PUSH
119713: EMPTY
119714: LIST
119715: LIST
119716: PUSH
119717: EMPTY
119718: LIST
119719: LIST
119720: LIST
119721: PUSH
119722: EMPTY
119723: LIST
119724: LIST
119725: PPUSH
119726: CALL_OW 69
119730: ST_TO_ADDR
// if not depot then
119731: LD_VAR 0 1
119735: NOT
119736: IFFALSE 119740
// exit ;
119738: GO 119775
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
119740: LD_VAR 0 1
119744: PUSH
119745: LD_INT 1
119747: ARRAY
119748: PPUSH
119749: CALL_OW 250
119753: PPUSH
119754: LD_VAR 0 1
119758: PUSH
119759: LD_INT 1
119761: ARRAY
119762: PPUSH
119763: CALL_OW 251
119767: PPUSH
119768: LD_INT 70
119770: PPUSH
119771: CALL_OW 495
// end ;
119775: PPOPN 1
119777: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
119778: LD_EXP 146
119782: PUSH
119783: LD_EXP 180
119787: AND
119788: IFFALSE 119999
119790: GO 119792
119792: DISABLE
119793: LD_INT 0
119795: PPUSH
119796: PPUSH
119797: PPUSH
119798: PPUSH
119799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
119800: LD_ADDR_VAR 0 5
119804: PUSH
119805: LD_INT 22
119807: PUSH
119808: LD_OWVAR 2
119812: PUSH
119813: EMPTY
119814: LIST
119815: LIST
119816: PUSH
119817: LD_INT 21
119819: PUSH
119820: LD_INT 1
119822: PUSH
119823: EMPTY
119824: LIST
119825: LIST
119826: PUSH
119827: EMPTY
119828: LIST
119829: LIST
119830: PPUSH
119831: CALL_OW 69
119835: ST_TO_ADDR
// if not tmp then
119836: LD_VAR 0 5
119840: NOT
119841: IFFALSE 119845
// exit ;
119843: GO 119999
// for i in tmp do
119845: LD_ADDR_VAR 0 1
119849: PUSH
119850: LD_VAR 0 5
119854: PUSH
119855: FOR_IN
119856: IFFALSE 119997
// begin d := rand ( 0 , 5 ) ;
119858: LD_ADDR_VAR 0 4
119862: PUSH
119863: LD_INT 0
119865: PPUSH
119866: LD_INT 5
119868: PPUSH
119869: CALL_OW 12
119873: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
119874: LD_ADDR_VAR 0 2
119878: PUSH
119879: LD_VAR 0 1
119883: PPUSH
119884: CALL_OW 250
119888: PPUSH
119889: LD_VAR 0 4
119893: PPUSH
119894: LD_INT 3
119896: PPUSH
119897: LD_INT 12
119899: PPUSH
119900: CALL_OW 12
119904: PPUSH
119905: CALL_OW 272
119909: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
119910: LD_ADDR_VAR 0 3
119914: PUSH
119915: LD_VAR 0 1
119919: PPUSH
119920: CALL_OW 251
119924: PPUSH
119925: LD_VAR 0 4
119929: PPUSH
119930: LD_INT 3
119932: PPUSH
119933: LD_INT 12
119935: PPUSH
119936: CALL_OW 12
119940: PPUSH
119941: CALL_OW 273
119945: ST_TO_ADDR
// if ValidHex ( x , y ) then
119946: LD_VAR 0 2
119950: PPUSH
119951: LD_VAR 0 3
119955: PPUSH
119956: CALL_OW 488
119960: IFFALSE 119995
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
119962: LD_VAR 0 1
119966: PPUSH
119967: LD_VAR 0 2
119971: PPUSH
119972: LD_VAR 0 3
119976: PPUSH
119977: LD_INT 3
119979: PPUSH
119980: LD_INT 6
119982: PPUSH
119983: CALL_OW 12
119987: PPUSH
119988: LD_INT 1
119990: PPUSH
119991: CALL_OW 483
// end ;
119995: GO 119855
119997: POP
119998: POP
// end ;
119999: PPOPN 5
120001: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
120002: LD_EXP 146
120006: PUSH
120007: LD_EXP 181
120011: AND
120012: IFFALSE 120106
120014: GO 120016
120016: DISABLE
120017: LD_INT 0
120019: PPUSH
120020: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
120021: LD_ADDR_VAR 0 2
120025: PUSH
120026: LD_INT 22
120028: PUSH
120029: LD_OWVAR 2
120033: PUSH
120034: EMPTY
120035: LIST
120036: LIST
120037: PUSH
120038: LD_INT 32
120040: PUSH
120041: LD_INT 1
120043: PUSH
120044: EMPTY
120045: LIST
120046: LIST
120047: PUSH
120048: LD_INT 21
120050: PUSH
120051: LD_INT 2
120053: PUSH
120054: EMPTY
120055: LIST
120056: LIST
120057: PUSH
120058: EMPTY
120059: LIST
120060: LIST
120061: LIST
120062: PPUSH
120063: CALL_OW 69
120067: ST_TO_ADDR
// if not tmp then
120068: LD_VAR 0 2
120072: NOT
120073: IFFALSE 120077
// exit ;
120075: GO 120106
// for i in tmp do
120077: LD_ADDR_VAR 0 1
120081: PUSH
120082: LD_VAR 0 2
120086: PUSH
120087: FOR_IN
120088: IFFALSE 120104
// SetFuel ( i , 0 ) ;
120090: LD_VAR 0 1
120094: PPUSH
120095: LD_INT 0
120097: PPUSH
120098: CALL_OW 240
120102: GO 120087
120104: POP
120105: POP
// end ;
120106: PPOPN 2
120108: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
120109: LD_EXP 146
120113: PUSH
120114: LD_EXP 182
120118: AND
120119: IFFALSE 120185
120121: GO 120123
120123: DISABLE
120124: LD_INT 0
120126: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
120127: LD_ADDR_VAR 0 1
120131: PUSH
120132: LD_INT 22
120134: PUSH
120135: LD_OWVAR 2
120139: PUSH
120140: EMPTY
120141: LIST
120142: LIST
120143: PUSH
120144: LD_INT 30
120146: PUSH
120147: LD_INT 29
120149: PUSH
120150: EMPTY
120151: LIST
120152: LIST
120153: PUSH
120154: EMPTY
120155: LIST
120156: LIST
120157: PPUSH
120158: CALL_OW 69
120162: ST_TO_ADDR
// if not tmp then
120163: LD_VAR 0 1
120167: NOT
120168: IFFALSE 120172
// exit ;
120170: GO 120185
// DestroyUnit ( tmp [ 1 ] ) ;
120172: LD_VAR 0 1
120176: PUSH
120177: LD_INT 1
120179: ARRAY
120180: PPUSH
120181: CALL_OW 65
// end ;
120185: PPOPN 1
120187: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
120188: LD_EXP 146
120192: PUSH
120193: LD_EXP 184
120197: AND
120198: IFFALSE 120327
120200: GO 120202
120202: DISABLE
120203: LD_INT 0
120205: PPUSH
// begin uc_side := 0 ;
120206: LD_ADDR_OWVAR 20
120210: PUSH
120211: LD_INT 0
120213: ST_TO_ADDR
// uc_nation := nation_arabian ;
120214: LD_ADDR_OWVAR 21
120218: PUSH
120219: LD_INT 2
120221: ST_TO_ADDR
// hc_gallery :=  ;
120222: LD_ADDR_OWVAR 33
120226: PUSH
120227: LD_STRING 
120229: ST_TO_ADDR
// hc_name :=  ;
120230: LD_ADDR_OWVAR 26
120234: PUSH
120235: LD_STRING 
120237: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
120238: LD_INT 1
120240: PPUSH
120241: LD_INT 11
120243: PPUSH
120244: LD_INT 10
120246: PPUSH
120247: CALL_OW 380
// un := CreateHuman ;
120251: LD_ADDR_VAR 0 1
120255: PUSH
120256: CALL_OW 44
120260: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
120261: LD_VAR 0 1
120265: PPUSH
120266: LD_INT 1
120268: PPUSH
120269: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
120273: LD_INT 35
120275: PPUSH
120276: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
120280: LD_VAR 0 1
120284: PPUSH
120285: LD_INT 22
120287: PUSH
120288: LD_OWVAR 2
120292: PUSH
120293: EMPTY
120294: LIST
120295: LIST
120296: PPUSH
120297: CALL_OW 69
120301: PPUSH
120302: LD_VAR 0 1
120306: PPUSH
120307: CALL_OW 74
120311: PPUSH
120312: CALL_OW 115
// until IsDead ( un ) ;
120316: LD_VAR 0 1
120320: PPUSH
120321: CALL_OW 301
120325: IFFALSE 120273
// end ;
120327: PPOPN 1
120329: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
120330: LD_EXP 146
120334: PUSH
120335: LD_EXP 186
120339: AND
120340: IFFALSE 120352
120342: GO 120344
120344: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
120345: LD_STRING earthquake(getX(game), 0, 32)
120347: PPUSH
120348: CALL_OW 559
120352: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
120353: LD_EXP 146
120357: PUSH
120358: LD_EXP 187
120362: AND
120363: IFFALSE 120454
120365: GO 120367
120367: DISABLE
120368: LD_INT 0
120370: PPUSH
// begin enable ;
120371: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
120372: LD_ADDR_VAR 0 1
120376: PUSH
120377: LD_INT 22
120379: PUSH
120380: LD_OWVAR 2
120384: PUSH
120385: EMPTY
120386: LIST
120387: LIST
120388: PUSH
120389: LD_INT 21
120391: PUSH
120392: LD_INT 2
120394: PUSH
120395: EMPTY
120396: LIST
120397: LIST
120398: PUSH
120399: LD_INT 33
120401: PUSH
120402: LD_INT 3
120404: PUSH
120405: EMPTY
120406: LIST
120407: LIST
120408: PUSH
120409: EMPTY
120410: LIST
120411: LIST
120412: LIST
120413: PPUSH
120414: CALL_OW 69
120418: ST_TO_ADDR
// if not tmp then
120419: LD_VAR 0 1
120423: NOT
120424: IFFALSE 120428
// exit ;
120426: GO 120454
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
120428: LD_VAR 0 1
120432: PUSH
120433: LD_INT 1
120435: PPUSH
120436: LD_VAR 0 1
120440: PPUSH
120441: CALL_OW 12
120445: ARRAY
120446: PPUSH
120447: LD_INT 1
120449: PPUSH
120450: CALL_OW 234
// end ;
120454: PPOPN 1
120456: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
120457: LD_EXP 146
120461: PUSH
120462: LD_EXP 188
120466: AND
120467: IFFALSE 120608
120469: GO 120471
120471: DISABLE
120472: LD_INT 0
120474: PPUSH
120475: PPUSH
120476: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120477: LD_ADDR_VAR 0 3
120481: PUSH
120482: LD_INT 22
120484: PUSH
120485: LD_OWVAR 2
120489: PUSH
120490: EMPTY
120491: LIST
120492: LIST
120493: PUSH
120494: LD_INT 25
120496: PUSH
120497: LD_INT 1
120499: PUSH
120500: EMPTY
120501: LIST
120502: LIST
120503: PUSH
120504: EMPTY
120505: LIST
120506: LIST
120507: PPUSH
120508: CALL_OW 69
120512: ST_TO_ADDR
// if not tmp then
120513: LD_VAR 0 3
120517: NOT
120518: IFFALSE 120522
// exit ;
120520: GO 120608
// un := tmp [ rand ( 1 , tmp ) ] ;
120522: LD_ADDR_VAR 0 2
120526: PUSH
120527: LD_VAR 0 3
120531: PUSH
120532: LD_INT 1
120534: PPUSH
120535: LD_VAR 0 3
120539: PPUSH
120540: CALL_OW 12
120544: ARRAY
120545: ST_TO_ADDR
// if Crawls ( un ) then
120546: LD_VAR 0 2
120550: PPUSH
120551: CALL_OW 318
120555: IFFALSE 120566
// ComWalk ( un ) ;
120557: LD_VAR 0 2
120561: PPUSH
120562: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
120566: LD_VAR 0 2
120570: PPUSH
120571: LD_INT 9
120573: PPUSH
120574: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
120578: LD_INT 28
120580: PPUSH
120581: LD_OWVAR 2
120585: PPUSH
120586: LD_INT 2
120588: PPUSH
120589: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
120593: LD_INT 29
120595: PPUSH
120596: LD_OWVAR 2
120600: PPUSH
120601: LD_INT 2
120603: PPUSH
120604: CALL_OW 322
// end ;
120608: PPOPN 3
120610: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
120611: LD_EXP 146
120615: PUSH
120616: LD_EXP 189
120620: AND
120621: IFFALSE 120732
120623: GO 120625
120625: DISABLE
120626: LD_INT 0
120628: PPUSH
120629: PPUSH
120630: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
120631: LD_ADDR_VAR 0 3
120635: PUSH
120636: LD_INT 22
120638: PUSH
120639: LD_OWVAR 2
120643: PUSH
120644: EMPTY
120645: LIST
120646: LIST
120647: PUSH
120648: LD_INT 25
120650: PUSH
120651: LD_INT 1
120653: PUSH
120654: EMPTY
120655: LIST
120656: LIST
120657: PUSH
120658: EMPTY
120659: LIST
120660: LIST
120661: PPUSH
120662: CALL_OW 69
120666: ST_TO_ADDR
// if not tmp then
120667: LD_VAR 0 3
120671: NOT
120672: IFFALSE 120676
// exit ;
120674: GO 120732
// un := tmp [ rand ( 1 , tmp ) ] ;
120676: LD_ADDR_VAR 0 2
120680: PUSH
120681: LD_VAR 0 3
120685: PUSH
120686: LD_INT 1
120688: PPUSH
120689: LD_VAR 0 3
120693: PPUSH
120694: CALL_OW 12
120698: ARRAY
120699: ST_TO_ADDR
// if Crawls ( un ) then
120700: LD_VAR 0 2
120704: PPUSH
120705: CALL_OW 318
120709: IFFALSE 120720
// ComWalk ( un ) ;
120711: LD_VAR 0 2
120715: PPUSH
120716: CALL_OW 138
// SetClass ( un , class_mortar ) ;
120720: LD_VAR 0 2
120724: PPUSH
120725: LD_INT 8
120727: PPUSH
120728: CALL_OW 336
// end ;
120732: PPOPN 3
120734: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
120735: LD_EXP 146
120739: PUSH
120740: LD_EXP 190
120744: AND
120745: IFFALSE 120889
120747: GO 120749
120749: DISABLE
120750: LD_INT 0
120752: PPUSH
120753: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
120754: LD_ADDR_VAR 0 2
120758: PUSH
120759: LD_INT 22
120761: PUSH
120762: LD_OWVAR 2
120766: PUSH
120767: EMPTY
120768: LIST
120769: LIST
120770: PUSH
120771: LD_INT 21
120773: PUSH
120774: LD_INT 2
120776: PUSH
120777: EMPTY
120778: LIST
120779: LIST
120780: PUSH
120781: LD_INT 2
120783: PUSH
120784: LD_INT 34
120786: PUSH
120787: LD_INT 12
120789: PUSH
120790: EMPTY
120791: LIST
120792: LIST
120793: PUSH
120794: LD_INT 34
120796: PUSH
120797: LD_INT 51
120799: PUSH
120800: EMPTY
120801: LIST
120802: LIST
120803: PUSH
120804: LD_INT 34
120806: PUSH
120807: LD_INT 32
120809: PUSH
120810: EMPTY
120811: LIST
120812: LIST
120813: PUSH
120814: EMPTY
120815: LIST
120816: LIST
120817: LIST
120818: LIST
120819: PUSH
120820: EMPTY
120821: LIST
120822: LIST
120823: LIST
120824: PPUSH
120825: CALL_OW 69
120829: ST_TO_ADDR
// if not tmp then
120830: LD_VAR 0 2
120834: NOT
120835: IFFALSE 120839
// exit ;
120837: GO 120889
// for i in tmp do
120839: LD_ADDR_VAR 0 1
120843: PUSH
120844: LD_VAR 0 2
120848: PUSH
120849: FOR_IN
120850: IFFALSE 120887
// if GetCargo ( i , mat_artifact ) = 0 then
120852: LD_VAR 0 1
120856: PPUSH
120857: LD_INT 4
120859: PPUSH
120860: CALL_OW 289
120864: PUSH
120865: LD_INT 0
120867: EQUAL
120868: IFFALSE 120885
// SetCargo ( i , mat_siberit , 100 ) ;
120870: LD_VAR 0 1
120874: PPUSH
120875: LD_INT 3
120877: PPUSH
120878: LD_INT 100
120880: PPUSH
120881: CALL_OW 290
120885: GO 120849
120887: POP
120888: POP
// end ;
120889: PPOPN 2
120891: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
120892: LD_EXP 146
120896: PUSH
120897: LD_EXP 191
120901: AND
120902: IFFALSE 121085
120904: GO 120906
120906: DISABLE
120907: LD_INT 0
120909: PPUSH
120910: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
120911: LD_ADDR_VAR 0 2
120915: PUSH
120916: LD_INT 22
120918: PUSH
120919: LD_OWVAR 2
120923: PUSH
120924: EMPTY
120925: LIST
120926: LIST
120927: PPUSH
120928: CALL_OW 69
120932: ST_TO_ADDR
// if not tmp then
120933: LD_VAR 0 2
120937: NOT
120938: IFFALSE 120942
// exit ;
120940: GO 121085
// for i := 1 to 2 do
120942: LD_ADDR_VAR 0 1
120946: PUSH
120947: DOUBLE
120948: LD_INT 1
120950: DEC
120951: ST_TO_ADDR
120952: LD_INT 2
120954: PUSH
120955: FOR_TO
120956: IFFALSE 121083
// begin uc_side := your_side ;
120958: LD_ADDR_OWVAR 20
120962: PUSH
120963: LD_OWVAR 2
120967: ST_TO_ADDR
// uc_nation := nation_american ;
120968: LD_ADDR_OWVAR 21
120972: PUSH
120973: LD_INT 1
120975: ST_TO_ADDR
// vc_chassis := us_morphling ;
120976: LD_ADDR_OWVAR 37
120980: PUSH
120981: LD_INT 5
120983: ST_TO_ADDR
// vc_engine := engine_siberite ;
120984: LD_ADDR_OWVAR 39
120988: PUSH
120989: LD_INT 3
120991: ST_TO_ADDR
// vc_control := control_computer ;
120992: LD_ADDR_OWVAR 38
120996: PUSH
120997: LD_INT 3
120999: ST_TO_ADDR
// vc_weapon := us_double_laser ;
121000: LD_ADDR_OWVAR 40
121004: PUSH
121005: LD_INT 10
121007: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
121008: LD_VAR 0 2
121012: PUSH
121013: LD_INT 1
121015: ARRAY
121016: PPUSH
121017: CALL_OW 310
121021: NOT
121022: IFFALSE 121069
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
121024: CALL_OW 45
121028: PPUSH
121029: LD_VAR 0 2
121033: PUSH
121034: LD_INT 1
121036: ARRAY
121037: PPUSH
121038: CALL_OW 250
121042: PPUSH
121043: LD_VAR 0 2
121047: PUSH
121048: LD_INT 1
121050: ARRAY
121051: PPUSH
121052: CALL_OW 251
121056: PPUSH
121057: LD_INT 12
121059: PPUSH
121060: LD_INT 1
121062: PPUSH
121063: CALL_OW 50
121067: GO 121081
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
121069: CALL_OW 45
121073: PPUSH
121074: LD_INT 1
121076: PPUSH
121077: CALL_OW 51
// end ;
121081: GO 120955
121083: POP
121084: POP
// end ;
121085: PPOPN 2
121087: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
121088: LD_EXP 146
121092: PUSH
121093: LD_EXP 192
121097: AND
121098: IFFALSE 121320
121100: GO 121102
121102: DISABLE
121103: LD_INT 0
121105: PPUSH
121106: PPUSH
121107: PPUSH
121108: PPUSH
121109: PPUSH
121110: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
121111: LD_ADDR_VAR 0 6
121115: PUSH
121116: LD_INT 22
121118: PUSH
121119: LD_OWVAR 2
121123: PUSH
121124: EMPTY
121125: LIST
121126: LIST
121127: PUSH
121128: LD_INT 21
121130: PUSH
121131: LD_INT 1
121133: PUSH
121134: EMPTY
121135: LIST
121136: LIST
121137: PUSH
121138: LD_INT 3
121140: PUSH
121141: LD_INT 23
121143: PUSH
121144: LD_INT 0
121146: PUSH
121147: EMPTY
121148: LIST
121149: LIST
121150: PUSH
121151: EMPTY
121152: LIST
121153: LIST
121154: PUSH
121155: EMPTY
121156: LIST
121157: LIST
121158: LIST
121159: PPUSH
121160: CALL_OW 69
121164: ST_TO_ADDR
// if not tmp then
121165: LD_VAR 0 6
121169: NOT
121170: IFFALSE 121174
// exit ;
121172: GO 121320
// s1 := rand ( 1 , 4 ) ;
121174: LD_ADDR_VAR 0 2
121178: PUSH
121179: LD_INT 1
121181: PPUSH
121182: LD_INT 4
121184: PPUSH
121185: CALL_OW 12
121189: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
121190: LD_ADDR_VAR 0 4
121194: PUSH
121195: LD_VAR 0 6
121199: PUSH
121200: LD_INT 1
121202: ARRAY
121203: PPUSH
121204: LD_VAR 0 2
121208: PPUSH
121209: CALL_OW 259
121213: ST_TO_ADDR
// if s1 = 1 then
121214: LD_VAR 0 2
121218: PUSH
121219: LD_INT 1
121221: EQUAL
121222: IFFALSE 121242
// s2 := rand ( 2 , 4 ) else
121224: LD_ADDR_VAR 0 3
121228: PUSH
121229: LD_INT 2
121231: PPUSH
121232: LD_INT 4
121234: PPUSH
121235: CALL_OW 12
121239: ST_TO_ADDR
121240: GO 121250
// s2 := 1 ;
121242: LD_ADDR_VAR 0 3
121246: PUSH
121247: LD_INT 1
121249: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
121250: LD_ADDR_VAR 0 5
121254: PUSH
121255: LD_VAR 0 6
121259: PUSH
121260: LD_INT 1
121262: ARRAY
121263: PPUSH
121264: LD_VAR 0 3
121268: PPUSH
121269: CALL_OW 259
121273: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
121274: LD_VAR 0 6
121278: PUSH
121279: LD_INT 1
121281: ARRAY
121282: PPUSH
121283: LD_VAR 0 2
121287: PPUSH
121288: LD_VAR 0 5
121292: PPUSH
121293: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
121297: LD_VAR 0 6
121301: PUSH
121302: LD_INT 1
121304: ARRAY
121305: PPUSH
121306: LD_VAR 0 3
121310: PPUSH
121311: LD_VAR 0 4
121315: PPUSH
121316: CALL_OW 237
// end ;
121320: PPOPN 6
121322: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
121323: LD_EXP 146
121327: PUSH
121328: LD_EXP 193
121332: AND
121333: IFFALSE 121412
121335: GO 121337
121337: DISABLE
121338: LD_INT 0
121340: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
121341: LD_ADDR_VAR 0 1
121345: PUSH
121346: LD_INT 22
121348: PUSH
121349: LD_OWVAR 2
121353: PUSH
121354: EMPTY
121355: LIST
121356: LIST
121357: PUSH
121358: LD_INT 30
121360: PUSH
121361: LD_INT 3
121363: PUSH
121364: EMPTY
121365: LIST
121366: LIST
121367: PUSH
121368: EMPTY
121369: LIST
121370: LIST
121371: PPUSH
121372: CALL_OW 69
121376: ST_TO_ADDR
// if not tmp then
121377: LD_VAR 0 1
121381: NOT
121382: IFFALSE 121386
// exit ;
121384: GO 121412
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
121386: LD_VAR 0 1
121390: PUSH
121391: LD_INT 1
121393: PPUSH
121394: LD_VAR 0 1
121398: PPUSH
121399: CALL_OW 12
121403: ARRAY
121404: PPUSH
121405: LD_INT 1
121407: PPUSH
121408: CALL_OW 234
// end ;
121412: PPOPN 1
121414: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
121415: LD_EXP 146
121419: PUSH
121420: LD_EXP 194
121424: AND
121425: IFFALSE 121537
121427: GO 121429
121429: DISABLE
121430: LD_INT 0
121432: PPUSH
121433: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
121434: LD_ADDR_VAR 0 2
121438: PUSH
121439: LD_INT 22
121441: PUSH
121442: LD_OWVAR 2
121446: PUSH
121447: EMPTY
121448: LIST
121449: LIST
121450: PUSH
121451: LD_INT 2
121453: PUSH
121454: LD_INT 30
121456: PUSH
121457: LD_INT 27
121459: PUSH
121460: EMPTY
121461: LIST
121462: LIST
121463: PUSH
121464: LD_INT 30
121466: PUSH
121467: LD_INT 26
121469: PUSH
121470: EMPTY
121471: LIST
121472: LIST
121473: PUSH
121474: LD_INT 30
121476: PUSH
121477: LD_INT 28
121479: PUSH
121480: EMPTY
121481: LIST
121482: LIST
121483: PUSH
121484: EMPTY
121485: LIST
121486: LIST
121487: LIST
121488: LIST
121489: PUSH
121490: EMPTY
121491: LIST
121492: LIST
121493: PPUSH
121494: CALL_OW 69
121498: ST_TO_ADDR
// if not tmp then
121499: LD_VAR 0 2
121503: NOT
121504: IFFALSE 121508
// exit ;
121506: GO 121537
// for i in tmp do
121508: LD_ADDR_VAR 0 1
121512: PUSH
121513: LD_VAR 0 2
121517: PUSH
121518: FOR_IN
121519: IFFALSE 121535
// SetLives ( i , 1 ) ;
121521: LD_VAR 0 1
121525: PPUSH
121526: LD_INT 1
121528: PPUSH
121529: CALL_OW 234
121533: GO 121518
121535: POP
121536: POP
// end ;
121537: PPOPN 2
121539: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
121540: LD_EXP 146
121544: PUSH
121545: LD_EXP 195
121549: AND
121550: IFFALSE 121837
121552: GO 121554
121554: DISABLE
121555: LD_INT 0
121557: PPUSH
121558: PPUSH
121559: PPUSH
// begin i := rand ( 1 , 7 ) ;
121560: LD_ADDR_VAR 0 1
121564: PUSH
121565: LD_INT 1
121567: PPUSH
121568: LD_INT 7
121570: PPUSH
121571: CALL_OW 12
121575: ST_TO_ADDR
// case i of 1 :
121576: LD_VAR 0 1
121580: PUSH
121581: LD_INT 1
121583: DOUBLE
121584: EQUAL
121585: IFTRUE 121589
121587: GO 121599
121589: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
121590: LD_STRING earthquake(getX(game), 0, 32)
121592: PPUSH
121593: CALL_OW 559
121597: GO 121837
121599: LD_INT 2
121601: DOUBLE
121602: EQUAL
121603: IFTRUE 121607
121605: GO 121621
121607: POP
// begin ToLua ( displayStucuk(); ) ;
121608: LD_STRING displayStucuk();
121610: PPUSH
121611: CALL_OW 559
// ResetFog ;
121615: CALL_OW 335
// end ; 3 :
121619: GO 121837
121621: LD_INT 3
121623: DOUBLE
121624: EQUAL
121625: IFTRUE 121629
121627: GO 121733
121629: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
121630: LD_ADDR_VAR 0 2
121634: PUSH
121635: LD_INT 22
121637: PUSH
121638: LD_OWVAR 2
121642: PUSH
121643: EMPTY
121644: LIST
121645: LIST
121646: PUSH
121647: LD_INT 25
121649: PUSH
121650: LD_INT 1
121652: PUSH
121653: EMPTY
121654: LIST
121655: LIST
121656: PUSH
121657: EMPTY
121658: LIST
121659: LIST
121660: PPUSH
121661: CALL_OW 69
121665: ST_TO_ADDR
// if not tmp then
121666: LD_VAR 0 2
121670: NOT
121671: IFFALSE 121675
// exit ;
121673: GO 121837
// un := tmp [ rand ( 1 , tmp ) ] ;
121675: LD_ADDR_VAR 0 3
121679: PUSH
121680: LD_VAR 0 2
121684: PUSH
121685: LD_INT 1
121687: PPUSH
121688: LD_VAR 0 2
121692: PPUSH
121693: CALL_OW 12
121697: ARRAY
121698: ST_TO_ADDR
// if Crawls ( un ) then
121699: LD_VAR 0 3
121703: PPUSH
121704: CALL_OW 318
121708: IFFALSE 121719
// ComWalk ( un ) ;
121710: LD_VAR 0 3
121714: PPUSH
121715: CALL_OW 138
// SetClass ( un , class_mortar ) ;
121719: LD_VAR 0 3
121723: PPUSH
121724: LD_INT 8
121726: PPUSH
121727: CALL_OW 336
// end ; 4 :
121731: GO 121837
121733: LD_INT 4
121735: DOUBLE
121736: EQUAL
121737: IFTRUE 121741
121739: GO 121815
121741: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
121742: LD_ADDR_VAR 0 2
121746: PUSH
121747: LD_INT 22
121749: PUSH
121750: LD_OWVAR 2
121754: PUSH
121755: EMPTY
121756: LIST
121757: LIST
121758: PUSH
121759: LD_INT 30
121761: PUSH
121762: LD_INT 29
121764: PUSH
121765: EMPTY
121766: LIST
121767: LIST
121768: PUSH
121769: EMPTY
121770: LIST
121771: LIST
121772: PPUSH
121773: CALL_OW 69
121777: ST_TO_ADDR
// if not tmp then
121778: LD_VAR 0 2
121782: NOT
121783: IFFALSE 121787
// exit ;
121785: GO 121837
// CenterNowOnUnits ( tmp [ 1 ] ) ;
121787: LD_VAR 0 2
121791: PUSH
121792: LD_INT 1
121794: ARRAY
121795: PPUSH
121796: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
121800: LD_VAR 0 2
121804: PUSH
121805: LD_INT 1
121807: ARRAY
121808: PPUSH
121809: CALL_OW 65
// end ; 5 .. 7 :
121813: GO 121837
121815: LD_INT 5
121817: DOUBLE
121818: GREATEREQUAL
121819: IFFALSE 121827
121821: LD_INT 7
121823: DOUBLE
121824: LESSEQUAL
121825: IFTRUE 121829
121827: GO 121836
121829: POP
// StreamSibBomb ; end ;
121830: CALL 118074 0 0
121834: GO 121837
121836: POP
// end ;
121837: PPOPN 3
121839: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
121840: LD_EXP 146
121844: PUSH
121845: LD_EXP 196
121849: AND
121850: IFFALSE 122006
121852: GO 121854
121854: DISABLE
121855: LD_INT 0
121857: PPUSH
121858: PPUSH
121859: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
121860: LD_ADDR_VAR 0 2
121864: PUSH
121865: LD_INT 81
121867: PUSH
121868: LD_OWVAR 2
121872: PUSH
121873: EMPTY
121874: LIST
121875: LIST
121876: PUSH
121877: LD_INT 2
121879: PUSH
121880: LD_INT 21
121882: PUSH
121883: LD_INT 1
121885: PUSH
121886: EMPTY
121887: LIST
121888: LIST
121889: PUSH
121890: LD_INT 21
121892: PUSH
121893: LD_INT 2
121895: PUSH
121896: EMPTY
121897: LIST
121898: LIST
121899: PUSH
121900: EMPTY
121901: LIST
121902: LIST
121903: LIST
121904: PUSH
121905: EMPTY
121906: LIST
121907: LIST
121908: PPUSH
121909: CALL_OW 69
121913: ST_TO_ADDR
// if not tmp then
121914: LD_VAR 0 2
121918: NOT
121919: IFFALSE 121923
// exit ;
121921: GO 122006
// p := 0 ;
121923: LD_ADDR_VAR 0 3
121927: PUSH
121928: LD_INT 0
121930: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
121931: LD_INT 35
121933: PPUSH
121934: CALL_OW 67
// p := p + 1 ;
121938: LD_ADDR_VAR 0 3
121942: PUSH
121943: LD_VAR 0 3
121947: PUSH
121948: LD_INT 1
121950: PLUS
121951: ST_TO_ADDR
// for i in tmp do
121952: LD_ADDR_VAR 0 1
121956: PUSH
121957: LD_VAR 0 2
121961: PUSH
121962: FOR_IN
121963: IFFALSE 121994
// if GetLives ( i ) < 1000 then
121965: LD_VAR 0 1
121969: PPUSH
121970: CALL_OW 256
121974: PUSH
121975: LD_INT 1000
121977: LESS
121978: IFFALSE 121992
// SetLives ( i , 1000 ) ;
121980: LD_VAR 0 1
121984: PPUSH
121985: LD_INT 1000
121987: PPUSH
121988: CALL_OW 234
121992: GO 121962
121994: POP
121995: POP
// until p > 20 ;
121996: LD_VAR 0 3
122000: PUSH
122001: LD_INT 20
122003: GREATER
122004: IFFALSE 121931
// end ;
122006: PPOPN 3
122008: END
// every 0 0$1 trigger StreamModeActive and sTime do
122009: LD_EXP 146
122013: PUSH
122014: LD_EXP 197
122018: AND
122019: IFFALSE 122054
122021: GO 122023
122023: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
122024: LD_INT 28
122026: PPUSH
122027: LD_OWVAR 2
122031: PPUSH
122032: LD_INT 2
122034: PPUSH
122035: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
122039: LD_INT 30
122041: PPUSH
122042: LD_OWVAR 2
122046: PPUSH
122047: LD_INT 2
122049: PPUSH
122050: CALL_OW 322
// end ;
122054: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
122055: LD_EXP 146
122059: PUSH
122060: LD_EXP 198
122064: AND
122065: IFFALSE 122186
122067: GO 122069
122069: DISABLE
122070: LD_INT 0
122072: PPUSH
122073: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
122074: LD_ADDR_VAR 0 2
122078: PUSH
122079: LD_INT 22
122081: PUSH
122082: LD_OWVAR 2
122086: PUSH
122087: EMPTY
122088: LIST
122089: LIST
122090: PUSH
122091: LD_INT 21
122093: PUSH
122094: LD_INT 1
122096: PUSH
122097: EMPTY
122098: LIST
122099: LIST
122100: PUSH
122101: LD_INT 3
122103: PUSH
122104: LD_INT 23
122106: PUSH
122107: LD_INT 0
122109: PUSH
122110: EMPTY
122111: LIST
122112: LIST
122113: PUSH
122114: EMPTY
122115: LIST
122116: LIST
122117: PUSH
122118: EMPTY
122119: LIST
122120: LIST
122121: LIST
122122: PPUSH
122123: CALL_OW 69
122127: ST_TO_ADDR
// if not tmp then
122128: LD_VAR 0 2
122132: NOT
122133: IFFALSE 122137
// exit ;
122135: GO 122186
// for i in tmp do
122137: LD_ADDR_VAR 0 1
122141: PUSH
122142: LD_VAR 0 2
122146: PUSH
122147: FOR_IN
122148: IFFALSE 122184
// begin if Crawls ( i ) then
122150: LD_VAR 0 1
122154: PPUSH
122155: CALL_OW 318
122159: IFFALSE 122170
// ComWalk ( i ) ;
122161: LD_VAR 0 1
122165: PPUSH
122166: CALL_OW 138
// SetClass ( i , 2 ) ;
122170: LD_VAR 0 1
122174: PPUSH
122175: LD_INT 2
122177: PPUSH
122178: CALL_OW 336
// end ;
122182: GO 122147
122184: POP
122185: POP
// end ;
122186: PPOPN 2
122188: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
122189: LD_EXP 146
122193: PUSH
122194: LD_EXP 199
122198: AND
122199: IFFALSE 122487
122201: GO 122203
122203: DISABLE
122204: LD_INT 0
122206: PPUSH
122207: PPUSH
122208: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
122209: LD_OWVAR 2
122213: PPUSH
122214: LD_INT 9
122216: PPUSH
122217: LD_INT 1
122219: PPUSH
122220: LD_INT 1
122222: PPUSH
122223: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
122227: LD_INT 9
122229: PPUSH
122230: LD_OWVAR 2
122234: PPUSH
122235: CALL_OW 343
// uc_side := 9 ;
122239: LD_ADDR_OWVAR 20
122243: PUSH
122244: LD_INT 9
122246: ST_TO_ADDR
// uc_nation := 2 ;
122247: LD_ADDR_OWVAR 21
122251: PUSH
122252: LD_INT 2
122254: ST_TO_ADDR
// hc_name := Dark Warrior ;
122255: LD_ADDR_OWVAR 26
122259: PUSH
122260: LD_STRING Dark Warrior
122262: ST_TO_ADDR
// hc_gallery :=  ;
122263: LD_ADDR_OWVAR 33
122267: PUSH
122268: LD_STRING 
122270: ST_TO_ADDR
// hc_noskilllimit := true ;
122271: LD_ADDR_OWVAR 76
122275: PUSH
122276: LD_INT 1
122278: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
122279: LD_ADDR_OWVAR 31
122283: PUSH
122284: LD_INT 30
122286: PUSH
122287: LD_INT 30
122289: PUSH
122290: LD_INT 30
122292: PUSH
122293: LD_INT 30
122295: PUSH
122296: EMPTY
122297: LIST
122298: LIST
122299: LIST
122300: LIST
122301: ST_TO_ADDR
// un := CreateHuman ;
122302: LD_ADDR_VAR 0 3
122306: PUSH
122307: CALL_OW 44
122311: ST_TO_ADDR
// hc_noskilllimit := false ;
122312: LD_ADDR_OWVAR 76
122316: PUSH
122317: LD_INT 0
122319: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
122320: LD_VAR 0 3
122324: PPUSH
122325: LD_INT 1
122327: PPUSH
122328: CALL_OW 51
// ToLua ( playRanger() ) ;
122332: LD_STRING playRanger()
122334: PPUSH
122335: CALL_OW 559
// p := 0 ;
122339: LD_ADDR_VAR 0 2
122343: PUSH
122344: LD_INT 0
122346: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
122347: LD_INT 35
122349: PPUSH
122350: CALL_OW 67
// p := p + 1 ;
122354: LD_ADDR_VAR 0 2
122358: PUSH
122359: LD_VAR 0 2
122363: PUSH
122364: LD_INT 1
122366: PLUS
122367: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
122368: LD_VAR 0 3
122372: PPUSH
122373: CALL_OW 256
122377: PUSH
122378: LD_INT 1000
122380: LESS
122381: IFFALSE 122395
// SetLives ( un , 1000 ) ;
122383: LD_VAR 0 3
122387: PPUSH
122388: LD_INT 1000
122390: PPUSH
122391: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
122395: LD_VAR 0 3
122399: PPUSH
122400: LD_INT 81
122402: PUSH
122403: LD_OWVAR 2
122407: PUSH
122408: EMPTY
122409: LIST
122410: LIST
122411: PUSH
122412: LD_INT 91
122414: PUSH
122415: LD_VAR 0 3
122419: PUSH
122420: LD_INT 30
122422: PUSH
122423: EMPTY
122424: LIST
122425: LIST
122426: LIST
122427: PUSH
122428: EMPTY
122429: LIST
122430: LIST
122431: PPUSH
122432: CALL_OW 69
122436: PPUSH
122437: LD_VAR 0 3
122441: PPUSH
122442: CALL_OW 74
122446: PPUSH
122447: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
122451: LD_VAR 0 2
122455: PUSH
122456: LD_INT 80
122458: GREATER
122459: PUSH
122460: LD_VAR 0 3
122464: PPUSH
122465: CALL_OW 301
122469: OR
122470: IFFALSE 122347
// if un then
122472: LD_VAR 0 3
122476: IFFALSE 122487
// RemoveUnit ( un ) ;
122478: LD_VAR 0 3
122482: PPUSH
122483: CALL_OW 64
// end ;
122487: PPOPN 3
122489: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
122490: LD_EXP 200
122494: IFFALSE 122610
122496: GO 122498
122498: DISABLE
122499: LD_INT 0
122501: PPUSH
122502: PPUSH
122503: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
122504: LD_ADDR_VAR 0 2
122508: PUSH
122509: LD_INT 81
122511: PUSH
122512: LD_OWVAR 2
122516: PUSH
122517: EMPTY
122518: LIST
122519: LIST
122520: PUSH
122521: LD_INT 21
122523: PUSH
122524: LD_INT 1
122526: PUSH
122527: EMPTY
122528: LIST
122529: LIST
122530: PUSH
122531: EMPTY
122532: LIST
122533: LIST
122534: PPUSH
122535: CALL_OW 69
122539: ST_TO_ADDR
// ToLua ( playComputer() ) ;
122540: LD_STRING playComputer()
122542: PPUSH
122543: CALL_OW 559
// if not tmp then
122547: LD_VAR 0 2
122551: NOT
122552: IFFALSE 122556
// exit ;
122554: GO 122610
// for i in tmp do
122556: LD_ADDR_VAR 0 1
122560: PUSH
122561: LD_VAR 0 2
122565: PUSH
122566: FOR_IN
122567: IFFALSE 122608
// for j := 1 to 4 do
122569: LD_ADDR_VAR 0 3
122573: PUSH
122574: DOUBLE
122575: LD_INT 1
122577: DEC
122578: ST_TO_ADDR
122579: LD_INT 4
122581: PUSH
122582: FOR_TO
122583: IFFALSE 122604
// SetSkill ( i , j , 10 ) ;
122585: LD_VAR 0 1
122589: PPUSH
122590: LD_VAR 0 3
122594: PPUSH
122595: LD_INT 10
122597: PPUSH
122598: CALL_OW 237
122602: GO 122582
122604: POP
122605: POP
122606: GO 122566
122608: POP
122609: POP
// end ;
122610: PPOPN 3
122612: END
// every 0 0$1 trigger s30 do var i , tmp ;
122613: LD_EXP 201
122617: IFFALSE 122686
122619: GO 122621
122621: DISABLE
122622: LD_INT 0
122624: PPUSH
122625: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
122626: LD_ADDR_VAR 0 2
122630: PUSH
122631: LD_INT 22
122633: PUSH
122634: LD_OWVAR 2
122638: PUSH
122639: EMPTY
122640: LIST
122641: LIST
122642: PPUSH
122643: CALL_OW 69
122647: ST_TO_ADDR
// if not tmp then
122648: LD_VAR 0 2
122652: NOT
122653: IFFALSE 122657
// exit ;
122655: GO 122686
// for i in tmp do
122657: LD_ADDR_VAR 0 1
122661: PUSH
122662: LD_VAR 0 2
122666: PUSH
122667: FOR_IN
122668: IFFALSE 122684
// SetLives ( i , 300 ) ;
122670: LD_VAR 0 1
122674: PPUSH
122675: LD_INT 300
122677: PPUSH
122678: CALL_OW 234
122682: GO 122667
122684: POP
122685: POP
// end ;
122686: PPOPN 2
122688: END
// every 0 0$1 trigger s60 do var i , tmp ;
122689: LD_EXP 202
122693: IFFALSE 122762
122695: GO 122697
122697: DISABLE
122698: LD_INT 0
122700: PPUSH
122701: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
122702: LD_ADDR_VAR 0 2
122706: PUSH
122707: LD_INT 22
122709: PUSH
122710: LD_OWVAR 2
122714: PUSH
122715: EMPTY
122716: LIST
122717: LIST
122718: PPUSH
122719: CALL_OW 69
122723: ST_TO_ADDR
// if not tmp then
122724: LD_VAR 0 2
122728: NOT
122729: IFFALSE 122733
// exit ;
122731: GO 122762
// for i in tmp do
122733: LD_ADDR_VAR 0 1
122737: PUSH
122738: LD_VAR 0 2
122742: PUSH
122743: FOR_IN
122744: IFFALSE 122760
// SetLives ( i , 600 ) ;
122746: LD_VAR 0 1
122750: PPUSH
122751: LD_INT 600
122753: PPUSH
122754: CALL_OW 234
122758: GO 122743
122760: POP
122761: POP
// end ;
122762: PPOPN 2
122764: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
122765: LD_INT 0
122767: PPUSH
// case cmd of 301 :
122768: LD_VAR 0 1
122772: PUSH
122773: LD_INT 301
122775: DOUBLE
122776: EQUAL
122777: IFTRUE 122781
122779: GO 122813
122781: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
122782: LD_VAR 0 6
122786: PPUSH
122787: LD_VAR 0 7
122791: PPUSH
122792: LD_VAR 0 8
122796: PPUSH
122797: LD_VAR 0 4
122801: PPUSH
122802: LD_VAR 0 5
122806: PPUSH
122807: CALL 124022 0 5
122811: GO 122934
122813: LD_INT 302
122815: DOUBLE
122816: EQUAL
122817: IFTRUE 122821
122819: GO 122858
122821: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
122822: LD_VAR 0 6
122826: PPUSH
122827: LD_VAR 0 7
122831: PPUSH
122832: LD_VAR 0 8
122836: PPUSH
122837: LD_VAR 0 9
122841: PPUSH
122842: LD_VAR 0 4
122846: PPUSH
122847: LD_VAR 0 5
122851: PPUSH
122852: CALL 124113 0 6
122856: GO 122934
122858: LD_INT 303
122860: DOUBLE
122861: EQUAL
122862: IFTRUE 122866
122864: GO 122903
122866: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
122867: LD_VAR 0 6
122871: PPUSH
122872: LD_VAR 0 7
122876: PPUSH
122877: LD_VAR 0 8
122881: PPUSH
122882: LD_VAR 0 9
122886: PPUSH
122887: LD_VAR 0 4
122891: PPUSH
122892: LD_VAR 0 5
122896: PPUSH
122897: CALL 122939 0 6
122901: GO 122934
122903: LD_INT 304
122905: DOUBLE
122906: EQUAL
122907: IFTRUE 122911
122909: GO 122933
122911: POP
// hHackTeleport ( unit , x , y ) ; end ;
122912: LD_VAR 0 2
122916: PPUSH
122917: LD_VAR 0 4
122921: PPUSH
122922: LD_VAR 0 5
122926: PPUSH
122927: CALL 124706 0 3
122931: GO 122934
122933: POP
// end ;
122934: LD_VAR 0 12
122938: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
122939: LD_INT 0
122941: PPUSH
122942: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
122943: LD_VAR 0 1
122947: PUSH
122948: LD_INT 1
122950: LESS
122951: PUSH
122952: LD_VAR 0 1
122956: PUSH
122957: LD_INT 3
122959: GREATER
122960: OR
122961: PUSH
122962: LD_VAR 0 5
122966: PPUSH
122967: LD_VAR 0 6
122971: PPUSH
122972: CALL_OW 428
122976: OR
122977: IFFALSE 122981
// exit ;
122979: GO 123709
// uc_side := your_side ;
122981: LD_ADDR_OWVAR 20
122985: PUSH
122986: LD_OWVAR 2
122990: ST_TO_ADDR
// uc_nation := nation ;
122991: LD_ADDR_OWVAR 21
122995: PUSH
122996: LD_VAR 0 1
123000: ST_TO_ADDR
// bc_level = 1 ;
123001: LD_ADDR_OWVAR 43
123005: PUSH
123006: LD_INT 1
123008: ST_TO_ADDR
// case btype of 1 :
123009: LD_VAR 0 2
123013: PUSH
123014: LD_INT 1
123016: DOUBLE
123017: EQUAL
123018: IFTRUE 123022
123020: GO 123033
123022: POP
// bc_type := b_depot ; 2 :
123023: LD_ADDR_OWVAR 42
123027: PUSH
123028: LD_INT 0
123030: ST_TO_ADDR
123031: GO 123653
123033: LD_INT 2
123035: DOUBLE
123036: EQUAL
123037: IFTRUE 123041
123039: GO 123052
123041: POP
// bc_type := b_warehouse ; 3 :
123042: LD_ADDR_OWVAR 42
123046: PUSH
123047: LD_INT 1
123049: ST_TO_ADDR
123050: GO 123653
123052: LD_INT 3
123054: DOUBLE
123055: EQUAL
123056: IFTRUE 123060
123058: GO 123071
123060: POP
// bc_type := b_lab ; 4 .. 9 :
123061: LD_ADDR_OWVAR 42
123065: PUSH
123066: LD_INT 6
123068: ST_TO_ADDR
123069: GO 123653
123071: LD_INT 4
123073: DOUBLE
123074: GREATEREQUAL
123075: IFFALSE 123083
123077: LD_INT 9
123079: DOUBLE
123080: LESSEQUAL
123081: IFTRUE 123085
123083: GO 123145
123085: POP
// begin bc_type := b_lab_half ;
123086: LD_ADDR_OWVAR 42
123090: PUSH
123091: LD_INT 7
123093: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
123094: LD_ADDR_OWVAR 44
123098: PUSH
123099: LD_INT 10
123101: PUSH
123102: LD_INT 11
123104: PUSH
123105: LD_INT 12
123107: PUSH
123108: LD_INT 15
123110: PUSH
123111: LD_INT 14
123113: PUSH
123114: LD_INT 13
123116: PUSH
123117: EMPTY
123118: LIST
123119: LIST
123120: LIST
123121: LIST
123122: LIST
123123: LIST
123124: PUSH
123125: LD_VAR 0 2
123129: PUSH
123130: LD_INT 3
123132: MINUS
123133: ARRAY
123134: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
123135: LD_ADDR_OWVAR 45
123139: PUSH
123140: LD_INT 9
123142: ST_TO_ADDR
// end ; 10 .. 13 :
123143: GO 123653
123145: LD_INT 10
123147: DOUBLE
123148: GREATEREQUAL
123149: IFFALSE 123157
123151: LD_INT 13
123153: DOUBLE
123154: LESSEQUAL
123155: IFTRUE 123159
123157: GO 123236
123159: POP
// begin bc_type := b_lab_full ;
123160: LD_ADDR_OWVAR 42
123164: PUSH
123165: LD_INT 8
123167: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
123168: LD_ADDR_OWVAR 44
123172: PUSH
123173: LD_INT 10
123175: PUSH
123176: LD_INT 12
123178: PUSH
123179: LD_INT 14
123181: PUSH
123182: LD_INT 13
123184: PUSH
123185: EMPTY
123186: LIST
123187: LIST
123188: LIST
123189: LIST
123190: PUSH
123191: LD_VAR 0 2
123195: PUSH
123196: LD_INT 9
123198: MINUS
123199: ARRAY
123200: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
123201: LD_ADDR_OWVAR 45
123205: PUSH
123206: LD_INT 11
123208: PUSH
123209: LD_INT 15
123211: PUSH
123212: LD_INT 12
123214: PUSH
123215: LD_INT 15
123217: PUSH
123218: EMPTY
123219: LIST
123220: LIST
123221: LIST
123222: LIST
123223: PUSH
123224: LD_VAR 0 2
123228: PUSH
123229: LD_INT 9
123231: MINUS
123232: ARRAY
123233: ST_TO_ADDR
// end ; 14 :
123234: GO 123653
123236: LD_INT 14
123238: DOUBLE
123239: EQUAL
123240: IFTRUE 123244
123242: GO 123255
123244: POP
// bc_type := b_workshop ; 15 :
123245: LD_ADDR_OWVAR 42
123249: PUSH
123250: LD_INT 2
123252: ST_TO_ADDR
123253: GO 123653
123255: LD_INT 15
123257: DOUBLE
123258: EQUAL
123259: IFTRUE 123263
123261: GO 123274
123263: POP
// bc_type := b_factory ; 16 :
123264: LD_ADDR_OWVAR 42
123268: PUSH
123269: LD_INT 3
123271: ST_TO_ADDR
123272: GO 123653
123274: LD_INT 16
123276: DOUBLE
123277: EQUAL
123278: IFTRUE 123282
123280: GO 123293
123282: POP
// bc_type := b_ext_gun ; 17 :
123283: LD_ADDR_OWVAR 42
123287: PUSH
123288: LD_INT 17
123290: ST_TO_ADDR
123291: GO 123653
123293: LD_INT 17
123295: DOUBLE
123296: EQUAL
123297: IFTRUE 123301
123299: GO 123329
123301: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
123302: LD_ADDR_OWVAR 42
123306: PUSH
123307: LD_INT 19
123309: PUSH
123310: LD_INT 23
123312: PUSH
123313: LD_INT 19
123315: PUSH
123316: EMPTY
123317: LIST
123318: LIST
123319: LIST
123320: PUSH
123321: LD_VAR 0 1
123325: ARRAY
123326: ST_TO_ADDR
123327: GO 123653
123329: LD_INT 18
123331: DOUBLE
123332: EQUAL
123333: IFTRUE 123337
123335: GO 123348
123337: POP
// bc_type := b_ext_radar ; 19 :
123338: LD_ADDR_OWVAR 42
123342: PUSH
123343: LD_INT 20
123345: ST_TO_ADDR
123346: GO 123653
123348: LD_INT 19
123350: DOUBLE
123351: EQUAL
123352: IFTRUE 123356
123354: GO 123367
123356: POP
// bc_type := b_ext_radio ; 20 :
123357: LD_ADDR_OWVAR 42
123361: PUSH
123362: LD_INT 22
123364: ST_TO_ADDR
123365: GO 123653
123367: LD_INT 20
123369: DOUBLE
123370: EQUAL
123371: IFTRUE 123375
123373: GO 123386
123375: POP
// bc_type := b_ext_siberium ; 21 :
123376: LD_ADDR_OWVAR 42
123380: PUSH
123381: LD_INT 21
123383: ST_TO_ADDR
123384: GO 123653
123386: LD_INT 21
123388: DOUBLE
123389: EQUAL
123390: IFTRUE 123394
123392: GO 123405
123394: POP
// bc_type := b_ext_computer ; 22 :
123395: LD_ADDR_OWVAR 42
123399: PUSH
123400: LD_INT 24
123402: ST_TO_ADDR
123403: GO 123653
123405: LD_INT 22
123407: DOUBLE
123408: EQUAL
123409: IFTRUE 123413
123411: GO 123424
123413: POP
// bc_type := b_ext_track ; 23 :
123414: LD_ADDR_OWVAR 42
123418: PUSH
123419: LD_INT 16
123421: ST_TO_ADDR
123422: GO 123653
123424: LD_INT 23
123426: DOUBLE
123427: EQUAL
123428: IFTRUE 123432
123430: GO 123443
123432: POP
// bc_type := b_ext_laser ; 24 :
123433: LD_ADDR_OWVAR 42
123437: PUSH
123438: LD_INT 25
123440: ST_TO_ADDR
123441: GO 123653
123443: LD_INT 24
123445: DOUBLE
123446: EQUAL
123447: IFTRUE 123451
123449: GO 123462
123451: POP
// bc_type := b_control_tower ; 25 :
123452: LD_ADDR_OWVAR 42
123456: PUSH
123457: LD_INT 36
123459: ST_TO_ADDR
123460: GO 123653
123462: LD_INT 25
123464: DOUBLE
123465: EQUAL
123466: IFTRUE 123470
123468: GO 123481
123470: POP
// bc_type := b_breastwork ; 26 :
123471: LD_ADDR_OWVAR 42
123475: PUSH
123476: LD_INT 31
123478: ST_TO_ADDR
123479: GO 123653
123481: LD_INT 26
123483: DOUBLE
123484: EQUAL
123485: IFTRUE 123489
123487: GO 123500
123489: POP
// bc_type := b_bunker ; 27 :
123490: LD_ADDR_OWVAR 42
123494: PUSH
123495: LD_INT 32
123497: ST_TO_ADDR
123498: GO 123653
123500: LD_INT 27
123502: DOUBLE
123503: EQUAL
123504: IFTRUE 123508
123506: GO 123519
123508: POP
// bc_type := b_turret ; 28 :
123509: LD_ADDR_OWVAR 42
123513: PUSH
123514: LD_INT 33
123516: ST_TO_ADDR
123517: GO 123653
123519: LD_INT 28
123521: DOUBLE
123522: EQUAL
123523: IFTRUE 123527
123525: GO 123538
123527: POP
// bc_type := b_armoury ; 29 :
123528: LD_ADDR_OWVAR 42
123532: PUSH
123533: LD_INT 4
123535: ST_TO_ADDR
123536: GO 123653
123538: LD_INT 29
123540: DOUBLE
123541: EQUAL
123542: IFTRUE 123546
123544: GO 123557
123546: POP
// bc_type := b_barracks ; 30 :
123547: LD_ADDR_OWVAR 42
123551: PUSH
123552: LD_INT 5
123554: ST_TO_ADDR
123555: GO 123653
123557: LD_INT 30
123559: DOUBLE
123560: EQUAL
123561: IFTRUE 123565
123563: GO 123576
123565: POP
// bc_type := b_solar_power ; 31 :
123566: LD_ADDR_OWVAR 42
123570: PUSH
123571: LD_INT 27
123573: ST_TO_ADDR
123574: GO 123653
123576: LD_INT 31
123578: DOUBLE
123579: EQUAL
123580: IFTRUE 123584
123582: GO 123595
123584: POP
// bc_type := b_oil_power ; 32 :
123585: LD_ADDR_OWVAR 42
123589: PUSH
123590: LD_INT 26
123592: ST_TO_ADDR
123593: GO 123653
123595: LD_INT 32
123597: DOUBLE
123598: EQUAL
123599: IFTRUE 123603
123601: GO 123614
123603: POP
// bc_type := b_siberite_power ; 33 :
123604: LD_ADDR_OWVAR 42
123608: PUSH
123609: LD_INT 28
123611: ST_TO_ADDR
123612: GO 123653
123614: LD_INT 33
123616: DOUBLE
123617: EQUAL
123618: IFTRUE 123622
123620: GO 123633
123622: POP
// bc_type := b_oil_mine ; 34 :
123623: LD_ADDR_OWVAR 42
123627: PUSH
123628: LD_INT 29
123630: ST_TO_ADDR
123631: GO 123653
123633: LD_INT 34
123635: DOUBLE
123636: EQUAL
123637: IFTRUE 123641
123639: GO 123652
123641: POP
// bc_type := b_siberite_mine ; end ;
123642: LD_ADDR_OWVAR 42
123646: PUSH
123647: LD_INT 30
123649: ST_TO_ADDR
123650: GO 123653
123652: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
123653: LD_ADDR_VAR 0 8
123657: PUSH
123658: LD_VAR 0 5
123662: PPUSH
123663: LD_VAR 0 6
123667: PPUSH
123668: LD_VAR 0 3
123672: PPUSH
123673: CALL_OW 47
123677: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
123678: LD_OWVAR 42
123682: PUSH
123683: LD_INT 32
123685: PUSH
123686: LD_INT 33
123688: PUSH
123689: EMPTY
123690: LIST
123691: LIST
123692: IN
123693: IFFALSE 123709
// PlaceWeaponTurret ( b , weapon ) ;
123695: LD_VAR 0 8
123699: PPUSH
123700: LD_VAR 0 4
123704: PPUSH
123705: CALL_OW 431
// end ;
123709: LD_VAR 0 7
123713: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
123714: LD_INT 0
123716: PPUSH
123717: PPUSH
123718: PPUSH
123719: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
123720: LD_ADDR_VAR 0 4
123724: PUSH
123725: LD_INT 22
123727: PUSH
123728: LD_OWVAR 2
123732: PUSH
123733: EMPTY
123734: LIST
123735: LIST
123736: PUSH
123737: LD_INT 2
123739: PUSH
123740: LD_INT 30
123742: PUSH
123743: LD_INT 0
123745: PUSH
123746: EMPTY
123747: LIST
123748: LIST
123749: PUSH
123750: LD_INT 30
123752: PUSH
123753: LD_INT 1
123755: PUSH
123756: EMPTY
123757: LIST
123758: LIST
123759: PUSH
123760: EMPTY
123761: LIST
123762: LIST
123763: LIST
123764: PUSH
123765: EMPTY
123766: LIST
123767: LIST
123768: PPUSH
123769: CALL_OW 69
123773: ST_TO_ADDR
// if not tmp then
123774: LD_VAR 0 4
123778: NOT
123779: IFFALSE 123783
// exit ;
123781: GO 123842
// for i in tmp do
123783: LD_ADDR_VAR 0 2
123787: PUSH
123788: LD_VAR 0 4
123792: PUSH
123793: FOR_IN
123794: IFFALSE 123840
// for j = 1 to 3 do
123796: LD_ADDR_VAR 0 3
123800: PUSH
123801: DOUBLE
123802: LD_INT 1
123804: DEC
123805: ST_TO_ADDR
123806: LD_INT 3
123808: PUSH
123809: FOR_TO
123810: IFFALSE 123836
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
123812: LD_VAR 0 2
123816: PPUSH
123817: CALL_OW 274
123821: PPUSH
123822: LD_VAR 0 3
123826: PPUSH
123827: LD_INT 99999
123829: PPUSH
123830: CALL_OW 277
123834: GO 123809
123836: POP
123837: POP
123838: GO 123793
123840: POP
123841: POP
// end ;
123842: LD_VAR 0 1
123846: RET
// export function hHackSetLevel10 ; var i , j ; begin
123847: LD_INT 0
123849: PPUSH
123850: PPUSH
123851: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
123852: LD_ADDR_VAR 0 2
123856: PUSH
123857: LD_INT 21
123859: PUSH
123860: LD_INT 1
123862: PUSH
123863: EMPTY
123864: LIST
123865: LIST
123866: PPUSH
123867: CALL_OW 69
123871: PUSH
123872: FOR_IN
123873: IFFALSE 123925
// if IsSelected ( i ) then
123875: LD_VAR 0 2
123879: PPUSH
123880: CALL_OW 306
123884: IFFALSE 123923
// begin for j := 1 to 4 do
123886: LD_ADDR_VAR 0 3
123890: PUSH
123891: DOUBLE
123892: LD_INT 1
123894: DEC
123895: ST_TO_ADDR
123896: LD_INT 4
123898: PUSH
123899: FOR_TO
123900: IFFALSE 123921
// SetSkill ( i , j , 10 ) ;
123902: LD_VAR 0 2
123906: PPUSH
123907: LD_VAR 0 3
123911: PPUSH
123912: LD_INT 10
123914: PPUSH
123915: CALL_OW 237
123919: GO 123899
123921: POP
123922: POP
// end ;
123923: GO 123872
123925: POP
123926: POP
// end ;
123927: LD_VAR 0 1
123931: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
123932: LD_INT 0
123934: PPUSH
123935: PPUSH
123936: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
123937: LD_ADDR_VAR 0 2
123941: PUSH
123942: LD_INT 22
123944: PUSH
123945: LD_OWVAR 2
123949: PUSH
123950: EMPTY
123951: LIST
123952: LIST
123953: PUSH
123954: LD_INT 21
123956: PUSH
123957: LD_INT 1
123959: PUSH
123960: EMPTY
123961: LIST
123962: LIST
123963: PUSH
123964: EMPTY
123965: LIST
123966: LIST
123967: PPUSH
123968: CALL_OW 69
123972: PUSH
123973: FOR_IN
123974: IFFALSE 124015
// begin for j := 1 to 4 do
123976: LD_ADDR_VAR 0 3
123980: PUSH
123981: DOUBLE
123982: LD_INT 1
123984: DEC
123985: ST_TO_ADDR
123986: LD_INT 4
123988: PUSH
123989: FOR_TO
123990: IFFALSE 124011
// SetSkill ( i , j , 10 ) ;
123992: LD_VAR 0 2
123996: PPUSH
123997: LD_VAR 0 3
124001: PPUSH
124002: LD_INT 10
124004: PPUSH
124005: CALL_OW 237
124009: GO 123989
124011: POP
124012: POP
// end ;
124013: GO 123973
124015: POP
124016: POP
// end ;
124017: LD_VAR 0 1
124021: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
124022: LD_INT 0
124024: PPUSH
// uc_side := your_side ;
124025: LD_ADDR_OWVAR 20
124029: PUSH
124030: LD_OWVAR 2
124034: ST_TO_ADDR
// uc_nation := nation ;
124035: LD_ADDR_OWVAR 21
124039: PUSH
124040: LD_VAR 0 1
124044: ST_TO_ADDR
// InitHc ;
124045: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
124049: LD_INT 0
124051: PPUSH
124052: LD_VAR 0 2
124056: PPUSH
124057: LD_VAR 0 3
124061: PPUSH
124062: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
124066: LD_VAR 0 4
124070: PPUSH
124071: LD_VAR 0 5
124075: PPUSH
124076: CALL_OW 428
124080: PUSH
124081: LD_INT 0
124083: EQUAL
124084: IFFALSE 124108
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
124086: CALL_OW 44
124090: PPUSH
124091: LD_VAR 0 4
124095: PPUSH
124096: LD_VAR 0 5
124100: PPUSH
124101: LD_INT 1
124103: PPUSH
124104: CALL_OW 48
// end ;
124108: LD_VAR 0 6
124112: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
124113: LD_INT 0
124115: PPUSH
124116: PPUSH
// uc_side := your_side ;
124117: LD_ADDR_OWVAR 20
124121: PUSH
124122: LD_OWVAR 2
124126: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
124127: LD_VAR 0 1
124131: PUSH
124132: LD_INT 1
124134: PUSH
124135: LD_INT 2
124137: PUSH
124138: LD_INT 3
124140: PUSH
124141: LD_INT 4
124143: PUSH
124144: LD_INT 5
124146: PUSH
124147: EMPTY
124148: LIST
124149: LIST
124150: LIST
124151: LIST
124152: LIST
124153: IN
124154: IFFALSE 124166
// uc_nation := nation_american else
124156: LD_ADDR_OWVAR 21
124160: PUSH
124161: LD_INT 1
124163: ST_TO_ADDR
124164: GO 124209
// if chassis in [ 11 , 12 , 13 , 14 ] then
124166: LD_VAR 0 1
124170: PUSH
124171: LD_INT 11
124173: PUSH
124174: LD_INT 12
124176: PUSH
124177: LD_INT 13
124179: PUSH
124180: LD_INT 14
124182: PUSH
124183: EMPTY
124184: LIST
124185: LIST
124186: LIST
124187: LIST
124188: IN
124189: IFFALSE 124201
// uc_nation := nation_arabian else
124191: LD_ADDR_OWVAR 21
124195: PUSH
124196: LD_INT 2
124198: ST_TO_ADDR
124199: GO 124209
// uc_nation := nation_russian ;
124201: LD_ADDR_OWVAR 21
124205: PUSH
124206: LD_INT 3
124208: ST_TO_ADDR
// vc_chassis := chassis ;
124209: LD_ADDR_OWVAR 37
124213: PUSH
124214: LD_VAR 0 1
124218: ST_TO_ADDR
// vc_engine := engine ;
124219: LD_ADDR_OWVAR 39
124223: PUSH
124224: LD_VAR 0 2
124228: ST_TO_ADDR
// vc_control := control ;
124229: LD_ADDR_OWVAR 38
124233: PUSH
124234: LD_VAR 0 3
124238: ST_TO_ADDR
// vc_weapon := weapon ;
124239: LD_ADDR_OWVAR 40
124243: PUSH
124244: LD_VAR 0 4
124248: ST_TO_ADDR
// un := CreateVehicle ;
124249: LD_ADDR_VAR 0 8
124253: PUSH
124254: CALL_OW 45
124258: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
124259: LD_VAR 0 8
124263: PPUSH
124264: LD_INT 0
124266: PPUSH
124267: LD_INT 5
124269: PPUSH
124270: CALL_OW 12
124274: PPUSH
124275: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
124279: LD_VAR 0 8
124283: PPUSH
124284: LD_VAR 0 5
124288: PPUSH
124289: LD_VAR 0 6
124293: PPUSH
124294: LD_INT 1
124296: PPUSH
124297: CALL_OW 48
// end ;
124301: LD_VAR 0 7
124305: RET
// export hInvincible ; every 1 do
124306: GO 124308
124308: DISABLE
// hInvincible := [ ] ;
124309: LD_ADDR_EXP 203
124313: PUSH
124314: EMPTY
124315: ST_TO_ADDR
124316: END
// every 10 do var i ;
124317: GO 124319
124319: DISABLE
124320: LD_INT 0
124322: PPUSH
// begin enable ;
124323: ENABLE
// if not hInvincible then
124324: LD_EXP 203
124328: NOT
124329: IFFALSE 124333
// exit ;
124331: GO 124377
// for i in hInvincible do
124333: LD_ADDR_VAR 0 1
124337: PUSH
124338: LD_EXP 203
124342: PUSH
124343: FOR_IN
124344: IFFALSE 124375
// if GetLives ( i ) < 1000 then
124346: LD_VAR 0 1
124350: PPUSH
124351: CALL_OW 256
124355: PUSH
124356: LD_INT 1000
124358: LESS
124359: IFFALSE 124373
// SetLives ( i , 1000 ) ;
124361: LD_VAR 0 1
124365: PPUSH
124366: LD_INT 1000
124368: PPUSH
124369: CALL_OW 234
124373: GO 124343
124375: POP
124376: POP
// end ;
124377: PPOPN 1
124379: END
// export function hHackInvincible ; var i ; begin
124380: LD_INT 0
124382: PPUSH
124383: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
124384: LD_ADDR_VAR 0 2
124388: PUSH
124389: LD_INT 2
124391: PUSH
124392: LD_INT 21
124394: PUSH
124395: LD_INT 1
124397: PUSH
124398: EMPTY
124399: LIST
124400: LIST
124401: PUSH
124402: LD_INT 21
124404: PUSH
124405: LD_INT 2
124407: PUSH
124408: EMPTY
124409: LIST
124410: LIST
124411: PUSH
124412: EMPTY
124413: LIST
124414: LIST
124415: LIST
124416: PPUSH
124417: CALL_OW 69
124421: PUSH
124422: FOR_IN
124423: IFFALSE 124484
// if IsSelected ( i ) then
124425: LD_VAR 0 2
124429: PPUSH
124430: CALL_OW 306
124434: IFFALSE 124482
// begin if i in hInvincible then
124436: LD_VAR 0 2
124440: PUSH
124441: LD_EXP 203
124445: IN
124446: IFFALSE 124466
// hInvincible := hInvincible diff i else
124448: LD_ADDR_EXP 203
124452: PUSH
124453: LD_EXP 203
124457: PUSH
124458: LD_VAR 0 2
124462: DIFF
124463: ST_TO_ADDR
124464: GO 124482
// hInvincible := hInvincible union i ;
124466: LD_ADDR_EXP 203
124470: PUSH
124471: LD_EXP 203
124475: PUSH
124476: LD_VAR 0 2
124480: UNION
124481: ST_TO_ADDR
// end ;
124482: GO 124422
124484: POP
124485: POP
// end ;
124486: LD_VAR 0 1
124490: RET
// export function hHackInvisible ; var i , j ; begin
124491: LD_INT 0
124493: PPUSH
124494: PPUSH
124495: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
124496: LD_ADDR_VAR 0 2
124500: PUSH
124501: LD_INT 21
124503: PUSH
124504: LD_INT 1
124506: PUSH
124507: EMPTY
124508: LIST
124509: LIST
124510: PPUSH
124511: CALL_OW 69
124515: PUSH
124516: FOR_IN
124517: IFFALSE 124541
// if IsSelected ( i ) then
124519: LD_VAR 0 2
124523: PPUSH
124524: CALL_OW 306
124528: IFFALSE 124539
// ComForceInvisible ( i ) ;
124530: LD_VAR 0 2
124534: PPUSH
124535: CALL_OW 496
124539: GO 124516
124541: POP
124542: POP
// end ;
124543: LD_VAR 0 1
124547: RET
// export function hHackChangeYourSide ; begin
124548: LD_INT 0
124550: PPUSH
// if your_side = 8 then
124551: LD_OWVAR 2
124555: PUSH
124556: LD_INT 8
124558: EQUAL
124559: IFFALSE 124571
// your_side := 0 else
124561: LD_ADDR_OWVAR 2
124565: PUSH
124566: LD_INT 0
124568: ST_TO_ADDR
124569: GO 124585
// your_side := your_side + 1 ;
124571: LD_ADDR_OWVAR 2
124575: PUSH
124576: LD_OWVAR 2
124580: PUSH
124581: LD_INT 1
124583: PLUS
124584: ST_TO_ADDR
// end ;
124585: LD_VAR 0 1
124589: RET
// export function hHackChangeUnitSide ; var i , j ; begin
124590: LD_INT 0
124592: PPUSH
124593: PPUSH
124594: PPUSH
// for i in all_units do
124595: LD_ADDR_VAR 0 2
124599: PUSH
124600: LD_OWVAR 3
124604: PUSH
124605: FOR_IN
124606: IFFALSE 124684
// if IsSelected ( i ) then
124608: LD_VAR 0 2
124612: PPUSH
124613: CALL_OW 306
124617: IFFALSE 124682
// begin j := GetSide ( i ) ;
124619: LD_ADDR_VAR 0 3
124623: PUSH
124624: LD_VAR 0 2
124628: PPUSH
124629: CALL_OW 255
124633: ST_TO_ADDR
// if j = 8 then
124634: LD_VAR 0 3
124638: PUSH
124639: LD_INT 8
124641: EQUAL
124642: IFFALSE 124654
// j := 0 else
124644: LD_ADDR_VAR 0 3
124648: PUSH
124649: LD_INT 0
124651: ST_TO_ADDR
124652: GO 124668
// j := j + 1 ;
124654: LD_ADDR_VAR 0 3
124658: PUSH
124659: LD_VAR 0 3
124663: PUSH
124664: LD_INT 1
124666: PLUS
124667: ST_TO_ADDR
// SetSide ( i , j ) ;
124668: LD_VAR 0 2
124672: PPUSH
124673: LD_VAR 0 3
124677: PPUSH
124678: CALL_OW 235
// end ;
124682: GO 124605
124684: POP
124685: POP
// end ;
124686: LD_VAR 0 1
124690: RET
// export function hHackFog ; begin
124691: LD_INT 0
124693: PPUSH
// FogOff ( true ) ;
124694: LD_INT 1
124696: PPUSH
124697: CALL_OW 344
// end ;
124701: LD_VAR 0 1
124705: RET
// export function hHackTeleport ( unit , x , y ) ; begin
124706: LD_INT 0
124708: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
124709: LD_VAR 0 1
124713: PPUSH
124714: LD_VAR 0 2
124718: PPUSH
124719: LD_VAR 0 3
124723: PPUSH
124724: LD_INT 1
124726: PPUSH
124727: LD_INT 1
124729: PPUSH
124730: CALL_OW 483
// CenterOnXY ( x , y ) ;
124734: LD_VAR 0 2
124738: PPUSH
124739: LD_VAR 0 3
124743: PPUSH
124744: CALL_OW 84
// end ;
124748: LD_VAR 0 4
124752: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
124753: LD_INT 0
124755: PPUSH
124756: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
124757: LD_VAR 0 1
124761: NOT
124762: PUSH
124763: LD_VAR 0 2
124767: PPUSH
124768: LD_VAR 0 3
124772: PPUSH
124773: CALL_OW 488
124777: NOT
124778: OR
124779: PUSH
124780: LD_VAR 0 1
124784: PPUSH
124785: CALL_OW 266
124789: PUSH
124790: LD_INT 3
124792: NONEQUAL
124793: PUSH
124794: LD_VAR 0 1
124798: PPUSH
124799: CALL_OW 247
124803: PUSH
124804: LD_INT 1
124806: EQUAL
124807: NOT
124808: AND
124809: OR
124810: IFFALSE 124814
// exit ;
124812: GO 124963
// if GetType ( factory ) = unit_human then
124814: LD_VAR 0 1
124818: PPUSH
124819: CALL_OW 247
124823: PUSH
124824: LD_INT 1
124826: EQUAL
124827: IFFALSE 124844
// factory := IsInUnit ( factory ) ;
124829: LD_ADDR_VAR 0 1
124833: PUSH
124834: LD_VAR 0 1
124838: PPUSH
124839: CALL_OW 310
124843: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
124844: LD_VAR 0 1
124848: PPUSH
124849: CALL_OW 266
124853: PUSH
124854: LD_INT 3
124856: NONEQUAL
124857: IFFALSE 124861
// exit ;
124859: GO 124963
// if HexInfo ( x , y ) = factory then
124861: LD_VAR 0 2
124865: PPUSH
124866: LD_VAR 0 3
124870: PPUSH
124871: CALL_OW 428
124875: PUSH
124876: LD_VAR 0 1
124880: EQUAL
124881: IFFALSE 124908
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
124883: LD_ADDR_EXP 204
124887: PUSH
124888: LD_EXP 204
124892: PPUSH
124893: LD_VAR 0 1
124897: PPUSH
124898: LD_INT 0
124900: PPUSH
124901: CALL_OW 1
124905: ST_TO_ADDR
124906: GO 124959
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
124908: LD_ADDR_EXP 204
124912: PUSH
124913: LD_EXP 204
124917: PPUSH
124918: LD_VAR 0 1
124922: PPUSH
124923: LD_VAR 0 1
124927: PPUSH
124928: CALL_OW 255
124932: PUSH
124933: LD_VAR 0 1
124937: PUSH
124938: LD_VAR 0 2
124942: PUSH
124943: LD_VAR 0 3
124947: PUSH
124948: EMPTY
124949: LIST
124950: LIST
124951: LIST
124952: LIST
124953: PPUSH
124954: CALL_OW 1
124958: ST_TO_ADDR
// UpdateFactoryWaypoints ;
124959: CALL 124968 0 0
// end ;
124963: LD_VAR 0 4
124967: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
124968: LD_INT 0
124970: PPUSH
124971: PPUSH
124972: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
124973: LD_STRING resetFactoryWaypoint();
124975: PPUSH
124976: CALL_OW 559
// if factoryWaypoints then
124980: LD_EXP 204
124984: IFFALSE 125110
// begin list := PrepareArray ( factoryWaypoints ) ;
124986: LD_ADDR_VAR 0 3
124990: PUSH
124991: LD_EXP 204
124995: PPUSH
124996: CALL 109948 0 1
125000: ST_TO_ADDR
// for i := 1 to list do
125001: LD_ADDR_VAR 0 2
125005: PUSH
125006: DOUBLE
125007: LD_INT 1
125009: DEC
125010: ST_TO_ADDR
125011: LD_VAR 0 3
125015: PUSH
125016: FOR_TO
125017: IFFALSE 125108
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
125019: LD_STRING setFactoryWaypointXY(
125021: PUSH
125022: LD_VAR 0 3
125026: PUSH
125027: LD_VAR 0 2
125031: ARRAY
125032: PUSH
125033: LD_INT 1
125035: ARRAY
125036: STR
125037: PUSH
125038: LD_STRING ,
125040: STR
125041: PUSH
125042: LD_VAR 0 3
125046: PUSH
125047: LD_VAR 0 2
125051: ARRAY
125052: PUSH
125053: LD_INT 2
125055: ARRAY
125056: STR
125057: PUSH
125058: LD_STRING ,
125060: STR
125061: PUSH
125062: LD_VAR 0 3
125066: PUSH
125067: LD_VAR 0 2
125071: ARRAY
125072: PUSH
125073: LD_INT 3
125075: ARRAY
125076: STR
125077: PUSH
125078: LD_STRING ,
125080: STR
125081: PUSH
125082: LD_VAR 0 3
125086: PUSH
125087: LD_VAR 0 2
125091: ARRAY
125092: PUSH
125093: LD_INT 4
125095: ARRAY
125096: STR
125097: PUSH
125098: LD_STRING )
125100: STR
125101: PPUSH
125102: CALL_OW 559
125106: GO 125016
125108: POP
125109: POP
// end ; end ;
125110: LD_VAR 0 1
125114: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
125115: LD_INT 0
125117: PPUSH
// if HexInfo ( x , y ) = warehouse then
125118: LD_VAR 0 2
125122: PPUSH
125123: LD_VAR 0 3
125127: PPUSH
125128: CALL_OW 428
125132: PUSH
125133: LD_VAR 0 1
125137: EQUAL
125138: IFFALSE 125165
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
125140: LD_ADDR_EXP 205
125144: PUSH
125145: LD_EXP 205
125149: PPUSH
125150: LD_VAR 0 1
125154: PPUSH
125155: LD_INT 0
125157: PPUSH
125158: CALL_OW 1
125162: ST_TO_ADDR
125163: GO 125216
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
125165: LD_ADDR_EXP 205
125169: PUSH
125170: LD_EXP 205
125174: PPUSH
125175: LD_VAR 0 1
125179: PPUSH
125180: LD_VAR 0 1
125184: PPUSH
125185: CALL_OW 255
125189: PUSH
125190: LD_VAR 0 1
125194: PUSH
125195: LD_VAR 0 2
125199: PUSH
125200: LD_VAR 0 3
125204: PUSH
125205: EMPTY
125206: LIST
125207: LIST
125208: LIST
125209: LIST
125210: PPUSH
125211: CALL_OW 1
125215: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
125216: CALL 125225 0 0
// end ;
125220: LD_VAR 0 4
125224: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
125225: LD_INT 0
125227: PPUSH
125228: PPUSH
125229: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
125230: LD_STRING resetWarehouseGatheringPoints();
125232: PPUSH
125233: CALL_OW 559
// if warehouseGatheringPoints then
125237: LD_EXP 205
125241: IFFALSE 125367
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
125243: LD_ADDR_VAR 0 3
125247: PUSH
125248: LD_EXP 205
125252: PPUSH
125253: CALL 109948 0 1
125257: ST_TO_ADDR
// for i := 1 to list do
125258: LD_ADDR_VAR 0 2
125262: PUSH
125263: DOUBLE
125264: LD_INT 1
125266: DEC
125267: ST_TO_ADDR
125268: LD_VAR 0 3
125272: PUSH
125273: FOR_TO
125274: IFFALSE 125365
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
125276: LD_STRING setWarehouseGatheringPointXY(
125278: PUSH
125279: LD_VAR 0 3
125283: PUSH
125284: LD_VAR 0 2
125288: ARRAY
125289: PUSH
125290: LD_INT 1
125292: ARRAY
125293: STR
125294: PUSH
125295: LD_STRING ,
125297: STR
125298: PUSH
125299: LD_VAR 0 3
125303: PUSH
125304: LD_VAR 0 2
125308: ARRAY
125309: PUSH
125310: LD_INT 2
125312: ARRAY
125313: STR
125314: PUSH
125315: LD_STRING ,
125317: STR
125318: PUSH
125319: LD_VAR 0 3
125323: PUSH
125324: LD_VAR 0 2
125328: ARRAY
125329: PUSH
125330: LD_INT 3
125332: ARRAY
125333: STR
125334: PUSH
125335: LD_STRING ,
125337: STR
125338: PUSH
125339: LD_VAR 0 3
125343: PUSH
125344: LD_VAR 0 2
125348: ARRAY
125349: PUSH
125350: LD_INT 4
125352: ARRAY
125353: STR
125354: PUSH
125355: LD_STRING )
125357: STR
125358: PPUSH
125359: CALL_OW 559
125363: GO 125273
125365: POP
125366: POP
// end ; end ;
125367: LD_VAR 0 1
125371: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
125372: LD_EXP 205
125376: IFFALSE 126061
125378: GO 125380
125380: DISABLE
125381: LD_INT 0
125383: PPUSH
125384: PPUSH
125385: PPUSH
125386: PPUSH
125387: PPUSH
125388: PPUSH
125389: PPUSH
125390: PPUSH
125391: PPUSH
// begin enable ;
125392: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
125393: LD_ADDR_VAR 0 3
125397: PUSH
125398: LD_EXP 205
125402: PPUSH
125403: CALL 109948 0 1
125407: ST_TO_ADDR
// if not list then
125408: LD_VAR 0 3
125412: NOT
125413: IFFALSE 125417
// exit ;
125415: GO 126061
// for i := 1 to list do
125417: LD_ADDR_VAR 0 1
125421: PUSH
125422: DOUBLE
125423: LD_INT 1
125425: DEC
125426: ST_TO_ADDR
125427: LD_VAR 0 3
125431: PUSH
125432: FOR_TO
125433: IFFALSE 126059
// begin depot := list [ i ] [ 2 ] ;
125435: LD_ADDR_VAR 0 8
125439: PUSH
125440: LD_VAR 0 3
125444: PUSH
125445: LD_VAR 0 1
125449: ARRAY
125450: PUSH
125451: LD_INT 2
125453: ARRAY
125454: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
125455: LD_ADDR_VAR 0 5
125459: PUSH
125460: LD_VAR 0 3
125464: PUSH
125465: LD_VAR 0 1
125469: ARRAY
125470: PUSH
125471: LD_INT 1
125473: ARRAY
125474: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
125475: LD_VAR 0 8
125479: PPUSH
125480: CALL_OW 301
125484: PUSH
125485: LD_VAR 0 5
125489: PUSH
125490: LD_VAR 0 8
125494: PPUSH
125495: CALL_OW 255
125499: NONEQUAL
125500: OR
125501: IFFALSE 125530
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
125503: LD_ADDR_EXP 205
125507: PUSH
125508: LD_EXP 205
125512: PPUSH
125513: LD_VAR 0 8
125517: PPUSH
125518: LD_INT 0
125520: PPUSH
125521: CALL_OW 1
125525: ST_TO_ADDR
// exit ;
125526: POP
125527: POP
125528: GO 126061
// end ; x := list [ i ] [ 3 ] ;
125530: LD_ADDR_VAR 0 6
125534: PUSH
125535: LD_VAR 0 3
125539: PUSH
125540: LD_VAR 0 1
125544: ARRAY
125545: PUSH
125546: LD_INT 3
125548: ARRAY
125549: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
125550: LD_ADDR_VAR 0 7
125554: PUSH
125555: LD_VAR 0 3
125559: PUSH
125560: LD_VAR 0 1
125564: ARRAY
125565: PUSH
125566: LD_INT 4
125568: ARRAY
125569: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
125570: LD_ADDR_VAR 0 9
125574: PUSH
125575: LD_VAR 0 6
125579: PPUSH
125580: LD_VAR 0 7
125584: PPUSH
125585: LD_INT 16
125587: PPUSH
125588: CALL 108536 0 3
125592: ST_TO_ADDR
// if not cratesNearbyPoint then
125593: LD_VAR 0 9
125597: NOT
125598: IFFALSE 125604
// exit ;
125600: POP
125601: POP
125602: GO 126061
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
125604: LD_ADDR_VAR 0 4
125608: PUSH
125609: LD_INT 22
125611: PUSH
125612: LD_VAR 0 5
125616: PUSH
125617: EMPTY
125618: LIST
125619: LIST
125620: PUSH
125621: LD_INT 3
125623: PUSH
125624: LD_INT 60
125626: PUSH
125627: EMPTY
125628: LIST
125629: PUSH
125630: EMPTY
125631: LIST
125632: LIST
125633: PUSH
125634: LD_INT 91
125636: PUSH
125637: LD_VAR 0 8
125641: PUSH
125642: LD_INT 6
125644: PUSH
125645: EMPTY
125646: LIST
125647: LIST
125648: LIST
125649: PUSH
125650: LD_INT 2
125652: PUSH
125653: LD_INT 25
125655: PUSH
125656: LD_INT 2
125658: PUSH
125659: EMPTY
125660: LIST
125661: LIST
125662: PUSH
125663: LD_INT 25
125665: PUSH
125666: LD_INT 16
125668: PUSH
125669: EMPTY
125670: LIST
125671: LIST
125672: PUSH
125673: EMPTY
125674: LIST
125675: LIST
125676: LIST
125677: PUSH
125678: EMPTY
125679: LIST
125680: LIST
125681: LIST
125682: LIST
125683: PPUSH
125684: CALL_OW 69
125688: PUSH
125689: LD_VAR 0 8
125693: PPUSH
125694: CALL_OW 313
125698: PPUSH
125699: LD_INT 3
125701: PUSH
125702: LD_INT 60
125704: PUSH
125705: EMPTY
125706: LIST
125707: PUSH
125708: EMPTY
125709: LIST
125710: LIST
125711: PUSH
125712: LD_INT 2
125714: PUSH
125715: LD_INT 25
125717: PUSH
125718: LD_INT 2
125720: PUSH
125721: EMPTY
125722: LIST
125723: LIST
125724: PUSH
125725: LD_INT 25
125727: PUSH
125728: LD_INT 16
125730: PUSH
125731: EMPTY
125732: LIST
125733: LIST
125734: PUSH
125735: EMPTY
125736: LIST
125737: LIST
125738: LIST
125739: PUSH
125740: EMPTY
125741: LIST
125742: LIST
125743: PPUSH
125744: CALL_OW 72
125748: UNION
125749: ST_TO_ADDR
// if tmp then
125750: LD_VAR 0 4
125754: IFFALSE 125834
// begin tmp := ShrinkArray ( tmp , 3 ) ;
125756: LD_ADDR_VAR 0 4
125760: PUSH
125761: LD_VAR 0 4
125765: PPUSH
125766: LD_INT 3
125768: PPUSH
125769: CALL 106505 0 2
125773: ST_TO_ADDR
// for j in tmp do
125774: LD_ADDR_VAR 0 2
125778: PUSH
125779: LD_VAR 0 4
125783: PUSH
125784: FOR_IN
125785: IFFALSE 125828
// begin if IsInUnit ( j ) then
125787: LD_VAR 0 2
125791: PPUSH
125792: CALL_OW 310
125796: IFFALSE 125807
// ComExit ( j ) ;
125798: LD_VAR 0 2
125802: PPUSH
125803: CALL 106588 0 1
// AddComCollect ( j , x , y ) ;
125807: LD_VAR 0 2
125811: PPUSH
125812: LD_VAR 0 6
125816: PPUSH
125817: LD_VAR 0 7
125821: PPUSH
125822: CALL_OW 177
// end ;
125826: GO 125784
125828: POP
125829: POP
// exit ;
125830: POP
125831: POP
125832: GO 126061
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
125834: LD_ADDR_VAR 0 4
125838: PUSH
125839: LD_INT 22
125841: PUSH
125842: LD_VAR 0 5
125846: PUSH
125847: EMPTY
125848: LIST
125849: LIST
125850: PUSH
125851: LD_INT 91
125853: PUSH
125854: LD_VAR 0 8
125858: PUSH
125859: LD_INT 8
125861: PUSH
125862: EMPTY
125863: LIST
125864: LIST
125865: LIST
125866: PUSH
125867: LD_INT 2
125869: PUSH
125870: LD_INT 34
125872: PUSH
125873: LD_INT 12
125875: PUSH
125876: EMPTY
125877: LIST
125878: LIST
125879: PUSH
125880: LD_INT 34
125882: PUSH
125883: LD_INT 51
125885: PUSH
125886: EMPTY
125887: LIST
125888: LIST
125889: PUSH
125890: LD_INT 34
125892: PUSH
125893: LD_INT 32
125895: PUSH
125896: EMPTY
125897: LIST
125898: LIST
125899: PUSH
125900: LD_INT 34
125902: PUSH
125903: LD_INT 89
125905: PUSH
125906: EMPTY
125907: LIST
125908: LIST
125909: PUSH
125910: EMPTY
125911: LIST
125912: LIST
125913: LIST
125914: LIST
125915: LIST
125916: PUSH
125917: EMPTY
125918: LIST
125919: LIST
125920: LIST
125921: PPUSH
125922: CALL_OW 69
125926: ST_TO_ADDR
// if tmp then
125927: LD_VAR 0 4
125931: IFFALSE 126057
// begin for j in tmp do
125933: LD_ADDR_VAR 0 2
125937: PUSH
125938: LD_VAR 0 4
125942: PUSH
125943: FOR_IN
125944: IFFALSE 126055
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
125946: LD_VAR 0 2
125950: PPUSH
125951: CALL_OW 262
125955: PUSH
125956: LD_INT 3
125958: EQUAL
125959: PUSH
125960: LD_VAR 0 2
125964: PPUSH
125965: CALL_OW 261
125969: PUSH
125970: LD_INT 20
125972: GREATER
125973: OR
125974: PUSH
125975: LD_VAR 0 2
125979: PPUSH
125980: CALL_OW 314
125984: NOT
125985: AND
125986: PUSH
125987: LD_VAR 0 2
125991: PPUSH
125992: CALL_OW 263
125996: PUSH
125997: LD_INT 1
125999: NONEQUAL
126000: PUSH
126001: LD_VAR 0 2
126005: PPUSH
126006: CALL_OW 311
126010: OR
126011: AND
126012: IFFALSE 126053
// begin ComCollect ( j , x , y ) ;
126014: LD_VAR 0 2
126018: PPUSH
126019: LD_VAR 0 6
126023: PPUSH
126024: LD_VAR 0 7
126028: PPUSH
126029: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
126033: LD_VAR 0 2
126037: PPUSH
126038: LD_VAR 0 8
126042: PPUSH
126043: CALL_OW 172
// exit ;
126047: POP
126048: POP
126049: POP
126050: POP
126051: GO 126061
// end ;
126053: GO 125943
126055: POP
126056: POP
// end ; end ;
126057: GO 125432
126059: POP
126060: POP
// end ; end_of_file
126061: PPOPN 9
126063: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
126064: LD_INT 0
126066: PPUSH
126067: PPUSH
126068: PPUSH
126069: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
126070: LD_VAR 0 1
126074: PPUSH
126075: CALL_OW 264
126079: PUSH
126080: LD_INT 91
126082: EQUAL
126083: IFFALSE 126155
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
126085: LD_INT 68
126087: PPUSH
126088: LD_VAR 0 1
126092: PPUSH
126093: CALL_OW 255
126097: PPUSH
126098: CALL_OW 321
126102: PUSH
126103: LD_INT 2
126105: EQUAL
126106: IFFALSE 126118
// eff := 70 else
126108: LD_ADDR_VAR 0 4
126112: PUSH
126113: LD_INT 70
126115: ST_TO_ADDR
126116: GO 126126
// eff := 30 ;
126118: LD_ADDR_VAR 0 4
126122: PUSH
126123: LD_INT 30
126125: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
126126: LD_VAR 0 1
126130: PPUSH
126131: CALL_OW 250
126135: PPUSH
126136: LD_VAR 0 1
126140: PPUSH
126141: CALL_OW 251
126145: PPUSH
126146: LD_VAR 0 4
126150: PPUSH
126151: CALL_OW 495
// end ; end ;
126155: LD_VAR 0 2
126159: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
126160: LD_INT 0
126162: PPUSH
// end ;
126163: LD_VAR 0 4
126167: RET
// export function SOS_Command ( cmd ) ; begin
126168: LD_INT 0
126170: PPUSH
// end ;
126171: LD_VAR 0 2
126175: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
126176: LD_INT 0
126178: PPUSH
// end ;
126179: LD_VAR 0 6
126183: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
126184: LD_INT 0
126186: PPUSH
126187: PPUSH
// if not vehicle or not factory then
126188: LD_VAR 0 1
126192: NOT
126193: PUSH
126194: LD_VAR 0 2
126198: NOT
126199: OR
126200: IFFALSE 126204
// exit ;
126202: GO 126435
// if factoryWaypoints >= factory then
126204: LD_EXP 204
126208: PUSH
126209: LD_VAR 0 2
126213: GREATEREQUAL
126214: IFFALSE 126435
// if factoryWaypoints [ factory ] then
126216: LD_EXP 204
126220: PUSH
126221: LD_VAR 0 2
126225: ARRAY
126226: IFFALSE 126435
// begin if GetControl ( vehicle ) = control_manual then
126228: LD_VAR 0 1
126232: PPUSH
126233: CALL_OW 263
126237: PUSH
126238: LD_INT 1
126240: EQUAL
126241: IFFALSE 126322
// begin driver := IsDrivenBy ( vehicle ) ;
126243: LD_ADDR_VAR 0 4
126247: PUSH
126248: LD_VAR 0 1
126252: PPUSH
126253: CALL_OW 311
126257: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
126258: LD_VAR 0 4
126262: PPUSH
126263: LD_EXP 204
126267: PUSH
126268: LD_VAR 0 2
126272: ARRAY
126273: PUSH
126274: LD_INT 3
126276: ARRAY
126277: PPUSH
126278: LD_EXP 204
126282: PUSH
126283: LD_VAR 0 2
126287: ARRAY
126288: PUSH
126289: LD_INT 4
126291: ARRAY
126292: PPUSH
126293: CALL_OW 171
// AddComExitVehicle ( driver ) ;
126297: LD_VAR 0 4
126301: PPUSH
126302: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
126306: LD_VAR 0 4
126310: PPUSH
126311: LD_VAR 0 2
126315: PPUSH
126316: CALL_OW 180
// end else
126320: GO 126435
// if GetControl ( vehicle ) = control_remote then
126322: LD_VAR 0 1
126326: PPUSH
126327: CALL_OW 263
126331: PUSH
126332: LD_INT 2
126334: EQUAL
126335: IFFALSE 126396
// begin wait ( 0 0$2 ) ;
126337: LD_INT 70
126339: PPUSH
126340: CALL_OW 67
// if Connect ( vehicle ) then
126344: LD_VAR 0 1
126348: PPUSH
126349: CALL 76829 0 1
126353: IFFALSE 126394
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
126355: LD_VAR 0 1
126359: PPUSH
126360: LD_EXP 204
126364: PUSH
126365: LD_VAR 0 2
126369: ARRAY
126370: PUSH
126371: LD_INT 3
126373: ARRAY
126374: PPUSH
126375: LD_EXP 204
126379: PUSH
126380: LD_VAR 0 2
126384: ARRAY
126385: PUSH
126386: LD_INT 4
126388: ARRAY
126389: PPUSH
126390: CALL_OW 171
// end else
126394: GO 126435
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
126396: LD_VAR 0 1
126400: PPUSH
126401: LD_EXP 204
126405: PUSH
126406: LD_VAR 0 2
126410: ARRAY
126411: PUSH
126412: LD_INT 3
126414: ARRAY
126415: PPUSH
126416: LD_EXP 204
126420: PUSH
126421: LD_VAR 0 2
126425: ARRAY
126426: PUSH
126427: LD_INT 4
126429: ARRAY
126430: PPUSH
126431: CALL_OW 171
// end ; end ;
126435: LD_VAR 0 3
126439: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
126440: LD_INT 0
126442: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
126443: LD_VAR 0 1
126447: PUSH
126448: LD_INT 250
126450: EQUAL
126451: PUSH
126452: LD_VAR 0 2
126456: PPUSH
126457: CALL_OW 264
126461: PUSH
126462: LD_INT 81
126464: EQUAL
126465: AND
126466: IFFALSE 126487
// MinerPlaceMine ( unit , x , y ) ;
126468: LD_VAR 0 2
126472: PPUSH
126473: LD_VAR 0 4
126477: PPUSH
126478: LD_VAR 0 5
126482: PPUSH
126483: CALL 128872 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
126487: LD_VAR 0 1
126491: PUSH
126492: LD_INT 251
126494: EQUAL
126495: PUSH
126496: LD_VAR 0 2
126500: PPUSH
126501: CALL_OW 264
126505: PUSH
126506: LD_INT 81
126508: EQUAL
126509: AND
126510: IFFALSE 126531
// MinerDetonateMine ( unit , x , y ) ;
126512: LD_VAR 0 2
126516: PPUSH
126517: LD_VAR 0 4
126521: PPUSH
126522: LD_VAR 0 5
126526: PPUSH
126527: CALL 129147 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
126531: LD_VAR 0 1
126535: PUSH
126536: LD_INT 252
126538: EQUAL
126539: PUSH
126540: LD_VAR 0 2
126544: PPUSH
126545: CALL_OW 264
126549: PUSH
126550: LD_INT 81
126552: EQUAL
126553: AND
126554: IFFALSE 126575
// MinerCreateMinefield ( unit , x , y ) ;
126556: LD_VAR 0 2
126560: PPUSH
126561: LD_VAR 0 4
126565: PPUSH
126566: LD_VAR 0 5
126570: PPUSH
126571: CALL 129564 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
126575: LD_VAR 0 1
126579: PUSH
126580: LD_INT 253
126582: EQUAL
126583: PUSH
126584: LD_VAR 0 2
126588: PPUSH
126589: CALL_OW 257
126593: PUSH
126594: LD_INT 5
126596: EQUAL
126597: AND
126598: IFFALSE 126619
// ComBinocular ( unit , x , y ) ;
126600: LD_VAR 0 2
126604: PPUSH
126605: LD_VAR 0 4
126609: PPUSH
126610: LD_VAR 0 5
126614: PPUSH
126615: CALL 129933 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
126619: LD_VAR 0 1
126623: PUSH
126624: LD_INT 254
126626: EQUAL
126627: PUSH
126628: LD_VAR 0 2
126632: PPUSH
126633: CALL_OW 264
126637: PUSH
126638: LD_INT 99
126640: EQUAL
126641: AND
126642: PUSH
126643: LD_VAR 0 3
126647: PPUSH
126648: CALL_OW 263
126652: PUSH
126653: LD_INT 3
126655: EQUAL
126656: AND
126657: IFFALSE 126673
// HackDestroyVehicle ( unit , selectedUnit ) ;
126659: LD_VAR 0 2
126663: PPUSH
126664: LD_VAR 0 3
126668: PPUSH
126669: CALL 128236 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
126673: LD_VAR 0 1
126677: PUSH
126678: LD_INT 255
126680: EQUAL
126681: PUSH
126682: LD_VAR 0 2
126686: PPUSH
126687: CALL_OW 264
126691: PUSH
126692: LD_INT 14
126694: PUSH
126695: LD_INT 53
126697: PUSH
126698: EMPTY
126699: LIST
126700: LIST
126701: IN
126702: AND
126703: PUSH
126704: LD_VAR 0 4
126708: PPUSH
126709: LD_VAR 0 5
126713: PPUSH
126714: CALL_OW 488
126718: AND
126719: IFFALSE 126743
// CutTreeXYR ( unit , x , y , 12 ) ;
126721: LD_VAR 0 2
126725: PPUSH
126726: LD_VAR 0 4
126730: PPUSH
126731: LD_VAR 0 5
126735: PPUSH
126736: LD_INT 12
126738: PPUSH
126739: CALL 126806 0 4
// if cmd = 256 then
126743: LD_VAR 0 1
126747: PUSH
126748: LD_INT 256
126750: EQUAL
126751: IFFALSE 126772
// SetFactoryWaypoint ( unit , x , y ) ;
126753: LD_VAR 0 2
126757: PPUSH
126758: LD_VAR 0 4
126762: PPUSH
126763: LD_VAR 0 5
126767: PPUSH
126768: CALL 124753 0 3
// if cmd = 257 then
126772: LD_VAR 0 1
126776: PUSH
126777: LD_INT 257
126779: EQUAL
126780: IFFALSE 126801
// SetWarehouseGatheringPoint ( unit , x , y ) ;
126782: LD_VAR 0 2
126786: PPUSH
126787: LD_VAR 0 4
126791: PPUSH
126792: LD_VAR 0 5
126796: PPUSH
126797: CALL 125115 0 3
// end ;
126801: LD_VAR 0 6
126805: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
126806: LD_INT 0
126808: PPUSH
126809: PPUSH
126810: PPUSH
126811: PPUSH
126812: PPUSH
126813: PPUSH
126814: PPUSH
126815: PPUSH
126816: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
126817: LD_VAR 0 1
126821: NOT
126822: PUSH
126823: LD_VAR 0 2
126827: PPUSH
126828: LD_VAR 0 3
126832: PPUSH
126833: CALL_OW 488
126837: NOT
126838: OR
126839: PUSH
126840: LD_VAR 0 4
126844: NOT
126845: OR
126846: IFFALSE 126850
// exit ;
126848: GO 127190
// list := [ ] ;
126850: LD_ADDR_VAR 0 13
126854: PUSH
126855: EMPTY
126856: ST_TO_ADDR
// if x - r < 0 then
126857: LD_VAR 0 2
126861: PUSH
126862: LD_VAR 0 4
126866: MINUS
126867: PUSH
126868: LD_INT 0
126870: LESS
126871: IFFALSE 126883
// min_x := 0 else
126873: LD_ADDR_VAR 0 7
126877: PUSH
126878: LD_INT 0
126880: ST_TO_ADDR
126881: GO 126899
// min_x := x - r ;
126883: LD_ADDR_VAR 0 7
126887: PUSH
126888: LD_VAR 0 2
126892: PUSH
126893: LD_VAR 0 4
126897: MINUS
126898: ST_TO_ADDR
// if y - r < 0 then
126899: LD_VAR 0 3
126903: PUSH
126904: LD_VAR 0 4
126908: MINUS
126909: PUSH
126910: LD_INT 0
126912: LESS
126913: IFFALSE 126925
// min_y := 0 else
126915: LD_ADDR_VAR 0 8
126919: PUSH
126920: LD_INT 0
126922: ST_TO_ADDR
126923: GO 126941
// min_y := y - r ;
126925: LD_ADDR_VAR 0 8
126929: PUSH
126930: LD_VAR 0 3
126934: PUSH
126935: LD_VAR 0 4
126939: MINUS
126940: ST_TO_ADDR
// max_x := x + r ;
126941: LD_ADDR_VAR 0 9
126945: PUSH
126946: LD_VAR 0 2
126950: PUSH
126951: LD_VAR 0 4
126955: PLUS
126956: ST_TO_ADDR
// max_y := y + r ;
126957: LD_ADDR_VAR 0 10
126961: PUSH
126962: LD_VAR 0 3
126966: PUSH
126967: LD_VAR 0 4
126971: PLUS
126972: ST_TO_ADDR
// for _x = min_x to max_x do
126973: LD_ADDR_VAR 0 11
126977: PUSH
126978: DOUBLE
126979: LD_VAR 0 7
126983: DEC
126984: ST_TO_ADDR
126985: LD_VAR 0 9
126989: PUSH
126990: FOR_TO
126991: IFFALSE 127108
// for _y = min_y to max_y do
126993: LD_ADDR_VAR 0 12
126997: PUSH
126998: DOUBLE
126999: LD_VAR 0 8
127003: DEC
127004: ST_TO_ADDR
127005: LD_VAR 0 10
127009: PUSH
127010: FOR_TO
127011: IFFALSE 127104
// begin if not ValidHex ( _x , _y ) then
127013: LD_VAR 0 11
127017: PPUSH
127018: LD_VAR 0 12
127022: PPUSH
127023: CALL_OW 488
127027: NOT
127028: IFFALSE 127032
// continue ;
127030: GO 127010
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
127032: LD_VAR 0 11
127036: PPUSH
127037: LD_VAR 0 12
127041: PPUSH
127042: CALL_OW 351
127046: PUSH
127047: LD_VAR 0 11
127051: PPUSH
127052: LD_VAR 0 12
127056: PPUSH
127057: CALL_OW 554
127061: AND
127062: IFFALSE 127102
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
127064: LD_ADDR_VAR 0 13
127068: PUSH
127069: LD_VAR 0 13
127073: PPUSH
127074: LD_VAR 0 13
127078: PUSH
127079: LD_INT 1
127081: PLUS
127082: PPUSH
127083: LD_VAR 0 11
127087: PUSH
127088: LD_VAR 0 12
127092: PUSH
127093: EMPTY
127094: LIST
127095: LIST
127096: PPUSH
127097: CALL_OW 2
127101: ST_TO_ADDR
// end ;
127102: GO 127010
127104: POP
127105: POP
127106: GO 126990
127108: POP
127109: POP
// if not list then
127110: LD_VAR 0 13
127114: NOT
127115: IFFALSE 127119
// exit ;
127117: GO 127190
// for i in list do
127119: LD_ADDR_VAR 0 6
127123: PUSH
127124: LD_VAR 0 13
127128: PUSH
127129: FOR_IN
127130: IFFALSE 127188
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
127132: LD_VAR 0 1
127136: PPUSH
127137: LD_STRING M
127139: PUSH
127140: LD_VAR 0 6
127144: PUSH
127145: LD_INT 1
127147: ARRAY
127148: PUSH
127149: LD_VAR 0 6
127153: PUSH
127154: LD_INT 2
127156: ARRAY
127157: PUSH
127158: LD_INT 0
127160: PUSH
127161: LD_INT 0
127163: PUSH
127164: LD_INT 0
127166: PUSH
127167: LD_INT 0
127169: PUSH
127170: EMPTY
127171: LIST
127172: LIST
127173: LIST
127174: LIST
127175: LIST
127176: LIST
127177: LIST
127178: PUSH
127179: EMPTY
127180: LIST
127181: PPUSH
127182: CALL_OW 447
127186: GO 127129
127188: POP
127189: POP
// end ;
127190: LD_VAR 0 5
127194: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
127195: LD_EXP 207
127199: NOT
127200: IFFALSE 127250
127202: GO 127204
127204: DISABLE
// begin initHack := true ;
127205: LD_ADDR_EXP 207
127209: PUSH
127210: LD_INT 1
127212: ST_TO_ADDR
// hackTanks := [ ] ;
127213: LD_ADDR_EXP 208
127217: PUSH
127218: EMPTY
127219: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
127220: LD_ADDR_EXP 209
127224: PUSH
127225: EMPTY
127226: ST_TO_ADDR
// hackLimit := 3 ;
127227: LD_ADDR_EXP 210
127231: PUSH
127232: LD_INT 3
127234: ST_TO_ADDR
// hackDist := 12 ;
127235: LD_ADDR_EXP 211
127239: PUSH
127240: LD_INT 12
127242: ST_TO_ADDR
// hackCounter := [ ] ;
127243: LD_ADDR_EXP 212
127247: PUSH
127248: EMPTY
127249: ST_TO_ADDR
// end ;
127250: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
127251: LD_EXP 207
127255: PUSH
127256: LD_INT 34
127258: PUSH
127259: LD_INT 99
127261: PUSH
127262: EMPTY
127263: LIST
127264: LIST
127265: PPUSH
127266: CALL_OW 69
127270: AND
127271: IFFALSE 127524
127273: GO 127275
127275: DISABLE
127276: LD_INT 0
127278: PPUSH
127279: PPUSH
// begin enable ;
127280: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
127281: LD_ADDR_VAR 0 1
127285: PUSH
127286: LD_INT 34
127288: PUSH
127289: LD_INT 99
127291: PUSH
127292: EMPTY
127293: LIST
127294: LIST
127295: PPUSH
127296: CALL_OW 69
127300: PUSH
127301: FOR_IN
127302: IFFALSE 127522
// begin if not i in hackTanks then
127304: LD_VAR 0 1
127308: PUSH
127309: LD_EXP 208
127313: IN
127314: NOT
127315: IFFALSE 127398
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
127317: LD_ADDR_EXP 208
127321: PUSH
127322: LD_EXP 208
127326: PPUSH
127327: LD_EXP 208
127331: PUSH
127332: LD_INT 1
127334: PLUS
127335: PPUSH
127336: LD_VAR 0 1
127340: PPUSH
127341: CALL_OW 1
127345: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
127346: LD_ADDR_EXP 209
127350: PUSH
127351: LD_EXP 209
127355: PPUSH
127356: LD_EXP 209
127360: PUSH
127361: LD_INT 1
127363: PLUS
127364: PPUSH
127365: EMPTY
127366: PPUSH
127367: CALL_OW 1
127371: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
127372: LD_ADDR_EXP 212
127376: PUSH
127377: LD_EXP 212
127381: PPUSH
127382: LD_EXP 212
127386: PUSH
127387: LD_INT 1
127389: PLUS
127390: PPUSH
127391: EMPTY
127392: PPUSH
127393: CALL_OW 1
127397: ST_TO_ADDR
// end ; if not IsOk ( i ) then
127398: LD_VAR 0 1
127402: PPUSH
127403: CALL_OW 302
127407: NOT
127408: IFFALSE 127421
// begin HackUnlinkAll ( i ) ;
127410: LD_VAR 0 1
127414: PPUSH
127415: CALL 127527 0 1
// continue ;
127419: GO 127301
// end ; HackCheckCapturedStatus ( i ) ;
127421: LD_VAR 0 1
127425: PPUSH
127426: CALL 127970 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
127430: LD_ADDR_VAR 0 2
127434: PUSH
127435: LD_INT 81
127437: PUSH
127438: LD_VAR 0 1
127442: PPUSH
127443: CALL_OW 255
127447: PUSH
127448: EMPTY
127449: LIST
127450: LIST
127451: PUSH
127452: LD_INT 33
127454: PUSH
127455: LD_INT 3
127457: PUSH
127458: EMPTY
127459: LIST
127460: LIST
127461: PUSH
127462: LD_INT 91
127464: PUSH
127465: LD_VAR 0 1
127469: PUSH
127470: LD_EXP 211
127474: PUSH
127475: EMPTY
127476: LIST
127477: LIST
127478: LIST
127479: PUSH
127480: LD_INT 50
127482: PUSH
127483: EMPTY
127484: LIST
127485: PUSH
127486: EMPTY
127487: LIST
127488: LIST
127489: LIST
127490: LIST
127491: PPUSH
127492: CALL_OW 69
127496: ST_TO_ADDR
// if not tmp then
127497: LD_VAR 0 2
127501: NOT
127502: IFFALSE 127506
// continue ;
127504: GO 127301
// HackLink ( i , tmp ) ;
127506: LD_VAR 0 1
127510: PPUSH
127511: LD_VAR 0 2
127515: PPUSH
127516: CALL 127663 0 2
// end ;
127520: GO 127301
127522: POP
127523: POP
// end ;
127524: PPOPN 2
127526: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
127527: LD_INT 0
127529: PPUSH
127530: PPUSH
127531: PPUSH
// if not hack in hackTanks then
127532: LD_VAR 0 1
127536: PUSH
127537: LD_EXP 208
127541: IN
127542: NOT
127543: IFFALSE 127547
// exit ;
127545: GO 127658
// index := GetElementIndex ( hackTanks , hack ) ;
127547: LD_ADDR_VAR 0 4
127551: PUSH
127552: LD_EXP 208
127556: PPUSH
127557: LD_VAR 0 1
127561: PPUSH
127562: CALL 73645 0 2
127566: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
127567: LD_EXP 209
127571: PUSH
127572: LD_VAR 0 4
127576: ARRAY
127577: IFFALSE 127658
// begin for i in hackTanksCaptured [ index ] do
127579: LD_ADDR_VAR 0 3
127583: PUSH
127584: LD_EXP 209
127588: PUSH
127589: LD_VAR 0 4
127593: ARRAY
127594: PUSH
127595: FOR_IN
127596: IFFALSE 127622
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
127598: LD_VAR 0 3
127602: PUSH
127603: LD_INT 1
127605: ARRAY
127606: PPUSH
127607: LD_VAR 0 3
127611: PUSH
127612: LD_INT 2
127614: ARRAY
127615: PPUSH
127616: CALL_OW 235
127620: GO 127595
127622: POP
127623: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
127624: LD_ADDR_EXP 209
127628: PUSH
127629: LD_EXP 209
127633: PPUSH
127634: LD_VAR 0 4
127638: PPUSH
127639: EMPTY
127640: PPUSH
127641: CALL_OW 1
127645: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
127646: LD_VAR 0 1
127650: PPUSH
127651: LD_INT 0
127653: PPUSH
127654: CALL_OW 505
// end ; end ;
127658: LD_VAR 0 2
127662: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
127663: LD_INT 0
127665: PPUSH
127666: PPUSH
127667: PPUSH
// if not hack in hackTanks or not vehicles then
127668: LD_VAR 0 1
127672: PUSH
127673: LD_EXP 208
127677: IN
127678: NOT
127679: PUSH
127680: LD_VAR 0 2
127684: NOT
127685: OR
127686: IFFALSE 127690
// exit ;
127688: GO 127965
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
127690: LD_ADDR_VAR 0 2
127694: PUSH
127695: LD_VAR 0 1
127699: PPUSH
127700: LD_VAR 0 2
127704: PPUSH
127705: LD_INT 1
127707: PPUSH
127708: LD_INT 1
127710: PPUSH
127711: CALL 74295 0 4
127715: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
127716: LD_ADDR_VAR 0 5
127720: PUSH
127721: LD_EXP 208
127725: PPUSH
127726: LD_VAR 0 1
127730: PPUSH
127731: CALL 73645 0 2
127735: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
127736: LD_EXP 209
127740: PUSH
127741: LD_VAR 0 5
127745: ARRAY
127746: PUSH
127747: LD_EXP 210
127751: LESS
127752: IFFALSE 127941
// begin for i := 1 to vehicles do
127754: LD_ADDR_VAR 0 4
127758: PUSH
127759: DOUBLE
127760: LD_INT 1
127762: DEC
127763: ST_TO_ADDR
127764: LD_VAR 0 2
127768: PUSH
127769: FOR_TO
127770: IFFALSE 127939
// begin if hackTanksCaptured [ index ] = hackLimit then
127772: LD_EXP 209
127776: PUSH
127777: LD_VAR 0 5
127781: ARRAY
127782: PUSH
127783: LD_EXP 210
127787: EQUAL
127788: IFFALSE 127792
// break ;
127790: GO 127939
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
127792: LD_ADDR_EXP 212
127796: PUSH
127797: LD_EXP 212
127801: PPUSH
127802: LD_VAR 0 5
127806: PPUSH
127807: LD_EXP 212
127811: PUSH
127812: LD_VAR 0 5
127816: ARRAY
127817: PUSH
127818: LD_INT 1
127820: PLUS
127821: PPUSH
127822: CALL_OW 1
127826: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
127827: LD_ADDR_EXP 209
127831: PUSH
127832: LD_EXP 209
127836: PPUSH
127837: LD_VAR 0 5
127841: PUSH
127842: LD_EXP 209
127846: PUSH
127847: LD_VAR 0 5
127851: ARRAY
127852: PUSH
127853: LD_INT 1
127855: PLUS
127856: PUSH
127857: EMPTY
127858: LIST
127859: LIST
127860: PPUSH
127861: LD_VAR 0 2
127865: PUSH
127866: LD_VAR 0 4
127870: ARRAY
127871: PUSH
127872: LD_VAR 0 2
127876: PUSH
127877: LD_VAR 0 4
127881: ARRAY
127882: PPUSH
127883: CALL_OW 255
127887: PUSH
127888: EMPTY
127889: LIST
127890: LIST
127891: PPUSH
127892: CALL 73860 0 3
127896: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
127897: LD_VAR 0 2
127901: PUSH
127902: LD_VAR 0 4
127906: ARRAY
127907: PPUSH
127908: LD_VAR 0 1
127912: PPUSH
127913: CALL_OW 255
127917: PPUSH
127918: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
127922: LD_VAR 0 2
127926: PUSH
127927: LD_VAR 0 4
127931: ARRAY
127932: PPUSH
127933: CALL_OW 141
// end ;
127937: GO 127769
127939: POP
127940: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
127941: LD_VAR 0 1
127945: PPUSH
127946: LD_EXP 209
127950: PUSH
127951: LD_VAR 0 5
127955: ARRAY
127956: PUSH
127957: LD_INT 0
127959: PLUS
127960: PPUSH
127961: CALL_OW 505
// end ;
127965: LD_VAR 0 3
127969: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
127970: LD_INT 0
127972: PPUSH
127973: PPUSH
127974: PPUSH
127975: PPUSH
// if not hack in hackTanks then
127976: LD_VAR 0 1
127980: PUSH
127981: LD_EXP 208
127985: IN
127986: NOT
127987: IFFALSE 127991
// exit ;
127989: GO 128231
// index := GetElementIndex ( hackTanks , hack ) ;
127991: LD_ADDR_VAR 0 4
127995: PUSH
127996: LD_EXP 208
128000: PPUSH
128001: LD_VAR 0 1
128005: PPUSH
128006: CALL 73645 0 2
128010: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
128011: LD_ADDR_VAR 0 3
128015: PUSH
128016: DOUBLE
128017: LD_EXP 209
128021: PUSH
128022: LD_VAR 0 4
128026: ARRAY
128027: INC
128028: ST_TO_ADDR
128029: LD_INT 1
128031: PUSH
128032: FOR_DOWNTO
128033: IFFALSE 128205
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
128035: LD_ADDR_VAR 0 5
128039: PUSH
128040: LD_EXP 209
128044: PUSH
128045: LD_VAR 0 4
128049: ARRAY
128050: PUSH
128051: LD_VAR 0 3
128055: ARRAY
128056: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
128057: LD_VAR 0 5
128061: PUSH
128062: LD_INT 1
128064: ARRAY
128065: PPUSH
128066: CALL_OW 302
128070: NOT
128071: PUSH
128072: LD_VAR 0 5
128076: PUSH
128077: LD_INT 1
128079: ARRAY
128080: PPUSH
128081: CALL_OW 255
128085: PUSH
128086: LD_VAR 0 1
128090: PPUSH
128091: CALL_OW 255
128095: NONEQUAL
128096: OR
128097: IFFALSE 128203
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
128099: LD_VAR 0 5
128103: PUSH
128104: LD_INT 1
128106: ARRAY
128107: PPUSH
128108: CALL_OW 305
128112: PUSH
128113: LD_VAR 0 5
128117: PUSH
128118: LD_INT 1
128120: ARRAY
128121: PPUSH
128122: CALL_OW 255
128126: PUSH
128127: LD_VAR 0 1
128131: PPUSH
128132: CALL_OW 255
128136: EQUAL
128137: AND
128138: IFFALSE 128162
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
128140: LD_VAR 0 5
128144: PUSH
128145: LD_INT 1
128147: ARRAY
128148: PPUSH
128149: LD_VAR 0 5
128153: PUSH
128154: LD_INT 2
128156: ARRAY
128157: PPUSH
128158: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
128162: LD_ADDR_EXP 209
128166: PUSH
128167: LD_EXP 209
128171: PPUSH
128172: LD_VAR 0 4
128176: PPUSH
128177: LD_EXP 209
128181: PUSH
128182: LD_VAR 0 4
128186: ARRAY
128187: PPUSH
128188: LD_VAR 0 3
128192: PPUSH
128193: CALL_OW 3
128197: PPUSH
128198: CALL_OW 1
128202: ST_TO_ADDR
// end ; end ;
128203: GO 128032
128205: POP
128206: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
128207: LD_VAR 0 1
128211: PPUSH
128212: LD_EXP 209
128216: PUSH
128217: LD_VAR 0 4
128221: ARRAY
128222: PUSH
128223: LD_INT 0
128225: PLUS
128226: PPUSH
128227: CALL_OW 505
// end ;
128231: LD_VAR 0 2
128235: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
128236: LD_INT 0
128238: PPUSH
128239: PPUSH
128240: PPUSH
128241: PPUSH
// if not hack in hackTanks then
128242: LD_VAR 0 1
128246: PUSH
128247: LD_EXP 208
128251: IN
128252: NOT
128253: IFFALSE 128257
// exit ;
128255: GO 128342
// index := GetElementIndex ( hackTanks , hack ) ;
128257: LD_ADDR_VAR 0 5
128261: PUSH
128262: LD_EXP 208
128266: PPUSH
128267: LD_VAR 0 1
128271: PPUSH
128272: CALL 73645 0 2
128276: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
128277: LD_ADDR_VAR 0 4
128281: PUSH
128282: DOUBLE
128283: LD_INT 1
128285: DEC
128286: ST_TO_ADDR
128287: LD_EXP 209
128291: PUSH
128292: LD_VAR 0 5
128296: ARRAY
128297: PUSH
128298: FOR_TO
128299: IFFALSE 128340
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
128301: LD_EXP 209
128305: PUSH
128306: LD_VAR 0 5
128310: ARRAY
128311: PUSH
128312: LD_VAR 0 4
128316: ARRAY
128317: PUSH
128318: LD_INT 1
128320: ARRAY
128321: PUSH
128322: LD_VAR 0 2
128326: EQUAL
128327: IFFALSE 128338
// KillUnit ( vehicle ) ;
128329: LD_VAR 0 2
128333: PPUSH
128334: CALL_OW 66
128338: GO 128298
128340: POP
128341: POP
// end ;
128342: LD_VAR 0 3
128346: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
128347: LD_EXP 213
128351: NOT
128352: IFFALSE 128387
128354: GO 128356
128356: DISABLE
// begin initMiner := true ;
128357: LD_ADDR_EXP 213
128361: PUSH
128362: LD_INT 1
128364: ST_TO_ADDR
// minersList := [ ] ;
128365: LD_ADDR_EXP 214
128369: PUSH
128370: EMPTY
128371: ST_TO_ADDR
// minerMinesList := [ ] ;
128372: LD_ADDR_EXP 215
128376: PUSH
128377: EMPTY
128378: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
128379: LD_ADDR_EXP 216
128383: PUSH
128384: LD_INT 5
128386: ST_TO_ADDR
// end ;
128387: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
128388: LD_EXP 213
128392: PUSH
128393: LD_INT 34
128395: PUSH
128396: LD_INT 81
128398: PUSH
128399: EMPTY
128400: LIST
128401: LIST
128402: PPUSH
128403: CALL_OW 69
128407: AND
128408: IFFALSE 128869
128410: GO 128412
128412: DISABLE
128413: LD_INT 0
128415: PPUSH
128416: PPUSH
128417: PPUSH
128418: PPUSH
// begin enable ;
128419: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
128420: LD_ADDR_VAR 0 1
128424: PUSH
128425: LD_INT 34
128427: PUSH
128428: LD_INT 81
128430: PUSH
128431: EMPTY
128432: LIST
128433: LIST
128434: PPUSH
128435: CALL_OW 69
128439: PUSH
128440: FOR_IN
128441: IFFALSE 128513
// begin if not i in minersList then
128443: LD_VAR 0 1
128447: PUSH
128448: LD_EXP 214
128452: IN
128453: NOT
128454: IFFALSE 128511
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
128456: LD_ADDR_EXP 214
128460: PUSH
128461: LD_EXP 214
128465: PPUSH
128466: LD_EXP 214
128470: PUSH
128471: LD_INT 1
128473: PLUS
128474: PPUSH
128475: LD_VAR 0 1
128479: PPUSH
128480: CALL_OW 1
128484: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
128485: LD_ADDR_EXP 215
128489: PUSH
128490: LD_EXP 215
128494: PPUSH
128495: LD_EXP 215
128499: PUSH
128500: LD_INT 1
128502: PLUS
128503: PPUSH
128504: EMPTY
128505: PPUSH
128506: CALL_OW 1
128510: ST_TO_ADDR
// end end ;
128511: GO 128440
128513: POP
128514: POP
// for i := minerMinesList downto 1 do
128515: LD_ADDR_VAR 0 1
128519: PUSH
128520: DOUBLE
128521: LD_EXP 215
128525: INC
128526: ST_TO_ADDR
128527: LD_INT 1
128529: PUSH
128530: FOR_DOWNTO
128531: IFFALSE 128867
// begin if IsLive ( minersList [ i ] ) then
128533: LD_EXP 214
128537: PUSH
128538: LD_VAR 0 1
128542: ARRAY
128543: PPUSH
128544: CALL_OW 300
128548: IFFALSE 128576
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
128550: LD_EXP 214
128554: PUSH
128555: LD_VAR 0 1
128559: ARRAY
128560: PPUSH
128561: LD_EXP 215
128565: PUSH
128566: LD_VAR 0 1
128570: ARRAY
128571: PPUSH
128572: CALL_OW 505
// if not minerMinesList [ i ] then
128576: LD_EXP 215
128580: PUSH
128581: LD_VAR 0 1
128585: ARRAY
128586: NOT
128587: IFFALSE 128591
// continue ;
128589: GO 128530
// for j := minerMinesList [ i ] downto 1 do
128591: LD_ADDR_VAR 0 2
128595: PUSH
128596: DOUBLE
128597: LD_EXP 215
128601: PUSH
128602: LD_VAR 0 1
128606: ARRAY
128607: INC
128608: ST_TO_ADDR
128609: LD_INT 1
128611: PUSH
128612: FOR_DOWNTO
128613: IFFALSE 128863
// begin side := GetSide ( minersList [ i ] ) ;
128615: LD_ADDR_VAR 0 3
128619: PUSH
128620: LD_EXP 214
128624: PUSH
128625: LD_VAR 0 1
128629: ARRAY
128630: PPUSH
128631: CALL_OW 255
128635: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
128636: LD_ADDR_VAR 0 4
128640: PUSH
128641: LD_EXP 215
128645: PUSH
128646: LD_VAR 0 1
128650: ARRAY
128651: PUSH
128652: LD_VAR 0 2
128656: ARRAY
128657: PUSH
128658: LD_INT 1
128660: ARRAY
128661: PPUSH
128662: LD_EXP 215
128666: PUSH
128667: LD_VAR 0 1
128671: ARRAY
128672: PUSH
128673: LD_VAR 0 2
128677: ARRAY
128678: PUSH
128679: LD_INT 2
128681: ARRAY
128682: PPUSH
128683: CALL_OW 428
128687: ST_TO_ADDR
// if not tmp then
128688: LD_VAR 0 4
128692: NOT
128693: IFFALSE 128697
// continue ;
128695: GO 128612
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
128697: LD_VAR 0 4
128701: PUSH
128702: LD_INT 81
128704: PUSH
128705: LD_VAR 0 3
128709: PUSH
128710: EMPTY
128711: LIST
128712: LIST
128713: PPUSH
128714: CALL_OW 69
128718: IN
128719: PUSH
128720: LD_EXP 215
128724: PUSH
128725: LD_VAR 0 1
128729: ARRAY
128730: PUSH
128731: LD_VAR 0 2
128735: ARRAY
128736: PUSH
128737: LD_INT 1
128739: ARRAY
128740: PPUSH
128741: LD_EXP 215
128745: PUSH
128746: LD_VAR 0 1
128750: ARRAY
128751: PUSH
128752: LD_VAR 0 2
128756: ARRAY
128757: PUSH
128758: LD_INT 2
128760: ARRAY
128761: PPUSH
128762: CALL_OW 458
128766: AND
128767: IFFALSE 128861
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
128769: LD_EXP 215
128773: PUSH
128774: LD_VAR 0 1
128778: ARRAY
128779: PUSH
128780: LD_VAR 0 2
128784: ARRAY
128785: PUSH
128786: LD_INT 1
128788: ARRAY
128789: PPUSH
128790: LD_EXP 215
128794: PUSH
128795: LD_VAR 0 1
128799: ARRAY
128800: PUSH
128801: LD_VAR 0 2
128805: ARRAY
128806: PUSH
128807: LD_INT 2
128809: ARRAY
128810: PPUSH
128811: LD_VAR 0 3
128815: PPUSH
128816: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
128820: LD_ADDR_EXP 215
128824: PUSH
128825: LD_EXP 215
128829: PPUSH
128830: LD_VAR 0 1
128834: PPUSH
128835: LD_EXP 215
128839: PUSH
128840: LD_VAR 0 1
128844: ARRAY
128845: PPUSH
128846: LD_VAR 0 2
128850: PPUSH
128851: CALL_OW 3
128855: PPUSH
128856: CALL_OW 1
128860: ST_TO_ADDR
// end ; end ;
128861: GO 128612
128863: POP
128864: POP
// end ;
128865: GO 128530
128867: POP
128868: POP
// end ;
128869: PPOPN 4
128871: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
128872: LD_INT 0
128874: PPUSH
128875: PPUSH
// result := false ;
128876: LD_ADDR_VAR 0 4
128880: PUSH
128881: LD_INT 0
128883: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
128884: LD_VAR 0 1
128888: PPUSH
128889: CALL_OW 264
128893: PUSH
128894: LD_INT 81
128896: EQUAL
128897: NOT
128898: IFFALSE 128902
// exit ;
128900: GO 129142
// index := GetElementIndex ( minersList , unit ) ;
128902: LD_ADDR_VAR 0 5
128906: PUSH
128907: LD_EXP 214
128911: PPUSH
128912: LD_VAR 0 1
128916: PPUSH
128917: CALL 73645 0 2
128921: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
128922: LD_EXP 215
128926: PUSH
128927: LD_VAR 0 5
128931: ARRAY
128932: PUSH
128933: LD_EXP 216
128937: GREATEREQUAL
128938: IFFALSE 128942
// exit ;
128940: GO 129142
// ComMoveXY ( unit , x , y ) ;
128942: LD_VAR 0 1
128946: PPUSH
128947: LD_VAR 0 2
128951: PPUSH
128952: LD_VAR 0 3
128956: PPUSH
128957: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
128961: LD_INT 35
128963: PPUSH
128964: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
128968: LD_VAR 0 1
128972: PPUSH
128973: LD_VAR 0 2
128977: PPUSH
128978: LD_VAR 0 3
128982: PPUSH
128983: CALL 105000 0 3
128987: NOT
128988: PUSH
128989: LD_VAR 0 1
128993: PPUSH
128994: CALL_OW 314
128998: AND
128999: IFFALSE 129003
// exit ;
129001: GO 129142
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
129003: LD_VAR 0 2
129007: PPUSH
129008: LD_VAR 0 3
129012: PPUSH
129013: CALL_OW 428
129017: PUSH
129018: LD_VAR 0 1
129022: EQUAL
129023: PUSH
129024: LD_VAR 0 1
129028: PPUSH
129029: CALL_OW 314
129033: NOT
129034: AND
129035: IFFALSE 128961
// PlaySoundXY ( x , y , PlantMine ) ;
129037: LD_VAR 0 2
129041: PPUSH
129042: LD_VAR 0 3
129046: PPUSH
129047: LD_STRING PlantMine
129049: PPUSH
129050: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
129054: LD_VAR 0 2
129058: PPUSH
129059: LD_VAR 0 3
129063: PPUSH
129064: LD_VAR 0 1
129068: PPUSH
129069: CALL_OW 255
129073: PPUSH
129074: LD_INT 0
129076: PPUSH
129077: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
129081: LD_ADDR_EXP 215
129085: PUSH
129086: LD_EXP 215
129090: PPUSH
129091: LD_VAR 0 5
129095: PUSH
129096: LD_EXP 215
129100: PUSH
129101: LD_VAR 0 5
129105: ARRAY
129106: PUSH
129107: LD_INT 1
129109: PLUS
129110: PUSH
129111: EMPTY
129112: LIST
129113: LIST
129114: PPUSH
129115: LD_VAR 0 2
129119: PUSH
129120: LD_VAR 0 3
129124: PUSH
129125: EMPTY
129126: LIST
129127: LIST
129128: PPUSH
129129: CALL 73860 0 3
129133: ST_TO_ADDR
// result := true ;
129134: LD_ADDR_VAR 0 4
129138: PUSH
129139: LD_INT 1
129141: ST_TO_ADDR
// end ;
129142: LD_VAR 0 4
129146: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
129147: LD_INT 0
129149: PPUSH
129150: PPUSH
129151: PPUSH
// if not unit in minersList then
129152: LD_VAR 0 1
129156: PUSH
129157: LD_EXP 214
129161: IN
129162: NOT
129163: IFFALSE 129167
// exit ;
129165: GO 129559
// index := GetElementIndex ( minersList , unit ) ;
129167: LD_ADDR_VAR 0 6
129171: PUSH
129172: LD_EXP 214
129176: PPUSH
129177: LD_VAR 0 1
129181: PPUSH
129182: CALL 73645 0 2
129186: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
129187: LD_ADDR_VAR 0 5
129191: PUSH
129192: DOUBLE
129193: LD_EXP 215
129197: PUSH
129198: LD_VAR 0 6
129202: ARRAY
129203: INC
129204: ST_TO_ADDR
129205: LD_INT 1
129207: PUSH
129208: FOR_DOWNTO
129209: IFFALSE 129370
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
129211: LD_EXP 215
129215: PUSH
129216: LD_VAR 0 6
129220: ARRAY
129221: PUSH
129222: LD_VAR 0 5
129226: ARRAY
129227: PUSH
129228: LD_INT 1
129230: ARRAY
129231: PUSH
129232: LD_VAR 0 2
129236: EQUAL
129237: PUSH
129238: LD_EXP 215
129242: PUSH
129243: LD_VAR 0 6
129247: ARRAY
129248: PUSH
129249: LD_VAR 0 5
129253: ARRAY
129254: PUSH
129255: LD_INT 2
129257: ARRAY
129258: PUSH
129259: LD_VAR 0 3
129263: EQUAL
129264: AND
129265: IFFALSE 129368
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
129267: LD_EXP 215
129271: PUSH
129272: LD_VAR 0 6
129276: ARRAY
129277: PUSH
129278: LD_VAR 0 5
129282: ARRAY
129283: PUSH
129284: LD_INT 1
129286: ARRAY
129287: PPUSH
129288: LD_EXP 215
129292: PUSH
129293: LD_VAR 0 6
129297: ARRAY
129298: PUSH
129299: LD_VAR 0 5
129303: ARRAY
129304: PUSH
129305: LD_INT 2
129307: ARRAY
129308: PPUSH
129309: LD_VAR 0 1
129313: PPUSH
129314: CALL_OW 255
129318: PPUSH
129319: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
129323: LD_ADDR_EXP 215
129327: PUSH
129328: LD_EXP 215
129332: PPUSH
129333: LD_VAR 0 6
129337: PPUSH
129338: LD_EXP 215
129342: PUSH
129343: LD_VAR 0 6
129347: ARRAY
129348: PPUSH
129349: LD_VAR 0 5
129353: PPUSH
129354: CALL_OW 3
129358: PPUSH
129359: CALL_OW 1
129363: ST_TO_ADDR
// exit ;
129364: POP
129365: POP
129366: GO 129559
// end ; end ;
129368: GO 129208
129370: POP
129371: POP
// for i := minerMinesList [ index ] downto 1 do
129372: LD_ADDR_VAR 0 5
129376: PUSH
129377: DOUBLE
129378: LD_EXP 215
129382: PUSH
129383: LD_VAR 0 6
129387: ARRAY
129388: INC
129389: ST_TO_ADDR
129390: LD_INT 1
129392: PUSH
129393: FOR_DOWNTO
129394: IFFALSE 129557
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
129396: LD_EXP 215
129400: PUSH
129401: LD_VAR 0 6
129405: ARRAY
129406: PUSH
129407: LD_VAR 0 5
129411: ARRAY
129412: PUSH
129413: LD_INT 1
129415: ARRAY
129416: PPUSH
129417: LD_EXP 215
129421: PUSH
129422: LD_VAR 0 6
129426: ARRAY
129427: PUSH
129428: LD_VAR 0 5
129432: ARRAY
129433: PUSH
129434: LD_INT 2
129436: ARRAY
129437: PPUSH
129438: LD_VAR 0 2
129442: PPUSH
129443: LD_VAR 0 3
129447: PPUSH
129448: CALL_OW 298
129452: PUSH
129453: LD_INT 6
129455: LESS
129456: IFFALSE 129555
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
129458: LD_EXP 215
129462: PUSH
129463: LD_VAR 0 6
129467: ARRAY
129468: PUSH
129469: LD_VAR 0 5
129473: ARRAY
129474: PUSH
129475: LD_INT 1
129477: ARRAY
129478: PPUSH
129479: LD_EXP 215
129483: PUSH
129484: LD_VAR 0 6
129488: ARRAY
129489: PUSH
129490: LD_VAR 0 5
129494: ARRAY
129495: PUSH
129496: LD_INT 2
129498: ARRAY
129499: PPUSH
129500: LD_VAR 0 1
129504: PPUSH
129505: CALL_OW 255
129509: PPUSH
129510: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
129514: LD_ADDR_EXP 215
129518: PUSH
129519: LD_EXP 215
129523: PPUSH
129524: LD_VAR 0 6
129528: PPUSH
129529: LD_EXP 215
129533: PUSH
129534: LD_VAR 0 6
129538: ARRAY
129539: PPUSH
129540: LD_VAR 0 5
129544: PPUSH
129545: CALL_OW 3
129549: PPUSH
129550: CALL_OW 1
129554: ST_TO_ADDR
// end ; end ;
129555: GO 129393
129557: POP
129558: POP
// end ;
129559: LD_VAR 0 4
129563: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
129564: LD_INT 0
129566: PPUSH
129567: PPUSH
129568: PPUSH
129569: PPUSH
129570: PPUSH
129571: PPUSH
129572: PPUSH
129573: PPUSH
129574: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
129575: LD_VAR 0 1
129579: PPUSH
129580: CALL_OW 264
129584: PUSH
129585: LD_INT 81
129587: EQUAL
129588: NOT
129589: PUSH
129590: LD_VAR 0 1
129594: PUSH
129595: LD_EXP 214
129599: IN
129600: NOT
129601: OR
129602: IFFALSE 129606
// exit ;
129604: GO 129928
// index := GetElementIndex ( minersList , unit ) ;
129606: LD_ADDR_VAR 0 6
129610: PUSH
129611: LD_EXP 214
129615: PPUSH
129616: LD_VAR 0 1
129620: PPUSH
129621: CALL 73645 0 2
129625: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
129626: LD_ADDR_VAR 0 8
129630: PUSH
129631: LD_EXP 216
129635: PUSH
129636: LD_EXP 215
129640: PUSH
129641: LD_VAR 0 6
129645: ARRAY
129646: MINUS
129647: ST_TO_ADDR
// if not minesFreeAmount then
129648: LD_VAR 0 8
129652: NOT
129653: IFFALSE 129657
// exit ;
129655: GO 129928
// tmp := [ ] ;
129657: LD_ADDR_VAR 0 7
129661: PUSH
129662: EMPTY
129663: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
129664: LD_ADDR_VAR 0 5
129668: PUSH
129669: DOUBLE
129670: LD_INT 1
129672: DEC
129673: ST_TO_ADDR
129674: LD_VAR 0 8
129678: PUSH
129679: FOR_TO
129680: IFFALSE 129875
// begin _d := rand ( 0 , 5 ) ;
129682: LD_ADDR_VAR 0 11
129686: PUSH
129687: LD_INT 0
129689: PPUSH
129690: LD_INT 5
129692: PPUSH
129693: CALL_OW 12
129697: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
129698: LD_ADDR_VAR 0 12
129702: PUSH
129703: LD_INT 2
129705: PPUSH
129706: LD_INT 6
129708: PPUSH
129709: CALL_OW 12
129713: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
129714: LD_ADDR_VAR 0 9
129718: PUSH
129719: LD_VAR 0 2
129723: PPUSH
129724: LD_VAR 0 11
129728: PPUSH
129729: LD_VAR 0 12
129733: PPUSH
129734: CALL_OW 272
129738: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
129739: LD_ADDR_VAR 0 10
129743: PUSH
129744: LD_VAR 0 3
129748: PPUSH
129749: LD_VAR 0 11
129753: PPUSH
129754: LD_VAR 0 12
129758: PPUSH
129759: CALL_OW 273
129763: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
129764: LD_VAR 0 9
129768: PPUSH
129769: LD_VAR 0 10
129773: PPUSH
129774: CALL_OW 488
129778: PUSH
129779: LD_VAR 0 9
129783: PUSH
129784: LD_VAR 0 10
129788: PUSH
129789: EMPTY
129790: LIST
129791: LIST
129792: PUSH
129793: LD_VAR 0 7
129797: IN
129798: NOT
129799: AND
129800: PUSH
129801: LD_VAR 0 9
129805: PPUSH
129806: LD_VAR 0 10
129810: PPUSH
129811: CALL_OW 458
129815: NOT
129816: AND
129817: IFFALSE 129859
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
129819: LD_ADDR_VAR 0 7
129823: PUSH
129824: LD_VAR 0 7
129828: PPUSH
129829: LD_VAR 0 7
129833: PUSH
129834: LD_INT 1
129836: PLUS
129837: PPUSH
129838: LD_VAR 0 9
129842: PUSH
129843: LD_VAR 0 10
129847: PUSH
129848: EMPTY
129849: LIST
129850: LIST
129851: PPUSH
129852: CALL_OW 1
129856: ST_TO_ADDR
129857: GO 129873
// i := i - 1 ;
129859: LD_ADDR_VAR 0 5
129863: PUSH
129864: LD_VAR 0 5
129868: PUSH
129869: LD_INT 1
129871: MINUS
129872: ST_TO_ADDR
// end ;
129873: GO 129679
129875: POP
129876: POP
// for i in tmp do
129877: LD_ADDR_VAR 0 5
129881: PUSH
129882: LD_VAR 0 7
129886: PUSH
129887: FOR_IN
129888: IFFALSE 129926
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
129890: LD_VAR 0 1
129894: PPUSH
129895: LD_VAR 0 5
129899: PUSH
129900: LD_INT 1
129902: ARRAY
129903: PPUSH
129904: LD_VAR 0 5
129908: PUSH
129909: LD_INT 2
129911: ARRAY
129912: PPUSH
129913: CALL 128872 0 3
129917: NOT
129918: IFFALSE 129924
// exit ;
129920: POP
129921: POP
129922: GO 129928
129924: GO 129887
129926: POP
129927: POP
// end ;
129928: LD_VAR 0 4
129932: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
129933: LD_INT 0
129935: PPUSH
129936: PPUSH
129937: PPUSH
129938: PPUSH
129939: PPUSH
129940: PPUSH
129941: PPUSH
// if not GetClass ( unit ) = class_sniper then
129942: LD_VAR 0 1
129946: PPUSH
129947: CALL_OW 257
129951: PUSH
129952: LD_INT 5
129954: EQUAL
129955: NOT
129956: IFFALSE 129960
// exit ;
129958: GO 130348
// dist := 8 ;
129960: LD_ADDR_VAR 0 5
129964: PUSH
129965: LD_INT 8
129967: ST_TO_ADDR
// viewRange := 12 ;
129968: LD_ADDR_VAR 0 7
129972: PUSH
129973: LD_INT 12
129975: ST_TO_ADDR
// side := GetSide ( unit ) ;
129976: LD_ADDR_VAR 0 6
129980: PUSH
129981: LD_VAR 0 1
129985: PPUSH
129986: CALL_OW 255
129990: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
129991: LD_INT 61
129993: PPUSH
129994: LD_VAR 0 6
129998: PPUSH
129999: CALL_OW 321
130003: PUSH
130004: LD_INT 2
130006: EQUAL
130007: IFFALSE 130017
// viewRange := 16 ;
130009: LD_ADDR_VAR 0 7
130013: PUSH
130014: LD_INT 16
130016: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
130017: LD_VAR 0 1
130021: PPUSH
130022: LD_VAR 0 2
130026: PPUSH
130027: LD_VAR 0 3
130031: PPUSH
130032: CALL_OW 297
130036: PUSH
130037: LD_VAR 0 5
130041: GREATER
130042: IFFALSE 130121
// begin ComMoveXY ( unit , x , y ) ;
130044: LD_VAR 0 1
130048: PPUSH
130049: LD_VAR 0 2
130053: PPUSH
130054: LD_VAR 0 3
130058: PPUSH
130059: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
130063: LD_INT 35
130065: PPUSH
130066: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
130070: LD_VAR 0 1
130074: PPUSH
130075: LD_VAR 0 2
130079: PPUSH
130080: LD_VAR 0 3
130084: PPUSH
130085: CALL 105000 0 3
130089: NOT
130090: IFFALSE 130094
// exit ;
130092: GO 130348
// until GetDistUnitXY ( unit , x , y ) < dist ;
130094: LD_VAR 0 1
130098: PPUSH
130099: LD_VAR 0 2
130103: PPUSH
130104: LD_VAR 0 3
130108: PPUSH
130109: CALL_OW 297
130113: PUSH
130114: LD_VAR 0 5
130118: LESS
130119: IFFALSE 130063
// end ; ComTurnXY ( unit , x , y ) ;
130121: LD_VAR 0 1
130125: PPUSH
130126: LD_VAR 0 2
130130: PPUSH
130131: LD_VAR 0 3
130135: PPUSH
130136: CALL_OW 118
// wait ( 5 ) ;
130140: LD_INT 5
130142: PPUSH
130143: CALL_OW 67
// _d := GetDir ( unit ) ;
130147: LD_ADDR_VAR 0 10
130151: PUSH
130152: LD_VAR 0 1
130156: PPUSH
130157: CALL_OW 254
130161: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
130162: LD_ADDR_VAR 0 8
130166: PUSH
130167: LD_VAR 0 1
130171: PPUSH
130172: CALL_OW 250
130176: PPUSH
130177: LD_VAR 0 10
130181: PPUSH
130182: LD_VAR 0 5
130186: PPUSH
130187: CALL_OW 272
130191: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
130192: LD_ADDR_VAR 0 9
130196: PUSH
130197: LD_VAR 0 1
130201: PPUSH
130202: CALL_OW 251
130206: PPUSH
130207: LD_VAR 0 10
130211: PPUSH
130212: LD_VAR 0 5
130216: PPUSH
130217: CALL_OW 273
130221: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
130222: LD_VAR 0 8
130226: PPUSH
130227: LD_VAR 0 9
130231: PPUSH
130232: CALL_OW 488
130236: NOT
130237: IFFALSE 130241
// exit ;
130239: GO 130348
// ComAnimCustom ( unit , 1 ) ;
130241: LD_VAR 0 1
130245: PPUSH
130246: LD_INT 1
130248: PPUSH
130249: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
130253: LD_VAR 0 8
130257: PPUSH
130258: LD_VAR 0 9
130262: PPUSH
130263: LD_VAR 0 6
130267: PPUSH
130268: LD_VAR 0 7
130272: PPUSH
130273: CALL_OW 330
// repeat wait ( 1 ) ;
130277: LD_INT 1
130279: PPUSH
130280: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
130284: LD_VAR 0 1
130288: PPUSH
130289: CALL_OW 316
130293: PUSH
130294: LD_VAR 0 1
130298: PPUSH
130299: CALL_OW 314
130303: OR
130304: PUSH
130305: LD_VAR 0 1
130309: PPUSH
130310: CALL_OW 302
130314: NOT
130315: OR
130316: PUSH
130317: LD_VAR 0 1
130321: PPUSH
130322: CALL_OW 301
130326: OR
130327: IFFALSE 130277
// RemoveSeeing ( _x , _y , side ) ;
130329: LD_VAR 0 8
130333: PPUSH
130334: LD_VAR 0 9
130338: PPUSH
130339: LD_VAR 0 6
130343: PPUSH
130344: CALL_OW 331
// end ; end_of_file
130348: LD_VAR 0 4
130352: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
130353: LD_INT 0
130355: PPUSH
130356: PPUSH
130357: PPUSH
130358: PPUSH
130359: PPUSH
130360: PPUSH
130361: PPUSH
130362: PPUSH
130363: PPUSH
130364: PPUSH
130365: PPUSH
130366: PPUSH
130367: PPUSH
130368: PPUSH
130369: PPUSH
130370: PPUSH
130371: PPUSH
130372: PPUSH
130373: PPUSH
130374: PPUSH
130375: PPUSH
130376: PPUSH
130377: PPUSH
130378: PPUSH
130379: PPUSH
130380: PPUSH
130381: PPUSH
130382: PPUSH
130383: PPUSH
130384: PPUSH
130385: PPUSH
130386: PPUSH
130387: PPUSH
130388: PPUSH
// if not list then
130389: LD_VAR 0 1
130393: NOT
130394: IFFALSE 130398
// exit ;
130396: GO 135057
// base := list [ 1 ] ;
130398: LD_ADDR_VAR 0 3
130402: PUSH
130403: LD_VAR 0 1
130407: PUSH
130408: LD_INT 1
130410: ARRAY
130411: ST_TO_ADDR
// group := list [ 2 ] ;
130412: LD_ADDR_VAR 0 4
130416: PUSH
130417: LD_VAR 0 1
130421: PUSH
130422: LD_INT 2
130424: ARRAY
130425: ST_TO_ADDR
// path := list [ 3 ] ;
130426: LD_ADDR_VAR 0 5
130430: PUSH
130431: LD_VAR 0 1
130435: PUSH
130436: LD_INT 3
130438: ARRAY
130439: ST_TO_ADDR
// flags := list [ 4 ] ;
130440: LD_ADDR_VAR 0 6
130444: PUSH
130445: LD_VAR 0 1
130449: PUSH
130450: LD_INT 4
130452: ARRAY
130453: ST_TO_ADDR
// mined := [ ] ;
130454: LD_ADDR_VAR 0 27
130458: PUSH
130459: EMPTY
130460: ST_TO_ADDR
// bombed := [ ] ;
130461: LD_ADDR_VAR 0 28
130465: PUSH
130466: EMPTY
130467: ST_TO_ADDR
// healers := [ ] ;
130468: LD_ADDR_VAR 0 31
130472: PUSH
130473: EMPTY
130474: ST_TO_ADDR
// to_heal := [ ] ;
130475: LD_ADDR_VAR 0 30
130479: PUSH
130480: EMPTY
130481: ST_TO_ADDR
// repairs := [ ] ;
130482: LD_ADDR_VAR 0 33
130486: PUSH
130487: EMPTY
130488: ST_TO_ADDR
// to_repair := [ ] ;
130489: LD_ADDR_VAR 0 32
130493: PUSH
130494: EMPTY
130495: ST_TO_ADDR
// if not group or not path then
130496: LD_VAR 0 4
130500: NOT
130501: PUSH
130502: LD_VAR 0 5
130506: NOT
130507: OR
130508: IFFALSE 130512
// exit ;
130510: GO 135057
// side := GetSide ( group [ 1 ] ) ;
130512: LD_ADDR_VAR 0 35
130516: PUSH
130517: LD_VAR 0 4
130521: PUSH
130522: LD_INT 1
130524: ARRAY
130525: PPUSH
130526: CALL_OW 255
130530: ST_TO_ADDR
// if flags then
130531: LD_VAR 0 6
130535: IFFALSE 130679
// begin f_ignore_area := flags [ 1 ] ;
130537: LD_ADDR_VAR 0 17
130541: PUSH
130542: LD_VAR 0 6
130546: PUSH
130547: LD_INT 1
130549: ARRAY
130550: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
130551: LD_ADDR_VAR 0 18
130555: PUSH
130556: LD_VAR 0 6
130560: PUSH
130561: LD_INT 2
130563: ARRAY
130564: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
130565: LD_ADDR_VAR 0 19
130569: PUSH
130570: LD_VAR 0 6
130574: PUSH
130575: LD_INT 3
130577: ARRAY
130578: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
130579: LD_ADDR_VAR 0 20
130583: PUSH
130584: LD_VAR 0 6
130588: PUSH
130589: LD_INT 4
130591: ARRAY
130592: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
130593: LD_ADDR_VAR 0 21
130597: PUSH
130598: LD_VAR 0 6
130602: PUSH
130603: LD_INT 5
130605: ARRAY
130606: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
130607: LD_ADDR_VAR 0 22
130611: PUSH
130612: LD_VAR 0 6
130616: PUSH
130617: LD_INT 6
130619: ARRAY
130620: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
130621: LD_ADDR_VAR 0 23
130625: PUSH
130626: LD_VAR 0 6
130630: PUSH
130631: LD_INT 7
130633: ARRAY
130634: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
130635: LD_ADDR_VAR 0 24
130639: PUSH
130640: LD_VAR 0 6
130644: PUSH
130645: LD_INT 8
130647: ARRAY
130648: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
130649: LD_ADDR_VAR 0 25
130653: PUSH
130654: LD_VAR 0 6
130658: PUSH
130659: LD_INT 9
130661: ARRAY
130662: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
130663: LD_ADDR_VAR 0 26
130667: PUSH
130668: LD_VAR 0 6
130672: PUSH
130673: LD_INT 10
130675: ARRAY
130676: ST_TO_ADDR
// end else
130677: GO 130759
// begin f_ignore_area := false ;
130679: LD_ADDR_VAR 0 17
130683: PUSH
130684: LD_INT 0
130686: ST_TO_ADDR
// f_capture := false ;
130687: LD_ADDR_VAR 0 18
130691: PUSH
130692: LD_INT 0
130694: ST_TO_ADDR
// f_ignore_civ := false ;
130695: LD_ADDR_VAR 0 19
130699: PUSH
130700: LD_INT 0
130702: ST_TO_ADDR
// f_murder := false ;
130703: LD_ADDR_VAR 0 20
130707: PUSH
130708: LD_INT 0
130710: ST_TO_ADDR
// f_mines := false ;
130711: LD_ADDR_VAR 0 21
130715: PUSH
130716: LD_INT 0
130718: ST_TO_ADDR
// f_repair := false ;
130719: LD_ADDR_VAR 0 22
130723: PUSH
130724: LD_INT 0
130726: ST_TO_ADDR
// f_heal := false ;
130727: LD_ADDR_VAR 0 23
130731: PUSH
130732: LD_INT 0
130734: ST_TO_ADDR
// f_spacetime := false ;
130735: LD_ADDR_VAR 0 24
130739: PUSH
130740: LD_INT 0
130742: ST_TO_ADDR
// f_attack_depot := false ;
130743: LD_ADDR_VAR 0 25
130747: PUSH
130748: LD_INT 0
130750: ST_TO_ADDR
// f_crawl := false ;
130751: LD_ADDR_VAR 0 26
130755: PUSH
130756: LD_INT 0
130758: ST_TO_ADDR
// end ; if f_heal then
130759: LD_VAR 0 23
130763: IFFALSE 130790
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
130765: LD_ADDR_VAR 0 31
130769: PUSH
130770: LD_VAR 0 4
130774: PPUSH
130775: LD_INT 25
130777: PUSH
130778: LD_INT 4
130780: PUSH
130781: EMPTY
130782: LIST
130783: LIST
130784: PPUSH
130785: CALL_OW 72
130789: ST_TO_ADDR
// if f_repair then
130790: LD_VAR 0 22
130794: IFFALSE 130821
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
130796: LD_ADDR_VAR 0 33
130800: PUSH
130801: LD_VAR 0 4
130805: PPUSH
130806: LD_INT 25
130808: PUSH
130809: LD_INT 3
130811: PUSH
130812: EMPTY
130813: LIST
130814: LIST
130815: PPUSH
130816: CALL_OW 72
130820: ST_TO_ADDR
// units_path := [ ] ;
130821: LD_ADDR_VAR 0 16
130825: PUSH
130826: EMPTY
130827: ST_TO_ADDR
// for i = 1 to group do
130828: LD_ADDR_VAR 0 7
130832: PUSH
130833: DOUBLE
130834: LD_INT 1
130836: DEC
130837: ST_TO_ADDR
130838: LD_VAR 0 4
130842: PUSH
130843: FOR_TO
130844: IFFALSE 130873
// units_path := Replace ( units_path , i , path ) ;
130846: LD_ADDR_VAR 0 16
130850: PUSH
130851: LD_VAR 0 16
130855: PPUSH
130856: LD_VAR 0 7
130860: PPUSH
130861: LD_VAR 0 5
130865: PPUSH
130866: CALL_OW 1
130870: ST_TO_ADDR
130871: GO 130843
130873: POP
130874: POP
// repeat for i = group downto 1 do
130875: LD_ADDR_VAR 0 7
130879: PUSH
130880: DOUBLE
130881: LD_VAR 0 4
130885: INC
130886: ST_TO_ADDR
130887: LD_INT 1
130889: PUSH
130890: FOR_DOWNTO
130891: IFFALSE 135013
// begin wait ( 5 ) ;
130893: LD_INT 5
130895: PPUSH
130896: CALL_OW 67
// tmp := [ ] ;
130900: LD_ADDR_VAR 0 14
130904: PUSH
130905: EMPTY
130906: ST_TO_ADDR
// attacking := false ;
130907: LD_ADDR_VAR 0 29
130911: PUSH
130912: LD_INT 0
130914: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
130915: LD_VAR 0 4
130919: PUSH
130920: LD_VAR 0 7
130924: ARRAY
130925: PPUSH
130926: CALL_OW 301
130930: PUSH
130931: LD_VAR 0 4
130935: PUSH
130936: LD_VAR 0 7
130940: ARRAY
130941: NOT
130942: OR
130943: IFFALSE 131052
// begin if GetType ( group [ i ] ) = unit_human then
130945: LD_VAR 0 4
130949: PUSH
130950: LD_VAR 0 7
130954: ARRAY
130955: PPUSH
130956: CALL_OW 247
130960: PUSH
130961: LD_INT 1
130963: EQUAL
130964: IFFALSE 131010
// begin to_heal := to_heal diff group [ i ] ;
130966: LD_ADDR_VAR 0 30
130970: PUSH
130971: LD_VAR 0 30
130975: PUSH
130976: LD_VAR 0 4
130980: PUSH
130981: LD_VAR 0 7
130985: ARRAY
130986: DIFF
130987: ST_TO_ADDR
// healers := healers diff group [ i ] ;
130988: LD_ADDR_VAR 0 31
130992: PUSH
130993: LD_VAR 0 31
130997: PUSH
130998: LD_VAR 0 4
131002: PUSH
131003: LD_VAR 0 7
131007: ARRAY
131008: DIFF
131009: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
131010: LD_ADDR_VAR 0 4
131014: PUSH
131015: LD_VAR 0 4
131019: PPUSH
131020: LD_VAR 0 7
131024: PPUSH
131025: CALL_OW 3
131029: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
131030: LD_ADDR_VAR 0 16
131034: PUSH
131035: LD_VAR 0 16
131039: PPUSH
131040: LD_VAR 0 7
131044: PPUSH
131045: CALL_OW 3
131049: ST_TO_ADDR
// continue ;
131050: GO 130890
// end ; if f_repair then
131052: LD_VAR 0 22
131056: IFFALSE 131545
// begin if GetType ( group [ i ] ) = unit_vehicle then
131058: LD_VAR 0 4
131062: PUSH
131063: LD_VAR 0 7
131067: ARRAY
131068: PPUSH
131069: CALL_OW 247
131073: PUSH
131074: LD_INT 2
131076: EQUAL
131077: IFFALSE 131267
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
131079: LD_VAR 0 4
131083: PUSH
131084: LD_VAR 0 7
131088: ARRAY
131089: PPUSH
131090: CALL_OW 256
131094: PUSH
131095: LD_INT 700
131097: LESS
131098: PUSH
131099: LD_VAR 0 4
131103: PUSH
131104: LD_VAR 0 7
131108: ARRAY
131109: PUSH
131110: LD_VAR 0 32
131114: IN
131115: NOT
131116: AND
131117: IFFALSE 131141
// to_repair := to_repair union group [ i ] ;
131119: LD_ADDR_VAR 0 32
131123: PUSH
131124: LD_VAR 0 32
131128: PUSH
131129: LD_VAR 0 4
131133: PUSH
131134: LD_VAR 0 7
131138: ARRAY
131139: UNION
131140: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
131141: LD_VAR 0 4
131145: PUSH
131146: LD_VAR 0 7
131150: ARRAY
131151: PPUSH
131152: CALL_OW 256
131156: PUSH
131157: LD_INT 1000
131159: EQUAL
131160: PUSH
131161: LD_VAR 0 4
131165: PUSH
131166: LD_VAR 0 7
131170: ARRAY
131171: PUSH
131172: LD_VAR 0 32
131176: IN
131177: AND
131178: IFFALSE 131202
// to_repair := to_repair diff group [ i ] ;
131180: LD_ADDR_VAR 0 32
131184: PUSH
131185: LD_VAR 0 32
131189: PUSH
131190: LD_VAR 0 4
131194: PUSH
131195: LD_VAR 0 7
131199: ARRAY
131200: DIFF
131201: ST_TO_ADDR
// if group [ i ] in to_repair then
131202: LD_VAR 0 4
131206: PUSH
131207: LD_VAR 0 7
131211: ARRAY
131212: PUSH
131213: LD_VAR 0 32
131217: IN
131218: IFFALSE 131265
// begin if not IsInArea ( group [ i ] , f_repair ) then
131220: LD_VAR 0 4
131224: PUSH
131225: LD_VAR 0 7
131229: ARRAY
131230: PPUSH
131231: LD_VAR 0 22
131235: PPUSH
131236: CALL_OW 308
131240: NOT
131241: IFFALSE 131263
// ComMoveToArea ( group [ i ] , f_repair ) ;
131243: LD_VAR 0 4
131247: PUSH
131248: LD_VAR 0 7
131252: ARRAY
131253: PPUSH
131254: LD_VAR 0 22
131258: PPUSH
131259: CALL_OW 113
// continue ;
131263: GO 130890
// end ; end else
131265: GO 131545
// if group [ i ] in repairs then
131267: LD_VAR 0 4
131271: PUSH
131272: LD_VAR 0 7
131276: ARRAY
131277: PUSH
131278: LD_VAR 0 33
131282: IN
131283: IFFALSE 131545
// begin if IsInUnit ( group [ i ] ) then
131285: LD_VAR 0 4
131289: PUSH
131290: LD_VAR 0 7
131294: ARRAY
131295: PPUSH
131296: CALL_OW 310
131300: IFFALSE 131368
// begin z := IsInUnit ( group [ i ] ) ;
131302: LD_ADDR_VAR 0 13
131306: PUSH
131307: LD_VAR 0 4
131311: PUSH
131312: LD_VAR 0 7
131316: ARRAY
131317: PPUSH
131318: CALL_OW 310
131322: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
131323: LD_VAR 0 13
131327: PUSH
131328: LD_VAR 0 32
131332: IN
131333: PUSH
131334: LD_VAR 0 13
131338: PPUSH
131339: LD_VAR 0 22
131343: PPUSH
131344: CALL_OW 308
131348: AND
131349: IFFALSE 131366
// ComExitVehicle ( group [ i ] ) ;
131351: LD_VAR 0 4
131355: PUSH
131356: LD_VAR 0 7
131360: ARRAY
131361: PPUSH
131362: CALL_OW 121
// end else
131366: GO 131545
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
131368: LD_ADDR_VAR 0 13
131372: PUSH
131373: LD_VAR 0 4
131377: PPUSH
131378: LD_INT 95
131380: PUSH
131381: LD_VAR 0 22
131385: PUSH
131386: EMPTY
131387: LIST
131388: LIST
131389: PUSH
131390: LD_INT 58
131392: PUSH
131393: EMPTY
131394: LIST
131395: PUSH
131396: EMPTY
131397: LIST
131398: LIST
131399: PPUSH
131400: CALL_OW 72
131404: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
131405: LD_VAR 0 4
131409: PUSH
131410: LD_VAR 0 7
131414: ARRAY
131415: PPUSH
131416: CALL_OW 314
131420: NOT
131421: IFFALSE 131543
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
131423: LD_ADDR_VAR 0 10
131427: PUSH
131428: LD_VAR 0 13
131432: PPUSH
131433: LD_VAR 0 4
131437: PUSH
131438: LD_VAR 0 7
131442: ARRAY
131443: PPUSH
131444: CALL_OW 74
131448: ST_TO_ADDR
// if not x then
131449: LD_VAR 0 10
131453: NOT
131454: IFFALSE 131458
// continue ;
131456: GO 130890
// if GetLives ( x ) < 1000 then
131458: LD_VAR 0 10
131462: PPUSH
131463: CALL_OW 256
131467: PUSH
131468: LD_INT 1000
131470: LESS
131471: IFFALSE 131495
// ComRepairVehicle ( group [ i ] , x ) else
131473: LD_VAR 0 4
131477: PUSH
131478: LD_VAR 0 7
131482: ARRAY
131483: PPUSH
131484: LD_VAR 0 10
131488: PPUSH
131489: CALL_OW 129
131493: GO 131543
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
131495: LD_VAR 0 23
131499: PUSH
131500: LD_VAR 0 4
131504: PUSH
131505: LD_VAR 0 7
131509: ARRAY
131510: PPUSH
131511: CALL_OW 256
131515: PUSH
131516: LD_INT 1000
131518: LESS
131519: AND
131520: NOT
131521: IFFALSE 131543
// ComEnterUnit ( group [ i ] , x ) ;
131523: LD_VAR 0 4
131527: PUSH
131528: LD_VAR 0 7
131532: ARRAY
131533: PPUSH
131534: LD_VAR 0 10
131538: PPUSH
131539: CALL_OW 120
// end ; continue ;
131543: GO 130890
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
131545: LD_VAR 0 23
131549: PUSH
131550: LD_VAR 0 4
131554: PUSH
131555: LD_VAR 0 7
131559: ARRAY
131560: PPUSH
131561: CALL_OW 247
131565: PUSH
131566: LD_INT 1
131568: EQUAL
131569: AND
131570: IFFALSE 132048
// begin if group [ i ] in healers then
131572: LD_VAR 0 4
131576: PUSH
131577: LD_VAR 0 7
131581: ARRAY
131582: PUSH
131583: LD_VAR 0 31
131587: IN
131588: IFFALSE 131861
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
131590: LD_VAR 0 4
131594: PUSH
131595: LD_VAR 0 7
131599: ARRAY
131600: PPUSH
131601: LD_VAR 0 23
131605: PPUSH
131606: CALL_OW 308
131610: NOT
131611: PUSH
131612: LD_VAR 0 4
131616: PUSH
131617: LD_VAR 0 7
131621: ARRAY
131622: PPUSH
131623: CALL_OW 314
131627: NOT
131628: AND
131629: IFFALSE 131653
// ComMoveToArea ( group [ i ] , f_heal ) else
131631: LD_VAR 0 4
131635: PUSH
131636: LD_VAR 0 7
131640: ARRAY
131641: PPUSH
131642: LD_VAR 0 23
131646: PPUSH
131647: CALL_OW 113
131651: GO 131859
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
131653: LD_VAR 0 4
131657: PUSH
131658: LD_VAR 0 7
131662: ARRAY
131663: PPUSH
131664: CALL 103583 0 1
131668: PPUSH
131669: CALL_OW 256
131673: PUSH
131674: LD_INT 1000
131676: EQUAL
131677: IFFALSE 131696
// ComStop ( group [ i ] ) else
131679: LD_VAR 0 4
131683: PUSH
131684: LD_VAR 0 7
131688: ARRAY
131689: PPUSH
131690: CALL_OW 141
131694: GO 131859
// if not HasTask ( group [ i ] ) and to_heal then
131696: LD_VAR 0 4
131700: PUSH
131701: LD_VAR 0 7
131705: ARRAY
131706: PPUSH
131707: CALL_OW 314
131711: NOT
131712: PUSH
131713: LD_VAR 0 30
131717: AND
131718: IFFALSE 131859
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
131720: LD_ADDR_VAR 0 13
131724: PUSH
131725: LD_VAR 0 30
131729: PPUSH
131730: LD_INT 3
131732: PUSH
131733: LD_INT 54
131735: PUSH
131736: EMPTY
131737: LIST
131738: PUSH
131739: EMPTY
131740: LIST
131741: LIST
131742: PPUSH
131743: CALL_OW 72
131747: PPUSH
131748: LD_VAR 0 4
131752: PUSH
131753: LD_VAR 0 7
131757: ARRAY
131758: PPUSH
131759: CALL_OW 74
131763: ST_TO_ADDR
// if z then
131764: LD_VAR 0 13
131768: IFFALSE 131859
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
131770: LD_INT 91
131772: PUSH
131773: LD_VAR 0 13
131777: PUSH
131778: LD_INT 10
131780: PUSH
131781: EMPTY
131782: LIST
131783: LIST
131784: LIST
131785: PUSH
131786: LD_INT 81
131788: PUSH
131789: LD_VAR 0 13
131793: PPUSH
131794: CALL_OW 255
131798: PUSH
131799: EMPTY
131800: LIST
131801: LIST
131802: PUSH
131803: EMPTY
131804: LIST
131805: LIST
131806: PPUSH
131807: CALL_OW 69
131811: PUSH
131812: LD_INT 0
131814: EQUAL
131815: IFFALSE 131839
// ComHeal ( group [ i ] , z ) else
131817: LD_VAR 0 4
131821: PUSH
131822: LD_VAR 0 7
131826: ARRAY
131827: PPUSH
131828: LD_VAR 0 13
131832: PPUSH
131833: CALL_OW 128
131837: GO 131859
// ComMoveToArea ( group [ i ] , f_heal ) ;
131839: LD_VAR 0 4
131843: PUSH
131844: LD_VAR 0 7
131848: ARRAY
131849: PPUSH
131850: LD_VAR 0 23
131854: PPUSH
131855: CALL_OW 113
// end ; continue ;
131859: GO 130890
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
131861: LD_VAR 0 4
131865: PUSH
131866: LD_VAR 0 7
131870: ARRAY
131871: PPUSH
131872: CALL_OW 256
131876: PUSH
131877: LD_INT 700
131879: LESS
131880: PUSH
131881: LD_VAR 0 4
131885: PUSH
131886: LD_VAR 0 7
131890: ARRAY
131891: PUSH
131892: LD_VAR 0 30
131896: IN
131897: NOT
131898: AND
131899: IFFALSE 131923
// to_heal := to_heal union group [ i ] ;
131901: LD_ADDR_VAR 0 30
131905: PUSH
131906: LD_VAR 0 30
131910: PUSH
131911: LD_VAR 0 4
131915: PUSH
131916: LD_VAR 0 7
131920: ARRAY
131921: UNION
131922: ST_TO_ADDR
// if group [ i ] in to_heal then
131923: LD_VAR 0 4
131927: PUSH
131928: LD_VAR 0 7
131932: ARRAY
131933: PUSH
131934: LD_VAR 0 30
131938: IN
131939: IFFALSE 132048
// begin if GetLives ( group [ i ] ) = 1000 then
131941: LD_VAR 0 4
131945: PUSH
131946: LD_VAR 0 7
131950: ARRAY
131951: PPUSH
131952: CALL_OW 256
131956: PUSH
131957: LD_INT 1000
131959: EQUAL
131960: IFFALSE 131986
// to_heal := to_heal diff group [ i ] else
131962: LD_ADDR_VAR 0 30
131966: PUSH
131967: LD_VAR 0 30
131971: PUSH
131972: LD_VAR 0 4
131976: PUSH
131977: LD_VAR 0 7
131981: ARRAY
131982: DIFF
131983: ST_TO_ADDR
131984: GO 132048
// begin if not IsInArea ( group [ i ] , to_heal ) then
131986: LD_VAR 0 4
131990: PUSH
131991: LD_VAR 0 7
131995: ARRAY
131996: PPUSH
131997: LD_VAR 0 30
132001: PPUSH
132002: CALL_OW 308
132006: NOT
132007: IFFALSE 132031
// ComMoveToArea ( group [ i ] , f_heal ) else
132009: LD_VAR 0 4
132013: PUSH
132014: LD_VAR 0 7
132018: ARRAY
132019: PPUSH
132020: LD_VAR 0 23
132024: PPUSH
132025: CALL_OW 113
132029: GO 132046
// ComHold ( group [ i ] ) ;
132031: LD_VAR 0 4
132035: PUSH
132036: LD_VAR 0 7
132040: ARRAY
132041: PPUSH
132042: CALL_OW 140
// continue ;
132046: GO 130890
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
132048: LD_VAR 0 4
132052: PUSH
132053: LD_VAR 0 7
132057: ARRAY
132058: PPUSH
132059: LD_INT 10
132061: PPUSH
132062: CALL 101354 0 2
132066: NOT
132067: PUSH
132068: LD_VAR 0 16
132072: PUSH
132073: LD_VAR 0 7
132077: ARRAY
132078: PUSH
132079: EMPTY
132080: EQUAL
132081: NOT
132082: AND
132083: IFFALSE 132349
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
132085: LD_VAR 0 4
132089: PUSH
132090: LD_VAR 0 7
132094: ARRAY
132095: PPUSH
132096: CALL_OW 262
132100: PUSH
132101: LD_INT 1
132103: PUSH
132104: LD_INT 2
132106: PUSH
132107: EMPTY
132108: LIST
132109: LIST
132110: IN
132111: IFFALSE 132152
// if GetFuel ( group [ i ] ) < 10 then
132113: LD_VAR 0 4
132117: PUSH
132118: LD_VAR 0 7
132122: ARRAY
132123: PPUSH
132124: CALL_OW 261
132128: PUSH
132129: LD_INT 10
132131: LESS
132132: IFFALSE 132152
// SetFuel ( group [ i ] , 12 ) ;
132134: LD_VAR 0 4
132138: PUSH
132139: LD_VAR 0 7
132143: ARRAY
132144: PPUSH
132145: LD_INT 12
132147: PPUSH
132148: CALL_OW 240
// if units_path [ i ] then
132152: LD_VAR 0 16
132156: PUSH
132157: LD_VAR 0 7
132161: ARRAY
132162: IFFALSE 132347
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
132164: LD_VAR 0 4
132168: PUSH
132169: LD_VAR 0 7
132173: ARRAY
132174: PPUSH
132175: LD_VAR 0 16
132179: PUSH
132180: LD_VAR 0 7
132184: ARRAY
132185: PUSH
132186: LD_INT 1
132188: ARRAY
132189: PUSH
132190: LD_INT 1
132192: ARRAY
132193: PPUSH
132194: LD_VAR 0 16
132198: PUSH
132199: LD_VAR 0 7
132203: ARRAY
132204: PUSH
132205: LD_INT 1
132207: ARRAY
132208: PUSH
132209: LD_INT 2
132211: ARRAY
132212: PPUSH
132213: CALL_OW 297
132217: PUSH
132218: LD_INT 6
132220: GREATER
132221: IFFALSE 132296
// begin if not HasTask ( group [ i ] ) then
132223: LD_VAR 0 4
132227: PUSH
132228: LD_VAR 0 7
132232: ARRAY
132233: PPUSH
132234: CALL_OW 314
132238: NOT
132239: IFFALSE 132294
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
132241: LD_VAR 0 4
132245: PUSH
132246: LD_VAR 0 7
132250: ARRAY
132251: PPUSH
132252: LD_VAR 0 16
132256: PUSH
132257: LD_VAR 0 7
132261: ARRAY
132262: PUSH
132263: LD_INT 1
132265: ARRAY
132266: PUSH
132267: LD_INT 1
132269: ARRAY
132270: PPUSH
132271: LD_VAR 0 16
132275: PUSH
132276: LD_VAR 0 7
132280: ARRAY
132281: PUSH
132282: LD_INT 1
132284: ARRAY
132285: PUSH
132286: LD_INT 2
132288: ARRAY
132289: PPUSH
132290: CALL_OW 114
// end else
132294: GO 132347
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
132296: LD_ADDR_VAR 0 15
132300: PUSH
132301: LD_VAR 0 16
132305: PUSH
132306: LD_VAR 0 7
132310: ARRAY
132311: PPUSH
132312: LD_INT 1
132314: PPUSH
132315: CALL_OW 3
132319: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
132320: LD_ADDR_VAR 0 16
132324: PUSH
132325: LD_VAR 0 16
132329: PPUSH
132330: LD_VAR 0 7
132334: PPUSH
132335: LD_VAR 0 15
132339: PPUSH
132340: CALL_OW 1
132344: ST_TO_ADDR
// continue ;
132345: GO 130890
// end ; end ; end else
132347: GO 135011
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
132349: LD_ADDR_VAR 0 14
132353: PUSH
132354: LD_INT 81
132356: PUSH
132357: LD_VAR 0 4
132361: PUSH
132362: LD_VAR 0 7
132366: ARRAY
132367: PPUSH
132368: CALL_OW 255
132372: PUSH
132373: EMPTY
132374: LIST
132375: LIST
132376: PPUSH
132377: CALL_OW 69
132381: ST_TO_ADDR
// if not tmp then
132382: LD_VAR 0 14
132386: NOT
132387: IFFALSE 132391
// continue ;
132389: GO 130890
// if f_ignore_area then
132391: LD_VAR 0 17
132395: IFFALSE 132483
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
132397: LD_ADDR_VAR 0 15
132401: PUSH
132402: LD_VAR 0 14
132406: PPUSH
132407: LD_INT 3
132409: PUSH
132410: LD_INT 92
132412: PUSH
132413: LD_VAR 0 17
132417: PUSH
132418: LD_INT 1
132420: ARRAY
132421: PUSH
132422: LD_VAR 0 17
132426: PUSH
132427: LD_INT 2
132429: ARRAY
132430: PUSH
132431: LD_VAR 0 17
132435: PUSH
132436: LD_INT 3
132438: ARRAY
132439: PUSH
132440: EMPTY
132441: LIST
132442: LIST
132443: LIST
132444: LIST
132445: PUSH
132446: EMPTY
132447: LIST
132448: LIST
132449: PPUSH
132450: CALL_OW 72
132454: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
132455: LD_VAR 0 14
132459: PUSH
132460: LD_VAR 0 15
132464: DIFF
132465: IFFALSE 132483
// tmp := tmp diff tmp2 ;
132467: LD_ADDR_VAR 0 14
132471: PUSH
132472: LD_VAR 0 14
132476: PUSH
132477: LD_VAR 0 15
132481: DIFF
132482: ST_TO_ADDR
// end ; if not f_murder then
132483: LD_VAR 0 20
132487: NOT
132488: IFFALSE 132546
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
132490: LD_ADDR_VAR 0 15
132494: PUSH
132495: LD_VAR 0 14
132499: PPUSH
132500: LD_INT 3
132502: PUSH
132503: LD_INT 50
132505: PUSH
132506: EMPTY
132507: LIST
132508: PUSH
132509: EMPTY
132510: LIST
132511: LIST
132512: PPUSH
132513: CALL_OW 72
132517: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
132518: LD_VAR 0 14
132522: PUSH
132523: LD_VAR 0 15
132527: DIFF
132528: IFFALSE 132546
// tmp := tmp diff tmp2 ;
132530: LD_ADDR_VAR 0 14
132534: PUSH
132535: LD_VAR 0 14
132539: PUSH
132540: LD_VAR 0 15
132544: DIFF
132545: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
132546: LD_ADDR_VAR 0 14
132550: PUSH
132551: LD_VAR 0 4
132555: PUSH
132556: LD_VAR 0 7
132560: ARRAY
132561: PPUSH
132562: LD_VAR 0 14
132566: PPUSH
132567: LD_INT 1
132569: PPUSH
132570: LD_INT 1
132572: PPUSH
132573: CALL 74295 0 4
132577: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
132578: LD_VAR 0 4
132582: PUSH
132583: LD_VAR 0 7
132587: ARRAY
132588: PPUSH
132589: CALL_OW 257
132593: PUSH
132594: LD_INT 1
132596: EQUAL
132597: IFFALSE 133045
// begin if WantPlant ( group [ i ] ) then
132599: LD_VAR 0 4
132603: PUSH
132604: LD_VAR 0 7
132608: ARRAY
132609: PPUSH
132610: CALL 73796 0 1
132614: IFFALSE 132618
// continue ;
132616: GO 130890
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
132618: LD_VAR 0 18
132622: PUSH
132623: LD_VAR 0 4
132627: PUSH
132628: LD_VAR 0 7
132632: ARRAY
132633: PPUSH
132634: CALL_OW 310
132638: NOT
132639: AND
132640: PUSH
132641: LD_VAR 0 14
132645: PUSH
132646: LD_INT 1
132648: ARRAY
132649: PUSH
132650: LD_VAR 0 14
132654: PPUSH
132655: LD_INT 21
132657: PUSH
132658: LD_INT 2
132660: PUSH
132661: EMPTY
132662: LIST
132663: LIST
132664: PUSH
132665: LD_INT 58
132667: PUSH
132668: EMPTY
132669: LIST
132670: PUSH
132671: EMPTY
132672: LIST
132673: LIST
132674: PPUSH
132675: CALL_OW 72
132679: IN
132680: AND
132681: IFFALSE 132717
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
132683: LD_VAR 0 4
132687: PUSH
132688: LD_VAR 0 7
132692: ARRAY
132693: PPUSH
132694: LD_VAR 0 14
132698: PUSH
132699: LD_INT 1
132701: ARRAY
132702: PPUSH
132703: CALL_OW 120
// attacking := true ;
132707: LD_ADDR_VAR 0 29
132711: PUSH
132712: LD_INT 1
132714: ST_TO_ADDR
// continue ;
132715: GO 130890
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
132717: LD_VAR 0 26
132721: PUSH
132722: LD_VAR 0 4
132726: PUSH
132727: LD_VAR 0 7
132731: ARRAY
132732: PPUSH
132733: CALL_OW 257
132737: PUSH
132738: LD_INT 1
132740: EQUAL
132741: AND
132742: PUSH
132743: LD_VAR 0 4
132747: PUSH
132748: LD_VAR 0 7
132752: ARRAY
132753: PPUSH
132754: CALL_OW 256
132758: PUSH
132759: LD_INT 800
132761: LESS
132762: AND
132763: PUSH
132764: LD_VAR 0 4
132768: PUSH
132769: LD_VAR 0 7
132773: ARRAY
132774: PPUSH
132775: CALL_OW 318
132779: NOT
132780: AND
132781: IFFALSE 132798
// ComCrawl ( group [ i ] ) ;
132783: LD_VAR 0 4
132787: PUSH
132788: LD_VAR 0 7
132792: ARRAY
132793: PPUSH
132794: CALL_OW 137
// if f_mines then
132798: LD_VAR 0 21
132802: IFFALSE 133045
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
132804: LD_VAR 0 14
132808: PUSH
132809: LD_INT 1
132811: ARRAY
132812: PPUSH
132813: CALL_OW 247
132817: PUSH
132818: LD_INT 3
132820: EQUAL
132821: PUSH
132822: LD_VAR 0 14
132826: PUSH
132827: LD_INT 1
132829: ARRAY
132830: PUSH
132831: LD_VAR 0 27
132835: IN
132836: NOT
132837: AND
132838: IFFALSE 133045
// begin x := GetX ( tmp [ 1 ] ) ;
132840: LD_ADDR_VAR 0 10
132844: PUSH
132845: LD_VAR 0 14
132849: PUSH
132850: LD_INT 1
132852: ARRAY
132853: PPUSH
132854: CALL_OW 250
132858: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
132859: LD_ADDR_VAR 0 11
132863: PUSH
132864: LD_VAR 0 14
132868: PUSH
132869: LD_INT 1
132871: ARRAY
132872: PPUSH
132873: CALL_OW 251
132877: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
132878: LD_ADDR_VAR 0 12
132882: PUSH
132883: LD_VAR 0 4
132887: PUSH
132888: LD_VAR 0 7
132892: ARRAY
132893: PPUSH
132894: CALL 101439 0 1
132898: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
132899: LD_VAR 0 4
132903: PUSH
132904: LD_VAR 0 7
132908: ARRAY
132909: PPUSH
132910: LD_VAR 0 10
132914: PPUSH
132915: LD_VAR 0 11
132919: PPUSH
132920: LD_VAR 0 14
132924: PUSH
132925: LD_INT 1
132927: ARRAY
132928: PPUSH
132929: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
132933: LD_VAR 0 4
132937: PUSH
132938: LD_VAR 0 7
132942: ARRAY
132943: PPUSH
132944: LD_VAR 0 10
132948: PPUSH
132949: LD_VAR 0 12
132953: PPUSH
132954: LD_INT 7
132956: PPUSH
132957: CALL_OW 272
132961: PPUSH
132962: LD_VAR 0 11
132966: PPUSH
132967: LD_VAR 0 12
132971: PPUSH
132972: LD_INT 7
132974: PPUSH
132975: CALL_OW 273
132979: PPUSH
132980: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
132984: LD_VAR 0 4
132988: PUSH
132989: LD_VAR 0 7
132993: ARRAY
132994: PPUSH
132995: LD_INT 71
132997: PPUSH
132998: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
133002: LD_ADDR_VAR 0 27
133006: PUSH
133007: LD_VAR 0 27
133011: PPUSH
133012: LD_VAR 0 27
133016: PUSH
133017: LD_INT 1
133019: PLUS
133020: PPUSH
133021: LD_VAR 0 14
133025: PUSH
133026: LD_INT 1
133028: ARRAY
133029: PPUSH
133030: CALL_OW 1
133034: ST_TO_ADDR
// attacking := true ;
133035: LD_ADDR_VAR 0 29
133039: PUSH
133040: LD_INT 1
133042: ST_TO_ADDR
// continue ;
133043: GO 130890
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
133045: LD_VAR 0 4
133049: PUSH
133050: LD_VAR 0 7
133054: ARRAY
133055: PPUSH
133056: CALL_OW 257
133060: PUSH
133061: LD_INT 17
133063: EQUAL
133064: PUSH
133065: LD_VAR 0 4
133069: PUSH
133070: LD_VAR 0 7
133074: ARRAY
133075: PPUSH
133076: CALL_OW 110
133080: PUSH
133081: LD_INT 71
133083: EQUAL
133084: NOT
133085: AND
133086: IFFALSE 133232
// begin attacking := false ;
133088: LD_ADDR_VAR 0 29
133092: PUSH
133093: LD_INT 0
133095: ST_TO_ADDR
// k := 5 ;
133096: LD_ADDR_VAR 0 9
133100: PUSH
133101: LD_INT 5
133103: ST_TO_ADDR
// if tmp < k then
133104: LD_VAR 0 14
133108: PUSH
133109: LD_VAR 0 9
133113: LESS
133114: IFFALSE 133126
// k := tmp ;
133116: LD_ADDR_VAR 0 9
133120: PUSH
133121: LD_VAR 0 14
133125: ST_TO_ADDR
// for j = 1 to k do
133126: LD_ADDR_VAR 0 8
133130: PUSH
133131: DOUBLE
133132: LD_INT 1
133134: DEC
133135: ST_TO_ADDR
133136: LD_VAR 0 9
133140: PUSH
133141: FOR_TO
133142: IFFALSE 133230
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
133144: LD_VAR 0 14
133148: PUSH
133149: LD_VAR 0 8
133153: ARRAY
133154: PUSH
133155: LD_VAR 0 14
133159: PPUSH
133160: LD_INT 58
133162: PUSH
133163: EMPTY
133164: LIST
133165: PPUSH
133166: CALL_OW 72
133170: IN
133171: NOT
133172: IFFALSE 133228
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
133174: LD_VAR 0 4
133178: PUSH
133179: LD_VAR 0 7
133183: ARRAY
133184: PPUSH
133185: LD_VAR 0 14
133189: PUSH
133190: LD_VAR 0 8
133194: ARRAY
133195: PPUSH
133196: CALL_OW 115
// attacking := true ;
133200: LD_ADDR_VAR 0 29
133204: PUSH
133205: LD_INT 1
133207: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
133208: LD_VAR 0 4
133212: PUSH
133213: LD_VAR 0 7
133217: ARRAY
133218: PPUSH
133219: LD_INT 71
133221: PPUSH
133222: CALL_OW 109
// continue ;
133226: GO 133141
// end ; end ;
133228: GO 133141
133230: POP
133231: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
133232: LD_VAR 0 4
133236: PUSH
133237: LD_VAR 0 7
133241: ARRAY
133242: PPUSH
133243: CALL_OW 257
133247: PUSH
133248: LD_INT 8
133250: EQUAL
133251: PUSH
133252: LD_VAR 0 4
133256: PUSH
133257: LD_VAR 0 7
133261: ARRAY
133262: PPUSH
133263: CALL_OW 264
133267: PUSH
133268: LD_INT 28
133270: PUSH
133271: LD_INT 45
133273: PUSH
133274: LD_INT 7
133276: PUSH
133277: LD_INT 47
133279: PUSH
133280: EMPTY
133281: LIST
133282: LIST
133283: LIST
133284: LIST
133285: IN
133286: OR
133287: IFFALSE 133543
// begin attacking := false ;
133289: LD_ADDR_VAR 0 29
133293: PUSH
133294: LD_INT 0
133296: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
133297: LD_VAR 0 14
133301: PUSH
133302: LD_INT 1
133304: ARRAY
133305: PPUSH
133306: CALL_OW 266
133310: PUSH
133311: LD_INT 32
133313: PUSH
133314: LD_INT 31
133316: PUSH
133317: LD_INT 33
133319: PUSH
133320: LD_INT 4
133322: PUSH
133323: LD_INT 5
133325: PUSH
133326: EMPTY
133327: LIST
133328: LIST
133329: LIST
133330: LIST
133331: LIST
133332: IN
133333: IFFALSE 133519
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
133335: LD_ADDR_VAR 0 9
133339: PUSH
133340: LD_VAR 0 14
133344: PUSH
133345: LD_INT 1
133347: ARRAY
133348: PPUSH
133349: CALL_OW 266
133353: PPUSH
133354: LD_VAR 0 14
133358: PUSH
133359: LD_INT 1
133361: ARRAY
133362: PPUSH
133363: CALL_OW 250
133367: PPUSH
133368: LD_VAR 0 14
133372: PUSH
133373: LD_INT 1
133375: ARRAY
133376: PPUSH
133377: CALL_OW 251
133381: PPUSH
133382: LD_VAR 0 14
133386: PUSH
133387: LD_INT 1
133389: ARRAY
133390: PPUSH
133391: CALL_OW 254
133395: PPUSH
133396: LD_VAR 0 14
133400: PUSH
133401: LD_INT 1
133403: ARRAY
133404: PPUSH
133405: CALL_OW 248
133409: PPUSH
133410: LD_INT 0
133412: PPUSH
133413: CALL 82809 0 6
133417: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
133418: LD_ADDR_VAR 0 8
133422: PUSH
133423: LD_VAR 0 4
133427: PUSH
133428: LD_VAR 0 7
133432: ARRAY
133433: PPUSH
133434: LD_VAR 0 9
133438: PPUSH
133439: CALL 101552 0 2
133443: ST_TO_ADDR
// if j then
133444: LD_VAR 0 8
133448: IFFALSE 133517
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
133450: LD_VAR 0 8
133454: PUSH
133455: LD_INT 1
133457: ARRAY
133458: PPUSH
133459: LD_VAR 0 8
133463: PUSH
133464: LD_INT 2
133466: ARRAY
133467: PPUSH
133468: CALL_OW 488
133472: IFFALSE 133517
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
133474: LD_VAR 0 4
133478: PUSH
133479: LD_VAR 0 7
133483: ARRAY
133484: PPUSH
133485: LD_VAR 0 8
133489: PUSH
133490: LD_INT 1
133492: ARRAY
133493: PPUSH
133494: LD_VAR 0 8
133498: PUSH
133499: LD_INT 2
133501: ARRAY
133502: PPUSH
133503: CALL_OW 116
// attacking := true ;
133507: LD_ADDR_VAR 0 29
133511: PUSH
133512: LD_INT 1
133514: ST_TO_ADDR
// continue ;
133515: GO 130890
// end ; end else
133517: GO 133543
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133519: LD_VAR 0 4
133523: PUSH
133524: LD_VAR 0 7
133528: ARRAY
133529: PPUSH
133530: LD_VAR 0 14
133534: PUSH
133535: LD_INT 1
133537: ARRAY
133538: PPUSH
133539: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
133543: LD_VAR 0 4
133547: PUSH
133548: LD_VAR 0 7
133552: ARRAY
133553: PPUSH
133554: CALL_OW 265
133558: PUSH
133559: LD_INT 11
133561: EQUAL
133562: IFFALSE 133840
// begin k := 10 ;
133564: LD_ADDR_VAR 0 9
133568: PUSH
133569: LD_INT 10
133571: ST_TO_ADDR
// x := 0 ;
133572: LD_ADDR_VAR 0 10
133576: PUSH
133577: LD_INT 0
133579: ST_TO_ADDR
// if tmp < k then
133580: LD_VAR 0 14
133584: PUSH
133585: LD_VAR 0 9
133589: LESS
133590: IFFALSE 133602
// k := tmp ;
133592: LD_ADDR_VAR 0 9
133596: PUSH
133597: LD_VAR 0 14
133601: ST_TO_ADDR
// for j = k downto 1 do
133602: LD_ADDR_VAR 0 8
133606: PUSH
133607: DOUBLE
133608: LD_VAR 0 9
133612: INC
133613: ST_TO_ADDR
133614: LD_INT 1
133616: PUSH
133617: FOR_DOWNTO
133618: IFFALSE 133693
// begin if GetType ( tmp [ j ] ) = unit_human then
133620: LD_VAR 0 14
133624: PUSH
133625: LD_VAR 0 8
133629: ARRAY
133630: PPUSH
133631: CALL_OW 247
133635: PUSH
133636: LD_INT 1
133638: EQUAL
133639: IFFALSE 133691
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
133641: LD_VAR 0 4
133645: PUSH
133646: LD_VAR 0 7
133650: ARRAY
133651: PPUSH
133652: LD_VAR 0 14
133656: PUSH
133657: LD_VAR 0 8
133661: ARRAY
133662: PPUSH
133663: CALL 101806 0 2
// x := tmp [ j ] ;
133667: LD_ADDR_VAR 0 10
133671: PUSH
133672: LD_VAR 0 14
133676: PUSH
133677: LD_VAR 0 8
133681: ARRAY
133682: ST_TO_ADDR
// attacking := true ;
133683: LD_ADDR_VAR 0 29
133687: PUSH
133688: LD_INT 1
133690: ST_TO_ADDR
// end ; end ;
133691: GO 133617
133693: POP
133694: POP
// if not x then
133695: LD_VAR 0 10
133699: NOT
133700: IFFALSE 133840
// begin attacking := true ;
133702: LD_ADDR_VAR 0 29
133706: PUSH
133707: LD_INT 1
133709: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
133710: LD_VAR 0 4
133714: PUSH
133715: LD_VAR 0 7
133719: ARRAY
133720: PPUSH
133721: CALL_OW 250
133725: PPUSH
133726: LD_VAR 0 4
133730: PUSH
133731: LD_VAR 0 7
133735: ARRAY
133736: PPUSH
133737: CALL_OW 251
133741: PPUSH
133742: CALL_OW 546
133746: PUSH
133747: LD_INT 2
133749: ARRAY
133750: PUSH
133751: LD_VAR 0 14
133755: PUSH
133756: LD_INT 1
133758: ARRAY
133759: PPUSH
133760: CALL_OW 250
133764: PPUSH
133765: LD_VAR 0 14
133769: PUSH
133770: LD_INT 1
133772: ARRAY
133773: PPUSH
133774: CALL_OW 251
133778: PPUSH
133779: CALL_OW 546
133783: PUSH
133784: LD_INT 2
133786: ARRAY
133787: EQUAL
133788: IFFALSE 133816
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
133790: LD_VAR 0 4
133794: PUSH
133795: LD_VAR 0 7
133799: ARRAY
133800: PPUSH
133801: LD_VAR 0 14
133805: PUSH
133806: LD_INT 1
133808: ARRAY
133809: PPUSH
133810: CALL 101806 0 2
133814: GO 133840
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
133816: LD_VAR 0 4
133820: PUSH
133821: LD_VAR 0 7
133825: ARRAY
133826: PPUSH
133827: LD_VAR 0 14
133831: PUSH
133832: LD_INT 1
133834: ARRAY
133835: PPUSH
133836: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
133840: LD_VAR 0 4
133844: PUSH
133845: LD_VAR 0 7
133849: ARRAY
133850: PPUSH
133851: CALL_OW 264
133855: PUSH
133856: LD_INT 29
133858: EQUAL
133859: IFFALSE 134225
// begin if WantsToAttack ( group [ i ] ) in bombed then
133861: LD_VAR 0 4
133865: PUSH
133866: LD_VAR 0 7
133870: ARRAY
133871: PPUSH
133872: CALL_OW 319
133876: PUSH
133877: LD_VAR 0 28
133881: IN
133882: IFFALSE 133886
// continue ;
133884: GO 130890
// k := 8 ;
133886: LD_ADDR_VAR 0 9
133890: PUSH
133891: LD_INT 8
133893: ST_TO_ADDR
// x := 0 ;
133894: LD_ADDR_VAR 0 10
133898: PUSH
133899: LD_INT 0
133901: ST_TO_ADDR
// if tmp < k then
133902: LD_VAR 0 14
133906: PUSH
133907: LD_VAR 0 9
133911: LESS
133912: IFFALSE 133924
// k := tmp ;
133914: LD_ADDR_VAR 0 9
133918: PUSH
133919: LD_VAR 0 14
133923: ST_TO_ADDR
// for j = 1 to k do
133924: LD_ADDR_VAR 0 8
133928: PUSH
133929: DOUBLE
133930: LD_INT 1
133932: DEC
133933: ST_TO_ADDR
133934: LD_VAR 0 9
133938: PUSH
133939: FOR_TO
133940: IFFALSE 134072
// begin if GetType ( tmp [ j ] ) = unit_building then
133942: LD_VAR 0 14
133946: PUSH
133947: LD_VAR 0 8
133951: ARRAY
133952: PPUSH
133953: CALL_OW 247
133957: PUSH
133958: LD_INT 3
133960: EQUAL
133961: IFFALSE 134070
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
133963: LD_VAR 0 14
133967: PUSH
133968: LD_VAR 0 8
133972: ARRAY
133973: PUSH
133974: LD_VAR 0 28
133978: IN
133979: NOT
133980: PUSH
133981: LD_VAR 0 14
133985: PUSH
133986: LD_VAR 0 8
133990: ARRAY
133991: PPUSH
133992: CALL_OW 313
133996: AND
133997: IFFALSE 134070
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
133999: LD_VAR 0 4
134003: PUSH
134004: LD_VAR 0 7
134008: ARRAY
134009: PPUSH
134010: LD_VAR 0 14
134014: PUSH
134015: LD_VAR 0 8
134019: ARRAY
134020: PPUSH
134021: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
134025: LD_ADDR_VAR 0 28
134029: PUSH
134030: LD_VAR 0 28
134034: PPUSH
134035: LD_VAR 0 28
134039: PUSH
134040: LD_INT 1
134042: PLUS
134043: PPUSH
134044: LD_VAR 0 14
134048: PUSH
134049: LD_VAR 0 8
134053: ARRAY
134054: PPUSH
134055: CALL_OW 1
134059: ST_TO_ADDR
// attacking := true ;
134060: LD_ADDR_VAR 0 29
134064: PUSH
134065: LD_INT 1
134067: ST_TO_ADDR
// break ;
134068: GO 134072
// end ; end ;
134070: GO 133939
134072: POP
134073: POP
// if not attacking and f_attack_depot then
134074: LD_VAR 0 29
134078: NOT
134079: PUSH
134080: LD_VAR 0 25
134084: AND
134085: IFFALSE 134180
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
134087: LD_ADDR_VAR 0 13
134091: PUSH
134092: LD_VAR 0 14
134096: PPUSH
134097: LD_INT 2
134099: PUSH
134100: LD_INT 30
134102: PUSH
134103: LD_INT 0
134105: PUSH
134106: EMPTY
134107: LIST
134108: LIST
134109: PUSH
134110: LD_INT 30
134112: PUSH
134113: LD_INT 1
134115: PUSH
134116: EMPTY
134117: LIST
134118: LIST
134119: PUSH
134120: EMPTY
134121: LIST
134122: LIST
134123: LIST
134124: PPUSH
134125: CALL_OW 72
134129: ST_TO_ADDR
// if z then
134130: LD_VAR 0 13
134134: IFFALSE 134180
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
134136: LD_VAR 0 4
134140: PUSH
134141: LD_VAR 0 7
134145: ARRAY
134146: PPUSH
134147: LD_VAR 0 13
134151: PPUSH
134152: LD_VAR 0 4
134156: PUSH
134157: LD_VAR 0 7
134161: ARRAY
134162: PPUSH
134163: CALL_OW 74
134167: PPUSH
134168: CALL_OW 115
// attacking := true ;
134172: LD_ADDR_VAR 0 29
134176: PUSH
134177: LD_INT 1
134179: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
134180: LD_VAR 0 4
134184: PUSH
134185: LD_VAR 0 7
134189: ARRAY
134190: PPUSH
134191: CALL_OW 256
134195: PUSH
134196: LD_INT 500
134198: LESS
134199: IFFALSE 134225
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
134201: LD_VAR 0 4
134205: PUSH
134206: LD_VAR 0 7
134210: ARRAY
134211: PPUSH
134212: LD_VAR 0 14
134216: PUSH
134217: LD_INT 1
134219: ARRAY
134220: PPUSH
134221: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
134225: LD_VAR 0 4
134229: PUSH
134230: LD_VAR 0 7
134234: ARRAY
134235: PPUSH
134236: CALL_OW 264
134240: PUSH
134241: LD_INT 49
134243: EQUAL
134244: IFFALSE 134365
// begin if not HasTask ( group [ i ] ) then
134246: LD_VAR 0 4
134250: PUSH
134251: LD_VAR 0 7
134255: ARRAY
134256: PPUSH
134257: CALL_OW 314
134261: NOT
134262: IFFALSE 134365
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
134264: LD_ADDR_VAR 0 9
134268: PUSH
134269: LD_INT 81
134271: PUSH
134272: LD_VAR 0 4
134276: PUSH
134277: LD_VAR 0 7
134281: ARRAY
134282: PPUSH
134283: CALL_OW 255
134287: PUSH
134288: EMPTY
134289: LIST
134290: LIST
134291: PPUSH
134292: CALL_OW 69
134296: PPUSH
134297: LD_VAR 0 4
134301: PUSH
134302: LD_VAR 0 7
134306: ARRAY
134307: PPUSH
134308: CALL_OW 74
134312: ST_TO_ADDR
// if k then
134313: LD_VAR 0 9
134317: IFFALSE 134365
// if GetDistUnits ( group [ i ] , k ) > 10 then
134319: LD_VAR 0 4
134323: PUSH
134324: LD_VAR 0 7
134328: ARRAY
134329: PPUSH
134330: LD_VAR 0 9
134334: PPUSH
134335: CALL_OW 296
134339: PUSH
134340: LD_INT 10
134342: GREATER
134343: IFFALSE 134365
// ComMoveUnit ( group [ i ] , k ) ;
134345: LD_VAR 0 4
134349: PUSH
134350: LD_VAR 0 7
134354: ARRAY
134355: PPUSH
134356: LD_VAR 0 9
134360: PPUSH
134361: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
134365: LD_VAR 0 4
134369: PUSH
134370: LD_VAR 0 7
134374: ARRAY
134375: PPUSH
134376: CALL_OW 256
134380: PUSH
134381: LD_INT 250
134383: LESS
134384: PUSH
134385: LD_VAR 0 4
134389: PUSH
134390: LD_VAR 0 7
134394: ARRAY
134395: PUSH
134396: LD_INT 21
134398: PUSH
134399: LD_INT 2
134401: PUSH
134402: EMPTY
134403: LIST
134404: LIST
134405: PUSH
134406: LD_INT 23
134408: PUSH
134409: LD_INT 2
134411: PUSH
134412: EMPTY
134413: LIST
134414: LIST
134415: PUSH
134416: EMPTY
134417: LIST
134418: LIST
134419: PPUSH
134420: CALL_OW 69
134424: IN
134425: AND
134426: IFFALSE 134551
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
134428: LD_ADDR_VAR 0 9
134432: PUSH
134433: LD_OWVAR 3
134437: PUSH
134438: LD_VAR 0 4
134442: PUSH
134443: LD_VAR 0 7
134447: ARRAY
134448: DIFF
134449: PPUSH
134450: LD_VAR 0 4
134454: PUSH
134455: LD_VAR 0 7
134459: ARRAY
134460: PPUSH
134461: CALL_OW 74
134465: ST_TO_ADDR
// if not k then
134466: LD_VAR 0 9
134470: NOT
134471: IFFALSE 134475
// continue ;
134473: GO 130890
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
134475: LD_VAR 0 9
134479: PUSH
134480: LD_INT 81
134482: PUSH
134483: LD_VAR 0 4
134487: PUSH
134488: LD_VAR 0 7
134492: ARRAY
134493: PPUSH
134494: CALL_OW 255
134498: PUSH
134499: EMPTY
134500: LIST
134501: LIST
134502: PPUSH
134503: CALL_OW 69
134507: IN
134508: PUSH
134509: LD_VAR 0 9
134513: PPUSH
134514: LD_VAR 0 4
134518: PUSH
134519: LD_VAR 0 7
134523: ARRAY
134524: PPUSH
134525: CALL_OW 296
134529: PUSH
134530: LD_INT 5
134532: LESS
134533: AND
134534: IFFALSE 134551
// ComAutodestruct ( group [ i ] ) ;
134536: LD_VAR 0 4
134540: PUSH
134541: LD_VAR 0 7
134545: ARRAY
134546: PPUSH
134547: CALL 101704 0 1
// end ; if f_attack_depot then
134551: LD_VAR 0 25
134555: IFFALSE 134667
// begin k := 6 ;
134557: LD_ADDR_VAR 0 9
134561: PUSH
134562: LD_INT 6
134564: ST_TO_ADDR
// if tmp < k then
134565: LD_VAR 0 14
134569: PUSH
134570: LD_VAR 0 9
134574: LESS
134575: IFFALSE 134587
// k := tmp ;
134577: LD_ADDR_VAR 0 9
134581: PUSH
134582: LD_VAR 0 14
134586: ST_TO_ADDR
// for j = 1 to k do
134587: LD_ADDR_VAR 0 8
134591: PUSH
134592: DOUBLE
134593: LD_INT 1
134595: DEC
134596: ST_TO_ADDR
134597: LD_VAR 0 9
134601: PUSH
134602: FOR_TO
134603: IFFALSE 134665
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
134605: LD_VAR 0 8
134609: PPUSH
134610: CALL_OW 266
134614: PUSH
134615: LD_INT 0
134617: PUSH
134618: LD_INT 1
134620: PUSH
134621: EMPTY
134622: LIST
134623: LIST
134624: IN
134625: IFFALSE 134663
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
134627: LD_VAR 0 4
134631: PUSH
134632: LD_VAR 0 7
134636: ARRAY
134637: PPUSH
134638: LD_VAR 0 14
134642: PUSH
134643: LD_VAR 0 8
134647: ARRAY
134648: PPUSH
134649: CALL_OW 115
// attacking := true ;
134653: LD_ADDR_VAR 0 29
134657: PUSH
134658: LD_INT 1
134660: ST_TO_ADDR
// break ;
134661: GO 134665
// end ;
134663: GO 134602
134665: POP
134666: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
134667: LD_VAR 0 4
134671: PUSH
134672: LD_VAR 0 7
134676: ARRAY
134677: PPUSH
134678: CALL_OW 302
134682: PUSH
134683: LD_VAR 0 29
134687: NOT
134688: AND
134689: IFFALSE 135011
// begin if GetTag ( group [ i ] ) = 71 then
134691: LD_VAR 0 4
134695: PUSH
134696: LD_VAR 0 7
134700: ARRAY
134701: PPUSH
134702: CALL_OW 110
134706: PUSH
134707: LD_INT 71
134709: EQUAL
134710: IFFALSE 134751
// begin if HasTask ( group [ i ] ) then
134712: LD_VAR 0 4
134716: PUSH
134717: LD_VAR 0 7
134721: ARRAY
134722: PPUSH
134723: CALL_OW 314
134727: IFFALSE 134733
// continue else
134729: GO 130890
134731: GO 134751
// SetTag ( group [ i ] , 0 ) ;
134733: LD_VAR 0 4
134737: PUSH
134738: LD_VAR 0 7
134742: ARRAY
134743: PPUSH
134744: LD_INT 0
134746: PPUSH
134747: CALL_OW 109
// end ; k := 8 ;
134751: LD_ADDR_VAR 0 9
134755: PUSH
134756: LD_INT 8
134758: ST_TO_ADDR
// x := 0 ;
134759: LD_ADDR_VAR 0 10
134763: PUSH
134764: LD_INT 0
134766: ST_TO_ADDR
// if tmp < k then
134767: LD_VAR 0 14
134771: PUSH
134772: LD_VAR 0 9
134776: LESS
134777: IFFALSE 134789
// k := tmp ;
134779: LD_ADDR_VAR 0 9
134783: PUSH
134784: LD_VAR 0 14
134788: ST_TO_ADDR
// for j = 1 to k do
134789: LD_ADDR_VAR 0 8
134793: PUSH
134794: DOUBLE
134795: LD_INT 1
134797: DEC
134798: ST_TO_ADDR
134799: LD_VAR 0 9
134803: PUSH
134804: FOR_TO
134805: IFFALSE 134903
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
134807: LD_VAR 0 14
134811: PUSH
134812: LD_VAR 0 8
134816: ARRAY
134817: PPUSH
134818: CALL_OW 247
134822: PUSH
134823: LD_INT 1
134825: EQUAL
134826: PUSH
134827: LD_VAR 0 14
134831: PUSH
134832: LD_VAR 0 8
134836: ARRAY
134837: PPUSH
134838: CALL_OW 256
134842: PUSH
134843: LD_INT 250
134845: LESS
134846: PUSH
134847: LD_VAR 0 20
134851: AND
134852: PUSH
134853: LD_VAR 0 20
134857: NOT
134858: PUSH
134859: LD_VAR 0 14
134863: PUSH
134864: LD_VAR 0 8
134868: ARRAY
134869: PPUSH
134870: CALL_OW 256
134874: PUSH
134875: LD_INT 250
134877: GREATEREQUAL
134878: AND
134879: OR
134880: AND
134881: IFFALSE 134901
// begin x := tmp [ j ] ;
134883: LD_ADDR_VAR 0 10
134887: PUSH
134888: LD_VAR 0 14
134892: PUSH
134893: LD_VAR 0 8
134897: ARRAY
134898: ST_TO_ADDR
// break ;
134899: GO 134903
// end ;
134901: GO 134804
134903: POP
134904: POP
// if x then
134905: LD_VAR 0 10
134909: IFFALSE 134933
// ComAttackUnit ( group [ i ] , x ) else
134911: LD_VAR 0 4
134915: PUSH
134916: LD_VAR 0 7
134920: ARRAY
134921: PPUSH
134922: LD_VAR 0 10
134926: PPUSH
134927: CALL_OW 115
134931: GO 134957
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
134933: LD_VAR 0 4
134937: PUSH
134938: LD_VAR 0 7
134942: ARRAY
134943: PPUSH
134944: LD_VAR 0 14
134948: PUSH
134949: LD_INT 1
134951: ARRAY
134952: PPUSH
134953: CALL_OW 115
// if not HasTask ( group [ i ] ) then
134957: LD_VAR 0 4
134961: PUSH
134962: LD_VAR 0 7
134966: ARRAY
134967: PPUSH
134968: CALL_OW 314
134972: NOT
134973: IFFALSE 135011
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
134975: LD_VAR 0 4
134979: PUSH
134980: LD_VAR 0 7
134984: ARRAY
134985: PPUSH
134986: LD_VAR 0 14
134990: PPUSH
134991: LD_VAR 0 4
134995: PUSH
134996: LD_VAR 0 7
135000: ARRAY
135001: PPUSH
135002: CALL_OW 74
135006: PPUSH
135007: CALL_OW 115
// end ; end ; end ;
135011: GO 130890
135013: POP
135014: POP
// wait ( 0 0$2 ) ;
135015: LD_INT 70
135017: PPUSH
135018: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
135022: LD_VAR 0 4
135026: NOT
135027: PUSH
135028: LD_VAR 0 4
135032: PUSH
135033: EMPTY
135034: EQUAL
135035: OR
135036: PUSH
135037: LD_INT 81
135039: PUSH
135040: LD_VAR 0 35
135044: PUSH
135045: EMPTY
135046: LIST
135047: LIST
135048: PPUSH
135049: CALL_OW 69
135053: NOT
135054: OR
135055: IFFALSE 130875
// end ;
135057: LD_VAR 0 2
135061: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
135062: LD_INT 0
135064: PPUSH
135065: PPUSH
135066: PPUSH
135067: PPUSH
135068: PPUSH
135069: PPUSH
// if not base or not mc_bases [ base ] or not solds then
135070: LD_VAR 0 1
135074: NOT
135075: PUSH
135076: LD_EXP 100
135080: PUSH
135081: LD_VAR 0 1
135085: ARRAY
135086: NOT
135087: OR
135088: PUSH
135089: LD_VAR 0 2
135093: NOT
135094: OR
135095: IFFALSE 135099
// exit ;
135097: GO 135653
// side := mc_sides [ base ] ;
135099: LD_ADDR_VAR 0 6
135103: PUSH
135104: LD_EXP 126
135108: PUSH
135109: LD_VAR 0 1
135113: ARRAY
135114: ST_TO_ADDR
// if not side then
135115: LD_VAR 0 6
135119: NOT
135120: IFFALSE 135124
// exit ;
135122: GO 135653
// for i in solds do
135124: LD_ADDR_VAR 0 7
135128: PUSH
135129: LD_VAR 0 2
135133: PUSH
135134: FOR_IN
135135: IFFALSE 135196
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
135137: LD_VAR 0 7
135141: PPUSH
135142: CALL_OW 310
135146: PPUSH
135147: CALL_OW 266
135151: PUSH
135152: LD_INT 32
135154: PUSH
135155: LD_INT 31
135157: PUSH
135158: EMPTY
135159: LIST
135160: LIST
135161: IN
135162: IFFALSE 135182
// solds := solds diff i else
135164: LD_ADDR_VAR 0 2
135168: PUSH
135169: LD_VAR 0 2
135173: PUSH
135174: LD_VAR 0 7
135178: DIFF
135179: ST_TO_ADDR
135180: GO 135194
// SetTag ( i , 18 ) ;
135182: LD_VAR 0 7
135186: PPUSH
135187: LD_INT 18
135189: PPUSH
135190: CALL_OW 109
135194: GO 135134
135196: POP
135197: POP
// if not solds then
135198: LD_VAR 0 2
135202: NOT
135203: IFFALSE 135207
// exit ;
135205: GO 135653
// repeat wait ( 0 0$2 ) ;
135207: LD_INT 70
135209: PPUSH
135210: CALL_OW 67
// enemy := mc_scan [ base ] ;
135214: LD_ADDR_VAR 0 4
135218: PUSH
135219: LD_EXP 123
135223: PUSH
135224: LD_VAR 0 1
135228: ARRAY
135229: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
135230: LD_EXP 100
135234: PUSH
135235: LD_VAR 0 1
135239: ARRAY
135240: NOT
135241: PUSH
135242: LD_EXP 100
135246: PUSH
135247: LD_VAR 0 1
135251: ARRAY
135252: PUSH
135253: EMPTY
135254: EQUAL
135255: OR
135256: IFFALSE 135293
// begin for i in solds do
135258: LD_ADDR_VAR 0 7
135262: PUSH
135263: LD_VAR 0 2
135267: PUSH
135268: FOR_IN
135269: IFFALSE 135282
// ComStop ( i ) ;
135271: LD_VAR 0 7
135275: PPUSH
135276: CALL_OW 141
135280: GO 135268
135282: POP
135283: POP
// solds := [ ] ;
135284: LD_ADDR_VAR 0 2
135288: PUSH
135289: EMPTY
135290: ST_TO_ADDR
// exit ;
135291: GO 135653
// end ; for i in solds do
135293: LD_ADDR_VAR 0 7
135297: PUSH
135298: LD_VAR 0 2
135302: PUSH
135303: FOR_IN
135304: IFFALSE 135625
// begin if IsInUnit ( i ) then
135306: LD_VAR 0 7
135310: PPUSH
135311: CALL_OW 310
135315: IFFALSE 135326
// ComExitBuilding ( i ) ;
135317: LD_VAR 0 7
135321: PPUSH
135322: CALL_OW 122
// if GetLives ( i ) > 500 then
135326: LD_VAR 0 7
135330: PPUSH
135331: CALL_OW 256
135335: PUSH
135336: LD_INT 500
135338: GREATER
135339: IFFALSE 135392
// begin e := NearestUnitToUnit ( enemy , i ) ;
135341: LD_ADDR_VAR 0 5
135345: PUSH
135346: LD_VAR 0 4
135350: PPUSH
135351: LD_VAR 0 7
135355: PPUSH
135356: CALL_OW 74
135360: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
135361: LD_VAR 0 7
135365: PPUSH
135366: LD_VAR 0 5
135370: PPUSH
135371: CALL_OW 250
135375: PPUSH
135376: LD_VAR 0 5
135380: PPUSH
135381: CALL_OW 251
135385: PPUSH
135386: CALL_OW 114
// end else
135390: GO 135623
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
135392: LD_VAR 0 7
135396: PPUSH
135397: LD_EXP 100
135401: PUSH
135402: LD_VAR 0 1
135406: ARRAY
135407: PPUSH
135408: LD_INT 2
135410: PUSH
135411: LD_INT 30
135413: PUSH
135414: LD_INT 0
135416: PUSH
135417: EMPTY
135418: LIST
135419: LIST
135420: PUSH
135421: LD_INT 30
135423: PUSH
135424: LD_INT 1
135426: PUSH
135427: EMPTY
135428: LIST
135429: LIST
135430: PUSH
135431: LD_INT 30
135433: PUSH
135434: LD_INT 6
135436: PUSH
135437: EMPTY
135438: LIST
135439: LIST
135440: PUSH
135441: EMPTY
135442: LIST
135443: LIST
135444: LIST
135445: LIST
135446: PPUSH
135447: CALL_OW 72
135451: PPUSH
135452: LD_VAR 0 7
135456: PPUSH
135457: CALL_OW 74
135461: PPUSH
135462: CALL_OW 296
135466: PUSH
135467: LD_INT 10
135469: GREATER
135470: IFFALSE 135623
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
135472: LD_ADDR_VAR 0 8
135476: PUSH
135477: LD_EXP 100
135481: PUSH
135482: LD_VAR 0 1
135486: ARRAY
135487: PPUSH
135488: LD_INT 2
135490: PUSH
135491: LD_INT 30
135493: PUSH
135494: LD_INT 0
135496: PUSH
135497: EMPTY
135498: LIST
135499: LIST
135500: PUSH
135501: LD_INT 30
135503: PUSH
135504: LD_INT 1
135506: PUSH
135507: EMPTY
135508: LIST
135509: LIST
135510: PUSH
135511: LD_INT 30
135513: PUSH
135514: LD_INT 6
135516: PUSH
135517: EMPTY
135518: LIST
135519: LIST
135520: PUSH
135521: EMPTY
135522: LIST
135523: LIST
135524: LIST
135525: LIST
135526: PPUSH
135527: CALL_OW 72
135531: PPUSH
135532: LD_VAR 0 7
135536: PPUSH
135537: CALL_OW 74
135541: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
135542: LD_VAR 0 7
135546: PPUSH
135547: LD_VAR 0 8
135551: PPUSH
135552: CALL_OW 250
135556: PPUSH
135557: LD_INT 3
135559: PPUSH
135560: LD_INT 5
135562: PPUSH
135563: CALL_OW 272
135567: PPUSH
135568: LD_VAR 0 8
135572: PPUSH
135573: CALL_OW 251
135577: PPUSH
135578: LD_INT 3
135580: PPUSH
135581: LD_INT 5
135583: PPUSH
135584: CALL_OW 273
135588: PPUSH
135589: CALL_OW 111
// SetTag ( i , 0 ) ;
135593: LD_VAR 0 7
135597: PPUSH
135598: LD_INT 0
135600: PPUSH
135601: CALL_OW 109
// solds := solds diff i ;
135605: LD_ADDR_VAR 0 2
135609: PUSH
135610: LD_VAR 0 2
135614: PUSH
135615: LD_VAR 0 7
135619: DIFF
135620: ST_TO_ADDR
// continue ;
135621: GO 135303
// end ; end ;
135623: GO 135303
135625: POP
135626: POP
// until not solds or not enemy ;
135627: LD_VAR 0 2
135631: NOT
135632: PUSH
135633: LD_VAR 0 4
135637: NOT
135638: OR
135639: IFFALSE 135207
// MC_Reset ( base , 18 ) ;
135641: LD_VAR 0 1
135645: PPUSH
135646: LD_INT 18
135648: PPUSH
135649: CALL 42373 0 2
// end ;
135653: LD_VAR 0 3
135657: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
135658: LD_INT 0
135660: PPUSH
135661: PPUSH
135662: PPUSH
135663: PPUSH
135664: PPUSH
135665: PPUSH
135666: PPUSH
135667: PPUSH
135668: PPUSH
135669: PPUSH
135670: PPUSH
135671: PPUSH
135672: PPUSH
135673: PPUSH
135674: PPUSH
135675: PPUSH
135676: PPUSH
135677: PPUSH
135678: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
135679: LD_ADDR_VAR 0 12
135683: PUSH
135684: LD_EXP 100
135688: PUSH
135689: LD_VAR 0 1
135693: ARRAY
135694: PPUSH
135695: LD_INT 25
135697: PUSH
135698: LD_INT 3
135700: PUSH
135701: EMPTY
135702: LIST
135703: LIST
135704: PPUSH
135705: CALL_OW 72
135709: ST_TO_ADDR
// if mc_remote_driver [ base ] then
135710: LD_EXP 140
135714: PUSH
135715: LD_VAR 0 1
135719: ARRAY
135720: IFFALSE 135744
// mechs := mechs diff mc_remote_driver [ base ] ;
135722: LD_ADDR_VAR 0 12
135726: PUSH
135727: LD_VAR 0 12
135731: PUSH
135732: LD_EXP 140
135736: PUSH
135737: LD_VAR 0 1
135741: ARRAY
135742: DIFF
135743: ST_TO_ADDR
// for i in mechs do
135744: LD_ADDR_VAR 0 4
135748: PUSH
135749: LD_VAR 0 12
135753: PUSH
135754: FOR_IN
135755: IFFALSE 135790
// if GetTag ( i ) > 0 then
135757: LD_VAR 0 4
135761: PPUSH
135762: CALL_OW 110
135766: PUSH
135767: LD_INT 0
135769: GREATER
135770: IFFALSE 135788
// mechs := mechs diff i ;
135772: LD_ADDR_VAR 0 12
135776: PUSH
135777: LD_VAR 0 12
135781: PUSH
135782: LD_VAR 0 4
135786: DIFF
135787: ST_TO_ADDR
135788: GO 135754
135790: POP
135791: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
135792: LD_ADDR_VAR 0 8
135796: PUSH
135797: LD_EXP 100
135801: PUSH
135802: LD_VAR 0 1
135806: ARRAY
135807: PPUSH
135808: LD_INT 2
135810: PUSH
135811: LD_INT 25
135813: PUSH
135814: LD_INT 1
135816: PUSH
135817: EMPTY
135818: LIST
135819: LIST
135820: PUSH
135821: LD_INT 25
135823: PUSH
135824: LD_INT 5
135826: PUSH
135827: EMPTY
135828: LIST
135829: LIST
135830: PUSH
135831: LD_INT 25
135833: PUSH
135834: LD_INT 8
135836: PUSH
135837: EMPTY
135838: LIST
135839: LIST
135840: PUSH
135841: LD_INT 25
135843: PUSH
135844: LD_INT 9
135846: PUSH
135847: EMPTY
135848: LIST
135849: LIST
135850: PUSH
135851: EMPTY
135852: LIST
135853: LIST
135854: LIST
135855: LIST
135856: LIST
135857: PPUSH
135858: CALL_OW 72
135862: ST_TO_ADDR
// if not defenders and not solds then
135863: LD_VAR 0 2
135867: NOT
135868: PUSH
135869: LD_VAR 0 8
135873: NOT
135874: AND
135875: IFFALSE 135879
// exit ;
135877: GO 137649
// depot_under_attack := false ;
135879: LD_ADDR_VAR 0 16
135883: PUSH
135884: LD_INT 0
135886: ST_TO_ADDR
// sold_defenders := [ ] ;
135887: LD_ADDR_VAR 0 17
135891: PUSH
135892: EMPTY
135893: ST_TO_ADDR
// if mechs then
135894: LD_VAR 0 12
135898: IFFALSE 136051
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
135900: LD_ADDR_VAR 0 4
135904: PUSH
135905: LD_VAR 0 2
135909: PPUSH
135910: LD_INT 21
135912: PUSH
135913: LD_INT 2
135915: PUSH
135916: EMPTY
135917: LIST
135918: LIST
135919: PPUSH
135920: CALL_OW 72
135924: PUSH
135925: FOR_IN
135926: IFFALSE 136049
// begin if GetTag ( i ) <> 20 then
135928: LD_VAR 0 4
135932: PPUSH
135933: CALL_OW 110
135937: PUSH
135938: LD_INT 20
135940: NONEQUAL
135941: IFFALSE 135955
// SetTag ( i , 20 ) ;
135943: LD_VAR 0 4
135947: PPUSH
135948: LD_INT 20
135950: PPUSH
135951: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
135955: LD_VAR 0 4
135959: PPUSH
135960: CALL_OW 263
135964: PUSH
135965: LD_INT 1
135967: EQUAL
135968: PUSH
135969: LD_VAR 0 4
135973: PPUSH
135974: CALL_OW 311
135978: NOT
135979: AND
135980: IFFALSE 136047
// begin un := mechs [ 1 ] ;
135982: LD_ADDR_VAR 0 10
135986: PUSH
135987: LD_VAR 0 12
135991: PUSH
135992: LD_INT 1
135994: ARRAY
135995: ST_TO_ADDR
// ComExit ( un ) ;
135996: LD_VAR 0 10
136000: PPUSH
136001: CALL 106588 0 1
// AddComEnterUnit ( un , i ) ;
136005: LD_VAR 0 10
136009: PPUSH
136010: LD_VAR 0 4
136014: PPUSH
136015: CALL_OW 180
// SetTag ( un , 19 ) ;
136019: LD_VAR 0 10
136023: PPUSH
136024: LD_INT 19
136026: PPUSH
136027: CALL_OW 109
// mechs := mechs diff un ;
136031: LD_ADDR_VAR 0 12
136035: PUSH
136036: LD_VAR 0 12
136040: PUSH
136041: LD_VAR 0 10
136045: DIFF
136046: ST_TO_ADDR
// end ; end ;
136047: GO 135925
136049: POP
136050: POP
// if solds then
136051: LD_VAR 0 8
136055: IFFALSE 136114
// for i in solds do
136057: LD_ADDR_VAR 0 4
136061: PUSH
136062: LD_VAR 0 8
136066: PUSH
136067: FOR_IN
136068: IFFALSE 136112
// if not GetTag ( i ) then
136070: LD_VAR 0 4
136074: PPUSH
136075: CALL_OW 110
136079: NOT
136080: IFFALSE 136110
// begin defenders := defenders union i ;
136082: LD_ADDR_VAR 0 2
136086: PUSH
136087: LD_VAR 0 2
136091: PUSH
136092: LD_VAR 0 4
136096: UNION
136097: ST_TO_ADDR
// SetTag ( i , 18 ) ;
136098: LD_VAR 0 4
136102: PPUSH
136103: LD_INT 18
136105: PPUSH
136106: CALL_OW 109
// end ;
136110: GO 136067
136112: POP
136113: POP
// repeat wait ( 0 0$2 ) ;
136114: LD_INT 70
136116: PPUSH
136117: CALL_OW 67
// enemy := mc_scan [ base ] ;
136121: LD_ADDR_VAR 0 21
136125: PUSH
136126: LD_EXP 123
136130: PUSH
136131: LD_VAR 0 1
136135: ARRAY
136136: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
136137: LD_EXP 100
136141: PUSH
136142: LD_VAR 0 1
136146: ARRAY
136147: NOT
136148: PUSH
136149: LD_EXP 100
136153: PUSH
136154: LD_VAR 0 1
136158: ARRAY
136159: PUSH
136160: EMPTY
136161: EQUAL
136162: OR
136163: IFFALSE 136200
// begin for i in defenders do
136165: LD_ADDR_VAR 0 4
136169: PUSH
136170: LD_VAR 0 2
136174: PUSH
136175: FOR_IN
136176: IFFALSE 136189
// ComStop ( i ) ;
136178: LD_VAR 0 4
136182: PPUSH
136183: CALL_OW 141
136187: GO 136175
136189: POP
136190: POP
// defenders := [ ] ;
136191: LD_ADDR_VAR 0 2
136195: PUSH
136196: EMPTY
136197: ST_TO_ADDR
// exit ;
136198: GO 137649
// end ; for i in defenders do
136200: LD_ADDR_VAR 0 4
136204: PUSH
136205: LD_VAR 0 2
136209: PUSH
136210: FOR_IN
136211: IFFALSE 137109
// begin e := NearestUnitToUnit ( enemy , i ) ;
136213: LD_ADDR_VAR 0 13
136217: PUSH
136218: LD_VAR 0 21
136222: PPUSH
136223: LD_VAR 0 4
136227: PPUSH
136228: CALL_OW 74
136232: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
136233: LD_ADDR_VAR 0 7
136237: PUSH
136238: LD_EXP 100
136242: PUSH
136243: LD_VAR 0 1
136247: ARRAY
136248: PPUSH
136249: LD_INT 2
136251: PUSH
136252: LD_INT 30
136254: PUSH
136255: LD_INT 0
136257: PUSH
136258: EMPTY
136259: LIST
136260: LIST
136261: PUSH
136262: LD_INT 30
136264: PUSH
136265: LD_INT 1
136267: PUSH
136268: EMPTY
136269: LIST
136270: LIST
136271: PUSH
136272: EMPTY
136273: LIST
136274: LIST
136275: LIST
136276: PPUSH
136277: CALL_OW 72
136281: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
136282: LD_ADDR_VAR 0 16
136286: PUSH
136287: LD_VAR 0 7
136291: NOT
136292: PUSH
136293: LD_VAR 0 7
136297: PPUSH
136298: LD_INT 3
136300: PUSH
136301: LD_INT 24
136303: PUSH
136304: LD_INT 600
136306: PUSH
136307: EMPTY
136308: LIST
136309: LIST
136310: PUSH
136311: EMPTY
136312: LIST
136313: LIST
136314: PPUSH
136315: CALL_OW 72
136319: OR
136320: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
136321: LD_VAR 0 4
136325: PPUSH
136326: CALL_OW 247
136330: PUSH
136331: LD_INT 2
136333: DOUBLE
136334: EQUAL
136335: IFTRUE 136339
136337: GO 136735
136339: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
136340: LD_VAR 0 4
136344: PPUSH
136345: CALL_OW 256
136349: PUSH
136350: LD_INT 1000
136352: EQUAL
136353: PUSH
136354: LD_VAR 0 4
136358: PPUSH
136359: LD_VAR 0 13
136363: PPUSH
136364: CALL_OW 296
136368: PUSH
136369: LD_INT 40
136371: LESS
136372: PUSH
136373: LD_VAR 0 13
136377: PPUSH
136378: LD_EXP 125
136382: PUSH
136383: LD_VAR 0 1
136387: ARRAY
136388: PPUSH
136389: CALL_OW 308
136393: OR
136394: AND
136395: IFFALSE 136517
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
136397: LD_VAR 0 4
136401: PPUSH
136402: CALL_OW 262
136406: PUSH
136407: LD_INT 1
136409: EQUAL
136410: PUSH
136411: LD_VAR 0 4
136415: PPUSH
136416: CALL_OW 261
136420: PUSH
136421: LD_INT 30
136423: LESS
136424: AND
136425: PUSH
136426: LD_VAR 0 7
136430: AND
136431: IFFALSE 136501
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
136433: LD_VAR 0 4
136437: PPUSH
136438: LD_VAR 0 7
136442: PPUSH
136443: LD_VAR 0 4
136447: PPUSH
136448: CALL_OW 74
136452: PPUSH
136453: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
136457: LD_VAR 0 4
136461: PPUSH
136462: LD_VAR 0 7
136466: PPUSH
136467: LD_VAR 0 4
136471: PPUSH
136472: CALL_OW 74
136476: PPUSH
136477: CALL_OW 296
136481: PUSH
136482: LD_INT 6
136484: LESS
136485: IFFALSE 136499
// SetFuel ( i , 100 ) ;
136487: LD_VAR 0 4
136491: PPUSH
136492: LD_INT 100
136494: PPUSH
136495: CALL_OW 240
// end else
136499: GO 136515
// ComAttackUnit ( i , e ) ;
136501: LD_VAR 0 4
136505: PPUSH
136506: LD_VAR 0 13
136510: PPUSH
136511: CALL_OW 115
// end else
136515: GO 136618
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
136517: LD_VAR 0 13
136521: PPUSH
136522: LD_EXP 125
136526: PUSH
136527: LD_VAR 0 1
136531: ARRAY
136532: PPUSH
136533: CALL_OW 308
136537: NOT
136538: PUSH
136539: LD_VAR 0 4
136543: PPUSH
136544: LD_VAR 0 13
136548: PPUSH
136549: CALL_OW 296
136553: PUSH
136554: LD_INT 40
136556: GREATEREQUAL
136557: AND
136558: PUSH
136559: LD_VAR 0 4
136563: PPUSH
136564: CALL_OW 256
136568: PUSH
136569: LD_INT 650
136571: LESSEQUAL
136572: OR
136573: PUSH
136574: LD_VAR 0 4
136578: PPUSH
136579: LD_EXP 124
136583: PUSH
136584: LD_VAR 0 1
136588: ARRAY
136589: PPUSH
136590: CALL_OW 308
136594: NOT
136595: AND
136596: IFFALSE 136618
// ComMoveToArea ( i , mc_parking [ base ] ) ;
136598: LD_VAR 0 4
136602: PPUSH
136603: LD_EXP 124
136607: PUSH
136608: LD_VAR 0 1
136612: ARRAY
136613: PPUSH
136614: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
136618: LD_VAR 0 4
136622: PPUSH
136623: CALL_OW 256
136627: PUSH
136628: LD_INT 1000
136630: LESS
136631: PUSH
136632: LD_VAR 0 4
136636: PPUSH
136637: CALL_OW 263
136641: PUSH
136642: LD_INT 1
136644: EQUAL
136645: AND
136646: PUSH
136647: LD_VAR 0 4
136651: PPUSH
136652: CALL_OW 311
136656: AND
136657: PUSH
136658: LD_VAR 0 4
136662: PPUSH
136663: LD_EXP 124
136667: PUSH
136668: LD_VAR 0 1
136672: ARRAY
136673: PPUSH
136674: CALL_OW 308
136678: AND
136679: IFFALSE 136733
// begin mech := IsDrivenBy ( i ) ;
136681: LD_ADDR_VAR 0 9
136685: PUSH
136686: LD_VAR 0 4
136690: PPUSH
136691: CALL_OW 311
136695: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
136696: LD_VAR 0 9
136700: PPUSH
136701: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
136705: LD_VAR 0 9
136709: PPUSH
136710: LD_VAR 0 4
136714: PPUSH
136715: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
136719: LD_VAR 0 9
136723: PPUSH
136724: LD_VAR 0 4
136728: PPUSH
136729: CALL_OW 180
// end ; end ; unit_human :
136733: GO 137080
136735: LD_INT 1
136737: DOUBLE
136738: EQUAL
136739: IFTRUE 136743
136741: GO 137079
136743: POP
// begin b := IsInUnit ( i ) ;
136744: LD_ADDR_VAR 0 18
136748: PUSH
136749: LD_VAR 0 4
136753: PPUSH
136754: CALL_OW 310
136758: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
136759: LD_ADDR_VAR 0 19
136763: PUSH
136764: LD_VAR 0 18
136768: NOT
136769: PUSH
136770: LD_VAR 0 18
136774: PPUSH
136775: CALL_OW 266
136779: PUSH
136780: LD_INT 32
136782: PUSH
136783: LD_INT 31
136785: PUSH
136786: EMPTY
136787: LIST
136788: LIST
136789: IN
136790: OR
136791: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
136792: LD_VAR 0 18
136796: PPUSH
136797: CALL_OW 266
136801: PUSH
136802: LD_INT 5
136804: EQUAL
136805: PUSH
136806: LD_VAR 0 4
136810: PPUSH
136811: CALL_OW 257
136815: PUSH
136816: LD_INT 1
136818: PUSH
136819: LD_INT 2
136821: PUSH
136822: LD_INT 3
136824: PUSH
136825: LD_INT 4
136827: PUSH
136828: EMPTY
136829: LIST
136830: LIST
136831: LIST
136832: LIST
136833: IN
136834: AND
136835: IFFALSE 136872
// begin class := AllowSpecClass ( i ) ;
136837: LD_ADDR_VAR 0 20
136841: PUSH
136842: LD_VAR 0 4
136846: PPUSH
136847: CALL 70684 0 1
136851: ST_TO_ADDR
// if class then
136852: LD_VAR 0 20
136856: IFFALSE 136872
// ComChangeProfession ( i , class ) ;
136858: LD_VAR 0 4
136862: PPUSH
136863: LD_VAR 0 20
136867: PPUSH
136868: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
136872: LD_VAR 0 16
136876: PUSH
136877: LD_VAR 0 2
136881: PPUSH
136882: LD_INT 21
136884: PUSH
136885: LD_INT 2
136887: PUSH
136888: EMPTY
136889: LIST
136890: LIST
136891: PPUSH
136892: CALL_OW 72
136896: PUSH
136897: LD_INT 1
136899: LESSEQUAL
136900: OR
136901: PUSH
136902: LD_VAR 0 19
136906: AND
136907: PUSH
136908: LD_VAR 0 4
136912: PUSH
136913: LD_VAR 0 17
136917: IN
136918: NOT
136919: AND
136920: IFFALSE 137013
// begin if b then
136922: LD_VAR 0 18
136926: IFFALSE 136975
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
136928: LD_VAR 0 18
136932: PPUSH
136933: LD_VAR 0 21
136937: PPUSH
136938: LD_VAR 0 18
136942: PPUSH
136943: CALL_OW 74
136947: PPUSH
136948: CALL_OW 296
136952: PUSH
136953: LD_INT 10
136955: LESS
136956: PUSH
136957: LD_VAR 0 18
136961: PPUSH
136962: CALL_OW 461
136966: PUSH
136967: LD_INT 7
136969: NONEQUAL
136970: AND
136971: IFFALSE 136975
// continue ;
136973: GO 136210
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
136975: LD_ADDR_VAR 0 17
136979: PUSH
136980: LD_VAR 0 17
136984: PPUSH
136985: LD_VAR 0 17
136989: PUSH
136990: LD_INT 1
136992: PLUS
136993: PPUSH
136994: LD_VAR 0 4
136998: PPUSH
136999: CALL_OW 1
137003: ST_TO_ADDR
// ComExitBuilding ( i ) ;
137004: LD_VAR 0 4
137008: PPUSH
137009: CALL_OW 122
// end ; if sold_defenders then
137013: LD_VAR 0 17
137017: IFFALSE 137077
// if i in sold_defenders then
137019: LD_VAR 0 4
137023: PUSH
137024: LD_VAR 0 17
137028: IN
137029: IFFALSE 137077
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
137031: LD_VAR 0 4
137035: PPUSH
137036: CALL_OW 314
137040: NOT
137041: PUSH
137042: LD_VAR 0 4
137046: PPUSH
137047: LD_VAR 0 13
137051: PPUSH
137052: CALL_OW 296
137056: PUSH
137057: LD_INT 30
137059: LESS
137060: AND
137061: IFFALSE 137077
// ComAttackUnit ( i , e ) ;
137063: LD_VAR 0 4
137067: PPUSH
137068: LD_VAR 0 13
137072: PPUSH
137073: CALL_OW 115
// end ; end ; end ;
137077: GO 137080
137079: POP
// if IsDead ( i ) then
137080: LD_VAR 0 4
137084: PPUSH
137085: CALL_OW 301
137089: IFFALSE 137107
// defenders := defenders diff i ;
137091: LD_ADDR_VAR 0 2
137095: PUSH
137096: LD_VAR 0 2
137100: PUSH
137101: LD_VAR 0 4
137105: DIFF
137106: ST_TO_ADDR
// end ;
137107: GO 136210
137109: POP
137110: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
137111: LD_VAR 0 21
137115: NOT
137116: PUSH
137117: LD_VAR 0 2
137121: NOT
137122: OR
137123: PUSH
137124: LD_EXP 100
137128: PUSH
137129: LD_VAR 0 1
137133: ARRAY
137134: NOT
137135: OR
137136: IFFALSE 136114
// MC_Reset ( base , 18 ) ;
137138: LD_VAR 0 1
137142: PPUSH
137143: LD_INT 18
137145: PPUSH
137146: CALL 42373 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
137150: LD_ADDR_VAR 0 2
137154: PUSH
137155: LD_VAR 0 2
137159: PUSH
137160: LD_VAR 0 2
137164: PPUSH
137165: LD_INT 2
137167: PUSH
137168: LD_INT 25
137170: PUSH
137171: LD_INT 1
137173: PUSH
137174: EMPTY
137175: LIST
137176: LIST
137177: PUSH
137178: LD_INT 25
137180: PUSH
137181: LD_INT 5
137183: PUSH
137184: EMPTY
137185: LIST
137186: LIST
137187: PUSH
137188: LD_INT 25
137190: PUSH
137191: LD_INT 8
137193: PUSH
137194: EMPTY
137195: LIST
137196: LIST
137197: PUSH
137198: LD_INT 25
137200: PUSH
137201: LD_INT 9
137203: PUSH
137204: EMPTY
137205: LIST
137206: LIST
137207: PUSH
137208: EMPTY
137209: LIST
137210: LIST
137211: LIST
137212: LIST
137213: LIST
137214: PPUSH
137215: CALL_OW 72
137219: DIFF
137220: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
137221: LD_VAR 0 21
137225: NOT
137226: PUSH
137227: LD_VAR 0 2
137231: PPUSH
137232: LD_INT 21
137234: PUSH
137235: LD_INT 2
137237: PUSH
137238: EMPTY
137239: LIST
137240: LIST
137241: PPUSH
137242: CALL_OW 72
137246: AND
137247: IFFALSE 137585
// begin tmp := FilterByTag ( defenders , 19 ) ;
137249: LD_ADDR_VAR 0 11
137253: PUSH
137254: LD_VAR 0 2
137258: PPUSH
137259: LD_INT 19
137261: PPUSH
137262: CALL 103772 0 2
137266: ST_TO_ADDR
// if tmp then
137267: LD_VAR 0 11
137271: IFFALSE 137341
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
137273: LD_ADDR_VAR 0 11
137277: PUSH
137278: LD_VAR 0 11
137282: PPUSH
137283: LD_INT 25
137285: PUSH
137286: LD_INT 3
137288: PUSH
137289: EMPTY
137290: LIST
137291: LIST
137292: PPUSH
137293: CALL_OW 72
137297: ST_TO_ADDR
// if tmp then
137298: LD_VAR 0 11
137302: IFFALSE 137341
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
137304: LD_ADDR_EXP 112
137308: PUSH
137309: LD_EXP 112
137313: PPUSH
137314: LD_VAR 0 1
137318: PPUSH
137319: LD_EXP 112
137323: PUSH
137324: LD_VAR 0 1
137328: ARRAY
137329: PUSH
137330: LD_VAR 0 11
137334: UNION
137335: PPUSH
137336: CALL_OW 1
137340: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
137341: LD_VAR 0 1
137345: PPUSH
137346: LD_INT 19
137348: PPUSH
137349: CALL 42373 0 2
// repeat wait ( 0 0$1 ) ;
137353: LD_INT 35
137355: PPUSH
137356: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
137360: LD_EXP 100
137364: PUSH
137365: LD_VAR 0 1
137369: ARRAY
137370: NOT
137371: PUSH
137372: LD_EXP 100
137376: PUSH
137377: LD_VAR 0 1
137381: ARRAY
137382: PUSH
137383: EMPTY
137384: EQUAL
137385: OR
137386: IFFALSE 137423
// begin for i in defenders do
137388: LD_ADDR_VAR 0 4
137392: PUSH
137393: LD_VAR 0 2
137397: PUSH
137398: FOR_IN
137399: IFFALSE 137412
// ComStop ( i ) ;
137401: LD_VAR 0 4
137405: PPUSH
137406: CALL_OW 141
137410: GO 137398
137412: POP
137413: POP
// defenders := [ ] ;
137414: LD_ADDR_VAR 0 2
137418: PUSH
137419: EMPTY
137420: ST_TO_ADDR
// exit ;
137421: GO 137649
// end ; for i in defenders do
137423: LD_ADDR_VAR 0 4
137427: PUSH
137428: LD_VAR 0 2
137432: PUSH
137433: FOR_IN
137434: IFFALSE 137523
// begin if not IsInArea ( i , mc_parking [ base ] ) then
137436: LD_VAR 0 4
137440: PPUSH
137441: LD_EXP 124
137445: PUSH
137446: LD_VAR 0 1
137450: ARRAY
137451: PPUSH
137452: CALL_OW 308
137456: NOT
137457: IFFALSE 137481
// ComMoveToArea ( i , mc_parking [ base ] ) else
137459: LD_VAR 0 4
137463: PPUSH
137464: LD_EXP 124
137468: PUSH
137469: LD_VAR 0 1
137473: ARRAY
137474: PPUSH
137475: CALL_OW 113
137479: GO 137521
// if GetControl ( i ) = control_manual then
137481: LD_VAR 0 4
137485: PPUSH
137486: CALL_OW 263
137490: PUSH
137491: LD_INT 1
137493: EQUAL
137494: IFFALSE 137521
// if IsDrivenBy ( i ) then
137496: LD_VAR 0 4
137500: PPUSH
137501: CALL_OW 311
137505: IFFALSE 137521
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
137507: LD_VAR 0 4
137511: PPUSH
137512: CALL_OW 311
137516: PPUSH
137517: CALL_OW 121
// end ;
137521: GO 137433
137523: POP
137524: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
137525: LD_VAR 0 2
137529: PPUSH
137530: LD_INT 95
137532: PUSH
137533: LD_EXP 124
137537: PUSH
137538: LD_VAR 0 1
137542: ARRAY
137543: PUSH
137544: EMPTY
137545: LIST
137546: LIST
137547: PPUSH
137548: CALL_OW 72
137552: PUSH
137553: LD_VAR 0 2
137557: EQUAL
137558: PUSH
137559: LD_EXP 123
137563: PUSH
137564: LD_VAR 0 1
137568: ARRAY
137569: OR
137570: PUSH
137571: LD_EXP 100
137575: PUSH
137576: LD_VAR 0 1
137580: ARRAY
137581: NOT
137582: OR
137583: IFFALSE 137353
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
137585: LD_ADDR_EXP 122
137589: PUSH
137590: LD_EXP 122
137594: PPUSH
137595: LD_VAR 0 1
137599: PPUSH
137600: LD_VAR 0 2
137604: PPUSH
137605: LD_INT 21
137607: PUSH
137608: LD_INT 2
137610: PUSH
137611: EMPTY
137612: LIST
137613: LIST
137614: PPUSH
137615: CALL_OW 72
137619: PPUSH
137620: CALL_OW 1
137624: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
137625: LD_VAR 0 1
137629: PPUSH
137630: LD_INT 19
137632: PPUSH
137633: CALL 42373 0 2
// MC_Reset ( base , 20 ) ;
137637: LD_VAR 0 1
137641: PPUSH
137642: LD_INT 20
137644: PPUSH
137645: CALL 42373 0 2
// end ; end_of_file
137649: LD_VAR 0 3
137653: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
137654: LD_VAR 0 1
137658: PUSH
137659: LD_INT 200
137661: DOUBLE
137662: GREATEREQUAL
137663: IFFALSE 137671
137665: LD_INT 299
137667: DOUBLE
137668: LESSEQUAL
137669: IFTRUE 137673
137671: GO 137705
137673: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
137674: LD_VAR 0 1
137678: PPUSH
137679: LD_VAR 0 2
137683: PPUSH
137684: LD_VAR 0 3
137688: PPUSH
137689: LD_VAR 0 4
137693: PPUSH
137694: LD_VAR 0 5
137698: PPUSH
137699: CALL 126440 0 5
137703: GO 137782
137705: LD_INT 300
137707: DOUBLE
137708: GREATEREQUAL
137709: IFFALSE 137717
137711: LD_INT 399
137713: DOUBLE
137714: LESSEQUAL
137715: IFTRUE 137719
137717: GO 137781
137719: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
137720: LD_VAR 0 1
137724: PPUSH
137725: LD_VAR 0 2
137729: PPUSH
137730: LD_VAR 0 3
137734: PPUSH
137735: LD_VAR 0 4
137739: PPUSH
137740: LD_VAR 0 5
137744: PPUSH
137745: LD_VAR 0 6
137749: PPUSH
137750: LD_VAR 0 7
137754: PPUSH
137755: LD_VAR 0 8
137759: PPUSH
137760: LD_VAR 0 9
137764: PPUSH
137765: LD_VAR 0 10
137769: PPUSH
137770: LD_VAR 0 11
137774: PPUSH
137775: CALL 122765 0 11
137779: GO 137782
137781: POP
// end ;
137782: PPOPN 11
137784: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
137785: LD_VAR 0 1
137789: PPUSH
137790: LD_VAR 0 2
137794: PPUSH
137795: LD_VAR 0 3
137799: PPUSH
137800: LD_VAR 0 4
137804: PPUSH
137805: LD_VAR 0 5
137809: PPUSH
137810: CALL 126176 0 5
// end ; end_of_file
137814: PPOPN 5
137816: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
137817: LD_VAR 0 1
137821: PPUSH
137822: LD_VAR 0 2
137826: PPUSH
137827: LD_VAR 0 3
137831: PPUSH
137832: LD_VAR 0 4
137836: PPUSH
137837: LD_VAR 0 5
137841: PPUSH
137842: LD_VAR 0 6
137846: PPUSH
137847: CALL 110417 0 6
// end ;
137851: PPOPN 6
137853: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
137854: LD_INT 0
137856: PPUSH
// begin if not units then
137857: LD_VAR 0 1
137861: NOT
137862: IFFALSE 137866
// exit ;
137864: GO 137866
// end ;
137866: PPOPN 7
137868: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
137869: CALL 110321 0 0
// end ;
137873: PPOPN 1
137875: END
