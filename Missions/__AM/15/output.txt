// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33701 0 0
// InitNature ;
  19: CALL 33525 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10792 0 0
// PrepareRussian ;
  40: CALL 6785 0 0
// PrepareLegion ;
  44: CALL 4025 0 0
// PreparePowell ;
  48: CALL 2779 0 0
// PrepareAmerican ;
  52: CALL 1602 0 0
// Action ;
  56: CALL 14699 0 0
// MC_Start ( ) ;
  60: CALL 35813 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 57553 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 57646 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57059 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 56874 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 57553 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 57646 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 24
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 47
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 24
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 47
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: EMPTY
 791: LIST
 792: LIST
 793: LIST
 794: LIST
 795: LIST
 796: LIST
 797: PPUSH
 798: CALL 56874 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 802: LD_INT 2
 804: PPUSH
 805: LD_INT 5
 807: PPUSH
 808: CALL 57059 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 812: LD_INT 2
 814: PPUSH
 815: LD_INT 0
 817: PPUSH
 818: CALL 57426 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 822: LD_INT 3
 824: PPUSH
 825: LD_INT 10
 827: PUSH
 828: LD_INT 12
 830: PUSH
 831: LD_INT 15
 833: PUSH
 834: EMPTY
 835: LIST
 836: LIST
 837: LIST
 838: PUSH
 839: LD_OWVAR 67
 843: ARRAY
 844: PPUSH
 845: LD_INT 27
 847: PPUSH
 848: CALL 56556 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 852: LD_INT 3
 854: PPUSH
 855: LD_INT 10
 857: PUSH
 858: LD_INT 11
 860: PUSH
 861: LD_INT 13
 863: PUSH
 864: LD_INT 15
 866: PUSH
 867: EMPTY
 868: LIST
 869: LIST
 870: LIST
 871: LIST
 872: PPUSH
 873: CALL 57553 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 877: LD_INT 3
 879: PPUSH
 880: LD_INT 15
 882: PUSH
 883: EMPTY
 884: LIST
 885: PPUSH
 886: CALL 57646 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 890: LD_ADDR_EXP 128
 894: PUSH
 895: LD_EXP 128
 899: PPUSH
 900: LD_INT 3
 902: PPUSH
 903: LD_INT 22
 905: PUSH
 906: LD_INT 8
 908: PUSH
 909: EMPTY
 910: LIST
 911: LIST
 912: PUSH
 913: LD_INT 25
 915: PUSH
 916: LD_INT 15
 918: PUSH
 919: EMPTY
 920: LIST
 921: LIST
 922: PUSH
 923: EMPTY
 924: LIST
 925: LIST
 926: PPUSH
 927: CALL_OW 69
 931: PPUSH
 932: CALL_OW 1
 936: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 937: LD_INT 3
 939: PPUSH
 940: LD_INT 13
 942: PUSH
 943: LD_INT 2
 945: PUSH
 946: LD_INT 1
 948: PUSH
 949: LD_INT 31
 951: PUSH
 952: EMPTY
 953: LIST
 954: LIST
 955: LIST
 956: LIST
 957: PUSH
 958: LD_INT 13
 960: PUSH
 961: LD_INT 2
 963: PUSH
 964: LD_INT 1
 966: PUSH
 967: LD_INT 31
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: LIST
 974: LIST
 975: PUSH
 976: LD_INT 13
 978: PUSH
 979: LD_INT 3
 981: PUSH
 982: LD_INT 2
 984: PUSH
 985: LD_INT 32
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: LIST
 992: LIST
 993: PUSH
 994: EMPTY
 995: LIST
 996: LIST
 997: LIST
 998: PPUSH
 999: CALL 56874 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1003: LD_INT 4
1005: PPUSH
1006: LD_INT 10
1008: PUSH
1009: LD_INT 12
1011: PUSH
1012: EMPTY
1013: LIST
1014: LIST
1015: PPUSH
1016: CALL 57553 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1020: LD_INT 4
1022: PPUSH
1023: LD_INT 9
1025: PUSH
1026: EMPTY
1027: LIST
1028: PPUSH
1029: CALL 57646 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1033: LD_INT 4
1035: PPUSH
1036: LD_INT 26
1038: PUSH
1039: LD_INT 74
1041: PUSH
1042: LD_INT 107
1044: PUSH
1045: LD_INT 0
1047: PUSH
1048: EMPTY
1049: LIST
1050: LIST
1051: LIST
1052: LIST
1053: PUSH
1054: LD_INT 32
1056: PUSH
1057: LD_INT 77
1059: PUSH
1060: LD_INT 101
1062: PUSH
1063: LD_INT 4
1065: PUSH
1066: EMPTY
1067: LIST
1068: LIST
1069: LIST
1070: LIST
1071: PUSH
1072: LD_INT 32
1074: PUSH
1075: LD_INT 69
1077: PUSH
1078: LD_INT 86
1080: PUSH
1081: LD_INT 4
1083: PUSH
1084: EMPTY
1085: LIST
1086: LIST
1087: LIST
1088: LIST
1089: PUSH
1090: LD_INT 27
1092: PUSH
1093: LD_INT 77
1095: PUSH
1096: LD_INT 110
1098: PUSH
1099: LD_INT 3
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: LIST
1106: LIST
1107: PUSH
1108: LD_INT 27
1110: PUSH
1111: LD_INT 42
1113: PUSH
1114: LD_INT 79
1116: PUSH
1117: LD_INT 5
1119: PUSH
1120: EMPTY
1121: LIST
1122: LIST
1123: LIST
1124: LIST
1125: PUSH
1126: LD_INT 29
1128: PUSH
1129: LD_INT 86
1131: PUSH
1132: LD_INT 105
1134: PUSH
1135: LD_INT 2
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 30
1146: PUSH
1147: LD_INT 40
1149: PUSH
1150: LD_INT 75
1152: PUSH
1153: LD_INT 1
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 32
1164: PUSH
1165: LD_INT 80
1167: PUSH
1168: LD_INT 106
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 32
1182: PUSH
1183: LD_INT 75
1185: PUSH
1186: LD_INT 114
1188: PUSH
1189: LD_INT 5
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 32
1200: PUSH
1201: LD_INT 82
1203: PUSH
1204: LD_INT 110
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 32
1218: PUSH
1219: LD_INT 62
1221: PUSH
1222: LD_INT 78
1224: PUSH
1225: LD_INT 4
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 4
1236: PUSH
1237: LD_INT 39
1239: PUSH
1240: LD_INT 61
1242: PUSH
1243: LD_INT 3
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: EMPTY
1253: LIST
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: LIST
1262: LIST
1263: LIST
1264: LIST
1265: PPUSH
1266: CALL 56766 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1270: LD_INT 4
1272: PPUSH
1273: LD_INT 5
1275: PUSH
1276: LD_INT 6
1278: PUSH
1279: LD_INT 7
1281: PUSH
1282: LD_INT 9
1284: PUSH
1285: EMPTY
1286: LIST
1287: LIST
1288: LIST
1289: LIST
1290: PPUSH
1291: CALL 57964 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1295: LD_INT 4
1297: PPUSH
1298: LD_INT 40
1300: PUSH
1301: LD_INT 75
1303: PUSH
1304: LD_INT 1
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: PUSH
1312: LD_INT 86
1314: PUSH
1315: LD_INT 105
1317: PUSH
1318: LD_INT 0
1320: PUSH
1321: EMPTY
1322: LIST
1323: LIST
1324: LIST
1325: PUSH
1326: EMPTY
1327: LIST
1328: LIST
1329: PPUSH
1330: CALL 57198 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1334: LD_INT 4
1336: PPUSH
1337: LD_INT 2
1339: PPUSH
1340: CALL 57426 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1344: LD_INT 4
1346: PPUSH
1347: LD_INT 0
1349: PPUSH
1350: CALL 57426 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1354: LD_INT 4
1356: PPUSH
1357: LD_INT 54
1359: PPUSH
1360: LD_INT 85
1362: PPUSH
1363: LD_INT 2
1365: PPUSH
1366: LD_INT 19
1368: PUSH
1369: LD_INT 16
1371: PUSH
1372: LD_INT 17
1374: PUSH
1375: LD_INT 18
1377: PUSH
1378: EMPTY
1379: LIST
1380: LIST
1381: LIST
1382: LIST
1383: PPUSH
1384: CALL 57758 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1388: LD_INT 4
1390: PPUSH
1391: LD_INT 3
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: LD_INT 1
1399: PUSH
1400: LD_INT 5
1402: PUSH
1403: EMPTY
1404: LIST
1405: LIST
1406: LIST
1407: LIST
1408: PUSH
1409: LD_INT 4
1411: PUSH
1412: LD_INT 1
1414: PUSH
1415: LD_INT 1
1417: PUSH
1418: LD_INT 6
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: PUSH
1427: LD_INT 4
1429: PUSH
1430: LD_INT 1
1432: PUSH
1433: LD_INT 1
1435: PUSH
1436: LD_INT 7
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PUSH
1445: LD_INT 4
1447: PUSH
1448: LD_INT 1
1450: PUSH
1451: LD_INT 1
1453: PUSH
1454: LD_INT 6
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: PUSH
1463: EMPTY
1464: LIST
1465: LIST
1466: LIST
1467: LIST
1468: PPUSH
1469: CALL 56874 0 2
// MC_SetTame ( 4 , powellApe ) ;
1473: LD_INT 4
1475: PPUSH
1476: LD_INT 13
1478: PPUSH
1479: CALL 57377 0 2
// end ;
1483: LD_VAR 0 1
1487: RET
// every 0 0$1 trigger debug do var i , tmp ;
1488: LD_EXP 1
1492: IFFALSE 1599
1494: GO 1496
1496: DISABLE
1497: LD_INT 0
1499: PPUSH
1500: PPUSH
// begin enable ;
1501: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1502: LD_ADDR_VAR 0 2
1506: PUSH
1507: LD_INT 22
1509: PUSH
1510: LD_INT 1
1512: PUSH
1513: EMPTY
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 3
1519: PUSH
1520: LD_INT 21
1522: PUSH
1523: LD_INT 3
1525: PUSH
1526: EMPTY
1527: LIST
1528: LIST
1529: PUSH
1530: EMPTY
1531: LIST
1532: LIST
1533: PUSH
1534: LD_INT 3
1536: PUSH
1537: LD_INT 24
1539: PUSH
1540: LD_INT 999
1542: PUSH
1543: EMPTY
1544: LIST
1545: LIST
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: LIST
1555: PPUSH
1556: CALL_OW 69
1560: ST_TO_ADDR
// if not tmp then
1561: LD_VAR 0 2
1565: NOT
1566: IFFALSE 1570
// exit ;
1568: GO 1599
// for i in tmp do
1570: LD_ADDR_VAR 0 1
1574: PUSH
1575: LD_VAR 0 2
1579: PUSH
1580: FOR_IN
1581: IFFALSE 1597
// SetLives ( i , 1000 ) ;
1583: LD_VAR 0 1
1587: PPUSH
1588: LD_INT 1000
1590: PPUSH
1591: CALL_OW 234
1595: GO 1580
1597: POP
1598: POP
// end ; end_of_file
1599: PPOPN 2
1601: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1602: LD_INT 0
1604: PPUSH
// uc_side := 1 ;
1605: LD_ADDR_OWVAR 20
1609: PUSH
1610: LD_INT 1
1612: ST_TO_ADDR
// uc_nation := 1 ;
1613: LD_ADDR_OWVAR 21
1617: PUSH
1618: LD_INT 1
1620: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1621: LD_ADDR_EXP 36
1625: PUSH
1626: LD_STRING JMM
1628: PPUSH
1629: LD_EXP 1
1633: NOT
1634: PPUSH
1635: LD_STRING 14_
1637: PPUSH
1638: CALL 62924 0 3
1642: ST_TO_ADDR
// if not JMMVeh then
1643: LD_EXP 4
1647: NOT
1648: IFFALSE 1671
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1650: LD_INT 3
1652: PPUSH
1653: LD_INT 3
1655: PPUSH
1656: LD_INT 1
1658: PPUSH
1659: LD_INT 5
1661: PPUSH
1662: LD_INT 100
1664: PPUSH
1665: CALL 69527 0 5
1669: GO 1730
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1671: LD_EXP 4
1675: PUSH
1676: LD_INT 1
1678: ARRAY
1679: PUSH
1680: LD_INT 1
1682: ARRAY
1683: PPUSH
1684: LD_EXP 4
1688: PUSH
1689: LD_INT 2
1691: ARRAY
1692: PUSH
1693: LD_INT 1
1695: ARRAY
1696: PPUSH
1697: LD_EXP 4
1701: PUSH
1702: LD_INT 3
1704: ARRAY
1705: PUSH
1706: LD_INT 1
1708: ARRAY
1709: PPUSH
1710: LD_EXP 4
1714: PUSH
1715: LD_INT 4
1717: ARRAY
1718: PUSH
1719: LD_INT 1
1721: ARRAY
1722: PPUSH
1723: LD_INT 30
1725: PPUSH
1726: CALL 69527 0 5
// JMMNewVeh := CreateVehicle ;
1730: LD_ADDR_EXP 53
1734: PUSH
1735: CALL_OW 45
1739: ST_TO_ADDR
// SetDir ( JMMNewVeh , 4 ) ;
1740: LD_EXP 53
1744: PPUSH
1745: LD_INT 4
1747: PPUSH
1748: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 75 , 92 , false ) ;
1752: LD_EXP 53
1756: PPUSH
1757: LD_INT 75
1759: PPUSH
1760: LD_INT 92
1762: PPUSH
1763: LD_INT 0
1765: PPUSH
1766: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1770: LD_EXP 36
1774: PPUSH
1775: LD_EXP 53
1779: PPUSH
1780: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1784: LD_EXP 6
1788: PUSH
1789: LD_EXP 2
1793: NOT
1794: AND
1795: IFFALSE 2053
// begin if not JMMGirlVeh then
1797: LD_EXP 5
1801: NOT
1802: IFFALSE 1825
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1804: LD_INT 3
1806: PPUSH
1807: LD_INT 3
1809: PPUSH
1810: LD_INT 1
1812: PPUSH
1813: LD_INT 9
1815: PPUSH
1816: LD_INT 100
1818: PPUSH
1819: CALL 69527 0 5
1823: GO 1884
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1825: LD_EXP 5
1829: PUSH
1830: LD_INT 1
1832: ARRAY
1833: PUSH
1834: LD_INT 1
1836: ARRAY
1837: PPUSH
1838: LD_EXP 5
1842: PUSH
1843: LD_INT 2
1845: ARRAY
1846: PUSH
1847: LD_INT 1
1849: ARRAY
1850: PPUSH
1851: LD_EXP 5
1855: PUSH
1856: LD_INT 3
1858: ARRAY
1859: PUSH
1860: LD_INT 1
1862: ARRAY
1863: PPUSH
1864: LD_EXP 5
1868: PUSH
1869: LD_INT 4
1871: ARRAY
1872: PUSH
1873: LD_INT 1
1875: ARRAY
1876: PPUSH
1877: LD_INT 30
1879: PPUSH
1880: CALL 69527 0 5
// GirlNewVeh := CreateVehicle ;
1884: LD_ADDR_EXP 54
1888: PUSH
1889: CALL_OW 45
1893: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1894: LD_EXP 54
1898: PPUSH
1899: LD_INT 4
1901: PPUSH
1902: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1906: LD_EXP 54
1910: PPUSH
1911: LD_INT 82
1913: PPUSH
1914: LD_INT 96
1916: PPUSH
1917: LD_INT 0
1919: PPUSH
1920: CALL_OW 48
// if JMMGirl = 1 then
1924: LD_EXP 7
1928: PUSH
1929: LD_INT 1
1931: EQUAL
1932: IFFALSE 1967
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
1934: LD_ADDR_EXP 37
1938: PUSH
1939: LD_STRING Joan
1941: PPUSH
1942: LD_INT 1
1944: PPUSH
1945: LD_STRING 14_
1947: PPUSH
1948: CALL 62924 0 3
1952: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
1953: LD_EXP 37
1957: PPUSH
1958: LD_EXP 54
1962: PPUSH
1963: CALL_OW 52
// end ; if JMMGirl = 2 then
1967: LD_EXP 7
1971: PUSH
1972: LD_INT 2
1974: EQUAL
1975: IFFALSE 2010
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
1977: LD_ADDR_EXP 39
1981: PUSH
1982: LD_STRING Lisa
1984: PPUSH
1985: LD_INT 1
1987: PPUSH
1988: LD_STRING 14_
1990: PPUSH
1991: CALL 62924 0 3
1995: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
1996: LD_EXP 39
2000: PPUSH
2001: LD_EXP 54
2005: PPUSH
2006: CALL_OW 52
// end ; if JMMGirl = 3 then
2010: LD_EXP 7
2014: PUSH
2015: LD_INT 3
2017: EQUAL
2018: IFFALSE 2053
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2020: LD_ADDR_EXP 51
2024: PUSH
2025: LD_STRING Connie
2027: PPUSH
2028: LD_INT 1
2030: PPUSH
2031: LD_STRING 14_
2033: PPUSH
2034: CALL 62924 0 3
2038: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2039: LD_EXP 51
2043: PPUSH
2044: LD_EXP 54
2048: PPUSH
2049: CALL_OW 52
// end ; end ; end ;
2053: LD_VAR 0 1
2057: RET
// export function PrepareStevensSquad ; var tmp ; begin
2058: LD_INT 0
2060: PPUSH
2061: PPUSH
// uc_side := 1 ;
2062: LD_ADDR_OWVAR 20
2066: PUSH
2067: LD_INT 1
2069: ST_TO_ADDR
// uc_nation := 1 ;
2070: LD_ADDR_OWVAR 21
2074: PUSH
2075: LD_INT 1
2077: ST_TO_ADDR
// tmp := [ ] ;
2078: LD_ADDR_VAR 0 2
2082: PUSH
2083: EMPTY
2084: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2085: LD_ADDR_EXP 38
2089: PUSH
2090: LD_STRING Stevens
2092: PPUSH
2093: LD_EXP 1
2097: NOT
2098: PPUSH
2099: LD_STRING 13f_
2101: PPUSH
2102: CALL 62924 0 3
2106: ST_TO_ADDR
// if not Stevens then
2107: LD_EXP 38
2111: NOT
2112: IFFALSE 2168
// begin hc_name = Baker Smith ;
2114: LD_ADDR_OWVAR 26
2118: PUSH
2119: LD_STRING Baker Smith
2121: ST_TO_ADDR
// hc_gallery =  ;
2122: LD_ADDR_OWVAR 33
2126: PUSH
2127: LD_STRING 
2129: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2130: LD_INT 1
2132: PPUSH
2133: LD_INT 10
2135: PPUSH
2136: CALL_OW 384
// Baker = CreateHuman ;
2140: LD_ADDR_EXP 52
2144: PUSH
2145: CALL_OW 44
2149: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2150: LD_ADDR_VAR 0 2
2154: PUSH
2155: LD_VAR 0 2
2159: PUSH
2160: LD_EXP 52
2164: ADD
2165: ST_TO_ADDR
// end else
2166: GO 2184
// tmp := tmp ^ Stevens ;
2168: LD_ADDR_VAR 0 2
2172: PUSH
2173: LD_VAR 0 2
2177: PUSH
2178: LD_EXP 38
2182: ADD
2183: ST_TO_ADDR
// if not Lisa then
2184: LD_EXP 39
2188: NOT
2189: IFFALSE 2235
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2191: LD_ADDR_EXP 39
2195: PUSH
2196: LD_STRING Lisa
2198: PPUSH
2199: LD_EXP 1
2203: NOT
2204: PPUSH
2205: LD_STRING 13f_
2207: PPUSH
2208: CALL 62924 0 3
2212: ST_TO_ADDR
// if Lisa then
2213: LD_EXP 39
2217: IFFALSE 2235
// tmp := tmp ^ Lisa ;
2219: LD_ADDR_VAR 0 2
2223: PUSH
2224: LD_VAR 0 2
2228: PUSH
2229: LD_EXP 39
2233: ADD
2234: ST_TO_ADDR
// end ; if not Donaldson then
2235: LD_EXP 40
2239: NOT
2240: IFFALSE 2286
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2242: LD_ADDR_EXP 40
2246: PUSH
2247: LD_STRING Donaldson
2249: PPUSH
2250: LD_EXP 1
2254: NOT
2255: PPUSH
2256: LD_STRING 13f_
2258: PPUSH
2259: CALL 62924 0 3
2263: ST_TO_ADDR
// if Donaldson then
2264: LD_EXP 40
2268: IFFALSE 2286
// tmp := tmp ^ Donaldson ;
2270: LD_ADDR_VAR 0 2
2274: PUSH
2275: LD_VAR 0 2
2279: PUSH
2280: LD_EXP 40
2284: ADD
2285: ST_TO_ADDR
// end ; if not Bobby then
2286: LD_EXP 41
2290: NOT
2291: IFFALSE 2337
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2293: LD_ADDR_EXP 41
2297: PUSH
2298: LD_STRING Bobby
2300: PPUSH
2301: LD_EXP 1
2305: NOT
2306: PPUSH
2307: LD_STRING 13f_
2309: PPUSH
2310: CALL 62924 0 3
2314: ST_TO_ADDR
// if Bobby then
2315: LD_EXP 41
2319: IFFALSE 2337
// tmp := tmp ^ Bobby ;
2321: LD_ADDR_VAR 0 2
2325: PUSH
2326: LD_VAR 0 2
2330: PUSH
2331: LD_EXP 41
2335: ADD
2336: ST_TO_ADDR
// end ; if not Cyrus then
2337: LD_EXP 42
2341: NOT
2342: IFFALSE 2388
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2344: LD_ADDR_EXP 42
2348: PUSH
2349: LD_STRING Cyrus
2351: PPUSH
2352: LD_EXP 1
2356: NOT
2357: PPUSH
2358: LD_STRING 13f_
2360: PPUSH
2361: CALL 62924 0 3
2365: ST_TO_ADDR
// if Cyrus then
2366: LD_EXP 42
2370: IFFALSE 2388
// tmp := tmp ^ Cyrus ;
2372: LD_ADDR_VAR 0 2
2376: PUSH
2377: LD_VAR 0 2
2381: PUSH
2382: LD_EXP 42
2386: ADD
2387: ST_TO_ADDR
// end ; if not Brown then
2388: LD_EXP 44
2392: NOT
2393: IFFALSE 2439
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2395: LD_ADDR_EXP 44
2399: PUSH
2400: LD_STRING Brown
2402: PPUSH
2403: LD_EXP 1
2407: NOT
2408: PPUSH
2409: LD_STRING 13f_
2411: PPUSH
2412: CALL 62924 0 3
2416: ST_TO_ADDR
// if Brown then
2417: LD_EXP 44
2421: IFFALSE 2439
// tmp := tmp ^ Brown ;
2423: LD_ADDR_VAR 0 2
2427: PUSH
2428: LD_VAR 0 2
2432: PUSH
2433: LD_EXP 44
2437: ADD
2438: ST_TO_ADDR
// end ; if not Gladstone then
2439: LD_EXP 45
2443: NOT
2444: IFFALSE 2490
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2446: LD_ADDR_EXP 45
2450: PUSH
2451: LD_STRING Gladstone
2453: PPUSH
2454: LD_EXP 1
2458: NOT
2459: PPUSH
2460: LD_STRING 13f_
2462: PPUSH
2463: CALL 62924 0 3
2467: ST_TO_ADDR
// if Gladstone then
2468: LD_EXP 45
2472: IFFALSE 2490
// tmp := tmp ^ Gladstone ;
2474: LD_ADDR_VAR 0 2
2478: PUSH
2479: LD_VAR 0 2
2483: PUSH
2484: LD_EXP 45
2488: ADD
2489: ST_TO_ADDR
// end ; if not Houten then
2490: LD_EXP 46
2494: NOT
2495: IFFALSE 2541
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2497: LD_ADDR_EXP 46
2501: PUSH
2502: LD_STRING Houten
2504: PPUSH
2505: LD_EXP 1
2509: NOT
2510: PPUSH
2511: LD_STRING 13f_
2513: PPUSH
2514: CALL 62924 0 3
2518: ST_TO_ADDR
// if Houten then
2519: LD_EXP 46
2523: IFFALSE 2541
// tmp := tmp ^ Houten ;
2525: LD_ADDR_VAR 0 2
2529: PUSH
2530: LD_VAR 0 2
2534: PUSH
2535: LD_EXP 46
2539: ADD
2540: ST_TO_ADDR
// end ; if not Cornel then
2541: LD_EXP 47
2545: NOT
2546: IFFALSE 2592
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2548: LD_ADDR_EXP 47
2552: PUSH
2553: LD_STRING Cornel
2555: PPUSH
2556: LD_EXP 1
2560: NOT
2561: PPUSH
2562: LD_STRING 13f_
2564: PPUSH
2565: CALL 62924 0 3
2569: ST_TO_ADDR
// if Cornel then
2570: LD_EXP 47
2574: IFFALSE 2592
// tmp := tmp ^ Cornel ;
2576: LD_ADDR_VAR 0 2
2580: PUSH
2581: LD_VAR 0 2
2585: PUSH
2586: LD_EXP 47
2590: ADD
2591: ST_TO_ADDR
// end ; if not Gary then
2592: LD_EXP 48
2596: NOT
2597: IFFALSE 2643
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2599: LD_ADDR_EXP 48
2603: PUSH
2604: LD_STRING Gary
2606: PPUSH
2607: LD_EXP 1
2611: NOT
2612: PPUSH
2613: LD_STRING 13f_
2615: PPUSH
2616: CALL 62924 0 3
2620: ST_TO_ADDR
// if Gary then
2621: LD_EXP 48
2625: IFFALSE 2643
// tmp := tmp ^ Gary ;
2627: LD_ADDR_VAR 0 2
2631: PUSH
2632: LD_VAR 0 2
2636: PUSH
2637: LD_EXP 48
2641: ADD
2642: ST_TO_ADDR
// end ; if not Frank then
2643: LD_EXP 49
2647: NOT
2648: IFFALSE 2694
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2650: LD_ADDR_EXP 49
2654: PUSH
2655: LD_STRING Frank
2657: PPUSH
2658: LD_EXP 1
2662: NOT
2663: PPUSH
2664: LD_STRING 13f_
2666: PPUSH
2667: CALL 62924 0 3
2671: ST_TO_ADDR
// if Frank then
2672: LD_EXP 49
2676: IFFALSE 2694
// tmp := tmp ^ Frank ;
2678: LD_ADDR_VAR 0 2
2682: PUSH
2683: LD_VAR 0 2
2687: PUSH
2688: LD_EXP 49
2692: ADD
2693: ST_TO_ADDR
// end ; if not Kikuchi then
2694: LD_EXP 50
2698: NOT
2699: IFFALSE 2745
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2701: LD_ADDR_EXP 50
2705: PUSH
2706: LD_STRING Kikuchi
2708: PPUSH
2709: LD_EXP 1
2713: NOT
2714: PPUSH
2715: LD_STRING 13f_
2717: PPUSH
2718: CALL 62924 0 3
2722: ST_TO_ADDR
// if Kikuchi then
2723: LD_EXP 50
2727: IFFALSE 2745
// tmp := tmp ^ Kikuchi ;
2729: LD_ADDR_VAR 0 2
2733: PUSH
2734: LD_VAR 0 2
2738: PUSH
2739: LD_EXP 50
2743: ADD
2744: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2745: LD_ADDR_VAR 0 2
2749: PUSH
2750: LD_VAR 0 2
2754: PUSH
2755: LD_STRING 13_other_survivors
2757: PPUSH
2758: CALL_OW 31
2762: UNION
2763: ST_TO_ADDR
// result := tmp ;
2764: LD_ADDR_VAR 0 1
2768: PUSH
2769: LD_VAR 0 2
2773: ST_TO_ADDR
// end ; end_of_file
2774: LD_VAR 0 1
2778: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2779: LD_INT 0
2781: PPUSH
2782: PPUSH
2783: PPUSH
2784: PPUSH
2785: PPUSH
2786: PPUSH
2787: PPUSH
2788: PPUSH
2789: PPUSH
2790: PPUSH
// uc_side := 4 ;
2791: LD_ADDR_OWVAR 20
2795: PUSH
2796: LD_INT 4
2798: ST_TO_ADDR
// uc_nation := 1 ;
2799: LD_ADDR_OWVAR 21
2803: PUSH
2804: LD_INT 1
2806: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2807: LD_INT 387
2809: PPUSH
2810: CALL_OW 274
2814: PPUSH
2815: LD_INT 1
2817: PPUSH
2818: LD_INT 2500
2820: PPUSH
2821: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2825: LD_INT 387
2827: PPUSH
2828: CALL_OW 274
2832: PPUSH
2833: LD_INT 2
2835: PPUSH
2836: LD_INT 400
2838: PPUSH
2839: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2843: LD_INT 387
2845: PPUSH
2846: CALL_OW 274
2850: PPUSH
2851: LD_INT 3
2853: PPUSH
2854: LD_INT 10
2856: PPUSH
2857: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2861: LD_ADDR_EXP 55
2865: PUSH
2866: LD_STRING Powell
2868: PPUSH
2869: CALL_OW 25
2873: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2874: LD_EXP 55
2878: PPUSH
2879: LD_INT 57
2881: PPUSH
2882: LD_INT 94
2884: PPUSH
2885: LD_INT 0
2887: PPUSH
2888: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2892: LD_EXP 55
2896: PPUSH
2897: LD_INT 58
2899: PPUSH
2900: LD_INT 94
2902: PPUSH
2903: CALL_OW 118
// vip := [ ] ;
2907: LD_ADDR_EXP 56
2911: PUSH
2912: EMPTY
2913: ST_TO_ADDR
// tmp := [ ] ;
2914: LD_ADDR_VAR 0 6
2918: PUSH
2919: EMPTY
2920: ST_TO_ADDR
// if JMMGirl <> 2 then
2921: LD_EXP 7
2925: PUSH
2926: LD_INT 2
2928: NONEQUAL
2929: IFFALSE 2953
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
2931: LD_ADDR_EXP 39
2935: PUSH
2936: LD_STRING Lisa
2938: PPUSH
2939: LD_EXP 1
2943: NOT
2944: PPUSH
2945: LD_STRING 13s_
2947: PPUSH
2948: CALL 62924 0 3
2952: ST_TO_ADDR
// if Lisa then
2953: LD_EXP 39
2957: IFFALSE 2975
// tmp := tmp ^ Lisa ;
2959: LD_ADDR_VAR 0 6
2963: PUSH
2964: LD_VAR 0 6
2968: PUSH
2969: LD_EXP 39
2973: ADD
2974: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
2975: LD_ADDR_EXP 40
2979: PUSH
2980: LD_STRING Donaldson
2982: PPUSH
2983: LD_EXP 1
2987: NOT
2988: PPUSH
2989: LD_STRING 13s_
2991: PPUSH
2992: CALL 62924 0 3
2996: ST_TO_ADDR
// if Donaldson then
2997: LD_EXP 40
3001: IFFALSE 3019
// tmp := tmp ^ Donaldson ;
3003: LD_ADDR_VAR 0 6
3007: PUSH
3008: LD_VAR 0 6
3012: PUSH
3013: LD_EXP 40
3017: ADD
3018: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3019: LD_ADDR_EXP 41
3023: PUSH
3024: LD_STRING Bobby
3026: PPUSH
3027: LD_EXP 1
3031: NOT
3032: PPUSH
3033: LD_STRING 13s_
3035: PPUSH
3036: CALL 62924 0 3
3040: ST_TO_ADDR
// if Bobby then
3041: LD_EXP 41
3045: IFFALSE 3063
// tmp := tmp ^ Bobby ;
3047: LD_ADDR_VAR 0 6
3051: PUSH
3052: LD_VAR 0 6
3056: PUSH
3057: LD_EXP 41
3061: ADD
3062: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3063: LD_ADDR_EXP 42
3067: PUSH
3068: LD_STRING Cyrus
3070: PPUSH
3071: LD_EXP 1
3075: NOT
3076: PPUSH
3077: LD_STRING 13s_
3079: PPUSH
3080: CALL 62924 0 3
3084: ST_TO_ADDR
// if Cyrus then
3085: LD_EXP 42
3089: IFFALSE 3107
// tmp := tmp ^ Cyrus ;
3091: LD_ADDR_VAR 0 6
3095: PUSH
3096: LD_VAR 0 6
3100: PUSH
3101: LD_EXP 42
3105: ADD
3106: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3107: LD_ADDR_EXP 43
3111: PUSH
3112: LD_STRING Denis
3114: PPUSH
3115: LD_EXP 1
3119: NOT
3120: PPUSH
3121: LD_STRING 13s_
3123: PPUSH
3124: CALL 62924 0 3
3128: ST_TO_ADDR
// if not Denis then
3129: LD_EXP 43
3133: NOT
3134: IFFALSE 3158
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3136: LD_ADDR_EXP 43
3140: PUSH
3141: LD_STRING Denis
3143: PPUSH
3144: LD_EXP 1
3148: NOT
3149: PPUSH
3150: LD_STRING 13f_
3152: PPUSH
3153: CALL 62924 0 3
3157: ST_TO_ADDR
// if Denis then
3158: LD_EXP 43
3162: IFFALSE 3180
// tmp := tmp ^ Denis ;
3164: LD_ADDR_VAR 0 6
3168: PUSH
3169: LD_VAR 0 6
3173: PUSH
3174: LD_EXP 43
3178: ADD
3179: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3180: LD_ADDR_EXP 44
3184: PUSH
3185: LD_STRING Brown
3187: PPUSH
3188: LD_EXP 1
3192: NOT
3193: PPUSH
3194: LD_STRING 13s_
3196: PPUSH
3197: CALL 62924 0 3
3201: ST_TO_ADDR
// if Brown then
3202: LD_EXP 44
3206: IFFALSE 3224
// tmp := tmp ^ Brown ;
3208: LD_ADDR_VAR 0 6
3212: PUSH
3213: LD_VAR 0 6
3217: PUSH
3218: LD_EXP 44
3222: ADD
3223: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3224: LD_ADDR_EXP 45
3228: PUSH
3229: LD_STRING Gladstone
3231: PPUSH
3232: LD_EXP 1
3236: NOT
3237: PPUSH
3238: LD_STRING 13s_
3240: PPUSH
3241: CALL 62924 0 3
3245: ST_TO_ADDR
// if Gladstone then
3246: LD_EXP 45
3250: IFFALSE 3268
// tmp := tmp ^ Gladstone ;
3252: LD_ADDR_VAR 0 6
3256: PUSH
3257: LD_VAR 0 6
3261: PUSH
3262: LD_EXP 45
3266: ADD
3267: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3268: LD_ADDR_EXP 46
3272: PUSH
3273: LD_STRING Houten
3275: PPUSH
3276: LD_EXP 1
3280: NOT
3281: PPUSH
3282: LD_STRING 13s_
3284: PPUSH
3285: CALL 62924 0 3
3289: ST_TO_ADDR
// if Houten then
3290: LD_EXP 46
3294: IFFALSE 3312
// tmp := tmp ^ Houten ;
3296: LD_ADDR_VAR 0 6
3300: PUSH
3301: LD_VAR 0 6
3305: PUSH
3306: LD_EXP 46
3310: ADD
3311: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3312: LD_ADDR_EXP 47
3316: PUSH
3317: LD_STRING Cornel
3319: PPUSH
3320: LD_EXP 1
3324: NOT
3325: PPUSH
3326: LD_STRING 13s_
3328: PPUSH
3329: CALL 62924 0 3
3333: ST_TO_ADDR
// if Cornel then
3334: LD_EXP 47
3338: IFFALSE 3356
// tmp := tmp ^ Cornel ;
3340: LD_ADDR_VAR 0 6
3344: PUSH
3345: LD_VAR 0 6
3349: PUSH
3350: LD_EXP 47
3354: ADD
3355: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3356: LD_ADDR_EXP 48
3360: PUSH
3361: LD_STRING Gary
3363: PPUSH
3364: LD_EXP 1
3368: NOT
3369: PPUSH
3370: LD_STRING 13s_
3372: PPUSH
3373: CALL 62924 0 3
3377: ST_TO_ADDR
// if Gary then
3378: LD_EXP 48
3382: IFFALSE 3400
// tmp := tmp ^ Gary ;
3384: LD_ADDR_VAR 0 6
3388: PUSH
3389: LD_VAR 0 6
3393: PUSH
3394: LD_EXP 48
3398: ADD
3399: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3400: LD_ADDR_EXP 49
3404: PUSH
3405: LD_STRING Frank
3407: PPUSH
3408: LD_EXP 1
3412: NOT
3413: PPUSH
3414: LD_STRING 13s_
3416: PPUSH
3417: CALL 62924 0 3
3421: ST_TO_ADDR
// if Frank then
3422: LD_EXP 49
3426: IFFALSE 3444
// tmp := tmp ^ Frank ;
3428: LD_ADDR_VAR 0 6
3432: PUSH
3433: LD_VAR 0 6
3437: PUSH
3438: LD_EXP 49
3442: ADD
3443: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3444: LD_ADDR_EXP 50
3448: PUSH
3449: LD_STRING Kikuchi
3451: PPUSH
3452: LD_EXP 1
3456: NOT
3457: PPUSH
3458: LD_STRING 13s_
3460: PPUSH
3461: CALL 62924 0 3
3465: ST_TO_ADDR
// if Kikuchi then
3466: LD_EXP 50
3470: IFFALSE 3488
// tmp := tmp ^ Kikuchi ;
3472: LD_ADDR_VAR 0 6
3476: PUSH
3477: LD_VAR 0 6
3481: PUSH
3482: LD_EXP 50
3486: ADD
3487: ST_TO_ADDR
// vip := tmp ;
3488: LD_ADDR_EXP 56
3492: PUSH
3493: LD_VAR 0 6
3497: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3498: LD_ADDR_VAR 0 6
3502: PUSH
3503: LD_VAR 0 6
3507: PUSH
3508: LD_STRING 13s_others
3510: PPUSH
3511: CALL_OW 31
3515: UNION
3516: ST_TO_ADDR
// if tmp < 20 then
3517: LD_VAR 0 6
3521: PUSH
3522: LD_INT 20
3524: LESS
3525: IFFALSE 3592
// for i = 1 to 20 - tmp do
3527: LD_ADDR_VAR 0 2
3531: PUSH
3532: DOUBLE
3533: LD_INT 1
3535: DEC
3536: ST_TO_ADDR
3537: LD_INT 20
3539: PUSH
3540: LD_VAR 0 6
3544: MINUS
3545: PUSH
3546: FOR_TO
3547: IFFALSE 3590
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3549: LD_INT 1
3551: PPUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_INT 4
3559: MOD
3560: PUSH
3561: LD_INT 1
3563: PLUS
3564: PPUSH
3565: LD_INT 5
3567: PPUSH
3568: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3572: LD_ADDR_VAR 0 6
3576: PUSH
3577: LD_VAR 0 6
3581: PUSH
3582: CALL_OW 44
3586: ADD
3587: ST_TO_ADDR
// end ;
3588: GO 3546
3590: POP
3591: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3592: LD_ADDR_VAR 0 7
3596: PUSH
3597: LD_INT 22
3599: PUSH
3600: LD_INT 4
3602: PUSH
3603: EMPTY
3604: LIST
3605: LIST
3606: PUSH
3607: LD_INT 30
3609: PUSH
3610: LD_INT 0
3612: PUSH
3613: EMPTY
3614: LIST
3615: LIST
3616: PUSH
3617: EMPTY
3618: LIST
3619: LIST
3620: PPUSH
3621: CALL_OW 69
3625: PUSH
3626: LD_INT 1
3628: ARRAY
3629: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3630: LD_ADDR_VAR 0 8
3634: PUSH
3635: LD_INT 22
3637: PUSH
3638: LD_INT 4
3640: PUSH
3641: EMPTY
3642: LIST
3643: LIST
3644: PUSH
3645: LD_INT 30
3647: PUSH
3648: LD_INT 6
3650: PUSH
3651: EMPTY
3652: LIST
3653: LIST
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: PPUSH
3659: CALL_OW 69
3663: PUSH
3664: LD_INT 1
3666: ARRAY
3667: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3668: LD_ADDR_VAR 0 9
3672: PUSH
3673: LD_INT 22
3675: PUSH
3676: LD_INT 4
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: PUSH
3683: LD_INT 30
3685: PUSH
3686: LD_INT 4
3688: PUSH
3689: EMPTY
3690: LIST
3691: LIST
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PPUSH
3697: CALL_OW 69
3701: PUSH
3702: LD_INT 1
3704: ARRAY
3705: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3706: LD_ADDR_VAR 0 10
3710: PUSH
3711: LD_INT 22
3713: PUSH
3714: LD_INT 4
3716: PUSH
3717: EMPTY
3718: LIST
3719: LIST
3720: PUSH
3721: LD_INT 30
3723: PUSH
3724: LD_INT 2
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PPUSH
3735: CALL_OW 69
3739: PUSH
3740: LD_INT 1
3742: ARRAY
3743: ST_TO_ADDR
// for i in tmp do
3744: LD_ADDR_VAR 0 2
3748: PUSH
3749: LD_VAR 0 6
3753: PUSH
3754: FOR_IN
3755: IFFALSE 3881
// begin cl := GetClass ( i ) ;
3757: LD_ADDR_VAR 0 5
3761: PUSH
3762: LD_VAR 0 2
3766: PPUSH
3767: CALL_OW 257
3771: ST_TO_ADDR
// if cl > 4 then
3772: LD_VAR 0 5
3776: PUSH
3777: LD_INT 4
3779: GREATER
3780: IFFALSE 3790
// cl := 1 ;
3782: LD_ADDR_VAR 0 5
3786: PUSH
3787: LD_INT 1
3789: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3790: LD_ADDR_VAR 0 3
3794: PUSH
3795: LD_VAR 0 9
3799: PUSH
3800: LD_VAR 0 7
3804: PUSH
3805: LD_VAR 0 10
3809: PUSH
3810: LD_VAR 0 8
3814: PUSH
3815: EMPTY
3816: LIST
3817: LIST
3818: LIST
3819: LIST
3820: PUSH
3821: LD_VAR 0 5
3825: ARRAY
3826: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3827: LD_VAR 0 3
3831: PPUSH
3832: CALL_OW 313
3836: PUSH
3837: LD_INT 5
3839: LESS
3840: IFFALSE 3858
// PlaceHumanInUnit ( i , b ) else
3842: LD_VAR 0 2
3846: PPUSH
3847: LD_VAR 0 3
3851: PPUSH
3852: CALL_OW 52
3856: GO 3879
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3858: LD_VAR 0 2
3862: PPUSH
3863: LD_INT 58
3865: PPUSH
3866: LD_INT 91
3868: PPUSH
3869: LD_INT 6
3871: PPUSH
3872: LD_INT 0
3874: PPUSH
3875: CALL_OW 50
// end ;
3879: GO 3754
3881: POP
3882: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3883: LD_INT 2
3885: PPUSH
3886: LD_INT 1
3888: PPUSH
3889: LD_INT 1
3891: PPUSH
3892: LD_INT 12
3894: PPUSH
3895: LD_INT 100
3897: PPUSH
3898: CALL 69527 0 5
// veh := CreateVehicle ;
3902: LD_ADDR_VAR 0 4
3906: PUSH
3907: CALL_OW 45
3911: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
3912: LD_VAR 0 4
3916: PPUSH
3917: LD_INT 4
3919: PPUSH
3920: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
3924: LD_VAR 0 4
3928: PPUSH
3929: LD_INT 49
3931: PPUSH
3932: LD_INT 88
3934: PPUSH
3935: LD_INT 0
3937: PPUSH
3938: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
3942: LD_VAR 0 4
3946: PPUSH
3947: LD_INT 1
3949: PPUSH
3950: LD_INT 100
3952: PPUSH
3953: CALL_OW 290
// uc_side := 0 ;
3957: LD_ADDR_OWVAR 20
3961: PUSH
3962: LD_INT 0
3964: ST_TO_ADDR
// uc_nation := 0 ;
3965: LD_ADDR_OWVAR 21
3969: PUSH
3970: LD_INT 0
3972: ST_TO_ADDR
// for i = 1 to 4 do
3973: LD_ADDR_VAR 0 2
3977: PUSH
3978: DOUBLE
3979: LD_INT 1
3981: DEC
3982: ST_TO_ADDR
3983: LD_INT 4
3985: PUSH
3986: FOR_TO
3987: IFFALSE 4018
// begin InitHc ;
3989: CALL_OW 19
// hc_class := class_apeman ;
3993: LD_ADDR_OWVAR 28
3997: PUSH
3998: LD_INT 12
4000: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4001: CALL_OW 44
4005: PPUSH
4006: LD_INT 13
4008: PPUSH
4009: LD_INT 0
4011: PPUSH
4012: CALL_OW 49
// end ;
4016: GO 3986
4018: POP
4019: POP
// end ; end_of_file
4020: LD_VAR 0 1
4024: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4025: LD_INT 0
4027: PPUSH
4028: PPUSH
4029: PPUSH
4030: PPUSH
4031: PPUSH
// side := 8 ;
4032: LD_ADDR_VAR 0 3
4036: PUSH
4037: LD_INT 8
4039: ST_TO_ADDR
// uc_side := side ;
4040: LD_ADDR_OWVAR 20
4044: PUSH
4045: LD_VAR 0 3
4049: ST_TO_ADDR
// uc_nation := 2 ;
4050: LD_ADDR_OWVAR 21
4054: PUSH
4055: LD_INT 2
4057: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4058: LD_ADDR_VAR 0 2
4062: PUSH
4063: LD_INT 22
4065: PUSH
4066: LD_VAR 0 3
4070: PUSH
4071: EMPTY
4072: LIST
4073: LIST
4074: PUSH
4075: LD_INT 21
4077: PUSH
4078: LD_INT 3
4080: PUSH
4081: EMPTY
4082: LIST
4083: LIST
4084: PUSH
4085: EMPTY
4086: LIST
4087: LIST
4088: PPUSH
4089: CALL_OW 69
4093: PUSH
4094: FOR_IN
4095: IFFALSE 4111
// SetBLevel ( i , 10 ) ;
4097: LD_VAR 0 2
4101: PPUSH
4102: LD_INT 10
4104: PPUSH
4105: CALL_OW 241
4109: GO 4094
4111: POP
4112: POP
// if KurtStatus then
4113: LD_EXP 3
4117: IFFALSE 4140
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4119: LD_ADDR_EXP 57
4123: PUSH
4124: LD_STRING Kurt
4126: PPUSH
4127: LD_INT 0
4129: PPUSH
4130: LD_STRING 
4132: PPUSH
4133: CALL 62924 0 3
4137: ST_TO_ADDR
4138: GO 4162
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4140: LD_ADDR_EXP 57
4144: PUSH
4145: LD_STRING AltKurt
4147: PPUSH
4148: LD_EXP 1
4152: NOT
4153: PPUSH
4154: LD_STRING 
4156: PPUSH
4157: CALL 62924 0 3
4161: ST_TO_ADDR
// if not Kurt then
4162: LD_EXP 57
4166: NOT
4167: IFFALSE 4193
// begin InitHc ;
4169: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4173: LD_INT 1
4175: PPUSH
4176: LD_INT 10
4178: PPUSH
4179: CALL_OW 381
// Kurt := CreateHuman ;
4183: LD_ADDR_EXP 57
4187: PUSH
4188: CALL_OW 44
4192: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4193: LD_EXP 57
4197: PPUSH
4198: LD_INT 324
4200: PPUSH
4201: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4205: LD_ADDR_EXP 58
4209: PUSH
4210: LD_STRING Kozlov
4212: PPUSH
4213: LD_INT 0
4215: PPUSH
4216: LD_STRING 
4218: PPUSH
4219: CALL 62924 0 3
4223: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4224: LD_EXP 58
4228: PPUSH
4229: LD_INT 22
4231: PUSH
4232: LD_INT 8
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: LD_INT 23
4241: PUSH
4242: LD_INT 3
4244: PUSH
4245: EMPTY
4246: LIST
4247: LIST
4248: PUSH
4249: LD_INT 30
4251: PUSH
4252: LD_INT 8
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: PPUSH
4264: CALL_OW 69
4268: PUSH
4269: LD_INT 1
4271: ARRAY
4272: PPUSH
4273: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4277: LD_EXP 58
4281: PPUSH
4282: LD_INT 3
4284: PPUSH
4285: LD_INT 10
4287: PPUSH
4288: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4292: LD_ADDR_VAR 0 5
4296: PUSH
4297: LD_INT 22
4299: PUSH
4300: LD_VAR 0 3
4304: PUSH
4305: EMPTY
4306: LIST
4307: LIST
4308: PUSH
4309: LD_INT 30
4311: PUSH
4312: LD_INT 32
4314: PUSH
4315: EMPTY
4316: LIST
4317: LIST
4318: PUSH
4319: LD_INT 58
4321: PUSH
4322: EMPTY
4323: LIST
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: LIST
4329: PPUSH
4330: CALL_OW 69
4334: ST_TO_ADDR
// for i = 1 to 10 do
4335: LD_ADDR_VAR 0 2
4339: PUSH
4340: DOUBLE
4341: LD_INT 1
4343: DEC
4344: ST_TO_ADDR
4345: LD_INT 10
4347: PUSH
4348: FOR_TO
4349: IFFALSE 4421
// begin uc_nation := nation_nature ;
4351: LD_ADDR_OWVAR 21
4355: PUSH
4356: LD_INT 0
4358: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4359: LD_ADDR_OWVAR 28
4363: PUSH
4364: LD_INT 15
4366: ST_TO_ADDR
// hc_gallery :=  ;
4367: LD_ADDR_OWVAR 33
4371: PUSH
4372: LD_STRING 
4374: ST_TO_ADDR
// hc_name :=  ;
4375: LD_ADDR_OWVAR 26
4379: PUSH
4380: LD_STRING 
4382: ST_TO_ADDR
// un := CreateHuman ;
4383: LD_ADDR_VAR 0 4
4387: PUSH
4388: CALL_OW 44
4392: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4393: LD_VAR 0 4
4397: PPUSH
4398: LD_VAR 0 5
4402: PUSH
4403: LD_VAR 0 5
4407: PUSH
4408: LD_VAR 0 2
4412: MINUS
4413: ARRAY
4414: PPUSH
4415: CALL_OW 52
// end ;
4419: GO 4348
4421: POP
4422: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4423: LD_ADDR_VAR 0 5
4427: PUSH
4428: LD_STRING 12_kurt_squad
4430: PPUSH
4431: CALL_OW 31
4435: ST_TO_ADDR
// if tmp then
4436: LD_VAR 0 5
4440: IFFALSE 4474
// for i in tmp do
4442: LD_ADDR_VAR 0 2
4446: PUSH
4447: LD_VAR 0 5
4451: PUSH
4452: FOR_IN
4453: IFFALSE 4472
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4455: LD_VAR 0 2
4459: PPUSH
4460: LD_INT 5
4462: PPUSH
4463: LD_INT 0
4465: PPUSH
4466: CALL_OW 49
4470: GO 4452
4472: POP
4473: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4474: LD_INT 324
4476: PPUSH
4477: LD_INT 5
4479: PPUSH
4480: LD_STRING 
4482: PPUSH
4483: LD_INT 8
4485: PUSH
4486: LD_INT 9
4488: PUSH
4489: LD_INT 10
4491: PUSH
4492: EMPTY
4493: LIST
4494: LIST
4495: LIST
4496: PUSH
4497: LD_OWVAR 67
4501: ARRAY
4502: PPUSH
4503: LD_INT 3000
4505: PUSH
4506: LD_INT 500
4508: PUSH
4509: LD_INT 150
4511: PUSH
4512: EMPTY
4513: LIST
4514: LIST
4515: LIST
4516: PPUSH
4517: LD_INT 16
4519: PUSH
4520: LD_INT 6
4522: PUSH
4523: LD_INT 6
4525: PUSH
4526: LD_INT 8
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: LIST
4533: LIST
4534: PPUSH
4535: CALL 72936 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4539: LD_ADDR_EXP 99
4543: PUSH
4544: LD_EXP 99
4548: PPUSH
4549: LD_INT 3
4551: PPUSH
4552: LD_INT 22
4554: PUSH
4555: LD_VAR 0 3
4559: PUSH
4560: EMPTY
4561: LIST
4562: LIST
4563: PUSH
4564: LD_INT 23
4566: PUSH
4567: LD_INT 2
4569: PUSH
4570: EMPTY
4571: LIST
4572: LIST
4573: PUSH
4574: LD_INT 3
4576: PUSH
4577: LD_INT 21
4579: PUSH
4580: LD_INT 2
4582: PUSH
4583: EMPTY
4584: LIST
4585: LIST
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: LIST
4595: PPUSH
4596: CALL_OW 69
4600: PUSH
4601: LD_EXP 57
4605: DIFF
4606: PPUSH
4607: CALL_OW 1
4611: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4612: LD_INT 1
4614: PPUSH
4615: LD_INT 7
4617: PPUSH
4618: CALL_OW 383
// Friend := CreateHuman ;
4622: LD_ADDR_EXP 59
4626: PUSH
4627: CALL_OW 44
4631: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4632: LD_INT 14
4634: PPUSH
4635: LD_INT 3
4637: PPUSH
4638: LD_INT 1
4640: PPUSH
4641: LD_INT 29
4643: PPUSH
4644: LD_INT 100
4646: PPUSH
4647: CALL 69527 0 5
// powellBomb := CreateVehicle ;
4651: LD_ADDR_EXP 60
4655: PUSH
4656: CALL_OW 45
4660: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4661: LD_EXP 60
4665: PPUSH
4666: LD_INT 90
4668: PPUSH
4669: LD_INT 51
4671: PPUSH
4672: LD_INT 0
4674: PPUSH
4675: CALL_OW 48
// end ;
4679: LD_VAR 0 1
4683: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4684: LD_INT 0
4686: PPUSH
4687: PPUSH
4688: PPUSH
// if IsLive ( kozlov_fac ) then
4689: LD_INT 332
4691: PPUSH
4692: CALL_OW 300
4696: IFFALSE 4700
// exit ;
4698: GO 5267
// ComExitBuilding ( Kozlov ) ;
4700: LD_EXP 58
4704: PPUSH
4705: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4709: LD_EXP 58
4713: PPUSH
4714: CALL_OW 257
4718: PUSH
4719: LD_INT 2
4721: NONEQUAL
4722: IFFALSE 4757
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4724: LD_EXP 58
4728: PPUSH
4729: LD_INT 324
4731: PPUSH
4732: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4736: LD_EXP 58
4740: PPUSH
4741: LD_INT 2
4743: PPUSH
4744: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4748: LD_EXP 58
4752: PPUSH
4753: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4757: LD_EXP 58
4761: PPUSH
4762: LD_INT 2
4764: PPUSH
4765: LD_INT 93
4767: PPUSH
4768: LD_INT 32
4770: PPUSH
4771: LD_INT 3
4773: PPUSH
4774: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4778: LD_INT 35
4780: PPUSH
4781: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4785: LD_INT 22
4787: PUSH
4788: LD_INT 8
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: LD_INT 30
4797: PUSH
4798: LD_INT 3
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PUSH
4805: LD_INT 23
4807: PUSH
4808: LD_INT 3
4810: PUSH
4811: EMPTY
4812: LIST
4813: LIST
4814: PUSH
4815: LD_INT 57
4817: PUSH
4818: EMPTY
4819: LIST
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: LIST
4825: LIST
4826: PPUSH
4827: CALL_OW 69
4831: IFFALSE 4778
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4833: LD_ADDR_VAR 0 2
4837: PUSH
4838: LD_INT 22
4840: PUSH
4841: LD_INT 8
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 30
4850: PUSH
4851: LD_INT 3
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 23
4860: PUSH
4861: LD_INT 3
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 57
4870: PUSH
4871: EMPTY
4872: LIST
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: LIST
4878: LIST
4879: PPUSH
4880: CALL_OW 69
4884: PUSH
4885: LD_INT 1
4887: ARRAY
4888: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4889: LD_INT 22
4891: PUSH
4892: LD_INT 8
4894: PUSH
4895: EMPTY
4896: LIST
4897: LIST
4898: PUSH
4899: LD_INT 23
4901: PUSH
4902: LD_INT 3
4904: PUSH
4905: EMPTY
4906: LIST
4907: LIST
4908: PUSH
4909: LD_INT 30
4911: PUSH
4912: LD_INT 21
4914: PUSH
4915: EMPTY
4916: LIST
4917: LIST
4918: PUSH
4919: EMPTY
4920: LIST
4921: LIST
4922: LIST
4923: PPUSH
4924: CALL_OW 69
4928: NOT
4929: IFFALSE 5007
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
4931: LD_EXP 58
4935: PPUSH
4936: LD_INT 21
4938: PPUSH
4939: LD_INT 97
4941: PPUSH
4942: LD_INT 36
4944: PPUSH
4945: LD_INT 5
4947: PPUSH
4948: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4952: LD_INT 35
4954: PPUSH
4955: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
4959: LD_INT 22
4961: PUSH
4962: LD_INT 8
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: PUSH
4969: LD_INT 23
4971: PUSH
4972: LD_INT 3
4974: PUSH
4975: EMPTY
4976: LIST
4977: LIST
4978: PUSH
4979: LD_INT 30
4981: PUSH
4982: LD_INT 21
4984: PUSH
4985: EMPTY
4986: LIST
4987: LIST
4988: PUSH
4989: LD_INT 57
4991: PUSH
4992: EMPTY
4993: LIST
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: LIST
4999: LIST
5000: PPUSH
5001: CALL_OW 69
5005: IFFALSE 4952
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5007: LD_INT 22
5009: PUSH
5010: LD_INT 8
5012: PUSH
5013: EMPTY
5014: LIST
5015: LIST
5016: PUSH
5017: LD_INT 23
5019: PUSH
5020: LD_INT 3
5022: PUSH
5023: EMPTY
5024: LIST
5025: LIST
5026: PUSH
5027: LD_INT 30
5029: PUSH
5030: LD_INT 18
5032: PUSH
5033: EMPTY
5034: LIST
5035: LIST
5036: PUSH
5037: EMPTY
5038: LIST
5039: LIST
5040: LIST
5041: PPUSH
5042: CALL_OW 69
5046: NOT
5047: IFFALSE 5125
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5049: LD_EXP 58
5053: PPUSH
5054: LD_INT 18
5056: PPUSH
5057: LD_INT 89
5059: PPUSH
5060: LD_INT 32
5062: PPUSH
5063: LD_INT 1
5065: PPUSH
5066: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5070: LD_INT 35
5072: PPUSH
5073: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5077: LD_INT 22
5079: PUSH
5080: LD_INT 8
5082: PUSH
5083: EMPTY
5084: LIST
5085: LIST
5086: PUSH
5087: LD_INT 23
5089: PUSH
5090: LD_INT 3
5092: PUSH
5093: EMPTY
5094: LIST
5095: LIST
5096: PUSH
5097: LD_INT 30
5099: PUSH
5100: LD_INT 18
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 57
5109: PUSH
5110: EMPTY
5111: LIST
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: PPUSH
5119: CALL_OW 69
5123: IFFALSE 5070
// end ; lab := kozlov_lab ;
5125: LD_ADDR_VAR 0 3
5129: PUSH
5130: LD_INT 336
5132: ST_TO_ADDR
// if not lab then
5133: LD_VAR 0 3
5137: NOT
5138: IFFALSE 5142
// exit ;
5140: GO 5267
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5142: LD_EXP 58
5146: PPUSH
5147: LD_VAR 0 3
5151: PUSH
5152: LD_INT 1
5154: ARRAY
5155: PPUSH
5156: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5160: LD_EXP 58
5164: PPUSH
5165: LD_INT 4
5167: PPUSH
5168: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5172: LD_VAR 0 3
5176: PUSH
5177: LD_INT 1
5179: ARRAY
5180: PPUSH
5181: LD_INT 25
5183: PPUSH
5184: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5188: LD_INT 35
5190: PPUSH
5191: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5195: LD_INT 25
5197: PPUSH
5198: LD_INT 8
5200: PPUSH
5201: CALL_OW 321
5205: PUSH
5206: LD_INT 2
5208: EQUAL
5209: IFFALSE 5188
// ComExitBuilding ( Kozlov ) ;
5211: LD_EXP 58
5215: PPUSH
5216: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5220: LD_EXP 58
5224: PPUSH
5225: LD_VAR 0 2
5229: PPUSH
5230: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5234: LD_EXP 58
5238: PPUSH
5239: LD_INT 3
5241: PPUSH
5242: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5246: LD_VAR 0 2
5250: PPUSH
5251: LD_INT 23
5253: PPUSH
5254: LD_INT 3
5256: PPUSH
5257: LD_INT 1
5259: PPUSH
5260: LD_INT 48
5262: PPUSH
5263: CALL_OW 125
// end ;
5267: LD_VAR 0 1
5271: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5272: LD_EXP 22
5276: NOT
5277: PUSH
5278: LD_EXP 15
5282: PUSH
5283: LD_INT 6
5285: GREATEREQUAL
5286: AND
5287: IFFALSE 5368
5289: GO 5291
5291: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5292: LD_INT 3
5294: PPUSH
5295: LD_INT 3
5297: PPUSH
5298: CALL 57059 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5302: LD_INT 3
5304: PPUSH
5305: LD_INT 14
5307: PUSH
5308: LD_INT 1
5310: PUSH
5311: LD_INT 1
5313: PUSH
5314: LD_INT 28
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: LIST
5321: LIST
5322: PUSH
5323: LD_INT 14
5325: PUSH
5326: LD_INT 1
5328: PUSH
5329: LD_INT 1
5331: PUSH
5332: LD_INT 28
5334: PUSH
5335: EMPTY
5336: LIST
5337: LIST
5338: LIST
5339: LIST
5340: PUSH
5341: LD_INT 14
5343: PUSH
5344: LD_INT 1
5346: PUSH
5347: LD_INT 1
5349: PUSH
5350: LD_INT 28
5352: PUSH
5353: EMPTY
5354: LIST
5355: LIST
5356: LIST
5357: LIST
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: LIST
5363: PPUSH
5364: CALL 56922 0 2
// end ;
5368: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5369: LD_EXP 22
5373: NOT
5374: PUSH
5375: LD_EXP 15
5379: PUSH
5380: LD_INT 6
5382: GREATEREQUAL
5383: AND
5384: PUSH
5385: LD_INT 3
5387: PPUSH
5388: LD_INT 1
5390: PPUSH
5391: CALL 58277 0 2
5395: NOT
5396: AND
5397: IFFALSE 6237
5399: GO 5401
5401: DISABLE
5402: LD_INT 0
5404: PPUSH
5405: PPUSH
5406: PPUSH
// begin enable ;
5407: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5408: LD_INT 22
5410: PUSH
5411: LD_INT 8
5413: PUSH
5414: EMPTY
5415: LIST
5416: LIST
5417: PUSH
5418: LD_INT 23
5420: PUSH
5421: LD_INT 2
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: PUSH
5428: LD_INT 30
5430: PUSH
5431: LD_INT 3
5433: PUSH
5434: EMPTY
5435: LIST
5436: LIST
5437: PUSH
5438: EMPTY
5439: LIST
5440: LIST
5441: LIST
5442: PPUSH
5443: CALL_OW 69
5447: NOT
5448: IFFALSE 5452
// exit ;
5450: GO 6237
// if Prob ( 40 ) then
5452: LD_INT 40
5454: PPUSH
5455: CALL_OW 13
5459: IFFALSE 5586
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5461: LD_INT 3
5463: PPUSH
5464: LD_INT 14
5466: PUSH
5467: LD_INT 1
5469: PUSH
5470: LD_INT 2
5472: PUSH
5473: LD_INT 28
5475: PUSH
5476: EMPTY
5477: LIST
5478: LIST
5479: LIST
5480: LIST
5481: PUSH
5482: LD_INT 14
5484: PUSH
5485: LD_INT 1
5487: PUSH
5488: LD_INT 2
5490: PUSH
5491: LD_INT 28
5493: PUSH
5494: EMPTY
5495: LIST
5496: LIST
5497: LIST
5498: LIST
5499: PUSH
5500: LD_INT 14
5502: PUSH
5503: LD_INT 1
5505: PUSH
5506: LD_INT 2
5508: PUSH
5509: LD_INT 28
5511: PUSH
5512: EMPTY
5513: LIST
5514: LIST
5515: LIST
5516: LIST
5517: PUSH
5518: LD_INT 14
5520: PUSH
5521: LD_INT 1
5523: PUSH
5524: LD_INT 2
5526: PUSH
5527: LD_INT 28
5529: PUSH
5530: EMPTY
5531: LIST
5532: LIST
5533: LIST
5534: LIST
5535: PUSH
5536: LD_INT 14
5538: PUSH
5539: LD_INT 1
5541: PUSH
5542: LD_INT 2
5544: PUSH
5545: LD_INT 28
5547: PUSH
5548: EMPTY
5549: LIST
5550: LIST
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 14
5556: PUSH
5557: LD_INT 1
5559: PUSH
5560: LD_INT 2
5562: PUSH
5563: LD_INT 26
5565: PUSH
5566: EMPTY
5567: LIST
5568: LIST
5569: LIST
5570: LIST
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: LIST
5576: LIST
5577: LIST
5578: LIST
5579: PPUSH
5580: CALL 56922 0 2
// end else
5584: GO 5777
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5586: LD_INT 3
5588: PPUSH
5589: LD_INT 14
5591: PUSH
5592: LD_INT 1
5594: PUSH
5595: LD_INT 2
5597: PUSH
5598: LD_INT 27
5600: PUSH
5601: LD_INT 26
5603: PUSH
5604: LD_INT 26
5606: PUSH
5607: EMPTY
5608: LIST
5609: LIST
5610: LIST
5611: PUSH
5612: LD_OWVAR 67
5616: ARRAY
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: LIST
5622: LIST
5623: PUSH
5624: LD_INT 14
5626: PUSH
5627: LD_INT 1
5629: PUSH
5630: LD_INT 2
5632: PUSH
5633: LD_INT 27
5635: PUSH
5636: LD_INT 26
5638: PUSH
5639: LD_INT 26
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: LIST
5646: PUSH
5647: LD_OWVAR 67
5651: ARRAY
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: LIST
5657: LIST
5658: PUSH
5659: LD_INT 14
5661: PUSH
5662: LD_INT 1
5664: PUSH
5665: LD_INT 2
5667: PUSH
5668: LD_INT 26
5670: PUSH
5671: LD_INT 26
5673: PUSH
5674: LD_INT 29
5676: PUSH
5677: EMPTY
5678: LIST
5679: LIST
5680: LIST
5681: PUSH
5682: LD_OWVAR 67
5686: ARRAY
5687: PUSH
5688: EMPTY
5689: LIST
5690: LIST
5691: LIST
5692: LIST
5693: PUSH
5694: LD_INT 13
5696: PUSH
5697: LD_INT 1
5699: PUSH
5700: LD_INT 2
5702: PUSH
5703: LD_INT 26
5705: PUSH
5706: LD_INT 29
5708: PUSH
5709: LD_INT 29
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: LIST
5716: PUSH
5717: LD_OWVAR 67
5721: ARRAY
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: LIST
5727: LIST
5728: PUSH
5729: LD_INT 13
5731: PUSH
5732: LD_INT 1
5734: PUSH
5735: LD_INT 2
5737: PUSH
5738: LD_INT 29
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: LIST
5746: PUSH
5747: LD_INT 14
5749: PUSH
5750: LD_INT 1
5752: PUSH
5753: LD_INT 2
5755: PUSH
5756: LD_INT 26
5758: PUSH
5759: EMPTY
5760: LIST
5761: LIST
5762: LIST
5763: LIST
5764: PUSH
5765: EMPTY
5766: LIST
5767: LIST
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PPUSH
5773: CALL 56922 0 2
// end ; repeat wait ( 0 0$1 ) ;
5777: LD_INT 35
5779: PPUSH
5780: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5784: LD_INT 3
5786: PPUSH
5787: LD_INT 1
5789: PPUSH
5790: CALL 58277 0 2
5794: PUSH
5795: LD_INT 6
5797: GREATEREQUAL
5798: IFFALSE 5777
// wait ( 0 0$30 ) ;
5800: LD_INT 1050
5802: PPUSH
5803: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5807: LD_ADDR_VAR 0 2
5811: PUSH
5812: LD_INT 3
5814: PPUSH
5815: LD_INT 1
5817: PPUSH
5818: CALL 58277 0 2
5822: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5823: LD_ADDR_EXP 118
5827: PUSH
5828: LD_EXP 118
5832: PPUSH
5833: LD_INT 3
5835: PPUSH
5836: LD_EXP 118
5840: PUSH
5841: LD_INT 3
5843: ARRAY
5844: PUSH
5845: LD_VAR 0 2
5849: DIFF
5850: PPUSH
5851: CALL_OW 1
5855: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5856: LD_ADDR_VAR 0 3
5860: PUSH
5861: LD_INT 0
5863: PPUSH
5864: LD_INT 2
5866: PPUSH
5867: CALL_OW 12
5871: ST_TO_ADDR
// if target then
5872: LD_VAR 0 3
5876: IFFALSE 6004
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5878: LD_ADDR_VAR 0 2
5882: PUSH
5883: LD_VAR 0 2
5887: PPUSH
5888: LD_INT 24
5890: PUSH
5891: LD_INT 250
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: PPUSH
5898: CALL_OW 72
5902: ST_TO_ADDR
// for i in tmp do
5903: LD_ADDR_VAR 0 1
5907: PUSH
5908: LD_VAR 0 2
5912: PUSH
5913: FOR_IN
5914: IFFALSE 5954
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
5916: LD_VAR 0 1
5920: PPUSH
5921: LD_INT 89
5923: PPUSH
5924: LD_INT 71
5926: PPUSH
5927: CALL_OW 297
5931: PUSH
5932: LD_INT 9
5934: GREATER
5935: IFFALSE 5952
// ComMoveXY ( i , 89 , 71 ) ;
5937: LD_VAR 0 1
5941: PPUSH
5942: LD_INT 89
5944: PPUSH
5945: LD_INT 71
5947: PPUSH
5948: CALL_OW 111
5952: GO 5913
5954: POP
5955: POP
// wait ( 0 0$1 ) ;
5956: LD_INT 35
5958: PPUSH
5959: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
5963: LD_VAR 0 2
5967: PPUSH
5968: LD_INT 92
5970: PUSH
5971: LD_INT 89
5973: PUSH
5974: LD_INT 71
5976: PUSH
5977: LD_INT 9
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: LIST
5984: LIST
5985: PPUSH
5986: CALL_OW 72
5990: PUSH
5991: LD_VAR 0 2
5995: PUSH
5996: LD_INT 1
5998: MINUS
5999: GREATEREQUAL
6000: IFFALSE 5878
// end else
6002: GO 6128
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6004: LD_ADDR_VAR 0 2
6008: PUSH
6009: LD_VAR 0 2
6013: PPUSH
6014: LD_INT 24
6016: PUSH
6017: LD_INT 250
6019: PUSH
6020: EMPTY
6021: LIST
6022: LIST
6023: PPUSH
6024: CALL_OW 72
6028: ST_TO_ADDR
// for i in tmp do
6029: LD_ADDR_VAR 0 1
6033: PUSH
6034: LD_VAR 0 2
6038: PUSH
6039: FOR_IN
6040: IFFALSE 6080
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6042: LD_VAR 0 1
6046: PPUSH
6047: LD_INT 125
6049: PPUSH
6050: LD_INT 129
6052: PPUSH
6053: CALL_OW 297
6057: PUSH
6058: LD_INT 9
6060: GREATER
6061: IFFALSE 6078
// ComMoveXY ( i , 125 , 129 ) ;
6063: LD_VAR 0 1
6067: PPUSH
6068: LD_INT 125
6070: PPUSH
6071: LD_INT 129
6073: PPUSH
6074: CALL_OW 111
6078: GO 6039
6080: POP
6081: POP
// wait ( 0 0$1 ) ;
6082: LD_INT 35
6084: PPUSH
6085: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6089: LD_VAR 0 2
6093: PPUSH
6094: LD_INT 92
6096: PUSH
6097: LD_INT 125
6099: PUSH
6100: LD_INT 129
6102: PUSH
6103: LD_INT 9
6105: PUSH
6106: EMPTY
6107: LIST
6108: LIST
6109: LIST
6110: LIST
6111: PPUSH
6112: CALL_OW 72
6116: PUSH
6117: LD_VAR 0 2
6121: PUSH
6122: LD_INT 1
6124: MINUS
6125: GREATEREQUAL
6126: IFFALSE 6004
// end ; repeat wait ( 0 0$1 ) ;
6128: LD_INT 35
6130: PPUSH
6131: CALL_OW 67
// for i in tmp do
6135: LD_ADDR_VAR 0 1
6139: PUSH
6140: LD_VAR 0 2
6144: PUSH
6145: FOR_IN
6146: IFFALSE 6228
// begin if GetLives ( i ) > 251 then
6148: LD_VAR 0 1
6152: PPUSH
6153: CALL_OW 256
6157: PUSH
6158: LD_INT 251
6160: GREATER
6161: IFFALSE 6199
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6163: LD_VAR 0 1
6167: PPUSH
6168: LD_INT 81
6170: PUSH
6171: LD_INT 8
6173: PUSH
6174: EMPTY
6175: LIST
6176: LIST
6177: PPUSH
6178: CALL_OW 69
6182: PPUSH
6183: LD_VAR 0 1
6187: PPUSH
6188: CALL_OW 74
6192: PPUSH
6193: CALL_OW 115
6197: GO 6226
// if IsDead ( i ) then
6199: LD_VAR 0 1
6203: PPUSH
6204: CALL_OW 301
6208: IFFALSE 6226
// tmp := tmp diff i ;
6210: LD_ADDR_VAR 0 2
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_VAR 0 1
6224: DIFF
6225: ST_TO_ADDR
// end ;
6226: GO 6145
6228: POP
6229: POP
// until not tmp ;
6230: LD_VAR 0 2
6234: NOT
6235: IFFALSE 6128
// end ;
6237: PPOPN 3
6239: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6240: LD_EXP 22
6244: NOT
6245: PUSH
6246: LD_EXP 15
6250: PUSH
6251: LD_INT 6
6253: GREATEREQUAL
6254: AND
6255: PUSH
6256: LD_OWVAR 67
6260: PUSH
6261: LD_INT 1
6263: GREATER
6264: AND
6265: IFFALSE 6782
6267: GO 6269
6269: DISABLE
6270: LD_INT 0
6272: PPUSH
6273: PPUSH
6274: PPUSH
// begin enable ;
6275: ENABLE
// tmp := [ ] ;
6276: LD_ADDR_VAR 0 3
6280: PUSH
6281: EMPTY
6282: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6283: LD_ADDR_VAR 0 1
6287: PUSH
6288: DOUBLE
6289: LD_INT 1
6291: DEC
6292: ST_TO_ADDR
6293: LD_INT 4
6295: PUSH
6296: LD_INT 6
6298: PUSH
6299: LD_INT 7
6301: PUSH
6302: EMPTY
6303: LIST
6304: LIST
6305: LIST
6306: PUSH
6307: LD_OWVAR 67
6311: ARRAY
6312: PUSH
6313: FOR_TO
6314: IFFALSE 6474
// begin uc_side := 8 ;
6316: LD_ADDR_OWVAR 20
6320: PUSH
6321: LD_INT 8
6323: ST_TO_ADDR
// uc_nation := 2 ;
6324: LD_ADDR_OWVAR 21
6328: PUSH
6329: LD_INT 2
6331: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6332: LD_INT 13
6334: PUSH
6335: LD_INT 14
6337: PUSH
6338: EMPTY
6339: LIST
6340: LIST
6341: PUSH
6342: LD_INT 1
6344: PPUSH
6345: LD_INT 2
6347: PPUSH
6348: CALL_OW 12
6352: ARRAY
6353: PPUSH
6354: LD_INT 1
6356: PPUSH
6357: LD_INT 5
6359: PPUSH
6360: LD_INT 27
6362: PUSH
6363: LD_INT 28
6365: PUSH
6366: LD_INT 26
6368: PUSH
6369: LD_INT 25
6371: PUSH
6372: EMPTY
6373: LIST
6374: LIST
6375: LIST
6376: LIST
6377: PUSH
6378: LD_INT 1
6380: PPUSH
6381: LD_INT 4
6383: PPUSH
6384: CALL_OW 12
6388: ARRAY
6389: PPUSH
6390: LD_INT 88
6392: PPUSH
6393: CALL 69527 0 5
// un := CreateVehicle ;
6397: LD_ADDR_VAR 0 2
6401: PUSH
6402: CALL_OW 45
6406: ST_TO_ADDR
// tmp := tmp ^ un ;
6407: LD_ADDR_VAR 0 3
6411: PUSH
6412: LD_VAR 0 3
6416: PUSH
6417: LD_VAR 0 2
6421: ADD
6422: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6423: LD_VAR 0 2
6427: PPUSH
6428: LD_INT 3
6430: PPUSH
6431: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6435: LD_VAR 0 2
6439: PPUSH
6440: LD_INT 30
6442: PPUSH
6443: LD_INT 0
6445: PPUSH
6446: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6450: LD_VAR 0 2
6454: PPUSH
6455: LD_INT 16
6457: PPUSH
6458: LD_INT 11
6460: PPUSH
6461: CALL_OW 111
// wait ( 0 0$2 ) ;
6465: LD_INT 70
6467: PPUSH
6468: CALL_OW 67
// end ;
6472: GO 6313
6474: POP
6475: POP
// for i = 1 to Difficulty do
6476: LD_ADDR_VAR 0 1
6480: PUSH
6481: DOUBLE
6482: LD_INT 1
6484: DEC
6485: ST_TO_ADDR
6486: LD_OWVAR 67
6490: PUSH
6491: FOR_TO
6492: IFFALSE 6617
// begin uc_side := 8 ;
6494: LD_ADDR_OWVAR 20
6498: PUSH
6499: LD_INT 8
6501: ST_TO_ADDR
// uc_nation := 2 ;
6502: LD_ADDR_OWVAR 21
6506: PUSH
6507: LD_INT 2
6509: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6510: LD_INT 0
6512: PPUSH
6513: LD_INT 8
6515: PPUSH
6516: LD_INT 8
6518: PUSH
6519: LD_INT 8
6521: PUSH
6522: LD_INT 9
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: LIST
6529: PUSH
6530: LD_OWVAR 67
6534: ARRAY
6535: PPUSH
6536: CALL_OW 380
// un := CreateHuman ;
6540: LD_ADDR_VAR 0 2
6544: PUSH
6545: CALL_OW 44
6549: ST_TO_ADDR
// tmp := tmp ^ un ;
6550: LD_ADDR_VAR 0 3
6554: PUSH
6555: LD_VAR 0 3
6559: PUSH
6560: LD_VAR 0 2
6564: ADD
6565: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6566: LD_VAR 0 2
6570: PPUSH
6571: LD_INT 3
6573: PPUSH
6574: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6578: LD_VAR 0 2
6582: PPUSH
6583: LD_INT 30
6585: PPUSH
6586: LD_INT 0
6588: PPUSH
6589: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6593: LD_VAR 0 2
6597: PPUSH
6598: LD_INT 16
6600: PPUSH
6601: LD_INT 11
6603: PPUSH
6604: CALL_OW 111
// wait ( 0 0$2 ) ;
6608: LD_INT 70
6610: PPUSH
6611: CALL_OW 67
// end ;
6615: GO 6491
6617: POP
6618: POP
// repeat wait ( 0 0$1 ) ;
6619: LD_INT 35
6621: PPUSH
6622: CALL_OW 67
// for i in tmp do
6626: LD_ADDR_VAR 0 1
6630: PUSH
6631: LD_VAR 0 3
6635: PUSH
6636: FOR_IN
6637: IFFALSE 6773
// begin if GetLives ( i ) > 250 then
6639: LD_VAR 0 1
6643: PPUSH
6644: CALL_OW 256
6648: PUSH
6649: LD_INT 250
6651: GREATER
6652: IFFALSE 6744
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6654: LD_INT 81
6656: PUSH
6657: LD_INT 8
6659: PUSH
6660: EMPTY
6661: LIST
6662: LIST
6663: PUSH
6664: LD_INT 91
6666: PUSH
6667: LD_VAR 0 1
6671: PUSH
6672: LD_INT 10
6674: PUSH
6675: EMPTY
6676: LIST
6677: LIST
6678: LIST
6679: PUSH
6680: EMPTY
6681: LIST
6682: LIST
6683: PPUSH
6684: CALL_OW 69
6688: NOT
6689: IFFALSE 6708
// ComAgressiveMove ( i , 67 , 110 ) else
6691: LD_VAR 0 1
6695: PPUSH
6696: LD_INT 67
6698: PPUSH
6699: LD_INT 110
6701: PPUSH
6702: CALL_OW 114
6706: GO 6742
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6708: LD_VAR 0 1
6712: PPUSH
6713: LD_INT 81
6715: PUSH
6716: LD_INT 8
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PPUSH
6723: CALL_OW 69
6727: PPUSH
6728: LD_VAR 0 1
6732: PPUSH
6733: CALL_OW 74
6737: PPUSH
6738: CALL_OW 115
// end else
6742: GO 6771
// if IsDead ( i ) then
6744: LD_VAR 0 1
6748: PPUSH
6749: CALL_OW 301
6753: IFFALSE 6771
// tmp := tmp diff i ;
6755: LD_ADDR_VAR 0 3
6759: PUSH
6760: LD_VAR 0 3
6764: PUSH
6765: LD_VAR 0 1
6769: DIFF
6770: ST_TO_ADDR
// end ;
6771: GO 6636
6773: POP
6774: POP
// until not tmp ;
6775: LD_VAR 0 3
6779: NOT
6780: IFFALSE 6619
// end ; end_of_file
6782: PPOPN 3
6784: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6785: LD_INT 0
6787: PPUSH
6788: PPUSH
6789: PPUSH
6790: PPUSH
6791: PPUSH
6792: PPUSH
6793: PPUSH
6794: PPUSH
6795: PPUSH
// side := 3 ;
6796: LD_ADDR_VAR 0 6
6800: PUSH
6801: LD_INT 3
6803: ST_TO_ADDR
// uc_side := side ;
6804: LD_ADDR_OWVAR 20
6808: PUSH
6809: LD_VAR 0 6
6813: ST_TO_ADDR
// uc_nation := 3 ;
6814: LD_ADDR_OWVAR 21
6818: PUSH
6819: LD_INT 3
6821: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6822: LD_ADDR_VAR 0 2
6826: PUSH
6827: LD_INT 22
6829: PUSH
6830: LD_VAR 0 6
6834: PUSH
6835: EMPTY
6836: LIST
6837: LIST
6838: PUSH
6839: LD_INT 21
6841: PUSH
6842: LD_INT 3
6844: PUSH
6845: EMPTY
6846: LIST
6847: LIST
6848: PUSH
6849: EMPTY
6850: LIST
6851: LIST
6852: PPUSH
6853: CALL_OW 69
6857: PUSH
6858: FOR_IN
6859: IFFALSE 6875
// SetBLevel ( i , 10 ) ;
6861: LD_VAR 0 2
6865: PPUSH
6866: LD_INT 10
6868: PPUSH
6869: CALL_OW 241
6873: GO 6858
6875: POP
6876: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6877: LD_ADDR_VAR 0 9
6881: PUSH
6882: LD_INT 22
6884: PUSH
6885: LD_VAR 0 6
6889: PUSH
6890: EMPTY
6891: LIST
6892: LIST
6893: PUSH
6894: LD_INT 30
6896: PUSH
6897: LD_INT 34
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PUSH
6904: EMPTY
6905: LIST
6906: LIST
6907: PPUSH
6908: CALL_OW 69
6912: ST_TO_ADDR
// if teleport then
6913: LD_VAR 0 9
6917: IFFALSE 6938
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
6919: LD_VAR 0 9
6923: PUSH
6924: LD_INT 1
6926: ARRAY
6927: PPUSH
6928: LD_INT 123
6930: PPUSH
6931: LD_INT 122
6933: PPUSH
6934: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
6938: LD_ADDR_EXP 61
6942: PUSH
6943: LD_STRING Platonov
6945: PPUSH
6946: CALL_OW 25
6950: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
6951: LD_ADDR_EXP 62
6955: PUSH
6956: LD_STRING Kovalyuk
6958: PPUSH
6959: CALL_OW 25
6963: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
6964: LD_ADDR_EXP 64
6968: PUSH
6969: LD_STRING Yakotich
6971: PPUSH
6972: CALL_OW 25
6976: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
6977: LD_ADDR_EXP 63
6981: PUSH
6982: LD_STRING Bystrov
6984: PPUSH
6985: CALL_OW 25
6989: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
6990: LD_ADDR_EXP 65
6994: PUSH
6995: LD_STRING Gleb
6997: PPUSH
6998: CALL_OW 25
7002: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7003: LD_STRING 03_Cornel
7005: PPUSH
7006: CALL_OW 28
7010: IFFALSE 7058
// begin Bierezov := NewCharacter ( Mikhail ) ;
7012: LD_ADDR_EXP 66
7016: PUSH
7017: LD_STRING Mikhail
7019: PPUSH
7020: CALL_OW 25
7024: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7025: LD_EXP 66
7029: PPUSH
7030: LD_INT 197
7032: PPUSH
7033: LD_INT 111
7035: PPUSH
7036: LD_INT 9
7038: PPUSH
7039: LD_INT 0
7041: PPUSH
7042: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7046: LD_EXP 66
7050: PPUSH
7051: LD_INT 3
7053: PPUSH
7054: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7058: LD_EXP 61
7062: PPUSH
7063: LD_INT 126
7065: PPUSH
7066: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7070: LD_EXP 62
7074: PPUSH
7075: LD_INT 134
7077: PPUSH
7078: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7082: LD_EXP 64
7086: PPUSH
7087: LD_INT 197
7089: PPUSH
7090: LD_INT 111
7092: PPUSH
7093: LD_INT 9
7095: PPUSH
7096: LD_INT 0
7098: PPUSH
7099: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7103: LD_EXP 63
7107: PPUSH
7108: LD_INT 197
7110: PPUSH
7111: LD_INT 111
7113: PPUSH
7114: LD_INT 9
7116: PPUSH
7117: LD_INT 0
7119: PPUSH
7120: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7124: LD_EXP 65
7128: PPUSH
7129: LD_INT 197
7131: PPUSH
7132: LD_INT 111
7134: PPUSH
7135: LD_INT 9
7137: PPUSH
7138: LD_INT 0
7140: PPUSH
7141: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 99999 , 1000 , 300 ] , [ 12 , 8 , 13 , 8 ] ) ;
7145: LD_ADDR_VAR 0 5
7149: PUSH
7150: LD_INT 126
7152: PPUSH
7153: LD_INT 4
7155: PPUSH
7156: LD_STRING zhukov
7158: PPUSH
7159: LD_INT 9
7161: PUSH
7162: LD_INT 10
7164: PUSH
7165: LD_INT 10
7167: PUSH
7168: EMPTY
7169: LIST
7170: LIST
7171: LIST
7172: PUSH
7173: LD_OWVAR 67
7177: ARRAY
7178: PPUSH
7179: LD_INT 99999
7181: PUSH
7182: LD_INT 1000
7184: PUSH
7185: LD_INT 300
7187: PUSH
7188: EMPTY
7189: LIST
7190: LIST
7191: LIST
7192: PPUSH
7193: LD_INT 12
7195: PUSH
7196: LD_INT 8
7198: PUSH
7199: LD_INT 13
7201: PUSH
7202: LD_INT 8
7204: PUSH
7205: EMPTY
7206: LIST
7207: LIST
7208: LIST
7209: LIST
7210: PPUSH
7211: CALL 72936 0 6
7215: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7216: LD_ADDR_VAR 0 4
7220: PUSH
7221: LD_INT 267
7223: PPUSH
7224: CALL_OW 274
7228: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7229: LD_VAR 0 4
7233: PPUSH
7234: LD_INT 1
7236: PPUSH
7237: LD_INT 5000
7239: PPUSH
7240: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7244: LD_VAR 0 4
7248: PPUSH
7249: LD_INT 2
7251: PPUSH
7252: LD_INT 200
7254: PPUSH
7255: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7259: LD_VAR 0 4
7263: PPUSH
7264: LD_INT 3
7266: PPUSH
7267: LD_INT 200
7269: PPUSH
7270: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7274: LD_ADDR_EXP 99
7278: PUSH
7279: LD_EXP 99
7283: PPUSH
7284: LD_INT 2
7286: PPUSH
7287: LD_VAR 0 5
7291: PUSH
7292: LD_INT 22
7294: PUSH
7295: LD_VAR 0 6
7299: PUSH
7300: EMPTY
7301: LIST
7302: LIST
7303: PUSH
7304: LD_INT 3
7306: PUSH
7307: LD_INT 21
7309: PUSH
7310: LD_INT 2
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PUSH
7317: EMPTY
7318: LIST
7319: LIST
7320: PUSH
7321: EMPTY
7322: LIST
7323: LIST
7324: PPUSH
7325: CALL_OW 69
7329: UNION
7330: PUSH
7331: LD_EXP 61
7335: DIFF
7336: PPUSH
7337: CALL_OW 1
7341: ST_TO_ADDR
// behemoths := [ ] ;
7342: LD_ADDR_EXP 69
7346: PUSH
7347: EMPTY
7348: ST_TO_ADDR
// behemothBuilders := [ ] ;
7349: LD_ADDR_EXP 70
7353: PUSH
7354: EMPTY
7355: ST_TO_ADDR
// if Kovalyuk then
7356: LD_EXP 62
7360: IFFALSE 7382
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7362: LD_ADDR_EXP 70
7366: PUSH
7367: LD_EXP 70
7371: PPUSH
7372: LD_EXP 62
7376: PPUSH
7377: CALL 105272 0 2
7381: ST_TO_ADDR
// j := 3 ;
7382: LD_ADDR_VAR 0 3
7386: PUSH
7387: LD_INT 3
7389: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7390: LD_ADDR_VAR 0 2
7394: PUSH
7395: LD_INT 22
7397: PUSH
7398: LD_INT 3
7400: PUSH
7401: EMPTY
7402: LIST
7403: LIST
7404: PUSH
7405: LD_INT 25
7407: PUSH
7408: LD_INT 3
7410: PUSH
7411: EMPTY
7412: LIST
7413: LIST
7414: PUSH
7415: EMPTY
7416: LIST
7417: LIST
7418: PPUSH
7419: CALL_OW 69
7423: PUSH
7424: LD_EXP 62
7428: DIFF
7429: PUSH
7430: FOR_IN
7431: IFFALSE 7481
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7433: LD_ADDR_EXP 70
7437: PUSH
7438: LD_EXP 70
7442: PPUSH
7443: LD_VAR 0 2
7447: PPUSH
7448: CALL 105272 0 2
7452: ST_TO_ADDR
// j := j - 1 ;
7453: LD_ADDR_VAR 0 3
7457: PUSH
7458: LD_VAR 0 3
7462: PUSH
7463: LD_INT 1
7465: MINUS
7466: ST_TO_ADDR
// if j = 0 then
7467: LD_VAR 0 3
7471: PUSH
7472: LD_INT 0
7474: EQUAL
7475: IFFALSE 7479
// break ;
7477: GO 7481
// end ;
7479: GO 7430
7481: POP
7482: POP
// end ;
7483: LD_VAR 0 1
7487: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7488: LD_INT 0
7490: PPUSH
7491: PPUSH
7492: PPUSH
7493: PPUSH
7494: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7495: LD_ADDR_VAR 0 4
7499: PUSH
7500: LD_INT 209
7502: PUSH
7503: LD_INT 149
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: PUSH
7510: LD_INT 219
7512: PUSH
7513: LD_INT 154
7515: PUSH
7516: EMPTY
7517: LIST
7518: LIST
7519: PUSH
7520: LD_INT 223
7522: PUSH
7523: LD_INT 149
7525: PUSH
7526: EMPTY
7527: LIST
7528: LIST
7529: PUSH
7530: LD_INT 232
7532: PUSH
7533: LD_INT 155
7535: PUSH
7536: EMPTY
7537: LIST
7538: LIST
7539: PUSH
7540: EMPTY
7541: LIST
7542: LIST
7543: LIST
7544: LIST
7545: ST_TO_ADDR
// if not behemothBuilders then
7546: LD_EXP 70
7550: NOT
7551: IFFALSE 7555
// exit ;
7553: GO 7659
// j := 1 ;
7555: LD_ADDR_VAR 0 3
7559: PUSH
7560: LD_INT 1
7562: ST_TO_ADDR
// for i in behemothBuilders do
7563: LD_ADDR_VAR 0 2
7567: PUSH
7568: LD_EXP 70
7572: PUSH
7573: FOR_IN
7574: IFFALSE 7657
// begin if IsInUnit ( i ) then
7576: LD_VAR 0 2
7580: PPUSH
7581: CALL_OW 310
7585: IFFALSE 7596
// ComExitBuilding ( i ) ;
7587: LD_VAR 0 2
7591: PPUSH
7592: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7596: LD_VAR 0 2
7600: PPUSH
7601: LD_INT 37
7603: PPUSH
7604: LD_VAR 0 4
7608: PUSH
7609: LD_VAR 0 3
7613: ARRAY
7614: PUSH
7615: LD_INT 1
7617: ARRAY
7618: PPUSH
7619: LD_VAR 0 4
7623: PUSH
7624: LD_VAR 0 3
7628: ARRAY
7629: PUSH
7630: LD_INT 2
7632: ARRAY
7633: PPUSH
7634: LD_INT 0
7636: PPUSH
7637: CALL_OW 230
// j := j + 1 ;
7641: LD_ADDR_VAR 0 3
7645: PUSH
7646: LD_VAR 0 3
7650: PUSH
7651: LD_INT 1
7653: PLUS
7654: ST_TO_ADDR
// end ;
7655: GO 7573
7657: POP
7658: POP
// end ;
7659: LD_VAR 0 1
7663: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7664: LD_INT 24
7666: PPUSH
7667: LD_INT 30
7669: PUSH
7670: LD_INT 37
7672: PUSH
7673: EMPTY
7674: LIST
7675: LIST
7676: PPUSH
7677: CALL_OW 70
7681: IFFALSE 7694
7683: GO 7685
7685: DISABLE
// behemothUnderConstruct := true ;
7686: LD_ADDR_EXP 26
7690: PUSH
7691: LD_INT 1
7693: ST_TO_ADDR
7694: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7695: LD_INT 3
7697: PPUSH
7698: CALL 105320 0 1
7702: PUSH
7703: LD_INT 22
7705: PUSH
7706: LD_INT 3
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: PUSH
7713: LD_INT 30
7715: PUSH
7716: LD_INT 37
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: EMPTY
7724: LIST
7725: LIST
7726: PPUSH
7727: CALL_OW 69
7731: NOT
7732: AND
7733: IFFALSE 7919
7735: GO 7737
7737: DISABLE
7738: LD_INT 0
7740: PPUSH
7741: PPUSH
// begin enable ;
7742: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7743: LD_ADDR_VAR 0 2
7747: PUSH
7748: LD_INT 3
7750: PPUSH
7751: CALL 105320 0 1
7755: ST_TO_ADDR
// for i in tmp do
7756: LD_ADDR_VAR 0 1
7760: PUSH
7761: LD_VAR 0 2
7765: PUSH
7766: FOR_IN
7767: IFFALSE 7917
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7769: LD_VAR 0 1
7773: PPUSH
7774: LD_INT 9
7776: PPUSH
7777: CALL_OW 308
7781: PUSH
7782: LD_VAR 0 1
7786: PPUSH
7787: CALL_OW 110
7791: PUSH
7792: LD_INT 2
7794: EQUAL
7795: NOT
7796: AND
7797: IFFALSE 7811
// SetTag ( i , 2 ) ;
7799: LD_VAR 0 1
7803: PPUSH
7804: LD_INT 2
7806: PPUSH
7807: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7811: LD_INT 81
7813: PUSH
7814: LD_INT 3
7816: PUSH
7817: EMPTY
7818: LIST
7819: LIST
7820: PUSH
7821: LD_INT 91
7823: PUSH
7824: LD_VAR 0 1
7828: PUSH
7829: LD_INT 12
7831: PUSH
7832: EMPTY
7833: LIST
7834: LIST
7835: LIST
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 69
7845: NOT
7846: PUSH
7847: LD_VAR 0 1
7851: PPUSH
7852: CALL_OW 110
7856: PUSH
7857: LD_INT 2
7859: EQUAL
7860: NOT
7861: AND
7862: IFFALSE 7881
// ComAgressiveMove ( i , 64 , 93 ) else
7864: LD_VAR 0 1
7868: PPUSH
7869: LD_INT 64
7871: PPUSH
7872: LD_INT 93
7874: PPUSH
7875: CALL_OW 114
7879: GO 7915
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7881: LD_VAR 0 1
7885: PPUSH
7886: LD_INT 81
7888: PUSH
7889: LD_INT 3
7891: PUSH
7892: EMPTY
7893: LIST
7894: LIST
7895: PPUSH
7896: CALL_OW 69
7900: PPUSH
7901: LD_VAR 0 1
7905: PPUSH
7906: CALL_OW 74
7910: PPUSH
7911: CALL_OW 115
// end ;
7915: GO 7766
7917: POP
7918: POP
// end ;
7919: PPOPN 2
7921: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
7922: LD_INT 0
7924: PPUSH
7925: PPUSH
7926: PPUSH
// result := [ ] ;
7927: LD_ADDR_VAR 0 2
7931: PUSH
7932: EMPTY
7933: ST_TO_ADDR
// uc_side := 6 ;
7934: LD_ADDR_OWVAR 20
7938: PUSH
7939: LD_INT 6
7941: ST_TO_ADDR
// uc_nation := 3 ;
7942: LD_ADDR_OWVAR 21
7946: PUSH
7947: LD_INT 3
7949: ST_TO_ADDR
// case strength of 1 :
7950: LD_VAR 0 1
7954: PUSH
7955: LD_INT 1
7957: DOUBLE
7958: EQUAL
7959: IFTRUE 7963
7961: GO 8101
7963: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
7964: LD_ADDR_VAR 0 3
7968: PUSH
7969: DOUBLE
7970: LD_INT 1
7972: DEC
7973: ST_TO_ADDR
7974: LD_INT 4
7976: PUSH
7977: LD_INT 5
7979: PUSH
7980: LD_INT 6
7982: PUSH
7983: EMPTY
7984: LIST
7985: LIST
7986: LIST
7987: PUSH
7988: LD_OWVAR 67
7992: ARRAY
7993: PUSH
7994: FOR_TO
7995: IFFALSE 8097
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
7997: LD_INT 22
7999: PUSH
8000: LD_INT 24
8002: PUSH
8003: EMPTY
8004: LIST
8005: LIST
8006: PUSH
8007: LD_VAR 0 3
8011: PUSH
8012: LD_INT 2
8014: MOD
8015: PUSH
8016: LD_INT 1
8018: PLUS
8019: ARRAY
8020: PPUSH
8021: LD_INT 1
8023: PUSH
8024: LD_INT 3
8026: PUSH
8027: EMPTY
8028: LIST
8029: LIST
8030: PUSH
8031: LD_INT 1
8033: PPUSH
8034: LD_INT 2
8036: PPUSH
8037: CALL_OW 12
8041: ARRAY
8042: PPUSH
8043: LD_INT 3
8045: PPUSH
8046: LD_INT 43
8048: PUSH
8049: LD_INT 44
8051: PUSH
8052: LD_INT 45
8054: PUSH
8055: EMPTY
8056: LIST
8057: LIST
8058: LIST
8059: PUSH
8060: LD_INT 1
8062: PPUSH
8063: LD_INT 3
8065: PPUSH
8066: CALL_OW 12
8070: ARRAY
8071: PPUSH
8072: LD_INT 80
8074: PPUSH
8075: CALL 69527 0 5
// result := result union CreateVehicle ;
8079: LD_ADDR_VAR 0 2
8083: PUSH
8084: LD_VAR 0 2
8088: PUSH
8089: CALL_OW 45
8093: UNION
8094: ST_TO_ADDR
// end ;
8095: GO 7994
8097: POP
8098: POP
// end ; 2 :
8099: GO 9045
8101: LD_INT 2
8103: DOUBLE
8104: EQUAL
8105: IFTRUE 8109
8107: GO 8265
8109: POP
// begin for i = 1 to [ 6 , 6 , 7 ] [ Difficulty ] do
8110: LD_ADDR_VAR 0 3
8114: PUSH
8115: DOUBLE
8116: LD_INT 1
8118: DEC
8119: ST_TO_ADDR
8120: LD_INT 6
8122: PUSH
8123: LD_INT 6
8125: PUSH
8126: LD_INT 7
8128: PUSH
8129: EMPTY
8130: LIST
8131: LIST
8132: LIST
8133: PUSH
8134: LD_OWVAR 67
8138: ARRAY
8139: PUSH
8140: FOR_TO
8141: IFFALSE 8261
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8143: LD_INT 22
8145: PUSH
8146: LD_INT 24
8148: PUSH
8149: LD_INT 24
8151: PUSH
8152: EMPTY
8153: LIST
8154: LIST
8155: LIST
8156: PUSH
8157: LD_VAR 0 3
8161: PUSH
8162: LD_INT 3
8164: MOD
8165: PUSH
8166: LD_INT 1
8168: PLUS
8169: ARRAY
8170: PPUSH
8171: LD_INT 1
8173: PUSH
8174: LD_INT 3
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 1
8183: PPUSH
8184: LD_INT 2
8186: PPUSH
8187: CALL_OW 12
8191: ARRAY
8192: PPUSH
8193: LD_INT 3
8195: PPUSH
8196: LD_INT 43
8198: PUSH
8199: LD_INT 44
8201: PUSH
8202: LD_INT 45
8204: PUSH
8205: LD_INT 44
8207: PUSH
8208: LD_INT 46
8210: PUSH
8211: LD_INT 46
8213: PUSH
8214: EMPTY
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: LIST
8221: PUSH
8222: LD_VAR 0 3
8226: PUSH
8227: LD_INT 6
8229: MOD
8230: PUSH
8231: LD_INT 1
8233: PLUS
8234: ARRAY
8235: PPUSH
8236: LD_INT 80
8238: PPUSH
8239: CALL 69527 0 5
// result := result union CreateVehicle ;
8243: LD_ADDR_VAR 0 2
8247: PUSH
8248: LD_VAR 0 2
8252: PUSH
8253: CALL_OW 45
8257: UNION
8258: ST_TO_ADDR
// end ;
8259: GO 8140
8261: POP
8262: POP
// end ; 3 :
8263: GO 9045
8265: LD_INT 3
8267: DOUBLE
8268: EQUAL
8269: IFTRUE 8273
8271: GO 8429
8273: POP
// begin for i = 1 to [ 6 , 7 , 8 ] [ Difficulty ] do
8274: LD_ADDR_VAR 0 3
8278: PUSH
8279: DOUBLE
8280: LD_INT 1
8282: DEC
8283: ST_TO_ADDR
8284: LD_INT 6
8286: PUSH
8287: LD_INT 7
8289: PUSH
8290: LD_INT 8
8292: PUSH
8293: EMPTY
8294: LIST
8295: LIST
8296: LIST
8297: PUSH
8298: LD_OWVAR 67
8302: ARRAY
8303: PUSH
8304: FOR_TO
8305: IFFALSE 8425
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8307: LD_INT 22
8309: PUSH
8310: LD_INT 24
8312: PUSH
8313: LD_INT 24
8315: PUSH
8316: EMPTY
8317: LIST
8318: LIST
8319: LIST
8320: PUSH
8321: LD_VAR 0 3
8325: PUSH
8326: LD_INT 3
8328: MOD
8329: PUSH
8330: LD_INT 1
8332: PLUS
8333: ARRAY
8334: PPUSH
8335: LD_INT 1
8337: PUSH
8338: LD_INT 3
8340: PUSH
8341: EMPTY
8342: LIST
8343: LIST
8344: PUSH
8345: LD_INT 1
8347: PPUSH
8348: LD_INT 2
8350: PPUSH
8351: CALL_OW 12
8355: ARRAY
8356: PPUSH
8357: LD_INT 3
8359: PPUSH
8360: LD_INT 43
8362: PUSH
8363: LD_INT 47
8365: PUSH
8366: LD_INT 45
8368: PUSH
8369: LD_INT 45
8371: PUSH
8372: LD_INT 46
8374: PUSH
8375: LD_INT 46
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: PUSH
8386: LD_VAR 0 3
8390: PUSH
8391: LD_INT 6
8393: MOD
8394: PUSH
8395: LD_INT 1
8397: PLUS
8398: ARRAY
8399: PPUSH
8400: LD_INT 80
8402: PPUSH
8403: CALL 69527 0 5
// result := result union CreateVehicle ;
8407: LD_ADDR_VAR 0 2
8411: PUSH
8412: LD_VAR 0 2
8416: PUSH
8417: CALL_OW 45
8421: UNION
8422: ST_TO_ADDR
// end ;
8423: GO 8304
8425: POP
8426: POP
// end ; 4 :
8427: GO 9045
8429: LD_INT 4
8431: DOUBLE
8432: EQUAL
8433: IFTRUE 8437
8435: GO 9044
8437: POP
// begin uc_nation := 3 ;
8438: LD_ADDR_OWVAR 21
8442: PUSH
8443: LD_INT 3
8445: ST_TO_ADDR
// for i = 1 to [ 7 , 8 , 9 ] [ Difficulty ] do
8446: LD_ADDR_VAR 0 3
8450: PUSH
8451: DOUBLE
8452: LD_INT 1
8454: DEC
8455: ST_TO_ADDR
8456: LD_INT 7
8458: PUSH
8459: LD_INT 8
8461: PUSH
8462: LD_INT 9
8464: PUSH
8465: EMPTY
8466: LIST
8467: LIST
8468: LIST
8469: PUSH
8470: LD_OWVAR 67
8474: ARRAY
8475: PUSH
8476: FOR_TO
8477: IFFALSE 8597
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8479: LD_INT 22
8481: PUSH
8482: LD_INT 24
8484: PUSH
8485: LD_INT 24
8487: PUSH
8488: EMPTY
8489: LIST
8490: LIST
8491: LIST
8492: PUSH
8493: LD_VAR 0 3
8497: PUSH
8498: LD_INT 3
8500: MOD
8501: PUSH
8502: LD_INT 1
8504: PLUS
8505: ARRAY
8506: PPUSH
8507: LD_INT 1
8509: PUSH
8510: LD_INT 3
8512: PUSH
8513: EMPTY
8514: LIST
8515: LIST
8516: PUSH
8517: LD_INT 1
8519: PPUSH
8520: LD_INT 2
8522: PPUSH
8523: CALL_OW 12
8527: ARRAY
8528: PPUSH
8529: LD_INT 3
8531: PPUSH
8532: LD_INT 45
8534: PUSH
8535: LD_INT 47
8537: PUSH
8538: LD_INT 47
8540: PUSH
8541: LD_INT 45
8543: PUSH
8544: LD_INT 46
8546: PUSH
8547: LD_INT 46
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: LIST
8554: LIST
8555: LIST
8556: LIST
8557: PUSH
8558: LD_VAR 0 3
8562: PUSH
8563: LD_INT 6
8565: MOD
8566: PUSH
8567: LD_INT 1
8569: PLUS
8570: ARRAY
8571: PPUSH
8572: LD_INT 80
8574: PPUSH
8575: CALL 69527 0 5
// result := result union CreateVehicle ;
8579: LD_ADDR_VAR 0 2
8583: PUSH
8584: LD_VAR 0 2
8588: PUSH
8589: CALL_OW 45
8593: UNION
8594: ST_TO_ADDR
// end ;
8595: GO 8476
8597: POP
8598: POP
// if not KappaStatus then
8599: LD_EXP 2
8603: NOT
8604: IFFALSE 8839
// begin uc_nation := 1 ;
8606: LD_ADDR_OWVAR 21
8610: PUSH
8611: LD_INT 1
8613: ST_TO_ADDR
// for i = 1 to 3 do
8614: LD_ADDR_VAR 0 3
8618: PUSH
8619: DOUBLE
8620: LD_INT 1
8622: DEC
8623: ST_TO_ADDR
8624: LD_INT 3
8626: PUSH
8627: FOR_TO
8628: IFFALSE 8764
// begin j := rand ( 0 , 1 ) ;
8630: LD_ADDR_VAR 0 4
8634: PUSH
8635: LD_INT 0
8637: PPUSH
8638: LD_INT 1
8640: PPUSH
8641: CALL_OW 12
8645: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8646: LD_INT 3
8648: PUSH
8649: LD_INT 5
8651: PUSH
8652: LD_INT 5
8654: PUSH
8655: LD_INT 4
8657: PUSH
8658: EMPTY
8659: LIST
8660: LIST
8661: LIST
8662: LIST
8663: PUSH
8664: LD_VAR 0 4
8668: PUSH
8669: LD_INT 1
8671: PPUSH
8672: LD_INT 3
8674: PPUSH
8675: CALL_OW 12
8679: PLUS
8680: ARRAY
8681: PPUSH
8682: LD_INT 1
8684: PUSH
8685: LD_INT 3
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: PUSH
8692: LD_INT 1
8694: PPUSH
8695: LD_INT 2
8697: PPUSH
8698: CALL_OW 12
8702: ARRAY
8703: PPUSH
8704: LD_INT 3
8706: PPUSH
8707: LD_INT 9
8709: PUSH
8710: LD_INT 7
8712: PUSH
8713: LD_INT 6
8715: PUSH
8716: EMPTY
8717: LIST
8718: LIST
8719: LIST
8720: PUSH
8721: LD_VAR 0 4
8725: PUSH
8726: LD_INT 1
8728: PPUSH
8729: LD_INT 2
8731: PPUSH
8732: CALL_OW 12
8736: PLUS
8737: ARRAY
8738: PPUSH
8739: LD_INT 85
8741: PPUSH
8742: CALL 69527 0 5
// result := result union CreateVehicle ;
8746: LD_ADDR_VAR 0 2
8750: PUSH
8751: LD_VAR 0 2
8755: PUSH
8756: CALL_OW 45
8760: UNION
8761: ST_TO_ADDR
// end ;
8762: GO 8627
8764: POP
8765: POP
// if vsevolodFirstAttack then
8766: LD_EXP 24
8770: IFFALSE 8837
// begin vsevolodFirstAttack := false ;
8772: LD_ADDR_EXP 24
8776: PUSH
8777: LD_INT 0
8779: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8780: LD_INT 5
8782: PPUSH
8783: LD_INT 3
8785: PPUSH
8786: LD_INT 1
8788: PPUSH
8789: LD_INT 6
8791: PPUSH
8792: LD_INT 100
8794: PPUSH
8795: CALL 69527 0 5
// sewiVeh := CreateVehicle ;
8799: LD_ADDR_EXP 68
8803: PUSH
8804: CALL_OW 45
8808: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8809: LD_EXP 68
8813: PPUSH
8814: LD_INT 1
8816: PPUSH
8817: CALL_OW 242
// result := result union sewiVeh ;
8821: LD_ADDR_VAR 0 2
8825: PUSH
8826: LD_VAR 0 2
8830: PUSH
8831: LD_EXP 68
8835: UNION
8836: ST_TO_ADDR
// end ; end else
8837: GO 9042
// if vsevolodFirstAttack then
8839: LD_EXP 24
8843: IFFALSE 9042
// begin vsevolodFirstAttack := false ;
8845: LD_ADDR_EXP 24
8849: PUSH
8850: LD_INT 0
8852: ST_TO_ADDR
// uc_nation := 3 ;
8853: LD_ADDR_OWVAR 21
8857: PUSH
8858: LD_INT 3
8860: ST_TO_ADDR
// for i = 1 to 3 do
8861: LD_ADDR_VAR 0 3
8865: PUSH
8866: DOUBLE
8867: LD_INT 1
8869: DEC
8870: ST_TO_ADDR
8871: LD_INT 3
8873: PUSH
8874: FOR_TO
8875: IFFALSE 8983
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8877: LD_INT 22
8879: PUSH
8880: LD_INT 24
8882: PUSH
8883: LD_INT 24
8885: PUSH
8886: EMPTY
8887: LIST
8888: LIST
8889: LIST
8890: PUSH
8891: LD_VAR 0 3
8895: PUSH
8896: LD_INT 3
8898: MOD
8899: PUSH
8900: LD_INT 1
8902: PLUS
8903: ARRAY
8904: PPUSH
8905: LD_INT 1
8907: PUSH
8908: LD_INT 3
8910: PUSH
8911: EMPTY
8912: LIST
8913: LIST
8914: PUSH
8915: LD_INT 1
8917: PPUSH
8918: LD_INT 2
8920: PPUSH
8921: CALL_OW 12
8925: ARRAY
8926: PPUSH
8927: LD_INT 3
8929: PPUSH
8930: LD_INT 45
8932: PUSH
8933: LD_INT 47
8935: PUSH
8936: LD_INT 47
8938: PUSH
8939: EMPTY
8940: LIST
8941: LIST
8942: LIST
8943: PUSH
8944: LD_VAR 0 3
8948: PUSH
8949: LD_INT 3
8951: MOD
8952: PUSH
8953: LD_INT 1
8955: PLUS
8956: ARRAY
8957: PPUSH
8958: LD_INT 80
8960: PPUSH
8961: CALL 69527 0 5
// result := result union CreateVehicle ;
8965: LD_ADDR_VAR 0 2
8969: PUSH
8970: LD_VAR 0 2
8974: PUSH
8975: CALL_OW 45
8979: UNION
8980: ST_TO_ADDR
// end ;
8981: GO 8874
8983: POP
8984: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
8985: LD_INT 24
8987: PPUSH
8988: LD_INT 3
8990: PPUSH
8991: LD_INT 1
8993: PPUSH
8994: LD_INT 47
8996: PPUSH
8997: LD_INT 100
8999: PPUSH
9000: CALL 69527 0 5
// sewiVeh := CreateVehicle ;
9004: LD_ADDR_EXP 68
9008: PUSH
9009: CALL_OW 45
9013: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9014: LD_EXP 68
9018: PPUSH
9019: LD_INT 1
9021: PPUSH
9022: CALL_OW 242
// result := result union sewiVeh ;
9026: LD_ADDR_VAR 0 2
9030: PUSH
9031: LD_VAR 0 2
9035: PUSH
9036: LD_EXP 68
9040: UNION
9041: ST_TO_ADDR
// end ; end ; end ;
9042: GO 9045
9044: POP
// end ;
9045: LD_VAR 0 2
9049: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9050: LD_EXP 16
9054: IFFALSE 9802
9056: GO 9058
9058: DISABLE
9059: LD_INT 0
9061: PPUSH
9062: PPUSH
9063: PPUSH
9064: PPUSH
9065: PPUSH
9066: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9067: LD_ADDR_VAR 0 4
9071: PUSH
9072: LD_INT 11
9074: PUSH
9075: LD_INT 12
9077: PUSH
9078: EMPTY
9079: LIST
9080: LIST
9081: ST_TO_ADDR
// time := [ 4 4$00 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9082: LD_ADDR_VAR 0 3
9086: PUSH
9087: LD_INT 8400
9089: PUSH
9090: LD_INT 7350
9092: PUSH
9093: LD_INT 6650
9095: PUSH
9096: EMPTY
9097: LIST
9098: LIST
9099: LIST
9100: PUSH
9101: LD_OWVAR 67
9105: ARRAY
9106: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9107: LD_ADDR_VAR 0 6
9111: PUSH
9112: LD_INT 70
9114: PUSH
9115: LD_INT 118
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: PUSH
9122: LD_INT 78
9124: PUSH
9125: LD_INT 31
9127: PUSH
9128: EMPTY
9129: LIST
9130: LIST
9131: PUSH
9132: EMPTY
9133: LIST
9134: LIST
9135: ST_TO_ADDR
// repeat if missionStage = 2 then
9136: LD_EXP 15
9140: PUSH
9141: LD_INT 2
9143: EQUAL
9144: IFFALSE 9155
// wait ( 1 1$30 ) else
9146: LD_INT 3150
9148: PPUSH
9149: CALL_OW 67
9153: GO 9164
// wait ( time ) ;
9155: LD_VAR 0 3
9159: PPUSH
9160: CALL_OW 67
// if missionStage = 6 then
9164: LD_EXP 15
9168: PUSH
9169: LD_INT 6
9171: EQUAL
9172: IFFALSE 9200
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9174: LD_INT 51
9176: PPUSH
9177: LD_INT 6
9179: PPUSH
9180: LD_INT 2
9182: PPUSH
9183: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9187: LD_INT 57
9189: PPUSH
9190: LD_INT 6
9192: PPUSH
9193: LD_INT 2
9195: PPUSH
9196: CALL_OW 322
// end ; if missionStage = 8 then
9200: LD_EXP 15
9204: PUSH
9205: LD_INT 8
9207: EQUAL
9208: IFFALSE 9236
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9210: LD_INT 52
9212: PPUSH
9213: LD_INT 6
9215: PPUSH
9216: LD_INT 2
9218: PPUSH
9219: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9223: LD_INT 58
9225: PPUSH
9226: LD_INT 6
9228: PPUSH
9229: LD_INT 2
9231: PPUSH
9232: CALL_OW 322
// end ; if missionStage = 10 then
9236: LD_EXP 15
9240: PUSH
9241: LD_INT 10
9243: EQUAL
9244: IFFALSE 9272
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9246: LD_INT 53
9248: PPUSH
9249: LD_INT 6
9251: PPUSH
9252: LD_INT 2
9254: PPUSH
9255: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9259: LD_INT 59
9261: PPUSH
9262: LD_INT 6
9264: PPUSH
9265: LD_INT 2
9267: PPUSH
9268: CALL_OW 322
// end ; if activeAttacks then
9272: LD_EXP 16
9276: IFFALSE 9796
// begin if missionStage = 2 then
9278: LD_EXP 15
9282: PUSH
9283: LD_INT 2
9285: EQUAL
9286: IFFALSE 9296
// strength := 1 ;
9288: LD_ADDR_VAR 0 5
9292: PUSH
9293: LD_INT 1
9295: ST_TO_ADDR
// if missionStage > 2 then
9296: LD_EXP 15
9300: PUSH
9301: LD_INT 2
9303: GREATER
9304: IFFALSE 9314
// strength := 2 ;
9306: LD_ADDR_VAR 0 5
9310: PUSH
9311: LD_INT 2
9313: ST_TO_ADDR
// if missionStage > 6 then
9314: LD_EXP 15
9318: PUSH
9319: LD_INT 6
9321: GREATER
9322: IFFALSE 9332
// strength := 3 ;
9324: LD_ADDR_VAR 0 5
9328: PUSH
9329: LD_INT 3
9331: ST_TO_ADDR
// if missionStage > 10 then
9332: LD_EXP 15
9336: PUSH
9337: LD_INT 10
9339: GREATER
9340: IFFALSE 9350
// strength := 4 ;
9342: LD_ADDR_VAR 0 5
9346: PUSH
9347: LD_INT 4
9349: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9350: LD_ADDR_VAR 0 2
9354: PUSH
9355: LD_VAR 0 5
9359: PPUSH
9360: CALL 7922 0 1
9364: ST_TO_ADDR
// for i in tmp do
9365: LD_ADDR_VAR 0 1
9369: PUSH
9370: LD_VAR 0 2
9374: PUSH
9375: FOR_IN
9376: IFFALSE 9476
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9378: LD_VAR 0 1
9382: PPUSH
9383: LD_VAR 0 4
9387: PUSH
9388: LD_INT 1
9390: PPUSH
9391: LD_INT 2
9393: PPUSH
9394: CALL_OW 12
9398: ARRAY
9399: PPUSH
9400: LD_INT 0
9402: PPUSH
9403: CALL_OW 49
// if i = sewiVeh then
9407: LD_VAR 0 1
9411: PUSH
9412: LD_EXP 68
9416: EQUAL
9417: IFFALSE 9452
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9419: LD_ADDR_EXP 67
9423: PUSH
9424: LD_STRING Vsevolod
9426: PPUSH
9427: LD_INT 0
9429: PPUSH
9430: LD_STRING 
9432: PPUSH
9433: CALL 62924 0 3
9437: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9438: LD_EXP 67
9442: PPUSH
9443: LD_VAR 0 1
9447: PPUSH
9448: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9452: LD_VAR 0 1
9456: PPUSH
9457: LD_INT 111
9459: PPUSH
9460: LD_INT 197
9462: PPUSH
9463: CALL_OW 111
// wait ( 0 0$2 ) ;
9467: LD_INT 70
9469: PPUSH
9470: CALL_OW 67
// end ;
9474: GO 9375
9476: POP
9477: POP
// repeat wait ( 0 0$1 ) ;
9478: LD_INT 35
9480: PPUSH
9481: CALL_OW 67
// for i in tmp do
9485: LD_ADDR_VAR 0 1
9489: PUSH
9490: LD_VAR 0 2
9494: PUSH
9495: FOR_IN
9496: IFFALSE 9777
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9498: LD_INT 81
9500: PUSH
9501: LD_INT 6
9503: PUSH
9504: EMPTY
9505: LIST
9506: LIST
9507: PUSH
9508: LD_INT 91
9510: PUSH
9511: LD_VAR 0 1
9515: PUSH
9516: LD_INT 12
9518: PUSH
9519: EMPTY
9520: LIST
9521: LIST
9522: LIST
9523: PUSH
9524: EMPTY
9525: LIST
9526: LIST
9527: PPUSH
9528: CALL_OW 69
9532: IFFALSE 9590
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_distxy , i , 12 ] ] ) , i ) ) else
9534: LD_VAR 0 1
9538: PPUSH
9539: LD_INT 81
9541: PUSH
9542: LD_INT 6
9544: PUSH
9545: EMPTY
9546: LIST
9547: LIST
9548: PUSH
9549: LD_INT 92
9551: PUSH
9552: LD_VAR 0 1
9556: PUSH
9557: LD_INT 12
9559: PUSH
9560: EMPTY
9561: LIST
9562: LIST
9563: LIST
9564: PUSH
9565: EMPTY
9566: LIST
9567: LIST
9568: PPUSH
9569: CALL_OW 69
9573: PPUSH
9574: LD_VAR 0 1
9578: PPUSH
9579: CALL_OW 74
9583: PPUSH
9584: CALL_OW 115
9588: GO 9775
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9590: LD_INT 9
9592: PPUSH
9593: LD_INT 81
9595: PUSH
9596: LD_INT 6
9598: PUSH
9599: EMPTY
9600: LIST
9601: LIST
9602: PPUSH
9603: CALL_OW 70
9607: IFFALSE 9741
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9609: LD_VAR 0 1
9613: PPUSH
9614: LD_VAR 0 6
9618: PUSH
9619: LD_INT 1
9621: ARRAY
9622: PUSH
9623: LD_INT 1
9625: ARRAY
9626: PPUSH
9627: LD_VAR 0 6
9631: PUSH
9632: LD_INT 1
9634: ARRAY
9635: PUSH
9636: LD_INT 2
9638: ARRAY
9639: PPUSH
9640: CALL_OW 297
9644: PUSH
9645: LD_INT 10
9647: GREATER
9648: PUSH
9649: LD_VAR 0 1
9653: PPUSH
9654: LD_INT 9
9656: PPUSH
9657: CALL_OW 308
9661: NOT
9662: AND
9663: IFFALSE 9702
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9665: LD_VAR 0 1
9669: PPUSH
9670: LD_VAR 0 6
9674: PUSH
9675: LD_INT 1
9677: ARRAY
9678: PUSH
9679: LD_INT 1
9681: ARRAY
9682: PPUSH
9683: LD_VAR 0 6
9687: PUSH
9688: LD_INT 1
9690: ARRAY
9691: PUSH
9692: LD_INT 2
9694: ARRAY
9695: PPUSH
9696: CALL_OW 114
9700: GO 9739
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9702: LD_VAR 0 1
9706: PPUSH
9707: LD_INT 9
9709: PPUSH
9710: LD_INT 81
9712: PUSH
9713: LD_INT 6
9715: PUSH
9716: EMPTY
9717: LIST
9718: LIST
9719: PPUSH
9720: CALL_OW 70
9724: PPUSH
9725: LD_VAR 0 1
9729: PPUSH
9730: CALL_OW 74
9734: PPUSH
9735: CALL_OW 115
// end else
9739: GO 9775
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9741: LD_VAR 0 1
9745: PPUSH
9746: LD_INT 81
9748: PUSH
9749: LD_INT 6
9751: PUSH
9752: EMPTY
9753: LIST
9754: LIST
9755: PPUSH
9756: CALL_OW 69
9760: PPUSH
9761: LD_VAR 0 1
9765: PPUSH
9766: CALL_OW 74
9770: PPUSH
9771: CALL_OW 115
// end ;
9775: GO 9495
9777: POP
9778: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9779: LD_INT 22
9781: PUSH
9782: LD_INT 6
9784: PUSH
9785: EMPTY
9786: LIST
9787: LIST
9788: PPUSH
9789: CALL_OW 69
9793: NOT
9794: IFFALSE 9478
// end ; until russianDestroyed ;
9796: LD_EXP 21
9800: IFFALSE 9136
// end ;
9802: PPOPN 6
9804: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9805: LD_EXP 21
9809: NOT
9810: PUSH
9811: LD_EXP 15
9815: PUSH
9816: LD_INT 6
9818: GREATEREQUAL
9819: AND
9820: PUSH
9821: LD_INT 2
9823: PPUSH
9824: LD_INT 1
9826: PPUSH
9827: CALL 58277 0 2
9831: NOT
9832: AND
9833: IFFALSE 10789
9835: GO 9837
9837: DISABLE
9838: LD_INT 0
9840: PPUSH
9841: PPUSH
9842: PPUSH
9843: PPUSH
// begin enable ;
9844: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9845: LD_INT 22
9847: PUSH
9848: LD_INT 3
9850: PUSH
9851: EMPTY
9852: LIST
9853: LIST
9854: PUSH
9855: LD_INT 30
9857: PUSH
9858: LD_INT 3
9860: PUSH
9861: EMPTY
9862: LIST
9863: LIST
9864: PUSH
9865: EMPTY
9866: LIST
9867: LIST
9868: PPUSH
9869: CALL_OW 69
9873: NOT
9874: IFFALSE 9878
// exit ;
9876: GO 10789
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9878: LD_ADDR_VAR 0 4
9882: PUSH
9883: LD_INT 22
9885: PUSH
9886: LD_INT 3
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: PUSH
9893: LD_INT 30
9895: PUSH
9896: LD_INT 34
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PUSH
9903: EMPTY
9904: LIST
9905: LIST
9906: PPUSH
9907: CALL_OW 69
9911: ST_TO_ADDR
// if Prob ( 40 ) then
9912: LD_INT 40
9914: PPUSH
9915: CALL_OW 13
9919: IFFALSE 10046
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
9921: LD_INT 2
9923: PPUSH
9924: LD_INT 22
9926: PUSH
9927: LD_INT 3
9929: PUSH
9930: LD_INT 3
9932: PUSH
9933: LD_INT 49
9935: PUSH
9936: EMPTY
9937: LIST
9938: LIST
9939: LIST
9940: LIST
9941: PUSH
9942: LD_INT 22
9944: PUSH
9945: LD_INT 3
9947: PUSH
9948: LD_INT 3
9950: PUSH
9951: LD_INT 49
9953: PUSH
9954: EMPTY
9955: LIST
9956: LIST
9957: LIST
9958: LIST
9959: PUSH
9960: LD_INT 22
9962: PUSH
9963: LD_INT 3
9965: PUSH
9966: LD_INT 3
9968: PUSH
9969: LD_INT 49
9971: PUSH
9972: EMPTY
9973: LIST
9974: LIST
9975: LIST
9976: LIST
9977: PUSH
9978: LD_INT 24
9980: PUSH
9981: LD_INT 3
9983: PUSH
9984: LD_INT 3
9986: PUSH
9987: LD_INT 46
9989: PUSH
9990: EMPTY
9991: LIST
9992: LIST
9993: LIST
9994: LIST
9995: PUSH
9996: LD_INT 24
9998: PUSH
9999: LD_INT 3
10001: PUSH
10002: LD_INT 3
10004: PUSH
10005: LD_INT 46
10007: PUSH
10008: EMPTY
10009: LIST
10010: LIST
10011: LIST
10012: LIST
10013: PUSH
10014: LD_INT 24
10016: PUSH
10017: LD_INT 3
10019: PUSH
10020: LD_INT 3
10022: PUSH
10023: LD_INT 46
10025: PUSH
10026: EMPTY
10027: LIST
10028: LIST
10029: LIST
10030: LIST
10031: PUSH
10032: EMPTY
10033: LIST
10034: LIST
10035: LIST
10036: LIST
10037: LIST
10038: LIST
10039: PPUSH
10040: CALL 56922 0 2
// end else
10044: GO 10169
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10046: LD_INT 2
10048: PPUSH
10049: LD_INT 24
10051: PUSH
10052: LD_INT 3
10054: PUSH
10055: LD_INT 3
10057: PUSH
10058: LD_INT 47
10060: PUSH
10061: EMPTY
10062: LIST
10063: LIST
10064: LIST
10065: LIST
10066: PUSH
10067: LD_INT 24
10069: PUSH
10070: LD_INT 3
10072: PUSH
10073: LD_INT 3
10075: PUSH
10076: LD_INT 47
10078: PUSH
10079: EMPTY
10080: LIST
10081: LIST
10082: LIST
10083: LIST
10084: PUSH
10085: LD_INT 24
10087: PUSH
10088: LD_INT 3
10090: PUSH
10091: LD_INT 3
10093: PUSH
10094: LD_INT 47
10096: PUSH
10097: EMPTY
10098: LIST
10099: LIST
10100: LIST
10101: LIST
10102: PUSH
10103: LD_INT 24
10105: PUSH
10106: LD_INT 3
10108: PUSH
10109: LD_INT 3
10111: PUSH
10112: LD_INT 46
10114: PUSH
10115: EMPTY
10116: LIST
10117: LIST
10118: LIST
10119: LIST
10120: PUSH
10121: LD_INT 24
10123: PUSH
10124: LD_INT 3
10126: PUSH
10127: LD_INT 3
10129: PUSH
10130: LD_INT 46
10132: PUSH
10133: EMPTY
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: PUSH
10139: LD_INT 24
10141: PUSH
10142: LD_INT 3
10144: PUSH
10145: LD_INT 3
10147: PUSH
10148: LD_INT 46
10150: PUSH
10151: EMPTY
10152: LIST
10153: LIST
10154: LIST
10155: LIST
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: LIST
10161: LIST
10162: LIST
10163: LIST
10164: PPUSH
10165: CALL 56922 0 2
// end ; if Difficulty > 1 then
10169: LD_OWVAR 67
10173: PUSH
10174: LD_INT 1
10176: GREATER
10177: IFFALSE 10207
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10179: LD_INT 2
10181: PPUSH
10182: LD_INT 24
10184: PUSH
10185: LD_INT 3
10187: PUSH
10188: LD_INT 3
10190: PUSH
10191: LD_INT 47
10193: PUSH
10194: EMPTY
10195: LIST
10196: LIST
10197: LIST
10198: LIST
10199: PUSH
10200: EMPTY
10201: LIST
10202: PPUSH
10203: CALL 56922 0 2
// repeat wait ( 0 0$1 ) ;
10207: LD_INT 35
10209: PPUSH
10210: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10214: LD_INT 2
10216: PPUSH
10217: LD_INT 1
10219: PPUSH
10220: CALL 58277 0 2
10224: PUSH
10225: LD_INT 6
10227: PUSH
10228: LD_INT 7
10230: PUSH
10231: LD_INT 7
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: LIST
10238: PUSH
10239: LD_OWVAR 67
10243: ARRAY
10244: GREATEREQUAL
10245: IFFALSE 10207
// wait ( 0 0$30 ) ;
10247: LD_INT 1050
10249: PPUSH
10250: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10254: LD_ADDR_VAR 0 2
10258: PUSH
10259: LD_INT 2
10261: PPUSH
10262: LD_INT 1
10264: PPUSH
10265: CALL 58277 0 2
10269: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10270: LD_ADDR_EXP 118
10274: PUSH
10275: LD_EXP 118
10279: PPUSH
10280: LD_INT 2
10282: PPUSH
10283: LD_EXP 118
10287: PUSH
10288: LD_INT 2
10290: ARRAY
10291: PUSH
10292: LD_VAR 0 2
10296: DIFF
10297: PPUSH
10298: CALL_OW 1
10302: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10303: LD_ADDR_VAR 0 3
10307: PUSH
10308: LD_INT 0
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: CALL_OW 12
10318: ST_TO_ADDR
// if target then
10319: LD_VAR 0 3
10323: IFFALSE 10451
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10325: LD_ADDR_VAR 0 2
10329: PUSH
10330: LD_VAR 0 2
10334: PPUSH
10335: LD_INT 24
10337: PUSH
10338: LD_INT 250
10340: PUSH
10341: EMPTY
10342: LIST
10343: LIST
10344: PPUSH
10345: CALL_OW 72
10349: ST_TO_ADDR
// for i in tmp do
10350: LD_ADDR_VAR 0 1
10354: PUSH
10355: LD_VAR 0 2
10359: PUSH
10360: FOR_IN
10361: IFFALSE 10401
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10363: LD_VAR 0 1
10367: PPUSH
10368: LD_INT 139
10370: PPUSH
10371: LD_INT 89
10373: PPUSH
10374: CALL_OW 297
10378: PUSH
10379: LD_INT 9
10381: GREATER
10382: IFFALSE 10399
// ComMoveXY ( i , 139 , 89 ) ;
10384: LD_VAR 0 1
10388: PPUSH
10389: LD_INT 139
10391: PPUSH
10392: LD_INT 89
10394: PPUSH
10395: CALL_OW 111
10399: GO 10360
10401: POP
10402: POP
// wait ( 0 0$1 ) ;
10403: LD_INT 35
10405: PPUSH
10406: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10410: LD_VAR 0 2
10414: PPUSH
10415: LD_INT 92
10417: PUSH
10418: LD_INT 139
10420: PUSH
10421: LD_INT 89
10423: PUSH
10424: LD_INT 9
10426: PUSH
10427: EMPTY
10428: LIST
10429: LIST
10430: LIST
10431: LIST
10432: PPUSH
10433: CALL_OW 72
10437: PUSH
10438: LD_VAR 0 2
10442: PUSH
10443: LD_INT 1
10445: MINUS
10446: GREATEREQUAL
10447: IFFALSE 10325
// end else
10449: GO 10593
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10451: LD_VAR 0 2
10455: PPUSH
10456: LD_VAR 0 4
10460: PUSH
10461: LD_INT 1
10463: ARRAY
10464: PPUSH
10465: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10469: LD_ADDR_VAR 0 2
10473: PUSH
10474: LD_VAR 0 2
10478: PPUSH
10479: LD_INT 24
10481: PUSH
10482: LD_INT 250
10484: PUSH
10485: EMPTY
10486: LIST
10487: LIST
10488: PPUSH
10489: CALL_OW 72
10493: ST_TO_ADDR
// for i in tmp do
10494: LD_ADDR_VAR 0 1
10498: PUSH
10499: LD_VAR 0 2
10503: PUSH
10504: FOR_IN
10505: IFFALSE 10545
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10507: LD_VAR 0 1
10511: PPUSH
10512: LD_INT 124
10514: PPUSH
10515: LD_INT 139
10517: PPUSH
10518: CALL_OW 297
10522: PUSH
10523: LD_INT 9
10525: GREATER
10526: IFFALSE 10543
// ComMoveXY ( i , 124 , 139 ) ;
10528: LD_VAR 0 1
10532: PPUSH
10533: LD_INT 124
10535: PPUSH
10536: LD_INT 139
10538: PPUSH
10539: CALL_OW 111
10543: GO 10504
10545: POP
10546: POP
// wait ( 0 0$1 ) ;
10547: LD_INT 35
10549: PPUSH
10550: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10554: LD_VAR 0 2
10558: PPUSH
10559: LD_INT 92
10561: PUSH
10562: LD_INT 124
10564: PUSH
10565: LD_INT 139
10567: PUSH
10568: LD_INT 9
10570: PUSH
10571: EMPTY
10572: LIST
10573: LIST
10574: LIST
10575: LIST
10576: PPUSH
10577: CALL_OW 72
10581: PUSH
10582: LD_VAR 0 2
10586: PUSH
10587: LD_INT 1
10589: MINUS
10590: GREATEREQUAL
10591: IFFALSE 10469
// end ; repeat wait ( 0 0$1 ) ;
10593: LD_INT 35
10595: PPUSH
10596: CALL_OW 67
// for i in tmp do
10600: LD_ADDR_VAR 0 1
10604: PUSH
10605: LD_VAR 0 2
10609: PUSH
10610: FOR_IN
10611: IFFALSE 10780
// begin if GetLives ( i ) > 251 then
10613: LD_VAR 0 1
10617: PPUSH
10618: CALL_OW 256
10622: PUSH
10623: LD_INT 251
10625: GREATER
10626: IFFALSE 10751
// begin if GetWeapon ( i ) = ru_time_lapser then
10628: LD_VAR 0 1
10632: PPUSH
10633: CALL_OW 264
10637: PUSH
10638: LD_INT 49
10640: EQUAL
10641: IFFALSE 10697
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10643: LD_VAR 0 1
10647: PPUSH
10648: LD_INT 2
10650: PUSH
10651: LD_INT 22
10653: PUSH
10654: LD_INT 1
10656: PUSH
10657: EMPTY
10658: LIST
10659: LIST
10660: PUSH
10661: LD_INT 22
10663: PUSH
10664: LD_INT 8
10666: PUSH
10667: EMPTY
10668: LIST
10669: LIST
10670: PUSH
10671: EMPTY
10672: LIST
10673: LIST
10674: LIST
10675: PPUSH
10676: CALL_OW 69
10680: PPUSH
10681: LD_VAR 0 1
10685: PPUSH
10686: CALL_OW 74
10690: PPUSH
10691: CALL_OW 112
10695: GO 10749
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10697: LD_VAR 0 1
10701: PPUSH
10702: LD_INT 2
10704: PUSH
10705: LD_INT 22
10707: PUSH
10708: LD_INT 1
10710: PUSH
10711: EMPTY
10712: LIST
10713: LIST
10714: PUSH
10715: LD_INT 22
10717: PUSH
10718: LD_INT 8
10720: PUSH
10721: EMPTY
10722: LIST
10723: LIST
10724: PUSH
10725: EMPTY
10726: LIST
10727: LIST
10728: LIST
10729: PPUSH
10730: CALL_OW 69
10734: PPUSH
10735: LD_VAR 0 1
10739: PPUSH
10740: CALL_OW 74
10744: PPUSH
10745: CALL_OW 115
// end else
10749: GO 10778
// if IsDead ( i ) then
10751: LD_VAR 0 1
10755: PPUSH
10756: CALL_OW 301
10760: IFFALSE 10778
// tmp := tmp diff i ;
10762: LD_ADDR_VAR 0 2
10766: PUSH
10767: LD_VAR 0 2
10771: PUSH
10772: LD_VAR 0 1
10776: DIFF
10777: ST_TO_ADDR
// end ;
10778: GO 10610
10780: POP
10781: POP
// until not tmp ;
10782: LD_VAR 0 2
10786: NOT
10787: IFFALSE 10593
// end ; end_of_file
10789: PPOPN 4
10791: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10792: LD_INT 0
10794: PPUSH
10795: PPUSH
10796: PPUSH
10797: PPUSH
10798: PPUSH
10799: PPUSH
// side := 7 ;
10800: LD_ADDR_VAR 0 5
10804: PUSH
10805: LD_INT 7
10807: ST_TO_ADDR
// uc_side := side ;
10808: LD_ADDR_OWVAR 20
10812: PUSH
10813: LD_VAR 0 5
10817: ST_TO_ADDR
// uc_nation := 1 ;
10818: LD_ADDR_OWVAR 21
10822: PUSH
10823: LD_INT 1
10825: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10826: LD_ADDR_VAR 0 2
10830: PUSH
10831: LD_INT 22
10833: PUSH
10834: LD_VAR 0 5
10838: PUSH
10839: EMPTY
10840: LIST
10841: LIST
10842: PUSH
10843: LD_INT 21
10845: PUSH
10846: LD_INT 3
10848: PUSH
10849: EMPTY
10850: LIST
10851: LIST
10852: PUSH
10853: EMPTY
10854: LIST
10855: LIST
10856: PPUSH
10857: CALL_OW 69
10861: PUSH
10862: FOR_IN
10863: IFFALSE 10879
// SetBLevel ( i , 10 ) ;
10865: LD_VAR 0 2
10869: PPUSH
10870: LD_INT 10
10872: PPUSH
10873: CALL_OW 241
10877: GO 10862
10879: POP
10880: POP
// base := GetBase ( al_depot ) ;
10881: LD_ADDR_VAR 0 4
10885: PUSH
10886: LD_INT 2
10888: PPUSH
10889: CALL_OW 274
10893: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10894: LD_ADDR_VAR 0 6
10898: PUSH
10899: LD_INT 22
10901: PUSH
10902: LD_VAR 0 5
10906: PUSH
10907: EMPTY
10908: LIST
10909: LIST
10910: PUSH
10911: LD_INT 30
10913: PUSH
10914: LD_INT 34
10916: PUSH
10917: EMPTY
10918: LIST
10919: LIST
10920: PUSH
10921: EMPTY
10922: LIST
10923: LIST
10924: PPUSH
10925: CALL_OW 69
10929: ST_TO_ADDR
// if teleport then
10930: LD_VAR 0 6
10934: IFFALSE 10955
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
10936: LD_VAR 0 6
10940: PUSH
10941: LD_INT 1
10943: ARRAY
10944: PPUSH
10945: LD_INT 262
10947: PPUSH
10948: LD_INT 119
10950: PPUSH
10951: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
10955: LD_VAR 0 4
10959: PPUSH
10960: LD_INT 1
10962: PPUSH
10963: LD_INT 19500
10965: PPUSH
10966: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
10970: LD_VAR 0 4
10974: PPUSH
10975: LD_INT 2
10977: PPUSH
10978: LD_INT 200
10980: PPUSH
10981: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
10985: LD_VAR 0 4
10989: PPUSH
10990: LD_INT 3
10992: PPUSH
10993: LD_INT 650
10995: PPUSH
10996: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11000: LD_ADDR_EXP 71
11004: PUSH
11005: LD_STRING Roth
11007: PPUSH
11008: CALL_OW 25
11012: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11013: LD_ADDR_EXP 72
11017: PUSH
11018: LD_STRING Simms
11020: PPUSH
11021: LD_EXP 1
11025: NOT
11026: PPUSH
11027: LD_STRING 10c_
11029: PPUSH
11030: CALL 62924 0 3
11034: ST_TO_ADDR
// if not Simms then
11035: LD_EXP 72
11039: NOT
11040: IFFALSE 11070
// begin uc_nation := 1 ;
11042: LD_ADDR_OWVAR 21
11046: PUSH
11047: LD_INT 1
11049: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11050: LD_INT 2
11052: PPUSH
11053: LD_INT 10
11055: PPUSH
11056: CALL_OW 384
// Simms := CreateHuman ;
11060: LD_ADDR_EXP 72
11064: PUSH
11065: CALL_OW 44
11069: ST_TO_ADDR
// end ; uc_nation := 3 ;
11070: LD_ADDR_OWVAR 21
11074: PUSH
11075: LD_INT 3
11077: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11078: LD_ADDR_EXP 73
11082: PUSH
11083: LD_STRING Kirilenkova
11085: PPUSH
11086: CALL_OW 25
11090: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11091: LD_ADDR_EXP 87
11095: PUSH
11096: LD_STRING Oblukov
11098: PPUSH
11099: CALL_OW 25
11103: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11104: LD_ADDR_EXP 74
11108: PUSH
11109: LD_STRING Dolgov
11111: PPUSH
11112: CALL_OW 25
11116: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11117: LD_ADDR_EXP 75
11121: PUSH
11122: LD_STRING Petrosyan
11124: PPUSH
11125: CALL_OW 25
11129: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11130: LD_ADDR_EXP 86
11134: PUSH
11135: LD_STRING Scholtze
11137: PPUSH
11138: CALL_OW 25
11142: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11143: LD_ADDR_EXP 85
11147: PUSH
11148: LD_STRING Kapitsova
11150: PPUSH
11151: CALL_OW 25
11155: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11156: LD_ADDR_EXP 76
11160: PUSH
11161: LD_STRING Petrovova
11163: PPUSH
11164: CALL_OW 25
11168: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11169: LD_ADDR_EXP 77
11173: PUSH
11174: LD_STRING Kuzmov
11176: PPUSH
11177: CALL_OW 25
11181: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11182: LD_ADDR_EXP 84
11186: PUSH
11187: LD_STRING Karamazov
11189: PPUSH
11190: CALL_OW 25
11194: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11195: LD_STRING 13_Lipshchin_1
11197: PPUSH
11198: LD_INT 0
11200: PPUSH
11201: CALL_OW 30
11205: IFFALSE 11220
// Lipshchin := NewCharacter ( Lipshchin ) ;
11207: LD_ADDR_EXP 78
11211: PUSH
11212: LD_STRING Lipshchin
11214: PPUSH
11215: CALL_OW 25
11219: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11220: LD_STRING 13_Titov_1
11222: PPUSH
11223: LD_INT 0
11225: PPUSH
11226: CALL_OW 30
11230: IFFALSE 11245
// Titov := NewCharacter ( Titov ) ;
11232: LD_ADDR_EXP 80
11236: PUSH
11237: LD_STRING Titov
11239: PPUSH
11240: CALL_OW 25
11244: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11245: LD_STRING 13_Gnyevko_1
11247: PPUSH
11248: LD_INT 0
11250: PPUSH
11251: CALL_OW 30
11255: IFFALSE 11270
// Gnyevko := NewCharacter ( Gnyevko ) ;
11257: LD_ADDR_EXP 79
11261: PUSH
11262: LD_STRING Gnyevko
11264: PPUSH
11265: CALL_OW 25
11269: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11270: LD_STRING 13_Xavier_1
11272: PPUSH
11273: LD_INT 0
11275: PPUSH
11276: CALL_OW 30
11280: IFFALSE 11295
// Xavier := NewCharacter ( Xavier2 ) ;
11282: LD_ADDR_EXP 81
11286: PUSH
11287: LD_STRING Xavier2
11289: PPUSH
11290: CALL_OW 25
11294: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11295: LD_STRING 13_Belkov_1
11297: PPUSH
11298: LD_INT 0
11300: PPUSH
11301: CALL_OW 30
11305: IFFALSE 11320
// Belkov := NewCharacter ( Belkov ) ;
11307: LD_ADDR_EXP 82
11311: PUSH
11312: LD_STRING Belkov
11314: PPUSH
11315: CALL_OW 25
11319: ST_TO_ADDR
// if not BurlakStatus then
11320: LD_EXP 9
11324: NOT
11325: IFFALSE 11340
// Burlak = NewCharacter ( Burlak ) ;
11327: LD_ADDR_EXP 83
11331: PUSH
11332: LD_STRING Burlak
11334: PPUSH
11335: CALL_OW 25
11339: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11340: LD_ADDR_VAR 0 3
11344: PUSH
11345: LD_EXP 71
11349: PUSH
11350: LD_EXP 73
11354: PUSH
11355: LD_EXP 87
11359: PUSH
11360: LD_EXP 74
11364: PUSH
11365: LD_EXP 75
11369: PUSH
11370: LD_EXP 86
11374: PUSH
11375: LD_EXP 85
11379: PUSH
11380: LD_EXP 76
11384: PUSH
11385: LD_EXP 77
11389: PUSH
11390: LD_EXP 84
11394: PUSH
11395: EMPTY
11396: LIST
11397: LIST
11398: LIST
11399: LIST
11400: LIST
11401: LIST
11402: LIST
11403: LIST
11404: LIST
11405: LIST
11406: ST_TO_ADDR
// if Simms then
11407: LD_EXP 72
11411: IFFALSE 11429
// tmp := tmp ^ Simms ;
11413: LD_ADDR_VAR 0 3
11417: PUSH
11418: LD_VAR 0 3
11422: PUSH
11423: LD_EXP 72
11427: ADD
11428: ST_TO_ADDR
// if Titov then
11429: LD_EXP 80
11433: IFFALSE 11451
// tmp := tmp ^ Titov ;
11435: LD_ADDR_VAR 0 3
11439: PUSH
11440: LD_VAR 0 3
11444: PUSH
11445: LD_EXP 80
11449: ADD
11450: ST_TO_ADDR
// if Lipshchin then
11451: LD_EXP 78
11455: IFFALSE 11473
// tmp := tmp ^ Lipshchin ;
11457: LD_ADDR_VAR 0 3
11461: PUSH
11462: LD_VAR 0 3
11466: PUSH
11467: LD_EXP 78
11471: ADD
11472: ST_TO_ADDR
// if Gnyevko then
11473: LD_EXP 79
11477: IFFALSE 11495
// tmp := tmp ^ Gnyevko ;
11479: LD_ADDR_VAR 0 3
11483: PUSH
11484: LD_VAR 0 3
11488: PUSH
11489: LD_EXP 79
11493: ADD
11494: ST_TO_ADDR
// if Xavier then
11495: LD_EXP 81
11499: IFFALSE 11517
// tmp := tmp ^ Xavier ;
11501: LD_ADDR_VAR 0 3
11505: PUSH
11506: LD_VAR 0 3
11510: PUSH
11511: LD_EXP 81
11515: ADD
11516: ST_TO_ADDR
// if Belkov then
11517: LD_EXP 82
11521: IFFALSE 11539
// tmp := tmp ^ Belkov ;
11523: LD_ADDR_VAR 0 3
11527: PUSH
11528: LD_VAR 0 3
11532: PUSH
11533: LD_EXP 82
11537: ADD
11538: ST_TO_ADDR
// if Burlak then
11539: LD_EXP 83
11543: IFFALSE 11561
// tmp := tmp ^ Burlak ;
11545: LD_ADDR_VAR 0 3
11549: PUSH
11550: LD_VAR 0 3
11554: PUSH
11555: LD_EXP 83
11559: ADD
11560: ST_TO_ADDR
// for i = 1 to 8 do
11561: LD_ADDR_VAR 0 2
11565: PUSH
11566: DOUBLE
11567: LD_INT 1
11569: DEC
11570: ST_TO_ADDR
11571: LD_INT 8
11573: PUSH
11574: FOR_TO
11575: IFFALSE 11641
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11577: LD_ADDR_OWVAR 21
11581: PUSH
11582: LD_INT 1
11584: PUSH
11585: LD_INT 3
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 1
11594: PPUSH
11595: LD_INT 2
11597: PPUSH
11598: CALL_OW 12
11602: ARRAY
11603: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11604: LD_INT 0
11606: PPUSH
11607: LD_VAR 0 2
11611: PUSH
11612: LD_INT 2
11614: DIV
11615: PPUSH
11616: LD_INT 10
11618: PPUSH
11619: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11623: LD_ADDR_VAR 0 3
11627: PUSH
11628: LD_VAR 0 3
11632: PUSH
11633: CALL_OW 44
11637: ADD
11638: ST_TO_ADDR
// end ;
11639: GO 11574
11641: POP
11642: POP
// for i in tmp do
11643: LD_ADDR_VAR 0 2
11647: PUSH
11648: LD_VAR 0 3
11652: PUSH
11653: FOR_IN
11654: IFFALSE 11679
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11656: LD_VAR 0 2
11660: PPUSH
11661: LD_INT 260
11663: PPUSH
11664: LD_INT 235
11666: PPUSH
11667: LD_INT 8
11669: PPUSH
11670: LD_INT 0
11672: PPUSH
11673: CALL_OW 50
11677: GO 11653
11679: POP
11680: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11681: LD_ADDR_EXP 99
11685: PUSH
11686: LD_EXP 99
11690: PPUSH
11691: LD_INT 1
11693: PPUSH
11694: LD_INT 22
11696: PUSH
11697: LD_VAR 0 5
11701: PUSH
11702: EMPTY
11703: LIST
11704: LIST
11705: PUSH
11706: LD_INT 3
11708: PUSH
11709: LD_INT 21
11711: PUSH
11712: LD_INT 2
11714: PUSH
11715: EMPTY
11716: LIST
11717: LIST
11718: PUSH
11719: EMPTY
11720: LIST
11721: LIST
11722: PUSH
11723: EMPTY
11724: LIST
11725: LIST
11726: PPUSH
11727: CALL_OW 69
11731: PUSH
11732: LD_EXP 71
11736: PUSH
11737: LD_EXP 72
11741: PUSH
11742: EMPTY
11743: LIST
11744: LIST
11745: DIFF
11746: PPUSH
11747: CALL_OW 1
11751: ST_TO_ADDR
// uc_side := 0 ;
11752: LD_ADDR_OWVAR 20
11756: PUSH
11757: LD_INT 0
11759: ST_TO_ADDR
// uc_nation := 0 ;
11760: LD_ADDR_OWVAR 21
11764: PUSH
11765: LD_INT 0
11767: ST_TO_ADDR
// for i = 1 to 5 do
11768: LD_ADDR_VAR 0 2
11772: PUSH
11773: DOUBLE
11774: LD_INT 1
11776: DEC
11777: ST_TO_ADDR
11778: LD_INT 5
11780: PUSH
11781: FOR_TO
11782: IFFALSE 11819
// begin InitHc ;
11784: CALL_OW 19
// hc_class := class_apeman ;
11788: LD_ADDR_OWVAR 28
11792: PUSH
11793: LD_INT 12
11795: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11796: CALL_OW 44
11800: PPUSH
11801: LD_INT 299
11803: PPUSH
11804: LD_INT 229
11806: PPUSH
11807: LD_INT 10
11809: PPUSH
11810: LD_INT 0
11812: PPUSH
11813: CALL_OW 50
// end ;
11817: GO 11781
11819: POP
11820: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11821: LD_EXP 71
11825: PPUSH
11826: LD_INT 259
11828: PPUSH
11829: LD_INT 235
11831: PPUSH
11832: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11836: LD_EXP 71
11840: PPUSH
11841: LD_INT 262
11843: PPUSH
11844: LD_INT 235
11846: PPUSH
11847: CALL_OW 178
// if Simms then
11851: LD_EXP 72
11855: IFFALSE 11886
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11857: LD_EXP 72
11861: PPUSH
11862: LD_INT 262
11864: PPUSH
11865: LD_INT 235
11867: PPUSH
11868: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11872: LD_EXP 72
11876: PPUSH
11877: LD_EXP 71
11881: PPUSH
11882: CALL_OW 179
// end ; end ;
11886: LD_VAR 0 1
11890: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11891: LD_EXP 31
11895: PUSH
11896: LD_EXP 23
11900: NOT
11901: AND
11902: IFFALSE 12078
11904: GO 11906
11906: DISABLE
11907: LD_INT 0
11909: PPUSH
11910: PPUSH
11911: PPUSH
// begin enable ;
11912: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
11913: LD_ADDR_VAR 0 2
11917: PUSH
11918: LD_INT 81
11920: PUSH
11921: LD_INT 7
11923: PUSH
11924: EMPTY
11925: LIST
11926: LIST
11927: PUSH
11928: LD_INT 2
11930: PUSH
11931: LD_INT 32
11933: PUSH
11934: LD_INT 3
11936: PUSH
11937: EMPTY
11938: LIST
11939: LIST
11940: PUSH
11941: LD_INT 30
11943: PUSH
11944: LD_INT 30
11946: PUSH
11947: EMPTY
11948: LIST
11949: LIST
11950: PUSH
11951: LD_INT 30
11953: PUSH
11954: LD_INT 28
11956: PUSH
11957: EMPTY
11958: LIST
11959: LIST
11960: PUSH
11961: LD_INT 34
11963: PUSH
11964: LD_INT 49
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PUSH
11971: LD_INT 34
11973: PUSH
11974: LD_INT 10
11976: PUSH
11977: EMPTY
11978: LIST
11979: LIST
11980: PUSH
11981: LD_INT 34
11983: PUSH
11984: LD_INT 8
11986: PUSH
11987: EMPTY
11988: LIST
11989: LIST
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: LIST
11995: LIST
11996: LIST
11997: LIST
11998: LIST
11999: PUSH
12000: EMPTY
12001: LIST
12002: LIST
12003: PPUSH
12004: CALL_OW 69
12008: ST_TO_ADDR
// if not tmp then
12009: LD_VAR 0 2
12013: NOT
12014: IFFALSE 12018
// exit ;
12016: GO 12078
// target := tmp [ rand ( 1 , tmp ) ] ;
12018: LD_ADDR_VAR 0 3
12022: PUSH
12023: LD_VAR 0 2
12027: PUSH
12028: LD_INT 1
12030: PPUSH
12031: LD_VAR 0 2
12035: PPUSH
12036: CALL_OW 12
12040: ARRAY
12041: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12042: LD_VAR 0 3
12046: PPUSH
12047: CALL_OW 255
12051: PUSH
12052: LD_INT 1
12054: EQUAL
12055: IFFALSE 12066
// CenterNowOnUnits ( target ) ;
12057: LD_VAR 0 3
12061: PPUSH
12062: CALL_OW 87
// SetLives ( target , 0 ) ;
12066: LD_VAR 0 3
12070: PPUSH
12071: LD_INT 0
12073: PPUSH
12074: CALL_OW 234
// end ;
12078: PPOPN 3
12080: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12081: LD_EXP 23
12085: NOT
12086: PUSH
12087: LD_EXP 31
12091: AND
12092: IFFALSE 12614
12094: GO 12096
12096: DISABLE
12097: LD_INT 0
12099: PPUSH
12100: PPUSH
12101: PPUSH
// begin uc_side := 7 ;
12102: LD_ADDR_OWVAR 20
12106: PUSH
12107: LD_INT 7
12109: ST_TO_ADDR
// uc_nation := 1 ;
12110: LD_ADDR_OWVAR 21
12114: PUSH
12115: LD_INT 1
12117: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12118: LD_ADDR_VAR 0 3
12122: PUSH
12123: LD_INT 125
12125: PUSH
12126: LD_INT 163
12128: PUSH
12129: EMPTY
12130: LIST
12131: LIST
12132: PUSH
12133: LD_INT 185
12135: PUSH
12136: LD_INT 168
12138: PUSH
12139: EMPTY
12140: LIST
12141: LIST
12142: PUSH
12143: LD_INT 111
12145: PUSH
12146: LD_INT 97
12148: PUSH
12149: EMPTY
12150: LIST
12151: LIST
12152: PUSH
12153: EMPTY
12154: LIST
12155: LIST
12156: LIST
12157: PPUSH
12158: CALL 105364 0 1
12162: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12163: LD_ADDR_EXP 88
12167: PUSH
12168: EMPTY
12169: ST_TO_ADDR
// for i = 1 to Difficulty do
12170: LD_ADDR_VAR 0 1
12174: PUSH
12175: DOUBLE
12176: LD_INT 1
12178: DEC
12179: ST_TO_ADDR
12180: LD_OWVAR 67
12184: PUSH
12185: FOR_TO
12186: IFFALSE 12344
// begin InitHc ;
12188: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12192: LD_INT 0
12194: PPUSH
12195: LD_INT 8
12197: PPUSH
12198: CALL_OW 381
// un := CreateHuman ;
12202: LD_ADDR_VAR 0 2
12206: PUSH
12207: CALL_OW 44
12211: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12212: LD_VAR 0 2
12216: PPUSH
12217: LD_INT 258
12219: PPUSH
12220: LD_INT 267
12222: PPUSH
12223: LD_INT 4
12225: PPUSH
12226: LD_INT 0
12228: PPUSH
12229: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12233: LD_ADDR_EXP 88
12237: PUSH
12238: LD_EXP 88
12242: PUSH
12243: LD_VAR 0 2
12247: UNION
12248: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12249: LD_VAR 0 2
12253: PPUSH
12254: LD_VAR 0 3
12258: PUSH
12259: LD_VAR 0 1
12263: ARRAY
12264: PUSH
12265: LD_INT 1
12267: ARRAY
12268: PPUSH
12269: LD_VAR 0 3
12273: PUSH
12274: LD_VAR 0 1
12278: ARRAY
12279: PUSH
12280: LD_INT 2
12282: ARRAY
12283: PPUSH
12284: LD_INT 4
12286: PPUSH
12287: LD_INT 1
12289: PPUSH
12290: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12294: LD_VAR 0 2
12298: PPUSH
12299: LD_VAR 0 3
12303: PUSH
12304: LD_VAR 0 1
12308: ARRAY
12309: PUSH
12310: LD_INT 1
12312: ARRAY
12313: PPUSH
12314: LD_VAR 0 3
12318: PUSH
12319: LD_VAR 0 1
12323: ARRAY
12324: PUSH
12325: LD_INT 2
12327: ARRAY
12328: PPUSH
12329: CALL_OW 171
// AddComInvisible ( un ) ;
12333: LD_VAR 0 2
12337: PPUSH
12338: CALL_OW 212
// end ;
12342: GO 12185
12344: POP
12345: POP
// repeat wait ( 0 0$20 ) ;
12346: LD_INT 700
12348: PPUSH
12349: CALL_OW 67
// for i in allianceSpecialForce do
12353: LD_ADDR_VAR 0 1
12357: PUSH
12358: LD_EXP 88
12362: PUSH
12363: FOR_IN
12364: IFFALSE 12599
// begin if IsInvisible ( i ) then
12366: LD_VAR 0 1
12370: PPUSH
12371: CALL_OW 571
12375: IFFALSE 12568
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12377: LD_ADDR_VAR 0 3
12381: PUSH
12382: LD_INT 22
12384: PUSH
12385: LD_INT 1
12387: PUSH
12388: EMPTY
12389: LIST
12390: LIST
12391: PUSH
12392: LD_INT 50
12394: PUSH
12395: EMPTY
12396: LIST
12397: PUSH
12398: LD_INT 56
12400: PUSH
12401: EMPTY
12402: LIST
12403: PUSH
12404: LD_INT 91
12406: PUSH
12407: LD_VAR 0 1
12411: PUSH
12412: LD_INT 25
12414: PUSH
12415: LD_INT 30
12417: PUSH
12418: LD_INT 35
12420: PUSH
12421: EMPTY
12422: LIST
12423: LIST
12424: LIST
12425: PUSH
12426: LD_OWVAR 67
12430: ARRAY
12431: PUSH
12432: EMPTY
12433: LIST
12434: LIST
12435: LIST
12436: PUSH
12437: LD_INT 2
12439: PUSH
12440: LD_INT 25
12442: PUSH
12443: LD_INT 1
12445: PUSH
12446: EMPTY
12447: LIST
12448: LIST
12449: PUSH
12450: LD_INT 25
12452: PUSH
12453: LD_INT 2
12455: PUSH
12456: EMPTY
12457: LIST
12458: LIST
12459: PUSH
12460: LD_INT 25
12462: PUSH
12463: LD_INT 3
12465: PUSH
12466: EMPTY
12467: LIST
12468: LIST
12469: PUSH
12470: LD_INT 25
12472: PUSH
12473: LD_INT 4
12475: PUSH
12476: EMPTY
12477: LIST
12478: LIST
12479: PUSH
12480: LD_INT 25
12482: PUSH
12483: LD_INT 5
12485: PUSH
12486: EMPTY
12487: LIST
12488: LIST
12489: PUSH
12490: LD_INT 25
12492: PUSH
12493: LD_INT 8
12495: PUSH
12496: EMPTY
12497: LIST
12498: LIST
12499: PUSH
12500: EMPTY
12501: LIST
12502: LIST
12503: LIST
12504: LIST
12505: LIST
12506: LIST
12507: LIST
12508: PUSH
12509: EMPTY
12510: LIST
12511: LIST
12512: LIST
12513: LIST
12514: LIST
12515: PPUSH
12516: CALL_OW 69
12520: ST_TO_ADDR
// if not tmp then
12521: LD_VAR 0 3
12525: NOT
12526: IFFALSE 12530
// continue ;
12528: GO 12363
// if Prob ( 30 * Difficulty ) then
12530: LD_INT 30
12532: PUSH
12533: LD_OWVAR 67
12537: MUL
12538: PPUSH
12539: CALL_OW 13
12543: IFFALSE 12568
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12545: LD_VAR 0 3
12549: PUSH
12550: LD_INT 1
12552: PPUSH
12553: LD_VAR 0 3
12557: PPUSH
12558: CALL_OW 12
12562: ARRAY
12563: PPUSH
12564: CALL 30032 0 1
// end ; if IsDead ( i ) then
12568: LD_VAR 0 1
12572: PPUSH
12573: CALL_OW 301
12577: IFFALSE 12597
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12579: LD_ADDR_EXP 88
12583: PUSH
12584: LD_EXP 88
12588: PUSH
12589: LD_VAR 0 1
12593: DIFF
12594: ST_TO_ADDR
// continue ;
12595: GO 12363
// end ; end ;
12597: GO 12363
12599: POP
12600: POP
// until allianceDestroyed or not allianceSpecialForce ;
12601: LD_EXP 23
12605: PUSH
12606: LD_EXP 88
12610: NOT
12611: OR
12612: IFFALSE 12346
// end ;
12614: PPOPN 3
12616: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12617: LD_EXP 23
12621: NOT
12622: PUSH
12623: LD_EXP 31
12627: AND
12628: PUSH
12629: LD_INT 1
12631: PPUSH
12632: LD_INT 1
12634: PPUSH
12635: CALL 58277 0 2
12639: NOT
12640: AND
12641: IFFALSE 13608
12643: GO 12645
12645: DISABLE
12646: LD_INT 0
12648: PPUSH
12649: PPUSH
12650: PPUSH
12651: PPUSH
// begin enable ;
12652: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12653: LD_INT 22
12655: PUSH
12656: LD_INT 7
12658: PUSH
12659: EMPTY
12660: LIST
12661: LIST
12662: PUSH
12663: LD_INT 30
12665: PUSH
12666: LD_INT 3
12668: PUSH
12669: EMPTY
12670: LIST
12671: LIST
12672: PUSH
12673: EMPTY
12674: LIST
12675: LIST
12676: PPUSH
12677: CALL_OW 69
12681: NOT
12682: IFFALSE 12686
// exit ;
12684: GO 13608
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12686: LD_ADDR_VAR 0 4
12690: PUSH
12691: LD_INT 22
12693: PUSH
12694: LD_INT 7
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: PUSH
12701: LD_INT 30
12703: PUSH
12704: LD_INT 34
12706: PUSH
12707: EMPTY
12708: LIST
12709: LIST
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: PPUSH
12715: CALL_OW 69
12719: ST_TO_ADDR
// if Prob ( 40 ) then
12720: LD_INT 40
12722: PPUSH
12723: CALL_OW 13
12727: IFFALSE 12854
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12729: LD_INT 1
12731: PPUSH
12732: LD_INT 5
12734: PUSH
12735: LD_INT 3
12737: PUSH
12738: LD_INT 2
12740: PUSH
12741: LD_INT 6
12743: PUSH
12744: EMPTY
12745: LIST
12746: LIST
12747: LIST
12748: LIST
12749: PUSH
12750: LD_INT 5
12752: PUSH
12753: LD_INT 3
12755: PUSH
12756: LD_INT 2
12758: PUSH
12759: LD_INT 6
12761: PUSH
12762: EMPTY
12763: LIST
12764: LIST
12765: LIST
12766: LIST
12767: PUSH
12768: LD_INT 5
12770: PUSH
12771: LD_INT 3
12773: PUSH
12774: LD_INT 2
12776: PUSH
12777: LD_INT 6
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: PUSH
12786: LD_INT 24
12788: PUSH
12789: LD_INT 3
12791: PUSH
12792: LD_INT 3
12794: PUSH
12795: LD_INT 45
12797: PUSH
12798: EMPTY
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 24
12806: PUSH
12807: LD_INT 3
12809: PUSH
12810: LD_INT 3
12812: PUSH
12813: LD_INT 47
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: PUSH
12822: LD_INT 24
12824: PUSH
12825: LD_INT 3
12827: PUSH
12828: LD_INT 3
12830: PUSH
12831: LD_INT 45
12833: PUSH
12834: EMPTY
12835: LIST
12836: LIST
12837: LIST
12838: LIST
12839: PUSH
12840: EMPTY
12841: LIST
12842: LIST
12843: LIST
12844: LIST
12845: LIST
12846: LIST
12847: PPUSH
12848: CALL 56922 0 2
// end else
12852: GO 12977
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12854: LD_INT 1
12856: PPUSH
12857: LD_INT 24
12859: PUSH
12860: LD_INT 3
12862: PUSH
12863: LD_INT 3
12865: PUSH
12866: LD_INT 47
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: LIST
12873: LIST
12874: PUSH
12875: LD_INT 24
12877: PUSH
12878: LD_INT 3
12880: PUSH
12881: LD_INT 3
12883: PUSH
12884: LD_INT 47
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: PUSH
12893: LD_INT 5
12895: PUSH
12896: LD_INT 3
12898: PUSH
12899: LD_INT 2
12901: PUSH
12902: LD_INT 9
12904: PUSH
12905: EMPTY
12906: LIST
12907: LIST
12908: LIST
12909: LIST
12910: PUSH
12911: LD_INT 5
12913: PUSH
12914: LD_INT 3
12916: PUSH
12917: LD_INT 2
12919: PUSH
12920: LD_INT 9
12922: PUSH
12923: EMPTY
12924: LIST
12925: LIST
12926: LIST
12927: LIST
12928: PUSH
12929: LD_INT 24
12931: PUSH
12932: LD_INT 1
12934: PUSH
12935: LD_INT 3
12937: PUSH
12938: LD_INT 45
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: PUSH
12947: LD_INT 24
12949: PUSH
12950: LD_INT 1
12952: PUSH
12953: LD_INT 3
12955: PUSH
12956: LD_INT 45
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: LIST
12963: LIST
12964: PUSH
12965: EMPTY
12966: LIST
12967: LIST
12968: LIST
12969: LIST
12970: LIST
12971: LIST
12972: PPUSH
12973: CALL 56922 0 2
// end ; if Difficulty > 1 then
12977: LD_OWVAR 67
12981: PUSH
12982: LD_INT 1
12984: GREATER
12985: IFFALSE 13015
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
12987: LD_INT 1
12989: PPUSH
12990: LD_INT 24
12992: PUSH
12993: LD_INT 3
12995: PUSH
12996: LD_INT 3
12998: PUSH
12999: LD_INT 47
13001: PUSH
13002: EMPTY
13003: LIST
13004: LIST
13005: LIST
13006: LIST
13007: PUSH
13008: EMPTY
13009: LIST
13010: PPUSH
13011: CALL 56922 0 2
// repeat wait ( 0 0$1 ) ;
13015: LD_INT 35
13017: PPUSH
13018: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13022: LD_INT 1
13024: PPUSH
13025: LD_INT 1
13027: PPUSH
13028: CALL 58277 0 2
13032: PUSH
13033: LD_INT 6
13035: PUSH
13036: LD_INT 7
13038: PUSH
13039: LD_INT 7
13041: PUSH
13042: EMPTY
13043: LIST
13044: LIST
13045: LIST
13046: PUSH
13047: LD_OWVAR 67
13051: ARRAY
13052: GREATEREQUAL
13053: IFFALSE 13015
// wait ( 0 0$40 ) ;
13055: LD_INT 1400
13057: PPUSH
13058: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13062: LD_ADDR_VAR 0 2
13066: PUSH
13067: LD_INT 1
13069: PPUSH
13070: LD_INT 1
13072: PPUSH
13073: CALL 58277 0 2
13077: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13078: LD_ADDR_EXP 118
13082: PUSH
13083: LD_EXP 118
13087: PPUSH
13088: LD_INT 1
13090: PPUSH
13091: LD_EXP 118
13095: PUSH
13096: LD_INT 1
13098: ARRAY
13099: PUSH
13100: LD_VAR 0 2
13104: DIFF
13105: PPUSH
13106: CALL_OW 1
13110: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13111: LD_ADDR_VAR 0 3
13115: PUSH
13116: LD_INT 0
13118: PPUSH
13119: LD_INT 1
13121: PPUSH
13122: CALL_OW 12
13126: ST_TO_ADDR
// if target then
13127: LD_VAR 0 3
13131: IFFALSE 13297
// begin for i in tmp do
13133: LD_ADDR_VAR 0 1
13137: PUSH
13138: LD_VAR 0 2
13142: PUSH
13143: FOR_IN
13144: IFFALSE 13169
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13146: LD_VAR 0 1
13150: PPUSH
13151: LD_INT 179
13153: PPUSH
13154: LD_INT 209
13156: PPUSH
13157: LD_INT 8
13159: PPUSH
13160: LD_INT 1
13162: PPUSH
13163: CALL_OW 483
13167: GO 13143
13169: POP
13170: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13171: LD_ADDR_VAR 0 2
13175: PUSH
13176: LD_VAR 0 2
13180: PPUSH
13181: LD_INT 24
13183: PUSH
13184: LD_INT 250
13186: PUSH
13187: EMPTY
13188: LIST
13189: LIST
13190: PPUSH
13191: CALL_OW 72
13195: ST_TO_ADDR
// for i in tmp do
13196: LD_ADDR_VAR 0 1
13200: PUSH
13201: LD_VAR 0 2
13205: PUSH
13206: FOR_IN
13207: IFFALSE 13247
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13209: LD_VAR 0 1
13213: PPUSH
13214: LD_INT 179
13216: PPUSH
13217: LD_INT 209
13219: PPUSH
13220: CALL_OW 297
13224: PUSH
13225: LD_INT 9
13227: GREATER
13228: IFFALSE 13245
// ComMoveXY ( i , 179 , 209 ) ;
13230: LD_VAR 0 1
13234: PPUSH
13235: LD_INT 179
13237: PPUSH
13238: LD_INT 209
13240: PPUSH
13241: CALL_OW 111
13245: GO 13206
13247: POP
13248: POP
// wait ( 0 0$1 ) ;
13249: LD_INT 35
13251: PPUSH
13252: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13256: LD_VAR 0 2
13260: PPUSH
13261: LD_INT 92
13263: PUSH
13264: LD_INT 179
13266: PUSH
13267: LD_INT 209
13269: PUSH
13270: LD_INT 9
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: PPUSH
13279: CALL_OW 72
13283: PUSH
13284: LD_VAR 0 2
13288: PUSH
13289: LD_INT 1
13291: MINUS
13292: GREATEREQUAL
13293: IFFALSE 13171
// end else
13295: GO 13459
// begin for i in tmp do
13297: LD_ADDR_VAR 0 1
13301: PUSH
13302: LD_VAR 0 2
13306: PUSH
13307: FOR_IN
13308: IFFALSE 13333
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13310: LD_VAR 0 1
13314: PPUSH
13315: LD_INT 285
13317: PPUSH
13318: LD_INT 163
13320: PPUSH
13321: LD_INT 8
13323: PPUSH
13324: LD_INT 1
13326: PPUSH
13327: CALL_OW 483
13331: GO 13307
13333: POP
13334: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13335: LD_ADDR_VAR 0 2
13339: PUSH
13340: LD_VAR 0 2
13344: PPUSH
13345: LD_INT 24
13347: PUSH
13348: LD_INT 250
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: PPUSH
13355: CALL_OW 72
13359: ST_TO_ADDR
// for i in tmp do
13360: LD_ADDR_VAR 0 1
13364: PUSH
13365: LD_VAR 0 2
13369: PUSH
13370: FOR_IN
13371: IFFALSE 13411
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13373: LD_VAR 0 1
13377: PPUSH
13378: LD_INT 285
13380: PPUSH
13381: LD_INT 163
13383: PPUSH
13384: CALL_OW 297
13388: PUSH
13389: LD_INT 9
13391: GREATER
13392: IFFALSE 13409
// ComMoveXY ( i , 285 , 163 ) ;
13394: LD_VAR 0 1
13398: PPUSH
13399: LD_INT 285
13401: PPUSH
13402: LD_INT 163
13404: PPUSH
13405: CALL_OW 111
13409: GO 13370
13411: POP
13412: POP
// wait ( 0 0$1 ) ;
13413: LD_INT 35
13415: PPUSH
13416: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13420: LD_VAR 0 2
13424: PPUSH
13425: LD_INT 92
13427: PUSH
13428: LD_INT 285
13430: PUSH
13431: LD_INT 163
13433: PUSH
13434: LD_INT 9
13436: PUSH
13437: EMPTY
13438: LIST
13439: LIST
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 72
13447: PUSH
13448: LD_VAR 0 2
13452: PUSH
13453: LD_INT 1
13455: MINUS
13456: GREATEREQUAL
13457: IFFALSE 13335
// end ; repeat wait ( 0 0$1 ) ;
13459: LD_INT 35
13461: PPUSH
13462: CALL_OW 67
// for i in tmp do
13466: LD_ADDR_VAR 0 1
13470: PUSH
13471: LD_VAR 0 2
13475: PUSH
13476: FOR_IN
13477: IFFALSE 13599
// if GetLives ( i ) > 251 then
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 256
13488: PUSH
13489: LD_INT 251
13491: GREATER
13492: IFFALSE 13581
// begin if GetWeapon ( i ) = ru_time_lapser then
13494: LD_VAR 0 1
13498: PPUSH
13499: CALL_OW 264
13503: PUSH
13504: LD_INT 49
13506: EQUAL
13507: IFFALSE 13545
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13509: LD_VAR 0 1
13513: PPUSH
13514: LD_INT 81
13516: PUSH
13517: LD_INT 7
13519: PUSH
13520: EMPTY
13521: LIST
13522: LIST
13523: PPUSH
13524: CALL_OW 69
13528: PPUSH
13529: LD_VAR 0 1
13533: PPUSH
13534: CALL_OW 74
13538: PPUSH
13539: CALL_OW 112
13543: GO 13579
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13545: LD_VAR 0 1
13549: PPUSH
13550: LD_INT 81
13552: PUSH
13553: LD_INT 7
13555: PUSH
13556: EMPTY
13557: LIST
13558: LIST
13559: PPUSH
13560: CALL_OW 69
13564: PPUSH
13565: LD_VAR 0 1
13569: PPUSH
13570: CALL_OW 74
13574: PPUSH
13575: CALL_OW 115
// end else
13579: GO 13597
// tmp := tmp diff i ;
13581: LD_ADDR_VAR 0 2
13585: PUSH
13586: LD_VAR 0 2
13590: PUSH
13591: LD_VAR 0 1
13595: DIFF
13596: ST_TO_ADDR
13597: GO 13476
13599: POP
13600: POP
// until not tmp ;
13601: LD_VAR 0 2
13605: NOT
13606: IFFALSE 13459
// end ; end_of_file
13608: PPOPN 4
13610: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13611: LD_INT 0
13613: PPUSH
13614: PPUSH
13615: PPUSH
13616: PPUSH
// missionStage := 13 ;
13617: LD_ADDR_EXP 15
13621: PUSH
13622: LD_INT 13
13624: ST_TO_ADDR
// uc_side := 2 ;
13625: LD_ADDR_OWVAR 20
13629: PUSH
13630: LD_INT 2
13632: ST_TO_ADDR
// uc_nation := 2 ;
13633: LD_ADDR_OWVAR 21
13637: PUSH
13638: LD_INT 2
13640: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13641: LD_ADDR_EXP 89
13645: PUSH
13646: LD_STRING Omar
13648: PPUSH
13649: CALL_OW 25
13653: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13654: LD_EXP 89
13658: PPUSH
13659: LD_INT 4
13661: PPUSH
13662: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13666: LD_EXP 89
13670: PPUSH
13671: LD_INT 242
13673: PPUSH
13674: LD_INT 75
13676: PPUSH
13677: LD_INT 0
13679: PPUSH
13680: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13684: LD_ADDR_EXP 90
13688: PUSH
13689: LD_STRING Heike
13691: PPUSH
13692: CALL_OW 25
13696: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13697: LD_INT 14
13699: PPUSH
13700: LD_INT 3
13702: PPUSH
13703: LD_INT 1
13705: PPUSH
13706: LD_INT 27
13708: PPUSH
13709: LD_INT 100
13711: PPUSH
13712: CALL 69527 0 5
// veh := CreateVehicle ;
13716: LD_ADDR_VAR 0 3
13720: PUSH
13721: CALL_OW 45
13725: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13726: LD_VAR 0 3
13730: PPUSH
13731: LD_INT 1
13733: PPUSH
13734: CALL_OW 242
// SetDir ( veh , 4 ) ;
13738: LD_VAR 0 3
13742: PPUSH
13743: LD_INT 4
13745: PPUSH
13746: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13750: LD_VAR 0 3
13754: PPUSH
13755: LD_INT 241
13757: PPUSH
13758: LD_INT 72
13760: PPUSH
13761: LD_INT 0
13763: PPUSH
13764: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13768: LD_EXP 90
13772: PPUSH
13773: LD_VAR 0 3
13777: PPUSH
13778: CALL_OW 52
// if KhatamStatus then
13782: LD_EXP 8
13786: IFFALSE 13837
// begin Khatam := NewCharacter ( Khatam ) ;
13788: LD_ADDR_EXP 91
13792: PUSH
13793: LD_STRING Khatam
13795: PPUSH
13796: CALL_OW 25
13800: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13801: LD_EXP 91
13805: PPUSH
13806: LD_INT 245
13808: PPUSH
13809: LD_INT 78
13811: PPUSH
13812: LD_INT 3
13814: PPUSH
13815: LD_INT 0
13817: PPUSH
13818: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13822: LD_EXP 91
13826: PPUSH
13827: LD_INT 4
13829: PPUSH
13830: LD_INT 10
13832: PPUSH
13833: CALL_OW 237
// end ; for i = 1 to Difficulty do
13837: LD_ADDR_VAR 0 2
13841: PUSH
13842: DOUBLE
13843: LD_INT 1
13845: DEC
13846: ST_TO_ADDR
13847: LD_OWVAR 67
13851: PUSH
13852: FOR_TO
13853: IFFALSE 13919
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13855: LD_INT 0
13857: PPUSH
13858: LD_INT 7
13860: PUSH
13861: LD_OWVAR 67
13865: PLUS
13866: PPUSH
13867: CALL_OW 384
// un := CreateHuman ;
13871: LD_ADDR_VAR 0 4
13875: PUSH
13876: CALL_OW 44
13880: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13881: LD_VAR 0 4
13885: PPUSH
13886: LD_INT 28
13888: PUSH
13889: LD_INT 29
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PUSH
13896: LD_VAR 0 2
13900: PUSH
13901: LD_INT 2
13903: MOD
13904: PUSH
13905: LD_INT 1
13907: PLUS
13908: ARRAY
13909: PPUSH
13910: LD_INT 0
13912: PPUSH
13913: CALL_OW 49
// end ;
13917: GO 13852
13919: POP
13920: POP
// for i = 1 to 6 do
13921: LD_ADDR_VAR 0 2
13925: PUSH
13926: DOUBLE
13927: LD_INT 1
13929: DEC
13930: ST_TO_ADDR
13931: LD_INT 6
13933: PUSH
13934: FOR_TO
13935: IFFALSE 13980
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
13937: LD_INT 0
13939: PPUSH
13940: LD_INT 7
13942: PUSH
13943: LD_OWVAR 67
13947: PLUS
13948: PPUSH
13949: CALL_OW 381
// un := CreateHuman ;
13953: LD_ADDR_VAR 0 4
13957: PUSH
13958: CALL_OW 44
13962: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
13963: LD_VAR 0 4
13967: PPUSH
13968: LD_INT 28
13970: PPUSH
13971: LD_INT 0
13973: PPUSH
13974: CALL_OW 49
// end ;
13978: GO 13934
13980: POP
13981: POP
// for i = 1 to 3 do
13982: LD_ADDR_VAR 0 2
13986: PUSH
13987: DOUBLE
13988: LD_INT 1
13990: DEC
13991: ST_TO_ADDR
13992: LD_INT 3
13994: PUSH
13995: FOR_TO
13996: IFFALSE 14044
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
13998: LD_INT 0
14000: PPUSH
14001: LD_INT 8
14003: PPUSH
14004: LD_INT 7
14006: PUSH
14007: LD_OWVAR 67
14011: PLUS
14012: PPUSH
14013: CALL_OW 380
// un := CreateHuman ;
14017: LD_ADDR_VAR 0 4
14021: PUSH
14022: CALL_OW 44
14026: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14027: LD_VAR 0 4
14031: PPUSH
14032: LD_INT 28
14034: PPUSH
14035: LD_INT 0
14037: PPUSH
14038: CALL_OW 49
// end ;
14042: GO 13995
14044: POP
14045: POP
// for i = 1 to 3 do
14046: LD_ADDR_VAR 0 2
14050: PUSH
14051: DOUBLE
14052: LD_INT 1
14054: DEC
14055: ST_TO_ADDR
14056: LD_INT 3
14058: PUSH
14059: FOR_TO
14060: IFFALSE 14150
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14062: LD_INT 14
14064: PPUSH
14065: LD_INT 2
14067: PPUSH
14068: LD_INT 1
14070: PPUSH
14071: LD_INT 28
14073: PPUSH
14074: LD_INT 80
14076: PPUSH
14077: CALL 69527 0 5
// veh := CreateVehicle ;
14081: LD_ADDR_VAR 0 3
14085: PUSH
14086: CALL_OW 45
14090: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14091: LD_VAR 0 3
14095: PPUSH
14096: LD_INT 3
14098: PPUSH
14099: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14103: LD_VAR 0 3
14107: PPUSH
14108: LD_INT 29
14110: PPUSH
14111: LD_INT 0
14113: PPUSH
14114: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14118: LD_INT 0
14120: PPUSH
14121: LD_INT 7
14123: PUSH
14124: LD_OWVAR 67
14128: PLUS
14129: PPUSH
14130: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14134: CALL_OW 44
14138: PPUSH
14139: LD_VAR 0 3
14143: PPUSH
14144: CALL_OW 52
// end ;
14148: GO 14059
14150: POP
14151: POP
// for i = 1 to 5 + Difficulty do
14152: LD_ADDR_VAR 0 2
14156: PUSH
14157: DOUBLE
14158: LD_INT 1
14160: DEC
14161: ST_TO_ADDR
14162: LD_INT 5
14164: PUSH
14165: LD_OWVAR 67
14169: PLUS
14170: PUSH
14171: FOR_TO
14172: IFFALSE 14299
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14174: LD_INT 14
14176: PPUSH
14177: LD_INT 1
14179: PPUSH
14180: LD_INT 3
14182: PPUSH
14183: CALL_OW 12
14187: PPUSH
14188: LD_INT 1
14190: PPUSH
14191: LD_INT 28
14193: PUSH
14194: LD_INT 26
14196: PUSH
14197: LD_INT 27
14199: PUSH
14200: LD_INT 25
14202: PUSH
14203: EMPTY
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: PUSH
14209: LD_VAR 0 2
14213: PUSH
14214: LD_INT 4
14216: MOD
14217: PUSH
14218: LD_INT 1
14220: PLUS
14221: ARRAY
14222: PPUSH
14223: LD_INT 80
14225: PPUSH
14226: CALL 69527 0 5
// veh := CreateVehicle ;
14230: LD_ADDR_VAR 0 3
14234: PUSH
14235: CALL_OW 45
14239: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14240: LD_VAR 0 3
14244: PPUSH
14245: LD_INT 4
14247: PPUSH
14248: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14252: LD_VAR 0 3
14256: PPUSH
14257: LD_INT 28
14259: PPUSH
14260: LD_INT 0
14262: PPUSH
14263: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14267: LD_INT 0
14269: PPUSH
14270: LD_INT 7
14272: PUSH
14273: LD_OWVAR 67
14277: PLUS
14278: PPUSH
14279: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14283: CALL_OW 44
14287: PPUSH
14288: LD_VAR 0 3
14292: PPUSH
14293: CALL_OW 52
// end ;
14297: GO 14171
14299: POP
14300: POP
// for i = 1 to 3 do
14301: LD_ADDR_VAR 0 2
14305: PUSH
14306: DOUBLE
14307: LD_INT 1
14309: DEC
14310: ST_TO_ADDR
14311: LD_INT 3
14313: PUSH
14314: FOR_TO
14315: IFFALSE 14375
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14317: LD_INT 14
14319: PPUSH
14320: LD_INT 3
14322: PPUSH
14323: LD_INT 5
14325: PPUSH
14326: LD_INT 29
14328: PPUSH
14329: LD_INT 80
14331: PPUSH
14332: CALL 69527 0 5
// veh := CreateVehicle ;
14336: LD_ADDR_VAR 0 3
14340: PUSH
14341: CALL_OW 45
14345: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14346: LD_VAR 0 3
14350: PPUSH
14351: LD_INT 4
14353: PPUSH
14354: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14358: LD_VAR 0 3
14362: PPUSH
14363: LD_INT 28
14365: PPUSH
14366: LD_INT 0
14368: PPUSH
14369: CALL_OW 49
// end ;
14373: GO 14314
14375: POP
14376: POP
// end ;
14377: LD_VAR 0 1
14381: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14382: LD_INT 22
14384: PUSH
14385: LD_INT 2
14387: PUSH
14388: EMPTY
14389: LIST
14390: LIST
14391: PPUSH
14392: CALL_OW 69
14396: IFFALSE 14696
14398: GO 14400
14400: DISABLE
14401: LD_INT 0
14403: PPUSH
14404: PPUSH
14405: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14406: LD_ADDR_VAR 0 3
14410: PUSH
14411: LD_INT 22
14413: PUSH
14414: LD_INT 2
14416: PUSH
14417: EMPTY
14418: LIST
14419: LIST
14420: PUSH
14421: LD_INT 25
14423: PUSH
14424: LD_INT 4
14426: PUSH
14427: EMPTY
14428: LIST
14429: LIST
14430: PUSH
14431: EMPTY
14432: LIST
14433: LIST
14434: PPUSH
14435: CALL_OW 69
14439: PUSH
14440: LD_EXP 91
14444: DIFF
14445: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14446: LD_ADDR_VAR 0 2
14450: PUSH
14451: LD_INT 22
14453: PUSH
14454: LD_INT 2
14456: PUSH
14457: EMPTY
14458: LIST
14459: LIST
14460: PPUSH
14461: CALL_OW 69
14465: PUSH
14466: LD_EXP 91
14470: PUSH
14471: LD_VAR 0 3
14475: UNION
14476: DIFF
14477: ST_TO_ADDR
// if Khatam then
14478: LD_EXP 91
14482: IFFALSE 14499
// ComMoveXY ( Khatam , 211 , 92 ) ;
14484: LD_EXP 91
14488: PPUSH
14489: LD_INT 211
14491: PPUSH
14492: LD_INT 92
14494: PPUSH
14495: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14499: LD_INT 197
14501: PPUSH
14502: LD_INT 80
14504: PPUSH
14505: LD_INT 2
14507: PPUSH
14508: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14512: LD_INT 213
14514: PPUSH
14515: LD_INT 90
14517: PPUSH
14518: LD_INT 2
14520: PPUSH
14521: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14525: LD_INT 215
14527: PPUSH
14528: LD_INT 129
14530: PPUSH
14531: LD_INT 2
14533: PPUSH
14534: CALL_OW 441
// if sci then
14538: LD_VAR 0 3
14542: IFFALSE 14563
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14544: LD_VAR 0 3
14548: PUSH
14549: LD_INT 1
14551: ARRAY
14552: PPUSH
14553: LD_INT 197
14555: PPUSH
14556: LD_INT 80
14558: PPUSH
14559: CALL_OW 158
// if sci > 1 then
14563: LD_VAR 0 3
14567: PUSH
14568: LD_INT 1
14570: GREATER
14571: IFFALSE 14592
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14573: LD_VAR 0 3
14577: PUSH
14578: LD_INT 2
14580: ARRAY
14581: PPUSH
14582: LD_INT 213
14584: PPUSH
14585: LD_INT 90
14587: PPUSH
14588: CALL_OW 158
// if sci > 2 then
14592: LD_VAR 0 3
14596: PUSH
14597: LD_INT 2
14599: GREATER
14600: IFFALSE 14621
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14602: LD_VAR 0 3
14606: PUSH
14607: LD_INT 3
14609: ARRAY
14610: PPUSH
14611: LD_INT 215
14613: PPUSH
14614: LD_INT 129
14616: PPUSH
14617: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14621: LD_INT 35
14623: PPUSH
14624: CALL_OW 67
// for i in tmp do
14628: LD_ADDR_VAR 0 1
14632: PUSH
14633: LD_VAR 0 2
14637: PUSH
14638: FOR_IN
14639: IFFALSE 14677
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14641: LD_VAR 0 1
14645: PPUSH
14646: LD_INT 81
14648: PUSH
14649: LD_INT 2
14651: PUSH
14652: EMPTY
14653: LIST
14654: LIST
14655: PPUSH
14656: CALL_OW 69
14660: PPUSH
14661: LD_VAR 0 1
14665: PPUSH
14666: CALL_OW 74
14670: PPUSH
14671: CALL_OW 115
14675: GO 14638
14677: POP
14678: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14679: LD_INT 22
14681: PUSH
14682: LD_INT 2
14684: PUSH
14685: EMPTY
14686: LIST
14687: LIST
14688: PPUSH
14689: CALL_OW 69
14693: NOT
14694: IFFALSE 14621
// end ; end_of_file
14696: PPOPN 3
14698: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14699: LD_INT 0
14701: PPUSH
14702: PPUSH
14703: PPUSH
14704: PPUSH
14705: PPUSH
14706: PPUSH
14707: PPUSH
14708: PPUSH
14709: PPUSH
// Video ( true ) ;
14710: LD_INT 1
14712: PPUSH
14713: CALL 105244 0 1
// if debug then
14717: LD_EXP 1
14721: IFFALSE 14731
// dialogue_skipped := true ;
14723: LD_ADDR_OWVAR 59
14727: PUSH
14728: LD_INT 1
14730: ST_TO_ADDR
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14731: LD_ADDR_VAR 0 5
14735: PUSH
14736: LD_INT 7
14738: PPUSH
14739: LD_INT 0
14741: PPUSH
14742: CALL_OW 517
14746: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14747: LD_ADDR_VAR 0 2
14751: PUSH
14752: DOUBLE
14753: LD_INT 1
14755: DEC
14756: ST_TO_ADDR
14757: LD_VAR 0 5
14761: PUSH
14762: LD_INT 1
14764: ARRAY
14765: PUSH
14766: FOR_TO
14767: IFFALSE 14812
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14769: LD_VAR 0 5
14773: PUSH
14774: LD_INT 1
14776: ARRAY
14777: PUSH
14778: LD_VAR 0 2
14782: ARRAY
14783: PPUSH
14784: LD_VAR 0 5
14788: PUSH
14789: LD_INT 2
14791: ARRAY
14792: PUSH
14793: LD_VAR 0 2
14797: ARRAY
14798: PPUSH
14799: LD_INT 1
14801: PPUSH
14802: LD_INT 15
14804: NEG
14805: PPUSH
14806: CALL 105158 0 4
14810: GO 14766
14812: POP
14813: POP
// CenterNowOnUnits ( Powell ) ;
14814: LD_EXP 55
14818: PPUSH
14819: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14823: LD_ADDR_VAR 0 5
14827: PUSH
14828: LD_EXP 53
14832: PUSH
14833: EMPTY
14834: LIST
14835: ST_TO_ADDR
// if GirlNewVeh then
14836: LD_EXP 54
14840: IFFALSE 14858
// tmp := tmp ^ GirlNewVeh ;
14842: LD_ADDR_VAR 0 5
14846: PUSH
14847: LD_VAR 0 5
14851: PUSH
14852: LD_EXP 54
14856: ADD
14857: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14858: LD_VAR 0 5
14862: PPUSH
14863: LD_INT 60
14865: PPUSH
14866: LD_INT 109
14868: PPUSH
14869: CALL_OW 111
// if KappaStatus then
14873: LD_EXP 2
14877: IFFALSE 14929
// begin Say ( JMM , D1nT-JMM-1 ) ;
14879: LD_EXP 36
14883: PPUSH
14884: LD_STRING D1nT-JMM-1
14886: PPUSH
14887: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14891: LD_EXP 55
14895: PPUSH
14896: LD_STRING D1T-Pow-1
14898: PPUSH
14899: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14903: LD_EXP 36
14907: PPUSH
14908: LD_STRING D1T-JMM-2
14910: PPUSH
14911: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
14915: LD_EXP 55
14919: PPUSH
14920: LD_STRING D1T-Pow-2
14922: PPUSH
14923: CALL_OW 88
// end else
14927: GO 15135
// if JMMGirlStatus then
14929: LD_EXP 6
14933: IFFALSE 15078
// begin Say ( JMM , D1T-JMM-1 ) ;
14935: LD_EXP 36
14939: PPUSH
14940: LD_STRING D1T-JMM-1
14942: PPUSH
14943: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14947: LD_EXP 55
14951: PPUSH
14952: LD_STRING D1T-Pow-1
14954: PPUSH
14955: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
14959: LD_EXP 36
14963: PPUSH
14964: LD_STRING D1T-JMM-3
14966: PPUSH
14967: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
14971: LD_EXP 55
14975: PPUSH
14976: LD_STRING D1T-Pow-3
14978: PPUSH
14979: CALL_OW 88
// if JMMGirl then
14983: LD_EXP 7
14987: IFFALSE 15076
// begin case JMMGirl of 1 :
14989: LD_EXP 7
14993: PUSH
14994: LD_INT 1
14996: DOUBLE
14997: EQUAL
14998: IFTRUE 15002
15000: GO 15017
15002: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15003: LD_EXP 37
15007: PPUSH
15008: LD_STRING D1T-Joan-3
15010: PPUSH
15011: CALL_OW 88
15015: GO 15064
15017: LD_INT 2
15019: DOUBLE
15020: EQUAL
15021: IFTRUE 15025
15023: GO 15040
15025: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15026: LD_EXP 39
15030: PPUSH
15031: LD_STRING D1T-Lisa-3
15033: PPUSH
15034: CALL_OW 88
15038: GO 15064
15040: LD_INT 3
15042: DOUBLE
15043: EQUAL
15044: IFTRUE 15048
15046: GO 15063
15048: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15049: LD_EXP 51
15053: PPUSH
15054: LD_STRING D1T-Con-3
15056: PPUSH
15057: CALL_OW 88
15061: GO 15064
15063: POP
// Say ( Powell , D1T-Pow-4 ) ;
15064: LD_EXP 55
15068: PPUSH
15069: LD_STRING D1T-Pow-4
15071: PPUSH
15072: CALL_OW 88
// end ; end else
15076: GO 15135
// if not FastEnd then
15078: LD_EXP 11
15082: NOT
15083: IFFALSE 15111
// begin Say ( JMM , D1T-JMM-4 ) ;
15085: LD_EXP 36
15089: PPUSH
15090: LD_STRING D1T-JMM-4
15092: PPUSH
15093: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15097: LD_EXP 55
15101: PPUSH
15102: LD_STRING D1T-Pow-5
15104: PPUSH
15105: CALL_OW 88
// end else
15109: GO 15135
// begin Say ( JMM , D1nT-JMM-1 ) ;
15111: LD_EXP 36
15115: PPUSH
15116: LD_STRING D1nT-JMM-1
15118: PPUSH
15119: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15123: LD_EXP 55
15127: PPUSH
15128: LD_STRING D1nT-Pow-1
15130: PPUSH
15131: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15135: LD_INT 35
15137: PPUSH
15138: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15142: LD_EXP 53
15146: PPUSH
15147: CALL_OW 314
15151: NOT
15152: IFFALSE 15135
// ComExitVehicle ( JMM ) ;
15154: LD_EXP 36
15158: PPUSH
15159: CALL_OW 121
// wait ( 3 ) ;
15163: LD_INT 3
15165: PPUSH
15166: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15170: LD_EXP 36
15174: PPUSH
15175: LD_INT 60
15177: PPUSH
15178: LD_INT 94
15180: PPUSH
15181: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15185: LD_EXP 36
15189: PPUSH
15190: LD_EXP 55
15194: PPUSH
15195: CALL_OW 179
// if Joan then
15199: LD_EXP 37
15203: IFFALSE 15257
// begin ComExitVehicle ( Joan ) ;
15205: LD_EXP 37
15209: PPUSH
15210: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15214: LD_EXP 37
15218: PPUSH
15219: LD_INT 35
15221: PPUSH
15222: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15226: LD_EXP 37
15230: PPUSH
15231: LD_INT 65
15233: PPUSH
15234: LD_INT 104
15236: PPUSH
15237: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15241: LD_EXP 37
15245: PPUSH
15246: LD_EXP 36
15250: PPUSH
15251: CALL_OW 179
// end else
15255: GO 15391
// if Lisa and JMMGirl = 2 then
15257: LD_EXP 39
15261: PUSH
15262: LD_EXP 7
15266: PUSH
15267: LD_INT 2
15269: EQUAL
15270: AND
15271: IFFALSE 15325
// begin ComExitVehicle ( Lisa ) ;
15273: LD_EXP 39
15277: PPUSH
15278: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15282: LD_EXP 39
15286: PPUSH
15287: LD_INT 35
15289: PPUSH
15290: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15294: LD_EXP 39
15298: PPUSH
15299: LD_INT 65
15301: PPUSH
15302: LD_INT 104
15304: PPUSH
15305: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15309: LD_EXP 39
15313: PPUSH
15314: LD_EXP 36
15318: PPUSH
15319: CALL_OW 179
// end else
15323: GO 15391
// if Connie and JMMGirl = 3 then
15325: LD_EXP 51
15329: PUSH
15330: LD_EXP 7
15334: PUSH
15335: LD_INT 3
15337: EQUAL
15338: AND
15339: IFFALSE 15391
// begin ComExitVehicle ( Connie ) ;
15341: LD_EXP 51
15345: PPUSH
15346: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15350: LD_EXP 51
15354: PPUSH
15355: LD_INT 35
15357: PPUSH
15358: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15362: LD_EXP 51
15366: PPUSH
15367: LD_INT 65
15369: PPUSH
15370: LD_INT 104
15372: PPUSH
15373: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15377: LD_EXP 51
15381: PPUSH
15382: LD_EXP 36
15386: PPUSH
15387: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15391: LD_INT 35
15393: PPUSH
15394: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15398: LD_EXP 36
15402: PPUSH
15403: LD_EXP 55
15407: PPUSH
15408: CALL_OW 296
15412: PUSH
15413: LD_INT 6
15415: LESS
15416: IFFALSE 15391
// wait ( 0 0$0.5 ) ;
15418: LD_INT 18
15420: PPUSH
15421: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15425: LD_EXP 36
15429: PPUSH
15430: LD_STRING D1-JMM-1
15432: PPUSH
15433: CALL_OW 88
// async ;
15437: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15438: LD_EXP 55
15442: PPUSH
15443: LD_STRING D1-Pow-1
15445: PPUSH
15446: CALL_OW 88
// if not dialogue_skipped then
15450: LD_OWVAR 59
15454: NOT
15455: IFFALSE 15464
// wait ( 0 0$2 ) ;
15457: LD_INT 70
15459: PPUSH
15460: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15464: LD_INT 170
15466: PPUSH
15467: LD_INT 99
15469: PPUSH
15470: LD_INT 1
15472: PPUSH
15473: LD_INT 6
15475: NEG
15476: PPUSH
15477: CALL 105158 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15481: LD_INT 174
15483: PPUSH
15484: LD_INT 115
15486: PPUSH
15487: LD_INT 1
15489: PPUSH
15490: LD_INT 6
15492: NEG
15493: PPUSH
15494: CALL 105158 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15498: LD_INT 169
15500: PPUSH
15501: LD_INT 71
15503: PPUSH
15504: LD_INT 1
15506: PPUSH
15507: LD_INT 6
15509: NEG
15510: PPUSH
15511: CALL 105158 0 4
// if not dialogue_skipped then
15515: LD_OWVAR 59
15519: NOT
15520: IFFALSE 15539
// begin CenterOnXY ( 170 , 99 ) ;
15522: LD_INT 170
15524: PPUSH
15525: LD_INT 99
15527: PPUSH
15528: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15532: LD_INT 80
15534: PPUSH
15535: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15539: LD_INT 75
15541: PPUSH
15542: LD_INT 53
15544: PPUSH
15545: LD_INT 1
15547: PPUSH
15548: LD_INT 9
15550: NEG
15551: PPUSH
15552: CALL 105158 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15556: LD_INT 54
15558: PPUSH
15559: LD_INT 42
15561: PPUSH
15562: LD_INT 1
15564: PPUSH
15565: LD_INT 9
15567: NEG
15568: PPUSH
15569: CALL 105158 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15573: LD_INT 62
15575: PPUSH
15576: LD_INT 51
15578: PPUSH
15579: LD_INT 1
15581: PPUSH
15582: LD_INT 9
15584: NEG
15585: PPUSH
15586: CALL 105158 0 4
// if not dialogue_skipped then
15590: LD_OWVAR 59
15594: NOT
15595: IFFALSE 15614
// begin CenterOnXY ( 75 , 53 ) ;
15597: LD_INT 75
15599: PPUSH
15600: LD_INT 53
15602: PPUSH
15603: CALL_OW 84
// wait ( 0 0$4 ) ;
15607: LD_INT 140
15609: PPUSH
15610: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15614: LD_EXP 55
15618: PPUSH
15619: CALL_OW 87
// if not dialogue_skipped then
15623: LD_OWVAR 59
15627: NOT
15628: IFFALSE 15637
// wait ( 0 0$2 ) ;
15630: LD_INT 70
15632: PPUSH
15633: CALL_OW 67
// sync ;
15637: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15638: LD_EXP 36
15642: PPUSH
15643: LD_STRING D1-JMM-2
15645: PPUSH
15646: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15650: LD_EXP 55
15654: PPUSH
15655: LD_STRING D1-Pow-2
15657: PPUSH
15658: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15662: LD_EXP 36
15666: PPUSH
15667: LD_STRING D1-JMM-3
15669: PPUSH
15670: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15674: LD_EXP 55
15678: PPUSH
15679: LD_STRING D1-Pow-3
15681: PPUSH
15682: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15686: LD_EXP 36
15690: PPUSH
15691: LD_STRING D1-JMM-4
15693: PPUSH
15694: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15698: LD_EXP 55
15702: PPUSH
15703: LD_STRING D1-Pow-4
15705: PPUSH
15706: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15710: LD_EXP 36
15714: PPUSH
15715: LD_STRING D1-JMM-5
15717: PPUSH
15718: CALL_OW 88
// async ;
15722: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15723: LD_EXP 55
15727: PPUSH
15728: LD_STRING D1-Pow-5
15730: PPUSH
15731: CALL_OW 88
// if not dialogue_skipped then
15735: LD_OWVAR 59
15739: NOT
15740: IFFALSE 15749
// wait ( 0 0$3.6 ) ;
15742: LD_INT 126
15744: PPUSH
15745: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15749: LD_INT 134
15751: PPUSH
15752: LD_INT 210
15754: PPUSH
15755: LD_INT 1
15757: PPUSH
15758: LD_INT 11
15760: NEG
15761: PPUSH
15762: CALL 105158 0 4
// if not dialogue_skipped then
15766: LD_OWVAR 59
15770: NOT
15771: IFFALSE 15790
// begin CenterOnXY ( 134 , 210 ) ;
15773: LD_INT 134
15775: PPUSH
15776: LD_INT 210
15778: PPUSH
15779: CALL_OW 84
// wait ( 0 0$2 ) ;
15783: LD_INT 70
15785: PPUSH
15786: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15790: LD_INT 101
15792: PPUSH
15793: LD_INT 159
15795: PPUSH
15796: LD_INT 1
15798: PPUSH
15799: LD_INT 10
15801: NEG
15802: PPUSH
15803: CALL 105158 0 4
// if not dialogue_skipped then
15807: LD_OWVAR 59
15811: NOT
15812: IFFALSE 15831
// begin CenterOnXY ( 101 , 159 ) ;
15814: LD_INT 101
15816: PPUSH
15817: LD_INT 159
15819: PPUSH
15820: CALL_OW 84
// wait ( 0 0$2 ) ;
15824: LD_INT 70
15826: PPUSH
15827: CALL_OW 67
// end ; sync ;
15831: SYNC
// CenterNowOnUnits ( Powell ) ;
15832: LD_EXP 55
15836: PPUSH
15837: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15841: LD_ADDR_VAR 0 6
15845: PUSH
15846: LD_INT 1
15848: PUSH
15849: LD_INT 2
15851: PUSH
15852: LD_INT 3
15854: PUSH
15855: LD_INT 4
15857: PUSH
15858: LD_INT 5
15860: PUSH
15861: LD_INT 6
15863: PUSH
15864: EMPTY
15865: LIST
15866: LIST
15867: LIST
15868: LIST
15869: LIST
15870: LIST
15871: ST_TO_ADDR
// if not dialogue_skipped then
15872: LD_OWVAR 59
15876: NOT
15877: IFFALSE 16046
// begin game_speed := 4 ;
15879: LD_ADDR_OWVAR 65
15883: PUSH
15884: LD_INT 4
15886: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15887: LD_INT 210
15889: PPUSH
15890: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15894: LD_ADDR_VAR 0 7
15898: PUSH
15899: LD_STRING Q1
15901: PPUSH
15902: LD_VAR 0 6
15906: PPUSH
15907: CALL_OW 98
15911: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15912: LD_ADDR_VAR 0 7
15916: PUSH
15917: LD_STRING Q1
15919: PPUSH
15920: LD_VAR 0 6
15924: PPUSH
15925: CALL_OW 98
15929: ST_TO_ADDR
// options = options diff dec ;
15930: LD_ADDR_VAR 0 6
15934: PUSH
15935: LD_VAR 0 6
15939: PUSH
15940: LD_VAR 0 7
15944: DIFF
15945: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
15946: LD_VAR 0 7
15950: PPUSH
15951: LD_VAR 0 6
15955: PPUSH
15956: CALL 17349 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
15960: LD_VAR 0 7
15964: PUSH
15965: LD_INT 5
15967: PUSH
15968: LD_INT 6
15970: PUSH
15971: EMPTY
15972: LIST
15973: LIST
15974: IN
15975: PUSH
15976: LD_VAR 0 6
15980: PUSH
15981: LD_INT 2
15983: EQUAL
15984: OR
15985: IFFALSE 15912
// if not ( dec in [ 5 , 6 ] ) then
15987: LD_VAR 0 7
15991: PUSH
15992: LD_INT 5
15994: PUSH
15995: LD_INT 6
15997: PUSH
15998: EMPTY
15999: LIST
16000: LIST
16001: IN
16002: NOT
16003: IFFALSE 16046
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16005: LD_ADDR_VAR 0 7
16009: PUSH
16010: LD_STRING Q1a
16012: PPUSH
16013: LD_INT 1
16015: PUSH
16016: LD_INT 2
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: PPUSH
16023: CALL_OW 98
16027: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16028: LD_VAR 0 7
16032: PUSH
16033: LD_INT 4
16035: PLUS
16036: PPUSH
16037: LD_VAR 0 6
16041: PPUSH
16042: CALL 17349 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16046: LD_INT 81
16048: PPUSH
16049: LD_INT 127
16051: PPUSH
16052: CALL_OW 84
// amount := 5 ;
16056: LD_ADDR_VAR 0 8
16060: PUSH
16061: LD_INT 5
16063: ST_TO_ADDR
// macmilan_squad := [ ] ;
16064: LD_ADDR_VAR 0 9
16068: PUSH
16069: EMPTY
16070: ST_TO_ADDR
// if vip < amount then
16071: LD_EXP 56
16075: PUSH
16076: LD_VAR 0 8
16080: LESS
16081: IFFALSE 16125
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16083: LD_ADDR_VAR 0 5
16087: PUSH
16088: LD_EXP 56
16092: PUSH
16093: LD_INT 22
16095: PUSH
16096: LD_INT 4
16098: PUSH
16099: EMPTY
16100: LIST
16101: LIST
16102: PUSH
16103: LD_INT 21
16105: PUSH
16106: LD_INT 1
16108: PUSH
16109: EMPTY
16110: LIST
16111: LIST
16112: PUSH
16113: EMPTY
16114: LIST
16115: LIST
16116: PPUSH
16117: CALL_OW 69
16121: UNION
16122: ST_TO_ADDR
16123: GO 16135
// tmp := vip ;
16125: LD_ADDR_VAR 0 5
16129: PUSH
16130: LD_EXP 56
16134: ST_TO_ADDR
// tmp := tmp diff Powell ;
16135: LD_ADDR_VAR 0 5
16139: PUSH
16140: LD_VAR 0 5
16144: PUSH
16145: LD_EXP 55
16149: DIFF
16150: ST_TO_ADDR
// if tmp < amount then
16151: LD_VAR 0 5
16155: PUSH
16156: LD_VAR 0 8
16160: LESS
16161: IFFALSE 16173
// amount := tmp ;
16163: LD_ADDR_VAR 0 8
16167: PUSH
16168: LD_VAR 0 5
16172: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16173: LD_VAR 0 5
16177: PUSH
16178: LD_INT 1
16180: ARRAY
16181: PPUSH
16182: CALL_OW 257
16186: PUSH
16187: LD_INT 2
16189: NONEQUAL
16190: IFFALSE 16252
// begin if IsInUnit ( tmp [ 1 ] ) then
16192: LD_VAR 0 5
16196: PUSH
16197: LD_INT 1
16199: ARRAY
16200: PPUSH
16201: CALL_OW 310
16205: IFFALSE 16220
// ComExitBuilding ( tmp [ 1 ] ) ;
16207: LD_VAR 0 5
16211: PUSH
16212: LD_INT 1
16214: ARRAY
16215: PPUSH
16216: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16220: LD_VAR 0 5
16224: PUSH
16225: LD_INT 1
16227: ARRAY
16228: PPUSH
16229: LD_INT 387
16231: PPUSH
16232: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16236: LD_VAR 0 5
16240: PUSH
16241: LD_INT 1
16243: ARRAY
16244: PPUSH
16245: LD_INT 2
16247: PPUSH
16248: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16252: LD_EXP 36
16256: PPUSH
16257: LD_INT 82
16259: PPUSH
16260: LD_INT 129
16262: PPUSH
16263: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16267: LD_EXP 36
16271: PPUSH
16272: LD_EXP 55
16276: PPUSH
16277: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16281: LD_INT 22
16283: PUSH
16284: LD_INT 1
16286: PUSH
16287: EMPTY
16288: LIST
16289: LIST
16290: PPUSH
16291: CALL_OW 69
16295: PUSH
16296: LD_EXP 36
16300: DIFF
16301: PPUSH
16302: LD_INT 84
16304: PPUSH
16305: LD_INT 128
16307: PPUSH
16308: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16312: LD_INT 22
16314: PUSH
16315: LD_INT 1
16317: PUSH
16318: EMPTY
16319: LIST
16320: LIST
16321: PPUSH
16322: CALL_OW 69
16326: PUSH
16327: LD_EXP 36
16331: DIFF
16332: PPUSH
16333: LD_EXP 36
16337: PPUSH
16338: CALL_OW 179
// for i = 1 to amount do
16342: LD_ADDR_VAR 0 2
16346: PUSH
16347: DOUBLE
16348: LD_INT 1
16350: DEC
16351: ST_TO_ADDR
16352: LD_VAR 0 8
16356: PUSH
16357: FOR_TO
16358: IFFALSE 16526
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16360: LD_ADDR_VAR 0 9
16364: PUSH
16365: LD_VAR 0 9
16369: PUSH
16370: LD_VAR 0 5
16374: PUSH
16375: LD_VAR 0 2
16379: ARRAY
16380: ADD
16381: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16382: LD_VAR 0 5
16386: PUSH
16387: LD_VAR 0 2
16391: ARRAY
16392: PPUSH
16393: CALL_OW 310
16397: IFFALSE 16414
// AddComExitBuilding ( tmp [ i ] ) ;
16399: LD_VAR 0 5
16403: PUSH
16404: LD_VAR 0 2
16408: ARRAY
16409: PPUSH
16410: CALL_OW 182
// if i = 2 and JMMNewVeh then
16414: LD_VAR 0 2
16418: PUSH
16419: LD_INT 2
16421: EQUAL
16422: PUSH
16423: LD_EXP 53
16427: AND
16428: IFFALSE 16486
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16430: LD_VAR 0 5
16434: PUSH
16435: LD_VAR 0 2
16439: ARRAY
16440: PPUSH
16441: LD_EXP 53
16445: PPUSH
16446: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16450: LD_VAR 0 5
16454: PUSH
16455: LD_VAR 0 2
16459: ARRAY
16460: PPUSH
16461: LD_INT 86
16463: PPUSH
16464: LD_INT 133
16466: PPUSH
16467: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16471: LD_VAR 0 5
16475: PUSH
16476: LD_VAR 0 2
16480: ARRAY
16481: PPUSH
16482: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16486: LD_VAR 0 5
16490: PUSH
16491: LD_VAR 0 2
16495: ARRAY
16496: PPUSH
16497: LD_INT 8
16499: PPUSH
16500: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16504: LD_VAR 0 5
16508: PUSH
16509: LD_VAR 0 2
16513: ARRAY
16514: PPUSH
16515: LD_EXP 36
16519: PPUSH
16520: CALL_OW 179
// end ;
16524: GO 16357
16526: POP
16527: POP
// if GirlNewVeh then
16528: LD_EXP 54
16532: IFFALSE 16546
// SetSide ( GirlNewVeh , 4 ) ;
16534: LD_EXP 54
16538: PPUSH
16539: LD_INT 4
16541: PPUSH
16542: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16546: LD_INT 35
16548: PPUSH
16549: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16553: LD_VAR 0 9
16557: PPUSH
16558: LD_INT 95
16560: PUSH
16561: LD_INT 9
16563: PUSH
16564: EMPTY
16565: LIST
16566: LIST
16567: PPUSH
16568: CALL_OW 72
16572: PUSH
16573: LD_INT 0
16575: EQUAL
16576: PUSH
16577: LD_EXP 36
16581: PPUSH
16582: LD_INT 9
16584: PPUSH
16585: CALL_OW 308
16589: NOT
16590: AND
16591: IFFALSE 16546
// wait ( 0 0$2 ) ;
16593: LD_INT 70
16595: PPUSH
16596: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16600: LD_VAR 0 9
16604: PPUSH
16605: LD_INT 1
16607: PPUSH
16608: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16612: LD_INT 21
16614: PUSH
16615: LD_INT 2
16617: PUSH
16618: EMPTY
16619: LIST
16620: LIST
16621: PUSH
16622: LD_INT 92
16624: PUSH
16625: LD_INT 83
16627: PUSH
16628: LD_INT 130
16630: PUSH
16631: LD_INT 10
16633: PUSH
16634: EMPTY
16635: LIST
16636: LIST
16637: LIST
16638: LIST
16639: PUSH
16640: EMPTY
16641: LIST
16642: LIST
16643: PPUSH
16644: CALL_OW 69
16648: PPUSH
16649: LD_INT 1
16651: PPUSH
16652: CALL_OW 235
// Video ( false ) ;
16656: LD_INT 0
16658: PPUSH
16659: CALL 105244 0 1
// ChangeMissionObjectives ( M1 ) ;
16663: LD_STRING M1
16665: PPUSH
16666: CALL_OW 337
// SaveForQuickRestart ;
16670: CALL_OW 22
// missionStart := true ;
16674: LD_ADDR_EXP 13
16678: PUSH
16679: LD_INT 1
16681: ST_TO_ADDR
// missionStage := 2 ;
16682: LD_ADDR_EXP 15
16686: PUSH
16687: LD_INT 2
16689: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16690: LD_INT 105
16692: PPUSH
16693: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16697: LD_ADDR_VAR 0 5
16701: PUSH
16702: LD_INT 22
16704: PUSH
16705: LD_INT 4
16707: PUSH
16708: EMPTY
16709: LIST
16710: LIST
16711: PUSH
16712: LD_INT 21
16714: PUSH
16715: LD_INT 1
16717: PUSH
16718: EMPTY
16719: LIST
16720: LIST
16721: PUSH
16722: EMPTY
16723: LIST
16724: LIST
16725: PPUSH
16726: CALL_OW 69
16730: PUSH
16731: LD_EXP 55
16735: DIFF
16736: ST_TO_ADDR
// if not tmp then
16737: LD_VAR 0 5
16741: NOT
16742: IFFALSE 16757
// tmp := [ Powell ] ;
16744: LD_ADDR_VAR 0 5
16748: PUSH
16749: LD_EXP 55
16753: PUSH
16754: EMPTY
16755: LIST
16756: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16757: LD_ADDR_EXP 99
16761: PUSH
16762: LD_EXP 99
16766: PPUSH
16767: LD_INT 4
16769: PPUSH
16770: LD_INT 22
16772: PUSH
16773: LD_INT 4
16775: PUSH
16776: EMPTY
16777: LIST
16778: LIST
16779: PUSH
16780: LD_INT 23
16782: PUSH
16783: LD_INT 1
16785: PUSH
16786: EMPTY
16787: LIST
16788: LIST
16789: PUSH
16790: LD_INT 3
16792: PUSH
16793: LD_INT 21
16795: PUSH
16796: LD_INT 2
16798: PUSH
16799: EMPTY
16800: LIST
16801: LIST
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: LIST
16811: PPUSH
16812: CALL_OW 69
16816: PUSH
16817: LD_EXP 55
16821: DIFF
16822: PPUSH
16823: CALL_OW 1
16827: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16828: LD_ADDR_VAR 0 4
16832: PUSH
16833: LD_INT 22
16835: PUSH
16836: LD_INT 4
16838: PUSH
16839: EMPTY
16840: LIST
16841: LIST
16842: PUSH
16843: LD_INT 34
16845: PUSH
16846: LD_INT 12
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PUSH
16853: EMPTY
16854: LIST
16855: LIST
16856: PPUSH
16857: CALL_OW 69
16861: PUSH
16862: LD_INT 1
16864: ARRAY
16865: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16866: LD_VAR 0 5
16870: PUSH
16871: LD_INT 1
16873: ARRAY
16874: PPUSH
16875: CALL_OW 310
16879: IFFALSE 16894
// ComExitBuilding ( tmp [ 1 ] ) ;
16881: LD_VAR 0 5
16885: PUSH
16886: LD_INT 1
16888: ARRAY
16889: PPUSH
16890: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16894: LD_VAR 0 5
16898: PUSH
16899: LD_INT 1
16901: ARRAY
16902: PPUSH
16903: LD_VAR 0 4
16907: PPUSH
16908: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16912: LD_VAR 0 5
16916: PUSH
16917: LD_INT 1
16919: ARRAY
16920: PPUSH
16921: LD_INT 80
16923: PPUSH
16924: LD_INT 136
16926: PPUSH
16927: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
16931: LD_VAR 0 5
16935: PUSH
16936: LD_INT 1
16938: ARRAY
16939: PPUSH
16940: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
16944: LD_VAR 0 5
16948: PUSH
16949: LD_INT 1
16951: ARRAY
16952: PPUSH
16953: LD_INT 59
16955: PPUSH
16956: LD_INT 112
16958: PPUSH
16959: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
16963: LD_VAR 0 5
16967: PUSH
16968: LD_INT 1
16970: ARRAY
16971: PPUSH
16972: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
16976: LD_EXP 39
16980: PUSH
16981: LD_EXP 56
16985: IN
16986: PUSH
16987: LD_EXP 39
16991: PPUSH
16992: CALL_OW 255
16996: PUSH
16997: LD_INT 1
16999: EQUAL
17000: AND
17001: IFFALSE 17017
// Say ( Lisa , D3nW-Lisa-1 ) else
17003: LD_EXP 39
17007: PPUSH
17008: LD_STRING D3nW-Lisa-1
17010: PPUSH
17011: CALL_OW 88
17015: GO 17261
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17017: LD_EXP 42
17021: PUSH
17022: LD_EXP 56
17026: IN
17027: PUSH
17028: LD_EXP 42
17032: PPUSH
17033: CALL_OW 255
17037: PUSH
17038: LD_INT 1
17040: EQUAL
17041: AND
17042: IFFALSE 17058
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17044: LD_EXP 42
17048: PPUSH
17049: LD_STRING D3nW-Cyrus-1
17051: PPUSH
17052: CALL_OW 88
17056: GO 17261
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17058: LD_EXP 41
17062: PUSH
17063: LD_EXP 56
17067: IN
17068: PUSH
17069: LD_EXP 41
17073: PPUSH
17074: CALL_OW 255
17078: PUSH
17079: LD_INT 1
17081: EQUAL
17082: AND
17083: IFFALSE 17099
// Say ( Bobby , D3nW-Bobby-1 ) else
17085: LD_EXP 41
17089: PPUSH
17090: LD_STRING D3nW-Bobby-1
17092: PPUSH
17093: CALL_OW 88
17097: GO 17261
// if Gary in vip and GetSide ( Gary ) = 1 then
17099: LD_EXP 48
17103: PUSH
17104: LD_EXP 56
17108: IN
17109: PUSH
17110: LD_EXP 48
17114: PPUSH
17115: CALL_OW 255
17119: PUSH
17120: LD_INT 1
17122: EQUAL
17123: AND
17124: IFFALSE 17140
// Say ( Gary , D3nW-Gary-1 ) else
17126: LD_EXP 48
17130: PPUSH
17131: LD_STRING D3nW-Gary-1
17133: PPUSH
17134: CALL_OW 88
17138: GO 17261
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17140: LD_EXP 40
17144: PUSH
17145: LD_EXP 56
17149: IN
17150: PUSH
17151: LD_EXP 40
17155: PPUSH
17156: CALL_OW 255
17160: PUSH
17161: LD_INT 1
17163: EQUAL
17164: AND
17165: IFFALSE 17181
// Say ( Donaldson , D3nW-Don-1 ) else
17167: LD_EXP 40
17171: PPUSH
17172: LD_STRING D3nW-Don-1
17174: PPUSH
17175: CALL_OW 88
17179: GO 17261
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17181: LD_EXP 47
17185: PUSH
17186: LD_EXP 56
17190: IN
17191: PUSH
17192: LD_EXP 47
17196: PPUSH
17197: CALL_OW 255
17201: PUSH
17202: LD_INT 1
17204: EQUAL
17205: AND
17206: IFFALSE 17222
// Say ( Cornel , D3nW-Corn-1 ) else
17208: LD_EXP 47
17212: PPUSH
17213: LD_STRING D3nW-Corn-1
17215: PPUSH
17216: CALL_OW 88
17220: GO 17261
// if Frank in vip and GetSide ( Frank ) = 1 then
17222: LD_EXP 49
17226: PUSH
17227: LD_EXP 56
17231: IN
17232: PUSH
17233: LD_EXP 49
17237: PPUSH
17238: CALL_OW 255
17242: PUSH
17243: LD_INT 1
17245: EQUAL
17246: AND
17247: IFFALSE 17261
// Say ( Frank , D3nW-Frank-1 ) ;
17249: LD_EXP 49
17253: PPUSH
17254: LD_STRING D3nW-Frank-1
17256: PPUSH
17257: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17261: LD_EXP 36
17265: PPUSH
17266: LD_STRING D3nW-JMM-1
17268: PPUSH
17269: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17273: LD_EXP 36
17277: PPUSH
17278: LD_STRING D3nW-JMM-1a
17280: PPUSH
17281: CALL_OW 88
// t := 0 0$00 ;
17285: LD_ADDR_VAR 0 3
17289: PUSH
17290: LD_INT 0
17292: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17293: LD_INT 35
17295: PPUSH
17296: CALL_OW 67
// t := t + 0 0$1 ;
17300: LD_ADDR_VAR 0 3
17304: PUSH
17305: LD_VAR 0 3
17309: PUSH
17310: LD_INT 35
17312: PLUS
17313: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17314: LD_INT 59
17316: PPUSH
17317: LD_INT 112
17319: PPUSH
17320: CALL_OW 428
17324: PUSH
17325: LD_VAR 0 3
17329: PUSH
17330: LD_INT 2100
17332: GREATER
17333: OR
17334: IFFALSE 17293
// activeAttacks := true ;
17336: LD_ADDR_EXP 16
17340: PUSH
17341: LD_INT 1
17343: ST_TO_ADDR
// end ;
17344: LD_VAR 0 1
17348: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17349: LD_INT 0
17351: PPUSH
// case question of 1 :
17352: LD_VAR 0 1
17356: PUSH
17357: LD_INT 1
17359: DOUBLE
17360: EQUAL
17361: IFTRUE 17365
17363: GO 17416
17365: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17366: LD_EXP 36
17370: PPUSH
17371: LD_STRING D2Mot-JMM-1
17373: PPUSH
17374: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17378: LD_EXP 55
17382: PPUSH
17383: LD_STRING D2Mot-Pow-1
17385: PPUSH
17386: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17390: LD_EXP 36
17394: PPUSH
17395: LD_STRING D2Mot-JMM-2
17397: PPUSH
17398: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17402: LD_EXP 55
17406: PPUSH
17407: LD_STRING D2Mot-Pow-2
17409: PPUSH
17410: CALL_OW 88
// end ; 2 :
17414: GO 17759
17416: LD_INT 2
17418: DOUBLE
17419: EQUAL
17420: IFTRUE 17424
17422: GO 17500
17424: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17425: LD_EXP 36
17429: PPUSH
17430: LD_STRING D2Rus-JMM-1
17432: PPUSH
17433: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17437: LD_EXP 55
17441: PPUSH
17442: LD_STRING D2Rus-Pow-1
17444: PPUSH
17445: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17449: LD_EXP 36
17453: PPUSH
17454: LD_STRING D2Rus-JMM-2
17456: PPUSH
17457: CALL_OW 88
// if not ( 3 in list_of_q ) then
17461: LD_INT 3
17463: PUSH
17464: LD_VAR 0 2
17468: IN
17469: NOT
17470: IFFALSE 17486
// Say ( Powell , D2Rus-Pow-2 ) else
17472: LD_EXP 55
17476: PPUSH
17477: LD_STRING D2Rus-Pow-2
17479: PPUSH
17480: CALL_OW 88
17484: GO 17498
// Say ( Powell , D2Rus-Pow-2a ) ;
17486: LD_EXP 55
17490: PPUSH
17491: LD_STRING D2Rus-Pow-2a
17493: PPUSH
17494: CALL_OW 88
// end ; 3 :
17498: GO 17759
17500: LD_INT 3
17502: DOUBLE
17503: EQUAL
17504: IFTRUE 17508
17506: GO 17593
17508: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17509: LD_EXP 36
17513: PPUSH
17514: LD_STRING D2Leg-JMM-1
17516: PPUSH
17517: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17521: LD_EXP 55
17525: PPUSH
17526: LD_STRING D2Leg-Pow-1
17528: PPUSH
17529: CALL_OW 88
// if 2 in list_of_q then
17533: LD_INT 2
17535: PUSH
17536: LD_VAR 0 2
17540: IN
17541: IFFALSE 17567
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17543: LD_EXP 36
17547: PPUSH
17548: LD_STRING D2Leg-JMM-2
17550: PPUSH
17551: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17555: LD_EXP 55
17559: PPUSH
17560: LD_STRING D2Leg-Pow-2
17562: PPUSH
17563: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17567: LD_EXP 36
17571: PPUSH
17572: LD_STRING D2Leg-JMM-3
17574: PPUSH
17575: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17579: LD_EXP 55
17583: PPUSH
17584: LD_STRING D2Leg-Pow-3
17586: PPUSH
17587: CALL_OW 88
// end ; 4 :
17591: GO 17759
17593: LD_INT 4
17595: DOUBLE
17596: EQUAL
17597: IFTRUE 17601
17599: GO 17676
17601: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17602: LD_EXP 36
17606: PPUSH
17607: LD_STRING D2Ar-JMM-1
17609: PPUSH
17610: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17614: LD_EXP 55
17618: PPUSH
17619: LD_STRING D2Ar-Pow-1
17621: PPUSH
17622: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17626: LD_EXP 36
17630: PPUSH
17631: LD_STRING D2Ar-JMM-2
17633: PPUSH
17634: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17638: LD_EXP 55
17642: PPUSH
17643: LD_STRING D2Ar-Pow-2
17645: PPUSH
17646: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17650: LD_EXP 36
17654: PPUSH
17655: LD_STRING D2Ar-JMM-3
17657: PPUSH
17658: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17662: LD_EXP 55
17666: PPUSH
17667: LD_STRING D2Ar-Pow-3
17669: PPUSH
17670: CALL_OW 88
// end ; 5 :
17674: GO 17759
17676: LD_INT 5
17678: DOUBLE
17679: EQUAL
17680: IFTRUE 17684
17682: GO 17699
17684: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17685: LD_EXP 36
17689: PPUSH
17690: LD_STRING D2Conf-JMM-1
17692: PPUSH
17693: CALL_OW 88
17697: GO 17759
17699: LD_INT 6
17701: DOUBLE
17702: EQUAL
17703: IFTRUE 17707
17705: GO 17758
17707: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17708: LD_EXP 36
17712: PPUSH
17713: LD_STRING D2Com-JMM-1
17715: PPUSH
17716: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17720: LD_EXP 55
17724: PPUSH
17725: LD_STRING D2Com-Pow-1
17727: PPUSH
17728: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17732: LD_EXP 36
17736: PPUSH
17737: LD_STRING D2Com-JMM-2
17739: PPUSH
17740: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17744: LD_EXP 55
17748: PPUSH
17749: LD_STRING D2Com-Pow-2
17751: PPUSH
17752: CALL_OW 88
// end ; end ;
17756: GO 17759
17758: POP
// end ;
17759: LD_VAR 0 3
17763: RET
// every 0 0$5 trigger missionStart do var tmp ;
17764: LD_EXP 13
17768: IFFALSE 18051
17770: GO 17772
17772: DISABLE
17773: LD_INT 0
17775: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17776: LD_INT 35
17778: PPUSH
17779: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17783: LD_INT 14
17785: PPUSH
17786: LD_INT 22
17788: PUSH
17789: LD_INT 1
17791: PUSH
17792: EMPTY
17793: LIST
17794: LIST
17795: PPUSH
17796: CALL_OW 70
17800: PUSH
17801: LD_EXP 15
17805: PUSH
17806: LD_INT 2
17808: PUSH
17809: LD_INT 3
17811: PUSH
17812: LD_INT 4
17814: PUSH
17815: LD_INT 5
17817: PUSH
17818: EMPTY
17819: LIST
17820: LIST
17821: LIST
17822: LIST
17823: IN
17824: AND
17825: IFFALSE 18041
// begin powellAnger := powellAnger + 1 ;
17827: LD_ADDR_EXP 17
17831: PUSH
17832: LD_EXP 17
17836: PUSH
17837: LD_INT 1
17839: PLUS
17840: ST_TO_ADDR
// Video ( true ) ;
17841: LD_INT 1
17843: PPUSH
17844: CALL 105244 0 1
// CenterNowOnUnits ( tmp ) ;
17848: LD_VAR 0 1
17852: PPUSH
17853: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17857: LD_INT 14
17859: PPUSH
17860: LD_INT 22
17862: PUSH
17863: LD_INT 1
17865: PUSH
17866: EMPTY
17867: LIST
17868: LIST
17869: PPUSH
17870: CALL_OW 70
17874: PPUSH
17875: LD_INT 86
17877: PPUSH
17878: LD_INT 133
17880: PPUSH
17881: CALL_OW 111
// async ;
17885: ASYNC
// case powellAnger of 1 :
17886: LD_EXP 17
17890: PUSH
17891: LD_INT 1
17893: DOUBLE
17894: EQUAL
17895: IFTRUE 17899
17897: GO 17914
17899: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17900: LD_EXP 55
17904: PPUSH
17905: LD_STRING DBack1-Pow-1
17907: PPUSH
17908: CALL_OW 88
17912: GO 17961
17914: LD_INT 2
17916: DOUBLE
17917: EQUAL
17918: IFTRUE 17922
17920: GO 17937
17922: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
17923: LD_EXP 55
17927: PPUSH
17928: LD_STRING DBack2-Pow-1
17930: PPUSH
17931: CALL_OW 88
17935: GO 17961
17937: LD_INT 3
17939: DOUBLE
17940: EQUAL
17941: IFTRUE 17945
17943: GO 17960
17945: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
17946: LD_EXP 55
17950: PPUSH
17951: LD_STRING DBack3-Pow-1
17953: PPUSH
17954: CALL_OW 88
17958: GO 17961
17960: POP
// sync ;
17961: SYNC
// repeat wait ( 0 0$1 ) ;
17962: LD_INT 35
17964: PPUSH
17965: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17969: LD_INT 14
17971: PPUSH
17972: LD_INT 22
17974: PUSH
17975: LD_INT 1
17977: PUSH
17978: EMPTY
17979: LIST
17980: LIST
17981: PPUSH
17982: CALL_OW 70
17986: PPUSH
17987: LD_INT 86
17989: PPUSH
17990: LD_INT 133
17992: PPUSH
17993: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
17997: LD_INT 14
17999: PPUSH
18000: LD_INT 22
18002: PUSH
18003: LD_INT 1
18005: PUSH
18006: EMPTY
18007: LIST
18008: LIST
18009: PPUSH
18010: CALL_OW 70
18014: NOT
18015: IFFALSE 17962
// if powellAnger >= 3 then
18017: LD_EXP 17
18021: PUSH
18022: LD_INT 3
18024: GREATEREQUAL
18025: IFFALSE 18034
// YouLost ( Dismissed ) ;
18027: LD_STRING Dismissed
18029: PPUSH
18030: CALL_OW 104
// Video ( false ) ;
18034: LD_INT 0
18036: PPUSH
18037: CALL 105244 0 1
// end ; until missionStage > 5 ;
18041: LD_EXP 15
18045: PUSH
18046: LD_INT 5
18048: GREATER
18049: IFFALSE 17776
// end ;
18051: PPOPN 1
18053: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18054: LD_EXP 13
18058: PUSH
18059: LD_INT 22
18061: PUSH
18062: LD_INT 4
18064: PUSH
18065: EMPTY
18066: LIST
18067: LIST
18068: PUSH
18069: LD_INT 21
18071: PUSH
18072: LD_INT 2
18074: PUSH
18075: EMPTY
18076: LIST
18077: LIST
18078: PUSH
18079: EMPTY
18080: LIST
18081: LIST
18082: PPUSH
18083: CALL_OW 69
18087: PUSH
18088: LD_INT 4
18090: GREATEREQUAL
18091: AND
18092: PUSH
18093: LD_EXP 15
18097: PUSH
18098: LD_INT 2
18100: EQUAL
18101: AND
18102: IFFALSE 19925
18104: GO 18106
18106: DISABLE
18107: LD_INT 0
18109: PPUSH
18110: PPUSH
18111: PPUSH
18112: PPUSH
18113: PPUSH
18114: PPUSH
18115: PPUSH
18116: PPUSH
// begin missionStage := 3 ;
18117: LD_ADDR_EXP 15
18121: PUSH
18122: LD_INT 3
18124: ST_TO_ADDR
// retreat := false ;
18125: LD_ADDR_VAR 0 4
18129: PUSH
18130: LD_INT 0
18132: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18133: LD_ADDR_VAR 0 5
18137: PUSH
18138: LD_INT 22
18140: PUSH
18141: LD_INT 4
18143: PUSH
18144: EMPTY
18145: LIST
18146: LIST
18147: PUSH
18148: LD_INT 30
18150: PUSH
18151: LD_INT 4
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: PUSH
18158: EMPTY
18159: LIST
18160: LIST
18161: PPUSH
18162: CALL_OW 69
18166: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18167: LD_ADDR_VAR 0 6
18171: PUSH
18172: LD_INT 22
18174: PUSH
18175: LD_INT 4
18177: PUSH
18178: EMPTY
18179: LIST
18180: LIST
18181: PUSH
18182: LD_INT 30
18184: PUSH
18185: LD_INT 5
18187: PUSH
18188: EMPTY
18189: LIST
18190: LIST
18191: PUSH
18192: EMPTY
18193: LIST
18194: LIST
18195: PPUSH
18196: CALL_OW 69
18200: ST_TO_ADDR
// if not bar then
18201: LD_VAR 0 6
18205: NOT
18206: IFFALSE 18259
// begin repeat wait ( 0 0$1 ) ;
18208: LD_INT 35
18210: PPUSH
18211: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18215: LD_INT 22
18217: PUSH
18218: LD_INT 4
18220: PUSH
18221: EMPTY
18222: LIST
18223: LIST
18224: PUSH
18225: LD_INT 3
18227: PUSH
18228: LD_INT 57
18230: PUSH
18231: EMPTY
18232: LIST
18233: PUSH
18234: EMPTY
18235: LIST
18236: LIST
18237: PUSH
18238: LD_INT 30
18240: PUSH
18241: LD_INT 5
18243: PUSH
18244: EMPTY
18245: LIST
18246: LIST
18247: PUSH
18248: EMPTY
18249: LIST
18250: LIST
18251: LIST
18252: PPUSH
18253: CALL_OW 69
18257: IFFALSE 18208
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18259: LD_ADDR_VAR 0 6
18263: PUSH
18264: LD_INT 22
18266: PUSH
18267: LD_INT 4
18269: PUSH
18270: EMPTY
18271: LIST
18272: LIST
18273: PUSH
18274: LD_INT 30
18276: PUSH
18277: LD_INT 5
18279: PUSH
18280: EMPTY
18281: LIST
18282: LIST
18283: PUSH
18284: EMPTY
18285: LIST
18286: LIST
18287: PPUSH
18288: CALL_OW 69
18292: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18293: LD_INT 35
18295: PPUSH
18296: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18300: LD_EXP 118
18304: PUSH
18305: LD_INT 4
18307: ARRAY
18308: PUSH
18309: LD_INT 4
18311: GREATEREQUAL
18312: IFFALSE 18293
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18314: LD_ADDR_VAR 0 2
18318: PUSH
18319: LD_INT 22
18321: PUSH
18322: LD_INT 4
18324: PUSH
18325: EMPTY
18326: LIST
18327: LIST
18328: PUSH
18329: LD_INT 2
18331: PUSH
18332: LD_INT 25
18334: PUSH
18335: LD_INT 1
18337: PUSH
18338: EMPTY
18339: LIST
18340: LIST
18341: PUSH
18342: LD_INT 25
18344: PUSH
18345: LD_INT 2
18347: PUSH
18348: EMPTY
18349: LIST
18350: LIST
18351: PUSH
18352: LD_INT 25
18354: PUSH
18355: LD_INT 3
18357: PUSH
18358: EMPTY
18359: LIST
18360: LIST
18361: PUSH
18362: LD_INT 25
18364: PUSH
18365: LD_INT 4
18367: PUSH
18368: EMPTY
18369: LIST
18370: LIST
18371: PUSH
18372: LD_INT 25
18374: PUSH
18375: LD_INT 5
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: PUSH
18382: EMPTY
18383: LIST
18384: LIST
18385: LIST
18386: LIST
18387: LIST
18388: LIST
18389: PUSH
18390: EMPTY
18391: LIST
18392: LIST
18393: PPUSH
18394: CALL_OW 69
18398: PUSH
18399: LD_EXP 55
18403: PUSH
18404: LD_EXP 56
18408: ADD
18409: DIFF
18410: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18411: LD_ADDR_VAR 0 3
18415: PUSH
18416: LD_VAR 0 2
18420: PPUSH
18421: LD_INT 26
18423: PUSH
18424: LD_INT 1
18426: PUSH
18427: EMPTY
18428: LIST
18429: LIST
18430: PPUSH
18431: CALL_OW 72
18435: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18436: LD_ADDR_VAR 0 2
18440: PUSH
18441: LD_VAR 0 2
18445: PUSH
18446: LD_VAR 0 3
18450: DIFF
18451: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18452: LD_ADDR_VAR 0 2
18456: PUSH
18457: LD_VAR 0 2
18461: PPUSH
18462: LD_INT 1
18464: PPUSH
18465: CALL 103897 0 2
18469: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18470: LD_ADDR_VAR 0 3
18474: PUSH
18475: LD_VAR 0 3
18479: PPUSH
18480: LD_INT 1
18482: PPUSH
18483: CALL 103897 0 2
18487: ST_TO_ADDR
// for i = 1 to 4 do
18488: LD_ADDR_VAR 0 1
18492: PUSH
18493: DOUBLE
18494: LD_INT 1
18496: DEC
18497: ST_TO_ADDR
18498: LD_INT 4
18500: PUSH
18501: FOR_TO
18502: IFFALSE 18668
// begin if tmp2 then
18504: LD_VAR 0 3
18508: IFFALSE 18589
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18510: LD_ADDR_EXP 18
18514: PUSH
18515: LD_EXP 18
18519: PPUSH
18520: LD_INT 1
18522: PPUSH
18523: LD_EXP 18
18527: PUSH
18528: LD_INT 1
18530: ARRAY
18531: PUSH
18532: LD_VAR 0 3
18536: PUSH
18537: LD_VAR 0 3
18541: ARRAY
18542: ADD
18543: PPUSH
18544: CALL_OW 1
18548: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18549: LD_VAR 0 3
18553: PUSH
18554: LD_VAR 0 3
18558: ARRAY
18559: PPUSH
18560: LD_INT 1
18562: PPUSH
18563: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18567: LD_ADDR_VAR 0 3
18571: PUSH
18572: LD_VAR 0 3
18576: PPUSH
18577: LD_VAR 0 3
18581: PPUSH
18582: CALL_OW 3
18586: ST_TO_ADDR
// end else
18587: GO 18666
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18589: LD_ADDR_EXP 18
18593: PUSH
18594: LD_EXP 18
18598: PPUSH
18599: LD_INT 1
18601: PPUSH
18602: LD_EXP 18
18606: PUSH
18607: LD_INT 1
18609: ARRAY
18610: PUSH
18611: LD_VAR 0 2
18615: PUSH
18616: LD_VAR 0 2
18620: ARRAY
18621: ADD
18622: PPUSH
18623: CALL_OW 1
18627: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18628: LD_VAR 0 2
18632: PUSH
18633: LD_VAR 0 2
18637: ARRAY
18638: PPUSH
18639: LD_INT 1
18641: PPUSH
18642: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18646: LD_ADDR_VAR 0 2
18650: PUSH
18651: LD_VAR 0 2
18655: PPUSH
18656: LD_VAR 0 2
18660: PPUSH
18661: CALL_OW 3
18665: ST_TO_ADDR
// end ; end ;
18666: GO 18501
18668: POP
18669: POP
// if tmp2 then
18670: LD_VAR 0 3
18674: IFFALSE 18692
// tmp := tmp union tmp2 ;
18676: LD_ADDR_VAR 0 2
18680: PUSH
18681: LD_VAR 0 2
18685: PUSH
18686: LD_VAR 0 3
18690: UNION
18691: ST_TO_ADDR
// for i = 1 to 4 do
18692: LD_ADDR_VAR 0 1
18696: PUSH
18697: DOUBLE
18698: LD_INT 1
18700: DEC
18701: ST_TO_ADDR
18702: LD_INT 4
18704: PUSH
18705: FOR_TO
18706: IFFALSE 18755
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18708: LD_ADDR_EXP 18
18712: PUSH
18713: LD_EXP 18
18717: PPUSH
18718: LD_INT 2
18720: PPUSH
18721: LD_EXP 18
18725: PUSH
18726: LD_INT 2
18728: ARRAY
18729: PUSH
18730: LD_VAR 0 2
18734: PUSH
18735: LD_VAR 0 2
18739: PUSH
18740: LD_VAR 0 1
18744: MINUS
18745: ARRAY
18746: ADD
18747: PPUSH
18748: CALL_OW 1
18752: ST_TO_ADDR
18753: GO 18705
18755: POP
18756: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18757: LD_ADDR_EXP 99
18761: PUSH
18762: LD_EXP 99
18766: PPUSH
18767: LD_INT 4
18769: PPUSH
18770: LD_EXP 99
18774: PUSH
18775: LD_INT 4
18777: ARRAY
18778: PUSH
18779: LD_EXP 18
18783: PUSH
18784: LD_INT 1
18786: ARRAY
18787: DIFF
18788: PPUSH
18789: CALL_OW 1
18793: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18794: LD_VAR 0 5
18798: PUSH
18799: LD_INT 1
18801: ARRAY
18802: PPUSH
18803: CALL_OW 313
18807: IFFALSE 18862
// begin for i in UnitsInside ( arm [ 1 ] ) do
18809: LD_ADDR_VAR 0 1
18813: PUSH
18814: LD_VAR 0 5
18818: PUSH
18819: LD_INT 1
18821: ARRAY
18822: PPUSH
18823: CALL_OW 313
18827: PUSH
18828: FOR_IN
18829: IFFALSE 18860
// begin ComExitBuilding ( i ) ;
18831: LD_VAR 0 1
18835: PPUSH
18836: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18840: LD_VAR 0 1
18844: PPUSH
18845: LD_VAR 0 6
18849: PUSH
18850: LD_INT 1
18852: ARRAY
18853: PPUSH
18854: CALL_OW 180
// end ;
18858: GO 18828
18860: POP
18861: POP
// end ; wait ( 0 0$3 ) ;
18862: LD_INT 105
18864: PPUSH
18865: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18869: LD_ADDR_VAR 0 1
18873: PUSH
18874: LD_EXP 18
18878: PUSH
18879: LD_INT 1
18881: ARRAY
18882: PUSH
18883: FOR_IN
18884: IFFALSE 18991
// begin if IsInUnit ( i ) then
18886: LD_VAR 0 1
18890: PPUSH
18891: CALL_OW 310
18895: IFFALSE 18906
// ComExitBuilding ( i ) ;
18897: LD_VAR 0 1
18901: PPUSH
18902: CALL_OW 122
// if GetClass ( i ) <> 1 then
18906: LD_VAR 0 1
18910: PPUSH
18911: CALL_OW 257
18915: PUSH
18916: LD_INT 1
18918: NONEQUAL
18919: IFFALSE 18960
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
18921: LD_VAR 0 1
18925: PPUSH
18926: LD_VAR 0 5
18930: PUSH
18931: LD_INT 1
18933: ARRAY
18934: PPUSH
18935: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
18939: LD_VAR 0 1
18943: PPUSH
18944: LD_INT 1
18946: PPUSH
18947: CALL_OW 183
// AddComExitBuilding ( i ) ;
18951: LD_VAR 0 1
18955: PPUSH
18956: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
18960: LD_VAR 0 1
18964: PPUSH
18965: LD_INT 60
18967: PPUSH
18968: LD_INT 94
18970: PPUSH
18971: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
18975: LD_VAR 0 1
18979: PPUSH
18980: LD_EXP 55
18984: PPUSH
18985: CALL_OW 179
// end ;
18989: GO 18883
18991: POP
18992: POP
// wait ( 0 0$15 ) ;
18993: LD_INT 525
18995: PPUSH
18996: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19000: LD_EXP 55
19004: PPUSH
19005: LD_STRING D4-Pow-1
19007: PPUSH
19008: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19012: LD_ADDR_VAR 0 2
19016: PUSH
19017: LD_EXP 18
19021: PUSH
19022: LD_INT 1
19024: ARRAY
19025: PPUSH
19026: LD_INT 26
19028: PUSH
19029: LD_INT 1
19031: PUSH
19032: EMPTY
19033: LIST
19034: LIST
19035: PPUSH
19036: CALL_OW 72
19040: ST_TO_ADDR
// if tmp then
19041: LD_VAR 0 2
19045: IFFALSE 19063
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19047: LD_VAR 0 2
19051: PUSH
19052: LD_INT 1
19054: ARRAY
19055: PPUSH
19056: LD_STRING D4-Sol1-1
19058: PPUSH
19059: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19063: LD_EXP 55
19067: PPUSH
19068: LD_STRING D4-Pow-2
19070: PPUSH
19071: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19075: LD_ADDR_VAR 0 1
19079: PUSH
19080: DOUBLE
19081: LD_INT 1
19083: DEC
19084: ST_TO_ADDR
19085: LD_EXP 18
19089: PUSH
19090: LD_INT 1
19092: ARRAY
19093: PUSH
19094: FOR_TO
19095: IFFALSE 19188
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19097: LD_EXP 18
19101: PUSH
19102: LD_INT 1
19104: ARRAY
19105: PUSH
19106: LD_VAR 0 1
19110: ARRAY
19111: PPUSH
19112: LD_EXP 118
19116: PUSH
19117: LD_INT 4
19119: ARRAY
19120: PUSH
19121: LD_INT 1
19123: ARRAY
19124: PPUSH
19125: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19129: LD_ADDR_EXP 118
19133: PUSH
19134: LD_EXP 118
19138: PPUSH
19139: LD_INT 4
19141: PPUSH
19142: LD_EXP 118
19146: PUSH
19147: LD_INT 4
19149: ARRAY
19150: PPUSH
19151: LD_INT 1
19153: PPUSH
19154: CALL_OW 3
19158: PPUSH
19159: CALL_OW 1
19163: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19164: LD_INT 8
19166: PPUSH
19167: LD_EXP 18
19171: PUSH
19172: LD_INT 1
19174: ARRAY
19175: PUSH
19176: LD_VAR 0 1
19180: ARRAY
19181: PPUSH
19182: CALL_OW 471
// end ;
19186: GO 19094
19188: POP
19189: POP
// repeat wait ( 0 0$1 ) ;
19190: LD_INT 35
19192: PPUSH
19193: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19197: LD_EXP 18
19201: PUSH
19202: LD_INT 1
19204: ARRAY
19205: PPUSH
19206: LD_INT 55
19208: PUSH
19209: EMPTY
19210: LIST
19211: PPUSH
19212: CALL_OW 72
19216: PUSH
19217: LD_INT 4
19219: GREATEREQUAL
19220: IFFALSE 19190
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19222: LD_EXP 18
19226: PUSH
19227: LD_INT 1
19229: ARRAY
19230: PPUSH
19231: LD_INT 69
19233: PPUSH
19234: LD_INT 94
19236: PPUSH
19237: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19241: LD_EXP 18
19245: PUSH
19246: LD_INT 1
19248: ARRAY
19249: PPUSH
19250: LD_INT 82
19252: PPUSH
19253: LD_INT 83
19255: PPUSH
19256: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19260: LD_EXP 18
19264: PUSH
19265: LD_INT 1
19267: ARRAY
19268: PPUSH
19269: LD_INT 77
19271: PPUSH
19272: LD_INT 69
19274: PPUSH
19275: CALL_OW 174
// repeat wait ( 3 ) ;
19279: LD_INT 3
19281: PPUSH
19282: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19286: LD_ADDR_VAR 0 1
19290: PUSH
19291: LD_EXP 18
19295: PUSH
19296: LD_INT 1
19298: ARRAY
19299: PUSH
19300: FOR_IN
19301: IFFALSE 19437
// begin if GetLives ( i ) < 990 then
19303: LD_VAR 0 1
19307: PPUSH
19308: CALL_OW 256
19312: PUSH
19313: LD_INT 990
19315: LESS
19316: IFFALSE 19330
// SetLives ( i , 1000 ) ;
19318: LD_VAR 0 1
19322: PPUSH
19323: LD_INT 1000
19325: PPUSH
19326: CALL_OW 234
// if not IsInUnit ( i ) then
19330: LD_VAR 0 1
19334: PPUSH
19335: CALL_OW 310
19339: NOT
19340: IFFALSE 19435
// begin if not HasTask ( i ) then
19342: LD_VAR 0 1
19346: PPUSH
19347: CALL_OW 314
19351: NOT
19352: IFFALSE 19369
// ComMoveXY ( i , 64 , 93 ) ;
19354: LD_VAR 0 1
19358: PPUSH
19359: LD_INT 64
19361: PPUSH
19362: LD_INT 93
19364: PPUSH
19365: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19369: LD_VAR 0 4
19373: NOT
19374: PUSH
19375: LD_VAR 0 1
19379: PPUSH
19380: CALL_OW 258
19384: PUSH
19385: LD_INT 1
19387: EQUAL
19388: AND
19389: IFFALSE 19435
// begin retreat := true ;
19391: LD_ADDR_VAR 0 4
19395: PUSH
19396: LD_INT 1
19398: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19399: LD_VAR 0 1
19403: PPUSH
19404: LD_INT 2
19406: PPUSH
19407: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19411: LD_VAR 0 1
19415: PPUSH
19416: LD_STRING D4a-Sol1-1
19418: PPUSH
19419: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19423: LD_EXP 55
19427: PPUSH
19428: LD_STRING D4a-Pow-1
19430: PPUSH
19431: CALL_OW 88
// end ; end ; end ;
19435: GO 19300
19437: POP
19438: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19439: LD_EXP 18
19443: PUSH
19444: LD_INT 1
19446: ARRAY
19447: PPUSH
19448: LD_INT 95
19450: PUSH
19451: LD_INT 9
19453: PUSH
19454: EMPTY
19455: LIST
19456: LIST
19457: PUSH
19458: LD_INT 3
19460: PUSH
19461: LD_INT 55
19463: PUSH
19464: EMPTY
19465: LIST
19466: PUSH
19467: EMPTY
19468: LIST
19469: LIST
19470: PUSH
19471: EMPTY
19472: LIST
19473: LIST
19474: PPUSH
19475: CALL_OW 72
19479: PUSH
19480: LD_INT 4
19482: GREATEREQUAL
19483: IFFALSE 19279
// for i in powellSquadAttack [ 1 ] do
19485: LD_ADDR_VAR 0 1
19489: PUSH
19490: LD_EXP 18
19494: PUSH
19495: LD_INT 1
19497: ARRAY
19498: PUSH
19499: FOR_IN
19500: IFFALSE 19636
// begin if GetTag ( i ) = 2 then
19502: LD_VAR 0 1
19506: PPUSH
19507: CALL_OW 110
19511: PUSH
19512: LD_INT 2
19514: EQUAL
19515: IFFALSE 19577
// begin ComMoveXY ( i , 60 , 94 ) ;
19517: LD_VAR 0 1
19521: PPUSH
19522: LD_INT 60
19524: PPUSH
19525: LD_INT 94
19527: PPUSH
19528: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19532: LD_VAR 0 1
19536: PPUSH
19537: LD_EXP 55
19541: PPUSH
19542: CALL_OW 179
// wait ( 0 0$3 ) ;
19546: LD_INT 105
19548: PPUSH
19549: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19553: LD_VAR 0 1
19557: PPUSH
19558: LD_STRING D4a-Sol1-2
19560: PPUSH
19561: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19565: LD_EXP 55
19569: PPUSH
19570: LD_STRING D4a-Pow-2
19572: PPUSH
19573: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19577: LD_VAR 0 1
19581: PPUSH
19582: LD_INT 0
19584: PPUSH
19585: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19589: LD_ADDR_EXP 99
19593: PUSH
19594: LD_EXP 99
19598: PPUSH
19599: LD_INT 4
19601: PPUSH
19602: LD_EXP 99
19606: PUSH
19607: LD_INT 4
19609: ARRAY
19610: PUSH
19611: LD_VAR 0 1
19615: UNION
19616: PPUSH
19617: CALL_OW 1
19621: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19622: LD_INT 8
19624: PPUSH
19625: LD_VAR 0 1
19629: PPUSH
19630: CALL_OW 472
// end ;
19634: GO 19499
19636: POP
19637: POP
// wait ( 4 4$00 ) ;
19638: LD_INT 8400
19640: PPUSH
19641: CALL_OW 67
// uc_side := 6 ;
19645: LD_ADDR_OWVAR 20
19649: PUSH
19650: LD_INT 6
19652: ST_TO_ADDR
// uc_nation := 3 ;
19653: LD_ADDR_OWVAR 21
19657: PUSH
19658: LD_INT 3
19660: ST_TO_ADDR
// ru := [ ] ;
19661: LD_ADDR_VAR 0 7
19665: PUSH
19666: EMPTY
19667: ST_TO_ADDR
// for i = 1 to 4 do
19668: LD_ADDR_VAR 0 1
19672: PUSH
19673: DOUBLE
19674: LD_INT 1
19676: DEC
19677: ST_TO_ADDR
19678: LD_INT 4
19680: PUSH
19681: FOR_TO
19682: IFFALSE 19783
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19684: LD_INT 22
19686: PPUSH
19687: LD_INT 1
19689: PPUSH
19690: LD_INT 3
19692: PPUSH
19693: LD_INT 43
19695: PUSH
19696: LD_INT 44
19698: PUSH
19699: EMPTY
19700: LIST
19701: LIST
19702: PUSH
19703: LD_INT 1
19705: PPUSH
19706: LD_INT 2
19708: PPUSH
19709: CALL_OW 12
19713: ARRAY
19714: PPUSH
19715: LD_INT 89
19717: PPUSH
19718: CALL 69527 0 5
// un := CreateVehicle ;
19722: LD_ADDR_VAR 0 8
19726: PUSH
19727: CALL_OW 45
19731: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19732: LD_VAR 0 8
19736: PPUSH
19737: LD_INT 4
19739: PPUSH
19740: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19744: LD_VAR 0 8
19748: PPUSH
19749: LD_INT 136
19751: PPUSH
19752: LD_INT 90
19754: PPUSH
19755: LD_INT 8
19757: PPUSH
19758: LD_INT 0
19760: PPUSH
19761: CALL_OW 50
// ru := ru ^ un ;
19765: LD_ADDR_VAR 0 7
19769: PUSH
19770: LD_VAR 0 7
19774: PUSH
19775: LD_VAR 0 8
19779: ADD
19780: ST_TO_ADDR
// end ;
19781: GO 19681
19783: POP
19784: POP
// if ru then
19785: LD_VAR 0 7
19789: IFFALSE 19806
// ComAgressiveMove ( ru , 80 , 92 ) ;
19791: LD_VAR 0 7
19795: PPUSH
19796: LD_INT 80
19798: PPUSH
19799: LD_INT 92
19801: PPUSH
19802: CALL_OW 114
// wait ( 8 8$00 ) ;
19806: LD_INT 16800
19808: PPUSH
19809: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19813: LD_INT 4
19815: PPUSH
19816: LD_INT 3
19818: PUSH
19819: LD_INT 1
19821: PUSH
19822: LD_INT 1
19824: PUSH
19825: LD_INT 5
19827: PUSH
19828: EMPTY
19829: LIST
19830: LIST
19831: LIST
19832: LIST
19833: PUSH
19834: LD_INT 4
19836: PUSH
19837: LD_INT 1
19839: PUSH
19840: LD_INT 1
19842: PUSH
19843: LD_INT 6
19845: PUSH
19846: EMPTY
19847: LIST
19848: LIST
19849: LIST
19850: LIST
19851: PUSH
19852: LD_INT 4
19854: PUSH
19855: LD_INT 1
19857: PUSH
19858: LD_INT 1
19860: PUSH
19861: LD_INT 7
19863: PUSH
19864: EMPTY
19865: LIST
19866: LIST
19867: LIST
19868: LIST
19869: PUSH
19870: LD_INT 3
19872: PUSH
19873: LD_INT 1
19875: PUSH
19876: LD_INT 1
19878: PUSH
19879: LD_INT 7
19881: PUSH
19882: EMPTY
19883: LIST
19884: LIST
19885: LIST
19886: LIST
19887: PUSH
19888: LD_INT 3
19890: PUSH
19891: LD_INT 1
19893: PUSH
19894: LD_INT 1
19896: PUSH
19897: LD_INT 5
19899: PUSH
19900: EMPTY
19901: LIST
19902: LIST
19903: LIST
19904: LIST
19905: PUSH
19906: EMPTY
19907: LIST
19908: LIST
19909: LIST
19910: LIST
19911: LIST
19912: PPUSH
19913: CALL 56874 0 2
// missionStage := 4 ;
19917: LD_ADDR_EXP 15
19921: PUSH
19922: LD_INT 4
19924: ST_TO_ADDR
// end ;
19925: PPOPN 8
19927: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
19928: LD_EXP 15
19932: PUSH
19933: LD_INT 4
19935: EQUAL
19936: PUSH
19937: LD_INT 22
19939: PUSH
19940: LD_INT 4
19942: PUSH
19943: EMPTY
19944: LIST
19945: LIST
19946: PUSH
19947: LD_INT 21
19949: PUSH
19950: LD_INT 2
19952: PUSH
19953: EMPTY
19954: LIST
19955: LIST
19956: PUSH
19957: EMPTY
19958: LIST
19959: LIST
19960: PPUSH
19961: CALL_OW 69
19965: PUSH
19966: LD_INT 5
19968: GREATEREQUAL
19969: AND
19970: IFFALSE 24056
19972: GO 19974
19974: DISABLE
19975: LD_INT 0
19977: PPUSH
19978: PPUSH
19979: PPUSH
19980: PPUSH
19981: PPUSH
19982: PPUSH
19983: PPUSH
19984: PPUSH
19985: PPUSH
19986: PPUSH
19987: PPUSH
19988: PPUSH
19989: PPUSH
// begin missionStage := 5 ;
19990: LD_ADDR_EXP 15
19994: PUSH
19995: LD_INT 5
19997: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
19998: LD_ADDR_VAR 0 10
20002: PUSH
20003: LD_INT 22
20005: PUSH
20006: LD_INT 4
20008: PUSH
20009: EMPTY
20010: LIST
20011: LIST
20012: PUSH
20013: LD_INT 2
20015: PUSH
20016: LD_INT 30
20018: PUSH
20019: LD_INT 4
20021: PUSH
20022: EMPTY
20023: LIST
20024: LIST
20025: PUSH
20026: LD_INT 30
20028: PUSH
20029: LD_INT 5
20031: PUSH
20032: EMPTY
20033: LIST
20034: LIST
20035: PUSH
20036: EMPTY
20037: LIST
20038: LIST
20039: LIST
20040: PUSH
20041: EMPTY
20042: LIST
20043: LIST
20044: PPUSH
20045: CALL_OW 69
20049: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20050: LD_ADDR_VAR 0 6
20054: PUSH
20055: LD_INT 22
20057: PUSH
20058: LD_INT 4
20060: PUSH
20061: EMPTY
20062: LIST
20063: LIST
20064: PUSH
20065: LD_INT 21
20067: PUSH
20068: LD_INT 1
20070: PUSH
20071: EMPTY
20072: LIST
20073: LIST
20074: PUSH
20075: LD_INT 3
20077: PUSH
20078: LD_INT 25
20080: PUSH
20081: LD_INT 16
20083: PUSH
20084: EMPTY
20085: LIST
20086: LIST
20087: PUSH
20088: EMPTY
20089: LIST
20090: LIST
20091: PUSH
20092: LD_INT 3
20094: PUSH
20095: LD_INT 25
20097: PUSH
20098: LD_INT 12
20100: PUSH
20101: EMPTY
20102: LIST
20103: LIST
20104: PUSH
20105: EMPTY
20106: LIST
20107: LIST
20108: PUSH
20109: EMPTY
20110: LIST
20111: LIST
20112: LIST
20113: LIST
20114: PPUSH
20115: CALL_OW 69
20119: PUSH
20120: LD_EXP 55
20124: DIFF
20125: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20126: LD_ADDR_VAR 0 9
20130: PUSH
20131: LD_INT 22
20133: PUSH
20134: LD_INT 4
20136: PUSH
20137: EMPTY
20138: LIST
20139: LIST
20140: PUSH
20141: LD_INT 30
20143: PUSH
20144: LD_INT 3
20146: PUSH
20147: EMPTY
20148: LIST
20149: LIST
20150: PUSH
20151: EMPTY
20152: LIST
20153: LIST
20154: PPUSH
20155: CALL_OW 69
20159: PUSH
20160: LD_INT 1
20162: ARRAY
20163: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20164: LD_INT 35
20166: PPUSH
20167: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20171: LD_EXP 118
20175: PUSH
20176: LD_INT 4
20178: ARRAY
20179: PUSH
20180: LD_INT 5
20182: GREATEREQUAL
20183: PUSH
20184: LD_EXP 118
20188: PUSH
20189: LD_INT 4
20191: ARRAY
20192: PPUSH
20193: LD_INT 58
20195: PUSH
20196: EMPTY
20197: LIST
20198: PPUSH
20199: CALL_OW 72
20203: PUSH
20204: LD_INT 5
20206: GREATEREQUAL
20207: AND
20208: IFFALSE 20164
// powellAllowRetreat := false ;
20210: LD_ADDR_EXP 19
20214: PUSH
20215: LD_INT 0
20217: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20218: LD_INT 700
20220: PPUSH
20221: CALL_OW 67
// activeAttacks := false ;
20225: LD_ADDR_EXP 16
20229: PUSH
20230: LD_INT 0
20232: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20233: LD_INT 35
20235: PPUSH
20236: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20240: LD_INT 22
20242: PUSH
20243: LD_INT 6
20245: PUSH
20246: EMPTY
20247: LIST
20248: LIST
20249: PPUSH
20250: CALL_OW 69
20254: PUSH
20255: LD_INT 0
20257: EQUAL
20258: IFFALSE 20233
// tmp := mc_vehicles [ 4 ] ;
20260: LD_ADDR_VAR 0 3
20264: PUSH
20265: LD_EXP 118
20269: PUSH
20270: LD_INT 4
20272: ARRAY
20273: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20274: LD_ADDR_VAR 0 1
20278: PUSH
20279: DOUBLE
20280: LD_INT 1
20282: DEC
20283: ST_TO_ADDR
20284: LD_EXP 18
20288: PUSH
20289: FOR_TO
20290: IFFALSE 20551
// begin for j in powellSquadAttack [ i ] do
20292: LD_ADDR_VAR 0 2
20296: PUSH
20297: LD_EXP 18
20301: PUSH
20302: LD_VAR 0 1
20306: ARRAY
20307: PUSH
20308: FOR_IN
20309: IFFALSE 20547
// begin forces := forces diff j ;
20311: LD_ADDR_VAR 0 6
20315: PUSH
20316: LD_VAR 0 6
20320: PUSH
20321: LD_VAR 0 2
20325: DIFF
20326: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20327: LD_VAR 0 2
20331: PPUSH
20332: LD_INT 1
20334: PPUSH
20335: CALL_OW 109
// wait ( 0 0$2 ) ;
20339: LD_INT 70
20341: PPUSH
20342: CALL_OW 67
// if IsInUnit ( j ) then
20346: LD_VAR 0 2
20350: PPUSH
20351: CALL_OW 310
20355: IFFALSE 20366
// ComExitBuilding ( j ) ;
20357: LD_VAR 0 2
20361: PPUSH
20362: CALL_OW 122
// if GetClass ( j ) <> 1 then
20366: LD_VAR 0 2
20370: PPUSH
20371: CALL_OW 257
20375: PUSH
20376: LD_INT 1
20378: NONEQUAL
20379: IFFALSE 20459
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20381: LD_VAR 0 10
20385: PUSH
20386: LD_INT 1
20388: ARRAY
20389: PPUSH
20390: CALL_OW 313
20394: PUSH
20395: LD_INT 5
20397: GREATEREQUAL
20398: IFFALSE 20420
// AddComEnterUnit ( j , arm [ 2 ] ) else
20400: LD_VAR 0 2
20404: PPUSH
20405: LD_VAR 0 10
20409: PUSH
20410: LD_INT 2
20412: ARRAY
20413: PPUSH
20414: CALL_OW 180
20418: GO 20438
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20420: LD_VAR 0 2
20424: PPUSH
20425: LD_VAR 0 10
20429: PUSH
20430: LD_INT 1
20432: ARRAY
20433: PPUSH
20434: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20438: LD_VAR 0 2
20442: PPUSH
20443: LD_INT 1
20445: PPUSH
20446: CALL_OW 183
// AddComExitBuilding ( j ) ;
20450: LD_VAR 0 2
20454: PPUSH
20455: CALL_OW 182
// end ; if i = 2 then
20459: LD_VAR 0 1
20463: PUSH
20464: LD_INT 2
20466: EQUAL
20467: IFFALSE 20484
// AddComMoveXY ( j , 61 , 93 ) ;
20469: LD_VAR 0 2
20473: PPUSH
20474: LD_INT 61
20476: PPUSH
20477: LD_INT 93
20479: PPUSH
20480: CALL_OW 171
// if i = 1 then
20484: LD_VAR 0 1
20488: PUSH
20489: LD_INT 1
20491: EQUAL
20492: IFFALSE 20545
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20494: LD_VAR 0 2
20498: PPUSH
20499: LD_VAR 0 3
20503: PUSH
20504: LD_INT 1
20506: ARRAY
20507: PPUSH
20508: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20512: LD_ADDR_VAR 0 3
20516: PUSH
20517: LD_VAR 0 3
20521: PPUSH
20522: LD_INT 1
20524: PPUSH
20525: CALL_OW 3
20529: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20530: LD_VAR 0 2
20534: PPUSH
20535: LD_INT 69
20537: PPUSH
20538: LD_INT 94
20540: PPUSH
20541: CALL_OW 171
// end ; end ;
20545: GO 20308
20547: POP
20548: POP
// end ;
20549: GO 20289
20551: POP
20552: POP
// wait ( 0 0$55 ) ;
20553: LD_INT 1925
20555: PPUSH
20556: CALL_OW 67
// MC_Kill ( 4 ) ;
20560: LD_INT 4
20562: PPUSH
20563: CALL 33936 0 1
// tmp := UnitsInside ( fac ) ;
20567: LD_ADDR_VAR 0 3
20571: PUSH
20572: LD_VAR 0 9
20576: PPUSH
20577: CALL_OW 313
20581: ST_TO_ADDR
// if tmp then
20582: LD_VAR 0 3
20586: IFFALSE 20707
// for i in tmp do
20588: LD_ADDR_VAR 0 1
20592: PUSH
20593: LD_VAR 0 3
20597: PUSH
20598: FOR_IN
20599: IFFALSE 20705
// begin ComExitBuilding ( i ) ;
20601: LD_VAR 0 1
20605: PPUSH
20606: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20610: LD_VAR 0 10
20614: PUSH
20615: LD_INT 2
20617: ARRAY
20618: PPUSH
20619: CALL_OW 313
20623: PUSH
20624: LD_INT 6
20626: LESS
20627: IFFALSE 20649
// AddComEnterUnit ( i , arm [ 2 ] ) else
20629: LD_VAR 0 1
20633: PPUSH
20634: LD_VAR 0 10
20638: PUSH
20639: LD_INT 2
20641: ARRAY
20642: PPUSH
20643: CALL_OW 180
20647: GO 20703
// if UnitsInside ( arm [ 1 ] ) < 6 then
20649: LD_VAR 0 10
20653: PUSH
20654: LD_INT 1
20656: ARRAY
20657: PPUSH
20658: CALL_OW 313
20662: PUSH
20663: LD_INT 6
20665: LESS
20666: IFFALSE 20688
// AddComEnterUnit ( i , arm [ 1 ] ) else
20668: LD_VAR 0 1
20672: PPUSH
20673: LD_VAR 0 10
20677: PUSH
20678: LD_INT 1
20680: ARRAY
20681: PPUSH
20682: CALL_OW 180
20686: GO 20703
// AddComMoveXY ( i , 37 , 68 ) ;
20688: LD_VAR 0 1
20692: PPUSH
20693: LD_INT 37
20695: PPUSH
20696: LD_INT 68
20698: PPUSH
20699: CALL_OW 171
// end ;
20703: GO 20598
20705: POP
20706: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20707: LD_ADDR_VAR 0 11
20711: PUSH
20712: LD_VAR 0 6
20716: PPUSH
20717: LD_INT 26
20719: PUSH
20720: LD_INT 1
20722: PUSH
20723: EMPTY
20724: LIST
20725: LIST
20726: PPUSH
20727: CALL_OW 72
20731: PUSH
20732: LD_EXP 56
20736: DIFF
20737: ST_TO_ADDR
// if not speaker then
20738: LD_VAR 0 11
20742: NOT
20743: IFFALSE 20770
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20745: LD_ADDR_VAR 0 11
20749: PUSH
20750: LD_VAR 0 6
20754: PPUSH
20755: LD_INT 26
20757: PUSH
20758: LD_INT 1
20760: PUSH
20761: EMPTY
20762: LIST
20763: LIST
20764: PPUSH
20765: CALL_OW 72
20769: ST_TO_ADDR
// if speaker then
20770: LD_VAR 0 11
20774: IFFALSE 20790
// speaker := speaker [ 1 ] ;
20776: LD_ADDR_VAR 0 11
20780: PUSH
20781: LD_VAR 0 11
20785: PUSH
20786: LD_INT 1
20788: ARRAY
20789: ST_TO_ADDR
// Video ( true ) ;
20790: LD_INT 1
20792: PPUSH
20793: CALL 105244 0 1
// CenterNowOnUnits ( Powell ) ;
20797: LD_EXP 55
20801: PPUSH
20802: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20806: LD_ADDR_VAR 0 3
20810: PUSH
20811: LD_VAR 0 6
20815: PPUSH
20816: LD_INT 3
20818: PUSH
20819: LD_INT 25
20821: PUSH
20822: LD_INT 1
20824: PUSH
20825: EMPTY
20826: LIST
20827: LIST
20828: PUSH
20829: EMPTY
20830: LIST
20831: LIST
20832: PPUSH
20833: CALL_OW 72
20837: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20838: LD_ADDR_VAR 0 12
20842: PUSH
20843: LD_INT 22
20845: PUSH
20846: LD_INT 4
20848: PUSH
20849: EMPTY
20850: LIST
20851: LIST
20852: PUSH
20853: LD_INT 30
20855: PUSH
20856: LD_INT 32
20858: PUSH
20859: EMPTY
20860: LIST
20861: LIST
20862: PUSH
20863: LD_INT 58
20865: PUSH
20866: EMPTY
20867: LIST
20868: PUSH
20869: EMPTY
20870: LIST
20871: LIST
20872: LIST
20873: PPUSH
20874: CALL_OW 69
20878: ST_TO_ADDR
// for i = 1 to 6 do
20879: LD_ADDR_VAR 0 1
20883: PUSH
20884: DOUBLE
20885: LD_INT 1
20887: DEC
20888: ST_TO_ADDR
20889: LD_INT 6
20891: PUSH
20892: FOR_TO
20893: IFFALSE 21034
// begin if IsInUnit ( tmp [ i ] ) then
20895: LD_VAR 0 3
20899: PUSH
20900: LD_VAR 0 1
20904: ARRAY
20905: PPUSH
20906: CALL_OW 310
20910: IFFALSE 20927
// ComExitBuilding ( tmp [ i ] ) ;
20912: LD_VAR 0 3
20916: PUSH
20917: LD_VAR 0 1
20921: ARRAY
20922: PPUSH
20923: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
20927: LD_VAR 0 3
20931: PUSH
20932: LD_VAR 0 1
20936: ARRAY
20937: PPUSH
20938: LD_VAR 0 10
20942: PUSH
20943: LD_INT 1
20945: ARRAY
20946: PPUSH
20947: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
20951: LD_VAR 0 3
20955: PUSH
20956: LD_VAR 0 1
20960: ARRAY
20961: PPUSH
20962: LD_INT 1
20964: PPUSH
20965: CALL_OW 183
// if emp_towers then
20969: LD_VAR 0 12
20973: IFFALSE 21032
// begin AddComExitBuilding ( tmp [ i ] ) ;
20975: LD_VAR 0 3
20979: PUSH
20980: LD_VAR 0 1
20984: ARRAY
20985: PPUSH
20986: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
20990: LD_VAR 0 3
20994: PUSH
20995: LD_VAR 0 1
20999: ARRAY
21000: PPUSH
21001: LD_VAR 0 12
21005: PUSH
21006: LD_INT 1
21008: ARRAY
21009: PPUSH
21010: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21014: LD_ADDR_VAR 0 12
21018: PUSH
21019: LD_VAR 0 12
21023: PPUSH
21024: LD_INT 1
21026: PPUSH
21027: CALL_OW 3
21031: ST_TO_ADDR
// end ; end ;
21032: GO 20892
21034: POP
21035: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21036: LD_ADDR_VAR 0 3
21040: PUSH
21041: LD_EXP 18
21045: PUSH
21046: LD_INT 1
21048: ARRAY
21049: PUSH
21050: LD_EXP 18
21054: PUSH
21055: LD_INT 2
21057: ARRAY
21058: ADD
21059: PPUSH
21060: LD_INT 26
21062: PUSH
21063: LD_INT 1
21065: PUSH
21066: EMPTY
21067: LIST
21068: LIST
21069: PPUSH
21070: CALL_OW 72
21074: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21075: LD_ADDR_VAR 0 1
21079: PUSH
21080: LD_EXP 18
21084: PUSH
21085: LD_INT 2
21087: ARRAY
21088: PUSH
21089: FOR_IN
21090: IFFALSE 21108
// ComTurnUnit ( i , Powell ) ;
21092: LD_VAR 0 1
21096: PPUSH
21097: LD_EXP 55
21101: PPUSH
21102: CALL_OW 119
21106: GO 21089
21108: POP
21109: POP
// Say ( Powell , D5-Pow-1 ) ;
21110: LD_EXP 55
21114: PPUSH
21115: LD_STRING D5-Pow-1
21117: PPUSH
21118: CALL_OW 88
// if tmp then
21122: LD_VAR 0 3
21126: IFFALSE 21144
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21128: LD_VAR 0 3
21132: PUSH
21133: LD_INT 1
21135: ARRAY
21136: PPUSH
21137: LD_STRING D5-Sol2-1
21139: PPUSH
21140: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21144: LD_EXP 55
21148: PPUSH
21149: LD_STRING D5-Pow-2
21151: PPUSH
21152: CALL_OW 88
// if tmp > 1 then
21156: LD_VAR 0 3
21160: PUSH
21161: LD_INT 1
21163: GREATER
21164: IFFALSE 21182
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21166: LD_VAR 0 3
21170: PUSH
21171: LD_INT 2
21173: ARRAY
21174: PPUSH
21175: LD_STRING D5-Sol2-2
21177: PPUSH
21178: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21182: LD_EXP 55
21186: PPUSH
21187: LD_STRING D5-Pow-3
21189: PPUSH
21190: CALL_OW 88
// wait ( 0 0$1 ) ;
21194: LD_INT 35
21196: PPUSH
21197: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21201: LD_ADDR_VAR 0 3
21205: PUSH
21206: LD_EXP 18
21210: PUSH
21211: LD_INT 1
21213: ARRAY
21214: PUSH
21215: LD_EXP 18
21219: PUSH
21220: LD_INT 2
21222: ARRAY
21223: UNION
21224: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21225: LD_VAR 0 3
21229: PPUSH
21230: LD_INT 80
21232: PPUSH
21233: LD_INT 67
21235: PPUSH
21236: CALL_OW 114
// wait ( 0 0$2 ) ;
21240: LD_INT 70
21242: PPUSH
21243: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21247: LD_INT 79
21249: PPUSH
21250: LD_INT 72
21252: PPUSH
21253: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21257: LD_INT 35
21259: PPUSH
21260: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21264: LD_VAR 0 3
21268: PPUSH
21269: LD_INT 3
21271: PUSH
21272: LD_INT 24
21274: PUSH
21275: LD_INT 1000
21277: PUSH
21278: EMPTY
21279: LIST
21280: LIST
21281: PUSH
21282: EMPTY
21283: LIST
21284: LIST
21285: PPUSH
21286: CALL_OW 72
21290: IFFALSE 21257
// Say ( Powell , D5a-Pow-1 ) ;
21292: LD_EXP 55
21296: PPUSH
21297: LD_STRING D5a-Pow-1
21299: PPUSH
21300: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21304: LD_EXP 55
21308: PPUSH
21309: LD_STRING D5a-Pow-1a
21311: PPUSH
21312: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21316: LD_INT 10
21318: PPUSH
21319: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21323: LD_EXP 55
21327: PPUSH
21328: LD_STRING D5a-Pow-1b
21330: PPUSH
21331: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21335: LD_EXP 55
21339: PPUSH
21340: LD_STRING D5a-Pow-1c
21342: PPUSH
21343: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21347: LD_EXP 55
21351: PPUSH
21352: LD_STRING D5a-Pow-1d
21354: PPUSH
21355: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21359: LD_INT 35
21361: PPUSH
21362: CALL_OW 67
// if not HasTask ( tmp ) then
21366: LD_VAR 0 3
21370: PPUSH
21371: CALL_OW 314
21375: NOT
21376: IFFALSE 21393
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21378: LD_VAR 0 3
21382: PPUSH
21383: LD_INT 80
21385: PPUSH
21386: LD_INT 67
21388: PPUSH
21389: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21393: LD_VAR 0 3
21397: PPUSH
21398: LD_INT 24
21400: PUSH
21401: LD_INT 1
21403: PUSH
21404: EMPTY
21405: LIST
21406: LIST
21407: PPUSH
21408: CALL_OW 72
21412: NOT
21413: IFFALSE 21359
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21415: LD_ADDR_VAR 0 3
21419: PUSH
21420: LD_INT 22
21422: PUSH
21423: LD_INT 4
21425: PUSH
21426: EMPTY
21427: LIST
21428: LIST
21429: PUSH
21430: LD_INT 92
21432: PUSH
21433: LD_INT 60
21435: PUSH
21436: LD_INT 93
21438: PUSH
21439: LD_INT 10
21441: PUSH
21442: EMPTY
21443: LIST
21444: LIST
21445: LIST
21446: LIST
21447: PUSH
21448: LD_INT 3
21450: PUSH
21451: LD_INT 54
21453: PUSH
21454: EMPTY
21455: LIST
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: PUSH
21461: EMPTY
21462: LIST
21463: LIST
21464: LIST
21465: PPUSH
21466: CALL_OW 69
21470: PUSH
21471: LD_EXP 55
21475: DIFF
21476: ST_TO_ADDR
// if tmp then
21477: LD_VAR 0 3
21481: IFFALSE 21515
// for i in tmp do
21483: LD_ADDR_VAR 0 1
21487: PUSH
21488: LD_VAR 0 3
21492: PUSH
21493: FOR_IN
21494: IFFALSE 21513
// ComMoveXY ( i , 36 , 67 ) ;
21496: LD_VAR 0 1
21500: PPUSH
21501: LD_INT 36
21503: PPUSH
21504: LD_INT 67
21506: PPUSH
21507: CALL_OW 111
21511: GO 21493
21513: POP
21514: POP
// wait ( 0 0$3 ) ;
21515: LD_INT 105
21517: PPUSH
21518: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21522: LD_VAR 0 11
21526: PPUSH
21527: LD_STRING D6-Sol3-1
21529: PPUSH
21530: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21534: LD_EXP 55
21538: PPUSH
21539: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21543: LD_EXP 55
21547: PPUSH
21548: LD_STRING D6-Pow-1
21550: PPUSH
21551: CALL_OW 88
// tmp := [ ] ;
21555: LD_ADDR_VAR 0 3
21559: PUSH
21560: EMPTY
21561: ST_TO_ADDR
// for i = 1 to 2 do
21562: LD_ADDR_VAR 0 1
21566: PUSH
21567: DOUBLE
21568: LD_INT 1
21570: DEC
21571: ST_TO_ADDR
21572: LD_INT 2
21574: PUSH
21575: FOR_TO
21576: IFFALSE 21683
// begin uc_side := 8 ;
21578: LD_ADDR_OWVAR 20
21582: PUSH
21583: LD_INT 8
21585: ST_TO_ADDR
// uc_nation := 2 ;
21586: LD_ADDR_OWVAR 21
21590: PUSH
21591: LD_INT 2
21593: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21594: LD_INT 14
21596: PPUSH
21597: LD_INT 3
21599: PPUSH
21600: LD_INT 2
21602: PPUSH
21603: LD_INT 29
21605: PPUSH
21606: LD_INT 100
21608: PPUSH
21609: CALL 69527 0 5
// veh := CreateVehicle ;
21613: LD_ADDR_VAR 0 13
21617: PUSH
21618: CALL_OW 45
21622: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21623: LD_VAR 0 13
21627: PPUSH
21628: LD_INT 4
21630: PPUSH
21631: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 5 , false ) ;
21635: LD_VAR 0 13
21639: PPUSH
21640: LD_INT 99
21642: PPUSH
21643: LD_INT 83
21645: PPUSH
21646: LD_INT 5
21648: PPUSH
21649: LD_INT 0
21651: PPUSH
21652: CALL_OW 50
// Connect ( veh ) ;
21656: LD_VAR 0 13
21660: PPUSH
21661: CALL 72582 0 1
// tmp := tmp ^ veh ;
21665: LD_ADDR_VAR 0 3
21669: PUSH
21670: LD_VAR 0 3
21674: PUSH
21675: LD_VAR 0 13
21679: ADD
21680: ST_TO_ADDR
// end ;
21681: GO 21575
21683: POP
21684: POP
// wait ( 0 0$1 ) ;
21685: LD_INT 35
21687: PPUSH
21688: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21692: LD_INT 99
21694: PPUSH
21695: LD_INT 83
21697: PPUSH
21698: LD_INT 1
21700: PPUSH
21701: LD_INT 10
21703: PPUSH
21704: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21708: LD_INT 99
21710: PPUSH
21711: LD_INT 83
21713: PPUSH
21714: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21718: LD_VAR 0 11
21722: PPUSH
21723: LD_STRING D6-Sol3-2
21725: PPUSH
21726: CALL_OW 88
// async ;
21730: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21731: LD_EXP 55
21735: PPUSH
21736: LD_STRING D6-Pow-2
21738: PPUSH
21739: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21743: LD_VAR 0 3
21747: PUSH
21748: LD_INT 1
21750: ARRAY
21751: PPUSH
21752: LD_VAR 0 9
21756: PPUSH
21757: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21761: LD_VAR 0 3
21765: PUSH
21766: LD_INT 2
21768: ARRAY
21769: PPUSH
21770: LD_INT 22
21772: PUSH
21773: LD_INT 4
21775: PUSH
21776: EMPTY
21777: LIST
21778: LIST
21779: PUSH
21780: LD_INT 21
21782: PUSH
21783: LD_INT 3
21785: PUSH
21786: EMPTY
21787: LIST
21788: LIST
21789: PUSH
21790: EMPTY
21791: LIST
21792: LIST
21793: PPUSH
21794: CALL_OW 69
21798: PPUSH
21799: LD_VAR 0 3
21803: PUSH
21804: LD_INT 2
21806: ARRAY
21807: PPUSH
21808: CALL_OW 74
21812: PPUSH
21813: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21817: LD_EXP 55
21821: PPUSH
21822: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21826: LD_INT 99
21828: PPUSH
21829: LD_INT 83
21831: PPUSH
21832: LD_INT 1
21834: PPUSH
21835: CALL_OW 331
// repeat wait ( 4 ) ;
21839: LD_INT 4
21841: PPUSH
21842: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21846: LD_VAR 0 3
21850: PUSH
21851: LD_INT 1
21853: ARRAY
21854: PPUSH
21855: CALL_OW 256
21859: PUSH
21860: LD_INT 1000
21862: LESS
21863: IFFALSE 21881
// SetLives ( tmp [ 1 ] , 1000 ) ;
21865: LD_VAR 0 3
21869: PUSH
21870: LD_INT 1
21872: ARRAY
21873: PPUSH
21874: LD_INT 1000
21876: PPUSH
21877: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21881: LD_INT 22
21883: PUSH
21884: LD_INT 4
21886: PUSH
21887: EMPTY
21888: LIST
21889: LIST
21890: PUSH
21891: LD_INT 30
21893: PUSH
21894: LD_INT 3
21896: PUSH
21897: EMPTY
21898: LIST
21899: LIST
21900: PUSH
21901: EMPTY
21902: LIST
21903: LIST
21904: PPUSH
21905: CALL_OW 69
21909: PUSH
21910: LD_INT 0
21912: EQUAL
21913: IFFALSE 21839
// sync ;
21915: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
21916: LD_EXP 55
21920: PPUSH
21921: LD_STRING D6a-Pow-1
21923: PPUSH
21924: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
21928: LD_VAR 0 11
21932: PPUSH
21933: LD_STRING D6a-Sol3-1
21935: PPUSH
21936: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
21940: LD_EXP 55
21944: PPUSH
21945: LD_STRING D6a-Pow-2
21947: PPUSH
21948: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
21952: LD_VAR 0 11
21956: PPUSH
21957: LD_STRING D6a-Sol3-2
21959: PPUSH
21960: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
21964: LD_EXP 55
21968: PPUSH
21969: LD_STRING D6a-Pow-3
21971: PPUSH
21972: CALL_OW 88
// powellCenterCameraMode := true ;
21976: LD_ADDR_EXP 20
21980: PUSH
21981: LD_INT 1
21983: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
21984: LD_ADDR_VAR 0 1
21988: PUSH
21989: LD_INT 22
21991: PUSH
21992: LD_INT 8
21994: PUSH
21995: EMPTY
21996: LIST
21997: LIST
21998: PUSH
21999: LD_INT 25
22001: PUSH
22002: LD_INT 2
22004: PUSH
22005: EMPTY
22006: LIST
22007: LIST
22008: PUSH
22009: EMPTY
22010: LIST
22011: LIST
22012: PPUSH
22013: CALL_OW 69
22017: PUSH
22018: FOR_IN
22019: IFFALSE 22074
// begin SetTag ( i , 1 ) ;
22021: LD_VAR 0 1
22025: PPUSH
22026: LD_INT 1
22028: PPUSH
22029: CALL_OW 109
// ComExitBuilding ( i ) ;
22033: LD_VAR 0 1
22037: PPUSH
22038: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22042: LD_VAR 0 1
22046: PPUSH
22047: LD_INT 35
22049: PPUSH
22050: LD_INT 6
22052: PPUSH
22053: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22057: LD_VAR 0 1
22061: PPUSH
22062: LD_INT 53
22064: PPUSH
22065: LD_INT 4
22067: PPUSH
22068: CALL_OW 171
// end ;
22072: GO 22018
22074: POP
22075: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22076: LD_ADDR_VAR 0 3
22080: PUSH
22081: LD_INT 22
22083: PUSH
22084: LD_INT 4
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: LD_INT 21
22093: PUSH
22094: LD_INT 2
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PUSH
22101: LD_INT 3
22103: PUSH
22104: LD_INT 34
22106: PUSH
22107: LD_INT 12
22109: PUSH
22110: EMPTY
22111: LIST
22112: LIST
22113: PUSH
22114: EMPTY
22115: LIST
22116: LIST
22117: PUSH
22118: EMPTY
22119: LIST
22120: LIST
22121: LIST
22122: PPUSH
22123: CALL_OW 69
22127: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22128: LD_EXP 55
22132: PPUSH
22133: LD_VAR 0 3
22137: PPUSH
22138: LD_EXP 55
22142: PPUSH
22143: CALL_OW 74
22147: PPUSH
22148: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22152: LD_EXP 55
22156: PPUSH
22157: LD_INT 100
22159: PPUSH
22160: LD_INT 88
22162: PPUSH
22163: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22167: LD_EXP 55
22171: PPUSH
22172: LD_INT 100
22174: PPUSH
22175: LD_INT 75
22177: PPUSH
22178: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22182: LD_EXP 55
22186: PPUSH
22187: LD_INT 88
22189: PPUSH
22190: LD_INT 53
22192: PPUSH
22193: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22197: LD_INT 8
22199: PPUSH
22200: LD_EXP 55
22204: PPUSH
22205: CALL_OW 471
// repeat wait ( 3 ) ;
22209: LD_INT 3
22211: PPUSH
22212: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22216: LD_INT 22
22218: PUSH
22219: LD_INT 4
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: PUSH
22226: LD_INT 92
22228: PUSH
22229: LD_INT 100
22231: PUSH
22232: LD_INT 75
22234: PUSH
22235: LD_INT 6
22237: PUSH
22238: EMPTY
22239: LIST
22240: LIST
22241: LIST
22242: LIST
22243: PUSH
22244: EMPTY
22245: LIST
22246: LIST
22247: PPUSH
22248: CALL_OW 69
22252: IFFALSE 22209
// async ;
22254: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22255: LD_EXP 55
22259: PPUSH
22260: LD_STRING D6b-Pow-1
22262: PPUSH
22263: CALL_OW 88
// repeat wait ( 3 ) ;
22267: LD_INT 3
22269: PPUSH
22270: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22274: LD_EXP 55
22278: PPUSH
22279: CALL_OW 310
22283: PPUSH
22284: CALL_OW 256
22288: PUSH
22289: LD_INT 1000
22291: LESS
22292: IFFALSE 22311
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22294: LD_EXP 55
22298: PPUSH
22299: CALL_OW 310
22303: PPUSH
22304: LD_INT 1000
22306: PPUSH
22307: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22311: LD_EXP 55
22315: PPUSH
22316: CALL_OW 256
22320: PUSH
22321: LD_INT 1000
22323: LESS
22324: IFFALSE 22338
// SetLives ( Powell , 1000 ) ;
22326: LD_EXP 55
22330: PPUSH
22331: LD_INT 1000
22333: PPUSH
22334: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22338: LD_EXP 55
22342: PPUSH
22343: LD_EXP 60
22347: PPUSH
22348: CALL_OW 296
22352: PUSH
22353: LD_INT 5
22355: LESS
22356: PUSH
22357: LD_EXP 55
22361: PPUSH
22362: CALL_OW 310
22366: PPUSH
22367: LD_EXP 60
22371: PPUSH
22372: CALL_OW 296
22376: PUSH
22377: LD_INT 5
22379: LESS
22380: OR
22381: IFFALSE 22400
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22383: LD_EXP 55
22387: PPUSH
22388: CALL_OW 310
22392: PPUSH
22393: LD_INT 100
22395: PPUSH
22396: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22400: LD_EXP 55
22404: PPUSH
22405: CALL_OW 310
22409: NOT
22410: IFFALSE 22267
// game_speed := 4 ;
22412: LD_ADDR_OWVAR 65
22416: PUSH
22417: LD_INT 4
22419: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22420: LD_EXP 55
22424: PPUSH
22425: LD_STRING D6b-Pow-1a
22427: PPUSH
22428: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22432: LD_EXP 55
22436: PPUSH
22437: LD_EXP 60
22441: PPUSH
22442: CALL_OW 180
// sync ;
22446: SYNC
// repeat wait ( 0 0$1 ) ;
22447: LD_INT 35
22449: PPUSH
22450: CALL_OW 67
// until IsInUnit ( Powell ) ;
22454: LD_EXP 55
22458: PPUSH
22459: CALL_OW 310
22463: IFFALSE 22447
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22465: LD_INT 8
22467: PPUSH
22468: LD_EXP 55
22472: PPUSH
22473: CALL_OW 310
22477: PPUSH
22478: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22482: LD_EXP 55
22486: PPUSH
22487: LD_INT 91
22489: PPUSH
22490: LD_INT 44
22492: PPUSH
22493: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22497: LD_EXP 55
22501: PPUSH
22502: LD_INT 96
22504: PPUSH
22505: LD_INT 44
22507: PPUSH
22508: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22512: LD_EXP 55
22516: PPUSH
22517: LD_INT 96
22519: PPUSH
22520: LD_INT 41
22522: PPUSH
22523: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22527: LD_EXP 55
22531: PPUSH
22532: LD_INT 92
22534: PPUSH
22535: LD_INT 39
22537: PPUSH
22538: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22542: LD_EXP 55
22546: PPUSH
22547: LD_INT 88
22549: PPUSH
22550: LD_INT 41
22552: PPUSH
22553: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22557: LD_EXP 55
22561: PPUSH
22562: LD_INT 91
22564: PPUSH
22565: LD_INT 44
22567: PPUSH
22568: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22572: LD_EXP 55
22576: PPUSH
22577: LD_INT 96
22579: PPUSH
22580: LD_INT 44
22582: PPUSH
22583: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22587: LD_EXP 55
22591: PPUSH
22592: LD_INT 96
22594: PPUSH
22595: LD_INT 41
22597: PPUSH
22598: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22602: LD_EXP 55
22606: PPUSH
22607: LD_INT 92
22609: PPUSH
22610: LD_INT 39
22612: PPUSH
22613: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22617: LD_EXP 55
22621: PPUSH
22622: LD_INT 88
22624: PPUSH
22625: LD_INT 41
22627: PPUSH
22628: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22632: LD_EXP 55
22636: PPUSH
22637: LD_INT 91
22639: PPUSH
22640: LD_INT 44
22642: PPUSH
22643: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22647: LD_EXP 55
22651: PPUSH
22652: LD_INT 93
22654: PPUSH
22655: LD_INT 39
22657: PPUSH
22658: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22662: LD_EXP 55
22666: PPUSH
22667: LD_INT 93
22669: PPUSH
22670: LD_INT 36
22672: PPUSH
22673: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22677: LD_INT 122
22679: PPUSH
22680: CALL_OW 67
// game_speed := 4 ;
22684: LD_ADDR_OWVAR 65
22688: PUSH
22689: LD_INT 4
22691: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22692: LD_EXP 55
22696: PPUSH
22697: LD_STRING D6b-Pow-1b
22699: PPUSH
22700: CALL_OW 88
// tmp := [ ] ;
22704: LD_ADDR_VAR 0 3
22708: PUSH
22709: EMPTY
22710: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22711: LD_ADDR_VAR 0 5
22715: PUSH
22716: LD_INT 78
22718: PUSH
22719: LD_INT 47
22721: PUSH
22722: EMPTY
22723: LIST
22724: LIST
22725: PUSH
22726: LD_INT 106
22728: PUSH
22729: LD_INT 53
22731: PUSH
22732: EMPTY
22733: LIST
22734: LIST
22735: PUSH
22736: EMPTY
22737: LIST
22738: LIST
22739: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22740: LD_ADDR_VAR 0 1
22744: PUSH
22745: LD_INT 22
22747: PUSH
22748: LD_INT 8
22750: PUSH
22751: EMPTY
22752: LIST
22753: LIST
22754: PUSH
22755: LD_INT 21
22757: PUSH
22758: LD_INT 3
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: PUSH
22765: LD_INT 92
22767: PUSH
22768: LD_INT 90
22770: PUSH
22771: LD_INT 52
22773: PUSH
22774: LD_INT 12
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: LIST
22781: LIST
22782: PUSH
22783: EMPTY
22784: LIST
22785: LIST
22786: LIST
22787: PPUSH
22788: CALL_OW 69
22792: PUSH
22793: FOR_IN
22794: IFFALSE 22819
// tmp := tmp ^ UnitsInside ( i ) ;
22796: LD_ADDR_VAR 0 3
22800: PUSH
22801: LD_VAR 0 3
22805: PUSH
22806: LD_VAR 0 1
22810: PPUSH
22811: CALL_OW 313
22815: ADD
22816: ST_TO_ADDR
22817: GO 22793
22819: POP
22820: POP
// for i in tmp do
22821: LD_ADDR_VAR 0 1
22825: PUSH
22826: LD_VAR 0 3
22830: PUSH
22831: FOR_IN
22832: IFFALSE 22994
// begin dist := 9999 ;
22834: LD_ADDR_VAR 0 8
22838: PUSH
22839: LD_INT 9999
22841: ST_TO_ADDR
// _xy := [ ] ;
22842: LD_ADDR_VAR 0 7
22846: PUSH
22847: EMPTY
22848: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22849: LD_VAR 0 1
22853: PPUSH
22854: LD_INT 1
22856: PPUSH
22857: CALL_OW 109
// ComExitBuilding ( i ) ;
22861: LD_VAR 0 1
22865: PPUSH
22866: CALL_OW 122
// for j in xy do
22870: LD_ADDR_VAR 0 2
22874: PUSH
22875: LD_VAR 0 5
22879: PUSH
22880: FOR_IN
22881: IFFALSE 22963
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22883: LD_VAR 0 1
22887: PPUSH
22888: LD_VAR 0 2
22892: PUSH
22893: LD_INT 1
22895: ARRAY
22896: PPUSH
22897: LD_VAR 0 2
22901: PUSH
22902: LD_INT 2
22904: ARRAY
22905: PPUSH
22906: CALL_OW 297
22910: PUSH
22911: LD_VAR 0 8
22915: LESS
22916: IFFALSE 22961
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
22918: LD_ADDR_VAR 0 8
22922: PUSH
22923: LD_VAR 0 1
22927: PPUSH
22928: LD_VAR 0 2
22932: PUSH
22933: LD_INT 1
22935: ARRAY
22936: PPUSH
22937: LD_VAR 0 2
22941: PUSH
22942: LD_INT 2
22944: ARRAY
22945: PPUSH
22946: CALL_OW 297
22950: ST_TO_ADDR
// _xy := j ;
22951: LD_ADDR_VAR 0 7
22955: PUSH
22956: LD_VAR 0 2
22960: ST_TO_ADDR
// end ;
22961: GO 22880
22963: POP
22964: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
22965: LD_VAR 0 1
22969: PPUSH
22970: LD_VAR 0 7
22974: PUSH
22975: LD_INT 1
22977: ARRAY
22978: PPUSH
22979: LD_VAR 0 7
22983: PUSH
22984: LD_INT 2
22986: ARRAY
22987: PPUSH
22988: CALL_OW 171
// end ;
22992: GO 22831
22994: POP
22995: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
22996: LD_ADDR_VAR 0 4
23000: PUSH
23001: LD_VAR 0 3
23005: PPUSH
23006: LD_INT 26
23008: PUSH
23009: LD_INT 1
23011: PUSH
23012: EMPTY
23013: LIST
23014: LIST
23015: PUSH
23016: LD_INT 25
23018: PUSH
23019: LD_INT 1
23021: PUSH
23022: EMPTY
23023: LIST
23024: LIST
23025: PUSH
23026: EMPTY
23027: LIST
23028: LIST
23029: PPUSH
23030: CALL_OW 72
23034: ST_TO_ADDR
// if tmp2 < 2 then
23035: LD_VAR 0 4
23039: PUSH
23040: LD_INT 2
23042: LESS
23043: IFFALSE 23112
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23045: LD_ADDR_VAR 0 4
23049: PUSH
23050: LD_INT 22
23052: PUSH
23053: LD_INT 8
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: PUSH
23060: LD_INT 26
23062: PUSH
23063: LD_INT 1
23065: PUSH
23066: EMPTY
23067: LIST
23068: LIST
23069: PUSH
23070: LD_INT 3
23072: PUSH
23073: LD_INT 25
23075: PUSH
23076: LD_INT 15
23078: PUSH
23079: EMPTY
23080: LIST
23081: LIST
23082: PUSH
23083: EMPTY
23084: LIST
23085: LIST
23086: PUSH
23087: EMPTY
23088: LIST
23089: LIST
23090: LIST
23091: PPUSH
23092: CALL_OW 69
23096: PUSH
23097: LD_EXP 57
23101: PUSH
23102: LD_EXP 58
23106: PUSH
23107: EMPTY
23108: LIST
23109: LIST
23110: DIFF
23111: ST_TO_ADDR
// if tmp2 then
23112: LD_VAR 0 4
23116: IFFALSE 23134
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23118: LD_VAR 0 4
23122: PUSH
23123: LD_INT 1
23125: ARRAY
23126: PPUSH
23127: LD_STRING D6b-ArSol1-1
23129: PPUSH
23130: CALL_OW 88
// async ;
23134: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23135: LD_EXP 55
23139: PPUSH
23140: LD_STRING D6b-Pow-2
23142: PPUSH
23143: CALL_OW 88
// wait ( 0 0$1 ) ;
23147: LD_INT 35
23149: PPUSH
23150: CALL_OW 67
// if tmp2 > 1 then
23154: LD_VAR 0 4
23158: PUSH
23159: LD_INT 1
23161: GREATER
23162: IFFALSE 23180
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23164: LD_VAR 0 4
23168: PUSH
23169: LD_INT 2
23171: ARRAY
23172: PPUSH
23173: LD_STRING D6b-ArSol2-1
23175: PPUSH
23176: CALL_OW 88
// sync ;
23180: SYNC
// repeat wait ( 5 ) ;
23181: LD_INT 5
23183: PPUSH
23184: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23188: LD_INT 93
23190: PPUSH
23191: LD_INT 36
23193: PPUSH
23194: CALL_OW 428
23198: PPUSH
23199: CALL_OW 255
23203: PUSH
23204: LD_INT 4
23206: EQUAL
23207: IFFALSE 23181
// DialogueOn ;
23209: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23213: LD_INT 10
23215: PPUSH
23216: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23220: LD_EXP 55
23224: PPUSH
23225: LD_STRING D6b-Pow-2a
23227: PPUSH
23228: CALL_OW 88
// DialogueOff ;
23232: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23236: LD_EXP 55
23240: PPUSH
23241: CALL_OW 310
23245: PPUSH
23246: LD_INT 332
23248: PPUSH
23249: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23253: LD_INT 93
23255: PPUSH
23256: LD_INT 35
23258: PPUSH
23259: LD_INT 1
23261: PPUSH
23262: LD_INT 6
23264: NEG
23265: PPUSH
23266: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23270: LD_INT 35
23272: PPUSH
23273: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23277: LD_INT 332
23279: PPUSH
23280: CALL_OW 256
23284: PUSH
23285: LD_INT 1000
23287: LESS
23288: PUSH
23289: LD_INT 332
23291: PPUSH
23292: CALL_OW 300
23296: AND
23297: IFFALSE 23309
// SetLives ( kozlov_fac , 0 ) ;
23299: LD_INT 332
23301: PPUSH
23302: LD_INT 0
23304: PPUSH
23305: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23309: LD_INT 332
23311: PPUSH
23312: CALL_OW 301
23316: PUSH
23317: LD_EXP 55
23321: PPUSH
23322: CALL_OW 301
23326: OR
23327: IFFALSE 23270
// game_speed := 4 ;
23329: LD_ADDR_OWVAR 65
23333: PUSH
23334: LD_INT 4
23336: ST_TO_ADDR
// powellCenterCameraMode := false ;
23337: LD_ADDR_EXP 20
23341: PUSH
23342: LD_INT 0
23344: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23345: LD_ADDR_VAR 0 1
23349: PUSH
23350: LD_VAR 0 3
23354: PUSH
23355: LD_INT 22
23357: PUSH
23358: LD_INT 8
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: PUSH
23365: LD_INT 25
23367: PUSH
23368: LD_INT 2
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: PUSH
23375: EMPTY
23376: LIST
23377: LIST
23378: PPUSH
23379: CALL_OW 69
23383: UNION
23384: PUSH
23385: FOR_IN
23386: IFFALSE 23402
// SetTag ( i , 0 ) ;
23388: LD_VAR 0 1
23392: PPUSH
23393: LD_INT 0
23395: PPUSH
23396: CALL_OW 109
23400: GO 23385
23402: POP
23403: POP
// wait ( 0 0$3 ) ;
23404: LD_INT 105
23406: PPUSH
23407: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23411: LD_INT 93
23413: PPUSH
23414: LD_INT 35
23416: PPUSH
23417: LD_INT 1
23419: PPUSH
23420: CALL_OW 331
// DialogueOn ;
23424: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23428: LD_VAR 0 11
23432: PPUSH
23433: LD_STRING D6c-Sol3-1
23435: PPUSH
23436: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23440: LD_INT 10
23442: PPUSH
23443: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23447: LD_EXP 36
23451: PPUSH
23452: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23456: LD_EXP 36
23460: PPUSH
23461: LD_STRING D6c-JMM-1
23463: PPUSH
23464: CALL_OW 88
// if Cyrus then
23468: LD_EXP 42
23472: IFFALSE 23486
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23474: LD_EXP 42
23478: PPUSH
23479: LD_STRING D6c-Cyrus-1
23481: PPUSH
23482: CALL_OW 88
// if Bobby then
23486: LD_EXP 41
23490: IFFALSE 23504
// Say ( Bobby , D6c-Bobby-1 ) ;
23492: LD_EXP 41
23496: PPUSH
23497: LD_STRING D6c-Bobby-1
23499: PPUSH
23500: CALL_OW 88
// if Cornel then
23504: LD_EXP 47
23508: IFFALSE 23522
// Say ( Cornel , D6c-Corn-1 ) ;
23510: LD_EXP 47
23514: PPUSH
23515: LD_STRING D6c-Corn-1
23517: PPUSH
23518: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23522: LD_ADDR_VAR 0 4
23526: PUSH
23527: LD_INT 2
23529: PUSH
23530: LD_INT 22
23532: PUSH
23533: LD_INT 1
23535: PUSH
23536: EMPTY
23537: LIST
23538: LIST
23539: PUSH
23540: LD_INT 22
23542: PUSH
23543: LD_INT 4
23545: PUSH
23546: EMPTY
23547: LIST
23548: LIST
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: LIST
23554: PUSH
23555: LD_INT 26
23557: PUSH
23558: LD_INT 1
23560: PUSH
23561: EMPTY
23562: LIST
23563: LIST
23564: PUSH
23565: LD_INT 3
23567: PUSH
23568: LD_INT 25
23570: PUSH
23571: LD_INT 16
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: PUSH
23578: LD_INT 25
23580: PUSH
23581: LD_INT 12
23583: PUSH
23584: EMPTY
23585: LIST
23586: LIST
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: LIST
23592: PUSH
23593: EMPTY
23594: LIST
23595: LIST
23596: LIST
23597: PPUSH
23598: CALL_OW 69
23602: PUSH
23603: LD_VAR 0 11
23607: PUSH
23608: LD_EXP 36
23612: UNION
23613: PUSH
23614: LD_EXP 56
23618: UNION
23619: PUSH
23620: EMPTY
23621: LIST
23622: DIFF
23623: ST_TO_ADDR
// if tmp2 then
23624: LD_VAR 0 4
23628: IFFALSE 23646
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23630: LD_VAR 0 4
23634: PUSH
23635: LD_INT 1
23637: ARRAY
23638: PPUSH
23639: LD_STRING D6c-Sol1-1
23641: PPUSH
23642: CALL_OW 88
// if Lisa then
23646: LD_EXP 39
23650: IFFALSE 23664
// Say ( Lisa , D6c-Lisa-1 ) ;
23652: LD_EXP 39
23656: PPUSH
23657: LD_STRING D6c-Lisa-1
23659: PPUSH
23660: CALL_OW 88
// if Gary then
23664: LD_EXP 48
23668: IFFALSE 23682
// Say ( Gary , D6c-Gary-1 ) ;
23670: LD_EXP 48
23674: PPUSH
23675: LD_STRING D6c-Gary-1
23677: PPUSH
23678: CALL_OW 88
// if Donaldson then
23682: LD_EXP 40
23686: IFFALSE 23700
// Say ( Donaldson , D6c-Don-1 ) ;
23688: LD_EXP 40
23692: PPUSH
23693: LD_STRING D6c-Don-1
23695: PPUSH
23696: CALL_OW 88
// if tmp2 > 1 then
23700: LD_VAR 0 4
23704: PUSH
23705: LD_INT 1
23707: GREATER
23708: IFFALSE 23726
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23710: LD_VAR 0 4
23714: PUSH
23715: LD_INT 2
23717: ARRAY
23718: PPUSH
23719: LD_STRING D6c-Sol2-1
23721: PPUSH
23722: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23726: LD_VAR 0 11
23730: PPUSH
23731: LD_STRING D6c-Sol3-2
23733: PPUSH
23734: CALL_OW 88
// dwait ( 0 0$1 ) ;
23738: LD_INT 35
23740: PPUSH
23741: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23745: LD_EXP 36
23749: PPUSH
23750: LD_STRING D6c-JMM-2
23752: PPUSH
23753: CALL_OW 88
// DialogueOff ;
23757: CALL_OW 7
// Video ( false ) ;
23761: LD_INT 0
23763: PPUSH
23764: CALL 105244 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23768: LD_INT 22
23770: PUSH
23771: LD_INT 4
23773: PUSH
23774: EMPTY
23775: LIST
23776: LIST
23777: PPUSH
23778: CALL_OW 69
23782: PPUSH
23783: LD_INT 1
23785: PPUSH
23786: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23790: LD_INT 4
23792: PPUSH
23793: LD_INT 4
23795: PPUSH
23796: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23800: LD_ADDR_VAR 0 1
23804: PUSH
23805: LD_INT 4
23807: PPUSH
23808: LD_INT 1
23810: PPUSH
23811: LD_INT 2
23813: PPUSH
23814: CALL 62987 0 3
23818: PUSH
23819: FOR_IN
23820: IFFALSE 23857
// if GetTech ( i , 1 ) <> state_researched then
23822: LD_VAR 0 1
23826: PPUSH
23827: LD_INT 1
23829: PPUSH
23830: CALL_OW 321
23834: PUSH
23835: LD_INT 2
23837: NONEQUAL
23838: IFFALSE 23855
// SetTech ( i , 1 , state_researched ) ;
23840: LD_VAR 0 1
23844: PPUSH
23845: LD_INT 1
23847: PPUSH
23848: LD_INT 2
23850: PPUSH
23851: CALL_OW 322
23855: GO 23819
23857: POP
23858: POP
// missionStage := 6 ;
23859: LD_ADDR_EXP 15
23863: PUSH
23864: LD_INT 6
23866: ST_TO_ADDR
// activeAttacks := true ;
23867: LD_ADDR_EXP 16
23871: PUSH
23872: LD_INT 1
23874: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23875: LD_STRING M2
23877: PPUSH
23878: CALL_OW 337
// SaveForQuickRestart ;
23882: CALL_OW 22
// wait ( 0 0$40 ) ;
23886: LD_INT 1400
23888: PPUSH
23889: CALL_OW 67
// DialogueOn ;
23893: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23897: LD_EXP 59
23901: PPUSH
23902: LD_STRING D7-Friend-1
23904: PPUSH
23905: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
23909: LD_EXP 36
23913: PPUSH
23914: LD_STRING D7-JMM-1
23916: PPUSH
23917: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
23921: LD_EXP 59
23925: PPUSH
23926: LD_STRING D7-Friend-2
23928: PPUSH
23929: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
23933: LD_EXP 36
23937: PPUSH
23938: LD_STRING D7-JMM-2
23940: PPUSH
23941: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
23945: LD_EXP 59
23949: PPUSH
23950: LD_STRING D7-Friend-3
23952: PPUSH
23953: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
23957: LD_EXP 36
23961: PPUSH
23962: LD_STRING D7-JMM-3
23964: PPUSH
23965: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
23969: LD_EXP 59
23973: PPUSH
23974: LD_STRING D7-Friend-4
23976: PPUSH
23977: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
23981: LD_EXP 36
23985: PPUSH
23986: LD_STRING D7-JMM-4
23988: PPUSH
23989: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
23993: LD_EXP 59
23997: PPUSH
23998: LD_STRING D7-Friend-5
24000: PPUSH
24001: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24005: LD_EXP 36
24009: PPUSH
24010: LD_STRING D7-JMM-5
24012: PPUSH
24013: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24017: LD_EXP 59
24021: PPUSH
24022: LD_STRING D7-Friend-6
24024: PPUSH
24025: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24029: LD_EXP 36
24033: PPUSH
24034: LD_STRING D7-JMM-6
24036: PPUSH
24037: CALL_OW 88
// DialogueOff ;
24041: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24045: LD_STRING Mlegion
24047: PPUSH
24048: CALL_OW 337
// RebuildKozlovFactory ;
24052: CALL 4684 0 0
// end ;
24056: PPOPN 13
24058: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24059: LD_EXP 20
24063: PUSH
24064: LD_EXP 55
24068: PPUSH
24069: CALL_OW 300
24073: AND
24074: IFFALSE 24116
24076: GO 24078
24078: DISABLE
// begin enable ;
24079: ENABLE
// if IsInUnit ( Powell ) then
24080: LD_EXP 55
24084: PPUSH
24085: CALL_OW 310
24089: IFFALSE 24107
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24091: LD_EXP 55
24095: PPUSH
24096: CALL_OW 310
24100: PPUSH
24101: CALL_OW 85
24105: GO 24116
// CenterOnUnits ( Powell ) ;
24107: LD_EXP 55
24111: PPUSH
24112: CALL_OW 85
// end ;
24116: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24117: LD_INT 22
24119: PUSH
24120: LD_INT 8
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: PUSH
24127: LD_INT 34
24129: PUSH
24130: LD_INT 48
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: PUSH
24137: EMPTY
24138: LIST
24139: LIST
24140: PPUSH
24141: CALL_OW 69
24145: IFFALSE 24408
24147: GO 24149
24149: DISABLE
24150: LD_INT 0
24152: PPUSH
24153: PPUSH
// begin if missionStage < 9 then
24154: LD_EXP 15
24158: PUSH
24159: LD_INT 9
24161: LESS
24162: IFFALSE 24172
// missionStage := 9 ;
24164: LD_ADDR_EXP 15
24168: PUSH
24169: LD_INT 9
24171: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24172: LD_ADDR_VAR 0 1
24176: PUSH
24177: LD_INT 22
24179: PUSH
24180: LD_INT 8
24182: PUSH
24183: EMPTY
24184: LIST
24185: LIST
24186: PUSH
24187: LD_INT 34
24189: PUSH
24190: LD_INT 48
24192: PUSH
24193: EMPTY
24194: LIST
24195: LIST
24196: PUSH
24197: EMPTY
24198: LIST
24199: LIST
24200: PPUSH
24201: CALL_OW 69
24205: PUSH
24206: LD_INT 1
24208: ARRAY
24209: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24210: LD_INT 175
24212: PPUSH
24213: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24217: LD_EXP 12
24221: PUSH
24222: LD_EXP 3
24226: PUSH
24227: LD_INT 0
24229: PUSH
24230: LD_INT 2
24232: PUSH
24233: EMPTY
24234: LIST
24235: LIST
24236: IN
24237: OR
24238: IFFALSE 24261
// target := [ 68 , 108 , 1 ] else
24240: LD_ADDR_VAR 0 2
24244: PUSH
24245: LD_INT 68
24247: PUSH
24248: LD_INT 108
24250: PUSH
24251: LD_INT 1
24253: PUSH
24254: EMPTY
24255: LIST
24256: LIST
24257: LIST
24258: ST_TO_ADDR
24259: GO 24280
// target := [ 181 , 88 , 2 ] ;
24261: LD_ADDR_VAR 0 2
24265: PUSH
24266: LD_INT 181
24268: PUSH
24269: LD_INT 88
24271: PUSH
24272: LD_INT 2
24274: PUSH
24275: EMPTY
24276: LIST
24277: LIST
24278: LIST
24279: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24280: LD_VAR 0 1
24284: PPUSH
24285: LD_VAR 0 2
24289: PUSH
24290: LD_INT 1
24292: ARRAY
24293: PPUSH
24294: LD_VAR 0 2
24298: PUSH
24299: LD_INT 2
24301: ARRAY
24302: PPUSH
24303: CALL_OW 176
// if target [ 3 ] = 1 then
24307: LD_VAR 0 2
24311: PUSH
24312: LD_INT 3
24314: ARRAY
24315: PUSH
24316: LD_INT 1
24318: EQUAL
24319: IFFALSE 24335
// SayRadio ( Kurt , D12-Kurt-1 ) else
24321: LD_EXP 57
24325: PPUSH
24326: LD_STRING D12-Kurt-1
24328: PPUSH
24329: CALL_OW 94
24333: GO 24359
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24335: LD_EXP 57
24339: PPUSH
24340: LD_STRING D12a-Kurt-1
24342: PPUSH
24343: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24347: LD_EXP 71
24351: PPUSH
24352: LD_STRING D12a-Roth-1
24354: PPUSH
24355: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24359: LD_INT 350
24361: PPUSH
24362: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24366: LD_VAR 0 1
24370: PPUSH
24371: LD_INT 22
24373: PUSH
24374: LD_INT 8
24376: PUSH
24377: EMPTY
24378: LIST
24379: LIST
24380: PUSH
24381: LD_INT 30
24383: PUSH
24384: LD_INT 3
24386: PUSH
24387: EMPTY
24388: LIST
24389: LIST
24390: PUSH
24391: EMPTY
24392: LIST
24393: LIST
24394: PPUSH
24395: CALL_OW 69
24399: PUSH
24400: LD_INT 1
24402: ARRAY
24403: PPUSH
24404: CALL_OW 228
// end ;
24408: PPOPN 2
24410: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24411: LD_INT 22
24413: PUSH
24414: LD_INT 8
24416: PUSH
24417: EMPTY
24418: LIST
24419: LIST
24420: PUSH
24421: LD_INT 21
24423: PUSH
24424: LD_INT 1
24426: PUSH
24427: EMPTY
24428: LIST
24429: LIST
24430: PUSH
24431: LD_INT 23
24433: PUSH
24434: LD_INT 2
24436: PUSH
24437: EMPTY
24438: LIST
24439: LIST
24440: PUSH
24441: EMPTY
24442: LIST
24443: LIST
24444: LIST
24445: PPUSH
24446: CALL_OW 69
24450: PUSH
24451: LD_INT 8
24453: PUSH
24454: LD_INT 7
24456: PUSH
24457: LD_INT 6
24459: PUSH
24460: EMPTY
24461: LIST
24462: LIST
24463: LIST
24464: PUSH
24465: LD_OWVAR 67
24469: ARRAY
24470: LESSEQUAL
24471: PUSH
24472: LD_INT 22
24474: PUSH
24475: LD_INT 8
24477: PUSH
24478: EMPTY
24479: LIST
24480: LIST
24481: PUSH
24482: LD_INT 34
24484: PUSH
24485: LD_INT 48
24487: PUSH
24488: EMPTY
24489: LIST
24490: LIST
24491: PUSH
24492: EMPTY
24493: LIST
24494: LIST
24495: PPUSH
24496: CALL_OW 69
24500: NOT
24501: AND
24502: PUSH
24503: LD_EXP 57
24507: PPUSH
24508: CALL_OW 302
24512: AND
24513: IFFALSE 24830
24515: GO 24517
24517: DISABLE
// begin DialogueOn ;
24518: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24522: LD_EXP 36
24526: PPUSH
24527: LD_STRING D13-JMM-1
24529: PPUSH
24530: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24534: LD_EXP 57
24538: PPUSH
24539: LD_STRING D13-Kurt-1
24541: PPUSH
24542: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24546: LD_EXP 36
24550: PPUSH
24551: LD_STRING D13-JMM-2
24553: PPUSH
24554: CALL_OW 88
// if FakeInfo then
24558: LD_EXP 12
24562: IFFALSE 24582
// begin Say ( Kurt , D13-Kurt-2 ) ;
24564: LD_EXP 57
24568: PPUSH
24569: LD_STRING D13-Kurt-2
24571: PPUSH
24572: CALL_OW 88
// DialogueOff ;
24576: CALL_OW 7
// exit ;
24580: GO 24830
// end ; if not KurtStatus then
24582: LD_EXP 3
24586: NOT
24587: IFFALSE 24603
// Say ( Kurt , D13-Kurt-2b ) else
24589: LD_EXP 57
24593: PPUSH
24594: LD_STRING D13-Kurt-2b
24596: PPUSH
24597: CALL_OW 88
24601: GO 24615
// Say ( Kurt , D13-Kurt-2a ) ;
24603: LD_EXP 57
24607: PPUSH
24608: LD_STRING D13-Kurt-2a
24610: PPUSH
24611: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24615: LD_EXP 57
24619: PPUSH
24620: LD_STRING D13-Kurt-2a
24622: PPUSH
24623: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24627: LD_EXP 36
24631: PPUSH
24632: LD_STRING D13-JMM-3
24634: PPUSH
24635: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24639: LD_EXP 57
24643: PPUSH
24644: LD_STRING D13-Kurt-3
24646: PPUSH
24647: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24651: LD_EXP 36
24655: PPUSH
24656: LD_STRING D13-JMM-4
24658: PPUSH
24659: CALL_OW 88
// DialogueOff ;
24663: CALL_OW 7
// MC_Kill ( 3 ) ;
24667: LD_INT 3
24669: PPUSH
24670: CALL 33936 0 1
// KillUnit ( Kozlov ) ;
24674: LD_EXP 58
24678: PPUSH
24679: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24683: LD_INT 22
24685: PUSH
24686: LD_INT 8
24688: PUSH
24689: EMPTY
24690: LIST
24691: LIST
24692: PUSH
24693: LD_INT 21
24695: PUSH
24696: LD_INT 3
24698: PUSH
24699: EMPTY
24700: LIST
24701: LIST
24702: PUSH
24703: LD_INT 23
24705: PUSH
24706: LD_INT 3
24708: PUSH
24709: EMPTY
24710: LIST
24711: LIST
24712: PUSH
24713: LD_INT 30
24715: PUSH
24716: LD_INT 3
24718: PUSH
24719: EMPTY
24720: LIST
24721: LIST
24722: PUSH
24723: EMPTY
24724: LIST
24725: LIST
24726: LIST
24727: LIST
24728: PPUSH
24729: CALL_OW 69
24733: PUSH
24734: LD_INT 1
24736: ARRAY
24737: PPUSH
24738: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24742: LD_INT 8
24744: PPUSH
24745: LD_INT 1
24747: PPUSH
24748: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24752: LD_INT 22
24754: PUSH
24755: LD_INT 8
24757: PUSH
24758: EMPTY
24759: LIST
24760: LIST
24761: PPUSH
24762: CALL_OW 69
24766: PPUSH
24767: LD_INT 1
24769: PPUSH
24770: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24774: LD_INT 8
24776: PPUSH
24777: LD_INT 1
24779: PPUSH
24780: LD_INT 1
24782: PPUSH
24783: LD_INT 1
24785: PPUSH
24786: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24790: LD_EXP 59
24794: PPUSH
24795: LD_INT 37
24797: PPUSH
24798: LD_INT 1
24800: PPUSH
24801: LD_INT 0
24803: PPUSH
24804: CALL_OW 48
// wait ( 0 0$1 ) ;
24808: LD_INT 35
24810: PPUSH
24811: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24815: LD_EXP 59
24819: PPUSH
24820: LD_INT 60
24822: PPUSH
24823: LD_INT 95
24825: PPUSH
24826: CALL_OW 111
// end ;
24830: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24831: LD_INT 22
24833: PUSH
24834: LD_INT 8
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 21
24843: PUSH
24844: LD_INT 1
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: PPUSH
24855: CALL_OW 69
24859: PUSH
24860: LD_INT 0
24862: EQUAL
24863: IFFALSE 24883
24865: GO 24867
24867: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24868: LD_STRING MlegionOut
24870: PPUSH
24871: CALL_OW 337
// legionDestroyed := true ;
24875: LD_ADDR_EXP 22
24879: PUSH
24880: LD_INT 1
24882: ST_TO_ADDR
// end ;
24883: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24884: LD_INT 1
24886: PPUSH
24887: LD_EXP 59
24891: PPUSH
24892: CALL_OW 292
24896: IFFALSE 25196
24898: GO 24900
24900: DISABLE
24901: LD_INT 0
24903: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24904: LD_EXP 59
24908: PPUSH
24909: CALL_OW 87
// DialogueOn ;
24913: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
24917: LD_EXP 36
24921: PPUSH
24922: LD_STRING D14-JMM-1
24924: PPUSH
24925: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
24929: LD_EXP 59
24933: PPUSH
24934: LD_STRING D14-Friend-1
24936: PPUSH
24937: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
24941: LD_EXP 36
24945: PPUSH
24946: LD_STRING D14-JMM-2
24948: PPUSH
24949: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
24953: LD_EXP 59
24957: PPUSH
24958: LD_STRING D14-Friend-2
24960: PPUSH
24961: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
24965: LD_EXP 36
24969: PPUSH
24970: LD_STRING D14-JMM-3
24972: PPUSH
24973: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
24977: LD_EXP 59
24981: PPUSH
24982: LD_STRING D14-Friend-3
24984: PPUSH
24985: CALL_OW 88
// DialogueOff ;
24989: CALL_OW 7
// dec = Query ( Q14 ) ;
24993: LD_ADDR_VAR 0 1
24997: PUSH
24998: LD_STRING Q14
25000: PPUSH
25001: CALL_OW 97
25005: ST_TO_ADDR
// if dec = 1 then
25006: LD_VAR 0 1
25010: PUSH
25011: LD_INT 1
25013: EQUAL
25014: IFFALSE 25048
// begin DialogueOn ;
25016: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25020: LD_EXP 36
25024: PPUSH
25025: LD_STRING D14a-JMM-1
25027: PPUSH
25028: CALL_OW 88
// DialogueOff ;
25032: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25036: LD_EXP 59
25040: PPUSH
25041: LD_INT 1
25043: PPUSH
25044: CALL_OW 235
// end ; if dec = 2 then
25048: LD_VAR 0 1
25052: PUSH
25053: LD_INT 2
25055: EQUAL
25056: IFFALSE 25102
// begin DialogueOn ;
25058: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25062: LD_EXP 36
25066: PPUSH
25067: LD_STRING D14b-JMM-1
25069: PPUSH
25070: CALL_OW 88
// DialogueOff ;
25074: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25078: LD_EXP 59
25082: PPUSH
25083: LD_INT 9
25085: PPUSH
25086: LD_INT 2
25088: PPUSH
25089: CALL_OW 111
// AddComHold ( Friend ) ;
25093: LD_EXP 59
25097: PPUSH
25098: CALL_OW 200
// end ; if dec = 3 then
25102: LD_VAR 0 1
25106: PUSH
25107: LD_INT 3
25109: EQUAL
25110: IFFALSE 25196
// begin DialogueOn ;
25112: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25116: LD_EXP 36
25120: PPUSH
25121: LD_STRING D14c-JMM-1
25123: PPUSH
25124: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25128: LD_EXP 59
25132: PPUSH
25133: LD_STRING D14c-Friend-1
25135: PPUSH
25136: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25140: LD_EXP 36
25144: PPUSH
25145: LD_STRING D14c-JMM-2
25147: PPUSH
25148: CALL_OW 88
// DialogueOff ;
25152: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25156: LD_INT 8
25158: PPUSH
25159: LD_INT 1
25161: PPUSH
25162: LD_INT 2
25164: PPUSH
25165: LD_INT 1
25167: PPUSH
25168: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25172: LD_EXP 59
25176: PPUSH
25177: LD_INT 9
25179: PPUSH
25180: LD_INT 2
25182: PPUSH
25183: CALL_OW 111
// AddComHold ( Friend ) ;
25187: LD_EXP 59
25191: PPUSH
25192: CALL_OW 200
// end ; end ;
25196: PPOPN 1
25198: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25199: LD_INT 9
25201: PPUSH
25202: LD_INT 2
25204: PPUSH
25205: CALL_OW 428
25209: PUSH
25210: LD_EXP 59
25214: EQUAL
25215: PUSH
25216: LD_EXP 59
25220: PPUSH
25221: CALL_OW 255
25225: PUSH
25226: LD_INT 8
25228: EQUAL
25229: AND
25230: IFFALSE 25244
25232: GO 25234
25234: DISABLE
// RemoveUnit ( Friend ) ;
25235: LD_EXP 59
25239: PPUSH
25240: CALL_OW 64
25244: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25245: LD_EXP 14
25249: PUSH
25250: LD_INT 31500
25252: GREATEREQUAL
25253: PUSH
25254: LD_EXP 7
25258: AND
25259: PUSH
25260: LD_EXP 2
25264: AND
25265: IFFALSE 25695
25267: GO 25269
25269: DISABLE
25270: LD_INT 0
25272: PPUSH
25273: PPUSH
25274: PPUSH
// begin missionStage := 7 ;
25275: LD_ADDR_EXP 15
25279: PUSH
25280: LD_INT 7
25282: ST_TO_ADDR
// uc_side = 1 ;
25283: LD_ADDR_OWVAR 20
25287: PUSH
25288: LD_INT 1
25290: ST_TO_ADDR
// uc_nation = 1 ;
25291: LD_ADDR_OWVAR 21
25295: PUSH
25296: LD_INT 1
25298: ST_TO_ADDR
// for i = 1 to 5 do
25299: LD_ADDR_VAR 0 1
25303: PUSH
25304: DOUBLE
25305: LD_INT 1
25307: DEC
25308: ST_TO_ADDR
25309: LD_INT 5
25311: PUSH
25312: FOR_TO
25313: IFFALSE 25409
// begin vc_engine = 3 ;
25315: LD_ADDR_OWVAR 39
25319: PUSH
25320: LD_INT 3
25322: ST_TO_ADDR
// vc_control = 3 ;
25323: LD_ADDR_OWVAR 38
25327: PUSH
25328: LD_INT 3
25330: ST_TO_ADDR
// vc_chassis = 3 ;
25331: LD_ADDR_OWVAR 37
25335: PUSH
25336: LD_INT 3
25338: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25339: LD_ADDR_OWVAR 40
25343: PUSH
25344: LD_INT 5
25346: PUSH
25347: LD_INT 9
25349: PUSH
25350: LD_INT 7
25352: PUSH
25353: EMPTY
25354: LIST
25355: LIST
25356: LIST
25357: PUSH
25358: LD_INT 1
25360: PPUSH
25361: LD_INT 3
25363: PPUSH
25364: CALL_OW 12
25368: ARRAY
25369: ST_TO_ADDR
// veh = CreateVehicle ;
25370: LD_ADDR_VAR 0 2
25374: PUSH
25375: CALL_OW 45
25379: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25380: LD_VAR 0 2
25384: PPUSH
25385: LD_INT 1
25387: PPUSH
25388: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25392: LD_VAR 0 2
25396: PPUSH
25397: LD_INT 19
25399: PPUSH
25400: LD_INT 0
25402: PPUSH
25403: CALL_OW 49
// end ;
25407: GO 25312
25409: POP
25410: POP
// vc_engine = 3 ;
25411: LD_ADDR_OWVAR 39
25415: PUSH
25416: LD_INT 3
25418: ST_TO_ADDR
// vc_control = 1 ;
25419: LD_ADDR_OWVAR 38
25423: PUSH
25424: LD_INT 1
25426: ST_TO_ADDR
// vc_chassis = 3 ;
25427: LD_ADDR_OWVAR 37
25431: PUSH
25432: LD_INT 3
25434: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25435: LD_ADDR_OWVAR 40
25439: PUSH
25440: LD_INT 5
25442: PUSH
25443: LD_INT 9
25445: PUSH
25446: LD_INT 7
25448: PUSH
25449: EMPTY
25450: LIST
25451: LIST
25452: LIST
25453: PUSH
25454: LD_INT 1
25456: PPUSH
25457: LD_INT 3
25459: PPUSH
25460: CALL_OW 12
25464: ARRAY
25465: ST_TO_ADDR
// vehG = CreateVehicle ;
25466: LD_ADDR_VAR 0 3
25470: PUSH
25471: CALL_OW 45
25475: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25476: LD_VAR 0 3
25480: PPUSH
25481: LD_INT 1
25483: PPUSH
25484: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25488: LD_VAR 0 3
25492: PPUSH
25493: LD_INT 19
25495: PPUSH
25496: LD_INT 0
25498: PPUSH
25499: CALL_OW 49
// if JMMGirl = 1 then
25503: LD_EXP 7
25507: PUSH
25508: LD_INT 1
25510: EQUAL
25511: IFFALSE 25567
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25513: LD_ADDR_EXP 37
25517: PUSH
25518: LD_STRING Joan
25520: PPUSH
25521: LD_INT 1
25523: PPUSH
25524: LD_STRING 14_
25526: PPUSH
25527: CALL 62924 0 3
25531: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25532: LD_EXP 37
25536: PPUSH
25537: LD_VAR 0 3
25541: PPUSH
25542: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25546: LD_VAR 0 3
25550: PPUSH
25551: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25555: LD_EXP 37
25559: PPUSH
25560: LD_STRING D10BW-Joan-1
25562: PPUSH
25563: CALL_OW 94
// end ; if JMMGirl = 2 then
25567: LD_EXP 7
25571: PUSH
25572: LD_INT 2
25574: EQUAL
25575: IFFALSE 25631
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25577: LD_ADDR_EXP 39
25581: PUSH
25582: LD_STRING Lisa
25584: PPUSH
25585: LD_INT 1
25587: PPUSH
25588: LD_STRING 14_
25590: PPUSH
25591: CALL 62924 0 3
25595: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25596: LD_EXP 39
25600: PPUSH
25601: LD_VAR 0 3
25605: PPUSH
25606: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25610: LD_VAR 0 3
25614: PPUSH
25615: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25619: LD_EXP 39
25623: PPUSH
25624: LD_STRING D10BW-Lisa-1
25626: PPUSH
25627: CALL_OW 94
// end ; if JMMGirl = 3 then
25631: LD_EXP 7
25635: PUSH
25636: LD_INT 3
25638: EQUAL
25639: IFFALSE 25695
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25641: LD_ADDR_EXP 51
25645: PUSH
25646: LD_STRING Connie
25648: PPUSH
25649: LD_INT 1
25651: PPUSH
25652: LD_STRING 14_
25654: PPUSH
25655: CALL 62924 0 3
25659: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25660: LD_EXP 51
25664: PPUSH
25665: LD_VAR 0 3
25669: PPUSH
25670: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25674: LD_VAR 0 3
25678: PPUSH
25679: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25683: LD_EXP 39
25687: PPUSH
25688: LD_STRING D10BW-Con-1
25690: PPUSH
25691: CALL_OW 94
// end ; end ;
25695: PPOPN 3
25697: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25698: LD_EXP 14
25702: PUSH
25703: LD_INT 94500
25705: GREATEREQUAL
25706: IFFALSE 26118
25708: GO 25710
25710: DISABLE
25711: LD_INT 0
25713: PPUSH
25714: PPUSH
25715: PPUSH
// begin tmp := PrepareStevensSquad ;
25716: LD_ADDR_VAR 0 3
25720: PUSH
25721: CALL 2058 0 0
25725: ST_TO_ADDR
// if not tmp then
25726: LD_VAR 0 3
25730: NOT
25731: IFFALSE 25735
// exit ;
25733: GO 26118
// uc_side := 1 ;
25735: LD_ADDR_OWVAR 20
25739: PUSH
25740: LD_INT 1
25742: ST_TO_ADDR
// uc_nation := 1 ;
25743: LD_ADDR_OWVAR 21
25747: PUSH
25748: LD_INT 1
25750: ST_TO_ADDR
// for i in tmp do
25751: LD_ADDR_VAR 0 1
25755: PUSH
25756: LD_VAR 0 3
25760: PUSH
25761: FOR_IN
25762: IFFALSE 25859
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25764: LD_INT 3
25766: PPUSH
25767: LD_INT 3
25769: PPUSH
25770: LD_INT 1
25772: PPUSH
25773: LD_INT 5
25775: PUSH
25776: LD_INT 9
25778: PUSH
25779: LD_INT 7
25781: PUSH
25782: EMPTY
25783: LIST
25784: LIST
25785: LIST
25786: PUSH
25787: LD_INT 1
25789: PPUSH
25790: LD_INT 3
25792: PPUSH
25793: CALL_OW 12
25797: ARRAY
25798: PPUSH
25799: LD_INT 40
25801: PPUSH
25802: CALL 69527 0 5
// veh := CreateVehicle ;
25806: LD_ADDR_VAR 0 2
25810: PUSH
25811: CALL_OW 45
25815: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25816: LD_VAR 0 2
25820: PPUSH
25821: LD_INT 1
25823: PPUSH
25824: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25828: LD_VAR 0 2
25832: PPUSH
25833: LD_INT 19
25835: PPUSH
25836: LD_INT 0
25838: PPUSH
25839: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25843: LD_VAR 0 1
25847: PPUSH
25848: LD_VAR 0 2
25852: PPUSH
25853: CALL_OW 52
// end ;
25857: GO 25761
25859: POP
25860: POP
// missionStage := 8 ;
25861: LD_ADDR_EXP 15
25865: PUSH
25866: LD_INT 8
25868: ST_TO_ADDR
// DialogueOn ;
25869: CALL_OW 6
// if Stevens then
25873: LD_EXP 38
25877: IFFALSE 25991
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25879: LD_EXP 38
25883: PPUSH
25884: CALL_OW 310
25888: PPUSH
25889: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25893: LD_EXP 38
25897: PPUSH
25898: LD_STRING D8-Huck-1
25900: PPUSH
25901: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25905: LD_EXP 36
25909: PPUSH
25910: LD_STRING D8-JMM-1
25912: PPUSH
25913: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
25917: LD_EXP 38
25921: PPUSH
25922: LD_STRING D8-Huck-2
25924: PPUSH
25925: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
25929: LD_EXP 36
25933: PPUSH
25934: LD_STRING D8-JMM-2
25936: PPUSH
25937: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
25941: LD_EXP 38
25945: PPUSH
25946: LD_STRING D8-Huck-3
25948: PPUSH
25949: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
25953: LD_EXP 36
25957: PPUSH
25958: LD_STRING D8-JMM-3
25960: PPUSH
25961: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
25965: LD_EXP 38
25969: PPUSH
25970: LD_STRING D8-Huck-4
25972: PPUSH
25973: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
25977: LD_EXP 36
25981: PPUSH
25982: LD_STRING D8-JMM-4
25984: PPUSH
25985: CALL_OW 88
// end else
25989: GO 26101
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
25991: LD_EXP 52
25995: PPUSH
25996: CALL_OW 310
26000: PPUSH
26001: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26005: LD_EXP 52
26009: PPUSH
26010: LD_STRING D8-Huck-1
26012: PPUSH
26013: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26017: LD_EXP 36
26021: PPUSH
26022: LD_STRING D8-JMM-1a
26024: PPUSH
26025: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26029: LD_EXP 52
26033: PPUSH
26034: LD_STRING D8-Huck-2
26036: PPUSH
26037: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26041: LD_EXP 36
26045: PPUSH
26046: LD_STRING D8-JMM-2
26048: PPUSH
26049: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26053: LD_EXP 52
26057: PPUSH
26058: LD_STRING D8-Huck-3
26060: PPUSH
26061: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26065: LD_EXP 36
26069: PPUSH
26070: LD_STRING D8-JMM-3
26072: PPUSH
26073: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26077: LD_EXP 52
26081: PPUSH
26082: LD_STRING D8-Huck-4
26084: PPUSH
26085: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26089: LD_EXP 36
26093: PPUSH
26094: LD_STRING D8-JMM-4
26096: PPUSH
26097: CALL_OW 88
// end ; DialogueOff ;
26101: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26105: LD_INT 25
26107: PPUSH
26108: LD_INT 1
26110: PPUSH
26111: LD_INT 1
26113: PPUSH
26114: CALL_OW 322
// end ;
26118: PPOPN 3
26120: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26121: LD_INT 1
26123: PPUSH
26124: LD_EXP 68
26128: PPUSH
26129: CALL_OW 292
26133: IFFALSE 26384
26135: GO 26137
26137: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26138: LD_EXP 68
26142: PPUSH
26143: CALL_OW 87
// DialogueOn ;
26147: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26151: LD_EXP 36
26155: PPUSH
26156: LD_STRING D10nB-JMM-1
26158: PPUSH
26159: CALL_OW 88
// if BurlakStatus = 1 then
26163: LD_EXP 9
26167: PUSH
26168: LD_INT 1
26170: EQUAL
26171: IFFALSE 26185
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26173: LD_EXP 67
26177: PPUSH
26178: LD_STRING D10nB-Vse-1a
26180: PPUSH
26181: CALL_OW 94
// end ; if BurlakStatus = 0 then
26185: LD_EXP 9
26189: PUSH
26190: LD_INT 0
26192: EQUAL
26193: IFFALSE 26207
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26195: LD_EXP 67
26199: PPUSH
26200: LD_STRING D10nB-Vse-1
26202: PPUSH
26203: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26207: LD_EXP 36
26211: PPUSH
26212: LD_STRING D10nB-JMM-2
26214: PPUSH
26215: CALL_OW 88
// if KappaStatus then
26219: LD_EXP 2
26223: IFFALSE 26237
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26225: LD_EXP 67
26229: PPUSH
26230: LD_STRING D10nB-Vse-5a
26232: PPUSH
26233: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26237: LD_EXP 2
26241: NOT
26242: PUSH
26243: LD_EXP 6
26247: PUSH
26248: LD_INT 0
26250: EQUAL
26251: AND
26252: IFFALSE 26380
// begin if JMMGirl = 1 then
26254: LD_EXP 7
26258: PUSH
26259: LD_INT 1
26261: EQUAL
26262: IFFALSE 26312
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26264: LD_EXP 67
26268: PPUSH
26269: LD_STRING D10nB-Vse-2
26271: PPUSH
26272: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26276: LD_EXP 36
26280: PPUSH
26281: LD_STRING D10nB-JMM-3
26283: PPUSH
26284: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26288: LD_EXP 67
26292: PPUSH
26293: LD_STRING D10nB-Vse-3
26295: PPUSH
26296: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26300: LD_EXP 36
26304: PPUSH
26305: LD_STRING D10nB-JMM-4
26307: PPUSH
26308: CALL_OW 88
// end ; if JMMGirl = 2 then
26312: LD_EXP 7
26316: PUSH
26317: LD_INT 2
26319: EQUAL
26320: IFFALSE 26346
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26322: LD_EXP 67
26326: PPUSH
26327: LD_STRING D10nB-Vse-4
26329: PPUSH
26330: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26334: LD_EXP 36
26338: PPUSH
26339: LD_STRING D10nB-JMM-5
26341: PPUSH
26342: CALL_OW 88
// end ; if JMMGirl = 3 then
26346: LD_EXP 7
26350: PUSH
26351: LD_INT 3
26353: EQUAL
26354: IFFALSE 26380
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26356: LD_EXP 67
26360: PPUSH
26361: LD_STRING D10nB-Vse-5
26363: PPUSH
26364: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26368: LD_EXP 36
26372: PPUSH
26373: LD_STRING D10nB-JMM-6
26375: PPUSH
26376: CALL_OW 88
// end ; end ; DialogueOff ;
26380: CALL_OW 7
// end ;
26384: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26385: LD_EXP 14
26389: PUSH
26390: LD_INT 115500
26392: GREATEREQUAL
26393: IFFALSE 26752
26395: GO 26397
26397: DISABLE
26398: LD_INT 0
26400: PPUSH
// begin missionStage := 10 ;
26401: LD_ADDR_EXP 15
26405: PUSH
26406: LD_INT 10
26408: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26409: LD_ADDR_VAR 0 1
26413: PUSH
26414: LD_INT 22
26416: PUSH
26417: LD_INT 1
26419: PUSH
26420: EMPTY
26421: LIST
26422: LIST
26423: PUSH
26424: LD_INT 26
26426: PUSH
26427: LD_INT 1
26429: PUSH
26430: EMPTY
26431: LIST
26432: LIST
26433: PUSH
26434: LD_INT 3
26436: PUSH
26437: LD_INT 25
26439: PUSH
26440: LD_INT 12
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: PUSH
26451: LD_INT 3
26453: PUSH
26454: LD_INT 25
26456: PUSH
26457: LD_INT 16
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: EMPTY
26465: LIST
26466: LIST
26467: PUSH
26468: EMPTY
26469: LIST
26470: LIST
26471: LIST
26472: LIST
26473: PPUSH
26474: CALL_OW 69
26478: PUSH
26479: LD_EXP 36
26483: PUSH
26484: LD_EXP 38
26488: PUSH
26489: LD_EXP 52
26493: PUSH
26494: LD_EXP 39
26498: PUSH
26499: LD_EXP 40
26503: PUSH
26504: LD_EXP 41
26508: PUSH
26509: LD_EXP 42
26513: PUSH
26514: LD_EXP 43
26518: PUSH
26519: LD_EXP 44
26523: PUSH
26524: LD_EXP 45
26528: PUSH
26529: LD_EXP 46
26533: PUSH
26534: LD_EXP 47
26538: PUSH
26539: LD_EXP 48
26543: PUSH
26544: LD_EXP 49
26548: PUSH
26549: LD_EXP 50
26553: PUSH
26554: EMPTY
26555: LIST
26556: LIST
26557: LIST
26558: LIST
26559: LIST
26560: LIST
26561: LIST
26562: LIST
26563: LIST
26564: LIST
26565: LIST
26566: LIST
26567: LIST
26568: LIST
26569: LIST
26570: DIFF
26571: ST_TO_ADDR
// if not tmp and Brown then
26572: LD_VAR 0 1
26576: NOT
26577: PUSH
26578: LD_EXP 44
26582: AND
26583: IFFALSE 26598
// tmp := [ Brown ] ;
26585: LD_ADDR_VAR 0 1
26589: PUSH
26590: LD_EXP 44
26594: PUSH
26595: EMPTY
26596: LIST
26597: ST_TO_ADDR
// DialogueOn ;
26598: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26602: LD_VAR 0 1
26606: PUSH
26607: LD_INT 1
26609: ARRAY
26610: PPUSH
26611: LD_STRING D11-Sol1-1
26613: PPUSH
26614: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26618: LD_EXP 61
26622: PPUSH
26623: LD_STRING D11-Pla-1
26625: PPUSH
26626: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26630: LD_EXP 62
26634: PPUSH
26635: LD_STRING D11-Kov-1
26637: PPUSH
26638: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26642: LD_EXP 61
26646: PPUSH
26647: LD_STRING D11-Pla-2
26649: PPUSH
26650: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26654: LD_VAR 0 1
26658: PUSH
26659: LD_INT 1
26661: ARRAY
26662: PPUSH
26663: LD_STRING D11-Sol1-2
26665: PPUSH
26666: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26670: LD_EXP 36
26674: PPUSH
26675: LD_STRING D11-JMM-2
26677: PPUSH
26678: CALL_OW 88
// DialogueOff ;
26682: CALL_OW 7
// allowBehemothConstruct := true ;
26686: LD_ADDR_EXP 25
26690: PUSH
26691: LD_INT 1
26693: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26694: LD_STRING M4
26696: PPUSH
26697: CALL_OW 337
// BuildBehemoths ;
26701: CALL 7488 0 0
// repeat wait ( 15 15$00 ) ;
26705: LD_INT 31500
26707: PPUSH
26708: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26712: LD_EXP 27
26716: IFFALSE 26720
// break ;
26718: GO 26752
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26720: LD_INT 267
26722: PPUSH
26723: CALL_OW 274
26727: PPUSH
26728: LD_INT 1
26730: PPUSH
26731: CALL_OW 275
26735: PUSH
26736: LD_INT 1000
26738: GREATEREQUAL
26739: IFFALSE 26745
// BuildBehemoths ;
26741: CALL 7488 0 0
// until not behemothBuilders ;
26745: LD_EXP 70
26749: NOT
26750: IFFALSE 26705
// end ;
26752: PPOPN 1
26754: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26755: LD_EXP 70
26759: NOT
26760: PUSH
26761: LD_EXP 28
26765: NOT
26766: AND
26767: PUSH
26768: LD_EXP 25
26772: AND
26773: IFFALSE 26793
26775: GO 26777
26777: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26778: LD_STRING M4a
26780: PPUSH
26781: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26785: LD_ADDR_EXP 27
26789: PUSH
26790: LD_INT 1
26792: ST_TO_ADDR
// end ;
26793: END
// every 0 0$1 trigger behemothDone do
26794: LD_EXP 28
26798: IFFALSE 26810
26800: GO 26802
26802: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26803: LD_STRING M4b
26805: PPUSH
26806: CALL_OW 337
26810: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26811: LD_EXP 29
26815: NOT
26816: IFFALSE 27012
26818: GO 26820
26820: DISABLE
26821: LD_INT 0
26823: PPUSH
26824: PPUSH
// begin enable ;
26825: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26826: LD_ADDR_VAR 0 1
26830: PUSH
26831: LD_INT 3
26833: PPUSH
26834: CALL 105320 0 1
26838: ST_TO_ADDR
// if not tmp and not behemothDone then
26839: LD_VAR 0 1
26843: NOT
26844: PUSH
26845: LD_EXP 28
26849: NOT
26850: AND
26851: IFFALSE 26887
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26853: LD_ADDR_VAR 0 1
26857: PUSH
26858: LD_INT 22
26860: PUSH
26861: LD_INT 3
26863: PUSH
26864: EMPTY
26865: LIST
26866: LIST
26867: PUSH
26868: LD_INT 30
26870: PUSH
26871: LD_INT 37
26873: PUSH
26874: EMPTY
26875: LIST
26876: LIST
26877: PUSH
26878: EMPTY
26879: LIST
26880: LIST
26881: PPUSH
26882: CALL_OW 69
26886: ST_TO_ADDR
// if not tmp then
26887: LD_VAR 0 1
26891: NOT
26892: IFFALSE 26896
// exit ;
26894: GO 27012
// for i in tmp do
26896: LD_ADDR_VAR 0 2
26900: PUSH
26901: LD_VAR 0 1
26905: PUSH
26906: FOR_IN
26907: IFFALSE 27010
// if See ( 1 , i ) then
26909: LD_INT 1
26911: PPUSH
26912: LD_VAR 0 2
26916: PPUSH
26917: CALL_OW 292
26921: IFFALSE 27008
// begin if GetType ( i ) = unit_building then
26923: LD_VAR 0 2
26927: PPUSH
26928: CALL_OW 247
26932: PUSH
26933: LD_INT 3
26935: EQUAL
26936: IFFALSE 26974
// begin CenterNowOnUnits ( i ) ;
26938: LD_VAR 0 2
26942: PPUSH
26943: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
26947: LD_EXP 36
26951: PPUSH
26952: LD_STRING D17a-JMM-1
26954: PPUSH
26955: CALL_OW 88
// seeBehemoth := true ;
26959: LD_ADDR_EXP 29
26963: PUSH
26964: LD_INT 1
26966: ST_TO_ADDR
// disable ;
26967: DISABLE
// exit ;
26968: POP
26969: POP
26970: GO 27012
// end else
26972: GO 27008
// begin CenterNowOnUnits ( i ) ;
26974: LD_VAR 0 2
26978: PPUSH
26979: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
26983: LD_EXP 36
26987: PPUSH
26988: LD_STRING D17b-JMM-1
26990: PPUSH
26991: CALL_OW 88
// seeBehemoth := true ;
26995: LD_ADDR_EXP 29
26999: PUSH
27000: LD_INT 1
27002: ST_TO_ADDR
// disable ;
27003: DISABLE
// exit ;
27004: POP
27005: POP
27006: GO 27012
// end ; end ;
27008: GO 26906
27010: POP
27011: POP
// end ;
27012: PPOPN 2
27014: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27015: LD_EXP 14
27019: PUSH
27020: LD_INT 116550
27022: GREATEREQUAL
27023: IFFALSE 28199
27025: GO 27027
27027: DISABLE
27028: LD_INT 0
27030: PPUSH
27031: PPUSH
27032: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27033: LD_INT 2
27035: PPUSH
27036: LD_INT 23
27038: PUSH
27039: LD_INT 3
27041: PUSH
27042: LD_INT 3
27044: PUSH
27045: LD_INT 48
27047: PUSH
27048: EMPTY
27049: LIST
27050: LIST
27051: LIST
27052: LIST
27053: PUSH
27054: EMPTY
27055: LIST
27056: PPUSH
27057: CALL 56922 0 2
// repeat wait ( 0 0$1 ) ;
27061: LD_INT 35
27063: PPUSH
27064: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27068: LD_INT 22
27070: PUSH
27071: LD_INT 3
27073: PUSH
27074: EMPTY
27075: LIST
27076: LIST
27077: PUSH
27078: LD_INT 34
27080: PUSH
27081: LD_INT 48
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: PPUSH
27092: CALL_OW 69
27096: IFFALSE 27061
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27098: LD_ADDR_VAR 0 1
27102: PUSH
27103: LD_INT 22
27105: PUSH
27106: LD_INT 3
27108: PUSH
27109: EMPTY
27110: LIST
27111: LIST
27112: PUSH
27113: LD_INT 34
27115: PUSH
27116: LD_INT 48
27118: PUSH
27119: EMPTY
27120: LIST
27121: LIST
27122: PUSH
27123: EMPTY
27124: LIST
27125: LIST
27126: PPUSH
27127: CALL_OW 69
27131: PUSH
27132: LD_INT 1
27134: ARRAY
27135: ST_TO_ADDR
// missionStage := 12 ;
27136: LD_ADDR_EXP 15
27140: PUSH
27141: LD_INT 12
27143: ST_TO_ADDR
// platonovHasBomb := true ;
27144: LD_ADDR_EXP 30
27148: PUSH
27149: LD_INT 1
27151: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27152: LD_VAR 0 1
27156: PPUSH
27157: LD_INT 181
27159: PPUSH
27160: LD_INT 86
27162: PPUSH
27163: CALL_OW 171
// AddComHold ( bomb ) ;
27167: LD_VAR 0 1
27171: PPUSH
27172: CALL_OW 200
// wait ( 0 0$10 ) ;
27176: LD_INT 350
27178: PPUSH
27179: CALL_OW 67
// DialogueOn ;
27183: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27187: LD_EXP 61
27191: PPUSH
27192: LD_STRING D15-Pla-1
27194: PPUSH
27195: CALL_OW 94
// dec = Query ( Q15a ) ;
27199: LD_ADDR_VAR 0 2
27203: PUSH
27204: LD_STRING Q15a
27206: PPUSH
27207: CALL_OW 97
27211: ST_TO_ADDR
// if dec = 1 then
27212: LD_VAR 0 2
27216: PUSH
27217: LD_INT 1
27219: EQUAL
27220: IFFALSE 27243
// begin Say ( JMM , D15a-JMM-1 ) ;
27222: LD_EXP 36
27226: PPUSH
27227: LD_STRING D15a-JMM-1
27229: PPUSH
27230: CALL_OW 88
// YouLost ( Surrender ) ;
27234: LD_STRING Surrender
27236: PPUSH
27237: CALL_OW 104
// exit ;
27241: GO 28199
// end ; if dec = 2 then
27243: LD_VAR 0 2
27247: PUSH
27248: LD_INT 2
27250: EQUAL
27251: IFFALSE 27320
// begin Say ( JMM , D15b-JMM-1 ) ;
27253: LD_EXP 36
27257: PPUSH
27258: LD_STRING D15b-JMM-1
27260: PPUSH
27261: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27265: LD_EXP 61
27269: PPUSH
27270: LD_STRING D15b-Pla-1
27272: PPUSH
27273: CALL_OW 94
// DialogueOff ;
27277: CALL_OW 7
// wait ( 3 3$00 ) ;
27281: LD_INT 6300
27283: PPUSH
27284: CALL_OW 67
// DialogueOn ;
27288: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27292: LD_EXP 36
27296: PPUSH
27297: LD_STRING D15d-JMM-1a
27299: PPUSH
27300: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27304: LD_EXP 61
27308: PPUSH
27309: LD_STRING D15d-Pla-1
27311: PPUSH
27312: CALL_OW 94
// DialogueOff ;
27316: CALL_OW 7
// end ; if dec = 3 then
27320: LD_VAR 0 2
27324: PUSH
27325: LD_INT 3
27327: EQUAL
27328: IFFALSE 27382
// begin Say ( JMM , D15c-JMM-1 ) ;
27330: LD_EXP 36
27334: PPUSH
27335: LD_STRING D15c-JMM-1
27337: PPUSH
27338: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27342: LD_EXP 61
27346: PPUSH
27347: LD_STRING D15c-Pla-1
27349: PPUSH
27350: CALL_OW 94
// DialogueOff ;
27354: CALL_OW 7
// wait ( 0 0$15 ) ;
27358: LD_INT 525
27360: PPUSH
27361: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27365: LD_VAR 0 1
27369: PPUSH
27370: LD_INT 60
27372: PPUSH
27373: LD_INT 95
27375: PPUSH
27376: CALL_OW 116
// exit ;
27380: GO 28199
// end ; if dec = 4 then
27382: LD_VAR 0 2
27386: PUSH
27387: LD_INT 4
27389: EQUAL
27390: IFFALSE 27420
// begin Say ( JMM , D15d-JMM-1 ) ;
27392: LD_EXP 36
27396: PPUSH
27397: LD_STRING D15d-JMM-1
27399: PPUSH
27400: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27404: LD_EXP 61
27408: PPUSH
27409: LD_STRING D15d-Pla-1
27411: PPUSH
27412: CALL_OW 94
// DialogueOff ;
27416: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27420: LD_EXP 59
27424: PPUSH
27425: CALL_OW 302
27429: PUSH
27430: LD_EXP 59
27434: PPUSH
27435: CALL_OW 255
27439: PUSH
27440: LD_INT 1
27442: EQUAL
27443: AND
27444: PUSH
27445: LD_INT 22
27447: PUSH
27448: LD_INT 1
27450: PUSH
27451: EMPTY
27452: LIST
27453: LIST
27454: PUSH
27455: LD_INT 34
27457: PUSH
27458: LD_INT 8
27460: PUSH
27461: EMPTY
27462: LIST
27463: LIST
27464: PUSH
27465: EMPTY
27466: LIST
27467: LIST
27468: PPUSH
27469: CALL_OW 69
27473: NOT
27474: AND
27475: IFFALSE 28100
// begin SetSide ( Friend , 8 ) ;
27477: LD_EXP 59
27481: PPUSH
27482: LD_INT 8
27484: PPUSH
27485: CALL_OW 235
// if IsInUnit ( Friend ) then
27489: LD_EXP 59
27493: PPUSH
27494: CALL_OW 310
27498: IFFALSE 27509
// ComExitBuilding ( Friend ) ;
27500: LD_EXP 59
27504: PPUSH
27505: CALL_OW 122
// if IsDriver ( Friend ) then
27509: LD_EXP 59
27513: PPUSH
27514: CALL 102997 0 1
27518: IFFALSE 27529
// ComExitVehicle ( Friend ) ;
27520: LD_EXP 59
27524: PPUSH
27525: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27529: LD_EXP 59
27533: PPUSH
27534: LD_INT 9
27536: PPUSH
27537: LD_INT 2
27539: PPUSH
27540: CALL_OW 171
// wait ( 0 0$05 ) ;
27544: LD_INT 175
27546: PPUSH
27547: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27551: LD_EXP 59
27555: PPUSH
27556: CALL_OW 87
// DialogueOn ;
27560: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27564: LD_EXP 36
27568: PPUSH
27569: LD_STRING D16-JMM-1
27571: PPUSH
27572: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27576: LD_EXP 59
27580: PPUSH
27581: LD_STRING D16-Friend-1
27583: PPUSH
27584: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27588: LD_EXP 36
27592: PPUSH
27593: LD_STRING D16-JMM-2
27595: PPUSH
27596: CALL_OW 88
// DialogueOff ;
27600: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27604: LD_EXP 59
27608: PPUSH
27609: LD_INT 1
27611: PPUSH
27612: CALL_OW 235
// ComHold ( Friend ) ;
27616: LD_EXP 59
27620: PPUSH
27621: CALL_OW 140
// wait ( 0 0$20 ) ;
27625: LD_INT 700
27627: PPUSH
27628: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27632: LD_EXP 59
27636: PPUSH
27637: LD_INT 9
27639: PPUSH
27640: LD_INT 2
27642: PPUSH
27643: CALL_OW 297
27647: PUSH
27648: LD_INT 30
27650: LESS
27651: IFFALSE 27720
// begin SetSide ( Friend , 8 ) ;
27653: LD_EXP 59
27657: PPUSH
27658: LD_INT 8
27660: PPUSH
27661: CALL_OW 235
// if IsInUnit ( Friend ) then
27665: LD_EXP 59
27669: PPUSH
27670: CALL_OW 310
27674: IFFALSE 27685
// ComExitBuilding ( Friend ) ;
27676: LD_EXP 59
27680: PPUSH
27681: CALL_OW 122
// if IsDriver ( Friend ) then
27685: LD_EXP 59
27689: PPUSH
27690: CALL 102997 0 1
27694: IFFALSE 27705
// ComExitVehicle ( Friend ) ;
27696: LD_EXP 59
27700: PPUSH
27701: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27705: LD_EXP 59
27709: PPUSH
27710: LD_INT 9
27712: PPUSH
27713: LD_INT 2
27715: PPUSH
27716: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27720: LD_INT 1050
27722: PPUSH
27723: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27727: LD_INT 22
27729: PUSH
27730: LD_INT 1
27732: PUSH
27733: EMPTY
27734: LIST
27735: LIST
27736: PUSH
27737: LD_INT 34
27739: PUSH
27740: LD_INT 8
27742: PUSH
27743: EMPTY
27744: LIST
27745: LIST
27746: PUSH
27747: EMPTY
27748: LIST
27749: LIST
27750: PPUSH
27751: CALL_OW 69
27755: NOT
27756: IFFALSE 28078
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27758: LD_ADDR_VAR 0 3
27762: PUSH
27763: LD_INT 22
27765: PUSH
27766: LD_INT 1
27768: PUSH
27769: EMPTY
27770: LIST
27771: LIST
27772: PUSH
27773: LD_INT 26
27775: PUSH
27776: LD_INT 1
27778: PUSH
27779: EMPTY
27780: LIST
27781: LIST
27782: PUSH
27783: LD_INT 3
27785: PUSH
27786: LD_INT 25
27788: PUSH
27789: LD_INT 12
27791: PUSH
27792: EMPTY
27793: LIST
27794: LIST
27795: PUSH
27796: LD_INT 25
27798: PUSH
27799: LD_INT 16
27801: PUSH
27802: EMPTY
27803: LIST
27804: LIST
27805: PUSH
27806: EMPTY
27807: LIST
27808: LIST
27809: LIST
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: LIST
27815: PPUSH
27816: CALL_OW 69
27820: PUSH
27821: LD_EXP 36
27825: PUSH
27826: LD_EXP 38
27830: PUSH
27831: LD_EXP 52
27835: PUSH
27836: LD_EXP 39
27840: PUSH
27841: LD_EXP 40
27845: PUSH
27846: LD_EXP 41
27850: PUSH
27851: LD_EXP 42
27855: PUSH
27856: LD_EXP 43
27860: PUSH
27861: LD_EXP 44
27865: PUSH
27866: LD_EXP 45
27870: PUSH
27871: LD_EXP 46
27875: PUSH
27876: LD_EXP 47
27880: PUSH
27881: LD_EXP 48
27885: PUSH
27886: LD_EXP 49
27890: PUSH
27891: LD_EXP 50
27895: PUSH
27896: EMPTY
27897: LIST
27898: LIST
27899: LIST
27900: LIST
27901: LIST
27902: LIST
27903: LIST
27904: LIST
27905: LIST
27906: LIST
27907: LIST
27908: LIST
27909: LIST
27910: LIST
27911: LIST
27912: DIFF
27913: ST_TO_ADDR
// DialogueOn ;
27914: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
27918: LD_EXP 61
27922: PPUSH
27923: LD_STRING D16a-Pla-1
27925: PPUSH
27926: CALL_OW 94
// if Stevens then
27930: LD_EXP 38
27934: IFFALSE 27950
// Say ( Stevens , D16a-Huck-1 ) else
27936: LD_EXP 38
27940: PPUSH
27941: LD_STRING D16a-Huck-1
27943: PPUSH
27944: CALL_OW 88
27948: GO 27992
// if Baker then
27950: LD_EXP 52
27954: IFFALSE 27970
// Say ( Baker , D16a-Huck-1 ) else
27956: LD_EXP 52
27960: PPUSH
27961: LD_STRING D16a-Huck-1
27963: PPUSH
27964: CALL_OW 88
27968: GO 27992
// if tmp then
27970: LD_VAR 0 3
27974: IFFALSE 27992
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
27976: LD_VAR 0 3
27980: PUSH
27981: LD_INT 1
27983: ARRAY
27984: PPUSH
27985: LD_STRING D16a-Sol1-1
27987: PPUSH
27988: CALL_OW 88
// if GetSide ( Friend ) = 8 then
27992: LD_EXP 59
27996: PPUSH
27997: CALL_OW 255
28001: PUSH
28002: LD_INT 8
28004: EQUAL
28005: IFFALSE 28021
// Say ( JMM , D16a-JMM-1 ) else
28007: LD_EXP 36
28011: PPUSH
28012: LD_STRING D16a-JMM-1
28014: PPUSH
28015: CALL_OW 88
28019: GO 28057
// begin Say ( JMM , D16a-JMM-1a ) ;
28021: LD_EXP 36
28025: PPUSH
28026: LD_STRING D16a-JMM-1a
28028: PPUSH
28029: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28033: LD_EXP 59
28037: PPUSH
28038: LD_STRING D16a-Friend-1
28040: PPUSH
28041: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28045: LD_EXP 59
28049: PPUSH
28050: LD_INT 3
28052: PPUSH
28053: CALL_OW 235
// end ; DialogueOff ;
28057: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28061: LD_VAR 0 1
28065: PPUSH
28066: LD_INT 60
28068: PPUSH
28069: LD_INT 95
28071: PPUSH
28072: CALL_OW 116
// end else
28076: GO 28098
// begin DialogueOn ;
28078: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28082: LD_EXP 61
28086: PPUSH
28087: LD_STRING D16c-Pla-
28089: PPUSH
28090: CALL_OW 94
// DialogueOff ;
28094: CALL_OW 7
// end ; end else
28098: GO 28199
// begin wait ( 3 3$00 ) ;
28100: LD_INT 6300
28102: PPUSH
28103: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28107: LD_INT 22
28109: PUSH
28110: LD_INT 1
28112: PUSH
28113: EMPTY
28114: LIST
28115: LIST
28116: PUSH
28117: LD_INT 34
28119: PUSH
28120: LD_INT 8
28122: PUSH
28123: EMPTY
28124: LIST
28125: LIST
28126: PUSH
28127: EMPTY
28128: LIST
28129: LIST
28130: PPUSH
28131: CALL_OW 69
28135: NOT
28136: IFFALSE 28179
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28138: LD_EXP 61
28142: PPUSH
28143: LD_STRING D16b-Pla-1
28145: PPUSH
28146: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28150: LD_EXP 36
28154: PPUSH
28155: LD_STRING D16b-JMM-
28157: PPUSH
28158: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28162: LD_VAR 0 1
28166: PPUSH
28167: LD_INT 60
28169: PPUSH
28170: LD_INT 95
28172: PPUSH
28173: CALL_OW 116
// end else
28177: GO 28199
// begin DialogueOn ;
28179: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28183: LD_EXP 61
28187: PPUSH
28188: LD_STRING D16c-Pla-
28190: PPUSH
28191: CALL_OW 94
// DialogueOff ;
28195: CALL_OW 7
// end ; end ; end ;
28199: PPOPN 3
28201: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28202: LD_EXP 14
28206: PUSH
28207: LD_INT 126000
28209: GREATEREQUAL
28210: PUSH
28211: LD_EXP 23
28215: NOT
28216: AND
28217: PUSH
28218: LD_EXP 71
28222: PPUSH
28223: CALL_OW 302
28227: AND
28228: IFFALSE 28586
28230: GO 28232
28232: DISABLE
28233: LD_INT 0
28235: PPUSH
// begin missionStage = 11 ;
28236: LD_ADDR_EXP 15
28240: PUSH
28241: LD_INT 11
28243: ST_TO_ADDR
// DialogueOn ;
28244: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28248: LD_EXP 71
28252: PPUSH
28253: LD_STRING D9-Roth-1
28255: PPUSH
28256: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28260: LD_EXP 36
28264: PPUSH
28265: LD_STRING D9-JMM-1
28267: PPUSH
28268: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28272: LD_EXP 71
28276: PPUSH
28277: LD_STRING D9-Roth-2
28279: PPUSH
28280: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28284: LD_EXP 71
28288: PPUSH
28289: LD_STRING D9-Roth-2a
28291: PPUSH
28292: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28296: LD_EXP 61
28300: PPUSH
28301: LD_STRING D9-Pla-2
28303: PPUSH
28304: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28308: LD_EXP 71
28312: PPUSH
28313: LD_STRING D9-Roth-3
28315: PPUSH
28316: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28320: LD_EXP 61
28324: PPUSH
28325: LD_STRING D9-Pla-3
28327: PPUSH
28328: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28332: LD_EXP 71
28336: PPUSH
28337: LD_STRING D9-Roth-4
28339: PPUSH
28340: CALL_OW 94
// dec = Query ( Q9 ) ;
28344: LD_ADDR_VAR 0 1
28348: PUSH
28349: LD_STRING Q9
28351: PPUSH
28352: CALL_OW 97
28356: ST_TO_ADDR
// if dec = 1 then
28357: LD_VAR 0 1
28361: PUSH
28362: LD_INT 1
28364: EQUAL
28365: IFFALSE 28379
// SayRadio ( Roth , D9a-Roth-1 ) ;
28367: LD_EXP 71
28371: PPUSH
28372: LD_STRING D9a-Roth-1
28374: PPUSH
28375: CALL_OW 94
// if dec = 2 then
28379: LD_VAR 0 1
28383: PUSH
28384: LD_INT 2
28386: EQUAL
28387: IFFALSE 28413
// begin Say ( JMM , D9b-JMM-1 ) ;
28389: LD_EXP 36
28393: PPUSH
28394: LD_STRING D9b-JMM-1
28396: PPUSH
28397: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28401: LD_EXP 71
28405: PPUSH
28406: LD_STRING D9b-Roth-1
28408: PPUSH
28409: CALL_OW 94
// end ; if dec = 3 then
28413: LD_VAR 0 1
28417: PUSH
28418: LD_INT 3
28420: EQUAL
28421: IFFALSE 28483
// begin Say ( JMM , D9c-JMM-1 ) ;
28423: LD_EXP 36
28427: PPUSH
28428: LD_STRING D9c-JMM-1
28430: PPUSH
28431: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28435: LD_EXP 71
28439: PPUSH
28440: LD_STRING D9c-Roth-1
28442: PPUSH
28443: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28447: LD_EXP 36
28451: PPUSH
28452: LD_STRING D9c-JMM-2
28454: PPUSH
28455: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28459: LD_EXP 71
28463: PPUSH
28464: LD_STRING D9c-Roth-2
28466: PPUSH
28467: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28471: LD_EXP 36
28475: PPUSH
28476: LD_STRING D9c-JMM-3
28478: PPUSH
28479: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28483: LD_EXP 71
28487: PPUSH
28488: LD_STRING D9c-Roth-3
28490: PPUSH
28491: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28495: LD_EXP 71
28499: PPUSH
28500: LD_STRING D9cont-Roth-1
28502: PPUSH
28503: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28507: LD_EXP 36
28511: PPUSH
28512: LD_STRING D9cont-JMM-1
28514: PPUSH
28515: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28519: LD_EXP 71
28523: PPUSH
28524: LD_STRING D9cont-Roth-2
28526: PPUSH
28527: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28531: LD_EXP 36
28535: PPUSH
28536: LD_STRING D9cont-JMM-2
28538: PPUSH
28539: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28543: LD_EXP 71
28547: PPUSH
28548: LD_STRING D9cont-Roth-3
28550: PPUSH
28551: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28555: LD_EXP 36
28559: PPUSH
28560: LD_STRING D9cont-JMM-3
28562: PPUSH
28563: CALL_OW 88
// DialogueOff ;
28567: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28571: LD_STRING M3
28573: PPUSH
28574: CALL_OW 337
// allianceActive := true ;
28578: LD_ADDR_EXP 31
28582: PUSH
28583: LD_INT 1
28585: ST_TO_ADDR
// end ;
28586: PPOPN 1
28588: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28589: LD_EXP 61
28593: PPUSH
28594: CALL_OW 301
28598: PUSH
28599: LD_EXP 64
28603: PPUSH
28604: CALL_OW 301
28608: AND
28609: PUSH
28610: LD_INT 22
28612: PUSH
28613: LD_INT 3
28615: PUSH
28616: EMPTY
28617: LIST
28618: LIST
28619: PUSH
28620: LD_INT 21
28622: PUSH
28623: LD_INT 1
28625: PUSH
28626: EMPTY
28627: LIST
28628: LIST
28629: PUSH
28630: LD_INT 50
28632: PUSH
28633: EMPTY
28634: LIST
28635: PUSH
28636: EMPTY
28637: LIST
28638: LIST
28639: LIST
28640: PPUSH
28641: CALL_OW 69
28645: PUSH
28646: LD_INT 7
28648: PUSH
28649: LD_INT 8
28651: PUSH
28652: LD_INT 9
28654: PUSH
28655: EMPTY
28656: LIST
28657: LIST
28658: LIST
28659: PUSH
28660: LD_OWVAR 67
28664: ARRAY
28665: LESS
28666: AND
28667: IFFALSE 29438
28669: GO 28671
28671: DISABLE
28672: LD_INT 0
28674: PPUSH
28675: PPUSH
28676: PPUSH
28677: PPUSH
// begin MC_Kill ( 1 ) ;
28678: LD_INT 1
28680: PPUSH
28681: CALL 33936 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28685: LD_INT 1
28687: PPUSH
28688: LD_INT 3
28690: PPUSH
28691: LD_INT 1
28693: PPUSH
28694: LD_INT 1
28696: PPUSH
28697: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28701: LD_ADDR_VAR 0 1
28705: PUSH
28706: LD_INT 22
28708: PUSH
28709: LD_INT 3
28711: PUSH
28712: EMPTY
28713: LIST
28714: LIST
28715: PUSH
28716: LD_INT 21
28718: PUSH
28719: LD_INT 1
28721: PUSH
28722: EMPTY
28723: LIST
28724: LIST
28725: PUSH
28726: LD_INT 24
28728: PUSH
28729: LD_INT 900
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: PUSH
28736: EMPTY
28737: LIST
28738: LIST
28739: LIST
28740: PPUSH
28741: CALL_OW 69
28745: PUSH
28746: FOR_IN
28747: IFFALSE 28778
// if GetSex ( i ) = sex_male then
28749: LD_VAR 0 1
28753: PPUSH
28754: CALL_OW 258
28758: PUSH
28759: LD_INT 1
28761: EQUAL
28762: IFFALSE 28776
// begin tmp = i ;
28764: LD_ADDR_VAR 0 2
28768: PUSH
28769: LD_VAR 0 1
28773: ST_TO_ADDR
// break ;
28774: GO 28778
// end ;
28776: GO 28746
28778: POP
28779: POP
// if tmp = 0 then
28780: LD_VAR 0 2
28784: PUSH
28785: LD_INT 0
28787: EQUAL
28788: IFFALSE 28842
// begin uc_side = 3 ;
28790: LD_ADDR_OWVAR 20
28794: PUSH
28795: LD_INT 3
28797: ST_TO_ADDR
// uc_nation = 3 ;
28798: LD_ADDR_OWVAR 21
28802: PUSH
28803: LD_INT 3
28805: ST_TO_ADDR
// hc_name =  ;
28806: LD_ADDR_OWVAR 26
28810: PUSH
28811: LD_STRING 
28813: ST_TO_ADDR
// hc_gallery =  ;
28814: LD_ADDR_OWVAR 33
28818: PUSH
28819: LD_STRING 
28821: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28822: LD_INT 1
28824: PPUSH
28825: LD_INT 10
28827: PPUSH
28828: CALL_OW 381
// tmp = CreateHuman ;
28832: LD_ADDR_VAR 0 2
28836: PUSH
28837: CALL_OW 44
28841: ST_TO_ADDR
// end ; DialogueOn ;
28842: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28846: LD_VAR 0 2
28850: PPUSH
28851: LD_STRING DSurrenderRussians-RSol1-1a
28853: PPUSH
28854: CALL_OW 88
// DialogueOff ;
28858: CALL_OW 7
// russianDestroyed := true ;
28862: LD_ADDR_EXP 21
28866: PUSH
28867: LD_INT 1
28869: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28870: LD_INT 22
28872: PUSH
28873: LD_INT 3
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: PUSH
28880: LD_INT 21
28882: PUSH
28883: LD_INT 1
28885: PUSH
28886: EMPTY
28887: LIST
28888: LIST
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PPUSH
28894: CALL_OW 69
28898: PPUSH
28899: CALL_OW 122
// wait ( 0 0$1 ) ;
28903: LD_INT 35
28905: PPUSH
28906: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
28910: LD_INT 22
28912: PUSH
28913: LD_INT 3
28915: PUSH
28916: EMPTY
28917: LIST
28918: LIST
28919: PUSH
28920: LD_INT 21
28922: PUSH
28923: LD_INT 1
28925: PUSH
28926: EMPTY
28927: LIST
28928: LIST
28929: PUSH
28930: EMPTY
28931: LIST
28932: LIST
28933: PPUSH
28934: CALL_OW 69
28938: PPUSH
28939: LD_INT 25
28941: PPUSH
28942: CALL_OW 173
// wait ( 0 0$10 ) ;
28946: LD_INT 350
28948: PPUSH
28949: CALL_OW 67
// PrepareOmarInvasion ;
28953: CALL 13611 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
28957: LD_ADDR_VAR 0 2
28961: PUSH
28962: LD_EXP 89
28966: PPUSH
28967: CALL_OW 250
28971: PUSH
28972: LD_EXP 89
28976: PPUSH
28977: CALL_OW 251
28981: PUSH
28982: EMPTY
28983: LIST
28984: LIST
28985: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
28986: LD_VAR 0 2
28990: PUSH
28991: LD_INT 1
28993: ARRAY
28994: PPUSH
28995: LD_VAR 0 2
28999: PUSH
29000: LD_INT 2
29002: ARRAY
29003: PPUSH
29004: LD_INT 1
29006: PPUSH
29007: LD_INT 8
29009: NEG
29010: PPUSH
29011: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29015: LD_EXP 89
29019: PPUSH
29020: CALL_OW 87
// DialogueOn ;
29024: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29028: LD_EXP 36
29032: PPUSH
29033: LD_STRING D19-JMM-1
29035: PPUSH
29036: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29040: LD_ADDR_VAR 0 3
29044: PUSH
29045: LD_INT 22
29047: PUSH
29048: LD_INT 1
29050: PUSH
29051: EMPTY
29052: LIST
29053: LIST
29054: PUSH
29055: LD_INT 26
29057: PUSH
29058: LD_INT 1
29060: PUSH
29061: EMPTY
29062: LIST
29063: LIST
29064: PUSH
29065: LD_INT 2
29067: PUSH
29068: LD_INT 25
29070: PUSH
29071: LD_INT 1
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: LD_INT 25
29080: PUSH
29081: LD_INT 2
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PUSH
29088: LD_INT 25
29090: PUSH
29091: LD_INT 3
29093: PUSH
29094: EMPTY
29095: LIST
29096: LIST
29097: PUSH
29098: LD_INT 25
29100: PUSH
29101: LD_INT 4
29103: PUSH
29104: EMPTY
29105: LIST
29106: LIST
29107: PUSH
29108: LD_INT 25
29110: PUSH
29111: LD_INT 5
29113: PUSH
29114: EMPTY
29115: LIST
29116: LIST
29117: PUSH
29118: LD_INT 25
29120: PUSH
29121: LD_INT 8
29123: PUSH
29124: EMPTY
29125: LIST
29126: LIST
29127: PUSH
29128: EMPTY
29129: LIST
29130: LIST
29131: LIST
29132: LIST
29133: LIST
29134: LIST
29135: LIST
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: LIST
29141: PPUSH
29142: CALL_OW 69
29146: PUSH
29147: LD_EXP 36
29151: PUSH
29152: LD_EXP 37
29156: PUSH
29157: LD_EXP 38
29161: PUSH
29162: LD_EXP 39
29166: PUSH
29167: LD_EXP 40
29171: PUSH
29172: LD_EXP 41
29176: PUSH
29177: LD_EXP 42
29181: PUSH
29182: LD_EXP 43
29186: PUSH
29187: LD_EXP 44
29191: PUSH
29192: LD_EXP 45
29196: PUSH
29197: LD_EXP 46
29201: PUSH
29202: LD_EXP 47
29206: PUSH
29207: LD_EXP 48
29211: PUSH
29212: LD_EXP 49
29216: PUSH
29217: LD_EXP 50
29221: PUSH
29222: LD_EXP 51
29226: PUSH
29227: LD_EXP 52
29231: PUSH
29232: EMPTY
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: LIST
29241: LIST
29242: LIST
29243: LIST
29244: LIST
29245: LIST
29246: LIST
29247: LIST
29248: LIST
29249: LIST
29250: DIFF
29251: ST_TO_ADDR
// if tmp2 then
29252: LD_VAR 0 3
29256: IFFALSE 29274
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29258: LD_VAR 0 3
29262: PUSH
29263: LD_INT 1
29265: ARRAY
29266: PPUSH
29267: LD_STRING D19-Sol1-1
29269: PPUSH
29270: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29274: LD_EXP 36
29278: PPUSH
29279: LD_STRING D19-JMM-2
29281: PPUSH
29282: CALL_OW 88
// DialogueOff ;
29286: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29290: LD_VAR 0 2
29294: PUSH
29295: LD_INT 1
29297: ARRAY
29298: PPUSH
29299: LD_VAR 0 2
29303: PUSH
29304: LD_INT 2
29306: ARRAY
29307: PPUSH
29308: LD_INT 1
29310: PPUSH
29311: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29315: LD_STRING M5
29317: PPUSH
29318: CALL_OW 337
// omarOnMotherLode := false ;
29322: LD_ADDR_VAR 0 4
29326: PUSH
29327: LD_INT 0
29329: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29330: LD_INT 35
29332: PPUSH
29333: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29337: LD_EXP 89
29341: PPUSH
29342: LD_INT 215
29344: PPUSH
29345: LD_INT 100
29347: PPUSH
29348: CALL_OW 297
29352: PUSH
29353: LD_INT 10
29355: LESS
29356: PUSH
29357: LD_VAR 0 4
29361: NOT
29362: AND
29363: IFFALSE 29397
// begin omarOnMotherLode := true ;
29365: LD_ADDR_VAR 0 4
29369: PUSH
29370: LD_INT 1
29372: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29373: LD_EXP 36
29377: PPUSH
29378: LD_STRING D19b-JMM-1
29380: PPUSH
29381: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29385: LD_EXP 89
29389: PPUSH
29390: LD_STRING DOmarContam-Omar-1
29392: PPUSH
29393: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29397: LD_EXP 89
29401: PPUSH
29402: CALL_OW 301
29406: IFFALSE 29330
// Say ( JMM , D19a-JMM-1 ) ;
29408: LD_EXP 36
29412: PPUSH
29413: LD_STRING D19a-JMM-1
29415: PPUSH
29416: CALL_OW 88
// if Heike then
29420: LD_EXP 90
29424: IFFALSE 29438
// Say ( Heike , D19a-Hke-1 ) ;
29426: LD_EXP 90
29430: PPUSH
29431: LD_STRING D19a-Hke-1
29433: PPUSH
29434: CALL_OW 88
// end ;
29438: PPOPN 4
29440: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29441: LD_INT 22
29443: PUSH
29444: LD_INT 3
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 21
29453: PUSH
29454: LD_INT 1
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: PUSH
29461: EMPTY
29462: LIST
29463: LIST
29464: PPUSH
29465: CALL_OW 69
29469: PUSH
29470: LD_EXP 21
29474: AND
29475: IFFALSE 29543
29477: GO 29479
29479: DISABLE
29480: LD_INT 0
29482: PPUSH
29483: PPUSH
// begin enable ;
29484: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29485: LD_ADDR_VAR 0 2
29489: PUSH
29490: LD_INT 25
29492: PPUSH
29493: LD_INT 22
29495: PUSH
29496: LD_INT 3
29498: PUSH
29499: EMPTY
29500: LIST
29501: LIST
29502: PPUSH
29503: CALL_OW 70
29507: ST_TO_ADDR
// if not tmp then
29508: LD_VAR 0 2
29512: NOT
29513: IFFALSE 29517
// exit ;
29515: GO 29543
// for i in tmp do
29517: LD_ADDR_VAR 0 1
29521: PUSH
29522: LD_VAR 0 2
29526: PUSH
29527: FOR_IN
29528: IFFALSE 29541
// RemoveUnit ( i ) ;
29530: LD_VAR 0 1
29534: PPUSH
29535: CALL_OW 64
29539: GO 29527
29541: POP
29542: POP
// end ;
29543: PPOPN 2
29545: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29546: LD_INT 22
29548: PUSH
29549: LD_INT 7
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 21
29558: PUSH
29559: LD_INT 1
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: EMPTY
29567: LIST
29568: LIST
29569: PPUSH
29570: CALL_OW 69
29574: PUSH
29575: LD_INT 6
29577: LESS
29578: IFFALSE 30029
29580: GO 29582
29582: DISABLE
29583: LD_INT 0
29585: PPUSH
29586: PPUSH
// begin MC_Kill ( 1 ) ;
29587: LD_INT 1
29589: PPUSH
29590: CALL 33936 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29594: LD_INT 7
29596: PPUSH
29597: LD_INT 1
29599: PPUSH
29600: LD_INT 1
29602: PPUSH
29603: LD_INT 1
29605: PPUSH
29606: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29610: LD_ADDR_VAR 0 1
29614: PUSH
29615: LD_INT 22
29617: PUSH
29618: LD_INT 7
29620: PUSH
29621: EMPTY
29622: LIST
29623: LIST
29624: PUSH
29625: LD_INT 26
29627: PUSH
29628: LD_INT 1
29630: PUSH
29631: EMPTY
29632: LIST
29633: LIST
29634: PUSH
29635: EMPTY
29636: LIST
29637: LIST
29638: PPUSH
29639: CALL_OW 69
29643: PUSH
29644: LD_EXP 71
29648: DIFF
29649: ST_TO_ADDR
// if tmp then
29650: LD_VAR 0 1
29654: IFFALSE 29672
// tmp := tmp [ 1 ] else
29656: LD_ADDR_VAR 0 1
29660: PUSH
29661: LD_VAR 0 1
29665: PUSH
29666: LD_INT 1
29668: ARRAY
29669: ST_TO_ADDR
29670: GO 29708
// begin uc_side := 7 ;
29672: LD_ADDR_OWVAR 20
29676: PUSH
29677: LD_INT 7
29679: ST_TO_ADDR
// uc_nation := 1 ;
29680: LD_ADDR_OWVAR 21
29684: PUSH
29685: LD_INT 1
29687: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29688: LD_INT 1
29690: PPUSH
29691: LD_INT 8
29693: PPUSH
29694: CALL_OW 384
// tmp := CreateHuman ;
29698: LD_ADDR_VAR 0 1
29702: PUSH
29703: CALL_OW 44
29707: ST_TO_ADDR
// end ; DialogueOn ;
29708: CALL_OW 6
// if IsOK ( Roth ) then
29712: LD_EXP 71
29716: PPUSH
29717: CALL_OW 302
29721: IFFALSE 29735
// Say ( JMM , DAb-JMM-1 ) ;
29723: LD_EXP 36
29727: PPUSH
29728: LD_STRING DAb-JMM-1
29730: PPUSH
29731: CALL_OW 88
// if IsOK ( Roth ) then
29735: LD_EXP 71
29739: PPUSH
29740: CALL_OW 302
29744: IFFALSE 29768
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29746: LD_EXP 71
29750: PPUSH
29751: LD_STRING DSurrenderAlliance-Roth-1
29753: PPUSH
29754: CALL_OW 88
// RothCaptured := true ;
29758: LD_ADDR_EXP 33
29762: PUSH
29763: LD_INT 1
29765: ST_TO_ADDR
// end else
29766: GO 29780
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29768: LD_VAR 0 1
29772: PPUSH
29773: LD_STRING DSurrenderAlliance-Sci1-1
29775: PPUSH
29776: CALL_OW 88
// DialogueOff ;
29780: CALL_OW 7
// allianceDestroyed := true ;
29784: LD_ADDR_EXP 23
29788: PUSH
29789: LD_INT 1
29791: ST_TO_ADDR
// if trueAmericans then
29792: LD_EXP 35
29796: IFFALSE 29872
// begin if trueAmericans = 1 then
29798: LD_EXP 35
29802: PUSH
29803: LD_INT 1
29805: EQUAL
29806: IFFALSE 29822
// Say ( JMM , DAb-JMM-1a ) else
29808: LD_EXP 36
29812: PPUSH
29813: LD_STRING DAb-JMM-1a
29815: PPUSH
29816: CALL_OW 88
29820: GO 29834
// Say ( JMM , DAb-JMM-1b ) ;
29822: LD_EXP 36
29826: PPUSH
29827: LD_STRING DAb-JMM-1b
29829: PPUSH
29830: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29834: LD_EXP 35
29838: PPUSH
29839: CALL_OW 87
// for i in trueAmericans do
29843: LD_ADDR_VAR 0 2
29847: PUSH
29848: LD_EXP 35
29852: PUSH
29853: FOR_IN
29854: IFFALSE 29870
// SetSide ( i , 1 ) ;
29856: LD_VAR 0 2
29860: PPUSH
29861: LD_INT 1
29863: PPUSH
29864: CALL_OW 235
29868: GO 29853
29870: POP
29871: POP
// end ; repeat wait ( 0 0$1 ) ;
29872: LD_INT 35
29874: PPUSH
29875: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29879: LD_ADDR_VAR 0 2
29883: PUSH
29884: LD_INT 22
29886: PUSH
29887: LD_INT 7
29889: PUSH
29890: EMPTY
29891: LIST
29892: LIST
29893: PUSH
29894: LD_INT 21
29896: PUSH
29897: LD_INT 1
29899: PUSH
29900: EMPTY
29901: LIST
29902: LIST
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PPUSH
29908: CALL_OW 69
29912: PUSH
29913: FOR_IN
29914: IFFALSE 29996
// begin if IsInUnit ( i ) then
29916: LD_VAR 0 2
29920: PPUSH
29921: CALL_OW 310
29925: IFFALSE 29936
// ComExitBuilding ( i ) ;
29927: LD_VAR 0 2
29931: PPUSH
29932: CALL_OW 122
// if IsDriver ( i ) then
29936: LD_VAR 0 2
29940: PPUSH
29941: CALL 102997 0 1
29945: IFFALSE 29956
// ComExitVehicle ( i ) ;
29947: LD_VAR 0 2
29951: PPUSH
29952: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
29956: LD_VAR 0 2
29960: PPUSH
29961: LD_INT 26
29963: PPUSH
29964: CALL_OW 308
29968: NOT
29969: IFFALSE 29985
// AddComMoveToArea ( i , allianceEscapeArea ) else
29971: LD_VAR 0 2
29975: PPUSH
29976: LD_INT 26
29978: PPUSH
29979: CALL_OW 173
29983: GO 29994
// RemoveUnit ( i ) ;
29985: LD_VAR 0 2
29989: PPUSH
29990: CALL_OW 64
// end ;
29994: GO 29913
29996: POP
29997: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
29998: LD_INT 22
30000: PUSH
30001: LD_INT 7
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 21
30010: PUSH
30011: LD_INT 1
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: EMPTY
30019: LIST
30020: LIST
30021: PPUSH
30022: CALL_OW 69
30026: NOT
30027: IFFALSE 29872
// end ;
30029: PPOPN 2
30031: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30032: LD_INT 0
30034: PPUSH
30035: PPUSH
// if not unit then
30036: LD_VAR 0 1
30040: NOT
30041: IFFALSE 30045
// exit ;
30043: GO 31543
// DoNotAttack ( 7 , unit ) ;
30045: LD_INT 7
30047: PPUSH
30048: LD_VAR 0 1
30052: PPUSH
30053: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30057: LD_VAR 0 1
30061: PPUSH
30062: LD_INT 260
30064: PPUSH
30065: LD_INT 235
30067: PPUSH
30068: LD_INT 3
30070: PPUSH
30071: LD_INT 1
30073: PPUSH
30074: CALL_OW 483
// SetSide ( unit , 4 ) ;
30078: LD_VAR 0 1
30082: PPUSH
30083: LD_INT 4
30085: PPUSH
30086: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30090: LD_ADDR_EXP 34
30094: PUSH
30095: LD_EXP 34
30099: PUSH
30100: LD_INT 1
30102: PLUS
30103: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30104: LD_INT 70
30106: PPUSH
30107: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30111: LD_INT 260
30113: PPUSH
30114: LD_INT 235
30116: PPUSH
30117: LD_INT 1
30119: PPUSH
30120: LD_INT 8
30122: NEG
30123: PPUSH
30124: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30128: LD_VAR 0 1
30132: PPUSH
30133: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30137: LD_VAR 0 1
30141: PPUSH
30142: LD_EXP 71
30146: PPUSH
30147: CALL_OW 119
// DialogueOn ;
30151: CALL_OW 6
// case unit of JMM :
30155: LD_VAR 0 1
30159: PUSH
30160: LD_EXP 36
30164: DOUBLE
30165: EQUAL
30166: IFTRUE 30170
30168: GO 30185
30170: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30171: LD_EXP 36
30175: PPUSH
30176: LD_STRING DA1-JMM-1
30178: PPUSH
30179: CALL_OW 91
30183: GO 30627
30185: LD_EXP 37
30189: DOUBLE
30190: EQUAL
30191: IFTRUE 30195
30193: GO 30210
30195: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30196: LD_EXP 37
30200: PPUSH
30201: LD_STRING DA1-Joan-1
30203: PPUSH
30204: CALL_OW 91
30208: GO 30627
30210: LD_EXP 39
30214: DOUBLE
30215: EQUAL
30216: IFTRUE 30220
30218: GO 30235
30220: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30221: LD_EXP 39
30225: PPUSH
30226: LD_STRING DA1-Lisa-1
30228: PPUSH
30229: CALL_OW 91
30233: GO 30627
30235: LD_EXP 40
30239: DOUBLE
30240: EQUAL
30241: IFTRUE 30245
30243: GO 30260
30245: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30246: LD_EXP 40
30250: PPUSH
30251: LD_STRING DA1-Don-1
30253: PPUSH
30254: CALL_OW 91
30258: GO 30627
30260: LD_EXP 47
30264: DOUBLE
30265: EQUAL
30266: IFTRUE 30270
30268: GO 30285
30270: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30271: LD_EXP 47
30275: PPUSH
30276: LD_STRING DA1-Corn-1
30278: PPUSH
30279: CALL_OW 91
30283: GO 30627
30285: LD_EXP 43
30289: DOUBLE
30290: EQUAL
30291: IFTRUE 30295
30293: GO 30310
30295: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30296: LD_EXP 43
30300: PPUSH
30301: LD_STRING DA1-Den-1
30303: PPUSH
30304: CALL_OW 91
30308: GO 30627
30310: LD_EXP 41
30314: DOUBLE
30315: EQUAL
30316: IFTRUE 30320
30318: GO 30335
30320: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30321: LD_EXP 41
30325: PPUSH
30326: LD_STRING DA1-Bobby-1
30328: PPUSH
30329: CALL_OW 91
30333: GO 30627
30335: LD_EXP 45
30339: DOUBLE
30340: EQUAL
30341: IFTRUE 30345
30343: GO 30360
30345: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30346: LD_EXP 45
30350: PPUSH
30351: LD_STRING DA1-Glad-1
30353: PPUSH
30354: CALL_OW 91
30358: GO 30627
30360: LD_EXP 42
30364: DOUBLE
30365: EQUAL
30366: IFTRUE 30370
30368: GO 30385
30370: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30371: LD_EXP 42
30375: PPUSH
30376: LD_STRING DA1-Cyrus-1
30378: PPUSH
30379: CALL_OW 91
30383: GO 30627
30385: LD_EXP 38
30389: DOUBLE
30390: EQUAL
30391: IFTRUE 30395
30393: GO 30410
30395: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30396: LD_EXP 38
30400: PPUSH
30401: LD_STRING DA1-Huck-1
30403: PPUSH
30404: CALL_OW 91
30408: GO 30627
30410: LD_EXP 52
30414: DOUBLE
30415: EQUAL
30416: IFTRUE 30420
30418: GO 30435
30420: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30421: LD_EXP 52
30425: PPUSH
30426: LD_STRING DA1-Huck-1
30428: PPUSH
30429: CALL_OW 91
30433: GO 30627
30435: LD_EXP 44
30439: DOUBLE
30440: EQUAL
30441: IFTRUE 30445
30443: GO 30460
30445: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30446: LD_EXP 44
30450: PPUSH
30451: LD_STRING DA1-Brown-1
30453: PPUSH
30454: CALL_OW 91
30458: GO 30627
30460: LD_EXP 48
30464: DOUBLE
30465: EQUAL
30466: IFTRUE 30470
30468: GO 30485
30470: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30471: LD_EXP 48
30475: PPUSH
30476: LD_STRING DA1-Gary-1
30478: PPUSH
30479: CALL_OW 91
30483: GO 30627
30485: LD_EXP 51
30489: DOUBLE
30490: EQUAL
30491: IFTRUE 30495
30493: GO 30510
30495: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30496: LD_EXP 51
30500: PPUSH
30501: LD_STRING DA1-Con-1
30503: PPUSH
30504: CALL_OW 91
30508: GO 30627
30510: LD_EXP 57
30514: DOUBLE
30515: EQUAL
30516: IFTRUE 30520
30518: GO 30535
30520: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30521: LD_EXP 57
30525: PPUSH
30526: LD_STRING DA1-Kurt-1
30528: PPUSH
30529: CALL_OW 91
30533: GO 30627
30535: LD_EXP 50
30539: DOUBLE
30540: EQUAL
30541: IFTRUE 30545
30543: GO 30560
30545: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30546: LD_EXP 50
30550: PPUSH
30551: LD_STRING DA1-Yam-1
30553: PPUSH
30554: CALL_OW 91
30558: GO 30627
30560: LD_EXP 49
30564: DOUBLE
30565: EQUAL
30566: IFTRUE 30570
30568: GO 30585
30570: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30571: LD_EXP 49
30575: PPUSH
30576: LD_STRING DA1-Frank-1
30578: PPUSH
30579: CALL_OW 91
30583: GO 30627
30585: POP
// begin if GetSex ( unit ) = sex_male then
30586: LD_VAR 0 1
30590: PPUSH
30591: CALL_OW 258
30595: PUSH
30596: LD_INT 1
30598: EQUAL
30599: IFFALSE 30615
// ForceSay ( unit , DA1-Sol1-1 ) else
30601: LD_VAR 0 1
30605: PPUSH
30606: LD_STRING DA1-Sol1-1
30608: PPUSH
30609: CALL_OW 91
30613: GO 30627
// ForceSay ( unit , DA1-FSol1-1 ) ;
30615: LD_VAR 0 1
30619: PPUSH
30620: LD_STRING DA1-FSol1-1
30622: PPUSH
30623: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30627: LD_EXP 71
30631: PPUSH
30632: LD_STRING DA-Roth-1
30634: PPUSH
30635: CALL_OW 88
// if capturedUnit = 1 then
30639: LD_EXP 34
30643: PUSH
30644: LD_INT 1
30646: EQUAL
30647: IFFALSE 30675
// begin Say ( Simms , DA-Sim-1 ) ;
30649: LD_EXP 72
30653: PPUSH
30654: LD_STRING DA-Sim-1
30656: PPUSH
30657: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30661: LD_EXP 71
30665: PPUSH
30666: LD_STRING DA-Roth-2
30668: PPUSH
30669: CALL_OW 88
// end else
30673: GO 30687
// Say ( Simms , DA-Sim-2 ) ;
30675: LD_EXP 72
30679: PPUSH
30680: LD_STRING DA-Sim-2
30682: PPUSH
30683: CALL_OW 88
// case unit of JMM :
30687: LD_VAR 0 1
30691: PUSH
30692: LD_EXP 36
30696: DOUBLE
30697: EQUAL
30698: IFTRUE 30702
30700: GO 30717
30702: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30703: LD_EXP 36
30707: PPUSH
30708: LD_STRING DA1-JMM-1a
30710: PPUSH
30711: CALL_OW 91
30715: GO 31224
30717: LD_EXP 37
30721: DOUBLE
30722: EQUAL
30723: IFTRUE 30727
30725: GO 30742
30727: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30728: LD_EXP 37
30732: PPUSH
30733: LD_STRING DA1-Joan-1a
30735: PPUSH
30736: CALL_OW 91
30740: GO 31224
30742: LD_EXP 39
30746: DOUBLE
30747: EQUAL
30748: IFTRUE 30752
30750: GO 30767
30752: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30753: LD_EXP 39
30757: PPUSH
30758: LD_STRING DA1-Lisa-1a
30760: PPUSH
30761: CALL_OW 91
30765: GO 31224
30767: LD_EXP 40
30771: DOUBLE
30772: EQUAL
30773: IFTRUE 30777
30775: GO 30792
30777: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30778: LD_EXP 40
30782: PPUSH
30783: LD_STRING DA1-Don-1a
30785: PPUSH
30786: CALL_OW 91
30790: GO 31224
30792: LD_EXP 47
30796: DOUBLE
30797: EQUAL
30798: IFTRUE 30802
30800: GO 30817
30802: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30803: LD_EXP 47
30807: PPUSH
30808: LD_STRING DA1-Corn-1a
30810: PPUSH
30811: CALL_OW 91
30815: GO 31224
30817: LD_EXP 43
30821: DOUBLE
30822: EQUAL
30823: IFTRUE 30827
30825: GO 30842
30827: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30828: LD_EXP 43
30832: PPUSH
30833: LD_STRING DA1-Den-1a
30835: PPUSH
30836: CALL_OW 91
30840: GO 31224
30842: LD_EXP 41
30846: DOUBLE
30847: EQUAL
30848: IFTRUE 30852
30850: GO 30867
30852: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30853: LD_EXP 41
30857: PPUSH
30858: LD_STRING DA1-Bobby-1a
30860: PPUSH
30861: CALL_OW 91
30865: GO 31224
30867: LD_EXP 45
30871: DOUBLE
30872: EQUAL
30873: IFTRUE 30877
30875: GO 30892
30877: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30878: LD_EXP 45
30882: PPUSH
30883: LD_STRING DA1-Glad-1a
30885: PPUSH
30886: CALL_OW 91
30890: GO 31224
30892: LD_EXP 42
30896: DOUBLE
30897: EQUAL
30898: IFTRUE 30902
30900: GO 30917
30902: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30903: LD_EXP 42
30907: PPUSH
30908: LD_STRING DA1-Cyrus-1a
30910: PPUSH
30911: CALL_OW 91
30915: GO 31224
30917: LD_EXP 38
30921: DOUBLE
30922: EQUAL
30923: IFTRUE 30927
30925: GO 30942
30927: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
30928: LD_EXP 38
30932: PPUSH
30933: LD_STRING DA1-Huck-1a
30935: PPUSH
30936: CALL_OW 91
30940: GO 31224
30942: LD_EXP 52
30946: DOUBLE
30947: EQUAL
30948: IFTRUE 30952
30950: GO 30967
30952: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
30953: LD_EXP 52
30957: PPUSH
30958: LD_STRING DA1-Huck-1a
30960: PPUSH
30961: CALL_OW 91
30965: GO 31224
30967: LD_EXP 44
30971: DOUBLE
30972: EQUAL
30973: IFTRUE 30977
30975: GO 30992
30977: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
30978: LD_EXP 44
30982: PPUSH
30983: LD_STRING DA1-Brown-1a
30985: PPUSH
30986: CALL_OW 91
30990: GO 31224
30992: LD_EXP 48
30996: DOUBLE
30997: EQUAL
30998: IFTRUE 31002
31000: GO 31017
31002: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31003: LD_EXP 48
31007: PPUSH
31008: LD_STRING DA1-Gary-1a
31010: PPUSH
31011: CALL_OW 91
31015: GO 31224
31017: LD_EXP 51
31021: DOUBLE
31022: EQUAL
31023: IFTRUE 31027
31025: GO 31042
31027: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31028: LD_EXP 51
31032: PPUSH
31033: LD_STRING DA1-Con-1a
31035: PPUSH
31036: CALL_OW 91
31040: GO 31224
31042: LD_EXP 57
31046: DOUBLE
31047: EQUAL
31048: IFTRUE 31052
31050: GO 31067
31052: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31053: LD_EXP 57
31057: PPUSH
31058: LD_STRING DA1-Kurt-1a
31060: PPUSH
31061: CALL_OW 91
31065: GO 31224
31067: LD_EXP 50
31071: DOUBLE
31072: EQUAL
31073: IFTRUE 31077
31075: GO 31092
31077: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31078: LD_EXP 50
31082: PPUSH
31083: LD_STRING DA1-Yam-1a
31085: PPUSH
31086: CALL_OW 91
31090: GO 31224
31092: LD_EXP 49
31096: DOUBLE
31097: EQUAL
31098: IFTRUE 31102
31100: GO 31117
31102: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31103: LD_EXP 49
31107: PPUSH
31108: LD_STRING DA1-Frank-1a
31110: PPUSH
31111: CALL_OW 91
31115: GO 31224
31117: POP
// begin join := rand ( 0 , 1 ) ;
31118: LD_ADDR_VAR 0 3
31122: PUSH
31123: LD_INT 0
31125: PPUSH
31126: LD_INT 1
31128: PPUSH
31129: CALL_OW 12
31133: ST_TO_ADDR
// if join then
31134: LD_VAR 0 3
31138: IFFALSE 31183
// begin if GetSex ( unit ) = sex_male then
31140: LD_VAR 0 1
31144: PPUSH
31145: CALL_OW 258
31149: PUSH
31150: LD_INT 1
31152: EQUAL
31153: IFFALSE 31169
// ForceSay ( unit , DA1-Sol1-1b ) else
31155: LD_VAR 0 1
31159: PPUSH
31160: LD_STRING DA1-Sol1-1b
31162: PPUSH
31163: CALL_OW 91
31167: GO 31181
// ForceSay ( unit , DA1-FSol1-1b ) ;
31169: LD_VAR 0 1
31173: PPUSH
31174: LD_STRING DA1-FSol1-1b
31176: PPUSH
31177: CALL_OW 91
// end else
31181: GO 31224
// begin if GetSex ( unit ) = sex_male then
31183: LD_VAR 0 1
31187: PPUSH
31188: CALL_OW 258
31192: PUSH
31193: LD_INT 1
31195: EQUAL
31196: IFFALSE 31212
// ForceSay ( unit , DA1-Sol1-1a ) else
31198: LD_VAR 0 1
31202: PPUSH
31203: LD_STRING DA1-Sol1-1a
31205: PPUSH
31206: CALL_OW 91
31210: GO 31224
// ForceSay ( unit , DA1-FSol1-1a ) ;
31212: LD_VAR 0 1
31216: PPUSH
31217: LD_STRING DA1-FSol1-1a
31219: PPUSH
31220: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31224: LD_VAR 0 1
31228: PUSH
31229: LD_EXP 36
31233: EQUAL
31234: IFFALSE 31245
// begin YouLost ( JMMCaptured ) ;
31236: LD_STRING JMMCaptured
31238: PPUSH
31239: CALL_OW 104
// exit ;
31243: GO 31543
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31245: LD_VAR 0 1
31249: PUSH
31250: LD_EXP 40
31254: PUSH
31255: LD_EXP 43
31259: PUSH
31260: LD_EXP 41
31264: PUSH
31265: LD_EXP 38
31269: PUSH
31270: LD_EXP 52
31274: PUSH
31275: LD_EXP 44
31279: PUSH
31280: LD_EXP 50
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: LIST
31289: LIST
31290: LIST
31291: LIST
31292: LIST
31293: IN
31294: PUSH
31295: LD_VAR 0 3
31299: OR
31300: IFFALSE 31399
// begin Say ( Roth , DA-Roth-3 ) ;
31302: LD_EXP 71
31306: PPUSH
31307: LD_STRING DA-Roth-3
31309: PPUSH
31310: CALL_OW 88
// SetSide ( unit , 7 ) ;
31314: LD_VAR 0 1
31318: PPUSH
31319: LD_INT 7
31321: PPUSH
31322: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31326: LD_ADDR_EXP 99
31330: PUSH
31331: LD_EXP 99
31335: PPUSH
31336: LD_INT 1
31338: PPUSH
31339: LD_EXP 99
31343: PUSH
31344: LD_INT 1
31346: ARRAY
31347: PUSH
31348: LD_VAR 0 1
31352: ADD
31353: PPUSH
31354: CALL_OW 1
31358: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31359: LD_INT 260
31361: PPUSH
31362: LD_INT 235
31364: PPUSH
31365: LD_INT 1
31367: PPUSH
31368: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31372: LD_VAR 0 1
31376: PPUSH
31377: LD_INT 1000
31379: PPUSH
31380: CALL_OW 234
// DialogueOff ;
31384: CALL_OW 7
// ComFree ( unit ) ;
31388: LD_VAR 0 1
31392: PPUSH
31393: CALL_OW 139
// end else
31397: GO 31480
// begin Say ( Roth , DA-Roth-3a ) ;
31399: LD_EXP 71
31403: PPUSH
31404: LD_STRING DA-Roth-3a
31406: PPUSH
31407: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31411: LD_ADDR_EXP 35
31415: PUSH
31416: LD_EXP 35
31420: PUSH
31421: LD_VAR 0 1
31425: ADD
31426: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31427: LD_INT 260
31429: PPUSH
31430: LD_INT 235
31432: PPUSH
31433: LD_INT 1
31435: PPUSH
31436: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31440: LD_VAR 0 1
31444: PPUSH
31445: LD_INT 1000
31447: PPUSH
31448: CALL_OW 234
// DialogueOff ;
31452: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31456: LD_VAR 0 1
31460: PPUSH
31461: LD_INT 272
31463: PPUSH
31464: LD_INT 254
31466: PPUSH
31467: CALL_OW 111
// AddComHold ( unit ) ;
31471: LD_VAR 0 1
31475: PPUSH
31476: CALL_OW 200
// end ; if capturedUnit = 1 then
31480: LD_EXP 34
31484: PUSH
31485: LD_INT 1
31487: EQUAL
31488: IFFALSE 31543
// begin DialogueOn ;
31490: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31494: LD_EXP 36
31498: PPUSH
31499: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31503: LD_EXP 36
31507: PPUSH
31508: LD_STRING DAa-JMM-1
31510: PPUSH
31511: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31515: LD_EXP 36
31519: PPUSH
31520: LD_STRING DAa-JMM-1a
31522: PPUSH
31523: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31527: LD_EXP 36
31531: PPUSH
31532: LD_STRING DAa-JMM-1b
31534: PPUSH
31535: CALL_OW 88
// DialogueOff ;
31539: CALL_OW 7
// end ; end ;
31543: LD_VAR 0 2
31547: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do
31548: LD_EXP 15
31552: PUSH
31553: LD_INT 13
31555: GREATEREQUAL
31556: PUSH
31557: LD_INT 22
31559: PUSH
31560: LD_INT 2
31562: PUSH
31563: EMPTY
31564: LIST
31565: LIST
31566: PUSH
31567: LD_INT 21
31569: PUSH
31570: LD_INT 1
31572: PUSH
31573: EMPTY
31574: LIST
31575: LIST
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PPUSH
31581: CALL_OW 69
31585: PUSH
31586: LD_INT 0
31588: EQUAL
31589: AND
31590: PUSH
31591: LD_INT 22
31593: PUSH
31594: LD_INT 2
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 21
31603: PUSH
31604: LD_INT 2
31606: PUSH
31607: EMPTY
31608: LIST
31609: LIST
31610: PUSH
31611: LD_INT 50
31613: PUSH
31614: EMPTY
31615: LIST
31616: PUSH
31617: EMPTY
31618: LIST
31619: LIST
31620: LIST
31621: PPUSH
31622: CALL_OW 69
31626: PUSH
31627: LD_INT 0
31629: EQUAL
31630: AND
31631: PUSH
31632: LD_EXP 21
31636: AND
31637: PUSH
31638: LD_EXP 22
31642: AND
31643: PUSH
31644: LD_EXP 23
31648: AND
31649: IFFALSE 32130
31651: GO 31653
31653: DISABLE
// begin DialogueOn ;
31654: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31658: LD_EXP 36
31662: PPUSH
31663: CALL_OW 87
// Say ( JMM , D20-JMM-1 ) ;
31667: LD_EXP 36
31671: PPUSH
31672: LD_STRING D20-JMM-1
31674: PPUSH
31675: CALL_OW 88
// if IsOK ( Joan ) then
31679: LD_EXP 37
31683: PPUSH
31684: CALL_OW 302
31688: IFFALSE 31702
// Say ( Joan , D20-Joan-1 ) ;
31690: LD_EXP 37
31694: PPUSH
31695: LD_STRING D20-Joan-1
31697: PPUSH
31698: CALL_OW 88
// if IsOk ( Lisa ) then
31702: LD_EXP 39
31706: PPUSH
31707: CALL_OW 302
31711: IFFALSE 31725
// Say ( Lisa , D20-Lisa-1 ) ;
31713: LD_EXP 39
31717: PPUSH
31718: LD_STRING D20-Lisa-1
31720: PPUSH
31721: CALL_OW 88
// if IsOk ( Donaldson ) then
31725: LD_EXP 40
31729: PPUSH
31730: CALL_OW 302
31734: IFFALSE 31748
// Say ( Donaldson , D20-Don-1 ) ;
31736: LD_EXP 40
31740: PPUSH
31741: LD_STRING D20-Don-1
31743: PPUSH
31744: CALL_OW 88
// if IsOK ( Cornel ) then
31748: LD_EXP 47
31752: PPUSH
31753: CALL_OW 302
31757: IFFALSE 31771
// Say ( Cornel , D20-Corn-1 ) ;
31759: LD_EXP 47
31763: PPUSH
31764: LD_STRING D20-Corn-1
31766: PPUSH
31767: CALL_OW 88
// if IsOk ( Denis ) then
31771: LD_EXP 43
31775: PPUSH
31776: CALL_OW 302
31780: IFFALSE 31794
// Say ( Denis , D20-Den-1 ) ;
31782: LD_EXP 43
31786: PPUSH
31787: LD_STRING D20-Den-1
31789: PPUSH
31790: CALL_OW 88
// if IsOk ( Bobby ) then
31794: LD_EXP 41
31798: PPUSH
31799: CALL_OW 302
31803: IFFALSE 31817
// Say ( Bobby , D20-Bobby-1 ) ;
31805: LD_EXP 41
31809: PPUSH
31810: LD_STRING D20-Bobby-1
31812: PPUSH
31813: CALL_OW 88
// if IsOk ( Gladstone ) then
31817: LD_EXP 45
31821: PPUSH
31822: CALL_OW 302
31826: IFFALSE 31840
// Say ( Gladstone , D20-Glad-1 ) ;
31828: LD_EXP 45
31832: PPUSH
31833: LD_STRING D20-Glad-1
31835: PPUSH
31836: CALL_OW 88
// if IsOk ( Cyrus ) then
31840: LD_EXP 42
31844: PPUSH
31845: CALL_OW 302
31849: IFFALSE 31863
// Say ( Cyrus , D20-Cyrus-1 ) ;
31851: LD_EXP 42
31855: PPUSH
31856: LD_STRING D20-Cyrus-1
31858: PPUSH
31859: CALL_OW 88
// if IsOk ( Stevens ) then
31863: LD_EXP 38
31867: PPUSH
31868: CALL_OW 302
31872: IFFALSE 31886
// Say ( Stevens , D20-Huck-1 ) ;
31874: LD_EXP 38
31878: PPUSH
31879: LD_STRING D20-Huck-1
31881: PPUSH
31882: CALL_OW 88
// if IsOk ( Brown ) then
31886: LD_EXP 44
31890: PPUSH
31891: CALL_OW 302
31895: IFFALSE 31909
// Say ( Brown , D20-Brown-1 ) ;
31897: LD_EXP 44
31901: PPUSH
31902: LD_STRING D20-Brown-1
31904: PPUSH
31905: CALL_OW 88
// if IsOk ( Gary ) then
31909: LD_EXP 48
31913: PPUSH
31914: CALL_OW 302
31918: IFFALSE 31932
// Say ( Gary , D20-Gary-1 ) ;
31920: LD_EXP 48
31924: PPUSH
31925: LD_STRING D20-Gary-1
31927: PPUSH
31928: CALL_OW 88
// if IsOk ( Connie ) then
31932: LD_EXP 51
31936: PPUSH
31937: CALL_OW 302
31941: IFFALSE 31955
// Say ( Connie , D20-Con-1 ) ;
31943: LD_EXP 51
31947: PPUSH
31948: LD_STRING D20-Con-1
31950: PPUSH
31951: CALL_OW 88
// if IsOk ( Kurt ) then
31955: LD_EXP 57
31959: PPUSH
31960: CALL_OW 302
31964: IFFALSE 31978
// Say ( Kurt , D20-Kurt-1 ) ;
31966: LD_EXP 57
31970: PPUSH
31971: LD_STRING D20-Kurt-1
31973: PPUSH
31974: CALL_OW 88
// if IsOk ( Kikuchi ) then
31978: LD_EXP 50
31982: PPUSH
31983: CALL_OW 302
31987: IFFALSE 32001
// Say ( Kikuchi , D20-Yam-1 ) ;
31989: LD_EXP 50
31993: PPUSH
31994: LD_STRING D20-Yam-1
31996: PPUSH
31997: CALL_OW 88
// if IsOk ( Frank ) then
32001: LD_EXP 49
32005: PPUSH
32006: CALL_OW 302
32010: IFFALSE 32024
// Say ( Frank , D20-Frank-1 ) ;
32012: LD_EXP 49
32016: PPUSH
32017: LD_STRING D20-Frank-1
32019: PPUSH
32020: CALL_OW 88
// DialogueOff ;
32024: CALL_OW 7
// if RothCaptured then
32028: LD_EXP 33
32032: IFFALSE 32046
// AddMedal ( Roth , 1 ) else
32034: LD_STRING Roth
32036: PPUSH
32037: LD_INT 1
32039: PPUSH
32040: CALL_OW 101
32044: GO 32057
// AddMedal ( Roth , - 1 ) ;
32046: LD_STRING Roth
32048: PPUSH
32049: LD_INT 1
32051: NEG
32052: PPUSH
32053: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32057: LD_EXP 27
32061: IFFALSE 32075
// AddMedal ( Project , 1 ) else
32063: LD_STRING Project
32065: PPUSH
32066: LD_INT 1
32068: PPUSH
32069: CALL_OW 101
32073: GO 32086
// AddMedal ( Project , - 1 ) ;
32075: LD_STRING Project
32077: PPUSH
32078: LD_INT 1
32080: NEG
32081: PPUSH
32082: CALL_OW 101
// if lostCounter = 0 then
32086: LD_EXP 32
32090: PUSH
32091: LD_INT 0
32093: EQUAL
32094: IFFALSE 32108
// AddMedal ( NoLosses , 1 ) else
32096: LD_STRING NoLosses
32098: PPUSH
32099: LD_INT 1
32101: PPUSH
32102: CALL_OW 101
32106: GO 32119
// AddMedal ( NoLosses , - 1 ) ;
32108: LD_STRING NoLosses
32110: PPUSH
32111: LD_INT 1
32113: NEG
32114: PPUSH
32115: CALL_OW 101
// GiveMedals ( MAIN ) ;
32119: LD_STRING MAIN
32121: PPUSH
32122: CALL_OW 102
// YouWin ;
32126: CALL_OW 103
// end ; end_of_file
32130: END
// export function CustomEvent ( event ) ; begin
32131: LD_INT 0
32133: PPUSH
// end ;
32134: LD_VAR 0 2
32138: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32139: LD_VAR 0 1
32143: PUSH
32144: LD_INT 1
32146: EQUAL
32147: PUSH
32148: LD_VAR 0 2
32152: PUSH
32153: LD_INT 4
32155: EQUAL
32156: AND
32157: PUSH
32158: LD_EXP 55
32162: PPUSH
32163: CALL_OW 300
32167: AND
32168: IFFALSE 32184
// begin wait ( 0 0$2 ) ;
32170: LD_INT 70
32172: PPUSH
32173: CALL_OW 67
// YouLost ( Dismissed ) ;
32177: LD_STRING Dismissed
32179: PPUSH
32180: CALL_OW 104
// end ; end ;
32184: PPOPN 2
32186: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32187: LD_VAR 0 2
32191: PPUSH
32192: LD_VAR 0 3
32196: PPUSH
32197: LD_INT 18
32199: PPUSH
32200: CALL_OW 309
32204: IFFALSE 32213
// YouLost ( Motherlode3 ) ;
32206: LD_STRING Motherlode3
32208: PPUSH
32209: CALL_OW 104
// end ;
32213: PPOPN 3
32215: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32216: LD_EXP 27
32220: NOT
32221: IFFALSE 32231
// behemothDone := true ;
32223: LD_ADDR_EXP 28
32227: PUSH
32228: LD_INT 1
32230: ST_TO_ADDR
// end ;
32231: PPOPN 1
32233: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32234: LD_VAR 0 1
32238: PPUSH
32239: CALL_OW 255
32243: PUSH
32244: LD_INT 1
32246: EQUAL
32247: PUSH
32248: LD_EXP 30
32252: AND
32253: PUSH
32254: LD_INT 22
32256: PUSH
32257: LD_INT 3
32259: PUSH
32260: EMPTY
32261: LIST
32262: LIST
32263: PUSH
32264: LD_INT 34
32266: PUSH
32267: LD_INT 48
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PPUSH
32278: CALL_OW 69
32282: AND
32283: PUSH
32284: LD_INT 22
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PUSH
32294: LD_INT 34
32296: PUSH
32297: LD_INT 8
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PPUSH
32308: CALL_OW 69
32312: NOT
32313: AND
32314: IFFALSE 32366
// begin wait ( 0 0$5 ) ;
32316: LD_INT 175
32318: PPUSH
32319: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32323: LD_INT 22
32325: PUSH
32326: LD_INT 3
32328: PUSH
32329: EMPTY
32330: LIST
32331: LIST
32332: PUSH
32333: LD_INT 34
32335: PUSH
32336: LD_INT 48
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: EMPTY
32344: LIST
32345: LIST
32346: PPUSH
32347: CALL_OW 69
32351: PUSH
32352: LD_INT 1
32354: ARRAY
32355: PPUSH
32356: LD_INT 60
32358: PPUSH
32359: LD_INT 95
32361: PPUSH
32362: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32366: LD_VAR 0 2
32370: PPUSH
32371: LD_VAR 0 3
32375: PPUSH
32376: LD_INT 18
32378: PPUSH
32379: CALL_OW 309
32383: IFFALSE 32443
// begin if GetSide ( unit ) = 1 then
32385: LD_VAR 0 1
32389: PPUSH
32390: CALL_OW 255
32394: PUSH
32395: LD_INT 1
32397: EQUAL
32398: IFFALSE 32414
// begin wait ( 0 0$6 ) ;
32400: LD_INT 210
32402: PPUSH
32403: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32407: LD_STRING Motherlode2
32409: PPUSH
32410: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32414: LD_VAR 0 1
32418: PPUSH
32419: CALL_OW 255
32423: PUSH
32424: LD_INT 8
32426: EQUAL
32427: IFFALSE 32443
// begin wait ( 0 0$6 ) ;
32429: LD_INT 210
32431: PPUSH
32432: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32436: LD_STRING Motherlode1
32438: PPUSH
32439: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32443: LD_VAR 0 1
32447: PPUSH
32448: CALL_OW 255
32452: PUSH
32453: LD_INT 3
32455: EQUAL
32456: IFFALSE 32477
// begin wait ( 0 0$5 ) ;
32458: LD_INT 175
32460: PPUSH
32461: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32465: LD_EXP 61
32469: PPUSH
32470: LD_STRING D18-Pla-1
32472: PPUSH
32473: CALL_OW 94
// end ; end ;
32477: PPOPN 3
32479: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32480: LD_VAR 0 1
32484: PUSH
32485: LD_EXP 70
32489: IN
32490: IFFALSE 32510
// begin behemothBuilders := behemothBuilders diff un ;
32492: LD_ADDR_EXP 70
32496: PUSH
32497: LD_EXP 70
32501: PUSH
32502: LD_VAR 0 1
32506: DIFF
32507: ST_TO_ADDR
// exit ;
32508: GO 32608
// end ; if un = JMM then
32510: LD_VAR 0 1
32514: PUSH
32515: LD_EXP 36
32519: EQUAL
32520: IFFALSE 32531
// begin YouLost ( JMM ) ;
32522: LD_STRING JMM
32524: PPUSH
32525: CALL_OW 104
// exit ;
32529: GO 32608
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32531: LD_VAR 0 1
32535: PUSH
32536: LD_INT 22
32538: PUSH
32539: LD_INT 1
32541: PUSH
32542: EMPTY
32543: LIST
32544: LIST
32545: PUSH
32546: LD_INT 3
32548: PUSH
32549: LD_INT 25
32551: PUSH
32552: LD_INT 16
32554: PUSH
32555: EMPTY
32556: LIST
32557: LIST
32558: PUSH
32559: LD_INT 25
32561: PUSH
32562: LD_INT 12
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: LIST
32573: PUSH
32574: EMPTY
32575: LIST
32576: LIST
32577: PPUSH
32578: CALL_OW 69
32582: IN
32583: IFFALSE 32599
// lostCounter := lostCounter + 1 ;
32585: LD_ADDR_EXP 32
32589: PUSH
32590: LD_EXP 32
32594: PUSH
32595: LD_INT 1
32597: PLUS
32598: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32599: LD_VAR 0 1
32603: PPUSH
32604: CALL 60251 0 1
// end ;
32608: PPOPN 1
32610: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32611: LD_VAR 0 1
32615: PPUSH
32616: LD_VAR 0 2
32620: PPUSH
32621: CALL 62306 0 2
// end ;
32625: PPOPN 2
32627: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32628: LD_VAR 0 1
32632: PPUSH
32633: CALL 61374 0 1
// end ;
32637: PPOPN 1
32639: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32640: LD_VAR 0 1
32644: PUSH
32645: LD_INT 22
32647: PUSH
32648: LD_INT 8
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 30
32657: PUSH
32658: LD_INT 2
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 23
32667: PUSH
32668: LD_INT 3
32670: PUSH
32671: EMPTY
32672: LIST
32673: LIST
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: LIST
32679: PPUSH
32680: CALL_OW 69
32684: IN
32685: IFFALSE 32712
// begin ComUpgrade ( building ) ;
32687: LD_VAR 0 1
32691: PPUSH
32692: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32696: LD_EXP 58
32700: PPUSH
32701: LD_VAR 0 1
32705: PPUSH
32706: CALL 72500 0 2
// exit ;
32710: GO 32721
// end ; MCE_BuildingComplete ( building ) ;
32712: LD_VAR 0 1
32716: PPUSH
32717: CALL 61615 0 1
// end ;
32721: PPOPN 1
32723: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32724: LD_VAR 0 1
32728: PPUSH
32729: LD_VAR 0 2
32733: PPUSH
32734: CALL 59947 0 2
// end ;
32738: PPOPN 2
32740: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32741: LD_VAR 0 1
32745: PPUSH
32746: LD_VAR 0 2
32750: PPUSH
32751: LD_VAR 0 3
32755: PPUSH
32756: LD_VAR 0 4
32760: PPUSH
32761: LD_VAR 0 5
32765: PPUSH
32766: CALL 59567 0 5
// end ;
32770: PPOPN 5
32772: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32773: LD_VAR 0 1
32777: PPUSH
32778: LD_VAR 0 2
32782: PPUSH
32783: CALL 59163 0 2
// end ;
32787: PPOPN 2
32789: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
32790: LD_VAR 0 1
32794: PPUSH
32795: LD_VAR 0 2
32799: PPUSH
32800: LD_VAR 0 3
32804: PPUSH
32805: LD_VAR 0 4
32809: PPUSH
32810: CALL 59001 0 4
// end ;
32814: PPOPN 4
32816: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
32817: LD_VAR 0 1
32821: PPUSH
32822: LD_VAR 0 2
32826: PPUSH
32827: LD_VAR 0 3
32831: PPUSH
32832: CALL 58776 0 3
// end ;
32836: PPOPN 3
32838: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
32839: LD_VAR 0 1
32843: PPUSH
32844: LD_VAR 0 2
32848: PPUSH
32849: CALL 58661 0 2
// end ;
32853: PPOPN 2
32855: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
32856: LD_VAR 0 1
32860: PPUSH
32861: LD_VAR 0 2
32865: PPUSH
32866: CALL 62567 0 2
// end ;
32870: PPOPN 2
32872: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
32873: LD_VAR 0 1
32877: PPUSH
32878: CALL_OW 255
32882: PUSH
32883: LD_INT 4
32885: EQUAL
32886: PUSH
32887: LD_VAR 0 1
32891: PUSH
32892: LD_EXP 18
32896: PUSH
32897: LD_INT 1
32899: ARRAY
32900: IN
32901: AND
32902: PUSH
32903: LD_EXP 19
32907: AND
32908: IFFALSE 32927
// begin ComMoveXY ( driver , 61 , 93 ) ;
32910: LD_VAR 0 1
32914: PPUSH
32915: LD_INT 61
32917: PPUSH
32918: LD_INT 93
32920: PPUSH
32921: CALL_OW 111
// exit ;
32925: GO 32951
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
32927: LD_VAR 0 1
32931: PPUSH
32932: LD_VAR 0 2
32936: PPUSH
32937: LD_VAR 0 3
32941: PPUSH
32942: LD_VAR 0 4
32946: PPUSH
32947: CALL 62783 0 4
// end ;
32951: PPOPN 4
32953: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
32954: LD_VAR 0 1
32958: PPUSH
32959: LD_VAR 0 2
32963: PPUSH
32964: CALL 58470 0 2
// end ;
32968: PPOPN 2
32970: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
32971: LD_VAR 0 1
32975: PPUSH
32976: CALL 105587 0 1
// end ; end_of_file
32980: PPOPN 1
32982: END
// every 0 0$30 trigger missionStage = 2 do var time ;
32983: LD_EXP 15
32987: PUSH
32988: LD_INT 2
32990: EQUAL
32991: IFFALSE 33470
32993: GO 32995
32995: DISABLE
32996: LD_INT 0
32998: PPUSH
// begin time := 0 0$40 ;
32999: LD_ADDR_VAR 0 1
33003: PUSH
33004: LD_INT 1400
33006: ST_TO_ADDR
// repeat wait ( time ) ;
33007: LD_VAR 0 1
33011: PPUSH
33012: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33016: LD_INT 1
33018: PPUSH
33019: LD_INT 5
33021: PPUSH
33022: CALL_OW 12
33026: PPUSH
33027: LD_INT 106
33029: PPUSH
33030: LD_INT 150
33032: PPUSH
33033: LD_INT 19
33035: PPUSH
33036: LD_INT 1
33038: PPUSH
33039: CALL_OW 56
// time := time + 0 0$9 ;
33043: LD_ADDR_VAR 0 1
33047: PUSH
33048: LD_VAR 0 1
33052: PUSH
33053: LD_INT 315
33055: PLUS
33056: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33057: LD_INT 455
33059: PPUSH
33060: LD_INT 840
33062: PPUSH
33063: CALL_OW 12
33067: PPUSH
33068: CALL_OW 67
// if Prob ( 50 ) then
33072: LD_INT 50
33074: PPUSH
33075: CALL_OW 13
33079: IFFALSE 33108
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33081: LD_INT 1
33083: PPUSH
33084: LD_INT 5
33086: PPUSH
33087: CALL_OW 12
33091: PPUSH
33092: LD_INT 62
33094: PPUSH
33095: LD_INT 108
33097: PPUSH
33098: LD_INT 10
33100: PPUSH
33101: LD_INT 1
33103: PPUSH
33104: CALL_OW 56
// until missionStage > 4 ;
33108: LD_EXP 15
33112: PUSH
33113: LD_INT 4
33115: GREATER
33116: IFFALSE 33007
// repeat wait ( 0 0$1 ) ;
33118: LD_INT 35
33120: PPUSH
33121: CALL_OW 67
// until missionStage = 6 ;
33125: LD_EXP 15
33129: PUSH
33130: LD_INT 6
33132: EQUAL
33133: IFFALSE 33118
// time := 0 0$50 ;
33135: LD_ADDR_VAR 0 1
33139: PUSH
33140: LD_INT 1750
33142: ST_TO_ADDR
// repeat wait ( time ) ;
33143: LD_VAR 0 1
33147: PPUSH
33148: CALL_OW 67
// if Prob ( 50 ) then
33152: LD_INT 50
33154: PPUSH
33155: CALL_OW 13
33159: IFFALSE 33188
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33161: LD_INT 1
33163: PPUSH
33164: LD_INT 5
33166: PPUSH
33167: CALL_OW 12
33171: PPUSH
33172: LD_INT 106
33174: PPUSH
33175: LD_INT 89
33177: PPUSH
33178: LD_INT 45
33180: PPUSH
33181: LD_INT 1
33183: PPUSH
33184: CALL_OW 56
// time := time + 0 0$3 ;
33188: LD_ADDR_VAR 0 1
33192: PUSH
33193: LD_VAR 0 1
33197: PUSH
33198: LD_INT 105
33200: PLUS
33201: ST_TO_ADDR
// if Prob ( 30 ) then
33202: LD_INT 30
33204: PPUSH
33205: CALL_OW 13
33209: IFFALSE 33255
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33211: LD_INT 525
33213: PPUSH
33214: LD_INT 735
33216: PPUSH
33217: CALL_OW 12
33221: PPUSH
33222: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33226: LD_INT 1
33228: PPUSH
33229: LD_INT 5
33231: PPUSH
33232: CALL_OW 12
33236: PPUSH
33237: LD_INT 21
33239: PPUSH
33240: LD_INT 26
33242: PPUSH
33243: LD_INT 12
33245: PPUSH
33246: LD_INT 1
33248: PPUSH
33249: CALL_OW 56
// end else
33253: GO 33291
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33255: LD_INT 700
33257: PPUSH
33258: LD_INT 1225
33260: PPUSH
33261: CALL_OW 12
33265: PPUSH
33266: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33270: LD_INT 1
33272: PPUSH
33273: LD_INT 5
33275: PPUSH
33276: CALL_OW 12
33280: PPUSH
33281: LD_INT 16
33283: PPUSH
33284: LD_INT 1
33286: PPUSH
33287: CALL_OW 55
// end ; if Prob ( 50 ) then
33291: LD_INT 50
33293: PPUSH
33294: CALL_OW 13
33298: IFFALSE 33344
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33300: LD_INT 700
33302: PPUSH
33303: LD_INT 1050
33305: PPUSH
33306: CALL_OW 12
33310: PPUSH
33311: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33315: LD_INT 1
33317: PPUSH
33318: LD_INT 5
33320: PPUSH
33321: CALL_OW 12
33325: PPUSH
33326: LD_INT 181
33328: PPUSH
33329: LD_INT 218
33331: PPUSH
33332: LD_INT 16
33334: PPUSH
33335: LD_INT 1
33337: PPUSH
33338: CALL_OW 56
// end else
33342: GO 33380
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33344: LD_INT 350
33346: PPUSH
33347: LD_INT 525
33349: PPUSH
33350: CALL_OW 12
33354: PPUSH
33355: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33359: LD_INT 1
33361: PPUSH
33362: LD_INT 5
33364: PPUSH
33365: CALL_OW 12
33369: PPUSH
33370: LD_INT 15
33372: PPUSH
33373: LD_INT 1
33375: PPUSH
33376: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33380: LD_INT 45
33382: PUSH
33383: LD_INT 32
33385: PUSH
33386: LD_INT 25
33388: PUSH
33389: EMPTY
33390: LIST
33391: LIST
33392: LIST
33393: PUSH
33394: LD_OWVAR 67
33398: ARRAY
33399: PPUSH
33400: CALL_OW 13
33404: IFFALSE 33448
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33406: LD_INT 525
33408: PPUSH
33409: LD_INT 875
33411: PPUSH
33412: CALL_OW 12
33416: PPUSH
33417: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33421: LD_INT 1
33423: PPUSH
33424: LD_INT 5
33426: PPUSH
33427: CALL_OW 12
33431: PPUSH
33432: LD_INT 103
33434: PPUSH
33435: LD_INT 140
33437: PPUSH
33438: LD_INT 20
33440: PPUSH
33441: LD_INT 1
33443: PPUSH
33444: CALL_OW 56
// end ; if time > 2 2$20 then
33448: LD_VAR 0 1
33452: PUSH
33453: LD_INT 4900
33455: GREATER
33456: IFFALSE 33466
// time := 0 0$50 ;
33458: LD_ADDR_VAR 0 1
33462: PUSH
33463: LD_INT 1750
33465: ST_TO_ADDR
// until false ;
33466: LD_INT 0
33468: IFFALSE 33143
// end ; end_of_file
33470: PPOPN 1
33472: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33473: LD_EXP 13
33477: PUSH
33478: LD_EXP 15
33482: PUSH
33483: LD_INT 6
33485: GREATEREQUAL
33486: AND
33487: IFFALSE 33524
33489: GO 33491
33491: DISABLE
// begin enable ;
33492: ENABLE
// missionTime := missionTime + 0 0$1 ;
33493: LD_ADDR_EXP 14
33497: PUSH
33498: LD_EXP 14
33502: PUSH
33503: LD_INT 35
33505: PLUS
33506: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33507: LD_ADDR_OWVAR 47
33511: PUSH
33512: LD_STRING #Am15-1
33514: PUSH
33515: LD_EXP 14
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: ST_TO_ADDR
// end ; end_of_file
33524: END
// export function InitNature ; begin
33525: LD_INT 0
33527: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33528: LD_INT 3
33530: PPUSH
33531: LD_INT 3
33533: PPUSH
33534: LD_INT 2
33536: PPUSH
33537: LD_INT 1
33539: PPUSH
33540: LD_INT 1
33542: PPUSH
33543: LD_INT 0
33545: PPUSH
33546: LD_INT 0
33548: PPUSH
33549: LD_INT 20
33551: PPUSH
33552: LD_INT 0
33554: PPUSH
33555: CALL 97341 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33559: LD_INT 2
33561: PPUSH
33562: LD_INT 1
33564: PPUSH
33565: LD_INT 1
33567: PPUSH
33568: LD_INT 1
33570: PPUSH
33571: LD_INT 1
33573: PPUSH
33574: LD_INT 0
33576: PPUSH
33577: LD_INT 0
33579: PPUSH
33580: LD_INT 21
33582: PPUSH
33583: LD_INT 0
33585: PPUSH
33586: CALL 97341 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33590: LD_INT 4
33592: PPUSH
33593: LD_INT 1
33595: PPUSH
33596: LD_INT 2
33598: PPUSH
33599: LD_INT 4
33601: PPUSH
33602: LD_INT 2
33604: PPUSH
33605: LD_INT 1
33607: PPUSH
33608: LD_INT 0
33610: PPUSH
33611: LD_INT 22
33613: PPUSH
33614: LD_INT 0
33616: PPUSH
33617: CALL 97341 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33621: LD_INT 0
33623: PPUSH
33624: LD_INT 0
33626: PPUSH
33627: LD_INT 0
33629: PPUSH
33630: LD_INT 0
33632: PPUSH
33633: LD_INT 0
33635: PPUSH
33636: LD_INT 0
33638: PPUSH
33639: LD_INT 9
33641: PPUSH
33642: LD_INT 0
33644: PPUSH
33645: LD_INT 23
33647: PPUSH
33648: CALL 97341 0 9
// end ; end_of_file
33652: LD_VAR 0 1
33656: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33657: GO 33659
33659: DISABLE
// begin ru_radar := 98 ;
33660: LD_ADDR_EXP 92
33664: PUSH
33665: LD_INT 98
33667: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33668: LD_ADDR_EXP 93
33672: PUSH
33673: LD_INT 89
33675: ST_TO_ADDR
// us_hack := 99 ;
33676: LD_ADDR_EXP 94
33680: PUSH
33681: LD_INT 99
33683: ST_TO_ADDR
// us_artillery := 97 ;
33684: LD_ADDR_EXP 95
33688: PUSH
33689: LD_INT 97
33691: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33692: LD_ADDR_EXP 96
33696: PUSH
33697: LD_INT 91
33699: ST_TO_ADDR
// end ; end_of_file
33700: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33701: LD_INT 0
33703: PPUSH
33704: PPUSH
// skirmish := false ;
33705: LD_ADDR_EXP 97
33709: PUSH
33710: LD_INT 0
33712: ST_TO_ADDR
// debug_mc := false ;
33713: LD_ADDR_EXP 98
33717: PUSH
33718: LD_INT 0
33720: ST_TO_ADDR
// mc_bases := [ ] ;
33721: LD_ADDR_EXP 99
33725: PUSH
33726: EMPTY
33727: ST_TO_ADDR
// mc_sides := [ ] ;
33728: LD_ADDR_EXP 125
33732: PUSH
33733: EMPTY
33734: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33735: LD_ADDR_EXP 100
33739: PUSH
33740: EMPTY
33741: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33742: LD_ADDR_EXP 101
33746: PUSH
33747: EMPTY
33748: ST_TO_ADDR
// mc_need_heal := [ ] ;
33749: LD_ADDR_EXP 102
33753: PUSH
33754: EMPTY
33755: ST_TO_ADDR
// mc_healers := [ ] ;
33756: LD_ADDR_EXP 103
33760: PUSH
33761: EMPTY
33762: ST_TO_ADDR
// mc_build_list := [ ] ;
33763: LD_ADDR_EXP 104
33767: PUSH
33768: EMPTY
33769: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33770: LD_ADDR_EXP 131
33774: PUSH
33775: EMPTY
33776: ST_TO_ADDR
// mc_builders := [ ] ;
33777: LD_ADDR_EXP 105
33781: PUSH
33782: EMPTY
33783: ST_TO_ADDR
// mc_construct_list := [ ] ;
33784: LD_ADDR_EXP 106
33788: PUSH
33789: EMPTY
33790: ST_TO_ADDR
// mc_turret_list := [ ] ;
33791: LD_ADDR_EXP 107
33795: PUSH
33796: EMPTY
33797: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
33798: LD_ADDR_EXP 108
33802: PUSH
33803: EMPTY
33804: ST_TO_ADDR
// mc_miners := [ ] ;
33805: LD_ADDR_EXP 113
33809: PUSH
33810: EMPTY
33811: ST_TO_ADDR
// mc_mines := [ ] ;
33812: LD_ADDR_EXP 112
33816: PUSH
33817: EMPTY
33818: ST_TO_ADDR
// mc_minefields := [ ] ;
33819: LD_ADDR_EXP 114
33823: PUSH
33824: EMPTY
33825: ST_TO_ADDR
// mc_crates := [ ] ;
33826: LD_ADDR_EXP 115
33830: PUSH
33831: EMPTY
33832: ST_TO_ADDR
// mc_crates_collector := [ ] ;
33833: LD_ADDR_EXP 116
33837: PUSH
33838: EMPTY
33839: ST_TO_ADDR
// mc_crates_area := [ ] ;
33840: LD_ADDR_EXP 117
33844: PUSH
33845: EMPTY
33846: ST_TO_ADDR
// mc_vehicles := [ ] ;
33847: LD_ADDR_EXP 118
33851: PUSH
33852: EMPTY
33853: ST_TO_ADDR
// mc_attack := [ ] ;
33854: LD_ADDR_EXP 119
33858: PUSH
33859: EMPTY
33860: ST_TO_ADDR
// mc_produce := [ ] ;
33861: LD_ADDR_EXP 120
33865: PUSH
33866: EMPTY
33867: ST_TO_ADDR
// mc_defender := [ ] ;
33868: LD_ADDR_EXP 121
33872: PUSH
33873: EMPTY
33874: ST_TO_ADDR
// mc_parking := [ ] ;
33875: LD_ADDR_EXP 123
33879: PUSH
33880: EMPTY
33881: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
33882: LD_ADDR_EXP 109
33886: PUSH
33887: EMPTY
33888: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
33889: LD_ADDR_EXP 111
33893: PUSH
33894: EMPTY
33895: ST_TO_ADDR
// mc_scan := [ ] ;
33896: LD_ADDR_EXP 122
33900: PUSH
33901: EMPTY
33902: ST_TO_ADDR
// mc_scan_area := [ ] ;
33903: LD_ADDR_EXP 124
33907: PUSH
33908: EMPTY
33909: ST_TO_ADDR
// mc_tech := [ ] ;
33910: LD_ADDR_EXP 126
33914: PUSH
33915: EMPTY
33916: ST_TO_ADDR
// mc_class := [ ] ;
33917: LD_ADDR_EXP 140
33921: PUSH
33922: EMPTY
33923: ST_TO_ADDR
// mc_class_case_use := [ ] ;
33924: LD_ADDR_EXP 141
33928: PUSH
33929: EMPTY
33930: ST_TO_ADDR
// end ;
33931: LD_VAR 0 1
33935: RET
// export function MC_Kill ( base ) ; begin
33936: LD_INT 0
33938: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
33939: LD_ADDR_EXP 99
33943: PUSH
33944: LD_EXP 99
33948: PPUSH
33949: LD_VAR 0 1
33953: PPUSH
33954: EMPTY
33955: PPUSH
33956: CALL_OW 1
33960: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
33961: LD_ADDR_EXP 100
33965: PUSH
33966: LD_EXP 100
33970: PPUSH
33971: LD_VAR 0 1
33975: PPUSH
33976: EMPTY
33977: PPUSH
33978: CALL_OW 1
33982: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
33983: LD_ADDR_EXP 101
33987: PUSH
33988: LD_EXP 101
33992: PPUSH
33993: LD_VAR 0 1
33997: PPUSH
33998: EMPTY
33999: PPUSH
34000: CALL_OW 1
34004: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34005: LD_ADDR_EXP 102
34009: PUSH
34010: LD_EXP 102
34014: PPUSH
34015: LD_VAR 0 1
34019: PPUSH
34020: EMPTY
34021: PPUSH
34022: CALL_OW 1
34026: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34027: LD_ADDR_EXP 103
34031: PUSH
34032: LD_EXP 103
34036: PPUSH
34037: LD_VAR 0 1
34041: PPUSH
34042: EMPTY
34043: PPUSH
34044: CALL_OW 1
34048: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34049: LD_ADDR_EXP 104
34053: PUSH
34054: LD_EXP 104
34058: PPUSH
34059: LD_VAR 0 1
34063: PPUSH
34064: EMPTY
34065: PPUSH
34066: CALL_OW 1
34070: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34071: LD_ADDR_EXP 105
34075: PUSH
34076: LD_EXP 105
34080: PPUSH
34081: LD_VAR 0 1
34085: PPUSH
34086: EMPTY
34087: PPUSH
34088: CALL_OW 1
34092: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34093: LD_ADDR_EXP 106
34097: PUSH
34098: LD_EXP 106
34102: PPUSH
34103: LD_VAR 0 1
34107: PPUSH
34108: EMPTY
34109: PPUSH
34110: CALL_OW 1
34114: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34115: LD_ADDR_EXP 107
34119: PUSH
34120: LD_EXP 107
34124: PPUSH
34125: LD_VAR 0 1
34129: PPUSH
34130: EMPTY
34131: PPUSH
34132: CALL_OW 1
34136: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34137: LD_ADDR_EXP 108
34141: PUSH
34142: LD_EXP 108
34146: PPUSH
34147: LD_VAR 0 1
34151: PPUSH
34152: EMPTY
34153: PPUSH
34154: CALL_OW 1
34158: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34159: LD_ADDR_EXP 109
34163: PUSH
34164: LD_EXP 109
34168: PPUSH
34169: LD_VAR 0 1
34173: PPUSH
34174: EMPTY
34175: PPUSH
34176: CALL_OW 1
34180: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34181: LD_ADDR_EXP 110
34185: PUSH
34186: LD_EXP 110
34190: PPUSH
34191: LD_VAR 0 1
34195: PPUSH
34196: LD_INT 0
34198: PPUSH
34199: CALL_OW 1
34203: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34204: LD_ADDR_EXP 111
34208: PUSH
34209: LD_EXP 111
34213: PPUSH
34214: LD_VAR 0 1
34218: PPUSH
34219: EMPTY
34220: PPUSH
34221: CALL_OW 1
34225: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34226: LD_ADDR_EXP 112
34230: PUSH
34231: LD_EXP 112
34235: PPUSH
34236: LD_VAR 0 1
34240: PPUSH
34241: EMPTY
34242: PPUSH
34243: CALL_OW 1
34247: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34248: LD_ADDR_EXP 113
34252: PUSH
34253: LD_EXP 113
34257: PPUSH
34258: LD_VAR 0 1
34262: PPUSH
34263: EMPTY
34264: PPUSH
34265: CALL_OW 1
34269: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34270: LD_ADDR_EXP 114
34274: PUSH
34275: LD_EXP 114
34279: PPUSH
34280: LD_VAR 0 1
34284: PPUSH
34285: EMPTY
34286: PPUSH
34287: CALL_OW 1
34291: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34292: LD_ADDR_EXP 115
34296: PUSH
34297: LD_EXP 115
34301: PPUSH
34302: LD_VAR 0 1
34306: PPUSH
34307: EMPTY
34308: PPUSH
34309: CALL_OW 1
34313: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34314: LD_ADDR_EXP 116
34318: PUSH
34319: LD_EXP 116
34323: PPUSH
34324: LD_VAR 0 1
34328: PPUSH
34329: EMPTY
34330: PPUSH
34331: CALL_OW 1
34335: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34336: LD_ADDR_EXP 117
34340: PUSH
34341: LD_EXP 117
34345: PPUSH
34346: LD_VAR 0 1
34350: PPUSH
34351: EMPTY
34352: PPUSH
34353: CALL_OW 1
34357: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34358: LD_ADDR_EXP 118
34362: PUSH
34363: LD_EXP 118
34367: PPUSH
34368: LD_VAR 0 1
34372: PPUSH
34373: EMPTY
34374: PPUSH
34375: CALL_OW 1
34379: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34380: LD_ADDR_EXP 119
34384: PUSH
34385: LD_EXP 119
34389: PPUSH
34390: LD_VAR 0 1
34394: PPUSH
34395: EMPTY
34396: PPUSH
34397: CALL_OW 1
34401: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34402: LD_ADDR_EXP 120
34406: PUSH
34407: LD_EXP 120
34411: PPUSH
34412: LD_VAR 0 1
34416: PPUSH
34417: EMPTY
34418: PPUSH
34419: CALL_OW 1
34423: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34424: LD_ADDR_EXP 121
34428: PUSH
34429: LD_EXP 121
34433: PPUSH
34434: LD_VAR 0 1
34438: PPUSH
34439: EMPTY
34440: PPUSH
34441: CALL_OW 1
34445: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34446: LD_ADDR_EXP 122
34450: PUSH
34451: LD_EXP 122
34455: PPUSH
34456: LD_VAR 0 1
34460: PPUSH
34461: EMPTY
34462: PPUSH
34463: CALL_OW 1
34467: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34468: LD_ADDR_EXP 123
34472: PUSH
34473: LD_EXP 123
34477: PPUSH
34478: LD_VAR 0 1
34482: PPUSH
34483: EMPTY
34484: PPUSH
34485: CALL_OW 1
34489: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34490: LD_ADDR_EXP 124
34494: PUSH
34495: LD_EXP 124
34499: PPUSH
34500: LD_VAR 0 1
34504: PPUSH
34505: EMPTY
34506: PPUSH
34507: CALL_OW 1
34511: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34512: LD_ADDR_EXP 126
34516: PUSH
34517: LD_EXP 126
34521: PPUSH
34522: LD_VAR 0 1
34526: PPUSH
34527: EMPTY
34528: PPUSH
34529: CALL_OW 1
34533: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34534: LD_ADDR_EXP 128
34538: PUSH
34539: LD_EXP 128
34543: PPUSH
34544: LD_VAR 0 1
34548: PPUSH
34549: EMPTY
34550: PPUSH
34551: CALL_OW 1
34555: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34556: LD_ADDR_EXP 129
34560: PUSH
34561: LD_EXP 129
34565: PPUSH
34566: LD_VAR 0 1
34570: PPUSH
34571: EMPTY
34572: PPUSH
34573: CALL_OW 1
34577: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34578: LD_ADDR_EXP 130
34582: PUSH
34583: LD_EXP 130
34587: PPUSH
34588: LD_VAR 0 1
34592: PPUSH
34593: EMPTY
34594: PPUSH
34595: CALL_OW 1
34599: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34600: LD_ADDR_EXP 131
34604: PUSH
34605: LD_EXP 131
34609: PPUSH
34610: LD_VAR 0 1
34614: PPUSH
34615: EMPTY
34616: PPUSH
34617: CALL_OW 1
34621: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34622: LD_ADDR_EXP 132
34626: PUSH
34627: LD_EXP 132
34631: PPUSH
34632: LD_VAR 0 1
34636: PPUSH
34637: EMPTY
34638: PPUSH
34639: CALL_OW 1
34643: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34644: LD_ADDR_EXP 133
34648: PUSH
34649: LD_EXP 133
34653: PPUSH
34654: LD_VAR 0 1
34658: PPUSH
34659: EMPTY
34660: PPUSH
34661: CALL_OW 1
34665: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34666: LD_ADDR_EXP 134
34670: PUSH
34671: LD_EXP 134
34675: PPUSH
34676: LD_VAR 0 1
34680: PPUSH
34681: EMPTY
34682: PPUSH
34683: CALL_OW 1
34687: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34688: LD_ADDR_EXP 135
34692: PUSH
34693: LD_EXP 135
34697: PPUSH
34698: LD_VAR 0 1
34702: PPUSH
34703: EMPTY
34704: PPUSH
34705: CALL_OW 1
34709: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34710: LD_ADDR_EXP 136
34714: PUSH
34715: LD_EXP 136
34719: PPUSH
34720: LD_VAR 0 1
34724: PPUSH
34725: EMPTY
34726: PPUSH
34727: CALL_OW 1
34731: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34732: LD_ADDR_EXP 137
34736: PUSH
34737: LD_EXP 137
34741: PPUSH
34742: LD_VAR 0 1
34746: PPUSH
34747: EMPTY
34748: PPUSH
34749: CALL_OW 1
34753: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34754: LD_ADDR_EXP 138
34758: PUSH
34759: LD_EXP 138
34763: PPUSH
34764: LD_VAR 0 1
34768: PPUSH
34769: EMPTY
34770: PPUSH
34771: CALL_OW 1
34775: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34776: LD_ADDR_EXP 139
34780: PUSH
34781: LD_EXP 139
34785: PPUSH
34786: LD_VAR 0 1
34790: PPUSH
34791: EMPTY
34792: PPUSH
34793: CALL_OW 1
34797: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
34798: LD_ADDR_EXP 140
34802: PUSH
34803: LD_EXP 140
34807: PPUSH
34808: LD_VAR 0 1
34812: PPUSH
34813: EMPTY
34814: PPUSH
34815: CALL_OW 1
34819: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
34820: LD_ADDR_EXP 141
34824: PUSH
34825: LD_EXP 141
34829: PPUSH
34830: LD_VAR 0 1
34834: PPUSH
34835: LD_INT 0
34837: PPUSH
34838: CALL_OW 1
34842: ST_TO_ADDR
// end ;
34843: LD_VAR 0 2
34847: RET
// export function MC_Add ( side , units ) ; var base ; begin
34848: LD_INT 0
34850: PPUSH
34851: PPUSH
// base := mc_bases + 1 ;
34852: LD_ADDR_VAR 0 4
34856: PUSH
34857: LD_EXP 99
34861: PUSH
34862: LD_INT 1
34864: PLUS
34865: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
34866: LD_ADDR_EXP 125
34870: PUSH
34871: LD_EXP 125
34875: PPUSH
34876: LD_VAR 0 4
34880: PPUSH
34881: LD_VAR 0 1
34885: PPUSH
34886: CALL_OW 1
34890: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
34891: LD_ADDR_EXP 99
34895: PUSH
34896: LD_EXP 99
34900: PPUSH
34901: LD_VAR 0 4
34905: PPUSH
34906: LD_VAR 0 2
34910: PPUSH
34911: CALL_OW 1
34915: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34916: LD_ADDR_EXP 100
34920: PUSH
34921: LD_EXP 100
34925: PPUSH
34926: LD_VAR 0 4
34930: PPUSH
34931: EMPTY
34932: PPUSH
34933: CALL_OW 1
34937: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34938: LD_ADDR_EXP 101
34942: PUSH
34943: LD_EXP 101
34947: PPUSH
34948: LD_VAR 0 4
34952: PPUSH
34953: EMPTY
34954: PPUSH
34955: CALL_OW 1
34959: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34960: LD_ADDR_EXP 102
34964: PUSH
34965: LD_EXP 102
34969: PPUSH
34970: LD_VAR 0 4
34974: PPUSH
34975: EMPTY
34976: PPUSH
34977: CALL_OW 1
34981: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34982: LD_ADDR_EXP 103
34986: PUSH
34987: LD_EXP 103
34991: PPUSH
34992: LD_VAR 0 4
34996: PPUSH
34997: EMPTY
34998: PPUSH
34999: CALL_OW 1
35003: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35004: LD_ADDR_EXP 104
35008: PUSH
35009: LD_EXP 104
35013: PPUSH
35014: LD_VAR 0 4
35018: PPUSH
35019: EMPTY
35020: PPUSH
35021: CALL_OW 1
35025: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35026: LD_ADDR_EXP 105
35030: PUSH
35031: LD_EXP 105
35035: PPUSH
35036: LD_VAR 0 4
35040: PPUSH
35041: EMPTY
35042: PPUSH
35043: CALL_OW 1
35047: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35048: LD_ADDR_EXP 106
35052: PUSH
35053: LD_EXP 106
35057: PPUSH
35058: LD_VAR 0 4
35062: PPUSH
35063: EMPTY
35064: PPUSH
35065: CALL_OW 1
35069: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35070: LD_ADDR_EXP 107
35074: PUSH
35075: LD_EXP 107
35079: PPUSH
35080: LD_VAR 0 4
35084: PPUSH
35085: EMPTY
35086: PPUSH
35087: CALL_OW 1
35091: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35092: LD_ADDR_EXP 108
35096: PUSH
35097: LD_EXP 108
35101: PPUSH
35102: LD_VAR 0 4
35106: PPUSH
35107: EMPTY
35108: PPUSH
35109: CALL_OW 1
35113: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35114: LD_ADDR_EXP 109
35118: PUSH
35119: LD_EXP 109
35123: PPUSH
35124: LD_VAR 0 4
35128: PPUSH
35129: EMPTY
35130: PPUSH
35131: CALL_OW 1
35135: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35136: LD_ADDR_EXP 110
35140: PUSH
35141: LD_EXP 110
35145: PPUSH
35146: LD_VAR 0 4
35150: PPUSH
35151: LD_INT 0
35153: PPUSH
35154: CALL_OW 1
35158: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35159: LD_ADDR_EXP 111
35163: PUSH
35164: LD_EXP 111
35168: PPUSH
35169: LD_VAR 0 4
35173: PPUSH
35174: EMPTY
35175: PPUSH
35176: CALL_OW 1
35180: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35181: LD_ADDR_EXP 112
35185: PUSH
35186: LD_EXP 112
35190: PPUSH
35191: LD_VAR 0 4
35195: PPUSH
35196: EMPTY
35197: PPUSH
35198: CALL_OW 1
35202: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35203: LD_ADDR_EXP 113
35207: PUSH
35208: LD_EXP 113
35212: PPUSH
35213: LD_VAR 0 4
35217: PPUSH
35218: EMPTY
35219: PPUSH
35220: CALL_OW 1
35224: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35225: LD_ADDR_EXP 114
35229: PUSH
35230: LD_EXP 114
35234: PPUSH
35235: LD_VAR 0 4
35239: PPUSH
35240: EMPTY
35241: PPUSH
35242: CALL_OW 1
35246: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35247: LD_ADDR_EXP 115
35251: PUSH
35252: LD_EXP 115
35256: PPUSH
35257: LD_VAR 0 4
35261: PPUSH
35262: EMPTY
35263: PPUSH
35264: CALL_OW 1
35268: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35269: LD_ADDR_EXP 116
35273: PUSH
35274: LD_EXP 116
35278: PPUSH
35279: LD_VAR 0 4
35283: PPUSH
35284: EMPTY
35285: PPUSH
35286: CALL_OW 1
35290: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35291: LD_ADDR_EXP 117
35295: PUSH
35296: LD_EXP 117
35300: PPUSH
35301: LD_VAR 0 4
35305: PPUSH
35306: EMPTY
35307: PPUSH
35308: CALL_OW 1
35312: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35313: LD_ADDR_EXP 118
35317: PUSH
35318: LD_EXP 118
35322: PPUSH
35323: LD_VAR 0 4
35327: PPUSH
35328: EMPTY
35329: PPUSH
35330: CALL_OW 1
35334: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35335: LD_ADDR_EXP 119
35339: PUSH
35340: LD_EXP 119
35344: PPUSH
35345: LD_VAR 0 4
35349: PPUSH
35350: EMPTY
35351: PPUSH
35352: CALL_OW 1
35356: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35357: LD_ADDR_EXP 120
35361: PUSH
35362: LD_EXP 120
35366: PPUSH
35367: LD_VAR 0 4
35371: PPUSH
35372: EMPTY
35373: PPUSH
35374: CALL_OW 1
35378: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35379: LD_ADDR_EXP 121
35383: PUSH
35384: LD_EXP 121
35388: PPUSH
35389: LD_VAR 0 4
35393: PPUSH
35394: EMPTY
35395: PPUSH
35396: CALL_OW 1
35400: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35401: LD_ADDR_EXP 122
35405: PUSH
35406: LD_EXP 122
35410: PPUSH
35411: LD_VAR 0 4
35415: PPUSH
35416: EMPTY
35417: PPUSH
35418: CALL_OW 1
35422: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35423: LD_ADDR_EXP 123
35427: PUSH
35428: LD_EXP 123
35432: PPUSH
35433: LD_VAR 0 4
35437: PPUSH
35438: EMPTY
35439: PPUSH
35440: CALL_OW 1
35444: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35445: LD_ADDR_EXP 124
35449: PUSH
35450: LD_EXP 124
35454: PPUSH
35455: LD_VAR 0 4
35459: PPUSH
35460: EMPTY
35461: PPUSH
35462: CALL_OW 1
35466: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35467: LD_ADDR_EXP 126
35471: PUSH
35472: LD_EXP 126
35476: PPUSH
35477: LD_VAR 0 4
35481: PPUSH
35482: EMPTY
35483: PPUSH
35484: CALL_OW 1
35488: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35489: LD_ADDR_EXP 128
35493: PUSH
35494: LD_EXP 128
35498: PPUSH
35499: LD_VAR 0 4
35503: PPUSH
35504: EMPTY
35505: PPUSH
35506: CALL_OW 1
35510: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35511: LD_ADDR_EXP 129
35515: PUSH
35516: LD_EXP 129
35520: PPUSH
35521: LD_VAR 0 4
35525: PPUSH
35526: EMPTY
35527: PPUSH
35528: CALL_OW 1
35532: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35533: LD_ADDR_EXP 130
35537: PUSH
35538: LD_EXP 130
35542: PPUSH
35543: LD_VAR 0 4
35547: PPUSH
35548: EMPTY
35549: PPUSH
35550: CALL_OW 1
35554: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35555: LD_ADDR_EXP 131
35559: PUSH
35560: LD_EXP 131
35564: PPUSH
35565: LD_VAR 0 4
35569: PPUSH
35570: EMPTY
35571: PPUSH
35572: CALL_OW 1
35576: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35577: LD_ADDR_EXP 132
35581: PUSH
35582: LD_EXP 132
35586: PPUSH
35587: LD_VAR 0 4
35591: PPUSH
35592: EMPTY
35593: PPUSH
35594: CALL_OW 1
35598: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35599: LD_ADDR_EXP 133
35603: PUSH
35604: LD_EXP 133
35608: PPUSH
35609: LD_VAR 0 4
35613: PPUSH
35614: EMPTY
35615: PPUSH
35616: CALL_OW 1
35620: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35621: LD_ADDR_EXP 134
35625: PUSH
35626: LD_EXP 134
35630: PPUSH
35631: LD_VAR 0 4
35635: PPUSH
35636: EMPTY
35637: PPUSH
35638: CALL_OW 1
35642: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35643: LD_ADDR_EXP 135
35647: PUSH
35648: LD_EXP 135
35652: PPUSH
35653: LD_VAR 0 4
35657: PPUSH
35658: EMPTY
35659: PPUSH
35660: CALL_OW 1
35664: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35665: LD_ADDR_EXP 136
35669: PUSH
35670: LD_EXP 136
35674: PPUSH
35675: LD_VAR 0 4
35679: PPUSH
35680: EMPTY
35681: PPUSH
35682: CALL_OW 1
35686: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35687: LD_ADDR_EXP 137
35691: PUSH
35692: LD_EXP 137
35696: PPUSH
35697: LD_VAR 0 4
35701: PPUSH
35702: EMPTY
35703: PPUSH
35704: CALL_OW 1
35708: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35709: LD_ADDR_EXP 138
35713: PUSH
35714: LD_EXP 138
35718: PPUSH
35719: LD_VAR 0 4
35723: PPUSH
35724: EMPTY
35725: PPUSH
35726: CALL_OW 1
35730: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35731: LD_ADDR_EXP 139
35735: PUSH
35736: LD_EXP 139
35740: PPUSH
35741: LD_VAR 0 4
35745: PPUSH
35746: EMPTY
35747: PPUSH
35748: CALL_OW 1
35752: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35753: LD_ADDR_EXP 140
35757: PUSH
35758: LD_EXP 140
35762: PPUSH
35763: LD_VAR 0 4
35767: PPUSH
35768: EMPTY
35769: PPUSH
35770: CALL_OW 1
35774: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35775: LD_ADDR_EXP 141
35779: PUSH
35780: LD_EXP 141
35784: PPUSH
35785: LD_VAR 0 4
35789: PPUSH
35790: LD_INT 0
35792: PPUSH
35793: CALL_OW 1
35797: ST_TO_ADDR
// result := base ;
35798: LD_ADDR_VAR 0 3
35802: PUSH
35803: LD_VAR 0 4
35807: ST_TO_ADDR
// end ;
35808: LD_VAR 0 3
35812: RET
// export function MC_Start ( ) ; var i ; begin
35813: LD_INT 0
35815: PPUSH
35816: PPUSH
// for i = 1 to mc_bases do
35817: LD_ADDR_VAR 0 2
35821: PUSH
35822: DOUBLE
35823: LD_INT 1
35825: DEC
35826: ST_TO_ADDR
35827: LD_EXP 99
35831: PUSH
35832: FOR_TO
35833: IFFALSE 36910
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
35835: LD_ADDR_EXP 99
35839: PUSH
35840: LD_EXP 99
35844: PPUSH
35845: LD_VAR 0 2
35849: PPUSH
35850: LD_EXP 99
35854: PUSH
35855: LD_VAR 0 2
35859: ARRAY
35860: PUSH
35861: LD_INT 0
35863: DIFF
35864: PPUSH
35865: CALL_OW 1
35869: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
35870: LD_ADDR_EXP 100
35874: PUSH
35875: LD_EXP 100
35879: PPUSH
35880: LD_VAR 0 2
35884: PPUSH
35885: EMPTY
35886: PPUSH
35887: CALL_OW 1
35891: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
35892: LD_ADDR_EXP 101
35896: PUSH
35897: LD_EXP 101
35901: PPUSH
35902: LD_VAR 0 2
35906: PPUSH
35907: EMPTY
35908: PPUSH
35909: CALL_OW 1
35913: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
35914: LD_ADDR_EXP 102
35918: PUSH
35919: LD_EXP 102
35923: PPUSH
35924: LD_VAR 0 2
35928: PPUSH
35929: EMPTY
35930: PPUSH
35931: CALL_OW 1
35935: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
35936: LD_ADDR_EXP 103
35940: PUSH
35941: LD_EXP 103
35945: PPUSH
35946: LD_VAR 0 2
35950: PPUSH
35951: EMPTY
35952: PUSH
35953: EMPTY
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PPUSH
35959: CALL_OW 1
35963: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
35964: LD_ADDR_EXP 104
35968: PUSH
35969: LD_EXP 104
35973: PPUSH
35974: LD_VAR 0 2
35978: PPUSH
35979: EMPTY
35980: PPUSH
35981: CALL_OW 1
35985: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
35986: LD_ADDR_EXP 131
35990: PUSH
35991: LD_EXP 131
35995: PPUSH
35996: LD_VAR 0 2
36000: PPUSH
36001: EMPTY
36002: PPUSH
36003: CALL_OW 1
36007: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36008: LD_ADDR_EXP 105
36012: PUSH
36013: LD_EXP 105
36017: PPUSH
36018: LD_VAR 0 2
36022: PPUSH
36023: EMPTY
36024: PPUSH
36025: CALL_OW 1
36029: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36030: LD_ADDR_EXP 106
36034: PUSH
36035: LD_EXP 106
36039: PPUSH
36040: LD_VAR 0 2
36044: PPUSH
36045: EMPTY
36046: PPUSH
36047: CALL_OW 1
36051: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36052: LD_ADDR_EXP 107
36056: PUSH
36057: LD_EXP 107
36061: PPUSH
36062: LD_VAR 0 2
36066: PPUSH
36067: LD_EXP 99
36071: PUSH
36072: LD_VAR 0 2
36076: ARRAY
36077: PPUSH
36078: LD_INT 2
36080: PUSH
36081: LD_INT 30
36083: PUSH
36084: LD_INT 32
36086: PUSH
36087: EMPTY
36088: LIST
36089: LIST
36090: PUSH
36091: LD_INT 30
36093: PUSH
36094: LD_INT 33
36096: PUSH
36097: EMPTY
36098: LIST
36099: LIST
36100: PUSH
36101: EMPTY
36102: LIST
36103: LIST
36104: LIST
36105: PPUSH
36106: CALL_OW 72
36110: PPUSH
36111: CALL_OW 1
36115: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36116: LD_ADDR_EXP 108
36120: PUSH
36121: LD_EXP 108
36125: PPUSH
36126: LD_VAR 0 2
36130: PPUSH
36131: LD_EXP 99
36135: PUSH
36136: LD_VAR 0 2
36140: ARRAY
36141: PPUSH
36142: LD_INT 2
36144: PUSH
36145: LD_INT 30
36147: PUSH
36148: LD_INT 32
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 30
36157: PUSH
36158: LD_INT 31
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: EMPTY
36166: LIST
36167: LIST
36168: LIST
36169: PUSH
36170: LD_INT 58
36172: PUSH
36173: EMPTY
36174: LIST
36175: PUSH
36176: EMPTY
36177: LIST
36178: LIST
36179: PPUSH
36180: CALL_OW 72
36184: PPUSH
36185: CALL_OW 1
36189: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36190: LD_ADDR_EXP 109
36194: PUSH
36195: LD_EXP 109
36199: PPUSH
36200: LD_VAR 0 2
36204: PPUSH
36205: EMPTY
36206: PPUSH
36207: CALL_OW 1
36211: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36212: LD_ADDR_EXP 113
36216: PUSH
36217: LD_EXP 113
36221: PPUSH
36222: LD_VAR 0 2
36226: PPUSH
36227: EMPTY
36228: PPUSH
36229: CALL_OW 1
36233: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36234: LD_ADDR_EXP 112
36238: PUSH
36239: LD_EXP 112
36243: PPUSH
36244: LD_VAR 0 2
36248: PPUSH
36249: EMPTY
36250: PPUSH
36251: CALL_OW 1
36255: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36256: LD_ADDR_EXP 114
36260: PUSH
36261: LD_EXP 114
36265: PPUSH
36266: LD_VAR 0 2
36270: PPUSH
36271: EMPTY
36272: PPUSH
36273: CALL_OW 1
36277: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36278: LD_ADDR_EXP 115
36282: PUSH
36283: LD_EXP 115
36287: PPUSH
36288: LD_VAR 0 2
36292: PPUSH
36293: EMPTY
36294: PPUSH
36295: CALL_OW 1
36299: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36300: LD_ADDR_EXP 116
36304: PUSH
36305: LD_EXP 116
36309: PPUSH
36310: LD_VAR 0 2
36314: PPUSH
36315: EMPTY
36316: PPUSH
36317: CALL_OW 1
36321: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36322: LD_ADDR_EXP 117
36326: PUSH
36327: LD_EXP 117
36331: PPUSH
36332: LD_VAR 0 2
36336: PPUSH
36337: EMPTY
36338: PPUSH
36339: CALL_OW 1
36343: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36344: LD_ADDR_EXP 118
36348: PUSH
36349: LD_EXP 118
36353: PPUSH
36354: LD_VAR 0 2
36358: PPUSH
36359: EMPTY
36360: PPUSH
36361: CALL_OW 1
36365: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36366: LD_ADDR_EXP 119
36370: PUSH
36371: LD_EXP 119
36375: PPUSH
36376: LD_VAR 0 2
36380: PPUSH
36381: EMPTY
36382: PPUSH
36383: CALL_OW 1
36387: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36388: LD_ADDR_EXP 120
36392: PUSH
36393: LD_EXP 120
36397: PPUSH
36398: LD_VAR 0 2
36402: PPUSH
36403: EMPTY
36404: PPUSH
36405: CALL_OW 1
36409: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36410: LD_ADDR_EXP 121
36414: PUSH
36415: LD_EXP 121
36419: PPUSH
36420: LD_VAR 0 2
36424: PPUSH
36425: EMPTY
36426: PPUSH
36427: CALL_OW 1
36431: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36432: LD_ADDR_EXP 110
36436: PUSH
36437: LD_EXP 110
36441: PPUSH
36442: LD_VAR 0 2
36446: PPUSH
36447: LD_INT 0
36449: PPUSH
36450: CALL_OW 1
36454: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36455: LD_ADDR_EXP 123
36459: PUSH
36460: LD_EXP 123
36464: PPUSH
36465: LD_VAR 0 2
36469: PPUSH
36470: LD_INT 0
36472: PPUSH
36473: CALL_OW 1
36477: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36478: LD_ADDR_EXP 111
36482: PUSH
36483: LD_EXP 111
36487: PPUSH
36488: LD_VAR 0 2
36492: PPUSH
36493: EMPTY
36494: PPUSH
36495: CALL_OW 1
36499: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36500: LD_ADDR_EXP 122
36504: PUSH
36505: LD_EXP 122
36509: PPUSH
36510: LD_VAR 0 2
36514: PPUSH
36515: LD_INT 0
36517: PPUSH
36518: CALL_OW 1
36522: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36523: LD_ADDR_EXP 124
36527: PUSH
36528: LD_EXP 124
36532: PPUSH
36533: LD_VAR 0 2
36537: PPUSH
36538: EMPTY
36539: PPUSH
36540: CALL_OW 1
36544: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36545: LD_ADDR_EXP 127
36549: PUSH
36550: LD_EXP 127
36554: PPUSH
36555: LD_VAR 0 2
36559: PPUSH
36560: LD_INT 0
36562: PPUSH
36563: CALL_OW 1
36567: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36568: LD_ADDR_EXP 128
36572: PUSH
36573: LD_EXP 128
36577: PPUSH
36578: LD_VAR 0 2
36582: PPUSH
36583: EMPTY
36584: PPUSH
36585: CALL_OW 1
36589: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36590: LD_ADDR_EXP 129
36594: PUSH
36595: LD_EXP 129
36599: PPUSH
36600: LD_VAR 0 2
36604: PPUSH
36605: EMPTY
36606: PPUSH
36607: CALL_OW 1
36611: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36612: LD_ADDR_EXP 130
36616: PUSH
36617: LD_EXP 130
36621: PPUSH
36622: LD_VAR 0 2
36626: PPUSH
36627: EMPTY
36628: PPUSH
36629: CALL_OW 1
36633: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36634: LD_ADDR_EXP 132
36638: PUSH
36639: LD_EXP 132
36643: PPUSH
36644: LD_VAR 0 2
36648: PPUSH
36649: LD_EXP 99
36653: PUSH
36654: LD_VAR 0 2
36658: ARRAY
36659: PPUSH
36660: LD_INT 2
36662: PUSH
36663: LD_INT 30
36665: PUSH
36666: LD_INT 6
36668: PUSH
36669: EMPTY
36670: LIST
36671: LIST
36672: PUSH
36673: LD_INT 30
36675: PUSH
36676: LD_INT 7
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 30
36685: PUSH
36686: LD_INT 8
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: LIST
36697: LIST
36698: PPUSH
36699: CALL_OW 72
36703: PPUSH
36704: CALL_OW 1
36708: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36709: LD_ADDR_EXP 133
36713: PUSH
36714: LD_EXP 133
36718: PPUSH
36719: LD_VAR 0 2
36723: PPUSH
36724: EMPTY
36725: PPUSH
36726: CALL_OW 1
36730: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36731: LD_ADDR_EXP 134
36735: PUSH
36736: LD_EXP 134
36740: PPUSH
36741: LD_VAR 0 2
36745: PPUSH
36746: EMPTY
36747: PPUSH
36748: CALL_OW 1
36752: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36753: LD_ADDR_EXP 135
36757: PUSH
36758: LD_EXP 135
36762: PPUSH
36763: LD_VAR 0 2
36767: PPUSH
36768: EMPTY
36769: PPUSH
36770: CALL_OW 1
36774: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
36775: LD_ADDR_EXP 136
36779: PUSH
36780: LD_EXP 136
36784: PPUSH
36785: LD_VAR 0 2
36789: PPUSH
36790: EMPTY
36791: PPUSH
36792: CALL_OW 1
36796: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
36797: LD_ADDR_EXP 137
36801: PUSH
36802: LD_EXP 137
36806: PPUSH
36807: LD_VAR 0 2
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
36819: LD_ADDR_EXP 138
36823: PUSH
36824: LD_EXP 138
36828: PPUSH
36829: LD_VAR 0 2
36833: PPUSH
36834: EMPTY
36835: PPUSH
36836: CALL_OW 1
36840: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
36841: LD_ADDR_EXP 139
36845: PUSH
36846: LD_EXP 139
36850: PPUSH
36851: LD_VAR 0 2
36855: PPUSH
36856: EMPTY
36857: PPUSH
36858: CALL_OW 1
36862: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
36863: LD_ADDR_EXP 140
36867: PUSH
36868: LD_EXP 140
36872: PPUSH
36873: LD_VAR 0 2
36877: PPUSH
36878: EMPTY
36879: PPUSH
36880: CALL_OW 1
36884: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
36885: LD_ADDR_EXP 141
36889: PUSH
36890: LD_EXP 141
36894: PPUSH
36895: LD_VAR 0 2
36899: PPUSH
36900: LD_INT 0
36902: PPUSH
36903: CALL_OW 1
36907: ST_TO_ADDR
// end ;
36908: GO 35832
36910: POP
36911: POP
// MC_InitSides ( ) ;
36912: CALL 37198 0 0
// MC_InitResearch ( ) ;
36916: CALL 36937 0 0
// CustomInitMacro ( ) ;
36920: CALL 444 0 0
// skirmish := true ;
36924: LD_ADDR_EXP 97
36928: PUSH
36929: LD_INT 1
36931: ST_TO_ADDR
// end ;
36932: LD_VAR 0 1
36936: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
36937: LD_INT 0
36939: PPUSH
36940: PPUSH
36941: PPUSH
36942: PPUSH
36943: PPUSH
36944: PPUSH
// if not mc_bases then
36945: LD_EXP 99
36949: NOT
36950: IFFALSE 36954
// exit ;
36952: GO 37193
// for i = 1 to 8 do
36954: LD_ADDR_VAR 0 2
36958: PUSH
36959: DOUBLE
36960: LD_INT 1
36962: DEC
36963: ST_TO_ADDR
36964: LD_INT 8
36966: PUSH
36967: FOR_TO
36968: IFFALSE 36994
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
36970: LD_ADDR_EXP 126
36974: PUSH
36975: LD_EXP 126
36979: PPUSH
36980: LD_VAR 0 2
36984: PPUSH
36985: EMPTY
36986: PPUSH
36987: CALL_OW 1
36991: ST_TO_ADDR
36992: GO 36967
36994: POP
36995: POP
// tmp := [ ] ;
36996: LD_ADDR_VAR 0 5
37000: PUSH
37001: EMPTY
37002: ST_TO_ADDR
// for i = 1 to mc_sides do
37003: LD_ADDR_VAR 0 2
37007: PUSH
37008: DOUBLE
37009: LD_INT 1
37011: DEC
37012: ST_TO_ADDR
37013: LD_EXP 125
37017: PUSH
37018: FOR_TO
37019: IFFALSE 37077
// if not mc_sides [ i ] in tmp then
37021: LD_EXP 125
37025: PUSH
37026: LD_VAR 0 2
37030: ARRAY
37031: PUSH
37032: LD_VAR 0 5
37036: IN
37037: NOT
37038: IFFALSE 37075
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37040: LD_ADDR_VAR 0 5
37044: PUSH
37045: LD_VAR 0 5
37049: PPUSH
37050: LD_VAR 0 5
37054: PUSH
37055: LD_INT 1
37057: PLUS
37058: PPUSH
37059: LD_EXP 125
37063: PUSH
37064: LD_VAR 0 2
37068: ARRAY
37069: PPUSH
37070: CALL_OW 2
37074: ST_TO_ADDR
37075: GO 37018
37077: POP
37078: POP
// if not tmp then
37079: LD_VAR 0 5
37083: NOT
37084: IFFALSE 37088
// exit ;
37086: GO 37193
// for j in tmp do
37088: LD_ADDR_VAR 0 3
37092: PUSH
37093: LD_VAR 0 5
37097: PUSH
37098: FOR_IN
37099: IFFALSE 37191
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37101: LD_ADDR_VAR 0 6
37105: PUSH
37106: LD_INT 22
37108: PUSH
37109: LD_VAR 0 3
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: PPUSH
37118: CALL_OW 69
37122: ST_TO_ADDR
// if not un then
37123: LD_VAR 0 6
37127: NOT
37128: IFFALSE 37132
// continue ;
37130: GO 37098
// nation := GetNation ( un [ 1 ] ) ;
37132: LD_ADDR_VAR 0 4
37136: PUSH
37137: LD_VAR 0 6
37141: PUSH
37142: LD_INT 1
37144: ARRAY
37145: PPUSH
37146: CALL_OW 248
37150: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37151: LD_ADDR_EXP 126
37155: PUSH
37156: LD_EXP 126
37160: PPUSH
37161: LD_VAR 0 3
37165: PPUSH
37166: LD_VAR 0 3
37170: PPUSH
37171: LD_VAR 0 4
37175: PPUSH
37176: LD_INT 1
37178: PPUSH
37179: CALL 62987 0 3
37183: PPUSH
37184: CALL_OW 1
37188: ST_TO_ADDR
// end ;
37189: GO 37098
37191: POP
37192: POP
// end ;
37193: LD_VAR 0 1
37197: RET
// export function MC_InitSides ( ) ; var i ; begin
37198: LD_INT 0
37200: PPUSH
37201: PPUSH
// if not mc_bases then
37202: LD_EXP 99
37206: NOT
37207: IFFALSE 37211
// exit ;
37209: GO 37285
// for i = 1 to mc_bases do
37211: LD_ADDR_VAR 0 2
37215: PUSH
37216: DOUBLE
37217: LD_INT 1
37219: DEC
37220: ST_TO_ADDR
37221: LD_EXP 99
37225: PUSH
37226: FOR_TO
37227: IFFALSE 37283
// if mc_bases [ i ] then
37229: LD_EXP 99
37233: PUSH
37234: LD_VAR 0 2
37238: ARRAY
37239: IFFALSE 37281
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37241: LD_ADDR_EXP 125
37245: PUSH
37246: LD_EXP 125
37250: PPUSH
37251: LD_VAR 0 2
37255: PPUSH
37256: LD_EXP 99
37260: PUSH
37261: LD_VAR 0 2
37265: ARRAY
37266: PUSH
37267: LD_INT 1
37269: ARRAY
37270: PPUSH
37271: CALL_OW 255
37275: PPUSH
37276: CALL_OW 1
37280: ST_TO_ADDR
37281: GO 37226
37283: POP
37284: POP
// end ;
37285: LD_VAR 0 1
37289: RET
// every 0 0$01 trigger skirmish do
37290: LD_EXP 97
37294: IFFALSE 37448
37296: GO 37298
37298: DISABLE
// begin enable ;
37299: ENABLE
// MC_CheckBuildings ( ) ;
37300: CALL 41937 0 0
// MC_CheckPeopleLife ( ) ;
37304: CALL 42062 0 0
// RaiseSailEvent ( 100 ) ;
37308: LD_INT 100
37310: PPUSH
37311: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37315: LD_INT 103
37317: PPUSH
37318: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37322: LD_INT 104
37324: PPUSH
37325: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37329: LD_INT 105
37331: PPUSH
37332: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37336: LD_INT 106
37338: PPUSH
37339: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37343: LD_INT 107
37345: PPUSH
37346: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37350: LD_INT 108
37352: PPUSH
37353: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37357: LD_INT 109
37359: PPUSH
37360: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37364: LD_INT 110
37366: PPUSH
37367: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37371: LD_INT 111
37373: PPUSH
37374: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37378: LD_INT 112
37380: PPUSH
37381: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37385: LD_INT 113
37387: PPUSH
37388: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37392: LD_INT 120
37394: PPUSH
37395: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37399: LD_INT 121
37401: PPUSH
37402: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37406: LD_INT 122
37408: PPUSH
37409: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37413: LD_INT 123
37415: PPUSH
37416: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37420: LD_INT 124
37422: PPUSH
37423: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37427: LD_INT 125
37429: PPUSH
37430: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37434: LD_INT 126
37436: PPUSH
37437: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37441: LD_INT 200
37443: PPUSH
37444: CALL_OW 427
// end ;
37448: END
// on SailEvent ( event ) do begin if event < 100 then
37449: LD_VAR 0 1
37453: PUSH
37454: LD_INT 100
37456: LESS
37457: IFFALSE 37468
// CustomEvent ( event ) ;
37459: LD_VAR 0 1
37463: PPUSH
37464: CALL 32131 0 1
// if event = 100 then
37468: LD_VAR 0 1
37472: PUSH
37473: LD_INT 100
37475: EQUAL
37476: IFFALSE 37482
// MC_ClassManager ( ) ;
37478: CALL 37874 0 0
// if event = 101 then
37482: LD_VAR 0 1
37486: PUSH
37487: LD_INT 101
37489: EQUAL
37490: IFFALSE 37496
// MC_RepairBuildings ( ) ;
37492: CALL 42658 0 0
// if event = 102 then
37496: LD_VAR 0 1
37500: PUSH
37501: LD_INT 102
37503: EQUAL
37504: IFFALSE 37510
// MC_Heal ( ) ;
37506: CALL 43064 0 0
// if event = 103 then
37510: LD_VAR 0 1
37514: PUSH
37515: LD_INT 103
37517: EQUAL
37518: IFFALSE 37524
// MC_Build ( ) ;
37520: CALL 43486 0 0
// if event = 104 then
37524: LD_VAR 0 1
37528: PUSH
37529: LD_INT 104
37531: EQUAL
37532: IFFALSE 37538
// MC_TurretWeapon ( ) ;
37534: CALL 45099 0 0
// if event = 105 then
37538: LD_VAR 0 1
37542: PUSH
37543: LD_INT 105
37545: EQUAL
37546: IFFALSE 37552
// MC_BuildUpgrade ( ) ;
37548: CALL 44650 0 0
// if event = 106 then
37552: LD_VAR 0 1
37556: PUSH
37557: LD_INT 106
37559: EQUAL
37560: IFFALSE 37566
// MC_PlantMines ( ) ;
37562: CALL 45529 0 0
// if event = 107 then
37566: LD_VAR 0 1
37570: PUSH
37571: LD_INT 107
37573: EQUAL
37574: IFFALSE 37580
// MC_CollectCrates ( ) ;
37576: CALL 46563 0 0
// if event = 108 then
37580: LD_VAR 0 1
37584: PUSH
37585: LD_INT 108
37587: EQUAL
37588: IFFALSE 37594
// MC_LinkRemoteControl ( ) ;
37590: CALL 48320 0 0
// if event = 109 then
37594: LD_VAR 0 1
37598: PUSH
37599: LD_INT 109
37601: EQUAL
37602: IFFALSE 37608
// MC_ProduceVehicle ( ) ;
37604: CALL 48501 0 0
// if event = 110 then
37608: LD_VAR 0 1
37612: PUSH
37613: LD_INT 110
37615: EQUAL
37616: IFFALSE 37622
// MC_SendAttack ( ) ;
37618: CALL 48982 0 0
// if event = 111 then
37622: LD_VAR 0 1
37626: PUSH
37627: LD_INT 111
37629: EQUAL
37630: IFFALSE 37636
// MC_Defend ( ) ;
37632: CALL 49090 0 0
// if event = 112 then
37636: LD_VAR 0 1
37640: PUSH
37641: LD_INT 112
37643: EQUAL
37644: IFFALSE 37650
// MC_Research ( ) ;
37646: CALL 49695 0 0
// if event = 113 then
37650: LD_VAR 0 1
37654: PUSH
37655: LD_INT 113
37657: EQUAL
37658: IFFALSE 37664
// MC_MinesTrigger ( ) ;
37660: CALL 50809 0 0
// if event = 120 then
37664: LD_VAR 0 1
37668: PUSH
37669: LD_INT 120
37671: EQUAL
37672: IFFALSE 37678
// MC_RepairVehicle ( ) ;
37674: CALL 50908 0 0
// if event = 121 then
37678: LD_VAR 0 1
37682: PUSH
37683: LD_INT 121
37685: EQUAL
37686: IFFALSE 37692
// MC_TameApe ( ) ;
37688: CALL 51615 0 0
// if event = 122 then
37692: LD_VAR 0 1
37696: PUSH
37697: LD_INT 122
37699: EQUAL
37700: IFFALSE 37706
// MC_ChangeApeClass ( ) ;
37702: CALL 52444 0 0
// if event = 123 then
37706: LD_VAR 0 1
37710: PUSH
37711: LD_INT 123
37713: EQUAL
37714: IFFALSE 37720
// MC_Bazooka ( ) ;
37716: CALL 53094 0 0
// if event = 124 then
37720: LD_VAR 0 1
37724: PUSH
37725: LD_INT 124
37727: EQUAL
37728: IFFALSE 37734
// MC_TeleportExit ( ) ;
37730: CALL 53292 0 0
// if event = 125 then
37734: LD_VAR 0 1
37738: PUSH
37739: LD_INT 125
37741: EQUAL
37742: IFFALSE 37748
// MC_Deposits ( ) ;
37744: CALL 53939 0 0
// if event = 126 then
37748: LD_VAR 0 1
37752: PUSH
37753: LD_INT 126
37755: EQUAL
37756: IFFALSE 37762
// MC_RemoteDriver ( ) ;
37758: CALL 54564 0 0
// if event = 200 then
37762: LD_VAR 0 1
37766: PUSH
37767: LD_INT 200
37769: EQUAL
37770: IFFALSE 37776
// MC_Idle ( ) ;
37772: CALL 56297 0 0
// end ;
37776: PPOPN 1
37778: END
// export function MC_Reset ( base , tag ) ; var i ; begin
37779: LD_INT 0
37781: PPUSH
37782: PPUSH
// if not mc_bases [ base ] or not tag then
37783: LD_EXP 99
37787: PUSH
37788: LD_VAR 0 1
37792: ARRAY
37793: NOT
37794: PUSH
37795: LD_VAR 0 2
37799: NOT
37800: OR
37801: IFFALSE 37805
// exit ;
37803: GO 37869
// for i in mc_bases [ base ] union mc_ape [ base ] do
37805: LD_ADDR_VAR 0 4
37809: PUSH
37810: LD_EXP 99
37814: PUSH
37815: LD_VAR 0 1
37819: ARRAY
37820: PUSH
37821: LD_EXP 128
37825: PUSH
37826: LD_VAR 0 1
37830: ARRAY
37831: UNION
37832: PUSH
37833: FOR_IN
37834: IFFALSE 37867
// if GetTag ( i ) = tag then
37836: LD_VAR 0 4
37840: PPUSH
37841: CALL_OW 110
37845: PUSH
37846: LD_VAR 0 2
37850: EQUAL
37851: IFFALSE 37865
// SetTag ( i , 0 ) ;
37853: LD_VAR 0 4
37857: PPUSH
37858: LD_INT 0
37860: PPUSH
37861: CALL_OW 109
37865: GO 37833
37867: POP
37868: POP
// end ;
37869: LD_VAR 0 3
37873: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
37874: LD_INT 0
37876: PPUSH
37877: PPUSH
37878: PPUSH
37879: PPUSH
37880: PPUSH
37881: PPUSH
37882: PPUSH
37883: PPUSH
// if not mc_bases then
37884: LD_EXP 99
37888: NOT
37889: IFFALSE 37893
// exit ;
37891: GO 38351
// for i = 1 to mc_bases do
37893: LD_ADDR_VAR 0 2
37897: PUSH
37898: DOUBLE
37899: LD_INT 1
37901: DEC
37902: ST_TO_ADDR
37903: LD_EXP 99
37907: PUSH
37908: FOR_TO
37909: IFFALSE 38349
// begin tmp := MC_ClassCheckReq ( i ) ;
37911: LD_ADDR_VAR 0 4
37915: PUSH
37916: LD_VAR 0 2
37920: PPUSH
37921: CALL 38356 0 1
37925: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
37926: LD_ADDR_EXP 140
37930: PUSH
37931: LD_EXP 140
37935: PPUSH
37936: LD_VAR 0 2
37940: PPUSH
37941: LD_VAR 0 4
37945: PPUSH
37946: CALL_OW 1
37950: ST_TO_ADDR
// if not tmp then
37951: LD_VAR 0 4
37955: NOT
37956: IFFALSE 37960
// continue ;
37958: GO 37908
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
37960: LD_ADDR_VAR 0 6
37964: PUSH
37965: LD_EXP 99
37969: PUSH
37970: LD_VAR 0 2
37974: ARRAY
37975: PPUSH
37976: LD_INT 2
37978: PUSH
37979: LD_INT 30
37981: PUSH
37982: LD_INT 4
37984: PUSH
37985: EMPTY
37986: LIST
37987: LIST
37988: PUSH
37989: LD_INT 30
37991: PUSH
37992: LD_INT 5
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: LIST
38003: PPUSH
38004: CALL_OW 72
38008: PUSH
38009: LD_EXP 99
38013: PUSH
38014: LD_VAR 0 2
38018: ARRAY
38019: PPUSH
38020: LD_INT 2
38022: PUSH
38023: LD_INT 30
38025: PUSH
38026: LD_INT 0
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 30
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: LIST
38047: PPUSH
38048: CALL_OW 72
38052: PUSH
38053: LD_EXP 99
38057: PUSH
38058: LD_VAR 0 2
38062: ARRAY
38063: PPUSH
38064: LD_INT 30
38066: PUSH
38067: LD_INT 3
38069: PUSH
38070: EMPTY
38071: LIST
38072: LIST
38073: PPUSH
38074: CALL_OW 72
38078: PUSH
38079: LD_EXP 99
38083: PUSH
38084: LD_VAR 0 2
38088: ARRAY
38089: PPUSH
38090: LD_INT 2
38092: PUSH
38093: LD_INT 30
38095: PUSH
38096: LD_INT 6
38098: PUSH
38099: EMPTY
38100: LIST
38101: LIST
38102: PUSH
38103: LD_INT 30
38105: PUSH
38106: LD_INT 7
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 30
38115: PUSH
38116: LD_INT 8
38118: PUSH
38119: EMPTY
38120: LIST
38121: LIST
38122: PUSH
38123: EMPTY
38124: LIST
38125: LIST
38126: LIST
38127: LIST
38128: PPUSH
38129: CALL_OW 72
38133: PUSH
38134: EMPTY
38135: LIST
38136: LIST
38137: LIST
38138: LIST
38139: ST_TO_ADDR
// for j = 1 to 4 do
38140: LD_ADDR_VAR 0 3
38144: PUSH
38145: DOUBLE
38146: LD_INT 1
38148: DEC
38149: ST_TO_ADDR
38150: LD_INT 4
38152: PUSH
38153: FOR_TO
38154: IFFALSE 38345
// begin if not tmp [ j ] then
38156: LD_VAR 0 4
38160: PUSH
38161: LD_VAR 0 3
38165: ARRAY
38166: NOT
38167: IFFALSE 38171
// continue ;
38169: GO 38153
// for p in tmp [ j ] do
38171: LD_ADDR_VAR 0 5
38175: PUSH
38176: LD_VAR 0 4
38180: PUSH
38181: LD_VAR 0 3
38185: ARRAY
38186: PUSH
38187: FOR_IN
38188: IFFALSE 38341
// begin if not b [ j ] then
38190: LD_VAR 0 6
38194: PUSH
38195: LD_VAR 0 3
38199: ARRAY
38200: NOT
38201: IFFALSE 38205
// break ;
38203: GO 38341
// e := 0 ;
38205: LD_ADDR_VAR 0 7
38209: PUSH
38210: LD_INT 0
38212: ST_TO_ADDR
// for k in b [ j ] do
38213: LD_ADDR_VAR 0 8
38217: PUSH
38218: LD_VAR 0 6
38222: PUSH
38223: LD_VAR 0 3
38227: ARRAY
38228: PUSH
38229: FOR_IN
38230: IFFALSE 38257
// if IsNotFull ( k ) then
38232: LD_VAR 0 8
38236: PPUSH
38237: CALL 66976 0 1
38241: IFFALSE 38255
// begin e := k ;
38243: LD_ADDR_VAR 0 7
38247: PUSH
38248: LD_VAR 0 8
38252: ST_TO_ADDR
// break ;
38253: GO 38257
// end ;
38255: GO 38229
38257: POP
38258: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38259: LD_VAR 0 7
38263: PUSH
38264: LD_VAR 0 5
38268: PPUSH
38269: LD_VAR 0 7
38273: PPUSH
38274: CALL 104034 0 2
38278: NOT
38279: AND
38280: IFFALSE 38339
// begin if IsInUnit ( p ) then
38282: LD_VAR 0 5
38286: PPUSH
38287: CALL_OW 310
38291: IFFALSE 38302
// ComExitBuilding ( p ) ;
38293: LD_VAR 0 5
38297: PPUSH
38298: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38302: LD_VAR 0 5
38306: PPUSH
38307: LD_VAR 0 7
38311: PPUSH
38312: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38316: LD_VAR 0 5
38320: PPUSH
38321: LD_VAR 0 3
38325: PPUSH
38326: CALL_OW 183
// AddComExitBuilding ( p ) ;
38330: LD_VAR 0 5
38334: PPUSH
38335: CALL_OW 182
// end ; end ;
38339: GO 38187
38341: POP
38342: POP
// end ;
38343: GO 38153
38345: POP
38346: POP
// end ;
38347: GO 37908
38349: POP
38350: POP
// end ;
38351: LD_VAR 0 1
38355: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38356: LD_INT 0
38358: PPUSH
38359: PPUSH
38360: PPUSH
38361: PPUSH
38362: PPUSH
38363: PPUSH
38364: PPUSH
38365: PPUSH
38366: PPUSH
38367: PPUSH
38368: PPUSH
38369: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38370: LD_VAR 0 1
38374: NOT
38375: PUSH
38376: LD_EXP 99
38380: PUSH
38381: LD_VAR 0 1
38385: ARRAY
38386: NOT
38387: OR
38388: PUSH
38389: LD_EXP 99
38393: PUSH
38394: LD_VAR 0 1
38398: ARRAY
38399: PPUSH
38400: LD_INT 2
38402: PUSH
38403: LD_INT 30
38405: PUSH
38406: LD_INT 0
38408: PUSH
38409: EMPTY
38410: LIST
38411: LIST
38412: PUSH
38413: LD_INT 30
38415: PUSH
38416: LD_INT 1
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: EMPTY
38424: LIST
38425: LIST
38426: LIST
38427: PPUSH
38428: CALL_OW 72
38432: NOT
38433: OR
38434: IFFALSE 38438
// exit ;
38436: GO 41932
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38438: LD_ADDR_VAR 0 4
38442: PUSH
38443: LD_EXP 99
38447: PUSH
38448: LD_VAR 0 1
38452: ARRAY
38453: PPUSH
38454: LD_INT 2
38456: PUSH
38457: LD_INT 25
38459: PUSH
38460: LD_INT 1
38462: PUSH
38463: EMPTY
38464: LIST
38465: LIST
38466: PUSH
38467: LD_INT 25
38469: PUSH
38470: LD_INT 2
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 25
38479: PUSH
38480: LD_INT 3
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: LD_INT 25
38489: PUSH
38490: LD_INT 4
38492: PUSH
38493: EMPTY
38494: LIST
38495: LIST
38496: PUSH
38497: LD_INT 25
38499: PUSH
38500: LD_INT 5
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 25
38509: PUSH
38510: LD_INT 8
38512: PUSH
38513: EMPTY
38514: LIST
38515: LIST
38516: PUSH
38517: LD_INT 25
38519: PUSH
38520: LD_INT 9
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: PUSH
38527: EMPTY
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: PPUSH
38537: CALL_OW 72
38541: ST_TO_ADDR
// for i in tmp do
38542: LD_ADDR_VAR 0 3
38546: PUSH
38547: LD_VAR 0 4
38551: PUSH
38552: FOR_IN
38553: IFFALSE 38584
// if GetTag ( i ) then
38555: LD_VAR 0 3
38559: PPUSH
38560: CALL_OW 110
38564: IFFALSE 38582
// tmp := tmp diff i ;
38566: LD_ADDR_VAR 0 4
38570: PUSH
38571: LD_VAR 0 4
38575: PUSH
38576: LD_VAR 0 3
38580: DIFF
38581: ST_TO_ADDR
38582: GO 38552
38584: POP
38585: POP
// if not tmp then
38586: LD_VAR 0 4
38590: NOT
38591: IFFALSE 38595
// exit ;
38593: GO 41932
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38595: LD_ADDR_VAR 0 5
38599: PUSH
38600: LD_EXP 99
38604: PUSH
38605: LD_VAR 0 1
38609: ARRAY
38610: PPUSH
38611: LD_INT 2
38613: PUSH
38614: LD_INT 25
38616: PUSH
38617: LD_INT 1
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 25
38626: PUSH
38627: LD_INT 5
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: PUSH
38634: LD_INT 25
38636: PUSH
38637: LD_INT 8
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: LD_INT 25
38646: PUSH
38647: LD_INT 9
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: LIST
38658: LIST
38659: LIST
38660: PPUSH
38661: CALL_OW 72
38665: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38666: LD_ADDR_VAR 0 6
38670: PUSH
38671: LD_EXP 99
38675: PUSH
38676: LD_VAR 0 1
38680: ARRAY
38681: PPUSH
38682: LD_INT 25
38684: PUSH
38685: LD_INT 2
38687: PUSH
38688: EMPTY
38689: LIST
38690: LIST
38691: PPUSH
38692: CALL_OW 72
38696: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38697: LD_ADDR_VAR 0 7
38701: PUSH
38702: LD_EXP 99
38706: PUSH
38707: LD_VAR 0 1
38711: ARRAY
38712: PPUSH
38713: LD_INT 25
38715: PUSH
38716: LD_INT 3
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PPUSH
38723: CALL_OW 72
38727: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38728: LD_ADDR_VAR 0 8
38732: PUSH
38733: LD_EXP 99
38737: PUSH
38738: LD_VAR 0 1
38742: ARRAY
38743: PPUSH
38744: LD_INT 25
38746: PUSH
38747: LD_INT 4
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 24
38756: PUSH
38757: LD_INT 251
38759: PUSH
38760: EMPTY
38761: LIST
38762: LIST
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PPUSH
38768: CALL_OW 72
38772: ST_TO_ADDR
// if mc_scan [ base ] then
38773: LD_EXP 122
38777: PUSH
38778: LD_VAR 0 1
38782: ARRAY
38783: IFFALSE 39244
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
38785: LD_ADDR_EXP 141
38789: PUSH
38790: LD_EXP 141
38794: PPUSH
38795: LD_VAR 0 1
38799: PPUSH
38800: LD_INT 4
38802: PPUSH
38803: CALL_OW 1
38807: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38808: LD_ADDR_VAR 0 12
38812: PUSH
38813: LD_EXP 99
38817: PUSH
38818: LD_VAR 0 1
38822: ARRAY
38823: PPUSH
38824: LD_INT 2
38826: PUSH
38827: LD_INT 30
38829: PUSH
38830: LD_INT 4
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: LD_INT 30
38839: PUSH
38840: LD_INT 5
38842: PUSH
38843: EMPTY
38844: LIST
38845: LIST
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: LIST
38851: PPUSH
38852: CALL_OW 72
38856: ST_TO_ADDR
// if not b then
38857: LD_VAR 0 12
38861: NOT
38862: IFFALSE 38866
// exit ;
38864: GO 41932
// p := [ ] ;
38866: LD_ADDR_VAR 0 11
38870: PUSH
38871: EMPTY
38872: ST_TO_ADDR
// if sci >= 2 then
38873: LD_VAR 0 8
38877: PUSH
38878: LD_INT 2
38880: GREATEREQUAL
38881: IFFALSE 38912
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
38883: LD_ADDR_VAR 0 8
38887: PUSH
38888: LD_VAR 0 8
38892: PUSH
38893: LD_INT 1
38895: ARRAY
38896: PUSH
38897: LD_VAR 0 8
38901: PUSH
38902: LD_INT 2
38904: ARRAY
38905: PUSH
38906: EMPTY
38907: LIST
38908: LIST
38909: ST_TO_ADDR
38910: GO 38973
// if sci = 1 then
38912: LD_VAR 0 8
38916: PUSH
38917: LD_INT 1
38919: EQUAL
38920: IFFALSE 38941
// sci := [ sci [ 1 ] ] else
38922: LD_ADDR_VAR 0 8
38926: PUSH
38927: LD_VAR 0 8
38931: PUSH
38932: LD_INT 1
38934: ARRAY
38935: PUSH
38936: EMPTY
38937: LIST
38938: ST_TO_ADDR
38939: GO 38973
// if sci = 0 then
38941: LD_VAR 0 8
38945: PUSH
38946: LD_INT 0
38948: EQUAL
38949: IFFALSE 38973
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
38951: LD_ADDR_VAR 0 11
38955: PUSH
38956: LD_VAR 0 4
38960: PPUSH
38961: LD_INT 4
38963: PPUSH
38964: CALL 103897 0 2
38968: PUSH
38969: LD_INT 1
38971: ARRAY
38972: ST_TO_ADDR
// if eng > 4 then
38973: LD_VAR 0 6
38977: PUSH
38978: LD_INT 4
38980: GREATER
38981: IFFALSE 39027
// for i = eng downto 4 do
38983: LD_ADDR_VAR 0 3
38987: PUSH
38988: DOUBLE
38989: LD_VAR 0 6
38993: INC
38994: ST_TO_ADDR
38995: LD_INT 4
38997: PUSH
38998: FOR_DOWNTO
38999: IFFALSE 39025
// eng := eng diff eng [ i ] ;
39001: LD_ADDR_VAR 0 6
39005: PUSH
39006: LD_VAR 0 6
39010: PUSH
39011: LD_VAR 0 6
39015: PUSH
39016: LD_VAR 0 3
39020: ARRAY
39021: DIFF
39022: ST_TO_ADDR
39023: GO 38998
39025: POP
39026: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39027: LD_ADDR_VAR 0 4
39031: PUSH
39032: LD_VAR 0 4
39036: PUSH
39037: LD_VAR 0 5
39041: PUSH
39042: LD_VAR 0 6
39046: UNION
39047: PUSH
39048: LD_VAR 0 7
39052: UNION
39053: PUSH
39054: LD_VAR 0 8
39058: UNION
39059: DIFF
39060: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39061: LD_ADDR_VAR 0 13
39065: PUSH
39066: LD_EXP 99
39070: PUSH
39071: LD_VAR 0 1
39075: ARRAY
39076: PPUSH
39077: LD_INT 2
39079: PUSH
39080: LD_INT 30
39082: PUSH
39083: LD_INT 32
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 30
39092: PUSH
39093: LD_INT 31
39095: PUSH
39096: EMPTY
39097: LIST
39098: LIST
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: LIST
39104: PPUSH
39105: CALL_OW 72
39109: PUSH
39110: LD_EXP 99
39114: PUSH
39115: LD_VAR 0 1
39119: ARRAY
39120: PPUSH
39121: LD_INT 2
39123: PUSH
39124: LD_INT 30
39126: PUSH
39127: LD_INT 4
39129: PUSH
39130: EMPTY
39131: LIST
39132: LIST
39133: PUSH
39134: LD_INT 30
39136: PUSH
39137: LD_INT 5
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: LIST
39148: PPUSH
39149: CALL_OW 72
39153: PUSH
39154: LD_INT 6
39156: MUL
39157: PLUS
39158: ST_TO_ADDR
// if bcount < tmp then
39159: LD_VAR 0 13
39163: PUSH
39164: LD_VAR 0 4
39168: LESS
39169: IFFALSE 39215
// for i = tmp downto bcount do
39171: LD_ADDR_VAR 0 3
39175: PUSH
39176: DOUBLE
39177: LD_VAR 0 4
39181: INC
39182: ST_TO_ADDR
39183: LD_VAR 0 13
39187: PUSH
39188: FOR_DOWNTO
39189: IFFALSE 39213
// tmp := Delete ( tmp , tmp ) ;
39191: LD_ADDR_VAR 0 4
39195: PUSH
39196: LD_VAR 0 4
39200: PPUSH
39201: LD_VAR 0 4
39205: PPUSH
39206: CALL_OW 3
39210: ST_TO_ADDR
39211: GO 39188
39213: POP
39214: POP
// result := [ tmp , 0 , 0 , p ] ;
39215: LD_ADDR_VAR 0 2
39219: PUSH
39220: LD_VAR 0 4
39224: PUSH
39225: LD_INT 0
39227: PUSH
39228: LD_INT 0
39230: PUSH
39231: LD_VAR 0 11
39235: PUSH
39236: EMPTY
39237: LIST
39238: LIST
39239: LIST
39240: LIST
39241: ST_TO_ADDR
// exit ;
39242: GO 41932
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39244: LD_EXP 99
39248: PUSH
39249: LD_VAR 0 1
39253: ARRAY
39254: PPUSH
39255: LD_INT 2
39257: PUSH
39258: LD_INT 30
39260: PUSH
39261: LD_INT 6
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: PUSH
39268: LD_INT 30
39270: PUSH
39271: LD_INT 7
39273: PUSH
39274: EMPTY
39275: LIST
39276: LIST
39277: PUSH
39278: LD_INT 30
39280: PUSH
39281: LD_INT 8
39283: PUSH
39284: EMPTY
39285: LIST
39286: LIST
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: PPUSH
39294: CALL_OW 72
39298: NOT
39299: PUSH
39300: LD_EXP 99
39304: PUSH
39305: LD_VAR 0 1
39309: ARRAY
39310: PPUSH
39311: LD_INT 30
39313: PUSH
39314: LD_INT 3
39316: PUSH
39317: EMPTY
39318: LIST
39319: LIST
39320: PPUSH
39321: CALL_OW 72
39325: NOT
39326: AND
39327: IFFALSE 39399
// begin if eng = tmp then
39329: LD_VAR 0 6
39333: PUSH
39334: LD_VAR 0 4
39338: EQUAL
39339: IFFALSE 39343
// exit ;
39341: GO 41932
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39343: LD_ADDR_EXP 141
39347: PUSH
39348: LD_EXP 141
39352: PPUSH
39353: LD_VAR 0 1
39357: PPUSH
39358: LD_INT 1
39360: PPUSH
39361: CALL_OW 1
39365: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39366: LD_ADDR_VAR 0 2
39370: PUSH
39371: LD_INT 0
39373: PUSH
39374: LD_VAR 0 4
39378: PUSH
39379: LD_VAR 0 6
39383: DIFF
39384: PUSH
39385: LD_INT 0
39387: PUSH
39388: LD_INT 0
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: LIST
39395: LIST
39396: ST_TO_ADDR
// exit ;
39397: GO 41932
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39399: LD_EXP 126
39403: PUSH
39404: LD_EXP 125
39408: PUSH
39409: LD_VAR 0 1
39413: ARRAY
39414: ARRAY
39415: PUSH
39416: LD_EXP 99
39420: PUSH
39421: LD_VAR 0 1
39425: ARRAY
39426: PPUSH
39427: LD_INT 2
39429: PUSH
39430: LD_INT 30
39432: PUSH
39433: LD_INT 6
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 30
39442: PUSH
39443: LD_INT 7
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 30
39452: PUSH
39453: LD_INT 8
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: LIST
39464: LIST
39465: PPUSH
39466: CALL_OW 72
39470: AND
39471: PUSH
39472: LD_EXP 99
39476: PUSH
39477: LD_VAR 0 1
39481: ARRAY
39482: PPUSH
39483: LD_INT 30
39485: PUSH
39486: LD_INT 3
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: PPUSH
39493: CALL_OW 72
39497: NOT
39498: AND
39499: IFFALSE 39713
// begin if sci >= 6 then
39501: LD_VAR 0 8
39505: PUSH
39506: LD_INT 6
39508: GREATEREQUAL
39509: IFFALSE 39513
// exit ;
39511: GO 41932
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39513: LD_ADDR_EXP 141
39517: PUSH
39518: LD_EXP 141
39522: PPUSH
39523: LD_VAR 0 1
39527: PPUSH
39528: LD_INT 2
39530: PPUSH
39531: CALL_OW 1
39535: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39536: LD_ADDR_VAR 0 9
39540: PUSH
39541: LD_VAR 0 4
39545: PUSH
39546: LD_VAR 0 8
39550: DIFF
39551: PPUSH
39552: LD_INT 4
39554: PPUSH
39555: CALL 103897 0 2
39559: ST_TO_ADDR
// p := [ ] ;
39560: LD_ADDR_VAR 0 11
39564: PUSH
39565: EMPTY
39566: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39567: LD_VAR 0 8
39571: PUSH
39572: LD_INT 6
39574: LESS
39575: PUSH
39576: LD_VAR 0 9
39580: PUSH
39581: LD_INT 6
39583: GREATER
39584: AND
39585: IFFALSE 39666
// begin for i = 1 to 6 - sci do
39587: LD_ADDR_VAR 0 3
39591: PUSH
39592: DOUBLE
39593: LD_INT 1
39595: DEC
39596: ST_TO_ADDR
39597: LD_INT 6
39599: PUSH
39600: LD_VAR 0 8
39604: MINUS
39605: PUSH
39606: FOR_TO
39607: IFFALSE 39662
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39609: LD_ADDR_VAR 0 11
39613: PUSH
39614: LD_VAR 0 11
39618: PPUSH
39619: LD_VAR 0 11
39623: PUSH
39624: LD_INT 1
39626: PLUS
39627: PPUSH
39628: LD_VAR 0 9
39632: PUSH
39633: LD_INT 1
39635: ARRAY
39636: PPUSH
39637: CALL_OW 2
39641: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39642: LD_ADDR_VAR 0 9
39646: PUSH
39647: LD_VAR 0 9
39651: PPUSH
39652: LD_INT 1
39654: PPUSH
39655: CALL_OW 3
39659: ST_TO_ADDR
// end ;
39660: GO 39606
39662: POP
39663: POP
// end else
39664: GO 39686
// if sort then
39666: LD_VAR 0 9
39670: IFFALSE 39686
// p := sort [ 1 ] ;
39672: LD_ADDR_VAR 0 11
39676: PUSH
39677: LD_VAR 0 9
39681: PUSH
39682: LD_INT 1
39684: ARRAY
39685: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39686: LD_ADDR_VAR 0 2
39690: PUSH
39691: LD_INT 0
39693: PUSH
39694: LD_INT 0
39696: PUSH
39697: LD_INT 0
39699: PUSH
39700: LD_VAR 0 11
39704: PUSH
39705: EMPTY
39706: LIST
39707: LIST
39708: LIST
39709: LIST
39710: ST_TO_ADDR
// exit ;
39711: GO 41932
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39713: LD_EXP 126
39717: PUSH
39718: LD_EXP 125
39722: PUSH
39723: LD_VAR 0 1
39727: ARRAY
39728: ARRAY
39729: PUSH
39730: LD_EXP 99
39734: PUSH
39735: LD_VAR 0 1
39739: ARRAY
39740: PPUSH
39741: LD_INT 2
39743: PUSH
39744: LD_INT 30
39746: PUSH
39747: LD_INT 6
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: PUSH
39754: LD_INT 30
39756: PUSH
39757: LD_INT 7
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: LD_INT 30
39766: PUSH
39767: LD_INT 8
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: EMPTY
39775: LIST
39776: LIST
39777: LIST
39778: LIST
39779: PPUSH
39780: CALL_OW 72
39784: AND
39785: PUSH
39786: LD_EXP 99
39790: PUSH
39791: LD_VAR 0 1
39795: ARRAY
39796: PPUSH
39797: LD_INT 30
39799: PUSH
39800: LD_INT 3
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PPUSH
39807: CALL_OW 72
39811: AND
39812: IFFALSE 40546
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
39814: LD_ADDR_EXP 141
39818: PUSH
39819: LD_EXP 141
39823: PPUSH
39824: LD_VAR 0 1
39828: PPUSH
39829: LD_INT 3
39831: PPUSH
39832: CALL_OW 1
39836: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
39837: LD_ADDR_VAR 0 2
39841: PUSH
39842: LD_INT 0
39844: PUSH
39845: LD_INT 0
39847: PUSH
39848: LD_INT 0
39850: PUSH
39851: LD_INT 0
39853: PUSH
39854: EMPTY
39855: LIST
39856: LIST
39857: LIST
39858: LIST
39859: ST_TO_ADDR
// if not eng then
39860: LD_VAR 0 6
39864: NOT
39865: IFFALSE 39928
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
39867: LD_ADDR_VAR 0 11
39871: PUSH
39872: LD_VAR 0 4
39876: PPUSH
39877: LD_INT 2
39879: PPUSH
39880: CALL 103897 0 2
39884: PUSH
39885: LD_INT 1
39887: ARRAY
39888: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
39889: LD_ADDR_VAR 0 2
39893: PUSH
39894: LD_VAR 0 2
39898: PPUSH
39899: LD_INT 2
39901: PPUSH
39902: LD_VAR 0 11
39906: PPUSH
39907: CALL_OW 1
39911: ST_TO_ADDR
// tmp := tmp diff p ;
39912: LD_ADDR_VAR 0 4
39916: PUSH
39917: LD_VAR 0 4
39921: PUSH
39922: LD_VAR 0 11
39926: DIFF
39927: ST_TO_ADDR
// end ; if tmp and sci < 6 then
39928: LD_VAR 0 4
39932: PUSH
39933: LD_VAR 0 8
39937: PUSH
39938: LD_INT 6
39940: LESS
39941: AND
39942: IFFALSE 40130
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
39944: LD_ADDR_VAR 0 9
39948: PUSH
39949: LD_VAR 0 4
39953: PUSH
39954: LD_VAR 0 8
39958: PUSH
39959: LD_VAR 0 7
39963: UNION
39964: DIFF
39965: PPUSH
39966: LD_INT 4
39968: PPUSH
39969: CALL 103897 0 2
39973: ST_TO_ADDR
// p := [ ] ;
39974: LD_ADDR_VAR 0 11
39978: PUSH
39979: EMPTY
39980: ST_TO_ADDR
// if sort then
39981: LD_VAR 0 9
39985: IFFALSE 40101
// for i = 1 to 6 - sci do
39987: LD_ADDR_VAR 0 3
39991: PUSH
39992: DOUBLE
39993: LD_INT 1
39995: DEC
39996: ST_TO_ADDR
39997: LD_INT 6
39999: PUSH
40000: LD_VAR 0 8
40004: MINUS
40005: PUSH
40006: FOR_TO
40007: IFFALSE 40099
// begin if i = sort then
40009: LD_VAR 0 3
40013: PUSH
40014: LD_VAR 0 9
40018: EQUAL
40019: IFFALSE 40023
// break ;
40021: GO 40099
// if GetClass ( i ) = 4 then
40023: LD_VAR 0 3
40027: PPUSH
40028: CALL_OW 257
40032: PUSH
40033: LD_INT 4
40035: EQUAL
40036: IFFALSE 40040
// continue ;
40038: GO 40006
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40040: LD_ADDR_VAR 0 11
40044: PUSH
40045: LD_VAR 0 11
40049: PPUSH
40050: LD_VAR 0 11
40054: PUSH
40055: LD_INT 1
40057: PLUS
40058: PPUSH
40059: LD_VAR 0 9
40063: PUSH
40064: LD_VAR 0 3
40068: ARRAY
40069: PPUSH
40070: CALL_OW 2
40074: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40075: LD_ADDR_VAR 0 4
40079: PUSH
40080: LD_VAR 0 4
40084: PUSH
40085: LD_VAR 0 9
40089: PUSH
40090: LD_VAR 0 3
40094: ARRAY
40095: DIFF
40096: ST_TO_ADDR
// end ;
40097: GO 40006
40099: POP
40100: POP
// if p then
40101: LD_VAR 0 11
40105: IFFALSE 40130
// result := Replace ( result , 4 , p ) ;
40107: LD_ADDR_VAR 0 2
40111: PUSH
40112: LD_VAR 0 2
40116: PPUSH
40117: LD_INT 4
40119: PPUSH
40120: LD_VAR 0 11
40124: PPUSH
40125: CALL_OW 1
40129: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40130: LD_VAR 0 4
40134: PUSH
40135: LD_VAR 0 7
40139: PUSH
40140: LD_INT 6
40142: LESS
40143: AND
40144: IFFALSE 40332
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40146: LD_ADDR_VAR 0 9
40150: PUSH
40151: LD_VAR 0 4
40155: PUSH
40156: LD_VAR 0 8
40160: PUSH
40161: LD_VAR 0 7
40165: UNION
40166: DIFF
40167: PPUSH
40168: LD_INT 3
40170: PPUSH
40171: CALL 103897 0 2
40175: ST_TO_ADDR
// p := [ ] ;
40176: LD_ADDR_VAR 0 11
40180: PUSH
40181: EMPTY
40182: ST_TO_ADDR
// if sort then
40183: LD_VAR 0 9
40187: IFFALSE 40303
// for i = 1 to 6 - mech do
40189: LD_ADDR_VAR 0 3
40193: PUSH
40194: DOUBLE
40195: LD_INT 1
40197: DEC
40198: ST_TO_ADDR
40199: LD_INT 6
40201: PUSH
40202: LD_VAR 0 7
40206: MINUS
40207: PUSH
40208: FOR_TO
40209: IFFALSE 40301
// begin if i = sort then
40211: LD_VAR 0 3
40215: PUSH
40216: LD_VAR 0 9
40220: EQUAL
40221: IFFALSE 40225
// break ;
40223: GO 40301
// if GetClass ( i ) = 3 then
40225: LD_VAR 0 3
40229: PPUSH
40230: CALL_OW 257
40234: PUSH
40235: LD_INT 3
40237: EQUAL
40238: IFFALSE 40242
// continue ;
40240: GO 40208
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40242: LD_ADDR_VAR 0 11
40246: PUSH
40247: LD_VAR 0 11
40251: PPUSH
40252: LD_VAR 0 11
40256: PUSH
40257: LD_INT 1
40259: PLUS
40260: PPUSH
40261: LD_VAR 0 9
40265: PUSH
40266: LD_VAR 0 3
40270: ARRAY
40271: PPUSH
40272: CALL_OW 2
40276: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40277: LD_ADDR_VAR 0 4
40281: PUSH
40282: LD_VAR 0 4
40286: PUSH
40287: LD_VAR 0 9
40291: PUSH
40292: LD_VAR 0 3
40296: ARRAY
40297: DIFF
40298: ST_TO_ADDR
// end ;
40299: GO 40208
40301: POP
40302: POP
// if p then
40303: LD_VAR 0 11
40307: IFFALSE 40332
// result := Replace ( result , 3 , p ) ;
40309: LD_ADDR_VAR 0 2
40313: PUSH
40314: LD_VAR 0 2
40318: PPUSH
40319: LD_INT 3
40321: PPUSH
40322: LD_VAR 0 11
40326: PPUSH
40327: CALL_OW 1
40331: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40332: LD_VAR 0 4
40336: PUSH
40337: LD_INT 6
40339: GREATER
40340: PUSH
40341: LD_VAR 0 6
40345: PUSH
40346: LD_INT 6
40348: LESS
40349: AND
40350: IFFALSE 40544
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40352: LD_ADDR_VAR 0 9
40356: PUSH
40357: LD_VAR 0 4
40361: PUSH
40362: LD_VAR 0 8
40366: PUSH
40367: LD_VAR 0 7
40371: UNION
40372: PUSH
40373: LD_VAR 0 6
40377: UNION
40378: DIFF
40379: PPUSH
40380: LD_INT 2
40382: PPUSH
40383: CALL 103897 0 2
40387: ST_TO_ADDR
// p := [ ] ;
40388: LD_ADDR_VAR 0 11
40392: PUSH
40393: EMPTY
40394: ST_TO_ADDR
// if sort then
40395: LD_VAR 0 9
40399: IFFALSE 40515
// for i = 1 to 6 - eng do
40401: LD_ADDR_VAR 0 3
40405: PUSH
40406: DOUBLE
40407: LD_INT 1
40409: DEC
40410: ST_TO_ADDR
40411: LD_INT 6
40413: PUSH
40414: LD_VAR 0 6
40418: MINUS
40419: PUSH
40420: FOR_TO
40421: IFFALSE 40513
// begin if i = sort then
40423: LD_VAR 0 3
40427: PUSH
40428: LD_VAR 0 9
40432: EQUAL
40433: IFFALSE 40437
// break ;
40435: GO 40513
// if GetClass ( i ) = 2 then
40437: LD_VAR 0 3
40441: PPUSH
40442: CALL_OW 257
40446: PUSH
40447: LD_INT 2
40449: EQUAL
40450: IFFALSE 40454
// continue ;
40452: GO 40420
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40454: LD_ADDR_VAR 0 11
40458: PUSH
40459: LD_VAR 0 11
40463: PPUSH
40464: LD_VAR 0 11
40468: PUSH
40469: LD_INT 1
40471: PLUS
40472: PPUSH
40473: LD_VAR 0 9
40477: PUSH
40478: LD_VAR 0 3
40482: ARRAY
40483: PPUSH
40484: CALL_OW 2
40488: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40489: LD_ADDR_VAR 0 4
40493: PUSH
40494: LD_VAR 0 4
40498: PUSH
40499: LD_VAR 0 9
40503: PUSH
40504: LD_VAR 0 3
40508: ARRAY
40509: DIFF
40510: ST_TO_ADDR
// end ;
40511: GO 40420
40513: POP
40514: POP
// if p then
40515: LD_VAR 0 11
40519: IFFALSE 40544
// result := Replace ( result , 2 , p ) ;
40521: LD_ADDR_VAR 0 2
40525: PUSH
40526: LD_VAR 0 2
40530: PPUSH
40531: LD_INT 2
40533: PPUSH
40534: LD_VAR 0 11
40538: PPUSH
40539: CALL_OW 1
40543: ST_TO_ADDR
// end ; exit ;
40544: GO 41932
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40546: LD_EXP 126
40550: PUSH
40551: LD_EXP 125
40555: PUSH
40556: LD_VAR 0 1
40560: ARRAY
40561: ARRAY
40562: NOT
40563: PUSH
40564: LD_EXP 99
40568: PUSH
40569: LD_VAR 0 1
40573: ARRAY
40574: PPUSH
40575: LD_INT 30
40577: PUSH
40578: LD_INT 3
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PPUSH
40585: CALL_OW 72
40589: AND
40590: PUSH
40591: LD_EXP 104
40595: PUSH
40596: LD_VAR 0 1
40600: ARRAY
40601: AND
40602: IFFALSE 41210
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40604: LD_ADDR_EXP 141
40608: PUSH
40609: LD_EXP 141
40613: PPUSH
40614: LD_VAR 0 1
40618: PPUSH
40619: LD_INT 5
40621: PPUSH
40622: CALL_OW 1
40626: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40627: LD_ADDR_VAR 0 2
40631: PUSH
40632: LD_INT 0
40634: PUSH
40635: LD_INT 0
40637: PUSH
40638: LD_INT 0
40640: PUSH
40641: LD_INT 0
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: LIST
40648: LIST
40649: ST_TO_ADDR
// if sci > 1 then
40650: LD_VAR 0 8
40654: PUSH
40655: LD_INT 1
40657: GREATER
40658: IFFALSE 40686
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40660: LD_ADDR_VAR 0 4
40664: PUSH
40665: LD_VAR 0 4
40669: PUSH
40670: LD_VAR 0 8
40674: PUSH
40675: LD_VAR 0 8
40679: PUSH
40680: LD_INT 1
40682: ARRAY
40683: DIFF
40684: DIFF
40685: ST_TO_ADDR
// if tmp and not sci then
40686: LD_VAR 0 4
40690: PUSH
40691: LD_VAR 0 8
40695: NOT
40696: AND
40697: IFFALSE 40766
// begin sort := SortBySkill ( tmp , 4 ) ;
40699: LD_ADDR_VAR 0 9
40703: PUSH
40704: LD_VAR 0 4
40708: PPUSH
40709: LD_INT 4
40711: PPUSH
40712: CALL 103897 0 2
40716: ST_TO_ADDR
// if sort then
40717: LD_VAR 0 9
40721: IFFALSE 40737
// p := sort [ 1 ] ;
40723: LD_ADDR_VAR 0 11
40727: PUSH
40728: LD_VAR 0 9
40732: PUSH
40733: LD_INT 1
40735: ARRAY
40736: ST_TO_ADDR
// if p then
40737: LD_VAR 0 11
40741: IFFALSE 40766
// result := Replace ( result , 4 , p ) ;
40743: LD_ADDR_VAR 0 2
40747: PUSH
40748: LD_VAR 0 2
40752: PPUSH
40753: LD_INT 4
40755: PPUSH
40756: LD_VAR 0 11
40760: PPUSH
40761: CALL_OW 1
40765: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40766: LD_ADDR_VAR 0 4
40770: PUSH
40771: LD_VAR 0 4
40775: PUSH
40776: LD_VAR 0 7
40780: DIFF
40781: ST_TO_ADDR
// if tmp and mech < 6 then
40782: LD_VAR 0 4
40786: PUSH
40787: LD_VAR 0 7
40791: PUSH
40792: LD_INT 6
40794: LESS
40795: AND
40796: IFFALSE 40984
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40798: LD_ADDR_VAR 0 9
40802: PUSH
40803: LD_VAR 0 4
40807: PUSH
40808: LD_VAR 0 8
40812: PUSH
40813: LD_VAR 0 7
40817: UNION
40818: DIFF
40819: PPUSH
40820: LD_INT 3
40822: PPUSH
40823: CALL 103897 0 2
40827: ST_TO_ADDR
// p := [ ] ;
40828: LD_ADDR_VAR 0 11
40832: PUSH
40833: EMPTY
40834: ST_TO_ADDR
// if sort then
40835: LD_VAR 0 9
40839: IFFALSE 40955
// for i = 1 to 6 - mech do
40841: LD_ADDR_VAR 0 3
40845: PUSH
40846: DOUBLE
40847: LD_INT 1
40849: DEC
40850: ST_TO_ADDR
40851: LD_INT 6
40853: PUSH
40854: LD_VAR 0 7
40858: MINUS
40859: PUSH
40860: FOR_TO
40861: IFFALSE 40953
// begin if i = sort then
40863: LD_VAR 0 3
40867: PUSH
40868: LD_VAR 0 9
40872: EQUAL
40873: IFFALSE 40877
// break ;
40875: GO 40953
// if GetClass ( i ) = 3 then
40877: LD_VAR 0 3
40881: PPUSH
40882: CALL_OW 257
40886: PUSH
40887: LD_INT 3
40889: EQUAL
40890: IFFALSE 40894
// continue ;
40892: GO 40860
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40894: LD_ADDR_VAR 0 11
40898: PUSH
40899: LD_VAR 0 11
40903: PPUSH
40904: LD_VAR 0 11
40908: PUSH
40909: LD_INT 1
40911: PLUS
40912: PPUSH
40913: LD_VAR 0 9
40917: PUSH
40918: LD_VAR 0 3
40922: ARRAY
40923: PPUSH
40924: CALL_OW 2
40928: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40929: LD_ADDR_VAR 0 4
40933: PUSH
40934: LD_VAR 0 4
40938: PUSH
40939: LD_VAR 0 9
40943: PUSH
40944: LD_VAR 0 3
40948: ARRAY
40949: DIFF
40950: ST_TO_ADDR
// end ;
40951: GO 40860
40953: POP
40954: POP
// if p then
40955: LD_VAR 0 11
40959: IFFALSE 40984
// result := Replace ( result , 3 , p ) ;
40961: LD_ADDR_VAR 0 2
40965: PUSH
40966: LD_VAR 0 2
40970: PPUSH
40971: LD_INT 3
40973: PPUSH
40974: LD_VAR 0 11
40978: PPUSH
40979: CALL_OW 1
40983: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
40984: LD_ADDR_VAR 0 4
40988: PUSH
40989: LD_VAR 0 4
40993: PUSH
40994: LD_VAR 0 6
40998: DIFF
40999: ST_TO_ADDR
// if tmp and eng < 6 then
41000: LD_VAR 0 4
41004: PUSH
41005: LD_VAR 0 6
41009: PUSH
41010: LD_INT 6
41012: LESS
41013: AND
41014: IFFALSE 41208
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41016: LD_ADDR_VAR 0 9
41020: PUSH
41021: LD_VAR 0 4
41025: PUSH
41026: LD_VAR 0 8
41030: PUSH
41031: LD_VAR 0 7
41035: UNION
41036: PUSH
41037: LD_VAR 0 6
41041: UNION
41042: DIFF
41043: PPUSH
41044: LD_INT 2
41046: PPUSH
41047: CALL 103897 0 2
41051: ST_TO_ADDR
// p := [ ] ;
41052: LD_ADDR_VAR 0 11
41056: PUSH
41057: EMPTY
41058: ST_TO_ADDR
// if sort then
41059: LD_VAR 0 9
41063: IFFALSE 41179
// for i = 1 to 6 - eng do
41065: LD_ADDR_VAR 0 3
41069: PUSH
41070: DOUBLE
41071: LD_INT 1
41073: DEC
41074: ST_TO_ADDR
41075: LD_INT 6
41077: PUSH
41078: LD_VAR 0 6
41082: MINUS
41083: PUSH
41084: FOR_TO
41085: IFFALSE 41177
// begin if i = sort then
41087: LD_VAR 0 3
41091: PUSH
41092: LD_VAR 0 9
41096: EQUAL
41097: IFFALSE 41101
// break ;
41099: GO 41177
// if GetClass ( i ) = 2 then
41101: LD_VAR 0 3
41105: PPUSH
41106: CALL_OW 257
41110: PUSH
41111: LD_INT 2
41113: EQUAL
41114: IFFALSE 41118
// continue ;
41116: GO 41084
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41118: LD_ADDR_VAR 0 11
41122: PUSH
41123: LD_VAR 0 11
41127: PPUSH
41128: LD_VAR 0 11
41132: PUSH
41133: LD_INT 1
41135: PLUS
41136: PPUSH
41137: LD_VAR 0 9
41141: PUSH
41142: LD_VAR 0 3
41146: ARRAY
41147: PPUSH
41148: CALL_OW 2
41152: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41153: LD_ADDR_VAR 0 4
41157: PUSH
41158: LD_VAR 0 4
41162: PUSH
41163: LD_VAR 0 9
41167: PUSH
41168: LD_VAR 0 3
41172: ARRAY
41173: DIFF
41174: ST_TO_ADDR
// end ;
41175: GO 41084
41177: POP
41178: POP
// if p then
41179: LD_VAR 0 11
41183: IFFALSE 41208
// result := Replace ( result , 2 , p ) ;
41185: LD_ADDR_VAR 0 2
41189: PUSH
41190: LD_VAR 0 2
41194: PPUSH
41195: LD_INT 2
41197: PPUSH
41198: LD_VAR 0 11
41202: PPUSH
41203: CALL_OW 1
41207: ST_TO_ADDR
// end ; exit ;
41208: GO 41932
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41210: LD_EXP 126
41214: PUSH
41215: LD_EXP 125
41219: PUSH
41220: LD_VAR 0 1
41224: ARRAY
41225: ARRAY
41226: NOT
41227: PUSH
41228: LD_EXP 99
41232: PUSH
41233: LD_VAR 0 1
41237: ARRAY
41238: PPUSH
41239: LD_INT 30
41241: PUSH
41242: LD_INT 3
41244: PUSH
41245: EMPTY
41246: LIST
41247: LIST
41248: PPUSH
41249: CALL_OW 72
41253: AND
41254: PUSH
41255: LD_EXP 104
41259: PUSH
41260: LD_VAR 0 1
41264: ARRAY
41265: NOT
41266: AND
41267: IFFALSE 41932
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41269: LD_ADDR_EXP 141
41273: PUSH
41274: LD_EXP 141
41278: PPUSH
41279: LD_VAR 0 1
41283: PPUSH
41284: LD_INT 6
41286: PPUSH
41287: CALL_OW 1
41291: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41292: LD_ADDR_VAR 0 2
41296: PUSH
41297: LD_INT 0
41299: PUSH
41300: LD_INT 0
41302: PUSH
41303: LD_INT 0
41305: PUSH
41306: LD_INT 0
41308: PUSH
41309: EMPTY
41310: LIST
41311: LIST
41312: LIST
41313: LIST
41314: ST_TO_ADDR
// if sci >= 1 then
41315: LD_VAR 0 8
41319: PUSH
41320: LD_INT 1
41322: GREATEREQUAL
41323: IFFALSE 41345
// tmp := tmp diff sci [ 1 ] ;
41325: LD_ADDR_VAR 0 4
41329: PUSH
41330: LD_VAR 0 4
41334: PUSH
41335: LD_VAR 0 8
41339: PUSH
41340: LD_INT 1
41342: ARRAY
41343: DIFF
41344: ST_TO_ADDR
// if tmp and not sci then
41345: LD_VAR 0 4
41349: PUSH
41350: LD_VAR 0 8
41354: NOT
41355: AND
41356: IFFALSE 41425
// begin sort := SortBySkill ( tmp , 4 ) ;
41358: LD_ADDR_VAR 0 9
41362: PUSH
41363: LD_VAR 0 4
41367: PPUSH
41368: LD_INT 4
41370: PPUSH
41371: CALL 103897 0 2
41375: ST_TO_ADDR
// if sort then
41376: LD_VAR 0 9
41380: IFFALSE 41396
// p := sort [ 1 ] ;
41382: LD_ADDR_VAR 0 11
41386: PUSH
41387: LD_VAR 0 9
41391: PUSH
41392: LD_INT 1
41394: ARRAY
41395: ST_TO_ADDR
// if p then
41396: LD_VAR 0 11
41400: IFFALSE 41425
// result := Replace ( result , 4 , p ) ;
41402: LD_ADDR_VAR 0 2
41406: PUSH
41407: LD_VAR 0 2
41411: PPUSH
41412: LD_INT 4
41414: PPUSH
41415: LD_VAR 0 11
41419: PPUSH
41420: CALL_OW 1
41424: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41425: LD_ADDR_VAR 0 4
41429: PUSH
41430: LD_VAR 0 4
41434: PUSH
41435: LD_VAR 0 7
41439: DIFF
41440: ST_TO_ADDR
// if tmp and mech < 6 then
41441: LD_VAR 0 4
41445: PUSH
41446: LD_VAR 0 7
41450: PUSH
41451: LD_INT 6
41453: LESS
41454: AND
41455: IFFALSE 41637
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41457: LD_ADDR_VAR 0 9
41461: PUSH
41462: LD_VAR 0 4
41466: PUSH
41467: LD_VAR 0 7
41471: DIFF
41472: PPUSH
41473: LD_INT 3
41475: PPUSH
41476: CALL 103897 0 2
41480: ST_TO_ADDR
// p := [ ] ;
41481: LD_ADDR_VAR 0 11
41485: PUSH
41486: EMPTY
41487: ST_TO_ADDR
// if sort then
41488: LD_VAR 0 9
41492: IFFALSE 41608
// for i = 1 to 6 - mech do
41494: LD_ADDR_VAR 0 3
41498: PUSH
41499: DOUBLE
41500: LD_INT 1
41502: DEC
41503: ST_TO_ADDR
41504: LD_INT 6
41506: PUSH
41507: LD_VAR 0 7
41511: MINUS
41512: PUSH
41513: FOR_TO
41514: IFFALSE 41606
// begin if i = sort then
41516: LD_VAR 0 3
41520: PUSH
41521: LD_VAR 0 9
41525: EQUAL
41526: IFFALSE 41530
// break ;
41528: GO 41606
// if GetClass ( i ) = 3 then
41530: LD_VAR 0 3
41534: PPUSH
41535: CALL_OW 257
41539: PUSH
41540: LD_INT 3
41542: EQUAL
41543: IFFALSE 41547
// continue ;
41545: GO 41513
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41547: LD_ADDR_VAR 0 11
41551: PUSH
41552: LD_VAR 0 11
41556: PPUSH
41557: LD_VAR 0 11
41561: PUSH
41562: LD_INT 1
41564: PLUS
41565: PPUSH
41566: LD_VAR 0 9
41570: PUSH
41571: LD_VAR 0 3
41575: ARRAY
41576: PPUSH
41577: CALL_OW 2
41581: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41582: LD_ADDR_VAR 0 4
41586: PUSH
41587: LD_VAR 0 4
41591: PUSH
41592: LD_VAR 0 9
41596: PUSH
41597: LD_VAR 0 3
41601: ARRAY
41602: DIFF
41603: ST_TO_ADDR
// end ;
41604: GO 41513
41606: POP
41607: POP
// if p then
41608: LD_VAR 0 11
41612: IFFALSE 41637
// result := Replace ( result , 3 , p ) ;
41614: LD_ADDR_VAR 0 2
41618: PUSH
41619: LD_VAR 0 2
41623: PPUSH
41624: LD_INT 3
41626: PPUSH
41627: LD_VAR 0 11
41631: PPUSH
41632: CALL_OW 1
41636: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41637: LD_ADDR_VAR 0 4
41641: PUSH
41642: LD_VAR 0 4
41646: PUSH
41647: LD_VAR 0 6
41651: DIFF
41652: ST_TO_ADDR
// if tmp and eng < 4 then
41653: LD_VAR 0 4
41657: PUSH
41658: LD_VAR 0 6
41662: PUSH
41663: LD_INT 4
41665: LESS
41666: AND
41667: IFFALSE 41857
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41669: LD_ADDR_VAR 0 9
41673: PUSH
41674: LD_VAR 0 4
41678: PUSH
41679: LD_VAR 0 7
41683: PUSH
41684: LD_VAR 0 6
41688: UNION
41689: DIFF
41690: PPUSH
41691: LD_INT 2
41693: PPUSH
41694: CALL 103897 0 2
41698: ST_TO_ADDR
// p := [ ] ;
41699: LD_ADDR_VAR 0 11
41703: PUSH
41704: EMPTY
41705: ST_TO_ADDR
// if sort then
41706: LD_VAR 0 9
41710: IFFALSE 41826
// for i = 1 to 4 - eng do
41712: LD_ADDR_VAR 0 3
41716: PUSH
41717: DOUBLE
41718: LD_INT 1
41720: DEC
41721: ST_TO_ADDR
41722: LD_INT 4
41724: PUSH
41725: LD_VAR 0 6
41729: MINUS
41730: PUSH
41731: FOR_TO
41732: IFFALSE 41824
// begin if i = sort then
41734: LD_VAR 0 3
41738: PUSH
41739: LD_VAR 0 9
41743: EQUAL
41744: IFFALSE 41748
// break ;
41746: GO 41824
// if GetClass ( i ) = 2 then
41748: LD_VAR 0 3
41752: PPUSH
41753: CALL_OW 257
41757: PUSH
41758: LD_INT 2
41760: EQUAL
41761: IFFALSE 41765
// continue ;
41763: GO 41731
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41765: LD_ADDR_VAR 0 11
41769: PUSH
41770: LD_VAR 0 11
41774: PPUSH
41775: LD_VAR 0 11
41779: PUSH
41780: LD_INT 1
41782: PLUS
41783: PPUSH
41784: LD_VAR 0 9
41788: PUSH
41789: LD_VAR 0 3
41793: ARRAY
41794: PPUSH
41795: CALL_OW 2
41799: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41800: LD_ADDR_VAR 0 4
41804: PUSH
41805: LD_VAR 0 4
41809: PUSH
41810: LD_VAR 0 9
41814: PUSH
41815: LD_VAR 0 3
41819: ARRAY
41820: DIFF
41821: ST_TO_ADDR
// end ;
41822: GO 41731
41824: POP
41825: POP
// if p then
41826: LD_VAR 0 11
41830: IFFALSE 41855
// result := Replace ( result , 2 , p ) ;
41832: LD_ADDR_VAR 0 2
41836: PUSH
41837: LD_VAR 0 2
41841: PPUSH
41842: LD_INT 2
41844: PPUSH
41845: LD_VAR 0 11
41849: PPUSH
41850: CALL_OW 1
41854: ST_TO_ADDR
// end else
41855: GO 41901
// for i = eng downto 5 do
41857: LD_ADDR_VAR 0 3
41861: PUSH
41862: DOUBLE
41863: LD_VAR 0 6
41867: INC
41868: ST_TO_ADDR
41869: LD_INT 5
41871: PUSH
41872: FOR_DOWNTO
41873: IFFALSE 41899
// tmp := tmp union eng [ i ] ;
41875: LD_ADDR_VAR 0 4
41879: PUSH
41880: LD_VAR 0 4
41884: PUSH
41885: LD_VAR 0 6
41889: PUSH
41890: LD_VAR 0 3
41894: ARRAY
41895: UNION
41896: ST_TO_ADDR
41897: GO 41872
41899: POP
41900: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
41901: LD_ADDR_VAR 0 2
41905: PUSH
41906: LD_VAR 0 2
41910: PPUSH
41911: LD_INT 1
41913: PPUSH
41914: LD_VAR 0 4
41918: PUSH
41919: LD_VAR 0 5
41923: DIFF
41924: PPUSH
41925: CALL_OW 1
41929: ST_TO_ADDR
// exit ;
41930: GO 41932
// end ; end ;
41932: LD_VAR 0 2
41936: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
41937: LD_INT 0
41939: PPUSH
41940: PPUSH
41941: PPUSH
// if not mc_bases then
41942: LD_EXP 99
41946: NOT
41947: IFFALSE 41951
// exit ;
41949: GO 42057
// for i = 1 to mc_bases do
41951: LD_ADDR_VAR 0 2
41955: PUSH
41956: DOUBLE
41957: LD_INT 1
41959: DEC
41960: ST_TO_ADDR
41961: LD_EXP 99
41965: PUSH
41966: FOR_TO
41967: IFFALSE 42048
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
41969: LD_ADDR_VAR 0 3
41973: PUSH
41974: LD_EXP 99
41978: PUSH
41979: LD_VAR 0 2
41983: ARRAY
41984: PPUSH
41985: LD_INT 21
41987: PUSH
41988: LD_INT 3
41990: PUSH
41991: EMPTY
41992: LIST
41993: LIST
41994: PUSH
41995: LD_INT 3
41997: PUSH
41998: LD_INT 24
42000: PUSH
42001: LD_INT 1000
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PUSH
42008: EMPTY
42009: LIST
42010: LIST
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PPUSH
42016: CALL_OW 72
42020: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42021: LD_ADDR_EXP 100
42025: PUSH
42026: LD_EXP 100
42030: PPUSH
42031: LD_VAR 0 2
42035: PPUSH
42036: LD_VAR 0 3
42040: PPUSH
42041: CALL_OW 1
42045: ST_TO_ADDR
// end ;
42046: GO 41966
42048: POP
42049: POP
// RaiseSailEvent ( 101 ) ;
42050: LD_INT 101
42052: PPUSH
42053: CALL_OW 427
// end ;
42057: LD_VAR 0 1
42061: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42062: LD_INT 0
42064: PPUSH
42065: PPUSH
42066: PPUSH
42067: PPUSH
42068: PPUSH
42069: PPUSH
42070: PPUSH
// if not mc_bases then
42071: LD_EXP 99
42075: NOT
42076: IFFALSE 42080
// exit ;
42078: GO 42653
// for i = 1 to mc_bases do
42080: LD_ADDR_VAR 0 2
42084: PUSH
42085: DOUBLE
42086: LD_INT 1
42088: DEC
42089: ST_TO_ADDR
42090: LD_EXP 99
42094: PUSH
42095: FOR_TO
42096: IFFALSE 42644
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42098: LD_ADDR_VAR 0 5
42102: PUSH
42103: LD_EXP 99
42107: PUSH
42108: LD_VAR 0 2
42112: ARRAY
42113: PUSH
42114: LD_EXP 128
42118: PUSH
42119: LD_VAR 0 2
42123: ARRAY
42124: UNION
42125: PPUSH
42126: LD_INT 21
42128: PUSH
42129: LD_INT 1
42131: PUSH
42132: EMPTY
42133: LIST
42134: LIST
42135: PUSH
42136: LD_INT 1
42138: PUSH
42139: LD_INT 3
42141: PUSH
42142: LD_INT 54
42144: PUSH
42145: EMPTY
42146: LIST
42147: PUSH
42148: EMPTY
42149: LIST
42150: LIST
42151: PUSH
42152: LD_INT 3
42154: PUSH
42155: LD_INT 24
42157: PUSH
42158: LD_INT 800
42160: PUSH
42161: EMPTY
42162: LIST
42163: LIST
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: EMPTY
42170: LIST
42171: LIST
42172: LIST
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PPUSH
42178: CALL_OW 72
42182: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42183: LD_ADDR_VAR 0 6
42187: PUSH
42188: LD_EXP 99
42192: PUSH
42193: LD_VAR 0 2
42197: ARRAY
42198: PPUSH
42199: LD_INT 21
42201: PUSH
42202: LD_INT 1
42204: PUSH
42205: EMPTY
42206: LIST
42207: LIST
42208: PUSH
42209: LD_INT 1
42211: PUSH
42212: LD_INT 3
42214: PUSH
42215: LD_INT 54
42217: PUSH
42218: EMPTY
42219: LIST
42220: PUSH
42221: EMPTY
42222: LIST
42223: LIST
42224: PUSH
42225: LD_INT 3
42227: PUSH
42228: LD_INT 24
42230: PUSH
42231: LD_INT 250
42233: PUSH
42234: EMPTY
42235: LIST
42236: LIST
42237: PUSH
42238: EMPTY
42239: LIST
42240: LIST
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: LIST
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PPUSH
42251: CALL_OW 72
42255: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42256: LD_ADDR_VAR 0 7
42260: PUSH
42261: LD_VAR 0 5
42265: PUSH
42266: LD_VAR 0 6
42270: DIFF
42271: ST_TO_ADDR
// if not need_heal_1 then
42272: LD_VAR 0 6
42276: NOT
42277: IFFALSE 42310
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42279: LD_ADDR_EXP 102
42283: PUSH
42284: LD_EXP 102
42288: PPUSH
42289: LD_VAR 0 2
42293: PUSH
42294: LD_INT 1
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PPUSH
42301: EMPTY
42302: PPUSH
42303: CALL 69649 0 3
42307: ST_TO_ADDR
42308: GO 42380
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42310: LD_ADDR_EXP 102
42314: PUSH
42315: LD_EXP 102
42319: PPUSH
42320: LD_VAR 0 2
42324: PUSH
42325: LD_INT 1
42327: PUSH
42328: EMPTY
42329: LIST
42330: LIST
42331: PPUSH
42332: LD_EXP 102
42336: PUSH
42337: LD_VAR 0 2
42341: ARRAY
42342: PUSH
42343: LD_INT 1
42345: ARRAY
42346: PPUSH
42347: LD_INT 3
42349: PUSH
42350: LD_INT 24
42352: PUSH
42353: LD_INT 1000
42355: PUSH
42356: EMPTY
42357: LIST
42358: LIST
42359: PUSH
42360: EMPTY
42361: LIST
42362: LIST
42363: PPUSH
42364: CALL_OW 72
42368: PUSH
42369: LD_VAR 0 6
42373: UNION
42374: PPUSH
42375: CALL 69649 0 3
42379: ST_TO_ADDR
// if not need_heal_2 then
42380: LD_VAR 0 7
42384: NOT
42385: IFFALSE 42418
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42387: LD_ADDR_EXP 102
42391: PUSH
42392: LD_EXP 102
42396: PPUSH
42397: LD_VAR 0 2
42401: PUSH
42402: LD_INT 2
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PPUSH
42409: EMPTY
42410: PPUSH
42411: CALL 69649 0 3
42415: ST_TO_ADDR
42416: GO 42450
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42418: LD_ADDR_EXP 102
42422: PUSH
42423: LD_EXP 102
42427: PPUSH
42428: LD_VAR 0 2
42432: PUSH
42433: LD_INT 2
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PPUSH
42440: LD_VAR 0 7
42444: PPUSH
42445: CALL 69649 0 3
42449: ST_TO_ADDR
// if need_heal_2 then
42450: LD_VAR 0 7
42454: IFFALSE 42626
// for j in need_heal_2 do
42456: LD_ADDR_VAR 0 3
42460: PUSH
42461: LD_VAR 0 7
42465: PUSH
42466: FOR_IN
42467: IFFALSE 42624
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42469: LD_ADDR_VAR 0 5
42473: PUSH
42474: LD_EXP 99
42478: PUSH
42479: LD_VAR 0 2
42483: ARRAY
42484: PPUSH
42485: LD_INT 2
42487: PUSH
42488: LD_INT 30
42490: PUSH
42491: LD_INT 6
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: PUSH
42498: LD_INT 30
42500: PUSH
42501: LD_INT 7
42503: PUSH
42504: EMPTY
42505: LIST
42506: LIST
42507: PUSH
42508: LD_INT 30
42510: PUSH
42511: LD_INT 8
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 30
42520: PUSH
42521: LD_INT 0
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: PUSH
42528: LD_INT 30
42530: PUSH
42531: LD_INT 1
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 25
42540: PUSH
42541: LD_INT 4
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: EMPTY
42549: LIST
42550: LIST
42551: LIST
42552: LIST
42553: LIST
42554: LIST
42555: LIST
42556: PPUSH
42557: CALL_OW 72
42561: ST_TO_ADDR
// if tmp then
42562: LD_VAR 0 5
42566: IFFALSE 42622
// begin k := NearestUnitToUnit ( tmp , j ) ;
42568: LD_ADDR_VAR 0 4
42572: PUSH
42573: LD_VAR 0 5
42577: PPUSH
42578: LD_VAR 0 3
42582: PPUSH
42583: CALL_OW 74
42587: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42588: LD_VAR 0 3
42592: PPUSH
42593: LD_VAR 0 4
42597: PPUSH
42598: CALL_OW 296
42602: PUSH
42603: LD_INT 7
42605: GREATER
42606: IFFALSE 42622
// ComMoveUnit ( j , k ) ;
42608: LD_VAR 0 3
42612: PPUSH
42613: LD_VAR 0 4
42617: PPUSH
42618: CALL_OW 112
// end ; end ;
42622: GO 42466
42624: POP
42625: POP
// if not need_heal_1 and not need_heal_2 then
42626: LD_VAR 0 6
42630: NOT
42631: PUSH
42632: LD_VAR 0 7
42636: NOT
42637: AND
42638: IFFALSE 42642
// continue ;
42640: GO 42095
// end ;
42642: GO 42095
42644: POP
42645: POP
// RaiseSailEvent ( 102 ) ;
42646: LD_INT 102
42648: PPUSH
42649: CALL_OW 427
// end ;
42653: LD_VAR 0 1
42657: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp ; begin
42658: LD_INT 0
42660: PPUSH
42661: PPUSH
42662: PPUSH
42663: PPUSH
42664: PPUSH
// if not mc_bases then
42665: LD_EXP 99
42669: NOT
42670: IFFALSE 42674
// exit ;
42672: GO 43059
// for i = 1 to mc_bases do
42674: LD_ADDR_VAR 0 2
42678: PUSH
42679: DOUBLE
42680: LD_INT 1
42682: DEC
42683: ST_TO_ADDR
42684: LD_EXP 99
42688: PUSH
42689: FOR_TO
42690: IFFALSE 43057
// begin if not mc_building_need_repair [ i ] then
42692: LD_EXP 100
42696: PUSH
42697: LD_VAR 0 2
42701: ARRAY
42702: NOT
42703: IFFALSE 42741
// begin mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
42705: LD_ADDR_EXP 101
42709: PUSH
42710: LD_EXP 101
42714: PPUSH
42715: LD_VAR 0 2
42719: PPUSH
42720: EMPTY
42721: PPUSH
42722: CALL_OW 1
42726: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
42727: LD_VAR 0 2
42731: PPUSH
42732: LD_INT 101
42734: PPUSH
42735: CALL 37779 0 2
// continue ;
42739: GO 42689
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
42741: LD_ADDR_EXP 105
42745: PUSH
42746: LD_EXP 105
42750: PPUSH
42751: LD_VAR 0 2
42755: PPUSH
42756: EMPTY
42757: PPUSH
42758: CALL_OW 1
42762: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
42763: LD_VAR 0 2
42767: PPUSH
42768: LD_INT 103
42770: PPUSH
42771: CALL 37779 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
42775: LD_ADDR_VAR 0 5
42779: PUSH
42780: LD_EXP 99
42784: PUSH
42785: LD_VAR 0 2
42789: ARRAY
42790: PUSH
42791: LD_EXP 128
42795: PUSH
42796: LD_VAR 0 2
42800: ARRAY
42801: UNION
42802: PPUSH
42803: LD_INT 2
42805: PUSH
42806: LD_INT 25
42808: PUSH
42809: LD_INT 2
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: PUSH
42816: LD_INT 25
42818: PUSH
42819: LD_INT 16
42821: PUSH
42822: EMPTY
42823: LIST
42824: LIST
42825: PUSH
42826: EMPTY
42827: LIST
42828: LIST
42829: LIST
42830: PUSH
42831: EMPTY
42832: LIST
42833: PPUSH
42834: CALL_OW 72
42838: ST_TO_ADDR
// if not tmp then
42839: LD_VAR 0 5
42843: NOT
42844: IFFALSE 42848
// continue ;
42846: GO 42689
// for j in tmp do
42848: LD_ADDR_VAR 0 3
42852: PUSH
42853: LD_VAR 0 5
42857: PUSH
42858: FOR_IN
42859: IFFALSE 43053
// begin if mc_need_heal [ i ] then
42861: LD_EXP 102
42865: PUSH
42866: LD_VAR 0 2
42870: ARRAY
42871: IFFALSE 42919
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
42873: LD_VAR 0 3
42877: PUSH
42878: LD_EXP 102
42882: PUSH
42883: LD_VAR 0 2
42887: ARRAY
42888: PUSH
42889: LD_INT 1
42891: ARRAY
42892: IN
42893: PUSH
42894: LD_VAR 0 3
42898: PUSH
42899: LD_EXP 102
42903: PUSH
42904: LD_VAR 0 2
42908: ARRAY
42909: PUSH
42910: LD_INT 2
42912: ARRAY
42913: IN
42914: OR
42915: IFFALSE 42919
// continue ;
42917: GO 42858
// if IsInUnit ( j ) then
42919: LD_VAR 0 3
42923: PPUSH
42924: CALL_OW 310
42928: IFFALSE 42939
// ComExitBuilding ( j ) ;
42930: LD_VAR 0 3
42934: PPUSH
42935: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
42939: LD_VAR 0 3
42943: PUSH
42944: LD_EXP 101
42948: PUSH
42949: LD_VAR 0 2
42953: ARRAY
42954: IN
42955: NOT
42956: IFFALSE 43014
// begin SetTag ( j , 101 ) ;
42958: LD_VAR 0 3
42962: PPUSH
42963: LD_INT 101
42965: PPUSH
42966: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
42970: LD_ADDR_EXP 101
42974: PUSH
42975: LD_EXP 101
42979: PPUSH
42980: LD_VAR 0 2
42984: PUSH
42985: LD_EXP 101
42989: PUSH
42990: LD_VAR 0 2
42994: ARRAY
42995: PUSH
42996: LD_INT 1
42998: PLUS
42999: PUSH
43000: EMPTY
43001: LIST
43002: LIST
43003: PPUSH
43004: LD_VAR 0 3
43008: PPUSH
43009: CALL 69649 0 3
43013: ST_TO_ADDR
// end ; wait ( 1 ) ;
43014: LD_INT 1
43016: PPUSH
43017: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43021: LD_VAR 0 3
43025: PPUSH
43026: LD_EXP 100
43030: PUSH
43031: LD_VAR 0 2
43035: ARRAY
43036: PPUSH
43037: LD_VAR 0 3
43041: PPUSH
43042: CALL_OW 74
43046: PPUSH
43047: CALL_OW 130
// end ;
43051: GO 42858
43053: POP
43054: POP
// end ;
43055: GO 42689
43057: POP
43058: POP
// end ;
43059: LD_VAR 0 1
43063: RET
// export function MC_Heal ; var i , j , tmp ; begin
43064: LD_INT 0
43066: PPUSH
43067: PPUSH
43068: PPUSH
43069: PPUSH
// if not mc_bases then
43070: LD_EXP 99
43074: NOT
43075: IFFALSE 43079
// exit ;
43077: GO 43481
// for i = 1 to mc_bases do
43079: LD_ADDR_VAR 0 2
43083: PUSH
43084: DOUBLE
43085: LD_INT 1
43087: DEC
43088: ST_TO_ADDR
43089: LD_EXP 99
43093: PUSH
43094: FOR_TO
43095: IFFALSE 43479
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43097: LD_EXP 102
43101: PUSH
43102: LD_VAR 0 2
43106: ARRAY
43107: PUSH
43108: LD_INT 1
43110: ARRAY
43111: NOT
43112: PUSH
43113: LD_EXP 102
43117: PUSH
43118: LD_VAR 0 2
43122: ARRAY
43123: PUSH
43124: LD_INT 2
43126: ARRAY
43127: NOT
43128: AND
43129: IFFALSE 43167
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43131: LD_ADDR_EXP 103
43135: PUSH
43136: LD_EXP 103
43140: PPUSH
43141: LD_VAR 0 2
43145: PPUSH
43146: EMPTY
43147: PPUSH
43148: CALL_OW 1
43152: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43153: LD_VAR 0 2
43157: PPUSH
43158: LD_INT 102
43160: PPUSH
43161: CALL 37779 0 2
// continue ;
43165: GO 43094
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43167: LD_ADDR_VAR 0 4
43171: PUSH
43172: LD_EXP 99
43176: PUSH
43177: LD_VAR 0 2
43181: ARRAY
43182: PPUSH
43183: LD_INT 25
43185: PUSH
43186: LD_INT 4
43188: PUSH
43189: EMPTY
43190: LIST
43191: LIST
43192: PPUSH
43193: CALL_OW 72
43197: ST_TO_ADDR
// if not tmp then
43198: LD_VAR 0 4
43202: NOT
43203: IFFALSE 43207
// continue ;
43205: GO 43094
// if mc_taming [ i ] then
43207: LD_EXP 130
43211: PUSH
43212: LD_VAR 0 2
43216: ARRAY
43217: IFFALSE 43241
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43219: LD_ADDR_EXP 130
43223: PUSH
43224: LD_EXP 130
43228: PPUSH
43229: LD_VAR 0 2
43233: PPUSH
43234: EMPTY
43235: PPUSH
43236: CALL_OW 1
43240: ST_TO_ADDR
// for j in tmp do
43241: LD_ADDR_VAR 0 3
43245: PUSH
43246: LD_VAR 0 4
43250: PUSH
43251: FOR_IN
43252: IFFALSE 43475
// begin if IsInUnit ( j ) then
43254: LD_VAR 0 3
43258: PPUSH
43259: CALL_OW 310
43263: IFFALSE 43274
// ComExitBuilding ( j ) ;
43265: LD_VAR 0 3
43269: PPUSH
43270: CALL_OW 122
// if not j in mc_healers [ i ] then
43274: LD_VAR 0 3
43278: PUSH
43279: LD_EXP 103
43283: PUSH
43284: LD_VAR 0 2
43288: ARRAY
43289: IN
43290: NOT
43291: IFFALSE 43337
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43293: LD_ADDR_EXP 103
43297: PUSH
43298: LD_EXP 103
43302: PPUSH
43303: LD_VAR 0 2
43307: PUSH
43308: LD_EXP 103
43312: PUSH
43313: LD_VAR 0 2
43317: ARRAY
43318: PUSH
43319: LD_INT 1
43321: PLUS
43322: PUSH
43323: EMPTY
43324: LIST
43325: LIST
43326: PPUSH
43327: LD_VAR 0 3
43331: PPUSH
43332: CALL 69649 0 3
43336: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43337: LD_VAR 0 3
43341: PPUSH
43342: CALL_OW 110
43346: PUSH
43347: LD_INT 102
43349: NONEQUAL
43350: IFFALSE 43364
// SetTag ( j , 102 ) ;
43352: LD_VAR 0 3
43356: PPUSH
43357: LD_INT 102
43359: PPUSH
43360: CALL_OW 109
// Wait ( 3 ) ;
43364: LD_INT 3
43366: PPUSH
43367: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43371: LD_EXP 102
43375: PUSH
43376: LD_VAR 0 2
43380: ARRAY
43381: PUSH
43382: LD_INT 1
43384: ARRAY
43385: IFFALSE 43417
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43387: LD_VAR 0 3
43391: PPUSH
43392: LD_EXP 102
43396: PUSH
43397: LD_VAR 0 2
43401: ARRAY
43402: PUSH
43403: LD_INT 1
43405: ARRAY
43406: PUSH
43407: LD_INT 1
43409: ARRAY
43410: PPUSH
43411: CALL_OW 128
43415: GO 43473
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43417: LD_VAR 0 3
43421: PPUSH
43422: CALL_OW 314
43426: NOT
43427: PUSH
43428: LD_EXP 102
43432: PUSH
43433: LD_VAR 0 2
43437: ARRAY
43438: PUSH
43439: LD_INT 2
43441: ARRAY
43442: AND
43443: IFFALSE 43473
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
43445: LD_VAR 0 3
43449: PPUSH
43450: LD_EXP 102
43454: PUSH
43455: LD_VAR 0 2
43459: ARRAY
43460: PUSH
43461: LD_INT 2
43463: ARRAY
43464: PUSH
43465: LD_INT 1
43467: ARRAY
43468: PPUSH
43469: CALL_OW 128
// end ;
43473: GO 43251
43475: POP
43476: POP
// end ;
43477: GO 43094
43479: POP
43480: POP
// end ;
43481: LD_VAR 0 1
43485: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
43486: LD_INT 0
43488: PPUSH
43489: PPUSH
43490: PPUSH
43491: PPUSH
43492: PPUSH
// if not mc_bases then
43493: LD_EXP 99
43497: NOT
43498: IFFALSE 43502
// exit ;
43500: GO 44645
// for i = 1 to mc_bases do
43502: LD_ADDR_VAR 0 2
43506: PUSH
43507: DOUBLE
43508: LD_INT 1
43510: DEC
43511: ST_TO_ADDR
43512: LD_EXP 99
43516: PUSH
43517: FOR_TO
43518: IFFALSE 44643
// begin if mc_scan [ i ] then
43520: LD_EXP 122
43524: PUSH
43525: LD_VAR 0 2
43529: ARRAY
43530: IFFALSE 43534
// continue ;
43532: GO 43517
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
43534: LD_EXP 104
43538: PUSH
43539: LD_VAR 0 2
43543: ARRAY
43544: NOT
43545: PUSH
43546: LD_EXP 106
43550: PUSH
43551: LD_VAR 0 2
43555: ARRAY
43556: NOT
43557: AND
43558: PUSH
43559: LD_EXP 105
43563: PUSH
43564: LD_VAR 0 2
43568: ARRAY
43569: AND
43570: IFFALSE 43608
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
43572: LD_ADDR_EXP 105
43576: PUSH
43577: LD_EXP 105
43581: PPUSH
43582: LD_VAR 0 2
43586: PPUSH
43587: EMPTY
43588: PPUSH
43589: CALL_OW 1
43593: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43594: LD_VAR 0 2
43598: PPUSH
43599: LD_INT 103
43601: PPUSH
43602: CALL 37779 0 2
// continue ;
43606: GO 43517
// end ; if mc_construct_list [ i ] then
43608: LD_EXP 106
43612: PUSH
43613: LD_VAR 0 2
43617: ARRAY
43618: IFFALSE 43838
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
43620: LD_ADDR_VAR 0 4
43624: PUSH
43625: LD_EXP 99
43629: PUSH
43630: LD_VAR 0 2
43634: ARRAY
43635: PPUSH
43636: LD_INT 25
43638: PUSH
43639: LD_INT 2
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PPUSH
43646: CALL_OW 72
43650: PUSH
43651: LD_EXP 101
43655: PUSH
43656: LD_VAR 0 2
43660: ARRAY
43661: DIFF
43662: ST_TO_ADDR
// if not tmp then
43663: LD_VAR 0 4
43667: NOT
43668: IFFALSE 43672
// continue ;
43670: GO 43517
// for j in tmp do
43672: LD_ADDR_VAR 0 3
43676: PUSH
43677: LD_VAR 0 4
43681: PUSH
43682: FOR_IN
43683: IFFALSE 43834
// begin if not mc_builders [ i ] then
43685: LD_EXP 105
43689: PUSH
43690: LD_VAR 0 2
43694: ARRAY
43695: NOT
43696: IFFALSE 43754
// begin SetTag ( j , 103 ) ;
43698: LD_VAR 0 3
43702: PPUSH
43703: LD_INT 103
43705: PPUSH
43706: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
43710: LD_ADDR_EXP 105
43714: PUSH
43715: LD_EXP 105
43719: PPUSH
43720: LD_VAR 0 2
43724: PUSH
43725: LD_EXP 105
43729: PUSH
43730: LD_VAR 0 2
43734: ARRAY
43735: PUSH
43736: LD_INT 1
43738: PLUS
43739: PUSH
43740: EMPTY
43741: LIST
43742: LIST
43743: PPUSH
43744: LD_VAR 0 3
43748: PPUSH
43749: CALL 69649 0 3
43753: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
43754: LD_VAR 0 3
43758: PPUSH
43759: CALL_OW 310
43763: IFFALSE 43774
// ComExitBuilding ( j ) ;
43765: LD_VAR 0 3
43769: PPUSH
43770: CALL_OW 122
// wait ( 3 ) ;
43774: LD_INT 3
43776: PPUSH
43777: CALL_OW 67
// if not mc_construct_list [ i ] then
43781: LD_EXP 106
43785: PUSH
43786: LD_VAR 0 2
43790: ARRAY
43791: NOT
43792: IFFALSE 43796
// break ;
43794: GO 43834
// if not HasTask ( j ) then
43796: LD_VAR 0 3
43800: PPUSH
43801: CALL_OW 314
43805: NOT
43806: IFFALSE 43832
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
43808: LD_VAR 0 3
43812: PPUSH
43813: LD_EXP 106
43817: PUSH
43818: LD_VAR 0 2
43822: ARRAY
43823: PUSH
43824: LD_INT 1
43826: ARRAY
43827: PPUSH
43828: CALL 72500 0 2
// end ;
43832: GO 43682
43834: POP
43835: POP
// end else
43836: GO 44641
// if mc_build_list [ i ] then
43838: LD_EXP 104
43842: PUSH
43843: LD_VAR 0 2
43847: ARRAY
43848: IFFALSE 44641
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
43850: LD_ADDR_VAR 0 5
43854: PUSH
43855: LD_EXP 99
43859: PUSH
43860: LD_VAR 0 2
43864: ARRAY
43865: PPUSH
43866: LD_INT 2
43868: PUSH
43869: LD_INT 30
43871: PUSH
43872: LD_INT 0
43874: PUSH
43875: EMPTY
43876: LIST
43877: LIST
43878: PUSH
43879: LD_INT 30
43881: PUSH
43882: LD_INT 1
43884: PUSH
43885: EMPTY
43886: LIST
43887: LIST
43888: PUSH
43889: EMPTY
43890: LIST
43891: LIST
43892: LIST
43893: PPUSH
43894: CALL_OW 72
43898: ST_TO_ADDR
// if depot then
43899: LD_VAR 0 5
43903: IFFALSE 43921
// depot := depot [ 1 ] else
43905: LD_ADDR_VAR 0 5
43909: PUSH
43910: LD_VAR 0 5
43914: PUSH
43915: LD_INT 1
43917: ARRAY
43918: ST_TO_ADDR
43919: GO 43929
// depot := 0 ;
43921: LD_ADDR_VAR 0 5
43925: PUSH
43926: LD_INT 0
43928: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
43929: LD_EXP 104
43933: PUSH
43934: LD_VAR 0 2
43938: ARRAY
43939: PUSH
43940: LD_INT 1
43942: ARRAY
43943: PUSH
43944: LD_INT 1
43946: ARRAY
43947: PPUSH
43948: CALL 72330 0 1
43952: PUSH
43953: LD_EXP 99
43957: PUSH
43958: LD_VAR 0 2
43962: ARRAY
43963: PPUSH
43964: LD_INT 2
43966: PUSH
43967: LD_INT 30
43969: PUSH
43970: LD_INT 2
43972: PUSH
43973: EMPTY
43974: LIST
43975: LIST
43976: PUSH
43977: LD_INT 30
43979: PUSH
43980: LD_INT 3
43982: PUSH
43983: EMPTY
43984: LIST
43985: LIST
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: LIST
43991: PPUSH
43992: CALL_OW 72
43996: NOT
43997: AND
43998: IFFALSE 44103
// begin for j = 1 to mc_build_list [ i ] do
44000: LD_ADDR_VAR 0 3
44004: PUSH
44005: DOUBLE
44006: LD_INT 1
44008: DEC
44009: ST_TO_ADDR
44010: LD_EXP 104
44014: PUSH
44015: LD_VAR 0 2
44019: ARRAY
44020: PUSH
44021: FOR_TO
44022: IFFALSE 44101
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44024: LD_EXP 104
44028: PUSH
44029: LD_VAR 0 2
44033: ARRAY
44034: PUSH
44035: LD_VAR 0 3
44039: ARRAY
44040: PUSH
44041: LD_INT 1
44043: ARRAY
44044: PUSH
44045: LD_INT 2
44047: EQUAL
44048: IFFALSE 44099
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44050: LD_ADDR_EXP 104
44054: PUSH
44055: LD_EXP 104
44059: PPUSH
44060: LD_VAR 0 2
44064: PPUSH
44065: LD_EXP 104
44069: PUSH
44070: LD_VAR 0 2
44074: ARRAY
44075: PPUSH
44076: LD_VAR 0 3
44080: PPUSH
44081: LD_INT 1
44083: PPUSH
44084: LD_INT 0
44086: PPUSH
44087: CALL 69067 0 4
44091: PPUSH
44092: CALL_OW 1
44096: ST_TO_ADDR
// break ;
44097: GO 44101
// end ;
44099: GO 44021
44101: POP
44102: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44103: LD_EXP 104
44107: PUSH
44108: LD_VAR 0 2
44112: ARRAY
44113: PUSH
44114: LD_INT 1
44116: ARRAY
44117: PUSH
44118: LD_INT 1
44120: ARRAY
44121: PUSH
44122: LD_INT 0
44124: EQUAL
44125: PUSH
44126: LD_VAR 0 5
44130: PUSH
44131: LD_VAR 0 5
44135: PPUSH
44136: LD_EXP 104
44140: PUSH
44141: LD_VAR 0 2
44145: ARRAY
44146: PUSH
44147: LD_INT 1
44149: ARRAY
44150: PUSH
44151: LD_INT 1
44153: ARRAY
44154: PPUSH
44155: LD_EXP 104
44159: PUSH
44160: LD_VAR 0 2
44164: ARRAY
44165: PUSH
44166: LD_INT 1
44168: ARRAY
44169: PUSH
44170: LD_INT 2
44172: ARRAY
44173: PPUSH
44174: LD_EXP 104
44178: PUSH
44179: LD_VAR 0 2
44183: ARRAY
44184: PUSH
44185: LD_INT 1
44187: ARRAY
44188: PUSH
44189: LD_INT 3
44191: ARRAY
44192: PPUSH
44193: LD_EXP 104
44197: PUSH
44198: LD_VAR 0 2
44202: ARRAY
44203: PUSH
44204: LD_INT 1
44206: ARRAY
44207: PUSH
44208: LD_INT 4
44210: ARRAY
44211: PPUSH
44212: CALL 77064 0 5
44216: AND
44217: OR
44218: IFFALSE 44499
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44220: LD_ADDR_VAR 0 4
44224: PUSH
44225: LD_EXP 99
44229: PUSH
44230: LD_VAR 0 2
44234: ARRAY
44235: PPUSH
44236: LD_INT 25
44238: PUSH
44239: LD_INT 2
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PPUSH
44246: CALL_OW 72
44250: PUSH
44251: LD_EXP 101
44255: PUSH
44256: LD_VAR 0 2
44260: ARRAY
44261: DIFF
44262: ST_TO_ADDR
// if not tmp then
44263: LD_VAR 0 4
44267: NOT
44268: IFFALSE 44272
// continue ;
44270: GO 43517
// for j in tmp do
44272: LD_ADDR_VAR 0 3
44276: PUSH
44277: LD_VAR 0 4
44281: PUSH
44282: FOR_IN
44283: IFFALSE 44495
// begin if not mc_builders [ i ] then
44285: LD_EXP 105
44289: PUSH
44290: LD_VAR 0 2
44294: ARRAY
44295: NOT
44296: IFFALSE 44354
// begin SetTag ( j , 103 ) ;
44298: LD_VAR 0 3
44302: PPUSH
44303: LD_INT 103
44305: PPUSH
44306: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44310: LD_ADDR_EXP 105
44314: PUSH
44315: LD_EXP 105
44319: PPUSH
44320: LD_VAR 0 2
44324: PUSH
44325: LD_EXP 105
44329: PUSH
44330: LD_VAR 0 2
44334: ARRAY
44335: PUSH
44336: LD_INT 1
44338: PLUS
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PPUSH
44344: LD_VAR 0 3
44348: PPUSH
44349: CALL 69649 0 3
44353: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44354: LD_VAR 0 3
44358: PPUSH
44359: CALL_OW 310
44363: IFFALSE 44374
// ComExitBuilding ( j ) ;
44365: LD_VAR 0 3
44369: PPUSH
44370: CALL_OW 122
// wait ( 3 ) ;
44374: LD_INT 3
44376: PPUSH
44377: CALL_OW 67
// if not mc_build_list [ i ] then
44381: LD_EXP 104
44385: PUSH
44386: LD_VAR 0 2
44390: ARRAY
44391: NOT
44392: IFFALSE 44396
// break ;
44394: GO 44495
// if not HasTask ( j ) then
44396: LD_VAR 0 3
44400: PPUSH
44401: CALL_OW 314
44405: NOT
44406: IFFALSE 44493
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44408: LD_VAR 0 3
44412: PPUSH
44413: LD_EXP 104
44417: PUSH
44418: LD_VAR 0 2
44422: ARRAY
44423: PUSH
44424: LD_INT 1
44426: ARRAY
44427: PUSH
44428: LD_INT 1
44430: ARRAY
44431: PPUSH
44432: LD_EXP 104
44436: PUSH
44437: LD_VAR 0 2
44441: ARRAY
44442: PUSH
44443: LD_INT 1
44445: ARRAY
44446: PUSH
44447: LD_INT 2
44449: ARRAY
44450: PPUSH
44451: LD_EXP 104
44455: PUSH
44456: LD_VAR 0 2
44460: ARRAY
44461: PUSH
44462: LD_INT 1
44464: ARRAY
44465: PUSH
44466: LD_INT 3
44468: ARRAY
44469: PPUSH
44470: LD_EXP 104
44474: PUSH
44475: LD_VAR 0 2
44479: ARRAY
44480: PUSH
44481: LD_INT 1
44483: ARRAY
44484: PUSH
44485: LD_INT 4
44487: ARRAY
44488: PPUSH
44489: CALL_OW 145
// end ;
44493: GO 44282
44495: POP
44496: POP
// end else
44497: GO 44641
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
44499: LD_EXP 99
44503: PUSH
44504: LD_VAR 0 2
44508: ARRAY
44509: PPUSH
44510: LD_EXP 104
44514: PUSH
44515: LD_VAR 0 2
44519: ARRAY
44520: PUSH
44521: LD_INT 1
44523: ARRAY
44524: PUSH
44525: LD_INT 1
44527: ARRAY
44528: PPUSH
44529: LD_EXP 104
44533: PUSH
44534: LD_VAR 0 2
44538: ARRAY
44539: PUSH
44540: LD_INT 1
44542: ARRAY
44543: PUSH
44544: LD_INT 2
44546: ARRAY
44547: PPUSH
44548: LD_EXP 104
44552: PUSH
44553: LD_VAR 0 2
44557: ARRAY
44558: PUSH
44559: LD_INT 1
44561: ARRAY
44562: PUSH
44563: LD_INT 3
44565: ARRAY
44566: PPUSH
44567: LD_EXP 104
44571: PUSH
44572: LD_VAR 0 2
44576: ARRAY
44577: PUSH
44578: LD_INT 1
44580: ARRAY
44581: PUSH
44582: LD_INT 4
44584: ARRAY
44585: PPUSH
44586: CALL 76400 0 5
44590: NOT
44591: IFFALSE 44641
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
44593: LD_ADDR_EXP 104
44597: PUSH
44598: LD_EXP 104
44602: PPUSH
44603: LD_VAR 0 2
44607: PPUSH
44608: LD_EXP 104
44612: PUSH
44613: LD_VAR 0 2
44617: ARRAY
44618: PPUSH
44619: LD_INT 1
44621: PPUSH
44622: LD_INT 1
44624: NEG
44625: PPUSH
44626: LD_INT 0
44628: PPUSH
44629: CALL 69067 0 4
44633: PPUSH
44634: CALL_OW 1
44638: ST_TO_ADDR
// continue ;
44639: GO 43517
// end ; end ; end ;
44641: GO 43517
44643: POP
44644: POP
// end ;
44645: LD_VAR 0 1
44649: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
44650: LD_INT 0
44652: PPUSH
44653: PPUSH
44654: PPUSH
44655: PPUSH
44656: PPUSH
44657: PPUSH
// if not mc_bases then
44658: LD_EXP 99
44662: NOT
44663: IFFALSE 44667
// exit ;
44665: GO 45094
// for i = 1 to mc_bases do
44667: LD_ADDR_VAR 0 2
44671: PUSH
44672: DOUBLE
44673: LD_INT 1
44675: DEC
44676: ST_TO_ADDR
44677: LD_EXP 99
44681: PUSH
44682: FOR_TO
44683: IFFALSE 45092
// begin tmp := mc_build_upgrade [ i ] ;
44685: LD_ADDR_VAR 0 4
44689: PUSH
44690: LD_EXP 131
44694: PUSH
44695: LD_VAR 0 2
44699: ARRAY
44700: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
44701: LD_ADDR_VAR 0 6
44705: PUSH
44706: LD_EXP 132
44710: PUSH
44711: LD_VAR 0 2
44715: ARRAY
44716: PPUSH
44717: LD_INT 2
44719: PUSH
44720: LD_INT 30
44722: PUSH
44723: LD_INT 6
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: LD_INT 30
44732: PUSH
44733: LD_INT 7
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: LIST
44744: PPUSH
44745: CALL_OW 72
44749: ST_TO_ADDR
// if not tmp and not lab then
44750: LD_VAR 0 4
44754: NOT
44755: PUSH
44756: LD_VAR 0 6
44760: NOT
44761: AND
44762: IFFALSE 44766
// continue ;
44764: GO 44682
// if tmp then
44766: LD_VAR 0 4
44770: IFFALSE 44890
// for j in tmp do
44772: LD_ADDR_VAR 0 3
44776: PUSH
44777: LD_VAR 0 4
44781: PUSH
44782: FOR_IN
44783: IFFALSE 44888
// begin if UpgradeCost ( j ) then
44785: LD_VAR 0 3
44789: PPUSH
44790: CALL 76060 0 1
44794: IFFALSE 44886
// begin ComUpgrade ( j ) ;
44796: LD_VAR 0 3
44800: PPUSH
44801: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
44805: LD_ADDR_EXP 131
44809: PUSH
44810: LD_EXP 131
44814: PPUSH
44815: LD_VAR 0 2
44819: PPUSH
44820: LD_EXP 131
44824: PUSH
44825: LD_VAR 0 2
44829: ARRAY
44830: PUSH
44831: LD_VAR 0 3
44835: DIFF
44836: PPUSH
44837: CALL_OW 1
44841: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
44842: LD_ADDR_EXP 106
44846: PUSH
44847: LD_EXP 106
44851: PPUSH
44852: LD_VAR 0 2
44856: PUSH
44857: LD_EXP 106
44861: PUSH
44862: LD_VAR 0 2
44866: ARRAY
44867: PUSH
44868: LD_INT 1
44870: PLUS
44871: PUSH
44872: EMPTY
44873: LIST
44874: LIST
44875: PPUSH
44876: LD_VAR 0 3
44880: PPUSH
44881: CALL 69649 0 3
44885: ST_TO_ADDR
// end ; end ;
44886: GO 44782
44888: POP
44889: POP
// if not lab or not mc_lab_upgrade [ i ] then
44890: LD_VAR 0 6
44894: NOT
44895: PUSH
44896: LD_EXP 133
44900: PUSH
44901: LD_VAR 0 2
44905: ARRAY
44906: NOT
44907: OR
44908: IFFALSE 44912
// continue ;
44910: GO 44682
// for j in lab do
44912: LD_ADDR_VAR 0 3
44916: PUSH
44917: LD_VAR 0 6
44921: PUSH
44922: FOR_IN
44923: IFFALSE 45088
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
44925: LD_VAR 0 3
44929: PPUSH
44930: CALL_OW 266
44934: PUSH
44935: LD_INT 6
44937: PUSH
44938: LD_INT 7
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: IN
44945: PUSH
44946: LD_VAR 0 3
44950: PPUSH
44951: CALL_OW 461
44955: PUSH
44956: LD_INT 1
44958: NONEQUAL
44959: AND
44960: IFFALSE 45086
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
44962: LD_VAR 0 3
44966: PPUSH
44967: LD_EXP 133
44971: PUSH
44972: LD_VAR 0 2
44976: ARRAY
44977: PUSH
44978: LD_INT 1
44980: ARRAY
44981: PPUSH
44982: CALL 76265 0 2
44986: IFFALSE 45086
// begin ComCancel ( j ) ;
44988: LD_VAR 0 3
44992: PPUSH
44993: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
44997: LD_VAR 0 3
45001: PPUSH
45002: LD_EXP 133
45006: PUSH
45007: LD_VAR 0 2
45011: ARRAY
45012: PUSH
45013: LD_INT 1
45015: ARRAY
45016: PPUSH
45017: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45021: LD_VAR 0 3
45025: PUSH
45026: LD_EXP 106
45030: PUSH
45031: LD_VAR 0 2
45035: ARRAY
45036: IN
45037: NOT
45038: IFFALSE 45084
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45040: LD_ADDR_EXP 106
45044: PUSH
45045: LD_EXP 106
45049: PPUSH
45050: LD_VAR 0 2
45054: PUSH
45055: LD_EXP 106
45059: PUSH
45060: LD_VAR 0 2
45064: ARRAY
45065: PUSH
45066: LD_INT 1
45068: PLUS
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PPUSH
45074: LD_VAR 0 3
45078: PPUSH
45079: CALL 69649 0 3
45083: ST_TO_ADDR
// break ;
45084: GO 45088
// end ; end ; end ;
45086: GO 44922
45088: POP
45089: POP
// end ;
45090: GO 44682
45092: POP
45093: POP
// end ;
45094: LD_VAR 0 1
45098: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45099: LD_INT 0
45101: PPUSH
45102: PPUSH
45103: PPUSH
45104: PPUSH
45105: PPUSH
45106: PPUSH
45107: PPUSH
45108: PPUSH
45109: PPUSH
// if not mc_bases then
45110: LD_EXP 99
45114: NOT
45115: IFFALSE 45119
// exit ;
45117: GO 45524
// for i = 1 to mc_bases do
45119: LD_ADDR_VAR 0 2
45123: PUSH
45124: DOUBLE
45125: LD_INT 1
45127: DEC
45128: ST_TO_ADDR
45129: LD_EXP 99
45133: PUSH
45134: FOR_TO
45135: IFFALSE 45522
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45137: LD_EXP 107
45141: PUSH
45142: LD_VAR 0 2
45146: ARRAY
45147: NOT
45148: PUSH
45149: LD_EXP 99
45153: PUSH
45154: LD_VAR 0 2
45158: ARRAY
45159: PPUSH
45160: LD_INT 30
45162: PUSH
45163: LD_INT 3
45165: PUSH
45166: EMPTY
45167: LIST
45168: LIST
45169: PPUSH
45170: CALL_OW 72
45174: NOT
45175: OR
45176: IFFALSE 45180
// continue ;
45178: GO 45134
// busy := false ;
45180: LD_ADDR_VAR 0 8
45184: PUSH
45185: LD_INT 0
45187: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45188: LD_ADDR_VAR 0 4
45192: PUSH
45193: LD_EXP 99
45197: PUSH
45198: LD_VAR 0 2
45202: ARRAY
45203: PPUSH
45204: LD_INT 30
45206: PUSH
45207: LD_INT 3
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PPUSH
45214: CALL_OW 72
45218: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45219: LD_ADDR_VAR 0 6
45223: PUSH
45224: LD_EXP 107
45228: PUSH
45229: LD_VAR 0 2
45233: ARRAY
45234: PPUSH
45235: LD_INT 2
45237: PUSH
45238: LD_INT 30
45240: PUSH
45241: LD_INT 32
45243: PUSH
45244: EMPTY
45245: LIST
45246: LIST
45247: PUSH
45248: LD_INT 30
45250: PUSH
45251: LD_INT 33
45253: PUSH
45254: EMPTY
45255: LIST
45256: LIST
45257: PUSH
45258: EMPTY
45259: LIST
45260: LIST
45261: LIST
45262: PPUSH
45263: CALL_OW 72
45267: ST_TO_ADDR
// if not t then
45268: LD_VAR 0 6
45272: NOT
45273: IFFALSE 45277
// continue ;
45275: GO 45134
// for j in tmp do
45277: LD_ADDR_VAR 0 3
45281: PUSH
45282: LD_VAR 0 4
45286: PUSH
45287: FOR_IN
45288: IFFALSE 45318
// if not BuildingStatus ( j ) = bs_idle then
45290: LD_VAR 0 3
45294: PPUSH
45295: CALL_OW 461
45299: PUSH
45300: LD_INT 2
45302: EQUAL
45303: NOT
45304: IFFALSE 45316
// begin busy := true ;
45306: LD_ADDR_VAR 0 8
45310: PUSH
45311: LD_INT 1
45313: ST_TO_ADDR
// break ;
45314: GO 45318
// end ;
45316: GO 45287
45318: POP
45319: POP
// if busy then
45320: LD_VAR 0 8
45324: IFFALSE 45328
// continue ;
45326: GO 45134
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45328: LD_ADDR_VAR 0 7
45332: PUSH
45333: LD_VAR 0 6
45337: PPUSH
45338: LD_INT 35
45340: PUSH
45341: LD_INT 0
45343: PUSH
45344: EMPTY
45345: LIST
45346: LIST
45347: PPUSH
45348: CALL_OW 72
45352: ST_TO_ADDR
// if tw then
45353: LD_VAR 0 7
45357: IFFALSE 45434
// begin tw := tw [ 1 ] ;
45359: LD_ADDR_VAR 0 7
45363: PUSH
45364: LD_VAR 0 7
45368: PUSH
45369: LD_INT 1
45371: ARRAY
45372: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45373: LD_ADDR_VAR 0 9
45377: PUSH
45378: LD_VAR 0 7
45382: PPUSH
45383: LD_EXP 124
45387: PUSH
45388: LD_VAR 0 2
45392: ARRAY
45393: PPUSH
45394: CALL 74619 0 2
45398: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45399: LD_EXP 138
45403: PUSH
45404: LD_VAR 0 2
45408: ARRAY
45409: IFFALSE 45432
// if not weapon in mc_allowed_tower_weapons [ i ] then
45411: LD_VAR 0 9
45415: PUSH
45416: LD_EXP 138
45420: PUSH
45421: LD_VAR 0 2
45425: ARRAY
45426: IN
45427: NOT
45428: IFFALSE 45432
// continue ;
45430: GO 45134
// end else
45432: GO 45497
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45434: LD_ADDR_VAR 0 5
45438: PUSH
45439: LD_EXP 107
45443: PUSH
45444: LD_VAR 0 2
45448: ARRAY
45449: PPUSH
45450: LD_VAR 0 4
45454: PPUSH
45455: CALL 104820 0 2
45459: ST_TO_ADDR
// if not tmp2 then
45460: LD_VAR 0 5
45464: NOT
45465: IFFALSE 45469
// continue ;
45467: GO 45134
// tw := tmp2 [ 1 ] ;
45469: LD_ADDR_VAR 0 7
45473: PUSH
45474: LD_VAR 0 5
45478: PUSH
45479: LD_INT 1
45481: ARRAY
45482: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
45483: LD_ADDR_VAR 0 9
45487: PUSH
45488: LD_VAR 0 5
45492: PUSH
45493: LD_INT 2
45495: ARRAY
45496: ST_TO_ADDR
// end ; if not weapon then
45497: LD_VAR 0 9
45501: NOT
45502: IFFALSE 45506
// continue ;
45504: GO 45134
// ComPlaceWeapon ( tw , weapon ) ;
45506: LD_VAR 0 7
45510: PPUSH
45511: LD_VAR 0 9
45515: PPUSH
45516: CALL_OW 148
// end ;
45520: GO 45134
45522: POP
45523: POP
// end ;
45524: LD_VAR 0 1
45528: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
45529: LD_INT 0
45531: PPUSH
45532: PPUSH
45533: PPUSH
45534: PPUSH
45535: PPUSH
45536: PPUSH
// if not mc_bases then
45537: LD_EXP 99
45541: NOT
45542: IFFALSE 45546
// exit ;
45544: GO 46558
// for i = 1 to mc_bases do
45546: LD_ADDR_VAR 0 2
45550: PUSH
45551: DOUBLE
45552: LD_INT 1
45554: DEC
45555: ST_TO_ADDR
45556: LD_EXP 99
45560: PUSH
45561: FOR_TO
45562: IFFALSE 46556
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
45564: LD_EXP 112
45568: PUSH
45569: LD_VAR 0 2
45573: ARRAY
45574: NOT
45575: PUSH
45576: LD_EXP 112
45580: PUSH
45581: LD_VAR 0 2
45585: ARRAY
45586: PUSH
45587: LD_EXP 113
45591: PUSH
45592: LD_VAR 0 2
45596: ARRAY
45597: EQUAL
45598: OR
45599: IFFALSE 45603
// continue ;
45601: GO 45561
// if mc_miners [ i ] then
45603: LD_EXP 113
45607: PUSH
45608: LD_VAR 0 2
45612: ARRAY
45613: IFFALSE 46243
// begin k := 1 ;
45615: LD_ADDR_VAR 0 4
45619: PUSH
45620: LD_INT 1
45622: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
45623: LD_ADDR_VAR 0 3
45627: PUSH
45628: DOUBLE
45629: LD_EXP 113
45633: PUSH
45634: LD_VAR 0 2
45638: ARRAY
45639: INC
45640: ST_TO_ADDR
45641: LD_INT 1
45643: PUSH
45644: FOR_DOWNTO
45645: IFFALSE 46241
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
45647: LD_EXP 113
45651: PUSH
45652: LD_VAR 0 2
45656: ARRAY
45657: PUSH
45658: LD_VAR 0 3
45662: ARRAY
45663: PPUSH
45664: CALL_OW 301
45668: PUSH
45669: LD_EXP 113
45673: PUSH
45674: LD_VAR 0 2
45678: ARRAY
45679: PUSH
45680: LD_VAR 0 3
45684: ARRAY
45685: PPUSH
45686: CALL_OW 257
45690: PUSH
45691: LD_INT 1
45693: NONEQUAL
45694: OR
45695: IFFALSE 45758
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
45697: LD_ADDR_VAR 0 5
45701: PUSH
45702: LD_EXP 113
45706: PUSH
45707: LD_VAR 0 2
45711: ARRAY
45712: PUSH
45713: LD_EXP 113
45717: PUSH
45718: LD_VAR 0 2
45722: ARRAY
45723: PUSH
45724: LD_VAR 0 3
45728: ARRAY
45729: DIFF
45730: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
45731: LD_ADDR_EXP 113
45735: PUSH
45736: LD_EXP 113
45740: PPUSH
45741: LD_VAR 0 2
45745: PPUSH
45746: LD_VAR 0 5
45750: PPUSH
45751: CALL_OW 1
45755: ST_TO_ADDR
// continue ;
45756: GO 45644
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
45758: LD_EXP 113
45762: PUSH
45763: LD_VAR 0 2
45767: ARRAY
45768: PUSH
45769: LD_VAR 0 3
45773: ARRAY
45774: PPUSH
45775: CALL 69585 0 1
45779: PUSH
45780: LD_EXP 113
45784: PUSH
45785: LD_VAR 0 2
45789: ARRAY
45790: PUSH
45791: LD_VAR 0 3
45795: ARRAY
45796: PPUSH
45797: CALL_OW 255
45801: PPUSH
45802: LD_EXP 112
45806: PUSH
45807: LD_VAR 0 2
45811: ARRAY
45812: PUSH
45813: LD_VAR 0 4
45817: ARRAY
45818: PUSH
45819: LD_INT 1
45821: ARRAY
45822: PPUSH
45823: LD_EXP 112
45827: PUSH
45828: LD_VAR 0 2
45832: ARRAY
45833: PUSH
45834: LD_VAR 0 4
45838: ARRAY
45839: PUSH
45840: LD_INT 2
45842: ARRAY
45843: PPUSH
45844: LD_INT 15
45846: PPUSH
45847: CALL 70545 0 4
45851: PUSH
45852: LD_INT 4
45854: ARRAY
45855: PUSH
45856: LD_EXP 113
45860: PUSH
45861: LD_VAR 0 2
45865: ARRAY
45866: PUSH
45867: LD_VAR 0 3
45871: ARRAY
45872: PPUSH
45873: LD_INT 10
45875: PPUSH
45876: CALL 72242 0 2
45880: PUSH
45881: LD_INT 4
45883: ARRAY
45884: OR
45885: AND
45886: IFFALSE 45909
// ComStop ( mc_miners [ i ] [ j ] ) ;
45888: LD_EXP 113
45892: PUSH
45893: LD_VAR 0 2
45897: ARRAY
45898: PUSH
45899: LD_VAR 0 3
45903: ARRAY
45904: PPUSH
45905: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
45909: LD_EXP 113
45913: PUSH
45914: LD_VAR 0 2
45918: ARRAY
45919: PUSH
45920: LD_VAR 0 3
45924: ARRAY
45925: PPUSH
45926: CALL_OW 257
45930: PUSH
45931: LD_INT 1
45933: EQUAL
45934: PUSH
45935: LD_EXP 113
45939: PUSH
45940: LD_VAR 0 2
45944: ARRAY
45945: PUSH
45946: LD_VAR 0 3
45950: ARRAY
45951: PPUSH
45952: CALL_OW 459
45956: NOT
45957: AND
45958: PUSH
45959: LD_EXP 113
45963: PUSH
45964: LD_VAR 0 2
45968: ARRAY
45969: PUSH
45970: LD_VAR 0 3
45974: ARRAY
45975: PPUSH
45976: CALL_OW 255
45980: PPUSH
45981: LD_EXP 112
45985: PUSH
45986: LD_VAR 0 2
45990: ARRAY
45991: PUSH
45992: LD_VAR 0 4
45996: ARRAY
45997: PUSH
45998: LD_INT 1
46000: ARRAY
46001: PPUSH
46002: LD_EXP 112
46006: PUSH
46007: LD_VAR 0 2
46011: ARRAY
46012: PUSH
46013: LD_VAR 0 4
46017: ARRAY
46018: PUSH
46019: LD_INT 2
46021: ARRAY
46022: PPUSH
46023: LD_INT 15
46025: PPUSH
46026: CALL 70545 0 4
46030: PUSH
46031: LD_INT 4
46033: ARRAY
46034: PUSH
46035: LD_INT 0
46037: EQUAL
46038: AND
46039: PUSH
46040: LD_EXP 113
46044: PUSH
46045: LD_VAR 0 2
46049: ARRAY
46050: PUSH
46051: LD_VAR 0 3
46055: ARRAY
46056: PPUSH
46057: CALL_OW 314
46061: NOT
46062: AND
46063: IFFALSE 46239
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46065: LD_EXP 113
46069: PUSH
46070: LD_VAR 0 2
46074: ARRAY
46075: PUSH
46076: LD_VAR 0 3
46080: ARRAY
46081: PPUSH
46082: CALL_OW 310
46086: IFFALSE 46109
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46088: LD_EXP 113
46092: PUSH
46093: LD_VAR 0 2
46097: ARRAY
46098: PUSH
46099: LD_VAR 0 3
46103: ARRAY
46104: PPUSH
46105: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46109: LD_EXP 113
46113: PUSH
46114: LD_VAR 0 2
46118: ARRAY
46119: PUSH
46120: LD_VAR 0 3
46124: ARRAY
46125: PPUSH
46126: CALL_OW 314
46130: NOT
46131: IFFALSE 46199
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46133: LD_EXP 113
46137: PUSH
46138: LD_VAR 0 2
46142: ARRAY
46143: PUSH
46144: LD_VAR 0 3
46148: ARRAY
46149: PPUSH
46150: LD_EXP 112
46154: PUSH
46155: LD_VAR 0 2
46159: ARRAY
46160: PUSH
46161: LD_VAR 0 4
46165: ARRAY
46166: PUSH
46167: LD_INT 1
46169: ARRAY
46170: PPUSH
46171: LD_EXP 112
46175: PUSH
46176: LD_VAR 0 2
46180: ARRAY
46181: PUSH
46182: LD_VAR 0 4
46186: ARRAY
46187: PUSH
46188: LD_INT 2
46190: ARRAY
46191: PPUSH
46192: LD_INT 0
46194: PPUSH
46195: CALL_OW 193
// k := k + 1 ;
46199: LD_ADDR_VAR 0 4
46203: PUSH
46204: LD_VAR 0 4
46208: PUSH
46209: LD_INT 1
46211: PLUS
46212: ST_TO_ADDR
// if k > mc_mines [ i ] then
46213: LD_VAR 0 4
46217: PUSH
46218: LD_EXP 112
46222: PUSH
46223: LD_VAR 0 2
46227: ARRAY
46228: GREATER
46229: IFFALSE 46239
// k := 1 ;
46231: LD_ADDR_VAR 0 4
46235: PUSH
46236: LD_INT 1
46238: ST_TO_ADDR
// end ; end ;
46239: GO 45644
46241: POP
46242: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46243: LD_ADDR_VAR 0 5
46247: PUSH
46248: LD_EXP 99
46252: PUSH
46253: LD_VAR 0 2
46257: ARRAY
46258: PPUSH
46259: LD_INT 2
46261: PUSH
46262: LD_INT 30
46264: PUSH
46265: LD_INT 4
46267: PUSH
46268: EMPTY
46269: LIST
46270: LIST
46271: PUSH
46272: LD_INT 30
46274: PUSH
46275: LD_INT 5
46277: PUSH
46278: EMPTY
46279: LIST
46280: LIST
46281: PUSH
46282: LD_INT 30
46284: PUSH
46285: LD_INT 32
46287: PUSH
46288: EMPTY
46289: LIST
46290: LIST
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: LIST
46296: LIST
46297: PPUSH
46298: CALL_OW 72
46302: ST_TO_ADDR
// if not tmp then
46303: LD_VAR 0 5
46307: NOT
46308: IFFALSE 46312
// continue ;
46310: GO 45561
// list := [ ] ;
46312: LD_ADDR_VAR 0 6
46316: PUSH
46317: EMPTY
46318: ST_TO_ADDR
// for j in tmp do
46319: LD_ADDR_VAR 0 3
46323: PUSH
46324: LD_VAR 0 5
46328: PUSH
46329: FOR_IN
46330: IFFALSE 46399
// begin for k in UnitsInside ( j ) do
46332: LD_ADDR_VAR 0 4
46336: PUSH
46337: LD_VAR 0 3
46341: PPUSH
46342: CALL_OW 313
46346: PUSH
46347: FOR_IN
46348: IFFALSE 46395
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46350: LD_VAR 0 4
46354: PPUSH
46355: CALL_OW 257
46359: PUSH
46360: LD_INT 1
46362: EQUAL
46363: PUSH
46364: LD_VAR 0 4
46368: PPUSH
46369: CALL_OW 459
46373: NOT
46374: AND
46375: IFFALSE 46393
// list := list ^ k ;
46377: LD_ADDR_VAR 0 6
46381: PUSH
46382: LD_VAR 0 6
46386: PUSH
46387: LD_VAR 0 4
46391: ADD
46392: ST_TO_ADDR
46393: GO 46347
46395: POP
46396: POP
// end ;
46397: GO 46329
46399: POP
46400: POP
// list := list diff mc_miners [ i ] ;
46401: LD_ADDR_VAR 0 6
46405: PUSH
46406: LD_VAR 0 6
46410: PUSH
46411: LD_EXP 113
46415: PUSH
46416: LD_VAR 0 2
46420: ARRAY
46421: DIFF
46422: ST_TO_ADDR
// if not list then
46423: LD_VAR 0 6
46427: NOT
46428: IFFALSE 46432
// continue ;
46430: GO 45561
// k := mc_mines [ i ] - mc_miners [ i ] ;
46432: LD_ADDR_VAR 0 4
46436: PUSH
46437: LD_EXP 112
46441: PUSH
46442: LD_VAR 0 2
46446: ARRAY
46447: PUSH
46448: LD_EXP 113
46452: PUSH
46453: LD_VAR 0 2
46457: ARRAY
46458: MINUS
46459: ST_TO_ADDR
// if k > list then
46460: LD_VAR 0 4
46464: PUSH
46465: LD_VAR 0 6
46469: GREATER
46470: IFFALSE 46482
// k := list ;
46472: LD_ADDR_VAR 0 4
46476: PUSH
46477: LD_VAR 0 6
46481: ST_TO_ADDR
// for j = 1 to k do
46482: LD_ADDR_VAR 0 3
46486: PUSH
46487: DOUBLE
46488: LD_INT 1
46490: DEC
46491: ST_TO_ADDR
46492: LD_VAR 0 4
46496: PUSH
46497: FOR_TO
46498: IFFALSE 46552
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
46500: LD_ADDR_EXP 113
46504: PUSH
46505: LD_EXP 113
46509: PPUSH
46510: LD_VAR 0 2
46514: PUSH
46515: LD_EXP 113
46519: PUSH
46520: LD_VAR 0 2
46524: ARRAY
46525: PUSH
46526: LD_INT 1
46528: PLUS
46529: PUSH
46530: EMPTY
46531: LIST
46532: LIST
46533: PPUSH
46534: LD_VAR 0 6
46538: PUSH
46539: LD_VAR 0 3
46543: ARRAY
46544: PPUSH
46545: CALL 69649 0 3
46549: ST_TO_ADDR
46550: GO 46497
46552: POP
46553: POP
// end ;
46554: GO 45561
46556: POP
46557: POP
// end ;
46558: LD_VAR 0 1
46562: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
46563: LD_INT 0
46565: PPUSH
46566: PPUSH
46567: PPUSH
46568: PPUSH
46569: PPUSH
46570: PPUSH
46571: PPUSH
46572: PPUSH
46573: PPUSH
46574: PPUSH
// if not mc_bases then
46575: LD_EXP 99
46579: NOT
46580: IFFALSE 46584
// exit ;
46582: GO 48315
// for i = 1 to mc_bases do
46584: LD_ADDR_VAR 0 2
46588: PUSH
46589: DOUBLE
46590: LD_INT 1
46592: DEC
46593: ST_TO_ADDR
46594: LD_EXP 99
46598: PUSH
46599: FOR_TO
46600: IFFALSE 48313
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
46602: LD_EXP 99
46606: PUSH
46607: LD_VAR 0 2
46611: ARRAY
46612: NOT
46613: PUSH
46614: LD_EXP 106
46618: PUSH
46619: LD_VAR 0 2
46623: ARRAY
46624: OR
46625: IFFALSE 46629
// continue ;
46627: GO 46599
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
46629: LD_EXP 115
46633: PUSH
46634: LD_VAR 0 2
46638: ARRAY
46639: NOT
46640: PUSH
46641: LD_EXP 116
46645: PUSH
46646: LD_VAR 0 2
46650: ARRAY
46651: AND
46652: IFFALSE 46690
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
46654: LD_ADDR_EXP 116
46658: PUSH
46659: LD_EXP 116
46663: PPUSH
46664: LD_VAR 0 2
46668: PPUSH
46669: EMPTY
46670: PPUSH
46671: CALL_OW 1
46675: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
46676: LD_VAR 0 2
46680: PPUSH
46681: LD_INT 107
46683: PPUSH
46684: CALL 37779 0 2
// continue ;
46688: GO 46599
// end ; target := [ ] ;
46690: LD_ADDR_VAR 0 6
46694: PUSH
46695: EMPTY
46696: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
46697: LD_ADDR_VAR 0 3
46701: PUSH
46702: DOUBLE
46703: LD_EXP 115
46707: PUSH
46708: LD_VAR 0 2
46712: ARRAY
46713: INC
46714: ST_TO_ADDR
46715: LD_INT 1
46717: PUSH
46718: FOR_DOWNTO
46719: IFFALSE 46979
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
46721: LD_EXP 115
46725: PUSH
46726: LD_VAR 0 2
46730: ARRAY
46731: PUSH
46732: LD_VAR 0 3
46736: ARRAY
46737: PUSH
46738: LD_INT 2
46740: ARRAY
46741: PPUSH
46742: LD_EXP 115
46746: PUSH
46747: LD_VAR 0 2
46751: ARRAY
46752: PUSH
46753: LD_VAR 0 3
46757: ARRAY
46758: PUSH
46759: LD_INT 3
46761: ARRAY
46762: PPUSH
46763: CALL_OW 488
46767: PUSH
46768: LD_EXP 115
46772: PUSH
46773: LD_VAR 0 2
46777: ARRAY
46778: PUSH
46779: LD_VAR 0 3
46783: ARRAY
46784: PUSH
46785: LD_INT 2
46787: ARRAY
46788: PPUSH
46789: LD_EXP 115
46793: PUSH
46794: LD_VAR 0 2
46798: ARRAY
46799: PUSH
46800: LD_VAR 0 3
46804: ARRAY
46805: PUSH
46806: LD_INT 3
46808: ARRAY
46809: PPUSH
46810: CALL_OW 284
46814: PUSH
46815: LD_INT 0
46817: EQUAL
46818: AND
46819: IFFALSE 46874
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
46821: LD_ADDR_VAR 0 5
46825: PUSH
46826: LD_EXP 115
46830: PUSH
46831: LD_VAR 0 2
46835: ARRAY
46836: PPUSH
46837: LD_VAR 0 3
46841: PPUSH
46842: CALL_OW 3
46846: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
46847: LD_ADDR_EXP 115
46851: PUSH
46852: LD_EXP 115
46856: PPUSH
46857: LD_VAR 0 2
46861: PPUSH
46862: LD_VAR 0 5
46866: PPUSH
46867: CALL_OW 1
46871: ST_TO_ADDR
// continue ;
46872: GO 46718
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
46874: LD_EXP 99
46878: PUSH
46879: LD_VAR 0 2
46883: ARRAY
46884: PUSH
46885: LD_INT 1
46887: ARRAY
46888: PPUSH
46889: CALL_OW 255
46893: PPUSH
46894: LD_EXP 115
46898: PUSH
46899: LD_VAR 0 2
46903: ARRAY
46904: PUSH
46905: LD_VAR 0 3
46909: ARRAY
46910: PUSH
46911: LD_INT 2
46913: ARRAY
46914: PPUSH
46915: LD_EXP 115
46919: PUSH
46920: LD_VAR 0 2
46924: ARRAY
46925: PUSH
46926: LD_VAR 0 3
46930: ARRAY
46931: PUSH
46932: LD_INT 3
46934: ARRAY
46935: PPUSH
46936: LD_INT 30
46938: PPUSH
46939: CALL 70545 0 4
46943: PUSH
46944: LD_INT 4
46946: ARRAY
46947: PUSH
46948: LD_INT 0
46950: EQUAL
46951: IFFALSE 46977
// begin target := mc_crates [ i ] [ j ] ;
46953: LD_ADDR_VAR 0 6
46957: PUSH
46958: LD_EXP 115
46962: PUSH
46963: LD_VAR 0 2
46967: ARRAY
46968: PUSH
46969: LD_VAR 0 3
46973: ARRAY
46974: ST_TO_ADDR
// break ;
46975: GO 46979
// end ; end ;
46977: GO 46718
46979: POP
46980: POP
// if not target then
46981: LD_VAR 0 6
46985: NOT
46986: IFFALSE 46990
// continue ;
46988: GO 46599
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
46990: LD_ADDR_VAR 0 7
46994: PUSH
46995: LD_EXP 118
46999: PUSH
47000: LD_VAR 0 2
47004: ARRAY
47005: PPUSH
47006: LD_INT 2
47008: PUSH
47009: LD_INT 3
47011: PUSH
47012: LD_INT 58
47014: PUSH
47015: EMPTY
47016: LIST
47017: PUSH
47018: EMPTY
47019: LIST
47020: LIST
47021: PUSH
47022: LD_INT 61
47024: PUSH
47025: EMPTY
47026: LIST
47027: PUSH
47028: LD_INT 33
47030: PUSH
47031: LD_INT 5
47033: PUSH
47034: EMPTY
47035: LIST
47036: LIST
47037: PUSH
47038: LD_INT 33
47040: PUSH
47041: LD_INT 3
47043: PUSH
47044: EMPTY
47045: LIST
47046: LIST
47047: PUSH
47048: EMPTY
47049: LIST
47050: LIST
47051: LIST
47052: LIST
47053: LIST
47054: PUSH
47055: LD_INT 2
47057: PUSH
47058: LD_INT 34
47060: PUSH
47061: LD_INT 32
47063: PUSH
47064: EMPTY
47065: LIST
47066: LIST
47067: PUSH
47068: LD_INT 34
47070: PUSH
47071: LD_INT 51
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: PUSH
47078: LD_INT 34
47080: PUSH
47081: LD_INT 12
47083: PUSH
47084: EMPTY
47085: LIST
47086: LIST
47087: PUSH
47088: EMPTY
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: PUSH
47094: EMPTY
47095: LIST
47096: LIST
47097: PPUSH
47098: CALL_OW 72
47102: ST_TO_ADDR
// if not cargo then
47103: LD_VAR 0 7
47107: NOT
47108: IFFALSE 47751
// begin if mc_crates_collector [ i ] < 5 then
47110: LD_EXP 116
47114: PUSH
47115: LD_VAR 0 2
47119: ARRAY
47120: PUSH
47121: LD_INT 5
47123: LESS
47124: IFFALSE 47490
// begin if mc_ape [ i ] then
47126: LD_EXP 128
47130: PUSH
47131: LD_VAR 0 2
47135: ARRAY
47136: IFFALSE 47183
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47138: LD_ADDR_VAR 0 5
47142: PUSH
47143: LD_EXP 128
47147: PUSH
47148: LD_VAR 0 2
47152: ARRAY
47153: PPUSH
47154: LD_INT 25
47156: PUSH
47157: LD_INT 16
47159: PUSH
47160: EMPTY
47161: LIST
47162: LIST
47163: PUSH
47164: LD_INT 24
47166: PUSH
47167: LD_INT 750
47169: PUSH
47170: EMPTY
47171: LIST
47172: LIST
47173: PUSH
47174: EMPTY
47175: LIST
47176: LIST
47177: PPUSH
47178: CALL_OW 72
47182: ST_TO_ADDR
// if not tmp then
47183: LD_VAR 0 5
47187: NOT
47188: IFFALSE 47235
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47190: LD_ADDR_VAR 0 5
47194: PUSH
47195: LD_EXP 99
47199: PUSH
47200: LD_VAR 0 2
47204: ARRAY
47205: PPUSH
47206: LD_INT 25
47208: PUSH
47209: LD_INT 2
47211: PUSH
47212: EMPTY
47213: LIST
47214: LIST
47215: PUSH
47216: LD_INT 24
47218: PUSH
47219: LD_INT 750
47221: PUSH
47222: EMPTY
47223: LIST
47224: LIST
47225: PUSH
47226: EMPTY
47227: LIST
47228: LIST
47229: PPUSH
47230: CALL_OW 72
47234: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47235: LD_EXP 128
47239: PUSH
47240: LD_VAR 0 2
47244: ARRAY
47245: PUSH
47246: LD_EXP 99
47250: PUSH
47251: LD_VAR 0 2
47255: ARRAY
47256: PPUSH
47257: LD_INT 25
47259: PUSH
47260: LD_INT 2
47262: PUSH
47263: EMPTY
47264: LIST
47265: LIST
47266: PUSH
47267: LD_INT 24
47269: PUSH
47270: LD_INT 750
47272: PUSH
47273: EMPTY
47274: LIST
47275: LIST
47276: PUSH
47277: EMPTY
47278: LIST
47279: LIST
47280: PPUSH
47281: CALL_OW 72
47285: AND
47286: PUSH
47287: LD_VAR 0 5
47291: PUSH
47292: LD_INT 5
47294: LESS
47295: AND
47296: IFFALSE 47378
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47298: LD_ADDR_VAR 0 3
47302: PUSH
47303: LD_EXP 99
47307: PUSH
47308: LD_VAR 0 2
47312: ARRAY
47313: PPUSH
47314: LD_INT 25
47316: PUSH
47317: LD_INT 2
47319: PUSH
47320: EMPTY
47321: LIST
47322: LIST
47323: PUSH
47324: LD_INT 24
47326: PUSH
47327: LD_INT 750
47329: PUSH
47330: EMPTY
47331: LIST
47332: LIST
47333: PUSH
47334: EMPTY
47335: LIST
47336: LIST
47337: PPUSH
47338: CALL_OW 72
47342: PUSH
47343: FOR_IN
47344: IFFALSE 47376
// begin tmp := tmp union j ;
47346: LD_ADDR_VAR 0 5
47350: PUSH
47351: LD_VAR 0 5
47355: PUSH
47356: LD_VAR 0 3
47360: UNION
47361: ST_TO_ADDR
// if tmp >= 5 then
47362: LD_VAR 0 5
47366: PUSH
47367: LD_INT 5
47369: GREATEREQUAL
47370: IFFALSE 47374
// break ;
47372: GO 47376
// end ;
47374: GO 47343
47376: POP
47377: POP
// end ; if not tmp then
47378: LD_VAR 0 5
47382: NOT
47383: IFFALSE 47387
// continue ;
47385: GO 46599
// for j in tmp do
47387: LD_ADDR_VAR 0 3
47391: PUSH
47392: LD_VAR 0 5
47396: PUSH
47397: FOR_IN
47398: IFFALSE 47488
// if not GetTag ( j ) then
47400: LD_VAR 0 3
47404: PPUSH
47405: CALL_OW 110
47409: NOT
47410: IFFALSE 47486
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47412: LD_ADDR_EXP 116
47416: PUSH
47417: LD_EXP 116
47421: PPUSH
47422: LD_VAR 0 2
47426: PUSH
47427: LD_EXP 116
47431: PUSH
47432: LD_VAR 0 2
47436: ARRAY
47437: PUSH
47438: LD_INT 1
47440: PLUS
47441: PUSH
47442: EMPTY
47443: LIST
47444: LIST
47445: PPUSH
47446: LD_VAR 0 3
47450: PPUSH
47451: CALL 69649 0 3
47455: ST_TO_ADDR
// SetTag ( j , 107 ) ;
47456: LD_VAR 0 3
47460: PPUSH
47461: LD_INT 107
47463: PPUSH
47464: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
47468: LD_EXP 116
47472: PUSH
47473: LD_VAR 0 2
47477: ARRAY
47478: PUSH
47479: LD_INT 5
47481: GREATEREQUAL
47482: IFFALSE 47486
// break ;
47484: GO 47488
// end ;
47486: GO 47397
47488: POP
47489: POP
// end ; if mc_crates_collector [ i ] and target then
47490: LD_EXP 116
47494: PUSH
47495: LD_VAR 0 2
47499: ARRAY
47500: PUSH
47501: LD_VAR 0 6
47505: AND
47506: IFFALSE 47749
// begin if mc_crates_collector [ i ] < target [ 1 ] then
47508: LD_EXP 116
47512: PUSH
47513: LD_VAR 0 2
47517: ARRAY
47518: PUSH
47519: LD_VAR 0 6
47523: PUSH
47524: LD_INT 1
47526: ARRAY
47527: LESS
47528: IFFALSE 47548
// tmp := mc_crates_collector [ i ] else
47530: LD_ADDR_VAR 0 5
47534: PUSH
47535: LD_EXP 116
47539: PUSH
47540: LD_VAR 0 2
47544: ARRAY
47545: ST_TO_ADDR
47546: GO 47562
// tmp := target [ 1 ] ;
47548: LD_ADDR_VAR 0 5
47552: PUSH
47553: LD_VAR 0 6
47557: PUSH
47558: LD_INT 1
47560: ARRAY
47561: ST_TO_ADDR
// k := 0 ;
47562: LD_ADDR_VAR 0 4
47566: PUSH
47567: LD_INT 0
47569: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
47570: LD_ADDR_VAR 0 3
47574: PUSH
47575: LD_EXP 116
47579: PUSH
47580: LD_VAR 0 2
47584: ARRAY
47585: PUSH
47586: FOR_IN
47587: IFFALSE 47747
// begin k := k + 1 ;
47589: LD_ADDR_VAR 0 4
47593: PUSH
47594: LD_VAR 0 4
47598: PUSH
47599: LD_INT 1
47601: PLUS
47602: ST_TO_ADDR
// if k > tmp then
47603: LD_VAR 0 4
47607: PUSH
47608: LD_VAR 0 5
47612: GREATER
47613: IFFALSE 47617
// break ;
47615: GO 47747
// if not GetClass ( j ) in [ 2 , 16 ] then
47617: LD_VAR 0 3
47621: PPUSH
47622: CALL_OW 257
47626: PUSH
47627: LD_INT 2
47629: PUSH
47630: LD_INT 16
47632: PUSH
47633: EMPTY
47634: LIST
47635: LIST
47636: IN
47637: NOT
47638: IFFALSE 47691
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
47640: LD_ADDR_EXP 116
47644: PUSH
47645: LD_EXP 116
47649: PPUSH
47650: LD_VAR 0 2
47654: PPUSH
47655: LD_EXP 116
47659: PUSH
47660: LD_VAR 0 2
47664: ARRAY
47665: PUSH
47666: LD_VAR 0 3
47670: DIFF
47671: PPUSH
47672: CALL_OW 1
47676: ST_TO_ADDR
// SetTag ( j , 0 ) ;
47677: LD_VAR 0 3
47681: PPUSH
47682: LD_INT 0
47684: PPUSH
47685: CALL_OW 109
// continue ;
47689: GO 47586
// end ; if IsInUnit ( j ) then
47691: LD_VAR 0 3
47695: PPUSH
47696: CALL_OW 310
47700: IFFALSE 47711
// ComExitBuilding ( j ) ;
47702: LD_VAR 0 3
47706: PPUSH
47707: CALL_OW 122
// wait ( 3 ) ;
47711: LD_INT 3
47713: PPUSH
47714: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
47718: LD_VAR 0 3
47722: PPUSH
47723: LD_VAR 0 6
47727: PUSH
47728: LD_INT 2
47730: ARRAY
47731: PPUSH
47732: LD_VAR 0 6
47736: PUSH
47737: LD_INT 3
47739: ARRAY
47740: PPUSH
47741: CALL_OW 117
// end ;
47745: GO 47586
47747: POP
47748: POP
// end ; end else
47749: GO 48311
// begin for j in cargo do
47751: LD_ADDR_VAR 0 3
47755: PUSH
47756: LD_VAR 0 7
47760: PUSH
47761: FOR_IN
47762: IFFALSE 48309
// begin if GetTag ( j ) <> 0 then
47764: LD_VAR 0 3
47768: PPUSH
47769: CALL_OW 110
47773: PUSH
47774: LD_INT 0
47776: NONEQUAL
47777: IFFALSE 47781
// continue ;
47779: GO 47761
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
47781: LD_VAR 0 3
47785: PPUSH
47786: CALL_OW 256
47790: PUSH
47791: LD_INT 1000
47793: LESS
47794: PUSH
47795: LD_VAR 0 3
47799: PPUSH
47800: LD_EXP 123
47804: PUSH
47805: LD_VAR 0 2
47809: ARRAY
47810: PPUSH
47811: CALL_OW 308
47815: NOT
47816: AND
47817: IFFALSE 47839
// ComMoveToArea ( j , mc_parking [ i ] ) ;
47819: LD_VAR 0 3
47823: PPUSH
47824: LD_EXP 123
47828: PUSH
47829: LD_VAR 0 2
47833: ARRAY
47834: PPUSH
47835: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
47839: LD_VAR 0 3
47843: PPUSH
47844: CALL_OW 256
47848: PUSH
47849: LD_INT 1000
47851: LESS
47852: PUSH
47853: LD_VAR 0 3
47857: PPUSH
47858: LD_EXP 123
47862: PUSH
47863: LD_VAR 0 2
47867: ARRAY
47868: PPUSH
47869: CALL_OW 308
47873: AND
47874: IFFALSE 47878
// continue ;
47876: GO 47761
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
47878: LD_VAR 0 3
47882: PPUSH
47883: CALL_OW 262
47887: PUSH
47888: LD_INT 2
47890: EQUAL
47891: PUSH
47892: LD_VAR 0 3
47896: PPUSH
47897: CALL_OW 261
47901: PUSH
47902: LD_INT 15
47904: LESS
47905: AND
47906: IFFALSE 47910
// continue ;
47908: GO 47761
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
47910: LD_VAR 0 3
47914: PPUSH
47915: CALL_OW 262
47919: PUSH
47920: LD_INT 1
47922: EQUAL
47923: PUSH
47924: LD_VAR 0 3
47928: PPUSH
47929: CALL_OW 261
47933: PUSH
47934: LD_INT 10
47936: LESS
47937: AND
47938: IFFALSE 48248
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
47940: LD_ADDR_VAR 0 8
47944: PUSH
47945: LD_EXP 99
47949: PUSH
47950: LD_VAR 0 2
47954: ARRAY
47955: PPUSH
47956: LD_INT 2
47958: PUSH
47959: LD_INT 30
47961: PUSH
47962: LD_INT 0
47964: PUSH
47965: EMPTY
47966: LIST
47967: LIST
47968: PUSH
47969: LD_INT 30
47971: PUSH
47972: LD_INT 1
47974: PUSH
47975: EMPTY
47976: LIST
47977: LIST
47978: PUSH
47979: EMPTY
47980: LIST
47981: LIST
47982: LIST
47983: PPUSH
47984: CALL_OW 72
47988: ST_TO_ADDR
// if not depot then
47989: LD_VAR 0 8
47993: NOT
47994: IFFALSE 47998
// continue ;
47996: GO 47761
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
47998: LD_VAR 0 3
48002: PPUSH
48003: LD_VAR 0 8
48007: PPUSH
48008: LD_VAR 0 3
48012: PPUSH
48013: CALL_OW 74
48017: PPUSH
48018: CALL_OW 296
48022: PUSH
48023: LD_INT 6
48025: LESS
48026: IFFALSE 48042
// SetFuel ( j , 100 ) else
48028: LD_VAR 0 3
48032: PPUSH
48033: LD_INT 100
48035: PPUSH
48036: CALL_OW 240
48040: GO 48248
// if GetFuel ( j ) = 0 then
48042: LD_VAR 0 3
48046: PPUSH
48047: CALL_OW 261
48051: PUSH
48052: LD_INT 0
48054: EQUAL
48055: IFFALSE 48248
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48057: LD_ADDR_EXP 118
48061: PUSH
48062: LD_EXP 118
48066: PPUSH
48067: LD_VAR 0 2
48071: PPUSH
48072: LD_EXP 118
48076: PUSH
48077: LD_VAR 0 2
48081: ARRAY
48082: PUSH
48083: LD_VAR 0 3
48087: DIFF
48088: PPUSH
48089: CALL_OW 1
48093: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48094: LD_VAR 0 3
48098: PPUSH
48099: CALL_OW 263
48103: PUSH
48104: LD_INT 1
48106: EQUAL
48107: IFFALSE 48123
// ComExitVehicle ( IsInUnit ( j ) ) ;
48109: LD_VAR 0 3
48113: PPUSH
48114: CALL_OW 310
48118: PPUSH
48119: CALL_OW 121
// if GetControl ( j ) = control_remote then
48123: LD_VAR 0 3
48127: PPUSH
48128: CALL_OW 263
48132: PUSH
48133: LD_INT 2
48135: EQUAL
48136: IFFALSE 48147
// ComUnlink ( j ) ;
48138: LD_VAR 0 3
48142: PPUSH
48143: CALL_OW 136
// fac := MC_GetBuilding ( i , b_factory ) ;
48147: LD_ADDR_VAR 0 9
48151: PUSH
48152: LD_VAR 0 2
48156: PPUSH
48157: LD_INT 3
48159: PPUSH
48160: CALL 57294 0 2
48164: ST_TO_ADDR
// if fac then
48165: LD_VAR 0 9
48169: IFFALSE 48246
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48171: LD_ADDR_VAR 0 10
48175: PUSH
48176: LD_VAR 0 9
48180: PPUSH
48181: LD_VAR 0 3
48185: PPUSH
48186: CALL_OW 265
48190: PPUSH
48191: LD_VAR 0 3
48195: PPUSH
48196: CALL_OW 262
48200: PPUSH
48201: LD_VAR 0 3
48205: PPUSH
48206: CALL_OW 263
48210: PPUSH
48211: LD_VAR 0 3
48215: PPUSH
48216: CALL_OW 264
48220: PPUSH
48221: CALL 67242 0 5
48225: ST_TO_ADDR
// if components then
48226: LD_VAR 0 10
48230: IFFALSE 48246
// MC_InsertProduceList ( i , components ) ;
48232: LD_VAR 0 2
48236: PPUSH
48237: LD_VAR 0 10
48241: PPUSH
48242: CALL 56922 0 2
// end ; continue ;
48246: GO 47761
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48248: LD_VAR 0 3
48252: PPUSH
48253: LD_INT 1
48255: PPUSH
48256: CALL_OW 289
48260: PUSH
48261: LD_INT 100
48263: LESS
48264: PUSH
48265: LD_VAR 0 3
48269: PPUSH
48270: CALL_OW 314
48274: NOT
48275: AND
48276: IFFALSE 48305
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48278: LD_VAR 0 3
48282: PPUSH
48283: LD_VAR 0 6
48287: PUSH
48288: LD_INT 2
48290: ARRAY
48291: PPUSH
48292: LD_VAR 0 6
48296: PUSH
48297: LD_INT 3
48299: ARRAY
48300: PPUSH
48301: CALL_OW 117
// break ;
48305: GO 48309
// end ;
48307: GO 47761
48309: POP
48310: POP
// end ; end ;
48311: GO 46599
48313: POP
48314: POP
// end ;
48315: LD_VAR 0 1
48319: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48320: LD_INT 0
48322: PPUSH
48323: PPUSH
48324: PPUSH
48325: PPUSH
// if not mc_bases then
48326: LD_EXP 99
48330: NOT
48331: IFFALSE 48335
// exit ;
48333: GO 48496
// for i = 1 to mc_bases do
48335: LD_ADDR_VAR 0 2
48339: PUSH
48340: DOUBLE
48341: LD_INT 1
48343: DEC
48344: ST_TO_ADDR
48345: LD_EXP 99
48349: PUSH
48350: FOR_TO
48351: IFFALSE 48494
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48353: LD_ADDR_VAR 0 4
48357: PUSH
48358: LD_EXP 118
48362: PUSH
48363: LD_VAR 0 2
48367: ARRAY
48368: PUSH
48369: LD_EXP 121
48373: PUSH
48374: LD_VAR 0 2
48378: ARRAY
48379: UNION
48380: PPUSH
48381: LD_INT 33
48383: PUSH
48384: LD_INT 2
48386: PUSH
48387: EMPTY
48388: LIST
48389: LIST
48390: PPUSH
48391: CALL_OW 72
48395: ST_TO_ADDR
// if tmp then
48396: LD_VAR 0 4
48400: IFFALSE 48492
// for j in tmp do
48402: LD_ADDR_VAR 0 3
48406: PUSH
48407: LD_VAR 0 4
48411: PUSH
48412: FOR_IN
48413: IFFALSE 48490
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48415: LD_VAR 0 3
48419: PPUSH
48420: CALL_OW 312
48424: NOT
48425: PUSH
48426: LD_VAR 0 3
48430: PPUSH
48431: CALL_OW 256
48435: PUSH
48436: LD_INT 250
48438: GREATEREQUAL
48439: AND
48440: IFFALSE 48453
// Connect ( j ) else
48442: LD_VAR 0 3
48446: PPUSH
48447: CALL 72582 0 1
48451: GO 48488
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
48453: LD_VAR 0 3
48457: PPUSH
48458: CALL_OW 256
48462: PUSH
48463: LD_INT 250
48465: LESS
48466: PUSH
48467: LD_VAR 0 3
48471: PPUSH
48472: CALL_OW 312
48476: AND
48477: IFFALSE 48488
// ComUnlink ( j ) ;
48479: LD_VAR 0 3
48483: PPUSH
48484: CALL_OW 136
48488: GO 48412
48490: POP
48491: POP
// end ;
48492: GO 48350
48494: POP
48495: POP
// end ;
48496: LD_VAR 0 1
48500: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
48501: LD_INT 0
48503: PPUSH
48504: PPUSH
48505: PPUSH
48506: PPUSH
48507: PPUSH
// if not mc_bases then
48508: LD_EXP 99
48512: NOT
48513: IFFALSE 48517
// exit ;
48515: GO 48977
// for i = 1 to mc_bases do
48517: LD_ADDR_VAR 0 2
48521: PUSH
48522: DOUBLE
48523: LD_INT 1
48525: DEC
48526: ST_TO_ADDR
48527: LD_EXP 99
48531: PUSH
48532: FOR_TO
48533: IFFALSE 48975
// begin if not mc_produce [ i ] then
48535: LD_EXP 120
48539: PUSH
48540: LD_VAR 0 2
48544: ARRAY
48545: NOT
48546: IFFALSE 48550
// continue ;
48548: GO 48532
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
48550: LD_ADDR_VAR 0 5
48554: PUSH
48555: LD_EXP 99
48559: PUSH
48560: LD_VAR 0 2
48564: ARRAY
48565: PPUSH
48566: LD_INT 30
48568: PUSH
48569: LD_INT 3
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: PPUSH
48576: CALL_OW 72
48580: ST_TO_ADDR
// if not fac then
48581: LD_VAR 0 5
48585: NOT
48586: IFFALSE 48590
// continue ;
48588: GO 48532
// for j in fac do
48590: LD_ADDR_VAR 0 3
48594: PUSH
48595: LD_VAR 0 5
48599: PUSH
48600: FOR_IN
48601: IFFALSE 48971
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] or UnitsInside ( j ) = 0 then
48603: LD_VAR 0 3
48607: PPUSH
48608: CALL_OW 461
48612: PUSH
48613: LD_INT 2
48615: NONEQUAL
48616: PUSH
48617: LD_VAR 0 3
48621: PPUSH
48622: LD_INT 15
48624: PPUSH
48625: CALL 72242 0 2
48629: PUSH
48630: LD_INT 4
48632: ARRAY
48633: OR
48634: PUSH
48635: LD_VAR 0 3
48639: PPUSH
48640: CALL_OW 313
48644: PUSH
48645: LD_INT 0
48647: EQUAL
48648: OR
48649: IFFALSE 48653
// continue ;
48651: GO 48600
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
48653: LD_VAR 0 3
48657: PPUSH
48658: LD_EXP 120
48662: PUSH
48663: LD_VAR 0 2
48667: ARRAY
48668: PUSH
48669: LD_INT 1
48671: ARRAY
48672: PUSH
48673: LD_INT 1
48675: ARRAY
48676: PPUSH
48677: LD_EXP 120
48681: PUSH
48682: LD_VAR 0 2
48686: ARRAY
48687: PUSH
48688: LD_INT 1
48690: ARRAY
48691: PUSH
48692: LD_INT 2
48694: ARRAY
48695: PPUSH
48696: LD_EXP 120
48700: PUSH
48701: LD_VAR 0 2
48705: ARRAY
48706: PUSH
48707: LD_INT 1
48709: ARRAY
48710: PUSH
48711: LD_INT 3
48713: ARRAY
48714: PPUSH
48715: LD_EXP 120
48719: PUSH
48720: LD_VAR 0 2
48724: ARRAY
48725: PUSH
48726: LD_INT 1
48728: ARRAY
48729: PUSH
48730: LD_INT 4
48732: ARRAY
48733: PPUSH
48734: CALL_OW 448
48738: PUSH
48739: LD_VAR 0 3
48743: PPUSH
48744: LD_EXP 120
48748: PUSH
48749: LD_VAR 0 2
48753: ARRAY
48754: PUSH
48755: LD_INT 1
48757: ARRAY
48758: PUSH
48759: LD_INT 1
48761: ARRAY
48762: PUSH
48763: LD_EXP 120
48767: PUSH
48768: LD_VAR 0 2
48772: ARRAY
48773: PUSH
48774: LD_INT 1
48776: ARRAY
48777: PUSH
48778: LD_INT 2
48780: ARRAY
48781: PUSH
48782: LD_EXP 120
48786: PUSH
48787: LD_VAR 0 2
48791: ARRAY
48792: PUSH
48793: LD_INT 1
48795: ARRAY
48796: PUSH
48797: LD_INT 3
48799: ARRAY
48800: PUSH
48801: LD_EXP 120
48805: PUSH
48806: LD_VAR 0 2
48810: ARRAY
48811: PUSH
48812: LD_INT 1
48814: ARRAY
48815: PUSH
48816: LD_INT 4
48818: ARRAY
48819: PUSH
48820: EMPTY
48821: LIST
48822: LIST
48823: LIST
48824: LIST
48825: PPUSH
48826: CALL 75913 0 2
48830: AND
48831: IFFALSE 48969
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
48833: LD_VAR 0 3
48837: PPUSH
48838: LD_EXP 120
48842: PUSH
48843: LD_VAR 0 2
48847: ARRAY
48848: PUSH
48849: LD_INT 1
48851: ARRAY
48852: PUSH
48853: LD_INT 1
48855: ARRAY
48856: PPUSH
48857: LD_EXP 120
48861: PUSH
48862: LD_VAR 0 2
48866: ARRAY
48867: PUSH
48868: LD_INT 1
48870: ARRAY
48871: PUSH
48872: LD_INT 2
48874: ARRAY
48875: PPUSH
48876: LD_EXP 120
48880: PUSH
48881: LD_VAR 0 2
48885: ARRAY
48886: PUSH
48887: LD_INT 1
48889: ARRAY
48890: PUSH
48891: LD_INT 3
48893: ARRAY
48894: PPUSH
48895: LD_EXP 120
48899: PUSH
48900: LD_VAR 0 2
48904: ARRAY
48905: PUSH
48906: LD_INT 1
48908: ARRAY
48909: PUSH
48910: LD_INT 4
48912: ARRAY
48913: PPUSH
48914: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
48918: LD_ADDR_VAR 0 4
48922: PUSH
48923: LD_EXP 120
48927: PUSH
48928: LD_VAR 0 2
48932: ARRAY
48933: PPUSH
48934: LD_INT 1
48936: PPUSH
48937: CALL_OW 3
48941: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
48942: LD_ADDR_EXP 120
48946: PUSH
48947: LD_EXP 120
48951: PPUSH
48952: LD_VAR 0 2
48956: PPUSH
48957: LD_VAR 0 4
48961: PPUSH
48962: CALL_OW 1
48966: ST_TO_ADDR
// break ;
48967: GO 48971
// end ; end ;
48969: GO 48600
48971: POP
48972: POP
// end ;
48973: GO 48532
48975: POP
48976: POP
// end ;
48977: LD_VAR 0 1
48981: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
48982: LD_INT 0
48984: PPUSH
48985: PPUSH
48986: PPUSH
// if not mc_bases then
48987: LD_EXP 99
48991: NOT
48992: IFFALSE 48996
// exit ;
48994: GO 49085
// for i = 1 to mc_bases do
48996: LD_ADDR_VAR 0 2
49000: PUSH
49001: DOUBLE
49002: LD_INT 1
49004: DEC
49005: ST_TO_ADDR
49006: LD_EXP 99
49010: PUSH
49011: FOR_TO
49012: IFFALSE 49083
// begin if mc_attack [ i ] then
49014: LD_EXP 119
49018: PUSH
49019: LD_VAR 0 2
49023: ARRAY
49024: IFFALSE 49081
// begin tmp := mc_attack [ i ] [ 1 ] ;
49026: LD_ADDR_VAR 0 3
49030: PUSH
49031: LD_EXP 119
49035: PUSH
49036: LD_VAR 0 2
49040: ARRAY
49041: PUSH
49042: LD_INT 1
49044: ARRAY
49045: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49046: LD_ADDR_EXP 119
49050: PUSH
49051: LD_EXP 119
49055: PPUSH
49056: LD_VAR 0 2
49060: PPUSH
49061: EMPTY
49062: PPUSH
49063: CALL_OW 1
49067: ST_TO_ADDR
// Attack ( tmp ) ;
49068: LD_VAR 0 3
49072: PPUSH
49073: CALL 98126 0 1
// exit ;
49077: POP
49078: POP
49079: GO 49085
// end ; end ;
49081: GO 49011
49083: POP
49084: POP
// end ;
49085: LD_VAR 0 1
49089: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49090: LD_INT 0
49092: PPUSH
49093: PPUSH
49094: PPUSH
49095: PPUSH
49096: PPUSH
49097: PPUSH
49098: PPUSH
// if not mc_bases then
49099: LD_EXP 99
49103: NOT
49104: IFFALSE 49108
// exit ;
49106: GO 49690
// for i = 1 to mc_bases do
49108: LD_ADDR_VAR 0 2
49112: PUSH
49113: DOUBLE
49114: LD_INT 1
49116: DEC
49117: ST_TO_ADDR
49118: LD_EXP 99
49122: PUSH
49123: FOR_TO
49124: IFFALSE 49688
// begin if not mc_bases [ i ] then
49126: LD_EXP 99
49130: PUSH
49131: LD_VAR 0 2
49135: ARRAY
49136: NOT
49137: IFFALSE 49141
// continue ;
49139: GO 49123
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49141: LD_ADDR_VAR 0 7
49145: PUSH
49146: LD_EXP 99
49150: PUSH
49151: LD_VAR 0 2
49155: ARRAY
49156: PUSH
49157: LD_INT 1
49159: ARRAY
49160: PPUSH
49161: CALL 66546 0 1
49165: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49166: LD_ADDR_EXP 122
49170: PUSH
49171: LD_EXP 122
49175: PPUSH
49176: LD_VAR 0 2
49180: PPUSH
49181: LD_EXP 99
49185: PUSH
49186: LD_VAR 0 2
49190: ARRAY
49191: PUSH
49192: LD_INT 1
49194: ARRAY
49195: PPUSH
49196: CALL_OW 255
49200: PPUSH
49201: LD_EXP 124
49205: PUSH
49206: LD_VAR 0 2
49210: ARRAY
49211: PPUSH
49212: CALL 64543 0 2
49216: PPUSH
49217: CALL_OW 1
49221: ST_TO_ADDR
// if not mc_scan [ i ] then
49222: LD_EXP 122
49226: PUSH
49227: LD_VAR 0 2
49231: ARRAY
49232: NOT
49233: IFFALSE 49388
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49235: LD_ADDR_VAR 0 4
49239: PUSH
49240: LD_EXP 99
49244: PUSH
49245: LD_VAR 0 2
49249: ARRAY
49250: PPUSH
49251: LD_INT 2
49253: PUSH
49254: LD_INT 25
49256: PUSH
49257: LD_INT 5
49259: PUSH
49260: EMPTY
49261: LIST
49262: LIST
49263: PUSH
49264: LD_INT 25
49266: PUSH
49267: LD_INT 8
49269: PUSH
49270: EMPTY
49271: LIST
49272: LIST
49273: PUSH
49274: LD_INT 25
49276: PUSH
49277: LD_INT 9
49279: PUSH
49280: EMPTY
49281: LIST
49282: LIST
49283: PUSH
49284: EMPTY
49285: LIST
49286: LIST
49287: LIST
49288: LIST
49289: PPUSH
49290: CALL_OW 72
49294: ST_TO_ADDR
// if not tmp then
49295: LD_VAR 0 4
49299: NOT
49300: IFFALSE 49304
// continue ;
49302: GO 49123
// for j in tmp do
49304: LD_ADDR_VAR 0 3
49308: PUSH
49309: LD_VAR 0 4
49313: PUSH
49314: FOR_IN
49315: IFFALSE 49386
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49317: LD_VAR 0 3
49321: PPUSH
49322: CALL_OW 310
49326: PPUSH
49327: CALL_OW 266
49331: PUSH
49332: LD_INT 5
49334: EQUAL
49335: PUSH
49336: LD_VAR 0 3
49340: PPUSH
49341: CALL_OW 257
49345: PUSH
49346: LD_INT 1
49348: EQUAL
49349: AND
49350: PUSH
49351: LD_VAR 0 3
49355: PPUSH
49356: CALL_OW 459
49360: NOT
49361: AND
49362: PUSH
49363: LD_VAR 0 7
49367: AND
49368: IFFALSE 49384
// ComChangeProfession ( j , class ) ;
49370: LD_VAR 0 3
49374: PPUSH
49375: LD_VAR 0 7
49379: PPUSH
49380: CALL_OW 123
49384: GO 49314
49386: POP
49387: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49388: LD_EXP 122
49392: PUSH
49393: LD_VAR 0 2
49397: ARRAY
49398: PUSH
49399: LD_EXP 121
49403: PUSH
49404: LD_VAR 0 2
49408: ARRAY
49409: NOT
49410: AND
49411: PUSH
49412: LD_EXP 99
49416: PUSH
49417: LD_VAR 0 2
49421: ARRAY
49422: PPUSH
49423: LD_INT 30
49425: PUSH
49426: LD_INT 32
49428: PUSH
49429: EMPTY
49430: LIST
49431: LIST
49432: PPUSH
49433: CALL_OW 72
49437: NOT
49438: AND
49439: PUSH
49440: LD_EXP 99
49444: PUSH
49445: LD_VAR 0 2
49449: ARRAY
49450: PPUSH
49451: LD_INT 2
49453: PUSH
49454: LD_INT 30
49456: PUSH
49457: LD_INT 4
49459: PUSH
49460: EMPTY
49461: LIST
49462: LIST
49463: PUSH
49464: LD_INT 30
49466: PUSH
49467: LD_INT 5
49469: PUSH
49470: EMPTY
49471: LIST
49472: LIST
49473: PUSH
49474: EMPTY
49475: LIST
49476: LIST
49477: LIST
49478: PPUSH
49479: CALL_OW 72
49483: NOT
49484: AND
49485: IFFALSE 49617
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49487: LD_ADDR_VAR 0 4
49491: PUSH
49492: LD_EXP 99
49496: PUSH
49497: LD_VAR 0 2
49501: ARRAY
49502: PPUSH
49503: LD_INT 2
49505: PUSH
49506: LD_INT 25
49508: PUSH
49509: LD_INT 1
49511: PUSH
49512: EMPTY
49513: LIST
49514: LIST
49515: PUSH
49516: LD_INT 25
49518: PUSH
49519: LD_INT 5
49521: PUSH
49522: EMPTY
49523: LIST
49524: LIST
49525: PUSH
49526: LD_INT 25
49528: PUSH
49529: LD_INT 8
49531: PUSH
49532: EMPTY
49533: LIST
49534: LIST
49535: PUSH
49536: LD_INT 25
49538: PUSH
49539: LD_INT 9
49541: PUSH
49542: EMPTY
49543: LIST
49544: LIST
49545: PUSH
49546: EMPTY
49547: LIST
49548: LIST
49549: LIST
49550: LIST
49551: LIST
49552: PPUSH
49553: CALL_OW 72
49557: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
49558: LD_ADDR_VAR 0 4
49562: PUSH
49563: LD_VAR 0 4
49567: PUSH
49568: LD_VAR 0 4
49572: PPUSH
49573: LD_INT 18
49575: PPUSH
49576: CALL 102909 0 2
49580: DIFF
49581: ST_TO_ADDR
// if tmp then
49582: LD_VAR 0 4
49586: IFFALSE 49617
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
49588: LD_VAR 0 2
49592: PPUSH
49593: LD_VAR 0 4
49597: PPUSH
49598: LD_EXP 124
49602: PUSH
49603: LD_VAR 0 2
49607: ARRAY
49608: PPUSH
49609: CALL 64578 0 3
// exit ;
49613: POP
49614: POP
49615: GO 49690
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
49617: LD_EXP 122
49621: PUSH
49622: LD_VAR 0 2
49626: ARRAY
49627: PUSH
49628: LD_EXP 121
49632: PUSH
49633: LD_VAR 0 2
49637: ARRAY
49638: AND
49639: IFFALSE 49686
// begin tmp := mc_defender [ i ] ;
49641: LD_ADDR_VAR 0 4
49645: PUSH
49646: LD_EXP 121
49650: PUSH
49651: LD_VAR 0 2
49655: ARRAY
49656: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
49657: LD_VAR 0 2
49661: PPUSH
49662: LD_VAR 0 4
49666: PPUSH
49667: LD_EXP 122
49671: PUSH
49672: LD_VAR 0 2
49676: ARRAY
49677: PPUSH
49678: CALL 65076 0 3
// exit ;
49682: POP
49683: POP
49684: GO 49690
// end ; end ;
49686: GO 49123
49688: POP
49689: POP
// end ;
49690: LD_VAR 0 1
49694: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
49695: LD_INT 0
49697: PPUSH
49698: PPUSH
49699: PPUSH
49700: PPUSH
49701: PPUSH
49702: PPUSH
49703: PPUSH
49704: PPUSH
49705: PPUSH
49706: PPUSH
49707: PPUSH
// if not mc_bases then
49708: LD_EXP 99
49712: NOT
49713: IFFALSE 49717
// exit ;
49715: GO 50804
// for i = 1 to mc_bases do
49717: LD_ADDR_VAR 0 2
49721: PUSH
49722: DOUBLE
49723: LD_INT 1
49725: DEC
49726: ST_TO_ADDR
49727: LD_EXP 99
49731: PUSH
49732: FOR_TO
49733: IFFALSE 50802
// begin tmp := mc_lab [ i ] ;
49735: LD_ADDR_VAR 0 6
49739: PUSH
49740: LD_EXP 132
49744: PUSH
49745: LD_VAR 0 2
49749: ARRAY
49750: ST_TO_ADDR
// if not tmp then
49751: LD_VAR 0 6
49755: NOT
49756: IFFALSE 49760
// continue ;
49758: GO 49732
// idle_lab := 0 ;
49760: LD_ADDR_VAR 0 11
49764: PUSH
49765: LD_INT 0
49767: ST_TO_ADDR
// for j in tmp do
49768: LD_ADDR_VAR 0 3
49772: PUSH
49773: LD_VAR 0 6
49777: PUSH
49778: FOR_IN
49779: IFFALSE 50798
// begin researching := false ;
49781: LD_ADDR_VAR 0 10
49785: PUSH
49786: LD_INT 0
49788: ST_TO_ADDR
// side := GetSide ( j ) ;
49789: LD_ADDR_VAR 0 4
49793: PUSH
49794: LD_VAR 0 3
49798: PPUSH
49799: CALL_OW 255
49803: ST_TO_ADDR
// if not mc_tech [ side ] then
49804: LD_EXP 126
49808: PUSH
49809: LD_VAR 0 4
49813: ARRAY
49814: NOT
49815: IFFALSE 49819
// continue ;
49817: GO 49778
// if BuildingStatus ( j ) = bs_idle then
49819: LD_VAR 0 3
49823: PPUSH
49824: CALL_OW 461
49828: PUSH
49829: LD_INT 2
49831: EQUAL
49832: IFFALSE 50020
// begin if idle_lab and UnitsInside ( j ) < 6 then
49834: LD_VAR 0 11
49838: PUSH
49839: LD_VAR 0 3
49843: PPUSH
49844: CALL_OW 313
49848: PUSH
49849: LD_INT 6
49851: LESS
49852: AND
49853: IFFALSE 49924
// begin tmp2 := UnitsInside ( idle_lab ) ;
49855: LD_ADDR_VAR 0 9
49859: PUSH
49860: LD_VAR 0 11
49864: PPUSH
49865: CALL_OW 313
49869: ST_TO_ADDR
// if tmp2 then
49870: LD_VAR 0 9
49874: IFFALSE 49916
// for x in tmp2 do
49876: LD_ADDR_VAR 0 7
49880: PUSH
49881: LD_VAR 0 9
49885: PUSH
49886: FOR_IN
49887: IFFALSE 49914
// begin ComExitBuilding ( x ) ;
49889: LD_VAR 0 7
49893: PPUSH
49894: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
49898: LD_VAR 0 7
49902: PPUSH
49903: LD_VAR 0 3
49907: PPUSH
49908: CALL_OW 180
// end ;
49912: GO 49886
49914: POP
49915: POP
// idle_lab := 0 ;
49916: LD_ADDR_VAR 0 11
49920: PUSH
49921: LD_INT 0
49923: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
49924: LD_ADDR_VAR 0 5
49928: PUSH
49929: LD_EXP 126
49933: PUSH
49934: LD_VAR 0 4
49938: ARRAY
49939: PUSH
49940: FOR_IN
49941: IFFALSE 50001
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
49943: LD_VAR 0 3
49947: PPUSH
49948: LD_VAR 0 5
49952: PPUSH
49953: CALL_OW 430
49957: PUSH
49958: LD_VAR 0 4
49962: PPUSH
49963: LD_VAR 0 5
49967: PPUSH
49968: CALL 63648 0 2
49972: AND
49973: IFFALSE 49999
// begin researching := true ;
49975: LD_ADDR_VAR 0 10
49979: PUSH
49980: LD_INT 1
49982: ST_TO_ADDR
// ComResearch ( j , t ) ;
49983: LD_VAR 0 3
49987: PPUSH
49988: LD_VAR 0 5
49992: PPUSH
49993: CALL_OW 124
// break ;
49997: GO 50001
// end ;
49999: GO 49940
50001: POP
50002: POP
// if not researching then
50003: LD_VAR 0 10
50007: NOT
50008: IFFALSE 50020
// idle_lab := j ;
50010: LD_ADDR_VAR 0 11
50014: PUSH
50015: LD_VAR 0 3
50019: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50020: LD_VAR 0 3
50024: PPUSH
50025: CALL_OW 461
50029: PUSH
50030: LD_INT 10
50032: EQUAL
50033: IFFALSE 50621
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50035: LD_EXP 128
50039: PUSH
50040: LD_VAR 0 2
50044: ARRAY
50045: NOT
50046: PUSH
50047: LD_EXP 129
50051: PUSH
50052: LD_VAR 0 2
50056: ARRAY
50057: NOT
50058: AND
50059: PUSH
50060: LD_EXP 126
50064: PUSH
50065: LD_VAR 0 4
50069: ARRAY
50070: PUSH
50071: LD_INT 1
50073: GREATER
50074: AND
50075: IFFALSE 50206
// begin ComCancel ( j ) ;
50077: LD_VAR 0 3
50081: PPUSH
50082: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50086: LD_ADDR_EXP 126
50090: PUSH
50091: LD_EXP 126
50095: PPUSH
50096: LD_VAR 0 4
50100: PPUSH
50101: LD_EXP 126
50105: PUSH
50106: LD_VAR 0 4
50110: ARRAY
50111: PPUSH
50112: LD_EXP 126
50116: PUSH
50117: LD_VAR 0 4
50121: ARRAY
50122: PUSH
50123: LD_INT 1
50125: MINUS
50126: PPUSH
50127: LD_EXP 126
50131: PUSH
50132: LD_VAR 0 4
50136: ARRAY
50137: PPUSH
50138: LD_INT 0
50140: PPUSH
50141: CALL 69067 0 4
50145: PPUSH
50146: CALL_OW 1
50150: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50151: LD_ADDR_EXP 126
50155: PUSH
50156: LD_EXP 126
50160: PPUSH
50161: LD_VAR 0 4
50165: PPUSH
50166: LD_EXP 126
50170: PUSH
50171: LD_VAR 0 4
50175: ARRAY
50176: PPUSH
50177: LD_EXP 126
50181: PUSH
50182: LD_VAR 0 4
50186: ARRAY
50187: PPUSH
50188: LD_INT 1
50190: PPUSH
50191: LD_INT 0
50193: PPUSH
50194: CALL 69067 0 4
50198: PPUSH
50199: CALL_OW 1
50203: ST_TO_ADDR
// continue ;
50204: GO 49778
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50206: LD_EXP 128
50210: PUSH
50211: LD_VAR 0 2
50215: ARRAY
50216: PUSH
50217: LD_EXP 129
50221: PUSH
50222: LD_VAR 0 2
50226: ARRAY
50227: NOT
50228: AND
50229: IFFALSE 50356
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50231: LD_ADDR_EXP 129
50235: PUSH
50236: LD_EXP 129
50240: PPUSH
50241: LD_VAR 0 2
50245: PUSH
50246: LD_EXP 129
50250: PUSH
50251: LD_VAR 0 2
50255: ARRAY
50256: PUSH
50257: LD_INT 1
50259: PLUS
50260: PUSH
50261: EMPTY
50262: LIST
50263: LIST
50264: PPUSH
50265: LD_EXP 128
50269: PUSH
50270: LD_VAR 0 2
50274: ARRAY
50275: PUSH
50276: LD_INT 1
50278: ARRAY
50279: PPUSH
50280: CALL 69649 0 3
50284: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50285: LD_EXP 128
50289: PUSH
50290: LD_VAR 0 2
50294: ARRAY
50295: PUSH
50296: LD_INT 1
50298: ARRAY
50299: PPUSH
50300: LD_INT 112
50302: PPUSH
50303: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50307: LD_ADDR_VAR 0 9
50311: PUSH
50312: LD_EXP 128
50316: PUSH
50317: LD_VAR 0 2
50321: ARRAY
50322: PPUSH
50323: LD_INT 1
50325: PPUSH
50326: CALL_OW 3
50330: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50331: LD_ADDR_EXP 128
50335: PUSH
50336: LD_EXP 128
50340: PPUSH
50341: LD_VAR 0 2
50345: PPUSH
50346: LD_VAR 0 9
50350: PPUSH
50351: CALL_OW 1
50355: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50356: LD_EXP 128
50360: PUSH
50361: LD_VAR 0 2
50365: ARRAY
50366: PUSH
50367: LD_EXP 129
50371: PUSH
50372: LD_VAR 0 2
50376: ARRAY
50377: AND
50378: PUSH
50379: LD_EXP 129
50383: PUSH
50384: LD_VAR 0 2
50388: ARRAY
50389: PUSH
50390: LD_INT 1
50392: ARRAY
50393: PPUSH
50394: CALL_OW 310
50398: NOT
50399: AND
50400: PUSH
50401: LD_VAR 0 3
50405: PPUSH
50406: CALL_OW 313
50410: PUSH
50411: LD_INT 6
50413: EQUAL
50414: AND
50415: IFFALSE 50471
// begin tmp2 := UnitsInside ( j ) ;
50417: LD_ADDR_VAR 0 9
50421: PUSH
50422: LD_VAR 0 3
50426: PPUSH
50427: CALL_OW 313
50431: ST_TO_ADDR
// if tmp2 = 6 then
50432: LD_VAR 0 9
50436: PUSH
50437: LD_INT 6
50439: EQUAL
50440: IFFALSE 50471
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
50442: LD_VAR 0 9
50446: PUSH
50447: LD_INT 1
50449: ARRAY
50450: PPUSH
50451: LD_INT 112
50453: PPUSH
50454: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
50458: LD_VAR 0 9
50462: PUSH
50463: LD_INT 1
50465: ARRAY
50466: PPUSH
50467: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
50471: LD_EXP 129
50475: PUSH
50476: LD_VAR 0 2
50480: ARRAY
50481: PUSH
50482: LD_EXP 129
50486: PUSH
50487: LD_VAR 0 2
50491: ARRAY
50492: PUSH
50493: LD_INT 1
50495: ARRAY
50496: PPUSH
50497: CALL_OW 314
50501: NOT
50502: AND
50503: PUSH
50504: LD_EXP 129
50508: PUSH
50509: LD_VAR 0 2
50513: ARRAY
50514: PUSH
50515: LD_INT 1
50517: ARRAY
50518: PPUSH
50519: CALL_OW 310
50523: NOT
50524: AND
50525: IFFALSE 50551
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
50527: LD_EXP 129
50531: PUSH
50532: LD_VAR 0 2
50536: ARRAY
50537: PUSH
50538: LD_INT 1
50540: ARRAY
50541: PPUSH
50542: LD_VAR 0 3
50546: PPUSH
50547: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
50551: LD_EXP 129
50555: PUSH
50556: LD_VAR 0 2
50560: ARRAY
50561: PUSH
50562: LD_INT 1
50564: ARRAY
50565: PPUSH
50566: CALL_OW 310
50570: PUSH
50571: LD_EXP 129
50575: PUSH
50576: LD_VAR 0 2
50580: ARRAY
50581: PUSH
50582: LD_INT 1
50584: ARRAY
50585: PPUSH
50586: CALL_OW 310
50590: PPUSH
50591: CALL_OW 461
50595: PUSH
50596: LD_INT 3
50598: NONEQUAL
50599: AND
50600: IFFALSE 50621
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
50602: LD_EXP 129
50606: PUSH
50607: LD_VAR 0 2
50611: ARRAY
50612: PUSH
50613: LD_INT 1
50615: ARRAY
50616: PPUSH
50617: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
50621: LD_VAR 0 3
50625: PPUSH
50626: CALL_OW 461
50630: PUSH
50631: LD_INT 6
50633: EQUAL
50634: PUSH
50635: LD_VAR 0 6
50639: PUSH
50640: LD_INT 1
50642: GREATER
50643: AND
50644: IFFALSE 50796
// begin sci := [ ] ;
50646: LD_ADDR_VAR 0 8
50650: PUSH
50651: EMPTY
50652: ST_TO_ADDR
// for x in ( tmp diff j ) do
50653: LD_ADDR_VAR 0 7
50657: PUSH
50658: LD_VAR 0 6
50662: PUSH
50663: LD_VAR 0 3
50667: DIFF
50668: PUSH
50669: FOR_IN
50670: IFFALSE 50722
// begin if sci = 6 then
50672: LD_VAR 0 8
50676: PUSH
50677: LD_INT 6
50679: EQUAL
50680: IFFALSE 50684
// break ;
50682: GO 50722
// if BuildingStatus ( x ) = bs_idle then
50684: LD_VAR 0 7
50688: PPUSH
50689: CALL_OW 461
50693: PUSH
50694: LD_INT 2
50696: EQUAL
50697: IFFALSE 50720
// sci := sci ^ UnitsInside ( x ) ;
50699: LD_ADDR_VAR 0 8
50703: PUSH
50704: LD_VAR 0 8
50708: PUSH
50709: LD_VAR 0 7
50713: PPUSH
50714: CALL_OW 313
50718: ADD
50719: ST_TO_ADDR
// end ;
50720: GO 50669
50722: POP
50723: POP
// if not sci then
50724: LD_VAR 0 8
50728: NOT
50729: IFFALSE 50733
// continue ;
50731: GO 49778
// for x in sci do
50733: LD_ADDR_VAR 0 7
50737: PUSH
50738: LD_VAR 0 8
50742: PUSH
50743: FOR_IN
50744: IFFALSE 50794
// if IsInUnit ( x ) and not HasTask ( x ) then
50746: LD_VAR 0 7
50750: PPUSH
50751: CALL_OW 310
50755: PUSH
50756: LD_VAR 0 7
50760: PPUSH
50761: CALL_OW 314
50765: NOT
50766: AND
50767: IFFALSE 50792
// begin ComExitBuilding ( x ) ;
50769: LD_VAR 0 7
50773: PPUSH
50774: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50778: LD_VAR 0 7
50782: PPUSH
50783: LD_VAR 0 3
50787: PPUSH
50788: CALL_OW 180
// end ;
50792: GO 50743
50794: POP
50795: POP
// end ; end ;
50796: GO 49778
50798: POP
50799: POP
// end ;
50800: GO 49732
50802: POP
50803: POP
// end ;
50804: LD_VAR 0 1
50808: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
50809: LD_INT 0
50811: PPUSH
50812: PPUSH
// if not mc_bases then
50813: LD_EXP 99
50817: NOT
50818: IFFALSE 50822
// exit ;
50820: GO 50903
// for i = 1 to mc_bases do
50822: LD_ADDR_VAR 0 2
50826: PUSH
50827: DOUBLE
50828: LD_INT 1
50830: DEC
50831: ST_TO_ADDR
50832: LD_EXP 99
50836: PUSH
50837: FOR_TO
50838: IFFALSE 50901
// if mc_mines [ i ] and mc_miners [ i ] then
50840: LD_EXP 112
50844: PUSH
50845: LD_VAR 0 2
50849: ARRAY
50850: PUSH
50851: LD_EXP 113
50855: PUSH
50856: LD_VAR 0 2
50860: ARRAY
50861: AND
50862: IFFALSE 50899
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
50864: LD_EXP 113
50868: PUSH
50869: LD_VAR 0 2
50873: ARRAY
50874: PUSH
50875: LD_INT 1
50877: ARRAY
50878: PPUSH
50879: CALL_OW 255
50883: PPUSH
50884: LD_EXP 112
50888: PUSH
50889: LD_VAR 0 2
50893: ARRAY
50894: PPUSH
50895: CALL 66699 0 2
50899: GO 50837
50901: POP
50902: POP
// end ;
50903: LD_VAR 0 1
50907: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
50908: LD_INT 0
50910: PPUSH
50911: PPUSH
50912: PPUSH
50913: PPUSH
50914: PPUSH
50915: PPUSH
50916: PPUSH
50917: PPUSH
// if not mc_bases or not mc_parking then
50918: LD_EXP 99
50922: NOT
50923: PUSH
50924: LD_EXP 123
50928: NOT
50929: OR
50930: IFFALSE 50934
// exit ;
50932: GO 51610
// for i = 1 to mc_bases do
50934: LD_ADDR_VAR 0 2
50938: PUSH
50939: DOUBLE
50940: LD_INT 1
50942: DEC
50943: ST_TO_ADDR
50944: LD_EXP 99
50948: PUSH
50949: FOR_TO
50950: IFFALSE 51608
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
50952: LD_EXP 99
50956: PUSH
50957: LD_VAR 0 2
50961: ARRAY
50962: NOT
50963: PUSH
50964: LD_EXP 123
50968: PUSH
50969: LD_VAR 0 2
50973: ARRAY
50974: NOT
50975: OR
50976: IFFALSE 50980
// continue ;
50978: GO 50949
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
50980: LD_ADDR_VAR 0 5
50984: PUSH
50985: LD_EXP 99
50989: PUSH
50990: LD_VAR 0 2
50994: ARRAY
50995: PUSH
50996: LD_INT 1
50998: ARRAY
50999: PPUSH
51000: CALL_OW 255
51004: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51005: LD_ADDR_VAR 0 6
51009: PUSH
51010: LD_EXP 99
51014: PUSH
51015: LD_VAR 0 2
51019: ARRAY
51020: PPUSH
51021: LD_INT 30
51023: PUSH
51024: LD_INT 3
51026: PUSH
51027: EMPTY
51028: LIST
51029: LIST
51030: PPUSH
51031: CALL_OW 72
51035: ST_TO_ADDR
// if not fac then
51036: LD_VAR 0 6
51040: NOT
51041: IFFALSE 51092
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51043: LD_ADDR_VAR 0 6
51047: PUSH
51048: LD_EXP 99
51052: PUSH
51053: LD_VAR 0 2
51057: ARRAY
51058: PPUSH
51059: LD_INT 2
51061: PUSH
51062: LD_INT 30
51064: PUSH
51065: LD_INT 0
51067: PUSH
51068: EMPTY
51069: LIST
51070: LIST
51071: PUSH
51072: LD_INT 30
51074: PUSH
51075: LD_INT 1
51077: PUSH
51078: EMPTY
51079: LIST
51080: LIST
51081: PUSH
51082: EMPTY
51083: LIST
51084: LIST
51085: LIST
51086: PPUSH
51087: CALL_OW 72
51091: ST_TO_ADDR
// if not fac then
51092: LD_VAR 0 6
51096: NOT
51097: IFFALSE 51101
// continue ;
51099: GO 50949
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , fac [ 1 ] , 25 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51101: LD_ADDR_VAR 0 7
51105: PUSH
51106: LD_EXP 123
51110: PUSH
51111: LD_VAR 0 2
51115: ARRAY
51116: PPUSH
51117: LD_INT 22
51119: PUSH
51120: LD_VAR 0 5
51124: PUSH
51125: EMPTY
51126: LIST
51127: LIST
51128: PUSH
51129: LD_INT 21
51131: PUSH
51132: LD_INT 2
51134: PUSH
51135: EMPTY
51136: LIST
51137: LIST
51138: PUSH
51139: LD_INT 3
51141: PUSH
51142: LD_INT 24
51144: PUSH
51145: LD_INT 1000
51147: PUSH
51148: EMPTY
51149: LIST
51150: LIST
51151: PUSH
51152: EMPTY
51153: LIST
51154: LIST
51155: PUSH
51156: EMPTY
51157: LIST
51158: LIST
51159: LIST
51160: PPUSH
51161: CALL_OW 70
51165: PUSH
51166: LD_INT 22
51168: PUSH
51169: LD_VAR 0 5
51173: PUSH
51174: EMPTY
51175: LIST
51176: LIST
51177: PUSH
51178: LD_INT 91
51180: PUSH
51181: LD_VAR 0 6
51185: PUSH
51186: LD_INT 1
51188: ARRAY
51189: PUSH
51190: LD_INT 25
51192: PUSH
51193: EMPTY
51194: LIST
51195: LIST
51196: LIST
51197: PUSH
51198: LD_INT 21
51200: PUSH
51201: LD_INT 2
51203: PUSH
51204: EMPTY
51205: LIST
51206: LIST
51207: PUSH
51208: LD_INT 3
51210: PUSH
51211: LD_INT 24
51213: PUSH
51214: LD_INT 1000
51216: PUSH
51217: EMPTY
51218: LIST
51219: LIST
51220: PUSH
51221: EMPTY
51222: LIST
51223: LIST
51224: PUSH
51225: EMPTY
51226: LIST
51227: LIST
51228: LIST
51229: LIST
51230: PPUSH
51231: CALL_OW 69
51235: UNION
51236: ST_TO_ADDR
// if not vehs then
51237: LD_VAR 0 7
51241: NOT
51242: IFFALSE 51268
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51244: LD_ADDR_EXP 111
51248: PUSH
51249: LD_EXP 111
51253: PPUSH
51254: LD_VAR 0 2
51258: PPUSH
51259: EMPTY
51260: PPUSH
51261: CALL_OW 1
51265: ST_TO_ADDR
// continue ;
51266: GO 50949
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51268: LD_ADDR_VAR 0 8
51272: PUSH
51273: LD_EXP 99
51277: PUSH
51278: LD_VAR 0 2
51282: ARRAY
51283: PPUSH
51284: LD_INT 30
51286: PUSH
51287: LD_INT 3
51289: PUSH
51290: EMPTY
51291: LIST
51292: LIST
51293: PPUSH
51294: CALL_OW 72
51298: ST_TO_ADDR
// if tmp then
51299: LD_VAR 0 8
51303: IFFALSE 51406
// begin for j in tmp do
51305: LD_ADDR_VAR 0 3
51309: PUSH
51310: LD_VAR 0 8
51314: PUSH
51315: FOR_IN
51316: IFFALSE 51404
// for k in UnitsInside ( j ) do
51318: LD_ADDR_VAR 0 4
51322: PUSH
51323: LD_VAR 0 3
51327: PPUSH
51328: CALL_OW 313
51332: PUSH
51333: FOR_IN
51334: IFFALSE 51400
// if k then
51336: LD_VAR 0 4
51340: IFFALSE 51398
// if not k in mc_repair_vehicle [ i ] then
51342: LD_VAR 0 4
51346: PUSH
51347: LD_EXP 111
51351: PUSH
51352: LD_VAR 0 2
51356: ARRAY
51357: IN
51358: NOT
51359: IFFALSE 51398
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51361: LD_ADDR_EXP 111
51365: PUSH
51366: LD_EXP 111
51370: PPUSH
51371: LD_VAR 0 2
51375: PPUSH
51376: LD_EXP 111
51380: PUSH
51381: LD_VAR 0 2
51385: ARRAY
51386: PUSH
51387: LD_VAR 0 4
51391: UNION
51392: PPUSH
51393: CALL_OW 1
51397: ST_TO_ADDR
51398: GO 51333
51400: POP
51401: POP
51402: GO 51315
51404: POP
51405: POP
// end ; if not mc_repair_vehicle [ i ] then
51406: LD_EXP 111
51410: PUSH
51411: LD_VAR 0 2
51415: ARRAY
51416: NOT
51417: IFFALSE 51421
// continue ;
51419: GO 50949
// for j in mc_repair_vehicle [ i ] do
51421: LD_ADDR_VAR 0 3
51425: PUSH
51426: LD_EXP 111
51430: PUSH
51431: LD_VAR 0 2
51435: ARRAY
51436: PUSH
51437: FOR_IN
51438: IFFALSE 51604
// begin if GetClass ( j ) <> 3 then
51440: LD_VAR 0 3
51444: PPUSH
51445: CALL_OW 257
51449: PUSH
51450: LD_INT 3
51452: NONEQUAL
51453: IFFALSE 51494
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
51455: LD_ADDR_EXP 111
51459: PUSH
51460: LD_EXP 111
51464: PPUSH
51465: LD_VAR 0 2
51469: PPUSH
51470: LD_EXP 111
51474: PUSH
51475: LD_VAR 0 2
51479: ARRAY
51480: PUSH
51481: LD_VAR 0 3
51485: DIFF
51486: PPUSH
51487: CALL_OW 1
51491: ST_TO_ADDR
// continue ;
51492: GO 51437
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
51494: LD_VAR 0 3
51498: PPUSH
51499: CALL_OW 311
51503: NOT
51504: PUSH
51505: LD_VAR 0 3
51509: PUSH
51510: LD_EXP 102
51514: PUSH
51515: LD_VAR 0 2
51519: ARRAY
51520: PUSH
51521: LD_INT 1
51523: ARRAY
51524: IN
51525: NOT
51526: AND
51527: PUSH
51528: LD_VAR 0 3
51532: PUSH
51533: LD_EXP 102
51537: PUSH
51538: LD_VAR 0 2
51542: ARRAY
51543: PUSH
51544: LD_INT 2
51546: ARRAY
51547: IN
51548: NOT
51549: AND
51550: IFFALSE 51602
// begin if IsInUnit ( j ) then
51552: LD_VAR 0 3
51556: PPUSH
51557: CALL_OW 310
51561: IFFALSE 51572
// ComExitBuilding ( j ) ;
51563: LD_VAR 0 3
51567: PPUSH
51568: CALL_OW 122
// if not HasTask ( j ) then
51572: LD_VAR 0 3
51576: PPUSH
51577: CALL_OW 314
51581: NOT
51582: IFFALSE 51602
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
51584: LD_VAR 0 3
51588: PPUSH
51589: LD_VAR 0 7
51593: PUSH
51594: LD_INT 1
51596: ARRAY
51597: PPUSH
51598: CALL_OW 189
// end ; end ;
51602: GO 51437
51604: POP
51605: POP
// end ;
51606: GO 50949
51608: POP
51609: POP
// end ;
51610: LD_VAR 0 1
51614: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
51615: LD_INT 0
51617: PPUSH
51618: PPUSH
51619: PPUSH
51620: PPUSH
51621: PPUSH
51622: PPUSH
51623: PPUSH
51624: PPUSH
51625: PPUSH
51626: PPUSH
51627: PPUSH
// if not mc_bases then
51628: LD_EXP 99
51632: NOT
51633: IFFALSE 51637
// exit ;
51635: GO 52439
// for i = 1 to mc_bases do
51637: LD_ADDR_VAR 0 2
51641: PUSH
51642: DOUBLE
51643: LD_INT 1
51645: DEC
51646: ST_TO_ADDR
51647: LD_EXP 99
51651: PUSH
51652: FOR_TO
51653: IFFALSE 52437
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
51655: LD_EXP 127
51659: PUSH
51660: LD_VAR 0 2
51664: ARRAY
51665: NOT
51666: PUSH
51667: LD_EXP 102
51671: PUSH
51672: LD_VAR 0 2
51676: ARRAY
51677: PUSH
51678: LD_INT 1
51680: ARRAY
51681: OR
51682: PUSH
51683: LD_EXP 102
51687: PUSH
51688: LD_VAR 0 2
51692: ARRAY
51693: PUSH
51694: LD_INT 2
51696: ARRAY
51697: OR
51698: PUSH
51699: LD_EXP 125
51703: PUSH
51704: LD_VAR 0 2
51708: ARRAY
51709: PPUSH
51710: LD_INT 1
51712: PPUSH
51713: CALL_OW 325
51717: NOT
51718: OR
51719: PUSH
51720: LD_EXP 122
51724: PUSH
51725: LD_VAR 0 2
51729: ARRAY
51730: OR
51731: IFFALSE 51735
// continue ;
51733: GO 51652
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
51735: LD_ADDR_VAR 0 8
51739: PUSH
51740: LD_EXP 99
51744: PUSH
51745: LD_VAR 0 2
51749: ARRAY
51750: PPUSH
51751: LD_INT 25
51753: PUSH
51754: LD_INT 4
51756: PUSH
51757: EMPTY
51758: LIST
51759: LIST
51760: PUSH
51761: LD_INT 50
51763: PUSH
51764: EMPTY
51765: LIST
51766: PUSH
51767: LD_INT 3
51769: PUSH
51770: LD_INT 60
51772: PUSH
51773: EMPTY
51774: LIST
51775: PUSH
51776: EMPTY
51777: LIST
51778: LIST
51779: PUSH
51780: EMPTY
51781: LIST
51782: LIST
51783: LIST
51784: PPUSH
51785: CALL_OW 72
51789: PUSH
51790: LD_EXP 103
51794: PUSH
51795: LD_VAR 0 2
51799: ARRAY
51800: DIFF
51801: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51802: LD_ADDR_VAR 0 9
51806: PUSH
51807: LD_EXP 99
51811: PUSH
51812: LD_VAR 0 2
51816: ARRAY
51817: PPUSH
51818: LD_INT 2
51820: PUSH
51821: LD_INT 30
51823: PUSH
51824: LD_INT 0
51826: PUSH
51827: EMPTY
51828: LIST
51829: LIST
51830: PUSH
51831: LD_INT 30
51833: PUSH
51834: LD_INT 1
51836: PUSH
51837: EMPTY
51838: LIST
51839: LIST
51840: PUSH
51841: EMPTY
51842: LIST
51843: LIST
51844: LIST
51845: PPUSH
51846: CALL_OW 72
51850: ST_TO_ADDR
// if not tmp or not dep then
51851: LD_VAR 0 8
51855: NOT
51856: PUSH
51857: LD_VAR 0 9
51861: NOT
51862: OR
51863: IFFALSE 51867
// continue ;
51865: GO 51652
// side := GetSide ( tmp [ 1 ] ) ;
51867: LD_ADDR_VAR 0 11
51871: PUSH
51872: LD_VAR 0 8
51876: PUSH
51877: LD_INT 1
51879: ARRAY
51880: PPUSH
51881: CALL_OW 255
51885: ST_TO_ADDR
// dep := dep [ 1 ] ;
51886: LD_ADDR_VAR 0 9
51890: PUSH
51891: LD_VAR 0 9
51895: PUSH
51896: LD_INT 1
51898: ARRAY
51899: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
51900: LD_ADDR_VAR 0 7
51904: PUSH
51905: LD_EXP 127
51909: PUSH
51910: LD_VAR 0 2
51914: ARRAY
51915: PPUSH
51916: LD_INT 22
51918: PUSH
51919: LD_INT 0
51921: PUSH
51922: EMPTY
51923: LIST
51924: LIST
51925: PUSH
51926: LD_INT 25
51928: PUSH
51929: LD_INT 12
51931: PUSH
51932: EMPTY
51933: LIST
51934: LIST
51935: PUSH
51936: EMPTY
51937: LIST
51938: LIST
51939: PPUSH
51940: CALL_OW 70
51944: PUSH
51945: LD_INT 22
51947: PUSH
51948: LD_INT 0
51950: PUSH
51951: EMPTY
51952: LIST
51953: LIST
51954: PUSH
51955: LD_INT 25
51957: PUSH
51958: LD_INT 12
51960: PUSH
51961: EMPTY
51962: LIST
51963: LIST
51964: PUSH
51965: LD_INT 91
51967: PUSH
51968: LD_VAR 0 9
51972: PUSH
51973: LD_INT 20
51975: PUSH
51976: EMPTY
51977: LIST
51978: LIST
51979: LIST
51980: PUSH
51981: EMPTY
51982: LIST
51983: LIST
51984: LIST
51985: PPUSH
51986: CALL_OW 69
51990: UNION
51991: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
51992: LD_ADDR_VAR 0 10
51996: PUSH
51997: LD_EXP 127
52001: PUSH
52002: LD_VAR 0 2
52006: ARRAY
52007: PPUSH
52008: LD_INT 81
52010: PUSH
52011: LD_VAR 0 11
52015: PUSH
52016: EMPTY
52017: LIST
52018: LIST
52019: PPUSH
52020: CALL_OW 70
52024: ST_TO_ADDR
// if not apes or danger_at_area then
52025: LD_VAR 0 7
52029: NOT
52030: PUSH
52031: LD_VAR 0 10
52035: OR
52036: IFFALSE 52086
// begin if mc_taming [ i ] then
52038: LD_EXP 130
52042: PUSH
52043: LD_VAR 0 2
52047: ARRAY
52048: IFFALSE 52084
// begin MC_Reset ( i , 121 ) ;
52050: LD_VAR 0 2
52054: PPUSH
52055: LD_INT 121
52057: PPUSH
52058: CALL 37779 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52062: LD_ADDR_EXP 130
52066: PUSH
52067: LD_EXP 130
52071: PPUSH
52072: LD_VAR 0 2
52076: PPUSH
52077: EMPTY
52078: PPUSH
52079: CALL_OW 1
52083: ST_TO_ADDR
// end ; continue ;
52084: GO 51652
// end ; for j in tmp do
52086: LD_ADDR_VAR 0 3
52090: PUSH
52091: LD_VAR 0 8
52095: PUSH
52096: FOR_IN
52097: IFFALSE 52433
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52099: LD_VAR 0 3
52103: PUSH
52104: LD_EXP 130
52108: PUSH
52109: LD_VAR 0 2
52113: ARRAY
52114: IN
52115: NOT
52116: PUSH
52117: LD_EXP 130
52121: PUSH
52122: LD_VAR 0 2
52126: ARRAY
52127: PUSH
52128: LD_INT 3
52130: LESS
52131: AND
52132: IFFALSE 52190
// begin SetTag ( j , 121 ) ;
52134: LD_VAR 0 3
52138: PPUSH
52139: LD_INT 121
52141: PPUSH
52142: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52146: LD_ADDR_EXP 130
52150: PUSH
52151: LD_EXP 130
52155: PPUSH
52156: LD_VAR 0 2
52160: PUSH
52161: LD_EXP 130
52165: PUSH
52166: LD_VAR 0 2
52170: ARRAY
52171: PUSH
52172: LD_INT 1
52174: PLUS
52175: PUSH
52176: EMPTY
52177: LIST
52178: LIST
52179: PPUSH
52180: LD_VAR 0 3
52184: PPUSH
52185: CALL 69649 0 3
52189: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52190: LD_VAR 0 3
52194: PUSH
52195: LD_EXP 130
52199: PUSH
52200: LD_VAR 0 2
52204: ARRAY
52205: IN
52206: IFFALSE 52431
// begin if GetClass ( j ) <> 4 then
52208: LD_VAR 0 3
52212: PPUSH
52213: CALL_OW 257
52217: PUSH
52218: LD_INT 4
52220: NONEQUAL
52221: IFFALSE 52274
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52223: LD_ADDR_EXP 130
52227: PUSH
52228: LD_EXP 130
52232: PPUSH
52233: LD_VAR 0 2
52237: PPUSH
52238: LD_EXP 130
52242: PUSH
52243: LD_VAR 0 2
52247: ARRAY
52248: PUSH
52249: LD_VAR 0 3
52253: DIFF
52254: PPUSH
52255: CALL_OW 1
52259: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52260: LD_VAR 0 3
52264: PPUSH
52265: LD_INT 0
52267: PPUSH
52268: CALL_OW 109
// continue ;
52272: GO 52096
// end ; if IsInUnit ( j ) then
52274: LD_VAR 0 3
52278: PPUSH
52279: CALL_OW 310
52283: IFFALSE 52294
// ComExitBuilding ( j ) ;
52285: LD_VAR 0 3
52289: PPUSH
52290: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52294: LD_ADDR_VAR 0 6
52298: PUSH
52299: LD_VAR 0 7
52303: PPUSH
52304: LD_VAR 0 3
52308: PPUSH
52309: CALL_OW 74
52313: ST_TO_ADDR
// if not ape then
52314: LD_VAR 0 6
52318: NOT
52319: IFFALSE 52323
// break ;
52321: GO 52433
// x := GetX ( ape ) ;
52323: LD_ADDR_VAR 0 4
52327: PUSH
52328: LD_VAR 0 6
52332: PPUSH
52333: CALL_OW 250
52337: ST_TO_ADDR
// y := GetY ( ape ) ;
52338: LD_ADDR_VAR 0 5
52342: PUSH
52343: LD_VAR 0 6
52347: PPUSH
52348: CALL_OW 251
52352: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52353: LD_VAR 0 4
52357: PPUSH
52358: LD_VAR 0 5
52362: PPUSH
52363: CALL_OW 488
52367: NOT
52368: PUSH
52369: LD_VAR 0 11
52373: PPUSH
52374: LD_VAR 0 4
52378: PPUSH
52379: LD_VAR 0 5
52383: PPUSH
52384: LD_INT 20
52386: PPUSH
52387: CALL 70545 0 4
52391: PUSH
52392: LD_INT 4
52394: ARRAY
52395: OR
52396: IFFALSE 52400
// break ;
52398: GO 52433
// if not HasTask ( j ) then
52400: LD_VAR 0 3
52404: PPUSH
52405: CALL_OW 314
52409: NOT
52410: IFFALSE 52431
// ComTameXY ( j , x , y ) ;
52412: LD_VAR 0 3
52416: PPUSH
52417: LD_VAR 0 4
52421: PPUSH
52422: LD_VAR 0 5
52426: PPUSH
52427: CALL_OW 131
// end ; end ;
52431: GO 52096
52433: POP
52434: POP
// end ;
52435: GO 51652
52437: POP
52438: POP
// end ;
52439: LD_VAR 0 1
52443: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
52444: LD_INT 0
52446: PPUSH
52447: PPUSH
52448: PPUSH
52449: PPUSH
52450: PPUSH
52451: PPUSH
52452: PPUSH
52453: PPUSH
// if not mc_bases then
52454: LD_EXP 99
52458: NOT
52459: IFFALSE 52463
// exit ;
52461: GO 53089
// for i = 1 to mc_bases do
52463: LD_ADDR_VAR 0 2
52467: PUSH
52468: DOUBLE
52469: LD_INT 1
52471: DEC
52472: ST_TO_ADDR
52473: LD_EXP 99
52477: PUSH
52478: FOR_TO
52479: IFFALSE 53087
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
52481: LD_EXP 128
52485: PUSH
52486: LD_VAR 0 2
52490: ARRAY
52491: NOT
52492: PUSH
52493: LD_EXP 128
52497: PUSH
52498: LD_VAR 0 2
52502: ARRAY
52503: PPUSH
52504: LD_INT 25
52506: PUSH
52507: LD_INT 12
52509: PUSH
52510: EMPTY
52511: LIST
52512: LIST
52513: PPUSH
52514: CALL_OW 72
52518: NOT
52519: OR
52520: IFFALSE 52524
// continue ;
52522: GO 52478
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
52524: LD_ADDR_VAR 0 5
52528: PUSH
52529: LD_EXP 128
52533: PUSH
52534: LD_VAR 0 2
52538: ARRAY
52539: PUSH
52540: LD_INT 1
52542: ARRAY
52543: PPUSH
52544: CALL_OW 255
52548: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
52549: LD_VAR 0 5
52553: PPUSH
52554: LD_INT 2
52556: PPUSH
52557: CALL_OW 325
52561: IFFALSE 52814
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
52563: LD_ADDR_VAR 0 4
52567: PUSH
52568: LD_EXP 128
52572: PUSH
52573: LD_VAR 0 2
52577: ARRAY
52578: PPUSH
52579: LD_INT 25
52581: PUSH
52582: LD_INT 16
52584: PUSH
52585: EMPTY
52586: LIST
52587: LIST
52588: PPUSH
52589: CALL_OW 72
52593: ST_TO_ADDR
// if tmp < 6 then
52594: LD_VAR 0 4
52598: PUSH
52599: LD_INT 6
52601: LESS
52602: IFFALSE 52814
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52604: LD_ADDR_VAR 0 6
52608: PUSH
52609: LD_EXP 99
52613: PUSH
52614: LD_VAR 0 2
52618: ARRAY
52619: PPUSH
52620: LD_INT 2
52622: PUSH
52623: LD_INT 30
52625: PUSH
52626: LD_INT 0
52628: PUSH
52629: EMPTY
52630: LIST
52631: LIST
52632: PUSH
52633: LD_INT 30
52635: PUSH
52636: LD_INT 1
52638: PUSH
52639: EMPTY
52640: LIST
52641: LIST
52642: PUSH
52643: EMPTY
52644: LIST
52645: LIST
52646: LIST
52647: PPUSH
52648: CALL_OW 72
52652: ST_TO_ADDR
// if depot then
52653: LD_VAR 0 6
52657: IFFALSE 52814
// begin selected := 0 ;
52659: LD_ADDR_VAR 0 7
52663: PUSH
52664: LD_INT 0
52666: ST_TO_ADDR
// for j in depot do
52667: LD_ADDR_VAR 0 3
52671: PUSH
52672: LD_VAR 0 6
52676: PUSH
52677: FOR_IN
52678: IFFALSE 52709
// begin if UnitsInside ( j ) < 6 then
52680: LD_VAR 0 3
52684: PPUSH
52685: CALL_OW 313
52689: PUSH
52690: LD_INT 6
52692: LESS
52693: IFFALSE 52707
// begin selected := j ;
52695: LD_ADDR_VAR 0 7
52699: PUSH
52700: LD_VAR 0 3
52704: ST_TO_ADDR
// break ;
52705: GO 52709
// end ; end ;
52707: GO 52677
52709: POP
52710: POP
// if selected then
52711: LD_VAR 0 7
52715: IFFALSE 52814
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
52717: LD_ADDR_VAR 0 3
52721: PUSH
52722: LD_EXP 128
52726: PUSH
52727: LD_VAR 0 2
52731: ARRAY
52732: PPUSH
52733: LD_INT 25
52735: PUSH
52736: LD_INT 12
52738: PUSH
52739: EMPTY
52740: LIST
52741: LIST
52742: PPUSH
52743: CALL_OW 72
52747: PUSH
52748: FOR_IN
52749: IFFALSE 52812
// if not HasTask ( j ) then
52751: LD_VAR 0 3
52755: PPUSH
52756: CALL_OW 314
52760: NOT
52761: IFFALSE 52810
// begin if not IsInUnit ( j ) then
52763: LD_VAR 0 3
52767: PPUSH
52768: CALL_OW 310
52772: NOT
52773: IFFALSE 52789
// ComEnterUnit ( j , selected ) ;
52775: LD_VAR 0 3
52779: PPUSH
52780: LD_VAR 0 7
52784: PPUSH
52785: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
52789: LD_VAR 0 3
52793: PPUSH
52794: LD_INT 16
52796: PPUSH
52797: CALL_OW 183
// AddComExitBuilding ( j ) ;
52801: LD_VAR 0 3
52805: PPUSH
52806: CALL_OW 182
// end ;
52810: GO 52748
52812: POP
52813: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
52814: LD_VAR 0 5
52818: PPUSH
52819: LD_INT 11
52821: PPUSH
52822: CALL_OW 325
52826: IFFALSE 53085
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
52828: LD_ADDR_VAR 0 4
52832: PUSH
52833: LD_EXP 128
52837: PUSH
52838: LD_VAR 0 2
52842: ARRAY
52843: PPUSH
52844: LD_INT 25
52846: PUSH
52847: LD_INT 16
52849: PUSH
52850: EMPTY
52851: LIST
52852: LIST
52853: PPUSH
52854: CALL_OW 72
52858: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
52859: LD_VAR 0 4
52863: PUSH
52864: LD_INT 6
52866: GREATEREQUAL
52867: PUSH
52868: LD_VAR 0 5
52872: PPUSH
52873: LD_INT 2
52875: PPUSH
52876: CALL_OW 325
52880: NOT
52881: OR
52882: IFFALSE 53085
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
52884: LD_ADDR_VAR 0 8
52888: PUSH
52889: LD_EXP 99
52893: PUSH
52894: LD_VAR 0 2
52898: ARRAY
52899: PPUSH
52900: LD_INT 2
52902: PUSH
52903: LD_INT 30
52905: PUSH
52906: LD_INT 4
52908: PUSH
52909: EMPTY
52910: LIST
52911: LIST
52912: PUSH
52913: LD_INT 30
52915: PUSH
52916: LD_INT 5
52918: PUSH
52919: EMPTY
52920: LIST
52921: LIST
52922: PUSH
52923: EMPTY
52924: LIST
52925: LIST
52926: LIST
52927: PPUSH
52928: CALL_OW 72
52932: ST_TO_ADDR
// if barracks then
52933: LD_VAR 0 8
52937: IFFALSE 53085
// begin selected := 0 ;
52939: LD_ADDR_VAR 0 7
52943: PUSH
52944: LD_INT 0
52946: ST_TO_ADDR
// for j in barracks do
52947: LD_ADDR_VAR 0 3
52951: PUSH
52952: LD_VAR 0 8
52956: PUSH
52957: FOR_IN
52958: IFFALSE 52989
// begin if UnitsInside ( j ) < 6 then
52960: LD_VAR 0 3
52964: PPUSH
52965: CALL_OW 313
52969: PUSH
52970: LD_INT 6
52972: LESS
52973: IFFALSE 52987
// begin selected := j ;
52975: LD_ADDR_VAR 0 7
52979: PUSH
52980: LD_VAR 0 3
52984: ST_TO_ADDR
// break ;
52985: GO 52989
// end ; end ;
52987: GO 52957
52989: POP
52990: POP
// if selected then
52991: LD_VAR 0 7
52995: IFFALSE 53085
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
52997: LD_ADDR_VAR 0 3
53001: PUSH
53002: LD_EXP 128
53006: PUSH
53007: LD_VAR 0 2
53011: ARRAY
53012: PPUSH
53013: LD_INT 25
53015: PUSH
53016: LD_INT 12
53018: PUSH
53019: EMPTY
53020: LIST
53021: LIST
53022: PPUSH
53023: CALL_OW 72
53027: PUSH
53028: FOR_IN
53029: IFFALSE 53083
// if not IsInUnit ( j ) and not HasTask ( j ) then
53031: LD_VAR 0 3
53035: PPUSH
53036: CALL_OW 310
53040: NOT
53041: PUSH
53042: LD_VAR 0 3
53046: PPUSH
53047: CALL_OW 314
53051: NOT
53052: AND
53053: IFFALSE 53081
// begin ComEnterUnit ( j , selected ) ;
53055: LD_VAR 0 3
53059: PPUSH
53060: LD_VAR 0 7
53064: PPUSH
53065: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53069: LD_VAR 0 3
53073: PPUSH
53074: LD_INT 15
53076: PPUSH
53077: CALL_OW 183
// end ;
53081: GO 53028
53083: POP
53084: POP
// end ; end ; end ; end ; end ;
53085: GO 52478
53087: POP
53088: POP
// end ;
53089: LD_VAR 0 1
53093: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53094: LD_INT 0
53096: PPUSH
53097: PPUSH
53098: PPUSH
53099: PPUSH
// if not mc_bases then
53100: LD_EXP 99
53104: NOT
53105: IFFALSE 53109
// exit ;
53107: GO 53287
// for i = 1 to mc_bases do
53109: LD_ADDR_VAR 0 2
53113: PUSH
53114: DOUBLE
53115: LD_INT 1
53117: DEC
53118: ST_TO_ADDR
53119: LD_EXP 99
53123: PUSH
53124: FOR_TO
53125: IFFALSE 53285
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53127: LD_ADDR_VAR 0 4
53131: PUSH
53132: LD_EXP 99
53136: PUSH
53137: LD_VAR 0 2
53141: ARRAY
53142: PPUSH
53143: LD_INT 25
53145: PUSH
53146: LD_INT 9
53148: PUSH
53149: EMPTY
53150: LIST
53151: LIST
53152: PPUSH
53153: CALL_OW 72
53157: ST_TO_ADDR
// if not tmp then
53158: LD_VAR 0 4
53162: NOT
53163: IFFALSE 53167
// continue ;
53165: GO 53124
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53167: LD_EXP 125
53171: PUSH
53172: LD_VAR 0 2
53176: ARRAY
53177: PPUSH
53178: LD_INT 29
53180: PPUSH
53181: CALL_OW 325
53185: NOT
53186: PUSH
53187: LD_EXP 125
53191: PUSH
53192: LD_VAR 0 2
53196: ARRAY
53197: PPUSH
53198: LD_INT 28
53200: PPUSH
53201: CALL_OW 325
53205: NOT
53206: AND
53207: IFFALSE 53211
// continue ;
53209: GO 53124
// for j in tmp do
53211: LD_ADDR_VAR 0 3
53215: PUSH
53216: LD_VAR 0 4
53220: PUSH
53221: FOR_IN
53222: IFFALSE 53281
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53224: LD_VAR 0 3
53228: PUSH
53229: LD_EXP 102
53233: PUSH
53234: LD_VAR 0 2
53238: ARRAY
53239: PUSH
53240: LD_INT 1
53242: ARRAY
53243: IN
53244: NOT
53245: PUSH
53246: LD_VAR 0 3
53250: PUSH
53251: LD_EXP 102
53255: PUSH
53256: LD_VAR 0 2
53260: ARRAY
53261: PUSH
53262: LD_INT 2
53264: ARRAY
53265: IN
53266: NOT
53267: AND
53268: IFFALSE 53279
// ComSpaceTimeShoot ( j ) ;
53270: LD_VAR 0 3
53274: PPUSH
53275: CALL 63739 0 1
53279: GO 53221
53281: POP
53282: POP
// end ;
53283: GO 53124
53285: POP
53286: POP
// end ;
53287: LD_VAR 0 1
53291: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53292: LD_INT 0
53294: PPUSH
53295: PPUSH
53296: PPUSH
53297: PPUSH
53298: PPUSH
53299: PPUSH
53300: PPUSH
53301: PPUSH
53302: PPUSH
// if not mc_bases then
53303: LD_EXP 99
53307: NOT
53308: IFFALSE 53312
// exit ;
53310: GO 53934
// for i = 1 to mc_bases do
53312: LD_ADDR_VAR 0 2
53316: PUSH
53317: DOUBLE
53318: LD_INT 1
53320: DEC
53321: ST_TO_ADDR
53322: LD_EXP 99
53326: PUSH
53327: FOR_TO
53328: IFFALSE 53932
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53330: LD_EXP 134
53334: PUSH
53335: LD_VAR 0 2
53339: ARRAY
53340: NOT
53341: PUSH
53342: LD_INT 38
53344: PPUSH
53345: LD_EXP 125
53349: PUSH
53350: LD_VAR 0 2
53354: ARRAY
53355: PPUSH
53356: CALL_OW 321
53360: PUSH
53361: LD_INT 2
53363: NONEQUAL
53364: OR
53365: IFFALSE 53369
// continue ;
53367: GO 53327
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53369: LD_ADDR_VAR 0 8
53373: PUSH
53374: LD_EXP 99
53378: PUSH
53379: LD_VAR 0 2
53383: ARRAY
53384: PPUSH
53385: LD_INT 30
53387: PUSH
53388: LD_INT 34
53390: PUSH
53391: EMPTY
53392: LIST
53393: LIST
53394: PPUSH
53395: CALL_OW 72
53399: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53400: LD_ADDR_VAR 0 9
53404: PUSH
53405: LD_EXP 99
53409: PUSH
53410: LD_VAR 0 2
53414: ARRAY
53415: PPUSH
53416: LD_INT 25
53418: PUSH
53419: LD_INT 4
53421: PUSH
53422: EMPTY
53423: LIST
53424: LIST
53425: PPUSH
53426: CALL_OW 72
53430: PPUSH
53431: LD_INT 0
53433: PPUSH
53434: CALL 102909 0 2
53438: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
53439: LD_VAR 0 9
53443: NOT
53444: PUSH
53445: LD_VAR 0 8
53449: NOT
53450: OR
53451: PUSH
53452: LD_EXP 99
53456: PUSH
53457: LD_VAR 0 2
53461: ARRAY
53462: PPUSH
53463: LD_INT 124
53465: PPUSH
53466: CALL 102909 0 2
53470: OR
53471: IFFALSE 53475
// continue ;
53473: GO 53327
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
53475: LD_EXP 135
53479: PUSH
53480: LD_VAR 0 2
53484: ARRAY
53485: PUSH
53486: LD_EXP 134
53490: PUSH
53491: LD_VAR 0 2
53495: ARRAY
53496: LESS
53497: PUSH
53498: LD_EXP 135
53502: PUSH
53503: LD_VAR 0 2
53507: ARRAY
53508: PUSH
53509: LD_VAR 0 8
53513: LESS
53514: AND
53515: IFFALSE 53930
// begin tmp := sci [ 1 ] ;
53517: LD_ADDR_VAR 0 7
53521: PUSH
53522: LD_VAR 0 9
53526: PUSH
53527: LD_INT 1
53529: ARRAY
53530: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
53531: LD_VAR 0 7
53535: PPUSH
53536: LD_INT 124
53538: PPUSH
53539: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
53543: LD_ADDR_VAR 0 3
53547: PUSH
53548: DOUBLE
53549: LD_EXP 134
53553: PUSH
53554: LD_VAR 0 2
53558: ARRAY
53559: INC
53560: ST_TO_ADDR
53561: LD_EXP 134
53565: PUSH
53566: LD_VAR 0 2
53570: ARRAY
53571: PUSH
53572: FOR_DOWNTO
53573: IFFALSE 53916
// begin if IsInUnit ( tmp ) then
53575: LD_VAR 0 7
53579: PPUSH
53580: CALL_OW 310
53584: IFFALSE 53595
// ComExitBuilding ( tmp ) ;
53586: LD_VAR 0 7
53590: PPUSH
53591: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
53595: LD_INT 35
53597: PPUSH
53598: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
53602: LD_VAR 0 7
53606: PPUSH
53607: CALL_OW 310
53611: NOT
53612: PUSH
53613: LD_VAR 0 7
53617: PPUSH
53618: CALL_OW 314
53622: NOT
53623: AND
53624: IFFALSE 53595
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
53626: LD_ADDR_VAR 0 6
53630: PUSH
53631: LD_VAR 0 7
53635: PPUSH
53636: CALL_OW 250
53640: PUSH
53641: LD_VAR 0 7
53645: PPUSH
53646: CALL_OW 251
53650: PUSH
53651: EMPTY
53652: LIST
53653: LIST
53654: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
53655: LD_INT 35
53657: PPUSH
53658: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
53662: LD_ADDR_VAR 0 4
53666: PUSH
53667: LD_EXP 134
53671: PUSH
53672: LD_VAR 0 2
53676: ARRAY
53677: PUSH
53678: LD_VAR 0 3
53682: ARRAY
53683: PUSH
53684: LD_INT 1
53686: ARRAY
53687: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
53688: LD_ADDR_VAR 0 5
53692: PUSH
53693: LD_EXP 134
53697: PUSH
53698: LD_VAR 0 2
53702: ARRAY
53703: PUSH
53704: LD_VAR 0 3
53708: ARRAY
53709: PUSH
53710: LD_INT 2
53712: ARRAY
53713: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
53714: LD_VAR 0 7
53718: PPUSH
53719: LD_INT 10
53721: PPUSH
53722: CALL 72242 0 2
53726: PUSH
53727: LD_INT 4
53729: ARRAY
53730: IFFALSE 53768
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
53732: LD_VAR 0 7
53736: PPUSH
53737: LD_VAR 0 6
53741: PUSH
53742: LD_INT 1
53744: ARRAY
53745: PPUSH
53746: LD_VAR 0 6
53750: PUSH
53751: LD_INT 2
53753: ARRAY
53754: PPUSH
53755: CALL_OW 111
// wait ( 0 0$10 ) ;
53759: LD_INT 350
53761: PPUSH
53762: CALL_OW 67
// end else
53766: GO 53794
// begin ComMoveXY ( tmp , x , y ) ;
53768: LD_VAR 0 7
53772: PPUSH
53773: LD_VAR 0 4
53777: PPUSH
53778: LD_VAR 0 5
53782: PPUSH
53783: CALL_OW 111
// wait ( 0 0$3 ) ;
53787: LD_INT 105
53789: PPUSH
53790: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
53794: LD_VAR 0 7
53798: PPUSH
53799: LD_VAR 0 4
53803: PPUSH
53804: LD_VAR 0 5
53808: PPUSH
53809: CALL_OW 307
53813: IFFALSE 53655
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
53815: LD_VAR 0 7
53819: PPUSH
53820: LD_VAR 0 4
53824: PPUSH
53825: LD_VAR 0 5
53829: PPUSH
53830: LD_VAR 0 8
53834: PUSH
53835: LD_VAR 0 3
53839: ARRAY
53840: PPUSH
53841: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
53845: LD_INT 35
53847: PPUSH
53848: CALL_OW 67
// until not HasTask ( tmp ) ;
53852: LD_VAR 0 7
53856: PPUSH
53857: CALL_OW 314
53861: NOT
53862: IFFALSE 53845
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
53864: LD_ADDR_EXP 135
53868: PUSH
53869: LD_EXP 135
53873: PPUSH
53874: LD_VAR 0 2
53878: PUSH
53879: LD_EXP 135
53883: PUSH
53884: LD_VAR 0 2
53888: ARRAY
53889: PUSH
53890: LD_INT 1
53892: PLUS
53893: PUSH
53894: EMPTY
53895: LIST
53896: LIST
53897: PPUSH
53898: LD_VAR 0 8
53902: PUSH
53903: LD_VAR 0 3
53907: ARRAY
53908: PPUSH
53909: CALL 69649 0 3
53913: ST_TO_ADDR
// end ;
53914: GO 53572
53916: POP
53917: POP
// MC_Reset ( i , 124 ) ;
53918: LD_VAR 0 2
53922: PPUSH
53923: LD_INT 124
53925: PPUSH
53926: CALL 37779 0 2
// end ; end ;
53930: GO 53327
53932: POP
53933: POP
// end ;
53934: LD_VAR 0 1
53938: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
53939: LD_INT 0
53941: PPUSH
53942: PPUSH
53943: PPUSH
// if not mc_bases then
53944: LD_EXP 99
53948: NOT
53949: IFFALSE 53953
// exit ;
53951: GO 54559
// for i = 1 to mc_bases do
53953: LD_ADDR_VAR 0 2
53957: PUSH
53958: DOUBLE
53959: LD_INT 1
53961: DEC
53962: ST_TO_ADDR
53963: LD_EXP 99
53967: PUSH
53968: FOR_TO
53969: IFFALSE 54557
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
53971: LD_ADDR_VAR 0 3
53975: PUSH
53976: LD_EXP 99
53980: PUSH
53981: LD_VAR 0 2
53985: ARRAY
53986: PPUSH
53987: LD_INT 25
53989: PUSH
53990: LD_INT 4
53992: PUSH
53993: EMPTY
53994: LIST
53995: LIST
53996: PPUSH
53997: CALL_OW 72
54001: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54002: LD_VAR 0 3
54006: NOT
54007: PUSH
54008: LD_EXP 136
54012: PUSH
54013: LD_VAR 0 2
54017: ARRAY
54018: NOT
54019: OR
54020: PUSH
54021: LD_EXP 99
54025: PUSH
54026: LD_VAR 0 2
54030: ARRAY
54031: PPUSH
54032: LD_INT 2
54034: PUSH
54035: LD_INT 30
54037: PUSH
54038: LD_INT 0
54040: PUSH
54041: EMPTY
54042: LIST
54043: LIST
54044: PUSH
54045: LD_INT 30
54047: PUSH
54048: LD_INT 1
54050: PUSH
54051: EMPTY
54052: LIST
54053: LIST
54054: PUSH
54055: EMPTY
54056: LIST
54057: LIST
54058: LIST
54059: PPUSH
54060: CALL_OW 72
54064: NOT
54065: OR
54066: IFFALSE 54116
// begin if mc_deposits_finder [ i ] then
54068: LD_EXP 137
54072: PUSH
54073: LD_VAR 0 2
54077: ARRAY
54078: IFFALSE 54114
// begin MC_Reset ( i , 125 ) ;
54080: LD_VAR 0 2
54084: PPUSH
54085: LD_INT 125
54087: PPUSH
54088: CALL 37779 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54092: LD_ADDR_EXP 137
54096: PUSH
54097: LD_EXP 137
54101: PPUSH
54102: LD_VAR 0 2
54106: PPUSH
54107: EMPTY
54108: PPUSH
54109: CALL_OW 1
54113: ST_TO_ADDR
// end ; continue ;
54114: GO 53968
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54116: LD_EXP 136
54120: PUSH
54121: LD_VAR 0 2
54125: ARRAY
54126: PUSH
54127: LD_INT 1
54129: ARRAY
54130: PUSH
54131: LD_INT 3
54133: ARRAY
54134: PUSH
54135: LD_INT 1
54137: EQUAL
54138: PUSH
54139: LD_INT 20
54141: PPUSH
54142: LD_EXP 125
54146: PUSH
54147: LD_VAR 0 2
54151: ARRAY
54152: PPUSH
54153: CALL_OW 321
54157: PUSH
54158: LD_INT 2
54160: NONEQUAL
54161: AND
54162: IFFALSE 54212
// begin if mc_deposits_finder [ i ] then
54164: LD_EXP 137
54168: PUSH
54169: LD_VAR 0 2
54173: ARRAY
54174: IFFALSE 54210
// begin MC_Reset ( i , 125 ) ;
54176: LD_VAR 0 2
54180: PPUSH
54181: LD_INT 125
54183: PPUSH
54184: CALL 37779 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54188: LD_ADDR_EXP 137
54192: PUSH
54193: LD_EXP 137
54197: PPUSH
54198: LD_VAR 0 2
54202: PPUSH
54203: EMPTY
54204: PPUSH
54205: CALL_OW 1
54209: ST_TO_ADDR
// end ; continue ;
54210: GO 53968
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54212: LD_EXP 136
54216: PUSH
54217: LD_VAR 0 2
54221: ARRAY
54222: PUSH
54223: LD_INT 1
54225: ARRAY
54226: PUSH
54227: LD_INT 1
54229: ARRAY
54230: PPUSH
54231: LD_EXP 136
54235: PUSH
54236: LD_VAR 0 2
54240: ARRAY
54241: PUSH
54242: LD_INT 1
54244: ARRAY
54245: PUSH
54246: LD_INT 2
54248: ARRAY
54249: PPUSH
54250: LD_EXP 125
54254: PUSH
54255: LD_VAR 0 2
54259: ARRAY
54260: PPUSH
54261: CALL_OW 440
54265: IFFALSE 54308
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54267: LD_ADDR_EXP 136
54271: PUSH
54272: LD_EXP 136
54276: PPUSH
54277: LD_VAR 0 2
54281: PPUSH
54282: LD_EXP 136
54286: PUSH
54287: LD_VAR 0 2
54291: ARRAY
54292: PPUSH
54293: LD_INT 1
54295: PPUSH
54296: CALL_OW 3
54300: PPUSH
54301: CALL_OW 1
54305: ST_TO_ADDR
54306: GO 54555
// begin if not mc_deposits_finder [ i ] then
54308: LD_EXP 137
54312: PUSH
54313: LD_VAR 0 2
54317: ARRAY
54318: NOT
54319: IFFALSE 54371
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54321: LD_ADDR_EXP 137
54325: PUSH
54326: LD_EXP 137
54330: PPUSH
54331: LD_VAR 0 2
54335: PPUSH
54336: LD_VAR 0 3
54340: PUSH
54341: LD_INT 1
54343: ARRAY
54344: PUSH
54345: EMPTY
54346: LIST
54347: PPUSH
54348: CALL_OW 1
54352: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54353: LD_VAR 0 3
54357: PUSH
54358: LD_INT 1
54360: ARRAY
54361: PPUSH
54362: LD_INT 125
54364: PPUSH
54365: CALL_OW 109
// end else
54369: GO 54555
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54371: LD_EXP 137
54375: PUSH
54376: LD_VAR 0 2
54380: ARRAY
54381: PUSH
54382: LD_INT 1
54384: ARRAY
54385: PPUSH
54386: CALL_OW 310
54390: IFFALSE 54413
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54392: LD_EXP 137
54396: PUSH
54397: LD_VAR 0 2
54401: ARRAY
54402: PUSH
54403: LD_INT 1
54405: ARRAY
54406: PPUSH
54407: CALL_OW 122
54411: GO 54555
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
54413: LD_EXP 137
54417: PUSH
54418: LD_VAR 0 2
54422: ARRAY
54423: PUSH
54424: LD_INT 1
54426: ARRAY
54427: PPUSH
54428: CALL_OW 314
54432: NOT
54433: PUSH
54434: LD_EXP 137
54438: PUSH
54439: LD_VAR 0 2
54443: ARRAY
54444: PUSH
54445: LD_INT 1
54447: ARRAY
54448: PPUSH
54449: LD_EXP 136
54453: PUSH
54454: LD_VAR 0 2
54458: ARRAY
54459: PUSH
54460: LD_INT 1
54462: ARRAY
54463: PUSH
54464: LD_INT 1
54466: ARRAY
54467: PPUSH
54468: LD_EXP 136
54472: PUSH
54473: LD_VAR 0 2
54477: ARRAY
54478: PUSH
54479: LD_INT 1
54481: ARRAY
54482: PUSH
54483: LD_INT 2
54485: ARRAY
54486: PPUSH
54487: CALL_OW 297
54491: PUSH
54492: LD_INT 6
54494: GREATER
54495: AND
54496: IFFALSE 54555
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
54498: LD_EXP 137
54502: PUSH
54503: LD_VAR 0 2
54507: ARRAY
54508: PUSH
54509: LD_INT 1
54511: ARRAY
54512: PPUSH
54513: LD_EXP 136
54517: PUSH
54518: LD_VAR 0 2
54522: ARRAY
54523: PUSH
54524: LD_INT 1
54526: ARRAY
54527: PUSH
54528: LD_INT 1
54530: ARRAY
54531: PPUSH
54532: LD_EXP 136
54536: PUSH
54537: LD_VAR 0 2
54541: ARRAY
54542: PUSH
54543: LD_INT 1
54545: ARRAY
54546: PUSH
54547: LD_INT 2
54549: ARRAY
54550: PPUSH
54551: CALL_OW 111
// end ; end ; end ;
54555: GO 53968
54557: POP
54558: POP
// end ;
54559: LD_VAR 0 1
54563: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
54564: LD_INT 0
54566: PPUSH
54567: PPUSH
54568: PPUSH
54569: PPUSH
54570: PPUSH
54571: PPUSH
54572: PPUSH
54573: PPUSH
54574: PPUSH
54575: PPUSH
54576: PPUSH
// if not mc_bases then
54577: LD_EXP 99
54581: NOT
54582: IFFALSE 54586
// exit ;
54584: GO 55310
// for i = 1 to mc_bases do
54586: LD_ADDR_VAR 0 2
54590: PUSH
54591: DOUBLE
54592: LD_INT 1
54594: DEC
54595: ST_TO_ADDR
54596: LD_EXP 99
54600: PUSH
54601: FOR_TO
54602: IFFALSE 55308
// begin if not mc_bases [ i ] then
54604: LD_EXP 99
54608: PUSH
54609: LD_VAR 0 2
54613: ARRAY
54614: NOT
54615: IFFALSE 54619
// continue ;
54617: GO 54601
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
54619: LD_ADDR_VAR 0 7
54623: PUSH
54624: LD_EXP 99
54628: PUSH
54629: LD_VAR 0 2
54633: ARRAY
54634: PUSH
54635: LD_INT 1
54637: ARRAY
54638: PPUSH
54639: CALL_OW 248
54643: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
54644: LD_VAR 0 7
54648: PUSH
54649: LD_INT 3
54651: EQUAL
54652: PUSH
54653: LD_EXP 118
54657: PUSH
54658: LD_VAR 0 2
54662: ARRAY
54663: PUSH
54664: LD_EXP 121
54668: PUSH
54669: LD_VAR 0 2
54673: ARRAY
54674: UNION
54675: PPUSH
54676: LD_INT 33
54678: PUSH
54679: LD_INT 2
54681: PUSH
54682: EMPTY
54683: LIST
54684: LIST
54685: PPUSH
54686: CALL_OW 72
54690: NOT
54691: OR
54692: IFFALSE 54696
// continue ;
54694: GO 54601
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
54696: LD_ADDR_VAR 0 9
54700: PUSH
54701: LD_EXP 99
54705: PUSH
54706: LD_VAR 0 2
54710: ARRAY
54711: PPUSH
54712: LD_INT 30
54714: PUSH
54715: LD_INT 36
54717: PUSH
54718: EMPTY
54719: LIST
54720: LIST
54721: PPUSH
54722: CALL_OW 72
54726: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
54727: LD_ADDR_VAR 0 10
54731: PUSH
54732: LD_EXP 118
54736: PUSH
54737: LD_VAR 0 2
54741: ARRAY
54742: PPUSH
54743: LD_INT 34
54745: PUSH
54746: LD_INT 31
54748: PUSH
54749: EMPTY
54750: LIST
54751: LIST
54752: PPUSH
54753: CALL_OW 72
54757: ST_TO_ADDR
// if not cts and not mcts then
54758: LD_VAR 0 9
54762: NOT
54763: PUSH
54764: LD_VAR 0 10
54768: NOT
54769: AND
54770: IFFALSE 54774
// continue ;
54772: GO 54601
// x := cts ;
54774: LD_ADDR_VAR 0 11
54778: PUSH
54779: LD_VAR 0 9
54783: ST_TO_ADDR
// if not x then
54784: LD_VAR 0 11
54788: NOT
54789: IFFALSE 54801
// x := mcts ;
54791: LD_ADDR_VAR 0 11
54795: PUSH
54796: LD_VAR 0 10
54800: ST_TO_ADDR
// if mc_remote_driver [ i ] then
54801: LD_EXP 139
54805: PUSH
54806: LD_VAR 0 2
54810: ARRAY
54811: IFFALSE 55080
// for j in mc_remote_driver [ i ] do
54813: LD_ADDR_VAR 0 3
54817: PUSH
54818: LD_EXP 139
54822: PUSH
54823: LD_VAR 0 2
54827: ARRAY
54828: PUSH
54829: FOR_IN
54830: IFFALSE 55078
// begin if GetClass ( j ) <> 3 then
54832: LD_VAR 0 3
54836: PPUSH
54837: CALL_OW 257
54841: PUSH
54842: LD_INT 3
54844: NONEQUAL
54845: IFFALSE 54898
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
54847: LD_ADDR_EXP 139
54851: PUSH
54852: LD_EXP 139
54856: PPUSH
54857: LD_VAR 0 2
54861: PPUSH
54862: LD_EXP 139
54866: PUSH
54867: LD_VAR 0 2
54871: ARRAY
54872: PUSH
54873: LD_VAR 0 3
54877: DIFF
54878: PPUSH
54879: CALL_OW 1
54883: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54884: LD_VAR 0 3
54888: PPUSH
54889: LD_INT 0
54891: PPUSH
54892: CALL_OW 109
// continue ;
54896: GO 54829
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
54898: LD_VAR 0 3
54902: PPUSH
54903: CALL_OW 310
54907: NOT
54908: PUSH
54909: LD_VAR 0 3
54913: PPUSH
54914: CALL_OW 310
54918: PPUSH
54919: CALL_OW 266
54923: PUSH
54924: LD_INT 36
54926: NONEQUAL
54927: PUSH
54928: LD_VAR 0 3
54932: PPUSH
54933: CALL 102997 0 1
54937: NOT
54938: AND
54939: OR
54940: IFFALSE 55076
// begin if IsInUnit ( j ) then
54942: LD_VAR 0 3
54946: PPUSH
54947: CALL_OW 310
54951: IFFALSE 54962
// ComExitBuilding ( j ) ;
54953: LD_VAR 0 3
54957: PPUSH
54958: CALL_OW 122
// ct := 0 ;
54962: LD_ADDR_VAR 0 8
54966: PUSH
54967: LD_INT 0
54969: ST_TO_ADDR
// for k in x do
54970: LD_ADDR_VAR 0 4
54974: PUSH
54975: LD_VAR 0 11
54979: PUSH
54980: FOR_IN
54981: IFFALSE 55054
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
54983: LD_VAR 0 4
54987: PPUSH
54988: CALL_OW 264
54992: PUSH
54993: LD_INT 31
54995: EQUAL
54996: PUSH
54997: LD_VAR 0 4
55001: PPUSH
55002: CALL_OW 311
55006: NOT
55007: AND
55008: PUSH
55009: LD_VAR 0 4
55013: PPUSH
55014: CALL_OW 266
55018: PUSH
55019: LD_INT 36
55021: EQUAL
55022: PUSH
55023: LD_VAR 0 4
55027: PPUSH
55028: CALL_OW 313
55032: PUSH
55033: LD_INT 3
55035: LESS
55036: AND
55037: OR
55038: IFFALSE 55052
// begin ct := k ;
55040: LD_ADDR_VAR 0 8
55044: PUSH
55045: LD_VAR 0 4
55049: ST_TO_ADDR
// break ;
55050: GO 55054
// end ;
55052: GO 54980
55054: POP
55055: POP
// if ct then
55056: LD_VAR 0 8
55060: IFFALSE 55076
// ComEnterUnit ( j , ct ) ;
55062: LD_VAR 0 3
55066: PPUSH
55067: LD_VAR 0 8
55071: PPUSH
55072: CALL_OW 120
// end ; end ;
55076: GO 54829
55078: POP
55079: POP
// places := 0 ;
55080: LD_ADDR_VAR 0 5
55084: PUSH
55085: LD_INT 0
55087: ST_TO_ADDR
// for j = 1 to x do
55088: LD_ADDR_VAR 0 3
55092: PUSH
55093: DOUBLE
55094: LD_INT 1
55096: DEC
55097: ST_TO_ADDR
55098: LD_VAR 0 11
55102: PUSH
55103: FOR_TO
55104: IFFALSE 55159
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55106: LD_VAR 0 11
55110: PUSH
55111: LD_VAR 0 3
55115: ARRAY
55116: PPUSH
55117: CALL_OW 264
55121: PUSH
55122: LD_INT 31
55124: EQUAL
55125: IFFALSE 55143
// places := places + 1 else
55127: LD_ADDR_VAR 0 5
55131: PUSH
55132: LD_VAR 0 5
55136: PUSH
55137: LD_INT 1
55139: PLUS
55140: ST_TO_ADDR
55141: GO 55157
// places := places + 3 ;
55143: LD_ADDR_VAR 0 5
55147: PUSH
55148: LD_VAR 0 5
55152: PUSH
55153: LD_INT 3
55155: PLUS
55156: ST_TO_ADDR
55157: GO 55103
55159: POP
55160: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55161: LD_ADDR_VAR 0 6
55165: PUSH
55166: LD_EXP 99
55170: PUSH
55171: LD_VAR 0 2
55175: ARRAY
55176: PPUSH
55177: LD_INT 25
55179: PUSH
55180: LD_INT 3
55182: PUSH
55183: EMPTY
55184: LIST
55185: LIST
55186: PPUSH
55187: CALL_OW 72
55191: PUSH
55192: LD_EXP 139
55196: PUSH
55197: LD_VAR 0 2
55201: ARRAY
55202: DIFF
55203: PPUSH
55204: LD_INT 3
55206: PPUSH
55207: CALL 103897 0 2
55211: ST_TO_ADDR
// if not tmp then
55212: LD_VAR 0 6
55216: NOT
55217: IFFALSE 55221
// continue ;
55219: GO 54601
// places := places - mc_remote_driver [ i ] ;
55221: LD_ADDR_VAR 0 5
55225: PUSH
55226: LD_VAR 0 5
55230: PUSH
55231: LD_EXP 139
55235: PUSH
55236: LD_VAR 0 2
55240: ARRAY
55241: MINUS
55242: ST_TO_ADDR
// if places then
55243: LD_VAR 0 5
55247: IFFALSE 55306
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
55249: LD_ADDR_EXP 139
55253: PUSH
55254: LD_EXP 139
55258: PPUSH
55259: LD_VAR 0 2
55263: PPUSH
55264: LD_EXP 139
55268: PUSH
55269: LD_VAR 0 2
55273: ARRAY
55274: PUSH
55275: LD_VAR 0 6
55279: PUSH
55280: LD_INT 1
55282: ARRAY
55283: UNION
55284: PPUSH
55285: CALL_OW 1
55289: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
55290: LD_VAR 0 6
55294: PUSH
55295: LD_INT 1
55297: ARRAY
55298: PPUSH
55299: LD_INT 126
55301: PPUSH
55302: CALL_OW 109
// end ; end ;
55306: GO 54601
55308: POP
55309: POP
// end ;
55310: LD_VAR 0 1
55314: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
55315: LD_INT 0
55317: PPUSH
55318: PPUSH
55319: PPUSH
55320: PPUSH
55321: PPUSH
55322: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
55323: LD_VAR 0 1
55327: NOT
55328: PUSH
55329: LD_VAR 0 2
55333: NOT
55334: OR
55335: PUSH
55336: LD_VAR 0 3
55340: NOT
55341: OR
55342: PUSH
55343: LD_VAR 0 4
55347: PUSH
55348: LD_INT 1
55350: PUSH
55351: LD_INT 2
55353: PUSH
55354: LD_INT 3
55356: PUSH
55357: LD_INT 4
55359: PUSH
55360: LD_INT 5
55362: PUSH
55363: LD_INT 8
55365: PUSH
55366: LD_INT 9
55368: PUSH
55369: LD_INT 15
55371: PUSH
55372: LD_INT 16
55374: PUSH
55375: EMPTY
55376: LIST
55377: LIST
55378: LIST
55379: LIST
55380: LIST
55381: LIST
55382: LIST
55383: LIST
55384: LIST
55385: IN
55386: NOT
55387: OR
55388: IFFALSE 55392
// exit ;
55390: GO 56292
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
55392: LD_ADDR_VAR 0 2
55396: PUSH
55397: LD_VAR 0 2
55401: PPUSH
55402: LD_INT 21
55404: PUSH
55405: LD_INT 3
55407: PUSH
55408: EMPTY
55409: LIST
55410: LIST
55411: PUSH
55412: LD_INT 24
55414: PUSH
55415: LD_INT 250
55417: PUSH
55418: EMPTY
55419: LIST
55420: LIST
55421: PUSH
55422: EMPTY
55423: LIST
55424: LIST
55425: PPUSH
55426: CALL_OW 72
55430: ST_TO_ADDR
// case class of 1 , 15 :
55431: LD_VAR 0 4
55435: PUSH
55436: LD_INT 1
55438: DOUBLE
55439: EQUAL
55440: IFTRUE 55450
55442: LD_INT 15
55444: DOUBLE
55445: EQUAL
55446: IFTRUE 55450
55448: GO 55535
55450: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
55451: LD_ADDR_VAR 0 8
55455: PUSH
55456: LD_VAR 0 2
55460: PPUSH
55461: LD_INT 2
55463: PUSH
55464: LD_INT 30
55466: PUSH
55467: LD_INT 32
55469: PUSH
55470: EMPTY
55471: LIST
55472: LIST
55473: PUSH
55474: LD_INT 30
55476: PUSH
55477: LD_INT 31
55479: PUSH
55480: EMPTY
55481: LIST
55482: LIST
55483: PUSH
55484: EMPTY
55485: LIST
55486: LIST
55487: LIST
55488: PPUSH
55489: CALL_OW 72
55493: PUSH
55494: LD_VAR 0 2
55498: PPUSH
55499: LD_INT 2
55501: PUSH
55502: LD_INT 30
55504: PUSH
55505: LD_INT 4
55507: PUSH
55508: EMPTY
55509: LIST
55510: LIST
55511: PUSH
55512: LD_INT 30
55514: PUSH
55515: LD_INT 5
55517: PUSH
55518: EMPTY
55519: LIST
55520: LIST
55521: PUSH
55522: EMPTY
55523: LIST
55524: LIST
55525: LIST
55526: PPUSH
55527: CALL_OW 72
55531: ADD
55532: ST_TO_ADDR
55533: GO 55781
55535: LD_INT 2
55537: DOUBLE
55538: EQUAL
55539: IFTRUE 55549
55541: LD_INT 16
55543: DOUBLE
55544: EQUAL
55545: IFTRUE 55549
55547: GO 55595
55549: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
55550: LD_ADDR_VAR 0 8
55554: PUSH
55555: LD_VAR 0 2
55559: PPUSH
55560: LD_INT 2
55562: PUSH
55563: LD_INT 30
55565: PUSH
55566: LD_INT 0
55568: PUSH
55569: EMPTY
55570: LIST
55571: LIST
55572: PUSH
55573: LD_INT 30
55575: PUSH
55576: LD_INT 1
55578: PUSH
55579: EMPTY
55580: LIST
55581: LIST
55582: PUSH
55583: EMPTY
55584: LIST
55585: LIST
55586: LIST
55587: PPUSH
55588: CALL_OW 72
55592: ST_TO_ADDR
55593: GO 55781
55595: LD_INT 3
55597: DOUBLE
55598: EQUAL
55599: IFTRUE 55603
55601: GO 55649
55603: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
55604: LD_ADDR_VAR 0 8
55608: PUSH
55609: LD_VAR 0 2
55613: PPUSH
55614: LD_INT 2
55616: PUSH
55617: LD_INT 30
55619: PUSH
55620: LD_INT 2
55622: PUSH
55623: EMPTY
55624: LIST
55625: LIST
55626: PUSH
55627: LD_INT 30
55629: PUSH
55630: LD_INT 3
55632: PUSH
55633: EMPTY
55634: LIST
55635: LIST
55636: PUSH
55637: EMPTY
55638: LIST
55639: LIST
55640: LIST
55641: PPUSH
55642: CALL_OW 72
55646: ST_TO_ADDR
55647: GO 55781
55649: LD_INT 4
55651: DOUBLE
55652: EQUAL
55653: IFTRUE 55657
55655: GO 55714
55657: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
55658: LD_ADDR_VAR 0 8
55662: PUSH
55663: LD_VAR 0 2
55667: PPUSH
55668: LD_INT 2
55670: PUSH
55671: LD_INT 30
55673: PUSH
55674: LD_INT 6
55676: PUSH
55677: EMPTY
55678: LIST
55679: LIST
55680: PUSH
55681: LD_INT 30
55683: PUSH
55684: LD_INT 7
55686: PUSH
55687: EMPTY
55688: LIST
55689: LIST
55690: PUSH
55691: LD_INT 30
55693: PUSH
55694: LD_INT 8
55696: PUSH
55697: EMPTY
55698: LIST
55699: LIST
55700: PUSH
55701: EMPTY
55702: LIST
55703: LIST
55704: LIST
55705: LIST
55706: PPUSH
55707: CALL_OW 72
55711: ST_TO_ADDR
55712: GO 55781
55714: LD_INT 5
55716: DOUBLE
55717: EQUAL
55718: IFTRUE 55734
55720: LD_INT 8
55722: DOUBLE
55723: EQUAL
55724: IFTRUE 55734
55726: LD_INT 9
55728: DOUBLE
55729: EQUAL
55730: IFTRUE 55734
55732: GO 55780
55734: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
55735: LD_ADDR_VAR 0 8
55739: PUSH
55740: LD_VAR 0 2
55744: PPUSH
55745: LD_INT 2
55747: PUSH
55748: LD_INT 30
55750: PUSH
55751: LD_INT 4
55753: PUSH
55754: EMPTY
55755: LIST
55756: LIST
55757: PUSH
55758: LD_INT 30
55760: PUSH
55761: LD_INT 5
55763: PUSH
55764: EMPTY
55765: LIST
55766: LIST
55767: PUSH
55768: EMPTY
55769: LIST
55770: LIST
55771: LIST
55772: PPUSH
55773: CALL_OW 72
55777: ST_TO_ADDR
55778: GO 55781
55780: POP
// if not tmp then
55781: LD_VAR 0 8
55785: NOT
55786: IFFALSE 55790
// exit ;
55788: GO 56292
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
55790: LD_VAR 0 4
55794: PUSH
55795: LD_INT 1
55797: PUSH
55798: LD_INT 15
55800: PUSH
55801: EMPTY
55802: LIST
55803: LIST
55804: IN
55805: PUSH
55806: LD_EXP 108
55810: PUSH
55811: LD_VAR 0 1
55815: ARRAY
55816: AND
55817: IFFALSE 55973
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
55819: LD_ADDR_VAR 0 9
55823: PUSH
55824: LD_EXP 108
55828: PUSH
55829: LD_VAR 0 1
55833: ARRAY
55834: PUSH
55835: LD_INT 1
55837: ARRAY
55838: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
55839: LD_VAR 0 9
55843: PUSH
55844: LD_EXP 109
55848: PUSH
55849: LD_VAR 0 1
55853: ARRAY
55854: IN
55855: NOT
55856: IFFALSE 55971
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
55858: LD_ADDR_EXP 109
55862: PUSH
55863: LD_EXP 109
55867: PPUSH
55868: LD_VAR 0 1
55872: PUSH
55873: LD_EXP 109
55877: PUSH
55878: LD_VAR 0 1
55882: ARRAY
55883: PUSH
55884: LD_INT 1
55886: PLUS
55887: PUSH
55888: EMPTY
55889: LIST
55890: LIST
55891: PPUSH
55892: LD_VAR 0 9
55896: PPUSH
55897: CALL 69649 0 3
55901: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
55902: LD_ADDR_EXP 108
55906: PUSH
55907: LD_EXP 108
55911: PPUSH
55912: LD_VAR 0 1
55916: PPUSH
55917: LD_EXP 108
55921: PUSH
55922: LD_VAR 0 1
55926: ARRAY
55927: PUSH
55928: LD_VAR 0 9
55932: DIFF
55933: PPUSH
55934: CALL_OW 1
55938: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
55939: LD_VAR 0 3
55943: PPUSH
55944: LD_EXP 109
55948: PUSH
55949: LD_VAR 0 1
55953: ARRAY
55954: PUSH
55955: LD_EXP 109
55959: PUSH
55960: LD_VAR 0 1
55964: ARRAY
55965: ARRAY
55966: PPUSH
55967: CALL_OW 120
// end ; exit ;
55971: GO 56292
// end ; if tmp > 1 then
55973: LD_VAR 0 8
55977: PUSH
55978: LD_INT 1
55980: GREATER
55981: IFFALSE 56085
// for i = 2 to tmp do
55983: LD_ADDR_VAR 0 6
55987: PUSH
55988: DOUBLE
55989: LD_INT 2
55991: DEC
55992: ST_TO_ADDR
55993: LD_VAR 0 8
55997: PUSH
55998: FOR_TO
55999: IFFALSE 56083
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56001: LD_VAR 0 8
56005: PUSH
56006: LD_VAR 0 6
56010: ARRAY
56011: PPUSH
56012: CALL_OW 461
56016: PUSH
56017: LD_INT 6
56019: EQUAL
56020: IFFALSE 56081
// begin x := tmp [ i ] ;
56022: LD_ADDR_VAR 0 9
56026: PUSH
56027: LD_VAR 0 8
56031: PUSH
56032: LD_VAR 0 6
56036: ARRAY
56037: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56038: LD_ADDR_VAR 0 8
56042: PUSH
56043: LD_VAR 0 8
56047: PPUSH
56048: LD_VAR 0 6
56052: PPUSH
56053: CALL_OW 3
56057: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56058: LD_ADDR_VAR 0 8
56062: PUSH
56063: LD_VAR 0 8
56067: PPUSH
56068: LD_INT 1
56070: PPUSH
56071: LD_VAR 0 9
56075: PPUSH
56076: CALL_OW 2
56080: ST_TO_ADDR
// end ;
56081: GO 55998
56083: POP
56084: POP
// for i in tmp do
56085: LD_ADDR_VAR 0 6
56089: PUSH
56090: LD_VAR 0 8
56094: PUSH
56095: FOR_IN
56096: IFFALSE 56165
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56098: LD_VAR 0 6
56102: PPUSH
56103: CALL_OW 313
56107: PUSH
56108: LD_INT 6
56110: LESS
56111: PUSH
56112: LD_VAR 0 6
56116: PPUSH
56117: CALL_OW 266
56121: PUSH
56122: LD_INT 31
56124: PUSH
56125: LD_INT 32
56127: PUSH
56128: EMPTY
56129: LIST
56130: LIST
56131: IN
56132: NOT
56133: AND
56134: PUSH
56135: LD_VAR 0 6
56139: PPUSH
56140: CALL_OW 313
56144: PUSH
56145: LD_INT 0
56147: EQUAL
56148: OR
56149: IFFALSE 56163
// begin j := i ;
56151: LD_ADDR_VAR 0 7
56155: PUSH
56156: LD_VAR 0 6
56160: ST_TO_ADDR
// break ;
56161: GO 56165
// end ; end ;
56163: GO 56095
56165: POP
56166: POP
// if j then
56167: LD_VAR 0 7
56171: IFFALSE 56189
// ComEnterUnit ( unit , j ) else
56173: LD_VAR 0 3
56177: PPUSH
56178: LD_VAR 0 7
56182: PPUSH
56183: CALL_OW 120
56187: GO 56292
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56189: LD_ADDR_VAR 0 10
56193: PUSH
56194: LD_VAR 0 2
56198: PPUSH
56199: LD_INT 2
56201: PUSH
56202: LD_INT 30
56204: PUSH
56205: LD_INT 0
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: PUSH
56212: LD_INT 30
56214: PUSH
56215: LD_INT 1
56217: PUSH
56218: EMPTY
56219: LIST
56220: LIST
56221: PUSH
56222: EMPTY
56223: LIST
56224: LIST
56225: LIST
56226: PPUSH
56227: CALL_OW 72
56231: ST_TO_ADDR
// if depot then
56232: LD_VAR 0 10
56236: IFFALSE 56292
// begin depot := NearestUnitToUnit ( depot , unit ) ;
56238: LD_ADDR_VAR 0 10
56242: PUSH
56243: LD_VAR 0 10
56247: PPUSH
56248: LD_VAR 0 3
56252: PPUSH
56253: CALL_OW 74
56257: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
56258: LD_VAR 0 3
56262: PPUSH
56263: LD_VAR 0 10
56267: PPUSH
56268: CALL_OW 296
56272: PUSH
56273: LD_INT 10
56275: GREATER
56276: IFFALSE 56292
// ComStandNearbyBuilding ( unit , depot ) ;
56278: LD_VAR 0 3
56282: PPUSH
56283: LD_VAR 0 10
56287: PPUSH
56288: CALL 64356 0 2
// end ; end ; end ;
56292: LD_VAR 0 5
56296: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
56297: LD_INT 0
56299: PPUSH
56300: PPUSH
56301: PPUSH
56302: PPUSH
// if not mc_bases then
56303: LD_EXP 99
56307: NOT
56308: IFFALSE 56312
// exit ;
56310: GO 56551
// for i = 1 to mc_bases do
56312: LD_ADDR_VAR 0 2
56316: PUSH
56317: DOUBLE
56318: LD_INT 1
56320: DEC
56321: ST_TO_ADDR
56322: LD_EXP 99
56326: PUSH
56327: FOR_TO
56328: IFFALSE 56549
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
56330: LD_ADDR_VAR 0 4
56334: PUSH
56335: LD_EXP 99
56339: PUSH
56340: LD_VAR 0 2
56344: ARRAY
56345: PPUSH
56346: LD_INT 21
56348: PUSH
56349: LD_INT 1
56351: PUSH
56352: EMPTY
56353: LIST
56354: LIST
56355: PPUSH
56356: CALL_OW 72
56360: PUSH
56361: LD_EXP 128
56365: PUSH
56366: LD_VAR 0 2
56370: ARRAY
56371: UNION
56372: ST_TO_ADDR
// if not tmp then
56373: LD_VAR 0 4
56377: NOT
56378: IFFALSE 56382
// continue ;
56380: GO 56327
// for j in tmp do
56382: LD_ADDR_VAR 0 3
56386: PUSH
56387: LD_VAR 0 4
56391: PUSH
56392: FOR_IN
56393: IFFALSE 56545
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
56395: LD_VAR 0 3
56399: PPUSH
56400: CALL_OW 110
56404: NOT
56405: PUSH
56406: LD_VAR 0 3
56410: PPUSH
56411: CALL_OW 314
56415: NOT
56416: AND
56417: PUSH
56418: LD_VAR 0 3
56422: PPUSH
56423: CALL_OW 311
56427: NOT
56428: AND
56429: PUSH
56430: LD_VAR 0 3
56434: PPUSH
56435: CALL_OW 310
56439: NOT
56440: AND
56441: PUSH
56442: LD_VAR 0 3
56446: PUSH
56447: LD_EXP 102
56451: PUSH
56452: LD_VAR 0 2
56456: ARRAY
56457: PUSH
56458: LD_INT 1
56460: ARRAY
56461: IN
56462: NOT
56463: AND
56464: PUSH
56465: LD_VAR 0 3
56469: PUSH
56470: LD_EXP 102
56474: PUSH
56475: LD_VAR 0 2
56479: ARRAY
56480: PUSH
56481: LD_INT 2
56483: ARRAY
56484: IN
56485: NOT
56486: AND
56487: PUSH
56488: LD_VAR 0 3
56492: PUSH
56493: LD_EXP 111
56497: PUSH
56498: LD_VAR 0 2
56502: ARRAY
56503: IN
56504: NOT
56505: AND
56506: IFFALSE 56543
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
56508: LD_VAR 0 2
56512: PPUSH
56513: LD_EXP 99
56517: PUSH
56518: LD_VAR 0 2
56522: ARRAY
56523: PPUSH
56524: LD_VAR 0 3
56528: PPUSH
56529: LD_VAR 0 3
56533: PPUSH
56534: CALL_OW 257
56538: PPUSH
56539: CALL 55315 0 4
// end ;
56543: GO 56392
56545: POP
56546: POP
// end ;
56547: GO 56327
56549: POP
56550: POP
// end ;
56551: LD_VAR 0 1
56555: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
56556: LD_INT 0
56558: PPUSH
56559: PPUSH
56560: PPUSH
56561: PPUSH
56562: PPUSH
56563: PPUSH
// if not mc_bases [ base ] then
56564: LD_EXP 99
56568: PUSH
56569: LD_VAR 0 1
56573: ARRAY
56574: NOT
56575: IFFALSE 56579
// exit ;
56577: GO 56761
// tmp := [ ] ;
56579: LD_ADDR_VAR 0 6
56583: PUSH
56584: EMPTY
56585: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
56586: LD_ADDR_VAR 0 7
56590: PUSH
56591: LD_VAR 0 3
56595: PPUSH
56596: LD_INT 0
56598: PPUSH
56599: CALL_OW 517
56603: ST_TO_ADDR
// if not list then
56604: LD_VAR 0 7
56608: NOT
56609: IFFALSE 56613
// exit ;
56611: GO 56761
// for i = 1 to amount do
56613: LD_ADDR_VAR 0 5
56617: PUSH
56618: DOUBLE
56619: LD_INT 1
56621: DEC
56622: ST_TO_ADDR
56623: LD_VAR 0 2
56627: PUSH
56628: FOR_TO
56629: IFFALSE 56709
// begin x := rand ( 1 , list [ 1 ] ) ;
56631: LD_ADDR_VAR 0 8
56635: PUSH
56636: LD_INT 1
56638: PPUSH
56639: LD_VAR 0 7
56643: PUSH
56644: LD_INT 1
56646: ARRAY
56647: PPUSH
56648: CALL_OW 12
56652: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
56653: LD_ADDR_VAR 0 6
56657: PUSH
56658: LD_VAR 0 6
56662: PPUSH
56663: LD_VAR 0 5
56667: PPUSH
56668: LD_VAR 0 7
56672: PUSH
56673: LD_INT 1
56675: ARRAY
56676: PUSH
56677: LD_VAR 0 8
56681: ARRAY
56682: PUSH
56683: LD_VAR 0 7
56687: PUSH
56688: LD_INT 2
56690: ARRAY
56691: PUSH
56692: LD_VAR 0 8
56696: ARRAY
56697: PUSH
56698: EMPTY
56699: LIST
56700: LIST
56701: PPUSH
56702: CALL_OW 1
56706: ST_TO_ADDR
// end ;
56707: GO 56628
56709: POP
56710: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
56711: LD_ADDR_EXP 112
56715: PUSH
56716: LD_EXP 112
56720: PPUSH
56721: LD_VAR 0 1
56725: PPUSH
56726: LD_VAR 0 6
56730: PPUSH
56731: CALL_OW 1
56735: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
56736: LD_ADDR_EXP 114
56740: PUSH
56741: LD_EXP 114
56745: PPUSH
56746: LD_VAR 0 1
56750: PPUSH
56751: LD_VAR 0 3
56755: PPUSH
56756: CALL_OW 1
56760: ST_TO_ADDR
// end ;
56761: LD_VAR 0 4
56765: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
56766: LD_INT 0
56768: PPUSH
// if not mc_bases [ base ] then
56769: LD_EXP 99
56773: PUSH
56774: LD_VAR 0 1
56778: ARRAY
56779: NOT
56780: IFFALSE 56784
// exit ;
56782: GO 56809
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
56784: LD_ADDR_EXP 104
56788: PUSH
56789: LD_EXP 104
56793: PPUSH
56794: LD_VAR 0 1
56798: PPUSH
56799: LD_VAR 0 2
56803: PPUSH
56804: CALL_OW 1
56808: ST_TO_ADDR
// end ;
56809: LD_VAR 0 3
56813: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
56814: LD_INT 0
56816: PPUSH
// if not mc_bases [ base ] then
56817: LD_EXP 99
56821: PUSH
56822: LD_VAR 0 1
56826: ARRAY
56827: NOT
56828: IFFALSE 56832
// exit ;
56830: GO 56869
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
56832: LD_ADDR_EXP 104
56836: PUSH
56837: LD_EXP 104
56841: PPUSH
56842: LD_VAR 0 1
56846: PPUSH
56847: LD_EXP 104
56851: PUSH
56852: LD_VAR 0 1
56856: ARRAY
56857: PUSH
56858: LD_VAR 0 2
56862: UNION
56863: PPUSH
56864: CALL_OW 1
56868: ST_TO_ADDR
// end ;
56869: LD_VAR 0 3
56873: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
56874: LD_INT 0
56876: PPUSH
// if not mc_bases [ base ] then
56877: LD_EXP 99
56881: PUSH
56882: LD_VAR 0 1
56886: ARRAY
56887: NOT
56888: IFFALSE 56892
// exit ;
56890: GO 56917
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
56892: LD_ADDR_EXP 120
56896: PUSH
56897: LD_EXP 120
56901: PPUSH
56902: LD_VAR 0 1
56906: PPUSH
56907: LD_VAR 0 2
56911: PPUSH
56912: CALL_OW 1
56916: ST_TO_ADDR
// end ;
56917: LD_VAR 0 3
56921: RET
// export function MC_InsertProduceList ( base , components ) ; begin
56922: LD_INT 0
56924: PPUSH
// if not mc_bases [ base ] then
56925: LD_EXP 99
56929: PUSH
56930: LD_VAR 0 1
56934: ARRAY
56935: NOT
56936: IFFALSE 56940
// exit ;
56938: GO 56977
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
56940: LD_ADDR_EXP 120
56944: PUSH
56945: LD_EXP 120
56949: PPUSH
56950: LD_VAR 0 1
56954: PPUSH
56955: LD_EXP 120
56959: PUSH
56960: LD_VAR 0 1
56964: ARRAY
56965: PUSH
56966: LD_VAR 0 2
56970: ADD
56971: PPUSH
56972: CALL_OW 1
56976: ST_TO_ADDR
// end ;
56977: LD_VAR 0 3
56981: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
56982: LD_INT 0
56984: PPUSH
// if not mc_bases [ base ] then
56985: LD_EXP 99
56989: PUSH
56990: LD_VAR 0 1
56994: ARRAY
56995: NOT
56996: IFFALSE 57000
// exit ;
56998: GO 57054
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57000: LD_ADDR_EXP 121
57004: PUSH
57005: LD_EXP 121
57009: PPUSH
57010: LD_VAR 0 1
57014: PPUSH
57015: LD_VAR 0 2
57019: PPUSH
57020: CALL_OW 1
57024: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57025: LD_ADDR_EXP 110
57029: PUSH
57030: LD_EXP 110
57034: PPUSH
57035: LD_VAR 0 1
57039: PPUSH
57040: LD_VAR 0 2
57044: PUSH
57045: LD_INT 0
57047: PLUS
57048: PPUSH
57049: CALL_OW 1
57053: ST_TO_ADDR
// end ;
57054: LD_VAR 0 3
57058: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57059: LD_INT 0
57061: PPUSH
// if not mc_bases [ base ] then
57062: LD_EXP 99
57066: PUSH
57067: LD_VAR 0 1
57071: ARRAY
57072: NOT
57073: IFFALSE 57077
// exit ;
57075: GO 57102
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57077: LD_ADDR_EXP 110
57081: PUSH
57082: LD_EXP 110
57086: PPUSH
57087: LD_VAR 0 1
57091: PPUSH
57092: LD_VAR 0 2
57096: PPUSH
57097: CALL_OW 1
57101: ST_TO_ADDR
// end ;
57102: LD_VAR 0 3
57106: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57107: LD_INT 0
57109: PPUSH
57110: PPUSH
57111: PPUSH
57112: PPUSH
// if not mc_bases [ base ] then
57113: LD_EXP 99
57117: PUSH
57118: LD_VAR 0 1
57122: ARRAY
57123: NOT
57124: IFFALSE 57128
// exit ;
57126: GO 57193
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57128: LD_ADDR_EXP 119
57132: PUSH
57133: LD_EXP 119
57137: PPUSH
57138: LD_VAR 0 1
57142: PUSH
57143: LD_EXP 119
57147: PUSH
57148: LD_VAR 0 1
57152: ARRAY
57153: PUSH
57154: LD_INT 1
57156: PLUS
57157: PUSH
57158: EMPTY
57159: LIST
57160: LIST
57161: PPUSH
57162: LD_VAR 0 1
57166: PUSH
57167: LD_VAR 0 2
57171: PUSH
57172: LD_VAR 0 3
57176: PUSH
57177: LD_VAR 0 4
57181: PUSH
57182: EMPTY
57183: LIST
57184: LIST
57185: LIST
57186: LIST
57187: PPUSH
57188: CALL 69649 0 3
57192: ST_TO_ADDR
// end ;
57193: LD_VAR 0 5
57197: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
57198: LD_INT 0
57200: PPUSH
// if not mc_bases [ base ] then
57201: LD_EXP 99
57205: PUSH
57206: LD_VAR 0 1
57210: ARRAY
57211: NOT
57212: IFFALSE 57216
// exit ;
57214: GO 57241
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
57216: LD_ADDR_EXP 136
57220: PUSH
57221: LD_EXP 136
57225: PPUSH
57226: LD_VAR 0 1
57230: PPUSH
57231: LD_VAR 0 2
57235: PPUSH
57236: CALL_OW 1
57240: ST_TO_ADDR
// end ;
57241: LD_VAR 0 3
57245: RET
// export function MC_GetMinesField ( base ) ; begin
57246: LD_INT 0
57248: PPUSH
// result := mc_mines [ base ] ;
57249: LD_ADDR_VAR 0 2
57253: PUSH
57254: LD_EXP 112
57258: PUSH
57259: LD_VAR 0 1
57263: ARRAY
57264: ST_TO_ADDR
// end ;
57265: LD_VAR 0 2
57269: RET
// export function MC_GetProduceList ( base ) ; begin
57270: LD_INT 0
57272: PPUSH
// result := mc_produce [ base ] ;
57273: LD_ADDR_VAR 0 2
57277: PUSH
57278: LD_EXP 120
57282: PUSH
57283: LD_VAR 0 1
57287: ARRAY
57288: ST_TO_ADDR
// end ;
57289: LD_VAR 0 2
57293: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
57294: LD_INT 0
57296: PPUSH
57297: PPUSH
// if not mc_bases then
57298: LD_EXP 99
57302: NOT
57303: IFFALSE 57307
// exit ;
57305: GO 57372
// if mc_bases [ base ] then
57307: LD_EXP 99
57311: PUSH
57312: LD_VAR 0 1
57316: ARRAY
57317: IFFALSE 57372
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57319: LD_ADDR_VAR 0 3
57323: PUSH
57324: LD_EXP 99
57328: PUSH
57329: LD_VAR 0 1
57333: ARRAY
57334: PPUSH
57335: LD_INT 30
57337: PUSH
57338: LD_VAR 0 2
57342: PUSH
57343: EMPTY
57344: LIST
57345: LIST
57346: PPUSH
57347: CALL_OW 72
57351: ST_TO_ADDR
// if result then
57352: LD_VAR 0 3
57356: IFFALSE 57372
// result := result [ 1 ] ;
57358: LD_ADDR_VAR 0 3
57362: PUSH
57363: LD_VAR 0 3
57367: PUSH
57368: LD_INT 1
57370: ARRAY
57371: ST_TO_ADDR
// end ; end ;
57372: LD_VAR 0 3
57376: RET
// export function MC_SetTame ( base , area ) ; begin
57377: LD_INT 0
57379: PPUSH
// if not mc_bases or not base then
57380: LD_EXP 99
57384: NOT
57385: PUSH
57386: LD_VAR 0 1
57390: NOT
57391: OR
57392: IFFALSE 57396
// exit ;
57394: GO 57421
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
57396: LD_ADDR_EXP 127
57400: PUSH
57401: LD_EXP 127
57405: PPUSH
57406: LD_VAR 0 1
57410: PPUSH
57411: LD_VAR 0 2
57415: PPUSH
57416: CALL_OW 1
57420: ST_TO_ADDR
// end ;
57421: LD_VAR 0 3
57425: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
57426: LD_INT 0
57428: PPUSH
57429: PPUSH
// if not mc_bases or not base then
57430: LD_EXP 99
57434: NOT
57435: PUSH
57436: LD_VAR 0 1
57440: NOT
57441: OR
57442: IFFALSE 57446
// exit ;
57444: GO 57548
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
57446: LD_ADDR_VAR 0 4
57450: PUSH
57451: LD_EXP 99
57455: PUSH
57456: LD_VAR 0 1
57460: ARRAY
57461: PPUSH
57462: LD_INT 30
57464: PUSH
57465: LD_VAR 0 2
57469: PUSH
57470: EMPTY
57471: LIST
57472: LIST
57473: PPUSH
57474: CALL_OW 72
57478: ST_TO_ADDR
// if not tmp then
57479: LD_VAR 0 4
57483: NOT
57484: IFFALSE 57488
// exit ;
57486: GO 57548
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
57488: LD_ADDR_EXP 131
57492: PUSH
57493: LD_EXP 131
57497: PPUSH
57498: LD_VAR 0 1
57502: PPUSH
57503: LD_EXP 131
57507: PUSH
57508: LD_VAR 0 1
57512: ARRAY
57513: PPUSH
57514: LD_EXP 131
57518: PUSH
57519: LD_VAR 0 1
57523: ARRAY
57524: PUSH
57525: LD_INT 1
57527: PLUS
57528: PPUSH
57529: LD_VAR 0 4
57533: PUSH
57534: LD_INT 1
57536: ARRAY
57537: PPUSH
57538: CALL_OW 2
57542: PPUSH
57543: CALL_OW 1
57547: ST_TO_ADDR
// end ;
57548: LD_VAR 0 3
57552: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
57553: LD_INT 0
57555: PPUSH
57556: PPUSH
// if not mc_bases or not base or not kinds then
57557: LD_EXP 99
57561: NOT
57562: PUSH
57563: LD_VAR 0 1
57567: NOT
57568: OR
57569: PUSH
57570: LD_VAR 0 2
57574: NOT
57575: OR
57576: IFFALSE 57580
// exit ;
57578: GO 57641
// for i in kinds do
57580: LD_ADDR_VAR 0 4
57584: PUSH
57585: LD_VAR 0 2
57589: PUSH
57590: FOR_IN
57591: IFFALSE 57639
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
57593: LD_ADDR_EXP 133
57597: PUSH
57598: LD_EXP 133
57602: PPUSH
57603: LD_VAR 0 1
57607: PUSH
57608: LD_EXP 133
57612: PUSH
57613: LD_VAR 0 1
57617: ARRAY
57618: PUSH
57619: LD_INT 1
57621: PLUS
57622: PUSH
57623: EMPTY
57624: LIST
57625: LIST
57626: PPUSH
57627: LD_VAR 0 4
57631: PPUSH
57632: CALL 69649 0 3
57636: ST_TO_ADDR
57637: GO 57590
57639: POP
57640: POP
// end ;
57641: LD_VAR 0 3
57645: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
57646: LD_INT 0
57648: PPUSH
// if not mc_bases or not base or not areas then
57649: LD_EXP 99
57653: NOT
57654: PUSH
57655: LD_VAR 0 1
57659: NOT
57660: OR
57661: PUSH
57662: LD_VAR 0 2
57666: NOT
57667: OR
57668: IFFALSE 57672
// exit ;
57670: GO 57697
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
57672: LD_ADDR_EXP 117
57676: PUSH
57677: LD_EXP 117
57681: PPUSH
57682: LD_VAR 0 1
57686: PPUSH
57687: LD_VAR 0 2
57691: PPUSH
57692: CALL_OW 1
57696: ST_TO_ADDR
// end ;
57697: LD_VAR 0 3
57701: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
57702: LD_INT 0
57704: PPUSH
// if not mc_bases or not base or not teleports_exit then
57705: LD_EXP 99
57709: NOT
57710: PUSH
57711: LD_VAR 0 1
57715: NOT
57716: OR
57717: PUSH
57718: LD_VAR 0 2
57722: NOT
57723: OR
57724: IFFALSE 57728
// exit ;
57726: GO 57753
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
57728: LD_ADDR_EXP 134
57732: PUSH
57733: LD_EXP 134
57737: PPUSH
57738: LD_VAR 0 1
57742: PPUSH
57743: LD_VAR 0 2
57747: PPUSH
57748: CALL_OW 1
57752: ST_TO_ADDR
// end ;
57753: LD_VAR 0 3
57757: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
57758: LD_INT 0
57760: PPUSH
57761: PPUSH
57762: PPUSH
// if not mc_bases or not base or not ext_list then
57763: LD_EXP 99
57767: NOT
57768: PUSH
57769: LD_VAR 0 1
57773: NOT
57774: OR
57775: PUSH
57776: LD_VAR 0 5
57780: NOT
57781: OR
57782: IFFALSE 57786
// exit ;
57784: GO 57959
// tmp := GetFacExtXYD ( x , y , d ) ;
57786: LD_ADDR_VAR 0 8
57790: PUSH
57791: LD_VAR 0 2
57795: PPUSH
57796: LD_VAR 0 3
57800: PPUSH
57801: LD_VAR 0 4
57805: PPUSH
57806: CALL 103027 0 3
57810: ST_TO_ADDR
// if not tmp then
57811: LD_VAR 0 8
57815: NOT
57816: IFFALSE 57820
// exit ;
57818: GO 57959
// for i in tmp do
57820: LD_ADDR_VAR 0 7
57824: PUSH
57825: LD_VAR 0 8
57829: PUSH
57830: FOR_IN
57831: IFFALSE 57957
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
57833: LD_ADDR_EXP 104
57837: PUSH
57838: LD_EXP 104
57842: PPUSH
57843: LD_VAR 0 1
57847: PPUSH
57848: LD_EXP 104
57852: PUSH
57853: LD_VAR 0 1
57857: ARRAY
57858: PPUSH
57859: LD_EXP 104
57863: PUSH
57864: LD_VAR 0 1
57868: ARRAY
57869: PUSH
57870: LD_INT 1
57872: PLUS
57873: PPUSH
57874: LD_VAR 0 5
57878: PUSH
57879: LD_INT 1
57881: ARRAY
57882: PUSH
57883: LD_VAR 0 7
57887: PUSH
57888: LD_INT 1
57890: ARRAY
57891: PUSH
57892: LD_VAR 0 7
57896: PUSH
57897: LD_INT 2
57899: ARRAY
57900: PUSH
57901: LD_VAR 0 7
57905: PUSH
57906: LD_INT 3
57908: ARRAY
57909: PUSH
57910: EMPTY
57911: LIST
57912: LIST
57913: LIST
57914: LIST
57915: PPUSH
57916: CALL_OW 2
57920: PPUSH
57921: CALL_OW 1
57925: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
57926: LD_ADDR_VAR 0 5
57930: PUSH
57931: LD_VAR 0 5
57935: PPUSH
57936: LD_INT 1
57938: PPUSH
57939: CALL_OW 3
57943: ST_TO_ADDR
// if not ext_list then
57944: LD_VAR 0 5
57948: NOT
57949: IFFALSE 57955
// exit ;
57951: POP
57952: POP
57953: GO 57959
// end ;
57955: GO 57830
57957: POP
57958: POP
// end ;
57959: LD_VAR 0 6
57963: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
57964: LD_INT 0
57966: PPUSH
// if not mc_bases or not base or not weapon_list then
57967: LD_EXP 99
57971: NOT
57972: PUSH
57973: LD_VAR 0 1
57977: NOT
57978: OR
57979: PUSH
57980: LD_VAR 0 2
57984: NOT
57985: OR
57986: IFFALSE 57990
// exit ;
57988: GO 58015
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
57990: LD_ADDR_EXP 138
57994: PUSH
57995: LD_EXP 138
57999: PPUSH
58000: LD_VAR 0 1
58004: PPUSH
58005: LD_VAR 0 2
58009: PPUSH
58010: CALL_OW 1
58014: ST_TO_ADDR
// end ;
58015: LD_VAR 0 3
58019: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58020: LD_INT 0
58022: PPUSH
// if not mc_bases or not base or not tech_list then
58023: LD_EXP 99
58027: NOT
58028: PUSH
58029: LD_VAR 0 1
58033: NOT
58034: OR
58035: PUSH
58036: LD_VAR 0 2
58040: NOT
58041: OR
58042: IFFALSE 58046
// exit ;
58044: GO 58071
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58046: LD_ADDR_EXP 126
58050: PUSH
58051: LD_EXP 126
58055: PPUSH
58056: LD_VAR 0 1
58060: PPUSH
58061: LD_VAR 0 2
58065: PPUSH
58066: CALL_OW 1
58070: ST_TO_ADDR
// end ;
58071: LD_VAR 0 3
58075: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58076: LD_INT 0
58078: PPUSH
// if not mc_bases or not parking_area or not base then
58079: LD_EXP 99
58083: NOT
58084: PUSH
58085: LD_VAR 0 2
58089: NOT
58090: OR
58091: PUSH
58092: LD_VAR 0 1
58096: NOT
58097: OR
58098: IFFALSE 58102
// exit ;
58100: GO 58127
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58102: LD_ADDR_EXP 123
58106: PUSH
58107: LD_EXP 123
58111: PPUSH
58112: LD_VAR 0 1
58116: PPUSH
58117: LD_VAR 0 2
58121: PPUSH
58122: CALL_OW 1
58126: ST_TO_ADDR
// end ;
58127: LD_VAR 0 3
58131: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
58132: LD_INT 0
58134: PPUSH
// if not mc_bases or not base or not scan_area then
58135: LD_EXP 99
58139: NOT
58140: PUSH
58141: LD_VAR 0 1
58145: NOT
58146: OR
58147: PUSH
58148: LD_VAR 0 2
58152: NOT
58153: OR
58154: IFFALSE 58158
// exit ;
58156: GO 58183
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
58158: LD_ADDR_EXP 124
58162: PUSH
58163: LD_EXP 124
58167: PPUSH
58168: LD_VAR 0 1
58172: PPUSH
58173: LD_VAR 0 2
58177: PPUSH
58178: CALL_OW 1
58182: ST_TO_ADDR
// end ;
58183: LD_VAR 0 3
58187: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
58188: LD_INT 0
58190: PPUSH
58191: PPUSH
// if not mc_bases or not base then
58192: LD_EXP 99
58196: NOT
58197: PUSH
58198: LD_VAR 0 1
58202: NOT
58203: OR
58204: IFFALSE 58208
// exit ;
58206: GO 58272
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
58208: LD_ADDR_VAR 0 3
58212: PUSH
58213: LD_INT 1
58215: PUSH
58216: LD_INT 2
58218: PUSH
58219: LD_INT 3
58221: PUSH
58222: LD_INT 4
58224: PUSH
58225: LD_INT 11
58227: PUSH
58228: EMPTY
58229: LIST
58230: LIST
58231: LIST
58232: LIST
58233: LIST
58234: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
58235: LD_ADDR_EXP 126
58239: PUSH
58240: LD_EXP 126
58244: PPUSH
58245: LD_VAR 0 1
58249: PPUSH
58250: LD_EXP 126
58254: PUSH
58255: LD_VAR 0 1
58259: ARRAY
58260: PUSH
58261: LD_VAR 0 3
58265: DIFF
58266: PPUSH
58267: CALL_OW 1
58271: ST_TO_ADDR
// end ;
58272: LD_VAR 0 2
58276: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
58277: LD_INT 0
58279: PPUSH
// result := mc_vehicles [ base ] ;
58280: LD_ADDR_VAR 0 3
58284: PUSH
58285: LD_EXP 118
58289: PUSH
58290: LD_VAR 0 1
58294: ARRAY
58295: ST_TO_ADDR
// if onlyCombat then
58296: LD_VAR 0 2
58300: IFFALSE 58465
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
58302: LD_ADDR_VAR 0 3
58306: PUSH
58307: LD_VAR 0 3
58311: PUSH
58312: LD_VAR 0 3
58316: PPUSH
58317: LD_INT 2
58319: PUSH
58320: LD_INT 34
58322: PUSH
58323: LD_INT 12
58325: PUSH
58326: EMPTY
58327: LIST
58328: LIST
58329: PUSH
58330: LD_INT 34
58332: PUSH
58333: LD_INT 51
58335: PUSH
58336: EMPTY
58337: LIST
58338: LIST
58339: PUSH
58340: LD_INT 34
58342: PUSH
58343: LD_EXP 93
58347: PUSH
58348: EMPTY
58349: LIST
58350: LIST
58351: PUSH
58352: LD_INT 34
58354: PUSH
58355: LD_INT 32
58357: PUSH
58358: EMPTY
58359: LIST
58360: LIST
58361: PUSH
58362: LD_INT 34
58364: PUSH
58365: LD_INT 13
58367: PUSH
58368: EMPTY
58369: LIST
58370: LIST
58371: PUSH
58372: LD_INT 34
58374: PUSH
58375: LD_INT 52
58377: PUSH
58378: EMPTY
58379: LIST
58380: LIST
58381: PUSH
58382: LD_INT 34
58384: PUSH
58385: LD_INT 14
58387: PUSH
58388: EMPTY
58389: LIST
58390: LIST
58391: PUSH
58392: LD_INT 34
58394: PUSH
58395: LD_INT 53
58397: PUSH
58398: EMPTY
58399: LIST
58400: LIST
58401: PUSH
58402: LD_INT 34
58404: PUSH
58405: LD_EXP 92
58409: PUSH
58410: EMPTY
58411: LIST
58412: LIST
58413: PUSH
58414: LD_INT 34
58416: PUSH
58417: LD_INT 31
58419: PUSH
58420: EMPTY
58421: LIST
58422: LIST
58423: PUSH
58424: LD_INT 34
58426: PUSH
58427: LD_INT 48
58429: PUSH
58430: EMPTY
58431: LIST
58432: LIST
58433: PUSH
58434: LD_INT 34
58436: PUSH
58437: LD_INT 8
58439: PUSH
58440: EMPTY
58441: LIST
58442: LIST
58443: PUSH
58444: EMPTY
58445: LIST
58446: LIST
58447: LIST
58448: LIST
58449: LIST
58450: LIST
58451: LIST
58452: LIST
58453: LIST
58454: LIST
58455: LIST
58456: LIST
58457: LIST
58458: PPUSH
58459: CALL_OW 72
58463: DIFF
58464: ST_TO_ADDR
// end ; end_of_file
58465: LD_VAR 0 3
58469: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
58470: LD_INT 0
58472: PPUSH
58473: PPUSH
58474: PPUSH
// if not mc_bases or not skirmish then
58475: LD_EXP 99
58479: NOT
58480: PUSH
58481: LD_EXP 97
58485: NOT
58486: OR
58487: IFFALSE 58491
// exit ;
58489: GO 58656
// for i = 1 to mc_bases do
58491: LD_ADDR_VAR 0 4
58495: PUSH
58496: DOUBLE
58497: LD_INT 1
58499: DEC
58500: ST_TO_ADDR
58501: LD_EXP 99
58505: PUSH
58506: FOR_TO
58507: IFFALSE 58654
// begin if sci in mc_bases [ i ] then
58509: LD_VAR 0 2
58513: PUSH
58514: LD_EXP 99
58518: PUSH
58519: LD_VAR 0 4
58523: ARRAY
58524: IN
58525: IFFALSE 58652
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
58527: LD_ADDR_EXP 128
58531: PUSH
58532: LD_EXP 128
58536: PPUSH
58537: LD_VAR 0 4
58541: PUSH
58542: LD_EXP 128
58546: PUSH
58547: LD_VAR 0 4
58551: ARRAY
58552: PUSH
58553: LD_INT 1
58555: PLUS
58556: PUSH
58557: EMPTY
58558: LIST
58559: LIST
58560: PPUSH
58561: LD_VAR 0 1
58565: PPUSH
58566: CALL 69649 0 3
58570: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
58571: LD_ADDR_VAR 0 5
58575: PUSH
58576: LD_EXP 99
58580: PUSH
58581: LD_VAR 0 4
58585: ARRAY
58586: PPUSH
58587: LD_INT 2
58589: PUSH
58590: LD_INT 30
58592: PUSH
58593: LD_INT 0
58595: PUSH
58596: EMPTY
58597: LIST
58598: LIST
58599: PUSH
58600: LD_INT 30
58602: PUSH
58603: LD_INT 1
58605: PUSH
58606: EMPTY
58607: LIST
58608: LIST
58609: PUSH
58610: EMPTY
58611: LIST
58612: LIST
58613: LIST
58614: PPUSH
58615: CALL_OW 72
58619: PPUSH
58620: LD_VAR 0 1
58624: PPUSH
58625: CALL_OW 74
58629: ST_TO_ADDR
// if tmp then
58630: LD_VAR 0 5
58634: IFFALSE 58650
// ComStandNearbyBuilding ( ape , tmp ) ;
58636: LD_VAR 0 1
58640: PPUSH
58641: LD_VAR 0 5
58645: PPUSH
58646: CALL 64356 0 2
// break ;
58650: GO 58654
// end ; end ;
58652: GO 58506
58654: POP
58655: POP
// end ;
58656: LD_VAR 0 3
58660: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
58661: LD_INT 0
58663: PPUSH
58664: PPUSH
58665: PPUSH
// if not mc_bases or not skirmish then
58666: LD_EXP 99
58670: NOT
58671: PUSH
58672: LD_EXP 97
58676: NOT
58677: OR
58678: IFFALSE 58682
// exit ;
58680: GO 58771
// for i = 1 to mc_bases do
58682: LD_ADDR_VAR 0 4
58686: PUSH
58687: DOUBLE
58688: LD_INT 1
58690: DEC
58691: ST_TO_ADDR
58692: LD_EXP 99
58696: PUSH
58697: FOR_TO
58698: IFFALSE 58769
// begin if building in mc_busy_turret_list [ i ] then
58700: LD_VAR 0 1
58704: PUSH
58705: LD_EXP 109
58709: PUSH
58710: LD_VAR 0 4
58714: ARRAY
58715: IN
58716: IFFALSE 58767
// begin tmp := mc_busy_turret_list [ i ] diff building ;
58718: LD_ADDR_VAR 0 5
58722: PUSH
58723: LD_EXP 109
58727: PUSH
58728: LD_VAR 0 4
58732: ARRAY
58733: PUSH
58734: LD_VAR 0 1
58738: DIFF
58739: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
58740: LD_ADDR_EXP 109
58744: PUSH
58745: LD_EXP 109
58749: PPUSH
58750: LD_VAR 0 4
58754: PPUSH
58755: LD_VAR 0 5
58759: PPUSH
58760: CALL_OW 1
58764: ST_TO_ADDR
// break ;
58765: GO 58769
// end ; end ;
58767: GO 58697
58769: POP
58770: POP
// end ;
58771: LD_VAR 0 3
58775: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
58776: LD_INT 0
58778: PPUSH
58779: PPUSH
58780: PPUSH
// if not mc_bases or not skirmish then
58781: LD_EXP 99
58785: NOT
58786: PUSH
58787: LD_EXP 97
58791: NOT
58792: OR
58793: IFFALSE 58797
// exit ;
58795: GO 58996
// for i = 1 to mc_bases do
58797: LD_ADDR_VAR 0 5
58801: PUSH
58802: DOUBLE
58803: LD_INT 1
58805: DEC
58806: ST_TO_ADDR
58807: LD_EXP 99
58811: PUSH
58812: FOR_TO
58813: IFFALSE 58994
// if building in mc_bases [ i ] then
58815: LD_VAR 0 1
58819: PUSH
58820: LD_EXP 99
58824: PUSH
58825: LD_VAR 0 5
58829: ARRAY
58830: IN
58831: IFFALSE 58992
// begin tmp := mc_bases [ i ] diff building ;
58833: LD_ADDR_VAR 0 6
58837: PUSH
58838: LD_EXP 99
58842: PUSH
58843: LD_VAR 0 5
58847: ARRAY
58848: PUSH
58849: LD_VAR 0 1
58853: DIFF
58854: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
58855: LD_ADDR_EXP 99
58859: PUSH
58860: LD_EXP 99
58864: PPUSH
58865: LD_VAR 0 5
58869: PPUSH
58870: LD_VAR 0 6
58874: PPUSH
58875: CALL_OW 1
58879: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
58880: LD_VAR 0 1
58884: PUSH
58885: LD_EXP 107
58889: PUSH
58890: LD_VAR 0 5
58894: ARRAY
58895: IN
58896: IFFALSE 58935
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
58898: LD_ADDR_EXP 107
58902: PUSH
58903: LD_EXP 107
58907: PPUSH
58908: LD_VAR 0 5
58912: PPUSH
58913: LD_EXP 107
58917: PUSH
58918: LD_VAR 0 5
58922: ARRAY
58923: PUSH
58924: LD_VAR 0 1
58928: DIFF
58929: PPUSH
58930: CALL_OW 1
58934: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
58935: LD_VAR 0 1
58939: PUSH
58940: LD_EXP 108
58944: PUSH
58945: LD_VAR 0 5
58949: ARRAY
58950: IN
58951: IFFALSE 58990
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
58953: LD_ADDR_EXP 108
58957: PUSH
58958: LD_EXP 108
58962: PPUSH
58963: LD_VAR 0 5
58967: PPUSH
58968: LD_EXP 108
58972: PUSH
58973: LD_VAR 0 5
58977: ARRAY
58978: PUSH
58979: LD_VAR 0 1
58983: DIFF
58984: PPUSH
58985: CALL_OW 1
58989: ST_TO_ADDR
// break ;
58990: GO 58994
// end ;
58992: GO 58812
58994: POP
58995: POP
// end ;
58996: LD_VAR 0 4
59000: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
59001: LD_INT 0
59003: PPUSH
59004: PPUSH
59005: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
59006: LD_EXP 99
59010: NOT
59011: PUSH
59012: LD_EXP 97
59016: NOT
59017: OR
59018: PUSH
59019: LD_VAR 0 3
59023: PUSH
59024: LD_EXP 125
59028: IN
59029: NOT
59030: OR
59031: IFFALSE 59035
// exit ;
59033: GO 59158
// for i = 1 to mc_vehicles do
59035: LD_ADDR_VAR 0 6
59039: PUSH
59040: DOUBLE
59041: LD_INT 1
59043: DEC
59044: ST_TO_ADDR
59045: LD_EXP 118
59049: PUSH
59050: FOR_TO
59051: IFFALSE 59156
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59053: LD_VAR 0 2
59057: PUSH
59058: LD_EXP 118
59062: PUSH
59063: LD_VAR 0 6
59067: ARRAY
59068: IN
59069: PUSH
59070: LD_VAR 0 1
59074: PUSH
59075: LD_EXP 118
59079: PUSH
59080: LD_VAR 0 6
59084: ARRAY
59085: IN
59086: OR
59087: IFFALSE 59154
// begin tmp := mc_vehicles [ i ] diff old ;
59089: LD_ADDR_VAR 0 7
59093: PUSH
59094: LD_EXP 118
59098: PUSH
59099: LD_VAR 0 6
59103: ARRAY
59104: PUSH
59105: LD_VAR 0 2
59109: DIFF
59110: ST_TO_ADDR
// tmp := tmp diff new ;
59111: LD_ADDR_VAR 0 7
59115: PUSH
59116: LD_VAR 0 7
59120: PUSH
59121: LD_VAR 0 1
59125: DIFF
59126: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59127: LD_ADDR_EXP 118
59131: PUSH
59132: LD_EXP 118
59136: PPUSH
59137: LD_VAR 0 6
59141: PPUSH
59142: LD_VAR 0 7
59146: PPUSH
59147: CALL_OW 1
59151: ST_TO_ADDR
// break ;
59152: GO 59156
// end ;
59154: GO 59050
59156: POP
59157: POP
// end ;
59158: LD_VAR 0 5
59162: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
59163: LD_INT 0
59165: PPUSH
59166: PPUSH
59167: PPUSH
59168: PPUSH
// if not mc_bases or not skirmish then
59169: LD_EXP 99
59173: NOT
59174: PUSH
59175: LD_EXP 97
59179: NOT
59180: OR
59181: IFFALSE 59185
// exit ;
59183: GO 59562
// side := GetSide ( vehicle ) ;
59185: LD_ADDR_VAR 0 5
59189: PUSH
59190: LD_VAR 0 1
59194: PPUSH
59195: CALL_OW 255
59199: ST_TO_ADDR
// for i = 1 to mc_bases do
59200: LD_ADDR_VAR 0 4
59204: PUSH
59205: DOUBLE
59206: LD_INT 1
59208: DEC
59209: ST_TO_ADDR
59210: LD_EXP 99
59214: PUSH
59215: FOR_TO
59216: IFFALSE 59560
// begin if factory in mc_bases [ i ] then
59218: LD_VAR 0 2
59222: PUSH
59223: LD_EXP 99
59227: PUSH
59228: LD_VAR 0 4
59232: ARRAY
59233: IN
59234: IFFALSE 59558
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
59236: LD_EXP 121
59240: PUSH
59241: LD_VAR 0 4
59245: ARRAY
59246: PUSH
59247: LD_EXP 110
59251: PUSH
59252: LD_VAR 0 4
59256: ARRAY
59257: LESS
59258: PUSH
59259: LD_VAR 0 1
59263: PPUSH
59264: CALL_OW 264
59268: PUSH
59269: LD_INT 31
59271: PUSH
59272: LD_INT 32
59274: PUSH
59275: LD_INT 51
59277: PUSH
59278: LD_EXP 93
59282: PUSH
59283: LD_INT 12
59285: PUSH
59286: LD_INT 30
59288: PUSH
59289: LD_EXP 92
59293: PUSH
59294: LD_INT 11
59296: PUSH
59297: LD_INT 53
59299: PUSH
59300: LD_INT 14
59302: PUSH
59303: LD_EXP 96
59307: PUSH
59308: LD_INT 29
59310: PUSH
59311: LD_EXP 94
59315: PUSH
59316: LD_INT 13
59318: PUSH
59319: LD_INT 52
59321: PUSH
59322: LD_INT 48
59324: PUSH
59325: LD_INT 8
59327: PUSH
59328: EMPTY
59329: LIST
59330: LIST
59331: LIST
59332: LIST
59333: LIST
59334: LIST
59335: LIST
59336: LIST
59337: LIST
59338: LIST
59339: LIST
59340: LIST
59341: LIST
59342: LIST
59343: LIST
59344: LIST
59345: LIST
59346: IN
59347: NOT
59348: AND
59349: IFFALSE 59397
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
59351: LD_ADDR_EXP 121
59355: PUSH
59356: LD_EXP 121
59360: PPUSH
59361: LD_VAR 0 4
59365: PUSH
59366: LD_EXP 121
59370: PUSH
59371: LD_VAR 0 4
59375: ARRAY
59376: PUSH
59377: LD_INT 1
59379: PLUS
59380: PUSH
59381: EMPTY
59382: LIST
59383: LIST
59384: PPUSH
59385: LD_VAR 0 1
59389: PPUSH
59390: CALL 69649 0 3
59394: ST_TO_ADDR
59395: GO 59441
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
59397: LD_ADDR_EXP 118
59401: PUSH
59402: LD_EXP 118
59406: PPUSH
59407: LD_VAR 0 4
59411: PUSH
59412: LD_EXP 118
59416: PUSH
59417: LD_VAR 0 4
59421: ARRAY
59422: PUSH
59423: LD_INT 1
59425: PLUS
59426: PUSH
59427: EMPTY
59428: LIST
59429: LIST
59430: PPUSH
59431: LD_VAR 0 1
59435: PPUSH
59436: CALL 69649 0 3
59440: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
59441: LD_VAR 0 1
59445: PPUSH
59446: CALL_OW 263
59450: PUSH
59451: LD_INT 2
59453: EQUAL
59454: IFFALSE 59474
// begin repeat wait ( 0 0$1 ) ;
59456: LD_INT 35
59458: PPUSH
59459: CALL_OW 67
// until IsControledBy ( vehicle ) ;
59463: LD_VAR 0 1
59467: PPUSH
59468: CALL_OW 312
59472: IFFALSE 59456
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
59474: LD_VAR 0 1
59478: PPUSH
59479: LD_EXP 123
59483: PUSH
59484: LD_VAR 0 4
59488: ARRAY
59489: PPUSH
59490: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
59494: LD_VAR 0 1
59498: PPUSH
59499: CALL_OW 263
59503: PUSH
59504: LD_INT 1
59506: NONEQUAL
59507: IFFALSE 59511
// break ;
59509: GO 59560
// repeat wait ( 0 0$1 ) ;
59511: LD_INT 35
59513: PPUSH
59514: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
59518: LD_VAR 0 1
59522: PPUSH
59523: LD_EXP 123
59527: PUSH
59528: LD_VAR 0 4
59532: ARRAY
59533: PPUSH
59534: CALL_OW 308
59538: IFFALSE 59511
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
59540: LD_VAR 0 1
59544: PPUSH
59545: CALL_OW 311
59549: PPUSH
59550: CALL_OW 121
// exit ;
59554: POP
59555: POP
59556: GO 59562
// end ; end ;
59558: GO 59215
59560: POP
59561: POP
// end ;
59562: LD_VAR 0 3
59566: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
59567: LD_INT 0
59569: PPUSH
59570: PPUSH
59571: PPUSH
59572: PPUSH
// if not mc_bases or not skirmish then
59573: LD_EXP 99
59577: NOT
59578: PUSH
59579: LD_EXP 97
59583: NOT
59584: OR
59585: IFFALSE 59589
// exit ;
59587: GO 59942
// repeat wait ( 0 0$1 ) ;
59589: LD_INT 35
59591: PPUSH
59592: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
59596: LD_VAR 0 2
59600: PPUSH
59601: LD_VAR 0 3
59605: PPUSH
59606: CALL_OW 284
59610: IFFALSE 59589
// if GetResourceTypeXY ( x , y ) = mat_artefact then
59612: LD_VAR 0 2
59616: PPUSH
59617: LD_VAR 0 3
59621: PPUSH
59622: CALL_OW 283
59626: PUSH
59627: LD_INT 4
59629: EQUAL
59630: IFFALSE 59634
// exit ;
59632: GO 59942
// for i = 1 to mc_bases do
59634: LD_ADDR_VAR 0 7
59638: PUSH
59639: DOUBLE
59640: LD_INT 1
59642: DEC
59643: ST_TO_ADDR
59644: LD_EXP 99
59648: PUSH
59649: FOR_TO
59650: IFFALSE 59940
// begin if mc_crates_area [ i ] then
59652: LD_EXP 117
59656: PUSH
59657: LD_VAR 0 7
59661: ARRAY
59662: IFFALSE 59773
// for j in mc_crates_area [ i ] do
59664: LD_ADDR_VAR 0 8
59668: PUSH
59669: LD_EXP 117
59673: PUSH
59674: LD_VAR 0 7
59678: ARRAY
59679: PUSH
59680: FOR_IN
59681: IFFALSE 59771
// if InArea ( x , y , j ) then
59683: LD_VAR 0 2
59687: PPUSH
59688: LD_VAR 0 3
59692: PPUSH
59693: LD_VAR 0 8
59697: PPUSH
59698: CALL_OW 309
59702: IFFALSE 59769
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
59704: LD_ADDR_EXP 115
59708: PUSH
59709: LD_EXP 115
59713: PPUSH
59714: LD_VAR 0 7
59718: PUSH
59719: LD_EXP 115
59723: PUSH
59724: LD_VAR 0 7
59728: ARRAY
59729: PUSH
59730: LD_INT 1
59732: PLUS
59733: PUSH
59734: EMPTY
59735: LIST
59736: LIST
59737: PPUSH
59738: LD_VAR 0 4
59742: PUSH
59743: LD_VAR 0 2
59747: PUSH
59748: LD_VAR 0 3
59752: PUSH
59753: EMPTY
59754: LIST
59755: LIST
59756: LIST
59757: PPUSH
59758: CALL 69649 0 3
59762: ST_TO_ADDR
// exit ;
59763: POP
59764: POP
59765: POP
59766: POP
59767: GO 59942
// end ;
59769: GO 59680
59771: POP
59772: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59773: LD_ADDR_VAR 0 9
59777: PUSH
59778: LD_EXP 99
59782: PUSH
59783: LD_VAR 0 7
59787: ARRAY
59788: PPUSH
59789: LD_INT 2
59791: PUSH
59792: LD_INT 30
59794: PUSH
59795: LD_INT 0
59797: PUSH
59798: EMPTY
59799: LIST
59800: LIST
59801: PUSH
59802: LD_INT 30
59804: PUSH
59805: LD_INT 1
59807: PUSH
59808: EMPTY
59809: LIST
59810: LIST
59811: PUSH
59812: EMPTY
59813: LIST
59814: LIST
59815: LIST
59816: PPUSH
59817: CALL_OW 72
59821: ST_TO_ADDR
// if not depot then
59822: LD_VAR 0 9
59826: NOT
59827: IFFALSE 59831
// continue ;
59829: GO 59649
// for j in depot do
59831: LD_ADDR_VAR 0 8
59835: PUSH
59836: LD_VAR 0 9
59840: PUSH
59841: FOR_IN
59842: IFFALSE 59936
// if GetDistUnitXY ( j , x , y ) < 30 then
59844: LD_VAR 0 8
59848: PPUSH
59849: LD_VAR 0 2
59853: PPUSH
59854: LD_VAR 0 3
59858: PPUSH
59859: CALL_OW 297
59863: PUSH
59864: LD_INT 30
59866: LESS
59867: IFFALSE 59934
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
59869: LD_ADDR_EXP 115
59873: PUSH
59874: LD_EXP 115
59878: PPUSH
59879: LD_VAR 0 7
59883: PUSH
59884: LD_EXP 115
59888: PUSH
59889: LD_VAR 0 7
59893: ARRAY
59894: PUSH
59895: LD_INT 1
59897: PLUS
59898: PUSH
59899: EMPTY
59900: LIST
59901: LIST
59902: PPUSH
59903: LD_VAR 0 4
59907: PUSH
59908: LD_VAR 0 2
59912: PUSH
59913: LD_VAR 0 3
59917: PUSH
59918: EMPTY
59919: LIST
59920: LIST
59921: LIST
59922: PPUSH
59923: CALL 69649 0 3
59927: ST_TO_ADDR
// exit ;
59928: POP
59929: POP
59930: POP
59931: POP
59932: GO 59942
// end ;
59934: GO 59841
59936: POP
59937: POP
// end ;
59938: GO 59649
59940: POP
59941: POP
// end ;
59942: LD_VAR 0 6
59946: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
59947: LD_INT 0
59949: PPUSH
59950: PPUSH
59951: PPUSH
59952: PPUSH
// if not mc_bases or not skirmish then
59953: LD_EXP 99
59957: NOT
59958: PUSH
59959: LD_EXP 97
59963: NOT
59964: OR
59965: IFFALSE 59969
// exit ;
59967: GO 60246
// side := GetSide ( lab ) ;
59969: LD_ADDR_VAR 0 4
59973: PUSH
59974: LD_VAR 0 2
59978: PPUSH
59979: CALL_OW 255
59983: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
59984: LD_VAR 0 4
59988: PUSH
59989: LD_EXP 125
59993: IN
59994: NOT
59995: PUSH
59996: LD_EXP 126
60000: NOT
60001: OR
60002: PUSH
60003: LD_EXP 99
60007: NOT
60008: OR
60009: IFFALSE 60013
// exit ;
60011: GO 60246
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60013: LD_ADDR_EXP 126
60017: PUSH
60018: LD_EXP 126
60022: PPUSH
60023: LD_VAR 0 4
60027: PPUSH
60028: LD_EXP 126
60032: PUSH
60033: LD_VAR 0 4
60037: ARRAY
60038: PUSH
60039: LD_VAR 0 1
60043: DIFF
60044: PPUSH
60045: CALL_OW 1
60049: ST_TO_ADDR
// for i = 1 to mc_bases do
60050: LD_ADDR_VAR 0 5
60054: PUSH
60055: DOUBLE
60056: LD_INT 1
60058: DEC
60059: ST_TO_ADDR
60060: LD_EXP 99
60064: PUSH
60065: FOR_TO
60066: IFFALSE 60244
// begin if lab in mc_bases [ i ] then
60068: LD_VAR 0 2
60072: PUSH
60073: LD_EXP 99
60077: PUSH
60078: LD_VAR 0 5
60082: ARRAY
60083: IN
60084: IFFALSE 60242
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60086: LD_VAR 0 1
60090: PUSH
60091: LD_INT 11
60093: PUSH
60094: LD_INT 4
60096: PUSH
60097: LD_INT 3
60099: PUSH
60100: LD_INT 2
60102: PUSH
60103: EMPTY
60104: LIST
60105: LIST
60106: LIST
60107: LIST
60108: IN
60109: PUSH
60110: LD_EXP 129
60114: PUSH
60115: LD_VAR 0 5
60119: ARRAY
60120: AND
60121: IFFALSE 60242
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60123: LD_ADDR_VAR 0 6
60127: PUSH
60128: LD_EXP 129
60132: PUSH
60133: LD_VAR 0 5
60137: ARRAY
60138: PUSH
60139: LD_INT 1
60141: ARRAY
60142: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60143: LD_ADDR_EXP 129
60147: PUSH
60148: LD_EXP 129
60152: PPUSH
60153: LD_VAR 0 5
60157: PPUSH
60158: EMPTY
60159: PPUSH
60160: CALL_OW 1
60164: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
60165: LD_VAR 0 6
60169: PPUSH
60170: LD_INT 0
60172: PPUSH
60173: CALL_OW 109
// ComExitBuilding ( tmp ) ;
60177: LD_VAR 0 6
60181: PPUSH
60182: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
60186: LD_ADDR_EXP 128
60190: PUSH
60191: LD_EXP 128
60195: PPUSH
60196: LD_VAR 0 5
60200: PPUSH
60201: LD_EXP 128
60205: PUSH
60206: LD_VAR 0 5
60210: ARRAY
60211: PPUSH
60212: LD_INT 1
60214: PPUSH
60215: LD_VAR 0 6
60219: PPUSH
60220: CALL_OW 2
60224: PPUSH
60225: CALL_OW 1
60229: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
60230: LD_VAR 0 5
60234: PPUSH
60235: LD_INT 112
60237: PPUSH
60238: CALL 37779 0 2
// end ; end ; end ;
60242: GO 60065
60244: POP
60245: POP
// end ;
60246: LD_VAR 0 3
60250: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
60251: LD_INT 0
60253: PPUSH
60254: PPUSH
60255: PPUSH
60256: PPUSH
60257: PPUSH
60258: PPUSH
60259: PPUSH
60260: PPUSH
// if not mc_bases or not skirmish then
60261: LD_EXP 99
60265: NOT
60266: PUSH
60267: LD_EXP 97
60271: NOT
60272: OR
60273: IFFALSE 60277
// exit ;
60275: GO 61369
// for i = 1 to mc_bases do
60277: LD_ADDR_VAR 0 3
60281: PUSH
60282: DOUBLE
60283: LD_INT 1
60285: DEC
60286: ST_TO_ADDR
60287: LD_EXP 99
60291: PUSH
60292: FOR_TO
60293: IFFALSE 61367
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
60295: LD_VAR 0 1
60299: PUSH
60300: LD_EXP 99
60304: PUSH
60305: LD_VAR 0 3
60309: ARRAY
60310: IN
60311: PUSH
60312: LD_VAR 0 1
60316: PUSH
60317: LD_EXP 106
60321: PUSH
60322: LD_VAR 0 3
60326: ARRAY
60327: IN
60328: OR
60329: PUSH
60330: LD_VAR 0 1
60334: PUSH
60335: LD_EXP 121
60339: PUSH
60340: LD_VAR 0 3
60344: ARRAY
60345: IN
60346: OR
60347: PUSH
60348: LD_VAR 0 1
60352: PUSH
60353: LD_EXP 118
60357: PUSH
60358: LD_VAR 0 3
60362: ARRAY
60363: IN
60364: OR
60365: PUSH
60366: LD_VAR 0 1
60370: PUSH
60371: LD_EXP 128
60375: PUSH
60376: LD_VAR 0 3
60380: ARRAY
60381: IN
60382: OR
60383: PUSH
60384: LD_VAR 0 1
60388: PUSH
60389: LD_EXP 129
60393: PUSH
60394: LD_VAR 0 3
60398: ARRAY
60399: IN
60400: OR
60401: IFFALSE 61365
// begin if un in mc_ape [ i ] then
60403: LD_VAR 0 1
60407: PUSH
60408: LD_EXP 128
60412: PUSH
60413: LD_VAR 0 3
60417: ARRAY
60418: IN
60419: IFFALSE 60458
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
60421: LD_ADDR_EXP 128
60425: PUSH
60426: LD_EXP 128
60430: PPUSH
60431: LD_VAR 0 3
60435: PPUSH
60436: LD_EXP 128
60440: PUSH
60441: LD_VAR 0 3
60445: ARRAY
60446: PUSH
60447: LD_VAR 0 1
60451: DIFF
60452: PPUSH
60453: CALL_OW 1
60457: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
60458: LD_VAR 0 1
60462: PUSH
60463: LD_EXP 129
60467: PUSH
60468: LD_VAR 0 3
60472: ARRAY
60473: IN
60474: IFFALSE 60498
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60476: LD_ADDR_EXP 129
60480: PUSH
60481: LD_EXP 129
60485: PPUSH
60486: LD_VAR 0 3
60490: PPUSH
60491: EMPTY
60492: PPUSH
60493: CALL_OW 1
60497: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] ) then
60498: LD_VAR 0 1
60502: PPUSH
60503: CALL_OW 247
60507: PUSH
60508: LD_INT 2
60510: EQUAL
60511: PUSH
60512: LD_VAR 0 1
60516: PPUSH
60517: CALL_OW 110
60521: PUSH
60522: LD_INT 20
60524: EQUAL
60525: PUSH
60526: LD_VAR 0 1
60530: PUSH
60531: LD_EXP 121
60535: PUSH
60536: LD_VAR 0 3
60540: ARRAY
60541: IN
60542: OR
60543: AND
60544: IFFALSE 60705
// begin if un in mc_defender [ i ] then
60546: LD_VAR 0 1
60550: PUSH
60551: LD_EXP 121
60555: PUSH
60556: LD_VAR 0 3
60560: ARRAY
60561: IN
60562: IFFALSE 60601
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
60564: LD_ADDR_EXP 121
60568: PUSH
60569: LD_EXP 121
60573: PPUSH
60574: LD_VAR 0 3
60578: PPUSH
60579: LD_EXP 121
60583: PUSH
60584: LD_VAR 0 3
60588: ARRAY
60589: PUSH
60590: LD_VAR 0 1
60594: DIFF
60595: PPUSH
60596: CALL_OW 1
60600: ST_TO_ADDR
// fac := MC_GetBuilding ( i , b_factory ) ;
60601: LD_ADDR_VAR 0 8
60605: PUSH
60606: LD_VAR 0 3
60610: PPUSH
60611: LD_INT 3
60613: PPUSH
60614: CALL 57294 0 2
60618: ST_TO_ADDR
// if fac then
60619: LD_VAR 0 8
60623: IFFALSE 60705
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
60625: LD_ADDR_VAR 0 9
60629: PUSH
60630: LD_VAR 0 8
60634: PPUSH
60635: LD_VAR 0 1
60639: PPUSH
60640: CALL_OW 265
60644: PPUSH
60645: LD_VAR 0 1
60649: PPUSH
60650: CALL_OW 262
60654: PPUSH
60655: LD_VAR 0 1
60659: PPUSH
60660: CALL_OW 263
60664: PPUSH
60665: LD_VAR 0 1
60669: PPUSH
60670: CALL_OW 264
60674: PPUSH
60675: CALL 67242 0 5
60679: ST_TO_ADDR
// if components then
60680: LD_VAR 0 9
60684: IFFALSE 60703
// MC_InsertProduceList ( i , [ components ] ) ;
60686: LD_VAR 0 3
60690: PPUSH
60691: LD_VAR 0 9
60695: PUSH
60696: EMPTY
60697: LIST
60698: PPUSH
60699: CALL 56922 0 2
// break ;
60703: GO 61367
// end ; end ; if GetType ( un ) = unit_building then
60705: LD_VAR 0 1
60709: PPUSH
60710: CALL_OW 247
60714: PUSH
60715: LD_INT 3
60717: EQUAL
60718: IFFALSE 61033
// begin btype := GetBType ( un ) ;
60720: LD_ADDR_VAR 0 5
60724: PUSH
60725: LD_VAR 0 1
60729: PPUSH
60730: CALL_OW 266
60734: ST_TO_ADDR
// if btype = b_warehouse then
60735: LD_VAR 0 5
60739: PUSH
60740: LD_INT 1
60742: EQUAL
60743: IFFALSE 60761
// begin btype := b_depot ;
60745: LD_ADDR_VAR 0 5
60749: PUSH
60750: LD_INT 0
60752: ST_TO_ADDR
// pos := 1 ;
60753: LD_ADDR_VAR 0 6
60757: PUSH
60758: LD_INT 1
60760: ST_TO_ADDR
// end ; if btype = b_factory then
60761: LD_VAR 0 5
60765: PUSH
60766: LD_INT 3
60768: EQUAL
60769: IFFALSE 60787
// begin btype := b_workshop ;
60771: LD_ADDR_VAR 0 5
60775: PUSH
60776: LD_INT 2
60778: ST_TO_ADDR
// pos := 1 ;
60779: LD_ADDR_VAR 0 6
60783: PUSH
60784: LD_INT 1
60786: ST_TO_ADDR
// end ; if btype = b_barracks then
60787: LD_VAR 0 5
60791: PUSH
60792: LD_INT 5
60794: EQUAL
60795: IFFALSE 60805
// btype := b_armoury ;
60797: LD_ADDR_VAR 0 5
60801: PUSH
60802: LD_INT 4
60804: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
60805: LD_VAR 0 5
60809: PUSH
60810: LD_INT 7
60812: PUSH
60813: LD_INT 8
60815: PUSH
60816: EMPTY
60817: LIST
60818: LIST
60819: IN
60820: IFFALSE 60830
// btype := b_lab ;
60822: LD_ADDR_VAR 0 5
60826: PUSH
60827: LD_INT 6
60829: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
60830: LD_ADDR_EXP 104
60834: PUSH
60835: LD_EXP 104
60839: PPUSH
60840: LD_VAR 0 3
60844: PUSH
60845: LD_EXP 104
60849: PUSH
60850: LD_VAR 0 3
60854: ARRAY
60855: PUSH
60856: LD_INT 1
60858: PLUS
60859: PUSH
60860: EMPTY
60861: LIST
60862: LIST
60863: PPUSH
60864: LD_VAR 0 5
60868: PUSH
60869: LD_VAR 0 1
60873: PPUSH
60874: CALL_OW 250
60878: PUSH
60879: LD_VAR 0 1
60883: PPUSH
60884: CALL_OW 251
60888: PUSH
60889: LD_VAR 0 1
60893: PPUSH
60894: CALL_OW 254
60898: PUSH
60899: EMPTY
60900: LIST
60901: LIST
60902: LIST
60903: LIST
60904: PPUSH
60905: CALL 69649 0 3
60909: ST_TO_ADDR
// if pos = 1 then
60910: LD_VAR 0 6
60914: PUSH
60915: LD_INT 1
60917: EQUAL
60918: IFFALSE 61033
// begin tmp := mc_build_list [ i ] ;
60920: LD_ADDR_VAR 0 7
60924: PUSH
60925: LD_EXP 104
60929: PUSH
60930: LD_VAR 0 3
60934: ARRAY
60935: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60936: LD_VAR 0 7
60940: PPUSH
60941: LD_INT 2
60943: PUSH
60944: LD_INT 30
60946: PUSH
60947: LD_INT 0
60949: PUSH
60950: EMPTY
60951: LIST
60952: LIST
60953: PUSH
60954: LD_INT 30
60956: PUSH
60957: LD_INT 1
60959: PUSH
60960: EMPTY
60961: LIST
60962: LIST
60963: PUSH
60964: EMPTY
60965: LIST
60966: LIST
60967: LIST
60968: PPUSH
60969: CALL_OW 72
60973: IFFALSE 60983
// pos := 2 ;
60975: LD_ADDR_VAR 0 6
60979: PUSH
60980: LD_INT 2
60982: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
60983: LD_ADDR_VAR 0 7
60987: PUSH
60988: LD_VAR 0 7
60992: PPUSH
60993: LD_VAR 0 6
60997: PPUSH
60998: LD_VAR 0 7
61002: PPUSH
61003: CALL 69975 0 3
61007: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
61008: LD_ADDR_EXP 104
61012: PUSH
61013: LD_EXP 104
61017: PPUSH
61018: LD_VAR 0 3
61022: PPUSH
61023: LD_VAR 0 7
61027: PPUSH
61028: CALL_OW 1
61032: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
61033: LD_VAR 0 1
61037: PUSH
61038: LD_EXP 99
61042: PUSH
61043: LD_VAR 0 3
61047: ARRAY
61048: IN
61049: IFFALSE 61088
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
61051: LD_ADDR_EXP 99
61055: PUSH
61056: LD_EXP 99
61060: PPUSH
61061: LD_VAR 0 3
61065: PPUSH
61066: LD_EXP 99
61070: PUSH
61071: LD_VAR 0 3
61075: ARRAY
61076: PUSH
61077: LD_VAR 0 1
61081: DIFF
61082: PPUSH
61083: CALL_OW 1
61087: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
61088: LD_VAR 0 1
61092: PUSH
61093: LD_EXP 106
61097: PUSH
61098: LD_VAR 0 3
61102: ARRAY
61103: IN
61104: IFFALSE 61143
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
61106: LD_ADDR_EXP 106
61110: PUSH
61111: LD_EXP 106
61115: PPUSH
61116: LD_VAR 0 3
61120: PPUSH
61121: LD_EXP 106
61125: PUSH
61126: LD_VAR 0 3
61130: ARRAY
61131: PUSH
61132: LD_VAR 0 1
61136: DIFF
61137: PPUSH
61138: CALL_OW 1
61142: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
61143: LD_VAR 0 1
61147: PUSH
61148: LD_EXP 118
61152: PUSH
61153: LD_VAR 0 3
61157: ARRAY
61158: IN
61159: IFFALSE 61198
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
61161: LD_ADDR_EXP 118
61165: PUSH
61166: LD_EXP 118
61170: PPUSH
61171: LD_VAR 0 3
61175: PPUSH
61176: LD_EXP 118
61180: PUSH
61181: LD_VAR 0 3
61185: ARRAY
61186: PUSH
61187: LD_VAR 0 1
61191: DIFF
61192: PPUSH
61193: CALL_OW 1
61197: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
61198: LD_VAR 0 1
61202: PUSH
61203: LD_EXP 121
61207: PUSH
61208: LD_VAR 0 3
61212: ARRAY
61213: IN
61214: IFFALSE 61253
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61216: LD_ADDR_EXP 121
61220: PUSH
61221: LD_EXP 121
61225: PPUSH
61226: LD_VAR 0 3
61230: PPUSH
61231: LD_EXP 121
61235: PUSH
61236: LD_VAR 0 3
61240: ARRAY
61241: PUSH
61242: LD_VAR 0 1
61246: DIFF
61247: PPUSH
61248: CALL_OW 1
61252: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
61253: LD_VAR 0 1
61257: PUSH
61258: LD_EXP 108
61262: PUSH
61263: LD_VAR 0 3
61267: ARRAY
61268: IN
61269: IFFALSE 61308
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
61271: LD_ADDR_EXP 108
61275: PUSH
61276: LD_EXP 108
61280: PPUSH
61281: LD_VAR 0 3
61285: PPUSH
61286: LD_EXP 108
61290: PUSH
61291: LD_VAR 0 3
61295: ARRAY
61296: PUSH
61297: LD_VAR 0 1
61301: DIFF
61302: PPUSH
61303: CALL_OW 1
61307: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
61308: LD_VAR 0 1
61312: PUSH
61313: LD_EXP 107
61317: PUSH
61318: LD_VAR 0 3
61322: ARRAY
61323: IN
61324: IFFALSE 61363
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
61326: LD_ADDR_EXP 107
61330: PUSH
61331: LD_EXP 107
61335: PPUSH
61336: LD_VAR 0 3
61340: PPUSH
61341: LD_EXP 107
61345: PUSH
61346: LD_VAR 0 3
61350: ARRAY
61351: PUSH
61352: LD_VAR 0 1
61356: DIFF
61357: PPUSH
61358: CALL_OW 1
61362: ST_TO_ADDR
// end ; break ;
61363: GO 61367
// end ;
61365: GO 60292
61367: POP
61368: POP
// end ;
61369: LD_VAR 0 2
61373: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
61374: LD_INT 0
61376: PPUSH
61377: PPUSH
61378: PPUSH
// if not mc_bases or not skirmish then
61379: LD_EXP 99
61383: NOT
61384: PUSH
61385: LD_EXP 97
61389: NOT
61390: OR
61391: IFFALSE 61395
// exit ;
61393: GO 61610
// for i = 1 to mc_bases do
61395: LD_ADDR_VAR 0 3
61399: PUSH
61400: DOUBLE
61401: LD_INT 1
61403: DEC
61404: ST_TO_ADDR
61405: LD_EXP 99
61409: PUSH
61410: FOR_TO
61411: IFFALSE 61608
// begin if building in mc_construct_list [ i ] then
61413: LD_VAR 0 1
61417: PUSH
61418: LD_EXP 106
61422: PUSH
61423: LD_VAR 0 3
61427: ARRAY
61428: IN
61429: IFFALSE 61606
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
61431: LD_ADDR_EXP 106
61435: PUSH
61436: LD_EXP 106
61440: PPUSH
61441: LD_VAR 0 3
61445: PPUSH
61446: LD_EXP 106
61450: PUSH
61451: LD_VAR 0 3
61455: ARRAY
61456: PUSH
61457: LD_VAR 0 1
61461: DIFF
61462: PPUSH
61463: CALL_OW 1
61467: ST_TO_ADDR
// if building in mc_lab [ i ] then
61468: LD_VAR 0 1
61472: PUSH
61473: LD_EXP 132
61477: PUSH
61478: LD_VAR 0 3
61482: ARRAY
61483: IN
61484: IFFALSE 61539
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
61486: LD_ADDR_EXP 133
61490: PUSH
61491: LD_EXP 133
61495: PPUSH
61496: LD_VAR 0 3
61500: PPUSH
61501: LD_EXP 133
61505: PUSH
61506: LD_VAR 0 3
61510: ARRAY
61511: PPUSH
61512: LD_INT 1
61514: PPUSH
61515: LD_EXP 133
61519: PUSH
61520: LD_VAR 0 3
61524: ARRAY
61525: PPUSH
61526: LD_INT 0
61528: PPUSH
61529: CALL 69067 0 4
61533: PPUSH
61534: CALL_OW 1
61538: ST_TO_ADDR
// if not building in mc_bases [ i ] then
61539: LD_VAR 0 1
61543: PUSH
61544: LD_EXP 99
61548: PUSH
61549: LD_VAR 0 3
61553: ARRAY
61554: IN
61555: NOT
61556: IFFALSE 61602
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
61558: LD_ADDR_EXP 99
61562: PUSH
61563: LD_EXP 99
61567: PPUSH
61568: LD_VAR 0 3
61572: PUSH
61573: LD_EXP 99
61577: PUSH
61578: LD_VAR 0 3
61582: ARRAY
61583: PUSH
61584: LD_INT 1
61586: PLUS
61587: PUSH
61588: EMPTY
61589: LIST
61590: LIST
61591: PPUSH
61592: LD_VAR 0 1
61596: PPUSH
61597: CALL 69649 0 3
61601: ST_TO_ADDR
// exit ;
61602: POP
61603: POP
61604: GO 61610
// end ; end ;
61606: GO 61410
61608: POP
61609: POP
// end ;
61610: LD_VAR 0 2
61614: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
61615: LD_INT 0
61617: PPUSH
61618: PPUSH
61619: PPUSH
61620: PPUSH
61621: PPUSH
61622: PPUSH
61623: PPUSH
// if not mc_bases or not skirmish then
61624: LD_EXP 99
61628: NOT
61629: PUSH
61630: LD_EXP 97
61634: NOT
61635: OR
61636: IFFALSE 61640
// exit ;
61638: GO 62301
// for i = 1 to mc_bases do
61640: LD_ADDR_VAR 0 3
61644: PUSH
61645: DOUBLE
61646: LD_INT 1
61648: DEC
61649: ST_TO_ADDR
61650: LD_EXP 99
61654: PUSH
61655: FOR_TO
61656: IFFALSE 62299
// begin if building in mc_construct_list [ i ] then
61658: LD_VAR 0 1
61662: PUSH
61663: LD_EXP 106
61667: PUSH
61668: LD_VAR 0 3
61672: ARRAY
61673: IN
61674: IFFALSE 62297
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
61676: LD_ADDR_EXP 106
61680: PUSH
61681: LD_EXP 106
61685: PPUSH
61686: LD_VAR 0 3
61690: PPUSH
61691: LD_EXP 106
61695: PUSH
61696: LD_VAR 0 3
61700: ARRAY
61701: PUSH
61702: LD_VAR 0 1
61706: DIFF
61707: PPUSH
61708: CALL_OW 1
61712: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
61713: LD_ADDR_EXP 99
61717: PUSH
61718: LD_EXP 99
61722: PPUSH
61723: LD_VAR 0 3
61727: PUSH
61728: LD_EXP 99
61732: PUSH
61733: LD_VAR 0 3
61737: ARRAY
61738: PUSH
61739: LD_INT 1
61741: PLUS
61742: PUSH
61743: EMPTY
61744: LIST
61745: LIST
61746: PPUSH
61747: LD_VAR 0 1
61751: PPUSH
61752: CALL 69649 0 3
61756: ST_TO_ADDR
// btype := GetBType ( building ) ;
61757: LD_ADDR_VAR 0 5
61761: PUSH
61762: LD_VAR 0 1
61766: PPUSH
61767: CALL_OW 266
61771: ST_TO_ADDR
// side := GetSide ( building ) ;
61772: LD_ADDR_VAR 0 8
61776: PUSH
61777: LD_VAR 0 1
61781: PPUSH
61782: CALL_OW 255
61786: ST_TO_ADDR
// if btype = b_lab then
61787: LD_VAR 0 5
61791: PUSH
61792: LD_INT 6
61794: EQUAL
61795: IFFALSE 61845
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
61797: LD_ADDR_EXP 132
61801: PUSH
61802: LD_EXP 132
61806: PPUSH
61807: LD_VAR 0 3
61811: PUSH
61812: LD_EXP 132
61816: PUSH
61817: LD_VAR 0 3
61821: ARRAY
61822: PUSH
61823: LD_INT 1
61825: PLUS
61826: PUSH
61827: EMPTY
61828: LIST
61829: LIST
61830: PPUSH
61831: LD_VAR 0 1
61835: PPUSH
61836: CALL 69649 0 3
61840: ST_TO_ADDR
// exit ;
61841: POP
61842: POP
61843: GO 62301
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
61845: LD_VAR 0 5
61849: PUSH
61850: LD_INT 0
61852: PUSH
61853: LD_INT 2
61855: PUSH
61856: LD_INT 4
61858: PUSH
61859: EMPTY
61860: LIST
61861: LIST
61862: LIST
61863: IN
61864: IFFALSE 61988
// begin if btype = b_armoury then
61866: LD_VAR 0 5
61870: PUSH
61871: LD_INT 4
61873: EQUAL
61874: IFFALSE 61884
// btype := b_barracks ;
61876: LD_ADDR_VAR 0 5
61880: PUSH
61881: LD_INT 5
61883: ST_TO_ADDR
// if btype = b_depot then
61884: LD_VAR 0 5
61888: PUSH
61889: LD_INT 0
61891: EQUAL
61892: IFFALSE 61902
// btype := b_warehouse ;
61894: LD_ADDR_VAR 0 5
61898: PUSH
61899: LD_INT 1
61901: ST_TO_ADDR
// if btype = b_workshop then
61902: LD_VAR 0 5
61906: PUSH
61907: LD_INT 2
61909: EQUAL
61910: IFFALSE 61920
// btype := b_factory ;
61912: LD_ADDR_VAR 0 5
61916: PUSH
61917: LD_INT 3
61919: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
61920: LD_VAR 0 5
61924: PPUSH
61925: LD_VAR 0 8
61929: PPUSH
61930: CALL_OW 323
61934: PUSH
61935: LD_INT 1
61937: EQUAL
61938: IFFALSE 61984
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
61940: LD_ADDR_EXP 131
61944: PUSH
61945: LD_EXP 131
61949: PPUSH
61950: LD_VAR 0 3
61954: PUSH
61955: LD_EXP 131
61959: PUSH
61960: LD_VAR 0 3
61964: ARRAY
61965: PUSH
61966: LD_INT 1
61968: PLUS
61969: PUSH
61970: EMPTY
61971: LIST
61972: LIST
61973: PPUSH
61974: LD_VAR 0 1
61978: PPUSH
61979: CALL 69649 0 3
61983: ST_TO_ADDR
// exit ;
61984: POP
61985: POP
61986: GO 62301
// end ; if btype in [ b_bunker , b_turret ] then
61988: LD_VAR 0 5
61992: PUSH
61993: LD_INT 32
61995: PUSH
61996: LD_INT 33
61998: PUSH
61999: EMPTY
62000: LIST
62001: LIST
62002: IN
62003: IFFALSE 62293
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
62005: LD_ADDR_EXP 107
62009: PUSH
62010: LD_EXP 107
62014: PPUSH
62015: LD_VAR 0 3
62019: PUSH
62020: LD_EXP 107
62024: PUSH
62025: LD_VAR 0 3
62029: ARRAY
62030: PUSH
62031: LD_INT 1
62033: PLUS
62034: PUSH
62035: EMPTY
62036: LIST
62037: LIST
62038: PPUSH
62039: LD_VAR 0 1
62043: PPUSH
62044: CALL 69649 0 3
62048: ST_TO_ADDR
// if btype = b_bunker then
62049: LD_VAR 0 5
62053: PUSH
62054: LD_INT 32
62056: EQUAL
62057: IFFALSE 62293
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62059: LD_ADDR_EXP 108
62063: PUSH
62064: LD_EXP 108
62068: PPUSH
62069: LD_VAR 0 3
62073: PUSH
62074: LD_EXP 108
62078: PUSH
62079: LD_VAR 0 3
62083: ARRAY
62084: PUSH
62085: LD_INT 1
62087: PLUS
62088: PUSH
62089: EMPTY
62090: LIST
62091: LIST
62092: PPUSH
62093: LD_VAR 0 1
62097: PPUSH
62098: CALL 69649 0 3
62102: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
62103: LD_ADDR_VAR 0 6
62107: PUSH
62108: LD_EXP 99
62112: PUSH
62113: LD_VAR 0 3
62117: ARRAY
62118: PPUSH
62119: LD_INT 25
62121: PUSH
62122: LD_INT 1
62124: PUSH
62125: EMPTY
62126: LIST
62127: LIST
62128: PUSH
62129: LD_INT 3
62131: PUSH
62132: LD_INT 54
62134: PUSH
62135: EMPTY
62136: LIST
62137: PUSH
62138: EMPTY
62139: LIST
62140: LIST
62141: PUSH
62142: EMPTY
62143: LIST
62144: LIST
62145: PPUSH
62146: CALL_OW 72
62150: ST_TO_ADDR
// if tmp then
62151: LD_VAR 0 6
62155: IFFALSE 62161
// exit ;
62157: POP
62158: POP
62159: GO 62301
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62161: LD_ADDR_VAR 0 6
62165: PUSH
62166: LD_EXP 99
62170: PUSH
62171: LD_VAR 0 3
62175: ARRAY
62176: PPUSH
62177: LD_INT 2
62179: PUSH
62180: LD_INT 30
62182: PUSH
62183: LD_INT 4
62185: PUSH
62186: EMPTY
62187: LIST
62188: LIST
62189: PUSH
62190: LD_INT 30
62192: PUSH
62193: LD_INT 5
62195: PUSH
62196: EMPTY
62197: LIST
62198: LIST
62199: PUSH
62200: EMPTY
62201: LIST
62202: LIST
62203: LIST
62204: PPUSH
62205: CALL_OW 72
62209: ST_TO_ADDR
// if not tmp then
62210: LD_VAR 0 6
62214: NOT
62215: IFFALSE 62221
// exit ;
62217: POP
62218: POP
62219: GO 62301
// for j in tmp do
62221: LD_ADDR_VAR 0 4
62225: PUSH
62226: LD_VAR 0 6
62230: PUSH
62231: FOR_IN
62232: IFFALSE 62291
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
62234: LD_ADDR_VAR 0 7
62238: PUSH
62239: LD_VAR 0 4
62243: PPUSH
62244: CALL_OW 313
62248: PPUSH
62249: LD_INT 25
62251: PUSH
62252: LD_INT 1
62254: PUSH
62255: EMPTY
62256: LIST
62257: LIST
62258: PPUSH
62259: CALL_OW 72
62263: ST_TO_ADDR
// if units then
62264: LD_VAR 0 7
62268: IFFALSE 62289
// begin ComExitBuilding ( units [ 1 ] ) ;
62270: LD_VAR 0 7
62274: PUSH
62275: LD_INT 1
62277: ARRAY
62278: PPUSH
62279: CALL_OW 122
// exit ;
62283: POP
62284: POP
62285: POP
62286: POP
62287: GO 62301
// end ; end ;
62289: GO 62231
62291: POP
62292: POP
// end ; end ; exit ;
62293: POP
62294: POP
62295: GO 62301
// end ; end ;
62297: GO 61655
62299: POP
62300: POP
// end ;
62301: LD_VAR 0 2
62305: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
62306: LD_INT 0
62308: PPUSH
62309: PPUSH
62310: PPUSH
62311: PPUSH
62312: PPUSH
62313: PPUSH
62314: PPUSH
// if not mc_bases or not skirmish then
62315: LD_EXP 99
62319: NOT
62320: PUSH
62321: LD_EXP 97
62325: NOT
62326: OR
62327: IFFALSE 62331
// exit ;
62329: GO 62562
// btype := GetBType ( building ) ;
62331: LD_ADDR_VAR 0 6
62335: PUSH
62336: LD_VAR 0 1
62340: PPUSH
62341: CALL_OW 266
62345: ST_TO_ADDR
// x := GetX ( building ) ;
62346: LD_ADDR_VAR 0 7
62350: PUSH
62351: LD_VAR 0 1
62355: PPUSH
62356: CALL_OW 250
62360: ST_TO_ADDR
// y := GetY ( building ) ;
62361: LD_ADDR_VAR 0 8
62365: PUSH
62366: LD_VAR 0 1
62370: PPUSH
62371: CALL_OW 251
62375: ST_TO_ADDR
// d := GetDir ( building ) ;
62376: LD_ADDR_VAR 0 9
62380: PUSH
62381: LD_VAR 0 1
62385: PPUSH
62386: CALL_OW 254
62390: ST_TO_ADDR
// for i = 1 to mc_bases do
62391: LD_ADDR_VAR 0 4
62395: PUSH
62396: DOUBLE
62397: LD_INT 1
62399: DEC
62400: ST_TO_ADDR
62401: LD_EXP 99
62405: PUSH
62406: FOR_TO
62407: IFFALSE 62560
// begin if not mc_build_list [ i ] then
62409: LD_EXP 104
62413: PUSH
62414: LD_VAR 0 4
62418: ARRAY
62419: NOT
62420: IFFALSE 62424
// continue ;
62422: GO 62406
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
62424: LD_VAR 0 6
62428: PUSH
62429: LD_VAR 0 7
62433: PUSH
62434: LD_VAR 0 8
62438: PUSH
62439: LD_VAR 0 9
62443: PUSH
62444: EMPTY
62445: LIST
62446: LIST
62447: LIST
62448: LIST
62449: PPUSH
62450: LD_EXP 104
62454: PUSH
62455: LD_VAR 0 4
62459: ARRAY
62460: PUSH
62461: LD_INT 1
62463: ARRAY
62464: PPUSH
62465: CALL 75818 0 2
62469: IFFALSE 62558
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
62471: LD_ADDR_EXP 104
62475: PUSH
62476: LD_EXP 104
62480: PPUSH
62481: LD_VAR 0 4
62485: PPUSH
62486: LD_EXP 104
62490: PUSH
62491: LD_VAR 0 4
62495: ARRAY
62496: PPUSH
62497: LD_INT 1
62499: PPUSH
62500: CALL_OW 3
62504: PPUSH
62505: CALL_OW 1
62509: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
62510: LD_ADDR_EXP 106
62514: PUSH
62515: LD_EXP 106
62519: PPUSH
62520: LD_VAR 0 4
62524: PUSH
62525: LD_EXP 106
62529: PUSH
62530: LD_VAR 0 4
62534: ARRAY
62535: PUSH
62536: LD_INT 1
62538: PLUS
62539: PUSH
62540: EMPTY
62541: LIST
62542: LIST
62543: PPUSH
62544: LD_VAR 0 1
62548: PPUSH
62549: CALL 69649 0 3
62553: ST_TO_ADDR
// exit ;
62554: POP
62555: POP
62556: GO 62562
// end ; end ;
62558: GO 62406
62560: POP
62561: POP
// end ;
62562: LD_VAR 0 3
62566: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
62567: LD_INT 0
62569: PPUSH
62570: PPUSH
62571: PPUSH
// if not mc_bases or not skirmish then
62572: LD_EXP 99
62576: NOT
62577: PUSH
62578: LD_EXP 97
62582: NOT
62583: OR
62584: IFFALSE 62588
// exit ;
62586: GO 62778
// for i = 1 to mc_bases do
62588: LD_ADDR_VAR 0 4
62592: PUSH
62593: DOUBLE
62594: LD_INT 1
62596: DEC
62597: ST_TO_ADDR
62598: LD_EXP 99
62602: PUSH
62603: FOR_TO
62604: IFFALSE 62691
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
62606: LD_VAR 0 1
62610: PUSH
62611: LD_EXP 107
62615: PUSH
62616: LD_VAR 0 4
62620: ARRAY
62621: IN
62622: PUSH
62623: LD_VAR 0 1
62627: PUSH
62628: LD_EXP 108
62632: PUSH
62633: LD_VAR 0 4
62637: ARRAY
62638: IN
62639: NOT
62640: AND
62641: IFFALSE 62689
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
62643: LD_ADDR_EXP 108
62647: PUSH
62648: LD_EXP 108
62652: PPUSH
62653: LD_VAR 0 4
62657: PUSH
62658: LD_EXP 108
62662: PUSH
62663: LD_VAR 0 4
62667: ARRAY
62668: PUSH
62669: LD_INT 1
62671: PLUS
62672: PUSH
62673: EMPTY
62674: LIST
62675: LIST
62676: PPUSH
62677: LD_VAR 0 1
62681: PPUSH
62682: CALL 69649 0 3
62686: ST_TO_ADDR
// break ;
62687: GO 62691
// end ; end ;
62689: GO 62603
62691: POP
62692: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
62693: LD_VAR 0 1
62697: PPUSH
62698: CALL_OW 257
62702: PUSH
62703: LD_EXP 125
62707: IN
62708: PUSH
62709: LD_VAR 0 1
62713: PPUSH
62714: CALL_OW 266
62718: PUSH
62719: LD_INT 5
62721: EQUAL
62722: AND
62723: PUSH
62724: LD_VAR 0 2
62728: PPUSH
62729: CALL_OW 110
62733: PUSH
62734: LD_INT 18
62736: NONEQUAL
62737: AND
62738: IFFALSE 62778
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
62740: LD_VAR 0 2
62744: PPUSH
62745: CALL_OW 257
62749: PUSH
62750: LD_INT 5
62752: PUSH
62753: LD_INT 8
62755: PUSH
62756: LD_INT 9
62758: PUSH
62759: EMPTY
62760: LIST
62761: LIST
62762: LIST
62763: IN
62764: IFFALSE 62778
// SetClass ( unit , 1 ) ;
62766: LD_VAR 0 2
62770: PPUSH
62771: LD_INT 1
62773: PPUSH
62774: CALL_OW 336
// end ;
62778: LD_VAR 0 3
62782: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
62783: LD_INT 0
62785: PPUSH
62786: PPUSH
// if not mc_bases or not skirmish then
62787: LD_EXP 99
62791: NOT
62792: PUSH
62793: LD_EXP 97
62797: NOT
62798: OR
62799: IFFALSE 62803
// exit ;
62801: GO 62919
// if GetLives ( abandoned_vehicle ) > 250 then
62803: LD_VAR 0 2
62807: PPUSH
62808: CALL_OW 256
62812: PUSH
62813: LD_INT 250
62815: GREATER
62816: IFFALSE 62820
// exit ;
62818: GO 62919
// for i = 1 to mc_bases do
62820: LD_ADDR_VAR 0 6
62824: PUSH
62825: DOUBLE
62826: LD_INT 1
62828: DEC
62829: ST_TO_ADDR
62830: LD_EXP 99
62834: PUSH
62835: FOR_TO
62836: IFFALSE 62917
// begin if driver in mc_bases [ i ] then
62838: LD_VAR 0 1
62842: PUSH
62843: LD_EXP 99
62847: PUSH
62848: LD_VAR 0 6
62852: ARRAY
62853: IN
62854: IFFALSE 62915
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
62856: LD_VAR 0 1
62860: PPUSH
62861: LD_EXP 99
62865: PUSH
62866: LD_VAR 0 6
62870: ARRAY
62871: PPUSH
62872: LD_INT 2
62874: PUSH
62875: LD_INT 30
62877: PUSH
62878: LD_INT 0
62880: PUSH
62881: EMPTY
62882: LIST
62883: LIST
62884: PUSH
62885: LD_INT 30
62887: PUSH
62888: LD_INT 1
62890: PUSH
62891: EMPTY
62892: LIST
62893: LIST
62894: PUSH
62895: EMPTY
62896: LIST
62897: LIST
62898: LIST
62899: PPUSH
62900: CALL_OW 72
62904: PUSH
62905: LD_INT 1
62907: ARRAY
62908: PPUSH
62909: CALL_OW 112
// break ;
62913: GO 62917
// end ; end ;
62915: GO 62835
62917: POP
62918: POP
// end ; end_of_file
62919: LD_VAR 0 5
62923: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
62924: LD_INT 0
62926: PPUSH
62927: PPUSH
// if exist_mode then
62928: LD_VAR 0 2
62932: IFFALSE 62957
// unit := CreateCharacter ( prefix & ident ) else
62934: LD_ADDR_VAR 0 5
62938: PUSH
62939: LD_VAR 0 3
62943: PUSH
62944: LD_VAR 0 1
62948: STR
62949: PPUSH
62950: CALL_OW 34
62954: ST_TO_ADDR
62955: GO 62972
// unit := NewCharacter ( ident ) ;
62957: LD_ADDR_VAR 0 5
62961: PUSH
62962: LD_VAR 0 1
62966: PPUSH
62967: CALL_OW 25
62971: ST_TO_ADDR
// result := unit ;
62972: LD_ADDR_VAR 0 4
62976: PUSH
62977: LD_VAR 0 5
62981: ST_TO_ADDR
// end ;
62982: LD_VAR 0 4
62986: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
62987: LD_INT 0
62989: PPUSH
62990: PPUSH
// if not side or not nation then
62991: LD_VAR 0 1
62995: NOT
62996: PUSH
62997: LD_VAR 0 2
63001: NOT
63002: OR
63003: IFFALSE 63007
// exit ;
63005: GO 63643
// case nation of nation_american :
63007: LD_VAR 0 2
63011: PUSH
63012: LD_INT 1
63014: DOUBLE
63015: EQUAL
63016: IFTRUE 63020
63018: GO 63190
63020: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 ] ; nation_arabian :
63021: LD_ADDR_VAR 0 4
63025: PUSH
63026: LD_INT 35
63028: PUSH
63029: LD_INT 45
63031: PUSH
63032: LD_INT 46
63034: PUSH
63035: LD_INT 47
63037: PUSH
63038: LD_INT 1
63040: PUSH
63041: LD_INT 2
63043: PUSH
63044: LD_INT 6
63046: PUSH
63047: LD_INT 15
63049: PUSH
63050: LD_INT 16
63052: PUSH
63053: LD_INT 7
63055: PUSH
63056: LD_INT 12
63058: PUSH
63059: LD_INT 13
63061: PUSH
63062: LD_INT 10
63064: PUSH
63065: LD_INT 14
63067: PUSH
63068: LD_INT 20
63070: PUSH
63071: LD_INT 21
63073: PUSH
63074: LD_INT 22
63076: PUSH
63077: LD_INT 25
63079: PUSH
63080: LD_INT 32
63082: PUSH
63083: LD_INT 27
63085: PUSH
63086: LD_INT 36
63088: PUSH
63089: LD_INT 69
63091: PUSH
63092: LD_INT 39
63094: PUSH
63095: LD_INT 34
63097: PUSH
63098: LD_INT 40
63100: PUSH
63101: LD_INT 48
63103: PUSH
63104: LD_INT 49
63106: PUSH
63107: LD_INT 50
63109: PUSH
63110: LD_INT 51
63112: PUSH
63113: LD_INT 52
63115: PUSH
63116: LD_INT 53
63118: PUSH
63119: LD_INT 54
63121: PUSH
63122: LD_INT 55
63124: PUSH
63125: LD_INT 56
63127: PUSH
63128: LD_INT 57
63130: PUSH
63131: LD_INT 58
63133: PUSH
63134: LD_INT 59
63136: PUSH
63137: LD_INT 60
63139: PUSH
63140: LD_INT 61
63142: PUSH
63143: LD_INT 62
63145: PUSH
63146: EMPTY
63147: LIST
63148: LIST
63149: LIST
63150: LIST
63151: LIST
63152: LIST
63153: LIST
63154: LIST
63155: LIST
63156: LIST
63157: LIST
63158: LIST
63159: LIST
63160: LIST
63161: LIST
63162: LIST
63163: LIST
63164: LIST
63165: LIST
63166: LIST
63167: LIST
63168: LIST
63169: LIST
63170: LIST
63171: LIST
63172: LIST
63173: LIST
63174: LIST
63175: LIST
63176: LIST
63177: LIST
63178: LIST
63179: LIST
63180: LIST
63181: LIST
63182: LIST
63183: LIST
63184: LIST
63185: LIST
63186: LIST
63187: ST_TO_ADDR
63188: GO 63567
63190: LD_INT 2
63192: DOUBLE
63193: EQUAL
63194: IFTRUE 63198
63196: GO 63376
63198: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 ] ; nation_russian :
63199: LD_ADDR_VAR 0 4
63203: PUSH
63204: LD_INT 35
63206: PUSH
63207: LD_INT 45
63209: PUSH
63210: LD_INT 46
63212: PUSH
63213: LD_INT 47
63215: PUSH
63216: LD_INT 70
63218: PUSH
63219: LD_INT 1
63221: PUSH
63222: LD_INT 11
63224: PUSH
63225: LD_INT 3
63227: PUSH
63228: LD_INT 4
63230: PUSH
63231: LD_INT 5
63233: PUSH
63234: LD_INT 6
63236: PUSH
63237: LD_INT 15
63239: PUSH
63240: LD_INT 18
63242: PUSH
63243: LD_INT 7
63245: PUSH
63246: LD_INT 17
63248: PUSH
63249: LD_INT 8
63251: PUSH
63252: LD_INT 20
63254: PUSH
63255: LD_INT 21
63257: PUSH
63258: LD_INT 22
63260: PUSH
63261: LD_INT 72
63263: PUSH
63264: LD_INT 26
63266: PUSH
63267: LD_INT 69
63269: PUSH
63270: LD_INT 39
63272: PUSH
63273: LD_INT 40
63275: PUSH
63276: LD_INT 41
63278: PUSH
63279: LD_INT 42
63281: PUSH
63282: LD_INT 43
63284: PUSH
63285: LD_INT 48
63287: PUSH
63288: LD_INT 49
63290: PUSH
63291: LD_INT 50
63293: PUSH
63294: LD_INT 51
63296: PUSH
63297: LD_INT 52
63299: PUSH
63300: LD_INT 53
63302: PUSH
63303: LD_INT 54
63305: PUSH
63306: LD_INT 55
63308: PUSH
63309: LD_INT 56
63311: PUSH
63312: LD_INT 60
63314: PUSH
63315: LD_INT 61
63317: PUSH
63318: LD_INT 62
63320: PUSH
63321: LD_INT 66
63323: PUSH
63324: LD_INT 67
63326: PUSH
63327: LD_INT 68
63329: PUSH
63330: EMPTY
63331: LIST
63332: LIST
63333: LIST
63334: LIST
63335: LIST
63336: LIST
63337: LIST
63338: LIST
63339: LIST
63340: LIST
63341: LIST
63342: LIST
63343: LIST
63344: LIST
63345: LIST
63346: LIST
63347: LIST
63348: LIST
63349: LIST
63350: LIST
63351: LIST
63352: LIST
63353: LIST
63354: LIST
63355: LIST
63356: LIST
63357: LIST
63358: LIST
63359: LIST
63360: LIST
63361: LIST
63362: LIST
63363: LIST
63364: LIST
63365: LIST
63366: LIST
63367: LIST
63368: LIST
63369: LIST
63370: LIST
63371: LIST
63372: LIST
63373: ST_TO_ADDR
63374: GO 63567
63376: LD_INT 3
63378: DOUBLE
63379: EQUAL
63380: IFTRUE 63384
63382: GO 63566
63384: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
63385: LD_ADDR_VAR 0 4
63389: PUSH
63390: LD_INT 46
63392: PUSH
63393: LD_INT 47
63395: PUSH
63396: LD_INT 1
63398: PUSH
63399: LD_INT 2
63401: PUSH
63402: LD_INT 11
63404: PUSH
63405: LD_INT 9
63407: PUSH
63408: LD_INT 20
63410: PUSH
63411: LD_INT 19
63413: PUSH
63414: LD_INT 21
63416: PUSH
63417: LD_INT 24
63419: PUSH
63420: LD_INT 22
63422: PUSH
63423: LD_INT 25
63425: PUSH
63426: LD_INT 28
63428: PUSH
63429: LD_INT 29
63431: PUSH
63432: LD_INT 30
63434: PUSH
63435: LD_INT 31
63437: PUSH
63438: LD_INT 37
63440: PUSH
63441: LD_INT 38
63443: PUSH
63444: LD_INT 32
63446: PUSH
63447: LD_INT 27
63449: PUSH
63450: LD_INT 33
63452: PUSH
63453: LD_INT 69
63455: PUSH
63456: LD_INT 39
63458: PUSH
63459: LD_INT 34
63461: PUSH
63462: LD_INT 40
63464: PUSH
63465: LD_INT 71
63467: PUSH
63468: LD_INT 23
63470: PUSH
63471: LD_INT 44
63473: PUSH
63474: LD_INT 48
63476: PUSH
63477: LD_INT 49
63479: PUSH
63480: LD_INT 50
63482: PUSH
63483: LD_INT 51
63485: PUSH
63486: LD_INT 52
63488: PUSH
63489: LD_INT 53
63491: PUSH
63492: LD_INT 54
63494: PUSH
63495: LD_INT 55
63497: PUSH
63498: LD_INT 56
63500: PUSH
63501: LD_INT 57
63503: PUSH
63504: LD_INT 58
63506: PUSH
63507: LD_INT 59
63509: PUSH
63510: LD_INT 63
63512: PUSH
63513: LD_INT 64
63515: PUSH
63516: LD_INT 65
63518: PUSH
63519: EMPTY
63520: LIST
63521: LIST
63522: LIST
63523: LIST
63524: LIST
63525: LIST
63526: LIST
63527: LIST
63528: LIST
63529: LIST
63530: LIST
63531: LIST
63532: LIST
63533: LIST
63534: LIST
63535: LIST
63536: LIST
63537: LIST
63538: LIST
63539: LIST
63540: LIST
63541: LIST
63542: LIST
63543: LIST
63544: LIST
63545: LIST
63546: LIST
63547: LIST
63548: LIST
63549: LIST
63550: LIST
63551: LIST
63552: LIST
63553: LIST
63554: LIST
63555: LIST
63556: LIST
63557: LIST
63558: LIST
63559: LIST
63560: LIST
63561: LIST
63562: LIST
63563: ST_TO_ADDR
63564: GO 63567
63566: POP
// if state > - 1 and state < 3 then
63567: LD_VAR 0 3
63571: PUSH
63572: LD_INT 1
63574: NEG
63575: GREATER
63576: PUSH
63577: LD_VAR 0 3
63581: PUSH
63582: LD_INT 3
63584: LESS
63585: AND
63586: IFFALSE 63643
// for i in result do
63588: LD_ADDR_VAR 0 5
63592: PUSH
63593: LD_VAR 0 4
63597: PUSH
63598: FOR_IN
63599: IFFALSE 63641
// if GetTech ( i , side ) <> state then
63601: LD_VAR 0 5
63605: PPUSH
63606: LD_VAR 0 1
63610: PPUSH
63611: CALL_OW 321
63615: PUSH
63616: LD_VAR 0 3
63620: NONEQUAL
63621: IFFALSE 63639
// result := result diff i ;
63623: LD_ADDR_VAR 0 4
63627: PUSH
63628: LD_VAR 0 4
63632: PUSH
63633: LD_VAR 0 5
63637: DIFF
63638: ST_TO_ADDR
63639: GO 63598
63641: POP
63642: POP
// end ;
63643: LD_VAR 0 4
63647: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
63648: LD_INT 0
63650: PPUSH
63651: PPUSH
63652: PPUSH
// result := true ;
63653: LD_ADDR_VAR 0 3
63657: PUSH
63658: LD_INT 1
63660: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
63661: LD_ADDR_VAR 0 5
63665: PUSH
63666: LD_VAR 0 2
63670: PPUSH
63671: CALL_OW 480
63675: ST_TO_ADDR
// if not tmp then
63676: LD_VAR 0 5
63680: NOT
63681: IFFALSE 63685
// exit ;
63683: GO 63734
// for i in tmp do
63685: LD_ADDR_VAR 0 4
63689: PUSH
63690: LD_VAR 0 5
63694: PUSH
63695: FOR_IN
63696: IFFALSE 63732
// if GetTech ( i , side ) <> state_researched then
63698: LD_VAR 0 4
63702: PPUSH
63703: LD_VAR 0 1
63707: PPUSH
63708: CALL_OW 321
63712: PUSH
63713: LD_INT 2
63715: NONEQUAL
63716: IFFALSE 63730
// begin result := false ;
63718: LD_ADDR_VAR 0 3
63722: PUSH
63723: LD_INT 0
63725: ST_TO_ADDR
// exit ;
63726: POP
63727: POP
63728: GO 63734
// end ;
63730: GO 63695
63732: POP
63733: POP
// end ;
63734: LD_VAR 0 3
63738: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
63739: LD_INT 0
63741: PPUSH
63742: PPUSH
63743: PPUSH
63744: PPUSH
63745: PPUSH
63746: PPUSH
63747: PPUSH
63748: PPUSH
63749: PPUSH
63750: PPUSH
63751: PPUSH
63752: PPUSH
63753: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
63754: LD_VAR 0 1
63758: NOT
63759: PUSH
63760: LD_VAR 0 1
63764: PPUSH
63765: CALL_OW 257
63769: PUSH
63770: LD_INT 9
63772: NONEQUAL
63773: OR
63774: IFFALSE 63778
// exit ;
63776: GO 64351
// side := GetSide ( unit ) ;
63778: LD_ADDR_VAR 0 9
63782: PUSH
63783: LD_VAR 0 1
63787: PPUSH
63788: CALL_OW 255
63792: ST_TO_ADDR
// tech_space := tech_spacanom ;
63793: LD_ADDR_VAR 0 12
63797: PUSH
63798: LD_INT 29
63800: ST_TO_ADDR
// tech_time := tech_taurad ;
63801: LD_ADDR_VAR 0 13
63805: PUSH
63806: LD_INT 28
63808: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
63809: LD_ADDR_VAR 0 11
63813: PUSH
63814: LD_VAR 0 1
63818: PPUSH
63819: CALL_OW 310
63823: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
63824: LD_VAR 0 11
63828: PPUSH
63829: CALL_OW 247
63833: PUSH
63834: LD_INT 2
63836: EQUAL
63837: IFFALSE 63841
// exit ;
63839: GO 64351
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
63841: LD_ADDR_VAR 0 8
63845: PUSH
63846: LD_INT 81
63848: PUSH
63849: LD_VAR 0 9
63853: PUSH
63854: EMPTY
63855: LIST
63856: LIST
63857: PUSH
63858: LD_INT 3
63860: PUSH
63861: LD_INT 21
63863: PUSH
63864: LD_INT 3
63866: PUSH
63867: EMPTY
63868: LIST
63869: LIST
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: PUSH
63875: EMPTY
63876: LIST
63877: LIST
63878: PPUSH
63879: CALL_OW 69
63883: ST_TO_ADDR
// if not tmp then
63884: LD_VAR 0 8
63888: NOT
63889: IFFALSE 63893
// exit ;
63891: GO 64351
// if in_unit then
63893: LD_VAR 0 11
63897: IFFALSE 63921
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
63899: LD_ADDR_VAR 0 10
63903: PUSH
63904: LD_VAR 0 8
63908: PPUSH
63909: LD_VAR 0 11
63913: PPUSH
63914: CALL_OW 74
63918: ST_TO_ADDR
63919: GO 63941
// enemy := NearestUnitToUnit ( tmp , unit ) ;
63921: LD_ADDR_VAR 0 10
63925: PUSH
63926: LD_VAR 0 8
63930: PPUSH
63931: LD_VAR 0 1
63935: PPUSH
63936: CALL_OW 74
63940: ST_TO_ADDR
// if not enemy then
63941: LD_VAR 0 10
63945: NOT
63946: IFFALSE 63950
// exit ;
63948: GO 64351
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
63950: LD_VAR 0 11
63954: PUSH
63955: LD_VAR 0 11
63959: PPUSH
63960: LD_VAR 0 10
63964: PPUSH
63965: CALL_OW 296
63969: PUSH
63970: LD_INT 13
63972: GREATER
63973: AND
63974: PUSH
63975: LD_VAR 0 1
63979: PPUSH
63980: LD_VAR 0 10
63984: PPUSH
63985: CALL_OW 296
63989: PUSH
63990: LD_INT 12
63992: GREATER
63993: OR
63994: IFFALSE 63998
// exit ;
63996: GO 64351
// missile := [ 1 ] ;
63998: LD_ADDR_VAR 0 14
64002: PUSH
64003: LD_INT 1
64005: PUSH
64006: EMPTY
64007: LIST
64008: ST_TO_ADDR
// if Researched ( side , tech_space ) then
64009: LD_VAR 0 9
64013: PPUSH
64014: LD_VAR 0 12
64018: PPUSH
64019: CALL_OW 325
64023: IFFALSE 64052
// missile := Insert ( missile , missile + 1 , 2 ) ;
64025: LD_ADDR_VAR 0 14
64029: PUSH
64030: LD_VAR 0 14
64034: PPUSH
64035: LD_VAR 0 14
64039: PUSH
64040: LD_INT 1
64042: PLUS
64043: PPUSH
64044: LD_INT 2
64046: PPUSH
64047: CALL_OW 2
64051: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
64052: LD_VAR 0 9
64056: PPUSH
64057: LD_VAR 0 13
64061: PPUSH
64062: CALL_OW 325
64066: PUSH
64067: LD_VAR 0 10
64071: PPUSH
64072: CALL_OW 255
64076: PPUSH
64077: LD_VAR 0 13
64081: PPUSH
64082: CALL_OW 325
64086: NOT
64087: AND
64088: IFFALSE 64117
// missile := Insert ( missile , missile + 1 , 3 ) ;
64090: LD_ADDR_VAR 0 14
64094: PUSH
64095: LD_VAR 0 14
64099: PPUSH
64100: LD_VAR 0 14
64104: PUSH
64105: LD_INT 1
64107: PLUS
64108: PPUSH
64109: LD_INT 3
64111: PPUSH
64112: CALL_OW 2
64116: ST_TO_ADDR
// if missile < 2 then
64117: LD_VAR 0 14
64121: PUSH
64122: LD_INT 2
64124: LESS
64125: IFFALSE 64129
// exit ;
64127: GO 64351
// x := GetX ( enemy ) ;
64129: LD_ADDR_VAR 0 4
64133: PUSH
64134: LD_VAR 0 10
64138: PPUSH
64139: CALL_OW 250
64143: ST_TO_ADDR
// y := GetY ( enemy ) ;
64144: LD_ADDR_VAR 0 5
64148: PUSH
64149: LD_VAR 0 10
64153: PPUSH
64154: CALL_OW 251
64158: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
64159: LD_ADDR_VAR 0 6
64163: PUSH
64164: LD_VAR 0 4
64168: PUSH
64169: LD_INT 1
64171: NEG
64172: PPUSH
64173: LD_INT 1
64175: PPUSH
64176: CALL_OW 12
64180: PLUS
64181: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
64182: LD_ADDR_VAR 0 7
64186: PUSH
64187: LD_VAR 0 5
64191: PUSH
64192: LD_INT 1
64194: NEG
64195: PPUSH
64196: LD_INT 1
64198: PPUSH
64199: CALL_OW 12
64203: PLUS
64204: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64205: LD_VAR 0 6
64209: PPUSH
64210: LD_VAR 0 7
64214: PPUSH
64215: CALL_OW 488
64219: NOT
64220: IFFALSE 64242
// begin _x := x ;
64222: LD_ADDR_VAR 0 6
64226: PUSH
64227: LD_VAR 0 4
64231: ST_TO_ADDR
// _y := y ;
64232: LD_ADDR_VAR 0 7
64236: PUSH
64237: LD_VAR 0 5
64241: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
64242: LD_ADDR_VAR 0 3
64246: PUSH
64247: LD_INT 1
64249: PPUSH
64250: LD_VAR 0 14
64254: PPUSH
64255: CALL_OW 12
64259: ST_TO_ADDR
// case i of 1 :
64260: LD_VAR 0 3
64264: PUSH
64265: LD_INT 1
64267: DOUBLE
64268: EQUAL
64269: IFTRUE 64273
64271: GO 64290
64273: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
64274: LD_VAR 0 1
64278: PPUSH
64279: LD_VAR 0 10
64283: PPUSH
64284: CALL_OW 115
64288: GO 64351
64290: LD_INT 2
64292: DOUBLE
64293: EQUAL
64294: IFTRUE 64298
64296: GO 64320
64298: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
64299: LD_VAR 0 1
64303: PPUSH
64304: LD_VAR 0 6
64308: PPUSH
64309: LD_VAR 0 7
64313: PPUSH
64314: CALL_OW 153
64318: GO 64351
64320: LD_INT 3
64322: DOUBLE
64323: EQUAL
64324: IFTRUE 64328
64326: GO 64350
64328: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
64329: LD_VAR 0 1
64333: PPUSH
64334: LD_VAR 0 6
64338: PPUSH
64339: LD_VAR 0 7
64343: PPUSH
64344: CALL_OW 154
64348: GO 64351
64350: POP
// end ;
64351: LD_VAR 0 2
64355: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
64356: LD_INT 0
64358: PPUSH
64359: PPUSH
64360: PPUSH
64361: PPUSH
64362: PPUSH
64363: PPUSH
// if not unit or not building then
64364: LD_VAR 0 1
64368: NOT
64369: PUSH
64370: LD_VAR 0 2
64374: NOT
64375: OR
64376: IFFALSE 64380
// exit ;
64378: GO 64538
// x := GetX ( building ) ;
64380: LD_ADDR_VAR 0 5
64384: PUSH
64385: LD_VAR 0 2
64389: PPUSH
64390: CALL_OW 250
64394: ST_TO_ADDR
// y := GetY ( building ) ;
64395: LD_ADDR_VAR 0 6
64399: PUSH
64400: LD_VAR 0 2
64404: PPUSH
64405: CALL_OW 251
64409: ST_TO_ADDR
// for i = 0 to 5 do
64410: LD_ADDR_VAR 0 4
64414: PUSH
64415: DOUBLE
64416: LD_INT 0
64418: DEC
64419: ST_TO_ADDR
64420: LD_INT 5
64422: PUSH
64423: FOR_TO
64424: IFFALSE 64536
// begin _x := ShiftX ( x , i , 3 ) ;
64426: LD_ADDR_VAR 0 7
64430: PUSH
64431: LD_VAR 0 5
64435: PPUSH
64436: LD_VAR 0 4
64440: PPUSH
64441: LD_INT 3
64443: PPUSH
64444: CALL_OW 272
64448: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
64449: LD_ADDR_VAR 0 8
64453: PUSH
64454: LD_VAR 0 6
64458: PPUSH
64459: LD_VAR 0 4
64463: PPUSH
64464: LD_INT 3
64466: PPUSH
64467: CALL_OW 273
64471: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
64472: LD_VAR 0 7
64476: PPUSH
64477: LD_VAR 0 8
64481: PPUSH
64482: CALL_OW 488
64486: NOT
64487: IFFALSE 64491
// continue ;
64489: GO 64423
// if HexInfo ( _x , _y ) = 0 then
64491: LD_VAR 0 7
64495: PPUSH
64496: LD_VAR 0 8
64500: PPUSH
64501: CALL_OW 428
64505: PUSH
64506: LD_INT 0
64508: EQUAL
64509: IFFALSE 64534
// begin ComMoveXY ( unit , _x , _y ) ;
64511: LD_VAR 0 1
64515: PPUSH
64516: LD_VAR 0 7
64520: PPUSH
64521: LD_VAR 0 8
64525: PPUSH
64526: CALL_OW 111
// exit ;
64530: POP
64531: POP
64532: GO 64538
// end ; end ;
64534: GO 64423
64536: POP
64537: POP
// end ;
64538: LD_VAR 0 3
64542: RET
// export function ScanBase ( side , base_area ) ; begin
64543: LD_INT 0
64545: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
64546: LD_ADDR_VAR 0 3
64550: PUSH
64551: LD_VAR 0 2
64555: PPUSH
64556: LD_INT 81
64558: PUSH
64559: LD_VAR 0 1
64563: PUSH
64564: EMPTY
64565: LIST
64566: LIST
64567: PPUSH
64568: CALL_OW 70
64572: ST_TO_ADDR
// end ;
64573: LD_VAR 0 3
64577: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
64578: LD_INT 0
64580: PPUSH
64581: PPUSH
64582: PPUSH
64583: PPUSH
64584: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
64585: LD_VAR 0 1
64589: NOT
64590: PUSH
64591: LD_EXP 99
64595: PUSH
64596: LD_VAR 0 1
64600: ARRAY
64601: NOT
64602: OR
64603: PUSH
64604: LD_VAR 0 2
64608: NOT
64609: OR
64610: PUSH
64611: LD_VAR 0 3
64615: NOT
64616: OR
64617: IFFALSE 64621
// exit ;
64619: GO 65071
// side := mc_sides [ base ] ;
64621: LD_ADDR_VAR 0 6
64625: PUSH
64626: LD_EXP 125
64630: PUSH
64631: LD_VAR 0 1
64635: ARRAY
64636: ST_TO_ADDR
// if not side then
64637: LD_VAR 0 6
64641: NOT
64642: IFFALSE 64646
// exit ;
64644: GO 65071
// for i in solds do
64646: LD_ADDR_VAR 0 7
64650: PUSH
64651: LD_VAR 0 2
64655: PUSH
64656: FOR_IN
64657: IFFALSE 64718
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
64659: LD_VAR 0 7
64663: PPUSH
64664: CALL_OW 310
64668: PPUSH
64669: CALL_OW 266
64673: PUSH
64674: LD_INT 32
64676: PUSH
64677: LD_INT 31
64679: PUSH
64680: EMPTY
64681: LIST
64682: LIST
64683: IN
64684: IFFALSE 64704
// solds := solds diff i else
64686: LD_ADDR_VAR 0 2
64690: PUSH
64691: LD_VAR 0 2
64695: PUSH
64696: LD_VAR 0 7
64700: DIFF
64701: ST_TO_ADDR
64702: GO 64716
// SetTag ( i , 18 ) ;
64704: LD_VAR 0 7
64708: PPUSH
64709: LD_INT 18
64711: PPUSH
64712: CALL_OW 109
64716: GO 64656
64718: POP
64719: POP
// if not solds then
64720: LD_VAR 0 2
64724: NOT
64725: IFFALSE 64729
// exit ;
64727: GO 65071
// repeat wait ( 0 0$1 ) ;
64729: LD_INT 35
64731: PPUSH
64732: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
64736: LD_ADDR_VAR 0 5
64740: PUSH
64741: LD_VAR 0 6
64745: PPUSH
64746: LD_VAR 0 3
64750: PPUSH
64751: CALL 64543 0 2
64755: ST_TO_ADDR
// if not enemy or enemy > 3 or mc_defender [ base ] then
64756: LD_VAR 0 5
64760: NOT
64761: PUSH
64762: LD_VAR 0 5
64766: PUSH
64767: LD_INT 3
64769: GREATER
64770: OR
64771: PUSH
64772: LD_EXP 121
64776: PUSH
64777: LD_VAR 0 1
64781: ARRAY
64782: OR
64783: IFFALSE 64824
// begin for i in solds do
64785: LD_ADDR_VAR 0 7
64789: PUSH
64790: LD_VAR 0 2
64794: PUSH
64795: FOR_IN
64796: IFFALSE 64820
// if HasTask ( i ) then
64798: LD_VAR 0 7
64802: PPUSH
64803: CALL_OW 314
64807: IFFALSE 64818
// ComStop ( i ) ;
64809: LD_VAR 0 7
64813: PPUSH
64814: CALL_OW 141
64818: GO 64795
64820: POP
64821: POP
// break ;
64822: GO 65059
// end ; for i in solds do
64824: LD_ADDR_VAR 0 7
64828: PUSH
64829: LD_VAR 0 2
64833: PUSH
64834: FOR_IN
64835: IFFALSE 65051
// begin if IsInUnit ( i ) then
64837: LD_VAR 0 7
64841: PPUSH
64842: CALL_OW 310
64846: IFFALSE 64857
// ComExitBuilding ( i ) ;
64848: LD_VAR 0 7
64852: PPUSH
64853: CALL_OW 122
// if GetLives ( i ) > 333 then
64857: LD_VAR 0 7
64861: PPUSH
64862: CALL_OW 256
64866: PUSH
64867: LD_INT 333
64869: GREATER
64870: IFFALSE 64898
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
64872: LD_VAR 0 7
64876: PPUSH
64877: LD_VAR 0 5
64881: PPUSH
64882: LD_VAR 0 7
64886: PPUSH
64887: CALL_OW 74
64891: PPUSH
64892: CALL_OW 115
64896: GO 65049
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
64898: LD_ADDR_VAR 0 8
64902: PUSH
64903: LD_EXP 99
64907: PUSH
64908: LD_VAR 0 1
64912: ARRAY
64913: PPUSH
64914: LD_INT 2
64916: PUSH
64917: LD_INT 30
64919: PUSH
64920: LD_INT 0
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: PUSH
64927: LD_INT 30
64929: PUSH
64930: LD_INT 1
64932: PUSH
64933: EMPTY
64934: LIST
64935: LIST
64936: PUSH
64937: LD_INT 30
64939: PUSH
64940: LD_INT 6
64942: PUSH
64943: EMPTY
64944: LIST
64945: LIST
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: LIST
64951: LIST
64952: PPUSH
64953: CALL_OW 72
64957: PPUSH
64958: LD_VAR 0 7
64962: PPUSH
64963: CALL_OW 74
64967: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
64968: LD_VAR 0 7
64972: PPUSH
64973: LD_VAR 0 8
64977: PPUSH
64978: CALL_OW 250
64982: PPUSH
64983: LD_INT 3
64985: PPUSH
64986: LD_INT 5
64988: PPUSH
64989: CALL_OW 272
64993: PPUSH
64994: LD_VAR 0 8
64998: PPUSH
64999: CALL_OW 251
65003: PPUSH
65004: LD_INT 3
65006: PPUSH
65007: LD_INT 5
65009: PPUSH
65010: CALL_OW 273
65014: PPUSH
65015: CALL_OW 111
// SetTag ( i , 0 ) ;
65019: LD_VAR 0 7
65023: PPUSH
65024: LD_INT 0
65026: PPUSH
65027: CALL_OW 109
// solds := solds diff i ;
65031: LD_ADDR_VAR 0 2
65035: PUSH
65036: LD_VAR 0 2
65040: PUSH
65041: LD_VAR 0 7
65045: DIFF
65046: ST_TO_ADDR
// continue ;
65047: GO 64834
// end ; end ;
65049: GO 64834
65051: POP
65052: POP
// until solds ;
65053: LD_VAR 0 2
65057: IFFALSE 64729
// MC_Reset ( base , 18 ) ;
65059: LD_VAR 0 1
65063: PPUSH
65064: LD_INT 18
65066: PPUSH
65067: CALL 37779 0 2
// end ;
65071: LD_VAR 0 4
65075: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
65076: LD_INT 0
65078: PPUSH
65079: PPUSH
65080: PPUSH
65081: PPUSH
65082: PPUSH
65083: PPUSH
65084: PPUSH
65085: PPUSH
65086: PPUSH
65087: PPUSH
65088: PPUSH
65089: PPUSH
65090: PPUSH
65091: PPUSH
65092: PPUSH
65093: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65094: LD_ADDR_VAR 0 12
65098: PUSH
65099: LD_EXP 99
65103: PUSH
65104: LD_VAR 0 1
65108: ARRAY
65109: PPUSH
65110: LD_INT 25
65112: PUSH
65113: LD_INT 3
65115: PUSH
65116: EMPTY
65117: LIST
65118: LIST
65119: PPUSH
65120: CALL_OW 72
65124: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65125: LD_ADDR_VAR 0 8
65129: PUSH
65130: LD_EXP 99
65134: PUSH
65135: LD_VAR 0 1
65139: ARRAY
65140: PPUSH
65141: LD_INT 2
65143: PUSH
65144: LD_INT 25
65146: PUSH
65147: LD_INT 1
65149: PUSH
65150: EMPTY
65151: LIST
65152: LIST
65153: PUSH
65154: LD_INT 25
65156: PUSH
65157: LD_INT 5
65159: PUSH
65160: EMPTY
65161: LIST
65162: LIST
65163: PUSH
65164: LD_INT 25
65166: PUSH
65167: LD_INT 8
65169: PUSH
65170: EMPTY
65171: LIST
65172: LIST
65173: PUSH
65174: LD_INT 25
65176: PUSH
65177: LD_INT 9
65179: PUSH
65180: EMPTY
65181: LIST
65182: LIST
65183: PUSH
65184: EMPTY
65185: LIST
65186: LIST
65187: LIST
65188: LIST
65189: LIST
65190: PPUSH
65191: CALL_OW 72
65195: ST_TO_ADDR
// if not defenders and not solds then
65196: LD_VAR 0 2
65200: NOT
65201: PUSH
65202: LD_VAR 0 8
65206: NOT
65207: AND
65208: IFFALSE 65212
// exit ;
65210: GO 66541
// depot_under_attack := false ;
65212: LD_ADDR_VAR 0 16
65216: PUSH
65217: LD_INT 0
65219: ST_TO_ADDR
// sold_defenders := [ ] ;
65220: LD_ADDR_VAR 0 17
65224: PUSH
65225: EMPTY
65226: ST_TO_ADDR
// if mechs then
65227: LD_VAR 0 12
65231: IFFALSE 65360
// for i in defenders do
65233: LD_ADDR_VAR 0 5
65237: PUSH
65238: LD_VAR 0 2
65242: PUSH
65243: FOR_IN
65244: IFFALSE 65358
// begin SetTag ( i , 20 ) ;
65246: LD_VAR 0 5
65250: PPUSH
65251: LD_INT 20
65253: PPUSH
65254: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
65258: LD_VAR 0 5
65262: PPUSH
65263: CALL_OW 263
65267: PUSH
65268: LD_INT 1
65270: EQUAL
65271: PUSH
65272: LD_VAR 0 5
65276: PPUSH
65277: CALL_OW 311
65281: NOT
65282: AND
65283: PUSH
65284: LD_VAR 0 12
65288: AND
65289: IFFALSE 65356
// begin un := mechs [ 1 ] ;
65291: LD_ADDR_VAR 0 10
65295: PUSH
65296: LD_VAR 0 12
65300: PUSH
65301: LD_INT 1
65303: ARRAY
65304: ST_TO_ADDR
// ComExitBuilding ( un ) ;
65305: LD_VAR 0 10
65309: PPUSH
65310: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
65314: LD_VAR 0 10
65318: PPUSH
65319: LD_VAR 0 5
65323: PPUSH
65324: CALL_OW 180
// SetTag ( un , 19 ) ;
65328: LD_VAR 0 10
65332: PPUSH
65333: LD_INT 19
65335: PPUSH
65336: CALL_OW 109
// mechs := mechs diff un ;
65340: LD_ADDR_VAR 0 12
65344: PUSH
65345: LD_VAR 0 12
65349: PUSH
65350: LD_VAR 0 10
65354: DIFF
65355: ST_TO_ADDR
// end ; end ;
65356: GO 65243
65358: POP
65359: POP
// if solds then
65360: LD_VAR 0 8
65364: IFFALSE 65423
// for i in solds do
65366: LD_ADDR_VAR 0 5
65370: PUSH
65371: LD_VAR 0 8
65375: PUSH
65376: FOR_IN
65377: IFFALSE 65421
// if not GetTag ( i ) then
65379: LD_VAR 0 5
65383: PPUSH
65384: CALL_OW 110
65388: NOT
65389: IFFALSE 65419
// begin defenders := defenders union i ;
65391: LD_ADDR_VAR 0 2
65395: PUSH
65396: LD_VAR 0 2
65400: PUSH
65401: LD_VAR 0 5
65405: UNION
65406: ST_TO_ADDR
// SetTag ( i , 18 ) ;
65407: LD_VAR 0 5
65411: PPUSH
65412: LD_INT 18
65414: PPUSH
65415: CALL_OW 109
// end ;
65419: GO 65376
65421: POP
65422: POP
// repeat wait ( 0 0$1 ) ;
65423: LD_INT 35
65425: PPUSH
65426: CALL_OW 67
// enemy := mc_scan [ base ] ;
65430: LD_ADDR_VAR 0 3
65434: PUSH
65435: LD_EXP 122
65439: PUSH
65440: LD_VAR 0 1
65444: ARRAY
65445: ST_TO_ADDR
// for i in defenders do
65446: LD_ADDR_VAR 0 5
65450: PUSH
65451: LD_VAR 0 2
65455: PUSH
65456: FOR_IN
65457: IFFALSE 66142
// begin e := NearestUnitToUnit ( enemy , i ) ;
65459: LD_ADDR_VAR 0 13
65463: PUSH
65464: LD_VAR 0 3
65468: PPUSH
65469: LD_VAR 0 5
65473: PPUSH
65474: CALL_OW 74
65478: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
65479: LD_ADDR_VAR 0 16
65483: PUSH
65484: LD_EXP 99
65488: PUSH
65489: LD_VAR 0 1
65493: ARRAY
65494: PPUSH
65495: LD_INT 2
65497: PUSH
65498: LD_INT 30
65500: PUSH
65501: LD_INT 0
65503: PUSH
65504: EMPTY
65505: LIST
65506: LIST
65507: PUSH
65508: LD_INT 30
65510: PUSH
65511: LD_INT 1
65513: PUSH
65514: EMPTY
65515: LIST
65516: LIST
65517: PUSH
65518: EMPTY
65519: LIST
65520: LIST
65521: LIST
65522: PPUSH
65523: CALL_OW 72
65527: NOT
65528: PUSH
65529: LD_EXP 99
65533: PUSH
65534: LD_VAR 0 1
65538: ARRAY
65539: PPUSH
65540: LD_INT 2
65542: PUSH
65543: LD_INT 30
65545: PUSH
65546: LD_INT 0
65548: PUSH
65549: EMPTY
65550: LIST
65551: LIST
65552: PUSH
65553: LD_INT 30
65555: PUSH
65556: LD_INT 1
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: PUSH
65563: EMPTY
65564: LIST
65565: LIST
65566: LIST
65567: PPUSH
65568: CALL_OW 72
65572: PPUSH
65573: CALL_OW 256
65577: PUSH
65578: LD_INT 600
65580: LESS
65581: OR
65582: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
65583: LD_VAR 0 5
65587: PPUSH
65588: CALL_OW 247
65592: PUSH
65593: LD_INT 2
65595: DOUBLE
65596: EQUAL
65597: IFTRUE 65601
65599: GO 65848
65601: POP
// begin if GetLives ( i ) > 650 and GetDistUnits ( i , e ) < 40 then
65602: LD_VAR 0 5
65606: PPUSH
65607: CALL_OW 256
65611: PUSH
65612: LD_INT 650
65614: GREATER
65615: PUSH
65616: LD_VAR 0 5
65620: PPUSH
65621: LD_VAR 0 13
65625: PPUSH
65626: CALL_OW 296
65630: PUSH
65631: LD_INT 40
65633: LESS
65634: AND
65635: IFFALSE 65653
// ComAttackUnit ( i , e ) else
65637: LD_VAR 0 5
65641: PPUSH
65642: LD_VAR 0 13
65646: PPUSH
65647: CALL_OW 115
65651: GO 65731
// if ( GetDistUnits ( i , e ) >= 30 or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
65653: LD_VAR 0 5
65657: PPUSH
65658: LD_VAR 0 13
65662: PPUSH
65663: CALL_OW 296
65667: PUSH
65668: LD_INT 30
65670: GREATEREQUAL
65671: PUSH
65672: LD_VAR 0 5
65676: PPUSH
65677: CALL_OW 256
65681: PUSH
65682: LD_INT 650
65684: LESSEQUAL
65685: OR
65686: PUSH
65687: LD_VAR 0 5
65691: PPUSH
65692: LD_EXP 123
65696: PUSH
65697: LD_VAR 0 1
65701: ARRAY
65702: PPUSH
65703: CALL_OW 308
65707: NOT
65708: AND
65709: IFFALSE 65731
// ComMoveToArea ( i , mc_parking [ base ] ) ;
65711: LD_VAR 0 5
65715: PPUSH
65716: LD_EXP 123
65720: PUSH
65721: LD_VAR 0 1
65725: ARRAY
65726: PPUSH
65727: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
65731: LD_VAR 0 5
65735: PPUSH
65736: CALL_OW 256
65740: PUSH
65741: LD_INT 998
65743: LESS
65744: PUSH
65745: LD_VAR 0 5
65749: PPUSH
65750: CALL_OW 263
65754: PUSH
65755: LD_INT 1
65757: EQUAL
65758: AND
65759: PUSH
65760: LD_VAR 0 5
65764: PPUSH
65765: CALL_OW 311
65769: AND
65770: PUSH
65771: LD_VAR 0 5
65775: PPUSH
65776: LD_EXP 123
65780: PUSH
65781: LD_VAR 0 1
65785: ARRAY
65786: PPUSH
65787: CALL_OW 308
65791: AND
65792: IFFALSE 65846
// begin mech := IsDrivenBy ( i ) ;
65794: LD_ADDR_VAR 0 9
65798: PUSH
65799: LD_VAR 0 5
65803: PPUSH
65804: CALL_OW 311
65808: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
65809: LD_VAR 0 9
65813: PPUSH
65814: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
65818: LD_VAR 0 9
65822: PPUSH
65823: LD_VAR 0 5
65827: PPUSH
65828: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
65832: LD_VAR 0 9
65836: PPUSH
65837: LD_VAR 0 5
65841: PPUSH
65842: CALL_OW 180
// end ; end ; unit_human :
65846: GO 66113
65848: LD_INT 1
65850: DOUBLE
65851: EQUAL
65852: IFTRUE 65856
65854: GO 66112
65856: POP
// begin b := IsInUnit ( i ) ;
65857: LD_ADDR_VAR 0 18
65861: PUSH
65862: LD_VAR 0 5
65866: PPUSH
65867: CALL_OW 310
65871: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
65872: LD_ADDR_VAR 0 19
65876: PUSH
65877: LD_VAR 0 18
65881: NOT
65882: PUSH
65883: LD_VAR 0 18
65887: PPUSH
65888: CALL_OW 266
65892: PUSH
65893: LD_INT 32
65895: PUSH
65896: LD_INT 31
65898: PUSH
65899: EMPTY
65900: LIST
65901: LIST
65902: IN
65903: OR
65904: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
65905: LD_VAR 0 16
65909: PUSH
65910: LD_VAR 0 2
65914: PPUSH
65915: LD_INT 21
65917: PUSH
65918: LD_INT 2
65920: PUSH
65921: EMPTY
65922: LIST
65923: LIST
65924: PPUSH
65925: CALL_OW 72
65929: PUSH
65930: LD_INT 1
65932: LESSEQUAL
65933: OR
65934: PUSH
65935: LD_VAR 0 19
65939: AND
65940: PUSH
65941: LD_VAR 0 5
65945: PUSH
65946: LD_VAR 0 17
65950: IN
65951: NOT
65952: AND
65953: IFFALSE 66046
// begin if b then
65955: LD_VAR 0 18
65959: IFFALSE 66008
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
65961: LD_VAR 0 18
65965: PPUSH
65966: LD_VAR 0 3
65970: PPUSH
65971: LD_VAR 0 18
65975: PPUSH
65976: CALL_OW 74
65980: PPUSH
65981: CALL_OW 296
65985: PUSH
65986: LD_INT 10
65988: LESS
65989: PUSH
65990: LD_VAR 0 18
65994: PPUSH
65995: CALL_OW 461
65999: PUSH
66000: LD_INT 7
66002: NONEQUAL
66003: AND
66004: IFFALSE 66008
// continue ;
66006: GO 65456
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
66008: LD_ADDR_VAR 0 17
66012: PUSH
66013: LD_VAR 0 17
66017: PPUSH
66018: LD_VAR 0 17
66022: PUSH
66023: LD_INT 1
66025: PLUS
66026: PPUSH
66027: LD_VAR 0 5
66031: PPUSH
66032: CALL_OW 1
66036: ST_TO_ADDR
// ComExitBuilding ( i ) ;
66037: LD_VAR 0 5
66041: PPUSH
66042: CALL_OW 122
// end ; if sold_defenders then
66046: LD_VAR 0 17
66050: IFFALSE 66110
// if i in sold_defenders then
66052: LD_VAR 0 5
66056: PUSH
66057: LD_VAR 0 17
66061: IN
66062: IFFALSE 66110
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
66064: LD_VAR 0 5
66068: PPUSH
66069: CALL_OW 314
66073: NOT
66074: PUSH
66075: LD_VAR 0 5
66079: PPUSH
66080: LD_VAR 0 13
66084: PPUSH
66085: CALL_OW 296
66089: PUSH
66090: LD_INT 30
66092: LESS
66093: AND
66094: IFFALSE 66110
// ComAttackUnit ( i , e ) ;
66096: LD_VAR 0 5
66100: PPUSH
66101: LD_VAR 0 13
66105: PPUSH
66106: CALL_OW 115
// end ; end ; end ;
66110: GO 66113
66112: POP
// if IsDead ( i ) then
66113: LD_VAR 0 5
66117: PPUSH
66118: CALL_OW 301
66122: IFFALSE 66140
// defenders := defenders diff i ;
66124: LD_ADDR_VAR 0 2
66128: PUSH
66129: LD_VAR 0 2
66133: PUSH
66134: LD_VAR 0 5
66138: DIFF
66139: ST_TO_ADDR
// end ;
66140: GO 65456
66142: POP
66143: POP
// until not enemy or not defenders ;
66144: LD_VAR 0 3
66148: NOT
66149: PUSH
66150: LD_VAR 0 2
66154: NOT
66155: OR
66156: IFFALSE 65423
// MC_Reset ( base , 18 ) ;
66158: LD_VAR 0 1
66162: PPUSH
66163: LD_INT 18
66165: PPUSH
66166: CALL 37779 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66170: LD_ADDR_VAR 0 2
66174: PUSH
66175: LD_VAR 0 2
66179: PUSH
66180: LD_VAR 0 2
66184: PPUSH
66185: LD_INT 2
66187: PUSH
66188: LD_INT 25
66190: PUSH
66191: LD_INT 1
66193: PUSH
66194: EMPTY
66195: LIST
66196: LIST
66197: PUSH
66198: LD_INT 25
66200: PUSH
66201: LD_INT 5
66203: PUSH
66204: EMPTY
66205: LIST
66206: LIST
66207: PUSH
66208: LD_INT 25
66210: PUSH
66211: LD_INT 8
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: PUSH
66218: LD_INT 25
66220: PUSH
66221: LD_INT 9
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: EMPTY
66229: LIST
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: PPUSH
66235: CALL_OW 72
66239: DIFF
66240: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
66241: LD_VAR 0 3
66245: NOT
66246: PUSH
66247: LD_VAR 0 2
66251: PPUSH
66252: LD_INT 21
66254: PUSH
66255: LD_INT 2
66257: PUSH
66258: EMPTY
66259: LIST
66260: LIST
66261: PPUSH
66262: CALL_OW 72
66266: AND
66267: IFFALSE 66529
// begin tmp := FilterByTag ( defenders , 19 ) ;
66269: LD_ADDR_VAR 0 11
66273: PUSH
66274: LD_VAR 0 2
66278: PPUSH
66279: LD_INT 19
66281: PPUSH
66282: CALL 102909 0 2
66286: ST_TO_ADDR
// if tmp then
66287: LD_VAR 0 11
66291: IFFALSE 66361
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
66293: LD_ADDR_VAR 0 11
66297: PUSH
66298: LD_VAR 0 11
66302: PPUSH
66303: LD_INT 25
66305: PUSH
66306: LD_INT 3
66308: PUSH
66309: EMPTY
66310: LIST
66311: LIST
66312: PPUSH
66313: CALL_OW 72
66317: ST_TO_ADDR
// if tmp then
66318: LD_VAR 0 11
66322: IFFALSE 66361
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
66324: LD_ADDR_EXP 111
66328: PUSH
66329: LD_EXP 111
66333: PPUSH
66334: LD_VAR 0 1
66338: PPUSH
66339: LD_EXP 111
66343: PUSH
66344: LD_VAR 0 1
66348: ARRAY
66349: PUSH
66350: LD_VAR 0 11
66354: UNION
66355: PPUSH
66356: CALL_OW 1
66360: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
66361: LD_VAR 0 1
66365: PPUSH
66366: LD_INT 19
66368: PPUSH
66369: CALL 37779 0 2
// repeat wait ( 0 0$1 ) ;
66373: LD_INT 35
66375: PPUSH
66376: CALL_OW 67
// for i in defenders do
66380: LD_ADDR_VAR 0 5
66384: PUSH
66385: LD_VAR 0 2
66389: PUSH
66390: FOR_IN
66391: IFFALSE 66480
// begin if not IsInArea ( i , mc_parking [ base ] ) then
66393: LD_VAR 0 5
66397: PPUSH
66398: LD_EXP 123
66402: PUSH
66403: LD_VAR 0 1
66407: ARRAY
66408: PPUSH
66409: CALL_OW 308
66413: NOT
66414: IFFALSE 66438
// ComMoveToArea ( i , mc_parking [ base ] ) else
66416: LD_VAR 0 5
66420: PPUSH
66421: LD_EXP 123
66425: PUSH
66426: LD_VAR 0 1
66430: ARRAY
66431: PPUSH
66432: CALL_OW 113
66436: GO 66478
// if GetControl ( i ) = control_manual then
66438: LD_VAR 0 5
66442: PPUSH
66443: CALL_OW 263
66447: PUSH
66448: LD_INT 1
66450: EQUAL
66451: IFFALSE 66478
// if IsDrivenBy ( i ) then
66453: LD_VAR 0 5
66457: PPUSH
66458: CALL_OW 311
66462: IFFALSE 66478
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
66464: LD_VAR 0 5
66468: PPUSH
66469: CALL_OW 311
66473: PPUSH
66474: CALL_OW 121
// end ;
66478: GO 66390
66480: POP
66481: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] ;
66482: LD_VAR 0 2
66486: PPUSH
66487: LD_INT 95
66489: PUSH
66490: LD_EXP 123
66494: PUSH
66495: LD_VAR 0 1
66499: ARRAY
66500: PUSH
66501: EMPTY
66502: LIST
66503: LIST
66504: PPUSH
66505: CALL_OW 72
66509: PUSH
66510: LD_VAR 0 2
66514: EQUAL
66515: PUSH
66516: LD_EXP 122
66520: PUSH
66521: LD_VAR 0 1
66525: ARRAY
66526: OR
66527: IFFALSE 66373
// end ; MC_Reset ( base , 20 ) ;
66529: LD_VAR 0 1
66533: PPUSH
66534: LD_INT 20
66536: PPUSH
66537: CALL 37779 0 2
// end ;
66541: LD_VAR 0 4
66545: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
66546: LD_INT 0
66548: PPUSH
66549: PPUSH
66550: PPUSH
66551: PPUSH
// result := false ;
66552: LD_ADDR_VAR 0 2
66556: PUSH
66557: LD_INT 0
66559: ST_TO_ADDR
// side := GetSide ( unit ) ;
66560: LD_ADDR_VAR 0 3
66564: PUSH
66565: LD_VAR 0 1
66569: PPUSH
66570: CALL_OW 255
66574: ST_TO_ADDR
// nat := GetNation ( unit ) ;
66575: LD_ADDR_VAR 0 4
66579: PUSH
66580: LD_VAR 0 1
66584: PPUSH
66585: CALL_OW 248
66589: ST_TO_ADDR
// case nat of 1 :
66590: LD_VAR 0 4
66594: PUSH
66595: LD_INT 1
66597: DOUBLE
66598: EQUAL
66599: IFTRUE 66603
66601: GO 66614
66603: POP
// tech := tech_lassight ; 2 :
66604: LD_ADDR_VAR 0 5
66608: PUSH
66609: LD_INT 12
66611: ST_TO_ADDR
66612: GO 66653
66614: LD_INT 2
66616: DOUBLE
66617: EQUAL
66618: IFTRUE 66622
66620: GO 66633
66622: POP
// tech := tech_mortar ; 3 :
66623: LD_ADDR_VAR 0 5
66627: PUSH
66628: LD_INT 41
66630: ST_TO_ADDR
66631: GO 66653
66633: LD_INT 3
66635: DOUBLE
66636: EQUAL
66637: IFTRUE 66641
66639: GO 66652
66641: POP
// tech := tech_bazooka ; end ;
66642: LD_ADDR_VAR 0 5
66646: PUSH
66647: LD_INT 44
66649: ST_TO_ADDR
66650: GO 66653
66652: POP
// if Researched ( side , tech ) then
66653: LD_VAR 0 3
66657: PPUSH
66658: LD_VAR 0 5
66662: PPUSH
66663: CALL_OW 325
66667: IFFALSE 66694
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
66669: LD_ADDR_VAR 0 2
66673: PUSH
66674: LD_INT 5
66676: PUSH
66677: LD_INT 8
66679: PUSH
66680: LD_INT 9
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: LIST
66687: PUSH
66688: LD_VAR 0 4
66692: ARRAY
66693: ST_TO_ADDR
// end ;
66694: LD_VAR 0 2
66698: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
66699: LD_INT 0
66701: PPUSH
66702: PPUSH
66703: PPUSH
// if not mines then
66704: LD_VAR 0 2
66708: NOT
66709: IFFALSE 66713
// exit ;
66711: GO 66857
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66713: LD_ADDR_VAR 0 5
66717: PUSH
66718: LD_INT 81
66720: PUSH
66721: LD_VAR 0 1
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: LD_INT 3
66732: PUSH
66733: LD_INT 21
66735: PUSH
66736: LD_INT 3
66738: PUSH
66739: EMPTY
66740: LIST
66741: LIST
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PUSH
66747: EMPTY
66748: LIST
66749: LIST
66750: PPUSH
66751: CALL_OW 69
66755: ST_TO_ADDR
// for i in mines do
66756: LD_ADDR_VAR 0 4
66760: PUSH
66761: LD_VAR 0 2
66765: PUSH
66766: FOR_IN
66767: IFFALSE 66855
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
66769: LD_VAR 0 4
66773: PUSH
66774: LD_INT 1
66776: ARRAY
66777: PPUSH
66778: LD_VAR 0 4
66782: PUSH
66783: LD_INT 2
66785: ARRAY
66786: PPUSH
66787: CALL_OW 458
66791: NOT
66792: IFFALSE 66796
// continue ;
66794: GO 66766
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
66796: LD_VAR 0 4
66800: PUSH
66801: LD_INT 1
66803: ARRAY
66804: PPUSH
66805: LD_VAR 0 4
66809: PUSH
66810: LD_INT 2
66812: ARRAY
66813: PPUSH
66814: CALL_OW 428
66818: PUSH
66819: LD_VAR 0 5
66823: IN
66824: IFFALSE 66853
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
66826: LD_VAR 0 4
66830: PUSH
66831: LD_INT 1
66833: ARRAY
66834: PPUSH
66835: LD_VAR 0 4
66839: PUSH
66840: LD_INT 2
66842: ARRAY
66843: PPUSH
66844: LD_VAR 0 1
66848: PPUSH
66849: CALL_OW 456
// end ;
66853: GO 66766
66855: POP
66856: POP
// end ;
66857: LD_VAR 0 3
66861: RET
// export function Count ( array ) ; var i ; begin
66862: LD_INT 0
66864: PPUSH
66865: PPUSH
// result := 0 ;
66866: LD_ADDR_VAR 0 2
66870: PUSH
66871: LD_INT 0
66873: ST_TO_ADDR
// for i in array do
66874: LD_ADDR_VAR 0 3
66878: PUSH
66879: LD_VAR 0 1
66883: PUSH
66884: FOR_IN
66885: IFFALSE 66909
// if i then
66887: LD_VAR 0 3
66891: IFFALSE 66907
// result := result + 1 ;
66893: LD_ADDR_VAR 0 2
66897: PUSH
66898: LD_VAR 0 2
66902: PUSH
66903: LD_INT 1
66905: PLUS
66906: ST_TO_ADDR
66907: GO 66884
66909: POP
66910: POP
// end ;
66911: LD_VAR 0 2
66915: RET
// export function IsEmpty ( building ) ; begin
66916: LD_INT 0
66918: PPUSH
// if not building then
66919: LD_VAR 0 1
66923: NOT
66924: IFFALSE 66928
// exit ;
66926: GO 66971
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
66928: LD_ADDR_VAR 0 2
66932: PUSH
66933: LD_VAR 0 1
66937: PUSH
66938: LD_INT 22
66940: PUSH
66941: LD_VAR 0 1
66945: PPUSH
66946: CALL_OW 255
66950: PUSH
66951: EMPTY
66952: LIST
66953: LIST
66954: PUSH
66955: LD_INT 58
66957: PUSH
66958: EMPTY
66959: LIST
66960: PUSH
66961: EMPTY
66962: LIST
66963: LIST
66964: PPUSH
66965: CALL_OW 69
66969: IN
66970: ST_TO_ADDR
// end ;
66971: LD_VAR 0 2
66975: RET
// export function IsNotFull ( building ) ; begin
66976: LD_INT 0
66978: PPUSH
// if not building then
66979: LD_VAR 0 1
66983: NOT
66984: IFFALSE 66988
// exit ;
66986: GO 67007
// result := UnitsInside ( building ) < 6 ;
66988: LD_ADDR_VAR 0 2
66992: PUSH
66993: LD_VAR 0 1
66997: PPUSH
66998: CALL_OW 313
67002: PUSH
67003: LD_INT 6
67005: LESS
67006: ST_TO_ADDR
// end ;
67007: LD_VAR 0 2
67011: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
67012: LD_INT 0
67014: PPUSH
67015: PPUSH
67016: PPUSH
67017: PPUSH
// tmp := [ ] ;
67018: LD_ADDR_VAR 0 3
67022: PUSH
67023: EMPTY
67024: ST_TO_ADDR
// list := [ ] ;
67025: LD_ADDR_VAR 0 5
67029: PUSH
67030: EMPTY
67031: ST_TO_ADDR
// for i = 16 to 25 do
67032: LD_ADDR_VAR 0 4
67036: PUSH
67037: DOUBLE
67038: LD_INT 16
67040: DEC
67041: ST_TO_ADDR
67042: LD_INT 25
67044: PUSH
67045: FOR_TO
67046: IFFALSE 67119
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
67048: LD_ADDR_VAR 0 3
67052: PUSH
67053: LD_VAR 0 3
67057: PUSH
67058: LD_INT 22
67060: PUSH
67061: LD_VAR 0 1
67065: PPUSH
67066: CALL_OW 255
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 91
67077: PUSH
67078: LD_VAR 0 1
67082: PUSH
67083: LD_INT 6
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 30
67093: PUSH
67094: LD_VAR 0 4
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: PUSH
67103: EMPTY
67104: LIST
67105: LIST
67106: LIST
67107: PUSH
67108: EMPTY
67109: LIST
67110: PPUSH
67111: CALL_OW 69
67115: ADD
67116: ST_TO_ADDR
67117: GO 67045
67119: POP
67120: POP
// for i = 1 to tmp do
67121: LD_ADDR_VAR 0 4
67125: PUSH
67126: DOUBLE
67127: LD_INT 1
67129: DEC
67130: ST_TO_ADDR
67131: LD_VAR 0 3
67135: PUSH
67136: FOR_TO
67137: IFFALSE 67225
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
67139: LD_ADDR_VAR 0 5
67143: PUSH
67144: LD_VAR 0 5
67148: PUSH
67149: LD_VAR 0 3
67153: PUSH
67154: LD_VAR 0 4
67158: ARRAY
67159: PPUSH
67160: CALL_OW 266
67164: PUSH
67165: LD_VAR 0 3
67169: PUSH
67170: LD_VAR 0 4
67174: ARRAY
67175: PPUSH
67176: CALL_OW 250
67180: PUSH
67181: LD_VAR 0 3
67185: PUSH
67186: LD_VAR 0 4
67190: ARRAY
67191: PPUSH
67192: CALL_OW 251
67196: PUSH
67197: LD_VAR 0 3
67201: PUSH
67202: LD_VAR 0 4
67206: ARRAY
67207: PPUSH
67208: CALL_OW 254
67212: PUSH
67213: EMPTY
67214: LIST
67215: LIST
67216: LIST
67217: LIST
67218: PUSH
67219: EMPTY
67220: LIST
67221: ADD
67222: ST_TO_ADDR
67223: GO 67136
67225: POP
67226: POP
// result := list ;
67227: LD_ADDR_VAR 0 2
67231: PUSH
67232: LD_VAR 0 5
67236: ST_TO_ADDR
// end ;
67237: LD_VAR 0 2
67241: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
67242: LD_INT 0
67244: PPUSH
67245: PPUSH
67246: PPUSH
67247: PPUSH
67248: PPUSH
67249: PPUSH
67250: PPUSH
// if not factory then
67251: LD_VAR 0 1
67255: NOT
67256: IFFALSE 67260
// exit ;
67258: GO 67792
// if control = control_apeman then
67260: LD_VAR 0 4
67264: PUSH
67265: LD_INT 5
67267: EQUAL
67268: IFFALSE 67377
// begin tmp := UnitsInside ( factory ) ;
67270: LD_ADDR_VAR 0 8
67274: PUSH
67275: LD_VAR 0 1
67279: PPUSH
67280: CALL_OW 313
67284: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
67285: LD_VAR 0 8
67289: PPUSH
67290: LD_INT 25
67292: PUSH
67293: LD_INT 12
67295: PUSH
67296: EMPTY
67297: LIST
67298: LIST
67299: PPUSH
67300: CALL_OW 72
67304: NOT
67305: IFFALSE 67315
// control := control_manual ;
67307: LD_ADDR_VAR 0 4
67311: PUSH
67312: LD_INT 1
67314: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
67315: LD_ADDR_VAR 0 8
67319: PUSH
67320: LD_VAR 0 1
67324: PPUSH
67325: CALL 67012 0 1
67329: ST_TO_ADDR
// if tmp then
67330: LD_VAR 0 8
67334: IFFALSE 67377
// begin for i in tmp do
67336: LD_ADDR_VAR 0 7
67340: PUSH
67341: LD_VAR 0 8
67345: PUSH
67346: FOR_IN
67347: IFFALSE 67375
// if i [ 1 ] = b_ext_radio then
67349: LD_VAR 0 7
67353: PUSH
67354: LD_INT 1
67356: ARRAY
67357: PUSH
67358: LD_INT 22
67360: EQUAL
67361: IFFALSE 67373
// begin control := control_remote ;
67363: LD_ADDR_VAR 0 4
67367: PUSH
67368: LD_INT 2
67370: ST_TO_ADDR
// break ;
67371: GO 67375
// end ;
67373: GO 67346
67375: POP
67376: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67377: LD_VAR 0 1
67381: PPUSH
67382: LD_VAR 0 2
67386: PPUSH
67387: LD_VAR 0 3
67391: PPUSH
67392: LD_VAR 0 4
67396: PPUSH
67397: LD_VAR 0 5
67401: PPUSH
67402: CALL_OW 448
67406: IFFALSE 67441
// begin result := [ chassis , engine , control , weapon ] ;
67408: LD_ADDR_VAR 0 6
67412: PUSH
67413: LD_VAR 0 2
67417: PUSH
67418: LD_VAR 0 3
67422: PUSH
67423: LD_VAR 0 4
67427: PUSH
67428: LD_VAR 0 5
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: LIST
67437: LIST
67438: ST_TO_ADDR
// exit ;
67439: GO 67792
// end ; _chassis := AvailableChassisList ( factory ) ;
67441: LD_ADDR_VAR 0 9
67445: PUSH
67446: LD_VAR 0 1
67450: PPUSH
67451: CALL_OW 475
67455: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
67456: LD_ADDR_VAR 0 11
67460: PUSH
67461: LD_VAR 0 1
67465: PPUSH
67466: CALL_OW 476
67470: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
67471: LD_ADDR_VAR 0 12
67475: PUSH
67476: LD_VAR 0 1
67480: PPUSH
67481: CALL_OW 477
67485: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
67486: LD_ADDR_VAR 0 10
67490: PUSH
67491: LD_VAR 0 1
67495: PPUSH
67496: CALL_OW 478
67500: ST_TO_ADDR
// if not chassis in _chassis then
67501: LD_VAR 0 2
67505: PUSH
67506: LD_VAR 0 9
67510: IN
67511: NOT
67512: IFFALSE 67538
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
67514: LD_ADDR_VAR 0 2
67518: PUSH
67519: LD_VAR 0 9
67523: PUSH
67524: LD_INT 1
67526: PPUSH
67527: LD_VAR 0 9
67531: PPUSH
67532: CALL_OW 12
67536: ARRAY
67537: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
67538: LD_VAR 0 2
67542: PPUSH
67543: LD_VAR 0 3
67547: PPUSH
67548: CALL 67797 0 2
67552: NOT
67553: IFFALSE 67612
// repeat engine := _engine [ 1 ] ;
67555: LD_ADDR_VAR 0 3
67559: PUSH
67560: LD_VAR 0 11
67564: PUSH
67565: LD_INT 1
67567: ARRAY
67568: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
67569: LD_ADDR_VAR 0 11
67573: PUSH
67574: LD_VAR 0 11
67578: PPUSH
67579: LD_INT 1
67581: PPUSH
67582: CALL_OW 3
67586: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
67587: LD_VAR 0 2
67591: PPUSH
67592: LD_VAR 0 3
67596: PPUSH
67597: CALL 67797 0 2
67601: PUSH
67602: LD_VAR 0 11
67606: PUSH
67607: EMPTY
67608: EQUAL
67609: OR
67610: IFFALSE 67555
// if not control in _control then
67612: LD_VAR 0 4
67616: PUSH
67617: LD_VAR 0 12
67621: IN
67622: NOT
67623: IFFALSE 67649
// control := _control [ rand ( 1 , _control ) ] ;
67625: LD_ADDR_VAR 0 4
67629: PUSH
67630: LD_VAR 0 12
67634: PUSH
67635: LD_INT 1
67637: PPUSH
67638: LD_VAR 0 12
67642: PPUSH
67643: CALL_OW 12
67647: ARRAY
67648: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
67649: LD_VAR 0 2
67653: PPUSH
67654: LD_VAR 0 5
67658: PPUSH
67659: CALL 68017 0 2
67663: NOT
67664: IFFALSE 67723
// repeat weapon := _weapon [ 1 ] ;
67666: LD_ADDR_VAR 0 5
67670: PUSH
67671: LD_VAR 0 10
67675: PUSH
67676: LD_INT 1
67678: ARRAY
67679: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
67680: LD_ADDR_VAR 0 10
67684: PUSH
67685: LD_VAR 0 10
67689: PPUSH
67690: LD_INT 1
67692: PPUSH
67693: CALL_OW 3
67697: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
67698: LD_VAR 0 2
67702: PPUSH
67703: LD_VAR 0 5
67707: PPUSH
67708: CALL 68017 0 2
67712: PUSH
67713: LD_VAR 0 10
67717: PUSH
67718: EMPTY
67719: EQUAL
67720: OR
67721: IFFALSE 67666
// result := [ ] ;
67723: LD_ADDR_VAR 0 6
67727: PUSH
67728: EMPTY
67729: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
67730: LD_VAR 0 1
67734: PPUSH
67735: LD_VAR 0 2
67739: PPUSH
67740: LD_VAR 0 3
67744: PPUSH
67745: LD_VAR 0 4
67749: PPUSH
67750: LD_VAR 0 5
67754: PPUSH
67755: CALL_OW 448
67759: IFFALSE 67792
// result := [ chassis , engine , control , weapon ] ;
67761: LD_ADDR_VAR 0 6
67765: PUSH
67766: LD_VAR 0 2
67770: PUSH
67771: LD_VAR 0 3
67775: PUSH
67776: LD_VAR 0 4
67780: PUSH
67781: LD_VAR 0 5
67785: PUSH
67786: EMPTY
67787: LIST
67788: LIST
67789: LIST
67790: LIST
67791: ST_TO_ADDR
// end ;
67792: LD_VAR 0 6
67796: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
67797: LD_INT 0
67799: PPUSH
// if not chassis or not engine then
67800: LD_VAR 0 1
67804: NOT
67805: PUSH
67806: LD_VAR 0 2
67810: NOT
67811: OR
67812: IFFALSE 67816
// exit ;
67814: GO 68012
// case engine of engine_solar :
67816: LD_VAR 0 2
67820: PUSH
67821: LD_INT 2
67823: DOUBLE
67824: EQUAL
67825: IFTRUE 67829
67827: GO 67867
67829: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
67830: LD_ADDR_VAR 0 3
67834: PUSH
67835: LD_INT 11
67837: PUSH
67838: LD_INT 12
67840: PUSH
67841: LD_INT 13
67843: PUSH
67844: LD_INT 14
67846: PUSH
67847: LD_INT 1
67849: PUSH
67850: LD_INT 2
67852: PUSH
67853: LD_INT 3
67855: PUSH
67856: EMPTY
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: LIST
67863: LIST
67864: ST_TO_ADDR
67865: GO 67996
67867: LD_INT 1
67869: DOUBLE
67870: EQUAL
67871: IFTRUE 67875
67873: GO 67937
67875: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
67876: LD_ADDR_VAR 0 3
67880: PUSH
67881: LD_INT 11
67883: PUSH
67884: LD_INT 12
67886: PUSH
67887: LD_INT 13
67889: PUSH
67890: LD_INT 14
67892: PUSH
67893: LD_INT 1
67895: PUSH
67896: LD_INT 2
67898: PUSH
67899: LD_INT 3
67901: PUSH
67902: LD_INT 4
67904: PUSH
67905: LD_INT 5
67907: PUSH
67908: LD_INT 21
67910: PUSH
67911: LD_INT 23
67913: PUSH
67914: LD_INT 22
67916: PUSH
67917: LD_INT 24
67919: PUSH
67920: EMPTY
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: ST_TO_ADDR
67935: GO 67996
67937: LD_INT 3
67939: DOUBLE
67940: EQUAL
67941: IFTRUE 67945
67943: GO 67995
67945: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
67946: LD_ADDR_VAR 0 3
67950: PUSH
67951: LD_INT 13
67953: PUSH
67954: LD_INT 14
67956: PUSH
67957: LD_INT 2
67959: PUSH
67960: LD_INT 3
67962: PUSH
67963: LD_INT 4
67965: PUSH
67966: LD_INT 5
67968: PUSH
67969: LD_INT 21
67971: PUSH
67972: LD_INT 22
67974: PUSH
67975: LD_INT 23
67977: PUSH
67978: LD_INT 24
67980: PUSH
67981: EMPTY
67982: LIST
67983: LIST
67984: LIST
67985: LIST
67986: LIST
67987: LIST
67988: LIST
67989: LIST
67990: LIST
67991: LIST
67992: ST_TO_ADDR
67993: GO 67996
67995: POP
// result := ( chassis in result ) ;
67996: LD_ADDR_VAR 0 3
68000: PUSH
68001: LD_VAR 0 1
68005: PUSH
68006: LD_VAR 0 3
68010: IN
68011: ST_TO_ADDR
// end ;
68012: LD_VAR 0 3
68016: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
68017: LD_INT 0
68019: PPUSH
// if not chassis or not weapon then
68020: LD_VAR 0 1
68024: NOT
68025: PUSH
68026: LD_VAR 0 2
68030: NOT
68031: OR
68032: IFFALSE 68036
// exit ;
68034: GO 69062
// case weapon of us_machine_gun :
68036: LD_VAR 0 2
68040: PUSH
68041: LD_INT 2
68043: DOUBLE
68044: EQUAL
68045: IFTRUE 68049
68047: GO 68079
68049: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
68050: LD_ADDR_VAR 0 3
68054: PUSH
68055: LD_INT 1
68057: PUSH
68058: LD_INT 2
68060: PUSH
68061: LD_INT 3
68063: PUSH
68064: LD_INT 4
68066: PUSH
68067: LD_INT 5
68069: PUSH
68070: EMPTY
68071: LIST
68072: LIST
68073: LIST
68074: LIST
68075: LIST
68076: ST_TO_ADDR
68077: GO 69046
68079: LD_INT 3
68081: DOUBLE
68082: EQUAL
68083: IFTRUE 68087
68085: GO 68117
68087: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
68088: LD_ADDR_VAR 0 3
68092: PUSH
68093: LD_INT 1
68095: PUSH
68096: LD_INT 2
68098: PUSH
68099: LD_INT 3
68101: PUSH
68102: LD_INT 4
68104: PUSH
68105: LD_INT 5
68107: PUSH
68108: EMPTY
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: ST_TO_ADDR
68115: GO 69046
68117: LD_INT 11
68119: DOUBLE
68120: EQUAL
68121: IFTRUE 68125
68123: GO 68155
68125: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
68126: LD_ADDR_VAR 0 3
68130: PUSH
68131: LD_INT 1
68133: PUSH
68134: LD_INT 2
68136: PUSH
68137: LD_INT 3
68139: PUSH
68140: LD_INT 4
68142: PUSH
68143: LD_INT 5
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: ST_TO_ADDR
68153: GO 69046
68155: LD_INT 4
68157: DOUBLE
68158: EQUAL
68159: IFTRUE 68163
68161: GO 68189
68163: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
68164: LD_ADDR_VAR 0 3
68168: PUSH
68169: LD_INT 2
68171: PUSH
68172: LD_INT 3
68174: PUSH
68175: LD_INT 4
68177: PUSH
68178: LD_INT 5
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: LIST
68185: LIST
68186: ST_TO_ADDR
68187: GO 69046
68189: LD_INT 5
68191: DOUBLE
68192: EQUAL
68193: IFTRUE 68197
68195: GO 68223
68197: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
68198: LD_ADDR_VAR 0 3
68202: PUSH
68203: LD_INT 2
68205: PUSH
68206: LD_INT 3
68208: PUSH
68209: LD_INT 4
68211: PUSH
68212: LD_INT 5
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: LIST
68219: LIST
68220: ST_TO_ADDR
68221: GO 69046
68223: LD_INT 9
68225: DOUBLE
68226: EQUAL
68227: IFTRUE 68231
68229: GO 68257
68231: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
68232: LD_ADDR_VAR 0 3
68236: PUSH
68237: LD_INT 2
68239: PUSH
68240: LD_INT 3
68242: PUSH
68243: LD_INT 4
68245: PUSH
68246: LD_INT 5
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: LIST
68253: LIST
68254: ST_TO_ADDR
68255: GO 69046
68257: LD_INT 7
68259: DOUBLE
68260: EQUAL
68261: IFTRUE 68265
68263: GO 68291
68265: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
68266: LD_ADDR_VAR 0 3
68270: PUSH
68271: LD_INT 2
68273: PUSH
68274: LD_INT 3
68276: PUSH
68277: LD_INT 4
68279: PUSH
68280: LD_INT 5
68282: PUSH
68283: EMPTY
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: ST_TO_ADDR
68289: GO 69046
68291: LD_INT 12
68293: DOUBLE
68294: EQUAL
68295: IFTRUE 68299
68297: GO 68325
68299: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
68300: LD_ADDR_VAR 0 3
68304: PUSH
68305: LD_INT 2
68307: PUSH
68308: LD_INT 3
68310: PUSH
68311: LD_INT 4
68313: PUSH
68314: LD_INT 5
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: ST_TO_ADDR
68323: GO 69046
68325: LD_INT 13
68327: DOUBLE
68328: EQUAL
68329: IFTRUE 68333
68331: GO 68359
68333: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
68334: LD_ADDR_VAR 0 3
68338: PUSH
68339: LD_INT 2
68341: PUSH
68342: LD_INT 3
68344: PUSH
68345: LD_INT 4
68347: PUSH
68348: LD_INT 5
68350: PUSH
68351: EMPTY
68352: LIST
68353: LIST
68354: LIST
68355: LIST
68356: ST_TO_ADDR
68357: GO 69046
68359: LD_INT 14
68361: DOUBLE
68362: EQUAL
68363: IFTRUE 68367
68365: GO 68385
68367: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
68368: LD_ADDR_VAR 0 3
68372: PUSH
68373: LD_INT 4
68375: PUSH
68376: LD_INT 5
68378: PUSH
68379: EMPTY
68380: LIST
68381: LIST
68382: ST_TO_ADDR
68383: GO 69046
68385: LD_INT 6
68387: DOUBLE
68388: EQUAL
68389: IFTRUE 68393
68391: GO 68411
68393: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
68394: LD_ADDR_VAR 0 3
68398: PUSH
68399: LD_INT 4
68401: PUSH
68402: LD_INT 5
68404: PUSH
68405: EMPTY
68406: LIST
68407: LIST
68408: ST_TO_ADDR
68409: GO 69046
68411: LD_INT 10
68413: DOUBLE
68414: EQUAL
68415: IFTRUE 68419
68417: GO 68437
68419: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
68420: LD_ADDR_VAR 0 3
68424: PUSH
68425: LD_INT 4
68427: PUSH
68428: LD_INT 5
68430: PUSH
68431: EMPTY
68432: LIST
68433: LIST
68434: ST_TO_ADDR
68435: GO 69046
68437: LD_INT 22
68439: DOUBLE
68440: EQUAL
68441: IFTRUE 68445
68443: GO 68471
68445: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
68446: LD_ADDR_VAR 0 3
68450: PUSH
68451: LD_INT 11
68453: PUSH
68454: LD_INT 12
68456: PUSH
68457: LD_INT 13
68459: PUSH
68460: LD_INT 14
68462: PUSH
68463: EMPTY
68464: LIST
68465: LIST
68466: LIST
68467: LIST
68468: ST_TO_ADDR
68469: GO 69046
68471: LD_INT 23
68473: DOUBLE
68474: EQUAL
68475: IFTRUE 68479
68477: GO 68505
68479: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
68480: LD_ADDR_VAR 0 3
68484: PUSH
68485: LD_INT 11
68487: PUSH
68488: LD_INT 12
68490: PUSH
68491: LD_INT 13
68493: PUSH
68494: LD_INT 14
68496: PUSH
68497: EMPTY
68498: LIST
68499: LIST
68500: LIST
68501: LIST
68502: ST_TO_ADDR
68503: GO 69046
68505: LD_INT 24
68507: DOUBLE
68508: EQUAL
68509: IFTRUE 68513
68511: GO 68539
68513: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
68514: LD_ADDR_VAR 0 3
68518: PUSH
68519: LD_INT 11
68521: PUSH
68522: LD_INT 12
68524: PUSH
68525: LD_INT 13
68527: PUSH
68528: LD_INT 14
68530: PUSH
68531: EMPTY
68532: LIST
68533: LIST
68534: LIST
68535: LIST
68536: ST_TO_ADDR
68537: GO 69046
68539: LD_INT 30
68541: DOUBLE
68542: EQUAL
68543: IFTRUE 68547
68545: GO 68573
68547: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
68548: LD_ADDR_VAR 0 3
68552: PUSH
68553: LD_INT 11
68555: PUSH
68556: LD_INT 12
68558: PUSH
68559: LD_INT 13
68561: PUSH
68562: LD_INT 14
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: LIST
68569: LIST
68570: ST_TO_ADDR
68571: GO 69046
68573: LD_INT 25
68575: DOUBLE
68576: EQUAL
68577: IFTRUE 68581
68579: GO 68599
68581: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
68582: LD_ADDR_VAR 0 3
68586: PUSH
68587: LD_INT 13
68589: PUSH
68590: LD_INT 14
68592: PUSH
68593: EMPTY
68594: LIST
68595: LIST
68596: ST_TO_ADDR
68597: GO 69046
68599: LD_INT 27
68601: DOUBLE
68602: EQUAL
68603: IFTRUE 68607
68605: GO 68625
68607: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
68608: LD_ADDR_VAR 0 3
68612: PUSH
68613: LD_INT 13
68615: PUSH
68616: LD_INT 14
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: ST_TO_ADDR
68623: GO 69046
68625: LD_INT 28
68627: DOUBLE
68628: EQUAL
68629: IFTRUE 68633
68631: GO 68651
68633: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
68634: LD_ADDR_VAR 0 3
68638: PUSH
68639: LD_INT 13
68641: PUSH
68642: LD_INT 14
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: ST_TO_ADDR
68649: GO 69046
68651: LD_INT 29
68653: DOUBLE
68654: EQUAL
68655: IFTRUE 68659
68657: GO 68677
68659: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
68660: LD_ADDR_VAR 0 3
68664: PUSH
68665: LD_INT 13
68667: PUSH
68668: LD_INT 14
68670: PUSH
68671: EMPTY
68672: LIST
68673: LIST
68674: ST_TO_ADDR
68675: GO 69046
68677: LD_INT 31
68679: DOUBLE
68680: EQUAL
68681: IFTRUE 68685
68683: GO 68703
68685: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
68686: LD_ADDR_VAR 0 3
68690: PUSH
68691: LD_INT 13
68693: PUSH
68694: LD_INT 14
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: ST_TO_ADDR
68701: GO 69046
68703: LD_INT 26
68705: DOUBLE
68706: EQUAL
68707: IFTRUE 68711
68709: GO 68729
68711: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
68712: LD_ADDR_VAR 0 3
68716: PUSH
68717: LD_INT 13
68719: PUSH
68720: LD_INT 14
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: ST_TO_ADDR
68727: GO 69046
68729: LD_INT 42
68731: DOUBLE
68732: EQUAL
68733: IFTRUE 68737
68735: GO 68763
68737: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
68738: LD_ADDR_VAR 0 3
68742: PUSH
68743: LD_INT 21
68745: PUSH
68746: LD_INT 22
68748: PUSH
68749: LD_INT 23
68751: PUSH
68752: LD_INT 24
68754: PUSH
68755: EMPTY
68756: LIST
68757: LIST
68758: LIST
68759: LIST
68760: ST_TO_ADDR
68761: GO 69046
68763: LD_INT 43
68765: DOUBLE
68766: EQUAL
68767: IFTRUE 68771
68769: GO 68797
68771: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
68772: LD_ADDR_VAR 0 3
68776: PUSH
68777: LD_INT 21
68779: PUSH
68780: LD_INT 22
68782: PUSH
68783: LD_INT 23
68785: PUSH
68786: LD_INT 24
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: LIST
68793: LIST
68794: ST_TO_ADDR
68795: GO 69046
68797: LD_INT 44
68799: DOUBLE
68800: EQUAL
68801: IFTRUE 68805
68803: GO 68831
68805: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
68806: LD_ADDR_VAR 0 3
68810: PUSH
68811: LD_INT 21
68813: PUSH
68814: LD_INT 22
68816: PUSH
68817: LD_INT 23
68819: PUSH
68820: LD_INT 24
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: LIST
68827: LIST
68828: ST_TO_ADDR
68829: GO 69046
68831: LD_INT 45
68833: DOUBLE
68834: EQUAL
68835: IFTRUE 68839
68837: GO 68865
68839: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
68840: LD_ADDR_VAR 0 3
68844: PUSH
68845: LD_INT 21
68847: PUSH
68848: LD_INT 22
68850: PUSH
68851: LD_INT 23
68853: PUSH
68854: LD_INT 24
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: LIST
68861: LIST
68862: ST_TO_ADDR
68863: GO 69046
68865: LD_INT 49
68867: DOUBLE
68868: EQUAL
68869: IFTRUE 68873
68871: GO 68899
68873: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
68874: LD_ADDR_VAR 0 3
68878: PUSH
68879: LD_INT 21
68881: PUSH
68882: LD_INT 22
68884: PUSH
68885: LD_INT 23
68887: PUSH
68888: LD_INT 24
68890: PUSH
68891: EMPTY
68892: LIST
68893: LIST
68894: LIST
68895: LIST
68896: ST_TO_ADDR
68897: GO 69046
68899: LD_INT 51
68901: DOUBLE
68902: EQUAL
68903: IFTRUE 68907
68905: GO 68933
68907: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
68908: LD_ADDR_VAR 0 3
68912: PUSH
68913: LD_INT 21
68915: PUSH
68916: LD_INT 22
68918: PUSH
68919: LD_INT 23
68921: PUSH
68922: LD_INT 24
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: LIST
68929: LIST
68930: ST_TO_ADDR
68931: GO 69046
68933: LD_INT 52
68935: DOUBLE
68936: EQUAL
68937: IFTRUE 68941
68939: GO 68967
68941: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
68942: LD_ADDR_VAR 0 3
68946: PUSH
68947: LD_INT 21
68949: PUSH
68950: LD_INT 22
68952: PUSH
68953: LD_INT 23
68955: PUSH
68956: LD_INT 24
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: ST_TO_ADDR
68965: GO 69046
68967: LD_INT 53
68969: DOUBLE
68970: EQUAL
68971: IFTRUE 68975
68973: GO 68993
68975: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
68976: LD_ADDR_VAR 0 3
68980: PUSH
68981: LD_INT 23
68983: PUSH
68984: LD_INT 24
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: ST_TO_ADDR
68991: GO 69046
68993: LD_INT 46
68995: DOUBLE
68996: EQUAL
68997: IFTRUE 69001
68999: GO 69019
69001: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
69002: LD_ADDR_VAR 0 3
69006: PUSH
69007: LD_INT 23
69009: PUSH
69010: LD_INT 24
69012: PUSH
69013: EMPTY
69014: LIST
69015: LIST
69016: ST_TO_ADDR
69017: GO 69046
69019: LD_INT 47
69021: DOUBLE
69022: EQUAL
69023: IFTRUE 69027
69025: GO 69045
69027: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69028: LD_ADDR_VAR 0 3
69032: PUSH
69033: LD_INT 23
69035: PUSH
69036: LD_INT 24
69038: PUSH
69039: EMPTY
69040: LIST
69041: LIST
69042: ST_TO_ADDR
69043: GO 69046
69045: POP
// result := ( chassis in result ) ;
69046: LD_ADDR_VAR 0 3
69050: PUSH
69051: LD_VAR 0 1
69055: PUSH
69056: LD_VAR 0 3
69060: IN
69061: ST_TO_ADDR
// end ;
69062: LD_VAR 0 3
69066: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
69067: LD_INT 0
69069: PPUSH
69070: PPUSH
69071: PPUSH
69072: PPUSH
69073: PPUSH
69074: PPUSH
69075: PPUSH
// result := array ;
69076: LD_ADDR_VAR 0 5
69080: PUSH
69081: LD_VAR 0 1
69085: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
69086: LD_VAR 0 1
69090: NOT
69091: PUSH
69092: LD_VAR 0 2
69096: NOT
69097: OR
69098: PUSH
69099: LD_VAR 0 3
69103: NOT
69104: OR
69105: PUSH
69106: LD_VAR 0 2
69110: PUSH
69111: LD_VAR 0 1
69115: GREATER
69116: OR
69117: PUSH
69118: LD_VAR 0 3
69122: PUSH
69123: LD_VAR 0 1
69127: GREATER
69128: OR
69129: IFFALSE 69133
// exit ;
69131: GO 69429
// if direction then
69133: LD_VAR 0 4
69137: IFFALSE 69201
// begin d := 1 ;
69139: LD_ADDR_VAR 0 9
69143: PUSH
69144: LD_INT 1
69146: ST_TO_ADDR
// if i_from > i_to then
69147: LD_VAR 0 2
69151: PUSH
69152: LD_VAR 0 3
69156: GREATER
69157: IFFALSE 69183
// length := ( array - i_from ) + i_to else
69159: LD_ADDR_VAR 0 11
69163: PUSH
69164: LD_VAR 0 1
69168: PUSH
69169: LD_VAR 0 2
69173: MINUS
69174: PUSH
69175: LD_VAR 0 3
69179: PLUS
69180: ST_TO_ADDR
69181: GO 69199
// length := i_to - i_from ;
69183: LD_ADDR_VAR 0 11
69187: PUSH
69188: LD_VAR 0 3
69192: PUSH
69193: LD_VAR 0 2
69197: MINUS
69198: ST_TO_ADDR
// end else
69199: GO 69262
// begin d := - 1 ;
69201: LD_ADDR_VAR 0 9
69205: PUSH
69206: LD_INT 1
69208: NEG
69209: ST_TO_ADDR
// if i_from > i_to then
69210: LD_VAR 0 2
69214: PUSH
69215: LD_VAR 0 3
69219: GREATER
69220: IFFALSE 69240
// length := i_from - i_to else
69222: LD_ADDR_VAR 0 11
69226: PUSH
69227: LD_VAR 0 2
69231: PUSH
69232: LD_VAR 0 3
69236: MINUS
69237: ST_TO_ADDR
69238: GO 69262
// length := ( array - i_to ) + i_from ;
69240: LD_ADDR_VAR 0 11
69244: PUSH
69245: LD_VAR 0 1
69249: PUSH
69250: LD_VAR 0 3
69254: MINUS
69255: PUSH
69256: LD_VAR 0 2
69260: PLUS
69261: ST_TO_ADDR
// end ; if not length then
69262: LD_VAR 0 11
69266: NOT
69267: IFFALSE 69271
// exit ;
69269: GO 69429
// tmp := array ;
69271: LD_ADDR_VAR 0 10
69275: PUSH
69276: LD_VAR 0 1
69280: ST_TO_ADDR
// for i = 1 to length do
69281: LD_ADDR_VAR 0 6
69285: PUSH
69286: DOUBLE
69287: LD_INT 1
69289: DEC
69290: ST_TO_ADDR
69291: LD_VAR 0 11
69295: PUSH
69296: FOR_TO
69297: IFFALSE 69417
// begin for j = 1 to array do
69299: LD_ADDR_VAR 0 7
69303: PUSH
69304: DOUBLE
69305: LD_INT 1
69307: DEC
69308: ST_TO_ADDR
69309: LD_VAR 0 1
69313: PUSH
69314: FOR_TO
69315: IFFALSE 69403
// begin k := j + d ;
69317: LD_ADDR_VAR 0 8
69321: PUSH
69322: LD_VAR 0 7
69326: PUSH
69327: LD_VAR 0 9
69331: PLUS
69332: ST_TO_ADDR
// if k > array then
69333: LD_VAR 0 8
69337: PUSH
69338: LD_VAR 0 1
69342: GREATER
69343: IFFALSE 69353
// k := 1 ;
69345: LD_ADDR_VAR 0 8
69349: PUSH
69350: LD_INT 1
69352: ST_TO_ADDR
// if not k then
69353: LD_VAR 0 8
69357: NOT
69358: IFFALSE 69370
// k := array ;
69360: LD_ADDR_VAR 0 8
69364: PUSH
69365: LD_VAR 0 1
69369: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
69370: LD_ADDR_VAR 0 10
69374: PUSH
69375: LD_VAR 0 10
69379: PPUSH
69380: LD_VAR 0 8
69384: PPUSH
69385: LD_VAR 0 1
69389: PUSH
69390: LD_VAR 0 7
69394: ARRAY
69395: PPUSH
69396: CALL_OW 1
69400: ST_TO_ADDR
// end ;
69401: GO 69314
69403: POP
69404: POP
// array := tmp ;
69405: LD_ADDR_VAR 0 1
69409: PUSH
69410: LD_VAR 0 10
69414: ST_TO_ADDR
// end ;
69415: GO 69296
69417: POP
69418: POP
// result := array ;
69419: LD_ADDR_VAR 0 5
69423: PUSH
69424: LD_VAR 0 1
69428: ST_TO_ADDR
// end ;
69429: LD_VAR 0 5
69433: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
69434: LD_INT 0
69436: PPUSH
69437: PPUSH
// result := 0 ;
69438: LD_ADDR_VAR 0 3
69442: PUSH
69443: LD_INT 0
69445: ST_TO_ADDR
// if not array or not value in array then
69446: LD_VAR 0 1
69450: NOT
69451: PUSH
69452: LD_VAR 0 2
69456: PUSH
69457: LD_VAR 0 1
69461: IN
69462: NOT
69463: OR
69464: IFFALSE 69468
// exit ;
69466: GO 69522
// for i = 1 to array do
69468: LD_ADDR_VAR 0 4
69472: PUSH
69473: DOUBLE
69474: LD_INT 1
69476: DEC
69477: ST_TO_ADDR
69478: LD_VAR 0 1
69482: PUSH
69483: FOR_TO
69484: IFFALSE 69520
// if value = array [ i ] then
69486: LD_VAR 0 2
69490: PUSH
69491: LD_VAR 0 1
69495: PUSH
69496: LD_VAR 0 4
69500: ARRAY
69501: EQUAL
69502: IFFALSE 69518
// begin result := i ;
69504: LD_ADDR_VAR 0 3
69508: PUSH
69509: LD_VAR 0 4
69513: ST_TO_ADDR
// exit ;
69514: POP
69515: POP
69516: GO 69522
// end ;
69518: GO 69483
69520: POP
69521: POP
// end ;
69522: LD_VAR 0 3
69526: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
69527: LD_INT 0
69529: PPUSH
// vc_chassis := chassis ;
69530: LD_ADDR_OWVAR 37
69534: PUSH
69535: LD_VAR 0 1
69539: ST_TO_ADDR
// vc_engine := engine ;
69540: LD_ADDR_OWVAR 39
69544: PUSH
69545: LD_VAR 0 2
69549: ST_TO_ADDR
// vc_control := control ;
69550: LD_ADDR_OWVAR 38
69554: PUSH
69555: LD_VAR 0 3
69559: ST_TO_ADDR
// vc_weapon := weapon ;
69560: LD_ADDR_OWVAR 40
69564: PUSH
69565: LD_VAR 0 4
69569: ST_TO_ADDR
// vc_fuel_battery := fuel ;
69570: LD_ADDR_OWVAR 41
69574: PUSH
69575: LD_VAR 0 5
69579: ST_TO_ADDR
// end ;
69580: LD_VAR 0 6
69584: RET
// export function WantPlant ( unit ) ; var task ; begin
69585: LD_INT 0
69587: PPUSH
69588: PPUSH
// result := false ;
69589: LD_ADDR_VAR 0 2
69593: PUSH
69594: LD_INT 0
69596: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
69597: LD_ADDR_VAR 0 3
69601: PUSH
69602: LD_VAR 0 1
69606: PPUSH
69607: CALL_OW 437
69611: ST_TO_ADDR
// if task then
69612: LD_VAR 0 3
69616: IFFALSE 69644
// if task [ 1 ] [ 1 ] = p then
69618: LD_VAR 0 3
69622: PUSH
69623: LD_INT 1
69625: ARRAY
69626: PUSH
69627: LD_INT 1
69629: ARRAY
69630: PUSH
69631: LD_STRING p
69633: EQUAL
69634: IFFALSE 69644
// result := true ;
69636: LD_ADDR_VAR 0 2
69640: PUSH
69641: LD_INT 1
69643: ST_TO_ADDR
// end ;
69644: LD_VAR 0 2
69648: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
69649: LD_INT 0
69651: PPUSH
69652: PPUSH
69653: PPUSH
69654: PPUSH
// if pos < 1 then
69655: LD_VAR 0 2
69659: PUSH
69660: LD_INT 1
69662: LESS
69663: IFFALSE 69667
// exit ;
69665: GO 69970
// if pos = 1 then
69667: LD_VAR 0 2
69671: PUSH
69672: LD_INT 1
69674: EQUAL
69675: IFFALSE 69708
// result := Replace ( arr , pos [ 1 ] , value ) else
69677: LD_ADDR_VAR 0 4
69681: PUSH
69682: LD_VAR 0 1
69686: PPUSH
69687: LD_VAR 0 2
69691: PUSH
69692: LD_INT 1
69694: ARRAY
69695: PPUSH
69696: LD_VAR 0 3
69700: PPUSH
69701: CALL_OW 1
69705: ST_TO_ADDR
69706: GO 69970
// begin tmp := arr ;
69708: LD_ADDR_VAR 0 6
69712: PUSH
69713: LD_VAR 0 1
69717: ST_TO_ADDR
// s_arr := [ tmp ] ;
69718: LD_ADDR_VAR 0 7
69722: PUSH
69723: LD_VAR 0 6
69727: PUSH
69728: EMPTY
69729: LIST
69730: ST_TO_ADDR
// for i = 1 to pos - 1 do
69731: LD_ADDR_VAR 0 5
69735: PUSH
69736: DOUBLE
69737: LD_INT 1
69739: DEC
69740: ST_TO_ADDR
69741: LD_VAR 0 2
69745: PUSH
69746: LD_INT 1
69748: MINUS
69749: PUSH
69750: FOR_TO
69751: IFFALSE 69796
// begin tmp := tmp [ pos [ i ] ] ;
69753: LD_ADDR_VAR 0 6
69757: PUSH
69758: LD_VAR 0 6
69762: PUSH
69763: LD_VAR 0 2
69767: PUSH
69768: LD_VAR 0 5
69772: ARRAY
69773: ARRAY
69774: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
69775: LD_ADDR_VAR 0 7
69779: PUSH
69780: LD_VAR 0 7
69784: PUSH
69785: LD_VAR 0 6
69789: PUSH
69790: EMPTY
69791: LIST
69792: ADD
69793: ST_TO_ADDR
// end ;
69794: GO 69750
69796: POP
69797: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
69798: LD_ADDR_VAR 0 6
69802: PUSH
69803: LD_VAR 0 6
69807: PPUSH
69808: LD_VAR 0 2
69812: PUSH
69813: LD_VAR 0 2
69817: ARRAY
69818: PPUSH
69819: LD_VAR 0 3
69823: PPUSH
69824: CALL_OW 1
69828: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
69829: LD_ADDR_VAR 0 7
69833: PUSH
69834: LD_VAR 0 7
69838: PPUSH
69839: LD_VAR 0 7
69843: PPUSH
69844: LD_VAR 0 6
69848: PPUSH
69849: CALL_OW 1
69853: ST_TO_ADDR
// for i = s_arr downto 2 do
69854: LD_ADDR_VAR 0 5
69858: PUSH
69859: DOUBLE
69860: LD_VAR 0 7
69864: INC
69865: ST_TO_ADDR
69866: LD_INT 2
69868: PUSH
69869: FOR_DOWNTO
69870: IFFALSE 69954
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
69872: LD_ADDR_VAR 0 6
69876: PUSH
69877: LD_VAR 0 7
69881: PUSH
69882: LD_VAR 0 5
69886: PUSH
69887: LD_INT 1
69889: MINUS
69890: ARRAY
69891: PPUSH
69892: LD_VAR 0 2
69896: PUSH
69897: LD_VAR 0 5
69901: PUSH
69902: LD_INT 1
69904: MINUS
69905: ARRAY
69906: PPUSH
69907: LD_VAR 0 7
69911: PUSH
69912: LD_VAR 0 5
69916: ARRAY
69917: PPUSH
69918: CALL_OW 1
69922: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
69923: LD_ADDR_VAR 0 7
69927: PUSH
69928: LD_VAR 0 7
69932: PPUSH
69933: LD_VAR 0 5
69937: PUSH
69938: LD_INT 1
69940: MINUS
69941: PPUSH
69942: LD_VAR 0 6
69946: PPUSH
69947: CALL_OW 1
69951: ST_TO_ADDR
// end ;
69952: GO 69869
69954: POP
69955: POP
// result := s_arr [ 1 ] ;
69956: LD_ADDR_VAR 0 4
69960: PUSH
69961: LD_VAR 0 7
69965: PUSH
69966: LD_INT 1
69968: ARRAY
69969: ST_TO_ADDR
// end ; end ;
69970: LD_VAR 0 4
69974: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
69975: LD_INT 0
69977: PPUSH
69978: PPUSH
// if not list then
69979: LD_VAR 0 1
69983: NOT
69984: IFFALSE 69988
// exit ;
69986: GO 70079
// i := list [ pos1 ] ;
69988: LD_ADDR_VAR 0 5
69992: PUSH
69993: LD_VAR 0 1
69997: PUSH
69998: LD_VAR 0 2
70002: ARRAY
70003: ST_TO_ADDR
// if not i then
70004: LD_VAR 0 5
70008: NOT
70009: IFFALSE 70013
// exit ;
70011: GO 70079
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
70013: LD_ADDR_VAR 0 1
70017: PUSH
70018: LD_VAR 0 1
70022: PPUSH
70023: LD_VAR 0 2
70027: PPUSH
70028: LD_VAR 0 1
70032: PUSH
70033: LD_VAR 0 3
70037: ARRAY
70038: PPUSH
70039: CALL_OW 1
70043: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
70044: LD_ADDR_VAR 0 1
70048: PUSH
70049: LD_VAR 0 1
70053: PPUSH
70054: LD_VAR 0 3
70058: PPUSH
70059: LD_VAR 0 5
70063: PPUSH
70064: CALL_OW 1
70068: ST_TO_ADDR
// result := list ;
70069: LD_ADDR_VAR 0 4
70073: PUSH
70074: LD_VAR 0 1
70078: ST_TO_ADDR
// end ;
70079: LD_VAR 0 4
70083: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
70084: LD_INT 0
70086: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
70087: LD_ADDR_VAR 0 5
70091: PUSH
70092: LD_VAR 0 1
70096: PPUSH
70097: CALL_OW 250
70101: PPUSH
70102: LD_VAR 0 1
70106: PPUSH
70107: CALL_OW 251
70111: PPUSH
70112: LD_VAR 0 2
70116: PPUSH
70117: LD_VAR 0 3
70121: PPUSH
70122: LD_VAR 0 4
70126: PPUSH
70127: CALL 70137 0 5
70131: ST_TO_ADDR
// end ;
70132: LD_VAR 0 5
70136: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
70137: LD_INT 0
70139: PPUSH
70140: PPUSH
70141: PPUSH
70142: PPUSH
// if not list then
70143: LD_VAR 0 3
70147: NOT
70148: IFFALSE 70152
// exit ;
70150: GO 70540
// result := [ ] ;
70152: LD_ADDR_VAR 0 6
70156: PUSH
70157: EMPTY
70158: ST_TO_ADDR
// for i in list do
70159: LD_ADDR_VAR 0 7
70163: PUSH
70164: LD_VAR 0 3
70168: PUSH
70169: FOR_IN
70170: IFFALSE 70372
// begin tmp := GetDistUnitXY ( i , x , y ) ;
70172: LD_ADDR_VAR 0 9
70176: PUSH
70177: LD_VAR 0 7
70181: PPUSH
70182: LD_VAR 0 1
70186: PPUSH
70187: LD_VAR 0 2
70191: PPUSH
70192: CALL_OW 297
70196: ST_TO_ADDR
// if not result then
70197: LD_VAR 0 6
70201: NOT
70202: IFFALSE 70228
// result := [ [ i , tmp ] ] else
70204: LD_ADDR_VAR 0 6
70208: PUSH
70209: LD_VAR 0 7
70213: PUSH
70214: LD_VAR 0 9
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PUSH
70223: EMPTY
70224: LIST
70225: ST_TO_ADDR
70226: GO 70370
// begin if result [ result ] [ 2 ] < tmp then
70228: LD_VAR 0 6
70232: PUSH
70233: LD_VAR 0 6
70237: ARRAY
70238: PUSH
70239: LD_INT 2
70241: ARRAY
70242: PUSH
70243: LD_VAR 0 9
70247: LESS
70248: IFFALSE 70290
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
70250: LD_ADDR_VAR 0 6
70254: PUSH
70255: LD_VAR 0 6
70259: PPUSH
70260: LD_VAR 0 6
70264: PUSH
70265: LD_INT 1
70267: PLUS
70268: PPUSH
70269: LD_VAR 0 7
70273: PUSH
70274: LD_VAR 0 9
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PPUSH
70283: CALL_OW 2
70287: ST_TO_ADDR
70288: GO 70370
// for j = 1 to result do
70290: LD_ADDR_VAR 0 8
70294: PUSH
70295: DOUBLE
70296: LD_INT 1
70298: DEC
70299: ST_TO_ADDR
70300: LD_VAR 0 6
70304: PUSH
70305: FOR_TO
70306: IFFALSE 70368
// begin if tmp < result [ j ] [ 2 ] then
70308: LD_VAR 0 9
70312: PUSH
70313: LD_VAR 0 6
70317: PUSH
70318: LD_VAR 0 8
70322: ARRAY
70323: PUSH
70324: LD_INT 2
70326: ARRAY
70327: LESS
70328: IFFALSE 70366
// begin result := Insert ( result , j , [ i , tmp ] ) ;
70330: LD_ADDR_VAR 0 6
70334: PUSH
70335: LD_VAR 0 6
70339: PPUSH
70340: LD_VAR 0 8
70344: PPUSH
70345: LD_VAR 0 7
70349: PUSH
70350: LD_VAR 0 9
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PPUSH
70359: CALL_OW 2
70363: ST_TO_ADDR
// break ;
70364: GO 70368
// end ; end ;
70366: GO 70305
70368: POP
70369: POP
// end ; end ;
70370: GO 70169
70372: POP
70373: POP
// if result and not asc then
70374: LD_VAR 0 6
70378: PUSH
70379: LD_VAR 0 4
70383: NOT
70384: AND
70385: IFFALSE 70460
// begin tmp := result ;
70387: LD_ADDR_VAR 0 9
70391: PUSH
70392: LD_VAR 0 6
70396: ST_TO_ADDR
// for i = tmp downto 1 do
70397: LD_ADDR_VAR 0 7
70401: PUSH
70402: DOUBLE
70403: LD_VAR 0 9
70407: INC
70408: ST_TO_ADDR
70409: LD_INT 1
70411: PUSH
70412: FOR_DOWNTO
70413: IFFALSE 70458
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
70415: LD_ADDR_VAR 0 6
70419: PUSH
70420: LD_VAR 0 6
70424: PPUSH
70425: LD_VAR 0 9
70429: PUSH
70430: LD_VAR 0 7
70434: MINUS
70435: PUSH
70436: LD_INT 1
70438: PLUS
70439: PPUSH
70440: LD_VAR 0 9
70444: PUSH
70445: LD_VAR 0 7
70449: ARRAY
70450: PPUSH
70451: CALL_OW 1
70455: ST_TO_ADDR
70456: GO 70412
70458: POP
70459: POP
// end ; tmp := [ ] ;
70460: LD_ADDR_VAR 0 9
70464: PUSH
70465: EMPTY
70466: ST_TO_ADDR
// if mode then
70467: LD_VAR 0 5
70471: IFFALSE 70540
// begin for i = 1 to result do
70473: LD_ADDR_VAR 0 7
70477: PUSH
70478: DOUBLE
70479: LD_INT 1
70481: DEC
70482: ST_TO_ADDR
70483: LD_VAR 0 6
70487: PUSH
70488: FOR_TO
70489: IFFALSE 70528
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
70491: LD_ADDR_VAR 0 9
70495: PUSH
70496: LD_VAR 0 9
70500: PPUSH
70501: LD_VAR 0 7
70505: PPUSH
70506: LD_VAR 0 6
70510: PUSH
70511: LD_VAR 0 7
70515: ARRAY
70516: PUSH
70517: LD_INT 1
70519: ARRAY
70520: PPUSH
70521: CALL_OW 1
70525: ST_TO_ADDR
70526: GO 70488
70528: POP
70529: POP
// result := tmp ;
70530: LD_ADDR_VAR 0 6
70534: PUSH
70535: LD_VAR 0 9
70539: ST_TO_ADDR
// end ; end ;
70540: LD_VAR 0 6
70544: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
70545: LD_INT 0
70547: PPUSH
70548: PPUSH
70549: PPUSH
70550: PPUSH
70551: PPUSH
70552: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
70553: LD_ADDR_VAR 0 5
70557: PUSH
70558: LD_INT 0
70560: PUSH
70561: LD_INT 0
70563: PUSH
70564: LD_INT 0
70566: PUSH
70567: EMPTY
70568: PUSH
70569: EMPTY
70570: LIST
70571: LIST
70572: LIST
70573: LIST
70574: ST_TO_ADDR
// if not x or not y then
70575: LD_VAR 0 2
70579: NOT
70580: PUSH
70581: LD_VAR 0 3
70585: NOT
70586: OR
70587: IFFALSE 70591
// exit ;
70589: GO 72237
// if not range then
70591: LD_VAR 0 4
70595: NOT
70596: IFFALSE 70606
// range := 10 ;
70598: LD_ADDR_VAR 0 4
70602: PUSH
70603: LD_INT 10
70605: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
70606: LD_ADDR_VAR 0 8
70610: PUSH
70611: LD_INT 81
70613: PUSH
70614: LD_VAR 0 1
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: PUSH
70623: LD_INT 92
70625: PUSH
70626: LD_VAR 0 2
70630: PUSH
70631: LD_VAR 0 3
70635: PUSH
70636: LD_VAR 0 4
70640: PUSH
70641: EMPTY
70642: LIST
70643: LIST
70644: LIST
70645: LIST
70646: PUSH
70647: LD_INT 3
70649: PUSH
70650: LD_INT 21
70652: PUSH
70653: LD_INT 3
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: EMPTY
70661: LIST
70662: LIST
70663: PUSH
70664: EMPTY
70665: LIST
70666: LIST
70667: LIST
70668: PPUSH
70669: CALL_OW 69
70673: ST_TO_ADDR
// if not tmp then
70674: LD_VAR 0 8
70678: NOT
70679: IFFALSE 70683
// exit ;
70681: GO 72237
// for i in tmp do
70683: LD_ADDR_VAR 0 6
70687: PUSH
70688: LD_VAR 0 8
70692: PUSH
70693: FOR_IN
70694: IFFALSE 72212
// begin points := [ 0 , 0 , 0 ] ;
70696: LD_ADDR_VAR 0 9
70700: PUSH
70701: LD_INT 0
70703: PUSH
70704: LD_INT 0
70706: PUSH
70707: LD_INT 0
70709: PUSH
70710: EMPTY
70711: LIST
70712: LIST
70713: LIST
70714: ST_TO_ADDR
// bpoints := 1 ;
70715: LD_ADDR_VAR 0 10
70719: PUSH
70720: LD_INT 1
70722: ST_TO_ADDR
// case GetType ( i ) of unit_human :
70723: LD_VAR 0 6
70727: PPUSH
70728: CALL_OW 247
70732: PUSH
70733: LD_INT 1
70735: DOUBLE
70736: EQUAL
70737: IFTRUE 70741
70739: GO 71319
70741: POP
// begin if GetClass ( i ) = 1 then
70742: LD_VAR 0 6
70746: PPUSH
70747: CALL_OW 257
70751: PUSH
70752: LD_INT 1
70754: EQUAL
70755: IFFALSE 70776
// points := [ 10 , 5 , 3 ] ;
70757: LD_ADDR_VAR 0 9
70761: PUSH
70762: LD_INT 10
70764: PUSH
70765: LD_INT 5
70767: PUSH
70768: LD_INT 3
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: LIST
70775: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
70776: LD_VAR 0 6
70780: PPUSH
70781: CALL_OW 257
70785: PUSH
70786: LD_INT 2
70788: PUSH
70789: LD_INT 3
70791: PUSH
70792: LD_INT 4
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: LIST
70799: IN
70800: IFFALSE 70821
// points := [ 3 , 2 , 1 ] ;
70802: LD_ADDR_VAR 0 9
70806: PUSH
70807: LD_INT 3
70809: PUSH
70810: LD_INT 2
70812: PUSH
70813: LD_INT 1
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: LIST
70820: ST_TO_ADDR
// if GetClass ( i ) = 5 then
70821: LD_VAR 0 6
70825: PPUSH
70826: CALL_OW 257
70830: PUSH
70831: LD_INT 5
70833: EQUAL
70834: IFFALSE 70855
// points := [ 130 , 5 , 2 ] ;
70836: LD_ADDR_VAR 0 9
70840: PUSH
70841: LD_INT 130
70843: PUSH
70844: LD_INT 5
70846: PUSH
70847: LD_INT 2
70849: PUSH
70850: EMPTY
70851: LIST
70852: LIST
70853: LIST
70854: ST_TO_ADDR
// if GetClass ( i ) = 8 then
70855: LD_VAR 0 6
70859: PPUSH
70860: CALL_OW 257
70864: PUSH
70865: LD_INT 8
70867: EQUAL
70868: IFFALSE 70889
// points := [ 35 , 35 , 30 ] ;
70870: LD_ADDR_VAR 0 9
70874: PUSH
70875: LD_INT 35
70877: PUSH
70878: LD_INT 35
70880: PUSH
70881: LD_INT 30
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: LIST
70888: ST_TO_ADDR
// if GetClass ( i ) = 9 then
70889: LD_VAR 0 6
70893: PPUSH
70894: CALL_OW 257
70898: PUSH
70899: LD_INT 9
70901: EQUAL
70902: IFFALSE 70923
// points := [ 20 , 55 , 40 ] ;
70904: LD_ADDR_VAR 0 9
70908: PUSH
70909: LD_INT 20
70911: PUSH
70912: LD_INT 55
70914: PUSH
70915: LD_INT 40
70917: PUSH
70918: EMPTY
70919: LIST
70920: LIST
70921: LIST
70922: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
70923: LD_VAR 0 6
70927: PPUSH
70928: CALL_OW 257
70932: PUSH
70933: LD_INT 12
70935: PUSH
70936: LD_INT 16
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: IN
70943: IFFALSE 70964
// points := [ 5 , 3 , 2 ] ;
70945: LD_ADDR_VAR 0 9
70949: PUSH
70950: LD_INT 5
70952: PUSH
70953: LD_INT 3
70955: PUSH
70956: LD_INT 2
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: LIST
70963: ST_TO_ADDR
// if GetClass ( i ) = 17 then
70964: LD_VAR 0 6
70968: PPUSH
70969: CALL_OW 257
70973: PUSH
70974: LD_INT 17
70976: EQUAL
70977: IFFALSE 70998
// points := [ 100 , 50 , 75 ] ;
70979: LD_ADDR_VAR 0 9
70983: PUSH
70984: LD_INT 100
70986: PUSH
70987: LD_INT 50
70989: PUSH
70990: LD_INT 75
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: LIST
70997: ST_TO_ADDR
// if GetClass ( i ) = 15 then
70998: LD_VAR 0 6
71002: PPUSH
71003: CALL_OW 257
71007: PUSH
71008: LD_INT 15
71010: EQUAL
71011: IFFALSE 71032
// points := [ 10 , 5 , 3 ] ;
71013: LD_ADDR_VAR 0 9
71017: PUSH
71018: LD_INT 10
71020: PUSH
71021: LD_INT 5
71023: PUSH
71024: LD_INT 3
71026: PUSH
71027: EMPTY
71028: LIST
71029: LIST
71030: LIST
71031: ST_TO_ADDR
// if GetClass ( i ) = 14 then
71032: LD_VAR 0 6
71036: PPUSH
71037: CALL_OW 257
71041: PUSH
71042: LD_INT 14
71044: EQUAL
71045: IFFALSE 71066
// points := [ 10 , 0 , 0 ] ;
71047: LD_ADDR_VAR 0 9
71051: PUSH
71052: LD_INT 10
71054: PUSH
71055: LD_INT 0
71057: PUSH
71058: LD_INT 0
71060: PUSH
71061: EMPTY
71062: LIST
71063: LIST
71064: LIST
71065: ST_TO_ADDR
// if GetClass ( i ) = 11 then
71066: LD_VAR 0 6
71070: PPUSH
71071: CALL_OW 257
71075: PUSH
71076: LD_INT 11
71078: EQUAL
71079: IFFALSE 71100
// points := [ 30 , 10 , 5 ] ;
71081: LD_ADDR_VAR 0 9
71085: PUSH
71086: LD_INT 30
71088: PUSH
71089: LD_INT 10
71091: PUSH
71092: LD_INT 5
71094: PUSH
71095: EMPTY
71096: LIST
71097: LIST
71098: LIST
71099: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
71100: LD_VAR 0 1
71104: PPUSH
71105: LD_INT 5
71107: PPUSH
71108: CALL_OW 321
71112: PUSH
71113: LD_INT 2
71115: EQUAL
71116: IFFALSE 71133
// bpoints := bpoints * 1.8 ;
71118: LD_ADDR_VAR 0 10
71122: PUSH
71123: LD_VAR 0 10
71127: PUSH
71128: LD_REAL  1.80000000000000E+0000
71131: MUL
71132: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
71133: LD_VAR 0 6
71137: PPUSH
71138: CALL_OW 257
71142: PUSH
71143: LD_INT 1
71145: PUSH
71146: LD_INT 2
71148: PUSH
71149: LD_INT 3
71151: PUSH
71152: LD_INT 4
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: LIST
71159: LIST
71160: IN
71161: PUSH
71162: LD_VAR 0 1
71166: PPUSH
71167: LD_INT 51
71169: PPUSH
71170: CALL_OW 321
71174: PUSH
71175: LD_INT 2
71177: EQUAL
71178: AND
71179: IFFALSE 71196
// bpoints := bpoints * 1.2 ;
71181: LD_ADDR_VAR 0 10
71185: PUSH
71186: LD_VAR 0 10
71190: PUSH
71191: LD_REAL  1.20000000000000E+0000
71194: MUL
71195: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
71196: LD_VAR 0 6
71200: PPUSH
71201: CALL_OW 257
71205: PUSH
71206: LD_INT 5
71208: PUSH
71209: LD_INT 7
71211: PUSH
71212: LD_INT 9
71214: PUSH
71215: EMPTY
71216: LIST
71217: LIST
71218: LIST
71219: IN
71220: PUSH
71221: LD_VAR 0 1
71225: PPUSH
71226: LD_INT 52
71228: PPUSH
71229: CALL_OW 321
71233: PUSH
71234: LD_INT 2
71236: EQUAL
71237: AND
71238: IFFALSE 71255
// bpoints := bpoints * 1.5 ;
71240: LD_ADDR_VAR 0 10
71244: PUSH
71245: LD_VAR 0 10
71249: PUSH
71250: LD_REAL  1.50000000000000E+0000
71253: MUL
71254: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
71255: LD_VAR 0 1
71259: PPUSH
71260: LD_INT 66
71262: PPUSH
71263: CALL_OW 321
71267: PUSH
71268: LD_INT 2
71270: EQUAL
71271: IFFALSE 71288
// bpoints := bpoints * 1.1 ;
71273: LD_ADDR_VAR 0 10
71277: PUSH
71278: LD_VAR 0 10
71282: PUSH
71283: LD_REAL  1.10000000000000E+0000
71286: MUL
71287: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
71288: LD_ADDR_VAR 0 10
71292: PUSH
71293: LD_VAR 0 10
71297: PUSH
71298: LD_VAR 0 6
71302: PPUSH
71303: LD_INT 1
71305: PPUSH
71306: CALL_OW 259
71310: PUSH
71311: LD_REAL  1.15000000000000E+0000
71314: MUL
71315: MUL
71316: ST_TO_ADDR
// end ; unit_vehicle :
71317: GO 72141
71319: LD_INT 2
71321: DOUBLE
71322: EQUAL
71323: IFTRUE 71327
71325: GO 72129
71327: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
71328: LD_VAR 0 6
71332: PPUSH
71333: CALL_OW 264
71337: PUSH
71338: LD_INT 2
71340: PUSH
71341: LD_INT 42
71343: PUSH
71344: LD_INT 24
71346: PUSH
71347: EMPTY
71348: LIST
71349: LIST
71350: LIST
71351: IN
71352: IFFALSE 71373
// points := [ 25 , 5 , 3 ] ;
71354: LD_ADDR_VAR 0 9
71358: PUSH
71359: LD_INT 25
71361: PUSH
71362: LD_INT 5
71364: PUSH
71365: LD_INT 3
71367: PUSH
71368: EMPTY
71369: LIST
71370: LIST
71371: LIST
71372: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
71373: LD_VAR 0 6
71377: PPUSH
71378: CALL_OW 264
71382: PUSH
71383: LD_INT 4
71385: PUSH
71386: LD_INT 43
71388: PUSH
71389: LD_INT 25
71391: PUSH
71392: EMPTY
71393: LIST
71394: LIST
71395: LIST
71396: IN
71397: IFFALSE 71418
// points := [ 40 , 15 , 5 ] ;
71399: LD_ADDR_VAR 0 9
71403: PUSH
71404: LD_INT 40
71406: PUSH
71407: LD_INT 15
71409: PUSH
71410: LD_INT 5
71412: PUSH
71413: EMPTY
71414: LIST
71415: LIST
71416: LIST
71417: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
71418: LD_VAR 0 6
71422: PPUSH
71423: CALL_OW 264
71427: PUSH
71428: LD_INT 3
71430: PUSH
71431: LD_INT 23
71433: PUSH
71434: EMPTY
71435: LIST
71436: LIST
71437: IN
71438: IFFALSE 71459
// points := [ 7 , 25 , 8 ] ;
71440: LD_ADDR_VAR 0 9
71444: PUSH
71445: LD_INT 7
71447: PUSH
71448: LD_INT 25
71450: PUSH
71451: LD_INT 8
71453: PUSH
71454: EMPTY
71455: LIST
71456: LIST
71457: LIST
71458: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
71459: LD_VAR 0 6
71463: PPUSH
71464: CALL_OW 264
71468: PUSH
71469: LD_INT 5
71471: PUSH
71472: LD_INT 27
71474: PUSH
71475: LD_INT 44
71477: PUSH
71478: EMPTY
71479: LIST
71480: LIST
71481: LIST
71482: IN
71483: IFFALSE 71504
// points := [ 14 , 50 , 16 ] ;
71485: LD_ADDR_VAR 0 9
71489: PUSH
71490: LD_INT 14
71492: PUSH
71493: LD_INT 50
71495: PUSH
71496: LD_INT 16
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: LIST
71503: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
71504: LD_VAR 0 6
71508: PPUSH
71509: CALL_OW 264
71513: PUSH
71514: LD_INT 6
71516: PUSH
71517: LD_INT 46
71519: PUSH
71520: EMPTY
71521: LIST
71522: LIST
71523: IN
71524: IFFALSE 71545
// points := [ 32 , 120 , 70 ] ;
71526: LD_ADDR_VAR 0 9
71530: PUSH
71531: LD_INT 32
71533: PUSH
71534: LD_INT 120
71536: PUSH
71537: LD_INT 70
71539: PUSH
71540: EMPTY
71541: LIST
71542: LIST
71543: LIST
71544: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
71545: LD_VAR 0 6
71549: PPUSH
71550: CALL_OW 264
71554: PUSH
71555: LD_INT 7
71557: PUSH
71558: LD_INT 28
71560: PUSH
71561: LD_INT 45
71563: PUSH
71564: EMPTY
71565: LIST
71566: LIST
71567: LIST
71568: IN
71569: IFFALSE 71590
// points := [ 35 , 20 , 45 ] ;
71571: LD_ADDR_VAR 0 9
71575: PUSH
71576: LD_INT 35
71578: PUSH
71579: LD_INT 20
71581: PUSH
71582: LD_INT 45
71584: PUSH
71585: EMPTY
71586: LIST
71587: LIST
71588: LIST
71589: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
71590: LD_VAR 0 6
71594: PPUSH
71595: CALL_OW 264
71599: PUSH
71600: LD_INT 47
71602: PUSH
71603: EMPTY
71604: LIST
71605: IN
71606: IFFALSE 71627
// points := [ 67 , 45 , 75 ] ;
71608: LD_ADDR_VAR 0 9
71612: PUSH
71613: LD_INT 67
71615: PUSH
71616: LD_INT 45
71618: PUSH
71619: LD_INT 75
71621: PUSH
71622: EMPTY
71623: LIST
71624: LIST
71625: LIST
71626: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
71627: LD_VAR 0 6
71631: PPUSH
71632: CALL_OW 264
71636: PUSH
71637: LD_INT 26
71639: PUSH
71640: EMPTY
71641: LIST
71642: IN
71643: IFFALSE 71664
// points := [ 120 , 30 , 80 ] ;
71645: LD_ADDR_VAR 0 9
71649: PUSH
71650: LD_INT 120
71652: PUSH
71653: LD_INT 30
71655: PUSH
71656: LD_INT 80
71658: PUSH
71659: EMPTY
71660: LIST
71661: LIST
71662: LIST
71663: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
71664: LD_VAR 0 6
71668: PPUSH
71669: CALL_OW 264
71673: PUSH
71674: LD_INT 22
71676: PUSH
71677: EMPTY
71678: LIST
71679: IN
71680: IFFALSE 71701
// points := [ 40 , 1 , 1 ] ;
71682: LD_ADDR_VAR 0 9
71686: PUSH
71687: LD_INT 40
71689: PUSH
71690: LD_INT 1
71692: PUSH
71693: LD_INT 1
71695: PUSH
71696: EMPTY
71697: LIST
71698: LIST
71699: LIST
71700: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
71701: LD_VAR 0 6
71705: PPUSH
71706: CALL_OW 264
71710: PUSH
71711: LD_INT 29
71713: PUSH
71714: EMPTY
71715: LIST
71716: IN
71717: IFFALSE 71738
// points := [ 70 , 200 , 400 ] ;
71719: LD_ADDR_VAR 0 9
71723: PUSH
71724: LD_INT 70
71726: PUSH
71727: LD_INT 200
71729: PUSH
71730: LD_INT 400
71732: PUSH
71733: EMPTY
71734: LIST
71735: LIST
71736: LIST
71737: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
71738: LD_VAR 0 6
71742: PPUSH
71743: CALL_OW 264
71747: PUSH
71748: LD_INT 14
71750: PUSH
71751: LD_INT 53
71753: PUSH
71754: EMPTY
71755: LIST
71756: LIST
71757: IN
71758: IFFALSE 71779
// points := [ 40 , 10 , 20 ] ;
71760: LD_ADDR_VAR 0 9
71764: PUSH
71765: LD_INT 40
71767: PUSH
71768: LD_INT 10
71770: PUSH
71771: LD_INT 20
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: LIST
71778: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
71779: LD_VAR 0 6
71783: PPUSH
71784: CALL_OW 264
71788: PUSH
71789: LD_INT 9
71791: PUSH
71792: EMPTY
71793: LIST
71794: IN
71795: IFFALSE 71816
// points := [ 5 , 70 , 20 ] ;
71797: LD_ADDR_VAR 0 9
71801: PUSH
71802: LD_INT 5
71804: PUSH
71805: LD_INT 70
71807: PUSH
71808: LD_INT 20
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: LIST
71815: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
71816: LD_VAR 0 6
71820: PPUSH
71821: CALL_OW 264
71825: PUSH
71826: LD_INT 10
71828: PUSH
71829: EMPTY
71830: LIST
71831: IN
71832: IFFALSE 71853
// points := [ 35 , 110 , 70 ] ;
71834: LD_ADDR_VAR 0 9
71838: PUSH
71839: LD_INT 35
71841: PUSH
71842: LD_INT 110
71844: PUSH
71845: LD_INT 70
71847: PUSH
71848: EMPTY
71849: LIST
71850: LIST
71851: LIST
71852: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
71853: LD_VAR 0 6
71857: PPUSH
71858: CALL_OW 265
71862: PUSH
71863: LD_INT 25
71865: EQUAL
71866: IFFALSE 71887
// points := [ 80 , 65 , 100 ] ;
71868: LD_ADDR_VAR 0 9
71872: PUSH
71873: LD_INT 80
71875: PUSH
71876: LD_INT 65
71878: PUSH
71879: LD_INT 100
71881: PUSH
71882: EMPTY
71883: LIST
71884: LIST
71885: LIST
71886: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
71887: LD_VAR 0 6
71891: PPUSH
71892: CALL_OW 263
71896: PUSH
71897: LD_INT 1
71899: EQUAL
71900: IFFALSE 71935
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
71902: LD_ADDR_VAR 0 10
71906: PUSH
71907: LD_VAR 0 10
71911: PUSH
71912: LD_VAR 0 6
71916: PPUSH
71917: CALL_OW 311
71921: PPUSH
71922: LD_INT 3
71924: PPUSH
71925: CALL_OW 259
71929: PUSH
71930: LD_INT 4
71932: MUL
71933: MUL
71934: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
71935: LD_VAR 0 6
71939: PPUSH
71940: CALL_OW 263
71944: PUSH
71945: LD_INT 2
71947: EQUAL
71948: IFFALSE 71999
// begin j := IsControledBy ( i ) ;
71950: LD_ADDR_VAR 0 7
71954: PUSH
71955: LD_VAR 0 6
71959: PPUSH
71960: CALL_OW 312
71964: ST_TO_ADDR
// if j then
71965: LD_VAR 0 7
71969: IFFALSE 71999
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
71971: LD_ADDR_VAR 0 10
71975: PUSH
71976: LD_VAR 0 10
71980: PUSH
71981: LD_VAR 0 7
71985: PPUSH
71986: LD_INT 3
71988: PPUSH
71989: CALL_OW 259
71993: PUSH
71994: LD_INT 3
71996: MUL
71997: MUL
71998: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
71999: LD_VAR 0 6
72003: PPUSH
72004: CALL_OW 264
72008: PUSH
72009: LD_INT 5
72011: PUSH
72012: LD_INT 6
72014: PUSH
72015: LD_INT 46
72017: PUSH
72018: LD_INT 44
72020: PUSH
72021: LD_INT 47
72023: PUSH
72024: LD_INT 45
72026: PUSH
72027: LD_INT 28
72029: PUSH
72030: LD_INT 7
72032: PUSH
72033: LD_INT 27
72035: PUSH
72036: LD_INT 29
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: LIST
72043: LIST
72044: LIST
72045: LIST
72046: LIST
72047: LIST
72048: LIST
72049: LIST
72050: IN
72051: PUSH
72052: LD_VAR 0 1
72056: PPUSH
72057: LD_INT 52
72059: PPUSH
72060: CALL_OW 321
72064: PUSH
72065: LD_INT 2
72067: EQUAL
72068: AND
72069: IFFALSE 72086
// bpoints := bpoints * 1.2 ;
72071: LD_ADDR_VAR 0 10
72075: PUSH
72076: LD_VAR 0 10
72080: PUSH
72081: LD_REAL  1.20000000000000E+0000
72084: MUL
72085: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
72086: LD_VAR 0 6
72090: PPUSH
72091: CALL_OW 264
72095: PUSH
72096: LD_INT 6
72098: PUSH
72099: LD_INT 46
72101: PUSH
72102: LD_INT 47
72104: PUSH
72105: EMPTY
72106: LIST
72107: LIST
72108: LIST
72109: IN
72110: IFFALSE 72127
// bpoints := bpoints * 1.2 ;
72112: LD_ADDR_VAR 0 10
72116: PUSH
72117: LD_VAR 0 10
72121: PUSH
72122: LD_REAL  1.20000000000000E+0000
72125: MUL
72126: ST_TO_ADDR
// end ; unit_building :
72127: GO 72141
72129: LD_INT 3
72131: DOUBLE
72132: EQUAL
72133: IFTRUE 72137
72135: GO 72140
72137: POP
// ; end ;
72138: GO 72141
72140: POP
// for j = 1 to 3 do
72141: LD_ADDR_VAR 0 7
72145: PUSH
72146: DOUBLE
72147: LD_INT 1
72149: DEC
72150: ST_TO_ADDR
72151: LD_INT 3
72153: PUSH
72154: FOR_TO
72155: IFFALSE 72208
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
72157: LD_ADDR_VAR 0 5
72161: PUSH
72162: LD_VAR 0 5
72166: PPUSH
72167: LD_VAR 0 7
72171: PPUSH
72172: LD_VAR 0 5
72176: PUSH
72177: LD_VAR 0 7
72181: ARRAY
72182: PUSH
72183: LD_VAR 0 9
72187: PUSH
72188: LD_VAR 0 7
72192: ARRAY
72193: PUSH
72194: LD_VAR 0 10
72198: MUL
72199: PLUS
72200: PPUSH
72201: CALL_OW 1
72205: ST_TO_ADDR
72206: GO 72154
72208: POP
72209: POP
// end ;
72210: GO 70693
72212: POP
72213: POP
// result := Replace ( result , 4 , tmp ) ;
72214: LD_ADDR_VAR 0 5
72218: PUSH
72219: LD_VAR 0 5
72223: PPUSH
72224: LD_INT 4
72226: PPUSH
72227: LD_VAR 0 8
72231: PPUSH
72232: CALL_OW 1
72236: ST_TO_ADDR
// end ;
72237: LD_VAR 0 5
72241: RET
// export function DangerAtRange ( unit , range ) ; begin
72242: LD_INT 0
72244: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
72245: LD_ADDR_VAR 0 3
72249: PUSH
72250: LD_VAR 0 1
72254: PPUSH
72255: CALL_OW 255
72259: PPUSH
72260: LD_VAR 0 1
72264: PPUSH
72265: CALL_OW 250
72269: PPUSH
72270: LD_VAR 0 1
72274: PPUSH
72275: CALL_OW 251
72279: PPUSH
72280: LD_VAR 0 2
72284: PPUSH
72285: CALL 70545 0 4
72289: ST_TO_ADDR
// end ;
72290: LD_VAR 0 3
72294: RET
// export function DangerInArea ( side , area ) ; begin
72295: LD_INT 0
72297: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
72298: LD_ADDR_VAR 0 3
72302: PUSH
72303: LD_VAR 0 2
72307: PPUSH
72308: LD_INT 81
72310: PUSH
72311: LD_VAR 0 1
72315: PUSH
72316: EMPTY
72317: LIST
72318: LIST
72319: PPUSH
72320: CALL_OW 70
72324: ST_TO_ADDR
// end ;
72325: LD_VAR 0 3
72329: RET
// export function IsExtension ( b ) ; begin
72330: LD_INT 0
72332: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
72333: LD_ADDR_VAR 0 2
72337: PUSH
72338: LD_VAR 0 1
72342: PUSH
72343: LD_INT 23
72345: PUSH
72346: LD_INT 20
72348: PUSH
72349: LD_INT 22
72351: PUSH
72352: LD_INT 17
72354: PUSH
72355: LD_INT 24
72357: PUSH
72358: LD_INT 21
72360: PUSH
72361: LD_INT 19
72363: PUSH
72364: LD_INT 16
72366: PUSH
72367: LD_INT 25
72369: PUSH
72370: LD_INT 18
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: LIST
72383: LIST
72384: IN
72385: ST_TO_ADDR
// end ;
72386: LD_VAR 0 2
72390: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
72391: LD_INT 0
72393: PPUSH
72394: PPUSH
72395: PPUSH
// result := [ ] ;
72396: LD_ADDR_VAR 0 3
72400: PUSH
72401: EMPTY
72402: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
72403: LD_ADDR_VAR 0 4
72407: PUSH
72408: LD_VAR 0 2
72412: PPUSH
72413: LD_INT 21
72415: PUSH
72416: LD_INT 3
72418: PUSH
72419: EMPTY
72420: LIST
72421: LIST
72422: PPUSH
72423: CALL_OW 70
72427: ST_TO_ADDR
// if not tmp then
72428: LD_VAR 0 4
72432: NOT
72433: IFFALSE 72437
// exit ;
72435: GO 72495
// for i in tmp do
72437: LD_ADDR_VAR 0 5
72441: PUSH
72442: LD_VAR 0 4
72446: PUSH
72447: FOR_IN
72448: IFFALSE 72483
// if GetBase ( i ) <> base then
72450: LD_VAR 0 5
72454: PPUSH
72455: CALL_OW 274
72459: PUSH
72460: LD_VAR 0 1
72464: NONEQUAL
72465: IFFALSE 72481
// ComLinkToBase ( base , i ) ;
72467: LD_VAR 0 1
72471: PPUSH
72472: LD_VAR 0 5
72476: PPUSH
72477: CALL_OW 169
72481: GO 72447
72483: POP
72484: POP
// result := tmp ;
72485: LD_ADDR_VAR 0 3
72489: PUSH
72490: LD_VAR 0 4
72494: ST_TO_ADDR
// end ;
72495: LD_VAR 0 3
72499: RET
// export function ComComplete ( unit , b ) ; var i ; begin
72500: LD_INT 0
72502: PPUSH
72503: PPUSH
// if BuildingStatus ( b ) = bs_build then
72504: LD_VAR 0 2
72508: PPUSH
72509: CALL_OW 461
72513: PUSH
72514: LD_INT 1
72516: EQUAL
72517: IFFALSE 72577
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
72519: LD_VAR 0 1
72523: PPUSH
72524: LD_STRING h
72526: PUSH
72527: LD_VAR 0 2
72531: PPUSH
72532: CALL_OW 250
72536: PUSH
72537: LD_VAR 0 2
72541: PPUSH
72542: CALL_OW 251
72546: PUSH
72547: LD_VAR 0 2
72551: PUSH
72552: LD_INT 0
72554: PUSH
72555: LD_INT 0
72557: PUSH
72558: LD_INT 0
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: LIST
72565: LIST
72566: LIST
72567: LIST
72568: LIST
72569: PUSH
72570: EMPTY
72571: LIST
72572: PPUSH
72573: CALL_OW 446
// end ;
72577: LD_VAR 0 3
72581: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
72582: LD_INT 0
72584: PPUSH
72585: PPUSH
72586: PPUSH
72587: PPUSH
72588: PPUSH
72589: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
72590: LD_VAR 0 1
72594: NOT
72595: PUSH
72596: LD_VAR 0 1
72600: PPUSH
72601: CALL_OW 263
72605: PUSH
72606: LD_INT 2
72608: EQUAL
72609: NOT
72610: OR
72611: IFFALSE 72615
// exit ;
72613: GO 72931
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
72615: LD_ADDR_VAR 0 6
72619: PUSH
72620: LD_INT 22
72622: PUSH
72623: LD_VAR 0 1
72627: PPUSH
72628: CALL_OW 255
72632: PUSH
72633: EMPTY
72634: LIST
72635: LIST
72636: PUSH
72637: LD_INT 2
72639: PUSH
72640: LD_INT 30
72642: PUSH
72643: LD_INT 36
72645: PUSH
72646: EMPTY
72647: LIST
72648: LIST
72649: PUSH
72650: LD_INT 34
72652: PUSH
72653: LD_INT 31
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: LIST
72664: PUSH
72665: EMPTY
72666: LIST
72667: LIST
72668: PPUSH
72669: CALL_OW 69
72673: ST_TO_ADDR
// if not tmp then
72674: LD_VAR 0 6
72678: NOT
72679: IFFALSE 72683
// exit ;
72681: GO 72931
// result := [ ] ;
72683: LD_ADDR_VAR 0 2
72687: PUSH
72688: EMPTY
72689: ST_TO_ADDR
// for i in tmp do
72690: LD_ADDR_VAR 0 3
72694: PUSH
72695: LD_VAR 0 6
72699: PUSH
72700: FOR_IN
72701: IFFALSE 72772
// begin t := UnitsInside ( i ) ;
72703: LD_ADDR_VAR 0 4
72707: PUSH
72708: LD_VAR 0 3
72712: PPUSH
72713: CALL_OW 313
72717: ST_TO_ADDR
// if t then
72718: LD_VAR 0 4
72722: IFFALSE 72770
// for j in t do
72724: LD_ADDR_VAR 0 7
72728: PUSH
72729: LD_VAR 0 4
72733: PUSH
72734: FOR_IN
72735: IFFALSE 72768
// result := Insert ( result , result + 1 , j ) ;
72737: LD_ADDR_VAR 0 2
72741: PUSH
72742: LD_VAR 0 2
72746: PPUSH
72747: LD_VAR 0 2
72751: PUSH
72752: LD_INT 1
72754: PLUS
72755: PPUSH
72756: LD_VAR 0 7
72760: PPUSH
72761: CALL_OW 2
72765: ST_TO_ADDR
72766: GO 72734
72768: POP
72769: POP
// end ;
72770: GO 72700
72772: POP
72773: POP
// if not result then
72774: LD_VAR 0 2
72778: NOT
72779: IFFALSE 72783
// exit ;
72781: GO 72931
// mech := result [ 1 ] ;
72783: LD_ADDR_VAR 0 5
72787: PUSH
72788: LD_VAR 0 2
72792: PUSH
72793: LD_INT 1
72795: ARRAY
72796: ST_TO_ADDR
// if result > 1 then
72797: LD_VAR 0 2
72801: PUSH
72802: LD_INT 1
72804: GREATER
72805: IFFALSE 72917
// for i = 2 to result do
72807: LD_ADDR_VAR 0 3
72811: PUSH
72812: DOUBLE
72813: LD_INT 2
72815: DEC
72816: ST_TO_ADDR
72817: LD_VAR 0 2
72821: PUSH
72822: FOR_TO
72823: IFFALSE 72915
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
72825: LD_ADDR_VAR 0 4
72829: PUSH
72830: LD_VAR 0 2
72834: PUSH
72835: LD_VAR 0 3
72839: ARRAY
72840: PPUSH
72841: LD_INT 3
72843: PPUSH
72844: CALL_OW 259
72848: PUSH
72849: LD_VAR 0 2
72853: PUSH
72854: LD_VAR 0 3
72858: ARRAY
72859: PPUSH
72860: CALL_OW 432
72864: MINUS
72865: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
72866: LD_VAR 0 4
72870: PUSH
72871: LD_VAR 0 5
72875: PPUSH
72876: LD_INT 3
72878: PPUSH
72879: CALL_OW 259
72883: PUSH
72884: LD_VAR 0 5
72888: PPUSH
72889: CALL_OW 432
72893: MINUS
72894: GREATEREQUAL
72895: IFFALSE 72913
// mech := result [ i ] ;
72897: LD_ADDR_VAR 0 5
72901: PUSH
72902: LD_VAR 0 2
72906: PUSH
72907: LD_VAR 0 3
72911: ARRAY
72912: ST_TO_ADDR
// end ;
72913: GO 72822
72915: POP
72916: POP
// ComLinkTo ( vehicle , mech ) ;
72917: LD_VAR 0 1
72921: PPUSH
72922: LD_VAR 0 5
72926: PPUSH
72927: CALL_OW 135
// end ;
72931: LD_VAR 0 2
72935: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
72936: LD_INT 0
72938: PPUSH
72939: PPUSH
72940: PPUSH
72941: PPUSH
72942: PPUSH
72943: PPUSH
72944: PPUSH
72945: PPUSH
72946: PPUSH
72947: PPUSH
72948: PPUSH
72949: PPUSH
72950: PPUSH
// result := [ ] ;
72951: LD_ADDR_VAR 0 7
72955: PUSH
72956: EMPTY
72957: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
72958: LD_VAR 0 1
72962: PPUSH
72963: CALL_OW 266
72967: PUSH
72968: LD_INT 0
72970: PUSH
72971: LD_INT 1
72973: PUSH
72974: EMPTY
72975: LIST
72976: LIST
72977: IN
72978: NOT
72979: IFFALSE 72983
// exit ;
72981: GO 74614
// if name then
72983: LD_VAR 0 3
72987: IFFALSE 73003
// SetBName ( base_dep , name ) ;
72989: LD_VAR 0 1
72993: PPUSH
72994: LD_VAR 0 3
72998: PPUSH
72999: CALL_OW 500
// base := GetBase ( base_dep ) ;
73003: LD_ADDR_VAR 0 15
73007: PUSH
73008: LD_VAR 0 1
73012: PPUSH
73013: CALL_OW 274
73017: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
73018: LD_ADDR_VAR 0 16
73022: PUSH
73023: LD_VAR 0 1
73027: PPUSH
73028: CALL_OW 255
73032: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
73033: LD_ADDR_VAR 0 17
73037: PUSH
73038: LD_VAR 0 1
73042: PPUSH
73043: CALL_OW 248
73047: ST_TO_ADDR
// if sources then
73048: LD_VAR 0 5
73052: IFFALSE 73099
// for i = 1 to 3 do
73054: LD_ADDR_VAR 0 8
73058: PUSH
73059: DOUBLE
73060: LD_INT 1
73062: DEC
73063: ST_TO_ADDR
73064: LD_INT 3
73066: PUSH
73067: FOR_TO
73068: IFFALSE 73097
// AddResourceType ( base , i , sources [ i ] ) ;
73070: LD_VAR 0 15
73074: PPUSH
73075: LD_VAR 0 8
73079: PPUSH
73080: LD_VAR 0 5
73084: PUSH
73085: LD_VAR 0 8
73089: ARRAY
73090: PPUSH
73091: CALL_OW 276
73095: GO 73067
73097: POP
73098: POP
// buildings := GetBaseBuildings ( base , area ) ;
73099: LD_ADDR_VAR 0 18
73103: PUSH
73104: LD_VAR 0 15
73108: PPUSH
73109: LD_VAR 0 2
73113: PPUSH
73114: CALL 72391 0 2
73118: ST_TO_ADDR
// InitHc ;
73119: CALL_OW 19
// InitUc ;
73123: CALL_OW 18
// uc_side := side ;
73127: LD_ADDR_OWVAR 20
73131: PUSH
73132: LD_VAR 0 16
73136: ST_TO_ADDR
// uc_nation := nation ;
73137: LD_ADDR_OWVAR 21
73141: PUSH
73142: LD_VAR 0 17
73146: ST_TO_ADDR
// if buildings then
73147: LD_VAR 0 18
73151: IFFALSE 74473
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
73153: LD_ADDR_VAR 0 19
73157: PUSH
73158: LD_VAR 0 18
73162: PPUSH
73163: LD_INT 2
73165: PUSH
73166: LD_INT 30
73168: PUSH
73169: LD_INT 29
73171: PUSH
73172: EMPTY
73173: LIST
73174: LIST
73175: PUSH
73176: LD_INT 30
73178: PUSH
73179: LD_INT 30
73181: PUSH
73182: EMPTY
73183: LIST
73184: LIST
73185: PUSH
73186: EMPTY
73187: LIST
73188: LIST
73189: LIST
73190: PPUSH
73191: CALL_OW 72
73195: ST_TO_ADDR
// if tmp then
73196: LD_VAR 0 19
73200: IFFALSE 73248
// for i in tmp do
73202: LD_ADDR_VAR 0 8
73206: PUSH
73207: LD_VAR 0 19
73211: PUSH
73212: FOR_IN
73213: IFFALSE 73246
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
73215: LD_VAR 0 8
73219: PPUSH
73220: CALL_OW 250
73224: PPUSH
73225: LD_VAR 0 8
73229: PPUSH
73230: CALL_OW 251
73234: PPUSH
73235: LD_VAR 0 16
73239: PPUSH
73240: CALL_OW 441
73244: GO 73212
73246: POP
73247: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
73248: LD_VAR 0 18
73252: PPUSH
73253: LD_INT 2
73255: PUSH
73256: LD_INT 30
73258: PUSH
73259: LD_INT 32
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: PUSH
73266: LD_INT 30
73268: PUSH
73269: LD_INT 33
73271: PUSH
73272: EMPTY
73273: LIST
73274: LIST
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: LIST
73280: PPUSH
73281: CALL_OW 72
73285: IFFALSE 73373
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
73287: LD_ADDR_VAR 0 8
73291: PUSH
73292: LD_VAR 0 18
73296: PPUSH
73297: LD_INT 2
73299: PUSH
73300: LD_INT 30
73302: PUSH
73303: LD_INT 32
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: LD_INT 30
73312: PUSH
73313: LD_INT 33
73315: PUSH
73316: EMPTY
73317: LIST
73318: LIST
73319: PUSH
73320: EMPTY
73321: LIST
73322: LIST
73323: LIST
73324: PPUSH
73325: CALL_OW 72
73329: PUSH
73330: FOR_IN
73331: IFFALSE 73371
// begin if not GetBWeapon ( i ) then
73333: LD_VAR 0 8
73337: PPUSH
73338: CALL_OW 269
73342: NOT
73343: IFFALSE 73369
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
73345: LD_VAR 0 8
73349: PPUSH
73350: LD_VAR 0 8
73354: PPUSH
73355: LD_VAR 0 2
73359: PPUSH
73360: CALL 74619 0 2
73364: PPUSH
73365: CALL_OW 431
// end ;
73369: GO 73330
73371: POP
73372: POP
// end ; for i = 1 to personel do
73373: LD_ADDR_VAR 0 8
73377: PUSH
73378: DOUBLE
73379: LD_INT 1
73381: DEC
73382: ST_TO_ADDR
73383: LD_VAR 0 6
73387: PUSH
73388: FOR_TO
73389: IFFALSE 74453
// begin if i > 4 then
73391: LD_VAR 0 8
73395: PUSH
73396: LD_INT 4
73398: GREATER
73399: IFFALSE 73403
// break ;
73401: GO 74453
// case i of 1 :
73403: LD_VAR 0 8
73407: PUSH
73408: LD_INT 1
73410: DOUBLE
73411: EQUAL
73412: IFTRUE 73416
73414: GO 73496
73416: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
73417: LD_ADDR_VAR 0 12
73421: PUSH
73422: LD_VAR 0 18
73426: PPUSH
73427: LD_INT 22
73429: PUSH
73430: LD_VAR 0 16
73434: PUSH
73435: EMPTY
73436: LIST
73437: LIST
73438: PUSH
73439: LD_INT 58
73441: PUSH
73442: EMPTY
73443: LIST
73444: PUSH
73445: LD_INT 2
73447: PUSH
73448: LD_INT 30
73450: PUSH
73451: LD_INT 32
73453: PUSH
73454: EMPTY
73455: LIST
73456: LIST
73457: PUSH
73458: LD_INT 30
73460: PUSH
73461: LD_INT 4
73463: PUSH
73464: EMPTY
73465: LIST
73466: LIST
73467: PUSH
73468: LD_INT 30
73470: PUSH
73471: LD_INT 5
73473: PUSH
73474: EMPTY
73475: LIST
73476: LIST
73477: PUSH
73478: EMPTY
73479: LIST
73480: LIST
73481: LIST
73482: LIST
73483: PUSH
73484: EMPTY
73485: LIST
73486: LIST
73487: LIST
73488: PPUSH
73489: CALL_OW 72
73493: ST_TO_ADDR
73494: GO 73718
73496: LD_INT 2
73498: DOUBLE
73499: EQUAL
73500: IFTRUE 73504
73502: GO 73566
73504: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
73505: LD_ADDR_VAR 0 12
73509: PUSH
73510: LD_VAR 0 18
73514: PPUSH
73515: LD_INT 22
73517: PUSH
73518: LD_VAR 0 16
73522: PUSH
73523: EMPTY
73524: LIST
73525: LIST
73526: PUSH
73527: LD_INT 2
73529: PUSH
73530: LD_INT 30
73532: PUSH
73533: LD_INT 0
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: PUSH
73540: LD_INT 30
73542: PUSH
73543: LD_INT 1
73545: PUSH
73546: EMPTY
73547: LIST
73548: LIST
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: LIST
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PPUSH
73559: CALL_OW 72
73563: ST_TO_ADDR
73564: GO 73718
73566: LD_INT 3
73568: DOUBLE
73569: EQUAL
73570: IFTRUE 73574
73572: GO 73636
73574: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
73575: LD_ADDR_VAR 0 12
73579: PUSH
73580: LD_VAR 0 18
73584: PPUSH
73585: LD_INT 22
73587: PUSH
73588: LD_VAR 0 16
73592: PUSH
73593: EMPTY
73594: LIST
73595: LIST
73596: PUSH
73597: LD_INT 2
73599: PUSH
73600: LD_INT 30
73602: PUSH
73603: LD_INT 2
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: PUSH
73610: LD_INT 30
73612: PUSH
73613: LD_INT 3
73615: PUSH
73616: EMPTY
73617: LIST
73618: LIST
73619: PUSH
73620: EMPTY
73621: LIST
73622: LIST
73623: LIST
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PPUSH
73629: CALL_OW 72
73633: ST_TO_ADDR
73634: GO 73718
73636: LD_INT 4
73638: DOUBLE
73639: EQUAL
73640: IFTRUE 73644
73642: GO 73717
73644: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
73645: LD_ADDR_VAR 0 12
73649: PUSH
73650: LD_VAR 0 18
73654: PPUSH
73655: LD_INT 22
73657: PUSH
73658: LD_VAR 0 16
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: PUSH
73667: LD_INT 2
73669: PUSH
73670: LD_INT 30
73672: PUSH
73673: LD_INT 6
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: PUSH
73680: LD_INT 30
73682: PUSH
73683: LD_INT 7
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 30
73692: PUSH
73693: LD_INT 8
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: PUSH
73700: EMPTY
73701: LIST
73702: LIST
73703: LIST
73704: LIST
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PPUSH
73710: CALL_OW 72
73714: ST_TO_ADDR
73715: GO 73718
73717: POP
// if i = 1 then
73718: LD_VAR 0 8
73722: PUSH
73723: LD_INT 1
73725: EQUAL
73726: IFFALSE 73837
// begin tmp := [ ] ;
73728: LD_ADDR_VAR 0 19
73732: PUSH
73733: EMPTY
73734: ST_TO_ADDR
// for j in f do
73735: LD_ADDR_VAR 0 9
73739: PUSH
73740: LD_VAR 0 12
73744: PUSH
73745: FOR_IN
73746: IFFALSE 73819
// if GetBType ( j ) = b_bunker then
73748: LD_VAR 0 9
73752: PPUSH
73753: CALL_OW 266
73757: PUSH
73758: LD_INT 32
73760: EQUAL
73761: IFFALSE 73788
// tmp := Insert ( tmp , 1 , j ) else
73763: LD_ADDR_VAR 0 19
73767: PUSH
73768: LD_VAR 0 19
73772: PPUSH
73773: LD_INT 1
73775: PPUSH
73776: LD_VAR 0 9
73780: PPUSH
73781: CALL_OW 2
73785: ST_TO_ADDR
73786: GO 73817
// tmp := Insert ( tmp , tmp + 1 , j ) ;
73788: LD_ADDR_VAR 0 19
73792: PUSH
73793: LD_VAR 0 19
73797: PPUSH
73798: LD_VAR 0 19
73802: PUSH
73803: LD_INT 1
73805: PLUS
73806: PPUSH
73807: LD_VAR 0 9
73811: PPUSH
73812: CALL_OW 2
73816: ST_TO_ADDR
73817: GO 73745
73819: POP
73820: POP
// if tmp then
73821: LD_VAR 0 19
73825: IFFALSE 73837
// f := tmp ;
73827: LD_ADDR_VAR 0 12
73831: PUSH
73832: LD_VAR 0 19
73836: ST_TO_ADDR
// end ; x := personel [ i ] ;
73837: LD_ADDR_VAR 0 13
73841: PUSH
73842: LD_VAR 0 6
73846: PUSH
73847: LD_VAR 0 8
73851: ARRAY
73852: ST_TO_ADDR
// if x = - 1 then
73853: LD_VAR 0 13
73857: PUSH
73858: LD_INT 1
73860: NEG
73861: EQUAL
73862: IFFALSE 74071
// begin for j in f do
73864: LD_ADDR_VAR 0 9
73868: PUSH
73869: LD_VAR 0 12
73873: PUSH
73874: FOR_IN
73875: IFFALSE 74067
// repeat InitHc ;
73877: CALL_OW 19
// if GetBType ( j ) = b_barracks then
73881: LD_VAR 0 9
73885: PPUSH
73886: CALL_OW 266
73890: PUSH
73891: LD_INT 5
73893: EQUAL
73894: IFFALSE 73964
// begin if UnitsInside ( j ) < 3 then
73896: LD_VAR 0 9
73900: PPUSH
73901: CALL_OW 313
73905: PUSH
73906: LD_INT 3
73908: LESS
73909: IFFALSE 73945
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
73911: LD_INT 0
73913: PPUSH
73914: LD_INT 5
73916: PUSH
73917: LD_INT 8
73919: PUSH
73920: LD_INT 9
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: LIST
73927: PUSH
73928: LD_VAR 0 17
73932: ARRAY
73933: PPUSH
73934: LD_VAR 0 4
73938: PPUSH
73939: CALL_OW 380
73943: GO 73962
// PrepareHuman ( false , i , skill ) ;
73945: LD_INT 0
73947: PPUSH
73948: LD_VAR 0 8
73952: PPUSH
73953: LD_VAR 0 4
73957: PPUSH
73958: CALL_OW 380
// end else
73962: GO 73981
// PrepareHuman ( false , i , skill ) ;
73964: LD_INT 0
73966: PPUSH
73967: LD_VAR 0 8
73971: PPUSH
73972: LD_VAR 0 4
73976: PPUSH
73977: CALL_OW 380
// un := CreateHuman ;
73981: LD_ADDR_VAR 0 14
73985: PUSH
73986: CALL_OW 44
73990: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
73991: LD_ADDR_VAR 0 7
73995: PUSH
73996: LD_VAR 0 7
74000: PPUSH
74001: LD_INT 1
74003: PPUSH
74004: LD_VAR 0 14
74008: PPUSH
74009: CALL_OW 2
74013: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
74014: LD_VAR 0 14
74018: PPUSH
74019: LD_VAR 0 9
74023: PPUSH
74024: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
74028: LD_VAR 0 9
74032: PPUSH
74033: CALL_OW 313
74037: PUSH
74038: LD_INT 6
74040: EQUAL
74041: PUSH
74042: LD_VAR 0 9
74046: PPUSH
74047: CALL_OW 266
74051: PUSH
74052: LD_INT 32
74054: PUSH
74055: LD_INT 31
74057: PUSH
74058: EMPTY
74059: LIST
74060: LIST
74061: IN
74062: OR
74063: IFFALSE 73877
74065: GO 73874
74067: POP
74068: POP
// end else
74069: GO 74451
// for j = 1 to x do
74071: LD_ADDR_VAR 0 9
74075: PUSH
74076: DOUBLE
74077: LD_INT 1
74079: DEC
74080: ST_TO_ADDR
74081: LD_VAR 0 13
74085: PUSH
74086: FOR_TO
74087: IFFALSE 74449
// begin InitHc ;
74089: CALL_OW 19
// if not f then
74093: LD_VAR 0 12
74097: NOT
74098: IFFALSE 74187
// begin PrepareHuman ( false , i , skill ) ;
74100: LD_INT 0
74102: PPUSH
74103: LD_VAR 0 8
74107: PPUSH
74108: LD_VAR 0 4
74112: PPUSH
74113: CALL_OW 380
// un := CreateHuman ;
74117: LD_ADDR_VAR 0 14
74121: PUSH
74122: CALL_OW 44
74126: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74127: LD_ADDR_VAR 0 7
74131: PUSH
74132: LD_VAR 0 7
74136: PPUSH
74137: LD_INT 1
74139: PPUSH
74140: LD_VAR 0 14
74144: PPUSH
74145: CALL_OW 2
74149: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74150: LD_VAR 0 14
74154: PPUSH
74155: LD_VAR 0 1
74159: PPUSH
74160: CALL_OW 250
74164: PPUSH
74165: LD_VAR 0 1
74169: PPUSH
74170: CALL_OW 251
74174: PPUSH
74175: LD_INT 10
74177: PPUSH
74178: LD_INT 0
74180: PPUSH
74181: CALL_OW 50
// continue ;
74185: GO 74086
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
74187: LD_VAR 0 12
74191: PUSH
74192: LD_INT 1
74194: ARRAY
74195: PPUSH
74196: CALL_OW 313
74200: PUSH
74201: LD_VAR 0 12
74205: PUSH
74206: LD_INT 1
74208: ARRAY
74209: PPUSH
74210: CALL_OW 266
74214: PUSH
74215: LD_INT 32
74217: PUSH
74218: LD_INT 31
74220: PUSH
74221: EMPTY
74222: LIST
74223: LIST
74224: IN
74225: AND
74226: PUSH
74227: LD_VAR 0 12
74231: PUSH
74232: LD_INT 1
74234: ARRAY
74235: PPUSH
74236: CALL_OW 313
74240: PUSH
74241: LD_INT 6
74243: EQUAL
74244: OR
74245: IFFALSE 74265
// f := Delete ( f , 1 ) ;
74247: LD_ADDR_VAR 0 12
74251: PUSH
74252: LD_VAR 0 12
74256: PPUSH
74257: LD_INT 1
74259: PPUSH
74260: CALL_OW 3
74264: ST_TO_ADDR
// if not f then
74265: LD_VAR 0 12
74269: NOT
74270: IFFALSE 74288
// begin x := x + 2 ;
74272: LD_ADDR_VAR 0 13
74276: PUSH
74277: LD_VAR 0 13
74281: PUSH
74282: LD_INT 2
74284: PLUS
74285: ST_TO_ADDR
// continue ;
74286: GO 74086
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
74288: LD_VAR 0 12
74292: PUSH
74293: LD_INT 1
74295: ARRAY
74296: PPUSH
74297: CALL_OW 266
74301: PUSH
74302: LD_INT 5
74304: EQUAL
74305: IFFALSE 74379
// begin if UnitsInside ( f [ 1 ] ) < 3 then
74307: LD_VAR 0 12
74311: PUSH
74312: LD_INT 1
74314: ARRAY
74315: PPUSH
74316: CALL_OW 313
74320: PUSH
74321: LD_INT 3
74323: LESS
74324: IFFALSE 74360
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
74326: LD_INT 0
74328: PPUSH
74329: LD_INT 5
74331: PUSH
74332: LD_INT 8
74334: PUSH
74335: LD_INT 9
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: LIST
74342: PUSH
74343: LD_VAR 0 17
74347: ARRAY
74348: PPUSH
74349: LD_VAR 0 4
74353: PPUSH
74354: CALL_OW 380
74358: GO 74377
// PrepareHuman ( false , i , skill ) ;
74360: LD_INT 0
74362: PPUSH
74363: LD_VAR 0 8
74367: PPUSH
74368: LD_VAR 0 4
74372: PPUSH
74373: CALL_OW 380
// end else
74377: GO 74396
// PrepareHuman ( false , i , skill ) ;
74379: LD_INT 0
74381: PPUSH
74382: LD_VAR 0 8
74386: PPUSH
74387: LD_VAR 0 4
74391: PPUSH
74392: CALL_OW 380
// un := CreateHuman ;
74396: LD_ADDR_VAR 0 14
74400: PUSH
74401: CALL_OW 44
74405: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
74406: LD_ADDR_VAR 0 7
74410: PUSH
74411: LD_VAR 0 7
74415: PPUSH
74416: LD_INT 1
74418: PPUSH
74419: LD_VAR 0 14
74423: PPUSH
74424: CALL_OW 2
74428: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
74429: LD_VAR 0 14
74433: PPUSH
74434: LD_VAR 0 12
74438: PUSH
74439: LD_INT 1
74441: ARRAY
74442: PPUSH
74443: CALL_OW 52
// end ;
74447: GO 74086
74449: POP
74450: POP
// end ;
74451: GO 73388
74453: POP
74454: POP
// result := result ^ buildings ;
74455: LD_ADDR_VAR 0 7
74459: PUSH
74460: LD_VAR 0 7
74464: PUSH
74465: LD_VAR 0 18
74469: ADD
74470: ST_TO_ADDR
// end else
74471: GO 74614
// begin for i = 1 to personel do
74473: LD_ADDR_VAR 0 8
74477: PUSH
74478: DOUBLE
74479: LD_INT 1
74481: DEC
74482: ST_TO_ADDR
74483: LD_VAR 0 6
74487: PUSH
74488: FOR_TO
74489: IFFALSE 74612
// begin if i > 4 then
74491: LD_VAR 0 8
74495: PUSH
74496: LD_INT 4
74498: GREATER
74499: IFFALSE 74503
// break ;
74501: GO 74612
// x := personel [ i ] ;
74503: LD_ADDR_VAR 0 13
74507: PUSH
74508: LD_VAR 0 6
74512: PUSH
74513: LD_VAR 0 8
74517: ARRAY
74518: ST_TO_ADDR
// if x = - 1 then
74519: LD_VAR 0 13
74523: PUSH
74524: LD_INT 1
74526: NEG
74527: EQUAL
74528: IFFALSE 74532
// continue ;
74530: GO 74488
// PrepareHuman ( false , i , skill ) ;
74532: LD_INT 0
74534: PPUSH
74535: LD_VAR 0 8
74539: PPUSH
74540: LD_VAR 0 4
74544: PPUSH
74545: CALL_OW 380
// un := CreateHuman ;
74549: LD_ADDR_VAR 0 14
74553: PUSH
74554: CALL_OW 44
74558: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
74559: LD_VAR 0 14
74563: PPUSH
74564: LD_VAR 0 1
74568: PPUSH
74569: CALL_OW 250
74573: PPUSH
74574: LD_VAR 0 1
74578: PPUSH
74579: CALL_OW 251
74583: PPUSH
74584: LD_INT 10
74586: PPUSH
74587: LD_INT 0
74589: PPUSH
74590: CALL_OW 50
// result := result ^ un ;
74594: LD_ADDR_VAR 0 7
74598: PUSH
74599: LD_VAR 0 7
74603: PUSH
74604: LD_VAR 0 14
74608: ADD
74609: ST_TO_ADDR
// end ;
74610: GO 74488
74612: POP
74613: POP
// end ; end ;
74614: LD_VAR 0 7
74618: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
74619: LD_INT 0
74621: PPUSH
74622: PPUSH
74623: PPUSH
74624: PPUSH
74625: PPUSH
74626: PPUSH
74627: PPUSH
74628: PPUSH
74629: PPUSH
74630: PPUSH
74631: PPUSH
74632: PPUSH
74633: PPUSH
74634: PPUSH
74635: PPUSH
74636: PPUSH
// result := false ;
74637: LD_ADDR_VAR 0 3
74641: PUSH
74642: LD_INT 0
74644: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
74645: LD_VAR 0 1
74649: NOT
74650: PUSH
74651: LD_VAR 0 1
74655: PPUSH
74656: CALL_OW 266
74660: PUSH
74661: LD_INT 32
74663: PUSH
74664: LD_INT 33
74666: PUSH
74667: EMPTY
74668: LIST
74669: LIST
74670: IN
74671: NOT
74672: OR
74673: IFFALSE 74677
// exit ;
74675: GO 75813
// nat := GetNation ( tower ) ;
74677: LD_ADDR_VAR 0 12
74681: PUSH
74682: LD_VAR 0 1
74686: PPUSH
74687: CALL_OW 248
74691: ST_TO_ADDR
// side := GetSide ( tower ) ;
74692: LD_ADDR_VAR 0 16
74696: PUSH
74697: LD_VAR 0 1
74701: PPUSH
74702: CALL_OW 255
74706: ST_TO_ADDR
// x := GetX ( tower ) ;
74707: LD_ADDR_VAR 0 10
74711: PUSH
74712: LD_VAR 0 1
74716: PPUSH
74717: CALL_OW 250
74721: ST_TO_ADDR
// y := GetY ( tower ) ;
74722: LD_ADDR_VAR 0 11
74726: PUSH
74727: LD_VAR 0 1
74731: PPUSH
74732: CALL_OW 251
74736: ST_TO_ADDR
// if not x or not y then
74737: LD_VAR 0 10
74741: NOT
74742: PUSH
74743: LD_VAR 0 11
74747: NOT
74748: OR
74749: IFFALSE 74753
// exit ;
74751: GO 75813
// weapon := 0 ;
74753: LD_ADDR_VAR 0 18
74757: PUSH
74758: LD_INT 0
74760: ST_TO_ADDR
// fac_list := [ ] ;
74761: LD_ADDR_VAR 0 17
74765: PUSH
74766: EMPTY
74767: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
74768: LD_ADDR_VAR 0 6
74772: PUSH
74773: LD_VAR 0 1
74777: PPUSH
74778: CALL_OW 274
74782: PPUSH
74783: LD_VAR 0 2
74787: PPUSH
74788: CALL 72391 0 2
74792: PPUSH
74793: LD_INT 30
74795: PUSH
74796: LD_INT 3
74798: PUSH
74799: EMPTY
74800: LIST
74801: LIST
74802: PPUSH
74803: CALL_OW 72
74807: ST_TO_ADDR
// if not factories then
74808: LD_VAR 0 6
74812: NOT
74813: IFFALSE 74817
// exit ;
74815: GO 75813
// for i in factories do
74817: LD_ADDR_VAR 0 8
74821: PUSH
74822: LD_VAR 0 6
74826: PUSH
74827: FOR_IN
74828: IFFALSE 74853
// fac_list := fac_list union AvailableWeaponList ( i ) ;
74830: LD_ADDR_VAR 0 17
74834: PUSH
74835: LD_VAR 0 17
74839: PUSH
74840: LD_VAR 0 8
74844: PPUSH
74845: CALL_OW 478
74849: UNION
74850: ST_TO_ADDR
74851: GO 74827
74853: POP
74854: POP
// if not fac_list then
74855: LD_VAR 0 17
74859: NOT
74860: IFFALSE 74864
// exit ;
74862: GO 75813
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
74864: LD_ADDR_VAR 0 5
74868: PUSH
74869: LD_INT 4
74871: PUSH
74872: LD_INT 5
74874: PUSH
74875: LD_INT 9
74877: PUSH
74878: LD_INT 10
74880: PUSH
74881: LD_INT 6
74883: PUSH
74884: LD_INT 7
74886: PUSH
74887: LD_INT 11
74889: PUSH
74890: EMPTY
74891: LIST
74892: LIST
74893: LIST
74894: LIST
74895: LIST
74896: LIST
74897: LIST
74898: PUSH
74899: LD_INT 27
74901: PUSH
74902: LD_INT 28
74904: PUSH
74905: LD_INT 26
74907: PUSH
74908: LD_INT 30
74910: PUSH
74911: EMPTY
74912: LIST
74913: LIST
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 43
74919: PUSH
74920: LD_INT 44
74922: PUSH
74923: LD_INT 46
74925: PUSH
74926: LD_INT 45
74928: PUSH
74929: LD_INT 47
74931: PUSH
74932: LD_INT 49
74934: PUSH
74935: EMPTY
74936: LIST
74937: LIST
74938: LIST
74939: LIST
74940: LIST
74941: LIST
74942: PUSH
74943: EMPTY
74944: LIST
74945: LIST
74946: LIST
74947: PUSH
74948: LD_VAR 0 12
74952: ARRAY
74953: ST_TO_ADDR
// for i in list do
74954: LD_ADDR_VAR 0 8
74958: PUSH
74959: LD_VAR 0 5
74963: PUSH
74964: FOR_IN
74965: IFFALSE 74998
// if not i in fac_list then
74967: LD_VAR 0 8
74971: PUSH
74972: LD_VAR 0 17
74976: IN
74977: NOT
74978: IFFALSE 74996
// list := list diff i ;
74980: LD_ADDR_VAR 0 5
74984: PUSH
74985: LD_VAR 0 5
74989: PUSH
74990: LD_VAR 0 8
74994: DIFF
74995: ST_TO_ADDR
74996: GO 74964
74998: POP
74999: POP
// if not list then
75000: LD_VAR 0 5
75004: NOT
75005: IFFALSE 75009
// exit ;
75007: GO 75813
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
75009: LD_VAR 0 12
75013: PUSH
75014: LD_INT 3
75016: EQUAL
75017: PUSH
75018: LD_INT 49
75020: PUSH
75021: LD_VAR 0 5
75025: IN
75026: AND
75027: PUSH
75028: LD_INT 31
75030: PPUSH
75031: LD_VAR 0 16
75035: PPUSH
75036: CALL_OW 321
75040: PUSH
75041: LD_INT 2
75043: EQUAL
75044: AND
75045: IFFALSE 75105
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
75047: LD_INT 22
75049: PUSH
75050: LD_VAR 0 16
75054: PUSH
75055: EMPTY
75056: LIST
75057: LIST
75058: PUSH
75059: LD_INT 35
75061: PUSH
75062: LD_INT 49
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PUSH
75069: LD_INT 91
75071: PUSH
75072: LD_VAR 0 1
75076: PUSH
75077: LD_INT 10
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: LIST
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: LIST
75089: PPUSH
75090: CALL_OW 69
75094: NOT
75095: IFFALSE 75105
// weapon := ru_time_lapser ;
75097: LD_ADDR_VAR 0 18
75101: PUSH
75102: LD_INT 49
75104: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
75105: LD_VAR 0 12
75109: PUSH
75110: LD_INT 1
75112: PUSH
75113: LD_INT 2
75115: PUSH
75116: EMPTY
75117: LIST
75118: LIST
75119: IN
75120: PUSH
75121: LD_INT 11
75123: PUSH
75124: LD_VAR 0 5
75128: IN
75129: PUSH
75130: LD_INT 30
75132: PUSH
75133: LD_VAR 0 5
75137: IN
75138: OR
75139: AND
75140: PUSH
75141: LD_INT 6
75143: PPUSH
75144: LD_VAR 0 16
75148: PPUSH
75149: CALL_OW 321
75153: PUSH
75154: LD_INT 2
75156: EQUAL
75157: AND
75158: IFFALSE 75323
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
75160: LD_INT 22
75162: PUSH
75163: LD_VAR 0 16
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 2
75174: PUSH
75175: LD_INT 35
75177: PUSH
75178: LD_INT 11
75180: PUSH
75181: EMPTY
75182: LIST
75183: LIST
75184: PUSH
75185: LD_INT 35
75187: PUSH
75188: LD_INT 30
75190: PUSH
75191: EMPTY
75192: LIST
75193: LIST
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: LIST
75199: PUSH
75200: LD_INT 91
75202: PUSH
75203: LD_VAR 0 1
75207: PUSH
75208: LD_INT 18
75210: PUSH
75211: EMPTY
75212: LIST
75213: LIST
75214: LIST
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: LIST
75220: PPUSH
75221: CALL_OW 69
75225: NOT
75226: PUSH
75227: LD_INT 22
75229: PUSH
75230: LD_VAR 0 16
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 2
75241: PUSH
75242: LD_INT 30
75244: PUSH
75245: LD_INT 32
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: LD_INT 30
75254: PUSH
75255: LD_INT 33
75257: PUSH
75258: EMPTY
75259: LIST
75260: LIST
75261: PUSH
75262: EMPTY
75263: LIST
75264: LIST
75265: LIST
75266: PUSH
75267: LD_INT 91
75269: PUSH
75270: LD_VAR 0 1
75274: PUSH
75275: LD_INT 12
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: LIST
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: LIST
75287: PUSH
75288: EMPTY
75289: LIST
75290: PPUSH
75291: CALL_OW 69
75295: PUSH
75296: LD_INT 2
75298: GREATER
75299: AND
75300: IFFALSE 75323
// weapon := [ us_radar , ar_radar ] [ nat ] ;
75302: LD_ADDR_VAR 0 18
75306: PUSH
75307: LD_INT 11
75309: PUSH
75310: LD_INT 30
75312: PUSH
75313: EMPTY
75314: LIST
75315: LIST
75316: PUSH
75317: LD_VAR 0 12
75321: ARRAY
75322: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
75323: LD_VAR 0 18
75327: NOT
75328: PUSH
75329: LD_INT 40
75331: PPUSH
75332: LD_VAR 0 16
75336: PPUSH
75337: CALL_OW 321
75341: PUSH
75342: LD_INT 2
75344: EQUAL
75345: AND
75346: PUSH
75347: LD_INT 7
75349: PUSH
75350: LD_VAR 0 5
75354: IN
75355: PUSH
75356: LD_INT 28
75358: PUSH
75359: LD_VAR 0 5
75363: IN
75364: OR
75365: PUSH
75366: LD_INT 45
75368: PUSH
75369: LD_VAR 0 5
75373: IN
75374: OR
75375: AND
75376: IFFALSE 75630
// begin hex := GetHexInfo ( x , y ) ;
75378: LD_ADDR_VAR 0 4
75382: PUSH
75383: LD_VAR 0 10
75387: PPUSH
75388: LD_VAR 0 11
75392: PPUSH
75393: CALL_OW 546
75397: ST_TO_ADDR
// if hex [ 1 ] then
75398: LD_VAR 0 4
75402: PUSH
75403: LD_INT 1
75405: ARRAY
75406: IFFALSE 75410
// exit ;
75408: GO 75813
// height := hex [ 2 ] ;
75410: LD_ADDR_VAR 0 15
75414: PUSH
75415: LD_VAR 0 4
75419: PUSH
75420: LD_INT 2
75422: ARRAY
75423: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
75424: LD_ADDR_VAR 0 14
75428: PUSH
75429: LD_INT 0
75431: PUSH
75432: LD_INT 2
75434: PUSH
75435: LD_INT 3
75437: PUSH
75438: LD_INT 5
75440: PUSH
75441: EMPTY
75442: LIST
75443: LIST
75444: LIST
75445: LIST
75446: ST_TO_ADDR
// for i in tmp do
75447: LD_ADDR_VAR 0 8
75451: PUSH
75452: LD_VAR 0 14
75456: PUSH
75457: FOR_IN
75458: IFFALSE 75628
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
75460: LD_ADDR_VAR 0 9
75464: PUSH
75465: LD_VAR 0 10
75469: PPUSH
75470: LD_VAR 0 8
75474: PPUSH
75475: LD_INT 5
75477: PPUSH
75478: CALL_OW 272
75482: PUSH
75483: LD_VAR 0 11
75487: PPUSH
75488: LD_VAR 0 8
75492: PPUSH
75493: LD_INT 5
75495: PPUSH
75496: CALL_OW 273
75500: PUSH
75501: EMPTY
75502: LIST
75503: LIST
75504: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
75505: LD_VAR 0 9
75509: PUSH
75510: LD_INT 1
75512: ARRAY
75513: PPUSH
75514: LD_VAR 0 9
75518: PUSH
75519: LD_INT 2
75521: ARRAY
75522: PPUSH
75523: CALL_OW 488
75527: IFFALSE 75626
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
75529: LD_ADDR_VAR 0 4
75533: PUSH
75534: LD_VAR 0 9
75538: PUSH
75539: LD_INT 1
75541: ARRAY
75542: PPUSH
75543: LD_VAR 0 9
75547: PUSH
75548: LD_INT 2
75550: ARRAY
75551: PPUSH
75552: CALL_OW 546
75556: ST_TO_ADDR
// if hex [ 1 ] then
75557: LD_VAR 0 4
75561: PUSH
75562: LD_INT 1
75564: ARRAY
75565: IFFALSE 75569
// continue ;
75567: GO 75457
// h := hex [ 2 ] ;
75569: LD_ADDR_VAR 0 13
75573: PUSH
75574: LD_VAR 0 4
75578: PUSH
75579: LD_INT 2
75581: ARRAY
75582: ST_TO_ADDR
// if h + 7 < height then
75583: LD_VAR 0 13
75587: PUSH
75588: LD_INT 7
75590: PLUS
75591: PUSH
75592: LD_VAR 0 15
75596: LESS
75597: IFFALSE 75626
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
75599: LD_ADDR_VAR 0 18
75603: PUSH
75604: LD_INT 7
75606: PUSH
75607: LD_INT 28
75609: PUSH
75610: LD_INT 45
75612: PUSH
75613: EMPTY
75614: LIST
75615: LIST
75616: LIST
75617: PUSH
75618: LD_VAR 0 12
75622: ARRAY
75623: ST_TO_ADDR
// break ;
75624: GO 75628
// end ; end ; end ;
75626: GO 75457
75628: POP
75629: POP
// end ; if not weapon then
75630: LD_VAR 0 18
75634: NOT
75635: IFFALSE 75695
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
75637: LD_ADDR_VAR 0 5
75641: PUSH
75642: LD_VAR 0 5
75646: PUSH
75647: LD_INT 11
75649: PUSH
75650: LD_INT 30
75652: PUSH
75653: LD_INT 49
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: LIST
75660: DIFF
75661: ST_TO_ADDR
// if not list then
75662: LD_VAR 0 5
75666: NOT
75667: IFFALSE 75671
// exit ;
75669: GO 75813
// weapon := list [ rand ( 1 , list ) ] ;
75671: LD_ADDR_VAR 0 18
75675: PUSH
75676: LD_VAR 0 5
75680: PUSH
75681: LD_INT 1
75683: PPUSH
75684: LD_VAR 0 5
75688: PPUSH
75689: CALL_OW 12
75693: ARRAY
75694: ST_TO_ADDR
// end ; if weapon then
75695: LD_VAR 0 18
75699: IFFALSE 75813
// begin tmp := CostOfWeapon ( weapon ) ;
75701: LD_ADDR_VAR 0 14
75705: PUSH
75706: LD_VAR 0 18
75710: PPUSH
75711: CALL_OW 451
75715: ST_TO_ADDR
// j := GetBase ( tower ) ;
75716: LD_ADDR_VAR 0 9
75720: PUSH
75721: LD_VAR 0 1
75725: PPUSH
75726: CALL_OW 274
75730: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
75731: LD_VAR 0 9
75735: PPUSH
75736: LD_INT 1
75738: PPUSH
75739: CALL_OW 275
75743: PUSH
75744: LD_VAR 0 14
75748: PUSH
75749: LD_INT 1
75751: ARRAY
75752: GREATEREQUAL
75753: PUSH
75754: LD_VAR 0 9
75758: PPUSH
75759: LD_INT 2
75761: PPUSH
75762: CALL_OW 275
75766: PUSH
75767: LD_VAR 0 14
75771: PUSH
75772: LD_INT 2
75774: ARRAY
75775: GREATEREQUAL
75776: AND
75777: PUSH
75778: LD_VAR 0 9
75782: PPUSH
75783: LD_INT 3
75785: PPUSH
75786: CALL_OW 275
75790: PUSH
75791: LD_VAR 0 14
75795: PUSH
75796: LD_INT 3
75798: ARRAY
75799: GREATEREQUAL
75800: AND
75801: IFFALSE 75813
// result := weapon ;
75803: LD_ADDR_VAR 0 3
75807: PUSH
75808: LD_VAR 0 18
75812: ST_TO_ADDR
// end ; end ;
75813: LD_VAR 0 3
75817: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
75818: LD_INT 0
75820: PPUSH
75821: PPUSH
// result := true ;
75822: LD_ADDR_VAR 0 3
75826: PUSH
75827: LD_INT 1
75829: ST_TO_ADDR
// if array1 = array2 then
75830: LD_VAR 0 1
75834: PUSH
75835: LD_VAR 0 2
75839: EQUAL
75840: IFFALSE 75900
// begin for i = 1 to array1 do
75842: LD_ADDR_VAR 0 4
75846: PUSH
75847: DOUBLE
75848: LD_INT 1
75850: DEC
75851: ST_TO_ADDR
75852: LD_VAR 0 1
75856: PUSH
75857: FOR_TO
75858: IFFALSE 75896
// if array1 [ i ] <> array2 [ i ] then
75860: LD_VAR 0 1
75864: PUSH
75865: LD_VAR 0 4
75869: ARRAY
75870: PUSH
75871: LD_VAR 0 2
75875: PUSH
75876: LD_VAR 0 4
75880: ARRAY
75881: NONEQUAL
75882: IFFALSE 75894
// begin result := false ;
75884: LD_ADDR_VAR 0 3
75888: PUSH
75889: LD_INT 0
75891: ST_TO_ADDR
// break ;
75892: GO 75896
// end ;
75894: GO 75857
75896: POP
75897: POP
// end else
75898: GO 75908
// result := false ;
75900: LD_ADDR_VAR 0 3
75904: PUSH
75905: LD_INT 0
75907: ST_TO_ADDR
// end ;
75908: LD_VAR 0 3
75912: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
75913: LD_INT 0
75915: PPUSH
75916: PPUSH
75917: PPUSH
// pom := GetBase ( fac ) ;
75918: LD_ADDR_VAR 0 5
75922: PUSH
75923: LD_VAR 0 1
75927: PPUSH
75928: CALL_OW 274
75932: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
75933: LD_ADDR_VAR 0 4
75937: PUSH
75938: LD_VAR 0 2
75942: PUSH
75943: LD_INT 1
75945: ARRAY
75946: PPUSH
75947: LD_VAR 0 2
75951: PUSH
75952: LD_INT 2
75954: ARRAY
75955: PPUSH
75956: LD_VAR 0 2
75960: PUSH
75961: LD_INT 3
75963: ARRAY
75964: PPUSH
75965: LD_VAR 0 2
75969: PUSH
75970: LD_INT 4
75972: ARRAY
75973: PPUSH
75974: CALL_OW 449
75978: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
75979: LD_ADDR_VAR 0 3
75983: PUSH
75984: LD_VAR 0 5
75988: PPUSH
75989: LD_INT 1
75991: PPUSH
75992: CALL_OW 275
75996: PUSH
75997: LD_VAR 0 4
76001: PUSH
76002: LD_INT 1
76004: ARRAY
76005: GREATEREQUAL
76006: PUSH
76007: LD_VAR 0 5
76011: PPUSH
76012: LD_INT 2
76014: PPUSH
76015: CALL_OW 275
76019: PUSH
76020: LD_VAR 0 4
76024: PUSH
76025: LD_INT 2
76027: ARRAY
76028: GREATEREQUAL
76029: AND
76030: PUSH
76031: LD_VAR 0 5
76035: PPUSH
76036: LD_INT 3
76038: PPUSH
76039: CALL_OW 275
76043: PUSH
76044: LD_VAR 0 4
76048: PUSH
76049: LD_INT 3
76051: ARRAY
76052: GREATEREQUAL
76053: AND
76054: ST_TO_ADDR
// end ;
76055: LD_VAR 0 3
76059: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
76060: LD_INT 0
76062: PPUSH
76063: PPUSH
76064: PPUSH
76065: PPUSH
// pom := GetBase ( building ) ;
76066: LD_ADDR_VAR 0 3
76070: PUSH
76071: LD_VAR 0 1
76075: PPUSH
76076: CALL_OW 274
76080: ST_TO_ADDR
// if not pom then
76081: LD_VAR 0 3
76085: NOT
76086: IFFALSE 76090
// exit ;
76088: GO 76260
// btype := GetBType ( building ) ;
76090: LD_ADDR_VAR 0 5
76094: PUSH
76095: LD_VAR 0 1
76099: PPUSH
76100: CALL_OW 266
76104: ST_TO_ADDR
// if btype = b_armoury then
76105: LD_VAR 0 5
76109: PUSH
76110: LD_INT 4
76112: EQUAL
76113: IFFALSE 76123
// btype := b_barracks ;
76115: LD_ADDR_VAR 0 5
76119: PUSH
76120: LD_INT 5
76122: ST_TO_ADDR
// if btype = b_depot then
76123: LD_VAR 0 5
76127: PUSH
76128: LD_INT 0
76130: EQUAL
76131: IFFALSE 76141
// btype := b_warehouse ;
76133: LD_ADDR_VAR 0 5
76137: PUSH
76138: LD_INT 1
76140: ST_TO_ADDR
// if btype = b_workshop then
76141: LD_VAR 0 5
76145: PUSH
76146: LD_INT 2
76148: EQUAL
76149: IFFALSE 76159
// btype := b_factory ;
76151: LD_ADDR_VAR 0 5
76155: PUSH
76156: LD_INT 3
76158: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76159: LD_ADDR_VAR 0 4
76163: PUSH
76164: LD_VAR 0 5
76168: PPUSH
76169: LD_VAR 0 1
76173: PPUSH
76174: CALL_OW 248
76178: PPUSH
76179: CALL_OW 450
76183: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76184: LD_ADDR_VAR 0 2
76188: PUSH
76189: LD_VAR 0 3
76193: PPUSH
76194: LD_INT 1
76196: PPUSH
76197: CALL_OW 275
76201: PUSH
76202: LD_VAR 0 4
76206: PUSH
76207: LD_INT 1
76209: ARRAY
76210: GREATEREQUAL
76211: PUSH
76212: LD_VAR 0 3
76216: PPUSH
76217: LD_INT 2
76219: PPUSH
76220: CALL_OW 275
76224: PUSH
76225: LD_VAR 0 4
76229: PUSH
76230: LD_INT 2
76232: ARRAY
76233: GREATEREQUAL
76234: AND
76235: PUSH
76236: LD_VAR 0 3
76240: PPUSH
76241: LD_INT 3
76243: PPUSH
76244: CALL_OW 275
76248: PUSH
76249: LD_VAR 0 4
76253: PUSH
76254: LD_INT 3
76256: ARRAY
76257: GREATEREQUAL
76258: AND
76259: ST_TO_ADDR
// end ;
76260: LD_VAR 0 2
76264: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
76265: LD_INT 0
76267: PPUSH
76268: PPUSH
76269: PPUSH
// pom := GetBase ( building ) ;
76270: LD_ADDR_VAR 0 4
76274: PUSH
76275: LD_VAR 0 1
76279: PPUSH
76280: CALL_OW 274
76284: ST_TO_ADDR
// if not pom then
76285: LD_VAR 0 4
76289: NOT
76290: IFFALSE 76294
// exit ;
76292: GO 76395
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
76294: LD_ADDR_VAR 0 5
76298: PUSH
76299: LD_VAR 0 2
76303: PPUSH
76304: LD_VAR 0 1
76308: PPUSH
76309: CALL_OW 248
76313: PPUSH
76314: CALL_OW 450
76318: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
76319: LD_ADDR_VAR 0 3
76323: PUSH
76324: LD_VAR 0 4
76328: PPUSH
76329: LD_INT 1
76331: PPUSH
76332: CALL_OW 275
76336: PUSH
76337: LD_VAR 0 5
76341: PUSH
76342: LD_INT 1
76344: ARRAY
76345: GREATEREQUAL
76346: PUSH
76347: LD_VAR 0 4
76351: PPUSH
76352: LD_INT 2
76354: PPUSH
76355: CALL_OW 275
76359: PUSH
76360: LD_VAR 0 5
76364: PUSH
76365: LD_INT 2
76367: ARRAY
76368: GREATEREQUAL
76369: AND
76370: PUSH
76371: LD_VAR 0 4
76375: PPUSH
76376: LD_INT 3
76378: PPUSH
76379: CALL_OW 275
76383: PUSH
76384: LD_VAR 0 5
76388: PUSH
76389: LD_INT 3
76391: ARRAY
76392: GREATEREQUAL
76393: AND
76394: ST_TO_ADDR
// end ;
76395: LD_VAR 0 3
76399: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
76400: LD_INT 0
76402: PPUSH
76403: PPUSH
76404: PPUSH
76405: PPUSH
76406: PPUSH
76407: PPUSH
76408: PPUSH
76409: PPUSH
76410: PPUSH
76411: PPUSH
// result := false ;
76412: LD_ADDR_VAR 0 6
76416: PUSH
76417: LD_INT 0
76419: ST_TO_ADDR
// if not base or not btype or not x or not y then
76420: LD_VAR 0 1
76424: NOT
76425: PUSH
76426: LD_VAR 0 2
76430: NOT
76431: OR
76432: PUSH
76433: LD_VAR 0 3
76437: NOT
76438: OR
76439: PUSH
76440: LD_VAR 0 4
76444: NOT
76445: OR
76446: IFFALSE 76450
// exit ;
76448: GO 77059
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
76450: LD_ADDR_VAR 0 12
76454: PUSH
76455: LD_VAR 0 2
76459: PPUSH
76460: LD_VAR 0 3
76464: PPUSH
76465: LD_VAR 0 4
76469: PPUSH
76470: LD_VAR 0 5
76474: PPUSH
76475: LD_VAR 0 1
76479: PUSH
76480: LD_INT 1
76482: ARRAY
76483: PPUSH
76484: CALL_OW 248
76488: PPUSH
76489: LD_INT 0
76491: PPUSH
76492: CALL 77896 0 6
76496: ST_TO_ADDR
// if not hexes then
76497: LD_VAR 0 12
76501: NOT
76502: IFFALSE 76506
// exit ;
76504: GO 77059
// for i = 1 to hexes do
76506: LD_ADDR_VAR 0 7
76510: PUSH
76511: DOUBLE
76512: LD_INT 1
76514: DEC
76515: ST_TO_ADDR
76516: LD_VAR 0 12
76520: PUSH
76521: FOR_TO
76522: IFFALSE 77057
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
76524: LD_ADDR_VAR 0 11
76528: PUSH
76529: LD_VAR 0 12
76533: PUSH
76534: LD_VAR 0 7
76538: ARRAY
76539: PUSH
76540: LD_INT 1
76542: ARRAY
76543: PPUSH
76544: LD_VAR 0 12
76548: PUSH
76549: LD_VAR 0 7
76553: ARRAY
76554: PUSH
76555: LD_INT 2
76557: ARRAY
76558: PPUSH
76559: CALL_OW 428
76563: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
76564: LD_VAR 0 12
76568: PUSH
76569: LD_VAR 0 7
76573: ARRAY
76574: PUSH
76575: LD_INT 1
76577: ARRAY
76578: PPUSH
76579: LD_VAR 0 12
76583: PUSH
76584: LD_VAR 0 7
76588: ARRAY
76589: PUSH
76590: LD_INT 2
76592: ARRAY
76593: PPUSH
76594: CALL_OW 351
76598: PUSH
76599: LD_VAR 0 12
76603: PUSH
76604: LD_VAR 0 7
76608: ARRAY
76609: PUSH
76610: LD_INT 1
76612: ARRAY
76613: PPUSH
76614: LD_VAR 0 12
76618: PUSH
76619: LD_VAR 0 7
76623: ARRAY
76624: PUSH
76625: LD_INT 2
76627: ARRAY
76628: PPUSH
76629: CALL_OW 488
76633: NOT
76634: OR
76635: PUSH
76636: LD_VAR 0 11
76640: PPUSH
76641: CALL_OW 247
76645: PUSH
76646: LD_INT 3
76648: EQUAL
76649: OR
76650: IFFALSE 76656
// exit ;
76652: POP
76653: POP
76654: GO 77059
// if not tmp or not tmp in base then
76656: LD_VAR 0 11
76660: NOT
76661: PUSH
76662: LD_VAR 0 11
76666: PUSH
76667: LD_VAR 0 1
76671: IN
76672: NOT
76673: OR
76674: IFFALSE 76678
// continue ;
76676: GO 76521
// result := true ;
76678: LD_ADDR_VAR 0 6
76682: PUSH
76683: LD_INT 1
76685: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
76686: LD_ADDR_VAR 0 15
76690: PUSH
76691: LD_VAR 0 1
76695: PPUSH
76696: LD_INT 22
76698: PUSH
76699: LD_VAR 0 11
76703: PPUSH
76704: CALL_OW 255
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: PUSH
76713: LD_INT 2
76715: PUSH
76716: LD_INT 30
76718: PUSH
76719: LD_INT 0
76721: PUSH
76722: EMPTY
76723: LIST
76724: LIST
76725: PUSH
76726: LD_INT 30
76728: PUSH
76729: LD_INT 1
76731: PUSH
76732: EMPTY
76733: LIST
76734: LIST
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: LIST
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PPUSH
76745: CALL_OW 72
76749: ST_TO_ADDR
// if dep then
76750: LD_VAR 0 15
76754: IFFALSE 76890
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
76756: LD_ADDR_VAR 0 14
76760: PUSH
76761: LD_VAR 0 15
76765: PUSH
76766: LD_INT 1
76768: ARRAY
76769: PPUSH
76770: CALL_OW 250
76774: PPUSH
76775: LD_VAR 0 15
76779: PUSH
76780: LD_INT 1
76782: ARRAY
76783: PPUSH
76784: CALL_OW 254
76788: PPUSH
76789: LD_INT 5
76791: PPUSH
76792: CALL_OW 272
76796: PUSH
76797: LD_VAR 0 15
76801: PUSH
76802: LD_INT 1
76804: ARRAY
76805: PPUSH
76806: CALL_OW 251
76810: PPUSH
76811: LD_VAR 0 15
76815: PUSH
76816: LD_INT 1
76818: ARRAY
76819: PPUSH
76820: CALL_OW 254
76824: PPUSH
76825: LD_INT 5
76827: PPUSH
76828: CALL_OW 273
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
76837: LD_VAR 0 14
76841: PUSH
76842: LD_INT 1
76844: ARRAY
76845: PPUSH
76846: LD_VAR 0 14
76850: PUSH
76851: LD_INT 2
76853: ARRAY
76854: PPUSH
76855: CALL_OW 488
76859: IFFALSE 76890
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
76861: LD_VAR 0 11
76865: PPUSH
76866: LD_VAR 0 14
76870: PUSH
76871: LD_INT 1
76873: ARRAY
76874: PPUSH
76875: LD_VAR 0 14
76879: PUSH
76880: LD_INT 2
76882: ARRAY
76883: PPUSH
76884: CALL_OW 111
// continue ;
76888: GO 76521
// end ; end ; r := GetDir ( tmp ) ;
76890: LD_ADDR_VAR 0 13
76894: PUSH
76895: LD_VAR 0 11
76899: PPUSH
76900: CALL_OW 254
76904: ST_TO_ADDR
// if r = 5 then
76905: LD_VAR 0 13
76909: PUSH
76910: LD_INT 5
76912: EQUAL
76913: IFFALSE 76923
// r := 0 ;
76915: LD_ADDR_VAR 0 13
76919: PUSH
76920: LD_INT 0
76922: ST_TO_ADDR
// for j = r to 5 do
76923: LD_ADDR_VAR 0 8
76927: PUSH
76928: DOUBLE
76929: LD_VAR 0 13
76933: DEC
76934: ST_TO_ADDR
76935: LD_INT 5
76937: PUSH
76938: FOR_TO
76939: IFFALSE 77053
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
76941: LD_ADDR_VAR 0 9
76945: PUSH
76946: LD_VAR 0 11
76950: PPUSH
76951: CALL_OW 250
76955: PPUSH
76956: LD_VAR 0 8
76960: PPUSH
76961: LD_INT 2
76963: PPUSH
76964: CALL_OW 272
76968: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
76969: LD_ADDR_VAR 0 10
76973: PUSH
76974: LD_VAR 0 11
76978: PPUSH
76979: CALL_OW 251
76983: PPUSH
76984: LD_VAR 0 8
76988: PPUSH
76989: LD_INT 2
76991: PPUSH
76992: CALL_OW 273
76996: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
76997: LD_VAR 0 9
77001: PPUSH
77002: LD_VAR 0 10
77006: PPUSH
77007: CALL_OW 488
77011: PUSH
77012: LD_VAR 0 9
77016: PPUSH
77017: LD_VAR 0 10
77021: PPUSH
77022: CALL_OW 428
77026: NOT
77027: AND
77028: IFFALSE 77051
// begin ComMoveXY ( tmp , _x , _y ) ;
77030: LD_VAR 0 11
77034: PPUSH
77035: LD_VAR 0 9
77039: PPUSH
77040: LD_VAR 0 10
77044: PPUSH
77045: CALL_OW 111
// break ;
77049: GO 77053
// end ; end ;
77051: GO 76938
77053: POP
77054: POP
// end ;
77055: GO 76521
77057: POP
77058: POP
// end ;
77059: LD_VAR 0 6
77063: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
77064: LD_INT 0
77066: PPUSH
77067: PPUSH
77068: PPUSH
77069: PPUSH
77070: PPUSH
77071: PPUSH
77072: PPUSH
77073: PPUSH
77074: PPUSH
77075: PPUSH
// result := false ;
77076: LD_ADDR_VAR 0 6
77080: PUSH
77081: LD_INT 0
77083: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
77084: LD_VAR 0 1
77088: NOT
77089: PUSH
77090: LD_VAR 0 1
77094: PPUSH
77095: CALL_OW 266
77099: PUSH
77100: LD_INT 0
77102: PUSH
77103: LD_INT 1
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: IN
77110: NOT
77111: OR
77112: PUSH
77113: LD_VAR 0 2
77117: NOT
77118: OR
77119: PUSH
77120: LD_VAR 0 5
77124: PUSH
77125: LD_INT 0
77127: PUSH
77128: LD_INT 1
77130: PUSH
77131: LD_INT 2
77133: PUSH
77134: LD_INT 3
77136: PUSH
77137: LD_INT 4
77139: PUSH
77140: LD_INT 5
77142: PUSH
77143: EMPTY
77144: LIST
77145: LIST
77146: LIST
77147: LIST
77148: LIST
77149: LIST
77150: IN
77151: NOT
77152: OR
77153: PUSH
77154: LD_VAR 0 3
77158: PPUSH
77159: LD_VAR 0 4
77163: PPUSH
77164: CALL_OW 488
77168: NOT
77169: OR
77170: IFFALSE 77174
// exit ;
77172: GO 77891
// pom := GetBase ( depot ) ;
77174: LD_ADDR_VAR 0 10
77178: PUSH
77179: LD_VAR 0 1
77183: PPUSH
77184: CALL_OW 274
77188: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
77189: LD_ADDR_VAR 0 11
77193: PUSH
77194: LD_VAR 0 2
77198: PPUSH
77199: LD_VAR 0 1
77203: PPUSH
77204: CALL_OW 248
77208: PPUSH
77209: CALL_OW 450
77213: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
77214: LD_VAR 0 10
77218: PPUSH
77219: LD_INT 1
77221: PPUSH
77222: CALL_OW 275
77226: PUSH
77227: LD_VAR 0 11
77231: PUSH
77232: LD_INT 1
77234: ARRAY
77235: GREATEREQUAL
77236: PUSH
77237: LD_VAR 0 10
77241: PPUSH
77242: LD_INT 2
77244: PPUSH
77245: CALL_OW 275
77249: PUSH
77250: LD_VAR 0 11
77254: PUSH
77255: LD_INT 2
77257: ARRAY
77258: GREATEREQUAL
77259: AND
77260: PUSH
77261: LD_VAR 0 10
77265: PPUSH
77266: LD_INT 3
77268: PPUSH
77269: CALL_OW 275
77273: PUSH
77274: LD_VAR 0 11
77278: PUSH
77279: LD_INT 3
77281: ARRAY
77282: GREATEREQUAL
77283: AND
77284: NOT
77285: IFFALSE 77289
// exit ;
77287: GO 77891
// if GetBType ( depot ) = b_depot then
77289: LD_VAR 0 1
77293: PPUSH
77294: CALL_OW 266
77298: PUSH
77299: LD_INT 0
77301: EQUAL
77302: IFFALSE 77314
// dist := 28 else
77304: LD_ADDR_VAR 0 14
77308: PUSH
77309: LD_INT 28
77311: ST_TO_ADDR
77312: GO 77322
// dist := 36 ;
77314: LD_ADDR_VAR 0 14
77318: PUSH
77319: LD_INT 36
77321: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
77322: LD_VAR 0 1
77326: PPUSH
77327: LD_VAR 0 3
77331: PPUSH
77332: LD_VAR 0 4
77336: PPUSH
77337: CALL_OW 297
77341: PUSH
77342: LD_VAR 0 14
77346: GREATER
77347: IFFALSE 77351
// exit ;
77349: GO 77891
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
77351: LD_ADDR_VAR 0 12
77355: PUSH
77356: LD_VAR 0 2
77360: PPUSH
77361: LD_VAR 0 3
77365: PPUSH
77366: LD_VAR 0 4
77370: PPUSH
77371: LD_VAR 0 5
77375: PPUSH
77376: LD_VAR 0 1
77380: PPUSH
77381: CALL_OW 248
77385: PPUSH
77386: LD_INT 0
77388: PPUSH
77389: CALL 77896 0 6
77393: ST_TO_ADDR
// if not hexes then
77394: LD_VAR 0 12
77398: NOT
77399: IFFALSE 77403
// exit ;
77401: GO 77891
// hex := GetHexInfo ( x , y ) ;
77403: LD_ADDR_VAR 0 15
77407: PUSH
77408: LD_VAR 0 3
77412: PPUSH
77413: LD_VAR 0 4
77417: PPUSH
77418: CALL_OW 546
77422: ST_TO_ADDR
// if hex [ 1 ] then
77423: LD_VAR 0 15
77427: PUSH
77428: LD_INT 1
77430: ARRAY
77431: IFFALSE 77435
// exit ;
77433: GO 77891
// height := hex [ 2 ] ;
77435: LD_ADDR_VAR 0 13
77439: PUSH
77440: LD_VAR 0 15
77444: PUSH
77445: LD_INT 2
77447: ARRAY
77448: ST_TO_ADDR
// for i = 1 to hexes do
77449: LD_ADDR_VAR 0 7
77453: PUSH
77454: DOUBLE
77455: LD_INT 1
77457: DEC
77458: ST_TO_ADDR
77459: LD_VAR 0 12
77463: PUSH
77464: FOR_TO
77465: IFFALSE 77795
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
77467: LD_VAR 0 12
77471: PUSH
77472: LD_VAR 0 7
77476: ARRAY
77477: PUSH
77478: LD_INT 1
77480: ARRAY
77481: PPUSH
77482: LD_VAR 0 12
77486: PUSH
77487: LD_VAR 0 7
77491: ARRAY
77492: PUSH
77493: LD_INT 2
77495: ARRAY
77496: PPUSH
77497: CALL_OW 488
77501: NOT
77502: PUSH
77503: LD_VAR 0 12
77507: PUSH
77508: LD_VAR 0 7
77512: ARRAY
77513: PUSH
77514: LD_INT 1
77516: ARRAY
77517: PPUSH
77518: LD_VAR 0 12
77522: PUSH
77523: LD_VAR 0 7
77527: ARRAY
77528: PUSH
77529: LD_INT 2
77531: ARRAY
77532: PPUSH
77533: CALL_OW 428
77537: PUSH
77538: LD_INT 0
77540: GREATER
77541: OR
77542: PUSH
77543: LD_VAR 0 12
77547: PUSH
77548: LD_VAR 0 7
77552: ARRAY
77553: PUSH
77554: LD_INT 1
77556: ARRAY
77557: PPUSH
77558: LD_VAR 0 12
77562: PUSH
77563: LD_VAR 0 7
77567: ARRAY
77568: PUSH
77569: LD_INT 2
77571: ARRAY
77572: PPUSH
77573: CALL_OW 351
77577: OR
77578: IFFALSE 77584
// exit ;
77580: POP
77581: POP
77582: GO 77891
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77584: LD_ADDR_VAR 0 8
77588: PUSH
77589: LD_VAR 0 12
77593: PUSH
77594: LD_VAR 0 7
77598: ARRAY
77599: PUSH
77600: LD_INT 1
77602: ARRAY
77603: PPUSH
77604: LD_VAR 0 12
77608: PUSH
77609: LD_VAR 0 7
77613: ARRAY
77614: PUSH
77615: LD_INT 2
77617: ARRAY
77618: PPUSH
77619: CALL_OW 546
77623: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
77624: LD_VAR 0 8
77628: PUSH
77629: LD_INT 1
77631: ARRAY
77632: PUSH
77633: LD_VAR 0 8
77637: PUSH
77638: LD_INT 2
77640: ARRAY
77641: PUSH
77642: LD_VAR 0 13
77646: PUSH
77647: LD_INT 2
77649: PLUS
77650: GREATER
77651: OR
77652: PUSH
77653: LD_VAR 0 8
77657: PUSH
77658: LD_INT 2
77660: ARRAY
77661: PUSH
77662: LD_VAR 0 13
77666: PUSH
77667: LD_INT 2
77669: MINUS
77670: LESS
77671: OR
77672: PUSH
77673: LD_VAR 0 8
77677: PUSH
77678: LD_INT 3
77680: ARRAY
77681: PUSH
77682: LD_INT 0
77684: PUSH
77685: LD_INT 8
77687: PUSH
77688: LD_INT 9
77690: PUSH
77691: LD_INT 10
77693: PUSH
77694: LD_INT 11
77696: PUSH
77697: LD_INT 12
77699: PUSH
77700: LD_INT 13
77702: PUSH
77703: LD_INT 16
77705: PUSH
77706: LD_INT 17
77708: PUSH
77709: LD_INT 18
77711: PUSH
77712: LD_INT 19
77714: PUSH
77715: LD_INT 20
77717: PUSH
77718: LD_INT 21
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: LIST
77725: LIST
77726: LIST
77727: LIST
77728: LIST
77729: LIST
77730: LIST
77731: LIST
77732: LIST
77733: LIST
77734: LIST
77735: IN
77736: NOT
77737: OR
77738: PUSH
77739: LD_VAR 0 8
77743: PUSH
77744: LD_INT 5
77746: ARRAY
77747: NOT
77748: OR
77749: PUSH
77750: LD_VAR 0 8
77754: PUSH
77755: LD_INT 6
77757: ARRAY
77758: PUSH
77759: LD_INT 1
77761: PUSH
77762: LD_INT 2
77764: PUSH
77765: LD_INT 7
77767: PUSH
77768: LD_INT 9
77770: PUSH
77771: LD_INT 10
77773: PUSH
77774: LD_INT 11
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: LIST
77781: LIST
77782: LIST
77783: LIST
77784: IN
77785: NOT
77786: OR
77787: IFFALSE 77793
// exit ;
77789: POP
77790: POP
77791: GO 77891
// end ;
77793: GO 77464
77795: POP
77796: POP
// side := GetSide ( depot ) ;
77797: LD_ADDR_VAR 0 9
77801: PUSH
77802: LD_VAR 0 1
77806: PPUSH
77807: CALL_OW 255
77811: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
77812: LD_VAR 0 9
77816: PPUSH
77817: LD_VAR 0 3
77821: PPUSH
77822: LD_VAR 0 4
77826: PPUSH
77827: LD_INT 20
77829: PPUSH
77830: CALL 70545 0 4
77834: PUSH
77835: LD_INT 4
77837: ARRAY
77838: IFFALSE 77842
// exit ;
77840: GO 77891
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
77842: LD_VAR 0 2
77846: PUSH
77847: LD_INT 29
77849: PUSH
77850: LD_INT 30
77852: PUSH
77853: EMPTY
77854: LIST
77855: LIST
77856: IN
77857: PUSH
77858: LD_VAR 0 3
77862: PPUSH
77863: LD_VAR 0 4
77867: PPUSH
77868: LD_VAR 0 9
77872: PPUSH
77873: CALL_OW 440
77877: NOT
77878: AND
77879: IFFALSE 77883
// exit ;
77881: GO 77891
// result := true ;
77883: LD_ADDR_VAR 0 6
77887: PUSH
77888: LD_INT 1
77890: ST_TO_ADDR
// end ;
77891: LD_VAR 0 6
77895: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
77896: LD_INT 0
77898: PPUSH
77899: PPUSH
77900: PPUSH
77901: PPUSH
77902: PPUSH
77903: PPUSH
77904: PPUSH
77905: PPUSH
77906: PPUSH
77907: PPUSH
77908: PPUSH
77909: PPUSH
77910: PPUSH
77911: PPUSH
77912: PPUSH
77913: PPUSH
77914: PPUSH
77915: PPUSH
77916: PPUSH
77917: PPUSH
77918: PPUSH
77919: PPUSH
77920: PPUSH
77921: PPUSH
77922: PPUSH
77923: PPUSH
77924: PPUSH
77925: PPUSH
77926: PPUSH
77927: PPUSH
77928: PPUSH
77929: PPUSH
77930: PPUSH
77931: PPUSH
77932: PPUSH
77933: PPUSH
77934: PPUSH
77935: PPUSH
77936: PPUSH
77937: PPUSH
77938: PPUSH
77939: PPUSH
77940: PPUSH
77941: PPUSH
77942: PPUSH
77943: PPUSH
77944: PPUSH
77945: PPUSH
77946: PPUSH
77947: PPUSH
77948: PPUSH
77949: PPUSH
77950: PPUSH
77951: PPUSH
77952: PPUSH
77953: PPUSH
77954: PPUSH
77955: PPUSH
// result = [ ] ;
77956: LD_ADDR_VAR 0 7
77960: PUSH
77961: EMPTY
77962: ST_TO_ADDR
// temp_list = [ ] ;
77963: LD_ADDR_VAR 0 9
77967: PUSH
77968: EMPTY
77969: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
77970: LD_VAR 0 4
77974: PUSH
77975: LD_INT 0
77977: PUSH
77978: LD_INT 1
77980: PUSH
77981: LD_INT 2
77983: PUSH
77984: LD_INT 3
77986: PUSH
77987: LD_INT 4
77989: PUSH
77990: LD_INT 5
77992: PUSH
77993: EMPTY
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: IN
78001: NOT
78002: PUSH
78003: LD_VAR 0 1
78007: PUSH
78008: LD_INT 0
78010: PUSH
78011: LD_INT 1
78013: PUSH
78014: EMPTY
78015: LIST
78016: LIST
78017: IN
78018: PUSH
78019: LD_VAR 0 5
78023: PUSH
78024: LD_INT 1
78026: PUSH
78027: LD_INT 2
78029: PUSH
78030: LD_INT 3
78032: PUSH
78033: EMPTY
78034: LIST
78035: LIST
78036: LIST
78037: IN
78038: NOT
78039: AND
78040: OR
78041: IFFALSE 78045
// exit ;
78043: GO 96436
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
78045: LD_VAR 0 1
78049: PUSH
78050: LD_INT 6
78052: PUSH
78053: LD_INT 7
78055: PUSH
78056: LD_INT 8
78058: PUSH
78059: LD_INT 13
78061: PUSH
78062: LD_INT 12
78064: PUSH
78065: LD_INT 15
78067: PUSH
78068: LD_INT 11
78070: PUSH
78071: LD_INT 14
78073: PUSH
78074: LD_INT 10
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: LIST
78081: LIST
78082: LIST
78083: LIST
78084: LIST
78085: LIST
78086: LIST
78087: IN
78088: IFFALSE 78098
// btype = b_lab ;
78090: LD_ADDR_VAR 0 1
78094: PUSH
78095: LD_INT 6
78097: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
78098: LD_VAR 0 6
78102: PUSH
78103: LD_INT 0
78105: PUSH
78106: LD_INT 1
78108: PUSH
78109: LD_INT 2
78111: PUSH
78112: EMPTY
78113: LIST
78114: LIST
78115: LIST
78116: IN
78117: NOT
78118: PUSH
78119: LD_VAR 0 1
78123: PUSH
78124: LD_INT 0
78126: PUSH
78127: LD_INT 1
78129: PUSH
78130: LD_INT 2
78132: PUSH
78133: LD_INT 3
78135: PUSH
78136: LD_INT 6
78138: PUSH
78139: LD_INT 36
78141: PUSH
78142: LD_INT 4
78144: PUSH
78145: LD_INT 5
78147: PUSH
78148: LD_INT 31
78150: PUSH
78151: LD_INT 32
78153: PUSH
78154: LD_INT 33
78156: PUSH
78157: EMPTY
78158: LIST
78159: LIST
78160: LIST
78161: LIST
78162: LIST
78163: LIST
78164: LIST
78165: LIST
78166: LIST
78167: LIST
78168: LIST
78169: IN
78170: NOT
78171: PUSH
78172: LD_VAR 0 6
78176: PUSH
78177: LD_INT 1
78179: EQUAL
78180: AND
78181: OR
78182: PUSH
78183: LD_VAR 0 1
78187: PUSH
78188: LD_INT 2
78190: PUSH
78191: LD_INT 3
78193: PUSH
78194: EMPTY
78195: LIST
78196: LIST
78197: IN
78198: NOT
78199: PUSH
78200: LD_VAR 0 6
78204: PUSH
78205: LD_INT 2
78207: EQUAL
78208: AND
78209: OR
78210: IFFALSE 78220
// mode = 0 ;
78212: LD_ADDR_VAR 0 6
78216: PUSH
78217: LD_INT 0
78219: ST_TO_ADDR
// case mode of 0 :
78220: LD_VAR 0 6
78224: PUSH
78225: LD_INT 0
78227: DOUBLE
78228: EQUAL
78229: IFTRUE 78233
78231: GO 89686
78233: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
78234: LD_ADDR_VAR 0 11
78238: PUSH
78239: LD_INT 0
78241: PUSH
78242: LD_INT 0
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 0
78251: PUSH
78252: LD_INT 1
78254: NEG
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: LD_INT 1
78262: PUSH
78263: LD_INT 0
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: PUSH
78270: LD_INT 1
78272: PUSH
78273: LD_INT 1
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: LD_INT 0
78282: PUSH
78283: LD_INT 1
78285: PUSH
78286: EMPTY
78287: LIST
78288: LIST
78289: PUSH
78290: LD_INT 1
78292: NEG
78293: PUSH
78294: LD_INT 0
78296: PUSH
78297: EMPTY
78298: LIST
78299: LIST
78300: PUSH
78301: LD_INT 1
78303: NEG
78304: PUSH
78305: LD_INT 1
78307: NEG
78308: PUSH
78309: EMPTY
78310: LIST
78311: LIST
78312: PUSH
78313: LD_INT 1
78315: NEG
78316: PUSH
78317: LD_INT 2
78319: NEG
78320: PUSH
78321: EMPTY
78322: LIST
78323: LIST
78324: PUSH
78325: LD_INT 0
78327: PUSH
78328: LD_INT 2
78330: NEG
78331: PUSH
78332: EMPTY
78333: LIST
78334: LIST
78335: PUSH
78336: LD_INT 1
78338: PUSH
78339: LD_INT 1
78341: NEG
78342: PUSH
78343: EMPTY
78344: LIST
78345: LIST
78346: PUSH
78347: LD_INT 1
78349: PUSH
78350: LD_INT 2
78352: PUSH
78353: EMPTY
78354: LIST
78355: LIST
78356: PUSH
78357: LD_INT 0
78359: PUSH
78360: LD_INT 2
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: PUSH
78367: LD_INT 1
78369: NEG
78370: PUSH
78371: LD_INT 1
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: PUSH
78378: LD_INT 1
78380: PUSH
78381: LD_INT 3
78383: PUSH
78384: EMPTY
78385: LIST
78386: LIST
78387: PUSH
78388: LD_INT 0
78390: PUSH
78391: LD_INT 3
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: PUSH
78398: LD_INT 1
78400: NEG
78401: PUSH
78402: LD_INT 2
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: EMPTY
78410: LIST
78411: LIST
78412: LIST
78413: LIST
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: LIST
78423: LIST
78424: LIST
78425: LIST
78426: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
78427: LD_ADDR_VAR 0 12
78431: PUSH
78432: LD_INT 0
78434: PUSH
78435: LD_INT 0
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 0
78444: PUSH
78445: LD_INT 1
78447: NEG
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: LD_INT 1
78455: PUSH
78456: LD_INT 0
78458: PUSH
78459: EMPTY
78460: LIST
78461: LIST
78462: PUSH
78463: LD_INT 1
78465: PUSH
78466: LD_INT 1
78468: PUSH
78469: EMPTY
78470: LIST
78471: LIST
78472: PUSH
78473: LD_INT 0
78475: PUSH
78476: LD_INT 1
78478: PUSH
78479: EMPTY
78480: LIST
78481: LIST
78482: PUSH
78483: LD_INT 1
78485: NEG
78486: PUSH
78487: LD_INT 0
78489: PUSH
78490: EMPTY
78491: LIST
78492: LIST
78493: PUSH
78494: LD_INT 1
78496: NEG
78497: PUSH
78498: LD_INT 1
78500: NEG
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 1
78508: PUSH
78509: LD_INT 1
78511: NEG
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: PUSH
78517: LD_INT 2
78519: PUSH
78520: LD_INT 0
78522: PUSH
78523: EMPTY
78524: LIST
78525: LIST
78526: PUSH
78527: LD_INT 2
78529: PUSH
78530: LD_INT 1
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 1
78539: NEG
78540: PUSH
78541: LD_INT 1
78543: PUSH
78544: EMPTY
78545: LIST
78546: LIST
78547: PUSH
78548: LD_INT 2
78550: NEG
78551: PUSH
78552: LD_INT 0
78554: PUSH
78555: EMPTY
78556: LIST
78557: LIST
78558: PUSH
78559: LD_INT 2
78561: NEG
78562: PUSH
78563: LD_INT 1
78565: NEG
78566: PUSH
78567: EMPTY
78568: LIST
78569: LIST
78570: PUSH
78571: LD_INT 2
78573: NEG
78574: PUSH
78575: LD_INT 1
78577: PUSH
78578: EMPTY
78579: LIST
78580: LIST
78581: PUSH
78582: LD_INT 3
78584: NEG
78585: PUSH
78586: LD_INT 0
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: LD_INT 3
78595: NEG
78596: PUSH
78597: LD_INT 1
78599: NEG
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: EMPTY
78606: LIST
78607: LIST
78608: LIST
78609: LIST
78610: LIST
78611: LIST
78612: LIST
78613: LIST
78614: LIST
78615: LIST
78616: LIST
78617: LIST
78618: LIST
78619: LIST
78620: LIST
78621: LIST
78622: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
78623: LD_ADDR_VAR 0 13
78627: PUSH
78628: LD_INT 0
78630: PUSH
78631: LD_INT 0
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PUSH
78638: LD_INT 0
78640: PUSH
78641: LD_INT 1
78643: NEG
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 1
78651: PUSH
78652: LD_INT 0
78654: PUSH
78655: EMPTY
78656: LIST
78657: LIST
78658: PUSH
78659: LD_INT 1
78661: PUSH
78662: LD_INT 1
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 0
78671: PUSH
78672: LD_INT 1
78674: PUSH
78675: EMPTY
78676: LIST
78677: LIST
78678: PUSH
78679: LD_INT 1
78681: NEG
78682: PUSH
78683: LD_INT 0
78685: PUSH
78686: EMPTY
78687: LIST
78688: LIST
78689: PUSH
78690: LD_INT 1
78692: NEG
78693: PUSH
78694: LD_INT 1
78696: NEG
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: PUSH
78702: LD_INT 1
78704: NEG
78705: PUSH
78706: LD_INT 2
78708: NEG
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 2
78716: PUSH
78717: LD_INT 1
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: PUSH
78724: LD_INT 2
78726: PUSH
78727: LD_INT 2
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: PUSH
78734: LD_INT 1
78736: PUSH
78737: LD_INT 2
78739: PUSH
78740: EMPTY
78741: LIST
78742: LIST
78743: PUSH
78744: LD_INT 2
78746: NEG
78747: PUSH
78748: LD_INT 1
78750: NEG
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: LD_INT 2
78758: NEG
78759: PUSH
78760: LD_INT 2
78762: NEG
78763: PUSH
78764: EMPTY
78765: LIST
78766: LIST
78767: PUSH
78768: LD_INT 2
78770: NEG
78771: PUSH
78772: LD_INT 3
78774: NEG
78775: PUSH
78776: EMPTY
78777: LIST
78778: LIST
78779: PUSH
78780: LD_INT 3
78782: NEG
78783: PUSH
78784: LD_INT 2
78786: NEG
78787: PUSH
78788: EMPTY
78789: LIST
78790: LIST
78791: PUSH
78792: LD_INT 3
78794: NEG
78795: PUSH
78796: LD_INT 3
78798: NEG
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: LIST
78811: LIST
78812: LIST
78813: LIST
78814: LIST
78815: LIST
78816: LIST
78817: LIST
78818: LIST
78819: LIST
78820: LIST
78821: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
78822: LD_ADDR_VAR 0 14
78826: PUSH
78827: LD_INT 0
78829: PUSH
78830: LD_INT 0
78832: PUSH
78833: EMPTY
78834: LIST
78835: LIST
78836: PUSH
78837: LD_INT 0
78839: PUSH
78840: LD_INT 1
78842: NEG
78843: PUSH
78844: EMPTY
78845: LIST
78846: LIST
78847: PUSH
78848: LD_INT 1
78850: PUSH
78851: LD_INT 0
78853: PUSH
78854: EMPTY
78855: LIST
78856: LIST
78857: PUSH
78858: LD_INT 1
78860: PUSH
78861: LD_INT 1
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 0
78870: PUSH
78871: LD_INT 1
78873: PUSH
78874: EMPTY
78875: LIST
78876: LIST
78877: PUSH
78878: LD_INT 1
78880: NEG
78881: PUSH
78882: LD_INT 0
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: PUSH
78889: LD_INT 1
78891: NEG
78892: PUSH
78893: LD_INT 1
78895: NEG
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 1
78903: NEG
78904: PUSH
78905: LD_INT 2
78907: NEG
78908: PUSH
78909: EMPTY
78910: LIST
78911: LIST
78912: PUSH
78913: LD_INT 0
78915: PUSH
78916: LD_INT 2
78918: NEG
78919: PUSH
78920: EMPTY
78921: LIST
78922: LIST
78923: PUSH
78924: LD_INT 1
78926: PUSH
78927: LD_INT 1
78929: NEG
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: LD_INT 1
78937: PUSH
78938: LD_INT 2
78940: PUSH
78941: EMPTY
78942: LIST
78943: LIST
78944: PUSH
78945: LD_INT 0
78947: PUSH
78948: LD_INT 2
78950: PUSH
78951: EMPTY
78952: LIST
78953: LIST
78954: PUSH
78955: LD_INT 1
78957: NEG
78958: PUSH
78959: LD_INT 1
78961: PUSH
78962: EMPTY
78963: LIST
78964: LIST
78965: PUSH
78966: LD_INT 1
78968: NEG
78969: PUSH
78970: LD_INT 3
78972: NEG
78973: PUSH
78974: EMPTY
78975: LIST
78976: LIST
78977: PUSH
78978: LD_INT 0
78980: PUSH
78981: LD_INT 3
78983: NEG
78984: PUSH
78985: EMPTY
78986: LIST
78987: LIST
78988: PUSH
78989: LD_INT 1
78991: PUSH
78992: LD_INT 2
78994: NEG
78995: PUSH
78996: EMPTY
78997: LIST
78998: LIST
78999: PUSH
79000: EMPTY
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: LIST
79006: LIST
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: LIST
79012: LIST
79013: LIST
79014: LIST
79015: LIST
79016: LIST
79017: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
79018: LD_ADDR_VAR 0 15
79022: PUSH
79023: LD_INT 0
79025: PUSH
79026: LD_INT 0
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 0
79035: PUSH
79036: LD_INT 1
79038: NEG
79039: PUSH
79040: EMPTY
79041: LIST
79042: LIST
79043: PUSH
79044: LD_INT 1
79046: PUSH
79047: LD_INT 0
79049: PUSH
79050: EMPTY
79051: LIST
79052: LIST
79053: PUSH
79054: LD_INT 1
79056: PUSH
79057: LD_INT 1
79059: PUSH
79060: EMPTY
79061: LIST
79062: LIST
79063: PUSH
79064: LD_INT 0
79066: PUSH
79067: LD_INT 1
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 1
79076: NEG
79077: PUSH
79078: LD_INT 0
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 1
79087: NEG
79088: PUSH
79089: LD_INT 1
79091: NEG
79092: PUSH
79093: EMPTY
79094: LIST
79095: LIST
79096: PUSH
79097: LD_INT 1
79099: PUSH
79100: LD_INT 1
79102: NEG
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: LD_INT 2
79110: PUSH
79111: LD_INT 0
79113: PUSH
79114: EMPTY
79115: LIST
79116: LIST
79117: PUSH
79118: LD_INT 2
79120: PUSH
79121: LD_INT 1
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: PUSH
79128: LD_INT 1
79130: NEG
79131: PUSH
79132: LD_INT 1
79134: PUSH
79135: EMPTY
79136: LIST
79137: LIST
79138: PUSH
79139: LD_INT 2
79141: NEG
79142: PUSH
79143: LD_INT 0
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: PUSH
79150: LD_INT 2
79152: NEG
79153: PUSH
79154: LD_INT 1
79156: NEG
79157: PUSH
79158: EMPTY
79159: LIST
79160: LIST
79161: PUSH
79162: LD_INT 2
79164: PUSH
79165: LD_INT 1
79167: NEG
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 3
79175: PUSH
79176: LD_INT 0
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: PUSH
79183: LD_INT 3
79185: PUSH
79186: LD_INT 1
79188: PUSH
79189: EMPTY
79190: LIST
79191: LIST
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: LIST
79197: LIST
79198: LIST
79199: LIST
79200: LIST
79201: LIST
79202: LIST
79203: LIST
79204: LIST
79205: LIST
79206: LIST
79207: LIST
79208: LIST
79209: LIST
79210: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
79211: LD_ADDR_VAR 0 16
79215: PUSH
79216: LD_INT 0
79218: PUSH
79219: LD_INT 0
79221: PUSH
79222: EMPTY
79223: LIST
79224: LIST
79225: PUSH
79226: LD_INT 0
79228: PUSH
79229: LD_INT 1
79231: NEG
79232: PUSH
79233: EMPTY
79234: LIST
79235: LIST
79236: PUSH
79237: LD_INT 1
79239: PUSH
79240: LD_INT 0
79242: PUSH
79243: EMPTY
79244: LIST
79245: LIST
79246: PUSH
79247: LD_INT 1
79249: PUSH
79250: LD_INT 1
79252: PUSH
79253: EMPTY
79254: LIST
79255: LIST
79256: PUSH
79257: LD_INT 0
79259: PUSH
79260: LD_INT 1
79262: PUSH
79263: EMPTY
79264: LIST
79265: LIST
79266: PUSH
79267: LD_INT 1
79269: NEG
79270: PUSH
79271: LD_INT 0
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: LD_INT 1
79280: NEG
79281: PUSH
79282: LD_INT 1
79284: NEG
79285: PUSH
79286: EMPTY
79287: LIST
79288: LIST
79289: PUSH
79290: LD_INT 1
79292: NEG
79293: PUSH
79294: LD_INT 2
79296: NEG
79297: PUSH
79298: EMPTY
79299: LIST
79300: LIST
79301: PUSH
79302: LD_INT 2
79304: PUSH
79305: LD_INT 1
79307: PUSH
79308: EMPTY
79309: LIST
79310: LIST
79311: PUSH
79312: LD_INT 2
79314: PUSH
79315: LD_INT 2
79317: PUSH
79318: EMPTY
79319: LIST
79320: LIST
79321: PUSH
79322: LD_INT 1
79324: PUSH
79325: LD_INT 2
79327: PUSH
79328: EMPTY
79329: LIST
79330: LIST
79331: PUSH
79332: LD_INT 2
79334: NEG
79335: PUSH
79336: LD_INT 1
79338: NEG
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PUSH
79344: LD_INT 2
79346: NEG
79347: PUSH
79348: LD_INT 2
79350: NEG
79351: PUSH
79352: EMPTY
79353: LIST
79354: LIST
79355: PUSH
79356: LD_INT 3
79358: PUSH
79359: LD_INT 2
79361: PUSH
79362: EMPTY
79363: LIST
79364: LIST
79365: PUSH
79366: LD_INT 3
79368: PUSH
79369: LD_INT 3
79371: PUSH
79372: EMPTY
79373: LIST
79374: LIST
79375: PUSH
79376: LD_INT 2
79378: PUSH
79379: LD_INT 3
79381: PUSH
79382: EMPTY
79383: LIST
79384: LIST
79385: PUSH
79386: EMPTY
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: LIST
79399: LIST
79400: LIST
79401: LIST
79402: LIST
79403: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79404: LD_ADDR_VAR 0 17
79408: PUSH
79409: LD_INT 0
79411: PUSH
79412: LD_INT 0
79414: PUSH
79415: EMPTY
79416: LIST
79417: LIST
79418: PUSH
79419: LD_INT 0
79421: PUSH
79422: LD_INT 1
79424: NEG
79425: PUSH
79426: EMPTY
79427: LIST
79428: LIST
79429: PUSH
79430: LD_INT 1
79432: PUSH
79433: LD_INT 0
79435: PUSH
79436: EMPTY
79437: LIST
79438: LIST
79439: PUSH
79440: LD_INT 1
79442: PUSH
79443: LD_INT 1
79445: PUSH
79446: EMPTY
79447: LIST
79448: LIST
79449: PUSH
79450: LD_INT 0
79452: PUSH
79453: LD_INT 1
79455: PUSH
79456: EMPTY
79457: LIST
79458: LIST
79459: PUSH
79460: LD_INT 1
79462: NEG
79463: PUSH
79464: LD_INT 0
79466: PUSH
79467: EMPTY
79468: LIST
79469: LIST
79470: PUSH
79471: LD_INT 1
79473: NEG
79474: PUSH
79475: LD_INT 1
79477: NEG
79478: PUSH
79479: EMPTY
79480: LIST
79481: LIST
79482: PUSH
79483: LD_INT 1
79485: NEG
79486: PUSH
79487: LD_INT 2
79489: NEG
79490: PUSH
79491: EMPTY
79492: LIST
79493: LIST
79494: PUSH
79495: LD_INT 0
79497: PUSH
79498: LD_INT 2
79500: NEG
79501: PUSH
79502: EMPTY
79503: LIST
79504: LIST
79505: PUSH
79506: LD_INT 1
79508: PUSH
79509: LD_INT 1
79511: NEG
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 2
79519: PUSH
79520: LD_INT 0
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 2
79529: PUSH
79530: LD_INT 1
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PUSH
79537: LD_INT 2
79539: PUSH
79540: LD_INT 2
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PUSH
79547: LD_INT 1
79549: PUSH
79550: LD_INT 2
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PUSH
79557: LD_INT 0
79559: PUSH
79560: LD_INT 2
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 1
79569: NEG
79570: PUSH
79571: LD_INT 1
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: PUSH
79578: LD_INT 2
79580: NEG
79581: PUSH
79582: LD_INT 0
79584: PUSH
79585: EMPTY
79586: LIST
79587: LIST
79588: PUSH
79589: LD_INT 2
79591: NEG
79592: PUSH
79593: LD_INT 1
79595: NEG
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PUSH
79601: LD_INT 2
79603: NEG
79604: PUSH
79605: LD_INT 2
79607: NEG
79608: PUSH
79609: EMPTY
79610: LIST
79611: LIST
79612: PUSH
79613: EMPTY
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: LIST
79633: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79634: LD_ADDR_VAR 0 18
79638: PUSH
79639: LD_INT 0
79641: PUSH
79642: LD_INT 0
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 0
79651: PUSH
79652: LD_INT 1
79654: NEG
79655: PUSH
79656: EMPTY
79657: LIST
79658: LIST
79659: PUSH
79660: LD_INT 1
79662: PUSH
79663: LD_INT 0
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: PUSH
79670: LD_INT 1
79672: PUSH
79673: LD_INT 1
79675: PUSH
79676: EMPTY
79677: LIST
79678: LIST
79679: PUSH
79680: LD_INT 0
79682: PUSH
79683: LD_INT 1
79685: PUSH
79686: EMPTY
79687: LIST
79688: LIST
79689: PUSH
79690: LD_INT 1
79692: NEG
79693: PUSH
79694: LD_INT 0
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 1
79703: NEG
79704: PUSH
79705: LD_INT 1
79707: NEG
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_INT 1
79715: NEG
79716: PUSH
79717: LD_INT 2
79719: NEG
79720: PUSH
79721: EMPTY
79722: LIST
79723: LIST
79724: PUSH
79725: LD_INT 0
79727: PUSH
79728: LD_INT 2
79730: NEG
79731: PUSH
79732: EMPTY
79733: LIST
79734: LIST
79735: PUSH
79736: LD_INT 1
79738: PUSH
79739: LD_INT 1
79741: NEG
79742: PUSH
79743: EMPTY
79744: LIST
79745: LIST
79746: PUSH
79747: LD_INT 2
79749: PUSH
79750: LD_INT 0
79752: PUSH
79753: EMPTY
79754: LIST
79755: LIST
79756: PUSH
79757: LD_INT 2
79759: PUSH
79760: LD_INT 1
79762: PUSH
79763: EMPTY
79764: LIST
79765: LIST
79766: PUSH
79767: LD_INT 2
79769: PUSH
79770: LD_INT 2
79772: PUSH
79773: EMPTY
79774: LIST
79775: LIST
79776: PUSH
79777: LD_INT 1
79779: PUSH
79780: LD_INT 2
79782: PUSH
79783: EMPTY
79784: LIST
79785: LIST
79786: PUSH
79787: LD_INT 0
79789: PUSH
79790: LD_INT 2
79792: PUSH
79793: EMPTY
79794: LIST
79795: LIST
79796: PUSH
79797: LD_INT 1
79799: NEG
79800: PUSH
79801: LD_INT 1
79803: PUSH
79804: EMPTY
79805: LIST
79806: LIST
79807: PUSH
79808: LD_INT 2
79810: NEG
79811: PUSH
79812: LD_INT 0
79814: PUSH
79815: EMPTY
79816: LIST
79817: LIST
79818: PUSH
79819: LD_INT 2
79821: NEG
79822: PUSH
79823: LD_INT 1
79825: NEG
79826: PUSH
79827: EMPTY
79828: LIST
79829: LIST
79830: PUSH
79831: LD_INT 2
79833: NEG
79834: PUSH
79835: LD_INT 2
79837: NEG
79838: PUSH
79839: EMPTY
79840: LIST
79841: LIST
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
79864: LD_ADDR_VAR 0 19
79868: PUSH
79869: LD_INT 0
79871: PUSH
79872: LD_INT 0
79874: PUSH
79875: EMPTY
79876: LIST
79877: LIST
79878: PUSH
79879: LD_INT 0
79881: PUSH
79882: LD_INT 1
79884: NEG
79885: PUSH
79886: EMPTY
79887: LIST
79888: LIST
79889: PUSH
79890: LD_INT 1
79892: PUSH
79893: LD_INT 0
79895: PUSH
79896: EMPTY
79897: LIST
79898: LIST
79899: PUSH
79900: LD_INT 1
79902: PUSH
79903: LD_INT 1
79905: PUSH
79906: EMPTY
79907: LIST
79908: LIST
79909: PUSH
79910: LD_INT 0
79912: PUSH
79913: LD_INT 1
79915: PUSH
79916: EMPTY
79917: LIST
79918: LIST
79919: PUSH
79920: LD_INT 1
79922: NEG
79923: PUSH
79924: LD_INT 0
79926: PUSH
79927: EMPTY
79928: LIST
79929: LIST
79930: PUSH
79931: LD_INT 1
79933: NEG
79934: PUSH
79935: LD_INT 1
79937: NEG
79938: PUSH
79939: EMPTY
79940: LIST
79941: LIST
79942: PUSH
79943: LD_INT 1
79945: NEG
79946: PUSH
79947: LD_INT 2
79949: NEG
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: LD_INT 0
79957: PUSH
79958: LD_INT 2
79960: NEG
79961: PUSH
79962: EMPTY
79963: LIST
79964: LIST
79965: PUSH
79966: LD_INT 1
79968: PUSH
79969: LD_INT 1
79971: NEG
79972: PUSH
79973: EMPTY
79974: LIST
79975: LIST
79976: PUSH
79977: LD_INT 2
79979: PUSH
79980: LD_INT 0
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: PUSH
79987: LD_INT 2
79989: PUSH
79990: LD_INT 1
79992: PUSH
79993: EMPTY
79994: LIST
79995: LIST
79996: PUSH
79997: LD_INT 2
79999: PUSH
80000: LD_INT 2
80002: PUSH
80003: EMPTY
80004: LIST
80005: LIST
80006: PUSH
80007: LD_INT 1
80009: PUSH
80010: LD_INT 2
80012: PUSH
80013: EMPTY
80014: LIST
80015: LIST
80016: PUSH
80017: LD_INT 0
80019: PUSH
80020: LD_INT 2
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 1
80029: NEG
80030: PUSH
80031: LD_INT 1
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: LD_INT 2
80040: NEG
80041: PUSH
80042: LD_INT 0
80044: PUSH
80045: EMPTY
80046: LIST
80047: LIST
80048: PUSH
80049: LD_INT 2
80051: NEG
80052: PUSH
80053: LD_INT 1
80055: NEG
80056: PUSH
80057: EMPTY
80058: LIST
80059: LIST
80060: PUSH
80061: LD_INT 2
80063: NEG
80064: PUSH
80065: LD_INT 2
80067: NEG
80068: PUSH
80069: EMPTY
80070: LIST
80071: LIST
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80094: LD_ADDR_VAR 0 20
80098: PUSH
80099: LD_INT 0
80101: PUSH
80102: LD_INT 0
80104: PUSH
80105: EMPTY
80106: LIST
80107: LIST
80108: PUSH
80109: LD_INT 0
80111: PUSH
80112: LD_INT 1
80114: NEG
80115: PUSH
80116: EMPTY
80117: LIST
80118: LIST
80119: PUSH
80120: LD_INT 1
80122: PUSH
80123: LD_INT 0
80125: PUSH
80126: EMPTY
80127: LIST
80128: LIST
80129: PUSH
80130: LD_INT 1
80132: PUSH
80133: LD_INT 1
80135: PUSH
80136: EMPTY
80137: LIST
80138: LIST
80139: PUSH
80140: LD_INT 0
80142: PUSH
80143: LD_INT 1
80145: PUSH
80146: EMPTY
80147: LIST
80148: LIST
80149: PUSH
80150: LD_INT 1
80152: NEG
80153: PUSH
80154: LD_INT 0
80156: PUSH
80157: EMPTY
80158: LIST
80159: LIST
80160: PUSH
80161: LD_INT 1
80163: NEG
80164: PUSH
80165: LD_INT 1
80167: NEG
80168: PUSH
80169: EMPTY
80170: LIST
80171: LIST
80172: PUSH
80173: LD_INT 1
80175: NEG
80176: PUSH
80177: LD_INT 2
80179: NEG
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PUSH
80185: LD_INT 0
80187: PUSH
80188: LD_INT 2
80190: NEG
80191: PUSH
80192: EMPTY
80193: LIST
80194: LIST
80195: PUSH
80196: LD_INT 1
80198: PUSH
80199: LD_INT 1
80201: NEG
80202: PUSH
80203: EMPTY
80204: LIST
80205: LIST
80206: PUSH
80207: LD_INT 2
80209: PUSH
80210: LD_INT 0
80212: PUSH
80213: EMPTY
80214: LIST
80215: LIST
80216: PUSH
80217: LD_INT 2
80219: PUSH
80220: LD_INT 1
80222: PUSH
80223: EMPTY
80224: LIST
80225: LIST
80226: PUSH
80227: LD_INT 2
80229: PUSH
80230: LD_INT 2
80232: PUSH
80233: EMPTY
80234: LIST
80235: LIST
80236: PUSH
80237: LD_INT 1
80239: PUSH
80240: LD_INT 2
80242: PUSH
80243: EMPTY
80244: LIST
80245: LIST
80246: PUSH
80247: LD_INT 0
80249: PUSH
80250: LD_INT 2
80252: PUSH
80253: EMPTY
80254: LIST
80255: LIST
80256: PUSH
80257: LD_INT 1
80259: NEG
80260: PUSH
80261: LD_INT 1
80263: PUSH
80264: EMPTY
80265: LIST
80266: LIST
80267: PUSH
80268: LD_INT 2
80270: NEG
80271: PUSH
80272: LD_INT 0
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 2
80281: NEG
80282: PUSH
80283: LD_INT 1
80285: NEG
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: LD_INT 2
80293: NEG
80294: PUSH
80295: LD_INT 2
80297: NEG
80298: PUSH
80299: EMPTY
80300: LIST
80301: LIST
80302: PUSH
80303: EMPTY
80304: LIST
80305: LIST
80306: LIST
80307: LIST
80308: LIST
80309: LIST
80310: LIST
80311: LIST
80312: LIST
80313: LIST
80314: LIST
80315: LIST
80316: LIST
80317: LIST
80318: LIST
80319: LIST
80320: LIST
80321: LIST
80322: LIST
80323: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80324: LD_ADDR_VAR 0 21
80328: PUSH
80329: LD_INT 0
80331: PUSH
80332: LD_INT 0
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: LD_INT 0
80341: PUSH
80342: LD_INT 1
80344: NEG
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 1
80352: PUSH
80353: LD_INT 0
80355: PUSH
80356: EMPTY
80357: LIST
80358: LIST
80359: PUSH
80360: LD_INT 1
80362: PUSH
80363: LD_INT 1
80365: PUSH
80366: EMPTY
80367: LIST
80368: LIST
80369: PUSH
80370: LD_INT 0
80372: PUSH
80373: LD_INT 1
80375: PUSH
80376: EMPTY
80377: LIST
80378: LIST
80379: PUSH
80380: LD_INT 1
80382: NEG
80383: PUSH
80384: LD_INT 0
80386: PUSH
80387: EMPTY
80388: LIST
80389: LIST
80390: PUSH
80391: LD_INT 1
80393: NEG
80394: PUSH
80395: LD_INT 1
80397: NEG
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 1
80405: NEG
80406: PUSH
80407: LD_INT 2
80409: NEG
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: LD_INT 0
80417: PUSH
80418: LD_INT 2
80420: NEG
80421: PUSH
80422: EMPTY
80423: LIST
80424: LIST
80425: PUSH
80426: LD_INT 1
80428: PUSH
80429: LD_INT 1
80431: NEG
80432: PUSH
80433: EMPTY
80434: LIST
80435: LIST
80436: PUSH
80437: LD_INT 2
80439: PUSH
80440: LD_INT 0
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 2
80449: PUSH
80450: LD_INT 1
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 2
80459: PUSH
80460: LD_INT 2
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 1
80469: PUSH
80470: LD_INT 2
80472: PUSH
80473: EMPTY
80474: LIST
80475: LIST
80476: PUSH
80477: LD_INT 0
80479: PUSH
80480: LD_INT 2
80482: PUSH
80483: EMPTY
80484: LIST
80485: LIST
80486: PUSH
80487: LD_INT 1
80489: NEG
80490: PUSH
80491: LD_INT 1
80493: PUSH
80494: EMPTY
80495: LIST
80496: LIST
80497: PUSH
80498: LD_INT 2
80500: NEG
80501: PUSH
80502: LD_INT 0
80504: PUSH
80505: EMPTY
80506: LIST
80507: LIST
80508: PUSH
80509: LD_INT 2
80511: NEG
80512: PUSH
80513: LD_INT 1
80515: NEG
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: PUSH
80521: LD_INT 2
80523: NEG
80524: PUSH
80525: LD_INT 2
80527: NEG
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: PUSH
80533: EMPTY
80534: LIST
80535: LIST
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: LIST
80552: LIST
80553: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80554: LD_ADDR_VAR 0 22
80558: PUSH
80559: LD_INT 0
80561: PUSH
80562: LD_INT 0
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PUSH
80569: LD_INT 0
80571: PUSH
80572: LD_INT 1
80574: NEG
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: LD_INT 1
80582: PUSH
80583: LD_INT 0
80585: PUSH
80586: EMPTY
80587: LIST
80588: LIST
80589: PUSH
80590: LD_INT 1
80592: PUSH
80593: LD_INT 1
80595: PUSH
80596: EMPTY
80597: LIST
80598: LIST
80599: PUSH
80600: LD_INT 0
80602: PUSH
80603: LD_INT 1
80605: PUSH
80606: EMPTY
80607: LIST
80608: LIST
80609: PUSH
80610: LD_INT 1
80612: NEG
80613: PUSH
80614: LD_INT 0
80616: PUSH
80617: EMPTY
80618: LIST
80619: LIST
80620: PUSH
80621: LD_INT 1
80623: NEG
80624: PUSH
80625: LD_INT 1
80627: NEG
80628: PUSH
80629: EMPTY
80630: LIST
80631: LIST
80632: PUSH
80633: LD_INT 1
80635: NEG
80636: PUSH
80637: LD_INT 2
80639: NEG
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: LD_INT 2
80650: NEG
80651: PUSH
80652: EMPTY
80653: LIST
80654: LIST
80655: PUSH
80656: LD_INT 1
80658: PUSH
80659: LD_INT 1
80661: NEG
80662: PUSH
80663: EMPTY
80664: LIST
80665: LIST
80666: PUSH
80667: LD_INT 2
80669: PUSH
80670: LD_INT 0
80672: PUSH
80673: EMPTY
80674: LIST
80675: LIST
80676: PUSH
80677: LD_INT 2
80679: PUSH
80680: LD_INT 1
80682: PUSH
80683: EMPTY
80684: LIST
80685: LIST
80686: PUSH
80687: LD_INT 2
80689: PUSH
80690: LD_INT 2
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: PUSH
80697: LD_INT 1
80699: PUSH
80700: LD_INT 2
80702: PUSH
80703: EMPTY
80704: LIST
80705: LIST
80706: PUSH
80707: LD_INT 0
80709: PUSH
80710: LD_INT 2
80712: PUSH
80713: EMPTY
80714: LIST
80715: LIST
80716: PUSH
80717: LD_INT 1
80719: NEG
80720: PUSH
80721: LD_INT 1
80723: PUSH
80724: EMPTY
80725: LIST
80726: LIST
80727: PUSH
80728: LD_INT 2
80730: NEG
80731: PUSH
80732: LD_INT 0
80734: PUSH
80735: EMPTY
80736: LIST
80737: LIST
80738: PUSH
80739: LD_INT 2
80741: NEG
80742: PUSH
80743: LD_INT 1
80745: NEG
80746: PUSH
80747: EMPTY
80748: LIST
80749: LIST
80750: PUSH
80751: LD_INT 2
80753: NEG
80754: PUSH
80755: LD_INT 2
80757: NEG
80758: PUSH
80759: EMPTY
80760: LIST
80761: LIST
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: LIST
80771: LIST
80772: LIST
80773: LIST
80774: LIST
80775: LIST
80776: LIST
80777: LIST
80778: LIST
80779: LIST
80780: LIST
80781: LIST
80782: LIST
80783: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
80784: LD_ADDR_VAR 0 23
80788: PUSH
80789: LD_INT 0
80791: PUSH
80792: LD_INT 0
80794: PUSH
80795: EMPTY
80796: LIST
80797: LIST
80798: PUSH
80799: LD_INT 0
80801: PUSH
80802: LD_INT 1
80804: NEG
80805: PUSH
80806: EMPTY
80807: LIST
80808: LIST
80809: PUSH
80810: LD_INT 1
80812: PUSH
80813: LD_INT 0
80815: PUSH
80816: EMPTY
80817: LIST
80818: LIST
80819: PUSH
80820: LD_INT 1
80822: PUSH
80823: LD_INT 1
80825: PUSH
80826: EMPTY
80827: LIST
80828: LIST
80829: PUSH
80830: LD_INT 0
80832: PUSH
80833: LD_INT 1
80835: PUSH
80836: EMPTY
80837: LIST
80838: LIST
80839: PUSH
80840: LD_INT 1
80842: NEG
80843: PUSH
80844: LD_INT 0
80846: PUSH
80847: EMPTY
80848: LIST
80849: LIST
80850: PUSH
80851: LD_INT 1
80853: NEG
80854: PUSH
80855: LD_INT 1
80857: NEG
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 1
80865: NEG
80866: PUSH
80867: LD_INT 2
80869: NEG
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: PUSH
80875: LD_INT 0
80877: PUSH
80878: LD_INT 2
80880: NEG
80881: PUSH
80882: EMPTY
80883: LIST
80884: LIST
80885: PUSH
80886: LD_INT 1
80888: PUSH
80889: LD_INT 1
80891: NEG
80892: PUSH
80893: EMPTY
80894: LIST
80895: LIST
80896: PUSH
80897: LD_INT 2
80899: PUSH
80900: LD_INT 0
80902: PUSH
80903: EMPTY
80904: LIST
80905: LIST
80906: PUSH
80907: LD_INT 2
80909: PUSH
80910: LD_INT 1
80912: PUSH
80913: EMPTY
80914: LIST
80915: LIST
80916: PUSH
80917: LD_INT 2
80919: PUSH
80920: LD_INT 2
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: PUSH
80927: LD_INT 1
80929: PUSH
80930: LD_INT 2
80932: PUSH
80933: EMPTY
80934: LIST
80935: LIST
80936: PUSH
80937: LD_INT 0
80939: PUSH
80940: LD_INT 2
80942: PUSH
80943: EMPTY
80944: LIST
80945: LIST
80946: PUSH
80947: LD_INT 1
80949: NEG
80950: PUSH
80951: LD_INT 1
80953: PUSH
80954: EMPTY
80955: LIST
80956: LIST
80957: PUSH
80958: LD_INT 2
80960: NEG
80961: PUSH
80962: LD_INT 0
80964: PUSH
80965: EMPTY
80966: LIST
80967: LIST
80968: PUSH
80969: LD_INT 2
80971: NEG
80972: PUSH
80973: LD_INT 1
80975: NEG
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: LD_INT 2
80983: NEG
80984: PUSH
80985: LD_INT 2
80987: NEG
80988: PUSH
80989: EMPTY
80990: LIST
80991: LIST
80992: PUSH
80993: LD_INT 2
80995: NEG
80996: PUSH
80997: LD_INT 3
80999: NEG
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 1
81007: NEG
81008: PUSH
81009: LD_INT 3
81011: NEG
81012: PUSH
81013: EMPTY
81014: LIST
81015: LIST
81016: PUSH
81017: LD_INT 1
81019: PUSH
81020: LD_INT 2
81022: NEG
81023: PUSH
81024: EMPTY
81025: LIST
81026: LIST
81027: PUSH
81028: LD_INT 2
81030: PUSH
81031: LD_INT 1
81033: NEG
81034: PUSH
81035: EMPTY
81036: LIST
81037: LIST
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: LIST
81043: LIST
81044: LIST
81045: LIST
81046: LIST
81047: LIST
81048: LIST
81049: LIST
81050: LIST
81051: LIST
81052: LIST
81053: LIST
81054: LIST
81055: LIST
81056: LIST
81057: LIST
81058: LIST
81059: LIST
81060: LIST
81061: LIST
81062: LIST
81063: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
81064: LD_ADDR_VAR 0 24
81068: PUSH
81069: LD_INT 0
81071: PUSH
81072: LD_INT 0
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: LD_INT 0
81081: PUSH
81082: LD_INT 1
81084: NEG
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 1
81092: PUSH
81093: LD_INT 0
81095: PUSH
81096: EMPTY
81097: LIST
81098: LIST
81099: PUSH
81100: LD_INT 1
81102: PUSH
81103: LD_INT 1
81105: PUSH
81106: EMPTY
81107: LIST
81108: LIST
81109: PUSH
81110: LD_INT 0
81112: PUSH
81113: LD_INT 1
81115: PUSH
81116: EMPTY
81117: LIST
81118: LIST
81119: PUSH
81120: LD_INT 1
81122: NEG
81123: PUSH
81124: LD_INT 0
81126: PUSH
81127: EMPTY
81128: LIST
81129: LIST
81130: PUSH
81131: LD_INT 1
81133: NEG
81134: PUSH
81135: LD_INT 1
81137: NEG
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: LD_INT 1
81145: NEG
81146: PUSH
81147: LD_INT 2
81149: NEG
81150: PUSH
81151: EMPTY
81152: LIST
81153: LIST
81154: PUSH
81155: LD_INT 0
81157: PUSH
81158: LD_INT 2
81160: NEG
81161: PUSH
81162: EMPTY
81163: LIST
81164: LIST
81165: PUSH
81166: LD_INT 1
81168: PUSH
81169: LD_INT 1
81171: NEG
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 2
81179: PUSH
81180: LD_INT 0
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 2
81189: PUSH
81190: LD_INT 1
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 2
81199: PUSH
81200: LD_INT 2
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PUSH
81207: LD_INT 1
81209: PUSH
81210: LD_INT 2
81212: PUSH
81213: EMPTY
81214: LIST
81215: LIST
81216: PUSH
81217: LD_INT 0
81219: PUSH
81220: LD_INT 2
81222: PUSH
81223: EMPTY
81224: LIST
81225: LIST
81226: PUSH
81227: LD_INT 1
81229: NEG
81230: PUSH
81231: LD_INT 1
81233: PUSH
81234: EMPTY
81235: LIST
81236: LIST
81237: PUSH
81238: LD_INT 2
81240: NEG
81241: PUSH
81242: LD_INT 0
81244: PUSH
81245: EMPTY
81246: LIST
81247: LIST
81248: PUSH
81249: LD_INT 2
81251: NEG
81252: PUSH
81253: LD_INT 1
81255: NEG
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 2
81263: NEG
81264: PUSH
81265: LD_INT 2
81267: NEG
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: LD_INT 1
81275: PUSH
81276: LD_INT 2
81278: NEG
81279: PUSH
81280: EMPTY
81281: LIST
81282: LIST
81283: PUSH
81284: LD_INT 2
81286: PUSH
81287: LD_INT 1
81289: NEG
81290: PUSH
81291: EMPTY
81292: LIST
81293: LIST
81294: PUSH
81295: LD_INT 3
81297: PUSH
81298: LD_INT 1
81300: PUSH
81301: EMPTY
81302: LIST
81303: LIST
81304: PUSH
81305: LD_INT 3
81307: PUSH
81308: LD_INT 2
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: PUSH
81315: EMPTY
81316: LIST
81317: LIST
81318: LIST
81319: LIST
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: LIST
81325: LIST
81326: LIST
81327: LIST
81328: LIST
81329: LIST
81330: LIST
81331: LIST
81332: LIST
81333: LIST
81334: LIST
81335: LIST
81336: LIST
81337: LIST
81338: LIST
81339: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
81340: LD_ADDR_VAR 0 25
81344: PUSH
81345: LD_INT 0
81347: PUSH
81348: LD_INT 0
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: PUSH
81355: LD_INT 0
81357: PUSH
81358: LD_INT 1
81360: NEG
81361: PUSH
81362: EMPTY
81363: LIST
81364: LIST
81365: PUSH
81366: LD_INT 1
81368: PUSH
81369: LD_INT 0
81371: PUSH
81372: EMPTY
81373: LIST
81374: LIST
81375: PUSH
81376: LD_INT 1
81378: PUSH
81379: LD_INT 1
81381: PUSH
81382: EMPTY
81383: LIST
81384: LIST
81385: PUSH
81386: LD_INT 0
81388: PUSH
81389: LD_INT 1
81391: PUSH
81392: EMPTY
81393: LIST
81394: LIST
81395: PUSH
81396: LD_INT 1
81398: NEG
81399: PUSH
81400: LD_INT 0
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: PUSH
81407: LD_INT 1
81409: NEG
81410: PUSH
81411: LD_INT 1
81413: NEG
81414: PUSH
81415: EMPTY
81416: LIST
81417: LIST
81418: PUSH
81419: LD_INT 1
81421: NEG
81422: PUSH
81423: LD_INT 2
81425: NEG
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 0
81433: PUSH
81434: LD_INT 2
81436: NEG
81437: PUSH
81438: EMPTY
81439: LIST
81440: LIST
81441: PUSH
81442: LD_INT 1
81444: PUSH
81445: LD_INT 1
81447: NEG
81448: PUSH
81449: EMPTY
81450: LIST
81451: LIST
81452: PUSH
81453: LD_INT 2
81455: PUSH
81456: LD_INT 0
81458: PUSH
81459: EMPTY
81460: LIST
81461: LIST
81462: PUSH
81463: LD_INT 2
81465: PUSH
81466: LD_INT 1
81468: PUSH
81469: EMPTY
81470: LIST
81471: LIST
81472: PUSH
81473: LD_INT 2
81475: PUSH
81476: LD_INT 2
81478: PUSH
81479: EMPTY
81480: LIST
81481: LIST
81482: PUSH
81483: LD_INT 1
81485: PUSH
81486: LD_INT 2
81488: PUSH
81489: EMPTY
81490: LIST
81491: LIST
81492: PUSH
81493: LD_INT 0
81495: PUSH
81496: LD_INT 2
81498: PUSH
81499: EMPTY
81500: LIST
81501: LIST
81502: PUSH
81503: LD_INT 1
81505: NEG
81506: PUSH
81507: LD_INT 1
81509: PUSH
81510: EMPTY
81511: LIST
81512: LIST
81513: PUSH
81514: LD_INT 2
81516: NEG
81517: PUSH
81518: LD_INT 0
81520: PUSH
81521: EMPTY
81522: LIST
81523: LIST
81524: PUSH
81525: LD_INT 2
81527: NEG
81528: PUSH
81529: LD_INT 1
81531: NEG
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 2
81539: NEG
81540: PUSH
81541: LD_INT 2
81543: NEG
81544: PUSH
81545: EMPTY
81546: LIST
81547: LIST
81548: PUSH
81549: LD_INT 3
81551: PUSH
81552: LD_INT 1
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: PUSH
81559: LD_INT 3
81561: PUSH
81562: LD_INT 2
81564: PUSH
81565: EMPTY
81566: LIST
81567: LIST
81568: PUSH
81569: LD_INT 2
81571: PUSH
81572: LD_INT 3
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 1
81581: PUSH
81582: LD_INT 3
81584: PUSH
81585: EMPTY
81586: LIST
81587: LIST
81588: PUSH
81589: EMPTY
81590: LIST
81591: LIST
81592: LIST
81593: LIST
81594: LIST
81595: LIST
81596: LIST
81597: LIST
81598: LIST
81599: LIST
81600: LIST
81601: LIST
81602: LIST
81603: LIST
81604: LIST
81605: LIST
81606: LIST
81607: LIST
81608: LIST
81609: LIST
81610: LIST
81611: LIST
81612: LIST
81613: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
81614: LD_ADDR_VAR 0 26
81618: PUSH
81619: LD_INT 0
81621: PUSH
81622: LD_INT 0
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: PUSH
81629: LD_INT 0
81631: PUSH
81632: LD_INT 1
81634: NEG
81635: PUSH
81636: EMPTY
81637: LIST
81638: LIST
81639: PUSH
81640: LD_INT 1
81642: PUSH
81643: LD_INT 0
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: LD_INT 1
81652: PUSH
81653: LD_INT 1
81655: PUSH
81656: EMPTY
81657: LIST
81658: LIST
81659: PUSH
81660: LD_INT 0
81662: PUSH
81663: LD_INT 1
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 1
81672: NEG
81673: PUSH
81674: LD_INT 0
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PUSH
81681: LD_INT 1
81683: NEG
81684: PUSH
81685: LD_INT 1
81687: NEG
81688: PUSH
81689: EMPTY
81690: LIST
81691: LIST
81692: PUSH
81693: LD_INT 1
81695: NEG
81696: PUSH
81697: LD_INT 2
81699: NEG
81700: PUSH
81701: EMPTY
81702: LIST
81703: LIST
81704: PUSH
81705: LD_INT 0
81707: PUSH
81708: LD_INT 2
81710: NEG
81711: PUSH
81712: EMPTY
81713: LIST
81714: LIST
81715: PUSH
81716: LD_INT 1
81718: PUSH
81719: LD_INT 1
81721: NEG
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: PUSH
81727: LD_INT 2
81729: PUSH
81730: LD_INT 0
81732: PUSH
81733: EMPTY
81734: LIST
81735: LIST
81736: PUSH
81737: LD_INT 2
81739: PUSH
81740: LD_INT 1
81742: PUSH
81743: EMPTY
81744: LIST
81745: LIST
81746: PUSH
81747: LD_INT 2
81749: PUSH
81750: LD_INT 2
81752: PUSH
81753: EMPTY
81754: LIST
81755: LIST
81756: PUSH
81757: LD_INT 1
81759: PUSH
81760: LD_INT 2
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 0
81769: PUSH
81770: LD_INT 2
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 1
81779: NEG
81780: PUSH
81781: LD_INT 1
81783: PUSH
81784: EMPTY
81785: LIST
81786: LIST
81787: PUSH
81788: LD_INT 2
81790: NEG
81791: PUSH
81792: LD_INT 0
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 2
81801: NEG
81802: PUSH
81803: LD_INT 1
81805: NEG
81806: PUSH
81807: EMPTY
81808: LIST
81809: LIST
81810: PUSH
81811: LD_INT 2
81813: NEG
81814: PUSH
81815: LD_INT 2
81817: NEG
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: PUSH
81823: LD_INT 2
81825: PUSH
81826: LD_INT 3
81828: PUSH
81829: EMPTY
81830: LIST
81831: LIST
81832: PUSH
81833: LD_INT 1
81835: PUSH
81836: LD_INT 3
81838: PUSH
81839: EMPTY
81840: LIST
81841: LIST
81842: PUSH
81843: LD_INT 1
81845: NEG
81846: PUSH
81847: LD_INT 2
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: PUSH
81854: LD_INT 2
81856: NEG
81857: PUSH
81858: LD_INT 1
81860: PUSH
81861: EMPTY
81862: LIST
81863: LIST
81864: PUSH
81865: EMPTY
81866: LIST
81867: LIST
81868: LIST
81869: LIST
81870: LIST
81871: LIST
81872: LIST
81873: LIST
81874: LIST
81875: LIST
81876: LIST
81877: LIST
81878: LIST
81879: LIST
81880: LIST
81881: LIST
81882: LIST
81883: LIST
81884: LIST
81885: LIST
81886: LIST
81887: LIST
81888: LIST
81889: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
81890: LD_ADDR_VAR 0 27
81894: PUSH
81895: LD_INT 0
81897: PUSH
81898: LD_INT 0
81900: PUSH
81901: EMPTY
81902: LIST
81903: LIST
81904: PUSH
81905: LD_INT 0
81907: PUSH
81908: LD_INT 1
81910: NEG
81911: PUSH
81912: EMPTY
81913: LIST
81914: LIST
81915: PUSH
81916: LD_INT 1
81918: PUSH
81919: LD_INT 0
81921: PUSH
81922: EMPTY
81923: LIST
81924: LIST
81925: PUSH
81926: LD_INT 1
81928: PUSH
81929: LD_INT 1
81931: PUSH
81932: EMPTY
81933: LIST
81934: LIST
81935: PUSH
81936: LD_INT 0
81938: PUSH
81939: LD_INT 1
81941: PUSH
81942: EMPTY
81943: LIST
81944: LIST
81945: PUSH
81946: LD_INT 1
81948: NEG
81949: PUSH
81950: LD_INT 0
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 1
81959: NEG
81960: PUSH
81961: LD_INT 1
81963: NEG
81964: PUSH
81965: EMPTY
81966: LIST
81967: LIST
81968: PUSH
81969: LD_INT 1
81971: NEG
81972: PUSH
81973: LD_INT 2
81975: NEG
81976: PUSH
81977: EMPTY
81978: LIST
81979: LIST
81980: PUSH
81981: LD_INT 0
81983: PUSH
81984: LD_INT 2
81986: NEG
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: PUSH
81992: LD_INT 1
81994: PUSH
81995: LD_INT 1
81997: NEG
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: LD_INT 2
82005: PUSH
82006: LD_INT 0
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 2
82015: PUSH
82016: LD_INT 1
82018: PUSH
82019: EMPTY
82020: LIST
82021: LIST
82022: PUSH
82023: LD_INT 2
82025: PUSH
82026: LD_INT 2
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_INT 1
82035: PUSH
82036: LD_INT 2
82038: PUSH
82039: EMPTY
82040: LIST
82041: LIST
82042: PUSH
82043: LD_INT 0
82045: PUSH
82046: LD_INT 2
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: PUSH
82053: LD_INT 1
82055: NEG
82056: PUSH
82057: LD_INT 1
82059: PUSH
82060: EMPTY
82061: LIST
82062: LIST
82063: PUSH
82064: LD_INT 2
82066: NEG
82067: PUSH
82068: LD_INT 0
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: PUSH
82075: LD_INT 2
82077: NEG
82078: PUSH
82079: LD_INT 1
82081: NEG
82082: PUSH
82083: EMPTY
82084: LIST
82085: LIST
82086: PUSH
82087: LD_INT 2
82089: NEG
82090: PUSH
82091: LD_INT 2
82093: NEG
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: LD_INT 1
82101: NEG
82102: PUSH
82103: LD_INT 2
82105: PUSH
82106: EMPTY
82107: LIST
82108: LIST
82109: PUSH
82110: LD_INT 2
82112: NEG
82113: PUSH
82114: LD_INT 1
82116: PUSH
82117: EMPTY
82118: LIST
82119: LIST
82120: PUSH
82121: LD_INT 3
82123: NEG
82124: PUSH
82125: LD_INT 1
82127: NEG
82128: PUSH
82129: EMPTY
82130: LIST
82131: LIST
82132: PUSH
82133: LD_INT 3
82135: NEG
82136: PUSH
82137: LD_INT 2
82139: NEG
82140: PUSH
82141: EMPTY
82142: LIST
82143: LIST
82144: PUSH
82145: EMPTY
82146: LIST
82147: LIST
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
82170: LD_ADDR_VAR 0 28
82174: PUSH
82175: LD_INT 0
82177: PUSH
82178: LD_INT 0
82180: PUSH
82181: EMPTY
82182: LIST
82183: LIST
82184: PUSH
82185: LD_INT 0
82187: PUSH
82188: LD_INT 1
82190: NEG
82191: PUSH
82192: EMPTY
82193: LIST
82194: LIST
82195: PUSH
82196: LD_INT 1
82198: PUSH
82199: LD_INT 0
82201: PUSH
82202: EMPTY
82203: LIST
82204: LIST
82205: PUSH
82206: LD_INT 1
82208: PUSH
82209: LD_INT 1
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 0
82218: PUSH
82219: LD_INT 1
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_INT 1
82228: NEG
82229: PUSH
82230: LD_INT 0
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 1
82239: NEG
82240: PUSH
82241: LD_INT 1
82243: NEG
82244: PUSH
82245: EMPTY
82246: LIST
82247: LIST
82248: PUSH
82249: LD_INT 1
82251: NEG
82252: PUSH
82253: LD_INT 2
82255: NEG
82256: PUSH
82257: EMPTY
82258: LIST
82259: LIST
82260: PUSH
82261: LD_INT 0
82263: PUSH
82264: LD_INT 2
82266: NEG
82267: PUSH
82268: EMPTY
82269: LIST
82270: LIST
82271: PUSH
82272: LD_INT 1
82274: PUSH
82275: LD_INT 1
82277: NEG
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: PUSH
82283: LD_INT 2
82285: PUSH
82286: LD_INT 0
82288: PUSH
82289: EMPTY
82290: LIST
82291: LIST
82292: PUSH
82293: LD_INT 2
82295: PUSH
82296: LD_INT 1
82298: PUSH
82299: EMPTY
82300: LIST
82301: LIST
82302: PUSH
82303: LD_INT 2
82305: PUSH
82306: LD_INT 2
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: PUSH
82313: LD_INT 1
82315: PUSH
82316: LD_INT 2
82318: PUSH
82319: EMPTY
82320: LIST
82321: LIST
82322: PUSH
82323: LD_INT 0
82325: PUSH
82326: LD_INT 2
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: LD_INT 1
82335: NEG
82336: PUSH
82337: LD_INT 1
82339: PUSH
82340: EMPTY
82341: LIST
82342: LIST
82343: PUSH
82344: LD_INT 2
82346: NEG
82347: PUSH
82348: LD_INT 0
82350: PUSH
82351: EMPTY
82352: LIST
82353: LIST
82354: PUSH
82355: LD_INT 2
82357: NEG
82358: PUSH
82359: LD_INT 1
82361: NEG
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 2
82369: NEG
82370: PUSH
82371: LD_INT 2
82373: NEG
82374: PUSH
82375: EMPTY
82376: LIST
82377: LIST
82378: PUSH
82379: LD_INT 2
82381: NEG
82382: PUSH
82383: LD_INT 3
82385: NEG
82386: PUSH
82387: EMPTY
82388: LIST
82389: LIST
82390: PUSH
82391: LD_INT 1
82393: NEG
82394: PUSH
82395: LD_INT 3
82397: NEG
82398: PUSH
82399: EMPTY
82400: LIST
82401: LIST
82402: PUSH
82403: LD_INT 3
82405: NEG
82406: PUSH
82407: LD_INT 1
82409: NEG
82410: PUSH
82411: EMPTY
82412: LIST
82413: LIST
82414: PUSH
82415: LD_INT 3
82417: NEG
82418: PUSH
82419: LD_INT 2
82421: NEG
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PUSH
82427: EMPTY
82428: LIST
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: LIST
82437: LIST
82438: LIST
82439: LIST
82440: LIST
82441: LIST
82442: LIST
82443: LIST
82444: LIST
82445: LIST
82446: LIST
82447: LIST
82448: LIST
82449: LIST
82450: LIST
82451: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
82452: LD_ADDR_VAR 0 29
82456: PUSH
82457: LD_INT 0
82459: PUSH
82460: LD_INT 0
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 0
82469: PUSH
82470: LD_INT 1
82472: NEG
82473: PUSH
82474: EMPTY
82475: LIST
82476: LIST
82477: PUSH
82478: LD_INT 1
82480: PUSH
82481: LD_INT 0
82483: PUSH
82484: EMPTY
82485: LIST
82486: LIST
82487: PUSH
82488: LD_INT 1
82490: PUSH
82491: LD_INT 1
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: PUSH
82498: LD_INT 0
82500: PUSH
82501: LD_INT 1
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: LD_INT 1
82510: NEG
82511: PUSH
82512: LD_INT 0
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 1
82521: NEG
82522: PUSH
82523: LD_INT 1
82525: NEG
82526: PUSH
82527: EMPTY
82528: LIST
82529: LIST
82530: PUSH
82531: LD_INT 1
82533: NEG
82534: PUSH
82535: LD_INT 2
82537: NEG
82538: PUSH
82539: EMPTY
82540: LIST
82541: LIST
82542: PUSH
82543: LD_INT 0
82545: PUSH
82546: LD_INT 2
82548: NEG
82549: PUSH
82550: EMPTY
82551: LIST
82552: LIST
82553: PUSH
82554: LD_INT 1
82556: PUSH
82557: LD_INT 1
82559: NEG
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 2
82567: PUSH
82568: LD_INT 0
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 2
82577: PUSH
82578: LD_INT 1
82580: PUSH
82581: EMPTY
82582: LIST
82583: LIST
82584: PUSH
82585: LD_INT 1
82587: PUSH
82588: LD_INT 2
82590: PUSH
82591: EMPTY
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 0
82597: PUSH
82598: LD_INT 2
82600: PUSH
82601: EMPTY
82602: LIST
82603: LIST
82604: PUSH
82605: LD_INT 1
82607: NEG
82608: PUSH
82609: LD_INT 1
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: PUSH
82616: LD_INT 2
82618: NEG
82619: PUSH
82620: LD_INT 1
82622: NEG
82623: PUSH
82624: EMPTY
82625: LIST
82626: LIST
82627: PUSH
82628: LD_INT 2
82630: NEG
82631: PUSH
82632: LD_INT 2
82634: NEG
82635: PUSH
82636: EMPTY
82637: LIST
82638: LIST
82639: PUSH
82640: LD_INT 2
82642: NEG
82643: PUSH
82644: LD_INT 3
82646: NEG
82647: PUSH
82648: EMPTY
82649: LIST
82650: LIST
82651: PUSH
82652: LD_INT 2
82654: PUSH
82655: LD_INT 1
82657: NEG
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PUSH
82663: LD_INT 3
82665: PUSH
82666: LD_INT 1
82668: PUSH
82669: EMPTY
82670: LIST
82671: LIST
82672: PUSH
82673: LD_INT 1
82675: PUSH
82676: LD_INT 3
82678: PUSH
82679: EMPTY
82680: LIST
82681: LIST
82682: PUSH
82683: LD_INT 1
82685: NEG
82686: PUSH
82687: LD_INT 2
82689: PUSH
82690: EMPTY
82691: LIST
82692: LIST
82693: PUSH
82694: LD_INT 3
82696: NEG
82697: PUSH
82698: LD_INT 2
82700: NEG
82701: PUSH
82702: EMPTY
82703: LIST
82704: LIST
82705: PUSH
82706: EMPTY
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: LIST
82714: LIST
82715: LIST
82716: LIST
82717: LIST
82718: LIST
82719: LIST
82720: LIST
82721: LIST
82722: LIST
82723: LIST
82724: LIST
82725: LIST
82726: LIST
82727: LIST
82728: LIST
82729: LIST
82730: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
82731: LD_ADDR_VAR 0 30
82735: PUSH
82736: LD_INT 0
82738: PUSH
82739: LD_INT 0
82741: PUSH
82742: EMPTY
82743: LIST
82744: LIST
82745: PUSH
82746: LD_INT 0
82748: PUSH
82749: LD_INT 1
82751: NEG
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: PUSH
82757: LD_INT 1
82759: PUSH
82760: LD_INT 0
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: PUSH
82767: LD_INT 1
82769: PUSH
82770: LD_INT 1
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 0
82779: PUSH
82780: LD_INT 1
82782: PUSH
82783: EMPTY
82784: LIST
82785: LIST
82786: PUSH
82787: LD_INT 1
82789: NEG
82790: PUSH
82791: LD_INT 0
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 1
82800: NEG
82801: PUSH
82802: LD_INT 1
82804: NEG
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 1
82812: NEG
82813: PUSH
82814: LD_INT 2
82816: NEG
82817: PUSH
82818: EMPTY
82819: LIST
82820: LIST
82821: PUSH
82822: LD_INT 0
82824: PUSH
82825: LD_INT 2
82827: NEG
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 1
82835: PUSH
82836: LD_INT 1
82838: NEG
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 2
82846: PUSH
82847: LD_INT 0
82849: PUSH
82850: EMPTY
82851: LIST
82852: LIST
82853: PUSH
82854: LD_INT 2
82856: PUSH
82857: LD_INT 1
82859: PUSH
82860: EMPTY
82861: LIST
82862: LIST
82863: PUSH
82864: LD_INT 2
82866: PUSH
82867: LD_INT 2
82869: PUSH
82870: EMPTY
82871: LIST
82872: LIST
82873: PUSH
82874: LD_INT 1
82876: PUSH
82877: LD_INT 2
82879: PUSH
82880: EMPTY
82881: LIST
82882: LIST
82883: PUSH
82884: LD_INT 1
82886: NEG
82887: PUSH
82888: LD_INT 1
82890: PUSH
82891: EMPTY
82892: LIST
82893: LIST
82894: PUSH
82895: LD_INT 2
82897: NEG
82898: PUSH
82899: LD_INT 0
82901: PUSH
82902: EMPTY
82903: LIST
82904: LIST
82905: PUSH
82906: LD_INT 2
82908: NEG
82909: PUSH
82910: LD_INT 1
82912: NEG
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: PUSH
82918: LD_INT 1
82920: NEG
82921: PUSH
82922: LD_INT 3
82924: NEG
82925: PUSH
82926: EMPTY
82927: LIST
82928: LIST
82929: PUSH
82930: LD_INT 1
82932: PUSH
82933: LD_INT 2
82935: NEG
82936: PUSH
82937: EMPTY
82938: LIST
82939: LIST
82940: PUSH
82941: LD_INT 3
82943: PUSH
82944: LD_INT 2
82946: PUSH
82947: EMPTY
82948: LIST
82949: LIST
82950: PUSH
82951: LD_INT 2
82953: PUSH
82954: LD_INT 3
82956: PUSH
82957: EMPTY
82958: LIST
82959: LIST
82960: PUSH
82961: LD_INT 2
82963: NEG
82964: PUSH
82965: LD_INT 1
82967: PUSH
82968: EMPTY
82969: LIST
82970: LIST
82971: PUSH
82972: LD_INT 3
82974: NEG
82975: PUSH
82976: LD_INT 1
82978: NEG
82979: PUSH
82980: EMPTY
82981: LIST
82982: LIST
82983: PUSH
82984: EMPTY
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: LIST
82999: LIST
83000: LIST
83001: LIST
83002: LIST
83003: LIST
83004: LIST
83005: LIST
83006: LIST
83007: LIST
83008: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83009: LD_ADDR_VAR 0 31
83013: PUSH
83014: LD_INT 0
83016: PUSH
83017: LD_INT 0
83019: PUSH
83020: EMPTY
83021: LIST
83022: LIST
83023: PUSH
83024: LD_INT 0
83026: PUSH
83027: LD_INT 1
83029: NEG
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PUSH
83035: LD_INT 1
83037: PUSH
83038: LD_INT 0
83040: PUSH
83041: EMPTY
83042: LIST
83043: LIST
83044: PUSH
83045: LD_INT 1
83047: PUSH
83048: LD_INT 1
83050: PUSH
83051: EMPTY
83052: LIST
83053: LIST
83054: PUSH
83055: LD_INT 0
83057: PUSH
83058: LD_INT 1
83060: PUSH
83061: EMPTY
83062: LIST
83063: LIST
83064: PUSH
83065: LD_INT 1
83067: NEG
83068: PUSH
83069: LD_INT 0
83071: PUSH
83072: EMPTY
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 1
83078: NEG
83079: PUSH
83080: LD_INT 1
83082: NEG
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PUSH
83088: LD_INT 1
83090: NEG
83091: PUSH
83092: LD_INT 2
83094: NEG
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: PUSH
83100: LD_INT 1
83102: PUSH
83103: LD_INT 1
83105: NEG
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: PUSH
83111: LD_INT 2
83113: PUSH
83114: LD_INT 0
83116: PUSH
83117: EMPTY
83118: LIST
83119: LIST
83120: PUSH
83121: LD_INT 2
83123: PUSH
83124: LD_INT 1
83126: PUSH
83127: EMPTY
83128: LIST
83129: LIST
83130: PUSH
83131: LD_INT 2
83133: PUSH
83134: LD_INT 2
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: PUSH
83141: LD_INT 1
83143: PUSH
83144: LD_INT 2
83146: PUSH
83147: EMPTY
83148: LIST
83149: LIST
83150: PUSH
83151: LD_INT 0
83153: PUSH
83154: LD_INT 2
83156: PUSH
83157: EMPTY
83158: LIST
83159: LIST
83160: PUSH
83161: LD_INT 1
83163: NEG
83164: PUSH
83165: LD_INT 1
83167: PUSH
83168: EMPTY
83169: LIST
83170: LIST
83171: PUSH
83172: LD_INT 2
83174: NEG
83175: PUSH
83176: LD_INT 1
83178: NEG
83179: PUSH
83180: EMPTY
83181: LIST
83182: LIST
83183: PUSH
83184: LD_INT 2
83186: NEG
83187: PUSH
83188: LD_INT 2
83190: NEG
83191: PUSH
83192: EMPTY
83193: LIST
83194: LIST
83195: PUSH
83196: LD_INT 2
83198: NEG
83199: PUSH
83200: LD_INT 3
83202: NEG
83203: PUSH
83204: EMPTY
83205: LIST
83206: LIST
83207: PUSH
83208: LD_INT 2
83210: PUSH
83211: LD_INT 1
83213: NEG
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: PUSH
83219: LD_INT 3
83221: PUSH
83222: LD_INT 1
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 1
83231: PUSH
83232: LD_INT 3
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 1
83241: NEG
83242: PUSH
83243: LD_INT 2
83245: PUSH
83246: EMPTY
83247: LIST
83248: LIST
83249: PUSH
83250: LD_INT 3
83252: NEG
83253: PUSH
83254: LD_INT 2
83256: NEG
83257: PUSH
83258: EMPTY
83259: LIST
83260: LIST
83261: PUSH
83262: EMPTY
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83287: LD_ADDR_VAR 0 32
83291: PUSH
83292: LD_INT 0
83294: PUSH
83295: LD_INT 0
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: PUSH
83302: LD_INT 0
83304: PUSH
83305: LD_INT 1
83307: NEG
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: PUSH
83313: LD_INT 1
83315: PUSH
83316: LD_INT 0
83318: PUSH
83319: EMPTY
83320: LIST
83321: LIST
83322: PUSH
83323: LD_INT 1
83325: PUSH
83326: LD_INT 1
83328: PUSH
83329: EMPTY
83330: LIST
83331: LIST
83332: PUSH
83333: LD_INT 0
83335: PUSH
83336: LD_INT 1
83338: PUSH
83339: EMPTY
83340: LIST
83341: LIST
83342: PUSH
83343: LD_INT 1
83345: NEG
83346: PUSH
83347: LD_INT 0
83349: PUSH
83350: EMPTY
83351: LIST
83352: LIST
83353: PUSH
83354: LD_INT 1
83356: NEG
83357: PUSH
83358: LD_INT 1
83360: NEG
83361: PUSH
83362: EMPTY
83363: LIST
83364: LIST
83365: PUSH
83366: LD_INT 1
83368: NEG
83369: PUSH
83370: LD_INT 2
83372: NEG
83373: PUSH
83374: EMPTY
83375: LIST
83376: LIST
83377: PUSH
83378: LD_INT 0
83380: PUSH
83381: LD_INT 2
83383: NEG
83384: PUSH
83385: EMPTY
83386: LIST
83387: LIST
83388: PUSH
83389: LD_INT 1
83391: PUSH
83392: LD_INT 1
83394: NEG
83395: PUSH
83396: EMPTY
83397: LIST
83398: LIST
83399: PUSH
83400: LD_INT 2
83402: PUSH
83403: LD_INT 1
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: PUSH
83410: LD_INT 2
83412: PUSH
83413: LD_INT 2
83415: PUSH
83416: EMPTY
83417: LIST
83418: LIST
83419: PUSH
83420: LD_INT 1
83422: PUSH
83423: LD_INT 2
83425: PUSH
83426: EMPTY
83427: LIST
83428: LIST
83429: PUSH
83430: LD_INT 0
83432: PUSH
83433: LD_INT 2
83435: PUSH
83436: EMPTY
83437: LIST
83438: LIST
83439: PUSH
83440: LD_INT 1
83442: NEG
83443: PUSH
83444: LD_INT 1
83446: PUSH
83447: EMPTY
83448: LIST
83449: LIST
83450: PUSH
83451: LD_INT 2
83453: NEG
83454: PUSH
83455: LD_INT 0
83457: PUSH
83458: EMPTY
83459: LIST
83460: LIST
83461: PUSH
83462: LD_INT 2
83464: NEG
83465: PUSH
83466: LD_INT 1
83468: NEG
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: PUSH
83474: LD_INT 1
83476: NEG
83477: PUSH
83478: LD_INT 3
83480: NEG
83481: PUSH
83482: EMPTY
83483: LIST
83484: LIST
83485: PUSH
83486: LD_INT 1
83488: PUSH
83489: LD_INT 2
83491: NEG
83492: PUSH
83493: EMPTY
83494: LIST
83495: LIST
83496: PUSH
83497: LD_INT 3
83499: PUSH
83500: LD_INT 2
83502: PUSH
83503: EMPTY
83504: LIST
83505: LIST
83506: PUSH
83507: LD_INT 2
83509: PUSH
83510: LD_INT 3
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: PUSH
83517: LD_INT 2
83519: NEG
83520: PUSH
83521: LD_INT 1
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: PUSH
83528: LD_INT 3
83530: NEG
83531: PUSH
83532: LD_INT 1
83534: NEG
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: PUSH
83540: EMPTY
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: LIST
83555: LIST
83556: LIST
83557: LIST
83558: LIST
83559: LIST
83560: LIST
83561: LIST
83562: LIST
83563: LIST
83564: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
83565: LD_ADDR_VAR 0 33
83569: PUSH
83570: LD_INT 0
83572: PUSH
83573: LD_INT 0
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: PUSH
83580: LD_INT 0
83582: PUSH
83583: LD_INT 1
83585: NEG
83586: PUSH
83587: EMPTY
83588: LIST
83589: LIST
83590: PUSH
83591: LD_INT 1
83593: PUSH
83594: LD_INT 0
83596: PUSH
83597: EMPTY
83598: LIST
83599: LIST
83600: PUSH
83601: LD_INT 1
83603: PUSH
83604: LD_INT 1
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PUSH
83611: LD_INT 0
83613: PUSH
83614: LD_INT 1
83616: PUSH
83617: EMPTY
83618: LIST
83619: LIST
83620: PUSH
83621: LD_INT 1
83623: NEG
83624: PUSH
83625: LD_INT 0
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 1
83634: NEG
83635: PUSH
83636: LD_INT 1
83638: NEG
83639: PUSH
83640: EMPTY
83641: LIST
83642: LIST
83643: PUSH
83644: LD_INT 1
83646: NEG
83647: PUSH
83648: LD_INT 2
83650: NEG
83651: PUSH
83652: EMPTY
83653: LIST
83654: LIST
83655: PUSH
83656: LD_INT 1
83658: PUSH
83659: LD_INT 1
83661: NEG
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: PUSH
83667: LD_INT 2
83669: PUSH
83670: LD_INT 0
83672: PUSH
83673: EMPTY
83674: LIST
83675: LIST
83676: PUSH
83677: LD_INT 2
83679: PUSH
83680: LD_INT 1
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 1
83689: PUSH
83690: LD_INT 2
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 0
83699: PUSH
83700: LD_INT 2
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 1
83709: NEG
83710: PUSH
83711: LD_INT 1
83713: PUSH
83714: EMPTY
83715: LIST
83716: LIST
83717: PUSH
83718: LD_INT 2
83720: NEG
83721: PUSH
83722: LD_INT 0
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 2
83731: NEG
83732: PUSH
83733: LD_INT 1
83735: NEG
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: LD_INT 2
83743: NEG
83744: PUSH
83745: LD_INT 2
83747: NEG
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: LD_INT 2
83755: NEG
83756: PUSH
83757: LD_INT 3
83759: NEG
83760: PUSH
83761: EMPTY
83762: LIST
83763: LIST
83764: PUSH
83765: LD_INT 2
83767: PUSH
83768: LD_INT 1
83770: NEG
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 3
83778: PUSH
83779: LD_INT 1
83781: PUSH
83782: EMPTY
83783: LIST
83784: LIST
83785: PUSH
83786: LD_INT 1
83788: PUSH
83789: LD_INT 3
83791: PUSH
83792: EMPTY
83793: LIST
83794: LIST
83795: PUSH
83796: LD_INT 1
83798: NEG
83799: PUSH
83800: LD_INT 2
83802: PUSH
83803: EMPTY
83804: LIST
83805: LIST
83806: PUSH
83807: LD_INT 3
83809: NEG
83810: PUSH
83811: LD_INT 2
83813: NEG
83814: PUSH
83815: EMPTY
83816: LIST
83817: LIST
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: LIST
83839: LIST
83840: LIST
83841: LIST
83842: LIST
83843: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
83844: LD_ADDR_VAR 0 34
83848: PUSH
83849: LD_INT 0
83851: PUSH
83852: LD_INT 0
83854: PUSH
83855: EMPTY
83856: LIST
83857: LIST
83858: PUSH
83859: LD_INT 0
83861: PUSH
83862: LD_INT 1
83864: NEG
83865: PUSH
83866: EMPTY
83867: LIST
83868: LIST
83869: PUSH
83870: LD_INT 1
83872: PUSH
83873: LD_INT 0
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: PUSH
83880: LD_INT 1
83882: PUSH
83883: LD_INT 1
83885: PUSH
83886: EMPTY
83887: LIST
83888: LIST
83889: PUSH
83890: LD_INT 0
83892: PUSH
83893: LD_INT 1
83895: PUSH
83896: EMPTY
83897: LIST
83898: LIST
83899: PUSH
83900: LD_INT 1
83902: NEG
83903: PUSH
83904: LD_INT 0
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 1
83913: NEG
83914: PUSH
83915: LD_INT 1
83917: NEG
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: PUSH
83923: LD_INT 1
83925: NEG
83926: PUSH
83927: LD_INT 2
83929: NEG
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: PUSH
83935: LD_INT 0
83937: PUSH
83938: LD_INT 2
83940: NEG
83941: PUSH
83942: EMPTY
83943: LIST
83944: LIST
83945: PUSH
83946: LD_INT 1
83948: PUSH
83949: LD_INT 1
83951: NEG
83952: PUSH
83953: EMPTY
83954: LIST
83955: LIST
83956: PUSH
83957: LD_INT 2
83959: PUSH
83960: LD_INT 1
83962: PUSH
83963: EMPTY
83964: LIST
83965: LIST
83966: PUSH
83967: LD_INT 2
83969: PUSH
83970: LD_INT 2
83972: PUSH
83973: EMPTY
83974: LIST
83975: LIST
83976: PUSH
83977: LD_INT 1
83979: PUSH
83980: LD_INT 2
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: LD_INT 1
83989: NEG
83990: PUSH
83991: LD_INT 1
83993: PUSH
83994: EMPTY
83995: LIST
83996: LIST
83997: PUSH
83998: LD_INT 2
84000: NEG
84001: PUSH
84002: LD_INT 0
84004: PUSH
84005: EMPTY
84006: LIST
84007: LIST
84008: PUSH
84009: LD_INT 2
84011: NEG
84012: PUSH
84013: LD_INT 1
84015: NEG
84016: PUSH
84017: EMPTY
84018: LIST
84019: LIST
84020: PUSH
84021: LD_INT 2
84023: NEG
84024: PUSH
84025: LD_INT 2
84027: NEG
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PUSH
84033: LD_INT 1
84035: NEG
84036: PUSH
84037: LD_INT 3
84039: NEG
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 1
84047: PUSH
84048: LD_INT 2
84050: NEG
84051: PUSH
84052: EMPTY
84053: LIST
84054: LIST
84055: PUSH
84056: LD_INT 3
84058: PUSH
84059: LD_INT 2
84061: PUSH
84062: EMPTY
84063: LIST
84064: LIST
84065: PUSH
84066: LD_INT 2
84068: PUSH
84069: LD_INT 3
84071: PUSH
84072: EMPTY
84073: LIST
84074: LIST
84075: PUSH
84076: LD_INT 2
84078: NEG
84079: PUSH
84080: LD_INT 1
84082: PUSH
84083: EMPTY
84084: LIST
84085: LIST
84086: PUSH
84087: LD_INT 3
84089: NEG
84090: PUSH
84091: LD_INT 1
84093: NEG
84094: PUSH
84095: EMPTY
84096: LIST
84097: LIST
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: LIST
84103: LIST
84104: LIST
84105: LIST
84106: LIST
84107: LIST
84108: LIST
84109: LIST
84110: LIST
84111: LIST
84112: LIST
84113: LIST
84114: LIST
84115: LIST
84116: LIST
84117: LIST
84118: LIST
84119: LIST
84120: LIST
84121: LIST
84122: LIST
84123: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84124: LD_ADDR_VAR 0 35
84128: PUSH
84129: LD_INT 0
84131: PUSH
84132: LD_INT 0
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: PUSH
84139: LD_INT 0
84141: PUSH
84142: LD_INT 1
84144: NEG
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: PUSH
84150: LD_INT 1
84152: PUSH
84153: LD_INT 0
84155: PUSH
84156: EMPTY
84157: LIST
84158: LIST
84159: PUSH
84160: LD_INT 1
84162: PUSH
84163: LD_INT 1
84165: PUSH
84166: EMPTY
84167: LIST
84168: LIST
84169: PUSH
84170: LD_INT 0
84172: PUSH
84173: LD_INT 1
84175: PUSH
84176: EMPTY
84177: LIST
84178: LIST
84179: PUSH
84180: LD_INT 1
84182: NEG
84183: PUSH
84184: LD_INT 0
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 1
84193: NEG
84194: PUSH
84195: LD_INT 1
84197: NEG
84198: PUSH
84199: EMPTY
84200: LIST
84201: LIST
84202: PUSH
84203: LD_INT 2
84205: PUSH
84206: LD_INT 1
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 2
84215: NEG
84216: PUSH
84217: LD_INT 1
84219: NEG
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: PUSH
84225: EMPTY
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84236: LD_ADDR_VAR 0 36
84240: PUSH
84241: LD_INT 0
84243: PUSH
84244: LD_INT 0
84246: PUSH
84247: EMPTY
84248: LIST
84249: LIST
84250: PUSH
84251: LD_INT 0
84253: PUSH
84254: LD_INT 1
84256: NEG
84257: PUSH
84258: EMPTY
84259: LIST
84260: LIST
84261: PUSH
84262: LD_INT 1
84264: PUSH
84265: LD_INT 0
84267: PUSH
84268: EMPTY
84269: LIST
84270: LIST
84271: PUSH
84272: LD_INT 1
84274: PUSH
84275: LD_INT 1
84277: PUSH
84278: EMPTY
84279: LIST
84280: LIST
84281: PUSH
84282: LD_INT 0
84284: PUSH
84285: LD_INT 1
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: LD_INT 1
84294: NEG
84295: PUSH
84296: LD_INT 0
84298: PUSH
84299: EMPTY
84300: LIST
84301: LIST
84302: PUSH
84303: LD_INT 1
84305: NEG
84306: PUSH
84307: LD_INT 1
84309: NEG
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: PUSH
84315: LD_INT 1
84317: NEG
84318: PUSH
84319: LD_INT 2
84321: NEG
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 1
84329: PUSH
84330: LD_INT 2
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: EMPTY
84338: LIST
84339: LIST
84340: LIST
84341: LIST
84342: LIST
84343: LIST
84344: LIST
84345: LIST
84346: LIST
84347: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84348: LD_ADDR_VAR 0 37
84352: PUSH
84353: LD_INT 0
84355: PUSH
84356: LD_INT 0
84358: PUSH
84359: EMPTY
84360: LIST
84361: LIST
84362: PUSH
84363: LD_INT 0
84365: PUSH
84366: LD_INT 1
84368: NEG
84369: PUSH
84370: EMPTY
84371: LIST
84372: LIST
84373: PUSH
84374: LD_INT 1
84376: PUSH
84377: LD_INT 0
84379: PUSH
84380: EMPTY
84381: LIST
84382: LIST
84383: PUSH
84384: LD_INT 1
84386: PUSH
84387: LD_INT 1
84389: PUSH
84390: EMPTY
84391: LIST
84392: LIST
84393: PUSH
84394: LD_INT 0
84396: PUSH
84397: LD_INT 1
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 1
84406: NEG
84407: PUSH
84408: LD_INT 0
84410: PUSH
84411: EMPTY
84412: LIST
84413: LIST
84414: PUSH
84415: LD_INT 1
84417: NEG
84418: PUSH
84419: LD_INT 1
84421: NEG
84422: PUSH
84423: EMPTY
84424: LIST
84425: LIST
84426: PUSH
84427: LD_INT 1
84429: PUSH
84430: LD_INT 1
84432: NEG
84433: PUSH
84434: EMPTY
84435: LIST
84436: LIST
84437: PUSH
84438: LD_INT 1
84440: NEG
84441: PUSH
84442: LD_INT 1
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: LIST
84453: LIST
84454: LIST
84455: LIST
84456: LIST
84457: LIST
84458: LIST
84459: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
84460: LD_ADDR_VAR 0 38
84464: PUSH
84465: LD_INT 0
84467: PUSH
84468: LD_INT 0
84470: PUSH
84471: EMPTY
84472: LIST
84473: LIST
84474: PUSH
84475: LD_INT 0
84477: PUSH
84478: LD_INT 1
84480: NEG
84481: PUSH
84482: EMPTY
84483: LIST
84484: LIST
84485: PUSH
84486: LD_INT 1
84488: PUSH
84489: LD_INT 0
84491: PUSH
84492: EMPTY
84493: LIST
84494: LIST
84495: PUSH
84496: LD_INT 1
84498: PUSH
84499: LD_INT 1
84501: PUSH
84502: EMPTY
84503: LIST
84504: LIST
84505: PUSH
84506: LD_INT 0
84508: PUSH
84509: LD_INT 1
84511: PUSH
84512: EMPTY
84513: LIST
84514: LIST
84515: PUSH
84516: LD_INT 1
84518: NEG
84519: PUSH
84520: LD_INT 0
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: PUSH
84527: LD_INT 1
84529: NEG
84530: PUSH
84531: LD_INT 1
84533: NEG
84534: PUSH
84535: EMPTY
84536: LIST
84537: LIST
84538: PUSH
84539: LD_INT 2
84541: PUSH
84542: LD_INT 1
84544: PUSH
84545: EMPTY
84546: LIST
84547: LIST
84548: PUSH
84549: LD_INT 2
84551: NEG
84552: PUSH
84553: LD_INT 1
84555: NEG
84556: PUSH
84557: EMPTY
84558: LIST
84559: LIST
84560: PUSH
84561: EMPTY
84562: LIST
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: LIST
84568: LIST
84569: LIST
84570: LIST
84571: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
84572: LD_ADDR_VAR 0 39
84576: PUSH
84577: LD_INT 0
84579: PUSH
84580: LD_INT 0
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: PUSH
84587: LD_INT 0
84589: PUSH
84590: LD_INT 1
84592: NEG
84593: PUSH
84594: EMPTY
84595: LIST
84596: LIST
84597: PUSH
84598: LD_INT 1
84600: PUSH
84601: LD_INT 0
84603: PUSH
84604: EMPTY
84605: LIST
84606: LIST
84607: PUSH
84608: LD_INT 1
84610: PUSH
84611: LD_INT 1
84613: PUSH
84614: EMPTY
84615: LIST
84616: LIST
84617: PUSH
84618: LD_INT 0
84620: PUSH
84621: LD_INT 1
84623: PUSH
84624: EMPTY
84625: LIST
84626: LIST
84627: PUSH
84628: LD_INT 1
84630: NEG
84631: PUSH
84632: LD_INT 0
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: PUSH
84639: LD_INT 1
84641: NEG
84642: PUSH
84643: LD_INT 1
84645: NEG
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: PUSH
84651: LD_INT 1
84653: NEG
84654: PUSH
84655: LD_INT 2
84657: NEG
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: PUSH
84663: LD_INT 1
84665: PUSH
84666: LD_INT 2
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: PUSH
84673: EMPTY
84674: LIST
84675: LIST
84676: LIST
84677: LIST
84678: LIST
84679: LIST
84680: LIST
84681: LIST
84682: LIST
84683: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
84684: LD_ADDR_VAR 0 40
84688: PUSH
84689: LD_INT 0
84691: PUSH
84692: LD_INT 0
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: LD_INT 0
84701: PUSH
84702: LD_INT 1
84704: NEG
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: PUSH
84710: LD_INT 1
84712: PUSH
84713: LD_INT 0
84715: PUSH
84716: EMPTY
84717: LIST
84718: LIST
84719: PUSH
84720: LD_INT 1
84722: PUSH
84723: LD_INT 1
84725: PUSH
84726: EMPTY
84727: LIST
84728: LIST
84729: PUSH
84730: LD_INT 0
84732: PUSH
84733: LD_INT 1
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 1
84742: NEG
84743: PUSH
84744: LD_INT 0
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: PUSH
84751: LD_INT 1
84753: NEG
84754: PUSH
84755: LD_INT 1
84757: NEG
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 1
84765: PUSH
84766: LD_INT 1
84768: NEG
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: PUSH
84774: LD_INT 1
84776: NEG
84777: PUSH
84778: LD_INT 1
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: LIST
84789: LIST
84790: LIST
84791: LIST
84792: LIST
84793: LIST
84794: LIST
84795: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
84796: LD_ADDR_VAR 0 41
84800: PUSH
84801: LD_INT 0
84803: PUSH
84804: LD_INT 0
84806: PUSH
84807: EMPTY
84808: LIST
84809: LIST
84810: PUSH
84811: LD_INT 0
84813: PUSH
84814: LD_INT 1
84816: NEG
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: PUSH
84822: LD_INT 1
84824: PUSH
84825: LD_INT 0
84827: PUSH
84828: EMPTY
84829: LIST
84830: LIST
84831: PUSH
84832: LD_INT 1
84834: PUSH
84835: LD_INT 1
84837: PUSH
84838: EMPTY
84839: LIST
84840: LIST
84841: PUSH
84842: LD_INT 0
84844: PUSH
84845: LD_INT 1
84847: PUSH
84848: EMPTY
84849: LIST
84850: LIST
84851: PUSH
84852: LD_INT 1
84854: NEG
84855: PUSH
84856: LD_INT 0
84858: PUSH
84859: EMPTY
84860: LIST
84861: LIST
84862: PUSH
84863: LD_INT 1
84865: NEG
84866: PUSH
84867: LD_INT 1
84869: NEG
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 1
84877: NEG
84878: PUSH
84879: LD_INT 2
84881: NEG
84882: PUSH
84883: EMPTY
84884: LIST
84885: LIST
84886: PUSH
84887: LD_INT 1
84889: PUSH
84890: LD_INT 1
84892: NEG
84893: PUSH
84894: EMPTY
84895: LIST
84896: LIST
84897: PUSH
84898: LD_INT 2
84900: PUSH
84901: LD_INT 0
84903: PUSH
84904: EMPTY
84905: LIST
84906: LIST
84907: PUSH
84908: LD_INT 2
84910: PUSH
84911: LD_INT 1
84913: PUSH
84914: EMPTY
84915: LIST
84916: LIST
84917: PUSH
84918: LD_INT 2
84920: PUSH
84921: LD_INT 2
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: PUSH
84928: LD_INT 1
84930: PUSH
84931: LD_INT 2
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: LD_INT 1
84940: NEG
84941: PUSH
84942: LD_INT 1
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 2
84951: NEG
84952: PUSH
84953: LD_INT 0
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 2
84962: NEG
84963: PUSH
84964: LD_INT 1
84966: NEG
84967: PUSH
84968: EMPTY
84969: LIST
84970: LIST
84971: PUSH
84972: LD_INT 2
84974: NEG
84975: PUSH
84976: LD_INT 2
84978: NEG
84979: PUSH
84980: EMPTY
84981: LIST
84982: LIST
84983: PUSH
84984: LD_INT 2
84986: NEG
84987: PUSH
84988: LD_INT 3
84990: NEG
84991: PUSH
84992: EMPTY
84993: LIST
84994: LIST
84995: PUSH
84996: LD_INT 2
84998: PUSH
84999: LD_INT 1
85001: NEG
85002: PUSH
85003: EMPTY
85004: LIST
85005: LIST
85006: PUSH
85007: LD_INT 3
85009: PUSH
85010: LD_INT 0
85012: PUSH
85013: EMPTY
85014: LIST
85015: LIST
85016: PUSH
85017: LD_INT 3
85019: PUSH
85020: LD_INT 1
85022: PUSH
85023: EMPTY
85024: LIST
85025: LIST
85026: PUSH
85027: LD_INT 3
85029: PUSH
85030: LD_INT 2
85032: PUSH
85033: EMPTY
85034: LIST
85035: LIST
85036: PUSH
85037: LD_INT 3
85039: PUSH
85040: LD_INT 3
85042: PUSH
85043: EMPTY
85044: LIST
85045: LIST
85046: PUSH
85047: LD_INT 2
85049: PUSH
85050: LD_INT 3
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 2
85059: NEG
85060: PUSH
85061: LD_INT 1
85063: PUSH
85064: EMPTY
85065: LIST
85066: LIST
85067: PUSH
85068: LD_INT 3
85070: NEG
85071: PUSH
85072: LD_INT 0
85074: PUSH
85075: EMPTY
85076: LIST
85077: LIST
85078: PUSH
85079: LD_INT 3
85081: NEG
85082: PUSH
85083: LD_INT 1
85085: NEG
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 3
85093: NEG
85094: PUSH
85095: LD_INT 2
85097: NEG
85098: PUSH
85099: EMPTY
85100: LIST
85101: LIST
85102: PUSH
85103: LD_INT 3
85105: NEG
85106: PUSH
85107: LD_INT 3
85109: NEG
85110: PUSH
85111: EMPTY
85112: LIST
85113: LIST
85114: PUSH
85115: EMPTY
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: LIST
85127: LIST
85128: LIST
85129: LIST
85130: LIST
85131: LIST
85132: LIST
85133: LIST
85134: LIST
85135: LIST
85136: LIST
85137: LIST
85138: LIST
85139: LIST
85140: LIST
85141: LIST
85142: LIST
85143: LIST
85144: LIST
85145: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85146: LD_ADDR_VAR 0 42
85150: PUSH
85151: LD_INT 0
85153: PUSH
85154: LD_INT 0
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 0
85163: PUSH
85164: LD_INT 1
85166: NEG
85167: PUSH
85168: EMPTY
85169: LIST
85170: LIST
85171: PUSH
85172: LD_INT 1
85174: PUSH
85175: LD_INT 0
85177: PUSH
85178: EMPTY
85179: LIST
85180: LIST
85181: PUSH
85182: LD_INT 1
85184: PUSH
85185: LD_INT 1
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PUSH
85192: LD_INT 0
85194: PUSH
85195: LD_INT 1
85197: PUSH
85198: EMPTY
85199: LIST
85200: LIST
85201: PUSH
85202: LD_INT 1
85204: NEG
85205: PUSH
85206: LD_INT 0
85208: PUSH
85209: EMPTY
85210: LIST
85211: LIST
85212: PUSH
85213: LD_INT 1
85215: NEG
85216: PUSH
85217: LD_INT 1
85219: NEG
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 1
85227: NEG
85228: PUSH
85229: LD_INT 2
85231: NEG
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: LD_INT 0
85239: PUSH
85240: LD_INT 2
85242: NEG
85243: PUSH
85244: EMPTY
85245: LIST
85246: LIST
85247: PUSH
85248: LD_INT 1
85250: PUSH
85251: LD_INT 1
85253: NEG
85254: PUSH
85255: EMPTY
85256: LIST
85257: LIST
85258: PUSH
85259: LD_INT 2
85261: PUSH
85262: LD_INT 1
85264: PUSH
85265: EMPTY
85266: LIST
85267: LIST
85268: PUSH
85269: LD_INT 2
85271: PUSH
85272: LD_INT 2
85274: PUSH
85275: EMPTY
85276: LIST
85277: LIST
85278: PUSH
85279: LD_INT 1
85281: PUSH
85282: LD_INT 2
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 0
85291: PUSH
85292: LD_INT 2
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: LD_INT 1
85301: NEG
85302: PUSH
85303: LD_INT 1
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: PUSH
85310: LD_INT 2
85312: NEG
85313: PUSH
85314: LD_INT 1
85316: NEG
85317: PUSH
85318: EMPTY
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 2
85324: NEG
85325: PUSH
85326: LD_INT 2
85328: NEG
85329: PUSH
85330: EMPTY
85331: LIST
85332: LIST
85333: PUSH
85334: LD_INT 2
85336: NEG
85337: PUSH
85338: LD_INT 3
85340: NEG
85341: PUSH
85342: EMPTY
85343: LIST
85344: LIST
85345: PUSH
85346: LD_INT 1
85348: NEG
85349: PUSH
85350: LD_INT 3
85352: NEG
85353: PUSH
85354: EMPTY
85355: LIST
85356: LIST
85357: PUSH
85358: LD_INT 0
85360: PUSH
85361: LD_INT 3
85363: NEG
85364: PUSH
85365: EMPTY
85366: LIST
85367: LIST
85368: PUSH
85369: LD_INT 1
85371: PUSH
85372: LD_INT 2
85374: NEG
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: PUSH
85380: LD_INT 3
85382: PUSH
85383: LD_INT 2
85385: PUSH
85386: EMPTY
85387: LIST
85388: LIST
85389: PUSH
85390: LD_INT 3
85392: PUSH
85393: LD_INT 3
85395: PUSH
85396: EMPTY
85397: LIST
85398: LIST
85399: PUSH
85400: LD_INT 2
85402: PUSH
85403: LD_INT 3
85405: PUSH
85406: EMPTY
85407: LIST
85408: LIST
85409: PUSH
85410: LD_INT 1
85412: PUSH
85413: LD_INT 3
85415: PUSH
85416: EMPTY
85417: LIST
85418: LIST
85419: PUSH
85420: LD_INT 0
85422: PUSH
85423: LD_INT 3
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: PUSH
85430: LD_INT 1
85432: NEG
85433: PUSH
85434: LD_INT 2
85436: PUSH
85437: EMPTY
85438: LIST
85439: LIST
85440: PUSH
85441: LD_INT 3
85443: NEG
85444: PUSH
85445: LD_INT 2
85447: NEG
85448: PUSH
85449: EMPTY
85450: LIST
85451: LIST
85452: PUSH
85453: LD_INT 3
85455: NEG
85456: PUSH
85457: LD_INT 3
85459: NEG
85460: PUSH
85461: EMPTY
85462: LIST
85463: LIST
85464: PUSH
85465: EMPTY
85466: LIST
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
85496: LD_ADDR_VAR 0 43
85500: PUSH
85501: LD_INT 0
85503: PUSH
85504: LD_INT 0
85506: PUSH
85507: EMPTY
85508: LIST
85509: LIST
85510: PUSH
85511: LD_INT 0
85513: PUSH
85514: LD_INT 1
85516: NEG
85517: PUSH
85518: EMPTY
85519: LIST
85520: LIST
85521: PUSH
85522: LD_INT 1
85524: PUSH
85525: LD_INT 0
85527: PUSH
85528: EMPTY
85529: LIST
85530: LIST
85531: PUSH
85532: LD_INT 1
85534: PUSH
85535: LD_INT 1
85537: PUSH
85538: EMPTY
85539: LIST
85540: LIST
85541: PUSH
85542: LD_INT 0
85544: PUSH
85545: LD_INT 1
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: PUSH
85552: LD_INT 1
85554: NEG
85555: PUSH
85556: LD_INT 0
85558: PUSH
85559: EMPTY
85560: LIST
85561: LIST
85562: PUSH
85563: LD_INT 1
85565: NEG
85566: PUSH
85567: LD_INT 1
85569: NEG
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 1
85577: NEG
85578: PUSH
85579: LD_INT 2
85581: NEG
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: PUSH
85587: LD_INT 0
85589: PUSH
85590: LD_INT 2
85592: NEG
85593: PUSH
85594: EMPTY
85595: LIST
85596: LIST
85597: PUSH
85598: LD_INT 1
85600: PUSH
85601: LD_INT 1
85603: NEG
85604: PUSH
85605: EMPTY
85606: LIST
85607: LIST
85608: PUSH
85609: LD_INT 2
85611: PUSH
85612: LD_INT 0
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: PUSH
85619: LD_INT 2
85621: PUSH
85622: LD_INT 1
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 1
85631: PUSH
85632: LD_INT 2
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 0
85641: PUSH
85642: LD_INT 2
85644: PUSH
85645: EMPTY
85646: LIST
85647: LIST
85648: PUSH
85649: LD_INT 1
85651: NEG
85652: PUSH
85653: LD_INT 1
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PUSH
85660: LD_INT 2
85662: NEG
85663: PUSH
85664: LD_INT 0
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 2
85673: NEG
85674: PUSH
85675: LD_INT 1
85677: NEG
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 1
85685: NEG
85686: PUSH
85687: LD_INT 3
85689: NEG
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 0
85697: PUSH
85698: LD_INT 3
85700: NEG
85701: PUSH
85702: EMPTY
85703: LIST
85704: LIST
85705: PUSH
85706: LD_INT 1
85708: PUSH
85709: LD_INT 2
85711: NEG
85712: PUSH
85713: EMPTY
85714: LIST
85715: LIST
85716: PUSH
85717: LD_INT 2
85719: PUSH
85720: LD_INT 1
85722: NEG
85723: PUSH
85724: EMPTY
85725: LIST
85726: LIST
85727: PUSH
85728: LD_INT 3
85730: PUSH
85731: LD_INT 0
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 3
85740: PUSH
85741: LD_INT 1
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 1
85750: PUSH
85751: LD_INT 3
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: LD_INT 0
85760: PUSH
85761: LD_INT 3
85763: PUSH
85764: EMPTY
85765: LIST
85766: LIST
85767: PUSH
85768: LD_INT 1
85770: NEG
85771: PUSH
85772: LD_INT 2
85774: PUSH
85775: EMPTY
85776: LIST
85777: LIST
85778: PUSH
85779: LD_INT 2
85781: NEG
85782: PUSH
85783: LD_INT 1
85785: PUSH
85786: EMPTY
85787: LIST
85788: LIST
85789: PUSH
85790: LD_INT 3
85792: NEG
85793: PUSH
85794: LD_INT 0
85796: PUSH
85797: EMPTY
85798: LIST
85799: LIST
85800: PUSH
85801: LD_INT 3
85803: NEG
85804: PUSH
85805: LD_INT 1
85807: NEG
85808: PUSH
85809: EMPTY
85810: LIST
85811: LIST
85812: PUSH
85813: EMPTY
85814: LIST
85815: LIST
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: LIST
85823: LIST
85824: LIST
85825: LIST
85826: LIST
85827: LIST
85828: LIST
85829: LIST
85830: LIST
85831: LIST
85832: LIST
85833: LIST
85834: LIST
85835: LIST
85836: LIST
85837: LIST
85838: LIST
85839: LIST
85840: LIST
85841: LIST
85842: LIST
85843: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
85844: LD_ADDR_VAR 0 44
85848: PUSH
85849: LD_INT 0
85851: PUSH
85852: LD_INT 0
85854: PUSH
85855: EMPTY
85856: LIST
85857: LIST
85858: PUSH
85859: LD_INT 0
85861: PUSH
85862: LD_INT 1
85864: NEG
85865: PUSH
85866: EMPTY
85867: LIST
85868: LIST
85869: PUSH
85870: LD_INT 1
85872: PUSH
85873: LD_INT 0
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: PUSH
85880: LD_INT 1
85882: PUSH
85883: LD_INT 1
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: PUSH
85890: LD_INT 0
85892: PUSH
85893: LD_INT 1
85895: PUSH
85896: EMPTY
85897: LIST
85898: LIST
85899: PUSH
85900: LD_INT 1
85902: NEG
85903: PUSH
85904: LD_INT 0
85906: PUSH
85907: EMPTY
85908: LIST
85909: LIST
85910: PUSH
85911: LD_INT 1
85913: NEG
85914: PUSH
85915: LD_INT 1
85917: NEG
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 1
85925: NEG
85926: PUSH
85927: LD_INT 2
85929: NEG
85930: PUSH
85931: EMPTY
85932: LIST
85933: LIST
85934: PUSH
85935: LD_INT 1
85937: PUSH
85938: LD_INT 1
85940: NEG
85941: PUSH
85942: EMPTY
85943: LIST
85944: LIST
85945: PUSH
85946: LD_INT 2
85948: PUSH
85949: LD_INT 0
85951: PUSH
85952: EMPTY
85953: LIST
85954: LIST
85955: PUSH
85956: LD_INT 2
85958: PUSH
85959: LD_INT 1
85961: PUSH
85962: EMPTY
85963: LIST
85964: LIST
85965: PUSH
85966: LD_INT 2
85968: PUSH
85969: LD_INT 2
85971: PUSH
85972: EMPTY
85973: LIST
85974: LIST
85975: PUSH
85976: LD_INT 1
85978: PUSH
85979: LD_INT 2
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PUSH
85986: LD_INT 1
85988: NEG
85989: PUSH
85990: LD_INT 1
85992: PUSH
85993: EMPTY
85994: LIST
85995: LIST
85996: PUSH
85997: LD_INT 2
85999: NEG
86000: PUSH
86001: LD_INT 0
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: PUSH
86008: LD_INT 2
86010: NEG
86011: PUSH
86012: LD_INT 1
86014: NEG
86015: PUSH
86016: EMPTY
86017: LIST
86018: LIST
86019: PUSH
86020: LD_INT 2
86022: NEG
86023: PUSH
86024: LD_INT 2
86026: NEG
86027: PUSH
86028: EMPTY
86029: LIST
86030: LIST
86031: PUSH
86032: LD_INT 2
86034: NEG
86035: PUSH
86036: LD_INT 3
86038: NEG
86039: PUSH
86040: EMPTY
86041: LIST
86042: LIST
86043: PUSH
86044: LD_INT 2
86046: PUSH
86047: LD_INT 1
86049: NEG
86050: PUSH
86051: EMPTY
86052: LIST
86053: LIST
86054: PUSH
86055: LD_INT 3
86057: PUSH
86058: LD_INT 0
86060: PUSH
86061: EMPTY
86062: LIST
86063: LIST
86064: PUSH
86065: LD_INT 3
86067: PUSH
86068: LD_INT 1
86070: PUSH
86071: EMPTY
86072: LIST
86073: LIST
86074: PUSH
86075: LD_INT 3
86077: PUSH
86078: LD_INT 2
86080: PUSH
86081: EMPTY
86082: LIST
86083: LIST
86084: PUSH
86085: LD_INT 3
86087: PUSH
86088: LD_INT 3
86090: PUSH
86091: EMPTY
86092: LIST
86093: LIST
86094: PUSH
86095: LD_INT 2
86097: PUSH
86098: LD_INT 3
86100: PUSH
86101: EMPTY
86102: LIST
86103: LIST
86104: PUSH
86105: LD_INT 2
86107: NEG
86108: PUSH
86109: LD_INT 1
86111: PUSH
86112: EMPTY
86113: LIST
86114: LIST
86115: PUSH
86116: LD_INT 3
86118: NEG
86119: PUSH
86120: LD_INT 0
86122: PUSH
86123: EMPTY
86124: LIST
86125: LIST
86126: PUSH
86127: LD_INT 3
86129: NEG
86130: PUSH
86131: LD_INT 1
86133: NEG
86134: PUSH
86135: EMPTY
86136: LIST
86137: LIST
86138: PUSH
86139: LD_INT 3
86141: NEG
86142: PUSH
86143: LD_INT 2
86145: NEG
86146: PUSH
86147: EMPTY
86148: LIST
86149: LIST
86150: PUSH
86151: LD_INT 3
86153: NEG
86154: PUSH
86155: LD_INT 3
86157: NEG
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: PUSH
86163: EMPTY
86164: LIST
86165: LIST
86166: LIST
86167: LIST
86168: LIST
86169: LIST
86170: LIST
86171: LIST
86172: LIST
86173: LIST
86174: LIST
86175: LIST
86176: LIST
86177: LIST
86178: LIST
86179: LIST
86180: LIST
86181: LIST
86182: LIST
86183: LIST
86184: LIST
86185: LIST
86186: LIST
86187: LIST
86188: LIST
86189: LIST
86190: LIST
86191: LIST
86192: LIST
86193: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86194: LD_ADDR_VAR 0 45
86198: PUSH
86199: LD_INT 0
86201: PUSH
86202: LD_INT 0
86204: PUSH
86205: EMPTY
86206: LIST
86207: LIST
86208: PUSH
86209: LD_INT 0
86211: PUSH
86212: LD_INT 1
86214: NEG
86215: PUSH
86216: EMPTY
86217: LIST
86218: LIST
86219: PUSH
86220: LD_INT 1
86222: PUSH
86223: LD_INT 0
86225: PUSH
86226: EMPTY
86227: LIST
86228: LIST
86229: PUSH
86230: LD_INT 1
86232: PUSH
86233: LD_INT 1
86235: PUSH
86236: EMPTY
86237: LIST
86238: LIST
86239: PUSH
86240: LD_INT 0
86242: PUSH
86243: LD_INT 1
86245: PUSH
86246: EMPTY
86247: LIST
86248: LIST
86249: PUSH
86250: LD_INT 1
86252: NEG
86253: PUSH
86254: LD_INT 0
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PUSH
86261: LD_INT 1
86263: NEG
86264: PUSH
86265: LD_INT 1
86267: NEG
86268: PUSH
86269: EMPTY
86270: LIST
86271: LIST
86272: PUSH
86273: LD_INT 1
86275: NEG
86276: PUSH
86277: LD_INT 2
86279: NEG
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: PUSH
86285: LD_INT 0
86287: PUSH
86288: LD_INT 2
86290: NEG
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: PUSH
86296: LD_INT 1
86298: PUSH
86299: LD_INT 1
86301: NEG
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: PUSH
86307: LD_INT 2
86309: PUSH
86310: LD_INT 1
86312: PUSH
86313: EMPTY
86314: LIST
86315: LIST
86316: PUSH
86317: LD_INT 2
86319: PUSH
86320: LD_INT 2
86322: PUSH
86323: EMPTY
86324: LIST
86325: LIST
86326: PUSH
86327: LD_INT 1
86329: PUSH
86330: LD_INT 2
86332: PUSH
86333: EMPTY
86334: LIST
86335: LIST
86336: PUSH
86337: LD_INT 0
86339: PUSH
86340: LD_INT 2
86342: PUSH
86343: EMPTY
86344: LIST
86345: LIST
86346: PUSH
86347: LD_INT 1
86349: NEG
86350: PUSH
86351: LD_INT 1
86353: PUSH
86354: EMPTY
86355: LIST
86356: LIST
86357: PUSH
86358: LD_INT 2
86360: NEG
86361: PUSH
86362: LD_INT 1
86364: NEG
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 2
86372: NEG
86373: PUSH
86374: LD_INT 2
86376: NEG
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PUSH
86382: LD_INT 2
86384: NEG
86385: PUSH
86386: LD_INT 3
86388: NEG
86389: PUSH
86390: EMPTY
86391: LIST
86392: LIST
86393: PUSH
86394: LD_INT 1
86396: NEG
86397: PUSH
86398: LD_INT 3
86400: NEG
86401: PUSH
86402: EMPTY
86403: LIST
86404: LIST
86405: PUSH
86406: LD_INT 0
86408: PUSH
86409: LD_INT 3
86411: NEG
86412: PUSH
86413: EMPTY
86414: LIST
86415: LIST
86416: PUSH
86417: LD_INT 1
86419: PUSH
86420: LD_INT 2
86422: NEG
86423: PUSH
86424: EMPTY
86425: LIST
86426: LIST
86427: PUSH
86428: LD_INT 3
86430: PUSH
86431: LD_INT 2
86433: PUSH
86434: EMPTY
86435: LIST
86436: LIST
86437: PUSH
86438: LD_INT 3
86440: PUSH
86441: LD_INT 3
86443: PUSH
86444: EMPTY
86445: LIST
86446: LIST
86447: PUSH
86448: LD_INT 2
86450: PUSH
86451: LD_INT 3
86453: PUSH
86454: EMPTY
86455: LIST
86456: LIST
86457: PUSH
86458: LD_INT 1
86460: PUSH
86461: LD_INT 3
86463: PUSH
86464: EMPTY
86465: LIST
86466: LIST
86467: PUSH
86468: LD_INT 0
86470: PUSH
86471: LD_INT 3
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: LD_INT 1
86480: NEG
86481: PUSH
86482: LD_INT 2
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: PUSH
86489: LD_INT 3
86491: NEG
86492: PUSH
86493: LD_INT 2
86495: NEG
86496: PUSH
86497: EMPTY
86498: LIST
86499: LIST
86500: PUSH
86501: LD_INT 3
86503: NEG
86504: PUSH
86505: LD_INT 3
86507: NEG
86508: PUSH
86509: EMPTY
86510: LIST
86511: LIST
86512: PUSH
86513: EMPTY
86514: LIST
86515: LIST
86516: LIST
86517: LIST
86518: LIST
86519: LIST
86520: LIST
86521: LIST
86522: LIST
86523: LIST
86524: LIST
86525: LIST
86526: LIST
86527: LIST
86528: LIST
86529: LIST
86530: LIST
86531: LIST
86532: LIST
86533: LIST
86534: LIST
86535: LIST
86536: LIST
86537: LIST
86538: LIST
86539: LIST
86540: LIST
86541: LIST
86542: LIST
86543: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
86544: LD_ADDR_VAR 0 46
86548: PUSH
86549: LD_INT 0
86551: PUSH
86552: LD_INT 0
86554: PUSH
86555: EMPTY
86556: LIST
86557: LIST
86558: PUSH
86559: LD_INT 0
86561: PUSH
86562: LD_INT 1
86564: NEG
86565: PUSH
86566: EMPTY
86567: LIST
86568: LIST
86569: PUSH
86570: LD_INT 1
86572: PUSH
86573: LD_INT 0
86575: PUSH
86576: EMPTY
86577: LIST
86578: LIST
86579: PUSH
86580: LD_INT 1
86582: PUSH
86583: LD_INT 1
86585: PUSH
86586: EMPTY
86587: LIST
86588: LIST
86589: PUSH
86590: LD_INT 0
86592: PUSH
86593: LD_INT 1
86595: PUSH
86596: EMPTY
86597: LIST
86598: LIST
86599: PUSH
86600: LD_INT 1
86602: NEG
86603: PUSH
86604: LD_INT 0
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 1
86613: NEG
86614: PUSH
86615: LD_INT 1
86617: NEG
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: LD_INT 1
86625: NEG
86626: PUSH
86627: LD_INT 2
86629: NEG
86630: PUSH
86631: EMPTY
86632: LIST
86633: LIST
86634: PUSH
86635: LD_INT 0
86637: PUSH
86638: LD_INT 2
86640: NEG
86641: PUSH
86642: EMPTY
86643: LIST
86644: LIST
86645: PUSH
86646: LD_INT 1
86648: PUSH
86649: LD_INT 1
86651: NEG
86652: PUSH
86653: EMPTY
86654: LIST
86655: LIST
86656: PUSH
86657: LD_INT 2
86659: PUSH
86660: LD_INT 0
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 2
86669: PUSH
86670: LD_INT 1
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: LD_INT 1
86679: PUSH
86680: LD_INT 2
86682: PUSH
86683: EMPTY
86684: LIST
86685: LIST
86686: PUSH
86687: LD_INT 0
86689: PUSH
86690: LD_INT 2
86692: PUSH
86693: EMPTY
86694: LIST
86695: LIST
86696: PUSH
86697: LD_INT 1
86699: NEG
86700: PUSH
86701: LD_INT 1
86703: PUSH
86704: EMPTY
86705: LIST
86706: LIST
86707: PUSH
86708: LD_INT 2
86710: NEG
86711: PUSH
86712: LD_INT 0
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: PUSH
86719: LD_INT 2
86721: NEG
86722: PUSH
86723: LD_INT 1
86725: NEG
86726: PUSH
86727: EMPTY
86728: LIST
86729: LIST
86730: PUSH
86731: LD_INT 1
86733: NEG
86734: PUSH
86735: LD_INT 3
86737: NEG
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: PUSH
86743: LD_INT 0
86745: PUSH
86746: LD_INT 3
86748: NEG
86749: PUSH
86750: EMPTY
86751: LIST
86752: LIST
86753: PUSH
86754: LD_INT 1
86756: PUSH
86757: LD_INT 2
86759: NEG
86760: PUSH
86761: EMPTY
86762: LIST
86763: LIST
86764: PUSH
86765: LD_INT 2
86767: PUSH
86768: LD_INT 1
86770: NEG
86771: PUSH
86772: EMPTY
86773: LIST
86774: LIST
86775: PUSH
86776: LD_INT 3
86778: PUSH
86779: LD_INT 0
86781: PUSH
86782: EMPTY
86783: LIST
86784: LIST
86785: PUSH
86786: LD_INT 3
86788: PUSH
86789: LD_INT 1
86791: PUSH
86792: EMPTY
86793: LIST
86794: LIST
86795: PUSH
86796: LD_INT 1
86798: PUSH
86799: LD_INT 3
86801: PUSH
86802: EMPTY
86803: LIST
86804: LIST
86805: PUSH
86806: LD_INT 0
86808: PUSH
86809: LD_INT 3
86811: PUSH
86812: EMPTY
86813: LIST
86814: LIST
86815: PUSH
86816: LD_INT 1
86818: NEG
86819: PUSH
86820: LD_INT 2
86822: PUSH
86823: EMPTY
86824: LIST
86825: LIST
86826: PUSH
86827: LD_INT 2
86829: NEG
86830: PUSH
86831: LD_INT 1
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 3
86840: NEG
86841: PUSH
86842: LD_INT 0
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: LD_INT 3
86851: NEG
86852: PUSH
86853: LD_INT 1
86855: NEG
86856: PUSH
86857: EMPTY
86858: LIST
86859: LIST
86860: PUSH
86861: EMPTY
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: LIST
86890: LIST
86891: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
86892: LD_ADDR_VAR 0 47
86896: PUSH
86897: LD_INT 0
86899: PUSH
86900: LD_INT 0
86902: PUSH
86903: EMPTY
86904: LIST
86905: LIST
86906: PUSH
86907: LD_INT 0
86909: PUSH
86910: LD_INT 1
86912: NEG
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 1
86920: PUSH
86921: LD_INT 0
86923: PUSH
86924: EMPTY
86925: LIST
86926: LIST
86927: PUSH
86928: LD_INT 1
86930: PUSH
86931: LD_INT 1
86933: PUSH
86934: EMPTY
86935: LIST
86936: LIST
86937: PUSH
86938: LD_INT 0
86940: PUSH
86941: LD_INT 1
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: PUSH
86948: LD_INT 1
86950: NEG
86951: PUSH
86952: LD_INT 0
86954: PUSH
86955: EMPTY
86956: LIST
86957: LIST
86958: PUSH
86959: LD_INT 1
86961: NEG
86962: PUSH
86963: LD_INT 1
86965: NEG
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: PUSH
86971: LD_INT 1
86973: NEG
86974: PUSH
86975: LD_INT 2
86977: NEG
86978: PUSH
86979: EMPTY
86980: LIST
86981: LIST
86982: PUSH
86983: LD_INT 0
86985: PUSH
86986: LD_INT 2
86988: NEG
86989: PUSH
86990: EMPTY
86991: LIST
86992: LIST
86993: PUSH
86994: LD_INT 1
86996: PUSH
86997: LD_INT 1
86999: NEG
87000: PUSH
87001: EMPTY
87002: LIST
87003: LIST
87004: PUSH
87005: LD_INT 2
87007: NEG
87008: PUSH
87009: LD_INT 1
87011: NEG
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: PUSH
87017: LD_INT 2
87019: NEG
87020: PUSH
87021: LD_INT 2
87023: NEG
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
87043: LD_ADDR_VAR 0 48
87047: PUSH
87048: LD_INT 0
87050: PUSH
87051: LD_INT 0
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: PUSH
87058: LD_INT 0
87060: PUSH
87061: LD_INT 1
87063: NEG
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 1
87071: PUSH
87072: LD_INT 0
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: PUSH
87079: LD_INT 1
87081: PUSH
87082: LD_INT 1
87084: PUSH
87085: EMPTY
87086: LIST
87087: LIST
87088: PUSH
87089: LD_INT 0
87091: PUSH
87092: LD_INT 1
87094: PUSH
87095: EMPTY
87096: LIST
87097: LIST
87098: PUSH
87099: LD_INT 1
87101: NEG
87102: PUSH
87103: LD_INT 0
87105: PUSH
87106: EMPTY
87107: LIST
87108: LIST
87109: PUSH
87110: LD_INT 1
87112: NEG
87113: PUSH
87114: LD_INT 1
87116: NEG
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 1
87124: NEG
87125: PUSH
87126: LD_INT 2
87128: NEG
87129: PUSH
87130: EMPTY
87131: LIST
87132: LIST
87133: PUSH
87134: LD_INT 0
87136: PUSH
87137: LD_INT 2
87139: NEG
87140: PUSH
87141: EMPTY
87142: LIST
87143: LIST
87144: PUSH
87145: LD_INT 1
87147: PUSH
87148: LD_INT 1
87150: NEG
87151: PUSH
87152: EMPTY
87153: LIST
87154: LIST
87155: PUSH
87156: LD_INT 2
87158: PUSH
87159: LD_INT 0
87161: PUSH
87162: EMPTY
87163: LIST
87164: LIST
87165: PUSH
87166: LD_INT 2
87168: PUSH
87169: LD_INT 1
87171: PUSH
87172: EMPTY
87173: LIST
87174: LIST
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: LIST
87182: LIST
87183: LIST
87184: LIST
87185: LIST
87186: LIST
87187: LIST
87188: LIST
87189: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
87190: LD_ADDR_VAR 0 49
87194: PUSH
87195: LD_INT 0
87197: PUSH
87198: LD_INT 0
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 0
87207: PUSH
87208: LD_INT 1
87210: NEG
87211: PUSH
87212: EMPTY
87213: LIST
87214: LIST
87215: PUSH
87216: LD_INT 1
87218: PUSH
87219: LD_INT 0
87221: PUSH
87222: EMPTY
87223: LIST
87224: LIST
87225: PUSH
87226: LD_INT 1
87228: PUSH
87229: LD_INT 1
87231: PUSH
87232: EMPTY
87233: LIST
87234: LIST
87235: PUSH
87236: LD_INT 0
87238: PUSH
87239: LD_INT 1
87241: PUSH
87242: EMPTY
87243: LIST
87244: LIST
87245: PUSH
87246: LD_INT 1
87248: NEG
87249: PUSH
87250: LD_INT 0
87252: PUSH
87253: EMPTY
87254: LIST
87255: LIST
87256: PUSH
87257: LD_INT 1
87259: NEG
87260: PUSH
87261: LD_INT 1
87263: NEG
87264: PUSH
87265: EMPTY
87266: LIST
87267: LIST
87268: PUSH
87269: LD_INT 1
87271: PUSH
87272: LD_INT 1
87274: NEG
87275: PUSH
87276: EMPTY
87277: LIST
87278: LIST
87279: PUSH
87280: LD_INT 2
87282: PUSH
87283: LD_INT 0
87285: PUSH
87286: EMPTY
87287: LIST
87288: LIST
87289: PUSH
87290: LD_INT 2
87292: PUSH
87293: LD_INT 1
87295: PUSH
87296: EMPTY
87297: LIST
87298: LIST
87299: PUSH
87300: LD_INT 2
87302: PUSH
87303: LD_INT 2
87305: PUSH
87306: EMPTY
87307: LIST
87308: LIST
87309: PUSH
87310: LD_INT 1
87312: PUSH
87313: LD_INT 2
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: LIST
87324: LIST
87325: LIST
87326: LIST
87327: LIST
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
87334: LD_ADDR_VAR 0 50
87338: PUSH
87339: LD_INT 0
87341: PUSH
87342: LD_INT 0
87344: PUSH
87345: EMPTY
87346: LIST
87347: LIST
87348: PUSH
87349: LD_INT 0
87351: PUSH
87352: LD_INT 1
87354: NEG
87355: PUSH
87356: EMPTY
87357: LIST
87358: LIST
87359: PUSH
87360: LD_INT 1
87362: PUSH
87363: LD_INT 0
87365: PUSH
87366: EMPTY
87367: LIST
87368: LIST
87369: PUSH
87370: LD_INT 1
87372: PUSH
87373: LD_INT 1
87375: PUSH
87376: EMPTY
87377: LIST
87378: LIST
87379: PUSH
87380: LD_INT 0
87382: PUSH
87383: LD_INT 1
87385: PUSH
87386: EMPTY
87387: LIST
87388: LIST
87389: PUSH
87390: LD_INT 1
87392: NEG
87393: PUSH
87394: LD_INT 0
87396: PUSH
87397: EMPTY
87398: LIST
87399: LIST
87400: PUSH
87401: LD_INT 1
87403: NEG
87404: PUSH
87405: LD_INT 1
87407: NEG
87408: PUSH
87409: EMPTY
87410: LIST
87411: LIST
87412: PUSH
87413: LD_INT 2
87415: PUSH
87416: LD_INT 1
87418: PUSH
87419: EMPTY
87420: LIST
87421: LIST
87422: PUSH
87423: LD_INT 2
87425: PUSH
87426: LD_INT 2
87428: PUSH
87429: EMPTY
87430: LIST
87431: LIST
87432: PUSH
87433: LD_INT 1
87435: PUSH
87436: LD_INT 2
87438: PUSH
87439: EMPTY
87440: LIST
87441: LIST
87442: PUSH
87443: LD_INT 0
87445: PUSH
87446: LD_INT 2
87448: PUSH
87449: EMPTY
87450: LIST
87451: LIST
87452: PUSH
87453: LD_INT 1
87455: NEG
87456: PUSH
87457: LD_INT 1
87459: PUSH
87460: EMPTY
87461: LIST
87462: LIST
87463: PUSH
87464: EMPTY
87465: LIST
87466: LIST
87467: LIST
87468: LIST
87469: LIST
87470: LIST
87471: LIST
87472: LIST
87473: LIST
87474: LIST
87475: LIST
87476: LIST
87477: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
87478: LD_ADDR_VAR 0 51
87482: PUSH
87483: LD_INT 0
87485: PUSH
87486: LD_INT 0
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 0
87495: PUSH
87496: LD_INT 1
87498: NEG
87499: PUSH
87500: EMPTY
87501: LIST
87502: LIST
87503: PUSH
87504: LD_INT 1
87506: PUSH
87507: LD_INT 0
87509: PUSH
87510: EMPTY
87511: LIST
87512: LIST
87513: PUSH
87514: LD_INT 1
87516: PUSH
87517: LD_INT 1
87519: PUSH
87520: EMPTY
87521: LIST
87522: LIST
87523: PUSH
87524: LD_INT 0
87526: PUSH
87527: LD_INT 1
87529: PUSH
87530: EMPTY
87531: LIST
87532: LIST
87533: PUSH
87534: LD_INT 1
87536: NEG
87537: PUSH
87538: LD_INT 0
87540: PUSH
87541: EMPTY
87542: LIST
87543: LIST
87544: PUSH
87545: LD_INT 1
87547: NEG
87548: PUSH
87549: LD_INT 1
87551: NEG
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 1
87559: PUSH
87560: LD_INT 2
87562: PUSH
87563: EMPTY
87564: LIST
87565: LIST
87566: PUSH
87567: LD_INT 0
87569: PUSH
87570: LD_INT 2
87572: PUSH
87573: EMPTY
87574: LIST
87575: LIST
87576: PUSH
87577: LD_INT 1
87579: NEG
87580: PUSH
87581: LD_INT 1
87583: PUSH
87584: EMPTY
87585: LIST
87586: LIST
87587: PUSH
87588: LD_INT 2
87590: NEG
87591: PUSH
87592: LD_INT 0
87594: PUSH
87595: EMPTY
87596: LIST
87597: LIST
87598: PUSH
87599: LD_INT 2
87601: NEG
87602: PUSH
87603: LD_INT 1
87605: NEG
87606: PUSH
87607: EMPTY
87608: LIST
87609: LIST
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: LIST
87615: LIST
87616: LIST
87617: LIST
87618: LIST
87619: LIST
87620: LIST
87621: LIST
87622: LIST
87623: LIST
87624: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87625: LD_ADDR_VAR 0 52
87629: PUSH
87630: LD_INT 0
87632: PUSH
87633: LD_INT 0
87635: PUSH
87636: EMPTY
87637: LIST
87638: LIST
87639: PUSH
87640: LD_INT 0
87642: PUSH
87643: LD_INT 1
87645: NEG
87646: PUSH
87647: EMPTY
87648: LIST
87649: LIST
87650: PUSH
87651: LD_INT 1
87653: PUSH
87654: LD_INT 0
87656: PUSH
87657: EMPTY
87658: LIST
87659: LIST
87660: PUSH
87661: LD_INT 1
87663: PUSH
87664: LD_INT 1
87666: PUSH
87667: EMPTY
87668: LIST
87669: LIST
87670: PUSH
87671: LD_INT 0
87673: PUSH
87674: LD_INT 1
87676: PUSH
87677: EMPTY
87678: LIST
87679: LIST
87680: PUSH
87681: LD_INT 1
87683: NEG
87684: PUSH
87685: LD_INT 0
87687: PUSH
87688: EMPTY
87689: LIST
87690: LIST
87691: PUSH
87692: LD_INT 1
87694: NEG
87695: PUSH
87696: LD_INT 1
87698: NEG
87699: PUSH
87700: EMPTY
87701: LIST
87702: LIST
87703: PUSH
87704: LD_INT 1
87706: NEG
87707: PUSH
87708: LD_INT 2
87710: NEG
87711: PUSH
87712: EMPTY
87713: LIST
87714: LIST
87715: PUSH
87716: LD_INT 1
87718: NEG
87719: PUSH
87720: LD_INT 1
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: PUSH
87727: LD_INT 2
87729: NEG
87730: PUSH
87731: LD_INT 0
87733: PUSH
87734: EMPTY
87735: LIST
87736: LIST
87737: PUSH
87738: LD_INT 2
87740: NEG
87741: PUSH
87742: LD_INT 1
87744: NEG
87745: PUSH
87746: EMPTY
87747: LIST
87748: LIST
87749: PUSH
87750: LD_INT 2
87752: NEG
87753: PUSH
87754: LD_INT 2
87756: NEG
87757: PUSH
87758: EMPTY
87759: LIST
87760: LIST
87761: PUSH
87762: EMPTY
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: LIST
87774: LIST
87775: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
87776: LD_ADDR_VAR 0 53
87780: PUSH
87781: LD_INT 0
87783: PUSH
87784: LD_INT 0
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PUSH
87791: LD_INT 0
87793: PUSH
87794: LD_INT 1
87796: NEG
87797: PUSH
87798: EMPTY
87799: LIST
87800: LIST
87801: PUSH
87802: LD_INT 1
87804: PUSH
87805: LD_INT 0
87807: PUSH
87808: EMPTY
87809: LIST
87810: LIST
87811: PUSH
87812: LD_INT 1
87814: PUSH
87815: LD_INT 1
87817: PUSH
87818: EMPTY
87819: LIST
87820: LIST
87821: PUSH
87822: LD_INT 0
87824: PUSH
87825: LD_INT 1
87827: PUSH
87828: EMPTY
87829: LIST
87830: LIST
87831: PUSH
87832: LD_INT 1
87834: NEG
87835: PUSH
87836: LD_INT 0
87838: PUSH
87839: EMPTY
87840: LIST
87841: LIST
87842: PUSH
87843: LD_INT 1
87845: NEG
87846: PUSH
87847: LD_INT 1
87849: NEG
87850: PUSH
87851: EMPTY
87852: LIST
87853: LIST
87854: PUSH
87855: LD_INT 1
87857: NEG
87858: PUSH
87859: LD_INT 2
87861: NEG
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: PUSH
87867: LD_INT 0
87869: PUSH
87870: LD_INT 2
87872: NEG
87873: PUSH
87874: EMPTY
87875: LIST
87876: LIST
87877: PUSH
87878: LD_INT 1
87880: PUSH
87881: LD_INT 1
87883: NEG
87884: PUSH
87885: EMPTY
87886: LIST
87887: LIST
87888: PUSH
87889: LD_INT 2
87891: PUSH
87892: LD_INT 0
87894: PUSH
87895: EMPTY
87896: LIST
87897: LIST
87898: PUSH
87899: LD_INT 2
87901: PUSH
87902: LD_INT 1
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: PUSH
87909: LD_INT 2
87911: PUSH
87912: LD_INT 2
87914: PUSH
87915: EMPTY
87916: LIST
87917: LIST
87918: PUSH
87919: LD_INT 1
87921: PUSH
87922: LD_INT 2
87924: PUSH
87925: EMPTY
87926: LIST
87927: LIST
87928: PUSH
87929: LD_INT 0
87931: PUSH
87932: LD_INT 2
87934: PUSH
87935: EMPTY
87936: LIST
87937: LIST
87938: PUSH
87939: LD_INT 1
87941: NEG
87942: PUSH
87943: LD_INT 1
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: PUSH
87950: LD_INT 2
87952: NEG
87953: PUSH
87954: LD_INT 0
87956: PUSH
87957: EMPTY
87958: LIST
87959: LIST
87960: PUSH
87961: LD_INT 2
87963: NEG
87964: PUSH
87965: LD_INT 1
87967: NEG
87968: PUSH
87969: EMPTY
87970: LIST
87971: LIST
87972: PUSH
87973: LD_INT 2
87975: NEG
87976: PUSH
87977: LD_INT 2
87979: NEG
87980: PUSH
87981: EMPTY
87982: LIST
87983: LIST
87984: PUSH
87985: EMPTY
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: LIST
87996: LIST
87997: LIST
87998: LIST
87999: LIST
88000: LIST
88001: LIST
88002: LIST
88003: LIST
88004: LIST
88005: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88006: LD_ADDR_VAR 0 54
88010: PUSH
88011: LD_INT 0
88013: PUSH
88014: LD_INT 0
88016: PUSH
88017: EMPTY
88018: LIST
88019: LIST
88020: PUSH
88021: LD_INT 0
88023: PUSH
88024: LD_INT 1
88026: NEG
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PUSH
88032: LD_INT 1
88034: PUSH
88035: LD_INT 0
88037: PUSH
88038: EMPTY
88039: LIST
88040: LIST
88041: PUSH
88042: LD_INT 1
88044: PUSH
88045: LD_INT 1
88047: PUSH
88048: EMPTY
88049: LIST
88050: LIST
88051: PUSH
88052: LD_INT 0
88054: PUSH
88055: LD_INT 1
88057: PUSH
88058: EMPTY
88059: LIST
88060: LIST
88061: PUSH
88062: LD_INT 1
88064: NEG
88065: PUSH
88066: LD_INT 0
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PUSH
88073: LD_INT 1
88075: NEG
88076: PUSH
88077: LD_INT 1
88079: NEG
88080: PUSH
88081: EMPTY
88082: LIST
88083: LIST
88084: PUSH
88085: LD_INT 1
88087: NEG
88088: PUSH
88089: LD_INT 2
88091: NEG
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: PUSH
88097: LD_INT 0
88099: PUSH
88100: LD_INT 2
88102: NEG
88103: PUSH
88104: EMPTY
88105: LIST
88106: LIST
88107: PUSH
88108: LD_INT 1
88110: PUSH
88111: LD_INT 1
88113: NEG
88114: PUSH
88115: EMPTY
88116: LIST
88117: LIST
88118: PUSH
88119: LD_INT 2
88121: PUSH
88122: LD_INT 0
88124: PUSH
88125: EMPTY
88126: LIST
88127: LIST
88128: PUSH
88129: LD_INT 2
88131: PUSH
88132: LD_INT 1
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 2
88141: PUSH
88142: LD_INT 2
88144: PUSH
88145: EMPTY
88146: LIST
88147: LIST
88148: PUSH
88149: LD_INT 1
88151: PUSH
88152: LD_INT 2
88154: PUSH
88155: EMPTY
88156: LIST
88157: LIST
88158: PUSH
88159: LD_INT 0
88161: PUSH
88162: LD_INT 2
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PUSH
88169: LD_INT 1
88171: NEG
88172: PUSH
88173: LD_INT 1
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: PUSH
88180: LD_INT 2
88182: NEG
88183: PUSH
88184: LD_INT 0
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 2
88193: NEG
88194: PUSH
88195: LD_INT 1
88197: NEG
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 2
88205: NEG
88206: PUSH
88207: LD_INT 2
88209: NEG
88210: PUSH
88211: EMPTY
88212: LIST
88213: LIST
88214: PUSH
88215: EMPTY
88216: LIST
88217: LIST
88218: LIST
88219: LIST
88220: LIST
88221: LIST
88222: LIST
88223: LIST
88224: LIST
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: LIST
88233: LIST
88234: LIST
88235: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88236: LD_ADDR_VAR 0 55
88240: PUSH
88241: LD_INT 0
88243: PUSH
88244: LD_INT 0
88246: PUSH
88247: EMPTY
88248: LIST
88249: LIST
88250: PUSH
88251: LD_INT 0
88253: PUSH
88254: LD_INT 1
88256: NEG
88257: PUSH
88258: EMPTY
88259: LIST
88260: LIST
88261: PUSH
88262: LD_INT 1
88264: PUSH
88265: LD_INT 0
88267: PUSH
88268: EMPTY
88269: LIST
88270: LIST
88271: PUSH
88272: LD_INT 1
88274: PUSH
88275: LD_INT 1
88277: PUSH
88278: EMPTY
88279: LIST
88280: LIST
88281: PUSH
88282: LD_INT 0
88284: PUSH
88285: LD_INT 1
88287: PUSH
88288: EMPTY
88289: LIST
88290: LIST
88291: PUSH
88292: LD_INT 1
88294: NEG
88295: PUSH
88296: LD_INT 0
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 1
88305: NEG
88306: PUSH
88307: LD_INT 1
88309: NEG
88310: PUSH
88311: EMPTY
88312: LIST
88313: LIST
88314: PUSH
88315: LD_INT 1
88317: NEG
88318: PUSH
88319: LD_INT 2
88321: NEG
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: LD_INT 2
88332: NEG
88333: PUSH
88334: EMPTY
88335: LIST
88336: LIST
88337: PUSH
88338: LD_INT 1
88340: PUSH
88341: LD_INT 1
88343: NEG
88344: PUSH
88345: EMPTY
88346: LIST
88347: LIST
88348: PUSH
88349: LD_INT 2
88351: PUSH
88352: LD_INT 0
88354: PUSH
88355: EMPTY
88356: LIST
88357: LIST
88358: PUSH
88359: LD_INT 2
88361: PUSH
88362: LD_INT 1
88364: PUSH
88365: EMPTY
88366: LIST
88367: LIST
88368: PUSH
88369: LD_INT 2
88371: PUSH
88372: LD_INT 2
88374: PUSH
88375: EMPTY
88376: LIST
88377: LIST
88378: PUSH
88379: LD_INT 1
88381: PUSH
88382: LD_INT 2
88384: PUSH
88385: EMPTY
88386: LIST
88387: LIST
88388: PUSH
88389: LD_INT 0
88391: PUSH
88392: LD_INT 2
88394: PUSH
88395: EMPTY
88396: LIST
88397: LIST
88398: PUSH
88399: LD_INT 1
88401: NEG
88402: PUSH
88403: LD_INT 1
88405: PUSH
88406: EMPTY
88407: LIST
88408: LIST
88409: PUSH
88410: LD_INT 2
88412: NEG
88413: PUSH
88414: LD_INT 0
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: LD_INT 2
88423: NEG
88424: PUSH
88425: LD_INT 1
88427: NEG
88428: PUSH
88429: EMPTY
88430: LIST
88431: LIST
88432: PUSH
88433: LD_INT 2
88435: NEG
88436: PUSH
88437: LD_INT 2
88439: NEG
88440: PUSH
88441: EMPTY
88442: LIST
88443: LIST
88444: PUSH
88445: EMPTY
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88466: LD_ADDR_VAR 0 56
88470: PUSH
88471: LD_INT 0
88473: PUSH
88474: LD_INT 0
88476: PUSH
88477: EMPTY
88478: LIST
88479: LIST
88480: PUSH
88481: LD_INT 0
88483: PUSH
88484: LD_INT 1
88486: NEG
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 1
88494: PUSH
88495: LD_INT 0
88497: PUSH
88498: EMPTY
88499: LIST
88500: LIST
88501: PUSH
88502: LD_INT 1
88504: PUSH
88505: LD_INT 1
88507: PUSH
88508: EMPTY
88509: LIST
88510: LIST
88511: PUSH
88512: LD_INT 0
88514: PUSH
88515: LD_INT 1
88517: PUSH
88518: EMPTY
88519: LIST
88520: LIST
88521: PUSH
88522: LD_INT 1
88524: NEG
88525: PUSH
88526: LD_INT 0
88528: PUSH
88529: EMPTY
88530: LIST
88531: LIST
88532: PUSH
88533: LD_INT 1
88535: NEG
88536: PUSH
88537: LD_INT 1
88539: NEG
88540: PUSH
88541: EMPTY
88542: LIST
88543: LIST
88544: PUSH
88545: LD_INT 1
88547: NEG
88548: PUSH
88549: LD_INT 2
88551: NEG
88552: PUSH
88553: EMPTY
88554: LIST
88555: LIST
88556: PUSH
88557: LD_INT 0
88559: PUSH
88560: LD_INT 2
88562: NEG
88563: PUSH
88564: EMPTY
88565: LIST
88566: LIST
88567: PUSH
88568: LD_INT 1
88570: PUSH
88571: LD_INT 1
88573: NEG
88574: PUSH
88575: EMPTY
88576: LIST
88577: LIST
88578: PUSH
88579: LD_INT 2
88581: PUSH
88582: LD_INT 0
88584: PUSH
88585: EMPTY
88586: LIST
88587: LIST
88588: PUSH
88589: LD_INT 2
88591: PUSH
88592: LD_INT 1
88594: PUSH
88595: EMPTY
88596: LIST
88597: LIST
88598: PUSH
88599: LD_INT 2
88601: PUSH
88602: LD_INT 2
88604: PUSH
88605: EMPTY
88606: LIST
88607: LIST
88608: PUSH
88609: LD_INT 1
88611: PUSH
88612: LD_INT 2
88614: PUSH
88615: EMPTY
88616: LIST
88617: LIST
88618: PUSH
88619: LD_INT 0
88621: PUSH
88622: LD_INT 2
88624: PUSH
88625: EMPTY
88626: LIST
88627: LIST
88628: PUSH
88629: LD_INT 1
88631: NEG
88632: PUSH
88633: LD_INT 1
88635: PUSH
88636: EMPTY
88637: LIST
88638: LIST
88639: PUSH
88640: LD_INT 2
88642: NEG
88643: PUSH
88644: LD_INT 0
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PUSH
88651: LD_INT 2
88653: NEG
88654: PUSH
88655: LD_INT 1
88657: NEG
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: PUSH
88663: LD_INT 2
88665: NEG
88666: PUSH
88667: LD_INT 2
88669: NEG
88670: PUSH
88671: EMPTY
88672: LIST
88673: LIST
88674: PUSH
88675: EMPTY
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: LIST
88683: LIST
88684: LIST
88685: LIST
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: LIST
88692: LIST
88693: LIST
88694: LIST
88695: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88696: LD_ADDR_VAR 0 57
88700: PUSH
88701: LD_INT 0
88703: PUSH
88704: LD_INT 0
88706: PUSH
88707: EMPTY
88708: LIST
88709: LIST
88710: PUSH
88711: LD_INT 0
88713: PUSH
88714: LD_INT 1
88716: NEG
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: PUSH
88722: LD_INT 1
88724: PUSH
88725: LD_INT 0
88727: PUSH
88728: EMPTY
88729: LIST
88730: LIST
88731: PUSH
88732: LD_INT 1
88734: PUSH
88735: LD_INT 1
88737: PUSH
88738: EMPTY
88739: LIST
88740: LIST
88741: PUSH
88742: LD_INT 0
88744: PUSH
88745: LD_INT 1
88747: PUSH
88748: EMPTY
88749: LIST
88750: LIST
88751: PUSH
88752: LD_INT 1
88754: NEG
88755: PUSH
88756: LD_INT 0
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: PUSH
88763: LD_INT 1
88765: NEG
88766: PUSH
88767: LD_INT 1
88769: NEG
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PUSH
88775: LD_INT 1
88777: NEG
88778: PUSH
88779: LD_INT 2
88781: NEG
88782: PUSH
88783: EMPTY
88784: LIST
88785: LIST
88786: PUSH
88787: LD_INT 0
88789: PUSH
88790: LD_INT 2
88792: NEG
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: PUSH
88798: LD_INT 1
88800: PUSH
88801: LD_INT 1
88803: NEG
88804: PUSH
88805: EMPTY
88806: LIST
88807: LIST
88808: PUSH
88809: LD_INT 2
88811: PUSH
88812: LD_INT 0
88814: PUSH
88815: EMPTY
88816: LIST
88817: LIST
88818: PUSH
88819: LD_INT 2
88821: PUSH
88822: LD_INT 1
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PUSH
88829: LD_INT 2
88831: PUSH
88832: LD_INT 2
88834: PUSH
88835: EMPTY
88836: LIST
88837: LIST
88838: PUSH
88839: LD_INT 1
88841: PUSH
88842: LD_INT 2
88844: PUSH
88845: EMPTY
88846: LIST
88847: LIST
88848: PUSH
88849: LD_INT 0
88851: PUSH
88852: LD_INT 2
88854: PUSH
88855: EMPTY
88856: LIST
88857: LIST
88858: PUSH
88859: LD_INT 1
88861: NEG
88862: PUSH
88863: LD_INT 1
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 2
88872: NEG
88873: PUSH
88874: LD_INT 0
88876: PUSH
88877: EMPTY
88878: LIST
88879: LIST
88880: PUSH
88881: LD_INT 2
88883: NEG
88884: PUSH
88885: LD_INT 1
88887: NEG
88888: PUSH
88889: EMPTY
88890: LIST
88891: LIST
88892: PUSH
88893: LD_INT 2
88895: NEG
88896: PUSH
88897: LD_INT 2
88899: NEG
88900: PUSH
88901: EMPTY
88902: LIST
88903: LIST
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: LIST
88925: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88926: LD_ADDR_VAR 0 58
88930: PUSH
88931: LD_INT 0
88933: PUSH
88934: LD_INT 0
88936: PUSH
88937: EMPTY
88938: LIST
88939: LIST
88940: PUSH
88941: LD_INT 0
88943: PUSH
88944: LD_INT 1
88946: NEG
88947: PUSH
88948: EMPTY
88949: LIST
88950: LIST
88951: PUSH
88952: LD_INT 1
88954: PUSH
88955: LD_INT 0
88957: PUSH
88958: EMPTY
88959: LIST
88960: LIST
88961: PUSH
88962: LD_INT 1
88964: PUSH
88965: LD_INT 1
88967: PUSH
88968: EMPTY
88969: LIST
88970: LIST
88971: PUSH
88972: LD_INT 0
88974: PUSH
88975: LD_INT 1
88977: PUSH
88978: EMPTY
88979: LIST
88980: LIST
88981: PUSH
88982: LD_INT 1
88984: NEG
88985: PUSH
88986: LD_INT 0
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PUSH
88993: LD_INT 1
88995: NEG
88996: PUSH
88997: LD_INT 1
88999: NEG
89000: PUSH
89001: EMPTY
89002: LIST
89003: LIST
89004: PUSH
89005: LD_INT 1
89007: NEG
89008: PUSH
89009: LD_INT 2
89011: NEG
89012: PUSH
89013: EMPTY
89014: LIST
89015: LIST
89016: PUSH
89017: LD_INT 0
89019: PUSH
89020: LD_INT 2
89022: NEG
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: PUSH
89028: LD_INT 1
89030: PUSH
89031: LD_INT 1
89033: NEG
89034: PUSH
89035: EMPTY
89036: LIST
89037: LIST
89038: PUSH
89039: LD_INT 2
89041: PUSH
89042: LD_INT 0
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PUSH
89049: LD_INT 2
89051: PUSH
89052: LD_INT 1
89054: PUSH
89055: EMPTY
89056: LIST
89057: LIST
89058: PUSH
89059: LD_INT 2
89061: PUSH
89062: LD_INT 2
89064: PUSH
89065: EMPTY
89066: LIST
89067: LIST
89068: PUSH
89069: LD_INT 1
89071: PUSH
89072: LD_INT 2
89074: PUSH
89075: EMPTY
89076: LIST
89077: LIST
89078: PUSH
89079: LD_INT 0
89081: PUSH
89082: LD_INT 2
89084: PUSH
89085: EMPTY
89086: LIST
89087: LIST
89088: PUSH
89089: LD_INT 1
89091: NEG
89092: PUSH
89093: LD_INT 1
89095: PUSH
89096: EMPTY
89097: LIST
89098: LIST
89099: PUSH
89100: LD_INT 2
89102: NEG
89103: PUSH
89104: LD_INT 0
89106: PUSH
89107: EMPTY
89108: LIST
89109: LIST
89110: PUSH
89111: LD_INT 2
89113: NEG
89114: PUSH
89115: LD_INT 1
89117: NEG
89118: PUSH
89119: EMPTY
89120: LIST
89121: LIST
89122: PUSH
89123: LD_INT 2
89125: NEG
89126: PUSH
89127: LD_INT 2
89129: NEG
89130: PUSH
89131: EMPTY
89132: LIST
89133: LIST
89134: PUSH
89135: EMPTY
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: LIST
89146: LIST
89147: LIST
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89156: LD_ADDR_VAR 0 59
89160: PUSH
89161: LD_INT 0
89163: PUSH
89164: LD_INT 0
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: LD_INT 0
89173: PUSH
89174: LD_INT 1
89176: NEG
89177: PUSH
89178: EMPTY
89179: LIST
89180: LIST
89181: PUSH
89182: LD_INT 1
89184: PUSH
89185: LD_INT 0
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: PUSH
89192: LD_INT 1
89194: PUSH
89195: LD_INT 1
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: PUSH
89202: LD_INT 0
89204: PUSH
89205: LD_INT 1
89207: PUSH
89208: EMPTY
89209: LIST
89210: LIST
89211: PUSH
89212: LD_INT 1
89214: NEG
89215: PUSH
89216: LD_INT 0
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: PUSH
89223: LD_INT 1
89225: NEG
89226: PUSH
89227: LD_INT 1
89229: NEG
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: PUSH
89235: EMPTY
89236: LIST
89237: LIST
89238: LIST
89239: LIST
89240: LIST
89241: LIST
89242: LIST
89243: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89244: LD_ADDR_VAR 0 60
89248: PUSH
89249: LD_INT 0
89251: PUSH
89252: LD_INT 0
89254: PUSH
89255: EMPTY
89256: LIST
89257: LIST
89258: PUSH
89259: LD_INT 0
89261: PUSH
89262: LD_INT 1
89264: NEG
89265: PUSH
89266: EMPTY
89267: LIST
89268: LIST
89269: PUSH
89270: LD_INT 1
89272: PUSH
89273: LD_INT 0
89275: PUSH
89276: EMPTY
89277: LIST
89278: LIST
89279: PUSH
89280: LD_INT 1
89282: PUSH
89283: LD_INT 1
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: PUSH
89290: LD_INT 0
89292: PUSH
89293: LD_INT 1
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 1
89302: NEG
89303: PUSH
89304: LD_INT 0
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: LD_INT 1
89313: NEG
89314: PUSH
89315: LD_INT 1
89317: NEG
89318: PUSH
89319: EMPTY
89320: LIST
89321: LIST
89322: PUSH
89323: EMPTY
89324: LIST
89325: LIST
89326: LIST
89327: LIST
89328: LIST
89329: LIST
89330: LIST
89331: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89332: LD_ADDR_VAR 0 61
89336: PUSH
89337: LD_INT 0
89339: PUSH
89340: LD_INT 0
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: PUSH
89347: LD_INT 0
89349: PUSH
89350: LD_INT 1
89352: NEG
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: PUSH
89358: LD_INT 1
89360: PUSH
89361: LD_INT 0
89363: PUSH
89364: EMPTY
89365: LIST
89366: LIST
89367: PUSH
89368: LD_INT 1
89370: PUSH
89371: LD_INT 1
89373: PUSH
89374: EMPTY
89375: LIST
89376: LIST
89377: PUSH
89378: LD_INT 0
89380: PUSH
89381: LD_INT 1
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: PUSH
89388: LD_INT 1
89390: NEG
89391: PUSH
89392: LD_INT 0
89394: PUSH
89395: EMPTY
89396: LIST
89397: LIST
89398: PUSH
89399: LD_INT 1
89401: NEG
89402: PUSH
89403: LD_INT 1
89405: NEG
89406: PUSH
89407: EMPTY
89408: LIST
89409: LIST
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89420: LD_ADDR_VAR 0 62
89424: PUSH
89425: LD_INT 0
89427: PUSH
89428: LD_INT 0
89430: PUSH
89431: EMPTY
89432: LIST
89433: LIST
89434: PUSH
89435: LD_INT 0
89437: PUSH
89438: LD_INT 1
89440: NEG
89441: PUSH
89442: EMPTY
89443: LIST
89444: LIST
89445: PUSH
89446: LD_INT 1
89448: PUSH
89449: LD_INT 0
89451: PUSH
89452: EMPTY
89453: LIST
89454: LIST
89455: PUSH
89456: LD_INT 1
89458: PUSH
89459: LD_INT 1
89461: PUSH
89462: EMPTY
89463: LIST
89464: LIST
89465: PUSH
89466: LD_INT 0
89468: PUSH
89469: LD_INT 1
89471: PUSH
89472: EMPTY
89473: LIST
89474: LIST
89475: PUSH
89476: LD_INT 1
89478: NEG
89479: PUSH
89480: LD_INT 0
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: LD_INT 1
89489: NEG
89490: PUSH
89491: LD_INT 1
89493: NEG
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: EMPTY
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89508: LD_ADDR_VAR 0 63
89512: PUSH
89513: LD_INT 0
89515: PUSH
89516: LD_INT 0
89518: PUSH
89519: EMPTY
89520: LIST
89521: LIST
89522: PUSH
89523: LD_INT 0
89525: PUSH
89526: LD_INT 1
89528: NEG
89529: PUSH
89530: EMPTY
89531: LIST
89532: LIST
89533: PUSH
89534: LD_INT 1
89536: PUSH
89537: LD_INT 0
89539: PUSH
89540: EMPTY
89541: LIST
89542: LIST
89543: PUSH
89544: LD_INT 1
89546: PUSH
89547: LD_INT 1
89549: PUSH
89550: EMPTY
89551: LIST
89552: LIST
89553: PUSH
89554: LD_INT 0
89556: PUSH
89557: LD_INT 1
89559: PUSH
89560: EMPTY
89561: LIST
89562: LIST
89563: PUSH
89564: LD_INT 1
89566: NEG
89567: PUSH
89568: LD_INT 0
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: PUSH
89575: LD_INT 1
89577: NEG
89578: PUSH
89579: LD_INT 1
89581: NEG
89582: PUSH
89583: EMPTY
89584: LIST
89585: LIST
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: LIST
89595: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
89596: LD_ADDR_VAR 0 64
89600: PUSH
89601: LD_INT 0
89603: PUSH
89604: LD_INT 0
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 0
89613: PUSH
89614: LD_INT 1
89616: NEG
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: LD_INT 1
89624: PUSH
89625: LD_INT 0
89627: PUSH
89628: EMPTY
89629: LIST
89630: LIST
89631: PUSH
89632: LD_INT 1
89634: PUSH
89635: LD_INT 1
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: PUSH
89642: LD_INT 0
89644: PUSH
89645: LD_INT 1
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 1
89654: NEG
89655: PUSH
89656: LD_INT 0
89658: PUSH
89659: EMPTY
89660: LIST
89661: LIST
89662: PUSH
89663: LD_INT 1
89665: NEG
89666: PUSH
89667: LD_INT 1
89669: NEG
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: PUSH
89675: EMPTY
89676: LIST
89677: LIST
89678: LIST
89679: LIST
89680: LIST
89681: LIST
89682: LIST
89683: ST_TO_ADDR
// end ; 1 :
89684: GO 95581
89686: LD_INT 1
89688: DOUBLE
89689: EQUAL
89690: IFTRUE 89694
89692: GO 92317
89694: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89695: LD_ADDR_VAR 0 11
89699: PUSH
89700: LD_INT 1
89702: NEG
89703: PUSH
89704: LD_INT 3
89706: NEG
89707: PUSH
89708: EMPTY
89709: LIST
89710: LIST
89711: PUSH
89712: LD_INT 0
89714: PUSH
89715: LD_INT 3
89717: NEG
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: PUSH
89723: LD_INT 1
89725: PUSH
89726: LD_INT 2
89728: NEG
89729: PUSH
89730: EMPTY
89731: LIST
89732: LIST
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: LIST
89738: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89739: LD_ADDR_VAR 0 12
89743: PUSH
89744: LD_INT 2
89746: PUSH
89747: LD_INT 1
89749: NEG
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: PUSH
89755: LD_INT 3
89757: PUSH
89758: LD_INT 0
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: PUSH
89765: LD_INT 3
89767: PUSH
89768: LD_INT 1
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: LIST
89779: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
89780: LD_ADDR_VAR 0 13
89784: PUSH
89785: LD_INT 3
89787: PUSH
89788: LD_INT 2
89790: PUSH
89791: EMPTY
89792: LIST
89793: LIST
89794: PUSH
89795: LD_INT 3
89797: PUSH
89798: LD_INT 3
89800: PUSH
89801: EMPTY
89802: LIST
89803: LIST
89804: PUSH
89805: LD_INT 2
89807: PUSH
89808: LD_INT 3
89810: PUSH
89811: EMPTY
89812: LIST
89813: LIST
89814: PUSH
89815: EMPTY
89816: LIST
89817: LIST
89818: LIST
89819: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
89820: LD_ADDR_VAR 0 14
89824: PUSH
89825: LD_INT 1
89827: PUSH
89828: LD_INT 3
89830: PUSH
89831: EMPTY
89832: LIST
89833: LIST
89834: PUSH
89835: LD_INT 0
89837: PUSH
89838: LD_INT 3
89840: PUSH
89841: EMPTY
89842: LIST
89843: LIST
89844: PUSH
89845: LD_INT 1
89847: NEG
89848: PUSH
89849: LD_INT 2
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: EMPTY
89857: LIST
89858: LIST
89859: LIST
89860: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89861: LD_ADDR_VAR 0 15
89865: PUSH
89866: LD_INT 2
89868: NEG
89869: PUSH
89870: LD_INT 1
89872: PUSH
89873: EMPTY
89874: LIST
89875: LIST
89876: PUSH
89877: LD_INT 3
89879: NEG
89880: PUSH
89881: LD_INT 0
89883: PUSH
89884: EMPTY
89885: LIST
89886: LIST
89887: PUSH
89888: LD_INT 3
89890: NEG
89891: PUSH
89892: LD_INT 1
89894: NEG
89895: PUSH
89896: EMPTY
89897: LIST
89898: LIST
89899: PUSH
89900: EMPTY
89901: LIST
89902: LIST
89903: LIST
89904: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
89905: LD_ADDR_VAR 0 16
89909: PUSH
89910: LD_INT 2
89912: NEG
89913: PUSH
89914: LD_INT 3
89916: NEG
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: LD_INT 3
89924: NEG
89925: PUSH
89926: LD_INT 2
89928: NEG
89929: PUSH
89930: EMPTY
89931: LIST
89932: LIST
89933: PUSH
89934: LD_INT 3
89936: NEG
89937: PUSH
89938: LD_INT 3
89940: NEG
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: LIST
89950: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
89951: LD_ADDR_VAR 0 17
89955: PUSH
89956: LD_INT 1
89958: NEG
89959: PUSH
89960: LD_INT 3
89962: NEG
89963: PUSH
89964: EMPTY
89965: LIST
89966: LIST
89967: PUSH
89968: LD_INT 0
89970: PUSH
89971: LD_INT 3
89973: NEG
89974: PUSH
89975: EMPTY
89976: LIST
89977: LIST
89978: PUSH
89979: LD_INT 1
89981: PUSH
89982: LD_INT 2
89984: NEG
89985: PUSH
89986: EMPTY
89987: LIST
89988: LIST
89989: PUSH
89990: EMPTY
89991: LIST
89992: LIST
89993: LIST
89994: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
89995: LD_ADDR_VAR 0 18
89999: PUSH
90000: LD_INT 2
90002: PUSH
90003: LD_INT 1
90005: NEG
90006: PUSH
90007: EMPTY
90008: LIST
90009: LIST
90010: PUSH
90011: LD_INT 3
90013: PUSH
90014: LD_INT 0
90016: PUSH
90017: EMPTY
90018: LIST
90019: LIST
90020: PUSH
90021: LD_INT 3
90023: PUSH
90024: LD_INT 1
90026: PUSH
90027: EMPTY
90028: LIST
90029: LIST
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: LIST
90035: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
90036: LD_ADDR_VAR 0 19
90040: PUSH
90041: LD_INT 3
90043: PUSH
90044: LD_INT 2
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: PUSH
90051: LD_INT 3
90053: PUSH
90054: LD_INT 3
90056: PUSH
90057: EMPTY
90058: LIST
90059: LIST
90060: PUSH
90061: LD_INT 2
90063: PUSH
90064: LD_INT 3
90066: PUSH
90067: EMPTY
90068: LIST
90069: LIST
90070: PUSH
90071: EMPTY
90072: LIST
90073: LIST
90074: LIST
90075: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
90076: LD_ADDR_VAR 0 20
90080: PUSH
90081: LD_INT 1
90083: PUSH
90084: LD_INT 3
90086: PUSH
90087: EMPTY
90088: LIST
90089: LIST
90090: PUSH
90091: LD_INT 0
90093: PUSH
90094: LD_INT 3
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PUSH
90101: LD_INT 1
90103: NEG
90104: PUSH
90105: LD_INT 2
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PUSH
90112: EMPTY
90113: LIST
90114: LIST
90115: LIST
90116: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
90117: LD_ADDR_VAR 0 21
90121: PUSH
90122: LD_INT 2
90124: NEG
90125: PUSH
90126: LD_INT 1
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 3
90135: NEG
90136: PUSH
90137: LD_INT 0
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: LD_INT 3
90146: NEG
90147: PUSH
90148: LD_INT 1
90150: NEG
90151: PUSH
90152: EMPTY
90153: LIST
90154: LIST
90155: PUSH
90156: EMPTY
90157: LIST
90158: LIST
90159: LIST
90160: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
90161: LD_ADDR_VAR 0 22
90165: PUSH
90166: LD_INT 2
90168: NEG
90169: PUSH
90170: LD_INT 3
90172: NEG
90173: PUSH
90174: EMPTY
90175: LIST
90176: LIST
90177: PUSH
90178: LD_INT 3
90180: NEG
90181: PUSH
90182: LD_INT 2
90184: NEG
90185: PUSH
90186: EMPTY
90187: LIST
90188: LIST
90189: PUSH
90190: LD_INT 3
90192: NEG
90193: PUSH
90194: LD_INT 3
90196: NEG
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: EMPTY
90203: LIST
90204: LIST
90205: LIST
90206: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
90207: LD_ADDR_VAR 0 23
90211: PUSH
90212: LD_INT 0
90214: PUSH
90215: LD_INT 3
90217: NEG
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 1
90225: NEG
90226: PUSH
90227: LD_INT 4
90229: NEG
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: LD_INT 1
90237: PUSH
90238: LD_INT 3
90240: NEG
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: PUSH
90246: EMPTY
90247: LIST
90248: LIST
90249: LIST
90250: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
90251: LD_ADDR_VAR 0 24
90255: PUSH
90256: LD_INT 3
90258: PUSH
90259: LD_INT 0
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: PUSH
90266: LD_INT 3
90268: PUSH
90269: LD_INT 1
90271: NEG
90272: PUSH
90273: EMPTY
90274: LIST
90275: LIST
90276: PUSH
90277: LD_INT 4
90279: PUSH
90280: LD_INT 1
90282: PUSH
90283: EMPTY
90284: LIST
90285: LIST
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: LIST
90291: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
90292: LD_ADDR_VAR 0 25
90296: PUSH
90297: LD_INT 3
90299: PUSH
90300: LD_INT 3
90302: PUSH
90303: EMPTY
90304: LIST
90305: LIST
90306: PUSH
90307: LD_INT 4
90309: PUSH
90310: LD_INT 3
90312: PUSH
90313: EMPTY
90314: LIST
90315: LIST
90316: PUSH
90317: LD_INT 3
90319: PUSH
90320: LD_INT 4
90322: PUSH
90323: EMPTY
90324: LIST
90325: LIST
90326: PUSH
90327: EMPTY
90328: LIST
90329: LIST
90330: LIST
90331: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
90332: LD_ADDR_VAR 0 26
90336: PUSH
90337: LD_INT 0
90339: PUSH
90340: LD_INT 3
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: PUSH
90347: LD_INT 1
90349: PUSH
90350: LD_INT 4
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: LD_INT 1
90359: NEG
90360: PUSH
90361: LD_INT 3
90363: PUSH
90364: EMPTY
90365: LIST
90366: LIST
90367: PUSH
90368: EMPTY
90369: LIST
90370: LIST
90371: LIST
90372: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
90373: LD_ADDR_VAR 0 27
90377: PUSH
90378: LD_INT 3
90380: NEG
90381: PUSH
90382: LD_INT 0
90384: PUSH
90385: EMPTY
90386: LIST
90387: LIST
90388: PUSH
90389: LD_INT 3
90391: NEG
90392: PUSH
90393: LD_INT 1
90395: PUSH
90396: EMPTY
90397: LIST
90398: LIST
90399: PUSH
90400: LD_INT 4
90402: NEG
90403: PUSH
90404: LD_INT 1
90406: NEG
90407: PUSH
90408: EMPTY
90409: LIST
90410: LIST
90411: PUSH
90412: EMPTY
90413: LIST
90414: LIST
90415: LIST
90416: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
90417: LD_ADDR_VAR 0 28
90421: PUSH
90422: LD_INT 3
90424: NEG
90425: PUSH
90426: LD_INT 3
90428: NEG
90429: PUSH
90430: EMPTY
90431: LIST
90432: LIST
90433: PUSH
90434: LD_INT 3
90436: NEG
90437: PUSH
90438: LD_INT 4
90440: NEG
90441: PUSH
90442: EMPTY
90443: LIST
90444: LIST
90445: PUSH
90446: LD_INT 4
90448: NEG
90449: PUSH
90450: LD_INT 3
90452: NEG
90453: PUSH
90454: EMPTY
90455: LIST
90456: LIST
90457: PUSH
90458: EMPTY
90459: LIST
90460: LIST
90461: LIST
90462: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
90463: LD_ADDR_VAR 0 29
90467: PUSH
90468: LD_INT 1
90470: NEG
90471: PUSH
90472: LD_INT 3
90474: NEG
90475: PUSH
90476: EMPTY
90477: LIST
90478: LIST
90479: PUSH
90480: LD_INT 0
90482: PUSH
90483: LD_INT 3
90485: NEG
90486: PUSH
90487: EMPTY
90488: LIST
90489: LIST
90490: PUSH
90491: LD_INT 1
90493: PUSH
90494: LD_INT 2
90496: NEG
90497: PUSH
90498: EMPTY
90499: LIST
90500: LIST
90501: PUSH
90502: LD_INT 1
90504: NEG
90505: PUSH
90506: LD_INT 4
90508: NEG
90509: PUSH
90510: EMPTY
90511: LIST
90512: LIST
90513: PUSH
90514: LD_INT 0
90516: PUSH
90517: LD_INT 4
90519: NEG
90520: PUSH
90521: EMPTY
90522: LIST
90523: LIST
90524: PUSH
90525: LD_INT 1
90527: PUSH
90528: LD_INT 3
90530: NEG
90531: PUSH
90532: EMPTY
90533: LIST
90534: LIST
90535: PUSH
90536: LD_INT 1
90538: NEG
90539: PUSH
90540: LD_INT 5
90542: NEG
90543: PUSH
90544: EMPTY
90545: LIST
90546: LIST
90547: PUSH
90548: LD_INT 0
90550: PUSH
90551: LD_INT 5
90553: NEG
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: PUSH
90559: LD_INT 1
90561: PUSH
90562: LD_INT 4
90564: NEG
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 1
90572: NEG
90573: PUSH
90574: LD_INT 6
90576: NEG
90577: PUSH
90578: EMPTY
90579: LIST
90580: LIST
90581: PUSH
90582: LD_INT 0
90584: PUSH
90585: LD_INT 6
90587: NEG
90588: PUSH
90589: EMPTY
90590: LIST
90591: LIST
90592: PUSH
90593: LD_INT 1
90595: PUSH
90596: LD_INT 5
90598: NEG
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: EMPTY
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
90618: LD_ADDR_VAR 0 30
90622: PUSH
90623: LD_INT 2
90625: PUSH
90626: LD_INT 1
90628: NEG
90629: PUSH
90630: EMPTY
90631: LIST
90632: LIST
90633: PUSH
90634: LD_INT 3
90636: PUSH
90637: LD_INT 0
90639: PUSH
90640: EMPTY
90641: LIST
90642: LIST
90643: PUSH
90644: LD_INT 3
90646: PUSH
90647: LD_INT 1
90649: PUSH
90650: EMPTY
90651: LIST
90652: LIST
90653: PUSH
90654: LD_INT 3
90656: PUSH
90657: LD_INT 1
90659: NEG
90660: PUSH
90661: EMPTY
90662: LIST
90663: LIST
90664: PUSH
90665: LD_INT 4
90667: PUSH
90668: LD_INT 0
90670: PUSH
90671: EMPTY
90672: LIST
90673: LIST
90674: PUSH
90675: LD_INT 4
90677: PUSH
90678: LD_INT 1
90680: PUSH
90681: EMPTY
90682: LIST
90683: LIST
90684: PUSH
90685: LD_INT 4
90687: PUSH
90688: LD_INT 1
90690: NEG
90691: PUSH
90692: EMPTY
90693: LIST
90694: LIST
90695: PUSH
90696: LD_INT 5
90698: PUSH
90699: LD_INT 0
90701: PUSH
90702: EMPTY
90703: LIST
90704: LIST
90705: PUSH
90706: LD_INT 5
90708: PUSH
90709: LD_INT 1
90711: PUSH
90712: EMPTY
90713: LIST
90714: LIST
90715: PUSH
90716: LD_INT 5
90718: PUSH
90719: LD_INT 1
90721: NEG
90722: PUSH
90723: EMPTY
90724: LIST
90725: LIST
90726: PUSH
90727: LD_INT 6
90729: PUSH
90730: LD_INT 0
90732: PUSH
90733: EMPTY
90734: LIST
90735: LIST
90736: PUSH
90737: LD_INT 6
90739: PUSH
90740: LD_INT 1
90742: PUSH
90743: EMPTY
90744: LIST
90745: LIST
90746: PUSH
90747: EMPTY
90748: LIST
90749: LIST
90750: LIST
90751: LIST
90752: LIST
90753: LIST
90754: LIST
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
90761: LD_ADDR_VAR 0 31
90765: PUSH
90766: LD_INT 3
90768: PUSH
90769: LD_INT 2
90771: PUSH
90772: EMPTY
90773: LIST
90774: LIST
90775: PUSH
90776: LD_INT 3
90778: PUSH
90779: LD_INT 3
90781: PUSH
90782: EMPTY
90783: LIST
90784: LIST
90785: PUSH
90786: LD_INT 2
90788: PUSH
90789: LD_INT 3
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: PUSH
90796: LD_INT 4
90798: PUSH
90799: LD_INT 3
90801: PUSH
90802: EMPTY
90803: LIST
90804: LIST
90805: PUSH
90806: LD_INT 4
90808: PUSH
90809: LD_INT 4
90811: PUSH
90812: EMPTY
90813: LIST
90814: LIST
90815: PUSH
90816: LD_INT 3
90818: PUSH
90819: LD_INT 4
90821: PUSH
90822: EMPTY
90823: LIST
90824: LIST
90825: PUSH
90826: LD_INT 5
90828: PUSH
90829: LD_INT 4
90831: PUSH
90832: EMPTY
90833: LIST
90834: LIST
90835: PUSH
90836: LD_INT 5
90838: PUSH
90839: LD_INT 5
90841: PUSH
90842: EMPTY
90843: LIST
90844: LIST
90845: PUSH
90846: LD_INT 4
90848: PUSH
90849: LD_INT 5
90851: PUSH
90852: EMPTY
90853: LIST
90854: LIST
90855: PUSH
90856: LD_INT 6
90858: PUSH
90859: LD_INT 5
90861: PUSH
90862: EMPTY
90863: LIST
90864: LIST
90865: PUSH
90866: LD_INT 6
90868: PUSH
90869: LD_INT 6
90871: PUSH
90872: EMPTY
90873: LIST
90874: LIST
90875: PUSH
90876: LD_INT 5
90878: PUSH
90879: LD_INT 6
90881: PUSH
90882: EMPTY
90883: LIST
90884: LIST
90885: PUSH
90886: EMPTY
90887: LIST
90888: LIST
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: LIST
90897: LIST
90898: LIST
90899: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
90900: LD_ADDR_VAR 0 32
90904: PUSH
90905: LD_INT 1
90907: PUSH
90908: LD_INT 3
90910: PUSH
90911: EMPTY
90912: LIST
90913: LIST
90914: PUSH
90915: LD_INT 0
90917: PUSH
90918: LD_INT 3
90920: PUSH
90921: EMPTY
90922: LIST
90923: LIST
90924: PUSH
90925: LD_INT 1
90927: NEG
90928: PUSH
90929: LD_INT 2
90931: PUSH
90932: EMPTY
90933: LIST
90934: LIST
90935: PUSH
90936: LD_INT 1
90938: PUSH
90939: LD_INT 4
90941: PUSH
90942: EMPTY
90943: LIST
90944: LIST
90945: PUSH
90946: LD_INT 0
90948: PUSH
90949: LD_INT 4
90951: PUSH
90952: EMPTY
90953: LIST
90954: LIST
90955: PUSH
90956: LD_INT 1
90958: NEG
90959: PUSH
90960: LD_INT 3
90962: PUSH
90963: EMPTY
90964: LIST
90965: LIST
90966: PUSH
90967: LD_INT 1
90969: PUSH
90970: LD_INT 5
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PUSH
90977: LD_INT 0
90979: PUSH
90980: LD_INT 5
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: PUSH
90987: LD_INT 1
90989: NEG
90990: PUSH
90991: LD_INT 4
90993: PUSH
90994: EMPTY
90995: LIST
90996: LIST
90997: PUSH
90998: LD_INT 1
91000: PUSH
91001: LD_INT 6
91003: PUSH
91004: EMPTY
91005: LIST
91006: LIST
91007: PUSH
91008: LD_INT 0
91010: PUSH
91011: LD_INT 6
91013: PUSH
91014: EMPTY
91015: LIST
91016: LIST
91017: PUSH
91018: LD_INT 1
91020: NEG
91021: PUSH
91022: LD_INT 5
91024: PUSH
91025: EMPTY
91026: LIST
91027: LIST
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: LIST
91038: LIST
91039: LIST
91040: LIST
91041: LIST
91042: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
91043: LD_ADDR_VAR 0 33
91047: PUSH
91048: LD_INT 2
91050: NEG
91051: PUSH
91052: LD_INT 1
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: LD_INT 3
91061: NEG
91062: PUSH
91063: LD_INT 0
91065: PUSH
91066: EMPTY
91067: LIST
91068: LIST
91069: PUSH
91070: LD_INT 3
91072: NEG
91073: PUSH
91074: LD_INT 1
91076: NEG
91077: PUSH
91078: EMPTY
91079: LIST
91080: LIST
91081: PUSH
91082: LD_INT 3
91084: NEG
91085: PUSH
91086: LD_INT 1
91088: PUSH
91089: EMPTY
91090: LIST
91091: LIST
91092: PUSH
91093: LD_INT 4
91095: NEG
91096: PUSH
91097: LD_INT 0
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 4
91106: NEG
91107: PUSH
91108: LD_INT 1
91110: NEG
91111: PUSH
91112: EMPTY
91113: LIST
91114: LIST
91115: PUSH
91116: LD_INT 4
91118: NEG
91119: PUSH
91120: LD_INT 1
91122: PUSH
91123: EMPTY
91124: LIST
91125: LIST
91126: PUSH
91127: LD_INT 5
91129: NEG
91130: PUSH
91131: LD_INT 0
91133: PUSH
91134: EMPTY
91135: LIST
91136: LIST
91137: PUSH
91138: LD_INT 5
91140: NEG
91141: PUSH
91142: LD_INT 1
91144: NEG
91145: PUSH
91146: EMPTY
91147: LIST
91148: LIST
91149: PUSH
91150: LD_INT 5
91152: NEG
91153: PUSH
91154: LD_INT 1
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: PUSH
91161: LD_INT 6
91163: NEG
91164: PUSH
91165: LD_INT 0
91167: PUSH
91168: EMPTY
91169: LIST
91170: LIST
91171: PUSH
91172: LD_INT 6
91174: NEG
91175: PUSH
91176: LD_INT 1
91178: NEG
91179: PUSH
91180: EMPTY
91181: LIST
91182: LIST
91183: PUSH
91184: EMPTY
91185: LIST
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
91198: LD_ADDR_VAR 0 34
91202: PUSH
91203: LD_INT 2
91205: NEG
91206: PUSH
91207: LD_INT 3
91209: NEG
91210: PUSH
91211: EMPTY
91212: LIST
91213: LIST
91214: PUSH
91215: LD_INT 3
91217: NEG
91218: PUSH
91219: LD_INT 2
91221: NEG
91222: PUSH
91223: EMPTY
91224: LIST
91225: LIST
91226: PUSH
91227: LD_INT 3
91229: NEG
91230: PUSH
91231: LD_INT 3
91233: NEG
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: PUSH
91239: LD_INT 3
91241: NEG
91242: PUSH
91243: LD_INT 4
91245: NEG
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: LD_INT 4
91253: NEG
91254: PUSH
91255: LD_INT 3
91257: NEG
91258: PUSH
91259: EMPTY
91260: LIST
91261: LIST
91262: PUSH
91263: LD_INT 4
91265: NEG
91266: PUSH
91267: LD_INT 4
91269: NEG
91270: PUSH
91271: EMPTY
91272: LIST
91273: LIST
91274: PUSH
91275: LD_INT 4
91277: NEG
91278: PUSH
91279: LD_INT 5
91281: NEG
91282: PUSH
91283: EMPTY
91284: LIST
91285: LIST
91286: PUSH
91287: LD_INT 5
91289: NEG
91290: PUSH
91291: LD_INT 4
91293: NEG
91294: PUSH
91295: EMPTY
91296: LIST
91297: LIST
91298: PUSH
91299: LD_INT 5
91301: NEG
91302: PUSH
91303: LD_INT 5
91305: NEG
91306: PUSH
91307: EMPTY
91308: LIST
91309: LIST
91310: PUSH
91311: LD_INT 5
91313: NEG
91314: PUSH
91315: LD_INT 6
91317: NEG
91318: PUSH
91319: EMPTY
91320: LIST
91321: LIST
91322: PUSH
91323: LD_INT 6
91325: NEG
91326: PUSH
91327: LD_INT 5
91329: NEG
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: PUSH
91335: LD_INT 6
91337: NEG
91338: PUSH
91339: LD_INT 6
91341: NEG
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: LIST
91351: LIST
91352: LIST
91353: LIST
91354: LIST
91355: LIST
91356: LIST
91357: LIST
91358: LIST
91359: LIST
91360: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
91361: LD_ADDR_VAR 0 41
91365: PUSH
91366: LD_INT 0
91368: PUSH
91369: LD_INT 2
91371: NEG
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PUSH
91377: LD_INT 1
91379: NEG
91380: PUSH
91381: LD_INT 3
91383: NEG
91384: PUSH
91385: EMPTY
91386: LIST
91387: LIST
91388: PUSH
91389: LD_INT 1
91391: PUSH
91392: LD_INT 2
91394: NEG
91395: PUSH
91396: EMPTY
91397: LIST
91398: LIST
91399: PUSH
91400: EMPTY
91401: LIST
91402: LIST
91403: LIST
91404: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
91405: LD_ADDR_VAR 0 42
91409: PUSH
91410: LD_INT 2
91412: PUSH
91413: LD_INT 0
91415: PUSH
91416: EMPTY
91417: LIST
91418: LIST
91419: PUSH
91420: LD_INT 2
91422: PUSH
91423: LD_INT 1
91425: NEG
91426: PUSH
91427: EMPTY
91428: LIST
91429: LIST
91430: PUSH
91431: LD_INT 3
91433: PUSH
91434: LD_INT 1
91436: PUSH
91437: EMPTY
91438: LIST
91439: LIST
91440: PUSH
91441: EMPTY
91442: LIST
91443: LIST
91444: LIST
91445: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
91446: LD_ADDR_VAR 0 43
91450: PUSH
91451: LD_INT 2
91453: PUSH
91454: LD_INT 2
91456: PUSH
91457: EMPTY
91458: LIST
91459: LIST
91460: PUSH
91461: LD_INT 3
91463: PUSH
91464: LD_INT 2
91466: PUSH
91467: EMPTY
91468: LIST
91469: LIST
91470: PUSH
91471: LD_INT 2
91473: PUSH
91474: LD_INT 3
91476: PUSH
91477: EMPTY
91478: LIST
91479: LIST
91480: PUSH
91481: EMPTY
91482: LIST
91483: LIST
91484: LIST
91485: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
91486: LD_ADDR_VAR 0 44
91490: PUSH
91491: LD_INT 0
91493: PUSH
91494: LD_INT 2
91496: PUSH
91497: EMPTY
91498: LIST
91499: LIST
91500: PUSH
91501: LD_INT 1
91503: PUSH
91504: LD_INT 3
91506: PUSH
91507: EMPTY
91508: LIST
91509: LIST
91510: PUSH
91511: LD_INT 1
91513: NEG
91514: PUSH
91515: LD_INT 2
91517: PUSH
91518: EMPTY
91519: LIST
91520: LIST
91521: PUSH
91522: EMPTY
91523: LIST
91524: LIST
91525: LIST
91526: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
91527: LD_ADDR_VAR 0 45
91531: PUSH
91532: LD_INT 2
91534: NEG
91535: PUSH
91536: LD_INT 0
91538: PUSH
91539: EMPTY
91540: LIST
91541: LIST
91542: PUSH
91543: LD_INT 2
91545: NEG
91546: PUSH
91547: LD_INT 1
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: PUSH
91554: LD_INT 3
91556: NEG
91557: PUSH
91558: LD_INT 1
91560: NEG
91561: PUSH
91562: EMPTY
91563: LIST
91564: LIST
91565: PUSH
91566: EMPTY
91567: LIST
91568: LIST
91569: LIST
91570: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
91571: LD_ADDR_VAR 0 46
91575: PUSH
91576: LD_INT 2
91578: NEG
91579: PUSH
91580: LD_INT 2
91582: NEG
91583: PUSH
91584: EMPTY
91585: LIST
91586: LIST
91587: PUSH
91588: LD_INT 2
91590: NEG
91591: PUSH
91592: LD_INT 3
91594: NEG
91595: PUSH
91596: EMPTY
91597: LIST
91598: LIST
91599: PUSH
91600: LD_INT 3
91602: NEG
91603: PUSH
91604: LD_INT 2
91606: NEG
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PUSH
91612: EMPTY
91613: LIST
91614: LIST
91615: LIST
91616: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
91617: LD_ADDR_VAR 0 47
91621: PUSH
91622: LD_INT 2
91624: NEG
91625: PUSH
91626: LD_INT 3
91628: NEG
91629: PUSH
91630: EMPTY
91631: LIST
91632: LIST
91633: PUSH
91634: LD_INT 1
91636: NEG
91637: PUSH
91638: LD_INT 3
91640: NEG
91641: PUSH
91642: EMPTY
91643: LIST
91644: LIST
91645: PUSH
91646: EMPTY
91647: LIST
91648: LIST
91649: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
91650: LD_ADDR_VAR 0 48
91654: PUSH
91655: LD_INT 1
91657: PUSH
91658: LD_INT 2
91660: NEG
91661: PUSH
91662: EMPTY
91663: LIST
91664: LIST
91665: PUSH
91666: LD_INT 2
91668: PUSH
91669: LD_INT 1
91671: NEG
91672: PUSH
91673: EMPTY
91674: LIST
91675: LIST
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
91681: LD_ADDR_VAR 0 49
91685: PUSH
91686: LD_INT 3
91688: PUSH
91689: LD_INT 1
91691: PUSH
91692: EMPTY
91693: LIST
91694: LIST
91695: PUSH
91696: LD_INT 3
91698: PUSH
91699: LD_INT 2
91701: PUSH
91702: EMPTY
91703: LIST
91704: LIST
91705: PUSH
91706: EMPTY
91707: LIST
91708: LIST
91709: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
91710: LD_ADDR_VAR 0 50
91714: PUSH
91715: LD_INT 2
91717: PUSH
91718: LD_INT 3
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: PUSH
91725: LD_INT 1
91727: PUSH
91728: LD_INT 3
91730: PUSH
91731: EMPTY
91732: LIST
91733: LIST
91734: PUSH
91735: EMPTY
91736: LIST
91737: LIST
91738: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
91739: LD_ADDR_VAR 0 51
91743: PUSH
91744: LD_INT 1
91746: NEG
91747: PUSH
91748: LD_INT 2
91750: PUSH
91751: EMPTY
91752: LIST
91753: LIST
91754: PUSH
91755: LD_INT 2
91757: NEG
91758: PUSH
91759: LD_INT 1
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: PUSH
91766: EMPTY
91767: LIST
91768: LIST
91769: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
91770: LD_ADDR_VAR 0 52
91774: PUSH
91775: LD_INT 3
91777: NEG
91778: PUSH
91779: LD_INT 1
91781: NEG
91782: PUSH
91783: EMPTY
91784: LIST
91785: LIST
91786: PUSH
91787: LD_INT 3
91789: NEG
91790: PUSH
91791: LD_INT 2
91793: NEG
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: EMPTY
91800: LIST
91801: LIST
91802: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91803: LD_ADDR_VAR 0 53
91807: PUSH
91808: LD_INT 1
91810: NEG
91811: PUSH
91812: LD_INT 3
91814: NEG
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PUSH
91820: LD_INT 0
91822: PUSH
91823: LD_INT 3
91825: NEG
91826: PUSH
91827: EMPTY
91828: LIST
91829: LIST
91830: PUSH
91831: LD_INT 1
91833: PUSH
91834: LD_INT 2
91836: NEG
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: EMPTY
91843: LIST
91844: LIST
91845: LIST
91846: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91847: LD_ADDR_VAR 0 54
91851: PUSH
91852: LD_INT 2
91854: PUSH
91855: LD_INT 1
91857: NEG
91858: PUSH
91859: EMPTY
91860: LIST
91861: LIST
91862: PUSH
91863: LD_INT 3
91865: PUSH
91866: LD_INT 0
91868: PUSH
91869: EMPTY
91870: LIST
91871: LIST
91872: PUSH
91873: LD_INT 3
91875: PUSH
91876: LD_INT 1
91878: PUSH
91879: EMPTY
91880: LIST
91881: LIST
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: LIST
91887: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91888: LD_ADDR_VAR 0 55
91892: PUSH
91893: LD_INT 3
91895: PUSH
91896: LD_INT 2
91898: PUSH
91899: EMPTY
91900: LIST
91901: LIST
91902: PUSH
91903: LD_INT 3
91905: PUSH
91906: LD_INT 3
91908: PUSH
91909: EMPTY
91910: LIST
91911: LIST
91912: PUSH
91913: LD_INT 2
91915: PUSH
91916: LD_INT 3
91918: PUSH
91919: EMPTY
91920: LIST
91921: LIST
91922: PUSH
91923: EMPTY
91924: LIST
91925: LIST
91926: LIST
91927: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91928: LD_ADDR_VAR 0 56
91932: PUSH
91933: LD_INT 1
91935: PUSH
91936: LD_INT 3
91938: PUSH
91939: EMPTY
91940: LIST
91941: LIST
91942: PUSH
91943: LD_INT 0
91945: PUSH
91946: LD_INT 3
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: LD_INT 1
91955: NEG
91956: PUSH
91957: LD_INT 2
91959: PUSH
91960: EMPTY
91961: LIST
91962: LIST
91963: PUSH
91964: EMPTY
91965: LIST
91966: LIST
91967: LIST
91968: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91969: LD_ADDR_VAR 0 57
91973: PUSH
91974: LD_INT 2
91976: NEG
91977: PUSH
91978: LD_INT 1
91980: PUSH
91981: EMPTY
91982: LIST
91983: LIST
91984: PUSH
91985: LD_INT 3
91987: NEG
91988: PUSH
91989: LD_INT 0
91991: PUSH
91992: EMPTY
91993: LIST
91994: LIST
91995: PUSH
91996: LD_INT 3
91998: NEG
91999: PUSH
92000: LD_INT 1
92002: NEG
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: PUSH
92008: EMPTY
92009: LIST
92010: LIST
92011: LIST
92012: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92013: LD_ADDR_VAR 0 58
92017: PUSH
92018: LD_INT 2
92020: NEG
92021: PUSH
92022: LD_INT 3
92024: NEG
92025: PUSH
92026: EMPTY
92027: LIST
92028: LIST
92029: PUSH
92030: LD_INT 3
92032: NEG
92033: PUSH
92034: LD_INT 2
92036: NEG
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: PUSH
92042: LD_INT 3
92044: NEG
92045: PUSH
92046: LD_INT 3
92048: NEG
92049: PUSH
92050: EMPTY
92051: LIST
92052: LIST
92053: PUSH
92054: EMPTY
92055: LIST
92056: LIST
92057: LIST
92058: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
92059: LD_ADDR_VAR 0 59
92063: PUSH
92064: LD_INT 1
92066: NEG
92067: PUSH
92068: LD_INT 2
92070: NEG
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: LD_INT 0
92078: PUSH
92079: LD_INT 2
92081: NEG
92082: PUSH
92083: EMPTY
92084: LIST
92085: LIST
92086: PUSH
92087: LD_INT 1
92089: PUSH
92090: LD_INT 1
92092: NEG
92093: PUSH
92094: EMPTY
92095: LIST
92096: LIST
92097: PUSH
92098: EMPTY
92099: LIST
92100: LIST
92101: LIST
92102: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
92103: LD_ADDR_VAR 0 60
92107: PUSH
92108: LD_INT 1
92110: PUSH
92111: LD_INT 1
92113: NEG
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: PUSH
92119: LD_INT 2
92121: PUSH
92122: LD_INT 0
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: PUSH
92129: LD_INT 2
92131: PUSH
92132: LD_INT 1
92134: PUSH
92135: EMPTY
92136: LIST
92137: LIST
92138: PUSH
92139: EMPTY
92140: LIST
92141: LIST
92142: LIST
92143: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
92144: LD_ADDR_VAR 0 61
92148: PUSH
92149: LD_INT 2
92151: PUSH
92152: LD_INT 1
92154: PUSH
92155: EMPTY
92156: LIST
92157: LIST
92158: PUSH
92159: LD_INT 2
92161: PUSH
92162: LD_INT 2
92164: PUSH
92165: EMPTY
92166: LIST
92167: LIST
92168: PUSH
92169: LD_INT 1
92171: PUSH
92172: LD_INT 2
92174: PUSH
92175: EMPTY
92176: LIST
92177: LIST
92178: PUSH
92179: EMPTY
92180: LIST
92181: LIST
92182: LIST
92183: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
92184: LD_ADDR_VAR 0 62
92188: PUSH
92189: LD_INT 1
92191: PUSH
92192: LD_INT 2
92194: PUSH
92195: EMPTY
92196: LIST
92197: LIST
92198: PUSH
92199: LD_INT 0
92201: PUSH
92202: LD_INT 2
92204: PUSH
92205: EMPTY
92206: LIST
92207: LIST
92208: PUSH
92209: LD_INT 1
92211: NEG
92212: PUSH
92213: LD_INT 1
92215: PUSH
92216: EMPTY
92217: LIST
92218: LIST
92219: PUSH
92220: EMPTY
92221: LIST
92222: LIST
92223: LIST
92224: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
92225: LD_ADDR_VAR 0 63
92229: PUSH
92230: LD_INT 1
92232: NEG
92233: PUSH
92234: LD_INT 1
92236: PUSH
92237: EMPTY
92238: LIST
92239: LIST
92240: PUSH
92241: LD_INT 2
92243: NEG
92244: PUSH
92245: LD_INT 0
92247: PUSH
92248: EMPTY
92249: LIST
92250: LIST
92251: PUSH
92252: LD_INT 2
92254: NEG
92255: PUSH
92256: LD_INT 1
92258: NEG
92259: PUSH
92260: EMPTY
92261: LIST
92262: LIST
92263: PUSH
92264: EMPTY
92265: LIST
92266: LIST
92267: LIST
92268: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
92269: LD_ADDR_VAR 0 64
92273: PUSH
92274: LD_INT 1
92276: NEG
92277: PUSH
92278: LD_INT 2
92280: NEG
92281: PUSH
92282: EMPTY
92283: LIST
92284: LIST
92285: PUSH
92286: LD_INT 2
92288: NEG
92289: PUSH
92290: LD_INT 1
92292: NEG
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: PUSH
92298: LD_INT 2
92300: NEG
92301: PUSH
92302: LD_INT 2
92304: NEG
92305: PUSH
92306: EMPTY
92307: LIST
92308: LIST
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: LIST
92314: ST_TO_ADDR
// end ; 2 :
92315: GO 95581
92317: LD_INT 2
92319: DOUBLE
92320: EQUAL
92321: IFTRUE 92325
92323: GO 95580
92325: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
92326: LD_ADDR_VAR 0 29
92330: PUSH
92331: LD_INT 4
92333: PUSH
92334: LD_INT 0
92336: PUSH
92337: EMPTY
92338: LIST
92339: LIST
92340: PUSH
92341: LD_INT 4
92343: PUSH
92344: LD_INT 1
92346: NEG
92347: PUSH
92348: EMPTY
92349: LIST
92350: LIST
92351: PUSH
92352: LD_INT 5
92354: PUSH
92355: LD_INT 0
92357: PUSH
92358: EMPTY
92359: LIST
92360: LIST
92361: PUSH
92362: LD_INT 5
92364: PUSH
92365: LD_INT 1
92367: PUSH
92368: EMPTY
92369: LIST
92370: LIST
92371: PUSH
92372: LD_INT 4
92374: PUSH
92375: LD_INT 1
92377: PUSH
92378: EMPTY
92379: LIST
92380: LIST
92381: PUSH
92382: LD_INT 3
92384: PUSH
92385: LD_INT 0
92387: PUSH
92388: EMPTY
92389: LIST
92390: LIST
92391: PUSH
92392: LD_INT 3
92394: PUSH
92395: LD_INT 1
92397: NEG
92398: PUSH
92399: EMPTY
92400: LIST
92401: LIST
92402: PUSH
92403: LD_INT 3
92405: PUSH
92406: LD_INT 2
92408: NEG
92409: PUSH
92410: EMPTY
92411: LIST
92412: LIST
92413: PUSH
92414: LD_INT 5
92416: PUSH
92417: LD_INT 2
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: PUSH
92424: LD_INT 3
92426: PUSH
92427: LD_INT 3
92429: PUSH
92430: EMPTY
92431: LIST
92432: LIST
92433: PUSH
92434: LD_INT 3
92436: PUSH
92437: LD_INT 2
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 4
92446: PUSH
92447: LD_INT 3
92449: PUSH
92450: EMPTY
92451: LIST
92452: LIST
92453: PUSH
92454: LD_INT 4
92456: PUSH
92457: LD_INT 4
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: PUSH
92464: LD_INT 3
92466: PUSH
92467: LD_INT 4
92469: PUSH
92470: EMPTY
92471: LIST
92472: LIST
92473: PUSH
92474: LD_INT 2
92476: PUSH
92477: LD_INT 3
92479: PUSH
92480: EMPTY
92481: LIST
92482: LIST
92483: PUSH
92484: LD_INT 2
92486: PUSH
92487: LD_INT 2
92489: PUSH
92490: EMPTY
92491: LIST
92492: LIST
92493: PUSH
92494: LD_INT 4
92496: PUSH
92497: LD_INT 2
92499: PUSH
92500: EMPTY
92501: LIST
92502: LIST
92503: PUSH
92504: LD_INT 2
92506: PUSH
92507: LD_INT 4
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: PUSH
92514: LD_INT 0
92516: PUSH
92517: LD_INT 4
92519: PUSH
92520: EMPTY
92521: LIST
92522: LIST
92523: PUSH
92524: LD_INT 0
92526: PUSH
92527: LD_INT 3
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: PUSH
92534: LD_INT 1
92536: PUSH
92537: LD_INT 4
92539: PUSH
92540: EMPTY
92541: LIST
92542: LIST
92543: PUSH
92544: LD_INT 1
92546: PUSH
92547: LD_INT 5
92549: PUSH
92550: EMPTY
92551: LIST
92552: LIST
92553: PUSH
92554: LD_INT 0
92556: PUSH
92557: LD_INT 5
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 1
92566: NEG
92567: PUSH
92568: LD_INT 4
92570: PUSH
92571: EMPTY
92572: LIST
92573: LIST
92574: PUSH
92575: LD_INT 1
92577: NEG
92578: PUSH
92579: LD_INT 3
92581: PUSH
92582: EMPTY
92583: LIST
92584: LIST
92585: PUSH
92586: LD_INT 2
92588: PUSH
92589: LD_INT 5
92591: PUSH
92592: EMPTY
92593: LIST
92594: LIST
92595: PUSH
92596: LD_INT 2
92598: NEG
92599: PUSH
92600: LD_INT 3
92602: PUSH
92603: EMPTY
92604: LIST
92605: LIST
92606: PUSH
92607: LD_INT 3
92609: NEG
92610: PUSH
92611: LD_INT 0
92613: PUSH
92614: EMPTY
92615: LIST
92616: LIST
92617: PUSH
92618: LD_INT 3
92620: NEG
92621: PUSH
92622: LD_INT 1
92624: NEG
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: LD_INT 2
92632: NEG
92633: PUSH
92634: LD_INT 0
92636: PUSH
92637: EMPTY
92638: LIST
92639: LIST
92640: PUSH
92641: LD_INT 2
92643: NEG
92644: PUSH
92645: LD_INT 1
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: PUSH
92652: LD_INT 3
92654: NEG
92655: PUSH
92656: LD_INT 1
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: PUSH
92663: LD_INT 4
92665: NEG
92666: PUSH
92667: LD_INT 0
92669: PUSH
92670: EMPTY
92671: LIST
92672: LIST
92673: PUSH
92674: LD_INT 4
92676: NEG
92677: PUSH
92678: LD_INT 1
92680: NEG
92681: PUSH
92682: EMPTY
92683: LIST
92684: LIST
92685: PUSH
92686: LD_INT 4
92688: NEG
92689: PUSH
92690: LD_INT 2
92692: NEG
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 2
92700: NEG
92701: PUSH
92702: LD_INT 2
92704: PUSH
92705: EMPTY
92706: LIST
92707: LIST
92708: PUSH
92709: LD_INT 4
92711: NEG
92712: PUSH
92713: LD_INT 4
92715: NEG
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 4
92723: NEG
92724: PUSH
92725: LD_INT 5
92727: NEG
92728: PUSH
92729: EMPTY
92730: LIST
92731: LIST
92732: PUSH
92733: LD_INT 3
92735: NEG
92736: PUSH
92737: LD_INT 4
92739: NEG
92740: PUSH
92741: EMPTY
92742: LIST
92743: LIST
92744: PUSH
92745: LD_INT 3
92747: NEG
92748: PUSH
92749: LD_INT 3
92751: NEG
92752: PUSH
92753: EMPTY
92754: LIST
92755: LIST
92756: PUSH
92757: LD_INT 4
92759: NEG
92760: PUSH
92761: LD_INT 3
92763: NEG
92764: PUSH
92765: EMPTY
92766: LIST
92767: LIST
92768: PUSH
92769: LD_INT 5
92771: NEG
92772: PUSH
92773: LD_INT 4
92775: NEG
92776: PUSH
92777: EMPTY
92778: LIST
92779: LIST
92780: PUSH
92781: LD_INT 5
92783: NEG
92784: PUSH
92785: LD_INT 5
92787: NEG
92788: PUSH
92789: EMPTY
92790: LIST
92791: LIST
92792: PUSH
92793: LD_INT 3
92795: NEG
92796: PUSH
92797: LD_INT 5
92799: NEG
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 5
92807: NEG
92808: PUSH
92809: LD_INT 3
92811: NEG
92812: PUSH
92813: EMPTY
92814: LIST
92815: LIST
92816: PUSH
92817: EMPTY
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: LIST
92832: LIST
92833: LIST
92834: LIST
92835: LIST
92836: LIST
92837: LIST
92838: LIST
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: LIST
92852: LIST
92853: LIST
92854: LIST
92855: LIST
92856: LIST
92857: LIST
92858: LIST
92859: LIST
92860: LIST
92861: LIST
92862: LIST
92863: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
92864: LD_ADDR_VAR 0 30
92868: PUSH
92869: LD_INT 4
92871: PUSH
92872: LD_INT 4
92874: PUSH
92875: EMPTY
92876: LIST
92877: LIST
92878: PUSH
92879: LD_INT 4
92881: PUSH
92882: LD_INT 3
92884: PUSH
92885: EMPTY
92886: LIST
92887: LIST
92888: PUSH
92889: LD_INT 5
92891: PUSH
92892: LD_INT 4
92894: PUSH
92895: EMPTY
92896: LIST
92897: LIST
92898: PUSH
92899: LD_INT 5
92901: PUSH
92902: LD_INT 5
92904: PUSH
92905: EMPTY
92906: LIST
92907: LIST
92908: PUSH
92909: LD_INT 4
92911: PUSH
92912: LD_INT 5
92914: PUSH
92915: EMPTY
92916: LIST
92917: LIST
92918: PUSH
92919: LD_INT 3
92921: PUSH
92922: LD_INT 4
92924: PUSH
92925: EMPTY
92926: LIST
92927: LIST
92928: PUSH
92929: LD_INT 3
92931: PUSH
92932: LD_INT 3
92934: PUSH
92935: EMPTY
92936: LIST
92937: LIST
92938: PUSH
92939: LD_INT 5
92941: PUSH
92942: LD_INT 3
92944: PUSH
92945: EMPTY
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 3
92951: PUSH
92952: LD_INT 5
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: LD_INT 0
92961: PUSH
92962: LD_INT 3
92964: PUSH
92965: EMPTY
92966: LIST
92967: LIST
92968: PUSH
92969: LD_INT 0
92971: PUSH
92972: LD_INT 2
92974: PUSH
92975: EMPTY
92976: LIST
92977: LIST
92978: PUSH
92979: LD_INT 1
92981: PUSH
92982: LD_INT 3
92984: PUSH
92985: EMPTY
92986: LIST
92987: LIST
92988: PUSH
92989: LD_INT 1
92991: PUSH
92992: LD_INT 4
92994: PUSH
92995: EMPTY
92996: LIST
92997: LIST
92998: PUSH
92999: LD_INT 0
93001: PUSH
93002: LD_INT 4
93004: PUSH
93005: EMPTY
93006: LIST
93007: LIST
93008: PUSH
93009: LD_INT 1
93011: NEG
93012: PUSH
93013: LD_INT 3
93015: PUSH
93016: EMPTY
93017: LIST
93018: LIST
93019: PUSH
93020: LD_INT 1
93022: NEG
93023: PUSH
93024: LD_INT 2
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 2
93033: PUSH
93034: LD_INT 4
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: PUSH
93041: LD_INT 2
93043: NEG
93044: PUSH
93045: LD_INT 2
93047: PUSH
93048: EMPTY
93049: LIST
93050: LIST
93051: PUSH
93052: LD_INT 4
93054: NEG
93055: PUSH
93056: LD_INT 0
93058: PUSH
93059: EMPTY
93060: LIST
93061: LIST
93062: PUSH
93063: LD_INT 4
93065: NEG
93066: PUSH
93067: LD_INT 1
93069: NEG
93070: PUSH
93071: EMPTY
93072: LIST
93073: LIST
93074: PUSH
93075: LD_INT 3
93077: NEG
93078: PUSH
93079: LD_INT 0
93081: PUSH
93082: EMPTY
93083: LIST
93084: LIST
93085: PUSH
93086: LD_INT 3
93088: NEG
93089: PUSH
93090: LD_INT 1
93092: PUSH
93093: EMPTY
93094: LIST
93095: LIST
93096: PUSH
93097: LD_INT 4
93099: NEG
93100: PUSH
93101: LD_INT 1
93103: PUSH
93104: EMPTY
93105: LIST
93106: LIST
93107: PUSH
93108: LD_INT 5
93110: NEG
93111: PUSH
93112: LD_INT 0
93114: PUSH
93115: EMPTY
93116: LIST
93117: LIST
93118: PUSH
93119: LD_INT 5
93121: NEG
93122: PUSH
93123: LD_INT 1
93125: NEG
93126: PUSH
93127: EMPTY
93128: LIST
93129: LIST
93130: PUSH
93131: LD_INT 5
93133: NEG
93134: PUSH
93135: LD_INT 2
93137: NEG
93138: PUSH
93139: EMPTY
93140: LIST
93141: LIST
93142: PUSH
93143: LD_INT 3
93145: NEG
93146: PUSH
93147: LD_INT 2
93149: PUSH
93150: EMPTY
93151: LIST
93152: LIST
93153: PUSH
93154: LD_INT 3
93156: NEG
93157: PUSH
93158: LD_INT 3
93160: NEG
93161: PUSH
93162: EMPTY
93163: LIST
93164: LIST
93165: PUSH
93166: LD_INT 3
93168: NEG
93169: PUSH
93170: LD_INT 4
93172: NEG
93173: PUSH
93174: EMPTY
93175: LIST
93176: LIST
93177: PUSH
93178: LD_INT 2
93180: NEG
93181: PUSH
93182: LD_INT 3
93184: NEG
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: PUSH
93190: LD_INT 2
93192: NEG
93193: PUSH
93194: LD_INT 2
93196: NEG
93197: PUSH
93198: EMPTY
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 3
93204: NEG
93205: PUSH
93206: LD_INT 2
93208: NEG
93209: PUSH
93210: EMPTY
93211: LIST
93212: LIST
93213: PUSH
93214: LD_INT 4
93216: NEG
93217: PUSH
93218: LD_INT 3
93220: NEG
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: LD_INT 4
93228: NEG
93229: PUSH
93230: LD_INT 4
93232: NEG
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 2
93240: NEG
93241: PUSH
93242: LD_INT 4
93244: NEG
93245: PUSH
93246: EMPTY
93247: LIST
93248: LIST
93249: PUSH
93250: LD_INT 4
93252: NEG
93253: PUSH
93254: LD_INT 2
93256: NEG
93257: PUSH
93258: EMPTY
93259: LIST
93260: LIST
93261: PUSH
93262: LD_INT 0
93264: PUSH
93265: LD_INT 4
93267: NEG
93268: PUSH
93269: EMPTY
93270: LIST
93271: LIST
93272: PUSH
93273: LD_INT 0
93275: PUSH
93276: LD_INT 5
93278: NEG
93279: PUSH
93280: EMPTY
93281: LIST
93282: LIST
93283: PUSH
93284: LD_INT 1
93286: PUSH
93287: LD_INT 4
93289: NEG
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: LD_INT 1
93297: PUSH
93298: LD_INT 3
93300: NEG
93301: PUSH
93302: EMPTY
93303: LIST
93304: LIST
93305: PUSH
93306: LD_INT 0
93308: PUSH
93309: LD_INT 3
93311: NEG
93312: PUSH
93313: EMPTY
93314: LIST
93315: LIST
93316: PUSH
93317: LD_INT 1
93319: NEG
93320: PUSH
93321: LD_INT 4
93323: NEG
93324: PUSH
93325: EMPTY
93326: LIST
93327: LIST
93328: PUSH
93329: LD_INT 1
93331: NEG
93332: PUSH
93333: LD_INT 5
93335: NEG
93336: PUSH
93337: EMPTY
93338: LIST
93339: LIST
93340: PUSH
93341: LD_INT 2
93343: PUSH
93344: LD_INT 3
93346: NEG
93347: PUSH
93348: EMPTY
93349: LIST
93350: LIST
93351: PUSH
93352: LD_INT 2
93354: NEG
93355: PUSH
93356: LD_INT 5
93358: NEG
93359: PUSH
93360: EMPTY
93361: LIST
93362: LIST
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: LIST
93384: LIST
93385: LIST
93386: LIST
93387: LIST
93388: LIST
93389: LIST
93390: LIST
93391: LIST
93392: LIST
93393: LIST
93394: LIST
93395: LIST
93396: LIST
93397: LIST
93398: LIST
93399: LIST
93400: LIST
93401: LIST
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: LIST
93410: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
93411: LD_ADDR_VAR 0 31
93415: PUSH
93416: LD_INT 0
93418: PUSH
93419: LD_INT 4
93421: PUSH
93422: EMPTY
93423: LIST
93424: LIST
93425: PUSH
93426: LD_INT 0
93428: PUSH
93429: LD_INT 3
93431: PUSH
93432: EMPTY
93433: LIST
93434: LIST
93435: PUSH
93436: LD_INT 1
93438: PUSH
93439: LD_INT 4
93441: PUSH
93442: EMPTY
93443: LIST
93444: LIST
93445: PUSH
93446: LD_INT 1
93448: PUSH
93449: LD_INT 5
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: PUSH
93456: LD_INT 0
93458: PUSH
93459: LD_INT 5
93461: PUSH
93462: EMPTY
93463: LIST
93464: LIST
93465: PUSH
93466: LD_INT 1
93468: NEG
93469: PUSH
93470: LD_INT 4
93472: PUSH
93473: EMPTY
93474: LIST
93475: LIST
93476: PUSH
93477: LD_INT 1
93479: NEG
93480: PUSH
93481: LD_INT 3
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: LD_INT 2
93490: PUSH
93491: LD_INT 5
93493: PUSH
93494: EMPTY
93495: LIST
93496: LIST
93497: PUSH
93498: LD_INT 2
93500: NEG
93501: PUSH
93502: LD_INT 3
93504: PUSH
93505: EMPTY
93506: LIST
93507: LIST
93508: PUSH
93509: LD_INT 3
93511: NEG
93512: PUSH
93513: LD_INT 0
93515: PUSH
93516: EMPTY
93517: LIST
93518: LIST
93519: PUSH
93520: LD_INT 3
93522: NEG
93523: PUSH
93524: LD_INT 1
93526: NEG
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: PUSH
93532: LD_INT 2
93534: NEG
93535: PUSH
93536: LD_INT 0
93538: PUSH
93539: EMPTY
93540: LIST
93541: LIST
93542: PUSH
93543: LD_INT 2
93545: NEG
93546: PUSH
93547: LD_INT 1
93549: PUSH
93550: EMPTY
93551: LIST
93552: LIST
93553: PUSH
93554: LD_INT 3
93556: NEG
93557: PUSH
93558: LD_INT 1
93560: PUSH
93561: EMPTY
93562: LIST
93563: LIST
93564: PUSH
93565: LD_INT 4
93567: NEG
93568: PUSH
93569: LD_INT 0
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: LD_INT 4
93578: NEG
93579: PUSH
93580: LD_INT 1
93582: NEG
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: PUSH
93588: LD_INT 4
93590: NEG
93591: PUSH
93592: LD_INT 2
93594: NEG
93595: PUSH
93596: EMPTY
93597: LIST
93598: LIST
93599: PUSH
93600: LD_INT 2
93602: NEG
93603: PUSH
93604: LD_INT 2
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: PUSH
93611: LD_INT 4
93613: NEG
93614: PUSH
93615: LD_INT 4
93617: NEG
93618: PUSH
93619: EMPTY
93620: LIST
93621: LIST
93622: PUSH
93623: LD_INT 4
93625: NEG
93626: PUSH
93627: LD_INT 5
93629: NEG
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: PUSH
93635: LD_INT 3
93637: NEG
93638: PUSH
93639: LD_INT 4
93641: NEG
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 3
93649: NEG
93650: PUSH
93651: LD_INT 3
93653: NEG
93654: PUSH
93655: EMPTY
93656: LIST
93657: LIST
93658: PUSH
93659: LD_INT 4
93661: NEG
93662: PUSH
93663: LD_INT 3
93665: NEG
93666: PUSH
93667: EMPTY
93668: LIST
93669: LIST
93670: PUSH
93671: LD_INT 5
93673: NEG
93674: PUSH
93675: LD_INT 4
93677: NEG
93678: PUSH
93679: EMPTY
93680: LIST
93681: LIST
93682: PUSH
93683: LD_INT 5
93685: NEG
93686: PUSH
93687: LD_INT 5
93689: NEG
93690: PUSH
93691: EMPTY
93692: LIST
93693: LIST
93694: PUSH
93695: LD_INT 3
93697: NEG
93698: PUSH
93699: LD_INT 5
93701: NEG
93702: PUSH
93703: EMPTY
93704: LIST
93705: LIST
93706: PUSH
93707: LD_INT 5
93709: NEG
93710: PUSH
93711: LD_INT 3
93713: NEG
93714: PUSH
93715: EMPTY
93716: LIST
93717: LIST
93718: PUSH
93719: LD_INT 0
93721: PUSH
93722: LD_INT 3
93724: NEG
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: PUSH
93730: LD_INT 0
93732: PUSH
93733: LD_INT 4
93735: NEG
93736: PUSH
93737: EMPTY
93738: LIST
93739: LIST
93740: PUSH
93741: LD_INT 1
93743: PUSH
93744: LD_INT 3
93746: NEG
93747: PUSH
93748: EMPTY
93749: LIST
93750: LIST
93751: PUSH
93752: LD_INT 1
93754: PUSH
93755: LD_INT 2
93757: NEG
93758: PUSH
93759: EMPTY
93760: LIST
93761: LIST
93762: PUSH
93763: LD_INT 0
93765: PUSH
93766: LD_INT 2
93768: NEG
93769: PUSH
93770: EMPTY
93771: LIST
93772: LIST
93773: PUSH
93774: LD_INT 1
93776: NEG
93777: PUSH
93778: LD_INT 3
93780: NEG
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: PUSH
93786: LD_INT 1
93788: NEG
93789: PUSH
93790: LD_INT 4
93792: NEG
93793: PUSH
93794: EMPTY
93795: LIST
93796: LIST
93797: PUSH
93798: LD_INT 2
93800: PUSH
93801: LD_INT 2
93803: NEG
93804: PUSH
93805: EMPTY
93806: LIST
93807: LIST
93808: PUSH
93809: LD_INT 2
93811: NEG
93812: PUSH
93813: LD_INT 4
93815: NEG
93816: PUSH
93817: EMPTY
93818: LIST
93819: LIST
93820: PUSH
93821: LD_INT 4
93823: PUSH
93824: LD_INT 0
93826: PUSH
93827: EMPTY
93828: LIST
93829: LIST
93830: PUSH
93831: LD_INT 4
93833: PUSH
93834: LD_INT 1
93836: NEG
93837: PUSH
93838: EMPTY
93839: LIST
93840: LIST
93841: PUSH
93842: LD_INT 5
93844: PUSH
93845: LD_INT 0
93847: PUSH
93848: EMPTY
93849: LIST
93850: LIST
93851: PUSH
93852: LD_INT 5
93854: PUSH
93855: LD_INT 1
93857: PUSH
93858: EMPTY
93859: LIST
93860: LIST
93861: PUSH
93862: LD_INT 4
93864: PUSH
93865: LD_INT 1
93867: PUSH
93868: EMPTY
93869: LIST
93870: LIST
93871: PUSH
93872: LD_INT 3
93874: PUSH
93875: LD_INT 0
93877: PUSH
93878: EMPTY
93879: LIST
93880: LIST
93881: PUSH
93882: LD_INT 3
93884: PUSH
93885: LD_INT 1
93887: NEG
93888: PUSH
93889: EMPTY
93890: LIST
93891: LIST
93892: PUSH
93893: LD_INT 3
93895: PUSH
93896: LD_INT 2
93898: NEG
93899: PUSH
93900: EMPTY
93901: LIST
93902: LIST
93903: PUSH
93904: LD_INT 5
93906: PUSH
93907: LD_INT 2
93909: PUSH
93910: EMPTY
93911: LIST
93912: LIST
93913: PUSH
93914: EMPTY
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: LIST
93945: LIST
93946: LIST
93947: LIST
93948: LIST
93949: LIST
93950: LIST
93951: LIST
93952: LIST
93953: LIST
93954: LIST
93955: LIST
93956: LIST
93957: LIST
93958: LIST
93959: LIST
93960: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
93961: LD_ADDR_VAR 0 32
93965: PUSH
93966: LD_INT 4
93968: NEG
93969: PUSH
93970: LD_INT 0
93972: PUSH
93973: EMPTY
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 4
93979: NEG
93980: PUSH
93981: LD_INT 1
93983: NEG
93984: PUSH
93985: EMPTY
93986: LIST
93987: LIST
93988: PUSH
93989: LD_INT 3
93991: NEG
93992: PUSH
93993: LD_INT 0
93995: PUSH
93996: EMPTY
93997: LIST
93998: LIST
93999: PUSH
94000: LD_INT 3
94002: NEG
94003: PUSH
94004: LD_INT 1
94006: PUSH
94007: EMPTY
94008: LIST
94009: LIST
94010: PUSH
94011: LD_INT 4
94013: NEG
94014: PUSH
94015: LD_INT 1
94017: PUSH
94018: EMPTY
94019: LIST
94020: LIST
94021: PUSH
94022: LD_INT 5
94024: NEG
94025: PUSH
94026: LD_INT 0
94028: PUSH
94029: EMPTY
94030: LIST
94031: LIST
94032: PUSH
94033: LD_INT 5
94035: NEG
94036: PUSH
94037: LD_INT 1
94039: NEG
94040: PUSH
94041: EMPTY
94042: LIST
94043: LIST
94044: PUSH
94045: LD_INT 5
94047: NEG
94048: PUSH
94049: LD_INT 2
94051: NEG
94052: PUSH
94053: EMPTY
94054: LIST
94055: LIST
94056: PUSH
94057: LD_INT 3
94059: NEG
94060: PUSH
94061: LD_INT 2
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: PUSH
94068: LD_INT 3
94070: NEG
94071: PUSH
94072: LD_INT 3
94074: NEG
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 3
94082: NEG
94083: PUSH
94084: LD_INT 4
94086: NEG
94087: PUSH
94088: EMPTY
94089: LIST
94090: LIST
94091: PUSH
94092: LD_INT 2
94094: NEG
94095: PUSH
94096: LD_INT 3
94098: NEG
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: PUSH
94104: LD_INT 2
94106: NEG
94107: PUSH
94108: LD_INT 2
94110: NEG
94111: PUSH
94112: EMPTY
94113: LIST
94114: LIST
94115: PUSH
94116: LD_INT 3
94118: NEG
94119: PUSH
94120: LD_INT 2
94122: NEG
94123: PUSH
94124: EMPTY
94125: LIST
94126: LIST
94127: PUSH
94128: LD_INT 4
94130: NEG
94131: PUSH
94132: LD_INT 3
94134: NEG
94135: PUSH
94136: EMPTY
94137: LIST
94138: LIST
94139: PUSH
94140: LD_INT 4
94142: NEG
94143: PUSH
94144: LD_INT 4
94146: NEG
94147: PUSH
94148: EMPTY
94149: LIST
94150: LIST
94151: PUSH
94152: LD_INT 2
94154: NEG
94155: PUSH
94156: LD_INT 4
94158: NEG
94159: PUSH
94160: EMPTY
94161: LIST
94162: LIST
94163: PUSH
94164: LD_INT 4
94166: NEG
94167: PUSH
94168: LD_INT 2
94170: NEG
94171: PUSH
94172: EMPTY
94173: LIST
94174: LIST
94175: PUSH
94176: LD_INT 0
94178: PUSH
94179: LD_INT 4
94181: NEG
94182: PUSH
94183: EMPTY
94184: LIST
94185: LIST
94186: PUSH
94187: LD_INT 0
94189: PUSH
94190: LD_INT 5
94192: NEG
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: PUSH
94198: LD_INT 1
94200: PUSH
94201: LD_INT 4
94203: NEG
94204: PUSH
94205: EMPTY
94206: LIST
94207: LIST
94208: PUSH
94209: LD_INT 1
94211: PUSH
94212: LD_INT 3
94214: NEG
94215: PUSH
94216: EMPTY
94217: LIST
94218: LIST
94219: PUSH
94220: LD_INT 0
94222: PUSH
94223: LD_INT 3
94225: NEG
94226: PUSH
94227: EMPTY
94228: LIST
94229: LIST
94230: PUSH
94231: LD_INT 1
94233: NEG
94234: PUSH
94235: LD_INT 4
94237: NEG
94238: PUSH
94239: EMPTY
94240: LIST
94241: LIST
94242: PUSH
94243: LD_INT 1
94245: NEG
94246: PUSH
94247: LD_INT 5
94249: NEG
94250: PUSH
94251: EMPTY
94252: LIST
94253: LIST
94254: PUSH
94255: LD_INT 2
94257: PUSH
94258: LD_INT 3
94260: NEG
94261: PUSH
94262: EMPTY
94263: LIST
94264: LIST
94265: PUSH
94266: LD_INT 2
94268: NEG
94269: PUSH
94270: LD_INT 5
94272: NEG
94273: PUSH
94274: EMPTY
94275: LIST
94276: LIST
94277: PUSH
94278: LD_INT 3
94280: PUSH
94281: LD_INT 0
94283: PUSH
94284: EMPTY
94285: LIST
94286: LIST
94287: PUSH
94288: LD_INT 3
94290: PUSH
94291: LD_INT 1
94293: NEG
94294: PUSH
94295: EMPTY
94296: LIST
94297: LIST
94298: PUSH
94299: LD_INT 4
94301: PUSH
94302: LD_INT 0
94304: PUSH
94305: EMPTY
94306: LIST
94307: LIST
94308: PUSH
94309: LD_INT 4
94311: PUSH
94312: LD_INT 1
94314: PUSH
94315: EMPTY
94316: LIST
94317: LIST
94318: PUSH
94319: LD_INT 3
94321: PUSH
94322: LD_INT 1
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: PUSH
94329: LD_INT 2
94331: PUSH
94332: LD_INT 0
94334: PUSH
94335: EMPTY
94336: LIST
94337: LIST
94338: PUSH
94339: LD_INT 2
94341: PUSH
94342: LD_INT 1
94344: NEG
94345: PUSH
94346: EMPTY
94347: LIST
94348: LIST
94349: PUSH
94350: LD_INT 2
94352: PUSH
94353: LD_INT 2
94355: NEG
94356: PUSH
94357: EMPTY
94358: LIST
94359: LIST
94360: PUSH
94361: LD_INT 4
94363: PUSH
94364: LD_INT 2
94366: PUSH
94367: EMPTY
94368: LIST
94369: LIST
94370: PUSH
94371: LD_INT 4
94373: PUSH
94374: LD_INT 4
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: PUSH
94381: LD_INT 4
94383: PUSH
94384: LD_INT 3
94386: PUSH
94387: EMPTY
94388: LIST
94389: LIST
94390: PUSH
94391: LD_INT 5
94393: PUSH
94394: LD_INT 4
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: PUSH
94401: LD_INT 5
94403: PUSH
94404: LD_INT 5
94406: PUSH
94407: EMPTY
94408: LIST
94409: LIST
94410: PUSH
94411: LD_INT 4
94413: PUSH
94414: LD_INT 5
94416: PUSH
94417: EMPTY
94418: LIST
94419: LIST
94420: PUSH
94421: LD_INT 3
94423: PUSH
94424: LD_INT 4
94426: PUSH
94427: EMPTY
94428: LIST
94429: LIST
94430: PUSH
94431: LD_INT 3
94433: PUSH
94434: LD_INT 3
94436: PUSH
94437: EMPTY
94438: LIST
94439: LIST
94440: PUSH
94441: LD_INT 5
94443: PUSH
94444: LD_INT 3
94446: PUSH
94447: EMPTY
94448: LIST
94449: LIST
94450: PUSH
94451: LD_INT 3
94453: PUSH
94454: LD_INT 5
94456: PUSH
94457: EMPTY
94458: LIST
94459: LIST
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: LIST
94471: LIST
94472: LIST
94473: LIST
94474: LIST
94475: LIST
94476: LIST
94477: LIST
94478: LIST
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: LIST
94497: LIST
94498: LIST
94499: LIST
94500: LIST
94501: LIST
94502: LIST
94503: LIST
94504: LIST
94505: LIST
94506: LIST
94507: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
94508: LD_ADDR_VAR 0 33
94512: PUSH
94513: LD_INT 4
94515: NEG
94516: PUSH
94517: LD_INT 4
94519: NEG
94520: PUSH
94521: EMPTY
94522: LIST
94523: LIST
94524: PUSH
94525: LD_INT 4
94527: NEG
94528: PUSH
94529: LD_INT 5
94531: NEG
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 3
94539: NEG
94540: PUSH
94541: LD_INT 4
94543: NEG
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 3
94551: NEG
94552: PUSH
94553: LD_INT 3
94555: NEG
94556: PUSH
94557: EMPTY
94558: LIST
94559: LIST
94560: PUSH
94561: LD_INT 4
94563: NEG
94564: PUSH
94565: LD_INT 3
94567: NEG
94568: PUSH
94569: EMPTY
94570: LIST
94571: LIST
94572: PUSH
94573: LD_INT 5
94575: NEG
94576: PUSH
94577: LD_INT 4
94579: NEG
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: PUSH
94585: LD_INT 5
94587: NEG
94588: PUSH
94589: LD_INT 5
94591: NEG
94592: PUSH
94593: EMPTY
94594: LIST
94595: LIST
94596: PUSH
94597: LD_INT 3
94599: NEG
94600: PUSH
94601: LD_INT 5
94603: NEG
94604: PUSH
94605: EMPTY
94606: LIST
94607: LIST
94608: PUSH
94609: LD_INT 5
94611: NEG
94612: PUSH
94613: LD_INT 3
94615: NEG
94616: PUSH
94617: EMPTY
94618: LIST
94619: LIST
94620: PUSH
94621: LD_INT 0
94623: PUSH
94624: LD_INT 3
94626: NEG
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PUSH
94632: LD_INT 0
94634: PUSH
94635: LD_INT 4
94637: NEG
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: PUSH
94643: LD_INT 1
94645: PUSH
94646: LD_INT 3
94648: NEG
94649: PUSH
94650: EMPTY
94651: LIST
94652: LIST
94653: PUSH
94654: LD_INT 1
94656: PUSH
94657: LD_INT 2
94659: NEG
94660: PUSH
94661: EMPTY
94662: LIST
94663: LIST
94664: PUSH
94665: LD_INT 0
94667: PUSH
94668: LD_INT 2
94670: NEG
94671: PUSH
94672: EMPTY
94673: LIST
94674: LIST
94675: PUSH
94676: LD_INT 1
94678: NEG
94679: PUSH
94680: LD_INT 3
94682: NEG
94683: PUSH
94684: EMPTY
94685: LIST
94686: LIST
94687: PUSH
94688: LD_INT 1
94690: NEG
94691: PUSH
94692: LD_INT 4
94694: NEG
94695: PUSH
94696: EMPTY
94697: LIST
94698: LIST
94699: PUSH
94700: LD_INT 2
94702: PUSH
94703: LD_INT 2
94705: NEG
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 2
94713: NEG
94714: PUSH
94715: LD_INT 4
94717: NEG
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: PUSH
94723: LD_INT 4
94725: PUSH
94726: LD_INT 0
94728: PUSH
94729: EMPTY
94730: LIST
94731: LIST
94732: PUSH
94733: LD_INT 4
94735: PUSH
94736: LD_INT 1
94738: NEG
94739: PUSH
94740: EMPTY
94741: LIST
94742: LIST
94743: PUSH
94744: LD_INT 5
94746: PUSH
94747: LD_INT 0
94749: PUSH
94750: EMPTY
94751: LIST
94752: LIST
94753: PUSH
94754: LD_INT 5
94756: PUSH
94757: LD_INT 1
94759: PUSH
94760: EMPTY
94761: LIST
94762: LIST
94763: PUSH
94764: LD_INT 4
94766: PUSH
94767: LD_INT 1
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: PUSH
94774: LD_INT 3
94776: PUSH
94777: LD_INT 0
94779: PUSH
94780: EMPTY
94781: LIST
94782: LIST
94783: PUSH
94784: LD_INT 3
94786: PUSH
94787: LD_INT 1
94789: NEG
94790: PUSH
94791: EMPTY
94792: LIST
94793: LIST
94794: PUSH
94795: LD_INT 3
94797: PUSH
94798: LD_INT 2
94800: NEG
94801: PUSH
94802: EMPTY
94803: LIST
94804: LIST
94805: PUSH
94806: LD_INT 5
94808: PUSH
94809: LD_INT 2
94811: PUSH
94812: EMPTY
94813: LIST
94814: LIST
94815: PUSH
94816: LD_INT 3
94818: PUSH
94819: LD_INT 3
94821: PUSH
94822: EMPTY
94823: LIST
94824: LIST
94825: PUSH
94826: LD_INT 3
94828: PUSH
94829: LD_INT 2
94831: PUSH
94832: EMPTY
94833: LIST
94834: LIST
94835: PUSH
94836: LD_INT 4
94838: PUSH
94839: LD_INT 3
94841: PUSH
94842: EMPTY
94843: LIST
94844: LIST
94845: PUSH
94846: LD_INT 4
94848: PUSH
94849: LD_INT 4
94851: PUSH
94852: EMPTY
94853: LIST
94854: LIST
94855: PUSH
94856: LD_INT 3
94858: PUSH
94859: LD_INT 4
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PUSH
94866: LD_INT 2
94868: PUSH
94869: LD_INT 3
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: PUSH
94876: LD_INT 2
94878: PUSH
94879: LD_INT 2
94881: PUSH
94882: EMPTY
94883: LIST
94884: LIST
94885: PUSH
94886: LD_INT 4
94888: PUSH
94889: LD_INT 2
94891: PUSH
94892: EMPTY
94893: LIST
94894: LIST
94895: PUSH
94896: LD_INT 2
94898: PUSH
94899: LD_INT 4
94901: PUSH
94902: EMPTY
94903: LIST
94904: LIST
94905: PUSH
94906: LD_INT 0
94908: PUSH
94909: LD_INT 4
94911: PUSH
94912: EMPTY
94913: LIST
94914: LIST
94915: PUSH
94916: LD_INT 0
94918: PUSH
94919: LD_INT 3
94921: PUSH
94922: EMPTY
94923: LIST
94924: LIST
94925: PUSH
94926: LD_INT 1
94928: PUSH
94929: LD_INT 4
94931: PUSH
94932: EMPTY
94933: LIST
94934: LIST
94935: PUSH
94936: LD_INT 1
94938: PUSH
94939: LD_INT 5
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: PUSH
94946: LD_INT 0
94948: PUSH
94949: LD_INT 5
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 1
94958: NEG
94959: PUSH
94960: LD_INT 4
94962: PUSH
94963: EMPTY
94964: LIST
94965: LIST
94966: PUSH
94967: LD_INT 1
94969: NEG
94970: PUSH
94971: LD_INT 3
94973: PUSH
94974: EMPTY
94975: LIST
94976: LIST
94977: PUSH
94978: LD_INT 2
94980: PUSH
94981: LD_INT 5
94983: PUSH
94984: EMPTY
94985: LIST
94986: LIST
94987: PUSH
94988: LD_INT 2
94990: NEG
94991: PUSH
94992: LD_INT 3
94994: PUSH
94995: EMPTY
94996: LIST
94997: LIST
94998: PUSH
94999: EMPTY
95000: LIST
95001: LIST
95002: LIST
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
95046: LD_ADDR_VAR 0 34
95050: PUSH
95051: LD_INT 0
95053: PUSH
95054: LD_INT 4
95056: NEG
95057: PUSH
95058: EMPTY
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 0
95064: PUSH
95065: LD_INT 5
95067: NEG
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: LD_INT 1
95075: PUSH
95076: LD_INT 4
95078: NEG
95079: PUSH
95080: EMPTY
95081: LIST
95082: LIST
95083: PUSH
95084: LD_INT 1
95086: PUSH
95087: LD_INT 3
95089: NEG
95090: PUSH
95091: EMPTY
95092: LIST
95093: LIST
95094: PUSH
95095: LD_INT 0
95097: PUSH
95098: LD_INT 3
95100: NEG
95101: PUSH
95102: EMPTY
95103: LIST
95104: LIST
95105: PUSH
95106: LD_INT 1
95108: NEG
95109: PUSH
95110: LD_INT 4
95112: NEG
95113: PUSH
95114: EMPTY
95115: LIST
95116: LIST
95117: PUSH
95118: LD_INT 1
95120: NEG
95121: PUSH
95122: LD_INT 5
95124: NEG
95125: PUSH
95126: EMPTY
95127: LIST
95128: LIST
95129: PUSH
95130: LD_INT 2
95132: PUSH
95133: LD_INT 3
95135: NEG
95136: PUSH
95137: EMPTY
95138: LIST
95139: LIST
95140: PUSH
95141: LD_INT 2
95143: NEG
95144: PUSH
95145: LD_INT 5
95147: NEG
95148: PUSH
95149: EMPTY
95150: LIST
95151: LIST
95152: PUSH
95153: LD_INT 3
95155: PUSH
95156: LD_INT 0
95158: PUSH
95159: EMPTY
95160: LIST
95161: LIST
95162: PUSH
95163: LD_INT 3
95165: PUSH
95166: LD_INT 1
95168: NEG
95169: PUSH
95170: EMPTY
95171: LIST
95172: LIST
95173: PUSH
95174: LD_INT 4
95176: PUSH
95177: LD_INT 0
95179: PUSH
95180: EMPTY
95181: LIST
95182: LIST
95183: PUSH
95184: LD_INT 4
95186: PUSH
95187: LD_INT 1
95189: PUSH
95190: EMPTY
95191: LIST
95192: LIST
95193: PUSH
95194: LD_INT 3
95196: PUSH
95197: LD_INT 1
95199: PUSH
95200: EMPTY
95201: LIST
95202: LIST
95203: PUSH
95204: LD_INT 2
95206: PUSH
95207: LD_INT 0
95209: PUSH
95210: EMPTY
95211: LIST
95212: LIST
95213: PUSH
95214: LD_INT 2
95216: PUSH
95217: LD_INT 1
95219: NEG
95220: PUSH
95221: EMPTY
95222: LIST
95223: LIST
95224: PUSH
95225: LD_INT 2
95227: PUSH
95228: LD_INT 2
95230: NEG
95231: PUSH
95232: EMPTY
95233: LIST
95234: LIST
95235: PUSH
95236: LD_INT 4
95238: PUSH
95239: LD_INT 2
95241: PUSH
95242: EMPTY
95243: LIST
95244: LIST
95245: PUSH
95246: LD_INT 4
95248: PUSH
95249: LD_INT 4
95251: PUSH
95252: EMPTY
95253: LIST
95254: LIST
95255: PUSH
95256: LD_INT 4
95258: PUSH
95259: LD_INT 3
95261: PUSH
95262: EMPTY
95263: LIST
95264: LIST
95265: PUSH
95266: LD_INT 5
95268: PUSH
95269: LD_INT 4
95271: PUSH
95272: EMPTY
95273: LIST
95274: LIST
95275: PUSH
95276: LD_INT 5
95278: PUSH
95279: LD_INT 5
95281: PUSH
95282: EMPTY
95283: LIST
95284: LIST
95285: PUSH
95286: LD_INT 4
95288: PUSH
95289: LD_INT 5
95291: PUSH
95292: EMPTY
95293: LIST
95294: LIST
95295: PUSH
95296: LD_INT 3
95298: PUSH
95299: LD_INT 4
95301: PUSH
95302: EMPTY
95303: LIST
95304: LIST
95305: PUSH
95306: LD_INT 3
95308: PUSH
95309: LD_INT 3
95311: PUSH
95312: EMPTY
95313: LIST
95314: LIST
95315: PUSH
95316: LD_INT 5
95318: PUSH
95319: LD_INT 3
95321: PUSH
95322: EMPTY
95323: LIST
95324: LIST
95325: PUSH
95326: LD_INT 3
95328: PUSH
95329: LD_INT 5
95331: PUSH
95332: EMPTY
95333: LIST
95334: LIST
95335: PUSH
95336: LD_INT 0
95338: PUSH
95339: LD_INT 3
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: PUSH
95346: LD_INT 0
95348: PUSH
95349: LD_INT 2
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: LD_INT 1
95358: PUSH
95359: LD_INT 3
95361: PUSH
95362: EMPTY
95363: LIST
95364: LIST
95365: PUSH
95366: LD_INT 1
95368: PUSH
95369: LD_INT 4
95371: PUSH
95372: EMPTY
95373: LIST
95374: LIST
95375: PUSH
95376: LD_INT 0
95378: PUSH
95379: LD_INT 4
95381: PUSH
95382: EMPTY
95383: LIST
95384: LIST
95385: PUSH
95386: LD_INT 1
95388: NEG
95389: PUSH
95390: LD_INT 3
95392: PUSH
95393: EMPTY
95394: LIST
95395: LIST
95396: PUSH
95397: LD_INT 1
95399: NEG
95400: PUSH
95401: LD_INT 2
95403: PUSH
95404: EMPTY
95405: LIST
95406: LIST
95407: PUSH
95408: LD_INT 2
95410: PUSH
95411: LD_INT 4
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 2
95420: NEG
95421: PUSH
95422: LD_INT 2
95424: PUSH
95425: EMPTY
95426: LIST
95427: LIST
95428: PUSH
95429: LD_INT 4
95431: NEG
95432: PUSH
95433: LD_INT 0
95435: PUSH
95436: EMPTY
95437: LIST
95438: LIST
95439: PUSH
95440: LD_INT 4
95442: NEG
95443: PUSH
95444: LD_INT 1
95446: NEG
95447: PUSH
95448: EMPTY
95449: LIST
95450: LIST
95451: PUSH
95452: LD_INT 3
95454: NEG
95455: PUSH
95456: LD_INT 0
95458: PUSH
95459: EMPTY
95460: LIST
95461: LIST
95462: PUSH
95463: LD_INT 3
95465: NEG
95466: PUSH
95467: LD_INT 1
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: PUSH
95474: LD_INT 4
95476: NEG
95477: PUSH
95478: LD_INT 1
95480: PUSH
95481: EMPTY
95482: LIST
95483: LIST
95484: PUSH
95485: LD_INT 5
95487: NEG
95488: PUSH
95489: LD_INT 0
95491: PUSH
95492: EMPTY
95493: LIST
95494: LIST
95495: PUSH
95496: LD_INT 5
95498: NEG
95499: PUSH
95500: LD_INT 1
95502: NEG
95503: PUSH
95504: EMPTY
95505: LIST
95506: LIST
95507: PUSH
95508: LD_INT 5
95510: NEG
95511: PUSH
95512: LD_INT 2
95514: NEG
95515: PUSH
95516: EMPTY
95517: LIST
95518: LIST
95519: PUSH
95520: LD_INT 3
95522: NEG
95523: PUSH
95524: LD_INT 2
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PUSH
95531: EMPTY
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: LIST
95539: LIST
95540: LIST
95541: LIST
95542: LIST
95543: LIST
95544: LIST
95545: LIST
95546: LIST
95547: LIST
95548: LIST
95549: LIST
95550: LIST
95551: LIST
95552: LIST
95553: LIST
95554: LIST
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: ST_TO_ADDR
// end ; end ;
95578: GO 95581
95580: POP
// case btype of b_depot , b_warehouse :
95581: LD_VAR 0 1
95585: PUSH
95586: LD_INT 0
95588: DOUBLE
95589: EQUAL
95590: IFTRUE 95600
95592: LD_INT 1
95594: DOUBLE
95595: EQUAL
95596: IFTRUE 95600
95598: GO 95801
95600: POP
// case nation of nation_american :
95601: LD_VAR 0 5
95605: PUSH
95606: LD_INT 1
95608: DOUBLE
95609: EQUAL
95610: IFTRUE 95614
95612: GO 95670
95614: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
95615: LD_ADDR_VAR 0 9
95619: PUSH
95620: LD_VAR 0 11
95624: PUSH
95625: LD_VAR 0 12
95629: PUSH
95630: LD_VAR 0 13
95634: PUSH
95635: LD_VAR 0 14
95639: PUSH
95640: LD_VAR 0 15
95644: PUSH
95645: LD_VAR 0 16
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: PUSH
95658: LD_VAR 0 4
95662: PUSH
95663: LD_INT 1
95665: PLUS
95666: ARRAY
95667: ST_TO_ADDR
95668: GO 95799
95670: LD_INT 2
95672: DOUBLE
95673: EQUAL
95674: IFTRUE 95678
95676: GO 95734
95678: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
95679: LD_ADDR_VAR 0 9
95683: PUSH
95684: LD_VAR 0 17
95688: PUSH
95689: LD_VAR 0 18
95693: PUSH
95694: LD_VAR 0 19
95698: PUSH
95699: LD_VAR 0 20
95703: PUSH
95704: LD_VAR 0 21
95708: PUSH
95709: LD_VAR 0 22
95713: PUSH
95714: EMPTY
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: PUSH
95722: LD_VAR 0 4
95726: PUSH
95727: LD_INT 1
95729: PLUS
95730: ARRAY
95731: ST_TO_ADDR
95732: GO 95799
95734: LD_INT 3
95736: DOUBLE
95737: EQUAL
95738: IFTRUE 95742
95740: GO 95798
95742: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
95743: LD_ADDR_VAR 0 9
95747: PUSH
95748: LD_VAR 0 23
95752: PUSH
95753: LD_VAR 0 24
95757: PUSH
95758: LD_VAR 0 25
95762: PUSH
95763: LD_VAR 0 26
95767: PUSH
95768: LD_VAR 0 27
95772: PUSH
95773: LD_VAR 0 28
95777: PUSH
95778: EMPTY
95779: LIST
95780: LIST
95781: LIST
95782: LIST
95783: LIST
95784: LIST
95785: PUSH
95786: LD_VAR 0 4
95790: PUSH
95791: LD_INT 1
95793: PLUS
95794: ARRAY
95795: ST_TO_ADDR
95796: GO 95799
95798: POP
95799: GO 96354
95801: LD_INT 2
95803: DOUBLE
95804: EQUAL
95805: IFTRUE 95815
95807: LD_INT 3
95809: DOUBLE
95810: EQUAL
95811: IFTRUE 95815
95813: GO 95871
95815: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
95816: LD_ADDR_VAR 0 9
95820: PUSH
95821: LD_VAR 0 29
95825: PUSH
95826: LD_VAR 0 30
95830: PUSH
95831: LD_VAR 0 31
95835: PUSH
95836: LD_VAR 0 32
95840: PUSH
95841: LD_VAR 0 33
95845: PUSH
95846: LD_VAR 0 34
95850: PUSH
95851: EMPTY
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: PUSH
95859: LD_VAR 0 4
95863: PUSH
95864: LD_INT 1
95866: PLUS
95867: ARRAY
95868: ST_TO_ADDR
95869: GO 96354
95871: LD_INT 16
95873: DOUBLE
95874: EQUAL
95875: IFTRUE 95933
95877: LD_INT 17
95879: DOUBLE
95880: EQUAL
95881: IFTRUE 95933
95883: LD_INT 18
95885: DOUBLE
95886: EQUAL
95887: IFTRUE 95933
95889: LD_INT 19
95891: DOUBLE
95892: EQUAL
95893: IFTRUE 95933
95895: LD_INT 22
95897: DOUBLE
95898: EQUAL
95899: IFTRUE 95933
95901: LD_INT 20
95903: DOUBLE
95904: EQUAL
95905: IFTRUE 95933
95907: LD_INT 21
95909: DOUBLE
95910: EQUAL
95911: IFTRUE 95933
95913: LD_INT 23
95915: DOUBLE
95916: EQUAL
95917: IFTRUE 95933
95919: LD_INT 24
95921: DOUBLE
95922: EQUAL
95923: IFTRUE 95933
95925: LD_INT 25
95927: DOUBLE
95928: EQUAL
95929: IFTRUE 95933
95931: GO 95989
95933: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
95934: LD_ADDR_VAR 0 9
95938: PUSH
95939: LD_VAR 0 35
95943: PUSH
95944: LD_VAR 0 36
95948: PUSH
95949: LD_VAR 0 37
95953: PUSH
95954: LD_VAR 0 38
95958: PUSH
95959: LD_VAR 0 39
95963: PUSH
95964: LD_VAR 0 40
95968: PUSH
95969: EMPTY
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: PUSH
95977: LD_VAR 0 4
95981: PUSH
95982: LD_INT 1
95984: PLUS
95985: ARRAY
95986: ST_TO_ADDR
95987: GO 96354
95989: LD_INT 6
95991: DOUBLE
95992: EQUAL
95993: IFTRUE 96045
95995: LD_INT 7
95997: DOUBLE
95998: EQUAL
95999: IFTRUE 96045
96001: LD_INT 8
96003: DOUBLE
96004: EQUAL
96005: IFTRUE 96045
96007: LD_INT 13
96009: DOUBLE
96010: EQUAL
96011: IFTRUE 96045
96013: LD_INT 12
96015: DOUBLE
96016: EQUAL
96017: IFTRUE 96045
96019: LD_INT 15
96021: DOUBLE
96022: EQUAL
96023: IFTRUE 96045
96025: LD_INT 11
96027: DOUBLE
96028: EQUAL
96029: IFTRUE 96045
96031: LD_INT 14
96033: DOUBLE
96034: EQUAL
96035: IFTRUE 96045
96037: LD_INT 10
96039: DOUBLE
96040: EQUAL
96041: IFTRUE 96045
96043: GO 96101
96045: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
96046: LD_ADDR_VAR 0 9
96050: PUSH
96051: LD_VAR 0 41
96055: PUSH
96056: LD_VAR 0 42
96060: PUSH
96061: LD_VAR 0 43
96065: PUSH
96066: LD_VAR 0 44
96070: PUSH
96071: LD_VAR 0 45
96075: PUSH
96076: LD_VAR 0 46
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: LIST
96085: LIST
96086: LIST
96087: LIST
96088: PUSH
96089: LD_VAR 0 4
96093: PUSH
96094: LD_INT 1
96096: PLUS
96097: ARRAY
96098: ST_TO_ADDR
96099: GO 96354
96101: LD_INT 36
96103: DOUBLE
96104: EQUAL
96105: IFTRUE 96109
96107: GO 96165
96109: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
96110: LD_ADDR_VAR 0 9
96114: PUSH
96115: LD_VAR 0 47
96119: PUSH
96120: LD_VAR 0 48
96124: PUSH
96125: LD_VAR 0 49
96129: PUSH
96130: LD_VAR 0 50
96134: PUSH
96135: LD_VAR 0 51
96139: PUSH
96140: LD_VAR 0 52
96144: PUSH
96145: EMPTY
96146: LIST
96147: LIST
96148: LIST
96149: LIST
96150: LIST
96151: LIST
96152: PUSH
96153: LD_VAR 0 4
96157: PUSH
96158: LD_INT 1
96160: PLUS
96161: ARRAY
96162: ST_TO_ADDR
96163: GO 96354
96165: LD_INT 4
96167: DOUBLE
96168: EQUAL
96169: IFTRUE 96191
96171: LD_INT 5
96173: DOUBLE
96174: EQUAL
96175: IFTRUE 96191
96177: LD_INT 34
96179: DOUBLE
96180: EQUAL
96181: IFTRUE 96191
96183: LD_INT 37
96185: DOUBLE
96186: EQUAL
96187: IFTRUE 96191
96189: GO 96247
96191: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
96192: LD_ADDR_VAR 0 9
96196: PUSH
96197: LD_VAR 0 53
96201: PUSH
96202: LD_VAR 0 54
96206: PUSH
96207: LD_VAR 0 55
96211: PUSH
96212: LD_VAR 0 56
96216: PUSH
96217: LD_VAR 0 57
96221: PUSH
96222: LD_VAR 0 58
96226: PUSH
96227: EMPTY
96228: LIST
96229: LIST
96230: LIST
96231: LIST
96232: LIST
96233: LIST
96234: PUSH
96235: LD_VAR 0 4
96239: PUSH
96240: LD_INT 1
96242: PLUS
96243: ARRAY
96244: ST_TO_ADDR
96245: GO 96354
96247: LD_INT 31
96249: DOUBLE
96250: EQUAL
96251: IFTRUE 96297
96253: LD_INT 32
96255: DOUBLE
96256: EQUAL
96257: IFTRUE 96297
96259: LD_INT 33
96261: DOUBLE
96262: EQUAL
96263: IFTRUE 96297
96265: LD_INT 27
96267: DOUBLE
96268: EQUAL
96269: IFTRUE 96297
96271: LD_INT 26
96273: DOUBLE
96274: EQUAL
96275: IFTRUE 96297
96277: LD_INT 28
96279: DOUBLE
96280: EQUAL
96281: IFTRUE 96297
96283: LD_INT 29
96285: DOUBLE
96286: EQUAL
96287: IFTRUE 96297
96289: LD_INT 30
96291: DOUBLE
96292: EQUAL
96293: IFTRUE 96297
96295: GO 96353
96297: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
96298: LD_ADDR_VAR 0 9
96302: PUSH
96303: LD_VAR 0 59
96307: PUSH
96308: LD_VAR 0 60
96312: PUSH
96313: LD_VAR 0 61
96317: PUSH
96318: LD_VAR 0 62
96322: PUSH
96323: LD_VAR 0 63
96327: PUSH
96328: LD_VAR 0 64
96332: PUSH
96333: EMPTY
96334: LIST
96335: LIST
96336: LIST
96337: LIST
96338: LIST
96339: LIST
96340: PUSH
96341: LD_VAR 0 4
96345: PUSH
96346: LD_INT 1
96348: PLUS
96349: ARRAY
96350: ST_TO_ADDR
96351: GO 96354
96353: POP
// temp_list2 = [ ] ;
96354: LD_ADDR_VAR 0 10
96358: PUSH
96359: EMPTY
96360: ST_TO_ADDR
// for i in temp_list do
96361: LD_ADDR_VAR 0 8
96365: PUSH
96366: LD_VAR 0 9
96370: PUSH
96371: FOR_IN
96372: IFFALSE 96424
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
96374: LD_ADDR_VAR 0 10
96378: PUSH
96379: LD_VAR 0 10
96383: PUSH
96384: LD_VAR 0 8
96388: PUSH
96389: LD_INT 1
96391: ARRAY
96392: PUSH
96393: LD_VAR 0 2
96397: PLUS
96398: PUSH
96399: LD_VAR 0 8
96403: PUSH
96404: LD_INT 2
96406: ARRAY
96407: PUSH
96408: LD_VAR 0 3
96412: PLUS
96413: PUSH
96414: EMPTY
96415: LIST
96416: LIST
96417: PUSH
96418: EMPTY
96419: LIST
96420: ADD
96421: ST_TO_ADDR
96422: GO 96371
96424: POP
96425: POP
// result = temp_list2 ;
96426: LD_ADDR_VAR 0 7
96430: PUSH
96431: LD_VAR 0 10
96435: ST_TO_ADDR
// end ;
96436: LD_VAR 0 7
96440: RET
// export function EnemyInRange ( unit , dist ) ; begin
96441: LD_INT 0
96443: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
96444: LD_ADDR_VAR 0 3
96448: PUSH
96449: LD_VAR 0 1
96453: PPUSH
96454: CALL_OW 255
96458: PPUSH
96459: LD_VAR 0 1
96463: PPUSH
96464: CALL_OW 250
96468: PPUSH
96469: LD_VAR 0 1
96473: PPUSH
96474: CALL_OW 251
96478: PPUSH
96479: LD_VAR 0 2
96483: PPUSH
96484: CALL 70545 0 4
96488: PUSH
96489: LD_INT 4
96491: ARRAY
96492: ST_TO_ADDR
// end ;
96493: LD_VAR 0 3
96497: RET
// export function PlayerSeeMe ( unit ) ; begin
96498: LD_INT 0
96500: PPUSH
// result := See ( your_side , unit ) ;
96501: LD_ADDR_VAR 0 2
96505: PUSH
96506: LD_OWVAR 2
96510: PPUSH
96511: LD_VAR 0 1
96515: PPUSH
96516: CALL_OW 292
96520: ST_TO_ADDR
// end ;
96521: LD_VAR 0 2
96525: RET
// export function ReverseDir ( unit ) ; begin
96526: LD_INT 0
96528: PPUSH
// if not unit then
96529: LD_VAR 0 1
96533: NOT
96534: IFFALSE 96538
// exit ;
96536: GO 96584
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
96538: LD_ADDR_VAR 0 2
96542: PUSH
96543: LD_INT 3
96545: PUSH
96546: LD_INT 4
96548: PUSH
96549: LD_INT 5
96551: PUSH
96552: LD_INT 0
96554: PUSH
96555: LD_INT 1
96557: PUSH
96558: LD_INT 2
96560: PUSH
96561: EMPTY
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: PUSH
96569: LD_VAR 0 1
96573: PPUSH
96574: CALL_OW 254
96578: PUSH
96579: LD_INT 1
96581: PLUS
96582: ARRAY
96583: ST_TO_ADDR
// end ;
96584: LD_VAR 0 2
96588: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
96589: LD_INT 0
96591: PPUSH
96592: PPUSH
96593: PPUSH
96594: PPUSH
96595: PPUSH
// if not hexes then
96596: LD_VAR 0 2
96600: NOT
96601: IFFALSE 96605
// exit ;
96603: GO 96753
// dist := 9999 ;
96605: LD_ADDR_VAR 0 5
96609: PUSH
96610: LD_INT 9999
96612: ST_TO_ADDR
// for i = 1 to hexes do
96613: LD_ADDR_VAR 0 4
96617: PUSH
96618: DOUBLE
96619: LD_INT 1
96621: DEC
96622: ST_TO_ADDR
96623: LD_VAR 0 2
96627: PUSH
96628: FOR_TO
96629: IFFALSE 96741
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
96631: LD_VAR 0 1
96635: PPUSH
96636: LD_VAR 0 2
96640: PUSH
96641: LD_VAR 0 4
96645: ARRAY
96646: PUSH
96647: LD_INT 1
96649: ARRAY
96650: PPUSH
96651: LD_VAR 0 2
96655: PUSH
96656: LD_VAR 0 4
96660: ARRAY
96661: PUSH
96662: LD_INT 2
96664: ARRAY
96665: PPUSH
96666: CALL_OW 297
96670: PUSH
96671: LD_VAR 0 5
96675: LESS
96676: IFFALSE 96739
// begin hex := hexes [ i ] ;
96678: LD_ADDR_VAR 0 7
96682: PUSH
96683: LD_VAR 0 2
96687: PUSH
96688: LD_VAR 0 4
96692: ARRAY
96693: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
96694: LD_ADDR_VAR 0 5
96698: PUSH
96699: LD_VAR 0 1
96703: PPUSH
96704: LD_VAR 0 2
96708: PUSH
96709: LD_VAR 0 4
96713: ARRAY
96714: PUSH
96715: LD_INT 1
96717: ARRAY
96718: PPUSH
96719: LD_VAR 0 2
96723: PUSH
96724: LD_VAR 0 4
96728: ARRAY
96729: PUSH
96730: LD_INT 2
96732: ARRAY
96733: PPUSH
96734: CALL_OW 297
96738: ST_TO_ADDR
// end ; end ;
96739: GO 96628
96741: POP
96742: POP
// result := hex ;
96743: LD_ADDR_VAR 0 3
96747: PUSH
96748: LD_VAR 0 7
96752: ST_TO_ADDR
// end ;
96753: LD_VAR 0 3
96757: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
96758: LD_INT 0
96760: PPUSH
96761: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96762: LD_VAR 0 1
96766: NOT
96767: PUSH
96768: LD_VAR 0 1
96772: PUSH
96773: LD_INT 21
96775: PUSH
96776: LD_INT 2
96778: PUSH
96779: EMPTY
96780: LIST
96781: LIST
96782: PUSH
96783: LD_INT 23
96785: PUSH
96786: LD_INT 2
96788: PUSH
96789: EMPTY
96790: LIST
96791: LIST
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PPUSH
96797: CALL_OW 69
96801: IN
96802: NOT
96803: OR
96804: IFFALSE 96808
// exit ;
96806: GO 96855
// for i = 1 to 3 do
96808: LD_ADDR_VAR 0 3
96812: PUSH
96813: DOUBLE
96814: LD_INT 1
96816: DEC
96817: ST_TO_ADDR
96818: LD_INT 3
96820: PUSH
96821: FOR_TO
96822: IFFALSE 96853
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
96824: LD_VAR 0 1
96828: PPUSH
96829: CALL_OW 250
96833: PPUSH
96834: LD_VAR 0 1
96838: PPUSH
96839: CALL_OW 251
96843: PPUSH
96844: LD_INT 1
96846: PPUSH
96847: CALL_OW 453
96851: GO 96821
96853: POP
96854: POP
// end ;
96855: LD_VAR 0 2
96859: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
96860: LD_INT 0
96862: PPUSH
96863: PPUSH
96864: PPUSH
96865: PPUSH
96866: PPUSH
96867: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
96868: LD_VAR 0 1
96872: NOT
96873: PUSH
96874: LD_VAR 0 2
96878: NOT
96879: OR
96880: PUSH
96881: LD_VAR 0 1
96885: PPUSH
96886: CALL_OW 314
96890: OR
96891: IFFALSE 96895
// exit ;
96893: GO 97336
// x := GetX ( enemy_unit ) ;
96895: LD_ADDR_VAR 0 7
96899: PUSH
96900: LD_VAR 0 2
96904: PPUSH
96905: CALL_OW 250
96909: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
96910: LD_ADDR_VAR 0 8
96914: PUSH
96915: LD_VAR 0 2
96919: PPUSH
96920: CALL_OW 251
96924: ST_TO_ADDR
// if not x or not y then
96925: LD_VAR 0 7
96929: NOT
96930: PUSH
96931: LD_VAR 0 8
96935: NOT
96936: OR
96937: IFFALSE 96941
// exit ;
96939: GO 97336
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
96941: LD_ADDR_VAR 0 6
96945: PUSH
96946: LD_VAR 0 7
96950: PPUSH
96951: LD_INT 0
96953: PPUSH
96954: LD_INT 4
96956: PPUSH
96957: CALL_OW 272
96961: PUSH
96962: LD_VAR 0 8
96966: PPUSH
96967: LD_INT 0
96969: PPUSH
96970: LD_INT 4
96972: PPUSH
96973: CALL_OW 273
96977: PUSH
96978: EMPTY
96979: LIST
96980: LIST
96981: PUSH
96982: LD_VAR 0 7
96986: PPUSH
96987: LD_INT 1
96989: PPUSH
96990: LD_INT 4
96992: PPUSH
96993: CALL_OW 272
96997: PUSH
96998: LD_VAR 0 8
97002: PPUSH
97003: LD_INT 1
97005: PPUSH
97006: LD_INT 4
97008: PPUSH
97009: CALL_OW 273
97013: PUSH
97014: EMPTY
97015: LIST
97016: LIST
97017: PUSH
97018: LD_VAR 0 7
97022: PPUSH
97023: LD_INT 2
97025: PPUSH
97026: LD_INT 4
97028: PPUSH
97029: CALL_OW 272
97033: PUSH
97034: LD_VAR 0 8
97038: PPUSH
97039: LD_INT 2
97041: PPUSH
97042: LD_INT 4
97044: PPUSH
97045: CALL_OW 273
97049: PUSH
97050: EMPTY
97051: LIST
97052: LIST
97053: PUSH
97054: LD_VAR 0 7
97058: PPUSH
97059: LD_INT 3
97061: PPUSH
97062: LD_INT 4
97064: PPUSH
97065: CALL_OW 272
97069: PUSH
97070: LD_VAR 0 8
97074: PPUSH
97075: LD_INT 3
97077: PPUSH
97078: LD_INT 4
97080: PPUSH
97081: CALL_OW 273
97085: PUSH
97086: EMPTY
97087: LIST
97088: LIST
97089: PUSH
97090: LD_VAR 0 7
97094: PPUSH
97095: LD_INT 4
97097: PPUSH
97098: LD_INT 4
97100: PPUSH
97101: CALL_OW 272
97105: PUSH
97106: LD_VAR 0 8
97110: PPUSH
97111: LD_INT 4
97113: PPUSH
97114: LD_INT 4
97116: PPUSH
97117: CALL_OW 273
97121: PUSH
97122: EMPTY
97123: LIST
97124: LIST
97125: PUSH
97126: LD_VAR 0 7
97130: PPUSH
97131: LD_INT 5
97133: PPUSH
97134: LD_INT 4
97136: PPUSH
97137: CALL_OW 272
97141: PUSH
97142: LD_VAR 0 8
97146: PPUSH
97147: LD_INT 5
97149: PPUSH
97150: LD_INT 4
97152: PPUSH
97153: CALL_OW 273
97157: PUSH
97158: EMPTY
97159: LIST
97160: LIST
97161: PUSH
97162: EMPTY
97163: LIST
97164: LIST
97165: LIST
97166: LIST
97167: LIST
97168: LIST
97169: ST_TO_ADDR
// for i = tmp downto 1 do
97170: LD_ADDR_VAR 0 4
97174: PUSH
97175: DOUBLE
97176: LD_VAR 0 6
97180: INC
97181: ST_TO_ADDR
97182: LD_INT 1
97184: PUSH
97185: FOR_DOWNTO
97186: IFFALSE 97287
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
97188: LD_VAR 0 6
97192: PUSH
97193: LD_VAR 0 4
97197: ARRAY
97198: PUSH
97199: LD_INT 1
97201: ARRAY
97202: PPUSH
97203: LD_VAR 0 6
97207: PUSH
97208: LD_VAR 0 4
97212: ARRAY
97213: PUSH
97214: LD_INT 2
97216: ARRAY
97217: PPUSH
97218: CALL_OW 488
97222: NOT
97223: PUSH
97224: LD_VAR 0 6
97228: PUSH
97229: LD_VAR 0 4
97233: ARRAY
97234: PUSH
97235: LD_INT 1
97237: ARRAY
97238: PPUSH
97239: LD_VAR 0 6
97243: PUSH
97244: LD_VAR 0 4
97248: ARRAY
97249: PUSH
97250: LD_INT 2
97252: ARRAY
97253: PPUSH
97254: CALL_OW 428
97258: PUSH
97259: LD_INT 0
97261: NONEQUAL
97262: OR
97263: IFFALSE 97285
// tmp := Delete ( tmp , i ) ;
97265: LD_ADDR_VAR 0 6
97269: PUSH
97270: LD_VAR 0 6
97274: PPUSH
97275: LD_VAR 0 4
97279: PPUSH
97280: CALL_OW 3
97284: ST_TO_ADDR
97285: GO 97185
97287: POP
97288: POP
// j := GetClosestHex ( unit , tmp ) ;
97289: LD_ADDR_VAR 0 5
97293: PUSH
97294: LD_VAR 0 1
97298: PPUSH
97299: LD_VAR 0 6
97303: PPUSH
97304: CALL 96589 0 2
97308: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
97309: LD_VAR 0 1
97313: PPUSH
97314: LD_VAR 0 5
97318: PUSH
97319: LD_INT 1
97321: ARRAY
97322: PPUSH
97323: LD_VAR 0 5
97327: PUSH
97328: LD_INT 2
97330: ARRAY
97331: PPUSH
97332: CALL_OW 111
// end ;
97336: LD_VAR 0 3
97340: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
97341: LD_INT 0
97343: PPUSH
97344: PPUSH
97345: PPUSH
// uc_side = 0 ;
97346: LD_ADDR_OWVAR 20
97350: PUSH
97351: LD_INT 0
97353: ST_TO_ADDR
// uc_nation = 0 ;
97354: LD_ADDR_OWVAR 21
97358: PUSH
97359: LD_INT 0
97361: ST_TO_ADDR
// InitHc ;
97362: CALL_OW 19
// InitVc ;
97366: CALL_OW 20
// if mastodonts then
97370: LD_VAR 0 6
97374: IFFALSE 97441
// for i = 1 to mastodonts do
97376: LD_ADDR_VAR 0 11
97380: PUSH
97381: DOUBLE
97382: LD_INT 1
97384: DEC
97385: ST_TO_ADDR
97386: LD_VAR 0 6
97390: PUSH
97391: FOR_TO
97392: IFFALSE 97439
// begin vc_chassis := 31 ;
97394: LD_ADDR_OWVAR 37
97398: PUSH
97399: LD_INT 31
97401: ST_TO_ADDR
// vc_control := control_rider ;
97402: LD_ADDR_OWVAR 38
97406: PUSH
97407: LD_INT 4
97409: ST_TO_ADDR
// animal := CreateVehicle ;
97410: LD_ADDR_VAR 0 12
97414: PUSH
97415: CALL_OW 45
97419: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97420: LD_VAR 0 12
97424: PPUSH
97425: LD_VAR 0 8
97429: PPUSH
97430: LD_INT 0
97432: PPUSH
97433: CALL 104186 0 3
// end ;
97437: GO 97391
97439: POP
97440: POP
// if horses then
97441: LD_VAR 0 5
97445: IFFALSE 97512
// for i = 1 to horses do
97447: LD_ADDR_VAR 0 11
97451: PUSH
97452: DOUBLE
97453: LD_INT 1
97455: DEC
97456: ST_TO_ADDR
97457: LD_VAR 0 5
97461: PUSH
97462: FOR_TO
97463: IFFALSE 97510
// begin hc_class := 21 ;
97465: LD_ADDR_OWVAR 28
97469: PUSH
97470: LD_INT 21
97472: ST_TO_ADDR
// hc_gallery :=  ;
97473: LD_ADDR_OWVAR 33
97477: PUSH
97478: LD_STRING 
97480: ST_TO_ADDR
// animal := CreateHuman ;
97481: LD_ADDR_VAR 0 12
97485: PUSH
97486: CALL_OW 44
97490: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97491: LD_VAR 0 12
97495: PPUSH
97496: LD_VAR 0 8
97500: PPUSH
97501: LD_INT 0
97503: PPUSH
97504: CALL 104186 0 3
// end ;
97508: GO 97462
97510: POP
97511: POP
// if birds then
97512: LD_VAR 0 1
97516: IFFALSE 97583
// for i = 1 to birds do
97518: LD_ADDR_VAR 0 11
97522: PUSH
97523: DOUBLE
97524: LD_INT 1
97526: DEC
97527: ST_TO_ADDR
97528: LD_VAR 0 1
97532: PUSH
97533: FOR_TO
97534: IFFALSE 97581
// begin hc_class = 18 ;
97536: LD_ADDR_OWVAR 28
97540: PUSH
97541: LD_INT 18
97543: ST_TO_ADDR
// hc_gallery =  ;
97544: LD_ADDR_OWVAR 33
97548: PUSH
97549: LD_STRING 
97551: ST_TO_ADDR
// animal := CreateHuman ;
97552: LD_ADDR_VAR 0 12
97556: PUSH
97557: CALL_OW 44
97561: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97562: LD_VAR 0 12
97566: PPUSH
97567: LD_VAR 0 8
97571: PPUSH
97572: LD_INT 0
97574: PPUSH
97575: CALL 104186 0 3
// end ;
97579: GO 97533
97581: POP
97582: POP
// if tigers then
97583: LD_VAR 0 2
97587: IFFALSE 97671
// for i = 1 to tigers do
97589: LD_ADDR_VAR 0 11
97593: PUSH
97594: DOUBLE
97595: LD_INT 1
97597: DEC
97598: ST_TO_ADDR
97599: LD_VAR 0 2
97603: PUSH
97604: FOR_TO
97605: IFFALSE 97669
// begin hc_class = class_tiger ;
97607: LD_ADDR_OWVAR 28
97611: PUSH
97612: LD_INT 14
97614: ST_TO_ADDR
// hc_gallery =  ;
97615: LD_ADDR_OWVAR 33
97619: PUSH
97620: LD_STRING 
97622: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
97623: LD_ADDR_OWVAR 35
97627: PUSH
97628: LD_INT 7
97630: NEG
97631: PPUSH
97632: LD_INT 7
97634: PPUSH
97635: CALL_OW 12
97639: ST_TO_ADDR
// animal := CreateHuman ;
97640: LD_ADDR_VAR 0 12
97644: PUSH
97645: CALL_OW 44
97649: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97650: LD_VAR 0 12
97654: PPUSH
97655: LD_VAR 0 8
97659: PPUSH
97660: LD_INT 0
97662: PPUSH
97663: CALL 104186 0 3
// end ;
97667: GO 97604
97669: POP
97670: POP
// if apemans then
97671: LD_VAR 0 3
97675: IFFALSE 97798
// for i = 1 to apemans do
97677: LD_ADDR_VAR 0 11
97681: PUSH
97682: DOUBLE
97683: LD_INT 1
97685: DEC
97686: ST_TO_ADDR
97687: LD_VAR 0 3
97691: PUSH
97692: FOR_TO
97693: IFFALSE 97796
// begin hc_class = class_apeman ;
97695: LD_ADDR_OWVAR 28
97699: PUSH
97700: LD_INT 12
97702: ST_TO_ADDR
// hc_gallery =  ;
97703: LD_ADDR_OWVAR 33
97707: PUSH
97708: LD_STRING 
97710: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
97711: LD_ADDR_OWVAR 35
97715: PUSH
97716: LD_INT 5
97718: NEG
97719: PPUSH
97720: LD_INT 5
97722: PPUSH
97723: CALL_OW 12
97727: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
97728: LD_ADDR_OWVAR 31
97732: PUSH
97733: LD_INT 1
97735: PPUSH
97736: LD_INT 3
97738: PPUSH
97739: CALL_OW 12
97743: PUSH
97744: LD_INT 1
97746: PPUSH
97747: LD_INT 3
97749: PPUSH
97750: CALL_OW 12
97754: PUSH
97755: LD_INT 0
97757: PUSH
97758: LD_INT 0
97760: PUSH
97761: EMPTY
97762: LIST
97763: LIST
97764: LIST
97765: LIST
97766: ST_TO_ADDR
// animal := CreateHuman ;
97767: LD_ADDR_VAR 0 12
97771: PUSH
97772: CALL_OW 44
97776: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97777: LD_VAR 0 12
97781: PPUSH
97782: LD_VAR 0 8
97786: PPUSH
97787: LD_INT 0
97789: PPUSH
97790: CALL 104186 0 3
// end ;
97794: GO 97692
97796: POP
97797: POP
// if enchidnas then
97798: LD_VAR 0 4
97802: IFFALSE 97869
// for i = 1 to enchidnas do
97804: LD_ADDR_VAR 0 11
97808: PUSH
97809: DOUBLE
97810: LD_INT 1
97812: DEC
97813: ST_TO_ADDR
97814: LD_VAR 0 4
97818: PUSH
97819: FOR_TO
97820: IFFALSE 97867
// begin hc_class = 13 ;
97822: LD_ADDR_OWVAR 28
97826: PUSH
97827: LD_INT 13
97829: ST_TO_ADDR
// hc_gallery =  ;
97830: LD_ADDR_OWVAR 33
97834: PUSH
97835: LD_STRING 
97837: ST_TO_ADDR
// animal := CreateHuman ;
97838: LD_ADDR_VAR 0 12
97842: PUSH
97843: CALL_OW 44
97847: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
97848: LD_VAR 0 12
97852: PPUSH
97853: LD_VAR 0 8
97857: PPUSH
97858: LD_INT 0
97860: PPUSH
97861: CALL 104186 0 3
// end ;
97865: GO 97819
97867: POP
97868: POP
// if fishes then
97869: LD_VAR 0 7
97873: IFFALSE 97940
// for i = 1 to fishes do
97875: LD_ADDR_VAR 0 11
97879: PUSH
97880: DOUBLE
97881: LD_INT 1
97883: DEC
97884: ST_TO_ADDR
97885: LD_VAR 0 7
97889: PUSH
97890: FOR_TO
97891: IFFALSE 97938
// begin hc_class = 20 ;
97893: LD_ADDR_OWVAR 28
97897: PUSH
97898: LD_INT 20
97900: ST_TO_ADDR
// hc_gallery =  ;
97901: LD_ADDR_OWVAR 33
97905: PUSH
97906: LD_STRING 
97908: ST_TO_ADDR
// animal := CreateHuman ;
97909: LD_ADDR_VAR 0 12
97913: PUSH
97914: CALL_OW 44
97918: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
97919: LD_VAR 0 12
97923: PPUSH
97924: LD_VAR 0 9
97928: PPUSH
97929: LD_INT 0
97931: PPUSH
97932: CALL 104186 0 3
// end ;
97936: GO 97890
97938: POP
97939: POP
// end ;
97940: LD_VAR 0 10
97944: RET
// export function WantHeal ( sci , unit ) ; begin
97945: LD_INT 0
97947: PPUSH
// if GetTaskList ( sci ) > 0 then
97948: LD_VAR 0 1
97952: PPUSH
97953: CALL_OW 437
97957: PUSH
97958: LD_INT 0
97960: GREATER
97961: IFFALSE 98031
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
97963: LD_VAR 0 1
97967: PPUSH
97968: CALL_OW 437
97972: PUSH
97973: LD_INT 1
97975: ARRAY
97976: PUSH
97977: LD_INT 1
97979: ARRAY
97980: PUSH
97981: LD_STRING l
97983: EQUAL
97984: PUSH
97985: LD_VAR 0 1
97989: PPUSH
97990: CALL_OW 437
97994: PUSH
97995: LD_INT 1
97997: ARRAY
97998: PUSH
97999: LD_INT 4
98001: ARRAY
98002: PUSH
98003: LD_VAR 0 2
98007: EQUAL
98008: AND
98009: IFFALSE 98021
// result := true else
98011: LD_ADDR_VAR 0 3
98015: PUSH
98016: LD_INT 1
98018: ST_TO_ADDR
98019: GO 98029
// result := false ;
98021: LD_ADDR_VAR 0 3
98025: PUSH
98026: LD_INT 0
98028: ST_TO_ADDR
// end else
98029: GO 98039
// result := false ;
98031: LD_ADDR_VAR 0 3
98035: PUSH
98036: LD_INT 0
98038: ST_TO_ADDR
// end ;
98039: LD_VAR 0 3
98043: RET
// export function HealTarget ( sci ) ; begin
98044: LD_INT 0
98046: PPUSH
// if not sci then
98047: LD_VAR 0 1
98051: NOT
98052: IFFALSE 98056
// exit ;
98054: GO 98121
// result := 0 ;
98056: LD_ADDR_VAR 0 2
98060: PUSH
98061: LD_INT 0
98063: ST_TO_ADDR
// if GetTaskList ( sci ) then
98064: LD_VAR 0 1
98068: PPUSH
98069: CALL_OW 437
98073: IFFALSE 98121
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
98075: LD_VAR 0 1
98079: PPUSH
98080: CALL_OW 437
98084: PUSH
98085: LD_INT 1
98087: ARRAY
98088: PUSH
98089: LD_INT 1
98091: ARRAY
98092: PUSH
98093: LD_STRING l
98095: EQUAL
98096: IFFALSE 98121
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
98098: LD_ADDR_VAR 0 2
98102: PUSH
98103: LD_VAR 0 1
98107: PPUSH
98108: CALL_OW 437
98112: PUSH
98113: LD_INT 1
98115: ARRAY
98116: PUSH
98117: LD_INT 4
98119: ARRAY
98120: ST_TO_ADDR
// end ;
98121: LD_VAR 0 2
98125: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98126: LD_INT 0
98128: PPUSH
98129: PPUSH
98130: PPUSH
98131: PPUSH
98132: PPUSH
98133: PPUSH
98134: PPUSH
98135: PPUSH
98136: PPUSH
98137: PPUSH
98138: PPUSH
98139: PPUSH
98140: PPUSH
98141: PPUSH
98142: PPUSH
98143: PPUSH
98144: PPUSH
98145: PPUSH
98146: PPUSH
98147: PPUSH
98148: PPUSH
98149: PPUSH
98150: PPUSH
98151: PPUSH
98152: PPUSH
98153: PPUSH
98154: PPUSH
98155: PPUSH
98156: PPUSH
98157: PPUSH
98158: PPUSH
98159: PPUSH
98160: PPUSH
98161: PPUSH
// if not list then
98162: LD_VAR 0 1
98166: NOT
98167: IFFALSE 98171
// exit ;
98169: GO 102797
// base := list [ 1 ] ;
98171: LD_ADDR_VAR 0 3
98175: PUSH
98176: LD_VAR 0 1
98180: PUSH
98181: LD_INT 1
98183: ARRAY
98184: ST_TO_ADDR
// group := list [ 2 ] ;
98185: LD_ADDR_VAR 0 4
98189: PUSH
98190: LD_VAR 0 1
98194: PUSH
98195: LD_INT 2
98197: ARRAY
98198: ST_TO_ADDR
// path := list [ 3 ] ;
98199: LD_ADDR_VAR 0 5
98203: PUSH
98204: LD_VAR 0 1
98208: PUSH
98209: LD_INT 3
98211: ARRAY
98212: ST_TO_ADDR
// flags := list [ 4 ] ;
98213: LD_ADDR_VAR 0 6
98217: PUSH
98218: LD_VAR 0 1
98222: PUSH
98223: LD_INT 4
98225: ARRAY
98226: ST_TO_ADDR
// mined := [ ] ;
98227: LD_ADDR_VAR 0 27
98231: PUSH
98232: EMPTY
98233: ST_TO_ADDR
// bombed := [ ] ;
98234: LD_ADDR_VAR 0 28
98238: PUSH
98239: EMPTY
98240: ST_TO_ADDR
// healers := [ ] ;
98241: LD_ADDR_VAR 0 31
98245: PUSH
98246: EMPTY
98247: ST_TO_ADDR
// to_heal := [ ] ;
98248: LD_ADDR_VAR 0 30
98252: PUSH
98253: EMPTY
98254: ST_TO_ADDR
// repairs := [ ] ;
98255: LD_ADDR_VAR 0 33
98259: PUSH
98260: EMPTY
98261: ST_TO_ADDR
// to_repair := [ ] ;
98262: LD_ADDR_VAR 0 32
98266: PUSH
98267: EMPTY
98268: ST_TO_ADDR
// if not group or not path then
98269: LD_VAR 0 4
98273: NOT
98274: PUSH
98275: LD_VAR 0 5
98279: NOT
98280: OR
98281: IFFALSE 98285
// exit ;
98283: GO 102797
// side := GetSide ( group [ 1 ] ) ;
98285: LD_ADDR_VAR 0 35
98289: PUSH
98290: LD_VAR 0 4
98294: PUSH
98295: LD_INT 1
98297: ARRAY
98298: PPUSH
98299: CALL_OW 255
98303: ST_TO_ADDR
// if flags then
98304: LD_VAR 0 6
98308: IFFALSE 98452
// begin f_ignore_area := flags [ 1 ] ;
98310: LD_ADDR_VAR 0 17
98314: PUSH
98315: LD_VAR 0 6
98319: PUSH
98320: LD_INT 1
98322: ARRAY
98323: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98324: LD_ADDR_VAR 0 18
98328: PUSH
98329: LD_VAR 0 6
98333: PUSH
98334: LD_INT 2
98336: ARRAY
98337: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98338: LD_ADDR_VAR 0 19
98342: PUSH
98343: LD_VAR 0 6
98347: PUSH
98348: LD_INT 3
98350: ARRAY
98351: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
98352: LD_ADDR_VAR 0 20
98356: PUSH
98357: LD_VAR 0 6
98361: PUSH
98362: LD_INT 4
98364: ARRAY
98365: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
98366: LD_ADDR_VAR 0 21
98370: PUSH
98371: LD_VAR 0 6
98375: PUSH
98376: LD_INT 5
98378: ARRAY
98379: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
98380: LD_ADDR_VAR 0 22
98384: PUSH
98385: LD_VAR 0 6
98389: PUSH
98390: LD_INT 6
98392: ARRAY
98393: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
98394: LD_ADDR_VAR 0 23
98398: PUSH
98399: LD_VAR 0 6
98403: PUSH
98404: LD_INT 7
98406: ARRAY
98407: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
98408: LD_ADDR_VAR 0 24
98412: PUSH
98413: LD_VAR 0 6
98417: PUSH
98418: LD_INT 8
98420: ARRAY
98421: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
98422: LD_ADDR_VAR 0 25
98426: PUSH
98427: LD_VAR 0 6
98431: PUSH
98432: LD_INT 9
98434: ARRAY
98435: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
98436: LD_ADDR_VAR 0 26
98440: PUSH
98441: LD_VAR 0 6
98445: PUSH
98446: LD_INT 10
98448: ARRAY
98449: ST_TO_ADDR
// end else
98450: GO 98532
// begin f_ignore_area := false ;
98452: LD_ADDR_VAR 0 17
98456: PUSH
98457: LD_INT 0
98459: ST_TO_ADDR
// f_capture := false ;
98460: LD_ADDR_VAR 0 18
98464: PUSH
98465: LD_INT 0
98467: ST_TO_ADDR
// f_ignore_civ := false ;
98468: LD_ADDR_VAR 0 19
98472: PUSH
98473: LD_INT 0
98475: ST_TO_ADDR
// f_murder := false ;
98476: LD_ADDR_VAR 0 20
98480: PUSH
98481: LD_INT 0
98483: ST_TO_ADDR
// f_mines := false ;
98484: LD_ADDR_VAR 0 21
98488: PUSH
98489: LD_INT 0
98491: ST_TO_ADDR
// f_repair := false ;
98492: LD_ADDR_VAR 0 22
98496: PUSH
98497: LD_INT 0
98499: ST_TO_ADDR
// f_heal := false ;
98500: LD_ADDR_VAR 0 23
98504: PUSH
98505: LD_INT 0
98507: ST_TO_ADDR
// f_spacetime := false ;
98508: LD_ADDR_VAR 0 24
98512: PUSH
98513: LD_INT 0
98515: ST_TO_ADDR
// f_attack_depot := false ;
98516: LD_ADDR_VAR 0 25
98520: PUSH
98521: LD_INT 0
98523: ST_TO_ADDR
// f_crawl := false ;
98524: LD_ADDR_VAR 0 26
98528: PUSH
98529: LD_INT 0
98531: ST_TO_ADDR
// end ; if f_heal then
98532: LD_VAR 0 23
98536: IFFALSE 98563
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
98538: LD_ADDR_VAR 0 31
98542: PUSH
98543: LD_VAR 0 4
98547: PPUSH
98548: LD_INT 25
98550: PUSH
98551: LD_INT 4
98553: PUSH
98554: EMPTY
98555: LIST
98556: LIST
98557: PPUSH
98558: CALL_OW 72
98562: ST_TO_ADDR
// if f_repair then
98563: LD_VAR 0 22
98567: IFFALSE 98594
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
98569: LD_ADDR_VAR 0 33
98573: PUSH
98574: LD_VAR 0 4
98578: PPUSH
98579: LD_INT 25
98581: PUSH
98582: LD_INT 3
98584: PUSH
98585: EMPTY
98586: LIST
98587: LIST
98588: PPUSH
98589: CALL_OW 72
98593: ST_TO_ADDR
// units_path := [ ] ;
98594: LD_ADDR_VAR 0 16
98598: PUSH
98599: EMPTY
98600: ST_TO_ADDR
// for i = 1 to group do
98601: LD_ADDR_VAR 0 7
98605: PUSH
98606: DOUBLE
98607: LD_INT 1
98609: DEC
98610: ST_TO_ADDR
98611: LD_VAR 0 4
98615: PUSH
98616: FOR_TO
98617: IFFALSE 98646
// units_path := Replace ( units_path , i , path ) ;
98619: LD_ADDR_VAR 0 16
98623: PUSH
98624: LD_VAR 0 16
98628: PPUSH
98629: LD_VAR 0 7
98633: PPUSH
98634: LD_VAR 0 5
98638: PPUSH
98639: CALL_OW 1
98643: ST_TO_ADDR
98644: GO 98616
98646: POP
98647: POP
// repeat for i = group downto 1 do
98648: LD_ADDR_VAR 0 7
98652: PUSH
98653: DOUBLE
98654: LD_VAR 0 4
98658: INC
98659: ST_TO_ADDR
98660: LD_INT 1
98662: PUSH
98663: FOR_DOWNTO
98664: IFFALSE 102760
// begin wait ( 5 ) ;
98666: LD_INT 5
98668: PPUSH
98669: CALL_OW 67
// tmp := [ ] ;
98673: LD_ADDR_VAR 0 14
98677: PUSH
98678: EMPTY
98679: ST_TO_ADDR
// attacking := false ;
98680: LD_ADDR_VAR 0 29
98684: PUSH
98685: LD_INT 0
98687: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
98688: LD_VAR 0 4
98692: PUSH
98693: LD_VAR 0 7
98697: ARRAY
98698: PPUSH
98699: CALL_OW 301
98703: PUSH
98704: LD_VAR 0 4
98708: PUSH
98709: LD_VAR 0 7
98713: ARRAY
98714: NOT
98715: OR
98716: IFFALSE 98825
// begin if GetType ( group [ i ] ) = unit_human then
98718: LD_VAR 0 4
98722: PUSH
98723: LD_VAR 0 7
98727: ARRAY
98728: PPUSH
98729: CALL_OW 247
98733: PUSH
98734: LD_INT 1
98736: EQUAL
98737: IFFALSE 98783
// begin to_heal := to_heal diff group [ i ] ;
98739: LD_ADDR_VAR 0 30
98743: PUSH
98744: LD_VAR 0 30
98748: PUSH
98749: LD_VAR 0 4
98753: PUSH
98754: LD_VAR 0 7
98758: ARRAY
98759: DIFF
98760: ST_TO_ADDR
// healers := healers diff group [ i ] ;
98761: LD_ADDR_VAR 0 31
98765: PUSH
98766: LD_VAR 0 31
98770: PUSH
98771: LD_VAR 0 4
98775: PUSH
98776: LD_VAR 0 7
98780: ARRAY
98781: DIFF
98782: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
98783: LD_ADDR_VAR 0 4
98787: PUSH
98788: LD_VAR 0 4
98792: PPUSH
98793: LD_VAR 0 7
98797: PPUSH
98798: CALL_OW 3
98802: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
98803: LD_ADDR_VAR 0 16
98807: PUSH
98808: LD_VAR 0 16
98812: PPUSH
98813: LD_VAR 0 7
98817: PPUSH
98818: CALL_OW 3
98822: ST_TO_ADDR
// continue ;
98823: GO 98663
// end ; if f_repair then
98825: LD_VAR 0 22
98829: IFFALSE 99318
// begin if GetType ( group [ i ] ) = unit_vehicle then
98831: LD_VAR 0 4
98835: PUSH
98836: LD_VAR 0 7
98840: ARRAY
98841: PPUSH
98842: CALL_OW 247
98846: PUSH
98847: LD_INT 2
98849: EQUAL
98850: IFFALSE 99040
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
98852: LD_VAR 0 4
98856: PUSH
98857: LD_VAR 0 7
98861: ARRAY
98862: PPUSH
98863: CALL_OW 256
98867: PUSH
98868: LD_INT 700
98870: LESS
98871: PUSH
98872: LD_VAR 0 4
98876: PUSH
98877: LD_VAR 0 7
98881: ARRAY
98882: PUSH
98883: LD_VAR 0 32
98887: IN
98888: NOT
98889: AND
98890: IFFALSE 98914
// to_repair := to_repair union group [ i ] ;
98892: LD_ADDR_VAR 0 32
98896: PUSH
98897: LD_VAR 0 32
98901: PUSH
98902: LD_VAR 0 4
98906: PUSH
98907: LD_VAR 0 7
98911: ARRAY
98912: UNION
98913: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
98914: LD_VAR 0 4
98918: PUSH
98919: LD_VAR 0 7
98923: ARRAY
98924: PPUSH
98925: CALL_OW 256
98929: PUSH
98930: LD_INT 1000
98932: EQUAL
98933: PUSH
98934: LD_VAR 0 4
98938: PUSH
98939: LD_VAR 0 7
98943: ARRAY
98944: PUSH
98945: LD_VAR 0 32
98949: IN
98950: AND
98951: IFFALSE 98975
// to_repair := to_repair diff group [ i ] ;
98953: LD_ADDR_VAR 0 32
98957: PUSH
98958: LD_VAR 0 32
98962: PUSH
98963: LD_VAR 0 4
98967: PUSH
98968: LD_VAR 0 7
98972: ARRAY
98973: DIFF
98974: ST_TO_ADDR
// if group [ i ] in to_repair then
98975: LD_VAR 0 4
98979: PUSH
98980: LD_VAR 0 7
98984: ARRAY
98985: PUSH
98986: LD_VAR 0 32
98990: IN
98991: IFFALSE 99038
// begin if not IsInArea ( group [ i ] , f_repair ) then
98993: LD_VAR 0 4
98997: PUSH
98998: LD_VAR 0 7
99002: ARRAY
99003: PPUSH
99004: LD_VAR 0 22
99008: PPUSH
99009: CALL_OW 308
99013: NOT
99014: IFFALSE 99036
// ComMoveToArea ( group [ i ] , f_repair ) ;
99016: LD_VAR 0 4
99020: PUSH
99021: LD_VAR 0 7
99025: ARRAY
99026: PPUSH
99027: LD_VAR 0 22
99031: PPUSH
99032: CALL_OW 113
// continue ;
99036: GO 98663
// end ; end else
99038: GO 99318
// if group [ i ] in repairs then
99040: LD_VAR 0 4
99044: PUSH
99045: LD_VAR 0 7
99049: ARRAY
99050: PUSH
99051: LD_VAR 0 33
99055: IN
99056: IFFALSE 99318
// begin if IsInUnit ( group [ i ] ) then
99058: LD_VAR 0 4
99062: PUSH
99063: LD_VAR 0 7
99067: ARRAY
99068: PPUSH
99069: CALL_OW 310
99073: IFFALSE 99141
// begin z := IsInUnit ( group [ i ] ) ;
99075: LD_ADDR_VAR 0 13
99079: PUSH
99080: LD_VAR 0 4
99084: PUSH
99085: LD_VAR 0 7
99089: ARRAY
99090: PPUSH
99091: CALL_OW 310
99095: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99096: LD_VAR 0 13
99100: PUSH
99101: LD_VAR 0 32
99105: IN
99106: PUSH
99107: LD_VAR 0 13
99111: PPUSH
99112: LD_VAR 0 22
99116: PPUSH
99117: CALL_OW 308
99121: AND
99122: IFFALSE 99139
// ComExitVehicle ( group [ i ] ) ;
99124: LD_VAR 0 4
99128: PUSH
99129: LD_VAR 0 7
99133: ARRAY
99134: PPUSH
99135: CALL_OW 121
// end else
99139: GO 99318
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99141: LD_ADDR_VAR 0 13
99145: PUSH
99146: LD_VAR 0 4
99150: PPUSH
99151: LD_INT 95
99153: PUSH
99154: LD_VAR 0 22
99158: PUSH
99159: EMPTY
99160: LIST
99161: LIST
99162: PUSH
99163: LD_INT 58
99165: PUSH
99166: EMPTY
99167: LIST
99168: PUSH
99169: EMPTY
99170: LIST
99171: LIST
99172: PPUSH
99173: CALL_OW 72
99177: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99178: LD_VAR 0 4
99182: PUSH
99183: LD_VAR 0 7
99187: ARRAY
99188: PPUSH
99189: CALL_OW 314
99193: NOT
99194: IFFALSE 99316
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99196: LD_ADDR_VAR 0 10
99200: PUSH
99201: LD_VAR 0 13
99205: PPUSH
99206: LD_VAR 0 4
99210: PUSH
99211: LD_VAR 0 7
99215: ARRAY
99216: PPUSH
99217: CALL_OW 74
99221: ST_TO_ADDR
// if not x then
99222: LD_VAR 0 10
99226: NOT
99227: IFFALSE 99231
// continue ;
99229: GO 98663
// if GetLives ( x ) < 1000 then
99231: LD_VAR 0 10
99235: PPUSH
99236: CALL_OW 256
99240: PUSH
99241: LD_INT 1000
99243: LESS
99244: IFFALSE 99268
// ComRepairVehicle ( group [ i ] , x ) else
99246: LD_VAR 0 4
99250: PUSH
99251: LD_VAR 0 7
99255: ARRAY
99256: PPUSH
99257: LD_VAR 0 10
99261: PPUSH
99262: CALL_OW 129
99266: GO 99316
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99268: LD_VAR 0 23
99272: PUSH
99273: LD_VAR 0 4
99277: PUSH
99278: LD_VAR 0 7
99282: ARRAY
99283: PPUSH
99284: CALL_OW 256
99288: PUSH
99289: LD_INT 1000
99291: LESS
99292: AND
99293: NOT
99294: IFFALSE 99316
// ComEnterUnit ( group [ i ] , x ) ;
99296: LD_VAR 0 4
99300: PUSH
99301: LD_VAR 0 7
99305: ARRAY
99306: PPUSH
99307: LD_VAR 0 10
99311: PPUSH
99312: CALL_OW 120
// end ; continue ;
99316: GO 98663
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99318: LD_VAR 0 23
99322: PUSH
99323: LD_VAR 0 4
99327: PUSH
99328: LD_VAR 0 7
99332: ARRAY
99333: PPUSH
99334: CALL_OW 247
99338: PUSH
99339: LD_INT 1
99341: EQUAL
99342: AND
99343: IFFALSE 99821
// begin if group [ i ] in healers then
99345: LD_VAR 0 4
99349: PUSH
99350: LD_VAR 0 7
99354: ARRAY
99355: PUSH
99356: LD_VAR 0 31
99360: IN
99361: IFFALSE 99634
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
99363: LD_VAR 0 4
99367: PUSH
99368: LD_VAR 0 7
99372: ARRAY
99373: PPUSH
99374: LD_VAR 0 23
99378: PPUSH
99379: CALL_OW 308
99383: NOT
99384: PUSH
99385: LD_VAR 0 4
99389: PUSH
99390: LD_VAR 0 7
99394: ARRAY
99395: PPUSH
99396: CALL_OW 314
99400: NOT
99401: AND
99402: IFFALSE 99426
// ComMoveToArea ( group [ i ] , f_heal ) else
99404: LD_VAR 0 4
99408: PUSH
99409: LD_VAR 0 7
99413: ARRAY
99414: PPUSH
99415: LD_VAR 0 23
99419: PPUSH
99420: CALL_OW 113
99424: GO 99632
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
99426: LD_VAR 0 4
99430: PUSH
99431: LD_VAR 0 7
99435: ARRAY
99436: PPUSH
99437: CALL 98044 0 1
99441: PPUSH
99442: CALL_OW 256
99446: PUSH
99447: LD_INT 1000
99449: EQUAL
99450: IFFALSE 99469
// ComStop ( group [ i ] ) else
99452: LD_VAR 0 4
99456: PUSH
99457: LD_VAR 0 7
99461: ARRAY
99462: PPUSH
99463: CALL_OW 141
99467: GO 99632
// if not HasTask ( group [ i ] ) and to_heal then
99469: LD_VAR 0 4
99473: PUSH
99474: LD_VAR 0 7
99478: ARRAY
99479: PPUSH
99480: CALL_OW 314
99484: NOT
99485: PUSH
99486: LD_VAR 0 30
99490: AND
99491: IFFALSE 99632
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
99493: LD_ADDR_VAR 0 13
99497: PUSH
99498: LD_VAR 0 30
99502: PPUSH
99503: LD_INT 3
99505: PUSH
99506: LD_INT 54
99508: PUSH
99509: EMPTY
99510: LIST
99511: PUSH
99512: EMPTY
99513: LIST
99514: LIST
99515: PPUSH
99516: CALL_OW 72
99520: PPUSH
99521: LD_VAR 0 4
99525: PUSH
99526: LD_VAR 0 7
99530: ARRAY
99531: PPUSH
99532: CALL_OW 74
99536: ST_TO_ADDR
// if z then
99537: LD_VAR 0 13
99541: IFFALSE 99632
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
99543: LD_INT 91
99545: PUSH
99546: LD_VAR 0 13
99550: PUSH
99551: LD_INT 10
99553: PUSH
99554: EMPTY
99555: LIST
99556: LIST
99557: LIST
99558: PUSH
99559: LD_INT 81
99561: PUSH
99562: LD_VAR 0 13
99566: PPUSH
99567: CALL_OW 255
99571: PUSH
99572: EMPTY
99573: LIST
99574: LIST
99575: PUSH
99576: EMPTY
99577: LIST
99578: LIST
99579: PPUSH
99580: CALL_OW 69
99584: PUSH
99585: LD_INT 0
99587: EQUAL
99588: IFFALSE 99612
// ComHeal ( group [ i ] , z ) else
99590: LD_VAR 0 4
99594: PUSH
99595: LD_VAR 0 7
99599: ARRAY
99600: PPUSH
99601: LD_VAR 0 13
99605: PPUSH
99606: CALL_OW 128
99610: GO 99632
// ComMoveToArea ( group [ i ] , f_heal ) ;
99612: LD_VAR 0 4
99616: PUSH
99617: LD_VAR 0 7
99621: ARRAY
99622: PPUSH
99623: LD_VAR 0 23
99627: PPUSH
99628: CALL_OW 113
// end ; continue ;
99632: GO 98663
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
99634: LD_VAR 0 4
99638: PUSH
99639: LD_VAR 0 7
99643: ARRAY
99644: PPUSH
99645: CALL_OW 256
99649: PUSH
99650: LD_INT 700
99652: LESS
99653: PUSH
99654: LD_VAR 0 4
99658: PUSH
99659: LD_VAR 0 7
99663: ARRAY
99664: PUSH
99665: LD_VAR 0 30
99669: IN
99670: NOT
99671: AND
99672: IFFALSE 99696
// to_heal := to_heal union group [ i ] ;
99674: LD_ADDR_VAR 0 30
99678: PUSH
99679: LD_VAR 0 30
99683: PUSH
99684: LD_VAR 0 4
99688: PUSH
99689: LD_VAR 0 7
99693: ARRAY
99694: UNION
99695: ST_TO_ADDR
// if group [ i ] in to_heal then
99696: LD_VAR 0 4
99700: PUSH
99701: LD_VAR 0 7
99705: ARRAY
99706: PUSH
99707: LD_VAR 0 30
99711: IN
99712: IFFALSE 99821
// begin if GetLives ( group [ i ] ) = 1000 then
99714: LD_VAR 0 4
99718: PUSH
99719: LD_VAR 0 7
99723: ARRAY
99724: PPUSH
99725: CALL_OW 256
99729: PUSH
99730: LD_INT 1000
99732: EQUAL
99733: IFFALSE 99759
// to_heal := to_heal diff group [ i ] else
99735: LD_ADDR_VAR 0 30
99739: PUSH
99740: LD_VAR 0 30
99744: PUSH
99745: LD_VAR 0 4
99749: PUSH
99750: LD_VAR 0 7
99754: ARRAY
99755: DIFF
99756: ST_TO_ADDR
99757: GO 99821
// begin if not IsInArea ( group [ i ] , to_heal ) then
99759: LD_VAR 0 4
99763: PUSH
99764: LD_VAR 0 7
99768: ARRAY
99769: PPUSH
99770: LD_VAR 0 30
99774: PPUSH
99775: CALL_OW 308
99779: NOT
99780: IFFALSE 99804
// ComMoveToArea ( group [ i ] , f_heal ) else
99782: LD_VAR 0 4
99786: PUSH
99787: LD_VAR 0 7
99791: ARRAY
99792: PPUSH
99793: LD_VAR 0 23
99797: PPUSH
99798: CALL_OW 113
99802: GO 99819
// ComHold ( group [ i ] ) ;
99804: LD_VAR 0 4
99808: PUSH
99809: LD_VAR 0 7
99813: ARRAY
99814: PPUSH
99815: CALL_OW 140
// continue ;
99819: GO 98663
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
99821: LD_VAR 0 4
99825: PUSH
99826: LD_VAR 0 7
99830: ARRAY
99831: PPUSH
99832: LD_INT 10
99834: PPUSH
99835: CALL 96441 0 2
99839: NOT
99840: PUSH
99841: LD_VAR 0 16
99845: PUSH
99846: LD_VAR 0 7
99850: ARRAY
99851: PUSH
99852: EMPTY
99853: EQUAL
99854: NOT
99855: AND
99856: IFFALSE 100122
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
99858: LD_VAR 0 4
99862: PUSH
99863: LD_VAR 0 7
99867: ARRAY
99868: PPUSH
99869: CALL_OW 262
99873: PUSH
99874: LD_INT 1
99876: PUSH
99877: LD_INT 2
99879: PUSH
99880: EMPTY
99881: LIST
99882: LIST
99883: IN
99884: IFFALSE 99925
// if GetFuel ( group [ i ] ) < 10 then
99886: LD_VAR 0 4
99890: PUSH
99891: LD_VAR 0 7
99895: ARRAY
99896: PPUSH
99897: CALL_OW 261
99901: PUSH
99902: LD_INT 10
99904: LESS
99905: IFFALSE 99925
// SetFuel ( group [ i ] , 12 ) ;
99907: LD_VAR 0 4
99911: PUSH
99912: LD_VAR 0 7
99916: ARRAY
99917: PPUSH
99918: LD_INT 12
99920: PPUSH
99921: CALL_OW 240
// if units_path [ i ] then
99925: LD_VAR 0 16
99929: PUSH
99930: LD_VAR 0 7
99934: ARRAY
99935: IFFALSE 100120
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
99937: LD_VAR 0 4
99941: PUSH
99942: LD_VAR 0 7
99946: ARRAY
99947: PPUSH
99948: LD_VAR 0 16
99952: PUSH
99953: LD_VAR 0 7
99957: ARRAY
99958: PUSH
99959: LD_INT 1
99961: ARRAY
99962: PUSH
99963: LD_INT 1
99965: ARRAY
99966: PPUSH
99967: LD_VAR 0 16
99971: PUSH
99972: LD_VAR 0 7
99976: ARRAY
99977: PUSH
99978: LD_INT 1
99980: ARRAY
99981: PUSH
99982: LD_INT 2
99984: ARRAY
99985: PPUSH
99986: CALL_OW 297
99990: PUSH
99991: LD_INT 6
99993: GREATER
99994: IFFALSE 100069
// begin if not HasTask ( group [ i ] ) then
99996: LD_VAR 0 4
100000: PUSH
100001: LD_VAR 0 7
100005: ARRAY
100006: PPUSH
100007: CALL_OW 314
100011: NOT
100012: IFFALSE 100067
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100014: LD_VAR 0 4
100018: PUSH
100019: LD_VAR 0 7
100023: ARRAY
100024: PPUSH
100025: LD_VAR 0 16
100029: PUSH
100030: LD_VAR 0 7
100034: ARRAY
100035: PUSH
100036: LD_INT 1
100038: ARRAY
100039: PUSH
100040: LD_INT 1
100042: ARRAY
100043: PPUSH
100044: LD_VAR 0 16
100048: PUSH
100049: LD_VAR 0 7
100053: ARRAY
100054: PUSH
100055: LD_INT 1
100057: ARRAY
100058: PUSH
100059: LD_INT 2
100061: ARRAY
100062: PPUSH
100063: CALL_OW 114
// end else
100067: GO 100120
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100069: LD_ADDR_VAR 0 15
100073: PUSH
100074: LD_VAR 0 16
100078: PUSH
100079: LD_VAR 0 7
100083: ARRAY
100084: PPUSH
100085: LD_INT 1
100087: PPUSH
100088: CALL_OW 3
100092: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100093: LD_ADDR_VAR 0 16
100097: PUSH
100098: LD_VAR 0 16
100102: PPUSH
100103: LD_VAR 0 7
100107: PPUSH
100108: LD_VAR 0 15
100112: PPUSH
100113: CALL_OW 1
100117: ST_TO_ADDR
// continue ;
100118: GO 98663
// end ; end ; end else
100120: GO 102758
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100122: LD_ADDR_VAR 0 14
100126: PUSH
100127: LD_INT 81
100129: PUSH
100130: LD_VAR 0 4
100134: PUSH
100135: LD_VAR 0 7
100139: ARRAY
100140: PPUSH
100141: CALL_OW 255
100145: PUSH
100146: EMPTY
100147: LIST
100148: LIST
100149: PPUSH
100150: CALL_OW 69
100154: ST_TO_ADDR
// if not tmp then
100155: LD_VAR 0 14
100159: NOT
100160: IFFALSE 100164
// continue ;
100162: GO 98663
// if f_ignore_area then
100164: LD_VAR 0 17
100168: IFFALSE 100256
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100170: LD_ADDR_VAR 0 15
100174: PUSH
100175: LD_VAR 0 14
100179: PPUSH
100180: LD_INT 3
100182: PUSH
100183: LD_INT 92
100185: PUSH
100186: LD_VAR 0 17
100190: PUSH
100191: LD_INT 1
100193: ARRAY
100194: PUSH
100195: LD_VAR 0 17
100199: PUSH
100200: LD_INT 2
100202: ARRAY
100203: PUSH
100204: LD_VAR 0 17
100208: PUSH
100209: LD_INT 3
100211: ARRAY
100212: PUSH
100213: EMPTY
100214: LIST
100215: LIST
100216: LIST
100217: LIST
100218: PUSH
100219: EMPTY
100220: LIST
100221: LIST
100222: PPUSH
100223: CALL_OW 72
100227: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100228: LD_VAR 0 14
100232: PUSH
100233: LD_VAR 0 15
100237: DIFF
100238: IFFALSE 100256
// tmp := tmp diff tmp2 ;
100240: LD_ADDR_VAR 0 14
100244: PUSH
100245: LD_VAR 0 14
100249: PUSH
100250: LD_VAR 0 15
100254: DIFF
100255: ST_TO_ADDR
// end ; if not f_murder then
100256: LD_VAR 0 20
100260: NOT
100261: IFFALSE 100319
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100263: LD_ADDR_VAR 0 15
100267: PUSH
100268: LD_VAR 0 14
100272: PPUSH
100273: LD_INT 3
100275: PUSH
100276: LD_INT 50
100278: PUSH
100279: EMPTY
100280: LIST
100281: PUSH
100282: EMPTY
100283: LIST
100284: LIST
100285: PPUSH
100286: CALL_OW 72
100290: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100291: LD_VAR 0 14
100295: PUSH
100296: LD_VAR 0 15
100300: DIFF
100301: IFFALSE 100319
// tmp := tmp diff tmp2 ;
100303: LD_ADDR_VAR 0 14
100307: PUSH
100308: LD_VAR 0 14
100312: PUSH
100313: LD_VAR 0 15
100317: DIFF
100318: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100319: LD_ADDR_VAR 0 14
100323: PUSH
100324: LD_VAR 0 4
100328: PUSH
100329: LD_VAR 0 7
100333: ARRAY
100334: PPUSH
100335: LD_VAR 0 14
100339: PPUSH
100340: LD_INT 1
100342: PPUSH
100343: LD_INT 1
100345: PPUSH
100346: CALL 70084 0 4
100350: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
100351: LD_VAR 0 4
100355: PUSH
100356: LD_VAR 0 7
100360: ARRAY
100361: PPUSH
100362: CALL_OW 257
100366: PUSH
100367: LD_INT 1
100369: EQUAL
100370: IFFALSE 100818
// begin if WantPlant ( group [ i ] ) then
100372: LD_VAR 0 4
100376: PUSH
100377: LD_VAR 0 7
100381: ARRAY
100382: PPUSH
100383: CALL 69585 0 1
100387: IFFALSE 100391
// continue ;
100389: GO 98663
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
100391: LD_VAR 0 18
100395: PUSH
100396: LD_VAR 0 4
100400: PUSH
100401: LD_VAR 0 7
100405: ARRAY
100406: PPUSH
100407: CALL_OW 310
100411: NOT
100412: AND
100413: PUSH
100414: LD_VAR 0 14
100418: PUSH
100419: LD_INT 1
100421: ARRAY
100422: PUSH
100423: LD_VAR 0 14
100427: PPUSH
100428: LD_INT 21
100430: PUSH
100431: LD_INT 2
100433: PUSH
100434: EMPTY
100435: LIST
100436: LIST
100437: PUSH
100438: LD_INT 58
100440: PUSH
100441: EMPTY
100442: LIST
100443: PUSH
100444: EMPTY
100445: LIST
100446: LIST
100447: PPUSH
100448: CALL_OW 72
100452: IN
100453: AND
100454: IFFALSE 100490
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
100456: LD_VAR 0 4
100460: PUSH
100461: LD_VAR 0 7
100465: ARRAY
100466: PPUSH
100467: LD_VAR 0 14
100471: PUSH
100472: LD_INT 1
100474: ARRAY
100475: PPUSH
100476: CALL_OW 120
// attacking := true ;
100480: LD_ADDR_VAR 0 29
100484: PUSH
100485: LD_INT 1
100487: ST_TO_ADDR
// continue ;
100488: GO 98663
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
100490: LD_VAR 0 26
100494: PUSH
100495: LD_VAR 0 4
100499: PUSH
100500: LD_VAR 0 7
100504: ARRAY
100505: PPUSH
100506: CALL_OW 257
100510: PUSH
100511: LD_INT 1
100513: EQUAL
100514: AND
100515: PUSH
100516: LD_VAR 0 4
100520: PUSH
100521: LD_VAR 0 7
100525: ARRAY
100526: PPUSH
100527: CALL_OW 256
100531: PUSH
100532: LD_INT 800
100534: LESS
100535: AND
100536: PUSH
100537: LD_VAR 0 4
100541: PUSH
100542: LD_VAR 0 7
100546: ARRAY
100547: PPUSH
100548: CALL_OW 318
100552: NOT
100553: AND
100554: IFFALSE 100571
// ComCrawl ( group [ i ] ) ;
100556: LD_VAR 0 4
100560: PUSH
100561: LD_VAR 0 7
100565: ARRAY
100566: PPUSH
100567: CALL_OW 137
// if f_mines then
100571: LD_VAR 0 21
100575: IFFALSE 100818
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
100577: LD_VAR 0 14
100581: PUSH
100582: LD_INT 1
100584: ARRAY
100585: PPUSH
100586: CALL_OW 247
100590: PUSH
100591: LD_INT 3
100593: EQUAL
100594: PUSH
100595: LD_VAR 0 14
100599: PUSH
100600: LD_INT 1
100602: ARRAY
100603: PUSH
100604: LD_VAR 0 27
100608: IN
100609: NOT
100610: AND
100611: IFFALSE 100818
// begin x := GetX ( tmp [ 1 ] ) ;
100613: LD_ADDR_VAR 0 10
100617: PUSH
100618: LD_VAR 0 14
100622: PUSH
100623: LD_INT 1
100625: ARRAY
100626: PPUSH
100627: CALL_OW 250
100631: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
100632: LD_ADDR_VAR 0 11
100636: PUSH
100637: LD_VAR 0 14
100641: PUSH
100642: LD_INT 1
100644: ARRAY
100645: PPUSH
100646: CALL_OW 251
100650: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
100651: LD_ADDR_VAR 0 12
100655: PUSH
100656: LD_VAR 0 4
100660: PUSH
100661: LD_VAR 0 7
100665: ARRAY
100666: PPUSH
100667: CALL 96526 0 1
100671: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
100672: LD_VAR 0 4
100676: PUSH
100677: LD_VAR 0 7
100681: ARRAY
100682: PPUSH
100683: LD_VAR 0 10
100687: PPUSH
100688: LD_VAR 0 11
100692: PPUSH
100693: LD_VAR 0 14
100697: PUSH
100698: LD_INT 1
100700: ARRAY
100701: PPUSH
100702: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
100706: LD_VAR 0 4
100710: PUSH
100711: LD_VAR 0 7
100715: ARRAY
100716: PPUSH
100717: LD_VAR 0 10
100721: PPUSH
100722: LD_VAR 0 12
100726: PPUSH
100727: LD_INT 7
100729: PPUSH
100730: CALL_OW 272
100734: PPUSH
100735: LD_VAR 0 11
100739: PPUSH
100740: LD_VAR 0 12
100744: PPUSH
100745: LD_INT 7
100747: PPUSH
100748: CALL_OW 273
100752: PPUSH
100753: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
100757: LD_VAR 0 4
100761: PUSH
100762: LD_VAR 0 7
100766: ARRAY
100767: PPUSH
100768: LD_INT 71
100770: PPUSH
100771: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
100775: LD_ADDR_VAR 0 27
100779: PUSH
100780: LD_VAR 0 27
100784: PPUSH
100785: LD_VAR 0 27
100789: PUSH
100790: LD_INT 1
100792: PLUS
100793: PPUSH
100794: LD_VAR 0 14
100798: PUSH
100799: LD_INT 1
100801: ARRAY
100802: PPUSH
100803: CALL_OW 1
100807: ST_TO_ADDR
// attacking := true ;
100808: LD_ADDR_VAR 0 29
100812: PUSH
100813: LD_INT 1
100815: ST_TO_ADDR
// continue ;
100816: GO 98663
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
100818: LD_VAR 0 4
100822: PUSH
100823: LD_VAR 0 7
100827: ARRAY
100828: PPUSH
100829: CALL_OW 257
100833: PUSH
100834: LD_INT 17
100836: EQUAL
100837: PUSH
100838: LD_VAR 0 4
100842: PUSH
100843: LD_VAR 0 7
100847: ARRAY
100848: PPUSH
100849: CALL_OW 110
100853: PUSH
100854: LD_INT 71
100856: EQUAL
100857: NOT
100858: AND
100859: IFFALSE 101005
// begin attacking := false ;
100861: LD_ADDR_VAR 0 29
100865: PUSH
100866: LD_INT 0
100868: ST_TO_ADDR
// k := 5 ;
100869: LD_ADDR_VAR 0 9
100873: PUSH
100874: LD_INT 5
100876: ST_TO_ADDR
// if tmp < k then
100877: LD_VAR 0 14
100881: PUSH
100882: LD_VAR 0 9
100886: LESS
100887: IFFALSE 100899
// k := tmp ;
100889: LD_ADDR_VAR 0 9
100893: PUSH
100894: LD_VAR 0 14
100898: ST_TO_ADDR
// for j = 1 to k do
100899: LD_ADDR_VAR 0 8
100903: PUSH
100904: DOUBLE
100905: LD_INT 1
100907: DEC
100908: ST_TO_ADDR
100909: LD_VAR 0 9
100913: PUSH
100914: FOR_TO
100915: IFFALSE 101003
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
100917: LD_VAR 0 14
100921: PUSH
100922: LD_VAR 0 8
100926: ARRAY
100927: PUSH
100928: LD_VAR 0 14
100932: PPUSH
100933: LD_INT 58
100935: PUSH
100936: EMPTY
100937: LIST
100938: PPUSH
100939: CALL_OW 72
100943: IN
100944: NOT
100945: IFFALSE 101001
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
100947: LD_VAR 0 4
100951: PUSH
100952: LD_VAR 0 7
100956: ARRAY
100957: PPUSH
100958: LD_VAR 0 14
100962: PUSH
100963: LD_VAR 0 8
100967: ARRAY
100968: PPUSH
100969: CALL_OW 115
// attacking := true ;
100973: LD_ADDR_VAR 0 29
100977: PUSH
100978: LD_INT 1
100980: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
100981: LD_VAR 0 4
100985: PUSH
100986: LD_VAR 0 7
100990: ARRAY
100991: PPUSH
100992: LD_INT 71
100994: PPUSH
100995: CALL_OW 109
// continue ;
100999: GO 100914
// end ; end ;
101001: GO 100914
101003: POP
101004: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101005: LD_VAR 0 4
101009: PUSH
101010: LD_VAR 0 7
101014: ARRAY
101015: PPUSH
101016: CALL_OW 257
101020: PUSH
101021: LD_INT 8
101023: EQUAL
101024: PUSH
101025: LD_VAR 0 4
101029: PUSH
101030: LD_VAR 0 7
101034: ARRAY
101035: PPUSH
101036: CALL_OW 264
101040: PUSH
101041: LD_INT 28
101043: PUSH
101044: LD_INT 45
101046: PUSH
101047: LD_INT 7
101049: PUSH
101050: LD_INT 47
101052: PUSH
101053: EMPTY
101054: LIST
101055: LIST
101056: LIST
101057: LIST
101058: IN
101059: OR
101060: IFFALSE 101290
// begin attacking := false ;
101062: LD_ADDR_VAR 0 29
101066: PUSH
101067: LD_INT 0
101069: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101070: LD_VAR 0 14
101074: PUSH
101075: LD_INT 1
101077: ARRAY
101078: PPUSH
101079: CALL_OW 266
101083: PUSH
101084: LD_INT 32
101086: PUSH
101087: LD_INT 31
101089: PUSH
101090: LD_INT 33
101092: PUSH
101093: LD_INT 4
101095: PUSH
101096: LD_INT 5
101098: PUSH
101099: EMPTY
101100: LIST
101101: LIST
101102: LIST
101103: LIST
101104: LIST
101105: IN
101106: IFFALSE 101290
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101108: LD_ADDR_VAR 0 9
101112: PUSH
101113: LD_VAR 0 14
101117: PUSH
101118: LD_INT 1
101120: ARRAY
101121: PPUSH
101122: CALL_OW 266
101126: PPUSH
101127: LD_VAR 0 14
101131: PUSH
101132: LD_INT 1
101134: ARRAY
101135: PPUSH
101136: CALL_OW 250
101140: PPUSH
101141: LD_VAR 0 14
101145: PUSH
101146: LD_INT 1
101148: ARRAY
101149: PPUSH
101150: CALL_OW 251
101154: PPUSH
101155: LD_VAR 0 14
101159: PUSH
101160: LD_INT 1
101162: ARRAY
101163: PPUSH
101164: CALL_OW 254
101168: PPUSH
101169: LD_VAR 0 14
101173: PUSH
101174: LD_INT 1
101176: ARRAY
101177: PPUSH
101178: CALL_OW 248
101182: PPUSH
101183: LD_INT 0
101185: PPUSH
101186: CALL 77896 0 6
101190: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101191: LD_ADDR_VAR 0 8
101195: PUSH
101196: LD_VAR 0 4
101200: PUSH
101201: LD_VAR 0 7
101205: ARRAY
101206: PPUSH
101207: LD_VAR 0 9
101211: PPUSH
101212: CALL 96589 0 2
101216: ST_TO_ADDR
// if j then
101217: LD_VAR 0 8
101221: IFFALSE 101290
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101223: LD_VAR 0 8
101227: PUSH
101228: LD_INT 1
101230: ARRAY
101231: PPUSH
101232: LD_VAR 0 8
101236: PUSH
101237: LD_INT 2
101239: ARRAY
101240: PPUSH
101241: CALL_OW 488
101245: IFFALSE 101290
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101247: LD_VAR 0 4
101251: PUSH
101252: LD_VAR 0 7
101256: ARRAY
101257: PPUSH
101258: LD_VAR 0 8
101262: PUSH
101263: LD_INT 1
101265: ARRAY
101266: PPUSH
101267: LD_VAR 0 8
101271: PUSH
101272: LD_INT 2
101274: ARRAY
101275: PPUSH
101276: CALL_OW 116
// attacking := true ;
101280: LD_ADDR_VAR 0 29
101284: PUSH
101285: LD_INT 1
101287: ST_TO_ADDR
// continue ;
101288: GO 98663
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101290: LD_VAR 0 4
101294: PUSH
101295: LD_VAR 0 7
101299: ARRAY
101300: PPUSH
101301: CALL_OW 265
101305: PUSH
101306: LD_INT 11
101308: EQUAL
101309: IFFALSE 101587
// begin k := 10 ;
101311: LD_ADDR_VAR 0 9
101315: PUSH
101316: LD_INT 10
101318: ST_TO_ADDR
// x := 0 ;
101319: LD_ADDR_VAR 0 10
101323: PUSH
101324: LD_INT 0
101326: ST_TO_ADDR
// if tmp < k then
101327: LD_VAR 0 14
101331: PUSH
101332: LD_VAR 0 9
101336: LESS
101337: IFFALSE 101349
// k := tmp ;
101339: LD_ADDR_VAR 0 9
101343: PUSH
101344: LD_VAR 0 14
101348: ST_TO_ADDR
// for j = k downto 1 do
101349: LD_ADDR_VAR 0 8
101353: PUSH
101354: DOUBLE
101355: LD_VAR 0 9
101359: INC
101360: ST_TO_ADDR
101361: LD_INT 1
101363: PUSH
101364: FOR_DOWNTO
101365: IFFALSE 101440
// begin if GetType ( tmp [ j ] ) = unit_human then
101367: LD_VAR 0 14
101371: PUSH
101372: LD_VAR 0 8
101376: ARRAY
101377: PPUSH
101378: CALL_OW 247
101382: PUSH
101383: LD_INT 1
101385: EQUAL
101386: IFFALSE 101438
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
101388: LD_VAR 0 4
101392: PUSH
101393: LD_VAR 0 7
101397: ARRAY
101398: PPUSH
101399: LD_VAR 0 14
101403: PUSH
101404: LD_VAR 0 8
101408: ARRAY
101409: PPUSH
101410: CALL 96860 0 2
// x := tmp [ j ] ;
101414: LD_ADDR_VAR 0 10
101418: PUSH
101419: LD_VAR 0 14
101423: PUSH
101424: LD_VAR 0 8
101428: ARRAY
101429: ST_TO_ADDR
// attacking := true ;
101430: LD_ADDR_VAR 0 29
101434: PUSH
101435: LD_INT 1
101437: ST_TO_ADDR
// end ; end ;
101438: GO 101364
101440: POP
101441: POP
// if not x then
101442: LD_VAR 0 10
101446: NOT
101447: IFFALSE 101587
// begin attacking := true ;
101449: LD_ADDR_VAR 0 29
101453: PUSH
101454: LD_INT 1
101456: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
101457: LD_VAR 0 4
101461: PUSH
101462: LD_VAR 0 7
101466: ARRAY
101467: PPUSH
101468: CALL_OW 250
101472: PPUSH
101473: LD_VAR 0 4
101477: PUSH
101478: LD_VAR 0 7
101482: ARRAY
101483: PPUSH
101484: CALL_OW 251
101488: PPUSH
101489: CALL_OW 546
101493: PUSH
101494: LD_INT 2
101496: ARRAY
101497: PUSH
101498: LD_VAR 0 14
101502: PUSH
101503: LD_INT 1
101505: ARRAY
101506: PPUSH
101507: CALL_OW 250
101511: PPUSH
101512: LD_VAR 0 14
101516: PUSH
101517: LD_INT 1
101519: ARRAY
101520: PPUSH
101521: CALL_OW 251
101525: PPUSH
101526: CALL_OW 546
101530: PUSH
101531: LD_INT 2
101533: ARRAY
101534: EQUAL
101535: IFFALSE 101563
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
101537: LD_VAR 0 4
101541: PUSH
101542: LD_VAR 0 7
101546: ARRAY
101547: PPUSH
101548: LD_VAR 0 14
101552: PUSH
101553: LD_INT 1
101555: ARRAY
101556: PPUSH
101557: CALL 96860 0 2
101561: GO 101587
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101563: LD_VAR 0 4
101567: PUSH
101568: LD_VAR 0 7
101572: ARRAY
101573: PPUSH
101574: LD_VAR 0 14
101578: PUSH
101579: LD_INT 1
101581: ARRAY
101582: PPUSH
101583: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
101587: LD_VAR 0 4
101591: PUSH
101592: LD_VAR 0 7
101596: ARRAY
101597: PPUSH
101598: CALL_OW 264
101602: PUSH
101603: LD_INT 29
101605: EQUAL
101606: IFFALSE 101972
// begin if WantsToAttack ( group [ i ] ) in bombed then
101608: LD_VAR 0 4
101612: PUSH
101613: LD_VAR 0 7
101617: ARRAY
101618: PPUSH
101619: CALL_OW 319
101623: PUSH
101624: LD_VAR 0 28
101628: IN
101629: IFFALSE 101633
// continue ;
101631: GO 98663
// k := 8 ;
101633: LD_ADDR_VAR 0 9
101637: PUSH
101638: LD_INT 8
101640: ST_TO_ADDR
// x := 0 ;
101641: LD_ADDR_VAR 0 10
101645: PUSH
101646: LD_INT 0
101648: ST_TO_ADDR
// if tmp < k then
101649: LD_VAR 0 14
101653: PUSH
101654: LD_VAR 0 9
101658: LESS
101659: IFFALSE 101671
// k := tmp ;
101661: LD_ADDR_VAR 0 9
101665: PUSH
101666: LD_VAR 0 14
101670: ST_TO_ADDR
// for j = 1 to k do
101671: LD_ADDR_VAR 0 8
101675: PUSH
101676: DOUBLE
101677: LD_INT 1
101679: DEC
101680: ST_TO_ADDR
101681: LD_VAR 0 9
101685: PUSH
101686: FOR_TO
101687: IFFALSE 101819
// begin if GetType ( tmp [ j ] ) = unit_building then
101689: LD_VAR 0 14
101693: PUSH
101694: LD_VAR 0 8
101698: ARRAY
101699: PPUSH
101700: CALL_OW 247
101704: PUSH
101705: LD_INT 3
101707: EQUAL
101708: IFFALSE 101817
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
101710: LD_VAR 0 14
101714: PUSH
101715: LD_VAR 0 8
101719: ARRAY
101720: PUSH
101721: LD_VAR 0 28
101725: IN
101726: NOT
101727: PUSH
101728: LD_VAR 0 14
101732: PUSH
101733: LD_VAR 0 8
101737: ARRAY
101738: PPUSH
101739: CALL_OW 313
101743: AND
101744: IFFALSE 101817
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101746: LD_VAR 0 4
101750: PUSH
101751: LD_VAR 0 7
101755: ARRAY
101756: PPUSH
101757: LD_VAR 0 14
101761: PUSH
101762: LD_VAR 0 8
101766: ARRAY
101767: PPUSH
101768: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
101772: LD_ADDR_VAR 0 28
101776: PUSH
101777: LD_VAR 0 28
101781: PPUSH
101782: LD_VAR 0 28
101786: PUSH
101787: LD_INT 1
101789: PLUS
101790: PPUSH
101791: LD_VAR 0 14
101795: PUSH
101796: LD_VAR 0 8
101800: ARRAY
101801: PPUSH
101802: CALL_OW 1
101806: ST_TO_ADDR
// attacking := true ;
101807: LD_ADDR_VAR 0 29
101811: PUSH
101812: LD_INT 1
101814: ST_TO_ADDR
// break ;
101815: GO 101819
// end ; end ;
101817: GO 101686
101819: POP
101820: POP
// if not attacking and f_attack_depot then
101821: LD_VAR 0 29
101825: NOT
101826: PUSH
101827: LD_VAR 0 25
101831: AND
101832: IFFALSE 101927
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101834: LD_ADDR_VAR 0 13
101838: PUSH
101839: LD_VAR 0 14
101843: PPUSH
101844: LD_INT 2
101846: PUSH
101847: LD_INT 30
101849: PUSH
101850: LD_INT 0
101852: PUSH
101853: EMPTY
101854: LIST
101855: LIST
101856: PUSH
101857: LD_INT 30
101859: PUSH
101860: LD_INT 1
101862: PUSH
101863: EMPTY
101864: LIST
101865: LIST
101866: PUSH
101867: EMPTY
101868: LIST
101869: LIST
101870: LIST
101871: PPUSH
101872: CALL_OW 72
101876: ST_TO_ADDR
// if z then
101877: LD_VAR 0 13
101881: IFFALSE 101927
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
101883: LD_VAR 0 4
101887: PUSH
101888: LD_VAR 0 7
101892: ARRAY
101893: PPUSH
101894: LD_VAR 0 13
101898: PPUSH
101899: LD_VAR 0 4
101903: PUSH
101904: LD_VAR 0 7
101908: ARRAY
101909: PPUSH
101910: CALL_OW 74
101914: PPUSH
101915: CALL_OW 115
// attacking := true ;
101919: LD_ADDR_VAR 0 29
101923: PUSH
101924: LD_INT 1
101926: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
101927: LD_VAR 0 4
101931: PUSH
101932: LD_VAR 0 7
101936: ARRAY
101937: PPUSH
101938: CALL_OW 256
101942: PUSH
101943: LD_INT 500
101945: LESS
101946: IFFALSE 101972
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101948: LD_VAR 0 4
101952: PUSH
101953: LD_VAR 0 7
101957: ARRAY
101958: PPUSH
101959: LD_VAR 0 14
101963: PUSH
101964: LD_INT 1
101966: ARRAY
101967: PPUSH
101968: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
101972: LD_VAR 0 4
101976: PUSH
101977: LD_VAR 0 7
101981: ARRAY
101982: PPUSH
101983: CALL_OW 264
101987: PUSH
101988: LD_INT 49
101990: EQUAL
101991: IFFALSE 102112
// begin if not HasTask ( group [ i ] ) then
101993: LD_VAR 0 4
101997: PUSH
101998: LD_VAR 0 7
102002: ARRAY
102003: PPUSH
102004: CALL_OW 314
102008: NOT
102009: IFFALSE 102112
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102011: LD_ADDR_VAR 0 9
102015: PUSH
102016: LD_INT 81
102018: PUSH
102019: LD_VAR 0 4
102023: PUSH
102024: LD_VAR 0 7
102028: ARRAY
102029: PPUSH
102030: CALL_OW 255
102034: PUSH
102035: EMPTY
102036: LIST
102037: LIST
102038: PPUSH
102039: CALL_OW 69
102043: PPUSH
102044: LD_VAR 0 4
102048: PUSH
102049: LD_VAR 0 7
102053: ARRAY
102054: PPUSH
102055: CALL_OW 74
102059: ST_TO_ADDR
// if k then
102060: LD_VAR 0 9
102064: IFFALSE 102112
// if GetDistUnits ( group [ i ] , k ) > 10 then
102066: LD_VAR 0 4
102070: PUSH
102071: LD_VAR 0 7
102075: ARRAY
102076: PPUSH
102077: LD_VAR 0 9
102081: PPUSH
102082: CALL_OW 296
102086: PUSH
102087: LD_INT 10
102089: GREATER
102090: IFFALSE 102112
// ComMoveUnit ( group [ i ] , k ) ;
102092: LD_VAR 0 4
102096: PUSH
102097: LD_VAR 0 7
102101: ARRAY
102102: PPUSH
102103: LD_VAR 0 9
102107: PPUSH
102108: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102112: LD_VAR 0 4
102116: PUSH
102117: LD_VAR 0 7
102121: ARRAY
102122: PPUSH
102123: CALL_OW 256
102127: PUSH
102128: LD_INT 250
102130: LESS
102131: PUSH
102132: LD_VAR 0 4
102136: PUSH
102137: LD_VAR 0 7
102141: ARRAY
102142: PUSH
102143: LD_INT 21
102145: PUSH
102146: LD_INT 2
102148: PUSH
102149: EMPTY
102150: LIST
102151: LIST
102152: PUSH
102153: LD_INT 23
102155: PUSH
102156: LD_INT 2
102158: PUSH
102159: EMPTY
102160: LIST
102161: LIST
102162: PUSH
102163: EMPTY
102164: LIST
102165: LIST
102166: PPUSH
102167: CALL_OW 69
102171: IN
102172: AND
102173: IFFALSE 102298
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102175: LD_ADDR_VAR 0 9
102179: PUSH
102180: LD_OWVAR 3
102184: PUSH
102185: LD_VAR 0 4
102189: PUSH
102190: LD_VAR 0 7
102194: ARRAY
102195: DIFF
102196: PPUSH
102197: LD_VAR 0 4
102201: PUSH
102202: LD_VAR 0 7
102206: ARRAY
102207: PPUSH
102208: CALL_OW 74
102212: ST_TO_ADDR
// if not k then
102213: LD_VAR 0 9
102217: NOT
102218: IFFALSE 102222
// continue ;
102220: GO 98663
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102222: LD_VAR 0 9
102226: PUSH
102227: LD_INT 81
102229: PUSH
102230: LD_VAR 0 4
102234: PUSH
102235: LD_VAR 0 7
102239: ARRAY
102240: PPUSH
102241: CALL_OW 255
102245: PUSH
102246: EMPTY
102247: LIST
102248: LIST
102249: PPUSH
102250: CALL_OW 69
102254: IN
102255: PUSH
102256: LD_VAR 0 9
102260: PPUSH
102261: LD_VAR 0 4
102265: PUSH
102266: LD_VAR 0 7
102270: ARRAY
102271: PPUSH
102272: CALL_OW 296
102276: PUSH
102277: LD_INT 5
102279: LESS
102280: AND
102281: IFFALSE 102298
// ComAutodestruct ( group [ i ] ) ;
102283: LD_VAR 0 4
102287: PUSH
102288: LD_VAR 0 7
102292: ARRAY
102293: PPUSH
102294: CALL 96758 0 1
// end ; if f_attack_depot then
102298: LD_VAR 0 25
102302: IFFALSE 102414
// begin k := 6 ;
102304: LD_ADDR_VAR 0 9
102308: PUSH
102309: LD_INT 6
102311: ST_TO_ADDR
// if tmp < k then
102312: LD_VAR 0 14
102316: PUSH
102317: LD_VAR 0 9
102321: LESS
102322: IFFALSE 102334
// k := tmp ;
102324: LD_ADDR_VAR 0 9
102328: PUSH
102329: LD_VAR 0 14
102333: ST_TO_ADDR
// for j = 1 to k do
102334: LD_ADDR_VAR 0 8
102338: PUSH
102339: DOUBLE
102340: LD_INT 1
102342: DEC
102343: ST_TO_ADDR
102344: LD_VAR 0 9
102348: PUSH
102349: FOR_TO
102350: IFFALSE 102412
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
102352: LD_VAR 0 8
102356: PPUSH
102357: CALL_OW 266
102361: PUSH
102362: LD_INT 0
102364: PUSH
102365: LD_INT 1
102367: PUSH
102368: EMPTY
102369: LIST
102370: LIST
102371: IN
102372: IFFALSE 102410
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102374: LD_VAR 0 4
102378: PUSH
102379: LD_VAR 0 7
102383: ARRAY
102384: PPUSH
102385: LD_VAR 0 14
102389: PUSH
102390: LD_VAR 0 8
102394: ARRAY
102395: PPUSH
102396: CALL_OW 115
// attacking := true ;
102400: LD_ADDR_VAR 0 29
102404: PUSH
102405: LD_INT 1
102407: ST_TO_ADDR
// break ;
102408: GO 102412
// end ;
102410: GO 102349
102412: POP
102413: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
102414: LD_VAR 0 4
102418: PUSH
102419: LD_VAR 0 7
102423: ARRAY
102424: PPUSH
102425: CALL_OW 302
102429: PUSH
102430: LD_VAR 0 29
102434: NOT
102435: AND
102436: IFFALSE 102758
// begin if GetTag ( group [ i ] ) = 71 then
102438: LD_VAR 0 4
102442: PUSH
102443: LD_VAR 0 7
102447: ARRAY
102448: PPUSH
102449: CALL_OW 110
102453: PUSH
102454: LD_INT 71
102456: EQUAL
102457: IFFALSE 102498
// begin if HasTask ( group [ i ] ) then
102459: LD_VAR 0 4
102463: PUSH
102464: LD_VAR 0 7
102468: ARRAY
102469: PPUSH
102470: CALL_OW 314
102474: IFFALSE 102480
// continue else
102476: GO 98663
102478: GO 102498
// SetTag ( group [ i ] , 0 ) ;
102480: LD_VAR 0 4
102484: PUSH
102485: LD_VAR 0 7
102489: ARRAY
102490: PPUSH
102491: LD_INT 0
102493: PPUSH
102494: CALL_OW 109
// end ; k := 8 ;
102498: LD_ADDR_VAR 0 9
102502: PUSH
102503: LD_INT 8
102505: ST_TO_ADDR
// x := 0 ;
102506: LD_ADDR_VAR 0 10
102510: PUSH
102511: LD_INT 0
102513: ST_TO_ADDR
// if tmp < k then
102514: LD_VAR 0 14
102518: PUSH
102519: LD_VAR 0 9
102523: LESS
102524: IFFALSE 102536
// k := tmp ;
102526: LD_ADDR_VAR 0 9
102530: PUSH
102531: LD_VAR 0 14
102535: ST_TO_ADDR
// for j = 1 to k do
102536: LD_ADDR_VAR 0 8
102540: PUSH
102541: DOUBLE
102542: LD_INT 1
102544: DEC
102545: ST_TO_ADDR
102546: LD_VAR 0 9
102550: PUSH
102551: FOR_TO
102552: IFFALSE 102650
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
102554: LD_VAR 0 14
102558: PUSH
102559: LD_VAR 0 8
102563: ARRAY
102564: PPUSH
102565: CALL_OW 247
102569: PUSH
102570: LD_INT 1
102572: EQUAL
102573: PUSH
102574: LD_VAR 0 14
102578: PUSH
102579: LD_VAR 0 8
102583: ARRAY
102584: PPUSH
102585: CALL_OW 256
102589: PUSH
102590: LD_INT 250
102592: LESS
102593: PUSH
102594: LD_VAR 0 20
102598: AND
102599: PUSH
102600: LD_VAR 0 20
102604: NOT
102605: PUSH
102606: LD_VAR 0 14
102610: PUSH
102611: LD_VAR 0 8
102615: ARRAY
102616: PPUSH
102617: CALL_OW 256
102621: PUSH
102622: LD_INT 250
102624: GREATEREQUAL
102625: AND
102626: OR
102627: AND
102628: IFFALSE 102648
// begin x := tmp [ j ] ;
102630: LD_ADDR_VAR 0 10
102634: PUSH
102635: LD_VAR 0 14
102639: PUSH
102640: LD_VAR 0 8
102644: ARRAY
102645: ST_TO_ADDR
// break ;
102646: GO 102650
// end ;
102648: GO 102551
102650: POP
102651: POP
// if x then
102652: LD_VAR 0 10
102656: IFFALSE 102680
// ComAttackUnit ( group [ i ] , x ) else
102658: LD_VAR 0 4
102662: PUSH
102663: LD_VAR 0 7
102667: ARRAY
102668: PPUSH
102669: LD_VAR 0 10
102673: PPUSH
102674: CALL_OW 115
102678: GO 102704
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102680: LD_VAR 0 4
102684: PUSH
102685: LD_VAR 0 7
102689: ARRAY
102690: PPUSH
102691: LD_VAR 0 14
102695: PUSH
102696: LD_INT 1
102698: ARRAY
102699: PPUSH
102700: CALL_OW 115
// if not HasTask ( group [ i ] ) then
102704: LD_VAR 0 4
102708: PUSH
102709: LD_VAR 0 7
102713: ARRAY
102714: PPUSH
102715: CALL_OW 314
102719: NOT
102720: IFFALSE 102758
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
102722: LD_VAR 0 4
102726: PUSH
102727: LD_VAR 0 7
102731: ARRAY
102732: PPUSH
102733: LD_VAR 0 14
102737: PPUSH
102738: LD_VAR 0 4
102742: PUSH
102743: LD_VAR 0 7
102747: ARRAY
102748: PPUSH
102749: CALL_OW 74
102753: PPUSH
102754: CALL_OW 115
// end ; end ; end ;
102758: GO 98663
102760: POP
102761: POP
// wait ( 0 0$1 ) ;
102762: LD_INT 35
102764: PPUSH
102765: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
102769: LD_VAR 0 4
102773: PUSH
102774: EMPTY
102775: EQUAL
102776: PUSH
102777: LD_INT 81
102779: PUSH
102780: LD_VAR 0 35
102784: PUSH
102785: EMPTY
102786: LIST
102787: LIST
102788: PPUSH
102789: CALL_OW 69
102793: NOT
102794: OR
102795: IFFALSE 98648
// end ;
102797: LD_VAR 0 2
102801: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
102802: LD_INT 0
102804: PPUSH
102805: PPUSH
102806: PPUSH
102807: PPUSH
// if not base_units then
102808: LD_VAR 0 1
102812: NOT
102813: IFFALSE 102817
// exit ;
102815: GO 102904
// result := false ;
102817: LD_ADDR_VAR 0 2
102821: PUSH
102822: LD_INT 0
102824: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
102825: LD_ADDR_VAR 0 5
102829: PUSH
102830: LD_VAR 0 1
102834: PPUSH
102835: LD_INT 21
102837: PUSH
102838: LD_INT 3
102840: PUSH
102841: EMPTY
102842: LIST
102843: LIST
102844: PPUSH
102845: CALL_OW 72
102849: ST_TO_ADDR
// if not tmp then
102850: LD_VAR 0 5
102854: NOT
102855: IFFALSE 102859
// exit ;
102857: GO 102904
// for i in tmp do
102859: LD_ADDR_VAR 0 3
102863: PUSH
102864: LD_VAR 0 5
102868: PUSH
102869: FOR_IN
102870: IFFALSE 102902
// begin result := EnemyInRange ( i , 22 ) ;
102872: LD_ADDR_VAR 0 2
102876: PUSH
102877: LD_VAR 0 3
102881: PPUSH
102882: LD_INT 22
102884: PPUSH
102885: CALL 96441 0 2
102889: ST_TO_ADDR
// if result then
102890: LD_VAR 0 2
102894: IFFALSE 102900
// exit ;
102896: POP
102897: POP
102898: GO 102904
// end ;
102900: GO 102869
102902: POP
102903: POP
// end ;
102904: LD_VAR 0 2
102908: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
102909: LD_INT 0
102911: PPUSH
102912: PPUSH
// if not units then
102913: LD_VAR 0 1
102917: NOT
102918: IFFALSE 102922
// exit ;
102920: GO 102992
// result := [ ] ;
102922: LD_ADDR_VAR 0 3
102926: PUSH
102927: EMPTY
102928: ST_TO_ADDR
// for i in units do
102929: LD_ADDR_VAR 0 4
102933: PUSH
102934: LD_VAR 0 1
102938: PUSH
102939: FOR_IN
102940: IFFALSE 102990
// if GetTag ( i ) = tag then
102942: LD_VAR 0 4
102946: PPUSH
102947: CALL_OW 110
102951: PUSH
102952: LD_VAR 0 2
102956: EQUAL
102957: IFFALSE 102988
// result := Insert ( result , result + 1 , i ) ;
102959: LD_ADDR_VAR 0 3
102963: PUSH
102964: LD_VAR 0 3
102968: PPUSH
102969: LD_VAR 0 3
102973: PUSH
102974: LD_INT 1
102976: PLUS
102977: PPUSH
102978: LD_VAR 0 4
102982: PPUSH
102983: CALL_OW 2
102987: ST_TO_ADDR
102988: GO 102939
102990: POP
102991: POP
// end ;
102992: LD_VAR 0 3
102996: RET
// export function IsDriver ( un ) ; begin
102997: LD_INT 0
102999: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
103000: LD_ADDR_VAR 0 2
103004: PUSH
103005: LD_VAR 0 1
103009: PUSH
103010: LD_INT 55
103012: PUSH
103013: EMPTY
103014: LIST
103015: PPUSH
103016: CALL_OW 69
103020: IN
103021: ST_TO_ADDR
// end ;
103022: LD_VAR 0 2
103026: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
103027: LD_INT 0
103029: PPUSH
103030: PPUSH
// list := [ ] ;
103031: LD_ADDR_VAR 0 5
103035: PUSH
103036: EMPTY
103037: ST_TO_ADDR
// case d of 0 :
103038: LD_VAR 0 3
103042: PUSH
103043: LD_INT 0
103045: DOUBLE
103046: EQUAL
103047: IFTRUE 103051
103049: GO 103184
103051: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
103052: LD_ADDR_VAR 0 5
103056: PUSH
103057: LD_VAR 0 1
103061: PUSH
103062: LD_INT 4
103064: MINUS
103065: PUSH
103066: LD_VAR 0 2
103070: PUSH
103071: LD_INT 4
103073: MINUS
103074: PUSH
103075: LD_INT 2
103077: PUSH
103078: EMPTY
103079: LIST
103080: LIST
103081: LIST
103082: PUSH
103083: LD_VAR 0 1
103087: PUSH
103088: LD_INT 3
103090: MINUS
103091: PUSH
103092: LD_VAR 0 2
103096: PUSH
103097: LD_INT 1
103099: PUSH
103100: EMPTY
103101: LIST
103102: LIST
103103: LIST
103104: PUSH
103105: LD_VAR 0 1
103109: PUSH
103110: LD_INT 4
103112: PLUS
103113: PUSH
103114: LD_VAR 0 2
103118: PUSH
103119: LD_INT 4
103121: PUSH
103122: EMPTY
103123: LIST
103124: LIST
103125: LIST
103126: PUSH
103127: LD_VAR 0 1
103131: PUSH
103132: LD_INT 3
103134: PLUS
103135: PUSH
103136: LD_VAR 0 2
103140: PUSH
103141: LD_INT 3
103143: PLUS
103144: PUSH
103145: LD_INT 5
103147: PUSH
103148: EMPTY
103149: LIST
103150: LIST
103151: LIST
103152: PUSH
103153: LD_VAR 0 1
103157: PUSH
103158: LD_VAR 0 2
103162: PUSH
103163: LD_INT 4
103165: PLUS
103166: PUSH
103167: LD_INT 0
103169: PUSH
103170: EMPTY
103171: LIST
103172: LIST
103173: LIST
103174: PUSH
103175: EMPTY
103176: LIST
103177: LIST
103178: LIST
103179: LIST
103180: LIST
103181: ST_TO_ADDR
// end ; 1 :
103182: GO 103882
103184: LD_INT 1
103186: DOUBLE
103187: EQUAL
103188: IFTRUE 103192
103190: GO 103325
103192: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
103193: LD_ADDR_VAR 0 5
103197: PUSH
103198: LD_VAR 0 1
103202: PUSH
103203: LD_VAR 0 2
103207: PUSH
103208: LD_INT 4
103210: MINUS
103211: PUSH
103212: LD_INT 3
103214: PUSH
103215: EMPTY
103216: LIST
103217: LIST
103218: LIST
103219: PUSH
103220: LD_VAR 0 1
103224: PUSH
103225: LD_INT 3
103227: MINUS
103228: PUSH
103229: LD_VAR 0 2
103233: PUSH
103234: LD_INT 3
103236: MINUS
103237: PUSH
103238: LD_INT 2
103240: PUSH
103241: EMPTY
103242: LIST
103243: LIST
103244: LIST
103245: PUSH
103246: LD_VAR 0 1
103250: PUSH
103251: LD_INT 4
103253: MINUS
103254: PUSH
103255: LD_VAR 0 2
103259: PUSH
103260: LD_INT 1
103262: PUSH
103263: EMPTY
103264: LIST
103265: LIST
103266: LIST
103267: PUSH
103268: LD_VAR 0 1
103272: PUSH
103273: LD_VAR 0 2
103277: PUSH
103278: LD_INT 3
103280: PLUS
103281: PUSH
103282: LD_INT 0
103284: PUSH
103285: EMPTY
103286: LIST
103287: LIST
103288: LIST
103289: PUSH
103290: LD_VAR 0 1
103294: PUSH
103295: LD_INT 4
103297: PLUS
103298: PUSH
103299: LD_VAR 0 2
103303: PUSH
103304: LD_INT 4
103306: PLUS
103307: PUSH
103308: LD_INT 5
103310: PUSH
103311: EMPTY
103312: LIST
103313: LIST
103314: LIST
103315: PUSH
103316: EMPTY
103317: LIST
103318: LIST
103319: LIST
103320: LIST
103321: LIST
103322: ST_TO_ADDR
// end ; 2 :
103323: GO 103882
103325: LD_INT 2
103327: DOUBLE
103328: EQUAL
103329: IFTRUE 103333
103331: GO 103462
103333: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
103334: LD_ADDR_VAR 0 5
103338: PUSH
103339: LD_VAR 0 1
103343: PUSH
103344: LD_VAR 0 2
103348: PUSH
103349: LD_INT 3
103351: MINUS
103352: PUSH
103353: LD_INT 3
103355: PUSH
103356: EMPTY
103357: LIST
103358: LIST
103359: LIST
103360: PUSH
103361: LD_VAR 0 1
103365: PUSH
103366: LD_INT 4
103368: PLUS
103369: PUSH
103370: LD_VAR 0 2
103374: PUSH
103375: LD_INT 4
103377: PUSH
103378: EMPTY
103379: LIST
103380: LIST
103381: LIST
103382: PUSH
103383: LD_VAR 0 1
103387: PUSH
103388: LD_VAR 0 2
103392: PUSH
103393: LD_INT 4
103395: PLUS
103396: PUSH
103397: LD_INT 0
103399: PUSH
103400: EMPTY
103401: LIST
103402: LIST
103403: LIST
103404: PUSH
103405: LD_VAR 0 1
103409: PUSH
103410: LD_INT 3
103412: MINUS
103413: PUSH
103414: LD_VAR 0 2
103418: PUSH
103419: LD_INT 1
103421: PUSH
103422: EMPTY
103423: LIST
103424: LIST
103425: LIST
103426: PUSH
103427: LD_VAR 0 1
103431: PUSH
103432: LD_INT 4
103434: MINUS
103435: PUSH
103436: LD_VAR 0 2
103440: PUSH
103441: LD_INT 4
103443: MINUS
103444: PUSH
103445: LD_INT 2
103447: PUSH
103448: EMPTY
103449: LIST
103450: LIST
103451: LIST
103452: PUSH
103453: EMPTY
103454: LIST
103455: LIST
103456: LIST
103457: LIST
103458: LIST
103459: ST_TO_ADDR
// end ; 3 :
103460: GO 103882
103462: LD_INT 3
103464: DOUBLE
103465: EQUAL
103466: IFTRUE 103470
103468: GO 103603
103470: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
103471: LD_ADDR_VAR 0 5
103475: PUSH
103476: LD_VAR 0 1
103480: PUSH
103481: LD_INT 3
103483: PLUS
103484: PUSH
103485: LD_VAR 0 2
103489: PUSH
103490: LD_INT 4
103492: PUSH
103493: EMPTY
103494: LIST
103495: LIST
103496: LIST
103497: PUSH
103498: LD_VAR 0 1
103502: PUSH
103503: LD_INT 4
103505: PLUS
103506: PUSH
103507: LD_VAR 0 2
103511: PUSH
103512: LD_INT 4
103514: PLUS
103515: PUSH
103516: LD_INT 5
103518: PUSH
103519: EMPTY
103520: LIST
103521: LIST
103522: LIST
103523: PUSH
103524: LD_VAR 0 1
103528: PUSH
103529: LD_INT 4
103531: MINUS
103532: PUSH
103533: LD_VAR 0 2
103537: PUSH
103538: LD_INT 1
103540: PUSH
103541: EMPTY
103542: LIST
103543: LIST
103544: LIST
103545: PUSH
103546: LD_VAR 0 1
103550: PUSH
103551: LD_VAR 0 2
103555: PUSH
103556: LD_INT 4
103558: MINUS
103559: PUSH
103560: LD_INT 3
103562: PUSH
103563: EMPTY
103564: LIST
103565: LIST
103566: LIST
103567: PUSH
103568: LD_VAR 0 1
103572: PUSH
103573: LD_INT 3
103575: MINUS
103576: PUSH
103577: LD_VAR 0 2
103581: PUSH
103582: LD_INT 3
103584: MINUS
103585: PUSH
103586: LD_INT 2
103588: PUSH
103589: EMPTY
103590: LIST
103591: LIST
103592: LIST
103593: PUSH
103594: EMPTY
103595: LIST
103596: LIST
103597: LIST
103598: LIST
103599: LIST
103600: ST_TO_ADDR
// end ; 4 :
103601: GO 103882
103603: LD_INT 4
103605: DOUBLE
103606: EQUAL
103607: IFTRUE 103611
103609: GO 103744
103611: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
103612: LD_ADDR_VAR 0 5
103616: PUSH
103617: LD_VAR 0 1
103621: PUSH
103622: LD_VAR 0 2
103626: PUSH
103627: LD_INT 4
103629: PLUS
103630: PUSH
103631: LD_INT 0
103633: PUSH
103634: EMPTY
103635: LIST
103636: LIST
103637: LIST
103638: PUSH
103639: LD_VAR 0 1
103643: PUSH
103644: LD_INT 3
103646: PLUS
103647: PUSH
103648: LD_VAR 0 2
103652: PUSH
103653: LD_INT 3
103655: PLUS
103656: PUSH
103657: LD_INT 5
103659: PUSH
103660: EMPTY
103661: LIST
103662: LIST
103663: LIST
103664: PUSH
103665: LD_VAR 0 1
103669: PUSH
103670: LD_INT 4
103672: PLUS
103673: PUSH
103674: LD_VAR 0 2
103678: PUSH
103679: LD_INT 4
103681: PUSH
103682: EMPTY
103683: LIST
103684: LIST
103685: LIST
103686: PUSH
103687: LD_VAR 0 1
103691: PUSH
103692: LD_VAR 0 2
103696: PUSH
103697: LD_INT 3
103699: MINUS
103700: PUSH
103701: LD_INT 3
103703: PUSH
103704: EMPTY
103705: LIST
103706: LIST
103707: LIST
103708: PUSH
103709: LD_VAR 0 1
103713: PUSH
103714: LD_INT 4
103716: MINUS
103717: PUSH
103718: LD_VAR 0 2
103722: PUSH
103723: LD_INT 4
103725: MINUS
103726: PUSH
103727: LD_INT 2
103729: PUSH
103730: EMPTY
103731: LIST
103732: LIST
103733: LIST
103734: PUSH
103735: EMPTY
103736: LIST
103737: LIST
103738: LIST
103739: LIST
103740: LIST
103741: ST_TO_ADDR
// end ; 5 :
103742: GO 103882
103744: LD_INT 5
103746: DOUBLE
103747: EQUAL
103748: IFTRUE 103752
103750: GO 103881
103752: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
103753: LD_ADDR_VAR 0 5
103757: PUSH
103758: LD_VAR 0 1
103762: PUSH
103763: LD_INT 4
103765: MINUS
103766: PUSH
103767: LD_VAR 0 2
103771: PUSH
103772: LD_INT 1
103774: PUSH
103775: EMPTY
103776: LIST
103777: LIST
103778: LIST
103779: PUSH
103780: LD_VAR 0 1
103784: PUSH
103785: LD_VAR 0 2
103789: PUSH
103790: LD_INT 4
103792: MINUS
103793: PUSH
103794: LD_INT 3
103796: PUSH
103797: EMPTY
103798: LIST
103799: LIST
103800: LIST
103801: PUSH
103802: LD_VAR 0 1
103806: PUSH
103807: LD_INT 4
103809: PLUS
103810: PUSH
103811: LD_VAR 0 2
103815: PUSH
103816: LD_INT 4
103818: PLUS
103819: PUSH
103820: LD_INT 5
103822: PUSH
103823: EMPTY
103824: LIST
103825: LIST
103826: LIST
103827: PUSH
103828: LD_VAR 0 1
103832: PUSH
103833: LD_INT 3
103835: PLUS
103836: PUSH
103837: LD_VAR 0 2
103841: PUSH
103842: LD_INT 4
103844: PUSH
103845: EMPTY
103846: LIST
103847: LIST
103848: LIST
103849: PUSH
103850: LD_VAR 0 1
103854: PUSH
103855: LD_VAR 0 2
103859: PUSH
103860: LD_INT 3
103862: PLUS
103863: PUSH
103864: LD_INT 0
103866: PUSH
103867: EMPTY
103868: LIST
103869: LIST
103870: LIST
103871: PUSH
103872: EMPTY
103873: LIST
103874: LIST
103875: LIST
103876: LIST
103877: LIST
103878: ST_TO_ADDR
// end ; end ;
103879: GO 103882
103881: POP
// result := list ;
103882: LD_ADDR_VAR 0 4
103886: PUSH
103887: LD_VAR 0 5
103891: ST_TO_ADDR
// end ;
103892: LD_VAR 0 4
103896: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
103897: LD_INT 0
103899: PPUSH
103900: PPUSH
103901: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
103902: LD_VAR 0 1
103906: NOT
103907: PUSH
103908: LD_VAR 0 2
103912: PUSH
103913: LD_INT 1
103915: PUSH
103916: LD_INT 2
103918: PUSH
103919: LD_INT 3
103921: PUSH
103922: LD_INT 4
103924: PUSH
103925: EMPTY
103926: LIST
103927: LIST
103928: LIST
103929: LIST
103930: IN
103931: NOT
103932: OR
103933: IFFALSE 103937
// exit ;
103935: GO 104029
// tmp := [ ] ;
103937: LD_ADDR_VAR 0 5
103941: PUSH
103942: EMPTY
103943: ST_TO_ADDR
// for i in units do
103944: LD_ADDR_VAR 0 4
103948: PUSH
103949: LD_VAR 0 1
103953: PUSH
103954: FOR_IN
103955: IFFALSE 103998
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
103957: LD_ADDR_VAR 0 5
103961: PUSH
103962: LD_VAR 0 5
103966: PPUSH
103967: LD_VAR 0 5
103971: PUSH
103972: LD_INT 1
103974: PLUS
103975: PPUSH
103976: LD_VAR 0 4
103980: PPUSH
103981: LD_VAR 0 2
103985: PPUSH
103986: CALL_OW 259
103990: PPUSH
103991: CALL_OW 2
103995: ST_TO_ADDR
103996: GO 103954
103998: POP
103999: POP
// if not tmp then
104000: LD_VAR 0 5
104004: NOT
104005: IFFALSE 104009
// exit ;
104007: GO 104029
// result := SortListByListDesc ( units , tmp ) ;
104009: LD_ADDR_VAR 0 3
104013: PUSH
104014: LD_VAR 0 1
104018: PPUSH
104019: LD_VAR 0 5
104023: PPUSH
104024: CALL_OW 77
104028: ST_TO_ADDR
// end ;
104029: LD_VAR 0 3
104033: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
104034: LD_INT 0
104036: PPUSH
104037: PPUSH
104038: PPUSH
// x := GetX ( building ) ;
104039: LD_ADDR_VAR 0 4
104043: PUSH
104044: LD_VAR 0 2
104048: PPUSH
104049: CALL_OW 250
104053: ST_TO_ADDR
// y := GetY ( building ) ;
104054: LD_ADDR_VAR 0 5
104058: PUSH
104059: LD_VAR 0 2
104063: PPUSH
104064: CALL_OW 251
104068: ST_TO_ADDR
// if GetTaskList ( unit ) then
104069: LD_VAR 0 1
104073: PPUSH
104074: CALL_OW 437
104078: IFFALSE 104173
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
104080: LD_STRING e
104082: PUSH
104083: LD_VAR 0 1
104087: PPUSH
104088: CALL_OW 437
104092: PUSH
104093: LD_INT 1
104095: ARRAY
104096: PUSH
104097: LD_INT 1
104099: ARRAY
104100: EQUAL
104101: PUSH
104102: LD_VAR 0 4
104106: PUSH
104107: LD_VAR 0 1
104111: PPUSH
104112: CALL_OW 437
104116: PUSH
104117: LD_INT 1
104119: ARRAY
104120: PUSH
104121: LD_INT 2
104123: ARRAY
104124: EQUAL
104125: AND
104126: PUSH
104127: LD_VAR 0 5
104131: PUSH
104132: LD_VAR 0 1
104136: PPUSH
104137: CALL_OW 437
104141: PUSH
104142: LD_INT 1
104144: ARRAY
104145: PUSH
104146: LD_INT 3
104148: ARRAY
104149: EQUAL
104150: AND
104151: IFFALSE 104163
// result := true else
104153: LD_ADDR_VAR 0 3
104157: PUSH
104158: LD_INT 1
104160: ST_TO_ADDR
104161: GO 104171
// result := false ;
104163: LD_ADDR_VAR 0 3
104167: PUSH
104168: LD_INT 0
104170: ST_TO_ADDR
// end else
104171: GO 104181
// result := false ;
104173: LD_ADDR_VAR 0 3
104177: PUSH
104178: LD_INT 0
104180: ST_TO_ADDR
// end ;
104181: LD_VAR 0 3
104185: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
104186: LD_INT 0
104188: PPUSH
104189: PPUSH
104190: PPUSH
104191: PPUSH
// if not unit or not area then
104192: LD_VAR 0 1
104196: NOT
104197: PUSH
104198: LD_VAR 0 2
104202: NOT
104203: OR
104204: IFFALSE 104208
// exit ;
104206: GO 104372
// tmp := AreaToList ( area , i ) ;
104208: LD_ADDR_VAR 0 6
104212: PUSH
104213: LD_VAR 0 2
104217: PPUSH
104218: LD_VAR 0 5
104222: PPUSH
104223: CALL_OW 517
104227: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
104228: LD_ADDR_VAR 0 5
104232: PUSH
104233: DOUBLE
104234: LD_INT 1
104236: DEC
104237: ST_TO_ADDR
104238: LD_VAR 0 6
104242: PUSH
104243: LD_INT 1
104245: ARRAY
104246: PUSH
104247: FOR_TO
104248: IFFALSE 104370
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
104250: LD_ADDR_VAR 0 7
104254: PUSH
104255: LD_VAR 0 6
104259: PUSH
104260: LD_INT 1
104262: ARRAY
104263: PUSH
104264: LD_VAR 0 5
104268: ARRAY
104269: PUSH
104270: LD_VAR 0 6
104274: PUSH
104275: LD_INT 2
104277: ARRAY
104278: PUSH
104279: LD_VAR 0 5
104283: ARRAY
104284: PUSH
104285: EMPTY
104286: LIST
104287: LIST
104288: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
104289: LD_VAR 0 7
104293: PUSH
104294: LD_INT 1
104296: ARRAY
104297: PPUSH
104298: LD_VAR 0 7
104302: PUSH
104303: LD_INT 2
104305: ARRAY
104306: PPUSH
104307: CALL_OW 428
104311: PUSH
104312: LD_INT 0
104314: EQUAL
104315: IFFALSE 104368
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
104317: LD_VAR 0 1
104321: PPUSH
104322: LD_VAR 0 7
104326: PUSH
104327: LD_INT 1
104329: ARRAY
104330: PPUSH
104331: LD_VAR 0 7
104335: PUSH
104336: LD_INT 2
104338: ARRAY
104339: PPUSH
104340: LD_VAR 0 3
104344: PPUSH
104345: CALL_OW 48
// result := IsPlaced ( unit ) ;
104349: LD_ADDR_VAR 0 4
104353: PUSH
104354: LD_VAR 0 1
104358: PPUSH
104359: CALL_OW 305
104363: ST_TO_ADDR
// exit ;
104364: POP
104365: POP
104366: GO 104372
// end ; end ;
104368: GO 104247
104370: POP
104371: POP
// end ;
104372: LD_VAR 0 4
104376: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
104377: LD_INT 0
104379: PPUSH
104380: PPUSH
104381: PPUSH
// if not side or side > 8 then
104382: LD_VAR 0 1
104386: NOT
104387: PUSH
104388: LD_VAR 0 1
104392: PUSH
104393: LD_INT 8
104395: GREATER
104396: OR
104397: IFFALSE 104401
// exit ;
104399: GO 104588
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
104401: LD_ADDR_VAR 0 4
104405: PUSH
104406: LD_INT 22
104408: PUSH
104409: LD_VAR 0 1
104413: PUSH
104414: EMPTY
104415: LIST
104416: LIST
104417: PUSH
104418: LD_INT 21
104420: PUSH
104421: LD_INT 3
104423: PUSH
104424: EMPTY
104425: LIST
104426: LIST
104427: PUSH
104428: EMPTY
104429: LIST
104430: LIST
104431: PPUSH
104432: CALL_OW 69
104436: ST_TO_ADDR
// if not tmp then
104437: LD_VAR 0 4
104441: NOT
104442: IFFALSE 104446
// exit ;
104444: GO 104588
// enable_addtolog := true ;
104446: LD_ADDR_OWVAR 81
104450: PUSH
104451: LD_INT 1
104453: ST_TO_ADDR
// AddToLog ( [ ) ;
104454: LD_STRING [
104456: PPUSH
104457: CALL_OW 561
// for i in tmp do
104461: LD_ADDR_VAR 0 3
104465: PUSH
104466: LD_VAR 0 4
104470: PUSH
104471: FOR_IN
104472: IFFALSE 104579
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
104474: LD_STRING [
104476: PUSH
104477: LD_VAR 0 3
104481: PPUSH
104482: CALL_OW 266
104486: STR
104487: PUSH
104488: LD_STRING , 
104490: STR
104491: PUSH
104492: LD_VAR 0 3
104496: PPUSH
104497: CALL_OW 250
104501: STR
104502: PUSH
104503: LD_STRING , 
104505: STR
104506: PUSH
104507: LD_VAR 0 3
104511: PPUSH
104512: CALL_OW 251
104516: STR
104517: PUSH
104518: LD_STRING , 
104520: STR
104521: PUSH
104522: LD_VAR 0 3
104526: PPUSH
104527: CALL_OW 254
104531: STR
104532: PUSH
104533: LD_STRING , 
104535: STR
104536: PUSH
104537: LD_VAR 0 3
104541: PPUSH
104542: LD_INT 1
104544: PPUSH
104545: CALL_OW 268
104549: STR
104550: PUSH
104551: LD_STRING , 
104553: STR
104554: PUSH
104555: LD_VAR 0 3
104559: PPUSH
104560: LD_INT 2
104562: PPUSH
104563: CALL_OW 268
104567: STR
104568: PUSH
104569: LD_STRING ],
104571: STR
104572: PPUSH
104573: CALL_OW 561
// end ;
104577: GO 104471
104579: POP
104580: POP
// AddToLog ( ]; ) ;
104581: LD_STRING ];
104583: PPUSH
104584: CALL_OW 561
// end ;
104588: LD_VAR 0 2
104592: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
104593: LD_INT 0
104595: PPUSH
104596: PPUSH
104597: PPUSH
104598: PPUSH
104599: PPUSH
// if not area or not rate or not max then
104600: LD_VAR 0 1
104604: NOT
104605: PUSH
104606: LD_VAR 0 2
104610: NOT
104611: OR
104612: PUSH
104613: LD_VAR 0 4
104617: NOT
104618: OR
104619: IFFALSE 104623
// exit ;
104621: GO 104815
// while 1 do
104623: LD_INT 1
104625: IFFALSE 104815
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
104627: LD_ADDR_VAR 0 9
104631: PUSH
104632: LD_VAR 0 1
104636: PPUSH
104637: LD_INT 1
104639: PPUSH
104640: CALL_OW 287
104644: PUSH
104645: LD_INT 10
104647: MUL
104648: ST_TO_ADDR
// r := rate / 10 ;
104649: LD_ADDR_VAR 0 7
104653: PUSH
104654: LD_VAR 0 2
104658: PUSH
104659: LD_INT 10
104661: DIVREAL
104662: ST_TO_ADDR
// time := 1 1$00 ;
104663: LD_ADDR_VAR 0 8
104667: PUSH
104668: LD_INT 2100
104670: ST_TO_ADDR
// if amount < min then
104671: LD_VAR 0 9
104675: PUSH
104676: LD_VAR 0 3
104680: LESS
104681: IFFALSE 104699
// r := r * 2 else
104683: LD_ADDR_VAR 0 7
104687: PUSH
104688: LD_VAR 0 7
104692: PUSH
104693: LD_INT 2
104695: MUL
104696: ST_TO_ADDR
104697: GO 104725
// if amount > max then
104699: LD_VAR 0 9
104703: PUSH
104704: LD_VAR 0 4
104708: GREATER
104709: IFFALSE 104725
// r := r / 2 ;
104711: LD_ADDR_VAR 0 7
104715: PUSH
104716: LD_VAR 0 7
104720: PUSH
104721: LD_INT 2
104723: DIVREAL
104724: ST_TO_ADDR
// time := time / r ;
104725: LD_ADDR_VAR 0 8
104729: PUSH
104730: LD_VAR 0 8
104734: PUSH
104735: LD_VAR 0 7
104739: DIVREAL
104740: ST_TO_ADDR
// if time < 0 then
104741: LD_VAR 0 8
104745: PUSH
104746: LD_INT 0
104748: LESS
104749: IFFALSE 104766
// time := time * - 1 ;
104751: LD_ADDR_VAR 0 8
104755: PUSH
104756: LD_VAR 0 8
104760: PUSH
104761: LD_INT 1
104763: NEG
104764: MUL
104765: ST_TO_ADDR
// wait ( time ) ;
104766: LD_VAR 0 8
104770: PPUSH
104771: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
104775: LD_INT 35
104777: PPUSH
104778: LD_INT 875
104780: PPUSH
104781: CALL_OW 12
104785: PPUSH
104786: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
104790: LD_INT 1
104792: PPUSH
104793: LD_INT 5
104795: PPUSH
104796: CALL_OW 12
104800: PPUSH
104801: LD_VAR 0 1
104805: PPUSH
104806: LD_INT 1
104808: PPUSH
104809: CALL_OW 55
// end ;
104813: GO 104623
// end ;
104815: LD_VAR 0 5
104819: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
104820: LD_INT 0
104822: PPUSH
104823: PPUSH
104824: PPUSH
104825: PPUSH
104826: PPUSH
104827: PPUSH
104828: PPUSH
104829: PPUSH
// if not turrets or not factories then
104830: LD_VAR 0 1
104834: NOT
104835: PUSH
104836: LD_VAR 0 2
104840: NOT
104841: OR
104842: IFFALSE 104846
// exit ;
104844: GO 105153
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
104846: LD_ADDR_VAR 0 10
104850: PUSH
104851: LD_INT 5
104853: PUSH
104854: LD_INT 6
104856: PUSH
104857: EMPTY
104858: LIST
104859: LIST
104860: PUSH
104861: LD_INT 2
104863: PUSH
104864: LD_INT 4
104866: PUSH
104867: EMPTY
104868: LIST
104869: LIST
104870: PUSH
104871: LD_INT 3
104873: PUSH
104874: LD_INT 5
104876: PUSH
104877: EMPTY
104878: LIST
104879: LIST
104880: PUSH
104881: EMPTY
104882: LIST
104883: LIST
104884: LIST
104885: PUSH
104886: LD_INT 24
104888: PUSH
104889: LD_INT 25
104891: PUSH
104892: EMPTY
104893: LIST
104894: LIST
104895: PUSH
104896: LD_INT 23
104898: PUSH
104899: LD_INT 27
104901: PUSH
104902: EMPTY
104903: LIST
104904: LIST
104905: PUSH
104906: EMPTY
104907: LIST
104908: LIST
104909: PUSH
104910: LD_INT 42
104912: PUSH
104913: LD_INT 43
104915: PUSH
104916: EMPTY
104917: LIST
104918: LIST
104919: PUSH
104920: LD_INT 44
104922: PUSH
104923: LD_INT 46
104925: PUSH
104926: EMPTY
104927: LIST
104928: LIST
104929: PUSH
104930: LD_INT 45
104932: PUSH
104933: LD_INT 47
104935: PUSH
104936: EMPTY
104937: LIST
104938: LIST
104939: PUSH
104940: EMPTY
104941: LIST
104942: LIST
104943: LIST
104944: PUSH
104945: EMPTY
104946: LIST
104947: LIST
104948: LIST
104949: ST_TO_ADDR
// result := [ ] ;
104950: LD_ADDR_VAR 0 3
104954: PUSH
104955: EMPTY
104956: ST_TO_ADDR
// for i in turrets do
104957: LD_ADDR_VAR 0 4
104961: PUSH
104962: LD_VAR 0 1
104966: PUSH
104967: FOR_IN
104968: IFFALSE 105151
// begin nat := GetNation ( i ) ;
104970: LD_ADDR_VAR 0 7
104974: PUSH
104975: LD_VAR 0 4
104979: PPUSH
104980: CALL_OW 248
104984: ST_TO_ADDR
// weapon := 0 ;
104985: LD_ADDR_VAR 0 8
104989: PUSH
104990: LD_INT 0
104992: ST_TO_ADDR
// if not nat then
104993: LD_VAR 0 7
104997: NOT
104998: IFFALSE 105002
// continue ;
105000: GO 104967
// for j in list [ nat ] do
105002: LD_ADDR_VAR 0 5
105006: PUSH
105007: LD_VAR 0 10
105011: PUSH
105012: LD_VAR 0 7
105016: ARRAY
105017: PUSH
105018: FOR_IN
105019: IFFALSE 105060
// if GetBWeapon ( i ) = j [ 1 ] then
105021: LD_VAR 0 4
105025: PPUSH
105026: CALL_OW 269
105030: PUSH
105031: LD_VAR 0 5
105035: PUSH
105036: LD_INT 1
105038: ARRAY
105039: EQUAL
105040: IFFALSE 105058
// begin weapon := j [ 2 ] ;
105042: LD_ADDR_VAR 0 8
105046: PUSH
105047: LD_VAR 0 5
105051: PUSH
105052: LD_INT 2
105054: ARRAY
105055: ST_TO_ADDR
// break ;
105056: GO 105060
// end ;
105058: GO 105018
105060: POP
105061: POP
// if not weapon then
105062: LD_VAR 0 8
105066: NOT
105067: IFFALSE 105071
// continue ;
105069: GO 104967
// for k in factories do
105071: LD_ADDR_VAR 0 6
105075: PUSH
105076: LD_VAR 0 2
105080: PUSH
105081: FOR_IN
105082: IFFALSE 105147
// begin weapons := AvailableWeaponList ( k ) ;
105084: LD_ADDR_VAR 0 9
105088: PUSH
105089: LD_VAR 0 6
105093: PPUSH
105094: CALL_OW 478
105098: ST_TO_ADDR
// if not weapons then
105099: LD_VAR 0 9
105103: NOT
105104: IFFALSE 105108
// continue ;
105106: GO 105081
// if weapon in weapons then
105108: LD_VAR 0 8
105112: PUSH
105113: LD_VAR 0 9
105117: IN
105118: IFFALSE 105145
// begin result := [ i , weapon ] ;
105120: LD_ADDR_VAR 0 3
105124: PUSH
105125: LD_VAR 0 4
105129: PUSH
105130: LD_VAR 0 8
105134: PUSH
105135: EMPTY
105136: LIST
105137: LIST
105138: ST_TO_ADDR
// exit ;
105139: POP
105140: POP
105141: POP
105142: POP
105143: GO 105153
// end ; end ;
105145: GO 105081
105147: POP
105148: POP
// end ;
105149: GO 104967
105151: POP
105152: POP
// end ;
105153: LD_VAR 0 3
105157: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
105158: LD_INT 0
105160: PPUSH
// if not side or side > 8 then
105161: LD_VAR 0 3
105165: NOT
105166: PUSH
105167: LD_VAR 0 3
105171: PUSH
105172: LD_INT 8
105174: GREATER
105175: OR
105176: IFFALSE 105180
// exit ;
105178: GO 105239
// if not range then
105180: LD_VAR 0 4
105184: NOT
105185: IFFALSE 105196
// range := - 12 ;
105187: LD_ADDR_VAR 0 4
105191: PUSH
105192: LD_INT 12
105194: NEG
105195: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
105196: LD_VAR 0 1
105200: PPUSH
105201: LD_VAR 0 2
105205: PPUSH
105206: LD_VAR 0 3
105210: PPUSH
105211: LD_VAR 0 4
105215: PPUSH
105216: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
105220: LD_VAR 0 1
105224: PPUSH
105225: LD_VAR 0 2
105229: PPUSH
105230: LD_VAR 0 3
105234: PPUSH
105235: CALL_OW 331
// end ;
105239: LD_VAR 0 5
105243: RET
// export function Video ( mode ) ; begin
105244: LD_INT 0
105246: PPUSH
// ingame_video = mode ;
105247: LD_ADDR_OWVAR 52
105251: PUSH
105252: LD_VAR 0 1
105256: ST_TO_ADDR
// interface_hidden = mode ;
105257: LD_ADDR_OWVAR 54
105261: PUSH
105262: LD_VAR 0 1
105266: ST_TO_ADDR
// end ;
105267: LD_VAR 0 2
105271: RET
// export function Join ( array , element ) ; begin
105272: LD_INT 0
105274: PPUSH
// result := array ^ element ;
105275: LD_ADDR_VAR 0 3
105279: PUSH
105280: LD_VAR 0 1
105284: PUSH
105285: LD_VAR 0 2
105289: ADD
105290: ST_TO_ADDR
// end ;
105291: LD_VAR 0 3
105295: RET
// export function JoinUnion ( array , element ) ; begin
105296: LD_INT 0
105298: PPUSH
// result := array union element ;
105299: LD_ADDR_VAR 0 3
105303: PUSH
105304: LD_VAR 0 1
105308: PUSH
105309: LD_VAR 0 2
105313: UNION
105314: ST_TO_ADDR
// end ;
105315: LD_VAR 0 3
105319: RET
// export function GetBehemoths ( side ) ; begin
105320: LD_INT 0
105322: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
105323: LD_ADDR_VAR 0 2
105327: PUSH
105328: LD_INT 22
105330: PUSH
105331: LD_VAR 0 1
105335: PUSH
105336: EMPTY
105337: LIST
105338: LIST
105339: PUSH
105340: LD_INT 31
105342: PUSH
105343: LD_INT 25
105345: PUSH
105346: EMPTY
105347: LIST
105348: LIST
105349: PUSH
105350: EMPTY
105351: LIST
105352: LIST
105353: PPUSH
105354: CALL_OW 69
105358: ST_TO_ADDR
// end ;
105359: LD_VAR 0 2
105363: RET
// export function Shuffle ( array ) ; var i , index ; begin
105364: LD_INT 0
105366: PPUSH
105367: PPUSH
105368: PPUSH
// result := [ ] ;
105369: LD_ADDR_VAR 0 2
105373: PUSH
105374: EMPTY
105375: ST_TO_ADDR
// if not array then
105376: LD_VAR 0 1
105380: NOT
105381: IFFALSE 105385
// exit ;
105383: GO 105484
// Randomize ;
105385: CALL_OW 10
// for i = array downto 1 do
105389: LD_ADDR_VAR 0 3
105393: PUSH
105394: DOUBLE
105395: LD_VAR 0 1
105399: INC
105400: ST_TO_ADDR
105401: LD_INT 1
105403: PUSH
105404: FOR_DOWNTO
105405: IFFALSE 105482
// begin index := rand ( 1 , array ) ;
105407: LD_ADDR_VAR 0 4
105411: PUSH
105412: LD_INT 1
105414: PPUSH
105415: LD_VAR 0 1
105419: PPUSH
105420: CALL_OW 12
105424: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
105425: LD_ADDR_VAR 0 2
105429: PUSH
105430: LD_VAR 0 2
105434: PPUSH
105435: LD_VAR 0 2
105439: PUSH
105440: LD_INT 1
105442: PLUS
105443: PPUSH
105444: LD_VAR 0 1
105448: PUSH
105449: LD_VAR 0 4
105453: ARRAY
105454: PPUSH
105455: CALL_OW 2
105459: ST_TO_ADDR
// array := Delete ( array , index ) ;
105460: LD_ADDR_VAR 0 1
105464: PUSH
105465: LD_VAR 0 1
105469: PPUSH
105470: LD_VAR 0 4
105474: PPUSH
105475: CALL_OW 3
105479: ST_TO_ADDR
// end ;
105480: GO 105404
105482: POP
105483: POP
// end ; end_of_file end_of_file end_of_file
105484: LD_VAR 0 2
105488: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
105489: LD_INT 0
105491: PPUSH
105492: PPUSH
105493: PPUSH
105494: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105495: LD_VAR 0 1
105499: PPUSH
105500: CALL_OW 264
105504: PUSH
105505: LD_EXP 96
105509: EQUAL
105510: IFFALSE 105582
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105512: LD_INT 68
105514: PPUSH
105515: LD_VAR 0 1
105519: PPUSH
105520: CALL_OW 255
105524: PPUSH
105525: CALL_OW 321
105529: PUSH
105530: LD_INT 2
105532: EQUAL
105533: IFFALSE 105545
// eff := 70 else
105535: LD_ADDR_VAR 0 6
105539: PUSH
105540: LD_INT 70
105542: ST_TO_ADDR
105543: GO 105553
// eff := 30 ;
105545: LD_ADDR_VAR 0 6
105549: PUSH
105550: LD_INT 30
105552: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105553: LD_VAR 0 1
105557: PPUSH
105558: CALL_OW 250
105562: PPUSH
105563: LD_VAR 0 1
105567: PPUSH
105568: CALL_OW 251
105572: PPUSH
105573: LD_VAR 0 6
105577: PPUSH
105578: CALL_OW 495
// end ; end ;
105582: LD_VAR 0 4
105586: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
105587: LD_INT 0
105589: PPUSH
105590: PPUSH
105591: PPUSH
105592: PPUSH
105593: PPUSH
105594: PPUSH
// if cmd = 124 then
105595: LD_VAR 0 1
105599: PUSH
105600: LD_INT 124
105602: EQUAL
105603: IFFALSE 105809
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
105605: LD_ADDR_VAR 0 5
105609: PUSH
105610: LD_INT 2
105612: PUSH
105613: LD_INT 34
105615: PUSH
105616: LD_INT 53
105618: PUSH
105619: EMPTY
105620: LIST
105621: LIST
105622: PUSH
105623: LD_INT 34
105625: PUSH
105626: LD_INT 14
105628: PUSH
105629: EMPTY
105630: LIST
105631: LIST
105632: PUSH
105633: EMPTY
105634: LIST
105635: LIST
105636: LIST
105637: PPUSH
105638: CALL_OW 69
105642: ST_TO_ADDR
// if not tmp then
105643: LD_VAR 0 5
105647: NOT
105648: IFFALSE 105652
// exit ;
105650: GO 105809
// for i in tmp do
105652: LD_ADDR_VAR 0 3
105656: PUSH
105657: LD_VAR 0 5
105661: PUSH
105662: FOR_IN
105663: IFFALSE 105807
// begin taskList := GetTaskList ( i ) ;
105665: LD_ADDR_VAR 0 6
105669: PUSH
105670: LD_VAR 0 3
105674: PPUSH
105675: CALL_OW 437
105679: ST_TO_ADDR
// if not taskList then
105680: LD_VAR 0 6
105684: NOT
105685: IFFALSE 105689
// continue ;
105687: GO 105662
// for j = 1 to taskList do
105689: LD_ADDR_VAR 0 4
105693: PUSH
105694: DOUBLE
105695: LD_INT 1
105697: DEC
105698: ST_TO_ADDR
105699: LD_VAR 0 6
105703: PUSH
105704: FOR_TO
105705: IFFALSE 105803
// if taskList [ j ] [ 1 ] = | then
105707: LD_VAR 0 6
105711: PUSH
105712: LD_VAR 0 4
105716: ARRAY
105717: PUSH
105718: LD_INT 1
105720: ARRAY
105721: PUSH
105722: LD_STRING |
105724: EQUAL
105725: IFFALSE 105801
// begin _taskList := Delete ( taskList , 1 ) ;
105727: LD_ADDR_VAR 0 7
105731: PUSH
105732: LD_VAR 0 6
105736: PPUSH
105737: LD_INT 1
105739: PPUSH
105740: CALL_OW 3
105744: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
105745: LD_VAR 0 3
105749: PPUSH
105750: LD_VAR 0 7
105754: PPUSH
105755: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
105759: LD_VAR 0 3
105763: PPUSH
105764: LD_VAR 0 6
105768: PUSH
105769: LD_VAR 0 4
105773: ARRAY
105774: PUSH
105775: LD_INT 2
105777: ARRAY
105778: PPUSH
105779: LD_VAR 0 6
105783: PUSH
105784: LD_VAR 0 4
105788: ARRAY
105789: PUSH
105790: LD_INT 3
105792: ARRAY
105793: PPUSH
105794: LD_INT 8
105796: PPUSH
105797: CALL 105814 0 4
// end ;
105801: GO 105704
105803: POP
105804: POP
// end ;
105805: GO 105662
105807: POP
105808: POP
// end ; end ;
105809: LD_VAR 0 2
105813: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
105814: LD_INT 0
105816: PPUSH
105817: PPUSH
105818: PPUSH
105819: PPUSH
105820: PPUSH
105821: PPUSH
105822: PPUSH
105823: PPUSH
105824: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
105825: LD_VAR 0 1
105829: NOT
105830: PUSH
105831: LD_VAR 0 2
105835: PPUSH
105836: LD_VAR 0 3
105840: PPUSH
105841: CALL_OW 488
105845: NOT
105846: OR
105847: PUSH
105848: LD_VAR 0 4
105852: NOT
105853: OR
105854: IFFALSE 105858
// exit ;
105856: GO 106198
// list := [ ] ;
105858: LD_ADDR_VAR 0 13
105862: PUSH
105863: EMPTY
105864: ST_TO_ADDR
// if x - r < 0 then
105865: LD_VAR 0 2
105869: PUSH
105870: LD_VAR 0 4
105874: MINUS
105875: PUSH
105876: LD_INT 0
105878: LESS
105879: IFFALSE 105891
// min_x := 0 else
105881: LD_ADDR_VAR 0 7
105885: PUSH
105886: LD_INT 0
105888: ST_TO_ADDR
105889: GO 105907
// min_x := x - r ;
105891: LD_ADDR_VAR 0 7
105895: PUSH
105896: LD_VAR 0 2
105900: PUSH
105901: LD_VAR 0 4
105905: MINUS
105906: ST_TO_ADDR
// if y - r < 0 then
105907: LD_VAR 0 3
105911: PUSH
105912: LD_VAR 0 4
105916: MINUS
105917: PUSH
105918: LD_INT 0
105920: LESS
105921: IFFALSE 105933
// min_y := 0 else
105923: LD_ADDR_VAR 0 8
105927: PUSH
105928: LD_INT 0
105930: ST_TO_ADDR
105931: GO 105949
// min_y := y - r ;
105933: LD_ADDR_VAR 0 8
105937: PUSH
105938: LD_VAR 0 3
105942: PUSH
105943: LD_VAR 0 4
105947: MINUS
105948: ST_TO_ADDR
// max_x := x + r ;
105949: LD_ADDR_VAR 0 9
105953: PUSH
105954: LD_VAR 0 2
105958: PUSH
105959: LD_VAR 0 4
105963: PLUS
105964: ST_TO_ADDR
// max_y := y + r ;
105965: LD_ADDR_VAR 0 10
105969: PUSH
105970: LD_VAR 0 3
105974: PUSH
105975: LD_VAR 0 4
105979: PLUS
105980: ST_TO_ADDR
// for _x = min_x to max_x do
105981: LD_ADDR_VAR 0 11
105985: PUSH
105986: DOUBLE
105987: LD_VAR 0 7
105991: DEC
105992: ST_TO_ADDR
105993: LD_VAR 0 9
105997: PUSH
105998: FOR_TO
105999: IFFALSE 106116
// for _y = min_y to max_y do
106001: LD_ADDR_VAR 0 12
106005: PUSH
106006: DOUBLE
106007: LD_VAR 0 8
106011: DEC
106012: ST_TO_ADDR
106013: LD_VAR 0 10
106017: PUSH
106018: FOR_TO
106019: IFFALSE 106112
// begin if not ValidHex ( _x , _y ) then
106021: LD_VAR 0 11
106025: PPUSH
106026: LD_VAR 0 12
106030: PPUSH
106031: CALL_OW 488
106035: NOT
106036: IFFALSE 106040
// continue ;
106038: GO 106018
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106040: LD_VAR 0 11
106044: PPUSH
106045: LD_VAR 0 12
106049: PPUSH
106050: CALL_OW 351
106054: PUSH
106055: LD_VAR 0 11
106059: PPUSH
106060: LD_VAR 0 12
106064: PPUSH
106065: CALL_OW 554
106069: AND
106070: IFFALSE 106110
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106072: LD_ADDR_VAR 0 13
106076: PUSH
106077: LD_VAR 0 13
106081: PPUSH
106082: LD_VAR 0 13
106086: PUSH
106087: LD_INT 1
106089: PLUS
106090: PPUSH
106091: LD_VAR 0 11
106095: PUSH
106096: LD_VAR 0 12
106100: PUSH
106101: EMPTY
106102: LIST
106103: LIST
106104: PPUSH
106105: CALL_OW 2
106109: ST_TO_ADDR
// end ;
106110: GO 106018
106112: POP
106113: POP
106114: GO 105998
106116: POP
106117: POP
// if not list then
106118: LD_VAR 0 13
106122: NOT
106123: IFFALSE 106127
// exit ;
106125: GO 106198
// for i in list do
106127: LD_ADDR_VAR 0 6
106131: PUSH
106132: LD_VAR 0 13
106136: PUSH
106137: FOR_IN
106138: IFFALSE 106196
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106140: LD_VAR 0 1
106144: PPUSH
106145: LD_STRING M
106147: PUSH
106148: LD_VAR 0 6
106152: PUSH
106153: LD_INT 1
106155: ARRAY
106156: PUSH
106157: LD_VAR 0 6
106161: PUSH
106162: LD_INT 2
106164: ARRAY
106165: PUSH
106166: LD_INT 0
106168: PUSH
106169: LD_INT 0
106171: PUSH
106172: LD_INT 0
106174: PUSH
106175: LD_INT 0
106177: PUSH
106178: EMPTY
106179: LIST
106180: LIST
106181: LIST
106182: LIST
106183: LIST
106184: LIST
106185: LIST
106186: PUSH
106187: EMPTY
106188: LIST
106189: PPUSH
106190: CALL_OW 447
106194: GO 106137
106196: POP
106197: POP
// end ;
106198: LD_VAR 0 5
106202: RET
