// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 34855 0 0
// InitNature ;
  19: CALL 34679 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 11057 0 0
// PrepareRussian ;
  40: CALL 6941 0 0
// PrepareLegion ;
  44: CALL 4181 0 0
// PreparePowell ;
  48: CALL 2918 0 0
// PrepareAmerican ;
  52: CALL 1690 0 0
// Action ;
  56: CALL 14951 0 0
// MC_Start ( ) ;
  60: CALL 36967 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := false ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAngerQuery := false ;
 116: LD_ADDR_EXP 36
 120: PUSH
 121: LD_INT 0
 123: ST_TO_ADDR
// powellAllowRetreat := true ;
 124: LD_ADDR_EXP 19
 128: PUSH
 129: LD_INT 1
 131: ST_TO_ADDR
// powellCenterCameraMode := false ;
 132: LD_ADDR_EXP 20
 136: PUSH
 137: LD_INT 0
 139: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 140: LD_ADDR_EXP 18
 144: PUSH
 145: EMPTY
 146: PUSH
 147: EMPTY
 148: PUSH
 149: EMPTY
 150: LIST
 151: LIST
 152: ST_TO_ADDR
// russianDestroyed := false ;
 153: LD_ADDR_EXP 21
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// legionDestroyed := false ;
 161: LD_ADDR_EXP 22
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// allianceDestroyed := false ;
 169: LD_ADDR_EXP 23
 173: PUSH
 174: LD_INT 0
 176: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 177: LD_ADDR_EXP 2
 181: PUSH
 182: LD_STRING 14_KappaStatus_1
 184: PPUSH
 185: LD_INT 0
 187: PPUSH
 188: CALL_OW 30
 192: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 193: LD_ADDR_EXP 3
 197: PUSH
 198: LD_STRING 06_KurtStatus_1
 200: PPUSH
 201: LD_INT 0
 203: PPUSH
 204: CALL_OW 30
 208: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 209: LD_ADDR_EXP 4
 213: PUSH
 214: LD_STRING 14_JMMVeh_1
 216: PPUSH
 217: LD_INT 0
 219: PPUSH
 220: CALL_OW 30
 224: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 225: LD_ADDR_EXP 5
 229: PUSH
 230: LD_STRING 14_JMMGirlVeh_1
 232: PPUSH
 233: LD_INT 0
 235: PPUSH
 236: CALL_OW 30
 240: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 241: LD_ADDR_EXP 7
 245: PUSH
 246: LD_STRING 14_JMMGirl_1
 248: PPUSH
 249: LD_INT 0
 251: PPUSH
 252: CALL_OW 30
 256: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 257: LD_ADDR_EXP 6
 261: PUSH
 262: LD_STRING 14_JMMGirlStatus_1
 264: PPUSH
 265: LD_INT 0
 267: PPUSH
 268: CALL_OW 30
 272: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 273: LD_ADDR_EXP 8
 277: PUSH
 278: LD_STRING 10_KhatamStatus_1
 280: PPUSH
 281: LD_INT 0
 283: PPUSH
 284: CALL_OW 30
 288: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 289: LD_ADDR_EXP 9
 293: PUSH
 294: LD_STRING 13_BurlakStatus_1
 296: PPUSH
 297: LD_INT 0
 299: PPUSH
 300: CALL_OW 30
 304: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 305: LD_ADDR_EXP 10
 309: PUSH
 310: LD_STRING 13_StevensStatus_1
 312: PPUSH
 313: LD_INT 0
 315: PPUSH
 316: CALL_OW 30
 320: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 321: LD_ADDR_EXP 11
 325: PUSH
 326: LD_STRING 14_FastEnd_1
 328: PPUSH
 329: LD_INT 0
 331: PPUSH
 332: CALL_OW 30
 336: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 337: LD_ADDR_EXP 12
 341: PUSH
 342: LD_STRING 12_MainDepositFake_1
 344: PPUSH
 345: LD_INT 0
 347: PPUSH
 348: CALL_OW 30
 352: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 353: LD_ADDR_EXP 24
 357: PUSH
 358: LD_INT 1
 360: ST_TO_ADDR
// behemothUnderConstruct := false ;
 361: LD_ADDR_EXP 26
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 369: LD_ADDR_EXP 27
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// behemothDone := false ;
 377: LD_ADDR_EXP 28
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// allowBehemothConstruct := false ;
 385: LD_ADDR_EXP 25
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// seeBehemoth := false ;
 393: LD_ADDR_EXP 29
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// platonovHasBomb := false ;
 401: LD_ADDR_EXP 30
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// allianceActive := false ;
 409: LD_ADDR_EXP 31
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// rothCaptured := false ;
 417: LD_ADDR_EXP 33
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// lostCounter := 0 ;
 425: LD_ADDR_EXP 32
 429: PUSH
 430: LD_INT 0
 432: ST_TO_ADDR
// capturedUnit := [ ] ;
 433: LD_ADDR_EXP 34
 437: PUSH
 438: EMPTY
 439: ST_TO_ADDR
// trueAmericans := [ ] ;
 440: LD_ADDR_EXP 35
 444: PUSH
 445: EMPTY
 446: ST_TO_ADDR
// bombExploded := false ;
 447: LD_ADDR_EXP 37
 451: PUSH
 452: LD_INT 0
 454: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 455: LD_ADDR_EXP 38
 459: PUSH
 460: EMPTY
 461: ST_TO_ADDR
// end ;
 462: LD_VAR 0 1
 466: RET
// export function CustomInitMacro ( ) ; begin
 467: LD_INT 0
 469: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 470: LD_ADDR_EXP 126
 474: PUSH
 475: LD_INT 2
 477: PUSH
 478: LD_INT 3
 480: PUSH
 481: LD_INT 6
 483: PUSH
 484: LD_INT 10
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 493: LD_ADDR_EXP 127
 497: PUSH
 498: LD_INT 1
 500: PUSH
 501: LD_INT 4
 503: PUSH
 504: LD_INT 5
 506: PUSH
 507: LD_INT 9
 509: PUSH
 510: EMPTY
 511: LIST
 512: LIST
 513: LIST
 514: LIST
 515: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 516: LD_INT 1
 518: PPUSH
 519: LD_INT 10
 521: PUSH
 522: LD_INT 11
 524: PUSH
 525: LD_INT 12
 527: PUSH
 528: EMPTY
 529: LIST
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 59244 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 17
 542: PUSH
 543: EMPTY
 544: LIST
 545: PPUSH
 546: CALL 59337 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 550: LD_INT 1
 552: PPUSH
 553: LD_INT 5
 555: PPUSH
 556: CALL 58687 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 560: LD_INT 1
 562: PPUSH
 563: LD_INT 24
 565: PUSH
 566: LD_INT 3
 568: PUSH
 569: LD_INT 3
 571: PUSH
 572: LD_INT 47
 574: PUSH
 575: EMPTY
 576: LIST
 577: LIST
 578: LIST
 579: LIST
 580: PUSH
 581: LD_INT 24
 583: PUSH
 584: LD_INT 3
 586: PUSH
 587: LD_INT 3
 589: PUSH
 590: LD_INT 47
 592: PUSH
 593: EMPTY
 594: LIST
 595: LIST
 596: LIST
 597: LIST
 598: PUSH
 599: LD_INT 24
 601: PUSH
 602: LD_INT 3
 604: PUSH
 605: LD_INT 3
 607: PUSH
 608: LD_INT 47
 610: PUSH
 611: EMPTY
 612: LIST
 613: LIST
 614: LIST
 615: LIST
 616: PUSH
 617: LD_INT 24
 619: PUSH
 620: LD_INT 3
 622: PUSH
 623: LD_INT 1
 625: PUSH
 626: LD_INT 47
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: LIST
 634: PUSH
 635: LD_INT 24
 637: PUSH
 638: LD_INT 3
 640: PUSH
 641: LD_INT 1
 643: PUSH
 644: LD_INT 47
 646: PUSH
 647: EMPTY
 648: LIST
 649: LIST
 650: LIST
 651: LIST
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: LIST
 659: PPUSH
 660: CALL 58502 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 664: LD_INT 2
 666: PPUSH
 667: LD_INT 10
 669: PUSH
 670: LD_INT 11
 672: PUSH
 673: LD_INT 12
 675: PUSH
 676: LD_INT 14
 678: PUSH
 679: EMPTY
 680: LIST
 681: LIST
 682: LIST
 683: LIST
 684: PPUSH
 685: CALL 59244 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 689: LD_INT 2
 691: PPUSH
 692: LD_INT 16
 694: PUSH
 695: EMPTY
 696: LIST
 697: PPUSH
 698: CALL 59337 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 702: LD_INT 2
 704: PPUSH
 705: LD_INT 21
 707: PUSH
 708: LD_INT 3
 710: PUSH
 711: LD_INT 3
 713: PUSH
 714: LD_INT 51
 716: PUSH
 717: EMPTY
 718: LIST
 719: LIST
 720: LIST
 721: LIST
 722: PUSH
 723: LD_INT 22
 725: PUSH
 726: LD_INT 3
 728: PUSH
 729: LD_INT 3
 731: PUSH
 732: LD_INT 52
 734: PUSH
 735: EMPTY
 736: LIST
 737: LIST
 738: LIST
 739: LIST
 740: PUSH
 741: LD_INT 22
 743: PUSH
 744: LD_INT 3
 746: PUSH
 747: LD_INT 3
 749: PUSH
 750: LD_INT 52
 752: PUSH
 753: EMPTY
 754: LIST
 755: LIST
 756: LIST
 757: LIST
 758: PUSH
 759: LD_INT 24
 761: PUSH
 762: LD_INT 3
 764: PUSH
 765: LD_INT 3
 767: PUSH
 768: LD_INT 47
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 24
 779: PUSH
 780: LD_INT 3
 782: PUSH
 783: LD_INT 3
 785: PUSH
 786: LD_INT 47
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 24
 797: PUSH
 798: LD_INT 3
 800: PUSH
 801: LD_INT 3
 803: PUSH
 804: LD_INT 47
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: LD_INT 24
 815: PUSH
 816: LD_INT 3
 818: PUSH
 819: LD_INT 3
 821: PUSH
 822: LD_INT 47
 824: PUSH
 825: EMPTY
 826: LIST
 827: LIST
 828: LIST
 829: LIST
 830: PUSH
 831: LD_INT 24
 833: PUSH
 834: LD_INT 3
 836: PUSH
 837: LD_INT 3
 839: PUSH
 840: LD_INT 47
 842: PUSH
 843: EMPTY
 844: LIST
 845: LIST
 846: LIST
 847: LIST
 848: PUSH
 849: EMPTY
 850: LIST
 851: LIST
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PPUSH
 859: CALL 58502 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 863: LD_INT 2
 865: PPUSH
 866: LD_INT 5
 868: PPUSH
 869: CALL 58687 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 873: LD_INT 2
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL 59117 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 883: LD_INT 3
 885: PPUSH
 886: LD_INT 10
 888: PUSH
 889: LD_INT 12
 891: PUSH
 892: LD_INT 15
 894: PUSH
 895: EMPTY
 896: LIST
 897: LIST
 898: LIST
 899: PUSH
 900: LD_OWVAR 67
 904: ARRAY
 905: PPUSH
 906: LD_INT 27
 908: PPUSH
 909: CALL 58184 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 913: LD_INT 3
 915: PPUSH
 916: LD_INT 10
 918: PUSH
 919: LD_INT 11
 921: PUSH
 922: LD_INT 13
 924: PUSH
 925: LD_INT 15
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: LIST
 933: PPUSH
 934: CALL 59244 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 15
 943: PUSH
 944: EMPTY
 945: LIST
 946: PPUSH
 947: CALL 59337 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 951: LD_ADDR_EXP 131
 955: PUSH
 956: LD_EXP 131
 960: PPUSH
 961: LD_INT 3
 963: PPUSH
 964: LD_INT 22
 966: PUSH
 967: LD_INT 8
 969: PUSH
 970: EMPTY
 971: LIST
 972: LIST
 973: PUSH
 974: LD_INT 25
 976: PUSH
 977: LD_INT 15
 979: PUSH
 980: EMPTY
 981: LIST
 982: LIST
 983: PUSH
 984: EMPTY
 985: LIST
 986: LIST
 987: PPUSH
 988: CALL_OW 69
 992: PPUSH
 993: CALL_OW 1
 997: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 998: LD_INT 3
1000: PPUSH
1001: LD_INT 13
1003: PUSH
1004: LD_INT 2
1006: PUSH
1007: LD_INT 1
1009: PUSH
1010: LD_INT 31
1012: PUSH
1013: EMPTY
1014: LIST
1015: LIST
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 13
1021: PUSH
1022: LD_INT 2
1024: PUSH
1025: LD_INT 1
1027: PUSH
1028: LD_INT 31
1030: PUSH
1031: EMPTY
1032: LIST
1033: LIST
1034: LIST
1035: LIST
1036: PUSH
1037: LD_INT 13
1039: PUSH
1040: LD_INT 3
1042: PUSH
1043: LD_INT 2
1045: PUSH
1046: LD_INT 32
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: PUSH
1055: EMPTY
1056: LIST
1057: LIST
1058: LIST
1059: PPUSH
1060: CALL 58502 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1064: LD_INT 4
1066: PPUSH
1067: LD_INT 10
1069: PUSH
1070: LD_INT 12
1072: PUSH
1073: EMPTY
1074: LIST
1075: LIST
1076: PPUSH
1077: CALL 59244 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1081: LD_INT 4
1083: PPUSH
1084: LD_INT 9
1086: PUSH
1087: EMPTY
1088: LIST
1089: PPUSH
1090: CALL 59337 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1094: LD_INT 4
1096: PPUSH
1097: LD_INT 26
1099: PUSH
1100: LD_INT 74
1102: PUSH
1103: LD_INT 107
1105: PUSH
1106: LD_INT 0
1108: PUSH
1109: EMPTY
1110: LIST
1111: LIST
1112: LIST
1113: LIST
1114: PUSH
1115: LD_INT 32
1117: PUSH
1118: LD_INT 77
1120: PUSH
1121: LD_INT 101
1123: PUSH
1124: LD_INT 4
1126: PUSH
1127: EMPTY
1128: LIST
1129: LIST
1130: LIST
1131: LIST
1132: PUSH
1133: LD_INT 32
1135: PUSH
1136: LD_INT 69
1138: PUSH
1139: LD_INT 86
1141: PUSH
1142: LD_INT 4
1144: PUSH
1145: EMPTY
1146: LIST
1147: LIST
1148: LIST
1149: LIST
1150: PUSH
1151: LD_INT 27
1153: PUSH
1154: LD_INT 77
1156: PUSH
1157: LD_INT 110
1159: PUSH
1160: LD_INT 3
1162: PUSH
1163: EMPTY
1164: LIST
1165: LIST
1166: LIST
1167: LIST
1168: PUSH
1169: LD_INT 27
1171: PUSH
1172: LD_INT 42
1174: PUSH
1175: LD_INT 79
1177: PUSH
1178: LD_INT 5
1180: PUSH
1181: EMPTY
1182: LIST
1183: LIST
1184: LIST
1185: LIST
1186: PUSH
1187: LD_INT 29
1189: PUSH
1190: LD_INT 86
1192: PUSH
1193: LD_INT 105
1195: PUSH
1196: LD_INT 2
1198: PUSH
1199: EMPTY
1200: LIST
1201: LIST
1202: LIST
1203: LIST
1204: PUSH
1205: LD_INT 30
1207: PUSH
1208: LD_INT 40
1210: PUSH
1211: LD_INT 75
1213: PUSH
1214: LD_INT 1
1216: PUSH
1217: EMPTY
1218: LIST
1219: LIST
1220: LIST
1221: LIST
1222: PUSH
1223: LD_INT 32
1225: PUSH
1226: LD_INT 80
1228: PUSH
1229: LD_INT 106
1231: PUSH
1232: LD_INT 4
1234: PUSH
1235: EMPTY
1236: LIST
1237: LIST
1238: LIST
1239: LIST
1240: PUSH
1241: LD_INT 32
1243: PUSH
1244: LD_INT 75
1246: PUSH
1247: LD_INT 114
1249: PUSH
1250: LD_INT 5
1252: PUSH
1253: EMPTY
1254: LIST
1255: LIST
1256: LIST
1257: LIST
1258: PUSH
1259: LD_INT 32
1261: PUSH
1262: LD_INT 82
1264: PUSH
1265: LD_INT 110
1267: PUSH
1268: LD_INT 5
1270: PUSH
1271: EMPTY
1272: LIST
1273: LIST
1274: LIST
1275: LIST
1276: PUSH
1277: LD_INT 32
1279: PUSH
1280: LD_INT 62
1282: PUSH
1283: LD_INT 78
1285: PUSH
1286: LD_INT 4
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_INT 4
1297: PUSH
1298: LD_INT 39
1300: PUSH
1301: LD_INT 61
1303: PUSH
1304: LD_INT 3
1306: PUSH
1307: EMPTY
1308: LIST
1309: LIST
1310: LIST
1311: LIST
1312: PUSH
1313: EMPTY
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: LIST
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: LIST
1324: LIST
1325: LIST
1326: PPUSH
1327: CALL 58394 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1331: LD_INT 4
1333: PPUSH
1334: LD_INT 5
1336: PUSH
1337: LD_INT 6
1339: PUSH
1340: LD_INT 7
1342: PUSH
1343: LD_INT 9
1345: PUSH
1346: EMPTY
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: PPUSH
1352: CALL 59655 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1356: LD_INT 4
1358: PPUSH
1359: LD_INT 40
1361: PUSH
1362: LD_INT 75
1364: PUSH
1365: LD_INT 1
1367: PUSH
1368: EMPTY
1369: LIST
1370: LIST
1371: LIST
1372: PUSH
1373: LD_INT 86
1375: PUSH
1376: LD_INT 105
1378: PUSH
1379: LD_INT 0
1381: PUSH
1382: EMPTY
1383: LIST
1384: LIST
1385: LIST
1386: PUSH
1387: EMPTY
1388: LIST
1389: LIST
1390: PPUSH
1391: CALL 58826 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1395: LD_INT 4
1397: PPUSH
1398: LD_INT 2
1400: PPUSH
1401: CALL 59117 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1405: LD_INT 4
1407: PPUSH
1408: LD_INT 0
1410: PPUSH
1411: CALL 59117 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1415: LD_INT 4
1417: PPUSH
1418: LD_INT 54
1420: PPUSH
1421: LD_INT 85
1423: PPUSH
1424: LD_INT 2
1426: PPUSH
1427: LD_INT 19
1429: PUSH
1430: LD_INT 16
1432: PUSH
1433: LD_INT 17
1435: PUSH
1436: LD_INT 18
1438: PUSH
1439: EMPTY
1440: LIST
1441: LIST
1442: LIST
1443: LIST
1444: PPUSH
1445: CALL 59449 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1449: LD_INT 4
1451: PPUSH
1452: LD_INT 3
1454: PUSH
1455: LD_INT 1
1457: PUSH
1458: LD_INT 1
1460: PUSH
1461: LD_INT 5
1463: PUSH
1464: EMPTY
1465: LIST
1466: LIST
1467: LIST
1468: LIST
1469: PUSH
1470: LD_INT 4
1472: PUSH
1473: LD_INT 1
1475: PUSH
1476: LD_INT 1
1478: PUSH
1479: LD_INT 6
1481: PUSH
1482: EMPTY
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: PUSH
1488: LD_INT 4
1490: PUSH
1491: LD_INT 1
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 7
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: LIST
1504: LIST
1505: PUSH
1506: LD_INT 4
1508: PUSH
1509: LD_INT 1
1511: PUSH
1512: LD_INT 1
1514: PUSH
1515: LD_INT 6
1517: PUSH
1518: EMPTY
1519: LIST
1520: LIST
1521: LIST
1522: LIST
1523: PUSH
1524: EMPTY
1525: LIST
1526: LIST
1527: LIST
1528: LIST
1529: PPUSH
1530: CALL 58502 0 2
// MC_SetTame ( 4 , powellApe ) ;
1534: LD_INT 4
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: CALL 59068 0 2
// end ;
1544: LD_VAR 0 1
1548: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1549: LD_EXP 36
1553: PUSH
1554: LD_EXP 17
1558: PUSH
1559: LD_INT 2
1561: GREATEREQUAL
1562: AND
1563: IFFALSE 1575
1565: GO 1567
1567: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1568: LD_STRING ACH_POWELL
1570: PPUSH
1571: CALL_OW 543
1575: END
// every 0 0$1 trigger debug do var i , tmp ;
1576: LD_EXP 1
1580: IFFALSE 1687
1582: GO 1584
1584: DISABLE
1585: LD_INT 0
1587: PPUSH
1588: PPUSH
// begin enable ;
1589: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1590: LD_ADDR_VAR 0 2
1594: PUSH
1595: LD_INT 22
1597: PUSH
1598: LD_INT 1
1600: PUSH
1601: EMPTY
1602: LIST
1603: LIST
1604: PUSH
1605: LD_INT 3
1607: PUSH
1608: LD_INT 21
1610: PUSH
1611: LD_INT 3
1613: PUSH
1614: EMPTY
1615: LIST
1616: LIST
1617: PUSH
1618: EMPTY
1619: LIST
1620: LIST
1621: PUSH
1622: LD_INT 3
1624: PUSH
1625: LD_INT 24
1627: PUSH
1628: LD_INT 999
1630: PUSH
1631: EMPTY
1632: LIST
1633: LIST
1634: PUSH
1635: EMPTY
1636: LIST
1637: LIST
1638: PUSH
1639: EMPTY
1640: LIST
1641: LIST
1642: LIST
1643: PPUSH
1644: CALL_OW 69
1648: ST_TO_ADDR
// if not tmp then
1649: LD_VAR 0 2
1653: NOT
1654: IFFALSE 1658
// exit ;
1656: GO 1687
// for i in tmp do
1658: LD_ADDR_VAR 0 1
1662: PUSH
1663: LD_VAR 0 2
1667: PUSH
1668: FOR_IN
1669: IFFALSE 1685
// SetLives ( i , 1000 ) ;
1671: LD_VAR 0 1
1675: PPUSH
1676: LD_INT 1000
1678: PPUSH
1679: CALL_OW 234
1683: GO 1668
1685: POP
1686: POP
// end ; end_of_file
1687: PPOPN 2
1689: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1690: LD_INT 0
1692: PPUSH
// uc_side := 1 ;
1693: LD_ADDR_OWVAR 20
1697: PUSH
1698: LD_INT 1
1700: ST_TO_ADDR
// uc_nation := 1 ;
1701: LD_ADDR_OWVAR 21
1705: PUSH
1706: LD_INT 1
1708: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1709: LD_ADDR_EXP 39
1713: PUSH
1714: LD_STRING JMM
1716: PPUSH
1717: LD_EXP 1
1721: NOT
1722: PPUSH
1723: LD_STRING 14_
1725: PPUSH
1726: CALL 64894 0 3
1730: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1731: LD_EXP 4
1735: NOT
1736: PUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 1
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: NOT
1750: OR
1751: IFFALSE 1774
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1753: LD_INT 5
1755: PPUSH
1756: LD_INT 3
1758: PPUSH
1759: LD_INT 1
1761: PPUSH
1762: LD_INT 9
1764: PPUSH
1765: LD_INT 100
1767: PPUSH
1768: CALL 72069 0 5
1772: GO 1833
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1774: LD_EXP 4
1778: PUSH
1779: LD_INT 1
1781: ARRAY
1782: PUSH
1783: LD_INT 1
1785: ARRAY
1786: PPUSH
1787: LD_EXP 4
1791: PUSH
1792: LD_INT 2
1794: ARRAY
1795: PUSH
1796: LD_INT 1
1798: ARRAY
1799: PPUSH
1800: LD_EXP 4
1804: PUSH
1805: LD_INT 3
1807: ARRAY
1808: PUSH
1809: LD_INT 1
1811: ARRAY
1812: PPUSH
1813: LD_EXP 4
1817: PUSH
1818: LD_INT 4
1820: ARRAY
1821: PUSH
1822: LD_INT 1
1824: ARRAY
1825: PPUSH
1826: LD_INT 30
1828: PPUSH
1829: CALL 72069 0 5
// JMMNewVeh := CreateVehicle ;
1833: LD_ADDR_EXP 56
1837: PUSH
1838: CALL_OW 45
1842: ST_TO_ADDR
// if not JMMNewVeh then
1843: LD_EXP 56
1847: NOT
1848: IFFALSE 1879
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1850: LD_INT 5
1852: PPUSH
1853: LD_INT 3
1855: PPUSH
1856: LD_INT 1
1858: PPUSH
1859: LD_INT 9
1861: PPUSH
1862: LD_INT 100
1864: PPUSH
1865: CALL 72069 0 5
// JMMNewVeh := CreateVehicle ;
1869: LD_ADDR_EXP 56
1873: PUSH
1874: CALL_OW 45
1878: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1879: LD_EXP 56
1883: PPUSH
1884: LD_INT 4
1886: PPUSH
1887: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1891: LD_EXP 56
1895: PPUSH
1896: LD_INT 79
1898: PPUSH
1899: LD_INT 91
1901: PPUSH
1902: LD_INT 0
1904: PPUSH
1905: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1909: LD_EXP 39
1913: PPUSH
1914: LD_EXP 56
1918: PPUSH
1919: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1923: LD_EXP 6
1927: PUSH
1928: LD_EXP 2
1932: NOT
1933: AND
1934: IFFALSE 2192
// begin if not JMMGirlVeh then
1936: LD_EXP 5
1940: NOT
1941: IFFALSE 1964
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1943: LD_INT 3
1945: PPUSH
1946: LD_INT 3
1948: PPUSH
1949: LD_INT 1
1951: PPUSH
1952: LD_INT 9
1954: PPUSH
1955: LD_INT 100
1957: PPUSH
1958: CALL 72069 0 5
1962: GO 2023
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1964: LD_EXP 5
1968: PUSH
1969: LD_INT 1
1971: ARRAY
1972: PUSH
1973: LD_INT 1
1975: ARRAY
1976: PPUSH
1977: LD_EXP 5
1981: PUSH
1982: LD_INT 2
1984: ARRAY
1985: PUSH
1986: LD_INT 1
1988: ARRAY
1989: PPUSH
1990: LD_EXP 5
1994: PUSH
1995: LD_INT 3
1997: ARRAY
1998: PUSH
1999: LD_INT 1
2001: ARRAY
2002: PPUSH
2003: LD_EXP 5
2007: PUSH
2008: LD_INT 4
2010: ARRAY
2011: PUSH
2012: LD_INT 1
2014: ARRAY
2015: PPUSH
2016: LD_INT 30
2018: PPUSH
2019: CALL 72069 0 5
// GirlNewVeh := CreateVehicle ;
2023: LD_ADDR_EXP 57
2027: PUSH
2028: CALL_OW 45
2032: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2033: LD_EXP 57
2037: PPUSH
2038: LD_INT 4
2040: PPUSH
2041: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2045: LD_EXP 57
2049: PPUSH
2050: LD_INT 82
2052: PPUSH
2053: LD_INT 96
2055: PPUSH
2056: LD_INT 0
2058: PPUSH
2059: CALL_OW 48
// if JMMGirl = 1 then
2063: LD_EXP 7
2067: PUSH
2068: LD_INT 1
2070: EQUAL
2071: IFFALSE 2106
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2073: LD_ADDR_EXP 40
2077: PUSH
2078: LD_STRING Joan
2080: PPUSH
2081: LD_INT 1
2083: PPUSH
2084: LD_STRING 14_
2086: PPUSH
2087: CALL 64894 0 3
2091: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2092: LD_EXP 40
2096: PPUSH
2097: LD_EXP 57
2101: PPUSH
2102: CALL_OW 52
// end ; if JMMGirl = 2 then
2106: LD_EXP 7
2110: PUSH
2111: LD_INT 2
2113: EQUAL
2114: IFFALSE 2149
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2116: LD_ADDR_EXP 42
2120: PUSH
2121: LD_STRING Lisa
2123: PPUSH
2124: LD_INT 1
2126: PPUSH
2127: LD_STRING 14_
2129: PPUSH
2130: CALL 64894 0 3
2134: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2135: LD_EXP 42
2139: PPUSH
2140: LD_EXP 57
2144: PPUSH
2145: CALL_OW 52
// end ; if JMMGirl = 3 then
2149: LD_EXP 7
2153: PUSH
2154: LD_INT 3
2156: EQUAL
2157: IFFALSE 2192
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2159: LD_ADDR_EXP 54
2163: PUSH
2164: LD_STRING Connie
2166: PPUSH
2167: LD_INT 1
2169: PPUSH
2170: LD_STRING 14_
2172: PPUSH
2173: CALL 64894 0 3
2177: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2178: LD_EXP 54
2182: PPUSH
2183: LD_EXP 57
2187: PPUSH
2188: CALL_OW 52
// end ; end ; end ;
2192: LD_VAR 0 1
2196: RET
// export function PrepareStevensSquad ; var tmp ; begin
2197: LD_INT 0
2199: PPUSH
2200: PPUSH
// uc_side := 1 ;
2201: LD_ADDR_OWVAR 20
2205: PUSH
2206: LD_INT 1
2208: ST_TO_ADDR
// uc_nation := 1 ;
2209: LD_ADDR_OWVAR 21
2213: PUSH
2214: LD_INT 1
2216: ST_TO_ADDR
// tmp := [ ] ;
2217: LD_ADDR_VAR 0 2
2221: PUSH
2222: EMPTY
2223: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2224: LD_ADDR_EXP 41
2228: PUSH
2229: LD_STRING Stevens
2231: PPUSH
2232: LD_EXP 1
2236: NOT
2237: PPUSH
2238: LD_STRING 13f_
2240: PPUSH
2241: CALL 64894 0 3
2245: ST_TO_ADDR
// if not Stevens then
2246: LD_EXP 41
2250: NOT
2251: IFFALSE 2307
// begin hc_name = Baker Smith ;
2253: LD_ADDR_OWVAR 26
2257: PUSH
2258: LD_STRING Baker Smith
2260: ST_TO_ADDR
// hc_gallery =  ;
2261: LD_ADDR_OWVAR 33
2265: PUSH
2266: LD_STRING 
2268: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2269: LD_INT 1
2271: PPUSH
2272: LD_INT 10
2274: PPUSH
2275: CALL_OW 384
// Baker = CreateHuman ;
2279: LD_ADDR_EXP 55
2283: PUSH
2284: CALL_OW 44
2288: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2289: LD_ADDR_VAR 0 2
2293: PUSH
2294: LD_VAR 0 2
2298: PUSH
2299: LD_EXP 55
2303: ADD
2304: ST_TO_ADDR
// end else
2305: GO 2323
// tmp := tmp ^ Stevens ;
2307: LD_ADDR_VAR 0 2
2311: PUSH
2312: LD_VAR 0 2
2316: PUSH
2317: LD_EXP 41
2321: ADD
2322: ST_TO_ADDR
// if not Lisa then
2323: LD_EXP 42
2327: NOT
2328: IFFALSE 2374
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2330: LD_ADDR_EXP 42
2334: PUSH
2335: LD_STRING Lisa
2337: PPUSH
2338: LD_EXP 1
2342: NOT
2343: PPUSH
2344: LD_STRING 13f_
2346: PPUSH
2347: CALL 64894 0 3
2351: ST_TO_ADDR
// if Lisa then
2352: LD_EXP 42
2356: IFFALSE 2374
// tmp := tmp ^ Lisa ;
2358: LD_ADDR_VAR 0 2
2362: PUSH
2363: LD_VAR 0 2
2367: PUSH
2368: LD_EXP 42
2372: ADD
2373: ST_TO_ADDR
// end ; if not Donaldson then
2374: LD_EXP 43
2378: NOT
2379: IFFALSE 2425
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2381: LD_ADDR_EXP 43
2385: PUSH
2386: LD_STRING Donaldson
2388: PPUSH
2389: LD_EXP 1
2393: NOT
2394: PPUSH
2395: LD_STRING 13f_
2397: PPUSH
2398: CALL 64894 0 3
2402: ST_TO_ADDR
// if Donaldson then
2403: LD_EXP 43
2407: IFFALSE 2425
// tmp := tmp ^ Donaldson ;
2409: LD_ADDR_VAR 0 2
2413: PUSH
2414: LD_VAR 0 2
2418: PUSH
2419: LD_EXP 43
2423: ADD
2424: ST_TO_ADDR
// end ; if not Bobby then
2425: LD_EXP 44
2429: NOT
2430: IFFALSE 2476
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2432: LD_ADDR_EXP 44
2436: PUSH
2437: LD_STRING Bobby
2439: PPUSH
2440: LD_EXP 1
2444: NOT
2445: PPUSH
2446: LD_STRING 13f_
2448: PPUSH
2449: CALL 64894 0 3
2453: ST_TO_ADDR
// if Bobby then
2454: LD_EXP 44
2458: IFFALSE 2476
// tmp := tmp ^ Bobby ;
2460: LD_ADDR_VAR 0 2
2464: PUSH
2465: LD_VAR 0 2
2469: PUSH
2470: LD_EXP 44
2474: ADD
2475: ST_TO_ADDR
// end ; if not Cyrus then
2476: LD_EXP 45
2480: NOT
2481: IFFALSE 2527
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2483: LD_ADDR_EXP 45
2487: PUSH
2488: LD_STRING Cyrus
2490: PPUSH
2491: LD_EXP 1
2495: NOT
2496: PPUSH
2497: LD_STRING 13f_
2499: PPUSH
2500: CALL 64894 0 3
2504: ST_TO_ADDR
// if Cyrus then
2505: LD_EXP 45
2509: IFFALSE 2527
// tmp := tmp ^ Cyrus ;
2511: LD_ADDR_VAR 0 2
2515: PUSH
2516: LD_VAR 0 2
2520: PUSH
2521: LD_EXP 45
2525: ADD
2526: ST_TO_ADDR
// end ; if not Brown then
2527: LD_EXP 47
2531: NOT
2532: IFFALSE 2578
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2534: LD_ADDR_EXP 47
2538: PUSH
2539: LD_STRING Brown
2541: PPUSH
2542: LD_EXP 1
2546: NOT
2547: PPUSH
2548: LD_STRING 13f_
2550: PPUSH
2551: CALL 64894 0 3
2555: ST_TO_ADDR
// if Brown then
2556: LD_EXP 47
2560: IFFALSE 2578
// tmp := tmp ^ Brown ;
2562: LD_ADDR_VAR 0 2
2566: PUSH
2567: LD_VAR 0 2
2571: PUSH
2572: LD_EXP 47
2576: ADD
2577: ST_TO_ADDR
// end ; if not Gladstone then
2578: LD_EXP 48
2582: NOT
2583: IFFALSE 2629
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2585: LD_ADDR_EXP 48
2589: PUSH
2590: LD_STRING Gladstone
2592: PPUSH
2593: LD_EXP 1
2597: NOT
2598: PPUSH
2599: LD_STRING 13f_
2601: PPUSH
2602: CALL 64894 0 3
2606: ST_TO_ADDR
// if Gladstone then
2607: LD_EXP 48
2611: IFFALSE 2629
// tmp := tmp ^ Gladstone ;
2613: LD_ADDR_VAR 0 2
2617: PUSH
2618: LD_VAR 0 2
2622: PUSH
2623: LD_EXP 48
2627: ADD
2628: ST_TO_ADDR
// end ; if not Houten then
2629: LD_EXP 49
2633: NOT
2634: IFFALSE 2680
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2636: LD_ADDR_EXP 49
2640: PUSH
2641: LD_STRING Houten
2643: PPUSH
2644: LD_EXP 1
2648: NOT
2649: PPUSH
2650: LD_STRING 13f_
2652: PPUSH
2653: CALL 64894 0 3
2657: ST_TO_ADDR
// if Houten then
2658: LD_EXP 49
2662: IFFALSE 2680
// tmp := tmp ^ Houten ;
2664: LD_ADDR_VAR 0 2
2668: PUSH
2669: LD_VAR 0 2
2673: PUSH
2674: LD_EXP 49
2678: ADD
2679: ST_TO_ADDR
// end ; if not Cornel then
2680: LD_EXP 50
2684: NOT
2685: IFFALSE 2731
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2687: LD_ADDR_EXP 50
2691: PUSH
2692: LD_STRING Cornell
2694: PPUSH
2695: LD_EXP 1
2699: NOT
2700: PPUSH
2701: LD_STRING 13f_
2703: PPUSH
2704: CALL 64894 0 3
2708: ST_TO_ADDR
// if Cornel then
2709: LD_EXP 50
2713: IFFALSE 2731
// tmp := tmp ^ Cornel ;
2715: LD_ADDR_VAR 0 2
2719: PUSH
2720: LD_VAR 0 2
2724: PUSH
2725: LD_EXP 50
2729: ADD
2730: ST_TO_ADDR
// end ; if not Gary then
2731: LD_EXP 51
2735: NOT
2736: IFFALSE 2782
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2738: LD_ADDR_EXP 51
2742: PUSH
2743: LD_STRING Gary
2745: PPUSH
2746: LD_EXP 1
2750: NOT
2751: PPUSH
2752: LD_STRING 13f_
2754: PPUSH
2755: CALL 64894 0 3
2759: ST_TO_ADDR
// if Gary then
2760: LD_EXP 51
2764: IFFALSE 2782
// tmp := tmp ^ Gary ;
2766: LD_ADDR_VAR 0 2
2770: PUSH
2771: LD_VAR 0 2
2775: PUSH
2776: LD_EXP 51
2780: ADD
2781: ST_TO_ADDR
// end ; if not Frank then
2782: LD_EXP 52
2786: NOT
2787: IFFALSE 2833
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2789: LD_ADDR_EXP 52
2793: PUSH
2794: LD_STRING Frank
2796: PPUSH
2797: LD_EXP 1
2801: NOT
2802: PPUSH
2803: LD_STRING 13f_
2805: PPUSH
2806: CALL 64894 0 3
2810: ST_TO_ADDR
// if Frank then
2811: LD_EXP 52
2815: IFFALSE 2833
// tmp := tmp ^ Frank ;
2817: LD_ADDR_VAR 0 2
2821: PUSH
2822: LD_VAR 0 2
2826: PUSH
2827: LD_EXP 52
2831: ADD
2832: ST_TO_ADDR
// end ; if not Kikuchi then
2833: LD_EXP 53
2837: NOT
2838: IFFALSE 2884
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2840: LD_ADDR_EXP 53
2844: PUSH
2845: LD_STRING Kikuchi
2847: PPUSH
2848: LD_EXP 1
2852: NOT
2853: PPUSH
2854: LD_STRING 13f_
2856: PPUSH
2857: CALL 64894 0 3
2861: ST_TO_ADDR
// if Kikuchi then
2862: LD_EXP 53
2866: IFFALSE 2884
// tmp := tmp ^ Kikuchi ;
2868: LD_ADDR_VAR 0 2
2872: PUSH
2873: LD_VAR 0 2
2877: PUSH
2878: LD_EXP 53
2882: ADD
2883: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2884: LD_ADDR_VAR 0 2
2888: PUSH
2889: LD_VAR 0 2
2893: PUSH
2894: LD_STRING 13_other_survivors
2896: PPUSH
2897: CALL_OW 31
2901: UNION
2902: ST_TO_ADDR
// result := tmp ;
2903: LD_ADDR_VAR 0 1
2907: PUSH
2908: LD_VAR 0 2
2912: ST_TO_ADDR
// end ; end_of_file
2913: LD_VAR 0 1
2917: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2918: LD_INT 0
2920: PPUSH
2921: PPUSH
2922: PPUSH
2923: PPUSH
2924: PPUSH
2925: PPUSH
2926: PPUSH
2927: PPUSH
2928: PPUSH
2929: PPUSH
// uc_side := 4 ;
2930: LD_ADDR_OWVAR 20
2934: PUSH
2935: LD_INT 4
2937: ST_TO_ADDR
// uc_nation := 1 ;
2938: LD_ADDR_OWVAR 21
2942: PUSH
2943: LD_INT 1
2945: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 ] [ Difficulty ] ) ;
2946: LD_INT 387
2948: PPUSH
2949: CALL_OW 274
2953: PPUSH
2954: LD_INT 1
2956: PPUSH
2957: LD_INT 3500
2959: PUSH
2960: LD_INT 3000
2962: PUSH
2963: LD_INT 2500
2965: PUSH
2966: EMPTY
2967: LIST
2968: LIST
2969: LIST
2970: PUSH
2971: LD_OWVAR 67
2975: ARRAY
2976: PPUSH
2977: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2981: LD_INT 387
2983: PPUSH
2984: CALL_OW 274
2988: PPUSH
2989: LD_INT 2
2991: PPUSH
2992: LD_INT 400
2994: PPUSH
2995: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2999: LD_INT 387
3001: PPUSH
3002: CALL_OW 274
3006: PPUSH
3007: LD_INT 3
3009: PPUSH
3010: LD_INT 10
3012: PPUSH
3013: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3017: LD_ADDR_EXP 58
3021: PUSH
3022: LD_STRING Powell
3024: PPUSH
3025: CALL_OW 25
3029: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3030: LD_EXP 58
3034: PPUSH
3035: LD_INT 57
3037: PPUSH
3038: LD_INT 94
3040: PPUSH
3041: LD_INT 0
3043: PPUSH
3044: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3048: LD_EXP 58
3052: PPUSH
3053: LD_INT 58
3055: PPUSH
3056: LD_INT 94
3058: PPUSH
3059: CALL_OW 118
// vip := [ ] ;
3063: LD_ADDR_EXP 59
3067: PUSH
3068: EMPTY
3069: ST_TO_ADDR
// tmp := [ ] ;
3070: LD_ADDR_VAR 0 6
3074: PUSH
3075: EMPTY
3076: ST_TO_ADDR
// if JMMGirl <> 2 then
3077: LD_EXP 7
3081: PUSH
3082: LD_INT 2
3084: NONEQUAL
3085: IFFALSE 3109
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3087: LD_ADDR_EXP 42
3091: PUSH
3092: LD_STRING Lisa
3094: PPUSH
3095: LD_EXP 1
3099: NOT
3100: PPUSH
3101: LD_STRING 13s_
3103: PPUSH
3104: CALL 64894 0 3
3108: ST_TO_ADDR
// if Lisa then
3109: LD_EXP 42
3113: IFFALSE 3131
// tmp := tmp ^ Lisa ;
3115: LD_ADDR_VAR 0 6
3119: PUSH
3120: LD_VAR 0 6
3124: PUSH
3125: LD_EXP 42
3129: ADD
3130: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3131: LD_ADDR_EXP 43
3135: PUSH
3136: LD_STRING Donaldson
3138: PPUSH
3139: LD_EXP 1
3143: NOT
3144: PPUSH
3145: LD_STRING 13s_
3147: PPUSH
3148: CALL 64894 0 3
3152: ST_TO_ADDR
// if Donaldson then
3153: LD_EXP 43
3157: IFFALSE 3175
// tmp := tmp ^ Donaldson ;
3159: LD_ADDR_VAR 0 6
3163: PUSH
3164: LD_VAR 0 6
3168: PUSH
3169: LD_EXP 43
3173: ADD
3174: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3175: LD_ADDR_EXP 44
3179: PUSH
3180: LD_STRING Bobby
3182: PPUSH
3183: LD_EXP 1
3187: NOT
3188: PPUSH
3189: LD_STRING 13s_
3191: PPUSH
3192: CALL 64894 0 3
3196: ST_TO_ADDR
// if Bobby then
3197: LD_EXP 44
3201: IFFALSE 3219
// tmp := tmp ^ Bobby ;
3203: LD_ADDR_VAR 0 6
3207: PUSH
3208: LD_VAR 0 6
3212: PUSH
3213: LD_EXP 44
3217: ADD
3218: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3219: LD_ADDR_EXP 45
3223: PUSH
3224: LD_STRING Cyrus
3226: PPUSH
3227: LD_EXP 1
3231: NOT
3232: PPUSH
3233: LD_STRING 13s_
3235: PPUSH
3236: CALL 64894 0 3
3240: ST_TO_ADDR
// if Cyrus then
3241: LD_EXP 45
3245: IFFALSE 3263
// tmp := tmp ^ Cyrus ;
3247: LD_ADDR_VAR 0 6
3251: PUSH
3252: LD_VAR 0 6
3256: PUSH
3257: LD_EXP 45
3261: ADD
3262: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3263: LD_ADDR_EXP 46
3267: PUSH
3268: LD_STRING Denis
3270: PPUSH
3271: LD_EXP 1
3275: NOT
3276: PPUSH
3277: LD_STRING 13s_
3279: PPUSH
3280: CALL 64894 0 3
3284: ST_TO_ADDR
// if not Denis then
3285: LD_EXP 46
3289: NOT
3290: IFFALSE 3314
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3292: LD_ADDR_EXP 46
3296: PUSH
3297: LD_STRING Denis
3299: PPUSH
3300: LD_EXP 1
3304: NOT
3305: PPUSH
3306: LD_STRING 13f_
3308: PPUSH
3309: CALL 64894 0 3
3313: ST_TO_ADDR
// if Denis then
3314: LD_EXP 46
3318: IFFALSE 3336
// tmp := tmp ^ Denis ;
3320: LD_ADDR_VAR 0 6
3324: PUSH
3325: LD_VAR 0 6
3329: PUSH
3330: LD_EXP 46
3334: ADD
3335: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3336: LD_ADDR_EXP 47
3340: PUSH
3341: LD_STRING Brown
3343: PPUSH
3344: LD_EXP 1
3348: NOT
3349: PPUSH
3350: LD_STRING 13s_
3352: PPUSH
3353: CALL 64894 0 3
3357: ST_TO_ADDR
// if Brown then
3358: LD_EXP 47
3362: IFFALSE 3380
// tmp := tmp ^ Brown ;
3364: LD_ADDR_VAR 0 6
3368: PUSH
3369: LD_VAR 0 6
3373: PUSH
3374: LD_EXP 47
3378: ADD
3379: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3380: LD_ADDR_EXP 48
3384: PUSH
3385: LD_STRING Gladstone
3387: PPUSH
3388: LD_EXP 1
3392: NOT
3393: PPUSH
3394: LD_STRING 13s_
3396: PPUSH
3397: CALL 64894 0 3
3401: ST_TO_ADDR
// if Gladstone then
3402: LD_EXP 48
3406: IFFALSE 3424
// tmp := tmp ^ Gladstone ;
3408: LD_ADDR_VAR 0 6
3412: PUSH
3413: LD_VAR 0 6
3417: PUSH
3418: LD_EXP 48
3422: ADD
3423: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3424: LD_ADDR_EXP 49
3428: PUSH
3429: LD_STRING Houten
3431: PPUSH
3432: LD_EXP 1
3436: NOT
3437: PPUSH
3438: LD_STRING 13s_
3440: PPUSH
3441: CALL 64894 0 3
3445: ST_TO_ADDR
// if Houten then
3446: LD_EXP 49
3450: IFFALSE 3468
// tmp := tmp ^ Houten ;
3452: LD_ADDR_VAR 0 6
3456: PUSH
3457: LD_VAR 0 6
3461: PUSH
3462: LD_EXP 49
3466: ADD
3467: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3468: LD_ADDR_EXP 50
3472: PUSH
3473: LD_STRING Cornel
3475: PPUSH
3476: LD_EXP 1
3480: NOT
3481: PPUSH
3482: LD_STRING 13s_
3484: PPUSH
3485: CALL 64894 0 3
3489: ST_TO_ADDR
// if Cornel then
3490: LD_EXP 50
3494: IFFALSE 3512
// tmp := tmp ^ Cornel ;
3496: LD_ADDR_VAR 0 6
3500: PUSH
3501: LD_VAR 0 6
3505: PUSH
3506: LD_EXP 50
3510: ADD
3511: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3512: LD_ADDR_EXP 51
3516: PUSH
3517: LD_STRING Gary
3519: PPUSH
3520: LD_EXP 1
3524: NOT
3525: PPUSH
3526: LD_STRING 13s_
3528: PPUSH
3529: CALL 64894 0 3
3533: ST_TO_ADDR
// if Gary then
3534: LD_EXP 51
3538: IFFALSE 3556
// tmp := tmp ^ Gary ;
3540: LD_ADDR_VAR 0 6
3544: PUSH
3545: LD_VAR 0 6
3549: PUSH
3550: LD_EXP 51
3554: ADD
3555: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3556: LD_ADDR_EXP 52
3560: PUSH
3561: LD_STRING Frank
3563: PPUSH
3564: LD_EXP 1
3568: NOT
3569: PPUSH
3570: LD_STRING 13s_
3572: PPUSH
3573: CALL 64894 0 3
3577: ST_TO_ADDR
// if Frank then
3578: LD_EXP 52
3582: IFFALSE 3600
// tmp := tmp ^ Frank ;
3584: LD_ADDR_VAR 0 6
3588: PUSH
3589: LD_VAR 0 6
3593: PUSH
3594: LD_EXP 52
3598: ADD
3599: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3600: LD_ADDR_EXP 53
3604: PUSH
3605: LD_STRING Kikuchi
3607: PPUSH
3608: LD_EXP 1
3612: NOT
3613: PPUSH
3614: LD_STRING 13s_
3616: PPUSH
3617: CALL 64894 0 3
3621: ST_TO_ADDR
// if Kikuchi then
3622: LD_EXP 53
3626: IFFALSE 3644
// tmp := tmp ^ Kikuchi ;
3628: LD_ADDR_VAR 0 6
3632: PUSH
3633: LD_VAR 0 6
3637: PUSH
3638: LD_EXP 53
3642: ADD
3643: ST_TO_ADDR
// vip := tmp ;
3644: LD_ADDR_EXP 59
3648: PUSH
3649: LD_VAR 0 6
3653: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3654: LD_ADDR_VAR 0 6
3658: PUSH
3659: LD_VAR 0 6
3663: PUSH
3664: LD_STRING 13s_others
3666: PPUSH
3667: CALL_OW 31
3671: UNION
3672: ST_TO_ADDR
// if tmp < 20 then
3673: LD_VAR 0 6
3677: PUSH
3678: LD_INT 20
3680: LESS
3681: IFFALSE 3748
// for i = 1 to 20 - tmp do
3683: LD_ADDR_VAR 0 2
3687: PUSH
3688: DOUBLE
3689: LD_INT 1
3691: DEC
3692: ST_TO_ADDR
3693: LD_INT 20
3695: PUSH
3696: LD_VAR 0 6
3700: MINUS
3701: PUSH
3702: FOR_TO
3703: IFFALSE 3746
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3705: LD_INT 1
3707: PPUSH
3708: LD_VAR 0 2
3712: PUSH
3713: LD_INT 4
3715: MOD
3716: PUSH
3717: LD_INT 1
3719: PLUS
3720: PPUSH
3721: LD_INT 5
3723: PPUSH
3724: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3728: LD_ADDR_VAR 0 6
3732: PUSH
3733: LD_VAR 0 6
3737: PUSH
3738: CALL_OW 44
3742: ADD
3743: ST_TO_ADDR
// end ;
3744: GO 3702
3746: POP
3747: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3748: LD_ADDR_VAR 0 7
3752: PUSH
3753: LD_INT 22
3755: PUSH
3756: LD_INT 4
3758: PUSH
3759: EMPTY
3760: LIST
3761: LIST
3762: PUSH
3763: LD_INT 30
3765: PUSH
3766: LD_INT 0
3768: PUSH
3769: EMPTY
3770: LIST
3771: LIST
3772: PUSH
3773: EMPTY
3774: LIST
3775: LIST
3776: PPUSH
3777: CALL_OW 69
3781: PUSH
3782: LD_INT 1
3784: ARRAY
3785: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3786: LD_ADDR_VAR 0 8
3790: PUSH
3791: LD_INT 22
3793: PUSH
3794: LD_INT 4
3796: PUSH
3797: EMPTY
3798: LIST
3799: LIST
3800: PUSH
3801: LD_INT 30
3803: PUSH
3804: LD_INT 6
3806: PUSH
3807: EMPTY
3808: LIST
3809: LIST
3810: PUSH
3811: EMPTY
3812: LIST
3813: LIST
3814: PPUSH
3815: CALL_OW 69
3819: PUSH
3820: LD_INT 1
3822: ARRAY
3823: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3824: LD_ADDR_VAR 0 9
3828: PUSH
3829: LD_INT 22
3831: PUSH
3832: LD_INT 4
3834: PUSH
3835: EMPTY
3836: LIST
3837: LIST
3838: PUSH
3839: LD_INT 30
3841: PUSH
3842: LD_INT 4
3844: PUSH
3845: EMPTY
3846: LIST
3847: LIST
3848: PUSH
3849: EMPTY
3850: LIST
3851: LIST
3852: PPUSH
3853: CALL_OW 69
3857: PUSH
3858: LD_INT 1
3860: ARRAY
3861: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3862: LD_ADDR_VAR 0 10
3866: PUSH
3867: LD_INT 22
3869: PUSH
3870: LD_INT 4
3872: PUSH
3873: EMPTY
3874: LIST
3875: LIST
3876: PUSH
3877: LD_INT 30
3879: PUSH
3880: LD_INT 2
3882: PUSH
3883: EMPTY
3884: LIST
3885: LIST
3886: PUSH
3887: EMPTY
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL_OW 69
3895: PUSH
3896: LD_INT 1
3898: ARRAY
3899: ST_TO_ADDR
// for i in tmp do
3900: LD_ADDR_VAR 0 2
3904: PUSH
3905: LD_VAR 0 6
3909: PUSH
3910: FOR_IN
3911: IFFALSE 4037
// begin cl := GetClass ( i ) ;
3913: LD_ADDR_VAR 0 5
3917: PUSH
3918: LD_VAR 0 2
3922: PPUSH
3923: CALL_OW 257
3927: ST_TO_ADDR
// if cl > 4 then
3928: LD_VAR 0 5
3932: PUSH
3933: LD_INT 4
3935: GREATER
3936: IFFALSE 3946
// cl := 1 ;
3938: LD_ADDR_VAR 0 5
3942: PUSH
3943: LD_INT 1
3945: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3946: LD_ADDR_VAR 0 3
3950: PUSH
3951: LD_VAR 0 9
3955: PUSH
3956: LD_VAR 0 7
3960: PUSH
3961: LD_VAR 0 10
3965: PUSH
3966: LD_VAR 0 8
3970: PUSH
3971: EMPTY
3972: LIST
3973: LIST
3974: LIST
3975: LIST
3976: PUSH
3977: LD_VAR 0 5
3981: ARRAY
3982: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3983: LD_VAR 0 3
3987: PPUSH
3988: CALL_OW 313
3992: PUSH
3993: LD_INT 5
3995: LESS
3996: IFFALSE 4014
// PlaceHumanInUnit ( i , b ) else
3998: LD_VAR 0 2
4002: PPUSH
4003: LD_VAR 0 3
4007: PPUSH
4008: CALL_OW 52
4012: GO 4035
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
4014: LD_VAR 0 2
4018: PPUSH
4019: LD_INT 58
4021: PPUSH
4022: LD_INT 91
4024: PPUSH
4025: LD_INT 6
4027: PPUSH
4028: LD_INT 0
4030: PPUSH
4031: CALL_OW 50
// end ;
4035: GO 3910
4037: POP
4038: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4039: LD_INT 2
4041: PPUSH
4042: LD_INT 1
4044: PPUSH
4045: LD_INT 1
4047: PPUSH
4048: LD_INT 12
4050: PPUSH
4051: LD_INT 100
4053: PPUSH
4054: CALL 72069 0 5
// veh := CreateVehicle ;
4058: LD_ADDR_VAR 0 4
4062: PUSH
4063: CALL_OW 45
4067: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4068: LD_VAR 0 4
4072: PPUSH
4073: LD_INT 4
4075: PPUSH
4076: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4080: LD_VAR 0 4
4084: PPUSH
4085: LD_INT 49
4087: PPUSH
4088: LD_INT 88
4090: PPUSH
4091: LD_INT 0
4093: PPUSH
4094: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4098: LD_VAR 0 4
4102: PPUSH
4103: LD_INT 1
4105: PPUSH
4106: LD_INT 100
4108: PPUSH
4109: CALL_OW 290
// uc_side := 0 ;
4113: LD_ADDR_OWVAR 20
4117: PUSH
4118: LD_INT 0
4120: ST_TO_ADDR
// uc_nation := 0 ;
4121: LD_ADDR_OWVAR 21
4125: PUSH
4126: LD_INT 0
4128: ST_TO_ADDR
// for i = 1 to 4 do
4129: LD_ADDR_VAR 0 2
4133: PUSH
4134: DOUBLE
4135: LD_INT 1
4137: DEC
4138: ST_TO_ADDR
4139: LD_INT 4
4141: PUSH
4142: FOR_TO
4143: IFFALSE 4174
// begin InitHc ;
4145: CALL_OW 19
// hc_class := class_apeman ;
4149: LD_ADDR_OWVAR 28
4153: PUSH
4154: LD_INT 12
4156: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4157: CALL_OW 44
4161: PPUSH
4162: LD_INT 13
4164: PPUSH
4165: LD_INT 0
4167: PPUSH
4168: CALL_OW 49
// end ;
4172: GO 4142
4174: POP
4175: POP
// end ; end_of_file
4176: LD_VAR 0 1
4180: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4181: LD_INT 0
4183: PPUSH
4184: PPUSH
4185: PPUSH
4186: PPUSH
4187: PPUSH
// side := 8 ;
4188: LD_ADDR_VAR 0 3
4192: PUSH
4193: LD_INT 8
4195: ST_TO_ADDR
// uc_side := side ;
4196: LD_ADDR_OWVAR 20
4200: PUSH
4201: LD_VAR 0 3
4205: ST_TO_ADDR
// uc_nation := 2 ;
4206: LD_ADDR_OWVAR 21
4210: PUSH
4211: LD_INT 2
4213: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4214: LD_ADDR_VAR 0 2
4218: PUSH
4219: LD_INT 22
4221: PUSH
4222: LD_VAR 0 3
4226: PUSH
4227: EMPTY
4228: LIST
4229: LIST
4230: PUSH
4231: LD_INT 21
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: PUSH
4241: EMPTY
4242: LIST
4243: LIST
4244: PPUSH
4245: CALL_OW 69
4249: PUSH
4250: FOR_IN
4251: IFFALSE 4267
// SetBLevel ( i , 10 ) ;
4253: LD_VAR 0 2
4257: PPUSH
4258: LD_INT 10
4260: PPUSH
4261: CALL_OW 241
4265: GO 4250
4267: POP
4268: POP
// if KurtStatus then
4269: LD_EXP 3
4273: IFFALSE 4296
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4275: LD_ADDR_EXP 60
4279: PUSH
4280: LD_STRING Kurt
4282: PPUSH
4283: LD_INT 0
4285: PPUSH
4286: LD_STRING 
4288: PPUSH
4289: CALL 64894 0 3
4293: ST_TO_ADDR
4294: GO 4318
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4296: LD_ADDR_EXP 60
4300: PUSH
4301: LD_STRING AltKurt
4303: PPUSH
4304: LD_EXP 1
4308: NOT
4309: PPUSH
4310: LD_STRING 
4312: PPUSH
4313: CALL 64894 0 3
4317: ST_TO_ADDR
// if not Kurt then
4318: LD_EXP 60
4322: NOT
4323: IFFALSE 4349
// begin InitHc ;
4325: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 10
4334: PPUSH
4335: CALL_OW 381
// Kurt := CreateHuman ;
4339: LD_ADDR_EXP 60
4343: PUSH
4344: CALL_OW 44
4348: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4349: LD_EXP 60
4353: PPUSH
4354: LD_INT 324
4356: PPUSH
4357: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4361: LD_ADDR_EXP 61
4365: PUSH
4366: LD_STRING Kozlov
4368: PPUSH
4369: LD_INT 0
4371: PPUSH
4372: LD_STRING 
4374: PPUSH
4375: CALL 64894 0 3
4379: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4380: LD_EXP 61
4384: PPUSH
4385: LD_INT 22
4387: PUSH
4388: LD_INT 8
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 23
4397: PUSH
4398: LD_INT 3
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 30
4407: PUSH
4408: LD_INT 8
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: EMPTY
4416: LIST
4417: LIST
4418: LIST
4419: PPUSH
4420: CALL_OW 69
4424: PUSH
4425: LD_INT 1
4427: ARRAY
4428: PPUSH
4429: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4433: LD_EXP 61
4437: PPUSH
4438: LD_INT 3
4440: PPUSH
4441: LD_INT 10
4443: PPUSH
4444: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4448: LD_ADDR_VAR 0 5
4452: PUSH
4453: LD_INT 22
4455: PUSH
4456: LD_VAR 0 3
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: PUSH
4465: LD_INT 30
4467: PUSH
4468: LD_INT 32
4470: PUSH
4471: EMPTY
4472: LIST
4473: LIST
4474: PUSH
4475: LD_INT 58
4477: PUSH
4478: EMPTY
4479: LIST
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: PPUSH
4486: CALL_OW 69
4490: ST_TO_ADDR
// for i = 1 to 10 do
4491: LD_ADDR_VAR 0 2
4495: PUSH
4496: DOUBLE
4497: LD_INT 1
4499: DEC
4500: ST_TO_ADDR
4501: LD_INT 10
4503: PUSH
4504: FOR_TO
4505: IFFALSE 4577
// begin uc_nation := nation_nature ;
4507: LD_ADDR_OWVAR 21
4511: PUSH
4512: LD_INT 0
4514: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4515: LD_ADDR_OWVAR 28
4519: PUSH
4520: LD_INT 15
4522: ST_TO_ADDR
// hc_gallery :=  ;
4523: LD_ADDR_OWVAR 33
4527: PUSH
4528: LD_STRING 
4530: ST_TO_ADDR
// hc_name :=  ;
4531: LD_ADDR_OWVAR 26
4535: PUSH
4536: LD_STRING 
4538: ST_TO_ADDR
// un := CreateHuman ;
4539: LD_ADDR_VAR 0 4
4543: PUSH
4544: CALL_OW 44
4548: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4549: LD_VAR 0 4
4553: PPUSH
4554: LD_VAR 0 5
4558: PUSH
4559: LD_VAR 0 5
4563: PUSH
4564: LD_VAR 0 2
4568: MINUS
4569: ARRAY
4570: PPUSH
4571: CALL_OW 52
// end ;
4575: GO 4504
4577: POP
4578: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4579: LD_ADDR_VAR 0 5
4583: PUSH
4584: LD_STRING 12_kurt_squad
4586: PPUSH
4587: CALL_OW 31
4591: ST_TO_ADDR
// if tmp then
4592: LD_VAR 0 5
4596: IFFALSE 4630
// for i in tmp do
4598: LD_ADDR_VAR 0 2
4602: PUSH
4603: LD_VAR 0 5
4607: PUSH
4608: FOR_IN
4609: IFFALSE 4628
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4611: LD_VAR 0 2
4615: PPUSH
4616: LD_INT 5
4618: PPUSH
4619: LD_INT 0
4621: PPUSH
4622: CALL_OW 49
4626: GO 4608
4628: POP
4629: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4630: LD_INT 324
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_STRING 
4638: PPUSH
4639: LD_INT 8
4641: PUSH
4642: LD_INT 9
4644: PUSH
4645: LD_INT 10
4647: PUSH
4648: EMPTY
4649: LIST
4650: LIST
4651: LIST
4652: PUSH
4653: LD_OWVAR 67
4657: ARRAY
4658: PPUSH
4659: LD_INT 3000
4661: PUSH
4662: LD_INT 500
4664: PUSH
4665: LD_INT 150
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: LIST
4672: PPUSH
4673: LD_INT 16
4675: PUSH
4676: LD_INT 6
4678: PUSH
4679: LD_INT 6
4681: PUSH
4682: LD_INT 8
4684: PUSH
4685: EMPTY
4686: LIST
4687: LIST
4688: LIST
4689: LIST
4690: PPUSH
4691: CALL 75478 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4695: LD_ADDR_EXP 102
4699: PUSH
4700: LD_EXP 102
4704: PPUSH
4705: LD_INT 3
4707: PPUSH
4708: LD_INT 22
4710: PUSH
4711: LD_VAR 0 3
4715: PUSH
4716: EMPTY
4717: LIST
4718: LIST
4719: PUSH
4720: LD_INT 23
4722: PUSH
4723: LD_INT 2
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 3
4732: PUSH
4733: LD_INT 21
4735: PUSH
4736: LD_INT 2
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: LIST
4751: PPUSH
4752: CALL_OW 69
4756: PUSH
4757: LD_EXP 60
4761: DIFF
4762: PPUSH
4763: CALL_OW 1
4767: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4768: LD_INT 1
4770: PPUSH
4771: LD_INT 7
4773: PPUSH
4774: CALL_OW 383
// Friend := CreateHuman ;
4778: LD_ADDR_EXP 62
4782: PUSH
4783: CALL_OW 44
4787: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4788: LD_INT 14
4790: PPUSH
4791: LD_INT 3
4793: PPUSH
4794: LD_INT 1
4796: PPUSH
4797: LD_INT 29
4799: PPUSH
4800: LD_INT 100
4802: PPUSH
4803: CALL 72069 0 5
// powellBomb := CreateVehicle ;
4807: LD_ADDR_EXP 63
4811: PUSH
4812: CALL_OW 45
4816: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4817: LD_EXP 63
4821: PPUSH
4822: LD_INT 90
4824: PPUSH
4825: LD_INT 51
4827: PPUSH
4828: LD_INT 0
4830: PPUSH
4831: CALL_OW 48
// end ;
4835: LD_VAR 0 1
4839: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4840: LD_INT 0
4842: PPUSH
4843: PPUSH
4844: PPUSH
// if IsLive ( kozlov_fac ) then
4845: LD_INT 332
4847: PPUSH
4848: CALL_OW 300
4852: IFFALSE 4856
// exit ;
4854: GO 5423
// ComExitBuilding ( Kozlov ) ;
4856: LD_EXP 61
4860: PPUSH
4861: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4865: LD_EXP 61
4869: PPUSH
4870: CALL_OW 257
4874: PUSH
4875: LD_INT 2
4877: NONEQUAL
4878: IFFALSE 4913
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4880: LD_EXP 61
4884: PPUSH
4885: LD_INT 324
4887: PPUSH
4888: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4892: LD_EXP 61
4896: PPUSH
4897: LD_INT 2
4899: PPUSH
4900: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4904: LD_EXP 61
4908: PPUSH
4909: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4913: LD_EXP 61
4917: PPUSH
4918: LD_INT 2
4920: PPUSH
4921: LD_INT 93
4923: PPUSH
4924: LD_INT 32
4926: PPUSH
4927: LD_INT 3
4929: PPUSH
4930: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4934: LD_INT 35
4936: PPUSH
4937: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4941: LD_INT 22
4943: PUSH
4944: LD_INT 8
4946: PUSH
4947: EMPTY
4948: LIST
4949: LIST
4950: PUSH
4951: LD_INT 30
4953: PUSH
4954: LD_INT 3
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: PUSH
4961: LD_INT 23
4963: PUSH
4964: LD_INT 3
4966: PUSH
4967: EMPTY
4968: LIST
4969: LIST
4970: PUSH
4971: LD_INT 57
4973: PUSH
4974: EMPTY
4975: LIST
4976: PUSH
4977: EMPTY
4978: LIST
4979: LIST
4980: LIST
4981: LIST
4982: PPUSH
4983: CALL_OW 69
4987: IFFALSE 4934
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4989: LD_ADDR_VAR 0 2
4993: PUSH
4994: LD_INT 22
4996: PUSH
4997: LD_INT 8
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 30
5006: PUSH
5007: LD_INT 3
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PUSH
5014: LD_INT 23
5016: PUSH
5017: LD_INT 3
5019: PUSH
5020: EMPTY
5021: LIST
5022: LIST
5023: PUSH
5024: LD_INT 57
5026: PUSH
5027: EMPTY
5028: LIST
5029: PUSH
5030: EMPTY
5031: LIST
5032: LIST
5033: LIST
5034: LIST
5035: PPUSH
5036: CALL_OW 69
5040: PUSH
5041: LD_INT 1
5043: ARRAY
5044: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5045: LD_INT 22
5047: PUSH
5048: LD_INT 8
5050: PUSH
5051: EMPTY
5052: LIST
5053: LIST
5054: PUSH
5055: LD_INT 23
5057: PUSH
5058: LD_INT 3
5060: PUSH
5061: EMPTY
5062: LIST
5063: LIST
5064: PUSH
5065: LD_INT 30
5067: PUSH
5068: LD_INT 21
5070: PUSH
5071: EMPTY
5072: LIST
5073: LIST
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: LIST
5079: PPUSH
5080: CALL_OW 69
5084: NOT
5085: IFFALSE 5163
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5087: LD_EXP 61
5091: PPUSH
5092: LD_INT 21
5094: PPUSH
5095: LD_INT 97
5097: PPUSH
5098: LD_INT 36
5100: PPUSH
5101: LD_INT 5
5103: PPUSH
5104: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5108: LD_INT 35
5110: PPUSH
5111: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5115: LD_INT 22
5117: PUSH
5118: LD_INT 8
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PUSH
5125: LD_INT 23
5127: PUSH
5128: LD_INT 3
5130: PUSH
5131: EMPTY
5132: LIST
5133: LIST
5134: PUSH
5135: LD_INT 30
5137: PUSH
5138: LD_INT 21
5140: PUSH
5141: EMPTY
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 57
5147: PUSH
5148: EMPTY
5149: LIST
5150: PUSH
5151: EMPTY
5152: LIST
5153: LIST
5154: LIST
5155: LIST
5156: PPUSH
5157: CALL_OW 69
5161: IFFALSE 5108
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5163: LD_INT 22
5165: PUSH
5166: LD_INT 8
5168: PUSH
5169: EMPTY
5170: LIST
5171: LIST
5172: PUSH
5173: LD_INT 23
5175: PUSH
5176: LD_INT 3
5178: PUSH
5179: EMPTY
5180: LIST
5181: LIST
5182: PUSH
5183: LD_INT 30
5185: PUSH
5186: LD_INT 18
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: NOT
5203: IFFALSE 5281
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5205: LD_EXP 61
5209: PPUSH
5210: LD_INT 18
5212: PPUSH
5213: LD_INT 89
5215: PPUSH
5216: LD_INT 32
5218: PPUSH
5219: LD_INT 1
5221: PPUSH
5222: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5226: LD_INT 35
5228: PPUSH
5229: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5233: LD_INT 22
5235: PUSH
5236: LD_INT 8
5238: PUSH
5239: EMPTY
5240: LIST
5241: LIST
5242: PUSH
5243: LD_INT 23
5245: PUSH
5246: LD_INT 3
5248: PUSH
5249: EMPTY
5250: LIST
5251: LIST
5252: PUSH
5253: LD_INT 30
5255: PUSH
5256: LD_INT 18
5258: PUSH
5259: EMPTY
5260: LIST
5261: LIST
5262: PUSH
5263: LD_INT 57
5265: PUSH
5266: EMPTY
5267: LIST
5268: PUSH
5269: EMPTY
5270: LIST
5271: LIST
5272: LIST
5273: LIST
5274: PPUSH
5275: CALL_OW 69
5279: IFFALSE 5226
// end ; lab := kozlov_lab ;
5281: LD_ADDR_VAR 0 3
5285: PUSH
5286: LD_INT 336
5288: ST_TO_ADDR
// if not lab then
5289: LD_VAR 0 3
5293: NOT
5294: IFFALSE 5298
// exit ;
5296: GO 5423
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5298: LD_EXP 61
5302: PPUSH
5303: LD_VAR 0 3
5307: PUSH
5308: LD_INT 1
5310: ARRAY
5311: PPUSH
5312: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5316: LD_EXP 61
5320: PPUSH
5321: LD_INT 4
5323: PPUSH
5324: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5328: LD_VAR 0 3
5332: PUSH
5333: LD_INT 1
5335: ARRAY
5336: PPUSH
5337: LD_INT 25
5339: PPUSH
5340: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5344: LD_INT 35
5346: PPUSH
5347: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5351: LD_INT 25
5353: PPUSH
5354: LD_INT 8
5356: PPUSH
5357: CALL_OW 321
5361: PUSH
5362: LD_INT 2
5364: EQUAL
5365: IFFALSE 5344
// ComExitBuilding ( Kozlov ) ;
5367: LD_EXP 61
5371: PPUSH
5372: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5376: LD_EXP 61
5380: PPUSH
5381: LD_VAR 0 2
5385: PPUSH
5386: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5390: LD_EXP 61
5394: PPUSH
5395: LD_INT 3
5397: PPUSH
5398: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5402: LD_VAR 0 2
5406: PPUSH
5407: LD_INT 23
5409: PPUSH
5410: LD_INT 3
5412: PPUSH
5413: LD_INT 1
5415: PPUSH
5416: LD_INT 48
5418: PPUSH
5419: CALL_OW 125
// end ;
5423: LD_VAR 0 1
5427: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5428: LD_EXP 22
5432: NOT
5433: PUSH
5434: LD_EXP 15
5438: PUSH
5439: LD_INT 6
5441: GREATEREQUAL
5442: AND
5443: IFFALSE 5524
5445: GO 5447
5447: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5448: LD_INT 3
5450: PPUSH
5451: LD_INT 3
5453: PPUSH
5454: CALL 58687 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5458: LD_INT 3
5460: PPUSH
5461: LD_INT 14
5463: PUSH
5464: LD_INT 1
5466: PUSH
5467: LD_INT 1
5469: PUSH
5470: LD_INT 28
5472: PUSH
5473: EMPTY
5474: LIST
5475: LIST
5476: LIST
5477: LIST
5478: PUSH
5479: LD_INT 14
5481: PUSH
5482: LD_INT 1
5484: PUSH
5485: LD_INT 1
5487: PUSH
5488: LD_INT 28
5490: PUSH
5491: EMPTY
5492: LIST
5493: LIST
5494: LIST
5495: LIST
5496: PUSH
5497: LD_INT 14
5499: PUSH
5500: LD_INT 1
5502: PUSH
5503: LD_INT 1
5505: PUSH
5506: LD_INT 28
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: LIST
5513: LIST
5514: PUSH
5515: EMPTY
5516: LIST
5517: LIST
5518: LIST
5519: PPUSH
5520: CALL 58550 0 2
// end ;
5524: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5525: LD_EXP 22
5529: NOT
5530: PUSH
5531: LD_EXP 15
5535: PUSH
5536: LD_INT 6
5538: GREATEREQUAL
5539: AND
5540: PUSH
5541: LD_INT 3
5543: PPUSH
5544: LD_INT 1
5546: PPUSH
5547: CALL 59968 0 2
5551: NOT
5552: AND
5553: IFFALSE 6393
5555: GO 5557
5557: DISABLE
5558: LD_INT 0
5560: PPUSH
5561: PPUSH
5562: PPUSH
// begin enable ;
5563: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5564: LD_INT 22
5566: PUSH
5567: LD_INT 8
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: LD_INT 23
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: EMPTY
5581: LIST
5582: LIST
5583: PUSH
5584: LD_INT 30
5586: PUSH
5587: LD_INT 3
5589: PUSH
5590: EMPTY
5591: LIST
5592: LIST
5593: PUSH
5594: EMPTY
5595: LIST
5596: LIST
5597: LIST
5598: PPUSH
5599: CALL_OW 69
5603: NOT
5604: IFFALSE 5608
// exit ;
5606: GO 6393
// if Prob ( 40 ) then
5608: LD_INT 40
5610: PPUSH
5611: CALL_OW 13
5615: IFFALSE 5742
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5617: LD_INT 3
5619: PPUSH
5620: LD_INT 14
5622: PUSH
5623: LD_INT 1
5625: PUSH
5626: LD_INT 2
5628: PUSH
5629: LD_INT 28
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: PUSH
5638: LD_INT 14
5640: PUSH
5641: LD_INT 1
5643: PUSH
5644: LD_INT 2
5646: PUSH
5647: LD_INT 28
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 14
5658: PUSH
5659: LD_INT 1
5661: PUSH
5662: LD_INT 2
5664: PUSH
5665: LD_INT 28
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: LIST
5672: LIST
5673: PUSH
5674: LD_INT 14
5676: PUSH
5677: LD_INT 1
5679: PUSH
5680: LD_INT 2
5682: PUSH
5683: LD_INT 28
5685: PUSH
5686: EMPTY
5687: LIST
5688: LIST
5689: LIST
5690: LIST
5691: PUSH
5692: LD_INT 14
5694: PUSH
5695: LD_INT 1
5697: PUSH
5698: LD_INT 2
5700: PUSH
5701: LD_INT 28
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_INT 14
5712: PUSH
5713: LD_INT 1
5715: PUSH
5716: LD_INT 2
5718: PUSH
5719: LD_INT 26
5721: PUSH
5722: EMPTY
5723: LIST
5724: LIST
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: LIST
5734: LIST
5735: PPUSH
5736: CALL 58550 0 2
// end else
5740: GO 5933
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5742: LD_INT 3
5744: PPUSH
5745: LD_INT 14
5747: PUSH
5748: LD_INT 1
5750: PUSH
5751: LD_INT 2
5753: PUSH
5754: LD_INT 27
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: PUSH
5768: LD_OWVAR 67
5772: ARRAY
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: LD_INT 14
5782: PUSH
5783: LD_INT 1
5785: PUSH
5786: LD_INT 2
5788: PUSH
5789: LD_INT 27
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 26
5797: PUSH
5798: EMPTY
5799: LIST
5800: LIST
5801: LIST
5802: PUSH
5803: LD_OWVAR 67
5807: ARRAY
5808: PUSH
5809: EMPTY
5810: LIST
5811: LIST
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 14
5817: PUSH
5818: LD_INT 1
5820: PUSH
5821: LD_INT 2
5823: PUSH
5824: LD_INT 26
5826: PUSH
5827: LD_INT 26
5829: PUSH
5830: LD_INT 29
5832: PUSH
5833: EMPTY
5834: LIST
5835: LIST
5836: LIST
5837: PUSH
5838: LD_OWVAR 67
5842: ARRAY
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: LIST
5848: LIST
5849: PUSH
5850: LD_INT 13
5852: PUSH
5853: LD_INT 1
5855: PUSH
5856: LD_INT 2
5858: PUSH
5859: LD_INT 26
5861: PUSH
5862: LD_INT 29
5864: PUSH
5865: LD_INT 29
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: PUSH
5873: LD_OWVAR 67
5877: ARRAY
5878: PUSH
5879: EMPTY
5880: LIST
5881: LIST
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 13
5887: PUSH
5888: LD_INT 1
5890: PUSH
5891: LD_INT 2
5893: PUSH
5894: LD_INT 29
5896: PUSH
5897: EMPTY
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: LD_INT 14
5905: PUSH
5906: LD_INT 1
5908: PUSH
5909: LD_INT 2
5911: PUSH
5912: LD_INT 26
5914: PUSH
5915: EMPTY
5916: LIST
5917: LIST
5918: LIST
5919: LIST
5920: PUSH
5921: EMPTY
5922: LIST
5923: LIST
5924: LIST
5925: LIST
5926: LIST
5927: LIST
5928: PPUSH
5929: CALL 58550 0 2
// end ; repeat wait ( 0 0$1 ) ;
5933: LD_INT 35
5935: PPUSH
5936: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5940: LD_INT 3
5942: PPUSH
5943: LD_INT 1
5945: PPUSH
5946: CALL 59968 0 2
5950: PUSH
5951: LD_INT 6
5953: GREATEREQUAL
5954: IFFALSE 5933
// wait ( 0 0$30 ) ;
5956: LD_INT 1050
5958: PPUSH
5959: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5963: LD_ADDR_VAR 0 2
5967: PUSH
5968: LD_INT 3
5970: PPUSH
5971: LD_INT 1
5973: PPUSH
5974: CALL 59968 0 2
5978: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5979: LD_ADDR_EXP 121
5983: PUSH
5984: LD_EXP 121
5988: PPUSH
5989: LD_INT 3
5991: PPUSH
5992: LD_EXP 121
5996: PUSH
5997: LD_INT 3
5999: ARRAY
6000: PUSH
6001: LD_VAR 0 2
6005: DIFF
6006: PPUSH
6007: CALL_OW 1
6011: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6012: LD_ADDR_VAR 0 3
6016: PUSH
6017: LD_INT 0
6019: PPUSH
6020: LD_INT 2
6022: PPUSH
6023: CALL_OW 12
6027: ST_TO_ADDR
// if target then
6028: LD_VAR 0 3
6032: IFFALSE 6160
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6034: LD_ADDR_VAR 0 2
6038: PUSH
6039: LD_VAR 0 2
6043: PPUSH
6044: LD_INT 24
6046: PUSH
6047: LD_INT 250
6049: PUSH
6050: EMPTY
6051: LIST
6052: LIST
6053: PPUSH
6054: CALL_OW 72
6058: ST_TO_ADDR
// for i in tmp do
6059: LD_ADDR_VAR 0 1
6063: PUSH
6064: LD_VAR 0 2
6068: PUSH
6069: FOR_IN
6070: IFFALSE 6110
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6072: LD_VAR 0 1
6076: PPUSH
6077: LD_INT 89
6079: PPUSH
6080: LD_INT 71
6082: PPUSH
6083: CALL_OW 297
6087: PUSH
6088: LD_INT 9
6090: GREATER
6091: IFFALSE 6108
// ComMoveXY ( i , 89 , 71 ) ;
6093: LD_VAR 0 1
6097: PPUSH
6098: LD_INT 89
6100: PPUSH
6101: LD_INT 71
6103: PPUSH
6104: CALL_OW 111
6108: GO 6069
6110: POP
6111: POP
// wait ( 0 0$1 ) ;
6112: LD_INT 35
6114: PPUSH
6115: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6119: LD_VAR 0 2
6123: PPUSH
6124: LD_INT 92
6126: PUSH
6127: LD_INT 89
6129: PUSH
6130: LD_INT 71
6132: PUSH
6133: LD_INT 9
6135: PUSH
6136: EMPTY
6137: LIST
6138: LIST
6139: LIST
6140: LIST
6141: PPUSH
6142: CALL_OW 72
6146: PUSH
6147: LD_VAR 0 2
6151: PUSH
6152: LD_INT 1
6154: MINUS
6155: GREATEREQUAL
6156: IFFALSE 6034
// end else
6158: GO 6284
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6160: LD_ADDR_VAR 0 2
6164: PUSH
6165: LD_VAR 0 2
6169: PPUSH
6170: LD_INT 24
6172: PUSH
6173: LD_INT 250
6175: PUSH
6176: EMPTY
6177: LIST
6178: LIST
6179: PPUSH
6180: CALL_OW 72
6184: ST_TO_ADDR
// for i in tmp do
6185: LD_ADDR_VAR 0 1
6189: PUSH
6190: LD_VAR 0 2
6194: PUSH
6195: FOR_IN
6196: IFFALSE 6236
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6198: LD_VAR 0 1
6202: PPUSH
6203: LD_INT 125
6205: PPUSH
6206: LD_INT 129
6208: PPUSH
6209: CALL_OW 297
6213: PUSH
6214: LD_INT 9
6216: GREATER
6217: IFFALSE 6234
// ComMoveXY ( i , 125 , 129 ) ;
6219: LD_VAR 0 1
6223: PPUSH
6224: LD_INT 125
6226: PPUSH
6227: LD_INT 129
6229: PPUSH
6230: CALL_OW 111
6234: GO 6195
6236: POP
6237: POP
// wait ( 0 0$1 ) ;
6238: LD_INT 35
6240: PPUSH
6241: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6245: LD_VAR 0 2
6249: PPUSH
6250: LD_INT 92
6252: PUSH
6253: LD_INT 125
6255: PUSH
6256: LD_INT 129
6258: PUSH
6259: LD_INT 9
6261: PUSH
6262: EMPTY
6263: LIST
6264: LIST
6265: LIST
6266: LIST
6267: PPUSH
6268: CALL_OW 72
6272: PUSH
6273: LD_VAR 0 2
6277: PUSH
6278: LD_INT 1
6280: MINUS
6281: GREATEREQUAL
6282: IFFALSE 6160
// end ; repeat wait ( 0 0$1 ) ;
6284: LD_INT 35
6286: PPUSH
6287: CALL_OW 67
// for i in tmp do
6291: LD_ADDR_VAR 0 1
6295: PUSH
6296: LD_VAR 0 2
6300: PUSH
6301: FOR_IN
6302: IFFALSE 6384
// begin if GetLives ( i ) > 251 then
6304: LD_VAR 0 1
6308: PPUSH
6309: CALL_OW 256
6313: PUSH
6314: LD_INT 251
6316: GREATER
6317: IFFALSE 6355
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6319: LD_VAR 0 1
6323: PPUSH
6324: LD_INT 81
6326: PUSH
6327: LD_INT 8
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: PPUSH
6334: CALL_OW 69
6338: PPUSH
6339: LD_VAR 0 1
6343: PPUSH
6344: CALL_OW 74
6348: PPUSH
6349: CALL_OW 115
6353: GO 6382
// if IsDead ( i ) then
6355: LD_VAR 0 1
6359: PPUSH
6360: CALL_OW 301
6364: IFFALSE 6382
// tmp := tmp diff i ;
6366: LD_ADDR_VAR 0 2
6370: PUSH
6371: LD_VAR 0 2
6375: PUSH
6376: LD_VAR 0 1
6380: DIFF
6381: ST_TO_ADDR
// end ;
6382: GO 6301
6384: POP
6385: POP
// until not tmp ;
6386: LD_VAR 0 2
6390: NOT
6391: IFFALSE 6284
// end ;
6393: PPOPN 3
6395: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6396: LD_EXP 22
6400: NOT
6401: PUSH
6402: LD_EXP 15
6406: PUSH
6407: LD_INT 6
6409: GREATEREQUAL
6410: AND
6411: PUSH
6412: LD_OWVAR 67
6416: PUSH
6417: LD_INT 1
6419: GREATER
6420: AND
6421: IFFALSE 6938
6423: GO 6425
6425: DISABLE
6426: LD_INT 0
6428: PPUSH
6429: PPUSH
6430: PPUSH
// begin enable ;
6431: ENABLE
// tmp := [ ] ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: EMPTY
6438: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6439: LD_ADDR_VAR 0 1
6443: PUSH
6444: DOUBLE
6445: LD_INT 1
6447: DEC
6448: ST_TO_ADDR
6449: LD_INT 4
6451: PUSH
6452: LD_INT 6
6454: PUSH
6455: LD_INT 7
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: LIST
6462: PUSH
6463: LD_OWVAR 67
6467: ARRAY
6468: PUSH
6469: FOR_TO
6470: IFFALSE 6630
// begin uc_side := 8 ;
6472: LD_ADDR_OWVAR 20
6476: PUSH
6477: LD_INT 8
6479: ST_TO_ADDR
// uc_nation := 2 ;
6480: LD_ADDR_OWVAR 21
6484: PUSH
6485: LD_INT 2
6487: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6488: LD_INT 13
6490: PUSH
6491: LD_INT 14
6493: PUSH
6494: EMPTY
6495: LIST
6496: LIST
6497: PUSH
6498: LD_INT 1
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 12
6508: ARRAY
6509: PPUSH
6510: LD_INT 1
6512: PPUSH
6513: LD_INT 5
6515: PPUSH
6516: LD_INT 27
6518: PUSH
6519: LD_INT 28
6521: PUSH
6522: LD_INT 26
6524: PUSH
6525: LD_INT 25
6527: PUSH
6528: EMPTY
6529: LIST
6530: LIST
6531: LIST
6532: LIST
6533: PUSH
6534: LD_INT 1
6536: PPUSH
6537: LD_INT 4
6539: PPUSH
6540: CALL_OW 12
6544: ARRAY
6545: PPUSH
6546: LD_INT 88
6548: PPUSH
6549: CALL 72069 0 5
// un := CreateVehicle ;
6553: LD_ADDR_VAR 0 2
6557: PUSH
6558: CALL_OW 45
6562: ST_TO_ADDR
// tmp := tmp ^ un ;
6563: LD_ADDR_VAR 0 3
6567: PUSH
6568: LD_VAR 0 3
6572: PUSH
6573: LD_VAR 0 2
6577: ADD
6578: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6579: LD_VAR 0 2
6583: PPUSH
6584: LD_INT 3
6586: PPUSH
6587: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6591: LD_VAR 0 2
6595: PPUSH
6596: LD_INT 30
6598: PPUSH
6599: LD_INT 0
6601: PPUSH
6602: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 16
6613: PPUSH
6614: LD_INT 11
6616: PPUSH
6617: CALL_OW 111
// wait ( 0 0$2 ) ;
6621: LD_INT 70
6623: PPUSH
6624: CALL_OW 67
// end ;
6628: GO 6469
6630: POP
6631: POP
// for i = 1 to Difficulty do
6632: LD_ADDR_VAR 0 1
6636: PUSH
6637: DOUBLE
6638: LD_INT 1
6640: DEC
6641: ST_TO_ADDR
6642: LD_OWVAR 67
6646: PUSH
6647: FOR_TO
6648: IFFALSE 6773
// begin uc_side := 8 ;
6650: LD_ADDR_OWVAR 20
6654: PUSH
6655: LD_INT 8
6657: ST_TO_ADDR
// uc_nation := 2 ;
6658: LD_ADDR_OWVAR 21
6662: PUSH
6663: LD_INT 2
6665: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6666: LD_INT 0
6668: PPUSH
6669: LD_INT 8
6671: PPUSH
6672: LD_INT 8
6674: PUSH
6675: LD_INT 8
6677: PUSH
6678: LD_INT 9
6680: PUSH
6681: EMPTY
6682: LIST
6683: LIST
6684: LIST
6685: PUSH
6686: LD_OWVAR 67
6690: ARRAY
6691: PPUSH
6692: CALL_OW 380
// un := CreateHuman ;
6696: LD_ADDR_VAR 0 2
6700: PUSH
6701: CALL_OW 44
6705: ST_TO_ADDR
// tmp := tmp ^ un ;
6706: LD_ADDR_VAR 0 3
6710: PUSH
6711: LD_VAR 0 3
6715: PUSH
6716: LD_VAR 0 2
6720: ADD
6721: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6722: LD_VAR 0 2
6726: PPUSH
6727: LD_INT 3
6729: PPUSH
6730: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6734: LD_VAR 0 2
6738: PPUSH
6739: LD_INT 30
6741: PPUSH
6742: LD_INT 0
6744: PPUSH
6745: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6749: LD_VAR 0 2
6753: PPUSH
6754: LD_INT 16
6756: PPUSH
6757: LD_INT 11
6759: PPUSH
6760: CALL_OW 111
// wait ( 0 0$2 ) ;
6764: LD_INT 70
6766: PPUSH
6767: CALL_OW 67
// end ;
6771: GO 6647
6773: POP
6774: POP
// repeat wait ( 0 0$1 ) ;
6775: LD_INT 35
6777: PPUSH
6778: CALL_OW 67
// for i in tmp do
6782: LD_ADDR_VAR 0 1
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: FOR_IN
6793: IFFALSE 6929
// begin if GetLives ( i ) > 250 then
6795: LD_VAR 0 1
6799: PPUSH
6800: CALL_OW 256
6804: PUSH
6805: LD_INT 250
6807: GREATER
6808: IFFALSE 6900
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6810: LD_INT 81
6812: PUSH
6813: LD_INT 8
6815: PUSH
6816: EMPTY
6817: LIST
6818: LIST
6819: PUSH
6820: LD_INT 91
6822: PUSH
6823: LD_VAR 0 1
6827: PUSH
6828: LD_INT 10
6830: PUSH
6831: EMPTY
6832: LIST
6833: LIST
6834: LIST
6835: PUSH
6836: EMPTY
6837: LIST
6838: LIST
6839: PPUSH
6840: CALL_OW 69
6844: NOT
6845: IFFALSE 6864
// ComAgressiveMove ( i , 67 , 110 ) else
6847: LD_VAR 0 1
6851: PPUSH
6852: LD_INT 67
6854: PPUSH
6855: LD_INT 110
6857: PPUSH
6858: CALL_OW 114
6862: GO 6898
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6864: LD_VAR 0 1
6868: PPUSH
6869: LD_INT 81
6871: PUSH
6872: LD_INT 8
6874: PUSH
6875: EMPTY
6876: LIST
6877: LIST
6878: PPUSH
6879: CALL_OW 69
6883: PPUSH
6884: LD_VAR 0 1
6888: PPUSH
6889: CALL_OW 74
6893: PPUSH
6894: CALL_OW 115
// end else
6898: GO 6927
// if IsDead ( i ) then
6900: LD_VAR 0 1
6904: PPUSH
6905: CALL_OW 301
6909: IFFALSE 6927
// tmp := tmp diff i ;
6911: LD_ADDR_VAR 0 3
6915: PUSH
6916: LD_VAR 0 3
6920: PUSH
6921: LD_VAR 0 1
6925: DIFF
6926: ST_TO_ADDR
// end ;
6927: GO 6792
6929: POP
6930: POP
// until not tmp ;
6931: LD_VAR 0 3
6935: NOT
6936: IFFALSE 6775
// end ; end_of_file
6938: PPOPN 3
6940: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6941: LD_INT 0
6943: PPUSH
6944: PPUSH
6945: PPUSH
6946: PPUSH
6947: PPUSH
6948: PPUSH
6949: PPUSH
6950: PPUSH
6951: PPUSH
// side := 3 ;
6952: LD_ADDR_VAR 0 6
6956: PUSH
6957: LD_INT 3
6959: ST_TO_ADDR
// uc_side := side ;
6960: LD_ADDR_OWVAR 20
6964: PUSH
6965: LD_VAR 0 6
6969: ST_TO_ADDR
// uc_nation := 3 ;
6970: LD_ADDR_OWVAR 21
6974: PUSH
6975: LD_INT 3
6977: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6978: LD_ADDR_VAR 0 2
6982: PUSH
6983: LD_INT 22
6985: PUSH
6986: LD_VAR 0 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: LD_INT 21
6997: PUSH
6998: LD_INT 3
7000: PUSH
7001: EMPTY
7002: LIST
7003: LIST
7004: PUSH
7005: EMPTY
7006: LIST
7007: LIST
7008: PPUSH
7009: CALL_OW 69
7013: PUSH
7014: FOR_IN
7015: IFFALSE 7031
// SetBLevel ( i , 10 ) ;
7017: LD_VAR 0 2
7021: PPUSH
7022: LD_INT 10
7024: PPUSH
7025: CALL_OW 241
7029: GO 7014
7031: POP
7032: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7033: LD_ADDR_VAR 0 9
7037: PUSH
7038: LD_INT 22
7040: PUSH
7041: LD_VAR 0 6
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 30
7052: PUSH
7053: LD_INT 34
7055: PUSH
7056: EMPTY
7057: LIST
7058: LIST
7059: PUSH
7060: EMPTY
7061: LIST
7062: LIST
7063: PPUSH
7064: CALL_OW 69
7068: ST_TO_ADDR
// if teleport then
7069: LD_VAR 0 9
7073: IFFALSE 7094
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7075: LD_VAR 0 9
7079: PUSH
7080: LD_INT 1
7082: ARRAY
7083: PPUSH
7084: LD_INT 123
7086: PPUSH
7087: LD_INT 122
7089: PPUSH
7090: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7094: LD_ADDR_EXP 64
7098: PUSH
7099: LD_STRING Platonov
7101: PPUSH
7102: CALL_OW 25
7106: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7107: LD_ADDR_EXP 65
7111: PUSH
7112: LD_STRING Kovalyuk
7114: PPUSH
7115: CALL_OW 25
7119: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7120: LD_ADDR_EXP 67
7124: PUSH
7125: LD_STRING Yakotich
7127: PPUSH
7128: LD_EXP 1
7132: NOT
7133: PPUSH
7134: LD_STRING 09_
7136: PPUSH
7137: CALL 64894 0 3
7141: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7142: LD_ADDR_EXP 66
7146: PUSH
7147: LD_STRING Bystrov
7149: PPUSH
7150: CALL_OW 25
7154: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7155: LD_ADDR_EXP 68
7159: PUSH
7160: LD_STRING Gleb
7162: PPUSH
7163: CALL_OW 25
7167: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7168: LD_STRING 03_Cornel
7170: PPUSH
7171: CALL_OW 28
7175: IFFALSE 7223
// begin Bierezov := NewCharacter ( Mikhail ) ;
7177: LD_ADDR_EXP 69
7181: PUSH
7182: LD_STRING Mikhail
7184: PPUSH
7185: CALL_OW 25
7189: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7190: LD_EXP 69
7194: PPUSH
7195: LD_INT 197
7197: PPUSH
7198: LD_INT 111
7200: PPUSH
7201: LD_INT 9
7203: PPUSH
7204: LD_INT 0
7206: PPUSH
7207: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7211: LD_EXP 69
7215: PPUSH
7216: LD_INT 3
7218: PPUSH
7219: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7223: LD_EXP 64
7227: PPUSH
7228: LD_INT 126
7230: PPUSH
7231: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7235: LD_EXP 65
7239: PPUSH
7240: LD_INT 134
7242: PPUSH
7243: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7247: LD_EXP 67
7251: PPUSH
7252: LD_INT 197
7254: PPUSH
7255: LD_INT 111
7257: PPUSH
7258: LD_INT 9
7260: PPUSH
7261: LD_INT 0
7263: PPUSH
7264: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7268: LD_EXP 66
7272: PPUSH
7273: LD_INT 197
7275: PPUSH
7276: LD_INT 111
7278: PPUSH
7279: LD_INT 9
7281: PPUSH
7282: LD_INT 0
7284: PPUSH
7285: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7289: LD_EXP 68
7293: PPUSH
7294: LD_INT 197
7296: PPUSH
7297: LD_INT 111
7299: PPUSH
7300: LD_INT 9
7302: PPUSH
7303: LD_INT 0
7305: PPUSH
7306: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7310: LD_ADDR_VAR 0 5
7314: PUSH
7315: LD_INT 126
7317: PPUSH
7318: LD_INT 4
7320: PPUSH
7321: LD_STRING zhukov
7323: PPUSH
7324: LD_INT 9
7326: PUSH
7327: LD_INT 10
7329: PUSH
7330: LD_INT 10
7332: PUSH
7333: EMPTY
7334: LIST
7335: LIST
7336: LIST
7337: PUSH
7338: LD_OWVAR 67
7342: ARRAY
7343: PPUSH
7344: LD_INT 90000
7346: PUSH
7347: LD_INT 1000
7349: PUSH
7350: LD_INT 300
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: LD_INT 18
7360: PUSH
7361: LD_INT 8
7363: PUSH
7364: LD_INT 13
7366: PUSH
7367: LD_INT 8
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: LIST
7374: LIST
7375: PPUSH
7376: CALL 75478 0 6
7380: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7381: LD_ADDR_VAR 0 4
7385: PUSH
7386: LD_INT 267
7388: PPUSH
7389: CALL_OW 274
7393: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7394: LD_VAR 0 4
7398: PPUSH
7399: LD_INT 1
7401: PPUSH
7402: LD_INT 5000
7404: PPUSH
7405: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7409: LD_VAR 0 4
7413: PPUSH
7414: LD_INT 2
7416: PPUSH
7417: LD_INT 200
7419: PPUSH
7420: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7424: LD_VAR 0 4
7428: PPUSH
7429: LD_INT 3
7431: PPUSH
7432: LD_INT 200
7434: PPUSH
7435: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7439: LD_ADDR_EXP 102
7443: PUSH
7444: LD_EXP 102
7448: PPUSH
7449: LD_INT 2
7451: PPUSH
7452: LD_VAR 0 5
7456: PUSH
7457: LD_INT 22
7459: PUSH
7460: LD_VAR 0 6
7464: PUSH
7465: EMPTY
7466: LIST
7467: LIST
7468: PUSH
7469: LD_INT 3
7471: PUSH
7472: LD_INT 21
7474: PUSH
7475: LD_INT 2
7477: PUSH
7478: EMPTY
7479: LIST
7480: LIST
7481: PUSH
7482: EMPTY
7483: LIST
7484: LIST
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: PPUSH
7490: CALL_OW 69
7494: UNION
7495: PUSH
7496: LD_EXP 64
7500: DIFF
7501: PPUSH
7502: CALL_OW 1
7506: ST_TO_ADDR
// behemoths := [ ] ;
7507: LD_ADDR_EXP 72
7511: PUSH
7512: EMPTY
7513: ST_TO_ADDR
// behemothBuilders := [ ] ;
7514: LD_ADDR_EXP 73
7518: PUSH
7519: EMPTY
7520: ST_TO_ADDR
// if Kovalyuk then
7521: LD_EXP 65
7525: IFFALSE 7547
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7527: LD_ADDR_EXP 73
7531: PUSH
7532: LD_EXP 73
7536: PPUSH
7537: LD_EXP 65
7541: PPUSH
7542: CALL 107824 0 2
7546: ST_TO_ADDR
// j := 3 ;
7547: LD_ADDR_VAR 0 3
7551: PUSH
7552: LD_INT 3
7554: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7555: LD_ADDR_VAR 0 2
7559: PUSH
7560: LD_INT 22
7562: PUSH
7563: LD_INT 3
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: LD_INT 25
7572: PUSH
7573: LD_INT 3
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PUSH
7580: EMPTY
7581: LIST
7582: LIST
7583: PPUSH
7584: CALL_OW 69
7588: PUSH
7589: LD_EXP 65
7593: DIFF
7594: PUSH
7595: FOR_IN
7596: IFFALSE 7646
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7598: LD_ADDR_EXP 73
7602: PUSH
7603: LD_EXP 73
7607: PPUSH
7608: LD_VAR 0 2
7612: PPUSH
7613: CALL 107824 0 2
7617: ST_TO_ADDR
// j := j - 1 ;
7618: LD_ADDR_VAR 0 3
7622: PUSH
7623: LD_VAR 0 3
7627: PUSH
7628: LD_INT 1
7630: MINUS
7631: ST_TO_ADDR
// if j = 0 then
7632: LD_VAR 0 3
7636: PUSH
7637: LD_INT 0
7639: EQUAL
7640: IFFALSE 7644
// break ;
7642: GO 7646
// end ;
7644: GO 7595
7646: POP
7647: POP
// end ;
7648: LD_VAR 0 1
7652: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7653: LD_INT 0
7655: PPUSH
7656: PPUSH
7657: PPUSH
7658: PPUSH
7659: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7660: LD_ADDR_VAR 0 4
7664: PUSH
7665: LD_INT 209
7667: PUSH
7668: LD_INT 149
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: LD_INT 219
7677: PUSH
7678: LD_INT 154
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: LD_INT 223
7687: PUSH
7688: LD_INT 149
7690: PUSH
7691: EMPTY
7692: LIST
7693: LIST
7694: PUSH
7695: LD_INT 232
7697: PUSH
7698: LD_INT 155
7700: PUSH
7701: EMPTY
7702: LIST
7703: LIST
7704: PUSH
7705: EMPTY
7706: LIST
7707: LIST
7708: LIST
7709: LIST
7710: ST_TO_ADDR
// if not behemothBuilders then
7711: LD_EXP 73
7715: NOT
7716: IFFALSE 7720
// exit ;
7718: GO 7824
// j := 1 ;
7720: LD_ADDR_VAR 0 3
7724: PUSH
7725: LD_INT 1
7727: ST_TO_ADDR
// for i in behemothBuilders do
7728: LD_ADDR_VAR 0 2
7732: PUSH
7733: LD_EXP 73
7737: PUSH
7738: FOR_IN
7739: IFFALSE 7822
// begin if IsInUnit ( i ) then
7741: LD_VAR 0 2
7745: PPUSH
7746: CALL_OW 310
7750: IFFALSE 7761
// ComExitBuilding ( i ) ;
7752: LD_VAR 0 2
7756: PPUSH
7757: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7761: LD_VAR 0 2
7765: PPUSH
7766: LD_INT 37
7768: PPUSH
7769: LD_VAR 0 4
7773: PUSH
7774: LD_VAR 0 3
7778: ARRAY
7779: PUSH
7780: LD_INT 1
7782: ARRAY
7783: PPUSH
7784: LD_VAR 0 4
7788: PUSH
7789: LD_VAR 0 3
7793: ARRAY
7794: PUSH
7795: LD_INT 2
7797: ARRAY
7798: PPUSH
7799: LD_INT 0
7801: PPUSH
7802: CALL_OW 230
// j := j + 1 ;
7806: LD_ADDR_VAR 0 3
7810: PUSH
7811: LD_VAR 0 3
7815: PUSH
7816: LD_INT 1
7818: PLUS
7819: ST_TO_ADDR
// end ;
7820: GO 7738
7822: POP
7823: POP
// end ;
7824: LD_VAR 0 1
7828: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7829: LD_INT 24
7831: PPUSH
7832: LD_INT 30
7834: PUSH
7835: LD_INT 37
7837: PUSH
7838: EMPTY
7839: LIST
7840: LIST
7841: PPUSH
7842: CALL_OW 70
7846: IFFALSE 7859
7848: GO 7850
7850: DISABLE
// behemothUnderConstruct := true ;
7851: LD_ADDR_EXP 26
7855: PUSH
7856: LD_INT 1
7858: ST_TO_ADDR
7859: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7860: LD_INT 3
7862: PPUSH
7863: CALL 107872 0 1
7867: PUSH
7868: LD_INT 22
7870: PUSH
7871: LD_INT 3
7873: PUSH
7874: EMPTY
7875: LIST
7876: LIST
7877: PUSH
7878: LD_INT 30
7880: PUSH
7881: LD_INT 37
7883: PUSH
7884: EMPTY
7885: LIST
7886: LIST
7887: PUSH
7888: EMPTY
7889: LIST
7890: LIST
7891: PPUSH
7892: CALL_OW 69
7896: NOT
7897: AND
7898: IFFALSE 8084
7900: GO 7902
7902: DISABLE
7903: LD_INT 0
7905: PPUSH
7906: PPUSH
// begin enable ;
7907: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7908: LD_ADDR_VAR 0 2
7912: PUSH
7913: LD_INT 3
7915: PPUSH
7916: CALL 107872 0 1
7920: ST_TO_ADDR
// for i in tmp do
7921: LD_ADDR_VAR 0 1
7925: PUSH
7926: LD_VAR 0 2
7930: PUSH
7931: FOR_IN
7932: IFFALSE 8082
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7934: LD_VAR 0 1
7938: PPUSH
7939: LD_INT 9
7941: PPUSH
7942: CALL_OW 308
7946: PUSH
7947: LD_VAR 0 1
7951: PPUSH
7952: CALL_OW 110
7956: PUSH
7957: LD_INT 2
7959: EQUAL
7960: NOT
7961: AND
7962: IFFALSE 7976
// SetTag ( i , 2 ) ;
7964: LD_VAR 0 1
7968: PPUSH
7969: LD_INT 2
7971: PPUSH
7972: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7976: LD_INT 81
7978: PUSH
7979: LD_INT 3
7981: PUSH
7982: EMPTY
7983: LIST
7984: LIST
7985: PUSH
7986: LD_INT 91
7988: PUSH
7989: LD_VAR 0 1
7993: PUSH
7994: LD_INT 12
7996: PUSH
7997: EMPTY
7998: LIST
7999: LIST
8000: LIST
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: PPUSH
8006: CALL_OW 69
8010: NOT
8011: PUSH
8012: LD_VAR 0 1
8016: PPUSH
8017: CALL_OW 110
8021: PUSH
8022: LD_INT 2
8024: EQUAL
8025: NOT
8026: AND
8027: IFFALSE 8046
// ComAgressiveMove ( i , 64 , 93 ) else
8029: LD_VAR 0 1
8033: PPUSH
8034: LD_INT 64
8036: PPUSH
8037: LD_INT 93
8039: PPUSH
8040: CALL_OW 114
8044: GO 8080
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8046: LD_VAR 0 1
8050: PPUSH
8051: LD_INT 81
8053: PUSH
8054: LD_INT 3
8056: PUSH
8057: EMPTY
8058: LIST
8059: LIST
8060: PPUSH
8061: CALL_OW 69
8065: PPUSH
8066: LD_VAR 0 1
8070: PPUSH
8071: CALL_OW 74
8075: PPUSH
8076: CALL_OW 115
// end ;
8080: GO 7931
8082: POP
8083: POP
// end ;
8084: PPOPN 2
8086: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8087: LD_INT 0
8089: PPUSH
8090: PPUSH
8091: PPUSH
// result := [ ] ;
8092: LD_ADDR_VAR 0 2
8096: PUSH
8097: EMPTY
8098: ST_TO_ADDR
// uc_side := 6 ;
8099: LD_ADDR_OWVAR 20
8103: PUSH
8104: LD_INT 6
8106: ST_TO_ADDR
// uc_nation := 3 ;
8107: LD_ADDR_OWVAR 21
8111: PUSH
8112: LD_INT 3
8114: ST_TO_ADDR
// case strength of 1 :
8115: LD_VAR 0 1
8119: PUSH
8120: LD_INT 1
8122: DOUBLE
8123: EQUAL
8124: IFTRUE 8128
8126: GO 8266
8128: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8129: LD_ADDR_VAR 0 3
8133: PUSH
8134: DOUBLE
8135: LD_INT 1
8137: DEC
8138: ST_TO_ADDR
8139: LD_INT 4
8141: PUSH
8142: LD_INT 5
8144: PUSH
8145: LD_INT 6
8147: PUSH
8148: EMPTY
8149: LIST
8150: LIST
8151: LIST
8152: PUSH
8153: LD_OWVAR 67
8157: ARRAY
8158: PUSH
8159: FOR_TO
8160: IFFALSE 8262
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8162: LD_INT 22
8164: PUSH
8165: LD_INT 24
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_VAR 0 3
8176: PUSH
8177: LD_INT 2
8179: MOD
8180: PUSH
8181: LD_INT 1
8183: PLUS
8184: ARRAY
8185: PPUSH
8186: LD_INT 1
8188: PUSH
8189: LD_INT 3
8191: PUSH
8192: EMPTY
8193: LIST
8194: LIST
8195: PUSH
8196: LD_INT 1
8198: PPUSH
8199: LD_INT 2
8201: PPUSH
8202: CALL_OW 12
8206: ARRAY
8207: PPUSH
8208: LD_INT 3
8210: PPUSH
8211: LD_INT 43
8213: PUSH
8214: LD_INT 44
8216: PUSH
8217: LD_INT 45
8219: PUSH
8220: EMPTY
8221: LIST
8222: LIST
8223: LIST
8224: PUSH
8225: LD_INT 1
8227: PPUSH
8228: LD_INT 3
8230: PPUSH
8231: CALL_OW 12
8235: ARRAY
8236: PPUSH
8237: LD_INT 80
8239: PPUSH
8240: CALL 72069 0 5
// result := result union CreateVehicle ;
8244: LD_ADDR_VAR 0 2
8248: PUSH
8249: LD_VAR 0 2
8253: PUSH
8254: CALL_OW 45
8258: UNION
8259: ST_TO_ADDR
// end ;
8260: GO 8159
8262: POP
8263: POP
// end ; 2 :
8264: GO 9217
8266: LD_INT 2
8268: DOUBLE
8269: EQUAL
8270: IFTRUE 8274
8272: GO 8430
8274: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8275: LD_ADDR_VAR 0 3
8279: PUSH
8280: DOUBLE
8281: LD_INT 1
8283: DEC
8284: ST_TO_ADDR
8285: LD_INT 5
8287: PUSH
8288: LD_INT 6
8290: PUSH
8291: LD_INT 7
8293: PUSH
8294: EMPTY
8295: LIST
8296: LIST
8297: LIST
8298: PUSH
8299: LD_OWVAR 67
8303: ARRAY
8304: PUSH
8305: FOR_TO
8306: IFFALSE 8426
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8308: LD_INT 22
8310: PUSH
8311: LD_INT 24
8313: PUSH
8314: LD_INT 24
8316: PUSH
8317: EMPTY
8318: LIST
8319: LIST
8320: LIST
8321: PUSH
8322: LD_VAR 0 3
8326: PUSH
8327: LD_INT 3
8329: MOD
8330: PUSH
8331: LD_INT 1
8333: PLUS
8334: ARRAY
8335: PPUSH
8336: LD_INT 1
8338: PUSH
8339: LD_INT 3
8341: PUSH
8342: EMPTY
8343: LIST
8344: LIST
8345: PUSH
8346: LD_INT 1
8348: PPUSH
8349: LD_INT 2
8351: PPUSH
8352: CALL_OW 12
8356: ARRAY
8357: PPUSH
8358: LD_INT 3
8360: PPUSH
8361: LD_INT 43
8363: PUSH
8364: LD_INT 44
8366: PUSH
8367: LD_INT 45
8369: PUSH
8370: LD_INT 44
8372: PUSH
8373: LD_INT 46
8375: PUSH
8376: LD_INT 46
8378: PUSH
8379: EMPTY
8380: LIST
8381: LIST
8382: LIST
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_VAR 0 3
8391: PUSH
8392: LD_INT 6
8394: MOD
8395: PUSH
8396: LD_INT 1
8398: PLUS
8399: ARRAY
8400: PPUSH
8401: LD_INT 80
8403: PPUSH
8404: CALL 72069 0 5
// result := result union CreateVehicle ;
8408: LD_ADDR_VAR 0 2
8412: PUSH
8413: LD_VAR 0 2
8417: PUSH
8418: CALL_OW 45
8422: UNION
8423: ST_TO_ADDR
// end ;
8424: GO 8305
8426: POP
8427: POP
// end ; 3 :
8428: GO 9217
8430: LD_INT 3
8432: DOUBLE
8433: EQUAL
8434: IFTRUE 8438
8436: GO 8594
8438: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8439: LD_ADDR_VAR 0 3
8443: PUSH
8444: DOUBLE
8445: LD_INT 1
8447: DEC
8448: ST_TO_ADDR
8449: LD_INT 5
8451: PUSH
8452: LD_INT 7
8454: PUSH
8455: LD_INT 8
8457: PUSH
8458: EMPTY
8459: LIST
8460: LIST
8461: LIST
8462: PUSH
8463: LD_OWVAR 67
8467: ARRAY
8468: PUSH
8469: FOR_TO
8470: IFFALSE 8590
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8472: LD_INT 22
8474: PUSH
8475: LD_INT 24
8477: PUSH
8478: LD_INT 24
8480: PUSH
8481: EMPTY
8482: LIST
8483: LIST
8484: LIST
8485: PUSH
8486: LD_VAR 0 3
8490: PUSH
8491: LD_INT 3
8493: MOD
8494: PUSH
8495: LD_INT 1
8497: PLUS
8498: ARRAY
8499: PPUSH
8500: LD_INT 1
8502: PUSH
8503: LD_INT 3
8505: PUSH
8506: EMPTY
8507: LIST
8508: LIST
8509: PUSH
8510: LD_INT 1
8512: PPUSH
8513: LD_INT 2
8515: PPUSH
8516: CALL_OW 12
8520: ARRAY
8521: PPUSH
8522: LD_INT 3
8524: PPUSH
8525: LD_INT 43
8527: PUSH
8528: LD_INT 47
8530: PUSH
8531: LD_INT 45
8533: PUSH
8534: LD_INT 45
8536: PUSH
8537: LD_INT 46
8539: PUSH
8540: LD_INT 46
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: LIST
8549: LIST
8550: PUSH
8551: LD_VAR 0 3
8555: PUSH
8556: LD_INT 6
8558: MOD
8559: PUSH
8560: LD_INT 1
8562: PLUS
8563: ARRAY
8564: PPUSH
8565: LD_INT 80
8567: PPUSH
8568: CALL 72069 0 5
// result := result union CreateVehicle ;
8572: LD_ADDR_VAR 0 2
8576: PUSH
8577: LD_VAR 0 2
8581: PUSH
8582: CALL_OW 45
8586: UNION
8587: ST_TO_ADDR
// end ;
8588: GO 8469
8590: POP
8591: POP
// end ; 4 :
8592: GO 9217
8594: LD_INT 4
8596: DOUBLE
8597: EQUAL
8598: IFTRUE 8602
8600: GO 9216
8602: POP
// begin uc_nation := 3 ;
8603: LD_ADDR_OWVAR 21
8607: PUSH
8608: LD_INT 3
8610: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8611: LD_ADDR_VAR 0 3
8615: PUSH
8616: DOUBLE
8617: LD_INT 1
8619: DEC
8620: ST_TO_ADDR
8621: LD_INT 6
8623: PUSH
8624: LD_INT 8
8626: PUSH
8627: LD_INT 9
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: PUSH
8635: LD_OWVAR 67
8639: ARRAY
8640: PUSH
8641: FOR_TO
8642: IFFALSE 8762
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8644: LD_INT 22
8646: PUSH
8647: LD_INT 24
8649: PUSH
8650: LD_INT 24
8652: PUSH
8653: EMPTY
8654: LIST
8655: LIST
8656: LIST
8657: PUSH
8658: LD_VAR 0 3
8662: PUSH
8663: LD_INT 3
8665: MOD
8666: PUSH
8667: LD_INT 1
8669: PLUS
8670: ARRAY
8671: PPUSH
8672: LD_INT 1
8674: PUSH
8675: LD_INT 3
8677: PUSH
8678: EMPTY
8679: LIST
8680: LIST
8681: PUSH
8682: LD_INT 1
8684: PPUSH
8685: LD_INT 2
8687: PPUSH
8688: CALL_OW 12
8692: ARRAY
8693: PPUSH
8694: LD_INT 3
8696: PPUSH
8697: LD_INT 45
8699: PUSH
8700: LD_INT 47
8702: PUSH
8703: LD_INT 47
8705: PUSH
8706: LD_INT 45
8708: PUSH
8709: LD_INT 46
8711: PUSH
8712: LD_INT 46
8714: PUSH
8715: EMPTY
8716: LIST
8717: LIST
8718: LIST
8719: LIST
8720: LIST
8721: LIST
8722: PUSH
8723: LD_VAR 0 3
8727: PUSH
8728: LD_INT 6
8730: MOD
8731: PUSH
8732: LD_INT 1
8734: PLUS
8735: ARRAY
8736: PPUSH
8737: LD_INT 80
8739: PPUSH
8740: CALL 72069 0 5
// result := result union CreateVehicle ;
8744: LD_ADDR_VAR 0 2
8748: PUSH
8749: LD_VAR 0 2
8753: PUSH
8754: CALL_OW 45
8758: UNION
8759: ST_TO_ADDR
// end ;
8760: GO 8641
8762: POP
8763: POP
// if not KappaStatus then
8764: LD_EXP 2
8768: NOT
8769: IFFALSE 9004
// begin uc_nation := 1 ;
8771: LD_ADDR_OWVAR 21
8775: PUSH
8776: LD_INT 1
8778: ST_TO_ADDR
// for i = 1 to 3 do
8779: LD_ADDR_VAR 0 3
8783: PUSH
8784: DOUBLE
8785: LD_INT 1
8787: DEC
8788: ST_TO_ADDR
8789: LD_INT 3
8791: PUSH
8792: FOR_TO
8793: IFFALSE 8929
// begin j := rand ( 0 , 1 ) ;
8795: LD_ADDR_VAR 0 4
8799: PUSH
8800: LD_INT 0
8802: PPUSH
8803: LD_INT 1
8805: PPUSH
8806: CALL_OW 12
8810: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8811: LD_INT 3
8813: PUSH
8814: LD_INT 5
8816: PUSH
8817: LD_INT 5
8819: PUSH
8820: LD_INT 4
8822: PUSH
8823: EMPTY
8824: LIST
8825: LIST
8826: LIST
8827: LIST
8828: PUSH
8829: LD_VAR 0 4
8833: PUSH
8834: LD_INT 1
8836: PPUSH
8837: LD_INT 3
8839: PPUSH
8840: CALL_OW 12
8844: PLUS
8845: ARRAY
8846: PPUSH
8847: LD_INT 1
8849: PUSH
8850: LD_INT 3
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: PUSH
8857: LD_INT 1
8859: PPUSH
8860: LD_INT 2
8862: PPUSH
8863: CALL_OW 12
8867: ARRAY
8868: PPUSH
8869: LD_INT 3
8871: PPUSH
8872: LD_INT 9
8874: PUSH
8875: LD_INT 7
8877: PUSH
8878: LD_INT 6
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: PUSH
8886: LD_VAR 0 4
8890: PUSH
8891: LD_INT 1
8893: PPUSH
8894: LD_INT 2
8896: PPUSH
8897: CALL_OW 12
8901: PLUS
8902: ARRAY
8903: PPUSH
8904: LD_INT 85
8906: PPUSH
8907: CALL 72069 0 5
// result := result union CreateVehicle ;
8911: LD_ADDR_VAR 0 2
8915: PUSH
8916: LD_VAR 0 2
8920: PUSH
8921: CALL_OW 45
8925: UNION
8926: ST_TO_ADDR
// end ;
8927: GO 8792
8929: POP
8930: POP
// if vsevolodFirstAttack then
8931: LD_EXP 24
8935: IFFALSE 9002
// begin vsevolodFirstAttack := false ;
8937: LD_ADDR_EXP 24
8941: PUSH
8942: LD_INT 0
8944: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8945: LD_INT 5
8947: PPUSH
8948: LD_INT 3
8950: PPUSH
8951: LD_INT 1
8953: PPUSH
8954: LD_INT 6
8956: PPUSH
8957: LD_INT 100
8959: PPUSH
8960: CALL 72069 0 5
// sewiVeh := CreateVehicle ;
8964: LD_ADDR_EXP 71
8968: PUSH
8969: CALL_OW 45
8973: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8974: LD_EXP 71
8978: PPUSH
8979: LD_INT 1
8981: PPUSH
8982: CALL_OW 242
// result := result union sewiVeh ;
8986: LD_ADDR_VAR 0 2
8990: PUSH
8991: LD_VAR 0 2
8995: PUSH
8996: LD_EXP 71
9000: UNION
9001: ST_TO_ADDR
// end ; end else
9002: GO 9214
// if vsevolodFirstAttack then
9004: LD_EXP 24
9008: IFFALSE 9214
// begin vsevolodFirstAttack := false ;
9010: LD_ADDR_EXP 24
9014: PUSH
9015: LD_INT 0
9017: ST_TO_ADDR
// uc_nation := 3 ;
9018: LD_ADDR_OWVAR 21
9022: PUSH
9023: LD_INT 3
9025: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9026: LD_ADDR_VAR 0 3
9030: PUSH
9031: DOUBLE
9032: LD_INT 1
9034: DEC
9035: ST_TO_ADDR
9036: LD_INT 2
9038: PUSH
9039: LD_OWVAR 67
9043: PLUS
9044: PUSH
9045: FOR_TO
9046: IFFALSE 9154
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9048: LD_INT 22
9050: PUSH
9051: LD_INT 24
9053: PUSH
9054: LD_INT 24
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: LIST
9061: PUSH
9062: LD_VAR 0 3
9066: PUSH
9067: LD_INT 3
9069: MOD
9070: PUSH
9071: LD_INT 1
9073: PLUS
9074: ARRAY
9075: PPUSH
9076: LD_INT 1
9078: PUSH
9079: LD_INT 3
9081: PUSH
9082: EMPTY
9083: LIST
9084: LIST
9085: PUSH
9086: LD_INT 1
9088: PPUSH
9089: LD_INT 2
9091: PPUSH
9092: CALL_OW 12
9096: ARRAY
9097: PPUSH
9098: LD_INT 1
9100: PPUSH
9101: LD_INT 45
9103: PUSH
9104: LD_INT 47
9106: PUSH
9107: LD_INT 47
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: PUSH
9115: LD_VAR 0 3
9119: PUSH
9120: LD_INT 3
9122: MOD
9123: PUSH
9124: LD_INT 1
9126: PLUS
9127: ARRAY
9128: PPUSH
9129: LD_INT 80
9131: PPUSH
9132: CALL 72069 0 5
// result := result union CreateVehicle ;
9136: LD_ADDR_VAR 0 2
9140: PUSH
9141: LD_VAR 0 2
9145: PUSH
9146: CALL_OW 45
9150: UNION
9151: ST_TO_ADDR
// end ;
9152: GO 9045
9154: POP
9155: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9156: LD_INT 24
9158: PPUSH
9159: LD_INT 3
9161: PPUSH
9162: LD_INT 1
9164: PPUSH
9165: LD_INT 47
9167: PPUSH
9168: LD_INT 100
9170: PPUSH
9171: CALL 72069 0 5
// sewiVeh := CreateVehicle ;
9175: LD_ADDR_EXP 71
9179: PUSH
9180: CALL_OW 45
9184: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9185: LD_EXP 71
9189: PPUSH
9190: LD_INT 6
9192: NEG
9193: PPUSH
9194: CALL_OW 242
// result := result union sewiVeh ;
9198: LD_ADDR_VAR 0 2
9202: PUSH
9203: LD_VAR 0 2
9207: PUSH
9208: LD_EXP 71
9212: UNION
9213: ST_TO_ADDR
// end ; end ; end ;
9214: GO 9217
9216: POP
// end ;
9217: LD_VAR 0 2
9221: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9222: LD_EXP 16
9226: IFFALSE 10067
9228: GO 9230
9230: DISABLE
9231: LD_INT 0
9233: PPUSH
9234: PPUSH
9235: PPUSH
9236: PPUSH
9237: PPUSH
9238: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9239: LD_ADDR_VAR 0 4
9243: PUSH
9244: LD_INT 11
9246: PUSH
9247: LD_INT 12
9249: PUSH
9250: EMPTY
9251: LIST
9252: LIST
9253: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 ] [ Difficulty ] ;
9254: LD_ADDR_VAR 0 3
9258: PUSH
9259: LD_INT 11550
9261: PUSH
9262: LD_INT 10150
9264: PUSH
9265: LD_INT 9800
9267: PUSH
9268: EMPTY
9269: LIST
9270: LIST
9271: LIST
9272: PUSH
9273: LD_OWVAR 67
9277: ARRAY
9278: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9279: LD_ADDR_VAR 0 6
9283: PUSH
9284: LD_INT 70
9286: PUSH
9287: LD_INT 118
9289: PUSH
9290: EMPTY
9291: LIST
9292: LIST
9293: PUSH
9294: LD_INT 78
9296: PUSH
9297: LD_INT 31
9299: PUSH
9300: EMPTY
9301: LIST
9302: LIST
9303: PUSH
9304: EMPTY
9305: LIST
9306: LIST
9307: ST_TO_ADDR
// repeat if missionStage = 2 then
9308: LD_EXP 15
9312: PUSH
9313: LD_INT 2
9315: EQUAL
9316: IFFALSE 9327
// wait ( 1 1$30 ) else
9318: LD_INT 3150
9320: PPUSH
9321: CALL_OW 67
9325: GO 9336
// wait ( time ) ;
9327: LD_VAR 0 3
9331: PPUSH
9332: CALL_OW 67
// if missionStage = 6 then
9336: LD_EXP 15
9340: PUSH
9341: LD_INT 6
9343: EQUAL
9344: IFFALSE 9372
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9346: LD_INT 51
9348: PPUSH
9349: LD_INT 6
9351: PPUSH
9352: LD_INT 2
9354: PPUSH
9355: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9359: LD_INT 57
9361: PPUSH
9362: LD_INT 6
9364: PPUSH
9365: LD_INT 2
9367: PPUSH
9368: CALL_OW 322
// end ; if missionStage = 8 then
9372: LD_EXP 15
9376: PUSH
9377: LD_INT 8
9379: EQUAL
9380: IFFALSE 9408
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9382: LD_INT 52
9384: PPUSH
9385: LD_INT 6
9387: PPUSH
9388: LD_INT 2
9390: PPUSH
9391: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9395: LD_INT 58
9397: PPUSH
9398: LD_INT 6
9400: PPUSH
9401: LD_INT 2
9403: PPUSH
9404: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9408: LD_EXP 15
9412: PUSH
9413: LD_INT 10
9415: EQUAL
9416: PUSH
9417: LD_OWVAR 67
9421: PUSH
9422: LD_INT 1
9424: GREATER
9425: AND
9426: IFFALSE 9454
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9428: LD_INT 53
9430: PPUSH
9431: LD_INT 6
9433: PPUSH
9434: LD_INT 2
9436: PPUSH
9437: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9441: LD_INT 59
9443: PPUSH
9444: LD_INT 6
9446: PPUSH
9447: LD_INT 2
9449: PPUSH
9450: CALL_OW 322
// end ; if activeAttacks then
9454: LD_EXP 16
9458: IFFALSE 10061
// begin if missionStage = 2 then
9460: LD_EXP 15
9464: PUSH
9465: LD_INT 2
9467: EQUAL
9468: IFFALSE 9478
// strength := 1 ;
9470: LD_ADDR_VAR 0 5
9474: PUSH
9475: LD_INT 1
9477: ST_TO_ADDR
// if missionStage > 2 then
9478: LD_EXP 15
9482: PUSH
9483: LD_INT 2
9485: GREATER
9486: IFFALSE 9496
// strength := 2 ;
9488: LD_ADDR_VAR 0 5
9492: PUSH
9493: LD_INT 2
9495: ST_TO_ADDR
// if missionStage > 6 then
9496: LD_EXP 15
9500: PUSH
9501: LD_INT 6
9503: GREATER
9504: IFFALSE 9514
// strength := 3 ;
9506: LD_ADDR_VAR 0 5
9510: PUSH
9511: LD_INT 3
9513: ST_TO_ADDR
// if missionStage > 10 then
9514: LD_EXP 15
9518: PUSH
9519: LD_INT 10
9521: GREATER
9522: IFFALSE 9532
// strength := 4 ;
9524: LD_ADDR_VAR 0 5
9528: PUSH
9529: LD_INT 4
9531: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9532: LD_ADDR_VAR 0 2
9536: PUSH
9537: LD_VAR 0 5
9541: PPUSH
9542: CALL 8087 0 1
9546: ST_TO_ADDR
// for i in tmp do
9547: LD_ADDR_VAR 0 1
9551: PUSH
9552: LD_VAR 0 2
9556: PUSH
9557: FOR_IN
9558: IFFALSE 9741
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9560: LD_VAR 0 1
9564: PPUSH
9565: LD_VAR 0 4
9569: PUSH
9570: LD_INT 1
9572: PPUSH
9573: LD_INT 2
9575: PPUSH
9576: CALL_OW 12
9580: ARRAY
9581: PPUSH
9582: LD_INT 0
9584: PPUSH
9585: CALL_OW 49
// if i = sewiVeh then
9589: LD_VAR 0 1
9593: PUSH
9594: LD_EXP 71
9598: EQUAL
9599: IFFALSE 9636
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9601: LD_ADDR_EXP 70
9605: PUSH
9606: LD_STRING Vsevolod
9608: PPUSH
9609: LD_INT 0
9611: PPUSH
9612: LD_STRING 
9614: PPUSH
9615: CALL 64894 0 3
9619: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9620: LD_EXP 70
9624: PPUSH
9625: LD_VAR 0 1
9629: PPUSH
9630: CALL_OW 52
// end else
9634: GO 9717
// if GetControl ( i ) = control_manual then
9636: LD_VAR 0 1
9640: PPUSH
9641: CALL_OW 263
9645: PUSH
9646: LD_INT 1
9648: EQUAL
9649: IFFALSE 9717
// begin uc_side := 6 ;
9651: LD_ADDR_OWVAR 20
9655: PUSH
9656: LD_INT 6
9658: ST_TO_ADDR
// uc_nation := 3 ;
9659: LD_ADDR_OWVAR 21
9663: PUSH
9664: LD_INT 3
9666: ST_TO_ADDR
// hc_gallery :=  ;
9667: LD_ADDR_OWVAR 33
9671: PUSH
9672: LD_STRING 
9674: ST_TO_ADDR
// hc_name :=  ;
9675: LD_ADDR_OWVAR 26
9679: PUSH
9680: LD_STRING 
9682: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9683: LD_INT 0
9685: PPUSH
9686: LD_INT 3
9688: PPUSH
9689: LD_INT 10
9691: PPUSH
9692: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9696: CALL_OW 44
9700: PPUSH
9701: LD_VAR 0 1
9705: PPUSH
9706: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9710: LD_INT 10
9712: PPUSH
9713: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9717: LD_VAR 0 1
9721: PPUSH
9722: LD_INT 111
9724: PPUSH
9725: LD_INT 197
9727: PPUSH
9728: CALL_OW 111
// wait ( 0 0$2 ) ;
9732: LD_INT 70
9734: PPUSH
9735: CALL_OW 67
// end ;
9739: GO 9557
9741: POP
9742: POP
// repeat wait ( 0 0$1 ) ;
9743: LD_INT 35
9745: PPUSH
9746: CALL_OW 67
// for i in tmp do
9750: LD_ADDR_VAR 0 1
9754: PUSH
9755: LD_VAR 0 2
9759: PUSH
9760: FOR_IN
9761: IFFALSE 10042
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9763: LD_INT 81
9765: PUSH
9766: LD_INT 6
9768: PUSH
9769: EMPTY
9770: LIST
9771: LIST
9772: PUSH
9773: LD_INT 91
9775: PUSH
9776: LD_VAR 0 1
9780: PUSH
9781: LD_INT 12
9783: PUSH
9784: EMPTY
9785: LIST
9786: LIST
9787: LIST
9788: PUSH
9789: EMPTY
9790: LIST
9791: LIST
9792: PPUSH
9793: CALL_OW 69
9797: IFFALSE 9855
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9799: LD_VAR 0 1
9803: PPUSH
9804: LD_INT 81
9806: PUSH
9807: LD_INT 6
9809: PUSH
9810: EMPTY
9811: LIST
9812: LIST
9813: PUSH
9814: LD_INT 91
9816: PUSH
9817: LD_VAR 0 1
9821: PUSH
9822: LD_INT 12
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PPUSH
9839: LD_VAR 0 1
9843: PPUSH
9844: CALL_OW 74
9848: PPUSH
9849: CALL_OW 115
9853: GO 10040
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9855: LD_INT 9
9857: PPUSH
9858: LD_INT 81
9860: PUSH
9861: LD_INT 6
9863: PUSH
9864: EMPTY
9865: LIST
9866: LIST
9867: PPUSH
9868: CALL_OW 70
9872: IFFALSE 10006
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9874: LD_VAR 0 1
9878: PPUSH
9879: LD_VAR 0 6
9883: PUSH
9884: LD_INT 1
9886: ARRAY
9887: PUSH
9888: LD_INT 1
9890: ARRAY
9891: PPUSH
9892: LD_VAR 0 6
9896: PUSH
9897: LD_INT 1
9899: ARRAY
9900: PUSH
9901: LD_INT 2
9903: ARRAY
9904: PPUSH
9905: CALL_OW 297
9909: PUSH
9910: LD_INT 10
9912: GREATER
9913: PUSH
9914: LD_VAR 0 1
9918: PPUSH
9919: LD_INT 9
9921: PPUSH
9922: CALL_OW 308
9926: NOT
9927: AND
9928: IFFALSE 9967
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9930: LD_VAR 0 1
9934: PPUSH
9935: LD_VAR 0 6
9939: PUSH
9940: LD_INT 1
9942: ARRAY
9943: PUSH
9944: LD_INT 1
9946: ARRAY
9947: PPUSH
9948: LD_VAR 0 6
9952: PUSH
9953: LD_INT 1
9955: ARRAY
9956: PUSH
9957: LD_INT 2
9959: ARRAY
9960: PPUSH
9961: CALL_OW 114
9965: GO 10004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9967: LD_VAR 0 1
9971: PPUSH
9972: LD_INT 9
9974: PPUSH
9975: LD_INT 81
9977: PUSH
9978: LD_INT 6
9980: PUSH
9981: EMPTY
9982: LIST
9983: LIST
9984: PPUSH
9985: CALL_OW 70
9989: PPUSH
9990: LD_VAR 0 1
9994: PPUSH
9995: CALL_OW 74
9999: PPUSH
10000: CALL_OW 115
// end else
10004: GO 10040
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10006: LD_VAR 0 1
10010: PPUSH
10011: LD_INT 81
10013: PUSH
10014: LD_INT 6
10016: PUSH
10017: EMPTY
10018: LIST
10019: LIST
10020: PPUSH
10021: CALL_OW 69
10025: PPUSH
10026: LD_VAR 0 1
10030: PPUSH
10031: CALL_OW 74
10035: PPUSH
10036: CALL_OW 115
// end ;
10040: GO 9760
10042: POP
10043: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10044: LD_INT 22
10046: PUSH
10047: LD_INT 6
10049: PUSH
10050: EMPTY
10051: LIST
10052: LIST
10053: PPUSH
10054: CALL_OW 69
10058: NOT
10059: IFFALSE 9743
// end ; until russianDestroyed ;
10061: LD_EXP 21
10065: IFFALSE 9308
// end ;
10067: PPOPN 6
10069: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10070: LD_EXP 21
10074: NOT
10075: PUSH
10076: LD_EXP 15
10080: PUSH
10081: LD_INT 6
10083: GREATEREQUAL
10084: AND
10085: PUSH
10086: LD_INT 2
10088: PPUSH
10089: LD_INT 1
10091: PPUSH
10092: CALL 59968 0 2
10096: NOT
10097: AND
10098: IFFALSE 11054
10100: GO 10102
10102: DISABLE
10103: LD_INT 0
10105: PPUSH
10106: PPUSH
10107: PPUSH
10108: PPUSH
// begin enable ;
10109: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10110: LD_INT 22
10112: PUSH
10113: LD_INT 3
10115: PUSH
10116: EMPTY
10117: LIST
10118: LIST
10119: PUSH
10120: LD_INT 30
10122: PUSH
10123: LD_INT 3
10125: PUSH
10126: EMPTY
10127: LIST
10128: LIST
10129: PUSH
10130: EMPTY
10131: LIST
10132: LIST
10133: PPUSH
10134: CALL_OW 69
10138: NOT
10139: IFFALSE 10143
// exit ;
10141: GO 11054
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10143: LD_ADDR_VAR 0 4
10147: PUSH
10148: LD_INT 22
10150: PUSH
10151: LD_INT 3
10153: PUSH
10154: EMPTY
10155: LIST
10156: LIST
10157: PUSH
10158: LD_INT 30
10160: PUSH
10161: LD_INT 34
10163: PUSH
10164: EMPTY
10165: LIST
10166: LIST
10167: PUSH
10168: EMPTY
10169: LIST
10170: LIST
10171: PPUSH
10172: CALL_OW 69
10176: ST_TO_ADDR
// if Prob ( 40 ) then
10177: LD_INT 40
10179: PPUSH
10180: CALL_OW 13
10184: IFFALSE 10311
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10186: LD_INT 2
10188: PPUSH
10189: LD_INT 22
10191: PUSH
10192: LD_INT 3
10194: PUSH
10195: LD_INT 3
10197: PUSH
10198: LD_INT 49
10200: PUSH
10201: EMPTY
10202: LIST
10203: LIST
10204: LIST
10205: LIST
10206: PUSH
10207: LD_INT 22
10209: PUSH
10210: LD_INT 3
10212: PUSH
10213: LD_INT 3
10215: PUSH
10216: LD_INT 49
10218: PUSH
10219: EMPTY
10220: LIST
10221: LIST
10222: LIST
10223: LIST
10224: PUSH
10225: LD_INT 22
10227: PUSH
10228: LD_INT 3
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: LD_INT 49
10236: PUSH
10237: EMPTY
10238: LIST
10239: LIST
10240: LIST
10241: LIST
10242: PUSH
10243: LD_INT 24
10245: PUSH
10246: LD_INT 3
10248: PUSH
10249: LD_INT 3
10251: PUSH
10252: LD_INT 46
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: LIST
10259: LIST
10260: PUSH
10261: LD_INT 24
10263: PUSH
10264: LD_INT 3
10266: PUSH
10267: LD_INT 3
10269: PUSH
10270: LD_INT 46
10272: PUSH
10273: EMPTY
10274: LIST
10275: LIST
10276: LIST
10277: LIST
10278: PUSH
10279: LD_INT 24
10281: PUSH
10282: LD_INT 3
10284: PUSH
10285: LD_INT 3
10287: PUSH
10288: LD_INT 46
10290: PUSH
10291: EMPTY
10292: LIST
10293: LIST
10294: LIST
10295: LIST
10296: PUSH
10297: EMPTY
10298: LIST
10299: LIST
10300: LIST
10301: LIST
10302: LIST
10303: LIST
10304: PPUSH
10305: CALL 58550 0 2
// end else
10309: GO 10434
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10311: LD_INT 2
10313: PPUSH
10314: LD_INT 24
10316: PUSH
10317: LD_INT 3
10319: PUSH
10320: LD_INT 3
10322: PUSH
10323: LD_INT 47
10325: PUSH
10326: EMPTY
10327: LIST
10328: LIST
10329: LIST
10330: LIST
10331: PUSH
10332: LD_INT 24
10334: PUSH
10335: LD_INT 3
10337: PUSH
10338: LD_INT 3
10340: PUSH
10341: LD_INT 47
10343: PUSH
10344: EMPTY
10345: LIST
10346: LIST
10347: LIST
10348: LIST
10349: PUSH
10350: LD_INT 24
10352: PUSH
10353: LD_INT 3
10355: PUSH
10356: LD_INT 3
10358: PUSH
10359: LD_INT 47
10361: PUSH
10362: EMPTY
10363: LIST
10364: LIST
10365: LIST
10366: LIST
10367: PUSH
10368: LD_INT 24
10370: PUSH
10371: LD_INT 3
10373: PUSH
10374: LD_INT 3
10376: PUSH
10377: LD_INT 46
10379: PUSH
10380: EMPTY
10381: LIST
10382: LIST
10383: LIST
10384: LIST
10385: PUSH
10386: LD_INT 24
10388: PUSH
10389: LD_INT 3
10391: PUSH
10392: LD_INT 3
10394: PUSH
10395: LD_INT 46
10397: PUSH
10398: EMPTY
10399: LIST
10400: LIST
10401: LIST
10402: LIST
10403: PUSH
10404: LD_INT 24
10406: PUSH
10407: LD_INT 3
10409: PUSH
10410: LD_INT 3
10412: PUSH
10413: LD_INT 46
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: PUSH
10422: EMPTY
10423: LIST
10424: LIST
10425: LIST
10426: LIST
10427: LIST
10428: LIST
10429: PPUSH
10430: CALL 58550 0 2
// end ; if Difficulty > 1 then
10434: LD_OWVAR 67
10438: PUSH
10439: LD_INT 1
10441: GREATER
10442: IFFALSE 10472
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10444: LD_INT 2
10446: PPUSH
10447: LD_INT 24
10449: PUSH
10450: LD_INT 3
10452: PUSH
10453: LD_INT 3
10455: PUSH
10456: LD_INT 47
10458: PUSH
10459: EMPTY
10460: LIST
10461: LIST
10462: LIST
10463: LIST
10464: PUSH
10465: EMPTY
10466: LIST
10467: PPUSH
10468: CALL 58550 0 2
// repeat wait ( 0 0$1 ) ;
10472: LD_INT 35
10474: PPUSH
10475: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10479: LD_INT 2
10481: PPUSH
10482: LD_INT 1
10484: PPUSH
10485: CALL 59968 0 2
10489: PUSH
10490: LD_INT 6
10492: PUSH
10493: LD_INT 7
10495: PUSH
10496: LD_INT 7
10498: PUSH
10499: EMPTY
10500: LIST
10501: LIST
10502: LIST
10503: PUSH
10504: LD_OWVAR 67
10508: ARRAY
10509: GREATEREQUAL
10510: IFFALSE 10472
// wait ( 0 0$30 ) ;
10512: LD_INT 1050
10514: PPUSH
10515: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10519: LD_ADDR_VAR 0 2
10523: PUSH
10524: LD_INT 2
10526: PPUSH
10527: LD_INT 1
10529: PPUSH
10530: CALL 59968 0 2
10534: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10535: LD_ADDR_EXP 121
10539: PUSH
10540: LD_EXP 121
10544: PPUSH
10545: LD_INT 2
10547: PPUSH
10548: LD_EXP 121
10552: PUSH
10553: LD_INT 2
10555: ARRAY
10556: PUSH
10557: LD_VAR 0 2
10561: DIFF
10562: PPUSH
10563: CALL_OW 1
10567: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10568: LD_ADDR_VAR 0 3
10572: PUSH
10573: LD_INT 0
10575: PPUSH
10576: LD_INT 1
10578: PPUSH
10579: CALL_OW 12
10583: ST_TO_ADDR
// if target then
10584: LD_VAR 0 3
10588: IFFALSE 10716
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10590: LD_ADDR_VAR 0 2
10594: PUSH
10595: LD_VAR 0 2
10599: PPUSH
10600: LD_INT 24
10602: PUSH
10603: LD_INT 250
10605: PUSH
10606: EMPTY
10607: LIST
10608: LIST
10609: PPUSH
10610: CALL_OW 72
10614: ST_TO_ADDR
// for i in tmp do
10615: LD_ADDR_VAR 0 1
10619: PUSH
10620: LD_VAR 0 2
10624: PUSH
10625: FOR_IN
10626: IFFALSE 10666
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10628: LD_VAR 0 1
10632: PPUSH
10633: LD_INT 139
10635: PPUSH
10636: LD_INT 89
10638: PPUSH
10639: CALL_OW 297
10643: PUSH
10644: LD_INT 9
10646: GREATER
10647: IFFALSE 10664
// ComMoveXY ( i , 139 , 89 ) ;
10649: LD_VAR 0 1
10653: PPUSH
10654: LD_INT 139
10656: PPUSH
10657: LD_INT 89
10659: PPUSH
10660: CALL_OW 111
10664: GO 10625
10666: POP
10667: POP
// wait ( 0 0$1 ) ;
10668: LD_INT 35
10670: PPUSH
10671: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10675: LD_VAR 0 2
10679: PPUSH
10680: LD_INT 92
10682: PUSH
10683: LD_INT 139
10685: PUSH
10686: LD_INT 89
10688: PUSH
10689: LD_INT 9
10691: PUSH
10692: EMPTY
10693: LIST
10694: LIST
10695: LIST
10696: LIST
10697: PPUSH
10698: CALL_OW 72
10702: PUSH
10703: LD_VAR 0 2
10707: PUSH
10708: LD_INT 1
10710: MINUS
10711: GREATEREQUAL
10712: IFFALSE 10590
// end else
10714: GO 10858
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10716: LD_VAR 0 2
10720: PPUSH
10721: LD_VAR 0 4
10725: PUSH
10726: LD_INT 1
10728: ARRAY
10729: PPUSH
10730: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10734: LD_ADDR_VAR 0 2
10738: PUSH
10739: LD_VAR 0 2
10743: PPUSH
10744: LD_INT 24
10746: PUSH
10747: LD_INT 250
10749: PUSH
10750: EMPTY
10751: LIST
10752: LIST
10753: PPUSH
10754: CALL_OW 72
10758: ST_TO_ADDR
// for i in tmp do
10759: LD_ADDR_VAR 0 1
10763: PUSH
10764: LD_VAR 0 2
10768: PUSH
10769: FOR_IN
10770: IFFALSE 10810
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10772: LD_VAR 0 1
10776: PPUSH
10777: LD_INT 124
10779: PPUSH
10780: LD_INT 139
10782: PPUSH
10783: CALL_OW 297
10787: PUSH
10788: LD_INT 9
10790: GREATER
10791: IFFALSE 10808
// ComMoveXY ( i , 124 , 139 ) ;
10793: LD_VAR 0 1
10797: PPUSH
10798: LD_INT 124
10800: PPUSH
10801: LD_INT 139
10803: PPUSH
10804: CALL_OW 111
10808: GO 10769
10810: POP
10811: POP
// wait ( 0 0$1 ) ;
10812: LD_INT 35
10814: PPUSH
10815: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10819: LD_VAR 0 2
10823: PPUSH
10824: LD_INT 92
10826: PUSH
10827: LD_INT 124
10829: PUSH
10830: LD_INT 139
10832: PUSH
10833: LD_INT 9
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: LIST
10840: LIST
10841: PPUSH
10842: CALL_OW 72
10846: PUSH
10847: LD_VAR 0 2
10851: PUSH
10852: LD_INT 1
10854: MINUS
10855: GREATEREQUAL
10856: IFFALSE 10734
// end ; repeat wait ( 0 0$1 ) ;
10858: LD_INT 35
10860: PPUSH
10861: CALL_OW 67
// for i in tmp do
10865: LD_ADDR_VAR 0 1
10869: PUSH
10870: LD_VAR 0 2
10874: PUSH
10875: FOR_IN
10876: IFFALSE 11045
// begin if GetLives ( i ) > 251 then
10878: LD_VAR 0 1
10882: PPUSH
10883: CALL_OW 256
10887: PUSH
10888: LD_INT 251
10890: GREATER
10891: IFFALSE 11016
// begin if GetWeapon ( i ) = ru_time_lapser then
10893: LD_VAR 0 1
10897: PPUSH
10898: CALL_OW 264
10902: PUSH
10903: LD_INT 49
10905: EQUAL
10906: IFFALSE 10962
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10908: LD_VAR 0 1
10912: PPUSH
10913: LD_INT 2
10915: PUSH
10916: LD_INT 22
10918: PUSH
10919: LD_INT 1
10921: PUSH
10922: EMPTY
10923: LIST
10924: LIST
10925: PUSH
10926: LD_INT 22
10928: PUSH
10929: LD_INT 8
10931: PUSH
10932: EMPTY
10933: LIST
10934: LIST
10935: PUSH
10936: EMPTY
10937: LIST
10938: LIST
10939: LIST
10940: PPUSH
10941: CALL_OW 69
10945: PPUSH
10946: LD_VAR 0 1
10950: PPUSH
10951: CALL_OW 74
10955: PPUSH
10956: CALL_OW 112
10960: GO 11014
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10962: LD_VAR 0 1
10966: PPUSH
10967: LD_INT 2
10969: PUSH
10970: LD_INT 22
10972: PUSH
10973: LD_INT 1
10975: PUSH
10976: EMPTY
10977: LIST
10978: LIST
10979: PUSH
10980: LD_INT 22
10982: PUSH
10983: LD_INT 8
10985: PUSH
10986: EMPTY
10987: LIST
10988: LIST
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: LIST
10994: PPUSH
10995: CALL_OW 69
10999: PPUSH
11000: LD_VAR 0 1
11004: PPUSH
11005: CALL_OW 74
11009: PPUSH
11010: CALL_OW 115
// end else
11014: GO 11043
// if IsDead ( i ) then
11016: LD_VAR 0 1
11020: PPUSH
11021: CALL_OW 301
11025: IFFALSE 11043
// tmp := tmp diff i ;
11027: LD_ADDR_VAR 0 2
11031: PUSH
11032: LD_VAR 0 2
11036: PUSH
11037: LD_VAR 0 1
11041: DIFF
11042: ST_TO_ADDR
// end ;
11043: GO 10875
11045: POP
11046: POP
// until not tmp ;
11047: LD_VAR 0 2
11051: NOT
11052: IFFALSE 10858
// end ; end_of_file
11054: PPOPN 4
11056: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11057: LD_INT 0
11059: PPUSH
11060: PPUSH
11061: PPUSH
11062: PPUSH
11063: PPUSH
11064: PPUSH
// side := 7 ;
11065: LD_ADDR_VAR 0 5
11069: PUSH
11070: LD_INT 7
11072: ST_TO_ADDR
// uc_side := side ;
11073: LD_ADDR_OWVAR 20
11077: PUSH
11078: LD_VAR 0 5
11082: ST_TO_ADDR
// uc_nation := 1 ;
11083: LD_ADDR_OWVAR 21
11087: PUSH
11088: LD_INT 1
11090: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11091: LD_ADDR_VAR 0 2
11095: PUSH
11096: LD_INT 22
11098: PUSH
11099: LD_VAR 0 5
11103: PUSH
11104: EMPTY
11105: LIST
11106: LIST
11107: PUSH
11108: LD_INT 21
11110: PUSH
11111: LD_INT 3
11113: PUSH
11114: EMPTY
11115: LIST
11116: LIST
11117: PUSH
11118: EMPTY
11119: LIST
11120: LIST
11121: PPUSH
11122: CALL_OW 69
11126: PUSH
11127: FOR_IN
11128: IFFALSE 11144
// SetBLevel ( i , 10 ) ;
11130: LD_VAR 0 2
11134: PPUSH
11135: LD_INT 10
11137: PPUSH
11138: CALL_OW 241
11142: GO 11127
11144: POP
11145: POP
// base := GetBase ( al_depot ) ;
11146: LD_ADDR_VAR 0 4
11150: PUSH
11151: LD_INT 2
11153: PPUSH
11154: CALL_OW 274
11158: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11159: LD_ADDR_VAR 0 6
11163: PUSH
11164: LD_INT 22
11166: PUSH
11167: LD_VAR 0 5
11171: PUSH
11172: EMPTY
11173: LIST
11174: LIST
11175: PUSH
11176: LD_INT 30
11178: PUSH
11179: LD_INT 34
11181: PUSH
11182: EMPTY
11183: LIST
11184: LIST
11185: PUSH
11186: EMPTY
11187: LIST
11188: LIST
11189: PPUSH
11190: CALL_OW 69
11194: ST_TO_ADDR
// if teleport then
11195: LD_VAR 0 6
11199: IFFALSE 11220
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11201: LD_VAR 0 6
11205: PUSH
11206: LD_INT 1
11208: ARRAY
11209: PPUSH
11210: LD_INT 262
11212: PPUSH
11213: LD_INT 119
11215: PPUSH
11216: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11220: LD_VAR 0 4
11224: PPUSH
11225: LD_INT 1
11227: PPUSH
11228: LD_INT 19500
11230: PPUSH
11231: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11235: LD_VAR 0 4
11239: PPUSH
11240: LD_INT 2
11242: PPUSH
11243: LD_INT 200
11245: PPUSH
11246: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11250: LD_VAR 0 4
11254: PPUSH
11255: LD_INT 3
11257: PPUSH
11258: LD_INT 650
11260: PPUSH
11261: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11265: LD_ADDR_EXP 74
11269: PUSH
11270: LD_STRING Roth
11272: PPUSH
11273: CALL_OW 25
11277: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11278: LD_ADDR_EXP 75
11282: PUSH
11283: LD_STRING Simms
11285: PPUSH
11286: LD_EXP 1
11290: NOT
11291: PPUSH
11292: LD_STRING 10c_
11294: PPUSH
11295: CALL 64894 0 3
11299: ST_TO_ADDR
// if not Simms then
11300: LD_EXP 75
11304: NOT
11305: IFFALSE 11335
// begin uc_nation := 1 ;
11307: LD_ADDR_OWVAR 21
11311: PUSH
11312: LD_INT 1
11314: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11315: LD_INT 2
11317: PPUSH
11318: LD_INT 10
11320: PPUSH
11321: CALL_OW 384
// Simms := CreateHuman ;
11325: LD_ADDR_EXP 75
11329: PUSH
11330: CALL_OW 44
11334: ST_TO_ADDR
// end ; uc_nation := 3 ;
11335: LD_ADDR_OWVAR 21
11339: PUSH
11340: LD_INT 3
11342: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11343: LD_ADDR_EXP 76
11347: PUSH
11348: LD_STRING Kirilenkova
11350: PPUSH
11351: CALL_OW 25
11355: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11356: LD_ADDR_EXP 90
11360: PUSH
11361: LD_STRING Oblukov
11363: PPUSH
11364: CALL_OW 25
11368: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11369: LD_ADDR_EXP 77
11373: PUSH
11374: LD_STRING Dolgov
11376: PPUSH
11377: CALL_OW 25
11381: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11382: LD_ADDR_EXP 78
11386: PUSH
11387: LD_STRING Petrosyan
11389: PPUSH
11390: CALL_OW 25
11394: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11395: LD_ADDR_EXP 89
11399: PUSH
11400: LD_STRING Scholtze
11402: PPUSH
11403: CALL_OW 25
11407: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11408: LD_ADDR_EXP 88
11412: PUSH
11413: LD_STRING Kapitsova
11415: PPUSH
11416: CALL_OW 25
11420: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11421: LD_ADDR_EXP 79
11425: PUSH
11426: LD_STRING Petrovova
11428: PPUSH
11429: CALL_OW 25
11433: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11434: LD_ADDR_EXP 80
11438: PUSH
11439: LD_STRING Kuzmov
11441: PPUSH
11442: CALL_OW 25
11446: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11447: LD_ADDR_EXP 87
11451: PUSH
11452: LD_STRING Karamazov
11454: PPUSH
11455: CALL_OW 25
11459: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11460: LD_STRING 13_Lipshchin_1
11462: PPUSH
11463: LD_INT 0
11465: PPUSH
11466: CALL_OW 30
11470: IFFALSE 11485
// Lipshchin := NewCharacter ( Lipshchin ) ;
11472: LD_ADDR_EXP 81
11476: PUSH
11477: LD_STRING Lipshchin
11479: PPUSH
11480: CALL_OW 25
11484: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11485: LD_STRING 13_Titov_1
11487: PPUSH
11488: LD_INT 0
11490: PPUSH
11491: CALL_OW 30
11495: IFFALSE 11510
// Titov := NewCharacter ( Titov ) ;
11497: LD_ADDR_EXP 83
11501: PUSH
11502: LD_STRING Titov
11504: PPUSH
11505: CALL_OW 25
11509: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11510: LD_STRING 13_Gnyevko_1
11512: PPUSH
11513: LD_INT 0
11515: PPUSH
11516: CALL_OW 30
11520: IFFALSE 11535
// Gnyevko := NewCharacter ( Gnyevko ) ;
11522: LD_ADDR_EXP 82
11526: PUSH
11527: LD_STRING Gnyevko
11529: PPUSH
11530: CALL_OW 25
11534: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11535: LD_STRING 13_Xavier_1
11537: PPUSH
11538: LD_INT 0
11540: PPUSH
11541: CALL_OW 30
11545: IFFALSE 11560
// Xavier := NewCharacter ( Xavier2 ) ;
11547: LD_ADDR_EXP 84
11551: PUSH
11552: LD_STRING Xavier2
11554: PPUSH
11555: CALL_OW 25
11559: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11560: LD_STRING 13_Belkov_1
11562: PPUSH
11563: LD_INT 0
11565: PPUSH
11566: CALL_OW 30
11570: IFFALSE 11585
// Belkov := NewCharacter ( Belkov ) ;
11572: LD_ADDR_EXP 85
11576: PUSH
11577: LD_STRING Belkov
11579: PPUSH
11580: CALL_OW 25
11584: ST_TO_ADDR
// if not BurlakStatus then
11585: LD_EXP 9
11589: NOT
11590: IFFALSE 11605
// Burlak = NewCharacter ( Burlak ) ;
11592: LD_ADDR_EXP 86
11596: PUSH
11597: LD_STRING Burlak
11599: PPUSH
11600: CALL_OW 25
11604: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11605: LD_ADDR_VAR 0 3
11609: PUSH
11610: LD_EXP 74
11614: PUSH
11615: LD_EXP 76
11619: PUSH
11620: LD_EXP 90
11624: PUSH
11625: LD_EXP 77
11629: PUSH
11630: LD_EXP 78
11634: PUSH
11635: LD_EXP 89
11639: PUSH
11640: LD_EXP 88
11644: PUSH
11645: LD_EXP 79
11649: PUSH
11650: LD_EXP 80
11654: PUSH
11655: LD_EXP 87
11659: PUSH
11660: EMPTY
11661: LIST
11662: LIST
11663: LIST
11664: LIST
11665: LIST
11666: LIST
11667: LIST
11668: LIST
11669: LIST
11670: LIST
11671: ST_TO_ADDR
// if Simms then
11672: LD_EXP 75
11676: IFFALSE 11694
// tmp := tmp ^ Simms ;
11678: LD_ADDR_VAR 0 3
11682: PUSH
11683: LD_VAR 0 3
11687: PUSH
11688: LD_EXP 75
11692: ADD
11693: ST_TO_ADDR
// if Titov then
11694: LD_EXP 83
11698: IFFALSE 11716
// tmp := tmp ^ Titov ;
11700: LD_ADDR_VAR 0 3
11704: PUSH
11705: LD_VAR 0 3
11709: PUSH
11710: LD_EXP 83
11714: ADD
11715: ST_TO_ADDR
// if Lipshchin then
11716: LD_EXP 81
11720: IFFALSE 11738
// tmp := tmp ^ Lipshchin ;
11722: LD_ADDR_VAR 0 3
11726: PUSH
11727: LD_VAR 0 3
11731: PUSH
11732: LD_EXP 81
11736: ADD
11737: ST_TO_ADDR
// if Gnyevko then
11738: LD_EXP 82
11742: IFFALSE 11760
// tmp := tmp ^ Gnyevko ;
11744: LD_ADDR_VAR 0 3
11748: PUSH
11749: LD_VAR 0 3
11753: PUSH
11754: LD_EXP 82
11758: ADD
11759: ST_TO_ADDR
// if Xavier then
11760: LD_EXP 84
11764: IFFALSE 11782
// tmp := tmp ^ Xavier ;
11766: LD_ADDR_VAR 0 3
11770: PUSH
11771: LD_VAR 0 3
11775: PUSH
11776: LD_EXP 84
11780: ADD
11781: ST_TO_ADDR
// if Belkov then
11782: LD_EXP 85
11786: IFFALSE 11804
// tmp := tmp ^ Belkov ;
11788: LD_ADDR_VAR 0 3
11792: PUSH
11793: LD_VAR 0 3
11797: PUSH
11798: LD_EXP 85
11802: ADD
11803: ST_TO_ADDR
// if Burlak then
11804: LD_EXP 86
11808: IFFALSE 11826
// tmp := tmp ^ Burlak ;
11810: LD_ADDR_VAR 0 3
11814: PUSH
11815: LD_VAR 0 3
11819: PUSH
11820: LD_EXP 86
11824: ADD
11825: ST_TO_ADDR
// for i = 1 to 11 do
11826: LD_ADDR_VAR 0 2
11830: PUSH
11831: DOUBLE
11832: LD_INT 1
11834: DEC
11835: ST_TO_ADDR
11836: LD_INT 11
11838: PUSH
11839: FOR_TO
11840: IFFALSE 11906
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11842: LD_ADDR_OWVAR 21
11846: PUSH
11847: LD_INT 1
11849: PUSH
11850: LD_INT 3
11852: PUSH
11853: EMPTY
11854: LIST
11855: LIST
11856: PUSH
11857: LD_INT 1
11859: PPUSH
11860: LD_INT 2
11862: PPUSH
11863: CALL_OW 12
11867: ARRAY
11868: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11869: LD_INT 0
11871: PPUSH
11872: LD_VAR 0 2
11876: PUSH
11877: LD_INT 2
11879: DIV
11880: PPUSH
11881: LD_INT 10
11883: PPUSH
11884: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11888: LD_ADDR_VAR 0 3
11892: PUSH
11893: LD_VAR 0 3
11897: PUSH
11898: CALL_OW 44
11902: ADD
11903: ST_TO_ADDR
// end ;
11904: GO 11839
11906: POP
11907: POP
// for i in tmp do
11908: LD_ADDR_VAR 0 2
11912: PUSH
11913: LD_VAR 0 3
11917: PUSH
11918: FOR_IN
11919: IFFALSE 11944
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11921: LD_VAR 0 2
11925: PPUSH
11926: LD_INT 260
11928: PPUSH
11929: LD_INT 235
11931: PPUSH
11932: LD_INT 8
11934: PPUSH
11935: LD_INT 0
11937: PPUSH
11938: CALL_OW 50
11942: GO 11918
11944: POP
11945: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11946: LD_ADDR_EXP 102
11950: PUSH
11951: LD_EXP 102
11955: PPUSH
11956: LD_INT 1
11958: PPUSH
11959: LD_INT 22
11961: PUSH
11962: LD_VAR 0 5
11966: PUSH
11967: EMPTY
11968: LIST
11969: LIST
11970: PUSH
11971: LD_INT 3
11973: PUSH
11974: LD_INT 21
11976: PUSH
11977: LD_INT 2
11979: PUSH
11980: EMPTY
11981: LIST
11982: LIST
11983: PUSH
11984: EMPTY
11985: LIST
11986: LIST
11987: PUSH
11988: EMPTY
11989: LIST
11990: LIST
11991: PPUSH
11992: CALL_OW 69
11996: PUSH
11997: LD_EXP 74
12001: PUSH
12002: LD_EXP 75
12006: PUSH
12007: EMPTY
12008: LIST
12009: LIST
12010: DIFF
12011: PPUSH
12012: CALL_OW 1
12016: ST_TO_ADDR
// uc_side := 0 ;
12017: LD_ADDR_OWVAR 20
12021: PUSH
12022: LD_INT 0
12024: ST_TO_ADDR
// uc_nation := 0 ;
12025: LD_ADDR_OWVAR 21
12029: PUSH
12030: LD_INT 0
12032: ST_TO_ADDR
// for i = 1 to 5 do
12033: LD_ADDR_VAR 0 2
12037: PUSH
12038: DOUBLE
12039: LD_INT 1
12041: DEC
12042: ST_TO_ADDR
12043: LD_INT 5
12045: PUSH
12046: FOR_TO
12047: IFFALSE 12084
// begin InitHc ;
12049: CALL_OW 19
// hc_class := class_apeman ;
12053: LD_ADDR_OWVAR 28
12057: PUSH
12058: LD_INT 12
12060: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12061: CALL_OW 44
12065: PPUSH
12066: LD_INT 299
12068: PPUSH
12069: LD_INT 229
12071: PPUSH
12072: LD_INT 10
12074: PPUSH
12075: LD_INT 0
12077: PPUSH
12078: CALL_OW 50
// end ;
12082: GO 12046
12084: POP
12085: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12086: LD_EXP 74
12090: PPUSH
12091: LD_INT 259
12093: PPUSH
12094: LD_INT 235
12096: PPUSH
12097: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12101: LD_EXP 74
12105: PPUSH
12106: LD_INT 262
12108: PPUSH
12109: LD_INT 235
12111: PPUSH
12112: CALL_OW 178
// if Simms then
12116: LD_EXP 75
12120: IFFALSE 12151
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12122: LD_EXP 75
12126: PPUSH
12127: LD_INT 262
12129: PPUSH
12130: LD_INT 235
12132: PPUSH
12133: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12137: LD_EXP 75
12141: PPUSH
12142: LD_EXP 74
12146: PPUSH
12147: CALL_OW 179
// end ; end ;
12151: LD_VAR 0 1
12155: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12156: LD_EXP 31
12160: PUSH
12161: LD_EXP 23
12165: NOT
12166: AND
12167: IFFALSE 12343
12169: GO 12171
12171: DISABLE
12172: LD_INT 0
12174: PPUSH
12175: PPUSH
12176: PPUSH
// begin enable ;
12177: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12178: LD_ADDR_VAR 0 2
12182: PUSH
12183: LD_INT 81
12185: PUSH
12186: LD_INT 7
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: PUSH
12193: LD_INT 2
12195: PUSH
12196: LD_INT 32
12198: PUSH
12199: LD_INT 3
12201: PUSH
12202: EMPTY
12203: LIST
12204: LIST
12205: PUSH
12206: LD_INT 30
12208: PUSH
12209: LD_INT 30
12211: PUSH
12212: EMPTY
12213: LIST
12214: LIST
12215: PUSH
12216: LD_INT 30
12218: PUSH
12219: LD_INT 28
12221: PUSH
12222: EMPTY
12223: LIST
12224: LIST
12225: PUSH
12226: LD_INT 34
12228: PUSH
12229: LD_INT 49
12231: PUSH
12232: EMPTY
12233: LIST
12234: LIST
12235: PUSH
12236: LD_INT 34
12238: PUSH
12239: LD_INT 10
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: PUSH
12246: LD_INT 34
12248: PUSH
12249: LD_INT 8
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: PUSH
12256: EMPTY
12257: LIST
12258: LIST
12259: LIST
12260: LIST
12261: LIST
12262: LIST
12263: LIST
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: PPUSH
12269: CALL_OW 69
12273: ST_TO_ADDR
// if not tmp then
12274: LD_VAR 0 2
12278: NOT
12279: IFFALSE 12283
// exit ;
12281: GO 12343
// target := tmp [ rand ( 1 , tmp ) ] ;
12283: LD_ADDR_VAR 0 3
12287: PUSH
12288: LD_VAR 0 2
12292: PUSH
12293: LD_INT 1
12295: PPUSH
12296: LD_VAR 0 2
12300: PPUSH
12301: CALL_OW 12
12305: ARRAY
12306: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12307: LD_VAR 0 3
12311: PPUSH
12312: CALL_OW 255
12316: PUSH
12317: LD_INT 1
12319: EQUAL
12320: IFFALSE 12331
// CenterNowOnUnits ( target ) ;
12322: LD_VAR 0 3
12326: PPUSH
12327: CALL_OW 87
// SetLives ( target , 0 ) ;
12331: LD_VAR 0 3
12335: PPUSH
12336: LD_INT 0
12338: PPUSH
12339: CALL_OW 234
// end ;
12343: PPOPN 3
12345: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12346: LD_EXP 23
12350: NOT
12351: PUSH
12352: LD_EXP 31
12356: AND
12357: IFFALSE 12879
12359: GO 12361
12361: DISABLE
12362: LD_INT 0
12364: PPUSH
12365: PPUSH
12366: PPUSH
// begin uc_side := 7 ;
12367: LD_ADDR_OWVAR 20
12371: PUSH
12372: LD_INT 7
12374: ST_TO_ADDR
// uc_nation := 1 ;
12375: LD_ADDR_OWVAR 21
12379: PUSH
12380: LD_INT 1
12382: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12383: LD_ADDR_VAR 0 3
12387: PUSH
12388: LD_INT 125
12390: PUSH
12391: LD_INT 163
12393: PUSH
12394: EMPTY
12395: LIST
12396: LIST
12397: PUSH
12398: LD_INT 185
12400: PUSH
12401: LD_INT 168
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PUSH
12408: LD_INT 111
12410: PUSH
12411: LD_INT 97
12413: PUSH
12414: EMPTY
12415: LIST
12416: LIST
12417: PUSH
12418: EMPTY
12419: LIST
12420: LIST
12421: LIST
12422: PPUSH
12423: CALL 107916 0 1
12427: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12428: LD_ADDR_EXP 91
12432: PUSH
12433: EMPTY
12434: ST_TO_ADDR
// for i = 1 to Difficulty do
12435: LD_ADDR_VAR 0 1
12439: PUSH
12440: DOUBLE
12441: LD_INT 1
12443: DEC
12444: ST_TO_ADDR
12445: LD_OWVAR 67
12449: PUSH
12450: FOR_TO
12451: IFFALSE 12609
// begin InitHc ;
12453: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12457: LD_INT 0
12459: PPUSH
12460: LD_INT 8
12462: PPUSH
12463: CALL_OW 381
// un := CreateHuman ;
12467: LD_ADDR_VAR 0 2
12471: PUSH
12472: CALL_OW 44
12476: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12477: LD_VAR 0 2
12481: PPUSH
12482: LD_INT 258
12484: PPUSH
12485: LD_INT 267
12487: PPUSH
12488: LD_INT 4
12490: PPUSH
12491: LD_INT 0
12493: PPUSH
12494: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12498: LD_ADDR_EXP 91
12502: PUSH
12503: LD_EXP 91
12507: PUSH
12508: LD_VAR 0 2
12512: UNION
12513: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12514: LD_VAR 0 2
12518: PPUSH
12519: LD_VAR 0 3
12523: PUSH
12524: LD_VAR 0 1
12528: ARRAY
12529: PUSH
12530: LD_INT 1
12532: ARRAY
12533: PPUSH
12534: LD_VAR 0 3
12538: PUSH
12539: LD_VAR 0 1
12543: ARRAY
12544: PUSH
12545: LD_INT 2
12547: ARRAY
12548: PPUSH
12549: LD_INT 4
12551: PPUSH
12552: LD_INT 1
12554: PPUSH
12555: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12559: LD_VAR 0 2
12563: PPUSH
12564: LD_VAR 0 3
12568: PUSH
12569: LD_VAR 0 1
12573: ARRAY
12574: PUSH
12575: LD_INT 1
12577: ARRAY
12578: PPUSH
12579: LD_VAR 0 3
12583: PUSH
12584: LD_VAR 0 1
12588: ARRAY
12589: PUSH
12590: LD_INT 2
12592: ARRAY
12593: PPUSH
12594: CALL_OW 171
// AddComInvisible ( un ) ;
12598: LD_VAR 0 2
12602: PPUSH
12603: CALL_OW 212
// end ;
12607: GO 12450
12609: POP
12610: POP
// repeat wait ( 0 0$20 ) ;
12611: LD_INT 700
12613: PPUSH
12614: CALL_OW 67
// for i in allianceSpecialForce do
12618: LD_ADDR_VAR 0 1
12622: PUSH
12623: LD_EXP 91
12627: PUSH
12628: FOR_IN
12629: IFFALSE 12864
// begin if IsInvisible ( i ) then
12631: LD_VAR 0 1
12635: PPUSH
12636: CALL_OW 571
12640: IFFALSE 12833
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12642: LD_ADDR_VAR 0 3
12646: PUSH
12647: LD_INT 22
12649: PUSH
12650: LD_INT 1
12652: PUSH
12653: EMPTY
12654: LIST
12655: LIST
12656: PUSH
12657: LD_INT 50
12659: PUSH
12660: EMPTY
12661: LIST
12662: PUSH
12663: LD_INT 56
12665: PUSH
12666: EMPTY
12667: LIST
12668: PUSH
12669: LD_INT 91
12671: PUSH
12672: LD_VAR 0 1
12676: PUSH
12677: LD_INT 25
12679: PUSH
12680: LD_INT 30
12682: PUSH
12683: LD_INT 35
12685: PUSH
12686: EMPTY
12687: LIST
12688: LIST
12689: LIST
12690: PUSH
12691: LD_OWVAR 67
12695: ARRAY
12696: PUSH
12697: EMPTY
12698: LIST
12699: LIST
12700: LIST
12701: PUSH
12702: LD_INT 2
12704: PUSH
12705: LD_INT 25
12707: PUSH
12708: LD_INT 1
12710: PUSH
12711: EMPTY
12712: LIST
12713: LIST
12714: PUSH
12715: LD_INT 25
12717: PUSH
12718: LD_INT 2
12720: PUSH
12721: EMPTY
12722: LIST
12723: LIST
12724: PUSH
12725: LD_INT 25
12727: PUSH
12728: LD_INT 3
12730: PUSH
12731: EMPTY
12732: LIST
12733: LIST
12734: PUSH
12735: LD_INT 25
12737: PUSH
12738: LD_INT 4
12740: PUSH
12741: EMPTY
12742: LIST
12743: LIST
12744: PUSH
12745: LD_INT 25
12747: PUSH
12748: LD_INT 5
12750: PUSH
12751: EMPTY
12752: LIST
12753: LIST
12754: PUSH
12755: LD_INT 25
12757: PUSH
12758: LD_INT 8
12760: PUSH
12761: EMPTY
12762: LIST
12763: LIST
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: LIST
12769: LIST
12770: LIST
12771: LIST
12772: LIST
12773: PUSH
12774: EMPTY
12775: LIST
12776: LIST
12777: LIST
12778: LIST
12779: LIST
12780: PPUSH
12781: CALL_OW 69
12785: ST_TO_ADDR
// if not tmp then
12786: LD_VAR 0 3
12790: NOT
12791: IFFALSE 12795
// continue ;
12793: GO 12628
// if Prob ( 30 * Difficulty ) then
12795: LD_INT 30
12797: PUSH
12798: LD_OWVAR 67
12802: MUL
12803: PPUSH
12804: CALL_OW 13
12808: IFFALSE 12833
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12810: LD_VAR 0 3
12814: PUSH
12815: LD_INT 1
12817: PPUSH
12818: LD_VAR 0 3
12822: PPUSH
12823: CALL_OW 12
12827: ARRAY
12828: PPUSH
12829: CALL 31000 0 1
// end ; if IsDead ( i ) then
12833: LD_VAR 0 1
12837: PPUSH
12838: CALL_OW 301
12842: IFFALSE 12862
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12844: LD_ADDR_EXP 91
12848: PUSH
12849: LD_EXP 91
12853: PUSH
12854: LD_VAR 0 1
12858: DIFF
12859: ST_TO_ADDR
// continue ;
12860: GO 12628
// end ; end ;
12862: GO 12628
12864: POP
12865: POP
// until allianceDestroyed or not allianceSpecialForce ;
12866: LD_EXP 23
12870: PUSH
12871: LD_EXP 91
12875: NOT
12876: OR
12877: IFFALSE 12611
// end ;
12879: PPOPN 3
12881: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12882: LD_EXP 23
12886: NOT
12887: PUSH
12888: LD_EXP 31
12892: AND
12893: IFFALSE 13860
12895: GO 12897
12897: DISABLE
12898: LD_INT 0
12900: PPUSH
12901: PPUSH
12902: PPUSH
12903: PPUSH
// begin enable ;
12904: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12905: LD_INT 22
12907: PUSH
12908: LD_INT 7
12910: PUSH
12911: EMPTY
12912: LIST
12913: LIST
12914: PUSH
12915: LD_INT 30
12917: PUSH
12918: LD_INT 3
12920: PUSH
12921: EMPTY
12922: LIST
12923: LIST
12924: PUSH
12925: EMPTY
12926: LIST
12927: LIST
12928: PPUSH
12929: CALL_OW 69
12933: NOT
12934: IFFALSE 12938
// exit ;
12936: GO 13860
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12938: LD_ADDR_VAR 0 4
12942: PUSH
12943: LD_INT 22
12945: PUSH
12946: LD_INT 7
12948: PUSH
12949: EMPTY
12950: LIST
12951: LIST
12952: PUSH
12953: LD_INT 30
12955: PUSH
12956: LD_INT 34
12958: PUSH
12959: EMPTY
12960: LIST
12961: LIST
12962: PUSH
12963: EMPTY
12964: LIST
12965: LIST
12966: PPUSH
12967: CALL_OW 69
12971: ST_TO_ADDR
// if Prob ( 40 ) then
12972: LD_INT 40
12974: PPUSH
12975: CALL_OW 13
12979: IFFALSE 13106
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12981: LD_INT 1
12983: PPUSH
12984: LD_INT 5
12986: PUSH
12987: LD_INT 3
12989: PUSH
12990: LD_INT 2
12992: PUSH
12993: LD_INT 6
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: PUSH
13002: LD_INT 5
13004: PUSH
13005: LD_INT 3
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: LD_INT 6
13013: PUSH
13014: EMPTY
13015: LIST
13016: LIST
13017: LIST
13018: LIST
13019: PUSH
13020: LD_INT 5
13022: PUSH
13023: LD_INT 3
13025: PUSH
13026: LD_INT 2
13028: PUSH
13029: LD_INT 6
13031: PUSH
13032: EMPTY
13033: LIST
13034: LIST
13035: LIST
13036: LIST
13037: PUSH
13038: LD_INT 24
13040: PUSH
13041: LD_INT 3
13043: PUSH
13044: LD_INT 3
13046: PUSH
13047: LD_INT 45
13049: PUSH
13050: EMPTY
13051: LIST
13052: LIST
13053: LIST
13054: LIST
13055: PUSH
13056: LD_INT 24
13058: PUSH
13059: LD_INT 3
13061: PUSH
13062: LD_INT 3
13064: PUSH
13065: LD_INT 47
13067: PUSH
13068: EMPTY
13069: LIST
13070: LIST
13071: LIST
13072: LIST
13073: PUSH
13074: LD_INT 24
13076: PUSH
13077: LD_INT 3
13079: PUSH
13080: LD_INT 3
13082: PUSH
13083: LD_INT 45
13085: PUSH
13086: EMPTY
13087: LIST
13088: LIST
13089: LIST
13090: LIST
13091: PUSH
13092: EMPTY
13093: LIST
13094: LIST
13095: LIST
13096: LIST
13097: LIST
13098: LIST
13099: PPUSH
13100: CALL 58550 0 2
// end else
13104: GO 13229
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13106: LD_INT 1
13108: PPUSH
13109: LD_INT 24
13111: PUSH
13112: LD_INT 3
13114: PUSH
13115: LD_INT 3
13117: PUSH
13118: LD_INT 47
13120: PUSH
13121: EMPTY
13122: LIST
13123: LIST
13124: LIST
13125: LIST
13126: PUSH
13127: LD_INT 24
13129: PUSH
13130: LD_INT 3
13132: PUSH
13133: LD_INT 3
13135: PUSH
13136: LD_INT 47
13138: PUSH
13139: EMPTY
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: PUSH
13145: LD_INT 5
13147: PUSH
13148: LD_INT 3
13150: PUSH
13151: LD_INT 2
13153: PUSH
13154: LD_INT 9
13156: PUSH
13157: EMPTY
13158: LIST
13159: LIST
13160: LIST
13161: LIST
13162: PUSH
13163: LD_INT 5
13165: PUSH
13166: LD_INT 3
13168: PUSH
13169: LD_INT 2
13171: PUSH
13172: LD_INT 9
13174: PUSH
13175: EMPTY
13176: LIST
13177: LIST
13178: LIST
13179: LIST
13180: PUSH
13181: LD_INT 24
13183: PUSH
13184: LD_INT 1
13186: PUSH
13187: LD_INT 3
13189: PUSH
13190: LD_INT 45
13192: PUSH
13193: EMPTY
13194: LIST
13195: LIST
13196: LIST
13197: LIST
13198: PUSH
13199: LD_INT 24
13201: PUSH
13202: LD_INT 1
13204: PUSH
13205: LD_INT 3
13207: PUSH
13208: LD_INT 45
13210: PUSH
13211: EMPTY
13212: LIST
13213: LIST
13214: LIST
13215: LIST
13216: PUSH
13217: EMPTY
13218: LIST
13219: LIST
13220: LIST
13221: LIST
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL 58550 0 2
// end ; if Difficulty > 1 then
13229: LD_OWVAR 67
13233: PUSH
13234: LD_INT 1
13236: GREATER
13237: IFFALSE 13267
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13239: LD_INT 1
13241: PPUSH
13242: LD_INT 24
13244: PUSH
13245: LD_INT 3
13247: PUSH
13248: LD_INT 3
13250: PUSH
13251: LD_INT 47
13253: PUSH
13254: EMPTY
13255: LIST
13256: LIST
13257: LIST
13258: LIST
13259: PUSH
13260: EMPTY
13261: LIST
13262: PPUSH
13263: CALL 58550 0 2
// repeat wait ( 0 0$1 ) ;
13267: LD_INT 35
13269: PPUSH
13270: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13274: LD_INT 1
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL 59968 0 2
13284: PUSH
13285: LD_INT 6
13287: PUSH
13288: LD_INT 7
13290: PUSH
13291: LD_INT 7
13293: PUSH
13294: EMPTY
13295: LIST
13296: LIST
13297: LIST
13298: PUSH
13299: LD_OWVAR 67
13303: ARRAY
13304: GREATEREQUAL
13305: IFFALSE 13267
// wait ( 0 0$40 ) ;
13307: LD_INT 1400
13309: PPUSH
13310: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13314: LD_ADDR_VAR 0 2
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_INT 1
13324: PPUSH
13325: CALL 59968 0 2
13329: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13330: LD_ADDR_EXP 121
13334: PUSH
13335: LD_EXP 121
13339: PPUSH
13340: LD_INT 1
13342: PPUSH
13343: LD_EXP 121
13347: PUSH
13348: LD_INT 1
13350: ARRAY
13351: PUSH
13352: LD_VAR 0 2
13356: DIFF
13357: PPUSH
13358: CALL_OW 1
13362: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13363: LD_ADDR_VAR 0 3
13367: PUSH
13368: LD_INT 0
13370: PPUSH
13371: LD_INT 1
13373: PPUSH
13374: CALL_OW 12
13378: ST_TO_ADDR
// if target then
13379: LD_VAR 0 3
13383: IFFALSE 13549
// begin for i in tmp do
13385: LD_ADDR_VAR 0 1
13389: PUSH
13390: LD_VAR 0 2
13394: PUSH
13395: FOR_IN
13396: IFFALSE 13421
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13398: LD_VAR 0 1
13402: PPUSH
13403: LD_INT 179
13405: PPUSH
13406: LD_INT 209
13408: PPUSH
13409: LD_INT 8
13411: PPUSH
13412: LD_INT 1
13414: PPUSH
13415: CALL_OW 483
13419: GO 13395
13421: POP
13422: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_VAR 0 2
13432: PPUSH
13433: LD_INT 24
13435: PUSH
13436: LD_INT 250
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 72
13447: ST_TO_ADDR
// for i in tmp do
13448: LD_ADDR_VAR 0 1
13452: PUSH
13453: LD_VAR 0 2
13457: PUSH
13458: FOR_IN
13459: IFFALSE 13499
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13461: LD_VAR 0 1
13465: PPUSH
13466: LD_INT 179
13468: PPUSH
13469: LD_INT 209
13471: PPUSH
13472: CALL_OW 297
13476: PUSH
13477: LD_INT 9
13479: GREATER
13480: IFFALSE 13497
// ComMoveXY ( i , 179 , 209 ) ;
13482: LD_VAR 0 1
13486: PPUSH
13487: LD_INT 179
13489: PPUSH
13490: LD_INT 209
13492: PPUSH
13493: CALL_OW 111
13497: GO 13458
13499: POP
13500: POP
// wait ( 0 0$1 ) ;
13501: LD_INT 35
13503: PPUSH
13504: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13508: LD_VAR 0 2
13512: PPUSH
13513: LD_INT 92
13515: PUSH
13516: LD_INT 179
13518: PUSH
13519: LD_INT 209
13521: PUSH
13522: LD_INT 9
13524: PUSH
13525: EMPTY
13526: LIST
13527: LIST
13528: LIST
13529: LIST
13530: PPUSH
13531: CALL_OW 72
13535: PUSH
13536: LD_VAR 0 2
13540: PUSH
13541: LD_INT 1
13543: MINUS
13544: GREATEREQUAL
13545: IFFALSE 13423
// end else
13547: GO 13711
// begin for i in tmp do
13549: LD_ADDR_VAR 0 1
13553: PUSH
13554: LD_VAR 0 2
13558: PUSH
13559: FOR_IN
13560: IFFALSE 13585
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13562: LD_VAR 0 1
13566: PPUSH
13567: LD_INT 285
13569: PPUSH
13570: LD_INT 163
13572: PPUSH
13573: LD_INT 8
13575: PPUSH
13576: LD_INT 1
13578: PPUSH
13579: CALL_OW 483
13583: GO 13559
13585: POP
13586: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13587: LD_ADDR_VAR 0 2
13591: PUSH
13592: LD_VAR 0 2
13596: PPUSH
13597: LD_INT 24
13599: PUSH
13600: LD_INT 250
13602: PUSH
13603: EMPTY
13604: LIST
13605: LIST
13606: PPUSH
13607: CALL_OW 72
13611: ST_TO_ADDR
// for i in tmp do
13612: LD_ADDR_VAR 0 1
13616: PUSH
13617: LD_VAR 0 2
13621: PUSH
13622: FOR_IN
13623: IFFALSE 13663
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13625: LD_VAR 0 1
13629: PPUSH
13630: LD_INT 285
13632: PPUSH
13633: LD_INT 163
13635: PPUSH
13636: CALL_OW 297
13640: PUSH
13641: LD_INT 9
13643: GREATER
13644: IFFALSE 13661
// ComMoveXY ( i , 285 , 163 ) ;
13646: LD_VAR 0 1
13650: PPUSH
13651: LD_INT 285
13653: PPUSH
13654: LD_INT 163
13656: PPUSH
13657: CALL_OW 111
13661: GO 13622
13663: POP
13664: POP
// wait ( 0 0$1 ) ;
13665: LD_INT 35
13667: PPUSH
13668: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13672: LD_VAR 0 2
13676: PPUSH
13677: LD_INT 92
13679: PUSH
13680: LD_INT 285
13682: PUSH
13683: LD_INT 163
13685: PUSH
13686: LD_INT 9
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: LIST
13693: LIST
13694: PPUSH
13695: CALL_OW 72
13699: PUSH
13700: LD_VAR 0 2
13704: PUSH
13705: LD_INT 1
13707: MINUS
13708: GREATEREQUAL
13709: IFFALSE 13587
// end ; repeat wait ( 0 0$1 ) ;
13711: LD_INT 35
13713: PPUSH
13714: CALL_OW 67
// for i in tmp do
13718: LD_ADDR_VAR 0 1
13722: PUSH
13723: LD_VAR 0 2
13727: PUSH
13728: FOR_IN
13729: IFFALSE 13851
// if GetLives ( i ) > 251 then
13731: LD_VAR 0 1
13735: PPUSH
13736: CALL_OW 256
13740: PUSH
13741: LD_INT 251
13743: GREATER
13744: IFFALSE 13833
// begin if GetWeapon ( i ) = ru_time_lapser then
13746: LD_VAR 0 1
13750: PPUSH
13751: CALL_OW 264
13755: PUSH
13756: LD_INT 49
13758: EQUAL
13759: IFFALSE 13797
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13761: LD_VAR 0 1
13765: PPUSH
13766: LD_INT 81
13768: PUSH
13769: LD_INT 7
13771: PUSH
13772: EMPTY
13773: LIST
13774: LIST
13775: PPUSH
13776: CALL_OW 69
13780: PPUSH
13781: LD_VAR 0 1
13785: PPUSH
13786: CALL_OW 74
13790: PPUSH
13791: CALL_OW 112
13795: GO 13831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13797: LD_VAR 0 1
13801: PPUSH
13802: LD_INT 81
13804: PUSH
13805: LD_INT 7
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PPUSH
13812: CALL_OW 69
13816: PPUSH
13817: LD_VAR 0 1
13821: PPUSH
13822: CALL_OW 74
13826: PPUSH
13827: CALL_OW 115
// end else
13831: GO 13849
// tmp := tmp diff i ;
13833: LD_ADDR_VAR 0 2
13837: PUSH
13838: LD_VAR 0 2
13842: PUSH
13843: LD_VAR 0 1
13847: DIFF
13848: ST_TO_ADDR
13849: GO 13728
13851: POP
13852: POP
// until not tmp ;
13853: LD_VAR 0 2
13857: NOT
13858: IFFALSE 13711
// end ; end_of_file
13860: PPOPN 4
13862: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13863: LD_INT 0
13865: PPUSH
13866: PPUSH
13867: PPUSH
13868: PPUSH
// missionStage := 13 ;
13869: LD_ADDR_EXP 15
13873: PUSH
13874: LD_INT 13
13876: ST_TO_ADDR
// uc_side := 2 ;
13877: LD_ADDR_OWVAR 20
13881: PUSH
13882: LD_INT 2
13884: ST_TO_ADDR
// uc_nation := 2 ;
13885: LD_ADDR_OWVAR 21
13889: PUSH
13890: LD_INT 2
13892: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13893: LD_ADDR_EXP 92
13897: PUSH
13898: LD_STRING Omar
13900: PPUSH
13901: CALL_OW 25
13905: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13906: LD_EXP 92
13910: PPUSH
13911: LD_INT 4
13913: PPUSH
13914: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13918: LD_EXP 92
13922: PPUSH
13923: LD_INT 242
13925: PPUSH
13926: LD_INT 75
13928: PPUSH
13929: LD_INT 0
13931: PPUSH
13932: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13936: LD_ADDR_EXP 93
13940: PUSH
13941: LD_STRING Heike
13943: PPUSH
13944: CALL_OW 25
13948: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13949: LD_INT 14
13951: PPUSH
13952: LD_INT 3
13954: PPUSH
13955: LD_INT 1
13957: PPUSH
13958: LD_INT 27
13960: PPUSH
13961: LD_INT 100
13963: PPUSH
13964: CALL 72069 0 5
// veh := CreateVehicle ;
13968: LD_ADDR_VAR 0 3
13972: PUSH
13973: CALL_OW 45
13977: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13978: LD_VAR 0 3
13982: PPUSH
13983: LD_INT 1
13985: PPUSH
13986: CALL_OW 242
// SetDir ( veh , 4 ) ;
13990: LD_VAR 0 3
13994: PPUSH
13995: LD_INT 4
13997: PPUSH
13998: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14002: LD_VAR 0 3
14006: PPUSH
14007: LD_INT 241
14009: PPUSH
14010: LD_INT 72
14012: PPUSH
14013: LD_INT 0
14015: PPUSH
14016: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14020: LD_EXP 93
14024: PPUSH
14025: LD_VAR 0 3
14029: PPUSH
14030: CALL_OW 52
// if KhatamStatus then
14034: LD_EXP 8
14038: IFFALSE 14089
// begin Khatam := NewCharacter ( Khatam ) ;
14040: LD_ADDR_EXP 94
14044: PUSH
14045: LD_STRING Khatam
14047: PPUSH
14048: CALL_OW 25
14052: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14053: LD_EXP 94
14057: PPUSH
14058: LD_INT 245
14060: PPUSH
14061: LD_INT 78
14063: PPUSH
14064: LD_INT 3
14066: PPUSH
14067: LD_INT 0
14069: PPUSH
14070: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14074: LD_EXP 94
14078: PPUSH
14079: LD_INT 4
14081: PPUSH
14082: LD_INT 10
14084: PPUSH
14085: CALL_OW 237
// end ; for i = 1 to Difficulty do
14089: LD_ADDR_VAR 0 2
14093: PUSH
14094: DOUBLE
14095: LD_INT 1
14097: DEC
14098: ST_TO_ADDR
14099: LD_OWVAR 67
14103: PUSH
14104: FOR_TO
14105: IFFALSE 14171
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14107: LD_INT 0
14109: PPUSH
14110: LD_INT 7
14112: PUSH
14113: LD_OWVAR 67
14117: PLUS
14118: PPUSH
14119: CALL_OW 384
// un := CreateHuman ;
14123: LD_ADDR_VAR 0 4
14127: PUSH
14128: CALL_OW 44
14132: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14133: LD_VAR 0 4
14137: PPUSH
14138: LD_INT 28
14140: PUSH
14141: LD_INT 29
14143: PUSH
14144: EMPTY
14145: LIST
14146: LIST
14147: PUSH
14148: LD_VAR 0 2
14152: PUSH
14153: LD_INT 2
14155: MOD
14156: PUSH
14157: LD_INT 1
14159: PLUS
14160: ARRAY
14161: PPUSH
14162: LD_INT 0
14164: PPUSH
14165: CALL_OW 49
// end ;
14169: GO 14104
14171: POP
14172: POP
// for i = 1 to 6 do
14173: LD_ADDR_VAR 0 2
14177: PUSH
14178: DOUBLE
14179: LD_INT 1
14181: DEC
14182: ST_TO_ADDR
14183: LD_INT 6
14185: PUSH
14186: FOR_TO
14187: IFFALSE 14232
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14189: LD_INT 0
14191: PPUSH
14192: LD_INT 7
14194: PUSH
14195: LD_OWVAR 67
14199: PLUS
14200: PPUSH
14201: CALL_OW 381
// un := CreateHuman ;
14205: LD_ADDR_VAR 0 4
14209: PUSH
14210: CALL_OW 44
14214: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14215: LD_VAR 0 4
14219: PPUSH
14220: LD_INT 28
14222: PPUSH
14223: LD_INT 0
14225: PPUSH
14226: CALL_OW 49
// end ;
14230: GO 14186
14232: POP
14233: POP
// for i = 1 to 3 do
14234: LD_ADDR_VAR 0 2
14238: PUSH
14239: DOUBLE
14240: LD_INT 1
14242: DEC
14243: ST_TO_ADDR
14244: LD_INT 3
14246: PUSH
14247: FOR_TO
14248: IFFALSE 14296
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14250: LD_INT 0
14252: PPUSH
14253: LD_INT 8
14255: PPUSH
14256: LD_INT 7
14258: PUSH
14259: LD_OWVAR 67
14263: PLUS
14264: PPUSH
14265: CALL_OW 380
// un := CreateHuman ;
14269: LD_ADDR_VAR 0 4
14273: PUSH
14274: CALL_OW 44
14278: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14279: LD_VAR 0 4
14283: PPUSH
14284: LD_INT 28
14286: PPUSH
14287: LD_INT 0
14289: PPUSH
14290: CALL_OW 49
// end ;
14294: GO 14247
14296: POP
14297: POP
// for i = 1 to 3 do
14298: LD_ADDR_VAR 0 2
14302: PUSH
14303: DOUBLE
14304: LD_INT 1
14306: DEC
14307: ST_TO_ADDR
14308: LD_INT 3
14310: PUSH
14311: FOR_TO
14312: IFFALSE 14402
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14314: LD_INT 14
14316: PPUSH
14317: LD_INT 2
14319: PPUSH
14320: LD_INT 1
14322: PPUSH
14323: LD_INT 28
14325: PPUSH
14326: LD_INT 80
14328: PPUSH
14329: CALL 72069 0 5
// veh := CreateVehicle ;
14333: LD_ADDR_VAR 0 3
14337: PUSH
14338: CALL_OW 45
14342: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14343: LD_VAR 0 3
14347: PPUSH
14348: LD_INT 3
14350: PPUSH
14351: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14355: LD_VAR 0 3
14359: PPUSH
14360: LD_INT 29
14362: PPUSH
14363: LD_INT 0
14365: PPUSH
14366: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14370: LD_INT 0
14372: PPUSH
14373: LD_INT 7
14375: PUSH
14376: LD_OWVAR 67
14380: PLUS
14381: PPUSH
14382: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14386: CALL_OW 44
14390: PPUSH
14391: LD_VAR 0 3
14395: PPUSH
14396: CALL_OW 52
// end ;
14400: GO 14311
14402: POP
14403: POP
// for i = 1 to 5 + Difficulty do
14404: LD_ADDR_VAR 0 2
14408: PUSH
14409: DOUBLE
14410: LD_INT 1
14412: DEC
14413: ST_TO_ADDR
14414: LD_INT 5
14416: PUSH
14417: LD_OWVAR 67
14421: PLUS
14422: PUSH
14423: FOR_TO
14424: IFFALSE 14551
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14426: LD_INT 14
14428: PPUSH
14429: LD_INT 1
14431: PPUSH
14432: LD_INT 3
14434: PPUSH
14435: CALL_OW 12
14439: PPUSH
14440: LD_INT 1
14442: PPUSH
14443: LD_INT 28
14445: PUSH
14446: LD_INT 26
14448: PUSH
14449: LD_INT 27
14451: PUSH
14452: LD_INT 25
14454: PUSH
14455: EMPTY
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: PUSH
14461: LD_VAR 0 2
14465: PUSH
14466: LD_INT 4
14468: MOD
14469: PUSH
14470: LD_INT 1
14472: PLUS
14473: ARRAY
14474: PPUSH
14475: LD_INT 80
14477: PPUSH
14478: CALL 72069 0 5
// veh := CreateVehicle ;
14482: LD_ADDR_VAR 0 3
14486: PUSH
14487: CALL_OW 45
14491: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14492: LD_VAR 0 3
14496: PPUSH
14497: LD_INT 4
14499: PPUSH
14500: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14504: LD_VAR 0 3
14508: PPUSH
14509: LD_INT 28
14511: PPUSH
14512: LD_INT 0
14514: PPUSH
14515: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14519: LD_INT 0
14521: PPUSH
14522: LD_INT 7
14524: PUSH
14525: LD_OWVAR 67
14529: PLUS
14530: PPUSH
14531: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14535: CALL_OW 44
14539: PPUSH
14540: LD_VAR 0 3
14544: PPUSH
14545: CALL_OW 52
// end ;
14549: GO 14423
14551: POP
14552: POP
// for i = 1 to 3 do
14553: LD_ADDR_VAR 0 2
14557: PUSH
14558: DOUBLE
14559: LD_INT 1
14561: DEC
14562: ST_TO_ADDR
14563: LD_INT 3
14565: PUSH
14566: FOR_TO
14567: IFFALSE 14627
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14569: LD_INT 14
14571: PPUSH
14572: LD_INT 3
14574: PPUSH
14575: LD_INT 5
14577: PPUSH
14578: LD_INT 29
14580: PPUSH
14581: LD_INT 80
14583: PPUSH
14584: CALL 72069 0 5
// veh := CreateVehicle ;
14588: LD_ADDR_VAR 0 3
14592: PUSH
14593: CALL_OW 45
14597: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14598: LD_VAR 0 3
14602: PPUSH
14603: LD_INT 4
14605: PPUSH
14606: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14610: LD_VAR 0 3
14614: PPUSH
14615: LD_INT 28
14617: PPUSH
14618: LD_INT 0
14620: PPUSH
14621: CALL_OW 49
// end ;
14625: GO 14566
14627: POP
14628: POP
// end ;
14629: LD_VAR 0 1
14633: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14634: LD_INT 22
14636: PUSH
14637: LD_INT 2
14639: PUSH
14640: EMPTY
14641: LIST
14642: LIST
14643: PPUSH
14644: CALL_OW 69
14648: IFFALSE 14948
14650: GO 14652
14652: DISABLE
14653: LD_INT 0
14655: PPUSH
14656: PPUSH
14657: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14658: LD_ADDR_VAR 0 3
14662: PUSH
14663: LD_INT 22
14665: PUSH
14666: LD_INT 2
14668: PUSH
14669: EMPTY
14670: LIST
14671: LIST
14672: PUSH
14673: LD_INT 25
14675: PUSH
14676: LD_INT 4
14678: PUSH
14679: EMPTY
14680: LIST
14681: LIST
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PPUSH
14687: CALL_OW 69
14691: PUSH
14692: LD_EXP 94
14696: DIFF
14697: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14698: LD_ADDR_VAR 0 2
14702: PUSH
14703: LD_INT 22
14705: PUSH
14706: LD_INT 2
14708: PUSH
14709: EMPTY
14710: LIST
14711: LIST
14712: PPUSH
14713: CALL_OW 69
14717: PUSH
14718: LD_EXP 94
14722: PUSH
14723: LD_VAR 0 3
14727: UNION
14728: DIFF
14729: ST_TO_ADDR
// if Khatam then
14730: LD_EXP 94
14734: IFFALSE 14751
// ComMoveXY ( Khatam , 211 , 92 ) ;
14736: LD_EXP 94
14740: PPUSH
14741: LD_INT 211
14743: PPUSH
14744: LD_INT 92
14746: PPUSH
14747: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14751: LD_INT 197
14753: PPUSH
14754: LD_INT 80
14756: PPUSH
14757: LD_INT 2
14759: PPUSH
14760: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14764: LD_INT 213
14766: PPUSH
14767: LD_INT 90
14769: PPUSH
14770: LD_INT 2
14772: PPUSH
14773: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14777: LD_INT 215
14779: PPUSH
14780: LD_INT 129
14782: PPUSH
14783: LD_INT 2
14785: PPUSH
14786: CALL_OW 441
// if sci then
14790: LD_VAR 0 3
14794: IFFALSE 14815
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14796: LD_VAR 0 3
14800: PUSH
14801: LD_INT 1
14803: ARRAY
14804: PPUSH
14805: LD_INT 197
14807: PPUSH
14808: LD_INT 80
14810: PPUSH
14811: CALL_OW 158
// if sci > 1 then
14815: LD_VAR 0 3
14819: PUSH
14820: LD_INT 1
14822: GREATER
14823: IFFALSE 14844
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14825: LD_VAR 0 3
14829: PUSH
14830: LD_INT 2
14832: ARRAY
14833: PPUSH
14834: LD_INT 213
14836: PPUSH
14837: LD_INT 90
14839: PPUSH
14840: CALL_OW 158
// if sci > 2 then
14844: LD_VAR 0 3
14848: PUSH
14849: LD_INT 2
14851: GREATER
14852: IFFALSE 14873
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14854: LD_VAR 0 3
14858: PUSH
14859: LD_INT 3
14861: ARRAY
14862: PPUSH
14863: LD_INT 215
14865: PPUSH
14866: LD_INT 129
14868: PPUSH
14869: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14873: LD_INT 35
14875: PPUSH
14876: CALL_OW 67
// for i in tmp do
14880: LD_ADDR_VAR 0 1
14884: PUSH
14885: LD_VAR 0 2
14889: PUSH
14890: FOR_IN
14891: IFFALSE 14929
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14893: LD_VAR 0 1
14897: PPUSH
14898: LD_INT 81
14900: PUSH
14901: LD_INT 2
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PPUSH
14908: CALL_OW 69
14912: PPUSH
14913: LD_VAR 0 1
14917: PPUSH
14918: CALL_OW 74
14922: PPUSH
14923: CALL_OW 115
14927: GO 14890
14929: POP
14930: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14931: LD_INT 22
14933: PUSH
14934: LD_INT 2
14936: PUSH
14937: EMPTY
14938: LIST
14939: LIST
14940: PPUSH
14941: CALL_OW 69
14945: NOT
14946: IFFALSE 14873
// end ; end_of_file
14948: PPOPN 3
14950: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14951: LD_INT 0
14953: PPUSH
14954: PPUSH
14955: PPUSH
14956: PPUSH
14957: PPUSH
14958: PPUSH
14959: PPUSH
14960: PPUSH
14961: PPUSH
// Video ( true ) ;
14962: LD_INT 1
14964: PPUSH
14965: CALL 107796 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14969: LD_ADDR_VAR 0 5
14973: PUSH
14974: LD_INT 7
14976: PPUSH
14977: LD_INT 0
14979: PPUSH
14980: CALL_OW 517
14984: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14985: LD_ADDR_VAR 0 2
14989: PUSH
14990: DOUBLE
14991: LD_INT 1
14993: DEC
14994: ST_TO_ADDR
14995: LD_VAR 0 5
14999: PUSH
15000: LD_INT 1
15002: ARRAY
15003: PUSH
15004: FOR_TO
15005: IFFALSE 15050
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15007: LD_VAR 0 5
15011: PUSH
15012: LD_INT 1
15014: ARRAY
15015: PUSH
15016: LD_VAR 0 2
15020: ARRAY
15021: PPUSH
15022: LD_VAR 0 5
15026: PUSH
15027: LD_INT 2
15029: ARRAY
15030: PUSH
15031: LD_VAR 0 2
15035: ARRAY
15036: PPUSH
15037: LD_INT 1
15039: PPUSH
15040: LD_INT 15
15042: NEG
15043: PPUSH
15044: CALL 107710 0 4
15048: GO 15004
15050: POP
15051: POP
// CenterNowOnUnits ( Powell ) ;
15052: LD_EXP 58
15056: PPUSH
15057: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15061: LD_ADDR_VAR 0 5
15065: PUSH
15066: LD_EXP 56
15070: PUSH
15071: EMPTY
15072: LIST
15073: ST_TO_ADDR
// if GirlNewVeh then
15074: LD_EXP 57
15078: IFFALSE 15096
// tmp := tmp ^ GirlNewVeh ;
15080: LD_ADDR_VAR 0 5
15084: PUSH
15085: LD_VAR 0 5
15089: PUSH
15090: LD_EXP 57
15094: ADD
15095: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15096: LD_VAR 0 5
15100: PPUSH
15101: LD_INT 60
15103: PPUSH
15104: LD_INT 109
15106: PPUSH
15107: CALL_OW 111
// if KappaStatus then
15111: LD_EXP 2
15115: IFFALSE 15167
// begin Say ( JMM , D1nT-JMM-1 ) ;
15117: LD_EXP 39
15121: PPUSH
15122: LD_STRING D1nT-JMM-1
15124: PPUSH
15125: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15129: LD_EXP 58
15133: PPUSH
15134: LD_STRING D1T-Pow-1
15136: PPUSH
15137: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15141: LD_EXP 39
15145: PPUSH
15146: LD_STRING D1T-JMM-2
15148: PPUSH
15149: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15153: LD_EXP 58
15157: PPUSH
15158: LD_STRING D1T-Pow-2
15160: PPUSH
15161: CALL_OW 88
// end else
15165: GO 15373
// if JMMGirlStatus then
15167: LD_EXP 6
15171: IFFALSE 15316
// begin Say ( JMM , D1T-JMM-1 ) ;
15173: LD_EXP 39
15177: PPUSH
15178: LD_STRING D1T-JMM-1
15180: PPUSH
15181: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15185: LD_EXP 58
15189: PPUSH
15190: LD_STRING D1T-Pow-1
15192: PPUSH
15193: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15197: LD_EXP 39
15201: PPUSH
15202: LD_STRING D1T-JMM-3
15204: PPUSH
15205: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15209: LD_EXP 58
15213: PPUSH
15214: LD_STRING D1T-Pow-3
15216: PPUSH
15217: CALL_OW 88
// if JMMGirl then
15221: LD_EXP 7
15225: IFFALSE 15314
// begin case JMMGirl of 1 :
15227: LD_EXP 7
15231: PUSH
15232: LD_INT 1
15234: DOUBLE
15235: EQUAL
15236: IFTRUE 15240
15238: GO 15255
15240: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15241: LD_EXP 40
15245: PPUSH
15246: LD_STRING D1T-Joan-3
15248: PPUSH
15249: CALL_OW 88
15253: GO 15302
15255: LD_INT 2
15257: DOUBLE
15258: EQUAL
15259: IFTRUE 15263
15261: GO 15278
15263: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15264: LD_EXP 42
15268: PPUSH
15269: LD_STRING D1T-Lisa-3
15271: PPUSH
15272: CALL_OW 88
15276: GO 15302
15278: LD_INT 3
15280: DOUBLE
15281: EQUAL
15282: IFTRUE 15286
15284: GO 15301
15286: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15287: LD_EXP 54
15291: PPUSH
15292: LD_STRING D1T-Con-3
15294: PPUSH
15295: CALL_OW 88
15299: GO 15302
15301: POP
// Say ( Powell , D1T-Pow-4 ) ;
15302: LD_EXP 58
15306: PPUSH
15307: LD_STRING D1T-Pow-4
15309: PPUSH
15310: CALL_OW 88
// end ; end else
15314: GO 15373
// if not FastEnd then
15316: LD_EXP 11
15320: NOT
15321: IFFALSE 15349
// begin Say ( JMM , D1T-JMM-4 ) ;
15323: LD_EXP 39
15327: PPUSH
15328: LD_STRING D1T-JMM-4
15330: PPUSH
15331: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15335: LD_EXP 58
15339: PPUSH
15340: LD_STRING D1T-Pow-5
15342: PPUSH
15343: CALL_OW 88
// end else
15347: GO 15373
// begin Say ( JMM , D1nT-JMM-1 ) ;
15349: LD_EXP 39
15353: PPUSH
15354: LD_STRING D1nT-JMM-1
15356: PPUSH
15357: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15361: LD_EXP 58
15365: PPUSH
15366: LD_STRING D1nT-Pow-1
15368: PPUSH
15369: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15373: LD_INT 35
15375: PPUSH
15376: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15380: LD_EXP 56
15384: PPUSH
15385: CALL_OW 314
15389: NOT
15390: IFFALSE 15373
// ComExitVehicle ( JMM ) ;
15392: LD_EXP 39
15396: PPUSH
15397: CALL_OW 121
// wait ( 3 ) ;
15401: LD_INT 3
15403: PPUSH
15404: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15408: LD_EXP 39
15412: PPUSH
15413: LD_INT 60
15415: PPUSH
15416: LD_INT 94
15418: PPUSH
15419: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15423: LD_EXP 39
15427: PPUSH
15428: LD_EXP 58
15432: PPUSH
15433: CALL_OW 179
// if Joan then
15437: LD_EXP 40
15441: IFFALSE 15495
// begin ComExitVehicle ( Joan ) ;
15443: LD_EXP 40
15447: PPUSH
15448: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15452: LD_EXP 40
15456: PPUSH
15457: LD_INT 35
15459: PPUSH
15460: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15464: LD_EXP 40
15468: PPUSH
15469: LD_INT 65
15471: PPUSH
15472: LD_INT 104
15474: PPUSH
15475: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15479: LD_EXP 40
15483: PPUSH
15484: LD_EXP 39
15488: PPUSH
15489: CALL_OW 179
// end else
15493: GO 15629
// if Lisa and JMMGirl = 2 then
15495: LD_EXP 42
15499: PUSH
15500: LD_EXP 7
15504: PUSH
15505: LD_INT 2
15507: EQUAL
15508: AND
15509: IFFALSE 15563
// begin ComExitVehicle ( Lisa ) ;
15511: LD_EXP 42
15515: PPUSH
15516: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15520: LD_EXP 42
15524: PPUSH
15525: LD_INT 35
15527: PPUSH
15528: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15532: LD_EXP 42
15536: PPUSH
15537: LD_INT 65
15539: PPUSH
15540: LD_INT 104
15542: PPUSH
15543: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15547: LD_EXP 42
15551: PPUSH
15552: LD_EXP 39
15556: PPUSH
15557: CALL_OW 179
// end else
15561: GO 15629
// if Connie and JMMGirl = 3 then
15563: LD_EXP 54
15567: PUSH
15568: LD_EXP 7
15572: PUSH
15573: LD_INT 3
15575: EQUAL
15576: AND
15577: IFFALSE 15629
// begin ComExitVehicle ( Connie ) ;
15579: LD_EXP 54
15583: PPUSH
15584: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15588: LD_EXP 54
15592: PPUSH
15593: LD_INT 35
15595: PPUSH
15596: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15600: LD_EXP 54
15604: PPUSH
15605: LD_INT 65
15607: PPUSH
15608: LD_INT 104
15610: PPUSH
15611: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15615: LD_EXP 54
15619: PPUSH
15620: LD_EXP 39
15624: PPUSH
15625: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15629: LD_INT 35
15631: PPUSH
15632: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15636: LD_EXP 39
15640: PPUSH
15641: LD_EXP 58
15645: PPUSH
15646: CALL_OW 296
15650: PUSH
15651: LD_INT 6
15653: LESS
15654: IFFALSE 15629
// wait ( 0 0$0.5 ) ;
15656: LD_INT 18
15658: PPUSH
15659: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15663: LD_EXP 39
15667: PPUSH
15668: LD_STRING D1-JMM-1
15670: PPUSH
15671: CALL_OW 88
// async ;
15675: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15676: LD_EXP 58
15680: PPUSH
15681: LD_STRING D1-Pow-1
15683: PPUSH
15684: CALL_OW 88
// if not dialogue_skipped then
15688: LD_OWVAR 59
15692: NOT
15693: IFFALSE 15702
// wait ( 0 0$2 ) ;
15695: LD_INT 70
15697: PPUSH
15698: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15702: LD_INT 170
15704: PPUSH
15705: LD_INT 99
15707: PPUSH
15708: LD_INT 1
15710: PPUSH
15711: LD_INT 6
15713: NEG
15714: PPUSH
15715: CALL 107710 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15719: LD_INT 174
15721: PPUSH
15722: LD_INT 115
15724: PPUSH
15725: LD_INT 1
15727: PPUSH
15728: LD_INT 6
15730: NEG
15731: PPUSH
15732: CALL 107710 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15736: LD_INT 169
15738: PPUSH
15739: LD_INT 71
15741: PPUSH
15742: LD_INT 1
15744: PPUSH
15745: LD_INT 6
15747: NEG
15748: PPUSH
15749: CALL 107710 0 4
// if not dialogue_skipped then
15753: LD_OWVAR 59
15757: NOT
15758: IFFALSE 15777
// begin CenterOnXY ( 170 , 99 ) ;
15760: LD_INT 170
15762: PPUSH
15763: LD_INT 99
15765: PPUSH
15766: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15770: LD_INT 80
15772: PPUSH
15773: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15777: LD_INT 75
15779: PPUSH
15780: LD_INT 53
15782: PPUSH
15783: LD_INT 1
15785: PPUSH
15786: LD_INT 9
15788: NEG
15789: PPUSH
15790: CALL 107710 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15794: LD_INT 54
15796: PPUSH
15797: LD_INT 42
15799: PPUSH
15800: LD_INT 1
15802: PPUSH
15803: LD_INT 9
15805: NEG
15806: PPUSH
15807: CALL 107710 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15811: LD_INT 62
15813: PPUSH
15814: LD_INT 51
15816: PPUSH
15817: LD_INT 1
15819: PPUSH
15820: LD_INT 9
15822: NEG
15823: PPUSH
15824: CALL 107710 0 4
// if not dialogue_skipped then
15828: LD_OWVAR 59
15832: NOT
15833: IFFALSE 15852
// begin CenterOnXY ( 75 , 53 ) ;
15835: LD_INT 75
15837: PPUSH
15838: LD_INT 53
15840: PPUSH
15841: CALL_OW 84
// wait ( 0 0$4 ) ;
15845: LD_INT 140
15847: PPUSH
15848: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15852: LD_EXP 58
15856: PPUSH
15857: CALL_OW 87
// if not dialogue_skipped then
15861: LD_OWVAR 59
15865: NOT
15866: IFFALSE 15875
// wait ( 0 0$2 ) ;
15868: LD_INT 70
15870: PPUSH
15871: CALL_OW 67
// sync ;
15875: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15876: LD_EXP 39
15880: PPUSH
15881: LD_STRING D1-JMM-2
15883: PPUSH
15884: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15888: LD_EXP 58
15892: PPUSH
15893: LD_STRING D1-Pow-2
15895: PPUSH
15896: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15900: LD_EXP 39
15904: PPUSH
15905: LD_STRING D1-JMM-3
15907: PPUSH
15908: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15912: LD_EXP 58
15916: PPUSH
15917: LD_STRING D1-Pow-3
15919: PPUSH
15920: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15924: LD_EXP 39
15928: PPUSH
15929: LD_STRING D1-JMM-4
15931: PPUSH
15932: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15936: LD_EXP 58
15940: PPUSH
15941: LD_STRING D1-Pow-4
15943: PPUSH
15944: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15948: LD_EXP 39
15952: PPUSH
15953: LD_STRING D1-JMM-5
15955: PPUSH
15956: CALL_OW 88
// async ;
15960: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15961: LD_EXP 58
15965: PPUSH
15966: LD_STRING D1-Pow-5
15968: PPUSH
15969: CALL_OW 88
// if not dialogue_skipped then
15973: LD_OWVAR 59
15977: NOT
15978: IFFALSE 15987
// wait ( 0 0$3.6 ) ;
15980: LD_INT 126
15982: PPUSH
15983: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15987: LD_INT 134
15989: PPUSH
15990: LD_INT 210
15992: PPUSH
15993: LD_INT 1
15995: PPUSH
15996: LD_INT 11
15998: NEG
15999: PPUSH
16000: CALL 107710 0 4
// if not dialogue_skipped then
16004: LD_OWVAR 59
16008: NOT
16009: IFFALSE 16028
// begin CenterOnXY ( 134 , 210 ) ;
16011: LD_INT 134
16013: PPUSH
16014: LD_INT 210
16016: PPUSH
16017: CALL_OW 84
// wait ( 0 0$2 ) ;
16021: LD_INT 70
16023: PPUSH
16024: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16028: LD_INT 101
16030: PPUSH
16031: LD_INT 159
16033: PPUSH
16034: LD_INT 1
16036: PPUSH
16037: LD_INT 10
16039: NEG
16040: PPUSH
16041: CALL 107710 0 4
// if not dialogue_skipped then
16045: LD_OWVAR 59
16049: NOT
16050: IFFALSE 16069
// begin CenterOnXY ( 101 , 159 ) ;
16052: LD_INT 101
16054: PPUSH
16055: LD_INT 159
16057: PPUSH
16058: CALL_OW 84
// wait ( 0 0$2 ) ;
16062: LD_INT 70
16064: PPUSH
16065: CALL_OW 67
// end ; sync ;
16069: SYNC
// CenterNowOnUnits ( Powell ) ;
16070: LD_EXP 58
16074: PPUSH
16075: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16079: LD_ADDR_VAR 0 6
16083: PUSH
16084: LD_INT 1
16086: PUSH
16087: LD_INT 2
16089: PUSH
16090: LD_INT 3
16092: PUSH
16093: LD_INT 4
16095: PUSH
16096: LD_INT 5
16098: PUSH
16099: LD_INT 6
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: LIST
16106: LIST
16107: LIST
16108: LIST
16109: ST_TO_ADDR
// if not dialogue_skipped then
16110: LD_OWVAR 59
16114: NOT
16115: IFFALSE 16284
// begin game_speed := 4 ;
16117: LD_ADDR_OWVAR 65
16121: PUSH
16122: LD_INT 4
16124: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16125: LD_INT 210
16127: PPUSH
16128: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16132: LD_ADDR_VAR 0 7
16136: PUSH
16137: LD_STRING Q1
16139: PPUSH
16140: LD_VAR 0 6
16144: PPUSH
16145: CALL_OW 98
16149: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16150: LD_ADDR_VAR 0 7
16154: PUSH
16155: LD_STRING Q1
16157: PPUSH
16158: LD_VAR 0 6
16162: PPUSH
16163: CALL_OW 98
16167: ST_TO_ADDR
// options = options diff dec ;
16168: LD_ADDR_VAR 0 6
16172: PUSH
16173: LD_VAR 0 6
16177: PUSH
16178: LD_VAR 0 7
16182: DIFF
16183: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16184: LD_VAR 0 7
16188: PPUSH
16189: LD_VAR 0 6
16193: PPUSH
16194: CALL 17756 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16198: LD_VAR 0 7
16202: PUSH
16203: LD_INT 5
16205: PUSH
16206: LD_INT 6
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: IN
16213: PUSH
16214: LD_VAR 0 6
16218: PUSH
16219: LD_INT 2
16221: EQUAL
16222: OR
16223: IFFALSE 16150
// if not ( dec in [ 5 , 6 ] ) then
16225: LD_VAR 0 7
16229: PUSH
16230: LD_INT 5
16232: PUSH
16233: LD_INT 6
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: IN
16240: NOT
16241: IFFALSE 16284
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16243: LD_ADDR_VAR 0 7
16247: PUSH
16248: LD_STRING Q1a
16250: PPUSH
16251: LD_INT 1
16253: PUSH
16254: LD_INT 2
16256: PUSH
16257: EMPTY
16258: LIST
16259: LIST
16260: PPUSH
16261: CALL_OW 98
16265: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16266: LD_VAR 0 7
16270: PUSH
16271: LD_INT 4
16273: PLUS
16274: PPUSH
16275: LD_VAR 0 6
16279: PPUSH
16280: CALL 17756 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16284: LD_INT 81
16286: PPUSH
16287: LD_INT 127
16289: PPUSH
16290: CALL_OW 84
// amount := 5 ;
16294: LD_ADDR_VAR 0 8
16298: PUSH
16299: LD_INT 5
16301: ST_TO_ADDR
// macmilan_squad := [ ] ;
16302: LD_ADDR_VAR 0 9
16306: PUSH
16307: EMPTY
16308: ST_TO_ADDR
// if vip < amount then
16309: LD_EXP 59
16313: PUSH
16314: LD_VAR 0 8
16318: LESS
16319: IFFALSE 16363
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16321: LD_ADDR_VAR 0 5
16325: PUSH
16326: LD_EXP 59
16330: PUSH
16331: LD_INT 22
16333: PUSH
16334: LD_INT 4
16336: PUSH
16337: EMPTY
16338: LIST
16339: LIST
16340: PUSH
16341: LD_INT 21
16343: PUSH
16344: LD_INT 1
16346: PUSH
16347: EMPTY
16348: LIST
16349: LIST
16350: PUSH
16351: EMPTY
16352: LIST
16353: LIST
16354: PPUSH
16355: CALL_OW 69
16359: UNION
16360: ST_TO_ADDR
16361: GO 16373
// tmp := vip ;
16363: LD_ADDR_VAR 0 5
16367: PUSH
16368: LD_EXP 59
16372: ST_TO_ADDR
// tmp := tmp diff Powell ;
16373: LD_ADDR_VAR 0 5
16377: PUSH
16378: LD_VAR 0 5
16382: PUSH
16383: LD_EXP 58
16387: DIFF
16388: ST_TO_ADDR
// if tmp < amount then
16389: LD_VAR 0 5
16393: PUSH
16394: LD_VAR 0 8
16398: LESS
16399: IFFALSE 16411
// amount := tmp ;
16401: LD_ADDR_VAR 0 8
16405: PUSH
16406: LD_VAR 0 5
16410: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16411: LD_VAR 0 5
16415: PUSH
16416: LD_INT 1
16418: ARRAY
16419: PPUSH
16420: CALL_OW 257
16424: PUSH
16425: LD_INT 2
16427: NONEQUAL
16428: IFFALSE 16490
// begin if IsInUnit ( tmp [ 1 ] ) then
16430: LD_VAR 0 5
16434: PUSH
16435: LD_INT 1
16437: ARRAY
16438: PPUSH
16439: CALL_OW 310
16443: IFFALSE 16458
// ComExitBuilding ( tmp [ 1 ] ) ;
16445: LD_VAR 0 5
16449: PUSH
16450: LD_INT 1
16452: ARRAY
16453: PPUSH
16454: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16458: LD_VAR 0 5
16462: PUSH
16463: LD_INT 1
16465: ARRAY
16466: PPUSH
16467: LD_INT 387
16469: PPUSH
16470: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16474: LD_VAR 0 5
16478: PUSH
16479: LD_INT 1
16481: ARRAY
16482: PPUSH
16483: LD_INT 2
16485: PPUSH
16486: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16490: LD_EXP 39
16494: PPUSH
16495: LD_INT 82
16497: PPUSH
16498: LD_INT 129
16500: PPUSH
16501: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16505: LD_EXP 39
16509: PPUSH
16510: LD_EXP 58
16514: PPUSH
16515: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16519: LD_INT 22
16521: PUSH
16522: LD_INT 1
16524: PUSH
16525: EMPTY
16526: LIST
16527: LIST
16528: PPUSH
16529: CALL_OW 69
16533: PUSH
16534: LD_EXP 39
16538: DIFF
16539: PPUSH
16540: LD_INT 84
16542: PPUSH
16543: LD_INT 128
16545: PPUSH
16546: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16550: LD_INT 22
16552: PUSH
16553: LD_INT 1
16555: PUSH
16556: EMPTY
16557: LIST
16558: LIST
16559: PPUSH
16560: CALL_OW 69
16564: PUSH
16565: LD_EXP 39
16569: DIFF
16570: PPUSH
16571: LD_EXP 39
16575: PPUSH
16576: CALL_OW 179
// for i = 1 to amount do
16580: LD_ADDR_VAR 0 2
16584: PUSH
16585: DOUBLE
16586: LD_INT 1
16588: DEC
16589: ST_TO_ADDR
16590: LD_VAR 0 8
16594: PUSH
16595: FOR_TO
16596: IFFALSE 16764
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16598: LD_ADDR_VAR 0 9
16602: PUSH
16603: LD_VAR 0 9
16607: PUSH
16608: LD_VAR 0 5
16612: PUSH
16613: LD_VAR 0 2
16617: ARRAY
16618: ADD
16619: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16620: LD_VAR 0 5
16624: PUSH
16625: LD_VAR 0 2
16629: ARRAY
16630: PPUSH
16631: CALL_OW 310
16635: IFFALSE 16652
// AddComExitBuilding ( tmp [ i ] ) ;
16637: LD_VAR 0 5
16641: PUSH
16642: LD_VAR 0 2
16646: ARRAY
16647: PPUSH
16648: CALL_OW 182
// if i = 2 and JMMNewVeh then
16652: LD_VAR 0 2
16656: PUSH
16657: LD_INT 2
16659: EQUAL
16660: PUSH
16661: LD_EXP 56
16665: AND
16666: IFFALSE 16724
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16668: LD_VAR 0 5
16672: PUSH
16673: LD_VAR 0 2
16677: ARRAY
16678: PPUSH
16679: LD_EXP 56
16683: PPUSH
16684: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16688: LD_VAR 0 5
16692: PUSH
16693: LD_VAR 0 2
16697: ARRAY
16698: PPUSH
16699: LD_INT 86
16701: PPUSH
16702: LD_INT 133
16704: PPUSH
16705: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16709: LD_VAR 0 5
16713: PUSH
16714: LD_VAR 0 2
16718: ARRAY
16719: PPUSH
16720: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16724: LD_VAR 0 5
16728: PUSH
16729: LD_VAR 0 2
16733: ARRAY
16734: PPUSH
16735: LD_INT 8
16737: PPUSH
16738: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16742: LD_VAR 0 5
16746: PUSH
16747: LD_VAR 0 2
16751: ARRAY
16752: PPUSH
16753: LD_EXP 39
16757: PPUSH
16758: CALL_OW 179
// end ;
16762: GO 16595
16764: POP
16765: POP
// if GirlNewVeh then
16766: LD_EXP 57
16770: IFFALSE 16784
// SetSide ( GirlNewVeh , 4 ) ;
16772: LD_EXP 57
16776: PPUSH
16777: LD_INT 4
16779: PPUSH
16780: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16784: LD_INT 35
16786: PPUSH
16787: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16791: LD_VAR 0 9
16795: PPUSH
16796: LD_INT 95
16798: PUSH
16799: LD_INT 9
16801: PUSH
16802: EMPTY
16803: LIST
16804: LIST
16805: PPUSH
16806: CALL_OW 72
16810: PUSH
16811: LD_INT 0
16813: EQUAL
16814: PUSH
16815: LD_EXP 39
16819: PPUSH
16820: LD_INT 9
16822: PPUSH
16823: CALL_OW 308
16827: NOT
16828: AND
16829: IFFALSE 16784
// wait ( 0 0$2 ) ;
16831: LD_INT 70
16833: PPUSH
16834: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16838: LD_VAR 0 9
16842: PPUSH
16843: LD_INT 1
16845: PPUSH
16846: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16850: LD_INT 21
16852: PUSH
16853: LD_INT 2
16855: PUSH
16856: EMPTY
16857: LIST
16858: LIST
16859: PUSH
16860: LD_INT 92
16862: PUSH
16863: LD_INT 83
16865: PUSH
16866: LD_INT 130
16868: PUSH
16869: LD_INT 10
16871: PUSH
16872: EMPTY
16873: LIST
16874: LIST
16875: LIST
16876: LIST
16877: PUSH
16878: EMPTY
16879: LIST
16880: LIST
16881: PPUSH
16882: CALL_OW 69
16886: PPUSH
16887: LD_INT 1
16889: PPUSH
16890: CALL_OW 235
// Video ( false ) ;
16894: LD_INT 0
16896: PPUSH
16897: CALL 107796 0 1
// ChangeMissionObjectives ( M1 ) ;
16901: LD_STRING M1
16903: PPUSH
16904: CALL_OW 337
// SaveForQuickRestart ;
16908: CALL_OW 22
// missionStart := true ;
16912: LD_ADDR_EXP 13
16916: PUSH
16917: LD_INT 1
16919: ST_TO_ADDR
// missionStage := 2 ;
16920: LD_ADDR_EXP 15
16924: PUSH
16925: LD_INT 2
16927: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16928: LD_INT 105
16930: PPUSH
16931: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16935: LD_ADDR_VAR 0 5
16939: PUSH
16940: LD_INT 22
16942: PUSH
16943: LD_INT 4
16945: PUSH
16946: EMPTY
16947: LIST
16948: LIST
16949: PUSH
16950: LD_INT 21
16952: PUSH
16953: LD_INT 1
16955: PUSH
16956: EMPTY
16957: LIST
16958: LIST
16959: PUSH
16960: EMPTY
16961: LIST
16962: LIST
16963: PPUSH
16964: CALL_OW 69
16968: PUSH
16969: LD_EXP 58
16973: DIFF
16974: ST_TO_ADDR
// if not tmp then
16975: LD_VAR 0 5
16979: NOT
16980: IFFALSE 16995
// tmp := [ Powell ] ;
16982: LD_ADDR_VAR 0 5
16986: PUSH
16987: LD_EXP 58
16991: PUSH
16992: EMPTY
16993: LIST
16994: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16995: LD_ADDR_EXP 102
16999: PUSH
17000: LD_EXP 102
17004: PPUSH
17005: LD_INT 4
17007: PPUSH
17008: LD_INT 22
17010: PUSH
17011: LD_INT 4
17013: PUSH
17014: EMPTY
17015: LIST
17016: LIST
17017: PUSH
17018: LD_INT 23
17020: PUSH
17021: LD_INT 1
17023: PUSH
17024: EMPTY
17025: LIST
17026: LIST
17027: PUSH
17028: LD_INT 3
17030: PUSH
17031: LD_INT 21
17033: PUSH
17034: LD_INT 2
17036: PUSH
17037: EMPTY
17038: LIST
17039: LIST
17040: PUSH
17041: EMPTY
17042: LIST
17043: LIST
17044: PUSH
17045: EMPTY
17046: LIST
17047: LIST
17048: LIST
17049: PPUSH
17050: CALL_OW 69
17054: PUSH
17055: LD_EXP 58
17059: DIFF
17060: PPUSH
17061: CALL_OW 1
17065: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17066: LD_ADDR_VAR 0 4
17070: PUSH
17071: LD_INT 22
17073: PUSH
17074: LD_INT 4
17076: PUSH
17077: EMPTY
17078: LIST
17079: LIST
17080: PUSH
17081: LD_INT 34
17083: PUSH
17084: LD_INT 12
17086: PUSH
17087: EMPTY
17088: LIST
17089: LIST
17090: PUSH
17091: EMPTY
17092: LIST
17093: LIST
17094: PPUSH
17095: CALL_OW 69
17099: PUSH
17100: LD_INT 1
17102: ARRAY
17103: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17104: LD_VAR 0 5
17108: PUSH
17109: LD_INT 1
17111: ARRAY
17112: PPUSH
17113: CALL_OW 310
17117: IFFALSE 17132
// ComExitBuilding ( tmp [ 1 ] ) ;
17119: LD_VAR 0 5
17123: PUSH
17124: LD_INT 1
17126: ARRAY
17127: PPUSH
17128: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17132: LD_VAR 0 5
17136: PUSH
17137: LD_INT 1
17139: ARRAY
17140: PPUSH
17141: LD_VAR 0 4
17145: PPUSH
17146: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17150: LD_VAR 0 5
17154: PUSH
17155: LD_INT 1
17157: ARRAY
17158: PPUSH
17159: LD_INT 80
17161: PPUSH
17162: LD_INT 136
17164: PPUSH
17165: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17169: LD_VAR 0 5
17173: PUSH
17174: LD_INT 1
17176: ARRAY
17177: PPUSH
17178: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17182: LD_VAR 0 5
17186: PUSH
17187: LD_INT 1
17189: ARRAY
17190: PPUSH
17191: LD_INT 59
17193: PPUSH
17194: LD_INT 112
17196: PPUSH
17197: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17201: LD_VAR 0 5
17205: PUSH
17206: LD_INT 1
17208: ARRAY
17209: PPUSH
17210: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17214: LD_EXP 40
17218: PUSH
17219: LD_EXP 40
17223: PPUSH
17224: CALL_OW 255
17228: PUSH
17229: LD_INT 1
17231: EQUAL
17232: AND
17233: IFFALSE 17259
// begin Say ( Joan , D3W-Joan-1 ) ;
17235: LD_EXP 40
17239: PPUSH
17240: LD_STRING D3W-Joan-1
17242: PPUSH
17243: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17247: LD_EXP 39
17251: PPUSH
17252: LD_STRING D3W-JMM-1
17254: PPUSH
17255: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17259: LD_EXP 42
17263: PUSH
17264: LD_EXP 42
17268: PPUSH
17269: CALL_OW 255
17273: PUSH
17274: LD_INT 1
17276: EQUAL
17277: AND
17278: PUSH
17279: LD_EXP 42
17283: PUSH
17284: LD_EXP 59
17288: IN
17289: NOT
17290: AND
17291: IFFALSE 17317
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17293: LD_EXP 42
17297: PPUSH
17298: LD_STRING D3W-Lisa-1
17300: PPUSH
17301: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17305: LD_EXP 39
17309: PPUSH
17310: LD_STRING D3W-JMM-1
17312: PPUSH
17313: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17317: LD_EXP 54
17321: PUSH
17322: LD_EXP 54
17326: PPUSH
17327: CALL_OW 255
17331: PUSH
17332: LD_INT 1
17334: EQUAL
17335: AND
17336: IFFALSE 17362
// begin Say ( Connie , D3W-Con-1 ) ;
17338: LD_EXP 54
17342: PPUSH
17343: LD_STRING D3W-Con-1
17345: PPUSH
17346: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17350: LD_EXP 39
17354: PPUSH
17355: LD_STRING D3W-JMM-1
17357: PPUSH
17358: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17362: LD_EXP 42
17366: PUSH
17367: LD_EXP 59
17371: IN
17372: PUSH
17373: LD_EXP 42
17377: PPUSH
17378: CALL_OW 255
17382: PUSH
17383: LD_INT 1
17385: EQUAL
17386: AND
17387: IFFALSE 17403
// Say ( Lisa , D3nW-Lisa-1 ) else
17389: LD_EXP 42
17393: PPUSH
17394: LD_STRING D3nW-Lisa-1
17396: PPUSH
17397: CALL_OW 88
17401: GO 17647
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17403: LD_EXP 45
17407: PUSH
17408: LD_EXP 59
17412: IN
17413: PUSH
17414: LD_EXP 45
17418: PPUSH
17419: CALL_OW 255
17423: PUSH
17424: LD_INT 1
17426: EQUAL
17427: AND
17428: IFFALSE 17444
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17430: LD_EXP 45
17434: PPUSH
17435: LD_STRING D3nW-Cyrus-1
17437: PPUSH
17438: CALL_OW 88
17442: GO 17647
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17444: LD_EXP 44
17448: PUSH
17449: LD_EXP 59
17453: IN
17454: PUSH
17455: LD_EXP 44
17459: PPUSH
17460: CALL_OW 255
17464: PUSH
17465: LD_INT 1
17467: EQUAL
17468: AND
17469: IFFALSE 17485
// Say ( Bobby , D3nW-Bobby-1 ) else
17471: LD_EXP 44
17475: PPUSH
17476: LD_STRING D3nW-Bobby-1
17478: PPUSH
17479: CALL_OW 88
17483: GO 17647
// if Gary in vip and GetSide ( Gary ) = 1 then
17485: LD_EXP 51
17489: PUSH
17490: LD_EXP 59
17494: IN
17495: PUSH
17496: LD_EXP 51
17500: PPUSH
17501: CALL_OW 255
17505: PUSH
17506: LD_INT 1
17508: EQUAL
17509: AND
17510: IFFALSE 17526
// Say ( Gary , D3nW-Gary-1 ) else
17512: LD_EXP 51
17516: PPUSH
17517: LD_STRING D3nW-Gary-1
17519: PPUSH
17520: CALL_OW 88
17524: GO 17647
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17526: LD_EXP 43
17530: PUSH
17531: LD_EXP 59
17535: IN
17536: PUSH
17537: LD_EXP 43
17541: PPUSH
17542: CALL_OW 255
17546: PUSH
17547: LD_INT 1
17549: EQUAL
17550: AND
17551: IFFALSE 17567
// Say ( Donaldson , D3nW-Don-1 ) else
17553: LD_EXP 43
17557: PPUSH
17558: LD_STRING D3nW-Don-1
17560: PPUSH
17561: CALL_OW 88
17565: GO 17647
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17567: LD_EXP 50
17571: PUSH
17572: LD_EXP 59
17576: IN
17577: PUSH
17578: LD_EXP 50
17582: PPUSH
17583: CALL_OW 255
17587: PUSH
17588: LD_INT 1
17590: EQUAL
17591: AND
17592: IFFALSE 17608
// Say ( Cornel , D3nW-Corn-1 ) else
17594: LD_EXP 50
17598: PPUSH
17599: LD_STRING D3nW-Corn-1
17601: PPUSH
17602: CALL_OW 88
17606: GO 17647
// if Frank in vip and GetSide ( Frank ) = 1 then
17608: LD_EXP 52
17612: PUSH
17613: LD_EXP 59
17617: IN
17618: PUSH
17619: LD_EXP 52
17623: PPUSH
17624: CALL_OW 255
17628: PUSH
17629: LD_INT 1
17631: EQUAL
17632: AND
17633: IFFALSE 17647
// Say ( Frank , D3nW-Frank-1 ) ;
17635: LD_EXP 52
17639: PPUSH
17640: LD_STRING D3nW-Frank-1
17642: PPUSH
17643: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17647: LD_EXP 59
17651: PPUSH
17652: LD_INT 22
17654: PUSH
17655: LD_INT 1
17657: PUSH
17658: EMPTY
17659: LIST
17660: LIST
17661: PPUSH
17662: CALL_OW 72
17666: IFFALSE 17692
// begin Say ( JMM , D3nW-JMM-1 ) ;
17668: LD_EXP 39
17672: PPUSH
17673: LD_STRING D3nW-JMM-1
17675: PPUSH
17676: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17680: LD_EXP 39
17684: PPUSH
17685: LD_STRING D3nW-JMM-1a
17687: PPUSH
17688: CALL_OW 88
// end ; t := 0 0$00 ;
17692: LD_ADDR_VAR 0 3
17696: PUSH
17697: LD_INT 0
17699: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17700: LD_INT 35
17702: PPUSH
17703: CALL_OW 67
// t := t + 0 0$1 ;
17707: LD_ADDR_VAR 0 3
17711: PUSH
17712: LD_VAR 0 3
17716: PUSH
17717: LD_INT 35
17719: PLUS
17720: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17721: LD_INT 59
17723: PPUSH
17724: LD_INT 112
17726: PPUSH
17727: CALL_OW 428
17731: PUSH
17732: LD_VAR 0 3
17736: PUSH
17737: LD_INT 2100
17739: GREATER
17740: OR
17741: IFFALSE 17700
// activeAttacks := true ;
17743: LD_ADDR_EXP 16
17747: PUSH
17748: LD_INT 1
17750: ST_TO_ADDR
// end ;
17751: LD_VAR 0 1
17755: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17756: LD_INT 0
17758: PPUSH
// case question of 1 :
17759: LD_VAR 0 1
17763: PUSH
17764: LD_INT 1
17766: DOUBLE
17767: EQUAL
17768: IFTRUE 17772
17770: GO 17823
17772: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17773: LD_EXP 39
17777: PPUSH
17778: LD_STRING D2Mot-JMM-1
17780: PPUSH
17781: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17785: LD_EXP 58
17789: PPUSH
17790: LD_STRING D2Mot-Pow-1
17792: PPUSH
17793: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17797: LD_EXP 39
17801: PPUSH
17802: LD_STRING D2Mot-JMM-2
17804: PPUSH
17805: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17809: LD_EXP 58
17813: PPUSH
17814: LD_STRING D2Mot-Pow-2
17816: PPUSH
17817: CALL_OW 88
// end ; 2 :
17821: GO 18174
17823: LD_INT 2
17825: DOUBLE
17826: EQUAL
17827: IFTRUE 17831
17829: GO 17907
17831: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17832: LD_EXP 39
17836: PPUSH
17837: LD_STRING D2Rus-JMM-1
17839: PPUSH
17840: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17844: LD_EXP 58
17848: PPUSH
17849: LD_STRING D2Rus-Pow-1
17851: PPUSH
17852: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17856: LD_EXP 39
17860: PPUSH
17861: LD_STRING D2Rus-JMM-2
17863: PPUSH
17864: CALL_OW 88
// if not ( 3 in list_of_q ) then
17868: LD_INT 3
17870: PUSH
17871: LD_VAR 0 2
17875: IN
17876: NOT
17877: IFFALSE 17893
// Say ( Powell , D2Rus-Pow-2 ) else
17879: LD_EXP 58
17883: PPUSH
17884: LD_STRING D2Rus-Pow-2
17886: PPUSH
17887: CALL_OW 88
17891: GO 17905
// Say ( Powell , D2Rus-Pow-2a ) ;
17893: LD_EXP 58
17897: PPUSH
17898: LD_STRING D2Rus-Pow-2a
17900: PPUSH
17901: CALL_OW 88
// end ; 3 :
17905: GO 18174
17907: LD_INT 3
17909: DOUBLE
17910: EQUAL
17911: IFTRUE 17915
17913: GO 18000
17915: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17916: LD_EXP 39
17920: PPUSH
17921: LD_STRING D2Leg-JMM-1
17923: PPUSH
17924: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17928: LD_EXP 58
17932: PPUSH
17933: LD_STRING D2Leg-Pow-1
17935: PPUSH
17936: CALL_OW 88
// if 2 in list_of_q then
17940: LD_INT 2
17942: PUSH
17943: LD_VAR 0 2
17947: IN
17948: IFFALSE 17974
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17950: LD_EXP 39
17954: PPUSH
17955: LD_STRING D2Leg-JMM-2
17957: PPUSH
17958: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17962: LD_EXP 58
17966: PPUSH
17967: LD_STRING D2Leg-Pow-2
17969: PPUSH
17970: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17974: LD_EXP 39
17978: PPUSH
17979: LD_STRING D2Leg-JMM-3
17981: PPUSH
17982: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17986: LD_EXP 58
17990: PPUSH
17991: LD_STRING D2Leg-Pow-3
17993: PPUSH
17994: CALL_OW 88
// end ; 4 :
17998: GO 18174
18000: LD_INT 4
18002: DOUBLE
18003: EQUAL
18004: IFTRUE 18008
18006: GO 18083
18008: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18009: LD_EXP 39
18013: PPUSH
18014: LD_STRING D2Ar-JMM-1
18016: PPUSH
18017: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18021: LD_EXP 58
18025: PPUSH
18026: LD_STRING D2Ar-Pow-1
18028: PPUSH
18029: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18033: LD_EXP 39
18037: PPUSH
18038: LD_STRING D2Ar-JMM-2
18040: PPUSH
18041: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18045: LD_EXP 58
18049: PPUSH
18050: LD_STRING D2Ar-Pow-2
18052: PPUSH
18053: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18057: LD_EXP 39
18061: PPUSH
18062: LD_STRING D2Ar-JMM-3
18064: PPUSH
18065: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18069: LD_EXP 58
18073: PPUSH
18074: LD_STRING D2Ar-Pow-3
18076: PPUSH
18077: CALL_OW 88
// end ; 5 :
18081: GO 18174
18083: LD_INT 5
18085: DOUBLE
18086: EQUAL
18087: IFTRUE 18091
18089: GO 18106
18091: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18092: LD_EXP 39
18096: PPUSH
18097: LD_STRING D2Conf-JMM-1
18099: PPUSH
18100: CALL_OW 88
18104: GO 18174
18106: LD_INT 6
18108: DOUBLE
18109: EQUAL
18110: IFTRUE 18114
18112: GO 18173
18114: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18115: LD_EXP 39
18119: PPUSH
18120: LD_STRING D2Com-JMM-1
18122: PPUSH
18123: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18127: LD_EXP 58
18131: PPUSH
18132: LD_STRING D2Com-Pow-1
18134: PPUSH
18135: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18139: LD_EXP 39
18143: PPUSH
18144: LD_STRING D2Com-JMM-2
18146: PPUSH
18147: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18151: LD_EXP 58
18155: PPUSH
18156: LD_STRING D2Com-Pow-2
18158: PPUSH
18159: CALL_OW 88
// powellAngerQuery := true ;
18163: LD_ADDR_EXP 36
18167: PUSH
18168: LD_INT 1
18170: ST_TO_ADDR
// end ; end ;
18171: GO 18174
18173: POP
// end ;
18174: LD_VAR 0 3
18178: RET
// every 0 0$5 trigger missionStart do var tmp ;
18179: LD_EXP 13
18183: IFFALSE 18466
18185: GO 18187
18187: DISABLE
18188: LD_INT 0
18190: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18191: LD_INT 35
18193: PPUSH
18194: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18198: LD_INT 14
18200: PPUSH
18201: LD_INT 22
18203: PUSH
18204: LD_INT 1
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: PPUSH
18211: CALL_OW 70
18215: PUSH
18216: LD_EXP 15
18220: PUSH
18221: LD_INT 2
18223: PUSH
18224: LD_INT 3
18226: PUSH
18227: LD_INT 4
18229: PUSH
18230: LD_INT 5
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: LIST
18237: LIST
18238: IN
18239: AND
18240: IFFALSE 18456
// begin powellAnger := powellAnger + 1 ;
18242: LD_ADDR_EXP 17
18246: PUSH
18247: LD_EXP 17
18251: PUSH
18252: LD_INT 1
18254: PLUS
18255: ST_TO_ADDR
// Video ( true ) ;
18256: LD_INT 1
18258: PPUSH
18259: CALL 107796 0 1
// CenterNowOnUnits ( tmp ) ;
18263: LD_VAR 0 1
18267: PPUSH
18268: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18272: LD_INT 14
18274: PPUSH
18275: LD_INT 22
18277: PUSH
18278: LD_INT 1
18280: PUSH
18281: EMPTY
18282: LIST
18283: LIST
18284: PPUSH
18285: CALL_OW 70
18289: PPUSH
18290: LD_INT 86
18292: PPUSH
18293: LD_INT 133
18295: PPUSH
18296: CALL_OW 111
// async ;
18300: ASYNC
// case powellAnger of 1 :
18301: LD_EXP 17
18305: PUSH
18306: LD_INT 1
18308: DOUBLE
18309: EQUAL
18310: IFTRUE 18314
18312: GO 18329
18314: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18315: LD_EXP 58
18319: PPUSH
18320: LD_STRING DBack1-Pow-1
18322: PPUSH
18323: CALL_OW 88
18327: GO 18376
18329: LD_INT 2
18331: DOUBLE
18332: EQUAL
18333: IFTRUE 18337
18335: GO 18352
18337: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18338: LD_EXP 58
18342: PPUSH
18343: LD_STRING DBack2-Pow-1
18345: PPUSH
18346: CALL_OW 88
18350: GO 18376
18352: LD_INT 3
18354: DOUBLE
18355: EQUAL
18356: IFTRUE 18360
18358: GO 18375
18360: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18361: LD_EXP 58
18365: PPUSH
18366: LD_STRING DBack3-Pow-1
18368: PPUSH
18369: CALL_OW 88
18373: GO 18376
18375: POP
// sync ;
18376: SYNC
// repeat wait ( 0 0$1 ) ;
18377: LD_INT 35
18379: PPUSH
18380: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18384: LD_INT 14
18386: PPUSH
18387: LD_INT 22
18389: PUSH
18390: LD_INT 1
18392: PUSH
18393: EMPTY
18394: LIST
18395: LIST
18396: PPUSH
18397: CALL_OW 70
18401: PPUSH
18402: LD_INT 86
18404: PPUSH
18405: LD_INT 133
18407: PPUSH
18408: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18412: LD_INT 14
18414: PPUSH
18415: LD_INT 22
18417: PUSH
18418: LD_INT 1
18420: PUSH
18421: EMPTY
18422: LIST
18423: LIST
18424: PPUSH
18425: CALL_OW 70
18429: NOT
18430: IFFALSE 18377
// if powellAnger >= 3 then
18432: LD_EXP 17
18436: PUSH
18437: LD_INT 3
18439: GREATEREQUAL
18440: IFFALSE 18449
// YouLost ( Dismissed ) ;
18442: LD_STRING Dismissed
18444: PPUSH
18445: CALL_OW 104
// Video ( false ) ;
18449: LD_INT 0
18451: PPUSH
18452: CALL 107796 0 1
// end ; until missionStage > 5 ;
18456: LD_EXP 15
18460: PUSH
18461: LD_INT 5
18463: GREATER
18464: IFFALSE 18191
// end ;
18466: PPOPN 1
18468: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18469: LD_EXP 13
18473: PUSH
18474: LD_INT 22
18476: PUSH
18477: LD_INT 4
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: PUSH
18484: LD_INT 21
18486: PUSH
18487: LD_INT 2
18489: PUSH
18490: EMPTY
18491: LIST
18492: LIST
18493: PUSH
18494: EMPTY
18495: LIST
18496: LIST
18497: PPUSH
18498: CALL_OW 69
18502: PUSH
18503: LD_INT 4
18505: GREATEREQUAL
18506: AND
18507: PUSH
18508: LD_EXP 15
18512: PUSH
18513: LD_INT 2
18515: EQUAL
18516: AND
18517: IFFALSE 20340
18519: GO 18521
18521: DISABLE
18522: LD_INT 0
18524: PPUSH
18525: PPUSH
18526: PPUSH
18527: PPUSH
18528: PPUSH
18529: PPUSH
18530: PPUSH
18531: PPUSH
// begin missionStage := 3 ;
18532: LD_ADDR_EXP 15
18536: PUSH
18537: LD_INT 3
18539: ST_TO_ADDR
// retreat := false ;
18540: LD_ADDR_VAR 0 4
18544: PUSH
18545: LD_INT 0
18547: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18548: LD_ADDR_VAR 0 5
18552: PUSH
18553: LD_INT 22
18555: PUSH
18556: LD_INT 4
18558: PUSH
18559: EMPTY
18560: LIST
18561: LIST
18562: PUSH
18563: LD_INT 30
18565: PUSH
18566: LD_INT 4
18568: PUSH
18569: EMPTY
18570: LIST
18571: LIST
18572: PUSH
18573: EMPTY
18574: LIST
18575: LIST
18576: PPUSH
18577: CALL_OW 69
18581: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18582: LD_ADDR_VAR 0 6
18586: PUSH
18587: LD_INT 22
18589: PUSH
18590: LD_INT 4
18592: PUSH
18593: EMPTY
18594: LIST
18595: LIST
18596: PUSH
18597: LD_INT 30
18599: PUSH
18600: LD_INT 5
18602: PUSH
18603: EMPTY
18604: LIST
18605: LIST
18606: PUSH
18607: EMPTY
18608: LIST
18609: LIST
18610: PPUSH
18611: CALL_OW 69
18615: ST_TO_ADDR
// if not bar then
18616: LD_VAR 0 6
18620: NOT
18621: IFFALSE 18674
// begin repeat wait ( 0 0$1 ) ;
18623: LD_INT 35
18625: PPUSH
18626: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18630: LD_INT 22
18632: PUSH
18633: LD_INT 4
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: PUSH
18640: LD_INT 3
18642: PUSH
18643: LD_INT 57
18645: PUSH
18646: EMPTY
18647: LIST
18648: PUSH
18649: EMPTY
18650: LIST
18651: LIST
18652: PUSH
18653: LD_INT 30
18655: PUSH
18656: LD_INT 5
18658: PUSH
18659: EMPTY
18660: LIST
18661: LIST
18662: PUSH
18663: EMPTY
18664: LIST
18665: LIST
18666: LIST
18667: PPUSH
18668: CALL_OW 69
18672: IFFALSE 18623
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18674: LD_ADDR_VAR 0 6
18678: PUSH
18679: LD_INT 22
18681: PUSH
18682: LD_INT 4
18684: PUSH
18685: EMPTY
18686: LIST
18687: LIST
18688: PUSH
18689: LD_INT 30
18691: PUSH
18692: LD_INT 5
18694: PUSH
18695: EMPTY
18696: LIST
18697: LIST
18698: PUSH
18699: EMPTY
18700: LIST
18701: LIST
18702: PPUSH
18703: CALL_OW 69
18707: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18708: LD_INT 35
18710: PPUSH
18711: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18715: LD_EXP 121
18719: PUSH
18720: LD_INT 4
18722: ARRAY
18723: PUSH
18724: LD_INT 4
18726: GREATEREQUAL
18727: IFFALSE 18708
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18729: LD_ADDR_VAR 0 2
18733: PUSH
18734: LD_INT 22
18736: PUSH
18737: LD_INT 4
18739: PUSH
18740: EMPTY
18741: LIST
18742: LIST
18743: PUSH
18744: LD_INT 2
18746: PUSH
18747: LD_INT 25
18749: PUSH
18750: LD_INT 1
18752: PUSH
18753: EMPTY
18754: LIST
18755: LIST
18756: PUSH
18757: LD_INT 25
18759: PUSH
18760: LD_INT 2
18762: PUSH
18763: EMPTY
18764: LIST
18765: LIST
18766: PUSH
18767: LD_INT 25
18769: PUSH
18770: LD_INT 3
18772: PUSH
18773: EMPTY
18774: LIST
18775: LIST
18776: PUSH
18777: LD_INT 25
18779: PUSH
18780: LD_INT 4
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: PUSH
18787: LD_INT 25
18789: PUSH
18790: LD_INT 5
18792: PUSH
18793: EMPTY
18794: LIST
18795: LIST
18796: PUSH
18797: EMPTY
18798: LIST
18799: LIST
18800: LIST
18801: LIST
18802: LIST
18803: LIST
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PPUSH
18809: CALL_OW 69
18813: PUSH
18814: LD_EXP 58
18818: PUSH
18819: LD_EXP 59
18823: ADD
18824: DIFF
18825: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18826: LD_ADDR_VAR 0 3
18830: PUSH
18831: LD_VAR 0 2
18835: PPUSH
18836: LD_INT 26
18838: PUSH
18839: LD_INT 1
18841: PUSH
18842: EMPTY
18843: LIST
18844: LIST
18845: PPUSH
18846: CALL_OW 72
18850: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18851: LD_ADDR_VAR 0 2
18855: PUSH
18856: LD_VAR 0 2
18860: PUSH
18861: LD_VAR 0 3
18865: DIFF
18866: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18867: LD_ADDR_VAR 0 2
18871: PUSH
18872: LD_VAR 0 2
18876: PPUSH
18877: LD_INT 1
18879: PPUSH
18880: CALL 106449 0 2
18884: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18885: LD_ADDR_VAR 0 3
18889: PUSH
18890: LD_VAR 0 3
18894: PPUSH
18895: LD_INT 1
18897: PPUSH
18898: CALL 106449 0 2
18902: ST_TO_ADDR
// for i = 1 to 4 do
18903: LD_ADDR_VAR 0 1
18907: PUSH
18908: DOUBLE
18909: LD_INT 1
18911: DEC
18912: ST_TO_ADDR
18913: LD_INT 4
18915: PUSH
18916: FOR_TO
18917: IFFALSE 19083
// begin if tmp2 then
18919: LD_VAR 0 3
18923: IFFALSE 19004
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18925: LD_ADDR_EXP 18
18929: PUSH
18930: LD_EXP 18
18934: PPUSH
18935: LD_INT 1
18937: PPUSH
18938: LD_EXP 18
18942: PUSH
18943: LD_INT 1
18945: ARRAY
18946: PUSH
18947: LD_VAR 0 3
18951: PUSH
18952: LD_VAR 0 3
18956: ARRAY
18957: ADD
18958: PPUSH
18959: CALL_OW 1
18963: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18964: LD_VAR 0 3
18968: PUSH
18969: LD_VAR 0 3
18973: ARRAY
18974: PPUSH
18975: LD_INT 1
18977: PPUSH
18978: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18982: LD_ADDR_VAR 0 3
18986: PUSH
18987: LD_VAR 0 3
18991: PPUSH
18992: LD_VAR 0 3
18996: PPUSH
18997: CALL_OW 3
19001: ST_TO_ADDR
// end else
19002: GO 19081
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19004: LD_ADDR_EXP 18
19008: PUSH
19009: LD_EXP 18
19013: PPUSH
19014: LD_INT 1
19016: PPUSH
19017: LD_EXP 18
19021: PUSH
19022: LD_INT 1
19024: ARRAY
19025: PUSH
19026: LD_VAR 0 2
19030: PUSH
19031: LD_VAR 0 2
19035: ARRAY
19036: ADD
19037: PPUSH
19038: CALL_OW 1
19042: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19043: LD_VAR 0 2
19047: PUSH
19048: LD_VAR 0 2
19052: ARRAY
19053: PPUSH
19054: LD_INT 1
19056: PPUSH
19057: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19061: LD_ADDR_VAR 0 2
19065: PUSH
19066: LD_VAR 0 2
19070: PPUSH
19071: LD_VAR 0 2
19075: PPUSH
19076: CALL_OW 3
19080: ST_TO_ADDR
// end ; end ;
19081: GO 18916
19083: POP
19084: POP
// if tmp2 then
19085: LD_VAR 0 3
19089: IFFALSE 19107
// tmp := tmp union tmp2 ;
19091: LD_ADDR_VAR 0 2
19095: PUSH
19096: LD_VAR 0 2
19100: PUSH
19101: LD_VAR 0 3
19105: UNION
19106: ST_TO_ADDR
// for i = 1 to 4 do
19107: LD_ADDR_VAR 0 1
19111: PUSH
19112: DOUBLE
19113: LD_INT 1
19115: DEC
19116: ST_TO_ADDR
19117: LD_INT 4
19119: PUSH
19120: FOR_TO
19121: IFFALSE 19170
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19123: LD_ADDR_EXP 18
19127: PUSH
19128: LD_EXP 18
19132: PPUSH
19133: LD_INT 2
19135: PPUSH
19136: LD_EXP 18
19140: PUSH
19141: LD_INT 2
19143: ARRAY
19144: PUSH
19145: LD_VAR 0 2
19149: PUSH
19150: LD_VAR 0 2
19154: PUSH
19155: LD_VAR 0 1
19159: MINUS
19160: ARRAY
19161: ADD
19162: PPUSH
19163: CALL_OW 1
19167: ST_TO_ADDR
19168: GO 19120
19170: POP
19171: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19172: LD_ADDR_EXP 102
19176: PUSH
19177: LD_EXP 102
19181: PPUSH
19182: LD_INT 4
19184: PPUSH
19185: LD_EXP 102
19189: PUSH
19190: LD_INT 4
19192: ARRAY
19193: PUSH
19194: LD_EXP 18
19198: PUSH
19199: LD_INT 1
19201: ARRAY
19202: DIFF
19203: PPUSH
19204: CALL_OW 1
19208: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19209: LD_VAR 0 5
19213: PUSH
19214: LD_INT 1
19216: ARRAY
19217: PPUSH
19218: CALL_OW 313
19222: IFFALSE 19277
// begin for i in UnitsInside ( arm [ 1 ] ) do
19224: LD_ADDR_VAR 0 1
19228: PUSH
19229: LD_VAR 0 5
19233: PUSH
19234: LD_INT 1
19236: ARRAY
19237: PPUSH
19238: CALL_OW 313
19242: PUSH
19243: FOR_IN
19244: IFFALSE 19275
// begin ComExitBuilding ( i ) ;
19246: LD_VAR 0 1
19250: PPUSH
19251: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19255: LD_VAR 0 1
19259: PPUSH
19260: LD_VAR 0 6
19264: PUSH
19265: LD_INT 1
19267: ARRAY
19268: PPUSH
19269: CALL_OW 180
// end ;
19273: GO 19243
19275: POP
19276: POP
// end ; wait ( 0 0$3 ) ;
19277: LD_INT 105
19279: PPUSH
19280: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19284: LD_ADDR_VAR 0 1
19288: PUSH
19289: LD_EXP 18
19293: PUSH
19294: LD_INT 1
19296: ARRAY
19297: PUSH
19298: FOR_IN
19299: IFFALSE 19406
// begin if IsInUnit ( i ) then
19301: LD_VAR 0 1
19305: PPUSH
19306: CALL_OW 310
19310: IFFALSE 19321
// ComExitBuilding ( i ) ;
19312: LD_VAR 0 1
19316: PPUSH
19317: CALL_OW 122
// if GetClass ( i ) <> 1 then
19321: LD_VAR 0 1
19325: PPUSH
19326: CALL_OW 257
19330: PUSH
19331: LD_INT 1
19333: NONEQUAL
19334: IFFALSE 19375
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19336: LD_VAR 0 1
19340: PPUSH
19341: LD_VAR 0 5
19345: PUSH
19346: LD_INT 1
19348: ARRAY
19349: PPUSH
19350: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19354: LD_VAR 0 1
19358: PPUSH
19359: LD_INT 1
19361: PPUSH
19362: CALL_OW 183
// AddComExitBuilding ( i ) ;
19366: LD_VAR 0 1
19370: PPUSH
19371: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19375: LD_VAR 0 1
19379: PPUSH
19380: LD_INT 60
19382: PPUSH
19383: LD_INT 94
19385: PPUSH
19386: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19390: LD_VAR 0 1
19394: PPUSH
19395: LD_EXP 58
19399: PPUSH
19400: CALL_OW 179
// end ;
19404: GO 19298
19406: POP
19407: POP
// wait ( 0 0$15 ) ;
19408: LD_INT 525
19410: PPUSH
19411: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19415: LD_EXP 58
19419: PPUSH
19420: LD_STRING D4-Pow-1
19422: PPUSH
19423: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19427: LD_ADDR_VAR 0 2
19431: PUSH
19432: LD_EXP 18
19436: PUSH
19437: LD_INT 1
19439: ARRAY
19440: PPUSH
19441: LD_INT 26
19443: PUSH
19444: LD_INT 1
19446: PUSH
19447: EMPTY
19448: LIST
19449: LIST
19450: PPUSH
19451: CALL_OW 72
19455: ST_TO_ADDR
// if tmp then
19456: LD_VAR 0 2
19460: IFFALSE 19478
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19462: LD_VAR 0 2
19466: PUSH
19467: LD_INT 1
19469: ARRAY
19470: PPUSH
19471: LD_STRING D4-Sol1-1
19473: PPUSH
19474: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19478: LD_EXP 58
19482: PPUSH
19483: LD_STRING D4-Pow-2
19485: PPUSH
19486: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19490: LD_ADDR_VAR 0 1
19494: PUSH
19495: DOUBLE
19496: LD_INT 1
19498: DEC
19499: ST_TO_ADDR
19500: LD_EXP 18
19504: PUSH
19505: LD_INT 1
19507: ARRAY
19508: PUSH
19509: FOR_TO
19510: IFFALSE 19603
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19512: LD_EXP 18
19516: PUSH
19517: LD_INT 1
19519: ARRAY
19520: PUSH
19521: LD_VAR 0 1
19525: ARRAY
19526: PPUSH
19527: LD_EXP 121
19531: PUSH
19532: LD_INT 4
19534: ARRAY
19535: PUSH
19536: LD_INT 1
19538: ARRAY
19539: PPUSH
19540: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19544: LD_ADDR_EXP 121
19548: PUSH
19549: LD_EXP 121
19553: PPUSH
19554: LD_INT 4
19556: PPUSH
19557: LD_EXP 121
19561: PUSH
19562: LD_INT 4
19564: ARRAY
19565: PPUSH
19566: LD_INT 1
19568: PPUSH
19569: CALL_OW 3
19573: PPUSH
19574: CALL_OW 1
19578: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19579: LD_INT 8
19581: PPUSH
19582: LD_EXP 18
19586: PUSH
19587: LD_INT 1
19589: ARRAY
19590: PUSH
19591: LD_VAR 0 1
19595: ARRAY
19596: PPUSH
19597: CALL_OW 471
// end ;
19601: GO 19509
19603: POP
19604: POP
// repeat wait ( 0 0$1 ) ;
19605: LD_INT 35
19607: PPUSH
19608: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19612: LD_EXP 18
19616: PUSH
19617: LD_INT 1
19619: ARRAY
19620: PPUSH
19621: LD_INT 55
19623: PUSH
19624: EMPTY
19625: LIST
19626: PPUSH
19627: CALL_OW 72
19631: PUSH
19632: LD_INT 4
19634: GREATEREQUAL
19635: IFFALSE 19605
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19637: LD_EXP 18
19641: PUSH
19642: LD_INT 1
19644: ARRAY
19645: PPUSH
19646: LD_INT 69
19648: PPUSH
19649: LD_INT 94
19651: PPUSH
19652: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19656: LD_EXP 18
19660: PUSH
19661: LD_INT 1
19663: ARRAY
19664: PPUSH
19665: LD_INT 82
19667: PPUSH
19668: LD_INT 83
19670: PPUSH
19671: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19675: LD_EXP 18
19679: PUSH
19680: LD_INT 1
19682: ARRAY
19683: PPUSH
19684: LD_INT 77
19686: PPUSH
19687: LD_INT 69
19689: PPUSH
19690: CALL_OW 174
// repeat wait ( 3 ) ;
19694: LD_INT 3
19696: PPUSH
19697: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19701: LD_ADDR_VAR 0 1
19705: PUSH
19706: LD_EXP 18
19710: PUSH
19711: LD_INT 1
19713: ARRAY
19714: PUSH
19715: FOR_IN
19716: IFFALSE 19852
// begin if GetLives ( i ) < 990 then
19718: LD_VAR 0 1
19722: PPUSH
19723: CALL_OW 256
19727: PUSH
19728: LD_INT 990
19730: LESS
19731: IFFALSE 19745
// SetLives ( i , 1000 ) ;
19733: LD_VAR 0 1
19737: PPUSH
19738: LD_INT 1000
19740: PPUSH
19741: CALL_OW 234
// if not IsInUnit ( i ) then
19745: LD_VAR 0 1
19749: PPUSH
19750: CALL_OW 310
19754: NOT
19755: IFFALSE 19850
// begin if not HasTask ( i ) then
19757: LD_VAR 0 1
19761: PPUSH
19762: CALL_OW 314
19766: NOT
19767: IFFALSE 19784
// ComMoveXY ( i , 64 , 93 ) ;
19769: LD_VAR 0 1
19773: PPUSH
19774: LD_INT 64
19776: PPUSH
19777: LD_INT 93
19779: PPUSH
19780: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19784: LD_VAR 0 4
19788: NOT
19789: PUSH
19790: LD_VAR 0 1
19794: PPUSH
19795: CALL_OW 258
19799: PUSH
19800: LD_INT 1
19802: EQUAL
19803: AND
19804: IFFALSE 19850
// begin retreat := true ;
19806: LD_ADDR_VAR 0 4
19810: PUSH
19811: LD_INT 1
19813: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19814: LD_VAR 0 1
19818: PPUSH
19819: LD_INT 2
19821: PPUSH
19822: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19826: LD_VAR 0 1
19830: PPUSH
19831: LD_STRING D4a-Sol1-1
19833: PPUSH
19834: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19838: LD_EXP 58
19842: PPUSH
19843: LD_STRING D4a-Pow-1
19845: PPUSH
19846: CALL_OW 88
// end ; end ; end ;
19850: GO 19715
19852: POP
19853: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19854: LD_EXP 18
19858: PUSH
19859: LD_INT 1
19861: ARRAY
19862: PPUSH
19863: LD_INT 95
19865: PUSH
19866: LD_INT 9
19868: PUSH
19869: EMPTY
19870: LIST
19871: LIST
19872: PUSH
19873: LD_INT 3
19875: PUSH
19876: LD_INT 55
19878: PUSH
19879: EMPTY
19880: LIST
19881: PUSH
19882: EMPTY
19883: LIST
19884: LIST
19885: PUSH
19886: EMPTY
19887: LIST
19888: LIST
19889: PPUSH
19890: CALL_OW 72
19894: PUSH
19895: LD_INT 4
19897: GREATEREQUAL
19898: IFFALSE 19694
// for i in powellSquadAttack [ 1 ] do
19900: LD_ADDR_VAR 0 1
19904: PUSH
19905: LD_EXP 18
19909: PUSH
19910: LD_INT 1
19912: ARRAY
19913: PUSH
19914: FOR_IN
19915: IFFALSE 20051
// begin if GetTag ( i ) = 2 then
19917: LD_VAR 0 1
19921: PPUSH
19922: CALL_OW 110
19926: PUSH
19927: LD_INT 2
19929: EQUAL
19930: IFFALSE 19992
// begin ComMoveXY ( i , 60 , 94 ) ;
19932: LD_VAR 0 1
19936: PPUSH
19937: LD_INT 60
19939: PPUSH
19940: LD_INT 94
19942: PPUSH
19943: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19947: LD_VAR 0 1
19951: PPUSH
19952: LD_EXP 58
19956: PPUSH
19957: CALL_OW 179
// wait ( 0 0$3 ) ;
19961: LD_INT 105
19963: PPUSH
19964: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19968: LD_VAR 0 1
19972: PPUSH
19973: LD_STRING D4a-Sol1-2
19975: PPUSH
19976: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19980: LD_EXP 58
19984: PPUSH
19985: LD_STRING D4a-Pow-2
19987: PPUSH
19988: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19992: LD_VAR 0 1
19996: PPUSH
19997: LD_INT 0
19999: PPUSH
20000: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20004: LD_ADDR_EXP 102
20008: PUSH
20009: LD_EXP 102
20013: PPUSH
20014: LD_INT 4
20016: PPUSH
20017: LD_EXP 102
20021: PUSH
20022: LD_INT 4
20024: ARRAY
20025: PUSH
20026: LD_VAR 0 1
20030: UNION
20031: PPUSH
20032: CALL_OW 1
20036: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20037: LD_INT 8
20039: PPUSH
20040: LD_VAR 0 1
20044: PPUSH
20045: CALL_OW 472
// end ;
20049: GO 19914
20051: POP
20052: POP
// wait ( 4 4$00 ) ;
20053: LD_INT 8400
20055: PPUSH
20056: CALL_OW 67
// uc_side := 6 ;
20060: LD_ADDR_OWVAR 20
20064: PUSH
20065: LD_INT 6
20067: ST_TO_ADDR
// uc_nation := 3 ;
20068: LD_ADDR_OWVAR 21
20072: PUSH
20073: LD_INT 3
20075: ST_TO_ADDR
// ru := [ ] ;
20076: LD_ADDR_VAR 0 7
20080: PUSH
20081: EMPTY
20082: ST_TO_ADDR
// for i = 1 to 4 do
20083: LD_ADDR_VAR 0 1
20087: PUSH
20088: DOUBLE
20089: LD_INT 1
20091: DEC
20092: ST_TO_ADDR
20093: LD_INT 4
20095: PUSH
20096: FOR_TO
20097: IFFALSE 20198
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20099: LD_INT 22
20101: PPUSH
20102: LD_INT 1
20104: PPUSH
20105: LD_INT 3
20107: PPUSH
20108: LD_INT 43
20110: PUSH
20111: LD_INT 44
20113: PUSH
20114: EMPTY
20115: LIST
20116: LIST
20117: PUSH
20118: LD_INT 1
20120: PPUSH
20121: LD_INT 2
20123: PPUSH
20124: CALL_OW 12
20128: ARRAY
20129: PPUSH
20130: LD_INT 89
20132: PPUSH
20133: CALL 72069 0 5
// un := CreateVehicle ;
20137: LD_ADDR_VAR 0 8
20141: PUSH
20142: CALL_OW 45
20146: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20147: LD_VAR 0 8
20151: PPUSH
20152: LD_INT 4
20154: PPUSH
20155: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20159: LD_VAR 0 8
20163: PPUSH
20164: LD_INT 136
20166: PPUSH
20167: LD_INT 90
20169: PPUSH
20170: LD_INT 8
20172: PPUSH
20173: LD_INT 0
20175: PPUSH
20176: CALL_OW 50
// ru := ru ^ un ;
20180: LD_ADDR_VAR 0 7
20184: PUSH
20185: LD_VAR 0 7
20189: PUSH
20190: LD_VAR 0 8
20194: ADD
20195: ST_TO_ADDR
// end ;
20196: GO 20096
20198: POP
20199: POP
// if ru then
20200: LD_VAR 0 7
20204: IFFALSE 20221
// ComAgressiveMove ( ru , 80 , 92 ) ;
20206: LD_VAR 0 7
20210: PPUSH
20211: LD_INT 80
20213: PPUSH
20214: LD_INT 92
20216: PPUSH
20217: CALL_OW 114
// wait ( 8 8$00 ) ;
20221: LD_INT 16800
20223: PPUSH
20224: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20228: LD_INT 4
20230: PPUSH
20231: LD_INT 3
20233: PUSH
20234: LD_INT 1
20236: PUSH
20237: LD_INT 1
20239: PUSH
20240: LD_INT 5
20242: PUSH
20243: EMPTY
20244: LIST
20245: LIST
20246: LIST
20247: LIST
20248: PUSH
20249: LD_INT 4
20251: PUSH
20252: LD_INT 1
20254: PUSH
20255: LD_INT 1
20257: PUSH
20258: LD_INT 6
20260: PUSH
20261: EMPTY
20262: LIST
20263: LIST
20264: LIST
20265: LIST
20266: PUSH
20267: LD_INT 4
20269: PUSH
20270: LD_INT 1
20272: PUSH
20273: LD_INT 1
20275: PUSH
20276: LD_INT 7
20278: PUSH
20279: EMPTY
20280: LIST
20281: LIST
20282: LIST
20283: LIST
20284: PUSH
20285: LD_INT 3
20287: PUSH
20288: LD_INT 1
20290: PUSH
20291: LD_INT 1
20293: PUSH
20294: LD_INT 7
20296: PUSH
20297: EMPTY
20298: LIST
20299: LIST
20300: LIST
20301: LIST
20302: PUSH
20303: LD_INT 3
20305: PUSH
20306: LD_INT 1
20308: PUSH
20309: LD_INT 1
20311: PUSH
20312: LD_INT 5
20314: PUSH
20315: EMPTY
20316: LIST
20317: LIST
20318: LIST
20319: LIST
20320: PUSH
20321: EMPTY
20322: LIST
20323: LIST
20324: LIST
20325: LIST
20326: LIST
20327: PPUSH
20328: CALL 58502 0 2
// missionStage := 4 ;
20332: LD_ADDR_EXP 15
20336: PUSH
20337: LD_INT 4
20339: ST_TO_ADDR
// end ;
20340: PPOPN 8
20342: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20343: LD_EXP 15
20347: PUSH
20348: LD_INT 4
20350: EQUAL
20351: PUSH
20352: LD_INT 22
20354: PUSH
20355: LD_INT 4
20357: PUSH
20358: EMPTY
20359: LIST
20360: LIST
20361: PUSH
20362: LD_INT 21
20364: PUSH
20365: LD_INT 2
20367: PUSH
20368: EMPTY
20369: LIST
20370: LIST
20371: PUSH
20372: EMPTY
20373: LIST
20374: LIST
20375: PPUSH
20376: CALL_OW 69
20380: PUSH
20381: LD_INT 5
20383: GREATEREQUAL
20384: AND
20385: IFFALSE 24490
20387: GO 20389
20389: DISABLE
20390: LD_INT 0
20392: PPUSH
20393: PPUSH
20394: PPUSH
20395: PPUSH
20396: PPUSH
20397: PPUSH
20398: PPUSH
20399: PPUSH
20400: PPUSH
20401: PPUSH
20402: PPUSH
20403: PPUSH
20404: PPUSH
// begin missionStage := 5 ;
20405: LD_ADDR_EXP 15
20409: PUSH
20410: LD_INT 5
20412: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20413: LD_ADDR_VAR 0 10
20417: PUSH
20418: LD_INT 22
20420: PUSH
20421: LD_INT 4
20423: PUSH
20424: EMPTY
20425: LIST
20426: LIST
20427: PUSH
20428: LD_INT 2
20430: PUSH
20431: LD_INT 30
20433: PUSH
20434: LD_INT 4
20436: PUSH
20437: EMPTY
20438: LIST
20439: LIST
20440: PUSH
20441: LD_INT 30
20443: PUSH
20444: LD_INT 5
20446: PUSH
20447: EMPTY
20448: LIST
20449: LIST
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: LIST
20455: PUSH
20456: EMPTY
20457: LIST
20458: LIST
20459: PPUSH
20460: CALL_OW 69
20464: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20465: LD_ADDR_VAR 0 6
20469: PUSH
20470: LD_INT 22
20472: PUSH
20473: LD_INT 4
20475: PUSH
20476: EMPTY
20477: LIST
20478: LIST
20479: PUSH
20480: LD_INT 21
20482: PUSH
20483: LD_INT 1
20485: PUSH
20486: EMPTY
20487: LIST
20488: LIST
20489: PUSH
20490: LD_INT 3
20492: PUSH
20493: LD_INT 25
20495: PUSH
20496: LD_INT 16
20498: PUSH
20499: EMPTY
20500: LIST
20501: LIST
20502: PUSH
20503: EMPTY
20504: LIST
20505: LIST
20506: PUSH
20507: LD_INT 3
20509: PUSH
20510: LD_INT 25
20512: PUSH
20513: LD_INT 12
20515: PUSH
20516: EMPTY
20517: LIST
20518: LIST
20519: PUSH
20520: EMPTY
20521: LIST
20522: LIST
20523: PUSH
20524: EMPTY
20525: LIST
20526: LIST
20527: LIST
20528: LIST
20529: PPUSH
20530: CALL_OW 69
20534: PUSH
20535: LD_EXP 58
20539: DIFF
20540: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20541: LD_ADDR_VAR 0 9
20545: PUSH
20546: LD_INT 22
20548: PUSH
20549: LD_INT 4
20551: PUSH
20552: EMPTY
20553: LIST
20554: LIST
20555: PUSH
20556: LD_INT 30
20558: PUSH
20559: LD_INT 3
20561: PUSH
20562: EMPTY
20563: LIST
20564: LIST
20565: PUSH
20566: EMPTY
20567: LIST
20568: LIST
20569: PPUSH
20570: CALL_OW 69
20574: PUSH
20575: LD_INT 1
20577: ARRAY
20578: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20579: LD_INT 35
20581: PPUSH
20582: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20586: LD_EXP 121
20590: PUSH
20591: LD_INT 4
20593: ARRAY
20594: PUSH
20595: LD_INT 5
20597: GREATEREQUAL
20598: PUSH
20599: LD_EXP 121
20603: PUSH
20604: LD_INT 4
20606: ARRAY
20607: PPUSH
20608: LD_INT 58
20610: PUSH
20611: EMPTY
20612: LIST
20613: PPUSH
20614: CALL_OW 72
20618: PUSH
20619: LD_INT 5
20621: GREATEREQUAL
20622: AND
20623: IFFALSE 20579
// powellAllowRetreat := false ;
20625: LD_ADDR_EXP 19
20629: PUSH
20630: LD_INT 0
20632: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20633: LD_INT 700
20635: PPUSH
20636: CALL_OW 67
// activeAttacks := false ;
20640: LD_ADDR_EXP 16
20644: PUSH
20645: LD_INT 0
20647: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20648: LD_INT 35
20650: PPUSH
20651: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20655: LD_INT 22
20657: PUSH
20658: LD_INT 6
20660: PUSH
20661: EMPTY
20662: LIST
20663: LIST
20664: PPUSH
20665: CALL_OW 69
20669: PUSH
20670: LD_INT 0
20672: EQUAL
20673: IFFALSE 20648
// tmp := mc_vehicles [ 4 ] ;
20675: LD_ADDR_VAR 0 3
20679: PUSH
20680: LD_EXP 121
20684: PUSH
20685: LD_INT 4
20687: ARRAY
20688: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20689: LD_ADDR_VAR 0 1
20693: PUSH
20694: DOUBLE
20695: LD_INT 1
20697: DEC
20698: ST_TO_ADDR
20699: LD_EXP 18
20703: PUSH
20704: FOR_TO
20705: IFFALSE 20966
// begin for j in powellSquadAttack [ i ] do
20707: LD_ADDR_VAR 0 2
20711: PUSH
20712: LD_EXP 18
20716: PUSH
20717: LD_VAR 0 1
20721: ARRAY
20722: PUSH
20723: FOR_IN
20724: IFFALSE 20962
// begin forces := forces diff j ;
20726: LD_ADDR_VAR 0 6
20730: PUSH
20731: LD_VAR 0 6
20735: PUSH
20736: LD_VAR 0 2
20740: DIFF
20741: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20742: LD_VAR 0 2
20746: PPUSH
20747: LD_INT 1
20749: PPUSH
20750: CALL_OW 109
// wait ( 0 0$2 ) ;
20754: LD_INT 70
20756: PPUSH
20757: CALL_OW 67
// if IsInUnit ( j ) then
20761: LD_VAR 0 2
20765: PPUSH
20766: CALL_OW 310
20770: IFFALSE 20781
// ComExitBuilding ( j ) ;
20772: LD_VAR 0 2
20776: PPUSH
20777: CALL_OW 122
// if GetClass ( j ) <> 1 then
20781: LD_VAR 0 2
20785: PPUSH
20786: CALL_OW 257
20790: PUSH
20791: LD_INT 1
20793: NONEQUAL
20794: IFFALSE 20874
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20796: LD_VAR 0 10
20800: PUSH
20801: LD_INT 1
20803: ARRAY
20804: PPUSH
20805: CALL_OW 313
20809: PUSH
20810: LD_INT 5
20812: GREATEREQUAL
20813: IFFALSE 20835
// AddComEnterUnit ( j , arm [ 2 ] ) else
20815: LD_VAR 0 2
20819: PPUSH
20820: LD_VAR 0 10
20824: PUSH
20825: LD_INT 2
20827: ARRAY
20828: PPUSH
20829: CALL_OW 180
20833: GO 20853
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20835: LD_VAR 0 2
20839: PPUSH
20840: LD_VAR 0 10
20844: PUSH
20845: LD_INT 1
20847: ARRAY
20848: PPUSH
20849: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20853: LD_VAR 0 2
20857: PPUSH
20858: LD_INT 1
20860: PPUSH
20861: CALL_OW 183
// AddComExitBuilding ( j ) ;
20865: LD_VAR 0 2
20869: PPUSH
20870: CALL_OW 182
// end ; if i = 2 then
20874: LD_VAR 0 1
20878: PUSH
20879: LD_INT 2
20881: EQUAL
20882: IFFALSE 20899
// AddComMoveXY ( j , 61 , 93 ) ;
20884: LD_VAR 0 2
20888: PPUSH
20889: LD_INT 61
20891: PPUSH
20892: LD_INT 93
20894: PPUSH
20895: CALL_OW 171
// if i = 1 then
20899: LD_VAR 0 1
20903: PUSH
20904: LD_INT 1
20906: EQUAL
20907: IFFALSE 20960
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20909: LD_VAR 0 2
20913: PPUSH
20914: LD_VAR 0 3
20918: PUSH
20919: LD_INT 1
20921: ARRAY
20922: PPUSH
20923: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20927: LD_ADDR_VAR 0 3
20931: PUSH
20932: LD_VAR 0 3
20936: PPUSH
20937: LD_INT 1
20939: PPUSH
20940: CALL_OW 3
20944: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20945: LD_VAR 0 2
20949: PPUSH
20950: LD_INT 69
20952: PPUSH
20953: LD_INT 94
20955: PPUSH
20956: CALL_OW 171
// end ; end ;
20960: GO 20723
20962: POP
20963: POP
// end ;
20964: GO 20704
20966: POP
20967: POP
// wait ( 0 0$55 ) ;
20968: LD_INT 1925
20970: PPUSH
20971: CALL_OW 67
// MC_Kill ( 4 ) ;
20975: LD_INT 4
20977: PPUSH
20978: CALL 35090 0 1
// tmp := UnitsInside ( fac ) ;
20982: LD_ADDR_VAR 0 3
20986: PUSH
20987: LD_VAR 0 9
20991: PPUSH
20992: CALL_OW 313
20996: ST_TO_ADDR
// if tmp then
20997: LD_VAR 0 3
21001: IFFALSE 21122
// for i in tmp do
21003: LD_ADDR_VAR 0 1
21007: PUSH
21008: LD_VAR 0 3
21012: PUSH
21013: FOR_IN
21014: IFFALSE 21120
// begin ComExitBuilding ( i ) ;
21016: LD_VAR 0 1
21020: PPUSH
21021: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21025: LD_VAR 0 10
21029: PUSH
21030: LD_INT 2
21032: ARRAY
21033: PPUSH
21034: CALL_OW 313
21038: PUSH
21039: LD_INT 6
21041: LESS
21042: IFFALSE 21064
// AddComEnterUnit ( i , arm [ 2 ] ) else
21044: LD_VAR 0 1
21048: PPUSH
21049: LD_VAR 0 10
21053: PUSH
21054: LD_INT 2
21056: ARRAY
21057: PPUSH
21058: CALL_OW 180
21062: GO 21118
// if UnitsInside ( arm [ 1 ] ) < 6 then
21064: LD_VAR 0 10
21068: PUSH
21069: LD_INT 1
21071: ARRAY
21072: PPUSH
21073: CALL_OW 313
21077: PUSH
21078: LD_INT 6
21080: LESS
21081: IFFALSE 21103
// AddComEnterUnit ( i , arm [ 1 ] ) else
21083: LD_VAR 0 1
21087: PPUSH
21088: LD_VAR 0 10
21092: PUSH
21093: LD_INT 1
21095: ARRAY
21096: PPUSH
21097: CALL_OW 180
21101: GO 21118
// AddComMoveXY ( i , 37 , 68 ) ;
21103: LD_VAR 0 1
21107: PPUSH
21108: LD_INT 37
21110: PPUSH
21111: LD_INT 68
21113: PPUSH
21114: CALL_OW 171
// end ;
21118: GO 21013
21120: POP
21121: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21122: LD_ADDR_VAR 0 11
21126: PUSH
21127: LD_VAR 0 6
21131: PPUSH
21132: LD_INT 26
21134: PUSH
21135: LD_INT 1
21137: PUSH
21138: EMPTY
21139: LIST
21140: LIST
21141: PPUSH
21142: CALL_OW 72
21146: PUSH
21147: LD_EXP 59
21151: DIFF
21152: ST_TO_ADDR
// if not speaker then
21153: LD_VAR 0 11
21157: NOT
21158: IFFALSE 21185
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21160: LD_ADDR_VAR 0 11
21164: PUSH
21165: LD_VAR 0 6
21169: PPUSH
21170: LD_INT 26
21172: PUSH
21173: LD_INT 1
21175: PUSH
21176: EMPTY
21177: LIST
21178: LIST
21179: PPUSH
21180: CALL_OW 72
21184: ST_TO_ADDR
// if speaker then
21185: LD_VAR 0 11
21189: IFFALSE 21205
// speaker := speaker [ 1 ] ;
21191: LD_ADDR_VAR 0 11
21195: PUSH
21196: LD_VAR 0 11
21200: PUSH
21201: LD_INT 1
21203: ARRAY
21204: ST_TO_ADDR
// Video ( true ) ;
21205: LD_INT 1
21207: PPUSH
21208: CALL 107796 0 1
// CenterNowOnUnits ( Powell ) ;
21212: LD_EXP 58
21216: PPUSH
21217: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21221: LD_ADDR_VAR 0 3
21225: PUSH
21226: LD_VAR 0 6
21230: PPUSH
21231: LD_INT 3
21233: PUSH
21234: LD_INT 25
21236: PUSH
21237: LD_INT 1
21239: PUSH
21240: EMPTY
21241: LIST
21242: LIST
21243: PUSH
21244: EMPTY
21245: LIST
21246: LIST
21247: PPUSH
21248: CALL_OW 72
21252: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21253: LD_ADDR_VAR 0 12
21257: PUSH
21258: LD_INT 22
21260: PUSH
21261: LD_INT 4
21263: PUSH
21264: EMPTY
21265: LIST
21266: LIST
21267: PUSH
21268: LD_INT 30
21270: PUSH
21271: LD_INT 32
21273: PUSH
21274: EMPTY
21275: LIST
21276: LIST
21277: PUSH
21278: LD_INT 58
21280: PUSH
21281: EMPTY
21282: LIST
21283: PUSH
21284: EMPTY
21285: LIST
21286: LIST
21287: LIST
21288: PPUSH
21289: CALL_OW 69
21293: ST_TO_ADDR
// for i = 1 to 6 do
21294: LD_ADDR_VAR 0 1
21298: PUSH
21299: DOUBLE
21300: LD_INT 1
21302: DEC
21303: ST_TO_ADDR
21304: LD_INT 6
21306: PUSH
21307: FOR_TO
21308: IFFALSE 21449
// begin if IsInUnit ( tmp [ i ] ) then
21310: LD_VAR 0 3
21314: PUSH
21315: LD_VAR 0 1
21319: ARRAY
21320: PPUSH
21321: CALL_OW 310
21325: IFFALSE 21342
// ComExitBuilding ( tmp [ i ] ) ;
21327: LD_VAR 0 3
21331: PUSH
21332: LD_VAR 0 1
21336: ARRAY
21337: PPUSH
21338: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21342: LD_VAR 0 3
21346: PUSH
21347: LD_VAR 0 1
21351: ARRAY
21352: PPUSH
21353: LD_VAR 0 10
21357: PUSH
21358: LD_INT 1
21360: ARRAY
21361: PPUSH
21362: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21366: LD_VAR 0 3
21370: PUSH
21371: LD_VAR 0 1
21375: ARRAY
21376: PPUSH
21377: LD_INT 1
21379: PPUSH
21380: CALL_OW 183
// if emp_towers then
21384: LD_VAR 0 12
21388: IFFALSE 21447
// begin AddComExitBuilding ( tmp [ i ] ) ;
21390: LD_VAR 0 3
21394: PUSH
21395: LD_VAR 0 1
21399: ARRAY
21400: PPUSH
21401: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21405: LD_VAR 0 3
21409: PUSH
21410: LD_VAR 0 1
21414: ARRAY
21415: PPUSH
21416: LD_VAR 0 12
21420: PUSH
21421: LD_INT 1
21423: ARRAY
21424: PPUSH
21425: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21429: LD_ADDR_VAR 0 12
21433: PUSH
21434: LD_VAR 0 12
21438: PPUSH
21439: LD_INT 1
21441: PPUSH
21442: CALL_OW 3
21446: ST_TO_ADDR
// end ; end ;
21447: GO 21307
21449: POP
21450: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21451: LD_ADDR_VAR 0 3
21455: PUSH
21456: LD_EXP 18
21460: PUSH
21461: LD_INT 1
21463: ARRAY
21464: PUSH
21465: LD_EXP 18
21469: PUSH
21470: LD_INT 2
21472: ARRAY
21473: ADD
21474: PPUSH
21475: LD_INT 26
21477: PUSH
21478: LD_INT 1
21480: PUSH
21481: EMPTY
21482: LIST
21483: LIST
21484: PPUSH
21485: CALL_OW 72
21489: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21490: LD_ADDR_VAR 0 1
21494: PUSH
21495: LD_EXP 18
21499: PUSH
21500: LD_INT 2
21502: ARRAY
21503: PUSH
21504: FOR_IN
21505: IFFALSE 21523
// ComTurnUnit ( i , Powell ) ;
21507: LD_VAR 0 1
21511: PPUSH
21512: LD_EXP 58
21516: PPUSH
21517: CALL_OW 119
21521: GO 21504
21523: POP
21524: POP
// Say ( Powell , D5-Pow-1 ) ;
21525: LD_EXP 58
21529: PPUSH
21530: LD_STRING D5-Pow-1
21532: PPUSH
21533: CALL_OW 88
// if tmp then
21537: LD_VAR 0 3
21541: IFFALSE 21559
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21543: LD_VAR 0 3
21547: PUSH
21548: LD_INT 1
21550: ARRAY
21551: PPUSH
21552: LD_STRING D5-Sol2-1
21554: PPUSH
21555: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21559: LD_EXP 58
21563: PPUSH
21564: LD_STRING D5-Pow-2
21566: PPUSH
21567: CALL_OW 88
// if tmp > 1 then
21571: LD_VAR 0 3
21575: PUSH
21576: LD_INT 1
21578: GREATER
21579: IFFALSE 21597
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21581: LD_VAR 0 3
21585: PUSH
21586: LD_INT 2
21588: ARRAY
21589: PPUSH
21590: LD_STRING D5-Sol2-2
21592: PPUSH
21593: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21597: LD_EXP 58
21601: PPUSH
21602: LD_STRING D5-Pow-3
21604: PPUSH
21605: CALL_OW 88
// wait ( 0 0$1 ) ;
21609: LD_INT 35
21611: PPUSH
21612: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21616: LD_ADDR_VAR 0 3
21620: PUSH
21621: LD_EXP 18
21625: PUSH
21626: LD_INT 1
21628: ARRAY
21629: PUSH
21630: LD_EXP 18
21634: PUSH
21635: LD_INT 2
21637: ARRAY
21638: UNION
21639: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21640: LD_VAR 0 3
21644: PPUSH
21645: LD_INT 80
21647: PPUSH
21648: LD_INT 67
21650: PPUSH
21651: CALL_OW 114
// wait ( 0 0$2 ) ;
21655: LD_INT 70
21657: PPUSH
21658: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21662: LD_INT 79
21664: PPUSH
21665: LD_INT 72
21667: PPUSH
21668: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21672: LD_INT 35
21674: PPUSH
21675: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21679: LD_VAR 0 3
21683: PPUSH
21684: LD_INT 3
21686: PUSH
21687: LD_INT 24
21689: PUSH
21690: LD_INT 1000
21692: PUSH
21693: EMPTY
21694: LIST
21695: LIST
21696: PUSH
21697: EMPTY
21698: LIST
21699: LIST
21700: PPUSH
21701: CALL_OW 72
21705: IFFALSE 21672
// Say ( Powell , D5a-Pow-1 ) ;
21707: LD_EXP 58
21711: PPUSH
21712: LD_STRING D5a-Pow-1
21714: PPUSH
21715: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21719: LD_EXP 58
21723: PPUSH
21724: LD_STRING D5a-Pow-1a
21726: PPUSH
21727: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21731: LD_INT 10
21733: PPUSH
21734: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21738: LD_EXP 58
21742: PPUSH
21743: LD_STRING D5a-Pow-1b
21745: PPUSH
21746: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21750: LD_EXP 58
21754: PPUSH
21755: LD_STRING D5a-Pow-1c
21757: PPUSH
21758: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21762: LD_EXP 58
21766: PPUSH
21767: LD_STRING D5a-Pow-1d
21769: PPUSH
21770: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21774: LD_INT 35
21776: PPUSH
21777: CALL_OW 67
// if not HasTask ( tmp ) then
21781: LD_VAR 0 3
21785: PPUSH
21786: CALL_OW 314
21790: NOT
21791: IFFALSE 21808
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21793: LD_VAR 0 3
21797: PPUSH
21798: LD_INT 80
21800: PPUSH
21801: LD_INT 67
21803: PPUSH
21804: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21808: LD_VAR 0 3
21812: PPUSH
21813: LD_INT 24
21815: PUSH
21816: LD_INT 1
21818: PUSH
21819: EMPTY
21820: LIST
21821: LIST
21822: PPUSH
21823: CALL_OW 72
21827: NOT
21828: IFFALSE 21774
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21830: LD_ADDR_VAR 0 3
21834: PUSH
21835: LD_INT 22
21837: PUSH
21838: LD_INT 4
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: PUSH
21845: LD_INT 92
21847: PUSH
21848: LD_INT 60
21850: PUSH
21851: LD_INT 93
21853: PUSH
21854: LD_INT 10
21856: PUSH
21857: EMPTY
21858: LIST
21859: LIST
21860: LIST
21861: LIST
21862: PUSH
21863: LD_INT 3
21865: PUSH
21866: LD_INT 54
21868: PUSH
21869: EMPTY
21870: LIST
21871: PUSH
21872: EMPTY
21873: LIST
21874: LIST
21875: PUSH
21876: EMPTY
21877: LIST
21878: LIST
21879: LIST
21880: PPUSH
21881: CALL_OW 69
21885: PUSH
21886: LD_EXP 58
21890: DIFF
21891: ST_TO_ADDR
// if tmp then
21892: LD_VAR 0 3
21896: IFFALSE 21930
// for i in tmp do
21898: LD_ADDR_VAR 0 1
21902: PUSH
21903: LD_VAR 0 3
21907: PUSH
21908: FOR_IN
21909: IFFALSE 21928
// ComMoveXY ( i , 36 , 67 ) ;
21911: LD_VAR 0 1
21915: PPUSH
21916: LD_INT 36
21918: PPUSH
21919: LD_INT 67
21921: PPUSH
21922: CALL_OW 111
21926: GO 21908
21928: POP
21929: POP
// wait ( 0 0$3 ) ;
21930: LD_INT 105
21932: PPUSH
21933: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21937: LD_VAR 0 11
21941: PPUSH
21942: LD_STRING D6-Sol3-1
21944: PPUSH
21945: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21949: LD_EXP 58
21953: PPUSH
21954: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21958: LD_EXP 58
21962: PPUSH
21963: LD_STRING D6-Pow-1
21965: PPUSH
21966: CALL_OW 88
// tmp := [ ] ;
21970: LD_ADDR_VAR 0 3
21974: PUSH
21975: EMPTY
21976: ST_TO_ADDR
// for i = 1 to 2 do
21977: LD_ADDR_VAR 0 1
21981: PUSH
21982: DOUBLE
21983: LD_INT 1
21985: DEC
21986: ST_TO_ADDR
21987: LD_INT 2
21989: PUSH
21990: FOR_TO
21991: IFFALSE 22105
// begin uc_side := 8 ;
21993: LD_ADDR_OWVAR 20
21997: PUSH
21998: LD_INT 8
22000: ST_TO_ADDR
// uc_nation := 2 ;
22001: LD_ADDR_OWVAR 21
22005: PUSH
22006: LD_INT 2
22008: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22009: LD_INT 14
22011: PPUSH
22012: LD_INT 3
22014: PPUSH
22015: LD_INT 2
22017: PPUSH
22018: LD_INT 29
22020: PPUSH
22021: LD_INT 100
22023: PPUSH
22024: CALL 72069 0 5
// veh := CreateVehicle ;
22028: LD_ADDR_VAR 0 13
22032: PUSH
22033: CALL_OW 45
22037: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22038: LD_VAR 0 13
22042: PPUSH
22043: LD_INT 4
22045: PPUSH
22046: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22050: LD_VAR 0 13
22054: PPUSH
22055: LD_INT 99
22057: PPUSH
22058: LD_INT 83
22060: PPUSH
22061: LD_INT 6
22063: PPUSH
22064: LD_INT 0
22066: PPUSH
22067: CALL_OW 50
// wait ( 3 ) ;
22071: LD_INT 3
22073: PPUSH
22074: CALL_OW 67
// Connect ( veh ) ;
22078: LD_VAR 0 13
22082: PPUSH
22083: CALL 75124 0 1
// tmp := tmp ^ veh ;
22087: LD_ADDR_VAR 0 3
22091: PUSH
22092: LD_VAR 0 3
22096: PUSH
22097: LD_VAR 0 13
22101: ADD
22102: ST_TO_ADDR
// end ;
22103: GO 21990
22105: POP
22106: POP
// wait ( 0 0$1 ) ;
22107: LD_INT 35
22109: PPUSH
22110: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22114: LD_INT 99
22116: PPUSH
22117: LD_INT 83
22119: PPUSH
22120: LD_INT 1
22122: PPUSH
22123: LD_INT 10
22125: PPUSH
22126: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22130: LD_INT 99
22132: PPUSH
22133: LD_INT 83
22135: PPUSH
22136: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22140: LD_VAR 0 11
22144: PPUSH
22145: LD_STRING D6-Sol3-2
22147: PPUSH
22148: CALL_OW 88
// async ;
22152: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22153: LD_EXP 58
22157: PPUSH
22158: LD_STRING D6-Pow-2
22160: PPUSH
22161: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22165: LD_VAR 0 3
22169: PUSH
22170: LD_INT 1
22172: ARRAY
22173: PPUSH
22174: LD_VAR 0 9
22178: PPUSH
22179: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22183: LD_VAR 0 3
22187: PUSH
22188: LD_INT 2
22190: ARRAY
22191: PPUSH
22192: LD_INT 22
22194: PUSH
22195: LD_INT 4
22197: PUSH
22198: EMPTY
22199: LIST
22200: LIST
22201: PUSH
22202: LD_INT 21
22204: PUSH
22205: LD_INT 3
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: PUSH
22212: EMPTY
22213: LIST
22214: LIST
22215: PPUSH
22216: CALL_OW 69
22220: PPUSH
22221: LD_VAR 0 3
22225: PUSH
22226: LD_INT 2
22228: ARRAY
22229: PPUSH
22230: CALL_OW 74
22234: PPUSH
22235: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22239: LD_EXP 58
22243: PPUSH
22244: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22248: LD_INT 99
22250: PPUSH
22251: LD_INT 83
22253: PPUSH
22254: LD_INT 1
22256: PPUSH
22257: CALL_OW 331
// repeat wait ( 4 ) ;
22261: LD_INT 4
22263: PPUSH
22264: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22268: LD_VAR 0 3
22272: PUSH
22273: LD_INT 1
22275: ARRAY
22276: PPUSH
22277: CALL_OW 256
22281: PUSH
22282: LD_INT 1000
22284: LESS
22285: IFFALSE 22303
// SetLives ( tmp [ 1 ] , 1000 ) ;
22287: LD_VAR 0 3
22291: PUSH
22292: LD_INT 1
22294: ARRAY
22295: PPUSH
22296: LD_INT 1000
22298: PPUSH
22299: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22303: LD_INT 22
22305: PUSH
22306: LD_INT 4
22308: PUSH
22309: EMPTY
22310: LIST
22311: LIST
22312: PUSH
22313: LD_INT 30
22315: PUSH
22316: LD_INT 3
22318: PUSH
22319: EMPTY
22320: LIST
22321: LIST
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PPUSH
22327: CALL_OW 69
22331: PUSH
22332: LD_INT 0
22334: EQUAL
22335: IFFALSE 22261
// sync ;
22337: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22338: LD_EXP 58
22342: PPUSH
22343: LD_STRING D6a-Pow-1
22345: PPUSH
22346: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22350: LD_VAR 0 11
22354: PPUSH
22355: LD_STRING D6a-Sol3-1
22357: PPUSH
22358: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22362: LD_EXP 58
22366: PPUSH
22367: LD_STRING D6a-Pow-2
22369: PPUSH
22370: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22374: LD_VAR 0 11
22378: PPUSH
22379: LD_STRING D6a-Sol3-2
22381: PPUSH
22382: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22386: LD_EXP 58
22390: PPUSH
22391: LD_STRING D6a-Pow-3
22393: PPUSH
22394: CALL_OW 88
// powellCenterCameraMode := true ;
22398: LD_ADDR_EXP 20
22402: PUSH
22403: LD_INT 1
22405: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22406: LD_ADDR_VAR 0 1
22410: PUSH
22411: LD_INT 22
22413: PUSH
22414: LD_INT 8
22416: PUSH
22417: EMPTY
22418: LIST
22419: LIST
22420: PUSH
22421: LD_INT 25
22423: PUSH
22424: LD_INT 2
22426: PUSH
22427: EMPTY
22428: LIST
22429: LIST
22430: PUSH
22431: EMPTY
22432: LIST
22433: LIST
22434: PPUSH
22435: CALL_OW 69
22439: PUSH
22440: FOR_IN
22441: IFFALSE 22496
// begin SetTag ( i , 1 ) ;
22443: LD_VAR 0 1
22447: PPUSH
22448: LD_INT 1
22450: PPUSH
22451: CALL_OW 109
// ComExitBuilding ( i ) ;
22455: LD_VAR 0 1
22459: PPUSH
22460: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22464: LD_VAR 0 1
22468: PPUSH
22469: LD_INT 35
22471: PPUSH
22472: LD_INT 6
22474: PPUSH
22475: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22479: LD_VAR 0 1
22483: PPUSH
22484: LD_INT 53
22486: PPUSH
22487: LD_INT 4
22489: PPUSH
22490: CALL_OW 171
// end ;
22494: GO 22440
22496: POP
22497: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22498: LD_ADDR_VAR 0 3
22502: PUSH
22503: LD_INT 22
22505: PUSH
22506: LD_INT 4
22508: PUSH
22509: EMPTY
22510: LIST
22511: LIST
22512: PUSH
22513: LD_INT 21
22515: PUSH
22516: LD_INT 2
22518: PUSH
22519: EMPTY
22520: LIST
22521: LIST
22522: PUSH
22523: LD_INT 3
22525: PUSH
22526: LD_INT 34
22528: PUSH
22529: LD_INT 12
22531: PUSH
22532: EMPTY
22533: LIST
22534: LIST
22535: PUSH
22536: EMPTY
22537: LIST
22538: LIST
22539: PUSH
22540: EMPTY
22541: LIST
22542: LIST
22543: LIST
22544: PPUSH
22545: CALL_OW 69
22549: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22550: LD_EXP 58
22554: PPUSH
22555: LD_VAR 0 3
22559: PPUSH
22560: LD_EXP 58
22564: PPUSH
22565: CALL_OW 74
22569: PPUSH
22570: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22574: LD_EXP 58
22578: PPUSH
22579: LD_INT 100
22581: PPUSH
22582: LD_INT 88
22584: PPUSH
22585: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22589: LD_EXP 58
22593: PPUSH
22594: LD_INT 100
22596: PPUSH
22597: LD_INT 75
22599: PPUSH
22600: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22604: LD_EXP 58
22608: PPUSH
22609: LD_INT 88
22611: PPUSH
22612: LD_INT 53
22614: PPUSH
22615: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22619: LD_INT 8
22621: PPUSH
22622: LD_EXP 58
22626: PPUSH
22627: CALL_OW 471
// repeat wait ( 3 ) ;
22631: LD_INT 3
22633: PPUSH
22634: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22638: LD_INT 22
22640: PUSH
22641: LD_INT 4
22643: PUSH
22644: EMPTY
22645: LIST
22646: LIST
22647: PUSH
22648: LD_INT 92
22650: PUSH
22651: LD_INT 100
22653: PUSH
22654: LD_INT 75
22656: PUSH
22657: LD_INT 6
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: LIST
22664: LIST
22665: PUSH
22666: EMPTY
22667: LIST
22668: LIST
22669: PPUSH
22670: CALL_OW 69
22674: IFFALSE 22631
// async ;
22676: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22677: LD_EXP 58
22681: PPUSH
22682: LD_STRING D6b-Pow-1
22684: PPUSH
22685: CALL_OW 88
// repeat wait ( 3 ) ;
22689: LD_INT 3
22691: PPUSH
22692: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22696: LD_EXP 58
22700: PPUSH
22701: CALL_OW 310
22705: PPUSH
22706: CALL_OW 256
22710: PUSH
22711: LD_INT 1000
22713: LESS
22714: IFFALSE 22733
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22716: LD_EXP 58
22720: PPUSH
22721: CALL_OW 310
22725: PPUSH
22726: LD_INT 1000
22728: PPUSH
22729: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22733: LD_EXP 58
22737: PPUSH
22738: CALL_OW 256
22742: PUSH
22743: LD_INT 1000
22745: LESS
22746: IFFALSE 22760
// SetLives ( Powell , 1000 ) ;
22748: LD_EXP 58
22752: PPUSH
22753: LD_INT 1000
22755: PPUSH
22756: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22760: LD_EXP 58
22764: PPUSH
22765: LD_EXP 63
22769: PPUSH
22770: CALL_OW 296
22774: PUSH
22775: LD_INT 5
22777: LESS
22778: PUSH
22779: LD_EXP 58
22783: PPUSH
22784: CALL_OW 310
22788: PPUSH
22789: LD_EXP 63
22793: PPUSH
22794: CALL_OW 296
22798: PUSH
22799: LD_INT 5
22801: LESS
22802: OR
22803: IFFALSE 22822
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22805: LD_EXP 58
22809: PPUSH
22810: CALL_OW 310
22814: PPUSH
22815: LD_INT 100
22817: PPUSH
22818: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22822: LD_EXP 58
22826: PPUSH
22827: CALL_OW 310
22831: NOT
22832: IFFALSE 22689
// DoNotAttack ( 8 , powellBomb ) ;
22834: LD_INT 8
22836: PPUSH
22837: LD_EXP 63
22841: PPUSH
22842: CALL_OW 471
// game_speed := 4 ;
22846: LD_ADDR_OWVAR 65
22850: PUSH
22851: LD_INT 4
22853: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22854: LD_EXP 58
22858: PPUSH
22859: LD_STRING D6b-Pow-1a
22861: PPUSH
22862: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22866: LD_EXP 58
22870: PPUSH
22871: LD_EXP 63
22875: PPUSH
22876: CALL_OW 180
// sync ;
22880: SYNC
// repeat wait ( 0 0$1 ) ;
22881: LD_INT 35
22883: PPUSH
22884: CALL_OW 67
// until IsInUnit ( Powell ) ;
22888: LD_EXP 58
22892: PPUSH
22893: CALL_OW 310
22897: IFFALSE 22881
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22899: LD_INT 8
22901: PPUSH
22902: LD_EXP 58
22906: PPUSH
22907: CALL_OW 310
22911: PPUSH
22912: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22916: LD_EXP 58
22920: PPUSH
22921: LD_INT 91
22923: PPUSH
22924: LD_INT 44
22926: PPUSH
22927: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22931: LD_EXP 58
22935: PPUSH
22936: LD_INT 96
22938: PPUSH
22939: LD_INT 44
22941: PPUSH
22942: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22946: LD_EXP 58
22950: PPUSH
22951: LD_INT 96
22953: PPUSH
22954: LD_INT 41
22956: PPUSH
22957: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22961: LD_EXP 58
22965: PPUSH
22966: LD_INT 92
22968: PPUSH
22969: LD_INT 39
22971: PPUSH
22972: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22976: LD_EXP 58
22980: PPUSH
22981: LD_INT 88
22983: PPUSH
22984: LD_INT 41
22986: PPUSH
22987: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22991: LD_EXP 58
22995: PPUSH
22996: LD_INT 91
22998: PPUSH
22999: LD_INT 44
23001: PPUSH
23002: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23006: LD_EXP 58
23010: PPUSH
23011: LD_INT 96
23013: PPUSH
23014: LD_INT 44
23016: PPUSH
23017: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23021: LD_EXP 58
23025: PPUSH
23026: LD_INT 96
23028: PPUSH
23029: LD_INT 41
23031: PPUSH
23032: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23036: LD_EXP 58
23040: PPUSH
23041: LD_INT 92
23043: PPUSH
23044: LD_INT 39
23046: PPUSH
23047: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23051: LD_EXP 58
23055: PPUSH
23056: LD_INT 88
23058: PPUSH
23059: LD_INT 41
23061: PPUSH
23062: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23066: LD_EXP 58
23070: PPUSH
23071: LD_INT 91
23073: PPUSH
23074: LD_INT 44
23076: PPUSH
23077: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23081: LD_EXP 58
23085: PPUSH
23086: LD_INT 93
23088: PPUSH
23089: LD_INT 39
23091: PPUSH
23092: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23096: LD_EXP 58
23100: PPUSH
23101: LD_INT 93
23103: PPUSH
23104: LD_INT 36
23106: PPUSH
23107: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23111: LD_INT 122
23113: PPUSH
23114: CALL_OW 67
// game_speed := 4 ;
23118: LD_ADDR_OWVAR 65
23122: PUSH
23123: LD_INT 4
23125: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23126: LD_EXP 58
23130: PPUSH
23131: LD_STRING D6b-Pow-1b
23133: PPUSH
23134: CALL_OW 88
// tmp := [ ] ;
23138: LD_ADDR_VAR 0 3
23142: PUSH
23143: EMPTY
23144: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23145: LD_ADDR_VAR 0 5
23149: PUSH
23150: LD_INT 78
23152: PUSH
23153: LD_INT 47
23155: PUSH
23156: EMPTY
23157: LIST
23158: LIST
23159: PUSH
23160: LD_INT 106
23162: PUSH
23163: LD_INT 53
23165: PUSH
23166: EMPTY
23167: LIST
23168: LIST
23169: PUSH
23170: EMPTY
23171: LIST
23172: LIST
23173: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23174: LD_ADDR_VAR 0 1
23178: PUSH
23179: LD_INT 22
23181: PUSH
23182: LD_INT 8
23184: PUSH
23185: EMPTY
23186: LIST
23187: LIST
23188: PUSH
23189: LD_INT 21
23191: PUSH
23192: LD_INT 3
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 92
23201: PUSH
23202: LD_INT 90
23204: PUSH
23205: LD_INT 52
23207: PUSH
23208: LD_INT 12
23210: PUSH
23211: EMPTY
23212: LIST
23213: LIST
23214: LIST
23215: LIST
23216: PUSH
23217: EMPTY
23218: LIST
23219: LIST
23220: LIST
23221: PPUSH
23222: CALL_OW 69
23226: PUSH
23227: FOR_IN
23228: IFFALSE 23253
// tmp := tmp ^ UnitsInside ( i ) ;
23230: LD_ADDR_VAR 0 3
23234: PUSH
23235: LD_VAR 0 3
23239: PUSH
23240: LD_VAR 0 1
23244: PPUSH
23245: CALL_OW 313
23249: ADD
23250: ST_TO_ADDR
23251: GO 23227
23253: POP
23254: POP
// for i in tmp do
23255: LD_ADDR_VAR 0 1
23259: PUSH
23260: LD_VAR 0 3
23264: PUSH
23265: FOR_IN
23266: IFFALSE 23428
// begin dist := 9999 ;
23268: LD_ADDR_VAR 0 8
23272: PUSH
23273: LD_INT 9999
23275: ST_TO_ADDR
// _xy := [ ] ;
23276: LD_ADDR_VAR 0 7
23280: PUSH
23281: EMPTY
23282: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23283: LD_VAR 0 1
23287: PPUSH
23288: LD_INT 1
23290: PPUSH
23291: CALL_OW 109
// ComExitBuilding ( i ) ;
23295: LD_VAR 0 1
23299: PPUSH
23300: CALL_OW 122
// for j in xy do
23304: LD_ADDR_VAR 0 2
23308: PUSH
23309: LD_VAR 0 5
23313: PUSH
23314: FOR_IN
23315: IFFALSE 23397
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23317: LD_VAR 0 1
23321: PPUSH
23322: LD_VAR 0 2
23326: PUSH
23327: LD_INT 1
23329: ARRAY
23330: PPUSH
23331: LD_VAR 0 2
23335: PUSH
23336: LD_INT 2
23338: ARRAY
23339: PPUSH
23340: CALL_OW 297
23344: PUSH
23345: LD_VAR 0 8
23349: LESS
23350: IFFALSE 23395
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23352: LD_ADDR_VAR 0 8
23356: PUSH
23357: LD_VAR 0 1
23361: PPUSH
23362: LD_VAR 0 2
23366: PUSH
23367: LD_INT 1
23369: ARRAY
23370: PPUSH
23371: LD_VAR 0 2
23375: PUSH
23376: LD_INT 2
23378: ARRAY
23379: PPUSH
23380: CALL_OW 297
23384: ST_TO_ADDR
// _xy := j ;
23385: LD_ADDR_VAR 0 7
23389: PUSH
23390: LD_VAR 0 2
23394: ST_TO_ADDR
// end ;
23395: GO 23314
23397: POP
23398: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23399: LD_VAR 0 1
23403: PPUSH
23404: LD_VAR 0 7
23408: PUSH
23409: LD_INT 1
23411: ARRAY
23412: PPUSH
23413: LD_VAR 0 7
23417: PUSH
23418: LD_INT 2
23420: ARRAY
23421: PPUSH
23422: CALL_OW 171
// end ;
23426: GO 23265
23428: POP
23429: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23430: LD_ADDR_VAR 0 4
23434: PUSH
23435: LD_VAR 0 3
23439: PPUSH
23440: LD_INT 26
23442: PUSH
23443: LD_INT 1
23445: PUSH
23446: EMPTY
23447: LIST
23448: LIST
23449: PUSH
23450: LD_INT 25
23452: PUSH
23453: LD_INT 1
23455: PUSH
23456: EMPTY
23457: LIST
23458: LIST
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PPUSH
23464: CALL_OW 72
23468: ST_TO_ADDR
// if tmp2 < 2 then
23469: LD_VAR 0 4
23473: PUSH
23474: LD_INT 2
23476: LESS
23477: IFFALSE 23546
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23479: LD_ADDR_VAR 0 4
23483: PUSH
23484: LD_INT 22
23486: PUSH
23487: LD_INT 8
23489: PUSH
23490: EMPTY
23491: LIST
23492: LIST
23493: PUSH
23494: LD_INT 26
23496: PUSH
23497: LD_INT 1
23499: PUSH
23500: EMPTY
23501: LIST
23502: LIST
23503: PUSH
23504: LD_INT 3
23506: PUSH
23507: LD_INT 25
23509: PUSH
23510: LD_INT 15
23512: PUSH
23513: EMPTY
23514: LIST
23515: LIST
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: LIST
23525: PPUSH
23526: CALL_OW 69
23530: PUSH
23531: LD_EXP 60
23535: PUSH
23536: LD_EXP 61
23540: PUSH
23541: EMPTY
23542: LIST
23543: LIST
23544: DIFF
23545: ST_TO_ADDR
// if tmp2 then
23546: LD_VAR 0 4
23550: IFFALSE 23568
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23552: LD_VAR 0 4
23556: PUSH
23557: LD_INT 1
23559: ARRAY
23560: PPUSH
23561: LD_STRING D6b-ArSol1-1
23563: PPUSH
23564: CALL_OW 88
// async ;
23568: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23569: LD_EXP 58
23573: PPUSH
23574: LD_STRING D6b-Pow-2
23576: PPUSH
23577: CALL_OW 88
// wait ( 0 0$1 ) ;
23581: LD_INT 35
23583: PPUSH
23584: CALL_OW 67
// if tmp2 > 1 then
23588: LD_VAR 0 4
23592: PUSH
23593: LD_INT 1
23595: GREATER
23596: IFFALSE 23614
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23598: LD_VAR 0 4
23602: PUSH
23603: LD_INT 2
23605: ARRAY
23606: PPUSH
23607: LD_STRING D6b-ArSol2-1
23609: PPUSH
23610: CALL_OW 88
// sync ;
23614: SYNC
// repeat wait ( 5 ) ;
23615: LD_INT 5
23617: PPUSH
23618: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23622: LD_INT 93
23624: PPUSH
23625: LD_INT 36
23627: PPUSH
23628: CALL_OW 428
23632: PPUSH
23633: CALL_OW 255
23637: PUSH
23638: LD_INT 4
23640: EQUAL
23641: IFFALSE 23615
// DialogueOn ;
23643: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23647: LD_INT 10
23649: PPUSH
23650: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23654: LD_EXP 58
23658: PPUSH
23659: LD_STRING D6b-Pow-2a
23661: PPUSH
23662: CALL_OW 88
// DialogueOff ;
23666: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23670: LD_EXP 58
23674: PPUSH
23675: CALL_OW 310
23679: PPUSH
23680: LD_INT 332
23682: PPUSH
23683: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23687: LD_INT 93
23689: PPUSH
23690: LD_INT 35
23692: PPUSH
23693: LD_INT 1
23695: PPUSH
23696: LD_INT 6
23698: NEG
23699: PPUSH
23700: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23704: LD_INT 35
23706: PPUSH
23707: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23711: LD_INT 332
23713: PPUSH
23714: CALL_OW 256
23718: PUSH
23719: LD_INT 1000
23721: LESS
23722: PUSH
23723: LD_INT 332
23725: PPUSH
23726: CALL_OW 300
23730: AND
23731: IFFALSE 23743
// SetLives ( kozlov_fac , 0 ) ;
23733: LD_INT 332
23735: PPUSH
23736: LD_INT 0
23738: PPUSH
23739: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23743: LD_INT 332
23745: PPUSH
23746: CALL_OW 301
23750: PUSH
23751: LD_EXP 58
23755: PPUSH
23756: CALL_OW 301
23760: OR
23761: IFFALSE 23704
// game_speed := 4 ;
23763: LD_ADDR_OWVAR 65
23767: PUSH
23768: LD_INT 4
23770: ST_TO_ADDR
// powellCenterCameraMode := false ;
23771: LD_ADDR_EXP 20
23775: PUSH
23776: LD_INT 0
23778: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23779: LD_ADDR_VAR 0 1
23783: PUSH
23784: LD_VAR 0 3
23788: PUSH
23789: LD_INT 22
23791: PUSH
23792: LD_INT 8
23794: PUSH
23795: EMPTY
23796: LIST
23797: LIST
23798: PUSH
23799: LD_INT 25
23801: PUSH
23802: LD_INT 2
23804: PUSH
23805: EMPTY
23806: LIST
23807: LIST
23808: PUSH
23809: EMPTY
23810: LIST
23811: LIST
23812: PPUSH
23813: CALL_OW 69
23817: UNION
23818: PUSH
23819: FOR_IN
23820: IFFALSE 23836
// SetTag ( i , 0 ) ;
23822: LD_VAR 0 1
23826: PPUSH
23827: LD_INT 0
23829: PPUSH
23830: CALL_OW 109
23834: GO 23819
23836: POP
23837: POP
// wait ( 0 0$3 ) ;
23838: LD_INT 105
23840: PPUSH
23841: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23845: LD_INT 93
23847: PPUSH
23848: LD_INT 35
23850: PPUSH
23851: LD_INT 1
23853: PPUSH
23854: CALL_OW 331
// DialogueOn ;
23858: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23862: LD_VAR 0 11
23866: PPUSH
23867: LD_STRING D6c-Sol3-1
23869: PPUSH
23870: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23874: LD_INT 10
23876: PPUSH
23877: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23881: LD_EXP 39
23885: PPUSH
23886: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23890: LD_EXP 39
23894: PPUSH
23895: LD_STRING D6c-JMM-1
23897: PPUSH
23898: CALL_OW 88
// if Cyrus then
23902: LD_EXP 45
23906: IFFALSE 23920
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23908: LD_EXP 45
23912: PPUSH
23913: LD_STRING D6c-Cyrus-1
23915: PPUSH
23916: CALL_OW 88
// if Bobby then
23920: LD_EXP 44
23924: IFFALSE 23938
// Say ( Bobby , D6c-Bobby-1 ) ;
23926: LD_EXP 44
23930: PPUSH
23931: LD_STRING D6c-Bobby-1
23933: PPUSH
23934: CALL_OW 88
// if Cornel then
23938: LD_EXP 50
23942: IFFALSE 23956
// Say ( Cornel , D6c-Corn-1 ) ;
23944: LD_EXP 50
23948: PPUSH
23949: LD_STRING D6c-Corn-1
23951: PPUSH
23952: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23956: LD_ADDR_VAR 0 4
23960: PUSH
23961: LD_INT 2
23963: PUSH
23964: LD_INT 22
23966: PUSH
23967: LD_INT 1
23969: PUSH
23970: EMPTY
23971: LIST
23972: LIST
23973: PUSH
23974: LD_INT 22
23976: PUSH
23977: LD_INT 4
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: PUSH
23984: EMPTY
23985: LIST
23986: LIST
23987: LIST
23988: PUSH
23989: LD_INT 26
23991: PUSH
23992: LD_INT 1
23994: PUSH
23995: EMPTY
23996: LIST
23997: LIST
23998: PUSH
23999: LD_INT 3
24001: PUSH
24002: LD_INT 25
24004: PUSH
24005: LD_INT 16
24007: PUSH
24008: EMPTY
24009: LIST
24010: LIST
24011: PUSH
24012: LD_INT 25
24014: PUSH
24015: LD_INT 12
24017: PUSH
24018: EMPTY
24019: LIST
24020: LIST
24021: PUSH
24022: EMPTY
24023: LIST
24024: LIST
24025: LIST
24026: PUSH
24027: EMPTY
24028: LIST
24029: LIST
24030: LIST
24031: PPUSH
24032: CALL_OW 69
24036: PUSH
24037: LD_VAR 0 11
24041: PUSH
24042: LD_EXP 39
24046: UNION
24047: PUSH
24048: LD_EXP 59
24052: UNION
24053: PUSH
24054: EMPTY
24055: LIST
24056: DIFF
24057: ST_TO_ADDR
// if tmp2 then
24058: LD_VAR 0 4
24062: IFFALSE 24080
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24064: LD_VAR 0 4
24068: PUSH
24069: LD_INT 1
24071: ARRAY
24072: PPUSH
24073: LD_STRING D6c-Sol1-1
24075: PPUSH
24076: CALL_OW 88
// if Lisa then
24080: LD_EXP 42
24084: IFFALSE 24098
// Say ( Lisa , D6c-Lisa-1 ) ;
24086: LD_EXP 42
24090: PPUSH
24091: LD_STRING D6c-Lisa-1
24093: PPUSH
24094: CALL_OW 88
// if Gary then
24098: LD_EXP 51
24102: IFFALSE 24116
// Say ( Gary , D6c-Gary-1 ) ;
24104: LD_EXP 51
24108: PPUSH
24109: LD_STRING D6c-Gary-1
24111: PPUSH
24112: CALL_OW 88
// if Donaldson then
24116: LD_EXP 43
24120: IFFALSE 24134
// Say ( Donaldson , D6c-Don-1 ) ;
24122: LD_EXP 43
24126: PPUSH
24127: LD_STRING D6c-Don-1
24129: PPUSH
24130: CALL_OW 88
// if tmp2 > 1 then
24134: LD_VAR 0 4
24138: PUSH
24139: LD_INT 1
24141: GREATER
24142: IFFALSE 24160
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24144: LD_VAR 0 4
24148: PUSH
24149: LD_INT 2
24151: ARRAY
24152: PPUSH
24153: LD_STRING D6c-Sol2-1
24155: PPUSH
24156: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24160: LD_VAR 0 11
24164: PPUSH
24165: LD_STRING D6c-Sol3-2
24167: PPUSH
24168: CALL_OW 88
// dwait ( 0 0$1 ) ;
24172: LD_INT 35
24174: PPUSH
24175: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24179: LD_EXP 39
24183: PPUSH
24184: LD_STRING D6c-JMM-2
24186: PPUSH
24187: CALL_OW 88
// DialogueOff ;
24191: CALL_OW 7
// Video ( false ) ;
24195: LD_INT 0
24197: PPUSH
24198: CALL 107796 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24202: LD_INT 22
24204: PUSH
24205: LD_INT 4
24207: PUSH
24208: EMPTY
24209: LIST
24210: LIST
24211: PPUSH
24212: CALL_OW 69
24216: PPUSH
24217: LD_INT 1
24219: PPUSH
24220: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24224: LD_INT 4
24226: PPUSH
24227: LD_INT 4
24229: PPUSH
24230: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24234: LD_ADDR_VAR 0 1
24238: PUSH
24239: LD_INT 4
24241: PPUSH
24242: LD_INT 1
24244: PPUSH
24245: LD_INT 2
24247: PPUSH
24248: CALL 64957 0 3
24252: PUSH
24253: FOR_IN
24254: IFFALSE 24291
// if GetTech ( i , 1 ) <> state_researched then
24256: LD_VAR 0 1
24260: PPUSH
24261: LD_INT 1
24263: PPUSH
24264: CALL_OW 321
24268: PUSH
24269: LD_INT 2
24271: NONEQUAL
24272: IFFALSE 24289
// SetTech ( i , 1 , state_researched ) ;
24274: LD_VAR 0 1
24278: PPUSH
24279: LD_INT 1
24281: PPUSH
24282: LD_INT 2
24284: PPUSH
24285: CALL_OW 322
24289: GO 24253
24291: POP
24292: POP
// missionStage := 6 ;
24293: LD_ADDR_EXP 15
24297: PUSH
24298: LD_INT 6
24300: ST_TO_ADDR
// activeAttacks := true ;
24301: LD_ADDR_EXP 16
24305: PUSH
24306: LD_INT 1
24308: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24309: LD_STRING M2
24311: PPUSH
24312: CALL_OW 337
// SaveForQuickRestart ;
24316: CALL_OW 22
// wait ( 0 0$40 ) ;
24320: LD_INT 1400
24322: PPUSH
24323: CALL_OW 67
// DialogueOn ;
24327: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24331: LD_EXP 62
24335: PPUSH
24336: LD_STRING D7-Friend-1
24338: PPUSH
24339: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24343: LD_EXP 39
24347: PPUSH
24348: LD_STRING D7-JMM-1
24350: PPUSH
24351: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24355: LD_EXP 62
24359: PPUSH
24360: LD_STRING D7-Friend-2
24362: PPUSH
24363: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24367: LD_EXP 39
24371: PPUSH
24372: LD_STRING D7-JMM-2
24374: PPUSH
24375: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24379: LD_EXP 62
24383: PPUSH
24384: LD_STRING D7-Friend-3
24386: PPUSH
24387: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24391: LD_EXP 39
24395: PPUSH
24396: LD_STRING D7-JMM-3
24398: PPUSH
24399: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24403: LD_EXP 62
24407: PPUSH
24408: LD_STRING D7-Friend-4
24410: PPUSH
24411: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24415: LD_EXP 39
24419: PPUSH
24420: LD_STRING D7-JMM-4
24422: PPUSH
24423: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24427: LD_EXP 62
24431: PPUSH
24432: LD_STRING D7-Friend-5
24434: PPUSH
24435: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24439: LD_EXP 39
24443: PPUSH
24444: LD_STRING D7-JMM-5
24446: PPUSH
24447: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24451: LD_EXP 62
24455: PPUSH
24456: LD_STRING D7-Friend-6
24458: PPUSH
24459: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24463: LD_EXP 39
24467: PPUSH
24468: LD_STRING D7-JMM-6
24470: PPUSH
24471: CALL_OW 88
// DialogueOff ;
24475: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24479: LD_STRING Mlegion
24481: PPUSH
24482: CALL_OW 337
// RebuildKozlovFactory ;
24486: CALL 4840 0 0
// end ;
24490: PPOPN 13
24492: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24493: LD_EXP 20
24497: PUSH
24498: LD_EXP 58
24502: PPUSH
24503: CALL_OW 300
24507: AND
24508: IFFALSE 24550
24510: GO 24512
24512: DISABLE
// begin enable ;
24513: ENABLE
// if IsInUnit ( Powell ) then
24514: LD_EXP 58
24518: PPUSH
24519: CALL_OW 310
24523: IFFALSE 24541
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24525: LD_EXP 58
24529: PPUSH
24530: CALL_OW 310
24534: PPUSH
24535: CALL_OW 85
24539: GO 24550
// CenterOnUnits ( Powell ) ;
24541: LD_EXP 58
24545: PPUSH
24546: CALL_OW 85
// end ;
24550: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24551: LD_INT 22
24553: PUSH
24554: LD_INT 8
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: PUSH
24561: LD_INT 34
24563: PUSH
24564: LD_INT 48
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: PUSH
24571: EMPTY
24572: LIST
24573: LIST
24574: PPUSH
24575: CALL_OW 69
24579: IFFALSE 24853
24581: GO 24583
24583: DISABLE
24584: LD_INT 0
24586: PPUSH
24587: PPUSH
// begin if missionStage < 9 then
24588: LD_EXP 15
24592: PUSH
24593: LD_INT 9
24595: LESS
24596: IFFALSE 24606
// missionStage := 9 ;
24598: LD_ADDR_EXP 15
24602: PUSH
24603: LD_INT 9
24605: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24606: LD_ADDR_VAR 0 1
24610: PUSH
24611: LD_INT 22
24613: PUSH
24614: LD_INT 8
24616: PUSH
24617: EMPTY
24618: LIST
24619: LIST
24620: PUSH
24621: LD_INT 34
24623: PUSH
24624: LD_INT 48
24626: PUSH
24627: EMPTY
24628: LIST
24629: LIST
24630: PUSH
24631: EMPTY
24632: LIST
24633: LIST
24634: PPUSH
24635: CALL_OW 69
24639: PUSH
24640: LD_INT 1
24642: ARRAY
24643: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24644: LD_INT 175
24646: PPUSH
24647: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24651: LD_EXP 12
24655: PUSH
24656: LD_EXP 3
24660: PUSH
24661: LD_INT 0
24663: PUSH
24664: LD_INT 2
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: IN
24671: OR
24672: IFFALSE 24695
// target := [ 68 , 108 , 1 ] else
24674: LD_ADDR_VAR 0 2
24678: PUSH
24679: LD_INT 68
24681: PUSH
24682: LD_INT 108
24684: PUSH
24685: LD_INT 1
24687: PUSH
24688: EMPTY
24689: LIST
24690: LIST
24691: LIST
24692: ST_TO_ADDR
24693: GO 24714
// target := [ 181 , 88 , 2 ] ;
24695: LD_ADDR_VAR 0 2
24699: PUSH
24700: LD_INT 181
24702: PUSH
24703: LD_INT 88
24705: PUSH
24706: LD_INT 2
24708: PUSH
24709: EMPTY
24710: LIST
24711: LIST
24712: LIST
24713: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24714: LD_VAR 0 1
24718: PPUSH
24719: LD_VAR 0 2
24723: PUSH
24724: LD_INT 1
24726: ARRAY
24727: PPUSH
24728: LD_VAR 0 2
24732: PUSH
24733: LD_INT 2
24735: ARRAY
24736: PPUSH
24737: CALL_OW 176
// if target [ 3 ] = 1 then
24741: LD_VAR 0 2
24745: PUSH
24746: LD_INT 3
24748: ARRAY
24749: PUSH
24750: LD_INT 1
24752: EQUAL
24753: IFFALSE 24769
// SayRadio ( Kurt , D12-Kurt-1 ) else
24755: LD_EXP 60
24759: PPUSH
24760: LD_STRING D12-Kurt-1
24762: PPUSH
24763: CALL_OW 94
24767: GO 24793
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24769: LD_EXP 60
24773: PPUSH
24774: LD_STRING D12a-Kurt-1
24776: PPUSH
24777: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24781: LD_EXP 74
24785: PPUSH
24786: LD_STRING D12a-Roth-1
24788: PPUSH
24789: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24793: LD_INT 350
24795: PPUSH
24796: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24800: LD_VAR 0 1
24804: PPUSH
24805: LD_INT 22
24807: PUSH
24808: LD_INT 8
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: LD_INT 23
24817: PUSH
24818: LD_INT 2
24820: PUSH
24821: EMPTY
24822: LIST
24823: LIST
24824: PUSH
24825: LD_INT 30
24827: PUSH
24828: LD_INT 3
24830: PUSH
24831: EMPTY
24832: LIST
24833: LIST
24834: PUSH
24835: EMPTY
24836: LIST
24837: LIST
24838: LIST
24839: PPUSH
24840: CALL_OW 69
24844: PUSH
24845: LD_INT 1
24847: ARRAY
24848: PPUSH
24849: CALL_OW 228
// end ;
24853: PPOPN 2
24855: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24856: LD_EXP 60
24860: PPUSH
24861: CALL_OW 256
24865: PUSH
24866: LD_INT 999
24868: LESS
24869: PUSH
24870: LD_INT 22
24872: PUSH
24873: LD_INT 8
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: PUSH
24880: LD_INT 21
24882: PUSH
24883: LD_INT 1
24885: PUSH
24886: EMPTY
24887: LIST
24888: LIST
24889: PUSH
24890: LD_INT 23
24892: PUSH
24893: LD_INT 2
24895: PUSH
24896: EMPTY
24897: LIST
24898: LIST
24899: PUSH
24900: EMPTY
24901: LIST
24902: LIST
24903: LIST
24904: PPUSH
24905: CALL_OW 69
24909: PUSH
24910: LD_INT 9
24912: PUSH
24913: LD_INT 8
24915: PUSH
24916: LD_INT 7
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: LIST
24923: PUSH
24924: LD_OWVAR 67
24928: ARRAY
24929: LESSEQUAL
24930: OR
24931: PUSH
24932: LD_INT 22
24934: PUSH
24935: LD_INT 8
24937: PUSH
24938: EMPTY
24939: LIST
24940: LIST
24941: PUSH
24942: LD_INT 34
24944: PUSH
24945: LD_INT 48
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: PUSH
24952: EMPTY
24953: LIST
24954: LIST
24955: PPUSH
24956: CALL_OW 69
24960: NOT
24961: AND
24962: PUSH
24963: LD_EXP 60
24967: PPUSH
24968: CALL_OW 302
24972: AND
24973: PUSH
24974: LD_INT 5
24976: PPUSH
24977: LD_INT 22
24979: PUSH
24980: LD_INT 1
24982: PUSH
24983: EMPTY
24984: LIST
24985: LIST
24986: PPUSH
24987: CALL_OW 70
24991: AND
24992: IFFALSE 25682
24994: GO 24996
24996: DISABLE
24997: LD_INT 0
24999: PPUSH
25000: PPUSH
25001: PPUSH
// begin DialogueOn ;
25002: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25006: LD_EXP 39
25010: PPUSH
25011: LD_STRING D13-JMM-1
25013: PPUSH
25014: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25018: LD_EXP 60
25022: PPUSH
25023: LD_STRING D13-Kurt-1
25025: PPUSH
25026: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25030: LD_EXP 39
25034: PPUSH
25035: LD_STRING D13-JMM-2
25037: PPUSH
25038: CALL_OW 88
// if FakeInfo then
25042: LD_EXP 12
25046: IFFALSE 25066
// begin Say ( Kurt , D13-Kurt-2 ) ;
25048: LD_EXP 60
25052: PPUSH
25053: LD_STRING D13-Kurt-2
25055: PPUSH
25056: CALL_OW 88
// DialogueOff ;
25060: CALL_OW 7
// exit ;
25064: GO 25682
// end ; if not KurtStatus then
25066: LD_EXP 3
25070: NOT
25071: IFFALSE 25087
// Say ( Kurt , D13-Kurt-2b ) else
25073: LD_EXP 60
25077: PPUSH
25078: LD_STRING D13-Kurt-2b
25080: PPUSH
25081: CALL_OW 88
25085: GO 25099
// Say ( Kurt , D13-Kurt-2a ) ;
25087: LD_EXP 60
25091: PPUSH
25092: LD_STRING D13-Kurt-2a
25094: PPUSH
25095: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25099: LD_EXP 39
25103: PPUSH
25104: LD_STRING D13-JMM-3
25106: PPUSH
25107: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25111: LD_EXP 60
25115: PPUSH
25116: LD_STRING D13-Kurt-3
25118: PPUSH
25119: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25123: LD_EXP 39
25127: PPUSH
25128: LD_STRING D13-JMM-4
25130: PPUSH
25131: CALL_OW 88
// DialogueOff ;
25135: CALL_OW 7
// MC_Kill ( 3 ) ;
25139: LD_INT 3
25141: PPUSH
25142: CALL 35090 0 1
// KillUnit ( Kozlov ) ;
25146: LD_EXP 61
25150: PPUSH
25151: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25155: LD_ADDR_VAR 0 1
25159: PUSH
25160: LD_INT 22
25162: PUSH
25163: LD_INT 8
25165: PUSH
25166: EMPTY
25167: LIST
25168: LIST
25169: PUSH
25170: LD_INT 23
25172: PUSH
25173: LD_INT 3
25175: PUSH
25176: EMPTY
25177: LIST
25178: LIST
25179: PUSH
25180: LD_INT 3
25182: PUSH
25183: LD_INT 21
25185: PUSH
25186: LD_INT 33
25188: PUSH
25189: EMPTY
25190: LIST
25191: LIST
25192: PUSH
25193: EMPTY
25194: LIST
25195: LIST
25196: PUSH
25197: EMPTY
25198: LIST
25199: LIST
25200: LIST
25201: PPUSH
25202: CALL_OW 69
25206: PUSH
25207: FOR_IN
25208: IFFALSE 25221
// KillUnit ( i ) ;
25210: LD_VAR 0 1
25214: PPUSH
25215: CALL_OW 66
25219: GO 25207
25221: POP
25222: POP
// ChangeSideFog ( 8 , 1 ) ;
25223: LD_INT 8
25225: PPUSH
25226: LD_INT 1
25228: PPUSH
25229: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25233: LD_ADDR_VAR 0 2
25237: PUSH
25238: LD_INT 22
25240: PUSH
25241: LD_INT 8
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: LD_INT 21
25250: PUSH
25251: LD_INT 1
25253: PUSH
25254: EMPTY
25255: LIST
25256: LIST
25257: PUSH
25258: EMPTY
25259: LIST
25260: LIST
25261: PPUSH
25262: CALL_OW 69
25266: PUSH
25267: LD_EXP 61
25271: PUSH
25272: LD_EXP 60
25276: PUSH
25277: EMPTY
25278: LIST
25279: LIST
25280: DIFF
25281: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 ] [ Difficulty ] then
25282: LD_VAR 0 2
25286: PUSH
25287: LD_INT 6
25289: PUSH
25290: LD_INT 5
25292: PUSH
25293: LD_INT 4
25295: PUSH
25296: EMPTY
25297: LIST
25298: LIST
25299: LIST
25300: PUSH
25301: LD_OWVAR 67
25305: ARRAY
25306: GREATEREQUAL
25307: IFFALSE 25481
// begin x := [ 6 , 5 , 4 ] [ Difficulty ] ;
25309: LD_ADDR_VAR 0 3
25313: PUSH
25314: LD_INT 6
25316: PUSH
25317: LD_INT 5
25319: PUSH
25320: LD_INT 4
25322: PUSH
25323: EMPTY
25324: LIST
25325: LIST
25326: LIST
25327: PUSH
25328: LD_OWVAR 67
25332: ARRAY
25333: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25334: LD_ADDR_VAR 0 1
25338: PUSH
25339: DOUBLE
25340: LD_VAR 0 2
25344: PUSH
25345: LD_VAR 0 3
25349: PUSH
25350: LD_INT 1
25352: PLUS
25353: MINUS
25354: INC
25355: ST_TO_ADDR
25356: LD_INT 1
25358: PUSH
25359: FOR_DOWNTO
25360: IFFALSE 25477
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25362: LD_ADDR_EXP 38
25366: PUSH
25367: LD_EXP 38
25371: PUSH
25372: LD_VAR 0 2
25376: PUSH
25377: LD_VAR 0 1
25381: ARRAY
25382: ADD
25383: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25384: LD_VAR 0 2
25388: PUSH
25389: LD_VAR 0 1
25393: ARRAY
25394: PPUSH
25395: CALL_OW 310
25399: IFFALSE 25416
// ComExitBuilding ( tmp [ i ] ) ;
25401: LD_VAR 0 2
25405: PUSH
25406: LD_VAR 0 1
25410: ARRAY
25411: PPUSH
25412: CALL_OW 122
// if IsInUnit ( i ) then
25416: LD_VAR 0 1
25420: PPUSH
25421: CALL_OW 310
25425: IFFALSE 25442
// ComExitVehicle ( tmp [ i ] ) ;
25427: LD_VAR 0 2
25431: PUSH
25432: LD_VAR 0 1
25436: ARRAY
25437: PPUSH
25438: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25442: LD_VAR 0 2
25446: PUSH
25447: LD_VAR 0 1
25451: ARRAY
25452: PPUSH
25453: LD_INT 34
25455: PUSH
25456: LD_INT 0
25458: PPUSH
25459: LD_INT 6
25461: PPUSH
25462: CALL_OW 12
25466: PLUS
25467: PPUSH
25468: LD_INT 1
25470: PPUSH
25471: CALL_OW 171
// end ;
25475: GO 25359
25477: POP
25478: POP
// end else
25479: GO 25491
// x := tmp ;
25481: LD_ADDR_VAR 0 3
25485: PUSH
25486: LD_VAR 0 2
25490: ST_TO_ADDR
// for i := tmp downto tmp - x do
25491: LD_ADDR_VAR 0 1
25495: PUSH
25496: DOUBLE
25497: LD_VAR 0 2
25501: INC
25502: ST_TO_ADDR
25503: LD_VAR 0 2
25507: PUSH
25508: LD_VAR 0 3
25512: MINUS
25513: PUSH
25514: FOR_DOWNTO
25515: IFFALSE 25569
// begin if IsInUnit ( tmp [ i ] ) then
25517: LD_VAR 0 2
25521: PUSH
25522: LD_VAR 0 1
25526: ARRAY
25527: PPUSH
25528: CALL_OW 310
25532: IFFALSE 25549
// ComExitVehicle ( tmp [ i ] ) ;
25534: LD_VAR 0 2
25538: PUSH
25539: LD_VAR 0 1
25543: ARRAY
25544: PPUSH
25545: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25549: LD_VAR 0 2
25553: PUSH
25554: LD_VAR 0 1
25558: ARRAY
25559: PPUSH
25560: LD_INT 1
25562: PPUSH
25563: CALL_OW 235
// end ;
25567: GO 25514
25569: POP
25570: POP
// SetSide ( Kurt , 1 ) ;
25571: LD_EXP 60
25575: PPUSH
25576: LD_INT 1
25578: PPUSH
25579: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25583: LD_INT 22
25585: PUSH
25586: LD_INT 8
25588: PUSH
25589: EMPTY
25590: LIST
25591: LIST
25592: PUSH
25593: LD_INT 21
25595: PUSH
25596: LD_INT 3
25598: PUSH
25599: EMPTY
25600: LIST
25601: LIST
25602: PUSH
25603: EMPTY
25604: LIST
25605: LIST
25606: PPUSH
25607: CALL_OW 69
25611: PPUSH
25612: LD_INT 1
25614: PPUSH
25615: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25619: LD_INT 8
25621: PPUSH
25622: LD_INT 1
25624: PPUSH
25625: LD_INT 1
25627: PPUSH
25628: LD_INT 1
25630: PPUSH
25631: CALL_OW 80
// wait ( 1 1$20 ) ;
25635: LD_INT 2800
25637: PPUSH
25638: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25642: LD_EXP 62
25646: PPUSH
25647: LD_INT 37
25649: PPUSH
25650: LD_INT 1
25652: PPUSH
25653: LD_INT 0
25655: PPUSH
25656: CALL_OW 48
// wait ( 0 0$1 ) ;
25660: LD_INT 35
25662: PPUSH
25663: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25667: LD_EXP 62
25671: PPUSH
25672: LD_INT 60
25674: PPUSH
25675: LD_INT 95
25677: PPUSH
25678: CALL_OW 111
// end ;
25682: PPOPN 3
25684: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25685: LD_EXP 38
25689: IFFALSE 25764
25691: GO 25693
25693: DISABLE
25694: LD_INT 0
25696: PPUSH
// begin enable ;
25697: ENABLE
// for i in legionEscapeUnits do
25698: LD_ADDR_VAR 0 1
25702: PUSH
25703: LD_EXP 38
25707: PUSH
25708: FOR_IN
25709: IFFALSE 25762
// begin if IsInArea ( i , legionEscapeArea ) then
25711: LD_VAR 0 1
25715: PPUSH
25716: LD_INT 31
25718: PPUSH
25719: CALL_OW 308
25723: IFFALSE 25736
// RemoveUnit ( i ) else
25725: LD_VAR 0 1
25729: PPUSH
25730: CALL_OW 64
25734: GO 25760
// if not HasTask ( i ) then
25736: LD_VAR 0 1
25740: PPUSH
25741: CALL_OW 314
25745: NOT
25746: IFFALSE 25760
// ComMoveToArea ( i , legionEscapeArea ) ;
25748: LD_VAR 0 1
25752: PPUSH
25753: LD_INT 31
25755: PPUSH
25756: CALL_OW 113
// end ;
25760: GO 25708
25762: POP
25763: POP
// end ;
25764: PPOPN 1
25766: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25767: LD_INT 22
25769: PUSH
25770: LD_INT 8
25772: PUSH
25773: EMPTY
25774: LIST
25775: LIST
25776: PUSH
25777: LD_INT 21
25779: PUSH
25780: LD_INT 1
25782: PUSH
25783: EMPTY
25784: LIST
25785: LIST
25786: PUSH
25787: EMPTY
25788: LIST
25789: LIST
25790: PPUSH
25791: CALL_OW 69
25795: PUSH
25796: LD_INT 0
25798: EQUAL
25799: IFFALSE 25819
25801: GO 25803
25803: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
25804: LD_STRING MlegionOut
25806: PPUSH
25807: CALL_OW 337
// legionDestroyed := true ;
25811: LD_ADDR_EXP 22
25815: PUSH
25816: LD_INT 1
25818: ST_TO_ADDR
// end ;
25819: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25820: LD_INT 1
25822: PPUSH
25823: LD_EXP 62
25827: PPUSH
25828: CALL_OW 292
25832: IFFALSE 26130
25834: GO 25836
25836: DISABLE
25837: LD_INT 0
25839: PPUSH
// begin wait ( 0 0$2 ) ;
25840: LD_INT 70
25842: PPUSH
25843: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
25847: LD_EXP 62
25851: PPUSH
25852: CALL_OW 87
// DialogueOn ;
25856: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25860: LD_EXP 39
25864: PPUSH
25865: LD_STRING D14-JMM-1
25867: PPUSH
25868: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25872: LD_EXP 62
25876: PPUSH
25877: LD_STRING D14-Friend-1
25879: PPUSH
25880: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25884: LD_EXP 39
25888: PPUSH
25889: LD_STRING D14-JMM-2
25891: PPUSH
25892: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25896: LD_EXP 62
25900: PPUSH
25901: LD_STRING D14-Friend-2
25903: PPUSH
25904: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25908: LD_EXP 39
25912: PPUSH
25913: LD_STRING D14-JMM-3
25915: PPUSH
25916: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25920: LD_EXP 62
25924: PPUSH
25925: LD_STRING D14-Friend-3
25927: PPUSH
25928: CALL_OW 88
// DialogueOff ;
25932: CALL_OW 7
// dec = Query ( Q14 ) ;
25936: LD_ADDR_VAR 0 1
25940: PUSH
25941: LD_STRING Q14
25943: PPUSH
25944: CALL_OW 97
25948: ST_TO_ADDR
// if dec = 1 then
25949: LD_VAR 0 1
25953: PUSH
25954: LD_INT 1
25956: EQUAL
25957: IFFALSE 25991
// begin DialogueOn ;
25959: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25963: LD_EXP 39
25967: PPUSH
25968: LD_STRING D14a-JMM-1
25970: PPUSH
25971: CALL_OW 88
// DialogueOff ;
25975: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25979: LD_EXP 62
25983: PPUSH
25984: LD_INT 1
25986: PPUSH
25987: CALL_OW 235
// end ; if dec = 2 then
25991: LD_VAR 0 1
25995: PUSH
25996: LD_INT 2
25998: EQUAL
25999: IFFALSE 26052
// begin DialogueOn ;
26001: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26005: LD_EXP 39
26009: PPUSH
26010: LD_STRING D14b-JMM-1
26012: PPUSH
26013: CALL_OW 88
// DialogueOff ;
26017: CALL_OW 7
// wait ( 0 0$1 ) ;
26021: LD_INT 35
26023: PPUSH
26024: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26028: LD_EXP 62
26032: PPUSH
26033: LD_INT 9
26035: PPUSH
26036: LD_INT 2
26038: PPUSH
26039: CALL_OW 111
// AddComHold ( Friend ) ;
26043: LD_EXP 62
26047: PPUSH
26048: CALL_OW 200
// end ; if dec = 3 then
26052: LD_VAR 0 1
26056: PUSH
26057: LD_INT 3
26059: EQUAL
26060: IFFALSE 26130
// begin DialogueOn ;
26062: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26066: LD_EXP 39
26070: PPUSH
26071: LD_STRING D14c-JMM-1
26073: PPUSH
26074: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26078: LD_EXP 62
26082: PPUSH
26083: LD_STRING D14c-Friend-1
26085: PPUSH
26086: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26090: LD_EXP 39
26094: PPUSH
26095: LD_STRING D14c-JMM-2
26097: PPUSH
26098: CALL_OW 88
// DialogueOff ;
26102: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26106: LD_EXP 62
26110: PPUSH
26111: LD_INT 9
26113: PPUSH
26114: LD_INT 2
26116: PPUSH
26117: CALL_OW 111
// AddComHold ( Friend ) ;
26121: LD_EXP 62
26125: PPUSH
26126: CALL_OW 200
// end ; end ;
26130: PPOPN 1
26132: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26133: LD_INT 9
26135: PPUSH
26136: LD_INT 2
26138: PPUSH
26139: CALL_OW 428
26143: PUSH
26144: LD_EXP 62
26148: EQUAL
26149: PUSH
26150: LD_EXP 62
26154: PPUSH
26155: CALL_OW 255
26159: PUSH
26160: LD_INT 8
26162: EQUAL
26163: AND
26164: IFFALSE 26178
26166: GO 26168
26168: DISABLE
// RemoveUnit ( Friend ) ;
26169: LD_EXP 62
26173: PPUSH
26174: CALL_OW 64
26178: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26179: LD_EXP 14
26183: PUSH
26184: LD_INT 31500
26186: GREATEREQUAL
26187: PUSH
26188: LD_EXP 7
26192: AND
26193: PUSH
26194: LD_EXP 2
26198: AND
26199: IFFALSE 26629
26201: GO 26203
26203: DISABLE
26204: LD_INT 0
26206: PPUSH
26207: PPUSH
26208: PPUSH
// begin missionStage := 7 ;
26209: LD_ADDR_EXP 15
26213: PUSH
26214: LD_INT 7
26216: ST_TO_ADDR
// uc_side = 1 ;
26217: LD_ADDR_OWVAR 20
26221: PUSH
26222: LD_INT 1
26224: ST_TO_ADDR
// uc_nation = 1 ;
26225: LD_ADDR_OWVAR 21
26229: PUSH
26230: LD_INT 1
26232: ST_TO_ADDR
// for i = 1 to 5 do
26233: LD_ADDR_VAR 0 1
26237: PUSH
26238: DOUBLE
26239: LD_INT 1
26241: DEC
26242: ST_TO_ADDR
26243: LD_INT 5
26245: PUSH
26246: FOR_TO
26247: IFFALSE 26343
// begin vc_engine = 3 ;
26249: LD_ADDR_OWVAR 39
26253: PUSH
26254: LD_INT 3
26256: ST_TO_ADDR
// vc_control = 3 ;
26257: LD_ADDR_OWVAR 38
26261: PUSH
26262: LD_INT 3
26264: ST_TO_ADDR
// vc_chassis = 3 ;
26265: LD_ADDR_OWVAR 37
26269: PUSH
26270: LD_INT 3
26272: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26273: LD_ADDR_OWVAR 40
26277: PUSH
26278: LD_INT 5
26280: PUSH
26281: LD_INT 9
26283: PUSH
26284: LD_INT 7
26286: PUSH
26287: EMPTY
26288: LIST
26289: LIST
26290: LIST
26291: PUSH
26292: LD_INT 1
26294: PPUSH
26295: LD_INT 3
26297: PPUSH
26298: CALL_OW 12
26302: ARRAY
26303: ST_TO_ADDR
// veh = CreateVehicle ;
26304: LD_ADDR_VAR 0 2
26308: PUSH
26309: CALL_OW 45
26313: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26314: LD_VAR 0 2
26318: PPUSH
26319: LD_INT 1
26321: PPUSH
26322: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26326: LD_VAR 0 2
26330: PPUSH
26331: LD_INT 19
26333: PPUSH
26334: LD_INT 0
26336: PPUSH
26337: CALL_OW 49
// end ;
26341: GO 26246
26343: POP
26344: POP
// vc_engine = 3 ;
26345: LD_ADDR_OWVAR 39
26349: PUSH
26350: LD_INT 3
26352: ST_TO_ADDR
// vc_control = 1 ;
26353: LD_ADDR_OWVAR 38
26357: PUSH
26358: LD_INT 1
26360: ST_TO_ADDR
// vc_chassis = 3 ;
26361: LD_ADDR_OWVAR 37
26365: PUSH
26366: LD_INT 3
26368: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26369: LD_ADDR_OWVAR 40
26373: PUSH
26374: LD_INT 5
26376: PUSH
26377: LD_INT 9
26379: PUSH
26380: LD_INT 7
26382: PUSH
26383: EMPTY
26384: LIST
26385: LIST
26386: LIST
26387: PUSH
26388: LD_INT 1
26390: PPUSH
26391: LD_INT 3
26393: PPUSH
26394: CALL_OW 12
26398: ARRAY
26399: ST_TO_ADDR
// vehG = CreateVehicle ;
26400: LD_ADDR_VAR 0 3
26404: PUSH
26405: CALL_OW 45
26409: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26410: LD_VAR 0 3
26414: PPUSH
26415: LD_INT 1
26417: PPUSH
26418: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26422: LD_VAR 0 3
26426: PPUSH
26427: LD_INT 19
26429: PPUSH
26430: LD_INT 0
26432: PPUSH
26433: CALL_OW 49
// if JMMGirl = 1 then
26437: LD_EXP 7
26441: PUSH
26442: LD_INT 1
26444: EQUAL
26445: IFFALSE 26501
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26447: LD_ADDR_EXP 40
26451: PUSH
26452: LD_STRING Joan
26454: PPUSH
26455: LD_INT 1
26457: PPUSH
26458: LD_STRING 14_
26460: PPUSH
26461: CALL 64894 0 3
26465: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26466: LD_EXP 40
26470: PPUSH
26471: LD_VAR 0 3
26475: PPUSH
26476: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26480: LD_VAR 0 3
26484: PPUSH
26485: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26489: LD_EXP 40
26493: PPUSH
26494: LD_STRING D10BW-Joan-1
26496: PPUSH
26497: CALL_OW 94
// end ; if JMMGirl = 2 then
26501: LD_EXP 7
26505: PUSH
26506: LD_INT 2
26508: EQUAL
26509: IFFALSE 26565
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26511: LD_ADDR_EXP 42
26515: PUSH
26516: LD_STRING Lisa
26518: PPUSH
26519: LD_INT 1
26521: PPUSH
26522: LD_STRING 14_
26524: PPUSH
26525: CALL 64894 0 3
26529: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26530: LD_EXP 42
26534: PPUSH
26535: LD_VAR 0 3
26539: PPUSH
26540: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26544: LD_VAR 0 3
26548: PPUSH
26549: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26553: LD_EXP 42
26557: PPUSH
26558: LD_STRING D10BW-Lisa-1
26560: PPUSH
26561: CALL_OW 94
// end ; if JMMGirl = 3 then
26565: LD_EXP 7
26569: PUSH
26570: LD_INT 3
26572: EQUAL
26573: IFFALSE 26629
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26575: LD_ADDR_EXP 54
26579: PUSH
26580: LD_STRING Connie
26582: PPUSH
26583: LD_INT 1
26585: PPUSH
26586: LD_STRING 14_
26588: PPUSH
26589: CALL 64894 0 3
26593: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26594: LD_EXP 54
26598: PPUSH
26599: LD_VAR 0 3
26603: PPUSH
26604: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26608: LD_VAR 0 3
26612: PPUSH
26613: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26617: LD_EXP 54
26621: PPUSH
26622: LD_STRING D10BW-Con-1
26624: PPUSH
26625: CALL_OW 94
// end ; end ;
26629: PPOPN 3
26631: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26632: LD_EXP 14
26636: PUSH
26637: LD_INT 94500
26639: GREATEREQUAL
26640: IFFALSE 27052
26642: GO 26644
26644: DISABLE
26645: LD_INT 0
26647: PPUSH
26648: PPUSH
26649: PPUSH
// begin tmp := PrepareStevensSquad ;
26650: LD_ADDR_VAR 0 3
26654: PUSH
26655: CALL 2197 0 0
26659: ST_TO_ADDR
// if not tmp then
26660: LD_VAR 0 3
26664: NOT
26665: IFFALSE 26669
// exit ;
26667: GO 27052
// uc_side := 1 ;
26669: LD_ADDR_OWVAR 20
26673: PUSH
26674: LD_INT 1
26676: ST_TO_ADDR
// uc_nation := 1 ;
26677: LD_ADDR_OWVAR 21
26681: PUSH
26682: LD_INT 1
26684: ST_TO_ADDR
// for i in tmp do
26685: LD_ADDR_VAR 0 1
26689: PUSH
26690: LD_VAR 0 3
26694: PUSH
26695: FOR_IN
26696: IFFALSE 26793
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26698: LD_INT 3
26700: PPUSH
26701: LD_INT 3
26703: PPUSH
26704: LD_INT 1
26706: PPUSH
26707: LD_INT 5
26709: PUSH
26710: LD_INT 9
26712: PUSH
26713: LD_INT 7
26715: PUSH
26716: EMPTY
26717: LIST
26718: LIST
26719: LIST
26720: PUSH
26721: LD_INT 1
26723: PPUSH
26724: LD_INT 3
26726: PPUSH
26727: CALL_OW 12
26731: ARRAY
26732: PPUSH
26733: LD_INT 40
26735: PPUSH
26736: CALL 72069 0 5
// veh := CreateVehicle ;
26740: LD_ADDR_VAR 0 2
26744: PUSH
26745: CALL_OW 45
26749: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26750: LD_VAR 0 2
26754: PPUSH
26755: LD_INT 1
26757: PPUSH
26758: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26762: LD_VAR 0 2
26766: PPUSH
26767: LD_INT 19
26769: PPUSH
26770: LD_INT 0
26772: PPUSH
26773: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26777: LD_VAR 0 1
26781: PPUSH
26782: LD_VAR 0 2
26786: PPUSH
26787: CALL_OW 52
// end ;
26791: GO 26695
26793: POP
26794: POP
// missionStage := 8 ;
26795: LD_ADDR_EXP 15
26799: PUSH
26800: LD_INT 8
26802: ST_TO_ADDR
// DialogueOn ;
26803: CALL_OW 6
// if Stevens then
26807: LD_EXP 41
26811: IFFALSE 26925
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26813: LD_EXP 41
26817: PPUSH
26818: CALL_OW 310
26822: PPUSH
26823: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26827: LD_EXP 41
26831: PPUSH
26832: LD_STRING D8-Huck-1
26834: PPUSH
26835: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
26839: LD_EXP 39
26843: PPUSH
26844: LD_STRING D8-JMM-1
26846: PPUSH
26847: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26851: LD_EXP 41
26855: PPUSH
26856: LD_STRING D8-Huck-2
26858: PPUSH
26859: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26863: LD_EXP 39
26867: PPUSH
26868: LD_STRING D8-JMM-2
26870: PPUSH
26871: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26875: LD_EXP 41
26879: PPUSH
26880: LD_STRING D8-Huck-3
26882: PPUSH
26883: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26887: LD_EXP 39
26891: PPUSH
26892: LD_STRING D8-JMM-3
26894: PPUSH
26895: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26899: LD_EXP 41
26903: PPUSH
26904: LD_STRING D8-Huck-4
26906: PPUSH
26907: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26911: LD_EXP 39
26915: PPUSH
26916: LD_STRING D8-JMM-4
26918: PPUSH
26919: CALL_OW 88
// end else
26923: GO 27035
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26925: LD_EXP 55
26929: PPUSH
26930: CALL_OW 310
26934: PPUSH
26935: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26939: LD_EXP 55
26943: PPUSH
26944: LD_STRING D8-Huck-1
26946: PPUSH
26947: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26951: LD_EXP 39
26955: PPUSH
26956: LD_STRING D8-JMM-1a
26958: PPUSH
26959: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26963: LD_EXP 55
26967: PPUSH
26968: LD_STRING D8-Huck-2
26970: PPUSH
26971: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26975: LD_EXP 39
26979: PPUSH
26980: LD_STRING D8-JMM-2
26982: PPUSH
26983: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26987: LD_EXP 55
26991: PPUSH
26992: LD_STRING D8-Huck-3
26994: PPUSH
26995: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26999: LD_EXP 39
27003: PPUSH
27004: LD_STRING D8-JMM-3
27006: PPUSH
27007: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27011: LD_EXP 55
27015: PPUSH
27016: LD_STRING D8-Huck-4
27018: PPUSH
27019: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27023: LD_EXP 39
27027: PPUSH
27028: LD_STRING D8-JMM-4
27030: PPUSH
27031: CALL_OW 88
// end ; DialogueOff ;
27035: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27039: LD_INT 25
27041: PPUSH
27042: LD_INT 1
27044: PPUSH
27045: LD_INT 1
27047: PPUSH
27048: CALL_OW 322
// end ;
27052: PPOPN 3
27054: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27055: LD_INT 1
27057: PPUSH
27058: LD_EXP 71
27062: PPUSH
27063: CALL_OW 292
27067: IFFALSE 27318
27069: GO 27071
27071: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27072: LD_EXP 71
27076: PPUSH
27077: CALL_OW 87
// DialogueOn ;
27081: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27085: LD_EXP 39
27089: PPUSH
27090: LD_STRING D10nB-JMM-1
27092: PPUSH
27093: CALL_OW 88
// if BurlakStatus = 1 then
27097: LD_EXP 9
27101: PUSH
27102: LD_INT 1
27104: EQUAL
27105: IFFALSE 27119
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27107: LD_EXP 70
27111: PPUSH
27112: LD_STRING D10nB-Vse-1a
27114: PPUSH
27115: CALL_OW 94
// end ; if BurlakStatus = 0 then
27119: LD_EXP 9
27123: PUSH
27124: LD_INT 0
27126: EQUAL
27127: IFFALSE 27141
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27129: LD_EXP 70
27133: PPUSH
27134: LD_STRING D10nB-Vse-1
27136: PPUSH
27137: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27141: LD_EXP 39
27145: PPUSH
27146: LD_STRING D10nB-JMM-2
27148: PPUSH
27149: CALL_OW 88
// if KappaStatus then
27153: LD_EXP 2
27157: IFFALSE 27171
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27159: LD_EXP 70
27163: PPUSH
27164: LD_STRING D10nB-Vse-5a
27166: PPUSH
27167: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27171: LD_EXP 2
27175: NOT
27176: PUSH
27177: LD_EXP 6
27181: PUSH
27182: LD_INT 0
27184: EQUAL
27185: AND
27186: IFFALSE 27314
// begin if JMMGirl = 1 then
27188: LD_EXP 7
27192: PUSH
27193: LD_INT 1
27195: EQUAL
27196: IFFALSE 27246
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27198: LD_EXP 70
27202: PPUSH
27203: LD_STRING D10nB-Vse-2
27205: PPUSH
27206: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27210: LD_EXP 39
27214: PPUSH
27215: LD_STRING D10nB-JMM-3
27217: PPUSH
27218: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27222: LD_EXP 70
27226: PPUSH
27227: LD_STRING D10nB-Vse-3
27229: PPUSH
27230: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27234: LD_EXP 39
27238: PPUSH
27239: LD_STRING D10nB-JMM-4
27241: PPUSH
27242: CALL_OW 88
// end ; if JMMGirl = 2 then
27246: LD_EXP 7
27250: PUSH
27251: LD_INT 2
27253: EQUAL
27254: IFFALSE 27280
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27256: LD_EXP 70
27260: PPUSH
27261: LD_STRING D10nB-Vse-4
27263: PPUSH
27264: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27268: LD_EXP 39
27272: PPUSH
27273: LD_STRING D10nB-JMM-5
27275: PPUSH
27276: CALL_OW 88
// end ; if JMMGirl = 3 then
27280: LD_EXP 7
27284: PUSH
27285: LD_INT 3
27287: EQUAL
27288: IFFALSE 27314
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27290: LD_EXP 70
27294: PPUSH
27295: LD_STRING D10nB-Vse-5
27297: PPUSH
27298: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27302: LD_EXP 39
27306: PPUSH
27307: LD_STRING D10nB-JMM-6
27309: PPUSH
27310: CALL_OW 88
// end ; end ; DialogueOff ;
27314: CALL_OW 7
// end ;
27318: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27319: LD_EXP 14
27323: PUSH
27324: LD_INT 115500
27326: GREATEREQUAL
27327: IFFALSE 27703
27329: GO 27331
27331: DISABLE
27332: LD_INT 0
27334: PPUSH
// begin missionStage := 10 ;
27335: LD_ADDR_EXP 15
27339: PUSH
27340: LD_INT 10
27342: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27343: LD_ADDR_VAR 0 1
27347: PUSH
27348: LD_INT 22
27350: PUSH
27351: LD_INT 1
27353: PUSH
27354: EMPTY
27355: LIST
27356: LIST
27357: PUSH
27358: LD_INT 23
27360: PUSH
27361: LD_INT 1
27363: PUSH
27364: EMPTY
27365: LIST
27366: LIST
27367: PUSH
27368: LD_INT 26
27370: PUSH
27371: LD_INT 1
27373: PUSH
27374: EMPTY
27375: LIST
27376: LIST
27377: PUSH
27378: LD_INT 3
27380: PUSH
27381: LD_INT 25
27383: PUSH
27384: LD_INT 12
27386: PUSH
27387: EMPTY
27388: LIST
27389: LIST
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: PUSH
27395: LD_INT 3
27397: PUSH
27398: LD_INT 25
27400: PUSH
27401: LD_INT 16
27403: PUSH
27404: EMPTY
27405: LIST
27406: LIST
27407: PUSH
27408: EMPTY
27409: LIST
27410: LIST
27411: PUSH
27412: EMPTY
27413: LIST
27414: LIST
27415: LIST
27416: LIST
27417: LIST
27418: PPUSH
27419: CALL_OW 69
27423: PUSH
27424: LD_EXP 39
27428: PUSH
27429: LD_EXP 60
27433: PUSH
27434: LD_EXP 41
27438: PUSH
27439: LD_EXP 55
27443: PUSH
27444: LD_EXP 42
27448: PUSH
27449: LD_EXP 43
27453: PUSH
27454: LD_EXP 44
27458: PUSH
27459: LD_EXP 45
27463: PUSH
27464: LD_EXP 46
27468: PUSH
27469: LD_EXP 47
27473: PUSH
27474: LD_EXP 48
27478: PUSH
27479: LD_EXP 49
27483: PUSH
27484: LD_EXP 50
27488: PUSH
27489: LD_EXP 51
27493: PUSH
27494: LD_EXP 52
27498: PUSH
27499: LD_EXP 53
27503: PUSH
27504: EMPTY
27505: LIST
27506: LIST
27507: LIST
27508: LIST
27509: LIST
27510: LIST
27511: LIST
27512: LIST
27513: LIST
27514: LIST
27515: LIST
27516: LIST
27517: LIST
27518: LIST
27519: LIST
27520: LIST
27521: DIFF
27522: ST_TO_ADDR
// if not tmp and Brown then
27523: LD_VAR 0 1
27527: NOT
27528: PUSH
27529: LD_EXP 47
27533: AND
27534: IFFALSE 27549
// tmp := [ Brown ] ;
27536: LD_ADDR_VAR 0 1
27540: PUSH
27541: LD_EXP 47
27545: PUSH
27546: EMPTY
27547: LIST
27548: ST_TO_ADDR
// DialogueOn ;
27549: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27553: LD_VAR 0 1
27557: PUSH
27558: LD_INT 1
27560: ARRAY
27561: PPUSH
27562: LD_STRING D11-Sol1-1
27564: PPUSH
27565: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27569: LD_EXP 64
27573: PPUSH
27574: LD_STRING D11-Pla-1
27576: PPUSH
27577: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27581: LD_EXP 65
27585: PPUSH
27586: LD_STRING D11-Kov-1
27588: PPUSH
27589: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27593: LD_EXP 64
27597: PPUSH
27598: LD_STRING D11-Pla-2
27600: PPUSH
27601: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27605: LD_VAR 0 1
27609: PUSH
27610: LD_INT 1
27612: ARRAY
27613: PPUSH
27614: LD_STRING D11-Sol1-2
27616: PPUSH
27617: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27621: LD_EXP 39
27625: PPUSH
27626: LD_STRING D11-JMM-2
27628: PPUSH
27629: CALL_OW 88
// DialogueOff ;
27633: CALL_OW 7
// allowBehemothConstruct := true ;
27637: LD_ADDR_EXP 25
27641: PUSH
27642: LD_INT 1
27644: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27645: LD_STRING M4
27647: PPUSH
27648: CALL_OW 337
// BuildBehemoths ;
27652: CALL 7653 0 0
// repeat wait ( 15 15$00 ) ;
27656: LD_INT 31500
27658: PPUSH
27659: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27663: LD_EXP 27
27667: IFFALSE 27671
// break ;
27669: GO 27703
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27671: LD_INT 267
27673: PPUSH
27674: CALL_OW 274
27678: PPUSH
27679: LD_INT 1
27681: PPUSH
27682: CALL_OW 275
27686: PUSH
27687: LD_INT 1000
27689: GREATEREQUAL
27690: IFFALSE 27696
// BuildBehemoths ;
27692: CALL 7653 0 0
// until not behemothBuilders ;
27696: LD_EXP 73
27700: NOT
27701: IFFALSE 27656
// end ;
27703: PPOPN 1
27705: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27706: LD_EXP 73
27710: NOT
27711: PUSH
27712: LD_EXP 28
27716: NOT
27717: AND
27718: PUSH
27719: LD_EXP 25
27723: AND
27724: IFFALSE 27744
27726: GO 27728
27728: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27729: LD_STRING M4a
27731: PPUSH
27732: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27736: LD_ADDR_EXP 27
27740: PUSH
27741: LD_INT 1
27743: ST_TO_ADDR
// end ;
27744: END
// every 0 0$1 trigger behemothDone do
27745: LD_EXP 28
27749: IFFALSE 27761
27751: GO 27753
27753: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27754: LD_STRING M4b
27756: PPUSH
27757: CALL_OW 337
27761: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27762: LD_EXP 29
27766: NOT
27767: IFFALSE 27963
27769: GO 27771
27771: DISABLE
27772: LD_INT 0
27774: PPUSH
27775: PPUSH
// begin enable ;
27776: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27777: LD_ADDR_VAR 0 1
27781: PUSH
27782: LD_INT 3
27784: PPUSH
27785: CALL 107872 0 1
27789: ST_TO_ADDR
// if not tmp and not behemothDone then
27790: LD_VAR 0 1
27794: NOT
27795: PUSH
27796: LD_EXP 28
27800: NOT
27801: AND
27802: IFFALSE 27838
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27804: LD_ADDR_VAR 0 1
27808: PUSH
27809: LD_INT 22
27811: PUSH
27812: LD_INT 3
27814: PUSH
27815: EMPTY
27816: LIST
27817: LIST
27818: PUSH
27819: LD_INT 30
27821: PUSH
27822: LD_INT 37
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: PUSH
27829: EMPTY
27830: LIST
27831: LIST
27832: PPUSH
27833: CALL_OW 69
27837: ST_TO_ADDR
// if not tmp then
27838: LD_VAR 0 1
27842: NOT
27843: IFFALSE 27847
// exit ;
27845: GO 27963
// for i in tmp do
27847: LD_ADDR_VAR 0 2
27851: PUSH
27852: LD_VAR 0 1
27856: PUSH
27857: FOR_IN
27858: IFFALSE 27961
// if See ( 1 , i ) then
27860: LD_INT 1
27862: PPUSH
27863: LD_VAR 0 2
27867: PPUSH
27868: CALL_OW 292
27872: IFFALSE 27959
// begin if GetType ( i ) = unit_building then
27874: LD_VAR 0 2
27878: PPUSH
27879: CALL_OW 247
27883: PUSH
27884: LD_INT 3
27886: EQUAL
27887: IFFALSE 27925
// begin CenterNowOnUnits ( i ) ;
27889: LD_VAR 0 2
27893: PPUSH
27894: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27898: LD_EXP 39
27902: PPUSH
27903: LD_STRING D17a-JMM-1
27905: PPUSH
27906: CALL_OW 88
// seeBehemoth := true ;
27910: LD_ADDR_EXP 29
27914: PUSH
27915: LD_INT 1
27917: ST_TO_ADDR
// disable ;
27918: DISABLE
// exit ;
27919: POP
27920: POP
27921: GO 27963
// end else
27923: GO 27959
// begin CenterNowOnUnits ( i ) ;
27925: LD_VAR 0 2
27929: PPUSH
27930: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27934: LD_EXP 39
27938: PPUSH
27939: LD_STRING D17b-JMM-1
27941: PPUSH
27942: CALL_OW 88
// seeBehemoth := true ;
27946: LD_ADDR_EXP 29
27950: PUSH
27951: LD_INT 1
27953: ST_TO_ADDR
// disable ;
27954: DISABLE
// exit ;
27955: POP
27956: POP
27957: GO 27963
// end ; end ;
27959: GO 27857
27961: POP
27962: POP
// end ;
27963: PPOPN 2
27965: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27966: LD_EXP 14
27970: PUSH
27971: LD_INT 116550
27973: GREATEREQUAL
27974: IFFALSE 29150
27976: GO 27978
27978: DISABLE
27979: LD_INT 0
27981: PPUSH
27982: PPUSH
27983: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27984: LD_INT 2
27986: PPUSH
27987: LD_INT 23
27989: PUSH
27990: LD_INT 3
27992: PUSH
27993: LD_INT 3
27995: PUSH
27996: LD_INT 48
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: PUSH
28005: EMPTY
28006: LIST
28007: PPUSH
28008: CALL 58550 0 2
// repeat wait ( 0 0$1 ) ;
28012: LD_INT 35
28014: PPUSH
28015: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28019: LD_INT 22
28021: PUSH
28022: LD_INT 3
28024: PUSH
28025: EMPTY
28026: LIST
28027: LIST
28028: PUSH
28029: LD_INT 34
28031: PUSH
28032: LD_INT 48
28034: PUSH
28035: EMPTY
28036: LIST
28037: LIST
28038: PUSH
28039: EMPTY
28040: LIST
28041: LIST
28042: PPUSH
28043: CALL_OW 69
28047: IFFALSE 28012
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28049: LD_ADDR_VAR 0 1
28053: PUSH
28054: LD_INT 22
28056: PUSH
28057: LD_INT 3
28059: PUSH
28060: EMPTY
28061: LIST
28062: LIST
28063: PUSH
28064: LD_INT 34
28066: PUSH
28067: LD_INT 48
28069: PUSH
28070: EMPTY
28071: LIST
28072: LIST
28073: PUSH
28074: EMPTY
28075: LIST
28076: LIST
28077: PPUSH
28078: CALL_OW 69
28082: PUSH
28083: LD_INT 1
28085: ARRAY
28086: ST_TO_ADDR
// missionStage := 12 ;
28087: LD_ADDR_EXP 15
28091: PUSH
28092: LD_INT 12
28094: ST_TO_ADDR
// platonovHasBomb := true ;
28095: LD_ADDR_EXP 30
28099: PUSH
28100: LD_INT 1
28102: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28103: LD_VAR 0 1
28107: PPUSH
28108: LD_INT 181
28110: PPUSH
28111: LD_INT 86
28113: PPUSH
28114: CALL_OW 171
// AddComHold ( bomb ) ;
28118: LD_VAR 0 1
28122: PPUSH
28123: CALL_OW 200
// wait ( 0 0$10 ) ;
28127: LD_INT 350
28129: PPUSH
28130: CALL_OW 67
// DialogueOn ;
28134: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28138: LD_EXP 64
28142: PPUSH
28143: LD_STRING D15-Pla-1
28145: PPUSH
28146: CALL_OW 94
// dec = Query ( Q15a ) ;
28150: LD_ADDR_VAR 0 2
28154: PUSH
28155: LD_STRING Q15a
28157: PPUSH
28158: CALL_OW 97
28162: ST_TO_ADDR
// if dec = 1 then
28163: LD_VAR 0 2
28167: PUSH
28168: LD_INT 1
28170: EQUAL
28171: IFFALSE 28194
// begin Say ( JMM , D15a-JMM-1 ) ;
28173: LD_EXP 39
28177: PPUSH
28178: LD_STRING D15a-JMM-1
28180: PPUSH
28181: CALL_OW 88
// YouLost ( Surrender ) ;
28185: LD_STRING Surrender
28187: PPUSH
28188: CALL_OW 104
// exit ;
28192: GO 29150
// end ; if dec = 2 then
28194: LD_VAR 0 2
28198: PUSH
28199: LD_INT 2
28201: EQUAL
28202: IFFALSE 28271
// begin Say ( JMM , D15b-JMM-1 ) ;
28204: LD_EXP 39
28208: PPUSH
28209: LD_STRING D15b-JMM-1
28211: PPUSH
28212: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28216: LD_EXP 64
28220: PPUSH
28221: LD_STRING D15b-Pla-1
28223: PPUSH
28224: CALL_OW 94
// DialogueOff ;
28228: CALL_OW 7
// wait ( 3 3$00 ) ;
28232: LD_INT 6300
28234: PPUSH
28235: CALL_OW 67
// DialogueOn ;
28239: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28243: LD_EXP 39
28247: PPUSH
28248: LD_STRING D15d-JMM-1a
28250: PPUSH
28251: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28255: LD_EXP 64
28259: PPUSH
28260: LD_STRING D15d-Pla-1
28262: PPUSH
28263: CALL_OW 94
// DialogueOff ;
28267: CALL_OW 7
// end ; if dec = 3 then
28271: LD_VAR 0 2
28275: PUSH
28276: LD_INT 3
28278: EQUAL
28279: IFFALSE 28333
// begin Say ( JMM , D15c-JMM-1 ) ;
28281: LD_EXP 39
28285: PPUSH
28286: LD_STRING D15c-JMM-1
28288: PPUSH
28289: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28293: LD_EXP 64
28297: PPUSH
28298: LD_STRING D15c-Pla-1
28300: PPUSH
28301: CALL_OW 94
// DialogueOff ;
28305: CALL_OW 7
// wait ( 0 0$15 ) ;
28309: LD_INT 525
28311: PPUSH
28312: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28316: LD_VAR 0 1
28320: PPUSH
28321: LD_INT 60
28323: PPUSH
28324: LD_INT 95
28326: PPUSH
28327: CALL_OW 116
// exit ;
28331: GO 29150
// end ; if dec = 4 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 4
28340: EQUAL
28341: IFFALSE 28371
// begin Say ( JMM , D15d-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15d-JMM-1
28350: PPUSH
28351: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28355: LD_EXP 64
28359: PPUSH
28360: LD_STRING D15d-Pla-1
28362: PPUSH
28363: CALL_OW 94
// DialogueOff ;
28367: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28371: LD_EXP 62
28375: PPUSH
28376: CALL_OW 302
28380: PUSH
28381: LD_EXP 62
28385: PPUSH
28386: CALL_OW 255
28390: PUSH
28391: LD_INT 1
28393: EQUAL
28394: AND
28395: PUSH
28396: LD_INT 22
28398: PUSH
28399: LD_INT 1
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: PUSH
28406: LD_INT 34
28408: PUSH
28409: LD_INT 8
28411: PUSH
28412: EMPTY
28413: LIST
28414: LIST
28415: PUSH
28416: EMPTY
28417: LIST
28418: LIST
28419: PPUSH
28420: CALL_OW 69
28424: NOT
28425: AND
28426: IFFALSE 29051
// begin SetSide ( Friend , 8 ) ;
28428: LD_EXP 62
28432: PPUSH
28433: LD_INT 8
28435: PPUSH
28436: CALL_OW 235
// if IsInUnit ( Friend ) then
28440: LD_EXP 62
28444: PPUSH
28445: CALL_OW 310
28449: IFFALSE 28460
// ComExitBuilding ( Friend ) ;
28451: LD_EXP 62
28455: PPUSH
28456: CALL_OW 122
// if IsDriver ( Friend ) then
28460: LD_EXP 62
28464: PPUSH
28465: CALL 105549 0 1
28469: IFFALSE 28480
// ComExitVehicle ( Friend ) ;
28471: LD_EXP 62
28475: PPUSH
28476: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28480: LD_EXP 62
28484: PPUSH
28485: LD_INT 9
28487: PPUSH
28488: LD_INT 2
28490: PPUSH
28491: CALL_OW 171
// wait ( 0 0$05 ) ;
28495: LD_INT 175
28497: PPUSH
28498: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28502: LD_EXP 62
28506: PPUSH
28507: CALL_OW 87
// DialogueOn ;
28511: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28515: LD_EXP 39
28519: PPUSH
28520: LD_STRING D16-JMM-1
28522: PPUSH
28523: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28527: LD_EXP 62
28531: PPUSH
28532: LD_STRING D16-Friend-1
28534: PPUSH
28535: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28539: LD_EXP 39
28543: PPUSH
28544: LD_STRING D16-JMM-2
28546: PPUSH
28547: CALL_OW 88
// DialogueOff ;
28551: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28555: LD_EXP 62
28559: PPUSH
28560: LD_INT 1
28562: PPUSH
28563: CALL_OW 235
// ComHold ( Friend ) ;
28567: LD_EXP 62
28571: PPUSH
28572: CALL_OW 140
// wait ( 0 0$20 ) ;
28576: LD_INT 700
28578: PPUSH
28579: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28583: LD_EXP 62
28587: PPUSH
28588: LD_INT 9
28590: PPUSH
28591: LD_INT 2
28593: PPUSH
28594: CALL_OW 297
28598: PUSH
28599: LD_INT 30
28601: LESS
28602: IFFALSE 28671
// begin SetSide ( Friend , 8 ) ;
28604: LD_EXP 62
28608: PPUSH
28609: LD_INT 8
28611: PPUSH
28612: CALL_OW 235
// if IsInUnit ( Friend ) then
28616: LD_EXP 62
28620: PPUSH
28621: CALL_OW 310
28625: IFFALSE 28636
// ComExitBuilding ( Friend ) ;
28627: LD_EXP 62
28631: PPUSH
28632: CALL_OW 122
// if IsDriver ( Friend ) then
28636: LD_EXP 62
28640: PPUSH
28641: CALL 105549 0 1
28645: IFFALSE 28656
// ComExitVehicle ( Friend ) ;
28647: LD_EXP 62
28651: PPUSH
28652: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28656: LD_EXP 62
28660: PPUSH
28661: LD_INT 9
28663: PPUSH
28664: LD_INT 2
28666: PPUSH
28667: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28671: LD_INT 1050
28673: PPUSH
28674: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28678: LD_INT 22
28680: PUSH
28681: LD_INT 1
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 34
28690: PUSH
28691: LD_INT 8
28693: PUSH
28694: EMPTY
28695: LIST
28696: LIST
28697: PUSH
28698: EMPTY
28699: LIST
28700: LIST
28701: PPUSH
28702: CALL_OW 69
28706: NOT
28707: IFFALSE 29029
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28709: LD_ADDR_VAR 0 3
28713: PUSH
28714: LD_INT 22
28716: PUSH
28717: LD_INT 1
28719: PUSH
28720: EMPTY
28721: LIST
28722: LIST
28723: PUSH
28724: LD_INT 26
28726: PUSH
28727: LD_INT 1
28729: PUSH
28730: EMPTY
28731: LIST
28732: LIST
28733: PUSH
28734: LD_INT 3
28736: PUSH
28737: LD_INT 25
28739: PUSH
28740: LD_INT 12
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PUSH
28747: LD_INT 25
28749: PUSH
28750: LD_INT 16
28752: PUSH
28753: EMPTY
28754: LIST
28755: LIST
28756: PUSH
28757: EMPTY
28758: LIST
28759: LIST
28760: LIST
28761: PUSH
28762: EMPTY
28763: LIST
28764: LIST
28765: LIST
28766: PPUSH
28767: CALL_OW 69
28771: PUSH
28772: LD_EXP 39
28776: PUSH
28777: LD_EXP 41
28781: PUSH
28782: LD_EXP 55
28786: PUSH
28787: LD_EXP 42
28791: PUSH
28792: LD_EXP 43
28796: PUSH
28797: LD_EXP 44
28801: PUSH
28802: LD_EXP 45
28806: PUSH
28807: LD_EXP 46
28811: PUSH
28812: LD_EXP 47
28816: PUSH
28817: LD_EXP 48
28821: PUSH
28822: LD_EXP 49
28826: PUSH
28827: LD_EXP 50
28831: PUSH
28832: LD_EXP 51
28836: PUSH
28837: LD_EXP 52
28841: PUSH
28842: LD_EXP 53
28846: PUSH
28847: EMPTY
28848: LIST
28849: LIST
28850: LIST
28851: LIST
28852: LIST
28853: LIST
28854: LIST
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: LIST
28862: LIST
28863: DIFF
28864: ST_TO_ADDR
// DialogueOn ;
28865: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28869: LD_EXP 64
28873: PPUSH
28874: LD_STRING D16a-Pla-1
28876: PPUSH
28877: CALL_OW 94
// if Stevens then
28881: LD_EXP 41
28885: IFFALSE 28901
// Say ( Stevens , D16a-Huck-1 ) else
28887: LD_EXP 41
28891: PPUSH
28892: LD_STRING D16a-Huck-1
28894: PPUSH
28895: CALL_OW 88
28899: GO 28943
// if Baker then
28901: LD_EXP 55
28905: IFFALSE 28921
// Say ( Baker , D16a-Huck-1 ) else
28907: LD_EXP 55
28911: PPUSH
28912: LD_STRING D16a-Huck-1
28914: PPUSH
28915: CALL_OW 88
28919: GO 28943
// if tmp then
28921: LD_VAR 0 3
28925: IFFALSE 28943
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28927: LD_VAR 0 3
28931: PUSH
28932: LD_INT 1
28934: ARRAY
28935: PPUSH
28936: LD_STRING D16a-Sol1-1
28938: PPUSH
28939: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28943: LD_EXP 62
28947: PPUSH
28948: CALL_OW 255
28952: PUSH
28953: LD_INT 8
28955: EQUAL
28956: IFFALSE 28972
// Say ( JMM , D16a-JMM-1 ) else
28958: LD_EXP 39
28962: PPUSH
28963: LD_STRING D16a-JMM-1
28965: PPUSH
28966: CALL_OW 88
28970: GO 29008
// begin Say ( JMM , D16a-JMM-1a ) ;
28972: LD_EXP 39
28976: PPUSH
28977: LD_STRING D16a-JMM-1a
28979: PPUSH
28980: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28984: LD_EXP 62
28988: PPUSH
28989: LD_STRING D16a-Friend-1
28991: PPUSH
28992: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28996: LD_EXP 62
29000: PPUSH
29001: LD_INT 3
29003: PPUSH
29004: CALL_OW 235
// end ; DialogueOff ;
29008: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29012: LD_VAR 0 1
29016: PPUSH
29017: LD_INT 60
29019: PPUSH
29020: LD_INT 95
29022: PPUSH
29023: CALL_OW 116
// end else
29027: GO 29049
// begin DialogueOn ;
29029: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29033: LD_EXP 64
29037: PPUSH
29038: LD_STRING D16c-Pla-
29040: PPUSH
29041: CALL_OW 94
// DialogueOff ;
29045: CALL_OW 7
// end ; end else
29049: GO 29150
// begin wait ( 3 3$00 ) ;
29051: LD_INT 6300
29053: PPUSH
29054: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29058: LD_INT 22
29060: PUSH
29061: LD_INT 1
29063: PUSH
29064: EMPTY
29065: LIST
29066: LIST
29067: PUSH
29068: LD_INT 34
29070: PUSH
29071: LD_INT 8
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: PUSH
29078: EMPTY
29079: LIST
29080: LIST
29081: PPUSH
29082: CALL_OW 69
29086: NOT
29087: IFFALSE 29130
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29089: LD_EXP 64
29093: PPUSH
29094: LD_STRING D16b-Pla-1
29096: PPUSH
29097: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29101: LD_EXP 39
29105: PPUSH
29106: LD_STRING D16b-JMM-
29108: PPUSH
29109: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29113: LD_VAR 0 1
29117: PPUSH
29118: LD_INT 60
29120: PPUSH
29121: LD_INT 95
29123: PPUSH
29124: CALL_OW 116
// end else
29128: GO 29150
// begin DialogueOn ;
29130: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29134: LD_EXP 64
29138: PPUSH
29139: LD_STRING D16c-Pla-
29141: PPUSH
29142: CALL_OW 94
// DialogueOff ;
29146: CALL_OW 7
// end ; end ; end ;
29150: PPOPN 3
29152: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29153: LD_EXP 14
29157: PUSH
29158: LD_INT 126000
29160: GREATEREQUAL
29161: PUSH
29162: LD_EXP 23
29166: NOT
29167: AND
29168: PUSH
29169: LD_EXP 74
29173: PPUSH
29174: CALL_OW 302
29178: AND
29179: IFFALSE 29537
29181: GO 29183
29183: DISABLE
29184: LD_INT 0
29186: PPUSH
// begin missionStage = 11 ;
29187: LD_ADDR_EXP 15
29191: PUSH
29192: LD_INT 11
29194: ST_TO_ADDR
// DialogueOn ;
29195: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29199: LD_EXP 74
29203: PPUSH
29204: LD_STRING D9-Roth-1
29206: PPUSH
29207: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29211: LD_EXP 39
29215: PPUSH
29216: LD_STRING D9-JMM-1
29218: PPUSH
29219: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29223: LD_EXP 74
29227: PPUSH
29228: LD_STRING D9-Roth-2
29230: PPUSH
29231: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29235: LD_EXP 74
29239: PPUSH
29240: LD_STRING D9-Roth-2a
29242: PPUSH
29243: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29247: LD_EXP 64
29251: PPUSH
29252: LD_STRING D9-Pla-2
29254: PPUSH
29255: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29259: LD_EXP 74
29263: PPUSH
29264: LD_STRING D9-Roth-3
29266: PPUSH
29267: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29271: LD_EXP 64
29275: PPUSH
29276: LD_STRING D9-Pla-3
29278: PPUSH
29279: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29283: LD_EXP 74
29287: PPUSH
29288: LD_STRING D9-Roth-4
29290: PPUSH
29291: CALL_OW 94
// dec = Query ( Q9 ) ;
29295: LD_ADDR_VAR 0 1
29299: PUSH
29300: LD_STRING Q9
29302: PPUSH
29303: CALL_OW 97
29307: ST_TO_ADDR
// if dec = 1 then
29308: LD_VAR 0 1
29312: PUSH
29313: LD_INT 1
29315: EQUAL
29316: IFFALSE 29330
// SayRadio ( Roth , D9a-Roth-1 ) ;
29318: LD_EXP 74
29322: PPUSH
29323: LD_STRING D9a-Roth-1
29325: PPUSH
29326: CALL_OW 94
// if dec = 2 then
29330: LD_VAR 0 1
29334: PUSH
29335: LD_INT 2
29337: EQUAL
29338: IFFALSE 29364
// begin Say ( JMM , D9b-JMM-1 ) ;
29340: LD_EXP 39
29344: PPUSH
29345: LD_STRING D9b-JMM-1
29347: PPUSH
29348: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29352: LD_EXP 74
29356: PPUSH
29357: LD_STRING D9b-Roth-1
29359: PPUSH
29360: CALL_OW 94
// end ; if dec = 3 then
29364: LD_VAR 0 1
29368: PUSH
29369: LD_INT 3
29371: EQUAL
29372: IFFALSE 29434
// begin Say ( JMM , D9c-JMM-1 ) ;
29374: LD_EXP 39
29378: PPUSH
29379: LD_STRING D9c-JMM-1
29381: PPUSH
29382: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29386: LD_EXP 74
29390: PPUSH
29391: LD_STRING D9c-Roth-1
29393: PPUSH
29394: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29398: LD_EXP 39
29402: PPUSH
29403: LD_STRING D9c-JMM-2
29405: PPUSH
29406: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29410: LD_EXP 74
29414: PPUSH
29415: LD_STRING D9c-Roth-2
29417: PPUSH
29418: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29422: LD_EXP 39
29426: PPUSH
29427: LD_STRING D9c-JMM-3
29429: PPUSH
29430: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29434: LD_EXP 74
29438: PPUSH
29439: LD_STRING D9c-Roth-3
29441: PPUSH
29442: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29446: LD_EXP 74
29450: PPUSH
29451: LD_STRING D9cont-Roth-1
29453: PPUSH
29454: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29458: LD_EXP 39
29462: PPUSH
29463: LD_STRING D9cont-JMM-1
29465: PPUSH
29466: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29470: LD_EXP 74
29474: PPUSH
29475: LD_STRING D9cont-Roth-2
29477: PPUSH
29478: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29482: LD_EXP 39
29486: PPUSH
29487: LD_STRING D9cont-JMM-2
29489: PPUSH
29490: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29494: LD_EXP 74
29498: PPUSH
29499: LD_STRING D9cont-Roth-3
29501: PPUSH
29502: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29506: LD_EXP 39
29510: PPUSH
29511: LD_STRING D9cont-JMM-3
29513: PPUSH
29514: CALL_OW 88
// DialogueOff ;
29518: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29522: LD_STRING M3
29524: PPUSH
29525: CALL_OW 337
// allianceActive := true ;
29529: LD_ADDR_EXP 31
29533: PUSH
29534: LD_INT 1
29536: ST_TO_ADDR
// end ;
29537: PPOPN 1
29539: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29540: LD_EXP 64
29544: PPUSH
29545: CALL_OW 301
29549: PUSH
29550: LD_EXP 67
29554: PPUSH
29555: CALL_OW 301
29559: AND
29560: PUSH
29561: LD_INT 22
29563: PUSH
29564: LD_INT 3
29566: PUSH
29567: EMPTY
29568: LIST
29569: LIST
29570: PUSH
29571: LD_INT 21
29573: PUSH
29574: LD_INT 1
29576: PUSH
29577: EMPTY
29578: LIST
29579: LIST
29580: PUSH
29581: LD_INT 50
29583: PUSH
29584: EMPTY
29585: LIST
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: LIST
29591: PPUSH
29592: CALL_OW 69
29596: PUSH
29597: LD_INT 7
29599: PUSH
29600: LD_INT 8
29602: PUSH
29603: LD_INT 9
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: LIST
29610: PUSH
29611: LD_OWVAR 67
29615: ARRAY
29616: LESS
29617: AND
29618: IFFALSE 30389
29620: GO 29622
29622: DISABLE
29623: LD_INT 0
29625: PPUSH
29626: PPUSH
29627: PPUSH
29628: PPUSH
// begin MC_Kill ( 1 ) ;
29629: LD_INT 1
29631: PPUSH
29632: CALL 35090 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29636: LD_INT 1
29638: PPUSH
29639: LD_INT 3
29641: PPUSH
29642: LD_INT 1
29644: PPUSH
29645: LD_INT 1
29647: PPUSH
29648: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29652: LD_ADDR_VAR 0 1
29656: PUSH
29657: LD_INT 22
29659: PUSH
29660: LD_INT 3
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: LD_INT 21
29669: PUSH
29670: LD_INT 1
29672: PUSH
29673: EMPTY
29674: LIST
29675: LIST
29676: PUSH
29677: LD_INT 24
29679: PUSH
29680: LD_INT 900
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: LIST
29691: PPUSH
29692: CALL_OW 69
29696: PUSH
29697: FOR_IN
29698: IFFALSE 29729
// if GetSex ( i ) = sex_male then
29700: LD_VAR 0 1
29704: PPUSH
29705: CALL_OW 258
29709: PUSH
29710: LD_INT 1
29712: EQUAL
29713: IFFALSE 29727
// begin tmp = i ;
29715: LD_ADDR_VAR 0 2
29719: PUSH
29720: LD_VAR 0 1
29724: ST_TO_ADDR
// break ;
29725: GO 29729
// end ;
29727: GO 29697
29729: POP
29730: POP
// if tmp = 0 then
29731: LD_VAR 0 2
29735: PUSH
29736: LD_INT 0
29738: EQUAL
29739: IFFALSE 29793
// begin uc_side = 3 ;
29741: LD_ADDR_OWVAR 20
29745: PUSH
29746: LD_INT 3
29748: ST_TO_ADDR
// uc_nation = 3 ;
29749: LD_ADDR_OWVAR 21
29753: PUSH
29754: LD_INT 3
29756: ST_TO_ADDR
// hc_name =  ;
29757: LD_ADDR_OWVAR 26
29761: PUSH
29762: LD_STRING 
29764: ST_TO_ADDR
// hc_gallery =  ;
29765: LD_ADDR_OWVAR 33
29769: PUSH
29770: LD_STRING 
29772: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
29773: LD_INT 1
29775: PPUSH
29776: LD_INT 10
29778: PPUSH
29779: CALL_OW 381
// tmp = CreateHuman ;
29783: LD_ADDR_VAR 0 2
29787: PUSH
29788: CALL_OW 44
29792: ST_TO_ADDR
// end ; DialogueOn ;
29793: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
29797: LD_VAR 0 2
29801: PPUSH
29802: LD_STRING DSurrenderRussians-RSol1-1a
29804: PPUSH
29805: CALL_OW 94
// DialogueOff ;
29809: CALL_OW 7
// russianDestroyed := true ;
29813: LD_ADDR_EXP 21
29817: PUSH
29818: LD_INT 1
29820: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
29821: LD_INT 22
29823: PUSH
29824: LD_INT 3
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 21
29833: PUSH
29834: LD_INT 1
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PPUSH
29845: CALL_OW 69
29849: PPUSH
29850: CALL_OW 122
// wait ( 0 0$1 ) ;
29854: LD_INT 35
29856: PPUSH
29857: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29861: LD_INT 22
29863: PUSH
29864: LD_INT 3
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 21
29873: PUSH
29874: LD_INT 1
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: EMPTY
29882: LIST
29883: LIST
29884: PPUSH
29885: CALL_OW 69
29889: PPUSH
29890: LD_INT 25
29892: PPUSH
29893: CALL_OW 173
// wait ( 0 0$10 ) ;
29897: LD_INT 350
29899: PPUSH
29900: CALL_OW 67
// PrepareOmarInvasion ;
29904: CALL 13863 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29908: LD_ADDR_VAR 0 2
29912: PUSH
29913: LD_EXP 92
29917: PPUSH
29918: CALL_OW 250
29922: PUSH
29923: LD_EXP 92
29927: PPUSH
29928: CALL_OW 251
29932: PUSH
29933: EMPTY
29934: LIST
29935: LIST
29936: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29937: LD_VAR 0 2
29941: PUSH
29942: LD_INT 1
29944: ARRAY
29945: PPUSH
29946: LD_VAR 0 2
29950: PUSH
29951: LD_INT 2
29953: ARRAY
29954: PPUSH
29955: LD_INT 1
29957: PPUSH
29958: LD_INT 8
29960: NEG
29961: PPUSH
29962: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29966: LD_EXP 92
29970: PPUSH
29971: CALL_OW 87
// DialogueOn ;
29975: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29979: LD_EXP 39
29983: PPUSH
29984: LD_STRING D19-JMM-1
29986: PPUSH
29987: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29991: LD_ADDR_VAR 0 3
29995: PUSH
29996: LD_INT 22
29998: PUSH
29999: LD_INT 1
30001: PUSH
30002: EMPTY
30003: LIST
30004: LIST
30005: PUSH
30006: LD_INT 26
30008: PUSH
30009: LD_INT 1
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 2
30018: PUSH
30019: LD_INT 25
30021: PUSH
30022: LD_INT 1
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 25
30031: PUSH
30032: LD_INT 2
30034: PUSH
30035: EMPTY
30036: LIST
30037: LIST
30038: PUSH
30039: LD_INT 25
30041: PUSH
30042: LD_INT 3
30044: PUSH
30045: EMPTY
30046: LIST
30047: LIST
30048: PUSH
30049: LD_INT 25
30051: PUSH
30052: LD_INT 4
30054: PUSH
30055: EMPTY
30056: LIST
30057: LIST
30058: PUSH
30059: LD_INT 25
30061: PUSH
30062: LD_INT 5
30064: PUSH
30065: EMPTY
30066: LIST
30067: LIST
30068: PUSH
30069: LD_INT 25
30071: PUSH
30072: LD_INT 8
30074: PUSH
30075: EMPTY
30076: LIST
30077: LIST
30078: PUSH
30079: EMPTY
30080: LIST
30081: LIST
30082: LIST
30083: LIST
30084: LIST
30085: LIST
30086: LIST
30087: PUSH
30088: EMPTY
30089: LIST
30090: LIST
30091: LIST
30092: PPUSH
30093: CALL_OW 69
30097: PUSH
30098: LD_EXP 39
30102: PUSH
30103: LD_EXP 40
30107: PUSH
30108: LD_EXP 41
30112: PUSH
30113: LD_EXP 42
30117: PUSH
30118: LD_EXP 43
30122: PUSH
30123: LD_EXP 44
30127: PUSH
30128: LD_EXP 45
30132: PUSH
30133: LD_EXP 46
30137: PUSH
30138: LD_EXP 47
30142: PUSH
30143: LD_EXP 48
30147: PUSH
30148: LD_EXP 49
30152: PUSH
30153: LD_EXP 50
30157: PUSH
30158: LD_EXP 51
30162: PUSH
30163: LD_EXP 52
30167: PUSH
30168: LD_EXP 53
30172: PUSH
30173: LD_EXP 54
30177: PUSH
30178: LD_EXP 55
30182: PUSH
30183: EMPTY
30184: LIST
30185: LIST
30186: LIST
30187: LIST
30188: LIST
30189: LIST
30190: LIST
30191: LIST
30192: LIST
30193: LIST
30194: LIST
30195: LIST
30196: LIST
30197: LIST
30198: LIST
30199: LIST
30200: LIST
30201: DIFF
30202: ST_TO_ADDR
// if tmp2 then
30203: LD_VAR 0 3
30207: IFFALSE 30225
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30209: LD_VAR 0 3
30213: PUSH
30214: LD_INT 1
30216: ARRAY
30217: PPUSH
30218: LD_STRING D19-Sol1-1
30220: PPUSH
30221: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30225: LD_EXP 39
30229: PPUSH
30230: LD_STRING D19-JMM-2
30232: PPUSH
30233: CALL_OW 88
// DialogueOff ;
30237: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30241: LD_VAR 0 2
30245: PUSH
30246: LD_INT 1
30248: ARRAY
30249: PPUSH
30250: LD_VAR 0 2
30254: PUSH
30255: LD_INT 2
30257: ARRAY
30258: PPUSH
30259: LD_INT 1
30261: PPUSH
30262: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30266: LD_STRING M5
30268: PPUSH
30269: CALL_OW 337
// omarOnMotherLode := false ;
30273: LD_ADDR_VAR 0 4
30277: PUSH
30278: LD_INT 0
30280: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30281: LD_INT 35
30283: PPUSH
30284: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30288: LD_EXP 92
30292: PPUSH
30293: LD_INT 215
30295: PPUSH
30296: LD_INT 100
30298: PPUSH
30299: CALL_OW 297
30303: PUSH
30304: LD_INT 10
30306: LESS
30307: PUSH
30308: LD_VAR 0 4
30312: NOT
30313: AND
30314: IFFALSE 30348
// begin omarOnMotherLode := true ;
30316: LD_ADDR_VAR 0 4
30320: PUSH
30321: LD_INT 1
30323: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30324: LD_EXP 39
30328: PPUSH
30329: LD_STRING D19b-JMM-1
30331: PPUSH
30332: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30336: LD_EXP 92
30340: PPUSH
30341: LD_STRING DOmarContam-Omar-1
30343: PPUSH
30344: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30348: LD_EXP 92
30352: PPUSH
30353: CALL_OW 301
30357: IFFALSE 30281
// Say ( JMM , D19a-JMM-1 ) ;
30359: LD_EXP 39
30363: PPUSH
30364: LD_STRING D19a-JMM-1
30366: PPUSH
30367: CALL_OW 88
// if Heike then
30371: LD_EXP 93
30375: IFFALSE 30389
// Say ( Heike , D19a-Hke-1 ) ;
30377: LD_EXP 93
30381: PPUSH
30382: LD_STRING D19a-Hke-1
30384: PPUSH
30385: CALL_OW 88
// end ;
30389: PPOPN 4
30391: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30392: LD_INT 22
30394: PUSH
30395: LD_INT 3
30397: PUSH
30398: EMPTY
30399: LIST
30400: LIST
30401: PUSH
30402: LD_INT 21
30404: PUSH
30405: LD_INT 1
30407: PUSH
30408: EMPTY
30409: LIST
30410: LIST
30411: PUSH
30412: EMPTY
30413: LIST
30414: LIST
30415: PPUSH
30416: CALL_OW 69
30420: PUSH
30421: LD_EXP 21
30425: AND
30426: IFFALSE 30494
30428: GO 30430
30430: DISABLE
30431: LD_INT 0
30433: PPUSH
30434: PPUSH
// begin enable ;
30435: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30436: LD_ADDR_VAR 0 2
30440: PUSH
30441: LD_INT 25
30443: PPUSH
30444: LD_INT 22
30446: PUSH
30447: LD_INT 3
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PPUSH
30454: CALL_OW 70
30458: ST_TO_ADDR
// if not tmp then
30459: LD_VAR 0 2
30463: NOT
30464: IFFALSE 30468
// exit ;
30466: GO 30494
// for i in tmp do
30468: LD_ADDR_VAR 0 1
30472: PUSH
30473: LD_VAR 0 2
30477: PUSH
30478: FOR_IN
30479: IFFALSE 30492
// RemoveUnit ( i ) ;
30481: LD_VAR 0 1
30485: PPUSH
30486: CALL_OW 64
30490: GO 30478
30492: POP
30493: POP
// end ;
30494: PPOPN 2
30496: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30497: LD_INT 22
30499: PUSH
30500: LD_INT 7
30502: PUSH
30503: EMPTY
30504: LIST
30505: LIST
30506: PUSH
30507: LD_INT 21
30509: PUSH
30510: LD_INT 1
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PPUSH
30521: CALL_OW 69
30525: PUSH
30526: LD_INT 6
30528: LESS
30529: IFFALSE 30997
30531: GO 30533
30533: DISABLE
30534: LD_INT 0
30536: PPUSH
30537: PPUSH
// begin MC_Kill ( 1 ) ;
30538: LD_INT 1
30540: PPUSH
30541: CALL 35090 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30545: LD_INT 7
30547: PPUSH
30548: LD_INT 1
30550: PPUSH
30551: LD_INT 1
30553: PPUSH
30554: LD_INT 1
30556: PPUSH
30557: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30561: LD_ADDR_VAR 0 1
30565: PUSH
30566: LD_INT 22
30568: PUSH
30569: LD_INT 7
30571: PUSH
30572: EMPTY
30573: LIST
30574: LIST
30575: PUSH
30576: LD_INT 26
30578: PUSH
30579: LD_INT 1
30581: PUSH
30582: EMPTY
30583: LIST
30584: LIST
30585: PUSH
30586: EMPTY
30587: LIST
30588: LIST
30589: PPUSH
30590: CALL_OW 69
30594: PUSH
30595: LD_EXP 74
30599: DIFF
30600: ST_TO_ADDR
// if tmp then
30601: LD_VAR 0 1
30605: IFFALSE 30623
// tmp := tmp [ 1 ] else
30607: LD_ADDR_VAR 0 1
30611: PUSH
30612: LD_VAR 0 1
30616: PUSH
30617: LD_INT 1
30619: ARRAY
30620: ST_TO_ADDR
30621: GO 30659
// begin uc_side := 7 ;
30623: LD_ADDR_OWVAR 20
30627: PUSH
30628: LD_INT 7
30630: ST_TO_ADDR
// uc_nation := 1 ;
30631: LD_ADDR_OWVAR 21
30635: PUSH
30636: LD_INT 1
30638: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30639: LD_INT 1
30641: PPUSH
30642: LD_INT 8
30644: PPUSH
30645: CALL_OW 384
// tmp := CreateHuman ;
30649: LD_ADDR_VAR 0 1
30653: PUSH
30654: CALL_OW 44
30658: ST_TO_ADDR
// end ; DialogueOn ;
30659: CALL_OW 6
// if IsOK ( Roth ) then
30663: LD_EXP 74
30667: PPUSH
30668: CALL_OW 302
30672: IFFALSE 30686
// Say ( JMM , DAb-JMM-1 ) ;
30674: LD_EXP 39
30678: PPUSH
30679: LD_STRING DAb-JMM-1
30681: PPUSH
30682: CALL_OW 88
// if IsOK ( Roth ) then
30686: LD_EXP 74
30690: PPUSH
30691: CALL_OW 302
30695: IFFALSE 30719
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30697: LD_EXP 74
30701: PPUSH
30702: LD_STRING DSurrenderAlliance-Roth-1
30704: PPUSH
30705: CALL_OW 88
// RothCaptured := true ;
30709: LD_ADDR_EXP 33
30713: PUSH
30714: LD_INT 1
30716: ST_TO_ADDR
// end else
30717: GO 30731
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30719: LD_VAR 0 1
30723: PPUSH
30724: LD_STRING DSurrenderAlliance-Sci1-1
30726: PPUSH
30727: CALL_OW 88
// DialogueOff ;
30731: CALL_OW 7
// allianceDestroyed := true ;
30735: LD_ADDR_EXP 23
30739: PUSH
30740: LD_INT 1
30742: ST_TO_ADDR
// if capturedUnit = 0 then
30743: LD_EXP 34
30747: PUSH
30748: LD_INT 0
30750: EQUAL
30751: IFFALSE 30760
// SetAchievement ( ACH_ALLIANCE ) ;
30753: LD_STRING ACH_ALLIANCE
30755: PPUSH
30756: CALL_OW 543
// if trueAmericans then
30760: LD_EXP 35
30764: IFFALSE 30840
// begin if trueAmericans = 1 then
30766: LD_EXP 35
30770: PUSH
30771: LD_INT 1
30773: EQUAL
30774: IFFALSE 30790
// Say ( JMM , DAb-JMM-1a ) else
30776: LD_EXP 39
30780: PPUSH
30781: LD_STRING DAb-JMM-1a
30783: PPUSH
30784: CALL_OW 88
30788: GO 30802
// Say ( JMM , DAb-JMM-1b ) ;
30790: LD_EXP 39
30794: PPUSH
30795: LD_STRING DAb-JMM-1b
30797: PPUSH
30798: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
30802: LD_EXP 35
30806: PPUSH
30807: CALL_OW 87
// for i in trueAmericans do
30811: LD_ADDR_VAR 0 2
30815: PUSH
30816: LD_EXP 35
30820: PUSH
30821: FOR_IN
30822: IFFALSE 30838
// SetSide ( i , 1 ) ;
30824: LD_VAR 0 2
30828: PPUSH
30829: LD_INT 1
30831: PPUSH
30832: CALL_OW 235
30836: GO 30821
30838: POP
30839: POP
// end ; repeat wait ( 0 0$1 ) ;
30840: LD_INT 35
30842: PPUSH
30843: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
30847: LD_ADDR_VAR 0 2
30851: PUSH
30852: LD_INT 22
30854: PUSH
30855: LD_INT 7
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: PUSH
30862: LD_INT 21
30864: PUSH
30865: LD_INT 1
30867: PUSH
30868: EMPTY
30869: LIST
30870: LIST
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: PPUSH
30876: CALL_OW 69
30880: PUSH
30881: FOR_IN
30882: IFFALSE 30964
// begin if IsInUnit ( i ) then
30884: LD_VAR 0 2
30888: PPUSH
30889: CALL_OW 310
30893: IFFALSE 30904
// ComExitBuilding ( i ) ;
30895: LD_VAR 0 2
30899: PPUSH
30900: CALL_OW 122
// if IsDriver ( i ) then
30904: LD_VAR 0 2
30908: PPUSH
30909: CALL 105549 0 1
30913: IFFALSE 30924
// ComExitVehicle ( i ) ;
30915: LD_VAR 0 2
30919: PPUSH
30920: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30924: LD_VAR 0 2
30928: PPUSH
30929: LD_INT 26
30931: PPUSH
30932: CALL_OW 308
30936: NOT
30937: IFFALSE 30953
// AddComMoveToArea ( i , allianceEscapeArea ) else
30939: LD_VAR 0 2
30943: PPUSH
30944: LD_INT 26
30946: PPUSH
30947: CALL_OW 173
30951: GO 30962
// RemoveUnit ( i ) ;
30953: LD_VAR 0 2
30957: PPUSH
30958: CALL_OW 64
// end ;
30962: GO 30881
30964: POP
30965: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30966: LD_INT 22
30968: PUSH
30969: LD_INT 7
30971: PUSH
30972: EMPTY
30973: LIST
30974: LIST
30975: PUSH
30976: LD_INT 21
30978: PUSH
30979: LD_INT 1
30981: PUSH
30982: EMPTY
30983: LIST
30984: LIST
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PPUSH
30990: CALL_OW 69
30994: NOT
30995: IFFALSE 30840
// end ;
30997: PPOPN 2
30999: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31000: LD_INT 0
31002: PPUSH
31003: PPUSH
// if not unit then
31004: LD_VAR 0 1
31008: NOT
31009: IFFALSE 31013
// exit ;
31011: GO 32511
// DoNotAttack ( 7 , unit ) ;
31013: LD_INT 7
31015: PPUSH
31016: LD_VAR 0 1
31020: PPUSH
31021: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31025: LD_VAR 0 1
31029: PPUSH
31030: LD_INT 260
31032: PPUSH
31033: LD_INT 235
31035: PPUSH
31036: LD_INT 3
31038: PPUSH
31039: LD_INT 1
31041: PPUSH
31042: CALL_OW 483
// SetSide ( unit , 4 ) ;
31046: LD_VAR 0 1
31050: PPUSH
31051: LD_INT 4
31053: PPUSH
31054: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31058: LD_ADDR_EXP 34
31062: PUSH
31063: LD_EXP 34
31067: PUSH
31068: LD_INT 1
31070: PLUS
31071: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31072: LD_INT 70
31074: PPUSH
31075: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31079: LD_INT 260
31081: PPUSH
31082: LD_INT 235
31084: PPUSH
31085: LD_INT 1
31087: PPUSH
31088: LD_INT 8
31090: NEG
31091: PPUSH
31092: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31096: LD_VAR 0 1
31100: PPUSH
31101: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31105: LD_VAR 0 1
31109: PPUSH
31110: LD_EXP 74
31114: PPUSH
31115: CALL_OW 119
// DialogueOn ;
31119: CALL_OW 6
// case unit of JMM :
31123: LD_VAR 0 1
31127: PUSH
31128: LD_EXP 39
31132: DOUBLE
31133: EQUAL
31134: IFTRUE 31138
31136: GO 31153
31138: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31139: LD_EXP 39
31143: PPUSH
31144: LD_STRING DA1-JMM-1
31146: PPUSH
31147: CALL_OW 91
31151: GO 31595
31153: LD_EXP 40
31157: DOUBLE
31158: EQUAL
31159: IFTRUE 31163
31161: GO 31178
31163: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31164: LD_EXP 40
31168: PPUSH
31169: LD_STRING DA1-Joan-1
31171: PPUSH
31172: CALL_OW 91
31176: GO 31595
31178: LD_EXP 42
31182: DOUBLE
31183: EQUAL
31184: IFTRUE 31188
31186: GO 31203
31188: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31189: LD_EXP 42
31193: PPUSH
31194: LD_STRING DA1-Lisa-1
31196: PPUSH
31197: CALL_OW 91
31201: GO 31595
31203: LD_EXP 43
31207: DOUBLE
31208: EQUAL
31209: IFTRUE 31213
31211: GO 31228
31213: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31214: LD_EXP 43
31218: PPUSH
31219: LD_STRING DA1-Don-1
31221: PPUSH
31222: CALL_OW 91
31226: GO 31595
31228: LD_EXP 50
31232: DOUBLE
31233: EQUAL
31234: IFTRUE 31238
31236: GO 31253
31238: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31239: LD_EXP 50
31243: PPUSH
31244: LD_STRING DA1-Corn-1
31246: PPUSH
31247: CALL_OW 91
31251: GO 31595
31253: LD_EXP 46
31257: DOUBLE
31258: EQUAL
31259: IFTRUE 31263
31261: GO 31278
31263: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31264: LD_EXP 46
31268: PPUSH
31269: LD_STRING DA1-Den-1
31271: PPUSH
31272: CALL_OW 91
31276: GO 31595
31278: LD_EXP 44
31282: DOUBLE
31283: EQUAL
31284: IFTRUE 31288
31286: GO 31303
31288: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31289: LD_EXP 44
31293: PPUSH
31294: LD_STRING DA1-Bobby-1
31296: PPUSH
31297: CALL_OW 91
31301: GO 31595
31303: LD_EXP 48
31307: DOUBLE
31308: EQUAL
31309: IFTRUE 31313
31311: GO 31328
31313: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31314: LD_EXP 48
31318: PPUSH
31319: LD_STRING DA1-Glad-1
31321: PPUSH
31322: CALL_OW 91
31326: GO 31595
31328: LD_EXP 45
31332: DOUBLE
31333: EQUAL
31334: IFTRUE 31338
31336: GO 31353
31338: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31339: LD_EXP 45
31343: PPUSH
31344: LD_STRING DA1-Cyrus-1
31346: PPUSH
31347: CALL_OW 91
31351: GO 31595
31353: LD_EXP 41
31357: DOUBLE
31358: EQUAL
31359: IFTRUE 31363
31361: GO 31378
31363: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31364: LD_EXP 41
31368: PPUSH
31369: LD_STRING DA1-Huck-1
31371: PPUSH
31372: CALL_OW 91
31376: GO 31595
31378: LD_EXP 55
31382: DOUBLE
31383: EQUAL
31384: IFTRUE 31388
31386: GO 31403
31388: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31389: LD_EXP 55
31393: PPUSH
31394: LD_STRING DA1-Huck-1
31396: PPUSH
31397: CALL_OW 91
31401: GO 31595
31403: LD_EXP 47
31407: DOUBLE
31408: EQUAL
31409: IFTRUE 31413
31411: GO 31428
31413: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31414: LD_EXP 47
31418: PPUSH
31419: LD_STRING DA1-Brown-1
31421: PPUSH
31422: CALL_OW 91
31426: GO 31595
31428: LD_EXP 51
31432: DOUBLE
31433: EQUAL
31434: IFTRUE 31438
31436: GO 31453
31438: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31439: LD_EXP 51
31443: PPUSH
31444: LD_STRING DA1-Gary-1
31446: PPUSH
31447: CALL_OW 91
31451: GO 31595
31453: LD_EXP 54
31457: DOUBLE
31458: EQUAL
31459: IFTRUE 31463
31461: GO 31478
31463: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31464: LD_EXP 54
31468: PPUSH
31469: LD_STRING DA1-Con-1
31471: PPUSH
31472: CALL_OW 91
31476: GO 31595
31478: LD_EXP 60
31482: DOUBLE
31483: EQUAL
31484: IFTRUE 31488
31486: GO 31503
31488: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31489: LD_EXP 60
31493: PPUSH
31494: LD_STRING DA1-Kurt-1
31496: PPUSH
31497: CALL_OW 91
31501: GO 31595
31503: LD_EXP 53
31507: DOUBLE
31508: EQUAL
31509: IFTRUE 31513
31511: GO 31528
31513: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31514: LD_EXP 53
31518: PPUSH
31519: LD_STRING DA1-Yam-1
31521: PPUSH
31522: CALL_OW 91
31526: GO 31595
31528: LD_EXP 52
31532: DOUBLE
31533: EQUAL
31534: IFTRUE 31538
31536: GO 31553
31538: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31539: LD_EXP 52
31543: PPUSH
31544: LD_STRING DA1-Frank-1
31546: PPUSH
31547: CALL_OW 91
31551: GO 31595
31553: POP
// begin if GetSex ( unit ) = sex_male then
31554: LD_VAR 0 1
31558: PPUSH
31559: CALL_OW 258
31563: PUSH
31564: LD_INT 1
31566: EQUAL
31567: IFFALSE 31583
// ForceSay ( unit , DA1-Sol1-1 ) else
31569: LD_VAR 0 1
31573: PPUSH
31574: LD_STRING DA1-Sol1-1
31576: PPUSH
31577: CALL_OW 91
31581: GO 31595
// ForceSay ( unit , DA1-FSol1-1 ) ;
31583: LD_VAR 0 1
31587: PPUSH
31588: LD_STRING DA1-FSol1-1
31590: PPUSH
31591: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31595: LD_EXP 74
31599: PPUSH
31600: LD_STRING DA-Roth-1
31602: PPUSH
31603: CALL_OW 88
// if capturedUnit = 1 then
31607: LD_EXP 34
31611: PUSH
31612: LD_INT 1
31614: EQUAL
31615: IFFALSE 31643
// begin Say ( Simms , DA-Sim-1 ) ;
31617: LD_EXP 75
31621: PPUSH
31622: LD_STRING DA-Sim-1
31624: PPUSH
31625: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31629: LD_EXP 74
31633: PPUSH
31634: LD_STRING DA-Roth-2
31636: PPUSH
31637: CALL_OW 88
// end else
31641: GO 31655
// Say ( Simms , DA-Sim-2 ) ;
31643: LD_EXP 75
31647: PPUSH
31648: LD_STRING DA-Sim-2
31650: PPUSH
31651: CALL_OW 88
// case unit of JMM :
31655: LD_VAR 0 1
31659: PUSH
31660: LD_EXP 39
31664: DOUBLE
31665: EQUAL
31666: IFTRUE 31670
31668: GO 31685
31670: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31671: LD_EXP 39
31675: PPUSH
31676: LD_STRING DA1-JMM-1a
31678: PPUSH
31679: CALL_OW 91
31683: GO 32192
31685: LD_EXP 40
31689: DOUBLE
31690: EQUAL
31691: IFTRUE 31695
31693: GO 31710
31695: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31696: LD_EXP 40
31700: PPUSH
31701: LD_STRING DA1-Joan-1a
31703: PPUSH
31704: CALL_OW 91
31708: GO 32192
31710: LD_EXP 42
31714: DOUBLE
31715: EQUAL
31716: IFTRUE 31720
31718: GO 31735
31720: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31721: LD_EXP 42
31725: PPUSH
31726: LD_STRING DA1-Lisa-1a
31728: PPUSH
31729: CALL_OW 91
31733: GO 32192
31735: LD_EXP 43
31739: DOUBLE
31740: EQUAL
31741: IFTRUE 31745
31743: GO 31760
31745: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
31746: LD_EXP 43
31750: PPUSH
31751: LD_STRING DA1-Don-1a
31753: PPUSH
31754: CALL_OW 91
31758: GO 32192
31760: LD_EXP 50
31764: DOUBLE
31765: EQUAL
31766: IFTRUE 31770
31768: GO 31785
31770: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
31771: LD_EXP 50
31775: PPUSH
31776: LD_STRING DA1-Corn-1a
31778: PPUSH
31779: CALL_OW 91
31783: GO 32192
31785: LD_EXP 46
31789: DOUBLE
31790: EQUAL
31791: IFTRUE 31795
31793: GO 31810
31795: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
31796: LD_EXP 46
31800: PPUSH
31801: LD_STRING DA1-Den-1a
31803: PPUSH
31804: CALL_OW 91
31808: GO 32192
31810: LD_EXP 44
31814: DOUBLE
31815: EQUAL
31816: IFTRUE 31820
31818: GO 31835
31820: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
31821: LD_EXP 44
31825: PPUSH
31826: LD_STRING DA1-Bobby-1a
31828: PPUSH
31829: CALL_OW 91
31833: GO 32192
31835: LD_EXP 48
31839: DOUBLE
31840: EQUAL
31841: IFTRUE 31845
31843: GO 31860
31845: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
31846: LD_EXP 48
31850: PPUSH
31851: LD_STRING DA1-Glad-1a
31853: PPUSH
31854: CALL_OW 91
31858: GO 32192
31860: LD_EXP 45
31864: DOUBLE
31865: EQUAL
31866: IFTRUE 31870
31868: GO 31885
31870: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
31871: LD_EXP 45
31875: PPUSH
31876: LD_STRING DA1-Cyrus-1a
31878: PPUSH
31879: CALL_OW 91
31883: GO 32192
31885: LD_EXP 41
31889: DOUBLE
31890: EQUAL
31891: IFTRUE 31895
31893: GO 31910
31895: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31896: LD_EXP 41
31900: PPUSH
31901: LD_STRING DA1-Huck-1a
31903: PPUSH
31904: CALL_OW 91
31908: GO 32192
31910: LD_EXP 55
31914: DOUBLE
31915: EQUAL
31916: IFTRUE 31920
31918: GO 31935
31920: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31921: LD_EXP 55
31925: PPUSH
31926: LD_STRING DA1-Huck-1a
31928: PPUSH
31929: CALL_OW 91
31933: GO 32192
31935: LD_EXP 47
31939: DOUBLE
31940: EQUAL
31941: IFTRUE 31945
31943: GO 31960
31945: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31946: LD_EXP 47
31950: PPUSH
31951: LD_STRING DA1-Brown-1a
31953: PPUSH
31954: CALL_OW 91
31958: GO 32192
31960: LD_EXP 51
31964: DOUBLE
31965: EQUAL
31966: IFTRUE 31970
31968: GO 31985
31970: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31971: LD_EXP 51
31975: PPUSH
31976: LD_STRING DA1-Gary-1a
31978: PPUSH
31979: CALL_OW 91
31983: GO 32192
31985: LD_EXP 54
31989: DOUBLE
31990: EQUAL
31991: IFTRUE 31995
31993: GO 32010
31995: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31996: LD_EXP 54
32000: PPUSH
32001: LD_STRING DA1-Con-1a
32003: PPUSH
32004: CALL_OW 91
32008: GO 32192
32010: LD_EXP 60
32014: DOUBLE
32015: EQUAL
32016: IFTRUE 32020
32018: GO 32035
32020: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32021: LD_EXP 60
32025: PPUSH
32026: LD_STRING DA1-Kurt-1a
32028: PPUSH
32029: CALL_OW 91
32033: GO 32192
32035: LD_EXP 53
32039: DOUBLE
32040: EQUAL
32041: IFTRUE 32045
32043: GO 32060
32045: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32046: LD_EXP 53
32050: PPUSH
32051: LD_STRING DA1-Yam-1a
32053: PPUSH
32054: CALL_OW 91
32058: GO 32192
32060: LD_EXP 52
32064: DOUBLE
32065: EQUAL
32066: IFTRUE 32070
32068: GO 32085
32070: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32071: LD_EXP 52
32075: PPUSH
32076: LD_STRING DA1-Frank-1a
32078: PPUSH
32079: CALL_OW 91
32083: GO 32192
32085: POP
// begin join := rand ( 0 , 1 ) ;
32086: LD_ADDR_VAR 0 3
32090: PUSH
32091: LD_INT 0
32093: PPUSH
32094: LD_INT 1
32096: PPUSH
32097: CALL_OW 12
32101: ST_TO_ADDR
// if join then
32102: LD_VAR 0 3
32106: IFFALSE 32151
// begin if GetSex ( unit ) = sex_male then
32108: LD_VAR 0 1
32112: PPUSH
32113: CALL_OW 258
32117: PUSH
32118: LD_INT 1
32120: EQUAL
32121: IFFALSE 32137
// ForceSay ( unit , DA1-Sol1-1b ) else
32123: LD_VAR 0 1
32127: PPUSH
32128: LD_STRING DA1-Sol1-1b
32130: PPUSH
32131: CALL_OW 91
32135: GO 32149
// ForceSay ( unit , DA1-FSol1-1b ) ;
32137: LD_VAR 0 1
32141: PPUSH
32142: LD_STRING DA1-FSol1-1b
32144: PPUSH
32145: CALL_OW 91
// end else
32149: GO 32192
// begin if GetSex ( unit ) = sex_male then
32151: LD_VAR 0 1
32155: PPUSH
32156: CALL_OW 258
32160: PUSH
32161: LD_INT 1
32163: EQUAL
32164: IFFALSE 32180
// ForceSay ( unit , DA1-Sol1-1a ) else
32166: LD_VAR 0 1
32170: PPUSH
32171: LD_STRING DA1-Sol1-1a
32173: PPUSH
32174: CALL_OW 91
32178: GO 32192
// ForceSay ( unit , DA1-FSol1-1a ) ;
32180: LD_VAR 0 1
32184: PPUSH
32185: LD_STRING DA1-FSol1-1a
32187: PPUSH
32188: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32192: LD_VAR 0 1
32196: PUSH
32197: LD_EXP 39
32201: EQUAL
32202: IFFALSE 32213
// begin YouLost ( JMMCaptured ) ;
32204: LD_STRING JMMCaptured
32206: PPUSH
32207: CALL_OW 104
// exit ;
32211: GO 32511
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32213: LD_VAR 0 1
32217: PUSH
32218: LD_EXP 43
32222: PUSH
32223: LD_EXP 46
32227: PUSH
32228: LD_EXP 44
32232: PUSH
32233: LD_EXP 41
32237: PUSH
32238: LD_EXP 55
32242: PUSH
32243: LD_EXP 47
32247: PUSH
32248: LD_EXP 53
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: LIST
32257: LIST
32258: LIST
32259: LIST
32260: LIST
32261: IN
32262: PUSH
32263: LD_VAR 0 3
32267: OR
32268: IFFALSE 32367
// begin Say ( Roth , DA-Roth-3 ) ;
32270: LD_EXP 74
32274: PPUSH
32275: LD_STRING DA-Roth-3
32277: PPUSH
32278: CALL_OW 88
// SetSide ( unit , 7 ) ;
32282: LD_VAR 0 1
32286: PPUSH
32287: LD_INT 7
32289: PPUSH
32290: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32294: LD_ADDR_EXP 102
32298: PUSH
32299: LD_EXP 102
32303: PPUSH
32304: LD_INT 1
32306: PPUSH
32307: LD_EXP 102
32311: PUSH
32312: LD_INT 1
32314: ARRAY
32315: PUSH
32316: LD_VAR 0 1
32320: ADD
32321: PPUSH
32322: CALL_OW 1
32326: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32327: LD_INT 260
32329: PPUSH
32330: LD_INT 235
32332: PPUSH
32333: LD_INT 1
32335: PPUSH
32336: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32340: LD_VAR 0 1
32344: PPUSH
32345: LD_INT 1000
32347: PPUSH
32348: CALL_OW 234
// DialogueOff ;
32352: CALL_OW 7
// ComFree ( unit ) ;
32356: LD_VAR 0 1
32360: PPUSH
32361: CALL_OW 139
// end else
32365: GO 32448
// begin Say ( Roth , DA-Roth-3a ) ;
32367: LD_EXP 74
32371: PPUSH
32372: LD_STRING DA-Roth-3a
32374: PPUSH
32375: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32379: LD_ADDR_EXP 35
32383: PUSH
32384: LD_EXP 35
32388: PUSH
32389: LD_VAR 0 1
32393: ADD
32394: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32395: LD_INT 260
32397: PPUSH
32398: LD_INT 235
32400: PPUSH
32401: LD_INT 1
32403: PPUSH
32404: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32408: LD_VAR 0 1
32412: PPUSH
32413: LD_INT 1000
32415: PPUSH
32416: CALL_OW 234
// DialogueOff ;
32420: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32424: LD_VAR 0 1
32428: PPUSH
32429: LD_INT 272
32431: PPUSH
32432: LD_INT 254
32434: PPUSH
32435: CALL_OW 111
// AddComHold ( unit ) ;
32439: LD_VAR 0 1
32443: PPUSH
32444: CALL_OW 200
// end ; if capturedUnit = 1 then
32448: LD_EXP 34
32452: PUSH
32453: LD_INT 1
32455: EQUAL
32456: IFFALSE 32511
// begin DialogueOn ;
32458: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32462: LD_EXP 39
32466: PPUSH
32467: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32471: LD_EXP 39
32475: PPUSH
32476: LD_STRING DAa-JMM-1
32478: PPUSH
32479: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32483: LD_EXP 39
32487: PPUSH
32488: LD_STRING DAa-JMM-1a
32490: PPUSH
32491: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32495: LD_EXP 39
32499: PPUSH
32500: LD_STRING DAa-JMM-1b
32502: PPUSH
32503: CALL_OW 88
// DialogueOff ;
32507: CALL_OW 7
// end ; end ;
32511: LD_VAR 0 2
32515: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32516: LD_EXP 15
32520: PUSH
32521: LD_INT 13
32523: GREATEREQUAL
32524: PUSH
32525: LD_INT 22
32527: PUSH
32528: LD_INT 2
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 21
32537: PUSH
32538: LD_INT 1
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: EMPTY
32546: LIST
32547: LIST
32548: PPUSH
32549: CALL_OW 69
32553: PUSH
32554: LD_INT 0
32556: EQUAL
32557: AND
32558: PUSH
32559: LD_INT 22
32561: PUSH
32562: LD_INT 2
32564: PUSH
32565: EMPTY
32566: LIST
32567: LIST
32568: PUSH
32569: LD_INT 21
32571: PUSH
32572: LD_INT 2
32574: PUSH
32575: EMPTY
32576: LIST
32577: LIST
32578: PUSH
32579: LD_INT 50
32581: PUSH
32582: EMPTY
32583: LIST
32584: PUSH
32585: EMPTY
32586: LIST
32587: LIST
32588: LIST
32589: PPUSH
32590: CALL_OW 69
32594: PUSH
32595: LD_INT 0
32597: EQUAL
32598: AND
32599: PUSH
32600: LD_EXP 21
32604: AND
32605: PUSH
32606: LD_EXP 22
32610: AND
32611: PUSH
32612: LD_EXP 23
32616: AND
32617: IFFALSE 33259
32619: GO 32621
32621: DISABLE
32622: LD_INT 0
32624: PPUSH
32625: PPUSH
32626: PPUSH
// begin m1 := false ;
32627: LD_ADDR_VAR 0 1
32631: PUSH
32632: LD_INT 0
32634: ST_TO_ADDR
// m2 := false ;
32635: LD_ADDR_VAR 0 2
32639: PUSH
32640: LD_INT 0
32642: ST_TO_ADDR
// m3 := false ;
32643: LD_ADDR_VAR 0 3
32647: PUSH
32648: LD_INT 0
32650: ST_TO_ADDR
// if not bombExploded then
32651: LD_EXP 37
32655: NOT
32656: IFFALSE 32665
// SetAchievement ( ACH_SIBROCKET ) ;
32658: LD_STRING ACH_SIBROCKET
32660: PPUSH
32661: CALL_OW 543
// if tick <= 120 120$00 then
32665: LD_OWVAR 1
32669: PUSH
32670: LD_INT 252000
32672: LESSEQUAL
32673: IFFALSE 32689
// begin wait ( 3 ) ;
32675: LD_INT 3
32677: PPUSH
32678: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32682: LD_STRING ACH_ASPEED_15
32684: PPUSH
32685: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32689: LD_EXP 39
32693: PPUSH
32694: CALL_OW 87
// music_class := 5 ;
32698: LD_ADDR_OWVAR 72
32702: PUSH
32703: LD_INT 5
32705: ST_TO_ADDR
// music_nat := 5 ;
32706: LD_ADDR_OWVAR 71
32710: PUSH
32711: LD_INT 5
32713: ST_TO_ADDR
// DialogueOn ;
32714: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
32718: LD_EXP 39
32722: PPUSH
32723: LD_STRING D20-JMM-1
32725: PPUSH
32726: CALL_OW 88
// if IsOK ( Joan ) then
32730: LD_EXP 40
32734: PPUSH
32735: CALL_OW 302
32739: IFFALSE 32753
// Say ( Joan , D20-Joan-1 ) ;
32741: LD_EXP 40
32745: PPUSH
32746: LD_STRING D20-Joan-1
32748: PPUSH
32749: CALL_OW 88
// if IsOk ( Lisa ) then
32753: LD_EXP 42
32757: PPUSH
32758: CALL_OW 302
32762: IFFALSE 32776
// Say ( Lisa , D20-Lisa-1 ) ;
32764: LD_EXP 42
32768: PPUSH
32769: LD_STRING D20-Lisa-1
32771: PPUSH
32772: CALL_OW 88
// if IsOk ( Donaldson ) then
32776: LD_EXP 43
32780: PPUSH
32781: CALL_OW 302
32785: IFFALSE 32799
// Say ( Donaldson , D20-Don-1 ) ;
32787: LD_EXP 43
32791: PPUSH
32792: LD_STRING D20-Don-1
32794: PPUSH
32795: CALL_OW 88
// if IsOK ( Cornel ) then
32799: LD_EXP 50
32803: PPUSH
32804: CALL_OW 302
32808: IFFALSE 32822
// Say ( Cornel , D20-Corn-1 ) ;
32810: LD_EXP 50
32814: PPUSH
32815: LD_STRING D20-Corn-1
32817: PPUSH
32818: CALL_OW 88
// if IsOk ( Denis ) then
32822: LD_EXP 46
32826: PPUSH
32827: CALL_OW 302
32831: IFFALSE 32845
// Say ( Denis , D20-Den-1 ) ;
32833: LD_EXP 46
32837: PPUSH
32838: LD_STRING D20-Den-1
32840: PPUSH
32841: CALL_OW 88
// if IsOk ( Bobby ) then
32845: LD_EXP 44
32849: PPUSH
32850: CALL_OW 302
32854: IFFALSE 32868
// Say ( Bobby , D20-Bobby-1 ) ;
32856: LD_EXP 44
32860: PPUSH
32861: LD_STRING D20-Bobby-1
32863: PPUSH
32864: CALL_OW 88
// if IsOk ( Gladstone ) then
32868: LD_EXP 48
32872: PPUSH
32873: CALL_OW 302
32877: IFFALSE 32891
// Say ( Gladstone , D20-Glad-1 ) ;
32879: LD_EXP 48
32883: PPUSH
32884: LD_STRING D20-Glad-1
32886: PPUSH
32887: CALL_OW 88
// if IsOk ( Cyrus ) then
32891: LD_EXP 45
32895: PPUSH
32896: CALL_OW 302
32900: IFFALSE 32914
// Say ( Cyrus , D20-Cyrus-1 ) ;
32902: LD_EXP 45
32906: PPUSH
32907: LD_STRING D20-Cyrus-1
32909: PPUSH
32910: CALL_OW 88
// if IsOk ( Stevens ) then
32914: LD_EXP 41
32918: PPUSH
32919: CALL_OW 302
32923: IFFALSE 32937
// Say ( Stevens , D20-Huck-1 ) ;
32925: LD_EXP 41
32929: PPUSH
32930: LD_STRING D20-Huck-1
32932: PPUSH
32933: CALL_OW 88
// if IsOk ( Brown ) then
32937: LD_EXP 47
32941: PPUSH
32942: CALL_OW 302
32946: IFFALSE 32960
// Say ( Brown , D20-Brown-1 ) ;
32948: LD_EXP 47
32952: PPUSH
32953: LD_STRING D20-Brown-1
32955: PPUSH
32956: CALL_OW 88
// if IsOk ( Gary ) then
32960: LD_EXP 51
32964: PPUSH
32965: CALL_OW 302
32969: IFFALSE 32983
// Say ( Gary , D20-Gary-1 ) ;
32971: LD_EXP 51
32975: PPUSH
32976: LD_STRING D20-Gary-1
32978: PPUSH
32979: CALL_OW 88
// if IsOk ( Connie ) then
32983: LD_EXP 54
32987: PPUSH
32988: CALL_OW 302
32992: IFFALSE 33006
// Say ( Connie , D20-Con-1 ) ;
32994: LD_EXP 54
32998: PPUSH
32999: LD_STRING D20-Con-1
33001: PPUSH
33002: CALL_OW 88
// if IsOk ( Kurt ) then
33006: LD_EXP 60
33010: PPUSH
33011: CALL_OW 302
33015: IFFALSE 33029
// Say ( Kurt , D20-Kurt-1 ) ;
33017: LD_EXP 60
33021: PPUSH
33022: LD_STRING D20-Kurt-1
33024: PPUSH
33025: CALL_OW 88
// if IsOk ( Kikuchi ) then
33029: LD_EXP 53
33033: PPUSH
33034: CALL_OW 302
33038: IFFALSE 33052
// Say ( Kikuchi , D20-Yam-1 ) ;
33040: LD_EXP 53
33044: PPUSH
33045: LD_STRING D20-Yam-1
33047: PPUSH
33048: CALL_OW 88
// if IsOk ( Frank ) then
33052: LD_EXP 52
33056: PPUSH
33057: CALL_OW 302
33061: IFFALSE 33075
// Say ( Frank , D20-Frank-1 ) ;
33063: LD_EXP 52
33067: PPUSH
33068: LD_STRING D20-Frank-1
33070: PPUSH
33071: CALL_OW 88
// DialogueOff ;
33075: CALL_OW 7
// if RothCaptured then
33079: LD_EXP 33
33083: IFFALSE 33105
// begin m1 := true ;
33085: LD_ADDR_VAR 0 1
33089: PUSH
33090: LD_INT 1
33092: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33093: LD_STRING Roth
33095: PPUSH
33096: LD_INT 1
33098: PPUSH
33099: CALL_OW 101
// end else
33103: GO 33116
// AddMedal ( Roth , - 1 ) ;
33105: LD_STRING Roth
33107: PPUSH
33108: LD_INT 1
33110: NEG
33111: PPUSH
33112: CALL_OW 101
// if behemothDestroyedBeforeFinish then
33116: LD_EXP 27
33120: IFFALSE 33142
// begin m2 := true ;
33122: LD_ADDR_VAR 0 2
33126: PUSH
33127: LD_INT 1
33129: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33130: LD_STRING Project
33132: PPUSH
33133: LD_INT 1
33135: PPUSH
33136: CALL_OW 101
// end else
33140: GO 33153
// AddMedal ( Project , - 1 ) ;
33142: LD_STRING Project
33144: PPUSH
33145: LD_INT 1
33147: NEG
33148: PPUSH
33149: CALL_OW 101
// if lostCounter = 0 then
33153: LD_EXP 32
33157: PUSH
33158: LD_INT 0
33160: EQUAL
33161: IFFALSE 33183
// begin m3 := true ;
33163: LD_ADDR_VAR 0 3
33167: PUSH
33168: LD_INT 1
33170: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33171: LD_STRING NoLosses
33173: PPUSH
33174: LD_INT 1
33176: PPUSH
33177: CALL_OW 101
// end else
33181: GO 33194
// AddMedal ( NoLosses , - 1 ) ;
33183: LD_STRING NoLosses
33185: PPUSH
33186: LD_INT 1
33188: NEG
33189: PPUSH
33190: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
33194: LD_VAR 0 1
33198: PUSH
33199: LD_VAR 0 2
33203: AND
33204: PUSH
33205: LD_VAR 0 3
33209: AND
33210: PUSH
33211: LD_OWVAR 67
33215: PUSH
33216: LD_INT 3
33218: EQUAL
33219: AND
33220: IFFALSE 33232
// SetAchievementEX ( ACH_AMER , 15 ) ;
33222: LD_STRING ACH_AMER
33224: PPUSH
33225: LD_INT 15
33227: PPUSH
33228: CALL_OW 564
// GiveMedals ( MAIN ) ;
33232: LD_STRING MAIN
33234: PPUSH
33235: CALL_OW 102
// music_class := 4 ;
33239: LD_ADDR_OWVAR 72
33243: PUSH
33244: LD_INT 4
33246: ST_TO_ADDR
// music_nat := 1 ;
33247: LD_ADDR_OWVAR 71
33251: PUSH
33252: LD_INT 1
33254: ST_TO_ADDR
// YouWin ;
33255: CALL_OW 103
// end ; end_of_file
33259: PPOPN 3
33261: END
// export function CustomEvent ( event ) ; begin
33262: LD_INT 0
33264: PPUSH
// end ;
33265: LD_VAR 0 2
33269: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33270: LD_VAR 0 1
33274: PUSH
33275: LD_INT 1
33277: EQUAL
33278: PUSH
33279: LD_VAR 0 2
33283: PUSH
33284: LD_INT 4
33286: EQUAL
33287: AND
33288: PUSH
33289: LD_EXP 58
33293: PPUSH
33294: CALL_OW 300
33298: AND
33299: IFFALSE 33315
// begin wait ( 0 0$2 ) ;
33301: LD_INT 70
33303: PPUSH
33304: CALL_OW 67
// YouLost ( Dismissed ) ;
33308: LD_STRING Dismissed
33310: PPUSH
33311: CALL_OW 104
// end ; end ;
33315: PPOPN 2
33317: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33318: LD_VAR 0 2
33322: PPUSH
33323: LD_VAR 0 3
33327: PPUSH
33328: LD_INT 18
33330: PPUSH
33331: CALL_OW 309
33335: IFFALSE 33344
// YouLost ( Motherlode3 ) ;
33337: LD_STRING Motherlode3
33339: PPUSH
33340: CALL_OW 104
// end ;
33344: PPOPN 3
33346: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33347: LD_EXP 27
33351: NOT
33352: IFFALSE 33362
// behemothDone := true ;
33354: LD_ADDR_EXP 28
33358: PUSH
33359: LD_INT 1
33361: ST_TO_ADDR
// end ;
33362: PPOPN 1
33364: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33365: LD_VAR 0 1
33369: PPUSH
33370: CALL_OW 255
33374: PUSH
33375: LD_INT 1
33377: EQUAL
33378: IFFALSE 33388
// bombExploded := true ;
33380: LD_ADDR_EXP 37
33384: PUSH
33385: LD_INT 1
33387: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33388: LD_VAR 0 1
33392: PPUSH
33393: CALL_OW 255
33397: PUSH
33398: LD_INT 1
33400: EQUAL
33401: PUSH
33402: LD_EXP 30
33406: AND
33407: PUSH
33408: LD_INT 22
33410: PUSH
33411: LD_INT 3
33413: PUSH
33414: EMPTY
33415: LIST
33416: LIST
33417: PUSH
33418: LD_INT 34
33420: PUSH
33421: LD_INT 48
33423: PUSH
33424: EMPTY
33425: LIST
33426: LIST
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PPUSH
33432: CALL_OW 69
33436: AND
33437: PUSH
33438: LD_INT 22
33440: PUSH
33441: LD_INT 1
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 34
33450: PUSH
33451: LD_INT 8
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PUSH
33458: EMPTY
33459: LIST
33460: LIST
33461: PPUSH
33462: CALL_OW 69
33466: NOT
33467: AND
33468: IFFALSE 33520
// begin wait ( 0 0$5 ) ;
33470: LD_INT 175
33472: PPUSH
33473: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33477: LD_INT 22
33479: PUSH
33480: LD_INT 3
33482: PUSH
33483: EMPTY
33484: LIST
33485: LIST
33486: PUSH
33487: LD_INT 34
33489: PUSH
33490: LD_INT 48
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: EMPTY
33498: LIST
33499: LIST
33500: PPUSH
33501: CALL_OW 69
33505: PUSH
33506: LD_INT 1
33508: ARRAY
33509: PPUSH
33510: LD_INT 60
33512: PPUSH
33513: LD_INT 95
33515: PPUSH
33516: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33520: LD_VAR 0 2
33524: PPUSH
33525: LD_VAR 0 3
33529: PPUSH
33530: LD_INT 18
33532: PPUSH
33533: CALL_OW 309
33537: IFFALSE 33597
// begin if GetSide ( unit ) = 1 then
33539: LD_VAR 0 1
33543: PPUSH
33544: CALL_OW 255
33548: PUSH
33549: LD_INT 1
33551: EQUAL
33552: IFFALSE 33568
// begin wait ( 0 0$6 ) ;
33554: LD_INT 210
33556: PPUSH
33557: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33561: LD_STRING Motherlode2
33563: PPUSH
33564: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
33568: LD_VAR 0 1
33572: PPUSH
33573: CALL_OW 255
33577: PUSH
33578: LD_INT 8
33580: EQUAL
33581: IFFALSE 33597
// begin wait ( 0 0$6 ) ;
33583: LD_INT 210
33585: PPUSH
33586: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33590: LD_STRING Motherlode1
33592: PPUSH
33593: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33597: LD_VAR 0 1
33601: PPUSH
33602: CALL_OW 255
33606: PUSH
33607: LD_INT 3
33609: EQUAL
33610: IFFALSE 33631
// begin wait ( 0 0$5 ) ;
33612: LD_INT 175
33614: PPUSH
33615: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33619: LD_EXP 64
33623: PPUSH
33624: LD_STRING D18-Pla-1
33626: PPUSH
33627: CALL_OW 94
// end ; end ;
33631: PPOPN 3
33633: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
33634: LD_VAR 0 1
33638: PUSH
33639: LD_EXP 73
33643: IN
33644: IFFALSE 33664
// begin behemothBuilders := behemothBuilders diff un ;
33646: LD_ADDR_EXP 73
33650: PUSH
33651: LD_EXP 73
33655: PUSH
33656: LD_VAR 0 1
33660: DIFF
33661: ST_TO_ADDR
// exit ;
33662: GO 33762
// end ; if un = JMM then
33664: LD_VAR 0 1
33668: PUSH
33669: LD_EXP 39
33673: EQUAL
33674: IFFALSE 33685
// begin YouLost ( JMM ) ;
33676: LD_STRING JMM
33678: PPUSH
33679: CALL_OW 104
// exit ;
33683: GO 33762
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
33685: LD_VAR 0 1
33689: PUSH
33690: LD_INT 22
33692: PUSH
33693: LD_INT 1
33695: PUSH
33696: EMPTY
33697: LIST
33698: LIST
33699: PUSH
33700: LD_INT 3
33702: PUSH
33703: LD_INT 25
33705: PUSH
33706: LD_INT 16
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: LD_INT 25
33715: PUSH
33716: LD_INT 12
33718: PUSH
33719: EMPTY
33720: LIST
33721: LIST
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: LIST
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PPUSH
33732: CALL_OW 69
33736: IN
33737: IFFALSE 33753
// lostCounter := lostCounter + 1 ;
33739: LD_ADDR_EXP 32
33743: PUSH
33744: LD_EXP 32
33748: PUSH
33749: LD_INT 1
33751: PLUS
33752: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
33753: LD_VAR 0 1
33757: PPUSH
33758: CALL 61942 0 1
// end ;
33762: PPOPN 1
33764: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
33765: LD_VAR 0 1
33769: PPUSH
33770: LD_VAR 0 2
33774: PPUSH
33775: CALL 64276 0 2
// end ;
33779: PPOPN 2
33781: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
33782: LD_VAR 0 1
33786: PPUSH
33787: CALL 63344 0 1
// end ;
33791: PPOPN 1
33793: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
33794: LD_VAR 0 1
33798: PUSH
33799: LD_INT 22
33801: PUSH
33802: LD_INT 8
33804: PUSH
33805: EMPTY
33806: LIST
33807: LIST
33808: PUSH
33809: LD_INT 30
33811: PUSH
33812: LD_INT 2
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 23
33821: PUSH
33822: LD_INT 3
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: LIST
33833: PPUSH
33834: CALL_OW 69
33838: IN
33839: IFFALSE 33866
// begin ComUpgrade ( building ) ;
33841: LD_VAR 0 1
33845: PPUSH
33846: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
33850: LD_EXP 61
33854: PPUSH
33855: LD_VAR 0 1
33859: PPUSH
33860: CALL 75042 0 2
// exit ;
33864: GO 33875
// end ; MCE_BuildingComplete ( building ) ;
33866: LD_VAR 0 1
33870: PPUSH
33871: CALL 63585 0 1
// end ;
33875: PPOPN 1
33877: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
33878: LD_VAR 0 1
33882: PPUSH
33883: LD_VAR 0 2
33887: PPUSH
33888: CALL 61638 0 2
// end ;
33892: PPOPN 2
33894: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
33895: LD_VAR 0 1
33899: PPUSH
33900: LD_VAR 0 2
33904: PPUSH
33905: LD_VAR 0 3
33909: PPUSH
33910: LD_VAR 0 4
33914: PPUSH
33915: LD_VAR 0 5
33919: PPUSH
33920: CALL 61258 0 5
// end ;
33924: PPOPN 5
33926: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
33927: LD_VAR 0 1
33931: PPUSH
33932: LD_VAR 0 2
33936: PPUSH
33937: CALL 60854 0 2
// end ;
33941: PPOPN 2
33943: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33944: LD_VAR 0 1
33948: PPUSH
33949: LD_VAR 0 2
33953: PPUSH
33954: LD_VAR 0 3
33958: PPUSH
33959: LD_VAR 0 4
33963: PPUSH
33964: CALL 60692 0 4
// end ;
33968: PPOPN 4
33970: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33971: LD_VAR 0 1
33975: PPUSH
33976: LD_VAR 0 2
33980: PPUSH
33981: LD_VAR 0 3
33985: PPUSH
33986: CALL 60467 0 3
// end ;
33990: PPOPN 3
33992: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33993: LD_VAR 0 1
33997: PPUSH
33998: LD_VAR 0 2
34002: PPUSH
34003: CALL 60352 0 2
// end ;
34007: PPOPN 2
34009: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34010: LD_VAR 0 1
34014: PPUSH
34015: LD_VAR 0 2
34019: PPUSH
34020: CALL 64537 0 2
// end ;
34024: PPOPN 2
34026: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34027: LD_VAR 0 1
34031: PPUSH
34032: CALL_OW 255
34036: PUSH
34037: LD_INT 4
34039: EQUAL
34040: PUSH
34041: LD_VAR 0 1
34045: PUSH
34046: LD_EXP 18
34050: PUSH
34051: LD_INT 1
34053: ARRAY
34054: IN
34055: AND
34056: PUSH
34057: LD_EXP 19
34061: AND
34062: IFFALSE 34081
// begin ComMoveXY ( driver , 61 , 93 ) ;
34064: LD_VAR 0 1
34068: PPUSH
34069: LD_INT 61
34071: PPUSH
34072: LD_INT 93
34074: PPUSH
34075: CALL_OW 111
// exit ;
34079: GO 34105
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34081: LD_VAR 0 1
34085: PPUSH
34086: LD_VAR 0 2
34090: PPUSH
34091: LD_VAR 0 3
34095: PPUSH
34096: LD_VAR 0 4
34100: PPUSH
34101: CALL 64753 0 4
// end ;
34105: PPOPN 4
34107: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34108: LD_VAR 0 1
34112: PPUSH
34113: LD_VAR 0 2
34117: PPUSH
34118: CALL 60161 0 2
// end ;
34122: PPOPN 2
34124: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34125: LD_VAR 0 1
34129: PPUSH
34130: CALL 119063 0 1
// end ; end_of_file
34134: PPOPN 1
34136: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34137: LD_EXP 15
34141: PUSH
34142: LD_INT 2
34144: EQUAL
34145: IFFALSE 34624
34147: GO 34149
34149: DISABLE
34150: LD_INT 0
34152: PPUSH
// begin time := 0 0$40 ;
34153: LD_ADDR_VAR 0 1
34157: PUSH
34158: LD_INT 1400
34160: ST_TO_ADDR
// repeat wait ( time ) ;
34161: LD_VAR 0 1
34165: PPUSH
34166: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34170: LD_INT 1
34172: PPUSH
34173: LD_INT 5
34175: PPUSH
34176: CALL_OW 12
34180: PPUSH
34181: LD_INT 106
34183: PPUSH
34184: LD_INT 150
34186: PPUSH
34187: LD_INT 19
34189: PPUSH
34190: LD_INT 1
34192: PPUSH
34193: CALL_OW 56
// time := time + 0 0$9 ;
34197: LD_ADDR_VAR 0 1
34201: PUSH
34202: LD_VAR 0 1
34206: PUSH
34207: LD_INT 315
34209: PLUS
34210: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34211: LD_INT 455
34213: PPUSH
34214: LD_INT 840
34216: PPUSH
34217: CALL_OW 12
34221: PPUSH
34222: CALL_OW 67
// if Prob ( 50 ) then
34226: LD_INT 50
34228: PPUSH
34229: CALL_OW 13
34233: IFFALSE 34262
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34235: LD_INT 1
34237: PPUSH
34238: LD_INT 5
34240: PPUSH
34241: CALL_OW 12
34245: PPUSH
34246: LD_INT 62
34248: PPUSH
34249: LD_INT 108
34251: PPUSH
34252: LD_INT 10
34254: PPUSH
34255: LD_INT 1
34257: PPUSH
34258: CALL_OW 56
// until missionStage > 4 ;
34262: LD_EXP 15
34266: PUSH
34267: LD_INT 4
34269: GREATER
34270: IFFALSE 34161
// repeat wait ( 0 0$1 ) ;
34272: LD_INT 35
34274: PPUSH
34275: CALL_OW 67
// until missionStage = 6 ;
34279: LD_EXP 15
34283: PUSH
34284: LD_INT 6
34286: EQUAL
34287: IFFALSE 34272
// time := 0 0$50 ;
34289: LD_ADDR_VAR 0 1
34293: PUSH
34294: LD_INT 1750
34296: ST_TO_ADDR
// repeat wait ( time ) ;
34297: LD_VAR 0 1
34301: PPUSH
34302: CALL_OW 67
// if Prob ( 50 ) then
34306: LD_INT 50
34308: PPUSH
34309: CALL_OW 13
34313: IFFALSE 34342
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34315: LD_INT 1
34317: PPUSH
34318: LD_INT 5
34320: PPUSH
34321: CALL_OW 12
34325: PPUSH
34326: LD_INT 106
34328: PPUSH
34329: LD_INT 89
34331: PPUSH
34332: LD_INT 45
34334: PPUSH
34335: LD_INT 1
34337: PPUSH
34338: CALL_OW 56
// time := time + 0 0$2 ;
34342: LD_ADDR_VAR 0 1
34346: PUSH
34347: LD_VAR 0 1
34351: PUSH
34352: LD_INT 70
34354: PLUS
34355: ST_TO_ADDR
// if Prob ( 30 ) then
34356: LD_INT 30
34358: PPUSH
34359: CALL_OW 13
34363: IFFALSE 34409
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34365: LD_INT 385
34367: PPUSH
34368: LD_INT 945
34370: PPUSH
34371: CALL_OW 12
34375: PPUSH
34376: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34380: LD_INT 1
34382: PPUSH
34383: LD_INT 5
34385: PPUSH
34386: CALL_OW 12
34390: PPUSH
34391: LD_INT 21
34393: PPUSH
34394: LD_INT 26
34396: PPUSH
34397: LD_INT 12
34399: PPUSH
34400: LD_INT 1
34402: PPUSH
34403: CALL_OW 56
// end else
34407: GO 34445
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34409: LD_INT 700
34411: PPUSH
34412: LD_INT 1225
34414: PPUSH
34415: CALL_OW 12
34419: PPUSH
34420: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34424: LD_INT 1
34426: PPUSH
34427: LD_INT 5
34429: PPUSH
34430: CALL_OW 12
34434: PPUSH
34435: LD_INT 16
34437: PPUSH
34438: LD_INT 1
34440: PPUSH
34441: CALL_OW 55
// end ; if Prob ( 50 ) then
34445: LD_INT 50
34447: PPUSH
34448: CALL_OW 13
34452: IFFALSE 34498
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34454: LD_INT 700
34456: PPUSH
34457: LD_INT 1050
34459: PPUSH
34460: CALL_OW 12
34464: PPUSH
34465: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34469: LD_INT 1
34471: PPUSH
34472: LD_INT 5
34474: PPUSH
34475: CALL_OW 12
34479: PPUSH
34480: LD_INT 181
34482: PPUSH
34483: LD_INT 218
34485: PPUSH
34486: LD_INT 16
34488: PPUSH
34489: LD_INT 1
34491: PPUSH
34492: CALL_OW 56
// end else
34496: GO 34534
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34498: LD_INT 350
34500: PPUSH
34501: LD_INT 525
34503: PPUSH
34504: CALL_OW 12
34508: PPUSH
34509: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34513: LD_INT 1
34515: PPUSH
34516: LD_INT 5
34518: PPUSH
34519: CALL_OW 12
34523: PPUSH
34524: LD_INT 15
34526: PPUSH
34527: LD_INT 1
34529: PPUSH
34530: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
34534: LD_INT 45
34536: PUSH
34537: LD_INT 32
34539: PUSH
34540: LD_INT 25
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: LIST
34547: PUSH
34548: LD_OWVAR 67
34552: ARRAY
34553: PPUSH
34554: CALL_OW 13
34558: IFFALSE 34602
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34560: LD_INT 175
34562: PPUSH
34563: LD_INT 315
34565: PPUSH
34566: CALL_OW 12
34570: PPUSH
34571: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34575: LD_INT 1
34577: PPUSH
34578: LD_INT 5
34580: PPUSH
34581: CALL_OW 12
34585: PPUSH
34586: LD_INT 103
34588: PPUSH
34589: LD_INT 140
34591: PPUSH
34592: LD_INT 20
34594: PPUSH
34595: LD_INT 1
34597: PPUSH
34598: CALL_OW 56
// end ; if time > 1 1$20 then
34602: LD_VAR 0 1
34606: PUSH
34607: LD_INT 2800
34609: GREATER
34610: IFFALSE 34620
// time := 0 0$30 ;
34612: LD_ADDR_VAR 0 1
34616: PUSH
34617: LD_INT 1050
34619: ST_TO_ADDR
// until false ;
34620: LD_INT 0
34622: IFFALSE 34297
// end ; end_of_file
34624: PPOPN 1
34626: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34627: LD_EXP 13
34631: PUSH
34632: LD_EXP 15
34636: PUSH
34637: LD_INT 6
34639: GREATEREQUAL
34640: AND
34641: IFFALSE 34678
34643: GO 34645
34645: DISABLE
// begin enable ;
34646: ENABLE
// missionTime := missionTime + 0 0$1 ;
34647: LD_ADDR_EXP 14
34651: PUSH
34652: LD_EXP 14
34656: PUSH
34657: LD_INT 35
34659: PLUS
34660: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34661: LD_ADDR_OWVAR 47
34665: PUSH
34666: LD_STRING #Am15-1
34668: PUSH
34669: LD_EXP 14
34673: PUSH
34674: EMPTY
34675: LIST
34676: LIST
34677: ST_TO_ADDR
// end ; end_of_file
34678: END
// export function InitNature ; begin
34679: LD_INT 0
34681: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34682: LD_INT 3
34684: PPUSH
34685: LD_INT 3
34687: PPUSH
34688: LD_INT 2
34690: PPUSH
34691: LD_INT 1
34693: PPUSH
34694: LD_INT 1
34696: PPUSH
34697: LD_INT 0
34699: PPUSH
34700: LD_INT 0
34702: PPUSH
34703: LD_INT 20
34705: PPUSH
34706: LD_INT 0
34708: PPUSH
34709: CALL 99860 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34713: LD_INT 2
34715: PPUSH
34716: LD_INT 1
34718: PPUSH
34719: LD_INT 1
34721: PPUSH
34722: LD_INT 1
34724: PPUSH
34725: LD_INT 1
34727: PPUSH
34728: LD_INT 0
34730: PPUSH
34731: LD_INT 0
34733: PPUSH
34734: LD_INT 21
34736: PPUSH
34737: LD_INT 0
34739: PPUSH
34740: CALL 99860 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
34744: LD_INT 4
34746: PPUSH
34747: LD_INT 1
34749: PPUSH
34750: LD_INT 2
34752: PPUSH
34753: LD_INT 4
34755: PPUSH
34756: LD_INT 2
34758: PPUSH
34759: LD_INT 1
34761: PPUSH
34762: LD_INT 0
34764: PPUSH
34765: LD_INT 22
34767: PPUSH
34768: LD_INT 0
34770: PPUSH
34771: CALL 99860 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
34775: LD_INT 0
34777: PPUSH
34778: LD_INT 0
34780: PPUSH
34781: LD_INT 0
34783: PPUSH
34784: LD_INT 0
34786: PPUSH
34787: LD_INT 0
34789: PPUSH
34790: LD_INT 0
34792: PPUSH
34793: LD_INT 9
34795: PPUSH
34796: LD_INT 0
34798: PPUSH
34799: LD_INT 23
34801: PPUSH
34802: CALL 99860 0 9
// end ; end_of_file
34806: LD_VAR 0 1
34810: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
34811: GO 34813
34813: DISABLE
// begin ru_radar := 98 ;
34814: LD_ADDR_EXP 95
34818: PUSH
34819: LD_INT 98
34821: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
34822: LD_ADDR_EXP 96
34826: PUSH
34827: LD_INT 89
34829: ST_TO_ADDR
// us_hack := 99 ;
34830: LD_ADDR_EXP 97
34834: PUSH
34835: LD_INT 99
34837: ST_TO_ADDR
// us_artillery := 97 ;
34838: LD_ADDR_EXP 98
34842: PUSH
34843: LD_INT 97
34845: ST_TO_ADDR
// ar_bio_bomb := 91 ;
34846: LD_ADDR_EXP 99
34850: PUSH
34851: LD_INT 91
34853: ST_TO_ADDR
// end ; end_of_file
34854: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
34855: LD_INT 0
34857: PPUSH
34858: PPUSH
// skirmish := false ;
34859: LD_ADDR_EXP 100
34863: PUSH
34864: LD_INT 0
34866: ST_TO_ADDR
// debug_mc := false ;
34867: LD_ADDR_EXP 101
34871: PUSH
34872: LD_INT 0
34874: ST_TO_ADDR
// mc_bases := [ ] ;
34875: LD_ADDR_EXP 102
34879: PUSH
34880: EMPTY
34881: ST_TO_ADDR
// mc_sides := [ ] ;
34882: LD_ADDR_EXP 128
34886: PUSH
34887: EMPTY
34888: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
34889: LD_ADDR_EXP 103
34893: PUSH
34894: EMPTY
34895: ST_TO_ADDR
// mc_building_repairs := [ ] ;
34896: LD_ADDR_EXP 104
34900: PUSH
34901: EMPTY
34902: ST_TO_ADDR
// mc_need_heal := [ ] ;
34903: LD_ADDR_EXP 105
34907: PUSH
34908: EMPTY
34909: ST_TO_ADDR
// mc_healers := [ ] ;
34910: LD_ADDR_EXP 106
34914: PUSH
34915: EMPTY
34916: ST_TO_ADDR
// mc_build_list := [ ] ;
34917: LD_ADDR_EXP 107
34921: PUSH
34922: EMPTY
34923: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
34924: LD_ADDR_EXP 134
34928: PUSH
34929: EMPTY
34930: ST_TO_ADDR
// mc_builders := [ ] ;
34931: LD_ADDR_EXP 108
34935: PUSH
34936: EMPTY
34937: ST_TO_ADDR
// mc_construct_list := [ ] ;
34938: LD_ADDR_EXP 109
34942: PUSH
34943: EMPTY
34944: ST_TO_ADDR
// mc_turret_list := [ ] ;
34945: LD_ADDR_EXP 110
34949: PUSH
34950: EMPTY
34951: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34952: LD_ADDR_EXP 111
34956: PUSH
34957: EMPTY
34958: ST_TO_ADDR
// mc_miners := [ ] ;
34959: LD_ADDR_EXP 116
34963: PUSH
34964: EMPTY
34965: ST_TO_ADDR
// mc_mines := [ ] ;
34966: LD_ADDR_EXP 115
34970: PUSH
34971: EMPTY
34972: ST_TO_ADDR
// mc_minefields := [ ] ;
34973: LD_ADDR_EXP 117
34977: PUSH
34978: EMPTY
34979: ST_TO_ADDR
// mc_crates := [ ] ;
34980: LD_ADDR_EXP 118
34984: PUSH
34985: EMPTY
34986: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34987: LD_ADDR_EXP 119
34991: PUSH
34992: EMPTY
34993: ST_TO_ADDR
// mc_crates_area := [ ] ;
34994: LD_ADDR_EXP 120
34998: PUSH
34999: EMPTY
35000: ST_TO_ADDR
// mc_vehicles := [ ] ;
35001: LD_ADDR_EXP 121
35005: PUSH
35006: EMPTY
35007: ST_TO_ADDR
// mc_attack := [ ] ;
35008: LD_ADDR_EXP 122
35012: PUSH
35013: EMPTY
35014: ST_TO_ADDR
// mc_produce := [ ] ;
35015: LD_ADDR_EXP 123
35019: PUSH
35020: EMPTY
35021: ST_TO_ADDR
// mc_defender := [ ] ;
35022: LD_ADDR_EXP 124
35026: PUSH
35027: EMPTY
35028: ST_TO_ADDR
// mc_parking := [ ] ;
35029: LD_ADDR_EXP 126
35033: PUSH
35034: EMPTY
35035: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35036: LD_ADDR_EXP 112
35040: PUSH
35041: EMPTY
35042: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35043: LD_ADDR_EXP 114
35047: PUSH
35048: EMPTY
35049: ST_TO_ADDR
// mc_scan := [ ] ;
35050: LD_ADDR_EXP 125
35054: PUSH
35055: EMPTY
35056: ST_TO_ADDR
// mc_scan_area := [ ] ;
35057: LD_ADDR_EXP 127
35061: PUSH
35062: EMPTY
35063: ST_TO_ADDR
// mc_tech := [ ] ;
35064: LD_ADDR_EXP 129
35068: PUSH
35069: EMPTY
35070: ST_TO_ADDR
// mc_class := [ ] ;
35071: LD_ADDR_EXP 143
35075: PUSH
35076: EMPTY
35077: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35078: LD_ADDR_EXP 144
35082: PUSH
35083: EMPTY
35084: ST_TO_ADDR
// end ;
35085: LD_VAR 0 1
35089: RET
// export function MC_Kill ( base ) ; begin
35090: LD_INT 0
35092: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35093: LD_ADDR_EXP 102
35097: PUSH
35098: LD_EXP 102
35102: PPUSH
35103: LD_VAR 0 1
35107: PPUSH
35108: EMPTY
35109: PPUSH
35110: CALL_OW 1
35114: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35115: LD_ADDR_EXP 103
35119: PUSH
35120: LD_EXP 103
35124: PPUSH
35125: LD_VAR 0 1
35129: PPUSH
35130: EMPTY
35131: PPUSH
35132: CALL_OW 1
35136: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35137: LD_ADDR_EXP 104
35141: PUSH
35142: LD_EXP 104
35146: PPUSH
35147: LD_VAR 0 1
35151: PPUSH
35152: EMPTY
35153: PPUSH
35154: CALL_OW 1
35158: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35159: LD_ADDR_EXP 105
35163: PUSH
35164: LD_EXP 105
35168: PPUSH
35169: LD_VAR 0 1
35173: PPUSH
35174: EMPTY
35175: PPUSH
35176: CALL_OW 1
35180: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35181: LD_ADDR_EXP 106
35185: PUSH
35186: LD_EXP 106
35190: PPUSH
35191: LD_VAR 0 1
35195: PPUSH
35196: EMPTY
35197: PPUSH
35198: CALL_OW 1
35202: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35203: LD_ADDR_EXP 107
35207: PUSH
35208: LD_EXP 107
35212: PPUSH
35213: LD_VAR 0 1
35217: PPUSH
35218: EMPTY
35219: PPUSH
35220: CALL_OW 1
35224: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35225: LD_ADDR_EXP 108
35229: PUSH
35230: LD_EXP 108
35234: PPUSH
35235: LD_VAR 0 1
35239: PPUSH
35240: EMPTY
35241: PPUSH
35242: CALL_OW 1
35246: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35247: LD_ADDR_EXP 109
35251: PUSH
35252: LD_EXP 109
35256: PPUSH
35257: LD_VAR 0 1
35261: PPUSH
35262: EMPTY
35263: PPUSH
35264: CALL_OW 1
35268: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35269: LD_ADDR_EXP 110
35273: PUSH
35274: LD_EXP 110
35278: PPUSH
35279: LD_VAR 0 1
35283: PPUSH
35284: EMPTY
35285: PPUSH
35286: CALL_OW 1
35290: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35291: LD_ADDR_EXP 111
35295: PUSH
35296: LD_EXP 111
35300: PPUSH
35301: LD_VAR 0 1
35305: PPUSH
35306: EMPTY
35307: PPUSH
35308: CALL_OW 1
35312: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35313: LD_ADDR_EXP 112
35317: PUSH
35318: LD_EXP 112
35322: PPUSH
35323: LD_VAR 0 1
35327: PPUSH
35328: EMPTY
35329: PPUSH
35330: CALL_OW 1
35334: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35335: LD_ADDR_EXP 113
35339: PUSH
35340: LD_EXP 113
35344: PPUSH
35345: LD_VAR 0 1
35349: PPUSH
35350: LD_INT 0
35352: PPUSH
35353: CALL_OW 1
35357: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35358: LD_ADDR_EXP 114
35362: PUSH
35363: LD_EXP 114
35367: PPUSH
35368: LD_VAR 0 1
35372: PPUSH
35373: EMPTY
35374: PPUSH
35375: CALL_OW 1
35379: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35380: LD_ADDR_EXP 115
35384: PUSH
35385: LD_EXP 115
35389: PPUSH
35390: LD_VAR 0 1
35394: PPUSH
35395: EMPTY
35396: PPUSH
35397: CALL_OW 1
35401: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35402: LD_ADDR_EXP 116
35406: PUSH
35407: LD_EXP 116
35411: PPUSH
35412: LD_VAR 0 1
35416: PPUSH
35417: EMPTY
35418: PPUSH
35419: CALL_OW 1
35423: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35424: LD_ADDR_EXP 117
35428: PUSH
35429: LD_EXP 117
35433: PPUSH
35434: LD_VAR 0 1
35438: PPUSH
35439: EMPTY
35440: PPUSH
35441: CALL_OW 1
35445: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35446: LD_ADDR_EXP 118
35450: PUSH
35451: LD_EXP 118
35455: PPUSH
35456: LD_VAR 0 1
35460: PPUSH
35461: EMPTY
35462: PPUSH
35463: CALL_OW 1
35467: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35468: LD_ADDR_EXP 119
35472: PUSH
35473: LD_EXP 119
35477: PPUSH
35478: LD_VAR 0 1
35482: PPUSH
35483: EMPTY
35484: PPUSH
35485: CALL_OW 1
35489: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35490: LD_ADDR_EXP 120
35494: PUSH
35495: LD_EXP 120
35499: PPUSH
35500: LD_VAR 0 1
35504: PPUSH
35505: EMPTY
35506: PPUSH
35507: CALL_OW 1
35511: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35512: LD_ADDR_EXP 121
35516: PUSH
35517: LD_EXP 121
35521: PPUSH
35522: LD_VAR 0 1
35526: PPUSH
35527: EMPTY
35528: PPUSH
35529: CALL_OW 1
35533: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35534: LD_ADDR_EXP 122
35538: PUSH
35539: LD_EXP 122
35543: PPUSH
35544: LD_VAR 0 1
35548: PPUSH
35549: EMPTY
35550: PPUSH
35551: CALL_OW 1
35555: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35556: LD_ADDR_EXP 123
35560: PUSH
35561: LD_EXP 123
35565: PPUSH
35566: LD_VAR 0 1
35570: PPUSH
35571: EMPTY
35572: PPUSH
35573: CALL_OW 1
35577: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35578: LD_ADDR_EXP 124
35582: PUSH
35583: LD_EXP 124
35587: PPUSH
35588: LD_VAR 0 1
35592: PPUSH
35593: EMPTY
35594: PPUSH
35595: CALL_OW 1
35599: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35600: LD_ADDR_EXP 125
35604: PUSH
35605: LD_EXP 125
35609: PPUSH
35610: LD_VAR 0 1
35614: PPUSH
35615: EMPTY
35616: PPUSH
35617: CALL_OW 1
35621: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35622: LD_ADDR_EXP 126
35626: PUSH
35627: LD_EXP 126
35631: PPUSH
35632: LD_VAR 0 1
35636: PPUSH
35637: EMPTY
35638: PPUSH
35639: CALL_OW 1
35643: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35644: LD_ADDR_EXP 127
35648: PUSH
35649: LD_EXP 127
35653: PPUSH
35654: LD_VAR 0 1
35658: PPUSH
35659: EMPTY
35660: PPUSH
35661: CALL_OW 1
35665: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35666: LD_ADDR_EXP 129
35670: PUSH
35671: LD_EXP 129
35675: PPUSH
35676: LD_VAR 0 1
35680: PPUSH
35681: EMPTY
35682: PPUSH
35683: CALL_OW 1
35687: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35688: LD_ADDR_EXP 131
35692: PUSH
35693: LD_EXP 131
35697: PPUSH
35698: LD_VAR 0 1
35702: PPUSH
35703: EMPTY
35704: PPUSH
35705: CALL_OW 1
35709: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35710: LD_ADDR_EXP 132
35714: PUSH
35715: LD_EXP 132
35719: PPUSH
35720: LD_VAR 0 1
35724: PPUSH
35725: EMPTY
35726: PPUSH
35727: CALL_OW 1
35731: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35732: LD_ADDR_EXP 133
35736: PUSH
35737: LD_EXP 133
35741: PPUSH
35742: LD_VAR 0 1
35746: PPUSH
35747: EMPTY
35748: PPUSH
35749: CALL_OW 1
35753: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35754: LD_ADDR_EXP 134
35758: PUSH
35759: LD_EXP 134
35763: PPUSH
35764: LD_VAR 0 1
35768: PPUSH
35769: EMPTY
35770: PPUSH
35771: CALL_OW 1
35775: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35776: LD_ADDR_EXP 135
35780: PUSH
35781: LD_EXP 135
35785: PPUSH
35786: LD_VAR 0 1
35790: PPUSH
35791: EMPTY
35792: PPUSH
35793: CALL_OW 1
35797: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35798: LD_ADDR_EXP 136
35802: PUSH
35803: LD_EXP 136
35807: PPUSH
35808: LD_VAR 0 1
35812: PPUSH
35813: EMPTY
35814: PPUSH
35815: CALL_OW 1
35819: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35820: LD_ADDR_EXP 137
35824: PUSH
35825: LD_EXP 137
35829: PPUSH
35830: LD_VAR 0 1
35834: PPUSH
35835: EMPTY
35836: PPUSH
35837: CALL_OW 1
35841: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35842: LD_ADDR_EXP 138
35846: PUSH
35847: LD_EXP 138
35851: PPUSH
35852: LD_VAR 0 1
35856: PPUSH
35857: EMPTY
35858: PPUSH
35859: CALL_OW 1
35863: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35864: LD_ADDR_EXP 139
35868: PUSH
35869: LD_EXP 139
35873: PPUSH
35874: LD_VAR 0 1
35878: PPUSH
35879: EMPTY
35880: PPUSH
35881: CALL_OW 1
35885: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35886: LD_ADDR_EXP 140
35890: PUSH
35891: LD_EXP 140
35895: PPUSH
35896: LD_VAR 0 1
35900: PPUSH
35901: EMPTY
35902: PPUSH
35903: CALL_OW 1
35907: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35908: LD_ADDR_EXP 141
35912: PUSH
35913: LD_EXP 141
35917: PPUSH
35918: LD_VAR 0 1
35922: PPUSH
35923: EMPTY
35924: PPUSH
35925: CALL_OW 1
35929: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35930: LD_ADDR_EXP 142
35934: PUSH
35935: LD_EXP 142
35939: PPUSH
35940: LD_VAR 0 1
35944: PPUSH
35945: EMPTY
35946: PPUSH
35947: CALL_OW 1
35951: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35952: LD_ADDR_EXP 143
35956: PUSH
35957: LD_EXP 143
35961: PPUSH
35962: LD_VAR 0 1
35966: PPUSH
35967: EMPTY
35968: PPUSH
35969: CALL_OW 1
35973: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35974: LD_ADDR_EXP 144
35978: PUSH
35979: LD_EXP 144
35983: PPUSH
35984: LD_VAR 0 1
35988: PPUSH
35989: LD_INT 0
35991: PPUSH
35992: CALL_OW 1
35996: ST_TO_ADDR
// end ;
35997: LD_VAR 0 2
36001: RET
// export function MC_Add ( side , units ) ; var base ; begin
36002: LD_INT 0
36004: PPUSH
36005: PPUSH
// base := mc_bases + 1 ;
36006: LD_ADDR_VAR 0 4
36010: PUSH
36011: LD_EXP 102
36015: PUSH
36016: LD_INT 1
36018: PLUS
36019: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36020: LD_ADDR_EXP 128
36024: PUSH
36025: LD_EXP 128
36029: PPUSH
36030: LD_VAR 0 4
36034: PPUSH
36035: LD_VAR 0 1
36039: PPUSH
36040: CALL_OW 1
36044: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36045: LD_ADDR_EXP 102
36049: PUSH
36050: LD_EXP 102
36054: PPUSH
36055: LD_VAR 0 4
36059: PPUSH
36060: LD_VAR 0 2
36064: PPUSH
36065: CALL_OW 1
36069: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36070: LD_ADDR_EXP 103
36074: PUSH
36075: LD_EXP 103
36079: PPUSH
36080: LD_VAR 0 4
36084: PPUSH
36085: EMPTY
36086: PPUSH
36087: CALL_OW 1
36091: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36092: LD_ADDR_EXP 104
36096: PUSH
36097: LD_EXP 104
36101: PPUSH
36102: LD_VAR 0 4
36106: PPUSH
36107: EMPTY
36108: PPUSH
36109: CALL_OW 1
36113: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36114: LD_ADDR_EXP 105
36118: PUSH
36119: LD_EXP 105
36123: PPUSH
36124: LD_VAR 0 4
36128: PPUSH
36129: EMPTY
36130: PPUSH
36131: CALL_OW 1
36135: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36136: LD_ADDR_EXP 106
36140: PUSH
36141: LD_EXP 106
36145: PPUSH
36146: LD_VAR 0 4
36150: PPUSH
36151: EMPTY
36152: PPUSH
36153: CALL_OW 1
36157: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36158: LD_ADDR_EXP 107
36162: PUSH
36163: LD_EXP 107
36167: PPUSH
36168: LD_VAR 0 4
36172: PPUSH
36173: EMPTY
36174: PPUSH
36175: CALL_OW 1
36179: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36180: LD_ADDR_EXP 108
36184: PUSH
36185: LD_EXP 108
36189: PPUSH
36190: LD_VAR 0 4
36194: PPUSH
36195: EMPTY
36196: PPUSH
36197: CALL_OW 1
36201: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36202: LD_ADDR_EXP 109
36206: PUSH
36207: LD_EXP 109
36211: PPUSH
36212: LD_VAR 0 4
36216: PPUSH
36217: EMPTY
36218: PPUSH
36219: CALL_OW 1
36223: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36224: LD_ADDR_EXP 110
36228: PUSH
36229: LD_EXP 110
36233: PPUSH
36234: LD_VAR 0 4
36238: PPUSH
36239: EMPTY
36240: PPUSH
36241: CALL_OW 1
36245: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36246: LD_ADDR_EXP 111
36250: PUSH
36251: LD_EXP 111
36255: PPUSH
36256: LD_VAR 0 4
36260: PPUSH
36261: EMPTY
36262: PPUSH
36263: CALL_OW 1
36267: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36268: LD_ADDR_EXP 112
36272: PUSH
36273: LD_EXP 112
36277: PPUSH
36278: LD_VAR 0 4
36282: PPUSH
36283: EMPTY
36284: PPUSH
36285: CALL_OW 1
36289: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36290: LD_ADDR_EXP 113
36294: PUSH
36295: LD_EXP 113
36299: PPUSH
36300: LD_VAR 0 4
36304: PPUSH
36305: LD_INT 0
36307: PPUSH
36308: CALL_OW 1
36312: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36313: LD_ADDR_EXP 114
36317: PUSH
36318: LD_EXP 114
36322: PPUSH
36323: LD_VAR 0 4
36327: PPUSH
36328: EMPTY
36329: PPUSH
36330: CALL_OW 1
36334: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36335: LD_ADDR_EXP 115
36339: PUSH
36340: LD_EXP 115
36344: PPUSH
36345: LD_VAR 0 4
36349: PPUSH
36350: EMPTY
36351: PPUSH
36352: CALL_OW 1
36356: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36357: LD_ADDR_EXP 116
36361: PUSH
36362: LD_EXP 116
36366: PPUSH
36367: LD_VAR 0 4
36371: PPUSH
36372: EMPTY
36373: PPUSH
36374: CALL_OW 1
36378: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36379: LD_ADDR_EXP 117
36383: PUSH
36384: LD_EXP 117
36388: PPUSH
36389: LD_VAR 0 4
36393: PPUSH
36394: EMPTY
36395: PPUSH
36396: CALL_OW 1
36400: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36401: LD_ADDR_EXP 118
36405: PUSH
36406: LD_EXP 118
36410: PPUSH
36411: LD_VAR 0 4
36415: PPUSH
36416: EMPTY
36417: PPUSH
36418: CALL_OW 1
36422: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36423: LD_ADDR_EXP 119
36427: PUSH
36428: LD_EXP 119
36432: PPUSH
36433: LD_VAR 0 4
36437: PPUSH
36438: EMPTY
36439: PPUSH
36440: CALL_OW 1
36444: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36445: LD_ADDR_EXP 120
36449: PUSH
36450: LD_EXP 120
36454: PPUSH
36455: LD_VAR 0 4
36459: PPUSH
36460: EMPTY
36461: PPUSH
36462: CALL_OW 1
36466: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36467: LD_ADDR_EXP 121
36471: PUSH
36472: LD_EXP 121
36476: PPUSH
36477: LD_VAR 0 4
36481: PPUSH
36482: EMPTY
36483: PPUSH
36484: CALL_OW 1
36488: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36489: LD_ADDR_EXP 122
36493: PUSH
36494: LD_EXP 122
36498: PPUSH
36499: LD_VAR 0 4
36503: PPUSH
36504: EMPTY
36505: PPUSH
36506: CALL_OW 1
36510: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36511: LD_ADDR_EXP 123
36515: PUSH
36516: LD_EXP 123
36520: PPUSH
36521: LD_VAR 0 4
36525: PPUSH
36526: EMPTY
36527: PPUSH
36528: CALL_OW 1
36532: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36533: LD_ADDR_EXP 124
36537: PUSH
36538: LD_EXP 124
36542: PPUSH
36543: LD_VAR 0 4
36547: PPUSH
36548: EMPTY
36549: PPUSH
36550: CALL_OW 1
36554: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36555: LD_ADDR_EXP 125
36559: PUSH
36560: LD_EXP 125
36564: PPUSH
36565: LD_VAR 0 4
36569: PPUSH
36570: EMPTY
36571: PPUSH
36572: CALL_OW 1
36576: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36577: LD_ADDR_EXP 126
36581: PUSH
36582: LD_EXP 126
36586: PPUSH
36587: LD_VAR 0 4
36591: PPUSH
36592: EMPTY
36593: PPUSH
36594: CALL_OW 1
36598: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36599: LD_ADDR_EXP 127
36603: PUSH
36604: LD_EXP 127
36608: PPUSH
36609: LD_VAR 0 4
36613: PPUSH
36614: EMPTY
36615: PPUSH
36616: CALL_OW 1
36620: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36621: LD_ADDR_EXP 129
36625: PUSH
36626: LD_EXP 129
36630: PPUSH
36631: LD_VAR 0 4
36635: PPUSH
36636: EMPTY
36637: PPUSH
36638: CALL_OW 1
36642: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36643: LD_ADDR_EXP 131
36647: PUSH
36648: LD_EXP 131
36652: PPUSH
36653: LD_VAR 0 4
36657: PPUSH
36658: EMPTY
36659: PPUSH
36660: CALL_OW 1
36664: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36665: LD_ADDR_EXP 132
36669: PUSH
36670: LD_EXP 132
36674: PPUSH
36675: LD_VAR 0 4
36679: PPUSH
36680: EMPTY
36681: PPUSH
36682: CALL_OW 1
36686: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36687: LD_ADDR_EXP 133
36691: PUSH
36692: LD_EXP 133
36696: PPUSH
36697: LD_VAR 0 4
36701: PPUSH
36702: EMPTY
36703: PPUSH
36704: CALL_OW 1
36708: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36709: LD_ADDR_EXP 134
36713: PUSH
36714: LD_EXP 134
36718: PPUSH
36719: LD_VAR 0 4
36723: PPUSH
36724: EMPTY
36725: PPUSH
36726: CALL_OW 1
36730: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36731: LD_ADDR_EXP 135
36735: PUSH
36736: LD_EXP 135
36740: PPUSH
36741: LD_VAR 0 4
36745: PPUSH
36746: EMPTY
36747: PPUSH
36748: CALL_OW 1
36752: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36753: LD_ADDR_EXP 136
36757: PUSH
36758: LD_EXP 136
36762: PPUSH
36763: LD_VAR 0 4
36767: PPUSH
36768: EMPTY
36769: PPUSH
36770: CALL_OW 1
36774: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36775: LD_ADDR_EXP 137
36779: PUSH
36780: LD_EXP 137
36784: PPUSH
36785: LD_VAR 0 4
36789: PPUSH
36790: EMPTY
36791: PPUSH
36792: CALL_OW 1
36796: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36797: LD_ADDR_EXP 138
36801: PUSH
36802: LD_EXP 138
36806: PPUSH
36807: LD_VAR 0 4
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36819: LD_ADDR_EXP 139
36823: PUSH
36824: LD_EXP 139
36828: PPUSH
36829: LD_VAR 0 4
36833: PPUSH
36834: EMPTY
36835: PPUSH
36836: CALL_OW 1
36840: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36841: LD_ADDR_EXP 140
36845: PUSH
36846: LD_EXP 140
36850: PPUSH
36851: LD_VAR 0 4
36855: PPUSH
36856: EMPTY
36857: PPUSH
36858: CALL_OW 1
36862: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36863: LD_ADDR_EXP 141
36867: PUSH
36868: LD_EXP 141
36872: PPUSH
36873: LD_VAR 0 4
36877: PPUSH
36878: EMPTY
36879: PPUSH
36880: CALL_OW 1
36884: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36885: LD_ADDR_EXP 142
36889: PUSH
36890: LD_EXP 142
36894: PPUSH
36895: LD_VAR 0 4
36899: PPUSH
36900: EMPTY
36901: PPUSH
36902: CALL_OW 1
36906: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36907: LD_ADDR_EXP 143
36911: PUSH
36912: LD_EXP 143
36916: PPUSH
36917: LD_VAR 0 4
36921: PPUSH
36922: EMPTY
36923: PPUSH
36924: CALL_OW 1
36928: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36929: LD_ADDR_EXP 144
36933: PUSH
36934: LD_EXP 144
36938: PPUSH
36939: LD_VAR 0 4
36943: PPUSH
36944: LD_INT 0
36946: PPUSH
36947: CALL_OW 1
36951: ST_TO_ADDR
// result := base ;
36952: LD_ADDR_VAR 0 3
36956: PUSH
36957: LD_VAR 0 4
36961: ST_TO_ADDR
// end ;
36962: LD_VAR 0 3
36966: RET
// export function MC_Start ( ) ; var i ; begin
36967: LD_INT 0
36969: PPUSH
36970: PPUSH
// for i = 1 to mc_bases do
36971: LD_ADDR_VAR 0 2
36975: PUSH
36976: DOUBLE
36977: LD_INT 1
36979: DEC
36980: ST_TO_ADDR
36981: LD_EXP 102
36985: PUSH
36986: FOR_TO
36987: IFFALSE 38064
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36989: LD_ADDR_EXP 102
36993: PUSH
36994: LD_EXP 102
36998: PPUSH
36999: LD_VAR 0 2
37003: PPUSH
37004: LD_EXP 102
37008: PUSH
37009: LD_VAR 0 2
37013: ARRAY
37014: PUSH
37015: LD_INT 0
37017: DIFF
37018: PPUSH
37019: CALL_OW 1
37023: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37024: LD_ADDR_EXP 103
37028: PUSH
37029: LD_EXP 103
37033: PPUSH
37034: LD_VAR 0 2
37038: PPUSH
37039: EMPTY
37040: PPUSH
37041: CALL_OW 1
37045: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37046: LD_ADDR_EXP 104
37050: PUSH
37051: LD_EXP 104
37055: PPUSH
37056: LD_VAR 0 2
37060: PPUSH
37061: EMPTY
37062: PPUSH
37063: CALL_OW 1
37067: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37068: LD_ADDR_EXP 105
37072: PUSH
37073: LD_EXP 105
37077: PPUSH
37078: LD_VAR 0 2
37082: PPUSH
37083: EMPTY
37084: PPUSH
37085: CALL_OW 1
37089: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37090: LD_ADDR_EXP 106
37094: PUSH
37095: LD_EXP 106
37099: PPUSH
37100: LD_VAR 0 2
37104: PPUSH
37105: EMPTY
37106: PUSH
37107: EMPTY
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PPUSH
37113: CALL_OW 1
37117: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37118: LD_ADDR_EXP 107
37122: PUSH
37123: LD_EXP 107
37127: PPUSH
37128: LD_VAR 0 2
37132: PPUSH
37133: EMPTY
37134: PPUSH
37135: CALL_OW 1
37139: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37140: LD_ADDR_EXP 134
37144: PUSH
37145: LD_EXP 134
37149: PPUSH
37150: LD_VAR 0 2
37154: PPUSH
37155: EMPTY
37156: PPUSH
37157: CALL_OW 1
37161: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37162: LD_ADDR_EXP 108
37166: PUSH
37167: LD_EXP 108
37171: PPUSH
37172: LD_VAR 0 2
37176: PPUSH
37177: EMPTY
37178: PPUSH
37179: CALL_OW 1
37183: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37184: LD_ADDR_EXP 109
37188: PUSH
37189: LD_EXP 109
37193: PPUSH
37194: LD_VAR 0 2
37198: PPUSH
37199: EMPTY
37200: PPUSH
37201: CALL_OW 1
37205: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37206: LD_ADDR_EXP 110
37210: PUSH
37211: LD_EXP 110
37215: PPUSH
37216: LD_VAR 0 2
37220: PPUSH
37221: LD_EXP 102
37225: PUSH
37226: LD_VAR 0 2
37230: ARRAY
37231: PPUSH
37232: LD_INT 2
37234: PUSH
37235: LD_INT 30
37237: PUSH
37238: LD_INT 32
37240: PUSH
37241: EMPTY
37242: LIST
37243: LIST
37244: PUSH
37245: LD_INT 30
37247: PUSH
37248: LD_INT 33
37250: PUSH
37251: EMPTY
37252: LIST
37253: LIST
37254: PUSH
37255: EMPTY
37256: LIST
37257: LIST
37258: LIST
37259: PPUSH
37260: CALL_OW 72
37264: PPUSH
37265: CALL_OW 1
37269: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37270: LD_ADDR_EXP 111
37274: PUSH
37275: LD_EXP 111
37279: PPUSH
37280: LD_VAR 0 2
37284: PPUSH
37285: LD_EXP 102
37289: PUSH
37290: LD_VAR 0 2
37294: ARRAY
37295: PPUSH
37296: LD_INT 2
37298: PUSH
37299: LD_INT 30
37301: PUSH
37302: LD_INT 32
37304: PUSH
37305: EMPTY
37306: LIST
37307: LIST
37308: PUSH
37309: LD_INT 30
37311: PUSH
37312: LD_INT 31
37314: PUSH
37315: EMPTY
37316: LIST
37317: LIST
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 58
37326: PUSH
37327: EMPTY
37328: LIST
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PPUSH
37334: CALL_OW 72
37338: PPUSH
37339: CALL_OW 1
37343: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37344: LD_ADDR_EXP 112
37348: PUSH
37349: LD_EXP 112
37353: PPUSH
37354: LD_VAR 0 2
37358: PPUSH
37359: EMPTY
37360: PPUSH
37361: CALL_OW 1
37365: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37366: LD_ADDR_EXP 116
37370: PUSH
37371: LD_EXP 116
37375: PPUSH
37376: LD_VAR 0 2
37380: PPUSH
37381: EMPTY
37382: PPUSH
37383: CALL_OW 1
37387: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37388: LD_ADDR_EXP 115
37392: PUSH
37393: LD_EXP 115
37397: PPUSH
37398: LD_VAR 0 2
37402: PPUSH
37403: EMPTY
37404: PPUSH
37405: CALL_OW 1
37409: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37410: LD_ADDR_EXP 117
37414: PUSH
37415: LD_EXP 117
37419: PPUSH
37420: LD_VAR 0 2
37424: PPUSH
37425: EMPTY
37426: PPUSH
37427: CALL_OW 1
37431: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37432: LD_ADDR_EXP 118
37436: PUSH
37437: LD_EXP 118
37441: PPUSH
37442: LD_VAR 0 2
37446: PPUSH
37447: EMPTY
37448: PPUSH
37449: CALL_OW 1
37453: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37454: LD_ADDR_EXP 119
37458: PUSH
37459: LD_EXP 119
37463: PPUSH
37464: LD_VAR 0 2
37468: PPUSH
37469: EMPTY
37470: PPUSH
37471: CALL_OW 1
37475: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37476: LD_ADDR_EXP 120
37480: PUSH
37481: LD_EXP 120
37485: PPUSH
37486: LD_VAR 0 2
37490: PPUSH
37491: EMPTY
37492: PPUSH
37493: CALL_OW 1
37497: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37498: LD_ADDR_EXP 121
37502: PUSH
37503: LD_EXP 121
37507: PPUSH
37508: LD_VAR 0 2
37512: PPUSH
37513: EMPTY
37514: PPUSH
37515: CALL_OW 1
37519: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37520: LD_ADDR_EXP 122
37524: PUSH
37525: LD_EXP 122
37529: PPUSH
37530: LD_VAR 0 2
37534: PPUSH
37535: EMPTY
37536: PPUSH
37537: CALL_OW 1
37541: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37542: LD_ADDR_EXP 123
37546: PUSH
37547: LD_EXP 123
37551: PPUSH
37552: LD_VAR 0 2
37556: PPUSH
37557: EMPTY
37558: PPUSH
37559: CALL_OW 1
37563: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
37564: LD_ADDR_EXP 124
37568: PUSH
37569: LD_EXP 124
37573: PPUSH
37574: LD_VAR 0 2
37578: PPUSH
37579: EMPTY
37580: PPUSH
37581: CALL_OW 1
37585: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
37586: LD_ADDR_EXP 113
37590: PUSH
37591: LD_EXP 113
37595: PPUSH
37596: LD_VAR 0 2
37600: PPUSH
37601: LD_INT 0
37603: PPUSH
37604: CALL_OW 1
37608: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
37609: LD_ADDR_EXP 126
37613: PUSH
37614: LD_EXP 126
37618: PPUSH
37619: LD_VAR 0 2
37623: PPUSH
37624: LD_INT 0
37626: PPUSH
37627: CALL_OW 1
37631: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
37632: LD_ADDR_EXP 114
37636: PUSH
37637: LD_EXP 114
37641: PPUSH
37642: LD_VAR 0 2
37646: PPUSH
37647: EMPTY
37648: PPUSH
37649: CALL_OW 1
37653: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
37654: LD_ADDR_EXP 125
37658: PUSH
37659: LD_EXP 125
37663: PPUSH
37664: LD_VAR 0 2
37668: PPUSH
37669: LD_INT 0
37671: PPUSH
37672: CALL_OW 1
37676: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
37677: LD_ADDR_EXP 127
37681: PUSH
37682: LD_EXP 127
37686: PPUSH
37687: LD_VAR 0 2
37691: PPUSH
37692: EMPTY
37693: PPUSH
37694: CALL_OW 1
37698: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
37699: LD_ADDR_EXP 130
37703: PUSH
37704: LD_EXP 130
37708: PPUSH
37709: LD_VAR 0 2
37713: PPUSH
37714: LD_INT 0
37716: PPUSH
37717: CALL_OW 1
37721: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
37722: LD_ADDR_EXP 131
37726: PUSH
37727: LD_EXP 131
37731: PPUSH
37732: LD_VAR 0 2
37736: PPUSH
37737: EMPTY
37738: PPUSH
37739: CALL_OW 1
37743: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
37744: LD_ADDR_EXP 132
37748: PUSH
37749: LD_EXP 132
37753: PPUSH
37754: LD_VAR 0 2
37758: PPUSH
37759: EMPTY
37760: PPUSH
37761: CALL_OW 1
37765: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37766: LD_ADDR_EXP 133
37770: PUSH
37771: LD_EXP 133
37775: PPUSH
37776: LD_VAR 0 2
37780: PPUSH
37781: EMPTY
37782: PPUSH
37783: CALL_OW 1
37787: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
37788: LD_ADDR_EXP 135
37792: PUSH
37793: LD_EXP 135
37797: PPUSH
37798: LD_VAR 0 2
37802: PPUSH
37803: LD_EXP 102
37807: PUSH
37808: LD_VAR 0 2
37812: ARRAY
37813: PPUSH
37814: LD_INT 2
37816: PUSH
37817: LD_INT 30
37819: PUSH
37820: LD_INT 6
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 30
37829: PUSH
37830: LD_INT 7
37832: PUSH
37833: EMPTY
37834: LIST
37835: LIST
37836: PUSH
37837: LD_INT 30
37839: PUSH
37840: LD_INT 8
37842: PUSH
37843: EMPTY
37844: LIST
37845: LIST
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: LIST
37851: LIST
37852: PPUSH
37853: CALL_OW 72
37857: PPUSH
37858: CALL_OW 1
37862: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
37863: LD_ADDR_EXP 136
37867: PUSH
37868: LD_EXP 136
37872: PPUSH
37873: LD_VAR 0 2
37877: PPUSH
37878: EMPTY
37879: PPUSH
37880: CALL_OW 1
37884: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
37885: LD_ADDR_EXP 137
37889: PUSH
37890: LD_EXP 137
37894: PPUSH
37895: LD_VAR 0 2
37899: PPUSH
37900: EMPTY
37901: PPUSH
37902: CALL_OW 1
37906: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
37907: LD_ADDR_EXP 138
37911: PUSH
37912: LD_EXP 138
37916: PPUSH
37917: LD_VAR 0 2
37921: PPUSH
37922: EMPTY
37923: PPUSH
37924: CALL_OW 1
37928: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
37929: LD_ADDR_EXP 139
37933: PUSH
37934: LD_EXP 139
37938: PPUSH
37939: LD_VAR 0 2
37943: PPUSH
37944: EMPTY
37945: PPUSH
37946: CALL_OW 1
37950: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37951: LD_ADDR_EXP 140
37955: PUSH
37956: LD_EXP 140
37960: PPUSH
37961: LD_VAR 0 2
37965: PPUSH
37966: EMPTY
37967: PPUSH
37968: CALL_OW 1
37972: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37973: LD_ADDR_EXP 141
37977: PUSH
37978: LD_EXP 141
37982: PPUSH
37983: LD_VAR 0 2
37987: PPUSH
37988: EMPTY
37989: PPUSH
37990: CALL_OW 1
37994: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37995: LD_ADDR_EXP 142
37999: PUSH
38000: LD_EXP 142
38004: PPUSH
38005: LD_VAR 0 2
38009: PPUSH
38010: EMPTY
38011: PPUSH
38012: CALL_OW 1
38016: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38017: LD_ADDR_EXP 143
38021: PUSH
38022: LD_EXP 143
38026: PPUSH
38027: LD_VAR 0 2
38031: PPUSH
38032: EMPTY
38033: PPUSH
38034: CALL_OW 1
38038: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38039: LD_ADDR_EXP 144
38043: PUSH
38044: LD_EXP 144
38048: PPUSH
38049: LD_VAR 0 2
38053: PPUSH
38054: LD_INT 0
38056: PPUSH
38057: CALL_OW 1
38061: ST_TO_ADDR
// end ;
38062: GO 36986
38064: POP
38065: POP
// MC_InitSides ( ) ;
38066: CALL 38352 0 0
// MC_InitResearch ( ) ;
38070: CALL 38091 0 0
// CustomInitMacro ( ) ;
38074: CALL 467 0 0
// skirmish := true ;
38078: LD_ADDR_EXP 100
38082: PUSH
38083: LD_INT 1
38085: ST_TO_ADDR
// end ;
38086: LD_VAR 0 1
38090: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38091: LD_INT 0
38093: PPUSH
38094: PPUSH
38095: PPUSH
38096: PPUSH
38097: PPUSH
38098: PPUSH
// if not mc_bases then
38099: LD_EXP 102
38103: NOT
38104: IFFALSE 38108
// exit ;
38106: GO 38347
// for i = 1 to 8 do
38108: LD_ADDR_VAR 0 2
38112: PUSH
38113: DOUBLE
38114: LD_INT 1
38116: DEC
38117: ST_TO_ADDR
38118: LD_INT 8
38120: PUSH
38121: FOR_TO
38122: IFFALSE 38148
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38124: LD_ADDR_EXP 129
38128: PUSH
38129: LD_EXP 129
38133: PPUSH
38134: LD_VAR 0 2
38138: PPUSH
38139: EMPTY
38140: PPUSH
38141: CALL_OW 1
38145: ST_TO_ADDR
38146: GO 38121
38148: POP
38149: POP
// tmp := [ ] ;
38150: LD_ADDR_VAR 0 5
38154: PUSH
38155: EMPTY
38156: ST_TO_ADDR
// for i = 1 to mc_sides do
38157: LD_ADDR_VAR 0 2
38161: PUSH
38162: DOUBLE
38163: LD_INT 1
38165: DEC
38166: ST_TO_ADDR
38167: LD_EXP 128
38171: PUSH
38172: FOR_TO
38173: IFFALSE 38231
// if not mc_sides [ i ] in tmp then
38175: LD_EXP 128
38179: PUSH
38180: LD_VAR 0 2
38184: ARRAY
38185: PUSH
38186: LD_VAR 0 5
38190: IN
38191: NOT
38192: IFFALSE 38229
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38194: LD_ADDR_VAR 0 5
38198: PUSH
38199: LD_VAR 0 5
38203: PPUSH
38204: LD_VAR 0 5
38208: PUSH
38209: LD_INT 1
38211: PLUS
38212: PPUSH
38213: LD_EXP 128
38217: PUSH
38218: LD_VAR 0 2
38222: ARRAY
38223: PPUSH
38224: CALL_OW 2
38228: ST_TO_ADDR
38229: GO 38172
38231: POP
38232: POP
// if not tmp then
38233: LD_VAR 0 5
38237: NOT
38238: IFFALSE 38242
// exit ;
38240: GO 38347
// for j in tmp do
38242: LD_ADDR_VAR 0 3
38246: PUSH
38247: LD_VAR 0 5
38251: PUSH
38252: FOR_IN
38253: IFFALSE 38345
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38255: LD_ADDR_VAR 0 6
38259: PUSH
38260: LD_INT 22
38262: PUSH
38263: LD_VAR 0 3
38267: PUSH
38268: EMPTY
38269: LIST
38270: LIST
38271: PPUSH
38272: CALL_OW 69
38276: ST_TO_ADDR
// if not un then
38277: LD_VAR 0 6
38281: NOT
38282: IFFALSE 38286
// continue ;
38284: GO 38252
// nation := GetNation ( un [ 1 ] ) ;
38286: LD_ADDR_VAR 0 4
38290: PUSH
38291: LD_VAR 0 6
38295: PUSH
38296: LD_INT 1
38298: ARRAY
38299: PPUSH
38300: CALL_OW 248
38304: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38305: LD_ADDR_EXP 129
38309: PUSH
38310: LD_EXP 129
38314: PPUSH
38315: LD_VAR 0 3
38319: PPUSH
38320: LD_VAR 0 3
38324: PPUSH
38325: LD_VAR 0 4
38329: PPUSH
38330: LD_INT 1
38332: PPUSH
38333: CALL 64957 0 3
38337: PPUSH
38338: CALL_OW 1
38342: ST_TO_ADDR
// end ;
38343: GO 38252
38345: POP
38346: POP
// end ;
38347: LD_VAR 0 1
38351: RET
// export function MC_InitSides ( ) ; var i ; begin
38352: LD_INT 0
38354: PPUSH
38355: PPUSH
// if not mc_bases then
38356: LD_EXP 102
38360: NOT
38361: IFFALSE 38365
// exit ;
38363: GO 38439
// for i = 1 to mc_bases do
38365: LD_ADDR_VAR 0 2
38369: PUSH
38370: DOUBLE
38371: LD_INT 1
38373: DEC
38374: ST_TO_ADDR
38375: LD_EXP 102
38379: PUSH
38380: FOR_TO
38381: IFFALSE 38437
// if mc_bases [ i ] then
38383: LD_EXP 102
38387: PUSH
38388: LD_VAR 0 2
38392: ARRAY
38393: IFFALSE 38435
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38395: LD_ADDR_EXP 128
38399: PUSH
38400: LD_EXP 128
38404: PPUSH
38405: LD_VAR 0 2
38409: PPUSH
38410: LD_EXP 102
38414: PUSH
38415: LD_VAR 0 2
38419: ARRAY
38420: PUSH
38421: LD_INT 1
38423: ARRAY
38424: PPUSH
38425: CALL_OW 255
38429: PPUSH
38430: CALL_OW 1
38434: ST_TO_ADDR
38435: GO 38380
38437: POP
38438: POP
// end ;
38439: LD_VAR 0 1
38443: RET
// every 0 0$01 trigger skirmish do
38444: LD_EXP 100
38448: IFFALSE 38602
38450: GO 38452
38452: DISABLE
// begin enable ;
38453: ENABLE
// MC_CheckBuildings ( ) ;
38454: CALL 43100 0 0
// MC_CheckPeopleLife ( ) ;
38458: CALL 43225 0 0
// RaiseSailEvent ( 100 ) ;
38462: LD_INT 100
38464: PPUSH
38465: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38469: LD_INT 103
38471: PPUSH
38472: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38476: LD_INT 104
38478: PPUSH
38479: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38483: LD_INT 105
38485: PPUSH
38486: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38490: LD_INT 106
38492: PPUSH
38493: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38497: LD_INT 107
38499: PPUSH
38500: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38504: LD_INT 108
38506: PPUSH
38507: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38511: LD_INT 109
38513: PPUSH
38514: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38518: LD_INT 110
38520: PPUSH
38521: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
38525: LD_INT 111
38527: PPUSH
38528: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
38532: LD_INT 112
38534: PPUSH
38535: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
38539: LD_INT 113
38541: PPUSH
38542: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
38546: LD_INT 120
38548: PPUSH
38549: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
38553: LD_INT 121
38555: PPUSH
38556: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
38560: LD_INT 122
38562: PPUSH
38563: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
38567: LD_INT 123
38569: PPUSH
38570: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
38574: LD_INT 124
38576: PPUSH
38577: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
38581: LD_INT 125
38583: PPUSH
38584: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
38588: LD_INT 126
38590: PPUSH
38591: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
38595: LD_INT 200
38597: PPUSH
38598: CALL_OW 427
// end ;
38602: END
// on SailEvent ( event ) do begin if event < 100 then
38603: LD_VAR 0 1
38607: PUSH
38608: LD_INT 100
38610: LESS
38611: IFFALSE 38622
// CustomEvent ( event ) ;
38613: LD_VAR 0 1
38617: PPUSH
38618: CALL 33262 0 1
// if event = 100 then
38622: LD_VAR 0 1
38626: PUSH
38627: LD_INT 100
38629: EQUAL
38630: IFFALSE 38636
// MC_ClassManager ( ) ;
38632: CALL 39028 0 0
// if event = 101 then
38636: LD_VAR 0 1
38640: PUSH
38641: LD_INT 101
38643: EQUAL
38644: IFFALSE 38650
// MC_RepairBuildings ( ) ;
38646: CALL 43821 0 0
// if event = 102 then
38650: LD_VAR 0 1
38654: PUSH
38655: LD_INT 102
38657: EQUAL
38658: IFFALSE 38664
// MC_Heal ( ) ;
38660: CALL 44685 0 0
// if event = 103 then
38664: LD_VAR 0 1
38668: PUSH
38669: LD_INT 103
38671: EQUAL
38672: IFFALSE 38678
// MC_Build ( ) ;
38674: CALL 45107 0 0
// if event = 104 then
38678: LD_VAR 0 1
38682: PUSH
38683: LD_INT 104
38685: EQUAL
38686: IFFALSE 38692
// MC_TurretWeapon ( ) ;
38688: CALL 46720 0 0
// if event = 105 then
38692: LD_VAR 0 1
38696: PUSH
38697: LD_INT 105
38699: EQUAL
38700: IFFALSE 38706
// MC_BuildUpgrade ( ) ;
38702: CALL 46271 0 0
// if event = 106 then
38706: LD_VAR 0 1
38710: PUSH
38711: LD_INT 106
38713: EQUAL
38714: IFFALSE 38720
// MC_PlantMines ( ) ;
38716: CALL 47150 0 0
// if event = 107 then
38720: LD_VAR 0 1
38724: PUSH
38725: LD_INT 107
38727: EQUAL
38728: IFFALSE 38734
// MC_CollectCrates ( ) ;
38730: CALL 47948 0 0
// if event = 108 then
38734: LD_VAR 0 1
38738: PUSH
38739: LD_INT 108
38741: EQUAL
38742: IFFALSE 38748
// MC_LinkRemoteControl ( ) ;
38744: CALL 49724 0 0
// if event = 109 then
38748: LD_VAR 0 1
38752: PUSH
38753: LD_INT 109
38755: EQUAL
38756: IFFALSE 38762
// MC_ProduceVehicle ( ) ;
38758: CALL 49905 0 0
// if event = 110 then
38762: LD_VAR 0 1
38766: PUSH
38767: LD_INT 110
38769: EQUAL
38770: IFFALSE 38776
// MC_SendAttack ( ) ;
38772: CALL 50371 0 0
// if event = 111 then
38776: LD_VAR 0 1
38780: PUSH
38781: LD_INT 111
38783: EQUAL
38784: IFFALSE 38790
// MC_Defend ( ) ;
38786: CALL 50479 0 0
// if event = 112 then
38790: LD_VAR 0 1
38794: PUSH
38795: LD_INT 112
38797: EQUAL
38798: IFFALSE 38804
// MC_Research ( ) ;
38800: CALL 51084 0 0
// if event = 113 then
38804: LD_VAR 0 1
38808: PUSH
38809: LD_INT 113
38811: EQUAL
38812: IFFALSE 38818
// MC_MinesTrigger ( ) ;
38814: CALL 52198 0 0
// if event = 120 then
38818: LD_VAR 0 1
38822: PUSH
38823: LD_INT 120
38825: EQUAL
38826: IFFALSE 38832
// MC_RepairVehicle ( ) ;
38828: CALL 52297 0 0
// if event = 121 then
38832: LD_VAR 0 1
38836: PUSH
38837: LD_INT 121
38839: EQUAL
38840: IFFALSE 38846
// MC_TameApe ( ) ;
38842: CALL 53027 0 0
// if event = 122 then
38846: LD_VAR 0 1
38850: PUSH
38851: LD_INT 122
38853: EQUAL
38854: IFFALSE 38860
// MC_ChangeApeClass ( ) ;
38856: CALL 53856 0 0
// if event = 123 then
38860: LD_VAR 0 1
38864: PUSH
38865: LD_INT 123
38867: EQUAL
38868: IFFALSE 38874
// MC_Bazooka ( ) ;
38870: CALL 54506 0 0
// if event = 124 then
38874: LD_VAR 0 1
38878: PUSH
38879: LD_INT 124
38881: EQUAL
38882: IFFALSE 38888
// MC_TeleportExit ( ) ;
38884: CALL 54704 0 0
// if event = 125 then
38888: LD_VAR 0 1
38892: PUSH
38893: LD_INT 125
38895: EQUAL
38896: IFFALSE 38902
// MC_Deposits ( ) ;
38898: CALL 55351 0 0
// if event = 126 then
38902: LD_VAR 0 1
38906: PUSH
38907: LD_INT 126
38909: EQUAL
38910: IFFALSE 38916
// MC_RemoteDriver ( ) ;
38912: CALL 55976 0 0
// if event = 200 then
38916: LD_VAR 0 1
38920: PUSH
38921: LD_INT 200
38923: EQUAL
38924: IFFALSE 38930
// MC_Idle ( ) ;
38926: CALL 57925 0 0
// end ;
38930: PPOPN 1
38932: END
// export function MC_Reset ( base , tag ) ; var i ; begin
38933: LD_INT 0
38935: PPUSH
38936: PPUSH
// if not mc_bases [ base ] or not tag then
38937: LD_EXP 102
38941: PUSH
38942: LD_VAR 0 1
38946: ARRAY
38947: NOT
38948: PUSH
38949: LD_VAR 0 2
38953: NOT
38954: OR
38955: IFFALSE 38959
// exit ;
38957: GO 39023
// for i in mc_bases [ base ] union mc_ape [ base ] do
38959: LD_ADDR_VAR 0 4
38963: PUSH
38964: LD_EXP 102
38968: PUSH
38969: LD_VAR 0 1
38973: ARRAY
38974: PUSH
38975: LD_EXP 131
38979: PUSH
38980: LD_VAR 0 1
38984: ARRAY
38985: UNION
38986: PUSH
38987: FOR_IN
38988: IFFALSE 39021
// if GetTag ( i ) = tag then
38990: LD_VAR 0 4
38994: PPUSH
38995: CALL_OW 110
38999: PUSH
39000: LD_VAR 0 2
39004: EQUAL
39005: IFFALSE 39019
// SetTag ( i , 0 ) ;
39007: LD_VAR 0 4
39011: PPUSH
39012: LD_INT 0
39014: PPUSH
39015: CALL_OW 109
39019: GO 38987
39021: POP
39022: POP
// end ;
39023: LD_VAR 0 3
39027: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39028: LD_INT 0
39030: PPUSH
39031: PPUSH
39032: PPUSH
39033: PPUSH
39034: PPUSH
39035: PPUSH
39036: PPUSH
39037: PPUSH
// if not mc_bases then
39038: LD_EXP 102
39042: NOT
39043: IFFALSE 39047
// exit ;
39045: GO 39505
// for i = 1 to mc_bases do
39047: LD_ADDR_VAR 0 2
39051: PUSH
39052: DOUBLE
39053: LD_INT 1
39055: DEC
39056: ST_TO_ADDR
39057: LD_EXP 102
39061: PUSH
39062: FOR_TO
39063: IFFALSE 39503
// begin tmp := MC_ClassCheckReq ( i ) ;
39065: LD_ADDR_VAR 0 4
39069: PUSH
39070: LD_VAR 0 2
39074: PPUSH
39075: CALL 39510 0 1
39079: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39080: LD_ADDR_EXP 143
39084: PUSH
39085: LD_EXP 143
39089: PPUSH
39090: LD_VAR 0 2
39094: PPUSH
39095: LD_VAR 0 4
39099: PPUSH
39100: CALL_OW 1
39104: ST_TO_ADDR
// if not tmp then
39105: LD_VAR 0 4
39109: NOT
39110: IFFALSE 39114
// continue ;
39112: GO 39062
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39114: LD_ADDR_VAR 0 6
39118: PUSH
39119: LD_EXP 102
39123: PUSH
39124: LD_VAR 0 2
39128: ARRAY
39129: PPUSH
39130: LD_INT 2
39132: PUSH
39133: LD_INT 30
39135: PUSH
39136: LD_INT 4
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 30
39145: PUSH
39146: LD_INT 5
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: EMPTY
39154: LIST
39155: LIST
39156: LIST
39157: PPUSH
39158: CALL_OW 72
39162: PUSH
39163: LD_EXP 102
39167: PUSH
39168: LD_VAR 0 2
39172: ARRAY
39173: PPUSH
39174: LD_INT 2
39176: PUSH
39177: LD_INT 30
39179: PUSH
39180: LD_INT 0
39182: PUSH
39183: EMPTY
39184: LIST
39185: LIST
39186: PUSH
39187: LD_INT 30
39189: PUSH
39190: LD_INT 1
39192: PUSH
39193: EMPTY
39194: LIST
39195: LIST
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: LIST
39201: PPUSH
39202: CALL_OW 72
39206: PUSH
39207: LD_EXP 102
39211: PUSH
39212: LD_VAR 0 2
39216: ARRAY
39217: PPUSH
39218: LD_INT 30
39220: PUSH
39221: LD_INT 3
39223: PUSH
39224: EMPTY
39225: LIST
39226: LIST
39227: PPUSH
39228: CALL_OW 72
39232: PUSH
39233: LD_EXP 102
39237: PUSH
39238: LD_VAR 0 2
39242: ARRAY
39243: PPUSH
39244: LD_INT 2
39246: PUSH
39247: LD_INT 30
39249: PUSH
39250: LD_INT 6
39252: PUSH
39253: EMPTY
39254: LIST
39255: LIST
39256: PUSH
39257: LD_INT 30
39259: PUSH
39260: LD_INT 7
39262: PUSH
39263: EMPTY
39264: LIST
39265: LIST
39266: PUSH
39267: LD_INT 30
39269: PUSH
39270: LD_INT 8
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: LIST
39281: LIST
39282: PPUSH
39283: CALL_OW 72
39287: PUSH
39288: EMPTY
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: ST_TO_ADDR
// for j = 1 to 4 do
39294: LD_ADDR_VAR 0 3
39298: PUSH
39299: DOUBLE
39300: LD_INT 1
39302: DEC
39303: ST_TO_ADDR
39304: LD_INT 4
39306: PUSH
39307: FOR_TO
39308: IFFALSE 39499
// begin if not tmp [ j ] then
39310: LD_VAR 0 4
39314: PUSH
39315: LD_VAR 0 3
39319: ARRAY
39320: NOT
39321: IFFALSE 39325
// continue ;
39323: GO 39307
// for p in tmp [ j ] do
39325: LD_ADDR_VAR 0 5
39329: PUSH
39330: LD_VAR 0 4
39334: PUSH
39335: LD_VAR 0 3
39339: ARRAY
39340: PUSH
39341: FOR_IN
39342: IFFALSE 39495
// begin if not b [ j ] then
39344: LD_VAR 0 6
39348: PUSH
39349: LD_VAR 0 3
39353: ARRAY
39354: NOT
39355: IFFALSE 39359
// break ;
39357: GO 39495
// e := 0 ;
39359: LD_ADDR_VAR 0 7
39363: PUSH
39364: LD_INT 0
39366: ST_TO_ADDR
// for k in b [ j ] do
39367: LD_ADDR_VAR 0 8
39371: PUSH
39372: LD_VAR 0 6
39376: PUSH
39377: LD_VAR 0 3
39381: ARRAY
39382: PUSH
39383: FOR_IN
39384: IFFALSE 39411
// if IsNotFull ( k ) then
39386: LD_VAR 0 8
39390: PPUSH
39391: CALL 69457 0 1
39395: IFFALSE 39409
// begin e := k ;
39397: LD_ADDR_VAR 0 7
39401: PUSH
39402: LD_VAR 0 8
39406: ST_TO_ADDR
// break ;
39407: GO 39411
// end ;
39409: GO 39383
39411: POP
39412: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39413: LD_VAR 0 7
39417: PUSH
39418: LD_VAR 0 5
39422: PPUSH
39423: LD_VAR 0 7
39427: PPUSH
39428: CALL 106586 0 2
39432: NOT
39433: AND
39434: IFFALSE 39493
// begin if IsInUnit ( p ) then
39436: LD_VAR 0 5
39440: PPUSH
39441: CALL_OW 310
39445: IFFALSE 39456
// ComExitBuilding ( p ) ;
39447: LD_VAR 0 5
39451: PPUSH
39452: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39456: LD_VAR 0 5
39460: PPUSH
39461: LD_VAR 0 7
39465: PPUSH
39466: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39470: LD_VAR 0 5
39474: PPUSH
39475: LD_VAR 0 3
39479: PPUSH
39480: CALL_OW 183
// AddComExitBuilding ( p ) ;
39484: LD_VAR 0 5
39488: PPUSH
39489: CALL_OW 182
// end ; end ;
39493: GO 39341
39495: POP
39496: POP
// end ;
39497: GO 39307
39499: POP
39500: POP
// end ;
39501: GO 39062
39503: POP
39504: POP
// end ;
39505: LD_VAR 0 1
39509: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39510: LD_INT 0
39512: PPUSH
39513: PPUSH
39514: PPUSH
39515: PPUSH
39516: PPUSH
39517: PPUSH
39518: PPUSH
39519: PPUSH
39520: PPUSH
39521: PPUSH
39522: PPUSH
39523: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39524: LD_VAR 0 1
39528: NOT
39529: PUSH
39530: LD_EXP 102
39534: PUSH
39535: LD_VAR 0 1
39539: ARRAY
39540: NOT
39541: OR
39542: PUSH
39543: LD_EXP 102
39547: PUSH
39548: LD_VAR 0 1
39552: ARRAY
39553: PPUSH
39554: LD_INT 2
39556: PUSH
39557: LD_INT 30
39559: PUSH
39560: LD_INT 0
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 30
39569: PUSH
39570: LD_INT 1
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: EMPTY
39578: LIST
39579: LIST
39580: LIST
39581: PPUSH
39582: CALL_OW 72
39586: NOT
39587: OR
39588: IFFALSE 39592
// exit ;
39590: GO 43095
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39592: LD_ADDR_VAR 0 4
39596: PUSH
39597: LD_EXP 102
39601: PUSH
39602: LD_VAR 0 1
39606: ARRAY
39607: PPUSH
39608: LD_INT 2
39610: PUSH
39611: LD_INT 25
39613: PUSH
39614: LD_INT 1
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: PUSH
39621: LD_INT 25
39623: PUSH
39624: LD_INT 2
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 25
39633: PUSH
39634: LD_INT 3
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 25
39643: PUSH
39644: LD_INT 4
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 25
39653: PUSH
39654: LD_INT 5
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 25
39663: PUSH
39664: LD_INT 8
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 25
39673: PUSH
39674: LD_INT 9
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: LIST
39685: LIST
39686: LIST
39687: LIST
39688: LIST
39689: LIST
39690: PPUSH
39691: CALL_OW 72
39695: ST_TO_ADDR
// if not tmp then
39696: LD_VAR 0 4
39700: NOT
39701: IFFALSE 39705
// exit ;
39703: GO 43095
// for i in tmp do
39705: LD_ADDR_VAR 0 3
39709: PUSH
39710: LD_VAR 0 4
39714: PUSH
39715: FOR_IN
39716: IFFALSE 39747
// if GetTag ( i ) then
39718: LD_VAR 0 3
39722: PPUSH
39723: CALL_OW 110
39727: IFFALSE 39745
// tmp := tmp diff i ;
39729: LD_ADDR_VAR 0 4
39733: PUSH
39734: LD_VAR 0 4
39738: PUSH
39739: LD_VAR 0 3
39743: DIFF
39744: ST_TO_ADDR
39745: GO 39715
39747: POP
39748: POP
// if not tmp then
39749: LD_VAR 0 4
39753: NOT
39754: IFFALSE 39758
// exit ;
39756: GO 43095
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
39758: LD_ADDR_VAR 0 5
39762: PUSH
39763: LD_EXP 102
39767: PUSH
39768: LD_VAR 0 1
39772: ARRAY
39773: PPUSH
39774: LD_INT 2
39776: PUSH
39777: LD_INT 25
39779: PUSH
39780: LD_INT 1
39782: PUSH
39783: EMPTY
39784: LIST
39785: LIST
39786: PUSH
39787: LD_INT 25
39789: PUSH
39790: LD_INT 5
39792: PUSH
39793: EMPTY
39794: LIST
39795: LIST
39796: PUSH
39797: LD_INT 25
39799: PUSH
39800: LD_INT 8
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 25
39809: PUSH
39810: LD_INT 9
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: EMPTY
39818: LIST
39819: LIST
39820: LIST
39821: LIST
39822: LIST
39823: PPUSH
39824: CALL_OW 72
39828: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
39829: LD_ADDR_VAR 0 6
39833: PUSH
39834: LD_EXP 102
39838: PUSH
39839: LD_VAR 0 1
39843: ARRAY
39844: PPUSH
39845: LD_INT 25
39847: PUSH
39848: LD_INT 2
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PPUSH
39855: CALL_OW 72
39859: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
39860: LD_ADDR_VAR 0 7
39864: PUSH
39865: LD_EXP 102
39869: PUSH
39870: LD_VAR 0 1
39874: ARRAY
39875: PPUSH
39876: LD_INT 25
39878: PUSH
39879: LD_INT 3
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PPUSH
39886: CALL_OW 72
39890: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
39891: LD_ADDR_VAR 0 8
39895: PUSH
39896: LD_EXP 102
39900: PUSH
39901: LD_VAR 0 1
39905: ARRAY
39906: PPUSH
39907: LD_INT 25
39909: PUSH
39910: LD_INT 4
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 24
39919: PUSH
39920: LD_INT 251
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PPUSH
39931: CALL_OW 72
39935: ST_TO_ADDR
// if mc_scan [ base ] then
39936: LD_EXP 125
39940: PUSH
39941: LD_VAR 0 1
39945: ARRAY
39946: IFFALSE 40407
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39948: LD_ADDR_EXP 144
39952: PUSH
39953: LD_EXP 144
39957: PPUSH
39958: LD_VAR 0 1
39962: PPUSH
39963: LD_INT 4
39965: PPUSH
39966: CALL_OW 1
39970: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39971: LD_ADDR_VAR 0 12
39975: PUSH
39976: LD_EXP 102
39980: PUSH
39981: LD_VAR 0 1
39985: ARRAY
39986: PPUSH
39987: LD_INT 2
39989: PUSH
39990: LD_INT 30
39992: PUSH
39993: LD_INT 4
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PUSH
40000: LD_INT 30
40002: PUSH
40003: LD_INT 5
40005: PUSH
40006: EMPTY
40007: LIST
40008: LIST
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: LIST
40014: PPUSH
40015: CALL_OW 72
40019: ST_TO_ADDR
// if not b then
40020: LD_VAR 0 12
40024: NOT
40025: IFFALSE 40029
// exit ;
40027: GO 43095
// p := [ ] ;
40029: LD_ADDR_VAR 0 11
40033: PUSH
40034: EMPTY
40035: ST_TO_ADDR
// if sci >= 2 then
40036: LD_VAR 0 8
40040: PUSH
40041: LD_INT 2
40043: GREATEREQUAL
40044: IFFALSE 40075
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40046: LD_ADDR_VAR 0 8
40050: PUSH
40051: LD_VAR 0 8
40055: PUSH
40056: LD_INT 1
40058: ARRAY
40059: PUSH
40060: LD_VAR 0 8
40064: PUSH
40065: LD_INT 2
40067: ARRAY
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: ST_TO_ADDR
40073: GO 40136
// if sci = 1 then
40075: LD_VAR 0 8
40079: PUSH
40080: LD_INT 1
40082: EQUAL
40083: IFFALSE 40104
// sci := [ sci [ 1 ] ] else
40085: LD_ADDR_VAR 0 8
40089: PUSH
40090: LD_VAR 0 8
40094: PUSH
40095: LD_INT 1
40097: ARRAY
40098: PUSH
40099: EMPTY
40100: LIST
40101: ST_TO_ADDR
40102: GO 40136
// if sci = 0 then
40104: LD_VAR 0 8
40108: PUSH
40109: LD_INT 0
40111: EQUAL
40112: IFFALSE 40136
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40114: LD_ADDR_VAR 0 11
40118: PUSH
40119: LD_VAR 0 4
40123: PPUSH
40124: LD_INT 4
40126: PPUSH
40127: CALL 106449 0 2
40131: PUSH
40132: LD_INT 1
40134: ARRAY
40135: ST_TO_ADDR
// if eng > 4 then
40136: LD_VAR 0 6
40140: PUSH
40141: LD_INT 4
40143: GREATER
40144: IFFALSE 40190
// for i = eng downto 4 do
40146: LD_ADDR_VAR 0 3
40150: PUSH
40151: DOUBLE
40152: LD_VAR 0 6
40156: INC
40157: ST_TO_ADDR
40158: LD_INT 4
40160: PUSH
40161: FOR_DOWNTO
40162: IFFALSE 40188
// eng := eng diff eng [ i ] ;
40164: LD_ADDR_VAR 0 6
40168: PUSH
40169: LD_VAR 0 6
40173: PUSH
40174: LD_VAR 0 6
40178: PUSH
40179: LD_VAR 0 3
40183: ARRAY
40184: DIFF
40185: ST_TO_ADDR
40186: GO 40161
40188: POP
40189: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40190: LD_ADDR_VAR 0 4
40194: PUSH
40195: LD_VAR 0 4
40199: PUSH
40200: LD_VAR 0 5
40204: PUSH
40205: LD_VAR 0 6
40209: UNION
40210: PUSH
40211: LD_VAR 0 7
40215: UNION
40216: PUSH
40217: LD_VAR 0 8
40221: UNION
40222: DIFF
40223: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40224: LD_ADDR_VAR 0 13
40228: PUSH
40229: LD_EXP 102
40233: PUSH
40234: LD_VAR 0 1
40238: ARRAY
40239: PPUSH
40240: LD_INT 2
40242: PUSH
40243: LD_INT 30
40245: PUSH
40246: LD_INT 32
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 30
40255: PUSH
40256: LD_INT 31
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: LIST
40267: PPUSH
40268: CALL_OW 72
40272: PUSH
40273: LD_EXP 102
40277: PUSH
40278: LD_VAR 0 1
40282: ARRAY
40283: PPUSH
40284: LD_INT 2
40286: PUSH
40287: LD_INT 30
40289: PUSH
40290: LD_INT 4
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 30
40299: PUSH
40300: LD_INT 5
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: PUSH
40307: EMPTY
40308: LIST
40309: LIST
40310: LIST
40311: PPUSH
40312: CALL_OW 72
40316: PUSH
40317: LD_INT 6
40319: MUL
40320: PLUS
40321: ST_TO_ADDR
// if bcount < tmp then
40322: LD_VAR 0 13
40326: PUSH
40327: LD_VAR 0 4
40331: LESS
40332: IFFALSE 40378
// for i = tmp downto bcount do
40334: LD_ADDR_VAR 0 3
40338: PUSH
40339: DOUBLE
40340: LD_VAR 0 4
40344: INC
40345: ST_TO_ADDR
40346: LD_VAR 0 13
40350: PUSH
40351: FOR_DOWNTO
40352: IFFALSE 40376
// tmp := Delete ( tmp , tmp ) ;
40354: LD_ADDR_VAR 0 4
40358: PUSH
40359: LD_VAR 0 4
40363: PPUSH
40364: LD_VAR 0 4
40368: PPUSH
40369: CALL_OW 3
40373: ST_TO_ADDR
40374: GO 40351
40376: POP
40377: POP
// result := [ tmp , 0 , 0 , p ] ;
40378: LD_ADDR_VAR 0 2
40382: PUSH
40383: LD_VAR 0 4
40387: PUSH
40388: LD_INT 0
40390: PUSH
40391: LD_INT 0
40393: PUSH
40394: LD_VAR 0 11
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: LIST
40403: LIST
40404: ST_TO_ADDR
// exit ;
40405: GO 43095
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40407: LD_EXP 102
40411: PUSH
40412: LD_VAR 0 1
40416: ARRAY
40417: PPUSH
40418: LD_INT 2
40420: PUSH
40421: LD_INT 30
40423: PUSH
40424: LD_INT 6
40426: PUSH
40427: EMPTY
40428: LIST
40429: LIST
40430: PUSH
40431: LD_INT 30
40433: PUSH
40434: LD_INT 7
40436: PUSH
40437: EMPTY
40438: LIST
40439: LIST
40440: PUSH
40441: LD_INT 30
40443: PUSH
40444: LD_INT 8
40446: PUSH
40447: EMPTY
40448: LIST
40449: LIST
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: LIST
40455: LIST
40456: PPUSH
40457: CALL_OW 72
40461: NOT
40462: PUSH
40463: LD_EXP 102
40467: PUSH
40468: LD_VAR 0 1
40472: ARRAY
40473: PPUSH
40474: LD_INT 30
40476: PUSH
40477: LD_INT 3
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PPUSH
40484: CALL_OW 72
40488: NOT
40489: AND
40490: IFFALSE 40562
// begin if eng = tmp then
40492: LD_VAR 0 6
40496: PUSH
40497: LD_VAR 0 4
40501: EQUAL
40502: IFFALSE 40506
// exit ;
40504: GO 43095
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40506: LD_ADDR_EXP 144
40510: PUSH
40511: LD_EXP 144
40515: PPUSH
40516: LD_VAR 0 1
40520: PPUSH
40521: LD_INT 1
40523: PPUSH
40524: CALL_OW 1
40528: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
40529: LD_ADDR_VAR 0 2
40533: PUSH
40534: LD_INT 0
40536: PUSH
40537: LD_VAR 0 4
40541: PUSH
40542: LD_VAR 0 6
40546: DIFF
40547: PUSH
40548: LD_INT 0
40550: PUSH
40551: LD_INT 0
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: ST_TO_ADDR
// exit ;
40560: GO 43095
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40562: LD_EXP 129
40566: PUSH
40567: LD_EXP 128
40571: PUSH
40572: LD_VAR 0 1
40576: ARRAY
40577: ARRAY
40578: PUSH
40579: LD_EXP 102
40583: PUSH
40584: LD_VAR 0 1
40588: ARRAY
40589: PPUSH
40590: LD_INT 2
40592: PUSH
40593: LD_INT 30
40595: PUSH
40596: LD_INT 6
40598: PUSH
40599: EMPTY
40600: LIST
40601: LIST
40602: PUSH
40603: LD_INT 30
40605: PUSH
40606: LD_INT 7
40608: PUSH
40609: EMPTY
40610: LIST
40611: LIST
40612: PUSH
40613: LD_INT 30
40615: PUSH
40616: LD_INT 8
40618: PUSH
40619: EMPTY
40620: LIST
40621: LIST
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: PPUSH
40629: CALL_OW 72
40633: AND
40634: PUSH
40635: LD_EXP 102
40639: PUSH
40640: LD_VAR 0 1
40644: ARRAY
40645: PPUSH
40646: LD_INT 30
40648: PUSH
40649: LD_INT 3
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PPUSH
40656: CALL_OW 72
40660: NOT
40661: AND
40662: IFFALSE 40876
// begin if sci >= 6 then
40664: LD_VAR 0 8
40668: PUSH
40669: LD_INT 6
40671: GREATEREQUAL
40672: IFFALSE 40676
// exit ;
40674: GO 43095
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
40676: LD_ADDR_EXP 144
40680: PUSH
40681: LD_EXP 144
40685: PPUSH
40686: LD_VAR 0 1
40690: PPUSH
40691: LD_INT 2
40693: PPUSH
40694: CALL_OW 1
40698: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
40699: LD_ADDR_VAR 0 9
40703: PUSH
40704: LD_VAR 0 4
40708: PUSH
40709: LD_VAR 0 8
40713: DIFF
40714: PPUSH
40715: LD_INT 4
40717: PPUSH
40718: CALL 106449 0 2
40722: ST_TO_ADDR
// p := [ ] ;
40723: LD_ADDR_VAR 0 11
40727: PUSH
40728: EMPTY
40729: ST_TO_ADDR
// if sci < 6 and sort > 6 then
40730: LD_VAR 0 8
40734: PUSH
40735: LD_INT 6
40737: LESS
40738: PUSH
40739: LD_VAR 0 9
40743: PUSH
40744: LD_INT 6
40746: GREATER
40747: AND
40748: IFFALSE 40829
// begin for i = 1 to 6 - sci do
40750: LD_ADDR_VAR 0 3
40754: PUSH
40755: DOUBLE
40756: LD_INT 1
40758: DEC
40759: ST_TO_ADDR
40760: LD_INT 6
40762: PUSH
40763: LD_VAR 0 8
40767: MINUS
40768: PUSH
40769: FOR_TO
40770: IFFALSE 40825
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
40772: LD_ADDR_VAR 0 11
40776: PUSH
40777: LD_VAR 0 11
40781: PPUSH
40782: LD_VAR 0 11
40786: PUSH
40787: LD_INT 1
40789: PLUS
40790: PPUSH
40791: LD_VAR 0 9
40795: PUSH
40796: LD_INT 1
40798: ARRAY
40799: PPUSH
40800: CALL_OW 2
40804: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
40805: LD_ADDR_VAR 0 9
40809: PUSH
40810: LD_VAR 0 9
40814: PPUSH
40815: LD_INT 1
40817: PPUSH
40818: CALL_OW 3
40822: ST_TO_ADDR
// end ;
40823: GO 40769
40825: POP
40826: POP
// end else
40827: GO 40849
// if sort then
40829: LD_VAR 0 9
40833: IFFALSE 40849
// p := sort [ 1 ] ;
40835: LD_ADDR_VAR 0 11
40839: PUSH
40840: LD_VAR 0 9
40844: PUSH
40845: LD_INT 1
40847: ARRAY
40848: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
40849: LD_ADDR_VAR 0 2
40853: PUSH
40854: LD_INT 0
40856: PUSH
40857: LD_INT 0
40859: PUSH
40860: LD_INT 0
40862: PUSH
40863: LD_VAR 0 11
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: LIST
40872: LIST
40873: ST_TO_ADDR
// exit ;
40874: GO 43095
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40876: LD_EXP 129
40880: PUSH
40881: LD_EXP 128
40885: PUSH
40886: LD_VAR 0 1
40890: ARRAY
40891: ARRAY
40892: PUSH
40893: LD_EXP 102
40897: PUSH
40898: LD_VAR 0 1
40902: ARRAY
40903: PPUSH
40904: LD_INT 2
40906: PUSH
40907: LD_INT 30
40909: PUSH
40910: LD_INT 6
40912: PUSH
40913: EMPTY
40914: LIST
40915: LIST
40916: PUSH
40917: LD_INT 30
40919: PUSH
40920: LD_INT 7
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 30
40929: PUSH
40930: LD_INT 8
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: LIST
40941: LIST
40942: PPUSH
40943: CALL_OW 72
40947: AND
40948: PUSH
40949: LD_EXP 102
40953: PUSH
40954: LD_VAR 0 1
40958: ARRAY
40959: PPUSH
40960: LD_INT 30
40962: PUSH
40963: LD_INT 3
40965: PUSH
40966: EMPTY
40967: LIST
40968: LIST
40969: PPUSH
40970: CALL_OW 72
40974: AND
40975: IFFALSE 41709
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40977: LD_ADDR_EXP 144
40981: PUSH
40982: LD_EXP 144
40986: PPUSH
40987: LD_VAR 0 1
40991: PPUSH
40992: LD_INT 3
40994: PPUSH
40995: CALL_OW 1
40999: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41000: LD_ADDR_VAR 0 2
41004: PUSH
41005: LD_INT 0
41007: PUSH
41008: LD_INT 0
41010: PUSH
41011: LD_INT 0
41013: PUSH
41014: LD_INT 0
41016: PUSH
41017: EMPTY
41018: LIST
41019: LIST
41020: LIST
41021: LIST
41022: ST_TO_ADDR
// if not eng then
41023: LD_VAR 0 6
41027: NOT
41028: IFFALSE 41091
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41030: LD_ADDR_VAR 0 11
41034: PUSH
41035: LD_VAR 0 4
41039: PPUSH
41040: LD_INT 2
41042: PPUSH
41043: CALL 106449 0 2
41047: PUSH
41048: LD_INT 1
41050: ARRAY
41051: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41052: LD_ADDR_VAR 0 2
41056: PUSH
41057: LD_VAR 0 2
41061: PPUSH
41062: LD_INT 2
41064: PPUSH
41065: LD_VAR 0 11
41069: PPUSH
41070: CALL_OW 1
41074: ST_TO_ADDR
// tmp := tmp diff p ;
41075: LD_ADDR_VAR 0 4
41079: PUSH
41080: LD_VAR 0 4
41084: PUSH
41085: LD_VAR 0 11
41089: DIFF
41090: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41091: LD_VAR 0 4
41095: PUSH
41096: LD_VAR 0 8
41100: PUSH
41101: LD_INT 6
41103: LESS
41104: AND
41105: IFFALSE 41293
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41107: LD_ADDR_VAR 0 9
41111: PUSH
41112: LD_VAR 0 4
41116: PUSH
41117: LD_VAR 0 8
41121: PUSH
41122: LD_VAR 0 7
41126: UNION
41127: DIFF
41128: PPUSH
41129: LD_INT 4
41131: PPUSH
41132: CALL 106449 0 2
41136: ST_TO_ADDR
// p := [ ] ;
41137: LD_ADDR_VAR 0 11
41141: PUSH
41142: EMPTY
41143: ST_TO_ADDR
// if sort then
41144: LD_VAR 0 9
41148: IFFALSE 41264
// for i = 1 to 6 - sci do
41150: LD_ADDR_VAR 0 3
41154: PUSH
41155: DOUBLE
41156: LD_INT 1
41158: DEC
41159: ST_TO_ADDR
41160: LD_INT 6
41162: PUSH
41163: LD_VAR 0 8
41167: MINUS
41168: PUSH
41169: FOR_TO
41170: IFFALSE 41262
// begin if i = sort then
41172: LD_VAR 0 3
41176: PUSH
41177: LD_VAR 0 9
41181: EQUAL
41182: IFFALSE 41186
// break ;
41184: GO 41262
// if GetClass ( i ) = 4 then
41186: LD_VAR 0 3
41190: PPUSH
41191: CALL_OW 257
41195: PUSH
41196: LD_INT 4
41198: EQUAL
41199: IFFALSE 41203
// continue ;
41201: GO 41169
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41203: LD_ADDR_VAR 0 11
41207: PUSH
41208: LD_VAR 0 11
41212: PPUSH
41213: LD_VAR 0 11
41217: PUSH
41218: LD_INT 1
41220: PLUS
41221: PPUSH
41222: LD_VAR 0 9
41226: PUSH
41227: LD_VAR 0 3
41231: ARRAY
41232: PPUSH
41233: CALL_OW 2
41237: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41238: LD_ADDR_VAR 0 4
41242: PUSH
41243: LD_VAR 0 4
41247: PUSH
41248: LD_VAR 0 9
41252: PUSH
41253: LD_VAR 0 3
41257: ARRAY
41258: DIFF
41259: ST_TO_ADDR
// end ;
41260: GO 41169
41262: POP
41263: POP
// if p then
41264: LD_VAR 0 11
41268: IFFALSE 41293
// result := Replace ( result , 4 , p ) ;
41270: LD_ADDR_VAR 0 2
41274: PUSH
41275: LD_VAR 0 2
41279: PPUSH
41280: LD_INT 4
41282: PPUSH
41283: LD_VAR 0 11
41287: PPUSH
41288: CALL_OW 1
41292: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41293: LD_VAR 0 4
41297: PUSH
41298: LD_VAR 0 7
41302: PUSH
41303: LD_INT 6
41305: LESS
41306: AND
41307: IFFALSE 41495
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41309: LD_ADDR_VAR 0 9
41313: PUSH
41314: LD_VAR 0 4
41318: PUSH
41319: LD_VAR 0 8
41323: PUSH
41324: LD_VAR 0 7
41328: UNION
41329: DIFF
41330: PPUSH
41331: LD_INT 3
41333: PPUSH
41334: CALL 106449 0 2
41338: ST_TO_ADDR
// p := [ ] ;
41339: LD_ADDR_VAR 0 11
41343: PUSH
41344: EMPTY
41345: ST_TO_ADDR
// if sort then
41346: LD_VAR 0 9
41350: IFFALSE 41466
// for i = 1 to 6 - mech do
41352: LD_ADDR_VAR 0 3
41356: PUSH
41357: DOUBLE
41358: LD_INT 1
41360: DEC
41361: ST_TO_ADDR
41362: LD_INT 6
41364: PUSH
41365: LD_VAR 0 7
41369: MINUS
41370: PUSH
41371: FOR_TO
41372: IFFALSE 41464
// begin if i = sort then
41374: LD_VAR 0 3
41378: PUSH
41379: LD_VAR 0 9
41383: EQUAL
41384: IFFALSE 41388
// break ;
41386: GO 41464
// if GetClass ( i ) = 3 then
41388: LD_VAR 0 3
41392: PPUSH
41393: CALL_OW 257
41397: PUSH
41398: LD_INT 3
41400: EQUAL
41401: IFFALSE 41405
// continue ;
41403: GO 41371
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41405: LD_ADDR_VAR 0 11
41409: PUSH
41410: LD_VAR 0 11
41414: PPUSH
41415: LD_VAR 0 11
41419: PUSH
41420: LD_INT 1
41422: PLUS
41423: PPUSH
41424: LD_VAR 0 9
41428: PUSH
41429: LD_VAR 0 3
41433: ARRAY
41434: PPUSH
41435: CALL_OW 2
41439: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41440: LD_ADDR_VAR 0 4
41444: PUSH
41445: LD_VAR 0 4
41449: PUSH
41450: LD_VAR 0 9
41454: PUSH
41455: LD_VAR 0 3
41459: ARRAY
41460: DIFF
41461: ST_TO_ADDR
// end ;
41462: GO 41371
41464: POP
41465: POP
// if p then
41466: LD_VAR 0 11
41470: IFFALSE 41495
// result := Replace ( result , 3 , p ) ;
41472: LD_ADDR_VAR 0 2
41476: PUSH
41477: LD_VAR 0 2
41481: PPUSH
41482: LD_INT 3
41484: PPUSH
41485: LD_VAR 0 11
41489: PPUSH
41490: CALL_OW 1
41494: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41495: LD_VAR 0 4
41499: PUSH
41500: LD_INT 6
41502: GREATER
41503: PUSH
41504: LD_VAR 0 6
41508: PUSH
41509: LD_INT 6
41511: LESS
41512: AND
41513: IFFALSE 41707
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41515: LD_ADDR_VAR 0 9
41519: PUSH
41520: LD_VAR 0 4
41524: PUSH
41525: LD_VAR 0 8
41529: PUSH
41530: LD_VAR 0 7
41534: UNION
41535: PUSH
41536: LD_VAR 0 6
41540: UNION
41541: DIFF
41542: PPUSH
41543: LD_INT 2
41545: PPUSH
41546: CALL 106449 0 2
41550: ST_TO_ADDR
// p := [ ] ;
41551: LD_ADDR_VAR 0 11
41555: PUSH
41556: EMPTY
41557: ST_TO_ADDR
// if sort then
41558: LD_VAR 0 9
41562: IFFALSE 41678
// for i = 1 to 6 - eng do
41564: LD_ADDR_VAR 0 3
41568: PUSH
41569: DOUBLE
41570: LD_INT 1
41572: DEC
41573: ST_TO_ADDR
41574: LD_INT 6
41576: PUSH
41577: LD_VAR 0 6
41581: MINUS
41582: PUSH
41583: FOR_TO
41584: IFFALSE 41676
// begin if i = sort then
41586: LD_VAR 0 3
41590: PUSH
41591: LD_VAR 0 9
41595: EQUAL
41596: IFFALSE 41600
// break ;
41598: GO 41676
// if GetClass ( i ) = 2 then
41600: LD_VAR 0 3
41604: PPUSH
41605: CALL_OW 257
41609: PUSH
41610: LD_INT 2
41612: EQUAL
41613: IFFALSE 41617
// continue ;
41615: GO 41583
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41617: LD_ADDR_VAR 0 11
41621: PUSH
41622: LD_VAR 0 11
41626: PPUSH
41627: LD_VAR 0 11
41631: PUSH
41632: LD_INT 1
41634: PLUS
41635: PPUSH
41636: LD_VAR 0 9
41640: PUSH
41641: LD_VAR 0 3
41645: ARRAY
41646: PPUSH
41647: CALL_OW 2
41651: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41652: LD_ADDR_VAR 0 4
41656: PUSH
41657: LD_VAR 0 4
41661: PUSH
41662: LD_VAR 0 9
41666: PUSH
41667: LD_VAR 0 3
41671: ARRAY
41672: DIFF
41673: ST_TO_ADDR
// end ;
41674: GO 41583
41676: POP
41677: POP
// if p then
41678: LD_VAR 0 11
41682: IFFALSE 41707
// result := Replace ( result , 2 , p ) ;
41684: LD_ADDR_VAR 0 2
41688: PUSH
41689: LD_VAR 0 2
41693: PPUSH
41694: LD_INT 2
41696: PPUSH
41697: LD_VAR 0 11
41701: PPUSH
41702: CALL_OW 1
41706: ST_TO_ADDR
// end ; exit ;
41707: GO 43095
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
41709: LD_EXP 129
41713: PUSH
41714: LD_EXP 128
41718: PUSH
41719: LD_VAR 0 1
41723: ARRAY
41724: ARRAY
41725: NOT
41726: PUSH
41727: LD_EXP 102
41731: PUSH
41732: LD_VAR 0 1
41736: ARRAY
41737: PPUSH
41738: LD_INT 30
41740: PUSH
41741: LD_INT 3
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PPUSH
41748: CALL_OW 72
41752: AND
41753: PUSH
41754: LD_EXP 107
41758: PUSH
41759: LD_VAR 0 1
41763: ARRAY
41764: AND
41765: IFFALSE 42373
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
41767: LD_ADDR_EXP 144
41771: PUSH
41772: LD_EXP 144
41776: PPUSH
41777: LD_VAR 0 1
41781: PPUSH
41782: LD_INT 5
41784: PPUSH
41785: CALL_OW 1
41789: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41790: LD_ADDR_VAR 0 2
41794: PUSH
41795: LD_INT 0
41797: PUSH
41798: LD_INT 0
41800: PUSH
41801: LD_INT 0
41803: PUSH
41804: LD_INT 0
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: LIST
41811: LIST
41812: ST_TO_ADDR
// if sci > 1 then
41813: LD_VAR 0 8
41817: PUSH
41818: LD_INT 1
41820: GREATER
41821: IFFALSE 41849
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
41823: LD_ADDR_VAR 0 4
41827: PUSH
41828: LD_VAR 0 4
41832: PUSH
41833: LD_VAR 0 8
41837: PUSH
41838: LD_VAR 0 8
41842: PUSH
41843: LD_INT 1
41845: ARRAY
41846: DIFF
41847: DIFF
41848: ST_TO_ADDR
// if tmp and not sci then
41849: LD_VAR 0 4
41853: PUSH
41854: LD_VAR 0 8
41858: NOT
41859: AND
41860: IFFALSE 41929
// begin sort := SortBySkill ( tmp , 4 ) ;
41862: LD_ADDR_VAR 0 9
41866: PUSH
41867: LD_VAR 0 4
41871: PPUSH
41872: LD_INT 4
41874: PPUSH
41875: CALL 106449 0 2
41879: ST_TO_ADDR
// if sort then
41880: LD_VAR 0 9
41884: IFFALSE 41900
// p := sort [ 1 ] ;
41886: LD_ADDR_VAR 0 11
41890: PUSH
41891: LD_VAR 0 9
41895: PUSH
41896: LD_INT 1
41898: ARRAY
41899: ST_TO_ADDR
// if p then
41900: LD_VAR 0 11
41904: IFFALSE 41929
// result := Replace ( result , 4 , p ) ;
41906: LD_ADDR_VAR 0 2
41910: PUSH
41911: LD_VAR 0 2
41915: PPUSH
41916: LD_INT 4
41918: PPUSH
41919: LD_VAR 0 11
41923: PPUSH
41924: CALL_OW 1
41928: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41929: LD_ADDR_VAR 0 4
41933: PUSH
41934: LD_VAR 0 4
41938: PUSH
41939: LD_VAR 0 7
41943: DIFF
41944: ST_TO_ADDR
// if tmp and mech < 6 then
41945: LD_VAR 0 4
41949: PUSH
41950: LD_VAR 0 7
41954: PUSH
41955: LD_INT 6
41957: LESS
41958: AND
41959: IFFALSE 42147
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41961: LD_ADDR_VAR 0 9
41965: PUSH
41966: LD_VAR 0 4
41970: PUSH
41971: LD_VAR 0 8
41975: PUSH
41976: LD_VAR 0 7
41980: UNION
41981: DIFF
41982: PPUSH
41983: LD_INT 3
41985: PPUSH
41986: CALL 106449 0 2
41990: ST_TO_ADDR
// p := [ ] ;
41991: LD_ADDR_VAR 0 11
41995: PUSH
41996: EMPTY
41997: ST_TO_ADDR
// if sort then
41998: LD_VAR 0 9
42002: IFFALSE 42118
// for i = 1 to 6 - mech do
42004: LD_ADDR_VAR 0 3
42008: PUSH
42009: DOUBLE
42010: LD_INT 1
42012: DEC
42013: ST_TO_ADDR
42014: LD_INT 6
42016: PUSH
42017: LD_VAR 0 7
42021: MINUS
42022: PUSH
42023: FOR_TO
42024: IFFALSE 42116
// begin if i = sort then
42026: LD_VAR 0 3
42030: PUSH
42031: LD_VAR 0 9
42035: EQUAL
42036: IFFALSE 42040
// break ;
42038: GO 42116
// if GetClass ( i ) = 3 then
42040: LD_VAR 0 3
42044: PPUSH
42045: CALL_OW 257
42049: PUSH
42050: LD_INT 3
42052: EQUAL
42053: IFFALSE 42057
// continue ;
42055: GO 42023
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42057: LD_ADDR_VAR 0 11
42061: PUSH
42062: LD_VAR 0 11
42066: PPUSH
42067: LD_VAR 0 11
42071: PUSH
42072: LD_INT 1
42074: PLUS
42075: PPUSH
42076: LD_VAR 0 9
42080: PUSH
42081: LD_VAR 0 3
42085: ARRAY
42086: PPUSH
42087: CALL_OW 2
42091: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42092: LD_ADDR_VAR 0 4
42096: PUSH
42097: LD_VAR 0 4
42101: PUSH
42102: LD_VAR 0 9
42106: PUSH
42107: LD_VAR 0 3
42111: ARRAY
42112: DIFF
42113: ST_TO_ADDR
// end ;
42114: GO 42023
42116: POP
42117: POP
// if p then
42118: LD_VAR 0 11
42122: IFFALSE 42147
// result := Replace ( result , 3 , p ) ;
42124: LD_ADDR_VAR 0 2
42128: PUSH
42129: LD_VAR 0 2
42133: PPUSH
42134: LD_INT 3
42136: PPUSH
42137: LD_VAR 0 11
42141: PPUSH
42142: CALL_OW 1
42146: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42147: LD_ADDR_VAR 0 4
42151: PUSH
42152: LD_VAR 0 4
42156: PUSH
42157: LD_VAR 0 6
42161: DIFF
42162: ST_TO_ADDR
// if tmp and eng < 6 then
42163: LD_VAR 0 4
42167: PUSH
42168: LD_VAR 0 6
42172: PUSH
42173: LD_INT 6
42175: LESS
42176: AND
42177: IFFALSE 42371
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42179: LD_ADDR_VAR 0 9
42183: PUSH
42184: LD_VAR 0 4
42188: PUSH
42189: LD_VAR 0 8
42193: PUSH
42194: LD_VAR 0 7
42198: UNION
42199: PUSH
42200: LD_VAR 0 6
42204: UNION
42205: DIFF
42206: PPUSH
42207: LD_INT 2
42209: PPUSH
42210: CALL 106449 0 2
42214: ST_TO_ADDR
// p := [ ] ;
42215: LD_ADDR_VAR 0 11
42219: PUSH
42220: EMPTY
42221: ST_TO_ADDR
// if sort then
42222: LD_VAR 0 9
42226: IFFALSE 42342
// for i = 1 to 6 - eng do
42228: LD_ADDR_VAR 0 3
42232: PUSH
42233: DOUBLE
42234: LD_INT 1
42236: DEC
42237: ST_TO_ADDR
42238: LD_INT 6
42240: PUSH
42241: LD_VAR 0 6
42245: MINUS
42246: PUSH
42247: FOR_TO
42248: IFFALSE 42340
// begin if i = sort then
42250: LD_VAR 0 3
42254: PUSH
42255: LD_VAR 0 9
42259: EQUAL
42260: IFFALSE 42264
// break ;
42262: GO 42340
// if GetClass ( i ) = 2 then
42264: LD_VAR 0 3
42268: PPUSH
42269: CALL_OW 257
42273: PUSH
42274: LD_INT 2
42276: EQUAL
42277: IFFALSE 42281
// continue ;
42279: GO 42247
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42281: LD_ADDR_VAR 0 11
42285: PUSH
42286: LD_VAR 0 11
42290: PPUSH
42291: LD_VAR 0 11
42295: PUSH
42296: LD_INT 1
42298: PLUS
42299: PPUSH
42300: LD_VAR 0 9
42304: PUSH
42305: LD_VAR 0 3
42309: ARRAY
42310: PPUSH
42311: CALL_OW 2
42315: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42316: LD_ADDR_VAR 0 4
42320: PUSH
42321: LD_VAR 0 4
42325: PUSH
42326: LD_VAR 0 9
42330: PUSH
42331: LD_VAR 0 3
42335: ARRAY
42336: DIFF
42337: ST_TO_ADDR
// end ;
42338: GO 42247
42340: POP
42341: POP
// if p then
42342: LD_VAR 0 11
42346: IFFALSE 42371
// result := Replace ( result , 2 , p ) ;
42348: LD_ADDR_VAR 0 2
42352: PUSH
42353: LD_VAR 0 2
42357: PPUSH
42358: LD_INT 2
42360: PPUSH
42361: LD_VAR 0 11
42365: PPUSH
42366: CALL_OW 1
42370: ST_TO_ADDR
// end ; exit ;
42371: GO 43095
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42373: LD_EXP 129
42377: PUSH
42378: LD_EXP 128
42382: PUSH
42383: LD_VAR 0 1
42387: ARRAY
42388: ARRAY
42389: NOT
42390: PUSH
42391: LD_EXP 102
42395: PUSH
42396: LD_VAR 0 1
42400: ARRAY
42401: PPUSH
42402: LD_INT 30
42404: PUSH
42405: LD_INT 3
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: PPUSH
42412: CALL_OW 72
42416: AND
42417: PUSH
42418: LD_EXP 107
42422: PUSH
42423: LD_VAR 0 1
42427: ARRAY
42428: NOT
42429: AND
42430: IFFALSE 43095
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42432: LD_ADDR_EXP 144
42436: PUSH
42437: LD_EXP 144
42441: PPUSH
42442: LD_VAR 0 1
42446: PPUSH
42447: LD_INT 6
42449: PPUSH
42450: CALL_OW 1
42454: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42455: LD_ADDR_VAR 0 2
42459: PUSH
42460: LD_INT 0
42462: PUSH
42463: LD_INT 0
42465: PUSH
42466: LD_INT 0
42468: PUSH
42469: LD_INT 0
42471: PUSH
42472: EMPTY
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: ST_TO_ADDR
// if sci >= 1 then
42478: LD_VAR 0 8
42482: PUSH
42483: LD_INT 1
42485: GREATEREQUAL
42486: IFFALSE 42508
// tmp := tmp diff sci [ 1 ] ;
42488: LD_ADDR_VAR 0 4
42492: PUSH
42493: LD_VAR 0 4
42497: PUSH
42498: LD_VAR 0 8
42502: PUSH
42503: LD_INT 1
42505: ARRAY
42506: DIFF
42507: ST_TO_ADDR
// if tmp and not sci then
42508: LD_VAR 0 4
42512: PUSH
42513: LD_VAR 0 8
42517: NOT
42518: AND
42519: IFFALSE 42588
// begin sort := SortBySkill ( tmp , 4 ) ;
42521: LD_ADDR_VAR 0 9
42525: PUSH
42526: LD_VAR 0 4
42530: PPUSH
42531: LD_INT 4
42533: PPUSH
42534: CALL 106449 0 2
42538: ST_TO_ADDR
// if sort then
42539: LD_VAR 0 9
42543: IFFALSE 42559
// p := sort [ 1 ] ;
42545: LD_ADDR_VAR 0 11
42549: PUSH
42550: LD_VAR 0 9
42554: PUSH
42555: LD_INT 1
42557: ARRAY
42558: ST_TO_ADDR
// if p then
42559: LD_VAR 0 11
42563: IFFALSE 42588
// result := Replace ( result , 4 , p ) ;
42565: LD_ADDR_VAR 0 2
42569: PUSH
42570: LD_VAR 0 2
42574: PPUSH
42575: LD_INT 4
42577: PPUSH
42578: LD_VAR 0 11
42582: PPUSH
42583: CALL_OW 1
42587: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42588: LD_ADDR_VAR 0 4
42592: PUSH
42593: LD_VAR 0 4
42597: PUSH
42598: LD_VAR 0 7
42602: DIFF
42603: ST_TO_ADDR
// if tmp and mech < 6 then
42604: LD_VAR 0 4
42608: PUSH
42609: LD_VAR 0 7
42613: PUSH
42614: LD_INT 6
42616: LESS
42617: AND
42618: IFFALSE 42800
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
42620: LD_ADDR_VAR 0 9
42624: PUSH
42625: LD_VAR 0 4
42629: PUSH
42630: LD_VAR 0 7
42634: DIFF
42635: PPUSH
42636: LD_INT 3
42638: PPUSH
42639: CALL 106449 0 2
42643: ST_TO_ADDR
// p := [ ] ;
42644: LD_ADDR_VAR 0 11
42648: PUSH
42649: EMPTY
42650: ST_TO_ADDR
// if sort then
42651: LD_VAR 0 9
42655: IFFALSE 42771
// for i = 1 to 6 - mech do
42657: LD_ADDR_VAR 0 3
42661: PUSH
42662: DOUBLE
42663: LD_INT 1
42665: DEC
42666: ST_TO_ADDR
42667: LD_INT 6
42669: PUSH
42670: LD_VAR 0 7
42674: MINUS
42675: PUSH
42676: FOR_TO
42677: IFFALSE 42769
// begin if i = sort then
42679: LD_VAR 0 3
42683: PUSH
42684: LD_VAR 0 9
42688: EQUAL
42689: IFFALSE 42693
// break ;
42691: GO 42769
// if GetClass ( i ) = 3 then
42693: LD_VAR 0 3
42697: PPUSH
42698: CALL_OW 257
42702: PUSH
42703: LD_INT 3
42705: EQUAL
42706: IFFALSE 42710
// continue ;
42708: GO 42676
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42710: LD_ADDR_VAR 0 11
42714: PUSH
42715: LD_VAR 0 11
42719: PPUSH
42720: LD_VAR 0 11
42724: PUSH
42725: LD_INT 1
42727: PLUS
42728: PPUSH
42729: LD_VAR 0 9
42733: PUSH
42734: LD_VAR 0 3
42738: ARRAY
42739: PPUSH
42740: CALL_OW 2
42744: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42745: LD_ADDR_VAR 0 4
42749: PUSH
42750: LD_VAR 0 4
42754: PUSH
42755: LD_VAR 0 9
42759: PUSH
42760: LD_VAR 0 3
42764: ARRAY
42765: DIFF
42766: ST_TO_ADDR
// end ;
42767: GO 42676
42769: POP
42770: POP
// if p then
42771: LD_VAR 0 11
42775: IFFALSE 42800
// result := Replace ( result , 3 , p ) ;
42777: LD_ADDR_VAR 0 2
42781: PUSH
42782: LD_VAR 0 2
42786: PPUSH
42787: LD_INT 3
42789: PPUSH
42790: LD_VAR 0 11
42794: PPUSH
42795: CALL_OW 1
42799: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42800: LD_ADDR_VAR 0 4
42804: PUSH
42805: LD_VAR 0 4
42809: PUSH
42810: LD_VAR 0 6
42814: DIFF
42815: ST_TO_ADDR
// if tmp and eng < 4 then
42816: LD_VAR 0 4
42820: PUSH
42821: LD_VAR 0 6
42825: PUSH
42826: LD_INT 4
42828: LESS
42829: AND
42830: IFFALSE 43020
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
42832: LD_ADDR_VAR 0 9
42836: PUSH
42837: LD_VAR 0 4
42841: PUSH
42842: LD_VAR 0 7
42846: PUSH
42847: LD_VAR 0 6
42851: UNION
42852: DIFF
42853: PPUSH
42854: LD_INT 2
42856: PPUSH
42857: CALL 106449 0 2
42861: ST_TO_ADDR
// p := [ ] ;
42862: LD_ADDR_VAR 0 11
42866: PUSH
42867: EMPTY
42868: ST_TO_ADDR
// if sort then
42869: LD_VAR 0 9
42873: IFFALSE 42989
// for i = 1 to 4 - eng do
42875: LD_ADDR_VAR 0 3
42879: PUSH
42880: DOUBLE
42881: LD_INT 1
42883: DEC
42884: ST_TO_ADDR
42885: LD_INT 4
42887: PUSH
42888: LD_VAR 0 6
42892: MINUS
42893: PUSH
42894: FOR_TO
42895: IFFALSE 42987
// begin if i = sort then
42897: LD_VAR 0 3
42901: PUSH
42902: LD_VAR 0 9
42906: EQUAL
42907: IFFALSE 42911
// break ;
42909: GO 42987
// if GetClass ( i ) = 2 then
42911: LD_VAR 0 3
42915: PPUSH
42916: CALL_OW 257
42920: PUSH
42921: LD_INT 2
42923: EQUAL
42924: IFFALSE 42928
// continue ;
42926: GO 42894
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42928: LD_ADDR_VAR 0 11
42932: PUSH
42933: LD_VAR 0 11
42937: PPUSH
42938: LD_VAR 0 11
42942: PUSH
42943: LD_INT 1
42945: PLUS
42946: PPUSH
42947: LD_VAR 0 9
42951: PUSH
42952: LD_VAR 0 3
42956: ARRAY
42957: PPUSH
42958: CALL_OW 2
42962: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42963: LD_ADDR_VAR 0 4
42967: PUSH
42968: LD_VAR 0 4
42972: PUSH
42973: LD_VAR 0 9
42977: PUSH
42978: LD_VAR 0 3
42982: ARRAY
42983: DIFF
42984: ST_TO_ADDR
// end ;
42985: GO 42894
42987: POP
42988: POP
// if p then
42989: LD_VAR 0 11
42993: IFFALSE 43018
// result := Replace ( result , 2 , p ) ;
42995: LD_ADDR_VAR 0 2
42999: PUSH
43000: LD_VAR 0 2
43004: PPUSH
43005: LD_INT 2
43007: PPUSH
43008: LD_VAR 0 11
43012: PPUSH
43013: CALL_OW 1
43017: ST_TO_ADDR
// end else
43018: GO 43064
// for i = eng downto 5 do
43020: LD_ADDR_VAR 0 3
43024: PUSH
43025: DOUBLE
43026: LD_VAR 0 6
43030: INC
43031: ST_TO_ADDR
43032: LD_INT 5
43034: PUSH
43035: FOR_DOWNTO
43036: IFFALSE 43062
// tmp := tmp union eng [ i ] ;
43038: LD_ADDR_VAR 0 4
43042: PUSH
43043: LD_VAR 0 4
43047: PUSH
43048: LD_VAR 0 6
43052: PUSH
43053: LD_VAR 0 3
43057: ARRAY
43058: UNION
43059: ST_TO_ADDR
43060: GO 43035
43062: POP
43063: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43064: LD_ADDR_VAR 0 2
43068: PUSH
43069: LD_VAR 0 2
43073: PPUSH
43074: LD_INT 1
43076: PPUSH
43077: LD_VAR 0 4
43081: PUSH
43082: LD_VAR 0 5
43086: DIFF
43087: PPUSH
43088: CALL_OW 1
43092: ST_TO_ADDR
// exit ;
43093: GO 43095
// end ; end ;
43095: LD_VAR 0 2
43099: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43100: LD_INT 0
43102: PPUSH
43103: PPUSH
43104: PPUSH
// if not mc_bases then
43105: LD_EXP 102
43109: NOT
43110: IFFALSE 43114
// exit ;
43112: GO 43220
// for i = 1 to mc_bases do
43114: LD_ADDR_VAR 0 2
43118: PUSH
43119: DOUBLE
43120: LD_INT 1
43122: DEC
43123: ST_TO_ADDR
43124: LD_EXP 102
43128: PUSH
43129: FOR_TO
43130: IFFALSE 43211
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43132: LD_ADDR_VAR 0 3
43136: PUSH
43137: LD_EXP 102
43141: PUSH
43142: LD_VAR 0 2
43146: ARRAY
43147: PPUSH
43148: LD_INT 21
43150: PUSH
43151: LD_INT 3
43153: PUSH
43154: EMPTY
43155: LIST
43156: LIST
43157: PUSH
43158: LD_INT 3
43160: PUSH
43161: LD_INT 24
43163: PUSH
43164: LD_INT 1000
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PPUSH
43179: CALL_OW 72
43183: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43184: LD_ADDR_EXP 103
43188: PUSH
43189: LD_EXP 103
43193: PPUSH
43194: LD_VAR 0 2
43198: PPUSH
43199: LD_VAR 0 3
43203: PPUSH
43204: CALL_OW 1
43208: ST_TO_ADDR
// end ;
43209: GO 43129
43211: POP
43212: POP
// RaiseSailEvent ( 101 ) ;
43213: LD_INT 101
43215: PPUSH
43216: CALL_OW 427
// end ;
43220: LD_VAR 0 1
43224: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43225: LD_INT 0
43227: PPUSH
43228: PPUSH
43229: PPUSH
43230: PPUSH
43231: PPUSH
43232: PPUSH
43233: PPUSH
// if not mc_bases then
43234: LD_EXP 102
43238: NOT
43239: IFFALSE 43243
// exit ;
43241: GO 43816
// for i = 1 to mc_bases do
43243: LD_ADDR_VAR 0 2
43247: PUSH
43248: DOUBLE
43249: LD_INT 1
43251: DEC
43252: ST_TO_ADDR
43253: LD_EXP 102
43257: PUSH
43258: FOR_TO
43259: IFFALSE 43807
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
43261: LD_ADDR_VAR 0 5
43265: PUSH
43266: LD_EXP 102
43270: PUSH
43271: LD_VAR 0 2
43275: ARRAY
43276: PUSH
43277: LD_EXP 131
43281: PUSH
43282: LD_VAR 0 2
43286: ARRAY
43287: UNION
43288: PPUSH
43289: LD_INT 21
43291: PUSH
43292: LD_INT 1
43294: PUSH
43295: EMPTY
43296: LIST
43297: LIST
43298: PUSH
43299: LD_INT 1
43301: PUSH
43302: LD_INT 3
43304: PUSH
43305: LD_INT 54
43307: PUSH
43308: EMPTY
43309: LIST
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: PUSH
43315: LD_INT 3
43317: PUSH
43318: LD_INT 24
43320: PUSH
43321: LD_INT 800
43323: PUSH
43324: EMPTY
43325: LIST
43326: LIST
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: EMPTY
43333: LIST
43334: LIST
43335: LIST
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PPUSH
43341: CALL_OW 72
43345: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43346: LD_ADDR_VAR 0 6
43350: PUSH
43351: LD_EXP 102
43355: PUSH
43356: LD_VAR 0 2
43360: ARRAY
43361: PPUSH
43362: LD_INT 21
43364: PUSH
43365: LD_INT 1
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: LD_INT 1
43374: PUSH
43375: LD_INT 3
43377: PUSH
43378: LD_INT 54
43380: PUSH
43381: EMPTY
43382: LIST
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 3
43390: PUSH
43391: LD_INT 24
43393: PUSH
43394: LD_INT 250
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: EMPTY
43402: LIST
43403: LIST
43404: PUSH
43405: EMPTY
43406: LIST
43407: LIST
43408: LIST
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PPUSH
43414: CALL_OW 72
43418: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43419: LD_ADDR_VAR 0 7
43423: PUSH
43424: LD_VAR 0 5
43428: PUSH
43429: LD_VAR 0 6
43433: DIFF
43434: ST_TO_ADDR
// if not need_heal_1 then
43435: LD_VAR 0 6
43439: NOT
43440: IFFALSE 43473
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43442: LD_ADDR_EXP 105
43446: PUSH
43447: LD_EXP 105
43451: PPUSH
43452: LD_VAR 0 2
43456: PUSH
43457: LD_INT 1
43459: PUSH
43460: EMPTY
43461: LIST
43462: LIST
43463: PPUSH
43464: EMPTY
43465: PPUSH
43466: CALL 72191 0 3
43470: ST_TO_ADDR
43471: GO 43543
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43473: LD_ADDR_EXP 105
43477: PUSH
43478: LD_EXP 105
43482: PPUSH
43483: LD_VAR 0 2
43487: PUSH
43488: LD_INT 1
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PPUSH
43495: LD_EXP 105
43499: PUSH
43500: LD_VAR 0 2
43504: ARRAY
43505: PUSH
43506: LD_INT 1
43508: ARRAY
43509: PPUSH
43510: LD_INT 3
43512: PUSH
43513: LD_INT 24
43515: PUSH
43516: LD_INT 1000
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PPUSH
43527: CALL_OW 72
43531: PUSH
43532: LD_VAR 0 6
43536: UNION
43537: PPUSH
43538: CALL 72191 0 3
43542: ST_TO_ADDR
// if not need_heal_2 then
43543: LD_VAR 0 7
43547: NOT
43548: IFFALSE 43581
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
43550: LD_ADDR_EXP 105
43554: PUSH
43555: LD_EXP 105
43559: PPUSH
43560: LD_VAR 0 2
43564: PUSH
43565: LD_INT 2
43567: PUSH
43568: EMPTY
43569: LIST
43570: LIST
43571: PPUSH
43572: EMPTY
43573: PPUSH
43574: CALL 72191 0 3
43578: ST_TO_ADDR
43579: GO 43613
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
43581: LD_ADDR_EXP 105
43585: PUSH
43586: LD_EXP 105
43590: PPUSH
43591: LD_VAR 0 2
43595: PUSH
43596: LD_INT 2
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PPUSH
43603: LD_VAR 0 7
43607: PPUSH
43608: CALL 72191 0 3
43612: ST_TO_ADDR
// if need_heal_2 then
43613: LD_VAR 0 7
43617: IFFALSE 43789
// for j in need_heal_2 do
43619: LD_ADDR_VAR 0 3
43623: PUSH
43624: LD_VAR 0 7
43628: PUSH
43629: FOR_IN
43630: IFFALSE 43787
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
43632: LD_ADDR_VAR 0 5
43636: PUSH
43637: LD_EXP 102
43641: PUSH
43642: LD_VAR 0 2
43646: ARRAY
43647: PPUSH
43648: LD_INT 2
43650: PUSH
43651: LD_INT 30
43653: PUSH
43654: LD_INT 6
43656: PUSH
43657: EMPTY
43658: LIST
43659: LIST
43660: PUSH
43661: LD_INT 30
43663: PUSH
43664: LD_INT 7
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: LD_INT 30
43673: PUSH
43674: LD_INT 8
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: LD_INT 30
43683: PUSH
43684: LD_INT 0
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 30
43693: PUSH
43694: LD_INT 1
43696: PUSH
43697: EMPTY
43698: LIST
43699: LIST
43700: PUSH
43701: LD_INT 25
43703: PUSH
43704: LD_INT 4
43706: PUSH
43707: EMPTY
43708: LIST
43709: LIST
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: LIST
43715: LIST
43716: LIST
43717: LIST
43718: LIST
43719: PPUSH
43720: CALL_OW 72
43724: ST_TO_ADDR
// if tmp then
43725: LD_VAR 0 5
43729: IFFALSE 43785
// begin k := NearestUnitToUnit ( tmp , j ) ;
43731: LD_ADDR_VAR 0 4
43735: PUSH
43736: LD_VAR 0 5
43740: PPUSH
43741: LD_VAR 0 3
43745: PPUSH
43746: CALL_OW 74
43750: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
43751: LD_VAR 0 3
43755: PPUSH
43756: LD_VAR 0 4
43760: PPUSH
43761: CALL_OW 296
43765: PUSH
43766: LD_INT 7
43768: GREATER
43769: IFFALSE 43785
// ComMoveUnit ( j , k ) ;
43771: LD_VAR 0 3
43775: PPUSH
43776: LD_VAR 0 4
43780: PPUSH
43781: CALL_OW 112
// end ; end ;
43785: GO 43629
43787: POP
43788: POP
// if not need_heal_1 and not need_heal_2 then
43789: LD_VAR 0 6
43793: NOT
43794: PUSH
43795: LD_VAR 0 7
43799: NOT
43800: AND
43801: IFFALSE 43805
// continue ;
43803: GO 43258
// end ;
43805: GO 43258
43807: POP
43808: POP
// RaiseSailEvent ( 102 ) ;
43809: LD_INT 102
43811: PPUSH
43812: CALL_OW 427
// end ;
43816: LD_VAR 0 1
43820: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
43821: LD_INT 0
43823: PPUSH
43824: PPUSH
43825: PPUSH
43826: PPUSH
43827: PPUSH
43828: PPUSH
43829: PPUSH
43830: PPUSH
// if not mc_bases then
43831: LD_EXP 102
43835: NOT
43836: IFFALSE 43840
// exit ;
43838: GO 44680
// for i = 1 to mc_bases do
43840: LD_ADDR_VAR 0 2
43844: PUSH
43845: DOUBLE
43846: LD_INT 1
43848: DEC
43849: ST_TO_ADDR
43850: LD_EXP 102
43854: PUSH
43855: FOR_TO
43856: IFFALSE 44678
// begin if not mc_building_need_repair [ i ] then
43858: LD_EXP 103
43862: PUSH
43863: LD_VAR 0 2
43867: ARRAY
43868: NOT
43869: IFFALSE 44043
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
43871: LD_ADDR_VAR 0 6
43875: PUSH
43876: LD_EXP 121
43880: PUSH
43881: LD_VAR 0 2
43885: ARRAY
43886: PPUSH
43887: LD_INT 3
43889: PUSH
43890: LD_INT 24
43892: PUSH
43893: LD_INT 1000
43895: PUSH
43896: EMPTY
43897: LIST
43898: LIST
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: LD_INT 2
43906: PUSH
43907: LD_INT 34
43909: PUSH
43910: LD_INT 13
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 34
43919: PUSH
43920: LD_INT 52
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: EMPTY
43928: LIST
43929: LIST
43930: LIST
43931: PUSH
43932: EMPTY
43933: LIST
43934: LIST
43935: PPUSH
43936: CALL_OW 72
43940: ST_TO_ADDR
// if cranes then
43941: LD_VAR 0 6
43945: IFFALSE 44007
// for j in cranes do
43947: LD_ADDR_VAR 0 3
43951: PUSH
43952: LD_VAR 0 6
43956: PUSH
43957: FOR_IN
43958: IFFALSE 44005
// if not IsInArea ( j , mc_parking [ i ] ) then
43960: LD_VAR 0 3
43964: PPUSH
43965: LD_EXP 126
43969: PUSH
43970: LD_VAR 0 2
43974: ARRAY
43975: PPUSH
43976: CALL_OW 308
43980: NOT
43981: IFFALSE 44003
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43983: LD_VAR 0 3
43987: PPUSH
43988: LD_EXP 126
43992: PUSH
43993: LD_VAR 0 2
43997: ARRAY
43998: PPUSH
43999: CALL_OW 113
44003: GO 43957
44005: POP
44006: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44007: LD_ADDR_EXP 104
44011: PUSH
44012: LD_EXP 104
44016: PPUSH
44017: LD_VAR 0 2
44021: PPUSH
44022: EMPTY
44023: PPUSH
44024: CALL_OW 1
44028: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44029: LD_VAR 0 2
44033: PPUSH
44034: LD_INT 101
44036: PPUSH
44037: CALL 38933 0 2
// continue ;
44041: GO 43855
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44043: LD_ADDR_EXP 108
44047: PUSH
44048: LD_EXP 108
44052: PPUSH
44053: LD_VAR 0 2
44057: PPUSH
44058: EMPTY
44059: PPUSH
44060: CALL_OW 1
44064: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44065: LD_VAR 0 2
44069: PPUSH
44070: LD_INT 103
44072: PPUSH
44073: CALL 38933 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44077: LD_ADDR_VAR 0 5
44081: PUSH
44082: LD_EXP 102
44086: PUSH
44087: LD_VAR 0 2
44091: ARRAY
44092: PUSH
44093: LD_EXP 131
44097: PUSH
44098: LD_VAR 0 2
44102: ARRAY
44103: UNION
44104: PPUSH
44105: LD_INT 2
44107: PUSH
44108: LD_INT 25
44110: PUSH
44111: LD_INT 2
44113: PUSH
44114: EMPTY
44115: LIST
44116: LIST
44117: PUSH
44118: LD_INT 25
44120: PUSH
44121: LD_INT 16
44123: PUSH
44124: EMPTY
44125: LIST
44126: LIST
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: LIST
44132: PUSH
44133: EMPTY
44134: LIST
44135: PPUSH
44136: CALL_OW 72
44140: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
44141: LD_ADDR_VAR 0 6
44145: PUSH
44146: LD_EXP 121
44150: PUSH
44151: LD_VAR 0 2
44155: ARRAY
44156: PPUSH
44157: LD_INT 2
44159: PUSH
44160: LD_INT 34
44162: PUSH
44163: LD_INT 13
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 34
44172: PUSH
44173: LD_INT 52
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: EMPTY
44181: LIST
44182: LIST
44183: LIST
44184: PPUSH
44185: CALL_OW 72
44189: ST_TO_ADDR
// if cranes then
44190: LD_VAR 0 6
44194: IFFALSE 44330
// begin for j in cranes do
44196: LD_ADDR_VAR 0 3
44200: PUSH
44201: LD_VAR 0 6
44205: PUSH
44206: FOR_IN
44207: IFFALSE 44328
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
44209: LD_VAR 0 3
44213: PPUSH
44214: CALL_OW 256
44218: PUSH
44219: LD_INT 500
44221: GREATEREQUAL
44222: PUSH
44223: LD_VAR 0 3
44227: PPUSH
44228: CALL_OW 314
44232: NOT
44233: AND
44234: IFFALSE 44268
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44236: LD_VAR 0 3
44240: PPUSH
44241: LD_EXP 103
44245: PUSH
44246: LD_VAR 0 2
44250: ARRAY
44251: PPUSH
44252: LD_VAR 0 3
44256: PPUSH
44257: CALL_OW 74
44261: PPUSH
44262: CALL_OW 130
44266: GO 44326
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44268: LD_VAR 0 3
44272: PPUSH
44273: CALL_OW 256
44277: PUSH
44278: LD_INT 500
44280: LESS
44281: PUSH
44282: LD_VAR 0 3
44286: PPUSH
44287: LD_EXP 126
44291: PUSH
44292: LD_VAR 0 2
44296: ARRAY
44297: PPUSH
44298: CALL_OW 308
44302: NOT
44303: AND
44304: IFFALSE 44326
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44306: LD_VAR 0 3
44310: PPUSH
44311: LD_EXP 126
44315: PUSH
44316: LD_VAR 0 2
44320: ARRAY
44321: PPUSH
44322: CALL_OW 113
44326: GO 44206
44328: POP
44329: POP
// end ; if not tmp then
44330: LD_VAR 0 5
44334: NOT
44335: IFFALSE 44339
// continue ;
44337: GO 43855
// for j in tmp do
44339: LD_ADDR_VAR 0 3
44343: PUSH
44344: LD_VAR 0 5
44348: PUSH
44349: FOR_IN
44350: IFFALSE 44674
// begin if mc_need_heal [ i ] then
44352: LD_EXP 105
44356: PUSH
44357: LD_VAR 0 2
44361: ARRAY
44362: IFFALSE 44410
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
44364: LD_VAR 0 3
44368: PUSH
44369: LD_EXP 105
44373: PUSH
44374: LD_VAR 0 2
44378: ARRAY
44379: PUSH
44380: LD_INT 1
44382: ARRAY
44383: IN
44384: PUSH
44385: LD_VAR 0 3
44389: PUSH
44390: LD_EXP 105
44394: PUSH
44395: LD_VAR 0 2
44399: ARRAY
44400: PUSH
44401: LD_INT 2
44403: ARRAY
44404: IN
44405: OR
44406: IFFALSE 44410
// continue ;
44408: GO 44349
// if IsInUnit ( j ) then
44410: LD_VAR 0 3
44414: PPUSH
44415: CALL_OW 310
44419: IFFALSE 44430
// ComExitBuilding ( j ) ;
44421: LD_VAR 0 3
44425: PPUSH
44426: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44430: LD_VAR 0 3
44434: PUSH
44435: LD_EXP 104
44439: PUSH
44440: LD_VAR 0 2
44444: ARRAY
44445: IN
44446: NOT
44447: IFFALSE 44505
// begin SetTag ( j , 101 ) ;
44449: LD_VAR 0 3
44453: PPUSH
44454: LD_INT 101
44456: PPUSH
44457: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
44461: LD_ADDR_EXP 104
44465: PUSH
44466: LD_EXP 104
44470: PPUSH
44471: LD_VAR 0 2
44475: PUSH
44476: LD_EXP 104
44480: PUSH
44481: LD_VAR 0 2
44485: ARRAY
44486: PUSH
44487: LD_INT 1
44489: PLUS
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PPUSH
44495: LD_VAR 0 3
44499: PPUSH
44500: CALL 72191 0 3
44504: ST_TO_ADDR
// end ; wait ( 1 ) ;
44505: LD_INT 1
44507: PPUSH
44508: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
44512: LD_ADDR_VAR 0 7
44516: PUSH
44517: LD_EXP 103
44521: PUSH
44522: LD_VAR 0 2
44526: ARRAY
44527: ST_TO_ADDR
// if mc_scan [ i ] then
44528: LD_EXP 125
44532: PUSH
44533: LD_VAR 0 2
44537: ARRAY
44538: IFFALSE 44607
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ] ) ;
44540: LD_ADDR_VAR 0 7
44544: PUSH
44545: LD_EXP 103
44549: PUSH
44550: LD_VAR 0 2
44554: ARRAY
44555: PPUSH
44556: LD_INT 3
44558: PUSH
44559: LD_INT 2
44561: PUSH
44562: LD_INT 30
44564: PUSH
44565: LD_INT 32
44567: PUSH
44568: EMPTY
44569: LIST
44570: LIST
44571: PUSH
44572: LD_INT 30
44574: PUSH
44575: LD_INT 33
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: LD_INT 30
44584: PUSH
44585: LD_INT 31
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: EMPTY
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PPUSH
44602: CALL_OW 72
44606: ST_TO_ADDR
// if not to_repair_tmp then
44607: LD_VAR 0 7
44611: NOT
44612: IFFALSE 44616
// continue ;
44614: GO 44349
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
44616: LD_ADDR_VAR 0 8
44620: PUSH
44621: LD_VAR 0 7
44625: PPUSH
44626: LD_VAR 0 3
44630: PPUSH
44631: CALL_OW 74
44635: ST_TO_ADDR
// if DangerAtRange ( to_repair , 14 ) [ 4 ] < 5 then
44636: LD_VAR 0 8
44640: PPUSH
44641: LD_INT 14
44643: PPUSH
44644: CALL 74784 0 2
44648: PUSH
44649: LD_INT 4
44651: ARRAY
44652: PUSH
44653: LD_INT 5
44655: LESS
44656: IFFALSE 44672
// ComRepairBuilding ( j , to_repair ) ;
44658: LD_VAR 0 3
44662: PPUSH
44663: LD_VAR 0 8
44667: PPUSH
44668: CALL_OW 130
// end ;
44672: GO 44349
44674: POP
44675: POP
// end ;
44676: GO 43855
44678: POP
44679: POP
// end ;
44680: LD_VAR 0 1
44684: RET
// export function MC_Heal ; var i , j , tmp ; begin
44685: LD_INT 0
44687: PPUSH
44688: PPUSH
44689: PPUSH
44690: PPUSH
// if not mc_bases then
44691: LD_EXP 102
44695: NOT
44696: IFFALSE 44700
// exit ;
44698: GO 45102
// for i = 1 to mc_bases do
44700: LD_ADDR_VAR 0 2
44704: PUSH
44705: DOUBLE
44706: LD_INT 1
44708: DEC
44709: ST_TO_ADDR
44710: LD_EXP 102
44714: PUSH
44715: FOR_TO
44716: IFFALSE 45100
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
44718: LD_EXP 105
44722: PUSH
44723: LD_VAR 0 2
44727: ARRAY
44728: PUSH
44729: LD_INT 1
44731: ARRAY
44732: NOT
44733: PUSH
44734: LD_EXP 105
44738: PUSH
44739: LD_VAR 0 2
44743: ARRAY
44744: PUSH
44745: LD_INT 2
44747: ARRAY
44748: NOT
44749: AND
44750: IFFALSE 44788
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
44752: LD_ADDR_EXP 106
44756: PUSH
44757: LD_EXP 106
44761: PPUSH
44762: LD_VAR 0 2
44766: PPUSH
44767: EMPTY
44768: PPUSH
44769: CALL_OW 1
44773: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
44774: LD_VAR 0 2
44778: PPUSH
44779: LD_INT 102
44781: PPUSH
44782: CALL 38933 0 2
// continue ;
44786: GO 44715
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
44788: LD_ADDR_VAR 0 4
44792: PUSH
44793: LD_EXP 102
44797: PUSH
44798: LD_VAR 0 2
44802: ARRAY
44803: PPUSH
44804: LD_INT 25
44806: PUSH
44807: LD_INT 4
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PPUSH
44814: CALL_OW 72
44818: ST_TO_ADDR
// if not tmp then
44819: LD_VAR 0 4
44823: NOT
44824: IFFALSE 44828
// continue ;
44826: GO 44715
// if mc_taming [ i ] then
44828: LD_EXP 133
44832: PUSH
44833: LD_VAR 0 2
44837: ARRAY
44838: IFFALSE 44862
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
44840: LD_ADDR_EXP 133
44844: PUSH
44845: LD_EXP 133
44849: PPUSH
44850: LD_VAR 0 2
44854: PPUSH
44855: EMPTY
44856: PPUSH
44857: CALL_OW 1
44861: ST_TO_ADDR
// for j in tmp do
44862: LD_ADDR_VAR 0 3
44866: PUSH
44867: LD_VAR 0 4
44871: PUSH
44872: FOR_IN
44873: IFFALSE 45096
// begin if IsInUnit ( j ) then
44875: LD_VAR 0 3
44879: PPUSH
44880: CALL_OW 310
44884: IFFALSE 44895
// ComExitBuilding ( j ) ;
44886: LD_VAR 0 3
44890: PPUSH
44891: CALL_OW 122
// if not j in mc_healers [ i ] then
44895: LD_VAR 0 3
44899: PUSH
44900: LD_EXP 106
44904: PUSH
44905: LD_VAR 0 2
44909: ARRAY
44910: IN
44911: NOT
44912: IFFALSE 44958
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
44914: LD_ADDR_EXP 106
44918: PUSH
44919: LD_EXP 106
44923: PPUSH
44924: LD_VAR 0 2
44928: PUSH
44929: LD_EXP 106
44933: PUSH
44934: LD_VAR 0 2
44938: ARRAY
44939: PUSH
44940: LD_INT 1
44942: PLUS
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: PPUSH
44948: LD_VAR 0 3
44952: PPUSH
44953: CALL 72191 0 3
44957: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
44958: LD_VAR 0 3
44962: PPUSH
44963: CALL_OW 110
44967: PUSH
44968: LD_INT 102
44970: NONEQUAL
44971: IFFALSE 44985
// SetTag ( j , 102 ) ;
44973: LD_VAR 0 3
44977: PPUSH
44978: LD_INT 102
44980: PPUSH
44981: CALL_OW 109
// Wait ( 3 ) ;
44985: LD_INT 3
44987: PPUSH
44988: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
44992: LD_EXP 105
44996: PUSH
44997: LD_VAR 0 2
45001: ARRAY
45002: PUSH
45003: LD_INT 1
45005: ARRAY
45006: IFFALSE 45038
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45008: LD_VAR 0 3
45012: PPUSH
45013: LD_EXP 105
45017: PUSH
45018: LD_VAR 0 2
45022: ARRAY
45023: PUSH
45024: LD_INT 1
45026: ARRAY
45027: PUSH
45028: LD_INT 1
45030: ARRAY
45031: PPUSH
45032: CALL_OW 128
45036: GO 45094
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45038: LD_VAR 0 3
45042: PPUSH
45043: CALL_OW 314
45047: NOT
45048: PUSH
45049: LD_EXP 105
45053: PUSH
45054: LD_VAR 0 2
45058: ARRAY
45059: PUSH
45060: LD_INT 2
45062: ARRAY
45063: AND
45064: IFFALSE 45094
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45066: LD_VAR 0 3
45070: PPUSH
45071: LD_EXP 105
45075: PUSH
45076: LD_VAR 0 2
45080: ARRAY
45081: PUSH
45082: LD_INT 2
45084: ARRAY
45085: PUSH
45086: LD_INT 1
45088: ARRAY
45089: PPUSH
45090: CALL_OW 128
// end ;
45094: GO 44872
45096: POP
45097: POP
// end ;
45098: GO 44715
45100: POP
45101: POP
// end ;
45102: LD_VAR 0 1
45106: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45107: LD_INT 0
45109: PPUSH
45110: PPUSH
45111: PPUSH
45112: PPUSH
45113: PPUSH
// if not mc_bases then
45114: LD_EXP 102
45118: NOT
45119: IFFALSE 45123
// exit ;
45121: GO 46266
// for i = 1 to mc_bases do
45123: LD_ADDR_VAR 0 2
45127: PUSH
45128: DOUBLE
45129: LD_INT 1
45131: DEC
45132: ST_TO_ADDR
45133: LD_EXP 102
45137: PUSH
45138: FOR_TO
45139: IFFALSE 46264
// begin if mc_scan [ i ] then
45141: LD_EXP 125
45145: PUSH
45146: LD_VAR 0 2
45150: ARRAY
45151: IFFALSE 45155
// continue ;
45153: GO 45138
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45155: LD_EXP 107
45159: PUSH
45160: LD_VAR 0 2
45164: ARRAY
45165: NOT
45166: PUSH
45167: LD_EXP 109
45171: PUSH
45172: LD_VAR 0 2
45176: ARRAY
45177: NOT
45178: AND
45179: PUSH
45180: LD_EXP 108
45184: PUSH
45185: LD_VAR 0 2
45189: ARRAY
45190: AND
45191: IFFALSE 45229
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45193: LD_ADDR_EXP 108
45197: PUSH
45198: LD_EXP 108
45202: PPUSH
45203: LD_VAR 0 2
45207: PPUSH
45208: EMPTY
45209: PPUSH
45210: CALL_OW 1
45214: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45215: LD_VAR 0 2
45219: PPUSH
45220: LD_INT 103
45222: PPUSH
45223: CALL 38933 0 2
// continue ;
45227: GO 45138
// end ; if mc_construct_list [ i ] then
45229: LD_EXP 109
45233: PUSH
45234: LD_VAR 0 2
45238: ARRAY
45239: IFFALSE 45459
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45241: LD_ADDR_VAR 0 4
45245: PUSH
45246: LD_EXP 102
45250: PUSH
45251: LD_VAR 0 2
45255: ARRAY
45256: PPUSH
45257: LD_INT 25
45259: PUSH
45260: LD_INT 2
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PPUSH
45267: CALL_OW 72
45271: PUSH
45272: LD_EXP 104
45276: PUSH
45277: LD_VAR 0 2
45281: ARRAY
45282: DIFF
45283: ST_TO_ADDR
// if not tmp then
45284: LD_VAR 0 4
45288: NOT
45289: IFFALSE 45293
// continue ;
45291: GO 45138
// for j in tmp do
45293: LD_ADDR_VAR 0 3
45297: PUSH
45298: LD_VAR 0 4
45302: PUSH
45303: FOR_IN
45304: IFFALSE 45455
// begin if not mc_builders [ i ] then
45306: LD_EXP 108
45310: PUSH
45311: LD_VAR 0 2
45315: ARRAY
45316: NOT
45317: IFFALSE 45375
// begin SetTag ( j , 103 ) ;
45319: LD_VAR 0 3
45323: PPUSH
45324: LD_INT 103
45326: PPUSH
45327: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45331: LD_ADDR_EXP 108
45335: PUSH
45336: LD_EXP 108
45340: PPUSH
45341: LD_VAR 0 2
45345: PUSH
45346: LD_EXP 108
45350: PUSH
45351: LD_VAR 0 2
45355: ARRAY
45356: PUSH
45357: LD_INT 1
45359: PLUS
45360: PUSH
45361: EMPTY
45362: LIST
45363: LIST
45364: PPUSH
45365: LD_VAR 0 3
45369: PPUSH
45370: CALL 72191 0 3
45374: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45375: LD_VAR 0 3
45379: PPUSH
45380: CALL_OW 310
45384: IFFALSE 45395
// ComExitBuilding ( j ) ;
45386: LD_VAR 0 3
45390: PPUSH
45391: CALL_OW 122
// wait ( 3 ) ;
45395: LD_INT 3
45397: PPUSH
45398: CALL_OW 67
// if not mc_construct_list [ i ] then
45402: LD_EXP 109
45406: PUSH
45407: LD_VAR 0 2
45411: ARRAY
45412: NOT
45413: IFFALSE 45417
// break ;
45415: GO 45455
// if not HasTask ( j ) then
45417: LD_VAR 0 3
45421: PPUSH
45422: CALL_OW 314
45426: NOT
45427: IFFALSE 45453
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45429: LD_VAR 0 3
45433: PPUSH
45434: LD_EXP 109
45438: PUSH
45439: LD_VAR 0 2
45443: ARRAY
45444: PUSH
45445: LD_INT 1
45447: ARRAY
45448: PPUSH
45449: CALL 75042 0 2
// end ;
45453: GO 45303
45455: POP
45456: POP
// end else
45457: GO 46262
// if mc_build_list [ i ] then
45459: LD_EXP 107
45463: PUSH
45464: LD_VAR 0 2
45468: ARRAY
45469: IFFALSE 46262
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45471: LD_ADDR_VAR 0 5
45475: PUSH
45476: LD_EXP 102
45480: PUSH
45481: LD_VAR 0 2
45485: ARRAY
45486: PPUSH
45487: LD_INT 2
45489: PUSH
45490: LD_INT 30
45492: PUSH
45493: LD_INT 0
45495: PUSH
45496: EMPTY
45497: LIST
45498: LIST
45499: PUSH
45500: LD_INT 30
45502: PUSH
45503: LD_INT 1
45505: PUSH
45506: EMPTY
45507: LIST
45508: LIST
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: LIST
45514: PPUSH
45515: CALL_OW 72
45519: ST_TO_ADDR
// if depot then
45520: LD_VAR 0 5
45524: IFFALSE 45542
// depot := depot [ 1 ] else
45526: LD_ADDR_VAR 0 5
45530: PUSH
45531: LD_VAR 0 5
45535: PUSH
45536: LD_INT 1
45538: ARRAY
45539: ST_TO_ADDR
45540: GO 45550
// depot := 0 ;
45542: LD_ADDR_VAR 0 5
45546: PUSH
45547: LD_INT 0
45549: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
45550: LD_EXP 107
45554: PUSH
45555: LD_VAR 0 2
45559: ARRAY
45560: PUSH
45561: LD_INT 1
45563: ARRAY
45564: PUSH
45565: LD_INT 1
45567: ARRAY
45568: PPUSH
45569: CALL 74872 0 1
45573: PUSH
45574: LD_EXP 102
45578: PUSH
45579: LD_VAR 0 2
45583: ARRAY
45584: PPUSH
45585: LD_INT 2
45587: PUSH
45588: LD_INT 30
45590: PUSH
45591: LD_INT 2
45593: PUSH
45594: EMPTY
45595: LIST
45596: LIST
45597: PUSH
45598: LD_INT 30
45600: PUSH
45601: LD_INT 3
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PUSH
45608: EMPTY
45609: LIST
45610: LIST
45611: LIST
45612: PPUSH
45613: CALL_OW 72
45617: NOT
45618: AND
45619: IFFALSE 45724
// begin for j = 1 to mc_build_list [ i ] do
45621: LD_ADDR_VAR 0 3
45625: PUSH
45626: DOUBLE
45627: LD_INT 1
45629: DEC
45630: ST_TO_ADDR
45631: LD_EXP 107
45635: PUSH
45636: LD_VAR 0 2
45640: ARRAY
45641: PUSH
45642: FOR_TO
45643: IFFALSE 45722
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
45645: LD_EXP 107
45649: PUSH
45650: LD_VAR 0 2
45654: ARRAY
45655: PUSH
45656: LD_VAR 0 3
45660: ARRAY
45661: PUSH
45662: LD_INT 1
45664: ARRAY
45665: PUSH
45666: LD_INT 2
45668: EQUAL
45669: IFFALSE 45720
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
45671: LD_ADDR_EXP 107
45675: PUSH
45676: LD_EXP 107
45680: PPUSH
45681: LD_VAR 0 2
45685: PPUSH
45686: LD_EXP 107
45690: PUSH
45691: LD_VAR 0 2
45695: ARRAY
45696: PPUSH
45697: LD_VAR 0 3
45701: PPUSH
45702: LD_INT 1
45704: PPUSH
45705: LD_INT 0
45707: PPUSH
45708: CALL 71609 0 4
45712: PPUSH
45713: CALL_OW 1
45717: ST_TO_ADDR
// break ;
45718: GO 45722
// end ;
45720: GO 45642
45722: POP
45723: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
45724: LD_EXP 107
45728: PUSH
45729: LD_VAR 0 2
45733: ARRAY
45734: PUSH
45735: LD_INT 1
45737: ARRAY
45738: PUSH
45739: LD_INT 1
45741: ARRAY
45742: PUSH
45743: LD_INT 0
45745: EQUAL
45746: PUSH
45747: LD_VAR 0 5
45751: PUSH
45752: LD_VAR 0 5
45756: PPUSH
45757: LD_EXP 107
45761: PUSH
45762: LD_VAR 0 2
45766: ARRAY
45767: PUSH
45768: LD_INT 1
45770: ARRAY
45771: PUSH
45772: LD_INT 1
45774: ARRAY
45775: PPUSH
45776: LD_EXP 107
45780: PUSH
45781: LD_VAR 0 2
45785: ARRAY
45786: PUSH
45787: LD_INT 1
45789: ARRAY
45790: PUSH
45791: LD_INT 2
45793: ARRAY
45794: PPUSH
45795: LD_EXP 107
45799: PUSH
45800: LD_VAR 0 2
45804: ARRAY
45805: PUSH
45806: LD_INT 1
45808: ARRAY
45809: PUSH
45810: LD_INT 3
45812: ARRAY
45813: PPUSH
45814: LD_EXP 107
45818: PUSH
45819: LD_VAR 0 2
45823: ARRAY
45824: PUSH
45825: LD_INT 1
45827: ARRAY
45828: PUSH
45829: LD_INT 4
45831: ARRAY
45832: PPUSH
45833: CALL 79606 0 5
45837: AND
45838: OR
45839: IFFALSE 46120
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45841: LD_ADDR_VAR 0 4
45845: PUSH
45846: LD_EXP 102
45850: PUSH
45851: LD_VAR 0 2
45855: ARRAY
45856: PPUSH
45857: LD_INT 25
45859: PUSH
45860: LD_INT 2
45862: PUSH
45863: EMPTY
45864: LIST
45865: LIST
45866: PPUSH
45867: CALL_OW 72
45871: PUSH
45872: LD_EXP 104
45876: PUSH
45877: LD_VAR 0 2
45881: ARRAY
45882: DIFF
45883: ST_TO_ADDR
// if not tmp then
45884: LD_VAR 0 4
45888: NOT
45889: IFFALSE 45893
// continue ;
45891: GO 45138
// for j in tmp do
45893: LD_ADDR_VAR 0 3
45897: PUSH
45898: LD_VAR 0 4
45902: PUSH
45903: FOR_IN
45904: IFFALSE 46116
// begin if not mc_builders [ i ] then
45906: LD_EXP 108
45910: PUSH
45911: LD_VAR 0 2
45915: ARRAY
45916: NOT
45917: IFFALSE 45975
// begin SetTag ( j , 103 ) ;
45919: LD_VAR 0 3
45923: PPUSH
45924: LD_INT 103
45926: PPUSH
45927: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45931: LD_ADDR_EXP 108
45935: PUSH
45936: LD_EXP 108
45940: PPUSH
45941: LD_VAR 0 2
45945: PUSH
45946: LD_EXP 108
45950: PUSH
45951: LD_VAR 0 2
45955: ARRAY
45956: PUSH
45957: LD_INT 1
45959: PLUS
45960: PUSH
45961: EMPTY
45962: LIST
45963: LIST
45964: PPUSH
45965: LD_VAR 0 3
45969: PPUSH
45970: CALL 72191 0 3
45974: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45975: LD_VAR 0 3
45979: PPUSH
45980: CALL_OW 310
45984: IFFALSE 45995
// ComExitBuilding ( j ) ;
45986: LD_VAR 0 3
45990: PPUSH
45991: CALL_OW 122
// wait ( 3 ) ;
45995: LD_INT 3
45997: PPUSH
45998: CALL_OW 67
// if not mc_build_list [ i ] then
46002: LD_EXP 107
46006: PUSH
46007: LD_VAR 0 2
46011: ARRAY
46012: NOT
46013: IFFALSE 46017
// break ;
46015: GO 46116
// if not HasTask ( j ) then
46017: LD_VAR 0 3
46021: PPUSH
46022: CALL_OW 314
46026: NOT
46027: IFFALSE 46114
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46029: LD_VAR 0 3
46033: PPUSH
46034: LD_EXP 107
46038: PUSH
46039: LD_VAR 0 2
46043: ARRAY
46044: PUSH
46045: LD_INT 1
46047: ARRAY
46048: PUSH
46049: LD_INT 1
46051: ARRAY
46052: PPUSH
46053: LD_EXP 107
46057: PUSH
46058: LD_VAR 0 2
46062: ARRAY
46063: PUSH
46064: LD_INT 1
46066: ARRAY
46067: PUSH
46068: LD_INT 2
46070: ARRAY
46071: PPUSH
46072: LD_EXP 107
46076: PUSH
46077: LD_VAR 0 2
46081: ARRAY
46082: PUSH
46083: LD_INT 1
46085: ARRAY
46086: PUSH
46087: LD_INT 3
46089: ARRAY
46090: PPUSH
46091: LD_EXP 107
46095: PUSH
46096: LD_VAR 0 2
46100: ARRAY
46101: PUSH
46102: LD_INT 1
46104: ARRAY
46105: PUSH
46106: LD_INT 4
46108: ARRAY
46109: PPUSH
46110: CALL_OW 145
// end ;
46114: GO 45903
46116: POP
46117: POP
// end else
46118: GO 46262
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
46120: LD_EXP 102
46124: PUSH
46125: LD_VAR 0 2
46129: ARRAY
46130: PPUSH
46131: LD_EXP 107
46135: PUSH
46136: LD_VAR 0 2
46140: ARRAY
46141: PUSH
46142: LD_INT 1
46144: ARRAY
46145: PUSH
46146: LD_INT 1
46148: ARRAY
46149: PPUSH
46150: LD_EXP 107
46154: PUSH
46155: LD_VAR 0 2
46159: ARRAY
46160: PUSH
46161: LD_INT 1
46163: ARRAY
46164: PUSH
46165: LD_INT 2
46167: ARRAY
46168: PPUSH
46169: LD_EXP 107
46173: PUSH
46174: LD_VAR 0 2
46178: ARRAY
46179: PUSH
46180: LD_INT 1
46182: ARRAY
46183: PUSH
46184: LD_INT 3
46186: ARRAY
46187: PPUSH
46188: LD_EXP 107
46192: PUSH
46193: LD_VAR 0 2
46197: ARRAY
46198: PUSH
46199: LD_INT 1
46201: ARRAY
46202: PUSH
46203: LD_INT 4
46205: ARRAY
46206: PPUSH
46207: CALL 78942 0 5
46211: NOT
46212: IFFALSE 46262
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46214: LD_ADDR_EXP 107
46218: PUSH
46219: LD_EXP 107
46223: PPUSH
46224: LD_VAR 0 2
46228: PPUSH
46229: LD_EXP 107
46233: PUSH
46234: LD_VAR 0 2
46238: ARRAY
46239: PPUSH
46240: LD_INT 1
46242: PPUSH
46243: LD_INT 1
46245: NEG
46246: PPUSH
46247: LD_INT 0
46249: PPUSH
46250: CALL 71609 0 4
46254: PPUSH
46255: CALL_OW 1
46259: ST_TO_ADDR
// continue ;
46260: GO 45138
// end ; end ; end ;
46262: GO 45138
46264: POP
46265: POP
// end ;
46266: LD_VAR 0 1
46270: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46271: LD_INT 0
46273: PPUSH
46274: PPUSH
46275: PPUSH
46276: PPUSH
46277: PPUSH
46278: PPUSH
// if not mc_bases then
46279: LD_EXP 102
46283: NOT
46284: IFFALSE 46288
// exit ;
46286: GO 46715
// for i = 1 to mc_bases do
46288: LD_ADDR_VAR 0 2
46292: PUSH
46293: DOUBLE
46294: LD_INT 1
46296: DEC
46297: ST_TO_ADDR
46298: LD_EXP 102
46302: PUSH
46303: FOR_TO
46304: IFFALSE 46713
// begin tmp := mc_build_upgrade [ i ] ;
46306: LD_ADDR_VAR 0 4
46310: PUSH
46311: LD_EXP 134
46315: PUSH
46316: LD_VAR 0 2
46320: ARRAY
46321: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46322: LD_ADDR_VAR 0 6
46326: PUSH
46327: LD_EXP 135
46331: PUSH
46332: LD_VAR 0 2
46336: ARRAY
46337: PPUSH
46338: LD_INT 2
46340: PUSH
46341: LD_INT 30
46343: PUSH
46344: LD_INT 6
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 30
46353: PUSH
46354: LD_INT 7
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: EMPTY
46362: LIST
46363: LIST
46364: LIST
46365: PPUSH
46366: CALL_OW 72
46370: ST_TO_ADDR
// if not tmp and not lab then
46371: LD_VAR 0 4
46375: NOT
46376: PUSH
46377: LD_VAR 0 6
46381: NOT
46382: AND
46383: IFFALSE 46387
// continue ;
46385: GO 46303
// if tmp then
46387: LD_VAR 0 4
46391: IFFALSE 46511
// for j in tmp do
46393: LD_ADDR_VAR 0 3
46397: PUSH
46398: LD_VAR 0 4
46402: PUSH
46403: FOR_IN
46404: IFFALSE 46509
// begin if UpgradeCost ( j ) then
46406: LD_VAR 0 3
46410: PPUSH
46411: CALL 78602 0 1
46415: IFFALSE 46507
// begin ComUpgrade ( j ) ;
46417: LD_VAR 0 3
46421: PPUSH
46422: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
46426: LD_ADDR_EXP 134
46430: PUSH
46431: LD_EXP 134
46435: PPUSH
46436: LD_VAR 0 2
46440: PPUSH
46441: LD_EXP 134
46445: PUSH
46446: LD_VAR 0 2
46450: ARRAY
46451: PUSH
46452: LD_VAR 0 3
46456: DIFF
46457: PPUSH
46458: CALL_OW 1
46462: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46463: LD_ADDR_EXP 109
46467: PUSH
46468: LD_EXP 109
46472: PPUSH
46473: LD_VAR 0 2
46477: PUSH
46478: LD_EXP 109
46482: PUSH
46483: LD_VAR 0 2
46487: ARRAY
46488: PUSH
46489: LD_INT 1
46491: PLUS
46492: PUSH
46493: EMPTY
46494: LIST
46495: LIST
46496: PPUSH
46497: LD_VAR 0 3
46501: PPUSH
46502: CALL 72191 0 3
46506: ST_TO_ADDR
// end ; end ;
46507: GO 46403
46509: POP
46510: POP
// if not lab or not mc_lab_upgrade [ i ] then
46511: LD_VAR 0 6
46515: NOT
46516: PUSH
46517: LD_EXP 136
46521: PUSH
46522: LD_VAR 0 2
46526: ARRAY
46527: NOT
46528: OR
46529: IFFALSE 46533
// continue ;
46531: GO 46303
// for j in lab do
46533: LD_ADDR_VAR 0 3
46537: PUSH
46538: LD_VAR 0 6
46542: PUSH
46543: FOR_IN
46544: IFFALSE 46709
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
46546: LD_VAR 0 3
46550: PPUSH
46551: CALL_OW 266
46555: PUSH
46556: LD_INT 6
46558: PUSH
46559: LD_INT 7
46561: PUSH
46562: EMPTY
46563: LIST
46564: LIST
46565: IN
46566: PUSH
46567: LD_VAR 0 3
46571: PPUSH
46572: CALL_OW 461
46576: PUSH
46577: LD_INT 1
46579: NONEQUAL
46580: AND
46581: IFFALSE 46707
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
46583: LD_VAR 0 3
46587: PPUSH
46588: LD_EXP 136
46592: PUSH
46593: LD_VAR 0 2
46597: ARRAY
46598: PUSH
46599: LD_INT 1
46601: ARRAY
46602: PPUSH
46603: CALL 78807 0 2
46607: IFFALSE 46707
// begin ComCancel ( j ) ;
46609: LD_VAR 0 3
46613: PPUSH
46614: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
46618: LD_VAR 0 3
46622: PPUSH
46623: LD_EXP 136
46627: PUSH
46628: LD_VAR 0 2
46632: ARRAY
46633: PUSH
46634: LD_INT 1
46636: ARRAY
46637: PPUSH
46638: CALL_OW 207
// if not j in mc_construct_list [ i ] then
46642: LD_VAR 0 3
46646: PUSH
46647: LD_EXP 109
46651: PUSH
46652: LD_VAR 0 2
46656: ARRAY
46657: IN
46658: NOT
46659: IFFALSE 46705
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
46661: LD_ADDR_EXP 109
46665: PUSH
46666: LD_EXP 109
46670: PPUSH
46671: LD_VAR 0 2
46675: PUSH
46676: LD_EXP 109
46680: PUSH
46681: LD_VAR 0 2
46685: ARRAY
46686: PUSH
46687: LD_INT 1
46689: PLUS
46690: PUSH
46691: EMPTY
46692: LIST
46693: LIST
46694: PPUSH
46695: LD_VAR 0 3
46699: PPUSH
46700: CALL 72191 0 3
46704: ST_TO_ADDR
// break ;
46705: GO 46709
// end ; end ; end ;
46707: GO 46543
46709: POP
46710: POP
// end ;
46711: GO 46303
46713: POP
46714: POP
// end ;
46715: LD_VAR 0 1
46719: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
46720: LD_INT 0
46722: PPUSH
46723: PPUSH
46724: PPUSH
46725: PPUSH
46726: PPUSH
46727: PPUSH
46728: PPUSH
46729: PPUSH
46730: PPUSH
// if not mc_bases then
46731: LD_EXP 102
46735: NOT
46736: IFFALSE 46740
// exit ;
46738: GO 47145
// for i = 1 to mc_bases do
46740: LD_ADDR_VAR 0 2
46744: PUSH
46745: DOUBLE
46746: LD_INT 1
46748: DEC
46749: ST_TO_ADDR
46750: LD_EXP 102
46754: PUSH
46755: FOR_TO
46756: IFFALSE 47143
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
46758: LD_EXP 110
46762: PUSH
46763: LD_VAR 0 2
46767: ARRAY
46768: NOT
46769: PUSH
46770: LD_EXP 102
46774: PUSH
46775: LD_VAR 0 2
46779: ARRAY
46780: PPUSH
46781: LD_INT 30
46783: PUSH
46784: LD_INT 3
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PPUSH
46791: CALL_OW 72
46795: NOT
46796: OR
46797: IFFALSE 46801
// continue ;
46799: GO 46755
// busy := false ;
46801: LD_ADDR_VAR 0 8
46805: PUSH
46806: LD_INT 0
46808: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
46809: LD_ADDR_VAR 0 4
46813: PUSH
46814: LD_EXP 102
46818: PUSH
46819: LD_VAR 0 2
46823: ARRAY
46824: PPUSH
46825: LD_INT 30
46827: PUSH
46828: LD_INT 3
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PPUSH
46835: CALL_OW 72
46839: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
46840: LD_ADDR_VAR 0 6
46844: PUSH
46845: LD_EXP 110
46849: PUSH
46850: LD_VAR 0 2
46854: ARRAY
46855: PPUSH
46856: LD_INT 2
46858: PUSH
46859: LD_INT 30
46861: PUSH
46862: LD_INT 32
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 30
46871: PUSH
46872: LD_INT 33
46874: PUSH
46875: EMPTY
46876: LIST
46877: LIST
46878: PUSH
46879: EMPTY
46880: LIST
46881: LIST
46882: LIST
46883: PPUSH
46884: CALL_OW 72
46888: ST_TO_ADDR
// if not t then
46889: LD_VAR 0 6
46893: NOT
46894: IFFALSE 46898
// continue ;
46896: GO 46755
// for j in tmp do
46898: LD_ADDR_VAR 0 3
46902: PUSH
46903: LD_VAR 0 4
46907: PUSH
46908: FOR_IN
46909: IFFALSE 46939
// if not BuildingStatus ( j ) = bs_idle then
46911: LD_VAR 0 3
46915: PPUSH
46916: CALL_OW 461
46920: PUSH
46921: LD_INT 2
46923: EQUAL
46924: NOT
46925: IFFALSE 46937
// begin busy := true ;
46927: LD_ADDR_VAR 0 8
46931: PUSH
46932: LD_INT 1
46934: ST_TO_ADDR
// break ;
46935: GO 46939
// end ;
46937: GO 46908
46939: POP
46940: POP
// if busy then
46941: LD_VAR 0 8
46945: IFFALSE 46949
// continue ;
46947: GO 46755
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
46949: LD_ADDR_VAR 0 7
46953: PUSH
46954: LD_VAR 0 6
46958: PPUSH
46959: LD_INT 35
46961: PUSH
46962: LD_INT 0
46964: PUSH
46965: EMPTY
46966: LIST
46967: LIST
46968: PPUSH
46969: CALL_OW 72
46973: ST_TO_ADDR
// if tw then
46974: LD_VAR 0 7
46978: IFFALSE 47055
// begin tw := tw [ 1 ] ;
46980: LD_ADDR_VAR 0 7
46984: PUSH
46985: LD_VAR 0 7
46989: PUSH
46990: LD_INT 1
46992: ARRAY
46993: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
46994: LD_ADDR_VAR 0 9
46998: PUSH
46999: LD_VAR 0 7
47003: PPUSH
47004: LD_EXP 127
47008: PUSH
47009: LD_VAR 0 2
47013: ARRAY
47014: PPUSH
47015: CALL 77161 0 2
47019: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47020: LD_EXP 141
47024: PUSH
47025: LD_VAR 0 2
47029: ARRAY
47030: IFFALSE 47053
// if not weapon in mc_allowed_tower_weapons [ i ] then
47032: LD_VAR 0 9
47036: PUSH
47037: LD_EXP 141
47041: PUSH
47042: LD_VAR 0 2
47046: ARRAY
47047: IN
47048: NOT
47049: IFFALSE 47053
// continue ;
47051: GO 46755
// end else
47053: GO 47118
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47055: LD_ADDR_VAR 0 5
47059: PUSH
47060: LD_EXP 110
47064: PUSH
47065: LD_VAR 0 2
47069: ARRAY
47070: PPUSH
47071: LD_VAR 0 4
47075: PPUSH
47076: CALL 107372 0 2
47080: ST_TO_ADDR
// if not tmp2 then
47081: LD_VAR 0 5
47085: NOT
47086: IFFALSE 47090
// continue ;
47088: GO 46755
// tw := tmp2 [ 1 ] ;
47090: LD_ADDR_VAR 0 7
47094: PUSH
47095: LD_VAR 0 5
47099: PUSH
47100: LD_INT 1
47102: ARRAY
47103: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47104: LD_ADDR_VAR 0 9
47108: PUSH
47109: LD_VAR 0 5
47113: PUSH
47114: LD_INT 2
47116: ARRAY
47117: ST_TO_ADDR
// end ; if not weapon then
47118: LD_VAR 0 9
47122: NOT
47123: IFFALSE 47127
// continue ;
47125: GO 46755
// ComPlaceWeapon ( tw , weapon ) ;
47127: LD_VAR 0 7
47131: PPUSH
47132: LD_VAR 0 9
47136: PPUSH
47137: CALL_OW 148
// end ;
47141: GO 46755
47143: POP
47144: POP
// end ;
47145: LD_VAR 0 1
47149: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
47150: LD_INT 0
47152: PPUSH
47153: PPUSH
47154: PPUSH
47155: PPUSH
47156: PPUSH
47157: PPUSH
// if not mc_bases then
47158: LD_EXP 102
47162: NOT
47163: IFFALSE 47167
// exit ;
47165: GO 47943
// for i = 1 to mc_bases do
47167: LD_ADDR_VAR 0 2
47171: PUSH
47172: DOUBLE
47173: LD_INT 1
47175: DEC
47176: ST_TO_ADDR
47177: LD_EXP 102
47181: PUSH
47182: FOR_TO
47183: IFFALSE 47941
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47185: LD_EXP 115
47189: PUSH
47190: LD_VAR 0 2
47194: ARRAY
47195: NOT
47196: PUSH
47197: LD_EXP 115
47201: PUSH
47202: LD_VAR 0 2
47206: ARRAY
47207: PUSH
47208: LD_EXP 116
47212: PUSH
47213: LD_VAR 0 2
47217: ARRAY
47218: EQUAL
47219: OR
47220: PUSH
47221: LD_EXP 125
47225: PUSH
47226: LD_VAR 0 2
47230: ARRAY
47231: OR
47232: IFFALSE 47236
// continue ;
47234: GO 47182
// if mc_miners [ i ] then
47236: LD_EXP 116
47240: PUSH
47241: LD_VAR 0 2
47245: ARRAY
47246: IFFALSE 47628
// begin for j = mc_miners [ i ] downto 1 do
47248: LD_ADDR_VAR 0 3
47252: PUSH
47253: DOUBLE
47254: LD_EXP 116
47258: PUSH
47259: LD_VAR 0 2
47263: ARRAY
47264: INC
47265: ST_TO_ADDR
47266: LD_INT 1
47268: PUSH
47269: FOR_DOWNTO
47270: IFFALSE 47626
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47272: LD_EXP 116
47276: PUSH
47277: LD_VAR 0 2
47281: ARRAY
47282: PUSH
47283: LD_VAR 0 3
47287: ARRAY
47288: PPUSH
47289: CALL_OW 301
47293: PUSH
47294: LD_EXP 116
47298: PUSH
47299: LD_VAR 0 2
47303: ARRAY
47304: PUSH
47305: LD_VAR 0 3
47309: ARRAY
47310: PPUSH
47311: CALL_OW 257
47315: PUSH
47316: LD_INT 1
47318: NONEQUAL
47319: OR
47320: IFFALSE 47383
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47322: LD_ADDR_VAR 0 5
47326: PUSH
47327: LD_EXP 116
47331: PUSH
47332: LD_VAR 0 2
47336: ARRAY
47337: PUSH
47338: LD_EXP 116
47342: PUSH
47343: LD_VAR 0 2
47347: ARRAY
47348: PUSH
47349: LD_VAR 0 3
47353: ARRAY
47354: DIFF
47355: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47356: LD_ADDR_EXP 116
47360: PUSH
47361: LD_EXP 116
47365: PPUSH
47366: LD_VAR 0 2
47370: PPUSH
47371: LD_VAR 0 5
47375: PPUSH
47376: CALL_OW 1
47380: ST_TO_ADDR
// continue ;
47381: GO 47269
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47383: LD_EXP 116
47387: PUSH
47388: LD_VAR 0 2
47392: ARRAY
47393: PUSH
47394: LD_VAR 0 3
47398: ARRAY
47399: PPUSH
47400: CALL_OW 257
47404: PUSH
47405: LD_INT 1
47407: EQUAL
47408: PUSH
47409: LD_EXP 116
47413: PUSH
47414: LD_VAR 0 2
47418: ARRAY
47419: PUSH
47420: LD_VAR 0 3
47424: ARRAY
47425: PPUSH
47426: CALL_OW 459
47430: NOT
47431: AND
47432: PUSH
47433: LD_EXP 116
47437: PUSH
47438: LD_VAR 0 2
47442: ARRAY
47443: PUSH
47444: LD_VAR 0 3
47448: ARRAY
47449: PPUSH
47450: CALL_OW 314
47454: NOT
47455: AND
47456: IFFALSE 47624
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
47458: LD_EXP 116
47462: PUSH
47463: LD_VAR 0 2
47467: ARRAY
47468: PUSH
47469: LD_VAR 0 3
47473: ARRAY
47474: PPUSH
47475: CALL_OW 310
47479: IFFALSE 47502
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
47481: LD_EXP 116
47485: PUSH
47486: LD_VAR 0 2
47490: ARRAY
47491: PUSH
47492: LD_VAR 0 3
47496: ARRAY
47497: PPUSH
47498: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
47502: LD_EXP 116
47506: PUSH
47507: LD_VAR 0 2
47511: ARRAY
47512: PUSH
47513: LD_VAR 0 3
47517: ARRAY
47518: PPUSH
47519: CALL_OW 314
47523: NOT
47524: IFFALSE 47624
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
47526: LD_EXP 116
47530: PUSH
47531: LD_VAR 0 2
47535: ARRAY
47536: PUSH
47537: LD_VAR 0 3
47541: ARRAY
47542: PPUSH
47543: LD_EXP 115
47547: PUSH
47548: LD_VAR 0 2
47552: ARRAY
47553: PUSH
47554: LD_VAR 0 3
47558: PUSH
47559: LD_EXP 115
47563: PUSH
47564: LD_VAR 0 2
47568: ARRAY
47569: MOD
47570: PUSH
47571: LD_INT 1
47573: PLUS
47574: ARRAY
47575: PUSH
47576: LD_INT 1
47578: ARRAY
47579: PPUSH
47580: LD_EXP 115
47584: PUSH
47585: LD_VAR 0 2
47589: ARRAY
47590: PUSH
47591: LD_VAR 0 3
47595: PUSH
47596: LD_EXP 115
47600: PUSH
47601: LD_VAR 0 2
47605: ARRAY
47606: MOD
47607: PUSH
47608: LD_INT 1
47610: PLUS
47611: ARRAY
47612: PUSH
47613: LD_INT 2
47615: ARRAY
47616: PPUSH
47617: LD_INT 0
47619: PPUSH
47620: CALL_OW 193
// end ; end ;
47624: GO 47269
47626: POP
47627: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
47628: LD_ADDR_VAR 0 5
47632: PUSH
47633: LD_EXP 102
47637: PUSH
47638: LD_VAR 0 2
47642: ARRAY
47643: PPUSH
47644: LD_INT 2
47646: PUSH
47647: LD_INT 30
47649: PUSH
47650: LD_INT 4
47652: PUSH
47653: EMPTY
47654: LIST
47655: LIST
47656: PUSH
47657: LD_INT 30
47659: PUSH
47660: LD_INT 5
47662: PUSH
47663: EMPTY
47664: LIST
47665: LIST
47666: PUSH
47667: LD_INT 30
47669: PUSH
47670: LD_INT 32
47672: PUSH
47673: EMPTY
47674: LIST
47675: LIST
47676: PUSH
47677: EMPTY
47678: LIST
47679: LIST
47680: LIST
47681: LIST
47682: PPUSH
47683: CALL_OW 72
47687: ST_TO_ADDR
// if not tmp then
47688: LD_VAR 0 5
47692: NOT
47693: IFFALSE 47697
// continue ;
47695: GO 47182
// list := [ ] ;
47697: LD_ADDR_VAR 0 6
47701: PUSH
47702: EMPTY
47703: ST_TO_ADDR
// for j in tmp do
47704: LD_ADDR_VAR 0 3
47708: PUSH
47709: LD_VAR 0 5
47713: PUSH
47714: FOR_IN
47715: IFFALSE 47784
// begin for k in UnitsInside ( j ) do
47717: LD_ADDR_VAR 0 4
47721: PUSH
47722: LD_VAR 0 3
47726: PPUSH
47727: CALL_OW 313
47731: PUSH
47732: FOR_IN
47733: IFFALSE 47780
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
47735: LD_VAR 0 4
47739: PPUSH
47740: CALL_OW 257
47744: PUSH
47745: LD_INT 1
47747: EQUAL
47748: PUSH
47749: LD_VAR 0 4
47753: PPUSH
47754: CALL_OW 459
47758: NOT
47759: AND
47760: IFFALSE 47778
// list := list ^ k ;
47762: LD_ADDR_VAR 0 6
47766: PUSH
47767: LD_VAR 0 6
47771: PUSH
47772: LD_VAR 0 4
47776: ADD
47777: ST_TO_ADDR
47778: GO 47732
47780: POP
47781: POP
// end ;
47782: GO 47714
47784: POP
47785: POP
// list := list diff mc_miners [ i ] ;
47786: LD_ADDR_VAR 0 6
47790: PUSH
47791: LD_VAR 0 6
47795: PUSH
47796: LD_EXP 116
47800: PUSH
47801: LD_VAR 0 2
47805: ARRAY
47806: DIFF
47807: ST_TO_ADDR
// if not list then
47808: LD_VAR 0 6
47812: NOT
47813: IFFALSE 47817
// continue ;
47815: GO 47182
// k := mc_mines [ i ] - mc_miners [ i ] ;
47817: LD_ADDR_VAR 0 4
47821: PUSH
47822: LD_EXP 115
47826: PUSH
47827: LD_VAR 0 2
47831: ARRAY
47832: PUSH
47833: LD_EXP 116
47837: PUSH
47838: LD_VAR 0 2
47842: ARRAY
47843: MINUS
47844: ST_TO_ADDR
// if k > list then
47845: LD_VAR 0 4
47849: PUSH
47850: LD_VAR 0 6
47854: GREATER
47855: IFFALSE 47867
// k := list ;
47857: LD_ADDR_VAR 0 4
47861: PUSH
47862: LD_VAR 0 6
47866: ST_TO_ADDR
// for j = 1 to k do
47867: LD_ADDR_VAR 0 3
47871: PUSH
47872: DOUBLE
47873: LD_INT 1
47875: DEC
47876: ST_TO_ADDR
47877: LD_VAR 0 4
47881: PUSH
47882: FOR_TO
47883: IFFALSE 47937
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47885: LD_ADDR_EXP 116
47889: PUSH
47890: LD_EXP 116
47894: PPUSH
47895: LD_VAR 0 2
47899: PUSH
47900: LD_EXP 116
47904: PUSH
47905: LD_VAR 0 2
47909: ARRAY
47910: PUSH
47911: LD_INT 1
47913: PLUS
47914: PUSH
47915: EMPTY
47916: LIST
47917: LIST
47918: PPUSH
47919: LD_VAR 0 6
47923: PUSH
47924: LD_VAR 0 3
47928: ARRAY
47929: PPUSH
47930: CALL 72191 0 3
47934: ST_TO_ADDR
47935: GO 47882
47937: POP
47938: POP
// end ;
47939: GO 47182
47941: POP
47942: POP
// end ;
47943: LD_VAR 0 1
47947: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47948: LD_INT 0
47950: PPUSH
47951: PPUSH
47952: PPUSH
47953: PPUSH
47954: PPUSH
47955: PPUSH
47956: PPUSH
47957: PPUSH
47958: PPUSH
47959: PPUSH
// if not mc_bases then
47960: LD_EXP 102
47964: NOT
47965: IFFALSE 47969
// exit ;
47967: GO 49719
// for i = 1 to mc_bases do
47969: LD_ADDR_VAR 0 2
47973: PUSH
47974: DOUBLE
47975: LD_INT 1
47977: DEC
47978: ST_TO_ADDR
47979: LD_EXP 102
47983: PUSH
47984: FOR_TO
47985: IFFALSE 49717
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47987: LD_EXP 102
47991: PUSH
47992: LD_VAR 0 2
47996: ARRAY
47997: NOT
47998: PUSH
47999: LD_EXP 109
48003: PUSH
48004: LD_VAR 0 2
48008: ARRAY
48009: OR
48010: IFFALSE 48014
// continue ;
48012: GO 47984
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48014: LD_EXP 118
48018: PUSH
48019: LD_VAR 0 2
48023: ARRAY
48024: NOT
48025: PUSH
48026: LD_EXP 119
48030: PUSH
48031: LD_VAR 0 2
48035: ARRAY
48036: AND
48037: IFFALSE 48075
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48039: LD_ADDR_EXP 119
48043: PUSH
48044: LD_EXP 119
48048: PPUSH
48049: LD_VAR 0 2
48053: PPUSH
48054: EMPTY
48055: PPUSH
48056: CALL_OW 1
48060: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48061: LD_VAR 0 2
48065: PPUSH
48066: LD_INT 107
48068: PPUSH
48069: CALL 38933 0 2
// continue ;
48073: GO 47984
// end ; target := [ ] ;
48075: LD_ADDR_VAR 0 6
48079: PUSH
48080: EMPTY
48081: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48082: LD_ADDR_VAR 0 3
48086: PUSH
48087: DOUBLE
48088: LD_EXP 118
48092: PUSH
48093: LD_VAR 0 2
48097: ARRAY
48098: INC
48099: ST_TO_ADDR
48100: LD_INT 1
48102: PUSH
48103: FOR_DOWNTO
48104: IFFALSE 48364
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48106: LD_EXP 118
48110: PUSH
48111: LD_VAR 0 2
48115: ARRAY
48116: PUSH
48117: LD_VAR 0 3
48121: ARRAY
48122: PUSH
48123: LD_INT 2
48125: ARRAY
48126: PPUSH
48127: LD_EXP 118
48131: PUSH
48132: LD_VAR 0 2
48136: ARRAY
48137: PUSH
48138: LD_VAR 0 3
48142: ARRAY
48143: PUSH
48144: LD_INT 3
48146: ARRAY
48147: PPUSH
48148: CALL_OW 488
48152: PUSH
48153: LD_EXP 118
48157: PUSH
48158: LD_VAR 0 2
48162: ARRAY
48163: PUSH
48164: LD_VAR 0 3
48168: ARRAY
48169: PUSH
48170: LD_INT 2
48172: ARRAY
48173: PPUSH
48174: LD_EXP 118
48178: PUSH
48179: LD_VAR 0 2
48183: ARRAY
48184: PUSH
48185: LD_VAR 0 3
48189: ARRAY
48190: PUSH
48191: LD_INT 3
48193: ARRAY
48194: PPUSH
48195: CALL_OW 284
48199: PUSH
48200: LD_INT 0
48202: EQUAL
48203: AND
48204: IFFALSE 48259
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48206: LD_ADDR_VAR 0 5
48210: PUSH
48211: LD_EXP 118
48215: PUSH
48216: LD_VAR 0 2
48220: ARRAY
48221: PPUSH
48222: LD_VAR 0 3
48226: PPUSH
48227: CALL_OW 3
48231: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48232: LD_ADDR_EXP 118
48236: PUSH
48237: LD_EXP 118
48241: PPUSH
48242: LD_VAR 0 2
48246: PPUSH
48247: LD_VAR 0 5
48251: PPUSH
48252: CALL_OW 1
48256: ST_TO_ADDR
// continue ;
48257: GO 48103
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48259: LD_EXP 102
48263: PUSH
48264: LD_VAR 0 2
48268: ARRAY
48269: PUSH
48270: LD_INT 1
48272: ARRAY
48273: PPUSH
48274: CALL_OW 255
48278: PPUSH
48279: LD_EXP 118
48283: PUSH
48284: LD_VAR 0 2
48288: ARRAY
48289: PUSH
48290: LD_VAR 0 3
48294: ARRAY
48295: PUSH
48296: LD_INT 2
48298: ARRAY
48299: PPUSH
48300: LD_EXP 118
48304: PUSH
48305: LD_VAR 0 2
48309: ARRAY
48310: PUSH
48311: LD_VAR 0 3
48315: ARRAY
48316: PUSH
48317: LD_INT 3
48319: ARRAY
48320: PPUSH
48321: LD_INT 30
48323: PPUSH
48324: CALL 73087 0 4
48328: PUSH
48329: LD_INT 4
48331: ARRAY
48332: PUSH
48333: LD_INT 0
48335: EQUAL
48336: IFFALSE 48362
// begin target := mc_crates [ i ] [ j ] ;
48338: LD_ADDR_VAR 0 6
48342: PUSH
48343: LD_EXP 118
48347: PUSH
48348: LD_VAR 0 2
48352: ARRAY
48353: PUSH
48354: LD_VAR 0 3
48358: ARRAY
48359: ST_TO_ADDR
// break ;
48360: GO 48364
// end ; end ;
48362: GO 48103
48364: POP
48365: POP
// if not target then
48366: LD_VAR 0 6
48370: NOT
48371: IFFALSE 48375
// continue ;
48373: GO 47984
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
48375: LD_ADDR_VAR 0 7
48379: PUSH
48380: LD_EXP 121
48384: PUSH
48385: LD_VAR 0 2
48389: ARRAY
48390: PPUSH
48391: LD_INT 2
48393: PUSH
48394: LD_INT 3
48396: PUSH
48397: LD_INT 58
48399: PUSH
48400: EMPTY
48401: LIST
48402: PUSH
48403: EMPTY
48404: LIST
48405: LIST
48406: PUSH
48407: LD_INT 61
48409: PUSH
48410: EMPTY
48411: LIST
48412: PUSH
48413: LD_INT 33
48415: PUSH
48416: LD_INT 5
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: LD_INT 33
48425: PUSH
48426: LD_INT 3
48428: PUSH
48429: EMPTY
48430: LIST
48431: LIST
48432: PUSH
48433: EMPTY
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: LIST
48439: PUSH
48440: LD_INT 2
48442: PUSH
48443: LD_INT 34
48445: PUSH
48446: LD_INT 32
48448: PUSH
48449: EMPTY
48450: LIST
48451: LIST
48452: PUSH
48453: LD_INT 34
48455: PUSH
48456: LD_INT 51
48458: PUSH
48459: EMPTY
48460: LIST
48461: LIST
48462: PUSH
48463: LD_INT 34
48465: PUSH
48466: LD_INT 12
48468: PUSH
48469: EMPTY
48470: LIST
48471: LIST
48472: PUSH
48473: EMPTY
48474: LIST
48475: LIST
48476: LIST
48477: LIST
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: PPUSH
48483: CALL_OW 72
48487: ST_TO_ADDR
// if not cargo then
48488: LD_VAR 0 7
48492: NOT
48493: IFFALSE 49136
// begin if mc_crates_collector [ i ] < 5 then
48495: LD_EXP 119
48499: PUSH
48500: LD_VAR 0 2
48504: ARRAY
48505: PUSH
48506: LD_INT 5
48508: LESS
48509: IFFALSE 48875
// begin if mc_ape [ i ] then
48511: LD_EXP 131
48515: PUSH
48516: LD_VAR 0 2
48520: ARRAY
48521: IFFALSE 48568
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
48523: LD_ADDR_VAR 0 5
48527: PUSH
48528: LD_EXP 131
48532: PUSH
48533: LD_VAR 0 2
48537: ARRAY
48538: PPUSH
48539: LD_INT 25
48541: PUSH
48542: LD_INT 16
48544: PUSH
48545: EMPTY
48546: LIST
48547: LIST
48548: PUSH
48549: LD_INT 24
48551: PUSH
48552: LD_INT 750
48554: PUSH
48555: EMPTY
48556: LIST
48557: LIST
48558: PUSH
48559: EMPTY
48560: LIST
48561: LIST
48562: PPUSH
48563: CALL_OW 72
48567: ST_TO_ADDR
// if not tmp then
48568: LD_VAR 0 5
48572: NOT
48573: IFFALSE 48620
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
48575: LD_ADDR_VAR 0 5
48579: PUSH
48580: LD_EXP 102
48584: PUSH
48585: LD_VAR 0 2
48589: ARRAY
48590: PPUSH
48591: LD_INT 25
48593: PUSH
48594: LD_INT 2
48596: PUSH
48597: EMPTY
48598: LIST
48599: LIST
48600: PUSH
48601: LD_INT 24
48603: PUSH
48604: LD_INT 750
48606: PUSH
48607: EMPTY
48608: LIST
48609: LIST
48610: PUSH
48611: EMPTY
48612: LIST
48613: LIST
48614: PPUSH
48615: CALL_OW 72
48619: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
48620: LD_EXP 131
48624: PUSH
48625: LD_VAR 0 2
48629: ARRAY
48630: PUSH
48631: LD_EXP 102
48635: PUSH
48636: LD_VAR 0 2
48640: ARRAY
48641: PPUSH
48642: LD_INT 25
48644: PUSH
48645: LD_INT 2
48647: PUSH
48648: EMPTY
48649: LIST
48650: LIST
48651: PUSH
48652: LD_INT 24
48654: PUSH
48655: LD_INT 750
48657: PUSH
48658: EMPTY
48659: LIST
48660: LIST
48661: PUSH
48662: EMPTY
48663: LIST
48664: LIST
48665: PPUSH
48666: CALL_OW 72
48670: AND
48671: PUSH
48672: LD_VAR 0 5
48676: PUSH
48677: LD_INT 5
48679: LESS
48680: AND
48681: IFFALSE 48763
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
48683: LD_ADDR_VAR 0 3
48687: PUSH
48688: LD_EXP 102
48692: PUSH
48693: LD_VAR 0 2
48697: ARRAY
48698: PPUSH
48699: LD_INT 25
48701: PUSH
48702: LD_INT 2
48704: PUSH
48705: EMPTY
48706: LIST
48707: LIST
48708: PUSH
48709: LD_INT 24
48711: PUSH
48712: LD_INT 750
48714: PUSH
48715: EMPTY
48716: LIST
48717: LIST
48718: PUSH
48719: EMPTY
48720: LIST
48721: LIST
48722: PPUSH
48723: CALL_OW 72
48727: PUSH
48728: FOR_IN
48729: IFFALSE 48761
// begin tmp := tmp union j ;
48731: LD_ADDR_VAR 0 5
48735: PUSH
48736: LD_VAR 0 5
48740: PUSH
48741: LD_VAR 0 3
48745: UNION
48746: ST_TO_ADDR
// if tmp >= 5 then
48747: LD_VAR 0 5
48751: PUSH
48752: LD_INT 5
48754: GREATEREQUAL
48755: IFFALSE 48759
// break ;
48757: GO 48761
// end ;
48759: GO 48728
48761: POP
48762: POP
// end ; if not tmp then
48763: LD_VAR 0 5
48767: NOT
48768: IFFALSE 48772
// continue ;
48770: GO 47984
// for j in tmp do
48772: LD_ADDR_VAR 0 3
48776: PUSH
48777: LD_VAR 0 5
48781: PUSH
48782: FOR_IN
48783: IFFALSE 48873
// if not GetTag ( j ) then
48785: LD_VAR 0 3
48789: PPUSH
48790: CALL_OW 110
48794: NOT
48795: IFFALSE 48871
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
48797: LD_ADDR_EXP 119
48801: PUSH
48802: LD_EXP 119
48806: PPUSH
48807: LD_VAR 0 2
48811: PUSH
48812: LD_EXP 119
48816: PUSH
48817: LD_VAR 0 2
48821: ARRAY
48822: PUSH
48823: LD_INT 1
48825: PLUS
48826: PUSH
48827: EMPTY
48828: LIST
48829: LIST
48830: PPUSH
48831: LD_VAR 0 3
48835: PPUSH
48836: CALL 72191 0 3
48840: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48841: LD_VAR 0 3
48845: PPUSH
48846: LD_INT 107
48848: PPUSH
48849: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48853: LD_EXP 119
48857: PUSH
48858: LD_VAR 0 2
48862: ARRAY
48863: PUSH
48864: LD_INT 5
48866: GREATEREQUAL
48867: IFFALSE 48871
// break ;
48869: GO 48873
// end ;
48871: GO 48782
48873: POP
48874: POP
// end ; if mc_crates_collector [ i ] and target then
48875: LD_EXP 119
48879: PUSH
48880: LD_VAR 0 2
48884: ARRAY
48885: PUSH
48886: LD_VAR 0 6
48890: AND
48891: IFFALSE 49134
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48893: LD_EXP 119
48897: PUSH
48898: LD_VAR 0 2
48902: ARRAY
48903: PUSH
48904: LD_VAR 0 6
48908: PUSH
48909: LD_INT 1
48911: ARRAY
48912: LESS
48913: IFFALSE 48933
// tmp := mc_crates_collector [ i ] else
48915: LD_ADDR_VAR 0 5
48919: PUSH
48920: LD_EXP 119
48924: PUSH
48925: LD_VAR 0 2
48929: ARRAY
48930: ST_TO_ADDR
48931: GO 48947
// tmp := target [ 1 ] ;
48933: LD_ADDR_VAR 0 5
48937: PUSH
48938: LD_VAR 0 6
48942: PUSH
48943: LD_INT 1
48945: ARRAY
48946: ST_TO_ADDR
// k := 0 ;
48947: LD_ADDR_VAR 0 4
48951: PUSH
48952: LD_INT 0
48954: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48955: LD_ADDR_VAR 0 3
48959: PUSH
48960: LD_EXP 119
48964: PUSH
48965: LD_VAR 0 2
48969: ARRAY
48970: PUSH
48971: FOR_IN
48972: IFFALSE 49132
// begin k := k + 1 ;
48974: LD_ADDR_VAR 0 4
48978: PUSH
48979: LD_VAR 0 4
48983: PUSH
48984: LD_INT 1
48986: PLUS
48987: ST_TO_ADDR
// if k > tmp then
48988: LD_VAR 0 4
48992: PUSH
48993: LD_VAR 0 5
48997: GREATER
48998: IFFALSE 49002
// break ;
49000: GO 49132
// if not GetClass ( j ) in [ 2 , 16 ] then
49002: LD_VAR 0 3
49006: PPUSH
49007: CALL_OW 257
49011: PUSH
49012: LD_INT 2
49014: PUSH
49015: LD_INT 16
49017: PUSH
49018: EMPTY
49019: LIST
49020: LIST
49021: IN
49022: NOT
49023: IFFALSE 49076
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49025: LD_ADDR_EXP 119
49029: PUSH
49030: LD_EXP 119
49034: PPUSH
49035: LD_VAR 0 2
49039: PPUSH
49040: LD_EXP 119
49044: PUSH
49045: LD_VAR 0 2
49049: ARRAY
49050: PUSH
49051: LD_VAR 0 3
49055: DIFF
49056: PPUSH
49057: CALL_OW 1
49061: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49062: LD_VAR 0 3
49066: PPUSH
49067: LD_INT 0
49069: PPUSH
49070: CALL_OW 109
// continue ;
49074: GO 48971
// end ; if IsInUnit ( j ) then
49076: LD_VAR 0 3
49080: PPUSH
49081: CALL_OW 310
49085: IFFALSE 49096
// ComExitBuilding ( j ) ;
49087: LD_VAR 0 3
49091: PPUSH
49092: CALL_OW 122
// wait ( 3 ) ;
49096: LD_INT 3
49098: PPUSH
49099: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49103: LD_VAR 0 3
49107: PPUSH
49108: LD_VAR 0 6
49112: PUSH
49113: LD_INT 2
49115: ARRAY
49116: PPUSH
49117: LD_VAR 0 6
49121: PUSH
49122: LD_INT 3
49124: ARRAY
49125: PPUSH
49126: CALL_OW 117
// end ;
49130: GO 48971
49132: POP
49133: POP
// end ; end else
49134: GO 49715
// begin for j in cargo do
49136: LD_ADDR_VAR 0 3
49140: PUSH
49141: LD_VAR 0 7
49145: PUSH
49146: FOR_IN
49147: IFFALSE 49713
// begin if GetTag ( j ) <> 0 then
49149: LD_VAR 0 3
49153: PPUSH
49154: CALL_OW 110
49158: PUSH
49159: LD_INT 0
49161: NONEQUAL
49162: IFFALSE 49166
// continue ;
49164: GO 49146
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49166: LD_VAR 0 3
49170: PPUSH
49171: CALL_OW 256
49175: PUSH
49176: LD_INT 1000
49178: LESS
49179: PUSH
49180: LD_VAR 0 3
49184: PPUSH
49185: LD_EXP 126
49189: PUSH
49190: LD_VAR 0 2
49194: ARRAY
49195: PPUSH
49196: CALL_OW 308
49200: NOT
49201: AND
49202: IFFALSE 49224
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49204: LD_VAR 0 3
49208: PPUSH
49209: LD_EXP 126
49213: PUSH
49214: LD_VAR 0 2
49218: ARRAY
49219: PPUSH
49220: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49224: LD_VAR 0 3
49228: PPUSH
49229: CALL_OW 256
49233: PUSH
49234: LD_INT 1000
49236: LESS
49237: PUSH
49238: LD_VAR 0 3
49242: PPUSH
49243: LD_EXP 126
49247: PUSH
49248: LD_VAR 0 2
49252: ARRAY
49253: PPUSH
49254: CALL_OW 308
49258: AND
49259: IFFALSE 49263
// continue ;
49261: GO 49146
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49263: LD_VAR 0 3
49267: PPUSH
49268: CALL_OW 262
49272: PUSH
49273: LD_INT 2
49275: EQUAL
49276: PUSH
49277: LD_VAR 0 3
49281: PPUSH
49282: CALL_OW 261
49286: PUSH
49287: LD_INT 15
49289: LESS
49290: AND
49291: IFFALSE 49295
// continue ;
49293: GO 49146
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49295: LD_VAR 0 3
49299: PPUSH
49300: CALL_OW 262
49304: PUSH
49305: LD_INT 1
49307: EQUAL
49308: PUSH
49309: LD_VAR 0 3
49313: PPUSH
49314: CALL_OW 261
49318: PUSH
49319: LD_INT 10
49321: LESS
49322: AND
49323: IFFALSE 49652
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
49325: LD_ADDR_VAR 0 8
49329: PUSH
49330: LD_EXP 102
49334: PUSH
49335: LD_VAR 0 2
49339: ARRAY
49340: PPUSH
49341: LD_INT 2
49343: PUSH
49344: LD_INT 30
49346: PUSH
49347: LD_INT 0
49349: PUSH
49350: EMPTY
49351: LIST
49352: LIST
49353: PUSH
49354: LD_INT 30
49356: PUSH
49357: LD_INT 1
49359: PUSH
49360: EMPTY
49361: LIST
49362: LIST
49363: PUSH
49364: EMPTY
49365: LIST
49366: LIST
49367: LIST
49368: PPUSH
49369: CALL_OW 72
49373: ST_TO_ADDR
// if not depot then
49374: LD_VAR 0 8
49378: NOT
49379: IFFALSE 49383
// continue ;
49381: GO 49146
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
49383: LD_VAR 0 3
49387: PPUSH
49388: LD_VAR 0 8
49392: PPUSH
49393: LD_VAR 0 3
49397: PPUSH
49398: CALL_OW 74
49402: PPUSH
49403: CALL_OW 296
49407: PUSH
49408: LD_INT 6
49410: LESS
49411: IFFALSE 49427
// SetFuel ( j , 100 ) else
49413: LD_VAR 0 3
49417: PPUSH
49418: LD_INT 100
49420: PPUSH
49421: CALL_OW 240
49425: GO 49652
// if GetFuel ( j ) = 0 then
49427: LD_VAR 0 3
49431: PPUSH
49432: CALL_OW 261
49436: PUSH
49437: LD_INT 0
49439: EQUAL
49440: IFFALSE 49652
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
49442: LD_ADDR_EXP 121
49446: PUSH
49447: LD_EXP 121
49451: PPUSH
49452: LD_VAR 0 2
49456: PPUSH
49457: LD_EXP 121
49461: PUSH
49462: LD_VAR 0 2
49466: ARRAY
49467: PUSH
49468: LD_VAR 0 3
49472: DIFF
49473: PPUSH
49474: CALL_OW 1
49478: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
49479: LD_VAR 0 3
49483: PPUSH
49484: CALL_OW 263
49488: PUSH
49489: LD_INT 1
49491: EQUAL
49492: IFFALSE 49508
// ComExitVehicle ( IsInUnit ( j ) ) ;
49494: LD_VAR 0 3
49498: PPUSH
49499: CALL_OW 310
49503: PPUSH
49504: CALL_OW 121
// if GetControl ( j ) = control_remote then
49508: LD_VAR 0 3
49512: PPUSH
49513: CALL_OW 263
49517: PUSH
49518: LD_INT 2
49520: EQUAL
49521: IFFALSE 49532
// ComUnlink ( j ) ;
49523: LD_VAR 0 3
49527: PPUSH
49528: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
49532: LD_ADDR_VAR 0 9
49536: PUSH
49537: LD_VAR 0 2
49541: PPUSH
49542: LD_INT 3
49544: PPUSH
49545: CALL 59005 0 2
49549: ST_TO_ADDR
// if fac then
49550: LD_VAR 0 9
49554: IFFALSE 49650
// begin for k in fac do
49556: LD_ADDR_VAR 0 4
49560: PUSH
49561: LD_VAR 0 9
49565: PUSH
49566: FOR_IN
49567: IFFALSE 49648
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
49569: LD_ADDR_VAR 0 10
49573: PUSH
49574: LD_VAR 0 9
49578: PPUSH
49579: LD_VAR 0 3
49583: PPUSH
49584: CALL_OW 265
49588: PPUSH
49589: LD_VAR 0 3
49593: PPUSH
49594: CALL_OW 262
49598: PPUSH
49599: LD_VAR 0 3
49603: PPUSH
49604: CALL_OW 263
49608: PPUSH
49609: LD_VAR 0 3
49613: PPUSH
49614: CALL_OW 264
49618: PPUSH
49619: CALL 69723 0 5
49623: ST_TO_ADDR
// if components then
49624: LD_VAR 0 10
49628: IFFALSE 49646
// begin MC_InsertProduceList ( i , components ) ;
49630: LD_VAR 0 2
49634: PPUSH
49635: LD_VAR 0 10
49639: PPUSH
49640: CALL 58550 0 2
// break ;
49644: GO 49648
// end ; end ;
49646: GO 49566
49648: POP
49649: POP
// end ; continue ;
49650: GO 49146
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
49652: LD_VAR 0 3
49656: PPUSH
49657: LD_INT 1
49659: PPUSH
49660: CALL_OW 289
49664: PUSH
49665: LD_INT 100
49667: LESS
49668: PUSH
49669: LD_VAR 0 3
49673: PPUSH
49674: CALL_OW 314
49678: NOT
49679: AND
49680: IFFALSE 49709
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49682: LD_VAR 0 3
49686: PPUSH
49687: LD_VAR 0 6
49691: PUSH
49692: LD_INT 2
49694: ARRAY
49695: PPUSH
49696: LD_VAR 0 6
49700: PUSH
49701: LD_INT 3
49703: ARRAY
49704: PPUSH
49705: CALL_OW 117
// break ;
49709: GO 49713
// end ;
49711: GO 49146
49713: POP
49714: POP
// end ; end ;
49715: GO 47984
49717: POP
49718: POP
// end ;
49719: LD_VAR 0 1
49723: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
49724: LD_INT 0
49726: PPUSH
49727: PPUSH
49728: PPUSH
49729: PPUSH
// if not mc_bases then
49730: LD_EXP 102
49734: NOT
49735: IFFALSE 49739
// exit ;
49737: GO 49900
// for i = 1 to mc_bases do
49739: LD_ADDR_VAR 0 2
49743: PUSH
49744: DOUBLE
49745: LD_INT 1
49747: DEC
49748: ST_TO_ADDR
49749: LD_EXP 102
49753: PUSH
49754: FOR_TO
49755: IFFALSE 49898
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
49757: LD_ADDR_VAR 0 4
49761: PUSH
49762: LD_EXP 121
49766: PUSH
49767: LD_VAR 0 2
49771: ARRAY
49772: PUSH
49773: LD_EXP 124
49777: PUSH
49778: LD_VAR 0 2
49782: ARRAY
49783: UNION
49784: PPUSH
49785: LD_INT 33
49787: PUSH
49788: LD_INT 2
49790: PUSH
49791: EMPTY
49792: LIST
49793: LIST
49794: PPUSH
49795: CALL_OW 72
49799: ST_TO_ADDR
// if tmp then
49800: LD_VAR 0 4
49804: IFFALSE 49896
// for j in tmp do
49806: LD_ADDR_VAR 0 3
49810: PUSH
49811: LD_VAR 0 4
49815: PUSH
49816: FOR_IN
49817: IFFALSE 49894
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
49819: LD_VAR 0 3
49823: PPUSH
49824: CALL_OW 312
49828: NOT
49829: PUSH
49830: LD_VAR 0 3
49834: PPUSH
49835: CALL_OW 256
49839: PUSH
49840: LD_INT 250
49842: GREATEREQUAL
49843: AND
49844: IFFALSE 49857
// Connect ( j ) else
49846: LD_VAR 0 3
49850: PPUSH
49851: CALL 75124 0 1
49855: GO 49892
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49857: LD_VAR 0 3
49861: PPUSH
49862: CALL_OW 256
49866: PUSH
49867: LD_INT 250
49869: LESS
49870: PUSH
49871: LD_VAR 0 3
49875: PPUSH
49876: CALL_OW 312
49880: AND
49881: IFFALSE 49892
// ComUnlink ( j ) ;
49883: LD_VAR 0 3
49887: PPUSH
49888: CALL_OW 136
49892: GO 49816
49894: POP
49895: POP
// end ;
49896: GO 49754
49898: POP
49899: POP
// end ;
49900: LD_VAR 0 1
49904: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49905: LD_INT 0
49907: PPUSH
49908: PPUSH
49909: PPUSH
49910: PPUSH
49911: PPUSH
// if not mc_bases then
49912: LD_EXP 102
49916: NOT
49917: IFFALSE 49921
// exit ;
49919: GO 50366
// for i = 1 to mc_bases do
49921: LD_ADDR_VAR 0 2
49925: PUSH
49926: DOUBLE
49927: LD_INT 1
49929: DEC
49930: ST_TO_ADDR
49931: LD_EXP 102
49935: PUSH
49936: FOR_TO
49937: IFFALSE 50364
// begin if not mc_produce [ i ] then
49939: LD_EXP 123
49943: PUSH
49944: LD_VAR 0 2
49948: ARRAY
49949: NOT
49950: IFFALSE 49954
// continue ;
49952: GO 49936
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49954: LD_ADDR_VAR 0 5
49958: PUSH
49959: LD_EXP 102
49963: PUSH
49964: LD_VAR 0 2
49968: ARRAY
49969: PPUSH
49970: LD_INT 30
49972: PUSH
49973: LD_INT 3
49975: PUSH
49976: EMPTY
49977: LIST
49978: LIST
49979: PPUSH
49980: CALL_OW 72
49984: ST_TO_ADDR
// if not fac then
49985: LD_VAR 0 5
49989: NOT
49990: IFFALSE 49994
// continue ;
49992: GO 49936
// for j in fac do
49994: LD_ADDR_VAR 0 3
49998: PUSH
49999: LD_VAR 0 5
50003: PUSH
50004: FOR_IN
50005: IFFALSE 50360
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50007: LD_VAR 0 3
50011: PPUSH
50012: CALL_OW 461
50016: PUSH
50017: LD_INT 2
50019: NONEQUAL
50020: PUSH
50021: LD_VAR 0 3
50025: PPUSH
50026: LD_INT 15
50028: PPUSH
50029: CALL 74784 0 2
50033: PUSH
50034: LD_INT 4
50036: ARRAY
50037: OR
50038: IFFALSE 50042
// continue ;
50040: GO 50004
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50042: LD_VAR 0 3
50046: PPUSH
50047: LD_EXP 123
50051: PUSH
50052: LD_VAR 0 2
50056: ARRAY
50057: PUSH
50058: LD_INT 1
50060: ARRAY
50061: PUSH
50062: LD_INT 1
50064: ARRAY
50065: PPUSH
50066: LD_EXP 123
50070: PUSH
50071: LD_VAR 0 2
50075: ARRAY
50076: PUSH
50077: LD_INT 1
50079: ARRAY
50080: PUSH
50081: LD_INT 2
50083: ARRAY
50084: PPUSH
50085: LD_EXP 123
50089: PUSH
50090: LD_VAR 0 2
50094: ARRAY
50095: PUSH
50096: LD_INT 1
50098: ARRAY
50099: PUSH
50100: LD_INT 3
50102: ARRAY
50103: PPUSH
50104: LD_EXP 123
50108: PUSH
50109: LD_VAR 0 2
50113: ARRAY
50114: PUSH
50115: LD_INT 1
50117: ARRAY
50118: PUSH
50119: LD_INT 4
50121: ARRAY
50122: PPUSH
50123: CALL_OW 448
50127: PUSH
50128: LD_VAR 0 3
50132: PPUSH
50133: LD_EXP 123
50137: PUSH
50138: LD_VAR 0 2
50142: ARRAY
50143: PUSH
50144: LD_INT 1
50146: ARRAY
50147: PUSH
50148: LD_INT 1
50150: ARRAY
50151: PUSH
50152: LD_EXP 123
50156: PUSH
50157: LD_VAR 0 2
50161: ARRAY
50162: PUSH
50163: LD_INT 1
50165: ARRAY
50166: PUSH
50167: LD_INT 2
50169: ARRAY
50170: PUSH
50171: LD_EXP 123
50175: PUSH
50176: LD_VAR 0 2
50180: ARRAY
50181: PUSH
50182: LD_INT 1
50184: ARRAY
50185: PUSH
50186: LD_INT 3
50188: ARRAY
50189: PUSH
50190: LD_EXP 123
50194: PUSH
50195: LD_VAR 0 2
50199: ARRAY
50200: PUSH
50201: LD_INT 1
50203: ARRAY
50204: PUSH
50205: LD_INT 4
50207: ARRAY
50208: PUSH
50209: EMPTY
50210: LIST
50211: LIST
50212: LIST
50213: LIST
50214: PPUSH
50215: CALL 78455 0 2
50219: AND
50220: IFFALSE 50358
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50222: LD_VAR 0 3
50226: PPUSH
50227: LD_EXP 123
50231: PUSH
50232: LD_VAR 0 2
50236: ARRAY
50237: PUSH
50238: LD_INT 1
50240: ARRAY
50241: PUSH
50242: LD_INT 1
50244: ARRAY
50245: PPUSH
50246: LD_EXP 123
50250: PUSH
50251: LD_VAR 0 2
50255: ARRAY
50256: PUSH
50257: LD_INT 1
50259: ARRAY
50260: PUSH
50261: LD_INT 2
50263: ARRAY
50264: PPUSH
50265: LD_EXP 123
50269: PUSH
50270: LD_VAR 0 2
50274: ARRAY
50275: PUSH
50276: LD_INT 1
50278: ARRAY
50279: PUSH
50280: LD_INT 3
50282: ARRAY
50283: PPUSH
50284: LD_EXP 123
50288: PUSH
50289: LD_VAR 0 2
50293: ARRAY
50294: PUSH
50295: LD_INT 1
50297: ARRAY
50298: PUSH
50299: LD_INT 4
50301: ARRAY
50302: PPUSH
50303: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50307: LD_ADDR_VAR 0 4
50311: PUSH
50312: LD_EXP 123
50316: PUSH
50317: LD_VAR 0 2
50321: ARRAY
50322: PPUSH
50323: LD_INT 1
50325: PPUSH
50326: CALL_OW 3
50330: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50331: LD_ADDR_EXP 123
50335: PUSH
50336: LD_EXP 123
50340: PPUSH
50341: LD_VAR 0 2
50345: PPUSH
50346: LD_VAR 0 4
50350: PPUSH
50351: CALL_OW 1
50355: ST_TO_ADDR
// break ;
50356: GO 50360
// end ; end ;
50358: GO 50004
50360: POP
50361: POP
// end ;
50362: GO 49936
50364: POP
50365: POP
// end ;
50366: LD_VAR 0 1
50370: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
50371: LD_INT 0
50373: PPUSH
50374: PPUSH
50375: PPUSH
// if not mc_bases then
50376: LD_EXP 102
50380: NOT
50381: IFFALSE 50385
// exit ;
50383: GO 50474
// for i = 1 to mc_bases do
50385: LD_ADDR_VAR 0 2
50389: PUSH
50390: DOUBLE
50391: LD_INT 1
50393: DEC
50394: ST_TO_ADDR
50395: LD_EXP 102
50399: PUSH
50400: FOR_TO
50401: IFFALSE 50472
// begin if mc_attack [ i ] then
50403: LD_EXP 122
50407: PUSH
50408: LD_VAR 0 2
50412: ARRAY
50413: IFFALSE 50470
// begin tmp := mc_attack [ i ] [ 1 ] ;
50415: LD_ADDR_VAR 0 3
50419: PUSH
50420: LD_EXP 122
50424: PUSH
50425: LD_VAR 0 2
50429: ARRAY
50430: PUSH
50431: LD_INT 1
50433: ARRAY
50434: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
50435: LD_ADDR_EXP 122
50439: PUSH
50440: LD_EXP 122
50444: PPUSH
50445: LD_VAR 0 2
50449: PPUSH
50450: EMPTY
50451: PPUSH
50452: CALL_OW 1
50456: ST_TO_ADDR
// Attack ( tmp ) ;
50457: LD_VAR 0 3
50461: PPUSH
50462: CALL 100645 0 1
// exit ;
50466: POP
50467: POP
50468: GO 50474
// end ; end ;
50470: GO 50400
50472: POP
50473: POP
// end ;
50474: LD_VAR 0 1
50478: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
50479: LD_INT 0
50481: PPUSH
50482: PPUSH
50483: PPUSH
50484: PPUSH
50485: PPUSH
50486: PPUSH
50487: PPUSH
// if not mc_bases then
50488: LD_EXP 102
50492: NOT
50493: IFFALSE 50497
// exit ;
50495: GO 51079
// for i = 1 to mc_bases do
50497: LD_ADDR_VAR 0 2
50501: PUSH
50502: DOUBLE
50503: LD_INT 1
50505: DEC
50506: ST_TO_ADDR
50507: LD_EXP 102
50511: PUSH
50512: FOR_TO
50513: IFFALSE 51077
// begin if not mc_bases [ i ] then
50515: LD_EXP 102
50519: PUSH
50520: LD_VAR 0 2
50524: ARRAY
50525: NOT
50526: IFFALSE 50530
// continue ;
50528: GO 50512
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
50530: LD_ADDR_VAR 0 7
50534: PUSH
50535: LD_EXP 102
50539: PUSH
50540: LD_VAR 0 2
50544: ARRAY
50545: PUSH
50546: LD_INT 1
50548: ARRAY
50549: PPUSH
50550: CALL 69027 0 1
50554: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
50555: LD_ADDR_EXP 125
50559: PUSH
50560: LD_EXP 125
50564: PPUSH
50565: LD_VAR 0 2
50569: PPUSH
50570: LD_EXP 102
50574: PUSH
50575: LD_VAR 0 2
50579: ARRAY
50580: PUSH
50581: LD_INT 1
50583: ARRAY
50584: PPUSH
50585: CALL_OW 255
50589: PPUSH
50590: LD_EXP 127
50594: PUSH
50595: LD_VAR 0 2
50599: ARRAY
50600: PPUSH
50601: CALL 66581 0 2
50605: PPUSH
50606: CALL_OW 1
50610: ST_TO_ADDR
// if not mc_scan [ i ] then
50611: LD_EXP 125
50615: PUSH
50616: LD_VAR 0 2
50620: ARRAY
50621: NOT
50622: IFFALSE 50777
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50624: LD_ADDR_VAR 0 4
50628: PUSH
50629: LD_EXP 102
50633: PUSH
50634: LD_VAR 0 2
50638: ARRAY
50639: PPUSH
50640: LD_INT 2
50642: PUSH
50643: LD_INT 25
50645: PUSH
50646: LD_INT 5
50648: PUSH
50649: EMPTY
50650: LIST
50651: LIST
50652: PUSH
50653: LD_INT 25
50655: PUSH
50656: LD_INT 8
50658: PUSH
50659: EMPTY
50660: LIST
50661: LIST
50662: PUSH
50663: LD_INT 25
50665: PUSH
50666: LD_INT 9
50668: PUSH
50669: EMPTY
50670: LIST
50671: LIST
50672: PUSH
50673: EMPTY
50674: LIST
50675: LIST
50676: LIST
50677: LIST
50678: PPUSH
50679: CALL_OW 72
50683: ST_TO_ADDR
// if not tmp then
50684: LD_VAR 0 4
50688: NOT
50689: IFFALSE 50693
// continue ;
50691: GO 50512
// for j in tmp do
50693: LD_ADDR_VAR 0 3
50697: PUSH
50698: LD_VAR 0 4
50702: PUSH
50703: FOR_IN
50704: IFFALSE 50775
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
50706: LD_VAR 0 3
50710: PPUSH
50711: CALL_OW 310
50715: PPUSH
50716: CALL_OW 266
50720: PUSH
50721: LD_INT 5
50723: EQUAL
50724: PUSH
50725: LD_VAR 0 3
50729: PPUSH
50730: CALL_OW 257
50734: PUSH
50735: LD_INT 1
50737: EQUAL
50738: AND
50739: PUSH
50740: LD_VAR 0 3
50744: PPUSH
50745: CALL_OW 459
50749: NOT
50750: AND
50751: PUSH
50752: LD_VAR 0 7
50756: AND
50757: IFFALSE 50773
// ComChangeProfession ( j , class ) ;
50759: LD_VAR 0 3
50763: PPUSH
50764: LD_VAR 0 7
50768: PPUSH
50769: CALL_OW 123
50773: GO 50703
50775: POP
50776: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
50777: LD_EXP 125
50781: PUSH
50782: LD_VAR 0 2
50786: ARRAY
50787: PUSH
50788: LD_EXP 124
50792: PUSH
50793: LD_VAR 0 2
50797: ARRAY
50798: NOT
50799: AND
50800: PUSH
50801: LD_EXP 102
50805: PUSH
50806: LD_VAR 0 2
50810: ARRAY
50811: PPUSH
50812: LD_INT 30
50814: PUSH
50815: LD_INT 32
50817: PUSH
50818: EMPTY
50819: LIST
50820: LIST
50821: PPUSH
50822: CALL_OW 72
50826: NOT
50827: AND
50828: PUSH
50829: LD_EXP 102
50833: PUSH
50834: LD_VAR 0 2
50838: ARRAY
50839: PPUSH
50840: LD_INT 2
50842: PUSH
50843: LD_INT 30
50845: PUSH
50846: LD_INT 4
50848: PUSH
50849: EMPTY
50850: LIST
50851: LIST
50852: PUSH
50853: LD_INT 30
50855: PUSH
50856: LD_INT 5
50858: PUSH
50859: EMPTY
50860: LIST
50861: LIST
50862: PUSH
50863: EMPTY
50864: LIST
50865: LIST
50866: LIST
50867: PPUSH
50868: CALL_OW 72
50872: NOT
50873: AND
50874: IFFALSE 51006
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50876: LD_ADDR_VAR 0 4
50880: PUSH
50881: LD_EXP 102
50885: PUSH
50886: LD_VAR 0 2
50890: ARRAY
50891: PPUSH
50892: LD_INT 2
50894: PUSH
50895: LD_INT 25
50897: PUSH
50898: LD_INT 1
50900: PUSH
50901: EMPTY
50902: LIST
50903: LIST
50904: PUSH
50905: LD_INT 25
50907: PUSH
50908: LD_INT 5
50910: PUSH
50911: EMPTY
50912: LIST
50913: LIST
50914: PUSH
50915: LD_INT 25
50917: PUSH
50918: LD_INT 8
50920: PUSH
50921: EMPTY
50922: LIST
50923: LIST
50924: PUSH
50925: LD_INT 25
50927: PUSH
50928: LD_INT 9
50930: PUSH
50931: EMPTY
50932: LIST
50933: LIST
50934: PUSH
50935: EMPTY
50936: LIST
50937: LIST
50938: LIST
50939: LIST
50940: LIST
50941: PPUSH
50942: CALL_OW 72
50946: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50947: LD_ADDR_VAR 0 4
50951: PUSH
50952: LD_VAR 0 4
50956: PUSH
50957: LD_VAR 0 4
50961: PPUSH
50962: LD_INT 18
50964: PPUSH
50965: CALL 105461 0 2
50969: DIFF
50970: ST_TO_ADDR
// if tmp then
50971: LD_VAR 0 4
50975: IFFALSE 51006
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50977: LD_VAR 0 2
50981: PPUSH
50982: LD_VAR 0 4
50986: PPUSH
50987: LD_EXP 127
50991: PUSH
50992: LD_VAR 0 2
50996: ARRAY
50997: PPUSH
50998: CALL 66616 0 3
// exit ;
51002: POP
51003: POP
51004: GO 51079
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
51006: LD_EXP 125
51010: PUSH
51011: LD_VAR 0 2
51015: ARRAY
51016: PUSH
51017: LD_EXP 124
51021: PUSH
51022: LD_VAR 0 2
51026: ARRAY
51027: AND
51028: IFFALSE 51075
// begin tmp := mc_defender [ i ] ;
51030: LD_ADDR_VAR 0 4
51034: PUSH
51035: LD_EXP 124
51039: PUSH
51040: LD_VAR 0 2
51044: ARRAY
51045: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
51046: LD_VAR 0 2
51050: PPUSH
51051: LD_VAR 0 4
51055: PPUSH
51056: LD_EXP 125
51060: PUSH
51061: LD_VAR 0 2
51065: ARRAY
51066: PPUSH
51067: CALL 67177 0 3
// exit ;
51071: POP
51072: POP
51073: GO 51079
// end ; end ;
51075: GO 50512
51077: POP
51078: POP
// end ;
51079: LD_VAR 0 1
51083: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
51084: LD_INT 0
51086: PPUSH
51087: PPUSH
51088: PPUSH
51089: PPUSH
51090: PPUSH
51091: PPUSH
51092: PPUSH
51093: PPUSH
51094: PPUSH
51095: PPUSH
51096: PPUSH
// if not mc_bases then
51097: LD_EXP 102
51101: NOT
51102: IFFALSE 51106
// exit ;
51104: GO 52193
// for i = 1 to mc_bases do
51106: LD_ADDR_VAR 0 2
51110: PUSH
51111: DOUBLE
51112: LD_INT 1
51114: DEC
51115: ST_TO_ADDR
51116: LD_EXP 102
51120: PUSH
51121: FOR_TO
51122: IFFALSE 52191
// begin tmp := mc_lab [ i ] ;
51124: LD_ADDR_VAR 0 6
51128: PUSH
51129: LD_EXP 135
51133: PUSH
51134: LD_VAR 0 2
51138: ARRAY
51139: ST_TO_ADDR
// if not tmp then
51140: LD_VAR 0 6
51144: NOT
51145: IFFALSE 51149
// continue ;
51147: GO 51121
// idle_lab := 0 ;
51149: LD_ADDR_VAR 0 11
51153: PUSH
51154: LD_INT 0
51156: ST_TO_ADDR
// for j in tmp do
51157: LD_ADDR_VAR 0 3
51161: PUSH
51162: LD_VAR 0 6
51166: PUSH
51167: FOR_IN
51168: IFFALSE 52187
// begin researching := false ;
51170: LD_ADDR_VAR 0 10
51174: PUSH
51175: LD_INT 0
51177: ST_TO_ADDR
// side := GetSide ( j ) ;
51178: LD_ADDR_VAR 0 4
51182: PUSH
51183: LD_VAR 0 3
51187: PPUSH
51188: CALL_OW 255
51192: ST_TO_ADDR
// if not mc_tech [ side ] then
51193: LD_EXP 129
51197: PUSH
51198: LD_VAR 0 4
51202: ARRAY
51203: NOT
51204: IFFALSE 51208
// continue ;
51206: GO 51167
// if BuildingStatus ( j ) = bs_idle then
51208: LD_VAR 0 3
51212: PPUSH
51213: CALL_OW 461
51217: PUSH
51218: LD_INT 2
51220: EQUAL
51221: IFFALSE 51409
// begin if idle_lab and UnitsInside ( j ) < 6 then
51223: LD_VAR 0 11
51227: PUSH
51228: LD_VAR 0 3
51232: PPUSH
51233: CALL_OW 313
51237: PUSH
51238: LD_INT 6
51240: LESS
51241: AND
51242: IFFALSE 51313
// begin tmp2 := UnitsInside ( idle_lab ) ;
51244: LD_ADDR_VAR 0 9
51248: PUSH
51249: LD_VAR 0 11
51253: PPUSH
51254: CALL_OW 313
51258: ST_TO_ADDR
// if tmp2 then
51259: LD_VAR 0 9
51263: IFFALSE 51305
// for x in tmp2 do
51265: LD_ADDR_VAR 0 7
51269: PUSH
51270: LD_VAR 0 9
51274: PUSH
51275: FOR_IN
51276: IFFALSE 51303
// begin ComExitBuilding ( x ) ;
51278: LD_VAR 0 7
51282: PPUSH
51283: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51287: LD_VAR 0 7
51291: PPUSH
51292: LD_VAR 0 3
51296: PPUSH
51297: CALL_OW 180
// end ;
51301: GO 51275
51303: POP
51304: POP
// idle_lab := 0 ;
51305: LD_ADDR_VAR 0 11
51309: PUSH
51310: LD_INT 0
51312: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
51313: LD_ADDR_VAR 0 5
51317: PUSH
51318: LD_EXP 129
51322: PUSH
51323: LD_VAR 0 4
51327: ARRAY
51328: PUSH
51329: FOR_IN
51330: IFFALSE 51390
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
51332: LD_VAR 0 3
51336: PPUSH
51337: LD_VAR 0 5
51341: PPUSH
51342: CALL_OW 430
51346: PUSH
51347: LD_VAR 0 4
51351: PPUSH
51352: LD_VAR 0 5
51356: PPUSH
51357: CALL 65686 0 2
51361: AND
51362: IFFALSE 51388
// begin researching := true ;
51364: LD_ADDR_VAR 0 10
51368: PUSH
51369: LD_INT 1
51371: ST_TO_ADDR
// ComResearch ( j , t ) ;
51372: LD_VAR 0 3
51376: PPUSH
51377: LD_VAR 0 5
51381: PPUSH
51382: CALL_OW 124
// break ;
51386: GO 51390
// end ;
51388: GO 51329
51390: POP
51391: POP
// if not researching then
51392: LD_VAR 0 10
51396: NOT
51397: IFFALSE 51409
// idle_lab := j ;
51399: LD_ADDR_VAR 0 11
51403: PUSH
51404: LD_VAR 0 3
51408: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
51409: LD_VAR 0 3
51413: PPUSH
51414: CALL_OW 461
51418: PUSH
51419: LD_INT 10
51421: EQUAL
51422: IFFALSE 52010
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
51424: LD_EXP 131
51428: PUSH
51429: LD_VAR 0 2
51433: ARRAY
51434: NOT
51435: PUSH
51436: LD_EXP 132
51440: PUSH
51441: LD_VAR 0 2
51445: ARRAY
51446: NOT
51447: AND
51448: PUSH
51449: LD_EXP 129
51453: PUSH
51454: LD_VAR 0 4
51458: ARRAY
51459: PUSH
51460: LD_INT 1
51462: GREATER
51463: AND
51464: IFFALSE 51595
// begin ComCancel ( j ) ;
51466: LD_VAR 0 3
51470: PPUSH
51471: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
51475: LD_ADDR_EXP 129
51479: PUSH
51480: LD_EXP 129
51484: PPUSH
51485: LD_VAR 0 4
51489: PPUSH
51490: LD_EXP 129
51494: PUSH
51495: LD_VAR 0 4
51499: ARRAY
51500: PPUSH
51501: LD_EXP 129
51505: PUSH
51506: LD_VAR 0 4
51510: ARRAY
51511: PUSH
51512: LD_INT 1
51514: MINUS
51515: PPUSH
51516: LD_EXP 129
51520: PUSH
51521: LD_VAR 0 4
51525: ARRAY
51526: PPUSH
51527: LD_INT 0
51529: PPUSH
51530: CALL 71609 0 4
51534: PPUSH
51535: CALL_OW 1
51539: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
51540: LD_ADDR_EXP 129
51544: PUSH
51545: LD_EXP 129
51549: PPUSH
51550: LD_VAR 0 4
51554: PPUSH
51555: LD_EXP 129
51559: PUSH
51560: LD_VAR 0 4
51564: ARRAY
51565: PPUSH
51566: LD_EXP 129
51570: PUSH
51571: LD_VAR 0 4
51575: ARRAY
51576: PPUSH
51577: LD_INT 1
51579: PPUSH
51580: LD_INT 0
51582: PPUSH
51583: CALL 71609 0 4
51587: PPUSH
51588: CALL_OW 1
51592: ST_TO_ADDR
// continue ;
51593: GO 51167
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
51595: LD_EXP 131
51599: PUSH
51600: LD_VAR 0 2
51604: ARRAY
51605: PUSH
51606: LD_EXP 132
51610: PUSH
51611: LD_VAR 0 2
51615: ARRAY
51616: NOT
51617: AND
51618: IFFALSE 51745
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
51620: LD_ADDR_EXP 132
51624: PUSH
51625: LD_EXP 132
51629: PPUSH
51630: LD_VAR 0 2
51634: PUSH
51635: LD_EXP 132
51639: PUSH
51640: LD_VAR 0 2
51644: ARRAY
51645: PUSH
51646: LD_INT 1
51648: PLUS
51649: PUSH
51650: EMPTY
51651: LIST
51652: LIST
51653: PPUSH
51654: LD_EXP 131
51658: PUSH
51659: LD_VAR 0 2
51663: ARRAY
51664: PUSH
51665: LD_INT 1
51667: ARRAY
51668: PPUSH
51669: CALL 72191 0 3
51673: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
51674: LD_EXP 131
51678: PUSH
51679: LD_VAR 0 2
51683: ARRAY
51684: PUSH
51685: LD_INT 1
51687: ARRAY
51688: PPUSH
51689: LD_INT 112
51691: PPUSH
51692: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
51696: LD_ADDR_VAR 0 9
51700: PUSH
51701: LD_EXP 131
51705: PUSH
51706: LD_VAR 0 2
51710: ARRAY
51711: PPUSH
51712: LD_INT 1
51714: PPUSH
51715: CALL_OW 3
51719: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
51720: LD_ADDR_EXP 131
51724: PUSH
51725: LD_EXP 131
51729: PPUSH
51730: LD_VAR 0 2
51734: PPUSH
51735: LD_VAR 0 9
51739: PPUSH
51740: CALL_OW 1
51744: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
51745: LD_EXP 131
51749: PUSH
51750: LD_VAR 0 2
51754: ARRAY
51755: PUSH
51756: LD_EXP 132
51760: PUSH
51761: LD_VAR 0 2
51765: ARRAY
51766: AND
51767: PUSH
51768: LD_EXP 132
51772: PUSH
51773: LD_VAR 0 2
51777: ARRAY
51778: PUSH
51779: LD_INT 1
51781: ARRAY
51782: PPUSH
51783: CALL_OW 310
51787: NOT
51788: AND
51789: PUSH
51790: LD_VAR 0 3
51794: PPUSH
51795: CALL_OW 313
51799: PUSH
51800: LD_INT 6
51802: EQUAL
51803: AND
51804: IFFALSE 51860
// begin tmp2 := UnitsInside ( j ) ;
51806: LD_ADDR_VAR 0 9
51810: PUSH
51811: LD_VAR 0 3
51815: PPUSH
51816: CALL_OW 313
51820: ST_TO_ADDR
// if tmp2 = 6 then
51821: LD_VAR 0 9
51825: PUSH
51826: LD_INT 6
51828: EQUAL
51829: IFFALSE 51860
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
51831: LD_VAR 0 9
51835: PUSH
51836: LD_INT 1
51838: ARRAY
51839: PPUSH
51840: LD_INT 112
51842: PPUSH
51843: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51847: LD_VAR 0 9
51851: PUSH
51852: LD_INT 1
51854: ARRAY
51855: PPUSH
51856: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51860: LD_EXP 132
51864: PUSH
51865: LD_VAR 0 2
51869: ARRAY
51870: PUSH
51871: LD_EXP 132
51875: PUSH
51876: LD_VAR 0 2
51880: ARRAY
51881: PUSH
51882: LD_INT 1
51884: ARRAY
51885: PPUSH
51886: CALL_OW 314
51890: NOT
51891: AND
51892: PUSH
51893: LD_EXP 132
51897: PUSH
51898: LD_VAR 0 2
51902: ARRAY
51903: PUSH
51904: LD_INT 1
51906: ARRAY
51907: PPUSH
51908: CALL_OW 310
51912: NOT
51913: AND
51914: IFFALSE 51940
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51916: LD_EXP 132
51920: PUSH
51921: LD_VAR 0 2
51925: ARRAY
51926: PUSH
51927: LD_INT 1
51929: ARRAY
51930: PPUSH
51931: LD_VAR 0 3
51935: PPUSH
51936: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51940: LD_EXP 132
51944: PUSH
51945: LD_VAR 0 2
51949: ARRAY
51950: PUSH
51951: LD_INT 1
51953: ARRAY
51954: PPUSH
51955: CALL_OW 310
51959: PUSH
51960: LD_EXP 132
51964: PUSH
51965: LD_VAR 0 2
51969: ARRAY
51970: PUSH
51971: LD_INT 1
51973: ARRAY
51974: PPUSH
51975: CALL_OW 310
51979: PPUSH
51980: CALL_OW 461
51984: PUSH
51985: LD_INT 3
51987: NONEQUAL
51988: AND
51989: IFFALSE 52010
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51991: LD_EXP 132
51995: PUSH
51996: LD_VAR 0 2
52000: ARRAY
52001: PUSH
52002: LD_INT 1
52004: ARRAY
52005: PPUSH
52006: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52010: LD_VAR 0 3
52014: PPUSH
52015: CALL_OW 461
52019: PUSH
52020: LD_INT 6
52022: EQUAL
52023: PUSH
52024: LD_VAR 0 6
52028: PUSH
52029: LD_INT 1
52031: GREATER
52032: AND
52033: IFFALSE 52185
// begin sci := [ ] ;
52035: LD_ADDR_VAR 0 8
52039: PUSH
52040: EMPTY
52041: ST_TO_ADDR
// for x in ( tmp diff j ) do
52042: LD_ADDR_VAR 0 7
52046: PUSH
52047: LD_VAR 0 6
52051: PUSH
52052: LD_VAR 0 3
52056: DIFF
52057: PUSH
52058: FOR_IN
52059: IFFALSE 52111
// begin if sci = 6 then
52061: LD_VAR 0 8
52065: PUSH
52066: LD_INT 6
52068: EQUAL
52069: IFFALSE 52073
// break ;
52071: GO 52111
// if BuildingStatus ( x ) = bs_idle then
52073: LD_VAR 0 7
52077: PPUSH
52078: CALL_OW 461
52082: PUSH
52083: LD_INT 2
52085: EQUAL
52086: IFFALSE 52109
// sci := sci ^ UnitsInside ( x ) ;
52088: LD_ADDR_VAR 0 8
52092: PUSH
52093: LD_VAR 0 8
52097: PUSH
52098: LD_VAR 0 7
52102: PPUSH
52103: CALL_OW 313
52107: ADD
52108: ST_TO_ADDR
// end ;
52109: GO 52058
52111: POP
52112: POP
// if not sci then
52113: LD_VAR 0 8
52117: NOT
52118: IFFALSE 52122
// continue ;
52120: GO 51167
// for x in sci do
52122: LD_ADDR_VAR 0 7
52126: PUSH
52127: LD_VAR 0 8
52131: PUSH
52132: FOR_IN
52133: IFFALSE 52183
// if IsInUnit ( x ) and not HasTask ( x ) then
52135: LD_VAR 0 7
52139: PPUSH
52140: CALL_OW 310
52144: PUSH
52145: LD_VAR 0 7
52149: PPUSH
52150: CALL_OW 314
52154: NOT
52155: AND
52156: IFFALSE 52181
// begin ComExitBuilding ( x ) ;
52158: LD_VAR 0 7
52162: PPUSH
52163: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52167: LD_VAR 0 7
52171: PPUSH
52172: LD_VAR 0 3
52176: PPUSH
52177: CALL_OW 180
// end ;
52181: GO 52132
52183: POP
52184: POP
// end ; end ;
52185: GO 51167
52187: POP
52188: POP
// end ;
52189: GO 51121
52191: POP
52192: POP
// end ;
52193: LD_VAR 0 1
52197: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
52198: LD_INT 0
52200: PPUSH
52201: PPUSH
// if not mc_bases then
52202: LD_EXP 102
52206: NOT
52207: IFFALSE 52211
// exit ;
52209: GO 52292
// for i = 1 to mc_bases do
52211: LD_ADDR_VAR 0 2
52215: PUSH
52216: DOUBLE
52217: LD_INT 1
52219: DEC
52220: ST_TO_ADDR
52221: LD_EXP 102
52225: PUSH
52226: FOR_TO
52227: IFFALSE 52290
// if mc_mines [ i ] and mc_miners [ i ] then
52229: LD_EXP 115
52233: PUSH
52234: LD_VAR 0 2
52238: ARRAY
52239: PUSH
52240: LD_EXP 116
52244: PUSH
52245: LD_VAR 0 2
52249: ARRAY
52250: AND
52251: IFFALSE 52288
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
52253: LD_EXP 116
52257: PUSH
52258: LD_VAR 0 2
52262: ARRAY
52263: PUSH
52264: LD_INT 1
52266: ARRAY
52267: PPUSH
52268: CALL_OW 255
52272: PPUSH
52273: LD_EXP 115
52277: PUSH
52278: LD_VAR 0 2
52282: ARRAY
52283: PPUSH
52284: CALL 69180 0 2
52288: GO 52226
52290: POP
52291: POP
// end ;
52292: LD_VAR 0 1
52296: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
52297: LD_INT 0
52299: PPUSH
52300: PPUSH
52301: PPUSH
52302: PPUSH
52303: PPUSH
52304: PPUSH
52305: PPUSH
52306: PPUSH
// if not mc_bases or not mc_parking then
52307: LD_EXP 102
52311: NOT
52312: PUSH
52313: LD_EXP 126
52317: NOT
52318: OR
52319: IFFALSE 52323
// exit ;
52321: GO 53022
// for i = 1 to mc_bases do
52323: LD_ADDR_VAR 0 2
52327: PUSH
52328: DOUBLE
52329: LD_INT 1
52331: DEC
52332: ST_TO_ADDR
52333: LD_EXP 102
52337: PUSH
52338: FOR_TO
52339: IFFALSE 53020
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
52341: LD_EXP 102
52345: PUSH
52346: LD_VAR 0 2
52350: ARRAY
52351: NOT
52352: PUSH
52353: LD_EXP 126
52357: PUSH
52358: LD_VAR 0 2
52362: ARRAY
52363: NOT
52364: OR
52365: IFFALSE 52369
// continue ;
52367: GO 52338
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
52369: LD_ADDR_VAR 0 5
52373: PUSH
52374: LD_EXP 102
52378: PUSH
52379: LD_VAR 0 2
52383: ARRAY
52384: PUSH
52385: LD_INT 1
52387: ARRAY
52388: PPUSH
52389: CALL_OW 255
52393: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52394: LD_ADDR_VAR 0 6
52398: PUSH
52399: LD_EXP 102
52403: PUSH
52404: LD_VAR 0 2
52408: ARRAY
52409: PPUSH
52410: LD_INT 30
52412: PUSH
52413: LD_INT 3
52415: PUSH
52416: EMPTY
52417: LIST
52418: LIST
52419: PPUSH
52420: CALL_OW 72
52424: ST_TO_ADDR
// if not fac then
52425: LD_VAR 0 6
52429: NOT
52430: IFFALSE 52481
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52432: LD_ADDR_VAR 0 6
52436: PUSH
52437: LD_EXP 102
52441: PUSH
52442: LD_VAR 0 2
52446: ARRAY
52447: PPUSH
52448: LD_INT 2
52450: PUSH
52451: LD_INT 30
52453: PUSH
52454: LD_INT 0
52456: PUSH
52457: EMPTY
52458: LIST
52459: LIST
52460: PUSH
52461: LD_INT 30
52463: PUSH
52464: LD_INT 1
52466: PUSH
52467: EMPTY
52468: LIST
52469: LIST
52470: PUSH
52471: EMPTY
52472: LIST
52473: LIST
52474: LIST
52475: PPUSH
52476: CALL_OW 72
52480: ST_TO_ADDR
// if not fac then
52481: LD_VAR 0 6
52485: NOT
52486: IFFALSE 52490
// continue ;
52488: GO 52338
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52490: LD_ADDR_VAR 0 7
52494: PUSH
52495: LD_EXP 126
52499: PUSH
52500: LD_VAR 0 2
52504: ARRAY
52505: PPUSH
52506: LD_INT 22
52508: PUSH
52509: LD_VAR 0 5
52513: PUSH
52514: EMPTY
52515: LIST
52516: LIST
52517: PUSH
52518: LD_INT 21
52520: PUSH
52521: LD_INT 2
52523: PUSH
52524: EMPTY
52525: LIST
52526: LIST
52527: PUSH
52528: LD_INT 3
52530: PUSH
52531: LD_INT 24
52533: PUSH
52534: LD_INT 1000
52536: PUSH
52537: EMPTY
52538: LIST
52539: LIST
52540: PUSH
52541: EMPTY
52542: LIST
52543: LIST
52544: PUSH
52545: EMPTY
52546: LIST
52547: LIST
52548: LIST
52549: PPUSH
52550: CALL_OW 70
52554: ST_TO_ADDR
// for j in fac do
52555: LD_ADDR_VAR 0 3
52559: PUSH
52560: LD_VAR 0 6
52564: PUSH
52565: FOR_IN
52566: IFFALSE 52647
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
52568: LD_ADDR_VAR 0 7
52572: PUSH
52573: LD_VAR 0 7
52577: PUSH
52578: LD_INT 22
52580: PUSH
52581: LD_VAR 0 5
52585: PUSH
52586: EMPTY
52587: LIST
52588: LIST
52589: PUSH
52590: LD_INT 91
52592: PUSH
52593: LD_VAR 0 3
52597: PUSH
52598: LD_INT 15
52600: PUSH
52601: EMPTY
52602: LIST
52603: LIST
52604: LIST
52605: PUSH
52606: LD_INT 21
52608: PUSH
52609: LD_INT 2
52611: PUSH
52612: EMPTY
52613: LIST
52614: LIST
52615: PUSH
52616: LD_INT 3
52618: PUSH
52619: LD_INT 24
52621: PUSH
52622: LD_INT 1000
52624: PUSH
52625: EMPTY
52626: LIST
52627: LIST
52628: PUSH
52629: EMPTY
52630: LIST
52631: LIST
52632: PUSH
52633: EMPTY
52634: LIST
52635: LIST
52636: LIST
52637: LIST
52638: PPUSH
52639: CALL_OW 69
52643: UNION
52644: ST_TO_ADDR
52645: GO 52565
52647: POP
52648: POP
// if not vehs then
52649: LD_VAR 0 7
52653: NOT
52654: IFFALSE 52680
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
52656: LD_ADDR_EXP 114
52660: PUSH
52661: LD_EXP 114
52665: PPUSH
52666: LD_VAR 0 2
52670: PPUSH
52671: EMPTY
52672: PPUSH
52673: CALL_OW 1
52677: ST_TO_ADDR
// continue ;
52678: GO 52338
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
52680: LD_ADDR_VAR 0 8
52684: PUSH
52685: LD_EXP 102
52689: PUSH
52690: LD_VAR 0 2
52694: ARRAY
52695: PPUSH
52696: LD_INT 30
52698: PUSH
52699: LD_INT 3
52701: PUSH
52702: EMPTY
52703: LIST
52704: LIST
52705: PPUSH
52706: CALL_OW 72
52710: ST_TO_ADDR
// if tmp then
52711: LD_VAR 0 8
52715: IFFALSE 52818
// begin for j in tmp do
52717: LD_ADDR_VAR 0 3
52721: PUSH
52722: LD_VAR 0 8
52726: PUSH
52727: FOR_IN
52728: IFFALSE 52816
// for k in UnitsInside ( j ) do
52730: LD_ADDR_VAR 0 4
52734: PUSH
52735: LD_VAR 0 3
52739: PPUSH
52740: CALL_OW 313
52744: PUSH
52745: FOR_IN
52746: IFFALSE 52812
// if k then
52748: LD_VAR 0 4
52752: IFFALSE 52810
// if not k in mc_repair_vehicle [ i ] then
52754: LD_VAR 0 4
52758: PUSH
52759: LD_EXP 114
52763: PUSH
52764: LD_VAR 0 2
52768: ARRAY
52769: IN
52770: NOT
52771: IFFALSE 52810
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
52773: LD_ADDR_EXP 114
52777: PUSH
52778: LD_EXP 114
52782: PPUSH
52783: LD_VAR 0 2
52787: PPUSH
52788: LD_EXP 114
52792: PUSH
52793: LD_VAR 0 2
52797: ARRAY
52798: PUSH
52799: LD_VAR 0 4
52803: UNION
52804: PPUSH
52805: CALL_OW 1
52809: ST_TO_ADDR
52810: GO 52745
52812: POP
52813: POP
52814: GO 52727
52816: POP
52817: POP
// end ; if not mc_repair_vehicle [ i ] then
52818: LD_EXP 114
52822: PUSH
52823: LD_VAR 0 2
52827: ARRAY
52828: NOT
52829: IFFALSE 52833
// continue ;
52831: GO 52338
// for j in mc_repair_vehicle [ i ] do
52833: LD_ADDR_VAR 0 3
52837: PUSH
52838: LD_EXP 114
52842: PUSH
52843: LD_VAR 0 2
52847: ARRAY
52848: PUSH
52849: FOR_IN
52850: IFFALSE 53016
// begin if GetClass ( j ) <> 3 then
52852: LD_VAR 0 3
52856: PPUSH
52857: CALL_OW 257
52861: PUSH
52862: LD_INT 3
52864: NONEQUAL
52865: IFFALSE 52906
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52867: LD_ADDR_EXP 114
52871: PUSH
52872: LD_EXP 114
52876: PPUSH
52877: LD_VAR 0 2
52881: PPUSH
52882: LD_EXP 114
52886: PUSH
52887: LD_VAR 0 2
52891: ARRAY
52892: PUSH
52893: LD_VAR 0 3
52897: DIFF
52898: PPUSH
52899: CALL_OW 1
52903: ST_TO_ADDR
// continue ;
52904: GO 52849
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52906: LD_VAR 0 3
52910: PPUSH
52911: CALL_OW 311
52915: NOT
52916: PUSH
52917: LD_VAR 0 3
52921: PUSH
52922: LD_EXP 105
52926: PUSH
52927: LD_VAR 0 2
52931: ARRAY
52932: PUSH
52933: LD_INT 1
52935: ARRAY
52936: IN
52937: NOT
52938: AND
52939: PUSH
52940: LD_VAR 0 3
52944: PUSH
52945: LD_EXP 105
52949: PUSH
52950: LD_VAR 0 2
52954: ARRAY
52955: PUSH
52956: LD_INT 2
52958: ARRAY
52959: IN
52960: NOT
52961: AND
52962: IFFALSE 53014
// begin if IsInUnit ( j ) then
52964: LD_VAR 0 3
52968: PPUSH
52969: CALL_OW 310
52973: IFFALSE 52984
// ComExitBuilding ( j ) ;
52975: LD_VAR 0 3
52979: PPUSH
52980: CALL_OW 122
// if not HasTask ( j ) then
52984: LD_VAR 0 3
52988: PPUSH
52989: CALL_OW 314
52993: NOT
52994: IFFALSE 53014
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52996: LD_VAR 0 3
53000: PPUSH
53001: LD_VAR 0 7
53005: PUSH
53006: LD_INT 1
53008: ARRAY
53009: PPUSH
53010: CALL_OW 189
// end ; end ;
53014: GO 52849
53016: POP
53017: POP
// end ;
53018: GO 52338
53020: POP
53021: POP
// end ;
53022: LD_VAR 0 1
53026: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53027: LD_INT 0
53029: PPUSH
53030: PPUSH
53031: PPUSH
53032: PPUSH
53033: PPUSH
53034: PPUSH
53035: PPUSH
53036: PPUSH
53037: PPUSH
53038: PPUSH
53039: PPUSH
// if not mc_bases then
53040: LD_EXP 102
53044: NOT
53045: IFFALSE 53049
// exit ;
53047: GO 53851
// for i = 1 to mc_bases do
53049: LD_ADDR_VAR 0 2
53053: PUSH
53054: DOUBLE
53055: LD_INT 1
53057: DEC
53058: ST_TO_ADDR
53059: LD_EXP 102
53063: PUSH
53064: FOR_TO
53065: IFFALSE 53849
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53067: LD_EXP 130
53071: PUSH
53072: LD_VAR 0 2
53076: ARRAY
53077: NOT
53078: PUSH
53079: LD_EXP 105
53083: PUSH
53084: LD_VAR 0 2
53088: ARRAY
53089: PUSH
53090: LD_INT 1
53092: ARRAY
53093: OR
53094: PUSH
53095: LD_EXP 105
53099: PUSH
53100: LD_VAR 0 2
53104: ARRAY
53105: PUSH
53106: LD_INT 2
53108: ARRAY
53109: OR
53110: PUSH
53111: LD_EXP 128
53115: PUSH
53116: LD_VAR 0 2
53120: ARRAY
53121: PPUSH
53122: LD_INT 1
53124: PPUSH
53125: CALL_OW 325
53129: NOT
53130: OR
53131: PUSH
53132: LD_EXP 125
53136: PUSH
53137: LD_VAR 0 2
53141: ARRAY
53142: OR
53143: IFFALSE 53147
// continue ;
53145: GO 53064
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
53147: LD_ADDR_VAR 0 8
53151: PUSH
53152: LD_EXP 102
53156: PUSH
53157: LD_VAR 0 2
53161: ARRAY
53162: PPUSH
53163: LD_INT 25
53165: PUSH
53166: LD_INT 4
53168: PUSH
53169: EMPTY
53170: LIST
53171: LIST
53172: PUSH
53173: LD_INT 50
53175: PUSH
53176: EMPTY
53177: LIST
53178: PUSH
53179: LD_INT 3
53181: PUSH
53182: LD_INT 60
53184: PUSH
53185: EMPTY
53186: LIST
53187: PUSH
53188: EMPTY
53189: LIST
53190: LIST
53191: PUSH
53192: EMPTY
53193: LIST
53194: LIST
53195: LIST
53196: PPUSH
53197: CALL_OW 72
53201: PUSH
53202: LD_EXP 106
53206: PUSH
53207: LD_VAR 0 2
53211: ARRAY
53212: DIFF
53213: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53214: LD_ADDR_VAR 0 9
53218: PUSH
53219: LD_EXP 102
53223: PUSH
53224: LD_VAR 0 2
53228: ARRAY
53229: PPUSH
53230: LD_INT 2
53232: PUSH
53233: LD_INT 30
53235: PUSH
53236: LD_INT 0
53238: PUSH
53239: EMPTY
53240: LIST
53241: LIST
53242: PUSH
53243: LD_INT 30
53245: PUSH
53246: LD_INT 1
53248: PUSH
53249: EMPTY
53250: LIST
53251: LIST
53252: PUSH
53253: EMPTY
53254: LIST
53255: LIST
53256: LIST
53257: PPUSH
53258: CALL_OW 72
53262: ST_TO_ADDR
// if not tmp or not dep then
53263: LD_VAR 0 8
53267: NOT
53268: PUSH
53269: LD_VAR 0 9
53273: NOT
53274: OR
53275: IFFALSE 53279
// continue ;
53277: GO 53064
// side := GetSide ( tmp [ 1 ] ) ;
53279: LD_ADDR_VAR 0 11
53283: PUSH
53284: LD_VAR 0 8
53288: PUSH
53289: LD_INT 1
53291: ARRAY
53292: PPUSH
53293: CALL_OW 255
53297: ST_TO_ADDR
// dep := dep [ 1 ] ;
53298: LD_ADDR_VAR 0 9
53302: PUSH
53303: LD_VAR 0 9
53307: PUSH
53308: LD_INT 1
53310: ARRAY
53311: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
53312: LD_ADDR_VAR 0 7
53316: PUSH
53317: LD_EXP 130
53321: PUSH
53322: LD_VAR 0 2
53326: ARRAY
53327: PPUSH
53328: LD_INT 22
53330: PUSH
53331: LD_INT 0
53333: PUSH
53334: EMPTY
53335: LIST
53336: LIST
53337: PUSH
53338: LD_INT 25
53340: PUSH
53341: LD_INT 12
53343: PUSH
53344: EMPTY
53345: LIST
53346: LIST
53347: PUSH
53348: EMPTY
53349: LIST
53350: LIST
53351: PPUSH
53352: CALL_OW 70
53356: PUSH
53357: LD_INT 22
53359: PUSH
53360: LD_INT 0
53362: PUSH
53363: EMPTY
53364: LIST
53365: LIST
53366: PUSH
53367: LD_INT 25
53369: PUSH
53370: LD_INT 12
53372: PUSH
53373: EMPTY
53374: LIST
53375: LIST
53376: PUSH
53377: LD_INT 91
53379: PUSH
53380: LD_VAR 0 9
53384: PUSH
53385: LD_INT 20
53387: PUSH
53388: EMPTY
53389: LIST
53390: LIST
53391: LIST
53392: PUSH
53393: EMPTY
53394: LIST
53395: LIST
53396: LIST
53397: PPUSH
53398: CALL_OW 69
53402: UNION
53403: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
53404: LD_ADDR_VAR 0 10
53408: PUSH
53409: LD_EXP 130
53413: PUSH
53414: LD_VAR 0 2
53418: ARRAY
53419: PPUSH
53420: LD_INT 81
53422: PUSH
53423: LD_VAR 0 11
53427: PUSH
53428: EMPTY
53429: LIST
53430: LIST
53431: PPUSH
53432: CALL_OW 70
53436: ST_TO_ADDR
// if not apes or danger_at_area then
53437: LD_VAR 0 7
53441: NOT
53442: PUSH
53443: LD_VAR 0 10
53447: OR
53448: IFFALSE 53498
// begin if mc_taming [ i ] then
53450: LD_EXP 133
53454: PUSH
53455: LD_VAR 0 2
53459: ARRAY
53460: IFFALSE 53496
// begin MC_Reset ( i , 121 ) ;
53462: LD_VAR 0 2
53466: PPUSH
53467: LD_INT 121
53469: PPUSH
53470: CALL 38933 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53474: LD_ADDR_EXP 133
53478: PUSH
53479: LD_EXP 133
53483: PPUSH
53484: LD_VAR 0 2
53488: PPUSH
53489: EMPTY
53490: PPUSH
53491: CALL_OW 1
53495: ST_TO_ADDR
// end ; continue ;
53496: GO 53064
// end ; for j in tmp do
53498: LD_ADDR_VAR 0 3
53502: PUSH
53503: LD_VAR 0 8
53507: PUSH
53508: FOR_IN
53509: IFFALSE 53845
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
53511: LD_VAR 0 3
53515: PUSH
53516: LD_EXP 133
53520: PUSH
53521: LD_VAR 0 2
53525: ARRAY
53526: IN
53527: NOT
53528: PUSH
53529: LD_EXP 133
53533: PUSH
53534: LD_VAR 0 2
53538: ARRAY
53539: PUSH
53540: LD_INT 3
53542: LESS
53543: AND
53544: IFFALSE 53602
// begin SetTag ( j , 121 ) ;
53546: LD_VAR 0 3
53550: PPUSH
53551: LD_INT 121
53553: PPUSH
53554: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
53558: LD_ADDR_EXP 133
53562: PUSH
53563: LD_EXP 133
53567: PPUSH
53568: LD_VAR 0 2
53572: PUSH
53573: LD_EXP 133
53577: PUSH
53578: LD_VAR 0 2
53582: ARRAY
53583: PUSH
53584: LD_INT 1
53586: PLUS
53587: PUSH
53588: EMPTY
53589: LIST
53590: LIST
53591: PPUSH
53592: LD_VAR 0 3
53596: PPUSH
53597: CALL 72191 0 3
53601: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
53602: LD_VAR 0 3
53606: PUSH
53607: LD_EXP 133
53611: PUSH
53612: LD_VAR 0 2
53616: ARRAY
53617: IN
53618: IFFALSE 53843
// begin if GetClass ( j ) <> 4 then
53620: LD_VAR 0 3
53624: PPUSH
53625: CALL_OW 257
53629: PUSH
53630: LD_INT 4
53632: NONEQUAL
53633: IFFALSE 53686
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
53635: LD_ADDR_EXP 133
53639: PUSH
53640: LD_EXP 133
53644: PPUSH
53645: LD_VAR 0 2
53649: PPUSH
53650: LD_EXP 133
53654: PUSH
53655: LD_VAR 0 2
53659: ARRAY
53660: PUSH
53661: LD_VAR 0 3
53665: DIFF
53666: PPUSH
53667: CALL_OW 1
53671: ST_TO_ADDR
// SetTag ( j , 0 ) ;
53672: LD_VAR 0 3
53676: PPUSH
53677: LD_INT 0
53679: PPUSH
53680: CALL_OW 109
// continue ;
53684: GO 53508
// end ; if IsInUnit ( j ) then
53686: LD_VAR 0 3
53690: PPUSH
53691: CALL_OW 310
53695: IFFALSE 53706
// ComExitBuilding ( j ) ;
53697: LD_VAR 0 3
53701: PPUSH
53702: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
53706: LD_ADDR_VAR 0 6
53710: PUSH
53711: LD_VAR 0 7
53715: PPUSH
53716: LD_VAR 0 3
53720: PPUSH
53721: CALL_OW 74
53725: ST_TO_ADDR
// if not ape then
53726: LD_VAR 0 6
53730: NOT
53731: IFFALSE 53735
// break ;
53733: GO 53845
// x := GetX ( ape ) ;
53735: LD_ADDR_VAR 0 4
53739: PUSH
53740: LD_VAR 0 6
53744: PPUSH
53745: CALL_OW 250
53749: ST_TO_ADDR
// y := GetY ( ape ) ;
53750: LD_ADDR_VAR 0 5
53754: PUSH
53755: LD_VAR 0 6
53759: PPUSH
53760: CALL_OW 251
53764: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
53765: LD_VAR 0 4
53769: PPUSH
53770: LD_VAR 0 5
53774: PPUSH
53775: CALL_OW 488
53779: NOT
53780: PUSH
53781: LD_VAR 0 11
53785: PPUSH
53786: LD_VAR 0 4
53790: PPUSH
53791: LD_VAR 0 5
53795: PPUSH
53796: LD_INT 20
53798: PPUSH
53799: CALL 73087 0 4
53803: PUSH
53804: LD_INT 4
53806: ARRAY
53807: OR
53808: IFFALSE 53812
// break ;
53810: GO 53845
// if not HasTask ( j ) then
53812: LD_VAR 0 3
53816: PPUSH
53817: CALL_OW 314
53821: NOT
53822: IFFALSE 53843
// ComTameXY ( j , x , y ) ;
53824: LD_VAR 0 3
53828: PPUSH
53829: LD_VAR 0 4
53833: PPUSH
53834: LD_VAR 0 5
53838: PPUSH
53839: CALL_OW 131
// end ; end ;
53843: GO 53508
53845: POP
53846: POP
// end ;
53847: GO 53064
53849: POP
53850: POP
// end ;
53851: LD_VAR 0 1
53855: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53856: LD_INT 0
53858: PPUSH
53859: PPUSH
53860: PPUSH
53861: PPUSH
53862: PPUSH
53863: PPUSH
53864: PPUSH
53865: PPUSH
// if not mc_bases then
53866: LD_EXP 102
53870: NOT
53871: IFFALSE 53875
// exit ;
53873: GO 54501
// for i = 1 to mc_bases do
53875: LD_ADDR_VAR 0 2
53879: PUSH
53880: DOUBLE
53881: LD_INT 1
53883: DEC
53884: ST_TO_ADDR
53885: LD_EXP 102
53889: PUSH
53890: FOR_TO
53891: IFFALSE 54499
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53893: LD_EXP 131
53897: PUSH
53898: LD_VAR 0 2
53902: ARRAY
53903: NOT
53904: PUSH
53905: LD_EXP 131
53909: PUSH
53910: LD_VAR 0 2
53914: ARRAY
53915: PPUSH
53916: LD_INT 25
53918: PUSH
53919: LD_INT 12
53921: PUSH
53922: EMPTY
53923: LIST
53924: LIST
53925: PPUSH
53926: CALL_OW 72
53930: NOT
53931: OR
53932: IFFALSE 53936
// continue ;
53934: GO 53890
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53936: LD_ADDR_VAR 0 5
53940: PUSH
53941: LD_EXP 131
53945: PUSH
53946: LD_VAR 0 2
53950: ARRAY
53951: PUSH
53952: LD_INT 1
53954: ARRAY
53955: PPUSH
53956: CALL_OW 255
53960: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53961: LD_VAR 0 5
53965: PPUSH
53966: LD_INT 2
53968: PPUSH
53969: CALL_OW 325
53973: IFFALSE 54226
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53975: LD_ADDR_VAR 0 4
53979: PUSH
53980: LD_EXP 131
53984: PUSH
53985: LD_VAR 0 2
53989: ARRAY
53990: PPUSH
53991: LD_INT 25
53993: PUSH
53994: LD_INT 16
53996: PUSH
53997: EMPTY
53998: LIST
53999: LIST
54000: PPUSH
54001: CALL_OW 72
54005: ST_TO_ADDR
// if tmp < 6 then
54006: LD_VAR 0 4
54010: PUSH
54011: LD_INT 6
54013: LESS
54014: IFFALSE 54226
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54016: LD_ADDR_VAR 0 6
54020: PUSH
54021: LD_EXP 102
54025: PUSH
54026: LD_VAR 0 2
54030: ARRAY
54031: PPUSH
54032: LD_INT 2
54034: PUSH
54035: LD_INT 30
54037: PUSH
54038: LD_INT 0
54040: PUSH
54041: EMPTY
54042: LIST
54043: LIST
54044: PUSH
54045: LD_INT 30
54047: PUSH
54048: LD_INT 1
54050: PUSH
54051: EMPTY
54052: LIST
54053: LIST
54054: PUSH
54055: EMPTY
54056: LIST
54057: LIST
54058: LIST
54059: PPUSH
54060: CALL_OW 72
54064: ST_TO_ADDR
// if depot then
54065: LD_VAR 0 6
54069: IFFALSE 54226
// begin selected := 0 ;
54071: LD_ADDR_VAR 0 7
54075: PUSH
54076: LD_INT 0
54078: ST_TO_ADDR
// for j in depot do
54079: LD_ADDR_VAR 0 3
54083: PUSH
54084: LD_VAR 0 6
54088: PUSH
54089: FOR_IN
54090: IFFALSE 54121
// begin if UnitsInside ( j ) < 6 then
54092: LD_VAR 0 3
54096: PPUSH
54097: CALL_OW 313
54101: PUSH
54102: LD_INT 6
54104: LESS
54105: IFFALSE 54119
// begin selected := j ;
54107: LD_ADDR_VAR 0 7
54111: PUSH
54112: LD_VAR 0 3
54116: ST_TO_ADDR
// break ;
54117: GO 54121
// end ; end ;
54119: GO 54089
54121: POP
54122: POP
// if selected then
54123: LD_VAR 0 7
54127: IFFALSE 54226
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54129: LD_ADDR_VAR 0 3
54133: PUSH
54134: LD_EXP 131
54138: PUSH
54139: LD_VAR 0 2
54143: ARRAY
54144: PPUSH
54145: LD_INT 25
54147: PUSH
54148: LD_INT 12
54150: PUSH
54151: EMPTY
54152: LIST
54153: LIST
54154: PPUSH
54155: CALL_OW 72
54159: PUSH
54160: FOR_IN
54161: IFFALSE 54224
// if not HasTask ( j ) then
54163: LD_VAR 0 3
54167: PPUSH
54168: CALL_OW 314
54172: NOT
54173: IFFALSE 54222
// begin if not IsInUnit ( j ) then
54175: LD_VAR 0 3
54179: PPUSH
54180: CALL_OW 310
54184: NOT
54185: IFFALSE 54201
// ComEnterUnit ( j , selected ) ;
54187: LD_VAR 0 3
54191: PPUSH
54192: LD_VAR 0 7
54196: PPUSH
54197: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
54201: LD_VAR 0 3
54205: PPUSH
54206: LD_INT 16
54208: PPUSH
54209: CALL_OW 183
// AddComExitBuilding ( j ) ;
54213: LD_VAR 0 3
54217: PPUSH
54218: CALL_OW 182
// end ;
54222: GO 54160
54224: POP
54225: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
54226: LD_VAR 0 5
54230: PPUSH
54231: LD_INT 11
54233: PPUSH
54234: CALL_OW 325
54238: IFFALSE 54497
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54240: LD_ADDR_VAR 0 4
54244: PUSH
54245: LD_EXP 131
54249: PUSH
54250: LD_VAR 0 2
54254: ARRAY
54255: PPUSH
54256: LD_INT 25
54258: PUSH
54259: LD_INT 16
54261: PUSH
54262: EMPTY
54263: LIST
54264: LIST
54265: PPUSH
54266: CALL_OW 72
54270: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
54271: LD_VAR 0 4
54275: PUSH
54276: LD_INT 6
54278: GREATEREQUAL
54279: PUSH
54280: LD_VAR 0 5
54284: PPUSH
54285: LD_INT 2
54287: PPUSH
54288: CALL_OW 325
54292: NOT
54293: OR
54294: IFFALSE 54497
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
54296: LD_ADDR_VAR 0 8
54300: PUSH
54301: LD_EXP 102
54305: PUSH
54306: LD_VAR 0 2
54310: ARRAY
54311: PPUSH
54312: LD_INT 2
54314: PUSH
54315: LD_INT 30
54317: PUSH
54318: LD_INT 4
54320: PUSH
54321: EMPTY
54322: LIST
54323: LIST
54324: PUSH
54325: LD_INT 30
54327: PUSH
54328: LD_INT 5
54330: PUSH
54331: EMPTY
54332: LIST
54333: LIST
54334: PUSH
54335: EMPTY
54336: LIST
54337: LIST
54338: LIST
54339: PPUSH
54340: CALL_OW 72
54344: ST_TO_ADDR
// if barracks then
54345: LD_VAR 0 8
54349: IFFALSE 54497
// begin selected := 0 ;
54351: LD_ADDR_VAR 0 7
54355: PUSH
54356: LD_INT 0
54358: ST_TO_ADDR
// for j in barracks do
54359: LD_ADDR_VAR 0 3
54363: PUSH
54364: LD_VAR 0 8
54368: PUSH
54369: FOR_IN
54370: IFFALSE 54401
// begin if UnitsInside ( j ) < 6 then
54372: LD_VAR 0 3
54376: PPUSH
54377: CALL_OW 313
54381: PUSH
54382: LD_INT 6
54384: LESS
54385: IFFALSE 54399
// begin selected := j ;
54387: LD_ADDR_VAR 0 7
54391: PUSH
54392: LD_VAR 0 3
54396: ST_TO_ADDR
// break ;
54397: GO 54401
// end ; end ;
54399: GO 54369
54401: POP
54402: POP
// if selected then
54403: LD_VAR 0 7
54407: IFFALSE 54497
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
54409: LD_ADDR_VAR 0 3
54413: PUSH
54414: LD_EXP 131
54418: PUSH
54419: LD_VAR 0 2
54423: ARRAY
54424: PPUSH
54425: LD_INT 25
54427: PUSH
54428: LD_INT 12
54430: PUSH
54431: EMPTY
54432: LIST
54433: LIST
54434: PPUSH
54435: CALL_OW 72
54439: PUSH
54440: FOR_IN
54441: IFFALSE 54495
// if not IsInUnit ( j ) and not HasTask ( j ) then
54443: LD_VAR 0 3
54447: PPUSH
54448: CALL_OW 310
54452: NOT
54453: PUSH
54454: LD_VAR 0 3
54458: PPUSH
54459: CALL_OW 314
54463: NOT
54464: AND
54465: IFFALSE 54493
// begin ComEnterUnit ( j , selected ) ;
54467: LD_VAR 0 3
54471: PPUSH
54472: LD_VAR 0 7
54476: PPUSH
54477: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
54481: LD_VAR 0 3
54485: PPUSH
54486: LD_INT 15
54488: PPUSH
54489: CALL_OW 183
// end ;
54493: GO 54440
54495: POP
54496: POP
// end ; end ; end ; end ; end ;
54497: GO 53890
54499: POP
54500: POP
// end ;
54501: LD_VAR 0 1
54505: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
54506: LD_INT 0
54508: PPUSH
54509: PPUSH
54510: PPUSH
54511: PPUSH
// if not mc_bases then
54512: LD_EXP 102
54516: NOT
54517: IFFALSE 54521
// exit ;
54519: GO 54699
// for i = 1 to mc_bases do
54521: LD_ADDR_VAR 0 2
54525: PUSH
54526: DOUBLE
54527: LD_INT 1
54529: DEC
54530: ST_TO_ADDR
54531: LD_EXP 102
54535: PUSH
54536: FOR_TO
54537: IFFALSE 54697
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
54539: LD_ADDR_VAR 0 4
54543: PUSH
54544: LD_EXP 102
54548: PUSH
54549: LD_VAR 0 2
54553: ARRAY
54554: PPUSH
54555: LD_INT 25
54557: PUSH
54558: LD_INT 9
54560: PUSH
54561: EMPTY
54562: LIST
54563: LIST
54564: PPUSH
54565: CALL_OW 72
54569: ST_TO_ADDR
// if not tmp then
54570: LD_VAR 0 4
54574: NOT
54575: IFFALSE 54579
// continue ;
54577: GO 54536
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
54579: LD_EXP 128
54583: PUSH
54584: LD_VAR 0 2
54588: ARRAY
54589: PPUSH
54590: LD_INT 29
54592: PPUSH
54593: CALL_OW 325
54597: NOT
54598: PUSH
54599: LD_EXP 128
54603: PUSH
54604: LD_VAR 0 2
54608: ARRAY
54609: PPUSH
54610: LD_INT 28
54612: PPUSH
54613: CALL_OW 325
54617: NOT
54618: AND
54619: IFFALSE 54623
// continue ;
54621: GO 54536
// for j in tmp do
54623: LD_ADDR_VAR 0 3
54627: PUSH
54628: LD_VAR 0 4
54632: PUSH
54633: FOR_IN
54634: IFFALSE 54693
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
54636: LD_VAR 0 3
54640: PUSH
54641: LD_EXP 105
54645: PUSH
54646: LD_VAR 0 2
54650: ARRAY
54651: PUSH
54652: LD_INT 1
54654: ARRAY
54655: IN
54656: NOT
54657: PUSH
54658: LD_VAR 0 3
54662: PUSH
54663: LD_EXP 105
54667: PUSH
54668: LD_VAR 0 2
54672: ARRAY
54673: PUSH
54674: LD_INT 2
54676: ARRAY
54677: IN
54678: NOT
54679: AND
54680: IFFALSE 54691
// ComSpaceTimeShoot ( j ) ;
54682: LD_VAR 0 3
54686: PPUSH
54687: CALL 65777 0 1
54691: GO 54633
54693: POP
54694: POP
// end ;
54695: GO 54536
54697: POP
54698: POP
// end ;
54699: LD_VAR 0 1
54703: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
54704: LD_INT 0
54706: PPUSH
54707: PPUSH
54708: PPUSH
54709: PPUSH
54710: PPUSH
54711: PPUSH
54712: PPUSH
54713: PPUSH
54714: PPUSH
// if not mc_bases then
54715: LD_EXP 102
54719: NOT
54720: IFFALSE 54724
// exit ;
54722: GO 55346
// for i = 1 to mc_bases do
54724: LD_ADDR_VAR 0 2
54728: PUSH
54729: DOUBLE
54730: LD_INT 1
54732: DEC
54733: ST_TO_ADDR
54734: LD_EXP 102
54738: PUSH
54739: FOR_TO
54740: IFFALSE 55344
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
54742: LD_EXP 137
54746: PUSH
54747: LD_VAR 0 2
54751: ARRAY
54752: NOT
54753: PUSH
54754: LD_INT 38
54756: PPUSH
54757: LD_EXP 128
54761: PUSH
54762: LD_VAR 0 2
54766: ARRAY
54767: PPUSH
54768: CALL_OW 321
54772: PUSH
54773: LD_INT 2
54775: NONEQUAL
54776: OR
54777: IFFALSE 54781
// continue ;
54779: GO 54739
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
54781: LD_ADDR_VAR 0 8
54785: PUSH
54786: LD_EXP 102
54790: PUSH
54791: LD_VAR 0 2
54795: ARRAY
54796: PPUSH
54797: LD_INT 30
54799: PUSH
54800: LD_INT 34
54802: PUSH
54803: EMPTY
54804: LIST
54805: LIST
54806: PPUSH
54807: CALL_OW 72
54811: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
54812: LD_ADDR_VAR 0 9
54816: PUSH
54817: LD_EXP 102
54821: PUSH
54822: LD_VAR 0 2
54826: ARRAY
54827: PPUSH
54828: LD_INT 25
54830: PUSH
54831: LD_INT 4
54833: PUSH
54834: EMPTY
54835: LIST
54836: LIST
54837: PPUSH
54838: CALL_OW 72
54842: PPUSH
54843: LD_INT 0
54845: PPUSH
54846: CALL 105461 0 2
54850: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54851: LD_VAR 0 9
54855: NOT
54856: PUSH
54857: LD_VAR 0 8
54861: NOT
54862: OR
54863: PUSH
54864: LD_EXP 102
54868: PUSH
54869: LD_VAR 0 2
54873: ARRAY
54874: PPUSH
54875: LD_INT 124
54877: PPUSH
54878: CALL 105461 0 2
54882: OR
54883: IFFALSE 54887
// continue ;
54885: GO 54739
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54887: LD_EXP 138
54891: PUSH
54892: LD_VAR 0 2
54896: ARRAY
54897: PUSH
54898: LD_EXP 137
54902: PUSH
54903: LD_VAR 0 2
54907: ARRAY
54908: LESS
54909: PUSH
54910: LD_EXP 138
54914: PUSH
54915: LD_VAR 0 2
54919: ARRAY
54920: PUSH
54921: LD_VAR 0 8
54925: LESS
54926: AND
54927: IFFALSE 55342
// begin tmp := sci [ 1 ] ;
54929: LD_ADDR_VAR 0 7
54933: PUSH
54934: LD_VAR 0 9
54938: PUSH
54939: LD_INT 1
54941: ARRAY
54942: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54943: LD_VAR 0 7
54947: PPUSH
54948: LD_INT 124
54950: PPUSH
54951: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54955: LD_ADDR_VAR 0 3
54959: PUSH
54960: DOUBLE
54961: LD_EXP 137
54965: PUSH
54966: LD_VAR 0 2
54970: ARRAY
54971: INC
54972: ST_TO_ADDR
54973: LD_EXP 137
54977: PUSH
54978: LD_VAR 0 2
54982: ARRAY
54983: PUSH
54984: FOR_DOWNTO
54985: IFFALSE 55328
// begin if IsInUnit ( tmp ) then
54987: LD_VAR 0 7
54991: PPUSH
54992: CALL_OW 310
54996: IFFALSE 55007
// ComExitBuilding ( tmp ) ;
54998: LD_VAR 0 7
55002: PPUSH
55003: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55007: LD_INT 35
55009: PPUSH
55010: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55014: LD_VAR 0 7
55018: PPUSH
55019: CALL_OW 310
55023: NOT
55024: PUSH
55025: LD_VAR 0 7
55029: PPUSH
55030: CALL_OW 314
55034: NOT
55035: AND
55036: IFFALSE 55007
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55038: LD_ADDR_VAR 0 6
55042: PUSH
55043: LD_VAR 0 7
55047: PPUSH
55048: CALL_OW 250
55052: PUSH
55053: LD_VAR 0 7
55057: PPUSH
55058: CALL_OW 251
55062: PUSH
55063: EMPTY
55064: LIST
55065: LIST
55066: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55067: LD_INT 35
55069: PPUSH
55070: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
55074: LD_ADDR_VAR 0 4
55078: PUSH
55079: LD_EXP 137
55083: PUSH
55084: LD_VAR 0 2
55088: ARRAY
55089: PUSH
55090: LD_VAR 0 3
55094: ARRAY
55095: PUSH
55096: LD_INT 1
55098: ARRAY
55099: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
55100: LD_ADDR_VAR 0 5
55104: PUSH
55105: LD_EXP 137
55109: PUSH
55110: LD_VAR 0 2
55114: ARRAY
55115: PUSH
55116: LD_VAR 0 3
55120: ARRAY
55121: PUSH
55122: LD_INT 2
55124: ARRAY
55125: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
55126: LD_VAR 0 7
55130: PPUSH
55131: LD_INT 10
55133: PPUSH
55134: CALL 74784 0 2
55138: PUSH
55139: LD_INT 4
55141: ARRAY
55142: IFFALSE 55180
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
55144: LD_VAR 0 7
55148: PPUSH
55149: LD_VAR 0 6
55153: PUSH
55154: LD_INT 1
55156: ARRAY
55157: PPUSH
55158: LD_VAR 0 6
55162: PUSH
55163: LD_INT 2
55165: ARRAY
55166: PPUSH
55167: CALL_OW 111
// wait ( 0 0$10 ) ;
55171: LD_INT 350
55173: PPUSH
55174: CALL_OW 67
// end else
55178: GO 55206
// begin ComMoveXY ( tmp , x , y ) ;
55180: LD_VAR 0 7
55184: PPUSH
55185: LD_VAR 0 4
55189: PPUSH
55190: LD_VAR 0 5
55194: PPUSH
55195: CALL_OW 111
// wait ( 0 0$3 ) ;
55199: LD_INT 105
55201: PPUSH
55202: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
55206: LD_VAR 0 7
55210: PPUSH
55211: LD_VAR 0 4
55215: PPUSH
55216: LD_VAR 0 5
55220: PPUSH
55221: CALL_OW 307
55225: IFFALSE 55067
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
55227: LD_VAR 0 7
55231: PPUSH
55232: LD_VAR 0 4
55236: PPUSH
55237: LD_VAR 0 5
55241: PPUSH
55242: LD_VAR 0 8
55246: PUSH
55247: LD_VAR 0 3
55251: ARRAY
55252: PPUSH
55253: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
55257: LD_INT 35
55259: PPUSH
55260: CALL_OW 67
// until not HasTask ( tmp ) ;
55264: LD_VAR 0 7
55268: PPUSH
55269: CALL_OW 314
55273: NOT
55274: IFFALSE 55257
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
55276: LD_ADDR_EXP 138
55280: PUSH
55281: LD_EXP 138
55285: PPUSH
55286: LD_VAR 0 2
55290: PUSH
55291: LD_EXP 138
55295: PUSH
55296: LD_VAR 0 2
55300: ARRAY
55301: PUSH
55302: LD_INT 1
55304: PLUS
55305: PUSH
55306: EMPTY
55307: LIST
55308: LIST
55309: PPUSH
55310: LD_VAR 0 8
55314: PUSH
55315: LD_VAR 0 3
55319: ARRAY
55320: PPUSH
55321: CALL 72191 0 3
55325: ST_TO_ADDR
// end ;
55326: GO 54984
55328: POP
55329: POP
// MC_Reset ( i , 124 ) ;
55330: LD_VAR 0 2
55334: PPUSH
55335: LD_INT 124
55337: PPUSH
55338: CALL 38933 0 2
// end ; end ;
55342: GO 54739
55344: POP
55345: POP
// end ;
55346: LD_VAR 0 1
55350: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
55351: LD_INT 0
55353: PPUSH
55354: PPUSH
55355: PPUSH
// if not mc_bases then
55356: LD_EXP 102
55360: NOT
55361: IFFALSE 55365
// exit ;
55363: GO 55971
// for i = 1 to mc_bases do
55365: LD_ADDR_VAR 0 2
55369: PUSH
55370: DOUBLE
55371: LD_INT 1
55373: DEC
55374: ST_TO_ADDR
55375: LD_EXP 102
55379: PUSH
55380: FOR_TO
55381: IFFALSE 55969
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
55383: LD_ADDR_VAR 0 3
55387: PUSH
55388: LD_EXP 102
55392: PUSH
55393: LD_VAR 0 2
55397: ARRAY
55398: PPUSH
55399: LD_INT 25
55401: PUSH
55402: LD_INT 4
55404: PUSH
55405: EMPTY
55406: LIST
55407: LIST
55408: PPUSH
55409: CALL_OW 72
55413: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55414: LD_VAR 0 3
55418: NOT
55419: PUSH
55420: LD_EXP 139
55424: PUSH
55425: LD_VAR 0 2
55429: ARRAY
55430: NOT
55431: OR
55432: PUSH
55433: LD_EXP 102
55437: PUSH
55438: LD_VAR 0 2
55442: ARRAY
55443: PPUSH
55444: LD_INT 2
55446: PUSH
55447: LD_INT 30
55449: PUSH
55450: LD_INT 0
55452: PUSH
55453: EMPTY
55454: LIST
55455: LIST
55456: PUSH
55457: LD_INT 30
55459: PUSH
55460: LD_INT 1
55462: PUSH
55463: EMPTY
55464: LIST
55465: LIST
55466: PUSH
55467: EMPTY
55468: LIST
55469: LIST
55470: LIST
55471: PPUSH
55472: CALL_OW 72
55476: NOT
55477: OR
55478: IFFALSE 55528
// begin if mc_deposits_finder [ i ] then
55480: LD_EXP 140
55484: PUSH
55485: LD_VAR 0 2
55489: ARRAY
55490: IFFALSE 55526
// begin MC_Reset ( i , 125 ) ;
55492: LD_VAR 0 2
55496: PPUSH
55497: LD_INT 125
55499: PPUSH
55500: CALL 38933 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55504: LD_ADDR_EXP 140
55508: PUSH
55509: LD_EXP 140
55513: PPUSH
55514: LD_VAR 0 2
55518: PPUSH
55519: EMPTY
55520: PPUSH
55521: CALL_OW 1
55525: ST_TO_ADDR
// end ; continue ;
55526: GO 55380
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
55528: LD_EXP 139
55532: PUSH
55533: LD_VAR 0 2
55537: ARRAY
55538: PUSH
55539: LD_INT 1
55541: ARRAY
55542: PUSH
55543: LD_INT 3
55545: ARRAY
55546: PUSH
55547: LD_INT 1
55549: EQUAL
55550: PUSH
55551: LD_INT 20
55553: PPUSH
55554: LD_EXP 128
55558: PUSH
55559: LD_VAR 0 2
55563: ARRAY
55564: PPUSH
55565: CALL_OW 321
55569: PUSH
55570: LD_INT 2
55572: NONEQUAL
55573: AND
55574: IFFALSE 55624
// begin if mc_deposits_finder [ i ] then
55576: LD_EXP 140
55580: PUSH
55581: LD_VAR 0 2
55585: ARRAY
55586: IFFALSE 55622
// begin MC_Reset ( i , 125 ) ;
55588: LD_VAR 0 2
55592: PPUSH
55593: LD_INT 125
55595: PPUSH
55596: CALL 38933 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55600: LD_ADDR_EXP 140
55604: PUSH
55605: LD_EXP 140
55609: PPUSH
55610: LD_VAR 0 2
55614: PPUSH
55615: EMPTY
55616: PPUSH
55617: CALL_OW 1
55621: ST_TO_ADDR
// end ; continue ;
55622: GO 55380
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
55624: LD_EXP 139
55628: PUSH
55629: LD_VAR 0 2
55633: ARRAY
55634: PUSH
55635: LD_INT 1
55637: ARRAY
55638: PUSH
55639: LD_INT 1
55641: ARRAY
55642: PPUSH
55643: LD_EXP 139
55647: PUSH
55648: LD_VAR 0 2
55652: ARRAY
55653: PUSH
55654: LD_INT 1
55656: ARRAY
55657: PUSH
55658: LD_INT 2
55660: ARRAY
55661: PPUSH
55662: LD_EXP 128
55666: PUSH
55667: LD_VAR 0 2
55671: ARRAY
55672: PPUSH
55673: CALL_OW 440
55677: IFFALSE 55720
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
55679: LD_ADDR_EXP 139
55683: PUSH
55684: LD_EXP 139
55688: PPUSH
55689: LD_VAR 0 2
55693: PPUSH
55694: LD_EXP 139
55698: PUSH
55699: LD_VAR 0 2
55703: ARRAY
55704: PPUSH
55705: LD_INT 1
55707: PPUSH
55708: CALL_OW 3
55712: PPUSH
55713: CALL_OW 1
55717: ST_TO_ADDR
55718: GO 55967
// begin if not mc_deposits_finder [ i ] then
55720: LD_EXP 140
55724: PUSH
55725: LD_VAR 0 2
55729: ARRAY
55730: NOT
55731: IFFALSE 55783
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
55733: LD_ADDR_EXP 140
55737: PUSH
55738: LD_EXP 140
55742: PPUSH
55743: LD_VAR 0 2
55747: PPUSH
55748: LD_VAR 0 3
55752: PUSH
55753: LD_INT 1
55755: ARRAY
55756: PUSH
55757: EMPTY
55758: LIST
55759: PPUSH
55760: CALL_OW 1
55764: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
55765: LD_VAR 0 3
55769: PUSH
55770: LD_INT 1
55772: ARRAY
55773: PPUSH
55774: LD_INT 125
55776: PPUSH
55777: CALL_OW 109
// end else
55781: GO 55967
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
55783: LD_EXP 140
55787: PUSH
55788: LD_VAR 0 2
55792: ARRAY
55793: PUSH
55794: LD_INT 1
55796: ARRAY
55797: PPUSH
55798: CALL_OW 310
55802: IFFALSE 55825
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
55804: LD_EXP 140
55808: PUSH
55809: LD_VAR 0 2
55813: ARRAY
55814: PUSH
55815: LD_INT 1
55817: ARRAY
55818: PPUSH
55819: CALL_OW 122
55823: GO 55967
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
55825: LD_EXP 140
55829: PUSH
55830: LD_VAR 0 2
55834: ARRAY
55835: PUSH
55836: LD_INT 1
55838: ARRAY
55839: PPUSH
55840: CALL_OW 314
55844: NOT
55845: PUSH
55846: LD_EXP 140
55850: PUSH
55851: LD_VAR 0 2
55855: ARRAY
55856: PUSH
55857: LD_INT 1
55859: ARRAY
55860: PPUSH
55861: LD_EXP 139
55865: PUSH
55866: LD_VAR 0 2
55870: ARRAY
55871: PUSH
55872: LD_INT 1
55874: ARRAY
55875: PUSH
55876: LD_INT 1
55878: ARRAY
55879: PPUSH
55880: LD_EXP 139
55884: PUSH
55885: LD_VAR 0 2
55889: ARRAY
55890: PUSH
55891: LD_INT 1
55893: ARRAY
55894: PUSH
55895: LD_INT 2
55897: ARRAY
55898: PPUSH
55899: CALL_OW 297
55903: PUSH
55904: LD_INT 6
55906: GREATER
55907: AND
55908: IFFALSE 55967
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55910: LD_EXP 140
55914: PUSH
55915: LD_VAR 0 2
55919: ARRAY
55920: PUSH
55921: LD_INT 1
55923: ARRAY
55924: PPUSH
55925: LD_EXP 139
55929: PUSH
55930: LD_VAR 0 2
55934: ARRAY
55935: PUSH
55936: LD_INT 1
55938: ARRAY
55939: PUSH
55940: LD_INT 1
55942: ARRAY
55943: PPUSH
55944: LD_EXP 139
55948: PUSH
55949: LD_VAR 0 2
55953: ARRAY
55954: PUSH
55955: LD_INT 1
55957: ARRAY
55958: PUSH
55959: LD_INT 2
55961: ARRAY
55962: PPUSH
55963: CALL_OW 111
// end ; end ; end ;
55967: GO 55380
55969: POP
55970: POP
// end ;
55971: LD_VAR 0 1
55975: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55976: LD_INT 0
55978: PPUSH
55979: PPUSH
55980: PPUSH
55981: PPUSH
55982: PPUSH
55983: PPUSH
55984: PPUSH
55985: PPUSH
55986: PPUSH
55987: PPUSH
55988: PPUSH
// if not mc_bases then
55989: LD_EXP 102
55993: NOT
55994: IFFALSE 55998
// exit ;
55996: GO 56938
// for i = 1 to mc_bases do
55998: LD_ADDR_VAR 0 2
56002: PUSH
56003: DOUBLE
56004: LD_INT 1
56006: DEC
56007: ST_TO_ADDR
56008: LD_EXP 102
56012: PUSH
56013: FOR_TO
56014: IFFALSE 56936
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56016: LD_EXP 102
56020: PUSH
56021: LD_VAR 0 2
56025: ARRAY
56026: NOT
56027: PUSH
56028: LD_EXP 125
56032: PUSH
56033: LD_VAR 0 2
56037: ARRAY
56038: OR
56039: IFFALSE 56043
// continue ;
56041: GO 56013
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56043: LD_ADDR_VAR 0 7
56047: PUSH
56048: LD_EXP 102
56052: PUSH
56053: LD_VAR 0 2
56057: ARRAY
56058: PUSH
56059: LD_INT 1
56061: ARRAY
56062: PPUSH
56063: CALL_OW 248
56067: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56068: LD_VAR 0 7
56072: PUSH
56073: LD_INT 3
56075: EQUAL
56076: PUSH
56077: LD_EXP 121
56081: PUSH
56082: LD_VAR 0 2
56086: ARRAY
56087: PUSH
56088: LD_EXP 124
56092: PUSH
56093: LD_VAR 0 2
56097: ARRAY
56098: UNION
56099: PPUSH
56100: LD_INT 33
56102: PUSH
56103: LD_INT 2
56105: PUSH
56106: EMPTY
56107: LIST
56108: LIST
56109: PPUSH
56110: CALL_OW 72
56114: NOT
56115: OR
56116: IFFALSE 56120
// continue ;
56118: GO 56013
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
56120: LD_ADDR_VAR 0 9
56124: PUSH
56125: LD_EXP 102
56129: PUSH
56130: LD_VAR 0 2
56134: ARRAY
56135: PPUSH
56136: LD_INT 30
56138: PUSH
56139: LD_INT 36
56141: PUSH
56142: EMPTY
56143: LIST
56144: LIST
56145: PPUSH
56146: CALL_OW 72
56150: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
56151: LD_ADDR_VAR 0 10
56155: PUSH
56156: LD_EXP 121
56160: PUSH
56161: LD_VAR 0 2
56165: ARRAY
56166: PPUSH
56167: LD_INT 34
56169: PUSH
56170: LD_INT 31
56172: PUSH
56173: EMPTY
56174: LIST
56175: LIST
56176: PPUSH
56177: CALL_OW 72
56181: ST_TO_ADDR
// if not cts and not mcts then
56182: LD_VAR 0 9
56186: NOT
56187: PUSH
56188: LD_VAR 0 10
56192: NOT
56193: AND
56194: IFFALSE 56198
// continue ;
56196: GO 56013
// x := cts ;
56198: LD_ADDR_VAR 0 11
56202: PUSH
56203: LD_VAR 0 9
56207: ST_TO_ADDR
// if not x then
56208: LD_VAR 0 11
56212: NOT
56213: IFFALSE 56225
// x := mcts ;
56215: LD_ADDR_VAR 0 11
56219: PUSH
56220: LD_VAR 0 10
56224: ST_TO_ADDR
// if not x then
56225: LD_VAR 0 11
56229: NOT
56230: IFFALSE 56234
// continue ;
56232: GO 56013
// if mc_remote_driver [ i ] then
56234: LD_EXP 142
56238: PUSH
56239: LD_VAR 0 2
56243: ARRAY
56244: IFFALSE 56631
// for j in mc_remote_driver [ i ] do
56246: LD_ADDR_VAR 0 3
56250: PUSH
56251: LD_EXP 142
56255: PUSH
56256: LD_VAR 0 2
56260: ARRAY
56261: PUSH
56262: FOR_IN
56263: IFFALSE 56629
// begin if GetClass ( j ) <> 3 then
56265: LD_VAR 0 3
56269: PPUSH
56270: CALL_OW 257
56274: PUSH
56275: LD_INT 3
56277: NONEQUAL
56278: IFFALSE 56331
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
56280: LD_ADDR_EXP 142
56284: PUSH
56285: LD_EXP 142
56289: PPUSH
56290: LD_VAR 0 2
56294: PPUSH
56295: LD_EXP 142
56299: PUSH
56300: LD_VAR 0 2
56304: ARRAY
56305: PUSH
56306: LD_VAR 0 3
56310: DIFF
56311: PPUSH
56312: CALL_OW 1
56316: ST_TO_ADDR
// SetTag ( j , 0 ) ;
56317: LD_VAR 0 3
56321: PPUSH
56322: LD_INT 0
56324: PPUSH
56325: CALL_OW 109
// continue ;
56329: GO 56262
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
56331: LD_EXP 121
56335: PUSH
56336: LD_VAR 0 2
56340: ARRAY
56341: PPUSH
56342: LD_INT 34
56344: PUSH
56345: LD_INT 31
56347: PUSH
56348: EMPTY
56349: LIST
56350: LIST
56351: PUSH
56352: LD_INT 58
56354: PUSH
56355: EMPTY
56356: LIST
56357: PUSH
56358: EMPTY
56359: LIST
56360: LIST
56361: PPUSH
56362: CALL_OW 72
56366: PUSH
56367: LD_VAR 0 3
56371: PPUSH
56372: CALL 105549 0 1
56376: NOT
56377: AND
56378: IFFALSE 56449
// begin if IsInUnit ( j ) then
56380: LD_VAR 0 3
56384: PPUSH
56385: CALL_OW 310
56389: IFFALSE 56400
// ComExitBuilding ( j ) ;
56391: LD_VAR 0 3
56395: PPUSH
56396: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
56400: LD_VAR 0 3
56404: PPUSH
56405: LD_EXP 121
56409: PUSH
56410: LD_VAR 0 2
56414: ARRAY
56415: PPUSH
56416: LD_INT 34
56418: PUSH
56419: LD_INT 31
56421: PUSH
56422: EMPTY
56423: LIST
56424: LIST
56425: PUSH
56426: LD_INT 58
56428: PUSH
56429: EMPTY
56430: LIST
56431: PUSH
56432: EMPTY
56433: LIST
56434: LIST
56435: PPUSH
56436: CALL_OW 72
56440: PUSH
56441: LD_INT 1
56443: ARRAY
56444: PPUSH
56445: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
56449: LD_VAR 0 3
56453: PPUSH
56454: CALL_OW 310
56458: NOT
56459: PUSH
56460: LD_VAR 0 3
56464: PPUSH
56465: CALL_OW 310
56469: PPUSH
56470: CALL_OW 266
56474: PUSH
56475: LD_INT 36
56477: NONEQUAL
56478: PUSH
56479: LD_VAR 0 3
56483: PPUSH
56484: CALL 105549 0 1
56488: NOT
56489: AND
56490: OR
56491: IFFALSE 56627
// begin if IsInUnit ( j ) then
56493: LD_VAR 0 3
56497: PPUSH
56498: CALL_OW 310
56502: IFFALSE 56513
// ComExitBuilding ( j ) ;
56504: LD_VAR 0 3
56508: PPUSH
56509: CALL_OW 122
// ct := 0 ;
56513: LD_ADDR_VAR 0 8
56517: PUSH
56518: LD_INT 0
56520: ST_TO_ADDR
// for k in x do
56521: LD_ADDR_VAR 0 4
56525: PUSH
56526: LD_VAR 0 11
56530: PUSH
56531: FOR_IN
56532: IFFALSE 56605
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
56534: LD_VAR 0 4
56538: PPUSH
56539: CALL_OW 264
56543: PUSH
56544: LD_INT 31
56546: EQUAL
56547: PUSH
56548: LD_VAR 0 4
56552: PPUSH
56553: CALL_OW 311
56557: NOT
56558: AND
56559: PUSH
56560: LD_VAR 0 4
56564: PPUSH
56565: CALL_OW 266
56569: PUSH
56570: LD_INT 36
56572: EQUAL
56573: PUSH
56574: LD_VAR 0 4
56578: PPUSH
56579: CALL_OW 313
56583: PUSH
56584: LD_INT 3
56586: LESS
56587: AND
56588: OR
56589: IFFALSE 56603
// begin ct := k ;
56591: LD_ADDR_VAR 0 8
56595: PUSH
56596: LD_VAR 0 4
56600: ST_TO_ADDR
// break ;
56601: GO 56605
// end ;
56603: GO 56531
56605: POP
56606: POP
// if ct then
56607: LD_VAR 0 8
56611: IFFALSE 56627
// ComEnterUnit ( j , ct ) ;
56613: LD_VAR 0 3
56617: PPUSH
56618: LD_VAR 0 8
56622: PPUSH
56623: CALL_OW 120
// end ; end ;
56627: GO 56262
56629: POP
56630: POP
// places := 0 ;
56631: LD_ADDR_VAR 0 5
56635: PUSH
56636: LD_INT 0
56638: ST_TO_ADDR
// for j = 1 to x do
56639: LD_ADDR_VAR 0 3
56643: PUSH
56644: DOUBLE
56645: LD_INT 1
56647: DEC
56648: ST_TO_ADDR
56649: LD_VAR 0 11
56653: PUSH
56654: FOR_TO
56655: IFFALSE 56731
// if GetWeapon ( x [ j ] ) = ar_control_tower then
56657: LD_VAR 0 11
56661: PUSH
56662: LD_VAR 0 3
56666: ARRAY
56667: PPUSH
56668: CALL_OW 264
56672: PUSH
56673: LD_INT 31
56675: EQUAL
56676: IFFALSE 56694
// places := places + 1 else
56678: LD_ADDR_VAR 0 5
56682: PUSH
56683: LD_VAR 0 5
56687: PUSH
56688: LD_INT 1
56690: PLUS
56691: ST_TO_ADDR
56692: GO 56729
// if GetBType ( x [ j ] ) = b_control_tower then
56694: LD_VAR 0 11
56698: PUSH
56699: LD_VAR 0 3
56703: ARRAY
56704: PPUSH
56705: CALL_OW 266
56709: PUSH
56710: LD_INT 36
56712: EQUAL
56713: IFFALSE 56729
// places := places + 3 ;
56715: LD_ADDR_VAR 0 5
56719: PUSH
56720: LD_VAR 0 5
56724: PUSH
56725: LD_INT 3
56727: PLUS
56728: ST_TO_ADDR
56729: GO 56654
56731: POP
56732: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
56733: LD_VAR 0 5
56737: PUSH
56738: LD_INT 0
56740: EQUAL
56741: PUSH
56742: LD_VAR 0 5
56746: PUSH
56747: LD_EXP 142
56751: PUSH
56752: LD_VAR 0 2
56756: ARRAY
56757: LESSEQUAL
56758: OR
56759: IFFALSE 56763
// continue ;
56761: GO 56013
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
56763: LD_ADDR_VAR 0 6
56767: PUSH
56768: LD_EXP 102
56772: PUSH
56773: LD_VAR 0 2
56777: ARRAY
56778: PPUSH
56779: LD_INT 25
56781: PUSH
56782: LD_INT 3
56784: PUSH
56785: EMPTY
56786: LIST
56787: LIST
56788: PPUSH
56789: CALL_OW 72
56793: PUSH
56794: LD_EXP 142
56798: PUSH
56799: LD_VAR 0 2
56803: ARRAY
56804: DIFF
56805: PPUSH
56806: LD_INT 3
56808: PPUSH
56809: CALL 106449 0 2
56813: ST_TO_ADDR
// for j in tmp do
56814: LD_ADDR_VAR 0 3
56818: PUSH
56819: LD_VAR 0 6
56823: PUSH
56824: FOR_IN
56825: IFFALSE 56860
// if GetTag ( j ) > 0 then
56827: LD_VAR 0 3
56831: PPUSH
56832: CALL_OW 110
56836: PUSH
56837: LD_INT 0
56839: GREATER
56840: IFFALSE 56858
// tmp := tmp diff j ;
56842: LD_ADDR_VAR 0 6
56846: PUSH
56847: LD_VAR 0 6
56851: PUSH
56852: LD_VAR 0 3
56856: DIFF
56857: ST_TO_ADDR
56858: GO 56824
56860: POP
56861: POP
// if not tmp then
56862: LD_VAR 0 6
56866: NOT
56867: IFFALSE 56871
// continue ;
56869: GO 56013
// if places then
56871: LD_VAR 0 5
56875: IFFALSE 56934
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56877: LD_ADDR_EXP 142
56881: PUSH
56882: LD_EXP 142
56886: PPUSH
56887: LD_VAR 0 2
56891: PPUSH
56892: LD_EXP 142
56896: PUSH
56897: LD_VAR 0 2
56901: ARRAY
56902: PUSH
56903: LD_VAR 0 6
56907: PUSH
56908: LD_INT 1
56910: ARRAY
56911: UNION
56912: PPUSH
56913: CALL_OW 1
56917: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56918: LD_VAR 0 6
56922: PUSH
56923: LD_INT 1
56925: ARRAY
56926: PPUSH
56927: LD_INT 126
56929: PPUSH
56930: CALL_OW 109
// end ; end ;
56934: GO 56013
56936: POP
56937: POP
// end ;
56938: LD_VAR 0 1
56942: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56943: LD_INT 0
56945: PPUSH
56946: PPUSH
56947: PPUSH
56948: PPUSH
56949: PPUSH
56950: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56951: LD_VAR 0 1
56955: NOT
56956: PUSH
56957: LD_VAR 0 2
56961: NOT
56962: OR
56963: PUSH
56964: LD_VAR 0 3
56968: NOT
56969: OR
56970: PUSH
56971: LD_VAR 0 4
56975: PUSH
56976: LD_INT 1
56978: PUSH
56979: LD_INT 2
56981: PUSH
56982: LD_INT 3
56984: PUSH
56985: LD_INT 4
56987: PUSH
56988: LD_INT 5
56990: PUSH
56991: LD_INT 8
56993: PUSH
56994: LD_INT 9
56996: PUSH
56997: LD_INT 15
56999: PUSH
57000: LD_INT 16
57002: PUSH
57003: EMPTY
57004: LIST
57005: LIST
57006: LIST
57007: LIST
57008: LIST
57009: LIST
57010: LIST
57011: LIST
57012: LIST
57013: IN
57014: NOT
57015: OR
57016: IFFALSE 57020
// exit ;
57018: GO 57920
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57020: LD_ADDR_VAR 0 2
57024: PUSH
57025: LD_VAR 0 2
57029: PPUSH
57030: LD_INT 21
57032: PUSH
57033: LD_INT 3
57035: PUSH
57036: EMPTY
57037: LIST
57038: LIST
57039: PUSH
57040: LD_INT 24
57042: PUSH
57043: LD_INT 250
57045: PUSH
57046: EMPTY
57047: LIST
57048: LIST
57049: PUSH
57050: EMPTY
57051: LIST
57052: LIST
57053: PPUSH
57054: CALL_OW 72
57058: ST_TO_ADDR
// case class of 1 , 15 :
57059: LD_VAR 0 4
57063: PUSH
57064: LD_INT 1
57066: DOUBLE
57067: EQUAL
57068: IFTRUE 57078
57070: LD_INT 15
57072: DOUBLE
57073: EQUAL
57074: IFTRUE 57078
57076: GO 57163
57078: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
57079: LD_ADDR_VAR 0 8
57083: PUSH
57084: LD_VAR 0 2
57088: PPUSH
57089: LD_INT 2
57091: PUSH
57092: LD_INT 30
57094: PUSH
57095: LD_INT 32
57097: PUSH
57098: EMPTY
57099: LIST
57100: LIST
57101: PUSH
57102: LD_INT 30
57104: PUSH
57105: LD_INT 31
57107: PUSH
57108: EMPTY
57109: LIST
57110: LIST
57111: PUSH
57112: EMPTY
57113: LIST
57114: LIST
57115: LIST
57116: PPUSH
57117: CALL_OW 72
57121: PUSH
57122: LD_VAR 0 2
57126: PPUSH
57127: LD_INT 2
57129: PUSH
57130: LD_INT 30
57132: PUSH
57133: LD_INT 4
57135: PUSH
57136: EMPTY
57137: LIST
57138: LIST
57139: PUSH
57140: LD_INT 30
57142: PUSH
57143: LD_INT 5
57145: PUSH
57146: EMPTY
57147: LIST
57148: LIST
57149: PUSH
57150: EMPTY
57151: LIST
57152: LIST
57153: LIST
57154: PPUSH
57155: CALL_OW 72
57159: ADD
57160: ST_TO_ADDR
57161: GO 57409
57163: LD_INT 2
57165: DOUBLE
57166: EQUAL
57167: IFTRUE 57177
57169: LD_INT 16
57171: DOUBLE
57172: EQUAL
57173: IFTRUE 57177
57175: GO 57223
57177: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
57178: LD_ADDR_VAR 0 8
57182: PUSH
57183: LD_VAR 0 2
57187: PPUSH
57188: LD_INT 2
57190: PUSH
57191: LD_INT 30
57193: PUSH
57194: LD_INT 0
57196: PUSH
57197: EMPTY
57198: LIST
57199: LIST
57200: PUSH
57201: LD_INT 30
57203: PUSH
57204: LD_INT 1
57206: PUSH
57207: EMPTY
57208: LIST
57209: LIST
57210: PUSH
57211: EMPTY
57212: LIST
57213: LIST
57214: LIST
57215: PPUSH
57216: CALL_OW 72
57220: ST_TO_ADDR
57221: GO 57409
57223: LD_INT 3
57225: DOUBLE
57226: EQUAL
57227: IFTRUE 57231
57229: GO 57277
57231: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
57232: LD_ADDR_VAR 0 8
57236: PUSH
57237: LD_VAR 0 2
57241: PPUSH
57242: LD_INT 2
57244: PUSH
57245: LD_INT 30
57247: PUSH
57248: LD_INT 2
57250: PUSH
57251: EMPTY
57252: LIST
57253: LIST
57254: PUSH
57255: LD_INT 30
57257: PUSH
57258: LD_INT 3
57260: PUSH
57261: EMPTY
57262: LIST
57263: LIST
57264: PUSH
57265: EMPTY
57266: LIST
57267: LIST
57268: LIST
57269: PPUSH
57270: CALL_OW 72
57274: ST_TO_ADDR
57275: GO 57409
57277: LD_INT 4
57279: DOUBLE
57280: EQUAL
57281: IFTRUE 57285
57283: GO 57342
57285: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
57286: LD_ADDR_VAR 0 8
57290: PUSH
57291: LD_VAR 0 2
57295: PPUSH
57296: LD_INT 2
57298: PUSH
57299: LD_INT 30
57301: PUSH
57302: LD_INT 6
57304: PUSH
57305: EMPTY
57306: LIST
57307: LIST
57308: PUSH
57309: LD_INT 30
57311: PUSH
57312: LD_INT 7
57314: PUSH
57315: EMPTY
57316: LIST
57317: LIST
57318: PUSH
57319: LD_INT 30
57321: PUSH
57322: LD_INT 8
57324: PUSH
57325: EMPTY
57326: LIST
57327: LIST
57328: PUSH
57329: EMPTY
57330: LIST
57331: LIST
57332: LIST
57333: LIST
57334: PPUSH
57335: CALL_OW 72
57339: ST_TO_ADDR
57340: GO 57409
57342: LD_INT 5
57344: DOUBLE
57345: EQUAL
57346: IFTRUE 57362
57348: LD_INT 8
57350: DOUBLE
57351: EQUAL
57352: IFTRUE 57362
57354: LD_INT 9
57356: DOUBLE
57357: EQUAL
57358: IFTRUE 57362
57360: GO 57408
57362: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
57363: LD_ADDR_VAR 0 8
57367: PUSH
57368: LD_VAR 0 2
57372: PPUSH
57373: LD_INT 2
57375: PUSH
57376: LD_INT 30
57378: PUSH
57379: LD_INT 4
57381: PUSH
57382: EMPTY
57383: LIST
57384: LIST
57385: PUSH
57386: LD_INT 30
57388: PUSH
57389: LD_INT 5
57391: PUSH
57392: EMPTY
57393: LIST
57394: LIST
57395: PUSH
57396: EMPTY
57397: LIST
57398: LIST
57399: LIST
57400: PPUSH
57401: CALL_OW 72
57405: ST_TO_ADDR
57406: GO 57409
57408: POP
// if not tmp then
57409: LD_VAR 0 8
57413: NOT
57414: IFFALSE 57418
// exit ;
57416: GO 57920
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
57418: LD_VAR 0 4
57422: PUSH
57423: LD_INT 1
57425: PUSH
57426: LD_INT 15
57428: PUSH
57429: EMPTY
57430: LIST
57431: LIST
57432: IN
57433: PUSH
57434: LD_EXP 111
57438: PUSH
57439: LD_VAR 0 1
57443: ARRAY
57444: AND
57445: IFFALSE 57601
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
57447: LD_ADDR_VAR 0 9
57451: PUSH
57452: LD_EXP 111
57456: PUSH
57457: LD_VAR 0 1
57461: ARRAY
57462: PUSH
57463: LD_INT 1
57465: ARRAY
57466: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
57467: LD_VAR 0 9
57471: PUSH
57472: LD_EXP 112
57476: PUSH
57477: LD_VAR 0 1
57481: ARRAY
57482: IN
57483: NOT
57484: IFFALSE 57599
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
57486: LD_ADDR_EXP 112
57490: PUSH
57491: LD_EXP 112
57495: PPUSH
57496: LD_VAR 0 1
57500: PUSH
57501: LD_EXP 112
57505: PUSH
57506: LD_VAR 0 1
57510: ARRAY
57511: PUSH
57512: LD_INT 1
57514: PLUS
57515: PUSH
57516: EMPTY
57517: LIST
57518: LIST
57519: PPUSH
57520: LD_VAR 0 9
57524: PPUSH
57525: CALL 72191 0 3
57529: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
57530: LD_ADDR_EXP 111
57534: PUSH
57535: LD_EXP 111
57539: PPUSH
57540: LD_VAR 0 1
57544: PPUSH
57545: LD_EXP 111
57549: PUSH
57550: LD_VAR 0 1
57554: ARRAY
57555: PUSH
57556: LD_VAR 0 9
57560: DIFF
57561: PPUSH
57562: CALL_OW 1
57566: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
57567: LD_VAR 0 3
57571: PPUSH
57572: LD_EXP 112
57576: PUSH
57577: LD_VAR 0 1
57581: ARRAY
57582: PUSH
57583: LD_EXP 112
57587: PUSH
57588: LD_VAR 0 1
57592: ARRAY
57593: ARRAY
57594: PPUSH
57595: CALL_OW 120
// end ; exit ;
57599: GO 57920
// end ; if tmp > 1 then
57601: LD_VAR 0 8
57605: PUSH
57606: LD_INT 1
57608: GREATER
57609: IFFALSE 57713
// for i = 2 to tmp do
57611: LD_ADDR_VAR 0 6
57615: PUSH
57616: DOUBLE
57617: LD_INT 2
57619: DEC
57620: ST_TO_ADDR
57621: LD_VAR 0 8
57625: PUSH
57626: FOR_TO
57627: IFFALSE 57711
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
57629: LD_VAR 0 8
57633: PUSH
57634: LD_VAR 0 6
57638: ARRAY
57639: PPUSH
57640: CALL_OW 461
57644: PUSH
57645: LD_INT 6
57647: EQUAL
57648: IFFALSE 57709
// begin x := tmp [ i ] ;
57650: LD_ADDR_VAR 0 9
57654: PUSH
57655: LD_VAR 0 8
57659: PUSH
57660: LD_VAR 0 6
57664: ARRAY
57665: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
57666: LD_ADDR_VAR 0 8
57670: PUSH
57671: LD_VAR 0 8
57675: PPUSH
57676: LD_VAR 0 6
57680: PPUSH
57681: CALL_OW 3
57685: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
57686: LD_ADDR_VAR 0 8
57690: PUSH
57691: LD_VAR 0 8
57695: PPUSH
57696: LD_INT 1
57698: PPUSH
57699: LD_VAR 0 9
57703: PPUSH
57704: CALL_OW 2
57708: ST_TO_ADDR
// end ;
57709: GO 57626
57711: POP
57712: POP
// for i in tmp do
57713: LD_ADDR_VAR 0 6
57717: PUSH
57718: LD_VAR 0 8
57722: PUSH
57723: FOR_IN
57724: IFFALSE 57793
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
57726: LD_VAR 0 6
57730: PPUSH
57731: CALL_OW 313
57735: PUSH
57736: LD_INT 6
57738: LESS
57739: PUSH
57740: LD_VAR 0 6
57744: PPUSH
57745: CALL_OW 266
57749: PUSH
57750: LD_INT 31
57752: PUSH
57753: LD_INT 32
57755: PUSH
57756: EMPTY
57757: LIST
57758: LIST
57759: IN
57760: NOT
57761: AND
57762: PUSH
57763: LD_VAR 0 6
57767: PPUSH
57768: CALL_OW 313
57772: PUSH
57773: LD_INT 0
57775: EQUAL
57776: OR
57777: IFFALSE 57791
// begin j := i ;
57779: LD_ADDR_VAR 0 7
57783: PUSH
57784: LD_VAR 0 6
57788: ST_TO_ADDR
// break ;
57789: GO 57793
// end ; end ;
57791: GO 57723
57793: POP
57794: POP
// if j then
57795: LD_VAR 0 7
57799: IFFALSE 57817
// ComEnterUnit ( unit , j ) else
57801: LD_VAR 0 3
57805: PPUSH
57806: LD_VAR 0 7
57810: PPUSH
57811: CALL_OW 120
57815: GO 57920
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
57817: LD_ADDR_VAR 0 10
57821: PUSH
57822: LD_VAR 0 2
57826: PPUSH
57827: LD_INT 2
57829: PUSH
57830: LD_INT 30
57832: PUSH
57833: LD_INT 0
57835: PUSH
57836: EMPTY
57837: LIST
57838: LIST
57839: PUSH
57840: LD_INT 30
57842: PUSH
57843: LD_INT 1
57845: PUSH
57846: EMPTY
57847: LIST
57848: LIST
57849: PUSH
57850: EMPTY
57851: LIST
57852: LIST
57853: LIST
57854: PPUSH
57855: CALL_OW 72
57859: ST_TO_ADDR
// if depot then
57860: LD_VAR 0 10
57864: IFFALSE 57920
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57866: LD_ADDR_VAR 0 10
57870: PUSH
57871: LD_VAR 0 10
57875: PPUSH
57876: LD_VAR 0 3
57880: PPUSH
57881: CALL_OW 74
57885: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57886: LD_VAR 0 3
57890: PPUSH
57891: LD_VAR 0 10
57895: PPUSH
57896: CALL_OW 296
57900: PUSH
57901: LD_INT 10
57903: GREATER
57904: IFFALSE 57920
// ComStandNearbyBuilding ( unit , depot ) ;
57906: LD_VAR 0 3
57910: PPUSH
57911: LD_VAR 0 10
57915: PPUSH
57916: CALL 66394 0 2
// end ; end ; end ;
57920: LD_VAR 0 5
57924: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57925: LD_INT 0
57927: PPUSH
57928: PPUSH
57929: PPUSH
57930: PPUSH
// if not mc_bases then
57931: LD_EXP 102
57935: NOT
57936: IFFALSE 57940
// exit ;
57938: GO 58179
// for i = 1 to mc_bases do
57940: LD_ADDR_VAR 0 2
57944: PUSH
57945: DOUBLE
57946: LD_INT 1
57948: DEC
57949: ST_TO_ADDR
57950: LD_EXP 102
57954: PUSH
57955: FOR_TO
57956: IFFALSE 58177
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57958: LD_ADDR_VAR 0 4
57962: PUSH
57963: LD_EXP 102
57967: PUSH
57968: LD_VAR 0 2
57972: ARRAY
57973: PPUSH
57974: LD_INT 21
57976: PUSH
57977: LD_INT 1
57979: PUSH
57980: EMPTY
57981: LIST
57982: LIST
57983: PPUSH
57984: CALL_OW 72
57988: PUSH
57989: LD_EXP 131
57993: PUSH
57994: LD_VAR 0 2
57998: ARRAY
57999: UNION
58000: ST_TO_ADDR
// if not tmp then
58001: LD_VAR 0 4
58005: NOT
58006: IFFALSE 58010
// continue ;
58008: GO 57955
// for j in tmp do
58010: LD_ADDR_VAR 0 3
58014: PUSH
58015: LD_VAR 0 4
58019: PUSH
58020: FOR_IN
58021: IFFALSE 58173
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58023: LD_VAR 0 3
58027: PPUSH
58028: CALL_OW 110
58032: NOT
58033: PUSH
58034: LD_VAR 0 3
58038: PPUSH
58039: CALL_OW 314
58043: NOT
58044: AND
58045: PUSH
58046: LD_VAR 0 3
58050: PPUSH
58051: CALL_OW 311
58055: NOT
58056: AND
58057: PUSH
58058: LD_VAR 0 3
58062: PPUSH
58063: CALL_OW 310
58067: NOT
58068: AND
58069: PUSH
58070: LD_VAR 0 3
58074: PUSH
58075: LD_EXP 105
58079: PUSH
58080: LD_VAR 0 2
58084: ARRAY
58085: PUSH
58086: LD_INT 1
58088: ARRAY
58089: IN
58090: NOT
58091: AND
58092: PUSH
58093: LD_VAR 0 3
58097: PUSH
58098: LD_EXP 105
58102: PUSH
58103: LD_VAR 0 2
58107: ARRAY
58108: PUSH
58109: LD_INT 2
58111: ARRAY
58112: IN
58113: NOT
58114: AND
58115: PUSH
58116: LD_VAR 0 3
58120: PUSH
58121: LD_EXP 114
58125: PUSH
58126: LD_VAR 0 2
58130: ARRAY
58131: IN
58132: NOT
58133: AND
58134: IFFALSE 58171
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
58136: LD_VAR 0 2
58140: PPUSH
58141: LD_EXP 102
58145: PUSH
58146: LD_VAR 0 2
58150: ARRAY
58151: PPUSH
58152: LD_VAR 0 3
58156: PPUSH
58157: LD_VAR 0 3
58161: PPUSH
58162: CALL_OW 257
58166: PPUSH
58167: CALL 56943 0 4
// end ;
58171: GO 58020
58173: POP
58174: POP
// end ;
58175: GO 57955
58177: POP
58178: POP
// end ;
58179: LD_VAR 0 1
58183: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
58184: LD_INT 0
58186: PPUSH
58187: PPUSH
58188: PPUSH
58189: PPUSH
58190: PPUSH
58191: PPUSH
// if not mc_bases [ base ] then
58192: LD_EXP 102
58196: PUSH
58197: LD_VAR 0 1
58201: ARRAY
58202: NOT
58203: IFFALSE 58207
// exit ;
58205: GO 58389
// tmp := [ ] ;
58207: LD_ADDR_VAR 0 6
58211: PUSH
58212: EMPTY
58213: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
58214: LD_ADDR_VAR 0 7
58218: PUSH
58219: LD_VAR 0 3
58223: PPUSH
58224: LD_INT 0
58226: PPUSH
58227: CALL_OW 517
58231: ST_TO_ADDR
// if not list then
58232: LD_VAR 0 7
58236: NOT
58237: IFFALSE 58241
// exit ;
58239: GO 58389
// for i = 1 to amount do
58241: LD_ADDR_VAR 0 5
58245: PUSH
58246: DOUBLE
58247: LD_INT 1
58249: DEC
58250: ST_TO_ADDR
58251: LD_VAR 0 2
58255: PUSH
58256: FOR_TO
58257: IFFALSE 58337
// begin x := rand ( 1 , list [ 1 ] ) ;
58259: LD_ADDR_VAR 0 8
58263: PUSH
58264: LD_INT 1
58266: PPUSH
58267: LD_VAR 0 7
58271: PUSH
58272: LD_INT 1
58274: ARRAY
58275: PPUSH
58276: CALL_OW 12
58280: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
58281: LD_ADDR_VAR 0 6
58285: PUSH
58286: LD_VAR 0 6
58290: PPUSH
58291: LD_VAR 0 5
58295: PPUSH
58296: LD_VAR 0 7
58300: PUSH
58301: LD_INT 1
58303: ARRAY
58304: PUSH
58305: LD_VAR 0 8
58309: ARRAY
58310: PUSH
58311: LD_VAR 0 7
58315: PUSH
58316: LD_INT 2
58318: ARRAY
58319: PUSH
58320: LD_VAR 0 8
58324: ARRAY
58325: PUSH
58326: EMPTY
58327: LIST
58328: LIST
58329: PPUSH
58330: CALL_OW 1
58334: ST_TO_ADDR
// end ;
58335: GO 58256
58337: POP
58338: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
58339: LD_ADDR_EXP 115
58343: PUSH
58344: LD_EXP 115
58348: PPUSH
58349: LD_VAR 0 1
58353: PPUSH
58354: LD_VAR 0 6
58358: PPUSH
58359: CALL_OW 1
58363: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
58364: LD_ADDR_EXP 117
58368: PUSH
58369: LD_EXP 117
58373: PPUSH
58374: LD_VAR 0 1
58378: PPUSH
58379: LD_VAR 0 3
58383: PPUSH
58384: CALL_OW 1
58388: ST_TO_ADDR
// end ;
58389: LD_VAR 0 4
58393: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
58394: LD_INT 0
58396: PPUSH
// if not mc_bases [ base ] then
58397: LD_EXP 102
58401: PUSH
58402: LD_VAR 0 1
58406: ARRAY
58407: NOT
58408: IFFALSE 58412
// exit ;
58410: GO 58437
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
58412: LD_ADDR_EXP 107
58416: PUSH
58417: LD_EXP 107
58421: PPUSH
58422: LD_VAR 0 1
58426: PPUSH
58427: LD_VAR 0 2
58431: PPUSH
58432: CALL_OW 1
58436: ST_TO_ADDR
// end ;
58437: LD_VAR 0 3
58441: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
58442: LD_INT 0
58444: PPUSH
// if not mc_bases [ base ] then
58445: LD_EXP 102
58449: PUSH
58450: LD_VAR 0 1
58454: ARRAY
58455: NOT
58456: IFFALSE 58460
// exit ;
58458: GO 58497
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
58460: LD_ADDR_EXP 107
58464: PUSH
58465: LD_EXP 107
58469: PPUSH
58470: LD_VAR 0 1
58474: PPUSH
58475: LD_EXP 107
58479: PUSH
58480: LD_VAR 0 1
58484: ARRAY
58485: PUSH
58486: LD_VAR 0 2
58490: UNION
58491: PPUSH
58492: CALL_OW 1
58496: ST_TO_ADDR
// end ;
58497: LD_VAR 0 3
58501: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
58502: LD_INT 0
58504: PPUSH
// if not mc_bases [ base ] then
58505: LD_EXP 102
58509: PUSH
58510: LD_VAR 0 1
58514: ARRAY
58515: NOT
58516: IFFALSE 58520
// exit ;
58518: GO 58545
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
58520: LD_ADDR_EXP 123
58524: PUSH
58525: LD_EXP 123
58529: PPUSH
58530: LD_VAR 0 1
58534: PPUSH
58535: LD_VAR 0 2
58539: PPUSH
58540: CALL_OW 1
58544: ST_TO_ADDR
// end ;
58545: LD_VAR 0 3
58549: RET
// export function MC_InsertProduceList ( base , components ) ; begin
58550: LD_INT 0
58552: PPUSH
// if not mc_bases [ base ] then
58553: LD_EXP 102
58557: PUSH
58558: LD_VAR 0 1
58562: ARRAY
58563: NOT
58564: IFFALSE 58568
// exit ;
58566: GO 58605
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
58568: LD_ADDR_EXP 123
58572: PUSH
58573: LD_EXP 123
58577: PPUSH
58578: LD_VAR 0 1
58582: PPUSH
58583: LD_EXP 123
58587: PUSH
58588: LD_VAR 0 1
58592: ARRAY
58593: PUSH
58594: LD_VAR 0 2
58598: ADD
58599: PPUSH
58600: CALL_OW 1
58604: ST_TO_ADDR
// end ;
58605: LD_VAR 0 3
58609: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
58610: LD_INT 0
58612: PPUSH
// if not mc_bases [ base ] then
58613: LD_EXP 102
58617: PUSH
58618: LD_VAR 0 1
58622: ARRAY
58623: NOT
58624: IFFALSE 58628
// exit ;
58626: GO 58682
// mc_defender := Replace ( mc_defender , base , deflist ) ;
58628: LD_ADDR_EXP 124
58632: PUSH
58633: LD_EXP 124
58637: PPUSH
58638: LD_VAR 0 1
58642: PPUSH
58643: LD_VAR 0 2
58647: PPUSH
58648: CALL_OW 1
58652: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
58653: LD_ADDR_EXP 113
58657: PUSH
58658: LD_EXP 113
58662: PPUSH
58663: LD_VAR 0 1
58667: PPUSH
58668: LD_VAR 0 2
58672: PUSH
58673: LD_INT 0
58675: PLUS
58676: PPUSH
58677: CALL_OW 1
58681: ST_TO_ADDR
// end ;
58682: LD_VAR 0 3
58686: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
58687: LD_INT 0
58689: PPUSH
// if not mc_bases [ base ] then
58690: LD_EXP 102
58694: PUSH
58695: LD_VAR 0 1
58699: ARRAY
58700: NOT
58701: IFFALSE 58705
// exit ;
58703: GO 58730
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
58705: LD_ADDR_EXP 113
58709: PUSH
58710: LD_EXP 113
58714: PPUSH
58715: LD_VAR 0 1
58719: PPUSH
58720: LD_VAR 0 2
58724: PPUSH
58725: CALL_OW 1
58729: ST_TO_ADDR
// end ;
58730: LD_VAR 0 3
58734: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
58735: LD_INT 0
58737: PPUSH
58738: PPUSH
58739: PPUSH
58740: PPUSH
// if not mc_bases [ base ] then
58741: LD_EXP 102
58745: PUSH
58746: LD_VAR 0 1
58750: ARRAY
58751: NOT
58752: IFFALSE 58756
// exit ;
58754: GO 58821
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
58756: LD_ADDR_EXP 122
58760: PUSH
58761: LD_EXP 122
58765: PPUSH
58766: LD_VAR 0 1
58770: PUSH
58771: LD_EXP 122
58775: PUSH
58776: LD_VAR 0 1
58780: ARRAY
58781: PUSH
58782: LD_INT 1
58784: PLUS
58785: PUSH
58786: EMPTY
58787: LIST
58788: LIST
58789: PPUSH
58790: LD_VAR 0 1
58794: PUSH
58795: LD_VAR 0 2
58799: PUSH
58800: LD_VAR 0 3
58804: PUSH
58805: LD_VAR 0 4
58809: PUSH
58810: EMPTY
58811: LIST
58812: LIST
58813: LIST
58814: LIST
58815: PPUSH
58816: CALL 72191 0 3
58820: ST_TO_ADDR
// end ;
58821: LD_VAR 0 5
58825: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
58826: LD_INT 0
58828: PPUSH
// if not mc_bases [ base ] then
58829: LD_EXP 102
58833: PUSH
58834: LD_VAR 0 1
58838: ARRAY
58839: NOT
58840: IFFALSE 58844
// exit ;
58842: GO 58869
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58844: LD_ADDR_EXP 139
58848: PUSH
58849: LD_EXP 139
58853: PPUSH
58854: LD_VAR 0 1
58858: PPUSH
58859: LD_VAR 0 2
58863: PPUSH
58864: CALL_OW 1
58868: ST_TO_ADDR
// end ;
58869: LD_VAR 0 3
58873: RET
// export function MC_GetMinesField ( base ) ; begin
58874: LD_INT 0
58876: PPUSH
// result := mc_mines [ base ] ;
58877: LD_ADDR_VAR 0 2
58881: PUSH
58882: LD_EXP 115
58886: PUSH
58887: LD_VAR 0 1
58891: ARRAY
58892: ST_TO_ADDR
// end ;
58893: LD_VAR 0 2
58897: RET
// export function MC_GetProduceList ( base ) ; begin
58898: LD_INT 0
58900: PPUSH
// result := mc_produce [ base ] ;
58901: LD_ADDR_VAR 0 2
58905: PUSH
58906: LD_EXP 123
58910: PUSH
58911: LD_VAR 0 1
58915: ARRAY
58916: ST_TO_ADDR
// end ;
58917: LD_VAR 0 2
58921: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58922: LD_INT 0
58924: PPUSH
58925: PPUSH
// if not mc_bases then
58926: LD_EXP 102
58930: NOT
58931: IFFALSE 58935
// exit ;
58933: GO 59000
// if mc_bases [ base ] then
58935: LD_EXP 102
58939: PUSH
58940: LD_VAR 0 1
58944: ARRAY
58945: IFFALSE 59000
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58947: LD_ADDR_VAR 0 3
58951: PUSH
58952: LD_EXP 102
58956: PUSH
58957: LD_VAR 0 1
58961: ARRAY
58962: PPUSH
58963: LD_INT 30
58965: PUSH
58966: LD_VAR 0 2
58970: PUSH
58971: EMPTY
58972: LIST
58973: LIST
58974: PPUSH
58975: CALL_OW 72
58979: ST_TO_ADDR
// if result then
58980: LD_VAR 0 3
58984: IFFALSE 59000
// result := result [ 1 ] ;
58986: LD_ADDR_VAR 0 3
58990: PUSH
58991: LD_VAR 0 3
58995: PUSH
58996: LD_INT 1
58998: ARRAY
58999: ST_TO_ADDR
// end ; end ;
59000: LD_VAR 0 3
59004: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59005: LD_INT 0
59007: PPUSH
59008: PPUSH
// if not mc_bases then
59009: LD_EXP 102
59013: NOT
59014: IFFALSE 59018
// exit ;
59016: GO 59063
// if mc_bases [ base ] then
59018: LD_EXP 102
59022: PUSH
59023: LD_VAR 0 1
59027: ARRAY
59028: IFFALSE 59063
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59030: LD_ADDR_VAR 0 3
59034: PUSH
59035: LD_EXP 102
59039: PUSH
59040: LD_VAR 0 1
59044: ARRAY
59045: PPUSH
59046: LD_INT 30
59048: PUSH
59049: LD_VAR 0 2
59053: PUSH
59054: EMPTY
59055: LIST
59056: LIST
59057: PPUSH
59058: CALL_OW 72
59062: ST_TO_ADDR
// end ;
59063: LD_VAR 0 3
59067: RET
// export function MC_SetTame ( base , area ) ; begin
59068: LD_INT 0
59070: PPUSH
// if not mc_bases or not base then
59071: LD_EXP 102
59075: NOT
59076: PUSH
59077: LD_VAR 0 1
59081: NOT
59082: OR
59083: IFFALSE 59087
// exit ;
59085: GO 59112
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
59087: LD_ADDR_EXP 130
59091: PUSH
59092: LD_EXP 130
59096: PPUSH
59097: LD_VAR 0 1
59101: PPUSH
59102: LD_VAR 0 2
59106: PPUSH
59107: CALL_OW 1
59111: ST_TO_ADDR
// end ;
59112: LD_VAR 0 3
59116: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
59117: LD_INT 0
59119: PPUSH
59120: PPUSH
// if not mc_bases or not base then
59121: LD_EXP 102
59125: NOT
59126: PUSH
59127: LD_VAR 0 1
59131: NOT
59132: OR
59133: IFFALSE 59137
// exit ;
59135: GO 59239
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59137: LD_ADDR_VAR 0 4
59141: PUSH
59142: LD_EXP 102
59146: PUSH
59147: LD_VAR 0 1
59151: ARRAY
59152: PPUSH
59153: LD_INT 30
59155: PUSH
59156: LD_VAR 0 2
59160: PUSH
59161: EMPTY
59162: LIST
59163: LIST
59164: PPUSH
59165: CALL_OW 72
59169: ST_TO_ADDR
// if not tmp then
59170: LD_VAR 0 4
59174: NOT
59175: IFFALSE 59179
// exit ;
59177: GO 59239
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
59179: LD_ADDR_EXP 134
59183: PUSH
59184: LD_EXP 134
59188: PPUSH
59189: LD_VAR 0 1
59193: PPUSH
59194: LD_EXP 134
59198: PUSH
59199: LD_VAR 0 1
59203: ARRAY
59204: PPUSH
59205: LD_EXP 134
59209: PUSH
59210: LD_VAR 0 1
59214: ARRAY
59215: PUSH
59216: LD_INT 1
59218: PLUS
59219: PPUSH
59220: LD_VAR 0 4
59224: PUSH
59225: LD_INT 1
59227: ARRAY
59228: PPUSH
59229: CALL_OW 2
59233: PPUSH
59234: CALL_OW 1
59238: ST_TO_ADDR
// end ;
59239: LD_VAR 0 3
59243: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
59244: LD_INT 0
59246: PPUSH
59247: PPUSH
// if not mc_bases or not base or not kinds then
59248: LD_EXP 102
59252: NOT
59253: PUSH
59254: LD_VAR 0 1
59258: NOT
59259: OR
59260: PUSH
59261: LD_VAR 0 2
59265: NOT
59266: OR
59267: IFFALSE 59271
// exit ;
59269: GO 59332
// for i in kinds do
59271: LD_ADDR_VAR 0 4
59275: PUSH
59276: LD_VAR 0 2
59280: PUSH
59281: FOR_IN
59282: IFFALSE 59330
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
59284: LD_ADDR_EXP 136
59288: PUSH
59289: LD_EXP 136
59293: PPUSH
59294: LD_VAR 0 1
59298: PUSH
59299: LD_EXP 136
59303: PUSH
59304: LD_VAR 0 1
59308: ARRAY
59309: PUSH
59310: LD_INT 1
59312: PLUS
59313: PUSH
59314: EMPTY
59315: LIST
59316: LIST
59317: PPUSH
59318: LD_VAR 0 4
59322: PPUSH
59323: CALL 72191 0 3
59327: ST_TO_ADDR
59328: GO 59281
59330: POP
59331: POP
// end ;
59332: LD_VAR 0 3
59336: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
59337: LD_INT 0
59339: PPUSH
// if not mc_bases or not base or not areas then
59340: LD_EXP 102
59344: NOT
59345: PUSH
59346: LD_VAR 0 1
59350: NOT
59351: OR
59352: PUSH
59353: LD_VAR 0 2
59357: NOT
59358: OR
59359: IFFALSE 59363
// exit ;
59361: GO 59388
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
59363: LD_ADDR_EXP 120
59367: PUSH
59368: LD_EXP 120
59372: PPUSH
59373: LD_VAR 0 1
59377: PPUSH
59378: LD_VAR 0 2
59382: PPUSH
59383: CALL_OW 1
59387: ST_TO_ADDR
// end ;
59388: LD_VAR 0 3
59392: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
59393: LD_INT 0
59395: PPUSH
// if not mc_bases or not base or not teleports_exit then
59396: LD_EXP 102
59400: NOT
59401: PUSH
59402: LD_VAR 0 1
59406: NOT
59407: OR
59408: PUSH
59409: LD_VAR 0 2
59413: NOT
59414: OR
59415: IFFALSE 59419
// exit ;
59417: GO 59444
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
59419: LD_ADDR_EXP 137
59423: PUSH
59424: LD_EXP 137
59428: PPUSH
59429: LD_VAR 0 1
59433: PPUSH
59434: LD_VAR 0 2
59438: PPUSH
59439: CALL_OW 1
59443: ST_TO_ADDR
// end ;
59444: LD_VAR 0 3
59448: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
59449: LD_INT 0
59451: PPUSH
59452: PPUSH
59453: PPUSH
// if not mc_bases or not base or not ext_list then
59454: LD_EXP 102
59458: NOT
59459: PUSH
59460: LD_VAR 0 1
59464: NOT
59465: OR
59466: PUSH
59467: LD_VAR 0 5
59471: NOT
59472: OR
59473: IFFALSE 59477
// exit ;
59475: GO 59650
// tmp := GetFacExtXYD ( x , y , d ) ;
59477: LD_ADDR_VAR 0 8
59481: PUSH
59482: LD_VAR 0 2
59486: PPUSH
59487: LD_VAR 0 3
59491: PPUSH
59492: LD_VAR 0 4
59496: PPUSH
59497: CALL 105579 0 3
59501: ST_TO_ADDR
// if not tmp then
59502: LD_VAR 0 8
59506: NOT
59507: IFFALSE 59511
// exit ;
59509: GO 59650
// for i in tmp do
59511: LD_ADDR_VAR 0 7
59515: PUSH
59516: LD_VAR 0 8
59520: PUSH
59521: FOR_IN
59522: IFFALSE 59648
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
59524: LD_ADDR_EXP 107
59528: PUSH
59529: LD_EXP 107
59533: PPUSH
59534: LD_VAR 0 1
59538: PPUSH
59539: LD_EXP 107
59543: PUSH
59544: LD_VAR 0 1
59548: ARRAY
59549: PPUSH
59550: LD_EXP 107
59554: PUSH
59555: LD_VAR 0 1
59559: ARRAY
59560: PUSH
59561: LD_INT 1
59563: PLUS
59564: PPUSH
59565: LD_VAR 0 5
59569: PUSH
59570: LD_INT 1
59572: ARRAY
59573: PUSH
59574: LD_VAR 0 7
59578: PUSH
59579: LD_INT 1
59581: ARRAY
59582: PUSH
59583: LD_VAR 0 7
59587: PUSH
59588: LD_INT 2
59590: ARRAY
59591: PUSH
59592: LD_VAR 0 7
59596: PUSH
59597: LD_INT 3
59599: ARRAY
59600: PUSH
59601: EMPTY
59602: LIST
59603: LIST
59604: LIST
59605: LIST
59606: PPUSH
59607: CALL_OW 2
59611: PPUSH
59612: CALL_OW 1
59616: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
59617: LD_ADDR_VAR 0 5
59621: PUSH
59622: LD_VAR 0 5
59626: PPUSH
59627: LD_INT 1
59629: PPUSH
59630: CALL_OW 3
59634: ST_TO_ADDR
// if not ext_list then
59635: LD_VAR 0 5
59639: NOT
59640: IFFALSE 59646
// exit ;
59642: POP
59643: POP
59644: GO 59650
// end ;
59646: GO 59521
59648: POP
59649: POP
// end ;
59650: LD_VAR 0 6
59654: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
59655: LD_INT 0
59657: PPUSH
// if not mc_bases or not base or not weapon_list then
59658: LD_EXP 102
59662: NOT
59663: PUSH
59664: LD_VAR 0 1
59668: NOT
59669: OR
59670: PUSH
59671: LD_VAR 0 2
59675: NOT
59676: OR
59677: IFFALSE 59681
// exit ;
59679: GO 59706
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
59681: LD_ADDR_EXP 141
59685: PUSH
59686: LD_EXP 141
59690: PPUSH
59691: LD_VAR 0 1
59695: PPUSH
59696: LD_VAR 0 2
59700: PPUSH
59701: CALL_OW 1
59705: ST_TO_ADDR
// end ;
59706: LD_VAR 0 3
59710: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
59711: LD_INT 0
59713: PPUSH
// if not mc_bases or not base or not tech_list then
59714: LD_EXP 102
59718: NOT
59719: PUSH
59720: LD_VAR 0 1
59724: NOT
59725: OR
59726: PUSH
59727: LD_VAR 0 2
59731: NOT
59732: OR
59733: IFFALSE 59737
// exit ;
59735: GO 59762
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
59737: LD_ADDR_EXP 129
59741: PUSH
59742: LD_EXP 129
59746: PPUSH
59747: LD_VAR 0 1
59751: PPUSH
59752: LD_VAR 0 2
59756: PPUSH
59757: CALL_OW 1
59761: ST_TO_ADDR
// end ;
59762: LD_VAR 0 3
59766: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
59767: LD_INT 0
59769: PPUSH
// if not mc_bases or not parking_area or not base then
59770: LD_EXP 102
59774: NOT
59775: PUSH
59776: LD_VAR 0 2
59780: NOT
59781: OR
59782: PUSH
59783: LD_VAR 0 1
59787: NOT
59788: OR
59789: IFFALSE 59793
// exit ;
59791: GO 59818
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
59793: LD_ADDR_EXP 126
59797: PUSH
59798: LD_EXP 126
59802: PPUSH
59803: LD_VAR 0 1
59807: PPUSH
59808: LD_VAR 0 2
59812: PPUSH
59813: CALL_OW 1
59817: ST_TO_ADDR
// end ;
59818: LD_VAR 0 3
59822: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
59823: LD_INT 0
59825: PPUSH
// if not mc_bases or not base or not scan_area then
59826: LD_EXP 102
59830: NOT
59831: PUSH
59832: LD_VAR 0 1
59836: NOT
59837: OR
59838: PUSH
59839: LD_VAR 0 2
59843: NOT
59844: OR
59845: IFFALSE 59849
// exit ;
59847: GO 59874
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59849: LD_ADDR_EXP 127
59853: PUSH
59854: LD_EXP 127
59858: PPUSH
59859: LD_VAR 0 1
59863: PPUSH
59864: LD_VAR 0 2
59868: PPUSH
59869: CALL_OW 1
59873: ST_TO_ADDR
// end ;
59874: LD_VAR 0 3
59878: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59879: LD_INT 0
59881: PPUSH
59882: PPUSH
// if not mc_bases or not base then
59883: LD_EXP 102
59887: NOT
59888: PUSH
59889: LD_VAR 0 1
59893: NOT
59894: OR
59895: IFFALSE 59899
// exit ;
59897: GO 59963
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59899: LD_ADDR_VAR 0 3
59903: PUSH
59904: LD_INT 1
59906: PUSH
59907: LD_INT 2
59909: PUSH
59910: LD_INT 3
59912: PUSH
59913: LD_INT 4
59915: PUSH
59916: LD_INT 11
59918: PUSH
59919: EMPTY
59920: LIST
59921: LIST
59922: LIST
59923: LIST
59924: LIST
59925: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59926: LD_ADDR_EXP 129
59930: PUSH
59931: LD_EXP 129
59935: PPUSH
59936: LD_VAR 0 1
59940: PPUSH
59941: LD_EXP 129
59945: PUSH
59946: LD_VAR 0 1
59950: ARRAY
59951: PUSH
59952: LD_VAR 0 3
59956: DIFF
59957: PPUSH
59958: CALL_OW 1
59962: ST_TO_ADDR
// end ;
59963: LD_VAR 0 2
59967: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59968: LD_INT 0
59970: PPUSH
// result := mc_vehicles [ base ] ;
59971: LD_ADDR_VAR 0 3
59975: PUSH
59976: LD_EXP 121
59980: PUSH
59981: LD_VAR 0 1
59985: ARRAY
59986: ST_TO_ADDR
// if onlyCombat then
59987: LD_VAR 0 2
59991: IFFALSE 60156
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59993: LD_ADDR_VAR 0 3
59997: PUSH
59998: LD_VAR 0 3
60002: PUSH
60003: LD_VAR 0 3
60007: PPUSH
60008: LD_INT 2
60010: PUSH
60011: LD_INT 34
60013: PUSH
60014: LD_INT 12
60016: PUSH
60017: EMPTY
60018: LIST
60019: LIST
60020: PUSH
60021: LD_INT 34
60023: PUSH
60024: LD_INT 51
60026: PUSH
60027: EMPTY
60028: LIST
60029: LIST
60030: PUSH
60031: LD_INT 34
60033: PUSH
60034: LD_EXP 96
60038: PUSH
60039: EMPTY
60040: LIST
60041: LIST
60042: PUSH
60043: LD_INT 34
60045: PUSH
60046: LD_INT 32
60048: PUSH
60049: EMPTY
60050: LIST
60051: LIST
60052: PUSH
60053: LD_INT 34
60055: PUSH
60056: LD_INT 13
60058: PUSH
60059: EMPTY
60060: LIST
60061: LIST
60062: PUSH
60063: LD_INT 34
60065: PUSH
60066: LD_INT 52
60068: PUSH
60069: EMPTY
60070: LIST
60071: LIST
60072: PUSH
60073: LD_INT 34
60075: PUSH
60076: LD_INT 14
60078: PUSH
60079: EMPTY
60080: LIST
60081: LIST
60082: PUSH
60083: LD_INT 34
60085: PUSH
60086: LD_INT 53
60088: PUSH
60089: EMPTY
60090: LIST
60091: LIST
60092: PUSH
60093: LD_INT 34
60095: PUSH
60096: LD_EXP 95
60100: PUSH
60101: EMPTY
60102: LIST
60103: LIST
60104: PUSH
60105: LD_INT 34
60107: PUSH
60108: LD_INT 31
60110: PUSH
60111: EMPTY
60112: LIST
60113: LIST
60114: PUSH
60115: LD_INT 34
60117: PUSH
60118: LD_INT 48
60120: PUSH
60121: EMPTY
60122: LIST
60123: LIST
60124: PUSH
60125: LD_INT 34
60127: PUSH
60128: LD_INT 8
60130: PUSH
60131: EMPTY
60132: LIST
60133: LIST
60134: PUSH
60135: EMPTY
60136: LIST
60137: LIST
60138: LIST
60139: LIST
60140: LIST
60141: LIST
60142: LIST
60143: LIST
60144: LIST
60145: LIST
60146: LIST
60147: LIST
60148: LIST
60149: PPUSH
60150: CALL_OW 72
60154: DIFF
60155: ST_TO_ADDR
// end ; end_of_file
60156: LD_VAR 0 3
60160: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
60161: LD_INT 0
60163: PPUSH
60164: PPUSH
60165: PPUSH
// if not mc_bases or not skirmish then
60166: LD_EXP 102
60170: NOT
60171: PUSH
60172: LD_EXP 100
60176: NOT
60177: OR
60178: IFFALSE 60182
// exit ;
60180: GO 60347
// for i = 1 to mc_bases do
60182: LD_ADDR_VAR 0 4
60186: PUSH
60187: DOUBLE
60188: LD_INT 1
60190: DEC
60191: ST_TO_ADDR
60192: LD_EXP 102
60196: PUSH
60197: FOR_TO
60198: IFFALSE 60345
// begin if sci in mc_bases [ i ] then
60200: LD_VAR 0 2
60204: PUSH
60205: LD_EXP 102
60209: PUSH
60210: LD_VAR 0 4
60214: ARRAY
60215: IN
60216: IFFALSE 60343
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
60218: LD_ADDR_EXP 131
60222: PUSH
60223: LD_EXP 131
60227: PPUSH
60228: LD_VAR 0 4
60232: PUSH
60233: LD_EXP 131
60237: PUSH
60238: LD_VAR 0 4
60242: ARRAY
60243: PUSH
60244: LD_INT 1
60246: PLUS
60247: PUSH
60248: EMPTY
60249: LIST
60250: LIST
60251: PPUSH
60252: LD_VAR 0 1
60256: PPUSH
60257: CALL 72191 0 3
60261: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
60262: LD_ADDR_VAR 0 5
60266: PUSH
60267: LD_EXP 102
60271: PUSH
60272: LD_VAR 0 4
60276: ARRAY
60277: PPUSH
60278: LD_INT 2
60280: PUSH
60281: LD_INT 30
60283: PUSH
60284: LD_INT 0
60286: PUSH
60287: EMPTY
60288: LIST
60289: LIST
60290: PUSH
60291: LD_INT 30
60293: PUSH
60294: LD_INT 1
60296: PUSH
60297: EMPTY
60298: LIST
60299: LIST
60300: PUSH
60301: EMPTY
60302: LIST
60303: LIST
60304: LIST
60305: PPUSH
60306: CALL_OW 72
60310: PPUSH
60311: LD_VAR 0 1
60315: PPUSH
60316: CALL_OW 74
60320: ST_TO_ADDR
// if tmp then
60321: LD_VAR 0 5
60325: IFFALSE 60341
// ComStandNearbyBuilding ( ape , tmp ) ;
60327: LD_VAR 0 1
60331: PPUSH
60332: LD_VAR 0 5
60336: PPUSH
60337: CALL 66394 0 2
// break ;
60341: GO 60345
// end ; end ;
60343: GO 60197
60345: POP
60346: POP
// end ;
60347: LD_VAR 0 3
60351: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
60352: LD_INT 0
60354: PPUSH
60355: PPUSH
60356: PPUSH
// if not mc_bases or not skirmish then
60357: LD_EXP 102
60361: NOT
60362: PUSH
60363: LD_EXP 100
60367: NOT
60368: OR
60369: IFFALSE 60373
// exit ;
60371: GO 60462
// for i = 1 to mc_bases do
60373: LD_ADDR_VAR 0 4
60377: PUSH
60378: DOUBLE
60379: LD_INT 1
60381: DEC
60382: ST_TO_ADDR
60383: LD_EXP 102
60387: PUSH
60388: FOR_TO
60389: IFFALSE 60460
// begin if building in mc_busy_turret_list [ i ] then
60391: LD_VAR 0 1
60395: PUSH
60396: LD_EXP 112
60400: PUSH
60401: LD_VAR 0 4
60405: ARRAY
60406: IN
60407: IFFALSE 60458
// begin tmp := mc_busy_turret_list [ i ] diff building ;
60409: LD_ADDR_VAR 0 5
60413: PUSH
60414: LD_EXP 112
60418: PUSH
60419: LD_VAR 0 4
60423: ARRAY
60424: PUSH
60425: LD_VAR 0 1
60429: DIFF
60430: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
60431: LD_ADDR_EXP 112
60435: PUSH
60436: LD_EXP 112
60440: PPUSH
60441: LD_VAR 0 4
60445: PPUSH
60446: LD_VAR 0 5
60450: PPUSH
60451: CALL_OW 1
60455: ST_TO_ADDR
// break ;
60456: GO 60460
// end ; end ;
60458: GO 60388
60460: POP
60461: POP
// end ;
60462: LD_VAR 0 3
60466: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
60467: LD_INT 0
60469: PPUSH
60470: PPUSH
60471: PPUSH
// if not mc_bases or not skirmish then
60472: LD_EXP 102
60476: NOT
60477: PUSH
60478: LD_EXP 100
60482: NOT
60483: OR
60484: IFFALSE 60488
// exit ;
60486: GO 60687
// for i = 1 to mc_bases do
60488: LD_ADDR_VAR 0 5
60492: PUSH
60493: DOUBLE
60494: LD_INT 1
60496: DEC
60497: ST_TO_ADDR
60498: LD_EXP 102
60502: PUSH
60503: FOR_TO
60504: IFFALSE 60685
// if building in mc_bases [ i ] then
60506: LD_VAR 0 1
60510: PUSH
60511: LD_EXP 102
60515: PUSH
60516: LD_VAR 0 5
60520: ARRAY
60521: IN
60522: IFFALSE 60683
// begin tmp := mc_bases [ i ] diff building ;
60524: LD_ADDR_VAR 0 6
60528: PUSH
60529: LD_EXP 102
60533: PUSH
60534: LD_VAR 0 5
60538: ARRAY
60539: PUSH
60540: LD_VAR 0 1
60544: DIFF
60545: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
60546: LD_ADDR_EXP 102
60550: PUSH
60551: LD_EXP 102
60555: PPUSH
60556: LD_VAR 0 5
60560: PPUSH
60561: LD_VAR 0 6
60565: PPUSH
60566: CALL_OW 1
60570: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
60571: LD_VAR 0 1
60575: PUSH
60576: LD_EXP 110
60580: PUSH
60581: LD_VAR 0 5
60585: ARRAY
60586: IN
60587: IFFALSE 60626
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
60589: LD_ADDR_EXP 110
60593: PUSH
60594: LD_EXP 110
60598: PPUSH
60599: LD_VAR 0 5
60603: PPUSH
60604: LD_EXP 110
60608: PUSH
60609: LD_VAR 0 5
60613: ARRAY
60614: PUSH
60615: LD_VAR 0 1
60619: DIFF
60620: PPUSH
60621: CALL_OW 1
60625: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
60626: LD_VAR 0 1
60630: PUSH
60631: LD_EXP 111
60635: PUSH
60636: LD_VAR 0 5
60640: ARRAY
60641: IN
60642: IFFALSE 60681
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
60644: LD_ADDR_EXP 111
60648: PUSH
60649: LD_EXP 111
60653: PPUSH
60654: LD_VAR 0 5
60658: PPUSH
60659: LD_EXP 111
60663: PUSH
60664: LD_VAR 0 5
60668: ARRAY
60669: PUSH
60670: LD_VAR 0 1
60674: DIFF
60675: PPUSH
60676: CALL_OW 1
60680: ST_TO_ADDR
// break ;
60681: GO 60685
// end ;
60683: GO 60503
60685: POP
60686: POP
// end ;
60687: LD_VAR 0 4
60691: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
60692: LD_INT 0
60694: PPUSH
60695: PPUSH
60696: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
60697: LD_EXP 102
60701: NOT
60702: PUSH
60703: LD_EXP 100
60707: NOT
60708: OR
60709: PUSH
60710: LD_VAR 0 3
60714: PUSH
60715: LD_EXP 128
60719: IN
60720: NOT
60721: OR
60722: IFFALSE 60726
// exit ;
60724: GO 60849
// for i = 1 to mc_vehicles do
60726: LD_ADDR_VAR 0 6
60730: PUSH
60731: DOUBLE
60732: LD_INT 1
60734: DEC
60735: ST_TO_ADDR
60736: LD_EXP 121
60740: PUSH
60741: FOR_TO
60742: IFFALSE 60847
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
60744: LD_VAR 0 2
60748: PUSH
60749: LD_EXP 121
60753: PUSH
60754: LD_VAR 0 6
60758: ARRAY
60759: IN
60760: PUSH
60761: LD_VAR 0 1
60765: PUSH
60766: LD_EXP 121
60770: PUSH
60771: LD_VAR 0 6
60775: ARRAY
60776: IN
60777: OR
60778: IFFALSE 60845
// begin tmp := mc_vehicles [ i ] diff old ;
60780: LD_ADDR_VAR 0 7
60784: PUSH
60785: LD_EXP 121
60789: PUSH
60790: LD_VAR 0 6
60794: ARRAY
60795: PUSH
60796: LD_VAR 0 2
60800: DIFF
60801: ST_TO_ADDR
// tmp := tmp diff new ;
60802: LD_ADDR_VAR 0 7
60806: PUSH
60807: LD_VAR 0 7
60811: PUSH
60812: LD_VAR 0 1
60816: DIFF
60817: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
60818: LD_ADDR_EXP 121
60822: PUSH
60823: LD_EXP 121
60827: PPUSH
60828: LD_VAR 0 6
60832: PPUSH
60833: LD_VAR 0 7
60837: PPUSH
60838: CALL_OW 1
60842: ST_TO_ADDR
// break ;
60843: GO 60847
// end ;
60845: GO 60741
60847: POP
60848: POP
// end ;
60849: LD_VAR 0 5
60853: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60854: LD_INT 0
60856: PPUSH
60857: PPUSH
60858: PPUSH
60859: PPUSH
// if not mc_bases or not skirmish then
60860: LD_EXP 102
60864: NOT
60865: PUSH
60866: LD_EXP 100
60870: NOT
60871: OR
60872: IFFALSE 60876
// exit ;
60874: GO 61253
// side := GetSide ( vehicle ) ;
60876: LD_ADDR_VAR 0 5
60880: PUSH
60881: LD_VAR 0 1
60885: PPUSH
60886: CALL_OW 255
60890: ST_TO_ADDR
// for i = 1 to mc_bases do
60891: LD_ADDR_VAR 0 4
60895: PUSH
60896: DOUBLE
60897: LD_INT 1
60899: DEC
60900: ST_TO_ADDR
60901: LD_EXP 102
60905: PUSH
60906: FOR_TO
60907: IFFALSE 61251
// begin if factory in mc_bases [ i ] then
60909: LD_VAR 0 2
60913: PUSH
60914: LD_EXP 102
60918: PUSH
60919: LD_VAR 0 4
60923: ARRAY
60924: IN
60925: IFFALSE 61249
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60927: LD_EXP 124
60931: PUSH
60932: LD_VAR 0 4
60936: ARRAY
60937: PUSH
60938: LD_EXP 113
60942: PUSH
60943: LD_VAR 0 4
60947: ARRAY
60948: LESS
60949: PUSH
60950: LD_VAR 0 1
60954: PPUSH
60955: CALL_OW 264
60959: PUSH
60960: LD_INT 31
60962: PUSH
60963: LD_INT 32
60965: PUSH
60966: LD_INT 51
60968: PUSH
60969: LD_EXP 96
60973: PUSH
60974: LD_INT 12
60976: PUSH
60977: LD_INT 30
60979: PUSH
60980: LD_EXP 95
60984: PUSH
60985: LD_INT 11
60987: PUSH
60988: LD_INT 53
60990: PUSH
60991: LD_INT 14
60993: PUSH
60994: LD_EXP 99
60998: PUSH
60999: LD_INT 29
61001: PUSH
61002: LD_EXP 97
61006: PUSH
61007: LD_INT 13
61009: PUSH
61010: LD_INT 52
61012: PUSH
61013: LD_INT 48
61015: PUSH
61016: LD_INT 8
61018: PUSH
61019: EMPTY
61020: LIST
61021: LIST
61022: LIST
61023: LIST
61024: LIST
61025: LIST
61026: LIST
61027: LIST
61028: LIST
61029: LIST
61030: LIST
61031: LIST
61032: LIST
61033: LIST
61034: LIST
61035: LIST
61036: LIST
61037: IN
61038: NOT
61039: AND
61040: IFFALSE 61088
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61042: LD_ADDR_EXP 124
61046: PUSH
61047: LD_EXP 124
61051: PPUSH
61052: LD_VAR 0 4
61056: PUSH
61057: LD_EXP 124
61061: PUSH
61062: LD_VAR 0 4
61066: ARRAY
61067: PUSH
61068: LD_INT 1
61070: PLUS
61071: PUSH
61072: EMPTY
61073: LIST
61074: LIST
61075: PPUSH
61076: LD_VAR 0 1
61080: PPUSH
61081: CALL 72191 0 3
61085: ST_TO_ADDR
61086: GO 61132
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
61088: LD_ADDR_EXP 121
61092: PUSH
61093: LD_EXP 121
61097: PPUSH
61098: LD_VAR 0 4
61102: PUSH
61103: LD_EXP 121
61107: PUSH
61108: LD_VAR 0 4
61112: ARRAY
61113: PUSH
61114: LD_INT 1
61116: PLUS
61117: PUSH
61118: EMPTY
61119: LIST
61120: LIST
61121: PPUSH
61122: LD_VAR 0 1
61126: PPUSH
61127: CALL 72191 0 3
61131: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
61132: LD_VAR 0 1
61136: PPUSH
61137: CALL_OW 263
61141: PUSH
61142: LD_INT 2
61144: EQUAL
61145: IFFALSE 61165
// begin repeat wait ( 0 0$1 ) ;
61147: LD_INT 35
61149: PPUSH
61150: CALL_OW 67
// until IsControledBy ( vehicle ) ;
61154: LD_VAR 0 1
61158: PPUSH
61159: CALL_OW 312
61163: IFFALSE 61147
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
61165: LD_VAR 0 1
61169: PPUSH
61170: LD_EXP 126
61174: PUSH
61175: LD_VAR 0 4
61179: ARRAY
61180: PPUSH
61181: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
61185: LD_VAR 0 1
61189: PPUSH
61190: CALL_OW 263
61194: PUSH
61195: LD_INT 1
61197: NONEQUAL
61198: IFFALSE 61202
// break ;
61200: GO 61251
// repeat wait ( 0 0$1 ) ;
61202: LD_INT 35
61204: PPUSH
61205: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
61209: LD_VAR 0 1
61213: PPUSH
61214: LD_EXP 126
61218: PUSH
61219: LD_VAR 0 4
61223: ARRAY
61224: PPUSH
61225: CALL_OW 308
61229: IFFALSE 61202
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
61231: LD_VAR 0 1
61235: PPUSH
61236: CALL_OW 311
61240: PPUSH
61241: CALL_OW 121
// exit ;
61245: POP
61246: POP
61247: GO 61253
// end ; end ;
61249: GO 60906
61251: POP
61252: POP
// end ;
61253: LD_VAR 0 3
61257: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
61258: LD_INT 0
61260: PPUSH
61261: PPUSH
61262: PPUSH
61263: PPUSH
// if not mc_bases or not skirmish then
61264: LD_EXP 102
61268: NOT
61269: PUSH
61270: LD_EXP 100
61274: NOT
61275: OR
61276: IFFALSE 61280
// exit ;
61278: GO 61633
// repeat wait ( 0 0$1 ) ;
61280: LD_INT 35
61282: PPUSH
61283: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
61287: LD_VAR 0 2
61291: PPUSH
61292: LD_VAR 0 3
61296: PPUSH
61297: CALL_OW 284
61301: IFFALSE 61280
// if GetResourceTypeXY ( x , y ) = mat_artefact then
61303: LD_VAR 0 2
61307: PPUSH
61308: LD_VAR 0 3
61312: PPUSH
61313: CALL_OW 283
61317: PUSH
61318: LD_INT 4
61320: EQUAL
61321: IFFALSE 61325
// exit ;
61323: GO 61633
// for i = 1 to mc_bases do
61325: LD_ADDR_VAR 0 7
61329: PUSH
61330: DOUBLE
61331: LD_INT 1
61333: DEC
61334: ST_TO_ADDR
61335: LD_EXP 102
61339: PUSH
61340: FOR_TO
61341: IFFALSE 61631
// begin if mc_crates_area [ i ] then
61343: LD_EXP 120
61347: PUSH
61348: LD_VAR 0 7
61352: ARRAY
61353: IFFALSE 61464
// for j in mc_crates_area [ i ] do
61355: LD_ADDR_VAR 0 8
61359: PUSH
61360: LD_EXP 120
61364: PUSH
61365: LD_VAR 0 7
61369: ARRAY
61370: PUSH
61371: FOR_IN
61372: IFFALSE 61462
// if InArea ( x , y , j ) then
61374: LD_VAR 0 2
61378: PPUSH
61379: LD_VAR 0 3
61383: PPUSH
61384: LD_VAR 0 8
61388: PPUSH
61389: CALL_OW 309
61393: IFFALSE 61460
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61395: LD_ADDR_EXP 118
61399: PUSH
61400: LD_EXP 118
61404: PPUSH
61405: LD_VAR 0 7
61409: PUSH
61410: LD_EXP 118
61414: PUSH
61415: LD_VAR 0 7
61419: ARRAY
61420: PUSH
61421: LD_INT 1
61423: PLUS
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PPUSH
61429: LD_VAR 0 4
61433: PUSH
61434: LD_VAR 0 2
61438: PUSH
61439: LD_VAR 0 3
61443: PUSH
61444: EMPTY
61445: LIST
61446: LIST
61447: LIST
61448: PPUSH
61449: CALL 72191 0 3
61453: ST_TO_ADDR
// exit ;
61454: POP
61455: POP
61456: POP
61457: POP
61458: GO 61633
// end ;
61460: GO 61371
61462: POP
61463: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61464: LD_ADDR_VAR 0 9
61468: PUSH
61469: LD_EXP 102
61473: PUSH
61474: LD_VAR 0 7
61478: ARRAY
61479: PPUSH
61480: LD_INT 2
61482: PUSH
61483: LD_INT 30
61485: PUSH
61486: LD_INT 0
61488: PUSH
61489: EMPTY
61490: LIST
61491: LIST
61492: PUSH
61493: LD_INT 30
61495: PUSH
61496: LD_INT 1
61498: PUSH
61499: EMPTY
61500: LIST
61501: LIST
61502: PUSH
61503: EMPTY
61504: LIST
61505: LIST
61506: LIST
61507: PPUSH
61508: CALL_OW 72
61512: ST_TO_ADDR
// if not depot then
61513: LD_VAR 0 9
61517: NOT
61518: IFFALSE 61522
// continue ;
61520: GO 61340
// for j in depot do
61522: LD_ADDR_VAR 0 8
61526: PUSH
61527: LD_VAR 0 9
61531: PUSH
61532: FOR_IN
61533: IFFALSE 61627
// if GetDistUnitXY ( j , x , y ) < 30 then
61535: LD_VAR 0 8
61539: PPUSH
61540: LD_VAR 0 2
61544: PPUSH
61545: LD_VAR 0 3
61549: PPUSH
61550: CALL_OW 297
61554: PUSH
61555: LD_INT 30
61557: LESS
61558: IFFALSE 61625
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
61560: LD_ADDR_EXP 118
61564: PUSH
61565: LD_EXP 118
61569: PPUSH
61570: LD_VAR 0 7
61574: PUSH
61575: LD_EXP 118
61579: PUSH
61580: LD_VAR 0 7
61584: ARRAY
61585: PUSH
61586: LD_INT 1
61588: PLUS
61589: PUSH
61590: EMPTY
61591: LIST
61592: LIST
61593: PPUSH
61594: LD_VAR 0 4
61598: PUSH
61599: LD_VAR 0 2
61603: PUSH
61604: LD_VAR 0 3
61608: PUSH
61609: EMPTY
61610: LIST
61611: LIST
61612: LIST
61613: PPUSH
61614: CALL 72191 0 3
61618: ST_TO_ADDR
// exit ;
61619: POP
61620: POP
61621: POP
61622: POP
61623: GO 61633
// end ;
61625: GO 61532
61627: POP
61628: POP
// end ;
61629: GO 61340
61631: POP
61632: POP
// end ;
61633: LD_VAR 0 6
61637: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
61638: LD_INT 0
61640: PPUSH
61641: PPUSH
61642: PPUSH
61643: PPUSH
// if not mc_bases or not skirmish then
61644: LD_EXP 102
61648: NOT
61649: PUSH
61650: LD_EXP 100
61654: NOT
61655: OR
61656: IFFALSE 61660
// exit ;
61658: GO 61937
// side := GetSide ( lab ) ;
61660: LD_ADDR_VAR 0 4
61664: PUSH
61665: LD_VAR 0 2
61669: PPUSH
61670: CALL_OW 255
61674: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
61675: LD_VAR 0 4
61679: PUSH
61680: LD_EXP 128
61684: IN
61685: NOT
61686: PUSH
61687: LD_EXP 129
61691: NOT
61692: OR
61693: PUSH
61694: LD_EXP 102
61698: NOT
61699: OR
61700: IFFALSE 61704
// exit ;
61702: GO 61937
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
61704: LD_ADDR_EXP 129
61708: PUSH
61709: LD_EXP 129
61713: PPUSH
61714: LD_VAR 0 4
61718: PPUSH
61719: LD_EXP 129
61723: PUSH
61724: LD_VAR 0 4
61728: ARRAY
61729: PUSH
61730: LD_VAR 0 1
61734: DIFF
61735: PPUSH
61736: CALL_OW 1
61740: ST_TO_ADDR
// for i = 1 to mc_bases do
61741: LD_ADDR_VAR 0 5
61745: PUSH
61746: DOUBLE
61747: LD_INT 1
61749: DEC
61750: ST_TO_ADDR
61751: LD_EXP 102
61755: PUSH
61756: FOR_TO
61757: IFFALSE 61935
// begin if lab in mc_bases [ i ] then
61759: LD_VAR 0 2
61763: PUSH
61764: LD_EXP 102
61768: PUSH
61769: LD_VAR 0 5
61773: ARRAY
61774: IN
61775: IFFALSE 61933
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
61777: LD_VAR 0 1
61781: PUSH
61782: LD_INT 11
61784: PUSH
61785: LD_INT 4
61787: PUSH
61788: LD_INT 3
61790: PUSH
61791: LD_INT 2
61793: PUSH
61794: EMPTY
61795: LIST
61796: LIST
61797: LIST
61798: LIST
61799: IN
61800: PUSH
61801: LD_EXP 132
61805: PUSH
61806: LD_VAR 0 5
61810: ARRAY
61811: AND
61812: IFFALSE 61933
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
61814: LD_ADDR_VAR 0 6
61818: PUSH
61819: LD_EXP 132
61823: PUSH
61824: LD_VAR 0 5
61828: ARRAY
61829: PUSH
61830: LD_INT 1
61832: ARRAY
61833: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61834: LD_ADDR_EXP 132
61838: PUSH
61839: LD_EXP 132
61843: PPUSH
61844: LD_VAR 0 5
61848: PPUSH
61849: EMPTY
61850: PPUSH
61851: CALL_OW 1
61855: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61856: LD_VAR 0 6
61860: PPUSH
61861: LD_INT 0
61863: PPUSH
61864: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61868: LD_VAR 0 6
61872: PPUSH
61873: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61877: LD_ADDR_EXP 131
61881: PUSH
61882: LD_EXP 131
61886: PPUSH
61887: LD_VAR 0 5
61891: PPUSH
61892: LD_EXP 131
61896: PUSH
61897: LD_VAR 0 5
61901: ARRAY
61902: PPUSH
61903: LD_INT 1
61905: PPUSH
61906: LD_VAR 0 6
61910: PPUSH
61911: CALL_OW 2
61915: PPUSH
61916: CALL_OW 1
61920: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61921: LD_VAR 0 5
61925: PPUSH
61926: LD_INT 112
61928: PPUSH
61929: CALL 38933 0 2
// end ; end ; end ;
61933: GO 61756
61935: POP
61936: POP
// end ;
61937: LD_VAR 0 3
61941: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61942: LD_INT 0
61944: PPUSH
61945: PPUSH
61946: PPUSH
61947: PPUSH
61948: PPUSH
61949: PPUSH
61950: PPUSH
61951: PPUSH
// if not mc_bases or not skirmish then
61952: LD_EXP 102
61956: NOT
61957: PUSH
61958: LD_EXP 100
61962: NOT
61963: OR
61964: IFFALSE 61968
// exit ;
61966: GO 63339
// for i = 1 to mc_bases do
61968: LD_ADDR_VAR 0 3
61972: PUSH
61973: DOUBLE
61974: LD_INT 1
61976: DEC
61977: ST_TO_ADDR
61978: LD_EXP 102
61982: PUSH
61983: FOR_TO
61984: IFFALSE 63337
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61986: LD_VAR 0 1
61990: PUSH
61991: LD_EXP 102
61995: PUSH
61996: LD_VAR 0 3
62000: ARRAY
62001: IN
62002: PUSH
62003: LD_VAR 0 1
62007: PUSH
62008: LD_EXP 109
62012: PUSH
62013: LD_VAR 0 3
62017: ARRAY
62018: IN
62019: OR
62020: PUSH
62021: LD_VAR 0 1
62025: PUSH
62026: LD_EXP 124
62030: PUSH
62031: LD_VAR 0 3
62035: ARRAY
62036: IN
62037: OR
62038: PUSH
62039: LD_VAR 0 1
62043: PUSH
62044: LD_EXP 121
62048: PUSH
62049: LD_VAR 0 3
62053: ARRAY
62054: IN
62055: OR
62056: PUSH
62057: LD_VAR 0 1
62061: PUSH
62062: LD_EXP 131
62066: PUSH
62067: LD_VAR 0 3
62071: ARRAY
62072: IN
62073: OR
62074: PUSH
62075: LD_VAR 0 1
62079: PUSH
62080: LD_EXP 132
62084: PUSH
62085: LD_VAR 0 3
62089: ARRAY
62090: IN
62091: OR
62092: IFFALSE 63335
// begin if un in mc_ape [ i ] then
62094: LD_VAR 0 1
62098: PUSH
62099: LD_EXP 131
62103: PUSH
62104: LD_VAR 0 3
62108: ARRAY
62109: IN
62110: IFFALSE 62149
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
62112: LD_ADDR_EXP 131
62116: PUSH
62117: LD_EXP 131
62121: PPUSH
62122: LD_VAR 0 3
62126: PPUSH
62127: LD_EXP 131
62131: PUSH
62132: LD_VAR 0 3
62136: ARRAY
62137: PUSH
62138: LD_VAR 0 1
62142: DIFF
62143: PPUSH
62144: CALL_OW 1
62148: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
62149: LD_VAR 0 1
62153: PUSH
62154: LD_EXP 132
62158: PUSH
62159: LD_VAR 0 3
62163: ARRAY
62164: IN
62165: IFFALSE 62189
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62167: LD_ADDR_EXP 132
62171: PUSH
62172: LD_EXP 132
62176: PPUSH
62177: LD_VAR 0 3
62181: PPUSH
62182: EMPTY
62183: PPUSH
62184: CALL_OW 1
62188: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
62189: LD_VAR 0 1
62193: PPUSH
62194: CALL_OW 247
62198: PUSH
62199: LD_INT 2
62201: EQUAL
62202: PUSH
62203: LD_VAR 0 1
62207: PPUSH
62208: CALL_OW 110
62212: PUSH
62213: LD_INT 20
62215: EQUAL
62216: PUSH
62217: LD_VAR 0 1
62221: PUSH
62222: LD_EXP 124
62226: PUSH
62227: LD_VAR 0 3
62231: ARRAY
62232: IN
62233: OR
62234: PUSH
62235: LD_VAR 0 1
62239: PPUSH
62240: CALL_OW 264
62244: PUSH
62245: LD_INT 12
62247: PUSH
62248: LD_INT 51
62250: PUSH
62251: LD_EXP 96
62255: PUSH
62256: LD_INT 32
62258: PUSH
62259: LD_INT 13
62261: PUSH
62262: LD_INT 52
62264: PUSH
62265: LD_INT 31
62267: PUSH
62268: EMPTY
62269: LIST
62270: LIST
62271: LIST
62272: LIST
62273: LIST
62274: LIST
62275: LIST
62276: IN
62277: OR
62278: AND
62279: IFFALSE 62587
// begin if un in mc_defender [ i ] then
62281: LD_VAR 0 1
62285: PUSH
62286: LD_EXP 124
62290: PUSH
62291: LD_VAR 0 3
62295: ARRAY
62296: IN
62297: IFFALSE 62336
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62299: LD_ADDR_EXP 124
62303: PUSH
62304: LD_EXP 124
62308: PPUSH
62309: LD_VAR 0 3
62313: PPUSH
62314: LD_EXP 124
62318: PUSH
62319: LD_VAR 0 3
62323: ARRAY
62324: PUSH
62325: LD_VAR 0 1
62329: DIFF
62330: PPUSH
62331: CALL_OW 1
62335: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
62336: LD_ADDR_VAR 0 8
62340: PUSH
62341: LD_VAR 0 3
62345: PPUSH
62346: LD_INT 3
62348: PPUSH
62349: CALL 59005 0 2
62353: ST_TO_ADDR
// if fac then
62354: LD_VAR 0 8
62358: IFFALSE 62587
// begin for j in fac do
62360: LD_ADDR_VAR 0 4
62364: PUSH
62365: LD_VAR 0 8
62369: PUSH
62370: FOR_IN
62371: IFFALSE 62585
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
62373: LD_ADDR_VAR 0 9
62377: PUSH
62378: LD_VAR 0 8
62382: PPUSH
62383: LD_VAR 0 1
62387: PPUSH
62388: CALL_OW 265
62392: PPUSH
62393: LD_VAR 0 1
62397: PPUSH
62398: CALL_OW 262
62402: PPUSH
62403: LD_VAR 0 1
62407: PPUSH
62408: CALL_OW 263
62412: PPUSH
62413: LD_VAR 0 1
62417: PPUSH
62418: CALL_OW 264
62422: PPUSH
62423: CALL 69723 0 5
62427: ST_TO_ADDR
// if components then
62428: LD_VAR 0 9
62432: IFFALSE 62583
// begin if GetWeapon ( un ) = ar_control_tower then
62434: LD_VAR 0 1
62438: PPUSH
62439: CALL_OW 264
62443: PUSH
62444: LD_INT 31
62446: EQUAL
62447: IFFALSE 62564
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
62449: LD_VAR 0 1
62453: PPUSH
62454: CALL_OW 311
62458: PPUSH
62459: LD_INT 0
62461: PPUSH
62462: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
62466: LD_ADDR_EXP 142
62470: PUSH
62471: LD_EXP 142
62475: PPUSH
62476: LD_VAR 0 3
62480: PPUSH
62481: LD_EXP 142
62485: PUSH
62486: LD_VAR 0 3
62490: ARRAY
62491: PUSH
62492: LD_VAR 0 1
62496: PPUSH
62497: CALL_OW 311
62501: DIFF
62502: PPUSH
62503: CALL_OW 1
62507: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
62508: LD_ADDR_VAR 0 7
62512: PUSH
62513: LD_EXP 123
62517: PUSH
62518: LD_VAR 0 3
62522: ARRAY
62523: PPUSH
62524: LD_INT 1
62526: PPUSH
62527: LD_VAR 0 9
62531: PPUSH
62532: CALL_OW 2
62536: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
62537: LD_ADDR_EXP 123
62541: PUSH
62542: LD_EXP 123
62546: PPUSH
62547: LD_VAR 0 3
62551: PPUSH
62552: LD_VAR 0 7
62556: PPUSH
62557: CALL_OW 1
62561: ST_TO_ADDR
// end else
62562: GO 62581
// MC_InsertProduceList ( i , [ components ] ) ;
62564: LD_VAR 0 3
62568: PPUSH
62569: LD_VAR 0 9
62573: PUSH
62574: EMPTY
62575: LIST
62576: PPUSH
62577: CALL 58550 0 2
// break ;
62581: GO 62585
// end ; end ;
62583: GO 62370
62585: POP
62586: POP
// end ; end ; if GetType ( un ) = unit_building then
62587: LD_VAR 0 1
62591: PPUSH
62592: CALL_OW 247
62596: PUSH
62597: LD_INT 3
62599: EQUAL
62600: IFFALSE 63003
// begin btype := GetBType ( un ) ;
62602: LD_ADDR_VAR 0 5
62606: PUSH
62607: LD_VAR 0 1
62611: PPUSH
62612: CALL_OW 266
62616: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
62617: LD_VAR 0 5
62621: PUSH
62622: LD_INT 29
62624: PUSH
62625: LD_INT 30
62627: PUSH
62628: EMPTY
62629: LIST
62630: LIST
62631: IN
62632: IFFALSE 62705
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
62634: LD_VAR 0 1
62638: PPUSH
62639: CALL_OW 250
62643: PPUSH
62644: LD_VAR 0 1
62648: PPUSH
62649: CALL_OW 251
62653: PPUSH
62654: LD_VAR 0 1
62658: PPUSH
62659: CALL_OW 255
62663: PPUSH
62664: CALL_OW 440
62668: NOT
62669: IFFALSE 62705
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
62671: LD_VAR 0 1
62675: PPUSH
62676: CALL_OW 250
62680: PPUSH
62681: LD_VAR 0 1
62685: PPUSH
62686: CALL_OW 251
62690: PPUSH
62691: LD_VAR 0 1
62695: PPUSH
62696: CALL_OW 255
62700: PPUSH
62701: CALL_OW 441
// end ; if btype = b_warehouse then
62705: LD_VAR 0 5
62709: PUSH
62710: LD_INT 1
62712: EQUAL
62713: IFFALSE 62731
// begin btype := b_depot ;
62715: LD_ADDR_VAR 0 5
62719: PUSH
62720: LD_INT 0
62722: ST_TO_ADDR
// pos := 1 ;
62723: LD_ADDR_VAR 0 6
62727: PUSH
62728: LD_INT 1
62730: ST_TO_ADDR
// end ; if btype = b_factory then
62731: LD_VAR 0 5
62735: PUSH
62736: LD_INT 3
62738: EQUAL
62739: IFFALSE 62757
// begin btype := b_workshop ;
62741: LD_ADDR_VAR 0 5
62745: PUSH
62746: LD_INT 2
62748: ST_TO_ADDR
// pos := 1 ;
62749: LD_ADDR_VAR 0 6
62753: PUSH
62754: LD_INT 1
62756: ST_TO_ADDR
// end ; if btype = b_barracks then
62757: LD_VAR 0 5
62761: PUSH
62762: LD_INT 5
62764: EQUAL
62765: IFFALSE 62775
// btype := b_armoury ;
62767: LD_ADDR_VAR 0 5
62771: PUSH
62772: LD_INT 4
62774: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
62775: LD_VAR 0 5
62779: PUSH
62780: LD_INT 7
62782: PUSH
62783: LD_INT 8
62785: PUSH
62786: EMPTY
62787: LIST
62788: LIST
62789: IN
62790: IFFALSE 62800
// btype := b_lab ;
62792: LD_ADDR_VAR 0 5
62796: PUSH
62797: LD_INT 6
62799: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
62800: LD_ADDR_EXP 107
62804: PUSH
62805: LD_EXP 107
62809: PPUSH
62810: LD_VAR 0 3
62814: PUSH
62815: LD_EXP 107
62819: PUSH
62820: LD_VAR 0 3
62824: ARRAY
62825: PUSH
62826: LD_INT 1
62828: PLUS
62829: PUSH
62830: EMPTY
62831: LIST
62832: LIST
62833: PPUSH
62834: LD_VAR 0 5
62838: PUSH
62839: LD_VAR 0 1
62843: PPUSH
62844: CALL_OW 250
62848: PUSH
62849: LD_VAR 0 1
62853: PPUSH
62854: CALL_OW 251
62858: PUSH
62859: LD_VAR 0 1
62863: PPUSH
62864: CALL_OW 254
62868: PUSH
62869: EMPTY
62870: LIST
62871: LIST
62872: LIST
62873: LIST
62874: PPUSH
62875: CALL 72191 0 3
62879: ST_TO_ADDR
// if pos = 1 then
62880: LD_VAR 0 6
62884: PUSH
62885: LD_INT 1
62887: EQUAL
62888: IFFALSE 63003
// begin tmp := mc_build_list [ i ] ;
62890: LD_ADDR_VAR 0 7
62894: PUSH
62895: LD_EXP 107
62899: PUSH
62900: LD_VAR 0 3
62904: ARRAY
62905: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62906: LD_VAR 0 7
62910: PPUSH
62911: LD_INT 2
62913: PUSH
62914: LD_INT 30
62916: PUSH
62917: LD_INT 0
62919: PUSH
62920: EMPTY
62921: LIST
62922: LIST
62923: PUSH
62924: LD_INT 30
62926: PUSH
62927: LD_INT 1
62929: PUSH
62930: EMPTY
62931: LIST
62932: LIST
62933: PUSH
62934: EMPTY
62935: LIST
62936: LIST
62937: LIST
62938: PPUSH
62939: CALL_OW 72
62943: IFFALSE 62953
// pos := 2 ;
62945: LD_ADDR_VAR 0 6
62949: PUSH
62950: LD_INT 2
62952: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62953: LD_ADDR_VAR 0 7
62957: PUSH
62958: LD_VAR 0 7
62962: PPUSH
62963: LD_VAR 0 6
62967: PPUSH
62968: LD_VAR 0 7
62972: PPUSH
62973: CALL 72517 0 3
62977: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62978: LD_ADDR_EXP 107
62982: PUSH
62983: LD_EXP 107
62987: PPUSH
62988: LD_VAR 0 3
62992: PPUSH
62993: LD_VAR 0 7
62997: PPUSH
62998: CALL_OW 1
63002: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63003: LD_VAR 0 1
63007: PUSH
63008: LD_EXP 102
63012: PUSH
63013: LD_VAR 0 3
63017: ARRAY
63018: IN
63019: IFFALSE 63058
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63021: LD_ADDR_EXP 102
63025: PUSH
63026: LD_EXP 102
63030: PPUSH
63031: LD_VAR 0 3
63035: PPUSH
63036: LD_EXP 102
63040: PUSH
63041: LD_VAR 0 3
63045: ARRAY
63046: PUSH
63047: LD_VAR 0 1
63051: DIFF
63052: PPUSH
63053: CALL_OW 1
63057: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
63058: LD_VAR 0 1
63062: PUSH
63063: LD_EXP 109
63067: PUSH
63068: LD_VAR 0 3
63072: ARRAY
63073: IN
63074: IFFALSE 63113
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
63076: LD_ADDR_EXP 109
63080: PUSH
63081: LD_EXP 109
63085: PPUSH
63086: LD_VAR 0 3
63090: PPUSH
63091: LD_EXP 109
63095: PUSH
63096: LD_VAR 0 3
63100: ARRAY
63101: PUSH
63102: LD_VAR 0 1
63106: DIFF
63107: PPUSH
63108: CALL_OW 1
63112: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
63113: LD_VAR 0 1
63117: PUSH
63118: LD_EXP 121
63122: PUSH
63123: LD_VAR 0 3
63127: ARRAY
63128: IN
63129: IFFALSE 63168
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
63131: LD_ADDR_EXP 121
63135: PUSH
63136: LD_EXP 121
63140: PPUSH
63141: LD_VAR 0 3
63145: PPUSH
63146: LD_EXP 121
63150: PUSH
63151: LD_VAR 0 3
63155: ARRAY
63156: PUSH
63157: LD_VAR 0 1
63161: DIFF
63162: PPUSH
63163: CALL_OW 1
63167: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
63168: LD_VAR 0 1
63172: PUSH
63173: LD_EXP 124
63177: PUSH
63178: LD_VAR 0 3
63182: ARRAY
63183: IN
63184: IFFALSE 63223
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63186: LD_ADDR_EXP 124
63190: PUSH
63191: LD_EXP 124
63195: PPUSH
63196: LD_VAR 0 3
63200: PPUSH
63201: LD_EXP 124
63205: PUSH
63206: LD_VAR 0 3
63210: ARRAY
63211: PUSH
63212: LD_VAR 0 1
63216: DIFF
63217: PPUSH
63218: CALL_OW 1
63222: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
63223: LD_VAR 0 1
63227: PUSH
63228: LD_EXP 111
63232: PUSH
63233: LD_VAR 0 3
63237: ARRAY
63238: IN
63239: IFFALSE 63278
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
63241: LD_ADDR_EXP 111
63245: PUSH
63246: LD_EXP 111
63250: PPUSH
63251: LD_VAR 0 3
63255: PPUSH
63256: LD_EXP 111
63260: PUSH
63261: LD_VAR 0 3
63265: ARRAY
63266: PUSH
63267: LD_VAR 0 1
63271: DIFF
63272: PPUSH
63273: CALL_OW 1
63277: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
63278: LD_VAR 0 1
63282: PUSH
63283: LD_EXP 110
63287: PUSH
63288: LD_VAR 0 3
63292: ARRAY
63293: IN
63294: IFFALSE 63333
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
63296: LD_ADDR_EXP 110
63300: PUSH
63301: LD_EXP 110
63305: PPUSH
63306: LD_VAR 0 3
63310: PPUSH
63311: LD_EXP 110
63315: PUSH
63316: LD_VAR 0 3
63320: ARRAY
63321: PUSH
63322: LD_VAR 0 1
63326: DIFF
63327: PPUSH
63328: CALL_OW 1
63332: ST_TO_ADDR
// end ; break ;
63333: GO 63337
// end ;
63335: GO 61983
63337: POP
63338: POP
// end ;
63339: LD_VAR 0 2
63343: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
63344: LD_INT 0
63346: PPUSH
63347: PPUSH
63348: PPUSH
// if not mc_bases or not skirmish then
63349: LD_EXP 102
63353: NOT
63354: PUSH
63355: LD_EXP 100
63359: NOT
63360: OR
63361: IFFALSE 63365
// exit ;
63363: GO 63580
// for i = 1 to mc_bases do
63365: LD_ADDR_VAR 0 3
63369: PUSH
63370: DOUBLE
63371: LD_INT 1
63373: DEC
63374: ST_TO_ADDR
63375: LD_EXP 102
63379: PUSH
63380: FOR_TO
63381: IFFALSE 63578
// begin if building in mc_construct_list [ i ] then
63383: LD_VAR 0 1
63387: PUSH
63388: LD_EXP 109
63392: PUSH
63393: LD_VAR 0 3
63397: ARRAY
63398: IN
63399: IFFALSE 63576
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63401: LD_ADDR_EXP 109
63405: PUSH
63406: LD_EXP 109
63410: PPUSH
63411: LD_VAR 0 3
63415: PPUSH
63416: LD_EXP 109
63420: PUSH
63421: LD_VAR 0 3
63425: ARRAY
63426: PUSH
63427: LD_VAR 0 1
63431: DIFF
63432: PPUSH
63433: CALL_OW 1
63437: ST_TO_ADDR
// if building in mc_lab [ i ] then
63438: LD_VAR 0 1
63442: PUSH
63443: LD_EXP 135
63447: PUSH
63448: LD_VAR 0 3
63452: ARRAY
63453: IN
63454: IFFALSE 63509
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
63456: LD_ADDR_EXP 136
63460: PUSH
63461: LD_EXP 136
63465: PPUSH
63466: LD_VAR 0 3
63470: PPUSH
63471: LD_EXP 136
63475: PUSH
63476: LD_VAR 0 3
63480: ARRAY
63481: PPUSH
63482: LD_INT 1
63484: PPUSH
63485: LD_EXP 136
63489: PUSH
63490: LD_VAR 0 3
63494: ARRAY
63495: PPUSH
63496: LD_INT 0
63498: PPUSH
63499: CALL 71609 0 4
63503: PPUSH
63504: CALL_OW 1
63508: ST_TO_ADDR
// if not building in mc_bases [ i ] then
63509: LD_VAR 0 1
63513: PUSH
63514: LD_EXP 102
63518: PUSH
63519: LD_VAR 0 3
63523: ARRAY
63524: IN
63525: NOT
63526: IFFALSE 63572
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63528: LD_ADDR_EXP 102
63532: PUSH
63533: LD_EXP 102
63537: PPUSH
63538: LD_VAR 0 3
63542: PUSH
63543: LD_EXP 102
63547: PUSH
63548: LD_VAR 0 3
63552: ARRAY
63553: PUSH
63554: LD_INT 1
63556: PLUS
63557: PUSH
63558: EMPTY
63559: LIST
63560: LIST
63561: PPUSH
63562: LD_VAR 0 1
63566: PPUSH
63567: CALL 72191 0 3
63571: ST_TO_ADDR
// exit ;
63572: POP
63573: POP
63574: GO 63580
// end ; end ;
63576: GO 63380
63578: POP
63579: POP
// end ;
63580: LD_VAR 0 2
63584: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
63585: LD_INT 0
63587: PPUSH
63588: PPUSH
63589: PPUSH
63590: PPUSH
63591: PPUSH
63592: PPUSH
63593: PPUSH
// if not mc_bases or not skirmish then
63594: LD_EXP 102
63598: NOT
63599: PUSH
63600: LD_EXP 100
63604: NOT
63605: OR
63606: IFFALSE 63610
// exit ;
63608: GO 64271
// for i = 1 to mc_bases do
63610: LD_ADDR_VAR 0 3
63614: PUSH
63615: DOUBLE
63616: LD_INT 1
63618: DEC
63619: ST_TO_ADDR
63620: LD_EXP 102
63624: PUSH
63625: FOR_TO
63626: IFFALSE 64269
// begin if building in mc_construct_list [ i ] then
63628: LD_VAR 0 1
63632: PUSH
63633: LD_EXP 109
63637: PUSH
63638: LD_VAR 0 3
63642: ARRAY
63643: IN
63644: IFFALSE 64267
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
63646: LD_ADDR_EXP 109
63650: PUSH
63651: LD_EXP 109
63655: PPUSH
63656: LD_VAR 0 3
63660: PPUSH
63661: LD_EXP 109
63665: PUSH
63666: LD_VAR 0 3
63670: ARRAY
63671: PUSH
63672: LD_VAR 0 1
63676: DIFF
63677: PPUSH
63678: CALL_OW 1
63682: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
63683: LD_ADDR_EXP 102
63687: PUSH
63688: LD_EXP 102
63692: PPUSH
63693: LD_VAR 0 3
63697: PUSH
63698: LD_EXP 102
63702: PUSH
63703: LD_VAR 0 3
63707: ARRAY
63708: PUSH
63709: LD_INT 1
63711: PLUS
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: PPUSH
63717: LD_VAR 0 1
63721: PPUSH
63722: CALL 72191 0 3
63726: ST_TO_ADDR
// btype := GetBType ( building ) ;
63727: LD_ADDR_VAR 0 5
63731: PUSH
63732: LD_VAR 0 1
63736: PPUSH
63737: CALL_OW 266
63741: ST_TO_ADDR
// side := GetSide ( building ) ;
63742: LD_ADDR_VAR 0 8
63746: PUSH
63747: LD_VAR 0 1
63751: PPUSH
63752: CALL_OW 255
63756: ST_TO_ADDR
// if btype = b_lab then
63757: LD_VAR 0 5
63761: PUSH
63762: LD_INT 6
63764: EQUAL
63765: IFFALSE 63815
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
63767: LD_ADDR_EXP 135
63771: PUSH
63772: LD_EXP 135
63776: PPUSH
63777: LD_VAR 0 3
63781: PUSH
63782: LD_EXP 135
63786: PUSH
63787: LD_VAR 0 3
63791: ARRAY
63792: PUSH
63793: LD_INT 1
63795: PLUS
63796: PUSH
63797: EMPTY
63798: LIST
63799: LIST
63800: PPUSH
63801: LD_VAR 0 1
63805: PPUSH
63806: CALL 72191 0 3
63810: ST_TO_ADDR
// exit ;
63811: POP
63812: POP
63813: GO 64271
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
63815: LD_VAR 0 5
63819: PUSH
63820: LD_INT 0
63822: PUSH
63823: LD_INT 2
63825: PUSH
63826: LD_INT 4
63828: PUSH
63829: EMPTY
63830: LIST
63831: LIST
63832: LIST
63833: IN
63834: IFFALSE 63958
// begin if btype = b_armoury then
63836: LD_VAR 0 5
63840: PUSH
63841: LD_INT 4
63843: EQUAL
63844: IFFALSE 63854
// btype := b_barracks ;
63846: LD_ADDR_VAR 0 5
63850: PUSH
63851: LD_INT 5
63853: ST_TO_ADDR
// if btype = b_depot then
63854: LD_VAR 0 5
63858: PUSH
63859: LD_INT 0
63861: EQUAL
63862: IFFALSE 63872
// btype := b_warehouse ;
63864: LD_ADDR_VAR 0 5
63868: PUSH
63869: LD_INT 1
63871: ST_TO_ADDR
// if btype = b_workshop then
63872: LD_VAR 0 5
63876: PUSH
63877: LD_INT 2
63879: EQUAL
63880: IFFALSE 63890
// btype := b_factory ;
63882: LD_ADDR_VAR 0 5
63886: PUSH
63887: LD_INT 3
63889: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63890: LD_VAR 0 5
63894: PPUSH
63895: LD_VAR 0 8
63899: PPUSH
63900: CALL_OW 323
63904: PUSH
63905: LD_INT 1
63907: EQUAL
63908: IFFALSE 63954
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63910: LD_ADDR_EXP 134
63914: PUSH
63915: LD_EXP 134
63919: PPUSH
63920: LD_VAR 0 3
63924: PUSH
63925: LD_EXP 134
63929: PUSH
63930: LD_VAR 0 3
63934: ARRAY
63935: PUSH
63936: LD_INT 1
63938: PLUS
63939: PUSH
63940: EMPTY
63941: LIST
63942: LIST
63943: PPUSH
63944: LD_VAR 0 1
63948: PPUSH
63949: CALL 72191 0 3
63953: ST_TO_ADDR
// exit ;
63954: POP
63955: POP
63956: GO 64271
// end ; if btype in [ b_bunker , b_turret ] then
63958: LD_VAR 0 5
63962: PUSH
63963: LD_INT 32
63965: PUSH
63966: LD_INT 33
63968: PUSH
63969: EMPTY
63970: LIST
63971: LIST
63972: IN
63973: IFFALSE 64263
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63975: LD_ADDR_EXP 110
63979: PUSH
63980: LD_EXP 110
63984: PPUSH
63985: LD_VAR 0 3
63989: PUSH
63990: LD_EXP 110
63994: PUSH
63995: LD_VAR 0 3
63999: ARRAY
64000: PUSH
64001: LD_INT 1
64003: PLUS
64004: PUSH
64005: EMPTY
64006: LIST
64007: LIST
64008: PPUSH
64009: LD_VAR 0 1
64013: PPUSH
64014: CALL 72191 0 3
64018: ST_TO_ADDR
// if btype = b_bunker then
64019: LD_VAR 0 5
64023: PUSH
64024: LD_INT 32
64026: EQUAL
64027: IFFALSE 64263
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64029: LD_ADDR_EXP 111
64033: PUSH
64034: LD_EXP 111
64038: PPUSH
64039: LD_VAR 0 3
64043: PUSH
64044: LD_EXP 111
64048: PUSH
64049: LD_VAR 0 3
64053: ARRAY
64054: PUSH
64055: LD_INT 1
64057: PLUS
64058: PUSH
64059: EMPTY
64060: LIST
64061: LIST
64062: PPUSH
64063: LD_VAR 0 1
64067: PPUSH
64068: CALL 72191 0 3
64072: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
64073: LD_ADDR_VAR 0 6
64077: PUSH
64078: LD_EXP 102
64082: PUSH
64083: LD_VAR 0 3
64087: ARRAY
64088: PPUSH
64089: LD_INT 25
64091: PUSH
64092: LD_INT 1
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: LD_INT 3
64101: PUSH
64102: LD_INT 54
64104: PUSH
64105: EMPTY
64106: LIST
64107: PUSH
64108: EMPTY
64109: LIST
64110: LIST
64111: PUSH
64112: EMPTY
64113: LIST
64114: LIST
64115: PPUSH
64116: CALL_OW 72
64120: ST_TO_ADDR
// if tmp then
64121: LD_VAR 0 6
64125: IFFALSE 64131
// exit ;
64127: POP
64128: POP
64129: GO 64271
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
64131: LD_ADDR_VAR 0 6
64135: PUSH
64136: LD_EXP 102
64140: PUSH
64141: LD_VAR 0 3
64145: ARRAY
64146: PPUSH
64147: LD_INT 2
64149: PUSH
64150: LD_INT 30
64152: PUSH
64153: LD_INT 4
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: PUSH
64160: LD_INT 30
64162: PUSH
64163: LD_INT 5
64165: PUSH
64166: EMPTY
64167: LIST
64168: LIST
64169: PUSH
64170: EMPTY
64171: LIST
64172: LIST
64173: LIST
64174: PPUSH
64175: CALL_OW 72
64179: ST_TO_ADDR
// if not tmp then
64180: LD_VAR 0 6
64184: NOT
64185: IFFALSE 64191
// exit ;
64187: POP
64188: POP
64189: GO 64271
// for j in tmp do
64191: LD_ADDR_VAR 0 4
64195: PUSH
64196: LD_VAR 0 6
64200: PUSH
64201: FOR_IN
64202: IFFALSE 64261
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
64204: LD_ADDR_VAR 0 7
64208: PUSH
64209: LD_VAR 0 4
64213: PPUSH
64214: CALL_OW 313
64218: PPUSH
64219: LD_INT 25
64221: PUSH
64222: LD_INT 1
64224: PUSH
64225: EMPTY
64226: LIST
64227: LIST
64228: PPUSH
64229: CALL_OW 72
64233: ST_TO_ADDR
// if units then
64234: LD_VAR 0 7
64238: IFFALSE 64259
// begin ComExitBuilding ( units [ 1 ] ) ;
64240: LD_VAR 0 7
64244: PUSH
64245: LD_INT 1
64247: ARRAY
64248: PPUSH
64249: CALL_OW 122
// exit ;
64253: POP
64254: POP
64255: POP
64256: POP
64257: GO 64271
// end ; end ;
64259: GO 64201
64261: POP
64262: POP
// end ; end ; exit ;
64263: POP
64264: POP
64265: GO 64271
// end ; end ;
64267: GO 63625
64269: POP
64270: POP
// end ;
64271: LD_VAR 0 2
64275: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
64276: LD_INT 0
64278: PPUSH
64279: PPUSH
64280: PPUSH
64281: PPUSH
64282: PPUSH
64283: PPUSH
64284: PPUSH
// if not mc_bases or not skirmish then
64285: LD_EXP 102
64289: NOT
64290: PUSH
64291: LD_EXP 100
64295: NOT
64296: OR
64297: IFFALSE 64301
// exit ;
64299: GO 64532
// btype := GetBType ( building ) ;
64301: LD_ADDR_VAR 0 6
64305: PUSH
64306: LD_VAR 0 1
64310: PPUSH
64311: CALL_OW 266
64315: ST_TO_ADDR
// x := GetX ( building ) ;
64316: LD_ADDR_VAR 0 7
64320: PUSH
64321: LD_VAR 0 1
64325: PPUSH
64326: CALL_OW 250
64330: ST_TO_ADDR
// y := GetY ( building ) ;
64331: LD_ADDR_VAR 0 8
64335: PUSH
64336: LD_VAR 0 1
64340: PPUSH
64341: CALL_OW 251
64345: ST_TO_ADDR
// d := GetDir ( building ) ;
64346: LD_ADDR_VAR 0 9
64350: PUSH
64351: LD_VAR 0 1
64355: PPUSH
64356: CALL_OW 254
64360: ST_TO_ADDR
// for i = 1 to mc_bases do
64361: LD_ADDR_VAR 0 4
64365: PUSH
64366: DOUBLE
64367: LD_INT 1
64369: DEC
64370: ST_TO_ADDR
64371: LD_EXP 102
64375: PUSH
64376: FOR_TO
64377: IFFALSE 64530
// begin if not mc_build_list [ i ] then
64379: LD_EXP 107
64383: PUSH
64384: LD_VAR 0 4
64388: ARRAY
64389: NOT
64390: IFFALSE 64394
// continue ;
64392: GO 64376
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
64394: LD_VAR 0 6
64398: PUSH
64399: LD_VAR 0 7
64403: PUSH
64404: LD_VAR 0 8
64408: PUSH
64409: LD_VAR 0 9
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: LIST
64418: LIST
64419: PPUSH
64420: LD_EXP 107
64424: PUSH
64425: LD_VAR 0 4
64429: ARRAY
64430: PUSH
64431: LD_INT 1
64433: ARRAY
64434: PPUSH
64435: CALL 78360 0 2
64439: IFFALSE 64528
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
64441: LD_ADDR_EXP 107
64445: PUSH
64446: LD_EXP 107
64450: PPUSH
64451: LD_VAR 0 4
64455: PPUSH
64456: LD_EXP 107
64460: PUSH
64461: LD_VAR 0 4
64465: ARRAY
64466: PPUSH
64467: LD_INT 1
64469: PPUSH
64470: CALL_OW 3
64474: PPUSH
64475: CALL_OW 1
64479: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
64480: LD_ADDR_EXP 109
64484: PUSH
64485: LD_EXP 109
64489: PPUSH
64490: LD_VAR 0 4
64494: PUSH
64495: LD_EXP 109
64499: PUSH
64500: LD_VAR 0 4
64504: ARRAY
64505: PUSH
64506: LD_INT 1
64508: PLUS
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: PPUSH
64514: LD_VAR 0 1
64518: PPUSH
64519: CALL 72191 0 3
64523: ST_TO_ADDR
// exit ;
64524: POP
64525: POP
64526: GO 64532
// end ; end ;
64528: GO 64376
64530: POP
64531: POP
// end ;
64532: LD_VAR 0 3
64536: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
64537: LD_INT 0
64539: PPUSH
64540: PPUSH
64541: PPUSH
// if not mc_bases or not skirmish then
64542: LD_EXP 102
64546: NOT
64547: PUSH
64548: LD_EXP 100
64552: NOT
64553: OR
64554: IFFALSE 64558
// exit ;
64556: GO 64748
// for i = 1 to mc_bases do
64558: LD_ADDR_VAR 0 4
64562: PUSH
64563: DOUBLE
64564: LD_INT 1
64566: DEC
64567: ST_TO_ADDR
64568: LD_EXP 102
64572: PUSH
64573: FOR_TO
64574: IFFALSE 64661
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
64576: LD_VAR 0 1
64580: PUSH
64581: LD_EXP 110
64585: PUSH
64586: LD_VAR 0 4
64590: ARRAY
64591: IN
64592: PUSH
64593: LD_VAR 0 1
64597: PUSH
64598: LD_EXP 111
64602: PUSH
64603: LD_VAR 0 4
64607: ARRAY
64608: IN
64609: NOT
64610: AND
64611: IFFALSE 64659
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64613: LD_ADDR_EXP 111
64617: PUSH
64618: LD_EXP 111
64622: PPUSH
64623: LD_VAR 0 4
64627: PUSH
64628: LD_EXP 111
64632: PUSH
64633: LD_VAR 0 4
64637: ARRAY
64638: PUSH
64639: LD_INT 1
64641: PLUS
64642: PUSH
64643: EMPTY
64644: LIST
64645: LIST
64646: PPUSH
64647: LD_VAR 0 1
64651: PPUSH
64652: CALL 72191 0 3
64656: ST_TO_ADDR
// break ;
64657: GO 64661
// end ; end ;
64659: GO 64573
64661: POP
64662: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
64663: LD_VAR 0 1
64667: PPUSH
64668: CALL_OW 257
64672: PUSH
64673: LD_EXP 128
64677: IN
64678: PUSH
64679: LD_VAR 0 1
64683: PPUSH
64684: CALL_OW 266
64688: PUSH
64689: LD_INT 5
64691: EQUAL
64692: AND
64693: PUSH
64694: LD_VAR 0 2
64698: PPUSH
64699: CALL_OW 110
64703: PUSH
64704: LD_INT 18
64706: NONEQUAL
64707: AND
64708: IFFALSE 64748
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
64710: LD_VAR 0 2
64714: PPUSH
64715: CALL_OW 257
64719: PUSH
64720: LD_INT 5
64722: PUSH
64723: LD_INT 8
64725: PUSH
64726: LD_INT 9
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: LIST
64733: IN
64734: IFFALSE 64748
// SetClass ( unit , 1 ) ;
64736: LD_VAR 0 2
64740: PPUSH
64741: LD_INT 1
64743: PPUSH
64744: CALL_OW 336
// end ;
64748: LD_VAR 0 3
64752: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
64753: LD_INT 0
64755: PPUSH
64756: PPUSH
// if not mc_bases or not skirmish then
64757: LD_EXP 102
64761: NOT
64762: PUSH
64763: LD_EXP 100
64767: NOT
64768: OR
64769: IFFALSE 64773
// exit ;
64771: GO 64889
// if GetLives ( abandoned_vehicle ) > 250 then
64773: LD_VAR 0 2
64777: PPUSH
64778: CALL_OW 256
64782: PUSH
64783: LD_INT 250
64785: GREATER
64786: IFFALSE 64790
// exit ;
64788: GO 64889
// for i = 1 to mc_bases do
64790: LD_ADDR_VAR 0 6
64794: PUSH
64795: DOUBLE
64796: LD_INT 1
64798: DEC
64799: ST_TO_ADDR
64800: LD_EXP 102
64804: PUSH
64805: FOR_TO
64806: IFFALSE 64887
// begin if driver in mc_bases [ i ] then
64808: LD_VAR 0 1
64812: PUSH
64813: LD_EXP 102
64817: PUSH
64818: LD_VAR 0 6
64822: ARRAY
64823: IN
64824: IFFALSE 64885
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
64826: LD_VAR 0 1
64830: PPUSH
64831: LD_EXP 102
64835: PUSH
64836: LD_VAR 0 6
64840: ARRAY
64841: PPUSH
64842: LD_INT 2
64844: PUSH
64845: LD_INT 30
64847: PUSH
64848: LD_INT 0
64850: PUSH
64851: EMPTY
64852: LIST
64853: LIST
64854: PUSH
64855: LD_INT 30
64857: PUSH
64858: LD_INT 1
64860: PUSH
64861: EMPTY
64862: LIST
64863: LIST
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: LIST
64869: PPUSH
64870: CALL_OW 72
64874: PUSH
64875: LD_INT 1
64877: ARRAY
64878: PPUSH
64879: CALL_OW 112
// break ;
64883: GO 64887
// end ; end ;
64885: GO 64805
64887: POP
64888: POP
// end ; end_of_file
64889: LD_VAR 0 5
64893: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64894: LD_INT 0
64896: PPUSH
64897: PPUSH
// if exist_mode then
64898: LD_VAR 0 2
64902: IFFALSE 64927
// unit := CreateCharacter ( prefix & ident ) else
64904: LD_ADDR_VAR 0 5
64908: PUSH
64909: LD_VAR 0 3
64913: PUSH
64914: LD_VAR 0 1
64918: STR
64919: PPUSH
64920: CALL_OW 34
64924: ST_TO_ADDR
64925: GO 64942
// unit := NewCharacter ( ident ) ;
64927: LD_ADDR_VAR 0 5
64931: PUSH
64932: LD_VAR 0 1
64936: PPUSH
64937: CALL_OW 25
64941: ST_TO_ADDR
// result := unit ;
64942: LD_ADDR_VAR 0 4
64946: PUSH
64947: LD_VAR 0 5
64951: ST_TO_ADDR
// end ;
64952: LD_VAR 0 4
64956: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64957: LD_INT 0
64959: PPUSH
64960: PPUSH
// if not side or not nation then
64961: LD_VAR 0 1
64965: NOT
64966: PUSH
64967: LD_VAR 0 2
64971: NOT
64972: OR
64973: IFFALSE 64977
// exit ;
64975: GO 65681
// case nation of nation_american :
64977: LD_VAR 0 2
64981: PUSH
64982: LD_INT 1
64984: DOUBLE
64985: EQUAL
64986: IFTRUE 64990
64988: GO 65184
64990: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64991: LD_ADDR_VAR 0 4
64995: PUSH
64996: LD_INT 35
64998: PUSH
64999: LD_INT 45
65001: PUSH
65002: LD_INT 46
65004: PUSH
65005: LD_INT 47
65007: PUSH
65008: LD_INT 82
65010: PUSH
65011: LD_INT 83
65013: PUSH
65014: LD_INT 84
65016: PUSH
65017: LD_INT 85
65019: PUSH
65020: LD_INT 86
65022: PUSH
65023: LD_INT 1
65025: PUSH
65026: LD_INT 2
65028: PUSH
65029: LD_INT 6
65031: PUSH
65032: LD_INT 15
65034: PUSH
65035: LD_INT 16
65037: PUSH
65038: LD_INT 7
65040: PUSH
65041: LD_INT 12
65043: PUSH
65044: LD_INT 13
65046: PUSH
65047: LD_INT 10
65049: PUSH
65050: LD_INT 14
65052: PUSH
65053: LD_INT 20
65055: PUSH
65056: LD_INT 21
65058: PUSH
65059: LD_INT 22
65061: PUSH
65062: LD_INT 25
65064: PUSH
65065: LD_INT 32
65067: PUSH
65068: LD_INT 27
65070: PUSH
65071: LD_INT 36
65073: PUSH
65074: LD_INT 69
65076: PUSH
65077: LD_INT 39
65079: PUSH
65080: LD_INT 34
65082: PUSH
65083: LD_INT 40
65085: PUSH
65086: LD_INT 48
65088: PUSH
65089: LD_INT 49
65091: PUSH
65092: LD_INT 50
65094: PUSH
65095: LD_INT 51
65097: PUSH
65098: LD_INT 52
65100: PUSH
65101: LD_INT 53
65103: PUSH
65104: LD_INT 54
65106: PUSH
65107: LD_INT 55
65109: PUSH
65110: LD_INT 56
65112: PUSH
65113: LD_INT 57
65115: PUSH
65116: LD_INT 58
65118: PUSH
65119: LD_INT 59
65121: PUSH
65122: LD_INT 60
65124: PUSH
65125: LD_INT 61
65127: PUSH
65128: LD_INT 62
65130: PUSH
65131: LD_INT 80
65133: PUSH
65134: EMPTY
65135: LIST
65136: LIST
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: LIST
65166: LIST
65167: LIST
65168: LIST
65169: LIST
65170: LIST
65171: LIST
65172: LIST
65173: LIST
65174: LIST
65175: LIST
65176: LIST
65177: LIST
65178: LIST
65179: LIST
65180: LIST
65181: ST_TO_ADDR
65182: GO 65605
65184: LD_INT 2
65186: DOUBLE
65187: EQUAL
65188: IFTRUE 65192
65190: GO 65394
65192: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
65193: LD_ADDR_VAR 0 4
65197: PUSH
65198: LD_INT 35
65200: PUSH
65201: LD_INT 45
65203: PUSH
65204: LD_INT 46
65206: PUSH
65207: LD_INT 47
65209: PUSH
65210: LD_INT 82
65212: PUSH
65213: LD_INT 83
65215: PUSH
65216: LD_INT 84
65218: PUSH
65219: LD_INT 85
65221: PUSH
65222: LD_INT 87
65224: PUSH
65225: LD_INT 70
65227: PUSH
65228: LD_INT 1
65230: PUSH
65231: LD_INT 11
65233: PUSH
65234: LD_INT 3
65236: PUSH
65237: LD_INT 4
65239: PUSH
65240: LD_INT 5
65242: PUSH
65243: LD_INT 6
65245: PUSH
65246: LD_INT 15
65248: PUSH
65249: LD_INT 18
65251: PUSH
65252: LD_INT 7
65254: PUSH
65255: LD_INT 17
65257: PUSH
65258: LD_INT 8
65260: PUSH
65261: LD_INT 20
65263: PUSH
65264: LD_INT 21
65266: PUSH
65267: LD_INT 22
65269: PUSH
65270: LD_INT 72
65272: PUSH
65273: LD_INT 26
65275: PUSH
65276: LD_INT 69
65278: PUSH
65279: LD_INT 39
65281: PUSH
65282: LD_INT 40
65284: PUSH
65285: LD_INT 41
65287: PUSH
65288: LD_INT 42
65290: PUSH
65291: LD_INT 43
65293: PUSH
65294: LD_INT 48
65296: PUSH
65297: LD_INT 49
65299: PUSH
65300: LD_INT 50
65302: PUSH
65303: LD_INT 51
65305: PUSH
65306: LD_INT 52
65308: PUSH
65309: LD_INT 53
65311: PUSH
65312: LD_INT 54
65314: PUSH
65315: LD_INT 55
65317: PUSH
65318: LD_INT 56
65320: PUSH
65321: LD_INT 60
65323: PUSH
65324: LD_INT 61
65326: PUSH
65327: LD_INT 62
65329: PUSH
65330: LD_INT 66
65332: PUSH
65333: LD_INT 67
65335: PUSH
65336: LD_INT 68
65338: PUSH
65339: LD_INT 81
65341: PUSH
65342: EMPTY
65343: LIST
65344: LIST
65345: LIST
65346: LIST
65347: LIST
65348: LIST
65349: LIST
65350: LIST
65351: LIST
65352: LIST
65353: LIST
65354: LIST
65355: LIST
65356: LIST
65357: LIST
65358: LIST
65359: LIST
65360: LIST
65361: LIST
65362: LIST
65363: LIST
65364: LIST
65365: LIST
65366: LIST
65367: LIST
65368: LIST
65369: LIST
65370: LIST
65371: LIST
65372: LIST
65373: LIST
65374: LIST
65375: LIST
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: ST_TO_ADDR
65392: GO 65605
65394: LD_INT 3
65396: DOUBLE
65397: EQUAL
65398: IFTRUE 65402
65400: GO 65604
65402: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
65403: LD_ADDR_VAR 0 4
65407: PUSH
65408: LD_INT 46
65410: PUSH
65411: LD_INT 47
65413: PUSH
65414: LD_INT 1
65416: PUSH
65417: LD_INT 2
65419: PUSH
65420: LD_INT 82
65422: PUSH
65423: LD_INT 83
65425: PUSH
65426: LD_INT 84
65428: PUSH
65429: LD_INT 85
65431: PUSH
65432: LD_INT 86
65434: PUSH
65435: LD_INT 11
65437: PUSH
65438: LD_INT 9
65440: PUSH
65441: LD_INT 20
65443: PUSH
65444: LD_INT 19
65446: PUSH
65447: LD_INT 21
65449: PUSH
65450: LD_INT 24
65452: PUSH
65453: LD_INT 22
65455: PUSH
65456: LD_INT 25
65458: PUSH
65459: LD_INT 28
65461: PUSH
65462: LD_INT 29
65464: PUSH
65465: LD_INT 30
65467: PUSH
65468: LD_INT 31
65470: PUSH
65471: LD_INT 37
65473: PUSH
65474: LD_INT 38
65476: PUSH
65477: LD_INT 32
65479: PUSH
65480: LD_INT 27
65482: PUSH
65483: LD_INT 33
65485: PUSH
65486: LD_INT 69
65488: PUSH
65489: LD_INT 39
65491: PUSH
65492: LD_INT 34
65494: PUSH
65495: LD_INT 40
65497: PUSH
65498: LD_INT 71
65500: PUSH
65501: LD_INT 23
65503: PUSH
65504: LD_INT 44
65506: PUSH
65507: LD_INT 48
65509: PUSH
65510: LD_INT 49
65512: PUSH
65513: LD_INT 50
65515: PUSH
65516: LD_INT 51
65518: PUSH
65519: LD_INT 52
65521: PUSH
65522: LD_INT 53
65524: PUSH
65525: LD_INT 54
65527: PUSH
65528: LD_INT 55
65530: PUSH
65531: LD_INT 56
65533: PUSH
65534: LD_INT 57
65536: PUSH
65537: LD_INT 58
65539: PUSH
65540: LD_INT 59
65542: PUSH
65543: LD_INT 63
65545: PUSH
65546: LD_INT 64
65548: PUSH
65549: LD_INT 65
65551: PUSH
65552: EMPTY
65553: LIST
65554: LIST
65555: LIST
65556: LIST
65557: LIST
65558: LIST
65559: LIST
65560: LIST
65561: LIST
65562: LIST
65563: LIST
65564: LIST
65565: LIST
65566: LIST
65567: LIST
65568: LIST
65569: LIST
65570: LIST
65571: LIST
65572: LIST
65573: LIST
65574: LIST
65575: LIST
65576: LIST
65577: LIST
65578: LIST
65579: LIST
65580: LIST
65581: LIST
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: ST_TO_ADDR
65602: GO 65605
65604: POP
// if state > - 1 and state < 3 then
65605: LD_VAR 0 3
65609: PUSH
65610: LD_INT 1
65612: NEG
65613: GREATER
65614: PUSH
65615: LD_VAR 0 3
65619: PUSH
65620: LD_INT 3
65622: LESS
65623: AND
65624: IFFALSE 65681
// for i in result do
65626: LD_ADDR_VAR 0 5
65630: PUSH
65631: LD_VAR 0 4
65635: PUSH
65636: FOR_IN
65637: IFFALSE 65679
// if GetTech ( i , side ) <> state then
65639: LD_VAR 0 5
65643: PPUSH
65644: LD_VAR 0 1
65648: PPUSH
65649: CALL_OW 321
65653: PUSH
65654: LD_VAR 0 3
65658: NONEQUAL
65659: IFFALSE 65677
// result := result diff i ;
65661: LD_ADDR_VAR 0 4
65665: PUSH
65666: LD_VAR 0 4
65670: PUSH
65671: LD_VAR 0 5
65675: DIFF
65676: ST_TO_ADDR
65677: GO 65636
65679: POP
65680: POP
// end ;
65681: LD_VAR 0 4
65685: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
65686: LD_INT 0
65688: PPUSH
65689: PPUSH
65690: PPUSH
// result := true ;
65691: LD_ADDR_VAR 0 3
65695: PUSH
65696: LD_INT 1
65698: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
65699: LD_ADDR_VAR 0 5
65703: PUSH
65704: LD_VAR 0 2
65708: PPUSH
65709: CALL_OW 480
65713: ST_TO_ADDR
// if not tmp then
65714: LD_VAR 0 5
65718: NOT
65719: IFFALSE 65723
// exit ;
65721: GO 65772
// for i in tmp do
65723: LD_ADDR_VAR 0 4
65727: PUSH
65728: LD_VAR 0 5
65732: PUSH
65733: FOR_IN
65734: IFFALSE 65770
// if GetTech ( i , side ) <> state_researched then
65736: LD_VAR 0 4
65740: PPUSH
65741: LD_VAR 0 1
65745: PPUSH
65746: CALL_OW 321
65750: PUSH
65751: LD_INT 2
65753: NONEQUAL
65754: IFFALSE 65768
// begin result := false ;
65756: LD_ADDR_VAR 0 3
65760: PUSH
65761: LD_INT 0
65763: ST_TO_ADDR
// exit ;
65764: POP
65765: POP
65766: GO 65772
// end ;
65768: GO 65733
65770: POP
65771: POP
// end ;
65772: LD_VAR 0 3
65776: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
65777: LD_INT 0
65779: PPUSH
65780: PPUSH
65781: PPUSH
65782: PPUSH
65783: PPUSH
65784: PPUSH
65785: PPUSH
65786: PPUSH
65787: PPUSH
65788: PPUSH
65789: PPUSH
65790: PPUSH
65791: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
65792: LD_VAR 0 1
65796: NOT
65797: PUSH
65798: LD_VAR 0 1
65802: PPUSH
65803: CALL_OW 257
65807: PUSH
65808: LD_INT 9
65810: NONEQUAL
65811: OR
65812: IFFALSE 65816
// exit ;
65814: GO 66389
// side := GetSide ( unit ) ;
65816: LD_ADDR_VAR 0 9
65820: PUSH
65821: LD_VAR 0 1
65825: PPUSH
65826: CALL_OW 255
65830: ST_TO_ADDR
// tech_space := tech_spacanom ;
65831: LD_ADDR_VAR 0 12
65835: PUSH
65836: LD_INT 29
65838: ST_TO_ADDR
// tech_time := tech_taurad ;
65839: LD_ADDR_VAR 0 13
65843: PUSH
65844: LD_INT 28
65846: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
65847: LD_ADDR_VAR 0 11
65851: PUSH
65852: LD_VAR 0 1
65856: PPUSH
65857: CALL_OW 310
65861: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
65862: LD_VAR 0 11
65866: PPUSH
65867: CALL_OW 247
65871: PUSH
65872: LD_INT 2
65874: EQUAL
65875: IFFALSE 65879
// exit ;
65877: GO 66389
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
65879: LD_ADDR_VAR 0 8
65883: PUSH
65884: LD_INT 81
65886: PUSH
65887: LD_VAR 0 9
65891: PUSH
65892: EMPTY
65893: LIST
65894: LIST
65895: PUSH
65896: LD_INT 3
65898: PUSH
65899: LD_INT 21
65901: PUSH
65902: LD_INT 3
65904: PUSH
65905: EMPTY
65906: LIST
65907: LIST
65908: PUSH
65909: EMPTY
65910: LIST
65911: LIST
65912: PUSH
65913: EMPTY
65914: LIST
65915: LIST
65916: PPUSH
65917: CALL_OW 69
65921: ST_TO_ADDR
// if not tmp then
65922: LD_VAR 0 8
65926: NOT
65927: IFFALSE 65931
// exit ;
65929: GO 66389
// if in_unit then
65931: LD_VAR 0 11
65935: IFFALSE 65959
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65937: LD_ADDR_VAR 0 10
65941: PUSH
65942: LD_VAR 0 8
65946: PPUSH
65947: LD_VAR 0 11
65951: PPUSH
65952: CALL_OW 74
65956: ST_TO_ADDR
65957: GO 65979
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65959: LD_ADDR_VAR 0 10
65963: PUSH
65964: LD_VAR 0 8
65968: PPUSH
65969: LD_VAR 0 1
65973: PPUSH
65974: CALL_OW 74
65978: ST_TO_ADDR
// if not enemy then
65979: LD_VAR 0 10
65983: NOT
65984: IFFALSE 65988
// exit ;
65986: GO 66389
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65988: LD_VAR 0 11
65992: PUSH
65993: LD_VAR 0 11
65997: PPUSH
65998: LD_VAR 0 10
66002: PPUSH
66003: CALL_OW 296
66007: PUSH
66008: LD_INT 13
66010: GREATER
66011: AND
66012: PUSH
66013: LD_VAR 0 1
66017: PPUSH
66018: LD_VAR 0 10
66022: PPUSH
66023: CALL_OW 296
66027: PUSH
66028: LD_INT 12
66030: GREATER
66031: OR
66032: IFFALSE 66036
// exit ;
66034: GO 66389
// missile := [ 1 ] ;
66036: LD_ADDR_VAR 0 14
66040: PUSH
66041: LD_INT 1
66043: PUSH
66044: EMPTY
66045: LIST
66046: ST_TO_ADDR
// if Researched ( side , tech_space ) then
66047: LD_VAR 0 9
66051: PPUSH
66052: LD_VAR 0 12
66056: PPUSH
66057: CALL_OW 325
66061: IFFALSE 66090
// missile := Insert ( missile , missile + 1 , 2 ) ;
66063: LD_ADDR_VAR 0 14
66067: PUSH
66068: LD_VAR 0 14
66072: PPUSH
66073: LD_VAR 0 14
66077: PUSH
66078: LD_INT 1
66080: PLUS
66081: PPUSH
66082: LD_INT 2
66084: PPUSH
66085: CALL_OW 2
66089: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
66090: LD_VAR 0 9
66094: PPUSH
66095: LD_VAR 0 13
66099: PPUSH
66100: CALL_OW 325
66104: PUSH
66105: LD_VAR 0 10
66109: PPUSH
66110: CALL_OW 255
66114: PPUSH
66115: LD_VAR 0 13
66119: PPUSH
66120: CALL_OW 325
66124: NOT
66125: AND
66126: IFFALSE 66155
// missile := Insert ( missile , missile + 1 , 3 ) ;
66128: LD_ADDR_VAR 0 14
66132: PUSH
66133: LD_VAR 0 14
66137: PPUSH
66138: LD_VAR 0 14
66142: PUSH
66143: LD_INT 1
66145: PLUS
66146: PPUSH
66147: LD_INT 3
66149: PPUSH
66150: CALL_OW 2
66154: ST_TO_ADDR
// if missile < 2 then
66155: LD_VAR 0 14
66159: PUSH
66160: LD_INT 2
66162: LESS
66163: IFFALSE 66167
// exit ;
66165: GO 66389
// x := GetX ( enemy ) ;
66167: LD_ADDR_VAR 0 4
66171: PUSH
66172: LD_VAR 0 10
66176: PPUSH
66177: CALL_OW 250
66181: ST_TO_ADDR
// y := GetY ( enemy ) ;
66182: LD_ADDR_VAR 0 5
66186: PUSH
66187: LD_VAR 0 10
66191: PPUSH
66192: CALL_OW 251
66196: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
66197: LD_ADDR_VAR 0 6
66201: PUSH
66202: LD_VAR 0 4
66206: PUSH
66207: LD_INT 1
66209: NEG
66210: PPUSH
66211: LD_INT 1
66213: PPUSH
66214: CALL_OW 12
66218: PLUS
66219: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
66220: LD_ADDR_VAR 0 7
66224: PUSH
66225: LD_VAR 0 5
66229: PUSH
66230: LD_INT 1
66232: NEG
66233: PPUSH
66234: LD_INT 1
66236: PPUSH
66237: CALL_OW 12
66241: PLUS
66242: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66243: LD_VAR 0 6
66247: PPUSH
66248: LD_VAR 0 7
66252: PPUSH
66253: CALL_OW 488
66257: NOT
66258: IFFALSE 66280
// begin _x := x ;
66260: LD_ADDR_VAR 0 6
66264: PUSH
66265: LD_VAR 0 4
66269: ST_TO_ADDR
// _y := y ;
66270: LD_ADDR_VAR 0 7
66274: PUSH
66275: LD_VAR 0 5
66279: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
66280: LD_ADDR_VAR 0 3
66284: PUSH
66285: LD_INT 1
66287: PPUSH
66288: LD_VAR 0 14
66292: PPUSH
66293: CALL_OW 12
66297: ST_TO_ADDR
// case i of 1 :
66298: LD_VAR 0 3
66302: PUSH
66303: LD_INT 1
66305: DOUBLE
66306: EQUAL
66307: IFTRUE 66311
66309: GO 66328
66311: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
66312: LD_VAR 0 1
66316: PPUSH
66317: LD_VAR 0 10
66321: PPUSH
66322: CALL_OW 115
66326: GO 66389
66328: LD_INT 2
66330: DOUBLE
66331: EQUAL
66332: IFTRUE 66336
66334: GO 66358
66336: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
66337: LD_VAR 0 1
66341: PPUSH
66342: LD_VAR 0 6
66346: PPUSH
66347: LD_VAR 0 7
66351: PPUSH
66352: CALL_OW 153
66356: GO 66389
66358: LD_INT 3
66360: DOUBLE
66361: EQUAL
66362: IFTRUE 66366
66364: GO 66388
66366: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
66367: LD_VAR 0 1
66371: PPUSH
66372: LD_VAR 0 6
66376: PPUSH
66377: LD_VAR 0 7
66381: PPUSH
66382: CALL_OW 154
66386: GO 66389
66388: POP
// end ;
66389: LD_VAR 0 2
66393: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
66394: LD_INT 0
66396: PPUSH
66397: PPUSH
66398: PPUSH
66399: PPUSH
66400: PPUSH
66401: PPUSH
// if not unit or not building then
66402: LD_VAR 0 1
66406: NOT
66407: PUSH
66408: LD_VAR 0 2
66412: NOT
66413: OR
66414: IFFALSE 66418
// exit ;
66416: GO 66576
// x := GetX ( building ) ;
66418: LD_ADDR_VAR 0 5
66422: PUSH
66423: LD_VAR 0 2
66427: PPUSH
66428: CALL_OW 250
66432: ST_TO_ADDR
// y := GetY ( building ) ;
66433: LD_ADDR_VAR 0 6
66437: PUSH
66438: LD_VAR 0 2
66442: PPUSH
66443: CALL_OW 251
66447: ST_TO_ADDR
// for i = 0 to 5 do
66448: LD_ADDR_VAR 0 4
66452: PUSH
66453: DOUBLE
66454: LD_INT 0
66456: DEC
66457: ST_TO_ADDR
66458: LD_INT 5
66460: PUSH
66461: FOR_TO
66462: IFFALSE 66574
// begin _x := ShiftX ( x , i , 3 ) ;
66464: LD_ADDR_VAR 0 7
66468: PUSH
66469: LD_VAR 0 5
66473: PPUSH
66474: LD_VAR 0 4
66478: PPUSH
66479: LD_INT 3
66481: PPUSH
66482: CALL_OW 272
66486: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
66487: LD_ADDR_VAR 0 8
66491: PUSH
66492: LD_VAR 0 6
66496: PPUSH
66497: LD_VAR 0 4
66501: PPUSH
66502: LD_INT 3
66504: PPUSH
66505: CALL_OW 273
66509: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
66510: LD_VAR 0 7
66514: PPUSH
66515: LD_VAR 0 8
66519: PPUSH
66520: CALL_OW 488
66524: NOT
66525: IFFALSE 66529
// continue ;
66527: GO 66461
// if HexInfo ( _x , _y ) = 0 then
66529: LD_VAR 0 7
66533: PPUSH
66534: LD_VAR 0 8
66538: PPUSH
66539: CALL_OW 428
66543: PUSH
66544: LD_INT 0
66546: EQUAL
66547: IFFALSE 66572
// begin ComMoveXY ( unit , _x , _y ) ;
66549: LD_VAR 0 1
66553: PPUSH
66554: LD_VAR 0 7
66558: PPUSH
66559: LD_VAR 0 8
66563: PPUSH
66564: CALL_OW 111
// exit ;
66568: POP
66569: POP
66570: GO 66576
// end ; end ;
66572: GO 66461
66574: POP
66575: POP
// end ;
66576: LD_VAR 0 3
66580: RET
// export function ScanBase ( side , base_area ) ; begin
66581: LD_INT 0
66583: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
66584: LD_ADDR_VAR 0 3
66588: PUSH
66589: LD_VAR 0 2
66593: PPUSH
66594: LD_INT 81
66596: PUSH
66597: LD_VAR 0 1
66601: PUSH
66602: EMPTY
66603: LIST
66604: LIST
66605: PPUSH
66606: CALL_OW 70
66610: ST_TO_ADDR
// end ;
66611: LD_VAR 0 3
66615: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
66616: LD_INT 0
66618: PPUSH
66619: PPUSH
66620: PPUSH
66621: PPUSH
66622: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
66623: LD_VAR 0 1
66627: NOT
66628: PUSH
66629: LD_EXP 102
66633: PUSH
66634: LD_VAR 0 1
66638: ARRAY
66639: NOT
66640: OR
66641: PUSH
66642: LD_VAR 0 2
66646: NOT
66647: OR
66648: PUSH
66649: LD_VAR 0 3
66653: NOT
66654: OR
66655: IFFALSE 66659
// exit ;
66657: GO 67172
// side := mc_sides [ base ] ;
66659: LD_ADDR_VAR 0 6
66663: PUSH
66664: LD_EXP 128
66668: PUSH
66669: LD_VAR 0 1
66673: ARRAY
66674: ST_TO_ADDR
// if not side then
66675: LD_VAR 0 6
66679: NOT
66680: IFFALSE 66684
// exit ;
66682: GO 67172
// for i in solds do
66684: LD_ADDR_VAR 0 7
66688: PUSH
66689: LD_VAR 0 2
66693: PUSH
66694: FOR_IN
66695: IFFALSE 66756
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
66697: LD_VAR 0 7
66701: PPUSH
66702: CALL_OW 310
66706: PPUSH
66707: CALL_OW 266
66711: PUSH
66712: LD_INT 32
66714: PUSH
66715: LD_INT 31
66717: PUSH
66718: EMPTY
66719: LIST
66720: LIST
66721: IN
66722: IFFALSE 66742
// solds := solds diff i else
66724: LD_ADDR_VAR 0 2
66728: PUSH
66729: LD_VAR 0 2
66733: PUSH
66734: LD_VAR 0 7
66738: DIFF
66739: ST_TO_ADDR
66740: GO 66754
// SetTag ( i , 18 ) ;
66742: LD_VAR 0 7
66746: PPUSH
66747: LD_INT 18
66749: PPUSH
66750: CALL_OW 109
66754: GO 66694
66756: POP
66757: POP
// if not solds then
66758: LD_VAR 0 2
66762: NOT
66763: IFFALSE 66767
// exit ;
66765: GO 67172
// repeat wait ( 0 0$1 ) ;
66767: LD_INT 35
66769: PPUSH
66770: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
66774: LD_ADDR_VAR 0 5
66778: PUSH
66779: LD_VAR 0 6
66783: PPUSH
66784: LD_VAR 0 3
66788: PPUSH
66789: CALL 66581 0 2
66793: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66794: LD_EXP 102
66798: PUSH
66799: LD_VAR 0 1
66803: ARRAY
66804: NOT
66805: PUSH
66806: LD_EXP 102
66810: PUSH
66811: LD_VAR 0 1
66815: ARRAY
66816: PUSH
66817: EMPTY
66818: EQUAL
66819: OR
66820: IFFALSE 66857
// begin for i in solds do
66822: LD_ADDR_VAR 0 7
66826: PUSH
66827: LD_VAR 0 2
66831: PUSH
66832: FOR_IN
66833: IFFALSE 66846
// ComStop ( i ) ;
66835: LD_VAR 0 7
66839: PPUSH
66840: CALL_OW 141
66844: GO 66832
66846: POP
66847: POP
// solds := [ ] ;
66848: LD_ADDR_VAR 0 2
66852: PUSH
66853: EMPTY
66854: ST_TO_ADDR
// exit ;
66855: GO 67172
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
66857: LD_VAR 0 5
66861: NOT
66862: PUSH
66863: LD_VAR 0 5
66867: PUSH
66868: LD_INT 3
66870: GREATER
66871: OR
66872: PUSH
66873: LD_EXP 124
66877: PUSH
66878: LD_VAR 0 1
66882: ARRAY
66883: OR
66884: IFFALSE 66925
// begin for i in solds do
66886: LD_ADDR_VAR 0 7
66890: PUSH
66891: LD_VAR 0 2
66895: PUSH
66896: FOR_IN
66897: IFFALSE 66921
// if HasTask ( i ) then
66899: LD_VAR 0 7
66903: PPUSH
66904: CALL_OW 314
66908: IFFALSE 66919
// ComStop ( i ) ;
66910: LD_VAR 0 7
66914: PPUSH
66915: CALL_OW 141
66919: GO 66896
66921: POP
66922: POP
// break ;
66923: GO 67160
// end ; for i in solds do
66925: LD_ADDR_VAR 0 7
66929: PUSH
66930: LD_VAR 0 2
66934: PUSH
66935: FOR_IN
66936: IFFALSE 67152
// begin if IsInUnit ( i ) then
66938: LD_VAR 0 7
66942: PPUSH
66943: CALL_OW 310
66947: IFFALSE 66958
// ComExitBuilding ( i ) ;
66949: LD_VAR 0 7
66953: PPUSH
66954: CALL_OW 122
// if GetLives ( i ) > 333 then
66958: LD_VAR 0 7
66962: PPUSH
66963: CALL_OW 256
66967: PUSH
66968: LD_INT 333
66970: GREATER
66971: IFFALSE 66999
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66973: LD_VAR 0 7
66977: PPUSH
66978: LD_VAR 0 5
66982: PPUSH
66983: LD_VAR 0 7
66987: PPUSH
66988: CALL_OW 74
66992: PPUSH
66993: CALL_OW 115
66997: GO 67150
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66999: LD_ADDR_VAR 0 8
67003: PUSH
67004: LD_EXP 102
67008: PUSH
67009: LD_VAR 0 1
67013: ARRAY
67014: PPUSH
67015: LD_INT 2
67017: PUSH
67018: LD_INT 30
67020: PUSH
67021: LD_INT 0
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: PUSH
67028: LD_INT 30
67030: PUSH
67031: LD_INT 1
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: PUSH
67038: LD_INT 30
67040: PUSH
67041: LD_INT 6
67043: PUSH
67044: EMPTY
67045: LIST
67046: LIST
67047: PUSH
67048: EMPTY
67049: LIST
67050: LIST
67051: LIST
67052: LIST
67053: PPUSH
67054: CALL_OW 72
67058: PPUSH
67059: LD_VAR 0 7
67063: PPUSH
67064: CALL_OW 74
67068: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
67069: LD_VAR 0 7
67073: PPUSH
67074: LD_VAR 0 8
67078: PPUSH
67079: CALL_OW 250
67083: PPUSH
67084: LD_INT 3
67086: PPUSH
67087: LD_INT 5
67089: PPUSH
67090: CALL_OW 272
67094: PPUSH
67095: LD_VAR 0 8
67099: PPUSH
67100: CALL_OW 251
67104: PPUSH
67105: LD_INT 3
67107: PPUSH
67108: LD_INT 5
67110: PPUSH
67111: CALL_OW 273
67115: PPUSH
67116: CALL_OW 111
// SetTag ( i , 0 ) ;
67120: LD_VAR 0 7
67124: PPUSH
67125: LD_INT 0
67127: PPUSH
67128: CALL_OW 109
// solds := solds diff i ;
67132: LD_ADDR_VAR 0 2
67136: PUSH
67137: LD_VAR 0 2
67141: PUSH
67142: LD_VAR 0 7
67146: DIFF
67147: ST_TO_ADDR
// continue ;
67148: GO 66935
// end ; end ;
67150: GO 66935
67152: POP
67153: POP
// until solds ;
67154: LD_VAR 0 2
67158: IFFALSE 66767
// MC_Reset ( base , 18 ) ;
67160: LD_VAR 0 1
67164: PPUSH
67165: LD_INT 18
67167: PPUSH
67168: CALL 38933 0 2
// end ;
67172: LD_VAR 0 4
67176: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
67177: LD_INT 0
67179: PPUSH
67180: PPUSH
67181: PPUSH
67182: PPUSH
67183: PPUSH
67184: PPUSH
67185: PPUSH
67186: PPUSH
67187: PPUSH
67188: PPUSH
67189: PPUSH
67190: PPUSH
67191: PPUSH
67192: PPUSH
67193: PPUSH
67194: PPUSH
67195: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
67196: LD_ADDR_VAR 0 13
67200: PUSH
67201: LD_EXP 102
67205: PUSH
67206: LD_VAR 0 1
67210: ARRAY
67211: PPUSH
67212: LD_INT 25
67214: PUSH
67215: LD_INT 3
67217: PUSH
67218: EMPTY
67219: LIST
67220: LIST
67221: PPUSH
67222: CALL_OW 72
67226: ST_TO_ADDR
// if mc_remote_driver [ base ] then
67227: LD_EXP 142
67231: PUSH
67232: LD_VAR 0 1
67236: ARRAY
67237: IFFALSE 67261
// mechs := mechs diff mc_remote_driver [ base ] ;
67239: LD_ADDR_VAR 0 13
67243: PUSH
67244: LD_VAR 0 13
67248: PUSH
67249: LD_EXP 142
67253: PUSH
67254: LD_VAR 0 1
67258: ARRAY
67259: DIFF
67260: ST_TO_ADDR
// for i in mechs do
67261: LD_ADDR_VAR 0 5
67265: PUSH
67266: LD_VAR 0 13
67270: PUSH
67271: FOR_IN
67272: IFFALSE 67307
// if GetTag ( i ) > 0 then
67274: LD_VAR 0 5
67278: PPUSH
67279: CALL_OW 110
67283: PUSH
67284: LD_INT 0
67286: GREATER
67287: IFFALSE 67305
// mechs := mechs diff i ;
67289: LD_ADDR_VAR 0 13
67293: PUSH
67294: LD_VAR 0 13
67298: PUSH
67299: LD_VAR 0 5
67303: DIFF
67304: ST_TO_ADDR
67305: GO 67271
67307: POP
67308: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67309: LD_ADDR_VAR 0 9
67313: PUSH
67314: LD_EXP 102
67318: PUSH
67319: LD_VAR 0 1
67323: ARRAY
67324: PPUSH
67325: LD_INT 2
67327: PUSH
67328: LD_INT 25
67330: PUSH
67331: LD_INT 1
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: PUSH
67338: LD_INT 25
67340: PUSH
67341: LD_INT 5
67343: PUSH
67344: EMPTY
67345: LIST
67346: LIST
67347: PUSH
67348: LD_INT 25
67350: PUSH
67351: LD_INT 8
67353: PUSH
67354: EMPTY
67355: LIST
67356: LIST
67357: PUSH
67358: LD_INT 25
67360: PUSH
67361: LD_INT 9
67363: PUSH
67364: EMPTY
67365: LIST
67366: LIST
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: LIST
67372: LIST
67373: LIST
67374: PPUSH
67375: CALL_OW 72
67379: ST_TO_ADDR
// if not defenders and not solds then
67380: LD_VAR 0 2
67384: NOT
67385: PUSH
67386: LD_VAR 0 9
67390: NOT
67391: AND
67392: IFFALSE 67396
// exit ;
67394: GO 69022
// depot_under_attack := false ;
67396: LD_ADDR_VAR 0 17
67400: PUSH
67401: LD_INT 0
67403: ST_TO_ADDR
// sold_defenders := [ ] ;
67404: LD_ADDR_VAR 0 18
67408: PUSH
67409: EMPTY
67410: ST_TO_ADDR
// if mechs then
67411: LD_VAR 0 13
67415: IFFALSE 67544
// for i in defenders do
67417: LD_ADDR_VAR 0 5
67421: PUSH
67422: LD_VAR 0 2
67426: PUSH
67427: FOR_IN
67428: IFFALSE 67542
// begin SetTag ( i , 20 ) ;
67430: LD_VAR 0 5
67434: PPUSH
67435: LD_INT 20
67437: PPUSH
67438: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
67442: LD_VAR 0 5
67446: PPUSH
67447: CALL_OW 263
67451: PUSH
67452: LD_INT 1
67454: EQUAL
67455: PUSH
67456: LD_VAR 0 5
67460: PPUSH
67461: CALL_OW 311
67465: NOT
67466: AND
67467: PUSH
67468: LD_VAR 0 13
67472: AND
67473: IFFALSE 67540
// begin un := mechs [ 1 ] ;
67475: LD_ADDR_VAR 0 11
67479: PUSH
67480: LD_VAR 0 13
67484: PUSH
67485: LD_INT 1
67487: ARRAY
67488: ST_TO_ADDR
// ComExitBuilding ( un ) ;
67489: LD_VAR 0 11
67493: PPUSH
67494: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
67498: LD_VAR 0 11
67502: PPUSH
67503: LD_VAR 0 5
67507: PPUSH
67508: CALL_OW 180
// SetTag ( un , 19 ) ;
67512: LD_VAR 0 11
67516: PPUSH
67517: LD_INT 19
67519: PPUSH
67520: CALL_OW 109
// mechs := mechs diff un ;
67524: LD_ADDR_VAR 0 13
67528: PUSH
67529: LD_VAR 0 13
67533: PUSH
67534: LD_VAR 0 11
67538: DIFF
67539: ST_TO_ADDR
// end ; end ;
67540: GO 67427
67542: POP
67543: POP
// if solds then
67544: LD_VAR 0 9
67548: IFFALSE 67607
// for i in solds do
67550: LD_ADDR_VAR 0 5
67554: PUSH
67555: LD_VAR 0 9
67559: PUSH
67560: FOR_IN
67561: IFFALSE 67605
// if not GetTag ( i ) then
67563: LD_VAR 0 5
67567: PPUSH
67568: CALL_OW 110
67572: NOT
67573: IFFALSE 67603
// begin defenders := defenders union i ;
67575: LD_ADDR_VAR 0 2
67579: PUSH
67580: LD_VAR 0 2
67584: PUSH
67585: LD_VAR 0 5
67589: UNION
67590: ST_TO_ADDR
// SetTag ( i , 18 ) ;
67591: LD_VAR 0 5
67595: PPUSH
67596: LD_INT 18
67598: PPUSH
67599: CALL_OW 109
// end ;
67603: GO 67560
67605: POP
67606: POP
// repeat wait ( 0 0$1 ) ;
67607: LD_INT 35
67609: PPUSH
67610: CALL_OW 67
// enemy := mc_scan [ base ] ;
67614: LD_ADDR_VAR 0 3
67618: PUSH
67619: LD_EXP 125
67623: PUSH
67624: LD_VAR 0 1
67628: ARRAY
67629: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67630: LD_EXP 102
67634: PUSH
67635: LD_VAR 0 1
67639: ARRAY
67640: NOT
67641: PUSH
67642: LD_EXP 102
67646: PUSH
67647: LD_VAR 0 1
67651: ARRAY
67652: PUSH
67653: EMPTY
67654: EQUAL
67655: OR
67656: IFFALSE 67693
// begin for i in defenders do
67658: LD_ADDR_VAR 0 5
67662: PUSH
67663: LD_VAR 0 2
67667: PUSH
67668: FOR_IN
67669: IFFALSE 67682
// ComStop ( i ) ;
67671: LD_VAR 0 5
67675: PPUSH
67676: CALL_OW 141
67680: GO 67668
67682: POP
67683: POP
// defenders := [ ] ;
67684: LD_ADDR_VAR 0 2
67688: PUSH
67689: EMPTY
67690: ST_TO_ADDR
// exit ;
67691: GO 69022
// end ; for i in defenders do
67693: LD_ADDR_VAR 0 5
67697: PUSH
67698: LD_VAR 0 2
67702: PUSH
67703: FOR_IN
67704: IFFALSE 68522
// begin e := NearestUnitToUnit ( enemy , i ) ;
67706: LD_ADDR_VAR 0 14
67710: PUSH
67711: LD_VAR 0 3
67715: PPUSH
67716: LD_VAR 0 5
67720: PPUSH
67721: CALL_OW 74
67725: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67726: LD_ADDR_VAR 0 8
67730: PUSH
67731: LD_EXP 102
67735: PUSH
67736: LD_VAR 0 1
67740: ARRAY
67741: PPUSH
67742: LD_INT 2
67744: PUSH
67745: LD_INT 30
67747: PUSH
67748: LD_INT 0
67750: PUSH
67751: EMPTY
67752: LIST
67753: LIST
67754: PUSH
67755: LD_INT 30
67757: PUSH
67758: LD_INT 1
67760: PUSH
67761: EMPTY
67762: LIST
67763: LIST
67764: PUSH
67765: EMPTY
67766: LIST
67767: LIST
67768: LIST
67769: PPUSH
67770: CALL_OW 72
67774: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
67775: LD_ADDR_VAR 0 17
67779: PUSH
67780: LD_VAR 0 8
67784: NOT
67785: PUSH
67786: LD_VAR 0 8
67790: PPUSH
67791: LD_INT 3
67793: PUSH
67794: LD_INT 24
67796: PUSH
67797: LD_INT 600
67799: PUSH
67800: EMPTY
67801: LIST
67802: LIST
67803: PUSH
67804: EMPTY
67805: LIST
67806: LIST
67807: PPUSH
67808: CALL_OW 72
67812: OR
67813: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
67814: LD_VAR 0 5
67818: PPUSH
67819: CALL_OW 247
67823: PUSH
67824: LD_INT 2
67826: DOUBLE
67827: EQUAL
67828: IFTRUE 67832
67830: GO 68228
67832: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
67833: LD_VAR 0 5
67837: PPUSH
67838: CALL_OW 256
67842: PUSH
67843: LD_INT 650
67845: GREATER
67846: PUSH
67847: LD_VAR 0 5
67851: PPUSH
67852: LD_VAR 0 14
67856: PPUSH
67857: CALL_OW 296
67861: PUSH
67862: LD_INT 40
67864: LESS
67865: PUSH
67866: LD_VAR 0 14
67870: PPUSH
67871: LD_EXP 127
67875: PUSH
67876: LD_VAR 0 1
67880: ARRAY
67881: PPUSH
67882: CALL_OW 308
67886: OR
67887: AND
67888: IFFALSE 68010
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
67890: LD_VAR 0 5
67894: PPUSH
67895: CALL_OW 262
67899: PUSH
67900: LD_INT 1
67902: EQUAL
67903: PUSH
67904: LD_VAR 0 5
67908: PPUSH
67909: CALL_OW 261
67913: PUSH
67914: LD_INT 30
67916: LESS
67917: AND
67918: PUSH
67919: LD_VAR 0 8
67923: AND
67924: IFFALSE 67994
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
67926: LD_VAR 0 5
67930: PPUSH
67931: LD_VAR 0 8
67935: PPUSH
67936: LD_VAR 0 5
67940: PPUSH
67941: CALL_OW 74
67945: PPUSH
67946: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
67950: LD_VAR 0 5
67954: PPUSH
67955: LD_VAR 0 8
67959: PPUSH
67960: LD_VAR 0 5
67964: PPUSH
67965: CALL_OW 74
67969: PPUSH
67970: CALL_OW 296
67974: PUSH
67975: LD_INT 6
67977: LESS
67978: IFFALSE 67992
// SetFuel ( i , 100 ) ;
67980: LD_VAR 0 5
67984: PPUSH
67985: LD_INT 100
67987: PPUSH
67988: CALL_OW 240
// end else
67992: GO 68008
// ComAttackUnit ( i , e ) ;
67994: LD_VAR 0 5
67998: PPUSH
67999: LD_VAR 0 14
68003: PPUSH
68004: CALL_OW 115
// end else
68008: GO 68111
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
68010: LD_VAR 0 14
68014: PPUSH
68015: LD_EXP 127
68019: PUSH
68020: LD_VAR 0 1
68024: ARRAY
68025: PPUSH
68026: CALL_OW 308
68030: NOT
68031: PUSH
68032: LD_VAR 0 5
68036: PPUSH
68037: LD_VAR 0 14
68041: PPUSH
68042: CALL_OW 296
68046: PUSH
68047: LD_INT 40
68049: GREATEREQUAL
68050: AND
68051: PUSH
68052: LD_VAR 0 5
68056: PPUSH
68057: CALL_OW 256
68061: PUSH
68062: LD_INT 650
68064: LESSEQUAL
68065: OR
68066: PUSH
68067: LD_VAR 0 5
68071: PPUSH
68072: LD_EXP 126
68076: PUSH
68077: LD_VAR 0 1
68081: ARRAY
68082: PPUSH
68083: CALL_OW 308
68087: NOT
68088: AND
68089: IFFALSE 68111
// ComMoveToArea ( i , mc_parking [ base ] ) ;
68091: LD_VAR 0 5
68095: PPUSH
68096: LD_EXP 126
68100: PUSH
68101: LD_VAR 0 1
68105: ARRAY
68106: PPUSH
68107: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
68111: LD_VAR 0 5
68115: PPUSH
68116: CALL_OW 256
68120: PUSH
68121: LD_INT 998
68123: LESS
68124: PUSH
68125: LD_VAR 0 5
68129: PPUSH
68130: CALL_OW 263
68134: PUSH
68135: LD_INT 1
68137: EQUAL
68138: AND
68139: PUSH
68140: LD_VAR 0 5
68144: PPUSH
68145: CALL_OW 311
68149: AND
68150: PUSH
68151: LD_VAR 0 5
68155: PPUSH
68156: LD_EXP 126
68160: PUSH
68161: LD_VAR 0 1
68165: ARRAY
68166: PPUSH
68167: CALL_OW 308
68171: AND
68172: IFFALSE 68226
// begin mech := IsDrivenBy ( i ) ;
68174: LD_ADDR_VAR 0 10
68178: PUSH
68179: LD_VAR 0 5
68183: PPUSH
68184: CALL_OW 311
68188: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
68189: LD_VAR 0 10
68193: PPUSH
68194: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
68198: LD_VAR 0 10
68202: PPUSH
68203: LD_VAR 0 5
68207: PPUSH
68208: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
68212: LD_VAR 0 10
68216: PPUSH
68217: LD_VAR 0 5
68221: PPUSH
68222: CALL_OW 180
// end ; end ; unit_human :
68226: GO 68493
68228: LD_INT 1
68230: DOUBLE
68231: EQUAL
68232: IFTRUE 68236
68234: GO 68492
68236: POP
// begin b := IsInUnit ( i ) ;
68237: LD_ADDR_VAR 0 19
68241: PUSH
68242: LD_VAR 0 5
68246: PPUSH
68247: CALL_OW 310
68251: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
68252: LD_ADDR_VAR 0 20
68256: PUSH
68257: LD_VAR 0 19
68261: NOT
68262: PUSH
68263: LD_VAR 0 19
68267: PPUSH
68268: CALL_OW 266
68272: PUSH
68273: LD_INT 32
68275: PUSH
68276: LD_INT 31
68278: PUSH
68279: EMPTY
68280: LIST
68281: LIST
68282: IN
68283: OR
68284: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
68285: LD_VAR 0 17
68289: PUSH
68290: LD_VAR 0 2
68294: PPUSH
68295: LD_INT 21
68297: PUSH
68298: LD_INT 2
68300: PUSH
68301: EMPTY
68302: LIST
68303: LIST
68304: PPUSH
68305: CALL_OW 72
68309: PUSH
68310: LD_INT 1
68312: LESSEQUAL
68313: OR
68314: PUSH
68315: LD_VAR 0 20
68319: AND
68320: PUSH
68321: LD_VAR 0 5
68325: PUSH
68326: LD_VAR 0 18
68330: IN
68331: NOT
68332: AND
68333: IFFALSE 68426
// begin if b then
68335: LD_VAR 0 19
68339: IFFALSE 68388
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
68341: LD_VAR 0 19
68345: PPUSH
68346: LD_VAR 0 3
68350: PPUSH
68351: LD_VAR 0 19
68355: PPUSH
68356: CALL_OW 74
68360: PPUSH
68361: CALL_OW 296
68365: PUSH
68366: LD_INT 10
68368: LESS
68369: PUSH
68370: LD_VAR 0 19
68374: PPUSH
68375: CALL_OW 461
68379: PUSH
68380: LD_INT 7
68382: NONEQUAL
68383: AND
68384: IFFALSE 68388
// continue ;
68386: GO 67703
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
68388: LD_ADDR_VAR 0 18
68392: PUSH
68393: LD_VAR 0 18
68397: PPUSH
68398: LD_VAR 0 18
68402: PUSH
68403: LD_INT 1
68405: PLUS
68406: PPUSH
68407: LD_VAR 0 5
68411: PPUSH
68412: CALL_OW 1
68416: ST_TO_ADDR
// ComExitBuilding ( i ) ;
68417: LD_VAR 0 5
68421: PPUSH
68422: CALL_OW 122
// end ; if sold_defenders then
68426: LD_VAR 0 18
68430: IFFALSE 68490
// if i in sold_defenders then
68432: LD_VAR 0 5
68436: PUSH
68437: LD_VAR 0 18
68441: IN
68442: IFFALSE 68490
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
68444: LD_VAR 0 5
68448: PPUSH
68449: CALL_OW 314
68453: NOT
68454: PUSH
68455: LD_VAR 0 5
68459: PPUSH
68460: LD_VAR 0 14
68464: PPUSH
68465: CALL_OW 296
68469: PUSH
68470: LD_INT 30
68472: LESS
68473: AND
68474: IFFALSE 68490
// ComAttackUnit ( i , e ) ;
68476: LD_VAR 0 5
68480: PPUSH
68481: LD_VAR 0 14
68485: PPUSH
68486: CALL_OW 115
// end ; end ; end ;
68490: GO 68493
68492: POP
// if IsDead ( i ) then
68493: LD_VAR 0 5
68497: PPUSH
68498: CALL_OW 301
68502: IFFALSE 68520
// defenders := defenders diff i ;
68504: LD_ADDR_VAR 0 2
68508: PUSH
68509: LD_VAR 0 2
68513: PUSH
68514: LD_VAR 0 5
68518: DIFF
68519: ST_TO_ADDR
// end ;
68520: GO 67703
68522: POP
68523: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
68524: LD_VAR 0 3
68528: NOT
68529: PUSH
68530: LD_VAR 0 2
68534: NOT
68535: OR
68536: PUSH
68537: LD_EXP 102
68541: PUSH
68542: LD_VAR 0 1
68546: ARRAY
68547: NOT
68548: OR
68549: IFFALSE 67607
// MC_Reset ( base , 18 ) ;
68551: LD_VAR 0 1
68555: PPUSH
68556: LD_INT 18
68558: PPUSH
68559: CALL 38933 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68563: LD_ADDR_VAR 0 2
68567: PUSH
68568: LD_VAR 0 2
68572: PUSH
68573: LD_VAR 0 2
68577: PPUSH
68578: LD_INT 2
68580: PUSH
68581: LD_INT 25
68583: PUSH
68584: LD_INT 1
68586: PUSH
68587: EMPTY
68588: LIST
68589: LIST
68590: PUSH
68591: LD_INT 25
68593: PUSH
68594: LD_INT 5
68596: PUSH
68597: EMPTY
68598: LIST
68599: LIST
68600: PUSH
68601: LD_INT 25
68603: PUSH
68604: LD_INT 8
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: PUSH
68611: LD_INT 25
68613: PUSH
68614: LD_INT 9
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: LIST
68625: LIST
68626: LIST
68627: PPUSH
68628: CALL_OW 72
68632: DIFF
68633: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
68634: LD_VAR 0 3
68638: NOT
68639: PUSH
68640: LD_VAR 0 2
68644: PPUSH
68645: LD_INT 21
68647: PUSH
68648: LD_INT 2
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PPUSH
68655: CALL_OW 72
68659: AND
68660: IFFALSE 68998
// begin tmp := FilterByTag ( defenders , 19 ) ;
68662: LD_ADDR_VAR 0 12
68666: PUSH
68667: LD_VAR 0 2
68671: PPUSH
68672: LD_INT 19
68674: PPUSH
68675: CALL 105461 0 2
68679: ST_TO_ADDR
// if tmp then
68680: LD_VAR 0 12
68684: IFFALSE 68754
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
68686: LD_ADDR_VAR 0 12
68690: PUSH
68691: LD_VAR 0 12
68695: PPUSH
68696: LD_INT 25
68698: PUSH
68699: LD_INT 3
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: PPUSH
68706: CALL_OW 72
68710: ST_TO_ADDR
// if tmp then
68711: LD_VAR 0 12
68715: IFFALSE 68754
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
68717: LD_ADDR_EXP 114
68721: PUSH
68722: LD_EXP 114
68726: PPUSH
68727: LD_VAR 0 1
68731: PPUSH
68732: LD_EXP 114
68736: PUSH
68737: LD_VAR 0 1
68741: ARRAY
68742: PUSH
68743: LD_VAR 0 12
68747: UNION
68748: PPUSH
68749: CALL_OW 1
68753: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
68754: LD_VAR 0 1
68758: PPUSH
68759: LD_INT 19
68761: PPUSH
68762: CALL 38933 0 2
// repeat wait ( 0 0$1 ) ;
68766: LD_INT 35
68768: PPUSH
68769: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
68773: LD_EXP 102
68777: PUSH
68778: LD_VAR 0 1
68782: ARRAY
68783: NOT
68784: PUSH
68785: LD_EXP 102
68789: PUSH
68790: LD_VAR 0 1
68794: ARRAY
68795: PUSH
68796: EMPTY
68797: EQUAL
68798: OR
68799: IFFALSE 68836
// begin for i in defenders do
68801: LD_ADDR_VAR 0 5
68805: PUSH
68806: LD_VAR 0 2
68810: PUSH
68811: FOR_IN
68812: IFFALSE 68825
// ComStop ( i ) ;
68814: LD_VAR 0 5
68818: PPUSH
68819: CALL_OW 141
68823: GO 68811
68825: POP
68826: POP
// defenders := [ ] ;
68827: LD_ADDR_VAR 0 2
68831: PUSH
68832: EMPTY
68833: ST_TO_ADDR
// exit ;
68834: GO 69022
// end ; for i in defenders do
68836: LD_ADDR_VAR 0 5
68840: PUSH
68841: LD_VAR 0 2
68845: PUSH
68846: FOR_IN
68847: IFFALSE 68936
// begin if not IsInArea ( i , mc_parking [ base ] ) then
68849: LD_VAR 0 5
68853: PPUSH
68854: LD_EXP 126
68858: PUSH
68859: LD_VAR 0 1
68863: ARRAY
68864: PPUSH
68865: CALL_OW 308
68869: NOT
68870: IFFALSE 68894
// ComMoveToArea ( i , mc_parking [ base ] ) else
68872: LD_VAR 0 5
68876: PPUSH
68877: LD_EXP 126
68881: PUSH
68882: LD_VAR 0 1
68886: ARRAY
68887: PPUSH
68888: CALL_OW 113
68892: GO 68934
// if GetControl ( i ) = control_manual then
68894: LD_VAR 0 5
68898: PPUSH
68899: CALL_OW 263
68903: PUSH
68904: LD_INT 1
68906: EQUAL
68907: IFFALSE 68934
// if IsDrivenBy ( i ) then
68909: LD_VAR 0 5
68913: PPUSH
68914: CALL_OW 311
68918: IFFALSE 68934
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
68920: LD_VAR 0 5
68924: PPUSH
68925: CALL_OW 311
68929: PPUSH
68930: CALL_OW 121
// end ;
68934: GO 68846
68936: POP
68937: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
68938: LD_VAR 0 2
68942: PPUSH
68943: LD_INT 95
68945: PUSH
68946: LD_EXP 126
68950: PUSH
68951: LD_VAR 0 1
68955: ARRAY
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PPUSH
68961: CALL_OW 72
68965: PUSH
68966: LD_VAR 0 2
68970: EQUAL
68971: PUSH
68972: LD_EXP 125
68976: PUSH
68977: LD_VAR 0 1
68981: ARRAY
68982: OR
68983: PUSH
68984: LD_EXP 102
68988: PUSH
68989: LD_VAR 0 1
68993: ARRAY
68994: NOT
68995: OR
68996: IFFALSE 68766
// end ; MC_Reset ( base , 19 ) ;
68998: LD_VAR 0 1
69002: PPUSH
69003: LD_INT 19
69005: PPUSH
69006: CALL 38933 0 2
// MC_Reset ( base , 20 ) ;
69010: LD_VAR 0 1
69014: PPUSH
69015: LD_INT 20
69017: PPUSH
69018: CALL 38933 0 2
// end ;
69022: LD_VAR 0 4
69026: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
69027: LD_INT 0
69029: PPUSH
69030: PPUSH
69031: PPUSH
69032: PPUSH
// result := false ;
69033: LD_ADDR_VAR 0 2
69037: PUSH
69038: LD_INT 0
69040: ST_TO_ADDR
// side := GetSide ( unit ) ;
69041: LD_ADDR_VAR 0 3
69045: PUSH
69046: LD_VAR 0 1
69050: PPUSH
69051: CALL_OW 255
69055: ST_TO_ADDR
// nat := GetNation ( unit ) ;
69056: LD_ADDR_VAR 0 4
69060: PUSH
69061: LD_VAR 0 1
69065: PPUSH
69066: CALL_OW 248
69070: ST_TO_ADDR
// case nat of 1 :
69071: LD_VAR 0 4
69075: PUSH
69076: LD_INT 1
69078: DOUBLE
69079: EQUAL
69080: IFTRUE 69084
69082: GO 69095
69084: POP
// tech := tech_lassight ; 2 :
69085: LD_ADDR_VAR 0 5
69089: PUSH
69090: LD_INT 12
69092: ST_TO_ADDR
69093: GO 69134
69095: LD_INT 2
69097: DOUBLE
69098: EQUAL
69099: IFTRUE 69103
69101: GO 69114
69103: POP
// tech := tech_mortar ; 3 :
69104: LD_ADDR_VAR 0 5
69108: PUSH
69109: LD_INT 41
69111: ST_TO_ADDR
69112: GO 69134
69114: LD_INT 3
69116: DOUBLE
69117: EQUAL
69118: IFTRUE 69122
69120: GO 69133
69122: POP
// tech := tech_bazooka ; end ;
69123: LD_ADDR_VAR 0 5
69127: PUSH
69128: LD_INT 44
69130: ST_TO_ADDR
69131: GO 69134
69133: POP
// if Researched ( side , tech ) then
69134: LD_VAR 0 3
69138: PPUSH
69139: LD_VAR 0 5
69143: PPUSH
69144: CALL_OW 325
69148: IFFALSE 69175
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
69150: LD_ADDR_VAR 0 2
69154: PUSH
69155: LD_INT 5
69157: PUSH
69158: LD_INT 8
69160: PUSH
69161: LD_INT 9
69163: PUSH
69164: EMPTY
69165: LIST
69166: LIST
69167: LIST
69168: PUSH
69169: LD_VAR 0 4
69173: ARRAY
69174: ST_TO_ADDR
// end ;
69175: LD_VAR 0 2
69179: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
69180: LD_INT 0
69182: PPUSH
69183: PPUSH
69184: PPUSH
// if not mines then
69185: LD_VAR 0 2
69189: NOT
69190: IFFALSE 69194
// exit ;
69192: GO 69338
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
69194: LD_ADDR_VAR 0 5
69198: PUSH
69199: LD_INT 81
69201: PUSH
69202: LD_VAR 0 1
69206: PUSH
69207: EMPTY
69208: LIST
69209: LIST
69210: PUSH
69211: LD_INT 3
69213: PUSH
69214: LD_INT 21
69216: PUSH
69217: LD_INT 3
69219: PUSH
69220: EMPTY
69221: LIST
69222: LIST
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: PUSH
69228: EMPTY
69229: LIST
69230: LIST
69231: PPUSH
69232: CALL_OW 69
69236: ST_TO_ADDR
// for i in mines do
69237: LD_ADDR_VAR 0 4
69241: PUSH
69242: LD_VAR 0 2
69246: PUSH
69247: FOR_IN
69248: IFFALSE 69336
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
69250: LD_VAR 0 4
69254: PUSH
69255: LD_INT 1
69257: ARRAY
69258: PPUSH
69259: LD_VAR 0 4
69263: PUSH
69264: LD_INT 2
69266: ARRAY
69267: PPUSH
69268: CALL_OW 458
69272: NOT
69273: IFFALSE 69277
// continue ;
69275: GO 69247
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
69277: LD_VAR 0 4
69281: PUSH
69282: LD_INT 1
69284: ARRAY
69285: PPUSH
69286: LD_VAR 0 4
69290: PUSH
69291: LD_INT 2
69293: ARRAY
69294: PPUSH
69295: CALL_OW 428
69299: PUSH
69300: LD_VAR 0 5
69304: IN
69305: IFFALSE 69334
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
69307: LD_VAR 0 4
69311: PUSH
69312: LD_INT 1
69314: ARRAY
69315: PPUSH
69316: LD_VAR 0 4
69320: PUSH
69321: LD_INT 2
69323: ARRAY
69324: PPUSH
69325: LD_VAR 0 1
69329: PPUSH
69330: CALL_OW 456
// end ;
69334: GO 69247
69336: POP
69337: POP
// end ;
69338: LD_VAR 0 3
69342: RET
// export function Count ( array ) ; var i ; begin
69343: LD_INT 0
69345: PPUSH
69346: PPUSH
// result := 0 ;
69347: LD_ADDR_VAR 0 2
69351: PUSH
69352: LD_INT 0
69354: ST_TO_ADDR
// for i in array do
69355: LD_ADDR_VAR 0 3
69359: PUSH
69360: LD_VAR 0 1
69364: PUSH
69365: FOR_IN
69366: IFFALSE 69390
// if i then
69368: LD_VAR 0 3
69372: IFFALSE 69388
// result := result + 1 ;
69374: LD_ADDR_VAR 0 2
69378: PUSH
69379: LD_VAR 0 2
69383: PUSH
69384: LD_INT 1
69386: PLUS
69387: ST_TO_ADDR
69388: GO 69365
69390: POP
69391: POP
// end ;
69392: LD_VAR 0 2
69396: RET
// export function IsEmpty ( building ) ; begin
69397: LD_INT 0
69399: PPUSH
// if not building then
69400: LD_VAR 0 1
69404: NOT
69405: IFFALSE 69409
// exit ;
69407: GO 69452
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
69409: LD_ADDR_VAR 0 2
69413: PUSH
69414: LD_VAR 0 1
69418: PUSH
69419: LD_INT 22
69421: PUSH
69422: LD_VAR 0 1
69426: PPUSH
69427: CALL_OW 255
69431: PUSH
69432: EMPTY
69433: LIST
69434: LIST
69435: PUSH
69436: LD_INT 58
69438: PUSH
69439: EMPTY
69440: LIST
69441: PUSH
69442: EMPTY
69443: LIST
69444: LIST
69445: PPUSH
69446: CALL_OW 69
69450: IN
69451: ST_TO_ADDR
// end ;
69452: LD_VAR 0 2
69456: RET
// export function IsNotFull ( building ) ; begin
69457: LD_INT 0
69459: PPUSH
// if not building then
69460: LD_VAR 0 1
69464: NOT
69465: IFFALSE 69469
// exit ;
69467: GO 69488
// result := UnitsInside ( building ) < 6 ;
69469: LD_ADDR_VAR 0 2
69473: PUSH
69474: LD_VAR 0 1
69478: PPUSH
69479: CALL_OW 313
69483: PUSH
69484: LD_INT 6
69486: LESS
69487: ST_TO_ADDR
// end ;
69488: LD_VAR 0 2
69492: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
69493: LD_INT 0
69495: PPUSH
69496: PPUSH
69497: PPUSH
69498: PPUSH
// tmp := [ ] ;
69499: LD_ADDR_VAR 0 3
69503: PUSH
69504: EMPTY
69505: ST_TO_ADDR
// list := [ ] ;
69506: LD_ADDR_VAR 0 5
69510: PUSH
69511: EMPTY
69512: ST_TO_ADDR
// for i = 16 to 25 do
69513: LD_ADDR_VAR 0 4
69517: PUSH
69518: DOUBLE
69519: LD_INT 16
69521: DEC
69522: ST_TO_ADDR
69523: LD_INT 25
69525: PUSH
69526: FOR_TO
69527: IFFALSE 69600
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
69529: LD_ADDR_VAR 0 3
69533: PUSH
69534: LD_VAR 0 3
69538: PUSH
69539: LD_INT 22
69541: PUSH
69542: LD_VAR 0 1
69546: PPUSH
69547: CALL_OW 255
69551: PUSH
69552: EMPTY
69553: LIST
69554: LIST
69555: PUSH
69556: LD_INT 91
69558: PUSH
69559: LD_VAR 0 1
69563: PUSH
69564: LD_INT 6
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 30
69574: PUSH
69575: LD_VAR 0 4
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: PUSH
69584: EMPTY
69585: LIST
69586: LIST
69587: LIST
69588: PUSH
69589: EMPTY
69590: LIST
69591: PPUSH
69592: CALL_OW 69
69596: ADD
69597: ST_TO_ADDR
69598: GO 69526
69600: POP
69601: POP
// for i = 1 to tmp do
69602: LD_ADDR_VAR 0 4
69606: PUSH
69607: DOUBLE
69608: LD_INT 1
69610: DEC
69611: ST_TO_ADDR
69612: LD_VAR 0 3
69616: PUSH
69617: FOR_TO
69618: IFFALSE 69706
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
69620: LD_ADDR_VAR 0 5
69624: PUSH
69625: LD_VAR 0 5
69629: PUSH
69630: LD_VAR 0 3
69634: PUSH
69635: LD_VAR 0 4
69639: ARRAY
69640: PPUSH
69641: CALL_OW 266
69645: PUSH
69646: LD_VAR 0 3
69650: PUSH
69651: LD_VAR 0 4
69655: ARRAY
69656: PPUSH
69657: CALL_OW 250
69661: PUSH
69662: LD_VAR 0 3
69666: PUSH
69667: LD_VAR 0 4
69671: ARRAY
69672: PPUSH
69673: CALL_OW 251
69677: PUSH
69678: LD_VAR 0 3
69682: PUSH
69683: LD_VAR 0 4
69687: ARRAY
69688: PPUSH
69689: CALL_OW 254
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: PUSH
69700: EMPTY
69701: LIST
69702: ADD
69703: ST_TO_ADDR
69704: GO 69617
69706: POP
69707: POP
// result := list ;
69708: LD_ADDR_VAR 0 2
69712: PUSH
69713: LD_VAR 0 5
69717: ST_TO_ADDR
// end ;
69718: LD_VAR 0 2
69722: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
69723: LD_INT 0
69725: PPUSH
69726: PPUSH
69727: PPUSH
69728: PPUSH
69729: PPUSH
69730: PPUSH
69731: PPUSH
// if not factory then
69732: LD_VAR 0 1
69736: NOT
69737: IFFALSE 69741
// exit ;
69739: GO 70334
// if control = control_apeman then
69741: LD_VAR 0 4
69745: PUSH
69746: LD_INT 5
69748: EQUAL
69749: IFFALSE 69858
// begin tmp := UnitsInside ( factory ) ;
69751: LD_ADDR_VAR 0 8
69755: PUSH
69756: LD_VAR 0 1
69760: PPUSH
69761: CALL_OW 313
69765: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
69766: LD_VAR 0 8
69770: PPUSH
69771: LD_INT 25
69773: PUSH
69774: LD_INT 12
69776: PUSH
69777: EMPTY
69778: LIST
69779: LIST
69780: PPUSH
69781: CALL_OW 72
69785: NOT
69786: IFFALSE 69796
// control := control_manual ;
69788: LD_ADDR_VAR 0 4
69792: PUSH
69793: LD_INT 1
69795: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
69796: LD_ADDR_VAR 0 8
69800: PUSH
69801: LD_VAR 0 1
69805: PPUSH
69806: CALL 69493 0 1
69810: ST_TO_ADDR
// if tmp then
69811: LD_VAR 0 8
69815: IFFALSE 69858
// begin for i in tmp do
69817: LD_ADDR_VAR 0 7
69821: PUSH
69822: LD_VAR 0 8
69826: PUSH
69827: FOR_IN
69828: IFFALSE 69856
// if i [ 1 ] = b_ext_radio then
69830: LD_VAR 0 7
69834: PUSH
69835: LD_INT 1
69837: ARRAY
69838: PUSH
69839: LD_INT 22
69841: EQUAL
69842: IFFALSE 69854
// begin control := control_remote ;
69844: LD_ADDR_VAR 0 4
69848: PUSH
69849: LD_INT 2
69851: ST_TO_ADDR
// break ;
69852: GO 69856
// end ;
69854: GO 69827
69856: POP
69857: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69858: LD_VAR 0 1
69862: PPUSH
69863: LD_VAR 0 2
69867: PPUSH
69868: LD_VAR 0 3
69872: PPUSH
69873: LD_VAR 0 4
69877: PPUSH
69878: LD_VAR 0 5
69882: PPUSH
69883: CALL_OW 448
69887: IFFALSE 69922
// begin result := [ chassis , engine , control , weapon ] ;
69889: LD_ADDR_VAR 0 6
69893: PUSH
69894: LD_VAR 0 2
69898: PUSH
69899: LD_VAR 0 3
69903: PUSH
69904: LD_VAR 0 4
69908: PUSH
69909: LD_VAR 0 5
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: LIST
69918: LIST
69919: ST_TO_ADDR
// exit ;
69920: GO 70334
// end ; _chassis := AvailableChassisList ( factory ) ;
69922: LD_ADDR_VAR 0 9
69926: PUSH
69927: LD_VAR 0 1
69931: PPUSH
69932: CALL_OW 475
69936: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
69937: LD_ADDR_VAR 0 11
69941: PUSH
69942: LD_VAR 0 1
69946: PPUSH
69947: CALL_OW 476
69951: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
69952: LD_ADDR_VAR 0 12
69956: PUSH
69957: LD_VAR 0 1
69961: PPUSH
69962: CALL_OW 477
69966: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
69967: LD_ADDR_VAR 0 10
69971: PUSH
69972: LD_VAR 0 1
69976: PPUSH
69977: CALL_OW 478
69981: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69982: LD_VAR 0 9
69986: NOT
69987: PUSH
69988: LD_VAR 0 11
69992: NOT
69993: OR
69994: PUSH
69995: LD_VAR 0 12
69999: NOT
70000: OR
70001: PUSH
70002: LD_VAR 0 10
70006: NOT
70007: OR
70008: IFFALSE 70043
// begin result := [ chassis , engine , control , weapon ] ;
70010: LD_ADDR_VAR 0 6
70014: PUSH
70015: LD_VAR 0 2
70019: PUSH
70020: LD_VAR 0 3
70024: PUSH
70025: LD_VAR 0 4
70029: PUSH
70030: LD_VAR 0 5
70034: PUSH
70035: EMPTY
70036: LIST
70037: LIST
70038: LIST
70039: LIST
70040: ST_TO_ADDR
// exit ;
70041: GO 70334
// end ; if not chassis in _chassis then
70043: LD_VAR 0 2
70047: PUSH
70048: LD_VAR 0 9
70052: IN
70053: NOT
70054: IFFALSE 70080
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
70056: LD_ADDR_VAR 0 2
70060: PUSH
70061: LD_VAR 0 9
70065: PUSH
70066: LD_INT 1
70068: PPUSH
70069: LD_VAR 0 9
70073: PPUSH
70074: CALL_OW 12
70078: ARRAY
70079: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
70080: LD_VAR 0 2
70084: PPUSH
70085: LD_VAR 0 3
70089: PPUSH
70090: CALL 70339 0 2
70094: NOT
70095: IFFALSE 70154
// repeat engine := _engine [ 1 ] ;
70097: LD_ADDR_VAR 0 3
70101: PUSH
70102: LD_VAR 0 11
70106: PUSH
70107: LD_INT 1
70109: ARRAY
70110: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
70111: LD_ADDR_VAR 0 11
70115: PUSH
70116: LD_VAR 0 11
70120: PPUSH
70121: LD_INT 1
70123: PPUSH
70124: CALL_OW 3
70128: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
70129: LD_VAR 0 2
70133: PPUSH
70134: LD_VAR 0 3
70138: PPUSH
70139: CALL 70339 0 2
70143: PUSH
70144: LD_VAR 0 11
70148: PUSH
70149: EMPTY
70150: EQUAL
70151: OR
70152: IFFALSE 70097
// if not control in _control then
70154: LD_VAR 0 4
70158: PUSH
70159: LD_VAR 0 12
70163: IN
70164: NOT
70165: IFFALSE 70191
// control := _control [ rand ( 1 , _control ) ] ;
70167: LD_ADDR_VAR 0 4
70171: PUSH
70172: LD_VAR 0 12
70176: PUSH
70177: LD_INT 1
70179: PPUSH
70180: LD_VAR 0 12
70184: PPUSH
70185: CALL_OW 12
70189: ARRAY
70190: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
70191: LD_VAR 0 2
70195: PPUSH
70196: LD_VAR 0 5
70200: PPUSH
70201: CALL 70559 0 2
70205: NOT
70206: IFFALSE 70265
// repeat weapon := _weapon [ 1 ] ;
70208: LD_ADDR_VAR 0 5
70212: PUSH
70213: LD_VAR 0 10
70217: PUSH
70218: LD_INT 1
70220: ARRAY
70221: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
70222: LD_ADDR_VAR 0 10
70226: PUSH
70227: LD_VAR 0 10
70231: PPUSH
70232: LD_INT 1
70234: PPUSH
70235: CALL_OW 3
70239: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
70240: LD_VAR 0 2
70244: PPUSH
70245: LD_VAR 0 5
70249: PPUSH
70250: CALL 70559 0 2
70254: PUSH
70255: LD_VAR 0 10
70259: PUSH
70260: EMPTY
70261: EQUAL
70262: OR
70263: IFFALSE 70208
// result := [ ] ;
70265: LD_ADDR_VAR 0 6
70269: PUSH
70270: EMPTY
70271: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
70272: LD_VAR 0 1
70276: PPUSH
70277: LD_VAR 0 2
70281: PPUSH
70282: LD_VAR 0 3
70286: PPUSH
70287: LD_VAR 0 4
70291: PPUSH
70292: LD_VAR 0 5
70296: PPUSH
70297: CALL_OW 448
70301: IFFALSE 70334
// result := [ chassis , engine , control , weapon ] ;
70303: LD_ADDR_VAR 0 6
70307: PUSH
70308: LD_VAR 0 2
70312: PUSH
70313: LD_VAR 0 3
70317: PUSH
70318: LD_VAR 0 4
70322: PUSH
70323: LD_VAR 0 5
70327: PUSH
70328: EMPTY
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: ST_TO_ADDR
// end ;
70334: LD_VAR 0 6
70338: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
70339: LD_INT 0
70341: PPUSH
// if not chassis or not engine then
70342: LD_VAR 0 1
70346: NOT
70347: PUSH
70348: LD_VAR 0 2
70352: NOT
70353: OR
70354: IFFALSE 70358
// exit ;
70356: GO 70554
// case engine of engine_solar :
70358: LD_VAR 0 2
70362: PUSH
70363: LD_INT 2
70365: DOUBLE
70366: EQUAL
70367: IFTRUE 70371
70369: GO 70409
70371: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
70372: LD_ADDR_VAR 0 3
70376: PUSH
70377: LD_INT 11
70379: PUSH
70380: LD_INT 12
70382: PUSH
70383: LD_INT 13
70385: PUSH
70386: LD_INT 14
70388: PUSH
70389: LD_INT 1
70391: PUSH
70392: LD_INT 2
70394: PUSH
70395: LD_INT 3
70397: PUSH
70398: EMPTY
70399: LIST
70400: LIST
70401: LIST
70402: LIST
70403: LIST
70404: LIST
70405: LIST
70406: ST_TO_ADDR
70407: GO 70538
70409: LD_INT 1
70411: DOUBLE
70412: EQUAL
70413: IFTRUE 70417
70415: GO 70479
70417: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
70418: LD_ADDR_VAR 0 3
70422: PUSH
70423: LD_INT 11
70425: PUSH
70426: LD_INT 12
70428: PUSH
70429: LD_INT 13
70431: PUSH
70432: LD_INT 14
70434: PUSH
70435: LD_INT 1
70437: PUSH
70438: LD_INT 2
70440: PUSH
70441: LD_INT 3
70443: PUSH
70444: LD_INT 4
70446: PUSH
70447: LD_INT 5
70449: PUSH
70450: LD_INT 21
70452: PUSH
70453: LD_INT 23
70455: PUSH
70456: LD_INT 22
70458: PUSH
70459: LD_INT 24
70461: PUSH
70462: EMPTY
70463: LIST
70464: LIST
70465: LIST
70466: LIST
70467: LIST
70468: LIST
70469: LIST
70470: LIST
70471: LIST
70472: LIST
70473: LIST
70474: LIST
70475: LIST
70476: ST_TO_ADDR
70477: GO 70538
70479: LD_INT 3
70481: DOUBLE
70482: EQUAL
70483: IFTRUE 70487
70485: GO 70537
70487: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70488: LD_ADDR_VAR 0 3
70492: PUSH
70493: LD_INT 13
70495: PUSH
70496: LD_INT 14
70498: PUSH
70499: LD_INT 2
70501: PUSH
70502: LD_INT 3
70504: PUSH
70505: LD_INT 4
70507: PUSH
70508: LD_INT 5
70510: PUSH
70511: LD_INT 21
70513: PUSH
70514: LD_INT 22
70516: PUSH
70517: LD_INT 23
70519: PUSH
70520: LD_INT 24
70522: PUSH
70523: EMPTY
70524: LIST
70525: LIST
70526: LIST
70527: LIST
70528: LIST
70529: LIST
70530: LIST
70531: LIST
70532: LIST
70533: LIST
70534: ST_TO_ADDR
70535: GO 70538
70537: POP
// result := ( chassis in result ) ;
70538: LD_ADDR_VAR 0 3
70542: PUSH
70543: LD_VAR 0 1
70547: PUSH
70548: LD_VAR 0 3
70552: IN
70553: ST_TO_ADDR
// end ;
70554: LD_VAR 0 3
70558: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
70559: LD_INT 0
70561: PPUSH
// if not chassis or not weapon then
70562: LD_VAR 0 1
70566: NOT
70567: PUSH
70568: LD_VAR 0 2
70572: NOT
70573: OR
70574: IFFALSE 70578
// exit ;
70576: GO 71604
// case weapon of us_machine_gun :
70578: LD_VAR 0 2
70582: PUSH
70583: LD_INT 2
70585: DOUBLE
70586: EQUAL
70587: IFTRUE 70591
70589: GO 70621
70591: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
70592: LD_ADDR_VAR 0 3
70596: PUSH
70597: LD_INT 1
70599: PUSH
70600: LD_INT 2
70602: PUSH
70603: LD_INT 3
70605: PUSH
70606: LD_INT 4
70608: PUSH
70609: LD_INT 5
70611: PUSH
70612: EMPTY
70613: LIST
70614: LIST
70615: LIST
70616: LIST
70617: LIST
70618: ST_TO_ADDR
70619: GO 71588
70621: LD_INT 3
70623: DOUBLE
70624: EQUAL
70625: IFTRUE 70629
70627: GO 70659
70629: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
70630: LD_ADDR_VAR 0 3
70634: PUSH
70635: LD_INT 1
70637: PUSH
70638: LD_INT 2
70640: PUSH
70641: LD_INT 3
70643: PUSH
70644: LD_INT 4
70646: PUSH
70647: LD_INT 5
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: LIST
70654: LIST
70655: LIST
70656: ST_TO_ADDR
70657: GO 71588
70659: LD_INT 11
70661: DOUBLE
70662: EQUAL
70663: IFTRUE 70667
70665: GO 70697
70667: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
70668: LD_ADDR_VAR 0 3
70672: PUSH
70673: LD_INT 1
70675: PUSH
70676: LD_INT 2
70678: PUSH
70679: LD_INT 3
70681: PUSH
70682: LD_INT 4
70684: PUSH
70685: LD_INT 5
70687: PUSH
70688: EMPTY
70689: LIST
70690: LIST
70691: LIST
70692: LIST
70693: LIST
70694: ST_TO_ADDR
70695: GO 71588
70697: LD_INT 4
70699: DOUBLE
70700: EQUAL
70701: IFTRUE 70705
70703: GO 70731
70705: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
70706: LD_ADDR_VAR 0 3
70710: PUSH
70711: LD_INT 2
70713: PUSH
70714: LD_INT 3
70716: PUSH
70717: LD_INT 4
70719: PUSH
70720: LD_INT 5
70722: PUSH
70723: EMPTY
70724: LIST
70725: LIST
70726: LIST
70727: LIST
70728: ST_TO_ADDR
70729: GO 71588
70731: LD_INT 5
70733: DOUBLE
70734: EQUAL
70735: IFTRUE 70739
70737: GO 70765
70739: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
70740: LD_ADDR_VAR 0 3
70744: PUSH
70745: LD_INT 2
70747: PUSH
70748: LD_INT 3
70750: PUSH
70751: LD_INT 4
70753: PUSH
70754: LD_INT 5
70756: PUSH
70757: EMPTY
70758: LIST
70759: LIST
70760: LIST
70761: LIST
70762: ST_TO_ADDR
70763: GO 71588
70765: LD_INT 9
70767: DOUBLE
70768: EQUAL
70769: IFTRUE 70773
70771: GO 70799
70773: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
70774: LD_ADDR_VAR 0 3
70778: PUSH
70779: LD_INT 2
70781: PUSH
70782: LD_INT 3
70784: PUSH
70785: LD_INT 4
70787: PUSH
70788: LD_INT 5
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: LIST
70795: LIST
70796: ST_TO_ADDR
70797: GO 71588
70799: LD_INT 7
70801: DOUBLE
70802: EQUAL
70803: IFTRUE 70807
70805: GO 70833
70807: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
70808: LD_ADDR_VAR 0 3
70812: PUSH
70813: LD_INT 2
70815: PUSH
70816: LD_INT 3
70818: PUSH
70819: LD_INT 4
70821: PUSH
70822: LD_INT 5
70824: PUSH
70825: EMPTY
70826: LIST
70827: LIST
70828: LIST
70829: LIST
70830: ST_TO_ADDR
70831: GO 71588
70833: LD_INT 12
70835: DOUBLE
70836: EQUAL
70837: IFTRUE 70841
70839: GO 70867
70841: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
70842: LD_ADDR_VAR 0 3
70846: PUSH
70847: LD_INT 2
70849: PUSH
70850: LD_INT 3
70852: PUSH
70853: LD_INT 4
70855: PUSH
70856: LD_INT 5
70858: PUSH
70859: EMPTY
70860: LIST
70861: LIST
70862: LIST
70863: LIST
70864: ST_TO_ADDR
70865: GO 71588
70867: LD_INT 13
70869: DOUBLE
70870: EQUAL
70871: IFTRUE 70875
70873: GO 70901
70875: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
70876: LD_ADDR_VAR 0 3
70880: PUSH
70881: LD_INT 2
70883: PUSH
70884: LD_INT 3
70886: PUSH
70887: LD_INT 4
70889: PUSH
70890: LD_INT 5
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: LIST
70897: LIST
70898: ST_TO_ADDR
70899: GO 71588
70901: LD_INT 14
70903: DOUBLE
70904: EQUAL
70905: IFTRUE 70909
70907: GO 70927
70909: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
70910: LD_ADDR_VAR 0 3
70914: PUSH
70915: LD_INT 4
70917: PUSH
70918: LD_INT 5
70920: PUSH
70921: EMPTY
70922: LIST
70923: LIST
70924: ST_TO_ADDR
70925: GO 71588
70927: LD_INT 6
70929: DOUBLE
70930: EQUAL
70931: IFTRUE 70935
70933: GO 70953
70935: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
70936: LD_ADDR_VAR 0 3
70940: PUSH
70941: LD_INT 4
70943: PUSH
70944: LD_INT 5
70946: PUSH
70947: EMPTY
70948: LIST
70949: LIST
70950: ST_TO_ADDR
70951: GO 71588
70953: LD_INT 10
70955: DOUBLE
70956: EQUAL
70957: IFTRUE 70961
70959: GO 70979
70961: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
70962: LD_ADDR_VAR 0 3
70966: PUSH
70967: LD_INT 4
70969: PUSH
70970: LD_INT 5
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: ST_TO_ADDR
70977: GO 71588
70979: LD_INT 22
70981: DOUBLE
70982: EQUAL
70983: IFTRUE 70987
70985: GO 71013
70987: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70988: LD_ADDR_VAR 0 3
70992: PUSH
70993: LD_INT 11
70995: PUSH
70996: LD_INT 12
70998: PUSH
70999: LD_INT 13
71001: PUSH
71002: LD_INT 14
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: ST_TO_ADDR
71011: GO 71588
71013: LD_INT 23
71015: DOUBLE
71016: EQUAL
71017: IFTRUE 71021
71019: GO 71047
71021: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
71022: LD_ADDR_VAR 0 3
71026: PUSH
71027: LD_INT 11
71029: PUSH
71030: LD_INT 12
71032: PUSH
71033: LD_INT 13
71035: PUSH
71036: LD_INT 14
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: LIST
71043: LIST
71044: ST_TO_ADDR
71045: GO 71588
71047: LD_INT 24
71049: DOUBLE
71050: EQUAL
71051: IFTRUE 71055
71053: GO 71081
71055: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
71056: LD_ADDR_VAR 0 3
71060: PUSH
71061: LD_INT 11
71063: PUSH
71064: LD_INT 12
71066: PUSH
71067: LD_INT 13
71069: PUSH
71070: LD_INT 14
71072: PUSH
71073: EMPTY
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: ST_TO_ADDR
71079: GO 71588
71081: LD_INT 30
71083: DOUBLE
71084: EQUAL
71085: IFTRUE 71089
71087: GO 71115
71089: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
71090: LD_ADDR_VAR 0 3
71094: PUSH
71095: LD_INT 11
71097: PUSH
71098: LD_INT 12
71100: PUSH
71101: LD_INT 13
71103: PUSH
71104: LD_INT 14
71106: PUSH
71107: EMPTY
71108: LIST
71109: LIST
71110: LIST
71111: LIST
71112: ST_TO_ADDR
71113: GO 71588
71115: LD_INT 25
71117: DOUBLE
71118: EQUAL
71119: IFTRUE 71123
71121: GO 71141
71123: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
71124: LD_ADDR_VAR 0 3
71128: PUSH
71129: LD_INT 13
71131: PUSH
71132: LD_INT 14
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: ST_TO_ADDR
71139: GO 71588
71141: LD_INT 27
71143: DOUBLE
71144: EQUAL
71145: IFTRUE 71149
71147: GO 71167
71149: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
71150: LD_ADDR_VAR 0 3
71154: PUSH
71155: LD_INT 13
71157: PUSH
71158: LD_INT 14
71160: PUSH
71161: EMPTY
71162: LIST
71163: LIST
71164: ST_TO_ADDR
71165: GO 71588
71167: LD_INT 28
71169: DOUBLE
71170: EQUAL
71171: IFTRUE 71175
71173: GO 71193
71175: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
71176: LD_ADDR_VAR 0 3
71180: PUSH
71181: LD_INT 13
71183: PUSH
71184: LD_INT 14
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: ST_TO_ADDR
71191: GO 71588
71193: LD_INT 29
71195: DOUBLE
71196: EQUAL
71197: IFTRUE 71201
71199: GO 71219
71201: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
71202: LD_ADDR_VAR 0 3
71206: PUSH
71207: LD_INT 13
71209: PUSH
71210: LD_INT 14
71212: PUSH
71213: EMPTY
71214: LIST
71215: LIST
71216: ST_TO_ADDR
71217: GO 71588
71219: LD_INT 31
71221: DOUBLE
71222: EQUAL
71223: IFTRUE 71227
71225: GO 71245
71227: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
71228: LD_ADDR_VAR 0 3
71232: PUSH
71233: LD_INT 13
71235: PUSH
71236: LD_INT 14
71238: PUSH
71239: EMPTY
71240: LIST
71241: LIST
71242: ST_TO_ADDR
71243: GO 71588
71245: LD_INT 26
71247: DOUBLE
71248: EQUAL
71249: IFTRUE 71253
71251: GO 71271
71253: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
71254: LD_ADDR_VAR 0 3
71258: PUSH
71259: LD_INT 13
71261: PUSH
71262: LD_INT 14
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: ST_TO_ADDR
71269: GO 71588
71271: LD_INT 42
71273: DOUBLE
71274: EQUAL
71275: IFTRUE 71279
71277: GO 71305
71279: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
71280: LD_ADDR_VAR 0 3
71284: PUSH
71285: LD_INT 21
71287: PUSH
71288: LD_INT 22
71290: PUSH
71291: LD_INT 23
71293: PUSH
71294: LD_INT 24
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: LIST
71301: LIST
71302: ST_TO_ADDR
71303: GO 71588
71305: LD_INT 43
71307: DOUBLE
71308: EQUAL
71309: IFTRUE 71313
71311: GO 71339
71313: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
71314: LD_ADDR_VAR 0 3
71318: PUSH
71319: LD_INT 21
71321: PUSH
71322: LD_INT 22
71324: PUSH
71325: LD_INT 23
71327: PUSH
71328: LD_INT 24
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: LIST
71335: LIST
71336: ST_TO_ADDR
71337: GO 71588
71339: LD_INT 44
71341: DOUBLE
71342: EQUAL
71343: IFTRUE 71347
71345: GO 71373
71347: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
71348: LD_ADDR_VAR 0 3
71352: PUSH
71353: LD_INT 21
71355: PUSH
71356: LD_INT 22
71358: PUSH
71359: LD_INT 23
71361: PUSH
71362: LD_INT 24
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: ST_TO_ADDR
71371: GO 71588
71373: LD_INT 45
71375: DOUBLE
71376: EQUAL
71377: IFTRUE 71381
71379: GO 71407
71381: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
71382: LD_ADDR_VAR 0 3
71386: PUSH
71387: LD_INT 21
71389: PUSH
71390: LD_INT 22
71392: PUSH
71393: LD_INT 23
71395: PUSH
71396: LD_INT 24
71398: PUSH
71399: EMPTY
71400: LIST
71401: LIST
71402: LIST
71403: LIST
71404: ST_TO_ADDR
71405: GO 71588
71407: LD_INT 49
71409: DOUBLE
71410: EQUAL
71411: IFTRUE 71415
71413: GO 71441
71415: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
71416: LD_ADDR_VAR 0 3
71420: PUSH
71421: LD_INT 21
71423: PUSH
71424: LD_INT 22
71426: PUSH
71427: LD_INT 23
71429: PUSH
71430: LD_INT 24
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: ST_TO_ADDR
71439: GO 71588
71441: LD_INT 51
71443: DOUBLE
71444: EQUAL
71445: IFTRUE 71449
71447: GO 71475
71449: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
71450: LD_ADDR_VAR 0 3
71454: PUSH
71455: LD_INT 21
71457: PUSH
71458: LD_INT 22
71460: PUSH
71461: LD_INT 23
71463: PUSH
71464: LD_INT 24
71466: PUSH
71467: EMPTY
71468: LIST
71469: LIST
71470: LIST
71471: LIST
71472: ST_TO_ADDR
71473: GO 71588
71475: LD_INT 52
71477: DOUBLE
71478: EQUAL
71479: IFTRUE 71483
71481: GO 71509
71483: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
71484: LD_ADDR_VAR 0 3
71488: PUSH
71489: LD_INT 21
71491: PUSH
71492: LD_INT 22
71494: PUSH
71495: LD_INT 23
71497: PUSH
71498: LD_INT 24
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: LIST
71505: LIST
71506: ST_TO_ADDR
71507: GO 71588
71509: LD_INT 53
71511: DOUBLE
71512: EQUAL
71513: IFTRUE 71517
71515: GO 71535
71517: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
71518: LD_ADDR_VAR 0 3
71522: PUSH
71523: LD_INT 23
71525: PUSH
71526: LD_INT 24
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: ST_TO_ADDR
71533: GO 71588
71535: LD_INT 46
71537: DOUBLE
71538: EQUAL
71539: IFTRUE 71543
71541: GO 71561
71543: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
71544: LD_ADDR_VAR 0 3
71548: PUSH
71549: LD_INT 23
71551: PUSH
71552: LD_INT 24
71554: PUSH
71555: EMPTY
71556: LIST
71557: LIST
71558: ST_TO_ADDR
71559: GO 71588
71561: LD_INT 47
71563: DOUBLE
71564: EQUAL
71565: IFTRUE 71569
71567: GO 71587
71569: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
71570: LD_ADDR_VAR 0 3
71574: PUSH
71575: LD_INT 23
71577: PUSH
71578: LD_INT 24
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: ST_TO_ADDR
71585: GO 71588
71587: POP
// result := ( chassis in result ) ;
71588: LD_ADDR_VAR 0 3
71592: PUSH
71593: LD_VAR 0 1
71597: PUSH
71598: LD_VAR 0 3
71602: IN
71603: ST_TO_ADDR
// end ;
71604: LD_VAR 0 3
71608: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
71609: LD_INT 0
71611: PPUSH
71612: PPUSH
71613: PPUSH
71614: PPUSH
71615: PPUSH
71616: PPUSH
71617: PPUSH
// result := array ;
71618: LD_ADDR_VAR 0 5
71622: PUSH
71623: LD_VAR 0 1
71627: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
71628: LD_VAR 0 1
71632: NOT
71633: PUSH
71634: LD_VAR 0 2
71638: NOT
71639: OR
71640: PUSH
71641: LD_VAR 0 3
71645: NOT
71646: OR
71647: PUSH
71648: LD_VAR 0 2
71652: PUSH
71653: LD_VAR 0 1
71657: GREATER
71658: OR
71659: PUSH
71660: LD_VAR 0 3
71664: PUSH
71665: LD_VAR 0 1
71669: GREATER
71670: OR
71671: IFFALSE 71675
// exit ;
71673: GO 71971
// if direction then
71675: LD_VAR 0 4
71679: IFFALSE 71743
// begin d := 1 ;
71681: LD_ADDR_VAR 0 9
71685: PUSH
71686: LD_INT 1
71688: ST_TO_ADDR
// if i_from > i_to then
71689: LD_VAR 0 2
71693: PUSH
71694: LD_VAR 0 3
71698: GREATER
71699: IFFALSE 71725
// length := ( array - i_from ) + i_to else
71701: LD_ADDR_VAR 0 11
71705: PUSH
71706: LD_VAR 0 1
71710: PUSH
71711: LD_VAR 0 2
71715: MINUS
71716: PUSH
71717: LD_VAR 0 3
71721: PLUS
71722: ST_TO_ADDR
71723: GO 71741
// length := i_to - i_from ;
71725: LD_ADDR_VAR 0 11
71729: PUSH
71730: LD_VAR 0 3
71734: PUSH
71735: LD_VAR 0 2
71739: MINUS
71740: ST_TO_ADDR
// end else
71741: GO 71804
// begin d := - 1 ;
71743: LD_ADDR_VAR 0 9
71747: PUSH
71748: LD_INT 1
71750: NEG
71751: ST_TO_ADDR
// if i_from > i_to then
71752: LD_VAR 0 2
71756: PUSH
71757: LD_VAR 0 3
71761: GREATER
71762: IFFALSE 71782
// length := i_from - i_to else
71764: LD_ADDR_VAR 0 11
71768: PUSH
71769: LD_VAR 0 2
71773: PUSH
71774: LD_VAR 0 3
71778: MINUS
71779: ST_TO_ADDR
71780: GO 71804
// length := ( array - i_to ) + i_from ;
71782: LD_ADDR_VAR 0 11
71786: PUSH
71787: LD_VAR 0 1
71791: PUSH
71792: LD_VAR 0 3
71796: MINUS
71797: PUSH
71798: LD_VAR 0 2
71802: PLUS
71803: ST_TO_ADDR
// end ; if not length then
71804: LD_VAR 0 11
71808: NOT
71809: IFFALSE 71813
// exit ;
71811: GO 71971
// tmp := array ;
71813: LD_ADDR_VAR 0 10
71817: PUSH
71818: LD_VAR 0 1
71822: ST_TO_ADDR
// for i = 1 to length do
71823: LD_ADDR_VAR 0 6
71827: PUSH
71828: DOUBLE
71829: LD_INT 1
71831: DEC
71832: ST_TO_ADDR
71833: LD_VAR 0 11
71837: PUSH
71838: FOR_TO
71839: IFFALSE 71959
// begin for j = 1 to array do
71841: LD_ADDR_VAR 0 7
71845: PUSH
71846: DOUBLE
71847: LD_INT 1
71849: DEC
71850: ST_TO_ADDR
71851: LD_VAR 0 1
71855: PUSH
71856: FOR_TO
71857: IFFALSE 71945
// begin k := j + d ;
71859: LD_ADDR_VAR 0 8
71863: PUSH
71864: LD_VAR 0 7
71868: PUSH
71869: LD_VAR 0 9
71873: PLUS
71874: ST_TO_ADDR
// if k > array then
71875: LD_VAR 0 8
71879: PUSH
71880: LD_VAR 0 1
71884: GREATER
71885: IFFALSE 71895
// k := 1 ;
71887: LD_ADDR_VAR 0 8
71891: PUSH
71892: LD_INT 1
71894: ST_TO_ADDR
// if not k then
71895: LD_VAR 0 8
71899: NOT
71900: IFFALSE 71912
// k := array ;
71902: LD_ADDR_VAR 0 8
71906: PUSH
71907: LD_VAR 0 1
71911: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
71912: LD_ADDR_VAR 0 10
71916: PUSH
71917: LD_VAR 0 10
71921: PPUSH
71922: LD_VAR 0 8
71926: PPUSH
71927: LD_VAR 0 1
71931: PUSH
71932: LD_VAR 0 7
71936: ARRAY
71937: PPUSH
71938: CALL_OW 1
71942: ST_TO_ADDR
// end ;
71943: GO 71856
71945: POP
71946: POP
// array := tmp ;
71947: LD_ADDR_VAR 0 1
71951: PUSH
71952: LD_VAR 0 10
71956: ST_TO_ADDR
// end ;
71957: GO 71838
71959: POP
71960: POP
// result := array ;
71961: LD_ADDR_VAR 0 5
71965: PUSH
71966: LD_VAR 0 1
71970: ST_TO_ADDR
// end ;
71971: LD_VAR 0 5
71975: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
71976: LD_INT 0
71978: PPUSH
71979: PPUSH
// result := 0 ;
71980: LD_ADDR_VAR 0 3
71984: PUSH
71985: LD_INT 0
71987: ST_TO_ADDR
// if not array or not value in array then
71988: LD_VAR 0 1
71992: NOT
71993: PUSH
71994: LD_VAR 0 2
71998: PUSH
71999: LD_VAR 0 1
72003: IN
72004: NOT
72005: OR
72006: IFFALSE 72010
// exit ;
72008: GO 72064
// for i = 1 to array do
72010: LD_ADDR_VAR 0 4
72014: PUSH
72015: DOUBLE
72016: LD_INT 1
72018: DEC
72019: ST_TO_ADDR
72020: LD_VAR 0 1
72024: PUSH
72025: FOR_TO
72026: IFFALSE 72062
// if value = array [ i ] then
72028: LD_VAR 0 2
72032: PUSH
72033: LD_VAR 0 1
72037: PUSH
72038: LD_VAR 0 4
72042: ARRAY
72043: EQUAL
72044: IFFALSE 72060
// begin result := i ;
72046: LD_ADDR_VAR 0 3
72050: PUSH
72051: LD_VAR 0 4
72055: ST_TO_ADDR
// exit ;
72056: POP
72057: POP
72058: GO 72064
// end ;
72060: GO 72025
72062: POP
72063: POP
// end ;
72064: LD_VAR 0 3
72068: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
72069: LD_INT 0
72071: PPUSH
// vc_chassis := chassis ;
72072: LD_ADDR_OWVAR 37
72076: PUSH
72077: LD_VAR 0 1
72081: ST_TO_ADDR
// vc_engine := engine ;
72082: LD_ADDR_OWVAR 39
72086: PUSH
72087: LD_VAR 0 2
72091: ST_TO_ADDR
// vc_control := control ;
72092: LD_ADDR_OWVAR 38
72096: PUSH
72097: LD_VAR 0 3
72101: ST_TO_ADDR
// vc_weapon := weapon ;
72102: LD_ADDR_OWVAR 40
72106: PUSH
72107: LD_VAR 0 4
72111: ST_TO_ADDR
// vc_fuel_battery := fuel ;
72112: LD_ADDR_OWVAR 41
72116: PUSH
72117: LD_VAR 0 5
72121: ST_TO_ADDR
// end ;
72122: LD_VAR 0 6
72126: RET
// export function WantPlant ( unit ) ; var task ; begin
72127: LD_INT 0
72129: PPUSH
72130: PPUSH
// result := false ;
72131: LD_ADDR_VAR 0 2
72135: PUSH
72136: LD_INT 0
72138: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
72139: LD_ADDR_VAR 0 3
72143: PUSH
72144: LD_VAR 0 1
72148: PPUSH
72149: CALL_OW 437
72153: ST_TO_ADDR
// if task then
72154: LD_VAR 0 3
72158: IFFALSE 72186
// if task [ 1 ] [ 1 ] = p then
72160: LD_VAR 0 3
72164: PUSH
72165: LD_INT 1
72167: ARRAY
72168: PUSH
72169: LD_INT 1
72171: ARRAY
72172: PUSH
72173: LD_STRING p
72175: EQUAL
72176: IFFALSE 72186
// result := true ;
72178: LD_ADDR_VAR 0 2
72182: PUSH
72183: LD_INT 1
72185: ST_TO_ADDR
// end ;
72186: LD_VAR 0 2
72190: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
72191: LD_INT 0
72193: PPUSH
72194: PPUSH
72195: PPUSH
72196: PPUSH
// if pos < 1 then
72197: LD_VAR 0 2
72201: PUSH
72202: LD_INT 1
72204: LESS
72205: IFFALSE 72209
// exit ;
72207: GO 72512
// if pos = 1 then
72209: LD_VAR 0 2
72213: PUSH
72214: LD_INT 1
72216: EQUAL
72217: IFFALSE 72250
// result := Replace ( arr , pos [ 1 ] , value ) else
72219: LD_ADDR_VAR 0 4
72223: PUSH
72224: LD_VAR 0 1
72228: PPUSH
72229: LD_VAR 0 2
72233: PUSH
72234: LD_INT 1
72236: ARRAY
72237: PPUSH
72238: LD_VAR 0 3
72242: PPUSH
72243: CALL_OW 1
72247: ST_TO_ADDR
72248: GO 72512
// begin tmp := arr ;
72250: LD_ADDR_VAR 0 6
72254: PUSH
72255: LD_VAR 0 1
72259: ST_TO_ADDR
// s_arr := [ tmp ] ;
72260: LD_ADDR_VAR 0 7
72264: PUSH
72265: LD_VAR 0 6
72269: PUSH
72270: EMPTY
72271: LIST
72272: ST_TO_ADDR
// for i = 1 to pos - 1 do
72273: LD_ADDR_VAR 0 5
72277: PUSH
72278: DOUBLE
72279: LD_INT 1
72281: DEC
72282: ST_TO_ADDR
72283: LD_VAR 0 2
72287: PUSH
72288: LD_INT 1
72290: MINUS
72291: PUSH
72292: FOR_TO
72293: IFFALSE 72338
// begin tmp := tmp [ pos [ i ] ] ;
72295: LD_ADDR_VAR 0 6
72299: PUSH
72300: LD_VAR 0 6
72304: PUSH
72305: LD_VAR 0 2
72309: PUSH
72310: LD_VAR 0 5
72314: ARRAY
72315: ARRAY
72316: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
72317: LD_ADDR_VAR 0 7
72321: PUSH
72322: LD_VAR 0 7
72326: PUSH
72327: LD_VAR 0 6
72331: PUSH
72332: EMPTY
72333: LIST
72334: ADD
72335: ST_TO_ADDR
// end ;
72336: GO 72292
72338: POP
72339: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
72340: LD_ADDR_VAR 0 6
72344: PUSH
72345: LD_VAR 0 6
72349: PPUSH
72350: LD_VAR 0 2
72354: PUSH
72355: LD_VAR 0 2
72359: ARRAY
72360: PPUSH
72361: LD_VAR 0 3
72365: PPUSH
72366: CALL_OW 1
72370: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
72371: LD_ADDR_VAR 0 7
72375: PUSH
72376: LD_VAR 0 7
72380: PPUSH
72381: LD_VAR 0 7
72385: PPUSH
72386: LD_VAR 0 6
72390: PPUSH
72391: CALL_OW 1
72395: ST_TO_ADDR
// for i = s_arr downto 2 do
72396: LD_ADDR_VAR 0 5
72400: PUSH
72401: DOUBLE
72402: LD_VAR 0 7
72406: INC
72407: ST_TO_ADDR
72408: LD_INT 2
72410: PUSH
72411: FOR_DOWNTO
72412: IFFALSE 72496
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
72414: LD_ADDR_VAR 0 6
72418: PUSH
72419: LD_VAR 0 7
72423: PUSH
72424: LD_VAR 0 5
72428: PUSH
72429: LD_INT 1
72431: MINUS
72432: ARRAY
72433: PPUSH
72434: LD_VAR 0 2
72438: PUSH
72439: LD_VAR 0 5
72443: PUSH
72444: LD_INT 1
72446: MINUS
72447: ARRAY
72448: PPUSH
72449: LD_VAR 0 7
72453: PUSH
72454: LD_VAR 0 5
72458: ARRAY
72459: PPUSH
72460: CALL_OW 1
72464: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
72465: LD_ADDR_VAR 0 7
72469: PUSH
72470: LD_VAR 0 7
72474: PPUSH
72475: LD_VAR 0 5
72479: PUSH
72480: LD_INT 1
72482: MINUS
72483: PPUSH
72484: LD_VAR 0 6
72488: PPUSH
72489: CALL_OW 1
72493: ST_TO_ADDR
// end ;
72494: GO 72411
72496: POP
72497: POP
// result := s_arr [ 1 ] ;
72498: LD_ADDR_VAR 0 4
72502: PUSH
72503: LD_VAR 0 7
72507: PUSH
72508: LD_INT 1
72510: ARRAY
72511: ST_TO_ADDR
// end ; end ;
72512: LD_VAR 0 4
72516: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
72517: LD_INT 0
72519: PPUSH
72520: PPUSH
// if not list then
72521: LD_VAR 0 1
72525: NOT
72526: IFFALSE 72530
// exit ;
72528: GO 72621
// i := list [ pos1 ] ;
72530: LD_ADDR_VAR 0 5
72534: PUSH
72535: LD_VAR 0 1
72539: PUSH
72540: LD_VAR 0 2
72544: ARRAY
72545: ST_TO_ADDR
// if not i then
72546: LD_VAR 0 5
72550: NOT
72551: IFFALSE 72555
// exit ;
72553: GO 72621
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
72555: LD_ADDR_VAR 0 1
72559: PUSH
72560: LD_VAR 0 1
72564: PPUSH
72565: LD_VAR 0 2
72569: PPUSH
72570: LD_VAR 0 1
72574: PUSH
72575: LD_VAR 0 3
72579: ARRAY
72580: PPUSH
72581: CALL_OW 1
72585: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
72586: LD_ADDR_VAR 0 1
72590: PUSH
72591: LD_VAR 0 1
72595: PPUSH
72596: LD_VAR 0 3
72600: PPUSH
72601: LD_VAR 0 5
72605: PPUSH
72606: CALL_OW 1
72610: ST_TO_ADDR
// result := list ;
72611: LD_ADDR_VAR 0 4
72615: PUSH
72616: LD_VAR 0 1
72620: ST_TO_ADDR
// end ;
72621: LD_VAR 0 4
72625: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
72626: LD_INT 0
72628: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
72629: LD_ADDR_VAR 0 5
72633: PUSH
72634: LD_VAR 0 1
72638: PPUSH
72639: CALL_OW 250
72643: PPUSH
72644: LD_VAR 0 1
72648: PPUSH
72649: CALL_OW 251
72653: PPUSH
72654: LD_VAR 0 2
72658: PPUSH
72659: LD_VAR 0 3
72663: PPUSH
72664: LD_VAR 0 4
72668: PPUSH
72669: CALL 72679 0 5
72673: ST_TO_ADDR
// end ;
72674: LD_VAR 0 5
72678: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
72679: LD_INT 0
72681: PPUSH
72682: PPUSH
72683: PPUSH
72684: PPUSH
// if not list then
72685: LD_VAR 0 3
72689: NOT
72690: IFFALSE 72694
// exit ;
72692: GO 73082
// result := [ ] ;
72694: LD_ADDR_VAR 0 6
72698: PUSH
72699: EMPTY
72700: ST_TO_ADDR
// for i in list do
72701: LD_ADDR_VAR 0 7
72705: PUSH
72706: LD_VAR 0 3
72710: PUSH
72711: FOR_IN
72712: IFFALSE 72914
// begin tmp := GetDistUnitXY ( i , x , y ) ;
72714: LD_ADDR_VAR 0 9
72718: PUSH
72719: LD_VAR 0 7
72723: PPUSH
72724: LD_VAR 0 1
72728: PPUSH
72729: LD_VAR 0 2
72733: PPUSH
72734: CALL_OW 297
72738: ST_TO_ADDR
// if not result then
72739: LD_VAR 0 6
72743: NOT
72744: IFFALSE 72770
// result := [ [ i , tmp ] ] else
72746: LD_ADDR_VAR 0 6
72750: PUSH
72751: LD_VAR 0 7
72755: PUSH
72756: LD_VAR 0 9
72760: PUSH
72761: EMPTY
72762: LIST
72763: LIST
72764: PUSH
72765: EMPTY
72766: LIST
72767: ST_TO_ADDR
72768: GO 72912
// begin if result [ result ] [ 2 ] < tmp then
72770: LD_VAR 0 6
72774: PUSH
72775: LD_VAR 0 6
72779: ARRAY
72780: PUSH
72781: LD_INT 2
72783: ARRAY
72784: PUSH
72785: LD_VAR 0 9
72789: LESS
72790: IFFALSE 72832
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
72792: LD_ADDR_VAR 0 6
72796: PUSH
72797: LD_VAR 0 6
72801: PPUSH
72802: LD_VAR 0 6
72806: PUSH
72807: LD_INT 1
72809: PLUS
72810: PPUSH
72811: LD_VAR 0 7
72815: PUSH
72816: LD_VAR 0 9
72820: PUSH
72821: EMPTY
72822: LIST
72823: LIST
72824: PPUSH
72825: CALL_OW 2
72829: ST_TO_ADDR
72830: GO 72912
// for j = 1 to result do
72832: LD_ADDR_VAR 0 8
72836: PUSH
72837: DOUBLE
72838: LD_INT 1
72840: DEC
72841: ST_TO_ADDR
72842: LD_VAR 0 6
72846: PUSH
72847: FOR_TO
72848: IFFALSE 72910
// begin if tmp < result [ j ] [ 2 ] then
72850: LD_VAR 0 9
72854: PUSH
72855: LD_VAR 0 6
72859: PUSH
72860: LD_VAR 0 8
72864: ARRAY
72865: PUSH
72866: LD_INT 2
72868: ARRAY
72869: LESS
72870: IFFALSE 72908
// begin result := Insert ( result , j , [ i , tmp ] ) ;
72872: LD_ADDR_VAR 0 6
72876: PUSH
72877: LD_VAR 0 6
72881: PPUSH
72882: LD_VAR 0 8
72886: PPUSH
72887: LD_VAR 0 7
72891: PUSH
72892: LD_VAR 0 9
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PPUSH
72901: CALL_OW 2
72905: ST_TO_ADDR
// break ;
72906: GO 72910
// end ; end ;
72908: GO 72847
72910: POP
72911: POP
// end ; end ;
72912: GO 72711
72914: POP
72915: POP
// if result and not asc then
72916: LD_VAR 0 6
72920: PUSH
72921: LD_VAR 0 4
72925: NOT
72926: AND
72927: IFFALSE 73002
// begin tmp := result ;
72929: LD_ADDR_VAR 0 9
72933: PUSH
72934: LD_VAR 0 6
72938: ST_TO_ADDR
// for i = tmp downto 1 do
72939: LD_ADDR_VAR 0 7
72943: PUSH
72944: DOUBLE
72945: LD_VAR 0 9
72949: INC
72950: ST_TO_ADDR
72951: LD_INT 1
72953: PUSH
72954: FOR_DOWNTO
72955: IFFALSE 73000
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
72957: LD_ADDR_VAR 0 6
72961: PUSH
72962: LD_VAR 0 6
72966: PPUSH
72967: LD_VAR 0 9
72971: PUSH
72972: LD_VAR 0 7
72976: MINUS
72977: PUSH
72978: LD_INT 1
72980: PLUS
72981: PPUSH
72982: LD_VAR 0 9
72986: PUSH
72987: LD_VAR 0 7
72991: ARRAY
72992: PPUSH
72993: CALL_OW 1
72997: ST_TO_ADDR
72998: GO 72954
73000: POP
73001: POP
// end ; tmp := [ ] ;
73002: LD_ADDR_VAR 0 9
73006: PUSH
73007: EMPTY
73008: ST_TO_ADDR
// if mode then
73009: LD_VAR 0 5
73013: IFFALSE 73082
// begin for i = 1 to result do
73015: LD_ADDR_VAR 0 7
73019: PUSH
73020: DOUBLE
73021: LD_INT 1
73023: DEC
73024: ST_TO_ADDR
73025: LD_VAR 0 6
73029: PUSH
73030: FOR_TO
73031: IFFALSE 73070
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
73033: LD_ADDR_VAR 0 9
73037: PUSH
73038: LD_VAR 0 9
73042: PPUSH
73043: LD_VAR 0 7
73047: PPUSH
73048: LD_VAR 0 6
73052: PUSH
73053: LD_VAR 0 7
73057: ARRAY
73058: PUSH
73059: LD_INT 1
73061: ARRAY
73062: PPUSH
73063: CALL_OW 1
73067: ST_TO_ADDR
73068: GO 73030
73070: POP
73071: POP
// result := tmp ;
73072: LD_ADDR_VAR 0 6
73076: PUSH
73077: LD_VAR 0 9
73081: ST_TO_ADDR
// end ; end ;
73082: LD_VAR 0 6
73086: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
73087: LD_INT 0
73089: PPUSH
73090: PPUSH
73091: PPUSH
73092: PPUSH
73093: PPUSH
73094: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
73095: LD_ADDR_VAR 0 5
73099: PUSH
73100: LD_INT 0
73102: PUSH
73103: LD_INT 0
73105: PUSH
73106: LD_INT 0
73108: PUSH
73109: EMPTY
73110: PUSH
73111: EMPTY
73112: LIST
73113: LIST
73114: LIST
73115: LIST
73116: ST_TO_ADDR
// if not x or not y then
73117: LD_VAR 0 2
73121: NOT
73122: PUSH
73123: LD_VAR 0 3
73127: NOT
73128: OR
73129: IFFALSE 73133
// exit ;
73131: GO 74779
// if not range then
73133: LD_VAR 0 4
73137: NOT
73138: IFFALSE 73148
// range := 10 ;
73140: LD_ADDR_VAR 0 4
73144: PUSH
73145: LD_INT 10
73147: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
73148: LD_ADDR_VAR 0 8
73152: PUSH
73153: LD_INT 81
73155: PUSH
73156: LD_VAR 0 1
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 92
73167: PUSH
73168: LD_VAR 0 2
73172: PUSH
73173: LD_VAR 0 3
73177: PUSH
73178: LD_VAR 0 4
73182: PUSH
73183: EMPTY
73184: LIST
73185: LIST
73186: LIST
73187: LIST
73188: PUSH
73189: LD_INT 3
73191: PUSH
73192: LD_INT 21
73194: PUSH
73195: LD_INT 3
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: PUSH
73202: EMPTY
73203: LIST
73204: LIST
73205: PUSH
73206: EMPTY
73207: LIST
73208: LIST
73209: LIST
73210: PPUSH
73211: CALL_OW 69
73215: ST_TO_ADDR
// if not tmp then
73216: LD_VAR 0 8
73220: NOT
73221: IFFALSE 73225
// exit ;
73223: GO 74779
// for i in tmp do
73225: LD_ADDR_VAR 0 6
73229: PUSH
73230: LD_VAR 0 8
73234: PUSH
73235: FOR_IN
73236: IFFALSE 74754
// begin points := [ 0 , 0 , 0 ] ;
73238: LD_ADDR_VAR 0 9
73242: PUSH
73243: LD_INT 0
73245: PUSH
73246: LD_INT 0
73248: PUSH
73249: LD_INT 0
73251: PUSH
73252: EMPTY
73253: LIST
73254: LIST
73255: LIST
73256: ST_TO_ADDR
// bpoints := 1 ;
73257: LD_ADDR_VAR 0 10
73261: PUSH
73262: LD_INT 1
73264: ST_TO_ADDR
// case GetType ( i ) of unit_human :
73265: LD_VAR 0 6
73269: PPUSH
73270: CALL_OW 247
73274: PUSH
73275: LD_INT 1
73277: DOUBLE
73278: EQUAL
73279: IFTRUE 73283
73281: GO 73861
73283: POP
// begin if GetClass ( i ) = 1 then
73284: LD_VAR 0 6
73288: PPUSH
73289: CALL_OW 257
73293: PUSH
73294: LD_INT 1
73296: EQUAL
73297: IFFALSE 73318
// points := [ 10 , 5 , 3 ] ;
73299: LD_ADDR_VAR 0 9
73303: PUSH
73304: LD_INT 10
73306: PUSH
73307: LD_INT 5
73309: PUSH
73310: LD_INT 3
73312: PUSH
73313: EMPTY
73314: LIST
73315: LIST
73316: LIST
73317: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
73318: LD_VAR 0 6
73322: PPUSH
73323: CALL_OW 257
73327: PUSH
73328: LD_INT 2
73330: PUSH
73331: LD_INT 3
73333: PUSH
73334: LD_INT 4
73336: PUSH
73337: EMPTY
73338: LIST
73339: LIST
73340: LIST
73341: IN
73342: IFFALSE 73363
// points := [ 3 , 2 , 1 ] ;
73344: LD_ADDR_VAR 0 9
73348: PUSH
73349: LD_INT 3
73351: PUSH
73352: LD_INT 2
73354: PUSH
73355: LD_INT 1
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: LIST
73362: ST_TO_ADDR
// if GetClass ( i ) = 5 then
73363: LD_VAR 0 6
73367: PPUSH
73368: CALL_OW 257
73372: PUSH
73373: LD_INT 5
73375: EQUAL
73376: IFFALSE 73397
// points := [ 130 , 5 , 2 ] ;
73378: LD_ADDR_VAR 0 9
73382: PUSH
73383: LD_INT 130
73385: PUSH
73386: LD_INT 5
73388: PUSH
73389: LD_INT 2
73391: PUSH
73392: EMPTY
73393: LIST
73394: LIST
73395: LIST
73396: ST_TO_ADDR
// if GetClass ( i ) = 8 then
73397: LD_VAR 0 6
73401: PPUSH
73402: CALL_OW 257
73406: PUSH
73407: LD_INT 8
73409: EQUAL
73410: IFFALSE 73431
// points := [ 35 , 35 , 30 ] ;
73412: LD_ADDR_VAR 0 9
73416: PUSH
73417: LD_INT 35
73419: PUSH
73420: LD_INT 35
73422: PUSH
73423: LD_INT 30
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: LIST
73430: ST_TO_ADDR
// if GetClass ( i ) = 9 then
73431: LD_VAR 0 6
73435: PPUSH
73436: CALL_OW 257
73440: PUSH
73441: LD_INT 9
73443: EQUAL
73444: IFFALSE 73465
// points := [ 20 , 55 , 40 ] ;
73446: LD_ADDR_VAR 0 9
73450: PUSH
73451: LD_INT 20
73453: PUSH
73454: LD_INT 55
73456: PUSH
73457: LD_INT 40
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: LIST
73464: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
73465: LD_VAR 0 6
73469: PPUSH
73470: CALL_OW 257
73474: PUSH
73475: LD_INT 12
73477: PUSH
73478: LD_INT 16
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: IN
73485: IFFALSE 73506
// points := [ 5 , 3 , 2 ] ;
73487: LD_ADDR_VAR 0 9
73491: PUSH
73492: LD_INT 5
73494: PUSH
73495: LD_INT 3
73497: PUSH
73498: LD_INT 2
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: LIST
73505: ST_TO_ADDR
// if GetClass ( i ) = 17 then
73506: LD_VAR 0 6
73510: PPUSH
73511: CALL_OW 257
73515: PUSH
73516: LD_INT 17
73518: EQUAL
73519: IFFALSE 73540
// points := [ 100 , 50 , 75 ] ;
73521: LD_ADDR_VAR 0 9
73525: PUSH
73526: LD_INT 100
73528: PUSH
73529: LD_INT 50
73531: PUSH
73532: LD_INT 75
73534: PUSH
73535: EMPTY
73536: LIST
73537: LIST
73538: LIST
73539: ST_TO_ADDR
// if GetClass ( i ) = 15 then
73540: LD_VAR 0 6
73544: PPUSH
73545: CALL_OW 257
73549: PUSH
73550: LD_INT 15
73552: EQUAL
73553: IFFALSE 73574
// points := [ 10 , 5 , 3 ] ;
73555: LD_ADDR_VAR 0 9
73559: PUSH
73560: LD_INT 10
73562: PUSH
73563: LD_INT 5
73565: PUSH
73566: LD_INT 3
73568: PUSH
73569: EMPTY
73570: LIST
73571: LIST
73572: LIST
73573: ST_TO_ADDR
// if GetClass ( i ) = 14 then
73574: LD_VAR 0 6
73578: PPUSH
73579: CALL_OW 257
73583: PUSH
73584: LD_INT 14
73586: EQUAL
73587: IFFALSE 73608
// points := [ 10 , 0 , 0 ] ;
73589: LD_ADDR_VAR 0 9
73593: PUSH
73594: LD_INT 10
73596: PUSH
73597: LD_INT 0
73599: PUSH
73600: LD_INT 0
73602: PUSH
73603: EMPTY
73604: LIST
73605: LIST
73606: LIST
73607: ST_TO_ADDR
// if GetClass ( i ) = 11 then
73608: LD_VAR 0 6
73612: PPUSH
73613: CALL_OW 257
73617: PUSH
73618: LD_INT 11
73620: EQUAL
73621: IFFALSE 73642
// points := [ 30 , 10 , 5 ] ;
73623: LD_ADDR_VAR 0 9
73627: PUSH
73628: LD_INT 30
73630: PUSH
73631: LD_INT 10
73633: PUSH
73634: LD_INT 5
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: LIST
73641: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
73642: LD_VAR 0 1
73646: PPUSH
73647: LD_INT 5
73649: PPUSH
73650: CALL_OW 321
73654: PUSH
73655: LD_INT 2
73657: EQUAL
73658: IFFALSE 73675
// bpoints := bpoints * 1.8 ;
73660: LD_ADDR_VAR 0 10
73664: PUSH
73665: LD_VAR 0 10
73669: PUSH
73670: LD_REAL  1.80000000000000E+0000
73673: MUL
73674: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
73675: LD_VAR 0 6
73679: PPUSH
73680: CALL_OW 257
73684: PUSH
73685: LD_INT 1
73687: PUSH
73688: LD_INT 2
73690: PUSH
73691: LD_INT 3
73693: PUSH
73694: LD_INT 4
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: IN
73703: PUSH
73704: LD_VAR 0 1
73708: PPUSH
73709: LD_INT 51
73711: PPUSH
73712: CALL_OW 321
73716: PUSH
73717: LD_INT 2
73719: EQUAL
73720: AND
73721: IFFALSE 73738
// bpoints := bpoints * 1.2 ;
73723: LD_ADDR_VAR 0 10
73727: PUSH
73728: LD_VAR 0 10
73732: PUSH
73733: LD_REAL  1.20000000000000E+0000
73736: MUL
73737: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
73738: LD_VAR 0 6
73742: PPUSH
73743: CALL_OW 257
73747: PUSH
73748: LD_INT 5
73750: PUSH
73751: LD_INT 7
73753: PUSH
73754: LD_INT 9
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: LIST
73761: IN
73762: PUSH
73763: LD_VAR 0 1
73767: PPUSH
73768: LD_INT 52
73770: PPUSH
73771: CALL_OW 321
73775: PUSH
73776: LD_INT 2
73778: EQUAL
73779: AND
73780: IFFALSE 73797
// bpoints := bpoints * 1.5 ;
73782: LD_ADDR_VAR 0 10
73786: PUSH
73787: LD_VAR 0 10
73791: PUSH
73792: LD_REAL  1.50000000000000E+0000
73795: MUL
73796: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
73797: LD_VAR 0 1
73801: PPUSH
73802: LD_INT 66
73804: PPUSH
73805: CALL_OW 321
73809: PUSH
73810: LD_INT 2
73812: EQUAL
73813: IFFALSE 73830
// bpoints := bpoints * 1.1 ;
73815: LD_ADDR_VAR 0 10
73819: PUSH
73820: LD_VAR 0 10
73824: PUSH
73825: LD_REAL  1.10000000000000E+0000
73828: MUL
73829: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
73830: LD_ADDR_VAR 0 10
73834: PUSH
73835: LD_VAR 0 10
73839: PUSH
73840: LD_VAR 0 6
73844: PPUSH
73845: LD_INT 1
73847: PPUSH
73848: CALL_OW 259
73852: PUSH
73853: LD_REAL  1.15000000000000E+0000
73856: MUL
73857: MUL
73858: ST_TO_ADDR
// end ; unit_vehicle :
73859: GO 74683
73861: LD_INT 2
73863: DOUBLE
73864: EQUAL
73865: IFTRUE 73869
73867: GO 74671
73869: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
73870: LD_VAR 0 6
73874: PPUSH
73875: CALL_OW 264
73879: PUSH
73880: LD_INT 2
73882: PUSH
73883: LD_INT 42
73885: PUSH
73886: LD_INT 24
73888: PUSH
73889: EMPTY
73890: LIST
73891: LIST
73892: LIST
73893: IN
73894: IFFALSE 73915
// points := [ 25 , 5 , 3 ] ;
73896: LD_ADDR_VAR 0 9
73900: PUSH
73901: LD_INT 25
73903: PUSH
73904: LD_INT 5
73906: PUSH
73907: LD_INT 3
73909: PUSH
73910: EMPTY
73911: LIST
73912: LIST
73913: LIST
73914: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
73915: LD_VAR 0 6
73919: PPUSH
73920: CALL_OW 264
73924: PUSH
73925: LD_INT 4
73927: PUSH
73928: LD_INT 43
73930: PUSH
73931: LD_INT 25
73933: PUSH
73934: EMPTY
73935: LIST
73936: LIST
73937: LIST
73938: IN
73939: IFFALSE 73960
// points := [ 40 , 15 , 5 ] ;
73941: LD_ADDR_VAR 0 9
73945: PUSH
73946: LD_INT 40
73948: PUSH
73949: LD_INT 15
73951: PUSH
73952: LD_INT 5
73954: PUSH
73955: EMPTY
73956: LIST
73957: LIST
73958: LIST
73959: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
73960: LD_VAR 0 6
73964: PPUSH
73965: CALL_OW 264
73969: PUSH
73970: LD_INT 3
73972: PUSH
73973: LD_INT 23
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: IN
73980: IFFALSE 74001
// points := [ 7 , 25 , 8 ] ;
73982: LD_ADDR_VAR 0 9
73986: PUSH
73987: LD_INT 7
73989: PUSH
73990: LD_INT 25
73992: PUSH
73993: LD_INT 8
73995: PUSH
73996: EMPTY
73997: LIST
73998: LIST
73999: LIST
74000: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
74001: LD_VAR 0 6
74005: PPUSH
74006: CALL_OW 264
74010: PUSH
74011: LD_INT 5
74013: PUSH
74014: LD_INT 27
74016: PUSH
74017: LD_INT 44
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: LIST
74024: IN
74025: IFFALSE 74046
// points := [ 14 , 50 , 16 ] ;
74027: LD_ADDR_VAR 0 9
74031: PUSH
74032: LD_INT 14
74034: PUSH
74035: LD_INT 50
74037: PUSH
74038: LD_INT 16
74040: PUSH
74041: EMPTY
74042: LIST
74043: LIST
74044: LIST
74045: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
74046: LD_VAR 0 6
74050: PPUSH
74051: CALL_OW 264
74055: PUSH
74056: LD_INT 6
74058: PUSH
74059: LD_INT 46
74061: PUSH
74062: EMPTY
74063: LIST
74064: LIST
74065: IN
74066: IFFALSE 74087
// points := [ 32 , 120 , 70 ] ;
74068: LD_ADDR_VAR 0 9
74072: PUSH
74073: LD_INT 32
74075: PUSH
74076: LD_INT 120
74078: PUSH
74079: LD_INT 70
74081: PUSH
74082: EMPTY
74083: LIST
74084: LIST
74085: LIST
74086: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
74087: LD_VAR 0 6
74091: PPUSH
74092: CALL_OW 264
74096: PUSH
74097: LD_INT 7
74099: PUSH
74100: LD_INT 28
74102: PUSH
74103: LD_INT 45
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: LIST
74110: IN
74111: IFFALSE 74132
// points := [ 35 , 20 , 45 ] ;
74113: LD_ADDR_VAR 0 9
74117: PUSH
74118: LD_INT 35
74120: PUSH
74121: LD_INT 20
74123: PUSH
74124: LD_INT 45
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: LIST
74131: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
74132: LD_VAR 0 6
74136: PPUSH
74137: CALL_OW 264
74141: PUSH
74142: LD_INT 47
74144: PUSH
74145: EMPTY
74146: LIST
74147: IN
74148: IFFALSE 74169
// points := [ 67 , 45 , 75 ] ;
74150: LD_ADDR_VAR 0 9
74154: PUSH
74155: LD_INT 67
74157: PUSH
74158: LD_INT 45
74160: PUSH
74161: LD_INT 75
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: LIST
74168: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
74169: LD_VAR 0 6
74173: PPUSH
74174: CALL_OW 264
74178: PUSH
74179: LD_INT 26
74181: PUSH
74182: EMPTY
74183: LIST
74184: IN
74185: IFFALSE 74206
// points := [ 120 , 30 , 80 ] ;
74187: LD_ADDR_VAR 0 9
74191: PUSH
74192: LD_INT 120
74194: PUSH
74195: LD_INT 30
74197: PUSH
74198: LD_INT 80
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: LIST
74205: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
74206: LD_VAR 0 6
74210: PPUSH
74211: CALL_OW 264
74215: PUSH
74216: LD_INT 22
74218: PUSH
74219: EMPTY
74220: LIST
74221: IN
74222: IFFALSE 74243
// points := [ 40 , 1 , 1 ] ;
74224: LD_ADDR_VAR 0 9
74228: PUSH
74229: LD_INT 40
74231: PUSH
74232: LD_INT 1
74234: PUSH
74235: LD_INT 1
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: LIST
74242: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
74243: LD_VAR 0 6
74247: PPUSH
74248: CALL_OW 264
74252: PUSH
74253: LD_INT 29
74255: PUSH
74256: EMPTY
74257: LIST
74258: IN
74259: IFFALSE 74280
// points := [ 70 , 200 , 400 ] ;
74261: LD_ADDR_VAR 0 9
74265: PUSH
74266: LD_INT 70
74268: PUSH
74269: LD_INT 200
74271: PUSH
74272: LD_INT 400
74274: PUSH
74275: EMPTY
74276: LIST
74277: LIST
74278: LIST
74279: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
74280: LD_VAR 0 6
74284: PPUSH
74285: CALL_OW 264
74289: PUSH
74290: LD_INT 14
74292: PUSH
74293: LD_INT 53
74295: PUSH
74296: EMPTY
74297: LIST
74298: LIST
74299: IN
74300: IFFALSE 74321
// points := [ 40 , 10 , 20 ] ;
74302: LD_ADDR_VAR 0 9
74306: PUSH
74307: LD_INT 40
74309: PUSH
74310: LD_INT 10
74312: PUSH
74313: LD_INT 20
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: LIST
74320: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
74321: LD_VAR 0 6
74325: PPUSH
74326: CALL_OW 264
74330: PUSH
74331: LD_INT 9
74333: PUSH
74334: EMPTY
74335: LIST
74336: IN
74337: IFFALSE 74358
// points := [ 5 , 70 , 20 ] ;
74339: LD_ADDR_VAR 0 9
74343: PUSH
74344: LD_INT 5
74346: PUSH
74347: LD_INT 70
74349: PUSH
74350: LD_INT 20
74352: PUSH
74353: EMPTY
74354: LIST
74355: LIST
74356: LIST
74357: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
74358: LD_VAR 0 6
74362: PPUSH
74363: CALL_OW 264
74367: PUSH
74368: LD_INT 10
74370: PUSH
74371: EMPTY
74372: LIST
74373: IN
74374: IFFALSE 74395
// points := [ 35 , 110 , 70 ] ;
74376: LD_ADDR_VAR 0 9
74380: PUSH
74381: LD_INT 35
74383: PUSH
74384: LD_INT 110
74386: PUSH
74387: LD_INT 70
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: LIST
74394: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
74395: LD_VAR 0 6
74399: PPUSH
74400: CALL_OW 265
74404: PUSH
74405: LD_INT 25
74407: EQUAL
74408: IFFALSE 74429
// points := [ 80 , 65 , 100 ] ;
74410: LD_ADDR_VAR 0 9
74414: PUSH
74415: LD_INT 80
74417: PUSH
74418: LD_INT 65
74420: PUSH
74421: LD_INT 100
74423: PUSH
74424: EMPTY
74425: LIST
74426: LIST
74427: LIST
74428: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
74429: LD_VAR 0 6
74433: PPUSH
74434: CALL_OW 263
74438: PUSH
74439: LD_INT 1
74441: EQUAL
74442: IFFALSE 74477
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
74444: LD_ADDR_VAR 0 10
74448: PUSH
74449: LD_VAR 0 10
74453: PUSH
74454: LD_VAR 0 6
74458: PPUSH
74459: CALL_OW 311
74463: PPUSH
74464: LD_INT 3
74466: PPUSH
74467: CALL_OW 259
74471: PUSH
74472: LD_INT 4
74474: MUL
74475: MUL
74476: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
74477: LD_VAR 0 6
74481: PPUSH
74482: CALL_OW 263
74486: PUSH
74487: LD_INT 2
74489: EQUAL
74490: IFFALSE 74541
// begin j := IsControledBy ( i ) ;
74492: LD_ADDR_VAR 0 7
74496: PUSH
74497: LD_VAR 0 6
74501: PPUSH
74502: CALL_OW 312
74506: ST_TO_ADDR
// if j then
74507: LD_VAR 0 7
74511: IFFALSE 74541
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
74513: LD_ADDR_VAR 0 10
74517: PUSH
74518: LD_VAR 0 10
74522: PUSH
74523: LD_VAR 0 7
74527: PPUSH
74528: LD_INT 3
74530: PPUSH
74531: CALL_OW 259
74535: PUSH
74536: LD_INT 3
74538: MUL
74539: MUL
74540: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
74541: LD_VAR 0 6
74545: PPUSH
74546: CALL_OW 264
74550: PUSH
74551: LD_INT 5
74553: PUSH
74554: LD_INT 6
74556: PUSH
74557: LD_INT 46
74559: PUSH
74560: LD_INT 44
74562: PUSH
74563: LD_INT 47
74565: PUSH
74566: LD_INT 45
74568: PUSH
74569: LD_INT 28
74571: PUSH
74572: LD_INT 7
74574: PUSH
74575: LD_INT 27
74577: PUSH
74578: LD_INT 29
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: LIST
74585: LIST
74586: LIST
74587: LIST
74588: LIST
74589: LIST
74590: LIST
74591: LIST
74592: IN
74593: PUSH
74594: LD_VAR 0 1
74598: PPUSH
74599: LD_INT 52
74601: PPUSH
74602: CALL_OW 321
74606: PUSH
74607: LD_INT 2
74609: EQUAL
74610: AND
74611: IFFALSE 74628
// bpoints := bpoints * 1.2 ;
74613: LD_ADDR_VAR 0 10
74617: PUSH
74618: LD_VAR 0 10
74622: PUSH
74623: LD_REAL  1.20000000000000E+0000
74626: MUL
74627: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
74628: LD_VAR 0 6
74632: PPUSH
74633: CALL_OW 264
74637: PUSH
74638: LD_INT 6
74640: PUSH
74641: LD_INT 46
74643: PUSH
74644: LD_INT 47
74646: PUSH
74647: EMPTY
74648: LIST
74649: LIST
74650: LIST
74651: IN
74652: IFFALSE 74669
// bpoints := bpoints * 1.2 ;
74654: LD_ADDR_VAR 0 10
74658: PUSH
74659: LD_VAR 0 10
74663: PUSH
74664: LD_REAL  1.20000000000000E+0000
74667: MUL
74668: ST_TO_ADDR
// end ; unit_building :
74669: GO 74683
74671: LD_INT 3
74673: DOUBLE
74674: EQUAL
74675: IFTRUE 74679
74677: GO 74682
74679: POP
// ; end ;
74680: GO 74683
74682: POP
// for j = 1 to 3 do
74683: LD_ADDR_VAR 0 7
74687: PUSH
74688: DOUBLE
74689: LD_INT 1
74691: DEC
74692: ST_TO_ADDR
74693: LD_INT 3
74695: PUSH
74696: FOR_TO
74697: IFFALSE 74750
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
74699: LD_ADDR_VAR 0 5
74703: PUSH
74704: LD_VAR 0 5
74708: PPUSH
74709: LD_VAR 0 7
74713: PPUSH
74714: LD_VAR 0 5
74718: PUSH
74719: LD_VAR 0 7
74723: ARRAY
74724: PUSH
74725: LD_VAR 0 9
74729: PUSH
74730: LD_VAR 0 7
74734: ARRAY
74735: PUSH
74736: LD_VAR 0 10
74740: MUL
74741: PLUS
74742: PPUSH
74743: CALL_OW 1
74747: ST_TO_ADDR
74748: GO 74696
74750: POP
74751: POP
// end ;
74752: GO 73235
74754: POP
74755: POP
// result := Replace ( result , 4 , tmp ) ;
74756: LD_ADDR_VAR 0 5
74760: PUSH
74761: LD_VAR 0 5
74765: PPUSH
74766: LD_INT 4
74768: PPUSH
74769: LD_VAR 0 8
74773: PPUSH
74774: CALL_OW 1
74778: ST_TO_ADDR
// end ;
74779: LD_VAR 0 5
74783: RET
// export function DangerAtRange ( unit , range ) ; begin
74784: LD_INT 0
74786: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
74787: LD_ADDR_VAR 0 3
74791: PUSH
74792: LD_VAR 0 1
74796: PPUSH
74797: CALL_OW 255
74801: PPUSH
74802: LD_VAR 0 1
74806: PPUSH
74807: CALL_OW 250
74811: PPUSH
74812: LD_VAR 0 1
74816: PPUSH
74817: CALL_OW 251
74821: PPUSH
74822: LD_VAR 0 2
74826: PPUSH
74827: CALL 73087 0 4
74831: ST_TO_ADDR
// end ;
74832: LD_VAR 0 3
74836: RET
// export function DangerInArea ( side , area ) ; begin
74837: LD_INT 0
74839: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
74840: LD_ADDR_VAR 0 3
74844: PUSH
74845: LD_VAR 0 2
74849: PPUSH
74850: LD_INT 81
74852: PUSH
74853: LD_VAR 0 1
74857: PUSH
74858: EMPTY
74859: LIST
74860: LIST
74861: PPUSH
74862: CALL_OW 70
74866: ST_TO_ADDR
// end ;
74867: LD_VAR 0 3
74871: RET
// export function IsExtension ( b ) ; begin
74872: LD_INT 0
74874: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
74875: LD_ADDR_VAR 0 2
74879: PUSH
74880: LD_VAR 0 1
74884: PUSH
74885: LD_INT 23
74887: PUSH
74888: LD_INT 20
74890: PUSH
74891: LD_INT 22
74893: PUSH
74894: LD_INT 17
74896: PUSH
74897: LD_INT 24
74899: PUSH
74900: LD_INT 21
74902: PUSH
74903: LD_INT 19
74905: PUSH
74906: LD_INT 16
74908: PUSH
74909: LD_INT 25
74911: PUSH
74912: LD_INT 18
74914: PUSH
74915: EMPTY
74916: LIST
74917: LIST
74918: LIST
74919: LIST
74920: LIST
74921: LIST
74922: LIST
74923: LIST
74924: LIST
74925: LIST
74926: IN
74927: ST_TO_ADDR
// end ;
74928: LD_VAR 0 2
74932: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
74933: LD_INT 0
74935: PPUSH
74936: PPUSH
74937: PPUSH
// result := [ ] ;
74938: LD_ADDR_VAR 0 3
74942: PUSH
74943: EMPTY
74944: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
74945: LD_ADDR_VAR 0 4
74949: PUSH
74950: LD_VAR 0 2
74954: PPUSH
74955: LD_INT 21
74957: PUSH
74958: LD_INT 3
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PPUSH
74965: CALL_OW 70
74969: ST_TO_ADDR
// if not tmp then
74970: LD_VAR 0 4
74974: NOT
74975: IFFALSE 74979
// exit ;
74977: GO 75037
// for i in tmp do
74979: LD_ADDR_VAR 0 5
74983: PUSH
74984: LD_VAR 0 4
74988: PUSH
74989: FOR_IN
74990: IFFALSE 75025
// if GetBase ( i ) <> base then
74992: LD_VAR 0 5
74996: PPUSH
74997: CALL_OW 274
75001: PUSH
75002: LD_VAR 0 1
75006: NONEQUAL
75007: IFFALSE 75023
// ComLinkToBase ( base , i ) ;
75009: LD_VAR 0 1
75013: PPUSH
75014: LD_VAR 0 5
75018: PPUSH
75019: CALL_OW 169
75023: GO 74989
75025: POP
75026: POP
// result := tmp ;
75027: LD_ADDR_VAR 0 3
75031: PUSH
75032: LD_VAR 0 4
75036: ST_TO_ADDR
// end ;
75037: LD_VAR 0 3
75041: RET
// export function ComComplete ( unit , b ) ; var i ; begin
75042: LD_INT 0
75044: PPUSH
75045: PPUSH
// if BuildingStatus ( b ) = bs_build then
75046: LD_VAR 0 2
75050: PPUSH
75051: CALL_OW 461
75055: PUSH
75056: LD_INT 1
75058: EQUAL
75059: IFFALSE 75119
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
75061: LD_VAR 0 1
75065: PPUSH
75066: LD_STRING h
75068: PUSH
75069: LD_VAR 0 2
75073: PPUSH
75074: CALL_OW 250
75078: PUSH
75079: LD_VAR 0 2
75083: PPUSH
75084: CALL_OW 251
75088: PUSH
75089: LD_VAR 0 2
75093: PUSH
75094: LD_INT 0
75096: PUSH
75097: LD_INT 0
75099: PUSH
75100: LD_INT 0
75102: PUSH
75103: EMPTY
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: LIST
75111: PUSH
75112: EMPTY
75113: LIST
75114: PPUSH
75115: CALL_OW 446
// end ;
75119: LD_VAR 0 3
75123: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
75124: LD_INT 0
75126: PPUSH
75127: PPUSH
75128: PPUSH
75129: PPUSH
75130: PPUSH
75131: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
75132: LD_VAR 0 1
75136: NOT
75137: PUSH
75138: LD_VAR 0 1
75142: PPUSH
75143: CALL_OW 263
75147: PUSH
75148: LD_INT 2
75150: EQUAL
75151: NOT
75152: OR
75153: IFFALSE 75157
// exit ;
75155: GO 75473
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
75157: LD_ADDR_VAR 0 6
75161: PUSH
75162: LD_INT 22
75164: PUSH
75165: LD_VAR 0 1
75169: PPUSH
75170: CALL_OW 255
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: PUSH
75179: LD_INT 2
75181: PUSH
75182: LD_INT 30
75184: PUSH
75185: LD_INT 36
75187: PUSH
75188: EMPTY
75189: LIST
75190: LIST
75191: PUSH
75192: LD_INT 34
75194: PUSH
75195: LD_INT 31
75197: PUSH
75198: EMPTY
75199: LIST
75200: LIST
75201: PUSH
75202: EMPTY
75203: LIST
75204: LIST
75205: LIST
75206: PUSH
75207: EMPTY
75208: LIST
75209: LIST
75210: PPUSH
75211: CALL_OW 69
75215: ST_TO_ADDR
// if not tmp then
75216: LD_VAR 0 6
75220: NOT
75221: IFFALSE 75225
// exit ;
75223: GO 75473
// result := [ ] ;
75225: LD_ADDR_VAR 0 2
75229: PUSH
75230: EMPTY
75231: ST_TO_ADDR
// for i in tmp do
75232: LD_ADDR_VAR 0 3
75236: PUSH
75237: LD_VAR 0 6
75241: PUSH
75242: FOR_IN
75243: IFFALSE 75314
// begin t := UnitsInside ( i ) ;
75245: LD_ADDR_VAR 0 4
75249: PUSH
75250: LD_VAR 0 3
75254: PPUSH
75255: CALL_OW 313
75259: ST_TO_ADDR
// if t then
75260: LD_VAR 0 4
75264: IFFALSE 75312
// for j in t do
75266: LD_ADDR_VAR 0 7
75270: PUSH
75271: LD_VAR 0 4
75275: PUSH
75276: FOR_IN
75277: IFFALSE 75310
// result := Insert ( result , result + 1 , j ) ;
75279: LD_ADDR_VAR 0 2
75283: PUSH
75284: LD_VAR 0 2
75288: PPUSH
75289: LD_VAR 0 2
75293: PUSH
75294: LD_INT 1
75296: PLUS
75297: PPUSH
75298: LD_VAR 0 7
75302: PPUSH
75303: CALL_OW 2
75307: ST_TO_ADDR
75308: GO 75276
75310: POP
75311: POP
// end ;
75312: GO 75242
75314: POP
75315: POP
// if not result then
75316: LD_VAR 0 2
75320: NOT
75321: IFFALSE 75325
// exit ;
75323: GO 75473
// mech := result [ 1 ] ;
75325: LD_ADDR_VAR 0 5
75329: PUSH
75330: LD_VAR 0 2
75334: PUSH
75335: LD_INT 1
75337: ARRAY
75338: ST_TO_ADDR
// if result > 1 then
75339: LD_VAR 0 2
75343: PUSH
75344: LD_INT 1
75346: GREATER
75347: IFFALSE 75459
// for i = 2 to result do
75349: LD_ADDR_VAR 0 3
75353: PUSH
75354: DOUBLE
75355: LD_INT 2
75357: DEC
75358: ST_TO_ADDR
75359: LD_VAR 0 2
75363: PUSH
75364: FOR_TO
75365: IFFALSE 75457
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
75367: LD_ADDR_VAR 0 4
75371: PUSH
75372: LD_VAR 0 2
75376: PUSH
75377: LD_VAR 0 3
75381: ARRAY
75382: PPUSH
75383: LD_INT 3
75385: PPUSH
75386: CALL_OW 259
75390: PUSH
75391: LD_VAR 0 2
75395: PUSH
75396: LD_VAR 0 3
75400: ARRAY
75401: PPUSH
75402: CALL_OW 432
75406: MINUS
75407: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
75408: LD_VAR 0 4
75412: PUSH
75413: LD_VAR 0 5
75417: PPUSH
75418: LD_INT 3
75420: PPUSH
75421: CALL_OW 259
75425: PUSH
75426: LD_VAR 0 5
75430: PPUSH
75431: CALL_OW 432
75435: MINUS
75436: GREATEREQUAL
75437: IFFALSE 75455
// mech := result [ i ] ;
75439: LD_ADDR_VAR 0 5
75443: PUSH
75444: LD_VAR 0 2
75448: PUSH
75449: LD_VAR 0 3
75453: ARRAY
75454: ST_TO_ADDR
// end ;
75455: GO 75364
75457: POP
75458: POP
// ComLinkTo ( vehicle , mech ) ;
75459: LD_VAR 0 1
75463: PPUSH
75464: LD_VAR 0 5
75468: PPUSH
75469: CALL_OW 135
// end ;
75473: LD_VAR 0 2
75477: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
75478: LD_INT 0
75480: PPUSH
75481: PPUSH
75482: PPUSH
75483: PPUSH
75484: PPUSH
75485: PPUSH
75486: PPUSH
75487: PPUSH
75488: PPUSH
75489: PPUSH
75490: PPUSH
75491: PPUSH
75492: PPUSH
// result := [ ] ;
75493: LD_ADDR_VAR 0 7
75497: PUSH
75498: EMPTY
75499: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
75500: LD_VAR 0 1
75504: PPUSH
75505: CALL_OW 266
75509: PUSH
75510: LD_INT 0
75512: PUSH
75513: LD_INT 1
75515: PUSH
75516: EMPTY
75517: LIST
75518: LIST
75519: IN
75520: NOT
75521: IFFALSE 75525
// exit ;
75523: GO 77156
// if name then
75525: LD_VAR 0 3
75529: IFFALSE 75545
// SetBName ( base_dep , name ) ;
75531: LD_VAR 0 1
75535: PPUSH
75536: LD_VAR 0 3
75540: PPUSH
75541: CALL_OW 500
// base := GetBase ( base_dep ) ;
75545: LD_ADDR_VAR 0 15
75549: PUSH
75550: LD_VAR 0 1
75554: PPUSH
75555: CALL_OW 274
75559: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
75560: LD_ADDR_VAR 0 16
75564: PUSH
75565: LD_VAR 0 1
75569: PPUSH
75570: CALL_OW 255
75574: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
75575: LD_ADDR_VAR 0 17
75579: PUSH
75580: LD_VAR 0 1
75584: PPUSH
75585: CALL_OW 248
75589: ST_TO_ADDR
// if sources then
75590: LD_VAR 0 5
75594: IFFALSE 75641
// for i = 1 to 3 do
75596: LD_ADDR_VAR 0 8
75600: PUSH
75601: DOUBLE
75602: LD_INT 1
75604: DEC
75605: ST_TO_ADDR
75606: LD_INT 3
75608: PUSH
75609: FOR_TO
75610: IFFALSE 75639
// AddResourceType ( base , i , sources [ i ] ) ;
75612: LD_VAR 0 15
75616: PPUSH
75617: LD_VAR 0 8
75621: PPUSH
75622: LD_VAR 0 5
75626: PUSH
75627: LD_VAR 0 8
75631: ARRAY
75632: PPUSH
75633: CALL_OW 276
75637: GO 75609
75639: POP
75640: POP
// buildings := GetBaseBuildings ( base , area ) ;
75641: LD_ADDR_VAR 0 18
75645: PUSH
75646: LD_VAR 0 15
75650: PPUSH
75651: LD_VAR 0 2
75655: PPUSH
75656: CALL 74933 0 2
75660: ST_TO_ADDR
// InitHc ;
75661: CALL_OW 19
// InitUc ;
75665: CALL_OW 18
// uc_side := side ;
75669: LD_ADDR_OWVAR 20
75673: PUSH
75674: LD_VAR 0 16
75678: ST_TO_ADDR
// uc_nation := nation ;
75679: LD_ADDR_OWVAR 21
75683: PUSH
75684: LD_VAR 0 17
75688: ST_TO_ADDR
// if buildings then
75689: LD_VAR 0 18
75693: IFFALSE 77015
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
75695: LD_ADDR_VAR 0 19
75699: PUSH
75700: LD_VAR 0 18
75704: PPUSH
75705: LD_INT 2
75707: PUSH
75708: LD_INT 30
75710: PUSH
75711: LD_INT 29
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: PUSH
75718: LD_INT 30
75720: PUSH
75721: LD_INT 30
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: LIST
75732: PPUSH
75733: CALL_OW 72
75737: ST_TO_ADDR
// if tmp then
75738: LD_VAR 0 19
75742: IFFALSE 75790
// for i in tmp do
75744: LD_ADDR_VAR 0 8
75748: PUSH
75749: LD_VAR 0 19
75753: PUSH
75754: FOR_IN
75755: IFFALSE 75788
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
75757: LD_VAR 0 8
75761: PPUSH
75762: CALL_OW 250
75766: PPUSH
75767: LD_VAR 0 8
75771: PPUSH
75772: CALL_OW 251
75776: PPUSH
75777: LD_VAR 0 16
75781: PPUSH
75782: CALL_OW 441
75786: GO 75754
75788: POP
75789: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
75790: LD_VAR 0 18
75794: PPUSH
75795: LD_INT 2
75797: PUSH
75798: LD_INT 30
75800: PUSH
75801: LD_INT 32
75803: PUSH
75804: EMPTY
75805: LIST
75806: LIST
75807: PUSH
75808: LD_INT 30
75810: PUSH
75811: LD_INT 33
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: EMPTY
75819: LIST
75820: LIST
75821: LIST
75822: PPUSH
75823: CALL_OW 72
75827: IFFALSE 75915
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
75829: LD_ADDR_VAR 0 8
75833: PUSH
75834: LD_VAR 0 18
75838: PPUSH
75839: LD_INT 2
75841: PUSH
75842: LD_INT 30
75844: PUSH
75845: LD_INT 32
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: LD_INT 30
75854: PUSH
75855: LD_INT 33
75857: PUSH
75858: EMPTY
75859: LIST
75860: LIST
75861: PUSH
75862: EMPTY
75863: LIST
75864: LIST
75865: LIST
75866: PPUSH
75867: CALL_OW 72
75871: PUSH
75872: FOR_IN
75873: IFFALSE 75913
// begin if not GetBWeapon ( i ) then
75875: LD_VAR 0 8
75879: PPUSH
75880: CALL_OW 269
75884: NOT
75885: IFFALSE 75911
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
75887: LD_VAR 0 8
75891: PPUSH
75892: LD_VAR 0 8
75896: PPUSH
75897: LD_VAR 0 2
75901: PPUSH
75902: CALL 77161 0 2
75906: PPUSH
75907: CALL_OW 431
// end ;
75911: GO 75872
75913: POP
75914: POP
// end ; for i = 1 to personel do
75915: LD_ADDR_VAR 0 8
75919: PUSH
75920: DOUBLE
75921: LD_INT 1
75923: DEC
75924: ST_TO_ADDR
75925: LD_VAR 0 6
75929: PUSH
75930: FOR_TO
75931: IFFALSE 76995
// begin if i > 4 then
75933: LD_VAR 0 8
75937: PUSH
75938: LD_INT 4
75940: GREATER
75941: IFFALSE 75945
// break ;
75943: GO 76995
// case i of 1 :
75945: LD_VAR 0 8
75949: PUSH
75950: LD_INT 1
75952: DOUBLE
75953: EQUAL
75954: IFTRUE 75958
75956: GO 76038
75958: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
75959: LD_ADDR_VAR 0 12
75963: PUSH
75964: LD_VAR 0 18
75968: PPUSH
75969: LD_INT 22
75971: PUSH
75972: LD_VAR 0 16
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: PUSH
75981: LD_INT 58
75983: PUSH
75984: EMPTY
75985: LIST
75986: PUSH
75987: LD_INT 2
75989: PUSH
75990: LD_INT 30
75992: PUSH
75993: LD_INT 32
75995: PUSH
75996: EMPTY
75997: LIST
75998: LIST
75999: PUSH
76000: LD_INT 30
76002: PUSH
76003: LD_INT 4
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: LD_INT 30
76012: PUSH
76013: LD_INT 5
76015: PUSH
76016: EMPTY
76017: LIST
76018: LIST
76019: PUSH
76020: EMPTY
76021: LIST
76022: LIST
76023: LIST
76024: LIST
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: LIST
76030: PPUSH
76031: CALL_OW 72
76035: ST_TO_ADDR
76036: GO 76260
76038: LD_INT 2
76040: DOUBLE
76041: EQUAL
76042: IFTRUE 76046
76044: GO 76108
76046: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
76047: LD_ADDR_VAR 0 12
76051: PUSH
76052: LD_VAR 0 18
76056: PPUSH
76057: LD_INT 22
76059: PUSH
76060: LD_VAR 0 16
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: PUSH
76069: LD_INT 2
76071: PUSH
76072: LD_INT 30
76074: PUSH
76075: LD_INT 0
76077: PUSH
76078: EMPTY
76079: LIST
76080: LIST
76081: PUSH
76082: LD_INT 30
76084: PUSH
76085: LD_INT 1
76087: PUSH
76088: EMPTY
76089: LIST
76090: LIST
76091: PUSH
76092: EMPTY
76093: LIST
76094: LIST
76095: LIST
76096: PUSH
76097: EMPTY
76098: LIST
76099: LIST
76100: PPUSH
76101: CALL_OW 72
76105: ST_TO_ADDR
76106: GO 76260
76108: LD_INT 3
76110: DOUBLE
76111: EQUAL
76112: IFTRUE 76116
76114: GO 76178
76116: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
76117: LD_ADDR_VAR 0 12
76121: PUSH
76122: LD_VAR 0 18
76126: PPUSH
76127: LD_INT 22
76129: PUSH
76130: LD_VAR 0 16
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: PUSH
76139: LD_INT 2
76141: PUSH
76142: LD_INT 30
76144: PUSH
76145: LD_INT 2
76147: PUSH
76148: EMPTY
76149: LIST
76150: LIST
76151: PUSH
76152: LD_INT 30
76154: PUSH
76155: LD_INT 3
76157: PUSH
76158: EMPTY
76159: LIST
76160: LIST
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: LIST
76166: PUSH
76167: EMPTY
76168: LIST
76169: LIST
76170: PPUSH
76171: CALL_OW 72
76175: ST_TO_ADDR
76176: GO 76260
76178: LD_INT 4
76180: DOUBLE
76181: EQUAL
76182: IFTRUE 76186
76184: GO 76259
76186: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
76187: LD_ADDR_VAR 0 12
76191: PUSH
76192: LD_VAR 0 18
76196: PPUSH
76197: LD_INT 22
76199: PUSH
76200: LD_VAR 0 16
76204: PUSH
76205: EMPTY
76206: LIST
76207: LIST
76208: PUSH
76209: LD_INT 2
76211: PUSH
76212: LD_INT 30
76214: PUSH
76215: LD_INT 6
76217: PUSH
76218: EMPTY
76219: LIST
76220: LIST
76221: PUSH
76222: LD_INT 30
76224: PUSH
76225: LD_INT 7
76227: PUSH
76228: EMPTY
76229: LIST
76230: LIST
76231: PUSH
76232: LD_INT 30
76234: PUSH
76235: LD_INT 8
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: LIST
76246: LIST
76247: PUSH
76248: EMPTY
76249: LIST
76250: LIST
76251: PPUSH
76252: CALL_OW 72
76256: ST_TO_ADDR
76257: GO 76260
76259: POP
// if i = 1 then
76260: LD_VAR 0 8
76264: PUSH
76265: LD_INT 1
76267: EQUAL
76268: IFFALSE 76379
// begin tmp := [ ] ;
76270: LD_ADDR_VAR 0 19
76274: PUSH
76275: EMPTY
76276: ST_TO_ADDR
// for j in f do
76277: LD_ADDR_VAR 0 9
76281: PUSH
76282: LD_VAR 0 12
76286: PUSH
76287: FOR_IN
76288: IFFALSE 76361
// if GetBType ( j ) = b_bunker then
76290: LD_VAR 0 9
76294: PPUSH
76295: CALL_OW 266
76299: PUSH
76300: LD_INT 32
76302: EQUAL
76303: IFFALSE 76330
// tmp := Insert ( tmp , 1 , j ) else
76305: LD_ADDR_VAR 0 19
76309: PUSH
76310: LD_VAR 0 19
76314: PPUSH
76315: LD_INT 1
76317: PPUSH
76318: LD_VAR 0 9
76322: PPUSH
76323: CALL_OW 2
76327: ST_TO_ADDR
76328: GO 76359
// tmp := Insert ( tmp , tmp + 1 , j ) ;
76330: LD_ADDR_VAR 0 19
76334: PUSH
76335: LD_VAR 0 19
76339: PPUSH
76340: LD_VAR 0 19
76344: PUSH
76345: LD_INT 1
76347: PLUS
76348: PPUSH
76349: LD_VAR 0 9
76353: PPUSH
76354: CALL_OW 2
76358: ST_TO_ADDR
76359: GO 76287
76361: POP
76362: POP
// if tmp then
76363: LD_VAR 0 19
76367: IFFALSE 76379
// f := tmp ;
76369: LD_ADDR_VAR 0 12
76373: PUSH
76374: LD_VAR 0 19
76378: ST_TO_ADDR
// end ; x := personel [ i ] ;
76379: LD_ADDR_VAR 0 13
76383: PUSH
76384: LD_VAR 0 6
76388: PUSH
76389: LD_VAR 0 8
76393: ARRAY
76394: ST_TO_ADDR
// if x = - 1 then
76395: LD_VAR 0 13
76399: PUSH
76400: LD_INT 1
76402: NEG
76403: EQUAL
76404: IFFALSE 76613
// begin for j in f do
76406: LD_ADDR_VAR 0 9
76410: PUSH
76411: LD_VAR 0 12
76415: PUSH
76416: FOR_IN
76417: IFFALSE 76609
// repeat InitHc ;
76419: CALL_OW 19
// if GetBType ( j ) = b_barracks then
76423: LD_VAR 0 9
76427: PPUSH
76428: CALL_OW 266
76432: PUSH
76433: LD_INT 5
76435: EQUAL
76436: IFFALSE 76506
// begin if UnitsInside ( j ) < 3 then
76438: LD_VAR 0 9
76442: PPUSH
76443: CALL_OW 313
76447: PUSH
76448: LD_INT 3
76450: LESS
76451: IFFALSE 76487
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76453: LD_INT 0
76455: PPUSH
76456: LD_INT 5
76458: PUSH
76459: LD_INT 8
76461: PUSH
76462: LD_INT 9
76464: PUSH
76465: EMPTY
76466: LIST
76467: LIST
76468: LIST
76469: PUSH
76470: LD_VAR 0 17
76474: ARRAY
76475: PPUSH
76476: LD_VAR 0 4
76480: PPUSH
76481: CALL_OW 380
76485: GO 76504
// PrepareHuman ( false , i , skill ) ;
76487: LD_INT 0
76489: PPUSH
76490: LD_VAR 0 8
76494: PPUSH
76495: LD_VAR 0 4
76499: PPUSH
76500: CALL_OW 380
// end else
76504: GO 76523
// PrepareHuman ( false , i , skill ) ;
76506: LD_INT 0
76508: PPUSH
76509: LD_VAR 0 8
76513: PPUSH
76514: LD_VAR 0 4
76518: PPUSH
76519: CALL_OW 380
// un := CreateHuman ;
76523: LD_ADDR_VAR 0 14
76527: PUSH
76528: CALL_OW 44
76532: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76533: LD_ADDR_VAR 0 7
76537: PUSH
76538: LD_VAR 0 7
76542: PPUSH
76543: LD_INT 1
76545: PPUSH
76546: LD_VAR 0 14
76550: PPUSH
76551: CALL_OW 2
76555: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
76556: LD_VAR 0 14
76560: PPUSH
76561: LD_VAR 0 9
76565: PPUSH
76566: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
76570: LD_VAR 0 9
76574: PPUSH
76575: CALL_OW 313
76579: PUSH
76580: LD_INT 6
76582: EQUAL
76583: PUSH
76584: LD_VAR 0 9
76588: PPUSH
76589: CALL_OW 266
76593: PUSH
76594: LD_INT 32
76596: PUSH
76597: LD_INT 31
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: IN
76604: OR
76605: IFFALSE 76419
76607: GO 76416
76609: POP
76610: POP
// end else
76611: GO 76993
// for j = 1 to x do
76613: LD_ADDR_VAR 0 9
76617: PUSH
76618: DOUBLE
76619: LD_INT 1
76621: DEC
76622: ST_TO_ADDR
76623: LD_VAR 0 13
76627: PUSH
76628: FOR_TO
76629: IFFALSE 76991
// begin InitHc ;
76631: CALL_OW 19
// if not f then
76635: LD_VAR 0 12
76639: NOT
76640: IFFALSE 76729
// begin PrepareHuman ( false , i , skill ) ;
76642: LD_INT 0
76644: PPUSH
76645: LD_VAR 0 8
76649: PPUSH
76650: LD_VAR 0 4
76654: PPUSH
76655: CALL_OW 380
// un := CreateHuman ;
76659: LD_ADDR_VAR 0 14
76663: PUSH
76664: CALL_OW 44
76668: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76669: LD_ADDR_VAR 0 7
76673: PUSH
76674: LD_VAR 0 7
76678: PPUSH
76679: LD_INT 1
76681: PPUSH
76682: LD_VAR 0 14
76686: PPUSH
76687: CALL_OW 2
76691: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76692: LD_VAR 0 14
76696: PPUSH
76697: LD_VAR 0 1
76701: PPUSH
76702: CALL_OW 250
76706: PPUSH
76707: LD_VAR 0 1
76711: PPUSH
76712: CALL_OW 251
76716: PPUSH
76717: LD_INT 10
76719: PPUSH
76720: LD_INT 0
76722: PPUSH
76723: CALL_OW 50
// continue ;
76727: GO 76628
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
76729: LD_VAR 0 12
76733: PUSH
76734: LD_INT 1
76736: ARRAY
76737: PPUSH
76738: CALL_OW 313
76742: PUSH
76743: LD_VAR 0 12
76747: PUSH
76748: LD_INT 1
76750: ARRAY
76751: PPUSH
76752: CALL_OW 266
76756: PUSH
76757: LD_INT 32
76759: PUSH
76760: LD_INT 31
76762: PUSH
76763: EMPTY
76764: LIST
76765: LIST
76766: IN
76767: AND
76768: PUSH
76769: LD_VAR 0 12
76773: PUSH
76774: LD_INT 1
76776: ARRAY
76777: PPUSH
76778: CALL_OW 313
76782: PUSH
76783: LD_INT 6
76785: EQUAL
76786: OR
76787: IFFALSE 76807
// f := Delete ( f , 1 ) ;
76789: LD_ADDR_VAR 0 12
76793: PUSH
76794: LD_VAR 0 12
76798: PPUSH
76799: LD_INT 1
76801: PPUSH
76802: CALL_OW 3
76806: ST_TO_ADDR
// if not f then
76807: LD_VAR 0 12
76811: NOT
76812: IFFALSE 76830
// begin x := x + 2 ;
76814: LD_ADDR_VAR 0 13
76818: PUSH
76819: LD_VAR 0 13
76823: PUSH
76824: LD_INT 2
76826: PLUS
76827: ST_TO_ADDR
// continue ;
76828: GO 76628
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
76830: LD_VAR 0 12
76834: PUSH
76835: LD_INT 1
76837: ARRAY
76838: PPUSH
76839: CALL_OW 266
76843: PUSH
76844: LD_INT 5
76846: EQUAL
76847: IFFALSE 76921
// begin if UnitsInside ( f [ 1 ] ) < 3 then
76849: LD_VAR 0 12
76853: PUSH
76854: LD_INT 1
76856: ARRAY
76857: PPUSH
76858: CALL_OW 313
76862: PUSH
76863: LD_INT 3
76865: LESS
76866: IFFALSE 76902
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
76868: LD_INT 0
76870: PPUSH
76871: LD_INT 5
76873: PUSH
76874: LD_INT 8
76876: PUSH
76877: LD_INT 9
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: LIST
76884: PUSH
76885: LD_VAR 0 17
76889: ARRAY
76890: PPUSH
76891: LD_VAR 0 4
76895: PPUSH
76896: CALL_OW 380
76900: GO 76919
// PrepareHuman ( false , i , skill ) ;
76902: LD_INT 0
76904: PPUSH
76905: LD_VAR 0 8
76909: PPUSH
76910: LD_VAR 0 4
76914: PPUSH
76915: CALL_OW 380
// end else
76919: GO 76938
// PrepareHuman ( false , i , skill ) ;
76921: LD_INT 0
76923: PPUSH
76924: LD_VAR 0 8
76928: PPUSH
76929: LD_VAR 0 4
76933: PPUSH
76934: CALL_OW 380
// un := CreateHuman ;
76938: LD_ADDR_VAR 0 14
76942: PUSH
76943: CALL_OW 44
76947: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
76948: LD_ADDR_VAR 0 7
76952: PUSH
76953: LD_VAR 0 7
76957: PPUSH
76958: LD_INT 1
76960: PPUSH
76961: LD_VAR 0 14
76965: PPUSH
76966: CALL_OW 2
76970: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
76971: LD_VAR 0 14
76975: PPUSH
76976: LD_VAR 0 12
76980: PUSH
76981: LD_INT 1
76983: ARRAY
76984: PPUSH
76985: CALL_OW 52
// end ;
76989: GO 76628
76991: POP
76992: POP
// end ;
76993: GO 75930
76995: POP
76996: POP
// result := result ^ buildings ;
76997: LD_ADDR_VAR 0 7
77001: PUSH
77002: LD_VAR 0 7
77006: PUSH
77007: LD_VAR 0 18
77011: ADD
77012: ST_TO_ADDR
// end else
77013: GO 77156
// begin for i = 1 to personel do
77015: LD_ADDR_VAR 0 8
77019: PUSH
77020: DOUBLE
77021: LD_INT 1
77023: DEC
77024: ST_TO_ADDR
77025: LD_VAR 0 6
77029: PUSH
77030: FOR_TO
77031: IFFALSE 77154
// begin if i > 4 then
77033: LD_VAR 0 8
77037: PUSH
77038: LD_INT 4
77040: GREATER
77041: IFFALSE 77045
// break ;
77043: GO 77154
// x := personel [ i ] ;
77045: LD_ADDR_VAR 0 13
77049: PUSH
77050: LD_VAR 0 6
77054: PUSH
77055: LD_VAR 0 8
77059: ARRAY
77060: ST_TO_ADDR
// if x = - 1 then
77061: LD_VAR 0 13
77065: PUSH
77066: LD_INT 1
77068: NEG
77069: EQUAL
77070: IFFALSE 77074
// continue ;
77072: GO 77030
// PrepareHuman ( false , i , skill ) ;
77074: LD_INT 0
77076: PPUSH
77077: LD_VAR 0 8
77081: PPUSH
77082: LD_VAR 0 4
77086: PPUSH
77087: CALL_OW 380
// un := CreateHuman ;
77091: LD_ADDR_VAR 0 14
77095: PUSH
77096: CALL_OW 44
77100: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
77101: LD_VAR 0 14
77105: PPUSH
77106: LD_VAR 0 1
77110: PPUSH
77111: CALL_OW 250
77115: PPUSH
77116: LD_VAR 0 1
77120: PPUSH
77121: CALL_OW 251
77125: PPUSH
77126: LD_INT 10
77128: PPUSH
77129: LD_INT 0
77131: PPUSH
77132: CALL_OW 50
// result := result ^ un ;
77136: LD_ADDR_VAR 0 7
77140: PUSH
77141: LD_VAR 0 7
77145: PUSH
77146: LD_VAR 0 14
77150: ADD
77151: ST_TO_ADDR
// end ;
77152: GO 77030
77154: POP
77155: POP
// end ; end ;
77156: LD_VAR 0 7
77160: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
77161: LD_INT 0
77163: PPUSH
77164: PPUSH
77165: PPUSH
77166: PPUSH
77167: PPUSH
77168: PPUSH
77169: PPUSH
77170: PPUSH
77171: PPUSH
77172: PPUSH
77173: PPUSH
77174: PPUSH
77175: PPUSH
77176: PPUSH
77177: PPUSH
77178: PPUSH
// result := false ;
77179: LD_ADDR_VAR 0 3
77183: PUSH
77184: LD_INT 0
77186: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
77187: LD_VAR 0 1
77191: NOT
77192: PUSH
77193: LD_VAR 0 1
77197: PPUSH
77198: CALL_OW 266
77202: PUSH
77203: LD_INT 32
77205: PUSH
77206: LD_INT 33
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: IN
77213: NOT
77214: OR
77215: IFFALSE 77219
// exit ;
77217: GO 78355
// nat := GetNation ( tower ) ;
77219: LD_ADDR_VAR 0 12
77223: PUSH
77224: LD_VAR 0 1
77228: PPUSH
77229: CALL_OW 248
77233: ST_TO_ADDR
// side := GetSide ( tower ) ;
77234: LD_ADDR_VAR 0 16
77238: PUSH
77239: LD_VAR 0 1
77243: PPUSH
77244: CALL_OW 255
77248: ST_TO_ADDR
// x := GetX ( tower ) ;
77249: LD_ADDR_VAR 0 10
77253: PUSH
77254: LD_VAR 0 1
77258: PPUSH
77259: CALL_OW 250
77263: ST_TO_ADDR
// y := GetY ( tower ) ;
77264: LD_ADDR_VAR 0 11
77268: PUSH
77269: LD_VAR 0 1
77273: PPUSH
77274: CALL_OW 251
77278: ST_TO_ADDR
// if not x or not y then
77279: LD_VAR 0 10
77283: NOT
77284: PUSH
77285: LD_VAR 0 11
77289: NOT
77290: OR
77291: IFFALSE 77295
// exit ;
77293: GO 78355
// weapon := 0 ;
77295: LD_ADDR_VAR 0 18
77299: PUSH
77300: LD_INT 0
77302: ST_TO_ADDR
// fac_list := [ ] ;
77303: LD_ADDR_VAR 0 17
77307: PUSH
77308: EMPTY
77309: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
77310: LD_ADDR_VAR 0 6
77314: PUSH
77315: LD_VAR 0 1
77319: PPUSH
77320: CALL_OW 274
77324: PPUSH
77325: LD_VAR 0 2
77329: PPUSH
77330: CALL 74933 0 2
77334: PPUSH
77335: LD_INT 30
77337: PUSH
77338: LD_INT 3
77340: PUSH
77341: EMPTY
77342: LIST
77343: LIST
77344: PPUSH
77345: CALL_OW 72
77349: ST_TO_ADDR
// if not factories then
77350: LD_VAR 0 6
77354: NOT
77355: IFFALSE 77359
// exit ;
77357: GO 78355
// for i in factories do
77359: LD_ADDR_VAR 0 8
77363: PUSH
77364: LD_VAR 0 6
77368: PUSH
77369: FOR_IN
77370: IFFALSE 77395
// fac_list := fac_list union AvailableWeaponList ( i ) ;
77372: LD_ADDR_VAR 0 17
77376: PUSH
77377: LD_VAR 0 17
77381: PUSH
77382: LD_VAR 0 8
77386: PPUSH
77387: CALL_OW 478
77391: UNION
77392: ST_TO_ADDR
77393: GO 77369
77395: POP
77396: POP
// if not fac_list then
77397: LD_VAR 0 17
77401: NOT
77402: IFFALSE 77406
// exit ;
77404: GO 78355
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
77406: LD_ADDR_VAR 0 5
77410: PUSH
77411: LD_INT 4
77413: PUSH
77414: LD_INT 5
77416: PUSH
77417: LD_INT 9
77419: PUSH
77420: LD_INT 10
77422: PUSH
77423: LD_INT 6
77425: PUSH
77426: LD_INT 7
77428: PUSH
77429: LD_INT 11
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: LIST
77436: LIST
77437: LIST
77438: LIST
77439: LIST
77440: PUSH
77441: LD_INT 27
77443: PUSH
77444: LD_INT 28
77446: PUSH
77447: LD_INT 26
77449: PUSH
77450: LD_INT 30
77452: PUSH
77453: EMPTY
77454: LIST
77455: LIST
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 43
77461: PUSH
77462: LD_INT 44
77464: PUSH
77465: LD_INT 46
77467: PUSH
77468: LD_INT 45
77470: PUSH
77471: LD_INT 47
77473: PUSH
77474: LD_INT 49
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: LIST
77481: LIST
77482: LIST
77483: LIST
77484: PUSH
77485: EMPTY
77486: LIST
77487: LIST
77488: LIST
77489: PUSH
77490: LD_VAR 0 12
77494: ARRAY
77495: ST_TO_ADDR
// for i in list do
77496: LD_ADDR_VAR 0 8
77500: PUSH
77501: LD_VAR 0 5
77505: PUSH
77506: FOR_IN
77507: IFFALSE 77540
// if not i in fac_list then
77509: LD_VAR 0 8
77513: PUSH
77514: LD_VAR 0 17
77518: IN
77519: NOT
77520: IFFALSE 77538
// list := list diff i ;
77522: LD_ADDR_VAR 0 5
77526: PUSH
77527: LD_VAR 0 5
77531: PUSH
77532: LD_VAR 0 8
77536: DIFF
77537: ST_TO_ADDR
77538: GO 77506
77540: POP
77541: POP
// if not list then
77542: LD_VAR 0 5
77546: NOT
77547: IFFALSE 77551
// exit ;
77549: GO 78355
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
77551: LD_VAR 0 12
77555: PUSH
77556: LD_INT 3
77558: EQUAL
77559: PUSH
77560: LD_INT 49
77562: PUSH
77563: LD_VAR 0 5
77567: IN
77568: AND
77569: PUSH
77570: LD_INT 31
77572: PPUSH
77573: LD_VAR 0 16
77577: PPUSH
77578: CALL_OW 321
77582: PUSH
77583: LD_INT 2
77585: EQUAL
77586: AND
77587: IFFALSE 77647
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
77589: LD_INT 22
77591: PUSH
77592: LD_VAR 0 16
77596: PUSH
77597: EMPTY
77598: LIST
77599: LIST
77600: PUSH
77601: LD_INT 35
77603: PUSH
77604: LD_INT 49
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: PUSH
77611: LD_INT 91
77613: PUSH
77614: LD_VAR 0 1
77618: PUSH
77619: LD_INT 10
77621: PUSH
77622: EMPTY
77623: LIST
77624: LIST
77625: LIST
77626: PUSH
77627: EMPTY
77628: LIST
77629: LIST
77630: LIST
77631: PPUSH
77632: CALL_OW 69
77636: NOT
77637: IFFALSE 77647
// weapon := ru_time_lapser ;
77639: LD_ADDR_VAR 0 18
77643: PUSH
77644: LD_INT 49
77646: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
77647: LD_VAR 0 12
77651: PUSH
77652: LD_INT 1
77654: PUSH
77655: LD_INT 2
77657: PUSH
77658: EMPTY
77659: LIST
77660: LIST
77661: IN
77662: PUSH
77663: LD_INT 11
77665: PUSH
77666: LD_VAR 0 5
77670: IN
77671: PUSH
77672: LD_INT 30
77674: PUSH
77675: LD_VAR 0 5
77679: IN
77680: OR
77681: AND
77682: PUSH
77683: LD_INT 6
77685: PPUSH
77686: LD_VAR 0 16
77690: PPUSH
77691: CALL_OW 321
77695: PUSH
77696: LD_INT 2
77698: EQUAL
77699: AND
77700: IFFALSE 77865
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
77702: LD_INT 22
77704: PUSH
77705: LD_VAR 0 16
77709: PUSH
77710: EMPTY
77711: LIST
77712: LIST
77713: PUSH
77714: LD_INT 2
77716: PUSH
77717: LD_INT 35
77719: PUSH
77720: LD_INT 11
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: LD_INT 35
77729: PUSH
77730: LD_INT 30
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: LIST
77741: PUSH
77742: LD_INT 91
77744: PUSH
77745: LD_VAR 0 1
77749: PUSH
77750: LD_INT 18
77752: PUSH
77753: EMPTY
77754: LIST
77755: LIST
77756: LIST
77757: PUSH
77758: EMPTY
77759: LIST
77760: LIST
77761: LIST
77762: PPUSH
77763: CALL_OW 69
77767: NOT
77768: PUSH
77769: LD_INT 22
77771: PUSH
77772: LD_VAR 0 16
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: PUSH
77781: LD_INT 2
77783: PUSH
77784: LD_INT 30
77786: PUSH
77787: LD_INT 32
77789: PUSH
77790: EMPTY
77791: LIST
77792: LIST
77793: PUSH
77794: LD_INT 30
77796: PUSH
77797: LD_INT 33
77799: PUSH
77800: EMPTY
77801: LIST
77802: LIST
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: LIST
77808: PUSH
77809: LD_INT 91
77811: PUSH
77812: LD_VAR 0 1
77816: PUSH
77817: LD_INT 12
77819: PUSH
77820: EMPTY
77821: LIST
77822: LIST
77823: LIST
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: LIST
77829: PUSH
77830: EMPTY
77831: LIST
77832: PPUSH
77833: CALL_OW 69
77837: PUSH
77838: LD_INT 2
77840: GREATER
77841: AND
77842: IFFALSE 77865
// weapon := [ us_radar , ar_radar ] [ nat ] ;
77844: LD_ADDR_VAR 0 18
77848: PUSH
77849: LD_INT 11
77851: PUSH
77852: LD_INT 30
77854: PUSH
77855: EMPTY
77856: LIST
77857: LIST
77858: PUSH
77859: LD_VAR 0 12
77863: ARRAY
77864: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
77865: LD_VAR 0 18
77869: NOT
77870: PUSH
77871: LD_INT 40
77873: PPUSH
77874: LD_VAR 0 16
77878: PPUSH
77879: CALL_OW 321
77883: PUSH
77884: LD_INT 2
77886: EQUAL
77887: AND
77888: PUSH
77889: LD_INT 7
77891: PUSH
77892: LD_VAR 0 5
77896: IN
77897: PUSH
77898: LD_INT 28
77900: PUSH
77901: LD_VAR 0 5
77905: IN
77906: OR
77907: PUSH
77908: LD_INT 45
77910: PUSH
77911: LD_VAR 0 5
77915: IN
77916: OR
77917: AND
77918: IFFALSE 78172
// begin hex := GetHexInfo ( x , y ) ;
77920: LD_ADDR_VAR 0 4
77924: PUSH
77925: LD_VAR 0 10
77929: PPUSH
77930: LD_VAR 0 11
77934: PPUSH
77935: CALL_OW 546
77939: ST_TO_ADDR
// if hex [ 1 ] then
77940: LD_VAR 0 4
77944: PUSH
77945: LD_INT 1
77947: ARRAY
77948: IFFALSE 77952
// exit ;
77950: GO 78355
// height := hex [ 2 ] ;
77952: LD_ADDR_VAR 0 15
77956: PUSH
77957: LD_VAR 0 4
77961: PUSH
77962: LD_INT 2
77964: ARRAY
77965: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
77966: LD_ADDR_VAR 0 14
77970: PUSH
77971: LD_INT 0
77973: PUSH
77974: LD_INT 2
77976: PUSH
77977: LD_INT 3
77979: PUSH
77980: LD_INT 5
77982: PUSH
77983: EMPTY
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: ST_TO_ADDR
// for i in tmp do
77989: LD_ADDR_VAR 0 8
77993: PUSH
77994: LD_VAR 0 14
77998: PUSH
77999: FOR_IN
78000: IFFALSE 78170
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
78002: LD_ADDR_VAR 0 9
78006: PUSH
78007: LD_VAR 0 10
78011: PPUSH
78012: LD_VAR 0 8
78016: PPUSH
78017: LD_INT 5
78019: PPUSH
78020: CALL_OW 272
78024: PUSH
78025: LD_VAR 0 11
78029: PPUSH
78030: LD_VAR 0 8
78034: PPUSH
78035: LD_INT 5
78037: PPUSH
78038: CALL_OW 273
78042: PUSH
78043: EMPTY
78044: LIST
78045: LIST
78046: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
78047: LD_VAR 0 9
78051: PUSH
78052: LD_INT 1
78054: ARRAY
78055: PPUSH
78056: LD_VAR 0 9
78060: PUSH
78061: LD_INT 2
78063: ARRAY
78064: PPUSH
78065: CALL_OW 488
78069: IFFALSE 78168
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
78071: LD_ADDR_VAR 0 4
78075: PUSH
78076: LD_VAR 0 9
78080: PUSH
78081: LD_INT 1
78083: ARRAY
78084: PPUSH
78085: LD_VAR 0 9
78089: PUSH
78090: LD_INT 2
78092: ARRAY
78093: PPUSH
78094: CALL_OW 546
78098: ST_TO_ADDR
// if hex [ 1 ] then
78099: LD_VAR 0 4
78103: PUSH
78104: LD_INT 1
78106: ARRAY
78107: IFFALSE 78111
// continue ;
78109: GO 77999
// h := hex [ 2 ] ;
78111: LD_ADDR_VAR 0 13
78115: PUSH
78116: LD_VAR 0 4
78120: PUSH
78121: LD_INT 2
78123: ARRAY
78124: ST_TO_ADDR
// if h + 7 < height then
78125: LD_VAR 0 13
78129: PUSH
78130: LD_INT 7
78132: PLUS
78133: PUSH
78134: LD_VAR 0 15
78138: LESS
78139: IFFALSE 78168
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
78141: LD_ADDR_VAR 0 18
78145: PUSH
78146: LD_INT 7
78148: PUSH
78149: LD_INT 28
78151: PUSH
78152: LD_INT 45
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: LIST
78159: PUSH
78160: LD_VAR 0 12
78164: ARRAY
78165: ST_TO_ADDR
// break ;
78166: GO 78170
// end ; end ; end ;
78168: GO 77999
78170: POP
78171: POP
// end ; if not weapon then
78172: LD_VAR 0 18
78176: NOT
78177: IFFALSE 78237
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
78179: LD_ADDR_VAR 0 5
78183: PUSH
78184: LD_VAR 0 5
78188: PUSH
78189: LD_INT 11
78191: PUSH
78192: LD_INT 30
78194: PUSH
78195: LD_INT 49
78197: PUSH
78198: EMPTY
78199: LIST
78200: LIST
78201: LIST
78202: DIFF
78203: ST_TO_ADDR
// if not list then
78204: LD_VAR 0 5
78208: NOT
78209: IFFALSE 78213
// exit ;
78211: GO 78355
// weapon := list [ rand ( 1 , list ) ] ;
78213: LD_ADDR_VAR 0 18
78217: PUSH
78218: LD_VAR 0 5
78222: PUSH
78223: LD_INT 1
78225: PPUSH
78226: LD_VAR 0 5
78230: PPUSH
78231: CALL_OW 12
78235: ARRAY
78236: ST_TO_ADDR
// end ; if weapon then
78237: LD_VAR 0 18
78241: IFFALSE 78355
// begin tmp := CostOfWeapon ( weapon ) ;
78243: LD_ADDR_VAR 0 14
78247: PUSH
78248: LD_VAR 0 18
78252: PPUSH
78253: CALL_OW 451
78257: ST_TO_ADDR
// j := GetBase ( tower ) ;
78258: LD_ADDR_VAR 0 9
78262: PUSH
78263: LD_VAR 0 1
78267: PPUSH
78268: CALL_OW 274
78272: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
78273: LD_VAR 0 9
78277: PPUSH
78278: LD_INT 1
78280: PPUSH
78281: CALL_OW 275
78285: PUSH
78286: LD_VAR 0 14
78290: PUSH
78291: LD_INT 1
78293: ARRAY
78294: GREATEREQUAL
78295: PUSH
78296: LD_VAR 0 9
78300: PPUSH
78301: LD_INT 2
78303: PPUSH
78304: CALL_OW 275
78308: PUSH
78309: LD_VAR 0 14
78313: PUSH
78314: LD_INT 2
78316: ARRAY
78317: GREATEREQUAL
78318: AND
78319: PUSH
78320: LD_VAR 0 9
78324: PPUSH
78325: LD_INT 3
78327: PPUSH
78328: CALL_OW 275
78332: PUSH
78333: LD_VAR 0 14
78337: PUSH
78338: LD_INT 3
78340: ARRAY
78341: GREATEREQUAL
78342: AND
78343: IFFALSE 78355
// result := weapon ;
78345: LD_ADDR_VAR 0 3
78349: PUSH
78350: LD_VAR 0 18
78354: ST_TO_ADDR
// end ; end ;
78355: LD_VAR 0 3
78359: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
78360: LD_INT 0
78362: PPUSH
78363: PPUSH
// result := true ;
78364: LD_ADDR_VAR 0 3
78368: PUSH
78369: LD_INT 1
78371: ST_TO_ADDR
// if array1 = array2 then
78372: LD_VAR 0 1
78376: PUSH
78377: LD_VAR 0 2
78381: EQUAL
78382: IFFALSE 78442
// begin for i = 1 to array1 do
78384: LD_ADDR_VAR 0 4
78388: PUSH
78389: DOUBLE
78390: LD_INT 1
78392: DEC
78393: ST_TO_ADDR
78394: LD_VAR 0 1
78398: PUSH
78399: FOR_TO
78400: IFFALSE 78438
// if array1 [ i ] <> array2 [ i ] then
78402: LD_VAR 0 1
78406: PUSH
78407: LD_VAR 0 4
78411: ARRAY
78412: PUSH
78413: LD_VAR 0 2
78417: PUSH
78418: LD_VAR 0 4
78422: ARRAY
78423: NONEQUAL
78424: IFFALSE 78436
// begin result := false ;
78426: LD_ADDR_VAR 0 3
78430: PUSH
78431: LD_INT 0
78433: ST_TO_ADDR
// break ;
78434: GO 78438
// end ;
78436: GO 78399
78438: POP
78439: POP
// end else
78440: GO 78450
// result := false ;
78442: LD_ADDR_VAR 0 3
78446: PUSH
78447: LD_INT 0
78449: ST_TO_ADDR
// end ;
78450: LD_VAR 0 3
78454: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
78455: LD_INT 0
78457: PPUSH
78458: PPUSH
78459: PPUSH
// pom := GetBase ( fac ) ;
78460: LD_ADDR_VAR 0 5
78464: PUSH
78465: LD_VAR 0 1
78469: PPUSH
78470: CALL_OW 274
78474: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
78475: LD_ADDR_VAR 0 4
78479: PUSH
78480: LD_VAR 0 2
78484: PUSH
78485: LD_INT 1
78487: ARRAY
78488: PPUSH
78489: LD_VAR 0 2
78493: PUSH
78494: LD_INT 2
78496: ARRAY
78497: PPUSH
78498: LD_VAR 0 2
78502: PUSH
78503: LD_INT 3
78505: ARRAY
78506: PPUSH
78507: LD_VAR 0 2
78511: PUSH
78512: LD_INT 4
78514: ARRAY
78515: PPUSH
78516: CALL_OW 449
78520: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78521: LD_ADDR_VAR 0 3
78525: PUSH
78526: LD_VAR 0 5
78530: PPUSH
78531: LD_INT 1
78533: PPUSH
78534: CALL_OW 275
78538: PUSH
78539: LD_VAR 0 4
78543: PUSH
78544: LD_INT 1
78546: ARRAY
78547: GREATEREQUAL
78548: PUSH
78549: LD_VAR 0 5
78553: PPUSH
78554: LD_INT 2
78556: PPUSH
78557: CALL_OW 275
78561: PUSH
78562: LD_VAR 0 4
78566: PUSH
78567: LD_INT 2
78569: ARRAY
78570: GREATEREQUAL
78571: AND
78572: PUSH
78573: LD_VAR 0 5
78577: PPUSH
78578: LD_INT 3
78580: PPUSH
78581: CALL_OW 275
78585: PUSH
78586: LD_VAR 0 4
78590: PUSH
78591: LD_INT 3
78593: ARRAY
78594: GREATEREQUAL
78595: AND
78596: ST_TO_ADDR
// end ;
78597: LD_VAR 0 3
78601: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
78602: LD_INT 0
78604: PPUSH
78605: PPUSH
78606: PPUSH
78607: PPUSH
// pom := GetBase ( building ) ;
78608: LD_ADDR_VAR 0 3
78612: PUSH
78613: LD_VAR 0 1
78617: PPUSH
78618: CALL_OW 274
78622: ST_TO_ADDR
// if not pom then
78623: LD_VAR 0 3
78627: NOT
78628: IFFALSE 78632
// exit ;
78630: GO 78802
// btype := GetBType ( building ) ;
78632: LD_ADDR_VAR 0 5
78636: PUSH
78637: LD_VAR 0 1
78641: PPUSH
78642: CALL_OW 266
78646: ST_TO_ADDR
// if btype = b_armoury then
78647: LD_VAR 0 5
78651: PUSH
78652: LD_INT 4
78654: EQUAL
78655: IFFALSE 78665
// btype := b_barracks ;
78657: LD_ADDR_VAR 0 5
78661: PUSH
78662: LD_INT 5
78664: ST_TO_ADDR
// if btype = b_depot then
78665: LD_VAR 0 5
78669: PUSH
78670: LD_INT 0
78672: EQUAL
78673: IFFALSE 78683
// btype := b_warehouse ;
78675: LD_ADDR_VAR 0 5
78679: PUSH
78680: LD_INT 1
78682: ST_TO_ADDR
// if btype = b_workshop then
78683: LD_VAR 0 5
78687: PUSH
78688: LD_INT 2
78690: EQUAL
78691: IFFALSE 78701
// btype := b_factory ;
78693: LD_ADDR_VAR 0 5
78697: PUSH
78698: LD_INT 3
78700: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78701: LD_ADDR_VAR 0 4
78705: PUSH
78706: LD_VAR 0 5
78710: PPUSH
78711: LD_VAR 0 1
78715: PPUSH
78716: CALL_OW 248
78720: PPUSH
78721: CALL_OW 450
78725: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78726: LD_ADDR_VAR 0 2
78730: PUSH
78731: LD_VAR 0 3
78735: PPUSH
78736: LD_INT 1
78738: PPUSH
78739: CALL_OW 275
78743: PUSH
78744: LD_VAR 0 4
78748: PUSH
78749: LD_INT 1
78751: ARRAY
78752: GREATEREQUAL
78753: PUSH
78754: LD_VAR 0 3
78758: PPUSH
78759: LD_INT 2
78761: PPUSH
78762: CALL_OW 275
78766: PUSH
78767: LD_VAR 0 4
78771: PUSH
78772: LD_INT 2
78774: ARRAY
78775: GREATEREQUAL
78776: AND
78777: PUSH
78778: LD_VAR 0 3
78782: PPUSH
78783: LD_INT 3
78785: PPUSH
78786: CALL_OW 275
78790: PUSH
78791: LD_VAR 0 4
78795: PUSH
78796: LD_INT 3
78798: ARRAY
78799: GREATEREQUAL
78800: AND
78801: ST_TO_ADDR
// end ;
78802: LD_VAR 0 2
78806: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
78807: LD_INT 0
78809: PPUSH
78810: PPUSH
78811: PPUSH
// pom := GetBase ( building ) ;
78812: LD_ADDR_VAR 0 4
78816: PUSH
78817: LD_VAR 0 1
78821: PPUSH
78822: CALL_OW 274
78826: ST_TO_ADDR
// if not pom then
78827: LD_VAR 0 4
78831: NOT
78832: IFFALSE 78836
// exit ;
78834: GO 78937
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
78836: LD_ADDR_VAR 0 5
78840: PUSH
78841: LD_VAR 0 2
78845: PPUSH
78846: LD_VAR 0 1
78850: PPUSH
78851: CALL_OW 248
78855: PPUSH
78856: CALL_OW 450
78860: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
78861: LD_ADDR_VAR 0 3
78865: PUSH
78866: LD_VAR 0 4
78870: PPUSH
78871: LD_INT 1
78873: PPUSH
78874: CALL_OW 275
78878: PUSH
78879: LD_VAR 0 5
78883: PUSH
78884: LD_INT 1
78886: ARRAY
78887: GREATEREQUAL
78888: PUSH
78889: LD_VAR 0 4
78893: PPUSH
78894: LD_INT 2
78896: PPUSH
78897: CALL_OW 275
78901: PUSH
78902: LD_VAR 0 5
78906: PUSH
78907: LD_INT 2
78909: ARRAY
78910: GREATEREQUAL
78911: AND
78912: PUSH
78913: LD_VAR 0 4
78917: PPUSH
78918: LD_INT 3
78920: PPUSH
78921: CALL_OW 275
78925: PUSH
78926: LD_VAR 0 5
78930: PUSH
78931: LD_INT 3
78933: ARRAY
78934: GREATEREQUAL
78935: AND
78936: ST_TO_ADDR
// end ;
78937: LD_VAR 0 3
78941: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
78942: LD_INT 0
78944: PPUSH
78945: PPUSH
78946: PPUSH
78947: PPUSH
78948: PPUSH
78949: PPUSH
78950: PPUSH
78951: PPUSH
78952: PPUSH
78953: PPUSH
// result := false ;
78954: LD_ADDR_VAR 0 6
78958: PUSH
78959: LD_INT 0
78961: ST_TO_ADDR
// if not base or not btype or not x or not y then
78962: LD_VAR 0 1
78966: NOT
78967: PUSH
78968: LD_VAR 0 2
78972: NOT
78973: OR
78974: PUSH
78975: LD_VAR 0 3
78979: NOT
78980: OR
78981: PUSH
78982: LD_VAR 0 4
78986: NOT
78987: OR
78988: IFFALSE 78992
// exit ;
78990: GO 79601
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78992: LD_ADDR_VAR 0 12
78996: PUSH
78997: LD_VAR 0 2
79001: PPUSH
79002: LD_VAR 0 3
79006: PPUSH
79007: LD_VAR 0 4
79011: PPUSH
79012: LD_VAR 0 5
79016: PPUSH
79017: LD_VAR 0 1
79021: PUSH
79022: LD_INT 1
79024: ARRAY
79025: PPUSH
79026: CALL_OW 248
79030: PPUSH
79031: LD_INT 0
79033: PPUSH
79034: CALL 80438 0 6
79038: ST_TO_ADDR
// if not hexes then
79039: LD_VAR 0 12
79043: NOT
79044: IFFALSE 79048
// exit ;
79046: GO 79601
// for i = 1 to hexes do
79048: LD_ADDR_VAR 0 7
79052: PUSH
79053: DOUBLE
79054: LD_INT 1
79056: DEC
79057: ST_TO_ADDR
79058: LD_VAR 0 12
79062: PUSH
79063: FOR_TO
79064: IFFALSE 79599
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79066: LD_ADDR_VAR 0 11
79070: PUSH
79071: LD_VAR 0 12
79075: PUSH
79076: LD_VAR 0 7
79080: ARRAY
79081: PUSH
79082: LD_INT 1
79084: ARRAY
79085: PPUSH
79086: LD_VAR 0 12
79090: PUSH
79091: LD_VAR 0 7
79095: ARRAY
79096: PUSH
79097: LD_INT 2
79099: ARRAY
79100: PPUSH
79101: CALL_OW 428
79105: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
79106: LD_VAR 0 12
79110: PUSH
79111: LD_VAR 0 7
79115: ARRAY
79116: PUSH
79117: LD_INT 1
79119: ARRAY
79120: PPUSH
79121: LD_VAR 0 12
79125: PUSH
79126: LD_VAR 0 7
79130: ARRAY
79131: PUSH
79132: LD_INT 2
79134: ARRAY
79135: PPUSH
79136: CALL_OW 351
79140: PUSH
79141: LD_VAR 0 12
79145: PUSH
79146: LD_VAR 0 7
79150: ARRAY
79151: PUSH
79152: LD_INT 1
79154: ARRAY
79155: PPUSH
79156: LD_VAR 0 12
79160: PUSH
79161: LD_VAR 0 7
79165: ARRAY
79166: PUSH
79167: LD_INT 2
79169: ARRAY
79170: PPUSH
79171: CALL_OW 488
79175: NOT
79176: OR
79177: PUSH
79178: LD_VAR 0 11
79182: PPUSH
79183: CALL_OW 247
79187: PUSH
79188: LD_INT 3
79190: EQUAL
79191: OR
79192: IFFALSE 79198
// exit ;
79194: POP
79195: POP
79196: GO 79601
// if not tmp or not tmp in base then
79198: LD_VAR 0 11
79202: NOT
79203: PUSH
79204: LD_VAR 0 11
79208: PUSH
79209: LD_VAR 0 1
79213: IN
79214: NOT
79215: OR
79216: IFFALSE 79220
// continue ;
79218: GO 79063
// result := true ;
79220: LD_ADDR_VAR 0 6
79224: PUSH
79225: LD_INT 1
79227: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
79228: LD_ADDR_VAR 0 15
79232: PUSH
79233: LD_VAR 0 1
79237: PPUSH
79238: LD_INT 22
79240: PUSH
79241: LD_VAR 0 11
79245: PPUSH
79246: CALL_OW 255
79250: PUSH
79251: EMPTY
79252: LIST
79253: LIST
79254: PUSH
79255: LD_INT 2
79257: PUSH
79258: LD_INT 30
79260: PUSH
79261: LD_INT 0
79263: PUSH
79264: EMPTY
79265: LIST
79266: LIST
79267: PUSH
79268: LD_INT 30
79270: PUSH
79271: LD_INT 1
79273: PUSH
79274: EMPTY
79275: LIST
79276: LIST
79277: PUSH
79278: EMPTY
79279: LIST
79280: LIST
79281: LIST
79282: PUSH
79283: EMPTY
79284: LIST
79285: LIST
79286: PPUSH
79287: CALL_OW 72
79291: ST_TO_ADDR
// if dep then
79292: LD_VAR 0 15
79296: IFFALSE 79432
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
79298: LD_ADDR_VAR 0 14
79302: PUSH
79303: LD_VAR 0 15
79307: PUSH
79308: LD_INT 1
79310: ARRAY
79311: PPUSH
79312: CALL_OW 250
79316: PPUSH
79317: LD_VAR 0 15
79321: PUSH
79322: LD_INT 1
79324: ARRAY
79325: PPUSH
79326: CALL_OW 254
79330: PPUSH
79331: LD_INT 5
79333: PPUSH
79334: CALL_OW 272
79338: PUSH
79339: LD_VAR 0 15
79343: PUSH
79344: LD_INT 1
79346: ARRAY
79347: PPUSH
79348: CALL_OW 251
79352: PPUSH
79353: LD_VAR 0 15
79357: PUSH
79358: LD_INT 1
79360: ARRAY
79361: PPUSH
79362: CALL_OW 254
79366: PPUSH
79367: LD_INT 5
79369: PPUSH
79370: CALL_OW 273
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
79379: LD_VAR 0 14
79383: PUSH
79384: LD_INT 1
79386: ARRAY
79387: PPUSH
79388: LD_VAR 0 14
79392: PUSH
79393: LD_INT 2
79395: ARRAY
79396: PPUSH
79397: CALL_OW 488
79401: IFFALSE 79432
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
79403: LD_VAR 0 11
79407: PPUSH
79408: LD_VAR 0 14
79412: PUSH
79413: LD_INT 1
79415: ARRAY
79416: PPUSH
79417: LD_VAR 0 14
79421: PUSH
79422: LD_INT 2
79424: ARRAY
79425: PPUSH
79426: CALL_OW 111
// continue ;
79430: GO 79063
// end ; end ; r := GetDir ( tmp ) ;
79432: LD_ADDR_VAR 0 13
79436: PUSH
79437: LD_VAR 0 11
79441: PPUSH
79442: CALL_OW 254
79446: ST_TO_ADDR
// if r = 5 then
79447: LD_VAR 0 13
79451: PUSH
79452: LD_INT 5
79454: EQUAL
79455: IFFALSE 79465
// r := 0 ;
79457: LD_ADDR_VAR 0 13
79461: PUSH
79462: LD_INT 0
79464: ST_TO_ADDR
// for j = r to 5 do
79465: LD_ADDR_VAR 0 8
79469: PUSH
79470: DOUBLE
79471: LD_VAR 0 13
79475: DEC
79476: ST_TO_ADDR
79477: LD_INT 5
79479: PUSH
79480: FOR_TO
79481: IFFALSE 79595
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
79483: LD_ADDR_VAR 0 9
79487: PUSH
79488: LD_VAR 0 11
79492: PPUSH
79493: CALL_OW 250
79497: PPUSH
79498: LD_VAR 0 8
79502: PPUSH
79503: LD_INT 2
79505: PPUSH
79506: CALL_OW 272
79510: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
79511: LD_ADDR_VAR 0 10
79515: PUSH
79516: LD_VAR 0 11
79520: PPUSH
79521: CALL_OW 251
79525: PPUSH
79526: LD_VAR 0 8
79530: PPUSH
79531: LD_INT 2
79533: PPUSH
79534: CALL_OW 273
79538: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
79539: LD_VAR 0 9
79543: PPUSH
79544: LD_VAR 0 10
79548: PPUSH
79549: CALL_OW 488
79553: PUSH
79554: LD_VAR 0 9
79558: PPUSH
79559: LD_VAR 0 10
79563: PPUSH
79564: CALL_OW 428
79568: NOT
79569: AND
79570: IFFALSE 79593
// begin ComMoveXY ( tmp , _x , _y ) ;
79572: LD_VAR 0 11
79576: PPUSH
79577: LD_VAR 0 9
79581: PPUSH
79582: LD_VAR 0 10
79586: PPUSH
79587: CALL_OW 111
// break ;
79591: GO 79595
// end ; end ;
79593: GO 79480
79595: POP
79596: POP
// end ;
79597: GO 79063
79599: POP
79600: POP
// end ;
79601: LD_VAR 0 6
79605: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
79606: LD_INT 0
79608: PPUSH
79609: PPUSH
79610: PPUSH
79611: PPUSH
79612: PPUSH
79613: PPUSH
79614: PPUSH
79615: PPUSH
79616: PPUSH
79617: PPUSH
// result := false ;
79618: LD_ADDR_VAR 0 6
79622: PUSH
79623: LD_INT 0
79625: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
79626: LD_VAR 0 1
79630: NOT
79631: PUSH
79632: LD_VAR 0 1
79636: PPUSH
79637: CALL_OW 266
79641: PUSH
79642: LD_INT 0
79644: PUSH
79645: LD_INT 1
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: IN
79652: NOT
79653: OR
79654: PUSH
79655: LD_VAR 0 2
79659: NOT
79660: OR
79661: PUSH
79662: LD_VAR 0 5
79666: PUSH
79667: LD_INT 0
79669: PUSH
79670: LD_INT 1
79672: PUSH
79673: LD_INT 2
79675: PUSH
79676: LD_INT 3
79678: PUSH
79679: LD_INT 4
79681: PUSH
79682: LD_INT 5
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: LIST
79689: LIST
79690: LIST
79691: LIST
79692: IN
79693: NOT
79694: OR
79695: PUSH
79696: LD_VAR 0 3
79700: PPUSH
79701: LD_VAR 0 4
79705: PPUSH
79706: CALL_OW 488
79710: NOT
79711: OR
79712: IFFALSE 79716
// exit ;
79714: GO 80433
// pom := GetBase ( depot ) ;
79716: LD_ADDR_VAR 0 10
79720: PUSH
79721: LD_VAR 0 1
79725: PPUSH
79726: CALL_OW 274
79730: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79731: LD_ADDR_VAR 0 11
79735: PUSH
79736: LD_VAR 0 2
79740: PPUSH
79741: LD_VAR 0 1
79745: PPUSH
79746: CALL_OW 248
79750: PPUSH
79751: CALL_OW 450
79755: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79756: LD_VAR 0 10
79760: PPUSH
79761: LD_INT 1
79763: PPUSH
79764: CALL_OW 275
79768: PUSH
79769: LD_VAR 0 11
79773: PUSH
79774: LD_INT 1
79776: ARRAY
79777: GREATEREQUAL
79778: PUSH
79779: LD_VAR 0 10
79783: PPUSH
79784: LD_INT 2
79786: PPUSH
79787: CALL_OW 275
79791: PUSH
79792: LD_VAR 0 11
79796: PUSH
79797: LD_INT 2
79799: ARRAY
79800: GREATEREQUAL
79801: AND
79802: PUSH
79803: LD_VAR 0 10
79807: PPUSH
79808: LD_INT 3
79810: PPUSH
79811: CALL_OW 275
79815: PUSH
79816: LD_VAR 0 11
79820: PUSH
79821: LD_INT 3
79823: ARRAY
79824: GREATEREQUAL
79825: AND
79826: NOT
79827: IFFALSE 79831
// exit ;
79829: GO 80433
// if GetBType ( depot ) = b_depot then
79831: LD_VAR 0 1
79835: PPUSH
79836: CALL_OW 266
79840: PUSH
79841: LD_INT 0
79843: EQUAL
79844: IFFALSE 79856
// dist := 28 else
79846: LD_ADDR_VAR 0 14
79850: PUSH
79851: LD_INT 28
79853: ST_TO_ADDR
79854: GO 79864
// dist := 36 ;
79856: LD_ADDR_VAR 0 14
79860: PUSH
79861: LD_INT 36
79863: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79864: LD_VAR 0 1
79868: PPUSH
79869: LD_VAR 0 3
79873: PPUSH
79874: LD_VAR 0 4
79878: PPUSH
79879: CALL_OW 297
79883: PUSH
79884: LD_VAR 0 14
79888: GREATER
79889: IFFALSE 79893
// exit ;
79891: GO 80433
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79893: LD_ADDR_VAR 0 12
79897: PUSH
79898: LD_VAR 0 2
79902: PPUSH
79903: LD_VAR 0 3
79907: PPUSH
79908: LD_VAR 0 4
79912: PPUSH
79913: LD_VAR 0 5
79917: PPUSH
79918: LD_VAR 0 1
79922: PPUSH
79923: CALL_OW 248
79927: PPUSH
79928: LD_INT 0
79930: PPUSH
79931: CALL 80438 0 6
79935: ST_TO_ADDR
// if not hexes then
79936: LD_VAR 0 12
79940: NOT
79941: IFFALSE 79945
// exit ;
79943: GO 80433
// hex := GetHexInfo ( x , y ) ;
79945: LD_ADDR_VAR 0 15
79949: PUSH
79950: LD_VAR 0 3
79954: PPUSH
79955: LD_VAR 0 4
79959: PPUSH
79960: CALL_OW 546
79964: ST_TO_ADDR
// if hex [ 1 ] then
79965: LD_VAR 0 15
79969: PUSH
79970: LD_INT 1
79972: ARRAY
79973: IFFALSE 79977
// exit ;
79975: GO 80433
// height := hex [ 2 ] ;
79977: LD_ADDR_VAR 0 13
79981: PUSH
79982: LD_VAR 0 15
79986: PUSH
79987: LD_INT 2
79989: ARRAY
79990: ST_TO_ADDR
// for i = 1 to hexes do
79991: LD_ADDR_VAR 0 7
79995: PUSH
79996: DOUBLE
79997: LD_INT 1
79999: DEC
80000: ST_TO_ADDR
80001: LD_VAR 0 12
80005: PUSH
80006: FOR_TO
80007: IFFALSE 80337
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
80009: LD_VAR 0 12
80013: PUSH
80014: LD_VAR 0 7
80018: ARRAY
80019: PUSH
80020: LD_INT 1
80022: ARRAY
80023: PPUSH
80024: LD_VAR 0 12
80028: PUSH
80029: LD_VAR 0 7
80033: ARRAY
80034: PUSH
80035: LD_INT 2
80037: ARRAY
80038: PPUSH
80039: CALL_OW 488
80043: NOT
80044: PUSH
80045: LD_VAR 0 12
80049: PUSH
80050: LD_VAR 0 7
80054: ARRAY
80055: PUSH
80056: LD_INT 1
80058: ARRAY
80059: PPUSH
80060: LD_VAR 0 12
80064: PUSH
80065: LD_VAR 0 7
80069: ARRAY
80070: PUSH
80071: LD_INT 2
80073: ARRAY
80074: PPUSH
80075: CALL_OW 428
80079: PUSH
80080: LD_INT 0
80082: GREATER
80083: OR
80084: PUSH
80085: LD_VAR 0 12
80089: PUSH
80090: LD_VAR 0 7
80094: ARRAY
80095: PUSH
80096: LD_INT 1
80098: ARRAY
80099: PPUSH
80100: LD_VAR 0 12
80104: PUSH
80105: LD_VAR 0 7
80109: ARRAY
80110: PUSH
80111: LD_INT 2
80113: ARRAY
80114: PPUSH
80115: CALL_OW 351
80119: OR
80120: IFFALSE 80126
// exit ;
80122: POP
80123: POP
80124: GO 80433
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80126: LD_ADDR_VAR 0 8
80130: PUSH
80131: LD_VAR 0 12
80135: PUSH
80136: LD_VAR 0 7
80140: ARRAY
80141: PUSH
80142: LD_INT 1
80144: ARRAY
80145: PPUSH
80146: LD_VAR 0 12
80150: PUSH
80151: LD_VAR 0 7
80155: ARRAY
80156: PUSH
80157: LD_INT 2
80159: ARRAY
80160: PPUSH
80161: CALL_OW 546
80165: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
80166: LD_VAR 0 8
80170: PUSH
80171: LD_INT 1
80173: ARRAY
80174: PUSH
80175: LD_VAR 0 8
80179: PUSH
80180: LD_INT 2
80182: ARRAY
80183: PUSH
80184: LD_VAR 0 13
80188: PUSH
80189: LD_INT 2
80191: PLUS
80192: GREATER
80193: OR
80194: PUSH
80195: LD_VAR 0 8
80199: PUSH
80200: LD_INT 2
80202: ARRAY
80203: PUSH
80204: LD_VAR 0 13
80208: PUSH
80209: LD_INT 2
80211: MINUS
80212: LESS
80213: OR
80214: PUSH
80215: LD_VAR 0 8
80219: PUSH
80220: LD_INT 3
80222: ARRAY
80223: PUSH
80224: LD_INT 0
80226: PUSH
80227: LD_INT 8
80229: PUSH
80230: LD_INT 9
80232: PUSH
80233: LD_INT 10
80235: PUSH
80236: LD_INT 11
80238: PUSH
80239: LD_INT 12
80241: PUSH
80242: LD_INT 13
80244: PUSH
80245: LD_INT 16
80247: PUSH
80248: LD_INT 17
80250: PUSH
80251: LD_INT 18
80253: PUSH
80254: LD_INT 19
80256: PUSH
80257: LD_INT 20
80259: PUSH
80260: LD_INT 21
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: LIST
80267: LIST
80268: LIST
80269: LIST
80270: LIST
80271: LIST
80272: LIST
80273: LIST
80274: LIST
80275: LIST
80276: LIST
80277: IN
80278: NOT
80279: OR
80280: PUSH
80281: LD_VAR 0 8
80285: PUSH
80286: LD_INT 5
80288: ARRAY
80289: NOT
80290: OR
80291: PUSH
80292: LD_VAR 0 8
80296: PUSH
80297: LD_INT 6
80299: ARRAY
80300: PUSH
80301: LD_INT 1
80303: PUSH
80304: LD_INT 2
80306: PUSH
80307: LD_INT 7
80309: PUSH
80310: LD_INT 9
80312: PUSH
80313: LD_INT 10
80315: PUSH
80316: LD_INT 11
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: LIST
80323: LIST
80324: LIST
80325: LIST
80326: IN
80327: NOT
80328: OR
80329: IFFALSE 80335
// exit ;
80331: POP
80332: POP
80333: GO 80433
// end ;
80335: GO 80006
80337: POP
80338: POP
// side := GetSide ( depot ) ;
80339: LD_ADDR_VAR 0 9
80343: PUSH
80344: LD_VAR 0 1
80348: PPUSH
80349: CALL_OW 255
80353: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
80354: LD_VAR 0 9
80358: PPUSH
80359: LD_VAR 0 3
80363: PPUSH
80364: LD_VAR 0 4
80368: PPUSH
80369: LD_INT 20
80371: PPUSH
80372: CALL 73087 0 4
80376: PUSH
80377: LD_INT 4
80379: ARRAY
80380: IFFALSE 80384
// exit ;
80382: GO 80433
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
80384: LD_VAR 0 2
80388: PUSH
80389: LD_INT 29
80391: PUSH
80392: LD_INT 30
80394: PUSH
80395: EMPTY
80396: LIST
80397: LIST
80398: IN
80399: PUSH
80400: LD_VAR 0 3
80404: PPUSH
80405: LD_VAR 0 4
80409: PPUSH
80410: LD_VAR 0 9
80414: PPUSH
80415: CALL_OW 440
80419: NOT
80420: AND
80421: IFFALSE 80425
// exit ;
80423: GO 80433
// result := true ;
80425: LD_ADDR_VAR 0 6
80429: PUSH
80430: LD_INT 1
80432: ST_TO_ADDR
// end ;
80433: LD_VAR 0 6
80437: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
80438: LD_INT 0
80440: PPUSH
80441: PPUSH
80442: PPUSH
80443: PPUSH
80444: PPUSH
80445: PPUSH
80446: PPUSH
80447: PPUSH
80448: PPUSH
80449: PPUSH
80450: PPUSH
80451: PPUSH
80452: PPUSH
80453: PPUSH
80454: PPUSH
80455: PPUSH
80456: PPUSH
80457: PPUSH
80458: PPUSH
80459: PPUSH
80460: PPUSH
80461: PPUSH
80462: PPUSH
80463: PPUSH
80464: PPUSH
80465: PPUSH
80466: PPUSH
80467: PPUSH
80468: PPUSH
80469: PPUSH
80470: PPUSH
80471: PPUSH
80472: PPUSH
80473: PPUSH
80474: PPUSH
80475: PPUSH
80476: PPUSH
80477: PPUSH
80478: PPUSH
80479: PPUSH
80480: PPUSH
80481: PPUSH
80482: PPUSH
80483: PPUSH
80484: PPUSH
80485: PPUSH
80486: PPUSH
80487: PPUSH
80488: PPUSH
80489: PPUSH
80490: PPUSH
80491: PPUSH
80492: PPUSH
80493: PPUSH
80494: PPUSH
80495: PPUSH
80496: PPUSH
80497: PPUSH
// result = [ ] ;
80498: LD_ADDR_VAR 0 7
80502: PUSH
80503: EMPTY
80504: ST_TO_ADDR
// temp_list = [ ] ;
80505: LD_ADDR_VAR 0 9
80509: PUSH
80510: EMPTY
80511: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
80512: LD_VAR 0 4
80516: PUSH
80517: LD_INT 0
80519: PUSH
80520: LD_INT 1
80522: PUSH
80523: LD_INT 2
80525: PUSH
80526: LD_INT 3
80528: PUSH
80529: LD_INT 4
80531: PUSH
80532: LD_INT 5
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: IN
80543: NOT
80544: PUSH
80545: LD_VAR 0 1
80549: PUSH
80550: LD_INT 0
80552: PUSH
80553: LD_INT 1
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: IN
80560: PUSH
80561: LD_VAR 0 5
80565: PUSH
80566: LD_INT 1
80568: PUSH
80569: LD_INT 2
80571: PUSH
80572: LD_INT 3
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: LIST
80579: IN
80580: NOT
80581: AND
80582: OR
80583: IFFALSE 80587
// exit ;
80585: GO 98978
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
80587: LD_VAR 0 1
80591: PUSH
80592: LD_INT 6
80594: PUSH
80595: LD_INT 7
80597: PUSH
80598: LD_INT 8
80600: PUSH
80601: LD_INT 13
80603: PUSH
80604: LD_INT 12
80606: PUSH
80607: LD_INT 15
80609: PUSH
80610: LD_INT 11
80612: PUSH
80613: LD_INT 14
80615: PUSH
80616: LD_INT 10
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: IN
80630: IFFALSE 80640
// btype = b_lab ;
80632: LD_ADDR_VAR 0 1
80636: PUSH
80637: LD_INT 6
80639: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80640: LD_VAR 0 6
80644: PUSH
80645: LD_INT 0
80647: PUSH
80648: LD_INT 1
80650: PUSH
80651: LD_INT 2
80653: PUSH
80654: EMPTY
80655: LIST
80656: LIST
80657: LIST
80658: IN
80659: NOT
80660: PUSH
80661: LD_VAR 0 1
80665: PUSH
80666: LD_INT 0
80668: PUSH
80669: LD_INT 1
80671: PUSH
80672: LD_INT 2
80674: PUSH
80675: LD_INT 3
80677: PUSH
80678: LD_INT 6
80680: PUSH
80681: LD_INT 36
80683: PUSH
80684: LD_INT 4
80686: PUSH
80687: LD_INT 5
80689: PUSH
80690: LD_INT 31
80692: PUSH
80693: LD_INT 32
80695: PUSH
80696: LD_INT 33
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: LIST
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: IN
80712: NOT
80713: PUSH
80714: LD_VAR 0 6
80718: PUSH
80719: LD_INT 1
80721: EQUAL
80722: AND
80723: OR
80724: PUSH
80725: LD_VAR 0 1
80729: PUSH
80730: LD_INT 2
80732: PUSH
80733: LD_INT 3
80735: PUSH
80736: EMPTY
80737: LIST
80738: LIST
80739: IN
80740: NOT
80741: PUSH
80742: LD_VAR 0 6
80746: PUSH
80747: LD_INT 2
80749: EQUAL
80750: AND
80751: OR
80752: IFFALSE 80762
// mode = 0 ;
80754: LD_ADDR_VAR 0 6
80758: PUSH
80759: LD_INT 0
80761: ST_TO_ADDR
// case mode of 0 :
80762: LD_VAR 0 6
80766: PUSH
80767: LD_INT 0
80769: DOUBLE
80770: EQUAL
80771: IFTRUE 80775
80773: GO 92228
80775: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80776: LD_ADDR_VAR 0 11
80780: PUSH
80781: LD_INT 0
80783: PUSH
80784: LD_INT 0
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: PUSH
80791: LD_INT 0
80793: PUSH
80794: LD_INT 1
80796: NEG
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PUSH
80802: LD_INT 1
80804: PUSH
80805: LD_INT 0
80807: PUSH
80808: EMPTY
80809: LIST
80810: LIST
80811: PUSH
80812: LD_INT 1
80814: PUSH
80815: LD_INT 1
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: PUSH
80822: LD_INT 0
80824: PUSH
80825: LD_INT 1
80827: PUSH
80828: EMPTY
80829: LIST
80830: LIST
80831: PUSH
80832: LD_INT 1
80834: NEG
80835: PUSH
80836: LD_INT 0
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 1
80845: NEG
80846: PUSH
80847: LD_INT 1
80849: NEG
80850: PUSH
80851: EMPTY
80852: LIST
80853: LIST
80854: PUSH
80855: LD_INT 1
80857: NEG
80858: PUSH
80859: LD_INT 2
80861: NEG
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: PUSH
80867: LD_INT 0
80869: PUSH
80870: LD_INT 2
80872: NEG
80873: PUSH
80874: EMPTY
80875: LIST
80876: LIST
80877: PUSH
80878: LD_INT 1
80880: PUSH
80881: LD_INT 1
80883: NEG
80884: PUSH
80885: EMPTY
80886: LIST
80887: LIST
80888: PUSH
80889: LD_INT 1
80891: PUSH
80892: LD_INT 2
80894: PUSH
80895: EMPTY
80896: LIST
80897: LIST
80898: PUSH
80899: LD_INT 0
80901: PUSH
80902: LD_INT 2
80904: PUSH
80905: EMPTY
80906: LIST
80907: LIST
80908: PUSH
80909: LD_INT 1
80911: NEG
80912: PUSH
80913: LD_INT 1
80915: PUSH
80916: EMPTY
80917: LIST
80918: LIST
80919: PUSH
80920: LD_INT 1
80922: PUSH
80923: LD_INT 3
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: LD_INT 0
80932: PUSH
80933: LD_INT 3
80935: PUSH
80936: EMPTY
80937: LIST
80938: LIST
80939: PUSH
80940: LD_INT 1
80942: NEG
80943: PUSH
80944: LD_INT 2
80946: PUSH
80947: EMPTY
80948: LIST
80949: LIST
80950: PUSH
80951: EMPTY
80952: LIST
80953: LIST
80954: LIST
80955: LIST
80956: LIST
80957: LIST
80958: LIST
80959: LIST
80960: LIST
80961: LIST
80962: LIST
80963: LIST
80964: LIST
80965: LIST
80966: LIST
80967: LIST
80968: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80969: LD_ADDR_VAR 0 12
80973: PUSH
80974: LD_INT 0
80976: PUSH
80977: LD_INT 0
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PUSH
80984: LD_INT 0
80986: PUSH
80987: LD_INT 1
80989: NEG
80990: PUSH
80991: EMPTY
80992: LIST
80993: LIST
80994: PUSH
80995: LD_INT 1
80997: PUSH
80998: LD_INT 0
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 1
81007: PUSH
81008: LD_INT 1
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 0
81017: PUSH
81018: LD_INT 1
81020: PUSH
81021: EMPTY
81022: LIST
81023: LIST
81024: PUSH
81025: LD_INT 1
81027: NEG
81028: PUSH
81029: LD_INT 0
81031: PUSH
81032: EMPTY
81033: LIST
81034: LIST
81035: PUSH
81036: LD_INT 1
81038: NEG
81039: PUSH
81040: LD_INT 1
81042: NEG
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: PUSH
81048: LD_INT 1
81050: PUSH
81051: LD_INT 1
81053: NEG
81054: PUSH
81055: EMPTY
81056: LIST
81057: LIST
81058: PUSH
81059: LD_INT 2
81061: PUSH
81062: LD_INT 0
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 2
81071: PUSH
81072: LD_INT 1
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PUSH
81079: LD_INT 1
81081: NEG
81082: PUSH
81083: LD_INT 1
81085: PUSH
81086: EMPTY
81087: LIST
81088: LIST
81089: PUSH
81090: LD_INT 2
81092: NEG
81093: PUSH
81094: LD_INT 0
81096: PUSH
81097: EMPTY
81098: LIST
81099: LIST
81100: PUSH
81101: LD_INT 2
81103: NEG
81104: PUSH
81105: LD_INT 1
81107: NEG
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 2
81115: NEG
81116: PUSH
81117: LD_INT 1
81119: PUSH
81120: EMPTY
81121: LIST
81122: LIST
81123: PUSH
81124: LD_INT 3
81126: NEG
81127: PUSH
81128: LD_INT 0
81130: PUSH
81131: EMPTY
81132: LIST
81133: LIST
81134: PUSH
81135: LD_INT 3
81137: NEG
81138: PUSH
81139: LD_INT 1
81141: NEG
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PUSH
81147: EMPTY
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
81165: LD_ADDR_VAR 0 13
81169: PUSH
81170: LD_INT 0
81172: PUSH
81173: LD_INT 0
81175: PUSH
81176: EMPTY
81177: LIST
81178: LIST
81179: PUSH
81180: LD_INT 0
81182: PUSH
81183: LD_INT 1
81185: NEG
81186: PUSH
81187: EMPTY
81188: LIST
81189: LIST
81190: PUSH
81191: LD_INT 1
81193: PUSH
81194: LD_INT 0
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: PUSH
81201: LD_INT 1
81203: PUSH
81204: LD_INT 1
81206: PUSH
81207: EMPTY
81208: LIST
81209: LIST
81210: PUSH
81211: LD_INT 0
81213: PUSH
81214: LD_INT 1
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: PUSH
81221: LD_INT 1
81223: NEG
81224: PUSH
81225: LD_INT 0
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: PUSH
81232: LD_INT 1
81234: NEG
81235: PUSH
81236: LD_INT 1
81238: NEG
81239: PUSH
81240: EMPTY
81241: LIST
81242: LIST
81243: PUSH
81244: LD_INT 1
81246: NEG
81247: PUSH
81248: LD_INT 2
81250: NEG
81251: PUSH
81252: EMPTY
81253: LIST
81254: LIST
81255: PUSH
81256: LD_INT 2
81258: PUSH
81259: LD_INT 1
81261: PUSH
81262: EMPTY
81263: LIST
81264: LIST
81265: PUSH
81266: LD_INT 2
81268: PUSH
81269: LD_INT 2
81271: PUSH
81272: EMPTY
81273: LIST
81274: LIST
81275: PUSH
81276: LD_INT 1
81278: PUSH
81279: LD_INT 2
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 2
81288: NEG
81289: PUSH
81290: LD_INT 1
81292: NEG
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: PUSH
81298: LD_INT 2
81300: NEG
81301: PUSH
81302: LD_INT 2
81304: NEG
81305: PUSH
81306: EMPTY
81307: LIST
81308: LIST
81309: PUSH
81310: LD_INT 2
81312: NEG
81313: PUSH
81314: LD_INT 3
81316: NEG
81317: PUSH
81318: EMPTY
81319: LIST
81320: LIST
81321: PUSH
81322: LD_INT 3
81324: NEG
81325: PUSH
81326: LD_INT 2
81328: NEG
81329: PUSH
81330: EMPTY
81331: LIST
81332: LIST
81333: PUSH
81334: LD_INT 3
81336: NEG
81337: PUSH
81338: LD_INT 3
81340: NEG
81341: PUSH
81342: EMPTY
81343: LIST
81344: LIST
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: LIST
81350: LIST
81351: LIST
81352: LIST
81353: LIST
81354: LIST
81355: LIST
81356: LIST
81357: LIST
81358: LIST
81359: LIST
81360: LIST
81361: LIST
81362: LIST
81363: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
81364: LD_ADDR_VAR 0 14
81368: PUSH
81369: LD_INT 0
81371: PUSH
81372: LD_INT 0
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 0
81381: PUSH
81382: LD_INT 1
81384: NEG
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 1
81392: PUSH
81393: LD_INT 0
81395: PUSH
81396: EMPTY
81397: LIST
81398: LIST
81399: PUSH
81400: LD_INT 1
81402: PUSH
81403: LD_INT 1
81405: PUSH
81406: EMPTY
81407: LIST
81408: LIST
81409: PUSH
81410: LD_INT 0
81412: PUSH
81413: LD_INT 1
81415: PUSH
81416: EMPTY
81417: LIST
81418: LIST
81419: PUSH
81420: LD_INT 1
81422: NEG
81423: PUSH
81424: LD_INT 0
81426: PUSH
81427: EMPTY
81428: LIST
81429: LIST
81430: PUSH
81431: LD_INT 1
81433: NEG
81434: PUSH
81435: LD_INT 1
81437: NEG
81438: PUSH
81439: EMPTY
81440: LIST
81441: LIST
81442: PUSH
81443: LD_INT 1
81445: NEG
81446: PUSH
81447: LD_INT 2
81449: NEG
81450: PUSH
81451: EMPTY
81452: LIST
81453: LIST
81454: PUSH
81455: LD_INT 0
81457: PUSH
81458: LD_INT 2
81460: NEG
81461: PUSH
81462: EMPTY
81463: LIST
81464: LIST
81465: PUSH
81466: LD_INT 1
81468: PUSH
81469: LD_INT 1
81471: NEG
81472: PUSH
81473: EMPTY
81474: LIST
81475: LIST
81476: PUSH
81477: LD_INT 1
81479: PUSH
81480: LD_INT 2
81482: PUSH
81483: EMPTY
81484: LIST
81485: LIST
81486: PUSH
81487: LD_INT 0
81489: PUSH
81490: LD_INT 2
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: PUSH
81497: LD_INT 1
81499: NEG
81500: PUSH
81501: LD_INT 1
81503: PUSH
81504: EMPTY
81505: LIST
81506: LIST
81507: PUSH
81508: LD_INT 1
81510: NEG
81511: PUSH
81512: LD_INT 3
81514: NEG
81515: PUSH
81516: EMPTY
81517: LIST
81518: LIST
81519: PUSH
81520: LD_INT 0
81522: PUSH
81523: LD_INT 3
81525: NEG
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 1
81533: PUSH
81534: LD_INT 2
81536: NEG
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: EMPTY
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: LIST
81556: LIST
81557: LIST
81558: LIST
81559: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
81560: LD_ADDR_VAR 0 15
81564: PUSH
81565: LD_INT 0
81567: PUSH
81568: LD_INT 0
81570: PUSH
81571: EMPTY
81572: LIST
81573: LIST
81574: PUSH
81575: LD_INT 0
81577: PUSH
81578: LD_INT 1
81580: NEG
81581: PUSH
81582: EMPTY
81583: LIST
81584: LIST
81585: PUSH
81586: LD_INT 1
81588: PUSH
81589: LD_INT 0
81591: PUSH
81592: EMPTY
81593: LIST
81594: LIST
81595: PUSH
81596: LD_INT 1
81598: PUSH
81599: LD_INT 1
81601: PUSH
81602: EMPTY
81603: LIST
81604: LIST
81605: PUSH
81606: LD_INT 0
81608: PUSH
81609: LD_INT 1
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PUSH
81616: LD_INT 1
81618: NEG
81619: PUSH
81620: LD_INT 0
81622: PUSH
81623: EMPTY
81624: LIST
81625: LIST
81626: PUSH
81627: LD_INT 1
81629: NEG
81630: PUSH
81631: LD_INT 1
81633: NEG
81634: PUSH
81635: EMPTY
81636: LIST
81637: LIST
81638: PUSH
81639: LD_INT 1
81641: PUSH
81642: LD_INT 1
81644: NEG
81645: PUSH
81646: EMPTY
81647: LIST
81648: LIST
81649: PUSH
81650: LD_INT 2
81652: PUSH
81653: LD_INT 0
81655: PUSH
81656: EMPTY
81657: LIST
81658: LIST
81659: PUSH
81660: LD_INT 2
81662: PUSH
81663: LD_INT 1
81665: PUSH
81666: EMPTY
81667: LIST
81668: LIST
81669: PUSH
81670: LD_INT 1
81672: NEG
81673: PUSH
81674: LD_INT 1
81676: PUSH
81677: EMPTY
81678: LIST
81679: LIST
81680: PUSH
81681: LD_INT 2
81683: NEG
81684: PUSH
81685: LD_INT 0
81687: PUSH
81688: EMPTY
81689: LIST
81690: LIST
81691: PUSH
81692: LD_INT 2
81694: NEG
81695: PUSH
81696: LD_INT 1
81698: NEG
81699: PUSH
81700: EMPTY
81701: LIST
81702: LIST
81703: PUSH
81704: LD_INT 2
81706: PUSH
81707: LD_INT 1
81709: NEG
81710: PUSH
81711: EMPTY
81712: LIST
81713: LIST
81714: PUSH
81715: LD_INT 3
81717: PUSH
81718: LD_INT 0
81720: PUSH
81721: EMPTY
81722: LIST
81723: LIST
81724: PUSH
81725: LD_INT 3
81727: PUSH
81728: LD_INT 1
81730: PUSH
81731: EMPTY
81732: LIST
81733: LIST
81734: PUSH
81735: EMPTY
81736: LIST
81737: LIST
81738: LIST
81739: LIST
81740: LIST
81741: LIST
81742: LIST
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: LIST
81750: LIST
81751: LIST
81752: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81753: LD_ADDR_VAR 0 16
81757: PUSH
81758: LD_INT 0
81760: PUSH
81761: LD_INT 0
81763: PUSH
81764: EMPTY
81765: LIST
81766: LIST
81767: PUSH
81768: LD_INT 0
81770: PUSH
81771: LD_INT 1
81773: NEG
81774: PUSH
81775: EMPTY
81776: LIST
81777: LIST
81778: PUSH
81779: LD_INT 1
81781: PUSH
81782: LD_INT 0
81784: PUSH
81785: EMPTY
81786: LIST
81787: LIST
81788: PUSH
81789: LD_INT 1
81791: PUSH
81792: LD_INT 1
81794: PUSH
81795: EMPTY
81796: LIST
81797: LIST
81798: PUSH
81799: LD_INT 0
81801: PUSH
81802: LD_INT 1
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 1
81811: NEG
81812: PUSH
81813: LD_INT 0
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PUSH
81820: LD_INT 1
81822: NEG
81823: PUSH
81824: LD_INT 1
81826: NEG
81827: PUSH
81828: EMPTY
81829: LIST
81830: LIST
81831: PUSH
81832: LD_INT 1
81834: NEG
81835: PUSH
81836: LD_INT 2
81838: NEG
81839: PUSH
81840: EMPTY
81841: LIST
81842: LIST
81843: PUSH
81844: LD_INT 2
81846: PUSH
81847: LD_INT 1
81849: PUSH
81850: EMPTY
81851: LIST
81852: LIST
81853: PUSH
81854: LD_INT 2
81856: PUSH
81857: LD_INT 2
81859: PUSH
81860: EMPTY
81861: LIST
81862: LIST
81863: PUSH
81864: LD_INT 1
81866: PUSH
81867: LD_INT 2
81869: PUSH
81870: EMPTY
81871: LIST
81872: LIST
81873: PUSH
81874: LD_INT 2
81876: NEG
81877: PUSH
81878: LD_INT 1
81880: NEG
81881: PUSH
81882: EMPTY
81883: LIST
81884: LIST
81885: PUSH
81886: LD_INT 2
81888: NEG
81889: PUSH
81890: LD_INT 2
81892: NEG
81893: PUSH
81894: EMPTY
81895: LIST
81896: LIST
81897: PUSH
81898: LD_INT 3
81900: PUSH
81901: LD_INT 2
81903: PUSH
81904: EMPTY
81905: LIST
81906: LIST
81907: PUSH
81908: LD_INT 3
81910: PUSH
81911: LD_INT 3
81913: PUSH
81914: EMPTY
81915: LIST
81916: LIST
81917: PUSH
81918: LD_INT 2
81920: PUSH
81921: LD_INT 3
81923: PUSH
81924: EMPTY
81925: LIST
81926: LIST
81927: PUSH
81928: EMPTY
81929: LIST
81930: LIST
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: LIST
81938: LIST
81939: LIST
81940: LIST
81941: LIST
81942: LIST
81943: LIST
81944: LIST
81945: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81946: LD_ADDR_VAR 0 17
81950: PUSH
81951: LD_INT 0
81953: PUSH
81954: LD_INT 0
81956: PUSH
81957: EMPTY
81958: LIST
81959: LIST
81960: PUSH
81961: LD_INT 0
81963: PUSH
81964: LD_INT 1
81966: NEG
81967: PUSH
81968: EMPTY
81969: LIST
81970: LIST
81971: PUSH
81972: LD_INT 1
81974: PUSH
81975: LD_INT 0
81977: PUSH
81978: EMPTY
81979: LIST
81980: LIST
81981: PUSH
81982: LD_INT 1
81984: PUSH
81985: LD_INT 1
81987: PUSH
81988: EMPTY
81989: LIST
81990: LIST
81991: PUSH
81992: LD_INT 0
81994: PUSH
81995: LD_INT 1
81997: PUSH
81998: EMPTY
81999: LIST
82000: LIST
82001: PUSH
82002: LD_INT 1
82004: NEG
82005: PUSH
82006: LD_INT 0
82008: PUSH
82009: EMPTY
82010: LIST
82011: LIST
82012: PUSH
82013: LD_INT 1
82015: NEG
82016: PUSH
82017: LD_INT 1
82019: NEG
82020: PUSH
82021: EMPTY
82022: LIST
82023: LIST
82024: PUSH
82025: LD_INT 1
82027: NEG
82028: PUSH
82029: LD_INT 2
82031: NEG
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 0
82039: PUSH
82040: LD_INT 2
82042: NEG
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: PUSH
82048: LD_INT 1
82050: PUSH
82051: LD_INT 1
82053: NEG
82054: PUSH
82055: EMPTY
82056: LIST
82057: LIST
82058: PUSH
82059: LD_INT 2
82061: PUSH
82062: LD_INT 0
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: LD_INT 2
82071: PUSH
82072: LD_INT 1
82074: PUSH
82075: EMPTY
82076: LIST
82077: LIST
82078: PUSH
82079: LD_INT 2
82081: PUSH
82082: LD_INT 2
82084: PUSH
82085: EMPTY
82086: LIST
82087: LIST
82088: PUSH
82089: LD_INT 1
82091: PUSH
82092: LD_INT 2
82094: PUSH
82095: EMPTY
82096: LIST
82097: LIST
82098: PUSH
82099: LD_INT 0
82101: PUSH
82102: LD_INT 2
82104: PUSH
82105: EMPTY
82106: LIST
82107: LIST
82108: PUSH
82109: LD_INT 1
82111: NEG
82112: PUSH
82113: LD_INT 1
82115: PUSH
82116: EMPTY
82117: LIST
82118: LIST
82119: PUSH
82120: LD_INT 2
82122: NEG
82123: PUSH
82124: LD_INT 0
82126: PUSH
82127: EMPTY
82128: LIST
82129: LIST
82130: PUSH
82131: LD_INT 2
82133: NEG
82134: PUSH
82135: LD_INT 1
82137: NEG
82138: PUSH
82139: EMPTY
82140: LIST
82141: LIST
82142: PUSH
82143: LD_INT 2
82145: NEG
82146: PUSH
82147: LD_INT 2
82149: NEG
82150: PUSH
82151: EMPTY
82152: LIST
82153: LIST
82154: PUSH
82155: EMPTY
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: LIST
82162: LIST
82163: LIST
82164: LIST
82165: LIST
82166: LIST
82167: LIST
82168: LIST
82169: LIST
82170: LIST
82171: LIST
82172: LIST
82173: LIST
82174: LIST
82175: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82176: LD_ADDR_VAR 0 18
82180: PUSH
82181: LD_INT 0
82183: PUSH
82184: LD_INT 0
82186: PUSH
82187: EMPTY
82188: LIST
82189: LIST
82190: PUSH
82191: LD_INT 0
82193: PUSH
82194: LD_INT 1
82196: NEG
82197: PUSH
82198: EMPTY
82199: LIST
82200: LIST
82201: PUSH
82202: LD_INT 1
82204: PUSH
82205: LD_INT 0
82207: PUSH
82208: EMPTY
82209: LIST
82210: LIST
82211: PUSH
82212: LD_INT 1
82214: PUSH
82215: LD_INT 1
82217: PUSH
82218: EMPTY
82219: LIST
82220: LIST
82221: PUSH
82222: LD_INT 0
82224: PUSH
82225: LD_INT 1
82227: PUSH
82228: EMPTY
82229: LIST
82230: LIST
82231: PUSH
82232: LD_INT 1
82234: NEG
82235: PUSH
82236: LD_INT 0
82238: PUSH
82239: EMPTY
82240: LIST
82241: LIST
82242: PUSH
82243: LD_INT 1
82245: NEG
82246: PUSH
82247: LD_INT 1
82249: NEG
82250: PUSH
82251: EMPTY
82252: LIST
82253: LIST
82254: PUSH
82255: LD_INT 1
82257: NEG
82258: PUSH
82259: LD_INT 2
82261: NEG
82262: PUSH
82263: EMPTY
82264: LIST
82265: LIST
82266: PUSH
82267: LD_INT 0
82269: PUSH
82270: LD_INT 2
82272: NEG
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PUSH
82278: LD_INT 1
82280: PUSH
82281: LD_INT 1
82283: NEG
82284: PUSH
82285: EMPTY
82286: LIST
82287: LIST
82288: PUSH
82289: LD_INT 2
82291: PUSH
82292: LD_INT 0
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: LD_INT 2
82301: PUSH
82302: LD_INT 1
82304: PUSH
82305: EMPTY
82306: LIST
82307: LIST
82308: PUSH
82309: LD_INT 2
82311: PUSH
82312: LD_INT 2
82314: PUSH
82315: EMPTY
82316: LIST
82317: LIST
82318: PUSH
82319: LD_INT 1
82321: PUSH
82322: LD_INT 2
82324: PUSH
82325: EMPTY
82326: LIST
82327: LIST
82328: PUSH
82329: LD_INT 0
82331: PUSH
82332: LD_INT 2
82334: PUSH
82335: EMPTY
82336: LIST
82337: LIST
82338: PUSH
82339: LD_INT 1
82341: NEG
82342: PUSH
82343: LD_INT 1
82345: PUSH
82346: EMPTY
82347: LIST
82348: LIST
82349: PUSH
82350: LD_INT 2
82352: NEG
82353: PUSH
82354: LD_INT 0
82356: PUSH
82357: EMPTY
82358: LIST
82359: LIST
82360: PUSH
82361: LD_INT 2
82363: NEG
82364: PUSH
82365: LD_INT 1
82367: NEG
82368: PUSH
82369: EMPTY
82370: LIST
82371: LIST
82372: PUSH
82373: LD_INT 2
82375: NEG
82376: PUSH
82377: LD_INT 2
82379: NEG
82380: PUSH
82381: EMPTY
82382: LIST
82383: LIST
82384: PUSH
82385: EMPTY
82386: LIST
82387: LIST
82388: LIST
82389: LIST
82390: LIST
82391: LIST
82392: LIST
82393: LIST
82394: LIST
82395: LIST
82396: LIST
82397: LIST
82398: LIST
82399: LIST
82400: LIST
82401: LIST
82402: LIST
82403: LIST
82404: LIST
82405: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82406: LD_ADDR_VAR 0 19
82410: PUSH
82411: LD_INT 0
82413: PUSH
82414: LD_INT 0
82416: PUSH
82417: EMPTY
82418: LIST
82419: LIST
82420: PUSH
82421: LD_INT 0
82423: PUSH
82424: LD_INT 1
82426: NEG
82427: PUSH
82428: EMPTY
82429: LIST
82430: LIST
82431: PUSH
82432: LD_INT 1
82434: PUSH
82435: LD_INT 0
82437: PUSH
82438: EMPTY
82439: LIST
82440: LIST
82441: PUSH
82442: LD_INT 1
82444: PUSH
82445: LD_INT 1
82447: PUSH
82448: EMPTY
82449: LIST
82450: LIST
82451: PUSH
82452: LD_INT 0
82454: PUSH
82455: LD_INT 1
82457: PUSH
82458: EMPTY
82459: LIST
82460: LIST
82461: PUSH
82462: LD_INT 1
82464: NEG
82465: PUSH
82466: LD_INT 0
82468: PUSH
82469: EMPTY
82470: LIST
82471: LIST
82472: PUSH
82473: LD_INT 1
82475: NEG
82476: PUSH
82477: LD_INT 1
82479: NEG
82480: PUSH
82481: EMPTY
82482: LIST
82483: LIST
82484: PUSH
82485: LD_INT 1
82487: NEG
82488: PUSH
82489: LD_INT 2
82491: NEG
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: PUSH
82497: LD_INT 0
82499: PUSH
82500: LD_INT 2
82502: NEG
82503: PUSH
82504: EMPTY
82505: LIST
82506: LIST
82507: PUSH
82508: LD_INT 1
82510: PUSH
82511: LD_INT 1
82513: NEG
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PUSH
82519: LD_INT 2
82521: PUSH
82522: LD_INT 0
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PUSH
82529: LD_INT 2
82531: PUSH
82532: LD_INT 1
82534: PUSH
82535: EMPTY
82536: LIST
82537: LIST
82538: PUSH
82539: LD_INT 2
82541: PUSH
82542: LD_INT 2
82544: PUSH
82545: EMPTY
82546: LIST
82547: LIST
82548: PUSH
82549: LD_INT 1
82551: PUSH
82552: LD_INT 2
82554: PUSH
82555: EMPTY
82556: LIST
82557: LIST
82558: PUSH
82559: LD_INT 0
82561: PUSH
82562: LD_INT 2
82564: PUSH
82565: EMPTY
82566: LIST
82567: LIST
82568: PUSH
82569: LD_INT 1
82571: NEG
82572: PUSH
82573: LD_INT 1
82575: PUSH
82576: EMPTY
82577: LIST
82578: LIST
82579: PUSH
82580: LD_INT 2
82582: NEG
82583: PUSH
82584: LD_INT 0
82586: PUSH
82587: EMPTY
82588: LIST
82589: LIST
82590: PUSH
82591: LD_INT 2
82593: NEG
82594: PUSH
82595: LD_INT 1
82597: NEG
82598: PUSH
82599: EMPTY
82600: LIST
82601: LIST
82602: PUSH
82603: LD_INT 2
82605: NEG
82606: PUSH
82607: LD_INT 2
82609: NEG
82610: PUSH
82611: EMPTY
82612: LIST
82613: LIST
82614: PUSH
82615: EMPTY
82616: LIST
82617: LIST
82618: LIST
82619: LIST
82620: LIST
82621: LIST
82622: LIST
82623: LIST
82624: LIST
82625: LIST
82626: LIST
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: LIST
82633: LIST
82634: LIST
82635: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82636: LD_ADDR_VAR 0 20
82640: PUSH
82641: LD_INT 0
82643: PUSH
82644: LD_INT 0
82646: PUSH
82647: EMPTY
82648: LIST
82649: LIST
82650: PUSH
82651: LD_INT 0
82653: PUSH
82654: LD_INT 1
82656: NEG
82657: PUSH
82658: EMPTY
82659: LIST
82660: LIST
82661: PUSH
82662: LD_INT 1
82664: PUSH
82665: LD_INT 0
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: PUSH
82672: LD_INT 1
82674: PUSH
82675: LD_INT 1
82677: PUSH
82678: EMPTY
82679: LIST
82680: LIST
82681: PUSH
82682: LD_INT 0
82684: PUSH
82685: LD_INT 1
82687: PUSH
82688: EMPTY
82689: LIST
82690: LIST
82691: PUSH
82692: LD_INT 1
82694: NEG
82695: PUSH
82696: LD_INT 0
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 1
82705: NEG
82706: PUSH
82707: LD_INT 1
82709: NEG
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 1
82717: NEG
82718: PUSH
82719: LD_INT 2
82721: NEG
82722: PUSH
82723: EMPTY
82724: LIST
82725: LIST
82726: PUSH
82727: LD_INT 0
82729: PUSH
82730: LD_INT 2
82732: NEG
82733: PUSH
82734: EMPTY
82735: LIST
82736: LIST
82737: PUSH
82738: LD_INT 1
82740: PUSH
82741: LD_INT 1
82743: NEG
82744: PUSH
82745: EMPTY
82746: LIST
82747: LIST
82748: PUSH
82749: LD_INT 2
82751: PUSH
82752: LD_INT 0
82754: PUSH
82755: EMPTY
82756: LIST
82757: LIST
82758: PUSH
82759: LD_INT 2
82761: PUSH
82762: LD_INT 1
82764: PUSH
82765: EMPTY
82766: LIST
82767: LIST
82768: PUSH
82769: LD_INT 2
82771: PUSH
82772: LD_INT 2
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: PUSH
82779: LD_INT 1
82781: PUSH
82782: LD_INT 2
82784: PUSH
82785: EMPTY
82786: LIST
82787: LIST
82788: PUSH
82789: LD_INT 0
82791: PUSH
82792: LD_INT 2
82794: PUSH
82795: EMPTY
82796: LIST
82797: LIST
82798: PUSH
82799: LD_INT 1
82801: NEG
82802: PUSH
82803: LD_INT 1
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 2
82812: NEG
82813: PUSH
82814: LD_INT 0
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 2
82823: NEG
82824: PUSH
82825: LD_INT 1
82827: NEG
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 2
82835: NEG
82836: PUSH
82837: LD_INT 2
82839: NEG
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PUSH
82845: EMPTY
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: LIST
82856: LIST
82857: LIST
82858: LIST
82859: LIST
82860: LIST
82861: LIST
82862: LIST
82863: LIST
82864: LIST
82865: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82866: LD_ADDR_VAR 0 21
82870: PUSH
82871: LD_INT 0
82873: PUSH
82874: LD_INT 0
82876: PUSH
82877: EMPTY
82878: LIST
82879: LIST
82880: PUSH
82881: LD_INT 0
82883: PUSH
82884: LD_INT 1
82886: NEG
82887: PUSH
82888: EMPTY
82889: LIST
82890: LIST
82891: PUSH
82892: LD_INT 1
82894: PUSH
82895: LD_INT 0
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: PUSH
82902: LD_INT 1
82904: PUSH
82905: LD_INT 1
82907: PUSH
82908: EMPTY
82909: LIST
82910: LIST
82911: PUSH
82912: LD_INT 0
82914: PUSH
82915: LD_INT 1
82917: PUSH
82918: EMPTY
82919: LIST
82920: LIST
82921: PUSH
82922: LD_INT 1
82924: NEG
82925: PUSH
82926: LD_INT 0
82928: PUSH
82929: EMPTY
82930: LIST
82931: LIST
82932: PUSH
82933: LD_INT 1
82935: NEG
82936: PUSH
82937: LD_INT 1
82939: NEG
82940: PUSH
82941: EMPTY
82942: LIST
82943: LIST
82944: PUSH
82945: LD_INT 1
82947: NEG
82948: PUSH
82949: LD_INT 2
82951: NEG
82952: PUSH
82953: EMPTY
82954: LIST
82955: LIST
82956: PUSH
82957: LD_INT 0
82959: PUSH
82960: LD_INT 2
82962: NEG
82963: PUSH
82964: EMPTY
82965: LIST
82966: LIST
82967: PUSH
82968: LD_INT 1
82970: PUSH
82971: LD_INT 1
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 2
82981: PUSH
82982: LD_INT 0
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: PUSH
82989: LD_INT 2
82991: PUSH
82992: LD_INT 1
82994: PUSH
82995: EMPTY
82996: LIST
82997: LIST
82998: PUSH
82999: LD_INT 2
83001: PUSH
83002: LD_INT 2
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 1
83011: PUSH
83012: LD_INT 2
83014: PUSH
83015: EMPTY
83016: LIST
83017: LIST
83018: PUSH
83019: LD_INT 0
83021: PUSH
83022: LD_INT 2
83024: PUSH
83025: EMPTY
83026: LIST
83027: LIST
83028: PUSH
83029: LD_INT 1
83031: NEG
83032: PUSH
83033: LD_INT 1
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 2
83042: NEG
83043: PUSH
83044: LD_INT 0
83046: PUSH
83047: EMPTY
83048: LIST
83049: LIST
83050: PUSH
83051: LD_INT 2
83053: NEG
83054: PUSH
83055: LD_INT 1
83057: NEG
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: PUSH
83063: LD_INT 2
83065: NEG
83066: PUSH
83067: LD_INT 2
83069: NEG
83070: PUSH
83071: EMPTY
83072: LIST
83073: LIST
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: LIST
83079: LIST
83080: LIST
83081: LIST
83082: LIST
83083: LIST
83084: LIST
83085: LIST
83086: LIST
83087: LIST
83088: LIST
83089: LIST
83090: LIST
83091: LIST
83092: LIST
83093: LIST
83094: LIST
83095: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
83096: LD_ADDR_VAR 0 22
83100: PUSH
83101: LD_INT 0
83103: PUSH
83104: LD_INT 0
83106: PUSH
83107: EMPTY
83108: LIST
83109: LIST
83110: PUSH
83111: LD_INT 0
83113: PUSH
83114: LD_INT 1
83116: NEG
83117: PUSH
83118: EMPTY
83119: LIST
83120: LIST
83121: PUSH
83122: LD_INT 1
83124: PUSH
83125: LD_INT 0
83127: PUSH
83128: EMPTY
83129: LIST
83130: LIST
83131: PUSH
83132: LD_INT 1
83134: PUSH
83135: LD_INT 1
83137: PUSH
83138: EMPTY
83139: LIST
83140: LIST
83141: PUSH
83142: LD_INT 0
83144: PUSH
83145: LD_INT 1
83147: PUSH
83148: EMPTY
83149: LIST
83150: LIST
83151: PUSH
83152: LD_INT 1
83154: NEG
83155: PUSH
83156: LD_INT 0
83158: PUSH
83159: EMPTY
83160: LIST
83161: LIST
83162: PUSH
83163: LD_INT 1
83165: NEG
83166: PUSH
83167: LD_INT 1
83169: NEG
83170: PUSH
83171: EMPTY
83172: LIST
83173: LIST
83174: PUSH
83175: LD_INT 1
83177: NEG
83178: PUSH
83179: LD_INT 2
83181: NEG
83182: PUSH
83183: EMPTY
83184: LIST
83185: LIST
83186: PUSH
83187: LD_INT 0
83189: PUSH
83190: LD_INT 2
83192: NEG
83193: PUSH
83194: EMPTY
83195: LIST
83196: LIST
83197: PUSH
83198: LD_INT 1
83200: PUSH
83201: LD_INT 1
83203: NEG
83204: PUSH
83205: EMPTY
83206: LIST
83207: LIST
83208: PUSH
83209: LD_INT 2
83211: PUSH
83212: LD_INT 0
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: PUSH
83219: LD_INT 2
83221: PUSH
83222: LD_INT 1
83224: PUSH
83225: EMPTY
83226: LIST
83227: LIST
83228: PUSH
83229: LD_INT 2
83231: PUSH
83232: LD_INT 2
83234: PUSH
83235: EMPTY
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 1
83241: PUSH
83242: LD_INT 2
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: PUSH
83249: LD_INT 0
83251: PUSH
83252: LD_INT 2
83254: PUSH
83255: EMPTY
83256: LIST
83257: LIST
83258: PUSH
83259: LD_INT 1
83261: NEG
83262: PUSH
83263: LD_INT 1
83265: PUSH
83266: EMPTY
83267: LIST
83268: LIST
83269: PUSH
83270: LD_INT 2
83272: NEG
83273: PUSH
83274: LD_INT 0
83276: PUSH
83277: EMPTY
83278: LIST
83279: LIST
83280: PUSH
83281: LD_INT 2
83283: NEG
83284: PUSH
83285: LD_INT 1
83287: NEG
83288: PUSH
83289: EMPTY
83290: LIST
83291: LIST
83292: PUSH
83293: LD_INT 2
83295: NEG
83296: PUSH
83297: LD_INT 2
83299: NEG
83300: PUSH
83301: EMPTY
83302: LIST
83303: LIST
83304: PUSH
83305: EMPTY
83306: LIST
83307: LIST
83308: LIST
83309: LIST
83310: LIST
83311: LIST
83312: LIST
83313: LIST
83314: LIST
83315: LIST
83316: LIST
83317: LIST
83318: LIST
83319: LIST
83320: LIST
83321: LIST
83322: LIST
83323: LIST
83324: LIST
83325: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
83326: LD_ADDR_VAR 0 23
83330: PUSH
83331: LD_INT 0
83333: PUSH
83334: LD_INT 0
83336: PUSH
83337: EMPTY
83338: LIST
83339: LIST
83340: PUSH
83341: LD_INT 0
83343: PUSH
83344: LD_INT 1
83346: NEG
83347: PUSH
83348: EMPTY
83349: LIST
83350: LIST
83351: PUSH
83352: LD_INT 1
83354: PUSH
83355: LD_INT 0
83357: PUSH
83358: EMPTY
83359: LIST
83360: LIST
83361: PUSH
83362: LD_INT 1
83364: PUSH
83365: LD_INT 1
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 0
83374: PUSH
83375: LD_INT 1
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: PUSH
83382: LD_INT 1
83384: NEG
83385: PUSH
83386: LD_INT 0
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: PUSH
83393: LD_INT 1
83395: NEG
83396: PUSH
83397: LD_INT 1
83399: NEG
83400: PUSH
83401: EMPTY
83402: LIST
83403: LIST
83404: PUSH
83405: LD_INT 1
83407: NEG
83408: PUSH
83409: LD_INT 2
83411: NEG
83412: PUSH
83413: EMPTY
83414: LIST
83415: LIST
83416: PUSH
83417: LD_INT 0
83419: PUSH
83420: LD_INT 2
83422: NEG
83423: PUSH
83424: EMPTY
83425: LIST
83426: LIST
83427: PUSH
83428: LD_INT 1
83430: PUSH
83431: LD_INT 1
83433: NEG
83434: PUSH
83435: EMPTY
83436: LIST
83437: LIST
83438: PUSH
83439: LD_INT 2
83441: PUSH
83442: LD_INT 0
83444: PUSH
83445: EMPTY
83446: LIST
83447: LIST
83448: PUSH
83449: LD_INT 2
83451: PUSH
83452: LD_INT 1
83454: PUSH
83455: EMPTY
83456: LIST
83457: LIST
83458: PUSH
83459: LD_INT 2
83461: PUSH
83462: LD_INT 2
83464: PUSH
83465: EMPTY
83466: LIST
83467: LIST
83468: PUSH
83469: LD_INT 1
83471: PUSH
83472: LD_INT 2
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 0
83481: PUSH
83482: LD_INT 2
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 1
83491: NEG
83492: PUSH
83493: LD_INT 1
83495: PUSH
83496: EMPTY
83497: LIST
83498: LIST
83499: PUSH
83500: LD_INT 2
83502: NEG
83503: PUSH
83504: LD_INT 0
83506: PUSH
83507: EMPTY
83508: LIST
83509: LIST
83510: PUSH
83511: LD_INT 2
83513: NEG
83514: PUSH
83515: LD_INT 1
83517: NEG
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: PUSH
83523: LD_INT 2
83525: NEG
83526: PUSH
83527: LD_INT 2
83529: NEG
83530: PUSH
83531: EMPTY
83532: LIST
83533: LIST
83534: PUSH
83535: LD_INT 2
83537: NEG
83538: PUSH
83539: LD_INT 3
83541: NEG
83542: PUSH
83543: EMPTY
83544: LIST
83545: LIST
83546: PUSH
83547: LD_INT 1
83549: NEG
83550: PUSH
83551: LD_INT 3
83553: NEG
83554: PUSH
83555: EMPTY
83556: LIST
83557: LIST
83558: PUSH
83559: LD_INT 1
83561: PUSH
83562: LD_INT 2
83564: NEG
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 2
83572: PUSH
83573: LD_INT 1
83575: NEG
83576: PUSH
83577: EMPTY
83578: LIST
83579: LIST
83580: PUSH
83581: EMPTY
83582: LIST
83583: LIST
83584: LIST
83585: LIST
83586: LIST
83587: LIST
83588: LIST
83589: LIST
83590: LIST
83591: LIST
83592: LIST
83593: LIST
83594: LIST
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
83606: LD_ADDR_VAR 0 24
83610: PUSH
83611: LD_INT 0
83613: PUSH
83614: LD_INT 0
83616: PUSH
83617: EMPTY
83618: LIST
83619: LIST
83620: PUSH
83621: LD_INT 0
83623: PUSH
83624: LD_INT 1
83626: NEG
83627: PUSH
83628: EMPTY
83629: LIST
83630: LIST
83631: PUSH
83632: LD_INT 1
83634: PUSH
83635: LD_INT 0
83637: PUSH
83638: EMPTY
83639: LIST
83640: LIST
83641: PUSH
83642: LD_INT 1
83644: PUSH
83645: LD_INT 1
83647: PUSH
83648: EMPTY
83649: LIST
83650: LIST
83651: PUSH
83652: LD_INT 0
83654: PUSH
83655: LD_INT 1
83657: PUSH
83658: EMPTY
83659: LIST
83660: LIST
83661: PUSH
83662: LD_INT 1
83664: NEG
83665: PUSH
83666: LD_INT 0
83668: PUSH
83669: EMPTY
83670: LIST
83671: LIST
83672: PUSH
83673: LD_INT 1
83675: NEG
83676: PUSH
83677: LD_INT 1
83679: NEG
83680: PUSH
83681: EMPTY
83682: LIST
83683: LIST
83684: PUSH
83685: LD_INT 1
83687: NEG
83688: PUSH
83689: LD_INT 2
83691: NEG
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 0
83699: PUSH
83700: LD_INT 2
83702: NEG
83703: PUSH
83704: EMPTY
83705: LIST
83706: LIST
83707: PUSH
83708: LD_INT 1
83710: PUSH
83711: LD_INT 1
83713: NEG
83714: PUSH
83715: EMPTY
83716: LIST
83717: LIST
83718: PUSH
83719: LD_INT 2
83721: PUSH
83722: LD_INT 0
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 2
83731: PUSH
83732: LD_INT 1
83734: PUSH
83735: EMPTY
83736: LIST
83737: LIST
83738: PUSH
83739: LD_INT 2
83741: PUSH
83742: LD_INT 2
83744: PUSH
83745: EMPTY
83746: LIST
83747: LIST
83748: PUSH
83749: LD_INT 1
83751: PUSH
83752: LD_INT 2
83754: PUSH
83755: EMPTY
83756: LIST
83757: LIST
83758: PUSH
83759: LD_INT 0
83761: PUSH
83762: LD_INT 2
83764: PUSH
83765: EMPTY
83766: LIST
83767: LIST
83768: PUSH
83769: LD_INT 1
83771: NEG
83772: PUSH
83773: LD_INT 1
83775: PUSH
83776: EMPTY
83777: LIST
83778: LIST
83779: PUSH
83780: LD_INT 2
83782: NEG
83783: PUSH
83784: LD_INT 0
83786: PUSH
83787: EMPTY
83788: LIST
83789: LIST
83790: PUSH
83791: LD_INT 2
83793: NEG
83794: PUSH
83795: LD_INT 1
83797: NEG
83798: PUSH
83799: EMPTY
83800: LIST
83801: LIST
83802: PUSH
83803: LD_INT 2
83805: NEG
83806: PUSH
83807: LD_INT 2
83809: NEG
83810: PUSH
83811: EMPTY
83812: LIST
83813: LIST
83814: PUSH
83815: LD_INT 1
83817: PUSH
83818: LD_INT 2
83820: NEG
83821: PUSH
83822: EMPTY
83823: LIST
83824: LIST
83825: PUSH
83826: LD_INT 2
83828: PUSH
83829: LD_INT 1
83831: NEG
83832: PUSH
83833: EMPTY
83834: LIST
83835: LIST
83836: PUSH
83837: LD_INT 3
83839: PUSH
83840: LD_INT 1
83842: PUSH
83843: EMPTY
83844: LIST
83845: LIST
83846: PUSH
83847: LD_INT 3
83849: PUSH
83850: LD_INT 2
83852: PUSH
83853: EMPTY
83854: LIST
83855: LIST
83856: PUSH
83857: EMPTY
83858: LIST
83859: LIST
83860: LIST
83861: LIST
83862: LIST
83863: LIST
83864: LIST
83865: LIST
83866: LIST
83867: LIST
83868: LIST
83869: LIST
83870: LIST
83871: LIST
83872: LIST
83873: LIST
83874: LIST
83875: LIST
83876: LIST
83877: LIST
83878: LIST
83879: LIST
83880: LIST
83881: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83882: LD_ADDR_VAR 0 25
83886: PUSH
83887: LD_INT 0
83889: PUSH
83890: LD_INT 0
83892: PUSH
83893: EMPTY
83894: LIST
83895: LIST
83896: PUSH
83897: LD_INT 0
83899: PUSH
83900: LD_INT 1
83902: NEG
83903: PUSH
83904: EMPTY
83905: LIST
83906: LIST
83907: PUSH
83908: LD_INT 1
83910: PUSH
83911: LD_INT 0
83913: PUSH
83914: EMPTY
83915: LIST
83916: LIST
83917: PUSH
83918: LD_INT 1
83920: PUSH
83921: LD_INT 1
83923: PUSH
83924: EMPTY
83925: LIST
83926: LIST
83927: PUSH
83928: LD_INT 0
83930: PUSH
83931: LD_INT 1
83933: PUSH
83934: EMPTY
83935: LIST
83936: LIST
83937: PUSH
83938: LD_INT 1
83940: NEG
83941: PUSH
83942: LD_INT 0
83944: PUSH
83945: EMPTY
83946: LIST
83947: LIST
83948: PUSH
83949: LD_INT 1
83951: NEG
83952: PUSH
83953: LD_INT 1
83955: NEG
83956: PUSH
83957: EMPTY
83958: LIST
83959: LIST
83960: PUSH
83961: LD_INT 1
83963: NEG
83964: PUSH
83965: LD_INT 2
83967: NEG
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PUSH
83973: LD_INT 0
83975: PUSH
83976: LD_INT 2
83978: NEG
83979: PUSH
83980: EMPTY
83981: LIST
83982: LIST
83983: PUSH
83984: LD_INT 1
83986: PUSH
83987: LD_INT 1
83989: NEG
83990: PUSH
83991: EMPTY
83992: LIST
83993: LIST
83994: PUSH
83995: LD_INT 2
83997: PUSH
83998: LD_INT 0
84000: PUSH
84001: EMPTY
84002: LIST
84003: LIST
84004: PUSH
84005: LD_INT 2
84007: PUSH
84008: LD_INT 1
84010: PUSH
84011: EMPTY
84012: LIST
84013: LIST
84014: PUSH
84015: LD_INT 2
84017: PUSH
84018: LD_INT 2
84020: PUSH
84021: EMPTY
84022: LIST
84023: LIST
84024: PUSH
84025: LD_INT 1
84027: PUSH
84028: LD_INT 2
84030: PUSH
84031: EMPTY
84032: LIST
84033: LIST
84034: PUSH
84035: LD_INT 0
84037: PUSH
84038: LD_INT 2
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PUSH
84045: LD_INT 1
84047: NEG
84048: PUSH
84049: LD_INT 1
84051: PUSH
84052: EMPTY
84053: LIST
84054: LIST
84055: PUSH
84056: LD_INT 2
84058: NEG
84059: PUSH
84060: LD_INT 0
84062: PUSH
84063: EMPTY
84064: LIST
84065: LIST
84066: PUSH
84067: LD_INT 2
84069: NEG
84070: PUSH
84071: LD_INT 1
84073: NEG
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: PUSH
84079: LD_INT 2
84081: NEG
84082: PUSH
84083: LD_INT 2
84085: NEG
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 3
84093: PUSH
84094: LD_INT 1
84096: PUSH
84097: EMPTY
84098: LIST
84099: LIST
84100: PUSH
84101: LD_INT 3
84103: PUSH
84104: LD_INT 2
84106: PUSH
84107: EMPTY
84108: LIST
84109: LIST
84110: PUSH
84111: LD_INT 2
84113: PUSH
84114: LD_INT 3
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: PUSH
84121: LD_INT 1
84123: PUSH
84124: LD_INT 3
84126: PUSH
84127: EMPTY
84128: LIST
84129: LIST
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: LIST
84135: LIST
84136: LIST
84137: LIST
84138: LIST
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
84156: LD_ADDR_VAR 0 26
84160: PUSH
84161: LD_INT 0
84163: PUSH
84164: LD_INT 0
84166: PUSH
84167: EMPTY
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 0
84173: PUSH
84174: LD_INT 1
84176: NEG
84177: PUSH
84178: EMPTY
84179: LIST
84180: LIST
84181: PUSH
84182: LD_INT 1
84184: PUSH
84185: LD_INT 0
84187: PUSH
84188: EMPTY
84189: LIST
84190: LIST
84191: PUSH
84192: LD_INT 1
84194: PUSH
84195: LD_INT 1
84197: PUSH
84198: EMPTY
84199: LIST
84200: LIST
84201: PUSH
84202: LD_INT 0
84204: PUSH
84205: LD_INT 1
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: PUSH
84212: LD_INT 1
84214: NEG
84215: PUSH
84216: LD_INT 0
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PUSH
84223: LD_INT 1
84225: NEG
84226: PUSH
84227: LD_INT 1
84229: NEG
84230: PUSH
84231: EMPTY
84232: LIST
84233: LIST
84234: PUSH
84235: LD_INT 1
84237: NEG
84238: PUSH
84239: LD_INT 2
84241: NEG
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: PUSH
84247: LD_INT 0
84249: PUSH
84250: LD_INT 2
84252: NEG
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: PUSH
84258: LD_INT 1
84260: PUSH
84261: LD_INT 1
84263: NEG
84264: PUSH
84265: EMPTY
84266: LIST
84267: LIST
84268: PUSH
84269: LD_INT 2
84271: PUSH
84272: LD_INT 0
84274: PUSH
84275: EMPTY
84276: LIST
84277: LIST
84278: PUSH
84279: LD_INT 2
84281: PUSH
84282: LD_INT 1
84284: PUSH
84285: EMPTY
84286: LIST
84287: LIST
84288: PUSH
84289: LD_INT 2
84291: PUSH
84292: LD_INT 2
84294: PUSH
84295: EMPTY
84296: LIST
84297: LIST
84298: PUSH
84299: LD_INT 1
84301: PUSH
84302: LD_INT 2
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: PUSH
84309: LD_INT 0
84311: PUSH
84312: LD_INT 2
84314: PUSH
84315: EMPTY
84316: LIST
84317: LIST
84318: PUSH
84319: LD_INT 1
84321: NEG
84322: PUSH
84323: LD_INT 1
84325: PUSH
84326: EMPTY
84327: LIST
84328: LIST
84329: PUSH
84330: LD_INT 2
84332: NEG
84333: PUSH
84334: LD_INT 0
84336: PUSH
84337: EMPTY
84338: LIST
84339: LIST
84340: PUSH
84341: LD_INT 2
84343: NEG
84344: PUSH
84345: LD_INT 1
84347: NEG
84348: PUSH
84349: EMPTY
84350: LIST
84351: LIST
84352: PUSH
84353: LD_INT 2
84355: NEG
84356: PUSH
84357: LD_INT 2
84359: NEG
84360: PUSH
84361: EMPTY
84362: LIST
84363: LIST
84364: PUSH
84365: LD_INT 2
84367: PUSH
84368: LD_INT 3
84370: PUSH
84371: EMPTY
84372: LIST
84373: LIST
84374: PUSH
84375: LD_INT 1
84377: PUSH
84378: LD_INT 3
84380: PUSH
84381: EMPTY
84382: LIST
84383: LIST
84384: PUSH
84385: LD_INT 1
84387: NEG
84388: PUSH
84389: LD_INT 2
84391: PUSH
84392: EMPTY
84393: LIST
84394: LIST
84395: PUSH
84396: LD_INT 2
84398: NEG
84399: PUSH
84400: LD_INT 1
84402: PUSH
84403: EMPTY
84404: LIST
84405: LIST
84406: PUSH
84407: EMPTY
84408: LIST
84409: LIST
84410: LIST
84411: LIST
84412: LIST
84413: LIST
84414: LIST
84415: LIST
84416: LIST
84417: LIST
84418: LIST
84419: LIST
84420: LIST
84421: LIST
84422: LIST
84423: LIST
84424: LIST
84425: LIST
84426: LIST
84427: LIST
84428: LIST
84429: LIST
84430: LIST
84431: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84432: LD_ADDR_VAR 0 27
84436: PUSH
84437: LD_INT 0
84439: PUSH
84440: LD_INT 0
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: PUSH
84447: LD_INT 0
84449: PUSH
84450: LD_INT 1
84452: NEG
84453: PUSH
84454: EMPTY
84455: LIST
84456: LIST
84457: PUSH
84458: LD_INT 1
84460: PUSH
84461: LD_INT 0
84463: PUSH
84464: EMPTY
84465: LIST
84466: LIST
84467: PUSH
84468: LD_INT 1
84470: PUSH
84471: LD_INT 1
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: PUSH
84478: LD_INT 0
84480: PUSH
84481: LD_INT 1
84483: PUSH
84484: EMPTY
84485: LIST
84486: LIST
84487: PUSH
84488: LD_INT 1
84490: NEG
84491: PUSH
84492: LD_INT 0
84494: PUSH
84495: EMPTY
84496: LIST
84497: LIST
84498: PUSH
84499: LD_INT 1
84501: NEG
84502: PUSH
84503: LD_INT 1
84505: NEG
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 1
84513: NEG
84514: PUSH
84515: LD_INT 2
84517: NEG
84518: PUSH
84519: EMPTY
84520: LIST
84521: LIST
84522: PUSH
84523: LD_INT 0
84525: PUSH
84526: LD_INT 2
84528: NEG
84529: PUSH
84530: EMPTY
84531: LIST
84532: LIST
84533: PUSH
84534: LD_INT 1
84536: PUSH
84537: LD_INT 1
84539: NEG
84540: PUSH
84541: EMPTY
84542: LIST
84543: LIST
84544: PUSH
84545: LD_INT 2
84547: PUSH
84548: LD_INT 0
84550: PUSH
84551: EMPTY
84552: LIST
84553: LIST
84554: PUSH
84555: LD_INT 2
84557: PUSH
84558: LD_INT 1
84560: PUSH
84561: EMPTY
84562: LIST
84563: LIST
84564: PUSH
84565: LD_INT 2
84567: PUSH
84568: LD_INT 2
84570: PUSH
84571: EMPTY
84572: LIST
84573: LIST
84574: PUSH
84575: LD_INT 1
84577: PUSH
84578: LD_INT 2
84580: PUSH
84581: EMPTY
84582: LIST
84583: LIST
84584: PUSH
84585: LD_INT 0
84587: PUSH
84588: LD_INT 2
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 1
84597: NEG
84598: PUSH
84599: LD_INT 1
84601: PUSH
84602: EMPTY
84603: LIST
84604: LIST
84605: PUSH
84606: LD_INT 2
84608: NEG
84609: PUSH
84610: LD_INT 0
84612: PUSH
84613: EMPTY
84614: LIST
84615: LIST
84616: PUSH
84617: LD_INT 2
84619: NEG
84620: PUSH
84621: LD_INT 1
84623: NEG
84624: PUSH
84625: EMPTY
84626: LIST
84627: LIST
84628: PUSH
84629: LD_INT 2
84631: NEG
84632: PUSH
84633: LD_INT 2
84635: NEG
84636: PUSH
84637: EMPTY
84638: LIST
84639: LIST
84640: PUSH
84641: LD_INT 1
84643: NEG
84644: PUSH
84645: LD_INT 2
84647: PUSH
84648: EMPTY
84649: LIST
84650: LIST
84651: PUSH
84652: LD_INT 2
84654: NEG
84655: PUSH
84656: LD_INT 1
84658: PUSH
84659: EMPTY
84660: LIST
84661: LIST
84662: PUSH
84663: LD_INT 3
84665: NEG
84666: PUSH
84667: LD_INT 1
84669: NEG
84670: PUSH
84671: EMPTY
84672: LIST
84673: LIST
84674: PUSH
84675: LD_INT 3
84677: NEG
84678: PUSH
84679: LD_INT 2
84681: NEG
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: LIST
84691: LIST
84692: LIST
84693: LIST
84694: LIST
84695: LIST
84696: LIST
84697: LIST
84698: LIST
84699: LIST
84700: LIST
84701: LIST
84702: LIST
84703: LIST
84704: LIST
84705: LIST
84706: LIST
84707: LIST
84708: LIST
84709: LIST
84710: LIST
84711: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84712: LD_ADDR_VAR 0 28
84716: PUSH
84717: LD_INT 0
84719: PUSH
84720: LD_INT 0
84722: PUSH
84723: EMPTY
84724: LIST
84725: LIST
84726: PUSH
84727: LD_INT 0
84729: PUSH
84730: LD_INT 1
84732: NEG
84733: PUSH
84734: EMPTY
84735: LIST
84736: LIST
84737: PUSH
84738: LD_INT 1
84740: PUSH
84741: LD_INT 0
84743: PUSH
84744: EMPTY
84745: LIST
84746: LIST
84747: PUSH
84748: LD_INT 1
84750: PUSH
84751: LD_INT 1
84753: PUSH
84754: EMPTY
84755: LIST
84756: LIST
84757: PUSH
84758: LD_INT 0
84760: PUSH
84761: LD_INT 1
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: PUSH
84768: LD_INT 1
84770: NEG
84771: PUSH
84772: LD_INT 0
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 1
84781: NEG
84782: PUSH
84783: LD_INT 1
84785: NEG
84786: PUSH
84787: EMPTY
84788: LIST
84789: LIST
84790: PUSH
84791: LD_INT 1
84793: NEG
84794: PUSH
84795: LD_INT 2
84797: NEG
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: PUSH
84803: LD_INT 0
84805: PUSH
84806: LD_INT 2
84808: NEG
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 1
84816: PUSH
84817: LD_INT 1
84819: NEG
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 2
84827: PUSH
84828: LD_INT 0
84830: PUSH
84831: EMPTY
84832: LIST
84833: LIST
84834: PUSH
84835: LD_INT 2
84837: PUSH
84838: LD_INT 1
84840: PUSH
84841: EMPTY
84842: LIST
84843: LIST
84844: PUSH
84845: LD_INT 2
84847: PUSH
84848: LD_INT 2
84850: PUSH
84851: EMPTY
84852: LIST
84853: LIST
84854: PUSH
84855: LD_INT 1
84857: PUSH
84858: LD_INT 2
84860: PUSH
84861: EMPTY
84862: LIST
84863: LIST
84864: PUSH
84865: LD_INT 0
84867: PUSH
84868: LD_INT 2
84870: PUSH
84871: EMPTY
84872: LIST
84873: LIST
84874: PUSH
84875: LD_INT 1
84877: NEG
84878: PUSH
84879: LD_INT 1
84881: PUSH
84882: EMPTY
84883: LIST
84884: LIST
84885: PUSH
84886: LD_INT 2
84888: NEG
84889: PUSH
84890: LD_INT 0
84892: PUSH
84893: EMPTY
84894: LIST
84895: LIST
84896: PUSH
84897: LD_INT 2
84899: NEG
84900: PUSH
84901: LD_INT 1
84903: NEG
84904: PUSH
84905: EMPTY
84906: LIST
84907: LIST
84908: PUSH
84909: LD_INT 2
84911: NEG
84912: PUSH
84913: LD_INT 2
84915: NEG
84916: PUSH
84917: EMPTY
84918: LIST
84919: LIST
84920: PUSH
84921: LD_INT 2
84923: NEG
84924: PUSH
84925: LD_INT 3
84927: NEG
84928: PUSH
84929: EMPTY
84930: LIST
84931: LIST
84932: PUSH
84933: LD_INT 1
84935: NEG
84936: PUSH
84937: LD_INT 3
84939: NEG
84940: PUSH
84941: EMPTY
84942: LIST
84943: LIST
84944: PUSH
84945: LD_INT 3
84947: NEG
84948: PUSH
84949: LD_INT 1
84951: NEG
84952: PUSH
84953: EMPTY
84954: LIST
84955: LIST
84956: PUSH
84957: LD_INT 3
84959: NEG
84960: PUSH
84961: LD_INT 2
84963: NEG
84964: PUSH
84965: EMPTY
84966: LIST
84967: LIST
84968: PUSH
84969: EMPTY
84970: LIST
84971: LIST
84972: LIST
84973: LIST
84974: LIST
84975: LIST
84976: LIST
84977: LIST
84978: LIST
84979: LIST
84980: LIST
84981: LIST
84982: LIST
84983: LIST
84984: LIST
84985: LIST
84986: LIST
84987: LIST
84988: LIST
84989: LIST
84990: LIST
84991: LIST
84992: LIST
84993: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84994: LD_ADDR_VAR 0 29
84998: PUSH
84999: LD_INT 0
85001: PUSH
85002: LD_INT 0
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: PUSH
85009: LD_INT 0
85011: PUSH
85012: LD_INT 1
85014: NEG
85015: PUSH
85016: EMPTY
85017: LIST
85018: LIST
85019: PUSH
85020: LD_INT 1
85022: PUSH
85023: LD_INT 0
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_INT 1
85032: PUSH
85033: LD_INT 1
85035: PUSH
85036: EMPTY
85037: LIST
85038: LIST
85039: PUSH
85040: LD_INT 0
85042: PUSH
85043: LD_INT 1
85045: PUSH
85046: EMPTY
85047: LIST
85048: LIST
85049: PUSH
85050: LD_INT 1
85052: NEG
85053: PUSH
85054: LD_INT 0
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: PUSH
85061: LD_INT 1
85063: NEG
85064: PUSH
85065: LD_INT 1
85067: NEG
85068: PUSH
85069: EMPTY
85070: LIST
85071: LIST
85072: PUSH
85073: LD_INT 1
85075: NEG
85076: PUSH
85077: LD_INT 2
85079: NEG
85080: PUSH
85081: EMPTY
85082: LIST
85083: LIST
85084: PUSH
85085: LD_INT 0
85087: PUSH
85088: LD_INT 2
85090: NEG
85091: PUSH
85092: EMPTY
85093: LIST
85094: LIST
85095: PUSH
85096: LD_INT 1
85098: PUSH
85099: LD_INT 1
85101: NEG
85102: PUSH
85103: EMPTY
85104: LIST
85105: LIST
85106: PUSH
85107: LD_INT 2
85109: PUSH
85110: LD_INT 0
85112: PUSH
85113: EMPTY
85114: LIST
85115: LIST
85116: PUSH
85117: LD_INT 2
85119: PUSH
85120: LD_INT 1
85122: PUSH
85123: EMPTY
85124: LIST
85125: LIST
85126: PUSH
85127: LD_INT 1
85129: PUSH
85130: LD_INT 2
85132: PUSH
85133: EMPTY
85134: LIST
85135: LIST
85136: PUSH
85137: LD_INT 0
85139: PUSH
85140: LD_INT 2
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: PUSH
85147: LD_INT 1
85149: NEG
85150: PUSH
85151: LD_INT 1
85153: PUSH
85154: EMPTY
85155: LIST
85156: LIST
85157: PUSH
85158: LD_INT 2
85160: NEG
85161: PUSH
85162: LD_INT 1
85164: NEG
85165: PUSH
85166: EMPTY
85167: LIST
85168: LIST
85169: PUSH
85170: LD_INT 2
85172: NEG
85173: PUSH
85174: LD_INT 2
85176: NEG
85177: PUSH
85178: EMPTY
85179: LIST
85180: LIST
85181: PUSH
85182: LD_INT 2
85184: NEG
85185: PUSH
85186: LD_INT 3
85188: NEG
85189: PUSH
85190: EMPTY
85191: LIST
85192: LIST
85193: PUSH
85194: LD_INT 2
85196: PUSH
85197: LD_INT 1
85199: NEG
85200: PUSH
85201: EMPTY
85202: LIST
85203: LIST
85204: PUSH
85205: LD_INT 3
85207: PUSH
85208: LD_INT 1
85210: PUSH
85211: EMPTY
85212: LIST
85213: LIST
85214: PUSH
85215: LD_INT 1
85217: PUSH
85218: LD_INT 3
85220: PUSH
85221: EMPTY
85222: LIST
85223: LIST
85224: PUSH
85225: LD_INT 1
85227: NEG
85228: PUSH
85229: LD_INT 2
85231: PUSH
85232: EMPTY
85233: LIST
85234: LIST
85235: PUSH
85236: LD_INT 3
85238: NEG
85239: PUSH
85240: LD_INT 2
85242: NEG
85243: PUSH
85244: EMPTY
85245: LIST
85246: LIST
85247: PUSH
85248: EMPTY
85249: LIST
85250: LIST
85251: LIST
85252: LIST
85253: LIST
85254: LIST
85255: LIST
85256: LIST
85257: LIST
85258: LIST
85259: LIST
85260: LIST
85261: LIST
85262: LIST
85263: LIST
85264: LIST
85265: LIST
85266: LIST
85267: LIST
85268: LIST
85269: LIST
85270: LIST
85271: LIST
85272: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85273: LD_ADDR_VAR 0 30
85277: PUSH
85278: LD_INT 0
85280: PUSH
85281: LD_INT 0
85283: PUSH
85284: EMPTY
85285: LIST
85286: LIST
85287: PUSH
85288: LD_INT 0
85290: PUSH
85291: LD_INT 1
85293: NEG
85294: PUSH
85295: EMPTY
85296: LIST
85297: LIST
85298: PUSH
85299: LD_INT 1
85301: PUSH
85302: LD_INT 0
85304: PUSH
85305: EMPTY
85306: LIST
85307: LIST
85308: PUSH
85309: LD_INT 1
85311: PUSH
85312: LD_INT 1
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 0
85321: PUSH
85322: LD_INT 1
85324: PUSH
85325: EMPTY
85326: LIST
85327: LIST
85328: PUSH
85329: LD_INT 1
85331: NEG
85332: PUSH
85333: LD_INT 0
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 1
85342: NEG
85343: PUSH
85344: LD_INT 1
85346: NEG
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: PUSH
85352: LD_INT 1
85354: NEG
85355: PUSH
85356: LD_INT 2
85358: NEG
85359: PUSH
85360: EMPTY
85361: LIST
85362: LIST
85363: PUSH
85364: LD_INT 0
85366: PUSH
85367: LD_INT 2
85369: NEG
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: PUSH
85375: LD_INT 1
85377: PUSH
85378: LD_INT 1
85380: NEG
85381: PUSH
85382: EMPTY
85383: LIST
85384: LIST
85385: PUSH
85386: LD_INT 2
85388: PUSH
85389: LD_INT 0
85391: PUSH
85392: EMPTY
85393: LIST
85394: LIST
85395: PUSH
85396: LD_INT 2
85398: PUSH
85399: LD_INT 1
85401: PUSH
85402: EMPTY
85403: LIST
85404: LIST
85405: PUSH
85406: LD_INT 2
85408: PUSH
85409: LD_INT 2
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PUSH
85416: LD_INT 1
85418: PUSH
85419: LD_INT 2
85421: PUSH
85422: EMPTY
85423: LIST
85424: LIST
85425: PUSH
85426: LD_INT 1
85428: NEG
85429: PUSH
85430: LD_INT 1
85432: PUSH
85433: EMPTY
85434: LIST
85435: LIST
85436: PUSH
85437: LD_INT 2
85439: NEG
85440: PUSH
85441: LD_INT 0
85443: PUSH
85444: EMPTY
85445: LIST
85446: LIST
85447: PUSH
85448: LD_INT 2
85450: NEG
85451: PUSH
85452: LD_INT 1
85454: NEG
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 1
85462: NEG
85463: PUSH
85464: LD_INT 3
85466: NEG
85467: PUSH
85468: EMPTY
85469: LIST
85470: LIST
85471: PUSH
85472: LD_INT 1
85474: PUSH
85475: LD_INT 2
85477: NEG
85478: PUSH
85479: EMPTY
85480: LIST
85481: LIST
85482: PUSH
85483: LD_INT 3
85485: PUSH
85486: LD_INT 2
85488: PUSH
85489: EMPTY
85490: LIST
85491: LIST
85492: PUSH
85493: LD_INT 2
85495: PUSH
85496: LD_INT 3
85498: PUSH
85499: EMPTY
85500: LIST
85501: LIST
85502: PUSH
85503: LD_INT 2
85505: NEG
85506: PUSH
85507: LD_INT 1
85509: PUSH
85510: EMPTY
85511: LIST
85512: LIST
85513: PUSH
85514: LD_INT 3
85516: NEG
85517: PUSH
85518: LD_INT 1
85520: NEG
85521: PUSH
85522: EMPTY
85523: LIST
85524: LIST
85525: PUSH
85526: EMPTY
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85551: LD_ADDR_VAR 0 31
85555: PUSH
85556: LD_INT 0
85558: PUSH
85559: LD_INT 0
85561: PUSH
85562: EMPTY
85563: LIST
85564: LIST
85565: PUSH
85566: LD_INT 0
85568: PUSH
85569: LD_INT 1
85571: NEG
85572: PUSH
85573: EMPTY
85574: LIST
85575: LIST
85576: PUSH
85577: LD_INT 1
85579: PUSH
85580: LD_INT 0
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: PUSH
85587: LD_INT 1
85589: PUSH
85590: LD_INT 1
85592: PUSH
85593: EMPTY
85594: LIST
85595: LIST
85596: PUSH
85597: LD_INT 0
85599: PUSH
85600: LD_INT 1
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: PUSH
85607: LD_INT 1
85609: NEG
85610: PUSH
85611: LD_INT 0
85613: PUSH
85614: EMPTY
85615: LIST
85616: LIST
85617: PUSH
85618: LD_INT 1
85620: NEG
85621: PUSH
85622: LD_INT 1
85624: NEG
85625: PUSH
85626: EMPTY
85627: LIST
85628: LIST
85629: PUSH
85630: LD_INT 1
85632: NEG
85633: PUSH
85634: LD_INT 2
85636: NEG
85637: PUSH
85638: EMPTY
85639: LIST
85640: LIST
85641: PUSH
85642: LD_INT 1
85644: PUSH
85645: LD_INT 1
85647: NEG
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: PUSH
85653: LD_INT 2
85655: PUSH
85656: LD_INT 0
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: PUSH
85663: LD_INT 2
85665: PUSH
85666: LD_INT 1
85668: PUSH
85669: EMPTY
85670: LIST
85671: LIST
85672: PUSH
85673: LD_INT 2
85675: PUSH
85676: LD_INT 2
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 1
85685: PUSH
85686: LD_INT 2
85688: PUSH
85689: EMPTY
85690: LIST
85691: LIST
85692: PUSH
85693: LD_INT 0
85695: PUSH
85696: LD_INT 2
85698: PUSH
85699: EMPTY
85700: LIST
85701: LIST
85702: PUSH
85703: LD_INT 1
85705: NEG
85706: PUSH
85707: LD_INT 1
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: PUSH
85714: LD_INT 2
85716: NEG
85717: PUSH
85718: LD_INT 1
85720: NEG
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 2
85728: NEG
85729: PUSH
85730: LD_INT 2
85732: NEG
85733: PUSH
85734: EMPTY
85735: LIST
85736: LIST
85737: PUSH
85738: LD_INT 2
85740: NEG
85741: PUSH
85742: LD_INT 3
85744: NEG
85745: PUSH
85746: EMPTY
85747: LIST
85748: LIST
85749: PUSH
85750: LD_INT 2
85752: PUSH
85753: LD_INT 1
85755: NEG
85756: PUSH
85757: EMPTY
85758: LIST
85759: LIST
85760: PUSH
85761: LD_INT 3
85763: PUSH
85764: LD_INT 1
85766: PUSH
85767: EMPTY
85768: LIST
85769: LIST
85770: PUSH
85771: LD_INT 1
85773: PUSH
85774: LD_INT 3
85776: PUSH
85777: EMPTY
85778: LIST
85779: LIST
85780: PUSH
85781: LD_INT 1
85783: NEG
85784: PUSH
85785: LD_INT 2
85787: PUSH
85788: EMPTY
85789: LIST
85790: LIST
85791: PUSH
85792: LD_INT 3
85794: NEG
85795: PUSH
85796: LD_INT 2
85798: NEG
85799: PUSH
85800: EMPTY
85801: LIST
85802: LIST
85803: PUSH
85804: EMPTY
85805: LIST
85806: LIST
85807: LIST
85808: LIST
85809: LIST
85810: LIST
85811: LIST
85812: LIST
85813: LIST
85814: LIST
85815: LIST
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: LIST
85823: LIST
85824: LIST
85825: LIST
85826: LIST
85827: LIST
85828: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85829: LD_ADDR_VAR 0 32
85833: PUSH
85834: LD_INT 0
85836: PUSH
85837: LD_INT 0
85839: PUSH
85840: EMPTY
85841: LIST
85842: LIST
85843: PUSH
85844: LD_INT 0
85846: PUSH
85847: LD_INT 1
85849: NEG
85850: PUSH
85851: EMPTY
85852: LIST
85853: LIST
85854: PUSH
85855: LD_INT 1
85857: PUSH
85858: LD_INT 0
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: LD_INT 1
85867: PUSH
85868: LD_INT 1
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PUSH
85875: LD_INT 0
85877: PUSH
85878: LD_INT 1
85880: PUSH
85881: EMPTY
85882: LIST
85883: LIST
85884: PUSH
85885: LD_INT 1
85887: NEG
85888: PUSH
85889: LD_INT 0
85891: PUSH
85892: EMPTY
85893: LIST
85894: LIST
85895: PUSH
85896: LD_INT 1
85898: NEG
85899: PUSH
85900: LD_INT 1
85902: NEG
85903: PUSH
85904: EMPTY
85905: LIST
85906: LIST
85907: PUSH
85908: LD_INT 1
85910: NEG
85911: PUSH
85912: LD_INT 2
85914: NEG
85915: PUSH
85916: EMPTY
85917: LIST
85918: LIST
85919: PUSH
85920: LD_INT 0
85922: PUSH
85923: LD_INT 2
85925: NEG
85926: PUSH
85927: EMPTY
85928: LIST
85929: LIST
85930: PUSH
85931: LD_INT 1
85933: PUSH
85934: LD_INT 1
85936: NEG
85937: PUSH
85938: EMPTY
85939: LIST
85940: LIST
85941: PUSH
85942: LD_INT 2
85944: PUSH
85945: LD_INT 1
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: PUSH
85952: LD_INT 2
85954: PUSH
85955: LD_INT 2
85957: PUSH
85958: EMPTY
85959: LIST
85960: LIST
85961: PUSH
85962: LD_INT 1
85964: PUSH
85965: LD_INT 2
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: PUSH
85972: LD_INT 0
85974: PUSH
85975: LD_INT 2
85977: PUSH
85978: EMPTY
85979: LIST
85980: LIST
85981: PUSH
85982: LD_INT 1
85984: NEG
85985: PUSH
85986: LD_INT 1
85988: PUSH
85989: EMPTY
85990: LIST
85991: LIST
85992: PUSH
85993: LD_INT 2
85995: NEG
85996: PUSH
85997: LD_INT 0
85999: PUSH
86000: EMPTY
86001: LIST
86002: LIST
86003: PUSH
86004: LD_INT 2
86006: NEG
86007: PUSH
86008: LD_INT 1
86010: NEG
86011: PUSH
86012: EMPTY
86013: LIST
86014: LIST
86015: PUSH
86016: LD_INT 1
86018: NEG
86019: PUSH
86020: LD_INT 3
86022: NEG
86023: PUSH
86024: EMPTY
86025: LIST
86026: LIST
86027: PUSH
86028: LD_INT 1
86030: PUSH
86031: LD_INT 2
86033: NEG
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PUSH
86039: LD_INT 3
86041: PUSH
86042: LD_INT 2
86044: PUSH
86045: EMPTY
86046: LIST
86047: LIST
86048: PUSH
86049: LD_INT 2
86051: PUSH
86052: LD_INT 3
86054: PUSH
86055: EMPTY
86056: LIST
86057: LIST
86058: PUSH
86059: LD_INT 2
86061: NEG
86062: PUSH
86063: LD_INT 1
86065: PUSH
86066: EMPTY
86067: LIST
86068: LIST
86069: PUSH
86070: LD_INT 3
86072: NEG
86073: PUSH
86074: LD_INT 1
86076: NEG
86077: PUSH
86078: EMPTY
86079: LIST
86080: LIST
86081: PUSH
86082: EMPTY
86083: LIST
86084: LIST
86085: LIST
86086: LIST
86087: LIST
86088: LIST
86089: LIST
86090: LIST
86091: LIST
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: LIST
86098: LIST
86099: LIST
86100: LIST
86101: LIST
86102: LIST
86103: LIST
86104: LIST
86105: LIST
86106: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
86107: LD_ADDR_VAR 0 33
86111: PUSH
86112: LD_INT 0
86114: PUSH
86115: LD_INT 0
86117: PUSH
86118: EMPTY
86119: LIST
86120: LIST
86121: PUSH
86122: LD_INT 0
86124: PUSH
86125: LD_INT 1
86127: NEG
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 1
86135: PUSH
86136: LD_INT 0
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 1
86145: PUSH
86146: LD_INT 1
86148: PUSH
86149: EMPTY
86150: LIST
86151: LIST
86152: PUSH
86153: LD_INT 0
86155: PUSH
86156: LD_INT 1
86158: PUSH
86159: EMPTY
86160: LIST
86161: LIST
86162: PUSH
86163: LD_INT 1
86165: NEG
86166: PUSH
86167: LD_INT 0
86169: PUSH
86170: EMPTY
86171: LIST
86172: LIST
86173: PUSH
86174: LD_INT 1
86176: NEG
86177: PUSH
86178: LD_INT 1
86180: NEG
86181: PUSH
86182: EMPTY
86183: LIST
86184: LIST
86185: PUSH
86186: LD_INT 1
86188: NEG
86189: PUSH
86190: LD_INT 2
86192: NEG
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 1
86200: PUSH
86201: LD_INT 1
86203: NEG
86204: PUSH
86205: EMPTY
86206: LIST
86207: LIST
86208: PUSH
86209: LD_INT 2
86211: PUSH
86212: LD_INT 0
86214: PUSH
86215: EMPTY
86216: LIST
86217: LIST
86218: PUSH
86219: LD_INT 2
86221: PUSH
86222: LD_INT 1
86224: PUSH
86225: EMPTY
86226: LIST
86227: LIST
86228: PUSH
86229: LD_INT 1
86231: PUSH
86232: LD_INT 2
86234: PUSH
86235: EMPTY
86236: LIST
86237: LIST
86238: PUSH
86239: LD_INT 0
86241: PUSH
86242: LD_INT 2
86244: PUSH
86245: EMPTY
86246: LIST
86247: LIST
86248: PUSH
86249: LD_INT 1
86251: NEG
86252: PUSH
86253: LD_INT 1
86255: PUSH
86256: EMPTY
86257: LIST
86258: LIST
86259: PUSH
86260: LD_INT 2
86262: NEG
86263: PUSH
86264: LD_INT 0
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: PUSH
86271: LD_INT 2
86273: NEG
86274: PUSH
86275: LD_INT 1
86277: NEG
86278: PUSH
86279: EMPTY
86280: LIST
86281: LIST
86282: PUSH
86283: LD_INT 2
86285: NEG
86286: PUSH
86287: LD_INT 2
86289: NEG
86290: PUSH
86291: EMPTY
86292: LIST
86293: LIST
86294: PUSH
86295: LD_INT 2
86297: NEG
86298: PUSH
86299: LD_INT 3
86301: NEG
86302: PUSH
86303: EMPTY
86304: LIST
86305: LIST
86306: PUSH
86307: LD_INT 2
86309: PUSH
86310: LD_INT 1
86312: NEG
86313: PUSH
86314: EMPTY
86315: LIST
86316: LIST
86317: PUSH
86318: LD_INT 3
86320: PUSH
86321: LD_INT 1
86323: PUSH
86324: EMPTY
86325: LIST
86326: LIST
86327: PUSH
86328: LD_INT 1
86330: PUSH
86331: LD_INT 3
86333: PUSH
86334: EMPTY
86335: LIST
86336: LIST
86337: PUSH
86338: LD_INT 1
86340: NEG
86341: PUSH
86342: LD_INT 2
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: PUSH
86349: LD_INT 3
86351: NEG
86352: PUSH
86353: LD_INT 2
86355: NEG
86356: PUSH
86357: EMPTY
86358: LIST
86359: LIST
86360: PUSH
86361: EMPTY
86362: LIST
86363: LIST
86364: LIST
86365: LIST
86366: LIST
86367: LIST
86368: LIST
86369: LIST
86370: LIST
86371: LIST
86372: LIST
86373: LIST
86374: LIST
86375: LIST
86376: LIST
86377: LIST
86378: LIST
86379: LIST
86380: LIST
86381: LIST
86382: LIST
86383: LIST
86384: LIST
86385: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
86386: LD_ADDR_VAR 0 34
86390: PUSH
86391: LD_INT 0
86393: PUSH
86394: LD_INT 0
86396: PUSH
86397: EMPTY
86398: LIST
86399: LIST
86400: PUSH
86401: LD_INT 0
86403: PUSH
86404: LD_INT 1
86406: NEG
86407: PUSH
86408: EMPTY
86409: LIST
86410: LIST
86411: PUSH
86412: LD_INT 1
86414: PUSH
86415: LD_INT 0
86417: PUSH
86418: EMPTY
86419: LIST
86420: LIST
86421: PUSH
86422: LD_INT 1
86424: PUSH
86425: LD_INT 1
86427: PUSH
86428: EMPTY
86429: LIST
86430: LIST
86431: PUSH
86432: LD_INT 0
86434: PUSH
86435: LD_INT 1
86437: PUSH
86438: EMPTY
86439: LIST
86440: LIST
86441: PUSH
86442: LD_INT 1
86444: NEG
86445: PUSH
86446: LD_INT 0
86448: PUSH
86449: EMPTY
86450: LIST
86451: LIST
86452: PUSH
86453: LD_INT 1
86455: NEG
86456: PUSH
86457: LD_INT 1
86459: NEG
86460: PUSH
86461: EMPTY
86462: LIST
86463: LIST
86464: PUSH
86465: LD_INT 1
86467: NEG
86468: PUSH
86469: LD_INT 2
86471: NEG
86472: PUSH
86473: EMPTY
86474: LIST
86475: LIST
86476: PUSH
86477: LD_INT 0
86479: PUSH
86480: LD_INT 2
86482: NEG
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 1
86490: PUSH
86491: LD_INT 1
86493: NEG
86494: PUSH
86495: EMPTY
86496: LIST
86497: LIST
86498: PUSH
86499: LD_INT 2
86501: PUSH
86502: LD_INT 1
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 2
86511: PUSH
86512: LD_INT 2
86514: PUSH
86515: EMPTY
86516: LIST
86517: LIST
86518: PUSH
86519: LD_INT 1
86521: PUSH
86522: LD_INT 2
86524: PUSH
86525: EMPTY
86526: LIST
86527: LIST
86528: PUSH
86529: LD_INT 1
86531: NEG
86532: PUSH
86533: LD_INT 1
86535: PUSH
86536: EMPTY
86537: LIST
86538: LIST
86539: PUSH
86540: LD_INT 2
86542: NEG
86543: PUSH
86544: LD_INT 0
86546: PUSH
86547: EMPTY
86548: LIST
86549: LIST
86550: PUSH
86551: LD_INT 2
86553: NEG
86554: PUSH
86555: LD_INT 1
86557: NEG
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: PUSH
86563: LD_INT 2
86565: NEG
86566: PUSH
86567: LD_INT 2
86569: NEG
86570: PUSH
86571: EMPTY
86572: LIST
86573: LIST
86574: PUSH
86575: LD_INT 1
86577: NEG
86578: PUSH
86579: LD_INT 3
86581: NEG
86582: PUSH
86583: EMPTY
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 1
86589: PUSH
86590: LD_INT 2
86592: NEG
86593: PUSH
86594: EMPTY
86595: LIST
86596: LIST
86597: PUSH
86598: LD_INT 3
86600: PUSH
86601: LD_INT 2
86603: PUSH
86604: EMPTY
86605: LIST
86606: LIST
86607: PUSH
86608: LD_INT 2
86610: PUSH
86611: LD_INT 3
86613: PUSH
86614: EMPTY
86615: LIST
86616: LIST
86617: PUSH
86618: LD_INT 2
86620: NEG
86621: PUSH
86622: LD_INT 1
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: LD_INT 3
86631: NEG
86632: PUSH
86633: LD_INT 1
86635: NEG
86636: PUSH
86637: EMPTY
86638: LIST
86639: LIST
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: LIST
86645: LIST
86646: LIST
86647: LIST
86648: LIST
86649: LIST
86650: LIST
86651: LIST
86652: LIST
86653: LIST
86654: LIST
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86666: LD_ADDR_VAR 0 35
86670: PUSH
86671: LD_INT 0
86673: PUSH
86674: LD_INT 0
86676: PUSH
86677: EMPTY
86678: LIST
86679: LIST
86680: PUSH
86681: LD_INT 0
86683: PUSH
86684: LD_INT 1
86686: NEG
86687: PUSH
86688: EMPTY
86689: LIST
86690: LIST
86691: PUSH
86692: LD_INT 1
86694: PUSH
86695: LD_INT 0
86697: PUSH
86698: EMPTY
86699: LIST
86700: LIST
86701: PUSH
86702: LD_INT 1
86704: PUSH
86705: LD_INT 1
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: PUSH
86712: LD_INT 0
86714: PUSH
86715: LD_INT 1
86717: PUSH
86718: EMPTY
86719: LIST
86720: LIST
86721: PUSH
86722: LD_INT 1
86724: NEG
86725: PUSH
86726: LD_INT 0
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 1
86735: NEG
86736: PUSH
86737: LD_INT 1
86739: NEG
86740: PUSH
86741: EMPTY
86742: LIST
86743: LIST
86744: PUSH
86745: LD_INT 2
86747: PUSH
86748: LD_INT 1
86750: PUSH
86751: EMPTY
86752: LIST
86753: LIST
86754: PUSH
86755: LD_INT 2
86757: NEG
86758: PUSH
86759: LD_INT 1
86761: NEG
86762: PUSH
86763: EMPTY
86764: LIST
86765: LIST
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86778: LD_ADDR_VAR 0 36
86782: PUSH
86783: LD_INT 0
86785: PUSH
86786: LD_INT 0
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: PUSH
86793: LD_INT 0
86795: PUSH
86796: LD_INT 1
86798: NEG
86799: PUSH
86800: EMPTY
86801: LIST
86802: LIST
86803: PUSH
86804: LD_INT 1
86806: PUSH
86807: LD_INT 0
86809: PUSH
86810: EMPTY
86811: LIST
86812: LIST
86813: PUSH
86814: LD_INT 1
86816: PUSH
86817: LD_INT 1
86819: PUSH
86820: EMPTY
86821: LIST
86822: LIST
86823: PUSH
86824: LD_INT 0
86826: PUSH
86827: LD_INT 1
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: PUSH
86834: LD_INT 1
86836: NEG
86837: PUSH
86838: LD_INT 0
86840: PUSH
86841: EMPTY
86842: LIST
86843: LIST
86844: PUSH
86845: LD_INT 1
86847: NEG
86848: PUSH
86849: LD_INT 1
86851: NEG
86852: PUSH
86853: EMPTY
86854: LIST
86855: LIST
86856: PUSH
86857: LD_INT 1
86859: NEG
86860: PUSH
86861: LD_INT 2
86863: NEG
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: PUSH
86869: LD_INT 1
86871: PUSH
86872: LD_INT 2
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: EMPTY
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: LIST
86885: LIST
86886: LIST
86887: LIST
86888: LIST
86889: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86890: LD_ADDR_VAR 0 37
86894: PUSH
86895: LD_INT 0
86897: PUSH
86898: LD_INT 0
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: PUSH
86905: LD_INT 0
86907: PUSH
86908: LD_INT 1
86910: NEG
86911: PUSH
86912: EMPTY
86913: LIST
86914: LIST
86915: PUSH
86916: LD_INT 1
86918: PUSH
86919: LD_INT 0
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: PUSH
86926: LD_INT 1
86928: PUSH
86929: LD_INT 1
86931: PUSH
86932: EMPTY
86933: LIST
86934: LIST
86935: PUSH
86936: LD_INT 0
86938: PUSH
86939: LD_INT 1
86941: PUSH
86942: EMPTY
86943: LIST
86944: LIST
86945: PUSH
86946: LD_INT 1
86948: NEG
86949: PUSH
86950: LD_INT 0
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 1
86959: NEG
86960: PUSH
86961: LD_INT 1
86963: NEG
86964: PUSH
86965: EMPTY
86966: LIST
86967: LIST
86968: PUSH
86969: LD_INT 1
86971: PUSH
86972: LD_INT 1
86974: NEG
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 1
86982: NEG
86983: PUSH
86984: LD_INT 1
86986: PUSH
86987: EMPTY
86988: LIST
86989: LIST
86990: PUSH
86991: EMPTY
86992: LIST
86993: LIST
86994: LIST
86995: LIST
86996: LIST
86997: LIST
86998: LIST
86999: LIST
87000: LIST
87001: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
87002: LD_ADDR_VAR 0 38
87006: PUSH
87007: LD_INT 0
87009: PUSH
87010: LD_INT 0
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: PUSH
87017: LD_INT 0
87019: PUSH
87020: LD_INT 1
87022: NEG
87023: PUSH
87024: EMPTY
87025: LIST
87026: LIST
87027: PUSH
87028: LD_INT 1
87030: PUSH
87031: LD_INT 0
87033: PUSH
87034: EMPTY
87035: LIST
87036: LIST
87037: PUSH
87038: LD_INT 1
87040: PUSH
87041: LD_INT 1
87043: PUSH
87044: EMPTY
87045: LIST
87046: LIST
87047: PUSH
87048: LD_INT 0
87050: PUSH
87051: LD_INT 1
87053: PUSH
87054: EMPTY
87055: LIST
87056: LIST
87057: PUSH
87058: LD_INT 1
87060: NEG
87061: PUSH
87062: LD_INT 0
87064: PUSH
87065: EMPTY
87066: LIST
87067: LIST
87068: PUSH
87069: LD_INT 1
87071: NEG
87072: PUSH
87073: LD_INT 1
87075: NEG
87076: PUSH
87077: EMPTY
87078: LIST
87079: LIST
87080: PUSH
87081: LD_INT 2
87083: PUSH
87084: LD_INT 1
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_INT 2
87093: NEG
87094: PUSH
87095: LD_INT 1
87097: NEG
87098: PUSH
87099: EMPTY
87100: LIST
87101: LIST
87102: PUSH
87103: EMPTY
87104: LIST
87105: LIST
87106: LIST
87107: LIST
87108: LIST
87109: LIST
87110: LIST
87111: LIST
87112: LIST
87113: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
87114: LD_ADDR_VAR 0 39
87118: PUSH
87119: LD_INT 0
87121: PUSH
87122: LD_INT 0
87124: PUSH
87125: EMPTY
87126: LIST
87127: LIST
87128: PUSH
87129: LD_INT 0
87131: PUSH
87132: LD_INT 1
87134: NEG
87135: PUSH
87136: EMPTY
87137: LIST
87138: LIST
87139: PUSH
87140: LD_INT 1
87142: PUSH
87143: LD_INT 0
87145: PUSH
87146: EMPTY
87147: LIST
87148: LIST
87149: PUSH
87150: LD_INT 1
87152: PUSH
87153: LD_INT 1
87155: PUSH
87156: EMPTY
87157: LIST
87158: LIST
87159: PUSH
87160: LD_INT 0
87162: PUSH
87163: LD_INT 1
87165: PUSH
87166: EMPTY
87167: LIST
87168: LIST
87169: PUSH
87170: LD_INT 1
87172: NEG
87173: PUSH
87174: LD_INT 0
87176: PUSH
87177: EMPTY
87178: LIST
87179: LIST
87180: PUSH
87181: LD_INT 1
87183: NEG
87184: PUSH
87185: LD_INT 1
87187: NEG
87188: PUSH
87189: EMPTY
87190: LIST
87191: LIST
87192: PUSH
87193: LD_INT 1
87195: NEG
87196: PUSH
87197: LD_INT 2
87199: NEG
87200: PUSH
87201: EMPTY
87202: LIST
87203: LIST
87204: PUSH
87205: LD_INT 1
87207: PUSH
87208: LD_INT 2
87210: PUSH
87211: EMPTY
87212: LIST
87213: LIST
87214: PUSH
87215: EMPTY
87216: LIST
87217: LIST
87218: LIST
87219: LIST
87220: LIST
87221: LIST
87222: LIST
87223: LIST
87224: LIST
87225: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
87226: LD_ADDR_VAR 0 40
87230: PUSH
87231: LD_INT 0
87233: PUSH
87234: LD_INT 0
87236: PUSH
87237: EMPTY
87238: LIST
87239: LIST
87240: PUSH
87241: LD_INT 0
87243: PUSH
87244: LD_INT 1
87246: NEG
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 1
87254: PUSH
87255: LD_INT 0
87257: PUSH
87258: EMPTY
87259: LIST
87260: LIST
87261: PUSH
87262: LD_INT 1
87264: PUSH
87265: LD_INT 1
87267: PUSH
87268: EMPTY
87269: LIST
87270: LIST
87271: PUSH
87272: LD_INT 0
87274: PUSH
87275: LD_INT 1
87277: PUSH
87278: EMPTY
87279: LIST
87280: LIST
87281: PUSH
87282: LD_INT 1
87284: NEG
87285: PUSH
87286: LD_INT 0
87288: PUSH
87289: EMPTY
87290: LIST
87291: LIST
87292: PUSH
87293: LD_INT 1
87295: NEG
87296: PUSH
87297: LD_INT 1
87299: NEG
87300: PUSH
87301: EMPTY
87302: LIST
87303: LIST
87304: PUSH
87305: LD_INT 1
87307: PUSH
87308: LD_INT 1
87310: NEG
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: LD_INT 1
87318: NEG
87319: PUSH
87320: LD_INT 1
87322: PUSH
87323: EMPTY
87324: LIST
87325: LIST
87326: PUSH
87327: EMPTY
87328: LIST
87329: LIST
87330: LIST
87331: LIST
87332: LIST
87333: LIST
87334: LIST
87335: LIST
87336: LIST
87337: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87338: LD_ADDR_VAR 0 41
87342: PUSH
87343: LD_INT 0
87345: PUSH
87346: LD_INT 0
87348: PUSH
87349: EMPTY
87350: LIST
87351: LIST
87352: PUSH
87353: LD_INT 0
87355: PUSH
87356: LD_INT 1
87358: NEG
87359: PUSH
87360: EMPTY
87361: LIST
87362: LIST
87363: PUSH
87364: LD_INT 1
87366: PUSH
87367: LD_INT 0
87369: PUSH
87370: EMPTY
87371: LIST
87372: LIST
87373: PUSH
87374: LD_INT 1
87376: PUSH
87377: LD_INT 1
87379: PUSH
87380: EMPTY
87381: LIST
87382: LIST
87383: PUSH
87384: LD_INT 0
87386: PUSH
87387: LD_INT 1
87389: PUSH
87390: EMPTY
87391: LIST
87392: LIST
87393: PUSH
87394: LD_INT 1
87396: NEG
87397: PUSH
87398: LD_INT 0
87400: PUSH
87401: EMPTY
87402: LIST
87403: LIST
87404: PUSH
87405: LD_INT 1
87407: NEG
87408: PUSH
87409: LD_INT 1
87411: NEG
87412: PUSH
87413: EMPTY
87414: LIST
87415: LIST
87416: PUSH
87417: LD_INT 1
87419: NEG
87420: PUSH
87421: LD_INT 2
87423: NEG
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PUSH
87429: LD_INT 1
87431: PUSH
87432: LD_INT 1
87434: NEG
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: PUSH
87440: LD_INT 2
87442: PUSH
87443: LD_INT 0
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 2
87452: PUSH
87453: LD_INT 1
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: LD_INT 2
87462: PUSH
87463: LD_INT 2
87465: PUSH
87466: EMPTY
87467: LIST
87468: LIST
87469: PUSH
87470: LD_INT 1
87472: PUSH
87473: LD_INT 2
87475: PUSH
87476: EMPTY
87477: LIST
87478: LIST
87479: PUSH
87480: LD_INT 1
87482: NEG
87483: PUSH
87484: LD_INT 1
87486: PUSH
87487: EMPTY
87488: LIST
87489: LIST
87490: PUSH
87491: LD_INT 2
87493: NEG
87494: PUSH
87495: LD_INT 0
87497: PUSH
87498: EMPTY
87499: LIST
87500: LIST
87501: PUSH
87502: LD_INT 2
87504: NEG
87505: PUSH
87506: LD_INT 1
87508: NEG
87509: PUSH
87510: EMPTY
87511: LIST
87512: LIST
87513: PUSH
87514: LD_INT 2
87516: NEG
87517: PUSH
87518: LD_INT 2
87520: NEG
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 2
87528: NEG
87529: PUSH
87530: LD_INT 3
87532: NEG
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 2
87540: PUSH
87541: LD_INT 1
87543: NEG
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: LD_INT 3
87551: PUSH
87552: LD_INT 0
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 3
87561: PUSH
87562: LD_INT 1
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PUSH
87569: LD_INT 3
87571: PUSH
87572: LD_INT 2
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: PUSH
87579: LD_INT 3
87581: PUSH
87582: LD_INT 3
87584: PUSH
87585: EMPTY
87586: LIST
87587: LIST
87588: PUSH
87589: LD_INT 2
87591: PUSH
87592: LD_INT 3
87594: PUSH
87595: EMPTY
87596: LIST
87597: LIST
87598: PUSH
87599: LD_INT 2
87601: NEG
87602: PUSH
87603: LD_INT 1
87605: PUSH
87606: EMPTY
87607: LIST
87608: LIST
87609: PUSH
87610: LD_INT 3
87612: NEG
87613: PUSH
87614: LD_INT 0
87616: PUSH
87617: EMPTY
87618: LIST
87619: LIST
87620: PUSH
87621: LD_INT 3
87623: NEG
87624: PUSH
87625: LD_INT 1
87627: NEG
87628: PUSH
87629: EMPTY
87630: LIST
87631: LIST
87632: PUSH
87633: LD_INT 3
87635: NEG
87636: PUSH
87637: LD_INT 2
87639: NEG
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 3
87647: NEG
87648: PUSH
87649: LD_INT 3
87651: NEG
87652: PUSH
87653: EMPTY
87654: LIST
87655: LIST
87656: PUSH
87657: EMPTY
87658: LIST
87659: LIST
87660: LIST
87661: LIST
87662: LIST
87663: LIST
87664: LIST
87665: LIST
87666: LIST
87667: LIST
87668: LIST
87669: LIST
87670: LIST
87671: LIST
87672: LIST
87673: LIST
87674: LIST
87675: LIST
87676: LIST
87677: LIST
87678: LIST
87679: LIST
87680: LIST
87681: LIST
87682: LIST
87683: LIST
87684: LIST
87685: LIST
87686: LIST
87687: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87688: LD_ADDR_VAR 0 42
87692: PUSH
87693: LD_INT 0
87695: PUSH
87696: LD_INT 0
87698: PUSH
87699: EMPTY
87700: LIST
87701: LIST
87702: PUSH
87703: LD_INT 0
87705: PUSH
87706: LD_INT 1
87708: NEG
87709: PUSH
87710: EMPTY
87711: LIST
87712: LIST
87713: PUSH
87714: LD_INT 1
87716: PUSH
87717: LD_INT 0
87719: PUSH
87720: EMPTY
87721: LIST
87722: LIST
87723: PUSH
87724: LD_INT 1
87726: PUSH
87727: LD_INT 1
87729: PUSH
87730: EMPTY
87731: LIST
87732: LIST
87733: PUSH
87734: LD_INT 0
87736: PUSH
87737: LD_INT 1
87739: PUSH
87740: EMPTY
87741: LIST
87742: LIST
87743: PUSH
87744: LD_INT 1
87746: NEG
87747: PUSH
87748: LD_INT 0
87750: PUSH
87751: EMPTY
87752: LIST
87753: LIST
87754: PUSH
87755: LD_INT 1
87757: NEG
87758: PUSH
87759: LD_INT 1
87761: NEG
87762: PUSH
87763: EMPTY
87764: LIST
87765: LIST
87766: PUSH
87767: LD_INT 1
87769: NEG
87770: PUSH
87771: LD_INT 2
87773: NEG
87774: PUSH
87775: EMPTY
87776: LIST
87777: LIST
87778: PUSH
87779: LD_INT 0
87781: PUSH
87782: LD_INT 2
87784: NEG
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: LD_INT 1
87792: PUSH
87793: LD_INT 1
87795: NEG
87796: PUSH
87797: EMPTY
87798: LIST
87799: LIST
87800: PUSH
87801: LD_INT 2
87803: PUSH
87804: LD_INT 1
87806: PUSH
87807: EMPTY
87808: LIST
87809: LIST
87810: PUSH
87811: LD_INT 2
87813: PUSH
87814: LD_INT 2
87816: PUSH
87817: EMPTY
87818: LIST
87819: LIST
87820: PUSH
87821: LD_INT 1
87823: PUSH
87824: LD_INT 2
87826: PUSH
87827: EMPTY
87828: LIST
87829: LIST
87830: PUSH
87831: LD_INT 0
87833: PUSH
87834: LD_INT 2
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: PUSH
87841: LD_INT 1
87843: NEG
87844: PUSH
87845: LD_INT 1
87847: PUSH
87848: EMPTY
87849: LIST
87850: LIST
87851: PUSH
87852: LD_INT 2
87854: NEG
87855: PUSH
87856: LD_INT 1
87858: NEG
87859: PUSH
87860: EMPTY
87861: LIST
87862: LIST
87863: PUSH
87864: LD_INT 2
87866: NEG
87867: PUSH
87868: LD_INT 2
87870: NEG
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 2
87878: NEG
87879: PUSH
87880: LD_INT 3
87882: NEG
87883: PUSH
87884: EMPTY
87885: LIST
87886: LIST
87887: PUSH
87888: LD_INT 1
87890: NEG
87891: PUSH
87892: LD_INT 3
87894: NEG
87895: PUSH
87896: EMPTY
87897: LIST
87898: LIST
87899: PUSH
87900: LD_INT 0
87902: PUSH
87903: LD_INT 3
87905: NEG
87906: PUSH
87907: EMPTY
87908: LIST
87909: LIST
87910: PUSH
87911: LD_INT 1
87913: PUSH
87914: LD_INT 2
87916: NEG
87917: PUSH
87918: EMPTY
87919: LIST
87920: LIST
87921: PUSH
87922: LD_INT 3
87924: PUSH
87925: LD_INT 2
87927: PUSH
87928: EMPTY
87929: LIST
87930: LIST
87931: PUSH
87932: LD_INT 3
87934: PUSH
87935: LD_INT 3
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PUSH
87942: LD_INT 2
87944: PUSH
87945: LD_INT 3
87947: PUSH
87948: EMPTY
87949: LIST
87950: LIST
87951: PUSH
87952: LD_INT 1
87954: PUSH
87955: LD_INT 3
87957: PUSH
87958: EMPTY
87959: LIST
87960: LIST
87961: PUSH
87962: LD_INT 0
87964: PUSH
87965: LD_INT 3
87967: PUSH
87968: EMPTY
87969: LIST
87970: LIST
87971: PUSH
87972: LD_INT 1
87974: NEG
87975: PUSH
87976: LD_INT 2
87978: PUSH
87979: EMPTY
87980: LIST
87981: LIST
87982: PUSH
87983: LD_INT 3
87985: NEG
87986: PUSH
87987: LD_INT 2
87989: NEG
87990: PUSH
87991: EMPTY
87992: LIST
87993: LIST
87994: PUSH
87995: LD_INT 3
87997: NEG
87998: PUSH
87999: LD_INT 3
88001: NEG
88002: PUSH
88003: EMPTY
88004: LIST
88005: LIST
88006: PUSH
88007: EMPTY
88008: LIST
88009: LIST
88010: LIST
88011: LIST
88012: LIST
88013: LIST
88014: LIST
88015: LIST
88016: LIST
88017: LIST
88018: LIST
88019: LIST
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: LIST
88028: LIST
88029: LIST
88030: LIST
88031: LIST
88032: LIST
88033: LIST
88034: LIST
88035: LIST
88036: LIST
88037: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88038: LD_ADDR_VAR 0 43
88042: PUSH
88043: LD_INT 0
88045: PUSH
88046: LD_INT 0
88048: PUSH
88049: EMPTY
88050: LIST
88051: LIST
88052: PUSH
88053: LD_INT 0
88055: PUSH
88056: LD_INT 1
88058: NEG
88059: PUSH
88060: EMPTY
88061: LIST
88062: LIST
88063: PUSH
88064: LD_INT 1
88066: PUSH
88067: LD_INT 0
88069: PUSH
88070: EMPTY
88071: LIST
88072: LIST
88073: PUSH
88074: LD_INT 1
88076: PUSH
88077: LD_INT 1
88079: PUSH
88080: EMPTY
88081: LIST
88082: LIST
88083: PUSH
88084: LD_INT 0
88086: PUSH
88087: LD_INT 1
88089: PUSH
88090: EMPTY
88091: LIST
88092: LIST
88093: PUSH
88094: LD_INT 1
88096: NEG
88097: PUSH
88098: LD_INT 0
88100: PUSH
88101: EMPTY
88102: LIST
88103: LIST
88104: PUSH
88105: LD_INT 1
88107: NEG
88108: PUSH
88109: LD_INT 1
88111: NEG
88112: PUSH
88113: EMPTY
88114: LIST
88115: LIST
88116: PUSH
88117: LD_INT 1
88119: NEG
88120: PUSH
88121: LD_INT 2
88123: NEG
88124: PUSH
88125: EMPTY
88126: LIST
88127: LIST
88128: PUSH
88129: LD_INT 0
88131: PUSH
88132: LD_INT 2
88134: NEG
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: PUSH
88140: LD_INT 1
88142: PUSH
88143: LD_INT 1
88145: NEG
88146: PUSH
88147: EMPTY
88148: LIST
88149: LIST
88150: PUSH
88151: LD_INT 2
88153: PUSH
88154: LD_INT 0
88156: PUSH
88157: EMPTY
88158: LIST
88159: LIST
88160: PUSH
88161: LD_INT 2
88163: PUSH
88164: LD_INT 1
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 1
88173: PUSH
88174: LD_INT 2
88176: PUSH
88177: EMPTY
88178: LIST
88179: LIST
88180: PUSH
88181: LD_INT 0
88183: PUSH
88184: LD_INT 2
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 1
88193: NEG
88194: PUSH
88195: LD_INT 1
88197: PUSH
88198: EMPTY
88199: LIST
88200: LIST
88201: PUSH
88202: LD_INT 2
88204: NEG
88205: PUSH
88206: LD_INT 0
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: PUSH
88213: LD_INT 2
88215: NEG
88216: PUSH
88217: LD_INT 1
88219: NEG
88220: PUSH
88221: EMPTY
88222: LIST
88223: LIST
88224: PUSH
88225: LD_INT 1
88227: NEG
88228: PUSH
88229: LD_INT 3
88231: NEG
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 0
88239: PUSH
88240: LD_INT 3
88242: NEG
88243: PUSH
88244: EMPTY
88245: LIST
88246: LIST
88247: PUSH
88248: LD_INT 1
88250: PUSH
88251: LD_INT 2
88253: NEG
88254: PUSH
88255: EMPTY
88256: LIST
88257: LIST
88258: PUSH
88259: LD_INT 2
88261: PUSH
88262: LD_INT 1
88264: NEG
88265: PUSH
88266: EMPTY
88267: LIST
88268: LIST
88269: PUSH
88270: LD_INT 3
88272: PUSH
88273: LD_INT 0
88275: PUSH
88276: EMPTY
88277: LIST
88278: LIST
88279: PUSH
88280: LD_INT 3
88282: PUSH
88283: LD_INT 1
88285: PUSH
88286: EMPTY
88287: LIST
88288: LIST
88289: PUSH
88290: LD_INT 1
88292: PUSH
88293: LD_INT 3
88295: PUSH
88296: EMPTY
88297: LIST
88298: LIST
88299: PUSH
88300: LD_INT 0
88302: PUSH
88303: LD_INT 3
88305: PUSH
88306: EMPTY
88307: LIST
88308: LIST
88309: PUSH
88310: LD_INT 1
88312: NEG
88313: PUSH
88314: LD_INT 2
88316: PUSH
88317: EMPTY
88318: LIST
88319: LIST
88320: PUSH
88321: LD_INT 2
88323: NEG
88324: PUSH
88325: LD_INT 1
88327: PUSH
88328: EMPTY
88329: LIST
88330: LIST
88331: PUSH
88332: LD_INT 3
88334: NEG
88335: PUSH
88336: LD_INT 0
88338: PUSH
88339: EMPTY
88340: LIST
88341: LIST
88342: PUSH
88343: LD_INT 3
88345: NEG
88346: PUSH
88347: LD_INT 1
88349: NEG
88350: PUSH
88351: EMPTY
88352: LIST
88353: LIST
88354: PUSH
88355: EMPTY
88356: LIST
88357: LIST
88358: LIST
88359: LIST
88360: LIST
88361: LIST
88362: LIST
88363: LIST
88364: LIST
88365: LIST
88366: LIST
88367: LIST
88368: LIST
88369: LIST
88370: LIST
88371: LIST
88372: LIST
88373: LIST
88374: LIST
88375: LIST
88376: LIST
88377: LIST
88378: LIST
88379: LIST
88380: LIST
88381: LIST
88382: LIST
88383: LIST
88384: LIST
88385: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88386: LD_ADDR_VAR 0 44
88390: PUSH
88391: LD_INT 0
88393: PUSH
88394: LD_INT 0
88396: PUSH
88397: EMPTY
88398: LIST
88399: LIST
88400: PUSH
88401: LD_INT 0
88403: PUSH
88404: LD_INT 1
88406: NEG
88407: PUSH
88408: EMPTY
88409: LIST
88410: LIST
88411: PUSH
88412: LD_INT 1
88414: PUSH
88415: LD_INT 0
88417: PUSH
88418: EMPTY
88419: LIST
88420: LIST
88421: PUSH
88422: LD_INT 1
88424: PUSH
88425: LD_INT 1
88427: PUSH
88428: EMPTY
88429: LIST
88430: LIST
88431: PUSH
88432: LD_INT 0
88434: PUSH
88435: LD_INT 1
88437: PUSH
88438: EMPTY
88439: LIST
88440: LIST
88441: PUSH
88442: LD_INT 1
88444: NEG
88445: PUSH
88446: LD_INT 0
88448: PUSH
88449: EMPTY
88450: LIST
88451: LIST
88452: PUSH
88453: LD_INT 1
88455: NEG
88456: PUSH
88457: LD_INT 1
88459: NEG
88460: PUSH
88461: EMPTY
88462: LIST
88463: LIST
88464: PUSH
88465: LD_INT 1
88467: NEG
88468: PUSH
88469: LD_INT 2
88471: NEG
88472: PUSH
88473: EMPTY
88474: LIST
88475: LIST
88476: PUSH
88477: LD_INT 1
88479: PUSH
88480: LD_INT 1
88482: NEG
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: PUSH
88488: LD_INT 2
88490: PUSH
88491: LD_INT 0
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PUSH
88498: LD_INT 2
88500: PUSH
88501: LD_INT 1
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: PUSH
88508: LD_INT 2
88510: PUSH
88511: LD_INT 2
88513: PUSH
88514: EMPTY
88515: LIST
88516: LIST
88517: PUSH
88518: LD_INT 1
88520: PUSH
88521: LD_INT 2
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: LD_INT 1
88530: NEG
88531: PUSH
88532: LD_INT 1
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: PUSH
88539: LD_INT 2
88541: NEG
88542: PUSH
88543: LD_INT 0
88545: PUSH
88546: EMPTY
88547: LIST
88548: LIST
88549: PUSH
88550: LD_INT 2
88552: NEG
88553: PUSH
88554: LD_INT 1
88556: NEG
88557: PUSH
88558: EMPTY
88559: LIST
88560: LIST
88561: PUSH
88562: LD_INT 2
88564: NEG
88565: PUSH
88566: LD_INT 2
88568: NEG
88569: PUSH
88570: EMPTY
88571: LIST
88572: LIST
88573: PUSH
88574: LD_INT 2
88576: NEG
88577: PUSH
88578: LD_INT 3
88580: NEG
88581: PUSH
88582: EMPTY
88583: LIST
88584: LIST
88585: PUSH
88586: LD_INT 2
88588: PUSH
88589: LD_INT 1
88591: NEG
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 3
88599: PUSH
88600: LD_INT 0
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 3
88609: PUSH
88610: LD_INT 1
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 3
88619: PUSH
88620: LD_INT 2
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: PUSH
88627: LD_INT 3
88629: PUSH
88630: LD_INT 3
88632: PUSH
88633: EMPTY
88634: LIST
88635: LIST
88636: PUSH
88637: LD_INT 2
88639: PUSH
88640: LD_INT 3
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: PUSH
88647: LD_INT 2
88649: NEG
88650: PUSH
88651: LD_INT 1
88653: PUSH
88654: EMPTY
88655: LIST
88656: LIST
88657: PUSH
88658: LD_INT 3
88660: NEG
88661: PUSH
88662: LD_INT 0
88664: PUSH
88665: EMPTY
88666: LIST
88667: LIST
88668: PUSH
88669: LD_INT 3
88671: NEG
88672: PUSH
88673: LD_INT 1
88675: NEG
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: PUSH
88681: LD_INT 3
88683: NEG
88684: PUSH
88685: LD_INT 2
88687: NEG
88688: PUSH
88689: EMPTY
88690: LIST
88691: LIST
88692: PUSH
88693: LD_INT 3
88695: NEG
88696: PUSH
88697: LD_INT 3
88699: NEG
88700: PUSH
88701: EMPTY
88702: LIST
88703: LIST
88704: PUSH
88705: EMPTY
88706: LIST
88707: LIST
88708: LIST
88709: LIST
88710: LIST
88711: LIST
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: LIST
88724: LIST
88725: LIST
88726: LIST
88727: LIST
88728: LIST
88729: LIST
88730: LIST
88731: LIST
88732: LIST
88733: LIST
88734: LIST
88735: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88736: LD_ADDR_VAR 0 45
88740: PUSH
88741: LD_INT 0
88743: PUSH
88744: LD_INT 0
88746: PUSH
88747: EMPTY
88748: LIST
88749: LIST
88750: PUSH
88751: LD_INT 0
88753: PUSH
88754: LD_INT 1
88756: NEG
88757: PUSH
88758: EMPTY
88759: LIST
88760: LIST
88761: PUSH
88762: LD_INT 1
88764: PUSH
88765: LD_INT 0
88767: PUSH
88768: EMPTY
88769: LIST
88770: LIST
88771: PUSH
88772: LD_INT 1
88774: PUSH
88775: LD_INT 1
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: PUSH
88782: LD_INT 0
88784: PUSH
88785: LD_INT 1
88787: PUSH
88788: EMPTY
88789: LIST
88790: LIST
88791: PUSH
88792: LD_INT 1
88794: NEG
88795: PUSH
88796: LD_INT 0
88798: PUSH
88799: EMPTY
88800: LIST
88801: LIST
88802: PUSH
88803: LD_INT 1
88805: NEG
88806: PUSH
88807: LD_INT 1
88809: NEG
88810: PUSH
88811: EMPTY
88812: LIST
88813: LIST
88814: PUSH
88815: LD_INT 1
88817: NEG
88818: PUSH
88819: LD_INT 2
88821: NEG
88822: PUSH
88823: EMPTY
88824: LIST
88825: LIST
88826: PUSH
88827: LD_INT 0
88829: PUSH
88830: LD_INT 2
88832: NEG
88833: PUSH
88834: EMPTY
88835: LIST
88836: LIST
88837: PUSH
88838: LD_INT 1
88840: PUSH
88841: LD_INT 1
88843: NEG
88844: PUSH
88845: EMPTY
88846: LIST
88847: LIST
88848: PUSH
88849: LD_INT 2
88851: PUSH
88852: LD_INT 1
88854: PUSH
88855: EMPTY
88856: LIST
88857: LIST
88858: PUSH
88859: LD_INT 2
88861: PUSH
88862: LD_INT 2
88864: PUSH
88865: EMPTY
88866: LIST
88867: LIST
88868: PUSH
88869: LD_INT 1
88871: PUSH
88872: LD_INT 2
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: PUSH
88879: LD_INT 0
88881: PUSH
88882: LD_INT 2
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: PUSH
88889: LD_INT 1
88891: NEG
88892: PUSH
88893: LD_INT 1
88895: PUSH
88896: EMPTY
88897: LIST
88898: LIST
88899: PUSH
88900: LD_INT 2
88902: NEG
88903: PUSH
88904: LD_INT 1
88906: NEG
88907: PUSH
88908: EMPTY
88909: LIST
88910: LIST
88911: PUSH
88912: LD_INT 2
88914: NEG
88915: PUSH
88916: LD_INT 2
88918: NEG
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: PUSH
88924: LD_INT 2
88926: NEG
88927: PUSH
88928: LD_INT 3
88930: NEG
88931: PUSH
88932: EMPTY
88933: LIST
88934: LIST
88935: PUSH
88936: LD_INT 1
88938: NEG
88939: PUSH
88940: LD_INT 3
88942: NEG
88943: PUSH
88944: EMPTY
88945: LIST
88946: LIST
88947: PUSH
88948: LD_INT 0
88950: PUSH
88951: LD_INT 3
88953: NEG
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: PUSH
88959: LD_INT 1
88961: PUSH
88962: LD_INT 2
88964: NEG
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: PUSH
88970: LD_INT 3
88972: PUSH
88973: LD_INT 2
88975: PUSH
88976: EMPTY
88977: LIST
88978: LIST
88979: PUSH
88980: LD_INT 3
88982: PUSH
88983: LD_INT 3
88985: PUSH
88986: EMPTY
88987: LIST
88988: LIST
88989: PUSH
88990: LD_INT 2
88992: PUSH
88993: LD_INT 3
88995: PUSH
88996: EMPTY
88997: LIST
88998: LIST
88999: PUSH
89000: LD_INT 1
89002: PUSH
89003: LD_INT 3
89005: PUSH
89006: EMPTY
89007: LIST
89008: LIST
89009: PUSH
89010: LD_INT 0
89012: PUSH
89013: LD_INT 3
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: PUSH
89020: LD_INT 1
89022: NEG
89023: PUSH
89024: LD_INT 2
89026: PUSH
89027: EMPTY
89028: LIST
89029: LIST
89030: PUSH
89031: LD_INT 3
89033: NEG
89034: PUSH
89035: LD_INT 2
89037: NEG
89038: PUSH
89039: EMPTY
89040: LIST
89041: LIST
89042: PUSH
89043: LD_INT 3
89045: NEG
89046: PUSH
89047: LD_INT 3
89049: NEG
89050: PUSH
89051: EMPTY
89052: LIST
89053: LIST
89054: PUSH
89055: EMPTY
89056: LIST
89057: LIST
89058: LIST
89059: LIST
89060: LIST
89061: LIST
89062: LIST
89063: LIST
89064: LIST
89065: LIST
89066: LIST
89067: LIST
89068: LIST
89069: LIST
89070: LIST
89071: LIST
89072: LIST
89073: LIST
89074: LIST
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: LIST
89083: LIST
89084: LIST
89085: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
89086: LD_ADDR_VAR 0 46
89090: PUSH
89091: LD_INT 0
89093: PUSH
89094: LD_INT 0
89096: PUSH
89097: EMPTY
89098: LIST
89099: LIST
89100: PUSH
89101: LD_INT 0
89103: PUSH
89104: LD_INT 1
89106: NEG
89107: PUSH
89108: EMPTY
89109: LIST
89110: LIST
89111: PUSH
89112: LD_INT 1
89114: PUSH
89115: LD_INT 0
89117: PUSH
89118: EMPTY
89119: LIST
89120: LIST
89121: PUSH
89122: LD_INT 1
89124: PUSH
89125: LD_INT 1
89127: PUSH
89128: EMPTY
89129: LIST
89130: LIST
89131: PUSH
89132: LD_INT 0
89134: PUSH
89135: LD_INT 1
89137: PUSH
89138: EMPTY
89139: LIST
89140: LIST
89141: PUSH
89142: LD_INT 1
89144: NEG
89145: PUSH
89146: LD_INT 0
89148: PUSH
89149: EMPTY
89150: LIST
89151: LIST
89152: PUSH
89153: LD_INT 1
89155: NEG
89156: PUSH
89157: LD_INT 1
89159: NEG
89160: PUSH
89161: EMPTY
89162: LIST
89163: LIST
89164: PUSH
89165: LD_INT 1
89167: NEG
89168: PUSH
89169: LD_INT 2
89171: NEG
89172: PUSH
89173: EMPTY
89174: LIST
89175: LIST
89176: PUSH
89177: LD_INT 0
89179: PUSH
89180: LD_INT 2
89182: NEG
89183: PUSH
89184: EMPTY
89185: LIST
89186: LIST
89187: PUSH
89188: LD_INT 1
89190: PUSH
89191: LD_INT 1
89193: NEG
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 2
89201: PUSH
89202: LD_INT 0
89204: PUSH
89205: EMPTY
89206: LIST
89207: LIST
89208: PUSH
89209: LD_INT 2
89211: PUSH
89212: LD_INT 1
89214: PUSH
89215: EMPTY
89216: LIST
89217: LIST
89218: PUSH
89219: LD_INT 1
89221: PUSH
89222: LD_INT 2
89224: PUSH
89225: EMPTY
89226: LIST
89227: LIST
89228: PUSH
89229: LD_INT 0
89231: PUSH
89232: LD_INT 2
89234: PUSH
89235: EMPTY
89236: LIST
89237: LIST
89238: PUSH
89239: LD_INT 1
89241: NEG
89242: PUSH
89243: LD_INT 1
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: PUSH
89250: LD_INT 2
89252: NEG
89253: PUSH
89254: LD_INT 0
89256: PUSH
89257: EMPTY
89258: LIST
89259: LIST
89260: PUSH
89261: LD_INT 2
89263: NEG
89264: PUSH
89265: LD_INT 1
89267: NEG
89268: PUSH
89269: EMPTY
89270: LIST
89271: LIST
89272: PUSH
89273: LD_INT 1
89275: NEG
89276: PUSH
89277: LD_INT 3
89279: NEG
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: PUSH
89285: LD_INT 0
89287: PUSH
89288: LD_INT 3
89290: NEG
89291: PUSH
89292: EMPTY
89293: LIST
89294: LIST
89295: PUSH
89296: LD_INT 1
89298: PUSH
89299: LD_INT 2
89301: NEG
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: PUSH
89307: LD_INT 2
89309: PUSH
89310: LD_INT 1
89312: NEG
89313: PUSH
89314: EMPTY
89315: LIST
89316: LIST
89317: PUSH
89318: LD_INT 3
89320: PUSH
89321: LD_INT 0
89323: PUSH
89324: EMPTY
89325: LIST
89326: LIST
89327: PUSH
89328: LD_INT 3
89330: PUSH
89331: LD_INT 1
89333: PUSH
89334: EMPTY
89335: LIST
89336: LIST
89337: PUSH
89338: LD_INT 1
89340: PUSH
89341: LD_INT 3
89343: PUSH
89344: EMPTY
89345: LIST
89346: LIST
89347: PUSH
89348: LD_INT 0
89350: PUSH
89351: LD_INT 3
89353: PUSH
89354: EMPTY
89355: LIST
89356: LIST
89357: PUSH
89358: LD_INT 1
89360: NEG
89361: PUSH
89362: LD_INT 2
89364: PUSH
89365: EMPTY
89366: LIST
89367: LIST
89368: PUSH
89369: LD_INT 2
89371: NEG
89372: PUSH
89373: LD_INT 1
89375: PUSH
89376: EMPTY
89377: LIST
89378: LIST
89379: PUSH
89380: LD_INT 3
89382: NEG
89383: PUSH
89384: LD_INT 0
89386: PUSH
89387: EMPTY
89388: LIST
89389: LIST
89390: PUSH
89391: LD_INT 3
89393: NEG
89394: PUSH
89395: LD_INT 1
89397: NEG
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: PUSH
89403: EMPTY
89404: LIST
89405: LIST
89406: LIST
89407: LIST
89408: LIST
89409: LIST
89410: LIST
89411: LIST
89412: LIST
89413: LIST
89414: LIST
89415: LIST
89416: LIST
89417: LIST
89418: LIST
89419: LIST
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89434: LD_ADDR_VAR 0 47
89438: PUSH
89439: LD_INT 0
89441: PUSH
89442: LD_INT 0
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: LD_INT 0
89451: PUSH
89452: LD_INT 1
89454: NEG
89455: PUSH
89456: EMPTY
89457: LIST
89458: LIST
89459: PUSH
89460: LD_INT 1
89462: PUSH
89463: LD_INT 0
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: PUSH
89470: LD_INT 1
89472: PUSH
89473: LD_INT 1
89475: PUSH
89476: EMPTY
89477: LIST
89478: LIST
89479: PUSH
89480: LD_INT 0
89482: PUSH
89483: LD_INT 1
89485: PUSH
89486: EMPTY
89487: LIST
89488: LIST
89489: PUSH
89490: LD_INT 1
89492: NEG
89493: PUSH
89494: LD_INT 0
89496: PUSH
89497: EMPTY
89498: LIST
89499: LIST
89500: PUSH
89501: LD_INT 1
89503: NEG
89504: PUSH
89505: LD_INT 1
89507: NEG
89508: PUSH
89509: EMPTY
89510: LIST
89511: LIST
89512: PUSH
89513: LD_INT 1
89515: NEG
89516: PUSH
89517: LD_INT 2
89519: NEG
89520: PUSH
89521: EMPTY
89522: LIST
89523: LIST
89524: PUSH
89525: LD_INT 0
89527: PUSH
89528: LD_INT 2
89530: NEG
89531: PUSH
89532: EMPTY
89533: LIST
89534: LIST
89535: PUSH
89536: LD_INT 1
89538: PUSH
89539: LD_INT 1
89541: NEG
89542: PUSH
89543: EMPTY
89544: LIST
89545: LIST
89546: PUSH
89547: LD_INT 2
89549: NEG
89550: PUSH
89551: LD_INT 1
89553: NEG
89554: PUSH
89555: EMPTY
89556: LIST
89557: LIST
89558: PUSH
89559: LD_INT 2
89561: NEG
89562: PUSH
89563: LD_INT 2
89565: NEG
89566: PUSH
89567: EMPTY
89568: LIST
89569: LIST
89570: PUSH
89571: EMPTY
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
89585: LD_ADDR_VAR 0 48
89589: PUSH
89590: LD_INT 0
89592: PUSH
89593: LD_INT 0
89595: PUSH
89596: EMPTY
89597: LIST
89598: LIST
89599: PUSH
89600: LD_INT 0
89602: PUSH
89603: LD_INT 1
89605: NEG
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 1
89613: PUSH
89614: LD_INT 0
89616: PUSH
89617: EMPTY
89618: LIST
89619: LIST
89620: PUSH
89621: LD_INT 1
89623: PUSH
89624: LD_INT 1
89626: PUSH
89627: EMPTY
89628: LIST
89629: LIST
89630: PUSH
89631: LD_INT 0
89633: PUSH
89634: LD_INT 1
89636: PUSH
89637: EMPTY
89638: LIST
89639: LIST
89640: PUSH
89641: LD_INT 1
89643: NEG
89644: PUSH
89645: LD_INT 0
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 1
89654: NEG
89655: PUSH
89656: LD_INT 1
89658: NEG
89659: PUSH
89660: EMPTY
89661: LIST
89662: LIST
89663: PUSH
89664: LD_INT 1
89666: NEG
89667: PUSH
89668: LD_INT 2
89670: NEG
89671: PUSH
89672: EMPTY
89673: LIST
89674: LIST
89675: PUSH
89676: LD_INT 0
89678: PUSH
89679: LD_INT 2
89681: NEG
89682: PUSH
89683: EMPTY
89684: LIST
89685: LIST
89686: PUSH
89687: LD_INT 1
89689: PUSH
89690: LD_INT 1
89692: NEG
89693: PUSH
89694: EMPTY
89695: LIST
89696: LIST
89697: PUSH
89698: LD_INT 2
89700: PUSH
89701: LD_INT 0
89703: PUSH
89704: EMPTY
89705: LIST
89706: LIST
89707: PUSH
89708: LD_INT 2
89710: PUSH
89711: LD_INT 1
89713: PUSH
89714: EMPTY
89715: LIST
89716: LIST
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89732: LD_ADDR_VAR 0 49
89736: PUSH
89737: LD_INT 0
89739: PUSH
89740: LD_INT 0
89742: PUSH
89743: EMPTY
89744: LIST
89745: LIST
89746: PUSH
89747: LD_INT 0
89749: PUSH
89750: LD_INT 1
89752: NEG
89753: PUSH
89754: EMPTY
89755: LIST
89756: LIST
89757: PUSH
89758: LD_INT 1
89760: PUSH
89761: LD_INT 0
89763: PUSH
89764: EMPTY
89765: LIST
89766: LIST
89767: PUSH
89768: LD_INT 1
89770: PUSH
89771: LD_INT 1
89773: PUSH
89774: EMPTY
89775: LIST
89776: LIST
89777: PUSH
89778: LD_INT 0
89780: PUSH
89781: LD_INT 1
89783: PUSH
89784: EMPTY
89785: LIST
89786: LIST
89787: PUSH
89788: LD_INT 1
89790: NEG
89791: PUSH
89792: LD_INT 0
89794: PUSH
89795: EMPTY
89796: LIST
89797: LIST
89798: PUSH
89799: LD_INT 1
89801: NEG
89802: PUSH
89803: LD_INT 1
89805: NEG
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 1
89813: PUSH
89814: LD_INT 1
89816: NEG
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_INT 2
89824: PUSH
89825: LD_INT 0
89827: PUSH
89828: EMPTY
89829: LIST
89830: LIST
89831: PUSH
89832: LD_INT 2
89834: PUSH
89835: LD_INT 1
89837: PUSH
89838: EMPTY
89839: LIST
89840: LIST
89841: PUSH
89842: LD_INT 2
89844: PUSH
89845: LD_INT 2
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 1
89854: PUSH
89855: LD_INT 2
89857: PUSH
89858: EMPTY
89859: LIST
89860: LIST
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: LIST
89866: LIST
89867: LIST
89868: LIST
89869: LIST
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89876: LD_ADDR_VAR 0 50
89880: PUSH
89881: LD_INT 0
89883: PUSH
89884: LD_INT 0
89886: PUSH
89887: EMPTY
89888: LIST
89889: LIST
89890: PUSH
89891: LD_INT 0
89893: PUSH
89894: LD_INT 1
89896: NEG
89897: PUSH
89898: EMPTY
89899: LIST
89900: LIST
89901: PUSH
89902: LD_INT 1
89904: PUSH
89905: LD_INT 0
89907: PUSH
89908: EMPTY
89909: LIST
89910: LIST
89911: PUSH
89912: LD_INT 1
89914: PUSH
89915: LD_INT 1
89917: PUSH
89918: EMPTY
89919: LIST
89920: LIST
89921: PUSH
89922: LD_INT 0
89924: PUSH
89925: LD_INT 1
89927: PUSH
89928: EMPTY
89929: LIST
89930: LIST
89931: PUSH
89932: LD_INT 1
89934: NEG
89935: PUSH
89936: LD_INT 0
89938: PUSH
89939: EMPTY
89940: LIST
89941: LIST
89942: PUSH
89943: LD_INT 1
89945: NEG
89946: PUSH
89947: LD_INT 1
89949: NEG
89950: PUSH
89951: EMPTY
89952: LIST
89953: LIST
89954: PUSH
89955: LD_INT 2
89957: PUSH
89958: LD_INT 1
89960: PUSH
89961: EMPTY
89962: LIST
89963: LIST
89964: PUSH
89965: LD_INT 2
89967: PUSH
89968: LD_INT 2
89970: PUSH
89971: EMPTY
89972: LIST
89973: LIST
89974: PUSH
89975: LD_INT 1
89977: PUSH
89978: LD_INT 2
89980: PUSH
89981: EMPTY
89982: LIST
89983: LIST
89984: PUSH
89985: LD_INT 0
89987: PUSH
89988: LD_INT 2
89990: PUSH
89991: EMPTY
89992: LIST
89993: LIST
89994: PUSH
89995: LD_INT 1
89997: NEG
89998: PUSH
89999: LD_INT 1
90001: PUSH
90002: EMPTY
90003: LIST
90004: LIST
90005: PUSH
90006: EMPTY
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
90020: LD_ADDR_VAR 0 51
90024: PUSH
90025: LD_INT 0
90027: PUSH
90028: LD_INT 0
90030: PUSH
90031: EMPTY
90032: LIST
90033: LIST
90034: PUSH
90035: LD_INT 0
90037: PUSH
90038: LD_INT 1
90040: NEG
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: PUSH
90046: LD_INT 1
90048: PUSH
90049: LD_INT 0
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: PUSH
90056: LD_INT 1
90058: PUSH
90059: LD_INT 1
90061: PUSH
90062: EMPTY
90063: LIST
90064: LIST
90065: PUSH
90066: LD_INT 0
90068: PUSH
90069: LD_INT 1
90071: PUSH
90072: EMPTY
90073: LIST
90074: LIST
90075: PUSH
90076: LD_INT 1
90078: NEG
90079: PUSH
90080: LD_INT 0
90082: PUSH
90083: EMPTY
90084: LIST
90085: LIST
90086: PUSH
90087: LD_INT 1
90089: NEG
90090: PUSH
90091: LD_INT 1
90093: NEG
90094: PUSH
90095: EMPTY
90096: LIST
90097: LIST
90098: PUSH
90099: LD_INT 1
90101: PUSH
90102: LD_INT 2
90104: PUSH
90105: EMPTY
90106: LIST
90107: LIST
90108: PUSH
90109: LD_INT 0
90111: PUSH
90112: LD_INT 2
90114: PUSH
90115: EMPTY
90116: LIST
90117: LIST
90118: PUSH
90119: LD_INT 1
90121: NEG
90122: PUSH
90123: LD_INT 1
90125: PUSH
90126: EMPTY
90127: LIST
90128: LIST
90129: PUSH
90130: LD_INT 2
90132: NEG
90133: PUSH
90134: LD_INT 0
90136: PUSH
90137: EMPTY
90138: LIST
90139: LIST
90140: PUSH
90141: LD_INT 2
90143: NEG
90144: PUSH
90145: LD_INT 1
90147: NEG
90148: PUSH
90149: EMPTY
90150: LIST
90151: LIST
90152: PUSH
90153: EMPTY
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90167: LD_ADDR_VAR 0 52
90171: PUSH
90172: LD_INT 0
90174: PUSH
90175: LD_INT 0
90177: PUSH
90178: EMPTY
90179: LIST
90180: LIST
90181: PUSH
90182: LD_INT 0
90184: PUSH
90185: LD_INT 1
90187: NEG
90188: PUSH
90189: EMPTY
90190: LIST
90191: LIST
90192: PUSH
90193: LD_INT 1
90195: PUSH
90196: LD_INT 0
90198: PUSH
90199: EMPTY
90200: LIST
90201: LIST
90202: PUSH
90203: LD_INT 1
90205: PUSH
90206: LD_INT 1
90208: PUSH
90209: EMPTY
90210: LIST
90211: LIST
90212: PUSH
90213: LD_INT 0
90215: PUSH
90216: LD_INT 1
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 1
90225: NEG
90226: PUSH
90227: LD_INT 0
90229: PUSH
90230: EMPTY
90231: LIST
90232: LIST
90233: PUSH
90234: LD_INT 1
90236: NEG
90237: PUSH
90238: LD_INT 1
90240: NEG
90241: PUSH
90242: EMPTY
90243: LIST
90244: LIST
90245: PUSH
90246: LD_INT 1
90248: NEG
90249: PUSH
90250: LD_INT 2
90252: NEG
90253: PUSH
90254: EMPTY
90255: LIST
90256: LIST
90257: PUSH
90258: LD_INT 1
90260: NEG
90261: PUSH
90262: LD_INT 1
90264: PUSH
90265: EMPTY
90266: LIST
90267: LIST
90268: PUSH
90269: LD_INT 2
90271: NEG
90272: PUSH
90273: LD_INT 0
90275: PUSH
90276: EMPTY
90277: LIST
90278: LIST
90279: PUSH
90280: LD_INT 2
90282: NEG
90283: PUSH
90284: LD_INT 1
90286: NEG
90287: PUSH
90288: EMPTY
90289: LIST
90290: LIST
90291: PUSH
90292: LD_INT 2
90294: NEG
90295: PUSH
90296: LD_INT 2
90298: NEG
90299: PUSH
90300: EMPTY
90301: LIST
90302: LIST
90303: PUSH
90304: EMPTY
90305: LIST
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: LIST
90316: LIST
90317: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90318: LD_ADDR_VAR 0 53
90322: PUSH
90323: LD_INT 0
90325: PUSH
90326: LD_INT 0
90328: PUSH
90329: EMPTY
90330: LIST
90331: LIST
90332: PUSH
90333: LD_INT 0
90335: PUSH
90336: LD_INT 1
90338: NEG
90339: PUSH
90340: EMPTY
90341: LIST
90342: LIST
90343: PUSH
90344: LD_INT 1
90346: PUSH
90347: LD_INT 0
90349: PUSH
90350: EMPTY
90351: LIST
90352: LIST
90353: PUSH
90354: LD_INT 1
90356: PUSH
90357: LD_INT 1
90359: PUSH
90360: EMPTY
90361: LIST
90362: LIST
90363: PUSH
90364: LD_INT 0
90366: PUSH
90367: LD_INT 1
90369: PUSH
90370: EMPTY
90371: LIST
90372: LIST
90373: PUSH
90374: LD_INT 1
90376: NEG
90377: PUSH
90378: LD_INT 0
90380: PUSH
90381: EMPTY
90382: LIST
90383: LIST
90384: PUSH
90385: LD_INT 1
90387: NEG
90388: PUSH
90389: LD_INT 1
90391: NEG
90392: PUSH
90393: EMPTY
90394: LIST
90395: LIST
90396: PUSH
90397: LD_INT 1
90399: NEG
90400: PUSH
90401: LD_INT 2
90403: NEG
90404: PUSH
90405: EMPTY
90406: LIST
90407: LIST
90408: PUSH
90409: LD_INT 0
90411: PUSH
90412: LD_INT 2
90414: NEG
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PUSH
90420: LD_INT 1
90422: PUSH
90423: LD_INT 1
90425: NEG
90426: PUSH
90427: EMPTY
90428: LIST
90429: LIST
90430: PUSH
90431: LD_INT 2
90433: PUSH
90434: LD_INT 0
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 2
90443: PUSH
90444: LD_INT 1
90446: PUSH
90447: EMPTY
90448: LIST
90449: LIST
90450: PUSH
90451: LD_INT 2
90453: PUSH
90454: LD_INT 2
90456: PUSH
90457: EMPTY
90458: LIST
90459: LIST
90460: PUSH
90461: LD_INT 1
90463: PUSH
90464: LD_INT 2
90466: PUSH
90467: EMPTY
90468: LIST
90469: LIST
90470: PUSH
90471: LD_INT 0
90473: PUSH
90474: LD_INT 2
90476: PUSH
90477: EMPTY
90478: LIST
90479: LIST
90480: PUSH
90481: LD_INT 1
90483: NEG
90484: PUSH
90485: LD_INT 1
90487: PUSH
90488: EMPTY
90489: LIST
90490: LIST
90491: PUSH
90492: LD_INT 2
90494: NEG
90495: PUSH
90496: LD_INT 0
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: PUSH
90503: LD_INT 2
90505: NEG
90506: PUSH
90507: LD_INT 1
90509: NEG
90510: PUSH
90511: EMPTY
90512: LIST
90513: LIST
90514: PUSH
90515: LD_INT 2
90517: NEG
90518: PUSH
90519: LD_INT 2
90521: NEG
90522: PUSH
90523: EMPTY
90524: LIST
90525: LIST
90526: PUSH
90527: EMPTY
90528: LIST
90529: LIST
90530: LIST
90531: LIST
90532: LIST
90533: LIST
90534: LIST
90535: LIST
90536: LIST
90537: LIST
90538: LIST
90539: LIST
90540: LIST
90541: LIST
90542: LIST
90543: LIST
90544: LIST
90545: LIST
90546: LIST
90547: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90548: LD_ADDR_VAR 0 54
90552: PUSH
90553: LD_INT 0
90555: PUSH
90556: LD_INT 0
90558: PUSH
90559: EMPTY
90560: LIST
90561: LIST
90562: PUSH
90563: LD_INT 0
90565: PUSH
90566: LD_INT 1
90568: NEG
90569: PUSH
90570: EMPTY
90571: LIST
90572: LIST
90573: PUSH
90574: LD_INT 1
90576: PUSH
90577: LD_INT 0
90579: PUSH
90580: EMPTY
90581: LIST
90582: LIST
90583: PUSH
90584: LD_INT 1
90586: PUSH
90587: LD_INT 1
90589: PUSH
90590: EMPTY
90591: LIST
90592: LIST
90593: PUSH
90594: LD_INT 0
90596: PUSH
90597: LD_INT 1
90599: PUSH
90600: EMPTY
90601: LIST
90602: LIST
90603: PUSH
90604: LD_INT 1
90606: NEG
90607: PUSH
90608: LD_INT 0
90610: PUSH
90611: EMPTY
90612: LIST
90613: LIST
90614: PUSH
90615: LD_INT 1
90617: NEG
90618: PUSH
90619: LD_INT 1
90621: NEG
90622: PUSH
90623: EMPTY
90624: LIST
90625: LIST
90626: PUSH
90627: LD_INT 1
90629: NEG
90630: PUSH
90631: LD_INT 2
90633: NEG
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: LD_INT 0
90641: PUSH
90642: LD_INT 2
90644: NEG
90645: PUSH
90646: EMPTY
90647: LIST
90648: LIST
90649: PUSH
90650: LD_INT 1
90652: PUSH
90653: LD_INT 1
90655: NEG
90656: PUSH
90657: EMPTY
90658: LIST
90659: LIST
90660: PUSH
90661: LD_INT 2
90663: PUSH
90664: LD_INT 0
90666: PUSH
90667: EMPTY
90668: LIST
90669: LIST
90670: PUSH
90671: LD_INT 2
90673: PUSH
90674: LD_INT 1
90676: PUSH
90677: EMPTY
90678: LIST
90679: LIST
90680: PUSH
90681: LD_INT 2
90683: PUSH
90684: LD_INT 2
90686: PUSH
90687: EMPTY
90688: LIST
90689: LIST
90690: PUSH
90691: LD_INT 1
90693: PUSH
90694: LD_INT 2
90696: PUSH
90697: EMPTY
90698: LIST
90699: LIST
90700: PUSH
90701: LD_INT 0
90703: PUSH
90704: LD_INT 2
90706: PUSH
90707: EMPTY
90708: LIST
90709: LIST
90710: PUSH
90711: LD_INT 1
90713: NEG
90714: PUSH
90715: LD_INT 1
90717: PUSH
90718: EMPTY
90719: LIST
90720: LIST
90721: PUSH
90722: LD_INT 2
90724: NEG
90725: PUSH
90726: LD_INT 0
90728: PUSH
90729: EMPTY
90730: LIST
90731: LIST
90732: PUSH
90733: LD_INT 2
90735: NEG
90736: PUSH
90737: LD_INT 1
90739: NEG
90740: PUSH
90741: EMPTY
90742: LIST
90743: LIST
90744: PUSH
90745: LD_INT 2
90747: NEG
90748: PUSH
90749: LD_INT 2
90751: NEG
90752: PUSH
90753: EMPTY
90754: LIST
90755: LIST
90756: PUSH
90757: EMPTY
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: LIST
90774: LIST
90775: LIST
90776: LIST
90777: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90778: LD_ADDR_VAR 0 55
90782: PUSH
90783: LD_INT 0
90785: PUSH
90786: LD_INT 0
90788: PUSH
90789: EMPTY
90790: LIST
90791: LIST
90792: PUSH
90793: LD_INT 0
90795: PUSH
90796: LD_INT 1
90798: NEG
90799: PUSH
90800: EMPTY
90801: LIST
90802: LIST
90803: PUSH
90804: LD_INT 1
90806: PUSH
90807: LD_INT 0
90809: PUSH
90810: EMPTY
90811: LIST
90812: LIST
90813: PUSH
90814: LD_INT 1
90816: PUSH
90817: LD_INT 1
90819: PUSH
90820: EMPTY
90821: LIST
90822: LIST
90823: PUSH
90824: LD_INT 0
90826: PUSH
90827: LD_INT 1
90829: PUSH
90830: EMPTY
90831: LIST
90832: LIST
90833: PUSH
90834: LD_INT 1
90836: NEG
90837: PUSH
90838: LD_INT 0
90840: PUSH
90841: EMPTY
90842: LIST
90843: LIST
90844: PUSH
90845: LD_INT 1
90847: NEG
90848: PUSH
90849: LD_INT 1
90851: NEG
90852: PUSH
90853: EMPTY
90854: LIST
90855: LIST
90856: PUSH
90857: LD_INT 1
90859: NEG
90860: PUSH
90861: LD_INT 2
90863: NEG
90864: PUSH
90865: EMPTY
90866: LIST
90867: LIST
90868: PUSH
90869: LD_INT 0
90871: PUSH
90872: LD_INT 2
90874: NEG
90875: PUSH
90876: EMPTY
90877: LIST
90878: LIST
90879: PUSH
90880: LD_INT 1
90882: PUSH
90883: LD_INT 1
90885: NEG
90886: PUSH
90887: EMPTY
90888: LIST
90889: LIST
90890: PUSH
90891: LD_INT 2
90893: PUSH
90894: LD_INT 0
90896: PUSH
90897: EMPTY
90898: LIST
90899: LIST
90900: PUSH
90901: LD_INT 2
90903: PUSH
90904: LD_INT 1
90906: PUSH
90907: EMPTY
90908: LIST
90909: LIST
90910: PUSH
90911: LD_INT 2
90913: PUSH
90914: LD_INT 2
90916: PUSH
90917: EMPTY
90918: LIST
90919: LIST
90920: PUSH
90921: LD_INT 1
90923: PUSH
90924: LD_INT 2
90926: PUSH
90927: EMPTY
90928: LIST
90929: LIST
90930: PUSH
90931: LD_INT 0
90933: PUSH
90934: LD_INT 2
90936: PUSH
90937: EMPTY
90938: LIST
90939: LIST
90940: PUSH
90941: LD_INT 1
90943: NEG
90944: PUSH
90945: LD_INT 1
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: LD_INT 2
90954: NEG
90955: PUSH
90956: LD_INT 0
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: PUSH
90963: LD_INT 2
90965: NEG
90966: PUSH
90967: LD_INT 1
90969: NEG
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: PUSH
90975: LD_INT 2
90977: NEG
90978: PUSH
90979: LD_INT 2
90981: NEG
90982: PUSH
90983: EMPTY
90984: LIST
90985: LIST
90986: PUSH
90987: EMPTY
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91008: LD_ADDR_VAR 0 56
91012: PUSH
91013: LD_INT 0
91015: PUSH
91016: LD_INT 0
91018: PUSH
91019: EMPTY
91020: LIST
91021: LIST
91022: PUSH
91023: LD_INT 0
91025: PUSH
91026: LD_INT 1
91028: NEG
91029: PUSH
91030: EMPTY
91031: LIST
91032: LIST
91033: PUSH
91034: LD_INT 1
91036: PUSH
91037: LD_INT 0
91039: PUSH
91040: EMPTY
91041: LIST
91042: LIST
91043: PUSH
91044: LD_INT 1
91046: PUSH
91047: LD_INT 1
91049: PUSH
91050: EMPTY
91051: LIST
91052: LIST
91053: PUSH
91054: LD_INT 0
91056: PUSH
91057: LD_INT 1
91059: PUSH
91060: EMPTY
91061: LIST
91062: LIST
91063: PUSH
91064: LD_INT 1
91066: NEG
91067: PUSH
91068: LD_INT 0
91070: PUSH
91071: EMPTY
91072: LIST
91073: LIST
91074: PUSH
91075: LD_INT 1
91077: NEG
91078: PUSH
91079: LD_INT 1
91081: NEG
91082: PUSH
91083: EMPTY
91084: LIST
91085: LIST
91086: PUSH
91087: LD_INT 1
91089: NEG
91090: PUSH
91091: LD_INT 2
91093: NEG
91094: PUSH
91095: EMPTY
91096: LIST
91097: LIST
91098: PUSH
91099: LD_INT 0
91101: PUSH
91102: LD_INT 2
91104: NEG
91105: PUSH
91106: EMPTY
91107: LIST
91108: LIST
91109: PUSH
91110: LD_INT 1
91112: PUSH
91113: LD_INT 1
91115: NEG
91116: PUSH
91117: EMPTY
91118: LIST
91119: LIST
91120: PUSH
91121: LD_INT 2
91123: PUSH
91124: LD_INT 0
91126: PUSH
91127: EMPTY
91128: LIST
91129: LIST
91130: PUSH
91131: LD_INT 2
91133: PUSH
91134: LD_INT 1
91136: PUSH
91137: EMPTY
91138: LIST
91139: LIST
91140: PUSH
91141: LD_INT 2
91143: PUSH
91144: LD_INT 2
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: PUSH
91151: LD_INT 1
91153: PUSH
91154: LD_INT 2
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: PUSH
91161: LD_INT 0
91163: PUSH
91164: LD_INT 2
91166: PUSH
91167: EMPTY
91168: LIST
91169: LIST
91170: PUSH
91171: LD_INT 1
91173: NEG
91174: PUSH
91175: LD_INT 1
91177: PUSH
91178: EMPTY
91179: LIST
91180: LIST
91181: PUSH
91182: LD_INT 2
91184: NEG
91185: PUSH
91186: LD_INT 0
91188: PUSH
91189: EMPTY
91190: LIST
91191: LIST
91192: PUSH
91193: LD_INT 2
91195: NEG
91196: PUSH
91197: LD_INT 1
91199: NEG
91200: PUSH
91201: EMPTY
91202: LIST
91203: LIST
91204: PUSH
91205: LD_INT 2
91207: NEG
91208: PUSH
91209: LD_INT 2
91211: NEG
91212: PUSH
91213: EMPTY
91214: LIST
91215: LIST
91216: PUSH
91217: EMPTY
91218: LIST
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: LIST
91235: LIST
91236: LIST
91237: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91238: LD_ADDR_VAR 0 57
91242: PUSH
91243: LD_INT 0
91245: PUSH
91246: LD_INT 0
91248: PUSH
91249: EMPTY
91250: LIST
91251: LIST
91252: PUSH
91253: LD_INT 0
91255: PUSH
91256: LD_INT 1
91258: NEG
91259: PUSH
91260: EMPTY
91261: LIST
91262: LIST
91263: PUSH
91264: LD_INT 1
91266: PUSH
91267: LD_INT 0
91269: PUSH
91270: EMPTY
91271: LIST
91272: LIST
91273: PUSH
91274: LD_INT 1
91276: PUSH
91277: LD_INT 1
91279: PUSH
91280: EMPTY
91281: LIST
91282: LIST
91283: PUSH
91284: LD_INT 0
91286: PUSH
91287: LD_INT 1
91289: PUSH
91290: EMPTY
91291: LIST
91292: LIST
91293: PUSH
91294: LD_INT 1
91296: NEG
91297: PUSH
91298: LD_INT 0
91300: PUSH
91301: EMPTY
91302: LIST
91303: LIST
91304: PUSH
91305: LD_INT 1
91307: NEG
91308: PUSH
91309: LD_INT 1
91311: NEG
91312: PUSH
91313: EMPTY
91314: LIST
91315: LIST
91316: PUSH
91317: LD_INT 1
91319: NEG
91320: PUSH
91321: LD_INT 2
91323: NEG
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: PUSH
91329: LD_INT 0
91331: PUSH
91332: LD_INT 2
91334: NEG
91335: PUSH
91336: EMPTY
91337: LIST
91338: LIST
91339: PUSH
91340: LD_INT 1
91342: PUSH
91343: LD_INT 1
91345: NEG
91346: PUSH
91347: EMPTY
91348: LIST
91349: LIST
91350: PUSH
91351: LD_INT 2
91353: PUSH
91354: LD_INT 0
91356: PUSH
91357: EMPTY
91358: LIST
91359: LIST
91360: PUSH
91361: LD_INT 2
91363: PUSH
91364: LD_INT 1
91366: PUSH
91367: EMPTY
91368: LIST
91369: LIST
91370: PUSH
91371: LD_INT 2
91373: PUSH
91374: LD_INT 2
91376: PUSH
91377: EMPTY
91378: LIST
91379: LIST
91380: PUSH
91381: LD_INT 1
91383: PUSH
91384: LD_INT 2
91386: PUSH
91387: EMPTY
91388: LIST
91389: LIST
91390: PUSH
91391: LD_INT 0
91393: PUSH
91394: LD_INT 2
91396: PUSH
91397: EMPTY
91398: LIST
91399: LIST
91400: PUSH
91401: LD_INT 1
91403: NEG
91404: PUSH
91405: LD_INT 1
91407: PUSH
91408: EMPTY
91409: LIST
91410: LIST
91411: PUSH
91412: LD_INT 2
91414: NEG
91415: PUSH
91416: LD_INT 0
91418: PUSH
91419: EMPTY
91420: LIST
91421: LIST
91422: PUSH
91423: LD_INT 2
91425: NEG
91426: PUSH
91427: LD_INT 1
91429: NEG
91430: PUSH
91431: EMPTY
91432: LIST
91433: LIST
91434: PUSH
91435: LD_INT 2
91437: NEG
91438: PUSH
91439: LD_INT 2
91441: NEG
91442: PUSH
91443: EMPTY
91444: LIST
91445: LIST
91446: PUSH
91447: EMPTY
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
91468: LD_ADDR_VAR 0 58
91472: PUSH
91473: LD_INT 0
91475: PUSH
91476: LD_INT 0
91478: PUSH
91479: EMPTY
91480: LIST
91481: LIST
91482: PUSH
91483: LD_INT 0
91485: PUSH
91486: LD_INT 1
91488: NEG
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: PUSH
91494: LD_INT 1
91496: PUSH
91497: LD_INT 0
91499: PUSH
91500: EMPTY
91501: LIST
91502: LIST
91503: PUSH
91504: LD_INT 1
91506: PUSH
91507: LD_INT 1
91509: PUSH
91510: EMPTY
91511: LIST
91512: LIST
91513: PUSH
91514: LD_INT 0
91516: PUSH
91517: LD_INT 1
91519: PUSH
91520: EMPTY
91521: LIST
91522: LIST
91523: PUSH
91524: LD_INT 1
91526: NEG
91527: PUSH
91528: LD_INT 0
91530: PUSH
91531: EMPTY
91532: LIST
91533: LIST
91534: PUSH
91535: LD_INT 1
91537: NEG
91538: PUSH
91539: LD_INT 1
91541: NEG
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: PUSH
91547: LD_INT 1
91549: NEG
91550: PUSH
91551: LD_INT 2
91553: NEG
91554: PUSH
91555: EMPTY
91556: LIST
91557: LIST
91558: PUSH
91559: LD_INT 0
91561: PUSH
91562: LD_INT 2
91564: NEG
91565: PUSH
91566: EMPTY
91567: LIST
91568: LIST
91569: PUSH
91570: LD_INT 1
91572: PUSH
91573: LD_INT 1
91575: NEG
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 2
91583: PUSH
91584: LD_INT 0
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: PUSH
91591: LD_INT 2
91593: PUSH
91594: LD_INT 1
91596: PUSH
91597: EMPTY
91598: LIST
91599: LIST
91600: PUSH
91601: LD_INT 2
91603: PUSH
91604: LD_INT 2
91606: PUSH
91607: EMPTY
91608: LIST
91609: LIST
91610: PUSH
91611: LD_INT 1
91613: PUSH
91614: LD_INT 2
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: PUSH
91621: LD_INT 0
91623: PUSH
91624: LD_INT 2
91626: PUSH
91627: EMPTY
91628: LIST
91629: LIST
91630: PUSH
91631: LD_INT 1
91633: NEG
91634: PUSH
91635: LD_INT 1
91637: PUSH
91638: EMPTY
91639: LIST
91640: LIST
91641: PUSH
91642: LD_INT 2
91644: NEG
91645: PUSH
91646: LD_INT 0
91648: PUSH
91649: EMPTY
91650: LIST
91651: LIST
91652: PUSH
91653: LD_INT 2
91655: NEG
91656: PUSH
91657: LD_INT 1
91659: NEG
91660: PUSH
91661: EMPTY
91662: LIST
91663: LIST
91664: PUSH
91665: LD_INT 2
91667: NEG
91668: PUSH
91669: LD_INT 2
91671: NEG
91672: PUSH
91673: EMPTY
91674: LIST
91675: LIST
91676: PUSH
91677: EMPTY
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: LIST
91696: LIST
91697: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91698: LD_ADDR_VAR 0 59
91702: PUSH
91703: LD_INT 0
91705: PUSH
91706: LD_INT 0
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: PUSH
91713: LD_INT 0
91715: PUSH
91716: LD_INT 1
91718: NEG
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: PUSH
91724: LD_INT 1
91726: PUSH
91727: LD_INT 0
91729: PUSH
91730: EMPTY
91731: LIST
91732: LIST
91733: PUSH
91734: LD_INT 1
91736: PUSH
91737: LD_INT 1
91739: PUSH
91740: EMPTY
91741: LIST
91742: LIST
91743: PUSH
91744: LD_INT 0
91746: PUSH
91747: LD_INT 1
91749: PUSH
91750: EMPTY
91751: LIST
91752: LIST
91753: PUSH
91754: LD_INT 1
91756: NEG
91757: PUSH
91758: LD_INT 0
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PUSH
91765: LD_INT 1
91767: NEG
91768: PUSH
91769: LD_INT 1
91771: NEG
91772: PUSH
91773: EMPTY
91774: LIST
91775: LIST
91776: PUSH
91777: EMPTY
91778: LIST
91779: LIST
91780: LIST
91781: LIST
91782: LIST
91783: LIST
91784: LIST
91785: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91786: LD_ADDR_VAR 0 60
91790: PUSH
91791: LD_INT 0
91793: PUSH
91794: LD_INT 0
91796: PUSH
91797: EMPTY
91798: LIST
91799: LIST
91800: PUSH
91801: LD_INT 0
91803: PUSH
91804: LD_INT 1
91806: NEG
91807: PUSH
91808: EMPTY
91809: LIST
91810: LIST
91811: PUSH
91812: LD_INT 1
91814: PUSH
91815: LD_INT 0
91817: PUSH
91818: EMPTY
91819: LIST
91820: LIST
91821: PUSH
91822: LD_INT 1
91824: PUSH
91825: LD_INT 1
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: PUSH
91832: LD_INT 0
91834: PUSH
91835: LD_INT 1
91837: PUSH
91838: EMPTY
91839: LIST
91840: LIST
91841: PUSH
91842: LD_INT 1
91844: NEG
91845: PUSH
91846: LD_INT 0
91848: PUSH
91849: EMPTY
91850: LIST
91851: LIST
91852: PUSH
91853: LD_INT 1
91855: NEG
91856: PUSH
91857: LD_INT 1
91859: NEG
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: PUSH
91865: EMPTY
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91874: LD_ADDR_VAR 0 61
91878: PUSH
91879: LD_INT 0
91881: PUSH
91882: LD_INT 0
91884: PUSH
91885: EMPTY
91886: LIST
91887: LIST
91888: PUSH
91889: LD_INT 0
91891: PUSH
91892: LD_INT 1
91894: NEG
91895: PUSH
91896: EMPTY
91897: LIST
91898: LIST
91899: PUSH
91900: LD_INT 1
91902: PUSH
91903: LD_INT 0
91905: PUSH
91906: EMPTY
91907: LIST
91908: LIST
91909: PUSH
91910: LD_INT 1
91912: PUSH
91913: LD_INT 1
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: LD_INT 0
91922: PUSH
91923: LD_INT 1
91925: PUSH
91926: EMPTY
91927: LIST
91928: LIST
91929: PUSH
91930: LD_INT 1
91932: NEG
91933: PUSH
91934: LD_INT 0
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: LD_INT 1
91943: NEG
91944: PUSH
91945: LD_INT 1
91947: NEG
91948: PUSH
91949: EMPTY
91950: LIST
91951: LIST
91952: PUSH
91953: EMPTY
91954: LIST
91955: LIST
91956: LIST
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91962: LD_ADDR_VAR 0 62
91966: PUSH
91967: LD_INT 0
91969: PUSH
91970: LD_INT 0
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: PUSH
91977: LD_INT 0
91979: PUSH
91980: LD_INT 1
91982: NEG
91983: PUSH
91984: EMPTY
91985: LIST
91986: LIST
91987: PUSH
91988: LD_INT 1
91990: PUSH
91991: LD_INT 0
91993: PUSH
91994: EMPTY
91995: LIST
91996: LIST
91997: PUSH
91998: LD_INT 1
92000: PUSH
92001: LD_INT 1
92003: PUSH
92004: EMPTY
92005: LIST
92006: LIST
92007: PUSH
92008: LD_INT 0
92010: PUSH
92011: LD_INT 1
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: LD_INT 1
92020: NEG
92021: PUSH
92022: LD_INT 0
92024: PUSH
92025: EMPTY
92026: LIST
92027: LIST
92028: PUSH
92029: LD_INT 1
92031: NEG
92032: PUSH
92033: LD_INT 1
92035: NEG
92036: PUSH
92037: EMPTY
92038: LIST
92039: LIST
92040: PUSH
92041: EMPTY
92042: LIST
92043: LIST
92044: LIST
92045: LIST
92046: LIST
92047: LIST
92048: LIST
92049: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92050: LD_ADDR_VAR 0 63
92054: PUSH
92055: LD_INT 0
92057: PUSH
92058: LD_INT 0
92060: PUSH
92061: EMPTY
92062: LIST
92063: LIST
92064: PUSH
92065: LD_INT 0
92067: PUSH
92068: LD_INT 1
92070: NEG
92071: PUSH
92072: EMPTY
92073: LIST
92074: LIST
92075: PUSH
92076: LD_INT 1
92078: PUSH
92079: LD_INT 0
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: LD_INT 1
92088: PUSH
92089: LD_INT 1
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 0
92098: PUSH
92099: LD_INT 1
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: PUSH
92106: LD_INT 1
92108: NEG
92109: PUSH
92110: LD_INT 0
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: PUSH
92117: LD_INT 1
92119: NEG
92120: PUSH
92121: LD_INT 1
92123: NEG
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: PUSH
92129: EMPTY
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
92138: LD_ADDR_VAR 0 64
92142: PUSH
92143: LD_INT 0
92145: PUSH
92146: LD_INT 0
92148: PUSH
92149: EMPTY
92150: LIST
92151: LIST
92152: PUSH
92153: LD_INT 0
92155: PUSH
92156: LD_INT 1
92158: NEG
92159: PUSH
92160: EMPTY
92161: LIST
92162: LIST
92163: PUSH
92164: LD_INT 1
92166: PUSH
92167: LD_INT 0
92169: PUSH
92170: EMPTY
92171: LIST
92172: LIST
92173: PUSH
92174: LD_INT 1
92176: PUSH
92177: LD_INT 1
92179: PUSH
92180: EMPTY
92181: LIST
92182: LIST
92183: PUSH
92184: LD_INT 0
92186: PUSH
92187: LD_INT 1
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PUSH
92194: LD_INT 1
92196: NEG
92197: PUSH
92198: LD_INT 0
92200: PUSH
92201: EMPTY
92202: LIST
92203: LIST
92204: PUSH
92205: LD_INT 1
92207: NEG
92208: PUSH
92209: LD_INT 1
92211: NEG
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: LIST
92221: LIST
92222: LIST
92223: LIST
92224: LIST
92225: ST_TO_ADDR
// end ; 1 :
92226: GO 98123
92228: LD_INT 1
92230: DOUBLE
92231: EQUAL
92232: IFTRUE 92236
92234: GO 94859
92236: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92237: LD_ADDR_VAR 0 11
92241: PUSH
92242: LD_INT 1
92244: NEG
92245: PUSH
92246: LD_INT 3
92248: NEG
92249: PUSH
92250: EMPTY
92251: LIST
92252: LIST
92253: PUSH
92254: LD_INT 0
92256: PUSH
92257: LD_INT 3
92259: NEG
92260: PUSH
92261: EMPTY
92262: LIST
92263: LIST
92264: PUSH
92265: LD_INT 1
92267: PUSH
92268: LD_INT 2
92270: NEG
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: PUSH
92276: EMPTY
92277: LIST
92278: LIST
92279: LIST
92280: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92281: LD_ADDR_VAR 0 12
92285: PUSH
92286: LD_INT 2
92288: PUSH
92289: LD_INT 1
92291: NEG
92292: PUSH
92293: EMPTY
92294: LIST
92295: LIST
92296: PUSH
92297: LD_INT 3
92299: PUSH
92300: LD_INT 0
92302: PUSH
92303: EMPTY
92304: LIST
92305: LIST
92306: PUSH
92307: LD_INT 3
92309: PUSH
92310: LD_INT 1
92312: PUSH
92313: EMPTY
92314: LIST
92315: LIST
92316: PUSH
92317: EMPTY
92318: LIST
92319: LIST
92320: LIST
92321: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92322: LD_ADDR_VAR 0 13
92326: PUSH
92327: LD_INT 3
92329: PUSH
92330: LD_INT 2
92332: PUSH
92333: EMPTY
92334: LIST
92335: LIST
92336: PUSH
92337: LD_INT 3
92339: PUSH
92340: LD_INT 3
92342: PUSH
92343: EMPTY
92344: LIST
92345: LIST
92346: PUSH
92347: LD_INT 2
92349: PUSH
92350: LD_INT 3
92352: PUSH
92353: EMPTY
92354: LIST
92355: LIST
92356: PUSH
92357: EMPTY
92358: LIST
92359: LIST
92360: LIST
92361: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92362: LD_ADDR_VAR 0 14
92366: PUSH
92367: LD_INT 1
92369: PUSH
92370: LD_INT 3
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: PUSH
92377: LD_INT 0
92379: PUSH
92380: LD_INT 3
92382: PUSH
92383: EMPTY
92384: LIST
92385: LIST
92386: PUSH
92387: LD_INT 1
92389: NEG
92390: PUSH
92391: LD_INT 2
92393: PUSH
92394: EMPTY
92395: LIST
92396: LIST
92397: PUSH
92398: EMPTY
92399: LIST
92400: LIST
92401: LIST
92402: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92403: LD_ADDR_VAR 0 15
92407: PUSH
92408: LD_INT 2
92410: NEG
92411: PUSH
92412: LD_INT 1
92414: PUSH
92415: EMPTY
92416: LIST
92417: LIST
92418: PUSH
92419: LD_INT 3
92421: NEG
92422: PUSH
92423: LD_INT 0
92425: PUSH
92426: EMPTY
92427: LIST
92428: LIST
92429: PUSH
92430: LD_INT 3
92432: NEG
92433: PUSH
92434: LD_INT 1
92436: NEG
92437: PUSH
92438: EMPTY
92439: LIST
92440: LIST
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: LIST
92446: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92447: LD_ADDR_VAR 0 16
92451: PUSH
92452: LD_INT 2
92454: NEG
92455: PUSH
92456: LD_INT 3
92458: NEG
92459: PUSH
92460: EMPTY
92461: LIST
92462: LIST
92463: PUSH
92464: LD_INT 3
92466: NEG
92467: PUSH
92468: LD_INT 2
92470: NEG
92471: PUSH
92472: EMPTY
92473: LIST
92474: LIST
92475: PUSH
92476: LD_INT 3
92478: NEG
92479: PUSH
92480: LD_INT 3
92482: NEG
92483: PUSH
92484: EMPTY
92485: LIST
92486: LIST
92487: PUSH
92488: EMPTY
92489: LIST
92490: LIST
92491: LIST
92492: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
92493: LD_ADDR_VAR 0 17
92497: PUSH
92498: LD_INT 1
92500: NEG
92501: PUSH
92502: LD_INT 3
92504: NEG
92505: PUSH
92506: EMPTY
92507: LIST
92508: LIST
92509: PUSH
92510: LD_INT 0
92512: PUSH
92513: LD_INT 3
92515: NEG
92516: PUSH
92517: EMPTY
92518: LIST
92519: LIST
92520: PUSH
92521: LD_INT 1
92523: PUSH
92524: LD_INT 2
92526: NEG
92527: PUSH
92528: EMPTY
92529: LIST
92530: LIST
92531: PUSH
92532: EMPTY
92533: LIST
92534: LIST
92535: LIST
92536: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
92537: LD_ADDR_VAR 0 18
92541: PUSH
92542: LD_INT 2
92544: PUSH
92545: LD_INT 1
92547: NEG
92548: PUSH
92549: EMPTY
92550: LIST
92551: LIST
92552: PUSH
92553: LD_INT 3
92555: PUSH
92556: LD_INT 0
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: PUSH
92563: LD_INT 3
92565: PUSH
92566: LD_INT 1
92568: PUSH
92569: EMPTY
92570: LIST
92571: LIST
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: LIST
92577: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
92578: LD_ADDR_VAR 0 19
92582: PUSH
92583: LD_INT 3
92585: PUSH
92586: LD_INT 2
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: PUSH
92593: LD_INT 3
92595: PUSH
92596: LD_INT 3
92598: PUSH
92599: EMPTY
92600: LIST
92601: LIST
92602: PUSH
92603: LD_INT 2
92605: PUSH
92606: LD_INT 3
92608: PUSH
92609: EMPTY
92610: LIST
92611: LIST
92612: PUSH
92613: EMPTY
92614: LIST
92615: LIST
92616: LIST
92617: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92618: LD_ADDR_VAR 0 20
92622: PUSH
92623: LD_INT 1
92625: PUSH
92626: LD_INT 3
92628: PUSH
92629: EMPTY
92630: LIST
92631: LIST
92632: PUSH
92633: LD_INT 0
92635: PUSH
92636: LD_INT 3
92638: PUSH
92639: EMPTY
92640: LIST
92641: LIST
92642: PUSH
92643: LD_INT 1
92645: NEG
92646: PUSH
92647: LD_INT 2
92649: PUSH
92650: EMPTY
92651: LIST
92652: LIST
92653: PUSH
92654: EMPTY
92655: LIST
92656: LIST
92657: LIST
92658: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92659: LD_ADDR_VAR 0 21
92663: PUSH
92664: LD_INT 2
92666: NEG
92667: PUSH
92668: LD_INT 1
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: LD_INT 3
92677: NEG
92678: PUSH
92679: LD_INT 0
92681: PUSH
92682: EMPTY
92683: LIST
92684: LIST
92685: PUSH
92686: LD_INT 3
92688: NEG
92689: PUSH
92690: LD_INT 1
92692: NEG
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: LIST
92702: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92703: LD_ADDR_VAR 0 22
92707: PUSH
92708: LD_INT 2
92710: NEG
92711: PUSH
92712: LD_INT 3
92714: NEG
92715: PUSH
92716: EMPTY
92717: LIST
92718: LIST
92719: PUSH
92720: LD_INT 3
92722: NEG
92723: PUSH
92724: LD_INT 2
92726: NEG
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: PUSH
92732: LD_INT 3
92734: NEG
92735: PUSH
92736: LD_INT 3
92738: NEG
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: PUSH
92744: EMPTY
92745: LIST
92746: LIST
92747: LIST
92748: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92749: LD_ADDR_VAR 0 23
92753: PUSH
92754: LD_INT 0
92756: PUSH
92757: LD_INT 3
92759: NEG
92760: PUSH
92761: EMPTY
92762: LIST
92763: LIST
92764: PUSH
92765: LD_INT 1
92767: NEG
92768: PUSH
92769: LD_INT 4
92771: NEG
92772: PUSH
92773: EMPTY
92774: LIST
92775: LIST
92776: PUSH
92777: LD_INT 1
92779: PUSH
92780: LD_INT 3
92782: NEG
92783: PUSH
92784: EMPTY
92785: LIST
92786: LIST
92787: PUSH
92788: EMPTY
92789: LIST
92790: LIST
92791: LIST
92792: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92793: LD_ADDR_VAR 0 24
92797: PUSH
92798: LD_INT 3
92800: PUSH
92801: LD_INT 0
92803: PUSH
92804: EMPTY
92805: LIST
92806: LIST
92807: PUSH
92808: LD_INT 3
92810: PUSH
92811: LD_INT 1
92813: NEG
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: PUSH
92819: LD_INT 4
92821: PUSH
92822: LD_INT 1
92824: PUSH
92825: EMPTY
92826: LIST
92827: LIST
92828: PUSH
92829: EMPTY
92830: LIST
92831: LIST
92832: LIST
92833: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92834: LD_ADDR_VAR 0 25
92838: PUSH
92839: LD_INT 3
92841: PUSH
92842: LD_INT 3
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: PUSH
92849: LD_INT 4
92851: PUSH
92852: LD_INT 3
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: LD_INT 3
92861: PUSH
92862: LD_INT 4
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: PUSH
92869: EMPTY
92870: LIST
92871: LIST
92872: LIST
92873: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92874: LD_ADDR_VAR 0 26
92878: PUSH
92879: LD_INT 0
92881: PUSH
92882: LD_INT 3
92884: PUSH
92885: EMPTY
92886: LIST
92887: LIST
92888: PUSH
92889: LD_INT 1
92891: PUSH
92892: LD_INT 4
92894: PUSH
92895: EMPTY
92896: LIST
92897: LIST
92898: PUSH
92899: LD_INT 1
92901: NEG
92902: PUSH
92903: LD_INT 3
92905: PUSH
92906: EMPTY
92907: LIST
92908: LIST
92909: PUSH
92910: EMPTY
92911: LIST
92912: LIST
92913: LIST
92914: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92915: LD_ADDR_VAR 0 27
92919: PUSH
92920: LD_INT 3
92922: NEG
92923: PUSH
92924: LD_INT 0
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PUSH
92931: LD_INT 3
92933: NEG
92934: PUSH
92935: LD_INT 1
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: PUSH
92942: LD_INT 4
92944: NEG
92945: PUSH
92946: LD_INT 1
92948: NEG
92949: PUSH
92950: EMPTY
92951: LIST
92952: LIST
92953: PUSH
92954: EMPTY
92955: LIST
92956: LIST
92957: LIST
92958: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92959: LD_ADDR_VAR 0 28
92963: PUSH
92964: LD_INT 3
92966: NEG
92967: PUSH
92968: LD_INT 3
92970: NEG
92971: PUSH
92972: EMPTY
92973: LIST
92974: LIST
92975: PUSH
92976: LD_INT 3
92978: NEG
92979: PUSH
92980: LD_INT 4
92982: NEG
92983: PUSH
92984: EMPTY
92985: LIST
92986: LIST
92987: PUSH
92988: LD_INT 4
92990: NEG
92991: PUSH
92992: LD_INT 3
92994: NEG
92995: PUSH
92996: EMPTY
92997: LIST
92998: LIST
92999: PUSH
93000: EMPTY
93001: LIST
93002: LIST
93003: LIST
93004: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
93005: LD_ADDR_VAR 0 29
93009: PUSH
93010: LD_INT 1
93012: NEG
93013: PUSH
93014: LD_INT 3
93016: NEG
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 0
93024: PUSH
93025: LD_INT 3
93027: NEG
93028: PUSH
93029: EMPTY
93030: LIST
93031: LIST
93032: PUSH
93033: LD_INT 1
93035: PUSH
93036: LD_INT 2
93038: NEG
93039: PUSH
93040: EMPTY
93041: LIST
93042: LIST
93043: PUSH
93044: LD_INT 1
93046: NEG
93047: PUSH
93048: LD_INT 4
93050: NEG
93051: PUSH
93052: EMPTY
93053: LIST
93054: LIST
93055: PUSH
93056: LD_INT 0
93058: PUSH
93059: LD_INT 4
93061: NEG
93062: PUSH
93063: EMPTY
93064: LIST
93065: LIST
93066: PUSH
93067: LD_INT 1
93069: PUSH
93070: LD_INT 3
93072: NEG
93073: PUSH
93074: EMPTY
93075: LIST
93076: LIST
93077: PUSH
93078: LD_INT 1
93080: NEG
93081: PUSH
93082: LD_INT 5
93084: NEG
93085: PUSH
93086: EMPTY
93087: LIST
93088: LIST
93089: PUSH
93090: LD_INT 0
93092: PUSH
93093: LD_INT 5
93095: NEG
93096: PUSH
93097: EMPTY
93098: LIST
93099: LIST
93100: PUSH
93101: LD_INT 1
93103: PUSH
93104: LD_INT 4
93106: NEG
93107: PUSH
93108: EMPTY
93109: LIST
93110: LIST
93111: PUSH
93112: LD_INT 1
93114: NEG
93115: PUSH
93116: LD_INT 6
93118: NEG
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: PUSH
93124: LD_INT 0
93126: PUSH
93127: LD_INT 6
93129: NEG
93130: PUSH
93131: EMPTY
93132: LIST
93133: LIST
93134: PUSH
93135: LD_INT 1
93137: PUSH
93138: LD_INT 5
93140: NEG
93141: PUSH
93142: EMPTY
93143: LIST
93144: LIST
93145: PUSH
93146: EMPTY
93147: LIST
93148: LIST
93149: LIST
93150: LIST
93151: LIST
93152: LIST
93153: LIST
93154: LIST
93155: LIST
93156: LIST
93157: LIST
93158: LIST
93159: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
93160: LD_ADDR_VAR 0 30
93164: PUSH
93165: LD_INT 2
93167: PUSH
93168: LD_INT 1
93170: NEG
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: PUSH
93176: LD_INT 3
93178: PUSH
93179: LD_INT 0
93181: PUSH
93182: EMPTY
93183: LIST
93184: LIST
93185: PUSH
93186: LD_INT 3
93188: PUSH
93189: LD_INT 1
93191: PUSH
93192: EMPTY
93193: LIST
93194: LIST
93195: PUSH
93196: LD_INT 3
93198: PUSH
93199: LD_INT 1
93201: NEG
93202: PUSH
93203: EMPTY
93204: LIST
93205: LIST
93206: PUSH
93207: LD_INT 4
93209: PUSH
93210: LD_INT 0
93212: PUSH
93213: EMPTY
93214: LIST
93215: LIST
93216: PUSH
93217: LD_INT 4
93219: PUSH
93220: LD_INT 1
93222: PUSH
93223: EMPTY
93224: LIST
93225: LIST
93226: PUSH
93227: LD_INT 4
93229: PUSH
93230: LD_INT 1
93232: NEG
93233: PUSH
93234: EMPTY
93235: LIST
93236: LIST
93237: PUSH
93238: LD_INT 5
93240: PUSH
93241: LD_INT 0
93243: PUSH
93244: EMPTY
93245: LIST
93246: LIST
93247: PUSH
93248: LD_INT 5
93250: PUSH
93251: LD_INT 1
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: PUSH
93258: LD_INT 5
93260: PUSH
93261: LD_INT 1
93263: NEG
93264: PUSH
93265: EMPTY
93266: LIST
93267: LIST
93268: PUSH
93269: LD_INT 6
93271: PUSH
93272: LD_INT 0
93274: PUSH
93275: EMPTY
93276: LIST
93277: LIST
93278: PUSH
93279: LD_INT 6
93281: PUSH
93282: LD_INT 1
93284: PUSH
93285: EMPTY
93286: LIST
93287: LIST
93288: PUSH
93289: EMPTY
93290: LIST
93291: LIST
93292: LIST
93293: LIST
93294: LIST
93295: LIST
93296: LIST
93297: LIST
93298: LIST
93299: LIST
93300: LIST
93301: LIST
93302: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
93303: LD_ADDR_VAR 0 31
93307: PUSH
93308: LD_INT 3
93310: PUSH
93311: LD_INT 2
93313: PUSH
93314: EMPTY
93315: LIST
93316: LIST
93317: PUSH
93318: LD_INT 3
93320: PUSH
93321: LD_INT 3
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: PUSH
93328: LD_INT 2
93330: PUSH
93331: LD_INT 3
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: PUSH
93338: LD_INT 4
93340: PUSH
93341: LD_INT 3
93343: PUSH
93344: EMPTY
93345: LIST
93346: LIST
93347: PUSH
93348: LD_INT 4
93350: PUSH
93351: LD_INT 4
93353: PUSH
93354: EMPTY
93355: LIST
93356: LIST
93357: PUSH
93358: LD_INT 3
93360: PUSH
93361: LD_INT 4
93363: PUSH
93364: EMPTY
93365: LIST
93366: LIST
93367: PUSH
93368: LD_INT 5
93370: PUSH
93371: LD_INT 4
93373: PUSH
93374: EMPTY
93375: LIST
93376: LIST
93377: PUSH
93378: LD_INT 5
93380: PUSH
93381: LD_INT 5
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: PUSH
93388: LD_INT 4
93390: PUSH
93391: LD_INT 5
93393: PUSH
93394: EMPTY
93395: LIST
93396: LIST
93397: PUSH
93398: LD_INT 6
93400: PUSH
93401: LD_INT 5
93403: PUSH
93404: EMPTY
93405: LIST
93406: LIST
93407: PUSH
93408: LD_INT 6
93410: PUSH
93411: LD_INT 6
93413: PUSH
93414: EMPTY
93415: LIST
93416: LIST
93417: PUSH
93418: LD_INT 5
93420: PUSH
93421: LD_INT 6
93423: PUSH
93424: EMPTY
93425: LIST
93426: LIST
93427: PUSH
93428: EMPTY
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: LIST
93441: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
93442: LD_ADDR_VAR 0 32
93446: PUSH
93447: LD_INT 1
93449: PUSH
93450: LD_INT 3
93452: PUSH
93453: EMPTY
93454: LIST
93455: LIST
93456: PUSH
93457: LD_INT 0
93459: PUSH
93460: LD_INT 3
93462: PUSH
93463: EMPTY
93464: LIST
93465: LIST
93466: PUSH
93467: LD_INT 1
93469: NEG
93470: PUSH
93471: LD_INT 2
93473: PUSH
93474: EMPTY
93475: LIST
93476: LIST
93477: PUSH
93478: LD_INT 1
93480: PUSH
93481: LD_INT 4
93483: PUSH
93484: EMPTY
93485: LIST
93486: LIST
93487: PUSH
93488: LD_INT 0
93490: PUSH
93491: LD_INT 4
93493: PUSH
93494: EMPTY
93495: LIST
93496: LIST
93497: PUSH
93498: LD_INT 1
93500: NEG
93501: PUSH
93502: LD_INT 3
93504: PUSH
93505: EMPTY
93506: LIST
93507: LIST
93508: PUSH
93509: LD_INT 1
93511: PUSH
93512: LD_INT 5
93514: PUSH
93515: EMPTY
93516: LIST
93517: LIST
93518: PUSH
93519: LD_INT 0
93521: PUSH
93522: LD_INT 5
93524: PUSH
93525: EMPTY
93526: LIST
93527: LIST
93528: PUSH
93529: LD_INT 1
93531: NEG
93532: PUSH
93533: LD_INT 4
93535: PUSH
93536: EMPTY
93537: LIST
93538: LIST
93539: PUSH
93540: LD_INT 1
93542: PUSH
93543: LD_INT 6
93545: PUSH
93546: EMPTY
93547: LIST
93548: LIST
93549: PUSH
93550: LD_INT 0
93552: PUSH
93553: LD_INT 6
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: PUSH
93560: LD_INT 1
93562: NEG
93563: PUSH
93564: LD_INT 5
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: PUSH
93571: EMPTY
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
93585: LD_ADDR_VAR 0 33
93589: PUSH
93590: LD_INT 2
93592: NEG
93593: PUSH
93594: LD_INT 1
93596: PUSH
93597: EMPTY
93598: LIST
93599: LIST
93600: PUSH
93601: LD_INT 3
93603: NEG
93604: PUSH
93605: LD_INT 0
93607: PUSH
93608: EMPTY
93609: LIST
93610: LIST
93611: PUSH
93612: LD_INT 3
93614: NEG
93615: PUSH
93616: LD_INT 1
93618: NEG
93619: PUSH
93620: EMPTY
93621: LIST
93622: LIST
93623: PUSH
93624: LD_INT 3
93626: NEG
93627: PUSH
93628: LD_INT 1
93630: PUSH
93631: EMPTY
93632: LIST
93633: LIST
93634: PUSH
93635: LD_INT 4
93637: NEG
93638: PUSH
93639: LD_INT 0
93641: PUSH
93642: EMPTY
93643: LIST
93644: LIST
93645: PUSH
93646: LD_INT 4
93648: NEG
93649: PUSH
93650: LD_INT 1
93652: NEG
93653: PUSH
93654: EMPTY
93655: LIST
93656: LIST
93657: PUSH
93658: LD_INT 4
93660: NEG
93661: PUSH
93662: LD_INT 1
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: PUSH
93669: LD_INT 5
93671: NEG
93672: PUSH
93673: LD_INT 0
93675: PUSH
93676: EMPTY
93677: LIST
93678: LIST
93679: PUSH
93680: LD_INT 5
93682: NEG
93683: PUSH
93684: LD_INT 1
93686: NEG
93687: PUSH
93688: EMPTY
93689: LIST
93690: LIST
93691: PUSH
93692: LD_INT 5
93694: NEG
93695: PUSH
93696: LD_INT 1
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: PUSH
93703: LD_INT 6
93705: NEG
93706: PUSH
93707: LD_INT 0
93709: PUSH
93710: EMPTY
93711: LIST
93712: LIST
93713: PUSH
93714: LD_INT 6
93716: NEG
93717: PUSH
93718: LD_INT 1
93720: NEG
93721: PUSH
93722: EMPTY
93723: LIST
93724: LIST
93725: PUSH
93726: EMPTY
93727: LIST
93728: LIST
93729: LIST
93730: LIST
93731: LIST
93732: LIST
93733: LIST
93734: LIST
93735: LIST
93736: LIST
93737: LIST
93738: LIST
93739: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93740: LD_ADDR_VAR 0 34
93744: PUSH
93745: LD_INT 2
93747: NEG
93748: PUSH
93749: LD_INT 3
93751: NEG
93752: PUSH
93753: EMPTY
93754: LIST
93755: LIST
93756: PUSH
93757: LD_INT 3
93759: NEG
93760: PUSH
93761: LD_INT 2
93763: NEG
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: PUSH
93769: LD_INT 3
93771: NEG
93772: PUSH
93773: LD_INT 3
93775: NEG
93776: PUSH
93777: EMPTY
93778: LIST
93779: LIST
93780: PUSH
93781: LD_INT 3
93783: NEG
93784: PUSH
93785: LD_INT 4
93787: NEG
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: LD_INT 4
93795: NEG
93796: PUSH
93797: LD_INT 3
93799: NEG
93800: PUSH
93801: EMPTY
93802: LIST
93803: LIST
93804: PUSH
93805: LD_INT 4
93807: NEG
93808: PUSH
93809: LD_INT 4
93811: NEG
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: PUSH
93817: LD_INT 4
93819: NEG
93820: PUSH
93821: LD_INT 5
93823: NEG
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PUSH
93829: LD_INT 5
93831: NEG
93832: PUSH
93833: LD_INT 4
93835: NEG
93836: PUSH
93837: EMPTY
93838: LIST
93839: LIST
93840: PUSH
93841: LD_INT 5
93843: NEG
93844: PUSH
93845: LD_INT 5
93847: NEG
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: LD_INT 5
93855: NEG
93856: PUSH
93857: LD_INT 6
93859: NEG
93860: PUSH
93861: EMPTY
93862: LIST
93863: LIST
93864: PUSH
93865: LD_INT 6
93867: NEG
93868: PUSH
93869: LD_INT 5
93871: NEG
93872: PUSH
93873: EMPTY
93874: LIST
93875: LIST
93876: PUSH
93877: LD_INT 6
93879: NEG
93880: PUSH
93881: LD_INT 6
93883: NEG
93884: PUSH
93885: EMPTY
93886: LIST
93887: LIST
93888: PUSH
93889: EMPTY
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93903: LD_ADDR_VAR 0 41
93907: PUSH
93908: LD_INT 0
93910: PUSH
93911: LD_INT 2
93913: NEG
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: PUSH
93919: LD_INT 1
93921: NEG
93922: PUSH
93923: LD_INT 3
93925: NEG
93926: PUSH
93927: EMPTY
93928: LIST
93929: LIST
93930: PUSH
93931: LD_INT 1
93933: PUSH
93934: LD_INT 2
93936: NEG
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: PUSH
93942: EMPTY
93943: LIST
93944: LIST
93945: LIST
93946: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93947: LD_ADDR_VAR 0 42
93951: PUSH
93952: LD_INT 2
93954: PUSH
93955: LD_INT 0
93957: PUSH
93958: EMPTY
93959: LIST
93960: LIST
93961: PUSH
93962: LD_INT 2
93964: PUSH
93965: LD_INT 1
93967: NEG
93968: PUSH
93969: EMPTY
93970: LIST
93971: LIST
93972: PUSH
93973: LD_INT 3
93975: PUSH
93976: LD_INT 1
93978: PUSH
93979: EMPTY
93980: LIST
93981: LIST
93982: PUSH
93983: EMPTY
93984: LIST
93985: LIST
93986: LIST
93987: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93988: LD_ADDR_VAR 0 43
93992: PUSH
93993: LD_INT 2
93995: PUSH
93996: LD_INT 2
93998: PUSH
93999: EMPTY
94000: LIST
94001: LIST
94002: PUSH
94003: LD_INT 3
94005: PUSH
94006: LD_INT 2
94008: PUSH
94009: EMPTY
94010: LIST
94011: LIST
94012: PUSH
94013: LD_INT 2
94015: PUSH
94016: LD_INT 3
94018: PUSH
94019: EMPTY
94020: LIST
94021: LIST
94022: PUSH
94023: EMPTY
94024: LIST
94025: LIST
94026: LIST
94027: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
94028: LD_ADDR_VAR 0 44
94032: PUSH
94033: LD_INT 0
94035: PUSH
94036: LD_INT 2
94038: PUSH
94039: EMPTY
94040: LIST
94041: LIST
94042: PUSH
94043: LD_INT 1
94045: PUSH
94046: LD_INT 3
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: PUSH
94053: LD_INT 1
94055: NEG
94056: PUSH
94057: LD_INT 2
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PUSH
94064: EMPTY
94065: LIST
94066: LIST
94067: LIST
94068: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
94069: LD_ADDR_VAR 0 45
94073: PUSH
94074: LD_INT 2
94076: NEG
94077: PUSH
94078: LD_INT 0
94080: PUSH
94081: EMPTY
94082: LIST
94083: LIST
94084: PUSH
94085: LD_INT 2
94087: NEG
94088: PUSH
94089: LD_INT 1
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: PUSH
94096: LD_INT 3
94098: NEG
94099: PUSH
94100: LD_INT 1
94102: NEG
94103: PUSH
94104: EMPTY
94105: LIST
94106: LIST
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: LIST
94112: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
94113: LD_ADDR_VAR 0 46
94117: PUSH
94118: LD_INT 2
94120: NEG
94121: PUSH
94122: LD_INT 2
94124: NEG
94125: PUSH
94126: EMPTY
94127: LIST
94128: LIST
94129: PUSH
94130: LD_INT 2
94132: NEG
94133: PUSH
94134: LD_INT 3
94136: NEG
94137: PUSH
94138: EMPTY
94139: LIST
94140: LIST
94141: PUSH
94142: LD_INT 3
94144: NEG
94145: PUSH
94146: LD_INT 2
94148: NEG
94149: PUSH
94150: EMPTY
94151: LIST
94152: LIST
94153: PUSH
94154: EMPTY
94155: LIST
94156: LIST
94157: LIST
94158: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
94159: LD_ADDR_VAR 0 47
94163: PUSH
94164: LD_INT 2
94166: NEG
94167: PUSH
94168: LD_INT 3
94170: NEG
94171: PUSH
94172: EMPTY
94173: LIST
94174: LIST
94175: PUSH
94176: LD_INT 1
94178: NEG
94179: PUSH
94180: LD_INT 3
94182: NEG
94183: PUSH
94184: EMPTY
94185: LIST
94186: LIST
94187: PUSH
94188: EMPTY
94189: LIST
94190: LIST
94191: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
94192: LD_ADDR_VAR 0 48
94196: PUSH
94197: LD_INT 1
94199: PUSH
94200: LD_INT 2
94202: NEG
94203: PUSH
94204: EMPTY
94205: LIST
94206: LIST
94207: PUSH
94208: LD_INT 2
94210: PUSH
94211: LD_INT 1
94213: NEG
94214: PUSH
94215: EMPTY
94216: LIST
94217: LIST
94218: PUSH
94219: EMPTY
94220: LIST
94221: LIST
94222: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
94223: LD_ADDR_VAR 0 49
94227: PUSH
94228: LD_INT 3
94230: PUSH
94231: LD_INT 1
94233: PUSH
94234: EMPTY
94235: LIST
94236: LIST
94237: PUSH
94238: LD_INT 3
94240: PUSH
94241: LD_INT 2
94243: PUSH
94244: EMPTY
94245: LIST
94246: LIST
94247: PUSH
94248: EMPTY
94249: LIST
94250: LIST
94251: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
94252: LD_ADDR_VAR 0 50
94256: PUSH
94257: LD_INT 2
94259: PUSH
94260: LD_INT 3
94262: PUSH
94263: EMPTY
94264: LIST
94265: LIST
94266: PUSH
94267: LD_INT 1
94269: PUSH
94270: LD_INT 3
94272: PUSH
94273: EMPTY
94274: LIST
94275: LIST
94276: PUSH
94277: EMPTY
94278: LIST
94279: LIST
94280: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
94281: LD_ADDR_VAR 0 51
94285: PUSH
94286: LD_INT 1
94288: NEG
94289: PUSH
94290: LD_INT 2
94292: PUSH
94293: EMPTY
94294: LIST
94295: LIST
94296: PUSH
94297: LD_INT 2
94299: NEG
94300: PUSH
94301: LD_INT 1
94303: PUSH
94304: EMPTY
94305: LIST
94306: LIST
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
94312: LD_ADDR_VAR 0 52
94316: PUSH
94317: LD_INT 3
94319: NEG
94320: PUSH
94321: LD_INT 1
94323: NEG
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: PUSH
94329: LD_INT 3
94331: NEG
94332: PUSH
94333: LD_INT 2
94335: NEG
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: PUSH
94341: EMPTY
94342: LIST
94343: LIST
94344: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
94345: LD_ADDR_VAR 0 53
94349: PUSH
94350: LD_INT 1
94352: NEG
94353: PUSH
94354: LD_INT 3
94356: NEG
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PUSH
94362: LD_INT 0
94364: PUSH
94365: LD_INT 3
94367: NEG
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: PUSH
94373: LD_INT 1
94375: PUSH
94376: LD_INT 2
94378: NEG
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: EMPTY
94385: LIST
94386: LIST
94387: LIST
94388: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
94389: LD_ADDR_VAR 0 54
94393: PUSH
94394: LD_INT 2
94396: PUSH
94397: LD_INT 1
94399: NEG
94400: PUSH
94401: EMPTY
94402: LIST
94403: LIST
94404: PUSH
94405: LD_INT 3
94407: PUSH
94408: LD_INT 0
94410: PUSH
94411: EMPTY
94412: LIST
94413: LIST
94414: PUSH
94415: LD_INT 3
94417: PUSH
94418: LD_INT 1
94420: PUSH
94421: EMPTY
94422: LIST
94423: LIST
94424: PUSH
94425: EMPTY
94426: LIST
94427: LIST
94428: LIST
94429: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
94430: LD_ADDR_VAR 0 55
94434: PUSH
94435: LD_INT 3
94437: PUSH
94438: LD_INT 2
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: PUSH
94445: LD_INT 3
94447: PUSH
94448: LD_INT 3
94450: PUSH
94451: EMPTY
94452: LIST
94453: LIST
94454: PUSH
94455: LD_INT 2
94457: PUSH
94458: LD_INT 3
94460: PUSH
94461: EMPTY
94462: LIST
94463: LIST
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: LIST
94469: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
94470: LD_ADDR_VAR 0 56
94474: PUSH
94475: LD_INT 1
94477: PUSH
94478: LD_INT 3
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: PUSH
94485: LD_INT 0
94487: PUSH
94488: LD_INT 3
94490: PUSH
94491: EMPTY
94492: LIST
94493: LIST
94494: PUSH
94495: LD_INT 1
94497: NEG
94498: PUSH
94499: LD_INT 2
94501: PUSH
94502: EMPTY
94503: LIST
94504: LIST
94505: PUSH
94506: EMPTY
94507: LIST
94508: LIST
94509: LIST
94510: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
94511: LD_ADDR_VAR 0 57
94515: PUSH
94516: LD_INT 2
94518: NEG
94519: PUSH
94520: LD_INT 1
94522: PUSH
94523: EMPTY
94524: LIST
94525: LIST
94526: PUSH
94527: LD_INT 3
94529: NEG
94530: PUSH
94531: LD_INT 0
94533: PUSH
94534: EMPTY
94535: LIST
94536: LIST
94537: PUSH
94538: LD_INT 3
94540: NEG
94541: PUSH
94542: LD_INT 1
94544: NEG
94545: PUSH
94546: EMPTY
94547: LIST
94548: LIST
94549: PUSH
94550: EMPTY
94551: LIST
94552: LIST
94553: LIST
94554: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
94555: LD_ADDR_VAR 0 58
94559: PUSH
94560: LD_INT 2
94562: NEG
94563: PUSH
94564: LD_INT 3
94566: NEG
94567: PUSH
94568: EMPTY
94569: LIST
94570: LIST
94571: PUSH
94572: LD_INT 3
94574: NEG
94575: PUSH
94576: LD_INT 2
94578: NEG
94579: PUSH
94580: EMPTY
94581: LIST
94582: LIST
94583: PUSH
94584: LD_INT 3
94586: NEG
94587: PUSH
94588: LD_INT 3
94590: NEG
94591: PUSH
94592: EMPTY
94593: LIST
94594: LIST
94595: PUSH
94596: EMPTY
94597: LIST
94598: LIST
94599: LIST
94600: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
94601: LD_ADDR_VAR 0 59
94605: PUSH
94606: LD_INT 1
94608: NEG
94609: PUSH
94610: LD_INT 2
94612: NEG
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: PUSH
94618: LD_INT 0
94620: PUSH
94621: LD_INT 2
94623: NEG
94624: PUSH
94625: EMPTY
94626: LIST
94627: LIST
94628: PUSH
94629: LD_INT 1
94631: PUSH
94632: LD_INT 1
94634: NEG
94635: PUSH
94636: EMPTY
94637: LIST
94638: LIST
94639: PUSH
94640: EMPTY
94641: LIST
94642: LIST
94643: LIST
94644: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94645: LD_ADDR_VAR 0 60
94649: PUSH
94650: LD_INT 1
94652: PUSH
94653: LD_INT 1
94655: NEG
94656: PUSH
94657: EMPTY
94658: LIST
94659: LIST
94660: PUSH
94661: LD_INT 2
94663: PUSH
94664: LD_INT 0
94666: PUSH
94667: EMPTY
94668: LIST
94669: LIST
94670: PUSH
94671: LD_INT 2
94673: PUSH
94674: LD_INT 1
94676: PUSH
94677: EMPTY
94678: LIST
94679: LIST
94680: PUSH
94681: EMPTY
94682: LIST
94683: LIST
94684: LIST
94685: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94686: LD_ADDR_VAR 0 61
94690: PUSH
94691: LD_INT 2
94693: PUSH
94694: LD_INT 1
94696: PUSH
94697: EMPTY
94698: LIST
94699: LIST
94700: PUSH
94701: LD_INT 2
94703: PUSH
94704: LD_INT 2
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 1
94713: PUSH
94714: LD_INT 2
94716: PUSH
94717: EMPTY
94718: LIST
94719: LIST
94720: PUSH
94721: EMPTY
94722: LIST
94723: LIST
94724: LIST
94725: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94726: LD_ADDR_VAR 0 62
94730: PUSH
94731: LD_INT 1
94733: PUSH
94734: LD_INT 2
94736: PUSH
94737: EMPTY
94738: LIST
94739: LIST
94740: PUSH
94741: LD_INT 0
94743: PUSH
94744: LD_INT 2
94746: PUSH
94747: EMPTY
94748: LIST
94749: LIST
94750: PUSH
94751: LD_INT 1
94753: NEG
94754: PUSH
94755: LD_INT 1
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: EMPTY
94763: LIST
94764: LIST
94765: LIST
94766: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94767: LD_ADDR_VAR 0 63
94771: PUSH
94772: LD_INT 1
94774: NEG
94775: PUSH
94776: LD_INT 1
94778: PUSH
94779: EMPTY
94780: LIST
94781: LIST
94782: PUSH
94783: LD_INT 2
94785: NEG
94786: PUSH
94787: LD_INT 0
94789: PUSH
94790: EMPTY
94791: LIST
94792: LIST
94793: PUSH
94794: LD_INT 2
94796: NEG
94797: PUSH
94798: LD_INT 1
94800: NEG
94801: PUSH
94802: EMPTY
94803: LIST
94804: LIST
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: LIST
94810: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94811: LD_ADDR_VAR 0 64
94815: PUSH
94816: LD_INT 1
94818: NEG
94819: PUSH
94820: LD_INT 2
94822: NEG
94823: PUSH
94824: EMPTY
94825: LIST
94826: LIST
94827: PUSH
94828: LD_INT 2
94830: NEG
94831: PUSH
94832: LD_INT 1
94834: NEG
94835: PUSH
94836: EMPTY
94837: LIST
94838: LIST
94839: PUSH
94840: LD_INT 2
94842: NEG
94843: PUSH
94844: LD_INT 2
94846: NEG
94847: PUSH
94848: EMPTY
94849: LIST
94850: LIST
94851: PUSH
94852: EMPTY
94853: LIST
94854: LIST
94855: LIST
94856: ST_TO_ADDR
// end ; 2 :
94857: GO 98123
94859: LD_INT 2
94861: DOUBLE
94862: EQUAL
94863: IFTRUE 94867
94865: GO 98122
94867: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94868: LD_ADDR_VAR 0 29
94872: PUSH
94873: LD_INT 4
94875: PUSH
94876: LD_INT 0
94878: PUSH
94879: EMPTY
94880: LIST
94881: LIST
94882: PUSH
94883: LD_INT 4
94885: PUSH
94886: LD_INT 1
94888: NEG
94889: PUSH
94890: EMPTY
94891: LIST
94892: LIST
94893: PUSH
94894: LD_INT 5
94896: PUSH
94897: LD_INT 0
94899: PUSH
94900: EMPTY
94901: LIST
94902: LIST
94903: PUSH
94904: LD_INT 5
94906: PUSH
94907: LD_INT 1
94909: PUSH
94910: EMPTY
94911: LIST
94912: LIST
94913: PUSH
94914: LD_INT 4
94916: PUSH
94917: LD_INT 1
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: PUSH
94924: LD_INT 3
94926: PUSH
94927: LD_INT 0
94929: PUSH
94930: EMPTY
94931: LIST
94932: LIST
94933: PUSH
94934: LD_INT 3
94936: PUSH
94937: LD_INT 1
94939: NEG
94940: PUSH
94941: EMPTY
94942: LIST
94943: LIST
94944: PUSH
94945: LD_INT 3
94947: PUSH
94948: LD_INT 2
94950: NEG
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PUSH
94956: LD_INT 5
94958: PUSH
94959: LD_INT 2
94961: PUSH
94962: EMPTY
94963: LIST
94964: LIST
94965: PUSH
94966: LD_INT 3
94968: PUSH
94969: LD_INT 3
94971: PUSH
94972: EMPTY
94973: LIST
94974: LIST
94975: PUSH
94976: LD_INT 3
94978: PUSH
94979: LD_INT 2
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 4
94988: PUSH
94989: LD_INT 3
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 4
94998: PUSH
94999: LD_INT 4
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: LD_INT 3
95008: PUSH
95009: LD_INT 4
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 2
95018: PUSH
95019: LD_INT 3
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: PUSH
95026: LD_INT 2
95028: PUSH
95029: LD_INT 2
95031: PUSH
95032: EMPTY
95033: LIST
95034: LIST
95035: PUSH
95036: LD_INT 4
95038: PUSH
95039: LD_INT 2
95041: PUSH
95042: EMPTY
95043: LIST
95044: LIST
95045: PUSH
95046: LD_INT 2
95048: PUSH
95049: LD_INT 4
95051: PUSH
95052: EMPTY
95053: LIST
95054: LIST
95055: PUSH
95056: LD_INT 0
95058: PUSH
95059: LD_INT 4
95061: PUSH
95062: EMPTY
95063: LIST
95064: LIST
95065: PUSH
95066: LD_INT 0
95068: PUSH
95069: LD_INT 3
95071: PUSH
95072: EMPTY
95073: LIST
95074: LIST
95075: PUSH
95076: LD_INT 1
95078: PUSH
95079: LD_INT 4
95081: PUSH
95082: EMPTY
95083: LIST
95084: LIST
95085: PUSH
95086: LD_INT 1
95088: PUSH
95089: LD_INT 5
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: PUSH
95096: LD_INT 0
95098: PUSH
95099: LD_INT 5
95101: PUSH
95102: EMPTY
95103: LIST
95104: LIST
95105: PUSH
95106: LD_INT 1
95108: NEG
95109: PUSH
95110: LD_INT 4
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: PUSH
95117: LD_INT 1
95119: NEG
95120: PUSH
95121: LD_INT 3
95123: PUSH
95124: EMPTY
95125: LIST
95126: LIST
95127: PUSH
95128: LD_INT 2
95130: PUSH
95131: LD_INT 5
95133: PUSH
95134: EMPTY
95135: LIST
95136: LIST
95137: PUSH
95138: LD_INT 2
95140: NEG
95141: PUSH
95142: LD_INT 3
95144: PUSH
95145: EMPTY
95146: LIST
95147: LIST
95148: PUSH
95149: LD_INT 3
95151: NEG
95152: PUSH
95153: LD_INT 0
95155: PUSH
95156: EMPTY
95157: LIST
95158: LIST
95159: PUSH
95160: LD_INT 3
95162: NEG
95163: PUSH
95164: LD_INT 1
95166: NEG
95167: PUSH
95168: EMPTY
95169: LIST
95170: LIST
95171: PUSH
95172: LD_INT 2
95174: NEG
95175: PUSH
95176: LD_INT 0
95178: PUSH
95179: EMPTY
95180: LIST
95181: LIST
95182: PUSH
95183: LD_INT 2
95185: NEG
95186: PUSH
95187: LD_INT 1
95189: PUSH
95190: EMPTY
95191: LIST
95192: LIST
95193: PUSH
95194: LD_INT 3
95196: NEG
95197: PUSH
95198: LD_INT 1
95200: PUSH
95201: EMPTY
95202: LIST
95203: LIST
95204: PUSH
95205: LD_INT 4
95207: NEG
95208: PUSH
95209: LD_INT 0
95211: PUSH
95212: EMPTY
95213: LIST
95214: LIST
95215: PUSH
95216: LD_INT 4
95218: NEG
95219: PUSH
95220: LD_INT 1
95222: NEG
95223: PUSH
95224: EMPTY
95225: LIST
95226: LIST
95227: PUSH
95228: LD_INT 4
95230: NEG
95231: PUSH
95232: LD_INT 2
95234: NEG
95235: PUSH
95236: EMPTY
95237: LIST
95238: LIST
95239: PUSH
95240: LD_INT 2
95242: NEG
95243: PUSH
95244: LD_INT 2
95246: PUSH
95247: EMPTY
95248: LIST
95249: LIST
95250: PUSH
95251: LD_INT 4
95253: NEG
95254: PUSH
95255: LD_INT 4
95257: NEG
95258: PUSH
95259: EMPTY
95260: LIST
95261: LIST
95262: PUSH
95263: LD_INT 4
95265: NEG
95266: PUSH
95267: LD_INT 5
95269: NEG
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: PUSH
95275: LD_INT 3
95277: NEG
95278: PUSH
95279: LD_INT 4
95281: NEG
95282: PUSH
95283: EMPTY
95284: LIST
95285: LIST
95286: PUSH
95287: LD_INT 3
95289: NEG
95290: PUSH
95291: LD_INT 3
95293: NEG
95294: PUSH
95295: EMPTY
95296: LIST
95297: LIST
95298: PUSH
95299: LD_INT 4
95301: NEG
95302: PUSH
95303: LD_INT 3
95305: NEG
95306: PUSH
95307: EMPTY
95308: LIST
95309: LIST
95310: PUSH
95311: LD_INT 5
95313: NEG
95314: PUSH
95315: LD_INT 4
95317: NEG
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: PUSH
95323: LD_INT 5
95325: NEG
95326: PUSH
95327: LD_INT 5
95329: NEG
95330: PUSH
95331: EMPTY
95332: LIST
95333: LIST
95334: PUSH
95335: LD_INT 3
95337: NEG
95338: PUSH
95339: LD_INT 5
95341: NEG
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: LD_INT 5
95349: NEG
95350: PUSH
95351: LD_INT 3
95353: NEG
95354: PUSH
95355: EMPTY
95356: LIST
95357: LIST
95358: PUSH
95359: EMPTY
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: LIST
95376: LIST
95377: LIST
95378: LIST
95379: LIST
95380: LIST
95381: LIST
95382: LIST
95383: LIST
95384: LIST
95385: LIST
95386: LIST
95387: LIST
95388: LIST
95389: LIST
95390: LIST
95391: LIST
95392: LIST
95393: LIST
95394: LIST
95395: LIST
95396: LIST
95397: LIST
95398: LIST
95399: LIST
95400: LIST
95401: LIST
95402: LIST
95403: LIST
95404: LIST
95405: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
95406: LD_ADDR_VAR 0 30
95410: PUSH
95411: LD_INT 4
95413: PUSH
95414: LD_INT 4
95416: PUSH
95417: EMPTY
95418: LIST
95419: LIST
95420: PUSH
95421: LD_INT 4
95423: PUSH
95424: LD_INT 3
95426: PUSH
95427: EMPTY
95428: LIST
95429: LIST
95430: PUSH
95431: LD_INT 5
95433: PUSH
95434: LD_INT 4
95436: PUSH
95437: EMPTY
95438: LIST
95439: LIST
95440: PUSH
95441: LD_INT 5
95443: PUSH
95444: LD_INT 5
95446: PUSH
95447: EMPTY
95448: LIST
95449: LIST
95450: PUSH
95451: LD_INT 4
95453: PUSH
95454: LD_INT 5
95456: PUSH
95457: EMPTY
95458: LIST
95459: LIST
95460: PUSH
95461: LD_INT 3
95463: PUSH
95464: LD_INT 4
95466: PUSH
95467: EMPTY
95468: LIST
95469: LIST
95470: PUSH
95471: LD_INT 3
95473: PUSH
95474: LD_INT 3
95476: PUSH
95477: EMPTY
95478: LIST
95479: LIST
95480: PUSH
95481: LD_INT 5
95483: PUSH
95484: LD_INT 3
95486: PUSH
95487: EMPTY
95488: LIST
95489: LIST
95490: PUSH
95491: LD_INT 3
95493: PUSH
95494: LD_INT 5
95496: PUSH
95497: EMPTY
95498: LIST
95499: LIST
95500: PUSH
95501: LD_INT 0
95503: PUSH
95504: LD_INT 3
95506: PUSH
95507: EMPTY
95508: LIST
95509: LIST
95510: PUSH
95511: LD_INT 0
95513: PUSH
95514: LD_INT 2
95516: PUSH
95517: EMPTY
95518: LIST
95519: LIST
95520: PUSH
95521: LD_INT 1
95523: PUSH
95524: LD_INT 3
95526: PUSH
95527: EMPTY
95528: LIST
95529: LIST
95530: PUSH
95531: LD_INT 1
95533: PUSH
95534: LD_INT 4
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: PUSH
95541: LD_INT 0
95543: PUSH
95544: LD_INT 4
95546: PUSH
95547: EMPTY
95548: LIST
95549: LIST
95550: PUSH
95551: LD_INT 1
95553: NEG
95554: PUSH
95555: LD_INT 3
95557: PUSH
95558: EMPTY
95559: LIST
95560: LIST
95561: PUSH
95562: LD_INT 1
95564: NEG
95565: PUSH
95566: LD_INT 2
95568: PUSH
95569: EMPTY
95570: LIST
95571: LIST
95572: PUSH
95573: LD_INT 2
95575: PUSH
95576: LD_INT 4
95578: PUSH
95579: EMPTY
95580: LIST
95581: LIST
95582: PUSH
95583: LD_INT 2
95585: NEG
95586: PUSH
95587: LD_INT 2
95589: PUSH
95590: EMPTY
95591: LIST
95592: LIST
95593: PUSH
95594: LD_INT 4
95596: NEG
95597: PUSH
95598: LD_INT 0
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 4
95607: NEG
95608: PUSH
95609: LD_INT 1
95611: NEG
95612: PUSH
95613: EMPTY
95614: LIST
95615: LIST
95616: PUSH
95617: LD_INT 3
95619: NEG
95620: PUSH
95621: LD_INT 0
95623: PUSH
95624: EMPTY
95625: LIST
95626: LIST
95627: PUSH
95628: LD_INT 3
95630: NEG
95631: PUSH
95632: LD_INT 1
95634: PUSH
95635: EMPTY
95636: LIST
95637: LIST
95638: PUSH
95639: LD_INT 4
95641: NEG
95642: PUSH
95643: LD_INT 1
95645: PUSH
95646: EMPTY
95647: LIST
95648: LIST
95649: PUSH
95650: LD_INT 5
95652: NEG
95653: PUSH
95654: LD_INT 0
95656: PUSH
95657: EMPTY
95658: LIST
95659: LIST
95660: PUSH
95661: LD_INT 5
95663: NEG
95664: PUSH
95665: LD_INT 1
95667: NEG
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: PUSH
95673: LD_INT 5
95675: NEG
95676: PUSH
95677: LD_INT 2
95679: NEG
95680: PUSH
95681: EMPTY
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 3
95687: NEG
95688: PUSH
95689: LD_INT 2
95691: PUSH
95692: EMPTY
95693: LIST
95694: LIST
95695: PUSH
95696: LD_INT 3
95698: NEG
95699: PUSH
95700: LD_INT 3
95702: NEG
95703: PUSH
95704: EMPTY
95705: LIST
95706: LIST
95707: PUSH
95708: LD_INT 3
95710: NEG
95711: PUSH
95712: LD_INT 4
95714: NEG
95715: PUSH
95716: EMPTY
95717: LIST
95718: LIST
95719: PUSH
95720: LD_INT 2
95722: NEG
95723: PUSH
95724: LD_INT 3
95726: NEG
95727: PUSH
95728: EMPTY
95729: LIST
95730: LIST
95731: PUSH
95732: LD_INT 2
95734: NEG
95735: PUSH
95736: LD_INT 2
95738: NEG
95739: PUSH
95740: EMPTY
95741: LIST
95742: LIST
95743: PUSH
95744: LD_INT 3
95746: NEG
95747: PUSH
95748: LD_INT 2
95750: NEG
95751: PUSH
95752: EMPTY
95753: LIST
95754: LIST
95755: PUSH
95756: LD_INT 4
95758: NEG
95759: PUSH
95760: LD_INT 3
95762: NEG
95763: PUSH
95764: EMPTY
95765: LIST
95766: LIST
95767: PUSH
95768: LD_INT 4
95770: NEG
95771: PUSH
95772: LD_INT 4
95774: NEG
95775: PUSH
95776: EMPTY
95777: LIST
95778: LIST
95779: PUSH
95780: LD_INT 2
95782: NEG
95783: PUSH
95784: LD_INT 4
95786: NEG
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PUSH
95792: LD_INT 4
95794: NEG
95795: PUSH
95796: LD_INT 2
95798: NEG
95799: PUSH
95800: EMPTY
95801: LIST
95802: LIST
95803: PUSH
95804: LD_INT 0
95806: PUSH
95807: LD_INT 4
95809: NEG
95810: PUSH
95811: EMPTY
95812: LIST
95813: LIST
95814: PUSH
95815: LD_INT 0
95817: PUSH
95818: LD_INT 5
95820: NEG
95821: PUSH
95822: EMPTY
95823: LIST
95824: LIST
95825: PUSH
95826: LD_INT 1
95828: PUSH
95829: LD_INT 4
95831: NEG
95832: PUSH
95833: EMPTY
95834: LIST
95835: LIST
95836: PUSH
95837: LD_INT 1
95839: PUSH
95840: LD_INT 3
95842: NEG
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: PUSH
95848: LD_INT 0
95850: PUSH
95851: LD_INT 3
95853: NEG
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 1
95861: NEG
95862: PUSH
95863: LD_INT 4
95865: NEG
95866: PUSH
95867: EMPTY
95868: LIST
95869: LIST
95870: PUSH
95871: LD_INT 1
95873: NEG
95874: PUSH
95875: LD_INT 5
95877: NEG
95878: PUSH
95879: EMPTY
95880: LIST
95881: LIST
95882: PUSH
95883: LD_INT 2
95885: PUSH
95886: LD_INT 3
95888: NEG
95889: PUSH
95890: EMPTY
95891: LIST
95892: LIST
95893: PUSH
95894: LD_INT 2
95896: NEG
95897: PUSH
95898: LD_INT 5
95900: NEG
95901: PUSH
95902: EMPTY
95903: LIST
95904: LIST
95905: PUSH
95906: EMPTY
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: LIST
95917: LIST
95918: LIST
95919: LIST
95920: LIST
95921: LIST
95922: LIST
95923: LIST
95924: LIST
95925: LIST
95926: LIST
95927: LIST
95928: LIST
95929: LIST
95930: LIST
95931: LIST
95932: LIST
95933: LIST
95934: LIST
95935: LIST
95936: LIST
95937: LIST
95938: LIST
95939: LIST
95940: LIST
95941: LIST
95942: LIST
95943: LIST
95944: LIST
95945: LIST
95946: LIST
95947: LIST
95948: LIST
95949: LIST
95950: LIST
95951: LIST
95952: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95953: LD_ADDR_VAR 0 31
95957: PUSH
95958: LD_INT 0
95960: PUSH
95961: LD_INT 4
95963: PUSH
95964: EMPTY
95965: LIST
95966: LIST
95967: PUSH
95968: LD_INT 0
95970: PUSH
95971: LD_INT 3
95973: PUSH
95974: EMPTY
95975: LIST
95976: LIST
95977: PUSH
95978: LD_INT 1
95980: PUSH
95981: LD_INT 4
95983: PUSH
95984: EMPTY
95985: LIST
95986: LIST
95987: PUSH
95988: LD_INT 1
95990: PUSH
95991: LD_INT 5
95993: PUSH
95994: EMPTY
95995: LIST
95996: LIST
95997: PUSH
95998: LD_INT 0
96000: PUSH
96001: LD_INT 5
96003: PUSH
96004: EMPTY
96005: LIST
96006: LIST
96007: PUSH
96008: LD_INT 1
96010: NEG
96011: PUSH
96012: LD_INT 4
96014: PUSH
96015: EMPTY
96016: LIST
96017: LIST
96018: PUSH
96019: LD_INT 1
96021: NEG
96022: PUSH
96023: LD_INT 3
96025: PUSH
96026: EMPTY
96027: LIST
96028: LIST
96029: PUSH
96030: LD_INT 2
96032: PUSH
96033: LD_INT 5
96035: PUSH
96036: EMPTY
96037: LIST
96038: LIST
96039: PUSH
96040: LD_INT 2
96042: NEG
96043: PUSH
96044: LD_INT 3
96046: PUSH
96047: EMPTY
96048: LIST
96049: LIST
96050: PUSH
96051: LD_INT 3
96053: NEG
96054: PUSH
96055: LD_INT 0
96057: PUSH
96058: EMPTY
96059: LIST
96060: LIST
96061: PUSH
96062: LD_INT 3
96064: NEG
96065: PUSH
96066: LD_INT 1
96068: NEG
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: PUSH
96074: LD_INT 2
96076: NEG
96077: PUSH
96078: LD_INT 0
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: PUSH
96085: LD_INT 2
96087: NEG
96088: PUSH
96089: LD_INT 1
96091: PUSH
96092: EMPTY
96093: LIST
96094: LIST
96095: PUSH
96096: LD_INT 3
96098: NEG
96099: PUSH
96100: LD_INT 1
96102: PUSH
96103: EMPTY
96104: LIST
96105: LIST
96106: PUSH
96107: LD_INT 4
96109: NEG
96110: PUSH
96111: LD_INT 0
96113: PUSH
96114: EMPTY
96115: LIST
96116: LIST
96117: PUSH
96118: LD_INT 4
96120: NEG
96121: PUSH
96122: LD_INT 1
96124: NEG
96125: PUSH
96126: EMPTY
96127: LIST
96128: LIST
96129: PUSH
96130: LD_INT 4
96132: NEG
96133: PUSH
96134: LD_INT 2
96136: NEG
96137: PUSH
96138: EMPTY
96139: LIST
96140: LIST
96141: PUSH
96142: LD_INT 2
96144: NEG
96145: PUSH
96146: LD_INT 2
96148: PUSH
96149: EMPTY
96150: LIST
96151: LIST
96152: PUSH
96153: LD_INT 4
96155: NEG
96156: PUSH
96157: LD_INT 4
96159: NEG
96160: PUSH
96161: EMPTY
96162: LIST
96163: LIST
96164: PUSH
96165: LD_INT 4
96167: NEG
96168: PUSH
96169: LD_INT 5
96171: NEG
96172: PUSH
96173: EMPTY
96174: LIST
96175: LIST
96176: PUSH
96177: LD_INT 3
96179: NEG
96180: PUSH
96181: LD_INT 4
96183: NEG
96184: PUSH
96185: EMPTY
96186: LIST
96187: LIST
96188: PUSH
96189: LD_INT 3
96191: NEG
96192: PUSH
96193: LD_INT 3
96195: NEG
96196: PUSH
96197: EMPTY
96198: LIST
96199: LIST
96200: PUSH
96201: LD_INT 4
96203: NEG
96204: PUSH
96205: LD_INT 3
96207: NEG
96208: PUSH
96209: EMPTY
96210: LIST
96211: LIST
96212: PUSH
96213: LD_INT 5
96215: NEG
96216: PUSH
96217: LD_INT 4
96219: NEG
96220: PUSH
96221: EMPTY
96222: LIST
96223: LIST
96224: PUSH
96225: LD_INT 5
96227: NEG
96228: PUSH
96229: LD_INT 5
96231: NEG
96232: PUSH
96233: EMPTY
96234: LIST
96235: LIST
96236: PUSH
96237: LD_INT 3
96239: NEG
96240: PUSH
96241: LD_INT 5
96243: NEG
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: PUSH
96249: LD_INT 5
96251: NEG
96252: PUSH
96253: LD_INT 3
96255: NEG
96256: PUSH
96257: EMPTY
96258: LIST
96259: LIST
96260: PUSH
96261: LD_INT 0
96263: PUSH
96264: LD_INT 3
96266: NEG
96267: PUSH
96268: EMPTY
96269: LIST
96270: LIST
96271: PUSH
96272: LD_INT 0
96274: PUSH
96275: LD_INT 4
96277: NEG
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: PUSH
96283: LD_INT 1
96285: PUSH
96286: LD_INT 3
96288: NEG
96289: PUSH
96290: EMPTY
96291: LIST
96292: LIST
96293: PUSH
96294: LD_INT 1
96296: PUSH
96297: LD_INT 2
96299: NEG
96300: PUSH
96301: EMPTY
96302: LIST
96303: LIST
96304: PUSH
96305: LD_INT 0
96307: PUSH
96308: LD_INT 2
96310: NEG
96311: PUSH
96312: EMPTY
96313: LIST
96314: LIST
96315: PUSH
96316: LD_INT 1
96318: NEG
96319: PUSH
96320: LD_INT 3
96322: NEG
96323: PUSH
96324: EMPTY
96325: LIST
96326: LIST
96327: PUSH
96328: LD_INT 1
96330: NEG
96331: PUSH
96332: LD_INT 4
96334: NEG
96335: PUSH
96336: EMPTY
96337: LIST
96338: LIST
96339: PUSH
96340: LD_INT 2
96342: PUSH
96343: LD_INT 2
96345: NEG
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PUSH
96351: LD_INT 2
96353: NEG
96354: PUSH
96355: LD_INT 4
96357: NEG
96358: PUSH
96359: EMPTY
96360: LIST
96361: LIST
96362: PUSH
96363: LD_INT 4
96365: PUSH
96366: LD_INT 0
96368: PUSH
96369: EMPTY
96370: LIST
96371: LIST
96372: PUSH
96373: LD_INT 4
96375: PUSH
96376: LD_INT 1
96378: NEG
96379: PUSH
96380: EMPTY
96381: LIST
96382: LIST
96383: PUSH
96384: LD_INT 5
96386: PUSH
96387: LD_INT 0
96389: PUSH
96390: EMPTY
96391: LIST
96392: LIST
96393: PUSH
96394: LD_INT 5
96396: PUSH
96397: LD_INT 1
96399: PUSH
96400: EMPTY
96401: LIST
96402: LIST
96403: PUSH
96404: LD_INT 4
96406: PUSH
96407: LD_INT 1
96409: PUSH
96410: EMPTY
96411: LIST
96412: LIST
96413: PUSH
96414: LD_INT 3
96416: PUSH
96417: LD_INT 0
96419: PUSH
96420: EMPTY
96421: LIST
96422: LIST
96423: PUSH
96424: LD_INT 3
96426: PUSH
96427: LD_INT 1
96429: NEG
96430: PUSH
96431: EMPTY
96432: LIST
96433: LIST
96434: PUSH
96435: LD_INT 3
96437: PUSH
96438: LD_INT 2
96440: NEG
96441: PUSH
96442: EMPTY
96443: LIST
96444: LIST
96445: PUSH
96446: LD_INT 5
96448: PUSH
96449: LD_INT 2
96451: PUSH
96452: EMPTY
96453: LIST
96454: LIST
96455: PUSH
96456: EMPTY
96457: LIST
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: LIST
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
96503: LD_ADDR_VAR 0 32
96507: PUSH
96508: LD_INT 4
96510: NEG
96511: PUSH
96512: LD_INT 0
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 4
96521: NEG
96522: PUSH
96523: LD_INT 1
96525: NEG
96526: PUSH
96527: EMPTY
96528: LIST
96529: LIST
96530: PUSH
96531: LD_INT 3
96533: NEG
96534: PUSH
96535: LD_INT 0
96537: PUSH
96538: EMPTY
96539: LIST
96540: LIST
96541: PUSH
96542: LD_INT 3
96544: NEG
96545: PUSH
96546: LD_INT 1
96548: PUSH
96549: EMPTY
96550: LIST
96551: LIST
96552: PUSH
96553: LD_INT 4
96555: NEG
96556: PUSH
96557: LD_INT 1
96559: PUSH
96560: EMPTY
96561: LIST
96562: LIST
96563: PUSH
96564: LD_INT 5
96566: NEG
96567: PUSH
96568: LD_INT 0
96570: PUSH
96571: EMPTY
96572: LIST
96573: LIST
96574: PUSH
96575: LD_INT 5
96577: NEG
96578: PUSH
96579: LD_INT 1
96581: NEG
96582: PUSH
96583: EMPTY
96584: LIST
96585: LIST
96586: PUSH
96587: LD_INT 5
96589: NEG
96590: PUSH
96591: LD_INT 2
96593: NEG
96594: PUSH
96595: EMPTY
96596: LIST
96597: LIST
96598: PUSH
96599: LD_INT 3
96601: NEG
96602: PUSH
96603: LD_INT 2
96605: PUSH
96606: EMPTY
96607: LIST
96608: LIST
96609: PUSH
96610: LD_INT 3
96612: NEG
96613: PUSH
96614: LD_INT 3
96616: NEG
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PUSH
96622: LD_INT 3
96624: NEG
96625: PUSH
96626: LD_INT 4
96628: NEG
96629: PUSH
96630: EMPTY
96631: LIST
96632: LIST
96633: PUSH
96634: LD_INT 2
96636: NEG
96637: PUSH
96638: LD_INT 3
96640: NEG
96641: PUSH
96642: EMPTY
96643: LIST
96644: LIST
96645: PUSH
96646: LD_INT 2
96648: NEG
96649: PUSH
96650: LD_INT 2
96652: NEG
96653: PUSH
96654: EMPTY
96655: LIST
96656: LIST
96657: PUSH
96658: LD_INT 3
96660: NEG
96661: PUSH
96662: LD_INT 2
96664: NEG
96665: PUSH
96666: EMPTY
96667: LIST
96668: LIST
96669: PUSH
96670: LD_INT 4
96672: NEG
96673: PUSH
96674: LD_INT 3
96676: NEG
96677: PUSH
96678: EMPTY
96679: LIST
96680: LIST
96681: PUSH
96682: LD_INT 4
96684: NEG
96685: PUSH
96686: LD_INT 4
96688: NEG
96689: PUSH
96690: EMPTY
96691: LIST
96692: LIST
96693: PUSH
96694: LD_INT 2
96696: NEG
96697: PUSH
96698: LD_INT 4
96700: NEG
96701: PUSH
96702: EMPTY
96703: LIST
96704: LIST
96705: PUSH
96706: LD_INT 4
96708: NEG
96709: PUSH
96710: LD_INT 2
96712: NEG
96713: PUSH
96714: EMPTY
96715: LIST
96716: LIST
96717: PUSH
96718: LD_INT 0
96720: PUSH
96721: LD_INT 4
96723: NEG
96724: PUSH
96725: EMPTY
96726: LIST
96727: LIST
96728: PUSH
96729: LD_INT 0
96731: PUSH
96732: LD_INT 5
96734: NEG
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: LD_INT 1
96742: PUSH
96743: LD_INT 4
96745: NEG
96746: PUSH
96747: EMPTY
96748: LIST
96749: LIST
96750: PUSH
96751: LD_INT 1
96753: PUSH
96754: LD_INT 3
96756: NEG
96757: PUSH
96758: EMPTY
96759: LIST
96760: LIST
96761: PUSH
96762: LD_INT 0
96764: PUSH
96765: LD_INT 3
96767: NEG
96768: PUSH
96769: EMPTY
96770: LIST
96771: LIST
96772: PUSH
96773: LD_INT 1
96775: NEG
96776: PUSH
96777: LD_INT 4
96779: NEG
96780: PUSH
96781: EMPTY
96782: LIST
96783: LIST
96784: PUSH
96785: LD_INT 1
96787: NEG
96788: PUSH
96789: LD_INT 5
96791: NEG
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PUSH
96797: LD_INT 2
96799: PUSH
96800: LD_INT 3
96802: NEG
96803: PUSH
96804: EMPTY
96805: LIST
96806: LIST
96807: PUSH
96808: LD_INT 2
96810: NEG
96811: PUSH
96812: LD_INT 5
96814: NEG
96815: PUSH
96816: EMPTY
96817: LIST
96818: LIST
96819: PUSH
96820: LD_INT 3
96822: PUSH
96823: LD_INT 0
96825: PUSH
96826: EMPTY
96827: LIST
96828: LIST
96829: PUSH
96830: LD_INT 3
96832: PUSH
96833: LD_INT 1
96835: NEG
96836: PUSH
96837: EMPTY
96838: LIST
96839: LIST
96840: PUSH
96841: LD_INT 4
96843: PUSH
96844: LD_INT 0
96846: PUSH
96847: EMPTY
96848: LIST
96849: LIST
96850: PUSH
96851: LD_INT 4
96853: PUSH
96854: LD_INT 1
96856: PUSH
96857: EMPTY
96858: LIST
96859: LIST
96860: PUSH
96861: LD_INT 3
96863: PUSH
96864: LD_INT 1
96866: PUSH
96867: EMPTY
96868: LIST
96869: LIST
96870: PUSH
96871: LD_INT 2
96873: PUSH
96874: LD_INT 0
96876: PUSH
96877: EMPTY
96878: LIST
96879: LIST
96880: PUSH
96881: LD_INT 2
96883: PUSH
96884: LD_INT 1
96886: NEG
96887: PUSH
96888: EMPTY
96889: LIST
96890: LIST
96891: PUSH
96892: LD_INT 2
96894: PUSH
96895: LD_INT 2
96897: NEG
96898: PUSH
96899: EMPTY
96900: LIST
96901: LIST
96902: PUSH
96903: LD_INT 4
96905: PUSH
96906: LD_INT 2
96908: PUSH
96909: EMPTY
96910: LIST
96911: LIST
96912: PUSH
96913: LD_INT 4
96915: PUSH
96916: LD_INT 4
96918: PUSH
96919: EMPTY
96920: LIST
96921: LIST
96922: PUSH
96923: LD_INT 4
96925: PUSH
96926: LD_INT 3
96928: PUSH
96929: EMPTY
96930: LIST
96931: LIST
96932: PUSH
96933: LD_INT 5
96935: PUSH
96936: LD_INT 4
96938: PUSH
96939: EMPTY
96940: LIST
96941: LIST
96942: PUSH
96943: LD_INT 5
96945: PUSH
96946: LD_INT 5
96948: PUSH
96949: EMPTY
96950: LIST
96951: LIST
96952: PUSH
96953: LD_INT 4
96955: PUSH
96956: LD_INT 5
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: PUSH
96963: LD_INT 3
96965: PUSH
96966: LD_INT 4
96968: PUSH
96969: EMPTY
96970: LIST
96971: LIST
96972: PUSH
96973: LD_INT 3
96975: PUSH
96976: LD_INT 3
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: PUSH
96983: LD_INT 5
96985: PUSH
96986: LD_INT 3
96988: PUSH
96989: EMPTY
96990: LIST
96991: LIST
96992: PUSH
96993: LD_INT 3
96995: PUSH
96996: LD_INT 5
96998: PUSH
96999: EMPTY
97000: LIST
97001: LIST
97002: PUSH
97003: EMPTY
97004: LIST
97005: LIST
97006: LIST
97007: LIST
97008: LIST
97009: LIST
97010: LIST
97011: LIST
97012: LIST
97013: LIST
97014: LIST
97015: LIST
97016: LIST
97017: LIST
97018: LIST
97019: LIST
97020: LIST
97021: LIST
97022: LIST
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: LIST
97031: LIST
97032: LIST
97033: LIST
97034: LIST
97035: LIST
97036: LIST
97037: LIST
97038: LIST
97039: LIST
97040: LIST
97041: LIST
97042: LIST
97043: LIST
97044: LIST
97045: LIST
97046: LIST
97047: LIST
97048: LIST
97049: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
97050: LD_ADDR_VAR 0 33
97054: PUSH
97055: LD_INT 4
97057: NEG
97058: PUSH
97059: LD_INT 4
97061: NEG
97062: PUSH
97063: EMPTY
97064: LIST
97065: LIST
97066: PUSH
97067: LD_INT 4
97069: NEG
97070: PUSH
97071: LD_INT 5
97073: NEG
97074: PUSH
97075: EMPTY
97076: LIST
97077: LIST
97078: PUSH
97079: LD_INT 3
97081: NEG
97082: PUSH
97083: LD_INT 4
97085: NEG
97086: PUSH
97087: EMPTY
97088: LIST
97089: LIST
97090: PUSH
97091: LD_INT 3
97093: NEG
97094: PUSH
97095: LD_INT 3
97097: NEG
97098: PUSH
97099: EMPTY
97100: LIST
97101: LIST
97102: PUSH
97103: LD_INT 4
97105: NEG
97106: PUSH
97107: LD_INT 3
97109: NEG
97110: PUSH
97111: EMPTY
97112: LIST
97113: LIST
97114: PUSH
97115: LD_INT 5
97117: NEG
97118: PUSH
97119: LD_INT 4
97121: NEG
97122: PUSH
97123: EMPTY
97124: LIST
97125: LIST
97126: PUSH
97127: LD_INT 5
97129: NEG
97130: PUSH
97131: LD_INT 5
97133: NEG
97134: PUSH
97135: EMPTY
97136: LIST
97137: LIST
97138: PUSH
97139: LD_INT 3
97141: NEG
97142: PUSH
97143: LD_INT 5
97145: NEG
97146: PUSH
97147: EMPTY
97148: LIST
97149: LIST
97150: PUSH
97151: LD_INT 5
97153: NEG
97154: PUSH
97155: LD_INT 3
97157: NEG
97158: PUSH
97159: EMPTY
97160: LIST
97161: LIST
97162: PUSH
97163: LD_INT 0
97165: PUSH
97166: LD_INT 3
97168: NEG
97169: PUSH
97170: EMPTY
97171: LIST
97172: LIST
97173: PUSH
97174: LD_INT 0
97176: PUSH
97177: LD_INT 4
97179: NEG
97180: PUSH
97181: EMPTY
97182: LIST
97183: LIST
97184: PUSH
97185: LD_INT 1
97187: PUSH
97188: LD_INT 3
97190: NEG
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 1
97198: PUSH
97199: LD_INT 2
97201: NEG
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: PUSH
97207: LD_INT 0
97209: PUSH
97210: LD_INT 2
97212: NEG
97213: PUSH
97214: EMPTY
97215: LIST
97216: LIST
97217: PUSH
97218: LD_INT 1
97220: NEG
97221: PUSH
97222: LD_INT 3
97224: NEG
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: PUSH
97230: LD_INT 1
97232: NEG
97233: PUSH
97234: LD_INT 4
97236: NEG
97237: PUSH
97238: EMPTY
97239: LIST
97240: LIST
97241: PUSH
97242: LD_INT 2
97244: PUSH
97245: LD_INT 2
97247: NEG
97248: PUSH
97249: EMPTY
97250: LIST
97251: LIST
97252: PUSH
97253: LD_INT 2
97255: NEG
97256: PUSH
97257: LD_INT 4
97259: NEG
97260: PUSH
97261: EMPTY
97262: LIST
97263: LIST
97264: PUSH
97265: LD_INT 4
97267: PUSH
97268: LD_INT 0
97270: PUSH
97271: EMPTY
97272: LIST
97273: LIST
97274: PUSH
97275: LD_INT 4
97277: PUSH
97278: LD_INT 1
97280: NEG
97281: PUSH
97282: EMPTY
97283: LIST
97284: LIST
97285: PUSH
97286: LD_INT 5
97288: PUSH
97289: LD_INT 0
97291: PUSH
97292: EMPTY
97293: LIST
97294: LIST
97295: PUSH
97296: LD_INT 5
97298: PUSH
97299: LD_INT 1
97301: PUSH
97302: EMPTY
97303: LIST
97304: LIST
97305: PUSH
97306: LD_INT 4
97308: PUSH
97309: LD_INT 1
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: PUSH
97316: LD_INT 3
97318: PUSH
97319: LD_INT 0
97321: PUSH
97322: EMPTY
97323: LIST
97324: LIST
97325: PUSH
97326: LD_INT 3
97328: PUSH
97329: LD_INT 1
97331: NEG
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PUSH
97337: LD_INT 3
97339: PUSH
97340: LD_INT 2
97342: NEG
97343: PUSH
97344: EMPTY
97345: LIST
97346: LIST
97347: PUSH
97348: LD_INT 5
97350: PUSH
97351: LD_INT 2
97353: PUSH
97354: EMPTY
97355: LIST
97356: LIST
97357: PUSH
97358: LD_INT 3
97360: PUSH
97361: LD_INT 3
97363: PUSH
97364: EMPTY
97365: LIST
97366: LIST
97367: PUSH
97368: LD_INT 3
97370: PUSH
97371: LD_INT 2
97373: PUSH
97374: EMPTY
97375: LIST
97376: LIST
97377: PUSH
97378: LD_INT 4
97380: PUSH
97381: LD_INT 3
97383: PUSH
97384: EMPTY
97385: LIST
97386: LIST
97387: PUSH
97388: LD_INT 4
97390: PUSH
97391: LD_INT 4
97393: PUSH
97394: EMPTY
97395: LIST
97396: LIST
97397: PUSH
97398: LD_INT 3
97400: PUSH
97401: LD_INT 4
97403: PUSH
97404: EMPTY
97405: LIST
97406: LIST
97407: PUSH
97408: LD_INT 2
97410: PUSH
97411: LD_INT 3
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: PUSH
97418: LD_INT 2
97420: PUSH
97421: LD_INT 2
97423: PUSH
97424: EMPTY
97425: LIST
97426: LIST
97427: PUSH
97428: LD_INT 4
97430: PUSH
97431: LD_INT 2
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: PUSH
97438: LD_INT 2
97440: PUSH
97441: LD_INT 4
97443: PUSH
97444: EMPTY
97445: LIST
97446: LIST
97447: PUSH
97448: LD_INT 0
97450: PUSH
97451: LD_INT 4
97453: PUSH
97454: EMPTY
97455: LIST
97456: LIST
97457: PUSH
97458: LD_INT 0
97460: PUSH
97461: LD_INT 3
97463: PUSH
97464: EMPTY
97465: LIST
97466: LIST
97467: PUSH
97468: LD_INT 1
97470: PUSH
97471: LD_INT 4
97473: PUSH
97474: EMPTY
97475: LIST
97476: LIST
97477: PUSH
97478: LD_INT 1
97480: PUSH
97481: LD_INT 5
97483: PUSH
97484: EMPTY
97485: LIST
97486: LIST
97487: PUSH
97488: LD_INT 0
97490: PUSH
97491: LD_INT 5
97493: PUSH
97494: EMPTY
97495: LIST
97496: LIST
97497: PUSH
97498: LD_INT 1
97500: NEG
97501: PUSH
97502: LD_INT 4
97504: PUSH
97505: EMPTY
97506: LIST
97507: LIST
97508: PUSH
97509: LD_INT 1
97511: NEG
97512: PUSH
97513: LD_INT 3
97515: PUSH
97516: EMPTY
97517: LIST
97518: LIST
97519: PUSH
97520: LD_INT 2
97522: PUSH
97523: LD_INT 5
97525: PUSH
97526: EMPTY
97527: LIST
97528: LIST
97529: PUSH
97530: LD_INT 2
97532: NEG
97533: PUSH
97534: LD_INT 3
97536: PUSH
97537: EMPTY
97538: LIST
97539: LIST
97540: PUSH
97541: EMPTY
97542: LIST
97543: LIST
97544: LIST
97545: LIST
97546: LIST
97547: LIST
97548: LIST
97549: LIST
97550: LIST
97551: LIST
97552: LIST
97553: LIST
97554: LIST
97555: LIST
97556: LIST
97557: LIST
97558: LIST
97559: LIST
97560: LIST
97561: LIST
97562: LIST
97563: LIST
97564: LIST
97565: LIST
97566: LIST
97567: LIST
97568: LIST
97569: LIST
97570: LIST
97571: LIST
97572: LIST
97573: LIST
97574: LIST
97575: LIST
97576: LIST
97577: LIST
97578: LIST
97579: LIST
97580: LIST
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
97588: LD_ADDR_VAR 0 34
97592: PUSH
97593: LD_INT 0
97595: PUSH
97596: LD_INT 4
97598: NEG
97599: PUSH
97600: EMPTY
97601: LIST
97602: LIST
97603: PUSH
97604: LD_INT 0
97606: PUSH
97607: LD_INT 5
97609: NEG
97610: PUSH
97611: EMPTY
97612: LIST
97613: LIST
97614: PUSH
97615: LD_INT 1
97617: PUSH
97618: LD_INT 4
97620: NEG
97621: PUSH
97622: EMPTY
97623: LIST
97624: LIST
97625: PUSH
97626: LD_INT 1
97628: PUSH
97629: LD_INT 3
97631: NEG
97632: PUSH
97633: EMPTY
97634: LIST
97635: LIST
97636: PUSH
97637: LD_INT 0
97639: PUSH
97640: LD_INT 3
97642: NEG
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: PUSH
97648: LD_INT 1
97650: NEG
97651: PUSH
97652: LD_INT 4
97654: NEG
97655: PUSH
97656: EMPTY
97657: LIST
97658: LIST
97659: PUSH
97660: LD_INT 1
97662: NEG
97663: PUSH
97664: LD_INT 5
97666: NEG
97667: PUSH
97668: EMPTY
97669: LIST
97670: LIST
97671: PUSH
97672: LD_INT 2
97674: PUSH
97675: LD_INT 3
97677: NEG
97678: PUSH
97679: EMPTY
97680: LIST
97681: LIST
97682: PUSH
97683: LD_INT 2
97685: NEG
97686: PUSH
97687: LD_INT 5
97689: NEG
97690: PUSH
97691: EMPTY
97692: LIST
97693: LIST
97694: PUSH
97695: LD_INT 3
97697: PUSH
97698: LD_INT 0
97700: PUSH
97701: EMPTY
97702: LIST
97703: LIST
97704: PUSH
97705: LD_INT 3
97707: PUSH
97708: LD_INT 1
97710: NEG
97711: PUSH
97712: EMPTY
97713: LIST
97714: LIST
97715: PUSH
97716: LD_INT 4
97718: PUSH
97719: LD_INT 0
97721: PUSH
97722: EMPTY
97723: LIST
97724: LIST
97725: PUSH
97726: LD_INT 4
97728: PUSH
97729: LD_INT 1
97731: PUSH
97732: EMPTY
97733: LIST
97734: LIST
97735: PUSH
97736: LD_INT 3
97738: PUSH
97739: LD_INT 1
97741: PUSH
97742: EMPTY
97743: LIST
97744: LIST
97745: PUSH
97746: LD_INT 2
97748: PUSH
97749: LD_INT 0
97751: PUSH
97752: EMPTY
97753: LIST
97754: LIST
97755: PUSH
97756: LD_INT 2
97758: PUSH
97759: LD_INT 1
97761: NEG
97762: PUSH
97763: EMPTY
97764: LIST
97765: LIST
97766: PUSH
97767: LD_INT 2
97769: PUSH
97770: LD_INT 2
97772: NEG
97773: PUSH
97774: EMPTY
97775: LIST
97776: LIST
97777: PUSH
97778: LD_INT 4
97780: PUSH
97781: LD_INT 2
97783: PUSH
97784: EMPTY
97785: LIST
97786: LIST
97787: PUSH
97788: LD_INT 4
97790: PUSH
97791: LD_INT 4
97793: PUSH
97794: EMPTY
97795: LIST
97796: LIST
97797: PUSH
97798: LD_INT 4
97800: PUSH
97801: LD_INT 3
97803: PUSH
97804: EMPTY
97805: LIST
97806: LIST
97807: PUSH
97808: LD_INT 5
97810: PUSH
97811: LD_INT 4
97813: PUSH
97814: EMPTY
97815: LIST
97816: LIST
97817: PUSH
97818: LD_INT 5
97820: PUSH
97821: LD_INT 5
97823: PUSH
97824: EMPTY
97825: LIST
97826: LIST
97827: PUSH
97828: LD_INT 4
97830: PUSH
97831: LD_INT 5
97833: PUSH
97834: EMPTY
97835: LIST
97836: LIST
97837: PUSH
97838: LD_INT 3
97840: PUSH
97841: LD_INT 4
97843: PUSH
97844: EMPTY
97845: LIST
97846: LIST
97847: PUSH
97848: LD_INT 3
97850: PUSH
97851: LD_INT 3
97853: PUSH
97854: EMPTY
97855: LIST
97856: LIST
97857: PUSH
97858: LD_INT 5
97860: PUSH
97861: LD_INT 3
97863: PUSH
97864: EMPTY
97865: LIST
97866: LIST
97867: PUSH
97868: LD_INT 3
97870: PUSH
97871: LD_INT 5
97873: PUSH
97874: EMPTY
97875: LIST
97876: LIST
97877: PUSH
97878: LD_INT 0
97880: PUSH
97881: LD_INT 3
97883: PUSH
97884: EMPTY
97885: LIST
97886: LIST
97887: PUSH
97888: LD_INT 0
97890: PUSH
97891: LD_INT 2
97893: PUSH
97894: EMPTY
97895: LIST
97896: LIST
97897: PUSH
97898: LD_INT 1
97900: PUSH
97901: LD_INT 3
97903: PUSH
97904: EMPTY
97905: LIST
97906: LIST
97907: PUSH
97908: LD_INT 1
97910: PUSH
97911: LD_INT 4
97913: PUSH
97914: EMPTY
97915: LIST
97916: LIST
97917: PUSH
97918: LD_INT 0
97920: PUSH
97921: LD_INT 4
97923: PUSH
97924: EMPTY
97925: LIST
97926: LIST
97927: PUSH
97928: LD_INT 1
97930: NEG
97931: PUSH
97932: LD_INT 3
97934: PUSH
97935: EMPTY
97936: LIST
97937: LIST
97938: PUSH
97939: LD_INT 1
97941: NEG
97942: PUSH
97943: LD_INT 2
97945: PUSH
97946: EMPTY
97947: LIST
97948: LIST
97949: PUSH
97950: LD_INT 2
97952: PUSH
97953: LD_INT 4
97955: PUSH
97956: EMPTY
97957: LIST
97958: LIST
97959: PUSH
97960: LD_INT 2
97962: NEG
97963: PUSH
97964: LD_INT 2
97966: PUSH
97967: EMPTY
97968: LIST
97969: LIST
97970: PUSH
97971: LD_INT 4
97973: NEG
97974: PUSH
97975: LD_INT 0
97977: PUSH
97978: EMPTY
97979: LIST
97980: LIST
97981: PUSH
97982: LD_INT 4
97984: NEG
97985: PUSH
97986: LD_INT 1
97988: NEG
97989: PUSH
97990: EMPTY
97991: LIST
97992: LIST
97993: PUSH
97994: LD_INT 3
97996: NEG
97997: PUSH
97998: LD_INT 0
98000: PUSH
98001: EMPTY
98002: LIST
98003: LIST
98004: PUSH
98005: LD_INT 3
98007: NEG
98008: PUSH
98009: LD_INT 1
98011: PUSH
98012: EMPTY
98013: LIST
98014: LIST
98015: PUSH
98016: LD_INT 4
98018: NEG
98019: PUSH
98020: LD_INT 1
98022: PUSH
98023: EMPTY
98024: LIST
98025: LIST
98026: PUSH
98027: LD_INT 5
98029: NEG
98030: PUSH
98031: LD_INT 0
98033: PUSH
98034: EMPTY
98035: LIST
98036: LIST
98037: PUSH
98038: LD_INT 5
98040: NEG
98041: PUSH
98042: LD_INT 1
98044: NEG
98045: PUSH
98046: EMPTY
98047: LIST
98048: LIST
98049: PUSH
98050: LD_INT 5
98052: NEG
98053: PUSH
98054: LD_INT 2
98056: NEG
98057: PUSH
98058: EMPTY
98059: LIST
98060: LIST
98061: PUSH
98062: LD_INT 3
98064: NEG
98065: PUSH
98066: LD_INT 2
98068: PUSH
98069: EMPTY
98070: LIST
98071: LIST
98072: PUSH
98073: EMPTY
98074: LIST
98075: LIST
98076: LIST
98077: LIST
98078: LIST
98079: LIST
98080: LIST
98081: LIST
98082: LIST
98083: LIST
98084: LIST
98085: LIST
98086: LIST
98087: LIST
98088: LIST
98089: LIST
98090: LIST
98091: LIST
98092: LIST
98093: LIST
98094: LIST
98095: LIST
98096: LIST
98097: LIST
98098: LIST
98099: LIST
98100: LIST
98101: LIST
98102: LIST
98103: LIST
98104: LIST
98105: LIST
98106: LIST
98107: LIST
98108: LIST
98109: LIST
98110: LIST
98111: LIST
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: LIST
98118: LIST
98119: ST_TO_ADDR
// end ; end ;
98120: GO 98123
98122: POP
// case btype of b_depot , b_warehouse :
98123: LD_VAR 0 1
98127: PUSH
98128: LD_INT 0
98130: DOUBLE
98131: EQUAL
98132: IFTRUE 98142
98134: LD_INT 1
98136: DOUBLE
98137: EQUAL
98138: IFTRUE 98142
98140: GO 98343
98142: POP
// case nation of nation_american :
98143: LD_VAR 0 5
98147: PUSH
98148: LD_INT 1
98150: DOUBLE
98151: EQUAL
98152: IFTRUE 98156
98154: GO 98212
98156: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
98157: LD_ADDR_VAR 0 9
98161: PUSH
98162: LD_VAR 0 11
98166: PUSH
98167: LD_VAR 0 12
98171: PUSH
98172: LD_VAR 0 13
98176: PUSH
98177: LD_VAR 0 14
98181: PUSH
98182: LD_VAR 0 15
98186: PUSH
98187: LD_VAR 0 16
98191: PUSH
98192: EMPTY
98193: LIST
98194: LIST
98195: LIST
98196: LIST
98197: LIST
98198: LIST
98199: PUSH
98200: LD_VAR 0 4
98204: PUSH
98205: LD_INT 1
98207: PLUS
98208: ARRAY
98209: ST_TO_ADDR
98210: GO 98341
98212: LD_INT 2
98214: DOUBLE
98215: EQUAL
98216: IFTRUE 98220
98218: GO 98276
98220: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
98221: LD_ADDR_VAR 0 9
98225: PUSH
98226: LD_VAR 0 17
98230: PUSH
98231: LD_VAR 0 18
98235: PUSH
98236: LD_VAR 0 19
98240: PUSH
98241: LD_VAR 0 20
98245: PUSH
98246: LD_VAR 0 21
98250: PUSH
98251: LD_VAR 0 22
98255: PUSH
98256: EMPTY
98257: LIST
98258: LIST
98259: LIST
98260: LIST
98261: LIST
98262: LIST
98263: PUSH
98264: LD_VAR 0 4
98268: PUSH
98269: LD_INT 1
98271: PLUS
98272: ARRAY
98273: ST_TO_ADDR
98274: GO 98341
98276: LD_INT 3
98278: DOUBLE
98279: EQUAL
98280: IFTRUE 98284
98282: GO 98340
98284: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
98285: LD_ADDR_VAR 0 9
98289: PUSH
98290: LD_VAR 0 23
98294: PUSH
98295: LD_VAR 0 24
98299: PUSH
98300: LD_VAR 0 25
98304: PUSH
98305: LD_VAR 0 26
98309: PUSH
98310: LD_VAR 0 27
98314: PUSH
98315: LD_VAR 0 28
98319: PUSH
98320: EMPTY
98321: LIST
98322: LIST
98323: LIST
98324: LIST
98325: LIST
98326: LIST
98327: PUSH
98328: LD_VAR 0 4
98332: PUSH
98333: LD_INT 1
98335: PLUS
98336: ARRAY
98337: ST_TO_ADDR
98338: GO 98341
98340: POP
98341: GO 98896
98343: LD_INT 2
98345: DOUBLE
98346: EQUAL
98347: IFTRUE 98357
98349: LD_INT 3
98351: DOUBLE
98352: EQUAL
98353: IFTRUE 98357
98355: GO 98413
98357: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
98358: LD_ADDR_VAR 0 9
98362: PUSH
98363: LD_VAR 0 29
98367: PUSH
98368: LD_VAR 0 30
98372: PUSH
98373: LD_VAR 0 31
98377: PUSH
98378: LD_VAR 0 32
98382: PUSH
98383: LD_VAR 0 33
98387: PUSH
98388: LD_VAR 0 34
98392: PUSH
98393: EMPTY
98394: LIST
98395: LIST
98396: LIST
98397: LIST
98398: LIST
98399: LIST
98400: PUSH
98401: LD_VAR 0 4
98405: PUSH
98406: LD_INT 1
98408: PLUS
98409: ARRAY
98410: ST_TO_ADDR
98411: GO 98896
98413: LD_INT 16
98415: DOUBLE
98416: EQUAL
98417: IFTRUE 98475
98419: LD_INT 17
98421: DOUBLE
98422: EQUAL
98423: IFTRUE 98475
98425: LD_INT 18
98427: DOUBLE
98428: EQUAL
98429: IFTRUE 98475
98431: LD_INT 19
98433: DOUBLE
98434: EQUAL
98435: IFTRUE 98475
98437: LD_INT 22
98439: DOUBLE
98440: EQUAL
98441: IFTRUE 98475
98443: LD_INT 20
98445: DOUBLE
98446: EQUAL
98447: IFTRUE 98475
98449: LD_INT 21
98451: DOUBLE
98452: EQUAL
98453: IFTRUE 98475
98455: LD_INT 23
98457: DOUBLE
98458: EQUAL
98459: IFTRUE 98475
98461: LD_INT 24
98463: DOUBLE
98464: EQUAL
98465: IFTRUE 98475
98467: LD_INT 25
98469: DOUBLE
98470: EQUAL
98471: IFTRUE 98475
98473: GO 98531
98475: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
98476: LD_ADDR_VAR 0 9
98480: PUSH
98481: LD_VAR 0 35
98485: PUSH
98486: LD_VAR 0 36
98490: PUSH
98491: LD_VAR 0 37
98495: PUSH
98496: LD_VAR 0 38
98500: PUSH
98501: LD_VAR 0 39
98505: PUSH
98506: LD_VAR 0 40
98510: PUSH
98511: EMPTY
98512: LIST
98513: LIST
98514: LIST
98515: LIST
98516: LIST
98517: LIST
98518: PUSH
98519: LD_VAR 0 4
98523: PUSH
98524: LD_INT 1
98526: PLUS
98527: ARRAY
98528: ST_TO_ADDR
98529: GO 98896
98531: LD_INT 6
98533: DOUBLE
98534: EQUAL
98535: IFTRUE 98587
98537: LD_INT 7
98539: DOUBLE
98540: EQUAL
98541: IFTRUE 98587
98543: LD_INT 8
98545: DOUBLE
98546: EQUAL
98547: IFTRUE 98587
98549: LD_INT 13
98551: DOUBLE
98552: EQUAL
98553: IFTRUE 98587
98555: LD_INT 12
98557: DOUBLE
98558: EQUAL
98559: IFTRUE 98587
98561: LD_INT 15
98563: DOUBLE
98564: EQUAL
98565: IFTRUE 98587
98567: LD_INT 11
98569: DOUBLE
98570: EQUAL
98571: IFTRUE 98587
98573: LD_INT 14
98575: DOUBLE
98576: EQUAL
98577: IFTRUE 98587
98579: LD_INT 10
98581: DOUBLE
98582: EQUAL
98583: IFTRUE 98587
98585: GO 98643
98587: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
98588: LD_ADDR_VAR 0 9
98592: PUSH
98593: LD_VAR 0 41
98597: PUSH
98598: LD_VAR 0 42
98602: PUSH
98603: LD_VAR 0 43
98607: PUSH
98608: LD_VAR 0 44
98612: PUSH
98613: LD_VAR 0 45
98617: PUSH
98618: LD_VAR 0 46
98622: PUSH
98623: EMPTY
98624: LIST
98625: LIST
98626: LIST
98627: LIST
98628: LIST
98629: LIST
98630: PUSH
98631: LD_VAR 0 4
98635: PUSH
98636: LD_INT 1
98638: PLUS
98639: ARRAY
98640: ST_TO_ADDR
98641: GO 98896
98643: LD_INT 36
98645: DOUBLE
98646: EQUAL
98647: IFTRUE 98651
98649: GO 98707
98651: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98652: LD_ADDR_VAR 0 9
98656: PUSH
98657: LD_VAR 0 47
98661: PUSH
98662: LD_VAR 0 48
98666: PUSH
98667: LD_VAR 0 49
98671: PUSH
98672: LD_VAR 0 50
98676: PUSH
98677: LD_VAR 0 51
98681: PUSH
98682: LD_VAR 0 52
98686: PUSH
98687: EMPTY
98688: LIST
98689: LIST
98690: LIST
98691: LIST
98692: LIST
98693: LIST
98694: PUSH
98695: LD_VAR 0 4
98699: PUSH
98700: LD_INT 1
98702: PLUS
98703: ARRAY
98704: ST_TO_ADDR
98705: GO 98896
98707: LD_INT 4
98709: DOUBLE
98710: EQUAL
98711: IFTRUE 98733
98713: LD_INT 5
98715: DOUBLE
98716: EQUAL
98717: IFTRUE 98733
98719: LD_INT 34
98721: DOUBLE
98722: EQUAL
98723: IFTRUE 98733
98725: LD_INT 37
98727: DOUBLE
98728: EQUAL
98729: IFTRUE 98733
98731: GO 98789
98733: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98734: LD_ADDR_VAR 0 9
98738: PUSH
98739: LD_VAR 0 53
98743: PUSH
98744: LD_VAR 0 54
98748: PUSH
98749: LD_VAR 0 55
98753: PUSH
98754: LD_VAR 0 56
98758: PUSH
98759: LD_VAR 0 57
98763: PUSH
98764: LD_VAR 0 58
98768: PUSH
98769: EMPTY
98770: LIST
98771: LIST
98772: LIST
98773: LIST
98774: LIST
98775: LIST
98776: PUSH
98777: LD_VAR 0 4
98781: PUSH
98782: LD_INT 1
98784: PLUS
98785: ARRAY
98786: ST_TO_ADDR
98787: GO 98896
98789: LD_INT 31
98791: DOUBLE
98792: EQUAL
98793: IFTRUE 98839
98795: LD_INT 32
98797: DOUBLE
98798: EQUAL
98799: IFTRUE 98839
98801: LD_INT 33
98803: DOUBLE
98804: EQUAL
98805: IFTRUE 98839
98807: LD_INT 27
98809: DOUBLE
98810: EQUAL
98811: IFTRUE 98839
98813: LD_INT 26
98815: DOUBLE
98816: EQUAL
98817: IFTRUE 98839
98819: LD_INT 28
98821: DOUBLE
98822: EQUAL
98823: IFTRUE 98839
98825: LD_INT 29
98827: DOUBLE
98828: EQUAL
98829: IFTRUE 98839
98831: LD_INT 30
98833: DOUBLE
98834: EQUAL
98835: IFTRUE 98839
98837: GO 98895
98839: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
98840: LD_ADDR_VAR 0 9
98844: PUSH
98845: LD_VAR 0 59
98849: PUSH
98850: LD_VAR 0 60
98854: PUSH
98855: LD_VAR 0 61
98859: PUSH
98860: LD_VAR 0 62
98864: PUSH
98865: LD_VAR 0 63
98869: PUSH
98870: LD_VAR 0 64
98874: PUSH
98875: EMPTY
98876: LIST
98877: LIST
98878: LIST
98879: LIST
98880: LIST
98881: LIST
98882: PUSH
98883: LD_VAR 0 4
98887: PUSH
98888: LD_INT 1
98890: PLUS
98891: ARRAY
98892: ST_TO_ADDR
98893: GO 98896
98895: POP
// temp_list2 = [ ] ;
98896: LD_ADDR_VAR 0 10
98900: PUSH
98901: EMPTY
98902: ST_TO_ADDR
// for i in temp_list do
98903: LD_ADDR_VAR 0 8
98907: PUSH
98908: LD_VAR 0 9
98912: PUSH
98913: FOR_IN
98914: IFFALSE 98966
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98916: LD_ADDR_VAR 0 10
98920: PUSH
98921: LD_VAR 0 10
98925: PUSH
98926: LD_VAR 0 8
98930: PUSH
98931: LD_INT 1
98933: ARRAY
98934: PUSH
98935: LD_VAR 0 2
98939: PLUS
98940: PUSH
98941: LD_VAR 0 8
98945: PUSH
98946: LD_INT 2
98948: ARRAY
98949: PUSH
98950: LD_VAR 0 3
98954: PLUS
98955: PUSH
98956: EMPTY
98957: LIST
98958: LIST
98959: PUSH
98960: EMPTY
98961: LIST
98962: ADD
98963: ST_TO_ADDR
98964: GO 98913
98966: POP
98967: POP
// result = temp_list2 ;
98968: LD_ADDR_VAR 0 7
98972: PUSH
98973: LD_VAR 0 10
98977: ST_TO_ADDR
// end ;
98978: LD_VAR 0 7
98982: RET
// export function EnemyInRange ( unit , dist ) ; begin
98983: LD_INT 0
98985: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98986: LD_ADDR_VAR 0 3
98990: PUSH
98991: LD_VAR 0 1
98995: PPUSH
98996: CALL_OW 255
99000: PPUSH
99001: LD_VAR 0 1
99005: PPUSH
99006: CALL_OW 250
99010: PPUSH
99011: LD_VAR 0 1
99015: PPUSH
99016: CALL_OW 251
99020: PPUSH
99021: LD_VAR 0 2
99025: PPUSH
99026: CALL 73087 0 4
99030: PUSH
99031: LD_INT 4
99033: ARRAY
99034: ST_TO_ADDR
// end ;
99035: LD_VAR 0 3
99039: RET
// export function PlayerSeeMe ( unit ) ; begin
99040: LD_INT 0
99042: PPUSH
// result := See ( your_side , unit ) ;
99043: LD_ADDR_VAR 0 2
99047: PUSH
99048: LD_OWVAR 2
99052: PPUSH
99053: LD_VAR 0 1
99057: PPUSH
99058: CALL_OW 292
99062: ST_TO_ADDR
// end ;
99063: LD_VAR 0 2
99067: RET
// export function ReverseDir ( unit ) ; begin
99068: LD_INT 0
99070: PPUSH
// if not unit then
99071: LD_VAR 0 1
99075: NOT
99076: IFFALSE 99080
// exit ;
99078: GO 99103
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
99080: LD_ADDR_VAR 0 2
99084: PUSH
99085: LD_VAR 0 1
99089: PPUSH
99090: CALL_OW 254
99094: PUSH
99095: LD_INT 3
99097: PLUS
99098: PUSH
99099: LD_INT 6
99101: MOD
99102: ST_TO_ADDR
// end ;
99103: LD_VAR 0 2
99107: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
99108: LD_INT 0
99110: PPUSH
99111: PPUSH
99112: PPUSH
99113: PPUSH
99114: PPUSH
// if not hexes then
99115: LD_VAR 0 2
99119: NOT
99120: IFFALSE 99124
// exit ;
99122: GO 99272
// dist := 9999 ;
99124: LD_ADDR_VAR 0 5
99128: PUSH
99129: LD_INT 9999
99131: ST_TO_ADDR
// for i = 1 to hexes do
99132: LD_ADDR_VAR 0 4
99136: PUSH
99137: DOUBLE
99138: LD_INT 1
99140: DEC
99141: ST_TO_ADDR
99142: LD_VAR 0 2
99146: PUSH
99147: FOR_TO
99148: IFFALSE 99260
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
99150: LD_VAR 0 1
99154: PPUSH
99155: LD_VAR 0 2
99159: PUSH
99160: LD_VAR 0 4
99164: ARRAY
99165: PUSH
99166: LD_INT 1
99168: ARRAY
99169: PPUSH
99170: LD_VAR 0 2
99174: PUSH
99175: LD_VAR 0 4
99179: ARRAY
99180: PUSH
99181: LD_INT 2
99183: ARRAY
99184: PPUSH
99185: CALL_OW 297
99189: PUSH
99190: LD_VAR 0 5
99194: LESS
99195: IFFALSE 99258
// begin hex := hexes [ i ] ;
99197: LD_ADDR_VAR 0 7
99201: PUSH
99202: LD_VAR 0 2
99206: PUSH
99207: LD_VAR 0 4
99211: ARRAY
99212: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
99213: LD_ADDR_VAR 0 5
99217: PUSH
99218: LD_VAR 0 1
99222: PPUSH
99223: LD_VAR 0 2
99227: PUSH
99228: LD_VAR 0 4
99232: ARRAY
99233: PUSH
99234: LD_INT 1
99236: ARRAY
99237: PPUSH
99238: LD_VAR 0 2
99242: PUSH
99243: LD_VAR 0 4
99247: ARRAY
99248: PUSH
99249: LD_INT 2
99251: ARRAY
99252: PPUSH
99253: CALL_OW 297
99257: ST_TO_ADDR
// end ; end ;
99258: GO 99147
99260: POP
99261: POP
// result := hex ;
99262: LD_ADDR_VAR 0 3
99266: PUSH
99267: LD_VAR 0 7
99271: ST_TO_ADDR
// end ;
99272: LD_VAR 0 3
99276: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
99277: LD_INT 0
99279: PPUSH
99280: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99281: LD_VAR 0 1
99285: NOT
99286: PUSH
99287: LD_VAR 0 1
99291: PUSH
99292: LD_INT 21
99294: PUSH
99295: LD_INT 2
99297: PUSH
99298: EMPTY
99299: LIST
99300: LIST
99301: PUSH
99302: LD_INT 23
99304: PUSH
99305: LD_INT 2
99307: PUSH
99308: EMPTY
99309: LIST
99310: LIST
99311: PUSH
99312: EMPTY
99313: LIST
99314: LIST
99315: PPUSH
99316: CALL_OW 69
99320: IN
99321: NOT
99322: OR
99323: IFFALSE 99327
// exit ;
99325: GO 99374
// for i = 1 to 3 do
99327: LD_ADDR_VAR 0 3
99331: PUSH
99332: DOUBLE
99333: LD_INT 1
99335: DEC
99336: ST_TO_ADDR
99337: LD_INT 3
99339: PUSH
99340: FOR_TO
99341: IFFALSE 99372
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
99343: LD_VAR 0 1
99347: PPUSH
99348: CALL_OW 250
99352: PPUSH
99353: LD_VAR 0 1
99357: PPUSH
99358: CALL_OW 251
99362: PPUSH
99363: LD_INT 1
99365: PPUSH
99366: CALL_OW 453
99370: GO 99340
99372: POP
99373: POP
// end ;
99374: LD_VAR 0 2
99378: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
99379: LD_INT 0
99381: PPUSH
99382: PPUSH
99383: PPUSH
99384: PPUSH
99385: PPUSH
99386: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
99387: LD_VAR 0 1
99391: NOT
99392: PUSH
99393: LD_VAR 0 2
99397: NOT
99398: OR
99399: PUSH
99400: LD_VAR 0 1
99404: PPUSH
99405: CALL_OW 314
99409: OR
99410: IFFALSE 99414
// exit ;
99412: GO 99855
// x := GetX ( enemy_unit ) ;
99414: LD_ADDR_VAR 0 7
99418: PUSH
99419: LD_VAR 0 2
99423: PPUSH
99424: CALL_OW 250
99428: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
99429: LD_ADDR_VAR 0 8
99433: PUSH
99434: LD_VAR 0 2
99438: PPUSH
99439: CALL_OW 251
99443: ST_TO_ADDR
// if not x or not y then
99444: LD_VAR 0 7
99448: NOT
99449: PUSH
99450: LD_VAR 0 8
99454: NOT
99455: OR
99456: IFFALSE 99460
// exit ;
99458: GO 99855
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
99460: LD_ADDR_VAR 0 6
99464: PUSH
99465: LD_VAR 0 7
99469: PPUSH
99470: LD_INT 0
99472: PPUSH
99473: LD_INT 4
99475: PPUSH
99476: CALL_OW 272
99480: PUSH
99481: LD_VAR 0 8
99485: PPUSH
99486: LD_INT 0
99488: PPUSH
99489: LD_INT 4
99491: PPUSH
99492: CALL_OW 273
99496: PUSH
99497: EMPTY
99498: LIST
99499: LIST
99500: PUSH
99501: LD_VAR 0 7
99505: PPUSH
99506: LD_INT 1
99508: PPUSH
99509: LD_INT 4
99511: PPUSH
99512: CALL_OW 272
99516: PUSH
99517: LD_VAR 0 8
99521: PPUSH
99522: LD_INT 1
99524: PPUSH
99525: LD_INT 4
99527: PPUSH
99528: CALL_OW 273
99532: PUSH
99533: EMPTY
99534: LIST
99535: LIST
99536: PUSH
99537: LD_VAR 0 7
99541: PPUSH
99542: LD_INT 2
99544: PPUSH
99545: LD_INT 4
99547: PPUSH
99548: CALL_OW 272
99552: PUSH
99553: LD_VAR 0 8
99557: PPUSH
99558: LD_INT 2
99560: PPUSH
99561: LD_INT 4
99563: PPUSH
99564: CALL_OW 273
99568: PUSH
99569: EMPTY
99570: LIST
99571: LIST
99572: PUSH
99573: LD_VAR 0 7
99577: PPUSH
99578: LD_INT 3
99580: PPUSH
99581: LD_INT 4
99583: PPUSH
99584: CALL_OW 272
99588: PUSH
99589: LD_VAR 0 8
99593: PPUSH
99594: LD_INT 3
99596: PPUSH
99597: LD_INT 4
99599: PPUSH
99600: CALL_OW 273
99604: PUSH
99605: EMPTY
99606: LIST
99607: LIST
99608: PUSH
99609: LD_VAR 0 7
99613: PPUSH
99614: LD_INT 4
99616: PPUSH
99617: LD_INT 4
99619: PPUSH
99620: CALL_OW 272
99624: PUSH
99625: LD_VAR 0 8
99629: PPUSH
99630: LD_INT 4
99632: PPUSH
99633: LD_INT 4
99635: PPUSH
99636: CALL_OW 273
99640: PUSH
99641: EMPTY
99642: LIST
99643: LIST
99644: PUSH
99645: LD_VAR 0 7
99649: PPUSH
99650: LD_INT 5
99652: PPUSH
99653: LD_INT 4
99655: PPUSH
99656: CALL_OW 272
99660: PUSH
99661: LD_VAR 0 8
99665: PPUSH
99666: LD_INT 5
99668: PPUSH
99669: LD_INT 4
99671: PPUSH
99672: CALL_OW 273
99676: PUSH
99677: EMPTY
99678: LIST
99679: LIST
99680: PUSH
99681: EMPTY
99682: LIST
99683: LIST
99684: LIST
99685: LIST
99686: LIST
99687: LIST
99688: ST_TO_ADDR
// for i = tmp downto 1 do
99689: LD_ADDR_VAR 0 4
99693: PUSH
99694: DOUBLE
99695: LD_VAR 0 6
99699: INC
99700: ST_TO_ADDR
99701: LD_INT 1
99703: PUSH
99704: FOR_DOWNTO
99705: IFFALSE 99806
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99707: LD_VAR 0 6
99711: PUSH
99712: LD_VAR 0 4
99716: ARRAY
99717: PUSH
99718: LD_INT 1
99720: ARRAY
99721: PPUSH
99722: LD_VAR 0 6
99726: PUSH
99727: LD_VAR 0 4
99731: ARRAY
99732: PUSH
99733: LD_INT 2
99735: ARRAY
99736: PPUSH
99737: CALL_OW 488
99741: NOT
99742: PUSH
99743: LD_VAR 0 6
99747: PUSH
99748: LD_VAR 0 4
99752: ARRAY
99753: PUSH
99754: LD_INT 1
99756: ARRAY
99757: PPUSH
99758: LD_VAR 0 6
99762: PUSH
99763: LD_VAR 0 4
99767: ARRAY
99768: PUSH
99769: LD_INT 2
99771: ARRAY
99772: PPUSH
99773: CALL_OW 428
99777: PUSH
99778: LD_INT 0
99780: NONEQUAL
99781: OR
99782: IFFALSE 99804
// tmp := Delete ( tmp , i ) ;
99784: LD_ADDR_VAR 0 6
99788: PUSH
99789: LD_VAR 0 6
99793: PPUSH
99794: LD_VAR 0 4
99798: PPUSH
99799: CALL_OW 3
99803: ST_TO_ADDR
99804: GO 99704
99806: POP
99807: POP
// j := GetClosestHex ( unit , tmp ) ;
99808: LD_ADDR_VAR 0 5
99812: PUSH
99813: LD_VAR 0 1
99817: PPUSH
99818: LD_VAR 0 6
99822: PPUSH
99823: CALL 99108 0 2
99827: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99828: LD_VAR 0 1
99832: PPUSH
99833: LD_VAR 0 5
99837: PUSH
99838: LD_INT 1
99840: ARRAY
99841: PPUSH
99842: LD_VAR 0 5
99846: PUSH
99847: LD_INT 2
99849: ARRAY
99850: PPUSH
99851: CALL_OW 111
// end ;
99855: LD_VAR 0 3
99859: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99860: LD_INT 0
99862: PPUSH
99863: PPUSH
99864: PPUSH
// uc_side = 0 ;
99865: LD_ADDR_OWVAR 20
99869: PUSH
99870: LD_INT 0
99872: ST_TO_ADDR
// uc_nation = 0 ;
99873: LD_ADDR_OWVAR 21
99877: PUSH
99878: LD_INT 0
99880: ST_TO_ADDR
// InitHc ;
99881: CALL_OW 19
// InitVc ;
99885: CALL_OW 20
// if mastodonts then
99889: LD_VAR 0 6
99893: IFFALSE 99960
// for i = 1 to mastodonts do
99895: LD_ADDR_VAR 0 11
99899: PUSH
99900: DOUBLE
99901: LD_INT 1
99903: DEC
99904: ST_TO_ADDR
99905: LD_VAR 0 6
99909: PUSH
99910: FOR_TO
99911: IFFALSE 99958
// begin vc_chassis := 31 ;
99913: LD_ADDR_OWVAR 37
99917: PUSH
99918: LD_INT 31
99920: ST_TO_ADDR
// vc_control := control_rider ;
99921: LD_ADDR_OWVAR 38
99925: PUSH
99926: LD_INT 4
99928: ST_TO_ADDR
// animal := CreateVehicle ;
99929: LD_ADDR_VAR 0 12
99933: PUSH
99934: CALL_OW 45
99938: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99939: LD_VAR 0 12
99943: PPUSH
99944: LD_VAR 0 8
99948: PPUSH
99949: LD_INT 0
99951: PPUSH
99952: CALL 106738 0 3
// end ;
99956: GO 99910
99958: POP
99959: POP
// if horses then
99960: LD_VAR 0 5
99964: IFFALSE 100031
// for i = 1 to horses do
99966: LD_ADDR_VAR 0 11
99970: PUSH
99971: DOUBLE
99972: LD_INT 1
99974: DEC
99975: ST_TO_ADDR
99976: LD_VAR 0 5
99980: PUSH
99981: FOR_TO
99982: IFFALSE 100029
// begin hc_class := 21 ;
99984: LD_ADDR_OWVAR 28
99988: PUSH
99989: LD_INT 21
99991: ST_TO_ADDR
// hc_gallery :=  ;
99992: LD_ADDR_OWVAR 33
99996: PUSH
99997: LD_STRING 
99999: ST_TO_ADDR
// animal := CreateHuman ;
100000: LD_ADDR_VAR 0 12
100004: PUSH
100005: CALL_OW 44
100009: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100010: LD_VAR 0 12
100014: PPUSH
100015: LD_VAR 0 8
100019: PPUSH
100020: LD_INT 0
100022: PPUSH
100023: CALL 106738 0 3
// end ;
100027: GO 99981
100029: POP
100030: POP
// if birds then
100031: LD_VAR 0 1
100035: IFFALSE 100102
// for i = 1 to birds do
100037: LD_ADDR_VAR 0 11
100041: PUSH
100042: DOUBLE
100043: LD_INT 1
100045: DEC
100046: ST_TO_ADDR
100047: LD_VAR 0 1
100051: PUSH
100052: FOR_TO
100053: IFFALSE 100100
// begin hc_class = 18 ;
100055: LD_ADDR_OWVAR 28
100059: PUSH
100060: LD_INT 18
100062: ST_TO_ADDR
// hc_gallery =  ;
100063: LD_ADDR_OWVAR 33
100067: PUSH
100068: LD_STRING 
100070: ST_TO_ADDR
// animal := CreateHuman ;
100071: LD_ADDR_VAR 0 12
100075: PUSH
100076: CALL_OW 44
100080: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100081: LD_VAR 0 12
100085: PPUSH
100086: LD_VAR 0 8
100090: PPUSH
100091: LD_INT 0
100093: PPUSH
100094: CALL 106738 0 3
// end ;
100098: GO 100052
100100: POP
100101: POP
// if tigers then
100102: LD_VAR 0 2
100106: IFFALSE 100190
// for i = 1 to tigers do
100108: LD_ADDR_VAR 0 11
100112: PUSH
100113: DOUBLE
100114: LD_INT 1
100116: DEC
100117: ST_TO_ADDR
100118: LD_VAR 0 2
100122: PUSH
100123: FOR_TO
100124: IFFALSE 100188
// begin hc_class = class_tiger ;
100126: LD_ADDR_OWVAR 28
100130: PUSH
100131: LD_INT 14
100133: ST_TO_ADDR
// hc_gallery =  ;
100134: LD_ADDR_OWVAR 33
100138: PUSH
100139: LD_STRING 
100141: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
100142: LD_ADDR_OWVAR 35
100146: PUSH
100147: LD_INT 7
100149: NEG
100150: PPUSH
100151: LD_INT 7
100153: PPUSH
100154: CALL_OW 12
100158: ST_TO_ADDR
// animal := CreateHuman ;
100159: LD_ADDR_VAR 0 12
100163: PUSH
100164: CALL_OW 44
100168: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100169: LD_VAR 0 12
100173: PPUSH
100174: LD_VAR 0 8
100178: PPUSH
100179: LD_INT 0
100181: PPUSH
100182: CALL 106738 0 3
// end ;
100186: GO 100123
100188: POP
100189: POP
// if apemans then
100190: LD_VAR 0 3
100194: IFFALSE 100317
// for i = 1 to apemans do
100196: LD_ADDR_VAR 0 11
100200: PUSH
100201: DOUBLE
100202: LD_INT 1
100204: DEC
100205: ST_TO_ADDR
100206: LD_VAR 0 3
100210: PUSH
100211: FOR_TO
100212: IFFALSE 100315
// begin hc_class = class_apeman ;
100214: LD_ADDR_OWVAR 28
100218: PUSH
100219: LD_INT 12
100221: ST_TO_ADDR
// hc_gallery =  ;
100222: LD_ADDR_OWVAR 33
100226: PUSH
100227: LD_STRING 
100229: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
100230: LD_ADDR_OWVAR 35
100234: PUSH
100235: LD_INT 5
100237: NEG
100238: PPUSH
100239: LD_INT 5
100241: PPUSH
100242: CALL_OW 12
100246: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
100247: LD_ADDR_OWVAR 31
100251: PUSH
100252: LD_INT 1
100254: PPUSH
100255: LD_INT 3
100257: PPUSH
100258: CALL_OW 12
100262: PUSH
100263: LD_INT 1
100265: PPUSH
100266: LD_INT 3
100268: PPUSH
100269: CALL_OW 12
100273: PUSH
100274: LD_INT 0
100276: PUSH
100277: LD_INT 0
100279: PUSH
100280: EMPTY
100281: LIST
100282: LIST
100283: LIST
100284: LIST
100285: ST_TO_ADDR
// animal := CreateHuman ;
100286: LD_ADDR_VAR 0 12
100290: PUSH
100291: CALL_OW 44
100295: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100296: LD_VAR 0 12
100300: PPUSH
100301: LD_VAR 0 8
100305: PPUSH
100306: LD_INT 0
100308: PPUSH
100309: CALL 106738 0 3
// end ;
100313: GO 100211
100315: POP
100316: POP
// if enchidnas then
100317: LD_VAR 0 4
100321: IFFALSE 100388
// for i = 1 to enchidnas do
100323: LD_ADDR_VAR 0 11
100327: PUSH
100328: DOUBLE
100329: LD_INT 1
100331: DEC
100332: ST_TO_ADDR
100333: LD_VAR 0 4
100337: PUSH
100338: FOR_TO
100339: IFFALSE 100386
// begin hc_class = 13 ;
100341: LD_ADDR_OWVAR 28
100345: PUSH
100346: LD_INT 13
100348: ST_TO_ADDR
// hc_gallery =  ;
100349: LD_ADDR_OWVAR 33
100353: PUSH
100354: LD_STRING 
100356: ST_TO_ADDR
// animal := CreateHuman ;
100357: LD_ADDR_VAR 0 12
100361: PUSH
100362: CALL_OW 44
100366: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
100367: LD_VAR 0 12
100371: PPUSH
100372: LD_VAR 0 8
100376: PPUSH
100377: LD_INT 0
100379: PPUSH
100380: CALL 106738 0 3
// end ;
100384: GO 100338
100386: POP
100387: POP
// if fishes then
100388: LD_VAR 0 7
100392: IFFALSE 100459
// for i = 1 to fishes do
100394: LD_ADDR_VAR 0 11
100398: PUSH
100399: DOUBLE
100400: LD_INT 1
100402: DEC
100403: ST_TO_ADDR
100404: LD_VAR 0 7
100408: PUSH
100409: FOR_TO
100410: IFFALSE 100457
// begin hc_class = 20 ;
100412: LD_ADDR_OWVAR 28
100416: PUSH
100417: LD_INT 20
100419: ST_TO_ADDR
// hc_gallery =  ;
100420: LD_ADDR_OWVAR 33
100424: PUSH
100425: LD_STRING 
100427: ST_TO_ADDR
// animal := CreateHuman ;
100428: LD_ADDR_VAR 0 12
100432: PUSH
100433: CALL_OW 44
100437: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
100438: LD_VAR 0 12
100442: PPUSH
100443: LD_VAR 0 9
100447: PPUSH
100448: LD_INT 0
100450: PPUSH
100451: CALL 106738 0 3
// end ;
100455: GO 100409
100457: POP
100458: POP
// end ;
100459: LD_VAR 0 10
100463: RET
// export function WantHeal ( sci , unit ) ; begin
100464: LD_INT 0
100466: PPUSH
// if GetTaskList ( sci ) > 0 then
100467: LD_VAR 0 1
100471: PPUSH
100472: CALL_OW 437
100476: PUSH
100477: LD_INT 0
100479: GREATER
100480: IFFALSE 100550
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
100482: LD_VAR 0 1
100486: PPUSH
100487: CALL_OW 437
100491: PUSH
100492: LD_INT 1
100494: ARRAY
100495: PUSH
100496: LD_INT 1
100498: ARRAY
100499: PUSH
100500: LD_STRING l
100502: EQUAL
100503: PUSH
100504: LD_VAR 0 1
100508: PPUSH
100509: CALL_OW 437
100513: PUSH
100514: LD_INT 1
100516: ARRAY
100517: PUSH
100518: LD_INT 4
100520: ARRAY
100521: PUSH
100522: LD_VAR 0 2
100526: EQUAL
100527: AND
100528: IFFALSE 100540
// result := true else
100530: LD_ADDR_VAR 0 3
100534: PUSH
100535: LD_INT 1
100537: ST_TO_ADDR
100538: GO 100548
// result := false ;
100540: LD_ADDR_VAR 0 3
100544: PUSH
100545: LD_INT 0
100547: ST_TO_ADDR
// end else
100548: GO 100558
// result := false ;
100550: LD_ADDR_VAR 0 3
100554: PUSH
100555: LD_INT 0
100557: ST_TO_ADDR
// end ;
100558: LD_VAR 0 3
100562: RET
// export function HealTarget ( sci ) ; begin
100563: LD_INT 0
100565: PPUSH
// if not sci then
100566: LD_VAR 0 1
100570: NOT
100571: IFFALSE 100575
// exit ;
100573: GO 100640
// result := 0 ;
100575: LD_ADDR_VAR 0 2
100579: PUSH
100580: LD_INT 0
100582: ST_TO_ADDR
// if GetTaskList ( sci ) then
100583: LD_VAR 0 1
100587: PPUSH
100588: CALL_OW 437
100592: IFFALSE 100640
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
100594: LD_VAR 0 1
100598: PPUSH
100599: CALL_OW 437
100603: PUSH
100604: LD_INT 1
100606: ARRAY
100607: PUSH
100608: LD_INT 1
100610: ARRAY
100611: PUSH
100612: LD_STRING l
100614: EQUAL
100615: IFFALSE 100640
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100617: LD_ADDR_VAR 0 2
100621: PUSH
100622: LD_VAR 0 1
100626: PPUSH
100627: CALL_OW 437
100631: PUSH
100632: LD_INT 1
100634: ARRAY
100635: PUSH
100636: LD_INT 4
100638: ARRAY
100639: ST_TO_ADDR
// end ;
100640: LD_VAR 0 2
100644: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
100645: LD_INT 0
100647: PPUSH
100648: PPUSH
100649: PPUSH
100650: PPUSH
100651: PPUSH
100652: PPUSH
100653: PPUSH
100654: PPUSH
100655: PPUSH
100656: PPUSH
100657: PPUSH
100658: PPUSH
100659: PPUSH
100660: PPUSH
100661: PPUSH
100662: PPUSH
100663: PPUSH
100664: PPUSH
100665: PPUSH
100666: PPUSH
100667: PPUSH
100668: PPUSH
100669: PPUSH
100670: PPUSH
100671: PPUSH
100672: PPUSH
100673: PPUSH
100674: PPUSH
100675: PPUSH
100676: PPUSH
100677: PPUSH
100678: PPUSH
100679: PPUSH
100680: PPUSH
// if not list then
100681: LD_VAR 0 1
100685: NOT
100686: IFFALSE 100690
// exit ;
100688: GO 105349
// base := list [ 1 ] ;
100690: LD_ADDR_VAR 0 3
100694: PUSH
100695: LD_VAR 0 1
100699: PUSH
100700: LD_INT 1
100702: ARRAY
100703: ST_TO_ADDR
// group := list [ 2 ] ;
100704: LD_ADDR_VAR 0 4
100708: PUSH
100709: LD_VAR 0 1
100713: PUSH
100714: LD_INT 2
100716: ARRAY
100717: ST_TO_ADDR
// path := list [ 3 ] ;
100718: LD_ADDR_VAR 0 5
100722: PUSH
100723: LD_VAR 0 1
100727: PUSH
100728: LD_INT 3
100730: ARRAY
100731: ST_TO_ADDR
// flags := list [ 4 ] ;
100732: LD_ADDR_VAR 0 6
100736: PUSH
100737: LD_VAR 0 1
100741: PUSH
100742: LD_INT 4
100744: ARRAY
100745: ST_TO_ADDR
// mined := [ ] ;
100746: LD_ADDR_VAR 0 27
100750: PUSH
100751: EMPTY
100752: ST_TO_ADDR
// bombed := [ ] ;
100753: LD_ADDR_VAR 0 28
100757: PUSH
100758: EMPTY
100759: ST_TO_ADDR
// healers := [ ] ;
100760: LD_ADDR_VAR 0 31
100764: PUSH
100765: EMPTY
100766: ST_TO_ADDR
// to_heal := [ ] ;
100767: LD_ADDR_VAR 0 30
100771: PUSH
100772: EMPTY
100773: ST_TO_ADDR
// repairs := [ ] ;
100774: LD_ADDR_VAR 0 33
100778: PUSH
100779: EMPTY
100780: ST_TO_ADDR
// to_repair := [ ] ;
100781: LD_ADDR_VAR 0 32
100785: PUSH
100786: EMPTY
100787: ST_TO_ADDR
// if not group or not path then
100788: LD_VAR 0 4
100792: NOT
100793: PUSH
100794: LD_VAR 0 5
100798: NOT
100799: OR
100800: IFFALSE 100804
// exit ;
100802: GO 105349
// side := GetSide ( group [ 1 ] ) ;
100804: LD_ADDR_VAR 0 35
100808: PUSH
100809: LD_VAR 0 4
100813: PUSH
100814: LD_INT 1
100816: ARRAY
100817: PPUSH
100818: CALL_OW 255
100822: ST_TO_ADDR
// if flags then
100823: LD_VAR 0 6
100827: IFFALSE 100971
// begin f_ignore_area := flags [ 1 ] ;
100829: LD_ADDR_VAR 0 17
100833: PUSH
100834: LD_VAR 0 6
100838: PUSH
100839: LD_INT 1
100841: ARRAY
100842: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
100843: LD_ADDR_VAR 0 18
100847: PUSH
100848: LD_VAR 0 6
100852: PUSH
100853: LD_INT 2
100855: ARRAY
100856: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
100857: LD_ADDR_VAR 0 19
100861: PUSH
100862: LD_VAR 0 6
100866: PUSH
100867: LD_INT 3
100869: ARRAY
100870: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
100871: LD_ADDR_VAR 0 20
100875: PUSH
100876: LD_VAR 0 6
100880: PUSH
100881: LD_INT 4
100883: ARRAY
100884: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
100885: LD_ADDR_VAR 0 21
100889: PUSH
100890: LD_VAR 0 6
100894: PUSH
100895: LD_INT 5
100897: ARRAY
100898: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
100899: LD_ADDR_VAR 0 22
100903: PUSH
100904: LD_VAR 0 6
100908: PUSH
100909: LD_INT 6
100911: ARRAY
100912: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
100913: LD_ADDR_VAR 0 23
100917: PUSH
100918: LD_VAR 0 6
100922: PUSH
100923: LD_INT 7
100925: ARRAY
100926: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
100927: LD_ADDR_VAR 0 24
100931: PUSH
100932: LD_VAR 0 6
100936: PUSH
100937: LD_INT 8
100939: ARRAY
100940: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
100941: LD_ADDR_VAR 0 25
100945: PUSH
100946: LD_VAR 0 6
100950: PUSH
100951: LD_INT 9
100953: ARRAY
100954: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
100955: LD_ADDR_VAR 0 26
100959: PUSH
100960: LD_VAR 0 6
100964: PUSH
100965: LD_INT 10
100967: ARRAY
100968: ST_TO_ADDR
// end else
100969: GO 101051
// begin f_ignore_area := false ;
100971: LD_ADDR_VAR 0 17
100975: PUSH
100976: LD_INT 0
100978: ST_TO_ADDR
// f_capture := false ;
100979: LD_ADDR_VAR 0 18
100983: PUSH
100984: LD_INT 0
100986: ST_TO_ADDR
// f_ignore_civ := false ;
100987: LD_ADDR_VAR 0 19
100991: PUSH
100992: LD_INT 0
100994: ST_TO_ADDR
// f_murder := false ;
100995: LD_ADDR_VAR 0 20
100999: PUSH
101000: LD_INT 0
101002: ST_TO_ADDR
// f_mines := false ;
101003: LD_ADDR_VAR 0 21
101007: PUSH
101008: LD_INT 0
101010: ST_TO_ADDR
// f_repair := false ;
101011: LD_ADDR_VAR 0 22
101015: PUSH
101016: LD_INT 0
101018: ST_TO_ADDR
// f_heal := false ;
101019: LD_ADDR_VAR 0 23
101023: PUSH
101024: LD_INT 0
101026: ST_TO_ADDR
// f_spacetime := false ;
101027: LD_ADDR_VAR 0 24
101031: PUSH
101032: LD_INT 0
101034: ST_TO_ADDR
// f_attack_depot := false ;
101035: LD_ADDR_VAR 0 25
101039: PUSH
101040: LD_INT 0
101042: ST_TO_ADDR
// f_crawl := false ;
101043: LD_ADDR_VAR 0 26
101047: PUSH
101048: LD_INT 0
101050: ST_TO_ADDR
// end ; if f_heal then
101051: LD_VAR 0 23
101055: IFFALSE 101082
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
101057: LD_ADDR_VAR 0 31
101061: PUSH
101062: LD_VAR 0 4
101066: PPUSH
101067: LD_INT 25
101069: PUSH
101070: LD_INT 4
101072: PUSH
101073: EMPTY
101074: LIST
101075: LIST
101076: PPUSH
101077: CALL_OW 72
101081: ST_TO_ADDR
// if f_repair then
101082: LD_VAR 0 22
101086: IFFALSE 101113
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
101088: LD_ADDR_VAR 0 33
101092: PUSH
101093: LD_VAR 0 4
101097: PPUSH
101098: LD_INT 25
101100: PUSH
101101: LD_INT 3
101103: PUSH
101104: EMPTY
101105: LIST
101106: LIST
101107: PPUSH
101108: CALL_OW 72
101112: ST_TO_ADDR
// units_path := [ ] ;
101113: LD_ADDR_VAR 0 16
101117: PUSH
101118: EMPTY
101119: ST_TO_ADDR
// for i = 1 to group do
101120: LD_ADDR_VAR 0 7
101124: PUSH
101125: DOUBLE
101126: LD_INT 1
101128: DEC
101129: ST_TO_ADDR
101130: LD_VAR 0 4
101134: PUSH
101135: FOR_TO
101136: IFFALSE 101165
// units_path := Replace ( units_path , i , path ) ;
101138: LD_ADDR_VAR 0 16
101142: PUSH
101143: LD_VAR 0 16
101147: PPUSH
101148: LD_VAR 0 7
101152: PPUSH
101153: LD_VAR 0 5
101157: PPUSH
101158: CALL_OW 1
101162: ST_TO_ADDR
101163: GO 101135
101165: POP
101166: POP
// repeat for i = group downto 1 do
101167: LD_ADDR_VAR 0 7
101171: PUSH
101172: DOUBLE
101173: LD_VAR 0 4
101177: INC
101178: ST_TO_ADDR
101179: LD_INT 1
101181: PUSH
101182: FOR_DOWNTO
101183: IFFALSE 105305
// begin wait ( 5 ) ;
101185: LD_INT 5
101187: PPUSH
101188: CALL_OW 67
// tmp := [ ] ;
101192: LD_ADDR_VAR 0 14
101196: PUSH
101197: EMPTY
101198: ST_TO_ADDR
// attacking := false ;
101199: LD_ADDR_VAR 0 29
101203: PUSH
101204: LD_INT 0
101206: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
101207: LD_VAR 0 4
101211: PUSH
101212: LD_VAR 0 7
101216: ARRAY
101217: PPUSH
101218: CALL_OW 301
101222: PUSH
101223: LD_VAR 0 4
101227: PUSH
101228: LD_VAR 0 7
101232: ARRAY
101233: NOT
101234: OR
101235: IFFALSE 101344
// begin if GetType ( group [ i ] ) = unit_human then
101237: LD_VAR 0 4
101241: PUSH
101242: LD_VAR 0 7
101246: ARRAY
101247: PPUSH
101248: CALL_OW 247
101252: PUSH
101253: LD_INT 1
101255: EQUAL
101256: IFFALSE 101302
// begin to_heal := to_heal diff group [ i ] ;
101258: LD_ADDR_VAR 0 30
101262: PUSH
101263: LD_VAR 0 30
101267: PUSH
101268: LD_VAR 0 4
101272: PUSH
101273: LD_VAR 0 7
101277: ARRAY
101278: DIFF
101279: ST_TO_ADDR
// healers := healers diff group [ i ] ;
101280: LD_ADDR_VAR 0 31
101284: PUSH
101285: LD_VAR 0 31
101289: PUSH
101290: LD_VAR 0 4
101294: PUSH
101295: LD_VAR 0 7
101299: ARRAY
101300: DIFF
101301: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
101302: LD_ADDR_VAR 0 4
101306: PUSH
101307: LD_VAR 0 4
101311: PPUSH
101312: LD_VAR 0 7
101316: PPUSH
101317: CALL_OW 3
101321: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
101322: LD_ADDR_VAR 0 16
101326: PUSH
101327: LD_VAR 0 16
101331: PPUSH
101332: LD_VAR 0 7
101336: PPUSH
101337: CALL_OW 3
101341: ST_TO_ADDR
// continue ;
101342: GO 101182
// end ; if f_repair then
101344: LD_VAR 0 22
101348: IFFALSE 101837
// begin if GetType ( group [ i ] ) = unit_vehicle then
101350: LD_VAR 0 4
101354: PUSH
101355: LD_VAR 0 7
101359: ARRAY
101360: PPUSH
101361: CALL_OW 247
101365: PUSH
101366: LD_INT 2
101368: EQUAL
101369: IFFALSE 101559
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
101371: LD_VAR 0 4
101375: PUSH
101376: LD_VAR 0 7
101380: ARRAY
101381: PPUSH
101382: CALL_OW 256
101386: PUSH
101387: LD_INT 700
101389: LESS
101390: PUSH
101391: LD_VAR 0 4
101395: PUSH
101396: LD_VAR 0 7
101400: ARRAY
101401: PUSH
101402: LD_VAR 0 32
101406: IN
101407: NOT
101408: AND
101409: IFFALSE 101433
// to_repair := to_repair union group [ i ] ;
101411: LD_ADDR_VAR 0 32
101415: PUSH
101416: LD_VAR 0 32
101420: PUSH
101421: LD_VAR 0 4
101425: PUSH
101426: LD_VAR 0 7
101430: ARRAY
101431: UNION
101432: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
101433: LD_VAR 0 4
101437: PUSH
101438: LD_VAR 0 7
101442: ARRAY
101443: PPUSH
101444: CALL_OW 256
101448: PUSH
101449: LD_INT 1000
101451: EQUAL
101452: PUSH
101453: LD_VAR 0 4
101457: PUSH
101458: LD_VAR 0 7
101462: ARRAY
101463: PUSH
101464: LD_VAR 0 32
101468: IN
101469: AND
101470: IFFALSE 101494
// to_repair := to_repair diff group [ i ] ;
101472: LD_ADDR_VAR 0 32
101476: PUSH
101477: LD_VAR 0 32
101481: PUSH
101482: LD_VAR 0 4
101486: PUSH
101487: LD_VAR 0 7
101491: ARRAY
101492: DIFF
101493: ST_TO_ADDR
// if group [ i ] in to_repair then
101494: LD_VAR 0 4
101498: PUSH
101499: LD_VAR 0 7
101503: ARRAY
101504: PUSH
101505: LD_VAR 0 32
101509: IN
101510: IFFALSE 101557
// begin if not IsInArea ( group [ i ] , f_repair ) then
101512: LD_VAR 0 4
101516: PUSH
101517: LD_VAR 0 7
101521: ARRAY
101522: PPUSH
101523: LD_VAR 0 22
101527: PPUSH
101528: CALL_OW 308
101532: NOT
101533: IFFALSE 101555
// ComMoveToArea ( group [ i ] , f_repair ) ;
101535: LD_VAR 0 4
101539: PUSH
101540: LD_VAR 0 7
101544: ARRAY
101545: PPUSH
101546: LD_VAR 0 22
101550: PPUSH
101551: CALL_OW 113
// continue ;
101555: GO 101182
// end ; end else
101557: GO 101837
// if group [ i ] in repairs then
101559: LD_VAR 0 4
101563: PUSH
101564: LD_VAR 0 7
101568: ARRAY
101569: PUSH
101570: LD_VAR 0 33
101574: IN
101575: IFFALSE 101837
// begin if IsInUnit ( group [ i ] ) then
101577: LD_VAR 0 4
101581: PUSH
101582: LD_VAR 0 7
101586: ARRAY
101587: PPUSH
101588: CALL_OW 310
101592: IFFALSE 101660
// begin z := IsInUnit ( group [ i ] ) ;
101594: LD_ADDR_VAR 0 13
101598: PUSH
101599: LD_VAR 0 4
101603: PUSH
101604: LD_VAR 0 7
101608: ARRAY
101609: PPUSH
101610: CALL_OW 310
101614: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
101615: LD_VAR 0 13
101619: PUSH
101620: LD_VAR 0 32
101624: IN
101625: PUSH
101626: LD_VAR 0 13
101630: PPUSH
101631: LD_VAR 0 22
101635: PPUSH
101636: CALL_OW 308
101640: AND
101641: IFFALSE 101658
// ComExitVehicle ( group [ i ] ) ;
101643: LD_VAR 0 4
101647: PUSH
101648: LD_VAR 0 7
101652: ARRAY
101653: PPUSH
101654: CALL_OW 121
// end else
101658: GO 101837
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
101660: LD_ADDR_VAR 0 13
101664: PUSH
101665: LD_VAR 0 4
101669: PPUSH
101670: LD_INT 95
101672: PUSH
101673: LD_VAR 0 22
101677: PUSH
101678: EMPTY
101679: LIST
101680: LIST
101681: PUSH
101682: LD_INT 58
101684: PUSH
101685: EMPTY
101686: LIST
101687: PUSH
101688: EMPTY
101689: LIST
101690: LIST
101691: PPUSH
101692: CALL_OW 72
101696: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
101697: LD_VAR 0 4
101701: PUSH
101702: LD_VAR 0 7
101706: ARRAY
101707: PPUSH
101708: CALL_OW 314
101712: NOT
101713: IFFALSE 101835
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
101715: LD_ADDR_VAR 0 10
101719: PUSH
101720: LD_VAR 0 13
101724: PPUSH
101725: LD_VAR 0 4
101729: PUSH
101730: LD_VAR 0 7
101734: ARRAY
101735: PPUSH
101736: CALL_OW 74
101740: ST_TO_ADDR
// if not x then
101741: LD_VAR 0 10
101745: NOT
101746: IFFALSE 101750
// continue ;
101748: GO 101182
// if GetLives ( x ) < 1000 then
101750: LD_VAR 0 10
101754: PPUSH
101755: CALL_OW 256
101759: PUSH
101760: LD_INT 1000
101762: LESS
101763: IFFALSE 101787
// ComRepairVehicle ( group [ i ] , x ) else
101765: LD_VAR 0 4
101769: PUSH
101770: LD_VAR 0 7
101774: ARRAY
101775: PPUSH
101776: LD_VAR 0 10
101780: PPUSH
101781: CALL_OW 129
101785: GO 101835
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
101787: LD_VAR 0 23
101791: PUSH
101792: LD_VAR 0 4
101796: PUSH
101797: LD_VAR 0 7
101801: ARRAY
101802: PPUSH
101803: CALL_OW 256
101807: PUSH
101808: LD_INT 1000
101810: LESS
101811: AND
101812: NOT
101813: IFFALSE 101835
// ComEnterUnit ( group [ i ] , x ) ;
101815: LD_VAR 0 4
101819: PUSH
101820: LD_VAR 0 7
101824: ARRAY
101825: PPUSH
101826: LD_VAR 0 10
101830: PPUSH
101831: CALL_OW 120
// end ; continue ;
101835: GO 101182
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
101837: LD_VAR 0 23
101841: PUSH
101842: LD_VAR 0 4
101846: PUSH
101847: LD_VAR 0 7
101851: ARRAY
101852: PPUSH
101853: CALL_OW 247
101857: PUSH
101858: LD_INT 1
101860: EQUAL
101861: AND
101862: IFFALSE 102340
// begin if group [ i ] in healers then
101864: LD_VAR 0 4
101868: PUSH
101869: LD_VAR 0 7
101873: ARRAY
101874: PUSH
101875: LD_VAR 0 31
101879: IN
101880: IFFALSE 102153
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
101882: LD_VAR 0 4
101886: PUSH
101887: LD_VAR 0 7
101891: ARRAY
101892: PPUSH
101893: LD_VAR 0 23
101897: PPUSH
101898: CALL_OW 308
101902: NOT
101903: PUSH
101904: LD_VAR 0 4
101908: PUSH
101909: LD_VAR 0 7
101913: ARRAY
101914: PPUSH
101915: CALL_OW 314
101919: NOT
101920: AND
101921: IFFALSE 101945
// ComMoveToArea ( group [ i ] , f_heal ) else
101923: LD_VAR 0 4
101927: PUSH
101928: LD_VAR 0 7
101932: ARRAY
101933: PPUSH
101934: LD_VAR 0 23
101938: PPUSH
101939: CALL_OW 113
101943: GO 102151
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
101945: LD_VAR 0 4
101949: PUSH
101950: LD_VAR 0 7
101954: ARRAY
101955: PPUSH
101956: CALL 100563 0 1
101960: PPUSH
101961: CALL_OW 256
101965: PUSH
101966: LD_INT 1000
101968: EQUAL
101969: IFFALSE 101988
// ComStop ( group [ i ] ) else
101971: LD_VAR 0 4
101975: PUSH
101976: LD_VAR 0 7
101980: ARRAY
101981: PPUSH
101982: CALL_OW 141
101986: GO 102151
// if not HasTask ( group [ i ] ) and to_heal then
101988: LD_VAR 0 4
101992: PUSH
101993: LD_VAR 0 7
101997: ARRAY
101998: PPUSH
101999: CALL_OW 314
102003: NOT
102004: PUSH
102005: LD_VAR 0 30
102009: AND
102010: IFFALSE 102151
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
102012: LD_ADDR_VAR 0 13
102016: PUSH
102017: LD_VAR 0 30
102021: PPUSH
102022: LD_INT 3
102024: PUSH
102025: LD_INT 54
102027: PUSH
102028: EMPTY
102029: LIST
102030: PUSH
102031: EMPTY
102032: LIST
102033: LIST
102034: PPUSH
102035: CALL_OW 72
102039: PPUSH
102040: LD_VAR 0 4
102044: PUSH
102045: LD_VAR 0 7
102049: ARRAY
102050: PPUSH
102051: CALL_OW 74
102055: ST_TO_ADDR
// if z then
102056: LD_VAR 0 13
102060: IFFALSE 102151
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
102062: LD_INT 91
102064: PUSH
102065: LD_VAR 0 13
102069: PUSH
102070: LD_INT 10
102072: PUSH
102073: EMPTY
102074: LIST
102075: LIST
102076: LIST
102077: PUSH
102078: LD_INT 81
102080: PUSH
102081: LD_VAR 0 13
102085: PPUSH
102086: CALL_OW 255
102090: PUSH
102091: EMPTY
102092: LIST
102093: LIST
102094: PUSH
102095: EMPTY
102096: LIST
102097: LIST
102098: PPUSH
102099: CALL_OW 69
102103: PUSH
102104: LD_INT 0
102106: EQUAL
102107: IFFALSE 102131
// ComHeal ( group [ i ] , z ) else
102109: LD_VAR 0 4
102113: PUSH
102114: LD_VAR 0 7
102118: ARRAY
102119: PPUSH
102120: LD_VAR 0 13
102124: PPUSH
102125: CALL_OW 128
102129: GO 102151
// ComMoveToArea ( group [ i ] , f_heal ) ;
102131: LD_VAR 0 4
102135: PUSH
102136: LD_VAR 0 7
102140: ARRAY
102141: PPUSH
102142: LD_VAR 0 23
102146: PPUSH
102147: CALL_OW 113
// end ; continue ;
102151: GO 101182
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
102153: LD_VAR 0 4
102157: PUSH
102158: LD_VAR 0 7
102162: ARRAY
102163: PPUSH
102164: CALL_OW 256
102168: PUSH
102169: LD_INT 700
102171: LESS
102172: PUSH
102173: LD_VAR 0 4
102177: PUSH
102178: LD_VAR 0 7
102182: ARRAY
102183: PUSH
102184: LD_VAR 0 30
102188: IN
102189: NOT
102190: AND
102191: IFFALSE 102215
// to_heal := to_heal union group [ i ] ;
102193: LD_ADDR_VAR 0 30
102197: PUSH
102198: LD_VAR 0 30
102202: PUSH
102203: LD_VAR 0 4
102207: PUSH
102208: LD_VAR 0 7
102212: ARRAY
102213: UNION
102214: ST_TO_ADDR
// if group [ i ] in to_heal then
102215: LD_VAR 0 4
102219: PUSH
102220: LD_VAR 0 7
102224: ARRAY
102225: PUSH
102226: LD_VAR 0 30
102230: IN
102231: IFFALSE 102340
// begin if GetLives ( group [ i ] ) = 1000 then
102233: LD_VAR 0 4
102237: PUSH
102238: LD_VAR 0 7
102242: ARRAY
102243: PPUSH
102244: CALL_OW 256
102248: PUSH
102249: LD_INT 1000
102251: EQUAL
102252: IFFALSE 102278
// to_heal := to_heal diff group [ i ] else
102254: LD_ADDR_VAR 0 30
102258: PUSH
102259: LD_VAR 0 30
102263: PUSH
102264: LD_VAR 0 4
102268: PUSH
102269: LD_VAR 0 7
102273: ARRAY
102274: DIFF
102275: ST_TO_ADDR
102276: GO 102340
// begin if not IsInArea ( group [ i ] , to_heal ) then
102278: LD_VAR 0 4
102282: PUSH
102283: LD_VAR 0 7
102287: ARRAY
102288: PPUSH
102289: LD_VAR 0 30
102293: PPUSH
102294: CALL_OW 308
102298: NOT
102299: IFFALSE 102323
// ComMoveToArea ( group [ i ] , f_heal ) else
102301: LD_VAR 0 4
102305: PUSH
102306: LD_VAR 0 7
102310: ARRAY
102311: PPUSH
102312: LD_VAR 0 23
102316: PPUSH
102317: CALL_OW 113
102321: GO 102338
// ComHold ( group [ i ] ) ;
102323: LD_VAR 0 4
102327: PUSH
102328: LD_VAR 0 7
102332: ARRAY
102333: PPUSH
102334: CALL_OW 140
// continue ;
102338: GO 101182
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
102340: LD_VAR 0 4
102344: PUSH
102345: LD_VAR 0 7
102349: ARRAY
102350: PPUSH
102351: LD_INT 10
102353: PPUSH
102354: CALL 98983 0 2
102358: NOT
102359: PUSH
102360: LD_VAR 0 16
102364: PUSH
102365: LD_VAR 0 7
102369: ARRAY
102370: PUSH
102371: EMPTY
102372: EQUAL
102373: NOT
102374: AND
102375: IFFALSE 102641
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
102377: LD_VAR 0 4
102381: PUSH
102382: LD_VAR 0 7
102386: ARRAY
102387: PPUSH
102388: CALL_OW 262
102392: PUSH
102393: LD_INT 1
102395: PUSH
102396: LD_INT 2
102398: PUSH
102399: EMPTY
102400: LIST
102401: LIST
102402: IN
102403: IFFALSE 102444
// if GetFuel ( group [ i ] ) < 10 then
102405: LD_VAR 0 4
102409: PUSH
102410: LD_VAR 0 7
102414: ARRAY
102415: PPUSH
102416: CALL_OW 261
102420: PUSH
102421: LD_INT 10
102423: LESS
102424: IFFALSE 102444
// SetFuel ( group [ i ] , 12 ) ;
102426: LD_VAR 0 4
102430: PUSH
102431: LD_VAR 0 7
102435: ARRAY
102436: PPUSH
102437: LD_INT 12
102439: PPUSH
102440: CALL_OW 240
// if units_path [ i ] then
102444: LD_VAR 0 16
102448: PUSH
102449: LD_VAR 0 7
102453: ARRAY
102454: IFFALSE 102639
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
102456: LD_VAR 0 4
102460: PUSH
102461: LD_VAR 0 7
102465: ARRAY
102466: PPUSH
102467: LD_VAR 0 16
102471: PUSH
102472: LD_VAR 0 7
102476: ARRAY
102477: PUSH
102478: LD_INT 1
102480: ARRAY
102481: PUSH
102482: LD_INT 1
102484: ARRAY
102485: PPUSH
102486: LD_VAR 0 16
102490: PUSH
102491: LD_VAR 0 7
102495: ARRAY
102496: PUSH
102497: LD_INT 1
102499: ARRAY
102500: PUSH
102501: LD_INT 2
102503: ARRAY
102504: PPUSH
102505: CALL_OW 297
102509: PUSH
102510: LD_INT 6
102512: GREATER
102513: IFFALSE 102588
// begin if not HasTask ( group [ i ] ) then
102515: LD_VAR 0 4
102519: PUSH
102520: LD_VAR 0 7
102524: ARRAY
102525: PPUSH
102526: CALL_OW 314
102530: NOT
102531: IFFALSE 102586
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
102533: LD_VAR 0 4
102537: PUSH
102538: LD_VAR 0 7
102542: ARRAY
102543: PPUSH
102544: LD_VAR 0 16
102548: PUSH
102549: LD_VAR 0 7
102553: ARRAY
102554: PUSH
102555: LD_INT 1
102557: ARRAY
102558: PUSH
102559: LD_INT 1
102561: ARRAY
102562: PPUSH
102563: LD_VAR 0 16
102567: PUSH
102568: LD_VAR 0 7
102572: ARRAY
102573: PUSH
102574: LD_INT 1
102576: ARRAY
102577: PUSH
102578: LD_INT 2
102580: ARRAY
102581: PPUSH
102582: CALL_OW 114
// end else
102586: GO 102639
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
102588: LD_ADDR_VAR 0 15
102592: PUSH
102593: LD_VAR 0 16
102597: PUSH
102598: LD_VAR 0 7
102602: ARRAY
102603: PPUSH
102604: LD_INT 1
102606: PPUSH
102607: CALL_OW 3
102611: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
102612: LD_ADDR_VAR 0 16
102616: PUSH
102617: LD_VAR 0 16
102621: PPUSH
102622: LD_VAR 0 7
102626: PPUSH
102627: LD_VAR 0 15
102631: PPUSH
102632: CALL_OW 1
102636: ST_TO_ADDR
// continue ;
102637: GO 101182
// end ; end ; end else
102639: GO 105303
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
102641: LD_ADDR_VAR 0 14
102645: PUSH
102646: LD_INT 81
102648: PUSH
102649: LD_VAR 0 4
102653: PUSH
102654: LD_VAR 0 7
102658: ARRAY
102659: PPUSH
102660: CALL_OW 255
102664: PUSH
102665: EMPTY
102666: LIST
102667: LIST
102668: PPUSH
102669: CALL_OW 69
102673: ST_TO_ADDR
// if not tmp then
102674: LD_VAR 0 14
102678: NOT
102679: IFFALSE 102683
// continue ;
102681: GO 101182
// if f_ignore_area then
102683: LD_VAR 0 17
102687: IFFALSE 102775
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
102689: LD_ADDR_VAR 0 15
102693: PUSH
102694: LD_VAR 0 14
102698: PPUSH
102699: LD_INT 3
102701: PUSH
102702: LD_INT 92
102704: PUSH
102705: LD_VAR 0 17
102709: PUSH
102710: LD_INT 1
102712: ARRAY
102713: PUSH
102714: LD_VAR 0 17
102718: PUSH
102719: LD_INT 2
102721: ARRAY
102722: PUSH
102723: LD_VAR 0 17
102727: PUSH
102728: LD_INT 3
102730: ARRAY
102731: PUSH
102732: EMPTY
102733: LIST
102734: LIST
102735: LIST
102736: LIST
102737: PUSH
102738: EMPTY
102739: LIST
102740: LIST
102741: PPUSH
102742: CALL_OW 72
102746: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102747: LD_VAR 0 14
102751: PUSH
102752: LD_VAR 0 15
102756: DIFF
102757: IFFALSE 102775
// tmp := tmp diff tmp2 ;
102759: LD_ADDR_VAR 0 14
102763: PUSH
102764: LD_VAR 0 14
102768: PUSH
102769: LD_VAR 0 15
102773: DIFF
102774: ST_TO_ADDR
// end ; if not f_murder then
102775: LD_VAR 0 20
102779: NOT
102780: IFFALSE 102838
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
102782: LD_ADDR_VAR 0 15
102786: PUSH
102787: LD_VAR 0 14
102791: PPUSH
102792: LD_INT 3
102794: PUSH
102795: LD_INT 50
102797: PUSH
102798: EMPTY
102799: LIST
102800: PUSH
102801: EMPTY
102802: LIST
102803: LIST
102804: PPUSH
102805: CALL_OW 72
102809: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
102810: LD_VAR 0 14
102814: PUSH
102815: LD_VAR 0 15
102819: DIFF
102820: IFFALSE 102838
// tmp := tmp diff tmp2 ;
102822: LD_ADDR_VAR 0 14
102826: PUSH
102827: LD_VAR 0 14
102831: PUSH
102832: LD_VAR 0 15
102836: DIFF
102837: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
102838: LD_ADDR_VAR 0 14
102842: PUSH
102843: LD_VAR 0 4
102847: PUSH
102848: LD_VAR 0 7
102852: ARRAY
102853: PPUSH
102854: LD_VAR 0 14
102858: PPUSH
102859: LD_INT 1
102861: PPUSH
102862: LD_INT 1
102864: PPUSH
102865: CALL 72626 0 4
102869: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
102870: LD_VAR 0 4
102874: PUSH
102875: LD_VAR 0 7
102879: ARRAY
102880: PPUSH
102881: CALL_OW 257
102885: PUSH
102886: LD_INT 1
102888: EQUAL
102889: IFFALSE 103337
// begin if WantPlant ( group [ i ] ) then
102891: LD_VAR 0 4
102895: PUSH
102896: LD_VAR 0 7
102900: ARRAY
102901: PPUSH
102902: CALL 72127 0 1
102906: IFFALSE 102910
// continue ;
102908: GO 101182
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
102910: LD_VAR 0 18
102914: PUSH
102915: LD_VAR 0 4
102919: PUSH
102920: LD_VAR 0 7
102924: ARRAY
102925: PPUSH
102926: CALL_OW 310
102930: NOT
102931: AND
102932: PUSH
102933: LD_VAR 0 14
102937: PUSH
102938: LD_INT 1
102940: ARRAY
102941: PUSH
102942: LD_VAR 0 14
102946: PPUSH
102947: LD_INT 21
102949: PUSH
102950: LD_INT 2
102952: PUSH
102953: EMPTY
102954: LIST
102955: LIST
102956: PUSH
102957: LD_INT 58
102959: PUSH
102960: EMPTY
102961: LIST
102962: PUSH
102963: EMPTY
102964: LIST
102965: LIST
102966: PPUSH
102967: CALL_OW 72
102971: IN
102972: AND
102973: IFFALSE 103009
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102975: LD_VAR 0 4
102979: PUSH
102980: LD_VAR 0 7
102984: ARRAY
102985: PPUSH
102986: LD_VAR 0 14
102990: PUSH
102991: LD_INT 1
102993: ARRAY
102994: PPUSH
102995: CALL_OW 120
// attacking := true ;
102999: LD_ADDR_VAR 0 29
103003: PUSH
103004: LD_INT 1
103006: ST_TO_ADDR
// continue ;
103007: GO 101182
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
103009: LD_VAR 0 26
103013: PUSH
103014: LD_VAR 0 4
103018: PUSH
103019: LD_VAR 0 7
103023: ARRAY
103024: PPUSH
103025: CALL_OW 257
103029: PUSH
103030: LD_INT 1
103032: EQUAL
103033: AND
103034: PUSH
103035: LD_VAR 0 4
103039: PUSH
103040: LD_VAR 0 7
103044: ARRAY
103045: PPUSH
103046: CALL_OW 256
103050: PUSH
103051: LD_INT 800
103053: LESS
103054: AND
103055: PUSH
103056: LD_VAR 0 4
103060: PUSH
103061: LD_VAR 0 7
103065: ARRAY
103066: PPUSH
103067: CALL_OW 318
103071: NOT
103072: AND
103073: IFFALSE 103090
// ComCrawl ( group [ i ] ) ;
103075: LD_VAR 0 4
103079: PUSH
103080: LD_VAR 0 7
103084: ARRAY
103085: PPUSH
103086: CALL_OW 137
// if f_mines then
103090: LD_VAR 0 21
103094: IFFALSE 103337
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
103096: LD_VAR 0 14
103100: PUSH
103101: LD_INT 1
103103: ARRAY
103104: PPUSH
103105: CALL_OW 247
103109: PUSH
103110: LD_INT 3
103112: EQUAL
103113: PUSH
103114: LD_VAR 0 14
103118: PUSH
103119: LD_INT 1
103121: ARRAY
103122: PUSH
103123: LD_VAR 0 27
103127: IN
103128: NOT
103129: AND
103130: IFFALSE 103337
// begin x := GetX ( tmp [ 1 ] ) ;
103132: LD_ADDR_VAR 0 10
103136: PUSH
103137: LD_VAR 0 14
103141: PUSH
103142: LD_INT 1
103144: ARRAY
103145: PPUSH
103146: CALL_OW 250
103150: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
103151: LD_ADDR_VAR 0 11
103155: PUSH
103156: LD_VAR 0 14
103160: PUSH
103161: LD_INT 1
103163: ARRAY
103164: PPUSH
103165: CALL_OW 251
103169: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
103170: LD_ADDR_VAR 0 12
103174: PUSH
103175: LD_VAR 0 4
103179: PUSH
103180: LD_VAR 0 7
103184: ARRAY
103185: PPUSH
103186: CALL 99068 0 1
103190: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
103191: LD_VAR 0 4
103195: PUSH
103196: LD_VAR 0 7
103200: ARRAY
103201: PPUSH
103202: LD_VAR 0 10
103206: PPUSH
103207: LD_VAR 0 11
103211: PPUSH
103212: LD_VAR 0 14
103216: PUSH
103217: LD_INT 1
103219: ARRAY
103220: PPUSH
103221: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
103225: LD_VAR 0 4
103229: PUSH
103230: LD_VAR 0 7
103234: ARRAY
103235: PPUSH
103236: LD_VAR 0 10
103240: PPUSH
103241: LD_VAR 0 12
103245: PPUSH
103246: LD_INT 7
103248: PPUSH
103249: CALL_OW 272
103253: PPUSH
103254: LD_VAR 0 11
103258: PPUSH
103259: LD_VAR 0 12
103263: PPUSH
103264: LD_INT 7
103266: PPUSH
103267: CALL_OW 273
103271: PPUSH
103272: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
103276: LD_VAR 0 4
103280: PUSH
103281: LD_VAR 0 7
103285: ARRAY
103286: PPUSH
103287: LD_INT 71
103289: PPUSH
103290: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
103294: LD_ADDR_VAR 0 27
103298: PUSH
103299: LD_VAR 0 27
103303: PPUSH
103304: LD_VAR 0 27
103308: PUSH
103309: LD_INT 1
103311: PLUS
103312: PPUSH
103313: LD_VAR 0 14
103317: PUSH
103318: LD_INT 1
103320: ARRAY
103321: PPUSH
103322: CALL_OW 1
103326: ST_TO_ADDR
// attacking := true ;
103327: LD_ADDR_VAR 0 29
103331: PUSH
103332: LD_INT 1
103334: ST_TO_ADDR
// continue ;
103335: GO 101182
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
103337: LD_VAR 0 4
103341: PUSH
103342: LD_VAR 0 7
103346: ARRAY
103347: PPUSH
103348: CALL_OW 257
103352: PUSH
103353: LD_INT 17
103355: EQUAL
103356: PUSH
103357: LD_VAR 0 4
103361: PUSH
103362: LD_VAR 0 7
103366: ARRAY
103367: PPUSH
103368: CALL_OW 110
103372: PUSH
103373: LD_INT 71
103375: EQUAL
103376: NOT
103377: AND
103378: IFFALSE 103524
// begin attacking := false ;
103380: LD_ADDR_VAR 0 29
103384: PUSH
103385: LD_INT 0
103387: ST_TO_ADDR
// k := 5 ;
103388: LD_ADDR_VAR 0 9
103392: PUSH
103393: LD_INT 5
103395: ST_TO_ADDR
// if tmp < k then
103396: LD_VAR 0 14
103400: PUSH
103401: LD_VAR 0 9
103405: LESS
103406: IFFALSE 103418
// k := tmp ;
103408: LD_ADDR_VAR 0 9
103412: PUSH
103413: LD_VAR 0 14
103417: ST_TO_ADDR
// for j = 1 to k do
103418: LD_ADDR_VAR 0 8
103422: PUSH
103423: DOUBLE
103424: LD_INT 1
103426: DEC
103427: ST_TO_ADDR
103428: LD_VAR 0 9
103432: PUSH
103433: FOR_TO
103434: IFFALSE 103522
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
103436: LD_VAR 0 14
103440: PUSH
103441: LD_VAR 0 8
103445: ARRAY
103446: PUSH
103447: LD_VAR 0 14
103451: PPUSH
103452: LD_INT 58
103454: PUSH
103455: EMPTY
103456: LIST
103457: PPUSH
103458: CALL_OW 72
103462: IN
103463: NOT
103464: IFFALSE 103520
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103466: LD_VAR 0 4
103470: PUSH
103471: LD_VAR 0 7
103475: ARRAY
103476: PPUSH
103477: LD_VAR 0 14
103481: PUSH
103482: LD_VAR 0 8
103486: ARRAY
103487: PPUSH
103488: CALL_OW 115
// attacking := true ;
103492: LD_ADDR_VAR 0 29
103496: PUSH
103497: LD_INT 1
103499: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
103500: LD_VAR 0 4
103504: PUSH
103505: LD_VAR 0 7
103509: ARRAY
103510: PPUSH
103511: LD_INT 71
103513: PPUSH
103514: CALL_OW 109
// continue ;
103518: GO 103433
// end ; end ;
103520: GO 103433
103522: POP
103523: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
103524: LD_VAR 0 4
103528: PUSH
103529: LD_VAR 0 7
103533: ARRAY
103534: PPUSH
103535: CALL_OW 257
103539: PUSH
103540: LD_INT 8
103542: EQUAL
103543: PUSH
103544: LD_VAR 0 4
103548: PUSH
103549: LD_VAR 0 7
103553: ARRAY
103554: PPUSH
103555: CALL_OW 264
103559: PUSH
103560: LD_INT 28
103562: PUSH
103563: LD_INT 45
103565: PUSH
103566: LD_INT 7
103568: PUSH
103569: LD_INT 47
103571: PUSH
103572: EMPTY
103573: LIST
103574: LIST
103575: LIST
103576: LIST
103577: IN
103578: OR
103579: IFFALSE 103835
// begin attacking := false ;
103581: LD_ADDR_VAR 0 29
103585: PUSH
103586: LD_INT 0
103588: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
103589: LD_VAR 0 14
103593: PUSH
103594: LD_INT 1
103596: ARRAY
103597: PPUSH
103598: CALL_OW 266
103602: PUSH
103603: LD_INT 32
103605: PUSH
103606: LD_INT 31
103608: PUSH
103609: LD_INT 33
103611: PUSH
103612: LD_INT 4
103614: PUSH
103615: LD_INT 5
103617: PUSH
103618: EMPTY
103619: LIST
103620: LIST
103621: LIST
103622: LIST
103623: LIST
103624: IN
103625: IFFALSE 103811
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
103627: LD_ADDR_VAR 0 9
103631: PUSH
103632: LD_VAR 0 14
103636: PUSH
103637: LD_INT 1
103639: ARRAY
103640: PPUSH
103641: CALL_OW 266
103645: PPUSH
103646: LD_VAR 0 14
103650: PUSH
103651: LD_INT 1
103653: ARRAY
103654: PPUSH
103655: CALL_OW 250
103659: PPUSH
103660: LD_VAR 0 14
103664: PUSH
103665: LD_INT 1
103667: ARRAY
103668: PPUSH
103669: CALL_OW 251
103673: PPUSH
103674: LD_VAR 0 14
103678: PUSH
103679: LD_INT 1
103681: ARRAY
103682: PPUSH
103683: CALL_OW 254
103687: PPUSH
103688: LD_VAR 0 14
103692: PUSH
103693: LD_INT 1
103695: ARRAY
103696: PPUSH
103697: CALL_OW 248
103701: PPUSH
103702: LD_INT 0
103704: PPUSH
103705: CALL 80438 0 6
103709: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
103710: LD_ADDR_VAR 0 8
103714: PUSH
103715: LD_VAR 0 4
103719: PUSH
103720: LD_VAR 0 7
103724: ARRAY
103725: PPUSH
103726: LD_VAR 0 9
103730: PPUSH
103731: CALL 99108 0 2
103735: ST_TO_ADDR
// if j then
103736: LD_VAR 0 8
103740: IFFALSE 103809
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
103742: LD_VAR 0 8
103746: PUSH
103747: LD_INT 1
103749: ARRAY
103750: PPUSH
103751: LD_VAR 0 8
103755: PUSH
103756: LD_INT 2
103758: ARRAY
103759: PPUSH
103760: CALL_OW 488
103764: IFFALSE 103809
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
103766: LD_VAR 0 4
103770: PUSH
103771: LD_VAR 0 7
103775: ARRAY
103776: PPUSH
103777: LD_VAR 0 8
103781: PUSH
103782: LD_INT 1
103784: ARRAY
103785: PPUSH
103786: LD_VAR 0 8
103790: PUSH
103791: LD_INT 2
103793: ARRAY
103794: PPUSH
103795: CALL_OW 116
// attacking := true ;
103799: LD_ADDR_VAR 0 29
103803: PUSH
103804: LD_INT 1
103806: ST_TO_ADDR
// continue ;
103807: GO 101182
// end ; end else
103809: GO 103835
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103811: LD_VAR 0 4
103815: PUSH
103816: LD_VAR 0 7
103820: ARRAY
103821: PPUSH
103822: LD_VAR 0 14
103826: PUSH
103827: LD_INT 1
103829: ARRAY
103830: PPUSH
103831: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
103835: LD_VAR 0 4
103839: PUSH
103840: LD_VAR 0 7
103844: ARRAY
103845: PPUSH
103846: CALL_OW 265
103850: PUSH
103851: LD_INT 11
103853: EQUAL
103854: IFFALSE 104132
// begin k := 10 ;
103856: LD_ADDR_VAR 0 9
103860: PUSH
103861: LD_INT 10
103863: ST_TO_ADDR
// x := 0 ;
103864: LD_ADDR_VAR 0 10
103868: PUSH
103869: LD_INT 0
103871: ST_TO_ADDR
// if tmp < k then
103872: LD_VAR 0 14
103876: PUSH
103877: LD_VAR 0 9
103881: LESS
103882: IFFALSE 103894
// k := tmp ;
103884: LD_ADDR_VAR 0 9
103888: PUSH
103889: LD_VAR 0 14
103893: ST_TO_ADDR
// for j = k downto 1 do
103894: LD_ADDR_VAR 0 8
103898: PUSH
103899: DOUBLE
103900: LD_VAR 0 9
103904: INC
103905: ST_TO_ADDR
103906: LD_INT 1
103908: PUSH
103909: FOR_DOWNTO
103910: IFFALSE 103985
// begin if GetType ( tmp [ j ] ) = unit_human then
103912: LD_VAR 0 14
103916: PUSH
103917: LD_VAR 0 8
103921: ARRAY
103922: PPUSH
103923: CALL_OW 247
103927: PUSH
103928: LD_INT 1
103930: EQUAL
103931: IFFALSE 103983
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
103933: LD_VAR 0 4
103937: PUSH
103938: LD_VAR 0 7
103942: ARRAY
103943: PPUSH
103944: LD_VAR 0 14
103948: PUSH
103949: LD_VAR 0 8
103953: ARRAY
103954: PPUSH
103955: CALL 99379 0 2
// x := tmp [ j ] ;
103959: LD_ADDR_VAR 0 10
103963: PUSH
103964: LD_VAR 0 14
103968: PUSH
103969: LD_VAR 0 8
103973: ARRAY
103974: ST_TO_ADDR
// attacking := true ;
103975: LD_ADDR_VAR 0 29
103979: PUSH
103980: LD_INT 1
103982: ST_TO_ADDR
// end ; end ;
103983: GO 103909
103985: POP
103986: POP
// if not x then
103987: LD_VAR 0 10
103991: NOT
103992: IFFALSE 104132
// begin attacking := true ;
103994: LD_ADDR_VAR 0 29
103998: PUSH
103999: LD_INT 1
104001: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
104002: LD_VAR 0 4
104006: PUSH
104007: LD_VAR 0 7
104011: ARRAY
104012: PPUSH
104013: CALL_OW 250
104017: PPUSH
104018: LD_VAR 0 4
104022: PUSH
104023: LD_VAR 0 7
104027: ARRAY
104028: PPUSH
104029: CALL_OW 251
104033: PPUSH
104034: CALL_OW 546
104038: PUSH
104039: LD_INT 2
104041: ARRAY
104042: PUSH
104043: LD_VAR 0 14
104047: PUSH
104048: LD_INT 1
104050: ARRAY
104051: PPUSH
104052: CALL_OW 250
104056: PPUSH
104057: LD_VAR 0 14
104061: PUSH
104062: LD_INT 1
104064: ARRAY
104065: PPUSH
104066: CALL_OW 251
104070: PPUSH
104071: CALL_OW 546
104075: PUSH
104076: LD_INT 2
104078: ARRAY
104079: EQUAL
104080: IFFALSE 104108
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
104082: LD_VAR 0 4
104086: PUSH
104087: LD_VAR 0 7
104091: ARRAY
104092: PPUSH
104093: LD_VAR 0 14
104097: PUSH
104098: LD_INT 1
104100: ARRAY
104101: PPUSH
104102: CALL 99379 0 2
104106: GO 104132
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104108: LD_VAR 0 4
104112: PUSH
104113: LD_VAR 0 7
104117: ARRAY
104118: PPUSH
104119: LD_VAR 0 14
104123: PUSH
104124: LD_INT 1
104126: ARRAY
104127: PPUSH
104128: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
104132: LD_VAR 0 4
104136: PUSH
104137: LD_VAR 0 7
104141: ARRAY
104142: PPUSH
104143: CALL_OW 264
104147: PUSH
104148: LD_INT 29
104150: EQUAL
104151: IFFALSE 104517
// begin if WantsToAttack ( group [ i ] ) in bombed then
104153: LD_VAR 0 4
104157: PUSH
104158: LD_VAR 0 7
104162: ARRAY
104163: PPUSH
104164: CALL_OW 319
104168: PUSH
104169: LD_VAR 0 28
104173: IN
104174: IFFALSE 104178
// continue ;
104176: GO 101182
// k := 8 ;
104178: LD_ADDR_VAR 0 9
104182: PUSH
104183: LD_INT 8
104185: ST_TO_ADDR
// x := 0 ;
104186: LD_ADDR_VAR 0 10
104190: PUSH
104191: LD_INT 0
104193: ST_TO_ADDR
// if tmp < k then
104194: LD_VAR 0 14
104198: PUSH
104199: LD_VAR 0 9
104203: LESS
104204: IFFALSE 104216
// k := tmp ;
104206: LD_ADDR_VAR 0 9
104210: PUSH
104211: LD_VAR 0 14
104215: ST_TO_ADDR
// for j = 1 to k do
104216: LD_ADDR_VAR 0 8
104220: PUSH
104221: DOUBLE
104222: LD_INT 1
104224: DEC
104225: ST_TO_ADDR
104226: LD_VAR 0 9
104230: PUSH
104231: FOR_TO
104232: IFFALSE 104364
// begin if GetType ( tmp [ j ] ) = unit_building then
104234: LD_VAR 0 14
104238: PUSH
104239: LD_VAR 0 8
104243: ARRAY
104244: PPUSH
104245: CALL_OW 247
104249: PUSH
104250: LD_INT 3
104252: EQUAL
104253: IFFALSE 104362
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
104255: LD_VAR 0 14
104259: PUSH
104260: LD_VAR 0 8
104264: ARRAY
104265: PUSH
104266: LD_VAR 0 28
104270: IN
104271: NOT
104272: PUSH
104273: LD_VAR 0 14
104277: PUSH
104278: LD_VAR 0 8
104282: ARRAY
104283: PPUSH
104284: CALL_OW 313
104288: AND
104289: IFFALSE 104362
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104291: LD_VAR 0 4
104295: PUSH
104296: LD_VAR 0 7
104300: ARRAY
104301: PPUSH
104302: LD_VAR 0 14
104306: PUSH
104307: LD_VAR 0 8
104311: ARRAY
104312: PPUSH
104313: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
104317: LD_ADDR_VAR 0 28
104321: PUSH
104322: LD_VAR 0 28
104326: PPUSH
104327: LD_VAR 0 28
104331: PUSH
104332: LD_INT 1
104334: PLUS
104335: PPUSH
104336: LD_VAR 0 14
104340: PUSH
104341: LD_VAR 0 8
104345: ARRAY
104346: PPUSH
104347: CALL_OW 1
104351: ST_TO_ADDR
// attacking := true ;
104352: LD_ADDR_VAR 0 29
104356: PUSH
104357: LD_INT 1
104359: ST_TO_ADDR
// break ;
104360: GO 104364
// end ; end ;
104362: GO 104231
104364: POP
104365: POP
// if not attacking and f_attack_depot then
104366: LD_VAR 0 29
104370: NOT
104371: PUSH
104372: LD_VAR 0 25
104376: AND
104377: IFFALSE 104472
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104379: LD_ADDR_VAR 0 13
104383: PUSH
104384: LD_VAR 0 14
104388: PPUSH
104389: LD_INT 2
104391: PUSH
104392: LD_INT 30
104394: PUSH
104395: LD_INT 0
104397: PUSH
104398: EMPTY
104399: LIST
104400: LIST
104401: PUSH
104402: LD_INT 30
104404: PUSH
104405: LD_INT 1
104407: PUSH
104408: EMPTY
104409: LIST
104410: LIST
104411: PUSH
104412: EMPTY
104413: LIST
104414: LIST
104415: LIST
104416: PPUSH
104417: CALL_OW 72
104421: ST_TO_ADDR
// if z then
104422: LD_VAR 0 13
104426: IFFALSE 104472
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
104428: LD_VAR 0 4
104432: PUSH
104433: LD_VAR 0 7
104437: ARRAY
104438: PPUSH
104439: LD_VAR 0 13
104443: PPUSH
104444: LD_VAR 0 4
104448: PUSH
104449: LD_VAR 0 7
104453: ARRAY
104454: PPUSH
104455: CALL_OW 74
104459: PPUSH
104460: CALL_OW 115
// attacking := true ;
104464: LD_ADDR_VAR 0 29
104468: PUSH
104469: LD_INT 1
104471: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
104472: LD_VAR 0 4
104476: PUSH
104477: LD_VAR 0 7
104481: ARRAY
104482: PPUSH
104483: CALL_OW 256
104487: PUSH
104488: LD_INT 500
104490: LESS
104491: IFFALSE 104517
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104493: LD_VAR 0 4
104497: PUSH
104498: LD_VAR 0 7
104502: ARRAY
104503: PPUSH
104504: LD_VAR 0 14
104508: PUSH
104509: LD_INT 1
104511: ARRAY
104512: PPUSH
104513: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
104517: LD_VAR 0 4
104521: PUSH
104522: LD_VAR 0 7
104526: ARRAY
104527: PPUSH
104528: CALL_OW 264
104532: PUSH
104533: LD_INT 49
104535: EQUAL
104536: IFFALSE 104657
// begin if not HasTask ( group [ i ] ) then
104538: LD_VAR 0 4
104542: PUSH
104543: LD_VAR 0 7
104547: ARRAY
104548: PPUSH
104549: CALL_OW 314
104553: NOT
104554: IFFALSE 104657
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
104556: LD_ADDR_VAR 0 9
104560: PUSH
104561: LD_INT 81
104563: PUSH
104564: LD_VAR 0 4
104568: PUSH
104569: LD_VAR 0 7
104573: ARRAY
104574: PPUSH
104575: CALL_OW 255
104579: PUSH
104580: EMPTY
104581: LIST
104582: LIST
104583: PPUSH
104584: CALL_OW 69
104588: PPUSH
104589: LD_VAR 0 4
104593: PUSH
104594: LD_VAR 0 7
104598: ARRAY
104599: PPUSH
104600: CALL_OW 74
104604: ST_TO_ADDR
// if k then
104605: LD_VAR 0 9
104609: IFFALSE 104657
// if GetDistUnits ( group [ i ] , k ) > 10 then
104611: LD_VAR 0 4
104615: PUSH
104616: LD_VAR 0 7
104620: ARRAY
104621: PPUSH
104622: LD_VAR 0 9
104626: PPUSH
104627: CALL_OW 296
104631: PUSH
104632: LD_INT 10
104634: GREATER
104635: IFFALSE 104657
// ComMoveUnit ( group [ i ] , k ) ;
104637: LD_VAR 0 4
104641: PUSH
104642: LD_VAR 0 7
104646: ARRAY
104647: PPUSH
104648: LD_VAR 0 9
104652: PPUSH
104653: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
104657: LD_VAR 0 4
104661: PUSH
104662: LD_VAR 0 7
104666: ARRAY
104667: PPUSH
104668: CALL_OW 256
104672: PUSH
104673: LD_INT 250
104675: LESS
104676: PUSH
104677: LD_VAR 0 4
104681: PUSH
104682: LD_VAR 0 7
104686: ARRAY
104687: PUSH
104688: LD_INT 21
104690: PUSH
104691: LD_INT 2
104693: PUSH
104694: EMPTY
104695: LIST
104696: LIST
104697: PUSH
104698: LD_INT 23
104700: PUSH
104701: LD_INT 2
104703: PUSH
104704: EMPTY
104705: LIST
104706: LIST
104707: PUSH
104708: EMPTY
104709: LIST
104710: LIST
104711: PPUSH
104712: CALL_OW 69
104716: IN
104717: AND
104718: IFFALSE 104843
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
104720: LD_ADDR_VAR 0 9
104724: PUSH
104725: LD_OWVAR 3
104729: PUSH
104730: LD_VAR 0 4
104734: PUSH
104735: LD_VAR 0 7
104739: ARRAY
104740: DIFF
104741: PPUSH
104742: LD_VAR 0 4
104746: PUSH
104747: LD_VAR 0 7
104751: ARRAY
104752: PPUSH
104753: CALL_OW 74
104757: ST_TO_ADDR
// if not k then
104758: LD_VAR 0 9
104762: NOT
104763: IFFALSE 104767
// continue ;
104765: GO 101182
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
104767: LD_VAR 0 9
104771: PUSH
104772: LD_INT 81
104774: PUSH
104775: LD_VAR 0 4
104779: PUSH
104780: LD_VAR 0 7
104784: ARRAY
104785: PPUSH
104786: CALL_OW 255
104790: PUSH
104791: EMPTY
104792: LIST
104793: LIST
104794: PPUSH
104795: CALL_OW 69
104799: IN
104800: PUSH
104801: LD_VAR 0 9
104805: PPUSH
104806: LD_VAR 0 4
104810: PUSH
104811: LD_VAR 0 7
104815: ARRAY
104816: PPUSH
104817: CALL_OW 296
104821: PUSH
104822: LD_INT 5
104824: LESS
104825: AND
104826: IFFALSE 104843
// ComAutodestruct ( group [ i ] ) ;
104828: LD_VAR 0 4
104832: PUSH
104833: LD_VAR 0 7
104837: ARRAY
104838: PPUSH
104839: CALL 99277 0 1
// end ; if f_attack_depot then
104843: LD_VAR 0 25
104847: IFFALSE 104959
// begin k := 6 ;
104849: LD_ADDR_VAR 0 9
104853: PUSH
104854: LD_INT 6
104856: ST_TO_ADDR
// if tmp < k then
104857: LD_VAR 0 14
104861: PUSH
104862: LD_VAR 0 9
104866: LESS
104867: IFFALSE 104879
// k := tmp ;
104869: LD_ADDR_VAR 0 9
104873: PUSH
104874: LD_VAR 0 14
104878: ST_TO_ADDR
// for j = 1 to k do
104879: LD_ADDR_VAR 0 8
104883: PUSH
104884: DOUBLE
104885: LD_INT 1
104887: DEC
104888: ST_TO_ADDR
104889: LD_VAR 0 9
104893: PUSH
104894: FOR_TO
104895: IFFALSE 104957
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
104897: LD_VAR 0 8
104901: PPUSH
104902: CALL_OW 266
104906: PUSH
104907: LD_INT 0
104909: PUSH
104910: LD_INT 1
104912: PUSH
104913: EMPTY
104914: LIST
104915: LIST
104916: IN
104917: IFFALSE 104955
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
104919: LD_VAR 0 4
104923: PUSH
104924: LD_VAR 0 7
104928: ARRAY
104929: PPUSH
104930: LD_VAR 0 14
104934: PUSH
104935: LD_VAR 0 8
104939: ARRAY
104940: PPUSH
104941: CALL_OW 115
// attacking := true ;
104945: LD_ADDR_VAR 0 29
104949: PUSH
104950: LD_INT 1
104952: ST_TO_ADDR
// break ;
104953: GO 104957
// end ;
104955: GO 104894
104957: POP
104958: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
104959: LD_VAR 0 4
104963: PUSH
104964: LD_VAR 0 7
104968: ARRAY
104969: PPUSH
104970: CALL_OW 302
104974: PUSH
104975: LD_VAR 0 29
104979: NOT
104980: AND
104981: IFFALSE 105303
// begin if GetTag ( group [ i ] ) = 71 then
104983: LD_VAR 0 4
104987: PUSH
104988: LD_VAR 0 7
104992: ARRAY
104993: PPUSH
104994: CALL_OW 110
104998: PUSH
104999: LD_INT 71
105001: EQUAL
105002: IFFALSE 105043
// begin if HasTask ( group [ i ] ) then
105004: LD_VAR 0 4
105008: PUSH
105009: LD_VAR 0 7
105013: ARRAY
105014: PPUSH
105015: CALL_OW 314
105019: IFFALSE 105025
// continue else
105021: GO 101182
105023: GO 105043
// SetTag ( group [ i ] , 0 ) ;
105025: LD_VAR 0 4
105029: PUSH
105030: LD_VAR 0 7
105034: ARRAY
105035: PPUSH
105036: LD_INT 0
105038: PPUSH
105039: CALL_OW 109
// end ; k := 8 ;
105043: LD_ADDR_VAR 0 9
105047: PUSH
105048: LD_INT 8
105050: ST_TO_ADDR
// x := 0 ;
105051: LD_ADDR_VAR 0 10
105055: PUSH
105056: LD_INT 0
105058: ST_TO_ADDR
// if tmp < k then
105059: LD_VAR 0 14
105063: PUSH
105064: LD_VAR 0 9
105068: LESS
105069: IFFALSE 105081
// k := tmp ;
105071: LD_ADDR_VAR 0 9
105075: PUSH
105076: LD_VAR 0 14
105080: ST_TO_ADDR
// for j = 1 to k do
105081: LD_ADDR_VAR 0 8
105085: PUSH
105086: DOUBLE
105087: LD_INT 1
105089: DEC
105090: ST_TO_ADDR
105091: LD_VAR 0 9
105095: PUSH
105096: FOR_TO
105097: IFFALSE 105195
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
105099: LD_VAR 0 14
105103: PUSH
105104: LD_VAR 0 8
105108: ARRAY
105109: PPUSH
105110: CALL_OW 247
105114: PUSH
105115: LD_INT 1
105117: EQUAL
105118: PUSH
105119: LD_VAR 0 14
105123: PUSH
105124: LD_VAR 0 8
105128: ARRAY
105129: PPUSH
105130: CALL_OW 256
105134: PUSH
105135: LD_INT 250
105137: LESS
105138: PUSH
105139: LD_VAR 0 20
105143: AND
105144: PUSH
105145: LD_VAR 0 20
105149: NOT
105150: PUSH
105151: LD_VAR 0 14
105155: PUSH
105156: LD_VAR 0 8
105160: ARRAY
105161: PPUSH
105162: CALL_OW 256
105166: PUSH
105167: LD_INT 250
105169: GREATEREQUAL
105170: AND
105171: OR
105172: AND
105173: IFFALSE 105193
// begin x := tmp [ j ] ;
105175: LD_ADDR_VAR 0 10
105179: PUSH
105180: LD_VAR 0 14
105184: PUSH
105185: LD_VAR 0 8
105189: ARRAY
105190: ST_TO_ADDR
// break ;
105191: GO 105195
// end ;
105193: GO 105096
105195: POP
105196: POP
// if x then
105197: LD_VAR 0 10
105201: IFFALSE 105225
// ComAttackUnit ( group [ i ] , x ) else
105203: LD_VAR 0 4
105207: PUSH
105208: LD_VAR 0 7
105212: ARRAY
105213: PPUSH
105214: LD_VAR 0 10
105218: PPUSH
105219: CALL_OW 115
105223: GO 105249
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105225: LD_VAR 0 4
105229: PUSH
105230: LD_VAR 0 7
105234: ARRAY
105235: PPUSH
105236: LD_VAR 0 14
105240: PUSH
105241: LD_INT 1
105243: ARRAY
105244: PPUSH
105245: CALL_OW 115
// if not HasTask ( group [ i ] ) then
105249: LD_VAR 0 4
105253: PUSH
105254: LD_VAR 0 7
105258: ARRAY
105259: PPUSH
105260: CALL_OW 314
105264: NOT
105265: IFFALSE 105303
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
105267: LD_VAR 0 4
105271: PUSH
105272: LD_VAR 0 7
105276: ARRAY
105277: PPUSH
105278: LD_VAR 0 14
105282: PPUSH
105283: LD_VAR 0 4
105287: PUSH
105288: LD_VAR 0 7
105292: ARRAY
105293: PPUSH
105294: CALL_OW 74
105298: PPUSH
105299: CALL_OW 115
// end ; end ; end ;
105303: GO 101182
105305: POP
105306: POP
// wait ( 0 0$2 ) ;
105307: LD_INT 70
105309: PPUSH
105310: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
105314: LD_VAR 0 4
105318: NOT
105319: PUSH
105320: LD_VAR 0 4
105324: PUSH
105325: EMPTY
105326: EQUAL
105327: OR
105328: PUSH
105329: LD_INT 81
105331: PUSH
105332: LD_VAR 0 35
105336: PUSH
105337: EMPTY
105338: LIST
105339: LIST
105340: PPUSH
105341: CALL_OW 69
105345: NOT
105346: OR
105347: IFFALSE 101167
// end ;
105349: LD_VAR 0 2
105353: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
105354: LD_INT 0
105356: PPUSH
105357: PPUSH
105358: PPUSH
105359: PPUSH
// if not base_units then
105360: LD_VAR 0 1
105364: NOT
105365: IFFALSE 105369
// exit ;
105367: GO 105456
// result := false ;
105369: LD_ADDR_VAR 0 2
105373: PUSH
105374: LD_INT 0
105376: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
105377: LD_ADDR_VAR 0 5
105381: PUSH
105382: LD_VAR 0 1
105386: PPUSH
105387: LD_INT 21
105389: PUSH
105390: LD_INT 3
105392: PUSH
105393: EMPTY
105394: LIST
105395: LIST
105396: PPUSH
105397: CALL_OW 72
105401: ST_TO_ADDR
// if not tmp then
105402: LD_VAR 0 5
105406: NOT
105407: IFFALSE 105411
// exit ;
105409: GO 105456
// for i in tmp do
105411: LD_ADDR_VAR 0 3
105415: PUSH
105416: LD_VAR 0 5
105420: PUSH
105421: FOR_IN
105422: IFFALSE 105454
// begin result := EnemyInRange ( i , 22 ) ;
105424: LD_ADDR_VAR 0 2
105428: PUSH
105429: LD_VAR 0 3
105433: PPUSH
105434: LD_INT 22
105436: PPUSH
105437: CALL 98983 0 2
105441: ST_TO_ADDR
// if result then
105442: LD_VAR 0 2
105446: IFFALSE 105452
// exit ;
105448: POP
105449: POP
105450: GO 105456
// end ;
105452: GO 105421
105454: POP
105455: POP
// end ;
105456: LD_VAR 0 2
105460: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
105461: LD_INT 0
105463: PPUSH
105464: PPUSH
// if not units then
105465: LD_VAR 0 1
105469: NOT
105470: IFFALSE 105474
// exit ;
105472: GO 105544
// result := [ ] ;
105474: LD_ADDR_VAR 0 3
105478: PUSH
105479: EMPTY
105480: ST_TO_ADDR
// for i in units do
105481: LD_ADDR_VAR 0 4
105485: PUSH
105486: LD_VAR 0 1
105490: PUSH
105491: FOR_IN
105492: IFFALSE 105542
// if GetTag ( i ) = tag then
105494: LD_VAR 0 4
105498: PPUSH
105499: CALL_OW 110
105503: PUSH
105504: LD_VAR 0 2
105508: EQUAL
105509: IFFALSE 105540
// result := Insert ( result , result + 1 , i ) ;
105511: LD_ADDR_VAR 0 3
105515: PUSH
105516: LD_VAR 0 3
105520: PPUSH
105521: LD_VAR 0 3
105525: PUSH
105526: LD_INT 1
105528: PLUS
105529: PPUSH
105530: LD_VAR 0 4
105534: PPUSH
105535: CALL_OW 2
105539: ST_TO_ADDR
105540: GO 105491
105542: POP
105543: POP
// end ;
105544: LD_VAR 0 3
105548: RET
// export function IsDriver ( un ) ; begin
105549: LD_INT 0
105551: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
105552: LD_ADDR_VAR 0 2
105556: PUSH
105557: LD_VAR 0 1
105561: PUSH
105562: LD_INT 55
105564: PUSH
105565: EMPTY
105566: LIST
105567: PPUSH
105568: CALL_OW 69
105572: IN
105573: ST_TO_ADDR
// end ;
105574: LD_VAR 0 2
105578: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
105579: LD_INT 0
105581: PPUSH
105582: PPUSH
// list := [ ] ;
105583: LD_ADDR_VAR 0 5
105587: PUSH
105588: EMPTY
105589: ST_TO_ADDR
// case d of 0 :
105590: LD_VAR 0 3
105594: PUSH
105595: LD_INT 0
105597: DOUBLE
105598: EQUAL
105599: IFTRUE 105603
105601: GO 105736
105603: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
105604: LD_ADDR_VAR 0 5
105608: PUSH
105609: LD_VAR 0 1
105613: PUSH
105614: LD_INT 4
105616: MINUS
105617: PUSH
105618: LD_VAR 0 2
105622: PUSH
105623: LD_INT 4
105625: MINUS
105626: PUSH
105627: LD_INT 2
105629: PUSH
105630: EMPTY
105631: LIST
105632: LIST
105633: LIST
105634: PUSH
105635: LD_VAR 0 1
105639: PUSH
105640: LD_INT 3
105642: MINUS
105643: PUSH
105644: LD_VAR 0 2
105648: PUSH
105649: LD_INT 1
105651: PUSH
105652: EMPTY
105653: LIST
105654: LIST
105655: LIST
105656: PUSH
105657: LD_VAR 0 1
105661: PUSH
105662: LD_INT 4
105664: PLUS
105665: PUSH
105666: LD_VAR 0 2
105670: PUSH
105671: LD_INT 4
105673: PUSH
105674: EMPTY
105675: LIST
105676: LIST
105677: LIST
105678: PUSH
105679: LD_VAR 0 1
105683: PUSH
105684: LD_INT 3
105686: PLUS
105687: PUSH
105688: LD_VAR 0 2
105692: PUSH
105693: LD_INT 3
105695: PLUS
105696: PUSH
105697: LD_INT 5
105699: PUSH
105700: EMPTY
105701: LIST
105702: LIST
105703: LIST
105704: PUSH
105705: LD_VAR 0 1
105709: PUSH
105710: LD_VAR 0 2
105714: PUSH
105715: LD_INT 4
105717: PLUS
105718: PUSH
105719: LD_INT 0
105721: PUSH
105722: EMPTY
105723: LIST
105724: LIST
105725: LIST
105726: PUSH
105727: EMPTY
105728: LIST
105729: LIST
105730: LIST
105731: LIST
105732: LIST
105733: ST_TO_ADDR
// end ; 1 :
105734: GO 106434
105736: LD_INT 1
105738: DOUBLE
105739: EQUAL
105740: IFTRUE 105744
105742: GO 105877
105744: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
105745: LD_ADDR_VAR 0 5
105749: PUSH
105750: LD_VAR 0 1
105754: PUSH
105755: LD_VAR 0 2
105759: PUSH
105760: LD_INT 4
105762: MINUS
105763: PUSH
105764: LD_INT 3
105766: PUSH
105767: EMPTY
105768: LIST
105769: LIST
105770: LIST
105771: PUSH
105772: LD_VAR 0 1
105776: PUSH
105777: LD_INT 3
105779: MINUS
105780: PUSH
105781: LD_VAR 0 2
105785: PUSH
105786: LD_INT 3
105788: MINUS
105789: PUSH
105790: LD_INT 2
105792: PUSH
105793: EMPTY
105794: LIST
105795: LIST
105796: LIST
105797: PUSH
105798: LD_VAR 0 1
105802: PUSH
105803: LD_INT 4
105805: MINUS
105806: PUSH
105807: LD_VAR 0 2
105811: PUSH
105812: LD_INT 1
105814: PUSH
105815: EMPTY
105816: LIST
105817: LIST
105818: LIST
105819: PUSH
105820: LD_VAR 0 1
105824: PUSH
105825: LD_VAR 0 2
105829: PUSH
105830: LD_INT 3
105832: PLUS
105833: PUSH
105834: LD_INT 0
105836: PUSH
105837: EMPTY
105838: LIST
105839: LIST
105840: LIST
105841: PUSH
105842: LD_VAR 0 1
105846: PUSH
105847: LD_INT 4
105849: PLUS
105850: PUSH
105851: LD_VAR 0 2
105855: PUSH
105856: LD_INT 4
105858: PLUS
105859: PUSH
105860: LD_INT 5
105862: PUSH
105863: EMPTY
105864: LIST
105865: LIST
105866: LIST
105867: PUSH
105868: EMPTY
105869: LIST
105870: LIST
105871: LIST
105872: LIST
105873: LIST
105874: ST_TO_ADDR
// end ; 2 :
105875: GO 106434
105877: LD_INT 2
105879: DOUBLE
105880: EQUAL
105881: IFTRUE 105885
105883: GO 106014
105885: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
105886: LD_ADDR_VAR 0 5
105890: PUSH
105891: LD_VAR 0 1
105895: PUSH
105896: LD_VAR 0 2
105900: PUSH
105901: LD_INT 3
105903: MINUS
105904: PUSH
105905: LD_INT 3
105907: PUSH
105908: EMPTY
105909: LIST
105910: LIST
105911: LIST
105912: PUSH
105913: LD_VAR 0 1
105917: PUSH
105918: LD_INT 4
105920: PLUS
105921: PUSH
105922: LD_VAR 0 2
105926: PUSH
105927: LD_INT 4
105929: PUSH
105930: EMPTY
105931: LIST
105932: LIST
105933: LIST
105934: PUSH
105935: LD_VAR 0 1
105939: PUSH
105940: LD_VAR 0 2
105944: PUSH
105945: LD_INT 4
105947: PLUS
105948: PUSH
105949: LD_INT 0
105951: PUSH
105952: EMPTY
105953: LIST
105954: LIST
105955: LIST
105956: PUSH
105957: LD_VAR 0 1
105961: PUSH
105962: LD_INT 3
105964: MINUS
105965: PUSH
105966: LD_VAR 0 2
105970: PUSH
105971: LD_INT 1
105973: PUSH
105974: EMPTY
105975: LIST
105976: LIST
105977: LIST
105978: PUSH
105979: LD_VAR 0 1
105983: PUSH
105984: LD_INT 4
105986: MINUS
105987: PUSH
105988: LD_VAR 0 2
105992: PUSH
105993: LD_INT 4
105995: MINUS
105996: PUSH
105997: LD_INT 2
105999: PUSH
106000: EMPTY
106001: LIST
106002: LIST
106003: LIST
106004: PUSH
106005: EMPTY
106006: LIST
106007: LIST
106008: LIST
106009: LIST
106010: LIST
106011: ST_TO_ADDR
// end ; 3 :
106012: GO 106434
106014: LD_INT 3
106016: DOUBLE
106017: EQUAL
106018: IFTRUE 106022
106020: GO 106155
106022: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
106023: LD_ADDR_VAR 0 5
106027: PUSH
106028: LD_VAR 0 1
106032: PUSH
106033: LD_INT 3
106035: PLUS
106036: PUSH
106037: LD_VAR 0 2
106041: PUSH
106042: LD_INT 4
106044: PUSH
106045: EMPTY
106046: LIST
106047: LIST
106048: LIST
106049: PUSH
106050: LD_VAR 0 1
106054: PUSH
106055: LD_INT 4
106057: PLUS
106058: PUSH
106059: LD_VAR 0 2
106063: PUSH
106064: LD_INT 4
106066: PLUS
106067: PUSH
106068: LD_INT 5
106070: PUSH
106071: EMPTY
106072: LIST
106073: LIST
106074: LIST
106075: PUSH
106076: LD_VAR 0 1
106080: PUSH
106081: LD_INT 4
106083: MINUS
106084: PUSH
106085: LD_VAR 0 2
106089: PUSH
106090: LD_INT 1
106092: PUSH
106093: EMPTY
106094: LIST
106095: LIST
106096: LIST
106097: PUSH
106098: LD_VAR 0 1
106102: PUSH
106103: LD_VAR 0 2
106107: PUSH
106108: LD_INT 4
106110: MINUS
106111: PUSH
106112: LD_INT 3
106114: PUSH
106115: EMPTY
106116: LIST
106117: LIST
106118: LIST
106119: PUSH
106120: LD_VAR 0 1
106124: PUSH
106125: LD_INT 3
106127: MINUS
106128: PUSH
106129: LD_VAR 0 2
106133: PUSH
106134: LD_INT 3
106136: MINUS
106137: PUSH
106138: LD_INT 2
106140: PUSH
106141: EMPTY
106142: LIST
106143: LIST
106144: LIST
106145: PUSH
106146: EMPTY
106147: LIST
106148: LIST
106149: LIST
106150: LIST
106151: LIST
106152: ST_TO_ADDR
// end ; 4 :
106153: GO 106434
106155: LD_INT 4
106157: DOUBLE
106158: EQUAL
106159: IFTRUE 106163
106161: GO 106296
106163: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
106164: LD_ADDR_VAR 0 5
106168: PUSH
106169: LD_VAR 0 1
106173: PUSH
106174: LD_VAR 0 2
106178: PUSH
106179: LD_INT 4
106181: PLUS
106182: PUSH
106183: LD_INT 0
106185: PUSH
106186: EMPTY
106187: LIST
106188: LIST
106189: LIST
106190: PUSH
106191: LD_VAR 0 1
106195: PUSH
106196: LD_INT 3
106198: PLUS
106199: PUSH
106200: LD_VAR 0 2
106204: PUSH
106205: LD_INT 3
106207: PLUS
106208: PUSH
106209: LD_INT 5
106211: PUSH
106212: EMPTY
106213: LIST
106214: LIST
106215: LIST
106216: PUSH
106217: LD_VAR 0 1
106221: PUSH
106222: LD_INT 4
106224: PLUS
106225: PUSH
106226: LD_VAR 0 2
106230: PUSH
106231: LD_INT 4
106233: PUSH
106234: EMPTY
106235: LIST
106236: LIST
106237: LIST
106238: PUSH
106239: LD_VAR 0 1
106243: PUSH
106244: LD_VAR 0 2
106248: PUSH
106249: LD_INT 3
106251: MINUS
106252: PUSH
106253: LD_INT 3
106255: PUSH
106256: EMPTY
106257: LIST
106258: LIST
106259: LIST
106260: PUSH
106261: LD_VAR 0 1
106265: PUSH
106266: LD_INT 4
106268: MINUS
106269: PUSH
106270: LD_VAR 0 2
106274: PUSH
106275: LD_INT 4
106277: MINUS
106278: PUSH
106279: LD_INT 2
106281: PUSH
106282: EMPTY
106283: LIST
106284: LIST
106285: LIST
106286: PUSH
106287: EMPTY
106288: LIST
106289: LIST
106290: LIST
106291: LIST
106292: LIST
106293: ST_TO_ADDR
// end ; 5 :
106294: GO 106434
106296: LD_INT 5
106298: DOUBLE
106299: EQUAL
106300: IFTRUE 106304
106302: GO 106433
106304: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
106305: LD_ADDR_VAR 0 5
106309: PUSH
106310: LD_VAR 0 1
106314: PUSH
106315: LD_INT 4
106317: MINUS
106318: PUSH
106319: LD_VAR 0 2
106323: PUSH
106324: LD_INT 1
106326: PUSH
106327: EMPTY
106328: LIST
106329: LIST
106330: LIST
106331: PUSH
106332: LD_VAR 0 1
106336: PUSH
106337: LD_VAR 0 2
106341: PUSH
106342: LD_INT 4
106344: MINUS
106345: PUSH
106346: LD_INT 3
106348: PUSH
106349: EMPTY
106350: LIST
106351: LIST
106352: LIST
106353: PUSH
106354: LD_VAR 0 1
106358: PUSH
106359: LD_INT 4
106361: PLUS
106362: PUSH
106363: LD_VAR 0 2
106367: PUSH
106368: LD_INT 4
106370: PLUS
106371: PUSH
106372: LD_INT 5
106374: PUSH
106375: EMPTY
106376: LIST
106377: LIST
106378: LIST
106379: PUSH
106380: LD_VAR 0 1
106384: PUSH
106385: LD_INT 3
106387: PLUS
106388: PUSH
106389: LD_VAR 0 2
106393: PUSH
106394: LD_INT 4
106396: PUSH
106397: EMPTY
106398: LIST
106399: LIST
106400: LIST
106401: PUSH
106402: LD_VAR 0 1
106406: PUSH
106407: LD_VAR 0 2
106411: PUSH
106412: LD_INT 3
106414: PLUS
106415: PUSH
106416: LD_INT 0
106418: PUSH
106419: EMPTY
106420: LIST
106421: LIST
106422: LIST
106423: PUSH
106424: EMPTY
106425: LIST
106426: LIST
106427: LIST
106428: LIST
106429: LIST
106430: ST_TO_ADDR
// end ; end ;
106431: GO 106434
106433: POP
// result := list ;
106434: LD_ADDR_VAR 0 4
106438: PUSH
106439: LD_VAR 0 5
106443: ST_TO_ADDR
// end ;
106444: LD_VAR 0 4
106448: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
106449: LD_INT 0
106451: PPUSH
106452: PPUSH
106453: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
106454: LD_VAR 0 1
106458: NOT
106459: PUSH
106460: LD_VAR 0 2
106464: PUSH
106465: LD_INT 1
106467: PUSH
106468: LD_INT 2
106470: PUSH
106471: LD_INT 3
106473: PUSH
106474: LD_INT 4
106476: PUSH
106477: EMPTY
106478: LIST
106479: LIST
106480: LIST
106481: LIST
106482: IN
106483: NOT
106484: OR
106485: IFFALSE 106489
// exit ;
106487: GO 106581
// tmp := [ ] ;
106489: LD_ADDR_VAR 0 5
106493: PUSH
106494: EMPTY
106495: ST_TO_ADDR
// for i in units do
106496: LD_ADDR_VAR 0 4
106500: PUSH
106501: LD_VAR 0 1
106505: PUSH
106506: FOR_IN
106507: IFFALSE 106550
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
106509: LD_ADDR_VAR 0 5
106513: PUSH
106514: LD_VAR 0 5
106518: PPUSH
106519: LD_VAR 0 5
106523: PUSH
106524: LD_INT 1
106526: PLUS
106527: PPUSH
106528: LD_VAR 0 4
106532: PPUSH
106533: LD_VAR 0 2
106537: PPUSH
106538: CALL_OW 259
106542: PPUSH
106543: CALL_OW 2
106547: ST_TO_ADDR
106548: GO 106506
106550: POP
106551: POP
// if not tmp then
106552: LD_VAR 0 5
106556: NOT
106557: IFFALSE 106561
// exit ;
106559: GO 106581
// result := SortListByListDesc ( units , tmp ) ;
106561: LD_ADDR_VAR 0 3
106565: PUSH
106566: LD_VAR 0 1
106570: PPUSH
106571: LD_VAR 0 5
106575: PPUSH
106576: CALL_OW 77
106580: ST_TO_ADDR
// end ;
106581: LD_VAR 0 3
106585: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
106586: LD_INT 0
106588: PPUSH
106589: PPUSH
106590: PPUSH
// x := GetX ( building ) ;
106591: LD_ADDR_VAR 0 4
106595: PUSH
106596: LD_VAR 0 2
106600: PPUSH
106601: CALL_OW 250
106605: ST_TO_ADDR
// y := GetY ( building ) ;
106606: LD_ADDR_VAR 0 5
106610: PUSH
106611: LD_VAR 0 2
106615: PPUSH
106616: CALL_OW 251
106620: ST_TO_ADDR
// if GetTaskList ( unit ) then
106621: LD_VAR 0 1
106625: PPUSH
106626: CALL_OW 437
106630: IFFALSE 106725
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
106632: LD_STRING e
106634: PUSH
106635: LD_VAR 0 1
106639: PPUSH
106640: CALL_OW 437
106644: PUSH
106645: LD_INT 1
106647: ARRAY
106648: PUSH
106649: LD_INT 1
106651: ARRAY
106652: EQUAL
106653: PUSH
106654: LD_VAR 0 4
106658: PUSH
106659: LD_VAR 0 1
106663: PPUSH
106664: CALL_OW 437
106668: PUSH
106669: LD_INT 1
106671: ARRAY
106672: PUSH
106673: LD_INT 2
106675: ARRAY
106676: EQUAL
106677: AND
106678: PUSH
106679: LD_VAR 0 5
106683: PUSH
106684: LD_VAR 0 1
106688: PPUSH
106689: CALL_OW 437
106693: PUSH
106694: LD_INT 1
106696: ARRAY
106697: PUSH
106698: LD_INT 3
106700: ARRAY
106701: EQUAL
106702: AND
106703: IFFALSE 106715
// result := true else
106705: LD_ADDR_VAR 0 3
106709: PUSH
106710: LD_INT 1
106712: ST_TO_ADDR
106713: GO 106723
// result := false ;
106715: LD_ADDR_VAR 0 3
106719: PUSH
106720: LD_INT 0
106722: ST_TO_ADDR
// end else
106723: GO 106733
// result := false ;
106725: LD_ADDR_VAR 0 3
106729: PUSH
106730: LD_INT 0
106732: ST_TO_ADDR
// end ;
106733: LD_VAR 0 3
106737: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
106738: LD_INT 0
106740: PPUSH
106741: PPUSH
106742: PPUSH
106743: PPUSH
// if not unit or not area then
106744: LD_VAR 0 1
106748: NOT
106749: PUSH
106750: LD_VAR 0 2
106754: NOT
106755: OR
106756: IFFALSE 106760
// exit ;
106758: GO 106924
// tmp := AreaToList ( area , i ) ;
106760: LD_ADDR_VAR 0 6
106764: PUSH
106765: LD_VAR 0 2
106769: PPUSH
106770: LD_VAR 0 5
106774: PPUSH
106775: CALL_OW 517
106779: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
106780: LD_ADDR_VAR 0 5
106784: PUSH
106785: DOUBLE
106786: LD_INT 1
106788: DEC
106789: ST_TO_ADDR
106790: LD_VAR 0 6
106794: PUSH
106795: LD_INT 1
106797: ARRAY
106798: PUSH
106799: FOR_TO
106800: IFFALSE 106922
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
106802: LD_ADDR_VAR 0 7
106806: PUSH
106807: LD_VAR 0 6
106811: PUSH
106812: LD_INT 1
106814: ARRAY
106815: PUSH
106816: LD_VAR 0 5
106820: ARRAY
106821: PUSH
106822: LD_VAR 0 6
106826: PUSH
106827: LD_INT 2
106829: ARRAY
106830: PUSH
106831: LD_VAR 0 5
106835: ARRAY
106836: PUSH
106837: EMPTY
106838: LIST
106839: LIST
106840: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
106841: LD_VAR 0 7
106845: PUSH
106846: LD_INT 1
106848: ARRAY
106849: PPUSH
106850: LD_VAR 0 7
106854: PUSH
106855: LD_INT 2
106857: ARRAY
106858: PPUSH
106859: CALL_OW 428
106863: PUSH
106864: LD_INT 0
106866: EQUAL
106867: IFFALSE 106920
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
106869: LD_VAR 0 1
106873: PPUSH
106874: LD_VAR 0 7
106878: PUSH
106879: LD_INT 1
106881: ARRAY
106882: PPUSH
106883: LD_VAR 0 7
106887: PUSH
106888: LD_INT 2
106890: ARRAY
106891: PPUSH
106892: LD_VAR 0 3
106896: PPUSH
106897: CALL_OW 48
// result := IsPlaced ( unit ) ;
106901: LD_ADDR_VAR 0 4
106905: PUSH
106906: LD_VAR 0 1
106910: PPUSH
106911: CALL_OW 305
106915: ST_TO_ADDR
// exit ;
106916: POP
106917: POP
106918: GO 106924
// end ; end ;
106920: GO 106799
106922: POP
106923: POP
// end ;
106924: LD_VAR 0 4
106928: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
106929: LD_INT 0
106931: PPUSH
106932: PPUSH
106933: PPUSH
// if not side or side > 8 then
106934: LD_VAR 0 1
106938: NOT
106939: PUSH
106940: LD_VAR 0 1
106944: PUSH
106945: LD_INT 8
106947: GREATER
106948: OR
106949: IFFALSE 106953
// exit ;
106951: GO 107140
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
106953: LD_ADDR_VAR 0 4
106957: PUSH
106958: LD_INT 22
106960: PUSH
106961: LD_VAR 0 1
106965: PUSH
106966: EMPTY
106967: LIST
106968: LIST
106969: PUSH
106970: LD_INT 21
106972: PUSH
106973: LD_INT 3
106975: PUSH
106976: EMPTY
106977: LIST
106978: LIST
106979: PUSH
106980: EMPTY
106981: LIST
106982: LIST
106983: PPUSH
106984: CALL_OW 69
106988: ST_TO_ADDR
// if not tmp then
106989: LD_VAR 0 4
106993: NOT
106994: IFFALSE 106998
// exit ;
106996: GO 107140
// enable_addtolog := true ;
106998: LD_ADDR_OWVAR 81
107002: PUSH
107003: LD_INT 1
107005: ST_TO_ADDR
// AddToLog ( [ ) ;
107006: LD_STRING [
107008: PPUSH
107009: CALL_OW 561
// for i in tmp do
107013: LD_ADDR_VAR 0 3
107017: PUSH
107018: LD_VAR 0 4
107022: PUSH
107023: FOR_IN
107024: IFFALSE 107131
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
107026: LD_STRING [
107028: PUSH
107029: LD_VAR 0 3
107033: PPUSH
107034: CALL_OW 266
107038: STR
107039: PUSH
107040: LD_STRING , 
107042: STR
107043: PUSH
107044: LD_VAR 0 3
107048: PPUSH
107049: CALL_OW 250
107053: STR
107054: PUSH
107055: LD_STRING , 
107057: STR
107058: PUSH
107059: LD_VAR 0 3
107063: PPUSH
107064: CALL_OW 251
107068: STR
107069: PUSH
107070: LD_STRING , 
107072: STR
107073: PUSH
107074: LD_VAR 0 3
107078: PPUSH
107079: CALL_OW 254
107083: STR
107084: PUSH
107085: LD_STRING , 
107087: STR
107088: PUSH
107089: LD_VAR 0 3
107093: PPUSH
107094: LD_INT 1
107096: PPUSH
107097: CALL_OW 268
107101: STR
107102: PUSH
107103: LD_STRING , 
107105: STR
107106: PUSH
107107: LD_VAR 0 3
107111: PPUSH
107112: LD_INT 2
107114: PPUSH
107115: CALL_OW 268
107119: STR
107120: PUSH
107121: LD_STRING ],
107123: STR
107124: PPUSH
107125: CALL_OW 561
// end ;
107129: GO 107023
107131: POP
107132: POP
// AddToLog ( ]; ) ;
107133: LD_STRING ];
107135: PPUSH
107136: CALL_OW 561
// end ;
107140: LD_VAR 0 2
107144: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
107145: LD_INT 0
107147: PPUSH
107148: PPUSH
107149: PPUSH
107150: PPUSH
107151: PPUSH
// if not area or not rate or not max then
107152: LD_VAR 0 1
107156: NOT
107157: PUSH
107158: LD_VAR 0 2
107162: NOT
107163: OR
107164: PUSH
107165: LD_VAR 0 4
107169: NOT
107170: OR
107171: IFFALSE 107175
// exit ;
107173: GO 107367
// while 1 do
107175: LD_INT 1
107177: IFFALSE 107367
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
107179: LD_ADDR_VAR 0 9
107183: PUSH
107184: LD_VAR 0 1
107188: PPUSH
107189: LD_INT 1
107191: PPUSH
107192: CALL_OW 287
107196: PUSH
107197: LD_INT 10
107199: MUL
107200: ST_TO_ADDR
// r := rate / 10 ;
107201: LD_ADDR_VAR 0 7
107205: PUSH
107206: LD_VAR 0 2
107210: PUSH
107211: LD_INT 10
107213: DIVREAL
107214: ST_TO_ADDR
// time := 1 1$00 ;
107215: LD_ADDR_VAR 0 8
107219: PUSH
107220: LD_INT 2100
107222: ST_TO_ADDR
// if amount < min then
107223: LD_VAR 0 9
107227: PUSH
107228: LD_VAR 0 3
107232: LESS
107233: IFFALSE 107251
// r := r * 2 else
107235: LD_ADDR_VAR 0 7
107239: PUSH
107240: LD_VAR 0 7
107244: PUSH
107245: LD_INT 2
107247: MUL
107248: ST_TO_ADDR
107249: GO 107277
// if amount > max then
107251: LD_VAR 0 9
107255: PUSH
107256: LD_VAR 0 4
107260: GREATER
107261: IFFALSE 107277
// r := r / 2 ;
107263: LD_ADDR_VAR 0 7
107267: PUSH
107268: LD_VAR 0 7
107272: PUSH
107273: LD_INT 2
107275: DIVREAL
107276: ST_TO_ADDR
// time := time / r ;
107277: LD_ADDR_VAR 0 8
107281: PUSH
107282: LD_VAR 0 8
107286: PUSH
107287: LD_VAR 0 7
107291: DIVREAL
107292: ST_TO_ADDR
// if time < 0 then
107293: LD_VAR 0 8
107297: PUSH
107298: LD_INT 0
107300: LESS
107301: IFFALSE 107318
// time := time * - 1 ;
107303: LD_ADDR_VAR 0 8
107307: PUSH
107308: LD_VAR 0 8
107312: PUSH
107313: LD_INT 1
107315: NEG
107316: MUL
107317: ST_TO_ADDR
// wait ( time ) ;
107318: LD_VAR 0 8
107322: PPUSH
107323: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
107327: LD_INT 35
107329: PPUSH
107330: LD_INT 875
107332: PPUSH
107333: CALL_OW 12
107337: PPUSH
107338: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
107342: LD_INT 1
107344: PPUSH
107345: LD_INT 5
107347: PPUSH
107348: CALL_OW 12
107352: PPUSH
107353: LD_VAR 0 1
107357: PPUSH
107358: LD_INT 1
107360: PPUSH
107361: CALL_OW 55
// end ;
107365: GO 107175
// end ;
107367: LD_VAR 0 5
107371: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
107372: LD_INT 0
107374: PPUSH
107375: PPUSH
107376: PPUSH
107377: PPUSH
107378: PPUSH
107379: PPUSH
107380: PPUSH
107381: PPUSH
// if not turrets or not factories then
107382: LD_VAR 0 1
107386: NOT
107387: PUSH
107388: LD_VAR 0 2
107392: NOT
107393: OR
107394: IFFALSE 107398
// exit ;
107396: GO 107705
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
107398: LD_ADDR_VAR 0 10
107402: PUSH
107403: LD_INT 5
107405: PUSH
107406: LD_INT 6
107408: PUSH
107409: EMPTY
107410: LIST
107411: LIST
107412: PUSH
107413: LD_INT 2
107415: PUSH
107416: LD_INT 4
107418: PUSH
107419: EMPTY
107420: LIST
107421: LIST
107422: PUSH
107423: LD_INT 3
107425: PUSH
107426: LD_INT 5
107428: PUSH
107429: EMPTY
107430: LIST
107431: LIST
107432: PUSH
107433: EMPTY
107434: LIST
107435: LIST
107436: LIST
107437: PUSH
107438: LD_INT 24
107440: PUSH
107441: LD_INT 25
107443: PUSH
107444: EMPTY
107445: LIST
107446: LIST
107447: PUSH
107448: LD_INT 23
107450: PUSH
107451: LD_INT 27
107453: PUSH
107454: EMPTY
107455: LIST
107456: LIST
107457: PUSH
107458: EMPTY
107459: LIST
107460: LIST
107461: PUSH
107462: LD_INT 42
107464: PUSH
107465: LD_INT 43
107467: PUSH
107468: EMPTY
107469: LIST
107470: LIST
107471: PUSH
107472: LD_INT 44
107474: PUSH
107475: LD_INT 46
107477: PUSH
107478: EMPTY
107479: LIST
107480: LIST
107481: PUSH
107482: LD_INT 45
107484: PUSH
107485: LD_INT 47
107487: PUSH
107488: EMPTY
107489: LIST
107490: LIST
107491: PUSH
107492: EMPTY
107493: LIST
107494: LIST
107495: LIST
107496: PUSH
107497: EMPTY
107498: LIST
107499: LIST
107500: LIST
107501: ST_TO_ADDR
// result := [ ] ;
107502: LD_ADDR_VAR 0 3
107506: PUSH
107507: EMPTY
107508: ST_TO_ADDR
// for i in turrets do
107509: LD_ADDR_VAR 0 4
107513: PUSH
107514: LD_VAR 0 1
107518: PUSH
107519: FOR_IN
107520: IFFALSE 107703
// begin nat := GetNation ( i ) ;
107522: LD_ADDR_VAR 0 7
107526: PUSH
107527: LD_VAR 0 4
107531: PPUSH
107532: CALL_OW 248
107536: ST_TO_ADDR
// weapon := 0 ;
107537: LD_ADDR_VAR 0 8
107541: PUSH
107542: LD_INT 0
107544: ST_TO_ADDR
// if not nat then
107545: LD_VAR 0 7
107549: NOT
107550: IFFALSE 107554
// continue ;
107552: GO 107519
// for j in list [ nat ] do
107554: LD_ADDR_VAR 0 5
107558: PUSH
107559: LD_VAR 0 10
107563: PUSH
107564: LD_VAR 0 7
107568: ARRAY
107569: PUSH
107570: FOR_IN
107571: IFFALSE 107612
// if GetBWeapon ( i ) = j [ 1 ] then
107573: LD_VAR 0 4
107577: PPUSH
107578: CALL_OW 269
107582: PUSH
107583: LD_VAR 0 5
107587: PUSH
107588: LD_INT 1
107590: ARRAY
107591: EQUAL
107592: IFFALSE 107610
// begin weapon := j [ 2 ] ;
107594: LD_ADDR_VAR 0 8
107598: PUSH
107599: LD_VAR 0 5
107603: PUSH
107604: LD_INT 2
107606: ARRAY
107607: ST_TO_ADDR
// break ;
107608: GO 107612
// end ;
107610: GO 107570
107612: POP
107613: POP
// if not weapon then
107614: LD_VAR 0 8
107618: NOT
107619: IFFALSE 107623
// continue ;
107621: GO 107519
// for k in factories do
107623: LD_ADDR_VAR 0 6
107627: PUSH
107628: LD_VAR 0 2
107632: PUSH
107633: FOR_IN
107634: IFFALSE 107699
// begin weapons := AvailableWeaponList ( k ) ;
107636: LD_ADDR_VAR 0 9
107640: PUSH
107641: LD_VAR 0 6
107645: PPUSH
107646: CALL_OW 478
107650: ST_TO_ADDR
// if not weapons then
107651: LD_VAR 0 9
107655: NOT
107656: IFFALSE 107660
// continue ;
107658: GO 107633
// if weapon in weapons then
107660: LD_VAR 0 8
107664: PUSH
107665: LD_VAR 0 9
107669: IN
107670: IFFALSE 107697
// begin result := [ i , weapon ] ;
107672: LD_ADDR_VAR 0 3
107676: PUSH
107677: LD_VAR 0 4
107681: PUSH
107682: LD_VAR 0 8
107686: PUSH
107687: EMPTY
107688: LIST
107689: LIST
107690: ST_TO_ADDR
// exit ;
107691: POP
107692: POP
107693: POP
107694: POP
107695: GO 107705
// end ; end ;
107697: GO 107633
107699: POP
107700: POP
// end ;
107701: GO 107519
107703: POP
107704: POP
// end ;
107705: LD_VAR 0 3
107709: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
107710: LD_INT 0
107712: PPUSH
// if not side or side > 8 then
107713: LD_VAR 0 3
107717: NOT
107718: PUSH
107719: LD_VAR 0 3
107723: PUSH
107724: LD_INT 8
107726: GREATER
107727: OR
107728: IFFALSE 107732
// exit ;
107730: GO 107791
// if not range then
107732: LD_VAR 0 4
107736: NOT
107737: IFFALSE 107748
// range := - 12 ;
107739: LD_ADDR_VAR 0 4
107743: PUSH
107744: LD_INT 12
107746: NEG
107747: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
107748: LD_VAR 0 1
107752: PPUSH
107753: LD_VAR 0 2
107757: PPUSH
107758: LD_VAR 0 3
107762: PPUSH
107763: LD_VAR 0 4
107767: PPUSH
107768: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
107772: LD_VAR 0 1
107776: PPUSH
107777: LD_VAR 0 2
107781: PPUSH
107782: LD_VAR 0 3
107786: PPUSH
107787: CALL_OW 331
// end ;
107791: LD_VAR 0 5
107795: RET
// export function Video ( mode ) ; begin
107796: LD_INT 0
107798: PPUSH
// ingame_video = mode ;
107799: LD_ADDR_OWVAR 52
107803: PUSH
107804: LD_VAR 0 1
107808: ST_TO_ADDR
// interface_hidden = mode ;
107809: LD_ADDR_OWVAR 54
107813: PUSH
107814: LD_VAR 0 1
107818: ST_TO_ADDR
// end ;
107819: LD_VAR 0 2
107823: RET
// export function Join ( array , element ) ; begin
107824: LD_INT 0
107826: PPUSH
// result := array ^ element ;
107827: LD_ADDR_VAR 0 3
107831: PUSH
107832: LD_VAR 0 1
107836: PUSH
107837: LD_VAR 0 2
107841: ADD
107842: ST_TO_ADDR
// end ;
107843: LD_VAR 0 3
107847: RET
// export function JoinUnion ( array , element ) ; begin
107848: LD_INT 0
107850: PPUSH
// result := array union element ;
107851: LD_ADDR_VAR 0 3
107855: PUSH
107856: LD_VAR 0 1
107860: PUSH
107861: LD_VAR 0 2
107865: UNION
107866: ST_TO_ADDR
// end ;
107867: LD_VAR 0 3
107871: RET
// export function GetBehemoths ( side ) ; begin
107872: LD_INT 0
107874: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
107875: LD_ADDR_VAR 0 2
107879: PUSH
107880: LD_INT 22
107882: PUSH
107883: LD_VAR 0 1
107887: PUSH
107888: EMPTY
107889: LIST
107890: LIST
107891: PUSH
107892: LD_INT 31
107894: PUSH
107895: LD_INT 25
107897: PUSH
107898: EMPTY
107899: LIST
107900: LIST
107901: PUSH
107902: EMPTY
107903: LIST
107904: LIST
107905: PPUSH
107906: CALL_OW 69
107910: ST_TO_ADDR
// end ;
107911: LD_VAR 0 2
107915: RET
// export function Shuffle ( array ) ; var i , index ; begin
107916: LD_INT 0
107918: PPUSH
107919: PPUSH
107920: PPUSH
// result := [ ] ;
107921: LD_ADDR_VAR 0 2
107925: PUSH
107926: EMPTY
107927: ST_TO_ADDR
// if not array then
107928: LD_VAR 0 1
107932: NOT
107933: IFFALSE 107937
// exit ;
107935: GO 108036
// Randomize ;
107937: CALL_OW 10
// for i = array downto 1 do
107941: LD_ADDR_VAR 0 3
107945: PUSH
107946: DOUBLE
107947: LD_VAR 0 1
107951: INC
107952: ST_TO_ADDR
107953: LD_INT 1
107955: PUSH
107956: FOR_DOWNTO
107957: IFFALSE 108034
// begin index := rand ( 1 , array ) ;
107959: LD_ADDR_VAR 0 4
107963: PUSH
107964: LD_INT 1
107966: PPUSH
107967: LD_VAR 0 1
107971: PPUSH
107972: CALL_OW 12
107976: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
107977: LD_ADDR_VAR 0 2
107981: PUSH
107982: LD_VAR 0 2
107986: PPUSH
107987: LD_VAR 0 2
107991: PUSH
107992: LD_INT 1
107994: PLUS
107995: PPUSH
107996: LD_VAR 0 1
108000: PUSH
108001: LD_VAR 0 4
108005: ARRAY
108006: PPUSH
108007: CALL_OW 2
108011: ST_TO_ADDR
// array := Delete ( array , index ) ;
108012: LD_ADDR_VAR 0 1
108016: PUSH
108017: LD_VAR 0 1
108021: PPUSH
108022: LD_VAR 0 4
108026: PPUSH
108027: CALL_OW 3
108031: ST_TO_ADDR
// end ;
108032: GO 107956
108034: POP
108035: POP
// end ;
108036: LD_VAR 0 2
108040: RET
// export function GetBaseMaterials ( base ) ; begin
108041: LD_INT 0
108043: PPUSH
// result := [ 0 , 0 , 0 ] ;
108044: LD_ADDR_VAR 0 2
108048: PUSH
108049: LD_INT 0
108051: PUSH
108052: LD_INT 0
108054: PUSH
108055: LD_INT 0
108057: PUSH
108058: EMPTY
108059: LIST
108060: LIST
108061: LIST
108062: ST_TO_ADDR
// if not base then
108063: LD_VAR 0 1
108067: NOT
108068: IFFALSE 108072
// exit ;
108070: GO 108121
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
108072: LD_ADDR_VAR 0 2
108076: PUSH
108077: LD_VAR 0 1
108081: PPUSH
108082: LD_INT 1
108084: PPUSH
108085: CALL_OW 275
108089: PUSH
108090: LD_VAR 0 1
108094: PPUSH
108095: LD_INT 2
108097: PPUSH
108098: CALL_OW 275
108102: PUSH
108103: LD_VAR 0 1
108107: PPUSH
108108: LD_INT 3
108110: PPUSH
108111: CALL_OW 275
108115: PUSH
108116: EMPTY
108117: LIST
108118: LIST
108119: LIST
108120: ST_TO_ADDR
// end ; end_of_file end_of_file
108121: LD_VAR 0 2
108125: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
108126: GO 108128
108128: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
108129: LD_STRING initStreamRollete();
108131: PPUSH
108132: CALL_OW 559
// InitStreamMode ;
108136: CALL 108145 0 0
// DefineStreamItems ( ) ;
108140: CALL 108585 0 0
// end ;
108144: END
// function InitStreamMode ; begin
108145: LD_INT 0
108147: PPUSH
// streamModeActive := false ;
108148: LD_ADDR_EXP 145
108152: PUSH
108153: LD_INT 0
108155: ST_TO_ADDR
// normalCounter := 36 ;
108156: LD_ADDR_EXP 146
108160: PUSH
108161: LD_INT 36
108163: ST_TO_ADDR
// hardcoreCounter := 16 ;
108164: LD_ADDR_EXP 147
108168: PUSH
108169: LD_INT 16
108171: ST_TO_ADDR
// sRocket := false ;
108172: LD_ADDR_EXP 150
108176: PUSH
108177: LD_INT 0
108179: ST_TO_ADDR
// sSpeed := false ;
108180: LD_ADDR_EXP 149
108184: PUSH
108185: LD_INT 0
108187: ST_TO_ADDR
// sEngine := false ;
108188: LD_ADDR_EXP 151
108192: PUSH
108193: LD_INT 0
108195: ST_TO_ADDR
// sSpec := false ;
108196: LD_ADDR_EXP 148
108200: PUSH
108201: LD_INT 0
108203: ST_TO_ADDR
// sLevel := false ;
108204: LD_ADDR_EXP 152
108208: PUSH
108209: LD_INT 0
108211: ST_TO_ADDR
// sArmoury := false ;
108212: LD_ADDR_EXP 153
108216: PUSH
108217: LD_INT 0
108219: ST_TO_ADDR
// sRadar := false ;
108220: LD_ADDR_EXP 154
108224: PUSH
108225: LD_INT 0
108227: ST_TO_ADDR
// sBunker := false ;
108228: LD_ADDR_EXP 155
108232: PUSH
108233: LD_INT 0
108235: ST_TO_ADDR
// sHack := false ;
108236: LD_ADDR_EXP 156
108240: PUSH
108241: LD_INT 0
108243: ST_TO_ADDR
// sFire := false ;
108244: LD_ADDR_EXP 157
108248: PUSH
108249: LD_INT 0
108251: ST_TO_ADDR
// sRefresh := false ;
108252: LD_ADDR_EXP 158
108256: PUSH
108257: LD_INT 0
108259: ST_TO_ADDR
// sExp := false ;
108260: LD_ADDR_EXP 159
108264: PUSH
108265: LD_INT 0
108267: ST_TO_ADDR
// sDepot := false ;
108268: LD_ADDR_EXP 160
108272: PUSH
108273: LD_INT 0
108275: ST_TO_ADDR
// sFlag := false ;
108276: LD_ADDR_EXP 161
108280: PUSH
108281: LD_INT 0
108283: ST_TO_ADDR
// sKamikadze := false ;
108284: LD_ADDR_EXP 169
108288: PUSH
108289: LD_INT 0
108291: ST_TO_ADDR
// sTroll := false ;
108292: LD_ADDR_EXP 170
108296: PUSH
108297: LD_INT 0
108299: ST_TO_ADDR
// sSlow := false ;
108300: LD_ADDR_EXP 171
108304: PUSH
108305: LD_INT 0
108307: ST_TO_ADDR
// sLack := false ;
108308: LD_ADDR_EXP 172
108312: PUSH
108313: LD_INT 0
108315: ST_TO_ADDR
// sTank := false ;
108316: LD_ADDR_EXP 174
108320: PUSH
108321: LD_INT 0
108323: ST_TO_ADDR
// sRemote := false ;
108324: LD_ADDR_EXP 175
108328: PUSH
108329: LD_INT 0
108331: ST_TO_ADDR
// sPowell := false ;
108332: LD_ADDR_EXP 176
108336: PUSH
108337: LD_INT 0
108339: ST_TO_ADDR
// sTeleport := false ;
108340: LD_ADDR_EXP 179
108344: PUSH
108345: LD_INT 0
108347: ST_TO_ADDR
// sOilTower := false ;
108348: LD_ADDR_EXP 181
108352: PUSH
108353: LD_INT 0
108355: ST_TO_ADDR
// sShovel := false ;
108356: LD_ADDR_EXP 182
108360: PUSH
108361: LD_INT 0
108363: ST_TO_ADDR
// sSheik := false ;
108364: LD_ADDR_EXP 183
108368: PUSH
108369: LD_INT 0
108371: ST_TO_ADDR
// sEarthquake := false ;
108372: LD_ADDR_EXP 185
108376: PUSH
108377: LD_INT 0
108379: ST_TO_ADDR
// sAI := false ;
108380: LD_ADDR_EXP 186
108384: PUSH
108385: LD_INT 0
108387: ST_TO_ADDR
// sCargo := false ;
108388: LD_ADDR_EXP 189
108392: PUSH
108393: LD_INT 0
108395: ST_TO_ADDR
// sDLaser := false ;
108396: LD_ADDR_EXP 190
108400: PUSH
108401: LD_INT 0
108403: ST_TO_ADDR
// sExchange := false ;
108404: LD_ADDR_EXP 191
108408: PUSH
108409: LD_INT 0
108411: ST_TO_ADDR
// sFac := false ;
108412: LD_ADDR_EXP 192
108416: PUSH
108417: LD_INT 0
108419: ST_TO_ADDR
// sPower := false ;
108420: LD_ADDR_EXP 193
108424: PUSH
108425: LD_INT 0
108427: ST_TO_ADDR
// sRandom := false ;
108428: LD_ADDR_EXP 194
108432: PUSH
108433: LD_INT 0
108435: ST_TO_ADDR
// sShield := false ;
108436: LD_ADDR_EXP 195
108440: PUSH
108441: LD_INT 0
108443: ST_TO_ADDR
// sTime := false ;
108444: LD_ADDR_EXP 196
108448: PUSH
108449: LD_INT 0
108451: ST_TO_ADDR
// sTools := false ;
108452: LD_ADDR_EXP 197
108456: PUSH
108457: LD_INT 0
108459: ST_TO_ADDR
// sSold := false ;
108460: LD_ADDR_EXP 162
108464: PUSH
108465: LD_INT 0
108467: ST_TO_ADDR
// sDiff := false ;
108468: LD_ADDR_EXP 163
108472: PUSH
108473: LD_INT 0
108475: ST_TO_ADDR
// sFog := false ;
108476: LD_ADDR_EXP 166
108480: PUSH
108481: LD_INT 0
108483: ST_TO_ADDR
// sReset := false ;
108484: LD_ADDR_EXP 167
108488: PUSH
108489: LD_INT 0
108491: ST_TO_ADDR
// sSun := false ;
108492: LD_ADDR_EXP 168
108496: PUSH
108497: LD_INT 0
108499: ST_TO_ADDR
// sTiger := false ;
108500: LD_ADDR_EXP 164
108504: PUSH
108505: LD_INT 0
108507: ST_TO_ADDR
// sBomb := false ;
108508: LD_ADDR_EXP 165
108512: PUSH
108513: LD_INT 0
108515: ST_TO_ADDR
// sWound := false ;
108516: LD_ADDR_EXP 173
108520: PUSH
108521: LD_INT 0
108523: ST_TO_ADDR
// sBetray := false ;
108524: LD_ADDR_EXP 177
108528: PUSH
108529: LD_INT 0
108531: ST_TO_ADDR
// sContamin := false ;
108532: LD_ADDR_EXP 178
108536: PUSH
108537: LD_INT 0
108539: ST_TO_ADDR
// sOil := false ;
108540: LD_ADDR_EXP 180
108544: PUSH
108545: LD_INT 0
108547: ST_TO_ADDR
// sStu := false ;
108548: LD_ADDR_EXP 184
108552: PUSH
108553: LD_INT 0
108555: ST_TO_ADDR
// sBazooka := false ;
108556: LD_ADDR_EXP 187
108560: PUSH
108561: LD_INT 0
108563: ST_TO_ADDR
// sMortar := false ;
108564: LD_ADDR_EXP 188
108568: PUSH
108569: LD_INT 0
108571: ST_TO_ADDR
// sRanger := false ;
108572: LD_ADDR_EXP 198
108576: PUSH
108577: LD_INT 0
108579: ST_TO_ADDR
// end ;
108580: LD_VAR 0 1
108584: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
108585: LD_INT 0
108587: PPUSH
108588: PPUSH
108589: PPUSH
108590: PPUSH
108591: PPUSH
// result := [ ] ;
108592: LD_ADDR_VAR 0 1
108596: PUSH
108597: EMPTY
108598: ST_TO_ADDR
// if campaign_id = 1 then
108599: LD_OWVAR 69
108603: PUSH
108604: LD_INT 1
108606: EQUAL
108607: IFFALSE 111545
// begin case mission_number of 1 :
108609: LD_OWVAR 70
108613: PUSH
108614: LD_INT 1
108616: DOUBLE
108617: EQUAL
108618: IFTRUE 108622
108620: GO 108686
108622: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
108623: LD_ADDR_VAR 0 1
108627: PUSH
108628: LD_INT 2
108630: PUSH
108631: LD_INT 4
108633: PUSH
108634: LD_INT 11
108636: PUSH
108637: LD_INT 12
108639: PUSH
108640: LD_INT 15
108642: PUSH
108643: LD_INT 16
108645: PUSH
108646: LD_INT 22
108648: PUSH
108649: LD_INT 23
108651: PUSH
108652: LD_INT 26
108654: PUSH
108655: EMPTY
108656: LIST
108657: LIST
108658: LIST
108659: LIST
108660: LIST
108661: LIST
108662: LIST
108663: LIST
108664: LIST
108665: PUSH
108666: LD_INT 101
108668: PUSH
108669: LD_INT 102
108671: PUSH
108672: LD_INT 106
108674: PUSH
108675: EMPTY
108676: LIST
108677: LIST
108678: LIST
108679: PUSH
108680: EMPTY
108681: LIST
108682: LIST
108683: ST_TO_ADDR
108684: GO 111543
108686: LD_INT 2
108688: DOUBLE
108689: EQUAL
108690: IFTRUE 108694
108692: GO 108766
108694: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
108695: LD_ADDR_VAR 0 1
108699: PUSH
108700: LD_INT 2
108702: PUSH
108703: LD_INT 4
108705: PUSH
108706: LD_INT 11
108708: PUSH
108709: LD_INT 12
108711: PUSH
108712: LD_INT 15
108714: PUSH
108715: LD_INT 16
108717: PUSH
108718: LD_INT 22
108720: PUSH
108721: LD_INT 23
108723: PUSH
108724: LD_INT 26
108726: PUSH
108727: EMPTY
108728: LIST
108729: LIST
108730: LIST
108731: LIST
108732: LIST
108733: LIST
108734: LIST
108735: LIST
108736: LIST
108737: PUSH
108738: LD_INT 101
108740: PUSH
108741: LD_INT 102
108743: PUSH
108744: LD_INT 105
108746: PUSH
108747: LD_INT 106
108749: PUSH
108750: LD_INT 108
108752: PUSH
108753: EMPTY
108754: LIST
108755: LIST
108756: LIST
108757: LIST
108758: LIST
108759: PUSH
108760: EMPTY
108761: LIST
108762: LIST
108763: ST_TO_ADDR
108764: GO 111543
108766: LD_INT 3
108768: DOUBLE
108769: EQUAL
108770: IFTRUE 108774
108772: GO 108850
108774: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
108775: LD_ADDR_VAR 0 1
108779: PUSH
108780: LD_INT 2
108782: PUSH
108783: LD_INT 4
108785: PUSH
108786: LD_INT 5
108788: PUSH
108789: LD_INT 11
108791: PUSH
108792: LD_INT 12
108794: PUSH
108795: LD_INT 15
108797: PUSH
108798: LD_INT 16
108800: PUSH
108801: LD_INT 22
108803: PUSH
108804: LD_INT 26
108806: PUSH
108807: LD_INT 36
108809: PUSH
108810: EMPTY
108811: LIST
108812: LIST
108813: LIST
108814: LIST
108815: LIST
108816: LIST
108817: LIST
108818: LIST
108819: LIST
108820: LIST
108821: PUSH
108822: LD_INT 101
108824: PUSH
108825: LD_INT 102
108827: PUSH
108828: LD_INT 105
108830: PUSH
108831: LD_INT 106
108833: PUSH
108834: LD_INT 108
108836: PUSH
108837: EMPTY
108838: LIST
108839: LIST
108840: LIST
108841: LIST
108842: LIST
108843: PUSH
108844: EMPTY
108845: LIST
108846: LIST
108847: ST_TO_ADDR
108848: GO 111543
108850: LD_INT 4
108852: DOUBLE
108853: EQUAL
108854: IFTRUE 108858
108856: GO 108942
108858: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
108859: LD_ADDR_VAR 0 1
108863: PUSH
108864: LD_INT 2
108866: PUSH
108867: LD_INT 4
108869: PUSH
108870: LD_INT 5
108872: PUSH
108873: LD_INT 8
108875: PUSH
108876: LD_INT 11
108878: PUSH
108879: LD_INT 12
108881: PUSH
108882: LD_INT 15
108884: PUSH
108885: LD_INT 16
108887: PUSH
108888: LD_INT 22
108890: PUSH
108891: LD_INT 23
108893: PUSH
108894: LD_INT 26
108896: PUSH
108897: LD_INT 36
108899: PUSH
108900: EMPTY
108901: LIST
108902: LIST
108903: LIST
108904: LIST
108905: LIST
108906: LIST
108907: LIST
108908: LIST
108909: LIST
108910: LIST
108911: LIST
108912: LIST
108913: PUSH
108914: LD_INT 101
108916: PUSH
108917: LD_INT 102
108919: PUSH
108920: LD_INT 105
108922: PUSH
108923: LD_INT 106
108925: PUSH
108926: LD_INT 108
108928: PUSH
108929: EMPTY
108930: LIST
108931: LIST
108932: LIST
108933: LIST
108934: LIST
108935: PUSH
108936: EMPTY
108937: LIST
108938: LIST
108939: ST_TO_ADDR
108940: GO 111543
108942: LD_INT 5
108944: DOUBLE
108945: EQUAL
108946: IFTRUE 108950
108948: GO 109050
108950: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
108951: LD_ADDR_VAR 0 1
108955: PUSH
108956: LD_INT 2
108958: PUSH
108959: LD_INT 4
108961: PUSH
108962: LD_INT 5
108964: PUSH
108965: LD_INT 6
108967: PUSH
108968: LD_INT 8
108970: PUSH
108971: LD_INT 11
108973: PUSH
108974: LD_INT 12
108976: PUSH
108977: LD_INT 15
108979: PUSH
108980: LD_INT 16
108982: PUSH
108983: LD_INT 22
108985: PUSH
108986: LD_INT 23
108988: PUSH
108989: LD_INT 25
108991: PUSH
108992: LD_INT 26
108994: PUSH
108995: LD_INT 36
108997: PUSH
108998: EMPTY
108999: LIST
109000: LIST
109001: LIST
109002: LIST
109003: LIST
109004: LIST
109005: LIST
109006: LIST
109007: LIST
109008: LIST
109009: LIST
109010: LIST
109011: LIST
109012: LIST
109013: PUSH
109014: LD_INT 101
109016: PUSH
109017: LD_INT 102
109019: PUSH
109020: LD_INT 105
109022: PUSH
109023: LD_INT 106
109025: PUSH
109026: LD_INT 108
109028: PUSH
109029: LD_INT 109
109031: PUSH
109032: LD_INT 112
109034: PUSH
109035: EMPTY
109036: LIST
109037: LIST
109038: LIST
109039: LIST
109040: LIST
109041: LIST
109042: LIST
109043: PUSH
109044: EMPTY
109045: LIST
109046: LIST
109047: ST_TO_ADDR
109048: GO 111543
109050: LD_INT 6
109052: DOUBLE
109053: EQUAL
109054: IFTRUE 109058
109056: GO 109178
109058: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
109059: LD_ADDR_VAR 0 1
109063: PUSH
109064: LD_INT 2
109066: PUSH
109067: LD_INT 4
109069: PUSH
109070: LD_INT 5
109072: PUSH
109073: LD_INT 6
109075: PUSH
109076: LD_INT 8
109078: PUSH
109079: LD_INT 11
109081: PUSH
109082: LD_INT 12
109084: PUSH
109085: LD_INT 15
109087: PUSH
109088: LD_INT 16
109090: PUSH
109091: LD_INT 20
109093: PUSH
109094: LD_INT 21
109096: PUSH
109097: LD_INT 22
109099: PUSH
109100: LD_INT 23
109102: PUSH
109103: LD_INT 25
109105: PUSH
109106: LD_INT 26
109108: PUSH
109109: LD_INT 30
109111: PUSH
109112: LD_INT 31
109114: PUSH
109115: LD_INT 32
109117: PUSH
109118: LD_INT 36
109120: PUSH
109121: EMPTY
109122: LIST
109123: LIST
109124: LIST
109125: LIST
109126: LIST
109127: LIST
109128: LIST
109129: LIST
109130: LIST
109131: LIST
109132: LIST
109133: LIST
109134: LIST
109135: LIST
109136: LIST
109137: LIST
109138: LIST
109139: LIST
109140: LIST
109141: PUSH
109142: LD_INT 101
109144: PUSH
109145: LD_INT 102
109147: PUSH
109148: LD_INT 105
109150: PUSH
109151: LD_INT 106
109153: PUSH
109154: LD_INT 108
109156: PUSH
109157: LD_INT 109
109159: PUSH
109160: LD_INT 112
109162: PUSH
109163: EMPTY
109164: LIST
109165: LIST
109166: LIST
109167: LIST
109168: LIST
109169: LIST
109170: LIST
109171: PUSH
109172: EMPTY
109173: LIST
109174: LIST
109175: ST_TO_ADDR
109176: GO 111543
109178: LD_INT 7
109180: DOUBLE
109181: EQUAL
109182: IFTRUE 109186
109184: GO 109286
109186: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
109187: LD_ADDR_VAR 0 1
109191: PUSH
109192: LD_INT 2
109194: PUSH
109195: LD_INT 4
109197: PUSH
109198: LD_INT 5
109200: PUSH
109201: LD_INT 7
109203: PUSH
109204: LD_INT 11
109206: PUSH
109207: LD_INT 12
109209: PUSH
109210: LD_INT 15
109212: PUSH
109213: LD_INT 16
109215: PUSH
109216: LD_INT 20
109218: PUSH
109219: LD_INT 21
109221: PUSH
109222: LD_INT 22
109224: PUSH
109225: LD_INT 23
109227: PUSH
109228: LD_INT 25
109230: PUSH
109231: LD_INT 26
109233: PUSH
109234: EMPTY
109235: LIST
109236: LIST
109237: LIST
109238: LIST
109239: LIST
109240: LIST
109241: LIST
109242: LIST
109243: LIST
109244: LIST
109245: LIST
109246: LIST
109247: LIST
109248: LIST
109249: PUSH
109250: LD_INT 101
109252: PUSH
109253: LD_INT 102
109255: PUSH
109256: LD_INT 103
109258: PUSH
109259: LD_INT 105
109261: PUSH
109262: LD_INT 106
109264: PUSH
109265: LD_INT 108
109267: PUSH
109268: LD_INT 112
109270: PUSH
109271: EMPTY
109272: LIST
109273: LIST
109274: LIST
109275: LIST
109276: LIST
109277: LIST
109278: LIST
109279: PUSH
109280: EMPTY
109281: LIST
109282: LIST
109283: ST_TO_ADDR
109284: GO 111543
109286: LD_INT 8
109288: DOUBLE
109289: EQUAL
109290: IFTRUE 109294
109292: GO 109422
109294: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
109295: LD_ADDR_VAR 0 1
109299: PUSH
109300: LD_INT 2
109302: PUSH
109303: LD_INT 4
109305: PUSH
109306: LD_INT 5
109308: PUSH
109309: LD_INT 6
109311: PUSH
109312: LD_INT 7
109314: PUSH
109315: LD_INT 8
109317: PUSH
109318: LD_INT 11
109320: PUSH
109321: LD_INT 12
109323: PUSH
109324: LD_INT 15
109326: PUSH
109327: LD_INT 16
109329: PUSH
109330: LD_INT 20
109332: PUSH
109333: LD_INT 21
109335: PUSH
109336: LD_INT 22
109338: PUSH
109339: LD_INT 23
109341: PUSH
109342: LD_INT 25
109344: PUSH
109345: LD_INT 26
109347: PUSH
109348: LD_INT 30
109350: PUSH
109351: LD_INT 31
109353: PUSH
109354: LD_INT 32
109356: PUSH
109357: LD_INT 36
109359: PUSH
109360: EMPTY
109361: LIST
109362: LIST
109363: LIST
109364: LIST
109365: LIST
109366: LIST
109367: LIST
109368: LIST
109369: LIST
109370: LIST
109371: LIST
109372: LIST
109373: LIST
109374: LIST
109375: LIST
109376: LIST
109377: LIST
109378: LIST
109379: LIST
109380: LIST
109381: PUSH
109382: LD_INT 101
109384: PUSH
109385: LD_INT 102
109387: PUSH
109388: LD_INT 103
109390: PUSH
109391: LD_INT 105
109393: PUSH
109394: LD_INT 106
109396: PUSH
109397: LD_INT 108
109399: PUSH
109400: LD_INT 109
109402: PUSH
109403: LD_INT 112
109405: PUSH
109406: EMPTY
109407: LIST
109408: LIST
109409: LIST
109410: LIST
109411: LIST
109412: LIST
109413: LIST
109414: LIST
109415: PUSH
109416: EMPTY
109417: LIST
109418: LIST
109419: ST_TO_ADDR
109420: GO 111543
109422: LD_INT 9
109424: DOUBLE
109425: EQUAL
109426: IFTRUE 109430
109428: GO 109566
109430: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
109431: LD_ADDR_VAR 0 1
109435: PUSH
109436: LD_INT 2
109438: PUSH
109439: LD_INT 4
109441: PUSH
109442: LD_INT 5
109444: PUSH
109445: LD_INT 6
109447: PUSH
109448: LD_INT 7
109450: PUSH
109451: LD_INT 8
109453: PUSH
109454: LD_INT 11
109456: PUSH
109457: LD_INT 12
109459: PUSH
109460: LD_INT 15
109462: PUSH
109463: LD_INT 16
109465: PUSH
109466: LD_INT 20
109468: PUSH
109469: LD_INT 21
109471: PUSH
109472: LD_INT 22
109474: PUSH
109475: LD_INT 23
109477: PUSH
109478: LD_INT 25
109480: PUSH
109481: LD_INT 26
109483: PUSH
109484: LD_INT 28
109486: PUSH
109487: LD_INT 30
109489: PUSH
109490: LD_INT 31
109492: PUSH
109493: LD_INT 32
109495: PUSH
109496: LD_INT 36
109498: PUSH
109499: EMPTY
109500: LIST
109501: LIST
109502: LIST
109503: LIST
109504: LIST
109505: LIST
109506: LIST
109507: LIST
109508: LIST
109509: LIST
109510: LIST
109511: LIST
109512: LIST
109513: LIST
109514: LIST
109515: LIST
109516: LIST
109517: LIST
109518: LIST
109519: LIST
109520: LIST
109521: PUSH
109522: LD_INT 101
109524: PUSH
109525: LD_INT 102
109527: PUSH
109528: LD_INT 103
109530: PUSH
109531: LD_INT 105
109533: PUSH
109534: LD_INT 106
109536: PUSH
109537: LD_INT 108
109539: PUSH
109540: LD_INT 109
109542: PUSH
109543: LD_INT 112
109545: PUSH
109546: LD_INT 114
109548: PUSH
109549: EMPTY
109550: LIST
109551: LIST
109552: LIST
109553: LIST
109554: LIST
109555: LIST
109556: LIST
109557: LIST
109558: LIST
109559: PUSH
109560: EMPTY
109561: LIST
109562: LIST
109563: ST_TO_ADDR
109564: GO 111543
109566: LD_INT 10
109568: DOUBLE
109569: EQUAL
109570: IFTRUE 109574
109572: GO 109758
109574: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
109575: LD_ADDR_VAR 0 1
109579: PUSH
109580: LD_INT 2
109582: PUSH
109583: LD_INT 4
109585: PUSH
109586: LD_INT 5
109588: PUSH
109589: LD_INT 6
109591: PUSH
109592: LD_INT 7
109594: PUSH
109595: LD_INT 8
109597: PUSH
109598: LD_INT 9
109600: PUSH
109601: LD_INT 10
109603: PUSH
109604: LD_INT 11
109606: PUSH
109607: LD_INT 12
109609: PUSH
109610: LD_INT 13
109612: PUSH
109613: LD_INT 14
109615: PUSH
109616: LD_INT 15
109618: PUSH
109619: LD_INT 16
109621: PUSH
109622: LD_INT 17
109624: PUSH
109625: LD_INT 18
109627: PUSH
109628: LD_INT 19
109630: PUSH
109631: LD_INT 20
109633: PUSH
109634: LD_INT 21
109636: PUSH
109637: LD_INT 22
109639: PUSH
109640: LD_INT 23
109642: PUSH
109643: LD_INT 24
109645: PUSH
109646: LD_INT 25
109648: PUSH
109649: LD_INT 26
109651: PUSH
109652: LD_INT 28
109654: PUSH
109655: LD_INT 30
109657: PUSH
109658: LD_INT 31
109660: PUSH
109661: LD_INT 32
109663: PUSH
109664: LD_INT 36
109666: PUSH
109667: EMPTY
109668: LIST
109669: LIST
109670: LIST
109671: LIST
109672: LIST
109673: LIST
109674: LIST
109675: LIST
109676: LIST
109677: LIST
109678: LIST
109679: LIST
109680: LIST
109681: LIST
109682: LIST
109683: LIST
109684: LIST
109685: LIST
109686: LIST
109687: LIST
109688: LIST
109689: LIST
109690: LIST
109691: LIST
109692: LIST
109693: LIST
109694: LIST
109695: LIST
109696: LIST
109697: PUSH
109698: LD_INT 101
109700: PUSH
109701: LD_INT 102
109703: PUSH
109704: LD_INT 103
109706: PUSH
109707: LD_INT 104
109709: PUSH
109710: LD_INT 105
109712: PUSH
109713: LD_INT 106
109715: PUSH
109716: LD_INT 107
109718: PUSH
109719: LD_INT 108
109721: PUSH
109722: LD_INT 109
109724: PUSH
109725: LD_INT 110
109727: PUSH
109728: LD_INT 111
109730: PUSH
109731: LD_INT 112
109733: PUSH
109734: LD_INT 114
109736: PUSH
109737: EMPTY
109738: LIST
109739: LIST
109740: LIST
109741: LIST
109742: LIST
109743: LIST
109744: LIST
109745: LIST
109746: LIST
109747: LIST
109748: LIST
109749: LIST
109750: LIST
109751: PUSH
109752: EMPTY
109753: LIST
109754: LIST
109755: ST_TO_ADDR
109756: GO 111543
109758: LD_INT 11
109760: DOUBLE
109761: EQUAL
109762: IFTRUE 109766
109764: GO 109958
109766: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
109767: LD_ADDR_VAR 0 1
109771: PUSH
109772: LD_INT 2
109774: PUSH
109775: LD_INT 3
109777: PUSH
109778: LD_INT 4
109780: PUSH
109781: LD_INT 5
109783: PUSH
109784: LD_INT 6
109786: PUSH
109787: LD_INT 7
109789: PUSH
109790: LD_INT 8
109792: PUSH
109793: LD_INT 9
109795: PUSH
109796: LD_INT 10
109798: PUSH
109799: LD_INT 11
109801: PUSH
109802: LD_INT 12
109804: PUSH
109805: LD_INT 13
109807: PUSH
109808: LD_INT 14
109810: PUSH
109811: LD_INT 15
109813: PUSH
109814: LD_INT 16
109816: PUSH
109817: LD_INT 17
109819: PUSH
109820: LD_INT 18
109822: PUSH
109823: LD_INT 19
109825: PUSH
109826: LD_INT 20
109828: PUSH
109829: LD_INT 21
109831: PUSH
109832: LD_INT 22
109834: PUSH
109835: LD_INT 23
109837: PUSH
109838: LD_INT 24
109840: PUSH
109841: LD_INT 25
109843: PUSH
109844: LD_INT 26
109846: PUSH
109847: LD_INT 28
109849: PUSH
109850: LD_INT 30
109852: PUSH
109853: LD_INT 31
109855: PUSH
109856: LD_INT 32
109858: PUSH
109859: LD_INT 34
109861: PUSH
109862: LD_INT 36
109864: PUSH
109865: EMPTY
109866: LIST
109867: LIST
109868: LIST
109869: LIST
109870: LIST
109871: LIST
109872: LIST
109873: LIST
109874: LIST
109875: LIST
109876: LIST
109877: LIST
109878: LIST
109879: LIST
109880: LIST
109881: LIST
109882: LIST
109883: LIST
109884: LIST
109885: LIST
109886: LIST
109887: LIST
109888: LIST
109889: LIST
109890: LIST
109891: LIST
109892: LIST
109893: LIST
109894: LIST
109895: LIST
109896: LIST
109897: PUSH
109898: LD_INT 101
109900: PUSH
109901: LD_INT 102
109903: PUSH
109904: LD_INT 103
109906: PUSH
109907: LD_INT 104
109909: PUSH
109910: LD_INT 105
109912: PUSH
109913: LD_INT 106
109915: PUSH
109916: LD_INT 107
109918: PUSH
109919: LD_INT 108
109921: PUSH
109922: LD_INT 109
109924: PUSH
109925: LD_INT 110
109927: PUSH
109928: LD_INT 111
109930: PUSH
109931: LD_INT 112
109933: PUSH
109934: LD_INT 114
109936: PUSH
109937: EMPTY
109938: LIST
109939: LIST
109940: LIST
109941: LIST
109942: LIST
109943: LIST
109944: LIST
109945: LIST
109946: LIST
109947: LIST
109948: LIST
109949: LIST
109950: LIST
109951: PUSH
109952: EMPTY
109953: LIST
109954: LIST
109955: ST_TO_ADDR
109956: GO 111543
109958: LD_INT 12
109960: DOUBLE
109961: EQUAL
109962: IFTRUE 109966
109964: GO 110174
109966: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
109967: LD_ADDR_VAR 0 1
109971: PUSH
109972: LD_INT 1
109974: PUSH
109975: LD_INT 2
109977: PUSH
109978: LD_INT 3
109980: PUSH
109981: LD_INT 4
109983: PUSH
109984: LD_INT 5
109986: PUSH
109987: LD_INT 6
109989: PUSH
109990: LD_INT 7
109992: PUSH
109993: LD_INT 8
109995: PUSH
109996: LD_INT 9
109998: PUSH
109999: LD_INT 10
110001: PUSH
110002: LD_INT 11
110004: PUSH
110005: LD_INT 12
110007: PUSH
110008: LD_INT 13
110010: PUSH
110011: LD_INT 14
110013: PUSH
110014: LD_INT 15
110016: PUSH
110017: LD_INT 16
110019: PUSH
110020: LD_INT 17
110022: PUSH
110023: LD_INT 18
110025: PUSH
110026: LD_INT 19
110028: PUSH
110029: LD_INT 20
110031: PUSH
110032: LD_INT 21
110034: PUSH
110035: LD_INT 22
110037: PUSH
110038: LD_INT 23
110040: PUSH
110041: LD_INT 24
110043: PUSH
110044: LD_INT 25
110046: PUSH
110047: LD_INT 26
110049: PUSH
110050: LD_INT 27
110052: PUSH
110053: LD_INT 28
110055: PUSH
110056: LD_INT 30
110058: PUSH
110059: LD_INT 31
110061: PUSH
110062: LD_INT 32
110064: PUSH
110065: LD_INT 33
110067: PUSH
110068: LD_INT 34
110070: PUSH
110071: LD_INT 36
110073: PUSH
110074: EMPTY
110075: LIST
110076: LIST
110077: LIST
110078: LIST
110079: LIST
110080: LIST
110081: LIST
110082: LIST
110083: LIST
110084: LIST
110085: LIST
110086: LIST
110087: LIST
110088: LIST
110089: LIST
110090: LIST
110091: LIST
110092: LIST
110093: LIST
110094: LIST
110095: LIST
110096: LIST
110097: LIST
110098: LIST
110099: LIST
110100: LIST
110101: LIST
110102: LIST
110103: LIST
110104: LIST
110105: LIST
110106: LIST
110107: LIST
110108: LIST
110109: PUSH
110110: LD_INT 101
110112: PUSH
110113: LD_INT 102
110115: PUSH
110116: LD_INT 103
110118: PUSH
110119: LD_INT 104
110121: PUSH
110122: LD_INT 105
110124: PUSH
110125: LD_INT 106
110127: PUSH
110128: LD_INT 107
110130: PUSH
110131: LD_INT 108
110133: PUSH
110134: LD_INT 109
110136: PUSH
110137: LD_INT 110
110139: PUSH
110140: LD_INT 111
110142: PUSH
110143: LD_INT 112
110145: PUSH
110146: LD_INT 113
110148: PUSH
110149: LD_INT 114
110151: PUSH
110152: EMPTY
110153: LIST
110154: LIST
110155: LIST
110156: LIST
110157: LIST
110158: LIST
110159: LIST
110160: LIST
110161: LIST
110162: LIST
110163: LIST
110164: LIST
110165: LIST
110166: LIST
110167: PUSH
110168: EMPTY
110169: LIST
110170: LIST
110171: ST_TO_ADDR
110172: GO 111543
110174: LD_INT 13
110176: DOUBLE
110177: EQUAL
110178: IFTRUE 110182
110180: GO 110378
110182: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
110183: LD_ADDR_VAR 0 1
110187: PUSH
110188: LD_INT 1
110190: PUSH
110191: LD_INT 2
110193: PUSH
110194: LD_INT 3
110196: PUSH
110197: LD_INT 4
110199: PUSH
110200: LD_INT 5
110202: PUSH
110203: LD_INT 8
110205: PUSH
110206: LD_INT 9
110208: PUSH
110209: LD_INT 10
110211: PUSH
110212: LD_INT 11
110214: PUSH
110215: LD_INT 12
110217: PUSH
110218: LD_INT 14
110220: PUSH
110221: LD_INT 15
110223: PUSH
110224: LD_INT 16
110226: PUSH
110227: LD_INT 17
110229: PUSH
110230: LD_INT 18
110232: PUSH
110233: LD_INT 19
110235: PUSH
110236: LD_INT 20
110238: PUSH
110239: LD_INT 21
110241: PUSH
110242: LD_INT 22
110244: PUSH
110245: LD_INT 23
110247: PUSH
110248: LD_INT 24
110250: PUSH
110251: LD_INT 25
110253: PUSH
110254: LD_INT 26
110256: PUSH
110257: LD_INT 27
110259: PUSH
110260: LD_INT 28
110262: PUSH
110263: LD_INT 30
110265: PUSH
110266: LD_INT 31
110268: PUSH
110269: LD_INT 32
110271: PUSH
110272: LD_INT 33
110274: PUSH
110275: LD_INT 34
110277: PUSH
110278: LD_INT 36
110280: PUSH
110281: EMPTY
110282: LIST
110283: LIST
110284: LIST
110285: LIST
110286: LIST
110287: LIST
110288: LIST
110289: LIST
110290: LIST
110291: LIST
110292: LIST
110293: LIST
110294: LIST
110295: LIST
110296: LIST
110297: LIST
110298: LIST
110299: LIST
110300: LIST
110301: LIST
110302: LIST
110303: LIST
110304: LIST
110305: LIST
110306: LIST
110307: LIST
110308: LIST
110309: LIST
110310: LIST
110311: LIST
110312: LIST
110313: PUSH
110314: LD_INT 101
110316: PUSH
110317: LD_INT 102
110319: PUSH
110320: LD_INT 103
110322: PUSH
110323: LD_INT 104
110325: PUSH
110326: LD_INT 105
110328: PUSH
110329: LD_INT 106
110331: PUSH
110332: LD_INT 107
110334: PUSH
110335: LD_INT 108
110337: PUSH
110338: LD_INT 109
110340: PUSH
110341: LD_INT 110
110343: PUSH
110344: LD_INT 111
110346: PUSH
110347: LD_INT 112
110349: PUSH
110350: LD_INT 113
110352: PUSH
110353: LD_INT 114
110355: PUSH
110356: EMPTY
110357: LIST
110358: LIST
110359: LIST
110360: LIST
110361: LIST
110362: LIST
110363: LIST
110364: LIST
110365: LIST
110366: LIST
110367: LIST
110368: LIST
110369: LIST
110370: LIST
110371: PUSH
110372: EMPTY
110373: LIST
110374: LIST
110375: ST_TO_ADDR
110376: GO 111543
110378: LD_INT 14
110380: DOUBLE
110381: EQUAL
110382: IFTRUE 110386
110384: GO 110598
110386: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
110387: LD_ADDR_VAR 0 1
110391: PUSH
110392: LD_INT 1
110394: PUSH
110395: LD_INT 2
110397: PUSH
110398: LD_INT 3
110400: PUSH
110401: LD_INT 4
110403: PUSH
110404: LD_INT 5
110406: PUSH
110407: LD_INT 6
110409: PUSH
110410: LD_INT 7
110412: PUSH
110413: LD_INT 8
110415: PUSH
110416: LD_INT 9
110418: PUSH
110419: LD_INT 10
110421: PUSH
110422: LD_INT 11
110424: PUSH
110425: LD_INT 12
110427: PUSH
110428: LD_INT 13
110430: PUSH
110431: LD_INT 14
110433: PUSH
110434: LD_INT 15
110436: PUSH
110437: LD_INT 16
110439: PUSH
110440: LD_INT 17
110442: PUSH
110443: LD_INT 18
110445: PUSH
110446: LD_INT 19
110448: PUSH
110449: LD_INT 20
110451: PUSH
110452: LD_INT 21
110454: PUSH
110455: LD_INT 22
110457: PUSH
110458: LD_INT 23
110460: PUSH
110461: LD_INT 24
110463: PUSH
110464: LD_INT 25
110466: PUSH
110467: LD_INT 26
110469: PUSH
110470: LD_INT 27
110472: PUSH
110473: LD_INT 28
110475: PUSH
110476: LD_INT 29
110478: PUSH
110479: LD_INT 30
110481: PUSH
110482: LD_INT 31
110484: PUSH
110485: LD_INT 32
110487: PUSH
110488: LD_INT 33
110490: PUSH
110491: LD_INT 34
110493: PUSH
110494: LD_INT 36
110496: PUSH
110497: EMPTY
110498: LIST
110499: LIST
110500: LIST
110501: LIST
110502: LIST
110503: LIST
110504: LIST
110505: LIST
110506: LIST
110507: LIST
110508: LIST
110509: LIST
110510: LIST
110511: LIST
110512: LIST
110513: LIST
110514: LIST
110515: LIST
110516: LIST
110517: LIST
110518: LIST
110519: LIST
110520: LIST
110521: LIST
110522: LIST
110523: LIST
110524: LIST
110525: LIST
110526: LIST
110527: LIST
110528: LIST
110529: LIST
110530: LIST
110531: LIST
110532: LIST
110533: PUSH
110534: LD_INT 101
110536: PUSH
110537: LD_INT 102
110539: PUSH
110540: LD_INT 103
110542: PUSH
110543: LD_INT 104
110545: PUSH
110546: LD_INT 105
110548: PUSH
110549: LD_INT 106
110551: PUSH
110552: LD_INT 107
110554: PUSH
110555: LD_INT 108
110557: PUSH
110558: LD_INT 109
110560: PUSH
110561: LD_INT 110
110563: PUSH
110564: LD_INT 111
110566: PUSH
110567: LD_INT 112
110569: PUSH
110570: LD_INT 113
110572: PUSH
110573: LD_INT 114
110575: PUSH
110576: EMPTY
110577: LIST
110578: LIST
110579: LIST
110580: LIST
110581: LIST
110582: LIST
110583: LIST
110584: LIST
110585: LIST
110586: LIST
110587: LIST
110588: LIST
110589: LIST
110590: LIST
110591: PUSH
110592: EMPTY
110593: LIST
110594: LIST
110595: ST_TO_ADDR
110596: GO 111543
110598: LD_INT 15
110600: DOUBLE
110601: EQUAL
110602: IFTRUE 110606
110604: GO 110818
110606: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
110607: LD_ADDR_VAR 0 1
110611: PUSH
110612: LD_INT 1
110614: PUSH
110615: LD_INT 2
110617: PUSH
110618: LD_INT 3
110620: PUSH
110621: LD_INT 4
110623: PUSH
110624: LD_INT 5
110626: PUSH
110627: LD_INT 6
110629: PUSH
110630: LD_INT 7
110632: PUSH
110633: LD_INT 8
110635: PUSH
110636: LD_INT 9
110638: PUSH
110639: LD_INT 10
110641: PUSH
110642: LD_INT 11
110644: PUSH
110645: LD_INT 12
110647: PUSH
110648: LD_INT 13
110650: PUSH
110651: LD_INT 14
110653: PUSH
110654: LD_INT 15
110656: PUSH
110657: LD_INT 16
110659: PUSH
110660: LD_INT 17
110662: PUSH
110663: LD_INT 18
110665: PUSH
110666: LD_INT 19
110668: PUSH
110669: LD_INT 20
110671: PUSH
110672: LD_INT 21
110674: PUSH
110675: LD_INT 22
110677: PUSH
110678: LD_INT 23
110680: PUSH
110681: LD_INT 24
110683: PUSH
110684: LD_INT 25
110686: PUSH
110687: LD_INT 26
110689: PUSH
110690: LD_INT 27
110692: PUSH
110693: LD_INT 28
110695: PUSH
110696: LD_INT 29
110698: PUSH
110699: LD_INT 30
110701: PUSH
110702: LD_INT 31
110704: PUSH
110705: LD_INT 32
110707: PUSH
110708: LD_INT 33
110710: PUSH
110711: LD_INT 34
110713: PUSH
110714: LD_INT 36
110716: PUSH
110717: EMPTY
110718: LIST
110719: LIST
110720: LIST
110721: LIST
110722: LIST
110723: LIST
110724: LIST
110725: LIST
110726: LIST
110727: LIST
110728: LIST
110729: LIST
110730: LIST
110731: LIST
110732: LIST
110733: LIST
110734: LIST
110735: LIST
110736: LIST
110737: LIST
110738: LIST
110739: LIST
110740: LIST
110741: LIST
110742: LIST
110743: LIST
110744: LIST
110745: LIST
110746: LIST
110747: LIST
110748: LIST
110749: LIST
110750: LIST
110751: LIST
110752: LIST
110753: PUSH
110754: LD_INT 101
110756: PUSH
110757: LD_INT 102
110759: PUSH
110760: LD_INT 103
110762: PUSH
110763: LD_INT 104
110765: PUSH
110766: LD_INT 105
110768: PUSH
110769: LD_INT 106
110771: PUSH
110772: LD_INT 107
110774: PUSH
110775: LD_INT 108
110777: PUSH
110778: LD_INT 109
110780: PUSH
110781: LD_INT 110
110783: PUSH
110784: LD_INT 111
110786: PUSH
110787: LD_INT 112
110789: PUSH
110790: LD_INT 113
110792: PUSH
110793: LD_INT 114
110795: PUSH
110796: EMPTY
110797: LIST
110798: LIST
110799: LIST
110800: LIST
110801: LIST
110802: LIST
110803: LIST
110804: LIST
110805: LIST
110806: LIST
110807: LIST
110808: LIST
110809: LIST
110810: LIST
110811: PUSH
110812: EMPTY
110813: LIST
110814: LIST
110815: ST_TO_ADDR
110816: GO 111543
110818: LD_INT 16
110820: DOUBLE
110821: EQUAL
110822: IFTRUE 110826
110824: GO 110950
110826: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
110827: LD_ADDR_VAR 0 1
110831: PUSH
110832: LD_INT 2
110834: PUSH
110835: LD_INT 4
110837: PUSH
110838: LD_INT 5
110840: PUSH
110841: LD_INT 7
110843: PUSH
110844: LD_INT 11
110846: PUSH
110847: LD_INT 12
110849: PUSH
110850: LD_INT 15
110852: PUSH
110853: LD_INT 16
110855: PUSH
110856: LD_INT 20
110858: PUSH
110859: LD_INT 21
110861: PUSH
110862: LD_INT 22
110864: PUSH
110865: LD_INT 23
110867: PUSH
110868: LD_INT 25
110870: PUSH
110871: LD_INT 26
110873: PUSH
110874: LD_INT 30
110876: PUSH
110877: LD_INT 31
110879: PUSH
110880: LD_INT 32
110882: PUSH
110883: LD_INT 33
110885: PUSH
110886: LD_INT 34
110888: PUSH
110889: EMPTY
110890: LIST
110891: LIST
110892: LIST
110893: LIST
110894: LIST
110895: LIST
110896: LIST
110897: LIST
110898: LIST
110899: LIST
110900: LIST
110901: LIST
110902: LIST
110903: LIST
110904: LIST
110905: LIST
110906: LIST
110907: LIST
110908: LIST
110909: PUSH
110910: LD_INT 101
110912: PUSH
110913: LD_INT 102
110915: PUSH
110916: LD_INT 103
110918: PUSH
110919: LD_INT 106
110921: PUSH
110922: LD_INT 108
110924: PUSH
110925: LD_INT 112
110927: PUSH
110928: LD_INT 113
110930: PUSH
110931: LD_INT 114
110933: PUSH
110934: EMPTY
110935: LIST
110936: LIST
110937: LIST
110938: LIST
110939: LIST
110940: LIST
110941: LIST
110942: LIST
110943: PUSH
110944: EMPTY
110945: LIST
110946: LIST
110947: ST_TO_ADDR
110948: GO 111543
110950: LD_INT 17
110952: DOUBLE
110953: EQUAL
110954: IFTRUE 110958
110956: GO 111170
110958: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
110959: LD_ADDR_VAR 0 1
110963: PUSH
110964: LD_INT 1
110966: PUSH
110967: LD_INT 2
110969: PUSH
110970: LD_INT 3
110972: PUSH
110973: LD_INT 4
110975: PUSH
110976: LD_INT 5
110978: PUSH
110979: LD_INT 6
110981: PUSH
110982: LD_INT 7
110984: PUSH
110985: LD_INT 8
110987: PUSH
110988: LD_INT 9
110990: PUSH
110991: LD_INT 10
110993: PUSH
110994: LD_INT 11
110996: PUSH
110997: LD_INT 12
110999: PUSH
111000: LD_INT 13
111002: PUSH
111003: LD_INT 14
111005: PUSH
111006: LD_INT 15
111008: PUSH
111009: LD_INT 16
111011: PUSH
111012: LD_INT 17
111014: PUSH
111015: LD_INT 18
111017: PUSH
111018: LD_INT 19
111020: PUSH
111021: LD_INT 20
111023: PUSH
111024: LD_INT 21
111026: PUSH
111027: LD_INT 22
111029: PUSH
111030: LD_INT 23
111032: PUSH
111033: LD_INT 24
111035: PUSH
111036: LD_INT 25
111038: PUSH
111039: LD_INT 26
111041: PUSH
111042: LD_INT 27
111044: PUSH
111045: LD_INT 28
111047: PUSH
111048: LD_INT 29
111050: PUSH
111051: LD_INT 30
111053: PUSH
111054: LD_INT 31
111056: PUSH
111057: LD_INT 32
111059: PUSH
111060: LD_INT 33
111062: PUSH
111063: LD_INT 34
111065: PUSH
111066: LD_INT 36
111068: PUSH
111069: EMPTY
111070: LIST
111071: LIST
111072: LIST
111073: LIST
111074: LIST
111075: LIST
111076: LIST
111077: LIST
111078: LIST
111079: LIST
111080: LIST
111081: LIST
111082: LIST
111083: LIST
111084: LIST
111085: LIST
111086: LIST
111087: LIST
111088: LIST
111089: LIST
111090: LIST
111091: LIST
111092: LIST
111093: LIST
111094: LIST
111095: LIST
111096: LIST
111097: LIST
111098: LIST
111099: LIST
111100: LIST
111101: LIST
111102: LIST
111103: LIST
111104: LIST
111105: PUSH
111106: LD_INT 101
111108: PUSH
111109: LD_INT 102
111111: PUSH
111112: LD_INT 103
111114: PUSH
111115: LD_INT 104
111117: PUSH
111118: LD_INT 105
111120: PUSH
111121: LD_INT 106
111123: PUSH
111124: LD_INT 107
111126: PUSH
111127: LD_INT 108
111129: PUSH
111130: LD_INT 109
111132: PUSH
111133: LD_INT 110
111135: PUSH
111136: LD_INT 111
111138: PUSH
111139: LD_INT 112
111141: PUSH
111142: LD_INT 113
111144: PUSH
111145: LD_INT 114
111147: PUSH
111148: EMPTY
111149: LIST
111150: LIST
111151: LIST
111152: LIST
111153: LIST
111154: LIST
111155: LIST
111156: LIST
111157: LIST
111158: LIST
111159: LIST
111160: LIST
111161: LIST
111162: LIST
111163: PUSH
111164: EMPTY
111165: LIST
111166: LIST
111167: ST_TO_ADDR
111168: GO 111543
111170: LD_INT 18
111172: DOUBLE
111173: EQUAL
111174: IFTRUE 111178
111176: GO 111314
111178: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
111179: LD_ADDR_VAR 0 1
111183: PUSH
111184: LD_INT 2
111186: PUSH
111187: LD_INT 4
111189: PUSH
111190: LD_INT 5
111192: PUSH
111193: LD_INT 7
111195: PUSH
111196: LD_INT 11
111198: PUSH
111199: LD_INT 12
111201: PUSH
111202: LD_INT 15
111204: PUSH
111205: LD_INT 16
111207: PUSH
111208: LD_INT 20
111210: PUSH
111211: LD_INT 21
111213: PUSH
111214: LD_INT 22
111216: PUSH
111217: LD_INT 23
111219: PUSH
111220: LD_INT 25
111222: PUSH
111223: LD_INT 26
111225: PUSH
111226: LD_INT 30
111228: PUSH
111229: LD_INT 31
111231: PUSH
111232: LD_INT 32
111234: PUSH
111235: LD_INT 33
111237: PUSH
111238: LD_INT 34
111240: PUSH
111241: LD_INT 35
111243: PUSH
111244: LD_INT 36
111246: PUSH
111247: EMPTY
111248: LIST
111249: LIST
111250: LIST
111251: LIST
111252: LIST
111253: LIST
111254: LIST
111255: LIST
111256: LIST
111257: LIST
111258: LIST
111259: LIST
111260: LIST
111261: LIST
111262: LIST
111263: LIST
111264: LIST
111265: LIST
111266: LIST
111267: LIST
111268: LIST
111269: PUSH
111270: LD_INT 101
111272: PUSH
111273: LD_INT 102
111275: PUSH
111276: LD_INT 103
111278: PUSH
111279: LD_INT 106
111281: PUSH
111282: LD_INT 108
111284: PUSH
111285: LD_INT 112
111287: PUSH
111288: LD_INT 113
111290: PUSH
111291: LD_INT 114
111293: PUSH
111294: LD_INT 115
111296: PUSH
111297: EMPTY
111298: LIST
111299: LIST
111300: LIST
111301: LIST
111302: LIST
111303: LIST
111304: LIST
111305: LIST
111306: LIST
111307: PUSH
111308: EMPTY
111309: LIST
111310: LIST
111311: ST_TO_ADDR
111312: GO 111543
111314: LD_INT 19
111316: DOUBLE
111317: EQUAL
111318: IFTRUE 111322
111320: GO 111542
111322: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
111323: LD_ADDR_VAR 0 1
111327: PUSH
111328: LD_INT 1
111330: PUSH
111331: LD_INT 2
111333: PUSH
111334: LD_INT 3
111336: PUSH
111337: LD_INT 4
111339: PUSH
111340: LD_INT 5
111342: PUSH
111343: LD_INT 6
111345: PUSH
111346: LD_INT 7
111348: PUSH
111349: LD_INT 8
111351: PUSH
111352: LD_INT 9
111354: PUSH
111355: LD_INT 10
111357: PUSH
111358: LD_INT 11
111360: PUSH
111361: LD_INT 12
111363: PUSH
111364: LD_INT 13
111366: PUSH
111367: LD_INT 14
111369: PUSH
111370: LD_INT 15
111372: PUSH
111373: LD_INT 16
111375: PUSH
111376: LD_INT 17
111378: PUSH
111379: LD_INT 18
111381: PUSH
111382: LD_INT 19
111384: PUSH
111385: LD_INT 20
111387: PUSH
111388: LD_INT 21
111390: PUSH
111391: LD_INT 22
111393: PUSH
111394: LD_INT 23
111396: PUSH
111397: LD_INT 24
111399: PUSH
111400: LD_INT 25
111402: PUSH
111403: LD_INT 26
111405: PUSH
111406: LD_INT 27
111408: PUSH
111409: LD_INT 28
111411: PUSH
111412: LD_INT 29
111414: PUSH
111415: LD_INT 30
111417: PUSH
111418: LD_INT 31
111420: PUSH
111421: LD_INT 32
111423: PUSH
111424: LD_INT 33
111426: PUSH
111427: LD_INT 34
111429: PUSH
111430: LD_INT 35
111432: PUSH
111433: LD_INT 36
111435: PUSH
111436: EMPTY
111437: LIST
111438: LIST
111439: LIST
111440: LIST
111441: LIST
111442: LIST
111443: LIST
111444: LIST
111445: LIST
111446: LIST
111447: LIST
111448: LIST
111449: LIST
111450: LIST
111451: LIST
111452: LIST
111453: LIST
111454: LIST
111455: LIST
111456: LIST
111457: LIST
111458: LIST
111459: LIST
111460: LIST
111461: LIST
111462: LIST
111463: LIST
111464: LIST
111465: LIST
111466: LIST
111467: LIST
111468: LIST
111469: LIST
111470: LIST
111471: LIST
111472: LIST
111473: PUSH
111474: LD_INT 101
111476: PUSH
111477: LD_INT 102
111479: PUSH
111480: LD_INT 103
111482: PUSH
111483: LD_INT 104
111485: PUSH
111486: LD_INT 105
111488: PUSH
111489: LD_INT 106
111491: PUSH
111492: LD_INT 107
111494: PUSH
111495: LD_INT 108
111497: PUSH
111498: LD_INT 109
111500: PUSH
111501: LD_INT 110
111503: PUSH
111504: LD_INT 111
111506: PUSH
111507: LD_INT 112
111509: PUSH
111510: LD_INT 113
111512: PUSH
111513: LD_INT 114
111515: PUSH
111516: LD_INT 115
111518: PUSH
111519: EMPTY
111520: LIST
111521: LIST
111522: LIST
111523: LIST
111524: LIST
111525: LIST
111526: LIST
111527: LIST
111528: LIST
111529: LIST
111530: LIST
111531: LIST
111532: LIST
111533: LIST
111534: LIST
111535: PUSH
111536: EMPTY
111537: LIST
111538: LIST
111539: ST_TO_ADDR
111540: GO 111543
111542: POP
// end else
111543: GO 111580
// if campaign_id = 5 then
111545: LD_OWVAR 69
111549: PUSH
111550: LD_INT 5
111552: EQUAL
111553: IFFALSE 111580
// begin result := [ [ 1 , 2 ] , [ 100 ] ] ;
111555: LD_ADDR_VAR 0 1
111559: PUSH
111560: LD_INT 1
111562: PUSH
111563: LD_INT 2
111565: PUSH
111566: EMPTY
111567: LIST
111568: LIST
111569: PUSH
111570: LD_INT 100
111572: PUSH
111573: EMPTY
111574: LIST
111575: PUSH
111576: EMPTY
111577: LIST
111578: LIST
111579: ST_TO_ADDR
// end ; if result then
111580: LD_VAR 0 1
111584: IFFALSE 111873
// begin normal :=  ;
111586: LD_ADDR_VAR 0 3
111590: PUSH
111591: LD_STRING 
111593: ST_TO_ADDR
// hardcore :=  ;
111594: LD_ADDR_VAR 0 4
111598: PUSH
111599: LD_STRING 
111601: ST_TO_ADDR
// for i = 1 to normalCounter do
111602: LD_ADDR_VAR 0 5
111606: PUSH
111607: DOUBLE
111608: LD_INT 1
111610: DEC
111611: ST_TO_ADDR
111612: LD_EXP 146
111616: PUSH
111617: FOR_TO
111618: IFFALSE 111719
// begin tmp := 0 ;
111620: LD_ADDR_VAR 0 2
111624: PUSH
111625: LD_STRING 0
111627: ST_TO_ADDR
// if result [ 1 ] then
111628: LD_VAR 0 1
111632: PUSH
111633: LD_INT 1
111635: ARRAY
111636: IFFALSE 111701
// if result [ 1 ] [ 1 ] = i then
111638: LD_VAR 0 1
111642: PUSH
111643: LD_INT 1
111645: ARRAY
111646: PUSH
111647: LD_INT 1
111649: ARRAY
111650: PUSH
111651: LD_VAR 0 5
111655: EQUAL
111656: IFFALSE 111701
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
111658: LD_ADDR_VAR 0 1
111662: PUSH
111663: LD_VAR 0 1
111667: PPUSH
111668: LD_INT 1
111670: PPUSH
111671: LD_VAR 0 1
111675: PUSH
111676: LD_INT 1
111678: ARRAY
111679: PPUSH
111680: LD_INT 1
111682: PPUSH
111683: CALL_OW 3
111687: PPUSH
111688: CALL_OW 1
111692: ST_TO_ADDR
// tmp := 1 ;
111693: LD_ADDR_VAR 0 2
111697: PUSH
111698: LD_STRING 1
111700: ST_TO_ADDR
// end ; normal := normal & tmp ;
111701: LD_ADDR_VAR 0 3
111705: PUSH
111706: LD_VAR 0 3
111710: PUSH
111711: LD_VAR 0 2
111715: STR
111716: ST_TO_ADDR
// end ;
111717: GO 111617
111719: POP
111720: POP
// for i = 1 to hardcoreCounter do
111721: LD_ADDR_VAR 0 5
111725: PUSH
111726: DOUBLE
111727: LD_INT 1
111729: DEC
111730: ST_TO_ADDR
111731: LD_EXP 147
111735: PUSH
111736: FOR_TO
111737: IFFALSE 111842
// begin tmp := 0 ;
111739: LD_ADDR_VAR 0 2
111743: PUSH
111744: LD_STRING 0
111746: ST_TO_ADDR
// if result [ 2 ] then
111747: LD_VAR 0 1
111751: PUSH
111752: LD_INT 2
111754: ARRAY
111755: IFFALSE 111824
// if result [ 2 ] [ 1 ] = 100 + i then
111757: LD_VAR 0 1
111761: PUSH
111762: LD_INT 2
111764: ARRAY
111765: PUSH
111766: LD_INT 1
111768: ARRAY
111769: PUSH
111770: LD_INT 100
111772: PUSH
111773: LD_VAR 0 5
111777: PLUS
111778: EQUAL
111779: IFFALSE 111824
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
111781: LD_ADDR_VAR 0 1
111785: PUSH
111786: LD_VAR 0 1
111790: PPUSH
111791: LD_INT 2
111793: PPUSH
111794: LD_VAR 0 1
111798: PUSH
111799: LD_INT 2
111801: ARRAY
111802: PPUSH
111803: LD_INT 1
111805: PPUSH
111806: CALL_OW 3
111810: PPUSH
111811: CALL_OW 1
111815: ST_TO_ADDR
// tmp := 1 ;
111816: LD_ADDR_VAR 0 2
111820: PUSH
111821: LD_STRING 1
111823: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
111824: LD_ADDR_VAR 0 4
111828: PUSH
111829: LD_VAR 0 4
111833: PUSH
111834: LD_VAR 0 2
111838: STR
111839: ST_TO_ADDR
// end ;
111840: GO 111736
111842: POP
111843: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
111844: LD_STRING getStreamItemsFromMission("
111846: PUSH
111847: LD_VAR 0 3
111851: STR
111852: PUSH
111853: LD_STRING ","
111855: STR
111856: PUSH
111857: LD_VAR 0 4
111861: STR
111862: PUSH
111863: LD_STRING ")
111865: STR
111866: PPUSH
111867: CALL_OW 559
// end else
111871: GO 111880
// ToLua ( getStreamItemsFromMission("","") ) ;
111873: LD_STRING getStreamItemsFromMission("","")
111875: PPUSH
111876: CALL_OW 559
// end ;
111880: LD_VAR 0 1
111884: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
111885: LD_VAR 0 2
111889: PUSH
111890: LD_INT 100
111892: EQUAL
111893: IFFALSE 112842
// begin if not StreamModeActive then
111895: LD_EXP 145
111899: NOT
111900: IFFALSE 111910
// StreamModeActive := true ;
111902: LD_ADDR_EXP 145
111906: PUSH
111907: LD_INT 1
111909: ST_TO_ADDR
// if p3 = 0 then
111910: LD_VAR 0 3
111914: PUSH
111915: LD_INT 0
111917: EQUAL
111918: IFFALSE 111924
// InitStreamMode ;
111920: CALL 108145 0 0
// if p3 = 1 then
111924: LD_VAR 0 3
111928: PUSH
111929: LD_INT 1
111931: EQUAL
111932: IFFALSE 111942
// sRocket := true ;
111934: LD_ADDR_EXP 150
111938: PUSH
111939: LD_INT 1
111941: ST_TO_ADDR
// if p3 = 2 then
111942: LD_VAR 0 3
111946: PUSH
111947: LD_INT 2
111949: EQUAL
111950: IFFALSE 111960
// sSpeed := true ;
111952: LD_ADDR_EXP 149
111956: PUSH
111957: LD_INT 1
111959: ST_TO_ADDR
// if p3 = 3 then
111960: LD_VAR 0 3
111964: PUSH
111965: LD_INT 3
111967: EQUAL
111968: IFFALSE 111978
// sEngine := true ;
111970: LD_ADDR_EXP 151
111974: PUSH
111975: LD_INT 1
111977: ST_TO_ADDR
// if p3 = 4 then
111978: LD_VAR 0 3
111982: PUSH
111983: LD_INT 4
111985: EQUAL
111986: IFFALSE 111996
// sSpec := true ;
111988: LD_ADDR_EXP 148
111992: PUSH
111993: LD_INT 1
111995: ST_TO_ADDR
// if p3 = 5 then
111996: LD_VAR 0 3
112000: PUSH
112001: LD_INT 5
112003: EQUAL
112004: IFFALSE 112014
// sLevel := true ;
112006: LD_ADDR_EXP 152
112010: PUSH
112011: LD_INT 1
112013: ST_TO_ADDR
// if p3 = 6 then
112014: LD_VAR 0 3
112018: PUSH
112019: LD_INT 6
112021: EQUAL
112022: IFFALSE 112032
// sArmoury := true ;
112024: LD_ADDR_EXP 153
112028: PUSH
112029: LD_INT 1
112031: ST_TO_ADDR
// if p3 = 7 then
112032: LD_VAR 0 3
112036: PUSH
112037: LD_INT 7
112039: EQUAL
112040: IFFALSE 112050
// sRadar := true ;
112042: LD_ADDR_EXP 154
112046: PUSH
112047: LD_INT 1
112049: ST_TO_ADDR
// if p3 = 8 then
112050: LD_VAR 0 3
112054: PUSH
112055: LD_INT 8
112057: EQUAL
112058: IFFALSE 112068
// sBunker := true ;
112060: LD_ADDR_EXP 155
112064: PUSH
112065: LD_INT 1
112067: ST_TO_ADDR
// if p3 = 9 then
112068: LD_VAR 0 3
112072: PUSH
112073: LD_INT 9
112075: EQUAL
112076: IFFALSE 112086
// sHack := true ;
112078: LD_ADDR_EXP 156
112082: PUSH
112083: LD_INT 1
112085: ST_TO_ADDR
// if p3 = 10 then
112086: LD_VAR 0 3
112090: PUSH
112091: LD_INT 10
112093: EQUAL
112094: IFFALSE 112104
// sFire := true ;
112096: LD_ADDR_EXP 157
112100: PUSH
112101: LD_INT 1
112103: ST_TO_ADDR
// if p3 = 11 then
112104: LD_VAR 0 3
112108: PUSH
112109: LD_INT 11
112111: EQUAL
112112: IFFALSE 112122
// sRefresh := true ;
112114: LD_ADDR_EXP 158
112118: PUSH
112119: LD_INT 1
112121: ST_TO_ADDR
// if p3 = 12 then
112122: LD_VAR 0 3
112126: PUSH
112127: LD_INT 12
112129: EQUAL
112130: IFFALSE 112140
// sExp := true ;
112132: LD_ADDR_EXP 159
112136: PUSH
112137: LD_INT 1
112139: ST_TO_ADDR
// if p3 = 13 then
112140: LD_VAR 0 3
112144: PUSH
112145: LD_INT 13
112147: EQUAL
112148: IFFALSE 112158
// sDepot := true ;
112150: LD_ADDR_EXP 160
112154: PUSH
112155: LD_INT 1
112157: ST_TO_ADDR
// if p3 = 14 then
112158: LD_VAR 0 3
112162: PUSH
112163: LD_INT 14
112165: EQUAL
112166: IFFALSE 112176
// sFlag := true ;
112168: LD_ADDR_EXP 161
112172: PUSH
112173: LD_INT 1
112175: ST_TO_ADDR
// if p3 = 15 then
112176: LD_VAR 0 3
112180: PUSH
112181: LD_INT 15
112183: EQUAL
112184: IFFALSE 112194
// sKamikadze := true ;
112186: LD_ADDR_EXP 169
112190: PUSH
112191: LD_INT 1
112193: ST_TO_ADDR
// if p3 = 16 then
112194: LD_VAR 0 3
112198: PUSH
112199: LD_INT 16
112201: EQUAL
112202: IFFALSE 112212
// sTroll := true ;
112204: LD_ADDR_EXP 170
112208: PUSH
112209: LD_INT 1
112211: ST_TO_ADDR
// if p3 = 17 then
112212: LD_VAR 0 3
112216: PUSH
112217: LD_INT 17
112219: EQUAL
112220: IFFALSE 112230
// sSlow := true ;
112222: LD_ADDR_EXP 171
112226: PUSH
112227: LD_INT 1
112229: ST_TO_ADDR
// if p3 = 18 then
112230: LD_VAR 0 3
112234: PUSH
112235: LD_INT 18
112237: EQUAL
112238: IFFALSE 112248
// sLack := true ;
112240: LD_ADDR_EXP 172
112244: PUSH
112245: LD_INT 1
112247: ST_TO_ADDR
// if p3 = 19 then
112248: LD_VAR 0 3
112252: PUSH
112253: LD_INT 19
112255: EQUAL
112256: IFFALSE 112266
// sTank := true ;
112258: LD_ADDR_EXP 174
112262: PUSH
112263: LD_INT 1
112265: ST_TO_ADDR
// if p3 = 20 then
112266: LD_VAR 0 3
112270: PUSH
112271: LD_INT 20
112273: EQUAL
112274: IFFALSE 112284
// sRemote := true ;
112276: LD_ADDR_EXP 175
112280: PUSH
112281: LD_INT 1
112283: ST_TO_ADDR
// if p3 = 21 then
112284: LD_VAR 0 3
112288: PUSH
112289: LD_INT 21
112291: EQUAL
112292: IFFALSE 112302
// sPowell := true ;
112294: LD_ADDR_EXP 176
112298: PUSH
112299: LD_INT 1
112301: ST_TO_ADDR
// if p3 = 22 then
112302: LD_VAR 0 3
112306: PUSH
112307: LD_INT 22
112309: EQUAL
112310: IFFALSE 112320
// sTeleport := true ;
112312: LD_ADDR_EXP 179
112316: PUSH
112317: LD_INT 1
112319: ST_TO_ADDR
// if p3 = 23 then
112320: LD_VAR 0 3
112324: PUSH
112325: LD_INT 23
112327: EQUAL
112328: IFFALSE 112338
// sOilTower := true ;
112330: LD_ADDR_EXP 181
112334: PUSH
112335: LD_INT 1
112337: ST_TO_ADDR
// if p3 = 24 then
112338: LD_VAR 0 3
112342: PUSH
112343: LD_INT 24
112345: EQUAL
112346: IFFALSE 112356
// sShovel := true ;
112348: LD_ADDR_EXP 182
112352: PUSH
112353: LD_INT 1
112355: ST_TO_ADDR
// if p3 = 25 then
112356: LD_VAR 0 3
112360: PUSH
112361: LD_INT 25
112363: EQUAL
112364: IFFALSE 112374
// sSheik := true ;
112366: LD_ADDR_EXP 183
112370: PUSH
112371: LD_INT 1
112373: ST_TO_ADDR
// if p3 = 26 then
112374: LD_VAR 0 3
112378: PUSH
112379: LD_INT 26
112381: EQUAL
112382: IFFALSE 112392
// sEarthquake := true ;
112384: LD_ADDR_EXP 185
112388: PUSH
112389: LD_INT 1
112391: ST_TO_ADDR
// if p3 = 27 then
112392: LD_VAR 0 3
112396: PUSH
112397: LD_INT 27
112399: EQUAL
112400: IFFALSE 112410
// sAI := true ;
112402: LD_ADDR_EXP 186
112406: PUSH
112407: LD_INT 1
112409: ST_TO_ADDR
// if p3 = 28 then
112410: LD_VAR 0 3
112414: PUSH
112415: LD_INT 28
112417: EQUAL
112418: IFFALSE 112428
// sCargo := true ;
112420: LD_ADDR_EXP 189
112424: PUSH
112425: LD_INT 1
112427: ST_TO_ADDR
// if p3 = 29 then
112428: LD_VAR 0 3
112432: PUSH
112433: LD_INT 29
112435: EQUAL
112436: IFFALSE 112446
// sDLaser := true ;
112438: LD_ADDR_EXP 190
112442: PUSH
112443: LD_INT 1
112445: ST_TO_ADDR
// if p3 = 30 then
112446: LD_VAR 0 3
112450: PUSH
112451: LD_INT 30
112453: EQUAL
112454: IFFALSE 112464
// sExchange := true ;
112456: LD_ADDR_EXP 191
112460: PUSH
112461: LD_INT 1
112463: ST_TO_ADDR
// if p3 = 31 then
112464: LD_VAR 0 3
112468: PUSH
112469: LD_INT 31
112471: EQUAL
112472: IFFALSE 112482
// sFac := true ;
112474: LD_ADDR_EXP 192
112478: PUSH
112479: LD_INT 1
112481: ST_TO_ADDR
// if p3 = 32 then
112482: LD_VAR 0 3
112486: PUSH
112487: LD_INT 32
112489: EQUAL
112490: IFFALSE 112500
// sPower := true ;
112492: LD_ADDR_EXP 193
112496: PUSH
112497: LD_INT 1
112499: ST_TO_ADDR
// if p3 = 33 then
112500: LD_VAR 0 3
112504: PUSH
112505: LD_INT 33
112507: EQUAL
112508: IFFALSE 112518
// sRandom := true ;
112510: LD_ADDR_EXP 194
112514: PUSH
112515: LD_INT 1
112517: ST_TO_ADDR
// if p3 = 34 then
112518: LD_VAR 0 3
112522: PUSH
112523: LD_INT 34
112525: EQUAL
112526: IFFALSE 112536
// sShield := true ;
112528: LD_ADDR_EXP 195
112532: PUSH
112533: LD_INT 1
112535: ST_TO_ADDR
// if p3 = 35 then
112536: LD_VAR 0 3
112540: PUSH
112541: LD_INT 35
112543: EQUAL
112544: IFFALSE 112554
// sTime := true ;
112546: LD_ADDR_EXP 196
112550: PUSH
112551: LD_INT 1
112553: ST_TO_ADDR
// if p3 = 36 then
112554: LD_VAR 0 3
112558: PUSH
112559: LD_INT 36
112561: EQUAL
112562: IFFALSE 112572
// sTools := true ;
112564: LD_ADDR_EXP 197
112568: PUSH
112569: LD_INT 1
112571: ST_TO_ADDR
// if p3 = 101 then
112572: LD_VAR 0 3
112576: PUSH
112577: LD_INT 101
112579: EQUAL
112580: IFFALSE 112590
// sSold := true ;
112582: LD_ADDR_EXP 162
112586: PUSH
112587: LD_INT 1
112589: ST_TO_ADDR
// if p3 = 102 then
112590: LD_VAR 0 3
112594: PUSH
112595: LD_INT 102
112597: EQUAL
112598: IFFALSE 112608
// sDiff := true ;
112600: LD_ADDR_EXP 163
112604: PUSH
112605: LD_INT 1
112607: ST_TO_ADDR
// if p3 = 103 then
112608: LD_VAR 0 3
112612: PUSH
112613: LD_INT 103
112615: EQUAL
112616: IFFALSE 112626
// sFog := true ;
112618: LD_ADDR_EXP 166
112622: PUSH
112623: LD_INT 1
112625: ST_TO_ADDR
// if p3 = 104 then
112626: LD_VAR 0 3
112630: PUSH
112631: LD_INT 104
112633: EQUAL
112634: IFFALSE 112644
// sReset := true ;
112636: LD_ADDR_EXP 167
112640: PUSH
112641: LD_INT 1
112643: ST_TO_ADDR
// if p3 = 105 then
112644: LD_VAR 0 3
112648: PUSH
112649: LD_INT 105
112651: EQUAL
112652: IFFALSE 112662
// sSun := true ;
112654: LD_ADDR_EXP 168
112658: PUSH
112659: LD_INT 1
112661: ST_TO_ADDR
// if p3 = 106 then
112662: LD_VAR 0 3
112666: PUSH
112667: LD_INT 106
112669: EQUAL
112670: IFFALSE 112680
// sTiger := true ;
112672: LD_ADDR_EXP 164
112676: PUSH
112677: LD_INT 1
112679: ST_TO_ADDR
// if p3 = 107 then
112680: LD_VAR 0 3
112684: PUSH
112685: LD_INT 107
112687: EQUAL
112688: IFFALSE 112698
// sBomb := true ;
112690: LD_ADDR_EXP 165
112694: PUSH
112695: LD_INT 1
112697: ST_TO_ADDR
// if p3 = 108 then
112698: LD_VAR 0 3
112702: PUSH
112703: LD_INT 108
112705: EQUAL
112706: IFFALSE 112716
// sWound := true ;
112708: LD_ADDR_EXP 173
112712: PUSH
112713: LD_INT 1
112715: ST_TO_ADDR
// if p3 = 109 then
112716: LD_VAR 0 3
112720: PUSH
112721: LD_INT 109
112723: EQUAL
112724: IFFALSE 112734
// sBetray := true ;
112726: LD_ADDR_EXP 177
112730: PUSH
112731: LD_INT 1
112733: ST_TO_ADDR
// if p3 = 110 then
112734: LD_VAR 0 3
112738: PUSH
112739: LD_INT 110
112741: EQUAL
112742: IFFALSE 112752
// sContamin := true ;
112744: LD_ADDR_EXP 178
112748: PUSH
112749: LD_INT 1
112751: ST_TO_ADDR
// if p3 = 111 then
112752: LD_VAR 0 3
112756: PUSH
112757: LD_INT 111
112759: EQUAL
112760: IFFALSE 112770
// sOil := true ;
112762: LD_ADDR_EXP 180
112766: PUSH
112767: LD_INT 1
112769: ST_TO_ADDR
// if p3 = 112 then
112770: LD_VAR 0 3
112774: PUSH
112775: LD_INT 112
112777: EQUAL
112778: IFFALSE 112788
// sStu := true ;
112780: LD_ADDR_EXP 184
112784: PUSH
112785: LD_INT 1
112787: ST_TO_ADDR
// if p3 = 113 then
112788: LD_VAR 0 3
112792: PUSH
112793: LD_INT 113
112795: EQUAL
112796: IFFALSE 112806
// sBazooka := true ;
112798: LD_ADDR_EXP 187
112802: PUSH
112803: LD_INT 1
112805: ST_TO_ADDR
// if p3 = 114 then
112806: LD_VAR 0 3
112810: PUSH
112811: LD_INT 114
112813: EQUAL
112814: IFFALSE 112824
// sMortar := true ;
112816: LD_ADDR_EXP 188
112820: PUSH
112821: LD_INT 1
112823: ST_TO_ADDR
// if p3 = 115 then
112824: LD_VAR 0 3
112828: PUSH
112829: LD_INT 115
112831: EQUAL
112832: IFFALSE 112842
// sRanger := true ;
112834: LD_ADDR_EXP 198
112838: PUSH
112839: LD_INT 1
112841: ST_TO_ADDR
// end ; end ;
112842: PPOPN 6
112844: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
112845: LD_EXP 145
112849: PUSH
112850: LD_EXP 150
112854: AND
112855: IFFALSE 112979
112857: GO 112859
112859: DISABLE
112860: LD_INT 0
112862: PPUSH
112863: PPUSH
// begin enable ;
112864: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
112865: LD_ADDR_VAR 0 2
112869: PUSH
112870: LD_INT 22
112872: PUSH
112873: LD_OWVAR 2
112877: PUSH
112878: EMPTY
112879: LIST
112880: LIST
112881: PUSH
112882: LD_INT 2
112884: PUSH
112885: LD_INT 34
112887: PUSH
112888: LD_INT 7
112890: PUSH
112891: EMPTY
112892: LIST
112893: LIST
112894: PUSH
112895: LD_INT 34
112897: PUSH
112898: LD_INT 45
112900: PUSH
112901: EMPTY
112902: LIST
112903: LIST
112904: PUSH
112905: LD_INT 34
112907: PUSH
112908: LD_INT 28
112910: PUSH
112911: EMPTY
112912: LIST
112913: LIST
112914: PUSH
112915: LD_INT 34
112917: PUSH
112918: LD_INT 47
112920: PUSH
112921: EMPTY
112922: LIST
112923: LIST
112924: PUSH
112925: EMPTY
112926: LIST
112927: LIST
112928: LIST
112929: LIST
112930: LIST
112931: PUSH
112932: EMPTY
112933: LIST
112934: LIST
112935: PPUSH
112936: CALL_OW 69
112940: ST_TO_ADDR
// if not tmp then
112941: LD_VAR 0 2
112945: NOT
112946: IFFALSE 112950
// exit ;
112948: GO 112979
// for i in tmp do
112950: LD_ADDR_VAR 0 1
112954: PUSH
112955: LD_VAR 0 2
112959: PUSH
112960: FOR_IN
112961: IFFALSE 112977
// begin SetLives ( i , 0 ) ;
112963: LD_VAR 0 1
112967: PPUSH
112968: LD_INT 0
112970: PPUSH
112971: CALL_OW 234
// end ;
112975: GO 112960
112977: POP
112978: POP
// end ;
112979: PPOPN 2
112981: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
112982: LD_EXP 145
112986: PUSH
112987: LD_EXP 151
112991: AND
112992: IFFALSE 113076
112994: GO 112996
112996: DISABLE
112997: LD_INT 0
112999: PPUSH
113000: PPUSH
// begin enable ;
113001: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
113002: LD_ADDR_VAR 0 2
113006: PUSH
113007: LD_INT 22
113009: PUSH
113010: LD_OWVAR 2
113014: PUSH
113015: EMPTY
113016: LIST
113017: LIST
113018: PUSH
113019: LD_INT 32
113021: PUSH
113022: LD_INT 3
113024: PUSH
113025: EMPTY
113026: LIST
113027: LIST
113028: PUSH
113029: EMPTY
113030: LIST
113031: LIST
113032: PPUSH
113033: CALL_OW 69
113037: ST_TO_ADDR
// if not tmp then
113038: LD_VAR 0 2
113042: NOT
113043: IFFALSE 113047
// exit ;
113045: GO 113076
// for i in tmp do
113047: LD_ADDR_VAR 0 1
113051: PUSH
113052: LD_VAR 0 2
113056: PUSH
113057: FOR_IN
113058: IFFALSE 113074
// begin SetLives ( i , 0 ) ;
113060: LD_VAR 0 1
113064: PPUSH
113065: LD_INT 0
113067: PPUSH
113068: CALL_OW 234
// end ;
113072: GO 113057
113074: POP
113075: POP
// end ;
113076: PPOPN 2
113078: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
113079: LD_EXP 145
113083: PUSH
113084: LD_EXP 148
113088: AND
113089: IFFALSE 113182
113091: GO 113093
113093: DISABLE
113094: LD_INT 0
113096: PPUSH
// begin enable ;
113097: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
113098: LD_ADDR_VAR 0 1
113102: PUSH
113103: LD_INT 22
113105: PUSH
113106: LD_OWVAR 2
113110: PUSH
113111: EMPTY
113112: LIST
113113: LIST
113114: PUSH
113115: LD_INT 2
113117: PUSH
113118: LD_INT 25
113120: PUSH
113121: LD_INT 5
113123: PUSH
113124: EMPTY
113125: LIST
113126: LIST
113127: PUSH
113128: LD_INT 25
113130: PUSH
113131: LD_INT 9
113133: PUSH
113134: EMPTY
113135: LIST
113136: LIST
113137: PUSH
113138: LD_INT 25
113140: PUSH
113141: LD_INT 8
113143: PUSH
113144: EMPTY
113145: LIST
113146: LIST
113147: PUSH
113148: EMPTY
113149: LIST
113150: LIST
113151: LIST
113152: LIST
113153: PUSH
113154: EMPTY
113155: LIST
113156: LIST
113157: PPUSH
113158: CALL_OW 69
113162: PUSH
113163: FOR_IN
113164: IFFALSE 113180
// begin SetClass ( i , 1 ) ;
113166: LD_VAR 0 1
113170: PPUSH
113171: LD_INT 1
113173: PPUSH
113174: CALL_OW 336
// end ;
113178: GO 113163
113180: POP
113181: POP
// end ;
113182: PPOPN 1
113184: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
113185: LD_EXP 145
113189: PUSH
113190: LD_EXP 149
113194: AND
113195: PUSH
113196: LD_OWVAR 65
113200: PUSH
113201: LD_INT 7
113203: LESS
113204: AND
113205: IFFALSE 113219
113207: GO 113209
113209: DISABLE
// begin enable ;
113210: ENABLE
// game_speed := 7 ;
113211: LD_ADDR_OWVAR 65
113215: PUSH
113216: LD_INT 7
113218: ST_TO_ADDR
// end ;
113219: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
113220: LD_EXP 145
113224: PUSH
113225: LD_EXP 152
113229: AND
113230: IFFALSE 113432
113232: GO 113234
113234: DISABLE
113235: LD_INT 0
113237: PPUSH
113238: PPUSH
113239: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
113240: LD_ADDR_VAR 0 3
113244: PUSH
113245: LD_INT 81
113247: PUSH
113248: LD_OWVAR 2
113252: PUSH
113253: EMPTY
113254: LIST
113255: LIST
113256: PUSH
113257: LD_INT 21
113259: PUSH
113260: LD_INT 1
113262: PUSH
113263: EMPTY
113264: LIST
113265: LIST
113266: PUSH
113267: EMPTY
113268: LIST
113269: LIST
113270: PPUSH
113271: CALL_OW 69
113275: ST_TO_ADDR
// if not tmp then
113276: LD_VAR 0 3
113280: NOT
113281: IFFALSE 113285
// exit ;
113283: GO 113432
// if tmp > 5 then
113285: LD_VAR 0 3
113289: PUSH
113290: LD_INT 5
113292: GREATER
113293: IFFALSE 113305
// k := 5 else
113295: LD_ADDR_VAR 0 2
113299: PUSH
113300: LD_INT 5
113302: ST_TO_ADDR
113303: GO 113315
// k := tmp ;
113305: LD_ADDR_VAR 0 2
113309: PUSH
113310: LD_VAR 0 3
113314: ST_TO_ADDR
// for i := 1 to k do
113315: LD_ADDR_VAR 0 1
113319: PUSH
113320: DOUBLE
113321: LD_INT 1
113323: DEC
113324: ST_TO_ADDR
113325: LD_VAR 0 2
113329: PUSH
113330: FOR_TO
113331: IFFALSE 113430
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
113333: LD_VAR 0 3
113337: PUSH
113338: LD_VAR 0 1
113342: ARRAY
113343: PPUSH
113344: LD_VAR 0 1
113348: PUSH
113349: LD_INT 4
113351: MOD
113352: PUSH
113353: LD_INT 1
113355: PLUS
113356: PPUSH
113357: CALL_OW 259
113361: PUSH
113362: LD_INT 10
113364: LESS
113365: IFFALSE 113428
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
113367: LD_VAR 0 3
113371: PUSH
113372: LD_VAR 0 1
113376: ARRAY
113377: PPUSH
113378: LD_VAR 0 1
113382: PUSH
113383: LD_INT 4
113385: MOD
113386: PUSH
113387: LD_INT 1
113389: PLUS
113390: PPUSH
113391: LD_VAR 0 3
113395: PUSH
113396: LD_VAR 0 1
113400: ARRAY
113401: PPUSH
113402: LD_VAR 0 1
113406: PUSH
113407: LD_INT 4
113409: MOD
113410: PUSH
113411: LD_INT 1
113413: PLUS
113414: PPUSH
113415: CALL_OW 259
113419: PUSH
113420: LD_INT 1
113422: PLUS
113423: PPUSH
113424: CALL_OW 237
113428: GO 113330
113430: POP
113431: POP
// end ;
113432: PPOPN 3
113434: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
113435: LD_EXP 145
113439: PUSH
113440: LD_EXP 153
113444: AND
113445: IFFALSE 113465
113447: GO 113449
113449: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
113450: LD_INT 4
113452: PPUSH
113453: LD_OWVAR 2
113457: PPUSH
113458: LD_INT 0
113460: PPUSH
113461: CALL_OW 324
113465: END
// every 0 0$1 trigger StreamModeActive and sShovel do
113466: LD_EXP 145
113470: PUSH
113471: LD_EXP 182
113475: AND
113476: IFFALSE 113496
113478: GO 113480
113480: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
113481: LD_INT 19
113483: PPUSH
113484: LD_OWVAR 2
113488: PPUSH
113489: LD_INT 0
113491: PPUSH
113492: CALL_OW 324
113496: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
113497: LD_EXP 145
113501: PUSH
113502: LD_EXP 154
113506: AND
113507: IFFALSE 113609
113509: GO 113511
113511: DISABLE
113512: LD_INT 0
113514: PPUSH
113515: PPUSH
// begin enable ;
113516: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
113517: LD_ADDR_VAR 0 2
113521: PUSH
113522: LD_INT 22
113524: PUSH
113525: LD_OWVAR 2
113529: PUSH
113530: EMPTY
113531: LIST
113532: LIST
113533: PUSH
113534: LD_INT 2
113536: PUSH
113537: LD_INT 34
113539: PUSH
113540: LD_INT 11
113542: PUSH
113543: EMPTY
113544: LIST
113545: LIST
113546: PUSH
113547: LD_INT 34
113549: PUSH
113550: LD_INT 30
113552: PUSH
113553: EMPTY
113554: LIST
113555: LIST
113556: PUSH
113557: EMPTY
113558: LIST
113559: LIST
113560: LIST
113561: PUSH
113562: EMPTY
113563: LIST
113564: LIST
113565: PPUSH
113566: CALL_OW 69
113570: ST_TO_ADDR
// if not tmp then
113571: LD_VAR 0 2
113575: NOT
113576: IFFALSE 113580
// exit ;
113578: GO 113609
// for i in tmp do
113580: LD_ADDR_VAR 0 1
113584: PUSH
113585: LD_VAR 0 2
113589: PUSH
113590: FOR_IN
113591: IFFALSE 113607
// begin SetLives ( i , 0 ) ;
113593: LD_VAR 0 1
113597: PPUSH
113598: LD_INT 0
113600: PPUSH
113601: CALL_OW 234
// end ;
113605: GO 113590
113607: POP
113608: POP
// end ;
113609: PPOPN 2
113611: END
// every 0 0$1 trigger StreamModeActive and sBunker do
113612: LD_EXP 145
113616: PUSH
113617: LD_EXP 155
113621: AND
113622: IFFALSE 113642
113624: GO 113626
113626: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
113627: LD_INT 32
113629: PPUSH
113630: LD_OWVAR 2
113634: PPUSH
113635: LD_INT 0
113637: PPUSH
113638: CALL_OW 324
113642: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
113643: LD_EXP 145
113647: PUSH
113648: LD_EXP 156
113652: AND
113653: IFFALSE 113834
113655: GO 113657
113657: DISABLE
113658: LD_INT 0
113660: PPUSH
113661: PPUSH
113662: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
113663: LD_ADDR_VAR 0 2
113667: PUSH
113668: LD_INT 22
113670: PUSH
113671: LD_OWVAR 2
113675: PUSH
113676: EMPTY
113677: LIST
113678: LIST
113679: PUSH
113680: LD_INT 33
113682: PUSH
113683: LD_INT 3
113685: PUSH
113686: EMPTY
113687: LIST
113688: LIST
113689: PUSH
113690: EMPTY
113691: LIST
113692: LIST
113693: PPUSH
113694: CALL_OW 69
113698: ST_TO_ADDR
// if not tmp then
113699: LD_VAR 0 2
113703: NOT
113704: IFFALSE 113708
// exit ;
113706: GO 113834
// side := 0 ;
113708: LD_ADDR_VAR 0 3
113712: PUSH
113713: LD_INT 0
113715: ST_TO_ADDR
// for i := 1 to 8 do
113716: LD_ADDR_VAR 0 1
113720: PUSH
113721: DOUBLE
113722: LD_INT 1
113724: DEC
113725: ST_TO_ADDR
113726: LD_INT 8
113728: PUSH
113729: FOR_TO
113730: IFFALSE 113778
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
113732: LD_OWVAR 2
113736: PUSH
113737: LD_VAR 0 1
113741: NONEQUAL
113742: PUSH
113743: LD_OWVAR 2
113747: PPUSH
113748: LD_VAR 0 1
113752: PPUSH
113753: CALL_OW 81
113757: PUSH
113758: LD_INT 2
113760: EQUAL
113761: AND
113762: IFFALSE 113776
// begin side := i ;
113764: LD_ADDR_VAR 0 3
113768: PUSH
113769: LD_VAR 0 1
113773: ST_TO_ADDR
// break ;
113774: GO 113778
// end ;
113776: GO 113729
113778: POP
113779: POP
// if not side then
113780: LD_VAR 0 3
113784: NOT
113785: IFFALSE 113789
// exit ;
113787: GO 113834
// for i := 1 to tmp do
113789: LD_ADDR_VAR 0 1
113793: PUSH
113794: DOUBLE
113795: LD_INT 1
113797: DEC
113798: ST_TO_ADDR
113799: LD_VAR 0 2
113803: PUSH
113804: FOR_TO
113805: IFFALSE 113832
// if Prob ( 60 ) then
113807: LD_INT 60
113809: PPUSH
113810: CALL_OW 13
113814: IFFALSE 113830
// SetSide ( i , side ) ;
113816: LD_VAR 0 1
113820: PPUSH
113821: LD_VAR 0 3
113825: PPUSH
113826: CALL_OW 235
113830: GO 113804
113832: POP
113833: POP
// end ;
113834: PPOPN 3
113836: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
113837: LD_EXP 145
113841: PUSH
113842: LD_EXP 158
113846: AND
113847: IFFALSE 113966
113849: GO 113851
113851: DISABLE
113852: LD_INT 0
113854: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
113855: LD_ADDR_VAR 0 1
113859: PUSH
113860: LD_INT 22
113862: PUSH
113863: LD_OWVAR 2
113867: PUSH
113868: EMPTY
113869: LIST
113870: LIST
113871: PUSH
113872: LD_INT 21
113874: PUSH
113875: LD_INT 1
113877: PUSH
113878: EMPTY
113879: LIST
113880: LIST
113881: PUSH
113882: LD_INT 3
113884: PUSH
113885: LD_INT 23
113887: PUSH
113888: LD_INT 0
113890: PUSH
113891: EMPTY
113892: LIST
113893: LIST
113894: PUSH
113895: EMPTY
113896: LIST
113897: LIST
113898: PUSH
113899: EMPTY
113900: LIST
113901: LIST
113902: LIST
113903: PPUSH
113904: CALL_OW 69
113908: PUSH
113909: FOR_IN
113910: IFFALSE 113964
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
113912: LD_VAR 0 1
113916: PPUSH
113917: CALL_OW 257
113921: PUSH
113922: LD_INT 1
113924: PUSH
113925: LD_INT 2
113927: PUSH
113928: LD_INT 3
113930: PUSH
113931: LD_INT 4
113933: PUSH
113934: EMPTY
113935: LIST
113936: LIST
113937: LIST
113938: LIST
113939: IN
113940: IFFALSE 113962
// SetClass ( un , rand ( 1 , 4 ) ) ;
113942: LD_VAR 0 1
113946: PPUSH
113947: LD_INT 1
113949: PPUSH
113950: LD_INT 4
113952: PPUSH
113953: CALL_OW 12
113957: PPUSH
113958: CALL_OW 336
113962: GO 113909
113964: POP
113965: POP
// end ;
113966: PPOPN 1
113968: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
113969: LD_EXP 145
113973: PUSH
113974: LD_EXP 157
113978: AND
113979: IFFALSE 114058
113981: GO 113983
113983: DISABLE
113984: LD_INT 0
113986: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
113987: LD_ADDR_VAR 0 1
113991: PUSH
113992: LD_INT 22
113994: PUSH
113995: LD_OWVAR 2
113999: PUSH
114000: EMPTY
114001: LIST
114002: LIST
114003: PUSH
114004: LD_INT 21
114006: PUSH
114007: LD_INT 3
114009: PUSH
114010: EMPTY
114011: LIST
114012: LIST
114013: PUSH
114014: EMPTY
114015: LIST
114016: LIST
114017: PPUSH
114018: CALL_OW 69
114022: ST_TO_ADDR
// if not tmp then
114023: LD_VAR 0 1
114027: NOT
114028: IFFALSE 114032
// exit ;
114030: GO 114058
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
114032: LD_VAR 0 1
114036: PUSH
114037: LD_INT 1
114039: PPUSH
114040: LD_VAR 0 1
114044: PPUSH
114045: CALL_OW 12
114049: ARRAY
114050: PPUSH
114051: LD_INT 100
114053: PPUSH
114054: CALL_OW 234
// end ;
114058: PPOPN 1
114060: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
114061: LD_EXP 145
114065: PUSH
114066: LD_EXP 159
114070: AND
114071: IFFALSE 114169
114073: GO 114075
114075: DISABLE
114076: LD_INT 0
114078: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
114079: LD_ADDR_VAR 0 1
114083: PUSH
114084: LD_INT 22
114086: PUSH
114087: LD_OWVAR 2
114091: PUSH
114092: EMPTY
114093: LIST
114094: LIST
114095: PUSH
114096: LD_INT 21
114098: PUSH
114099: LD_INT 1
114101: PUSH
114102: EMPTY
114103: LIST
114104: LIST
114105: PUSH
114106: EMPTY
114107: LIST
114108: LIST
114109: PPUSH
114110: CALL_OW 69
114114: ST_TO_ADDR
// if not tmp then
114115: LD_VAR 0 1
114119: NOT
114120: IFFALSE 114124
// exit ;
114122: GO 114169
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
114124: LD_VAR 0 1
114128: PUSH
114129: LD_INT 1
114131: PPUSH
114132: LD_VAR 0 1
114136: PPUSH
114137: CALL_OW 12
114141: ARRAY
114142: PPUSH
114143: LD_INT 1
114145: PPUSH
114146: LD_INT 4
114148: PPUSH
114149: CALL_OW 12
114153: PPUSH
114154: LD_INT 3000
114156: PPUSH
114157: LD_INT 9000
114159: PPUSH
114160: CALL_OW 12
114164: PPUSH
114165: CALL_OW 492
// end ;
114169: PPOPN 1
114171: END
// every 0 0$1 trigger StreamModeActive and sDepot do
114172: LD_EXP 145
114176: PUSH
114177: LD_EXP 160
114181: AND
114182: IFFALSE 114202
114184: GO 114186
114186: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
114187: LD_INT 1
114189: PPUSH
114190: LD_OWVAR 2
114194: PPUSH
114195: LD_INT 0
114197: PPUSH
114198: CALL_OW 324
114202: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
114203: LD_EXP 145
114207: PUSH
114208: LD_EXP 161
114212: AND
114213: IFFALSE 114296
114215: GO 114217
114217: DISABLE
114218: LD_INT 0
114220: PPUSH
114221: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
114222: LD_ADDR_VAR 0 2
114226: PUSH
114227: LD_INT 22
114229: PUSH
114230: LD_OWVAR 2
114234: PUSH
114235: EMPTY
114236: LIST
114237: LIST
114238: PUSH
114239: LD_INT 21
114241: PUSH
114242: LD_INT 3
114244: PUSH
114245: EMPTY
114246: LIST
114247: LIST
114248: PUSH
114249: EMPTY
114250: LIST
114251: LIST
114252: PPUSH
114253: CALL_OW 69
114257: ST_TO_ADDR
// if not tmp then
114258: LD_VAR 0 2
114262: NOT
114263: IFFALSE 114267
// exit ;
114265: GO 114296
// for i in tmp do
114267: LD_ADDR_VAR 0 1
114271: PUSH
114272: LD_VAR 0 2
114276: PUSH
114277: FOR_IN
114278: IFFALSE 114294
// SetBLevel ( i , 10 ) ;
114280: LD_VAR 0 1
114284: PPUSH
114285: LD_INT 10
114287: PPUSH
114288: CALL_OW 241
114292: GO 114277
114294: POP
114295: POP
// end ;
114296: PPOPN 2
114298: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
114299: LD_EXP 145
114303: PUSH
114304: LD_EXP 162
114308: AND
114309: IFFALSE 114420
114311: GO 114313
114313: DISABLE
114314: LD_INT 0
114316: PPUSH
114317: PPUSH
114318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
114319: LD_ADDR_VAR 0 3
114323: PUSH
114324: LD_INT 22
114326: PUSH
114327: LD_OWVAR 2
114331: PUSH
114332: EMPTY
114333: LIST
114334: LIST
114335: PUSH
114336: LD_INT 25
114338: PUSH
114339: LD_INT 1
114341: PUSH
114342: EMPTY
114343: LIST
114344: LIST
114345: PUSH
114346: EMPTY
114347: LIST
114348: LIST
114349: PPUSH
114350: CALL_OW 69
114354: ST_TO_ADDR
// if not tmp then
114355: LD_VAR 0 3
114359: NOT
114360: IFFALSE 114364
// exit ;
114362: GO 114420
// un := tmp [ rand ( 1 , tmp ) ] ;
114364: LD_ADDR_VAR 0 2
114368: PUSH
114369: LD_VAR 0 3
114373: PUSH
114374: LD_INT 1
114376: PPUSH
114377: LD_VAR 0 3
114381: PPUSH
114382: CALL_OW 12
114386: ARRAY
114387: ST_TO_ADDR
// if Crawls ( un ) then
114388: LD_VAR 0 2
114392: PPUSH
114393: CALL_OW 318
114397: IFFALSE 114408
// ComWalk ( un ) ;
114399: LD_VAR 0 2
114403: PPUSH
114404: CALL_OW 138
// SetClass ( un , class_sniper ) ;
114408: LD_VAR 0 2
114412: PPUSH
114413: LD_INT 5
114415: PPUSH
114416: CALL_OW 336
// end ;
114420: PPOPN 3
114422: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
114423: LD_EXP 145
114427: PUSH
114428: LD_EXP 163
114432: AND
114433: PUSH
114434: LD_OWVAR 67
114438: PUSH
114439: LD_INT 3
114441: LESS
114442: AND
114443: IFFALSE 114462
114445: GO 114447
114447: DISABLE
// Difficulty := Difficulty + 1 ;
114448: LD_ADDR_OWVAR 67
114452: PUSH
114453: LD_OWVAR 67
114457: PUSH
114458: LD_INT 1
114460: PLUS
114461: ST_TO_ADDR
114462: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
114463: LD_EXP 145
114467: PUSH
114468: LD_EXP 164
114472: AND
114473: IFFALSE 114576
114475: GO 114477
114477: DISABLE
114478: LD_INT 0
114480: PPUSH
// begin for i := 1 to 5 do
114481: LD_ADDR_VAR 0 1
114485: PUSH
114486: DOUBLE
114487: LD_INT 1
114489: DEC
114490: ST_TO_ADDR
114491: LD_INT 5
114493: PUSH
114494: FOR_TO
114495: IFFALSE 114574
// begin uc_nation := nation_nature ;
114497: LD_ADDR_OWVAR 21
114501: PUSH
114502: LD_INT 0
114504: ST_TO_ADDR
// uc_side := 0 ;
114505: LD_ADDR_OWVAR 20
114509: PUSH
114510: LD_INT 0
114512: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
114513: LD_ADDR_OWVAR 29
114517: PUSH
114518: LD_INT 12
114520: PUSH
114521: LD_INT 12
114523: PUSH
114524: EMPTY
114525: LIST
114526: LIST
114527: ST_TO_ADDR
// hc_agressivity := 20 ;
114528: LD_ADDR_OWVAR 35
114532: PUSH
114533: LD_INT 20
114535: ST_TO_ADDR
// hc_class := class_tiger ;
114536: LD_ADDR_OWVAR 28
114540: PUSH
114541: LD_INT 14
114543: ST_TO_ADDR
// hc_gallery :=  ;
114544: LD_ADDR_OWVAR 33
114548: PUSH
114549: LD_STRING 
114551: ST_TO_ADDR
// hc_name :=  ;
114552: LD_ADDR_OWVAR 26
114556: PUSH
114557: LD_STRING 
114559: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
114560: CALL_OW 44
114564: PPUSH
114565: LD_INT 0
114567: PPUSH
114568: CALL_OW 51
// end ;
114572: GO 114494
114574: POP
114575: POP
// end ;
114576: PPOPN 1
114578: END
// every 0 0$1 trigger StreamModeActive and sBomb do
114579: LD_EXP 145
114583: PUSH
114584: LD_EXP 165
114588: AND
114589: IFFALSE 114598
114591: GO 114593
114593: DISABLE
// StreamSibBomb ;
114594: CALL 114599 0 0
114598: END
// export function StreamSibBomb ; var i , x , y ; begin
114599: LD_INT 0
114601: PPUSH
114602: PPUSH
114603: PPUSH
114604: PPUSH
// result := false ;
114605: LD_ADDR_VAR 0 1
114609: PUSH
114610: LD_INT 0
114612: ST_TO_ADDR
// for i := 1 to 16 do
114613: LD_ADDR_VAR 0 2
114617: PUSH
114618: DOUBLE
114619: LD_INT 1
114621: DEC
114622: ST_TO_ADDR
114623: LD_INT 16
114625: PUSH
114626: FOR_TO
114627: IFFALSE 114826
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114629: LD_ADDR_VAR 0 3
114633: PUSH
114634: LD_INT 10
114636: PUSH
114637: LD_INT 20
114639: PUSH
114640: LD_INT 30
114642: PUSH
114643: LD_INT 40
114645: PUSH
114646: LD_INT 50
114648: PUSH
114649: LD_INT 60
114651: PUSH
114652: LD_INT 70
114654: PUSH
114655: LD_INT 80
114657: PUSH
114658: LD_INT 90
114660: PUSH
114661: LD_INT 100
114663: PUSH
114664: LD_INT 110
114666: PUSH
114667: LD_INT 120
114669: PUSH
114670: LD_INT 130
114672: PUSH
114673: LD_INT 140
114675: PUSH
114676: LD_INT 150
114678: PUSH
114679: EMPTY
114680: LIST
114681: LIST
114682: LIST
114683: LIST
114684: LIST
114685: LIST
114686: LIST
114687: LIST
114688: LIST
114689: LIST
114690: LIST
114691: LIST
114692: LIST
114693: LIST
114694: LIST
114695: PUSH
114696: LD_INT 1
114698: PPUSH
114699: LD_INT 15
114701: PPUSH
114702: CALL_OW 12
114706: ARRAY
114707: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
114708: LD_ADDR_VAR 0 4
114712: PUSH
114713: LD_INT 10
114715: PUSH
114716: LD_INT 20
114718: PUSH
114719: LD_INT 30
114721: PUSH
114722: LD_INT 40
114724: PUSH
114725: LD_INT 50
114727: PUSH
114728: LD_INT 60
114730: PUSH
114731: LD_INT 70
114733: PUSH
114734: LD_INT 80
114736: PUSH
114737: LD_INT 90
114739: PUSH
114740: LD_INT 100
114742: PUSH
114743: LD_INT 110
114745: PUSH
114746: LD_INT 120
114748: PUSH
114749: LD_INT 130
114751: PUSH
114752: LD_INT 140
114754: PUSH
114755: LD_INT 150
114757: PUSH
114758: EMPTY
114759: LIST
114760: LIST
114761: LIST
114762: LIST
114763: LIST
114764: LIST
114765: LIST
114766: LIST
114767: LIST
114768: LIST
114769: LIST
114770: LIST
114771: LIST
114772: LIST
114773: LIST
114774: PUSH
114775: LD_INT 1
114777: PPUSH
114778: LD_INT 15
114780: PPUSH
114781: CALL_OW 12
114785: ARRAY
114786: ST_TO_ADDR
// if ValidHex ( x , y ) then
114787: LD_VAR 0 3
114791: PPUSH
114792: LD_VAR 0 4
114796: PPUSH
114797: CALL_OW 488
114801: IFFALSE 114824
// begin result := [ x , y ] ;
114803: LD_ADDR_VAR 0 1
114807: PUSH
114808: LD_VAR 0 3
114812: PUSH
114813: LD_VAR 0 4
114817: PUSH
114818: EMPTY
114819: LIST
114820: LIST
114821: ST_TO_ADDR
// break ;
114822: GO 114826
// end ; end ;
114824: GO 114626
114826: POP
114827: POP
// if result then
114828: LD_VAR 0 1
114832: IFFALSE 114892
// begin ToLua ( playSibBomb() ) ;
114834: LD_STRING playSibBomb()
114836: PPUSH
114837: CALL_OW 559
// wait ( 0 0$14 ) ;
114841: LD_INT 490
114843: PPUSH
114844: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
114848: LD_VAR 0 1
114852: PUSH
114853: LD_INT 1
114855: ARRAY
114856: PPUSH
114857: LD_VAR 0 1
114861: PUSH
114862: LD_INT 2
114864: ARRAY
114865: PPUSH
114866: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
114870: LD_VAR 0 1
114874: PUSH
114875: LD_INT 1
114877: ARRAY
114878: PPUSH
114879: LD_VAR 0 1
114883: PUSH
114884: LD_INT 2
114886: ARRAY
114887: PPUSH
114888: CALL_OW 429
// end ; end ;
114892: LD_VAR 0 1
114896: RET
// every 0 0$1 trigger StreamModeActive and sReset do
114897: LD_EXP 145
114901: PUSH
114902: LD_EXP 167
114906: AND
114907: IFFALSE 114919
114909: GO 114911
114911: DISABLE
// YouLost (  ) ;
114912: LD_STRING 
114914: PPUSH
114915: CALL_OW 104
114919: END
// every 0 0$1 trigger StreamModeActive and sFog do
114920: LD_EXP 145
114924: PUSH
114925: LD_EXP 166
114929: AND
114930: IFFALSE 114944
114932: GO 114934
114934: DISABLE
// FogOff ( your_side ) ;
114935: LD_OWVAR 2
114939: PPUSH
114940: CALL_OW 344
114944: END
// every 0 0$1 trigger StreamModeActive and sSun do
114945: LD_EXP 145
114949: PUSH
114950: LD_EXP 168
114954: AND
114955: IFFALSE 114983
114957: GO 114959
114959: DISABLE
// begin solar_recharge_percent := 0 ;
114960: LD_ADDR_OWVAR 79
114964: PUSH
114965: LD_INT 0
114967: ST_TO_ADDR
// wait ( 5 5$00 ) ;
114968: LD_INT 10500
114970: PPUSH
114971: CALL_OW 67
// solar_recharge_percent := 100 ;
114975: LD_ADDR_OWVAR 79
114979: PUSH
114980: LD_INT 100
114982: ST_TO_ADDR
// end ;
114983: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
114984: LD_EXP 145
114988: PUSH
114989: LD_EXP 169
114993: AND
114994: IFFALSE 115233
114996: GO 114998
114998: DISABLE
114999: LD_INT 0
115001: PPUSH
115002: PPUSH
115003: PPUSH
// begin tmp := [ ] ;
115004: LD_ADDR_VAR 0 3
115008: PUSH
115009: EMPTY
115010: ST_TO_ADDR
// for i := 1 to 6 do
115011: LD_ADDR_VAR 0 1
115015: PUSH
115016: DOUBLE
115017: LD_INT 1
115019: DEC
115020: ST_TO_ADDR
115021: LD_INT 6
115023: PUSH
115024: FOR_TO
115025: IFFALSE 115130
// begin uc_nation := nation_nature ;
115027: LD_ADDR_OWVAR 21
115031: PUSH
115032: LD_INT 0
115034: ST_TO_ADDR
// uc_side := 0 ;
115035: LD_ADDR_OWVAR 20
115039: PUSH
115040: LD_INT 0
115042: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
115043: LD_ADDR_OWVAR 29
115047: PUSH
115048: LD_INT 12
115050: PUSH
115051: LD_INT 12
115053: PUSH
115054: EMPTY
115055: LIST
115056: LIST
115057: ST_TO_ADDR
// hc_agressivity := 20 ;
115058: LD_ADDR_OWVAR 35
115062: PUSH
115063: LD_INT 20
115065: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
115066: LD_ADDR_OWVAR 28
115070: PUSH
115071: LD_INT 17
115073: ST_TO_ADDR
// hc_gallery :=  ;
115074: LD_ADDR_OWVAR 33
115078: PUSH
115079: LD_STRING 
115081: ST_TO_ADDR
// hc_name :=  ;
115082: LD_ADDR_OWVAR 26
115086: PUSH
115087: LD_STRING 
115089: ST_TO_ADDR
// un := CreateHuman ;
115090: LD_ADDR_VAR 0 2
115094: PUSH
115095: CALL_OW 44
115099: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
115100: LD_VAR 0 2
115104: PPUSH
115105: LD_INT 1
115107: PPUSH
115108: CALL_OW 51
// tmp := tmp ^ un ;
115112: LD_ADDR_VAR 0 3
115116: PUSH
115117: LD_VAR 0 3
115121: PUSH
115122: LD_VAR 0 2
115126: ADD
115127: ST_TO_ADDR
// end ;
115128: GO 115024
115130: POP
115131: POP
// repeat wait ( 0 0$1 ) ;
115132: LD_INT 35
115134: PPUSH
115135: CALL_OW 67
// for un in tmp do
115139: LD_ADDR_VAR 0 2
115143: PUSH
115144: LD_VAR 0 3
115148: PUSH
115149: FOR_IN
115150: IFFALSE 115224
// begin if IsDead ( un ) then
115152: LD_VAR 0 2
115156: PPUSH
115157: CALL_OW 301
115161: IFFALSE 115181
// begin tmp := tmp diff un ;
115163: LD_ADDR_VAR 0 3
115167: PUSH
115168: LD_VAR 0 3
115172: PUSH
115173: LD_VAR 0 2
115177: DIFF
115178: ST_TO_ADDR
// continue ;
115179: GO 115149
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
115181: LD_VAR 0 2
115185: PPUSH
115186: LD_INT 3
115188: PUSH
115189: LD_INT 22
115191: PUSH
115192: LD_INT 0
115194: PUSH
115195: EMPTY
115196: LIST
115197: LIST
115198: PUSH
115199: EMPTY
115200: LIST
115201: LIST
115202: PPUSH
115203: CALL_OW 69
115207: PPUSH
115208: LD_VAR 0 2
115212: PPUSH
115213: CALL_OW 74
115217: PPUSH
115218: CALL_OW 115
// end ;
115222: GO 115149
115224: POP
115225: POP
// until not tmp ;
115226: LD_VAR 0 3
115230: NOT
115231: IFFALSE 115132
// end ;
115233: PPOPN 3
115235: END
// every 0 0$1 trigger StreamModeActive and sTroll do
115236: LD_EXP 145
115240: PUSH
115241: LD_EXP 170
115245: AND
115246: IFFALSE 115300
115248: GO 115250
115250: DISABLE
// begin ToLua ( displayTroll(); ) ;
115251: LD_STRING displayTroll();
115253: PPUSH
115254: CALL_OW 559
// wait ( 3 3$00 ) ;
115258: LD_INT 6300
115260: PPUSH
115261: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115265: LD_STRING hideTroll();
115267: PPUSH
115268: CALL_OW 559
// wait ( 1 1$00 ) ;
115272: LD_INT 2100
115274: PPUSH
115275: CALL_OW 67
// ToLua ( displayTroll(); ) ;
115279: LD_STRING displayTroll();
115281: PPUSH
115282: CALL_OW 559
// wait ( 1 1$00 ) ;
115286: LD_INT 2100
115288: PPUSH
115289: CALL_OW 67
// ToLua ( hideTroll(); ) ;
115293: LD_STRING hideTroll();
115295: PPUSH
115296: CALL_OW 559
// end ;
115300: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
115301: LD_EXP 145
115305: PUSH
115306: LD_EXP 171
115310: AND
115311: IFFALSE 115374
115313: GO 115315
115315: DISABLE
115316: LD_INT 0
115318: PPUSH
// begin p := 0 ;
115319: LD_ADDR_VAR 0 1
115323: PUSH
115324: LD_INT 0
115326: ST_TO_ADDR
// repeat game_speed := 1 ;
115327: LD_ADDR_OWVAR 65
115331: PUSH
115332: LD_INT 1
115334: ST_TO_ADDR
// wait ( 0 0$1 ) ;
115335: LD_INT 35
115337: PPUSH
115338: CALL_OW 67
// p := p + 1 ;
115342: LD_ADDR_VAR 0 1
115346: PUSH
115347: LD_VAR 0 1
115351: PUSH
115352: LD_INT 1
115354: PLUS
115355: ST_TO_ADDR
// until p >= 60 ;
115356: LD_VAR 0 1
115360: PUSH
115361: LD_INT 60
115363: GREATEREQUAL
115364: IFFALSE 115327
// game_speed := 4 ;
115366: LD_ADDR_OWVAR 65
115370: PUSH
115371: LD_INT 4
115373: ST_TO_ADDR
// end ;
115374: PPOPN 1
115376: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
115377: LD_EXP 145
115381: PUSH
115382: LD_EXP 172
115386: AND
115387: IFFALSE 115533
115389: GO 115391
115391: DISABLE
115392: LD_INT 0
115394: PPUSH
115395: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
115396: LD_ADDR_VAR 0 1
115400: PUSH
115401: LD_INT 22
115403: PUSH
115404: LD_OWVAR 2
115408: PUSH
115409: EMPTY
115410: LIST
115411: LIST
115412: PUSH
115413: LD_INT 2
115415: PUSH
115416: LD_INT 30
115418: PUSH
115419: LD_INT 0
115421: PUSH
115422: EMPTY
115423: LIST
115424: LIST
115425: PUSH
115426: LD_INT 30
115428: PUSH
115429: LD_INT 1
115431: PUSH
115432: EMPTY
115433: LIST
115434: LIST
115435: PUSH
115436: EMPTY
115437: LIST
115438: LIST
115439: LIST
115440: PUSH
115441: EMPTY
115442: LIST
115443: LIST
115444: PPUSH
115445: CALL_OW 69
115449: ST_TO_ADDR
// if not depot then
115450: LD_VAR 0 1
115454: NOT
115455: IFFALSE 115459
// exit ;
115457: GO 115533
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
115459: LD_ADDR_VAR 0 2
115463: PUSH
115464: LD_VAR 0 1
115468: PUSH
115469: LD_INT 1
115471: PPUSH
115472: LD_VAR 0 1
115476: PPUSH
115477: CALL_OW 12
115481: ARRAY
115482: PPUSH
115483: CALL_OW 274
115487: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
115488: LD_VAR 0 2
115492: PPUSH
115493: LD_INT 1
115495: PPUSH
115496: LD_INT 0
115498: PPUSH
115499: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
115503: LD_VAR 0 2
115507: PPUSH
115508: LD_INT 2
115510: PPUSH
115511: LD_INT 0
115513: PPUSH
115514: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
115518: LD_VAR 0 2
115522: PPUSH
115523: LD_INT 3
115525: PPUSH
115526: LD_INT 0
115528: PPUSH
115529: CALL_OW 277
// end ;
115533: PPOPN 2
115535: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
115536: LD_EXP 145
115540: PUSH
115541: LD_EXP 173
115545: AND
115546: IFFALSE 115643
115548: GO 115550
115550: DISABLE
115551: LD_INT 0
115553: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
115554: LD_ADDR_VAR 0 1
115558: PUSH
115559: LD_INT 22
115561: PUSH
115562: LD_OWVAR 2
115566: PUSH
115567: EMPTY
115568: LIST
115569: LIST
115570: PUSH
115571: LD_INT 21
115573: PUSH
115574: LD_INT 1
115576: PUSH
115577: EMPTY
115578: LIST
115579: LIST
115580: PUSH
115581: LD_INT 3
115583: PUSH
115584: LD_INT 23
115586: PUSH
115587: LD_INT 0
115589: PUSH
115590: EMPTY
115591: LIST
115592: LIST
115593: PUSH
115594: EMPTY
115595: LIST
115596: LIST
115597: PUSH
115598: EMPTY
115599: LIST
115600: LIST
115601: LIST
115602: PPUSH
115603: CALL_OW 69
115607: ST_TO_ADDR
// if not tmp then
115608: LD_VAR 0 1
115612: NOT
115613: IFFALSE 115617
// exit ;
115615: GO 115643
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
115617: LD_VAR 0 1
115621: PUSH
115622: LD_INT 1
115624: PPUSH
115625: LD_VAR 0 1
115629: PPUSH
115630: CALL_OW 12
115634: ARRAY
115635: PPUSH
115636: LD_INT 200
115638: PPUSH
115639: CALL_OW 234
// end ;
115643: PPOPN 1
115645: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
115646: LD_EXP 145
115650: PUSH
115651: LD_EXP 174
115655: AND
115656: IFFALSE 115735
115658: GO 115660
115660: DISABLE
115661: LD_INT 0
115663: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
115664: LD_ADDR_VAR 0 1
115668: PUSH
115669: LD_INT 22
115671: PUSH
115672: LD_OWVAR 2
115676: PUSH
115677: EMPTY
115678: LIST
115679: LIST
115680: PUSH
115681: LD_INT 21
115683: PUSH
115684: LD_INT 2
115686: PUSH
115687: EMPTY
115688: LIST
115689: LIST
115690: PUSH
115691: EMPTY
115692: LIST
115693: LIST
115694: PPUSH
115695: CALL_OW 69
115699: ST_TO_ADDR
// if not tmp then
115700: LD_VAR 0 1
115704: NOT
115705: IFFALSE 115709
// exit ;
115707: GO 115735
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
115709: LD_VAR 0 1
115713: PUSH
115714: LD_INT 1
115716: PPUSH
115717: LD_VAR 0 1
115721: PPUSH
115722: CALL_OW 12
115726: ARRAY
115727: PPUSH
115728: LD_INT 60
115730: PPUSH
115731: CALL_OW 234
// end ;
115735: PPOPN 1
115737: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
115738: LD_EXP 145
115742: PUSH
115743: LD_EXP 175
115747: AND
115748: IFFALSE 115847
115750: GO 115752
115752: DISABLE
115753: LD_INT 0
115755: PPUSH
115756: PPUSH
// begin enable ;
115757: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
115758: LD_ADDR_VAR 0 1
115762: PUSH
115763: LD_INT 22
115765: PUSH
115766: LD_OWVAR 2
115770: PUSH
115771: EMPTY
115772: LIST
115773: LIST
115774: PUSH
115775: LD_INT 61
115777: PUSH
115778: EMPTY
115779: LIST
115780: PUSH
115781: LD_INT 33
115783: PUSH
115784: LD_INT 2
115786: PUSH
115787: EMPTY
115788: LIST
115789: LIST
115790: PUSH
115791: EMPTY
115792: LIST
115793: LIST
115794: LIST
115795: PPUSH
115796: CALL_OW 69
115800: ST_TO_ADDR
// if not tmp then
115801: LD_VAR 0 1
115805: NOT
115806: IFFALSE 115810
// exit ;
115808: GO 115847
// for i in tmp do
115810: LD_ADDR_VAR 0 2
115814: PUSH
115815: LD_VAR 0 1
115819: PUSH
115820: FOR_IN
115821: IFFALSE 115845
// if IsControledBy ( i ) then
115823: LD_VAR 0 2
115827: PPUSH
115828: CALL_OW 312
115832: IFFALSE 115843
// ComUnlink ( i ) ;
115834: LD_VAR 0 2
115838: PPUSH
115839: CALL_OW 136
115843: GO 115820
115845: POP
115846: POP
// end ;
115847: PPOPN 2
115849: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
115850: LD_EXP 145
115854: PUSH
115855: LD_EXP 176
115859: AND
115860: IFFALSE 116000
115862: GO 115864
115864: DISABLE
115865: LD_INT 0
115867: PPUSH
115868: PPUSH
// begin ToLua ( displayPowell(); ) ;
115869: LD_STRING displayPowell();
115871: PPUSH
115872: CALL_OW 559
// uc_side := 0 ;
115876: LD_ADDR_OWVAR 20
115880: PUSH
115881: LD_INT 0
115883: ST_TO_ADDR
// uc_nation := 2 ;
115884: LD_ADDR_OWVAR 21
115888: PUSH
115889: LD_INT 2
115891: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
115892: LD_ADDR_OWVAR 37
115896: PUSH
115897: LD_INT 14
115899: ST_TO_ADDR
// vc_engine := engine_siberite ;
115900: LD_ADDR_OWVAR 39
115904: PUSH
115905: LD_INT 3
115907: ST_TO_ADDR
// vc_control := control_apeman ;
115908: LD_ADDR_OWVAR 38
115912: PUSH
115913: LD_INT 5
115915: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
115916: LD_ADDR_OWVAR 40
115920: PUSH
115921: LD_INT 29
115923: ST_TO_ADDR
// un := CreateVehicle ;
115924: LD_ADDR_VAR 0 2
115928: PUSH
115929: CALL_OW 45
115933: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
115934: LD_VAR 0 2
115938: PPUSH
115939: LD_INT 1
115941: PPUSH
115942: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
115946: LD_INT 35
115948: PPUSH
115949: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
115953: LD_VAR 0 2
115957: PPUSH
115958: LD_INT 22
115960: PUSH
115961: LD_OWVAR 2
115965: PUSH
115966: EMPTY
115967: LIST
115968: LIST
115969: PPUSH
115970: CALL_OW 69
115974: PPUSH
115975: LD_VAR 0 2
115979: PPUSH
115980: CALL_OW 74
115984: PPUSH
115985: CALL_OW 115
// until IsDead ( un ) ;
115989: LD_VAR 0 2
115993: PPUSH
115994: CALL_OW 301
115998: IFFALSE 115946
// end ;
116000: PPOPN 2
116002: END
// every 0 0$1 trigger StreamModeActive and sStu do
116003: LD_EXP 145
116007: PUSH
116008: LD_EXP 184
116012: AND
116013: IFFALSE 116029
116015: GO 116017
116017: DISABLE
// begin ToLua ( displayStucuk(); ) ;
116018: LD_STRING displayStucuk();
116020: PPUSH
116021: CALL_OW 559
// ResetFog ;
116025: CALL_OW 335
// end ;
116029: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
116030: LD_EXP 145
116034: PUSH
116035: LD_EXP 177
116039: AND
116040: IFFALSE 116181
116042: GO 116044
116044: DISABLE
116045: LD_INT 0
116047: PPUSH
116048: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116049: LD_ADDR_VAR 0 2
116053: PUSH
116054: LD_INT 22
116056: PUSH
116057: LD_OWVAR 2
116061: PUSH
116062: EMPTY
116063: LIST
116064: LIST
116065: PUSH
116066: LD_INT 21
116068: PUSH
116069: LD_INT 1
116071: PUSH
116072: EMPTY
116073: LIST
116074: LIST
116075: PUSH
116076: EMPTY
116077: LIST
116078: LIST
116079: PPUSH
116080: CALL_OW 69
116084: ST_TO_ADDR
// if not tmp then
116085: LD_VAR 0 2
116089: NOT
116090: IFFALSE 116094
// exit ;
116092: GO 116181
// un := tmp [ rand ( 1 , tmp ) ] ;
116094: LD_ADDR_VAR 0 1
116098: PUSH
116099: LD_VAR 0 2
116103: PUSH
116104: LD_INT 1
116106: PPUSH
116107: LD_VAR 0 2
116111: PPUSH
116112: CALL_OW 12
116116: ARRAY
116117: ST_TO_ADDR
// SetSide ( un , 0 ) ;
116118: LD_VAR 0 1
116122: PPUSH
116123: LD_INT 0
116125: PPUSH
116126: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
116130: LD_VAR 0 1
116134: PPUSH
116135: LD_OWVAR 3
116139: PUSH
116140: LD_VAR 0 1
116144: DIFF
116145: PPUSH
116146: LD_VAR 0 1
116150: PPUSH
116151: CALL_OW 74
116155: PPUSH
116156: CALL_OW 115
// wait ( 0 0$20 ) ;
116160: LD_INT 700
116162: PPUSH
116163: CALL_OW 67
// SetSide ( un , your_side ) ;
116167: LD_VAR 0 1
116171: PPUSH
116172: LD_OWVAR 2
116176: PPUSH
116177: CALL_OW 235
// end ;
116181: PPOPN 2
116183: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
116184: LD_EXP 145
116188: PUSH
116189: LD_EXP 178
116193: AND
116194: IFFALSE 116300
116196: GO 116198
116198: DISABLE
116199: LD_INT 0
116201: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
116202: LD_ADDR_VAR 0 1
116206: PUSH
116207: LD_INT 22
116209: PUSH
116210: LD_OWVAR 2
116214: PUSH
116215: EMPTY
116216: LIST
116217: LIST
116218: PUSH
116219: LD_INT 2
116221: PUSH
116222: LD_INT 30
116224: PUSH
116225: LD_INT 0
116227: PUSH
116228: EMPTY
116229: LIST
116230: LIST
116231: PUSH
116232: LD_INT 30
116234: PUSH
116235: LD_INT 1
116237: PUSH
116238: EMPTY
116239: LIST
116240: LIST
116241: PUSH
116242: EMPTY
116243: LIST
116244: LIST
116245: LIST
116246: PUSH
116247: EMPTY
116248: LIST
116249: LIST
116250: PPUSH
116251: CALL_OW 69
116255: ST_TO_ADDR
// if not depot then
116256: LD_VAR 0 1
116260: NOT
116261: IFFALSE 116265
// exit ;
116263: GO 116300
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
116265: LD_VAR 0 1
116269: PUSH
116270: LD_INT 1
116272: ARRAY
116273: PPUSH
116274: CALL_OW 250
116278: PPUSH
116279: LD_VAR 0 1
116283: PUSH
116284: LD_INT 1
116286: ARRAY
116287: PPUSH
116288: CALL_OW 251
116292: PPUSH
116293: LD_INT 70
116295: PPUSH
116296: CALL_OW 495
// end ;
116300: PPOPN 1
116302: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
116303: LD_EXP 145
116307: PUSH
116308: LD_EXP 179
116312: AND
116313: IFFALSE 116524
116315: GO 116317
116317: DISABLE
116318: LD_INT 0
116320: PPUSH
116321: PPUSH
116322: PPUSH
116323: PPUSH
116324: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
116325: LD_ADDR_VAR 0 5
116329: PUSH
116330: LD_INT 22
116332: PUSH
116333: LD_OWVAR 2
116337: PUSH
116338: EMPTY
116339: LIST
116340: LIST
116341: PUSH
116342: LD_INT 21
116344: PUSH
116345: LD_INT 1
116347: PUSH
116348: EMPTY
116349: LIST
116350: LIST
116351: PUSH
116352: EMPTY
116353: LIST
116354: LIST
116355: PPUSH
116356: CALL_OW 69
116360: ST_TO_ADDR
// if not tmp then
116361: LD_VAR 0 5
116365: NOT
116366: IFFALSE 116370
// exit ;
116368: GO 116524
// for i in tmp do
116370: LD_ADDR_VAR 0 1
116374: PUSH
116375: LD_VAR 0 5
116379: PUSH
116380: FOR_IN
116381: IFFALSE 116522
// begin d := rand ( 0 , 5 ) ;
116383: LD_ADDR_VAR 0 4
116387: PUSH
116388: LD_INT 0
116390: PPUSH
116391: LD_INT 5
116393: PPUSH
116394: CALL_OW 12
116398: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
116399: LD_ADDR_VAR 0 2
116403: PUSH
116404: LD_VAR 0 1
116408: PPUSH
116409: CALL_OW 250
116413: PPUSH
116414: LD_VAR 0 4
116418: PPUSH
116419: LD_INT 3
116421: PPUSH
116422: LD_INT 12
116424: PPUSH
116425: CALL_OW 12
116429: PPUSH
116430: CALL_OW 272
116434: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
116435: LD_ADDR_VAR 0 3
116439: PUSH
116440: LD_VAR 0 1
116444: PPUSH
116445: CALL_OW 251
116449: PPUSH
116450: LD_VAR 0 4
116454: PPUSH
116455: LD_INT 3
116457: PPUSH
116458: LD_INT 12
116460: PPUSH
116461: CALL_OW 12
116465: PPUSH
116466: CALL_OW 273
116470: ST_TO_ADDR
// if ValidHex ( x , y ) then
116471: LD_VAR 0 2
116475: PPUSH
116476: LD_VAR 0 3
116480: PPUSH
116481: CALL_OW 488
116485: IFFALSE 116520
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
116487: LD_VAR 0 1
116491: PPUSH
116492: LD_VAR 0 2
116496: PPUSH
116497: LD_VAR 0 3
116501: PPUSH
116502: LD_INT 3
116504: PPUSH
116505: LD_INT 6
116507: PPUSH
116508: CALL_OW 12
116512: PPUSH
116513: LD_INT 1
116515: PPUSH
116516: CALL_OW 483
// end ;
116520: GO 116380
116522: POP
116523: POP
// end ;
116524: PPOPN 5
116526: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
116527: LD_EXP 145
116531: PUSH
116532: LD_EXP 180
116536: AND
116537: IFFALSE 116631
116539: GO 116541
116541: DISABLE
116542: LD_INT 0
116544: PPUSH
116545: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
116546: LD_ADDR_VAR 0 2
116550: PUSH
116551: LD_INT 22
116553: PUSH
116554: LD_OWVAR 2
116558: PUSH
116559: EMPTY
116560: LIST
116561: LIST
116562: PUSH
116563: LD_INT 32
116565: PUSH
116566: LD_INT 1
116568: PUSH
116569: EMPTY
116570: LIST
116571: LIST
116572: PUSH
116573: LD_INT 21
116575: PUSH
116576: LD_INT 2
116578: PUSH
116579: EMPTY
116580: LIST
116581: LIST
116582: PUSH
116583: EMPTY
116584: LIST
116585: LIST
116586: LIST
116587: PPUSH
116588: CALL_OW 69
116592: ST_TO_ADDR
// if not tmp then
116593: LD_VAR 0 2
116597: NOT
116598: IFFALSE 116602
// exit ;
116600: GO 116631
// for i in tmp do
116602: LD_ADDR_VAR 0 1
116606: PUSH
116607: LD_VAR 0 2
116611: PUSH
116612: FOR_IN
116613: IFFALSE 116629
// SetFuel ( i , 0 ) ;
116615: LD_VAR 0 1
116619: PPUSH
116620: LD_INT 0
116622: PPUSH
116623: CALL_OW 240
116627: GO 116612
116629: POP
116630: POP
// end ;
116631: PPOPN 2
116633: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
116634: LD_EXP 145
116638: PUSH
116639: LD_EXP 181
116643: AND
116644: IFFALSE 116710
116646: GO 116648
116648: DISABLE
116649: LD_INT 0
116651: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
116652: LD_ADDR_VAR 0 1
116656: PUSH
116657: LD_INT 22
116659: PUSH
116660: LD_OWVAR 2
116664: PUSH
116665: EMPTY
116666: LIST
116667: LIST
116668: PUSH
116669: LD_INT 30
116671: PUSH
116672: LD_INT 29
116674: PUSH
116675: EMPTY
116676: LIST
116677: LIST
116678: PUSH
116679: EMPTY
116680: LIST
116681: LIST
116682: PPUSH
116683: CALL_OW 69
116687: ST_TO_ADDR
// if not tmp then
116688: LD_VAR 0 1
116692: NOT
116693: IFFALSE 116697
// exit ;
116695: GO 116710
// DestroyUnit ( tmp [ 1 ] ) ;
116697: LD_VAR 0 1
116701: PUSH
116702: LD_INT 1
116704: ARRAY
116705: PPUSH
116706: CALL_OW 65
// end ;
116710: PPOPN 1
116712: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
116713: LD_EXP 145
116717: PUSH
116718: LD_EXP 183
116722: AND
116723: IFFALSE 116852
116725: GO 116727
116727: DISABLE
116728: LD_INT 0
116730: PPUSH
// begin uc_side := 0 ;
116731: LD_ADDR_OWVAR 20
116735: PUSH
116736: LD_INT 0
116738: ST_TO_ADDR
// uc_nation := nation_arabian ;
116739: LD_ADDR_OWVAR 21
116743: PUSH
116744: LD_INT 2
116746: ST_TO_ADDR
// hc_gallery :=  ;
116747: LD_ADDR_OWVAR 33
116751: PUSH
116752: LD_STRING 
116754: ST_TO_ADDR
// hc_name :=  ;
116755: LD_ADDR_OWVAR 26
116759: PUSH
116760: LD_STRING 
116762: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
116763: LD_INT 1
116765: PPUSH
116766: LD_INT 11
116768: PPUSH
116769: LD_INT 10
116771: PPUSH
116772: CALL_OW 380
// un := CreateHuman ;
116776: LD_ADDR_VAR 0 1
116780: PUSH
116781: CALL_OW 44
116785: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
116786: LD_VAR 0 1
116790: PPUSH
116791: LD_INT 1
116793: PPUSH
116794: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
116798: LD_INT 35
116800: PPUSH
116801: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
116805: LD_VAR 0 1
116809: PPUSH
116810: LD_INT 22
116812: PUSH
116813: LD_OWVAR 2
116817: PUSH
116818: EMPTY
116819: LIST
116820: LIST
116821: PPUSH
116822: CALL_OW 69
116826: PPUSH
116827: LD_VAR 0 1
116831: PPUSH
116832: CALL_OW 74
116836: PPUSH
116837: CALL_OW 115
// until IsDead ( un ) ;
116841: LD_VAR 0 1
116845: PPUSH
116846: CALL_OW 301
116850: IFFALSE 116798
// end ;
116852: PPOPN 1
116854: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
116855: LD_EXP 145
116859: PUSH
116860: LD_EXP 185
116864: AND
116865: IFFALSE 116877
116867: GO 116869
116869: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
116870: LD_STRING earthquake(getX(game), 0, 32)
116872: PPUSH
116873: CALL_OW 559
116877: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
116878: LD_EXP 145
116882: PUSH
116883: LD_EXP 186
116887: AND
116888: IFFALSE 116979
116890: GO 116892
116892: DISABLE
116893: LD_INT 0
116895: PPUSH
// begin enable ;
116896: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
116897: LD_ADDR_VAR 0 1
116901: PUSH
116902: LD_INT 22
116904: PUSH
116905: LD_OWVAR 2
116909: PUSH
116910: EMPTY
116911: LIST
116912: LIST
116913: PUSH
116914: LD_INT 21
116916: PUSH
116917: LD_INT 2
116919: PUSH
116920: EMPTY
116921: LIST
116922: LIST
116923: PUSH
116924: LD_INT 33
116926: PUSH
116927: LD_INT 3
116929: PUSH
116930: EMPTY
116931: LIST
116932: LIST
116933: PUSH
116934: EMPTY
116935: LIST
116936: LIST
116937: LIST
116938: PPUSH
116939: CALL_OW 69
116943: ST_TO_ADDR
// if not tmp then
116944: LD_VAR 0 1
116948: NOT
116949: IFFALSE 116953
// exit ;
116951: GO 116979
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
116953: LD_VAR 0 1
116957: PUSH
116958: LD_INT 1
116960: PPUSH
116961: LD_VAR 0 1
116965: PPUSH
116966: CALL_OW 12
116970: ARRAY
116971: PPUSH
116972: LD_INT 1
116974: PPUSH
116975: CALL_OW 234
// end ;
116979: PPOPN 1
116981: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
116982: LD_EXP 145
116986: PUSH
116987: LD_EXP 187
116991: AND
116992: IFFALSE 117133
116994: GO 116996
116996: DISABLE
116997: LD_INT 0
116999: PPUSH
117000: PPUSH
117001: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117002: LD_ADDR_VAR 0 3
117006: PUSH
117007: LD_INT 22
117009: PUSH
117010: LD_OWVAR 2
117014: PUSH
117015: EMPTY
117016: LIST
117017: LIST
117018: PUSH
117019: LD_INT 25
117021: PUSH
117022: LD_INT 1
117024: PUSH
117025: EMPTY
117026: LIST
117027: LIST
117028: PUSH
117029: EMPTY
117030: LIST
117031: LIST
117032: PPUSH
117033: CALL_OW 69
117037: ST_TO_ADDR
// if not tmp then
117038: LD_VAR 0 3
117042: NOT
117043: IFFALSE 117047
// exit ;
117045: GO 117133
// un := tmp [ rand ( 1 , tmp ) ] ;
117047: LD_ADDR_VAR 0 2
117051: PUSH
117052: LD_VAR 0 3
117056: PUSH
117057: LD_INT 1
117059: PPUSH
117060: LD_VAR 0 3
117064: PPUSH
117065: CALL_OW 12
117069: ARRAY
117070: ST_TO_ADDR
// if Crawls ( un ) then
117071: LD_VAR 0 2
117075: PPUSH
117076: CALL_OW 318
117080: IFFALSE 117091
// ComWalk ( un ) ;
117082: LD_VAR 0 2
117086: PPUSH
117087: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
117091: LD_VAR 0 2
117095: PPUSH
117096: LD_INT 9
117098: PPUSH
117099: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
117103: LD_INT 28
117105: PPUSH
117106: LD_OWVAR 2
117110: PPUSH
117111: LD_INT 2
117113: PPUSH
117114: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
117118: LD_INT 29
117120: PPUSH
117121: LD_OWVAR 2
117125: PPUSH
117126: LD_INT 2
117128: PPUSH
117129: CALL_OW 322
// end ;
117133: PPOPN 3
117135: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
117136: LD_EXP 145
117140: PUSH
117141: LD_EXP 188
117145: AND
117146: IFFALSE 117257
117148: GO 117150
117150: DISABLE
117151: LD_INT 0
117153: PPUSH
117154: PPUSH
117155: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
117156: LD_ADDR_VAR 0 3
117160: PUSH
117161: LD_INT 22
117163: PUSH
117164: LD_OWVAR 2
117168: PUSH
117169: EMPTY
117170: LIST
117171: LIST
117172: PUSH
117173: LD_INT 25
117175: PUSH
117176: LD_INT 1
117178: PUSH
117179: EMPTY
117180: LIST
117181: LIST
117182: PUSH
117183: EMPTY
117184: LIST
117185: LIST
117186: PPUSH
117187: CALL_OW 69
117191: ST_TO_ADDR
// if not tmp then
117192: LD_VAR 0 3
117196: NOT
117197: IFFALSE 117201
// exit ;
117199: GO 117257
// un := tmp [ rand ( 1 , tmp ) ] ;
117201: LD_ADDR_VAR 0 2
117205: PUSH
117206: LD_VAR 0 3
117210: PUSH
117211: LD_INT 1
117213: PPUSH
117214: LD_VAR 0 3
117218: PPUSH
117219: CALL_OW 12
117223: ARRAY
117224: ST_TO_ADDR
// if Crawls ( un ) then
117225: LD_VAR 0 2
117229: PPUSH
117230: CALL_OW 318
117234: IFFALSE 117245
// ComWalk ( un ) ;
117236: LD_VAR 0 2
117240: PPUSH
117241: CALL_OW 138
// SetClass ( un , class_mortar ) ;
117245: LD_VAR 0 2
117249: PPUSH
117250: LD_INT 8
117252: PPUSH
117253: CALL_OW 336
// end ;
117257: PPOPN 3
117259: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
117260: LD_EXP 145
117264: PUSH
117265: LD_EXP 189
117269: AND
117270: IFFALSE 117414
117272: GO 117274
117274: DISABLE
117275: LD_INT 0
117277: PPUSH
117278: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
117279: LD_ADDR_VAR 0 2
117283: PUSH
117284: LD_INT 22
117286: PUSH
117287: LD_OWVAR 2
117291: PUSH
117292: EMPTY
117293: LIST
117294: LIST
117295: PUSH
117296: LD_INT 21
117298: PUSH
117299: LD_INT 2
117301: PUSH
117302: EMPTY
117303: LIST
117304: LIST
117305: PUSH
117306: LD_INT 2
117308: PUSH
117309: LD_INT 34
117311: PUSH
117312: LD_INT 12
117314: PUSH
117315: EMPTY
117316: LIST
117317: LIST
117318: PUSH
117319: LD_INT 34
117321: PUSH
117322: LD_INT 51
117324: PUSH
117325: EMPTY
117326: LIST
117327: LIST
117328: PUSH
117329: LD_INT 34
117331: PUSH
117332: LD_INT 32
117334: PUSH
117335: EMPTY
117336: LIST
117337: LIST
117338: PUSH
117339: EMPTY
117340: LIST
117341: LIST
117342: LIST
117343: LIST
117344: PUSH
117345: EMPTY
117346: LIST
117347: LIST
117348: LIST
117349: PPUSH
117350: CALL_OW 69
117354: ST_TO_ADDR
// if not tmp then
117355: LD_VAR 0 2
117359: NOT
117360: IFFALSE 117364
// exit ;
117362: GO 117414
// for i in tmp do
117364: LD_ADDR_VAR 0 1
117368: PUSH
117369: LD_VAR 0 2
117373: PUSH
117374: FOR_IN
117375: IFFALSE 117412
// if GetCargo ( i , mat_artifact ) = 0 then
117377: LD_VAR 0 1
117381: PPUSH
117382: LD_INT 4
117384: PPUSH
117385: CALL_OW 289
117389: PUSH
117390: LD_INT 0
117392: EQUAL
117393: IFFALSE 117410
// SetCargo ( i , mat_siberit , 100 ) ;
117395: LD_VAR 0 1
117399: PPUSH
117400: LD_INT 3
117402: PPUSH
117403: LD_INT 100
117405: PPUSH
117406: CALL_OW 290
117410: GO 117374
117412: POP
117413: POP
// end ;
117414: PPOPN 2
117416: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
117417: LD_EXP 145
117421: PUSH
117422: LD_EXP 190
117426: AND
117427: IFFALSE 117580
117429: GO 117431
117431: DISABLE
117432: LD_INT 0
117434: PPUSH
117435: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
117436: LD_ADDR_VAR 0 2
117440: PUSH
117441: LD_INT 22
117443: PUSH
117444: LD_OWVAR 2
117448: PUSH
117449: EMPTY
117450: LIST
117451: LIST
117452: PPUSH
117453: CALL_OW 69
117457: ST_TO_ADDR
// if not tmp then
117458: LD_VAR 0 2
117462: NOT
117463: IFFALSE 117467
// exit ;
117465: GO 117580
// for i := 1 to 2 do
117467: LD_ADDR_VAR 0 1
117471: PUSH
117472: DOUBLE
117473: LD_INT 1
117475: DEC
117476: ST_TO_ADDR
117477: LD_INT 2
117479: PUSH
117480: FOR_TO
117481: IFFALSE 117578
// begin uc_side := your_side ;
117483: LD_ADDR_OWVAR 20
117487: PUSH
117488: LD_OWVAR 2
117492: ST_TO_ADDR
// uc_nation := nation_american ;
117493: LD_ADDR_OWVAR 21
117497: PUSH
117498: LD_INT 1
117500: ST_TO_ADDR
// vc_chassis := us_morphling ;
117501: LD_ADDR_OWVAR 37
117505: PUSH
117506: LD_INT 5
117508: ST_TO_ADDR
// vc_engine := engine_siberite ;
117509: LD_ADDR_OWVAR 39
117513: PUSH
117514: LD_INT 3
117516: ST_TO_ADDR
// vc_control := control_computer ;
117517: LD_ADDR_OWVAR 38
117521: PUSH
117522: LD_INT 3
117524: ST_TO_ADDR
// vc_weapon := us_double_laser ;
117525: LD_ADDR_OWVAR 40
117529: PUSH
117530: LD_INT 10
117532: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
117533: CALL_OW 45
117537: PPUSH
117538: LD_VAR 0 2
117542: PUSH
117543: LD_INT 1
117545: ARRAY
117546: PPUSH
117547: CALL_OW 250
117551: PPUSH
117552: LD_VAR 0 2
117556: PUSH
117557: LD_INT 1
117559: ARRAY
117560: PPUSH
117561: CALL_OW 251
117565: PPUSH
117566: LD_INT 12
117568: PPUSH
117569: LD_INT 1
117571: PPUSH
117572: CALL_OW 50
// end ;
117576: GO 117480
117578: POP
117579: POP
// end ;
117580: PPOPN 2
117582: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
117583: LD_EXP 145
117587: PUSH
117588: LD_EXP 191
117592: AND
117593: IFFALSE 117815
117595: GO 117597
117597: DISABLE
117598: LD_INT 0
117600: PPUSH
117601: PPUSH
117602: PPUSH
117603: PPUSH
117604: PPUSH
117605: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117606: LD_ADDR_VAR 0 6
117610: PUSH
117611: LD_INT 22
117613: PUSH
117614: LD_OWVAR 2
117618: PUSH
117619: EMPTY
117620: LIST
117621: LIST
117622: PUSH
117623: LD_INT 21
117625: PUSH
117626: LD_INT 1
117628: PUSH
117629: EMPTY
117630: LIST
117631: LIST
117632: PUSH
117633: LD_INT 3
117635: PUSH
117636: LD_INT 23
117638: PUSH
117639: LD_INT 0
117641: PUSH
117642: EMPTY
117643: LIST
117644: LIST
117645: PUSH
117646: EMPTY
117647: LIST
117648: LIST
117649: PUSH
117650: EMPTY
117651: LIST
117652: LIST
117653: LIST
117654: PPUSH
117655: CALL_OW 69
117659: ST_TO_ADDR
// if not tmp then
117660: LD_VAR 0 6
117664: NOT
117665: IFFALSE 117669
// exit ;
117667: GO 117815
// s1 := rand ( 1 , 4 ) ;
117669: LD_ADDR_VAR 0 2
117673: PUSH
117674: LD_INT 1
117676: PPUSH
117677: LD_INT 4
117679: PPUSH
117680: CALL_OW 12
117684: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
117685: LD_ADDR_VAR 0 4
117689: PUSH
117690: LD_VAR 0 6
117694: PUSH
117695: LD_INT 1
117697: ARRAY
117698: PPUSH
117699: LD_VAR 0 2
117703: PPUSH
117704: CALL_OW 259
117708: ST_TO_ADDR
// if s1 = 1 then
117709: LD_VAR 0 2
117713: PUSH
117714: LD_INT 1
117716: EQUAL
117717: IFFALSE 117737
// s2 := rand ( 2 , 4 ) else
117719: LD_ADDR_VAR 0 3
117723: PUSH
117724: LD_INT 2
117726: PPUSH
117727: LD_INT 4
117729: PPUSH
117730: CALL_OW 12
117734: ST_TO_ADDR
117735: GO 117745
// s2 := 1 ;
117737: LD_ADDR_VAR 0 3
117741: PUSH
117742: LD_INT 1
117744: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
117745: LD_ADDR_VAR 0 5
117749: PUSH
117750: LD_VAR 0 6
117754: PUSH
117755: LD_INT 1
117757: ARRAY
117758: PPUSH
117759: LD_VAR 0 3
117763: PPUSH
117764: CALL_OW 259
117768: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
117769: LD_VAR 0 6
117773: PUSH
117774: LD_INT 1
117776: ARRAY
117777: PPUSH
117778: LD_VAR 0 2
117782: PPUSH
117783: LD_VAR 0 5
117787: PPUSH
117788: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
117792: LD_VAR 0 6
117796: PUSH
117797: LD_INT 1
117799: ARRAY
117800: PPUSH
117801: LD_VAR 0 3
117805: PPUSH
117806: LD_VAR 0 4
117810: PPUSH
117811: CALL_OW 237
// end ;
117815: PPOPN 6
117817: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
117818: LD_EXP 145
117822: PUSH
117823: LD_EXP 192
117827: AND
117828: IFFALSE 117907
117830: GO 117832
117832: DISABLE
117833: LD_INT 0
117835: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
117836: LD_ADDR_VAR 0 1
117840: PUSH
117841: LD_INT 22
117843: PUSH
117844: LD_OWVAR 2
117848: PUSH
117849: EMPTY
117850: LIST
117851: LIST
117852: PUSH
117853: LD_INT 30
117855: PUSH
117856: LD_INT 3
117858: PUSH
117859: EMPTY
117860: LIST
117861: LIST
117862: PUSH
117863: EMPTY
117864: LIST
117865: LIST
117866: PPUSH
117867: CALL_OW 69
117871: ST_TO_ADDR
// if not tmp then
117872: LD_VAR 0 1
117876: NOT
117877: IFFALSE 117881
// exit ;
117879: GO 117907
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
117881: LD_VAR 0 1
117885: PUSH
117886: LD_INT 1
117888: PPUSH
117889: LD_VAR 0 1
117893: PPUSH
117894: CALL_OW 12
117898: ARRAY
117899: PPUSH
117900: LD_INT 1
117902: PPUSH
117903: CALL_OW 234
// end ;
117907: PPOPN 1
117909: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
117910: LD_EXP 145
117914: PUSH
117915: LD_EXP 193
117919: AND
117920: IFFALSE 118032
117922: GO 117924
117924: DISABLE
117925: LD_INT 0
117927: PPUSH
117928: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
117929: LD_ADDR_VAR 0 2
117933: PUSH
117934: LD_INT 22
117936: PUSH
117937: LD_OWVAR 2
117941: PUSH
117942: EMPTY
117943: LIST
117944: LIST
117945: PUSH
117946: LD_INT 2
117948: PUSH
117949: LD_INT 30
117951: PUSH
117952: LD_INT 27
117954: PUSH
117955: EMPTY
117956: LIST
117957: LIST
117958: PUSH
117959: LD_INT 30
117961: PUSH
117962: LD_INT 26
117964: PUSH
117965: EMPTY
117966: LIST
117967: LIST
117968: PUSH
117969: LD_INT 30
117971: PUSH
117972: LD_INT 28
117974: PUSH
117975: EMPTY
117976: LIST
117977: LIST
117978: PUSH
117979: EMPTY
117980: LIST
117981: LIST
117982: LIST
117983: LIST
117984: PUSH
117985: EMPTY
117986: LIST
117987: LIST
117988: PPUSH
117989: CALL_OW 69
117993: ST_TO_ADDR
// if not tmp then
117994: LD_VAR 0 2
117998: NOT
117999: IFFALSE 118003
// exit ;
118001: GO 118032
// for i in tmp do
118003: LD_ADDR_VAR 0 1
118007: PUSH
118008: LD_VAR 0 2
118012: PUSH
118013: FOR_IN
118014: IFFALSE 118030
// SetLives ( i , 1 ) ;
118016: LD_VAR 0 1
118020: PPUSH
118021: LD_INT 1
118023: PPUSH
118024: CALL_OW 234
118028: GO 118013
118030: POP
118031: POP
// end ;
118032: PPOPN 2
118034: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
118035: LD_EXP 145
118039: PUSH
118040: LD_EXP 194
118044: AND
118045: IFFALSE 118319
118047: GO 118049
118049: DISABLE
118050: LD_INT 0
118052: PPUSH
118053: PPUSH
118054: PPUSH
// begin i := rand ( 1 , 7 ) ;
118055: LD_ADDR_VAR 0 1
118059: PUSH
118060: LD_INT 1
118062: PPUSH
118063: LD_INT 7
118065: PPUSH
118066: CALL_OW 12
118070: ST_TO_ADDR
// case i of 1 :
118071: LD_VAR 0 1
118075: PUSH
118076: LD_INT 1
118078: DOUBLE
118079: EQUAL
118080: IFTRUE 118084
118082: GO 118094
118084: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
118085: LD_STRING earthquake(getX(game), 0, 32)
118087: PPUSH
118088: CALL_OW 559
118092: GO 118319
118094: LD_INT 2
118096: DOUBLE
118097: EQUAL
118098: IFTRUE 118102
118100: GO 118116
118102: POP
// begin ToLua ( displayStucuk(); ) ;
118103: LD_STRING displayStucuk();
118105: PPUSH
118106: CALL_OW 559
// ResetFog ;
118110: CALL_OW 335
// end ; 3 :
118114: GO 118319
118116: LD_INT 3
118118: DOUBLE
118119: EQUAL
118120: IFTRUE 118124
118122: GO 118228
118124: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
118125: LD_ADDR_VAR 0 2
118129: PUSH
118130: LD_INT 22
118132: PUSH
118133: LD_OWVAR 2
118137: PUSH
118138: EMPTY
118139: LIST
118140: LIST
118141: PUSH
118142: LD_INT 25
118144: PUSH
118145: LD_INT 1
118147: PUSH
118148: EMPTY
118149: LIST
118150: LIST
118151: PUSH
118152: EMPTY
118153: LIST
118154: LIST
118155: PPUSH
118156: CALL_OW 69
118160: ST_TO_ADDR
// if not tmp then
118161: LD_VAR 0 2
118165: NOT
118166: IFFALSE 118170
// exit ;
118168: GO 118319
// un := tmp [ rand ( 1 , tmp ) ] ;
118170: LD_ADDR_VAR 0 3
118174: PUSH
118175: LD_VAR 0 2
118179: PUSH
118180: LD_INT 1
118182: PPUSH
118183: LD_VAR 0 2
118187: PPUSH
118188: CALL_OW 12
118192: ARRAY
118193: ST_TO_ADDR
// if Crawls ( un ) then
118194: LD_VAR 0 3
118198: PPUSH
118199: CALL_OW 318
118203: IFFALSE 118214
// ComWalk ( un ) ;
118205: LD_VAR 0 3
118209: PPUSH
118210: CALL_OW 138
// SetClass ( un , class_mortar ) ;
118214: LD_VAR 0 3
118218: PPUSH
118219: LD_INT 8
118221: PPUSH
118222: CALL_OW 336
// end ; 4 :
118226: GO 118319
118228: LD_INT 4
118230: DOUBLE
118231: EQUAL
118232: IFTRUE 118236
118234: GO 118297
118236: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
118237: LD_ADDR_VAR 0 2
118241: PUSH
118242: LD_INT 22
118244: PUSH
118245: LD_OWVAR 2
118249: PUSH
118250: EMPTY
118251: LIST
118252: LIST
118253: PUSH
118254: LD_INT 30
118256: PUSH
118257: LD_INT 29
118259: PUSH
118260: EMPTY
118261: LIST
118262: LIST
118263: PUSH
118264: EMPTY
118265: LIST
118266: LIST
118267: PPUSH
118268: CALL_OW 69
118272: ST_TO_ADDR
// if not tmp then
118273: LD_VAR 0 2
118277: NOT
118278: IFFALSE 118282
// exit ;
118280: GO 118319
// DestroyUnit ( tmp [ 1 ] ) ;
118282: LD_VAR 0 2
118286: PUSH
118287: LD_INT 1
118289: ARRAY
118290: PPUSH
118291: CALL_OW 65
// end ; 5 .. 7 :
118295: GO 118319
118297: LD_INT 5
118299: DOUBLE
118300: GREATEREQUAL
118301: IFFALSE 118309
118303: LD_INT 7
118305: DOUBLE
118306: LESSEQUAL
118307: IFTRUE 118311
118309: GO 118318
118311: POP
// StreamSibBomb ; end ;
118312: CALL 114599 0 0
118316: GO 118319
118318: POP
// end ;
118319: PPOPN 3
118321: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
118322: LD_EXP 145
118326: PUSH
118327: LD_EXP 195
118331: AND
118332: IFFALSE 118488
118334: GO 118336
118336: DISABLE
118337: LD_INT 0
118339: PPUSH
118340: PPUSH
118341: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
118342: LD_ADDR_VAR 0 2
118346: PUSH
118347: LD_INT 81
118349: PUSH
118350: LD_OWVAR 2
118354: PUSH
118355: EMPTY
118356: LIST
118357: LIST
118358: PUSH
118359: LD_INT 2
118361: PUSH
118362: LD_INT 21
118364: PUSH
118365: LD_INT 1
118367: PUSH
118368: EMPTY
118369: LIST
118370: LIST
118371: PUSH
118372: LD_INT 21
118374: PUSH
118375: LD_INT 2
118377: PUSH
118378: EMPTY
118379: LIST
118380: LIST
118381: PUSH
118382: EMPTY
118383: LIST
118384: LIST
118385: LIST
118386: PUSH
118387: EMPTY
118388: LIST
118389: LIST
118390: PPUSH
118391: CALL_OW 69
118395: ST_TO_ADDR
// if not tmp then
118396: LD_VAR 0 2
118400: NOT
118401: IFFALSE 118405
// exit ;
118403: GO 118488
// p := 0 ;
118405: LD_ADDR_VAR 0 3
118409: PUSH
118410: LD_INT 0
118412: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118413: LD_INT 35
118415: PPUSH
118416: CALL_OW 67
// p := p + 1 ;
118420: LD_ADDR_VAR 0 3
118424: PUSH
118425: LD_VAR 0 3
118429: PUSH
118430: LD_INT 1
118432: PLUS
118433: ST_TO_ADDR
// for i in tmp do
118434: LD_ADDR_VAR 0 1
118438: PUSH
118439: LD_VAR 0 2
118443: PUSH
118444: FOR_IN
118445: IFFALSE 118476
// if GetLives ( i ) < 1000 then
118447: LD_VAR 0 1
118451: PPUSH
118452: CALL_OW 256
118456: PUSH
118457: LD_INT 1000
118459: LESS
118460: IFFALSE 118474
// SetLives ( i , 1000 ) ;
118462: LD_VAR 0 1
118466: PPUSH
118467: LD_INT 1000
118469: PPUSH
118470: CALL_OW 234
118474: GO 118444
118476: POP
118477: POP
// until p > 20 ;
118478: LD_VAR 0 3
118482: PUSH
118483: LD_INT 20
118485: GREATER
118486: IFFALSE 118413
// end ;
118488: PPOPN 3
118490: END
// every 0 0$1 trigger StreamModeActive and sTime do
118491: LD_EXP 145
118495: PUSH
118496: LD_EXP 196
118500: AND
118501: IFFALSE 118536
118503: GO 118505
118505: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
118506: LD_INT 28
118508: PPUSH
118509: LD_OWVAR 2
118513: PPUSH
118514: LD_INT 2
118516: PPUSH
118517: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
118521: LD_INT 30
118523: PPUSH
118524: LD_OWVAR 2
118528: PPUSH
118529: LD_INT 2
118531: PPUSH
118532: CALL_OW 322
// end ;
118536: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
118537: LD_EXP 145
118541: PUSH
118542: LD_EXP 197
118546: AND
118547: IFFALSE 118668
118549: GO 118551
118551: DISABLE
118552: LD_INT 0
118554: PPUSH
118555: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
118556: LD_ADDR_VAR 0 2
118560: PUSH
118561: LD_INT 22
118563: PUSH
118564: LD_OWVAR 2
118568: PUSH
118569: EMPTY
118570: LIST
118571: LIST
118572: PUSH
118573: LD_INT 21
118575: PUSH
118576: LD_INT 1
118578: PUSH
118579: EMPTY
118580: LIST
118581: LIST
118582: PUSH
118583: LD_INT 3
118585: PUSH
118586: LD_INT 23
118588: PUSH
118589: LD_INT 0
118591: PUSH
118592: EMPTY
118593: LIST
118594: LIST
118595: PUSH
118596: EMPTY
118597: LIST
118598: LIST
118599: PUSH
118600: EMPTY
118601: LIST
118602: LIST
118603: LIST
118604: PPUSH
118605: CALL_OW 69
118609: ST_TO_ADDR
// if not tmp then
118610: LD_VAR 0 2
118614: NOT
118615: IFFALSE 118619
// exit ;
118617: GO 118668
// for i in tmp do
118619: LD_ADDR_VAR 0 1
118623: PUSH
118624: LD_VAR 0 2
118628: PUSH
118629: FOR_IN
118630: IFFALSE 118666
// begin if Crawls ( i ) then
118632: LD_VAR 0 1
118636: PPUSH
118637: CALL_OW 318
118641: IFFALSE 118652
// ComWalk ( i ) ;
118643: LD_VAR 0 1
118647: PPUSH
118648: CALL_OW 138
// SetClass ( i , 2 ) ;
118652: LD_VAR 0 1
118656: PPUSH
118657: LD_INT 2
118659: PPUSH
118660: CALL_OW 336
// end ;
118664: GO 118629
118666: POP
118667: POP
// end ;
118668: PPOPN 2
118670: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
118671: LD_EXP 145
118675: PUSH
118676: LD_EXP 198
118680: AND
118681: IFFALSE 118962
118683: GO 118685
118685: DISABLE
118686: LD_INT 0
118688: PPUSH
118689: PPUSH
118690: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
118691: LD_OWVAR 2
118695: PPUSH
118696: LD_INT 9
118698: PPUSH
118699: LD_INT 1
118701: PPUSH
118702: LD_INT 1
118704: PPUSH
118705: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
118709: LD_INT 9
118711: PPUSH
118712: LD_OWVAR 2
118716: PPUSH
118717: CALL_OW 343
// uc_side := 9 ;
118721: LD_ADDR_OWVAR 20
118725: PUSH
118726: LD_INT 9
118728: ST_TO_ADDR
// uc_nation := 2 ;
118729: LD_ADDR_OWVAR 21
118733: PUSH
118734: LD_INT 2
118736: ST_TO_ADDR
// hc_name := Dark Warrior ;
118737: LD_ADDR_OWVAR 26
118741: PUSH
118742: LD_STRING Dark Warrior
118744: ST_TO_ADDR
// hc_gallery :=  ;
118745: LD_ADDR_OWVAR 33
118749: PUSH
118750: LD_STRING 
118752: ST_TO_ADDR
// hc_noskilllimit := true ;
118753: LD_ADDR_OWVAR 76
118757: PUSH
118758: LD_INT 1
118760: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
118761: LD_ADDR_OWVAR 31
118765: PUSH
118766: LD_INT 30
118768: PUSH
118769: LD_INT 30
118771: PUSH
118772: LD_INT 30
118774: PUSH
118775: LD_INT 30
118777: PUSH
118778: EMPTY
118779: LIST
118780: LIST
118781: LIST
118782: LIST
118783: ST_TO_ADDR
// un := CreateHuman ;
118784: LD_ADDR_VAR 0 3
118788: PUSH
118789: CALL_OW 44
118793: ST_TO_ADDR
// hc_noskilllimit := false ;
118794: LD_ADDR_OWVAR 76
118798: PUSH
118799: LD_INT 0
118801: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
118802: LD_VAR 0 3
118806: PPUSH
118807: LD_INT 1
118809: PPUSH
118810: CALL_OW 51
// p := 0 ;
118814: LD_ADDR_VAR 0 2
118818: PUSH
118819: LD_INT 0
118821: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
118822: LD_INT 35
118824: PPUSH
118825: CALL_OW 67
// p := p + 1 ;
118829: LD_ADDR_VAR 0 2
118833: PUSH
118834: LD_VAR 0 2
118838: PUSH
118839: LD_INT 1
118841: PLUS
118842: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
118843: LD_VAR 0 3
118847: PPUSH
118848: CALL_OW 256
118852: PUSH
118853: LD_INT 1000
118855: LESS
118856: IFFALSE 118870
// SetLives ( un , 1000 ) ;
118858: LD_VAR 0 3
118862: PPUSH
118863: LD_INT 1000
118865: PPUSH
118866: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
118870: LD_VAR 0 3
118874: PPUSH
118875: LD_INT 81
118877: PUSH
118878: LD_OWVAR 2
118882: PUSH
118883: EMPTY
118884: LIST
118885: LIST
118886: PUSH
118887: LD_INT 91
118889: PUSH
118890: LD_VAR 0 3
118894: PUSH
118895: LD_INT 30
118897: PUSH
118898: EMPTY
118899: LIST
118900: LIST
118901: LIST
118902: PUSH
118903: EMPTY
118904: LIST
118905: LIST
118906: PPUSH
118907: CALL_OW 69
118911: PPUSH
118912: LD_VAR 0 3
118916: PPUSH
118917: CALL_OW 74
118921: PPUSH
118922: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
118926: LD_VAR 0 2
118930: PUSH
118931: LD_INT 60
118933: GREATER
118934: PUSH
118935: LD_VAR 0 3
118939: PPUSH
118940: CALL_OW 301
118944: OR
118945: IFFALSE 118822
// if un then
118947: LD_VAR 0 3
118951: IFFALSE 118962
// RemoveUnit ( un ) ;
118953: LD_VAR 0 3
118957: PPUSH
118958: CALL_OW 64
// end ; end_of_file
118962: PPOPN 3
118964: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
118965: LD_INT 0
118967: PPUSH
118968: PPUSH
118969: PPUSH
118970: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
118971: LD_VAR 0 1
118975: PPUSH
118976: CALL_OW 264
118980: PUSH
118981: LD_EXP 99
118985: EQUAL
118986: IFFALSE 119058
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
118988: LD_INT 68
118990: PPUSH
118991: LD_VAR 0 1
118995: PPUSH
118996: CALL_OW 255
119000: PPUSH
119001: CALL_OW 321
119005: PUSH
119006: LD_INT 2
119008: EQUAL
119009: IFFALSE 119021
// eff := 70 else
119011: LD_ADDR_VAR 0 6
119015: PUSH
119016: LD_INT 70
119018: ST_TO_ADDR
119019: GO 119029
// eff := 30 ;
119021: LD_ADDR_VAR 0 6
119025: PUSH
119026: LD_INT 30
119028: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
119029: LD_VAR 0 1
119033: PPUSH
119034: CALL_OW 250
119038: PPUSH
119039: LD_VAR 0 1
119043: PPUSH
119044: CALL_OW 251
119048: PPUSH
119049: LD_VAR 0 6
119053: PPUSH
119054: CALL_OW 495
// end ; end ;
119058: LD_VAR 0 4
119062: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
119063: LD_INT 0
119065: PPUSH
119066: PPUSH
119067: PPUSH
119068: PPUSH
119069: PPUSH
119070: PPUSH
// if cmd = 124 then
119071: LD_VAR 0 1
119075: PUSH
119076: LD_INT 124
119078: EQUAL
119079: IFFALSE 119285
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
119081: LD_ADDR_VAR 0 5
119085: PUSH
119086: LD_INT 2
119088: PUSH
119089: LD_INT 34
119091: PUSH
119092: LD_INT 53
119094: PUSH
119095: EMPTY
119096: LIST
119097: LIST
119098: PUSH
119099: LD_INT 34
119101: PUSH
119102: LD_INT 14
119104: PUSH
119105: EMPTY
119106: LIST
119107: LIST
119108: PUSH
119109: EMPTY
119110: LIST
119111: LIST
119112: LIST
119113: PPUSH
119114: CALL_OW 69
119118: ST_TO_ADDR
// if not tmp then
119119: LD_VAR 0 5
119123: NOT
119124: IFFALSE 119128
// exit ;
119126: GO 119285
// for i in tmp do
119128: LD_ADDR_VAR 0 3
119132: PUSH
119133: LD_VAR 0 5
119137: PUSH
119138: FOR_IN
119139: IFFALSE 119283
// begin taskList := GetTaskList ( i ) ;
119141: LD_ADDR_VAR 0 6
119145: PUSH
119146: LD_VAR 0 3
119150: PPUSH
119151: CALL_OW 437
119155: ST_TO_ADDR
// if not taskList then
119156: LD_VAR 0 6
119160: NOT
119161: IFFALSE 119165
// continue ;
119163: GO 119138
// for j = 1 to taskList do
119165: LD_ADDR_VAR 0 4
119169: PUSH
119170: DOUBLE
119171: LD_INT 1
119173: DEC
119174: ST_TO_ADDR
119175: LD_VAR 0 6
119179: PUSH
119180: FOR_TO
119181: IFFALSE 119279
// if taskList [ j ] [ 1 ] = | then
119183: LD_VAR 0 6
119187: PUSH
119188: LD_VAR 0 4
119192: ARRAY
119193: PUSH
119194: LD_INT 1
119196: ARRAY
119197: PUSH
119198: LD_STRING |
119200: EQUAL
119201: IFFALSE 119277
// begin _taskList := Delete ( taskList , 1 ) ;
119203: LD_ADDR_VAR 0 7
119207: PUSH
119208: LD_VAR 0 6
119212: PPUSH
119213: LD_INT 1
119215: PPUSH
119216: CALL_OW 3
119220: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
119221: LD_VAR 0 3
119225: PPUSH
119226: LD_VAR 0 7
119230: PPUSH
119231: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
119235: LD_VAR 0 3
119239: PPUSH
119240: LD_VAR 0 6
119244: PUSH
119245: LD_VAR 0 4
119249: ARRAY
119250: PUSH
119251: LD_INT 2
119253: ARRAY
119254: PPUSH
119255: LD_VAR 0 6
119259: PUSH
119260: LD_VAR 0 4
119264: ARRAY
119265: PUSH
119266: LD_INT 3
119268: ARRAY
119269: PPUSH
119270: LD_INT 8
119272: PPUSH
119273: CALL 119290 0 4
// end ;
119277: GO 119180
119279: POP
119280: POP
// end ;
119281: GO 119138
119283: POP
119284: POP
// end ; end ;
119285: LD_VAR 0 2
119289: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
119290: LD_INT 0
119292: PPUSH
119293: PPUSH
119294: PPUSH
119295: PPUSH
119296: PPUSH
119297: PPUSH
119298: PPUSH
119299: PPUSH
119300: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
119301: LD_VAR 0 1
119305: NOT
119306: PUSH
119307: LD_VAR 0 2
119311: PPUSH
119312: LD_VAR 0 3
119316: PPUSH
119317: CALL_OW 488
119321: NOT
119322: OR
119323: PUSH
119324: LD_VAR 0 4
119328: NOT
119329: OR
119330: IFFALSE 119334
// exit ;
119332: GO 119674
// list := [ ] ;
119334: LD_ADDR_VAR 0 13
119338: PUSH
119339: EMPTY
119340: ST_TO_ADDR
// if x - r < 0 then
119341: LD_VAR 0 2
119345: PUSH
119346: LD_VAR 0 4
119350: MINUS
119351: PUSH
119352: LD_INT 0
119354: LESS
119355: IFFALSE 119367
// min_x := 0 else
119357: LD_ADDR_VAR 0 7
119361: PUSH
119362: LD_INT 0
119364: ST_TO_ADDR
119365: GO 119383
// min_x := x - r ;
119367: LD_ADDR_VAR 0 7
119371: PUSH
119372: LD_VAR 0 2
119376: PUSH
119377: LD_VAR 0 4
119381: MINUS
119382: ST_TO_ADDR
// if y - r < 0 then
119383: LD_VAR 0 3
119387: PUSH
119388: LD_VAR 0 4
119392: MINUS
119393: PUSH
119394: LD_INT 0
119396: LESS
119397: IFFALSE 119409
// min_y := 0 else
119399: LD_ADDR_VAR 0 8
119403: PUSH
119404: LD_INT 0
119406: ST_TO_ADDR
119407: GO 119425
// min_y := y - r ;
119409: LD_ADDR_VAR 0 8
119413: PUSH
119414: LD_VAR 0 3
119418: PUSH
119419: LD_VAR 0 4
119423: MINUS
119424: ST_TO_ADDR
// max_x := x + r ;
119425: LD_ADDR_VAR 0 9
119429: PUSH
119430: LD_VAR 0 2
119434: PUSH
119435: LD_VAR 0 4
119439: PLUS
119440: ST_TO_ADDR
// max_y := y + r ;
119441: LD_ADDR_VAR 0 10
119445: PUSH
119446: LD_VAR 0 3
119450: PUSH
119451: LD_VAR 0 4
119455: PLUS
119456: ST_TO_ADDR
// for _x = min_x to max_x do
119457: LD_ADDR_VAR 0 11
119461: PUSH
119462: DOUBLE
119463: LD_VAR 0 7
119467: DEC
119468: ST_TO_ADDR
119469: LD_VAR 0 9
119473: PUSH
119474: FOR_TO
119475: IFFALSE 119592
// for _y = min_y to max_y do
119477: LD_ADDR_VAR 0 12
119481: PUSH
119482: DOUBLE
119483: LD_VAR 0 8
119487: DEC
119488: ST_TO_ADDR
119489: LD_VAR 0 10
119493: PUSH
119494: FOR_TO
119495: IFFALSE 119588
// begin if not ValidHex ( _x , _y ) then
119497: LD_VAR 0 11
119501: PPUSH
119502: LD_VAR 0 12
119506: PPUSH
119507: CALL_OW 488
119511: NOT
119512: IFFALSE 119516
// continue ;
119514: GO 119494
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
119516: LD_VAR 0 11
119520: PPUSH
119521: LD_VAR 0 12
119525: PPUSH
119526: CALL_OW 351
119530: PUSH
119531: LD_VAR 0 11
119535: PPUSH
119536: LD_VAR 0 12
119540: PPUSH
119541: CALL_OW 554
119545: AND
119546: IFFALSE 119586
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
119548: LD_ADDR_VAR 0 13
119552: PUSH
119553: LD_VAR 0 13
119557: PPUSH
119558: LD_VAR 0 13
119562: PUSH
119563: LD_INT 1
119565: PLUS
119566: PPUSH
119567: LD_VAR 0 11
119571: PUSH
119572: LD_VAR 0 12
119576: PUSH
119577: EMPTY
119578: LIST
119579: LIST
119580: PPUSH
119581: CALL_OW 2
119585: ST_TO_ADDR
// end ;
119586: GO 119494
119588: POP
119589: POP
119590: GO 119474
119592: POP
119593: POP
// if not list then
119594: LD_VAR 0 13
119598: NOT
119599: IFFALSE 119603
// exit ;
119601: GO 119674
// for i in list do
119603: LD_ADDR_VAR 0 6
119607: PUSH
119608: LD_VAR 0 13
119612: PUSH
119613: FOR_IN
119614: IFFALSE 119672
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
119616: LD_VAR 0 1
119620: PPUSH
119621: LD_STRING M
119623: PUSH
119624: LD_VAR 0 6
119628: PUSH
119629: LD_INT 1
119631: ARRAY
119632: PUSH
119633: LD_VAR 0 6
119637: PUSH
119638: LD_INT 2
119640: ARRAY
119641: PUSH
119642: LD_INT 0
119644: PUSH
119645: LD_INT 0
119647: PUSH
119648: LD_INT 0
119650: PUSH
119651: LD_INT 0
119653: PUSH
119654: EMPTY
119655: LIST
119656: LIST
119657: LIST
119658: LIST
119659: LIST
119660: LIST
119661: LIST
119662: PUSH
119663: EMPTY
119664: LIST
119665: PPUSH
119666: CALL_OW 447
119670: GO 119613
119672: POP
119673: POP
// end ;
119674: LD_VAR 0 5
119678: RET
