// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 69 0 0
// InitGlobalVariables ;
  15: CALL 35091 0 0
// InitMacro ;
  19: CALL 35259 0 0
// InitNature ;
  23: CALL 34959 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// PrepareAlliance ;
  40: CALL 11169 0 0
// PrepareRussian ;
  44: CALL 7025 0 0
// PrepareLegion ;
  48: CALL 4214 0 0
// PreparePowell ;
  52: CALL 2947 0 0
// PrepareAmerican ;
  56: CALL 1719 0 0
// Action ;
  60: CALL 15071 0 0
// MC_Start ( ) ;
  64: CALL 37424 0 0
// end ;
  68: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans , powellAngerQuery , bombExploded , legionEscapeUnits ; export function InitVariables ; begin
  69: LD_INT 0
  71: PPUSH
// debug := false ;
  72: LD_ADDR_EXP 1
  76: PUSH
  77: LD_INT 0
  79: ST_TO_ADDR
// missionStart := false ;
  80: LD_ADDR_EXP 13
  84: PUSH
  85: LD_INT 0
  87: ST_TO_ADDR
// missionTime := 0 0$00 ;
  88: LD_ADDR_EXP 14
  92: PUSH
  93: LD_INT 0
  95: ST_TO_ADDR
// missionStage := 1 ;
  96: LD_ADDR_EXP 15
 100: PUSH
 101: LD_INT 1
 103: ST_TO_ADDR
// activeAttacks := false ;
 104: LD_ADDR_EXP 16
 108: PUSH
 109: LD_INT 0
 111: ST_TO_ADDR
// powellAnger := 0 ;
 112: LD_ADDR_EXP 17
 116: PUSH
 117: LD_INT 0
 119: ST_TO_ADDR
// powellAngerQuery := false ;
 120: LD_ADDR_EXP 36
 124: PUSH
 125: LD_INT 0
 127: ST_TO_ADDR
// powellAllowRetreat := true ;
 128: LD_ADDR_EXP 19
 132: PUSH
 133: LD_INT 1
 135: ST_TO_ADDR
// powellCenterCameraMode := false ;
 136: LD_ADDR_EXP 20
 140: PUSH
 141: LD_INT 0
 143: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 144: LD_ADDR_EXP 18
 148: PUSH
 149: EMPTY
 150: PUSH
 151: EMPTY
 152: PUSH
 153: EMPTY
 154: LIST
 155: LIST
 156: ST_TO_ADDR
// russianDestroyed := false ;
 157: LD_ADDR_EXP 21
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// legionDestroyed := false ;
 165: LD_ADDR_EXP 22
 169: PUSH
 170: LD_INT 0
 172: ST_TO_ADDR
// allianceDestroyed := false ;
 173: LD_ADDR_EXP 23
 177: PUSH
 178: LD_INT 0
 180: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 181: LD_ADDR_EXP 2
 185: PUSH
 186: LD_STRING 14_KappaStatus_1
 188: PPUSH
 189: LD_INT 0
 191: PPUSH
 192: CALL_OW 30
 196: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 197: LD_ADDR_EXP 3
 201: PUSH
 202: LD_STRING 06_KurtStatus_1
 204: PPUSH
 205: LD_INT 0
 207: PPUSH
 208: CALL_OW 30
 212: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 213: LD_ADDR_EXP 4
 217: PUSH
 218: LD_STRING 14_JMMVeh_1
 220: PPUSH
 221: LD_INT 0
 223: PPUSH
 224: CALL_OW 30
 228: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 229: LD_ADDR_EXP 5
 233: PUSH
 234: LD_STRING 14_JMMGirlVeh_1
 236: PPUSH
 237: LD_INT 0
 239: PPUSH
 240: CALL_OW 30
 244: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 245: LD_ADDR_EXP 7
 249: PUSH
 250: LD_STRING 14_JMMGirl_1
 252: PPUSH
 253: LD_INT 0
 255: PPUSH
 256: CALL_OW 30
 260: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 261: LD_ADDR_EXP 6
 265: PUSH
 266: LD_STRING 14_JMMGirlStatus_1
 268: PPUSH
 269: LD_INT 0
 271: PPUSH
 272: CALL_OW 30
 276: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 277: LD_ADDR_EXP 8
 281: PUSH
 282: LD_STRING 10_KhatamStatus_1
 284: PPUSH
 285: LD_INT 0
 287: PPUSH
 288: CALL_OW 30
 292: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 293: LD_ADDR_EXP 9
 297: PUSH
 298: LD_STRING 13_BurlakStatus_1
 300: PPUSH
 301: LD_INT 0
 303: PPUSH
 304: CALL_OW 30
 308: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 309: LD_ADDR_EXP 10
 313: PUSH
 314: LD_STRING 13_StevensStatus_1
 316: PPUSH
 317: LD_INT 0
 319: PPUSH
 320: CALL_OW 30
 324: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 325: LD_ADDR_EXP 11
 329: PUSH
 330: LD_STRING 14_FastEnd_1
 332: PPUSH
 333: LD_INT 0
 335: PPUSH
 336: CALL_OW 30
 340: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 341: LD_ADDR_EXP 12
 345: PUSH
 346: LD_STRING 12_MainDepositFake_1
 348: PPUSH
 349: LD_INT 0
 351: PPUSH
 352: CALL_OW 30
 356: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 357: LD_ADDR_EXP 24
 361: PUSH
 362: LD_INT 1
 364: ST_TO_ADDR
// behemothUnderConstruct := false ;
 365: LD_ADDR_EXP 26
 369: PUSH
 370: LD_INT 0
 372: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 373: LD_ADDR_EXP 27
 377: PUSH
 378: LD_INT 0
 380: ST_TO_ADDR
// behemothDone := false ;
 381: LD_ADDR_EXP 28
 385: PUSH
 386: LD_INT 0
 388: ST_TO_ADDR
// allowBehemothConstruct := false ;
 389: LD_ADDR_EXP 25
 393: PUSH
 394: LD_INT 0
 396: ST_TO_ADDR
// seeBehemoth := false ;
 397: LD_ADDR_EXP 29
 401: PUSH
 402: LD_INT 0
 404: ST_TO_ADDR
// platonovHasBomb := false ;
 405: LD_ADDR_EXP 30
 409: PUSH
 410: LD_INT 0
 412: ST_TO_ADDR
// allianceActive := false ;
 413: LD_ADDR_EXP 31
 417: PUSH
 418: LD_INT 0
 420: ST_TO_ADDR
// rothCaptured := false ;
 421: LD_ADDR_EXP 33
 425: PUSH
 426: LD_INT 0
 428: ST_TO_ADDR
// lostCounter := 0 ;
 429: LD_ADDR_EXP 32
 433: PUSH
 434: LD_INT 0
 436: ST_TO_ADDR
// capturedUnit := [ ] ;
 437: LD_ADDR_EXP 34
 441: PUSH
 442: EMPTY
 443: ST_TO_ADDR
// trueAmericans := [ ] ;
 444: LD_ADDR_EXP 35
 448: PUSH
 449: EMPTY
 450: ST_TO_ADDR
// bombExploded := false ;
 451: LD_ADDR_EXP 37
 455: PUSH
 456: LD_INT 0
 458: ST_TO_ADDR
// legionEscapeUnits := [ ] ;
 459: LD_ADDR_EXP 38
 463: PUSH
 464: EMPTY
 465: ST_TO_ADDR
// end ;
 466: LD_VAR 0 1
 470: RET
// export function CustomInitMacro ( ) ; begin
 471: LD_INT 0
 473: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 474: LD_ADDR_EXP 140
 478: PUSH
 479: LD_INT 2
 481: PUSH
 482: LD_INT 3
 484: PUSH
 485: LD_INT 6
 487: PUSH
 488: LD_INT 10
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 497: LD_ADDR_EXP 141
 501: PUSH
 502: LD_INT 1
 504: PUSH
 505: LD_INT 4
 507: PUSH
 508: LD_INT 5
 510: PUSH
 511: LD_INT 9
 513: PUSH
 514: EMPTY
 515: LIST
 516: LIST
 517: LIST
 518: LIST
 519: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 520: LD_INT 1
 522: PPUSH
 523: LD_INT 10
 525: PUSH
 526: LD_INT 11
 528: PUSH
 529: LD_INT 12
 531: PUSH
 532: EMPTY
 533: LIST
 534: LIST
 535: LIST
 536: PPUSH
 537: CALL 60173 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 541: LD_INT 1
 543: PPUSH
 544: LD_INT 17
 546: PUSH
 547: EMPTY
 548: LIST
 549: PPUSH
 550: CALL 60266 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 554: LD_INT 1
 556: PPUSH
 557: LD_INT 5
 559: PPUSH
 560: CALL 59616 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 564: LD_INT 1
 566: PPUSH
 567: LD_INT 24
 569: PUSH
 570: LD_INT 3
 572: PUSH
 573: LD_INT 3
 575: PUSH
 576: LD_INT 47
 578: PUSH
 579: EMPTY
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: PUSH
 585: LD_INT 24
 587: PUSH
 588: LD_INT 3
 590: PUSH
 591: LD_INT 3
 593: PUSH
 594: LD_INT 47
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: PUSH
 603: LD_INT 24
 605: PUSH
 606: LD_INT 3
 608: PUSH
 609: LD_INT 3
 611: PUSH
 612: LD_INT 47
 614: PUSH
 615: EMPTY
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: PUSH
 621: LD_INT 24
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 1
 629: PUSH
 630: LD_INT 47
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_INT 24
 641: PUSH
 642: LD_INT 3
 644: PUSH
 645: LD_INT 1
 647: PUSH
 648: LD_INT 47
 650: PUSH
 651: EMPTY
 652: LIST
 653: LIST
 654: LIST
 655: LIST
 656: PUSH
 657: EMPTY
 658: LIST
 659: LIST
 660: LIST
 661: LIST
 662: LIST
 663: PPUSH
 664: CALL 59431 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 668: LD_INT 2
 670: PPUSH
 671: LD_INT 10
 673: PUSH
 674: LD_INT 11
 676: PUSH
 677: LD_INT 12
 679: PUSH
 680: LD_INT 14
 682: PUSH
 683: EMPTY
 684: LIST
 685: LIST
 686: LIST
 687: LIST
 688: PPUSH
 689: CALL 60173 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 693: LD_INT 2
 695: PPUSH
 696: LD_INT 16
 698: PUSH
 699: EMPTY
 700: LIST
 701: PPUSH
 702: CALL 60266 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 706: LD_INT 2
 708: PPUSH
 709: LD_INT 21
 711: PUSH
 712: LD_INT 3
 714: PUSH
 715: LD_INT 3
 717: PUSH
 718: LD_INT 51
 720: PUSH
 721: EMPTY
 722: LIST
 723: LIST
 724: LIST
 725: LIST
 726: PUSH
 727: LD_INT 22
 729: PUSH
 730: LD_INT 3
 732: PUSH
 733: LD_INT 3
 735: PUSH
 736: LD_INT 52
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: LIST
 744: PUSH
 745: LD_INT 22
 747: PUSH
 748: LD_INT 3
 750: PUSH
 751: LD_INT 3
 753: PUSH
 754: LD_INT 52
 756: PUSH
 757: EMPTY
 758: LIST
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_INT 24
 765: PUSH
 766: LD_INT 3
 768: PUSH
 769: LD_INT 3
 771: PUSH
 772: LD_INT 47
 774: PUSH
 775: EMPTY
 776: LIST
 777: LIST
 778: LIST
 779: LIST
 780: PUSH
 781: LD_INT 24
 783: PUSH
 784: LD_INT 3
 786: PUSH
 787: LD_INT 3
 789: PUSH
 790: LD_INT 47
 792: PUSH
 793: EMPTY
 794: LIST
 795: LIST
 796: LIST
 797: LIST
 798: PUSH
 799: LD_INT 24
 801: PUSH
 802: LD_INT 3
 804: PUSH
 805: LD_INT 3
 807: PUSH
 808: LD_INT 47
 810: PUSH
 811: EMPTY
 812: LIST
 813: LIST
 814: LIST
 815: LIST
 816: PUSH
 817: LD_INT 24
 819: PUSH
 820: LD_INT 3
 822: PUSH
 823: LD_INT 3
 825: PUSH
 826: LD_INT 47
 828: PUSH
 829: EMPTY
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: PUSH
 835: LD_INT 24
 837: PUSH
 838: LD_INT 3
 840: PUSH
 841: LD_INT 3
 843: PUSH
 844: LD_INT 47
 846: PUSH
 847: EMPTY
 848: LIST
 849: LIST
 850: LIST
 851: LIST
 852: PUSH
 853: EMPTY
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: LIST
 859: LIST
 860: LIST
 861: LIST
 862: PPUSH
 863: CALL 59431 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 867: LD_INT 2
 869: PPUSH
 870: LD_INT 5
 872: PPUSH
 873: CALL 59616 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 877: LD_INT 2
 879: PPUSH
 880: LD_INT 0
 882: PPUSH
 883: CALL 60046 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 14 , 15 ] [ Difficulty ] , legionMinefield ) ;
 887: LD_INT 3
 889: PPUSH
 890: LD_INT 10
 892: PUSH
 893: LD_INT 12
 895: PUSH
 896: LD_INT 14
 898: PUSH
 899: LD_INT 15
 901: PUSH
 902: EMPTY
 903: LIST
 904: LIST
 905: LIST
 906: LIST
 907: PUSH
 908: LD_OWVAR 67
 912: ARRAY
 913: PPUSH
 914: LD_INT 27
 916: PPUSH
 917: CALL 59113 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 921: LD_INT 3
 923: PPUSH
 924: LD_INT 10
 926: PUSH
 927: LD_INT 11
 929: PUSH
 930: LD_INT 13
 932: PUSH
 933: LD_INT 15
 935: PUSH
 936: EMPTY
 937: LIST
 938: LIST
 939: LIST
 940: LIST
 941: PPUSH
 942: CALL 60173 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 946: LD_INT 3
 948: PPUSH
 949: LD_INT 15
 951: PUSH
 952: EMPTY
 953: LIST
 954: PPUSH
 955: CALL 60266 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 959: LD_ADDR_EXP 145
 963: PUSH
 964: LD_EXP 145
 968: PPUSH
 969: LD_INT 3
 971: PPUSH
 972: LD_INT 22
 974: PUSH
 975: LD_INT 8
 977: PUSH
 978: EMPTY
 979: LIST
 980: LIST
 981: PUSH
 982: LD_INT 25
 984: PUSH
 985: LD_INT 15
 987: PUSH
 988: EMPTY
 989: LIST
 990: LIST
 991: PUSH
 992: EMPTY
 993: LIST
 994: LIST
 995: PPUSH
 996: CALL_OW 69
1000: PPUSH
1001: CALL_OW 1
1005: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
1006: LD_INT 3
1008: PPUSH
1009: LD_INT 13
1011: PUSH
1012: LD_INT 2
1014: PUSH
1015: LD_INT 1
1017: PUSH
1018: LD_INT 31
1020: PUSH
1021: EMPTY
1022: LIST
1023: LIST
1024: LIST
1025: LIST
1026: PUSH
1027: LD_INT 13
1029: PUSH
1030: LD_INT 2
1032: PUSH
1033: LD_INT 1
1035: PUSH
1036: LD_INT 31
1038: PUSH
1039: EMPTY
1040: LIST
1041: LIST
1042: LIST
1043: LIST
1044: PUSH
1045: LD_INT 13
1047: PUSH
1048: LD_INT 3
1050: PUSH
1051: LD_INT 2
1053: PUSH
1054: LD_INT 32
1056: PUSH
1057: EMPTY
1058: LIST
1059: LIST
1060: LIST
1061: LIST
1062: PUSH
1063: LD_INT 14
1065: PUSH
1066: LD_INT 1
1068: PUSH
1069: LD_INT 2
1071: PUSH
1072: LD_EXP 101
1076: PUSH
1077: EMPTY
1078: LIST
1079: LIST
1080: LIST
1081: LIST
1082: PUSH
1083: EMPTY
1084: LIST
1085: LIST
1086: LIST
1087: LIST
1088: PPUSH
1089: CALL 59431 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1093: LD_INT 4
1095: PPUSH
1096: LD_INT 10
1098: PUSH
1099: LD_INT 12
1101: PUSH
1102: EMPTY
1103: LIST
1104: LIST
1105: PPUSH
1106: CALL 60173 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1110: LD_INT 4
1112: PPUSH
1113: LD_INT 9
1115: PUSH
1116: EMPTY
1117: LIST
1118: PPUSH
1119: CALL 60266 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1123: LD_INT 4
1125: PPUSH
1126: LD_INT 26
1128: PUSH
1129: LD_INT 74
1131: PUSH
1132: LD_INT 107
1134: PUSH
1135: LD_INT 0
1137: PUSH
1138: EMPTY
1139: LIST
1140: LIST
1141: LIST
1142: LIST
1143: PUSH
1144: LD_INT 32
1146: PUSH
1147: LD_INT 77
1149: PUSH
1150: LD_INT 101
1152: PUSH
1153: LD_INT 4
1155: PUSH
1156: EMPTY
1157: LIST
1158: LIST
1159: LIST
1160: LIST
1161: PUSH
1162: LD_INT 32
1164: PUSH
1165: LD_INT 69
1167: PUSH
1168: LD_INT 86
1170: PUSH
1171: LD_INT 4
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: LIST
1178: LIST
1179: PUSH
1180: LD_INT 27
1182: PUSH
1183: LD_INT 77
1185: PUSH
1186: LD_INT 110
1188: PUSH
1189: LD_INT 3
1191: PUSH
1192: EMPTY
1193: LIST
1194: LIST
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 27
1200: PUSH
1201: LD_INT 42
1203: PUSH
1204: LD_INT 79
1206: PUSH
1207: LD_INT 5
1209: PUSH
1210: EMPTY
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: PUSH
1216: LD_INT 29
1218: PUSH
1219: LD_INT 86
1221: PUSH
1222: LD_INT 105
1224: PUSH
1225: LD_INT 2
1227: PUSH
1228: EMPTY
1229: LIST
1230: LIST
1231: LIST
1232: LIST
1233: PUSH
1234: LD_INT 30
1236: PUSH
1237: LD_INT 40
1239: PUSH
1240: LD_INT 75
1242: PUSH
1243: LD_INT 1
1245: PUSH
1246: EMPTY
1247: LIST
1248: LIST
1249: LIST
1250: LIST
1251: PUSH
1252: LD_INT 32
1254: PUSH
1255: LD_INT 80
1257: PUSH
1258: LD_INT 106
1260: PUSH
1261: LD_INT 4
1263: PUSH
1264: EMPTY
1265: LIST
1266: LIST
1267: LIST
1268: LIST
1269: PUSH
1270: LD_INT 32
1272: PUSH
1273: LD_INT 75
1275: PUSH
1276: LD_INT 114
1278: PUSH
1279: LD_INT 5
1281: PUSH
1282: EMPTY
1283: LIST
1284: LIST
1285: LIST
1286: LIST
1287: PUSH
1288: LD_INT 32
1290: PUSH
1291: LD_INT 82
1293: PUSH
1294: LD_INT 110
1296: PUSH
1297: LD_INT 5
1299: PUSH
1300: EMPTY
1301: LIST
1302: LIST
1303: LIST
1304: LIST
1305: PUSH
1306: LD_INT 32
1308: PUSH
1309: LD_INT 62
1311: PUSH
1312: LD_INT 78
1314: PUSH
1315: LD_INT 4
1317: PUSH
1318: EMPTY
1319: LIST
1320: LIST
1321: LIST
1322: LIST
1323: PUSH
1324: LD_INT 4
1326: PUSH
1327: LD_INT 39
1329: PUSH
1330: LD_INT 61
1332: PUSH
1333: LD_INT 3
1335: PUSH
1336: EMPTY
1337: LIST
1338: LIST
1339: LIST
1340: LIST
1341: PUSH
1342: EMPTY
1343: LIST
1344: LIST
1345: LIST
1346: LIST
1347: LIST
1348: LIST
1349: LIST
1350: LIST
1351: LIST
1352: LIST
1353: LIST
1354: LIST
1355: PPUSH
1356: CALL 59323 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1360: LD_INT 4
1362: PPUSH
1363: LD_INT 5
1365: PUSH
1366: LD_INT 6
1368: PUSH
1369: LD_INT 7
1371: PUSH
1372: LD_INT 9
1374: PUSH
1375: EMPTY
1376: LIST
1377: LIST
1378: LIST
1379: LIST
1380: PPUSH
1381: CALL 60584 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1385: LD_INT 4
1387: PPUSH
1388: LD_INT 40
1390: PUSH
1391: LD_INT 75
1393: PUSH
1394: LD_INT 1
1396: PUSH
1397: EMPTY
1398: LIST
1399: LIST
1400: LIST
1401: PUSH
1402: LD_INT 86
1404: PUSH
1405: LD_INT 105
1407: PUSH
1408: LD_INT 0
1410: PUSH
1411: EMPTY
1412: LIST
1413: LIST
1414: LIST
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: PPUSH
1420: CALL 59755 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1424: LD_INT 4
1426: PPUSH
1427: LD_INT 2
1429: PPUSH
1430: CALL 60046 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1434: LD_INT 4
1436: PPUSH
1437: LD_INT 0
1439: PPUSH
1440: CALL 60046 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1444: LD_INT 4
1446: PPUSH
1447: LD_INT 54
1449: PPUSH
1450: LD_INT 85
1452: PPUSH
1453: LD_INT 2
1455: PPUSH
1456: LD_INT 19
1458: PUSH
1459: LD_INT 16
1461: PUSH
1462: LD_INT 17
1464: PUSH
1465: LD_INT 18
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: PPUSH
1474: CALL 60378 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1478: LD_INT 4
1480: PPUSH
1481: LD_INT 3
1483: PUSH
1484: LD_INT 1
1486: PUSH
1487: LD_INT 1
1489: PUSH
1490: LD_INT 5
1492: PUSH
1493: EMPTY
1494: LIST
1495: LIST
1496: LIST
1497: LIST
1498: PUSH
1499: LD_INT 4
1501: PUSH
1502: LD_INT 1
1504: PUSH
1505: LD_INT 1
1507: PUSH
1508: LD_INT 6
1510: PUSH
1511: EMPTY
1512: LIST
1513: LIST
1514: LIST
1515: LIST
1516: PUSH
1517: LD_INT 4
1519: PUSH
1520: LD_INT 1
1522: PUSH
1523: LD_INT 1
1525: PUSH
1526: LD_INT 7
1528: PUSH
1529: EMPTY
1530: LIST
1531: LIST
1532: LIST
1533: LIST
1534: PUSH
1535: LD_INT 4
1537: PUSH
1538: LD_INT 1
1540: PUSH
1541: LD_INT 1
1543: PUSH
1544: LD_INT 6
1546: PUSH
1547: EMPTY
1548: LIST
1549: LIST
1550: LIST
1551: LIST
1552: PUSH
1553: EMPTY
1554: LIST
1555: LIST
1556: LIST
1557: LIST
1558: PPUSH
1559: CALL 59431 0 2
// MC_SetTame ( 4 , powellApe ) ;
1563: LD_INT 4
1565: PPUSH
1566: LD_INT 13
1568: PPUSH
1569: CALL 59997 0 2
// end ;
1573: LD_VAR 0 1
1577: RET
// every 0 0$1 trigger powellAngerQuery and powellAnger >= 2 do
1578: LD_EXP 36
1582: PUSH
1583: LD_EXP 17
1587: PUSH
1588: LD_INT 2
1590: GREATEREQUAL
1591: AND
1592: IFFALSE 1604
1594: GO 1596
1596: DISABLE
// SetAchievement ( ACH_POWELL ) ;
1597: LD_STRING ACH_POWELL
1599: PPUSH
1600: CALL_OW 543
1604: END
// every 0 0$1 trigger debug do var i , tmp ;
1605: LD_EXP 1
1609: IFFALSE 1716
1611: GO 1613
1613: DISABLE
1614: LD_INT 0
1616: PPUSH
1617: PPUSH
// begin enable ;
1618: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1619: LD_ADDR_VAR 0 2
1623: PUSH
1624: LD_INT 22
1626: PUSH
1627: LD_INT 1
1629: PUSH
1630: EMPTY
1631: LIST
1632: LIST
1633: PUSH
1634: LD_INT 3
1636: PUSH
1637: LD_INT 21
1639: PUSH
1640: LD_INT 3
1642: PUSH
1643: EMPTY
1644: LIST
1645: LIST
1646: PUSH
1647: EMPTY
1648: LIST
1649: LIST
1650: PUSH
1651: LD_INT 3
1653: PUSH
1654: LD_INT 24
1656: PUSH
1657: LD_INT 999
1659: PUSH
1660: EMPTY
1661: LIST
1662: LIST
1663: PUSH
1664: EMPTY
1665: LIST
1666: LIST
1667: PUSH
1668: EMPTY
1669: LIST
1670: LIST
1671: LIST
1672: PPUSH
1673: CALL_OW 69
1677: ST_TO_ADDR
// if not tmp then
1678: LD_VAR 0 2
1682: NOT
1683: IFFALSE 1687
// exit ;
1685: GO 1716
// for i in tmp do
1687: LD_ADDR_VAR 0 1
1691: PUSH
1692: LD_VAR 0 2
1696: PUSH
1697: FOR_IN
1698: IFFALSE 1714
// SetLives ( i , 1000 ) ;
1700: LD_VAR 0 1
1704: PPUSH
1705: LD_INT 1000
1707: PPUSH
1708: CALL_OW 234
1712: GO 1697
1714: POP
1715: POP
// end ; end_of_file
1716: PPOPN 2
1718: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1719: LD_INT 0
1721: PPUSH
// uc_side := 1 ;
1722: LD_ADDR_OWVAR 20
1726: PUSH
1727: LD_INT 1
1729: ST_TO_ADDR
// uc_nation := 1 ;
1730: LD_ADDR_OWVAR 21
1734: PUSH
1735: LD_INT 1
1737: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1738: LD_ADDR_EXP 39
1742: PUSH
1743: LD_STRING JMM
1745: PPUSH
1746: LD_EXP 1
1750: NOT
1751: PPUSH
1752: LD_STRING 14_
1754: PPUSH
1755: CALL 65885 0 3
1759: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1760: LD_EXP 4
1764: NOT
1765: PUSH
1766: LD_EXP 4
1770: PUSH
1771: LD_INT 1
1773: ARRAY
1774: PUSH
1775: LD_INT 1
1777: ARRAY
1778: NOT
1779: OR
1780: IFFALSE 1803
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) else
1782: LD_INT 5
1784: PPUSH
1785: LD_INT 3
1787: PPUSH
1788: LD_INT 1
1790: PPUSH
1791: LD_INT 9
1793: PPUSH
1794: LD_INT 100
1796: PPUSH
1797: CALL 70749 0 5
1801: GO 1862
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1803: LD_EXP 4
1807: PUSH
1808: LD_INT 1
1810: ARRAY
1811: PUSH
1812: LD_INT 1
1814: ARRAY
1815: PPUSH
1816: LD_EXP 4
1820: PUSH
1821: LD_INT 2
1823: ARRAY
1824: PUSH
1825: LD_INT 1
1827: ARRAY
1828: PPUSH
1829: LD_EXP 4
1833: PUSH
1834: LD_INT 3
1836: ARRAY
1837: PUSH
1838: LD_INT 1
1840: ARRAY
1841: PPUSH
1842: LD_EXP 4
1846: PUSH
1847: LD_INT 4
1849: ARRAY
1850: PUSH
1851: LD_INT 1
1853: ARRAY
1854: PPUSH
1855: LD_INT 30
1857: PPUSH
1858: CALL 70749 0 5
// JMMNewVeh := CreateVehicle ;
1862: LD_ADDR_EXP 56
1866: PUSH
1867: CALL_OW 45
1871: ST_TO_ADDR
// if not JMMNewVeh then
1872: LD_EXP 56
1876: NOT
1877: IFFALSE 1908
// begin PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_laser , 100 ) ;
1879: LD_INT 5
1881: PPUSH
1882: LD_INT 3
1884: PPUSH
1885: LD_INT 1
1887: PPUSH
1888: LD_INT 9
1890: PPUSH
1891: LD_INT 100
1893: PPUSH
1894: CALL 70749 0 5
// JMMNewVeh := CreateVehicle ;
1898: LD_ADDR_EXP 56
1902: PUSH
1903: CALL_OW 45
1907: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1908: LD_EXP 56
1912: PPUSH
1913: LD_INT 4
1915: PPUSH
1916: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1920: LD_EXP 56
1924: PPUSH
1925: LD_INT 79
1927: PPUSH
1928: LD_INT 91
1930: PPUSH
1931: LD_INT 0
1933: PPUSH
1934: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1938: LD_EXP 39
1942: PPUSH
1943: LD_EXP 56
1947: PPUSH
1948: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1952: LD_EXP 6
1956: PUSH
1957: LD_EXP 2
1961: NOT
1962: AND
1963: IFFALSE 2221
// begin if not JMMGirlVeh then
1965: LD_EXP 5
1969: NOT
1970: IFFALSE 1993
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1972: LD_INT 3
1974: PPUSH
1975: LD_INT 3
1977: PPUSH
1978: LD_INT 1
1980: PPUSH
1981: LD_INT 9
1983: PPUSH
1984: LD_INT 100
1986: PPUSH
1987: CALL 70749 0 5
1991: GO 2052
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1993: LD_EXP 5
1997: PUSH
1998: LD_INT 1
2000: ARRAY
2001: PUSH
2002: LD_INT 1
2004: ARRAY
2005: PPUSH
2006: LD_EXP 5
2010: PUSH
2011: LD_INT 2
2013: ARRAY
2014: PUSH
2015: LD_INT 1
2017: ARRAY
2018: PPUSH
2019: LD_EXP 5
2023: PUSH
2024: LD_INT 3
2026: ARRAY
2027: PUSH
2028: LD_INT 1
2030: ARRAY
2031: PPUSH
2032: LD_EXP 5
2036: PUSH
2037: LD_INT 4
2039: ARRAY
2040: PUSH
2041: LD_INT 1
2043: ARRAY
2044: PPUSH
2045: LD_INT 30
2047: PPUSH
2048: CALL 70749 0 5
// GirlNewVeh := CreateVehicle ;
2052: LD_ADDR_EXP 57
2056: PUSH
2057: CALL_OW 45
2061: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
2062: LD_EXP 57
2066: PPUSH
2067: LD_INT 4
2069: PPUSH
2070: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
2074: LD_EXP 57
2078: PPUSH
2079: LD_INT 82
2081: PPUSH
2082: LD_INT 96
2084: PPUSH
2085: LD_INT 0
2087: PPUSH
2088: CALL_OW 48
// if JMMGirl = 1 then
2092: LD_EXP 7
2096: PUSH
2097: LD_INT 1
2099: EQUAL
2100: IFFALSE 2135
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2102: LD_ADDR_EXP 40
2106: PUSH
2107: LD_STRING Joan
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: LD_STRING 14_
2115: PPUSH
2116: CALL 65885 0 3
2120: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2121: LD_EXP 40
2125: PPUSH
2126: LD_EXP 57
2130: PPUSH
2131: CALL_OW 52
// end ; if JMMGirl = 2 then
2135: LD_EXP 7
2139: PUSH
2140: LD_INT 2
2142: EQUAL
2143: IFFALSE 2178
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2145: LD_ADDR_EXP 42
2149: PUSH
2150: LD_STRING Lisa
2152: PPUSH
2153: LD_INT 1
2155: PPUSH
2156: LD_STRING 14_
2158: PPUSH
2159: CALL 65885 0 3
2163: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2164: LD_EXP 42
2168: PPUSH
2169: LD_EXP 57
2173: PPUSH
2174: CALL_OW 52
// end ; if JMMGirl = 3 then
2178: LD_EXP 7
2182: PUSH
2183: LD_INT 3
2185: EQUAL
2186: IFFALSE 2221
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2188: LD_ADDR_EXP 54
2192: PUSH
2193: LD_STRING Connie
2195: PPUSH
2196: LD_INT 1
2198: PPUSH
2199: LD_STRING 14_
2201: PPUSH
2202: CALL 65885 0 3
2206: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2207: LD_EXP 54
2211: PPUSH
2212: LD_EXP 57
2216: PPUSH
2217: CALL_OW 52
// end ; end ; end ;
2221: LD_VAR 0 1
2225: RET
// export function PrepareStevensSquad ; var tmp ; begin
2226: LD_INT 0
2228: PPUSH
2229: PPUSH
// uc_side := 1 ;
2230: LD_ADDR_OWVAR 20
2234: PUSH
2235: LD_INT 1
2237: ST_TO_ADDR
// uc_nation := 1 ;
2238: LD_ADDR_OWVAR 21
2242: PUSH
2243: LD_INT 1
2245: ST_TO_ADDR
// tmp := [ ] ;
2246: LD_ADDR_VAR 0 2
2250: PUSH
2251: EMPTY
2252: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2253: LD_ADDR_EXP 41
2257: PUSH
2258: LD_STRING Stevens
2260: PPUSH
2261: LD_EXP 1
2265: NOT
2266: PPUSH
2267: LD_STRING 13f_
2269: PPUSH
2270: CALL 65885 0 3
2274: ST_TO_ADDR
// if not Stevens then
2275: LD_EXP 41
2279: NOT
2280: IFFALSE 2336
// begin hc_name = Baker Smith ;
2282: LD_ADDR_OWVAR 26
2286: PUSH
2287: LD_STRING Baker Smith
2289: ST_TO_ADDR
// hc_gallery =  ;
2290: LD_ADDR_OWVAR 33
2294: PUSH
2295: LD_STRING 
2297: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2298: LD_INT 1
2300: PPUSH
2301: LD_INT 10
2303: PPUSH
2304: CALL_OW 384
// Baker = CreateHuman ;
2308: LD_ADDR_EXP 55
2312: PUSH
2313: CALL_OW 44
2317: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2318: LD_ADDR_VAR 0 2
2322: PUSH
2323: LD_VAR 0 2
2327: PUSH
2328: LD_EXP 55
2332: ADD
2333: ST_TO_ADDR
// end else
2334: GO 2352
// tmp := tmp ^ Stevens ;
2336: LD_ADDR_VAR 0 2
2340: PUSH
2341: LD_VAR 0 2
2345: PUSH
2346: LD_EXP 41
2350: ADD
2351: ST_TO_ADDR
// if not Lisa then
2352: LD_EXP 42
2356: NOT
2357: IFFALSE 2403
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2359: LD_ADDR_EXP 42
2363: PUSH
2364: LD_STRING Lisa
2366: PPUSH
2367: LD_EXP 1
2371: NOT
2372: PPUSH
2373: LD_STRING 13f_
2375: PPUSH
2376: CALL 65885 0 3
2380: ST_TO_ADDR
// if Lisa then
2381: LD_EXP 42
2385: IFFALSE 2403
// tmp := tmp ^ Lisa ;
2387: LD_ADDR_VAR 0 2
2391: PUSH
2392: LD_VAR 0 2
2396: PUSH
2397: LD_EXP 42
2401: ADD
2402: ST_TO_ADDR
// end ; if not Donaldson then
2403: LD_EXP 43
2407: NOT
2408: IFFALSE 2454
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2410: LD_ADDR_EXP 43
2414: PUSH
2415: LD_STRING Donaldson
2417: PPUSH
2418: LD_EXP 1
2422: NOT
2423: PPUSH
2424: LD_STRING 13f_
2426: PPUSH
2427: CALL 65885 0 3
2431: ST_TO_ADDR
// if Donaldson then
2432: LD_EXP 43
2436: IFFALSE 2454
// tmp := tmp ^ Donaldson ;
2438: LD_ADDR_VAR 0 2
2442: PUSH
2443: LD_VAR 0 2
2447: PUSH
2448: LD_EXP 43
2452: ADD
2453: ST_TO_ADDR
// end ; if not Bobby then
2454: LD_EXP 44
2458: NOT
2459: IFFALSE 2505
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2461: LD_ADDR_EXP 44
2465: PUSH
2466: LD_STRING Bobby
2468: PPUSH
2469: LD_EXP 1
2473: NOT
2474: PPUSH
2475: LD_STRING 13f_
2477: PPUSH
2478: CALL 65885 0 3
2482: ST_TO_ADDR
// if Bobby then
2483: LD_EXP 44
2487: IFFALSE 2505
// tmp := tmp ^ Bobby ;
2489: LD_ADDR_VAR 0 2
2493: PUSH
2494: LD_VAR 0 2
2498: PUSH
2499: LD_EXP 44
2503: ADD
2504: ST_TO_ADDR
// end ; if not Cyrus then
2505: LD_EXP 45
2509: NOT
2510: IFFALSE 2556
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2512: LD_ADDR_EXP 45
2516: PUSH
2517: LD_STRING Cyrus
2519: PPUSH
2520: LD_EXP 1
2524: NOT
2525: PPUSH
2526: LD_STRING 13f_
2528: PPUSH
2529: CALL 65885 0 3
2533: ST_TO_ADDR
// if Cyrus then
2534: LD_EXP 45
2538: IFFALSE 2556
// tmp := tmp ^ Cyrus ;
2540: LD_ADDR_VAR 0 2
2544: PUSH
2545: LD_VAR 0 2
2549: PUSH
2550: LD_EXP 45
2554: ADD
2555: ST_TO_ADDR
// end ; if not Brown then
2556: LD_EXP 47
2560: NOT
2561: IFFALSE 2607
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2563: LD_ADDR_EXP 47
2567: PUSH
2568: LD_STRING Brown
2570: PPUSH
2571: LD_EXP 1
2575: NOT
2576: PPUSH
2577: LD_STRING 13f_
2579: PPUSH
2580: CALL 65885 0 3
2584: ST_TO_ADDR
// if Brown then
2585: LD_EXP 47
2589: IFFALSE 2607
// tmp := tmp ^ Brown ;
2591: LD_ADDR_VAR 0 2
2595: PUSH
2596: LD_VAR 0 2
2600: PUSH
2601: LD_EXP 47
2605: ADD
2606: ST_TO_ADDR
// end ; if not Gladstone then
2607: LD_EXP 48
2611: NOT
2612: IFFALSE 2658
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2614: LD_ADDR_EXP 48
2618: PUSH
2619: LD_STRING Gladstone
2621: PPUSH
2622: LD_EXP 1
2626: NOT
2627: PPUSH
2628: LD_STRING 13f_
2630: PPUSH
2631: CALL 65885 0 3
2635: ST_TO_ADDR
// if Gladstone then
2636: LD_EXP 48
2640: IFFALSE 2658
// tmp := tmp ^ Gladstone ;
2642: LD_ADDR_VAR 0 2
2646: PUSH
2647: LD_VAR 0 2
2651: PUSH
2652: LD_EXP 48
2656: ADD
2657: ST_TO_ADDR
// end ; if not Houten then
2658: LD_EXP 49
2662: NOT
2663: IFFALSE 2709
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2665: LD_ADDR_EXP 49
2669: PUSH
2670: LD_STRING Houten
2672: PPUSH
2673: LD_EXP 1
2677: NOT
2678: PPUSH
2679: LD_STRING 13f_
2681: PPUSH
2682: CALL 65885 0 3
2686: ST_TO_ADDR
// if Houten then
2687: LD_EXP 49
2691: IFFALSE 2709
// tmp := tmp ^ Houten ;
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 2
2702: PUSH
2703: LD_EXP 49
2707: ADD
2708: ST_TO_ADDR
// end ; if not Cornel then
2709: LD_EXP 50
2713: NOT
2714: IFFALSE 2760
// begin Cornel := PrepareUnit ( Cornell , ( not debug ) , 13f_ ) ;
2716: LD_ADDR_EXP 50
2720: PUSH
2721: LD_STRING Cornell
2723: PPUSH
2724: LD_EXP 1
2728: NOT
2729: PPUSH
2730: LD_STRING 13f_
2732: PPUSH
2733: CALL 65885 0 3
2737: ST_TO_ADDR
// if Cornel then
2738: LD_EXP 50
2742: IFFALSE 2760
// tmp := tmp ^ Cornel ;
2744: LD_ADDR_VAR 0 2
2748: PUSH
2749: LD_VAR 0 2
2753: PUSH
2754: LD_EXP 50
2758: ADD
2759: ST_TO_ADDR
// end ; if not Gary then
2760: LD_EXP 51
2764: NOT
2765: IFFALSE 2811
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2767: LD_ADDR_EXP 51
2771: PUSH
2772: LD_STRING Gary
2774: PPUSH
2775: LD_EXP 1
2779: NOT
2780: PPUSH
2781: LD_STRING 13f_
2783: PPUSH
2784: CALL 65885 0 3
2788: ST_TO_ADDR
// if Gary then
2789: LD_EXP 51
2793: IFFALSE 2811
// tmp := tmp ^ Gary ;
2795: LD_ADDR_VAR 0 2
2799: PUSH
2800: LD_VAR 0 2
2804: PUSH
2805: LD_EXP 51
2809: ADD
2810: ST_TO_ADDR
// end ; if not Frank then
2811: LD_EXP 52
2815: NOT
2816: IFFALSE 2862
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2818: LD_ADDR_EXP 52
2822: PUSH
2823: LD_STRING Frank
2825: PPUSH
2826: LD_EXP 1
2830: NOT
2831: PPUSH
2832: LD_STRING 13f_
2834: PPUSH
2835: CALL 65885 0 3
2839: ST_TO_ADDR
// if Frank then
2840: LD_EXP 52
2844: IFFALSE 2862
// tmp := tmp ^ Frank ;
2846: LD_ADDR_VAR 0 2
2850: PUSH
2851: LD_VAR 0 2
2855: PUSH
2856: LD_EXP 52
2860: ADD
2861: ST_TO_ADDR
// end ; if not Kikuchi then
2862: LD_EXP 53
2866: NOT
2867: IFFALSE 2913
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2869: LD_ADDR_EXP 53
2873: PUSH
2874: LD_STRING Kikuchi
2876: PPUSH
2877: LD_EXP 1
2881: NOT
2882: PPUSH
2883: LD_STRING 13f_
2885: PPUSH
2886: CALL 65885 0 3
2890: ST_TO_ADDR
// if Kikuchi then
2891: LD_EXP 53
2895: IFFALSE 2913
// tmp := tmp ^ Kikuchi ;
2897: LD_ADDR_VAR 0 2
2901: PUSH
2902: LD_VAR 0 2
2906: PUSH
2907: LD_EXP 53
2911: ADD
2912: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2913: LD_ADDR_VAR 0 2
2917: PUSH
2918: LD_VAR 0 2
2922: PUSH
2923: LD_STRING 13_other_survivors
2925: PPUSH
2926: CALL_OW 31
2930: UNION
2931: ST_TO_ADDR
// result := tmp ;
2932: LD_ADDR_VAR 0 1
2936: PUSH
2937: LD_VAR 0 2
2941: ST_TO_ADDR
// end ; end_of_file
2942: LD_VAR 0 1
2946: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2947: LD_INT 0
2949: PPUSH
2950: PPUSH
2951: PPUSH
2952: PPUSH
2953: PPUSH
2954: PPUSH
2955: PPUSH
2956: PPUSH
2957: PPUSH
2958: PPUSH
// uc_side := 4 ;
2959: LD_ADDR_OWVAR 20
2963: PUSH
2964: LD_INT 4
2966: ST_TO_ADDR
// uc_nation := 1 ;
2967: LD_ADDR_OWVAR 21
2971: PUSH
2972: LD_INT 1
2974: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , [ 3500 , 3000 , 2500 , 2000 ] [ Difficulty ] ) ;
2975: LD_INT 387
2977: PPUSH
2978: CALL_OW 274
2982: PPUSH
2983: LD_INT 1
2985: PPUSH
2986: LD_INT 3500
2988: PUSH
2989: LD_INT 3000
2991: PUSH
2992: LD_INT 2500
2994: PUSH
2995: LD_INT 2000
2997: PUSH
2998: EMPTY
2999: LIST
3000: LIST
3001: LIST
3002: LIST
3003: PUSH
3004: LD_OWVAR 67
3008: ARRAY
3009: PPUSH
3010: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
3014: LD_INT 387
3016: PPUSH
3017: CALL_OW 274
3021: PPUSH
3022: LD_INT 2
3024: PPUSH
3025: LD_INT 400
3027: PPUSH
3028: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
3032: LD_INT 387
3034: PPUSH
3035: CALL_OW 274
3039: PPUSH
3040: LD_INT 3
3042: PPUSH
3043: LD_INT 10
3045: PPUSH
3046: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
3050: LD_ADDR_EXP 58
3054: PUSH
3055: LD_STRING Powell
3057: PPUSH
3058: CALL_OW 25
3062: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
3063: LD_EXP 58
3067: PPUSH
3068: LD_INT 57
3070: PPUSH
3071: LD_INT 94
3073: PPUSH
3074: LD_INT 0
3076: PPUSH
3077: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
3081: LD_EXP 58
3085: PPUSH
3086: LD_INT 58
3088: PPUSH
3089: LD_INT 94
3091: PPUSH
3092: CALL_OW 118
// vip := [ ] ;
3096: LD_ADDR_EXP 59
3100: PUSH
3101: EMPTY
3102: ST_TO_ADDR
// tmp := [ ] ;
3103: LD_ADDR_VAR 0 6
3107: PUSH
3108: EMPTY
3109: ST_TO_ADDR
// if JMMGirl <> 2 then
3110: LD_EXP 7
3114: PUSH
3115: LD_INT 2
3117: NONEQUAL
3118: IFFALSE 3142
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3120: LD_ADDR_EXP 42
3124: PUSH
3125: LD_STRING Lisa
3127: PPUSH
3128: LD_EXP 1
3132: NOT
3133: PPUSH
3134: LD_STRING 13s_
3136: PPUSH
3137: CALL 65885 0 3
3141: ST_TO_ADDR
// if Lisa then
3142: LD_EXP 42
3146: IFFALSE 3164
// tmp := tmp ^ Lisa ;
3148: LD_ADDR_VAR 0 6
3152: PUSH
3153: LD_VAR 0 6
3157: PUSH
3158: LD_EXP 42
3162: ADD
3163: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3164: LD_ADDR_EXP 43
3168: PUSH
3169: LD_STRING Donaldson
3171: PPUSH
3172: LD_EXP 1
3176: NOT
3177: PPUSH
3178: LD_STRING 13s_
3180: PPUSH
3181: CALL 65885 0 3
3185: ST_TO_ADDR
// if Donaldson then
3186: LD_EXP 43
3190: IFFALSE 3208
// tmp := tmp ^ Donaldson ;
3192: LD_ADDR_VAR 0 6
3196: PUSH
3197: LD_VAR 0 6
3201: PUSH
3202: LD_EXP 43
3206: ADD
3207: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3208: LD_ADDR_EXP 44
3212: PUSH
3213: LD_STRING Bobby
3215: PPUSH
3216: LD_EXP 1
3220: NOT
3221: PPUSH
3222: LD_STRING 13s_
3224: PPUSH
3225: CALL 65885 0 3
3229: ST_TO_ADDR
// if Bobby then
3230: LD_EXP 44
3234: IFFALSE 3252
// tmp := tmp ^ Bobby ;
3236: LD_ADDR_VAR 0 6
3240: PUSH
3241: LD_VAR 0 6
3245: PUSH
3246: LD_EXP 44
3250: ADD
3251: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3252: LD_ADDR_EXP 45
3256: PUSH
3257: LD_STRING Cyrus
3259: PPUSH
3260: LD_EXP 1
3264: NOT
3265: PPUSH
3266: LD_STRING 13s_
3268: PPUSH
3269: CALL 65885 0 3
3273: ST_TO_ADDR
// if Cyrus then
3274: LD_EXP 45
3278: IFFALSE 3296
// tmp := tmp ^ Cyrus ;
3280: LD_ADDR_VAR 0 6
3284: PUSH
3285: LD_VAR 0 6
3289: PUSH
3290: LD_EXP 45
3294: ADD
3295: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3296: LD_ADDR_EXP 46
3300: PUSH
3301: LD_STRING Denis
3303: PPUSH
3304: LD_EXP 1
3308: NOT
3309: PPUSH
3310: LD_STRING 13s_
3312: PPUSH
3313: CALL 65885 0 3
3317: ST_TO_ADDR
// if not Denis then
3318: LD_EXP 46
3322: NOT
3323: IFFALSE 3347
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3325: LD_ADDR_EXP 46
3329: PUSH
3330: LD_STRING Denis
3332: PPUSH
3333: LD_EXP 1
3337: NOT
3338: PPUSH
3339: LD_STRING 13f_
3341: PPUSH
3342: CALL 65885 0 3
3346: ST_TO_ADDR
// if Denis then
3347: LD_EXP 46
3351: IFFALSE 3369
// tmp := tmp ^ Denis ;
3353: LD_ADDR_VAR 0 6
3357: PUSH
3358: LD_VAR 0 6
3362: PUSH
3363: LD_EXP 46
3367: ADD
3368: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3369: LD_ADDR_EXP 47
3373: PUSH
3374: LD_STRING Brown
3376: PPUSH
3377: LD_EXP 1
3381: NOT
3382: PPUSH
3383: LD_STRING 13s_
3385: PPUSH
3386: CALL 65885 0 3
3390: ST_TO_ADDR
// if Brown then
3391: LD_EXP 47
3395: IFFALSE 3413
// tmp := tmp ^ Brown ;
3397: LD_ADDR_VAR 0 6
3401: PUSH
3402: LD_VAR 0 6
3406: PUSH
3407: LD_EXP 47
3411: ADD
3412: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3413: LD_ADDR_EXP 48
3417: PUSH
3418: LD_STRING Gladstone
3420: PPUSH
3421: LD_EXP 1
3425: NOT
3426: PPUSH
3427: LD_STRING 13s_
3429: PPUSH
3430: CALL 65885 0 3
3434: ST_TO_ADDR
// if Gladstone then
3435: LD_EXP 48
3439: IFFALSE 3457
// tmp := tmp ^ Gladstone ;
3441: LD_ADDR_VAR 0 6
3445: PUSH
3446: LD_VAR 0 6
3450: PUSH
3451: LD_EXP 48
3455: ADD
3456: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3457: LD_ADDR_EXP 49
3461: PUSH
3462: LD_STRING Houten
3464: PPUSH
3465: LD_EXP 1
3469: NOT
3470: PPUSH
3471: LD_STRING 13s_
3473: PPUSH
3474: CALL 65885 0 3
3478: ST_TO_ADDR
// if Houten then
3479: LD_EXP 49
3483: IFFALSE 3501
// tmp := tmp ^ Houten ;
3485: LD_ADDR_VAR 0 6
3489: PUSH
3490: LD_VAR 0 6
3494: PUSH
3495: LD_EXP 49
3499: ADD
3500: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3501: LD_ADDR_EXP 50
3505: PUSH
3506: LD_STRING Cornel
3508: PPUSH
3509: LD_EXP 1
3513: NOT
3514: PPUSH
3515: LD_STRING 13s_
3517: PPUSH
3518: CALL 65885 0 3
3522: ST_TO_ADDR
// if Cornel then
3523: LD_EXP 50
3527: IFFALSE 3545
// tmp := tmp ^ Cornel ;
3529: LD_ADDR_VAR 0 6
3533: PUSH
3534: LD_VAR 0 6
3538: PUSH
3539: LD_EXP 50
3543: ADD
3544: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3545: LD_ADDR_EXP 51
3549: PUSH
3550: LD_STRING Gary
3552: PPUSH
3553: LD_EXP 1
3557: NOT
3558: PPUSH
3559: LD_STRING 13s_
3561: PPUSH
3562: CALL 65885 0 3
3566: ST_TO_ADDR
// if Gary then
3567: LD_EXP 51
3571: IFFALSE 3589
// tmp := tmp ^ Gary ;
3573: LD_ADDR_VAR 0 6
3577: PUSH
3578: LD_VAR 0 6
3582: PUSH
3583: LD_EXP 51
3587: ADD
3588: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3589: LD_ADDR_EXP 52
3593: PUSH
3594: LD_STRING Frank
3596: PPUSH
3597: LD_EXP 1
3601: NOT
3602: PPUSH
3603: LD_STRING 13s_
3605: PPUSH
3606: CALL 65885 0 3
3610: ST_TO_ADDR
// if Frank then
3611: LD_EXP 52
3615: IFFALSE 3633
// tmp := tmp ^ Frank ;
3617: LD_ADDR_VAR 0 6
3621: PUSH
3622: LD_VAR 0 6
3626: PUSH
3627: LD_EXP 52
3631: ADD
3632: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3633: LD_ADDR_EXP 53
3637: PUSH
3638: LD_STRING Kikuchi
3640: PPUSH
3641: LD_EXP 1
3645: NOT
3646: PPUSH
3647: LD_STRING 13s_
3649: PPUSH
3650: CALL 65885 0 3
3654: ST_TO_ADDR
// if Kikuchi then
3655: LD_EXP 53
3659: IFFALSE 3677
// tmp := tmp ^ Kikuchi ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: LD_EXP 53
3675: ADD
3676: ST_TO_ADDR
// vip := tmp ;
3677: LD_ADDR_EXP 59
3681: PUSH
3682: LD_VAR 0 6
3686: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3687: LD_ADDR_VAR 0 6
3691: PUSH
3692: LD_VAR 0 6
3696: PUSH
3697: LD_STRING 13s_others
3699: PPUSH
3700: CALL_OW 31
3704: UNION
3705: ST_TO_ADDR
// if tmp < 18 then
3706: LD_VAR 0 6
3710: PUSH
3711: LD_INT 18
3713: LESS
3714: IFFALSE 3781
// for i = 1 to 18 - tmp do
3716: LD_ADDR_VAR 0 2
3720: PUSH
3721: DOUBLE
3722: LD_INT 1
3724: DEC
3725: ST_TO_ADDR
3726: LD_INT 18
3728: PUSH
3729: LD_VAR 0 6
3733: MINUS
3734: PUSH
3735: FOR_TO
3736: IFFALSE 3779
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3738: LD_INT 1
3740: PPUSH
3741: LD_VAR 0 2
3745: PUSH
3746: LD_INT 4
3748: MOD
3749: PUSH
3750: LD_INT 1
3752: PLUS
3753: PPUSH
3754: LD_INT 5
3756: PPUSH
3757: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3761: LD_ADDR_VAR 0 6
3765: PUSH
3766: LD_VAR 0 6
3770: PUSH
3771: CALL_OW 44
3775: ADD
3776: ST_TO_ADDR
// end ;
3777: GO 3735
3779: POP
3780: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3781: LD_ADDR_VAR 0 7
3785: PUSH
3786: LD_INT 22
3788: PUSH
3789: LD_INT 4
3791: PUSH
3792: EMPTY
3793: LIST
3794: LIST
3795: PUSH
3796: LD_INT 30
3798: PUSH
3799: LD_INT 0
3801: PUSH
3802: EMPTY
3803: LIST
3804: LIST
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PPUSH
3810: CALL_OW 69
3814: PUSH
3815: LD_INT 1
3817: ARRAY
3818: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3819: LD_ADDR_VAR 0 8
3823: PUSH
3824: LD_INT 22
3826: PUSH
3827: LD_INT 4
3829: PUSH
3830: EMPTY
3831: LIST
3832: LIST
3833: PUSH
3834: LD_INT 30
3836: PUSH
3837: LD_INT 6
3839: PUSH
3840: EMPTY
3841: LIST
3842: LIST
3843: PUSH
3844: EMPTY
3845: LIST
3846: LIST
3847: PPUSH
3848: CALL_OW 69
3852: PUSH
3853: LD_INT 1
3855: ARRAY
3856: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3857: LD_ADDR_VAR 0 9
3861: PUSH
3862: LD_INT 22
3864: PUSH
3865: LD_INT 4
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: PUSH
3872: LD_INT 30
3874: PUSH
3875: LD_INT 4
3877: PUSH
3878: EMPTY
3879: LIST
3880: LIST
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PPUSH
3886: CALL_OW 69
3890: PUSH
3891: LD_INT 1
3893: ARRAY
3894: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3895: LD_ADDR_VAR 0 10
3899: PUSH
3900: LD_INT 22
3902: PUSH
3903: LD_INT 4
3905: PUSH
3906: EMPTY
3907: LIST
3908: LIST
3909: PUSH
3910: LD_INT 30
3912: PUSH
3913: LD_INT 2
3915: PUSH
3916: EMPTY
3917: LIST
3918: LIST
3919: PUSH
3920: EMPTY
3921: LIST
3922: LIST
3923: PPUSH
3924: CALL_OW 69
3928: PUSH
3929: LD_INT 1
3931: ARRAY
3932: ST_TO_ADDR
// for i in tmp do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: LD_VAR 0 6
3942: PUSH
3943: FOR_IN
3944: IFFALSE 4070
// begin cl := GetClass ( i ) ;
3946: LD_ADDR_VAR 0 5
3950: PUSH
3951: LD_VAR 0 2
3955: PPUSH
3956: CALL_OW 257
3960: ST_TO_ADDR
// if cl > 4 then
3961: LD_VAR 0 5
3965: PUSH
3966: LD_INT 4
3968: GREATER
3969: IFFALSE 3979
// cl := 1 ;
3971: LD_ADDR_VAR 0 5
3975: PUSH
3976: LD_INT 1
3978: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3979: LD_ADDR_VAR 0 3
3983: PUSH
3984: LD_VAR 0 9
3988: PUSH
3989: LD_VAR 0 7
3993: PUSH
3994: LD_VAR 0 10
3998: PUSH
3999: LD_VAR 0 8
4003: PUSH
4004: EMPTY
4005: LIST
4006: LIST
4007: LIST
4008: LIST
4009: PUSH
4010: LD_VAR 0 5
4014: ARRAY
4015: ST_TO_ADDR
// if UnitsInside ( b ) < 6 then
4016: LD_VAR 0 3
4020: PPUSH
4021: CALL_OW 313
4025: PUSH
4026: LD_INT 6
4028: LESS
4029: IFFALSE 4047
// PlaceHumanInUnit ( i , b ) else
4031: LD_VAR 0 2
4035: PPUSH
4036: LD_VAR 0 3
4040: PPUSH
4041: CALL_OW 52
4045: GO 4068
// PlaceUnitXYR ( i , 61 , 89 , 6 , false ) ;
4047: LD_VAR 0 2
4051: PPUSH
4052: LD_INT 61
4054: PPUSH
4055: LD_INT 89
4057: PPUSH
4058: LD_INT 6
4060: PPUSH
4061: LD_INT 0
4063: PPUSH
4064: CALL_OW 50
// end ;
4068: GO 3943
4070: POP
4071: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
4072: LD_INT 2
4074: PPUSH
4075: LD_INT 1
4077: PPUSH
4078: LD_INT 1
4080: PPUSH
4081: LD_INT 12
4083: PPUSH
4084: LD_INT 100
4086: PPUSH
4087: CALL 70749 0 5
// veh := CreateVehicle ;
4091: LD_ADDR_VAR 0 4
4095: PUSH
4096: CALL_OW 45
4100: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4101: LD_VAR 0 4
4105: PPUSH
4106: LD_INT 4
4108: PPUSH
4109: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4113: LD_VAR 0 4
4117: PPUSH
4118: LD_INT 49
4120: PPUSH
4121: LD_INT 88
4123: PPUSH
4124: LD_INT 0
4126: PPUSH
4127: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4131: LD_VAR 0 4
4135: PPUSH
4136: LD_INT 1
4138: PPUSH
4139: LD_INT 100
4141: PPUSH
4142: CALL_OW 290
// uc_side := 0 ;
4146: LD_ADDR_OWVAR 20
4150: PUSH
4151: LD_INT 0
4153: ST_TO_ADDR
// uc_nation := 0 ;
4154: LD_ADDR_OWVAR 21
4158: PUSH
4159: LD_INT 0
4161: ST_TO_ADDR
// for i = 1 to 4 do
4162: LD_ADDR_VAR 0 2
4166: PUSH
4167: DOUBLE
4168: LD_INT 1
4170: DEC
4171: ST_TO_ADDR
4172: LD_INT 4
4174: PUSH
4175: FOR_TO
4176: IFFALSE 4207
// begin InitHc ;
4178: CALL_OW 19
// hc_class := class_apeman ;
4182: LD_ADDR_OWVAR 28
4186: PUSH
4187: LD_INT 12
4189: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4190: CALL_OW 44
4194: PPUSH
4195: LD_INT 13
4197: PPUSH
4198: LD_INT 0
4200: PPUSH
4201: CALL_OW 49
// end ;
4205: GO 4175
4207: POP
4208: POP
// end ; end_of_file
4209: LD_VAR 0 1
4213: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4214: LD_INT 0
4216: PPUSH
4217: PPUSH
4218: PPUSH
4219: PPUSH
4220: PPUSH
// side := 8 ;
4221: LD_ADDR_VAR 0 3
4225: PUSH
4226: LD_INT 8
4228: ST_TO_ADDR
// uc_side := side ;
4229: LD_ADDR_OWVAR 20
4233: PUSH
4234: LD_VAR 0 3
4238: ST_TO_ADDR
// uc_nation := 2 ;
4239: LD_ADDR_OWVAR 21
4243: PUSH
4244: LD_INT 2
4246: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4247: LD_ADDR_VAR 0 2
4251: PUSH
4252: LD_INT 22
4254: PUSH
4255: LD_VAR 0 3
4259: PUSH
4260: EMPTY
4261: LIST
4262: LIST
4263: PUSH
4264: LD_INT 21
4266: PUSH
4267: LD_INT 3
4269: PUSH
4270: EMPTY
4271: LIST
4272: LIST
4273: PUSH
4274: EMPTY
4275: LIST
4276: LIST
4277: PPUSH
4278: CALL_OW 69
4282: PUSH
4283: FOR_IN
4284: IFFALSE 4300
// SetBLevel ( i , 10 ) ;
4286: LD_VAR 0 2
4290: PPUSH
4291: LD_INT 10
4293: PPUSH
4294: CALL_OW 241
4298: GO 4283
4300: POP
4301: POP
// if KurtStatus then
4302: LD_EXP 3
4306: IFFALSE 4329
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4308: LD_ADDR_EXP 60
4312: PUSH
4313: LD_STRING Kurt
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: LD_STRING 
4321: PPUSH
4322: CALL 65885 0 3
4326: ST_TO_ADDR
4327: GO 4351
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4329: LD_ADDR_EXP 60
4333: PUSH
4334: LD_STRING AltKurt
4336: PPUSH
4337: LD_EXP 1
4341: NOT
4342: PPUSH
4343: LD_STRING 
4345: PPUSH
4346: CALL 65885 0 3
4350: ST_TO_ADDR
// if not Kurt then
4351: LD_EXP 60
4355: NOT
4356: IFFALSE 4382
// begin InitHc ;
4358: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4362: LD_INT 1
4364: PPUSH
4365: LD_INT 10
4367: PPUSH
4368: CALL_OW 381
// Kurt := CreateHuman ;
4372: LD_ADDR_EXP 60
4376: PUSH
4377: CALL_OW 44
4381: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4382: LD_EXP 60
4386: PPUSH
4387: LD_INT 324
4389: PPUSH
4390: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4394: LD_ADDR_EXP 61
4398: PUSH
4399: LD_STRING Kozlov
4401: PPUSH
4402: LD_INT 0
4404: PPUSH
4405: LD_STRING 
4407: PPUSH
4408: CALL 65885 0 3
4412: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4413: LD_EXP 61
4417: PPUSH
4418: LD_INT 22
4420: PUSH
4421: LD_INT 8
4423: PUSH
4424: EMPTY
4425: LIST
4426: LIST
4427: PUSH
4428: LD_INT 23
4430: PUSH
4431: LD_INT 3
4433: PUSH
4434: EMPTY
4435: LIST
4436: LIST
4437: PUSH
4438: LD_INT 30
4440: PUSH
4441: LD_INT 8
4443: PUSH
4444: EMPTY
4445: LIST
4446: LIST
4447: PUSH
4448: EMPTY
4449: LIST
4450: LIST
4451: LIST
4452: PPUSH
4453: CALL_OW 69
4457: PUSH
4458: LD_INT 1
4460: ARRAY
4461: PPUSH
4462: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4466: LD_EXP 61
4470: PPUSH
4471: LD_INT 3
4473: PPUSH
4474: LD_INT 10
4476: PPUSH
4477: CALL_OW 237
// SetSkill ( Kozlov , class_scientistic , 10 ) ;
4481: LD_EXP 61
4485: PPUSH
4486: LD_INT 4
4488: PPUSH
4489: LD_INT 10
4491: PPUSH
4492: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4496: LD_ADDR_VAR 0 5
4500: PUSH
4501: LD_INT 22
4503: PUSH
4504: LD_VAR 0 3
4508: PUSH
4509: EMPTY
4510: LIST
4511: LIST
4512: PUSH
4513: LD_INT 30
4515: PUSH
4516: LD_INT 32
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PUSH
4523: LD_INT 58
4525: PUSH
4526: EMPTY
4527: LIST
4528: PUSH
4529: EMPTY
4530: LIST
4531: LIST
4532: LIST
4533: PPUSH
4534: CALL_OW 69
4538: ST_TO_ADDR
// for i = 1 to 10 do
4539: LD_ADDR_VAR 0 2
4543: PUSH
4544: DOUBLE
4545: LD_INT 1
4547: DEC
4548: ST_TO_ADDR
4549: LD_INT 10
4551: PUSH
4552: FOR_TO
4553: IFFALSE 4625
// begin uc_nation := nation_nature ;
4555: LD_ADDR_OWVAR 21
4559: PUSH
4560: LD_INT 0
4562: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4563: LD_ADDR_OWVAR 28
4567: PUSH
4568: LD_INT 15
4570: ST_TO_ADDR
// hc_gallery :=  ;
4571: LD_ADDR_OWVAR 33
4575: PUSH
4576: LD_STRING 
4578: ST_TO_ADDR
// hc_name :=  ;
4579: LD_ADDR_OWVAR 26
4583: PUSH
4584: LD_STRING 
4586: ST_TO_ADDR
// un := CreateHuman ;
4587: LD_ADDR_VAR 0 4
4591: PUSH
4592: CALL_OW 44
4596: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4597: LD_VAR 0 4
4601: PPUSH
4602: LD_VAR 0 5
4606: PUSH
4607: LD_VAR 0 5
4611: PUSH
4612: LD_VAR 0 2
4616: MINUS
4617: ARRAY
4618: PPUSH
4619: CALL_OW 52
// end ;
4623: GO 4552
4625: POP
4626: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4627: LD_ADDR_VAR 0 5
4631: PUSH
4632: LD_STRING 12_kurt_squad
4634: PPUSH
4635: CALL_OW 31
4639: ST_TO_ADDR
// if tmp then
4640: LD_VAR 0 5
4644: IFFALSE 4678
// for i in tmp do
4646: LD_ADDR_VAR 0 2
4650: PUSH
4651: LD_VAR 0 5
4655: PUSH
4656: FOR_IN
4657: IFFALSE 4676
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4659: LD_VAR 0 2
4663: PPUSH
4664: LD_INT 5
4666: PPUSH
4667: LD_INT 0
4669: PPUSH
4670: CALL_OW 49
4674: GO 4656
4676: POP
4677: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4678: LD_INT 324
4680: PPUSH
4681: LD_INT 5
4683: PPUSH
4684: LD_STRING 
4686: PPUSH
4687: LD_INT 8
4689: PUSH
4690: LD_INT 9
4692: PUSH
4693: LD_INT 10
4695: PUSH
4696: LD_INT 10
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: LIST
4703: LIST
4704: PUSH
4705: LD_OWVAR 67
4709: ARRAY
4710: PPUSH
4711: LD_INT 3000
4713: PUSH
4714: LD_INT 500
4716: PUSH
4717: LD_INT 150
4719: PUSH
4720: EMPTY
4721: LIST
4722: LIST
4723: LIST
4724: PPUSH
4725: LD_INT 16
4727: PUSH
4728: LD_INT 6
4730: PUSH
4731: LD_INT 6
4733: PUSH
4734: LD_INT 8
4736: PUSH
4737: EMPTY
4738: LIST
4739: LIST
4740: LIST
4741: LIST
4742: PPUSH
4743: CALL 74195 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4747: LD_ADDR_EXP 116
4751: PUSH
4752: LD_EXP 116
4756: PPUSH
4757: LD_INT 3
4759: PPUSH
4760: LD_INT 22
4762: PUSH
4763: LD_VAR 0 3
4767: PUSH
4768: EMPTY
4769: LIST
4770: LIST
4771: PUSH
4772: LD_INT 23
4774: PUSH
4775: LD_INT 2
4777: PUSH
4778: EMPTY
4779: LIST
4780: LIST
4781: PUSH
4782: LD_INT 3
4784: PUSH
4785: LD_INT 21
4787: PUSH
4788: LD_INT 2
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PUSH
4795: EMPTY
4796: LIST
4797: LIST
4798: PUSH
4799: EMPTY
4800: LIST
4801: LIST
4802: LIST
4803: PPUSH
4804: CALL_OW 69
4808: PUSH
4809: LD_EXP 60
4813: DIFF
4814: PPUSH
4815: CALL_OW 1
4819: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4820: LD_INT 1
4822: PPUSH
4823: LD_INT 7
4825: PPUSH
4826: CALL_OW 383
// Friend := CreateHuman ;
4830: LD_ADDR_EXP 62
4834: PUSH
4835: CALL_OW 44
4839: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4840: LD_INT 14
4842: PPUSH
4843: LD_INT 3
4845: PPUSH
4846: LD_INT 1
4848: PPUSH
4849: LD_INT 29
4851: PPUSH
4852: LD_INT 100
4854: PPUSH
4855: CALL 70749 0 5
// powellBomb := CreateVehicle ;
4859: LD_ADDR_EXP 63
4863: PUSH
4864: CALL_OW 45
4868: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4869: LD_EXP 63
4873: PPUSH
4874: LD_INT 90
4876: PPUSH
4877: LD_INT 51
4879: PPUSH
4880: LD_INT 0
4882: PPUSH
4883: CALL_OW 48
// end ;
4887: LD_VAR 0 1
4891: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4892: LD_INT 0
4894: PPUSH
4895: PPUSH
4896: PPUSH
// if IsLive ( kozlov_fac ) then
4897: LD_INT 332
4899: PPUSH
4900: CALL_OW 300
4904: IFFALSE 4908
// exit ;
4906: GO 5475
// ComExitBuilding ( Kozlov ) ;
4908: LD_EXP 61
4912: PPUSH
4913: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4917: LD_EXP 61
4921: PPUSH
4922: CALL_OW 257
4926: PUSH
4927: LD_INT 2
4929: NONEQUAL
4930: IFFALSE 4965
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4932: LD_EXP 61
4936: PPUSH
4937: LD_INT 324
4939: PPUSH
4940: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4944: LD_EXP 61
4948: PPUSH
4949: LD_INT 2
4951: PPUSH
4952: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4956: LD_EXP 61
4960: PPUSH
4961: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4965: LD_EXP 61
4969: PPUSH
4970: LD_INT 2
4972: PPUSH
4973: LD_INT 93
4975: PPUSH
4976: LD_INT 32
4978: PPUSH
4979: LD_INT 3
4981: PPUSH
4982: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4986: LD_INT 35
4988: PPUSH
4989: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4993: LD_INT 22
4995: PUSH
4996: LD_INT 8
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: PUSH
5003: LD_INT 30
5005: PUSH
5006: LD_INT 3
5008: PUSH
5009: EMPTY
5010: LIST
5011: LIST
5012: PUSH
5013: LD_INT 23
5015: PUSH
5016: LD_INT 3
5018: PUSH
5019: EMPTY
5020: LIST
5021: LIST
5022: PUSH
5023: LD_INT 57
5025: PUSH
5026: EMPTY
5027: LIST
5028: PUSH
5029: EMPTY
5030: LIST
5031: LIST
5032: LIST
5033: LIST
5034: PPUSH
5035: CALL_OW 69
5039: IFFALSE 4986
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
5041: LD_ADDR_VAR 0 2
5045: PUSH
5046: LD_INT 22
5048: PUSH
5049: LD_INT 8
5051: PUSH
5052: EMPTY
5053: LIST
5054: LIST
5055: PUSH
5056: LD_INT 30
5058: PUSH
5059: LD_INT 3
5061: PUSH
5062: EMPTY
5063: LIST
5064: LIST
5065: PUSH
5066: LD_INT 23
5068: PUSH
5069: LD_INT 3
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: LD_INT 57
5078: PUSH
5079: EMPTY
5080: LIST
5081: PUSH
5082: EMPTY
5083: LIST
5084: LIST
5085: LIST
5086: LIST
5087: PPUSH
5088: CALL_OW 69
5092: PUSH
5093: LD_INT 1
5095: ARRAY
5096: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
5097: LD_INT 22
5099: PUSH
5100: LD_INT 8
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 23
5109: PUSH
5110: LD_INT 3
5112: PUSH
5113: EMPTY
5114: LIST
5115: LIST
5116: PUSH
5117: LD_INT 30
5119: PUSH
5120: LD_INT 21
5122: PUSH
5123: EMPTY
5124: LIST
5125: LIST
5126: PUSH
5127: EMPTY
5128: LIST
5129: LIST
5130: LIST
5131: PPUSH
5132: CALL_OW 69
5136: NOT
5137: IFFALSE 5215
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5139: LD_EXP 61
5143: PPUSH
5144: LD_INT 21
5146: PPUSH
5147: LD_INT 97
5149: PPUSH
5150: LD_INT 36
5152: PPUSH
5153: LD_INT 5
5155: PPUSH
5156: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5160: LD_INT 35
5162: PPUSH
5163: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5167: LD_INT 22
5169: PUSH
5170: LD_INT 8
5172: PUSH
5173: EMPTY
5174: LIST
5175: LIST
5176: PUSH
5177: LD_INT 23
5179: PUSH
5180: LD_INT 3
5182: PUSH
5183: EMPTY
5184: LIST
5185: LIST
5186: PUSH
5187: LD_INT 30
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: PUSH
5197: LD_INT 57
5199: PUSH
5200: EMPTY
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: LIST
5208: PPUSH
5209: CALL_OW 69
5213: IFFALSE 5160
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5215: LD_INT 22
5217: PUSH
5218: LD_INT 8
5220: PUSH
5221: EMPTY
5222: LIST
5223: LIST
5224: PUSH
5225: LD_INT 23
5227: PUSH
5228: LD_INT 3
5230: PUSH
5231: EMPTY
5232: LIST
5233: LIST
5234: PUSH
5235: LD_INT 30
5237: PUSH
5238: LD_INT 18
5240: PUSH
5241: EMPTY
5242: LIST
5243: LIST
5244: PUSH
5245: EMPTY
5246: LIST
5247: LIST
5248: LIST
5249: PPUSH
5250: CALL_OW 69
5254: NOT
5255: IFFALSE 5333
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5257: LD_EXP 61
5261: PPUSH
5262: LD_INT 18
5264: PPUSH
5265: LD_INT 89
5267: PPUSH
5268: LD_INT 32
5270: PPUSH
5271: LD_INT 1
5273: PPUSH
5274: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5278: LD_INT 35
5280: PPUSH
5281: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5285: LD_INT 22
5287: PUSH
5288: LD_INT 8
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: PUSH
5295: LD_INT 23
5297: PUSH
5298: LD_INT 3
5300: PUSH
5301: EMPTY
5302: LIST
5303: LIST
5304: PUSH
5305: LD_INT 30
5307: PUSH
5308: LD_INT 18
5310: PUSH
5311: EMPTY
5312: LIST
5313: LIST
5314: PUSH
5315: LD_INT 57
5317: PUSH
5318: EMPTY
5319: LIST
5320: PUSH
5321: EMPTY
5322: LIST
5323: LIST
5324: LIST
5325: LIST
5326: PPUSH
5327: CALL_OW 69
5331: IFFALSE 5278
// end ; lab := kozlov_lab ;
5333: LD_ADDR_VAR 0 3
5337: PUSH
5338: LD_INT 336
5340: ST_TO_ADDR
// if not lab then
5341: LD_VAR 0 3
5345: NOT
5346: IFFALSE 5350
// exit ;
5348: GO 5475
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5350: LD_EXP 61
5354: PPUSH
5355: LD_VAR 0 3
5359: PUSH
5360: LD_INT 1
5362: ARRAY
5363: PPUSH
5364: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5368: LD_EXP 61
5372: PPUSH
5373: LD_INT 4
5375: PPUSH
5376: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5380: LD_VAR 0 3
5384: PUSH
5385: LD_INT 1
5387: ARRAY
5388: PPUSH
5389: LD_INT 25
5391: PPUSH
5392: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5396: LD_INT 35
5398: PPUSH
5399: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5403: LD_INT 25
5405: PPUSH
5406: LD_INT 8
5408: PPUSH
5409: CALL_OW 321
5413: PUSH
5414: LD_INT 2
5416: EQUAL
5417: IFFALSE 5396
// ComExitBuilding ( Kozlov ) ;
5419: LD_EXP 61
5423: PPUSH
5424: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5428: LD_EXP 61
5432: PPUSH
5433: LD_VAR 0 2
5437: PPUSH
5438: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5442: LD_EXP 61
5446: PPUSH
5447: LD_INT 3
5449: PPUSH
5450: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5454: LD_VAR 0 2
5458: PPUSH
5459: LD_INT 23
5461: PPUSH
5462: LD_INT 3
5464: PPUSH
5465: LD_INT 1
5467: PPUSH
5468: LD_INT 48
5470: PPUSH
5471: CALL_OW 125
// end ;
5475: LD_VAR 0 1
5479: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5480: LD_EXP 22
5484: NOT
5485: PUSH
5486: LD_EXP 15
5490: PUSH
5491: LD_INT 6
5493: GREATEREQUAL
5494: AND
5495: IFFALSE 5576
5497: GO 5499
5499: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5500: LD_INT 3
5502: PPUSH
5503: LD_INT 3
5505: PPUSH
5506: CALL 59616 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5510: LD_INT 3
5512: PPUSH
5513: LD_INT 14
5515: PUSH
5516: LD_INT 1
5518: PUSH
5519: LD_INT 1
5521: PUSH
5522: LD_INT 28
5524: PUSH
5525: EMPTY
5526: LIST
5527: LIST
5528: LIST
5529: LIST
5530: PUSH
5531: LD_INT 14
5533: PUSH
5534: LD_INT 1
5536: PUSH
5537: LD_INT 1
5539: PUSH
5540: LD_INT 28
5542: PUSH
5543: EMPTY
5544: LIST
5545: LIST
5546: LIST
5547: LIST
5548: PUSH
5549: LD_INT 14
5551: PUSH
5552: LD_INT 1
5554: PUSH
5555: LD_INT 1
5557: PUSH
5558: LD_INT 28
5560: PUSH
5561: EMPTY
5562: LIST
5563: LIST
5564: LIST
5565: LIST
5566: PUSH
5567: EMPTY
5568: LIST
5569: LIST
5570: LIST
5571: PPUSH
5572: CALL 59479 0 2
// end ;
5576: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5577: LD_EXP 22
5581: NOT
5582: PUSH
5583: LD_EXP 15
5587: PUSH
5588: LD_INT 6
5590: GREATEREQUAL
5591: AND
5592: PUSH
5593: LD_INT 3
5595: PPUSH
5596: LD_INT 1
5598: PPUSH
5599: CALL 60897 0 2
5603: NOT
5604: AND
5605: IFFALSE 6461
5607: GO 5609
5609: DISABLE
5610: LD_INT 0
5612: PPUSH
5613: PPUSH
5614: PPUSH
// begin enable ;
5615: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5616: LD_INT 22
5618: PUSH
5619: LD_INT 8
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 23
5628: PUSH
5629: LD_INT 2
5631: PUSH
5632: EMPTY
5633: LIST
5634: LIST
5635: PUSH
5636: LD_INT 30
5638: PUSH
5639: LD_INT 3
5641: PUSH
5642: EMPTY
5643: LIST
5644: LIST
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: LIST
5650: PPUSH
5651: CALL_OW 69
5655: NOT
5656: IFFALSE 5660
// exit ;
5658: GO 6461
// if Prob ( 40 ) then
5660: LD_INT 40
5662: PPUSH
5663: CALL_OW 13
5667: IFFALSE 5794
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5669: LD_INT 3
5671: PPUSH
5672: LD_INT 14
5674: PUSH
5675: LD_INT 1
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: LD_INT 28
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: LIST
5688: LIST
5689: PUSH
5690: LD_INT 14
5692: PUSH
5693: LD_INT 1
5695: PUSH
5696: LD_INT 2
5698: PUSH
5699: LD_INT 28
5701: PUSH
5702: EMPTY
5703: LIST
5704: LIST
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 14
5710: PUSH
5711: LD_INT 1
5713: PUSH
5714: LD_INT 2
5716: PUSH
5717: LD_INT 28
5719: PUSH
5720: EMPTY
5721: LIST
5722: LIST
5723: LIST
5724: LIST
5725: PUSH
5726: LD_INT 14
5728: PUSH
5729: LD_INT 1
5731: PUSH
5732: LD_INT 2
5734: PUSH
5735: LD_INT 28
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: PUSH
5744: LD_INT 14
5746: PUSH
5747: LD_INT 1
5749: PUSH
5750: LD_INT 2
5752: PUSH
5753: LD_INT 28
5755: PUSH
5756: EMPTY
5757: LIST
5758: LIST
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 14
5764: PUSH
5765: LD_INT 1
5767: PUSH
5768: LD_INT 2
5770: PUSH
5771: LD_INT 26
5773: PUSH
5774: EMPTY
5775: LIST
5776: LIST
5777: LIST
5778: LIST
5779: PUSH
5780: EMPTY
5781: LIST
5782: LIST
5783: LIST
5784: LIST
5785: LIST
5786: LIST
5787: PPUSH
5788: CALL 59479 0 2
// end else
5792: GO 6001
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_rocket_launcher ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5794: LD_INT 3
5796: PPUSH
5797: LD_INT 14
5799: PUSH
5800: LD_INT 1
5802: PUSH
5803: LD_INT 2
5805: PUSH
5806: LD_INT 27
5808: PUSH
5809: LD_INT 26
5811: PUSH
5812: LD_INT 26
5814: PUSH
5815: LD_INT 28
5817: PUSH
5818: EMPTY
5819: LIST
5820: LIST
5821: LIST
5822: LIST
5823: PUSH
5824: LD_OWVAR 67
5828: ARRAY
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 27
5847: PUSH
5848: LD_INT 26
5850: PUSH
5851: LD_INT 26
5853: PUSH
5854: LD_INT 26
5856: PUSH
5857: EMPTY
5858: LIST
5859: LIST
5860: LIST
5861: LIST
5862: PUSH
5863: LD_OWVAR 67
5867: ARRAY
5868: PUSH
5869: EMPTY
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: PUSH
5875: LD_INT 14
5877: PUSH
5878: LD_INT 1
5880: PUSH
5881: LD_INT 2
5883: PUSH
5884: LD_INT 26
5886: PUSH
5887: LD_INT 26
5889: PUSH
5890: LD_INT 29
5892: PUSH
5893: LD_INT 29
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: PUSH
5902: LD_OWVAR 67
5906: ARRAY
5907: PUSH
5908: EMPTY
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 13
5916: PUSH
5917: LD_INT 1
5919: PUSH
5920: LD_INT 2
5922: PUSH
5923: LD_INT 26
5925: PUSH
5926: LD_INT 29
5928: PUSH
5929: LD_INT 29
5931: PUSH
5932: LD_INT 29
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: LIST
5939: LIST
5940: PUSH
5941: LD_OWVAR 67
5945: ARRAY
5946: PUSH
5947: EMPTY
5948: LIST
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 13
5955: PUSH
5956: LD_INT 1
5958: PUSH
5959: LD_INT 2
5961: PUSH
5962: LD_INT 29
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 14
5973: PUSH
5974: LD_INT 1
5976: PUSH
5977: LD_INT 2
5979: PUSH
5980: LD_INT 26
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: LIST
5994: LIST
5995: LIST
5996: PPUSH
5997: CALL 59479 0 2
// end ; repeat wait ( 0 0$1 ) ;
6001: LD_INT 35
6003: PPUSH
6004: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
6008: LD_INT 3
6010: PPUSH
6011: LD_INT 1
6013: PPUSH
6014: CALL 60897 0 2
6018: PUSH
6019: LD_INT 6
6021: GREATEREQUAL
6022: IFFALSE 6001
// wait ( 0 0$30 ) ;
6024: LD_INT 1050
6026: PPUSH
6027: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
6031: LD_ADDR_VAR 0 2
6035: PUSH
6036: LD_INT 3
6038: PPUSH
6039: LD_INT 1
6041: PPUSH
6042: CALL 60897 0 2
6046: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
6047: LD_ADDR_EXP 135
6051: PUSH
6052: LD_EXP 135
6056: PPUSH
6057: LD_INT 3
6059: PPUSH
6060: LD_EXP 135
6064: PUSH
6065: LD_INT 3
6067: ARRAY
6068: PUSH
6069: LD_VAR 0 2
6073: DIFF
6074: PPUSH
6075: CALL_OW 1
6079: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
6080: LD_ADDR_VAR 0 3
6084: PUSH
6085: LD_INT 0
6087: PPUSH
6088: LD_INT 2
6090: PPUSH
6091: CALL_OW 12
6095: ST_TO_ADDR
// if target then
6096: LD_VAR 0 3
6100: IFFALSE 6228
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6102: LD_ADDR_VAR 0 2
6106: PUSH
6107: LD_VAR 0 2
6111: PPUSH
6112: LD_INT 24
6114: PUSH
6115: LD_INT 250
6117: PUSH
6118: EMPTY
6119: LIST
6120: LIST
6121: PPUSH
6122: CALL_OW 72
6126: ST_TO_ADDR
// for i in tmp do
6127: LD_ADDR_VAR 0 1
6131: PUSH
6132: LD_VAR 0 2
6136: PUSH
6137: FOR_IN
6138: IFFALSE 6178
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6140: LD_VAR 0 1
6144: PPUSH
6145: LD_INT 89
6147: PPUSH
6148: LD_INT 71
6150: PPUSH
6151: CALL_OW 297
6155: PUSH
6156: LD_INT 9
6158: GREATER
6159: IFFALSE 6176
// ComMoveXY ( i , 89 , 71 ) ;
6161: LD_VAR 0 1
6165: PPUSH
6166: LD_INT 89
6168: PPUSH
6169: LD_INT 71
6171: PPUSH
6172: CALL_OW 111
6176: GO 6137
6178: POP
6179: POP
// wait ( 0 0$1 ) ;
6180: LD_INT 35
6182: PPUSH
6183: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6187: LD_VAR 0 2
6191: PPUSH
6192: LD_INT 92
6194: PUSH
6195: LD_INT 89
6197: PUSH
6198: LD_INT 71
6200: PUSH
6201: LD_INT 9
6203: PUSH
6204: EMPTY
6205: LIST
6206: LIST
6207: LIST
6208: LIST
6209: PPUSH
6210: CALL_OW 72
6214: PUSH
6215: LD_VAR 0 2
6219: PUSH
6220: LD_INT 1
6222: MINUS
6223: GREATEREQUAL
6224: IFFALSE 6102
// end else
6226: GO 6352
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6228: LD_ADDR_VAR 0 2
6232: PUSH
6233: LD_VAR 0 2
6237: PPUSH
6238: LD_INT 24
6240: PUSH
6241: LD_INT 250
6243: PUSH
6244: EMPTY
6245: LIST
6246: LIST
6247: PPUSH
6248: CALL_OW 72
6252: ST_TO_ADDR
// for i in tmp do
6253: LD_ADDR_VAR 0 1
6257: PUSH
6258: LD_VAR 0 2
6262: PUSH
6263: FOR_IN
6264: IFFALSE 6304
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6266: LD_VAR 0 1
6270: PPUSH
6271: LD_INT 125
6273: PPUSH
6274: LD_INT 129
6276: PPUSH
6277: CALL_OW 297
6281: PUSH
6282: LD_INT 9
6284: GREATER
6285: IFFALSE 6302
// ComMoveXY ( i , 125 , 129 ) ;
6287: LD_VAR 0 1
6291: PPUSH
6292: LD_INT 125
6294: PPUSH
6295: LD_INT 129
6297: PPUSH
6298: CALL_OW 111
6302: GO 6263
6304: POP
6305: POP
// wait ( 0 0$1 ) ;
6306: LD_INT 35
6308: PPUSH
6309: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6313: LD_VAR 0 2
6317: PPUSH
6318: LD_INT 92
6320: PUSH
6321: LD_INT 125
6323: PUSH
6324: LD_INT 129
6326: PUSH
6327: LD_INT 9
6329: PUSH
6330: EMPTY
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: PPUSH
6336: CALL_OW 72
6340: PUSH
6341: LD_VAR 0 2
6345: PUSH
6346: LD_INT 1
6348: MINUS
6349: GREATEREQUAL
6350: IFFALSE 6228
// end ; repeat wait ( 0 0$1 ) ;
6352: LD_INT 35
6354: PPUSH
6355: CALL_OW 67
// for i in tmp do
6359: LD_ADDR_VAR 0 1
6363: PUSH
6364: LD_VAR 0 2
6368: PUSH
6369: FOR_IN
6370: IFFALSE 6452
// begin if GetLives ( i ) > 251 then
6372: LD_VAR 0 1
6376: PPUSH
6377: CALL_OW 256
6381: PUSH
6382: LD_INT 251
6384: GREATER
6385: IFFALSE 6423
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6387: LD_VAR 0 1
6391: PPUSH
6392: LD_INT 81
6394: PUSH
6395: LD_INT 8
6397: PUSH
6398: EMPTY
6399: LIST
6400: LIST
6401: PPUSH
6402: CALL_OW 69
6406: PPUSH
6407: LD_VAR 0 1
6411: PPUSH
6412: CALL_OW 74
6416: PPUSH
6417: CALL_OW 115
6421: GO 6450
// if IsDead ( i ) then
6423: LD_VAR 0 1
6427: PPUSH
6428: CALL_OW 301
6432: IFFALSE 6450
// tmp := tmp diff i ;
6434: LD_ADDR_VAR 0 2
6438: PUSH
6439: LD_VAR 0 2
6443: PUSH
6444: LD_VAR 0 1
6448: DIFF
6449: ST_TO_ADDR
// end ;
6450: GO 6369
6452: POP
6453: POP
// until not tmp ;
6454: LD_VAR 0 2
6458: NOT
6459: IFFALSE 6352
// end ;
6461: PPOPN 3
6463: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6464: LD_EXP 22
6468: NOT
6469: PUSH
6470: LD_EXP 15
6474: PUSH
6475: LD_INT 6
6477: GREATEREQUAL
6478: AND
6479: PUSH
6480: LD_OWVAR 67
6484: PUSH
6485: LD_INT 1
6487: GREATER
6488: AND
6489: IFFALSE 7022
6491: GO 6493
6493: DISABLE
6494: LD_INT 0
6496: PPUSH
6497: PPUSH
6498: PPUSH
// begin enable ;
6499: ENABLE
// tmp := [ ] ;
6500: LD_ADDR_VAR 0 3
6504: PUSH
6505: EMPTY
6506: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 , 8 ] [ Difficulty ] do
6507: LD_ADDR_VAR 0 1
6511: PUSH
6512: DOUBLE
6513: LD_INT 1
6515: DEC
6516: ST_TO_ADDR
6517: LD_INT 4
6519: PUSH
6520: LD_INT 6
6522: PUSH
6523: LD_INT 7
6525: PUSH
6526: LD_INT 8
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: LIST
6533: LIST
6534: PUSH
6535: LD_OWVAR 67
6539: ARRAY
6540: PUSH
6541: FOR_TO
6542: IFFALSE 6702
// begin uc_side := 8 ;
6544: LD_ADDR_OWVAR 20
6548: PUSH
6549: LD_INT 8
6551: ST_TO_ADDR
// uc_nation := 2 ;
6552: LD_ADDR_OWVAR 21
6556: PUSH
6557: LD_INT 2
6559: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6560: LD_INT 13
6562: PUSH
6563: LD_INT 14
6565: PUSH
6566: EMPTY
6567: LIST
6568: LIST
6569: PUSH
6570: LD_INT 1
6572: PPUSH
6573: LD_INT 2
6575: PPUSH
6576: CALL_OW 12
6580: ARRAY
6581: PPUSH
6582: LD_INT 1
6584: PPUSH
6585: LD_INT 5
6587: PPUSH
6588: LD_INT 27
6590: PUSH
6591: LD_INT 28
6593: PUSH
6594: LD_INT 26
6596: PUSH
6597: LD_INT 25
6599: PUSH
6600: EMPTY
6601: LIST
6602: LIST
6603: LIST
6604: LIST
6605: PUSH
6606: LD_INT 1
6608: PPUSH
6609: LD_INT 4
6611: PPUSH
6612: CALL_OW 12
6616: ARRAY
6617: PPUSH
6618: LD_INT 88
6620: PPUSH
6621: CALL 70749 0 5
// un := CreateVehicle ;
6625: LD_ADDR_VAR 0 2
6629: PUSH
6630: CALL_OW 45
6634: ST_TO_ADDR
// tmp := tmp ^ un ;
6635: LD_ADDR_VAR 0 3
6639: PUSH
6640: LD_VAR 0 3
6644: PUSH
6645: LD_VAR 0 2
6649: ADD
6650: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6651: LD_VAR 0 2
6655: PPUSH
6656: LD_INT 3
6658: PPUSH
6659: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6663: LD_VAR 0 2
6667: PPUSH
6668: LD_INT 30
6670: PPUSH
6671: LD_INT 0
6673: PPUSH
6674: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6678: LD_VAR 0 2
6682: PPUSH
6683: LD_INT 16
6685: PPUSH
6686: LD_INT 11
6688: PPUSH
6689: CALL_OW 111
// wait ( 0 0$2 ) ;
6693: LD_INT 70
6695: PPUSH
6696: CALL_OW 67
// end ;
6700: GO 6541
6702: POP
6703: POP
// for i = 1 to Difficulty do
6704: LD_ADDR_VAR 0 1
6708: PUSH
6709: DOUBLE
6710: LD_INT 1
6712: DEC
6713: ST_TO_ADDR
6714: LD_OWVAR 67
6718: PUSH
6719: FOR_TO
6720: IFFALSE 6849
// begin uc_side := 8 ;
6722: LD_ADDR_OWVAR 20
6726: PUSH
6727: LD_INT 8
6729: ST_TO_ADDR
// uc_nation := 2 ;
6730: LD_ADDR_OWVAR 21
6734: PUSH
6735: LD_INT 2
6737: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 , 10 ] [ Difficulty ] ) ;
6738: LD_INT 0
6740: PPUSH
6741: LD_INT 8
6743: PPUSH
6744: LD_INT 8
6746: PUSH
6747: LD_INT 8
6749: PUSH
6750: LD_INT 9
6752: PUSH
6753: LD_INT 10
6755: PUSH
6756: EMPTY
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: PUSH
6762: LD_OWVAR 67
6766: ARRAY
6767: PPUSH
6768: CALL_OW 380
// un := CreateHuman ;
6772: LD_ADDR_VAR 0 2
6776: PUSH
6777: CALL_OW 44
6781: ST_TO_ADDR
// tmp := tmp ^ un ;
6782: LD_ADDR_VAR 0 3
6786: PUSH
6787: LD_VAR 0 3
6791: PUSH
6792: LD_VAR 0 2
6796: ADD
6797: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6798: LD_VAR 0 2
6802: PPUSH
6803: LD_INT 3
6805: PPUSH
6806: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6810: LD_VAR 0 2
6814: PPUSH
6815: LD_INT 30
6817: PPUSH
6818: LD_INT 0
6820: PPUSH
6821: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6825: LD_VAR 0 2
6829: PPUSH
6830: LD_INT 16
6832: PPUSH
6833: LD_INT 11
6835: PPUSH
6836: CALL_OW 111
// wait ( 0 0$2 ) ;
6840: LD_INT 70
6842: PPUSH
6843: CALL_OW 67
// end ;
6847: GO 6719
6849: POP
6850: POP
// repeat wait ( 0 0$1 ) ;
6851: LD_INT 35
6853: PPUSH
6854: CALL_OW 67
// if legionDestroyed then
6858: LD_EXP 22
6862: IFFALSE 6866
// exit ;
6864: GO 7022
// for i in tmp do
6866: LD_ADDR_VAR 0 1
6870: PUSH
6871: LD_VAR 0 3
6875: PUSH
6876: FOR_IN
6877: IFFALSE 7013
// begin if GetLives ( i ) > 250 then
6879: LD_VAR 0 1
6883: PPUSH
6884: CALL_OW 256
6888: PUSH
6889: LD_INT 250
6891: GREATER
6892: IFFALSE 6984
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6894: LD_INT 81
6896: PUSH
6897: LD_INT 8
6899: PUSH
6900: EMPTY
6901: LIST
6902: LIST
6903: PUSH
6904: LD_INT 91
6906: PUSH
6907: LD_VAR 0 1
6911: PUSH
6912: LD_INT 10
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: LIST
6919: PUSH
6920: EMPTY
6921: LIST
6922: LIST
6923: PPUSH
6924: CALL_OW 69
6928: NOT
6929: IFFALSE 6948
// ComAgressiveMove ( i , 67 , 110 ) else
6931: LD_VAR 0 1
6935: PPUSH
6936: LD_INT 67
6938: PPUSH
6939: LD_INT 110
6941: PPUSH
6942: CALL_OW 114
6946: GO 6982
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6948: LD_VAR 0 1
6952: PPUSH
6953: LD_INT 81
6955: PUSH
6956: LD_INT 8
6958: PUSH
6959: EMPTY
6960: LIST
6961: LIST
6962: PPUSH
6963: CALL_OW 69
6967: PPUSH
6968: LD_VAR 0 1
6972: PPUSH
6973: CALL_OW 74
6977: PPUSH
6978: CALL_OW 115
// end else
6982: GO 7011
// if IsDead ( i ) then
6984: LD_VAR 0 1
6988: PPUSH
6989: CALL_OW 301
6993: IFFALSE 7011
// tmp := tmp diff i ;
6995: LD_ADDR_VAR 0 3
6999: PUSH
7000: LD_VAR 0 3
7004: PUSH
7005: LD_VAR 0 1
7009: DIFF
7010: ST_TO_ADDR
// end ;
7011: GO 6876
7013: POP
7014: POP
// until not tmp ;
7015: LD_VAR 0 3
7019: NOT
7020: IFFALSE 6851
// end ; end_of_file
7022: PPOPN 3
7024: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
7025: LD_INT 0
7027: PPUSH
7028: PPUSH
7029: PPUSH
7030: PPUSH
7031: PPUSH
7032: PPUSH
7033: PPUSH
7034: PPUSH
7035: PPUSH
// side := 3 ;
7036: LD_ADDR_VAR 0 6
7040: PUSH
7041: LD_INT 3
7043: ST_TO_ADDR
// uc_side := side ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_VAR 0 6
7053: ST_TO_ADDR
// uc_nation := 3 ;
7054: LD_ADDR_OWVAR 21
7058: PUSH
7059: LD_INT 3
7061: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
7062: LD_ADDR_VAR 0 2
7066: PUSH
7067: LD_INT 22
7069: PUSH
7070: LD_VAR 0 6
7074: PUSH
7075: EMPTY
7076: LIST
7077: LIST
7078: PUSH
7079: LD_INT 21
7081: PUSH
7082: LD_INT 3
7084: PUSH
7085: EMPTY
7086: LIST
7087: LIST
7088: PUSH
7089: EMPTY
7090: LIST
7091: LIST
7092: PPUSH
7093: CALL_OW 69
7097: PUSH
7098: FOR_IN
7099: IFFALSE 7115
// SetBLevel ( i , 10 ) ;
7101: LD_VAR 0 2
7105: PPUSH
7106: LD_INT 10
7108: PPUSH
7109: CALL_OW 241
7113: GO 7098
7115: POP
7116: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
7117: LD_ADDR_VAR 0 9
7121: PUSH
7122: LD_INT 22
7124: PUSH
7125: LD_VAR 0 6
7129: PUSH
7130: EMPTY
7131: LIST
7132: LIST
7133: PUSH
7134: LD_INT 30
7136: PUSH
7137: LD_INT 34
7139: PUSH
7140: EMPTY
7141: LIST
7142: LIST
7143: PUSH
7144: EMPTY
7145: LIST
7146: LIST
7147: PPUSH
7148: CALL_OW 69
7152: ST_TO_ADDR
// if teleport then
7153: LD_VAR 0 9
7157: IFFALSE 7178
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7159: LD_VAR 0 9
7163: PUSH
7164: LD_INT 1
7166: ARRAY
7167: PPUSH
7168: LD_INT 123
7170: PPUSH
7171: LD_INT 122
7173: PPUSH
7174: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7178: LD_ADDR_EXP 64
7182: PUSH
7183: LD_STRING Platonov
7185: PPUSH
7186: CALL_OW 25
7190: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7191: LD_ADDR_EXP 65
7195: PUSH
7196: LD_STRING Kovalyuk
7198: PPUSH
7199: CALL_OW 25
7203: ST_TO_ADDR
// Yakotich := PrepareUnit ( Yakotich , ( not debug ) , 09_ ) ;
7204: LD_ADDR_EXP 67
7208: PUSH
7209: LD_STRING Yakotich
7211: PPUSH
7212: LD_EXP 1
7216: NOT
7217: PPUSH
7218: LD_STRING 09_
7220: PPUSH
7221: CALL 65885 0 3
7225: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7226: LD_ADDR_EXP 66
7230: PUSH
7231: LD_STRING Bystrov
7233: PPUSH
7234: CALL_OW 25
7238: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7239: LD_ADDR_EXP 68
7243: PUSH
7244: LD_STRING Gleb
7246: PPUSH
7247: CALL_OW 25
7251: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7252: LD_STRING 03_Cornel
7254: PPUSH
7255: CALL_OW 28
7259: IFFALSE 7307
// begin Bierezov := NewCharacter ( Mikhail ) ;
7261: LD_ADDR_EXP 69
7265: PUSH
7266: LD_STRING Mikhail
7268: PPUSH
7269: CALL_OW 25
7273: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7274: LD_EXP 69
7278: PPUSH
7279: LD_INT 197
7281: PPUSH
7282: LD_INT 111
7284: PPUSH
7285: LD_INT 9
7287: PPUSH
7288: LD_INT 0
7290: PPUSH
7291: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7295: LD_EXP 69
7299: PPUSH
7300: LD_INT 3
7302: PPUSH
7303: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7307: LD_EXP 64
7311: PPUSH
7312: LD_INT 126
7314: PPUSH
7315: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7319: LD_EXP 65
7323: PPUSH
7324: LD_INT 134
7326: PPUSH
7327: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7331: LD_EXP 67
7335: PPUSH
7336: LD_INT 197
7338: PPUSH
7339: LD_INT 111
7341: PPUSH
7342: LD_INT 9
7344: PPUSH
7345: LD_INT 0
7347: PPUSH
7348: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7352: LD_EXP 66
7356: PPUSH
7357: LD_INT 197
7359: PPUSH
7360: LD_INT 111
7362: PPUSH
7363: LD_INT 9
7365: PPUSH
7366: LD_INT 0
7368: PPUSH
7369: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7373: LD_EXP 68
7377: PPUSH
7378: LD_INT 197
7380: PPUSH
7381: LD_INT 111
7383: PPUSH
7384: LD_INT 9
7386: PPUSH
7387: LD_INT 0
7389: PPUSH
7390: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 18 , 8 , 13 , 8 ] ) ;
7394: LD_ADDR_VAR 0 5
7398: PUSH
7399: LD_INT 126
7401: PPUSH
7402: LD_INT 4
7404: PPUSH
7405: LD_STRING zhukov
7407: PPUSH
7408: LD_INT 9
7410: PUSH
7411: LD_INT 10
7413: PUSH
7414: LD_INT 10
7416: PUSH
7417: LD_INT 10
7419: PUSH
7420: EMPTY
7421: LIST
7422: LIST
7423: LIST
7424: LIST
7425: PUSH
7426: LD_OWVAR 67
7430: ARRAY
7431: PPUSH
7432: LD_INT 90000
7434: PUSH
7435: LD_INT 1000
7437: PUSH
7438: LD_INT 300
7440: PUSH
7441: EMPTY
7442: LIST
7443: LIST
7444: LIST
7445: PPUSH
7446: LD_INT 18
7448: PUSH
7449: LD_INT 8
7451: PUSH
7452: LD_INT 13
7454: PUSH
7455: LD_INT 8
7457: PUSH
7458: EMPTY
7459: LIST
7460: LIST
7461: LIST
7462: LIST
7463: PPUSH
7464: CALL 74195 0 6
7468: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7469: LD_ADDR_VAR 0 4
7473: PUSH
7474: LD_INT 267
7476: PPUSH
7477: CALL_OW 274
7481: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7482: LD_VAR 0 4
7486: PPUSH
7487: LD_INT 1
7489: PPUSH
7490: LD_INT 5000
7492: PPUSH
7493: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7497: LD_VAR 0 4
7501: PPUSH
7502: LD_INT 2
7504: PPUSH
7505: LD_INT 200
7507: PPUSH
7508: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7512: LD_VAR 0 4
7516: PPUSH
7517: LD_INT 3
7519: PPUSH
7520: LD_INT 200
7522: PPUSH
7523: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7527: LD_ADDR_EXP 116
7531: PUSH
7532: LD_EXP 116
7536: PPUSH
7537: LD_INT 2
7539: PPUSH
7540: LD_VAR 0 5
7544: PUSH
7545: LD_INT 22
7547: PUSH
7548: LD_VAR 0 6
7552: PUSH
7553: EMPTY
7554: LIST
7555: LIST
7556: PUSH
7557: LD_INT 3
7559: PUSH
7560: LD_INT 21
7562: PUSH
7563: LD_INT 2
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: PUSH
7570: EMPTY
7571: LIST
7572: LIST
7573: PUSH
7574: EMPTY
7575: LIST
7576: LIST
7577: PPUSH
7578: CALL_OW 69
7582: UNION
7583: PUSH
7584: LD_EXP 64
7588: DIFF
7589: PPUSH
7590: CALL_OW 1
7594: ST_TO_ADDR
// behemoths := [ ] ;
7595: LD_ADDR_EXP 72
7599: PUSH
7600: EMPTY
7601: ST_TO_ADDR
// behemothBuilders := [ ] ;
7602: LD_ADDR_EXP 73
7606: PUSH
7607: EMPTY
7608: ST_TO_ADDR
// if Kovalyuk then
7609: LD_EXP 65
7613: IFFALSE 7635
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7615: LD_ADDR_EXP 73
7619: PUSH
7620: LD_EXP 73
7624: PPUSH
7625: LD_EXP 65
7629: PPUSH
7630: CALL 102622 0 2
7634: ST_TO_ADDR
// j := 3 ;
7635: LD_ADDR_VAR 0 3
7639: PUSH
7640: LD_INT 3
7642: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7643: LD_ADDR_VAR 0 2
7647: PUSH
7648: LD_INT 22
7650: PUSH
7651: LD_INT 3
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 3
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: PPUSH
7672: CALL_OW 69
7676: PUSH
7677: LD_EXP 65
7681: DIFF
7682: PUSH
7683: FOR_IN
7684: IFFALSE 7734
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7686: LD_ADDR_EXP 73
7690: PUSH
7691: LD_EXP 73
7695: PPUSH
7696: LD_VAR 0 2
7700: PPUSH
7701: CALL 102622 0 2
7705: ST_TO_ADDR
// j := j - 1 ;
7706: LD_ADDR_VAR 0 3
7710: PUSH
7711: LD_VAR 0 3
7715: PUSH
7716: LD_INT 1
7718: MINUS
7719: ST_TO_ADDR
// if j = 0 then
7720: LD_VAR 0 3
7724: PUSH
7725: LD_INT 0
7727: EQUAL
7728: IFFALSE 7732
// break ;
7730: GO 7734
// end ;
7732: GO 7683
7734: POP
7735: POP
// end ;
7736: LD_VAR 0 1
7740: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7741: LD_INT 0
7743: PPUSH
7744: PPUSH
7745: PPUSH
7746: PPUSH
7747: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7748: LD_ADDR_VAR 0 4
7752: PUSH
7753: LD_INT 209
7755: PUSH
7756: LD_INT 149
7758: PUSH
7759: EMPTY
7760: LIST
7761: LIST
7762: PUSH
7763: LD_INT 219
7765: PUSH
7766: LD_INT 154
7768: PUSH
7769: EMPTY
7770: LIST
7771: LIST
7772: PUSH
7773: LD_INT 223
7775: PUSH
7776: LD_INT 149
7778: PUSH
7779: EMPTY
7780: LIST
7781: LIST
7782: PUSH
7783: LD_INT 232
7785: PUSH
7786: LD_INT 155
7788: PUSH
7789: EMPTY
7790: LIST
7791: LIST
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: LIST
7797: LIST
7798: ST_TO_ADDR
// if not behemothBuilders then
7799: LD_EXP 73
7803: NOT
7804: IFFALSE 7808
// exit ;
7806: GO 7912
// j := 1 ;
7808: LD_ADDR_VAR 0 3
7812: PUSH
7813: LD_INT 1
7815: ST_TO_ADDR
// for i in behemothBuilders do
7816: LD_ADDR_VAR 0 2
7820: PUSH
7821: LD_EXP 73
7825: PUSH
7826: FOR_IN
7827: IFFALSE 7910
// begin if IsInUnit ( i ) then
7829: LD_VAR 0 2
7833: PPUSH
7834: CALL_OW 310
7838: IFFALSE 7849
// ComExitBuilding ( i ) ;
7840: LD_VAR 0 2
7844: PPUSH
7845: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7849: LD_VAR 0 2
7853: PPUSH
7854: LD_INT 37
7856: PPUSH
7857: LD_VAR 0 4
7861: PUSH
7862: LD_VAR 0 3
7866: ARRAY
7867: PUSH
7868: LD_INT 1
7870: ARRAY
7871: PPUSH
7872: LD_VAR 0 4
7876: PUSH
7877: LD_VAR 0 3
7881: ARRAY
7882: PUSH
7883: LD_INT 2
7885: ARRAY
7886: PPUSH
7887: LD_INT 0
7889: PPUSH
7890: CALL_OW 230
// j := j + 1 ;
7894: LD_ADDR_VAR 0 3
7898: PUSH
7899: LD_VAR 0 3
7903: PUSH
7904: LD_INT 1
7906: PLUS
7907: ST_TO_ADDR
// end ;
7908: GO 7826
7910: POP
7911: POP
// end ;
7912: LD_VAR 0 1
7916: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7917: LD_INT 24
7919: PPUSH
7920: LD_INT 30
7922: PUSH
7923: LD_INT 37
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 70
7934: IFFALSE 7947
7936: GO 7938
7938: DISABLE
// behemothUnderConstruct := true ;
7939: LD_ADDR_EXP 26
7943: PUSH
7944: LD_INT 1
7946: ST_TO_ADDR
7947: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7948: LD_INT 3
7950: PPUSH
7951: CALL 102683 0 1
7955: PUSH
7956: LD_INT 22
7958: PUSH
7959: LD_INT 3
7961: PUSH
7962: EMPTY
7963: LIST
7964: LIST
7965: PUSH
7966: LD_INT 30
7968: PUSH
7969: LD_INT 37
7971: PUSH
7972: EMPTY
7973: LIST
7974: LIST
7975: PUSH
7976: EMPTY
7977: LIST
7978: LIST
7979: PPUSH
7980: CALL_OW 69
7984: NOT
7985: AND
7986: IFFALSE 8172
7988: GO 7990
7990: DISABLE
7991: LD_INT 0
7993: PPUSH
7994: PPUSH
// begin enable ;
7995: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7996: LD_ADDR_VAR 0 2
8000: PUSH
8001: LD_INT 3
8003: PPUSH
8004: CALL 102683 0 1
8008: ST_TO_ADDR
// for i in tmp do
8009: LD_ADDR_VAR 0 1
8013: PUSH
8014: LD_VAR 0 2
8018: PUSH
8019: FOR_IN
8020: IFFALSE 8170
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
8022: LD_VAR 0 1
8026: PPUSH
8027: LD_INT 9
8029: PPUSH
8030: CALL_OW 308
8034: PUSH
8035: LD_VAR 0 1
8039: PPUSH
8040: CALL_OW 110
8044: PUSH
8045: LD_INT 2
8047: EQUAL
8048: NOT
8049: AND
8050: IFFALSE 8064
// SetTag ( i , 2 ) ;
8052: LD_VAR 0 1
8056: PPUSH
8057: LD_INT 2
8059: PPUSH
8060: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
8064: LD_INT 81
8066: PUSH
8067: LD_INT 3
8069: PUSH
8070: EMPTY
8071: LIST
8072: LIST
8073: PUSH
8074: LD_INT 91
8076: PUSH
8077: LD_VAR 0 1
8081: PUSH
8082: LD_INT 12
8084: PUSH
8085: EMPTY
8086: LIST
8087: LIST
8088: LIST
8089: PUSH
8090: EMPTY
8091: LIST
8092: LIST
8093: PPUSH
8094: CALL_OW 69
8098: NOT
8099: PUSH
8100: LD_VAR 0 1
8104: PPUSH
8105: CALL_OW 110
8109: PUSH
8110: LD_INT 2
8112: EQUAL
8113: NOT
8114: AND
8115: IFFALSE 8134
// ComAgressiveMove ( i , 64 , 93 ) else
8117: LD_VAR 0 1
8121: PPUSH
8122: LD_INT 64
8124: PPUSH
8125: LD_INT 93
8127: PPUSH
8128: CALL_OW 114
8132: GO 8168
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
8134: LD_VAR 0 1
8138: PPUSH
8139: LD_INT 81
8141: PUSH
8142: LD_INT 3
8144: PUSH
8145: EMPTY
8146: LIST
8147: LIST
8148: PPUSH
8149: CALL_OW 69
8153: PPUSH
8154: LD_VAR 0 1
8158: PPUSH
8159: CALL_OW 74
8163: PPUSH
8164: CALL_OW 115
// end ;
8168: GO 8019
8170: POP
8171: POP
// end ;
8172: PPOPN 2
8174: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8175: LD_INT 0
8177: PPUSH
8178: PPUSH
8179: PPUSH
// result := [ ] ;
8180: LD_ADDR_VAR 0 2
8184: PUSH
8185: EMPTY
8186: ST_TO_ADDR
// uc_side := 6 ;
8187: LD_ADDR_OWVAR 20
8191: PUSH
8192: LD_INT 6
8194: ST_TO_ADDR
// uc_nation := 3 ;
8195: LD_ADDR_OWVAR 21
8199: PUSH
8200: LD_INT 3
8202: ST_TO_ADDR
// case strength of 1 :
8203: LD_VAR 0 1
8207: PUSH
8208: LD_INT 1
8210: DOUBLE
8211: EQUAL
8212: IFTRUE 8216
8214: GO 8358
8216: POP
// begin for i = 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
8217: LD_ADDR_VAR 0 3
8221: PUSH
8222: DOUBLE
8223: LD_INT 1
8225: DEC
8226: ST_TO_ADDR
8227: LD_INT 4
8229: PUSH
8230: LD_INT 5
8232: PUSH
8233: LD_INT 6
8235: PUSH
8236: LD_INT 7
8238: PUSH
8239: EMPTY
8240: LIST
8241: LIST
8242: LIST
8243: LIST
8244: PUSH
8245: LD_OWVAR 67
8249: ARRAY
8250: PUSH
8251: FOR_TO
8252: IFFALSE 8354
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8254: LD_INT 22
8256: PUSH
8257: LD_INT 24
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: PUSH
8264: LD_VAR 0 3
8268: PUSH
8269: LD_INT 2
8271: MOD
8272: PUSH
8273: LD_INT 1
8275: PLUS
8276: ARRAY
8277: PPUSH
8278: LD_INT 1
8280: PUSH
8281: LD_INT 3
8283: PUSH
8284: EMPTY
8285: LIST
8286: LIST
8287: PUSH
8288: LD_INT 1
8290: PPUSH
8291: LD_INT 2
8293: PPUSH
8294: CALL_OW 12
8298: ARRAY
8299: PPUSH
8300: LD_INT 3
8302: PPUSH
8303: LD_INT 43
8305: PUSH
8306: LD_INT 44
8308: PUSH
8309: LD_INT 45
8311: PUSH
8312: EMPTY
8313: LIST
8314: LIST
8315: LIST
8316: PUSH
8317: LD_INT 1
8319: PPUSH
8320: LD_INT 3
8322: PPUSH
8323: CALL_OW 12
8327: ARRAY
8328: PPUSH
8329: LD_INT 80
8331: PPUSH
8332: CALL 70749 0 5
// result := result union CreateVehicle ;
8336: LD_ADDR_VAR 0 2
8340: PUSH
8341: LD_VAR 0 2
8345: PUSH
8346: CALL_OW 45
8350: UNION
8351: ST_TO_ADDR
// end ;
8352: GO 8251
8354: POP
8355: POP
// end ; 2 :
8356: GO 9321
8358: LD_INT 2
8360: DOUBLE
8361: EQUAL
8362: IFTRUE 8366
8364: GO 8526
8366: POP
// begin for i = 1 to [ 5 , 6 , 7 , 8 ] [ Difficulty ] do
8367: LD_ADDR_VAR 0 3
8371: PUSH
8372: DOUBLE
8373: LD_INT 1
8375: DEC
8376: ST_TO_ADDR
8377: LD_INT 5
8379: PUSH
8380: LD_INT 6
8382: PUSH
8383: LD_INT 7
8385: PUSH
8386: LD_INT 8
8388: PUSH
8389: EMPTY
8390: LIST
8391: LIST
8392: LIST
8393: LIST
8394: PUSH
8395: LD_OWVAR 67
8399: ARRAY
8400: PUSH
8401: FOR_TO
8402: IFFALSE 8522
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8404: LD_INT 22
8406: PUSH
8407: LD_INT 24
8409: PUSH
8410: LD_INT 24
8412: PUSH
8413: EMPTY
8414: LIST
8415: LIST
8416: LIST
8417: PUSH
8418: LD_VAR 0 3
8422: PUSH
8423: LD_INT 3
8425: MOD
8426: PUSH
8427: LD_INT 1
8429: PLUS
8430: ARRAY
8431: PPUSH
8432: LD_INT 1
8434: PUSH
8435: LD_INT 3
8437: PUSH
8438: EMPTY
8439: LIST
8440: LIST
8441: PUSH
8442: LD_INT 1
8444: PPUSH
8445: LD_INT 2
8447: PPUSH
8448: CALL_OW 12
8452: ARRAY
8453: PPUSH
8454: LD_INT 3
8456: PPUSH
8457: LD_INT 43
8459: PUSH
8460: LD_INT 44
8462: PUSH
8463: LD_INT 45
8465: PUSH
8466: LD_INT 44
8468: PUSH
8469: LD_INT 46
8471: PUSH
8472: LD_INT 46
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: LIST
8479: LIST
8480: LIST
8481: LIST
8482: PUSH
8483: LD_VAR 0 3
8487: PUSH
8488: LD_INT 6
8490: MOD
8491: PUSH
8492: LD_INT 1
8494: PLUS
8495: ARRAY
8496: PPUSH
8497: LD_INT 80
8499: PPUSH
8500: CALL 70749 0 5
// result := result union CreateVehicle ;
8504: LD_ADDR_VAR 0 2
8508: PUSH
8509: LD_VAR 0 2
8513: PUSH
8514: CALL_OW 45
8518: UNION
8519: ST_TO_ADDR
// end ;
8520: GO 8401
8522: POP
8523: POP
// end ; 3 :
8524: GO 9321
8526: LD_INT 3
8528: DOUBLE
8529: EQUAL
8530: IFTRUE 8534
8532: GO 8694
8534: POP
// begin for i = 1 to [ 5 , 7 , 8 , 9 ] [ Difficulty ] do
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: DOUBLE
8541: LD_INT 1
8543: DEC
8544: ST_TO_ADDR
8545: LD_INT 5
8547: PUSH
8548: LD_INT 7
8550: PUSH
8551: LD_INT 8
8553: PUSH
8554: LD_INT 9
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: PUSH
8563: LD_OWVAR 67
8567: ARRAY
8568: PUSH
8569: FOR_TO
8570: IFFALSE 8690
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8572: LD_INT 22
8574: PUSH
8575: LD_INT 24
8577: PUSH
8578: LD_INT 24
8580: PUSH
8581: EMPTY
8582: LIST
8583: LIST
8584: LIST
8585: PUSH
8586: LD_VAR 0 3
8590: PUSH
8591: LD_INT 3
8593: MOD
8594: PUSH
8595: LD_INT 1
8597: PLUS
8598: ARRAY
8599: PPUSH
8600: LD_INT 1
8602: PUSH
8603: LD_INT 3
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PUSH
8610: LD_INT 1
8612: PPUSH
8613: LD_INT 2
8615: PPUSH
8616: CALL_OW 12
8620: ARRAY
8621: PPUSH
8622: LD_INT 3
8624: PPUSH
8625: LD_INT 43
8627: PUSH
8628: LD_INT 47
8630: PUSH
8631: LD_INT 45
8633: PUSH
8634: LD_INT 45
8636: PUSH
8637: LD_INT 46
8639: PUSH
8640: LD_INT 46
8642: PUSH
8643: EMPTY
8644: LIST
8645: LIST
8646: LIST
8647: LIST
8648: LIST
8649: LIST
8650: PUSH
8651: LD_VAR 0 3
8655: PUSH
8656: LD_INT 6
8658: MOD
8659: PUSH
8660: LD_INT 1
8662: PLUS
8663: ARRAY
8664: PPUSH
8665: LD_INT 80
8667: PPUSH
8668: CALL 70749 0 5
// result := result union CreateVehicle ;
8672: LD_ADDR_VAR 0 2
8676: PUSH
8677: LD_VAR 0 2
8681: PUSH
8682: CALL_OW 45
8686: UNION
8687: ST_TO_ADDR
// end ;
8688: GO 8569
8690: POP
8691: POP
// end ; 4 :
8692: GO 9321
8694: LD_INT 4
8696: DOUBLE
8697: EQUAL
8698: IFTRUE 8702
8700: GO 9320
8702: POP
// begin uc_nation := 3 ;
8703: LD_ADDR_OWVAR 21
8707: PUSH
8708: LD_INT 3
8710: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 , 10 ] [ Difficulty ] do
8711: LD_ADDR_VAR 0 3
8715: PUSH
8716: DOUBLE
8717: LD_INT 1
8719: DEC
8720: ST_TO_ADDR
8721: LD_INT 6
8723: PUSH
8724: LD_INT 8
8726: PUSH
8727: LD_INT 9
8729: PUSH
8730: LD_INT 10
8732: PUSH
8733: EMPTY
8734: LIST
8735: LIST
8736: LIST
8737: LIST
8738: PUSH
8739: LD_OWVAR 67
8743: ARRAY
8744: PUSH
8745: FOR_TO
8746: IFFALSE 8866
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8748: LD_INT 22
8750: PUSH
8751: LD_INT 24
8753: PUSH
8754: LD_INT 24
8756: PUSH
8757: EMPTY
8758: LIST
8759: LIST
8760: LIST
8761: PUSH
8762: LD_VAR 0 3
8766: PUSH
8767: LD_INT 3
8769: MOD
8770: PUSH
8771: LD_INT 1
8773: PLUS
8774: ARRAY
8775: PPUSH
8776: LD_INT 1
8778: PUSH
8779: LD_INT 3
8781: PUSH
8782: EMPTY
8783: LIST
8784: LIST
8785: PUSH
8786: LD_INT 1
8788: PPUSH
8789: LD_INT 2
8791: PPUSH
8792: CALL_OW 12
8796: ARRAY
8797: PPUSH
8798: LD_INT 3
8800: PPUSH
8801: LD_INT 45
8803: PUSH
8804: LD_INT 47
8806: PUSH
8807: LD_INT 47
8809: PUSH
8810: LD_INT 45
8812: PUSH
8813: LD_INT 46
8815: PUSH
8816: LD_INT 46
8818: PUSH
8819: EMPTY
8820: LIST
8821: LIST
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: PUSH
8827: LD_VAR 0 3
8831: PUSH
8832: LD_INT 6
8834: MOD
8835: PUSH
8836: LD_INT 1
8838: PLUS
8839: ARRAY
8840: PPUSH
8841: LD_INT 80
8843: PPUSH
8844: CALL 70749 0 5
// result := result union CreateVehicle ;
8848: LD_ADDR_VAR 0 2
8852: PUSH
8853: LD_VAR 0 2
8857: PUSH
8858: CALL_OW 45
8862: UNION
8863: ST_TO_ADDR
// end ;
8864: GO 8745
8866: POP
8867: POP
// if not KappaStatus then
8868: LD_EXP 2
8872: NOT
8873: IFFALSE 9108
// begin uc_nation := 1 ;
8875: LD_ADDR_OWVAR 21
8879: PUSH
8880: LD_INT 1
8882: ST_TO_ADDR
// for i = 1 to 3 do
8883: LD_ADDR_VAR 0 3
8887: PUSH
8888: DOUBLE
8889: LD_INT 1
8891: DEC
8892: ST_TO_ADDR
8893: LD_INT 3
8895: PUSH
8896: FOR_TO
8897: IFFALSE 9033
// begin j := rand ( 0 , 1 ) ;
8899: LD_ADDR_VAR 0 4
8903: PUSH
8904: LD_INT 0
8906: PPUSH
8907: LD_INT 1
8909: PPUSH
8910: CALL_OW 12
8914: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8915: LD_INT 3
8917: PUSH
8918: LD_INT 5
8920: PUSH
8921: LD_INT 5
8923: PUSH
8924: LD_INT 4
8926: PUSH
8927: EMPTY
8928: LIST
8929: LIST
8930: LIST
8931: LIST
8932: PUSH
8933: LD_VAR 0 4
8937: PUSH
8938: LD_INT 1
8940: PPUSH
8941: LD_INT 3
8943: PPUSH
8944: CALL_OW 12
8948: PLUS
8949: ARRAY
8950: PPUSH
8951: LD_INT 1
8953: PUSH
8954: LD_INT 3
8956: PUSH
8957: EMPTY
8958: LIST
8959: LIST
8960: PUSH
8961: LD_INT 1
8963: PPUSH
8964: LD_INT 2
8966: PPUSH
8967: CALL_OW 12
8971: ARRAY
8972: PPUSH
8973: LD_INT 3
8975: PPUSH
8976: LD_INT 9
8978: PUSH
8979: LD_INT 7
8981: PUSH
8982: LD_INT 6
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: PUSH
8990: LD_VAR 0 4
8994: PUSH
8995: LD_INT 1
8997: PPUSH
8998: LD_INT 2
9000: PPUSH
9001: CALL_OW 12
9005: PLUS
9006: ARRAY
9007: PPUSH
9008: LD_INT 85
9010: PPUSH
9011: CALL 70749 0 5
// result := result union CreateVehicle ;
9015: LD_ADDR_VAR 0 2
9019: PUSH
9020: LD_VAR 0 2
9024: PUSH
9025: CALL_OW 45
9029: UNION
9030: ST_TO_ADDR
// end ;
9031: GO 8896
9033: POP
9034: POP
// if vsevolodFirstAttack then
9035: LD_EXP 24
9039: IFFALSE 9106
// begin vsevolodFirstAttack := false ;
9041: LD_ADDR_EXP 24
9045: PUSH
9046: LD_INT 0
9048: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
9049: LD_INT 5
9051: PPUSH
9052: LD_INT 3
9054: PPUSH
9055: LD_INT 1
9057: PPUSH
9058: LD_INT 6
9060: PPUSH
9061: LD_INT 100
9063: PPUSH
9064: CALL 70749 0 5
// sewiVeh := CreateVehicle ;
9068: LD_ADDR_EXP 71
9072: PUSH
9073: CALL_OW 45
9077: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9078: LD_EXP 71
9082: PPUSH
9083: LD_INT 1
9085: PPUSH
9086: CALL_OW 242
// result := result union sewiVeh ;
9090: LD_ADDR_VAR 0 2
9094: PUSH
9095: LD_VAR 0 2
9099: PUSH
9100: LD_EXP 71
9104: UNION
9105: ST_TO_ADDR
// end ; end else
9106: GO 9318
// if vsevolodFirstAttack then
9108: LD_EXP 24
9112: IFFALSE 9318
// begin vsevolodFirstAttack := false ;
9114: LD_ADDR_EXP 24
9118: PUSH
9119: LD_INT 0
9121: ST_TO_ADDR
// uc_nation := 3 ;
9122: LD_ADDR_OWVAR 21
9126: PUSH
9127: LD_INT 3
9129: ST_TO_ADDR
// for i = 1 to 2 + Difficulty do
9130: LD_ADDR_VAR 0 3
9134: PUSH
9135: DOUBLE
9136: LD_INT 1
9138: DEC
9139: ST_TO_ADDR
9140: LD_INT 2
9142: PUSH
9143: LD_OWVAR 67
9147: PLUS
9148: PUSH
9149: FOR_TO
9150: IFFALSE 9258
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_manual , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
9152: LD_INT 22
9154: PUSH
9155: LD_INT 24
9157: PUSH
9158: LD_INT 24
9160: PUSH
9161: EMPTY
9162: LIST
9163: LIST
9164: LIST
9165: PUSH
9166: LD_VAR 0 3
9170: PUSH
9171: LD_INT 3
9173: MOD
9174: PUSH
9175: LD_INT 1
9177: PLUS
9178: ARRAY
9179: PPUSH
9180: LD_INT 1
9182: PUSH
9183: LD_INT 3
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: LD_INT 1
9192: PPUSH
9193: LD_INT 2
9195: PPUSH
9196: CALL_OW 12
9200: ARRAY
9201: PPUSH
9202: LD_INT 1
9204: PPUSH
9205: LD_INT 45
9207: PUSH
9208: LD_INT 47
9210: PUSH
9211: LD_INT 47
9213: PUSH
9214: EMPTY
9215: LIST
9216: LIST
9217: LIST
9218: PUSH
9219: LD_VAR 0 3
9223: PUSH
9224: LD_INT 3
9226: MOD
9227: PUSH
9228: LD_INT 1
9230: PLUS
9231: ARRAY
9232: PPUSH
9233: LD_INT 80
9235: PPUSH
9236: CALL 70749 0 5
// result := result union CreateVehicle ;
9240: LD_ADDR_VAR 0 2
9244: PUSH
9245: LD_VAR 0 2
9249: PUSH
9250: CALL_OW 45
9254: UNION
9255: ST_TO_ADDR
// end ;
9256: GO 9149
9258: POP
9259: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9260: LD_INT 24
9262: PPUSH
9263: LD_INT 3
9265: PPUSH
9266: LD_INT 1
9268: PPUSH
9269: LD_INT 47
9271: PPUSH
9272: LD_INT 100
9274: PPUSH
9275: CALL 70749 0 5
// sewiVeh := CreateVehicle ;
9279: LD_ADDR_EXP 71
9283: PUSH
9284: CALL_OW 45
9288: ST_TO_ADDR
// SetMark ( sewiVeh , - 6 ) ;
9289: LD_EXP 71
9293: PPUSH
9294: LD_INT 6
9296: NEG
9297: PPUSH
9298: CALL_OW 242
// result := result union sewiVeh ;
9302: LD_ADDR_VAR 0 2
9306: PUSH
9307: LD_VAR 0 2
9311: PUSH
9312: LD_EXP 71
9316: UNION
9317: ST_TO_ADDR
// end ; end ; end ;
9318: GO 9321
9320: POP
// end ;
9321: LD_VAR 0 2
9325: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9326: LD_EXP 16
9330: IFFALSE 10175
9332: GO 9334
9334: DISABLE
9335: LD_INT 0
9337: PPUSH
9338: PPUSH
9339: PPUSH
9340: PPUSH
9341: PPUSH
9342: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9343: LD_ADDR_VAR 0 4
9347: PUSH
9348: LD_INT 11
9350: PUSH
9351: LD_INT 12
9353: PUSH
9354: EMPTY
9355: LIST
9356: LIST
9357: ST_TO_ADDR
// time := [ 5 5$30 , 4 4$50 , 4 4$40 , 4 4$30 ] [ Difficulty ] ;
9358: LD_ADDR_VAR 0 3
9362: PUSH
9363: LD_INT 11550
9365: PUSH
9366: LD_INT 10150
9368: PUSH
9369: LD_INT 9800
9371: PUSH
9372: LD_INT 9450
9374: PUSH
9375: EMPTY
9376: LIST
9377: LIST
9378: LIST
9379: LIST
9380: PUSH
9381: LD_OWVAR 67
9385: ARRAY
9386: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9387: LD_ADDR_VAR 0 6
9391: PUSH
9392: LD_INT 70
9394: PUSH
9395: LD_INT 118
9397: PUSH
9398: EMPTY
9399: LIST
9400: LIST
9401: PUSH
9402: LD_INT 78
9404: PUSH
9405: LD_INT 31
9407: PUSH
9408: EMPTY
9409: LIST
9410: LIST
9411: PUSH
9412: EMPTY
9413: LIST
9414: LIST
9415: ST_TO_ADDR
// repeat if missionStage = 2 then
9416: LD_EXP 15
9420: PUSH
9421: LD_INT 2
9423: EQUAL
9424: IFFALSE 9435
// wait ( 1 1$30 ) else
9426: LD_INT 3150
9428: PPUSH
9429: CALL_OW 67
9433: GO 9444
// wait ( time ) ;
9435: LD_VAR 0 3
9439: PPUSH
9440: CALL_OW 67
// if missionStage = 6 then
9444: LD_EXP 15
9448: PUSH
9449: LD_INT 6
9451: EQUAL
9452: IFFALSE 9480
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9454: LD_INT 51
9456: PPUSH
9457: LD_INT 6
9459: PPUSH
9460: LD_INT 2
9462: PPUSH
9463: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9467: LD_INT 57
9469: PPUSH
9470: LD_INT 6
9472: PPUSH
9473: LD_INT 2
9475: PPUSH
9476: CALL_OW 322
// end ; if missionStage = 8 then
9480: LD_EXP 15
9484: PUSH
9485: LD_INT 8
9487: EQUAL
9488: IFFALSE 9516
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9490: LD_INT 52
9492: PPUSH
9493: LD_INT 6
9495: PPUSH
9496: LD_INT 2
9498: PPUSH
9499: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9503: LD_INT 58
9505: PPUSH
9506: LD_INT 6
9508: PPUSH
9509: LD_INT 2
9511: PPUSH
9512: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9516: LD_EXP 15
9520: PUSH
9521: LD_INT 10
9523: EQUAL
9524: PUSH
9525: LD_OWVAR 67
9529: PUSH
9530: LD_INT 1
9532: GREATER
9533: AND
9534: IFFALSE 9562
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9536: LD_INT 53
9538: PPUSH
9539: LD_INT 6
9541: PPUSH
9542: LD_INT 2
9544: PPUSH
9545: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9549: LD_INT 59
9551: PPUSH
9552: LD_INT 6
9554: PPUSH
9555: LD_INT 2
9557: PPUSH
9558: CALL_OW 322
// end ; if activeAttacks then
9562: LD_EXP 16
9566: IFFALSE 10169
// begin if missionStage = 2 then
9568: LD_EXP 15
9572: PUSH
9573: LD_INT 2
9575: EQUAL
9576: IFFALSE 9586
// strength := 1 ;
9578: LD_ADDR_VAR 0 5
9582: PUSH
9583: LD_INT 1
9585: ST_TO_ADDR
// if missionStage > 2 then
9586: LD_EXP 15
9590: PUSH
9591: LD_INT 2
9593: GREATER
9594: IFFALSE 9604
// strength := 2 ;
9596: LD_ADDR_VAR 0 5
9600: PUSH
9601: LD_INT 2
9603: ST_TO_ADDR
// if missionStage > 6 then
9604: LD_EXP 15
9608: PUSH
9609: LD_INT 6
9611: GREATER
9612: IFFALSE 9622
// strength := 3 ;
9614: LD_ADDR_VAR 0 5
9618: PUSH
9619: LD_INT 3
9621: ST_TO_ADDR
// if missionStage > 10 then
9622: LD_EXP 15
9626: PUSH
9627: LD_INT 10
9629: GREATER
9630: IFFALSE 9640
// strength := 4 ;
9632: LD_ADDR_VAR 0 5
9636: PUSH
9637: LD_INT 4
9639: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9640: LD_ADDR_VAR 0 2
9644: PUSH
9645: LD_VAR 0 5
9649: PPUSH
9650: CALL 8175 0 1
9654: ST_TO_ADDR
// for i in tmp do
9655: LD_ADDR_VAR 0 1
9659: PUSH
9660: LD_VAR 0 2
9664: PUSH
9665: FOR_IN
9666: IFFALSE 9849
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9668: LD_VAR 0 1
9672: PPUSH
9673: LD_VAR 0 4
9677: PUSH
9678: LD_INT 1
9680: PPUSH
9681: LD_INT 2
9683: PPUSH
9684: CALL_OW 12
9688: ARRAY
9689: PPUSH
9690: LD_INT 0
9692: PPUSH
9693: CALL_OW 49
// if i = sewiVeh then
9697: LD_VAR 0 1
9701: PUSH
9702: LD_EXP 71
9706: EQUAL
9707: IFFALSE 9744
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9709: LD_ADDR_EXP 70
9713: PUSH
9714: LD_STRING Vsevolod
9716: PPUSH
9717: LD_INT 0
9719: PPUSH
9720: LD_STRING 
9722: PPUSH
9723: CALL 65885 0 3
9727: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9728: LD_EXP 70
9732: PPUSH
9733: LD_VAR 0 1
9737: PPUSH
9738: CALL_OW 52
// end else
9742: GO 9825
// if GetControl ( i ) = control_manual then
9744: LD_VAR 0 1
9748: PPUSH
9749: CALL_OW 263
9753: PUSH
9754: LD_INT 1
9756: EQUAL
9757: IFFALSE 9825
// begin uc_side := 6 ;
9759: LD_ADDR_OWVAR 20
9763: PUSH
9764: LD_INT 6
9766: ST_TO_ADDR
// uc_nation := 3 ;
9767: LD_ADDR_OWVAR 21
9771: PUSH
9772: LD_INT 3
9774: ST_TO_ADDR
// hc_gallery :=  ;
9775: LD_ADDR_OWVAR 33
9779: PUSH
9780: LD_STRING 
9782: ST_TO_ADDR
// hc_name :=  ;
9783: LD_ADDR_OWVAR 26
9787: PUSH
9788: LD_STRING 
9790: ST_TO_ADDR
// PrepareHuman ( false , 3 , 10 ) ;
9791: LD_INT 0
9793: PPUSH
9794: LD_INT 3
9796: PPUSH
9797: LD_INT 10
9799: PPUSH
9800: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , i ) ;
9804: CALL_OW 44
9808: PPUSH
9809: LD_VAR 0 1
9813: PPUSH
9814: CALL_OW 52
// wait ( 0 0$0.3 ) ;
9818: LD_INT 10
9820: PPUSH
9821: CALL_OW 67
// end ; ComMoveXY ( i , 111 , 197 ) ;
9825: LD_VAR 0 1
9829: PPUSH
9830: LD_INT 111
9832: PPUSH
9833: LD_INT 197
9835: PPUSH
9836: CALL_OW 111
// wait ( 0 0$2 ) ;
9840: LD_INT 70
9842: PPUSH
9843: CALL_OW 67
// end ;
9847: GO 9665
9849: POP
9850: POP
// repeat wait ( 0 0$1 ) ;
9851: LD_INT 35
9853: PPUSH
9854: CALL_OW 67
// for i in tmp do
9858: LD_ADDR_VAR 0 1
9862: PUSH
9863: LD_VAR 0 2
9867: PUSH
9868: FOR_IN
9869: IFFALSE 10150
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9871: LD_INT 81
9873: PUSH
9874: LD_INT 6
9876: PUSH
9877: EMPTY
9878: LIST
9879: LIST
9880: PUSH
9881: LD_INT 91
9883: PUSH
9884: LD_VAR 0 1
9888: PUSH
9889: LD_INT 12
9891: PUSH
9892: EMPTY
9893: LIST
9894: LIST
9895: LIST
9896: PUSH
9897: EMPTY
9898: LIST
9899: LIST
9900: PPUSH
9901: CALL_OW 69
9905: IFFALSE 9963
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9907: LD_VAR 0 1
9911: PPUSH
9912: LD_INT 81
9914: PUSH
9915: LD_INT 6
9917: PUSH
9918: EMPTY
9919: LIST
9920: LIST
9921: PUSH
9922: LD_INT 91
9924: PUSH
9925: LD_VAR 0 1
9929: PUSH
9930: LD_INT 12
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PUSH
9938: EMPTY
9939: LIST
9940: LIST
9941: PPUSH
9942: CALL_OW 69
9946: PPUSH
9947: LD_VAR 0 1
9951: PPUSH
9952: CALL_OW 74
9956: PPUSH
9957: CALL_OW 115
9961: GO 10148
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9963: LD_INT 9
9965: PPUSH
9966: LD_INT 81
9968: PUSH
9969: LD_INT 6
9971: PUSH
9972: EMPTY
9973: LIST
9974: LIST
9975: PPUSH
9976: CALL_OW 70
9980: IFFALSE 10114
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9982: LD_VAR 0 1
9986: PPUSH
9987: LD_VAR 0 6
9991: PUSH
9992: LD_INT 1
9994: ARRAY
9995: PUSH
9996: LD_INT 1
9998: ARRAY
9999: PPUSH
10000: LD_VAR 0 6
10004: PUSH
10005: LD_INT 1
10007: ARRAY
10008: PUSH
10009: LD_INT 2
10011: ARRAY
10012: PPUSH
10013: CALL_OW 297
10017: PUSH
10018: LD_INT 10
10020: GREATER
10021: PUSH
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_INT 9
10029: PPUSH
10030: CALL_OW 308
10034: NOT
10035: AND
10036: IFFALSE 10075
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
10038: LD_VAR 0 1
10042: PPUSH
10043: LD_VAR 0 6
10047: PUSH
10048: LD_INT 1
10050: ARRAY
10051: PUSH
10052: LD_INT 1
10054: ARRAY
10055: PPUSH
10056: LD_VAR 0 6
10060: PUSH
10061: LD_INT 1
10063: ARRAY
10064: PUSH
10065: LD_INT 2
10067: ARRAY
10068: PPUSH
10069: CALL_OW 114
10073: GO 10112
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
10075: LD_VAR 0 1
10079: PPUSH
10080: LD_INT 9
10082: PPUSH
10083: LD_INT 81
10085: PUSH
10086: LD_INT 6
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: PPUSH
10093: CALL_OW 70
10097: PPUSH
10098: LD_VAR 0 1
10102: PPUSH
10103: CALL_OW 74
10107: PPUSH
10108: CALL_OW 115
// end else
10112: GO 10148
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
10114: LD_VAR 0 1
10118: PPUSH
10119: LD_INT 81
10121: PUSH
10122: LD_INT 6
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: PPUSH
10129: CALL_OW 69
10133: PPUSH
10134: LD_VAR 0 1
10138: PPUSH
10139: CALL_OW 74
10143: PPUSH
10144: CALL_OW 115
// end ;
10148: GO 9868
10150: POP
10151: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
10152: LD_INT 22
10154: PUSH
10155: LD_INT 6
10157: PUSH
10158: EMPTY
10159: LIST
10160: LIST
10161: PPUSH
10162: CALL_OW 69
10166: NOT
10167: IFFALSE 9851
// end ; until russianDestroyed ;
10169: LD_EXP 21
10173: IFFALSE 9416
// end ;
10175: PPOPN 6
10177: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
10178: LD_EXP 21
10182: NOT
10183: PUSH
10184: LD_EXP 15
10188: PUSH
10189: LD_INT 6
10191: GREATEREQUAL
10192: AND
10193: PUSH
10194: LD_INT 2
10196: PPUSH
10197: LD_INT 1
10199: PPUSH
10200: CALL 60897 0 2
10204: NOT
10205: AND
10206: IFFALSE 11166
10208: GO 10210
10210: DISABLE
10211: LD_INT 0
10213: PPUSH
10214: PPUSH
10215: PPUSH
10216: PPUSH
// begin enable ;
10217: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
10218: LD_INT 22
10220: PUSH
10221: LD_INT 3
10223: PUSH
10224: EMPTY
10225: LIST
10226: LIST
10227: PUSH
10228: LD_INT 30
10230: PUSH
10231: LD_INT 3
10233: PUSH
10234: EMPTY
10235: LIST
10236: LIST
10237: PUSH
10238: EMPTY
10239: LIST
10240: LIST
10241: PPUSH
10242: CALL_OW 69
10246: NOT
10247: IFFALSE 10251
// exit ;
10249: GO 11166
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
10251: LD_ADDR_VAR 0 4
10255: PUSH
10256: LD_INT 22
10258: PUSH
10259: LD_INT 3
10261: PUSH
10262: EMPTY
10263: LIST
10264: LIST
10265: PUSH
10266: LD_INT 30
10268: PUSH
10269: LD_INT 34
10271: PUSH
10272: EMPTY
10273: LIST
10274: LIST
10275: PUSH
10276: EMPTY
10277: LIST
10278: LIST
10279: PPUSH
10280: CALL_OW 69
10284: ST_TO_ADDR
// if Prob ( 40 ) then
10285: LD_INT 40
10287: PPUSH
10288: CALL_OW 13
10292: IFFALSE 10419
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10294: LD_INT 2
10296: PPUSH
10297: LD_INT 22
10299: PUSH
10300: LD_INT 3
10302: PUSH
10303: LD_INT 3
10305: PUSH
10306: LD_INT 49
10308: PUSH
10309: EMPTY
10310: LIST
10311: LIST
10312: LIST
10313: LIST
10314: PUSH
10315: LD_INT 22
10317: PUSH
10318: LD_INT 3
10320: PUSH
10321: LD_INT 3
10323: PUSH
10324: LD_INT 49
10326: PUSH
10327: EMPTY
10328: LIST
10329: LIST
10330: LIST
10331: LIST
10332: PUSH
10333: LD_INT 22
10335: PUSH
10336: LD_INT 3
10338: PUSH
10339: LD_INT 3
10341: PUSH
10342: LD_INT 49
10344: PUSH
10345: EMPTY
10346: LIST
10347: LIST
10348: LIST
10349: LIST
10350: PUSH
10351: LD_INT 24
10353: PUSH
10354: LD_INT 3
10356: PUSH
10357: LD_INT 3
10359: PUSH
10360: LD_INT 46
10362: PUSH
10363: EMPTY
10364: LIST
10365: LIST
10366: LIST
10367: LIST
10368: PUSH
10369: LD_INT 24
10371: PUSH
10372: LD_INT 3
10374: PUSH
10375: LD_INT 3
10377: PUSH
10378: LD_INT 46
10380: PUSH
10381: EMPTY
10382: LIST
10383: LIST
10384: LIST
10385: LIST
10386: PUSH
10387: LD_INT 24
10389: PUSH
10390: LD_INT 3
10392: PUSH
10393: LD_INT 3
10395: PUSH
10396: LD_INT 46
10398: PUSH
10399: EMPTY
10400: LIST
10401: LIST
10402: LIST
10403: LIST
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: LIST
10409: LIST
10410: LIST
10411: LIST
10412: PPUSH
10413: CALL 59479 0 2
// end else
10417: GO 10542
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10419: LD_INT 2
10421: PPUSH
10422: LD_INT 24
10424: PUSH
10425: LD_INT 3
10427: PUSH
10428: LD_INT 3
10430: PUSH
10431: LD_INT 47
10433: PUSH
10434: EMPTY
10435: LIST
10436: LIST
10437: LIST
10438: LIST
10439: PUSH
10440: LD_INT 24
10442: PUSH
10443: LD_INT 3
10445: PUSH
10446: LD_INT 3
10448: PUSH
10449: LD_INT 47
10451: PUSH
10452: EMPTY
10453: LIST
10454: LIST
10455: LIST
10456: LIST
10457: PUSH
10458: LD_INT 24
10460: PUSH
10461: LD_INT 3
10463: PUSH
10464: LD_INT 3
10466: PUSH
10467: LD_INT 47
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: PUSH
10476: LD_INT 24
10478: PUSH
10479: LD_INT 3
10481: PUSH
10482: LD_INT 3
10484: PUSH
10485: LD_INT 46
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: LIST
10492: LIST
10493: PUSH
10494: LD_INT 24
10496: PUSH
10497: LD_INT 3
10499: PUSH
10500: LD_INT 3
10502: PUSH
10503: LD_INT 46
10505: PUSH
10506: EMPTY
10507: LIST
10508: LIST
10509: LIST
10510: LIST
10511: PUSH
10512: LD_INT 24
10514: PUSH
10515: LD_INT 3
10517: PUSH
10518: LD_INT 3
10520: PUSH
10521: LD_INT 46
10523: PUSH
10524: EMPTY
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: PUSH
10530: EMPTY
10531: LIST
10532: LIST
10533: LIST
10534: LIST
10535: LIST
10536: LIST
10537: PPUSH
10538: CALL 59479 0 2
// end ; if Difficulty > 1 then
10542: LD_OWVAR 67
10546: PUSH
10547: LD_INT 1
10549: GREATER
10550: IFFALSE 10580
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10552: LD_INT 2
10554: PPUSH
10555: LD_INT 24
10557: PUSH
10558: LD_INT 3
10560: PUSH
10561: LD_INT 3
10563: PUSH
10564: LD_INT 47
10566: PUSH
10567: EMPTY
10568: LIST
10569: LIST
10570: LIST
10571: LIST
10572: PUSH
10573: EMPTY
10574: LIST
10575: PPUSH
10576: CALL 59479 0 2
// repeat wait ( 0 0$1 ) ;
10580: LD_INT 35
10582: PPUSH
10583: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
10587: LD_INT 2
10589: PPUSH
10590: LD_INT 1
10592: PPUSH
10593: CALL 60897 0 2
10597: PUSH
10598: LD_INT 6
10600: PUSH
10601: LD_INT 7
10603: PUSH
10604: LD_INT 7
10606: PUSH
10607: LD_INT 7
10609: PUSH
10610: EMPTY
10611: LIST
10612: LIST
10613: LIST
10614: LIST
10615: PUSH
10616: LD_OWVAR 67
10620: ARRAY
10621: GREATEREQUAL
10622: IFFALSE 10580
// wait ( 0 0$30 ) ;
10624: LD_INT 1050
10626: PPUSH
10627: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10631: LD_ADDR_VAR 0 2
10635: PUSH
10636: LD_INT 2
10638: PPUSH
10639: LD_INT 1
10641: PPUSH
10642: CALL 60897 0 2
10646: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10647: LD_ADDR_EXP 135
10651: PUSH
10652: LD_EXP 135
10656: PPUSH
10657: LD_INT 2
10659: PPUSH
10660: LD_EXP 135
10664: PUSH
10665: LD_INT 2
10667: ARRAY
10668: PUSH
10669: LD_VAR 0 2
10673: DIFF
10674: PPUSH
10675: CALL_OW 1
10679: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10680: LD_ADDR_VAR 0 3
10684: PUSH
10685: LD_INT 0
10687: PPUSH
10688: LD_INT 1
10690: PPUSH
10691: CALL_OW 12
10695: ST_TO_ADDR
// if target then
10696: LD_VAR 0 3
10700: IFFALSE 10828
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10702: LD_ADDR_VAR 0 2
10706: PUSH
10707: LD_VAR 0 2
10711: PPUSH
10712: LD_INT 24
10714: PUSH
10715: LD_INT 250
10717: PUSH
10718: EMPTY
10719: LIST
10720: LIST
10721: PPUSH
10722: CALL_OW 72
10726: ST_TO_ADDR
// for i in tmp do
10727: LD_ADDR_VAR 0 1
10731: PUSH
10732: LD_VAR 0 2
10736: PUSH
10737: FOR_IN
10738: IFFALSE 10778
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10740: LD_VAR 0 1
10744: PPUSH
10745: LD_INT 139
10747: PPUSH
10748: LD_INT 89
10750: PPUSH
10751: CALL_OW 297
10755: PUSH
10756: LD_INT 9
10758: GREATER
10759: IFFALSE 10776
// ComMoveXY ( i , 139 , 89 ) ;
10761: LD_VAR 0 1
10765: PPUSH
10766: LD_INT 139
10768: PPUSH
10769: LD_INT 89
10771: PPUSH
10772: CALL_OW 111
10776: GO 10737
10778: POP
10779: POP
// wait ( 0 0$1 ) ;
10780: LD_INT 35
10782: PPUSH
10783: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10787: LD_VAR 0 2
10791: PPUSH
10792: LD_INT 92
10794: PUSH
10795: LD_INT 139
10797: PUSH
10798: LD_INT 89
10800: PUSH
10801: LD_INT 9
10803: PUSH
10804: EMPTY
10805: LIST
10806: LIST
10807: LIST
10808: LIST
10809: PPUSH
10810: CALL_OW 72
10814: PUSH
10815: LD_VAR 0 2
10819: PUSH
10820: LD_INT 1
10822: MINUS
10823: GREATEREQUAL
10824: IFFALSE 10702
// end else
10826: GO 10970
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10828: LD_VAR 0 2
10832: PPUSH
10833: LD_VAR 0 4
10837: PUSH
10838: LD_INT 1
10840: ARRAY
10841: PPUSH
10842: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10846: LD_ADDR_VAR 0 2
10850: PUSH
10851: LD_VAR 0 2
10855: PPUSH
10856: LD_INT 24
10858: PUSH
10859: LD_INT 250
10861: PUSH
10862: EMPTY
10863: LIST
10864: LIST
10865: PPUSH
10866: CALL_OW 72
10870: ST_TO_ADDR
// for i in tmp do
10871: LD_ADDR_VAR 0 1
10875: PUSH
10876: LD_VAR 0 2
10880: PUSH
10881: FOR_IN
10882: IFFALSE 10922
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10884: LD_VAR 0 1
10888: PPUSH
10889: LD_INT 124
10891: PPUSH
10892: LD_INT 139
10894: PPUSH
10895: CALL_OW 297
10899: PUSH
10900: LD_INT 9
10902: GREATER
10903: IFFALSE 10920
// ComMoveXY ( i , 124 , 139 ) ;
10905: LD_VAR 0 1
10909: PPUSH
10910: LD_INT 124
10912: PPUSH
10913: LD_INT 139
10915: PPUSH
10916: CALL_OW 111
10920: GO 10881
10922: POP
10923: POP
// wait ( 0 0$1 ) ;
10924: LD_INT 35
10926: PPUSH
10927: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10931: LD_VAR 0 2
10935: PPUSH
10936: LD_INT 92
10938: PUSH
10939: LD_INT 124
10941: PUSH
10942: LD_INT 139
10944: PUSH
10945: LD_INT 9
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: LIST
10952: LIST
10953: PPUSH
10954: CALL_OW 72
10958: PUSH
10959: LD_VAR 0 2
10963: PUSH
10964: LD_INT 1
10966: MINUS
10967: GREATEREQUAL
10968: IFFALSE 10846
// end ; repeat wait ( 0 0$1 ) ;
10970: LD_INT 35
10972: PPUSH
10973: CALL_OW 67
// for i in tmp do
10977: LD_ADDR_VAR 0 1
10981: PUSH
10982: LD_VAR 0 2
10986: PUSH
10987: FOR_IN
10988: IFFALSE 11157
// begin if GetLives ( i ) > 251 then
10990: LD_VAR 0 1
10994: PPUSH
10995: CALL_OW 256
10999: PUSH
11000: LD_INT 251
11002: GREATER
11003: IFFALSE 11128
// begin if GetWeapon ( i ) = ru_time_lapser then
11005: LD_VAR 0 1
11009: PPUSH
11010: CALL_OW 264
11014: PUSH
11015: LD_INT 49
11017: EQUAL
11018: IFFALSE 11074
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
11020: LD_VAR 0 1
11024: PPUSH
11025: LD_INT 2
11027: PUSH
11028: LD_INT 22
11030: PUSH
11031: LD_INT 1
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PUSH
11038: LD_INT 22
11040: PUSH
11041: LD_INT 8
11043: PUSH
11044: EMPTY
11045: LIST
11046: LIST
11047: PUSH
11048: EMPTY
11049: LIST
11050: LIST
11051: LIST
11052: PPUSH
11053: CALL_OW 69
11057: PPUSH
11058: LD_VAR 0 1
11062: PPUSH
11063: CALL_OW 74
11067: PPUSH
11068: CALL_OW 112
11072: GO 11126
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
11074: LD_VAR 0 1
11078: PPUSH
11079: LD_INT 2
11081: PUSH
11082: LD_INT 22
11084: PUSH
11085: LD_INT 1
11087: PUSH
11088: EMPTY
11089: LIST
11090: LIST
11091: PUSH
11092: LD_INT 22
11094: PUSH
11095: LD_INT 8
11097: PUSH
11098: EMPTY
11099: LIST
11100: LIST
11101: PUSH
11102: EMPTY
11103: LIST
11104: LIST
11105: LIST
11106: PPUSH
11107: CALL_OW 69
11111: PPUSH
11112: LD_VAR 0 1
11116: PPUSH
11117: CALL_OW 74
11121: PPUSH
11122: CALL_OW 115
// end else
11126: GO 11155
// if IsDead ( i ) then
11128: LD_VAR 0 1
11132: PPUSH
11133: CALL_OW 301
11137: IFFALSE 11155
// tmp := tmp diff i ;
11139: LD_ADDR_VAR 0 2
11143: PUSH
11144: LD_VAR 0 2
11148: PUSH
11149: LD_VAR 0 1
11153: DIFF
11154: ST_TO_ADDR
// end ;
11155: GO 10987
11157: POP
11158: POP
// until not tmp ;
11159: LD_VAR 0 2
11163: NOT
11164: IFFALSE 10970
// end ; end_of_file
11166: PPOPN 4
11168: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
11169: LD_INT 0
11171: PPUSH
11172: PPUSH
11173: PPUSH
11174: PPUSH
11175: PPUSH
11176: PPUSH
// side := 7 ;
11177: LD_ADDR_VAR 0 5
11181: PUSH
11182: LD_INT 7
11184: ST_TO_ADDR
// uc_side := side ;
11185: LD_ADDR_OWVAR 20
11189: PUSH
11190: LD_VAR 0 5
11194: ST_TO_ADDR
// uc_nation := 1 ;
11195: LD_ADDR_OWVAR 21
11199: PUSH
11200: LD_INT 1
11202: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
11203: LD_ADDR_VAR 0 2
11207: PUSH
11208: LD_INT 22
11210: PUSH
11211: LD_VAR 0 5
11215: PUSH
11216: EMPTY
11217: LIST
11218: LIST
11219: PUSH
11220: LD_INT 21
11222: PUSH
11223: LD_INT 3
11225: PUSH
11226: EMPTY
11227: LIST
11228: LIST
11229: PUSH
11230: EMPTY
11231: LIST
11232: LIST
11233: PPUSH
11234: CALL_OW 69
11238: PUSH
11239: FOR_IN
11240: IFFALSE 11256
// SetBLevel ( i , 10 ) ;
11242: LD_VAR 0 2
11246: PPUSH
11247: LD_INT 10
11249: PPUSH
11250: CALL_OW 241
11254: GO 11239
11256: POP
11257: POP
// base := GetBase ( al_depot ) ;
11258: LD_ADDR_VAR 0 4
11262: PUSH
11263: LD_INT 2
11265: PPUSH
11266: CALL_OW 274
11270: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
11271: LD_ADDR_VAR 0 6
11275: PUSH
11276: LD_INT 22
11278: PUSH
11279: LD_VAR 0 5
11283: PUSH
11284: EMPTY
11285: LIST
11286: LIST
11287: PUSH
11288: LD_INT 30
11290: PUSH
11291: LD_INT 34
11293: PUSH
11294: EMPTY
11295: LIST
11296: LIST
11297: PUSH
11298: EMPTY
11299: LIST
11300: LIST
11301: PPUSH
11302: CALL_OW 69
11306: ST_TO_ADDR
// if teleport then
11307: LD_VAR 0 6
11311: IFFALSE 11332
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11313: LD_VAR 0 6
11317: PUSH
11318: LD_INT 1
11320: ARRAY
11321: PPUSH
11322: LD_INT 262
11324: PPUSH
11325: LD_INT 119
11327: PPUSH
11328: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11332: LD_VAR 0 4
11336: PPUSH
11337: LD_INT 1
11339: PPUSH
11340: LD_INT 19500
11342: PPUSH
11343: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11347: LD_VAR 0 4
11351: PPUSH
11352: LD_INT 2
11354: PPUSH
11355: LD_INT 200
11357: PPUSH
11358: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11362: LD_VAR 0 4
11366: PPUSH
11367: LD_INT 3
11369: PPUSH
11370: LD_INT 650
11372: PPUSH
11373: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11377: LD_ADDR_EXP 74
11381: PUSH
11382: LD_STRING Roth
11384: PPUSH
11385: CALL_OW 25
11389: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11390: LD_ADDR_EXP 75
11394: PUSH
11395: LD_STRING Simms
11397: PPUSH
11398: LD_EXP 1
11402: NOT
11403: PPUSH
11404: LD_STRING 10c_
11406: PPUSH
11407: CALL 65885 0 3
11411: ST_TO_ADDR
// if not Simms then
11412: LD_EXP 75
11416: NOT
11417: IFFALSE 11447
// begin uc_nation := 1 ;
11419: LD_ADDR_OWVAR 21
11423: PUSH
11424: LD_INT 1
11426: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11427: LD_INT 2
11429: PPUSH
11430: LD_INT 10
11432: PPUSH
11433: CALL_OW 384
// Simms := CreateHuman ;
11437: LD_ADDR_EXP 75
11441: PUSH
11442: CALL_OW 44
11446: ST_TO_ADDR
// end ; uc_nation := 3 ;
11447: LD_ADDR_OWVAR 21
11451: PUSH
11452: LD_INT 3
11454: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11455: LD_ADDR_EXP 76
11459: PUSH
11460: LD_STRING Kirilenkova
11462: PPUSH
11463: CALL_OW 25
11467: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11468: LD_ADDR_EXP 90
11472: PUSH
11473: LD_STRING Oblukov
11475: PPUSH
11476: CALL_OW 25
11480: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11481: LD_ADDR_EXP 77
11485: PUSH
11486: LD_STRING Dolgov
11488: PPUSH
11489: CALL_OW 25
11493: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11494: LD_ADDR_EXP 78
11498: PUSH
11499: LD_STRING Petrosyan
11501: PPUSH
11502: CALL_OW 25
11506: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11507: LD_ADDR_EXP 89
11511: PUSH
11512: LD_STRING Scholtze
11514: PPUSH
11515: CALL_OW 25
11519: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11520: LD_ADDR_EXP 88
11524: PUSH
11525: LD_STRING Kapitsova
11527: PPUSH
11528: CALL_OW 25
11532: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11533: LD_ADDR_EXP 79
11537: PUSH
11538: LD_STRING Petrovova
11540: PPUSH
11541: CALL_OW 25
11545: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11546: LD_ADDR_EXP 80
11550: PUSH
11551: LD_STRING Kuzmov
11553: PPUSH
11554: CALL_OW 25
11558: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11559: LD_ADDR_EXP 87
11563: PUSH
11564: LD_STRING Karamazov
11566: PPUSH
11567: CALL_OW 25
11571: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11572: LD_STRING 13_Lipshchin_1
11574: PPUSH
11575: LD_INT 0
11577: PPUSH
11578: CALL_OW 30
11582: IFFALSE 11597
// Lipshchin := NewCharacter ( Lipshchin ) ;
11584: LD_ADDR_EXP 81
11588: PUSH
11589: LD_STRING Lipshchin
11591: PPUSH
11592: CALL_OW 25
11596: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11597: LD_STRING 13_Titov_1
11599: PPUSH
11600: LD_INT 0
11602: PPUSH
11603: CALL_OW 30
11607: IFFALSE 11622
// Titov := NewCharacter ( Titov ) ;
11609: LD_ADDR_EXP 83
11613: PUSH
11614: LD_STRING Titov
11616: PPUSH
11617: CALL_OW 25
11621: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11622: LD_STRING 13_Gnyevko_1
11624: PPUSH
11625: LD_INT 0
11627: PPUSH
11628: CALL_OW 30
11632: IFFALSE 11647
// Gnyevko := NewCharacter ( Gnyevko ) ;
11634: LD_ADDR_EXP 82
11638: PUSH
11639: LD_STRING Gnyevko
11641: PPUSH
11642: CALL_OW 25
11646: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11647: LD_STRING 13_Xavier_1
11649: PPUSH
11650: LD_INT 0
11652: PPUSH
11653: CALL_OW 30
11657: IFFALSE 11672
// Xavier := NewCharacter ( Xavier2 ) ;
11659: LD_ADDR_EXP 84
11663: PUSH
11664: LD_STRING Xavier2
11666: PPUSH
11667: CALL_OW 25
11671: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11672: LD_STRING 13_Belkov_1
11674: PPUSH
11675: LD_INT 0
11677: PPUSH
11678: CALL_OW 30
11682: IFFALSE 11697
// Belkov := NewCharacter ( Belkov ) ;
11684: LD_ADDR_EXP 85
11688: PUSH
11689: LD_STRING Belkov
11691: PPUSH
11692: CALL_OW 25
11696: ST_TO_ADDR
// if not BurlakStatus then
11697: LD_EXP 9
11701: NOT
11702: IFFALSE 11717
// Burlak = NewCharacter ( Burlak ) ;
11704: LD_ADDR_EXP 86
11708: PUSH
11709: LD_STRING Burlak
11711: PPUSH
11712: CALL_OW 25
11716: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11717: LD_ADDR_VAR 0 3
11721: PUSH
11722: LD_EXP 74
11726: PUSH
11727: LD_EXP 76
11731: PUSH
11732: LD_EXP 90
11736: PUSH
11737: LD_EXP 77
11741: PUSH
11742: LD_EXP 78
11746: PUSH
11747: LD_EXP 89
11751: PUSH
11752: LD_EXP 88
11756: PUSH
11757: LD_EXP 79
11761: PUSH
11762: LD_EXP 80
11766: PUSH
11767: LD_EXP 87
11771: PUSH
11772: EMPTY
11773: LIST
11774: LIST
11775: LIST
11776: LIST
11777: LIST
11778: LIST
11779: LIST
11780: LIST
11781: LIST
11782: LIST
11783: ST_TO_ADDR
// if Simms then
11784: LD_EXP 75
11788: IFFALSE 11806
// tmp := tmp ^ Simms ;
11790: LD_ADDR_VAR 0 3
11794: PUSH
11795: LD_VAR 0 3
11799: PUSH
11800: LD_EXP 75
11804: ADD
11805: ST_TO_ADDR
// if Titov then
11806: LD_EXP 83
11810: IFFALSE 11828
// tmp := tmp ^ Titov ;
11812: LD_ADDR_VAR 0 3
11816: PUSH
11817: LD_VAR 0 3
11821: PUSH
11822: LD_EXP 83
11826: ADD
11827: ST_TO_ADDR
// if Lipshchin then
11828: LD_EXP 81
11832: IFFALSE 11850
// tmp := tmp ^ Lipshchin ;
11834: LD_ADDR_VAR 0 3
11838: PUSH
11839: LD_VAR 0 3
11843: PUSH
11844: LD_EXP 81
11848: ADD
11849: ST_TO_ADDR
// if Gnyevko then
11850: LD_EXP 82
11854: IFFALSE 11872
// tmp := tmp ^ Gnyevko ;
11856: LD_ADDR_VAR 0 3
11860: PUSH
11861: LD_VAR 0 3
11865: PUSH
11866: LD_EXP 82
11870: ADD
11871: ST_TO_ADDR
// if Xavier then
11872: LD_EXP 84
11876: IFFALSE 11894
// tmp := tmp ^ Xavier ;
11878: LD_ADDR_VAR 0 3
11882: PUSH
11883: LD_VAR 0 3
11887: PUSH
11888: LD_EXP 84
11892: ADD
11893: ST_TO_ADDR
// if Belkov then
11894: LD_EXP 85
11898: IFFALSE 11916
// tmp := tmp ^ Belkov ;
11900: LD_ADDR_VAR 0 3
11904: PUSH
11905: LD_VAR 0 3
11909: PUSH
11910: LD_EXP 85
11914: ADD
11915: ST_TO_ADDR
// if Burlak then
11916: LD_EXP 86
11920: IFFALSE 11938
// tmp := tmp ^ Burlak ;
11922: LD_ADDR_VAR 0 3
11926: PUSH
11927: LD_VAR 0 3
11931: PUSH
11932: LD_EXP 86
11936: ADD
11937: ST_TO_ADDR
// for i = 1 to 11 do
11938: LD_ADDR_VAR 0 2
11942: PUSH
11943: DOUBLE
11944: LD_INT 1
11946: DEC
11947: ST_TO_ADDR
11948: LD_INT 11
11950: PUSH
11951: FOR_TO
11952: IFFALSE 12018
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11954: LD_ADDR_OWVAR 21
11958: PUSH
11959: LD_INT 1
11961: PUSH
11962: LD_INT 3
11964: PUSH
11965: EMPTY
11966: LIST
11967: LIST
11968: PUSH
11969: LD_INT 1
11971: PPUSH
11972: LD_INT 2
11974: PPUSH
11975: CALL_OW 12
11979: ARRAY
11980: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11981: LD_INT 0
11983: PPUSH
11984: LD_VAR 0 2
11988: PUSH
11989: LD_INT 2
11991: DIV
11992: PPUSH
11993: LD_INT 10
11995: PPUSH
11996: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
12000: LD_ADDR_VAR 0 3
12004: PUSH
12005: LD_VAR 0 3
12009: PUSH
12010: CALL_OW 44
12014: ADD
12015: ST_TO_ADDR
// end ;
12016: GO 11951
12018: POP
12019: POP
// for i in tmp do
12020: LD_ADDR_VAR 0 2
12024: PUSH
12025: LD_VAR 0 3
12029: PUSH
12030: FOR_IN
12031: IFFALSE 12056
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
12033: LD_VAR 0 2
12037: PPUSH
12038: LD_INT 260
12040: PPUSH
12041: LD_INT 235
12043: PPUSH
12044: LD_INT 8
12046: PPUSH
12047: LD_INT 0
12049: PPUSH
12050: CALL_OW 50
12054: GO 12030
12056: POP
12057: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
12058: LD_ADDR_EXP 116
12062: PUSH
12063: LD_EXP 116
12067: PPUSH
12068: LD_INT 1
12070: PPUSH
12071: LD_INT 22
12073: PUSH
12074: LD_VAR 0 5
12078: PUSH
12079: EMPTY
12080: LIST
12081: LIST
12082: PUSH
12083: LD_INT 3
12085: PUSH
12086: LD_INT 21
12088: PUSH
12089: LD_INT 2
12091: PUSH
12092: EMPTY
12093: LIST
12094: LIST
12095: PUSH
12096: EMPTY
12097: LIST
12098: LIST
12099: PUSH
12100: EMPTY
12101: LIST
12102: LIST
12103: PPUSH
12104: CALL_OW 69
12108: PUSH
12109: LD_EXP 74
12113: PUSH
12114: LD_EXP 75
12118: PUSH
12119: EMPTY
12120: LIST
12121: LIST
12122: DIFF
12123: PPUSH
12124: CALL_OW 1
12128: ST_TO_ADDR
// uc_side := 0 ;
12129: LD_ADDR_OWVAR 20
12133: PUSH
12134: LD_INT 0
12136: ST_TO_ADDR
// uc_nation := 0 ;
12137: LD_ADDR_OWVAR 21
12141: PUSH
12142: LD_INT 0
12144: ST_TO_ADDR
// for i = 1 to 5 do
12145: LD_ADDR_VAR 0 2
12149: PUSH
12150: DOUBLE
12151: LD_INT 1
12153: DEC
12154: ST_TO_ADDR
12155: LD_INT 5
12157: PUSH
12158: FOR_TO
12159: IFFALSE 12196
// begin InitHc ;
12161: CALL_OW 19
// hc_class := class_apeman ;
12165: LD_ADDR_OWVAR 28
12169: PUSH
12170: LD_INT 12
12172: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
12173: CALL_OW 44
12177: PPUSH
12178: LD_INT 299
12180: PPUSH
12181: LD_INT 229
12183: PPUSH
12184: LD_INT 10
12186: PPUSH
12187: LD_INT 0
12189: PPUSH
12190: CALL_OW 50
// end ;
12194: GO 12158
12196: POP
12197: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
12198: LD_EXP 74
12202: PPUSH
12203: LD_INT 259
12205: PPUSH
12206: LD_INT 235
12208: PPUSH
12209: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
12213: LD_EXP 74
12217: PPUSH
12218: LD_INT 262
12220: PPUSH
12221: LD_INT 235
12223: PPUSH
12224: CALL_OW 178
// if Simms then
12228: LD_EXP 75
12232: IFFALSE 12263
// begin ComMoveXY ( Simms , 262 , 235 ) ;
12234: LD_EXP 75
12238: PPUSH
12239: LD_INT 262
12241: PPUSH
12242: LD_INT 235
12244: PPUSH
12245: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
12249: LD_EXP 75
12253: PPUSH
12254: LD_EXP 74
12258: PPUSH
12259: CALL_OW 179
// end ; end ;
12263: LD_VAR 0 1
12267: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
12268: LD_EXP 31
12272: PUSH
12273: LD_EXP 23
12277: NOT
12278: AND
12279: IFFALSE 12455
12281: GO 12283
12283: DISABLE
12284: LD_INT 0
12286: PPUSH
12287: PPUSH
12288: PPUSH
// begin enable ;
12289: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12290: LD_ADDR_VAR 0 2
12294: PUSH
12295: LD_INT 81
12297: PUSH
12298: LD_INT 7
12300: PUSH
12301: EMPTY
12302: LIST
12303: LIST
12304: PUSH
12305: LD_INT 2
12307: PUSH
12308: LD_INT 32
12310: PUSH
12311: LD_INT 3
12313: PUSH
12314: EMPTY
12315: LIST
12316: LIST
12317: PUSH
12318: LD_INT 30
12320: PUSH
12321: LD_INT 30
12323: PUSH
12324: EMPTY
12325: LIST
12326: LIST
12327: PUSH
12328: LD_INT 30
12330: PUSH
12331: LD_INT 28
12333: PUSH
12334: EMPTY
12335: LIST
12336: LIST
12337: PUSH
12338: LD_INT 34
12340: PUSH
12341: LD_INT 49
12343: PUSH
12344: EMPTY
12345: LIST
12346: LIST
12347: PUSH
12348: LD_INT 34
12350: PUSH
12351: LD_INT 10
12353: PUSH
12354: EMPTY
12355: LIST
12356: LIST
12357: PUSH
12358: LD_INT 34
12360: PUSH
12361: LD_INT 8
12363: PUSH
12364: EMPTY
12365: LIST
12366: LIST
12367: PUSH
12368: EMPTY
12369: LIST
12370: LIST
12371: LIST
12372: LIST
12373: LIST
12374: LIST
12375: LIST
12376: PUSH
12377: EMPTY
12378: LIST
12379: LIST
12380: PPUSH
12381: CALL_OW 69
12385: ST_TO_ADDR
// if not tmp then
12386: LD_VAR 0 2
12390: NOT
12391: IFFALSE 12395
// exit ;
12393: GO 12455
// target := tmp [ rand ( 1 , tmp ) ] ;
12395: LD_ADDR_VAR 0 3
12399: PUSH
12400: LD_VAR 0 2
12404: PUSH
12405: LD_INT 1
12407: PPUSH
12408: LD_VAR 0 2
12412: PPUSH
12413: CALL_OW 12
12417: ARRAY
12418: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12419: LD_VAR 0 3
12423: PPUSH
12424: CALL_OW 255
12428: PUSH
12429: LD_INT 1
12431: EQUAL
12432: IFFALSE 12443
// CenterNowOnUnits ( target ) ;
12434: LD_VAR 0 3
12438: PPUSH
12439: CALL_OW 87
// SetLives ( target , 0 ) ;
12443: LD_VAR 0 3
12447: PPUSH
12448: LD_INT 0
12450: PPUSH
12451: CALL_OW 234
// end ;
12455: PPOPN 3
12457: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12458: LD_EXP 23
12462: NOT
12463: PUSH
12464: LD_EXP 31
12468: AND
12469: IFFALSE 12995
12471: GO 12473
12473: DISABLE
12474: LD_INT 0
12476: PPUSH
12477: PPUSH
12478: PPUSH
// begin uc_side := 7 ;
12479: LD_ADDR_OWVAR 20
12483: PUSH
12484: LD_INT 7
12486: ST_TO_ADDR
// uc_nation := 1 ;
12487: LD_ADDR_OWVAR 21
12491: PUSH
12492: LD_INT 1
12494: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12495: LD_ADDR_VAR 0 3
12499: PUSH
12500: LD_INT 125
12502: PUSH
12503: LD_INT 163
12505: PUSH
12506: EMPTY
12507: LIST
12508: LIST
12509: PUSH
12510: LD_INT 185
12512: PUSH
12513: LD_INT 168
12515: PUSH
12516: EMPTY
12517: LIST
12518: LIST
12519: PUSH
12520: LD_INT 111
12522: PUSH
12523: LD_INT 97
12525: PUSH
12526: EMPTY
12527: LIST
12528: LIST
12529: PUSH
12530: EMPTY
12531: LIST
12532: LIST
12533: LIST
12534: PPUSH
12535: CALL 102727 0 1
12539: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12540: LD_ADDR_EXP 91
12544: PUSH
12545: EMPTY
12546: ST_TO_ADDR
// for i = 1 to Difficulty do
12547: LD_ADDR_VAR 0 1
12551: PUSH
12552: DOUBLE
12553: LD_INT 1
12555: DEC
12556: ST_TO_ADDR
12557: LD_OWVAR 67
12561: PUSH
12562: FOR_TO
12563: IFFALSE 12721
// begin InitHc ;
12565: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12569: LD_INT 0
12571: PPUSH
12572: LD_INT 8
12574: PPUSH
12575: CALL_OW 381
// un := CreateHuman ;
12579: LD_ADDR_VAR 0 2
12583: PUSH
12584: CALL_OW 44
12588: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12589: LD_VAR 0 2
12593: PPUSH
12594: LD_INT 258
12596: PPUSH
12597: LD_INT 267
12599: PPUSH
12600: LD_INT 4
12602: PPUSH
12603: LD_INT 0
12605: PPUSH
12606: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12610: LD_ADDR_EXP 91
12614: PUSH
12615: LD_EXP 91
12619: PUSH
12620: LD_VAR 0 2
12624: UNION
12625: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12626: LD_VAR 0 2
12630: PPUSH
12631: LD_VAR 0 3
12635: PUSH
12636: LD_VAR 0 1
12640: ARRAY
12641: PUSH
12642: LD_INT 1
12644: ARRAY
12645: PPUSH
12646: LD_VAR 0 3
12650: PUSH
12651: LD_VAR 0 1
12655: ARRAY
12656: PUSH
12657: LD_INT 2
12659: ARRAY
12660: PPUSH
12661: LD_INT 4
12663: PPUSH
12664: LD_INT 1
12666: PPUSH
12667: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12671: LD_VAR 0 2
12675: PPUSH
12676: LD_VAR 0 3
12680: PUSH
12681: LD_VAR 0 1
12685: ARRAY
12686: PUSH
12687: LD_INT 1
12689: ARRAY
12690: PPUSH
12691: LD_VAR 0 3
12695: PUSH
12696: LD_VAR 0 1
12700: ARRAY
12701: PUSH
12702: LD_INT 2
12704: ARRAY
12705: PPUSH
12706: CALL_OW 171
// AddComInvisible ( un ) ;
12710: LD_VAR 0 2
12714: PPUSH
12715: CALL_OW 212
// end ;
12719: GO 12562
12721: POP
12722: POP
// repeat wait ( 0 0$20 ) ;
12723: LD_INT 700
12725: PPUSH
12726: CALL_OW 67
// for i in allianceSpecialForce do
12730: LD_ADDR_VAR 0 1
12734: PUSH
12735: LD_EXP 91
12739: PUSH
12740: FOR_IN
12741: IFFALSE 12980
// begin if IsInvisible ( i ) then
12743: LD_VAR 0 1
12747: PPUSH
12748: CALL_OW 571
12752: IFFALSE 12949
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 , 40 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12754: LD_ADDR_VAR 0 3
12758: PUSH
12759: LD_INT 22
12761: PUSH
12762: LD_INT 1
12764: PUSH
12765: EMPTY
12766: LIST
12767: LIST
12768: PUSH
12769: LD_INT 50
12771: PUSH
12772: EMPTY
12773: LIST
12774: PUSH
12775: LD_INT 56
12777: PUSH
12778: EMPTY
12779: LIST
12780: PUSH
12781: LD_INT 91
12783: PUSH
12784: LD_VAR 0 1
12788: PUSH
12789: LD_INT 25
12791: PUSH
12792: LD_INT 30
12794: PUSH
12795: LD_INT 35
12797: PUSH
12798: LD_INT 40
12800: PUSH
12801: EMPTY
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: PUSH
12807: LD_OWVAR 67
12811: ARRAY
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: LIST
12817: PUSH
12818: LD_INT 2
12820: PUSH
12821: LD_INT 25
12823: PUSH
12824: LD_INT 1
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PUSH
12831: LD_INT 25
12833: PUSH
12834: LD_INT 2
12836: PUSH
12837: EMPTY
12838: LIST
12839: LIST
12840: PUSH
12841: LD_INT 25
12843: PUSH
12844: LD_INT 3
12846: PUSH
12847: EMPTY
12848: LIST
12849: LIST
12850: PUSH
12851: LD_INT 25
12853: PUSH
12854: LD_INT 4
12856: PUSH
12857: EMPTY
12858: LIST
12859: LIST
12860: PUSH
12861: LD_INT 25
12863: PUSH
12864: LD_INT 5
12866: PUSH
12867: EMPTY
12868: LIST
12869: LIST
12870: PUSH
12871: LD_INT 25
12873: PUSH
12874: LD_INT 8
12876: PUSH
12877: EMPTY
12878: LIST
12879: LIST
12880: PUSH
12881: EMPTY
12882: LIST
12883: LIST
12884: LIST
12885: LIST
12886: LIST
12887: LIST
12888: LIST
12889: PUSH
12890: EMPTY
12891: LIST
12892: LIST
12893: LIST
12894: LIST
12895: LIST
12896: PPUSH
12897: CALL_OW 69
12901: ST_TO_ADDR
// if not tmp then
12902: LD_VAR 0 3
12906: NOT
12907: IFFALSE 12911
// continue ;
12909: GO 12740
// if Prob ( 30 * Difficulty ) then
12911: LD_INT 30
12913: PUSH
12914: LD_OWVAR 67
12918: MUL
12919: PPUSH
12920: CALL_OW 13
12924: IFFALSE 12949
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12926: LD_VAR 0 3
12930: PUSH
12931: LD_INT 1
12933: PPUSH
12934: LD_VAR 0 3
12938: PPUSH
12939: CALL_OW 12
12943: ARRAY
12944: PPUSH
12945: CALL 31278 0 1
// end ; if IsDead ( i ) then
12949: LD_VAR 0 1
12953: PPUSH
12954: CALL_OW 301
12958: IFFALSE 12978
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12960: LD_ADDR_EXP 91
12964: PUSH
12965: LD_EXP 91
12969: PUSH
12970: LD_VAR 0 1
12974: DIFF
12975: ST_TO_ADDR
// continue ;
12976: GO 12740
// end ; end ;
12978: GO 12740
12980: POP
12981: POP
// until allianceDestroyed or not allianceSpecialForce ;
12982: LD_EXP 23
12986: PUSH
12987: LD_EXP 91
12991: NOT
12992: OR
12993: IFFALSE 12723
// end ;
12995: PPOPN 3
12997: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive do var i , tmp , target , teleport ;
12998: LD_EXP 23
13002: NOT
13003: PUSH
13004: LD_EXP 31
13008: AND
13009: IFFALSE 13980
13011: GO 13013
13013: DISABLE
13014: LD_INT 0
13016: PPUSH
13017: PPUSH
13018: PPUSH
13019: PPUSH
// begin enable ;
13020: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
13021: LD_INT 22
13023: PUSH
13024: LD_INT 7
13026: PUSH
13027: EMPTY
13028: LIST
13029: LIST
13030: PUSH
13031: LD_INT 30
13033: PUSH
13034: LD_INT 3
13036: PUSH
13037: EMPTY
13038: LIST
13039: LIST
13040: PUSH
13041: EMPTY
13042: LIST
13043: LIST
13044: PPUSH
13045: CALL_OW 69
13049: NOT
13050: IFFALSE 13054
// exit ;
13052: GO 13980
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
13054: LD_ADDR_VAR 0 4
13058: PUSH
13059: LD_INT 22
13061: PUSH
13062: LD_INT 7
13064: PUSH
13065: EMPTY
13066: LIST
13067: LIST
13068: PUSH
13069: LD_INT 30
13071: PUSH
13072: LD_INT 34
13074: PUSH
13075: EMPTY
13076: LIST
13077: LIST
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PPUSH
13083: CALL_OW 69
13087: ST_TO_ADDR
// if Prob ( 40 ) then
13088: LD_INT 40
13090: PPUSH
13091: CALL_OW 13
13095: IFFALSE 13222
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
13097: LD_INT 1
13099: PPUSH
13100: LD_INT 5
13102: PUSH
13103: LD_INT 3
13105: PUSH
13106: LD_INT 2
13108: PUSH
13109: LD_INT 6
13111: PUSH
13112: EMPTY
13113: LIST
13114: LIST
13115: LIST
13116: LIST
13117: PUSH
13118: LD_INT 5
13120: PUSH
13121: LD_INT 3
13123: PUSH
13124: LD_INT 2
13126: PUSH
13127: LD_INT 6
13129: PUSH
13130: EMPTY
13131: LIST
13132: LIST
13133: LIST
13134: LIST
13135: PUSH
13136: LD_INT 5
13138: PUSH
13139: LD_INT 3
13141: PUSH
13142: LD_INT 2
13144: PUSH
13145: LD_INT 6
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: LIST
13152: LIST
13153: PUSH
13154: LD_INT 24
13156: PUSH
13157: LD_INT 3
13159: PUSH
13160: LD_INT 3
13162: PUSH
13163: LD_INT 45
13165: PUSH
13166: EMPTY
13167: LIST
13168: LIST
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 24
13174: PUSH
13175: LD_INT 3
13177: PUSH
13178: LD_INT 3
13180: PUSH
13181: LD_INT 47
13183: PUSH
13184: EMPTY
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: PUSH
13190: LD_INT 24
13192: PUSH
13193: LD_INT 3
13195: PUSH
13196: LD_INT 3
13198: PUSH
13199: LD_INT 45
13201: PUSH
13202: EMPTY
13203: LIST
13204: LIST
13205: LIST
13206: LIST
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: LIST
13214: LIST
13215: PPUSH
13216: CALL 59479 0 2
// end else
13220: GO 13345
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
13222: LD_INT 1
13224: PPUSH
13225: LD_INT 24
13227: PUSH
13228: LD_INT 3
13230: PUSH
13231: LD_INT 3
13233: PUSH
13234: LD_INT 47
13236: PUSH
13237: EMPTY
13238: LIST
13239: LIST
13240: LIST
13241: LIST
13242: PUSH
13243: LD_INT 24
13245: PUSH
13246: LD_INT 3
13248: PUSH
13249: LD_INT 3
13251: PUSH
13252: LD_INT 47
13254: PUSH
13255: EMPTY
13256: LIST
13257: LIST
13258: LIST
13259: LIST
13260: PUSH
13261: LD_INT 5
13263: PUSH
13264: LD_INT 3
13266: PUSH
13267: LD_INT 2
13269: PUSH
13270: LD_INT 9
13272: PUSH
13273: EMPTY
13274: LIST
13275: LIST
13276: LIST
13277: LIST
13278: PUSH
13279: LD_INT 5
13281: PUSH
13282: LD_INT 3
13284: PUSH
13285: LD_INT 2
13287: PUSH
13288: LD_INT 9
13290: PUSH
13291: EMPTY
13292: LIST
13293: LIST
13294: LIST
13295: LIST
13296: PUSH
13297: LD_INT 24
13299: PUSH
13300: LD_INT 1
13302: PUSH
13303: LD_INT 3
13305: PUSH
13306: LD_INT 45
13308: PUSH
13309: EMPTY
13310: LIST
13311: LIST
13312: LIST
13313: LIST
13314: PUSH
13315: LD_INT 24
13317: PUSH
13318: LD_INT 1
13320: PUSH
13321: LD_INT 3
13323: PUSH
13324: LD_INT 45
13326: PUSH
13327: EMPTY
13328: LIST
13329: LIST
13330: LIST
13331: LIST
13332: PUSH
13333: EMPTY
13334: LIST
13335: LIST
13336: LIST
13337: LIST
13338: LIST
13339: LIST
13340: PPUSH
13341: CALL 59479 0 2
// end ; if Difficulty > 1 then
13345: LD_OWVAR 67
13349: PUSH
13350: LD_INT 1
13352: GREATER
13353: IFFALSE 13383
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13355: LD_INT 1
13357: PPUSH
13358: LD_INT 24
13360: PUSH
13361: LD_INT 3
13363: PUSH
13364: LD_INT 3
13366: PUSH
13367: LD_INT 47
13369: PUSH
13370: EMPTY
13371: LIST
13372: LIST
13373: LIST
13374: LIST
13375: PUSH
13376: EMPTY
13377: LIST
13378: PPUSH
13379: CALL 59479 0 2
// repeat wait ( 0 0$1 ) ;
13383: LD_INT 35
13385: PPUSH
13386: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 , 7 ] [ Difficulty ] ;
13390: LD_INT 1
13392: PPUSH
13393: LD_INT 1
13395: PPUSH
13396: CALL 60897 0 2
13400: PUSH
13401: LD_INT 6
13403: PUSH
13404: LD_INT 7
13406: PUSH
13407: LD_INT 7
13409: PUSH
13410: LD_INT 7
13412: PUSH
13413: EMPTY
13414: LIST
13415: LIST
13416: LIST
13417: LIST
13418: PUSH
13419: LD_OWVAR 67
13423: ARRAY
13424: GREATEREQUAL
13425: IFFALSE 13383
// wait ( 0 0$40 ) ;
13427: LD_INT 1400
13429: PPUSH
13430: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13434: LD_ADDR_VAR 0 2
13438: PUSH
13439: LD_INT 1
13441: PPUSH
13442: LD_INT 1
13444: PPUSH
13445: CALL 60897 0 2
13449: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13450: LD_ADDR_EXP 135
13454: PUSH
13455: LD_EXP 135
13459: PPUSH
13460: LD_INT 1
13462: PPUSH
13463: LD_EXP 135
13467: PUSH
13468: LD_INT 1
13470: ARRAY
13471: PUSH
13472: LD_VAR 0 2
13476: DIFF
13477: PPUSH
13478: CALL_OW 1
13482: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13483: LD_ADDR_VAR 0 3
13487: PUSH
13488: LD_INT 0
13490: PPUSH
13491: LD_INT 1
13493: PPUSH
13494: CALL_OW 12
13498: ST_TO_ADDR
// if target then
13499: LD_VAR 0 3
13503: IFFALSE 13669
// begin for i in tmp do
13505: LD_ADDR_VAR 0 1
13509: PUSH
13510: LD_VAR 0 2
13514: PUSH
13515: FOR_IN
13516: IFFALSE 13541
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13518: LD_VAR 0 1
13522: PPUSH
13523: LD_INT 179
13525: PPUSH
13526: LD_INT 209
13528: PPUSH
13529: LD_INT 8
13531: PPUSH
13532: LD_INT 1
13534: PPUSH
13535: CALL_OW 483
13539: GO 13515
13541: POP
13542: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13543: LD_ADDR_VAR 0 2
13547: PUSH
13548: LD_VAR 0 2
13552: PPUSH
13553: LD_INT 24
13555: PUSH
13556: LD_INT 250
13558: PUSH
13559: EMPTY
13560: LIST
13561: LIST
13562: PPUSH
13563: CALL_OW 72
13567: ST_TO_ADDR
// for i in tmp do
13568: LD_ADDR_VAR 0 1
13572: PUSH
13573: LD_VAR 0 2
13577: PUSH
13578: FOR_IN
13579: IFFALSE 13619
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13581: LD_VAR 0 1
13585: PPUSH
13586: LD_INT 179
13588: PPUSH
13589: LD_INT 209
13591: PPUSH
13592: CALL_OW 297
13596: PUSH
13597: LD_INT 9
13599: GREATER
13600: IFFALSE 13617
// ComMoveXY ( i , 179 , 209 ) ;
13602: LD_VAR 0 1
13606: PPUSH
13607: LD_INT 179
13609: PPUSH
13610: LD_INT 209
13612: PPUSH
13613: CALL_OW 111
13617: GO 13578
13619: POP
13620: POP
// wait ( 0 0$1 ) ;
13621: LD_INT 35
13623: PPUSH
13624: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13628: LD_VAR 0 2
13632: PPUSH
13633: LD_INT 92
13635: PUSH
13636: LD_INT 179
13638: PUSH
13639: LD_INT 209
13641: PUSH
13642: LD_INT 9
13644: PUSH
13645: EMPTY
13646: LIST
13647: LIST
13648: LIST
13649: LIST
13650: PPUSH
13651: CALL_OW 72
13655: PUSH
13656: LD_VAR 0 2
13660: PUSH
13661: LD_INT 1
13663: MINUS
13664: GREATEREQUAL
13665: IFFALSE 13543
// end else
13667: GO 13831
// begin for i in tmp do
13669: LD_ADDR_VAR 0 1
13673: PUSH
13674: LD_VAR 0 2
13678: PUSH
13679: FOR_IN
13680: IFFALSE 13705
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13682: LD_VAR 0 1
13686: PPUSH
13687: LD_INT 285
13689: PPUSH
13690: LD_INT 163
13692: PPUSH
13693: LD_INT 8
13695: PPUSH
13696: LD_INT 1
13698: PPUSH
13699: CALL_OW 483
13703: GO 13679
13705: POP
13706: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13707: LD_ADDR_VAR 0 2
13711: PUSH
13712: LD_VAR 0 2
13716: PPUSH
13717: LD_INT 24
13719: PUSH
13720: LD_INT 250
13722: PUSH
13723: EMPTY
13724: LIST
13725: LIST
13726: PPUSH
13727: CALL_OW 72
13731: ST_TO_ADDR
// for i in tmp do
13732: LD_ADDR_VAR 0 1
13736: PUSH
13737: LD_VAR 0 2
13741: PUSH
13742: FOR_IN
13743: IFFALSE 13783
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13745: LD_VAR 0 1
13749: PPUSH
13750: LD_INT 285
13752: PPUSH
13753: LD_INT 163
13755: PPUSH
13756: CALL_OW 297
13760: PUSH
13761: LD_INT 9
13763: GREATER
13764: IFFALSE 13781
// ComMoveXY ( i , 285 , 163 ) ;
13766: LD_VAR 0 1
13770: PPUSH
13771: LD_INT 285
13773: PPUSH
13774: LD_INT 163
13776: PPUSH
13777: CALL_OW 111
13781: GO 13742
13783: POP
13784: POP
// wait ( 0 0$1 ) ;
13785: LD_INT 35
13787: PPUSH
13788: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13792: LD_VAR 0 2
13796: PPUSH
13797: LD_INT 92
13799: PUSH
13800: LD_INT 285
13802: PUSH
13803: LD_INT 163
13805: PUSH
13806: LD_INT 9
13808: PUSH
13809: EMPTY
13810: LIST
13811: LIST
13812: LIST
13813: LIST
13814: PPUSH
13815: CALL_OW 72
13819: PUSH
13820: LD_VAR 0 2
13824: PUSH
13825: LD_INT 1
13827: MINUS
13828: GREATEREQUAL
13829: IFFALSE 13707
// end ; repeat wait ( 0 0$1 ) ;
13831: LD_INT 35
13833: PPUSH
13834: CALL_OW 67
// for i in tmp do
13838: LD_ADDR_VAR 0 1
13842: PUSH
13843: LD_VAR 0 2
13847: PUSH
13848: FOR_IN
13849: IFFALSE 13971
// if GetLives ( i ) > 251 then
13851: LD_VAR 0 1
13855: PPUSH
13856: CALL_OW 256
13860: PUSH
13861: LD_INT 251
13863: GREATER
13864: IFFALSE 13953
// begin if GetWeapon ( i ) = ru_time_lapser then
13866: LD_VAR 0 1
13870: PPUSH
13871: CALL_OW 264
13875: PUSH
13876: LD_INT 49
13878: EQUAL
13879: IFFALSE 13917
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13881: LD_VAR 0 1
13885: PPUSH
13886: LD_INT 81
13888: PUSH
13889: LD_INT 7
13891: PUSH
13892: EMPTY
13893: LIST
13894: LIST
13895: PPUSH
13896: CALL_OW 69
13900: PPUSH
13901: LD_VAR 0 1
13905: PPUSH
13906: CALL_OW 74
13910: PPUSH
13911: CALL_OW 112
13915: GO 13951
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13917: LD_VAR 0 1
13921: PPUSH
13922: LD_INT 81
13924: PUSH
13925: LD_INT 7
13927: PUSH
13928: EMPTY
13929: LIST
13930: LIST
13931: PPUSH
13932: CALL_OW 69
13936: PPUSH
13937: LD_VAR 0 1
13941: PPUSH
13942: CALL_OW 74
13946: PPUSH
13947: CALL_OW 115
// end else
13951: GO 13969
// tmp := tmp diff i ;
13953: LD_ADDR_VAR 0 2
13957: PUSH
13958: LD_VAR 0 2
13962: PUSH
13963: LD_VAR 0 1
13967: DIFF
13968: ST_TO_ADDR
13969: GO 13848
13971: POP
13972: POP
// until not tmp ;
13973: LD_VAR 0 2
13977: NOT
13978: IFFALSE 13831
// end ; end_of_file
13980: PPOPN 4
13982: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13983: LD_INT 0
13985: PPUSH
13986: PPUSH
13987: PPUSH
13988: PPUSH
// missionStage := 13 ;
13989: LD_ADDR_EXP 15
13993: PUSH
13994: LD_INT 13
13996: ST_TO_ADDR
// uc_side := 2 ;
13997: LD_ADDR_OWVAR 20
14001: PUSH
14002: LD_INT 2
14004: ST_TO_ADDR
// uc_nation := 2 ;
14005: LD_ADDR_OWVAR 21
14009: PUSH
14010: LD_INT 2
14012: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
14013: LD_ADDR_EXP 92
14017: PUSH
14018: LD_STRING Omar
14020: PPUSH
14021: CALL_OW 25
14025: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
14026: LD_EXP 92
14030: PPUSH
14031: LD_INT 4
14033: PPUSH
14034: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
14038: LD_EXP 92
14042: PPUSH
14043: LD_INT 242
14045: PPUSH
14046: LD_INT 75
14048: PPUSH
14049: LD_INT 0
14051: PPUSH
14052: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
14056: LD_ADDR_EXP 93
14060: PUSH
14061: LD_STRING Heike
14063: PPUSH
14064: CALL_OW 25
14068: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
14069: LD_INT 14
14071: PPUSH
14072: LD_INT 3
14074: PPUSH
14075: LD_INT 1
14077: PPUSH
14078: LD_INT 27
14080: PPUSH
14081: LD_INT 100
14083: PPUSH
14084: CALL 70749 0 5
// veh := CreateVehicle ;
14088: LD_ADDR_VAR 0 3
14092: PUSH
14093: CALL_OW 45
14097: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
14098: LD_VAR 0 3
14102: PPUSH
14103: LD_INT 1
14105: PPUSH
14106: CALL_OW 242
// SetDir ( veh , 4 ) ;
14110: LD_VAR 0 3
14114: PPUSH
14115: LD_INT 4
14117: PPUSH
14118: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
14122: LD_VAR 0 3
14126: PPUSH
14127: LD_INT 241
14129: PPUSH
14130: LD_INT 72
14132: PPUSH
14133: LD_INT 0
14135: PPUSH
14136: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
14140: LD_EXP 93
14144: PPUSH
14145: LD_VAR 0 3
14149: PPUSH
14150: CALL_OW 52
// if KhatamStatus then
14154: LD_EXP 8
14158: IFFALSE 14209
// begin Khatam := NewCharacter ( Khatam ) ;
14160: LD_ADDR_EXP 94
14164: PUSH
14165: LD_STRING Khatam
14167: PPUSH
14168: CALL_OW 25
14172: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
14173: LD_EXP 94
14177: PPUSH
14178: LD_INT 245
14180: PPUSH
14181: LD_INT 78
14183: PPUSH
14184: LD_INT 3
14186: PPUSH
14187: LD_INT 0
14189: PPUSH
14190: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
14194: LD_EXP 94
14198: PPUSH
14199: LD_INT 4
14201: PPUSH
14202: LD_INT 10
14204: PPUSH
14205: CALL_OW 237
// end ; for i = 1 to Difficulty do
14209: LD_ADDR_VAR 0 2
14213: PUSH
14214: DOUBLE
14215: LD_INT 1
14217: DEC
14218: ST_TO_ADDR
14219: LD_OWVAR 67
14223: PUSH
14224: FOR_TO
14225: IFFALSE 14291
// begin PrepareScientist ( false , 7 + Difficulty ) ;
14227: LD_INT 0
14229: PPUSH
14230: LD_INT 7
14232: PUSH
14233: LD_OWVAR 67
14237: PLUS
14238: PPUSH
14239: CALL_OW 384
// un := CreateHuman ;
14243: LD_ADDR_VAR 0 4
14247: PUSH
14248: CALL_OW 44
14252: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
14253: LD_VAR 0 4
14257: PPUSH
14258: LD_INT 28
14260: PUSH
14261: LD_INT 29
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: PUSH
14268: LD_VAR 0 2
14272: PUSH
14273: LD_INT 2
14275: MOD
14276: PUSH
14277: LD_INT 1
14279: PLUS
14280: ARRAY
14281: PPUSH
14282: LD_INT 0
14284: PPUSH
14285: CALL_OW 49
// end ;
14289: GO 14224
14291: POP
14292: POP
// for i = 1 to 6 do
14293: LD_ADDR_VAR 0 2
14297: PUSH
14298: DOUBLE
14299: LD_INT 1
14301: DEC
14302: ST_TO_ADDR
14303: LD_INT 6
14305: PUSH
14306: FOR_TO
14307: IFFALSE 14352
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14309: LD_INT 0
14311: PPUSH
14312: LD_INT 7
14314: PUSH
14315: LD_OWVAR 67
14319: PLUS
14320: PPUSH
14321: CALL_OW 381
// un := CreateHuman ;
14325: LD_ADDR_VAR 0 4
14329: PUSH
14330: CALL_OW 44
14334: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14335: LD_VAR 0 4
14339: PPUSH
14340: LD_INT 28
14342: PPUSH
14343: LD_INT 0
14345: PPUSH
14346: CALL_OW 49
// end ;
14350: GO 14306
14352: POP
14353: POP
// for i = 1 to 3 do
14354: LD_ADDR_VAR 0 2
14358: PUSH
14359: DOUBLE
14360: LD_INT 1
14362: DEC
14363: ST_TO_ADDR
14364: LD_INT 3
14366: PUSH
14367: FOR_TO
14368: IFFALSE 14416
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14370: LD_INT 0
14372: PPUSH
14373: LD_INT 8
14375: PPUSH
14376: LD_INT 7
14378: PUSH
14379: LD_OWVAR 67
14383: PLUS
14384: PPUSH
14385: CALL_OW 380
// un := CreateHuman ;
14389: LD_ADDR_VAR 0 4
14393: PUSH
14394: CALL_OW 44
14398: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14399: LD_VAR 0 4
14403: PPUSH
14404: LD_INT 28
14406: PPUSH
14407: LD_INT 0
14409: PPUSH
14410: CALL_OW 49
// end ;
14414: GO 14367
14416: POP
14417: POP
// for i = 1 to 3 do
14418: LD_ADDR_VAR 0 2
14422: PUSH
14423: DOUBLE
14424: LD_INT 1
14426: DEC
14427: ST_TO_ADDR
14428: LD_INT 3
14430: PUSH
14431: FOR_TO
14432: IFFALSE 14522
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14434: LD_INT 14
14436: PPUSH
14437: LD_INT 2
14439: PPUSH
14440: LD_INT 1
14442: PPUSH
14443: LD_INT 28
14445: PPUSH
14446: LD_INT 80
14448: PPUSH
14449: CALL 70749 0 5
// veh := CreateVehicle ;
14453: LD_ADDR_VAR 0 3
14457: PUSH
14458: CALL_OW 45
14462: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14463: LD_VAR 0 3
14467: PPUSH
14468: LD_INT 3
14470: PPUSH
14471: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14475: LD_VAR 0 3
14479: PPUSH
14480: LD_INT 29
14482: PPUSH
14483: LD_INT 0
14485: PPUSH
14486: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14490: LD_INT 0
14492: PPUSH
14493: LD_INT 7
14495: PUSH
14496: LD_OWVAR 67
14500: PLUS
14501: PPUSH
14502: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14506: CALL_OW 44
14510: PPUSH
14511: LD_VAR 0 3
14515: PPUSH
14516: CALL_OW 52
// end ;
14520: GO 14431
14522: POP
14523: POP
// for i = 1 to 5 + Difficulty do
14524: LD_ADDR_VAR 0 2
14528: PUSH
14529: DOUBLE
14530: LD_INT 1
14532: DEC
14533: ST_TO_ADDR
14534: LD_INT 5
14536: PUSH
14537: LD_OWVAR 67
14541: PLUS
14542: PUSH
14543: FOR_TO
14544: IFFALSE 14671
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14546: LD_INT 14
14548: PPUSH
14549: LD_INT 1
14551: PPUSH
14552: LD_INT 3
14554: PPUSH
14555: CALL_OW 12
14559: PPUSH
14560: LD_INT 1
14562: PPUSH
14563: LD_INT 28
14565: PUSH
14566: LD_INT 26
14568: PUSH
14569: LD_INT 27
14571: PUSH
14572: LD_INT 25
14574: PUSH
14575: EMPTY
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: PUSH
14581: LD_VAR 0 2
14585: PUSH
14586: LD_INT 4
14588: MOD
14589: PUSH
14590: LD_INT 1
14592: PLUS
14593: ARRAY
14594: PPUSH
14595: LD_INT 80
14597: PPUSH
14598: CALL 70749 0 5
// veh := CreateVehicle ;
14602: LD_ADDR_VAR 0 3
14606: PUSH
14607: CALL_OW 45
14611: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14612: LD_VAR 0 3
14616: PPUSH
14617: LD_INT 4
14619: PPUSH
14620: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14624: LD_VAR 0 3
14628: PPUSH
14629: LD_INT 28
14631: PPUSH
14632: LD_INT 0
14634: PPUSH
14635: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14639: LD_INT 0
14641: PPUSH
14642: LD_INT 7
14644: PUSH
14645: LD_OWVAR 67
14649: PLUS
14650: PPUSH
14651: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14655: CALL_OW 44
14659: PPUSH
14660: LD_VAR 0 3
14664: PPUSH
14665: CALL_OW 52
// end ;
14669: GO 14543
14671: POP
14672: POP
// for i = 1 to 3 do
14673: LD_ADDR_VAR 0 2
14677: PUSH
14678: DOUBLE
14679: LD_INT 1
14681: DEC
14682: ST_TO_ADDR
14683: LD_INT 3
14685: PUSH
14686: FOR_TO
14687: IFFALSE 14747
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14689: LD_INT 14
14691: PPUSH
14692: LD_INT 3
14694: PPUSH
14695: LD_INT 5
14697: PPUSH
14698: LD_INT 29
14700: PPUSH
14701: LD_INT 80
14703: PPUSH
14704: CALL 70749 0 5
// veh := CreateVehicle ;
14708: LD_ADDR_VAR 0 3
14712: PUSH
14713: CALL_OW 45
14717: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14718: LD_VAR 0 3
14722: PPUSH
14723: LD_INT 4
14725: PPUSH
14726: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14730: LD_VAR 0 3
14734: PPUSH
14735: LD_INT 28
14737: PPUSH
14738: LD_INT 0
14740: PPUSH
14741: CALL_OW 49
// end ;
14745: GO 14686
14747: POP
14748: POP
// end ;
14749: LD_VAR 0 1
14753: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14754: LD_INT 22
14756: PUSH
14757: LD_INT 2
14759: PUSH
14760: EMPTY
14761: LIST
14762: LIST
14763: PPUSH
14764: CALL_OW 69
14768: IFFALSE 15068
14770: GO 14772
14772: DISABLE
14773: LD_INT 0
14775: PPUSH
14776: PPUSH
14777: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14778: LD_ADDR_VAR 0 3
14782: PUSH
14783: LD_INT 22
14785: PUSH
14786: LD_INT 2
14788: PUSH
14789: EMPTY
14790: LIST
14791: LIST
14792: PUSH
14793: LD_INT 25
14795: PUSH
14796: LD_INT 4
14798: PUSH
14799: EMPTY
14800: LIST
14801: LIST
14802: PUSH
14803: EMPTY
14804: LIST
14805: LIST
14806: PPUSH
14807: CALL_OW 69
14811: PUSH
14812: LD_EXP 94
14816: DIFF
14817: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14818: LD_ADDR_VAR 0 2
14822: PUSH
14823: LD_INT 22
14825: PUSH
14826: LD_INT 2
14828: PUSH
14829: EMPTY
14830: LIST
14831: LIST
14832: PPUSH
14833: CALL_OW 69
14837: PUSH
14838: LD_EXP 94
14842: PUSH
14843: LD_VAR 0 3
14847: UNION
14848: DIFF
14849: ST_TO_ADDR
// if Khatam then
14850: LD_EXP 94
14854: IFFALSE 14871
// ComMoveXY ( Khatam , 211 , 92 ) ;
14856: LD_EXP 94
14860: PPUSH
14861: LD_INT 211
14863: PPUSH
14864: LD_INT 92
14866: PPUSH
14867: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14871: LD_INT 197
14873: PPUSH
14874: LD_INT 80
14876: PPUSH
14877: LD_INT 2
14879: PPUSH
14880: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14884: LD_INT 213
14886: PPUSH
14887: LD_INT 90
14889: PPUSH
14890: LD_INT 2
14892: PPUSH
14893: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14897: LD_INT 215
14899: PPUSH
14900: LD_INT 129
14902: PPUSH
14903: LD_INT 2
14905: PPUSH
14906: CALL_OW 441
// if sci then
14910: LD_VAR 0 3
14914: IFFALSE 14935
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14916: LD_VAR 0 3
14920: PUSH
14921: LD_INT 1
14923: ARRAY
14924: PPUSH
14925: LD_INT 197
14927: PPUSH
14928: LD_INT 80
14930: PPUSH
14931: CALL_OW 158
// if sci > 1 then
14935: LD_VAR 0 3
14939: PUSH
14940: LD_INT 1
14942: GREATER
14943: IFFALSE 14964
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14945: LD_VAR 0 3
14949: PUSH
14950: LD_INT 2
14952: ARRAY
14953: PPUSH
14954: LD_INT 213
14956: PPUSH
14957: LD_INT 90
14959: PPUSH
14960: CALL_OW 158
// if sci > 2 then
14964: LD_VAR 0 3
14968: PUSH
14969: LD_INT 2
14971: GREATER
14972: IFFALSE 14993
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14974: LD_VAR 0 3
14978: PUSH
14979: LD_INT 3
14981: ARRAY
14982: PPUSH
14983: LD_INT 215
14985: PPUSH
14986: LD_INT 129
14988: PPUSH
14989: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14993: LD_INT 35
14995: PPUSH
14996: CALL_OW 67
// for i in tmp do
15000: LD_ADDR_VAR 0 1
15004: PUSH
15005: LD_VAR 0 2
15009: PUSH
15010: FOR_IN
15011: IFFALSE 15049
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
15013: LD_VAR 0 1
15017: PPUSH
15018: LD_INT 81
15020: PUSH
15021: LD_INT 2
15023: PUSH
15024: EMPTY
15025: LIST
15026: LIST
15027: PPUSH
15028: CALL_OW 69
15032: PPUSH
15033: LD_VAR 0 1
15037: PPUSH
15038: CALL_OW 74
15042: PPUSH
15043: CALL_OW 115
15047: GO 15010
15049: POP
15050: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
15051: LD_INT 22
15053: PUSH
15054: LD_INT 2
15056: PUSH
15057: EMPTY
15058: LIST
15059: LIST
15060: PPUSH
15061: CALL_OW 69
15065: NOT
15066: IFFALSE 14993
// end ; end_of_file
15068: PPOPN 3
15070: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
15071: LD_INT 0
15073: PPUSH
15074: PPUSH
15075: PPUSH
15076: PPUSH
15077: PPUSH
15078: PPUSH
15079: PPUSH
15080: PPUSH
15081: PPUSH
// Video ( true ) ;
15082: LD_INT 1
15084: PPUSH
15085: CALL 102594 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
15089: LD_ADDR_VAR 0 5
15093: PUSH
15094: LD_INT 7
15096: PPUSH
15097: LD_INT 0
15099: PPUSH
15100: CALL_OW 517
15104: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
15105: LD_ADDR_VAR 0 2
15109: PUSH
15110: DOUBLE
15111: LD_INT 1
15113: DEC
15114: ST_TO_ADDR
15115: LD_VAR 0 5
15119: PUSH
15120: LD_INT 1
15122: ARRAY
15123: PUSH
15124: FOR_TO
15125: IFFALSE 15170
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
15127: LD_VAR 0 5
15131: PUSH
15132: LD_INT 1
15134: ARRAY
15135: PUSH
15136: LD_VAR 0 2
15140: ARRAY
15141: PPUSH
15142: LD_VAR 0 5
15146: PUSH
15147: LD_INT 2
15149: ARRAY
15150: PUSH
15151: LD_VAR 0 2
15155: ARRAY
15156: PPUSH
15157: LD_INT 1
15159: PPUSH
15160: LD_INT 15
15162: NEG
15163: PPUSH
15164: CALL 102508 0 4
15168: GO 15124
15170: POP
15171: POP
// CenterNowOnUnits ( Powell ) ;
15172: LD_EXP 58
15176: PPUSH
15177: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
15181: LD_ADDR_VAR 0 5
15185: PUSH
15186: LD_EXP 56
15190: PUSH
15191: EMPTY
15192: LIST
15193: ST_TO_ADDR
// if GirlNewVeh then
15194: LD_EXP 57
15198: IFFALSE 15216
// tmp := tmp ^ GirlNewVeh ;
15200: LD_ADDR_VAR 0 5
15204: PUSH
15205: LD_VAR 0 5
15209: PUSH
15210: LD_EXP 57
15214: ADD
15215: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
15216: LD_VAR 0 5
15220: PPUSH
15221: LD_INT 60
15223: PPUSH
15224: LD_INT 109
15226: PPUSH
15227: CALL_OW 111
// if KappaStatus then
15231: LD_EXP 2
15235: IFFALSE 15287
// begin Say ( JMM , D1nT-JMM-1 ) ;
15237: LD_EXP 39
15241: PPUSH
15242: LD_STRING D1nT-JMM-1
15244: PPUSH
15245: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15249: LD_EXP 58
15253: PPUSH
15254: LD_STRING D1T-Pow-1
15256: PPUSH
15257: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
15261: LD_EXP 39
15265: PPUSH
15266: LD_STRING D1T-JMM-2
15268: PPUSH
15269: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15273: LD_EXP 58
15277: PPUSH
15278: LD_STRING D1T-Pow-2
15280: PPUSH
15281: CALL_OW 88
// end else
15285: GO 15493
// if JMMGirlStatus then
15287: LD_EXP 6
15291: IFFALSE 15436
// begin Say ( JMM , D1T-JMM-1 ) ;
15293: LD_EXP 39
15297: PPUSH
15298: LD_STRING D1T-JMM-1
15300: PPUSH
15301: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15305: LD_EXP 58
15309: PPUSH
15310: LD_STRING D1T-Pow-1
15312: PPUSH
15313: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15317: LD_EXP 39
15321: PPUSH
15322: LD_STRING D1T-JMM-3
15324: PPUSH
15325: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15329: LD_EXP 58
15333: PPUSH
15334: LD_STRING D1T-Pow-3
15336: PPUSH
15337: CALL_OW 88
// if JMMGirl then
15341: LD_EXP 7
15345: IFFALSE 15434
// begin case JMMGirl of 1 :
15347: LD_EXP 7
15351: PUSH
15352: LD_INT 1
15354: DOUBLE
15355: EQUAL
15356: IFTRUE 15360
15358: GO 15375
15360: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15361: LD_EXP 40
15365: PPUSH
15366: LD_STRING D1T-Joan-3
15368: PPUSH
15369: CALL_OW 88
15373: GO 15422
15375: LD_INT 2
15377: DOUBLE
15378: EQUAL
15379: IFTRUE 15383
15381: GO 15398
15383: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15384: LD_EXP 42
15388: PPUSH
15389: LD_STRING D1T-Lisa-3
15391: PPUSH
15392: CALL_OW 88
15396: GO 15422
15398: LD_INT 3
15400: DOUBLE
15401: EQUAL
15402: IFTRUE 15406
15404: GO 15421
15406: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15407: LD_EXP 54
15411: PPUSH
15412: LD_STRING D1T-Con-3
15414: PPUSH
15415: CALL_OW 88
15419: GO 15422
15421: POP
// Say ( Powell , D1T-Pow-4 ) ;
15422: LD_EXP 58
15426: PPUSH
15427: LD_STRING D1T-Pow-4
15429: PPUSH
15430: CALL_OW 88
// end ; end else
15434: GO 15493
// if not FastEnd then
15436: LD_EXP 11
15440: NOT
15441: IFFALSE 15469
// begin Say ( JMM , D1T-JMM-4 ) ;
15443: LD_EXP 39
15447: PPUSH
15448: LD_STRING D1T-JMM-4
15450: PPUSH
15451: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15455: LD_EXP 58
15459: PPUSH
15460: LD_STRING D1T-Pow-5
15462: PPUSH
15463: CALL_OW 88
// end else
15467: GO 15493
// begin Say ( JMM , D1nT-JMM-1 ) ;
15469: LD_EXP 39
15473: PPUSH
15474: LD_STRING D1nT-JMM-1
15476: PPUSH
15477: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15481: LD_EXP 58
15485: PPUSH
15486: LD_STRING D1nT-Pow-1
15488: PPUSH
15489: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15493: LD_INT 35
15495: PPUSH
15496: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15500: LD_EXP 56
15504: PPUSH
15505: CALL_OW 314
15509: NOT
15510: IFFALSE 15493
// ComExitVehicle ( JMM ) ;
15512: LD_EXP 39
15516: PPUSH
15517: CALL_OW 121
// wait ( 3 ) ;
15521: LD_INT 3
15523: PPUSH
15524: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15528: LD_EXP 39
15532: PPUSH
15533: LD_INT 60
15535: PPUSH
15536: LD_INT 94
15538: PPUSH
15539: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15543: LD_EXP 39
15547: PPUSH
15548: LD_EXP 58
15552: PPUSH
15553: CALL_OW 179
// if Joan then
15557: LD_EXP 40
15561: IFFALSE 15615
// begin ComExitVehicle ( Joan ) ;
15563: LD_EXP 40
15567: PPUSH
15568: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15572: LD_EXP 40
15576: PPUSH
15577: LD_INT 35
15579: PPUSH
15580: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15584: LD_EXP 40
15588: PPUSH
15589: LD_INT 65
15591: PPUSH
15592: LD_INT 104
15594: PPUSH
15595: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15599: LD_EXP 40
15603: PPUSH
15604: LD_EXP 39
15608: PPUSH
15609: CALL_OW 179
// end else
15613: GO 15749
// if Lisa and JMMGirl = 2 then
15615: LD_EXP 42
15619: PUSH
15620: LD_EXP 7
15624: PUSH
15625: LD_INT 2
15627: EQUAL
15628: AND
15629: IFFALSE 15683
// begin ComExitVehicle ( Lisa ) ;
15631: LD_EXP 42
15635: PPUSH
15636: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15640: LD_EXP 42
15644: PPUSH
15645: LD_INT 35
15647: PPUSH
15648: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15652: LD_EXP 42
15656: PPUSH
15657: LD_INT 65
15659: PPUSH
15660: LD_INT 104
15662: PPUSH
15663: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15667: LD_EXP 42
15671: PPUSH
15672: LD_EXP 39
15676: PPUSH
15677: CALL_OW 179
// end else
15681: GO 15749
// if Connie and JMMGirl = 3 then
15683: LD_EXP 54
15687: PUSH
15688: LD_EXP 7
15692: PUSH
15693: LD_INT 3
15695: EQUAL
15696: AND
15697: IFFALSE 15749
// begin ComExitVehicle ( Connie ) ;
15699: LD_EXP 54
15703: PPUSH
15704: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15708: LD_EXP 54
15712: PPUSH
15713: LD_INT 35
15715: PPUSH
15716: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15720: LD_EXP 54
15724: PPUSH
15725: LD_INT 65
15727: PPUSH
15728: LD_INT 104
15730: PPUSH
15731: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15735: LD_EXP 54
15739: PPUSH
15740: LD_EXP 39
15744: PPUSH
15745: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15749: LD_INT 35
15751: PPUSH
15752: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15756: LD_EXP 39
15760: PPUSH
15761: LD_EXP 58
15765: PPUSH
15766: CALL_OW 296
15770: PUSH
15771: LD_INT 6
15773: LESS
15774: IFFALSE 15749
// wait ( 0 0$0.5 ) ;
15776: LD_INT 18
15778: PPUSH
15779: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15783: LD_EXP 39
15787: PPUSH
15788: LD_STRING D1-JMM-1
15790: PPUSH
15791: CALL_OW 88
// async ;
15795: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15796: LD_EXP 58
15800: PPUSH
15801: LD_STRING D1-Pow-1
15803: PPUSH
15804: CALL_OW 88
// if not dialogue_skipped then
15808: LD_OWVAR 59
15812: NOT
15813: IFFALSE 15822
// wait ( 0 0$2 ) ;
15815: LD_INT 70
15817: PPUSH
15818: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15822: LD_INT 170
15824: PPUSH
15825: LD_INT 99
15827: PPUSH
15828: LD_INT 1
15830: PPUSH
15831: LD_INT 6
15833: NEG
15834: PPUSH
15835: CALL 102508 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15839: LD_INT 174
15841: PPUSH
15842: LD_INT 115
15844: PPUSH
15845: LD_INT 1
15847: PPUSH
15848: LD_INT 6
15850: NEG
15851: PPUSH
15852: CALL 102508 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15856: LD_INT 169
15858: PPUSH
15859: LD_INT 71
15861: PPUSH
15862: LD_INT 1
15864: PPUSH
15865: LD_INT 6
15867: NEG
15868: PPUSH
15869: CALL 102508 0 4
// if not dialogue_skipped then
15873: LD_OWVAR 59
15877: NOT
15878: IFFALSE 15897
// begin CenterOnXY ( 170 , 99 ) ;
15880: LD_INT 170
15882: PPUSH
15883: LD_INT 99
15885: PPUSH
15886: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15890: LD_INT 80
15892: PPUSH
15893: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15897: LD_INT 75
15899: PPUSH
15900: LD_INT 53
15902: PPUSH
15903: LD_INT 1
15905: PPUSH
15906: LD_INT 9
15908: NEG
15909: PPUSH
15910: CALL 102508 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15914: LD_INT 54
15916: PPUSH
15917: LD_INT 42
15919: PPUSH
15920: LD_INT 1
15922: PPUSH
15923: LD_INT 9
15925: NEG
15926: PPUSH
15927: CALL 102508 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15931: LD_INT 62
15933: PPUSH
15934: LD_INT 51
15936: PPUSH
15937: LD_INT 1
15939: PPUSH
15940: LD_INT 9
15942: NEG
15943: PPUSH
15944: CALL 102508 0 4
// if not dialogue_skipped then
15948: LD_OWVAR 59
15952: NOT
15953: IFFALSE 15972
// begin CenterOnXY ( 75 , 53 ) ;
15955: LD_INT 75
15957: PPUSH
15958: LD_INT 53
15960: PPUSH
15961: CALL_OW 84
// wait ( 0 0$4 ) ;
15965: LD_INT 140
15967: PPUSH
15968: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15972: LD_EXP 58
15976: PPUSH
15977: CALL_OW 87
// if not dialogue_skipped then
15981: LD_OWVAR 59
15985: NOT
15986: IFFALSE 15995
// wait ( 0 0$2 ) ;
15988: LD_INT 70
15990: PPUSH
15991: CALL_OW 67
// sync ;
15995: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15996: LD_EXP 39
16000: PPUSH
16001: LD_STRING D1-JMM-2
16003: PPUSH
16004: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
16008: LD_EXP 58
16012: PPUSH
16013: LD_STRING D1-Pow-2
16015: PPUSH
16016: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
16020: LD_EXP 39
16024: PPUSH
16025: LD_STRING D1-JMM-3
16027: PPUSH
16028: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
16032: LD_EXP 58
16036: PPUSH
16037: LD_STRING D1-Pow-3
16039: PPUSH
16040: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
16044: LD_EXP 39
16048: PPUSH
16049: LD_STRING D1-JMM-4
16051: PPUSH
16052: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
16056: LD_EXP 58
16060: PPUSH
16061: LD_STRING D1-Pow-4
16063: PPUSH
16064: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
16068: LD_EXP 39
16072: PPUSH
16073: LD_STRING D1-JMM-5
16075: PPUSH
16076: CALL_OW 88
// async ;
16080: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
16081: LD_EXP 58
16085: PPUSH
16086: LD_STRING D1-Pow-5
16088: PPUSH
16089: CALL_OW 88
// if not dialogue_skipped then
16093: LD_OWVAR 59
16097: NOT
16098: IFFALSE 16107
// wait ( 0 0$3.6 ) ;
16100: LD_INT 126
16102: PPUSH
16103: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
16107: LD_INT 134
16109: PPUSH
16110: LD_INT 210
16112: PPUSH
16113: LD_INT 1
16115: PPUSH
16116: LD_INT 11
16118: NEG
16119: PPUSH
16120: CALL 102508 0 4
// if not dialogue_skipped then
16124: LD_OWVAR 59
16128: NOT
16129: IFFALSE 16148
// begin CenterOnXY ( 134 , 210 ) ;
16131: LD_INT 134
16133: PPUSH
16134: LD_INT 210
16136: PPUSH
16137: CALL_OW 84
// wait ( 0 0$2 ) ;
16141: LD_INT 70
16143: PPUSH
16144: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
16148: LD_INT 101
16150: PPUSH
16151: LD_INT 159
16153: PPUSH
16154: LD_INT 1
16156: PPUSH
16157: LD_INT 10
16159: NEG
16160: PPUSH
16161: CALL 102508 0 4
// if not dialogue_skipped then
16165: LD_OWVAR 59
16169: NOT
16170: IFFALSE 16189
// begin CenterOnXY ( 101 , 159 ) ;
16172: LD_INT 101
16174: PPUSH
16175: LD_INT 159
16177: PPUSH
16178: CALL_OW 84
// wait ( 0 0$2 ) ;
16182: LD_INT 70
16184: PPUSH
16185: CALL_OW 67
// end ; sync ;
16189: SYNC
// CenterNowOnUnits ( Powell ) ;
16190: LD_EXP 58
16194: PPUSH
16195: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
16199: LD_ADDR_VAR 0 6
16203: PUSH
16204: LD_INT 1
16206: PUSH
16207: LD_INT 2
16209: PUSH
16210: LD_INT 3
16212: PUSH
16213: LD_INT 4
16215: PUSH
16216: LD_INT 5
16218: PUSH
16219: LD_INT 6
16221: PUSH
16222: EMPTY
16223: LIST
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: LIST
16229: ST_TO_ADDR
// if not dialogue_skipped then
16230: LD_OWVAR 59
16234: NOT
16235: IFFALSE 16404
// begin game_speed := 4 ;
16237: LD_ADDR_OWVAR 65
16241: PUSH
16242: LD_INT 4
16244: ST_TO_ADDR
// wait ( 0 0$6 ) ;
16245: LD_INT 210
16247: PPUSH
16248: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
16252: LD_ADDR_VAR 0 7
16256: PUSH
16257: LD_STRING Q1
16259: PPUSH
16260: LD_VAR 0 6
16264: PPUSH
16265: CALL_OW 98
16269: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
16270: LD_ADDR_VAR 0 7
16274: PUSH
16275: LD_STRING Q1
16277: PPUSH
16278: LD_VAR 0 6
16282: PPUSH
16283: CALL_OW 98
16287: ST_TO_ADDR
// options = options diff dec ;
16288: LD_ADDR_VAR 0 6
16292: PUSH
16293: LD_VAR 0 6
16297: PUSH
16298: LD_VAR 0 7
16302: DIFF
16303: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16304: LD_VAR 0 7
16308: PPUSH
16309: LD_VAR 0 6
16313: PPUSH
16314: CALL 17876 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16318: LD_VAR 0 7
16322: PUSH
16323: LD_INT 5
16325: PUSH
16326: LD_INT 6
16328: PUSH
16329: EMPTY
16330: LIST
16331: LIST
16332: IN
16333: PUSH
16334: LD_VAR 0 6
16338: PUSH
16339: LD_INT 2
16341: EQUAL
16342: OR
16343: IFFALSE 16270
// if not ( dec in [ 5 , 6 ] ) then
16345: LD_VAR 0 7
16349: PUSH
16350: LD_INT 5
16352: PUSH
16353: LD_INT 6
16355: PUSH
16356: EMPTY
16357: LIST
16358: LIST
16359: IN
16360: NOT
16361: IFFALSE 16404
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16363: LD_ADDR_VAR 0 7
16367: PUSH
16368: LD_STRING Q1a
16370: PPUSH
16371: LD_INT 1
16373: PUSH
16374: LD_INT 2
16376: PUSH
16377: EMPTY
16378: LIST
16379: LIST
16380: PPUSH
16381: CALL_OW 98
16385: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16386: LD_VAR 0 7
16390: PUSH
16391: LD_INT 4
16393: PLUS
16394: PPUSH
16395: LD_VAR 0 6
16399: PPUSH
16400: CALL 17876 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16404: LD_INT 81
16406: PPUSH
16407: LD_INT 127
16409: PPUSH
16410: CALL_OW 84
// amount := 5 ;
16414: LD_ADDR_VAR 0 8
16418: PUSH
16419: LD_INT 5
16421: ST_TO_ADDR
// macmilan_squad := [ ] ;
16422: LD_ADDR_VAR 0 9
16426: PUSH
16427: EMPTY
16428: ST_TO_ADDR
// if vip < amount then
16429: LD_EXP 59
16433: PUSH
16434: LD_VAR 0 8
16438: LESS
16439: IFFALSE 16483
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16441: LD_ADDR_VAR 0 5
16445: PUSH
16446: LD_EXP 59
16450: PUSH
16451: LD_INT 22
16453: PUSH
16454: LD_INT 4
16456: PUSH
16457: EMPTY
16458: LIST
16459: LIST
16460: PUSH
16461: LD_INT 21
16463: PUSH
16464: LD_INT 1
16466: PUSH
16467: EMPTY
16468: LIST
16469: LIST
16470: PUSH
16471: EMPTY
16472: LIST
16473: LIST
16474: PPUSH
16475: CALL_OW 69
16479: UNION
16480: ST_TO_ADDR
16481: GO 16493
// tmp := vip ;
16483: LD_ADDR_VAR 0 5
16487: PUSH
16488: LD_EXP 59
16492: ST_TO_ADDR
// tmp := tmp diff Powell ;
16493: LD_ADDR_VAR 0 5
16497: PUSH
16498: LD_VAR 0 5
16502: PUSH
16503: LD_EXP 58
16507: DIFF
16508: ST_TO_ADDR
// if tmp < amount then
16509: LD_VAR 0 5
16513: PUSH
16514: LD_VAR 0 8
16518: LESS
16519: IFFALSE 16531
// amount := tmp ;
16521: LD_ADDR_VAR 0 8
16525: PUSH
16526: LD_VAR 0 5
16530: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16531: LD_VAR 0 5
16535: PUSH
16536: LD_INT 1
16538: ARRAY
16539: PPUSH
16540: CALL_OW 257
16544: PUSH
16545: LD_INT 2
16547: NONEQUAL
16548: IFFALSE 16610
// begin if IsInUnit ( tmp [ 1 ] ) then
16550: LD_VAR 0 5
16554: PUSH
16555: LD_INT 1
16557: ARRAY
16558: PPUSH
16559: CALL_OW 310
16563: IFFALSE 16578
// ComExitBuilding ( tmp [ 1 ] ) ;
16565: LD_VAR 0 5
16569: PUSH
16570: LD_INT 1
16572: ARRAY
16573: PPUSH
16574: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16578: LD_VAR 0 5
16582: PUSH
16583: LD_INT 1
16585: ARRAY
16586: PPUSH
16587: LD_INT 387
16589: PPUSH
16590: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16594: LD_VAR 0 5
16598: PUSH
16599: LD_INT 1
16601: ARRAY
16602: PPUSH
16603: LD_INT 2
16605: PPUSH
16606: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16610: LD_EXP 39
16614: PPUSH
16615: LD_INT 82
16617: PPUSH
16618: LD_INT 129
16620: PPUSH
16621: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16625: LD_EXP 39
16629: PPUSH
16630: LD_EXP 58
16634: PPUSH
16635: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16639: LD_INT 22
16641: PUSH
16642: LD_INT 1
16644: PUSH
16645: EMPTY
16646: LIST
16647: LIST
16648: PPUSH
16649: CALL_OW 69
16653: PUSH
16654: LD_EXP 39
16658: DIFF
16659: PPUSH
16660: LD_INT 84
16662: PPUSH
16663: LD_INT 128
16665: PPUSH
16666: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16670: LD_INT 22
16672: PUSH
16673: LD_INT 1
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PPUSH
16680: CALL_OW 69
16684: PUSH
16685: LD_EXP 39
16689: DIFF
16690: PPUSH
16691: LD_EXP 39
16695: PPUSH
16696: CALL_OW 179
// for i = 1 to amount do
16700: LD_ADDR_VAR 0 2
16704: PUSH
16705: DOUBLE
16706: LD_INT 1
16708: DEC
16709: ST_TO_ADDR
16710: LD_VAR 0 8
16714: PUSH
16715: FOR_TO
16716: IFFALSE 16884
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16718: LD_ADDR_VAR 0 9
16722: PUSH
16723: LD_VAR 0 9
16727: PUSH
16728: LD_VAR 0 5
16732: PUSH
16733: LD_VAR 0 2
16737: ARRAY
16738: ADD
16739: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16740: LD_VAR 0 5
16744: PUSH
16745: LD_VAR 0 2
16749: ARRAY
16750: PPUSH
16751: CALL_OW 310
16755: IFFALSE 16772
// AddComExitBuilding ( tmp [ i ] ) ;
16757: LD_VAR 0 5
16761: PUSH
16762: LD_VAR 0 2
16766: ARRAY
16767: PPUSH
16768: CALL_OW 182
// if i = 2 and JMMNewVeh then
16772: LD_VAR 0 2
16776: PUSH
16777: LD_INT 2
16779: EQUAL
16780: PUSH
16781: LD_EXP 56
16785: AND
16786: IFFALSE 16844
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16788: LD_VAR 0 5
16792: PUSH
16793: LD_VAR 0 2
16797: ARRAY
16798: PPUSH
16799: LD_EXP 56
16803: PPUSH
16804: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16808: LD_VAR 0 5
16812: PUSH
16813: LD_VAR 0 2
16817: ARRAY
16818: PPUSH
16819: LD_INT 86
16821: PPUSH
16822: LD_INT 133
16824: PPUSH
16825: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16829: LD_VAR 0 5
16833: PUSH
16834: LD_VAR 0 2
16838: ARRAY
16839: PPUSH
16840: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16844: LD_VAR 0 5
16848: PUSH
16849: LD_VAR 0 2
16853: ARRAY
16854: PPUSH
16855: LD_INT 8
16857: PPUSH
16858: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16862: LD_VAR 0 5
16866: PUSH
16867: LD_VAR 0 2
16871: ARRAY
16872: PPUSH
16873: LD_EXP 39
16877: PPUSH
16878: CALL_OW 179
// end ;
16882: GO 16715
16884: POP
16885: POP
// if GirlNewVeh then
16886: LD_EXP 57
16890: IFFALSE 16904
// SetSide ( GirlNewVeh , 4 ) ;
16892: LD_EXP 57
16896: PPUSH
16897: LD_INT 4
16899: PPUSH
16900: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16904: LD_INT 35
16906: PPUSH
16907: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16911: LD_VAR 0 9
16915: PPUSH
16916: LD_INT 95
16918: PUSH
16919: LD_INT 9
16921: PUSH
16922: EMPTY
16923: LIST
16924: LIST
16925: PPUSH
16926: CALL_OW 72
16930: PUSH
16931: LD_INT 0
16933: EQUAL
16934: PUSH
16935: LD_EXP 39
16939: PPUSH
16940: LD_INT 9
16942: PPUSH
16943: CALL_OW 308
16947: NOT
16948: AND
16949: IFFALSE 16904
// wait ( 0 0$2 ) ;
16951: LD_INT 70
16953: PPUSH
16954: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16958: LD_VAR 0 9
16962: PPUSH
16963: LD_INT 1
16965: PPUSH
16966: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16970: LD_INT 21
16972: PUSH
16973: LD_INT 2
16975: PUSH
16976: EMPTY
16977: LIST
16978: LIST
16979: PUSH
16980: LD_INT 92
16982: PUSH
16983: LD_INT 83
16985: PUSH
16986: LD_INT 130
16988: PUSH
16989: LD_INT 10
16991: PUSH
16992: EMPTY
16993: LIST
16994: LIST
16995: LIST
16996: LIST
16997: PUSH
16998: EMPTY
16999: LIST
17000: LIST
17001: PPUSH
17002: CALL_OW 69
17006: PPUSH
17007: LD_INT 1
17009: PPUSH
17010: CALL_OW 235
// Video ( false ) ;
17014: LD_INT 0
17016: PPUSH
17017: CALL 102594 0 1
// ChangeMissionObjectives ( M1 ) ;
17021: LD_STRING M1
17023: PPUSH
17024: CALL_OW 337
// SaveForQuickRestart ;
17028: CALL_OW 22
// missionStart := true ;
17032: LD_ADDR_EXP 13
17036: PUSH
17037: LD_INT 1
17039: ST_TO_ADDR
// missionStage := 2 ;
17040: LD_ADDR_EXP 15
17044: PUSH
17045: LD_INT 2
17047: ST_TO_ADDR
// wait ( 0 0$3 ) ;
17048: LD_INT 105
17050: PPUSH
17051: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
17055: LD_ADDR_VAR 0 5
17059: PUSH
17060: LD_INT 22
17062: PUSH
17063: LD_INT 4
17065: PUSH
17066: EMPTY
17067: LIST
17068: LIST
17069: PUSH
17070: LD_INT 21
17072: PUSH
17073: LD_INT 1
17075: PUSH
17076: EMPTY
17077: LIST
17078: LIST
17079: PUSH
17080: EMPTY
17081: LIST
17082: LIST
17083: PPUSH
17084: CALL_OW 69
17088: PUSH
17089: LD_EXP 58
17093: DIFF
17094: ST_TO_ADDR
// if not tmp then
17095: LD_VAR 0 5
17099: NOT
17100: IFFALSE 17115
// tmp := [ Powell ] ;
17102: LD_ADDR_VAR 0 5
17106: PUSH
17107: LD_EXP 58
17111: PUSH
17112: EMPTY
17113: LIST
17114: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
17115: LD_ADDR_EXP 116
17119: PUSH
17120: LD_EXP 116
17124: PPUSH
17125: LD_INT 4
17127: PPUSH
17128: LD_INT 22
17130: PUSH
17131: LD_INT 4
17133: PUSH
17134: EMPTY
17135: LIST
17136: LIST
17137: PUSH
17138: LD_INT 23
17140: PUSH
17141: LD_INT 1
17143: PUSH
17144: EMPTY
17145: LIST
17146: LIST
17147: PUSH
17148: LD_INT 3
17150: PUSH
17151: LD_INT 21
17153: PUSH
17154: LD_INT 2
17156: PUSH
17157: EMPTY
17158: LIST
17159: LIST
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: PUSH
17165: EMPTY
17166: LIST
17167: LIST
17168: LIST
17169: PPUSH
17170: CALL_OW 69
17174: PUSH
17175: LD_EXP 58
17179: DIFF
17180: PPUSH
17181: CALL_OW 1
17185: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
17186: LD_ADDR_VAR 0 4
17190: PUSH
17191: LD_INT 22
17193: PUSH
17194: LD_INT 4
17196: PUSH
17197: EMPTY
17198: LIST
17199: LIST
17200: PUSH
17201: LD_INT 34
17203: PUSH
17204: LD_INT 12
17206: PUSH
17207: EMPTY
17208: LIST
17209: LIST
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: PPUSH
17215: CALL_OW 69
17219: PUSH
17220: LD_INT 1
17222: ARRAY
17223: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
17224: LD_VAR 0 5
17228: PUSH
17229: LD_INT 1
17231: ARRAY
17232: PPUSH
17233: CALL_OW 310
17237: IFFALSE 17252
// ComExitBuilding ( tmp [ 1 ] ) ;
17239: LD_VAR 0 5
17243: PUSH
17244: LD_INT 1
17246: ARRAY
17247: PPUSH
17248: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
17252: LD_VAR 0 5
17256: PUSH
17257: LD_INT 1
17259: ARRAY
17260: PPUSH
17261: LD_VAR 0 4
17265: PPUSH
17266: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
17270: LD_VAR 0 5
17274: PUSH
17275: LD_INT 1
17277: ARRAY
17278: PPUSH
17279: LD_INT 80
17281: PPUSH
17282: LD_INT 136
17284: PPUSH
17285: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17289: LD_VAR 0 5
17293: PUSH
17294: LD_INT 1
17296: ARRAY
17297: PPUSH
17298: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17302: LD_VAR 0 5
17306: PUSH
17307: LD_INT 1
17309: ARRAY
17310: PPUSH
17311: LD_INT 59
17313: PPUSH
17314: LD_INT 112
17316: PPUSH
17317: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17321: LD_VAR 0 5
17325: PUSH
17326: LD_INT 1
17328: ARRAY
17329: PPUSH
17330: CALL_OW 181
// if Joan and GetSide ( Joan ) = 1 then
17334: LD_EXP 40
17338: PUSH
17339: LD_EXP 40
17343: PPUSH
17344: CALL_OW 255
17348: PUSH
17349: LD_INT 1
17351: EQUAL
17352: AND
17353: IFFALSE 17379
// begin Say ( Joan , D3W-Joan-1 ) ;
17355: LD_EXP 40
17359: PPUSH
17360: LD_STRING D3W-Joan-1
17362: PPUSH
17363: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17367: LD_EXP 39
17371: PPUSH
17372: LD_STRING D3W-JMM-1
17374: PPUSH
17375: CALL_OW 88
// end ; if Lisa and GetSide ( Lisa ) = 1 and not Lisa in vip then
17379: LD_EXP 42
17383: PUSH
17384: LD_EXP 42
17388: PPUSH
17389: CALL_OW 255
17393: PUSH
17394: LD_INT 1
17396: EQUAL
17397: AND
17398: PUSH
17399: LD_EXP 42
17403: PUSH
17404: LD_EXP 59
17408: IN
17409: NOT
17410: AND
17411: IFFALSE 17437
// begin Say ( Lisa , D3W-Lisa-1 ) ;
17413: LD_EXP 42
17417: PPUSH
17418: LD_STRING D3W-Lisa-1
17420: PPUSH
17421: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17425: LD_EXP 39
17429: PPUSH
17430: LD_STRING D3W-JMM-1
17432: PPUSH
17433: CALL_OW 88
// end ; if Connie and GetSide ( Connie ) = 1 then
17437: LD_EXP 54
17441: PUSH
17442: LD_EXP 54
17446: PPUSH
17447: CALL_OW 255
17451: PUSH
17452: LD_INT 1
17454: EQUAL
17455: AND
17456: IFFALSE 17482
// begin Say ( Connie , D3W-Con-1 ) ;
17458: LD_EXP 54
17462: PPUSH
17463: LD_STRING D3W-Con-1
17465: PPUSH
17466: CALL_OW 88
// Say ( JMM , D3W-JMM-1 ) ;
17470: LD_EXP 39
17474: PPUSH
17475: LD_STRING D3W-JMM-1
17477: PPUSH
17478: CALL_OW 88
// end ; if Lisa in vip and GetSide ( Lisa ) = 1 then
17482: LD_EXP 42
17486: PUSH
17487: LD_EXP 59
17491: IN
17492: PUSH
17493: LD_EXP 42
17497: PPUSH
17498: CALL_OW 255
17502: PUSH
17503: LD_INT 1
17505: EQUAL
17506: AND
17507: IFFALSE 17523
// Say ( Lisa , D3nW-Lisa-1 ) else
17509: LD_EXP 42
17513: PPUSH
17514: LD_STRING D3nW-Lisa-1
17516: PPUSH
17517: CALL_OW 88
17521: GO 17767
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17523: LD_EXP 45
17527: PUSH
17528: LD_EXP 59
17532: IN
17533: PUSH
17534: LD_EXP 45
17538: PPUSH
17539: CALL_OW 255
17543: PUSH
17544: LD_INT 1
17546: EQUAL
17547: AND
17548: IFFALSE 17564
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17550: LD_EXP 45
17554: PPUSH
17555: LD_STRING D3nW-Cyrus-1
17557: PPUSH
17558: CALL_OW 88
17562: GO 17767
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17564: LD_EXP 44
17568: PUSH
17569: LD_EXP 59
17573: IN
17574: PUSH
17575: LD_EXP 44
17579: PPUSH
17580: CALL_OW 255
17584: PUSH
17585: LD_INT 1
17587: EQUAL
17588: AND
17589: IFFALSE 17605
// Say ( Bobby , D3nW-Bobby-1 ) else
17591: LD_EXP 44
17595: PPUSH
17596: LD_STRING D3nW-Bobby-1
17598: PPUSH
17599: CALL_OW 88
17603: GO 17767
// if Gary in vip and GetSide ( Gary ) = 1 then
17605: LD_EXP 51
17609: PUSH
17610: LD_EXP 59
17614: IN
17615: PUSH
17616: LD_EXP 51
17620: PPUSH
17621: CALL_OW 255
17625: PUSH
17626: LD_INT 1
17628: EQUAL
17629: AND
17630: IFFALSE 17646
// Say ( Gary , D3nW-Gary-1 ) else
17632: LD_EXP 51
17636: PPUSH
17637: LD_STRING D3nW-Gary-1
17639: PPUSH
17640: CALL_OW 88
17644: GO 17767
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17646: LD_EXP 43
17650: PUSH
17651: LD_EXP 59
17655: IN
17656: PUSH
17657: LD_EXP 43
17661: PPUSH
17662: CALL_OW 255
17666: PUSH
17667: LD_INT 1
17669: EQUAL
17670: AND
17671: IFFALSE 17687
// Say ( Donaldson , D3nW-Don-1 ) else
17673: LD_EXP 43
17677: PPUSH
17678: LD_STRING D3nW-Don-1
17680: PPUSH
17681: CALL_OW 88
17685: GO 17767
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17687: LD_EXP 50
17691: PUSH
17692: LD_EXP 59
17696: IN
17697: PUSH
17698: LD_EXP 50
17702: PPUSH
17703: CALL_OW 255
17707: PUSH
17708: LD_INT 1
17710: EQUAL
17711: AND
17712: IFFALSE 17728
// Say ( Cornel , D3nW-Corn-1 ) else
17714: LD_EXP 50
17718: PPUSH
17719: LD_STRING D3nW-Corn-1
17721: PPUSH
17722: CALL_OW 88
17726: GO 17767
// if Frank in vip and GetSide ( Frank ) = 1 then
17728: LD_EXP 52
17732: PUSH
17733: LD_EXP 59
17737: IN
17738: PUSH
17739: LD_EXP 52
17743: PPUSH
17744: CALL_OW 255
17748: PUSH
17749: LD_INT 1
17751: EQUAL
17752: AND
17753: IFFALSE 17767
// Say ( Frank , D3nW-Frank-1 ) ;
17755: LD_EXP 52
17759: PPUSH
17760: LD_STRING D3nW-Frank-1
17762: PPUSH
17763: CALL_OW 88
// if UnitFilter ( vip , [ f_side , 1 ] ) then
17767: LD_EXP 59
17771: PPUSH
17772: LD_INT 22
17774: PUSH
17775: LD_INT 1
17777: PUSH
17778: EMPTY
17779: LIST
17780: LIST
17781: PPUSH
17782: CALL_OW 72
17786: IFFALSE 17812
// begin Say ( JMM , D3nW-JMM-1 ) ;
17788: LD_EXP 39
17792: PPUSH
17793: LD_STRING D3nW-JMM-1
17795: PPUSH
17796: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17800: LD_EXP 39
17804: PPUSH
17805: LD_STRING D3nW-JMM-1a
17807: PPUSH
17808: CALL_OW 88
// end ; t := 0 0$00 ;
17812: LD_ADDR_VAR 0 3
17816: PUSH
17817: LD_INT 0
17819: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17820: LD_INT 35
17822: PPUSH
17823: CALL_OW 67
// t := t + 0 0$1 ;
17827: LD_ADDR_VAR 0 3
17831: PUSH
17832: LD_VAR 0 3
17836: PUSH
17837: LD_INT 35
17839: PLUS
17840: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17841: LD_INT 59
17843: PPUSH
17844: LD_INT 112
17846: PPUSH
17847: CALL_OW 428
17851: PUSH
17852: LD_VAR 0 3
17856: PUSH
17857: LD_INT 2100
17859: GREATER
17860: OR
17861: IFFALSE 17820
// activeAttacks := true ;
17863: LD_ADDR_EXP 16
17867: PUSH
17868: LD_INT 1
17870: ST_TO_ADDR
// end ;
17871: LD_VAR 0 1
17875: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17876: LD_INT 0
17878: PPUSH
// case question of 1 :
17879: LD_VAR 0 1
17883: PUSH
17884: LD_INT 1
17886: DOUBLE
17887: EQUAL
17888: IFTRUE 17892
17890: GO 17943
17892: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17893: LD_EXP 39
17897: PPUSH
17898: LD_STRING D2Mot-JMM-1
17900: PPUSH
17901: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17905: LD_EXP 58
17909: PPUSH
17910: LD_STRING D2Mot-Pow-1
17912: PPUSH
17913: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17917: LD_EXP 39
17921: PPUSH
17922: LD_STRING D2Mot-JMM-2
17924: PPUSH
17925: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17929: LD_EXP 58
17933: PPUSH
17934: LD_STRING D2Mot-Pow-2
17936: PPUSH
17937: CALL_OW 88
// end ; 2 :
17941: GO 18294
17943: LD_INT 2
17945: DOUBLE
17946: EQUAL
17947: IFTRUE 17951
17949: GO 18027
17951: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17952: LD_EXP 39
17956: PPUSH
17957: LD_STRING D2Rus-JMM-1
17959: PPUSH
17960: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17964: LD_EXP 58
17968: PPUSH
17969: LD_STRING D2Rus-Pow-1
17971: PPUSH
17972: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17976: LD_EXP 39
17980: PPUSH
17981: LD_STRING D2Rus-JMM-2
17983: PPUSH
17984: CALL_OW 88
// if not ( 3 in list_of_q ) then
17988: LD_INT 3
17990: PUSH
17991: LD_VAR 0 2
17995: IN
17996: NOT
17997: IFFALSE 18013
// Say ( Powell , D2Rus-Pow-2 ) else
17999: LD_EXP 58
18003: PPUSH
18004: LD_STRING D2Rus-Pow-2
18006: PPUSH
18007: CALL_OW 88
18011: GO 18025
// Say ( Powell , D2Rus-Pow-2a ) ;
18013: LD_EXP 58
18017: PPUSH
18018: LD_STRING D2Rus-Pow-2a
18020: PPUSH
18021: CALL_OW 88
// end ; 3 :
18025: GO 18294
18027: LD_INT 3
18029: DOUBLE
18030: EQUAL
18031: IFTRUE 18035
18033: GO 18120
18035: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
18036: LD_EXP 39
18040: PPUSH
18041: LD_STRING D2Leg-JMM-1
18043: PPUSH
18044: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
18048: LD_EXP 58
18052: PPUSH
18053: LD_STRING D2Leg-Pow-1
18055: PPUSH
18056: CALL_OW 88
// if 2 in list_of_q then
18060: LD_INT 2
18062: PUSH
18063: LD_VAR 0 2
18067: IN
18068: IFFALSE 18094
// begin Say ( JMM , D2Leg-JMM-2 ) ;
18070: LD_EXP 39
18074: PPUSH
18075: LD_STRING D2Leg-JMM-2
18077: PPUSH
18078: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
18082: LD_EXP 58
18086: PPUSH
18087: LD_STRING D2Leg-Pow-2
18089: PPUSH
18090: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
18094: LD_EXP 39
18098: PPUSH
18099: LD_STRING D2Leg-JMM-3
18101: PPUSH
18102: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
18106: LD_EXP 58
18110: PPUSH
18111: LD_STRING D2Leg-Pow-3
18113: PPUSH
18114: CALL_OW 88
// end ; 4 :
18118: GO 18294
18120: LD_INT 4
18122: DOUBLE
18123: EQUAL
18124: IFTRUE 18128
18126: GO 18203
18128: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
18129: LD_EXP 39
18133: PPUSH
18134: LD_STRING D2Ar-JMM-1
18136: PPUSH
18137: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
18141: LD_EXP 58
18145: PPUSH
18146: LD_STRING D2Ar-Pow-1
18148: PPUSH
18149: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
18153: LD_EXP 39
18157: PPUSH
18158: LD_STRING D2Ar-JMM-2
18160: PPUSH
18161: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
18165: LD_EXP 58
18169: PPUSH
18170: LD_STRING D2Ar-Pow-2
18172: PPUSH
18173: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
18177: LD_EXP 39
18181: PPUSH
18182: LD_STRING D2Ar-JMM-3
18184: PPUSH
18185: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
18189: LD_EXP 58
18193: PPUSH
18194: LD_STRING D2Ar-Pow-3
18196: PPUSH
18197: CALL_OW 88
// end ; 5 :
18201: GO 18294
18203: LD_INT 5
18205: DOUBLE
18206: EQUAL
18207: IFTRUE 18211
18209: GO 18226
18211: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
18212: LD_EXP 39
18216: PPUSH
18217: LD_STRING D2Conf-JMM-1
18219: PPUSH
18220: CALL_OW 88
18224: GO 18294
18226: LD_INT 6
18228: DOUBLE
18229: EQUAL
18230: IFTRUE 18234
18232: GO 18293
18234: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
18235: LD_EXP 39
18239: PPUSH
18240: LD_STRING D2Com-JMM-1
18242: PPUSH
18243: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
18247: LD_EXP 58
18251: PPUSH
18252: LD_STRING D2Com-Pow-1
18254: PPUSH
18255: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
18259: LD_EXP 39
18263: PPUSH
18264: LD_STRING D2Com-JMM-2
18266: PPUSH
18267: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
18271: LD_EXP 58
18275: PPUSH
18276: LD_STRING D2Com-Pow-2
18278: PPUSH
18279: CALL_OW 88
// powellAngerQuery := true ;
18283: LD_ADDR_EXP 36
18287: PUSH
18288: LD_INT 1
18290: ST_TO_ADDR
// end ; end ;
18291: GO 18294
18293: POP
// end ;
18294: LD_VAR 0 3
18298: RET
// every 0 0$5 trigger missionStart do var tmp ;
18299: LD_EXP 13
18303: IFFALSE 18586
18305: GO 18307
18307: DISABLE
18308: LD_INT 0
18310: PPUSH
// begin repeat wait ( 0 0$1 ) ;
18311: LD_INT 35
18313: PPUSH
18314: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
18318: LD_INT 14
18320: PPUSH
18321: LD_INT 22
18323: PUSH
18324: LD_INT 1
18326: PUSH
18327: EMPTY
18328: LIST
18329: LIST
18330: PPUSH
18331: CALL_OW 70
18335: PUSH
18336: LD_EXP 15
18340: PUSH
18341: LD_INT 2
18343: PUSH
18344: LD_INT 3
18346: PUSH
18347: LD_INT 4
18349: PUSH
18350: LD_INT 5
18352: PUSH
18353: EMPTY
18354: LIST
18355: LIST
18356: LIST
18357: LIST
18358: IN
18359: AND
18360: IFFALSE 18576
// begin powellAnger := powellAnger + 1 ;
18362: LD_ADDR_EXP 17
18366: PUSH
18367: LD_EXP 17
18371: PUSH
18372: LD_INT 1
18374: PLUS
18375: ST_TO_ADDR
// Video ( true ) ;
18376: LD_INT 1
18378: PPUSH
18379: CALL 102594 0 1
// CenterNowOnUnits ( tmp ) ;
18383: LD_VAR 0 1
18387: PPUSH
18388: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18392: LD_INT 14
18394: PPUSH
18395: LD_INT 22
18397: PUSH
18398: LD_INT 1
18400: PUSH
18401: EMPTY
18402: LIST
18403: LIST
18404: PPUSH
18405: CALL_OW 70
18409: PPUSH
18410: LD_INT 86
18412: PPUSH
18413: LD_INT 133
18415: PPUSH
18416: CALL_OW 111
// async ;
18420: ASYNC
// case powellAnger of 1 :
18421: LD_EXP 17
18425: PUSH
18426: LD_INT 1
18428: DOUBLE
18429: EQUAL
18430: IFTRUE 18434
18432: GO 18449
18434: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
18435: LD_EXP 58
18439: PPUSH
18440: LD_STRING DBack1-Pow-1
18442: PPUSH
18443: CALL_OW 88
18447: GO 18496
18449: LD_INT 2
18451: DOUBLE
18452: EQUAL
18453: IFTRUE 18457
18455: GO 18472
18457: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18458: LD_EXP 58
18462: PPUSH
18463: LD_STRING DBack2-Pow-1
18465: PPUSH
18466: CALL_OW 88
18470: GO 18496
18472: LD_INT 3
18474: DOUBLE
18475: EQUAL
18476: IFTRUE 18480
18478: GO 18495
18480: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18481: LD_EXP 58
18485: PPUSH
18486: LD_STRING DBack3-Pow-1
18488: PPUSH
18489: CALL_OW 88
18493: GO 18496
18495: POP
// sync ;
18496: SYNC
// repeat wait ( 0 0$1 ) ;
18497: LD_INT 35
18499: PPUSH
18500: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18504: LD_INT 14
18506: PPUSH
18507: LD_INT 22
18509: PUSH
18510: LD_INT 1
18512: PUSH
18513: EMPTY
18514: LIST
18515: LIST
18516: PPUSH
18517: CALL_OW 70
18521: PPUSH
18522: LD_INT 86
18524: PPUSH
18525: LD_INT 133
18527: PPUSH
18528: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18532: LD_INT 14
18534: PPUSH
18535: LD_INT 22
18537: PUSH
18538: LD_INT 1
18540: PUSH
18541: EMPTY
18542: LIST
18543: LIST
18544: PPUSH
18545: CALL_OW 70
18549: NOT
18550: IFFALSE 18497
// if powellAnger >= 3 then
18552: LD_EXP 17
18556: PUSH
18557: LD_INT 3
18559: GREATEREQUAL
18560: IFFALSE 18569
// YouLost ( Dismissed ) ;
18562: LD_STRING Dismissed
18564: PPUSH
18565: CALL_OW 104
// Video ( false ) ;
18569: LD_INT 0
18571: PPUSH
18572: CALL 102594 0 1
// end ; until missionStage > 5 ;
18576: LD_EXP 15
18580: PUSH
18581: LD_INT 5
18583: GREATER
18584: IFFALSE 18311
// end ;
18586: PPOPN 1
18588: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18589: LD_EXP 13
18593: PUSH
18594: LD_INT 22
18596: PUSH
18597: LD_INT 4
18599: PUSH
18600: EMPTY
18601: LIST
18602: LIST
18603: PUSH
18604: LD_INT 21
18606: PUSH
18607: LD_INT 2
18609: PUSH
18610: EMPTY
18611: LIST
18612: LIST
18613: PUSH
18614: EMPTY
18615: LIST
18616: LIST
18617: PPUSH
18618: CALL_OW 69
18622: PUSH
18623: LD_INT 4
18625: GREATEREQUAL
18626: AND
18627: PUSH
18628: LD_EXP 15
18632: PUSH
18633: LD_INT 2
18635: EQUAL
18636: AND
18637: IFFALSE 20460
18639: GO 18641
18641: DISABLE
18642: LD_INT 0
18644: PPUSH
18645: PPUSH
18646: PPUSH
18647: PPUSH
18648: PPUSH
18649: PPUSH
18650: PPUSH
18651: PPUSH
// begin missionStage := 3 ;
18652: LD_ADDR_EXP 15
18656: PUSH
18657: LD_INT 3
18659: ST_TO_ADDR
// retreat := false ;
18660: LD_ADDR_VAR 0 4
18664: PUSH
18665: LD_INT 0
18667: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18668: LD_ADDR_VAR 0 5
18672: PUSH
18673: LD_INT 22
18675: PUSH
18676: LD_INT 4
18678: PUSH
18679: EMPTY
18680: LIST
18681: LIST
18682: PUSH
18683: LD_INT 30
18685: PUSH
18686: LD_INT 4
18688: PUSH
18689: EMPTY
18690: LIST
18691: LIST
18692: PUSH
18693: EMPTY
18694: LIST
18695: LIST
18696: PPUSH
18697: CALL_OW 69
18701: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18702: LD_ADDR_VAR 0 6
18706: PUSH
18707: LD_INT 22
18709: PUSH
18710: LD_INT 4
18712: PUSH
18713: EMPTY
18714: LIST
18715: LIST
18716: PUSH
18717: LD_INT 30
18719: PUSH
18720: LD_INT 5
18722: PUSH
18723: EMPTY
18724: LIST
18725: LIST
18726: PUSH
18727: EMPTY
18728: LIST
18729: LIST
18730: PPUSH
18731: CALL_OW 69
18735: ST_TO_ADDR
// if not bar then
18736: LD_VAR 0 6
18740: NOT
18741: IFFALSE 18794
// begin repeat wait ( 0 0$1 ) ;
18743: LD_INT 35
18745: PPUSH
18746: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18750: LD_INT 22
18752: PUSH
18753: LD_INT 4
18755: PUSH
18756: EMPTY
18757: LIST
18758: LIST
18759: PUSH
18760: LD_INT 3
18762: PUSH
18763: LD_INT 57
18765: PUSH
18766: EMPTY
18767: LIST
18768: PUSH
18769: EMPTY
18770: LIST
18771: LIST
18772: PUSH
18773: LD_INT 30
18775: PUSH
18776: LD_INT 5
18778: PUSH
18779: EMPTY
18780: LIST
18781: LIST
18782: PUSH
18783: EMPTY
18784: LIST
18785: LIST
18786: LIST
18787: PPUSH
18788: CALL_OW 69
18792: IFFALSE 18743
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18794: LD_ADDR_VAR 0 6
18798: PUSH
18799: LD_INT 22
18801: PUSH
18802: LD_INT 4
18804: PUSH
18805: EMPTY
18806: LIST
18807: LIST
18808: PUSH
18809: LD_INT 30
18811: PUSH
18812: LD_INT 5
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: PUSH
18819: EMPTY
18820: LIST
18821: LIST
18822: PPUSH
18823: CALL_OW 69
18827: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18828: LD_INT 35
18830: PPUSH
18831: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18835: LD_EXP 135
18839: PUSH
18840: LD_INT 4
18842: ARRAY
18843: PUSH
18844: LD_INT 4
18846: GREATEREQUAL
18847: IFFALSE 18828
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18849: LD_ADDR_VAR 0 2
18853: PUSH
18854: LD_INT 22
18856: PUSH
18857: LD_INT 4
18859: PUSH
18860: EMPTY
18861: LIST
18862: LIST
18863: PUSH
18864: LD_INT 2
18866: PUSH
18867: LD_INT 25
18869: PUSH
18870: LD_INT 1
18872: PUSH
18873: EMPTY
18874: LIST
18875: LIST
18876: PUSH
18877: LD_INT 25
18879: PUSH
18880: LD_INT 2
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: PUSH
18887: LD_INT 25
18889: PUSH
18890: LD_INT 3
18892: PUSH
18893: EMPTY
18894: LIST
18895: LIST
18896: PUSH
18897: LD_INT 25
18899: PUSH
18900: LD_INT 4
18902: PUSH
18903: EMPTY
18904: LIST
18905: LIST
18906: PUSH
18907: LD_INT 25
18909: PUSH
18910: LD_INT 5
18912: PUSH
18913: EMPTY
18914: LIST
18915: LIST
18916: PUSH
18917: EMPTY
18918: LIST
18919: LIST
18920: LIST
18921: LIST
18922: LIST
18923: LIST
18924: PUSH
18925: EMPTY
18926: LIST
18927: LIST
18928: PPUSH
18929: CALL_OW 69
18933: PUSH
18934: LD_EXP 58
18938: PUSH
18939: LD_EXP 59
18943: ADD
18944: DIFF
18945: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18946: LD_ADDR_VAR 0 3
18950: PUSH
18951: LD_VAR 0 2
18955: PPUSH
18956: LD_INT 26
18958: PUSH
18959: LD_INT 1
18961: PUSH
18962: EMPTY
18963: LIST
18964: LIST
18965: PPUSH
18966: CALL_OW 72
18970: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18971: LD_ADDR_VAR 0 2
18975: PUSH
18976: LD_VAR 0 2
18980: PUSH
18981: LD_VAR 0 3
18985: DIFF
18986: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18987: LD_ADDR_VAR 0 2
18991: PUSH
18992: LD_VAR 0 2
18996: PPUSH
18997: LD_INT 1
18999: PPUSH
19000: CALL 101128 0 2
19004: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
19005: LD_ADDR_VAR 0 3
19009: PUSH
19010: LD_VAR 0 3
19014: PPUSH
19015: LD_INT 1
19017: PPUSH
19018: CALL 101128 0 2
19022: ST_TO_ADDR
// for i = 1 to 4 do
19023: LD_ADDR_VAR 0 1
19027: PUSH
19028: DOUBLE
19029: LD_INT 1
19031: DEC
19032: ST_TO_ADDR
19033: LD_INT 4
19035: PUSH
19036: FOR_TO
19037: IFFALSE 19203
// begin if tmp2 then
19039: LD_VAR 0 3
19043: IFFALSE 19124
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
19045: LD_ADDR_EXP 18
19049: PUSH
19050: LD_EXP 18
19054: PPUSH
19055: LD_INT 1
19057: PPUSH
19058: LD_EXP 18
19062: PUSH
19063: LD_INT 1
19065: ARRAY
19066: PUSH
19067: LD_VAR 0 3
19071: PUSH
19072: LD_VAR 0 3
19076: ARRAY
19077: ADD
19078: PPUSH
19079: CALL_OW 1
19083: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
19084: LD_VAR 0 3
19088: PUSH
19089: LD_VAR 0 3
19093: ARRAY
19094: PPUSH
19095: LD_INT 1
19097: PPUSH
19098: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
19102: LD_ADDR_VAR 0 3
19106: PUSH
19107: LD_VAR 0 3
19111: PPUSH
19112: LD_VAR 0 3
19116: PPUSH
19117: CALL_OW 3
19121: ST_TO_ADDR
// end else
19122: GO 19201
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
19124: LD_ADDR_EXP 18
19128: PUSH
19129: LD_EXP 18
19133: PPUSH
19134: LD_INT 1
19136: PPUSH
19137: LD_EXP 18
19141: PUSH
19142: LD_INT 1
19144: ARRAY
19145: PUSH
19146: LD_VAR 0 2
19150: PUSH
19151: LD_VAR 0 2
19155: ARRAY
19156: ADD
19157: PPUSH
19158: CALL_OW 1
19162: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
19163: LD_VAR 0 2
19167: PUSH
19168: LD_VAR 0 2
19172: ARRAY
19173: PPUSH
19174: LD_INT 1
19176: PPUSH
19177: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
19181: LD_ADDR_VAR 0 2
19185: PUSH
19186: LD_VAR 0 2
19190: PPUSH
19191: LD_VAR 0 2
19195: PPUSH
19196: CALL_OW 3
19200: ST_TO_ADDR
// end ; end ;
19201: GO 19036
19203: POP
19204: POP
// if tmp2 then
19205: LD_VAR 0 3
19209: IFFALSE 19227
// tmp := tmp union tmp2 ;
19211: LD_ADDR_VAR 0 2
19215: PUSH
19216: LD_VAR 0 2
19220: PUSH
19221: LD_VAR 0 3
19225: UNION
19226: ST_TO_ADDR
// for i = 1 to 4 do
19227: LD_ADDR_VAR 0 1
19231: PUSH
19232: DOUBLE
19233: LD_INT 1
19235: DEC
19236: ST_TO_ADDR
19237: LD_INT 4
19239: PUSH
19240: FOR_TO
19241: IFFALSE 19290
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
19243: LD_ADDR_EXP 18
19247: PUSH
19248: LD_EXP 18
19252: PPUSH
19253: LD_INT 2
19255: PPUSH
19256: LD_EXP 18
19260: PUSH
19261: LD_INT 2
19263: ARRAY
19264: PUSH
19265: LD_VAR 0 2
19269: PUSH
19270: LD_VAR 0 2
19274: PUSH
19275: LD_VAR 0 1
19279: MINUS
19280: ARRAY
19281: ADD
19282: PPUSH
19283: CALL_OW 1
19287: ST_TO_ADDR
19288: GO 19240
19290: POP
19291: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
19292: LD_ADDR_EXP 116
19296: PUSH
19297: LD_EXP 116
19301: PPUSH
19302: LD_INT 4
19304: PPUSH
19305: LD_EXP 116
19309: PUSH
19310: LD_INT 4
19312: ARRAY
19313: PUSH
19314: LD_EXP 18
19318: PUSH
19319: LD_INT 1
19321: ARRAY
19322: DIFF
19323: PPUSH
19324: CALL_OW 1
19328: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
19329: LD_VAR 0 5
19333: PUSH
19334: LD_INT 1
19336: ARRAY
19337: PPUSH
19338: CALL_OW 313
19342: IFFALSE 19397
// begin for i in UnitsInside ( arm [ 1 ] ) do
19344: LD_ADDR_VAR 0 1
19348: PUSH
19349: LD_VAR 0 5
19353: PUSH
19354: LD_INT 1
19356: ARRAY
19357: PPUSH
19358: CALL_OW 313
19362: PUSH
19363: FOR_IN
19364: IFFALSE 19395
// begin ComExitBuilding ( i ) ;
19366: LD_VAR 0 1
19370: PPUSH
19371: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
19375: LD_VAR 0 1
19379: PPUSH
19380: LD_VAR 0 6
19384: PUSH
19385: LD_INT 1
19387: ARRAY
19388: PPUSH
19389: CALL_OW 180
// end ;
19393: GO 19363
19395: POP
19396: POP
// end ; wait ( 0 0$3 ) ;
19397: LD_INT 105
19399: PPUSH
19400: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19404: LD_ADDR_VAR 0 1
19408: PUSH
19409: LD_EXP 18
19413: PUSH
19414: LD_INT 1
19416: ARRAY
19417: PUSH
19418: FOR_IN
19419: IFFALSE 19526
// begin if IsInUnit ( i ) then
19421: LD_VAR 0 1
19425: PPUSH
19426: CALL_OW 310
19430: IFFALSE 19441
// ComExitBuilding ( i ) ;
19432: LD_VAR 0 1
19436: PPUSH
19437: CALL_OW 122
// if GetClass ( i ) <> 1 then
19441: LD_VAR 0 1
19445: PPUSH
19446: CALL_OW 257
19450: PUSH
19451: LD_INT 1
19453: NONEQUAL
19454: IFFALSE 19495
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19456: LD_VAR 0 1
19460: PPUSH
19461: LD_VAR 0 5
19465: PUSH
19466: LD_INT 1
19468: ARRAY
19469: PPUSH
19470: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19474: LD_VAR 0 1
19478: PPUSH
19479: LD_INT 1
19481: PPUSH
19482: CALL_OW 183
// AddComExitBuilding ( i ) ;
19486: LD_VAR 0 1
19490: PPUSH
19491: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19495: LD_VAR 0 1
19499: PPUSH
19500: LD_INT 60
19502: PPUSH
19503: LD_INT 94
19505: PPUSH
19506: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19510: LD_VAR 0 1
19514: PPUSH
19515: LD_EXP 58
19519: PPUSH
19520: CALL_OW 179
// end ;
19524: GO 19418
19526: POP
19527: POP
// wait ( 0 0$15 ) ;
19528: LD_INT 525
19530: PPUSH
19531: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19535: LD_EXP 58
19539: PPUSH
19540: LD_STRING D4-Pow-1
19542: PPUSH
19543: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19547: LD_ADDR_VAR 0 2
19551: PUSH
19552: LD_EXP 18
19556: PUSH
19557: LD_INT 1
19559: ARRAY
19560: PPUSH
19561: LD_INT 26
19563: PUSH
19564: LD_INT 1
19566: PUSH
19567: EMPTY
19568: LIST
19569: LIST
19570: PPUSH
19571: CALL_OW 72
19575: ST_TO_ADDR
// if tmp then
19576: LD_VAR 0 2
19580: IFFALSE 19598
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19582: LD_VAR 0 2
19586: PUSH
19587: LD_INT 1
19589: ARRAY
19590: PPUSH
19591: LD_STRING D4-Sol1-1
19593: PPUSH
19594: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19598: LD_EXP 58
19602: PPUSH
19603: LD_STRING D4-Pow-2
19605: PPUSH
19606: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19610: LD_ADDR_VAR 0 1
19614: PUSH
19615: DOUBLE
19616: LD_INT 1
19618: DEC
19619: ST_TO_ADDR
19620: LD_EXP 18
19624: PUSH
19625: LD_INT 1
19627: ARRAY
19628: PUSH
19629: FOR_TO
19630: IFFALSE 19723
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19632: LD_EXP 18
19636: PUSH
19637: LD_INT 1
19639: ARRAY
19640: PUSH
19641: LD_VAR 0 1
19645: ARRAY
19646: PPUSH
19647: LD_EXP 135
19651: PUSH
19652: LD_INT 4
19654: ARRAY
19655: PUSH
19656: LD_INT 1
19658: ARRAY
19659: PPUSH
19660: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19664: LD_ADDR_EXP 135
19668: PUSH
19669: LD_EXP 135
19673: PPUSH
19674: LD_INT 4
19676: PPUSH
19677: LD_EXP 135
19681: PUSH
19682: LD_INT 4
19684: ARRAY
19685: PPUSH
19686: LD_INT 1
19688: PPUSH
19689: CALL_OW 3
19693: PPUSH
19694: CALL_OW 1
19698: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19699: LD_INT 8
19701: PPUSH
19702: LD_EXP 18
19706: PUSH
19707: LD_INT 1
19709: ARRAY
19710: PUSH
19711: LD_VAR 0 1
19715: ARRAY
19716: PPUSH
19717: CALL_OW 471
// end ;
19721: GO 19629
19723: POP
19724: POP
// repeat wait ( 0 0$1 ) ;
19725: LD_INT 35
19727: PPUSH
19728: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19732: LD_EXP 18
19736: PUSH
19737: LD_INT 1
19739: ARRAY
19740: PPUSH
19741: LD_INT 55
19743: PUSH
19744: EMPTY
19745: LIST
19746: PPUSH
19747: CALL_OW 72
19751: PUSH
19752: LD_INT 4
19754: GREATEREQUAL
19755: IFFALSE 19725
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19757: LD_EXP 18
19761: PUSH
19762: LD_INT 1
19764: ARRAY
19765: PPUSH
19766: LD_INT 69
19768: PPUSH
19769: LD_INT 94
19771: PPUSH
19772: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19776: LD_EXP 18
19780: PUSH
19781: LD_INT 1
19783: ARRAY
19784: PPUSH
19785: LD_INT 82
19787: PPUSH
19788: LD_INT 83
19790: PPUSH
19791: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19795: LD_EXP 18
19799: PUSH
19800: LD_INT 1
19802: ARRAY
19803: PPUSH
19804: LD_INT 77
19806: PPUSH
19807: LD_INT 69
19809: PPUSH
19810: CALL_OW 174
// repeat wait ( 3 ) ;
19814: LD_INT 3
19816: PPUSH
19817: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19821: LD_ADDR_VAR 0 1
19825: PUSH
19826: LD_EXP 18
19830: PUSH
19831: LD_INT 1
19833: ARRAY
19834: PUSH
19835: FOR_IN
19836: IFFALSE 19972
// begin if GetLives ( i ) < 990 then
19838: LD_VAR 0 1
19842: PPUSH
19843: CALL_OW 256
19847: PUSH
19848: LD_INT 990
19850: LESS
19851: IFFALSE 19865
// SetLives ( i , 1000 ) ;
19853: LD_VAR 0 1
19857: PPUSH
19858: LD_INT 1000
19860: PPUSH
19861: CALL_OW 234
// if not IsInUnit ( i ) then
19865: LD_VAR 0 1
19869: PPUSH
19870: CALL_OW 310
19874: NOT
19875: IFFALSE 19970
// begin if not HasTask ( i ) then
19877: LD_VAR 0 1
19881: PPUSH
19882: CALL_OW 314
19886: NOT
19887: IFFALSE 19904
// ComMoveXY ( i , 64 , 93 ) ;
19889: LD_VAR 0 1
19893: PPUSH
19894: LD_INT 64
19896: PPUSH
19897: LD_INT 93
19899: PPUSH
19900: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19904: LD_VAR 0 4
19908: NOT
19909: PUSH
19910: LD_VAR 0 1
19914: PPUSH
19915: CALL_OW 258
19919: PUSH
19920: LD_INT 1
19922: EQUAL
19923: AND
19924: IFFALSE 19970
// begin retreat := true ;
19926: LD_ADDR_VAR 0 4
19930: PUSH
19931: LD_INT 1
19933: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19934: LD_VAR 0 1
19938: PPUSH
19939: LD_INT 2
19941: PPUSH
19942: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19946: LD_VAR 0 1
19950: PPUSH
19951: LD_STRING D4a-Sol1-1
19953: PPUSH
19954: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19958: LD_EXP 58
19962: PPUSH
19963: LD_STRING D4a-Pow-1
19965: PPUSH
19966: CALL_OW 88
// end ; end ; end ;
19970: GO 19835
19972: POP
19973: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19974: LD_EXP 18
19978: PUSH
19979: LD_INT 1
19981: ARRAY
19982: PPUSH
19983: LD_INT 95
19985: PUSH
19986: LD_INT 9
19988: PUSH
19989: EMPTY
19990: LIST
19991: LIST
19992: PUSH
19993: LD_INT 3
19995: PUSH
19996: LD_INT 55
19998: PUSH
19999: EMPTY
20000: LIST
20001: PUSH
20002: EMPTY
20003: LIST
20004: LIST
20005: PUSH
20006: EMPTY
20007: LIST
20008: LIST
20009: PPUSH
20010: CALL_OW 72
20014: PUSH
20015: LD_INT 4
20017: GREATEREQUAL
20018: IFFALSE 19814
// for i in powellSquadAttack [ 1 ] do
20020: LD_ADDR_VAR 0 1
20024: PUSH
20025: LD_EXP 18
20029: PUSH
20030: LD_INT 1
20032: ARRAY
20033: PUSH
20034: FOR_IN
20035: IFFALSE 20171
// begin if GetTag ( i ) = 2 then
20037: LD_VAR 0 1
20041: PPUSH
20042: CALL_OW 110
20046: PUSH
20047: LD_INT 2
20049: EQUAL
20050: IFFALSE 20112
// begin ComMoveXY ( i , 60 , 94 ) ;
20052: LD_VAR 0 1
20056: PPUSH
20057: LD_INT 60
20059: PPUSH
20060: LD_INT 94
20062: PPUSH
20063: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
20067: LD_VAR 0 1
20071: PPUSH
20072: LD_EXP 58
20076: PPUSH
20077: CALL_OW 179
// wait ( 0 0$3 ) ;
20081: LD_INT 105
20083: PPUSH
20084: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
20088: LD_VAR 0 1
20092: PPUSH
20093: LD_STRING D4a-Sol1-2
20095: PPUSH
20096: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
20100: LD_EXP 58
20104: PPUSH
20105: LD_STRING D4a-Pow-2
20107: PPUSH
20108: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
20112: LD_VAR 0 1
20116: PPUSH
20117: LD_INT 0
20119: PPUSH
20120: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
20124: LD_ADDR_EXP 116
20128: PUSH
20129: LD_EXP 116
20133: PPUSH
20134: LD_INT 4
20136: PPUSH
20137: LD_EXP 116
20141: PUSH
20142: LD_INT 4
20144: ARRAY
20145: PUSH
20146: LD_VAR 0 1
20150: UNION
20151: PPUSH
20152: CALL_OW 1
20156: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
20157: LD_INT 8
20159: PPUSH
20160: LD_VAR 0 1
20164: PPUSH
20165: CALL_OW 472
// end ;
20169: GO 20034
20171: POP
20172: POP
// wait ( 4 4$00 ) ;
20173: LD_INT 8400
20175: PPUSH
20176: CALL_OW 67
// uc_side := 6 ;
20180: LD_ADDR_OWVAR 20
20184: PUSH
20185: LD_INT 6
20187: ST_TO_ADDR
// uc_nation := 3 ;
20188: LD_ADDR_OWVAR 21
20192: PUSH
20193: LD_INT 3
20195: ST_TO_ADDR
// ru := [ ] ;
20196: LD_ADDR_VAR 0 7
20200: PUSH
20201: EMPTY
20202: ST_TO_ADDR
// for i = 1 to 4 do
20203: LD_ADDR_VAR 0 1
20207: PUSH
20208: DOUBLE
20209: LD_INT 1
20211: DEC
20212: ST_TO_ADDR
20213: LD_INT 4
20215: PUSH
20216: FOR_TO
20217: IFFALSE 20318
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
20219: LD_INT 22
20221: PPUSH
20222: LD_INT 1
20224: PPUSH
20225: LD_INT 3
20227: PPUSH
20228: LD_INT 43
20230: PUSH
20231: LD_INT 44
20233: PUSH
20234: EMPTY
20235: LIST
20236: LIST
20237: PUSH
20238: LD_INT 1
20240: PPUSH
20241: LD_INT 2
20243: PPUSH
20244: CALL_OW 12
20248: ARRAY
20249: PPUSH
20250: LD_INT 89
20252: PPUSH
20253: CALL 70749 0 5
// un := CreateVehicle ;
20257: LD_ADDR_VAR 0 8
20261: PUSH
20262: CALL_OW 45
20266: ST_TO_ADDR
// SetDir ( un , 4 ) ;
20267: LD_VAR 0 8
20271: PPUSH
20272: LD_INT 4
20274: PPUSH
20275: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
20279: LD_VAR 0 8
20283: PPUSH
20284: LD_INT 136
20286: PPUSH
20287: LD_INT 90
20289: PPUSH
20290: LD_INT 8
20292: PPUSH
20293: LD_INT 0
20295: PPUSH
20296: CALL_OW 50
// ru := ru ^ un ;
20300: LD_ADDR_VAR 0 7
20304: PUSH
20305: LD_VAR 0 7
20309: PUSH
20310: LD_VAR 0 8
20314: ADD
20315: ST_TO_ADDR
// end ;
20316: GO 20216
20318: POP
20319: POP
// if ru then
20320: LD_VAR 0 7
20324: IFFALSE 20341
// ComAgressiveMove ( ru , 80 , 92 ) ;
20326: LD_VAR 0 7
20330: PPUSH
20331: LD_INT 80
20333: PPUSH
20334: LD_INT 92
20336: PPUSH
20337: CALL_OW 114
// wait ( 8 8$00 ) ;
20341: LD_INT 16800
20343: PPUSH
20344: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
20348: LD_INT 4
20350: PPUSH
20351: LD_INT 3
20353: PUSH
20354: LD_INT 1
20356: PUSH
20357: LD_INT 1
20359: PUSH
20360: LD_INT 5
20362: PUSH
20363: EMPTY
20364: LIST
20365: LIST
20366: LIST
20367: LIST
20368: PUSH
20369: LD_INT 4
20371: PUSH
20372: LD_INT 1
20374: PUSH
20375: LD_INT 1
20377: PUSH
20378: LD_INT 6
20380: PUSH
20381: EMPTY
20382: LIST
20383: LIST
20384: LIST
20385: LIST
20386: PUSH
20387: LD_INT 4
20389: PUSH
20390: LD_INT 1
20392: PUSH
20393: LD_INT 1
20395: PUSH
20396: LD_INT 7
20398: PUSH
20399: EMPTY
20400: LIST
20401: LIST
20402: LIST
20403: LIST
20404: PUSH
20405: LD_INT 3
20407: PUSH
20408: LD_INT 1
20410: PUSH
20411: LD_INT 1
20413: PUSH
20414: LD_INT 7
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: PUSH
20423: LD_INT 3
20425: PUSH
20426: LD_INT 1
20428: PUSH
20429: LD_INT 1
20431: PUSH
20432: LD_INT 5
20434: PUSH
20435: EMPTY
20436: LIST
20437: LIST
20438: LIST
20439: LIST
20440: PUSH
20441: EMPTY
20442: LIST
20443: LIST
20444: LIST
20445: LIST
20446: LIST
20447: PPUSH
20448: CALL 59431 0 2
// missionStage := 4 ;
20452: LD_ADDR_EXP 15
20456: PUSH
20457: LD_INT 4
20459: ST_TO_ADDR
// end ;
20460: PPOPN 8
20462: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20463: LD_EXP 15
20467: PUSH
20468: LD_INT 4
20470: EQUAL
20471: PUSH
20472: LD_INT 22
20474: PUSH
20475: LD_INT 4
20477: PUSH
20478: EMPTY
20479: LIST
20480: LIST
20481: PUSH
20482: LD_INT 21
20484: PUSH
20485: LD_INT 2
20487: PUSH
20488: EMPTY
20489: LIST
20490: LIST
20491: PUSH
20492: EMPTY
20493: LIST
20494: LIST
20495: PPUSH
20496: CALL_OW 69
20500: PUSH
20501: LD_INT 5
20503: GREATEREQUAL
20504: AND
20505: IFFALSE 24626
20507: GO 20509
20509: DISABLE
20510: LD_INT 0
20512: PPUSH
20513: PPUSH
20514: PPUSH
20515: PPUSH
20516: PPUSH
20517: PPUSH
20518: PPUSH
20519: PPUSH
20520: PPUSH
20521: PPUSH
20522: PPUSH
20523: PPUSH
20524: PPUSH
// begin missionStage := 5 ;
20525: LD_ADDR_EXP 15
20529: PUSH
20530: LD_INT 5
20532: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20533: LD_ADDR_VAR 0 10
20537: PUSH
20538: LD_INT 22
20540: PUSH
20541: LD_INT 4
20543: PUSH
20544: EMPTY
20545: LIST
20546: LIST
20547: PUSH
20548: LD_INT 2
20550: PUSH
20551: LD_INT 30
20553: PUSH
20554: LD_INT 4
20556: PUSH
20557: EMPTY
20558: LIST
20559: LIST
20560: PUSH
20561: LD_INT 30
20563: PUSH
20564: LD_INT 5
20566: PUSH
20567: EMPTY
20568: LIST
20569: LIST
20570: PUSH
20571: EMPTY
20572: LIST
20573: LIST
20574: LIST
20575: PUSH
20576: EMPTY
20577: LIST
20578: LIST
20579: PPUSH
20580: CALL_OW 69
20584: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20585: LD_ADDR_VAR 0 6
20589: PUSH
20590: LD_INT 22
20592: PUSH
20593: LD_INT 4
20595: PUSH
20596: EMPTY
20597: LIST
20598: LIST
20599: PUSH
20600: LD_INT 21
20602: PUSH
20603: LD_INT 1
20605: PUSH
20606: EMPTY
20607: LIST
20608: LIST
20609: PUSH
20610: LD_INT 3
20612: PUSH
20613: LD_INT 25
20615: PUSH
20616: LD_INT 16
20618: PUSH
20619: EMPTY
20620: LIST
20621: LIST
20622: PUSH
20623: EMPTY
20624: LIST
20625: LIST
20626: PUSH
20627: LD_INT 3
20629: PUSH
20630: LD_INT 25
20632: PUSH
20633: LD_INT 12
20635: PUSH
20636: EMPTY
20637: LIST
20638: LIST
20639: PUSH
20640: EMPTY
20641: LIST
20642: LIST
20643: PUSH
20644: EMPTY
20645: LIST
20646: LIST
20647: LIST
20648: LIST
20649: PPUSH
20650: CALL_OW 69
20654: PUSH
20655: LD_EXP 58
20659: DIFF
20660: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20661: LD_ADDR_VAR 0 9
20665: PUSH
20666: LD_INT 22
20668: PUSH
20669: LD_INT 4
20671: PUSH
20672: EMPTY
20673: LIST
20674: LIST
20675: PUSH
20676: LD_INT 30
20678: PUSH
20679: LD_INT 3
20681: PUSH
20682: EMPTY
20683: LIST
20684: LIST
20685: PUSH
20686: EMPTY
20687: LIST
20688: LIST
20689: PPUSH
20690: CALL_OW 69
20694: PUSH
20695: LD_INT 1
20697: ARRAY
20698: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20699: LD_INT 35
20701: PPUSH
20702: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20706: LD_EXP 135
20710: PUSH
20711: LD_INT 4
20713: ARRAY
20714: PUSH
20715: LD_INT 5
20717: GREATEREQUAL
20718: PUSH
20719: LD_EXP 135
20723: PUSH
20724: LD_INT 4
20726: ARRAY
20727: PPUSH
20728: LD_INT 58
20730: PUSH
20731: EMPTY
20732: LIST
20733: PPUSH
20734: CALL_OW 72
20738: PUSH
20739: LD_INT 5
20741: GREATEREQUAL
20742: AND
20743: IFFALSE 20699
// powellAllowRetreat := false ;
20745: LD_ADDR_EXP 19
20749: PUSH
20750: LD_INT 0
20752: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20753: LD_INT 700
20755: PPUSH
20756: CALL_OW 67
// activeAttacks := false ;
20760: LD_ADDR_EXP 16
20764: PUSH
20765: LD_INT 0
20767: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20768: LD_INT 35
20770: PPUSH
20771: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20775: LD_INT 22
20777: PUSH
20778: LD_INT 6
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: PPUSH
20785: CALL_OW 69
20789: PUSH
20790: LD_INT 0
20792: EQUAL
20793: IFFALSE 20768
// tmp := mc_vehicles [ 4 ] ;
20795: LD_ADDR_VAR 0 3
20799: PUSH
20800: LD_EXP 135
20804: PUSH
20805: LD_INT 4
20807: ARRAY
20808: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20809: LD_ADDR_VAR 0 1
20813: PUSH
20814: DOUBLE
20815: LD_INT 1
20817: DEC
20818: ST_TO_ADDR
20819: LD_EXP 18
20823: PUSH
20824: FOR_TO
20825: IFFALSE 21086
// begin for j in powellSquadAttack [ i ] do
20827: LD_ADDR_VAR 0 2
20831: PUSH
20832: LD_EXP 18
20836: PUSH
20837: LD_VAR 0 1
20841: ARRAY
20842: PUSH
20843: FOR_IN
20844: IFFALSE 21082
// begin forces := forces diff j ;
20846: LD_ADDR_VAR 0 6
20850: PUSH
20851: LD_VAR 0 6
20855: PUSH
20856: LD_VAR 0 2
20860: DIFF
20861: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20862: LD_VAR 0 2
20866: PPUSH
20867: LD_INT 1
20869: PPUSH
20870: CALL_OW 109
// wait ( 0 0$2 ) ;
20874: LD_INT 70
20876: PPUSH
20877: CALL_OW 67
// if IsInUnit ( j ) then
20881: LD_VAR 0 2
20885: PPUSH
20886: CALL_OW 310
20890: IFFALSE 20901
// ComExitBuilding ( j ) ;
20892: LD_VAR 0 2
20896: PPUSH
20897: CALL_OW 122
// if GetClass ( j ) <> 1 then
20901: LD_VAR 0 2
20905: PPUSH
20906: CALL_OW 257
20910: PUSH
20911: LD_INT 1
20913: NONEQUAL
20914: IFFALSE 20994
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20916: LD_VAR 0 10
20920: PUSH
20921: LD_INT 1
20923: ARRAY
20924: PPUSH
20925: CALL_OW 313
20929: PUSH
20930: LD_INT 5
20932: GREATEREQUAL
20933: IFFALSE 20955
// AddComEnterUnit ( j , arm [ 2 ] ) else
20935: LD_VAR 0 2
20939: PPUSH
20940: LD_VAR 0 10
20944: PUSH
20945: LD_INT 2
20947: ARRAY
20948: PPUSH
20949: CALL_OW 180
20953: GO 20973
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20955: LD_VAR 0 2
20959: PPUSH
20960: LD_VAR 0 10
20964: PUSH
20965: LD_INT 1
20967: ARRAY
20968: PPUSH
20969: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20973: LD_VAR 0 2
20977: PPUSH
20978: LD_INT 1
20980: PPUSH
20981: CALL_OW 183
// AddComExitBuilding ( j ) ;
20985: LD_VAR 0 2
20989: PPUSH
20990: CALL_OW 182
// end ; if i = 2 then
20994: LD_VAR 0 1
20998: PUSH
20999: LD_INT 2
21001: EQUAL
21002: IFFALSE 21019
// AddComMoveXY ( j , 61 , 93 ) ;
21004: LD_VAR 0 2
21008: PPUSH
21009: LD_INT 61
21011: PPUSH
21012: LD_INT 93
21014: PPUSH
21015: CALL_OW 171
// if i = 1 then
21019: LD_VAR 0 1
21023: PUSH
21024: LD_INT 1
21026: EQUAL
21027: IFFALSE 21080
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
21029: LD_VAR 0 2
21033: PPUSH
21034: LD_VAR 0 3
21038: PUSH
21039: LD_INT 1
21041: ARRAY
21042: PPUSH
21043: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
21047: LD_ADDR_VAR 0 3
21051: PUSH
21052: LD_VAR 0 3
21056: PPUSH
21057: LD_INT 1
21059: PPUSH
21060: CALL_OW 3
21064: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
21065: LD_VAR 0 2
21069: PPUSH
21070: LD_INT 69
21072: PPUSH
21073: LD_INT 94
21075: PPUSH
21076: CALL_OW 171
// end ; end ;
21080: GO 20843
21082: POP
21083: POP
// end ;
21084: GO 20824
21086: POP
21087: POP
// wait ( 0 0$55 ) ;
21088: LD_INT 1925
21090: PPUSH
21091: CALL_OW 67
// MC_Kill ( 4 ) ;
21095: LD_INT 4
21097: PPUSH
21098: CALL 35501 0 1
// tmp := UnitsInside ( fac ) ;
21102: LD_ADDR_VAR 0 3
21106: PUSH
21107: LD_VAR 0 9
21111: PPUSH
21112: CALL_OW 313
21116: ST_TO_ADDR
// if tmp then
21117: LD_VAR 0 3
21121: IFFALSE 21242
// for i in tmp do
21123: LD_ADDR_VAR 0 1
21127: PUSH
21128: LD_VAR 0 3
21132: PUSH
21133: FOR_IN
21134: IFFALSE 21240
// begin ComExitBuilding ( i ) ;
21136: LD_VAR 0 1
21140: PPUSH
21141: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
21145: LD_VAR 0 10
21149: PUSH
21150: LD_INT 2
21152: ARRAY
21153: PPUSH
21154: CALL_OW 313
21158: PUSH
21159: LD_INT 6
21161: LESS
21162: IFFALSE 21184
// AddComEnterUnit ( i , arm [ 2 ] ) else
21164: LD_VAR 0 1
21168: PPUSH
21169: LD_VAR 0 10
21173: PUSH
21174: LD_INT 2
21176: ARRAY
21177: PPUSH
21178: CALL_OW 180
21182: GO 21238
// if UnitsInside ( arm [ 1 ] ) < 6 then
21184: LD_VAR 0 10
21188: PUSH
21189: LD_INT 1
21191: ARRAY
21192: PPUSH
21193: CALL_OW 313
21197: PUSH
21198: LD_INT 6
21200: LESS
21201: IFFALSE 21223
// AddComEnterUnit ( i , arm [ 1 ] ) else
21203: LD_VAR 0 1
21207: PPUSH
21208: LD_VAR 0 10
21212: PUSH
21213: LD_INT 1
21215: ARRAY
21216: PPUSH
21217: CALL_OW 180
21221: GO 21238
// AddComMoveXY ( i , 37 , 68 ) ;
21223: LD_VAR 0 1
21227: PPUSH
21228: LD_INT 37
21230: PPUSH
21231: LD_INT 68
21233: PPUSH
21234: CALL_OW 171
// end ;
21238: GO 21133
21240: POP
21241: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
21242: LD_ADDR_VAR 0 11
21246: PUSH
21247: LD_VAR 0 6
21251: PPUSH
21252: LD_INT 26
21254: PUSH
21255: LD_INT 1
21257: PUSH
21258: EMPTY
21259: LIST
21260: LIST
21261: PPUSH
21262: CALL_OW 72
21266: PUSH
21267: LD_EXP 59
21271: DIFF
21272: ST_TO_ADDR
// if not speaker then
21273: LD_VAR 0 11
21277: NOT
21278: IFFALSE 21305
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
21280: LD_ADDR_VAR 0 11
21284: PUSH
21285: LD_VAR 0 6
21289: PPUSH
21290: LD_INT 26
21292: PUSH
21293: LD_INT 1
21295: PUSH
21296: EMPTY
21297: LIST
21298: LIST
21299: PPUSH
21300: CALL_OW 72
21304: ST_TO_ADDR
// if speaker then
21305: LD_VAR 0 11
21309: IFFALSE 21325
// speaker := speaker [ 1 ] ;
21311: LD_ADDR_VAR 0 11
21315: PUSH
21316: LD_VAR 0 11
21320: PUSH
21321: LD_INT 1
21323: ARRAY
21324: ST_TO_ADDR
// Video ( true ) ;
21325: LD_INT 1
21327: PPUSH
21328: CALL 102594 0 1
// CenterNowOnUnits ( Powell ) ;
21332: LD_EXP 58
21336: PPUSH
21337: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
21341: LD_ADDR_VAR 0 3
21345: PUSH
21346: LD_VAR 0 6
21350: PPUSH
21351: LD_INT 3
21353: PUSH
21354: LD_INT 25
21356: PUSH
21357: LD_INT 1
21359: PUSH
21360: EMPTY
21361: LIST
21362: LIST
21363: PUSH
21364: EMPTY
21365: LIST
21366: LIST
21367: PPUSH
21368: CALL_OW 72
21372: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
21373: LD_ADDR_VAR 0 12
21377: PUSH
21378: LD_INT 22
21380: PUSH
21381: LD_INT 4
21383: PUSH
21384: EMPTY
21385: LIST
21386: LIST
21387: PUSH
21388: LD_INT 30
21390: PUSH
21391: LD_INT 32
21393: PUSH
21394: EMPTY
21395: LIST
21396: LIST
21397: PUSH
21398: LD_INT 58
21400: PUSH
21401: EMPTY
21402: LIST
21403: PUSH
21404: EMPTY
21405: LIST
21406: LIST
21407: LIST
21408: PPUSH
21409: CALL_OW 69
21413: ST_TO_ADDR
// for i = 1 to 6 do
21414: LD_ADDR_VAR 0 1
21418: PUSH
21419: DOUBLE
21420: LD_INT 1
21422: DEC
21423: ST_TO_ADDR
21424: LD_INT 6
21426: PUSH
21427: FOR_TO
21428: IFFALSE 21569
// begin if IsInUnit ( tmp [ i ] ) then
21430: LD_VAR 0 3
21434: PUSH
21435: LD_VAR 0 1
21439: ARRAY
21440: PPUSH
21441: CALL_OW 310
21445: IFFALSE 21462
// ComExitBuilding ( tmp [ i ] ) ;
21447: LD_VAR 0 3
21451: PUSH
21452: LD_VAR 0 1
21456: ARRAY
21457: PPUSH
21458: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21462: LD_VAR 0 3
21466: PUSH
21467: LD_VAR 0 1
21471: ARRAY
21472: PPUSH
21473: LD_VAR 0 10
21477: PUSH
21478: LD_INT 1
21480: ARRAY
21481: PPUSH
21482: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21486: LD_VAR 0 3
21490: PUSH
21491: LD_VAR 0 1
21495: ARRAY
21496: PPUSH
21497: LD_INT 1
21499: PPUSH
21500: CALL_OW 183
// if emp_towers then
21504: LD_VAR 0 12
21508: IFFALSE 21567
// begin AddComExitBuilding ( tmp [ i ] ) ;
21510: LD_VAR 0 3
21514: PUSH
21515: LD_VAR 0 1
21519: ARRAY
21520: PPUSH
21521: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21525: LD_VAR 0 3
21529: PUSH
21530: LD_VAR 0 1
21534: ARRAY
21535: PPUSH
21536: LD_VAR 0 12
21540: PUSH
21541: LD_INT 1
21543: ARRAY
21544: PPUSH
21545: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21549: LD_ADDR_VAR 0 12
21553: PUSH
21554: LD_VAR 0 12
21558: PPUSH
21559: LD_INT 1
21561: PPUSH
21562: CALL_OW 3
21566: ST_TO_ADDR
// end ; end ;
21567: GO 21427
21569: POP
21570: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21571: LD_ADDR_VAR 0 3
21575: PUSH
21576: LD_EXP 18
21580: PUSH
21581: LD_INT 1
21583: ARRAY
21584: PUSH
21585: LD_EXP 18
21589: PUSH
21590: LD_INT 2
21592: ARRAY
21593: ADD
21594: PPUSH
21595: LD_INT 26
21597: PUSH
21598: LD_INT 1
21600: PUSH
21601: EMPTY
21602: LIST
21603: LIST
21604: PPUSH
21605: CALL_OW 72
21609: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21610: LD_ADDR_VAR 0 1
21614: PUSH
21615: LD_EXP 18
21619: PUSH
21620: LD_INT 2
21622: ARRAY
21623: PUSH
21624: FOR_IN
21625: IFFALSE 21643
// ComTurnUnit ( i , Powell ) ;
21627: LD_VAR 0 1
21631: PPUSH
21632: LD_EXP 58
21636: PPUSH
21637: CALL_OW 119
21641: GO 21624
21643: POP
21644: POP
// Say ( Powell , D5-Pow-1 ) ;
21645: LD_EXP 58
21649: PPUSH
21650: LD_STRING D5-Pow-1
21652: PPUSH
21653: CALL_OW 88
// if tmp then
21657: LD_VAR 0 3
21661: IFFALSE 21679
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21663: LD_VAR 0 3
21667: PUSH
21668: LD_INT 1
21670: ARRAY
21671: PPUSH
21672: LD_STRING D5-Sol2-1
21674: PPUSH
21675: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21679: LD_EXP 58
21683: PPUSH
21684: LD_STRING D5-Pow-2
21686: PPUSH
21687: CALL_OW 88
// if tmp > 1 then
21691: LD_VAR 0 3
21695: PUSH
21696: LD_INT 1
21698: GREATER
21699: IFFALSE 21717
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21701: LD_VAR 0 3
21705: PUSH
21706: LD_INT 2
21708: ARRAY
21709: PPUSH
21710: LD_STRING D5-Sol2-2
21712: PPUSH
21713: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21717: LD_EXP 58
21721: PPUSH
21722: LD_STRING D5-Pow-3
21724: PPUSH
21725: CALL_OW 88
// wait ( 0 0$1 ) ;
21729: LD_INT 35
21731: PPUSH
21732: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21736: LD_ADDR_VAR 0 3
21740: PUSH
21741: LD_EXP 18
21745: PUSH
21746: LD_INT 1
21748: ARRAY
21749: PUSH
21750: LD_EXP 18
21754: PUSH
21755: LD_INT 2
21757: ARRAY
21758: UNION
21759: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21760: LD_VAR 0 3
21764: PPUSH
21765: LD_INT 80
21767: PPUSH
21768: LD_INT 67
21770: PPUSH
21771: CALL_OW 114
// wait ( 0 0$2 ) ;
21775: LD_INT 70
21777: PPUSH
21778: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21782: LD_INT 79
21784: PPUSH
21785: LD_INT 72
21787: PPUSH
21788: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21792: LD_INT 35
21794: PPUSH
21795: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21799: LD_VAR 0 3
21803: PPUSH
21804: LD_INT 3
21806: PUSH
21807: LD_INT 24
21809: PUSH
21810: LD_INT 1000
21812: PUSH
21813: EMPTY
21814: LIST
21815: LIST
21816: PUSH
21817: EMPTY
21818: LIST
21819: LIST
21820: PPUSH
21821: CALL_OW 72
21825: IFFALSE 21792
// Say ( Powell , D5a-Pow-1 ) ;
21827: LD_EXP 58
21831: PPUSH
21832: LD_STRING D5a-Pow-1
21834: PPUSH
21835: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21839: LD_EXP 58
21843: PPUSH
21844: LD_STRING D5a-Pow-1a
21846: PPUSH
21847: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21851: LD_INT 10
21853: PPUSH
21854: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21858: LD_EXP 58
21862: PPUSH
21863: LD_STRING D5a-Pow-1b
21865: PPUSH
21866: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21870: LD_EXP 58
21874: PPUSH
21875: LD_STRING D5a-Pow-1c
21877: PPUSH
21878: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21882: LD_EXP 58
21886: PPUSH
21887: LD_STRING D5a-Pow-1d
21889: PPUSH
21890: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21894: LD_INT 35
21896: PPUSH
21897: CALL_OW 67
// if not HasTask ( tmp ) then
21901: LD_VAR 0 3
21905: PPUSH
21906: CALL_OW 314
21910: NOT
21911: IFFALSE 21928
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21913: LD_VAR 0 3
21917: PPUSH
21918: LD_INT 80
21920: PPUSH
21921: LD_INT 67
21923: PPUSH
21924: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21928: LD_VAR 0 3
21932: PPUSH
21933: LD_INT 24
21935: PUSH
21936: LD_INT 1
21938: PUSH
21939: EMPTY
21940: LIST
21941: LIST
21942: PPUSH
21943: CALL_OW 72
21947: NOT
21948: IFFALSE 21894
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21950: LD_ADDR_VAR 0 3
21954: PUSH
21955: LD_INT 22
21957: PUSH
21958: LD_INT 4
21960: PUSH
21961: EMPTY
21962: LIST
21963: LIST
21964: PUSH
21965: LD_INT 92
21967: PUSH
21968: LD_INT 60
21970: PUSH
21971: LD_INT 93
21973: PUSH
21974: LD_INT 10
21976: PUSH
21977: EMPTY
21978: LIST
21979: LIST
21980: LIST
21981: LIST
21982: PUSH
21983: LD_INT 3
21985: PUSH
21986: LD_INT 54
21988: PUSH
21989: EMPTY
21990: LIST
21991: PUSH
21992: EMPTY
21993: LIST
21994: LIST
21995: PUSH
21996: EMPTY
21997: LIST
21998: LIST
21999: LIST
22000: PPUSH
22001: CALL_OW 69
22005: PUSH
22006: LD_EXP 58
22010: DIFF
22011: ST_TO_ADDR
// if tmp then
22012: LD_VAR 0 3
22016: IFFALSE 22050
// for i in tmp do
22018: LD_ADDR_VAR 0 1
22022: PUSH
22023: LD_VAR 0 3
22027: PUSH
22028: FOR_IN
22029: IFFALSE 22048
// ComMoveXY ( i , 36 , 67 ) ;
22031: LD_VAR 0 1
22035: PPUSH
22036: LD_INT 36
22038: PPUSH
22039: LD_INT 67
22041: PPUSH
22042: CALL_OW 111
22046: GO 22028
22048: POP
22049: POP
// wait ( 0 0$3 ) ;
22050: LD_INT 105
22052: PPUSH
22053: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
22057: LD_VAR 0 11
22061: PPUSH
22062: LD_STRING D6-Sol3-1
22064: PPUSH
22065: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
22069: LD_EXP 58
22073: PPUSH
22074: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
22078: LD_EXP 58
22082: PPUSH
22083: LD_STRING D6-Pow-1
22085: PPUSH
22086: CALL_OW 88
// tmp := [ ] ;
22090: LD_ADDR_VAR 0 3
22094: PUSH
22095: EMPTY
22096: ST_TO_ADDR
// for i = 1 to 2 do
22097: LD_ADDR_VAR 0 1
22101: PUSH
22102: DOUBLE
22103: LD_INT 1
22105: DEC
22106: ST_TO_ADDR
22107: LD_INT 2
22109: PUSH
22110: FOR_TO
22111: IFFALSE 22225
// begin uc_side := 8 ;
22113: LD_ADDR_OWVAR 20
22117: PUSH
22118: LD_INT 8
22120: ST_TO_ADDR
// uc_nation := 2 ;
22121: LD_ADDR_OWVAR 21
22125: PUSH
22126: LD_INT 2
22128: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
22129: LD_INT 14
22131: PPUSH
22132: LD_INT 3
22134: PPUSH
22135: LD_INT 2
22137: PPUSH
22138: LD_INT 29
22140: PPUSH
22141: LD_INT 100
22143: PPUSH
22144: CALL 70749 0 5
// veh := CreateVehicle ;
22148: LD_ADDR_VAR 0 13
22152: PUSH
22153: CALL_OW 45
22157: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
22158: LD_VAR 0 13
22162: PPUSH
22163: LD_INT 4
22165: PPUSH
22166: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
22170: LD_VAR 0 13
22174: PPUSH
22175: LD_INT 99
22177: PPUSH
22178: LD_INT 83
22180: PPUSH
22181: LD_INT 6
22183: PPUSH
22184: LD_INT 0
22186: PPUSH
22187: CALL_OW 50
// wait ( 3 ) ;
22191: LD_INT 3
22193: PPUSH
22194: CALL_OW 67
// Connect ( veh ) ;
22198: LD_VAR 0 13
22202: PPUSH
22203: CALL 73842 0 1
// tmp := tmp ^ veh ;
22207: LD_ADDR_VAR 0 3
22211: PUSH
22212: LD_VAR 0 3
22216: PUSH
22217: LD_VAR 0 13
22221: ADD
22222: ST_TO_ADDR
// end ;
22223: GO 22110
22225: POP
22226: POP
// wait ( 0 0$1 ) ;
22227: LD_INT 35
22229: PPUSH
22230: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
22234: LD_INT 99
22236: PPUSH
22237: LD_INT 83
22239: PPUSH
22240: LD_INT 1
22242: PPUSH
22243: LD_INT 10
22245: PPUSH
22246: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
22250: LD_INT 99
22252: PPUSH
22253: LD_INT 83
22255: PPUSH
22256: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
22260: LD_VAR 0 11
22264: PPUSH
22265: LD_STRING D6-Sol3-2
22267: PPUSH
22268: CALL_OW 88
// async ;
22272: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
22273: LD_EXP 58
22277: PPUSH
22278: LD_STRING D6-Pow-2
22280: PPUSH
22281: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
22285: LD_VAR 0 3
22289: PUSH
22290: LD_INT 1
22292: ARRAY
22293: PPUSH
22294: LD_VAR 0 9
22298: PPUSH
22299: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
22303: LD_VAR 0 3
22307: PUSH
22308: LD_INT 2
22310: ARRAY
22311: PPUSH
22312: LD_INT 22
22314: PUSH
22315: LD_INT 4
22317: PUSH
22318: EMPTY
22319: LIST
22320: LIST
22321: PUSH
22322: LD_INT 21
22324: PUSH
22325: LD_INT 3
22327: PUSH
22328: EMPTY
22329: LIST
22330: LIST
22331: PUSH
22332: EMPTY
22333: LIST
22334: LIST
22335: PPUSH
22336: CALL_OW 69
22340: PPUSH
22341: LD_VAR 0 3
22345: PUSH
22346: LD_INT 2
22348: ARRAY
22349: PPUSH
22350: CALL_OW 74
22354: PPUSH
22355: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
22359: LD_EXP 58
22363: PPUSH
22364: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
22368: LD_INT 99
22370: PPUSH
22371: LD_INT 83
22373: PPUSH
22374: LD_INT 1
22376: PPUSH
22377: CALL_OW 331
// repeat wait ( 4 ) ;
22381: LD_INT 4
22383: PPUSH
22384: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
22388: LD_VAR 0 3
22392: PUSH
22393: LD_INT 1
22395: ARRAY
22396: PPUSH
22397: CALL_OW 256
22401: PUSH
22402: LD_INT 1000
22404: LESS
22405: IFFALSE 22423
// SetLives ( tmp [ 1 ] , 1000 ) ;
22407: LD_VAR 0 3
22411: PUSH
22412: LD_INT 1
22414: ARRAY
22415: PPUSH
22416: LD_INT 1000
22418: PPUSH
22419: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
22423: LD_INT 22
22425: PUSH
22426: LD_INT 4
22428: PUSH
22429: EMPTY
22430: LIST
22431: LIST
22432: PUSH
22433: LD_INT 30
22435: PUSH
22436: LD_INT 3
22438: PUSH
22439: EMPTY
22440: LIST
22441: LIST
22442: PUSH
22443: EMPTY
22444: LIST
22445: LIST
22446: PPUSH
22447: CALL_OW 69
22451: PUSH
22452: LD_INT 0
22454: EQUAL
22455: IFFALSE 22381
// skirmish := false ;
22457: LD_ADDR_EXP 114
22461: PUSH
22462: LD_INT 0
22464: ST_TO_ADDR
// sync ;
22465: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22466: LD_EXP 58
22470: PPUSH
22471: LD_STRING D6a-Pow-1
22473: PPUSH
22474: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22478: LD_VAR 0 11
22482: PPUSH
22483: LD_STRING D6a-Sol3-1
22485: PPUSH
22486: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22490: LD_EXP 58
22494: PPUSH
22495: LD_STRING D6a-Pow-2
22497: PPUSH
22498: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22502: LD_VAR 0 11
22506: PPUSH
22507: LD_STRING D6a-Sol3-2
22509: PPUSH
22510: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22514: LD_EXP 58
22518: PPUSH
22519: LD_STRING D6a-Pow-3
22521: PPUSH
22522: CALL_OW 88
// powellCenterCameraMode := true ;
22526: LD_ADDR_EXP 20
22530: PUSH
22531: LD_INT 1
22533: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22534: LD_ADDR_VAR 0 1
22538: PUSH
22539: LD_INT 22
22541: PUSH
22542: LD_INT 8
22544: PUSH
22545: EMPTY
22546: LIST
22547: LIST
22548: PUSH
22549: LD_INT 25
22551: PUSH
22552: LD_INT 2
22554: PUSH
22555: EMPTY
22556: LIST
22557: LIST
22558: PUSH
22559: EMPTY
22560: LIST
22561: LIST
22562: PPUSH
22563: CALL_OW 69
22567: PUSH
22568: FOR_IN
22569: IFFALSE 22624
// begin SetTag ( i , 1 ) ;
22571: LD_VAR 0 1
22575: PPUSH
22576: LD_INT 1
22578: PPUSH
22579: CALL_OW 109
// ComExitBuilding ( i ) ;
22583: LD_VAR 0 1
22587: PPUSH
22588: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22592: LD_VAR 0 1
22596: PPUSH
22597: LD_INT 35
22599: PPUSH
22600: LD_INT 6
22602: PPUSH
22603: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22607: LD_VAR 0 1
22611: PPUSH
22612: LD_INT 53
22614: PPUSH
22615: LD_INT 4
22617: PPUSH
22618: CALL_OW 171
// end ;
22622: GO 22568
22624: POP
22625: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22626: LD_ADDR_VAR 0 3
22630: PUSH
22631: LD_INT 22
22633: PUSH
22634: LD_INT 4
22636: PUSH
22637: EMPTY
22638: LIST
22639: LIST
22640: PUSH
22641: LD_INT 21
22643: PUSH
22644: LD_INT 2
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: PUSH
22651: LD_INT 3
22653: PUSH
22654: LD_INT 34
22656: PUSH
22657: LD_INT 12
22659: PUSH
22660: EMPTY
22661: LIST
22662: LIST
22663: PUSH
22664: EMPTY
22665: LIST
22666: LIST
22667: PUSH
22668: EMPTY
22669: LIST
22670: LIST
22671: LIST
22672: PPUSH
22673: CALL_OW 69
22677: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22678: LD_EXP 58
22682: PPUSH
22683: LD_VAR 0 3
22687: PPUSH
22688: LD_EXP 58
22692: PPUSH
22693: CALL_OW 74
22697: PPUSH
22698: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22702: LD_EXP 58
22706: PPUSH
22707: LD_INT 100
22709: PPUSH
22710: LD_INT 88
22712: PPUSH
22713: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22717: LD_EXP 58
22721: PPUSH
22722: LD_INT 100
22724: PPUSH
22725: LD_INT 75
22727: PPUSH
22728: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22732: LD_EXP 58
22736: PPUSH
22737: LD_INT 88
22739: PPUSH
22740: LD_INT 53
22742: PPUSH
22743: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22747: LD_INT 8
22749: PPUSH
22750: LD_EXP 58
22754: PPUSH
22755: CALL_OW 471
// repeat wait ( 3 ) ;
22759: LD_INT 3
22761: PPUSH
22762: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22766: LD_INT 22
22768: PUSH
22769: LD_INT 4
22771: PUSH
22772: EMPTY
22773: LIST
22774: LIST
22775: PUSH
22776: LD_INT 92
22778: PUSH
22779: LD_INT 100
22781: PUSH
22782: LD_INT 75
22784: PUSH
22785: LD_INT 6
22787: PUSH
22788: EMPTY
22789: LIST
22790: LIST
22791: LIST
22792: LIST
22793: PUSH
22794: EMPTY
22795: LIST
22796: LIST
22797: PPUSH
22798: CALL_OW 69
22802: IFFALSE 22759
// async ;
22804: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22805: LD_EXP 58
22809: PPUSH
22810: LD_STRING D6b-Pow-1
22812: PPUSH
22813: CALL_OW 88
// repeat wait ( 3 ) ;
22817: LD_INT 3
22819: PPUSH
22820: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22824: LD_EXP 58
22828: PPUSH
22829: CALL_OW 310
22833: PPUSH
22834: CALL_OW 256
22838: PUSH
22839: LD_INT 1000
22841: LESS
22842: IFFALSE 22861
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22844: LD_EXP 58
22848: PPUSH
22849: CALL_OW 310
22853: PPUSH
22854: LD_INT 1000
22856: PPUSH
22857: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22861: LD_EXP 58
22865: PPUSH
22866: CALL_OW 256
22870: PUSH
22871: LD_INT 1000
22873: LESS
22874: IFFALSE 22888
// SetLives ( Powell , 1000 ) ;
22876: LD_EXP 58
22880: PPUSH
22881: LD_INT 1000
22883: PPUSH
22884: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22888: LD_EXP 58
22892: PPUSH
22893: LD_EXP 63
22897: PPUSH
22898: CALL_OW 296
22902: PUSH
22903: LD_INT 5
22905: LESS
22906: PUSH
22907: LD_EXP 58
22911: PPUSH
22912: CALL_OW 310
22916: PPUSH
22917: LD_EXP 63
22921: PPUSH
22922: CALL_OW 296
22926: PUSH
22927: LD_INT 5
22929: LESS
22930: OR
22931: IFFALSE 22950
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22933: LD_EXP 58
22937: PPUSH
22938: CALL_OW 310
22942: PPUSH
22943: LD_INT 100
22945: PPUSH
22946: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22950: LD_EXP 58
22954: PPUSH
22955: CALL_OW 310
22959: NOT
22960: IFFALSE 22817
// DoNotAttack ( 8 , powellBomb ) ;
22962: LD_INT 8
22964: PPUSH
22965: LD_EXP 63
22969: PPUSH
22970: CALL_OW 471
// game_speed := 4 ;
22974: LD_ADDR_OWVAR 65
22978: PUSH
22979: LD_INT 4
22981: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22982: LD_EXP 58
22986: PPUSH
22987: LD_STRING D6b-Pow-1a
22989: PPUSH
22990: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22994: LD_EXP 58
22998: PPUSH
22999: LD_EXP 63
23003: PPUSH
23004: CALL_OW 180
// sync ;
23008: SYNC
// repeat wait ( 0 0$1 ) ;
23009: LD_INT 35
23011: PPUSH
23012: CALL_OW 67
// until IsInUnit ( Powell ) ;
23016: LD_EXP 58
23020: PPUSH
23021: CALL_OW 310
23025: IFFALSE 23009
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
23027: LD_INT 8
23029: PPUSH
23030: LD_EXP 58
23034: PPUSH
23035: CALL_OW 310
23039: PPUSH
23040: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
23044: LD_EXP 58
23048: PPUSH
23049: LD_INT 91
23051: PPUSH
23052: LD_INT 44
23054: PPUSH
23055: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23059: LD_EXP 58
23063: PPUSH
23064: LD_INT 96
23066: PPUSH
23067: LD_INT 44
23069: PPUSH
23070: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23074: LD_EXP 58
23078: PPUSH
23079: LD_INT 96
23081: PPUSH
23082: LD_INT 41
23084: PPUSH
23085: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23089: LD_EXP 58
23093: PPUSH
23094: LD_INT 92
23096: PPUSH
23097: LD_INT 39
23099: PPUSH
23100: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23104: LD_EXP 58
23108: PPUSH
23109: LD_INT 88
23111: PPUSH
23112: LD_INT 41
23114: PPUSH
23115: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23119: LD_EXP 58
23123: PPUSH
23124: LD_INT 91
23126: PPUSH
23127: LD_INT 44
23129: PPUSH
23130: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
23134: LD_EXP 58
23138: PPUSH
23139: LD_INT 96
23141: PPUSH
23142: LD_INT 44
23144: PPUSH
23145: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
23149: LD_EXP 58
23153: PPUSH
23154: LD_INT 96
23156: PPUSH
23157: LD_INT 41
23159: PPUSH
23160: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
23164: LD_EXP 58
23168: PPUSH
23169: LD_INT 92
23171: PPUSH
23172: LD_INT 39
23174: PPUSH
23175: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
23179: LD_EXP 58
23183: PPUSH
23184: LD_INT 88
23186: PPUSH
23187: LD_INT 41
23189: PPUSH
23190: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
23194: LD_EXP 58
23198: PPUSH
23199: LD_INT 91
23201: PPUSH
23202: LD_INT 44
23204: PPUSH
23205: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
23209: LD_EXP 58
23213: PPUSH
23214: LD_INT 93
23216: PPUSH
23217: LD_INT 39
23219: PPUSH
23220: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
23224: LD_EXP 58
23228: PPUSH
23229: LD_INT 93
23231: PPUSH
23232: LD_INT 36
23234: PPUSH
23235: CALL_OW 171
// wait ( 0 0$3.5 ) ;
23239: LD_INT 122
23241: PPUSH
23242: CALL_OW 67
// game_speed := 4 ;
23246: LD_ADDR_OWVAR 65
23250: PUSH
23251: LD_INT 4
23253: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
23254: LD_EXP 58
23258: PPUSH
23259: LD_STRING D6b-Pow-1b
23261: PPUSH
23262: CALL_OW 88
// tmp := [ ] ;
23266: LD_ADDR_VAR 0 3
23270: PUSH
23271: EMPTY
23272: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
23273: LD_ADDR_VAR 0 5
23277: PUSH
23278: LD_INT 78
23280: PUSH
23281: LD_INT 47
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: PUSH
23288: LD_INT 106
23290: PUSH
23291: LD_INT 53
23293: PUSH
23294: EMPTY
23295: LIST
23296: LIST
23297: PUSH
23298: EMPTY
23299: LIST
23300: LIST
23301: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
23302: LD_ADDR_VAR 0 1
23306: PUSH
23307: LD_INT 22
23309: PUSH
23310: LD_INT 8
23312: PUSH
23313: EMPTY
23314: LIST
23315: LIST
23316: PUSH
23317: LD_INT 21
23319: PUSH
23320: LD_INT 3
23322: PUSH
23323: EMPTY
23324: LIST
23325: LIST
23326: PUSH
23327: LD_INT 92
23329: PUSH
23330: LD_INT 90
23332: PUSH
23333: LD_INT 52
23335: PUSH
23336: LD_INT 12
23338: PUSH
23339: EMPTY
23340: LIST
23341: LIST
23342: LIST
23343: LIST
23344: PUSH
23345: EMPTY
23346: LIST
23347: LIST
23348: LIST
23349: PPUSH
23350: CALL_OW 69
23354: PUSH
23355: FOR_IN
23356: IFFALSE 23381
// tmp := tmp ^ UnitsInside ( i ) ;
23358: LD_ADDR_VAR 0 3
23362: PUSH
23363: LD_VAR 0 3
23367: PUSH
23368: LD_VAR 0 1
23372: PPUSH
23373: CALL_OW 313
23377: ADD
23378: ST_TO_ADDR
23379: GO 23355
23381: POP
23382: POP
// for i in tmp do
23383: LD_ADDR_VAR 0 1
23387: PUSH
23388: LD_VAR 0 3
23392: PUSH
23393: FOR_IN
23394: IFFALSE 23556
// begin dist := 9999 ;
23396: LD_ADDR_VAR 0 8
23400: PUSH
23401: LD_INT 9999
23403: ST_TO_ADDR
// _xy := [ ] ;
23404: LD_ADDR_VAR 0 7
23408: PUSH
23409: EMPTY
23410: ST_TO_ADDR
// SetTag ( i , 1 ) ;
23411: LD_VAR 0 1
23415: PPUSH
23416: LD_INT 1
23418: PPUSH
23419: CALL_OW 109
// ComExitBuilding ( i ) ;
23423: LD_VAR 0 1
23427: PPUSH
23428: CALL_OW 122
// for j in xy do
23432: LD_ADDR_VAR 0 2
23436: PUSH
23437: LD_VAR 0 5
23441: PUSH
23442: FOR_IN
23443: IFFALSE 23525
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
23445: LD_VAR 0 1
23449: PPUSH
23450: LD_VAR 0 2
23454: PUSH
23455: LD_INT 1
23457: ARRAY
23458: PPUSH
23459: LD_VAR 0 2
23463: PUSH
23464: LD_INT 2
23466: ARRAY
23467: PPUSH
23468: CALL_OW 297
23472: PUSH
23473: LD_VAR 0 8
23477: LESS
23478: IFFALSE 23523
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23480: LD_ADDR_VAR 0 8
23484: PUSH
23485: LD_VAR 0 1
23489: PPUSH
23490: LD_VAR 0 2
23494: PUSH
23495: LD_INT 1
23497: ARRAY
23498: PPUSH
23499: LD_VAR 0 2
23503: PUSH
23504: LD_INT 2
23506: ARRAY
23507: PPUSH
23508: CALL_OW 297
23512: ST_TO_ADDR
// _xy := j ;
23513: LD_ADDR_VAR 0 7
23517: PUSH
23518: LD_VAR 0 2
23522: ST_TO_ADDR
// end ;
23523: GO 23442
23525: POP
23526: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23527: LD_VAR 0 1
23531: PPUSH
23532: LD_VAR 0 7
23536: PUSH
23537: LD_INT 1
23539: ARRAY
23540: PPUSH
23541: LD_VAR 0 7
23545: PUSH
23546: LD_INT 2
23548: ARRAY
23549: PPUSH
23550: CALL_OW 171
// end ;
23554: GO 23393
23556: POP
23557: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23558: LD_ADDR_VAR 0 4
23562: PUSH
23563: LD_VAR 0 3
23567: PPUSH
23568: LD_INT 26
23570: PUSH
23571: LD_INT 1
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: PUSH
23578: LD_INT 25
23580: PUSH
23581: LD_INT 1
23583: PUSH
23584: EMPTY
23585: LIST
23586: LIST
23587: PUSH
23588: EMPTY
23589: LIST
23590: LIST
23591: PPUSH
23592: CALL_OW 72
23596: ST_TO_ADDR
// if tmp2 < 2 then
23597: LD_VAR 0 4
23601: PUSH
23602: LD_INT 2
23604: LESS
23605: IFFALSE 23674
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23607: LD_ADDR_VAR 0 4
23611: PUSH
23612: LD_INT 22
23614: PUSH
23615: LD_INT 8
23617: PUSH
23618: EMPTY
23619: LIST
23620: LIST
23621: PUSH
23622: LD_INT 26
23624: PUSH
23625: LD_INT 1
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: LD_INT 3
23634: PUSH
23635: LD_INT 25
23637: PUSH
23638: LD_INT 15
23640: PUSH
23641: EMPTY
23642: LIST
23643: LIST
23644: PUSH
23645: EMPTY
23646: LIST
23647: LIST
23648: PUSH
23649: EMPTY
23650: LIST
23651: LIST
23652: LIST
23653: PPUSH
23654: CALL_OW 69
23658: PUSH
23659: LD_EXP 60
23663: PUSH
23664: LD_EXP 61
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: DIFF
23673: ST_TO_ADDR
// if tmp2 then
23674: LD_VAR 0 4
23678: IFFALSE 23696
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23680: LD_VAR 0 4
23684: PUSH
23685: LD_INT 1
23687: ARRAY
23688: PPUSH
23689: LD_STRING D6b-ArSol1-1
23691: PPUSH
23692: CALL_OW 88
// async ;
23696: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23697: LD_EXP 58
23701: PPUSH
23702: LD_STRING D6b-Pow-2
23704: PPUSH
23705: CALL_OW 88
// wait ( 0 0$1 ) ;
23709: LD_INT 35
23711: PPUSH
23712: CALL_OW 67
// if tmp2 > 1 then
23716: LD_VAR 0 4
23720: PUSH
23721: LD_INT 1
23723: GREATER
23724: IFFALSE 23742
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23726: LD_VAR 0 4
23730: PUSH
23731: LD_INT 2
23733: ARRAY
23734: PPUSH
23735: LD_STRING D6b-ArSol2-1
23737: PPUSH
23738: CALL_OW 88
// sync ;
23742: SYNC
// repeat wait ( 5 ) ;
23743: LD_INT 5
23745: PPUSH
23746: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23750: LD_INT 93
23752: PPUSH
23753: LD_INT 36
23755: PPUSH
23756: CALL_OW 428
23760: PPUSH
23761: CALL_OW 255
23765: PUSH
23766: LD_INT 4
23768: EQUAL
23769: IFFALSE 23743
// DialogueOn ;
23771: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23775: LD_INT 10
23777: PPUSH
23778: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23782: LD_EXP 58
23786: PPUSH
23787: LD_STRING D6b-Pow-2a
23789: PPUSH
23790: CALL_OW 88
// DialogueOff ;
23794: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23798: LD_EXP 58
23802: PPUSH
23803: CALL_OW 310
23807: PPUSH
23808: LD_INT 332
23810: PPUSH
23811: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23815: LD_INT 93
23817: PPUSH
23818: LD_INT 35
23820: PPUSH
23821: LD_INT 1
23823: PPUSH
23824: LD_INT 6
23826: NEG
23827: PPUSH
23828: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23832: LD_INT 35
23834: PPUSH
23835: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23839: LD_INT 332
23841: PPUSH
23842: CALL_OW 256
23846: PUSH
23847: LD_INT 1000
23849: LESS
23850: PUSH
23851: LD_INT 332
23853: PPUSH
23854: CALL_OW 300
23858: AND
23859: IFFALSE 23871
// SetLives ( kozlov_fac , 0 ) ;
23861: LD_INT 332
23863: PPUSH
23864: LD_INT 0
23866: PPUSH
23867: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23871: LD_INT 332
23873: PPUSH
23874: CALL_OW 301
23878: PUSH
23879: LD_EXP 58
23883: PPUSH
23884: CALL_OW 301
23888: OR
23889: IFFALSE 23832
// game_speed := 4 ;
23891: LD_ADDR_OWVAR 65
23895: PUSH
23896: LD_INT 4
23898: ST_TO_ADDR
// powellCenterCameraMode := false ;
23899: LD_ADDR_EXP 20
23903: PUSH
23904: LD_INT 0
23906: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23907: LD_ADDR_VAR 0 1
23911: PUSH
23912: LD_VAR 0 3
23916: PUSH
23917: LD_INT 22
23919: PUSH
23920: LD_INT 8
23922: PUSH
23923: EMPTY
23924: LIST
23925: LIST
23926: PUSH
23927: LD_INT 25
23929: PUSH
23930: LD_INT 2
23932: PUSH
23933: EMPTY
23934: LIST
23935: LIST
23936: PUSH
23937: EMPTY
23938: LIST
23939: LIST
23940: PPUSH
23941: CALL_OW 69
23945: UNION
23946: PUSH
23947: FOR_IN
23948: IFFALSE 23964
// SetTag ( i , 0 ) ;
23950: LD_VAR 0 1
23954: PPUSH
23955: LD_INT 0
23957: PPUSH
23958: CALL_OW 109
23962: GO 23947
23964: POP
23965: POP
// wait ( 0 0$3 ) ;
23966: LD_INT 105
23968: PPUSH
23969: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23973: LD_INT 93
23975: PPUSH
23976: LD_INT 35
23978: PPUSH
23979: LD_INT 1
23981: PPUSH
23982: CALL_OW 331
// DialogueOn ;
23986: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23990: LD_VAR 0 11
23994: PPUSH
23995: LD_STRING D6c-Sol3-1
23997: PPUSH
23998: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
24002: LD_INT 10
24004: PPUSH
24005: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
24009: LD_EXP 39
24013: PPUSH
24014: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
24018: LD_EXP 39
24022: PPUSH
24023: LD_STRING D6c-JMM-1
24025: PPUSH
24026: CALL_OW 88
// if Cyrus then
24030: LD_EXP 45
24034: IFFALSE 24048
// Say ( Cyrus , D6c-Cyrus-1 ) ;
24036: LD_EXP 45
24040: PPUSH
24041: LD_STRING D6c-Cyrus-1
24043: PPUSH
24044: CALL_OW 88
// if Bobby then
24048: LD_EXP 44
24052: IFFALSE 24066
// Say ( Bobby , D6c-Bobby-1 ) ;
24054: LD_EXP 44
24058: PPUSH
24059: LD_STRING D6c-Bobby-1
24061: PPUSH
24062: CALL_OW 88
// if Cornel then
24066: LD_EXP 50
24070: IFFALSE 24084
// Say ( Cornel , D6c-Corn-1 ) ;
24072: LD_EXP 50
24076: PPUSH
24077: LD_STRING D6c-Corn-1
24079: PPUSH
24080: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
24084: LD_ADDR_VAR 0 4
24088: PUSH
24089: LD_INT 2
24091: PUSH
24092: LD_INT 22
24094: PUSH
24095: LD_INT 1
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: PUSH
24102: LD_INT 22
24104: PUSH
24105: LD_INT 4
24107: PUSH
24108: EMPTY
24109: LIST
24110: LIST
24111: PUSH
24112: EMPTY
24113: LIST
24114: LIST
24115: LIST
24116: PUSH
24117: LD_INT 26
24119: PUSH
24120: LD_INT 1
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: PUSH
24127: LD_INT 3
24129: PUSH
24130: LD_INT 25
24132: PUSH
24133: LD_INT 16
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: PUSH
24140: LD_INT 25
24142: PUSH
24143: LD_INT 12
24145: PUSH
24146: EMPTY
24147: LIST
24148: LIST
24149: PUSH
24150: EMPTY
24151: LIST
24152: LIST
24153: LIST
24154: PUSH
24155: EMPTY
24156: LIST
24157: LIST
24158: LIST
24159: PPUSH
24160: CALL_OW 69
24164: PUSH
24165: LD_VAR 0 11
24169: PUSH
24170: LD_EXP 39
24174: UNION
24175: PUSH
24176: LD_EXP 59
24180: UNION
24181: PUSH
24182: EMPTY
24183: LIST
24184: DIFF
24185: ST_TO_ADDR
// if tmp2 then
24186: LD_VAR 0 4
24190: IFFALSE 24208
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
24192: LD_VAR 0 4
24196: PUSH
24197: LD_INT 1
24199: ARRAY
24200: PPUSH
24201: LD_STRING D6c-Sol1-1
24203: PPUSH
24204: CALL_OW 88
// if Lisa then
24208: LD_EXP 42
24212: IFFALSE 24226
// Say ( Lisa , D6c-Lisa-1 ) ;
24214: LD_EXP 42
24218: PPUSH
24219: LD_STRING D6c-Lisa-1
24221: PPUSH
24222: CALL_OW 88
// if Gary then
24226: LD_EXP 51
24230: IFFALSE 24244
// Say ( Gary , D6c-Gary-1 ) ;
24232: LD_EXP 51
24236: PPUSH
24237: LD_STRING D6c-Gary-1
24239: PPUSH
24240: CALL_OW 88
// if Donaldson then
24244: LD_EXP 43
24248: IFFALSE 24262
// Say ( Donaldson , D6c-Don-1 ) ;
24250: LD_EXP 43
24254: PPUSH
24255: LD_STRING D6c-Don-1
24257: PPUSH
24258: CALL_OW 88
// if tmp2 > 1 then
24262: LD_VAR 0 4
24266: PUSH
24267: LD_INT 1
24269: GREATER
24270: IFFALSE 24288
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
24272: LD_VAR 0 4
24276: PUSH
24277: LD_INT 2
24279: ARRAY
24280: PPUSH
24281: LD_STRING D6c-Sol2-1
24283: PPUSH
24284: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
24288: LD_VAR 0 11
24292: PPUSH
24293: LD_STRING D6c-Sol3-2
24295: PPUSH
24296: CALL_OW 88
// dwait ( 0 0$1 ) ;
24300: LD_INT 35
24302: PPUSH
24303: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
24307: LD_EXP 39
24311: PPUSH
24312: LD_STRING D6c-JMM-2
24314: PPUSH
24315: CALL_OW 88
// DialogueOff ;
24319: CALL_OW 7
// Video ( false ) ;
24323: LD_INT 0
24325: PPUSH
24326: CALL 102594 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
24330: LD_INT 22
24332: PUSH
24333: LD_INT 4
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: PPUSH
24340: CALL_OW 69
24344: PPUSH
24345: LD_INT 1
24347: PPUSH
24348: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
24352: LD_INT 4
24354: PPUSH
24355: LD_INT 4
24357: PPUSH
24358: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
24362: LD_ADDR_VAR 0 1
24366: PUSH
24367: LD_INT 4
24369: PPUSH
24370: LD_INT 1
24372: PPUSH
24373: LD_INT 2
24375: PPUSH
24376: CALL 65948 0 3
24380: PUSH
24381: FOR_IN
24382: IFFALSE 24419
// if GetTech ( i , 1 ) <> state_researched then
24384: LD_VAR 0 1
24388: PPUSH
24389: LD_INT 1
24391: PPUSH
24392: CALL_OW 321
24396: PUSH
24397: LD_INT 2
24399: NONEQUAL
24400: IFFALSE 24417
// SetTech ( i , 1 , state_researched ) ;
24402: LD_VAR 0 1
24406: PPUSH
24407: LD_INT 1
24409: PPUSH
24410: LD_INT 2
24412: PPUSH
24413: CALL_OW 322
24417: GO 24381
24419: POP
24420: POP
// missionStage := 6 ;
24421: LD_ADDR_EXP 15
24425: PUSH
24426: LD_INT 6
24428: ST_TO_ADDR
// activeAttacks := true ;
24429: LD_ADDR_EXP 16
24433: PUSH
24434: LD_INT 1
24436: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
24437: LD_STRING M2
24439: PPUSH
24440: CALL_OW 337
// SaveForQuickRestart ;
24444: CALL_OW 22
// wait ( 0 0$40 ) ;
24448: LD_INT 1400
24450: PPUSH
24451: CALL_OW 67
// DialogueOn ;
24455: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
24459: LD_EXP 62
24463: PPUSH
24464: LD_STRING D7-Friend-1
24466: PPUSH
24467: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24471: LD_EXP 39
24475: PPUSH
24476: LD_STRING D7-JMM-1
24478: PPUSH
24479: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24483: LD_EXP 62
24487: PPUSH
24488: LD_STRING D7-Friend-2
24490: PPUSH
24491: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24495: LD_EXP 39
24499: PPUSH
24500: LD_STRING D7-JMM-2
24502: PPUSH
24503: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24507: LD_EXP 62
24511: PPUSH
24512: LD_STRING D7-Friend-3
24514: PPUSH
24515: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24519: LD_EXP 39
24523: PPUSH
24524: LD_STRING D7-JMM-3
24526: PPUSH
24527: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24531: LD_EXP 62
24535: PPUSH
24536: LD_STRING D7-Friend-4
24538: PPUSH
24539: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24543: LD_EXP 39
24547: PPUSH
24548: LD_STRING D7-JMM-4
24550: PPUSH
24551: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24555: LD_EXP 62
24559: PPUSH
24560: LD_STRING D7-Friend-5
24562: PPUSH
24563: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24567: LD_EXP 39
24571: PPUSH
24572: LD_STRING D7-JMM-5
24574: PPUSH
24575: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24579: LD_EXP 62
24583: PPUSH
24584: LD_STRING D7-Friend-6
24586: PPUSH
24587: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24591: LD_EXP 39
24595: PPUSH
24596: LD_STRING D7-JMM-6
24598: PPUSH
24599: CALL_OW 88
// DialogueOff ;
24603: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24607: LD_STRING Mlegion
24609: PPUSH
24610: CALL_OW 337
// skirmish := true ;
24614: LD_ADDR_EXP 114
24618: PUSH
24619: LD_INT 1
24621: ST_TO_ADDR
// RebuildKozlovFactory ;
24622: CALL 4892 0 0
// end ;
24626: PPOPN 13
24628: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24629: LD_EXP 20
24633: PUSH
24634: LD_EXP 58
24638: PPUSH
24639: CALL_OW 300
24643: AND
24644: IFFALSE 24686
24646: GO 24648
24648: DISABLE
// begin enable ;
24649: ENABLE
// if IsInUnit ( Powell ) then
24650: LD_EXP 58
24654: PPUSH
24655: CALL_OW 310
24659: IFFALSE 24677
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24661: LD_EXP 58
24665: PPUSH
24666: CALL_OW 310
24670: PPUSH
24671: CALL_OW 85
24675: GO 24686
// CenterOnUnits ( Powell ) ;
24677: LD_EXP 58
24681: PPUSH
24682: CALL_OW 85
// end ;
24686: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24687: LD_INT 22
24689: PUSH
24690: LD_INT 8
24692: PUSH
24693: EMPTY
24694: LIST
24695: LIST
24696: PUSH
24697: LD_INT 34
24699: PUSH
24700: LD_INT 48
24702: PUSH
24703: EMPTY
24704: LIST
24705: LIST
24706: PUSH
24707: EMPTY
24708: LIST
24709: LIST
24710: PPUSH
24711: CALL_OW 69
24715: IFFALSE 24989
24717: GO 24719
24719: DISABLE
24720: LD_INT 0
24722: PPUSH
24723: PPUSH
// begin if missionStage < 9 then
24724: LD_EXP 15
24728: PUSH
24729: LD_INT 9
24731: LESS
24732: IFFALSE 24742
// missionStage := 9 ;
24734: LD_ADDR_EXP 15
24738: PUSH
24739: LD_INT 9
24741: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24742: LD_ADDR_VAR 0 1
24746: PUSH
24747: LD_INT 22
24749: PUSH
24750: LD_INT 8
24752: PUSH
24753: EMPTY
24754: LIST
24755: LIST
24756: PUSH
24757: LD_INT 34
24759: PUSH
24760: LD_INT 48
24762: PUSH
24763: EMPTY
24764: LIST
24765: LIST
24766: PUSH
24767: EMPTY
24768: LIST
24769: LIST
24770: PPUSH
24771: CALL_OW 69
24775: PUSH
24776: LD_INT 1
24778: ARRAY
24779: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24780: LD_INT 175
24782: PPUSH
24783: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24787: LD_EXP 12
24791: PUSH
24792: LD_EXP 3
24796: PUSH
24797: LD_INT 0
24799: PUSH
24800: LD_INT 2
24802: PUSH
24803: EMPTY
24804: LIST
24805: LIST
24806: IN
24807: OR
24808: IFFALSE 24831
// target := [ 68 , 108 , 1 ] else
24810: LD_ADDR_VAR 0 2
24814: PUSH
24815: LD_INT 68
24817: PUSH
24818: LD_INT 108
24820: PUSH
24821: LD_INT 1
24823: PUSH
24824: EMPTY
24825: LIST
24826: LIST
24827: LIST
24828: ST_TO_ADDR
24829: GO 24850
// target := [ 181 , 88 , 2 ] ;
24831: LD_ADDR_VAR 0 2
24835: PUSH
24836: LD_INT 181
24838: PUSH
24839: LD_INT 88
24841: PUSH
24842: LD_INT 2
24844: PUSH
24845: EMPTY
24846: LIST
24847: LIST
24848: LIST
24849: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24850: LD_VAR 0 1
24854: PPUSH
24855: LD_VAR 0 2
24859: PUSH
24860: LD_INT 1
24862: ARRAY
24863: PPUSH
24864: LD_VAR 0 2
24868: PUSH
24869: LD_INT 2
24871: ARRAY
24872: PPUSH
24873: CALL_OW 176
// if target [ 3 ] = 1 then
24877: LD_VAR 0 2
24881: PUSH
24882: LD_INT 3
24884: ARRAY
24885: PUSH
24886: LD_INT 1
24888: EQUAL
24889: IFFALSE 24905
// SayRadio ( Kurt , D12-Kurt-1 ) else
24891: LD_EXP 60
24895: PPUSH
24896: LD_STRING D12-Kurt-1
24898: PPUSH
24899: CALL_OW 94
24903: GO 24929
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24905: LD_EXP 60
24909: PPUSH
24910: LD_STRING D12a-Kurt-1
24912: PPUSH
24913: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24917: LD_EXP 74
24921: PPUSH
24922: LD_STRING D12a-Roth-1
24924: PPUSH
24925: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24929: LD_INT 350
24931: PPUSH
24932: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24936: LD_VAR 0 1
24940: PPUSH
24941: LD_INT 22
24943: PUSH
24944: LD_INT 8
24946: PUSH
24947: EMPTY
24948: LIST
24949: LIST
24950: PUSH
24951: LD_INT 23
24953: PUSH
24954: LD_INT 2
24956: PUSH
24957: EMPTY
24958: LIST
24959: LIST
24960: PUSH
24961: LD_INT 30
24963: PUSH
24964: LD_INT 3
24966: PUSH
24967: EMPTY
24968: LIST
24969: LIST
24970: PUSH
24971: EMPTY
24972: LIST
24973: LIST
24974: LIST
24975: PPUSH
24976: CALL_OW 69
24980: PUSH
24981: LD_INT 1
24983: ARRAY
24984: PPUSH
24985: CALL_OW 228
// end ;
24989: PPOPN 2
24991: END
// every 0 0$1 trigger ( GetLives ( Kurt ) < 999 or FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 9 , 8 , 7 , 6 ] [ Difficulty ] ) and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) and FilterUnitsInArea ( legionBaseArea , [ f_side , 1 ] ) do var i , tmp , x ;
24992: LD_EXP 60
24996: PPUSH
24997: CALL_OW 256
25001: PUSH
25002: LD_INT 999
25004: LESS
25005: PUSH
25006: LD_INT 22
25008: PUSH
25009: LD_INT 8
25011: PUSH
25012: EMPTY
25013: LIST
25014: LIST
25015: PUSH
25016: LD_INT 21
25018: PUSH
25019: LD_INT 1
25021: PUSH
25022: EMPTY
25023: LIST
25024: LIST
25025: PUSH
25026: LD_INT 23
25028: PUSH
25029: LD_INT 2
25031: PUSH
25032: EMPTY
25033: LIST
25034: LIST
25035: PUSH
25036: EMPTY
25037: LIST
25038: LIST
25039: LIST
25040: PPUSH
25041: CALL_OW 69
25045: PUSH
25046: LD_INT 9
25048: PUSH
25049: LD_INT 8
25051: PUSH
25052: LD_INT 7
25054: PUSH
25055: LD_INT 6
25057: PUSH
25058: EMPTY
25059: LIST
25060: LIST
25061: LIST
25062: LIST
25063: PUSH
25064: LD_OWVAR 67
25068: ARRAY
25069: LESSEQUAL
25070: OR
25071: PUSH
25072: LD_INT 22
25074: PUSH
25075: LD_INT 8
25077: PUSH
25078: EMPTY
25079: LIST
25080: LIST
25081: PUSH
25082: LD_INT 34
25084: PUSH
25085: LD_INT 48
25087: PUSH
25088: EMPTY
25089: LIST
25090: LIST
25091: PUSH
25092: EMPTY
25093: LIST
25094: LIST
25095: PPUSH
25096: CALL_OW 69
25100: NOT
25101: AND
25102: PUSH
25103: LD_EXP 60
25107: PPUSH
25108: CALL_OW 302
25112: AND
25113: PUSH
25114: LD_INT 5
25116: PPUSH
25117: LD_INT 22
25119: PUSH
25120: LD_INT 1
25122: PUSH
25123: EMPTY
25124: LIST
25125: LIST
25126: PPUSH
25127: CALL_OW 70
25131: AND
25132: IFFALSE 25845
25134: GO 25136
25136: DISABLE
25137: LD_INT 0
25139: PPUSH
25140: PPUSH
25141: PPUSH
// begin legionDestroyed := true ;
25142: LD_ADDR_EXP 22
25146: PUSH
25147: LD_INT 1
25149: ST_TO_ADDR
// DialogueOn ;
25150: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
25154: LD_EXP 39
25158: PPUSH
25159: LD_STRING D13-JMM-1
25161: PPUSH
25162: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
25166: LD_EXP 60
25170: PPUSH
25171: LD_STRING D13-Kurt-1
25173: PPUSH
25174: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
25178: LD_EXP 39
25182: PPUSH
25183: LD_STRING D13-JMM-2
25185: PPUSH
25186: CALL_OW 88
// if FakeInfo then
25190: LD_EXP 12
25194: IFFALSE 25214
// begin Say ( Kurt , D13-Kurt-2 ) ;
25196: LD_EXP 60
25200: PPUSH
25201: LD_STRING D13-Kurt-2
25203: PPUSH
25204: CALL_OW 88
// DialogueOff ;
25208: CALL_OW 7
// exit ;
25212: GO 25845
// end ; if not KurtStatus then
25214: LD_EXP 3
25218: NOT
25219: IFFALSE 25235
// Say ( Kurt , D13-Kurt-2b ) else
25221: LD_EXP 60
25225: PPUSH
25226: LD_STRING D13-Kurt-2b
25228: PPUSH
25229: CALL_OW 88
25233: GO 25247
// Say ( Kurt , D13-Kurt-2a ) ;
25235: LD_EXP 60
25239: PPUSH
25240: LD_STRING D13-Kurt-2a
25242: PPUSH
25243: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
25247: LD_EXP 39
25251: PPUSH
25252: LD_STRING D13-JMM-3
25254: PPUSH
25255: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
25259: LD_EXP 60
25263: PPUSH
25264: LD_STRING D13-Kurt-3
25266: PPUSH
25267: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
25271: LD_EXP 39
25275: PPUSH
25276: LD_STRING D13-JMM-4
25278: PPUSH
25279: CALL_OW 88
// DialogueOff ;
25283: CALL_OW 7
// ChangeMissionObjectives ( MlegionOut ) ;
25287: LD_STRING MlegionOut
25289: PPUSH
25290: CALL_OW 337
// MC_Kill ( 3 ) ;
25294: LD_INT 3
25296: PPUSH
25297: CALL 35501 0 1
// KillUnit ( Kozlov ) ;
25301: LD_EXP 61
25305: PPUSH
25306: CALL_OW 66
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_not , [ f_type , b_turret ] ] ] ) do
25310: LD_ADDR_VAR 0 1
25314: PUSH
25315: LD_INT 22
25317: PUSH
25318: LD_INT 8
25320: PUSH
25321: EMPTY
25322: LIST
25323: LIST
25324: PUSH
25325: LD_INT 23
25327: PUSH
25328: LD_INT 3
25330: PUSH
25331: EMPTY
25332: LIST
25333: LIST
25334: PUSH
25335: LD_INT 3
25337: PUSH
25338: LD_INT 21
25340: PUSH
25341: LD_INT 33
25343: PUSH
25344: EMPTY
25345: LIST
25346: LIST
25347: PUSH
25348: EMPTY
25349: LIST
25350: LIST
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: LIST
25356: PPUSH
25357: CALL_OW 69
25361: PUSH
25362: FOR_IN
25363: IFFALSE 25376
// KillUnit ( i ) ;
25365: LD_VAR 0 1
25369: PPUSH
25370: CALL_OW 66
25374: GO 25362
25376: POP
25377: POP
// ChangeSideFog ( 8 , 1 ) ;
25378: LD_INT 8
25380: PPUSH
25381: LD_INT 1
25383: PPUSH
25384: CALL_OW 343
// tmp := FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) diff [ Kozlov , Kurt ] ;
25388: LD_ADDR_VAR 0 2
25392: PUSH
25393: LD_INT 22
25395: PUSH
25396: LD_INT 8
25398: PUSH
25399: EMPTY
25400: LIST
25401: LIST
25402: PUSH
25403: LD_INT 21
25405: PUSH
25406: LD_INT 1
25408: PUSH
25409: EMPTY
25410: LIST
25411: LIST
25412: PUSH
25413: EMPTY
25414: LIST
25415: LIST
25416: PPUSH
25417: CALL_OW 69
25421: PUSH
25422: LD_EXP 61
25426: PUSH
25427: LD_EXP 60
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: DIFF
25436: ST_TO_ADDR
// if tmp >= [ 6 , 5 , 4 , 3 ] [ Difficulty ] then
25437: LD_VAR 0 2
25441: PUSH
25442: LD_INT 6
25444: PUSH
25445: LD_INT 5
25447: PUSH
25448: LD_INT 4
25450: PUSH
25451: LD_INT 3
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: PUSH
25460: LD_OWVAR 67
25464: ARRAY
25465: GREATEREQUAL
25466: IFFALSE 25644
// begin x := [ 6 , 5 , 4 , 3 ] [ Difficulty ] ;
25468: LD_ADDR_VAR 0 3
25472: PUSH
25473: LD_INT 6
25475: PUSH
25476: LD_INT 5
25478: PUSH
25479: LD_INT 4
25481: PUSH
25482: LD_INT 3
25484: PUSH
25485: EMPTY
25486: LIST
25487: LIST
25488: LIST
25489: LIST
25490: PUSH
25491: LD_OWVAR 67
25495: ARRAY
25496: ST_TO_ADDR
// for i := tmp - ( x + 1 ) downto 1 do
25497: LD_ADDR_VAR 0 1
25501: PUSH
25502: DOUBLE
25503: LD_VAR 0 2
25507: PUSH
25508: LD_VAR 0 3
25512: PUSH
25513: LD_INT 1
25515: PLUS
25516: MINUS
25517: INC
25518: ST_TO_ADDR
25519: LD_INT 1
25521: PUSH
25522: FOR_DOWNTO
25523: IFFALSE 25640
// begin legionEscapeUnits := legionEscapeUnits ^ tmp [ i ] ;
25525: LD_ADDR_EXP 38
25529: PUSH
25530: LD_EXP 38
25534: PUSH
25535: LD_VAR 0 2
25539: PUSH
25540: LD_VAR 0 1
25544: ARRAY
25545: ADD
25546: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
25547: LD_VAR 0 2
25551: PUSH
25552: LD_VAR 0 1
25556: ARRAY
25557: PPUSH
25558: CALL_OW 310
25562: IFFALSE 25579
// ComExitBuilding ( tmp [ i ] ) ;
25564: LD_VAR 0 2
25568: PUSH
25569: LD_VAR 0 1
25573: ARRAY
25574: PPUSH
25575: CALL_OW 122
// if IsInUnit ( i ) then
25579: LD_VAR 0 1
25583: PPUSH
25584: CALL_OW 310
25588: IFFALSE 25605
// ComExitVehicle ( tmp [ i ] ) ;
25590: LD_VAR 0 2
25594: PUSH
25595: LD_VAR 0 1
25599: ARRAY
25600: PPUSH
25601: CALL_OW 121
// AddComMoveXY ( tmp [ i ] , 34 + rand ( 0 , 6 ) , 1 ) ;
25605: LD_VAR 0 2
25609: PUSH
25610: LD_VAR 0 1
25614: ARRAY
25615: PPUSH
25616: LD_INT 34
25618: PUSH
25619: LD_INT 0
25621: PPUSH
25622: LD_INT 6
25624: PPUSH
25625: CALL_OW 12
25629: PLUS
25630: PPUSH
25631: LD_INT 1
25633: PPUSH
25634: CALL_OW 171
// end ;
25638: GO 25522
25640: POP
25641: POP
// end else
25642: GO 25654
// x := tmp ;
25644: LD_ADDR_VAR 0 3
25648: PUSH
25649: LD_VAR 0 2
25653: ST_TO_ADDR
// for i := tmp downto tmp - x do
25654: LD_ADDR_VAR 0 1
25658: PUSH
25659: DOUBLE
25660: LD_VAR 0 2
25664: INC
25665: ST_TO_ADDR
25666: LD_VAR 0 2
25670: PUSH
25671: LD_VAR 0 3
25675: MINUS
25676: PUSH
25677: FOR_DOWNTO
25678: IFFALSE 25732
// begin if IsInUnit ( tmp [ i ] ) then
25680: LD_VAR 0 2
25684: PUSH
25685: LD_VAR 0 1
25689: ARRAY
25690: PPUSH
25691: CALL_OW 310
25695: IFFALSE 25712
// ComExitVehicle ( tmp [ i ] ) ;
25697: LD_VAR 0 2
25701: PUSH
25702: LD_VAR 0 1
25706: ARRAY
25707: PPUSH
25708: CALL_OW 121
// SetSide ( tmp [ i ] , 1 ) ;
25712: LD_VAR 0 2
25716: PUSH
25717: LD_VAR 0 1
25721: ARRAY
25722: PPUSH
25723: LD_INT 1
25725: PPUSH
25726: CALL_OW 235
// end ;
25730: GO 25677
25732: POP
25733: POP
// SetSide ( Kurt , 1 ) ;
25734: LD_EXP 60
25738: PPUSH
25739: LD_INT 1
25741: PPUSH
25742: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] ] ) , 1 ) ;
25746: LD_INT 22
25748: PUSH
25749: LD_INT 8
25751: PUSH
25752: EMPTY
25753: LIST
25754: LIST
25755: PUSH
25756: LD_INT 21
25758: PUSH
25759: LD_INT 3
25761: PUSH
25762: EMPTY
25763: LIST
25764: LIST
25765: PUSH
25766: EMPTY
25767: LIST
25768: LIST
25769: PPUSH
25770: CALL_OW 69
25774: PPUSH
25775: LD_INT 1
25777: PPUSH
25778: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
25782: LD_INT 8
25784: PPUSH
25785: LD_INT 1
25787: PPUSH
25788: LD_INT 1
25790: PPUSH
25791: LD_INT 1
25793: PPUSH
25794: CALL_OW 80
// wait ( 1 1$20 ) ;
25798: LD_INT 2800
25800: PPUSH
25801: CALL_OW 67
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
25805: LD_EXP 62
25809: PPUSH
25810: LD_INT 37
25812: PPUSH
25813: LD_INT 1
25815: PPUSH
25816: LD_INT 0
25818: PPUSH
25819: CALL_OW 48
// wait ( 0 0$1 ) ;
25823: LD_INT 35
25825: PPUSH
25826: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
25830: LD_EXP 62
25834: PPUSH
25835: LD_INT 60
25837: PPUSH
25838: LD_INT 95
25840: PPUSH
25841: CALL_OW 111
// end ;
25845: PPOPN 3
25847: END
// every 0 0$1 trigger not legionDestroyed and FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
25848: LD_EXP 22
25852: NOT
25853: PUSH
25854: LD_INT 22
25856: PUSH
25857: LD_INT 8
25859: PUSH
25860: EMPTY
25861: LIST
25862: LIST
25863: PUSH
25864: LD_INT 21
25866: PUSH
25867: LD_INT 1
25869: PUSH
25870: EMPTY
25871: LIST
25872: LIST
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: PPUSH
25878: CALL_OW 69
25882: PUSH
25883: LD_INT 0
25885: EQUAL
25886: AND
25887: IFFALSE 25907
25889: GO 25891
25891: DISABLE
// begin legionDestroyed := true ;
25892: LD_ADDR_EXP 22
25896: PUSH
25897: LD_INT 1
25899: ST_TO_ADDR
// ChangeMissionObjectives ( MlegionOut ) ;
25900: LD_STRING MlegionOut
25902: PPUSH
25903: CALL_OW 337
// end ;
25907: END
// every 0 0$1 trigger legionEscapeUnits do var i ;
25908: LD_EXP 38
25912: IFFALSE 25987
25914: GO 25916
25916: DISABLE
25917: LD_INT 0
25919: PPUSH
// begin enable ;
25920: ENABLE
// for i in legionEscapeUnits do
25921: LD_ADDR_VAR 0 1
25925: PUSH
25926: LD_EXP 38
25930: PUSH
25931: FOR_IN
25932: IFFALSE 25985
// begin if IsInArea ( i , legionEscapeArea ) then
25934: LD_VAR 0 1
25938: PPUSH
25939: LD_INT 31
25941: PPUSH
25942: CALL_OW 308
25946: IFFALSE 25959
// RemoveUnit ( i ) else
25948: LD_VAR 0 1
25952: PPUSH
25953: CALL_OW 64
25957: GO 25983
// if not HasTask ( i ) then
25959: LD_VAR 0 1
25963: PPUSH
25964: CALL_OW 314
25968: NOT
25969: IFFALSE 25983
// ComMoveToArea ( i , legionEscapeArea ) ;
25971: LD_VAR 0 1
25975: PPUSH
25976: LD_INT 31
25978: PPUSH
25979: CALL_OW 113
// end ;
25983: GO 25931
25985: POP
25986: POP
// end ;
25987: PPOPN 1
25989: END
// every 0 0$3 trigger See ( 1 , Friend ) do var dec ;
25990: LD_INT 1
25992: PPUSH
25993: LD_EXP 62
25997: PPUSH
25998: CALL_OW 292
26002: IFFALSE 26300
26004: GO 26006
26006: DISABLE
26007: LD_INT 0
26009: PPUSH
// begin wait ( 0 0$2 ) ;
26010: LD_INT 70
26012: PPUSH
26013: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
26017: LD_EXP 62
26021: PPUSH
26022: CALL_OW 87
// DialogueOn ;
26026: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
26030: LD_EXP 39
26034: PPUSH
26035: LD_STRING D14-JMM-1
26037: PPUSH
26038: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
26042: LD_EXP 62
26046: PPUSH
26047: LD_STRING D14-Friend-1
26049: PPUSH
26050: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
26054: LD_EXP 39
26058: PPUSH
26059: LD_STRING D14-JMM-2
26061: PPUSH
26062: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
26066: LD_EXP 62
26070: PPUSH
26071: LD_STRING D14-Friend-2
26073: PPUSH
26074: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
26078: LD_EXP 39
26082: PPUSH
26083: LD_STRING D14-JMM-3
26085: PPUSH
26086: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
26090: LD_EXP 62
26094: PPUSH
26095: LD_STRING D14-Friend-3
26097: PPUSH
26098: CALL_OW 88
// DialogueOff ;
26102: CALL_OW 7
// dec = Query ( Q14 ) ;
26106: LD_ADDR_VAR 0 1
26110: PUSH
26111: LD_STRING Q14
26113: PPUSH
26114: CALL_OW 97
26118: ST_TO_ADDR
// if dec = 1 then
26119: LD_VAR 0 1
26123: PUSH
26124: LD_INT 1
26126: EQUAL
26127: IFFALSE 26161
// begin DialogueOn ;
26129: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
26133: LD_EXP 39
26137: PPUSH
26138: LD_STRING D14a-JMM-1
26140: PPUSH
26141: CALL_OW 88
// DialogueOff ;
26145: CALL_OW 7
// SetSide ( Friend , 1 ) ;
26149: LD_EXP 62
26153: PPUSH
26154: LD_INT 1
26156: PPUSH
26157: CALL_OW 235
// end ; if dec = 2 then
26161: LD_VAR 0 1
26165: PUSH
26166: LD_INT 2
26168: EQUAL
26169: IFFALSE 26222
// begin DialogueOn ;
26171: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
26175: LD_EXP 39
26179: PPUSH
26180: LD_STRING D14b-JMM-1
26182: PPUSH
26183: CALL_OW 88
// DialogueOff ;
26187: CALL_OW 7
// wait ( 0 0$1 ) ;
26191: LD_INT 35
26193: PPUSH
26194: CALL_OW 67
// ComMoveXY ( Friend , 9 , 2 ) ;
26198: LD_EXP 62
26202: PPUSH
26203: LD_INT 9
26205: PPUSH
26206: LD_INT 2
26208: PPUSH
26209: CALL_OW 111
// AddComHold ( Friend ) ;
26213: LD_EXP 62
26217: PPUSH
26218: CALL_OW 200
// end ; if dec = 3 then
26222: LD_VAR 0 1
26226: PUSH
26227: LD_INT 3
26229: EQUAL
26230: IFFALSE 26300
// begin DialogueOn ;
26232: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
26236: LD_EXP 39
26240: PPUSH
26241: LD_STRING D14c-JMM-1
26243: PPUSH
26244: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
26248: LD_EXP 62
26252: PPUSH
26253: LD_STRING D14c-Friend-1
26255: PPUSH
26256: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
26260: LD_EXP 39
26264: PPUSH
26265: LD_STRING D14c-JMM-2
26267: PPUSH
26268: CALL_OW 88
// DialogueOff ;
26272: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
26276: LD_EXP 62
26280: PPUSH
26281: LD_INT 9
26283: PPUSH
26284: LD_INT 2
26286: PPUSH
26287: CALL_OW 111
// AddComHold ( Friend ) ;
26291: LD_EXP 62
26295: PPUSH
26296: CALL_OW 200
// end ; end ;
26300: PPOPN 1
26302: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
26303: LD_INT 9
26305: PPUSH
26306: LD_INT 2
26308: PPUSH
26309: CALL_OW 428
26313: PUSH
26314: LD_EXP 62
26318: EQUAL
26319: PUSH
26320: LD_EXP 62
26324: PPUSH
26325: CALL_OW 255
26329: PUSH
26330: LD_INT 8
26332: EQUAL
26333: AND
26334: IFFALSE 26348
26336: GO 26338
26338: DISABLE
// RemoveUnit ( Friend ) ;
26339: LD_EXP 62
26343: PPUSH
26344: CALL_OW 64
26348: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
26349: LD_EXP 14
26353: PUSH
26354: LD_INT 31500
26356: GREATEREQUAL
26357: PUSH
26358: LD_EXP 7
26362: AND
26363: PUSH
26364: LD_EXP 2
26368: AND
26369: IFFALSE 26799
26371: GO 26373
26373: DISABLE
26374: LD_INT 0
26376: PPUSH
26377: PPUSH
26378: PPUSH
// begin missionStage := 7 ;
26379: LD_ADDR_EXP 15
26383: PUSH
26384: LD_INT 7
26386: ST_TO_ADDR
// uc_side = 1 ;
26387: LD_ADDR_OWVAR 20
26391: PUSH
26392: LD_INT 1
26394: ST_TO_ADDR
// uc_nation = 1 ;
26395: LD_ADDR_OWVAR 21
26399: PUSH
26400: LD_INT 1
26402: ST_TO_ADDR
// for i = 1 to 5 do
26403: LD_ADDR_VAR 0 1
26407: PUSH
26408: DOUBLE
26409: LD_INT 1
26411: DEC
26412: ST_TO_ADDR
26413: LD_INT 5
26415: PUSH
26416: FOR_TO
26417: IFFALSE 26513
// begin vc_engine = 3 ;
26419: LD_ADDR_OWVAR 39
26423: PUSH
26424: LD_INT 3
26426: ST_TO_ADDR
// vc_control = 3 ;
26427: LD_ADDR_OWVAR 38
26431: PUSH
26432: LD_INT 3
26434: ST_TO_ADDR
// vc_chassis = 3 ;
26435: LD_ADDR_OWVAR 37
26439: PUSH
26440: LD_INT 3
26442: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26443: LD_ADDR_OWVAR 40
26447: PUSH
26448: LD_INT 5
26450: PUSH
26451: LD_INT 9
26453: PUSH
26454: LD_INT 7
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: LIST
26461: PUSH
26462: LD_INT 1
26464: PPUSH
26465: LD_INT 3
26467: PPUSH
26468: CALL_OW 12
26472: ARRAY
26473: ST_TO_ADDR
// veh = CreateVehicle ;
26474: LD_ADDR_VAR 0 2
26478: PUSH
26479: CALL_OW 45
26483: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26484: LD_VAR 0 2
26488: PPUSH
26489: LD_INT 1
26491: PPUSH
26492: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26496: LD_VAR 0 2
26500: PPUSH
26501: LD_INT 19
26503: PPUSH
26504: LD_INT 0
26506: PPUSH
26507: CALL_OW 49
// end ;
26511: GO 26416
26513: POP
26514: POP
// vc_engine = 3 ;
26515: LD_ADDR_OWVAR 39
26519: PUSH
26520: LD_INT 3
26522: ST_TO_ADDR
// vc_control = 1 ;
26523: LD_ADDR_OWVAR 38
26527: PUSH
26528: LD_INT 1
26530: ST_TO_ADDR
// vc_chassis = 3 ;
26531: LD_ADDR_OWVAR 37
26535: PUSH
26536: LD_INT 3
26538: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
26539: LD_ADDR_OWVAR 40
26543: PUSH
26544: LD_INT 5
26546: PUSH
26547: LD_INT 9
26549: PUSH
26550: LD_INT 7
26552: PUSH
26553: EMPTY
26554: LIST
26555: LIST
26556: LIST
26557: PUSH
26558: LD_INT 1
26560: PPUSH
26561: LD_INT 3
26563: PPUSH
26564: CALL_OW 12
26568: ARRAY
26569: ST_TO_ADDR
// vehG = CreateVehicle ;
26570: LD_ADDR_VAR 0 3
26574: PUSH
26575: CALL_OW 45
26579: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
26580: LD_VAR 0 3
26584: PPUSH
26585: LD_INT 1
26587: PPUSH
26588: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
26592: LD_VAR 0 3
26596: PPUSH
26597: LD_INT 19
26599: PPUSH
26600: LD_INT 0
26602: PPUSH
26603: CALL_OW 49
// if JMMGirl = 1 then
26607: LD_EXP 7
26611: PUSH
26612: LD_INT 1
26614: EQUAL
26615: IFFALSE 26671
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
26617: LD_ADDR_EXP 40
26621: PUSH
26622: LD_STRING Joan
26624: PPUSH
26625: LD_INT 1
26627: PPUSH
26628: LD_STRING 14_
26630: PPUSH
26631: CALL 65885 0 3
26635: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
26636: LD_EXP 40
26640: PPUSH
26641: LD_VAR 0 3
26645: PPUSH
26646: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26650: LD_VAR 0 3
26654: PPUSH
26655: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
26659: LD_EXP 40
26663: PPUSH
26664: LD_STRING D10BW-Joan-1
26666: PPUSH
26667: CALL_OW 94
// end ; if JMMGirl = 2 then
26671: LD_EXP 7
26675: PUSH
26676: LD_INT 2
26678: EQUAL
26679: IFFALSE 26735
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
26681: LD_ADDR_EXP 42
26685: PUSH
26686: LD_STRING Lisa
26688: PPUSH
26689: LD_INT 1
26691: PPUSH
26692: LD_STRING 14_
26694: PPUSH
26695: CALL 65885 0 3
26699: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
26700: LD_EXP 42
26704: PPUSH
26705: LD_VAR 0 3
26709: PPUSH
26710: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26714: LD_VAR 0 3
26718: PPUSH
26719: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
26723: LD_EXP 42
26727: PPUSH
26728: LD_STRING D10BW-Lisa-1
26730: PPUSH
26731: CALL_OW 94
// end ; if JMMGirl = 3 then
26735: LD_EXP 7
26739: PUSH
26740: LD_INT 3
26742: EQUAL
26743: IFFALSE 26799
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
26745: LD_ADDR_EXP 54
26749: PUSH
26750: LD_STRING Connie
26752: PPUSH
26753: LD_INT 1
26755: PPUSH
26756: LD_STRING 14_
26758: PPUSH
26759: CALL 65885 0 3
26763: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
26764: LD_EXP 54
26768: PPUSH
26769: LD_VAR 0 3
26773: PPUSH
26774: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
26778: LD_VAR 0 3
26782: PPUSH
26783: CALL_OW 87
// SayRadio ( Connie , D10BW-Con-1 ) ;
26787: LD_EXP 54
26791: PPUSH
26792: LD_STRING D10BW-Con-1
26794: PPUSH
26795: CALL_OW 94
// end ; end ;
26799: PPOPN 3
26801: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
26802: LD_EXP 14
26806: PUSH
26807: LD_INT 94500
26809: GREATEREQUAL
26810: IFFALSE 27222
26812: GO 26814
26814: DISABLE
26815: LD_INT 0
26817: PPUSH
26818: PPUSH
26819: PPUSH
// begin tmp := PrepareStevensSquad ;
26820: LD_ADDR_VAR 0 3
26824: PUSH
26825: CALL 2226 0 0
26829: ST_TO_ADDR
// if not tmp then
26830: LD_VAR 0 3
26834: NOT
26835: IFFALSE 26839
// exit ;
26837: GO 27222
// uc_side := 1 ;
26839: LD_ADDR_OWVAR 20
26843: PUSH
26844: LD_INT 1
26846: ST_TO_ADDR
// uc_nation := 1 ;
26847: LD_ADDR_OWVAR 21
26851: PUSH
26852: LD_INT 1
26854: ST_TO_ADDR
// for i in tmp do
26855: LD_ADDR_VAR 0 1
26859: PUSH
26860: LD_VAR 0 3
26864: PUSH
26865: FOR_IN
26866: IFFALSE 26963
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
26868: LD_INT 3
26870: PPUSH
26871: LD_INT 3
26873: PPUSH
26874: LD_INT 1
26876: PPUSH
26877: LD_INT 5
26879: PUSH
26880: LD_INT 9
26882: PUSH
26883: LD_INT 7
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: LIST
26890: PUSH
26891: LD_INT 1
26893: PPUSH
26894: LD_INT 3
26896: PPUSH
26897: CALL_OW 12
26901: ARRAY
26902: PPUSH
26903: LD_INT 40
26905: PPUSH
26906: CALL 70749 0 5
// veh := CreateVehicle ;
26910: LD_ADDR_VAR 0 2
26914: PUSH
26915: CALL_OW 45
26919: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
26920: LD_VAR 0 2
26924: PPUSH
26925: LD_INT 1
26927: PPUSH
26928: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
26932: LD_VAR 0 2
26936: PPUSH
26937: LD_INT 19
26939: PPUSH
26940: LD_INT 0
26942: PPUSH
26943: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
26947: LD_VAR 0 1
26951: PPUSH
26952: LD_VAR 0 2
26956: PPUSH
26957: CALL_OW 52
// end ;
26961: GO 26865
26963: POP
26964: POP
// missionStage := 8 ;
26965: LD_ADDR_EXP 15
26969: PUSH
26970: LD_INT 8
26972: ST_TO_ADDR
// DialogueOn ;
26973: CALL_OW 6
// if Stevens then
26977: LD_EXP 41
26981: IFFALSE 27095
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
26983: LD_EXP 41
26987: PPUSH
26988: CALL_OW 310
26992: PPUSH
26993: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
26997: LD_EXP 41
27001: PPUSH
27002: LD_STRING D8-Huck-1
27004: PPUSH
27005: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
27009: LD_EXP 39
27013: PPUSH
27014: LD_STRING D8-JMM-1
27016: PPUSH
27017: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
27021: LD_EXP 41
27025: PPUSH
27026: LD_STRING D8-Huck-2
27028: PPUSH
27029: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27033: LD_EXP 39
27037: PPUSH
27038: LD_STRING D8-JMM-2
27040: PPUSH
27041: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
27045: LD_EXP 41
27049: PPUSH
27050: LD_STRING D8-Huck-3
27052: PPUSH
27053: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27057: LD_EXP 39
27061: PPUSH
27062: LD_STRING D8-JMM-3
27064: PPUSH
27065: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
27069: LD_EXP 41
27073: PPUSH
27074: LD_STRING D8-Huck-4
27076: PPUSH
27077: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27081: LD_EXP 39
27085: PPUSH
27086: LD_STRING D8-JMM-4
27088: PPUSH
27089: CALL_OW 88
// end else
27093: GO 27205
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
27095: LD_EXP 55
27099: PPUSH
27100: CALL_OW 310
27104: PPUSH
27105: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
27109: LD_EXP 55
27113: PPUSH
27114: LD_STRING D8-Huck-1
27116: PPUSH
27117: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
27121: LD_EXP 39
27125: PPUSH
27126: LD_STRING D8-JMM-1a
27128: PPUSH
27129: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
27133: LD_EXP 55
27137: PPUSH
27138: LD_STRING D8-Huck-2
27140: PPUSH
27141: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
27145: LD_EXP 39
27149: PPUSH
27150: LD_STRING D8-JMM-2
27152: PPUSH
27153: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
27157: LD_EXP 55
27161: PPUSH
27162: LD_STRING D8-Huck-3
27164: PPUSH
27165: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
27169: LD_EXP 39
27173: PPUSH
27174: LD_STRING D8-JMM-3
27176: PPUSH
27177: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
27181: LD_EXP 55
27185: PPUSH
27186: LD_STRING D8-Huck-4
27188: PPUSH
27189: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
27193: LD_EXP 39
27197: PPUSH
27198: LD_STRING D8-JMM-4
27200: PPUSH
27201: CALL_OW 88
// end ; DialogueOff ;
27205: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
27209: LD_INT 25
27211: PPUSH
27212: LD_INT 1
27214: PPUSH
27215: LD_INT 1
27217: PPUSH
27218: CALL_OW 322
// end ;
27222: PPOPN 3
27224: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
27225: LD_INT 1
27227: PPUSH
27228: LD_EXP 71
27232: PPUSH
27233: CALL_OW 292
27237: IFFALSE 27488
27239: GO 27241
27241: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
27242: LD_EXP 71
27246: PPUSH
27247: CALL_OW 87
// DialogueOn ;
27251: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
27255: LD_EXP 39
27259: PPUSH
27260: LD_STRING D10nB-JMM-1
27262: PPUSH
27263: CALL_OW 88
// if BurlakStatus = 1 then
27267: LD_EXP 9
27271: PUSH
27272: LD_INT 1
27274: EQUAL
27275: IFFALSE 27289
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
27277: LD_EXP 70
27281: PPUSH
27282: LD_STRING D10nB-Vse-1a
27284: PPUSH
27285: CALL_OW 94
// end ; if BurlakStatus = 0 then
27289: LD_EXP 9
27293: PUSH
27294: LD_INT 0
27296: EQUAL
27297: IFFALSE 27311
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
27299: LD_EXP 70
27303: PPUSH
27304: LD_STRING D10nB-Vse-1
27306: PPUSH
27307: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
27311: LD_EXP 39
27315: PPUSH
27316: LD_STRING D10nB-JMM-2
27318: PPUSH
27319: CALL_OW 88
// if KappaStatus then
27323: LD_EXP 2
27327: IFFALSE 27341
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
27329: LD_EXP 70
27333: PPUSH
27334: LD_STRING D10nB-Vse-5a
27336: PPUSH
27337: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
27341: LD_EXP 2
27345: NOT
27346: PUSH
27347: LD_EXP 6
27351: PUSH
27352: LD_INT 0
27354: EQUAL
27355: AND
27356: IFFALSE 27484
// begin if JMMGirl = 1 then
27358: LD_EXP 7
27362: PUSH
27363: LD_INT 1
27365: EQUAL
27366: IFFALSE 27416
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
27368: LD_EXP 70
27372: PPUSH
27373: LD_STRING D10nB-Vse-2
27375: PPUSH
27376: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
27380: LD_EXP 39
27384: PPUSH
27385: LD_STRING D10nB-JMM-3
27387: PPUSH
27388: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
27392: LD_EXP 70
27396: PPUSH
27397: LD_STRING D10nB-Vse-3
27399: PPUSH
27400: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
27404: LD_EXP 39
27408: PPUSH
27409: LD_STRING D10nB-JMM-4
27411: PPUSH
27412: CALL_OW 88
// end ; if JMMGirl = 2 then
27416: LD_EXP 7
27420: PUSH
27421: LD_INT 2
27423: EQUAL
27424: IFFALSE 27450
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
27426: LD_EXP 70
27430: PPUSH
27431: LD_STRING D10nB-Vse-4
27433: PPUSH
27434: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
27438: LD_EXP 39
27442: PPUSH
27443: LD_STRING D10nB-JMM-5
27445: PPUSH
27446: CALL_OW 88
// end ; if JMMGirl = 3 then
27450: LD_EXP 7
27454: PUSH
27455: LD_INT 3
27457: EQUAL
27458: IFFALSE 27484
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
27460: LD_EXP 70
27464: PPUSH
27465: LD_STRING D10nB-Vse-5
27467: PPUSH
27468: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
27472: LD_EXP 39
27476: PPUSH
27477: LD_STRING D10nB-JMM-6
27479: PPUSH
27480: CALL_OW 88
// end ; end ; DialogueOff ;
27484: CALL_OW 7
// end ;
27488: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
27489: LD_EXP 14
27493: PUSH
27494: LD_INT 115500
27496: GREATEREQUAL
27497: IFFALSE 27873
27499: GO 27501
27501: DISABLE
27502: LD_INT 0
27504: PPUSH
// begin missionStage := 10 ;
27505: LD_ADDR_EXP 15
27509: PUSH
27510: LD_INT 10
27512: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Kurt , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27513: LD_ADDR_VAR 0 1
27517: PUSH
27518: LD_INT 22
27520: PUSH
27521: LD_INT 1
27523: PUSH
27524: EMPTY
27525: LIST
27526: LIST
27527: PUSH
27528: LD_INT 23
27530: PUSH
27531: LD_INT 1
27533: PUSH
27534: EMPTY
27535: LIST
27536: LIST
27537: PUSH
27538: LD_INT 26
27540: PUSH
27541: LD_INT 1
27543: PUSH
27544: EMPTY
27545: LIST
27546: LIST
27547: PUSH
27548: LD_INT 3
27550: PUSH
27551: LD_INT 25
27553: PUSH
27554: LD_INT 12
27556: PUSH
27557: EMPTY
27558: LIST
27559: LIST
27560: PUSH
27561: EMPTY
27562: LIST
27563: LIST
27564: PUSH
27565: LD_INT 3
27567: PUSH
27568: LD_INT 25
27570: PUSH
27571: LD_INT 16
27573: PUSH
27574: EMPTY
27575: LIST
27576: LIST
27577: PUSH
27578: EMPTY
27579: LIST
27580: LIST
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: PPUSH
27589: CALL_OW 69
27593: PUSH
27594: LD_EXP 39
27598: PUSH
27599: LD_EXP 60
27603: PUSH
27604: LD_EXP 41
27608: PUSH
27609: LD_EXP 55
27613: PUSH
27614: LD_EXP 42
27618: PUSH
27619: LD_EXP 43
27623: PUSH
27624: LD_EXP 44
27628: PUSH
27629: LD_EXP 45
27633: PUSH
27634: LD_EXP 46
27638: PUSH
27639: LD_EXP 47
27643: PUSH
27644: LD_EXP 48
27648: PUSH
27649: LD_EXP 49
27653: PUSH
27654: LD_EXP 50
27658: PUSH
27659: LD_EXP 51
27663: PUSH
27664: LD_EXP 52
27668: PUSH
27669: LD_EXP 53
27673: PUSH
27674: EMPTY
27675: LIST
27676: LIST
27677: LIST
27678: LIST
27679: LIST
27680: LIST
27681: LIST
27682: LIST
27683: LIST
27684: LIST
27685: LIST
27686: LIST
27687: LIST
27688: LIST
27689: LIST
27690: LIST
27691: DIFF
27692: ST_TO_ADDR
// if not tmp and Brown then
27693: LD_VAR 0 1
27697: NOT
27698: PUSH
27699: LD_EXP 47
27703: AND
27704: IFFALSE 27719
// tmp := [ Brown ] ;
27706: LD_ADDR_VAR 0 1
27710: PUSH
27711: LD_EXP 47
27715: PUSH
27716: EMPTY
27717: LIST
27718: ST_TO_ADDR
// DialogueOn ;
27719: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
27723: LD_VAR 0 1
27727: PUSH
27728: LD_INT 1
27730: ARRAY
27731: PPUSH
27732: LD_STRING D11-Sol1-1
27734: PPUSH
27735: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
27739: LD_EXP 64
27743: PPUSH
27744: LD_STRING D11-Pla-1
27746: PPUSH
27747: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
27751: LD_EXP 65
27755: PPUSH
27756: LD_STRING D11-Kov-1
27758: PPUSH
27759: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
27763: LD_EXP 64
27767: PPUSH
27768: LD_STRING D11-Pla-2
27770: PPUSH
27771: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
27775: LD_VAR 0 1
27779: PUSH
27780: LD_INT 1
27782: ARRAY
27783: PPUSH
27784: LD_STRING D11-Sol1-2
27786: PPUSH
27787: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
27791: LD_EXP 39
27795: PPUSH
27796: LD_STRING D11-JMM-2
27798: PPUSH
27799: CALL_OW 88
// DialogueOff ;
27803: CALL_OW 7
// allowBehemothConstruct := true ;
27807: LD_ADDR_EXP 25
27811: PUSH
27812: LD_INT 1
27814: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
27815: LD_STRING M4
27817: PPUSH
27818: CALL_OW 337
// BuildBehemoths ;
27822: CALL 7741 0 0
// repeat wait ( 15 15$00 ) ;
27826: LD_INT 31500
27828: PPUSH
27829: CALL_OW 67
// if behemothDestroyedBeforeFinish then
27833: LD_EXP 27
27837: IFFALSE 27841
// break ;
27839: GO 27873
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
27841: LD_INT 267
27843: PPUSH
27844: CALL_OW 274
27848: PPUSH
27849: LD_INT 1
27851: PPUSH
27852: CALL_OW 275
27856: PUSH
27857: LD_INT 1000
27859: GREATEREQUAL
27860: IFFALSE 27866
// BuildBehemoths ;
27862: CALL 7741 0 0
// until not behemothBuilders ;
27866: LD_EXP 73
27870: NOT
27871: IFFALSE 27826
// end ;
27873: PPOPN 1
27875: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
27876: LD_EXP 73
27880: NOT
27881: PUSH
27882: LD_EXP 28
27886: NOT
27887: AND
27888: PUSH
27889: LD_EXP 25
27893: AND
27894: IFFALSE 27914
27896: GO 27898
27898: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
27899: LD_STRING M4a
27901: PPUSH
27902: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
27906: LD_ADDR_EXP 27
27910: PUSH
27911: LD_INT 1
27913: ST_TO_ADDR
// end ;
27914: END
// every 0 0$1 trigger behemothDone do
27915: LD_EXP 28
27919: IFFALSE 27931
27921: GO 27923
27923: DISABLE
// ChangeMissionObjectives ( M4b ) ;
27924: LD_STRING M4b
27926: PPUSH
27927: CALL_OW 337
27931: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
27932: LD_EXP 29
27936: NOT
27937: IFFALSE 28133
27939: GO 27941
27941: DISABLE
27942: LD_INT 0
27944: PPUSH
27945: PPUSH
// begin enable ;
27946: ENABLE
// tmp := GetBehemoths ( 3 ) ;
27947: LD_ADDR_VAR 0 1
27951: PUSH
27952: LD_INT 3
27954: PPUSH
27955: CALL 102683 0 1
27959: ST_TO_ADDR
// if not tmp and not behemothDone then
27960: LD_VAR 0 1
27964: NOT
27965: PUSH
27966: LD_EXP 28
27970: NOT
27971: AND
27972: IFFALSE 28008
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
27974: LD_ADDR_VAR 0 1
27978: PUSH
27979: LD_INT 22
27981: PUSH
27982: LD_INT 3
27984: PUSH
27985: EMPTY
27986: LIST
27987: LIST
27988: PUSH
27989: LD_INT 30
27991: PUSH
27992: LD_INT 37
27994: PUSH
27995: EMPTY
27996: LIST
27997: LIST
27998: PUSH
27999: EMPTY
28000: LIST
28001: LIST
28002: PPUSH
28003: CALL_OW 69
28007: ST_TO_ADDR
// if not tmp then
28008: LD_VAR 0 1
28012: NOT
28013: IFFALSE 28017
// exit ;
28015: GO 28133
// for i in tmp do
28017: LD_ADDR_VAR 0 2
28021: PUSH
28022: LD_VAR 0 1
28026: PUSH
28027: FOR_IN
28028: IFFALSE 28131
// if See ( 1 , i ) then
28030: LD_INT 1
28032: PPUSH
28033: LD_VAR 0 2
28037: PPUSH
28038: CALL_OW 292
28042: IFFALSE 28129
// begin if GetType ( i ) = unit_building then
28044: LD_VAR 0 2
28048: PPUSH
28049: CALL_OW 247
28053: PUSH
28054: LD_INT 3
28056: EQUAL
28057: IFFALSE 28095
// begin CenterNowOnUnits ( i ) ;
28059: LD_VAR 0 2
28063: PPUSH
28064: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
28068: LD_EXP 39
28072: PPUSH
28073: LD_STRING D17a-JMM-1
28075: PPUSH
28076: CALL_OW 88
// seeBehemoth := true ;
28080: LD_ADDR_EXP 29
28084: PUSH
28085: LD_INT 1
28087: ST_TO_ADDR
// disable ;
28088: DISABLE
// exit ;
28089: POP
28090: POP
28091: GO 28133
// end else
28093: GO 28129
// begin CenterNowOnUnits ( i ) ;
28095: LD_VAR 0 2
28099: PPUSH
28100: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
28104: LD_EXP 39
28108: PPUSH
28109: LD_STRING D17b-JMM-1
28111: PPUSH
28112: CALL_OW 88
// seeBehemoth := true ;
28116: LD_ADDR_EXP 29
28120: PUSH
28121: LD_INT 1
28123: ST_TO_ADDR
// disable ;
28124: DISABLE
// exit ;
28125: POP
28126: POP
28127: GO 28133
// end ; end ;
28129: GO 28027
28131: POP
28132: POP
// end ;
28133: PPOPN 2
28135: END
// every 0 0$1 trigger missionTime >= 58 58$40 do var bomb , dec , tmp ;
28136: LD_EXP 14
28140: PUSH
28141: LD_INT 123200
28143: GREATEREQUAL
28144: IFFALSE 29320
28146: GO 28148
28148: DISABLE
28149: LD_INT 0
28151: PPUSH
28152: PPUSH
28153: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
28154: LD_INT 2
28156: PPUSH
28157: LD_INT 23
28159: PUSH
28160: LD_INT 3
28162: PUSH
28163: LD_INT 3
28165: PUSH
28166: LD_INT 48
28168: PUSH
28169: EMPTY
28170: LIST
28171: LIST
28172: LIST
28173: LIST
28174: PUSH
28175: EMPTY
28176: LIST
28177: PPUSH
28178: CALL 59479 0 2
// repeat wait ( 0 0$1 ) ;
28182: LD_INT 35
28184: PPUSH
28185: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
28189: LD_INT 22
28191: PUSH
28192: LD_INT 3
28194: PUSH
28195: EMPTY
28196: LIST
28197: LIST
28198: PUSH
28199: LD_INT 34
28201: PUSH
28202: LD_INT 48
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: EMPTY
28210: LIST
28211: LIST
28212: PPUSH
28213: CALL_OW 69
28217: IFFALSE 28182
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
28219: LD_ADDR_VAR 0 1
28223: PUSH
28224: LD_INT 22
28226: PUSH
28227: LD_INT 3
28229: PUSH
28230: EMPTY
28231: LIST
28232: LIST
28233: PUSH
28234: LD_INT 34
28236: PUSH
28237: LD_INT 48
28239: PUSH
28240: EMPTY
28241: LIST
28242: LIST
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PPUSH
28248: CALL_OW 69
28252: PUSH
28253: LD_INT 1
28255: ARRAY
28256: ST_TO_ADDR
// missionStage := 12 ;
28257: LD_ADDR_EXP 15
28261: PUSH
28262: LD_INT 12
28264: ST_TO_ADDR
// platonovHasBomb := true ;
28265: LD_ADDR_EXP 30
28269: PUSH
28270: LD_INT 1
28272: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
28273: LD_VAR 0 1
28277: PPUSH
28278: LD_INT 181
28280: PPUSH
28281: LD_INT 86
28283: PPUSH
28284: CALL_OW 171
// AddComHold ( bomb ) ;
28288: LD_VAR 0 1
28292: PPUSH
28293: CALL_OW 200
// wait ( 0 0$10 ) ;
28297: LD_INT 350
28299: PPUSH
28300: CALL_OW 67
// DialogueOn ;
28304: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
28308: LD_EXP 64
28312: PPUSH
28313: LD_STRING D15-Pla-1
28315: PPUSH
28316: CALL_OW 94
// dec = Query ( Q15a ) ;
28320: LD_ADDR_VAR 0 2
28324: PUSH
28325: LD_STRING Q15a
28327: PPUSH
28328: CALL_OW 97
28332: ST_TO_ADDR
// if dec = 1 then
28333: LD_VAR 0 2
28337: PUSH
28338: LD_INT 1
28340: EQUAL
28341: IFFALSE 28364
// begin Say ( JMM , D15a-JMM-1 ) ;
28343: LD_EXP 39
28347: PPUSH
28348: LD_STRING D15a-JMM-1
28350: PPUSH
28351: CALL_OW 88
// YouLost ( Surrender ) ;
28355: LD_STRING Surrender
28357: PPUSH
28358: CALL_OW 104
// exit ;
28362: GO 29320
// end ; if dec = 2 then
28364: LD_VAR 0 2
28368: PUSH
28369: LD_INT 2
28371: EQUAL
28372: IFFALSE 28441
// begin Say ( JMM , D15b-JMM-1 ) ;
28374: LD_EXP 39
28378: PPUSH
28379: LD_STRING D15b-JMM-1
28381: PPUSH
28382: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
28386: LD_EXP 64
28390: PPUSH
28391: LD_STRING D15b-Pla-1
28393: PPUSH
28394: CALL_OW 94
// DialogueOff ;
28398: CALL_OW 7
// wait ( 3 3$00 ) ;
28402: LD_INT 6300
28404: PPUSH
28405: CALL_OW 67
// DialogueOn ;
28409: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
28413: LD_EXP 39
28417: PPUSH
28418: LD_STRING D15d-JMM-1a
28420: PPUSH
28421: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28425: LD_EXP 64
28429: PPUSH
28430: LD_STRING D15d-Pla-1
28432: PPUSH
28433: CALL_OW 94
// DialogueOff ;
28437: CALL_OW 7
// end ; if dec = 3 then
28441: LD_VAR 0 2
28445: PUSH
28446: LD_INT 3
28448: EQUAL
28449: IFFALSE 28503
// begin Say ( JMM , D15c-JMM-1 ) ;
28451: LD_EXP 39
28455: PPUSH
28456: LD_STRING D15c-JMM-1
28458: PPUSH
28459: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
28463: LD_EXP 64
28467: PPUSH
28468: LD_STRING D15c-Pla-1
28470: PPUSH
28471: CALL_OW 94
// DialogueOff ;
28475: CALL_OW 7
// wait ( 0 0$15 ) ;
28479: LD_INT 525
28481: PPUSH
28482: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
28486: LD_VAR 0 1
28490: PPUSH
28491: LD_INT 60
28493: PPUSH
28494: LD_INT 95
28496: PPUSH
28497: CALL_OW 116
// exit ;
28501: GO 29320
// end ; if dec = 4 then
28503: LD_VAR 0 2
28507: PUSH
28508: LD_INT 4
28510: EQUAL
28511: IFFALSE 28541
// begin Say ( JMM , D15d-JMM-1 ) ;
28513: LD_EXP 39
28517: PPUSH
28518: LD_STRING D15d-JMM-1
28520: PPUSH
28521: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
28525: LD_EXP 64
28529: PPUSH
28530: LD_STRING D15d-Pla-1
28532: PPUSH
28533: CALL_OW 94
// DialogueOff ;
28537: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28541: LD_EXP 62
28545: PPUSH
28546: CALL_OW 302
28550: PUSH
28551: LD_EXP 62
28555: PPUSH
28556: CALL_OW 255
28560: PUSH
28561: LD_INT 1
28563: EQUAL
28564: AND
28565: PUSH
28566: LD_INT 22
28568: PUSH
28569: LD_INT 1
28571: PUSH
28572: EMPTY
28573: LIST
28574: LIST
28575: PUSH
28576: LD_INT 34
28578: PUSH
28579: LD_INT 8
28581: PUSH
28582: EMPTY
28583: LIST
28584: LIST
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PPUSH
28590: CALL_OW 69
28594: NOT
28595: AND
28596: IFFALSE 29221
// begin SetSide ( Friend , 8 ) ;
28598: LD_EXP 62
28602: PPUSH
28603: LD_INT 8
28605: PPUSH
28606: CALL_OW 235
// if IsInUnit ( Friend ) then
28610: LD_EXP 62
28614: PPUSH
28615: CALL_OW 310
28619: IFFALSE 28630
// ComExitBuilding ( Friend ) ;
28621: LD_EXP 62
28625: PPUSH
28626: CALL_OW 122
// if IsDriver ( Friend ) then
28630: LD_EXP 62
28634: PPUSH
28635: CALL 100228 0 1
28639: IFFALSE 28650
// ComExitVehicle ( Friend ) ;
28641: LD_EXP 62
28645: PPUSH
28646: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28650: LD_EXP 62
28654: PPUSH
28655: LD_INT 9
28657: PPUSH
28658: LD_INT 2
28660: PPUSH
28661: CALL_OW 171
// wait ( 0 0$05 ) ;
28665: LD_INT 175
28667: PPUSH
28668: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
28672: LD_EXP 62
28676: PPUSH
28677: CALL_OW 87
// DialogueOn ;
28681: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
28685: LD_EXP 39
28689: PPUSH
28690: LD_STRING D16-JMM-1
28692: PPUSH
28693: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
28697: LD_EXP 62
28701: PPUSH
28702: LD_STRING D16-Friend-1
28704: PPUSH
28705: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
28709: LD_EXP 39
28713: PPUSH
28714: LD_STRING D16-JMM-2
28716: PPUSH
28717: CALL_OW 88
// DialogueOff ;
28721: CALL_OW 7
// SetSide ( Friend , 1 ) ;
28725: LD_EXP 62
28729: PPUSH
28730: LD_INT 1
28732: PPUSH
28733: CALL_OW 235
// ComHold ( Friend ) ;
28737: LD_EXP 62
28741: PPUSH
28742: CALL_OW 140
// wait ( 0 0$20 ) ;
28746: LD_INT 700
28748: PPUSH
28749: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
28753: LD_EXP 62
28757: PPUSH
28758: LD_INT 9
28760: PPUSH
28761: LD_INT 2
28763: PPUSH
28764: CALL_OW 297
28768: PUSH
28769: LD_INT 30
28771: LESS
28772: IFFALSE 28841
// begin SetSide ( Friend , 8 ) ;
28774: LD_EXP 62
28778: PPUSH
28779: LD_INT 8
28781: PPUSH
28782: CALL_OW 235
// if IsInUnit ( Friend ) then
28786: LD_EXP 62
28790: PPUSH
28791: CALL_OW 310
28795: IFFALSE 28806
// ComExitBuilding ( Friend ) ;
28797: LD_EXP 62
28801: PPUSH
28802: CALL_OW 122
// if IsDriver ( Friend ) then
28806: LD_EXP 62
28810: PPUSH
28811: CALL 100228 0 1
28815: IFFALSE 28826
// ComExitVehicle ( Friend ) ;
28817: LD_EXP 62
28821: PPUSH
28822: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
28826: LD_EXP 62
28830: PPUSH
28831: LD_INT 9
28833: PPUSH
28834: LD_INT 2
28836: PPUSH
28837: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
28841: LD_INT 1050
28843: PPUSH
28844: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28848: LD_INT 22
28850: PUSH
28851: LD_INT 1
28853: PUSH
28854: EMPTY
28855: LIST
28856: LIST
28857: PUSH
28858: LD_INT 34
28860: PUSH
28861: LD_INT 8
28863: PUSH
28864: EMPTY
28865: LIST
28866: LIST
28867: PUSH
28868: EMPTY
28869: LIST
28870: LIST
28871: PPUSH
28872: CALL_OW 69
28876: NOT
28877: IFFALSE 29199
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
28879: LD_ADDR_VAR 0 3
28883: PUSH
28884: LD_INT 22
28886: PUSH
28887: LD_INT 1
28889: PUSH
28890: EMPTY
28891: LIST
28892: LIST
28893: PUSH
28894: LD_INT 26
28896: PUSH
28897: LD_INT 1
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 3
28906: PUSH
28907: LD_INT 25
28909: PUSH
28910: LD_INT 12
28912: PUSH
28913: EMPTY
28914: LIST
28915: LIST
28916: PUSH
28917: LD_INT 25
28919: PUSH
28920: LD_INT 16
28922: PUSH
28923: EMPTY
28924: LIST
28925: LIST
28926: PUSH
28927: EMPTY
28928: LIST
28929: LIST
28930: LIST
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: LIST
28936: PPUSH
28937: CALL_OW 69
28941: PUSH
28942: LD_EXP 39
28946: PUSH
28947: LD_EXP 41
28951: PUSH
28952: LD_EXP 55
28956: PUSH
28957: LD_EXP 42
28961: PUSH
28962: LD_EXP 43
28966: PUSH
28967: LD_EXP 44
28971: PUSH
28972: LD_EXP 45
28976: PUSH
28977: LD_EXP 46
28981: PUSH
28982: LD_EXP 47
28986: PUSH
28987: LD_EXP 48
28991: PUSH
28992: LD_EXP 49
28996: PUSH
28997: LD_EXP 50
29001: PUSH
29002: LD_EXP 51
29006: PUSH
29007: LD_EXP 52
29011: PUSH
29012: LD_EXP 53
29016: PUSH
29017: EMPTY
29018: LIST
29019: LIST
29020: LIST
29021: LIST
29022: LIST
29023: LIST
29024: LIST
29025: LIST
29026: LIST
29027: LIST
29028: LIST
29029: LIST
29030: LIST
29031: LIST
29032: LIST
29033: DIFF
29034: ST_TO_ADDR
// DialogueOn ;
29035: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
29039: LD_EXP 64
29043: PPUSH
29044: LD_STRING D16a-Pla-1
29046: PPUSH
29047: CALL_OW 94
// if Stevens then
29051: LD_EXP 41
29055: IFFALSE 29071
// Say ( Stevens , D16a-Huck-1 ) else
29057: LD_EXP 41
29061: PPUSH
29062: LD_STRING D16a-Huck-1
29064: PPUSH
29065: CALL_OW 88
29069: GO 29113
// if Baker then
29071: LD_EXP 55
29075: IFFALSE 29091
// Say ( Baker , D16a-Huck-1 ) else
29077: LD_EXP 55
29081: PPUSH
29082: LD_STRING D16a-Huck-1
29084: PPUSH
29085: CALL_OW 88
29089: GO 29113
// if tmp then
29091: LD_VAR 0 3
29095: IFFALSE 29113
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
29097: LD_VAR 0 3
29101: PUSH
29102: LD_INT 1
29104: ARRAY
29105: PPUSH
29106: LD_STRING D16a-Sol1-1
29108: PPUSH
29109: CALL_OW 88
// if GetSide ( Friend ) = 8 then
29113: LD_EXP 62
29117: PPUSH
29118: CALL_OW 255
29122: PUSH
29123: LD_INT 8
29125: EQUAL
29126: IFFALSE 29142
// Say ( JMM , D16a-JMM-1 ) else
29128: LD_EXP 39
29132: PPUSH
29133: LD_STRING D16a-JMM-1
29135: PPUSH
29136: CALL_OW 88
29140: GO 29178
// begin Say ( JMM , D16a-JMM-1a ) ;
29142: LD_EXP 39
29146: PPUSH
29147: LD_STRING D16a-JMM-1a
29149: PPUSH
29150: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
29154: LD_EXP 62
29158: PPUSH
29159: LD_STRING D16a-Friend-1
29161: PPUSH
29162: CALL_OW 88
// SetSide ( Friend , 3 ) ;
29166: LD_EXP 62
29170: PPUSH
29171: LD_INT 3
29173: PPUSH
29174: CALL_OW 235
// end ; DialogueOff ;
29178: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
29182: LD_VAR 0 1
29186: PPUSH
29187: LD_INT 60
29189: PPUSH
29190: LD_INT 95
29192: PPUSH
29193: CALL_OW 116
// end else
29197: GO 29219
// begin DialogueOn ;
29199: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29203: LD_EXP 64
29207: PPUSH
29208: LD_STRING D16c-Pla-
29210: PPUSH
29211: CALL_OW 94
// DialogueOff ;
29215: CALL_OW 7
// end ; end else
29219: GO 29320
// begin wait ( 3 3$00 ) ;
29221: LD_INT 6300
29223: PPUSH
29224: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
29228: LD_INT 22
29230: PUSH
29231: LD_INT 1
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 34
29240: PUSH
29241: LD_INT 8
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: EMPTY
29249: LIST
29250: LIST
29251: PPUSH
29252: CALL_OW 69
29256: NOT
29257: IFFALSE 29300
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
29259: LD_EXP 64
29263: PPUSH
29264: LD_STRING D16b-Pla-1
29266: PPUSH
29267: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
29271: LD_EXP 39
29275: PPUSH
29276: LD_STRING D16b-JMM-
29278: PPUSH
29279: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
29283: LD_VAR 0 1
29287: PPUSH
29288: LD_INT 60
29290: PPUSH
29291: LD_INT 95
29293: PPUSH
29294: CALL_OW 116
// end else
29298: GO 29320
// begin DialogueOn ;
29300: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
29304: LD_EXP 64
29308: PPUSH
29309: LD_STRING D16c-Pla-
29311: PPUSH
29312: CALL_OW 94
// DialogueOff ;
29316: CALL_OW 7
// end ; end ; end ;
29320: PPOPN 3
29322: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
29323: LD_EXP 14
29327: PUSH
29328: LD_INT 126000
29330: GREATEREQUAL
29331: PUSH
29332: LD_EXP 23
29336: NOT
29337: AND
29338: PUSH
29339: LD_EXP 74
29343: PPUSH
29344: CALL_OW 302
29348: AND
29349: IFFALSE 29707
29351: GO 29353
29353: DISABLE
29354: LD_INT 0
29356: PPUSH
// begin missionStage = 11 ;
29357: LD_ADDR_EXP 15
29361: PUSH
29362: LD_INT 11
29364: ST_TO_ADDR
// DialogueOn ;
29365: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
29369: LD_EXP 74
29373: PPUSH
29374: LD_STRING D9-Roth-1
29376: PPUSH
29377: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
29381: LD_EXP 39
29385: PPUSH
29386: LD_STRING D9-JMM-1
29388: PPUSH
29389: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
29393: LD_EXP 74
29397: PPUSH
29398: LD_STRING D9-Roth-2
29400: PPUSH
29401: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
29405: LD_EXP 74
29409: PPUSH
29410: LD_STRING D9-Roth-2a
29412: PPUSH
29413: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
29417: LD_EXP 64
29421: PPUSH
29422: LD_STRING D9-Pla-2
29424: PPUSH
29425: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
29429: LD_EXP 74
29433: PPUSH
29434: LD_STRING D9-Roth-3
29436: PPUSH
29437: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
29441: LD_EXP 64
29445: PPUSH
29446: LD_STRING D9-Pla-3
29448: PPUSH
29449: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
29453: LD_EXP 74
29457: PPUSH
29458: LD_STRING D9-Roth-4
29460: PPUSH
29461: CALL_OW 94
// dec = Query ( Q9 ) ;
29465: LD_ADDR_VAR 0 1
29469: PUSH
29470: LD_STRING Q9
29472: PPUSH
29473: CALL_OW 97
29477: ST_TO_ADDR
// if dec = 1 then
29478: LD_VAR 0 1
29482: PUSH
29483: LD_INT 1
29485: EQUAL
29486: IFFALSE 29500
// SayRadio ( Roth , D9a-Roth-1 ) ;
29488: LD_EXP 74
29492: PPUSH
29493: LD_STRING D9a-Roth-1
29495: PPUSH
29496: CALL_OW 94
// if dec = 2 then
29500: LD_VAR 0 1
29504: PUSH
29505: LD_INT 2
29507: EQUAL
29508: IFFALSE 29534
// begin Say ( JMM , D9b-JMM-1 ) ;
29510: LD_EXP 39
29514: PPUSH
29515: LD_STRING D9b-JMM-1
29517: PPUSH
29518: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
29522: LD_EXP 74
29526: PPUSH
29527: LD_STRING D9b-Roth-1
29529: PPUSH
29530: CALL_OW 94
// end ; if dec = 3 then
29534: LD_VAR 0 1
29538: PUSH
29539: LD_INT 3
29541: EQUAL
29542: IFFALSE 29604
// begin Say ( JMM , D9c-JMM-1 ) ;
29544: LD_EXP 39
29548: PPUSH
29549: LD_STRING D9c-JMM-1
29551: PPUSH
29552: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
29556: LD_EXP 74
29560: PPUSH
29561: LD_STRING D9c-Roth-1
29563: PPUSH
29564: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
29568: LD_EXP 39
29572: PPUSH
29573: LD_STRING D9c-JMM-2
29575: PPUSH
29576: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
29580: LD_EXP 74
29584: PPUSH
29585: LD_STRING D9c-Roth-2
29587: PPUSH
29588: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
29592: LD_EXP 39
29596: PPUSH
29597: LD_STRING D9c-JMM-3
29599: PPUSH
29600: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
29604: LD_EXP 74
29608: PPUSH
29609: LD_STRING D9c-Roth-3
29611: PPUSH
29612: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
29616: LD_EXP 74
29620: PPUSH
29621: LD_STRING D9cont-Roth-1
29623: PPUSH
29624: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
29628: LD_EXP 39
29632: PPUSH
29633: LD_STRING D9cont-JMM-1
29635: PPUSH
29636: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
29640: LD_EXP 74
29644: PPUSH
29645: LD_STRING D9cont-Roth-2
29647: PPUSH
29648: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
29652: LD_EXP 39
29656: PPUSH
29657: LD_STRING D9cont-JMM-2
29659: PPUSH
29660: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
29664: LD_EXP 74
29668: PPUSH
29669: LD_STRING D9cont-Roth-3
29671: PPUSH
29672: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
29676: LD_EXP 39
29680: PPUSH
29681: LD_STRING D9cont-JMM-3
29683: PPUSH
29684: CALL_OW 88
// DialogueOff ;
29688: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
29692: LD_STRING M3
29694: PPUSH
29695: CALL_OW 337
// allianceActive := true ;
29699: LD_ADDR_EXP 31
29703: PUSH
29704: LD_INT 1
29706: ST_TO_ADDR
// end ;
29707: PPOPN 1
29709: END
// every 0 0$2 trigger See ( 1 , ru_depot ) and IsInUnit ( Platonov ) do var enemy ;
29710: LD_INT 1
29712: PPUSH
29713: LD_INT 126
29715: PPUSH
29716: CALL_OW 292
29720: PUSH
29721: LD_EXP 64
29725: PPUSH
29726: CALL_OW 310
29730: AND
29731: IFFALSE 29811
29733: GO 29735
29735: DISABLE
29736: LD_INT 0
29738: PPUSH
// begin ComExitBuilding ( Platonov ) ;
29739: LD_EXP 64
29743: PPUSH
29744: CALL_OW 122
// enemy := NearestUnitToUnit ( FilterUnitsInArea ( russianBaseArea , [ f_side , 1 ] ) , Platonov ) ;
29748: LD_ADDR_VAR 0 1
29752: PUSH
29753: LD_INT 4
29755: PPUSH
29756: LD_INT 22
29758: PUSH
29759: LD_INT 1
29761: PUSH
29762: EMPTY
29763: LIST
29764: LIST
29765: PPUSH
29766: CALL_OW 70
29770: PPUSH
29771: LD_EXP 64
29775: PPUSH
29776: CALL_OW 74
29780: ST_TO_ADDR
// AddComAttackUnit ( Platonov , enemy [ 1 ] ) ;
29781: LD_EXP 64
29785: PPUSH
29786: LD_VAR 0 1
29790: PUSH
29791: LD_INT 1
29793: ARRAY
29794: PPUSH
29795: CALL_OW 175
// Say ( Platonov , D18-Pla-1 ) ;
29799: LD_EXP 64
29803: PPUSH
29804: LD_STRING D18-Pla-1
29806: PPUSH
29807: CALL_OW 88
// end ;
29811: PPOPN 1
29813: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 , 10 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
29814: LD_EXP 64
29818: PPUSH
29819: CALL_OW 301
29823: PUSH
29824: LD_EXP 67
29828: PPUSH
29829: CALL_OW 301
29833: AND
29834: PUSH
29835: LD_INT 22
29837: PUSH
29838: LD_INT 3
29840: PUSH
29841: EMPTY
29842: LIST
29843: LIST
29844: PUSH
29845: LD_INT 21
29847: PUSH
29848: LD_INT 1
29850: PUSH
29851: EMPTY
29852: LIST
29853: LIST
29854: PUSH
29855: LD_INT 50
29857: PUSH
29858: EMPTY
29859: LIST
29860: PUSH
29861: EMPTY
29862: LIST
29863: LIST
29864: LIST
29865: PPUSH
29866: CALL_OW 69
29870: PUSH
29871: LD_INT 7
29873: PUSH
29874: LD_INT 8
29876: PUSH
29877: LD_INT 9
29879: PUSH
29880: LD_INT 10
29882: PUSH
29883: EMPTY
29884: LIST
29885: LIST
29886: LIST
29887: LIST
29888: PUSH
29889: LD_OWVAR 67
29893: ARRAY
29894: LESS
29895: AND
29896: IFFALSE 30667
29898: GO 29900
29900: DISABLE
29901: LD_INT 0
29903: PPUSH
29904: PPUSH
29905: PPUSH
29906: PPUSH
// begin MC_Kill ( 2 ) ;
29907: LD_INT 2
29909: PPUSH
29910: CALL 35501 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
29914: LD_INT 1
29916: PPUSH
29917: LD_INT 3
29919: PPUSH
29920: LD_INT 1
29922: PPUSH
29923: LD_INT 1
29925: PPUSH
29926: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
29930: LD_ADDR_VAR 0 1
29934: PUSH
29935: LD_INT 22
29937: PUSH
29938: LD_INT 3
29940: PUSH
29941: EMPTY
29942: LIST
29943: LIST
29944: PUSH
29945: LD_INT 21
29947: PUSH
29948: LD_INT 1
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 24
29957: PUSH
29958: LD_INT 900
29960: PUSH
29961: EMPTY
29962: LIST
29963: LIST
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: LIST
29969: PPUSH
29970: CALL_OW 69
29974: PUSH
29975: FOR_IN
29976: IFFALSE 30007
// if GetSex ( i ) = sex_male then
29978: LD_VAR 0 1
29982: PPUSH
29983: CALL_OW 258
29987: PUSH
29988: LD_INT 1
29990: EQUAL
29991: IFFALSE 30005
// begin tmp = i ;
29993: LD_ADDR_VAR 0 2
29997: PUSH
29998: LD_VAR 0 1
30002: ST_TO_ADDR
// break ;
30003: GO 30007
// end ;
30005: GO 29975
30007: POP
30008: POP
// if tmp = 0 then
30009: LD_VAR 0 2
30013: PUSH
30014: LD_INT 0
30016: EQUAL
30017: IFFALSE 30071
// begin uc_side = 3 ;
30019: LD_ADDR_OWVAR 20
30023: PUSH
30024: LD_INT 3
30026: ST_TO_ADDR
// uc_nation = 3 ;
30027: LD_ADDR_OWVAR 21
30031: PUSH
30032: LD_INT 3
30034: ST_TO_ADDR
// hc_name =  ;
30035: LD_ADDR_OWVAR 26
30039: PUSH
30040: LD_STRING 
30042: ST_TO_ADDR
// hc_gallery =  ;
30043: LD_ADDR_OWVAR 33
30047: PUSH
30048: LD_STRING 
30050: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
30051: LD_INT 1
30053: PPUSH
30054: LD_INT 10
30056: PPUSH
30057: CALL_OW 381
// tmp = CreateHuman ;
30061: LD_ADDR_VAR 0 2
30065: PUSH
30066: CALL_OW 44
30070: ST_TO_ADDR
// end ; DialogueOn ;
30071: CALL_OW 6
// SayRadio ( tmp , DSurrenderRussians-RSol1-1a ) ;
30075: LD_VAR 0 2
30079: PPUSH
30080: LD_STRING DSurrenderRussians-RSol1-1a
30082: PPUSH
30083: CALL_OW 94
// DialogueOff ;
30087: CALL_OW 7
// russianDestroyed := true ;
30091: LD_ADDR_EXP 21
30095: PUSH
30096: LD_INT 1
30098: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
30099: LD_INT 22
30101: PUSH
30102: LD_INT 3
30104: PUSH
30105: EMPTY
30106: LIST
30107: LIST
30108: PUSH
30109: LD_INT 21
30111: PUSH
30112: LD_INT 1
30114: PUSH
30115: EMPTY
30116: LIST
30117: LIST
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PPUSH
30123: CALL_OW 69
30127: PPUSH
30128: CALL_OW 122
// wait ( 0 0$1 ) ;
30132: LD_INT 35
30134: PPUSH
30135: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
30139: LD_INT 22
30141: PUSH
30142: LD_INT 3
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: LD_INT 21
30151: PUSH
30152: LD_INT 1
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: PPUSH
30163: CALL_OW 69
30167: PPUSH
30168: LD_INT 25
30170: PPUSH
30171: CALL_OW 173
// wait ( 0 0$10 ) ;
30175: LD_INT 350
30177: PPUSH
30178: CALL_OW 67
// PrepareOmarInvasion ;
30182: CALL 13983 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
30186: LD_ADDR_VAR 0 2
30190: PUSH
30191: LD_EXP 92
30195: PPUSH
30196: CALL_OW 250
30200: PUSH
30201: LD_EXP 92
30205: PPUSH
30206: CALL_OW 251
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
30215: LD_VAR 0 2
30219: PUSH
30220: LD_INT 1
30222: ARRAY
30223: PPUSH
30224: LD_VAR 0 2
30228: PUSH
30229: LD_INT 2
30231: ARRAY
30232: PPUSH
30233: LD_INT 1
30235: PPUSH
30236: LD_INT 8
30238: NEG
30239: PPUSH
30240: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
30244: LD_EXP 92
30248: PPUSH
30249: CALL_OW 87
// DialogueOn ;
30253: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
30257: LD_EXP 39
30261: PPUSH
30262: LD_STRING D19-JMM-1
30264: PPUSH
30265: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
30269: LD_ADDR_VAR 0 3
30273: PUSH
30274: LD_INT 22
30276: PUSH
30277: LD_INT 1
30279: PUSH
30280: EMPTY
30281: LIST
30282: LIST
30283: PUSH
30284: LD_INT 26
30286: PUSH
30287: LD_INT 1
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 2
30296: PUSH
30297: LD_INT 25
30299: PUSH
30300: LD_INT 1
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: LD_INT 25
30309: PUSH
30310: LD_INT 2
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 25
30319: PUSH
30320: LD_INT 3
30322: PUSH
30323: EMPTY
30324: LIST
30325: LIST
30326: PUSH
30327: LD_INT 25
30329: PUSH
30330: LD_INT 4
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 25
30339: PUSH
30340: LD_INT 5
30342: PUSH
30343: EMPTY
30344: LIST
30345: LIST
30346: PUSH
30347: LD_INT 25
30349: PUSH
30350: LD_INT 8
30352: PUSH
30353: EMPTY
30354: LIST
30355: LIST
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: PUSH
30366: EMPTY
30367: LIST
30368: LIST
30369: LIST
30370: PPUSH
30371: CALL_OW 69
30375: PUSH
30376: LD_EXP 39
30380: PUSH
30381: LD_EXP 40
30385: PUSH
30386: LD_EXP 41
30390: PUSH
30391: LD_EXP 42
30395: PUSH
30396: LD_EXP 43
30400: PUSH
30401: LD_EXP 44
30405: PUSH
30406: LD_EXP 45
30410: PUSH
30411: LD_EXP 46
30415: PUSH
30416: LD_EXP 47
30420: PUSH
30421: LD_EXP 48
30425: PUSH
30426: LD_EXP 49
30430: PUSH
30431: LD_EXP 50
30435: PUSH
30436: LD_EXP 51
30440: PUSH
30441: LD_EXP 52
30445: PUSH
30446: LD_EXP 53
30450: PUSH
30451: LD_EXP 54
30455: PUSH
30456: LD_EXP 55
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: LIST
30465: LIST
30466: LIST
30467: LIST
30468: LIST
30469: LIST
30470: LIST
30471: LIST
30472: LIST
30473: LIST
30474: LIST
30475: LIST
30476: LIST
30477: LIST
30478: LIST
30479: DIFF
30480: ST_TO_ADDR
// if tmp2 then
30481: LD_VAR 0 3
30485: IFFALSE 30503
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
30487: LD_VAR 0 3
30491: PUSH
30492: LD_INT 1
30494: ARRAY
30495: PPUSH
30496: LD_STRING D19-Sol1-1
30498: PPUSH
30499: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
30503: LD_EXP 39
30507: PPUSH
30508: LD_STRING D19-JMM-2
30510: PPUSH
30511: CALL_OW 88
// DialogueOff ;
30515: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
30519: LD_VAR 0 2
30523: PUSH
30524: LD_INT 1
30526: ARRAY
30527: PPUSH
30528: LD_VAR 0 2
30532: PUSH
30533: LD_INT 2
30535: ARRAY
30536: PPUSH
30537: LD_INT 1
30539: PPUSH
30540: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
30544: LD_STRING M5
30546: PPUSH
30547: CALL_OW 337
// omarOnMotherLode := false ;
30551: LD_ADDR_VAR 0 4
30555: PUSH
30556: LD_INT 0
30558: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
30559: LD_INT 35
30561: PPUSH
30562: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
30566: LD_EXP 92
30570: PPUSH
30571: LD_INT 215
30573: PPUSH
30574: LD_INT 100
30576: PPUSH
30577: CALL_OW 297
30581: PUSH
30582: LD_INT 10
30584: LESS
30585: PUSH
30586: LD_VAR 0 4
30590: NOT
30591: AND
30592: IFFALSE 30626
// begin omarOnMotherLode := true ;
30594: LD_ADDR_VAR 0 4
30598: PUSH
30599: LD_INT 1
30601: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
30602: LD_EXP 39
30606: PPUSH
30607: LD_STRING D19b-JMM-1
30609: PPUSH
30610: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
30614: LD_EXP 92
30618: PPUSH
30619: LD_STRING DOmarContam-Omar-1
30621: PPUSH
30622: CALL_OW 88
// end ; until IsDead ( Omar ) ;
30626: LD_EXP 92
30630: PPUSH
30631: CALL_OW 301
30635: IFFALSE 30559
// Say ( JMM , D19a-JMM-1 ) ;
30637: LD_EXP 39
30641: PPUSH
30642: LD_STRING D19a-JMM-1
30644: PPUSH
30645: CALL_OW 88
// if Heike then
30649: LD_EXP 93
30653: IFFALSE 30667
// Say ( Heike , D19a-Hke-1 ) ;
30655: LD_EXP 93
30659: PPUSH
30660: LD_STRING D19a-Hke-1
30662: PPUSH
30663: CALL_OW 88
// end ;
30667: PPOPN 4
30669: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
30670: LD_INT 22
30672: PUSH
30673: LD_INT 3
30675: PUSH
30676: EMPTY
30677: LIST
30678: LIST
30679: PUSH
30680: LD_INT 21
30682: PUSH
30683: LD_INT 1
30685: PUSH
30686: EMPTY
30687: LIST
30688: LIST
30689: PUSH
30690: EMPTY
30691: LIST
30692: LIST
30693: PPUSH
30694: CALL_OW 69
30698: PUSH
30699: LD_EXP 21
30703: AND
30704: IFFALSE 30772
30706: GO 30708
30708: DISABLE
30709: LD_INT 0
30711: PPUSH
30712: PPUSH
// begin enable ;
30713: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
30714: LD_ADDR_VAR 0 2
30718: PUSH
30719: LD_INT 25
30721: PPUSH
30722: LD_INT 22
30724: PUSH
30725: LD_INT 3
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PPUSH
30732: CALL_OW 70
30736: ST_TO_ADDR
// if not tmp then
30737: LD_VAR 0 2
30741: NOT
30742: IFFALSE 30746
// exit ;
30744: GO 30772
// for i in tmp do
30746: LD_ADDR_VAR 0 1
30750: PUSH
30751: LD_VAR 0 2
30755: PUSH
30756: FOR_IN
30757: IFFALSE 30770
// RemoveUnit ( i ) ;
30759: LD_VAR 0 1
30763: PPUSH
30764: CALL_OW 64
30768: GO 30756
30770: POP
30771: POP
// end ;
30772: PPOPN 2
30774: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
30775: LD_INT 22
30777: PUSH
30778: LD_INT 7
30780: PUSH
30781: EMPTY
30782: LIST
30783: LIST
30784: PUSH
30785: LD_INT 21
30787: PUSH
30788: LD_INT 1
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: PUSH
30795: EMPTY
30796: LIST
30797: LIST
30798: PPUSH
30799: CALL_OW 69
30803: PUSH
30804: LD_INT 6
30806: LESS
30807: IFFALSE 31275
30809: GO 30811
30811: DISABLE
30812: LD_INT 0
30814: PPUSH
30815: PPUSH
// begin MC_Kill ( 1 ) ;
30816: LD_INT 1
30818: PPUSH
30819: CALL 35501 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
30823: LD_INT 7
30825: PPUSH
30826: LD_INT 1
30828: PPUSH
30829: LD_INT 1
30831: PPUSH
30832: LD_INT 1
30834: PPUSH
30835: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
30839: LD_ADDR_VAR 0 1
30843: PUSH
30844: LD_INT 22
30846: PUSH
30847: LD_INT 7
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 26
30856: PUSH
30857: LD_INT 1
30859: PUSH
30860: EMPTY
30861: LIST
30862: LIST
30863: PUSH
30864: EMPTY
30865: LIST
30866: LIST
30867: PPUSH
30868: CALL_OW 69
30872: PUSH
30873: LD_EXP 74
30877: DIFF
30878: ST_TO_ADDR
// if tmp then
30879: LD_VAR 0 1
30883: IFFALSE 30901
// tmp := tmp [ 1 ] else
30885: LD_ADDR_VAR 0 1
30889: PUSH
30890: LD_VAR 0 1
30894: PUSH
30895: LD_INT 1
30897: ARRAY
30898: ST_TO_ADDR
30899: GO 30937
// begin uc_side := 7 ;
30901: LD_ADDR_OWVAR 20
30905: PUSH
30906: LD_INT 7
30908: ST_TO_ADDR
// uc_nation := 1 ;
30909: LD_ADDR_OWVAR 21
30913: PUSH
30914: LD_INT 1
30916: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
30917: LD_INT 1
30919: PPUSH
30920: LD_INT 8
30922: PPUSH
30923: CALL_OW 384
// tmp := CreateHuman ;
30927: LD_ADDR_VAR 0 1
30931: PUSH
30932: CALL_OW 44
30936: ST_TO_ADDR
// end ; DialogueOn ;
30937: CALL_OW 6
// if IsOK ( Roth ) then
30941: LD_EXP 74
30945: PPUSH
30946: CALL_OW 302
30950: IFFALSE 30964
// Say ( JMM , DAb-JMM-1 ) ;
30952: LD_EXP 39
30956: PPUSH
30957: LD_STRING DAb-JMM-1
30959: PPUSH
30960: CALL_OW 88
// if IsOK ( Roth ) then
30964: LD_EXP 74
30968: PPUSH
30969: CALL_OW 302
30973: IFFALSE 30997
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
30975: LD_EXP 74
30979: PPUSH
30980: LD_STRING DSurrenderAlliance-Roth-1
30982: PPUSH
30983: CALL_OW 88
// RothCaptured := true ;
30987: LD_ADDR_EXP 33
30991: PUSH
30992: LD_INT 1
30994: ST_TO_ADDR
// end else
30995: GO 31009
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
30997: LD_VAR 0 1
31001: PPUSH
31002: LD_STRING DSurrenderAlliance-Sci1-1
31004: PPUSH
31005: CALL_OW 88
// DialogueOff ;
31009: CALL_OW 7
// allianceDestroyed := true ;
31013: LD_ADDR_EXP 23
31017: PUSH
31018: LD_INT 1
31020: ST_TO_ADDR
// if capturedUnit = 0 then
31021: LD_EXP 34
31025: PUSH
31026: LD_INT 0
31028: EQUAL
31029: IFFALSE 31038
// SetAchievement ( ACH_ALLIANCE ) ;
31031: LD_STRING ACH_ALLIANCE
31033: PPUSH
31034: CALL_OW 543
// if trueAmericans then
31038: LD_EXP 35
31042: IFFALSE 31118
// begin if trueAmericans = 1 then
31044: LD_EXP 35
31048: PUSH
31049: LD_INT 1
31051: EQUAL
31052: IFFALSE 31068
// Say ( JMM , DAb-JMM-1a ) else
31054: LD_EXP 39
31058: PPUSH
31059: LD_STRING DAb-JMM-1a
31061: PPUSH
31062: CALL_OW 88
31066: GO 31080
// Say ( JMM , DAb-JMM-1b ) ;
31068: LD_EXP 39
31072: PPUSH
31073: LD_STRING DAb-JMM-1b
31075: PPUSH
31076: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
31080: LD_EXP 35
31084: PPUSH
31085: CALL_OW 87
// for i in trueAmericans do
31089: LD_ADDR_VAR 0 2
31093: PUSH
31094: LD_EXP 35
31098: PUSH
31099: FOR_IN
31100: IFFALSE 31116
// SetSide ( i , 1 ) ;
31102: LD_VAR 0 2
31106: PPUSH
31107: LD_INT 1
31109: PPUSH
31110: CALL_OW 235
31114: GO 31099
31116: POP
31117: POP
// end ; repeat wait ( 0 0$1 ) ;
31118: LD_INT 35
31120: PPUSH
31121: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
31125: LD_ADDR_VAR 0 2
31129: PUSH
31130: LD_INT 22
31132: PUSH
31133: LD_INT 7
31135: PUSH
31136: EMPTY
31137: LIST
31138: LIST
31139: PUSH
31140: LD_INT 21
31142: PUSH
31143: LD_INT 1
31145: PUSH
31146: EMPTY
31147: LIST
31148: LIST
31149: PUSH
31150: EMPTY
31151: LIST
31152: LIST
31153: PPUSH
31154: CALL_OW 69
31158: PUSH
31159: FOR_IN
31160: IFFALSE 31242
// begin if IsInUnit ( i ) then
31162: LD_VAR 0 2
31166: PPUSH
31167: CALL_OW 310
31171: IFFALSE 31182
// ComExitBuilding ( i ) ;
31173: LD_VAR 0 2
31177: PPUSH
31178: CALL_OW 122
// if IsDriver ( i ) then
31182: LD_VAR 0 2
31186: PPUSH
31187: CALL 100228 0 1
31191: IFFALSE 31202
// ComExitVehicle ( i ) ;
31193: LD_VAR 0 2
31197: PPUSH
31198: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
31202: LD_VAR 0 2
31206: PPUSH
31207: LD_INT 26
31209: PPUSH
31210: CALL_OW 308
31214: NOT
31215: IFFALSE 31231
// AddComMoveToArea ( i , allianceEscapeArea ) else
31217: LD_VAR 0 2
31221: PPUSH
31222: LD_INT 26
31224: PPUSH
31225: CALL_OW 173
31229: GO 31240
// RemoveUnit ( i ) ;
31231: LD_VAR 0 2
31235: PPUSH
31236: CALL_OW 64
// end ;
31240: GO 31159
31242: POP
31243: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
31244: LD_INT 22
31246: PUSH
31247: LD_INT 7
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 21
31256: PUSH
31257: LD_INT 1
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: EMPTY
31265: LIST
31266: LIST
31267: PPUSH
31268: CALL_OW 69
31272: NOT
31273: IFFALSE 31118
// end ;
31275: PPOPN 2
31277: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
31278: LD_INT 0
31280: PPUSH
31281: PPUSH
// if not unit then
31282: LD_VAR 0 1
31286: NOT
31287: IFFALSE 31291
// exit ;
31289: GO 32789
// DoNotAttack ( 7 , unit ) ;
31291: LD_INT 7
31293: PPUSH
31294: LD_VAR 0 1
31298: PPUSH
31299: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
31303: LD_VAR 0 1
31307: PPUSH
31308: LD_INT 260
31310: PPUSH
31311: LD_INT 235
31313: PPUSH
31314: LD_INT 3
31316: PPUSH
31317: LD_INT 1
31319: PPUSH
31320: CALL_OW 483
// SetSide ( unit , 4 ) ;
31324: LD_VAR 0 1
31328: PPUSH
31329: LD_INT 4
31331: PPUSH
31332: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
31336: LD_ADDR_EXP 34
31340: PUSH
31341: LD_EXP 34
31345: PUSH
31346: LD_INT 1
31348: PLUS
31349: ST_TO_ADDR
// wait ( 0 0$2 ) ;
31350: LD_INT 70
31352: PPUSH
31353: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
31357: LD_INT 260
31359: PPUSH
31360: LD_INT 235
31362: PPUSH
31363: LD_INT 1
31365: PPUSH
31366: LD_INT 8
31368: NEG
31369: PPUSH
31370: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
31374: LD_VAR 0 1
31378: PPUSH
31379: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
31383: LD_VAR 0 1
31387: PPUSH
31388: LD_EXP 74
31392: PPUSH
31393: CALL_OW 119
// DialogueOn ;
31397: CALL_OW 6
// case unit of JMM :
31401: LD_VAR 0 1
31405: PUSH
31406: LD_EXP 39
31410: DOUBLE
31411: EQUAL
31412: IFTRUE 31416
31414: GO 31431
31416: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
31417: LD_EXP 39
31421: PPUSH
31422: LD_STRING DA1-JMM-1
31424: PPUSH
31425: CALL_OW 91
31429: GO 31873
31431: LD_EXP 40
31435: DOUBLE
31436: EQUAL
31437: IFTRUE 31441
31439: GO 31456
31441: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
31442: LD_EXP 40
31446: PPUSH
31447: LD_STRING DA1-Joan-1
31449: PPUSH
31450: CALL_OW 91
31454: GO 31873
31456: LD_EXP 42
31460: DOUBLE
31461: EQUAL
31462: IFTRUE 31466
31464: GO 31481
31466: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
31467: LD_EXP 42
31471: PPUSH
31472: LD_STRING DA1-Lisa-1
31474: PPUSH
31475: CALL_OW 91
31479: GO 31873
31481: LD_EXP 43
31485: DOUBLE
31486: EQUAL
31487: IFTRUE 31491
31489: GO 31506
31491: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
31492: LD_EXP 43
31496: PPUSH
31497: LD_STRING DA1-Don-1
31499: PPUSH
31500: CALL_OW 91
31504: GO 31873
31506: LD_EXP 50
31510: DOUBLE
31511: EQUAL
31512: IFTRUE 31516
31514: GO 31531
31516: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
31517: LD_EXP 50
31521: PPUSH
31522: LD_STRING DA1-Corn-1
31524: PPUSH
31525: CALL_OW 91
31529: GO 31873
31531: LD_EXP 46
31535: DOUBLE
31536: EQUAL
31537: IFTRUE 31541
31539: GO 31556
31541: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
31542: LD_EXP 46
31546: PPUSH
31547: LD_STRING DA1-Den-1
31549: PPUSH
31550: CALL_OW 91
31554: GO 31873
31556: LD_EXP 44
31560: DOUBLE
31561: EQUAL
31562: IFTRUE 31566
31564: GO 31581
31566: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
31567: LD_EXP 44
31571: PPUSH
31572: LD_STRING DA1-Bobby-1
31574: PPUSH
31575: CALL_OW 91
31579: GO 31873
31581: LD_EXP 48
31585: DOUBLE
31586: EQUAL
31587: IFTRUE 31591
31589: GO 31606
31591: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
31592: LD_EXP 48
31596: PPUSH
31597: LD_STRING DA1-Glad-1
31599: PPUSH
31600: CALL_OW 91
31604: GO 31873
31606: LD_EXP 45
31610: DOUBLE
31611: EQUAL
31612: IFTRUE 31616
31614: GO 31631
31616: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
31617: LD_EXP 45
31621: PPUSH
31622: LD_STRING DA1-Cyrus-1
31624: PPUSH
31625: CALL_OW 91
31629: GO 31873
31631: LD_EXP 41
31635: DOUBLE
31636: EQUAL
31637: IFTRUE 31641
31639: GO 31656
31641: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
31642: LD_EXP 41
31646: PPUSH
31647: LD_STRING DA1-Huck-1
31649: PPUSH
31650: CALL_OW 91
31654: GO 31873
31656: LD_EXP 55
31660: DOUBLE
31661: EQUAL
31662: IFTRUE 31666
31664: GO 31681
31666: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
31667: LD_EXP 55
31671: PPUSH
31672: LD_STRING DA1-Huck-1
31674: PPUSH
31675: CALL_OW 91
31679: GO 31873
31681: LD_EXP 47
31685: DOUBLE
31686: EQUAL
31687: IFTRUE 31691
31689: GO 31706
31691: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
31692: LD_EXP 47
31696: PPUSH
31697: LD_STRING DA1-Brown-1
31699: PPUSH
31700: CALL_OW 91
31704: GO 31873
31706: LD_EXP 51
31710: DOUBLE
31711: EQUAL
31712: IFTRUE 31716
31714: GO 31731
31716: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
31717: LD_EXP 51
31721: PPUSH
31722: LD_STRING DA1-Gary-1
31724: PPUSH
31725: CALL_OW 91
31729: GO 31873
31731: LD_EXP 54
31735: DOUBLE
31736: EQUAL
31737: IFTRUE 31741
31739: GO 31756
31741: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
31742: LD_EXP 54
31746: PPUSH
31747: LD_STRING DA1-Con-1
31749: PPUSH
31750: CALL_OW 91
31754: GO 31873
31756: LD_EXP 60
31760: DOUBLE
31761: EQUAL
31762: IFTRUE 31766
31764: GO 31781
31766: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
31767: LD_EXP 60
31771: PPUSH
31772: LD_STRING DA1-Kurt-1
31774: PPUSH
31775: CALL_OW 91
31779: GO 31873
31781: LD_EXP 53
31785: DOUBLE
31786: EQUAL
31787: IFTRUE 31791
31789: GO 31806
31791: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
31792: LD_EXP 53
31796: PPUSH
31797: LD_STRING DA1-Yam-1
31799: PPUSH
31800: CALL_OW 91
31804: GO 31873
31806: LD_EXP 52
31810: DOUBLE
31811: EQUAL
31812: IFTRUE 31816
31814: GO 31831
31816: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
31817: LD_EXP 52
31821: PPUSH
31822: LD_STRING DA1-Frank-1
31824: PPUSH
31825: CALL_OW 91
31829: GO 31873
31831: POP
// begin if GetSex ( unit ) = sex_male then
31832: LD_VAR 0 1
31836: PPUSH
31837: CALL_OW 258
31841: PUSH
31842: LD_INT 1
31844: EQUAL
31845: IFFALSE 31861
// ForceSay ( unit , DA1-Sol1-1 ) else
31847: LD_VAR 0 1
31851: PPUSH
31852: LD_STRING DA1-Sol1-1
31854: PPUSH
31855: CALL_OW 91
31859: GO 31873
// ForceSay ( unit , DA1-FSol1-1 ) ;
31861: LD_VAR 0 1
31865: PPUSH
31866: LD_STRING DA1-FSol1-1
31868: PPUSH
31869: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
31873: LD_EXP 74
31877: PPUSH
31878: LD_STRING DA-Roth-1
31880: PPUSH
31881: CALL_OW 88
// if capturedUnit = 1 then
31885: LD_EXP 34
31889: PUSH
31890: LD_INT 1
31892: EQUAL
31893: IFFALSE 31921
// begin Say ( Simms , DA-Sim-1 ) ;
31895: LD_EXP 75
31899: PPUSH
31900: LD_STRING DA-Sim-1
31902: PPUSH
31903: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
31907: LD_EXP 74
31911: PPUSH
31912: LD_STRING DA-Roth-2
31914: PPUSH
31915: CALL_OW 88
// end else
31919: GO 31933
// Say ( Simms , DA-Sim-2 ) ;
31921: LD_EXP 75
31925: PPUSH
31926: LD_STRING DA-Sim-2
31928: PPUSH
31929: CALL_OW 88
// case unit of JMM :
31933: LD_VAR 0 1
31937: PUSH
31938: LD_EXP 39
31942: DOUBLE
31943: EQUAL
31944: IFTRUE 31948
31946: GO 31963
31948: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
31949: LD_EXP 39
31953: PPUSH
31954: LD_STRING DA1-JMM-1a
31956: PPUSH
31957: CALL_OW 91
31961: GO 32470
31963: LD_EXP 40
31967: DOUBLE
31968: EQUAL
31969: IFTRUE 31973
31971: GO 31988
31973: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
31974: LD_EXP 40
31978: PPUSH
31979: LD_STRING DA1-Joan-1a
31981: PPUSH
31982: CALL_OW 91
31986: GO 32470
31988: LD_EXP 42
31992: DOUBLE
31993: EQUAL
31994: IFTRUE 31998
31996: GO 32013
31998: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
31999: LD_EXP 42
32003: PPUSH
32004: LD_STRING DA1-Lisa-1a
32006: PPUSH
32007: CALL_OW 91
32011: GO 32470
32013: LD_EXP 43
32017: DOUBLE
32018: EQUAL
32019: IFTRUE 32023
32021: GO 32038
32023: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
32024: LD_EXP 43
32028: PPUSH
32029: LD_STRING DA1-Don-1a
32031: PPUSH
32032: CALL_OW 91
32036: GO 32470
32038: LD_EXP 50
32042: DOUBLE
32043: EQUAL
32044: IFTRUE 32048
32046: GO 32063
32048: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
32049: LD_EXP 50
32053: PPUSH
32054: LD_STRING DA1-Corn-1a
32056: PPUSH
32057: CALL_OW 91
32061: GO 32470
32063: LD_EXP 46
32067: DOUBLE
32068: EQUAL
32069: IFTRUE 32073
32071: GO 32088
32073: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
32074: LD_EXP 46
32078: PPUSH
32079: LD_STRING DA1-Den-1a
32081: PPUSH
32082: CALL_OW 91
32086: GO 32470
32088: LD_EXP 44
32092: DOUBLE
32093: EQUAL
32094: IFTRUE 32098
32096: GO 32113
32098: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
32099: LD_EXP 44
32103: PPUSH
32104: LD_STRING DA1-Bobby-1a
32106: PPUSH
32107: CALL_OW 91
32111: GO 32470
32113: LD_EXP 48
32117: DOUBLE
32118: EQUAL
32119: IFTRUE 32123
32121: GO 32138
32123: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
32124: LD_EXP 48
32128: PPUSH
32129: LD_STRING DA1-Glad-1a
32131: PPUSH
32132: CALL_OW 91
32136: GO 32470
32138: LD_EXP 45
32142: DOUBLE
32143: EQUAL
32144: IFTRUE 32148
32146: GO 32163
32148: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
32149: LD_EXP 45
32153: PPUSH
32154: LD_STRING DA1-Cyrus-1a
32156: PPUSH
32157: CALL_OW 91
32161: GO 32470
32163: LD_EXP 41
32167: DOUBLE
32168: EQUAL
32169: IFTRUE 32173
32171: GO 32188
32173: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
32174: LD_EXP 41
32178: PPUSH
32179: LD_STRING DA1-Huck-1a
32181: PPUSH
32182: CALL_OW 91
32186: GO 32470
32188: LD_EXP 55
32192: DOUBLE
32193: EQUAL
32194: IFTRUE 32198
32196: GO 32213
32198: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
32199: LD_EXP 55
32203: PPUSH
32204: LD_STRING DA1-Huck-1a
32206: PPUSH
32207: CALL_OW 91
32211: GO 32470
32213: LD_EXP 47
32217: DOUBLE
32218: EQUAL
32219: IFTRUE 32223
32221: GO 32238
32223: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
32224: LD_EXP 47
32228: PPUSH
32229: LD_STRING DA1-Brown-1a
32231: PPUSH
32232: CALL_OW 91
32236: GO 32470
32238: LD_EXP 51
32242: DOUBLE
32243: EQUAL
32244: IFTRUE 32248
32246: GO 32263
32248: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
32249: LD_EXP 51
32253: PPUSH
32254: LD_STRING DA1-Gary-1a
32256: PPUSH
32257: CALL_OW 91
32261: GO 32470
32263: LD_EXP 54
32267: DOUBLE
32268: EQUAL
32269: IFTRUE 32273
32271: GO 32288
32273: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
32274: LD_EXP 54
32278: PPUSH
32279: LD_STRING DA1-Con-1a
32281: PPUSH
32282: CALL_OW 91
32286: GO 32470
32288: LD_EXP 60
32292: DOUBLE
32293: EQUAL
32294: IFTRUE 32298
32296: GO 32313
32298: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
32299: LD_EXP 60
32303: PPUSH
32304: LD_STRING DA1-Kurt-1a
32306: PPUSH
32307: CALL_OW 91
32311: GO 32470
32313: LD_EXP 53
32317: DOUBLE
32318: EQUAL
32319: IFTRUE 32323
32321: GO 32338
32323: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
32324: LD_EXP 53
32328: PPUSH
32329: LD_STRING DA1-Yam-1a
32331: PPUSH
32332: CALL_OW 91
32336: GO 32470
32338: LD_EXP 52
32342: DOUBLE
32343: EQUAL
32344: IFTRUE 32348
32346: GO 32363
32348: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
32349: LD_EXP 52
32353: PPUSH
32354: LD_STRING DA1-Frank-1a
32356: PPUSH
32357: CALL_OW 91
32361: GO 32470
32363: POP
// begin join := rand ( 0 , 1 ) ;
32364: LD_ADDR_VAR 0 3
32368: PUSH
32369: LD_INT 0
32371: PPUSH
32372: LD_INT 1
32374: PPUSH
32375: CALL_OW 12
32379: ST_TO_ADDR
// if join then
32380: LD_VAR 0 3
32384: IFFALSE 32429
// begin if GetSex ( unit ) = sex_male then
32386: LD_VAR 0 1
32390: PPUSH
32391: CALL_OW 258
32395: PUSH
32396: LD_INT 1
32398: EQUAL
32399: IFFALSE 32415
// ForceSay ( unit , DA1-Sol1-1b ) else
32401: LD_VAR 0 1
32405: PPUSH
32406: LD_STRING DA1-Sol1-1b
32408: PPUSH
32409: CALL_OW 91
32413: GO 32427
// ForceSay ( unit , DA1-FSol1-1b ) ;
32415: LD_VAR 0 1
32419: PPUSH
32420: LD_STRING DA1-FSol1-1b
32422: PPUSH
32423: CALL_OW 91
// end else
32427: GO 32470
// begin if GetSex ( unit ) = sex_male then
32429: LD_VAR 0 1
32433: PPUSH
32434: CALL_OW 258
32438: PUSH
32439: LD_INT 1
32441: EQUAL
32442: IFFALSE 32458
// ForceSay ( unit , DA1-Sol1-1a ) else
32444: LD_VAR 0 1
32448: PPUSH
32449: LD_STRING DA1-Sol1-1a
32451: PPUSH
32452: CALL_OW 91
32456: GO 32470
// ForceSay ( unit , DA1-FSol1-1a ) ;
32458: LD_VAR 0 1
32462: PPUSH
32463: LD_STRING DA1-FSol1-1a
32465: PPUSH
32466: CALL_OW 91
// end ; end ; end ; if unit = JMM then
32470: LD_VAR 0 1
32474: PUSH
32475: LD_EXP 39
32479: EQUAL
32480: IFFALSE 32491
// begin YouLost ( JMMCaptured ) ;
32482: LD_STRING JMMCaptured
32484: PPUSH
32485: CALL_OW 104
// exit ;
32489: GO 32789
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
32491: LD_VAR 0 1
32495: PUSH
32496: LD_EXP 43
32500: PUSH
32501: LD_EXP 46
32505: PUSH
32506: LD_EXP 44
32510: PUSH
32511: LD_EXP 41
32515: PUSH
32516: LD_EXP 55
32520: PUSH
32521: LD_EXP 47
32525: PUSH
32526: LD_EXP 53
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: LIST
32535: LIST
32536: LIST
32537: LIST
32538: LIST
32539: IN
32540: PUSH
32541: LD_VAR 0 3
32545: OR
32546: IFFALSE 32645
// begin Say ( Roth , DA-Roth-3 ) ;
32548: LD_EXP 74
32552: PPUSH
32553: LD_STRING DA-Roth-3
32555: PPUSH
32556: CALL_OW 88
// SetSide ( unit , 7 ) ;
32560: LD_VAR 0 1
32564: PPUSH
32565: LD_INT 7
32567: PPUSH
32568: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
32572: LD_ADDR_EXP 116
32576: PUSH
32577: LD_EXP 116
32581: PPUSH
32582: LD_INT 1
32584: PPUSH
32585: LD_EXP 116
32589: PUSH
32590: LD_INT 1
32592: ARRAY
32593: PUSH
32594: LD_VAR 0 1
32598: ADD
32599: PPUSH
32600: CALL_OW 1
32604: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32605: LD_INT 260
32607: PPUSH
32608: LD_INT 235
32610: PPUSH
32611: LD_INT 1
32613: PPUSH
32614: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32618: LD_VAR 0 1
32622: PPUSH
32623: LD_INT 1000
32625: PPUSH
32626: CALL_OW 234
// DialogueOff ;
32630: CALL_OW 7
// ComFree ( unit ) ;
32634: LD_VAR 0 1
32638: PPUSH
32639: CALL_OW 139
// end else
32643: GO 32726
// begin Say ( Roth , DA-Roth-3a ) ;
32645: LD_EXP 74
32649: PPUSH
32650: LD_STRING DA-Roth-3a
32652: PPUSH
32653: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
32657: LD_ADDR_EXP 35
32661: PUSH
32662: LD_EXP 35
32666: PUSH
32667: LD_VAR 0 1
32671: ADD
32672: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
32673: LD_INT 260
32675: PPUSH
32676: LD_INT 235
32678: PPUSH
32679: LD_INT 1
32681: PPUSH
32682: CALL_OW 331
// SetLives ( unit , 1000 ) ;
32686: LD_VAR 0 1
32690: PPUSH
32691: LD_INT 1000
32693: PPUSH
32694: CALL_OW 234
// DialogueOff ;
32698: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
32702: LD_VAR 0 1
32706: PPUSH
32707: LD_INT 272
32709: PPUSH
32710: LD_INT 254
32712: PPUSH
32713: CALL_OW 111
// AddComHold ( unit ) ;
32717: LD_VAR 0 1
32721: PPUSH
32722: CALL_OW 200
// end ; if capturedUnit = 1 then
32726: LD_EXP 34
32730: PUSH
32731: LD_INT 1
32733: EQUAL
32734: IFFALSE 32789
// begin DialogueOn ;
32736: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
32740: LD_EXP 39
32744: PPUSH
32745: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
32749: LD_EXP 39
32753: PPUSH
32754: LD_STRING DAa-JMM-1
32756: PPUSH
32757: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
32761: LD_EXP 39
32765: PPUSH
32766: LD_STRING DAa-JMM-1a
32768: PPUSH
32769: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
32773: LD_EXP 39
32777: PPUSH
32778: LD_STRING DAa-JMM-1b
32780: PPUSH
32781: CALL_OW 88
// DialogueOff ;
32785: CALL_OW 7
// end ; end ;
32789: LD_VAR 0 2
32793: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
32794: LD_EXP 15
32798: PUSH
32799: LD_INT 13
32801: GREATEREQUAL
32802: PUSH
32803: LD_INT 22
32805: PUSH
32806: LD_INT 2
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: PUSH
32813: LD_INT 21
32815: PUSH
32816: LD_INT 1
32818: PUSH
32819: EMPTY
32820: LIST
32821: LIST
32822: PUSH
32823: EMPTY
32824: LIST
32825: LIST
32826: PPUSH
32827: CALL_OW 69
32831: PUSH
32832: LD_INT 0
32834: EQUAL
32835: AND
32836: PUSH
32837: LD_INT 22
32839: PUSH
32840: LD_INT 2
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 33
32849: PUSH
32850: LD_INT 5
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 21
32859: PUSH
32860: LD_INT 2
32862: PUSH
32863: EMPTY
32864: LIST
32865: LIST
32866: PUSH
32867: LD_INT 50
32869: PUSH
32870: EMPTY
32871: LIST
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: PPUSH
32879: CALL_OW 69
32883: PUSH
32884: LD_INT 0
32886: EQUAL
32887: AND
32888: PUSH
32889: LD_EXP 21
32893: AND
32894: PUSH
32895: LD_EXP 22
32899: AND
32900: PUSH
32901: LD_EXP 23
32905: AND
32906: IFFALSE 33555
32908: GO 32910
32910: DISABLE
32911: LD_INT 0
32913: PPUSH
32914: PPUSH
32915: PPUSH
// begin m1 := false ;
32916: LD_ADDR_VAR 0 1
32920: PUSH
32921: LD_INT 0
32923: ST_TO_ADDR
// m2 := false ;
32924: LD_ADDR_VAR 0 2
32928: PUSH
32929: LD_INT 0
32931: ST_TO_ADDR
// m3 := false ;
32932: LD_ADDR_VAR 0 3
32936: PUSH
32937: LD_INT 0
32939: ST_TO_ADDR
// if not bombExploded then
32940: LD_EXP 37
32944: NOT
32945: IFFALSE 32954
// SetAchievement ( ACH_SIBROCKET ) ;
32947: LD_STRING ACH_SIBROCKET
32949: PPUSH
32950: CALL_OW 543
// if tick <= 120 120$00 then
32954: LD_OWVAR 1
32958: PUSH
32959: LD_INT 252000
32961: LESSEQUAL
32962: IFFALSE 32978
// begin wait ( 3 ) ;
32964: LD_INT 3
32966: PPUSH
32967: CALL_OW 67
// SetAchievement ( ACH_ASPEED_15 ) ;
32971: LD_STRING ACH_ASPEED_15
32973: PPUSH
32974: CALL_OW 543
// end ; CenterNowOnUnits ( JMM ) ;
32978: LD_EXP 39
32982: PPUSH
32983: CALL_OW 87
// music_class := 5 ;
32987: LD_ADDR_OWVAR 72
32991: PUSH
32992: LD_INT 5
32994: ST_TO_ADDR
// music_nat := 5 ;
32995: LD_ADDR_OWVAR 71
32999: PUSH
33000: LD_INT 5
33002: ST_TO_ADDR
// DialogueOn ;
33003: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
33007: LD_EXP 39
33011: PPUSH
33012: LD_STRING D20-JMM-1
33014: PPUSH
33015: CALL_OW 88
// if IsOK ( Joan ) then
33019: LD_EXP 40
33023: PPUSH
33024: CALL_OW 302
33028: IFFALSE 33042
// Say ( Joan , D20-Joan-1 ) ;
33030: LD_EXP 40
33034: PPUSH
33035: LD_STRING D20-Joan-1
33037: PPUSH
33038: CALL_OW 88
// if IsOk ( Lisa ) then
33042: LD_EXP 42
33046: PPUSH
33047: CALL_OW 302
33051: IFFALSE 33065
// Say ( Lisa , D20-Lisa-1 ) ;
33053: LD_EXP 42
33057: PPUSH
33058: LD_STRING D20-Lisa-1
33060: PPUSH
33061: CALL_OW 88
// if IsOk ( Donaldson ) then
33065: LD_EXP 43
33069: PPUSH
33070: CALL_OW 302
33074: IFFALSE 33088
// Say ( Donaldson , D20-Don-1 ) ;
33076: LD_EXP 43
33080: PPUSH
33081: LD_STRING D20-Don-1
33083: PPUSH
33084: CALL_OW 88
// if IsOK ( Cornel ) then
33088: LD_EXP 50
33092: PPUSH
33093: CALL_OW 302
33097: IFFALSE 33111
// Say ( Cornel , D20-Corn-1 ) ;
33099: LD_EXP 50
33103: PPUSH
33104: LD_STRING D20-Corn-1
33106: PPUSH
33107: CALL_OW 88
// if IsOk ( Denis ) then
33111: LD_EXP 46
33115: PPUSH
33116: CALL_OW 302
33120: IFFALSE 33134
// Say ( Denis , D20-Den-1 ) ;
33122: LD_EXP 46
33126: PPUSH
33127: LD_STRING D20-Den-1
33129: PPUSH
33130: CALL_OW 88
// if IsOk ( Bobby ) then
33134: LD_EXP 44
33138: PPUSH
33139: CALL_OW 302
33143: IFFALSE 33157
// Say ( Bobby , D20-Bobby-1 ) ;
33145: LD_EXP 44
33149: PPUSH
33150: LD_STRING D20-Bobby-1
33152: PPUSH
33153: CALL_OW 88
// if IsOk ( Gladstone ) then
33157: LD_EXP 48
33161: PPUSH
33162: CALL_OW 302
33166: IFFALSE 33180
// Say ( Gladstone , D20-Glad-1 ) ;
33168: LD_EXP 48
33172: PPUSH
33173: LD_STRING D20-Glad-1
33175: PPUSH
33176: CALL_OW 88
// if IsOk ( Cyrus ) then
33180: LD_EXP 45
33184: PPUSH
33185: CALL_OW 302
33189: IFFALSE 33203
// Say ( Cyrus , D20-Cyrus-1 ) ;
33191: LD_EXP 45
33195: PPUSH
33196: LD_STRING D20-Cyrus-1
33198: PPUSH
33199: CALL_OW 88
// if IsOk ( Stevens ) then
33203: LD_EXP 41
33207: PPUSH
33208: CALL_OW 302
33212: IFFALSE 33226
// Say ( Stevens , D20-Huck-1 ) ;
33214: LD_EXP 41
33218: PPUSH
33219: LD_STRING D20-Huck-1
33221: PPUSH
33222: CALL_OW 88
// if IsOk ( Brown ) then
33226: LD_EXP 47
33230: PPUSH
33231: CALL_OW 302
33235: IFFALSE 33249
// Say ( Brown , D20-Brown-1 ) ;
33237: LD_EXP 47
33241: PPUSH
33242: LD_STRING D20-Brown-1
33244: PPUSH
33245: CALL_OW 88
// if IsOk ( Gary ) then
33249: LD_EXP 51
33253: PPUSH
33254: CALL_OW 302
33258: IFFALSE 33272
// Say ( Gary , D20-Gary-1 ) ;
33260: LD_EXP 51
33264: PPUSH
33265: LD_STRING D20-Gary-1
33267: PPUSH
33268: CALL_OW 88
// if IsOk ( Connie ) then
33272: LD_EXP 54
33276: PPUSH
33277: CALL_OW 302
33281: IFFALSE 33295
// Say ( Connie , D20-Con-1 ) ;
33283: LD_EXP 54
33287: PPUSH
33288: LD_STRING D20-Con-1
33290: PPUSH
33291: CALL_OW 88
// if IsOk ( Kurt ) then
33295: LD_EXP 60
33299: PPUSH
33300: CALL_OW 302
33304: IFFALSE 33318
// Say ( Kurt , D20-Kurt-1 ) ;
33306: LD_EXP 60
33310: PPUSH
33311: LD_STRING D20-Kurt-1
33313: PPUSH
33314: CALL_OW 88
// if IsOk ( Kikuchi ) then
33318: LD_EXP 53
33322: PPUSH
33323: CALL_OW 302
33327: IFFALSE 33341
// Say ( Kikuchi , D20-Yam-1 ) ;
33329: LD_EXP 53
33333: PPUSH
33334: LD_STRING D20-Yam-1
33336: PPUSH
33337: CALL_OW 88
// if IsOk ( Frank ) then
33341: LD_EXP 52
33345: PPUSH
33346: CALL_OW 302
33350: IFFALSE 33364
// Say ( Frank , D20-Frank-1 ) ;
33352: LD_EXP 52
33356: PPUSH
33357: LD_STRING D20-Frank-1
33359: PPUSH
33360: CALL_OW 88
// DialogueOff ;
33364: CALL_OW 7
// if RothCaptured then
33368: LD_EXP 33
33372: IFFALSE 33394
// begin m1 := true ;
33374: LD_ADDR_VAR 0 1
33378: PUSH
33379: LD_INT 1
33381: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
33382: LD_STRING Roth
33384: PPUSH
33385: LD_INT 1
33387: PPUSH
33388: CALL_OW 101
// end else
33392: GO 33405
// AddMedal ( Roth , - 1 ) ;
33394: LD_STRING Roth
33396: PPUSH
33397: LD_INT 1
33399: NEG
33400: PPUSH
33401: CALL_OW 101
// if not allowBehemothConstruct or behemothDestroyedBeforeFinish then
33405: LD_EXP 25
33409: NOT
33410: PUSH
33411: LD_EXP 27
33415: OR
33416: IFFALSE 33438
// begin m2 := true ;
33418: LD_ADDR_VAR 0 2
33422: PUSH
33423: LD_INT 1
33425: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
33426: LD_STRING Project
33428: PPUSH
33429: LD_INT 1
33431: PPUSH
33432: CALL_OW 101
// end else
33436: GO 33449
// AddMedal ( Project , - 1 ) ;
33438: LD_STRING Project
33440: PPUSH
33441: LD_INT 1
33443: NEG
33444: PPUSH
33445: CALL_OW 101
// if lostCounter = 0 then
33449: LD_EXP 32
33453: PUSH
33454: LD_INT 0
33456: EQUAL
33457: IFFALSE 33479
// begin m3 := true ;
33459: LD_ADDR_VAR 0 3
33463: PUSH
33464: LD_INT 1
33466: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
33467: LD_STRING NoLosses
33469: PPUSH
33470: LD_INT 1
33472: PPUSH
33473: CALL_OW 101
// end else
33477: GO 33490
// AddMedal ( NoLosses , - 1 ) ;
33479: LD_STRING NoLosses
33481: PPUSH
33482: LD_INT 1
33484: NEG
33485: PPUSH
33486: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
33490: LD_VAR 0 1
33494: PUSH
33495: LD_VAR 0 2
33499: AND
33500: PUSH
33501: LD_VAR 0 3
33505: AND
33506: PUSH
33507: LD_OWVAR 67
33511: PUSH
33512: LD_INT 3
33514: GREATEREQUAL
33515: AND
33516: IFFALSE 33528
// SetAchievementEX ( ACH_AMER , 15 ) ;
33518: LD_STRING ACH_AMER
33520: PPUSH
33521: LD_INT 15
33523: PPUSH
33524: CALL_OW 564
// GiveMedals ( MAIN ) ;
33528: LD_STRING MAIN
33530: PPUSH
33531: CALL_OW 102
// music_class := 4 ;
33535: LD_ADDR_OWVAR 72
33539: PUSH
33540: LD_INT 4
33542: ST_TO_ADDR
// music_nat := 1 ;
33543: LD_ADDR_OWVAR 71
33547: PUSH
33548: LD_INT 1
33550: ST_TO_ADDR
// YouWin ;
33551: CALL_OW 103
// end ; end_of_file
33555: PPOPN 3
33557: END
// export function CustomEvent ( event ) ; begin
33558: LD_INT 0
33560: PPUSH
// end ;
33561: LD_VAR 0 2
33565: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
33566: LD_VAR 0 1
33570: PUSH
33571: LD_INT 1
33573: EQUAL
33574: PUSH
33575: LD_VAR 0 2
33579: PUSH
33580: LD_INT 4
33582: EQUAL
33583: AND
33584: PUSH
33585: LD_EXP 58
33589: PPUSH
33590: CALL_OW 300
33594: AND
33595: IFFALSE 33611
// begin wait ( 0 0$2 ) ;
33597: LD_INT 70
33599: PPUSH
33600: CALL_OW 67
// YouLost ( Dismissed ) ;
33604: LD_STRING Dismissed
33606: PPUSH
33607: CALL_OW 104
// end ; end ;
33611: PPOPN 2
33613: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
33614: LD_VAR 0 2
33618: PPUSH
33619: LD_VAR 0 3
33623: PPUSH
33624: LD_INT 18
33626: PPUSH
33627: CALL_OW 309
33631: IFFALSE 33640
// YouLost ( Motherlode3 ) ;
33633: LD_STRING Motherlode3
33635: PPUSH
33636: CALL_OW 104
// end ;
33640: PPOPN 3
33642: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
33643: LD_EXP 27
33647: NOT
33648: IFFALSE 33658
// behemothDone := true ;
33650: LD_ADDR_EXP 28
33654: PUSH
33655: LD_INT 1
33657: ST_TO_ADDR
// end ;
33658: PPOPN 1
33660: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 then
33661: LD_VAR 0 1
33665: PPUSH
33666: CALL_OW 255
33670: PUSH
33671: LD_INT 1
33673: EQUAL
33674: IFFALSE 33684
// bombExploded := true ;
33676: LD_ADDR_EXP 37
33680: PUSH
33681: LD_INT 1
33683: ST_TO_ADDR
// if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
33684: LD_VAR 0 1
33688: PPUSH
33689: CALL_OW 255
33693: PUSH
33694: LD_INT 1
33696: EQUAL
33697: PUSH
33698: LD_EXP 30
33702: AND
33703: PUSH
33704: LD_INT 22
33706: PUSH
33707: LD_INT 3
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 34
33716: PUSH
33717: LD_INT 48
33719: PUSH
33720: EMPTY
33721: LIST
33722: LIST
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PPUSH
33728: CALL_OW 69
33732: AND
33733: PUSH
33734: LD_INT 22
33736: PUSH
33737: LD_INT 1
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 34
33746: PUSH
33747: LD_INT 8
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: EMPTY
33755: LIST
33756: LIST
33757: PPUSH
33758: CALL_OW 69
33762: NOT
33763: AND
33764: IFFALSE 33816
// begin wait ( 0 0$5 ) ;
33766: LD_INT 175
33768: PPUSH
33769: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
33773: LD_INT 22
33775: PUSH
33776: LD_INT 3
33778: PUSH
33779: EMPTY
33780: LIST
33781: LIST
33782: PUSH
33783: LD_INT 34
33785: PUSH
33786: LD_INT 48
33788: PUSH
33789: EMPTY
33790: LIST
33791: LIST
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PPUSH
33797: CALL_OW 69
33801: PUSH
33802: LD_INT 1
33804: ARRAY
33805: PPUSH
33806: LD_INT 60
33808: PPUSH
33809: LD_INT 95
33811: PPUSH
33812: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
33816: LD_VAR 0 2
33820: PPUSH
33821: LD_VAR 0 3
33825: PPUSH
33826: LD_INT 18
33828: PPUSH
33829: CALL_OW 309
33833: IFFALSE 33880
// begin if GetSide ( unit ) = 1 then
33835: LD_VAR 0 1
33839: PPUSH
33840: CALL_OW 255
33844: PUSH
33845: LD_INT 1
33847: EQUAL
33848: IFFALSE 33866
// begin wait ( 0 0$6 ) ;
33850: LD_INT 210
33852: PPUSH
33853: CALL_OW 67
// YouLost ( Motherlode2 ) ;
33857: LD_STRING Motherlode2
33859: PPUSH
33860: CALL_OW 104
// end else
33864: GO 33880
// begin wait ( 0 0$6 ) ;
33866: LD_INT 210
33868: PPUSH
33869: CALL_OW 67
// YouLost ( Motherlode1 ) ;
33873: LD_STRING Motherlode1
33875: PPUSH
33876: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
33880: LD_VAR 0 1
33884: PPUSH
33885: CALL_OW 255
33889: PUSH
33890: LD_INT 3
33892: EQUAL
33893: IFFALSE 33914
// begin wait ( 0 0$5 ) ;
33895: LD_INT 175
33897: PPUSH
33898: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
33902: LD_EXP 64
33906: PPUSH
33907: LD_STRING D18-Pla-1
33909: PPUSH
33910: CALL_OW 94
// end ; end ;
33914: PPOPN 3
33916: END
// on UnitDestroyed ( un ) do begin if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] ] ) then
33917: LD_VAR 0 1
33921: PUSH
33922: LD_INT 22
33924: PUSH
33925: LD_INT 1
33927: PUSH
33928: EMPTY
33929: LIST
33930: LIST
33931: PUSH
33932: LD_INT 21
33934: PUSH
33935: LD_INT 1
33937: PUSH
33938: EMPTY
33939: LIST
33940: LIST
33941: PUSH
33942: LD_INT 23
33944: PUSH
33945: LD_INT 1
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: LIST
33956: PPUSH
33957: CALL_OW 69
33961: IN
33962: IFFALSE 33978
// lostCounter := lostCounter + 1 ;
33964: LD_ADDR_EXP 32
33968: PUSH
33969: LD_EXP 32
33973: PUSH
33974: LD_INT 1
33976: PLUS
33977: ST_TO_ADDR
// if un in behemothBuilders then
33978: LD_VAR 0 1
33982: PUSH
33983: LD_EXP 73
33987: IN
33988: IFFALSE 34008
// begin behemothBuilders := behemothBuilders diff un ;
33990: LD_ADDR_EXP 73
33994: PUSH
33995: LD_EXP 73
33999: PUSH
34000: LD_VAR 0 1
34004: DIFF
34005: ST_TO_ADDR
// exit ;
34006: GO 34038
// end ; if un = JMM then
34008: LD_VAR 0 1
34012: PUSH
34013: LD_EXP 39
34017: EQUAL
34018: IFFALSE 34029
// begin YouLost ( JMM ) ;
34020: LD_STRING JMM
34022: PPUSH
34023: CALL_OW 104
// exit ;
34027: GO 34038
// end ; MCE_UnitDestroyed ( un ) ;
34029: LD_VAR 0 1
34033: PPUSH
34034: CALL 62899 0 1
// end ;
34038: PPOPN 1
34040: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
34041: LD_VAR 0 1
34045: PPUSH
34046: LD_VAR 0 2
34050: PPUSH
34051: CALL 65233 0 2
// end ;
34055: PPOPN 2
34057: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
34058: LD_VAR 0 1
34062: PPUSH
34063: CALL 64301 0 1
// end ;
34067: PPOPN 1
34069: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
34070: LD_VAR 0 1
34074: PUSH
34075: LD_INT 22
34077: PUSH
34078: LD_INT 8
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 30
34087: PUSH
34088: LD_INT 2
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 23
34097: PUSH
34098: LD_INT 3
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: EMPTY
34106: LIST
34107: LIST
34108: LIST
34109: PPUSH
34110: CALL_OW 69
34114: IN
34115: IFFALSE 34142
// begin ComUpgrade ( building ) ;
34117: LD_VAR 0 1
34121: PPUSH
34122: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
34126: LD_EXP 61
34130: PPUSH
34131: LD_VAR 0 1
34135: PPUSH
34136: CALL 73734 0 2
// exit ;
34140: GO 34151
// end ; MCE_BuildingComplete ( building ) ;
34142: LD_VAR 0 1
34146: PPUSH
34147: CALL 64542 0 1
// end ;
34151: PPOPN 1
34153: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
34154: LD_VAR 0 1
34158: PPUSH
34159: LD_VAR 0 2
34163: PPUSH
34164: CALL 62595 0 2
// end ;
34168: PPOPN 2
34170: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
34171: LD_VAR 0 1
34175: PPUSH
34176: LD_VAR 0 2
34180: PPUSH
34181: LD_VAR 0 3
34185: PPUSH
34186: LD_VAR 0 4
34190: PPUSH
34191: LD_VAR 0 5
34195: PPUSH
34196: CALL 62215 0 5
// end ;
34200: PPOPN 5
34202: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
34203: LD_VAR 0 1
34207: PPUSH
34208: LD_VAR 0 2
34212: PPUSH
34213: CALL 61796 0 2
// end ;
34217: PPOPN 2
34219: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
34220: LD_VAR 0 1
34224: PPUSH
34225: LD_VAR 0 2
34229: PPUSH
34230: LD_VAR 0 3
34234: PPUSH
34235: LD_VAR 0 4
34239: PPUSH
34240: CALL 61634 0 4
// end ;
34244: PPOPN 4
34246: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
34247: LD_VAR 0 1
34251: PPUSH
34252: LD_VAR 0 2
34256: PPUSH
34257: LD_VAR 0 3
34261: PPUSH
34262: CALL 61409 0 3
// end ;
34266: PPOPN 3
34268: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
34269: LD_VAR 0 1
34273: PPUSH
34274: LD_VAR 0 2
34278: PPUSH
34279: CALL 61294 0 2
// end ;
34283: PPOPN 2
34285: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
34286: LD_VAR 0 1
34290: PPUSH
34291: LD_VAR 0 2
34295: PPUSH
34296: CALL 65528 0 2
// end ;
34300: PPOPN 2
34302: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
34303: LD_VAR 0 1
34307: PPUSH
34308: CALL_OW 255
34312: PUSH
34313: LD_INT 4
34315: EQUAL
34316: PUSH
34317: LD_VAR 0 1
34321: PUSH
34322: LD_EXP 18
34326: PUSH
34327: LD_INT 1
34329: ARRAY
34330: IN
34331: AND
34332: PUSH
34333: LD_EXP 19
34337: AND
34338: IFFALSE 34357
// begin ComMoveXY ( driver , 61 , 93 ) ;
34340: LD_VAR 0 1
34344: PPUSH
34345: LD_INT 61
34347: PPUSH
34348: LD_INT 93
34350: PPUSH
34351: CALL_OW 111
// exit ;
34355: GO 34381
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
34357: LD_VAR 0 1
34361: PPUSH
34362: LD_VAR 0 2
34366: PPUSH
34367: LD_VAR 0 3
34371: PPUSH
34372: LD_VAR 0 4
34376: PPUSH
34377: CALL 65744 0 4
// end ;
34381: PPOPN 4
34383: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
34384: LD_VAR 0 1
34388: PPUSH
34389: LD_VAR 0 2
34393: PPUSH
34394: CALL 61103 0 2
// end ;
34398: PPOPN 2
34400: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
34401: LD_VAR 0 1
34405: PPUSH
34406: CALL 119889 0 1
// end ; end_of_file
34410: PPOPN 1
34412: END
// every 0 0$30 trigger missionStage = 2 do var time ;
34413: LD_EXP 15
34417: PUSH
34418: LD_INT 2
34420: EQUAL
34421: IFFALSE 34904
34423: GO 34425
34425: DISABLE
34426: LD_INT 0
34428: PPUSH
// begin time := 0 0$40 ;
34429: LD_ADDR_VAR 0 1
34433: PUSH
34434: LD_INT 1400
34436: ST_TO_ADDR
// repeat wait ( time ) ;
34437: LD_VAR 0 1
34441: PPUSH
34442: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
34446: LD_INT 1
34448: PPUSH
34449: LD_INT 5
34451: PPUSH
34452: CALL_OW 12
34456: PPUSH
34457: LD_INT 106
34459: PPUSH
34460: LD_INT 150
34462: PPUSH
34463: LD_INT 19
34465: PPUSH
34466: LD_INT 1
34468: PPUSH
34469: CALL_OW 56
// time := time + 0 0$9 ;
34473: LD_ADDR_VAR 0 1
34477: PUSH
34478: LD_VAR 0 1
34482: PUSH
34483: LD_INT 315
34485: PLUS
34486: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
34487: LD_INT 455
34489: PPUSH
34490: LD_INT 840
34492: PPUSH
34493: CALL_OW 12
34497: PPUSH
34498: CALL_OW 67
// if Prob ( 50 ) then
34502: LD_INT 50
34504: PPUSH
34505: CALL_OW 13
34509: IFFALSE 34538
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
34511: LD_INT 1
34513: PPUSH
34514: LD_INT 5
34516: PPUSH
34517: CALL_OW 12
34521: PPUSH
34522: LD_INT 62
34524: PPUSH
34525: LD_INT 108
34527: PPUSH
34528: LD_INT 10
34530: PPUSH
34531: LD_INT 1
34533: PPUSH
34534: CALL_OW 56
// until missionStage > 4 ;
34538: LD_EXP 15
34542: PUSH
34543: LD_INT 4
34545: GREATER
34546: IFFALSE 34437
// repeat wait ( 0 0$1 ) ;
34548: LD_INT 35
34550: PPUSH
34551: CALL_OW 67
// until missionStage = 6 ;
34555: LD_EXP 15
34559: PUSH
34560: LD_INT 6
34562: EQUAL
34563: IFFALSE 34548
// time := 0 0$50 ;
34565: LD_ADDR_VAR 0 1
34569: PUSH
34570: LD_INT 1750
34572: ST_TO_ADDR
// repeat wait ( time ) ;
34573: LD_VAR 0 1
34577: PPUSH
34578: CALL_OW 67
// if Prob ( 50 ) then
34582: LD_INT 50
34584: PPUSH
34585: CALL_OW 13
34589: IFFALSE 34618
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
34591: LD_INT 1
34593: PPUSH
34594: LD_INT 5
34596: PPUSH
34597: CALL_OW 12
34601: PPUSH
34602: LD_INT 106
34604: PPUSH
34605: LD_INT 89
34607: PPUSH
34608: LD_INT 45
34610: PPUSH
34611: LD_INT 1
34613: PPUSH
34614: CALL_OW 56
// time := time + 0 0$2 ;
34618: LD_ADDR_VAR 0 1
34622: PUSH
34623: LD_VAR 0 1
34627: PUSH
34628: LD_INT 70
34630: PLUS
34631: ST_TO_ADDR
// if Prob ( 30 ) then
34632: LD_INT 30
34634: PPUSH
34635: CALL_OW 13
34639: IFFALSE 34685
// begin wait ( rand ( 0 0$11 , 0 0$27 ) ) ;
34641: LD_INT 385
34643: PPUSH
34644: LD_INT 945
34646: PPUSH
34647: CALL_OW 12
34651: PPUSH
34652: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
34656: LD_INT 1
34658: PPUSH
34659: LD_INT 5
34661: PPUSH
34662: CALL_OW 12
34666: PPUSH
34667: LD_INT 21
34669: PPUSH
34670: LD_INT 26
34672: PPUSH
34673: LD_INT 12
34675: PPUSH
34676: LD_INT 1
34678: PPUSH
34679: CALL_OW 56
// end else
34683: GO 34721
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
34685: LD_INT 700
34687: PPUSH
34688: LD_INT 1225
34690: PPUSH
34691: CALL_OW 12
34695: PPUSH
34696: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
34700: LD_INT 1
34702: PPUSH
34703: LD_INT 5
34705: PPUSH
34706: CALL_OW 12
34710: PPUSH
34711: LD_INT 16
34713: PPUSH
34714: LD_INT 1
34716: PPUSH
34717: CALL_OW 55
// end ; if Prob ( 50 ) then
34721: LD_INT 50
34723: PPUSH
34724: CALL_OW 13
34728: IFFALSE 34774
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
34730: LD_INT 700
34732: PPUSH
34733: LD_INT 1050
34735: PPUSH
34736: CALL_OW 12
34740: PPUSH
34741: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
34745: LD_INT 1
34747: PPUSH
34748: LD_INT 5
34750: PPUSH
34751: CALL_OW 12
34755: PPUSH
34756: LD_INT 181
34758: PPUSH
34759: LD_INT 218
34761: PPUSH
34762: LD_INT 16
34764: PPUSH
34765: LD_INT 1
34767: PPUSH
34768: CALL_OW 56
// end else
34772: GO 34810
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
34774: LD_INT 350
34776: PPUSH
34777: LD_INT 525
34779: PPUSH
34780: CALL_OW 12
34784: PPUSH
34785: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
34789: LD_INT 1
34791: PPUSH
34792: LD_INT 5
34794: PPUSH
34795: CALL_OW 12
34799: PPUSH
34800: LD_INT 15
34802: PPUSH
34803: LD_INT 1
34805: PPUSH
34806: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 , 22 ] [ Difficulty ] ) then
34810: LD_INT 45
34812: PUSH
34813: LD_INT 32
34815: PUSH
34816: LD_INT 25
34818: PUSH
34819: LD_INT 22
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: PUSH
34828: LD_OWVAR 67
34832: ARRAY
34833: PPUSH
34834: CALL_OW 13
34838: IFFALSE 34882
// begin wait ( rand ( 0 0$5 , 0 0$9 ) ) ;
34840: LD_INT 175
34842: PPUSH
34843: LD_INT 315
34845: PPUSH
34846: CALL_OW 12
34850: PPUSH
34851: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
34855: LD_INT 1
34857: PPUSH
34858: LD_INT 5
34860: PPUSH
34861: CALL_OW 12
34865: PPUSH
34866: LD_INT 103
34868: PPUSH
34869: LD_INT 140
34871: PPUSH
34872: LD_INT 20
34874: PPUSH
34875: LD_INT 1
34877: PPUSH
34878: CALL_OW 56
// end ; if time > 1 1$20 then
34882: LD_VAR 0 1
34886: PUSH
34887: LD_INT 2800
34889: GREATER
34890: IFFALSE 34900
// time := 0 0$30 ;
34892: LD_ADDR_VAR 0 1
34896: PUSH
34897: LD_INT 1050
34899: ST_TO_ADDR
// until false ;
34900: LD_INT 0
34902: IFFALSE 34573
// end ; end_of_file
34904: PPOPN 1
34906: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
34907: LD_EXP 13
34911: PUSH
34912: LD_EXP 15
34916: PUSH
34917: LD_INT 6
34919: GREATEREQUAL
34920: AND
34921: IFFALSE 34958
34923: GO 34925
34925: DISABLE
// begin enable ;
34926: ENABLE
// missionTime := missionTime + 0 0$1 ;
34927: LD_ADDR_EXP 14
34931: PUSH
34932: LD_EXP 14
34936: PUSH
34937: LD_INT 35
34939: PLUS
34940: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
34941: LD_ADDR_OWVAR 47
34945: PUSH
34946: LD_STRING #Am15-1
34948: PUSH
34949: LD_EXP 14
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: ST_TO_ADDR
// end ; end_of_file
34958: END
// export function InitNature ; begin
34959: LD_INT 0
34961: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
34962: LD_INT 3
34964: PPUSH
34965: LD_INT 3
34967: PPUSH
34968: LD_INT 2
34970: PPUSH
34971: LD_INT 1
34973: PPUSH
34974: LD_INT 1
34976: PPUSH
34977: LD_INT 0
34979: PPUSH
34980: LD_INT 0
34982: PPUSH
34983: LD_INT 20
34985: PPUSH
34986: LD_INT 0
34988: PPUSH
34989: CALL 99248 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
34993: LD_INT 2
34995: PPUSH
34996: LD_INT 1
34998: PPUSH
34999: LD_INT 1
35001: PPUSH
35002: LD_INT 1
35004: PPUSH
35005: LD_INT 1
35007: PPUSH
35008: LD_INT 0
35010: PPUSH
35011: LD_INT 0
35013: PPUSH
35014: LD_INT 21
35016: PPUSH
35017: LD_INT 0
35019: PPUSH
35020: CALL 99248 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
35024: LD_INT 4
35026: PPUSH
35027: LD_INT 1
35029: PPUSH
35030: LD_INT 2
35032: PPUSH
35033: LD_INT 4
35035: PPUSH
35036: LD_INT 2
35038: PPUSH
35039: LD_INT 1
35041: PPUSH
35042: LD_INT 0
35044: PPUSH
35045: LD_INT 22
35047: PPUSH
35048: LD_INT 0
35050: PPUSH
35051: CALL 99248 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
35055: LD_INT 0
35057: PPUSH
35058: LD_INT 0
35060: PPUSH
35061: LD_INT 0
35063: PPUSH
35064: LD_INT 0
35066: PPUSH
35067: LD_INT 0
35069: PPUSH
35070: LD_INT 0
35072: PPUSH
35073: LD_INT 9
35075: PPUSH
35076: LD_INT 0
35078: PPUSH
35079: LD_INT 23
35081: PPUSH
35082: CALL 99248 0 9
// end ; end_of_file
35086: LD_VAR 0 1
35090: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
35091: LD_INT 0
35093: PPUSH
// ar_miner := 81 ;
35094: LD_ADDR_EXP 102
35098: PUSH
35099: LD_INT 81
35101: ST_TO_ADDR
// ar_crane := 88 ;
35102: LD_ADDR_EXP 101
35106: PUSH
35107: LD_INT 88
35109: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
35110: LD_ADDR_EXP 96
35114: PUSH
35115: LD_INT 89
35117: ST_TO_ADDR
// us_hack := 99 ;
35118: LD_ADDR_EXP 97
35122: PUSH
35123: LD_INT 99
35125: ST_TO_ADDR
// us_artillery := 97 ;
35126: LD_ADDR_EXP 98
35130: PUSH
35131: LD_INT 97
35133: ST_TO_ADDR
// ar_bio_bomb := 91 ;
35134: LD_ADDR_EXP 99
35138: PUSH
35139: LD_INT 91
35141: ST_TO_ADDR
// ar_mortar := 92 ;
35142: LD_ADDR_EXP 100
35146: PUSH
35147: LD_INT 92
35149: ST_TO_ADDR
// ru_radar := 98 ;
35150: LD_ADDR_EXP 95
35154: PUSH
35155: LD_INT 98
35157: ST_TO_ADDR
// tech_Artillery := 80 ;
35158: LD_ADDR_EXP 103
35162: PUSH
35163: LD_INT 80
35165: ST_TO_ADDR
// tech_RadMat := 81 ;
35166: LD_ADDR_EXP 104
35170: PUSH
35171: LD_INT 81
35173: ST_TO_ADDR
// tech_BasicTools := 82 ;
35174: LD_ADDR_EXP 105
35178: PUSH
35179: LD_INT 82
35181: ST_TO_ADDR
// tech_Cargo := 83 ;
35182: LD_ADDR_EXP 106
35186: PUSH
35187: LD_INT 83
35189: ST_TO_ADDR
// tech_Track := 84 ;
35190: LD_ADDR_EXP 107
35194: PUSH
35195: LD_INT 84
35197: ST_TO_ADDR
// tech_Crane := 85 ;
35198: LD_ADDR_EXP 108
35202: PUSH
35203: LD_INT 85
35205: ST_TO_ADDR
// tech_Bulldozer := 86 ;
35206: LD_ADDR_EXP 109
35210: PUSH
35211: LD_INT 86
35213: ST_TO_ADDR
// tech_Hovercraft := 87 ;
35214: LD_ADDR_EXP 110
35218: PUSH
35219: LD_INT 87
35221: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
35222: LD_ADDR_EXP 111
35226: PUSH
35227: LD_INT 88
35229: ST_TO_ADDR
// class_mastodont := 31 ;
35230: LD_ADDR_EXP 112
35234: PUSH
35235: LD_INT 31
35237: ST_TO_ADDR
// class_horse := 21 ;
35238: LD_ADDR_EXP 113
35242: PUSH
35243: LD_INT 21
35245: ST_TO_ADDR
// end ;
35246: LD_VAR 0 1
35250: RET
// every 1 do
35251: GO 35253
35253: DISABLE
// InitGlobalVariables ; end_of_file
35254: CALL 35091 0 0
35258: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
35259: LD_INT 0
35261: PPUSH
35262: PPUSH
// skirmish := false ;
35263: LD_ADDR_EXP 114
35267: PUSH
35268: LD_INT 0
35270: ST_TO_ADDR
// debug_mc := false ;
35271: LD_ADDR_EXP 115
35275: PUSH
35276: LD_INT 0
35278: ST_TO_ADDR
// mc_bases := [ ] ;
35279: LD_ADDR_EXP 116
35283: PUSH
35284: EMPTY
35285: ST_TO_ADDR
// mc_sides := [ ] ;
35286: LD_ADDR_EXP 142
35290: PUSH
35291: EMPTY
35292: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
35293: LD_ADDR_EXP 117
35297: PUSH
35298: EMPTY
35299: ST_TO_ADDR
// mc_building_repairs := [ ] ;
35300: LD_ADDR_EXP 118
35304: PUSH
35305: EMPTY
35306: ST_TO_ADDR
// mc_need_heal := [ ] ;
35307: LD_ADDR_EXP 119
35311: PUSH
35312: EMPTY
35313: ST_TO_ADDR
// mc_healers := [ ] ;
35314: LD_ADDR_EXP 120
35318: PUSH
35319: EMPTY
35320: ST_TO_ADDR
// mc_build_list := [ ] ;
35321: LD_ADDR_EXP 121
35325: PUSH
35326: EMPTY
35327: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
35328: LD_ADDR_EXP 148
35332: PUSH
35333: EMPTY
35334: ST_TO_ADDR
// mc_builders := [ ] ;
35335: LD_ADDR_EXP 122
35339: PUSH
35340: EMPTY
35341: ST_TO_ADDR
// mc_construct_list := [ ] ;
35342: LD_ADDR_EXP 123
35346: PUSH
35347: EMPTY
35348: ST_TO_ADDR
// mc_turret_list := [ ] ;
35349: LD_ADDR_EXP 124
35353: PUSH
35354: EMPTY
35355: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
35356: LD_ADDR_EXP 125
35360: PUSH
35361: EMPTY
35362: ST_TO_ADDR
// mc_miners := [ ] ;
35363: LD_ADDR_EXP 130
35367: PUSH
35368: EMPTY
35369: ST_TO_ADDR
// mc_mines := [ ] ;
35370: LD_ADDR_EXP 129
35374: PUSH
35375: EMPTY
35376: ST_TO_ADDR
// mc_minefields := [ ] ;
35377: LD_ADDR_EXP 131
35381: PUSH
35382: EMPTY
35383: ST_TO_ADDR
// mc_crates := [ ] ;
35384: LD_ADDR_EXP 132
35388: PUSH
35389: EMPTY
35390: ST_TO_ADDR
// mc_crates_collector := [ ] ;
35391: LD_ADDR_EXP 133
35395: PUSH
35396: EMPTY
35397: ST_TO_ADDR
// mc_crates_area := [ ] ;
35398: LD_ADDR_EXP 134
35402: PUSH
35403: EMPTY
35404: ST_TO_ADDR
// mc_vehicles := [ ] ;
35405: LD_ADDR_EXP 135
35409: PUSH
35410: EMPTY
35411: ST_TO_ADDR
// mc_attack := [ ] ;
35412: LD_ADDR_EXP 136
35416: PUSH
35417: EMPTY
35418: ST_TO_ADDR
// mc_produce := [ ] ;
35419: LD_ADDR_EXP 137
35423: PUSH
35424: EMPTY
35425: ST_TO_ADDR
// mc_defender := [ ] ;
35426: LD_ADDR_EXP 138
35430: PUSH
35431: EMPTY
35432: ST_TO_ADDR
// mc_parking := [ ] ;
35433: LD_ADDR_EXP 140
35437: PUSH
35438: EMPTY
35439: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
35440: LD_ADDR_EXP 126
35444: PUSH
35445: EMPTY
35446: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
35447: LD_ADDR_EXP 128
35451: PUSH
35452: EMPTY
35453: ST_TO_ADDR
// mc_scan := [ ] ;
35454: LD_ADDR_EXP 139
35458: PUSH
35459: EMPTY
35460: ST_TO_ADDR
// mc_scan_area := [ ] ;
35461: LD_ADDR_EXP 141
35465: PUSH
35466: EMPTY
35467: ST_TO_ADDR
// mc_tech := [ ] ;
35468: LD_ADDR_EXP 143
35472: PUSH
35473: EMPTY
35474: ST_TO_ADDR
// mc_class := [ ] ;
35475: LD_ADDR_EXP 157
35479: PUSH
35480: EMPTY
35481: ST_TO_ADDR
// mc_class_case_use := [ ] ;
35482: LD_ADDR_EXP 158
35486: PUSH
35487: EMPTY
35488: ST_TO_ADDR
// mc_is_defending := [ ] ;
35489: LD_ADDR_EXP 159
35493: PUSH
35494: EMPTY
35495: ST_TO_ADDR
// end ;
35496: LD_VAR 0 1
35500: RET
// export function MC_Kill ( base ) ; begin
35501: LD_INT 0
35503: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
35504: LD_ADDR_EXP 116
35508: PUSH
35509: LD_EXP 116
35513: PPUSH
35514: LD_VAR 0 1
35518: PPUSH
35519: EMPTY
35520: PPUSH
35521: CALL_OW 1
35525: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35526: LD_ADDR_EXP 117
35530: PUSH
35531: LD_EXP 117
35535: PPUSH
35536: LD_VAR 0 1
35540: PPUSH
35541: EMPTY
35542: PPUSH
35543: CALL_OW 1
35547: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35548: LD_ADDR_EXP 118
35552: PUSH
35553: LD_EXP 118
35557: PPUSH
35558: LD_VAR 0 1
35562: PPUSH
35563: EMPTY
35564: PPUSH
35565: CALL_OW 1
35569: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35570: LD_ADDR_EXP 119
35574: PUSH
35575: LD_EXP 119
35579: PPUSH
35580: LD_VAR 0 1
35584: PPUSH
35585: EMPTY
35586: PPUSH
35587: CALL_OW 1
35591: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35592: LD_ADDR_EXP 120
35596: PUSH
35597: LD_EXP 120
35601: PPUSH
35602: LD_VAR 0 1
35606: PPUSH
35607: EMPTY
35608: PPUSH
35609: CALL_OW 1
35613: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35614: LD_ADDR_EXP 121
35618: PUSH
35619: LD_EXP 121
35623: PPUSH
35624: LD_VAR 0 1
35628: PPUSH
35629: EMPTY
35630: PPUSH
35631: CALL_OW 1
35635: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35636: LD_ADDR_EXP 122
35640: PUSH
35641: LD_EXP 122
35645: PPUSH
35646: LD_VAR 0 1
35650: PPUSH
35651: EMPTY
35652: PPUSH
35653: CALL_OW 1
35657: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35658: LD_ADDR_EXP 123
35662: PUSH
35663: LD_EXP 123
35667: PPUSH
35668: LD_VAR 0 1
35672: PPUSH
35673: EMPTY
35674: PPUSH
35675: CALL_OW 1
35679: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35680: LD_ADDR_EXP 124
35684: PUSH
35685: LD_EXP 124
35689: PPUSH
35690: LD_VAR 0 1
35694: PPUSH
35695: EMPTY
35696: PPUSH
35697: CALL_OW 1
35701: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35702: LD_ADDR_EXP 125
35706: PUSH
35707: LD_EXP 125
35711: PPUSH
35712: LD_VAR 0 1
35716: PPUSH
35717: EMPTY
35718: PPUSH
35719: CALL_OW 1
35723: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35724: LD_ADDR_EXP 126
35728: PUSH
35729: LD_EXP 126
35733: PPUSH
35734: LD_VAR 0 1
35738: PPUSH
35739: EMPTY
35740: PPUSH
35741: CALL_OW 1
35745: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35746: LD_ADDR_EXP 127
35750: PUSH
35751: LD_EXP 127
35755: PPUSH
35756: LD_VAR 0 1
35760: PPUSH
35761: LD_INT 0
35763: PPUSH
35764: CALL_OW 1
35768: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35769: LD_ADDR_EXP 128
35773: PUSH
35774: LD_EXP 128
35778: PPUSH
35779: LD_VAR 0 1
35783: PPUSH
35784: EMPTY
35785: PPUSH
35786: CALL_OW 1
35790: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35791: LD_ADDR_EXP 129
35795: PUSH
35796: LD_EXP 129
35800: PPUSH
35801: LD_VAR 0 1
35805: PPUSH
35806: EMPTY
35807: PPUSH
35808: CALL_OW 1
35812: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35813: LD_ADDR_EXP 130
35817: PUSH
35818: LD_EXP 130
35822: PPUSH
35823: LD_VAR 0 1
35827: PPUSH
35828: EMPTY
35829: PPUSH
35830: CALL_OW 1
35834: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35835: LD_ADDR_EXP 131
35839: PUSH
35840: LD_EXP 131
35844: PPUSH
35845: LD_VAR 0 1
35849: PPUSH
35850: EMPTY
35851: PPUSH
35852: CALL_OW 1
35856: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35857: LD_ADDR_EXP 132
35861: PUSH
35862: LD_EXP 132
35866: PPUSH
35867: LD_VAR 0 1
35871: PPUSH
35872: EMPTY
35873: PPUSH
35874: CALL_OW 1
35878: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35879: LD_ADDR_EXP 133
35883: PUSH
35884: LD_EXP 133
35888: PPUSH
35889: LD_VAR 0 1
35893: PPUSH
35894: EMPTY
35895: PPUSH
35896: CALL_OW 1
35900: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35901: LD_ADDR_EXP 134
35905: PUSH
35906: LD_EXP 134
35910: PPUSH
35911: LD_VAR 0 1
35915: PPUSH
35916: EMPTY
35917: PPUSH
35918: CALL_OW 1
35922: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35923: LD_ADDR_EXP 135
35927: PUSH
35928: LD_EXP 135
35932: PPUSH
35933: LD_VAR 0 1
35937: PPUSH
35938: EMPTY
35939: PPUSH
35940: CALL_OW 1
35944: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35945: LD_ADDR_EXP 136
35949: PUSH
35950: LD_EXP 136
35954: PPUSH
35955: LD_VAR 0 1
35959: PPUSH
35960: EMPTY
35961: PPUSH
35962: CALL_OW 1
35966: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35967: LD_ADDR_EXP 137
35971: PUSH
35972: LD_EXP 137
35976: PPUSH
35977: LD_VAR 0 1
35981: PPUSH
35982: EMPTY
35983: PPUSH
35984: CALL_OW 1
35988: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35989: LD_ADDR_EXP 138
35993: PUSH
35994: LD_EXP 138
35998: PPUSH
35999: LD_VAR 0 1
36003: PPUSH
36004: EMPTY
36005: PPUSH
36006: CALL_OW 1
36010: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36011: LD_ADDR_EXP 139
36015: PUSH
36016: LD_EXP 139
36020: PPUSH
36021: LD_VAR 0 1
36025: PPUSH
36026: EMPTY
36027: PPUSH
36028: CALL_OW 1
36032: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
36033: LD_ADDR_EXP 140
36037: PUSH
36038: LD_EXP 140
36042: PPUSH
36043: LD_VAR 0 1
36047: PPUSH
36048: EMPTY
36049: PPUSH
36050: CALL_OW 1
36054: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
36055: LD_ADDR_EXP 141
36059: PUSH
36060: LD_EXP 141
36064: PPUSH
36065: LD_VAR 0 1
36069: PPUSH
36070: EMPTY
36071: PPUSH
36072: CALL_OW 1
36076: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
36077: LD_ADDR_EXP 143
36081: PUSH
36082: LD_EXP 143
36086: PPUSH
36087: LD_VAR 0 1
36091: PPUSH
36092: EMPTY
36093: PPUSH
36094: CALL_OW 1
36098: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
36099: LD_ADDR_EXP 145
36103: PUSH
36104: LD_EXP 145
36108: PPUSH
36109: LD_VAR 0 1
36113: PPUSH
36114: EMPTY
36115: PPUSH
36116: CALL_OW 1
36120: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
36121: LD_ADDR_EXP 146
36125: PUSH
36126: LD_EXP 146
36130: PPUSH
36131: LD_VAR 0 1
36135: PPUSH
36136: EMPTY
36137: PPUSH
36138: CALL_OW 1
36142: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
36143: LD_ADDR_EXP 147
36147: PUSH
36148: LD_EXP 147
36152: PPUSH
36153: LD_VAR 0 1
36157: PPUSH
36158: EMPTY
36159: PPUSH
36160: CALL_OW 1
36164: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
36165: LD_ADDR_EXP 148
36169: PUSH
36170: LD_EXP 148
36174: PPUSH
36175: LD_VAR 0 1
36179: PPUSH
36180: EMPTY
36181: PPUSH
36182: CALL_OW 1
36186: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
36187: LD_ADDR_EXP 149
36191: PUSH
36192: LD_EXP 149
36196: PPUSH
36197: LD_VAR 0 1
36201: PPUSH
36202: EMPTY
36203: PPUSH
36204: CALL_OW 1
36208: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
36209: LD_ADDR_EXP 150
36213: PUSH
36214: LD_EXP 150
36218: PPUSH
36219: LD_VAR 0 1
36223: PPUSH
36224: EMPTY
36225: PPUSH
36226: CALL_OW 1
36230: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
36231: LD_ADDR_EXP 151
36235: PUSH
36236: LD_EXP 151
36240: PPUSH
36241: LD_VAR 0 1
36245: PPUSH
36246: EMPTY
36247: PPUSH
36248: CALL_OW 1
36252: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
36253: LD_ADDR_EXP 152
36257: PUSH
36258: LD_EXP 152
36262: PPUSH
36263: LD_VAR 0 1
36267: PPUSH
36268: EMPTY
36269: PPUSH
36270: CALL_OW 1
36274: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
36275: LD_ADDR_EXP 153
36279: PUSH
36280: LD_EXP 153
36284: PPUSH
36285: LD_VAR 0 1
36289: PPUSH
36290: EMPTY
36291: PPUSH
36292: CALL_OW 1
36296: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
36297: LD_ADDR_EXP 154
36301: PUSH
36302: LD_EXP 154
36306: PPUSH
36307: LD_VAR 0 1
36311: PPUSH
36312: EMPTY
36313: PPUSH
36314: CALL_OW 1
36318: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
36319: LD_ADDR_EXP 155
36323: PUSH
36324: LD_EXP 155
36328: PPUSH
36329: LD_VAR 0 1
36333: PPUSH
36334: EMPTY
36335: PPUSH
36336: CALL_OW 1
36340: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
36341: LD_ADDR_EXP 156
36345: PUSH
36346: LD_EXP 156
36350: PPUSH
36351: LD_VAR 0 1
36355: PPUSH
36356: EMPTY
36357: PPUSH
36358: CALL_OW 1
36362: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
36363: LD_ADDR_EXP 157
36367: PUSH
36368: LD_EXP 157
36372: PPUSH
36373: LD_VAR 0 1
36377: PPUSH
36378: EMPTY
36379: PPUSH
36380: CALL_OW 1
36384: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
36385: LD_ADDR_EXP 158
36389: PUSH
36390: LD_EXP 158
36394: PPUSH
36395: LD_VAR 0 1
36399: PPUSH
36400: LD_INT 0
36402: PPUSH
36403: CALL_OW 1
36407: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
36408: LD_ADDR_EXP 159
36412: PUSH
36413: LD_EXP 159
36417: PPUSH
36418: LD_VAR 0 1
36422: PPUSH
36423: LD_INT 0
36425: PPUSH
36426: CALL_OW 1
36430: ST_TO_ADDR
// end ;
36431: LD_VAR 0 2
36435: RET
// export function MC_Add ( side , units ) ; var base ; begin
36436: LD_INT 0
36438: PPUSH
36439: PPUSH
// base := mc_bases + 1 ;
36440: LD_ADDR_VAR 0 4
36444: PUSH
36445: LD_EXP 116
36449: PUSH
36450: LD_INT 1
36452: PLUS
36453: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
36454: LD_ADDR_EXP 142
36458: PUSH
36459: LD_EXP 142
36463: PPUSH
36464: LD_VAR 0 4
36468: PPUSH
36469: LD_VAR 0 1
36473: PPUSH
36474: CALL_OW 1
36478: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
36479: LD_ADDR_EXP 116
36483: PUSH
36484: LD_EXP 116
36488: PPUSH
36489: LD_VAR 0 4
36493: PPUSH
36494: LD_VAR 0 2
36498: PPUSH
36499: CALL_OW 1
36503: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
36504: LD_ADDR_EXP 117
36508: PUSH
36509: LD_EXP 117
36513: PPUSH
36514: LD_VAR 0 4
36518: PPUSH
36519: EMPTY
36520: PPUSH
36521: CALL_OW 1
36525: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
36526: LD_ADDR_EXP 118
36530: PUSH
36531: LD_EXP 118
36535: PPUSH
36536: LD_VAR 0 4
36540: PPUSH
36541: EMPTY
36542: PPUSH
36543: CALL_OW 1
36547: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
36548: LD_ADDR_EXP 119
36552: PUSH
36553: LD_EXP 119
36557: PPUSH
36558: LD_VAR 0 4
36562: PPUSH
36563: EMPTY
36564: PPUSH
36565: CALL_OW 1
36569: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
36570: LD_ADDR_EXP 120
36574: PUSH
36575: LD_EXP 120
36579: PPUSH
36580: LD_VAR 0 4
36584: PPUSH
36585: EMPTY
36586: PPUSH
36587: CALL_OW 1
36591: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
36592: LD_ADDR_EXP 121
36596: PUSH
36597: LD_EXP 121
36601: PPUSH
36602: LD_VAR 0 4
36606: PPUSH
36607: EMPTY
36608: PPUSH
36609: CALL_OW 1
36613: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
36614: LD_ADDR_EXP 122
36618: PUSH
36619: LD_EXP 122
36623: PPUSH
36624: LD_VAR 0 4
36628: PPUSH
36629: EMPTY
36630: PPUSH
36631: CALL_OW 1
36635: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
36636: LD_ADDR_EXP 123
36640: PUSH
36641: LD_EXP 123
36645: PPUSH
36646: LD_VAR 0 4
36650: PPUSH
36651: EMPTY
36652: PPUSH
36653: CALL_OW 1
36657: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
36658: LD_ADDR_EXP 124
36662: PUSH
36663: LD_EXP 124
36667: PPUSH
36668: LD_VAR 0 4
36672: PPUSH
36673: EMPTY
36674: PPUSH
36675: CALL_OW 1
36679: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
36680: LD_ADDR_EXP 125
36684: PUSH
36685: LD_EXP 125
36689: PPUSH
36690: LD_VAR 0 4
36694: PPUSH
36695: EMPTY
36696: PPUSH
36697: CALL_OW 1
36701: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
36702: LD_ADDR_EXP 126
36706: PUSH
36707: LD_EXP 126
36711: PPUSH
36712: LD_VAR 0 4
36716: PPUSH
36717: EMPTY
36718: PPUSH
36719: CALL_OW 1
36723: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
36724: LD_ADDR_EXP 127
36728: PUSH
36729: LD_EXP 127
36733: PPUSH
36734: LD_VAR 0 4
36738: PPUSH
36739: LD_INT 0
36741: PPUSH
36742: CALL_OW 1
36746: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
36747: LD_ADDR_EXP 128
36751: PUSH
36752: LD_EXP 128
36756: PPUSH
36757: LD_VAR 0 4
36761: PPUSH
36762: EMPTY
36763: PPUSH
36764: CALL_OW 1
36768: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
36769: LD_ADDR_EXP 129
36773: PUSH
36774: LD_EXP 129
36778: PPUSH
36779: LD_VAR 0 4
36783: PPUSH
36784: EMPTY
36785: PPUSH
36786: CALL_OW 1
36790: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
36791: LD_ADDR_EXP 130
36795: PUSH
36796: LD_EXP 130
36800: PPUSH
36801: LD_VAR 0 4
36805: PPUSH
36806: EMPTY
36807: PPUSH
36808: CALL_OW 1
36812: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
36813: LD_ADDR_EXP 131
36817: PUSH
36818: LD_EXP 131
36822: PPUSH
36823: LD_VAR 0 4
36827: PPUSH
36828: EMPTY
36829: PPUSH
36830: CALL_OW 1
36834: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
36835: LD_ADDR_EXP 132
36839: PUSH
36840: LD_EXP 132
36844: PPUSH
36845: LD_VAR 0 4
36849: PPUSH
36850: EMPTY
36851: PPUSH
36852: CALL_OW 1
36856: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
36857: LD_ADDR_EXP 133
36861: PUSH
36862: LD_EXP 133
36866: PPUSH
36867: LD_VAR 0 4
36871: PPUSH
36872: EMPTY
36873: PPUSH
36874: CALL_OW 1
36878: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
36879: LD_ADDR_EXP 134
36883: PUSH
36884: LD_EXP 134
36888: PPUSH
36889: LD_VAR 0 4
36893: PPUSH
36894: EMPTY
36895: PPUSH
36896: CALL_OW 1
36900: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
36901: LD_ADDR_EXP 135
36905: PUSH
36906: LD_EXP 135
36910: PPUSH
36911: LD_VAR 0 4
36915: PPUSH
36916: EMPTY
36917: PPUSH
36918: CALL_OW 1
36922: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
36923: LD_ADDR_EXP 136
36927: PUSH
36928: LD_EXP 136
36932: PPUSH
36933: LD_VAR 0 4
36937: PPUSH
36938: EMPTY
36939: PPUSH
36940: CALL_OW 1
36944: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
36945: LD_ADDR_EXP 137
36949: PUSH
36950: LD_EXP 137
36954: PPUSH
36955: LD_VAR 0 4
36959: PPUSH
36960: EMPTY
36961: PPUSH
36962: CALL_OW 1
36966: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
36967: LD_ADDR_EXP 138
36971: PUSH
36972: LD_EXP 138
36976: PPUSH
36977: LD_VAR 0 4
36981: PPUSH
36982: EMPTY
36983: PPUSH
36984: CALL_OW 1
36988: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
36989: LD_ADDR_EXP 139
36993: PUSH
36994: LD_EXP 139
36998: PPUSH
36999: LD_VAR 0 4
37003: PPUSH
37004: EMPTY
37005: PPUSH
37006: CALL_OW 1
37010: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
37011: LD_ADDR_EXP 140
37015: PUSH
37016: LD_EXP 140
37020: PPUSH
37021: LD_VAR 0 4
37025: PPUSH
37026: EMPTY
37027: PPUSH
37028: CALL_OW 1
37032: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
37033: LD_ADDR_EXP 141
37037: PUSH
37038: LD_EXP 141
37042: PPUSH
37043: LD_VAR 0 4
37047: PPUSH
37048: EMPTY
37049: PPUSH
37050: CALL_OW 1
37054: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
37055: LD_ADDR_EXP 143
37059: PUSH
37060: LD_EXP 143
37064: PPUSH
37065: LD_VAR 0 4
37069: PPUSH
37070: EMPTY
37071: PPUSH
37072: CALL_OW 1
37076: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
37077: LD_ADDR_EXP 145
37081: PUSH
37082: LD_EXP 145
37086: PPUSH
37087: LD_VAR 0 4
37091: PPUSH
37092: EMPTY
37093: PPUSH
37094: CALL_OW 1
37098: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
37099: LD_ADDR_EXP 146
37103: PUSH
37104: LD_EXP 146
37108: PPUSH
37109: LD_VAR 0 4
37113: PPUSH
37114: EMPTY
37115: PPUSH
37116: CALL_OW 1
37120: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
37121: LD_ADDR_EXP 147
37125: PUSH
37126: LD_EXP 147
37130: PPUSH
37131: LD_VAR 0 4
37135: PPUSH
37136: EMPTY
37137: PPUSH
37138: CALL_OW 1
37142: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
37143: LD_ADDR_EXP 148
37147: PUSH
37148: LD_EXP 148
37152: PPUSH
37153: LD_VAR 0 4
37157: PPUSH
37158: EMPTY
37159: PPUSH
37160: CALL_OW 1
37164: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
37165: LD_ADDR_EXP 149
37169: PUSH
37170: LD_EXP 149
37174: PPUSH
37175: LD_VAR 0 4
37179: PPUSH
37180: EMPTY
37181: PPUSH
37182: CALL_OW 1
37186: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
37187: LD_ADDR_EXP 150
37191: PUSH
37192: LD_EXP 150
37196: PPUSH
37197: LD_VAR 0 4
37201: PPUSH
37202: EMPTY
37203: PPUSH
37204: CALL_OW 1
37208: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
37209: LD_ADDR_EXP 151
37213: PUSH
37214: LD_EXP 151
37218: PPUSH
37219: LD_VAR 0 4
37223: PPUSH
37224: EMPTY
37225: PPUSH
37226: CALL_OW 1
37230: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
37231: LD_ADDR_EXP 152
37235: PUSH
37236: LD_EXP 152
37240: PPUSH
37241: LD_VAR 0 4
37245: PPUSH
37246: EMPTY
37247: PPUSH
37248: CALL_OW 1
37252: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
37253: LD_ADDR_EXP 153
37257: PUSH
37258: LD_EXP 153
37262: PPUSH
37263: LD_VAR 0 4
37267: PPUSH
37268: EMPTY
37269: PPUSH
37270: CALL_OW 1
37274: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
37275: LD_ADDR_EXP 154
37279: PUSH
37280: LD_EXP 154
37284: PPUSH
37285: LD_VAR 0 4
37289: PPUSH
37290: EMPTY
37291: PPUSH
37292: CALL_OW 1
37296: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
37297: LD_ADDR_EXP 155
37301: PUSH
37302: LD_EXP 155
37306: PPUSH
37307: LD_VAR 0 4
37311: PPUSH
37312: EMPTY
37313: PPUSH
37314: CALL_OW 1
37318: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
37319: LD_ADDR_EXP 156
37323: PUSH
37324: LD_EXP 156
37328: PPUSH
37329: LD_VAR 0 4
37333: PPUSH
37334: EMPTY
37335: PPUSH
37336: CALL_OW 1
37340: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
37341: LD_ADDR_EXP 157
37345: PUSH
37346: LD_EXP 157
37350: PPUSH
37351: LD_VAR 0 4
37355: PPUSH
37356: EMPTY
37357: PPUSH
37358: CALL_OW 1
37362: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
37363: LD_ADDR_EXP 158
37367: PUSH
37368: LD_EXP 158
37372: PPUSH
37373: LD_VAR 0 4
37377: PPUSH
37378: LD_INT 0
37380: PPUSH
37381: CALL_OW 1
37385: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
37386: LD_ADDR_EXP 159
37390: PUSH
37391: LD_EXP 159
37395: PPUSH
37396: LD_VAR 0 4
37400: PPUSH
37401: LD_INT 0
37403: PPUSH
37404: CALL_OW 1
37408: ST_TO_ADDR
// result := base ;
37409: LD_ADDR_VAR 0 3
37413: PUSH
37414: LD_VAR 0 4
37418: ST_TO_ADDR
// end ;
37419: LD_VAR 0 3
37423: RET
// export function MC_Start ( ) ; var i ; begin
37424: LD_INT 0
37426: PPUSH
37427: PPUSH
// for i = 1 to mc_bases do
37428: LD_ADDR_VAR 0 2
37432: PUSH
37433: DOUBLE
37434: LD_INT 1
37436: DEC
37437: ST_TO_ADDR
37438: LD_EXP 116
37442: PUSH
37443: FOR_TO
37444: IFFALSE 38544
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
37446: LD_ADDR_EXP 116
37450: PUSH
37451: LD_EXP 116
37455: PPUSH
37456: LD_VAR 0 2
37460: PPUSH
37461: LD_EXP 116
37465: PUSH
37466: LD_VAR 0 2
37470: ARRAY
37471: PUSH
37472: LD_INT 0
37474: DIFF
37475: PPUSH
37476: CALL_OW 1
37480: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
37481: LD_ADDR_EXP 117
37485: PUSH
37486: LD_EXP 117
37490: PPUSH
37491: LD_VAR 0 2
37495: PPUSH
37496: EMPTY
37497: PPUSH
37498: CALL_OW 1
37502: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
37503: LD_ADDR_EXP 118
37507: PUSH
37508: LD_EXP 118
37512: PPUSH
37513: LD_VAR 0 2
37517: PPUSH
37518: EMPTY
37519: PPUSH
37520: CALL_OW 1
37524: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
37525: LD_ADDR_EXP 119
37529: PUSH
37530: LD_EXP 119
37534: PPUSH
37535: LD_VAR 0 2
37539: PPUSH
37540: EMPTY
37541: PPUSH
37542: CALL_OW 1
37546: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
37547: LD_ADDR_EXP 120
37551: PUSH
37552: LD_EXP 120
37556: PPUSH
37557: LD_VAR 0 2
37561: PPUSH
37562: EMPTY
37563: PUSH
37564: EMPTY
37565: PUSH
37566: EMPTY
37567: LIST
37568: LIST
37569: PPUSH
37570: CALL_OW 1
37574: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
37575: LD_ADDR_EXP 121
37579: PUSH
37580: LD_EXP 121
37584: PPUSH
37585: LD_VAR 0 2
37589: PPUSH
37590: EMPTY
37591: PPUSH
37592: CALL_OW 1
37596: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
37597: LD_ADDR_EXP 148
37601: PUSH
37602: LD_EXP 148
37606: PPUSH
37607: LD_VAR 0 2
37611: PPUSH
37612: EMPTY
37613: PPUSH
37614: CALL_OW 1
37618: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
37619: LD_ADDR_EXP 122
37623: PUSH
37624: LD_EXP 122
37628: PPUSH
37629: LD_VAR 0 2
37633: PPUSH
37634: EMPTY
37635: PPUSH
37636: CALL_OW 1
37640: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
37641: LD_ADDR_EXP 123
37645: PUSH
37646: LD_EXP 123
37650: PPUSH
37651: LD_VAR 0 2
37655: PPUSH
37656: EMPTY
37657: PPUSH
37658: CALL_OW 1
37662: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
37663: LD_ADDR_EXP 124
37667: PUSH
37668: LD_EXP 124
37672: PPUSH
37673: LD_VAR 0 2
37677: PPUSH
37678: LD_EXP 116
37682: PUSH
37683: LD_VAR 0 2
37687: ARRAY
37688: PPUSH
37689: LD_INT 2
37691: PUSH
37692: LD_INT 30
37694: PUSH
37695: LD_INT 32
37697: PUSH
37698: EMPTY
37699: LIST
37700: LIST
37701: PUSH
37702: LD_INT 30
37704: PUSH
37705: LD_INT 33
37707: PUSH
37708: EMPTY
37709: LIST
37710: LIST
37711: PUSH
37712: EMPTY
37713: LIST
37714: LIST
37715: LIST
37716: PPUSH
37717: CALL_OW 72
37721: PPUSH
37722: CALL_OW 1
37726: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
37727: LD_ADDR_EXP 125
37731: PUSH
37732: LD_EXP 125
37736: PPUSH
37737: LD_VAR 0 2
37741: PPUSH
37742: LD_EXP 116
37746: PUSH
37747: LD_VAR 0 2
37751: ARRAY
37752: PPUSH
37753: LD_INT 2
37755: PUSH
37756: LD_INT 30
37758: PUSH
37759: LD_INT 32
37761: PUSH
37762: EMPTY
37763: LIST
37764: LIST
37765: PUSH
37766: LD_INT 30
37768: PUSH
37769: LD_INT 31
37771: PUSH
37772: EMPTY
37773: LIST
37774: LIST
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 58
37783: PUSH
37784: EMPTY
37785: LIST
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PPUSH
37791: CALL_OW 72
37795: PPUSH
37796: CALL_OW 1
37800: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
37801: LD_ADDR_EXP 126
37805: PUSH
37806: LD_EXP 126
37810: PPUSH
37811: LD_VAR 0 2
37815: PPUSH
37816: EMPTY
37817: PPUSH
37818: CALL_OW 1
37822: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
37823: LD_ADDR_EXP 130
37827: PUSH
37828: LD_EXP 130
37832: PPUSH
37833: LD_VAR 0 2
37837: PPUSH
37838: EMPTY
37839: PPUSH
37840: CALL_OW 1
37844: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
37845: LD_ADDR_EXP 129
37849: PUSH
37850: LD_EXP 129
37854: PPUSH
37855: LD_VAR 0 2
37859: PPUSH
37860: EMPTY
37861: PPUSH
37862: CALL_OW 1
37866: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
37867: LD_ADDR_EXP 131
37871: PUSH
37872: LD_EXP 131
37876: PPUSH
37877: LD_VAR 0 2
37881: PPUSH
37882: EMPTY
37883: PPUSH
37884: CALL_OW 1
37888: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
37889: LD_ADDR_EXP 132
37893: PUSH
37894: LD_EXP 132
37898: PPUSH
37899: LD_VAR 0 2
37903: PPUSH
37904: EMPTY
37905: PPUSH
37906: CALL_OW 1
37910: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
37911: LD_ADDR_EXP 133
37915: PUSH
37916: LD_EXP 133
37920: PPUSH
37921: LD_VAR 0 2
37925: PPUSH
37926: EMPTY
37927: PPUSH
37928: CALL_OW 1
37932: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
37933: LD_ADDR_EXP 134
37937: PUSH
37938: LD_EXP 134
37942: PPUSH
37943: LD_VAR 0 2
37947: PPUSH
37948: EMPTY
37949: PPUSH
37950: CALL_OW 1
37954: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
37955: LD_ADDR_EXP 135
37959: PUSH
37960: LD_EXP 135
37964: PPUSH
37965: LD_VAR 0 2
37969: PPUSH
37970: EMPTY
37971: PPUSH
37972: CALL_OW 1
37976: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
37977: LD_ADDR_EXP 136
37981: PUSH
37982: LD_EXP 136
37986: PPUSH
37987: LD_VAR 0 2
37991: PPUSH
37992: EMPTY
37993: PPUSH
37994: CALL_OW 1
37998: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
37999: LD_ADDR_EXP 137
38003: PUSH
38004: LD_EXP 137
38008: PPUSH
38009: LD_VAR 0 2
38013: PPUSH
38014: EMPTY
38015: PPUSH
38016: CALL_OW 1
38020: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
38021: LD_ADDR_EXP 138
38025: PUSH
38026: LD_EXP 138
38030: PPUSH
38031: LD_VAR 0 2
38035: PPUSH
38036: EMPTY
38037: PPUSH
38038: CALL_OW 1
38042: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
38043: LD_ADDR_EXP 127
38047: PUSH
38048: LD_EXP 127
38052: PPUSH
38053: LD_VAR 0 2
38057: PPUSH
38058: LD_INT 0
38060: PPUSH
38061: CALL_OW 1
38065: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
38066: LD_ADDR_EXP 140
38070: PUSH
38071: LD_EXP 140
38075: PPUSH
38076: LD_VAR 0 2
38080: PPUSH
38081: LD_INT 0
38083: PPUSH
38084: CALL_OW 1
38088: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
38089: LD_ADDR_EXP 128
38093: PUSH
38094: LD_EXP 128
38098: PPUSH
38099: LD_VAR 0 2
38103: PPUSH
38104: EMPTY
38105: PPUSH
38106: CALL_OW 1
38110: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
38111: LD_ADDR_EXP 139
38115: PUSH
38116: LD_EXP 139
38120: PPUSH
38121: LD_VAR 0 2
38125: PPUSH
38126: LD_INT 0
38128: PPUSH
38129: CALL_OW 1
38133: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
38134: LD_ADDR_EXP 141
38138: PUSH
38139: LD_EXP 141
38143: PPUSH
38144: LD_VAR 0 2
38148: PPUSH
38149: EMPTY
38150: PPUSH
38151: CALL_OW 1
38155: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
38156: LD_ADDR_EXP 144
38160: PUSH
38161: LD_EXP 144
38165: PPUSH
38166: LD_VAR 0 2
38170: PPUSH
38171: LD_INT 0
38173: PPUSH
38174: CALL_OW 1
38178: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
38179: LD_ADDR_EXP 145
38183: PUSH
38184: LD_EXP 145
38188: PPUSH
38189: LD_VAR 0 2
38193: PPUSH
38194: EMPTY
38195: PPUSH
38196: CALL_OW 1
38200: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
38201: LD_ADDR_EXP 146
38205: PUSH
38206: LD_EXP 146
38210: PPUSH
38211: LD_VAR 0 2
38215: PPUSH
38216: EMPTY
38217: PPUSH
38218: CALL_OW 1
38222: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
38223: LD_ADDR_EXP 147
38227: PUSH
38228: LD_EXP 147
38232: PPUSH
38233: LD_VAR 0 2
38237: PPUSH
38238: EMPTY
38239: PPUSH
38240: CALL_OW 1
38244: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
38245: LD_ADDR_EXP 149
38249: PUSH
38250: LD_EXP 149
38254: PPUSH
38255: LD_VAR 0 2
38259: PPUSH
38260: LD_EXP 116
38264: PUSH
38265: LD_VAR 0 2
38269: ARRAY
38270: PPUSH
38271: LD_INT 2
38273: PUSH
38274: LD_INT 30
38276: PUSH
38277: LD_INT 6
38279: PUSH
38280: EMPTY
38281: LIST
38282: LIST
38283: PUSH
38284: LD_INT 30
38286: PUSH
38287: LD_INT 7
38289: PUSH
38290: EMPTY
38291: LIST
38292: LIST
38293: PUSH
38294: LD_INT 30
38296: PUSH
38297: LD_INT 8
38299: PUSH
38300: EMPTY
38301: LIST
38302: LIST
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: LIST
38308: LIST
38309: PPUSH
38310: CALL_OW 72
38314: PPUSH
38315: CALL_OW 1
38319: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
38320: LD_ADDR_EXP 150
38324: PUSH
38325: LD_EXP 150
38329: PPUSH
38330: LD_VAR 0 2
38334: PPUSH
38335: EMPTY
38336: PPUSH
38337: CALL_OW 1
38341: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
38342: LD_ADDR_EXP 151
38346: PUSH
38347: LD_EXP 151
38351: PPUSH
38352: LD_VAR 0 2
38356: PPUSH
38357: EMPTY
38358: PPUSH
38359: CALL_OW 1
38363: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
38364: LD_ADDR_EXP 152
38368: PUSH
38369: LD_EXP 152
38373: PPUSH
38374: LD_VAR 0 2
38378: PPUSH
38379: EMPTY
38380: PPUSH
38381: CALL_OW 1
38385: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
38386: LD_ADDR_EXP 153
38390: PUSH
38391: LD_EXP 153
38395: PPUSH
38396: LD_VAR 0 2
38400: PPUSH
38401: EMPTY
38402: PPUSH
38403: CALL_OW 1
38407: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38408: LD_ADDR_EXP 154
38412: PUSH
38413: LD_EXP 154
38417: PPUSH
38418: LD_VAR 0 2
38422: PPUSH
38423: EMPTY
38424: PPUSH
38425: CALL_OW 1
38429: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
38430: LD_ADDR_EXP 155
38434: PUSH
38435: LD_EXP 155
38439: PPUSH
38440: LD_VAR 0 2
38444: PPUSH
38445: EMPTY
38446: PPUSH
38447: CALL_OW 1
38451: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
38452: LD_ADDR_EXP 156
38456: PUSH
38457: LD_EXP 156
38461: PPUSH
38462: LD_VAR 0 2
38466: PPUSH
38467: EMPTY
38468: PPUSH
38469: CALL_OW 1
38473: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
38474: LD_ADDR_EXP 157
38478: PUSH
38479: LD_EXP 157
38483: PPUSH
38484: LD_VAR 0 2
38488: PPUSH
38489: EMPTY
38490: PPUSH
38491: CALL_OW 1
38495: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
38496: LD_ADDR_EXP 158
38500: PUSH
38501: LD_EXP 158
38505: PPUSH
38506: LD_VAR 0 2
38510: PPUSH
38511: LD_INT 0
38513: PPUSH
38514: CALL_OW 1
38518: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
38519: LD_ADDR_EXP 159
38523: PUSH
38524: LD_EXP 159
38528: PPUSH
38529: LD_VAR 0 2
38533: PPUSH
38534: LD_INT 0
38536: PPUSH
38537: CALL_OW 1
38541: ST_TO_ADDR
// end ;
38542: GO 37443
38544: POP
38545: POP
// MC_InitSides ( ) ;
38546: CALL 38832 0 0
// MC_InitResearch ( ) ;
38550: CALL 38571 0 0
// CustomInitMacro ( ) ;
38554: CALL 471 0 0
// skirmish := true ;
38558: LD_ADDR_EXP 114
38562: PUSH
38563: LD_INT 1
38565: ST_TO_ADDR
// end ;
38566: LD_VAR 0 1
38570: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
38571: LD_INT 0
38573: PPUSH
38574: PPUSH
38575: PPUSH
38576: PPUSH
38577: PPUSH
38578: PPUSH
// if not mc_bases then
38579: LD_EXP 116
38583: NOT
38584: IFFALSE 38588
// exit ;
38586: GO 38827
// for i = 1 to 8 do
38588: LD_ADDR_VAR 0 2
38592: PUSH
38593: DOUBLE
38594: LD_INT 1
38596: DEC
38597: ST_TO_ADDR
38598: LD_INT 8
38600: PUSH
38601: FOR_TO
38602: IFFALSE 38628
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
38604: LD_ADDR_EXP 143
38608: PUSH
38609: LD_EXP 143
38613: PPUSH
38614: LD_VAR 0 2
38618: PPUSH
38619: EMPTY
38620: PPUSH
38621: CALL_OW 1
38625: ST_TO_ADDR
38626: GO 38601
38628: POP
38629: POP
// tmp := [ ] ;
38630: LD_ADDR_VAR 0 5
38634: PUSH
38635: EMPTY
38636: ST_TO_ADDR
// for i = 1 to mc_sides do
38637: LD_ADDR_VAR 0 2
38641: PUSH
38642: DOUBLE
38643: LD_INT 1
38645: DEC
38646: ST_TO_ADDR
38647: LD_EXP 142
38651: PUSH
38652: FOR_TO
38653: IFFALSE 38711
// if not mc_sides [ i ] in tmp then
38655: LD_EXP 142
38659: PUSH
38660: LD_VAR 0 2
38664: ARRAY
38665: PUSH
38666: LD_VAR 0 5
38670: IN
38671: NOT
38672: IFFALSE 38709
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
38674: LD_ADDR_VAR 0 5
38678: PUSH
38679: LD_VAR 0 5
38683: PPUSH
38684: LD_VAR 0 5
38688: PUSH
38689: LD_INT 1
38691: PLUS
38692: PPUSH
38693: LD_EXP 142
38697: PUSH
38698: LD_VAR 0 2
38702: ARRAY
38703: PPUSH
38704: CALL_OW 2
38708: ST_TO_ADDR
38709: GO 38652
38711: POP
38712: POP
// if not tmp then
38713: LD_VAR 0 5
38717: NOT
38718: IFFALSE 38722
// exit ;
38720: GO 38827
// for j in tmp do
38722: LD_ADDR_VAR 0 3
38726: PUSH
38727: LD_VAR 0 5
38731: PUSH
38732: FOR_IN
38733: IFFALSE 38825
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
38735: LD_ADDR_VAR 0 6
38739: PUSH
38740: LD_INT 22
38742: PUSH
38743: LD_VAR 0 3
38747: PUSH
38748: EMPTY
38749: LIST
38750: LIST
38751: PPUSH
38752: CALL_OW 69
38756: ST_TO_ADDR
// if not un then
38757: LD_VAR 0 6
38761: NOT
38762: IFFALSE 38766
// continue ;
38764: GO 38732
// nation := GetNation ( un [ 1 ] ) ;
38766: LD_ADDR_VAR 0 4
38770: PUSH
38771: LD_VAR 0 6
38775: PUSH
38776: LD_INT 1
38778: ARRAY
38779: PPUSH
38780: CALL_OW 248
38784: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
38785: LD_ADDR_EXP 143
38789: PUSH
38790: LD_EXP 143
38794: PPUSH
38795: LD_VAR 0 3
38799: PPUSH
38800: LD_VAR 0 3
38804: PPUSH
38805: LD_VAR 0 4
38809: PPUSH
38810: LD_INT 1
38812: PPUSH
38813: CALL 65948 0 3
38817: PPUSH
38818: CALL_OW 1
38822: ST_TO_ADDR
// end ;
38823: GO 38732
38825: POP
38826: POP
// end ;
38827: LD_VAR 0 1
38831: RET
// export function MC_InitSides ( ) ; var i ; begin
38832: LD_INT 0
38834: PPUSH
38835: PPUSH
// if not mc_bases then
38836: LD_EXP 116
38840: NOT
38841: IFFALSE 38845
// exit ;
38843: GO 38919
// for i = 1 to mc_bases do
38845: LD_ADDR_VAR 0 2
38849: PUSH
38850: DOUBLE
38851: LD_INT 1
38853: DEC
38854: ST_TO_ADDR
38855: LD_EXP 116
38859: PUSH
38860: FOR_TO
38861: IFFALSE 38917
// if mc_bases [ i ] then
38863: LD_EXP 116
38867: PUSH
38868: LD_VAR 0 2
38872: ARRAY
38873: IFFALSE 38915
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
38875: LD_ADDR_EXP 142
38879: PUSH
38880: LD_EXP 142
38884: PPUSH
38885: LD_VAR 0 2
38889: PPUSH
38890: LD_EXP 116
38894: PUSH
38895: LD_VAR 0 2
38899: ARRAY
38900: PUSH
38901: LD_INT 1
38903: ARRAY
38904: PPUSH
38905: CALL_OW 255
38909: PPUSH
38910: CALL_OW 1
38914: ST_TO_ADDR
38915: GO 38860
38917: POP
38918: POP
// end ;
38919: LD_VAR 0 1
38923: RET
// every 0 0$03 trigger skirmish do
38924: LD_EXP 114
38928: IFFALSE 39082
38930: GO 38932
38932: DISABLE
// begin enable ;
38933: ENABLE
// MC_CheckBuildings ( ) ;
38934: CALL 43580 0 0
// MC_CheckPeopleLife ( ) ;
38938: CALL 43741 0 0
// RaiseSailEvent ( 100 ) ;
38942: LD_INT 100
38944: PPUSH
38945: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
38949: LD_INT 103
38951: PPUSH
38952: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
38956: LD_INT 104
38958: PPUSH
38959: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
38963: LD_INT 105
38965: PPUSH
38966: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
38970: LD_INT 106
38972: PPUSH
38973: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
38977: LD_INT 107
38979: PPUSH
38980: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
38984: LD_INT 108
38986: PPUSH
38987: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
38991: LD_INT 109
38993: PPUSH
38994: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
38998: LD_INT 110
39000: PPUSH
39001: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
39005: LD_INT 111
39007: PPUSH
39008: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
39012: LD_INT 112
39014: PPUSH
39015: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
39019: LD_INT 113
39021: PPUSH
39022: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
39026: LD_INT 120
39028: PPUSH
39029: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
39033: LD_INT 121
39035: PPUSH
39036: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
39040: LD_INT 122
39042: PPUSH
39043: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
39047: LD_INT 123
39049: PPUSH
39050: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
39054: LD_INT 124
39056: PPUSH
39057: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
39061: LD_INT 125
39063: PPUSH
39064: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
39068: LD_INT 126
39070: PPUSH
39071: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
39075: LD_INT 200
39077: PPUSH
39078: CALL_OW 427
// end ;
39082: END
// on SailEvent ( event ) do begin if event < 100 then
39083: LD_VAR 0 1
39087: PUSH
39088: LD_INT 100
39090: LESS
39091: IFFALSE 39102
// CustomEvent ( event ) ;
39093: LD_VAR 0 1
39097: PPUSH
39098: CALL 33558 0 1
// if event = 100 then
39102: LD_VAR 0 1
39106: PUSH
39107: LD_INT 100
39109: EQUAL
39110: IFFALSE 39116
// MC_ClassManager ( ) ;
39112: CALL 39508 0 0
// if event = 101 then
39116: LD_VAR 0 1
39120: PUSH
39121: LD_INT 101
39123: EQUAL
39124: IFFALSE 39130
// MC_RepairBuildings ( ) ;
39126: CALL 44326 0 0
// if event = 102 then
39130: LD_VAR 0 1
39134: PUSH
39135: LD_INT 102
39137: EQUAL
39138: IFFALSE 39144
// MC_Heal ( ) ;
39140: CALL 45233 0 0
// if event = 103 then
39144: LD_VAR 0 1
39148: PUSH
39149: LD_INT 103
39151: EQUAL
39152: IFFALSE 39158
// MC_Build ( ) ;
39154: CALL 45655 0 0
// if event = 104 then
39158: LD_VAR 0 1
39162: PUSH
39163: LD_INT 104
39165: EQUAL
39166: IFFALSE 39172
// MC_TurretWeapon ( ) ;
39168: CALL 47296 0 0
// if event = 105 then
39172: LD_VAR 0 1
39176: PUSH
39177: LD_INT 105
39179: EQUAL
39180: IFFALSE 39186
// MC_BuildUpgrade ( ) ;
39182: CALL 46847 0 0
// if event = 106 then
39186: LD_VAR 0 1
39190: PUSH
39191: LD_INT 106
39193: EQUAL
39194: IFFALSE 39200
// MC_PlantMines ( ) ;
39196: CALL 47726 0 0
// if event = 107 then
39200: LD_VAR 0 1
39204: PUSH
39205: LD_INT 107
39207: EQUAL
39208: IFFALSE 39214
// MC_CollectCrates ( ) ;
39210: CALL 48517 0 0
// if event = 108 then
39214: LD_VAR 0 1
39218: PUSH
39219: LD_INT 108
39221: EQUAL
39222: IFFALSE 39228
// MC_LinkRemoteControl ( ) ;
39224: CALL 50367 0 0
// if event = 109 then
39228: LD_VAR 0 1
39232: PUSH
39233: LD_INT 109
39235: EQUAL
39236: IFFALSE 39242
// MC_ProduceVehicle ( ) ;
39238: CALL 50548 0 0
// if event = 110 then
39242: LD_VAR 0 1
39246: PUSH
39247: LD_INT 110
39249: EQUAL
39250: IFFALSE 39256
// MC_SendAttack ( ) ;
39252: CALL 51014 0 0
// if event = 111 then
39256: LD_VAR 0 1
39260: PUSH
39261: LD_INT 111
39263: EQUAL
39264: IFFALSE 39270
// MC_Defend ( ) ;
39266: CALL 51122 0 0
// if event = 112 then
39270: LD_VAR 0 1
39274: PUSH
39275: LD_INT 112
39277: EQUAL
39278: IFFALSE 39284
// MC_Research ( ) ;
39280: CALL 52002 0 0
// if event = 113 then
39284: LD_VAR 0 1
39288: PUSH
39289: LD_INT 113
39291: EQUAL
39292: IFFALSE 39298
// MC_MinesTrigger ( ) ;
39294: CALL 53116 0 0
// if event = 120 then
39298: LD_VAR 0 1
39302: PUSH
39303: LD_INT 120
39305: EQUAL
39306: IFFALSE 39312
// MC_RepairVehicle ( ) ;
39308: CALL 53215 0 0
// if event = 121 then
39312: LD_VAR 0 1
39316: PUSH
39317: LD_INT 121
39319: EQUAL
39320: IFFALSE 39326
// MC_TameApe ( ) ;
39322: CALL 53956 0 0
// if event = 122 then
39326: LD_VAR 0 1
39330: PUSH
39331: LD_INT 122
39333: EQUAL
39334: IFFALSE 39340
// MC_ChangeApeClass ( ) ;
39336: CALL 54785 0 0
// if event = 123 then
39340: LD_VAR 0 1
39344: PUSH
39345: LD_INT 123
39347: EQUAL
39348: IFFALSE 39354
// MC_Bazooka ( ) ;
39350: CALL 55435 0 0
// if event = 124 then
39354: LD_VAR 0 1
39358: PUSH
39359: LD_INT 124
39361: EQUAL
39362: IFFALSE 39368
// MC_TeleportExit ( ) ;
39364: CALL 55633 0 0
// if event = 125 then
39368: LD_VAR 0 1
39372: PUSH
39373: LD_INT 125
39375: EQUAL
39376: IFFALSE 39382
// MC_Deposits ( ) ;
39378: CALL 56280 0 0
// if event = 126 then
39382: LD_VAR 0 1
39386: PUSH
39387: LD_INT 126
39389: EQUAL
39390: IFFALSE 39396
// MC_RemoteDriver ( ) ;
39392: CALL 56905 0 0
// if event = 200 then
39396: LD_VAR 0 1
39400: PUSH
39401: LD_INT 200
39403: EQUAL
39404: IFFALSE 39410
// MC_Idle ( ) ;
39406: CALL 58854 0 0
// end ;
39410: PPOPN 1
39412: END
// export function MC_Reset ( base , tag ) ; var i ; begin
39413: LD_INT 0
39415: PPUSH
39416: PPUSH
// if not mc_bases [ base ] or not tag then
39417: LD_EXP 116
39421: PUSH
39422: LD_VAR 0 1
39426: ARRAY
39427: NOT
39428: PUSH
39429: LD_VAR 0 2
39433: NOT
39434: OR
39435: IFFALSE 39439
// exit ;
39437: GO 39503
// for i in mc_bases [ base ] union mc_ape [ base ] do
39439: LD_ADDR_VAR 0 4
39443: PUSH
39444: LD_EXP 116
39448: PUSH
39449: LD_VAR 0 1
39453: ARRAY
39454: PUSH
39455: LD_EXP 145
39459: PUSH
39460: LD_VAR 0 1
39464: ARRAY
39465: UNION
39466: PUSH
39467: FOR_IN
39468: IFFALSE 39501
// if GetTag ( i ) = tag then
39470: LD_VAR 0 4
39474: PPUSH
39475: CALL_OW 110
39479: PUSH
39480: LD_VAR 0 2
39484: EQUAL
39485: IFFALSE 39499
// SetTag ( i , 0 ) ;
39487: LD_VAR 0 4
39491: PPUSH
39492: LD_INT 0
39494: PPUSH
39495: CALL_OW 109
39499: GO 39467
39501: POP
39502: POP
// end ;
39503: LD_VAR 0 3
39507: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
39508: LD_INT 0
39510: PPUSH
39511: PPUSH
39512: PPUSH
39513: PPUSH
39514: PPUSH
39515: PPUSH
39516: PPUSH
39517: PPUSH
// if not mc_bases then
39518: LD_EXP 116
39522: NOT
39523: IFFALSE 39527
// exit ;
39525: GO 39985
// for i = 1 to mc_bases do
39527: LD_ADDR_VAR 0 2
39531: PUSH
39532: DOUBLE
39533: LD_INT 1
39535: DEC
39536: ST_TO_ADDR
39537: LD_EXP 116
39541: PUSH
39542: FOR_TO
39543: IFFALSE 39983
// begin tmp := MC_ClassCheckReq ( i ) ;
39545: LD_ADDR_VAR 0 4
39549: PUSH
39550: LD_VAR 0 2
39554: PPUSH
39555: CALL 39990 0 1
39559: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
39560: LD_ADDR_EXP 157
39564: PUSH
39565: LD_EXP 157
39569: PPUSH
39570: LD_VAR 0 2
39574: PPUSH
39575: LD_VAR 0 4
39579: PPUSH
39580: CALL_OW 1
39584: ST_TO_ADDR
// if not tmp then
39585: LD_VAR 0 4
39589: NOT
39590: IFFALSE 39594
// continue ;
39592: GO 39542
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
39594: LD_ADDR_VAR 0 6
39598: PUSH
39599: LD_EXP 116
39603: PUSH
39604: LD_VAR 0 2
39608: ARRAY
39609: PPUSH
39610: LD_INT 2
39612: PUSH
39613: LD_INT 30
39615: PUSH
39616: LD_INT 4
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 30
39625: PUSH
39626: LD_INT 5
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: EMPTY
39634: LIST
39635: LIST
39636: LIST
39637: PPUSH
39638: CALL_OW 72
39642: PUSH
39643: LD_EXP 116
39647: PUSH
39648: LD_VAR 0 2
39652: ARRAY
39653: PPUSH
39654: LD_INT 2
39656: PUSH
39657: LD_INT 30
39659: PUSH
39660: LD_INT 0
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 30
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: LIST
39681: PPUSH
39682: CALL_OW 72
39686: PUSH
39687: LD_EXP 116
39691: PUSH
39692: LD_VAR 0 2
39696: ARRAY
39697: PPUSH
39698: LD_INT 30
39700: PUSH
39701: LD_INT 3
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PPUSH
39708: CALL_OW 72
39712: PUSH
39713: LD_EXP 116
39717: PUSH
39718: LD_VAR 0 2
39722: ARRAY
39723: PPUSH
39724: LD_INT 2
39726: PUSH
39727: LD_INT 30
39729: PUSH
39730: LD_INT 6
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: LD_INT 30
39739: PUSH
39740: LD_INT 7
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 30
39749: PUSH
39750: LD_INT 8
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: EMPTY
39758: LIST
39759: LIST
39760: LIST
39761: LIST
39762: PPUSH
39763: CALL_OW 72
39767: PUSH
39768: EMPTY
39769: LIST
39770: LIST
39771: LIST
39772: LIST
39773: ST_TO_ADDR
// for j = 1 to 4 do
39774: LD_ADDR_VAR 0 3
39778: PUSH
39779: DOUBLE
39780: LD_INT 1
39782: DEC
39783: ST_TO_ADDR
39784: LD_INT 4
39786: PUSH
39787: FOR_TO
39788: IFFALSE 39979
// begin if not tmp [ j ] then
39790: LD_VAR 0 4
39794: PUSH
39795: LD_VAR 0 3
39799: ARRAY
39800: NOT
39801: IFFALSE 39805
// continue ;
39803: GO 39787
// for p in tmp [ j ] do
39805: LD_ADDR_VAR 0 5
39809: PUSH
39810: LD_VAR 0 4
39814: PUSH
39815: LD_VAR 0 3
39819: ARRAY
39820: PUSH
39821: FOR_IN
39822: IFFALSE 39975
// begin if not b [ j ] then
39824: LD_VAR 0 6
39828: PUSH
39829: LD_VAR 0 3
39833: ARRAY
39834: NOT
39835: IFFALSE 39839
// break ;
39837: GO 39975
// e := 0 ;
39839: LD_ADDR_VAR 0 7
39843: PUSH
39844: LD_INT 0
39846: ST_TO_ADDR
// for k in b [ j ] do
39847: LD_ADDR_VAR 0 8
39851: PUSH
39852: LD_VAR 0 6
39856: PUSH
39857: LD_VAR 0 3
39861: ARRAY
39862: PUSH
39863: FOR_IN
39864: IFFALSE 39891
// if IsNotFull ( k ) then
39866: LD_VAR 0 8
39870: PPUSH
39871: CALL 68101 0 1
39875: IFFALSE 39889
// begin e := k ;
39877: LD_ADDR_VAR 0 7
39881: PUSH
39882: LD_VAR 0 8
39886: ST_TO_ADDR
// break ;
39887: GO 39891
// end ;
39889: GO 39863
39891: POP
39892: POP
// if e and not UnitGoingToBuilding ( p , e ) then
39893: LD_VAR 0 7
39897: PUSH
39898: LD_VAR 0 5
39902: PPUSH
39903: LD_VAR 0 7
39907: PPUSH
39908: CALL 101265 0 2
39912: NOT
39913: AND
39914: IFFALSE 39973
// begin if IsInUnit ( p ) then
39916: LD_VAR 0 5
39920: PPUSH
39921: CALL_OW 310
39925: IFFALSE 39936
// ComExitBuilding ( p ) ;
39927: LD_VAR 0 5
39931: PPUSH
39932: CALL_OW 122
// ComEnterUnit ( p , e ) ;
39936: LD_VAR 0 5
39940: PPUSH
39941: LD_VAR 0 7
39945: PPUSH
39946: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
39950: LD_VAR 0 5
39954: PPUSH
39955: LD_VAR 0 3
39959: PPUSH
39960: CALL_OW 183
// AddComExitBuilding ( p ) ;
39964: LD_VAR 0 5
39968: PPUSH
39969: CALL_OW 182
// end ; end ;
39973: GO 39821
39975: POP
39976: POP
// end ;
39977: GO 39787
39979: POP
39980: POP
// end ;
39981: GO 39542
39983: POP
39984: POP
// end ;
39985: LD_VAR 0 1
39989: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
39990: LD_INT 0
39992: PPUSH
39993: PPUSH
39994: PPUSH
39995: PPUSH
39996: PPUSH
39997: PPUSH
39998: PPUSH
39999: PPUSH
40000: PPUSH
40001: PPUSH
40002: PPUSH
40003: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
40004: LD_VAR 0 1
40008: NOT
40009: PUSH
40010: LD_EXP 116
40014: PUSH
40015: LD_VAR 0 1
40019: ARRAY
40020: NOT
40021: OR
40022: PUSH
40023: LD_EXP 116
40027: PUSH
40028: LD_VAR 0 1
40032: ARRAY
40033: PPUSH
40034: LD_INT 2
40036: PUSH
40037: LD_INT 30
40039: PUSH
40040: LD_INT 0
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 30
40049: PUSH
40050: LD_INT 1
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: LIST
40061: PPUSH
40062: CALL_OW 72
40066: NOT
40067: OR
40068: IFFALSE 40072
// exit ;
40070: GO 43575
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40072: LD_ADDR_VAR 0 4
40076: PUSH
40077: LD_EXP 116
40081: PUSH
40082: LD_VAR 0 1
40086: ARRAY
40087: PPUSH
40088: LD_INT 2
40090: PUSH
40091: LD_INT 25
40093: PUSH
40094: LD_INT 1
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 25
40103: PUSH
40104: LD_INT 2
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 25
40113: PUSH
40114: LD_INT 3
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 25
40123: PUSH
40124: LD_INT 4
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 25
40133: PUSH
40134: LD_INT 5
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PUSH
40141: LD_INT 25
40143: PUSH
40144: LD_INT 8
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 25
40153: PUSH
40154: LD_INT 9
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: LIST
40165: LIST
40166: LIST
40167: LIST
40168: LIST
40169: LIST
40170: PPUSH
40171: CALL_OW 72
40175: ST_TO_ADDR
// if not tmp then
40176: LD_VAR 0 4
40180: NOT
40181: IFFALSE 40185
// exit ;
40183: GO 43575
// for i in tmp do
40185: LD_ADDR_VAR 0 3
40189: PUSH
40190: LD_VAR 0 4
40194: PUSH
40195: FOR_IN
40196: IFFALSE 40227
// if GetTag ( i ) then
40198: LD_VAR 0 3
40202: PPUSH
40203: CALL_OW 110
40207: IFFALSE 40225
// tmp := tmp diff i ;
40209: LD_ADDR_VAR 0 4
40213: PUSH
40214: LD_VAR 0 4
40218: PUSH
40219: LD_VAR 0 3
40223: DIFF
40224: ST_TO_ADDR
40225: GO 40195
40227: POP
40228: POP
// if not tmp then
40229: LD_VAR 0 4
40233: NOT
40234: IFFALSE 40238
// exit ;
40236: GO 43575
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
40238: LD_ADDR_VAR 0 5
40242: PUSH
40243: LD_EXP 116
40247: PUSH
40248: LD_VAR 0 1
40252: ARRAY
40253: PPUSH
40254: LD_INT 2
40256: PUSH
40257: LD_INT 25
40259: PUSH
40260: LD_INT 1
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 25
40269: PUSH
40270: LD_INT 5
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 25
40279: PUSH
40280: LD_INT 8
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 25
40289: PUSH
40290: LD_INT 9
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: LIST
40301: LIST
40302: LIST
40303: PPUSH
40304: CALL_OW 72
40308: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
40309: LD_ADDR_VAR 0 6
40313: PUSH
40314: LD_EXP 116
40318: PUSH
40319: LD_VAR 0 1
40323: ARRAY
40324: PPUSH
40325: LD_INT 25
40327: PUSH
40328: LD_INT 2
40330: PUSH
40331: EMPTY
40332: LIST
40333: LIST
40334: PPUSH
40335: CALL_OW 72
40339: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
40340: LD_ADDR_VAR 0 7
40344: PUSH
40345: LD_EXP 116
40349: PUSH
40350: LD_VAR 0 1
40354: ARRAY
40355: PPUSH
40356: LD_INT 25
40358: PUSH
40359: LD_INT 3
40361: PUSH
40362: EMPTY
40363: LIST
40364: LIST
40365: PPUSH
40366: CALL_OW 72
40370: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
40371: LD_ADDR_VAR 0 8
40375: PUSH
40376: LD_EXP 116
40380: PUSH
40381: LD_VAR 0 1
40385: ARRAY
40386: PPUSH
40387: LD_INT 25
40389: PUSH
40390: LD_INT 4
40392: PUSH
40393: EMPTY
40394: LIST
40395: LIST
40396: PUSH
40397: LD_INT 24
40399: PUSH
40400: LD_INT 251
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: EMPTY
40408: LIST
40409: LIST
40410: PPUSH
40411: CALL_OW 72
40415: ST_TO_ADDR
// if mc_is_defending [ base ] then
40416: LD_EXP 159
40420: PUSH
40421: LD_VAR 0 1
40425: ARRAY
40426: IFFALSE 40887
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
40428: LD_ADDR_EXP 158
40432: PUSH
40433: LD_EXP 158
40437: PPUSH
40438: LD_VAR 0 1
40442: PPUSH
40443: LD_INT 4
40445: PPUSH
40446: CALL_OW 1
40450: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
40451: LD_ADDR_VAR 0 12
40455: PUSH
40456: LD_EXP 116
40460: PUSH
40461: LD_VAR 0 1
40465: ARRAY
40466: PPUSH
40467: LD_INT 2
40469: PUSH
40470: LD_INT 30
40472: PUSH
40473: LD_INT 4
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 30
40482: PUSH
40483: LD_INT 5
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: LIST
40494: PPUSH
40495: CALL_OW 72
40499: ST_TO_ADDR
// if not b then
40500: LD_VAR 0 12
40504: NOT
40505: IFFALSE 40509
// exit ;
40507: GO 43575
// p := [ ] ;
40509: LD_ADDR_VAR 0 11
40513: PUSH
40514: EMPTY
40515: ST_TO_ADDR
// if sci >= 2 then
40516: LD_VAR 0 8
40520: PUSH
40521: LD_INT 2
40523: GREATEREQUAL
40524: IFFALSE 40555
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
40526: LD_ADDR_VAR 0 8
40530: PUSH
40531: LD_VAR 0 8
40535: PUSH
40536: LD_INT 1
40538: ARRAY
40539: PUSH
40540: LD_VAR 0 8
40544: PUSH
40545: LD_INT 2
40547: ARRAY
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: ST_TO_ADDR
40553: GO 40616
// if sci = 1 then
40555: LD_VAR 0 8
40559: PUSH
40560: LD_INT 1
40562: EQUAL
40563: IFFALSE 40584
// sci := [ sci [ 1 ] ] else
40565: LD_ADDR_VAR 0 8
40569: PUSH
40570: LD_VAR 0 8
40574: PUSH
40575: LD_INT 1
40577: ARRAY
40578: PUSH
40579: EMPTY
40580: LIST
40581: ST_TO_ADDR
40582: GO 40616
// if sci = 0 then
40584: LD_VAR 0 8
40588: PUSH
40589: LD_INT 0
40591: EQUAL
40592: IFFALSE 40616
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
40594: LD_ADDR_VAR 0 11
40598: PUSH
40599: LD_VAR 0 4
40603: PPUSH
40604: LD_INT 4
40606: PPUSH
40607: CALL 101128 0 2
40611: PUSH
40612: LD_INT 1
40614: ARRAY
40615: ST_TO_ADDR
// if eng > 4 then
40616: LD_VAR 0 6
40620: PUSH
40621: LD_INT 4
40623: GREATER
40624: IFFALSE 40670
// for i = eng downto 4 do
40626: LD_ADDR_VAR 0 3
40630: PUSH
40631: DOUBLE
40632: LD_VAR 0 6
40636: INC
40637: ST_TO_ADDR
40638: LD_INT 4
40640: PUSH
40641: FOR_DOWNTO
40642: IFFALSE 40668
// eng := eng diff eng [ i ] ;
40644: LD_ADDR_VAR 0 6
40648: PUSH
40649: LD_VAR 0 6
40653: PUSH
40654: LD_VAR 0 6
40658: PUSH
40659: LD_VAR 0 3
40663: ARRAY
40664: DIFF
40665: ST_TO_ADDR
40666: GO 40641
40668: POP
40669: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
40670: LD_ADDR_VAR 0 4
40674: PUSH
40675: LD_VAR 0 4
40679: PUSH
40680: LD_VAR 0 5
40684: PUSH
40685: LD_VAR 0 6
40689: UNION
40690: PUSH
40691: LD_VAR 0 7
40695: UNION
40696: PUSH
40697: LD_VAR 0 8
40701: UNION
40702: DIFF
40703: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
40704: LD_ADDR_VAR 0 13
40708: PUSH
40709: LD_EXP 116
40713: PUSH
40714: LD_VAR 0 1
40718: ARRAY
40719: PPUSH
40720: LD_INT 2
40722: PUSH
40723: LD_INT 30
40725: PUSH
40726: LD_INT 32
40728: PUSH
40729: EMPTY
40730: LIST
40731: LIST
40732: PUSH
40733: LD_INT 30
40735: PUSH
40736: LD_INT 31
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: LIST
40747: PPUSH
40748: CALL_OW 72
40752: PUSH
40753: LD_EXP 116
40757: PUSH
40758: LD_VAR 0 1
40762: ARRAY
40763: PPUSH
40764: LD_INT 2
40766: PUSH
40767: LD_INT 30
40769: PUSH
40770: LD_INT 4
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: LD_INT 30
40779: PUSH
40780: LD_INT 5
40782: PUSH
40783: EMPTY
40784: LIST
40785: LIST
40786: PUSH
40787: EMPTY
40788: LIST
40789: LIST
40790: LIST
40791: PPUSH
40792: CALL_OW 72
40796: PUSH
40797: LD_INT 6
40799: MUL
40800: PLUS
40801: ST_TO_ADDR
// if bcount < tmp then
40802: LD_VAR 0 13
40806: PUSH
40807: LD_VAR 0 4
40811: LESS
40812: IFFALSE 40858
// for i = tmp downto bcount do
40814: LD_ADDR_VAR 0 3
40818: PUSH
40819: DOUBLE
40820: LD_VAR 0 4
40824: INC
40825: ST_TO_ADDR
40826: LD_VAR 0 13
40830: PUSH
40831: FOR_DOWNTO
40832: IFFALSE 40856
// tmp := Delete ( tmp , tmp ) ;
40834: LD_ADDR_VAR 0 4
40838: PUSH
40839: LD_VAR 0 4
40843: PPUSH
40844: LD_VAR 0 4
40848: PPUSH
40849: CALL_OW 3
40853: ST_TO_ADDR
40854: GO 40831
40856: POP
40857: POP
// result := [ tmp , 0 , 0 , p ] ;
40858: LD_ADDR_VAR 0 2
40862: PUSH
40863: LD_VAR 0 4
40867: PUSH
40868: LD_INT 0
40870: PUSH
40871: LD_INT 0
40873: PUSH
40874: LD_VAR 0 11
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: LIST
40883: LIST
40884: ST_TO_ADDR
// exit ;
40885: GO 43575
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
40887: LD_EXP 116
40891: PUSH
40892: LD_VAR 0 1
40896: ARRAY
40897: PPUSH
40898: LD_INT 2
40900: PUSH
40901: LD_INT 30
40903: PUSH
40904: LD_INT 6
40906: PUSH
40907: EMPTY
40908: LIST
40909: LIST
40910: PUSH
40911: LD_INT 30
40913: PUSH
40914: LD_INT 7
40916: PUSH
40917: EMPTY
40918: LIST
40919: LIST
40920: PUSH
40921: LD_INT 30
40923: PUSH
40924: LD_INT 8
40926: PUSH
40927: EMPTY
40928: LIST
40929: LIST
40930: PUSH
40931: EMPTY
40932: LIST
40933: LIST
40934: LIST
40935: LIST
40936: PPUSH
40937: CALL_OW 72
40941: NOT
40942: PUSH
40943: LD_EXP 116
40947: PUSH
40948: LD_VAR 0 1
40952: ARRAY
40953: PPUSH
40954: LD_INT 30
40956: PUSH
40957: LD_INT 3
40959: PUSH
40960: EMPTY
40961: LIST
40962: LIST
40963: PPUSH
40964: CALL_OW 72
40968: NOT
40969: AND
40970: IFFALSE 41042
// begin if eng = tmp then
40972: LD_VAR 0 6
40976: PUSH
40977: LD_VAR 0 4
40981: EQUAL
40982: IFFALSE 40986
// exit ;
40984: GO 43575
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
40986: LD_ADDR_EXP 158
40990: PUSH
40991: LD_EXP 158
40995: PPUSH
40996: LD_VAR 0 1
41000: PPUSH
41001: LD_INT 1
41003: PPUSH
41004: CALL_OW 1
41008: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
41009: LD_ADDR_VAR 0 2
41013: PUSH
41014: LD_INT 0
41016: PUSH
41017: LD_VAR 0 4
41021: PUSH
41022: LD_VAR 0 6
41026: DIFF
41027: PUSH
41028: LD_INT 0
41030: PUSH
41031: LD_INT 0
41033: PUSH
41034: EMPTY
41035: LIST
41036: LIST
41037: LIST
41038: LIST
41039: ST_TO_ADDR
// exit ;
41040: GO 43575
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41042: LD_EXP 143
41046: PUSH
41047: LD_EXP 142
41051: PUSH
41052: LD_VAR 0 1
41056: ARRAY
41057: ARRAY
41058: PUSH
41059: LD_EXP 116
41063: PUSH
41064: LD_VAR 0 1
41068: ARRAY
41069: PPUSH
41070: LD_INT 2
41072: PUSH
41073: LD_INT 30
41075: PUSH
41076: LD_INT 6
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 30
41085: PUSH
41086: LD_INT 7
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: PUSH
41093: LD_INT 30
41095: PUSH
41096: LD_INT 8
41098: PUSH
41099: EMPTY
41100: LIST
41101: LIST
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: LIST
41107: LIST
41108: PPUSH
41109: CALL_OW 72
41113: AND
41114: PUSH
41115: LD_EXP 116
41119: PUSH
41120: LD_VAR 0 1
41124: ARRAY
41125: PPUSH
41126: LD_INT 30
41128: PUSH
41129: LD_INT 3
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PPUSH
41136: CALL_OW 72
41140: NOT
41141: AND
41142: IFFALSE 41356
// begin if sci >= 6 then
41144: LD_VAR 0 8
41148: PUSH
41149: LD_INT 6
41151: GREATEREQUAL
41152: IFFALSE 41156
// exit ;
41154: GO 43575
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
41156: LD_ADDR_EXP 158
41160: PUSH
41161: LD_EXP 158
41165: PPUSH
41166: LD_VAR 0 1
41170: PPUSH
41171: LD_INT 2
41173: PPUSH
41174: CALL_OW 1
41178: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
41179: LD_ADDR_VAR 0 9
41183: PUSH
41184: LD_VAR 0 4
41188: PUSH
41189: LD_VAR 0 8
41193: DIFF
41194: PPUSH
41195: LD_INT 4
41197: PPUSH
41198: CALL 101128 0 2
41202: ST_TO_ADDR
// p := [ ] ;
41203: LD_ADDR_VAR 0 11
41207: PUSH
41208: EMPTY
41209: ST_TO_ADDR
// if sci < 6 and sort > 6 then
41210: LD_VAR 0 8
41214: PUSH
41215: LD_INT 6
41217: LESS
41218: PUSH
41219: LD_VAR 0 9
41223: PUSH
41224: LD_INT 6
41226: GREATER
41227: AND
41228: IFFALSE 41309
// begin for i = 1 to 6 - sci do
41230: LD_ADDR_VAR 0 3
41234: PUSH
41235: DOUBLE
41236: LD_INT 1
41238: DEC
41239: ST_TO_ADDR
41240: LD_INT 6
41242: PUSH
41243: LD_VAR 0 8
41247: MINUS
41248: PUSH
41249: FOR_TO
41250: IFFALSE 41305
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
41252: LD_ADDR_VAR 0 11
41256: PUSH
41257: LD_VAR 0 11
41261: PPUSH
41262: LD_VAR 0 11
41266: PUSH
41267: LD_INT 1
41269: PLUS
41270: PPUSH
41271: LD_VAR 0 9
41275: PUSH
41276: LD_INT 1
41278: ARRAY
41279: PPUSH
41280: CALL_OW 2
41284: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
41285: LD_ADDR_VAR 0 9
41289: PUSH
41290: LD_VAR 0 9
41294: PPUSH
41295: LD_INT 1
41297: PPUSH
41298: CALL_OW 3
41302: ST_TO_ADDR
// end ;
41303: GO 41249
41305: POP
41306: POP
// end else
41307: GO 41329
// if sort then
41309: LD_VAR 0 9
41313: IFFALSE 41329
// p := sort [ 1 ] ;
41315: LD_ADDR_VAR 0 11
41319: PUSH
41320: LD_VAR 0 9
41324: PUSH
41325: LD_INT 1
41327: ARRAY
41328: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
41329: LD_ADDR_VAR 0 2
41333: PUSH
41334: LD_INT 0
41336: PUSH
41337: LD_INT 0
41339: PUSH
41340: LD_INT 0
41342: PUSH
41343: LD_VAR 0 11
41347: PUSH
41348: EMPTY
41349: LIST
41350: LIST
41351: LIST
41352: LIST
41353: ST_TO_ADDR
// exit ;
41354: GO 43575
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
41356: LD_EXP 143
41360: PUSH
41361: LD_EXP 142
41365: PUSH
41366: LD_VAR 0 1
41370: ARRAY
41371: ARRAY
41372: PUSH
41373: LD_EXP 116
41377: PUSH
41378: LD_VAR 0 1
41382: ARRAY
41383: PPUSH
41384: LD_INT 2
41386: PUSH
41387: LD_INT 30
41389: PUSH
41390: LD_INT 6
41392: PUSH
41393: EMPTY
41394: LIST
41395: LIST
41396: PUSH
41397: LD_INT 30
41399: PUSH
41400: LD_INT 7
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 30
41409: PUSH
41410: LD_INT 8
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: LIST
41421: LIST
41422: PPUSH
41423: CALL_OW 72
41427: AND
41428: PUSH
41429: LD_EXP 116
41433: PUSH
41434: LD_VAR 0 1
41438: ARRAY
41439: PPUSH
41440: LD_INT 30
41442: PUSH
41443: LD_INT 3
41445: PUSH
41446: EMPTY
41447: LIST
41448: LIST
41449: PPUSH
41450: CALL_OW 72
41454: AND
41455: IFFALSE 42189
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
41457: LD_ADDR_EXP 158
41461: PUSH
41462: LD_EXP 158
41466: PPUSH
41467: LD_VAR 0 1
41471: PPUSH
41472: LD_INT 3
41474: PPUSH
41475: CALL_OW 1
41479: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41480: LD_ADDR_VAR 0 2
41484: PUSH
41485: LD_INT 0
41487: PUSH
41488: LD_INT 0
41490: PUSH
41491: LD_INT 0
41493: PUSH
41494: LD_INT 0
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: LIST
41501: LIST
41502: ST_TO_ADDR
// if not eng then
41503: LD_VAR 0 6
41507: NOT
41508: IFFALSE 41571
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
41510: LD_ADDR_VAR 0 11
41514: PUSH
41515: LD_VAR 0 4
41519: PPUSH
41520: LD_INT 2
41522: PPUSH
41523: CALL 101128 0 2
41527: PUSH
41528: LD_INT 1
41530: ARRAY
41531: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
41532: LD_ADDR_VAR 0 2
41536: PUSH
41537: LD_VAR 0 2
41541: PPUSH
41542: LD_INT 2
41544: PPUSH
41545: LD_VAR 0 11
41549: PPUSH
41550: CALL_OW 1
41554: ST_TO_ADDR
// tmp := tmp diff p ;
41555: LD_ADDR_VAR 0 4
41559: PUSH
41560: LD_VAR 0 4
41564: PUSH
41565: LD_VAR 0 11
41569: DIFF
41570: ST_TO_ADDR
// end ; if tmp and sci < 6 then
41571: LD_VAR 0 4
41575: PUSH
41576: LD_VAR 0 8
41580: PUSH
41581: LD_INT 6
41583: LESS
41584: AND
41585: IFFALSE 41773
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
41587: LD_ADDR_VAR 0 9
41591: PUSH
41592: LD_VAR 0 4
41596: PUSH
41597: LD_VAR 0 8
41601: PUSH
41602: LD_VAR 0 7
41606: UNION
41607: DIFF
41608: PPUSH
41609: LD_INT 4
41611: PPUSH
41612: CALL 101128 0 2
41616: ST_TO_ADDR
// p := [ ] ;
41617: LD_ADDR_VAR 0 11
41621: PUSH
41622: EMPTY
41623: ST_TO_ADDR
// if sort then
41624: LD_VAR 0 9
41628: IFFALSE 41744
// for i = 1 to 6 - sci do
41630: LD_ADDR_VAR 0 3
41634: PUSH
41635: DOUBLE
41636: LD_INT 1
41638: DEC
41639: ST_TO_ADDR
41640: LD_INT 6
41642: PUSH
41643: LD_VAR 0 8
41647: MINUS
41648: PUSH
41649: FOR_TO
41650: IFFALSE 41742
// begin if i = sort then
41652: LD_VAR 0 3
41656: PUSH
41657: LD_VAR 0 9
41661: EQUAL
41662: IFFALSE 41666
// break ;
41664: GO 41742
// if GetClass ( i ) = 4 then
41666: LD_VAR 0 3
41670: PPUSH
41671: CALL_OW 257
41675: PUSH
41676: LD_INT 4
41678: EQUAL
41679: IFFALSE 41683
// continue ;
41681: GO 41649
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41683: LD_ADDR_VAR 0 11
41687: PUSH
41688: LD_VAR 0 11
41692: PPUSH
41693: LD_VAR 0 11
41697: PUSH
41698: LD_INT 1
41700: PLUS
41701: PPUSH
41702: LD_VAR 0 9
41706: PUSH
41707: LD_VAR 0 3
41711: ARRAY
41712: PPUSH
41713: CALL_OW 2
41717: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41718: LD_ADDR_VAR 0 4
41722: PUSH
41723: LD_VAR 0 4
41727: PUSH
41728: LD_VAR 0 9
41732: PUSH
41733: LD_VAR 0 3
41737: ARRAY
41738: DIFF
41739: ST_TO_ADDR
// end ;
41740: GO 41649
41742: POP
41743: POP
// if p then
41744: LD_VAR 0 11
41748: IFFALSE 41773
// result := Replace ( result , 4 , p ) ;
41750: LD_ADDR_VAR 0 2
41754: PUSH
41755: LD_VAR 0 2
41759: PPUSH
41760: LD_INT 4
41762: PPUSH
41763: LD_VAR 0 11
41767: PPUSH
41768: CALL_OW 1
41772: ST_TO_ADDR
// end ; if tmp and mech < 6 then
41773: LD_VAR 0 4
41777: PUSH
41778: LD_VAR 0 7
41782: PUSH
41783: LD_INT 6
41785: LESS
41786: AND
41787: IFFALSE 41975
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41789: LD_ADDR_VAR 0 9
41793: PUSH
41794: LD_VAR 0 4
41798: PUSH
41799: LD_VAR 0 8
41803: PUSH
41804: LD_VAR 0 7
41808: UNION
41809: DIFF
41810: PPUSH
41811: LD_INT 3
41813: PPUSH
41814: CALL 101128 0 2
41818: ST_TO_ADDR
// p := [ ] ;
41819: LD_ADDR_VAR 0 11
41823: PUSH
41824: EMPTY
41825: ST_TO_ADDR
// if sort then
41826: LD_VAR 0 9
41830: IFFALSE 41946
// for i = 1 to 6 - mech do
41832: LD_ADDR_VAR 0 3
41836: PUSH
41837: DOUBLE
41838: LD_INT 1
41840: DEC
41841: ST_TO_ADDR
41842: LD_INT 6
41844: PUSH
41845: LD_VAR 0 7
41849: MINUS
41850: PUSH
41851: FOR_TO
41852: IFFALSE 41944
// begin if i = sort then
41854: LD_VAR 0 3
41858: PUSH
41859: LD_VAR 0 9
41863: EQUAL
41864: IFFALSE 41868
// break ;
41866: GO 41944
// if GetClass ( i ) = 3 then
41868: LD_VAR 0 3
41872: PPUSH
41873: CALL_OW 257
41877: PUSH
41878: LD_INT 3
41880: EQUAL
41881: IFFALSE 41885
// continue ;
41883: GO 41851
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41885: LD_ADDR_VAR 0 11
41889: PUSH
41890: LD_VAR 0 11
41894: PPUSH
41895: LD_VAR 0 11
41899: PUSH
41900: LD_INT 1
41902: PLUS
41903: PPUSH
41904: LD_VAR 0 9
41908: PUSH
41909: LD_VAR 0 3
41913: ARRAY
41914: PPUSH
41915: CALL_OW 2
41919: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41920: LD_ADDR_VAR 0 4
41924: PUSH
41925: LD_VAR 0 4
41929: PUSH
41930: LD_VAR 0 9
41934: PUSH
41935: LD_VAR 0 3
41939: ARRAY
41940: DIFF
41941: ST_TO_ADDR
// end ;
41942: GO 41851
41944: POP
41945: POP
// if p then
41946: LD_VAR 0 11
41950: IFFALSE 41975
// result := Replace ( result , 3 , p ) ;
41952: LD_ADDR_VAR 0 2
41956: PUSH
41957: LD_VAR 0 2
41961: PPUSH
41962: LD_INT 3
41964: PPUSH
41965: LD_VAR 0 11
41969: PPUSH
41970: CALL_OW 1
41974: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
41975: LD_VAR 0 4
41979: PUSH
41980: LD_INT 6
41982: GREATER
41983: PUSH
41984: LD_VAR 0 6
41988: PUSH
41989: LD_INT 6
41991: LESS
41992: AND
41993: IFFALSE 42187
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41995: LD_ADDR_VAR 0 9
41999: PUSH
42000: LD_VAR 0 4
42004: PUSH
42005: LD_VAR 0 8
42009: PUSH
42010: LD_VAR 0 7
42014: UNION
42015: PUSH
42016: LD_VAR 0 6
42020: UNION
42021: DIFF
42022: PPUSH
42023: LD_INT 2
42025: PPUSH
42026: CALL 101128 0 2
42030: ST_TO_ADDR
// p := [ ] ;
42031: LD_ADDR_VAR 0 11
42035: PUSH
42036: EMPTY
42037: ST_TO_ADDR
// if sort then
42038: LD_VAR 0 9
42042: IFFALSE 42158
// for i = 1 to 6 - eng do
42044: LD_ADDR_VAR 0 3
42048: PUSH
42049: DOUBLE
42050: LD_INT 1
42052: DEC
42053: ST_TO_ADDR
42054: LD_INT 6
42056: PUSH
42057: LD_VAR 0 6
42061: MINUS
42062: PUSH
42063: FOR_TO
42064: IFFALSE 42156
// begin if i = sort then
42066: LD_VAR 0 3
42070: PUSH
42071: LD_VAR 0 9
42075: EQUAL
42076: IFFALSE 42080
// break ;
42078: GO 42156
// if GetClass ( i ) = 2 then
42080: LD_VAR 0 3
42084: PPUSH
42085: CALL_OW 257
42089: PUSH
42090: LD_INT 2
42092: EQUAL
42093: IFFALSE 42097
// continue ;
42095: GO 42063
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42097: LD_ADDR_VAR 0 11
42101: PUSH
42102: LD_VAR 0 11
42106: PPUSH
42107: LD_VAR 0 11
42111: PUSH
42112: LD_INT 1
42114: PLUS
42115: PPUSH
42116: LD_VAR 0 9
42120: PUSH
42121: LD_VAR 0 3
42125: ARRAY
42126: PPUSH
42127: CALL_OW 2
42131: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42132: LD_ADDR_VAR 0 4
42136: PUSH
42137: LD_VAR 0 4
42141: PUSH
42142: LD_VAR 0 9
42146: PUSH
42147: LD_VAR 0 3
42151: ARRAY
42152: DIFF
42153: ST_TO_ADDR
// end ;
42154: GO 42063
42156: POP
42157: POP
// if p then
42158: LD_VAR 0 11
42162: IFFALSE 42187
// result := Replace ( result , 2 , p ) ;
42164: LD_ADDR_VAR 0 2
42168: PUSH
42169: LD_VAR 0 2
42173: PPUSH
42174: LD_INT 2
42176: PPUSH
42177: LD_VAR 0 11
42181: PPUSH
42182: CALL_OW 1
42186: ST_TO_ADDR
// end ; exit ;
42187: GO 43575
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
42189: LD_EXP 143
42193: PUSH
42194: LD_EXP 142
42198: PUSH
42199: LD_VAR 0 1
42203: ARRAY
42204: ARRAY
42205: NOT
42206: PUSH
42207: LD_EXP 116
42211: PUSH
42212: LD_VAR 0 1
42216: ARRAY
42217: PPUSH
42218: LD_INT 30
42220: PUSH
42221: LD_INT 3
42223: PUSH
42224: EMPTY
42225: LIST
42226: LIST
42227: PPUSH
42228: CALL_OW 72
42232: AND
42233: PUSH
42234: LD_EXP 121
42238: PUSH
42239: LD_VAR 0 1
42243: ARRAY
42244: AND
42245: IFFALSE 42853
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
42247: LD_ADDR_EXP 158
42251: PUSH
42252: LD_EXP 158
42256: PPUSH
42257: LD_VAR 0 1
42261: PPUSH
42262: LD_INT 5
42264: PPUSH
42265: CALL_OW 1
42269: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42270: LD_ADDR_VAR 0 2
42274: PUSH
42275: LD_INT 0
42277: PUSH
42278: LD_INT 0
42280: PUSH
42281: LD_INT 0
42283: PUSH
42284: LD_INT 0
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: LIST
42291: LIST
42292: ST_TO_ADDR
// if sci > 1 then
42293: LD_VAR 0 8
42297: PUSH
42298: LD_INT 1
42300: GREATER
42301: IFFALSE 42329
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
42303: LD_ADDR_VAR 0 4
42307: PUSH
42308: LD_VAR 0 4
42312: PUSH
42313: LD_VAR 0 8
42317: PUSH
42318: LD_VAR 0 8
42322: PUSH
42323: LD_INT 1
42325: ARRAY
42326: DIFF
42327: DIFF
42328: ST_TO_ADDR
// if tmp and not sci then
42329: LD_VAR 0 4
42333: PUSH
42334: LD_VAR 0 8
42338: NOT
42339: AND
42340: IFFALSE 42409
// begin sort := SortBySkill ( tmp , 4 ) ;
42342: LD_ADDR_VAR 0 9
42346: PUSH
42347: LD_VAR 0 4
42351: PPUSH
42352: LD_INT 4
42354: PPUSH
42355: CALL 101128 0 2
42359: ST_TO_ADDR
// if sort then
42360: LD_VAR 0 9
42364: IFFALSE 42380
// p := sort [ 1 ] ;
42366: LD_ADDR_VAR 0 11
42370: PUSH
42371: LD_VAR 0 9
42375: PUSH
42376: LD_INT 1
42378: ARRAY
42379: ST_TO_ADDR
// if p then
42380: LD_VAR 0 11
42384: IFFALSE 42409
// result := Replace ( result , 4 , p ) ;
42386: LD_ADDR_VAR 0 2
42390: PUSH
42391: LD_VAR 0 2
42395: PPUSH
42396: LD_INT 4
42398: PPUSH
42399: LD_VAR 0 11
42403: PPUSH
42404: CALL_OW 1
42408: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
42409: LD_ADDR_VAR 0 4
42413: PUSH
42414: LD_VAR 0 4
42418: PUSH
42419: LD_VAR 0 7
42423: DIFF
42424: ST_TO_ADDR
// if tmp and mech < 6 then
42425: LD_VAR 0 4
42429: PUSH
42430: LD_VAR 0 7
42434: PUSH
42435: LD_INT 6
42437: LESS
42438: AND
42439: IFFALSE 42627
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
42441: LD_ADDR_VAR 0 9
42445: PUSH
42446: LD_VAR 0 4
42450: PUSH
42451: LD_VAR 0 8
42455: PUSH
42456: LD_VAR 0 7
42460: UNION
42461: DIFF
42462: PPUSH
42463: LD_INT 3
42465: PPUSH
42466: CALL 101128 0 2
42470: ST_TO_ADDR
// p := [ ] ;
42471: LD_ADDR_VAR 0 11
42475: PUSH
42476: EMPTY
42477: ST_TO_ADDR
// if sort then
42478: LD_VAR 0 9
42482: IFFALSE 42598
// for i = 1 to 6 - mech do
42484: LD_ADDR_VAR 0 3
42488: PUSH
42489: DOUBLE
42490: LD_INT 1
42492: DEC
42493: ST_TO_ADDR
42494: LD_INT 6
42496: PUSH
42497: LD_VAR 0 7
42501: MINUS
42502: PUSH
42503: FOR_TO
42504: IFFALSE 42596
// begin if i = sort then
42506: LD_VAR 0 3
42510: PUSH
42511: LD_VAR 0 9
42515: EQUAL
42516: IFFALSE 42520
// break ;
42518: GO 42596
// if GetClass ( i ) = 3 then
42520: LD_VAR 0 3
42524: PPUSH
42525: CALL_OW 257
42529: PUSH
42530: LD_INT 3
42532: EQUAL
42533: IFFALSE 42537
// continue ;
42535: GO 42503
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42537: LD_ADDR_VAR 0 11
42541: PUSH
42542: LD_VAR 0 11
42546: PPUSH
42547: LD_VAR 0 11
42551: PUSH
42552: LD_INT 1
42554: PLUS
42555: PPUSH
42556: LD_VAR 0 9
42560: PUSH
42561: LD_VAR 0 3
42565: ARRAY
42566: PPUSH
42567: CALL_OW 2
42571: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42572: LD_ADDR_VAR 0 4
42576: PUSH
42577: LD_VAR 0 4
42581: PUSH
42582: LD_VAR 0 9
42586: PUSH
42587: LD_VAR 0 3
42591: ARRAY
42592: DIFF
42593: ST_TO_ADDR
// end ;
42594: GO 42503
42596: POP
42597: POP
// if p then
42598: LD_VAR 0 11
42602: IFFALSE 42627
// result := Replace ( result , 3 , p ) ;
42604: LD_ADDR_VAR 0 2
42608: PUSH
42609: LD_VAR 0 2
42613: PPUSH
42614: LD_INT 3
42616: PPUSH
42617: LD_VAR 0 11
42621: PPUSH
42622: CALL_OW 1
42626: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
42627: LD_ADDR_VAR 0 4
42631: PUSH
42632: LD_VAR 0 4
42636: PUSH
42637: LD_VAR 0 6
42641: DIFF
42642: ST_TO_ADDR
// if tmp and eng < 6 then
42643: LD_VAR 0 4
42647: PUSH
42648: LD_VAR 0 6
42652: PUSH
42653: LD_INT 6
42655: LESS
42656: AND
42657: IFFALSE 42851
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
42659: LD_ADDR_VAR 0 9
42663: PUSH
42664: LD_VAR 0 4
42668: PUSH
42669: LD_VAR 0 8
42673: PUSH
42674: LD_VAR 0 7
42678: UNION
42679: PUSH
42680: LD_VAR 0 6
42684: UNION
42685: DIFF
42686: PPUSH
42687: LD_INT 2
42689: PPUSH
42690: CALL 101128 0 2
42694: ST_TO_ADDR
// p := [ ] ;
42695: LD_ADDR_VAR 0 11
42699: PUSH
42700: EMPTY
42701: ST_TO_ADDR
// if sort then
42702: LD_VAR 0 9
42706: IFFALSE 42822
// for i = 1 to 6 - eng do
42708: LD_ADDR_VAR 0 3
42712: PUSH
42713: DOUBLE
42714: LD_INT 1
42716: DEC
42717: ST_TO_ADDR
42718: LD_INT 6
42720: PUSH
42721: LD_VAR 0 6
42725: MINUS
42726: PUSH
42727: FOR_TO
42728: IFFALSE 42820
// begin if i = sort then
42730: LD_VAR 0 3
42734: PUSH
42735: LD_VAR 0 9
42739: EQUAL
42740: IFFALSE 42744
// break ;
42742: GO 42820
// if GetClass ( i ) = 2 then
42744: LD_VAR 0 3
42748: PPUSH
42749: CALL_OW 257
42753: PUSH
42754: LD_INT 2
42756: EQUAL
42757: IFFALSE 42761
// continue ;
42759: GO 42727
// p := Insert ( p , p + 1 , sort [ i ] ) ;
42761: LD_ADDR_VAR 0 11
42765: PUSH
42766: LD_VAR 0 11
42770: PPUSH
42771: LD_VAR 0 11
42775: PUSH
42776: LD_INT 1
42778: PLUS
42779: PPUSH
42780: LD_VAR 0 9
42784: PUSH
42785: LD_VAR 0 3
42789: ARRAY
42790: PPUSH
42791: CALL_OW 2
42795: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42796: LD_ADDR_VAR 0 4
42800: PUSH
42801: LD_VAR 0 4
42805: PUSH
42806: LD_VAR 0 9
42810: PUSH
42811: LD_VAR 0 3
42815: ARRAY
42816: DIFF
42817: ST_TO_ADDR
// end ;
42818: GO 42727
42820: POP
42821: POP
// if p then
42822: LD_VAR 0 11
42826: IFFALSE 42851
// result := Replace ( result , 2 , p ) ;
42828: LD_ADDR_VAR 0 2
42832: PUSH
42833: LD_VAR 0 2
42837: PPUSH
42838: LD_INT 2
42840: PPUSH
42841: LD_VAR 0 11
42845: PPUSH
42846: CALL_OW 1
42850: ST_TO_ADDR
// end ; exit ;
42851: GO 43575
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
42853: LD_EXP 143
42857: PUSH
42858: LD_EXP 142
42862: PUSH
42863: LD_VAR 0 1
42867: ARRAY
42868: ARRAY
42869: NOT
42870: PUSH
42871: LD_EXP 116
42875: PUSH
42876: LD_VAR 0 1
42880: ARRAY
42881: PPUSH
42882: LD_INT 30
42884: PUSH
42885: LD_INT 3
42887: PUSH
42888: EMPTY
42889: LIST
42890: LIST
42891: PPUSH
42892: CALL_OW 72
42896: AND
42897: PUSH
42898: LD_EXP 121
42902: PUSH
42903: LD_VAR 0 1
42907: ARRAY
42908: NOT
42909: AND
42910: IFFALSE 43575
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
42912: LD_ADDR_EXP 158
42916: PUSH
42917: LD_EXP 158
42921: PPUSH
42922: LD_VAR 0 1
42926: PPUSH
42927: LD_INT 6
42929: PPUSH
42930: CALL_OW 1
42934: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
42935: LD_ADDR_VAR 0 2
42939: PUSH
42940: LD_INT 0
42942: PUSH
42943: LD_INT 0
42945: PUSH
42946: LD_INT 0
42948: PUSH
42949: LD_INT 0
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: LIST
42956: LIST
42957: ST_TO_ADDR
// if sci >= 1 then
42958: LD_VAR 0 8
42962: PUSH
42963: LD_INT 1
42965: GREATEREQUAL
42966: IFFALSE 42988
// tmp := tmp diff sci [ 1 ] ;
42968: LD_ADDR_VAR 0 4
42972: PUSH
42973: LD_VAR 0 4
42977: PUSH
42978: LD_VAR 0 8
42982: PUSH
42983: LD_INT 1
42985: ARRAY
42986: DIFF
42987: ST_TO_ADDR
// if tmp and not sci then
42988: LD_VAR 0 4
42992: PUSH
42993: LD_VAR 0 8
42997: NOT
42998: AND
42999: IFFALSE 43068
// begin sort := SortBySkill ( tmp , 4 ) ;
43001: LD_ADDR_VAR 0 9
43005: PUSH
43006: LD_VAR 0 4
43010: PPUSH
43011: LD_INT 4
43013: PPUSH
43014: CALL 101128 0 2
43018: ST_TO_ADDR
// if sort then
43019: LD_VAR 0 9
43023: IFFALSE 43039
// p := sort [ 1 ] ;
43025: LD_ADDR_VAR 0 11
43029: PUSH
43030: LD_VAR 0 9
43034: PUSH
43035: LD_INT 1
43037: ARRAY
43038: ST_TO_ADDR
// if p then
43039: LD_VAR 0 11
43043: IFFALSE 43068
// result := Replace ( result , 4 , p ) ;
43045: LD_ADDR_VAR 0 2
43049: PUSH
43050: LD_VAR 0 2
43054: PPUSH
43055: LD_INT 4
43057: PPUSH
43058: LD_VAR 0 11
43062: PPUSH
43063: CALL_OW 1
43067: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
43068: LD_ADDR_VAR 0 4
43072: PUSH
43073: LD_VAR 0 4
43077: PUSH
43078: LD_VAR 0 7
43082: DIFF
43083: ST_TO_ADDR
// if tmp and mech < 6 then
43084: LD_VAR 0 4
43088: PUSH
43089: LD_VAR 0 7
43093: PUSH
43094: LD_INT 6
43096: LESS
43097: AND
43098: IFFALSE 43280
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
43100: LD_ADDR_VAR 0 9
43104: PUSH
43105: LD_VAR 0 4
43109: PUSH
43110: LD_VAR 0 7
43114: DIFF
43115: PPUSH
43116: LD_INT 3
43118: PPUSH
43119: CALL 101128 0 2
43123: ST_TO_ADDR
// p := [ ] ;
43124: LD_ADDR_VAR 0 11
43128: PUSH
43129: EMPTY
43130: ST_TO_ADDR
// if sort then
43131: LD_VAR 0 9
43135: IFFALSE 43251
// for i = 1 to 6 - mech do
43137: LD_ADDR_VAR 0 3
43141: PUSH
43142: DOUBLE
43143: LD_INT 1
43145: DEC
43146: ST_TO_ADDR
43147: LD_INT 6
43149: PUSH
43150: LD_VAR 0 7
43154: MINUS
43155: PUSH
43156: FOR_TO
43157: IFFALSE 43249
// begin if i = sort then
43159: LD_VAR 0 3
43163: PUSH
43164: LD_VAR 0 9
43168: EQUAL
43169: IFFALSE 43173
// break ;
43171: GO 43249
// if GetClass ( i ) = 3 then
43173: LD_VAR 0 3
43177: PPUSH
43178: CALL_OW 257
43182: PUSH
43183: LD_INT 3
43185: EQUAL
43186: IFFALSE 43190
// continue ;
43188: GO 43156
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43190: LD_ADDR_VAR 0 11
43194: PUSH
43195: LD_VAR 0 11
43199: PPUSH
43200: LD_VAR 0 11
43204: PUSH
43205: LD_INT 1
43207: PLUS
43208: PPUSH
43209: LD_VAR 0 9
43213: PUSH
43214: LD_VAR 0 3
43218: ARRAY
43219: PPUSH
43220: CALL_OW 2
43224: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43225: LD_ADDR_VAR 0 4
43229: PUSH
43230: LD_VAR 0 4
43234: PUSH
43235: LD_VAR 0 9
43239: PUSH
43240: LD_VAR 0 3
43244: ARRAY
43245: DIFF
43246: ST_TO_ADDR
// end ;
43247: GO 43156
43249: POP
43250: POP
// if p then
43251: LD_VAR 0 11
43255: IFFALSE 43280
// result := Replace ( result , 3 , p ) ;
43257: LD_ADDR_VAR 0 2
43261: PUSH
43262: LD_VAR 0 2
43266: PPUSH
43267: LD_INT 3
43269: PPUSH
43270: LD_VAR 0 11
43274: PPUSH
43275: CALL_OW 1
43279: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
43280: LD_ADDR_VAR 0 4
43284: PUSH
43285: LD_VAR 0 4
43289: PUSH
43290: LD_VAR 0 6
43294: DIFF
43295: ST_TO_ADDR
// if tmp and eng < 4 then
43296: LD_VAR 0 4
43300: PUSH
43301: LD_VAR 0 6
43305: PUSH
43306: LD_INT 4
43308: LESS
43309: AND
43310: IFFALSE 43500
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
43312: LD_ADDR_VAR 0 9
43316: PUSH
43317: LD_VAR 0 4
43321: PUSH
43322: LD_VAR 0 7
43326: PUSH
43327: LD_VAR 0 6
43331: UNION
43332: DIFF
43333: PPUSH
43334: LD_INT 2
43336: PPUSH
43337: CALL 101128 0 2
43341: ST_TO_ADDR
// p := [ ] ;
43342: LD_ADDR_VAR 0 11
43346: PUSH
43347: EMPTY
43348: ST_TO_ADDR
// if sort then
43349: LD_VAR 0 9
43353: IFFALSE 43469
// for i = 1 to 4 - eng do
43355: LD_ADDR_VAR 0 3
43359: PUSH
43360: DOUBLE
43361: LD_INT 1
43363: DEC
43364: ST_TO_ADDR
43365: LD_INT 4
43367: PUSH
43368: LD_VAR 0 6
43372: MINUS
43373: PUSH
43374: FOR_TO
43375: IFFALSE 43467
// begin if i = sort then
43377: LD_VAR 0 3
43381: PUSH
43382: LD_VAR 0 9
43386: EQUAL
43387: IFFALSE 43391
// break ;
43389: GO 43467
// if GetClass ( i ) = 2 then
43391: LD_VAR 0 3
43395: PPUSH
43396: CALL_OW 257
43400: PUSH
43401: LD_INT 2
43403: EQUAL
43404: IFFALSE 43408
// continue ;
43406: GO 43374
// p := Insert ( p , p + 1 , sort [ i ] ) ;
43408: LD_ADDR_VAR 0 11
43412: PUSH
43413: LD_VAR 0 11
43417: PPUSH
43418: LD_VAR 0 11
43422: PUSH
43423: LD_INT 1
43425: PLUS
43426: PPUSH
43427: LD_VAR 0 9
43431: PUSH
43432: LD_VAR 0 3
43436: ARRAY
43437: PPUSH
43438: CALL_OW 2
43442: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
43443: LD_ADDR_VAR 0 4
43447: PUSH
43448: LD_VAR 0 4
43452: PUSH
43453: LD_VAR 0 9
43457: PUSH
43458: LD_VAR 0 3
43462: ARRAY
43463: DIFF
43464: ST_TO_ADDR
// end ;
43465: GO 43374
43467: POP
43468: POP
// if p then
43469: LD_VAR 0 11
43473: IFFALSE 43498
// result := Replace ( result , 2 , p ) ;
43475: LD_ADDR_VAR 0 2
43479: PUSH
43480: LD_VAR 0 2
43484: PPUSH
43485: LD_INT 2
43487: PPUSH
43488: LD_VAR 0 11
43492: PPUSH
43493: CALL_OW 1
43497: ST_TO_ADDR
// end else
43498: GO 43544
// for i = eng downto 5 do
43500: LD_ADDR_VAR 0 3
43504: PUSH
43505: DOUBLE
43506: LD_VAR 0 6
43510: INC
43511: ST_TO_ADDR
43512: LD_INT 5
43514: PUSH
43515: FOR_DOWNTO
43516: IFFALSE 43542
// tmp := tmp union eng [ i ] ;
43518: LD_ADDR_VAR 0 4
43522: PUSH
43523: LD_VAR 0 4
43527: PUSH
43528: LD_VAR 0 6
43532: PUSH
43533: LD_VAR 0 3
43537: ARRAY
43538: UNION
43539: ST_TO_ADDR
43540: GO 43515
43542: POP
43543: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
43544: LD_ADDR_VAR 0 2
43548: PUSH
43549: LD_VAR 0 2
43553: PPUSH
43554: LD_INT 1
43556: PPUSH
43557: LD_VAR 0 4
43561: PUSH
43562: LD_VAR 0 5
43566: DIFF
43567: PPUSH
43568: CALL_OW 1
43572: ST_TO_ADDR
// exit ;
43573: GO 43575
// end ; end ;
43575: LD_VAR 0 2
43579: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
43580: LD_INT 0
43582: PPUSH
43583: PPUSH
43584: PPUSH
// if not mc_bases then
43585: LD_EXP 116
43589: NOT
43590: IFFALSE 43594
// exit ;
43592: GO 43736
// for i = 1 to mc_bases do
43594: LD_ADDR_VAR 0 2
43598: PUSH
43599: DOUBLE
43600: LD_INT 1
43602: DEC
43603: ST_TO_ADDR
43604: LD_EXP 116
43608: PUSH
43609: FOR_TO
43610: IFFALSE 43727
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
43612: LD_ADDR_VAR 0 3
43616: PUSH
43617: LD_EXP 116
43621: PUSH
43622: LD_VAR 0 2
43626: ARRAY
43627: PPUSH
43628: LD_INT 21
43630: PUSH
43631: LD_INT 3
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 3
43640: PUSH
43641: LD_INT 2
43643: PUSH
43644: LD_INT 30
43646: PUSH
43647: LD_INT 29
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 30
43656: PUSH
43657: LD_INT 30
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: LIST
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: PUSH
43673: LD_INT 3
43675: PUSH
43676: LD_INT 24
43678: PUSH
43679: LD_INT 1000
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: LIST
43694: PPUSH
43695: CALL_OW 72
43699: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
43700: LD_ADDR_EXP 117
43704: PUSH
43705: LD_EXP 117
43709: PPUSH
43710: LD_VAR 0 2
43714: PPUSH
43715: LD_VAR 0 3
43719: PPUSH
43720: CALL_OW 1
43724: ST_TO_ADDR
// end ;
43725: GO 43609
43727: POP
43728: POP
// RaiseSailEvent ( 101 ) ;
43729: LD_INT 101
43731: PPUSH
43732: CALL_OW 427
// end ;
43736: LD_VAR 0 1
43740: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
43741: LD_INT 0
43743: PPUSH
43744: PPUSH
43745: PPUSH
43746: PPUSH
43747: PPUSH
43748: PPUSH
43749: PPUSH
// if not mc_bases then
43750: LD_EXP 116
43754: NOT
43755: IFFALSE 43759
// exit ;
43757: GO 44321
// for i = 1 to mc_bases do
43759: LD_ADDR_VAR 0 2
43763: PUSH
43764: DOUBLE
43765: LD_INT 1
43767: DEC
43768: ST_TO_ADDR
43769: LD_EXP 116
43773: PUSH
43774: FOR_TO
43775: IFFALSE 44312
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
43777: LD_ADDR_VAR 0 5
43781: PUSH
43782: LD_EXP 116
43786: PUSH
43787: LD_VAR 0 2
43791: ARRAY
43792: PUSH
43793: LD_EXP 145
43797: PUSH
43798: LD_VAR 0 2
43802: ARRAY
43803: UNION
43804: PPUSH
43805: LD_INT 21
43807: PUSH
43808: LD_INT 1
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: LD_INT 1
43817: PUSH
43818: LD_INT 3
43820: PUSH
43821: LD_INT 54
43823: PUSH
43824: EMPTY
43825: LIST
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 3
43833: PUSH
43834: LD_INT 24
43836: PUSH
43837: LD_INT 1000
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: EMPTY
43849: LIST
43850: LIST
43851: LIST
43852: PUSH
43853: EMPTY
43854: LIST
43855: LIST
43856: PPUSH
43857: CALL_OW 72
43861: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
43862: LD_ADDR_VAR 0 6
43866: PUSH
43867: LD_EXP 116
43871: PUSH
43872: LD_VAR 0 2
43876: ARRAY
43877: PPUSH
43878: LD_INT 21
43880: PUSH
43881: LD_INT 1
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 1
43890: PUSH
43891: LD_INT 3
43893: PUSH
43894: LD_INT 54
43896: PUSH
43897: EMPTY
43898: LIST
43899: PUSH
43900: EMPTY
43901: LIST
43902: LIST
43903: PUSH
43904: LD_INT 3
43906: PUSH
43907: LD_INT 24
43909: PUSH
43910: LD_INT 250
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: EMPTY
43918: LIST
43919: LIST
43920: PUSH
43921: EMPTY
43922: LIST
43923: LIST
43924: LIST
43925: PUSH
43926: EMPTY
43927: LIST
43928: LIST
43929: PPUSH
43930: CALL_OW 72
43934: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
43935: LD_ADDR_VAR 0 7
43939: PUSH
43940: LD_VAR 0 5
43944: PUSH
43945: LD_VAR 0 6
43949: DIFF
43950: ST_TO_ADDR
// if not need_heal_1 then
43951: LD_VAR 0 6
43955: NOT
43956: IFFALSE 43989
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
43958: LD_ADDR_EXP 119
43962: PUSH
43963: LD_EXP 119
43967: PPUSH
43968: LD_VAR 0 2
43972: PUSH
43973: LD_INT 1
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PPUSH
43980: EMPTY
43981: PPUSH
43982: CALL 70871 0 3
43986: ST_TO_ADDR
43987: GO 44059
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
43989: LD_ADDR_EXP 119
43993: PUSH
43994: LD_EXP 119
43998: PPUSH
43999: LD_VAR 0 2
44003: PUSH
44004: LD_INT 1
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PPUSH
44011: LD_EXP 119
44015: PUSH
44016: LD_VAR 0 2
44020: ARRAY
44021: PUSH
44022: LD_INT 1
44024: ARRAY
44025: PPUSH
44026: LD_INT 3
44028: PUSH
44029: LD_INT 24
44031: PUSH
44032: LD_INT 1000
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: EMPTY
44040: LIST
44041: LIST
44042: PPUSH
44043: CALL_OW 72
44047: PUSH
44048: LD_VAR 0 6
44052: UNION
44053: PPUSH
44054: CALL 70871 0 3
44058: ST_TO_ADDR
// if not need_heal_2 then
44059: LD_VAR 0 7
44063: NOT
44064: IFFALSE 44097
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
44066: LD_ADDR_EXP 119
44070: PUSH
44071: LD_EXP 119
44075: PPUSH
44076: LD_VAR 0 2
44080: PUSH
44081: LD_INT 2
44083: PUSH
44084: EMPTY
44085: LIST
44086: LIST
44087: PPUSH
44088: EMPTY
44089: PPUSH
44090: CALL 70871 0 3
44094: ST_TO_ADDR
44095: GO 44129
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
44097: LD_ADDR_EXP 119
44101: PUSH
44102: LD_EXP 119
44106: PPUSH
44107: LD_VAR 0 2
44111: PUSH
44112: LD_INT 2
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PPUSH
44119: LD_VAR 0 7
44123: PPUSH
44124: CALL 70871 0 3
44128: ST_TO_ADDR
// if need_heal_2 then
44129: LD_VAR 0 7
44133: IFFALSE 44294
// for j in need_heal_2 do
44135: LD_ADDR_VAR 0 3
44139: PUSH
44140: LD_VAR 0 7
44144: PUSH
44145: FOR_IN
44146: IFFALSE 44292
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44148: LD_ADDR_VAR 0 5
44152: PUSH
44153: LD_EXP 116
44157: PUSH
44158: LD_VAR 0 2
44162: ARRAY
44163: PPUSH
44164: LD_INT 2
44166: PUSH
44167: LD_INT 30
44169: PUSH
44170: LD_INT 6
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: LD_INT 30
44179: PUSH
44180: LD_INT 7
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_INT 30
44189: PUSH
44190: LD_INT 8
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: PUSH
44197: LD_INT 30
44199: PUSH
44200: LD_INT 0
44202: PUSH
44203: EMPTY
44204: LIST
44205: LIST
44206: PUSH
44207: LD_INT 30
44209: PUSH
44210: LD_INT 1
44212: PUSH
44213: EMPTY
44214: LIST
44215: LIST
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: LIST
44221: LIST
44222: LIST
44223: LIST
44224: PPUSH
44225: CALL_OW 72
44229: ST_TO_ADDR
// if tmp then
44230: LD_VAR 0 5
44234: IFFALSE 44290
// begin k := NearestUnitToUnit ( tmp , j ) ;
44236: LD_ADDR_VAR 0 4
44240: PUSH
44241: LD_VAR 0 5
44245: PPUSH
44246: LD_VAR 0 3
44250: PPUSH
44251: CALL_OW 74
44255: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
44256: LD_VAR 0 3
44260: PPUSH
44261: LD_VAR 0 4
44265: PPUSH
44266: CALL_OW 296
44270: PUSH
44271: LD_INT 5
44273: GREATER
44274: IFFALSE 44290
// ComMoveToNearbyEntrance ( j , k ) ;
44276: LD_VAR 0 3
44280: PPUSH
44281: LD_VAR 0 4
44285: PPUSH
44286: CALL 103489 0 2
// end ; end ;
44290: GO 44145
44292: POP
44293: POP
// if not need_heal_1 and not need_heal_2 then
44294: LD_VAR 0 6
44298: NOT
44299: PUSH
44300: LD_VAR 0 7
44304: NOT
44305: AND
44306: IFFALSE 44310
// continue ;
44308: GO 43774
// end ;
44310: GO 43774
44312: POP
44313: POP
// RaiseSailEvent ( 102 ) ;
44314: LD_INT 102
44316: PPUSH
44317: CALL_OW 427
// end ;
44321: LD_VAR 0 1
44325: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
44326: LD_INT 0
44328: PPUSH
44329: PPUSH
44330: PPUSH
44331: PPUSH
44332: PPUSH
44333: PPUSH
44334: PPUSH
44335: PPUSH
// if not mc_bases then
44336: LD_EXP 116
44340: NOT
44341: IFFALSE 44345
// exit ;
44343: GO 45228
// for i = 1 to mc_bases do
44345: LD_ADDR_VAR 0 2
44349: PUSH
44350: DOUBLE
44351: LD_INT 1
44353: DEC
44354: ST_TO_ADDR
44355: LD_EXP 116
44359: PUSH
44360: FOR_TO
44361: IFFALSE 45226
// begin if not mc_building_need_repair [ i ] then
44363: LD_EXP 117
44367: PUSH
44368: LD_VAR 0 2
44372: ARRAY
44373: NOT
44374: IFFALSE 44561
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
44376: LD_ADDR_VAR 0 6
44380: PUSH
44381: LD_EXP 135
44385: PUSH
44386: LD_VAR 0 2
44390: ARRAY
44391: PPUSH
44392: LD_INT 3
44394: PUSH
44395: LD_INT 24
44397: PUSH
44398: LD_INT 1000
44400: PUSH
44401: EMPTY
44402: LIST
44403: LIST
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: PUSH
44409: LD_INT 2
44411: PUSH
44412: LD_INT 34
44414: PUSH
44415: LD_INT 13
44417: PUSH
44418: EMPTY
44419: LIST
44420: LIST
44421: PUSH
44422: LD_INT 34
44424: PUSH
44425: LD_INT 52
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: PUSH
44432: LD_INT 34
44434: PUSH
44435: LD_EXP 101
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: EMPTY
44445: LIST
44446: LIST
44447: LIST
44448: LIST
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PPUSH
44454: CALL_OW 72
44458: ST_TO_ADDR
// if cranes then
44459: LD_VAR 0 6
44463: IFFALSE 44525
// for j in cranes do
44465: LD_ADDR_VAR 0 3
44469: PUSH
44470: LD_VAR 0 6
44474: PUSH
44475: FOR_IN
44476: IFFALSE 44523
// if not IsInArea ( j , mc_parking [ i ] ) then
44478: LD_VAR 0 3
44482: PPUSH
44483: LD_EXP 140
44487: PUSH
44488: LD_VAR 0 2
44492: ARRAY
44493: PPUSH
44494: CALL_OW 308
44498: NOT
44499: IFFALSE 44521
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44501: LD_VAR 0 3
44505: PPUSH
44506: LD_EXP 140
44510: PUSH
44511: LD_VAR 0 2
44515: ARRAY
44516: PPUSH
44517: CALL_OW 113
44521: GO 44475
44523: POP
44524: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
44525: LD_ADDR_EXP 118
44529: PUSH
44530: LD_EXP 118
44534: PPUSH
44535: LD_VAR 0 2
44539: PPUSH
44540: EMPTY
44541: PPUSH
44542: CALL_OW 1
44546: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
44547: LD_VAR 0 2
44551: PPUSH
44552: LD_INT 101
44554: PPUSH
44555: CALL 39413 0 2
// continue ;
44559: GO 44360
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
44561: LD_ADDR_EXP 122
44565: PUSH
44566: LD_EXP 122
44570: PPUSH
44571: LD_VAR 0 2
44575: PPUSH
44576: EMPTY
44577: PPUSH
44578: CALL_OW 1
44582: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44583: LD_VAR 0 2
44587: PPUSH
44588: LD_INT 103
44590: PPUSH
44591: CALL 39413 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
44595: LD_ADDR_VAR 0 5
44599: PUSH
44600: LD_EXP 116
44604: PUSH
44605: LD_VAR 0 2
44609: ARRAY
44610: PUSH
44611: LD_EXP 145
44615: PUSH
44616: LD_VAR 0 2
44620: ARRAY
44621: UNION
44622: PPUSH
44623: LD_INT 2
44625: PUSH
44626: LD_INT 25
44628: PUSH
44629: LD_INT 2
44631: PUSH
44632: EMPTY
44633: LIST
44634: LIST
44635: PUSH
44636: LD_INT 25
44638: PUSH
44639: LD_INT 16
44641: PUSH
44642: EMPTY
44643: LIST
44644: LIST
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: LIST
44650: PUSH
44651: EMPTY
44652: LIST
44653: PPUSH
44654: CALL_OW 72
44658: ST_TO_ADDR
// if mc_need_heal [ i ] then
44659: LD_EXP 119
44663: PUSH
44664: LD_VAR 0 2
44668: ARRAY
44669: IFFALSE 44713
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
44671: LD_ADDR_VAR 0 5
44675: PUSH
44676: LD_VAR 0 5
44680: PUSH
44681: LD_EXP 119
44685: PUSH
44686: LD_VAR 0 2
44690: ARRAY
44691: PUSH
44692: LD_INT 1
44694: ARRAY
44695: PUSH
44696: LD_EXP 119
44700: PUSH
44701: LD_VAR 0 2
44705: ARRAY
44706: PUSH
44707: LD_INT 2
44709: ARRAY
44710: UNION
44711: DIFF
44712: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
44713: LD_ADDR_VAR 0 6
44717: PUSH
44718: LD_EXP 135
44722: PUSH
44723: LD_VAR 0 2
44727: ARRAY
44728: PPUSH
44729: LD_INT 2
44731: PUSH
44732: LD_INT 34
44734: PUSH
44735: LD_INT 13
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 34
44744: PUSH
44745: LD_INT 52
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PUSH
44752: LD_INT 34
44754: PUSH
44755: LD_EXP 101
44759: PUSH
44760: EMPTY
44761: LIST
44762: LIST
44763: PUSH
44764: EMPTY
44765: LIST
44766: LIST
44767: LIST
44768: LIST
44769: PPUSH
44770: CALL_OW 72
44774: ST_TO_ADDR
// if cranes then
44775: LD_VAR 0 6
44779: IFFALSE 44915
// begin for j in cranes do
44781: LD_ADDR_VAR 0 3
44785: PUSH
44786: LD_VAR 0 6
44790: PUSH
44791: FOR_IN
44792: IFFALSE 44913
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
44794: LD_VAR 0 3
44798: PPUSH
44799: CALL_OW 256
44803: PUSH
44804: LD_INT 1000
44806: EQUAL
44807: PUSH
44808: LD_VAR 0 3
44812: PPUSH
44813: CALL_OW 314
44817: NOT
44818: AND
44819: IFFALSE 44853
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
44821: LD_VAR 0 3
44825: PPUSH
44826: LD_EXP 117
44830: PUSH
44831: LD_VAR 0 2
44835: ARRAY
44836: PPUSH
44837: LD_VAR 0 3
44841: PPUSH
44842: CALL_OW 74
44846: PPUSH
44847: CALL_OW 130
44851: GO 44911
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
44853: LD_VAR 0 3
44857: PPUSH
44858: CALL_OW 256
44862: PUSH
44863: LD_INT 500
44865: LESS
44866: PUSH
44867: LD_VAR 0 3
44871: PPUSH
44872: LD_EXP 140
44876: PUSH
44877: LD_VAR 0 2
44881: ARRAY
44882: PPUSH
44883: CALL_OW 308
44887: NOT
44888: AND
44889: IFFALSE 44911
// ComMoveToArea ( j , mc_parking [ i ] ) ;
44891: LD_VAR 0 3
44895: PPUSH
44896: LD_EXP 140
44900: PUSH
44901: LD_VAR 0 2
44905: ARRAY
44906: PPUSH
44907: CALL_OW 113
// end ;
44911: GO 44791
44913: POP
44914: POP
// end ; if tmp > 3 then
44915: LD_VAR 0 5
44919: PUSH
44920: LD_INT 3
44922: GREATER
44923: IFFALSE 44943
// tmp := ShrinkArray ( tmp , 4 ) ;
44925: LD_ADDR_VAR 0 5
44929: PUSH
44930: LD_VAR 0 5
44934: PPUSH
44935: LD_INT 4
44937: PPUSH
44938: CALL 102937 0 2
44942: ST_TO_ADDR
// if not tmp then
44943: LD_VAR 0 5
44947: NOT
44948: IFFALSE 44952
// continue ;
44950: GO 44360
// for j in tmp do
44952: LD_ADDR_VAR 0 3
44956: PUSH
44957: LD_VAR 0 5
44961: PUSH
44962: FOR_IN
44963: IFFALSE 45222
// begin if IsInUnit ( j ) then
44965: LD_VAR 0 3
44969: PPUSH
44970: CALL_OW 310
44974: IFFALSE 44985
// ComExitBuilding ( j ) ;
44976: LD_VAR 0 3
44980: PPUSH
44981: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
44985: LD_VAR 0 3
44989: PUSH
44990: LD_EXP 118
44994: PUSH
44995: LD_VAR 0 2
44999: ARRAY
45000: IN
45001: NOT
45002: IFFALSE 45060
// begin SetTag ( j , 101 ) ;
45004: LD_VAR 0 3
45008: PPUSH
45009: LD_INT 101
45011: PPUSH
45012: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
45016: LD_ADDR_EXP 118
45020: PUSH
45021: LD_EXP 118
45025: PPUSH
45026: LD_VAR 0 2
45030: PUSH
45031: LD_EXP 118
45035: PUSH
45036: LD_VAR 0 2
45040: ARRAY
45041: PUSH
45042: LD_INT 1
45044: PLUS
45045: PUSH
45046: EMPTY
45047: LIST
45048: LIST
45049: PPUSH
45050: LD_VAR 0 3
45054: PPUSH
45055: CALL 70871 0 3
45059: ST_TO_ADDR
// end ; wait ( 1 ) ;
45060: LD_INT 1
45062: PPUSH
45063: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
45067: LD_ADDR_VAR 0 7
45071: PUSH
45072: LD_EXP 117
45076: PUSH
45077: LD_VAR 0 2
45081: ARRAY
45082: ST_TO_ADDR
// if mc_scan [ i ] then
45083: LD_EXP 139
45087: PUSH
45088: LD_VAR 0 2
45092: ARRAY
45093: IFFALSE 45155
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
45095: LD_ADDR_VAR 0 7
45099: PUSH
45100: LD_EXP 117
45104: PUSH
45105: LD_VAR 0 2
45109: ARRAY
45110: PPUSH
45111: LD_INT 3
45113: PUSH
45114: LD_INT 30
45116: PUSH
45117: LD_INT 32
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: PUSH
45124: LD_INT 30
45126: PUSH
45127: LD_INT 33
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 30
45136: PUSH
45137: LD_INT 31
45139: PUSH
45140: EMPTY
45141: LIST
45142: LIST
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: PPUSH
45150: CALL_OW 72
45154: ST_TO_ADDR
// if not to_repair_tmp then
45155: LD_VAR 0 7
45159: NOT
45160: IFFALSE 45164
// continue ;
45162: GO 44962
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
45164: LD_ADDR_VAR 0 8
45168: PUSH
45169: LD_VAR 0 7
45173: PPUSH
45174: LD_VAR 0 3
45178: PPUSH
45179: CALL_OW 74
45183: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
45184: LD_VAR 0 8
45188: PPUSH
45189: LD_INT 16
45191: PPUSH
45192: CALL 73470 0 2
45196: PUSH
45197: LD_INT 4
45199: ARRAY
45200: PUSH
45201: LD_INT 10
45203: LESS
45204: IFFALSE 45220
// ComRepairBuilding ( j , to_repair ) ;
45206: LD_VAR 0 3
45210: PPUSH
45211: LD_VAR 0 8
45215: PPUSH
45216: CALL_OW 130
// end ;
45220: GO 44962
45222: POP
45223: POP
// end ;
45224: GO 44360
45226: POP
45227: POP
// end ;
45228: LD_VAR 0 1
45232: RET
// export function MC_Heal ; var i , j , tmp ; begin
45233: LD_INT 0
45235: PPUSH
45236: PPUSH
45237: PPUSH
45238: PPUSH
// if not mc_bases then
45239: LD_EXP 116
45243: NOT
45244: IFFALSE 45248
// exit ;
45246: GO 45650
// for i = 1 to mc_bases do
45248: LD_ADDR_VAR 0 2
45252: PUSH
45253: DOUBLE
45254: LD_INT 1
45256: DEC
45257: ST_TO_ADDR
45258: LD_EXP 116
45262: PUSH
45263: FOR_TO
45264: IFFALSE 45648
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
45266: LD_EXP 119
45270: PUSH
45271: LD_VAR 0 2
45275: ARRAY
45276: PUSH
45277: LD_INT 1
45279: ARRAY
45280: NOT
45281: PUSH
45282: LD_EXP 119
45286: PUSH
45287: LD_VAR 0 2
45291: ARRAY
45292: PUSH
45293: LD_INT 2
45295: ARRAY
45296: NOT
45297: AND
45298: IFFALSE 45336
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
45300: LD_ADDR_EXP 120
45304: PUSH
45305: LD_EXP 120
45309: PPUSH
45310: LD_VAR 0 2
45314: PPUSH
45315: EMPTY
45316: PPUSH
45317: CALL_OW 1
45321: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
45322: LD_VAR 0 2
45326: PPUSH
45327: LD_INT 102
45329: PPUSH
45330: CALL 39413 0 2
// continue ;
45334: GO 45263
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
45336: LD_ADDR_VAR 0 4
45340: PUSH
45341: LD_EXP 116
45345: PUSH
45346: LD_VAR 0 2
45350: ARRAY
45351: PPUSH
45352: LD_INT 25
45354: PUSH
45355: LD_INT 4
45357: PUSH
45358: EMPTY
45359: LIST
45360: LIST
45361: PPUSH
45362: CALL_OW 72
45366: ST_TO_ADDR
// if not tmp then
45367: LD_VAR 0 4
45371: NOT
45372: IFFALSE 45376
// continue ;
45374: GO 45263
// if mc_taming [ i ] then
45376: LD_EXP 147
45380: PUSH
45381: LD_VAR 0 2
45385: ARRAY
45386: IFFALSE 45410
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
45388: LD_ADDR_EXP 147
45392: PUSH
45393: LD_EXP 147
45397: PPUSH
45398: LD_VAR 0 2
45402: PPUSH
45403: EMPTY
45404: PPUSH
45405: CALL_OW 1
45409: ST_TO_ADDR
// for j in tmp do
45410: LD_ADDR_VAR 0 3
45414: PUSH
45415: LD_VAR 0 4
45419: PUSH
45420: FOR_IN
45421: IFFALSE 45644
// begin if IsInUnit ( j ) then
45423: LD_VAR 0 3
45427: PPUSH
45428: CALL_OW 310
45432: IFFALSE 45443
// ComExitBuilding ( j ) ;
45434: LD_VAR 0 3
45438: PPUSH
45439: CALL_OW 122
// if not j in mc_healers [ i ] then
45443: LD_VAR 0 3
45447: PUSH
45448: LD_EXP 120
45452: PUSH
45453: LD_VAR 0 2
45457: ARRAY
45458: IN
45459: NOT
45460: IFFALSE 45506
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
45462: LD_ADDR_EXP 120
45466: PUSH
45467: LD_EXP 120
45471: PPUSH
45472: LD_VAR 0 2
45476: PUSH
45477: LD_EXP 120
45481: PUSH
45482: LD_VAR 0 2
45486: ARRAY
45487: PUSH
45488: LD_INT 1
45490: PLUS
45491: PUSH
45492: EMPTY
45493: LIST
45494: LIST
45495: PPUSH
45496: LD_VAR 0 3
45500: PPUSH
45501: CALL 70871 0 3
45505: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
45506: LD_VAR 0 3
45510: PPUSH
45511: CALL_OW 110
45515: PUSH
45516: LD_INT 102
45518: NONEQUAL
45519: IFFALSE 45533
// SetTag ( j , 102 ) ;
45521: LD_VAR 0 3
45525: PPUSH
45526: LD_INT 102
45528: PPUSH
45529: CALL_OW 109
// Wait ( 3 ) ;
45533: LD_INT 3
45535: PPUSH
45536: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
45540: LD_EXP 119
45544: PUSH
45545: LD_VAR 0 2
45549: ARRAY
45550: PUSH
45551: LD_INT 1
45553: ARRAY
45554: IFFALSE 45586
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
45556: LD_VAR 0 3
45560: PPUSH
45561: LD_EXP 119
45565: PUSH
45566: LD_VAR 0 2
45570: ARRAY
45571: PUSH
45572: LD_INT 1
45574: ARRAY
45575: PUSH
45576: LD_INT 1
45578: ARRAY
45579: PPUSH
45580: CALL_OW 128
45584: GO 45642
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
45586: LD_VAR 0 3
45590: PPUSH
45591: CALL_OW 314
45595: NOT
45596: PUSH
45597: LD_EXP 119
45601: PUSH
45602: LD_VAR 0 2
45606: ARRAY
45607: PUSH
45608: LD_INT 2
45610: ARRAY
45611: AND
45612: IFFALSE 45642
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
45614: LD_VAR 0 3
45618: PPUSH
45619: LD_EXP 119
45623: PUSH
45624: LD_VAR 0 2
45628: ARRAY
45629: PUSH
45630: LD_INT 2
45632: ARRAY
45633: PUSH
45634: LD_INT 1
45636: ARRAY
45637: PPUSH
45638: CALL_OW 128
// end ;
45642: GO 45420
45644: POP
45645: POP
// end ;
45646: GO 45263
45648: POP
45649: POP
// end ;
45650: LD_VAR 0 1
45654: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
45655: LD_INT 0
45657: PPUSH
45658: PPUSH
45659: PPUSH
45660: PPUSH
45661: PPUSH
// if not mc_bases then
45662: LD_EXP 116
45666: NOT
45667: IFFALSE 45671
// exit ;
45669: GO 46842
// for i = 1 to mc_bases do
45671: LD_ADDR_VAR 0 2
45675: PUSH
45676: DOUBLE
45677: LD_INT 1
45679: DEC
45680: ST_TO_ADDR
45681: LD_EXP 116
45685: PUSH
45686: FOR_TO
45687: IFFALSE 46840
// begin if mc_scan [ i ] then
45689: LD_EXP 139
45693: PUSH
45694: LD_VAR 0 2
45698: ARRAY
45699: IFFALSE 45703
// continue ;
45701: GO 45686
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
45703: LD_EXP 121
45707: PUSH
45708: LD_VAR 0 2
45712: ARRAY
45713: NOT
45714: PUSH
45715: LD_EXP 123
45719: PUSH
45720: LD_VAR 0 2
45724: ARRAY
45725: NOT
45726: AND
45727: PUSH
45728: LD_EXP 122
45732: PUSH
45733: LD_VAR 0 2
45737: ARRAY
45738: AND
45739: IFFALSE 45777
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
45741: LD_ADDR_EXP 122
45745: PUSH
45746: LD_EXP 122
45750: PPUSH
45751: LD_VAR 0 2
45755: PPUSH
45756: EMPTY
45757: PPUSH
45758: CALL_OW 1
45762: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
45763: LD_VAR 0 2
45767: PPUSH
45768: LD_INT 103
45770: PPUSH
45771: CALL 39413 0 2
// continue ;
45775: GO 45686
// end ; if mc_construct_list [ i ] then
45777: LD_EXP 123
45781: PUSH
45782: LD_VAR 0 2
45786: ARRAY
45787: IFFALSE 46007
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
45789: LD_ADDR_VAR 0 4
45793: PUSH
45794: LD_EXP 116
45798: PUSH
45799: LD_VAR 0 2
45803: ARRAY
45804: PPUSH
45805: LD_INT 25
45807: PUSH
45808: LD_INT 2
45810: PUSH
45811: EMPTY
45812: LIST
45813: LIST
45814: PPUSH
45815: CALL_OW 72
45819: PUSH
45820: LD_EXP 118
45824: PUSH
45825: LD_VAR 0 2
45829: ARRAY
45830: DIFF
45831: ST_TO_ADDR
// if not tmp then
45832: LD_VAR 0 4
45836: NOT
45837: IFFALSE 45841
// continue ;
45839: GO 45686
// for j in tmp do
45841: LD_ADDR_VAR 0 3
45845: PUSH
45846: LD_VAR 0 4
45850: PUSH
45851: FOR_IN
45852: IFFALSE 46003
// begin if not mc_builders [ i ] then
45854: LD_EXP 122
45858: PUSH
45859: LD_VAR 0 2
45863: ARRAY
45864: NOT
45865: IFFALSE 45923
// begin SetTag ( j , 103 ) ;
45867: LD_VAR 0 3
45871: PPUSH
45872: LD_INT 103
45874: PPUSH
45875: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
45879: LD_ADDR_EXP 122
45883: PUSH
45884: LD_EXP 122
45888: PPUSH
45889: LD_VAR 0 2
45893: PUSH
45894: LD_EXP 122
45898: PUSH
45899: LD_VAR 0 2
45903: ARRAY
45904: PUSH
45905: LD_INT 1
45907: PLUS
45908: PUSH
45909: EMPTY
45910: LIST
45911: LIST
45912: PPUSH
45913: LD_VAR 0 3
45917: PPUSH
45918: CALL 70871 0 3
45922: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
45923: LD_VAR 0 3
45927: PPUSH
45928: CALL_OW 310
45932: IFFALSE 45943
// ComExitBuilding ( j ) ;
45934: LD_VAR 0 3
45938: PPUSH
45939: CALL_OW 122
// wait ( 3 ) ;
45943: LD_INT 3
45945: PPUSH
45946: CALL_OW 67
// if not mc_construct_list [ i ] then
45950: LD_EXP 123
45954: PUSH
45955: LD_VAR 0 2
45959: ARRAY
45960: NOT
45961: IFFALSE 45965
// break ;
45963: GO 46003
// if not HasTask ( j ) then
45965: LD_VAR 0 3
45969: PPUSH
45970: CALL_OW 314
45974: NOT
45975: IFFALSE 46001
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
45977: LD_VAR 0 3
45981: PPUSH
45982: LD_EXP 123
45986: PUSH
45987: LD_VAR 0 2
45991: ARRAY
45992: PUSH
45993: LD_INT 1
45995: ARRAY
45996: PPUSH
45997: CALL 73734 0 2
// end ;
46001: GO 45851
46003: POP
46004: POP
// end else
46005: GO 46838
// if mc_build_list [ i ] then
46007: LD_EXP 121
46011: PUSH
46012: LD_VAR 0 2
46016: ARRAY
46017: IFFALSE 46838
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
46019: LD_ADDR_VAR 0 5
46023: PUSH
46024: LD_EXP 116
46028: PUSH
46029: LD_VAR 0 2
46033: ARRAY
46034: PPUSH
46035: LD_INT 2
46037: PUSH
46038: LD_INT 30
46040: PUSH
46041: LD_INT 0
46043: PUSH
46044: EMPTY
46045: LIST
46046: LIST
46047: PUSH
46048: LD_INT 30
46050: PUSH
46051: LD_INT 1
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: LIST
46062: PPUSH
46063: CALL_OW 72
46067: ST_TO_ADDR
// if depot then
46068: LD_VAR 0 5
46072: IFFALSE 46090
// depot := depot [ 1 ] else
46074: LD_ADDR_VAR 0 5
46078: PUSH
46079: LD_VAR 0 5
46083: PUSH
46084: LD_INT 1
46086: ARRAY
46087: ST_TO_ADDR
46088: GO 46098
// depot := 0 ;
46090: LD_ADDR_VAR 0 5
46094: PUSH
46095: LD_INT 0
46097: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
46098: LD_EXP 121
46102: PUSH
46103: LD_VAR 0 2
46107: ARRAY
46108: PUSH
46109: LD_INT 1
46111: ARRAY
46112: PUSH
46113: LD_INT 1
46115: ARRAY
46116: PPUSH
46117: CALL 73558 0 1
46121: PUSH
46122: LD_EXP 116
46126: PUSH
46127: LD_VAR 0 2
46131: ARRAY
46132: PPUSH
46133: LD_INT 2
46135: PUSH
46136: LD_INT 30
46138: PUSH
46139: LD_INT 2
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 30
46148: PUSH
46149: LD_INT 3
46151: PUSH
46152: EMPTY
46153: LIST
46154: LIST
46155: PUSH
46156: EMPTY
46157: LIST
46158: LIST
46159: LIST
46160: PPUSH
46161: CALL_OW 72
46165: NOT
46166: AND
46167: IFFALSE 46272
// begin for j = 1 to mc_build_list [ i ] do
46169: LD_ADDR_VAR 0 3
46173: PUSH
46174: DOUBLE
46175: LD_INT 1
46177: DEC
46178: ST_TO_ADDR
46179: LD_EXP 121
46183: PUSH
46184: LD_VAR 0 2
46188: ARRAY
46189: PUSH
46190: FOR_TO
46191: IFFALSE 46270
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
46193: LD_EXP 121
46197: PUSH
46198: LD_VAR 0 2
46202: ARRAY
46203: PUSH
46204: LD_VAR 0 3
46208: ARRAY
46209: PUSH
46210: LD_INT 1
46212: ARRAY
46213: PUSH
46214: LD_INT 2
46216: EQUAL
46217: IFFALSE 46268
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
46219: LD_ADDR_EXP 121
46223: PUSH
46224: LD_EXP 121
46228: PPUSH
46229: LD_VAR 0 2
46233: PPUSH
46234: LD_EXP 121
46238: PUSH
46239: LD_VAR 0 2
46243: ARRAY
46244: PPUSH
46245: LD_VAR 0 3
46249: PPUSH
46250: LD_INT 1
46252: PPUSH
46253: LD_INT 0
46255: PPUSH
46256: CALL 70289 0 4
46260: PPUSH
46261: CALL_OW 1
46265: ST_TO_ADDR
// break ;
46266: GO 46270
// end ;
46268: GO 46190
46270: POP
46271: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
46272: LD_EXP 121
46276: PUSH
46277: LD_VAR 0 2
46281: ARRAY
46282: PUSH
46283: LD_INT 1
46285: ARRAY
46286: PUSH
46287: LD_INT 1
46289: ARRAY
46290: PUSH
46291: LD_INT 0
46293: EQUAL
46294: PUSH
46295: LD_VAR 0 5
46299: PUSH
46300: LD_VAR 0 5
46304: PPUSH
46305: LD_EXP 121
46309: PUSH
46310: LD_VAR 0 2
46314: ARRAY
46315: PUSH
46316: LD_INT 1
46318: ARRAY
46319: PUSH
46320: LD_INT 1
46322: ARRAY
46323: PPUSH
46324: LD_EXP 121
46328: PUSH
46329: LD_VAR 0 2
46333: ARRAY
46334: PUSH
46335: LD_INT 1
46337: ARRAY
46338: PUSH
46339: LD_INT 2
46341: ARRAY
46342: PPUSH
46343: LD_EXP 121
46347: PUSH
46348: LD_VAR 0 2
46352: ARRAY
46353: PUSH
46354: LD_INT 1
46356: ARRAY
46357: PUSH
46358: LD_INT 3
46360: ARRAY
46361: PPUSH
46362: LD_EXP 121
46366: PUSH
46367: LD_VAR 0 2
46371: ARRAY
46372: PUSH
46373: LD_INT 1
46375: ARRAY
46376: PUSH
46377: LD_INT 4
46379: ARRAY
46380: PPUSH
46381: CALL 78974 0 5
46385: AND
46386: OR
46387: IFFALSE 46668
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
46389: LD_ADDR_VAR 0 4
46393: PUSH
46394: LD_EXP 116
46398: PUSH
46399: LD_VAR 0 2
46403: ARRAY
46404: PPUSH
46405: LD_INT 25
46407: PUSH
46408: LD_INT 2
46410: PUSH
46411: EMPTY
46412: LIST
46413: LIST
46414: PPUSH
46415: CALL_OW 72
46419: PUSH
46420: LD_EXP 118
46424: PUSH
46425: LD_VAR 0 2
46429: ARRAY
46430: DIFF
46431: ST_TO_ADDR
// if not tmp then
46432: LD_VAR 0 4
46436: NOT
46437: IFFALSE 46441
// continue ;
46439: GO 45686
// for j in tmp do
46441: LD_ADDR_VAR 0 3
46445: PUSH
46446: LD_VAR 0 4
46450: PUSH
46451: FOR_IN
46452: IFFALSE 46664
// begin if not mc_builders [ i ] then
46454: LD_EXP 122
46458: PUSH
46459: LD_VAR 0 2
46463: ARRAY
46464: NOT
46465: IFFALSE 46523
// begin SetTag ( j , 103 ) ;
46467: LD_VAR 0 3
46471: PPUSH
46472: LD_INT 103
46474: PPUSH
46475: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
46479: LD_ADDR_EXP 122
46483: PUSH
46484: LD_EXP 122
46488: PPUSH
46489: LD_VAR 0 2
46493: PUSH
46494: LD_EXP 122
46498: PUSH
46499: LD_VAR 0 2
46503: ARRAY
46504: PUSH
46505: LD_INT 1
46507: PLUS
46508: PUSH
46509: EMPTY
46510: LIST
46511: LIST
46512: PPUSH
46513: LD_VAR 0 3
46517: PPUSH
46518: CALL 70871 0 3
46522: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
46523: LD_VAR 0 3
46527: PPUSH
46528: CALL_OW 310
46532: IFFALSE 46543
// ComExitBuilding ( j ) ;
46534: LD_VAR 0 3
46538: PPUSH
46539: CALL_OW 122
// wait ( 3 ) ;
46543: LD_INT 3
46545: PPUSH
46546: CALL_OW 67
// if not mc_build_list [ i ] then
46550: LD_EXP 121
46554: PUSH
46555: LD_VAR 0 2
46559: ARRAY
46560: NOT
46561: IFFALSE 46565
// break ;
46563: GO 46664
// if not HasTask ( j ) then
46565: LD_VAR 0 3
46569: PPUSH
46570: CALL_OW 314
46574: NOT
46575: IFFALSE 46662
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
46577: LD_VAR 0 3
46581: PPUSH
46582: LD_EXP 121
46586: PUSH
46587: LD_VAR 0 2
46591: ARRAY
46592: PUSH
46593: LD_INT 1
46595: ARRAY
46596: PUSH
46597: LD_INT 1
46599: ARRAY
46600: PPUSH
46601: LD_EXP 121
46605: PUSH
46606: LD_VAR 0 2
46610: ARRAY
46611: PUSH
46612: LD_INT 1
46614: ARRAY
46615: PUSH
46616: LD_INT 2
46618: ARRAY
46619: PPUSH
46620: LD_EXP 121
46624: PUSH
46625: LD_VAR 0 2
46629: ARRAY
46630: PUSH
46631: LD_INT 1
46633: ARRAY
46634: PUSH
46635: LD_INT 3
46637: ARRAY
46638: PPUSH
46639: LD_EXP 121
46643: PUSH
46644: LD_VAR 0 2
46648: ARRAY
46649: PUSH
46650: LD_INT 1
46652: ARRAY
46653: PUSH
46654: LD_INT 4
46656: ARRAY
46657: PPUSH
46658: CALL_OW 145
// end ;
46662: GO 46451
46664: POP
46665: POP
// end else
46666: GO 46838
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
46668: LD_EXP 116
46672: PUSH
46673: LD_VAR 0 2
46677: ARRAY
46678: PPUSH
46679: LD_EXP 121
46683: PUSH
46684: LD_VAR 0 2
46688: ARRAY
46689: PUSH
46690: LD_INT 1
46692: ARRAY
46693: PUSH
46694: LD_INT 1
46696: ARRAY
46697: PPUSH
46698: LD_EXP 121
46702: PUSH
46703: LD_VAR 0 2
46707: ARRAY
46708: PUSH
46709: LD_INT 1
46711: ARRAY
46712: PUSH
46713: LD_INT 2
46715: ARRAY
46716: PPUSH
46717: LD_EXP 121
46721: PUSH
46722: LD_VAR 0 2
46726: ARRAY
46727: PUSH
46728: LD_INT 1
46730: ARRAY
46731: PUSH
46732: LD_INT 3
46734: ARRAY
46735: PPUSH
46736: LD_EXP 121
46740: PUSH
46741: LD_VAR 0 2
46745: ARRAY
46746: PUSH
46747: LD_INT 1
46749: ARRAY
46750: PUSH
46751: LD_INT 4
46753: ARRAY
46754: PPUSH
46755: LD_EXP 116
46759: PUSH
46760: LD_VAR 0 2
46764: ARRAY
46765: PPUSH
46766: LD_INT 21
46768: PUSH
46769: LD_INT 3
46771: PUSH
46772: EMPTY
46773: LIST
46774: LIST
46775: PPUSH
46776: CALL_OW 72
46780: PPUSH
46781: EMPTY
46782: PPUSH
46783: CALL 77724 0 7
46787: NOT
46788: IFFALSE 46838
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
46790: LD_ADDR_EXP 121
46794: PUSH
46795: LD_EXP 121
46799: PPUSH
46800: LD_VAR 0 2
46804: PPUSH
46805: LD_EXP 121
46809: PUSH
46810: LD_VAR 0 2
46814: ARRAY
46815: PPUSH
46816: LD_INT 1
46818: PPUSH
46819: LD_INT 1
46821: NEG
46822: PPUSH
46823: LD_INT 0
46825: PPUSH
46826: CALL 70289 0 4
46830: PPUSH
46831: CALL_OW 1
46835: ST_TO_ADDR
// continue ;
46836: GO 45686
// end ; end ; end ;
46838: GO 45686
46840: POP
46841: POP
// end ;
46842: LD_VAR 0 1
46846: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
46847: LD_INT 0
46849: PPUSH
46850: PPUSH
46851: PPUSH
46852: PPUSH
46853: PPUSH
46854: PPUSH
// if not mc_bases then
46855: LD_EXP 116
46859: NOT
46860: IFFALSE 46864
// exit ;
46862: GO 47291
// for i = 1 to mc_bases do
46864: LD_ADDR_VAR 0 2
46868: PUSH
46869: DOUBLE
46870: LD_INT 1
46872: DEC
46873: ST_TO_ADDR
46874: LD_EXP 116
46878: PUSH
46879: FOR_TO
46880: IFFALSE 47289
// begin tmp := mc_build_upgrade [ i ] ;
46882: LD_ADDR_VAR 0 4
46886: PUSH
46887: LD_EXP 148
46891: PUSH
46892: LD_VAR 0 2
46896: ARRAY
46897: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
46898: LD_ADDR_VAR 0 6
46902: PUSH
46903: LD_EXP 149
46907: PUSH
46908: LD_VAR 0 2
46912: ARRAY
46913: PPUSH
46914: LD_INT 2
46916: PUSH
46917: LD_INT 30
46919: PUSH
46920: LD_INT 6
46922: PUSH
46923: EMPTY
46924: LIST
46925: LIST
46926: PUSH
46927: LD_INT 30
46929: PUSH
46930: LD_INT 7
46932: PUSH
46933: EMPTY
46934: LIST
46935: LIST
46936: PUSH
46937: EMPTY
46938: LIST
46939: LIST
46940: LIST
46941: PPUSH
46942: CALL_OW 72
46946: ST_TO_ADDR
// if not tmp and not lab then
46947: LD_VAR 0 4
46951: NOT
46952: PUSH
46953: LD_VAR 0 6
46957: NOT
46958: AND
46959: IFFALSE 46963
// continue ;
46961: GO 46879
// if tmp then
46963: LD_VAR 0 4
46967: IFFALSE 47087
// for j in tmp do
46969: LD_ADDR_VAR 0 3
46973: PUSH
46974: LD_VAR 0 4
46978: PUSH
46979: FOR_IN
46980: IFFALSE 47085
// begin if UpgradeCost ( j ) then
46982: LD_VAR 0 3
46986: PPUSH
46987: CALL 77384 0 1
46991: IFFALSE 47083
// begin ComUpgrade ( j ) ;
46993: LD_VAR 0 3
46997: PPUSH
46998: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
47002: LD_ADDR_EXP 148
47006: PUSH
47007: LD_EXP 148
47011: PPUSH
47012: LD_VAR 0 2
47016: PPUSH
47017: LD_EXP 148
47021: PUSH
47022: LD_VAR 0 2
47026: ARRAY
47027: PUSH
47028: LD_VAR 0 3
47032: DIFF
47033: PPUSH
47034: CALL_OW 1
47038: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47039: LD_ADDR_EXP 123
47043: PUSH
47044: LD_EXP 123
47048: PPUSH
47049: LD_VAR 0 2
47053: PUSH
47054: LD_EXP 123
47058: PUSH
47059: LD_VAR 0 2
47063: ARRAY
47064: PUSH
47065: LD_INT 1
47067: PLUS
47068: PUSH
47069: EMPTY
47070: LIST
47071: LIST
47072: PPUSH
47073: LD_VAR 0 3
47077: PPUSH
47078: CALL 70871 0 3
47082: ST_TO_ADDR
// end ; end ;
47083: GO 46979
47085: POP
47086: POP
// if not lab or not mc_lab_upgrade [ i ] then
47087: LD_VAR 0 6
47091: NOT
47092: PUSH
47093: LD_EXP 150
47097: PUSH
47098: LD_VAR 0 2
47102: ARRAY
47103: NOT
47104: OR
47105: IFFALSE 47109
// continue ;
47107: GO 46879
// for j in lab do
47109: LD_ADDR_VAR 0 3
47113: PUSH
47114: LD_VAR 0 6
47118: PUSH
47119: FOR_IN
47120: IFFALSE 47285
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
47122: LD_VAR 0 3
47126: PPUSH
47127: CALL_OW 266
47131: PUSH
47132: LD_INT 6
47134: PUSH
47135: LD_INT 7
47137: PUSH
47138: EMPTY
47139: LIST
47140: LIST
47141: IN
47142: PUSH
47143: LD_VAR 0 3
47147: PPUSH
47148: CALL_OW 461
47152: PUSH
47153: LD_INT 1
47155: NONEQUAL
47156: AND
47157: IFFALSE 47283
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
47159: LD_VAR 0 3
47163: PPUSH
47164: LD_EXP 150
47168: PUSH
47169: LD_VAR 0 2
47173: ARRAY
47174: PUSH
47175: LD_INT 1
47177: ARRAY
47178: PPUSH
47179: CALL 77589 0 2
47183: IFFALSE 47283
// begin ComCancel ( j ) ;
47185: LD_VAR 0 3
47189: PPUSH
47190: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
47194: LD_VAR 0 3
47198: PPUSH
47199: LD_EXP 150
47203: PUSH
47204: LD_VAR 0 2
47208: ARRAY
47209: PUSH
47210: LD_INT 1
47212: ARRAY
47213: PPUSH
47214: CALL_OW 207
// if not j in mc_construct_list [ i ] then
47218: LD_VAR 0 3
47222: PUSH
47223: LD_EXP 123
47227: PUSH
47228: LD_VAR 0 2
47232: ARRAY
47233: IN
47234: NOT
47235: IFFALSE 47281
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
47237: LD_ADDR_EXP 123
47241: PUSH
47242: LD_EXP 123
47246: PPUSH
47247: LD_VAR 0 2
47251: PUSH
47252: LD_EXP 123
47256: PUSH
47257: LD_VAR 0 2
47261: ARRAY
47262: PUSH
47263: LD_INT 1
47265: PLUS
47266: PUSH
47267: EMPTY
47268: LIST
47269: LIST
47270: PPUSH
47271: LD_VAR 0 3
47275: PPUSH
47276: CALL 70871 0 3
47280: ST_TO_ADDR
// break ;
47281: GO 47285
// end ; end ; end ;
47283: GO 47119
47285: POP
47286: POP
// end ;
47287: GO 46879
47289: POP
47290: POP
// end ;
47291: LD_VAR 0 1
47295: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
47296: LD_INT 0
47298: PPUSH
47299: PPUSH
47300: PPUSH
47301: PPUSH
47302: PPUSH
47303: PPUSH
47304: PPUSH
47305: PPUSH
47306: PPUSH
// if not mc_bases then
47307: LD_EXP 116
47311: NOT
47312: IFFALSE 47316
// exit ;
47314: GO 47721
// for i = 1 to mc_bases do
47316: LD_ADDR_VAR 0 2
47320: PUSH
47321: DOUBLE
47322: LD_INT 1
47324: DEC
47325: ST_TO_ADDR
47326: LD_EXP 116
47330: PUSH
47331: FOR_TO
47332: IFFALSE 47719
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
47334: LD_EXP 124
47338: PUSH
47339: LD_VAR 0 2
47343: ARRAY
47344: NOT
47345: PUSH
47346: LD_EXP 116
47350: PUSH
47351: LD_VAR 0 2
47355: ARRAY
47356: PPUSH
47357: LD_INT 30
47359: PUSH
47360: LD_INT 3
47362: PUSH
47363: EMPTY
47364: LIST
47365: LIST
47366: PPUSH
47367: CALL_OW 72
47371: NOT
47372: OR
47373: IFFALSE 47377
// continue ;
47375: GO 47331
// busy := false ;
47377: LD_ADDR_VAR 0 8
47381: PUSH
47382: LD_INT 0
47384: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
47385: LD_ADDR_VAR 0 4
47389: PUSH
47390: LD_EXP 116
47394: PUSH
47395: LD_VAR 0 2
47399: ARRAY
47400: PPUSH
47401: LD_INT 30
47403: PUSH
47404: LD_INT 3
47406: PUSH
47407: EMPTY
47408: LIST
47409: LIST
47410: PPUSH
47411: CALL_OW 72
47415: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
47416: LD_ADDR_VAR 0 6
47420: PUSH
47421: LD_EXP 124
47425: PUSH
47426: LD_VAR 0 2
47430: ARRAY
47431: PPUSH
47432: LD_INT 2
47434: PUSH
47435: LD_INT 30
47437: PUSH
47438: LD_INT 32
47440: PUSH
47441: EMPTY
47442: LIST
47443: LIST
47444: PUSH
47445: LD_INT 30
47447: PUSH
47448: LD_INT 33
47450: PUSH
47451: EMPTY
47452: LIST
47453: LIST
47454: PUSH
47455: EMPTY
47456: LIST
47457: LIST
47458: LIST
47459: PPUSH
47460: CALL_OW 72
47464: ST_TO_ADDR
// if not t then
47465: LD_VAR 0 6
47469: NOT
47470: IFFALSE 47474
// continue ;
47472: GO 47331
// for j in tmp do
47474: LD_ADDR_VAR 0 3
47478: PUSH
47479: LD_VAR 0 4
47483: PUSH
47484: FOR_IN
47485: IFFALSE 47515
// if not BuildingStatus ( j ) = bs_idle then
47487: LD_VAR 0 3
47491: PPUSH
47492: CALL_OW 461
47496: PUSH
47497: LD_INT 2
47499: EQUAL
47500: NOT
47501: IFFALSE 47513
// begin busy := true ;
47503: LD_ADDR_VAR 0 8
47507: PUSH
47508: LD_INT 1
47510: ST_TO_ADDR
// break ;
47511: GO 47515
// end ;
47513: GO 47484
47515: POP
47516: POP
// if busy then
47517: LD_VAR 0 8
47521: IFFALSE 47525
// continue ;
47523: GO 47331
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
47525: LD_ADDR_VAR 0 7
47529: PUSH
47530: LD_VAR 0 6
47534: PPUSH
47535: LD_INT 35
47537: PUSH
47538: LD_INT 0
47540: PUSH
47541: EMPTY
47542: LIST
47543: LIST
47544: PPUSH
47545: CALL_OW 72
47549: ST_TO_ADDR
// if tw then
47550: LD_VAR 0 7
47554: IFFALSE 47631
// begin tw := tw [ 1 ] ;
47556: LD_ADDR_VAR 0 7
47560: PUSH
47561: LD_VAR 0 7
47565: PUSH
47566: LD_INT 1
47568: ARRAY
47569: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
47570: LD_ADDR_VAR 0 9
47574: PUSH
47575: LD_VAR 0 7
47579: PPUSH
47580: LD_EXP 141
47584: PUSH
47585: LD_VAR 0 2
47589: ARRAY
47590: PPUSH
47591: CALL 75881 0 2
47595: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
47596: LD_EXP 155
47600: PUSH
47601: LD_VAR 0 2
47605: ARRAY
47606: IFFALSE 47629
// if not weapon in mc_allowed_tower_weapons [ i ] then
47608: LD_VAR 0 9
47612: PUSH
47613: LD_EXP 155
47617: PUSH
47618: LD_VAR 0 2
47622: ARRAY
47623: IN
47624: NOT
47625: IFFALSE 47629
// continue ;
47627: GO 47331
// end else
47629: GO 47694
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
47631: LD_ADDR_VAR 0 5
47635: PUSH
47636: LD_EXP 124
47640: PUSH
47641: LD_VAR 0 2
47645: ARRAY
47646: PPUSH
47647: LD_VAR 0 4
47651: PPUSH
47652: CALL 102170 0 2
47656: ST_TO_ADDR
// if not tmp2 then
47657: LD_VAR 0 5
47661: NOT
47662: IFFALSE 47666
// continue ;
47664: GO 47331
// tw := tmp2 [ 1 ] ;
47666: LD_ADDR_VAR 0 7
47670: PUSH
47671: LD_VAR 0 5
47675: PUSH
47676: LD_INT 1
47678: ARRAY
47679: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
47680: LD_ADDR_VAR 0 9
47684: PUSH
47685: LD_VAR 0 5
47689: PUSH
47690: LD_INT 2
47692: ARRAY
47693: ST_TO_ADDR
// end ; if not weapon then
47694: LD_VAR 0 9
47698: NOT
47699: IFFALSE 47703
// continue ;
47701: GO 47331
// ComPlaceWeapon ( tw , weapon ) ;
47703: LD_VAR 0 7
47707: PPUSH
47708: LD_VAR 0 9
47712: PPUSH
47713: CALL_OW 148
// end ;
47717: GO 47331
47719: POP
47720: POP
// end ;
47721: LD_VAR 0 1
47725: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
47726: LD_INT 0
47728: PPUSH
47729: PPUSH
47730: PPUSH
47731: PPUSH
47732: PPUSH
47733: PPUSH
47734: PPUSH
// if not mc_bases then
47735: LD_EXP 116
47739: NOT
47740: IFFALSE 47744
// exit ;
47742: GO 48512
// for i = 1 to mc_bases do
47744: LD_ADDR_VAR 0 2
47748: PUSH
47749: DOUBLE
47750: LD_INT 1
47752: DEC
47753: ST_TO_ADDR
47754: LD_EXP 116
47758: PUSH
47759: FOR_TO
47760: IFFALSE 48510
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
47762: LD_EXP 129
47766: PUSH
47767: LD_VAR 0 2
47771: ARRAY
47772: NOT
47773: PUSH
47774: LD_EXP 129
47778: PUSH
47779: LD_VAR 0 2
47783: ARRAY
47784: PUSH
47785: LD_EXP 130
47789: PUSH
47790: LD_VAR 0 2
47794: ARRAY
47795: EQUAL
47796: OR
47797: PUSH
47798: LD_EXP 139
47802: PUSH
47803: LD_VAR 0 2
47807: ARRAY
47808: OR
47809: IFFALSE 47813
// continue ;
47811: GO 47759
// if mc_miners [ i ] then
47813: LD_EXP 130
47817: PUSH
47818: LD_VAR 0 2
47822: ARRAY
47823: IFFALSE 48197
// begin for j = mc_miners [ i ] downto 1 do
47825: LD_ADDR_VAR 0 3
47829: PUSH
47830: DOUBLE
47831: LD_EXP 130
47835: PUSH
47836: LD_VAR 0 2
47840: ARRAY
47841: INC
47842: ST_TO_ADDR
47843: LD_INT 1
47845: PUSH
47846: FOR_DOWNTO
47847: IFFALSE 48195
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
47849: LD_EXP 130
47853: PUSH
47854: LD_VAR 0 2
47858: ARRAY
47859: PUSH
47860: LD_VAR 0 3
47864: ARRAY
47865: PPUSH
47866: CALL_OW 301
47870: PUSH
47871: LD_EXP 130
47875: PUSH
47876: LD_VAR 0 2
47880: ARRAY
47881: PUSH
47882: LD_VAR 0 3
47886: ARRAY
47887: PPUSH
47888: CALL_OW 257
47892: PUSH
47893: LD_INT 1
47895: NONEQUAL
47896: OR
47897: IFFALSE 47960
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
47899: LD_ADDR_VAR 0 5
47903: PUSH
47904: LD_EXP 130
47908: PUSH
47909: LD_VAR 0 2
47913: ARRAY
47914: PUSH
47915: LD_EXP 130
47919: PUSH
47920: LD_VAR 0 2
47924: ARRAY
47925: PUSH
47926: LD_VAR 0 3
47930: ARRAY
47931: DIFF
47932: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
47933: LD_ADDR_EXP 130
47937: PUSH
47938: LD_EXP 130
47942: PPUSH
47943: LD_VAR 0 2
47947: PPUSH
47948: LD_VAR 0 5
47952: PPUSH
47953: CALL_OW 1
47957: ST_TO_ADDR
// continue ;
47958: GO 47846
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
47960: LD_EXP 130
47964: PUSH
47965: LD_VAR 0 2
47969: ARRAY
47970: PUSH
47971: LD_VAR 0 3
47975: ARRAY
47976: PPUSH
47977: CALL_OW 257
47981: PUSH
47982: LD_INT 1
47984: EQUAL
47985: PUSH
47986: LD_EXP 130
47990: PUSH
47991: LD_VAR 0 2
47995: ARRAY
47996: PUSH
47997: LD_VAR 0 3
48001: ARRAY
48002: PPUSH
48003: CALL_OW 459
48007: NOT
48008: AND
48009: PUSH
48010: LD_EXP 130
48014: PUSH
48015: LD_VAR 0 2
48019: ARRAY
48020: PUSH
48021: LD_VAR 0 3
48025: ARRAY
48026: PPUSH
48027: CALL_OW 314
48031: NOT
48032: AND
48033: IFFALSE 48193
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
48035: LD_EXP 130
48039: PUSH
48040: LD_VAR 0 2
48044: ARRAY
48045: PUSH
48046: LD_VAR 0 3
48050: ARRAY
48051: PPUSH
48052: CALL_OW 310
48056: IFFALSE 48079
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
48058: LD_EXP 130
48062: PUSH
48063: LD_VAR 0 2
48067: ARRAY
48068: PUSH
48069: LD_VAR 0 3
48073: ARRAY
48074: PPUSH
48075: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
48079: LD_EXP 130
48083: PUSH
48084: LD_VAR 0 2
48088: ARRAY
48089: PUSH
48090: LD_VAR 0 3
48094: ARRAY
48095: PPUSH
48096: CALL_OW 314
48100: NOT
48101: IFFALSE 48193
// begin r := rand ( 1 , mc_mines [ i ] ) ;
48103: LD_ADDR_VAR 0 7
48107: PUSH
48108: LD_INT 1
48110: PPUSH
48111: LD_EXP 129
48115: PUSH
48116: LD_VAR 0 2
48120: ARRAY
48121: PPUSH
48122: CALL_OW 12
48126: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
48127: LD_EXP 130
48131: PUSH
48132: LD_VAR 0 2
48136: ARRAY
48137: PUSH
48138: LD_VAR 0 3
48142: ARRAY
48143: PPUSH
48144: LD_EXP 129
48148: PUSH
48149: LD_VAR 0 2
48153: ARRAY
48154: PUSH
48155: LD_VAR 0 7
48159: ARRAY
48160: PUSH
48161: LD_INT 1
48163: ARRAY
48164: PPUSH
48165: LD_EXP 129
48169: PUSH
48170: LD_VAR 0 2
48174: ARRAY
48175: PUSH
48176: LD_VAR 0 7
48180: ARRAY
48181: PUSH
48182: LD_INT 2
48184: ARRAY
48185: PPUSH
48186: LD_INT 0
48188: PPUSH
48189: CALL_OW 193
// end ; end ; end ;
48193: GO 47846
48195: POP
48196: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
48197: LD_ADDR_VAR 0 5
48201: PUSH
48202: LD_EXP 116
48206: PUSH
48207: LD_VAR 0 2
48211: ARRAY
48212: PPUSH
48213: LD_INT 2
48215: PUSH
48216: LD_INT 30
48218: PUSH
48219: LD_INT 4
48221: PUSH
48222: EMPTY
48223: LIST
48224: LIST
48225: PUSH
48226: LD_INT 30
48228: PUSH
48229: LD_INT 5
48231: PUSH
48232: EMPTY
48233: LIST
48234: LIST
48235: PUSH
48236: LD_INT 30
48238: PUSH
48239: LD_INT 32
48241: PUSH
48242: EMPTY
48243: LIST
48244: LIST
48245: PUSH
48246: EMPTY
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: PPUSH
48252: CALL_OW 72
48256: ST_TO_ADDR
// if not tmp then
48257: LD_VAR 0 5
48261: NOT
48262: IFFALSE 48266
// continue ;
48264: GO 47759
// list := [ ] ;
48266: LD_ADDR_VAR 0 6
48270: PUSH
48271: EMPTY
48272: ST_TO_ADDR
// for j in tmp do
48273: LD_ADDR_VAR 0 3
48277: PUSH
48278: LD_VAR 0 5
48282: PUSH
48283: FOR_IN
48284: IFFALSE 48353
// begin for k in UnitsInside ( j ) do
48286: LD_ADDR_VAR 0 4
48290: PUSH
48291: LD_VAR 0 3
48295: PPUSH
48296: CALL_OW 313
48300: PUSH
48301: FOR_IN
48302: IFFALSE 48349
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
48304: LD_VAR 0 4
48308: PPUSH
48309: CALL_OW 257
48313: PUSH
48314: LD_INT 1
48316: EQUAL
48317: PUSH
48318: LD_VAR 0 4
48322: PPUSH
48323: CALL_OW 459
48327: NOT
48328: AND
48329: IFFALSE 48347
// list := list ^ k ;
48331: LD_ADDR_VAR 0 6
48335: PUSH
48336: LD_VAR 0 6
48340: PUSH
48341: LD_VAR 0 4
48345: ADD
48346: ST_TO_ADDR
48347: GO 48301
48349: POP
48350: POP
// end ;
48351: GO 48283
48353: POP
48354: POP
// list := list diff mc_miners [ i ] ;
48355: LD_ADDR_VAR 0 6
48359: PUSH
48360: LD_VAR 0 6
48364: PUSH
48365: LD_EXP 130
48369: PUSH
48370: LD_VAR 0 2
48374: ARRAY
48375: DIFF
48376: ST_TO_ADDR
// if not list then
48377: LD_VAR 0 6
48381: NOT
48382: IFFALSE 48386
// continue ;
48384: GO 47759
// k := mc_mines [ i ] - mc_miners [ i ] ;
48386: LD_ADDR_VAR 0 4
48390: PUSH
48391: LD_EXP 129
48395: PUSH
48396: LD_VAR 0 2
48400: ARRAY
48401: PUSH
48402: LD_EXP 130
48406: PUSH
48407: LD_VAR 0 2
48411: ARRAY
48412: MINUS
48413: ST_TO_ADDR
// if k > list then
48414: LD_VAR 0 4
48418: PUSH
48419: LD_VAR 0 6
48423: GREATER
48424: IFFALSE 48436
// k := list ;
48426: LD_ADDR_VAR 0 4
48430: PUSH
48431: LD_VAR 0 6
48435: ST_TO_ADDR
// for j = 1 to k do
48436: LD_ADDR_VAR 0 3
48440: PUSH
48441: DOUBLE
48442: LD_INT 1
48444: DEC
48445: ST_TO_ADDR
48446: LD_VAR 0 4
48450: PUSH
48451: FOR_TO
48452: IFFALSE 48506
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
48454: LD_ADDR_EXP 130
48458: PUSH
48459: LD_EXP 130
48463: PPUSH
48464: LD_VAR 0 2
48468: PUSH
48469: LD_EXP 130
48473: PUSH
48474: LD_VAR 0 2
48478: ARRAY
48479: PUSH
48480: LD_INT 1
48482: PLUS
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: PPUSH
48488: LD_VAR 0 6
48492: PUSH
48493: LD_VAR 0 3
48497: ARRAY
48498: PPUSH
48499: CALL 70871 0 3
48503: ST_TO_ADDR
48504: GO 48451
48506: POP
48507: POP
// end ;
48508: GO 47759
48510: POP
48511: POP
// end ;
48512: LD_VAR 0 1
48516: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
48517: LD_INT 0
48519: PPUSH
48520: PPUSH
48521: PPUSH
48522: PPUSH
48523: PPUSH
48524: PPUSH
48525: PPUSH
48526: PPUSH
48527: PPUSH
48528: PPUSH
48529: PPUSH
// if not mc_bases then
48530: LD_EXP 116
48534: NOT
48535: IFFALSE 48539
// exit ;
48537: GO 50362
// for i = 1 to mc_bases do
48539: LD_ADDR_VAR 0 2
48543: PUSH
48544: DOUBLE
48545: LD_INT 1
48547: DEC
48548: ST_TO_ADDR
48549: LD_EXP 116
48553: PUSH
48554: FOR_TO
48555: IFFALSE 50360
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
48557: LD_EXP 116
48561: PUSH
48562: LD_VAR 0 2
48566: ARRAY
48567: NOT
48568: PUSH
48569: LD_EXP 123
48573: PUSH
48574: LD_VAR 0 2
48578: ARRAY
48579: OR
48580: IFFALSE 48584
// continue ;
48582: GO 48554
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
48584: LD_EXP 132
48588: PUSH
48589: LD_VAR 0 2
48593: ARRAY
48594: NOT
48595: PUSH
48596: LD_EXP 133
48600: PUSH
48601: LD_VAR 0 2
48605: ARRAY
48606: AND
48607: IFFALSE 48645
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
48609: LD_ADDR_EXP 133
48613: PUSH
48614: LD_EXP 133
48618: PPUSH
48619: LD_VAR 0 2
48623: PPUSH
48624: EMPTY
48625: PPUSH
48626: CALL_OW 1
48630: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
48631: LD_VAR 0 2
48635: PPUSH
48636: LD_INT 107
48638: PPUSH
48639: CALL 39413 0 2
// continue ;
48643: GO 48554
// end ; target := [ ] ;
48645: LD_ADDR_VAR 0 7
48649: PUSH
48650: EMPTY
48651: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
48652: LD_ADDR_VAR 0 6
48656: PUSH
48657: LD_EXP 116
48661: PUSH
48662: LD_VAR 0 2
48666: ARRAY
48667: PUSH
48668: LD_INT 1
48670: ARRAY
48671: PPUSH
48672: CALL_OW 255
48676: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48677: LD_ADDR_VAR 0 9
48681: PUSH
48682: LD_EXP 116
48686: PUSH
48687: LD_VAR 0 2
48691: ARRAY
48692: PPUSH
48693: LD_INT 2
48695: PUSH
48696: LD_INT 30
48698: PUSH
48699: LD_INT 0
48701: PUSH
48702: EMPTY
48703: LIST
48704: LIST
48705: PUSH
48706: LD_INT 30
48708: PUSH
48709: LD_INT 1
48711: PUSH
48712: EMPTY
48713: LIST
48714: LIST
48715: PUSH
48716: EMPTY
48717: LIST
48718: LIST
48719: LIST
48720: PPUSH
48721: CALL_OW 72
48725: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
48726: LD_ADDR_VAR 0 3
48730: PUSH
48731: DOUBLE
48732: LD_EXP 132
48736: PUSH
48737: LD_VAR 0 2
48741: ARRAY
48742: INC
48743: ST_TO_ADDR
48744: LD_INT 1
48746: PUSH
48747: FOR_DOWNTO
48748: IFFALSE 48993
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
48750: LD_EXP 132
48754: PUSH
48755: LD_VAR 0 2
48759: ARRAY
48760: PUSH
48761: LD_VAR 0 3
48765: ARRAY
48766: PUSH
48767: LD_INT 2
48769: ARRAY
48770: PPUSH
48771: LD_EXP 132
48775: PUSH
48776: LD_VAR 0 2
48780: ARRAY
48781: PUSH
48782: LD_VAR 0 3
48786: ARRAY
48787: PUSH
48788: LD_INT 3
48790: ARRAY
48791: PPUSH
48792: CALL_OW 488
48796: PUSH
48797: LD_EXP 132
48801: PUSH
48802: LD_VAR 0 2
48806: ARRAY
48807: PUSH
48808: LD_VAR 0 3
48812: ARRAY
48813: PUSH
48814: LD_INT 2
48816: ARRAY
48817: PPUSH
48818: LD_EXP 132
48822: PUSH
48823: LD_VAR 0 2
48827: ARRAY
48828: PUSH
48829: LD_VAR 0 3
48833: ARRAY
48834: PUSH
48835: LD_INT 3
48837: ARRAY
48838: PPUSH
48839: CALL_OW 284
48843: PUSH
48844: LD_INT 0
48846: EQUAL
48847: AND
48848: IFFALSE 48903
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
48850: LD_ADDR_VAR 0 5
48854: PUSH
48855: LD_EXP 132
48859: PUSH
48860: LD_VAR 0 2
48864: ARRAY
48865: PPUSH
48866: LD_VAR 0 3
48870: PPUSH
48871: CALL_OW 3
48875: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
48876: LD_ADDR_EXP 132
48880: PUSH
48881: LD_EXP 132
48885: PPUSH
48886: LD_VAR 0 2
48890: PPUSH
48891: LD_VAR 0 5
48895: PPUSH
48896: CALL_OW 1
48900: ST_TO_ADDR
// continue ;
48901: GO 48747
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
48903: LD_VAR 0 6
48907: PPUSH
48908: LD_EXP 132
48912: PUSH
48913: LD_VAR 0 2
48917: ARRAY
48918: PUSH
48919: LD_VAR 0 3
48923: ARRAY
48924: PUSH
48925: LD_INT 2
48927: ARRAY
48928: PPUSH
48929: LD_EXP 132
48933: PUSH
48934: LD_VAR 0 2
48938: ARRAY
48939: PUSH
48940: LD_VAR 0 3
48944: ARRAY
48945: PUSH
48946: LD_INT 3
48948: ARRAY
48949: PPUSH
48950: LD_INT 30
48952: PPUSH
48953: CALL 71767 0 4
48957: PUSH
48958: LD_INT 4
48960: ARRAY
48961: PUSH
48962: LD_INT 0
48964: EQUAL
48965: IFFALSE 48991
// begin target := mc_crates [ i ] [ j ] ;
48967: LD_ADDR_VAR 0 7
48971: PUSH
48972: LD_EXP 132
48976: PUSH
48977: LD_VAR 0 2
48981: ARRAY
48982: PUSH
48983: LD_VAR 0 3
48987: ARRAY
48988: ST_TO_ADDR
// break ;
48989: GO 48993
// end ; end ;
48991: GO 48747
48993: POP
48994: POP
// if not target then
48995: LD_VAR 0 7
48999: NOT
49000: IFFALSE 49004
// continue ;
49002: GO 48554
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
49004: LD_ADDR_VAR 0 8
49008: PUSH
49009: LD_EXP 135
49013: PUSH
49014: LD_VAR 0 2
49018: ARRAY
49019: PPUSH
49020: LD_INT 2
49022: PUSH
49023: LD_INT 3
49025: PUSH
49026: LD_INT 58
49028: PUSH
49029: EMPTY
49030: LIST
49031: PUSH
49032: EMPTY
49033: LIST
49034: LIST
49035: PUSH
49036: LD_INT 61
49038: PUSH
49039: EMPTY
49040: LIST
49041: PUSH
49042: LD_INT 33
49044: PUSH
49045: LD_INT 5
49047: PUSH
49048: EMPTY
49049: LIST
49050: LIST
49051: PUSH
49052: LD_INT 33
49054: PUSH
49055: LD_INT 3
49057: PUSH
49058: EMPTY
49059: LIST
49060: LIST
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: LIST
49066: LIST
49067: LIST
49068: PUSH
49069: LD_INT 2
49071: PUSH
49072: LD_INT 34
49074: PUSH
49075: LD_INT 32
49077: PUSH
49078: EMPTY
49079: LIST
49080: LIST
49081: PUSH
49082: LD_INT 34
49084: PUSH
49085: LD_INT 51
49087: PUSH
49088: EMPTY
49089: LIST
49090: LIST
49091: PUSH
49092: LD_INT 34
49094: PUSH
49095: LD_INT 12
49097: PUSH
49098: EMPTY
49099: LIST
49100: LIST
49101: PUSH
49102: EMPTY
49103: LIST
49104: LIST
49105: LIST
49106: LIST
49107: PUSH
49108: EMPTY
49109: LIST
49110: LIST
49111: PPUSH
49112: CALL_OW 72
49116: ST_TO_ADDR
// if not cargo then
49117: LD_VAR 0 8
49121: NOT
49122: IFFALSE 49828
// begin if mc_crates_collector [ i ] < 5 then
49124: LD_EXP 133
49128: PUSH
49129: LD_VAR 0 2
49133: ARRAY
49134: PUSH
49135: LD_INT 5
49137: LESS
49138: IFFALSE 49504
// begin if mc_ape [ i ] then
49140: LD_EXP 145
49144: PUSH
49145: LD_VAR 0 2
49149: ARRAY
49150: IFFALSE 49197
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
49152: LD_ADDR_VAR 0 5
49156: PUSH
49157: LD_EXP 145
49161: PUSH
49162: LD_VAR 0 2
49166: ARRAY
49167: PPUSH
49168: LD_INT 25
49170: PUSH
49171: LD_INT 16
49173: PUSH
49174: EMPTY
49175: LIST
49176: LIST
49177: PUSH
49178: LD_INT 24
49180: PUSH
49181: LD_INT 750
49183: PUSH
49184: EMPTY
49185: LIST
49186: LIST
49187: PUSH
49188: EMPTY
49189: LIST
49190: LIST
49191: PPUSH
49192: CALL_OW 72
49196: ST_TO_ADDR
// if not tmp then
49197: LD_VAR 0 5
49201: NOT
49202: IFFALSE 49249
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
49204: LD_ADDR_VAR 0 5
49208: PUSH
49209: LD_EXP 116
49213: PUSH
49214: LD_VAR 0 2
49218: ARRAY
49219: PPUSH
49220: LD_INT 25
49222: PUSH
49223: LD_INT 2
49225: PUSH
49226: EMPTY
49227: LIST
49228: LIST
49229: PUSH
49230: LD_INT 24
49232: PUSH
49233: LD_INT 750
49235: PUSH
49236: EMPTY
49237: LIST
49238: LIST
49239: PUSH
49240: EMPTY
49241: LIST
49242: LIST
49243: PPUSH
49244: CALL_OW 72
49248: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
49249: LD_EXP 145
49253: PUSH
49254: LD_VAR 0 2
49258: ARRAY
49259: PUSH
49260: LD_EXP 116
49264: PUSH
49265: LD_VAR 0 2
49269: ARRAY
49270: PPUSH
49271: LD_INT 25
49273: PUSH
49274: LD_INT 2
49276: PUSH
49277: EMPTY
49278: LIST
49279: LIST
49280: PUSH
49281: LD_INT 24
49283: PUSH
49284: LD_INT 750
49286: PUSH
49287: EMPTY
49288: LIST
49289: LIST
49290: PUSH
49291: EMPTY
49292: LIST
49293: LIST
49294: PPUSH
49295: CALL_OW 72
49299: AND
49300: PUSH
49301: LD_VAR 0 5
49305: PUSH
49306: LD_INT 5
49308: LESS
49309: AND
49310: IFFALSE 49392
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
49312: LD_ADDR_VAR 0 3
49316: PUSH
49317: LD_EXP 116
49321: PUSH
49322: LD_VAR 0 2
49326: ARRAY
49327: PPUSH
49328: LD_INT 25
49330: PUSH
49331: LD_INT 2
49333: PUSH
49334: EMPTY
49335: LIST
49336: LIST
49337: PUSH
49338: LD_INT 24
49340: PUSH
49341: LD_INT 750
49343: PUSH
49344: EMPTY
49345: LIST
49346: LIST
49347: PUSH
49348: EMPTY
49349: LIST
49350: LIST
49351: PPUSH
49352: CALL_OW 72
49356: PUSH
49357: FOR_IN
49358: IFFALSE 49390
// begin tmp := tmp union j ;
49360: LD_ADDR_VAR 0 5
49364: PUSH
49365: LD_VAR 0 5
49369: PUSH
49370: LD_VAR 0 3
49374: UNION
49375: ST_TO_ADDR
// if tmp >= 5 then
49376: LD_VAR 0 5
49380: PUSH
49381: LD_INT 5
49383: GREATEREQUAL
49384: IFFALSE 49388
// break ;
49386: GO 49390
// end ;
49388: GO 49357
49390: POP
49391: POP
// end ; if not tmp then
49392: LD_VAR 0 5
49396: NOT
49397: IFFALSE 49401
// continue ;
49399: GO 48554
// for j in tmp do
49401: LD_ADDR_VAR 0 3
49405: PUSH
49406: LD_VAR 0 5
49410: PUSH
49411: FOR_IN
49412: IFFALSE 49502
// if not GetTag ( j ) then
49414: LD_VAR 0 3
49418: PPUSH
49419: CALL_OW 110
49423: NOT
49424: IFFALSE 49500
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
49426: LD_ADDR_EXP 133
49430: PUSH
49431: LD_EXP 133
49435: PPUSH
49436: LD_VAR 0 2
49440: PUSH
49441: LD_EXP 133
49445: PUSH
49446: LD_VAR 0 2
49450: ARRAY
49451: PUSH
49452: LD_INT 1
49454: PLUS
49455: PUSH
49456: EMPTY
49457: LIST
49458: LIST
49459: PPUSH
49460: LD_VAR 0 3
49464: PPUSH
49465: CALL 70871 0 3
49469: ST_TO_ADDR
// SetTag ( j , 107 ) ;
49470: LD_VAR 0 3
49474: PPUSH
49475: LD_INT 107
49477: PPUSH
49478: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
49482: LD_EXP 133
49486: PUSH
49487: LD_VAR 0 2
49491: ARRAY
49492: PUSH
49493: LD_INT 5
49495: GREATEREQUAL
49496: IFFALSE 49500
// break ;
49498: GO 49502
// end ;
49500: GO 49411
49502: POP
49503: POP
// end ; if mc_crates_collector [ i ] and target then
49504: LD_EXP 133
49508: PUSH
49509: LD_VAR 0 2
49513: ARRAY
49514: PUSH
49515: LD_VAR 0 7
49519: AND
49520: IFFALSE 49826
// begin if mc_crates_collector [ i ] < target [ 1 ] then
49522: LD_EXP 133
49526: PUSH
49527: LD_VAR 0 2
49531: ARRAY
49532: PUSH
49533: LD_VAR 0 7
49537: PUSH
49538: LD_INT 1
49540: ARRAY
49541: LESS
49542: IFFALSE 49562
// tmp := mc_crates_collector [ i ] else
49544: LD_ADDR_VAR 0 5
49548: PUSH
49549: LD_EXP 133
49553: PUSH
49554: LD_VAR 0 2
49558: ARRAY
49559: ST_TO_ADDR
49560: GO 49576
// tmp := target [ 1 ] ;
49562: LD_ADDR_VAR 0 5
49566: PUSH
49567: LD_VAR 0 7
49571: PUSH
49572: LD_INT 1
49574: ARRAY
49575: ST_TO_ADDR
// k := 0 ;
49576: LD_ADDR_VAR 0 4
49580: PUSH
49581: LD_INT 0
49583: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
49584: LD_ADDR_VAR 0 3
49588: PUSH
49589: LD_EXP 133
49593: PUSH
49594: LD_VAR 0 2
49598: ARRAY
49599: PUSH
49600: FOR_IN
49601: IFFALSE 49824
// begin k := k + 1 ;
49603: LD_ADDR_VAR 0 4
49607: PUSH
49608: LD_VAR 0 4
49612: PUSH
49613: LD_INT 1
49615: PLUS
49616: ST_TO_ADDR
// if k > tmp then
49617: LD_VAR 0 4
49621: PUSH
49622: LD_VAR 0 5
49626: GREATER
49627: IFFALSE 49631
// break ;
49629: GO 49824
// if not GetClass ( j ) in [ 2 , 16 ] then
49631: LD_VAR 0 3
49635: PPUSH
49636: CALL_OW 257
49640: PUSH
49641: LD_INT 2
49643: PUSH
49644: LD_INT 16
49646: PUSH
49647: EMPTY
49648: LIST
49649: LIST
49650: IN
49651: NOT
49652: IFFALSE 49705
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
49654: LD_ADDR_EXP 133
49658: PUSH
49659: LD_EXP 133
49663: PPUSH
49664: LD_VAR 0 2
49668: PPUSH
49669: LD_EXP 133
49673: PUSH
49674: LD_VAR 0 2
49678: ARRAY
49679: PUSH
49680: LD_VAR 0 3
49684: DIFF
49685: PPUSH
49686: CALL_OW 1
49690: ST_TO_ADDR
// SetTag ( j , 0 ) ;
49691: LD_VAR 0 3
49695: PPUSH
49696: LD_INT 0
49698: PPUSH
49699: CALL_OW 109
// continue ;
49703: GO 49600
// end ; if IsInUnit ( j ) then
49705: LD_VAR 0 3
49709: PPUSH
49710: CALL_OW 310
49714: IFFALSE 49725
// ComExitBuilding ( j ) ;
49716: LD_VAR 0 3
49720: PPUSH
49721: CALL_OW 122
// wait ( 3 ) ;
49725: LD_INT 3
49727: PPUSH
49728: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
49732: LD_VAR 0 3
49736: PPUSH
49737: CALL_OW 314
49741: PUSH
49742: LD_VAR 0 6
49746: PPUSH
49747: LD_VAR 0 7
49751: PUSH
49752: LD_INT 2
49754: ARRAY
49755: PPUSH
49756: LD_VAR 0 7
49760: PUSH
49761: LD_INT 3
49763: ARRAY
49764: PPUSH
49765: LD_INT 30
49767: PPUSH
49768: CALL 71767 0 4
49772: PUSH
49773: LD_INT 4
49775: ARRAY
49776: AND
49777: IFFALSE 49795
// ComStandNearbyBuilding ( j , depot ) else
49779: LD_VAR 0 3
49783: PPUSH
49784: LD_VAR 0 9
49788: PPUSH
49789: CALL 67449 0 2
49793: GO 49822
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
49795: LD_VAR 0 3
49799: PPUSH
49800: LD_VAR 0 7
49804: PUSH
49805: LD_INT 2
49807: ARRAY
49808: PPUSH
49809: LD_VAR 0 7
49813: PUSH
49814: LD_INT 3
49816: ARRAY
49817: PPUSH
49818: CALL_OW 117
// end ;
49822: GO 49600
49824: POP
49825: POP
// end ; end else
49826: GO 50358
// begin for j in cargo do
49828: LD_ADDR_VAR 0 3
49832: PUSH
49833: LD_VAR 0 8
49837: PUSH
49838: FOR_IN
49839: IFFALSE 50356
// begin if GetTag ( j ) <> 0 then
49841: LD_VAR 0 3
49845: PPUSH
49846: CALL_OW 110
49850: PUSH
49851: LD_INT 0
49853: NONEQUAL
49854: IFFALSE 49858
// continue ;
49856: GO 49838
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
49858: LD_VAR 0 3
49862: PPUSH
49863: CALL_OW 256
49867: PUSH
49868: LD_INT 1000
49870: LESS
49871: PUSH
49872: LD_VAR 0 3
49876: PPUSH
49877: LD_EXP 140
49881: PUSH
49882: LD_VAR 0 2
49886: ARRAY
49887: PPUSH
49888: CALL_OW 308
49892: NOT
49893: AND
49894: IFFALSE 49916
// ComMoveToArea ( j , mc_parking [ i ] ) ;
49896: LD_VAR 0 3
49900: PPUSH
49901: LD_EXP 140
49905: PUSH
49906: LD_VAR 0 2
49910: ARRAY
49911: PPUSH
49912: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
49916: LD_VAR 0 3
49920: PPUSH
49921: CALL_OW 256
49925: PUSH
49926: LD_INT 1000
49928: LESS
49929: PUSH
49930: LD_VAR 0 3
49934: PPUSH
49935: LD_EXP 140
49939: PUSH
49940: LD_VAR 0 2
49944: ARRAY
49945: PPUSH
49946: CALL_OW 308
49950: AND
49951: IFFALSE 49955
// continue ;
49953: GO 49838
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
49955: LD_VAR 0 3
49959: PPUSH
49960: CALL_OW 262
49964: PUSH
49965: LD_INT 2
49967: EQUAL
49968: PUSH
49969: LD_VAR 0 3
49973: PPUSH
49974: CALL_OW 261
49978: PUSH
49979: LD_INT 15
49981: LESS
49982: AND
49983: IFFALSE 49987
// continue ;
49985: GO 49838
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
49987: LD_VAR 0 3
49991: PPUSH
49992: CALL_OW 262
49996: PUSH
49997: LD_INT 1
49999: EQUAL
50000: PUSH
50001: LD_VAR 0 3
50005: PPUSH
50006: CALL_OW 261
50010: PUSH
50011: LD_INT 10
50013: LESS
50014: AND
50015: IFFALSE 50295
// begin if not depot then
50017: LD_VAR 0 9
50021: NOT
50022: IFFALSE 50026
// continue ;
50024: GO 49838
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
50026: LD_VAR 0 3
50030: PPUSH
50031: LD_VAR 0 9
50035: PPUSH
50036: LD_VAR 0 3
50040: PPUSH
50041: CALL_OW 74
50045: PPUSH
50046: CALL_OW 296
50050: PUSH
50051: LD_INT 6
50053: LESS
50054: IFFALSE 50070
// SetFuel ( j , 100 ) else
50056: LD_VAR 0 3
50060: PPUSH
50061: LD_INT 100
50063: PPUSH
50064: CALL_OW 240
50068: GO 50295
// if GetFuel ( j ) = 0 then
50070: LD_VAR 0 3
50074: PPUSH
50075: CALL_OW 261
50079: PUSH
50080: LD_INT 0
50082: EQUAL
50083: IFFALSE 50295
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
50085: LD_ADDR_EXP 135
50089: PUSH
50090: LD_EXP 135
50094: PPUSH
50095: LD_VAR 0 2
50099: PPUSH
50100: LD_EXP 135
50104: PUSH
50105: LD_VAR 0 2
50109: ARRAY
50110: PUSH
50111: LD_VAR 0 3
50115: DIFF
50116: PPUSH
50117: CALL_OW 1
50121: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
50122: LD_VAR 0 3
50126: PPUSH
50127: CALL_OW 263
50131: PUSH
50132: LD_INT 1
50134: EQUAL
50135: IFFALSE 50151
// ComExitVehicle ( IsInUnit ( j ) ) ;
50137: LD_VAR 0 3
50141: PPUSH
50142: CALL_OW 310
50146: PPUSH
50147: CALL_OW 121
// if GetControl ( j ) = control_remote then
50151: LD_VAR 0 3
50155: PPUSH
50156: CALL_OW 263
50160: PUSH
50161: LD_INT 2
50163: EQUAL
50164: IFFALSE 50175
// ComUnlink ( j ) ;
50166: LD_VAR 0 3
50170: PPUSH
50171: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
50175: LD_ADDR_VAR 0 10
50179: PUSH
50180: LD_VAR 0 2
50184: PPUSH
50185: LD_INT 3
50187: PPUSH
50188: CALL 59934 0 2
50192: ST_TO_ADDR
// if fac then
50193: LD_VAR 0 10
50197: IFFALSE 50293
// begin for k in fac do
50199: LD_ADDR_VAR 0 4
50203: PUSH
50204: LD_VAR 0 10
50208: PUSH
50209: FOR_IN
50210: IFFALSE 50291
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
50212: LD_ADDR_VAR 0 11
50216: PUSH
50217: LD_VAR 0 10
50221: PPUSH
50222: LD_VAR 0 3
50226: PPUSH
50227: CALL_OW 265
50231: PPUSH
50232: LD_VAR 0 3
50236: PPUSH
50237: CALL_OW 262
50241: PPUSH
50242: LD_VAR 0 3
50246: PPUSH
50247: CALL_OW 263
50251: PPUSH
50252: LD_VAR 0 3
50256: PPUSH
50257: CALL_OW 264
50261: PPUSH
50262: CALL 68367 0 5
50266: ST_TO_ADDR
// if components then
50267: LD_VAR 0 11
50271: IFFALSE 50289
// begin MC_InsertProduceList ( i , components ) ;
50273: LD_VAR 0 2
50277: PPUSH
50278: LD_VAR 0 11
50282: PPUSH
50283: CALL 59479 0 2
// break ;
50287: GO 50291
// end ; end ;
50289: GO 50209
50291: POP
50292: POP
// end ; continue ;
50293: GO 49838
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
50295: LD_VAR 0 3
50299: PPUSH
50300: LD_INT 1
50302: PPUSH
50303: CALL_OW 289
50307: PUSH
50308: LD_INT 100
50310: LESS
50311: PUSH
50312: LD_VAR 0 3
50316: PPUSH
50317: CALL_OW 314
50321: NOT
50322: AND
50323: IFFALSE 50352
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
50325: LD_VAR 0 3
50329: PPUSH
50330: LD_VAR 0 7
50334: PUSH
50335: LD_INT 2
50337: ARRAY
50338: PPUSH
50339: LD_VAR 0 7
50343: PUSH
50344: LD_INT 3
50346: ARRAY
50347: PPUSH
50348: CALL_OW 117
// break ;
50352: GO 50356
// end ;
50354: GO 49838
50356: POP
50357: POP
// end ; end ;
50358: GO 48554
50360: POP
50361: POP
// end ;
50362: LD_VAR 0 1
50366: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
50367: LD_INT 0
50369: PPUSH
50370: PPUSH
50371: PPUSH
50372: PPUSH
// if not mc_bases then
50373: LD_EXP 116
50377: NOT
50378: IFFALSE 50382
// exit ;
50380: GO 50543
// for i = 1 to mc_bases do
50382: LD_ADDR_VAR 0 2
50386: PUSH
50387: DOUBLE
50388: LD_INT 1
50390: DEC
50391: ST_TO_ADDR
50392: LD_EXP 116
50396: PUSH
50397: FOR_TO
50398: IFFALSE 50541
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
50400: LD_ADDR_VAR 0 4
50404: PUSH
50405: LD_EXP 135
50409: PUSH
50410: LD_VAR 0 2
50414: ARRAY
50415: PUSH
50416: LD_EXP 138
50420: PUSH
50421: LD_VAR 0 2
50425: ARRAY
50426: UNION
50427: PPUSH
50428: LD_INT 33
50430: PUSH
50431: LD_INT 2
50433: PUSH
50434: EMPTY
50435: LIST
50436: LIST
50437: PPUSH
50438: CALL_OW 72
50442: ST_TO_ADDR
// if tmp then
50443: LD_VAR 0 4
50447: IFFALSE 50539
// for j in tmp do
50449: LD_ADDR_VAR 0 3
50453: PUSH
50454: LD_VAR 0 4
50458: PUSH
50459: FOR_IN
50460: IFFALSE 50537
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
50462: LD_VAR 0 3
50466: PPUSH
50467: CALL_OW 312
50471: NOT
50472: PUSH
50473: LD_VAR 0 3
50477: PPUSH
50478: CALL_OW 256
50482: PUSH
50483: LD_INT 250
50485: GREATEREQUAL
50486: AND
50487: IFFALSE 50500
// Connect ( j ) else
50489: LD_VAR 0 3
50493: PPUSH
50494: CALL 73842 0 1
50498: GO 50535
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
50500: LD_VAR 0 3
50504: PPUSH
50505: CALL_OW 256
50509: PUSH
50510: LD_INT 250
50512: LESS
50513: PUSH
50514: LD_VAR 0 3
50518: PPUSH
50519: CALL_OW 312
50523: AND
50524: IFFALSE 50535
// ComUnlink ( j ) ;
50526: LD_VAR 0 3
50530: PPUSH
50531: CALL_OW 136
50535: GO 50459
50537: POP
50538: POP
// end ;
50539: GO 50397
50541: POP
50542: POP
// end ;
50543: LD_VAR 0 1
50547: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
50548: LD_INT 0
50550: PPUSH
50551: PPUSH
50552: PPUSH
50553: PPUSH
50554: PPUSH
// if not mc_bases then
50555: LD_EXP 116
50559: NOT
50560: IFFALSE 50564
// exit ;
50562: GO 51009
// for i = 1 to mc_bases do
50564: LD_ADDR_VAR 0 2
50568: PUSH
50569: DOUBLE
50570: LD_INT 1
50572: DEC
50573: ST_TO_ADDR
50574: LD_EXP 116
50578: PUSH
50579: FOR_TO
50580: IFFALSE 51007
// begin if not mc_produce [ i ] then
50582: LD_EXP 137
50586: PUSH
50587: LD_VAR 0 2
50591: ARRAY
50592: NOT
50593: IFFALSE 50597
// continue ;
50595: GO 50579
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
50597: LD_ADDR_VAR 0 5
50601: PUSH
50602: LD_EXP 116
50606: PUSH
50607: LD_VAR 0 2
50611: ARRAY
50612: PPUSH
50613: LD_INT 30
50615: PUSH
50616: LD_INT 3
50618: PUSH
50619: EMPTY
50620: LIST
50621: LIST
50622: PPUSH
50623: CALL_OW 72
50627: ST_TO_ADDR
// if not fac then
50628: LD_VAR 0 5
50632: NOT
50633: IFFALSE 50637
// continue ;
50635: GO 50579
// for j in fac do
50637: LD_ADDR_VAR 0 3
50641: PUSH
50642: LD_VAR 0 5
50646: PUSH
50647: FOR_IN
50648: IFFALSE 51003
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
50650: LD_VAR 0 3
50654: PPUSH
50655: CALL_OW 461
50659: PUSH
50660: LD_INT 2
50662: NONEQUAL
50663: PUSH
50664: LD_VAR 0 3
50668: PPUSH
50669: LD_INT 15
50671: PPUSH
50672: CALL 73470 0 2
50676: PUSH
50677: LD_INT 4
50679: ARRAY
50680: OR
50681: IFFALSE 50685
// continue ;
50683: GO 50647
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
50685: LD_VAR 0 3
50689: PPUSH
50690: LD_EXP 137
50694: PUSH
50695: LD_VAR 0 2
50699: ARRAY
50700: PUSH
50701: LD_INT 1
50703: ARRAY
50704: PUSH
50705: LD_INT 1
50707: ARRAY
50708: PPUSH
50709: LD_EXP 137
50713: PUSH
50714: LD_VAR 0 2
50718: ARRAY
50719: PUSH
50720: LD_INT 1
50722: ARRAY
50723: PUSH
50724: LD_INT 2
50726: ARRAY
50727: PPUSH
50728: LD_EXP 137
50732: PUSH
50733: LD_VAR 0 2
50737: ARRAY
50738: PUSH
50739: LD_INT 1
50741: ARRAY
50742: PUSH
50743: LD_INT 3
50745: ARRAY
50746: PPUSH
50747: LD_EXP 137
50751: PUSH
50752: LD_VAR 0 2
50756: ARRAY
50757: PUSH
50758: LD_INT 1
50760: ARRAY
50761: PUSH
50762: LD_INT 4
50764: ARRAY
50765: PPUSH
50766: CALL_OW 448
50770: PUSH
50771: LD_VAR 0 3
50775: PPUSH
50776: LD_EXP 137
50780: PUSH
50781: LD_VAR 0 2
50785: ARRAY
50786: PUSH
50787: LD_INT 1
50789: ARRAY
50790: PUSH
50791: LD_INT 1
50793: ARRAY
50794: PUSH
50795: LD_EXP 137
50799: PUSH
50800: LD_VAR 0 2
50804: ARRAY
50805: PUSH
50806: LD_INT 1
50808: ARRAY
50809: PUSH
50810: LD_INT 2
50812: ARRAY
50813: PUSH
50814: LD_EXP 137
50818: PUSH
50819: LD_VAR 0 2
50823: ARRAY
50824: PUSH
50825: LD_INT 1
50827: ARRAY
50828: PUSH
50829: LD_INT 3
50831: ARRAY
50832: PUSH
50833: LD_EXP 137
50837: PUSH
50838: LD_VAR 0 2
50842: ARRAY
50843: PUSH
50844: LD_INT 1
50846: ARRAY
50847: PUSH
50848: LD_INT 4
50850: ARRAY
50851: PUSH
50852: EMPTY
50853: LIST
50854: LIST
50855: LIST
50856: LIST
50857: PPUSH
50858: CALL 77237 0 2
50862: AND
50863: IFFALSE 51001
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
50865: LD_VAR 0 3
50869: PPUSH
50870: LD_EXP 137
50874: PUSH
50875: LD_VAR 0 2
50879: ARRAY
50880: PUSH
50881: LD_INT 1
50883: ARRAY
50884: PUSH
50885: LD_INT 1
50887: ARRAY
50888: PPUSH
50889: LD_EXP 137
50893: PUSH
50894: LD_VAR 0 2
50898: ARRAY
50899: PUSH
50900: LD_INT 1
50902: ARRAY
50903: PUSH
50904: LD_INT 2
50906: ARRAY
50907: PPUSH
50908: LD_EXP 137
50912: PUSH
50913: LD_VAR 0 2
50917: ARRAY
50918: PUSH
50919: LD_INT 1
50921: ARRAY
50922: PUSH
50923: LD_INT 3
50925: ARRAY
50926: PPUSH
50927: LD_EXP 137
50931: PUSH
50932: LD_VAR 0 2
50936: ARRAY
50937: PUSH
50938: LD_INT 1
50940: ARRAY
50941: PUSH
50942: LD_INT 4
50944: ARRAY
50945: PPUSH
50946: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
50950: LD_ADDR_VAR 0 4
50954: PUSH
50955: LD_EXP 137
50959: PUSH
50960: LD_VAR 0 2
50964: ARRAY
50965: PPUSH
50966: LD_INT 1
50968: PPUSH
50969: CALL_OW 3
50973: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
50974: LD_ADDR_EXP 137
50978: PUSH
50979: LD_EXP 137
50983: PPUSH
50984: LD_VAR 0 2
50988: PPUSH
50989: LD_VAR 0 4
50993: PPUSH
50994: CALL_OW 1
50998: ST_TO_ADDR
// break ;
50999: GO 51003
// end ; end ;
51001: GO 50647
51003: POP
51004: POP
// end ;
51005: GO 50579
51007: POP
51008: POP
// end ;
51009: LD_VAR 0 1
51013: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
51014: LD_INT 0
51016: PPUSH
51017: PPUSH
51018: PPUSH
// if not mc_bases then
51019: LD_EXP 116
51023: NOT
51024: IFFALSE 51028
// exit ;
51026: GO 51117
// for i = 1 to mc_bases do
51028: LD_ADDR_VAR 0 2
51032: PUSH
51033: DOUBLE
51034: LD_INT 1
51036: DEC
51037: ST_TO_ADDR
51038: LD_EXP 116
51042: PUSH
51043: FOR_TO
51044: IFFALSE 51115
// begin if mc_attack [ i ] then
51046: LD_EXP 136
51050: PUSH
51051: LD_VAR 0 2
51055: ARRAY
51056: IFFALSE 51113
// begin tmp := mc_attack [ i ] [ 1 ] ;
51058: LD_ADDR_VAR 0 3
51062: PUSH
51063: LD_EXP 136
51067: PUSH
51068: LD_VAR 0 2
51072: ARRAY
51073: PUSH
51074: LD_INT 1
51076: ARRAY
51077: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
51078: LD_ADDR_EXP 136
51082: PUSH
51083: LD_EXP 136
51087: PPUSH
51088: LD_VAR 0 2
51092: PPUSH
51093: EMPTY
51094: PPUSH
51095: CALL_OW 1
51099: ST_TO_ADDR
// Attack ( tmp ) ;
51100: LD_VAR 0 3
51104: PPUSH
51105: CALL 123788 0 1
// exit ;
51109: POP
51110: POP
51111: GO 51117
// end ; end ;
51113: GO 51043
51115: POP
51116: POP
// end ;
51117: LD_VAR 0 1
51121: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
51122: LD_INT 0
51124: PPUSH
51125: PPUSH
51126: PPUSH
51127: PPUSH
51128: PPUSH
51129: PPUSH
51130: PPUSH
// if not mc_bases then
51131: LD_EXP 116
51135: NOT
51136: IFFALSE 51140
// exit ;
51138: GO 51997
// for i = 1 to mc_bases do
51140: LD_ADDR_VAR 0 2
51144: PUSH
51145: DOUBLE
51146: LD_INT 1
51148: DEC
51149: ST_TO_ADDR
51150: LD_EXP 116
51154: PUSH
51155: FOR_TO
51156: IFFALSE 51995
// begin if not mc_bases [ i ] then
51158: LD_EXP 116
51162: PUSH
51163: LD_VAR 0 2
51167: ARRAY
51168: NOT
51169: IFFALSE 51173
// continue ;
51171: GO 51155
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
51173: LD_ADDR_VAR 0 7
51177: PUSH
51178: LD_EXP 116
51182: PUSH
51183: LD_VAR 0 2
51187: ARRAY
51188: PUSH
51189: LD_INT 1
51191: ARRAY
51192: PPUSH
51193: CALL 67671 0 1
51197: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
51198: LD_ADDR_EXP 139
51202: PUSH
51203: LD_EXP 139
51207: PPUSH
51208: LD_VAR 0 2
51212: PPUSH
51213: LD_EXP 116
51217: PUSH
51218: LD_VAR 0 2
51222: ARRAY
51223: PUSH
51224: LD_INT 1
51226: ARRAY
51227: PPUSH
51228: CALL_OW 255
51232: PPUSH
51233: LD_EXP 141
51237: PUSH
51238: LD_VAR 0 2
51242: ARRAY
51243: PPUSH
51244: CALL 67636 0 2
51248: PPUSH
51249: CALL_OW 1
51253: ST_TO_ADDR
// if not mc_scan [ i ] then
51254: LD_EXP 139
51258: PUSH
51259: LD_VAR 0 2
51263: ARRAY
51264: NOT
51265: IFFALSE 51443
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
51267: LD_ADDR_EXP 159
51271: PUSH
51272: LD_EXP 159
51276: PPUSH
51277: LD_VAR 0 2
51281: PPUSH
51282: LD_INT 0
51284: PPUSH
51285: CALL_OW 1
51289: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51290: LD_ADDR_VAR 0 4
51294: PUSH
51295: LD_EXP 116
51299: PUSH
51300: LD_VAR 0 2
51304: ARRAY
51305: PPUSH
51306: LD_INT 2
51308: PUSH
51309: LD_INT 25
51311: PUSH
51312: LD_INT 5
51314: PUSH
51315: EMPTY
51316: LIST
51317: LIST
51318: PUSH
51319: LD_INT 25
51321: PUSH
51322: LD_INT 8
51324: PUSH
51325: EMPTY
51326: LIST
51327: LIST
51328: PUSH
51329: LD_INT 25
51331: PUSH
51332: LD_INT 9
51334: PUSH
51335: EMPTY
51336: LIST
51337: LIST
51338: PUSH
51339: EMPTY
51340: LIST
51341: LIST
51342: LIST
51343: LIST
51344: PPUSH
51345: CALL_OW 72
51349: ST_TO_ADDR
// if not tmp then
51350: LD_VAR 0 4
51354: NOT
51355: IFFALSE 51359
// continue ;
51357: GO 51155
// for j in tmp do
51359: LD_ADDR_VAR 0 3
51363: PUSH
51364: LD_VAR 0 4
51368: PUSH
51369: FOR_IN
51370: IFFALSE 51441
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
51372: LD_VAR 0 3
51376: PPUSH
51377: CALL_OW 310
51381: PPUSH
51382: CALL_OW 266
51386: PUSH
51387: LD_INT 5
51389: EQUAL
51390: PUSH
51391: LD_VAR 0 3
51395: PPUSH
51396: CALL_OW 257
51400: PUSH
51401: LD_INT 1
51403: EQUAL
51404: AND
51405: PUSH
51406: LD_VAR 0 3
51410: PPUSH
51411: CALL_OW 459
51415: NOT
51416: AND
51417: PUSH
51418: LD_VAR 0 7
51422: AND
51423: IFFALSE 51439
// ComChangeProfession ( j , class ) ;
51425: LD_VAR 0 3
51429: PPUSH
51430: LD_VAR 0 7
51434: PPUSH
51435: CALL_OW 123
51439: GO 51369
51441: POP
51442: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
51443: LD_EXP 139
51447: PUSH
51448: LD_VAR 0 2
51452: ARRAY
51453: PUSH
51454: LD_EXP 159
51458: PUSH
51459: LD_VAR 0 2
51463: ARRAY
51464: NOT
51465: AND
51466: PUSH
51467: LD_EXP 138
51471: PUSH
51472: LD_VAR 0 2
51476: ARRAY
51477: NOT
51478: AND
51479: PUSH
51480: LD_EXP 116
51484: PUSH
51485: LD_VAR 0 2
51489: ARRAY
51490: PPUSH
51491: LD_INT 50
51493: PUSH
51494: EMPTY
51495: LIST
51496: PUSH
51497: LD_INT 2
51499: PUSH
51500: LD_INT 30
51502: PUSH
51503: LD_INT 32
51505: PUSH
51506: EMPTY
51507: LIST
51508: LIST
51509: PUSH
51510: LD_INT 30
51512: PUSH
51513: LD_INT 33
51515: PUSH
51516: EMPTY
51517: LIST
51518: LIST
51519: PUSH
51520: LD_INT 30
51522: PUSH
51523: LD_INT 4
51525: PUSH
51526: EMPTY
51527: LIST
51528: LIST
51529: PUSH
51530: LD_INT 30
51532: PUSH
51533: LD_INT 5
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: PUSH
51540: EMPTY
51541: LIST
51542: LIST
51543: LIST
51544: LIST
51545: LIST
51546: PUSH
51547: EMPTY
51548: LIST
51549: LIST
51550: PPUSH
51551: CALL_OW 72
51555: PUSH
51556: LD_INT 4
51558: LESS
51559: PUSH
51560: LD_EXP 116
51564: PUSH
51565: LD_VAR 0 2
51569: ARRAY
51570: PPUSH
51571: LD_INT 3
51573: PUSH
51574: LD_INT 24
51576: PUSH
51577: LD_INT 1000
51579: PUSH
51580: EMPTY
51581: LIST
51582: LIST
51583: PUSH
51584: EMPTY
51585: LIST
51586: LIST
51587: PUSH
51588: LD_INT 2
51590: PUSH
51591: LD_INT 30
51593: PUSH
51594: LD_INT 0
51596: PUSH
51597: EMPTY
51598: LIST
51599: LIST
51600: PUSH
51601: LD_INT 30
51603: PUSH
51604: LD_INT 1
51606: PUSH
51607: EMPTY
51608: LIST
51609: LIST
51610: PUSH
51611: EMPTY
51612: LIST
51613: LIST
51614: LIST
51615: PUSH
51616: EMPTY
51617: LIST
51618: LIST
51619: PPUSH
51620: CALL_OW 72
51624: OR
51625: AND
51626: IFFALSE 51877
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51628: LD_ADDR_EXP 159
51632: PUSH
51633: LD_EXP 159
51637: PPUSH
51638: LD_VAR 0 2
51642: PPUSH
51643: LD_INT 1
51645: PPUSH
51646: CALL_OW 1
51650: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
51651: LD_ADDR_VAR 0 4
51655: PUSH
51656: LD_EXP 116
51660: PUSH
51661: LD_VAR 0 2
51665: ARRAY
51666: PPUSH
51667: LD_INT 2
51669: PUSH
51670: LD_INT 25
51672: PUSH
51673: LD_INT 1
51675: PUSH
51676: EMPTY
51677: LIST
51678: LIST
51679: PUSH
51680: LD_INT 25
51682: PUSH
51683: LD_INT 5
51685: PUSH
51686: EMPTY
51687: LIST
51688: LIST
51689: PUSH
51690: LD_INT 25
51692: PUSH
51693: LD_INT 8
51695: PUSH
51696: EMPTY
51697: LIST
51698: LIST
51699: PUSH
51700: LD_INT 25
51702: PUSH
51703: LD_INT 9
51705: PUSH
51706: EMPTY
51707: LIST
51708: LIST
51709: PUSH
51710: EMPTY
51711: LIST
51712: LIST
51713: LIST
51714: LIST
51715: LIST
51716: PPUSH
51717: CALL_OW 72
51721: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
51722: LD_ADDR_VAR 0 4
51726: PUSH
51727: LD_VAR 0 4
51731: PUSH
51732: LD_VAR 0 4
51736: PPUSH
51737: LD_INT 18
51739: PPUSH
51740: CALL 100140 0 2
51744: DIFF
51745: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
51746: LD_VAR 0 4
51750: NOT
51751: PUSH
51752: LD_EXP 116
51756: PUSH
51757: LD_VAR 0 2
51761: ARRAY
51762: PPUSH
51763: LD_INT 2
51765: PUSH
51766: LD_INT 30
51768: PUSH
51769: LD_INT 4
51771: PUSH
51772: EMPTY
51773: LIST
51774: LIST
51775: PUSH
51776: LD_INT 30
51778: PUSH
51779: LD_INT 5
51781: PUSH
51782: EMPTY
51783: LIST
51784: LIST
51785: PUSH
51786: EMPTY
51787: LIST
51788: LIST
51789: LIST
51790: PPUSH
51791: CALL_OW 72
51795: NOT
51796: AND
51797: IFFALSE 51859
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
51799: LD_ADDR_VAR 0 4
51803: PUSH
51804: LD_EXP 116
51808: PUSH
51809: LD_VAR 0 2
51813: ARRAY
51814: PPUSH
51815: LD_INT 2
51817: PUSH
51818: LD_INT 25
51820: PUSH
51821: LD_INT 2
51823: PUSH
51824: EMPTY
51825: LIST
51826: LIST
51827: PUSH
51828: LD_INT 25
51830: PUSH
51831: LD_INT 3
51833: PUSH
51834: EMPTY
51835: LIST
51836: LIST
51837: PUSH
51838: LD_INT 25
51840: PUSH
51841: LD_INT 4
51843: PUSH
51844: EMPTY
51845: LIST
51846: LIST
51847: PUSH
51848: EMPTY
51849: LIST
51850: LIST
51851: LIST
51852: LIST
51853: PPUSH
51854: CALL_OW 72
51858: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
51859: LD_VAR 0 2
51863: PPUSH
51864: LD_VAR 0 4
51868: PPUSH
51869: CALL 128497 0 2
// exit ;
51873: POP
51874: POP
51875: GO 51997
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
51877: LD_EXP 139
51881: PUSH
51882: LD_VAR 0 2
51886: ARRAY
51887: PUSH
51888: LD_EXP 159
51892: PUSH
51893: LD_VAR 0 2
51897: ARRAY
51898: NOT
51899: AND
51900: PUSH
51901: LD_EXP 138
51905: PUSH
51906: LD_VAR 0 2
51910: ARRAY
51911: AND
51912: IFFALSE 51993
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
51914: LD_ADDR_EXP 159
51918: PUSH
51919: LD_EXP 159
51923: PPUSH
51924: LD_VAR 0 2
51928: PPUSH
51929: LD_INT 1
51931: PPUSH
51932: CALL_OW 1
51936: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
51937: LD_ADDR_VAR 0 4
51941: PUSH
51942: LD_EXP 138
51946: PUSH
51947: LD_VAR 0 2
51951: ARRAY
51952: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
51953: LD_ADDR_EXP 138
51957: PUSH
51958: LD_EXP 138
51962: PPUSH
51963: LD_VAR 0 2
51967: PPUSH
51968: EMPTY
51969: PPUSH
51970: CALL_OW 1
51974: ST_TO_ADDR
// Defend ( i , tmp ) ;
51975: LD_VAR 0 2
51979: PPUSH
51980: LD_VAR 0 4
51984: PPUSH
51985: CALL 129093 0 2
// exit ;
51989: POP
51990: POP
51991: GO 51997
// end ; end ;
51993: GO 51155
51995: POP
51996: POP
// end ;
51997: LD_VAR 0 1
52001: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
52002: LD_INT 0
52004: PPUSH
52005: PPUSH
52006: PPUSH
52007: PPUSH
52008: PPUSH
52009: PPUSH
52010: PPUSH
52011: PPUSH
52012: PPUSH
52013: PPUSH
52014: PPUSH
// if not mc_bases then
52015: LD_EXP 116
52019: NOT
52020: IFFALSE 52024
// exit ;
52022: GO 53111
// for i = 1 to mc_bases do
52024: LD_ADDR_VAR 0 2
52028: PUSH
52029: DOUBLE
52030: LD_INT 1
52032: DEC
52033: ST_TO_ADDR
52034: LD_EXP 116
52038: PUSH
52039: FOR_TO
52040: IFFALSE 53109
// begin tmp := mc_lab [ i ] ;
52042: LD_ADDR_VAR 0 6
52046: PUSH
52047: LD_EXP 149
52051: PUSH
52052: LD_VAR 0 2
52056: ARRAY
52057: ST_TO_ADDR
// if not tmp then
52058: LD_VAR 0 6
52062: NOT
52063: IFFALSE 52067
// continue ;
52065: GO 52039
// idle_lab := 0 ;
52067: LD_ADDR_VAR 0 11
52071: PUSH
52072: LD_INT 0
52074: ST_TO_ADDR
// for j in tmp do
52075: LD_ADDR_VAR 0 3
52079: PUSH
52080: LD_VAR 0 6
52084: PUSH
52085: FOR_IN
52086: IFFALSE 53105
// begin researching := false ;
52088: LD_ADDR_VAR 0 10
52092: PUSH
52093: LD_INT 0
52095: ST_TO_ADDR
// side := GetSide ( j ) ;
52096: LD_ADDR_VAR 0 4
52100: PUSH
52101: LD_VAR 0 3
52105: PPUSH
52106: CALL_OW 255
52110: ST_TO_ADDR
// if not mc_tech [ side ] then
52111: LD_EXP 143
52115: PUSH
52116: LD_VAR 0 4
52120: ARRAY
52121: NOT
52122: IFFALSE 52126
// continue ;
52124: GO 52085
// if BuildingStatus ( j ) = bs_idle then
52126: LD_VAR 0 3
52130: PPUSH
52131: CALL_OW 461
52135: PUSH
52136: LD_INT 2
52138: EQUAL
52139: IFFALSE 52327
// begin if idle_lab and UnitsInside ( j ) < 6 then
52141: LD_VAR 0 11
52145: PUSH
52146: LD_VAR 0 3
52150: PPUSH
52151: CALL_OW 313
52155: PUSH
52156: LD_INT 6
52158: LESS
52159: AND
52160: IFFALSE 52231
// begin tmp2 := UnitsInside ( idle_lab ) ;
52162: LD_ADDR_VAR 0 9
52166: PUSH
52167: LD_VAR 0 11
52171: PPUSH
52172: CALL_OW 313
52176: ST_TO_ADDR
// if tmp2 then
52177: LD_VAR 0 9
52181: IFFALSE 52223
// for x in tmp2 do
52183: LD_ADDR_VAR 0 7
52187: PUSH
52188: LD_VAR 0 9
52192: PUSH
52193: FOR_IN
52194: IFFALSE 52221
// begin ComExitBuilding ( x ) ;
52196: LD_VAR 0 7
52200: PPUSH
52201: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
52205: LD_VAR 0 7
52209: PPUSH
52210: LD_VAR 0 3
52214: PPUSH
52215: CALL_OW 180
// end ;
52219: GO 52193
52221: POP
52222: POP
// idle_lab := 0 ;
52223: LD_ADDR_VAR 0 11
52227: PUSH
52228: LD_INT 0
52230: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
52231: LD_ADDR_VAR 0 5
52235: PUSH
52236: LD_EXP 143
52240: PUSH
52241: LD_VAR 0 4
52245: ARRAY
52246: PUSH
52247: FOR_IN
52248: IFFALSE 52308
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
52250: LD_VAR 0 3
52254: PPUSH
52255: LD_VAR 0 5
52259: PPUSH
52260: CALL_OW 430
52264: PUSH
52265: LD_VAR 0 4
52269: PPUSH
52270: LD_VAR 0 5
52274: PPUSH
52275: CALL 66741 0 2
52279: AND
52280: IFFALSE 52306
// begin researching := true ;
52282: LD_ADDR_VAR 0 10
52286: PUSH
52287: LD_INT 1
52289: ST_TO_ADDR
// ComResearch ( j , t ) ;
52290: LD_VAR 0 3
52294: PPUSH
52295: LD_VAR 0 5
52299: PPUSH
52300: CALL_OW 124
// break ;
52304: GO 52308
// end ;
52306: GO 52247
52308: POP
52309: POP
// if not researching then
52310: LD_VAR 0 10
52314: NOT
52315: IFFALSE 52327
// idle_lab := j ;
52317: LD_ADDR_VAR 0 11
52321: PUSH
52322: LD_VAR 0 3
52326: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
52327: LD_VAR 0 3
52331: PPUSH
52332: CALL_OW 461
52336: PUSH
52337: LD_INT 10
52339: EQUAL
52340: IFFALSE 52928
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
52342: LD_EXP 145
52346: PUSH
52347: LD_VAR 0 2
52351: ARRAY
52352: NOT
52353: PUSH
52354: LD_EXP 146
52358: PUSH
52359: LD_VAR 0 2
52363: ARRAY
52364: NOT
52365: AND
52366: PUSH
52367: LD_EXP 143
52371: PUSH
52372: LD_VAR 0 4
52376: ARRAY
52377: PUSH
52378: LD_INT 1
52380: GREATER
52381: AND
52382: IFFALSE 52513
// begin ComCancel ( j ) ;
52384: LD_VAR 0 3
52388: PPUSH
52389: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
52393: LD_ADDR_EXP 143
52397: PUSH
52398: LD_EXP 143
52402: PPUSH
52403: LD_VAR 0 4
52407: PPUSH
52408: LD_EXP 143
52412: PUSH
52413: LD_VAR 0 4
52417: ARRAY
52418: PPUSH
52419: LD_EXP 143
52423: PUSH
52424: LD_VAR 0 4
52428: ARRAY
52429: PUSH
52430: LD_INT 1
52432: MINUS
52433: PPUSH
52434: LD_EXP 143
52438: PUSH
52439: LD_VAR 0 4
52443: ARRAY
52444: PPUSH
52445: LD_INT 0
52447: PPUSH
52448: CALL 70289 0 4
52452: PPUSH
52453: CALL_OW 1
52457: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
52458: LD_ADDR_EXP 143
52462: PUSH
52463: LD_EXP 143
52467: PPUSH
52468: LD_VAR 0 4
52472: PPUSH
52473: LD_EXP 143
52477: PUSH
52478: LD_VAR 0 4
52482: ARRAY
52483: PPUSH
52484: LD_EXP 143
52488: PUSH
52489: LD_VAR 0 4
52493: ARRAY
52494: PPUSH
52495: LD_INT 1
52497: PPUSH
52498: LD_INT 0
52500: PPUSH
52501: CALL 70289 0 4
52505: PPUSH
52506: CALL_OW 1
52510: ST_TO_ADDR
// continue ;
52511: GO 52085
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
52513: LD_EXP 145
52517: PUSH
52518: LD_VAR 0 2
52522: ARRAY
52523: PUSH
52524: LD_EXP 146
52528: PUSH
52529: LD_VAR 0 2
52533: ARRAY
52534: NOT
52535: AND
52536: IFFALSE 52663
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
52538: LD_ADDR_EXP 146
52542: PUSH
52543: LD_EXP 146
52547: PPUSH
52548: LD_VAR 0 2
52552: PUSH
52553: LD_EXP 146
52557: PUSH
52558: LD_VAR 0 2
52562: ARRAY
52563: PUSH
52564: LD_INT 1
52566: PLUS
52567: PUSH
52568: EMPTY
52569: LIST
52570: LIST
52571: PPUSH
52572: LD_EXP 145
52576: PUSH
52577: LD_VAR 0 2
52581: ARRAY
52582: PUSH
52583: LD_INT 1
52585: ARRAY
52586: PPUSH
52587: CALL 70871 0 3
52591: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
52592: LD_EXP 145
52596: PUSH
52597: LD_VAR 0 2
52601: ARRAY
52602: PUSH
52603: LD_INT 1
52605: ARRAY
52606: PPUSH
52607: LD_INT 112
52609: PPUSH
52610: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
52614: LD_ADDR_VAR 0 9
52618: PUSH
52619: LD_EXP 145
52623: PUSH
52624: LD_VAR 0 2
52628: ARRAY
52629: PPUSH
52630: LD_INT 1
52632: PPUSH
52633: CALL_OW 3
52637: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
52638: LD_ADDR_EXP 145
52642: PUSH
52643: LD_EXP 145
52647: PPUSH
52648: LD_VAR 0 2
52652: PPUSH
52653: LD_VAR 0 9
52657: PPUSH
52658: CALL_OW 1
52662: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
52663: LD_EXP 145
52667: PUSH
52668: LD_VAR 0 2
52672: ARRAY
52673: PUSH
52674: LD_EXP 146
52678: PUSH
52679: LD_VAR 0 2
52683: ARRAY
52684: AND
52685: PUSH
52686: LD_EXP 146
52690: PUSH
52691: LD_VAR 0 2
52695: ARRAY
52696: PUSH
52697: LD_INT 1
52699: ARRAY
52700: PPUSH
52701: CALL_OW 310
52705: NOT
52706: AND
52707: PUSH
52708: LD_VAR 0 3
52712: PPUSH
52713: CALL_OW 313
52717: PUSH
52718: LD_INT 6
52720: EQUAL
52721: AND
52722: IFFALSE 52778
// begin tmp2 := UnitsInside ( j ) ;
52724: LD_ADDR_VAR 0 9
52728: PUSH
52729: LD_VAR 0 3
52733: PPUSH
52734: CALL_OW 313
52738: ST_TO_ADDR
// if tmp2 = 6 then
52739: LD_VAR 0 9
52743: PUSH
52744: LD_INT 6
52746: EQUAL
52747: IFFALSE 52778
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
52749: LD_VAR 0 9
52753: PUSH
52754: LD_INT 1
52756: ARRAY
52757: PPUSH
52758: LD_INT 112
52760: PPUSH
52761: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
52765: LD_VAR 0 9
52769: PUSH
52770: LD_INT 1
52772: ARRAY
52773: PPUSH
52774: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
52778: LD_EXP 146
52782: PUSH
52783: LD_VAR 0 2
52787: ARRAY
52788: PUSH
52789: LD_EXP 146
52793: PUSH
52794: LD_VAR 0 2
52798: ARRAY
52799: PUSH
52800: LD_INT 1
52802: ARRAY
52803: PPUSH
52804: CALL_OW 314
52808: NOT
52809: AND
52810: PUSH
52811: LD_EXP 146
52815: PUSH
52816: LD_VAR 0 2
52820: ARRAY
52821: PUSH
52822: LD_INT 1
52824: ARRAY
52825: PPUSH
52826: CALL_OW 310
52830: NOT
52831: AND
52832: IFFALSE 52858
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
52834: LD_EXP 146
52838: PUSH
52839: LD_VAR 0 2
52843: ARRAY
52844: PUSH
52845: LD_INT 1
52847: ARRAY
52848: PPUSH
52849: LD_VAR 0 3
52853: PPUSH
52854: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
52858: LD_EXP 146
52862: PUSH
52863: LD_VAR 0 2
52867: ARRAY
52868: PUSH
52869: LD_INT 1
52871: ARRAY
52872: PPUSH
52873: CALL_OW 310
52877: PUSH
52878: LD_EXP 146
52882: PUSH
52883: LD_VAR 0 2
52887: ARRAY
52888: PUSH
52889: LD_INT 1
52891: ARRAY
52892: PPUSH
52893: CALL_OW 310
52897: PPUSH
52898: CALL_OW 461
52902: PUSH
52903: LD_INT 3
52905: NONEQUAL
52906: AND
52907: IFFALSE 52928
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
52909: LD_EXP 146
52913: PUSH
52914: LD_VAR 0 2
52918: ARRAY
52919: PUSH
52920: LD_INT 1
52922: ARRAY
52923: PPUSH
52924: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
52928: LD_VAR 0 3
52932: PPUSH
52933: CALL_OW 461
52937: PUSH
52938: LD_INT 6
52940: EQUAL
52941: PUSH
52942: LD_VAR 0 6
52946: PUSH
52947: LD_INT 1
52949: GREATER
52950: AND
52951: IFFALSE 53103
// begin sci := [ ] ;
52953: LD_ADDR_VAR 0 8
52957: PUSH
52958: EMPTY
52959: ST_TO_ADDR
// for x in ( tmp diff j ) do
52960: LD_ADDR_VAR 0 7
52964: PUSH
52965: LD_VAR 0 6
52969: PUSH
52970: LD_VAR 0 3
52974: DIFF
52975: PUSH
52976: FOR_IN
52977: IFFALSE 53029
// begin if sci = 6 then
52979: LD_VAR 0 8
52983: PUSH
52984: LD_INT 6
52986: EQUAL
52987: IFFALSE 52991
// break ;
52989: GO 53029
// if BuildingStatus ( x ) = bs_idle then
52991: LD_VAR 0 7
52995: PPUSH
52996: CALL_OW 461
53000: PUSH
53001: LD_INT 2
53003: EQUAL
53004: IFFALSE 53027
// sci := sci ^ UnitsInside ( x ) ;
53006: LD_ADDR_VAR 0 8
53010: PUSH
53011: LD_VAR 0 8
53015: PUSH
53016: LD_VAR 0 7
53020: PPUSH
53021: CALL_OW 313
53025: ADD
53026: ST_TO_ADDR
// end ;
53027: GO 52976
53029: POP
53030: POP
// if not sci then
53031: LD_VAR 0 8
53035: NOT
53036: IFFALSE 53040
// continue ;
53038: GO 52085
// for x in sci do
53040: LD_ADDR_VAR 0 7
53044: PUSH
53045: LD_VAR 0 8
53049: PUSH
53050: FOR_IN
53051: IFFALSE 53101
// if IsInUnit ( x ) and not HasTask ( x ) then
53053: LD_VAR 0 7
53057: PPUSH
53058: CALL_OW 310
53062: PUSH
53063: LD_VAR 0 7
53067: PPUSH
53068: CALL_OW 314
53072: NOT
53073: AND
53074: IFFALSE 53099
// begin ComExitBuilding ( x ) ;
53076: LD_VAR 0 7
53080: PPUSH
53081: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
53085: LD_VAR 0 7
53089: PPUSH
53090: LD_VAR 0 3
53094: PPUSH
53095: CALL_OW 180
// end ;
53099: GO 53050
53101: POP
53102: POP
// end ; end ;
53103: GO 52085
53105: POP
53106: POP
// end ;
53107: GO 52039
53109: POP
53110: POP
// end ;
53111: LD_VAR 0 1
53115: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
53116: LD_INT 0
53118: PPUSH
53119: PPUSH
// if not mc_bases then
53120: LD_EXP 116
53124: NOT
53125: IFFALSE 53129
// exit ;
53127: GO 53210
// for i = 1 to mc_bases do
53129: LD_ADDR_VAR 0 2
53133: PUSH
53134: DOUBLE
53135: LD_INT 1
53137: DEC
53138: ST_TO_ADDR
53139: LD_EXP 116
53143: PUSH
53144: FOR_TO
53145: IFFALSE 53208
// if mc_mines [ i ] and mc_miners [ i ] then
53147: LD_EXP 129
53151: PUSH
53152: LD_VAR 0 2
53156: ARRAY
53157: PUSH
53158: LD_EXP 130
53162: PUSH
53163: LD_VAR 0 2
53167: ARRAY
53168: AND
53169: IFFALSE 53206
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
53171: LD_EXP 130
53175: PUSH
53176: LD_VAR 0 2
53180: ARRAY
53181: PUSH
53182: LD_INT 1
53184: ARRAY
53185: PPUSH
53186: CALL_OW 255
53190: PPUSH
53191: LD_EXP 129
53195: PUSH
53196: LD_VAR 0 2
53200: ARRAY
53201: PPUSH
53202: CALL 67824 0 2
53206: GO 53144
53208: POP
53209: POP
// end ;
53210: LD_VAR 0 1
53214: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
53215: LD_INT 0
53217: PPUSH
53218: PPUSH
53219: PPUSH
53220: PPUSH
53221: PPUSH
53222: PPUSH
53223: PPUSH
53224: PPUSH
// if not mc_bases or not mc_parking then
53225: LD_EXP 116
53229: NOT
53230: PUSH
53231: LD_EXP 140
53235: NOT
53236: OR
53237: IFFALSE 53241
// exit ;
53239: GO 53951
// for i = 1 to mc_bases do
53241: LD_ADDR_VAR 0 2
53245: PUSH
53246: DOUBLE
53247: LD_INT 1
53249: DEC
53250: ST_TO_ADDR
53251: LD_EXP 116
53255: PUSH
53256: FOR_TO
53257: IFFALSE 53949
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
53259: LD_EXP 116
53263: PUSH
53264: LD_VAR 0 2
53268: ARRAY
53269: NOT
53270: PUSH
53271: LD_EXP 140
53275: PUSH
53276: LD_VAR 0 2
53280: ARRAY
53281: NOT
53282: OR
53283: IFFALSE 53287
// continue ;
53285: GO 53256
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
53287: LD_ADDR_VAR 0 5
53291: PUSH
53292: LD_EXP 116
53296: PUSH
53297: LD_VAR 0 2
53301: ARRAY
53302: PUSH
53303: LD_INT 1
53305: ARRAY
53306: PPUSH
53307: CALL_OW 255
53311: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53312: LD_ADDR_VAR 0 6
53316: PUSH
53317: LD_EXP 116
53321: PUSH
53322: LD_VAR 0 2
53326: ARRAY
53327: PPUSH
53328: LD_INT 30
53330: PUSH
53331: LD_INT 3
53333: PUSH
53334: EMPTY
53335: LIST
53336: LIST
53337: PPUSH
53338: CALL_OW 72
53342: ST_TO_ADDR
// if not fac then
53343: LD_VAR 0 6
53347: NOT
53348: IFFALSE 53399
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53350: LD_ADDR_VAR 0 6
53354: PUSH
53355: LD_EXP 116
53359: PUSH
53360: LD_VAR 0 2
53364: ARRAY
53365: PPUSH
53366: LD_INT 2
53368: PUSH
53369: LD_INT 30
53371: PUSH
53372: LD_INT 0
53374: PUSH
53375: EMPTY
53376: LIST
53377: LIST
53378: PUSH
53379: LD_INT 30
53381: PUSH
53382: LD_INT 1
53384: PUSH
53385: EMPTY
53386: LIST
53387: LIST
53388: PUSH
53389: EMPTY
53390: LIST
53391: LIST
53392: LIST
53393: PPUSH
53394: CALL_OW 72
53398: ST_TO_ADDR
// if not fac then
53399: LD_VAR 0 6
53403: NOT
53404: IFFALSE 53408
// continue ;
53406: GO 53256
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53408: LD_ADDR_VAR 0 7
53412: PUSH
53413: LD_EXP 140
53417: PUSH
53418: LD_VAR 0 2
53422: ARRAY
53423: PPUSH
53424: LD_INT 22
53426: PUSH
53427: LD_VAR 0 5
53431: PUSH
53432: EMPTY
53433: LIST
53434: LIST
53435: PUSH
53436: LD_INT 21
53438: PUSH
53439: LD_INT 2
53441: PUSH
53442: EMPTY
53443: LIST
53444: LIST
53445: PUSH
53446: LD_INT 3
53448: PUSH
53449: LD_INT 24
53451: PUSH
53452: LD_INT 1000
53454: PUSH
53455: EMPTY
53456: LIST
53457: LIST
53458: PUSH
53459: EMPTY
53460: LIST
53461: LIST
53462: PUSH
53463: EMPTY
53464: LIST
53465: LIST
53466: LIST
53467: PPUSH
53468: CALL_OW 70
53472: ST_TO_ADDR
// for j in fac do
53473: LD_ADDR_VAR 0 3
53477: PUSH
53478: LD_VAR 0 6
53482: PUSH
53483: FOR_IN
53484: IFFALSE 53565
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
53486: LD_ADDR_VAR 0 7
53490: PUSH
53491: LD_VAR 0 7
53495: PUSH
53496: LD_INT 22
53498: PUSH
53499: LD_VAR 0 5
53503: PUSH
53504: EMPTY
53505: LIST
53506: LIST
53507: PUSH
53508: LD_INT 91
53510: PUSH
53511: LD_VAR 0 3
53515: PUSH
53516: LD_INT 15
53518: PUSH
53519: EMPTY
53520: LIST
53521: LIST
53522: LIST
53523: PUSH
53524: LD_INT 21
53526: PUSH
53527: LD_INT 2
53529: PUSH
53530: EMPTY
53531: LIST
53532: LIST
53533: PUSH
53534: LD_INT 3
53536: PUSH
53537: LD_INT 24
53539: PUSH
53540: LD_INT 1000
53542: PUSH
53543: EMPTY
53544: LIST
53545: LIST
53546: PUSH
53547: EMPTY
53548: LIST
53549: LIST
53550: PUSH
53551: EMPTY
53552: LIST
53553: LIST
53554: LIST
53555: LIST
53556: PPUSH
53557: CALL_OW 69
53561: UNION
53562: ST_TO_ADDR
53563: GO 53483
53565: POP
53566: POP
// if not vehs then
53567: LD_VAR 0 7
53571: NOT
53572: IFFALSE 53598
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53574: LD_ADDR_EXP 128
53578: PUSH
53579: LD_EXP 128
53583: PPUSH
53584: LD_VAR 0 2
53588: PPUSH
53589: EMPTY
53590: PPUSH
53591: CALL_OW 1
53595: ST_TO_ADDR
// continue ;
53596: GO 53256
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
53598: LD_ADDR_VAR 0 8
53602: PUSH
53603: LD_EXP 116
53607: PUSH
53608: LD_VAR 0 2
53612: ARRAY
53613: PPUSH
53614: LD_INT 30
53616: PUSH
53617: LD_INT 3
53619: PUSH
53620: EMPTY
53621: LIST
53622: LIST
53623: PPUSH
53624: CALL_OW 72
53628: ST_TO_ADDR
// if tmp then
53629: LD_VAR 0 8
53633: IFFALSE 53736
// begin for j in tmp do
53635: LD_ADDR_VAR 0 3
53639: PUSH
53640: LD_VAR 0 8
53644: PUSH
53645: FOR_IN
53646: IFFALSE 53734
// for k in UnitsInside ( j ) do
53648: LD_ADDR_VAR 0 4
53652: PUSH
53653: LD_VAR 0 3
53657: PPUSH
53658: CALL_OW 313
53662: PUSH
53663: FOR_IN
53664: IFFALSE 53730
// if k then
53666: LD_VAR 0 4
53670: IFFALSE 53728
// if not k in mc_repair_vehicle [ i ] then
53672: LD_VAR 0 4
53676: PUSH
53677: LD_EXP 128
53681: PUSH
53682: LD_VAR 0 2
53686: ARRAY
53687: IN
53688: NOT
53689: IFFALSE 53728
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
53691: LD_ADDR_EXP 128
53695: PUSH
53696: LD_EXP 128
53700: PPUSH
53701: LD_VAR 0 2
53705: PPUSH
53706: LD_EXP 128
53710: PUSH
53711: LD_VAR 0 2
53715: ARRAY
53716: PUSH
53717: LD_VAR 0 4
53721: UNION
53722: PPUSH
53723: CALL_OW 1
53727: ST_TO_ADDR
53728: GO 53663
53730: POP
53731: POP
53732: GO 53645
53734: POP
53735: POP
// end ; if not mc_repair_vehicle [ i ] then
53736: LD_EXP 128
53740: PUSH
53741: LD_VAR 0 2
53745: ARRAY
53746: NOT
53747: IFFALSE 53751
// continue ;
53749: GO 53256
// for j in mc_repair_vehicle [ i ] do
53751: LD_ADDR_VAR 0 3
53755: PUSH
53756: LD_EXP 128
53760: PUSH
53761: LD_VAR 0 2
53765: ARRAY
53766: PUSH
53767: FOR_IN
53768: IFFALSE 53945
// begin if GetClass ( j ) <> 3 then
53770: LD_VAR 0 3
53774: PPUSH
53775: CALL_OW 257
53779: PUSH
53780: LD_INT 3
53782: NONEQUAL
53783: IFFALSE 53824
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
53785: LD_ADDR_EXP 128
53789: PUSH
53790: LD_EXP 128
53794: PPUSH
53795: LD_VAR 0 2
53799: PPUSH
53800: LD_EXP 128
53804: PUSH
53805: LD_VAR 0 2
53809: ARRAY
53810: PUSH
53811: LD_VAR 0 3
53815: DIFF
53816: PPUSH
53817: CALL_OW 1
53821: ST_TO_ADDR
// continue ;
53822: GO 53767
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53824: LD_VAR 0 3
53828: PPUSH
53829: CALL_OW 311
53833: NOT
53834: PUSH
53835: LD_VAR 0 3
53839: PUSH
53840: LD_EXP 119
53844: PUSH
53845: LD_VAR 0 2
53849: ARRAY
53850: PUSH
53851: LD_INT 1
53853: ARRAY
53854: IN
53855: NOT
53856: AND
53857: PUSH
53858: LD_VAR 0 3
53862: PUSH
53863: LD_EXP 119
53867: PUSH
53868: LD_VAR 0 2
53872: ARRAY
53873: PUSH
53874: LD_INT 2
53876: ARRAY
53877: IN
53878: NOT
53879: AND
53880: IFFALSE 53943
// begin if IsInUnit ( j ) then
53882: LD_VAR 0 3
53886: PPUSH
53887: CALL_OW 310
53891: IFFALSE 53904
// ComExitBuilding ( j ) else
53893: LD_VAR 0 3
53897: PPUSH
53898: CALL_OW 122
53902: GO 53943
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
53904: LD_VAR 0 3
53908: PPUSH
53909: LD_VAR 0 7
53913: PUSH
53914: LD_INT 1
53916: ARRAY
53917: PPUSH
53918: CALL 104679 0 2
53922: NOT
53923: IFFALSE 53943
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
53925: LD_VAR 0 3
53929: PPUSH
53930: LD_VAR 0 7
53934: PUSH
53935: LD_INT 1
53937: ARRAY
53938: PPUSH
53939: CALL_OW 129
// end ; end ;
53943: GO 53767
53945: POP
53946: POP
// end ;
53947: GO 53256
53949: POP
53950: POP
// end ;
53951: LD_VAR 0 1
53955: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
53956: LD_INT 0
53958: PPUSH
53959: PPUSH
53960: PPUSH
53961: PPUSH
53962: PPUSH
53963: PPUSH
53964: PPUSH
53965: PPUSH
53966: PPUSH
53967: PPUSH
53968: PPUSH
// if not mc_bases then
53969: LD_EXP 116
53973: NOT
53974: IFFALSE 53978
// exit ;
53976: GO 54780
// for i = 1 to mc_bases do
53978: LD_ADDR_VAR 0 2
53982: PUSH
53983: DOUBLE
53984: LD_INT 1
53986: DEC
53987: ST_TO_ADDR
53988: LD_EXP 116
53992: PUSH
53993: FOR_TO
53994: IFFALSE 54778
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
53996: LD_EXP 144
54000: PUSH
54001: LD_VAR 0 2
54005: ARRAY
54006: NOT
54007: PUSH
54008: LD_EXP 119
54012: PUSH
54013: LD_VAR 0 2
54017: ARRAY
54018: PUSH
54019: LD_INT 1
54021: ARRAY
54022: OR
54023: PUSH
54024: LD_EXP 119
54028: PUSH
54029: LD_VAR 0 2
54033: ARRAY
54034: PUSH
54035: LD_INT 2
54037: ARRAY
54038: OR
54039: PUSH
54040: LD_EXP 142
54044: PUSH
54045: LD_VAR 0 2
54049: ARRAY
54050: PPUSH
54051: LD_INT 1
54053: PPUSH
54054: CALL_OW 325
54058: NOT
54059: OR
54060: PUSH
54061: LD_EXP 139
54065: PUSH
54066: LD_VAR 0 2
54070: ARRAY
54071: OR
54072: IFFALSE 54076
// continue ;
54074: GO 53993
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
54076: LD_ADDR_VAR 0 8
54080: PUSH
54081: LD_EXP 116
54085: PUSH
54086: LD_VAR 0 2
54090: ARRAY
54091: PPUSH
54092: LD_INT 25
54094: PUSH
54095: LD_INT 4
54097: PUSH
54098: EMPTY
54099: LIST
54100: LIST
54101: PUSH
54102: LD_INT 50
54104: PUSH
54105: EMPTY
54106: LIST
54107: PUSH
54108: LD_INT 3
54110: PUSH
54111: LD_INT 60
54113: PUSH
54114: EMPTY
54115: LIST
54116: PUSH
54117: EMPTY
54118: LIST
54119: LIST
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: LIST
54125: PPUSH
54126: CALL_OW 72
54130: PUSH
54131: LD_EXP 120
54135: PUSH
54136: LD_VAR 0 2
54140: ARRAY
54141: DIFF
54142: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54143: LD_ADDR_VAR 0 9
54147: PUSH
54148: LD_EXP 116
54152: PUSH
54153: LD_VAR 0 2
54157: ARRAY
54158: PPUSH
54159: LD_INT 2
54161: PUSH
54162: LD_INT 30
54164: PUSH
54165: LD_INT 0
54167: PUSH
54168: EMPTY
54169: LIST
54170: LIST
54171: PUSH
54172: LD_INT 30
54174: PUSH
54175: LD_INT 1
54177: PUSH
54178: EMPTY
54179: LIST
54180: LIST
54181: PUSH
54182: EMPTY
54183: LIST
54184: LIST
54185: LIST
54186: PPUSH
54187: CALL_OW 72
54191: ST_TO_ADDR
// if not tmp or not dep then
54192: LD_VAR 0 8
54196: NOT
54197: PUSH
54198: LD_VAR 0 9
54202: NOT
54203: OR
54204: IFFALSE 54208
// continue ;
54206: GO 53993
// side := GetSide ( tmp [ 1 ] ) ;
54208: LD_ADDR_VAR 0 11
54212: PUSH
54213: LD_VAR 0 8
54217: PUSH
54218: LD_INT 1
54220: ARRAY
54221: PPUSH
54222: CALL_OW 255
54226: ST_TO_ADDR
// dep := dep [ 1 ] ;
54227: LD_ADDR_VAR 0 9
54231: PUSH
54232: LD_VAR 0 9
54236: PUSH
54237: LD_INT 1
54239: ARRAY
54240: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
54241: LD_ADDR_VAR 0 7
54245: PUSH
54246: LD_EXP 144
54250: PUSH
54251: LD_VAR 0 2
54255: ARRAY
54256: PPUSH
54257: LD_INT 22
54259: PUSH
54260: LD_INT 0
54262: PUSH
54263: EMPTY
54264: LIST
54265: LIST
54266: PUSH
54267: LD_INT 25
54269: PUSH
54270: LD_INT 12
54272: PUSH
54273: EMPTY
54274: LIST
54275: LIST
54276: PUSH
54277: EMPTY
54278: LIST
54279: LIST
54280: PPUSH
54281: CALL_OW 70
54285: PUSH
54286: LD_INT 22
54288: PUSH
54289: LD_INT 0
54291: PUSH
54292: EMPTY
54293: LIST
54294: LIST
54295: PUSH
54296: LD_INT 25
54298: PUSH
54299: LD_INT 12
54301: PUSH
54302: EMPTY
54303: LIST
54304: LIST
54305: PUSH
54306: LD_INT 91
54308: PUSH
54309: LD_VAR 0 9
54313: PUSH
54314: LD_INT 20
54316: PUSH
54317: EMPTY
54318: LIST
54319: LIST
54320: LIST
54321: PUSH
54322: EMPTY
54323: LIST
54324: LIST
54325: LIST
54326: PPUSH
54327: CALL_OW 69
54331: UNION
54332: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
54333: LD_ADDR_VAR 0 10
54337: PUSH
54338: LD_EXP 144
54342: PUSH
54343: LD_VAR 0 2
54347: ARRAY
54348: PPUSH
54349: LD_INT 81
54351: PUSH
54352: LD_VAR 0 11
54356: PUSH
54357: EMPTY
54358: LIST
54359: LIST
54360: PPUSH
54361: CALL_OW 70
54365: ST_TO_ADDR
// if not apes or danger_at_area then
54366: LD_VAR 0 7
54370: NOT
54371: PUSH
54372: LD_VAR 0 10
54376: OR
54377: IFFALSE 54427
// begin if mc_taming [ i ] then
54379: LD_EXP 147
54383: PUSH
54384: LD_VAR 0 2
54388: ARRAY
54389: IFFALSE 54425
// begin MC_Reset ( i , 121 ) ;
54391: LD_VAR 0 2
54395: PPUSH
54396: LD_INT 121
54398: PPUSH
54399: CALL 39413 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54403: LD_ADDR_EXP 147
54407: PUSH
54408: LD_EXP 147
54412: PPUSH
54413: LD_VAR 0 2
54417: PPUSH
54418: EMPTY
54419: PPUSH
54420: CALL_OW 1
54424: ST_TO_ADDR
// end ; continue ;
54425: GO 53993
// end ; for j in tmp do
54427: LD_ADDR_VAR 0 3
54431: PUSH
54432: LD_VAR 0 8
54436: PUSH
54437: FOR_IN
54438: IFFALSE 54774
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
54440: LD_VAR 0 3
54444: PUSH
54445: LD_EXP 147
54449: PUSH
54450: LD_VAR 0 2
54454: ARRAY
54455: IN
54456: NOT
54457: PUSH
54458: LD_EXP 147
54462: PUSH
54463: LD_VAR 0 2
54467: ARRAY
54468: PUSH
54469: LD_INT 3
54471: LESS
54472: AND
54473: IFFALSE 54531
// begin SetTag ( j , 121 ) ;
54475: LD_VAR 0 3
54479: PPUSH
54480: LD_INT 121
54482: PPUSH
54483: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
54487: LD_ADDR_EXP 147
54491: PUSH
54492: LD_EXP 147
54496: PPUSH
54497: LD_VAR 0 2
54501: PUSH
54502: LD_EXP 147
54506: PUSH
54507: LD_VAR 0 2
54511: ARRAY
54512: PUSH
54513: LD_INT 1
54515: PLUS
54516: PUSH
54517: EMPTY
54518: LIST
54519: LIST
54520: PPUSH
54521: LD_VAR 0 3
54525: PPUSH
54526: CALL 70871 0 3
54530: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
54531: LD_VAR 0 3
54535: PUSH
54536: LD_EXP 147
54540: PUSH
54541: LD_VAR 0 2
54545: ARRAY
54546: IN
54547: IFFALSE 54772
// begin if GetClass ( j ) <> 4 then
54549: LD_VAR 0 3
54553: PPUSH
54554: CALL_OW 257
54558: PUSH
54559: LD_INT 4
54561: NONEQUAL
54562: IFFALSE 54615
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
54564: LD_ADDR_EXP 147
54568: PUSH
54569: LD_EXP 147
54573: PPUSH
54574: LD_VAR 0 2
54578: PPUSH
54579: LD_EXP 147
54583: PUSH
54584: LD_VAR 0 2
54588: ARRAY
54589: PUSH
54590: LD_VAR 0 3
54594: DIFF
54595: PPUSH
54596: CALL_OW 1
54600: ST_TO_ADDR
// SetTag ( j , 0 ) ;
54601: LD_VAR 0 3
54605: PPUSH
54606: LD_INT 0
54608: PPUSH
54609: CALL_OW 109
// continue ;
54613: GO 54437
// end ; if IsInUnit ( j ) then
54615: LD_VAR 0 3
54619: PPUSH
54620: CALL_OW 310
54624: IFFALSE 54635
// ComExitBuilding ( j ) ;
54626: LD_VAR 0 3
54630: PPUSH
54631: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
54635: LD_ADDR_VAR 0 6
54639: PUSH
54640: LD_VAR 0 7
54644: PPUSH
54645: LD_VAR 0 3
54649: PPUSH
54650: CALL_OW 74
54654: ST_TO_ADDR
// if not ape then
54655: LD_VAR 0 6
54659: NOT
54660: IFFALSE 54664
// break ;
54662: GO 54774
// x := GetX ( ape ) ;
54664: LD_ADDR_VAR 0 4
54668: PUSH
54669: LD_VAR 0 6
54673: PPUSH
54674: CALL_OW 250
54678: ST_TO_ADDR
// y := GetY ( ape ) ;
54679: LD_ADDR_VAR 0 5
54683: PUSH
54684: LD_VAR 0 6
54688: PPUSH
54689: CALL_OW 251
54693: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
54694: LD_VAR 0 4
54698: PPUSH
54699: LD_VAR 0 5
54703: PPUSH
54704: CALL_OW 488
54708: NOT
54709: PUSH
54710: LD_VAR 0 11
54714: PPUSH
54715: LD_VAR 0 4
54719: PPUSH
54720: LD_VAR 0 5
54724: PPUSH
54725: LD_INT 20
54727: PPUSH
54728: CALL 71767 0 4
54732: PUSH
54733: LD_INT 4
54735: ARRAY
54736: OR
54737: IFFALSE 54741
// break ;
54739: GO 54774
// if not HasTask ( j ) then
54741: LD_VAR 0 3
54745: PPUSH
54746: CALL_OW 314
54750: NOT
54751: IFFALSE 54772
// ComTameXY ( j , x , y ) ;
54753: LD_VAR 0 3
54757: PPUSH
54758: LD_VAR 0 4
54762: PPUSH
54763: LD_VAR 0 5
54767: PPUSH
54768: CALL_OW 131
// end ; end ;
54772: GO 54437
54774: POP
54775: POP
// end ;
54776: GO 53993
54778: POP
54779: POP
// end ;
54780: LD_VAR 0 1
54784: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
54785: LD_INT 0
54787: PPUSH
54788: PPUSH
54789: PPUSH
54790: PPUSH
54791: PPUSH
54792: PPUSH
54793: PPUSH
54794: PPUSH
// if not mc_bases then
54795: LD_EXP 116
54799: NOT
54800: IFFALSE 54804
// exit ;
54802: GO 55430
// for i = 1 to mc_bases do
54804: LD_ADDR_VAR 0 2
54808: PUSH
54809: DOUBLE
54810: LD_INT 1
54812: DEC
54813: ST_TO_ADDR
54814: LD_EXP 116
54818: PUSH
54819: FOR_TO
54820: IFFALSE 55428
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
54822: LD_EXP 145
54826: PUSH
54827: LD_VAR 0 2
54831: ARRAY
54832: NOT
54833: PUSH
54834: LD_EXP 145
54838: PUSH
54839: LD_VAR 0 2
54843: ARRAY
54844: PPUSH
54845: LD_INT 25
54847: PUSH
54848: LD_INT 12
54850: PUSH
54851: EMPTY
54852: LIST
54853: LIST
54854: PPUSH
54855: CALL_OW 72
54859: NOT
54860: OR
54861: IFFALSE 54865
// continue ;
54863: GO 54819
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
54865: LD_ADDR_VAR 0 5
54869: PUSH
54870: LD_EXP 145
54874: PUSH
54875: LD_VAR 0 2
54879: ARRAY
54880: PUSH
54881: LD_INT 1
54883: ARRAY
54884: PPUSH
54885: CALL_OW 255
54889: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
54890: LD_VAR 0 5
54894: PPUSH
54895: LD_INT 2
54897: PPUSH
54898: CALL_OW 325
54902: IFFALSE 55155
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
54904: LD_ADDR_VAR 0 4
54908: PUSH
54909: LD_EXP 145
54913: PUSH
54914: LD_VAR 0 2
54918: ARRAY
54919: PPUSH
54920: LD_INT 25
54922: PUSH
54923: LD_INT 16
54925: PUSH
54926: EMPTY
54927: LIST
54928: LIST
54929: PPUSH
54930: CALL_OW 72
54934: ST_TO_ADDR
// if tmp < 6 then
54935: LD_VAR 0 4
54939: PUSH
54940: LD_INT 6
54942: LESS
54943: IFFALSE 55155
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
54945: LD_ADDR_VAR 0 6
54949: PUSH
54950: LD_EXP 116
54954: PUSH
54955: LD_VAR 0 2
54959: ARRAY
54960: PPUSH
54961: LD_INT 2
54963: PUSH
54964: LD_INT 30
54966: PUSH
54967: LD_INT 0
54969: PUSH
54970: EMPTY
54971: LIST
54972: LIST
54973: PUSH
54974: LD_INT 30
54976: PUSH
54977: LD_INT 1
54979: PUSH
54980: EMPTY
54981: LIST
54982: LIST
54983: PUSH
54984: EMPTY
54985: LIST
54986: LIST
54987: LIST
54988: PPUSH
54989: CALL_OW 72
54993: ST_TO_ADDR
// if depot then
54994: LD_VAR 0 6
54998: IFFALSE 55155
// begin selected := 0 ;
55000: LD_ADDR_VAR 0 7
55004: PUSH
55005: LD_INT 0
55007: ST_TO_ADDR
// for j in depot do
55008: LD_ADDR_VAR 0 3
55012: PUSH
55013: LD_VAR 0 6
55017: PUSH
55018: FOR_IN
55019: IFFALSE 55050
// begin if UnitsInside ( j ) < 6 then
55021: LD_VAR 0 3
55025: PPUSH
55026: CALL_OW 313
55030: PUSH
55031: LD_INT 6
55033: LESS
55034: IFFALSE 55048
// begin selected := j ;
55036: LD_ADDR_VAR 0 7
55040: PUSH
55041: LD_VAR 0 3
55045: ST_TO_ADDR
// break ;
55046: GO 55050
// end ; end ;
55048: GO 55018
55050: POP
55051: POP
// if selected then
55052: LD_VAR 0 7
55056: IFFALSE 55155
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55058: LD_ADDR_VAR 0 3
55062: PUSH
55063: LD_EXP 145
55067: PUSH
55068: LD_VAR 0 2
55072: ARRAY
55073: PPUSH
55074: LD_INT 25
55076: PUSH
55077: LD_INT 12
55079: PUSH
55080: EMPTY
55081: LIST
55082: LIST
55083: PPUSH
55084: CALL_OW 72
55088: PUSH
55089: FOR_IN
55090: IFFALSE 55153
// if not HasTask ( j ) then
55092: LD_VAR 0 3
55096: PPUSH
55097: CALL_OW 314
55101: NOT
55102: IFFALSE 55151
// begin if not IsInUnit ( j ) then
55104: LD_VAR 0 3
55108: PPUSH
55109: CALL_OW 310
55113: NOT
55114: IFFALSE 55130
// ComEnterUnit ( j , selected ) ;
55116: LD_VAR 0 3
55120: PPUSH
55121: LD_VAR 0 7
55125: PPUSH
55126: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
55130: LD_VAR 0 3
55134: PPUSH
55135: LD_INT 16
55137: PPUSH
55138: CALL_OW 183
// AddComExitBuilding ( j ) ;
55142: LD_VAR 0 3
55146: PPUSH
55147: CALL_OW 182
// end ;
55151: GO 55089
55153: POP
55154: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
55155: LD_VAR 0 5
55159: PPUSH
55160: LD_INT 11
55162: PPUSH
55163: CALL_OW 325
55167: IFFALSE 55426
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
55169: LD_ADDR_VAR 0 4
55173: PUSH
55174: LD_EXP 145
55178: PUSH
55179: LD_VAR 0 2
55183: ARRAY
55184: PPUSH
55185: LD_INT 25
55187: PUSH
55188: LD_INT 16
55190: PUSH
55191: EMPTY
55192: LIST
55193: LIST
55194: PPUSH
55195: CALL_OW 72
55199: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
55200: LD_VAR 0 4
55204: PUSH
55205: LD_INT 6
55207: GREATEREQUAL
55208: PUSH
55209: LD_VAR 0 5
55213: PPUSH
55214: LD_INT 2
55216: PPUSH
55217: CALL_OW 325
55221: NOT
55222: OR
55223: IFFALSE 55426
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55225: LD_ADDR_VAR 0 8
55229: PUSH
55230: LD_EXP 116
55234: PUSH
55235: LD_VAR 0 2
55239: ARRAY
55240: PPUSH
55241: LD_INT 2
55243: PUSH
55244: LD_INT 30
55246: PUSH
55247: LD_INT 4
55249: PUSH
55250: EMPTY
55251: LIST
55252: LIST
55253: PUSH
55254: LD_INT 30
55256: PUSH
55257: LD_INT 5
55259: PUSH
55260: EMPTY
55261: LIST
55262: LIST
55263: PUSH
55264: EMPTY
55265: LIST
55266: LIST
55267: LIST
55268: PPUSH
55269: CALL_OW 72
55273: ST_TO_ADDR
// if barracks then
55274: LD_VAR 0 8
55278: IFFALSE 55426
// begin selected := 0 ;
55280: LD_ADDR_VAR 0 7
55284: PUSH
55285: LD_INT 0
55287: ST_TO_ADDR
// for j in barracks do
55288: LD_ADDR_VAR 0 3
55292: PUSH
55293: LD_VAR 0 8
55297: PUSH
55298: FOR_IN
55299: IFFALSE 55330
// begin if UnitsInside ( j ) < 6 then
55301: LD_VAR 0 3
55305: PPUSH
55306: CALL_OW 313
55310: PUSH
55311: LD_INT 6
55313: LESS
55314: IFFALSE 55328
// begin selected := j ;
55316: LD_ADDR_VAR 0 7
55320: PUSH
55321: LD_VAR 0 3
55325: ST_TO_ADDR
// break ;
55326: GO 55330
// end ; end ;
55328: GO 55298
55330: POP
55331: POP
// if selected then
55332: LD_VAR 0 7
55336: IFFALSE 55426
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
55338: LD_ADDR_VAR 0 3
55342: PUSH
55343: LD_EXP 145
55347: PUSH
55348: LD_VAR 0 2
55352: ARRAY
55353: PPUSH
55354: LD_INT 25
55356: PUSH
55357: LD_INT 12
55359: PUSH
55360: EMPTY
55361: LIST
55362: LIST
55363: PPUSH
55364: CALL_OW 72
55368: PUSH
55369: FOR_IN
55370: IFFALSE 55424
// if not IsInUnit ( j ) and not HasTask ( j ) then
55372: LD_VAR 0 3
55376: PPUSH
55377: CALL_OW 310
55381: NOT
55382: PUSH
55383: LD_VAR 0 3
55387: PPUSH
55388: CALL_OW 314
55392: NOT
55393: AND
55394: IFFALSE 55422
// begin ComEnterUnit ( j , selected ) ;
55396: LD_VAR 0 3
55400: PPUSH
55401: LD_VAR 0 7
55405: PPUSH
55406: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
55410: LD_VAR 0 3
55414: PPUSH
55415: LD_INT 15
55417: PPUSH
55418: CALL_OW 183
// end ;
55422: GO 55369
55424: POP
55425: POP
// end ; end ; end ; end ; end ;
55426: GO 54819
55428: POP
55429: POP
// end ;
55430: LD_VAR 0 1
55434: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
55435: LD_INT 0
55437: PPUSH
55438: PPUSH
55439: PPUSH
55440: PPUSH
// if not mc_bases then
55441: LD_EXP 116
55445: NOT
55446: IFFALSE 55450
// exit ;
55448: GO 55628
// for i = 1 to mc_bases do
55450: LD_ADDR_VAR 0 2
55454: PUSH
55455: DOUBLE
55456: LD_INT 1
55458: DEC
55459: ST_TO_ADDR
55460: LD_EXP 116
55464: PUSH
55465: FOR_TO
55466: IFFALSE 55626
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
55468: LD_ADDR_VAR 0 4
55472: PUSH
55473: LD_EXP 116
55477: PUSH
55478: LD_VAR 0 2
55482: ARRAY
55483: PPUSH
55484: LD_INT 25
55486: PUSH
55487: LD_INT 9
55489: PUSH
55490: EMPTY
55491: LIST
55492: LIST
55493: PPUSH
55494: CALL_OW 72
55498: ST_TO_ADDR
// if not tmp then
55499: LD_VAR 0 4
55503: NOT
55504: IFFALSE 55508
// continue ;
55506: GO 55465
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
55508: LD_EXP 142
55512: PUSH
55513: LD_VAR 0 2
55517: ARRAY
55518: PPUSH
55519: LD_INT 29
55521: PPUSH
55522: CALL_OW 325
55526: NOT
55527: PUSH
55528: LD_EXP 142
55532: PUSH
55533: LD_VAR 0 2
55537: ARRAY
55538: PPUSH
55539: LD_INT 28
55541: PPUSH
55542: CALL_OW 325
55546: NOT
55547: AND
55548: IFFALSE 55552
// continue ;
55550: GO 55465
// for j in tmp do
55552: LD_ADDR_VAR 0 3
55556: PUSH
55557: LD_VAR 0 4
55561: PUSH
55562: FOR_IN
55563: IFFALSE 55622
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
55565: LD_VAR 0 3
55569: PUSH
55570: LD_EXP 119
55574: PUSH
55575: LD_VAR 0 2
55579: ARRAY
55580: PUSH
55581: LD_INT 1
55583: ARRAY
55584: IN
55585: NOT
55586: PUSH
55587: LD_VAR 0 3
55591: PUSH
55592: LD_EXP 119
55596: PUSH
55597: LD_VAR 0 2
55601: ARRAY
55602: PUSH
55603: LD_INT 2
55605: ARRAY
55606: IN
55607: NOT
55608: AND
55609: IFFALSE 55620
// ComSpaceTimeShoot ( j ) ;
55611: LD_VAR 0 3
55615: PPUSH
55616: CALL 66832 0 1
55620: GO 55562
55622: POP
55623: POP
// end ;
55624: GO 55465
55626: POP
55627: POP
// end ;
55628: LD_VAR 0 1
55632: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
55633: LD_INT 0
55635: PPUSH
55636: PPUSH
55637: PPUSH
55638: PPUSH
55639: PPUSH
55640: PPUSH
55641: PPUSH
55642: PPUSH
55643: PPUSH
// if not mc_bases then
55644: LD_EXP 116
55648: NOT
55649: IFFALSE 55653
// exit ;
55651: GO 56275
// for i = 1 to mc_bases do
55653: LD_ADDR_VAR 0 2
55657: PUSH
55658: DOUBLE
55659: LD_INT 1
55661: DEC
55662: ST_TO_ADDR
55663: LD_EXP 116
55667: PUSH
55668: FOR_TO
55669: IFFALSE 56273
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
55671: LD_EXP 151
55675: PUSH
55676: LD_VAR 0 2
55680: ARRAY
55681: NOT
55682: PUSH
55683: LD_INT 38
55685: PPUSH
55686: LD_EXP 142
55690: PUSH
55691: LD_VAR 0 2
55695: ARRAY
55696: PPUSH
55697: CALL_OW 321
55701: PUSH
55702: LD_INT 2
55704: NONEQUAL
55705: OR
55706: IFFALSE 55710
// continue ;
55708: GO 55668
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
55710: LD_ADDR_VAR 0 8
55714: PUSH
55715: LD_EXP 116
55719: PUSH
55720: LD_VAR 0 2
55724: ARRAY
55725: PPUSH
55726: LD_INT 30
55728: PUSH
55729: LD_INT 34
55731: PUSH
55732: EMPTY
55733: LIST
55734: LIST
55735: PPUSH
55736: CALL_OW 72
55740: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
55741: LD_ADDR_VAR 0 9
55745: PUSH
55746: LD_EXP 116
55750: PUSH
55751: LD_VAR 0 2
55755: ARRAY
55756: PPUSH
55757: LD_INT 25
55759: PUSH
55760: LD_INT 4
55762: PUSH
55763: EMPTY
55764: LIST
55765: LIST
55766: PPUSH
55767: CALL_OW 72
55771: PPUSH
55772: LD_INT 0
55774: PPUSH
55775: CALL 100140 0 2
55779: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
55780: LD_VAR 0 9
55784: NOT
55785: PUSH
55786: LD_VAR 0 8
55790: NOT
55791: OR
55792: PUSH
55793: LD_EXP 116
55797: PUSH
55798: LD_VAR 0 2
55802: ARRAY
55803: PPUSH
55804: LD_INT 124
55806: PPUSH
55807: CALL 100140 0 2
55811: OR
55812: IFFALSE 55816
// continue ;
55814: GO 55668
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
55816: LD_EXP 152
55820: PUSH
55821: LD_VAR 0 2
55825: ARRAY
55826: PUSH
55827: LD_EXP 151
55831: PUSH
55832: LD_VAR 0 2
55836: ARRAY
55837: LESS
55838: PUSH
55839: LD_EXP 152
55843: PUSH
55844: LD_VAR 0 2
55848: ARRAY
55849: PUSH
55850: LD_VAR 0 8
55854: LESS
55855: AND
55856: IFFALSE 56271
// begin tmp := sci [ 1 ] ;
55858: LD_ADDR_VAR 0 7
55862: PUSH
55863: LD_VAR 0 9
55867: PUSH
55868: LD_INT 1
55870: ARRAY
55871: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
55872: LD_VAR 0 7
55876: PPUSH
55877: LD_INT 124
55879: PPUSH
55880: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
55884: LD_ADDR_VAR 0 3
55888: PUSH
55889: DOUBLE
55890: LD_EXP 151
55894: PUSH
55895: LD_VAR 0 2
55899: ARRAY
55900: INC
55901: ST_TO_ADDR
55902: LD_EXP 151
55906: PUSH
55907: LD_VAR 0 2
55911: ARRAY
55912: PUSH
55913: FOR_DOWNTO
55914: IFFALSE 56257
// begin if IsInUnit ( tmp ) then
55916: LD_VAR 0 7
55920: PPUSH
55921: CALL_OW 310
55925: IFFALSE 55936
// ComExitBuilding ( tmp ) ;
55927: LD_VAR 0 7
55931: PPUSH
55932: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
55936: LD_INT 35
55938: PPUSH
55939: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
55943: LD_VAR 0 7
55947: PPUSH
55948: CALL_OW 310
55952: NOT
55953: PUSH
55954: LD_VAR 0 7
55958: PPUSH
55959: CALL_OW 314
55963: NOT
55964: AND
55965: IFFALSE 55936
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
55967: LD_ADDR_VAR 0 6
55971: PUSH
55972: LD_VAR 0 7
55976: PPUSH
55977: CALL_OW 250
55981: PUSH
55982: LD_VAR 0 7
55986: PPUSH
55987: CALL_OW 251
55991: PUSH
55992: EMPTY
55993: LIST
55994: LIST
55995: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
55996: LD_INT 35
55998: PPUSH
55999: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
56003: LD_ADDR_VAR 0 4
56007: PUSH
56008: LD_EXP 151
56012: PUSH
56013: LD_VAR 0 2
56017: ARRAY
56018: PUSH
56019: LD_VAR 0 3
56023: ARRAY
56024: PUSH
56025: LD_INT 1
56027: ARRAY
56028: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
56029: LD_ADDR_VAR 0 5
56033: PUSH
56034: LD_EXP 151
56038: PUSH
56039: LD_VAR 0 2
56043: ARRAY
56044: PUSH
56045: LD_VAR 0 3
56049: ARRAY
56050: PUSH
56051: LD_INT 2
56053: ARRAY
56054: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
56055: LD_VAR 0 7
56059: PPUSH
56060: LD_INT 10
56062: PPUSH
56063: CALL 73470 0 2
56067: PUSH
56068: LD_INT 4
56070: ARRAY
56071: IFFALSE 56109
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
56073: LD_VAR 0 7
56077: PPUSH
56078: LD_VAR 0 6
56082: PUSH
56083: LD_INT 1
56085: ARRAY
56086: PPUSH
56087: LD_VAR 0 6
56091: PUSH
56092: LD_INT 2
56094: ARRAY
56095: PPUSH
56096: CALL_OW 111
// wait ( 0 0$10 ) ;
56100: LD_INT 350
56102: PPUSH
56103: CALL_OW 67
// end else
56107: GO 56135
// begin ComMoveXY ( tmp , x , y ) ;
56109: LD_VAR 0 7
56113: PPUSH
56114: LD_VAR 0 4
56118: PPUSH
56119: LD_VAR 0 5
56123: PPUSH
56124: CALL_OW 111
// wait ( 0 0$3 ) ;
56128: LD_INT 105
56130: PPUSH
56131: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
56135: LD_VAR 0 7
56139: PPUSH
56140: LD_VAR 0 4
56144: PPUSH
56145: LD_VAR 0 5
56149: PPUSH
56150: CALL_OW 307
56154: IFFALSE 55996
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
56156: LD_VAR 0 7
56160: PPUSH
56161: LD_VAR 0 4
56165: PPUSH
56166: LD_VAR 0 5
56170: PPUSH
56171: LD_VAR 0 8
56175: PUSH
56176: LD_VAR 0 3
56180: ARRAY
56181: PPUSH
56182: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
56186: LD_INT 35
56188: PPUSH
56189: CALL_OW 67
// until not HasTask ( tmp ) ;
56193: LD_VAR 0 7
56197: PPUSH
56198: CALL_OW 314
56202: NOT
56203: IFFALSE 56186
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
56205: LD_ADDR_EXP 152
56209: PUSH
56210: LD_EXP 152
56214: PPUSH
56215: LD_VAR 0 2
56219: PUSH
56220: LD_EXP 152
56224: PUSH
56225: LD_VAR 0 2
56229: ARRAY
56230: PUSH
56231: LD_INT 1
56233: PLUS
56234: PUSH
56235: EMPTY
56236: LIST
56237: LIST
56238: PPUSH
56239: LD_VAR 0 8
56243: PUSH
56244: LD_VAR 0 3
56248: ARRAY
56249: PPUSH
56250: CALL 70871 0 3
56254: ST_TO_ADDR
// end ;
56255: GO 55913
56257: POP
56258: POP
// MC_Reset ( i , 124 ) ;
56259: LD_VAR 0 2
56263: PPUSH
56264: LD_INT 124
56266: PPUSH
56267: CALL 39413 0 2
// end ; end ;
56271: GO 55668
56273: POP
56274: POP
// end ;
56275: LD_VAR 0 1
56279: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
56280: LD_INT 0
56282: PPUSH
56283: PPUSH
56284: PPUSH
// if not mc_bases then
56285: LD_EXP 116
56289: NOT
56290: IFFALSE 56294
// exit ;
56292: GO 56900
// for i = 1 to mc_bases do
56294: LD_ADDR_VAR 0 2
56298: PUSH
56299: DOUBLE
56300: LD_INT 1
56302: DEC
56303: ST_TO_ADDR
56304: LD_EXP 116
56308: PUSH
56309: FOR_TO
56310: IFFALSE 56898
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
56312: LD_ADDR_VAR 0 3
56316: PUSH
56317: LD_EXP 116
56321: PUSH
56322: LD_VAR 0 2
56326: ARRAY
56327: PPUSH
56328: LD_INT 25
56330: PUSH
56331: LD_INT 4
56333: PUSH
56334: EMPTY
56335: LIST
56336: LIST
56337: PPUSH
56338: CALL_OW 72
56342: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56343: LD_VAR 0 3
56347: NOT
56348: PUSH
56349: LD_EXP 153
56353: PUSH
56354: LD_VAR 0 2
56358: ARRAY
56359: NOT
56360: OR
56361: PUSH
56362: LD_EXP 116
56366: PUSH
56367: LD_VAR 0 2
56371: ARRAY
56372: PPUSH
56373: LD_INT 2
56375: PUSH
56376: LD_INT 30
56378: PUSH
56379: LD_INT 0
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: PUSH
56386: LD_INT 30
56388: PUSH
56389: LD_INT 1
56391: PUSH
56392: EMPTY
56393: LIST
56394: LIST
56395: PUSH
56396: EMPTY
56397: LIST
56398: LIST
56399: LIST
56400: PPUSH
56401: CALL_OW 72
56405: NOT
56406: OR
56407: IFFALSE 56457
// begin if mc_deposits_finder [ i ] then
56409: LD_EXP 154
56413: PUSH
56414: LD_VAR 0 2
56418: ARRAY
56419: IFFALSE 56455
// begin MC_Reset ( i , 125 ) ;
56421: LD_VAR 0 2
56425: PPUSH
56426: LD_INT 125
56428: PPUSH
56429: CALL 39413 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56433: LD_ADDR_EXP 154
56437: PUSH
56438: LD_EXP 154
56442: PPUSH
56443: LD_VAR 0 2
56447: PPUSH
56448: EMPTY
56449: PPUSH
56450: CALL_OW 1
56454: ST_TO_ADDR
// end ; continue ;
56455: GO 56309
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
56457: LD_EXP 153
56461: PUSH
56462: LD_VAR 0 2
56466: ARRAY
56467: PUSH
56468: LD_INT 1
56470: ARRAY
56471: PUSH
56472: LD_INT 3
56474: ARRAY
56475: PUSH
56476: LD_INT 1
56478: EQUAL
56479: PUSH
56480: LD_INT 20
56482: PPUSH
56483: LD_EXP 142
56487: PUSH
56488: LD_VAR 0 2
56492: ARRAY
56493: PPUSH
56494: CALL_OW 321
56498: PUSH
56499: LD_INT 2
56501: NONEQUAL
56502: AND
56503: IFFALSE 56553
// begin if mc_deposits_finder [ i ] then
56505: LD_EXP 154
56509: PUSH
56510: LD_VAR 0 2
56514: ARRAY
56515: IFFALSE 56551
// begin MC_Reset ( i , 125 ) ;
56517: LD_VAR 0 2
56521: PPUSH
56522: LD_INT 125
56524: PPUSH
56525: CALL 39413 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
56529: LD_ADDR_EXP 154
56533: PUSH
56534: LD_EXP 154
56538: PPUSH
56539: LD_VAR 0 2
56543: PPUSH
56544: EMPTY
56545: PPUSH
56546: CALL_OW 1
56550: ST_TO_ADDR
// end ; continue ;
56551: GO 56309
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
56553: LD_EXP 153
56557: PUSH
56558: LD_VAR 0 2
56562: ARRAY
56563: PUSH
56564: LD_INT 1
56566: ARRAY
56567: PUSH
56568: LD_INT 1
56570: ARRAY
56571: PPUSH
56572: LD_EXP 153
56576: PUSH
56577: LD_VAR 0 2
56581: ARRAY
56582: PUSH
56583: LD_INT 1
56585: ARRAY
56586: PUSH
56587: LD_INT 2
56589: ARRAY
56590: PPUSH
56591: LD_EXP 142
56595: PUSH
56596: LD_VAR 0 2
56600: ARRAY
56601: PPUSH
56602: CALL_OW 440
56606: IFFALSE 56649
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
56608: LD_ADDR_EXP 153
56612: PUSH
56613: LD_EXP 153
56617: PPUSH
56618: LD_VAR 0 2
56622: PPUSH
56623: LD_EXP 153
56627: PUSH
56628: LD_VAR 0 2
56632: ARRAY
56633: PPUSH
56634: LD_INT 1
56636: PPUSH
56637: CALL_OW 3
56641: PPUSH
56642: CALL_OW 1
56646: ST_TO_ADDR
56647: GO 56896
// begin if not mc_deposits_finder [ i ] then
56649: LD_EXP 154
56653: PUSH
56654: LD_VAR 0 2
56658: ARRAY
56659: NOT
56660: IFFALSE 56712
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
56662: LD_ADDR_EXP 154
56666: PUSH
56667: LD_EXP 154
56671: PPUSH
56672: LD_VAR 0 2
56676: PPUSH
56677: LD_VAR 0 3
56681: PUSH
56682: LD_INT 1
56684: ARRAY
56685: PUSH
56686: EMPTY
56687: LIST
56688: PPUSH
56689: CALL_OW 1
56693: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
56694: LD_VAR 0 3
56698: PUSH
56699: LD_INT 1
56701: ARRAY
56702: PPUSH
56703: LD_INT 125
56705: PPUSH
56706: CALL_OW 109
// end else
56710: GO 56896
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
56712: LD_EXP 154
56716: PUSH
56717: LD_VAR 0 2
56721: ARRAY
56722: PUSH
56723: LD_INT 1
56725: ARRAY
56726: PPUSH
56727: CALL_OW 310
56731: IFFALSE 56754
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
56733: LD_EXP 154
56737: PUSH
56738: LD_VAR 0 2
56742: ARRAY
56743: PUSH
56744: LD_INT 1
56746: ARRAY
56747: PPUSH
56748: CALL_OW 122
56752: GO 56896
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
56754: LD_EXP 154
56758: PUSH
56759: LD_VAR 0 2
56763: ARRAY
56764: PUSH
56765: LD_INT 1
56767: ARRAY
56768: PPUSH
56769: CALL_OW 314
56773: NOT
56774: PUSH
56775: LD_EXP 154
56779: PUSH
56780: LD_VAR 0 2
56784: ARRAY
56785: PUSH
56786: LD_INT 1
56788: ARRAY
56789: PPUSH
56790: LD_EXP 153
56794: PUSH
56795: LD_VAR 0 2
56799: ARRAY
56800: PUSH
56801: LD_INT 1
56803: ARRAY
56804: PUSH
56805: LD_INT 1
56807: ARRAY
56808: PPUSH
56809: LD_EXP 153
56813: PUSH
56814: LD_VAR 0 2
56818: ARRAY
56819: PUSH
56820: LD_INT 1
56822: ARRAY
56823: PUSH
56824: LD_INT 2
56826: ARRAY
56827: PPUSH
56828: CALL_OW 297
56832: PUSH
56833: LD_INT 6
56835: GREATER
56836: AND
56837: IFFALSE 56896
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
56839: LD_EXP 154
56843: PUSH
56844: LD_VAR 0 2
56848: ARRAY
56849: PUSH
56850: LD_INT 1
56852: ARRAY
56853: PPUSH
56854: LD_EXP 153
56858: PUSH
56859: LD_VAR 0 2
56863: ARRAY
56864: PUSH
56865: LD_INT 1
56867: ARRAY
56868: PUSH
56869: LD_INT 1
56871: ARRAY
56872: PPUSH
56873: LD_EXP 153
56877: PUSH
56878: LD_VAR 0 2
56882: ARRAY
56883: PUSH
56884: LD_INT 1
56886: ARRAY
56887: PUSH
56888: LD_INT 2
56890: ARRAY
56891: PPUSH
56892: CALL_OW 111
// end ; end ; end ;
56896: GO 56309
56898: POP
56899: POP
// end ;
56900: LD_VAR 0 1
56904: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
56905: LD_INT 0
56907: PPUSH
56908: PPUSH
56909: PPUSH
56910: PPUSH
56911: PPUSH
56912: PPUSH
56913: PPUSH
56914: PPUSH
56915: PPUSH
56916: PPUSH
56917: PPUSH
// if not mc_bases then
56918: LD_EXP 116
56922: NOT
56923: IFFALSE 56927
// exit ;
56925: GO 57867
// for i = 1 to mc_bases do
56927: LD_ADDR_VAR 0 2
56931: PUSH
56932: DOUBLE
56933: LD_INT 1
56935: DEC
56936: ST_TO_ADDR
56937: LD_EXP 116
56941: PUSH
56942: FOR_TO
56943: IFFALSE 57865
// begin if not mc_bases [ i ] or mc_scan [ i ] then
56945: LD_EXP 116
56949: PUSH
56950: LD_VAR 0 2
56954: ARRAY
56955: NOT
56956: PUSH
56957: LD_EXP 139
56961: PUSH
56962: LD_VAR 0 2
56966: ARRAY
56967: OR
56968: IFFALSE 56972
// continue ;
56970: GO 56942
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
56972: LD_ADDR_VAR 0 7
56976: PUSH
56977: LD_EXP 116
56981: PUSH
56982: LD_VAR 0 2
56986: ARRAY
56987: PUSH
56988: LD_INT 1
56990: ARRAY
56991: PPUSH
56992: CALL_OW 248
56996: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
56997: LD_VAR 0 7
57001: PUSH
57002: LD_INT 3
57004: EQUAL
57005: PUSH
57006: LD_EXP 135
57010: PUSH
57011: LD_VAR 0 2
57015: ARRAY
57016: PUSH
57017: LD_EXP 138
57021: PUSH
57022: LD_VAR 0 2
57026: ARRAY
57027: UNION
57028: PPUSH
57029: LD_INT 33
57031: PUSH
57032: LD_INT 2
57034: PUSH
57035: EMPTY
57036: LIST
57037: LIST
57038: PPUSH
57039: CALL_OW 72
57043: NOT
57044: OR
57045: IFFALSE 57049
// continue ;
57047: GO 56942
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
57049: LD_ADDR_VAR 0 9
57053: PUSH
57054: LD_EXP 116
57058: PUSH
57059: LD_VAR 0 2
57063: ARRAY
57064: PPUSH
57065: LD_INT 30
57067: PUSH
57068: LD_INT 36
57070: PUSH
57071: EMPTY
57072: LIST
57073: LIST
57074: PPUSH
57075: CALL_OW 72
57079: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
57080: LD_ADDR_VAR 0 10
57084: PUSH
57085: LD_EXP 135
57089: PUSH
57090: LD_VAR 0 2
57094: ARRAY
57095: PPUSH
57096: LD_INT 34
57098: PUSH
57099: LD_INT 31
57101: PUSH
57102: EMPTY
57103: LIST
57104: LIST
57105: PPUSH
57106: CALL_OW 72
57110: ST_TO_ADDR
// if not cts and not mcts then
57111: LD_VAR 0 9
57115: NOT
57116: PUSH
57117: LD_VAR 0 10
57121: NOT
57122: AND
57123: IFFALSE 57127
// continue ;
57125: GO 56942
// x := cts ;
57127: LD_ADDR_VAR 0 11
57131: PUSH
57132: LD_VAR 0 9
57136: ST_TO_ADDR
// if not x then
57137: LD_VAR 0 11
57141: NOT
57142: IFFALSE 57154
// x := mcts ;
57144: LD_ADDR_VAR 0 11
57148: PUSH
57149: LD_VAR 0 10
57153: ST_TO_ADDR
// if not x then
57154: LD_VAR 0 11
57158: NOT
57159: IFFALSE 57163
// continue ;
57161: GO 56942
// if mc_remote_driver [ i ] then
57163: LD_EXP 156
57167: PUSH
57168: LD_VAR 0 2
57172: ARRAY
57173: IFFALSE 57560
// for j in mc_remote_driver [ i ] do
57175: LD_ADDR_VAR 0 3
57179: PUSH
57180: LD_EXP 156
57184: PUSH
57185: LD_VAR 0 2
57189: ARRAY
57190: PUSH
57191: FOR_IN
57192: IFFALSE 57558
// begin if GetClass ( j ) <> 3 then
57194: LD_VAR 0 3
57198: PPUSH
57199: CALL_OW 257
57203: PUSH
57204: LD_INT 3
57206: NONEQUAL
57207: IFFALSE 57260
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
57209: LD_ADDR_EXP 156
57213: PUSH
57214: LD_EXP 156
57218: PPUSH
57219: LD_VAR 0 2
57223: PPUSH
57224: LD_EXP 156
57228: PUSH
57229: LD_VAR 0 2
57233: ARRAY
57234: PUSH
57235: LD_VAR 0 3
57239: DIFF
57240: PPUSH
57241: CALL_OW 1
57245: ST_TO_ADDR
// SetTag ( j , 0 ) ;
57246: LD_VAR 0 3
57250: PPUSH
57251: LD_INT 0
57253: PPUSH
57254: CALL_OW 109
// continue ;
57258: GO 57191
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
57260: LD_EXP 135
57264: PUSH
57265: LD_VAR 0 2
57269: ARRAY
57270: PPUSH
57271: LD_INT 34
57273: PUSH
57274: LD_INT 31
57276: PUSH
57277: EMPTY
57278: LIST
57279: LIST
57280: PUSH
57281: LD_INT 58
57283: PUSH
57284: EMPTY
57285: LIST
57286: PUSH
57287: EMPTY
57288: LIST
57289: LIST
57290: PPUSH
57291: CALL_OW 72
57295: PUSH
57296: LD_VAR 0 3
57300: PPUSH
57301: CALL 100228 0 1
57305: NOT
57306: AND
57307: IFFALSE 57378
// begin if IsInUnit ( j ) then
57309: LD_VAR 0 3
57313: PPUSH
57314: CALL_OW 310
57318: IFFALSE 57329
// ComExitBuilding ( j ) ;
57320: LD_VAR 0 3
57324: PPUSH
57325: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
57329: LD_VAR 0 3
57333: PPUSH
57334: LD_EXP 135
57338: PUSH
57339: LD_VAR 0 2
57343: ARRAY
57344: PPUSH
57345: LD_INT 34
57347: PUSH
57348: LD_INT 31
57350: PUSH
57351: EMPTY
57352: LIST
57353: LIST
57354: PUSH
57355: LD_INT 58
57357: PUSH
57358: EMPTY
57359: LIST
57360: PUSH
57361: EMPTY
57362: LIST
57363: LIST
57364: PPUSH
57365: CALL_OW 72
57369: PUSH
57370: LD_INT 1
57372: ARRAY
57373: PPUSH
57374: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
57378: LD_VAR 0 3
57382: PPUSH
57383: CALL_OW 310
57387: NOT
57388: PUSH
57389: LD_VAR 0 3
57393: PPUSH
57394: CALL_OW 310
57398: PPUSH
57399: CALL_OW 266
57403: PUSH
57404: LD_INT 36
57406: NONEQUAL
57407: PUSH
57408: LD_VAR 0 3
57412: PPUSH
57413: CALL 100228 0 1
57417: NOT
57418: AND
57419: OR
57420: IFFALSE 57556
// begin if IsInUnit ( j ) then
57422: LD_VAR 0 3
57426: PPUSH
57427: CALL_OW 310
57431: IFFALSE 57442
// ComExitBuilding ( j ) ;
57433: LD_VAR 0 3
57437: PPUSH
57438: CALL_OW 122
// ct := 0 ;
57442: LD_ADDR_VAR 0 8
57446: PUSH
57447: LD_INT 0
57449: ST_TO_ADDR
// for k in x do
57450: LD_ADDR_VAR 0 4
57454: PUSH
57455: LD_VAR 0 11
57459: PUSH
57460: FOR_IN
57461: IFFALSE 57534
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
57463: LD_VAR 0 4
57467: PPUSH
57468: CALL_OW 264
57472: PUSH
57473: LD_INT 31
57475: EQUAL
57476: PUSH
57477: LD_VAR 0 4
57481: PPUSH
57482: CALL_OW 311
57486: NOT
57487: AND
57488: PUSH
57489: LD_VAR 0 4
57493: PPUSH
57494: CALL_OW 266
57498: PUSH
57499: LD_INT 36
57501: EQUAL
57502: PUSH
57503: LD_VAR 0 4
57507: PPUSH
57508: CALL_OW 313
57512: PUSH
57513: LD_INT 3
57515: LESS
57516: AND
57517: OR
57518: IFFALSE 57532
// begin ct := k ;
57520: LD_ADDR_VAR 0 8
57524: PUSH
57525: LD_VAR 0 4
57529: ST_TO_ADDR
// break ;
57530: GO 57534
// end ;
57532: GO 57460
57534: POP
57535: POP
// if ct then
57536: LD_VAR 0 8
57540: IFFALSE 57556
// ComEnterUnit ( j , ct ) ;
57542: LD_VAR 0 3
57546: PPUSH
57547: LD_VAR 0 8
57551: PPUSH
57552: CALL_OW 120
// end ; end ;
57556: GO 57191
57558: POP
57559: POP
// places := 0 ;
57560: LD_ADDR_VAR 0 5
57564: PUSH
57565: LD_INT 0
57567: ST_TO_ADDR
// for j = 1 to x do
57568: LD_ADDR_VAR 0 3
57572: PUSH
57573: DOUBLE
57574: LD_INT 1
57576: DEC
57577: ST_TO_ADDR
57578: LD_VAR 0 11
57582: PUSH
57583: FOR_TO
57584: IFFALSE 57660
// if GetWeapon ( x [ j ] ) = ar_control_tower then
57586: LD_VAR 0 11
57590: PUSH
57591: LD_VAR 0 3
57595: ARRAY
57596: PPUSH
57597: CALL_OW 264
57601: PUSH
57602: LD_INT 31
57604: EQUAL
57605: IFFALSE 57623
// places := places + 1 else
57607: LD_ADDR_VAR 0 5
57611: PUSH
57612: LD_VAR 0 5
57616: PUSH
57617: LD_INT 1
57619: PLUS
57620: ST_TO_ADDR
57621: GO 57658
// if GetBType ( x [ j ] ) = b_control_tower then
57623: LD_VAR 0 11
57627: PUSH
57628: LD_VAR 0 3
57632: ARRAY
57633: PPUSH
57634: CALL_OW 266
57638: PUSH
57639: LD_INT 36
57641: EQUAL
57642: IFFALSE 57658
// places := places + 3 ;
57644: LD_ADDR_VAR 0 5
57648: PUSH
57649: LD_VAR 0 5
57653: PUSH
57654: LD_INT 3
57656: PLUS
57657: ST_TO_ADDR
57658: GO 57583
57660: POP
57661: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
57662: LD_VAR 0 5
57666: PUSH
57667: LD_INT 0
57669: EQUAL
57670: PUSH
57671: LD_VAR 0 5
57675: PUSH
57676: LD_EXP 156
57680: PUSH
57681: LD_VAR 0 2
57685: ARRAY
57686: LESSEQUAL
57687: OR
57688: IFFALSE 57692
// continue ;
57690: GO 56942
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
57692: LD_ADDR_VAR 0 6
57696: PUSH
57697: LD_EXP 116
57701: PUSH
57702: LD_VAR 0 2
57706: ARRAY
57707: PPUSH
57708: LD_INT 25
57710: PUSH
57711: LD_INT 3
57713: PUSH
57714: EMPTY
57715: LIST
57716: LIST
57717: PPUSH
57718: CALL_OW 72
57722: PUSH
57723: LD_EXP 156
57727: PUSH
57728: LD_VAR 0 2
57732: ARRAY
57733: DIFF
57734: PPUSH
57735: LD_INT 3
57737: PPUSH
57738: CALL 101128 0 2
57742: ST_TO_ADDR
// for j in tmp do
57743: LD_ADDR_VAR 0 3
57747: PUSH
57748: LD_VAR 0 6
57752: PUSH
57753: FOR_IN
57754: IFFALSE 57789
// if GetTag ( j ) > 0 then
57756: LD_VAR 0 3
57760: PPUSH
57761: CALL_OW 110
57765: PUSH
57766: LD_INT 0
57768: GREATER
57769: IFFALSE 57787
// tmp := tmp diff j ;
57771: LD_ADDR_VAR 0 6
57775: PUSH
57776: LD_VAR 0 6
57780: PUSH
57781: LD_VAR 0 3
57785: DIFF
57786: ST_TO_ADDR
57787: GO 57753
57789: POP
57790: POP
// if not tmp then
57791: LD_VAR 0 6
57795: NOT
57796: IFFALSE 57800
// continue ;
57798: GO 56942
// if places then
57800: LD_VAR 0 5
57804: IFFALSE 57863
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
57806: LD_ADDR_EXP 156
57810: PUSH
57811: LD_EXP 156
57815: PPUSH
57816: LD_VAR 0 2
57820: PPUSH
57821: LD_EXP 156
57825: PUSH
57826: LD_VAR 0 2
57830: ARRAY
57831: PUSH
57832: LD_VAR 0 6
57836: PUSH
57837: LD_INT 1
57839: ARRAY
57840: UNION
57841: PPUSH
57842: CALL_OW 1
57846: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
57847: LD_VAR 0 6
57851: PUSH
57852: LD_INT 1
57854: ARRAY
57855: PPUSH
57856: LD_INT 126
57858: PPUSH
57859: CALL_OW 109
// end ; end ;
57863: GO 56942
57865: POP
57866: POP
// end ;
57867: LD_VAR 0 1
57871: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
57872: LD_INT 0
57874: PPUSH
57875: PPUSH
57876: PPUSH
57877: PPUSH
57878: PPUSH
57879: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
57880: LD_VAR 0 1
57884: NOT
57885: PUSH
57886: LD_VAR 0 2
57890: NOT
57891: OR
57892: PUSH
57893: LD_VAR 0 3
57897: NOT
57898: OR
57899: PUSH
57900: LD_VAR 0 4
57904: PUSH
57905: LD_INT 1
57907: PUSH
57908: LD_INT 2
57910: PUSH
57911: LD_INT 3
57913: PUSH
57914: LD_INT 4
57916: PUSH
57917: LD_INT 5
57919: PUSH
57920: LD_INT 8
57922: PUSH
57923: LD_INT 9
57925: PUSH
57926: LD_INT 15
57928: PUSH
57929: LD_INT 16
57931: PUSH
57932: EMPTY
57933: LIST
57934: LIST
57935: LIST
57936: LIST
57937: LIST
57938: LIST
57939: LIST
57940: LIST
57941: LIST
57942: IN
57943: NOT
57944: OR
57945: IFFALSE 57949
// exit ;
57947: GO 58849
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
57949: LD_ADDR_VAR 0 2
57953: PUSH
57954: LD_VAR 0 2
57958: PPUSH
57959: LD_INT 21
57961: PUSH
57962: LD_INT 3
57964: PUSH
57965: EMPTY
57966: LIST
57967: LIST
57968: PUSH
57969: LD_INT 24
57971: PUSH
57972: LD_INT 250
57974: PUSH
57975: EMPTY
57976: LIST
57977: LIST
57978: PUSH
57979: EMPTY
57980: LIST
57981: LIST
57982: PPUSH
57983: CALL_OW 72
57987: ST_TO_ADDR
// case class of 1 , 15 :
57988: LD_VAR 0 4
57992: PUSH
57993: LD_INT 1
57995: DOUBLE
57996: EQUAL
57997: IFTRUE 58007
57999: LD_INT 15
58001: DOUBLE
58002: EQUAL
58003: IFTRUE 58007
58005: GO 58092
58007: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
58008: LD_ADDR_VAR 0 8
58012: PUSH
58013: LD_VAR 0 2
58017: PPUSH
58018: LD_INT 2
58020: PUSH
58021: LD_INT 30
58023: PUSH
58024: LD_INT 32
58026: PUSH
58027: EMPTY
58028: LIST
58029: LIST
58030: PUSH
58031: LD_INT 30
58033: PUSH
58034: LD_INT 31
58036: PUSH
58037: EMPTY
58038: LIST
58039: LIST
58040: PUSH
58041: EMPTY
58042: LIST
58043: LIST
58044: LIST
58045: PPUSH
58046: CALL_OW 72
58050: PUSH
58051: LD_VAR 0 2
58055: PPUSH
58056: LD_INT 2
58058: PUSH
58059: LD_INT 30
58061: PUSH
58062: LD_INT 4
58064: PUSH
58065: EMPTY
58066: LIST
58067: LIST
58068: PUSH
58069: LD_INT 30
58071: PUSH
58072: LD_INT 5
58074: PUSH
58075: EMPTY
58076: LIST
58077: LIST
58078: PUSH
58079: EMPTY
58080: LIST
58081: LIST
58082: LIST
58083: PPUSH
58084: CALL_OW 72
58088: ADD
58089: ST_TO_ADDR
58090: GO 58338
58092: LD_INT 2
58094: DOUBLE
58095: EQUAL
58096: IFTRUE 58106
58098: LD_INT 16
58100: DOUBLE
58101: EQUAL
58102: IFTRUE 58106
58104: GO 58152
58106: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
58107: LD_ADDR_VAR 0 8
58111: PUSH
58112: LD_VAR 0 2
58116: PPUSH
58117: LD_INT 2
58119: PUSH
58120: LD_INT 30
58122: PUSH
58123: LD_INT 0
58125: PUSH
58126: EMPTY
58127: LIST
58128: LIST
58129: PUSH
58130: LD_INT 30
58132: PUSH
58133: LD_INT 1
58135: PUSH
58136: EMPTY
58137: LIST
58138: LIST
58139: PUSH
58140: EMPTY
58141: LIST
58142: LIST
58143: LIST
58144: PPUSH
58145: CALL_OW 72
58149: ST_TO_ADDR
58150: GO 58338
58152: LD_INT 3
58154: DOUBLE
58155: EQUAL
58156: IFTRUE 58160
58158: GO 58206
58160: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
58161: LD_ADDR_VAR 0 8
58165: PUSH
58166: LD_VAR 0 2
58170: PPUSH
58171: LD_INT 2
58173: PUSH
58174: LD_INT 30
58176: PUSH
58177: LD_INT 2
58179: PUSH
58180: EMPTY
58181: LIST
58182: LIST
58183: PUSH
58184: LD_INT 30
58186: PUSH
58187: LD_INT 3
58189: PUSH
58190: EMPTY
58191: LIST
58192: LIST
58193: PUSH
58194: EMPTY
58195: LIST
58196: LIST
58197: LIST
58198: PPUSH
58199: CALL_OW 72
58203: ST_TO_ADDR
58204: GO 58338
58206: LD_INT 4
58208: DOUBLE
58209: EQUAL
58210: IFTRUE 58214
58212: GO 58271
58214: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
58215: LD_ADDR_VAR 0 8
58219: PUSH
58220: LD_VAR 0 2
58224: PPUSH
58225: LD_INT 2
58227: PUSH
58228: LD_INT 30
58230: PUSH
58231: LD_INT 6
58233: PUSH
58234: EMPTY
58235: LIST
58236: LIST
58237: PUSH
58238: LD_INT 30
58240: PUSH
58241: LD_INT 7
58243: PUSH
58244: EMPTY
58245: LIST
58246: LIST
58247: PUSH
58248: LD_INT 30
58250: PUSH
58251: LD_INT 8
58253: PUSH
58254: EMPTY
58255: LIST
58256: LIST
58257: PUSH
58258: EMPTY
58259: LIST
58260: LIST
58261: LIST
58262: LIST
58263: PPUSH
58264: CALL_OW 72
58268: ST_TO_ADDR
58269: GO 58338
58271: LD_INT 5
58273: DOUBLE
58274: EQUAL
58275: IFTRUE 58291
58277: LD_INT 8
58279: DOUBLE
58280: EQUAL
58281: IFTRUE 58291
58283: LD_INT 9
58285: DOUBLE
58286: EQUAL
58287: IFTRUE 58291
58289: GO 58337
58291: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
58292: LD_ADDR_VAR 0 8
58296: PUSH
58297: LD_VAR 0 2
58301: PPUSH
58302: LD_INT 2
58304: PUSH
58305: LD_INT 30
58307: PUSH
58308: LD_INT 4
58310: PUSH
58311: EMPTY
58312: LIST
58313: LIST
58314: PUSH
58315: LD_INT 30
58317: PUSH
58318: LD_INT 5
58320: PUSH
58321: EMPTY
58322: LIST
58323: LIST
58324: PUSH
58325: EMPTY
58326: LIST
58327: LIST
58328: LIST
58329: PPUSH
58330: CALL_OW 72
58334: ST_TO_ADDR
58335: GO 58338
58337: POP
// if not tmp then
58338: LD_VAR 0 8
58342: NOT
58343: IFFALSE 58347
// exit ;
58345: GO 58849
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
58347: LD_VAR 0 4
58351: PUSH
58352: LD_INT 1
58354: PUSH
58355: LD_INT 15
58357: PUSH
58358: EMPTY
58359: LIST
58360: LIST
58361: IN
58362: PUSH
58363: LD_EXP 125
58367: PUSH
58368: LD_VAR 0 1
58372: ARRAY
58373: AND
58374: IFFALSE 58530
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
58376: LD_ADDR_VAR 0 9
58380: PUSH
58381: LD_EXP 125
58385: PUSH
58386: LD_VAR 0 1
58390: ARRAY
58391: PUSH
58392: LD_INT 1
58394: ARRAY
58395: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
58396: LD_VAR 0 9
58400: PUSH
58401: LD_EXP 126
58405: PUSH
58406: LD_VAR 0 1
58410: ARRAY
58411: IN
58412: NOT
58413: IFFALSE 58528
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
58415: LD_ADDR_EXP 126
58419: PUSH
58420: LD_EXP 126
58424: PPUSH
58425: LD_VAR 0 1
58429: PUSH
58430: LD_EXP 126
58434: PUSH
58435: LD_VAR 0 1
58439: ARRAY
58440: PUSH
58441: LD_INT 1
58443: PLUS
58444: PUSH
58445: EMPTY
58446: LIST
58447: LIST
58448: PPUSH
58449: LD_VAR 0 9
58453: PPUSH
58454: CALL 70871 0 3
58458: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
58459: LD_ADDR_EXP 125
58463: PUSH
58464: LD_EXP 125
58468: PPUSH
58469: LD_VAR 0 1
58473: PPUSH
58474: LD_EXP 125
58478: PUSH
58479: LD_VAR 0 1
58483: ARRAY
58484: PUSH
58485: LD_VAR 0 9
58489: DIFF
58490: PPUSH
58491: CALL_OW 1
58495: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
58496: LD_VAR 0 3
58500: PPUSH
58501: LD_EXP 126
58505: PUSH
58506: LD_VAR 0 1
58510: ARRAY
58511: PUSH
58512: LD_EXP 126
58516: PUSH
58517: LD_VAR 0 1
58521: ARRAY
58522: ARRAY
58523: PPUSH
58524: CALL_OW 120
// end ; exit ;
58528: GO 58849
// end ; if tmp > 1 then
58530: LD_VAR 0 8
58534: PUSH
58535: LD_INT 1
58537: GREATER
58538: IFFALSE 58642
// for i = 2 to tmp do
58540: LD_ADDR_VAR 0 6
58544: PUSH
58545: DOUBLE
58546: LD_INT 2
58548: DEC
58549: ST_TO_ADDR
58550: LD_VAR 0 8
58554: PUSH
58555: FOR_TO
58556: IFFALSE 58640
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
58558: LD_VAR 0 8
58562: PUSH
58563: LD_VAR 0 6
58567: ARRAY
58568: PPUSH
58569: CALL_OW 461
58573: PUSH
58574: LD_INT 6
58576: EQUAL
58577: IFFALSE 58638
// begin x := tmp [ i ] ;
58579: LD_ADDR_VAR 0 9
58583: PUSH
58584: LD_VAR 0 8
58588: PUSH
58589: LD_VAR 0 6
58593: ARRAY
58594: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
58595: LD_ADDR_VAR 0 8
58599: PUSH
58600: LD_VAR 0 8
58604: PPUSH
58605: LD_VAR 0 6
58609: PPUSH
58610: CALL_OW 3
58614: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
58615: LD_ADDR_VAR 0 8
58619: PUSH
58620: LD_VAR 0 8
58624: PPUSH
58625: LD_INT 1
58627: PPUSH
58628: LD_VAR 0 9
58632: PPUSH
58633: CALL_OW 2
58637: ST_TO_ADDR
// end ;
58638: GO 58555
58640: POP
58641: POP
// for i in tmp do
58642: LD_ADDR_VAR 0 6
58646: PUSH
58647: LD_VAR 0 8
58651: PUSH
58652: FOR_IN
58653: IFFALSE 58722
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
58655: LD_VAR 0 6
58659: PPUSH
58660: CALL_OW 313
58664: PUSH
58665: LD_INT 6
58667: LESS
58668: PUSH
58669: LD_VAR 0 6
58673: PPUSH
58674: CALL_OW 266
58678: PUSH
58679: LD_INT 31
58681: PUSH
58682: LD_INT 32
58684: PUSH
58685: EMPTY
58686: LIST
58687: LIST
58688: IN
58689: NOT
58690: AND
58691: PUSH
58692: LD_VAR 0 6
58696: PPUSH
58697: CALL_OW 313
58701: PUSH
58702: LD_INT 0
58704: EQUAL
58705: OR
58706: IFFALSE 58720
// begin j := i ;
58708: LD_ADDR_VAR 0 7
58712: PUSH
58713: LD_VAR 0 6
58717: ST_TO_ADDR
// break ;
58718: GO 58722
// end ; end ;
58720: GO 58652
58722: POP
58723: POP
// if j then
58724: LD_VAR 0 7
58728: IFFALSE 58746
// ComEnterUnit ( unit , j ) else
58730: LD_VAR 0 3
58734: PPUSH
58735: LD_VAR 0 7
58739: PPUSH
58740: CALL_OW 120
58744: GO 58849
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
58746: LD_ADDR_VAR 0 10
58750: PUSH
58751: LD_VAR 0 2
58755: PPUSH
58756: LD_INT 2
58758: PUSH
58759: LD_INT 30
58761: PUSH
58762: LD_INT 0
58764: PUSH
58765: EMPTY
58766: LIST
58767: LIST
58768: PUSH
58769: LD_INT 30
58771: PUSH
58772: LD_INT 1
58774: PUSH
58775: EMPTY
58776: LIST
58777: LIST
58778: PUSH
58779: EMPTY
58780: LIST
58781: LIST
58782: LIST
58783: PPUSH
58784: CALL_OW 72
58788: ST_TO_ADDR
// if depot then
58789: LD_VAR 0 10
58793: IFFALSE 58849
// begin depot := NearestUnitToUnit ( depot , unit ) ;
58795: LD_ADDR_VAR 0 10
58799: PUSH
58800: LD_VAR 0 10
58804: PPUSH
58805: LD_VAR 0 3
58809: PPUSH
58810: CALL_OW 74
58814: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
58815: LD_VAR 0 3
58819: PPUSH
58820: LD_VAR 0 10
58824: PPUSH
58825: CALL_OW 296
58829: PUSH
58830: LD_INT 10
58832: GREATER
58833: IFFALSE 58849
// ComStandNearbyBuilding ( unit , depot ) ;
58835: LD_VAR 0 3
58839: PPUSH
58840: LD_VAR 0 10
58844: PPUSH
58845: CALL 67449 0 2
// end ; end ; end ;
58849: LD_VAR 0 5
58853: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
58854: LD_INT 0
58856: PPUSH
58857: PPUSH
58858: PPUSH
58859: PPUSH
// if not mc_bases then
58860: LD_EXP 116
58864: NOT
58865: IFFALSE 58869
// exit ;
58867: GO 59108
// for i = 1 to mc_bases do
58869: LD_ADDR_VAR 0 2
58873: PUSH
58874: DOUBLE
58875: LD_INT 1
58877: DEC
58878: ST_TO_ADDR
58879: LD_EXP 116
58883: PUSH
58884: FOR_TO
58885: IFFALSE 59106
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
58887: LD_ADDR_VAR 0 4
58891: PUSH
58892: LD_EXP 116
58896: PUSH
58897: LD_VAR 0 2
58901: ARRAY
58902: PPUSH
58903: LD_INT 21
58905: PUSH
58906: LD_INT 1
58908: PUSH
58909: EMPTY
58910: LIST
58911: LIST
58912: PPUSH
58913: CALL_OW 72
58917: PUSH
58918: LD_EXP 145
58922: PUSH
58923: LD_VAR 0 2
58927: ARRAY
58928: UNION
58929: ST_TO_ADDR
// if not tmp then
58930: LD_VAR 0 4
58934: NOT
58935: IFFALSE 58939
// continue ;
58937: GO 58884
// for j in tmp do
58939: LD_ADDR_VAR 0 3
58943: PUSH
58944: LD_VAR 0 4
58948: PUSH
58949: FOR_IN
58950: IFFALSE 59102
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
58952: LD_VAR 0 3
58956: PPUSH
58957: CALL_OW 110
58961: NOT
58962: PUSH
58963: LD_VAR 0 3
58967: PPUSH
58968: CALL_OW 314
58972: NOT
58973: AND
58974: PUSH
58975: LD_VAR 0 3
58979: PPUSH
58980: CALL_OW 311
58984: NOT
58985: AND
58986: PUSH
58987: LD_VAR 0 3
58991: PPUSH
58992: CALL_OW 310
58996: NOT
58997: AND
58998: PUSH
58999: LD_VAR 0 3
59003: PUSH
59004: LD_EXP 119
59008: PUSH
59009: LD_VAR 0 2
59013: ARRAY
59014: PUSH
59015: LD_INT 1
59017: ARRAY
59018: IN
59019: NOT
59020: AND
59021: PUSH
59022: LD_VAR 0 3
59026: PUSH
59027: LD_EXP 119
59031: PUSH
59032: LD_VAR 0 2
59036: ARRAY
59037: PUSH
59038: LD_INT 2
59040: ARRAY
59041: IN
59042: NOT
59043: AND
59044: PUSH
59045: LD_VAR 0 3
59049: PUSH
59050: LD_EXP 128
59054: PUSH
59055: LD_VAR 0 2
59059: ARRAY
59060: IN
59061: NOT
59062: AND
59063: IFFALSE 59100
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
59065: LD_VAR 0 2
59069: PPUSH
59070: LD_EXP 116
59074: PUSH
59075: LD_VAR 0 2
59079: ARRAY
59080: PPUSH
59081: LD_VAR 0 3
59085: PPUSH
59086: LD_VAR 0 3
59090: PPUSH
59091: CALL_OW 257
59095: PPUSH
59096: CALL 57872 0 4
// end ;
59100: GO 58949
59102: POP
59103: POP
// end ;
59104: GO 58884
59106: POP
59107: POP
// end ;
59108: LD_VAR 0 1
59112: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
59113: LD_INT 0
59115: PPUSH
59116: PPUSH
59117: PPUSH
59118: PPUSH
59119: PPUSH
59120: PPUSH
// if not mc_bases [ base ] then
59121: LD_EXP 116
59125: PUSH
59126: LD_VAR 0 1
59130: ARRAY
59131: NOT
59132: IFFALSE 59136
// exit ;
59134: GO 59318
// tmp := [ ] ;
59136: LD_ADDR_VAR 0 6
59140: PUSH
59141: EMPTY
59142: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
59143: LD_ADDR_VAR 0 7
59147: PUSH
59148: LD_VAR 0 3
59152: PPUSH
59153: LD_INT 0
59155: PPUSH
59156: CALL_OW 517
59160: ST_TO_ADDR
// if not list then
59161: LD_VAR 0 7
59165: NOT
59166: IFFALSE 59170
// exit ;
59168: GO 59318
// for i = 1 to amount do
59170: LD_ADDR_VAR 0 5
59174: PUSH
59175: DOUBLE
59176: LD_INT 1
59178: DEC
59179: ST_TO_ADDR
59180: LD_VAR 0 2
59184: PUSH
59185: FOR_TO
59186: IFFALSE 59266
// begin x := rand ( 1 , list [ 1 ] ) ;
59188: LD_ADDR_VAR 0 8
59192: PUSH
59193: LD_INT 1
59195: PPUSH
59196: LD_VAR 0 7
59200: PUSH
59201: LD_INT 1
59203: ARRAY
59204: PPUSH
59205: CALL_OW 12
59209: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
59210: LD_ADDR_VAR 0 6
59214: PUSH
59215: LD_VAR 0 6
59219: PPUSH
59220: LD_VAR 0 5
59224: PPUSH
59225: LD_VAR 0 7
59229: PUSH
59230: LD_INT 1
59232: ARRAY
59233: PUSH
59234: LD_VAR 0 8
59238: ARRAY
59239: PUSH
59240: LD_VAR 0 7
59244: PUSH
59245: LD_INT 2
59247: ARRAY
59248: PUSH
59249: LD_VAR 0 8
59253: ARRAY
59254: PUSH
59255: EMPTY
59256: LIST
59257: LIST
59258: PPUSH
59259: CALL_OW 1
59263: ST_TO_ADDR
// end ;
59264: GO 59185
59266: POP
59267: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
59268: LD_ADDR_EXP 129
59272: PUSH
59273: LD_EXP 129
59277: PPUSH
59278: LD_VAR 0 1
59282: PPUSH
59283: LD_VAR 0 6
59287: PPUSH
59288: CALL_OW 1
59292: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
59293: LD_ADDR_EXP 131
59297: PUSH
59298: LD_EXP 131
59302: PPUSH
59303: LD_VAR 0 1
59307: PPUSH
59308: LD_VAR 0 3
59312: PPUSH
59313: CALL_OW 1
59317: ST_TO_ADDR
// end ;
59318: LD_VAR 0 4
59322: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
59323: LD_INT 0
59325: PPUSH
// if not mc_bases [ base ] then
59326: LD_EXP 116
59330: PUSH
59331: LD_VAR 0 1
59335: ARRAY
59336: NOT
59337: IFFALSE 59341
// exit ;
59339: GO 59366
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
59341: LD_ADDR_EXP 121
59345: PUSH
59346: LD_EXP 121
59350: PPUSH
59351: LD_VAR 0 1
59355: PPUSH
59356: LD_VAR 0 2
59360: PPUSH
59361: CALL_OW 1
59365: ST_TO_ADDR
// end ;
59366: LD_VAR 0 3
59370: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
59371: LD_INT 0
59373: PPUSH
// if not mc_bases [ base ] then
59374: LD_EXP 116
59378: PUSH
59379: LD_VAR 0 1
59383: ARRAY
59384: NOT
59385: IFFALSE 59389
// exit ;
59387: GO 59426
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
59389: LD_ADDR_EXP 121
59393: PUSH
59394: LD_EXP 121
59398: PPUSH
59399: LD_VAR 0 1
59403: PPUSH
59404: LD_EXP 121
59408: PUSH
59409: LD_VAR 0 1
59413: ARRAY
59414: PUSH
59415: LD_VAR 0 2
59419: UNION
59420: PPUSH
59421: CALL_OW 1
59425: ST_TO_ADDR
// end ;
59426: LD_VAR 0 3
59430: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
59431: LD_INT 0
59433: PPUSH
// if not mc_bases [ base ] then
59434: LD_EXP 116
59438: PUSH
59439: LD_VAR 0 1
59443: ARRAY
59444: NOT
59445: IFFALSE 59449
// exit ;
59447: GO 59474
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
59449: LD_ADDR_EXP 137
59453: PUSH
59454: LD_EXP 137
59458: PPUSH
59459: LD_VAR 0 1
59463: PPUSH
59464: LD_VAR 0 2
59468: PPUSH
59469: CALL_OW 1
59473: ST_TO_ADDR
// end ;
59474: LD_VAR 0 3
59478: RET
// export function MC_InsertProduceList ( base , components ) ; begin
59479: LD_INT 0
59481: PPUSH
// if not mc_bases [ base ] then
59482: LD_EXP 116
59486: PUSH
59487: LD_VAR 0 1
59491: ARRAY
59492: NOT
59493: IFFALSE 59497
// exit ;
59495: GO 59534
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
59497: LD_ADDR_EXP 137
59501: PUSH
59502: LD_EXP 137
59506: PPUSH
59507: LD_VAR 0 1
59511: PPUSH
59512: LD_EXP 137
59516: PUSH
59517: LD_VAR 0 1
59521: ARRAY
59522: PUSH
59523: LD_VAR 0 2
59527: ADD
59528: PPUSH
59529: CALL_OW 1
59533: ST_TO_ADDR
// end ;
59534: LD_VAR 0 3
59538: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
59539: LD_INT 0
59541: PPUSH
// if not mc_bases [ base ] then
59542: LD_EXP 116
59546: PUSH
59547: LD_VAR 0 1
59551: ARRAY
59552: NOT
59553: IFFALSE 59557
// exit ;
59555: GO 59611
// mc_defender := Replace ( mc_defender , base , deflist ) ;
59557: LD_ADDR_EXP 138
59561: PUSH
59562: LD_EXP 138
59566: PPUSH
59567: LD_VAR 0 1
59571: PPUSH
59572: LD_VAR 0 2
59576: PPUSH
59577: CALL_OW 1
59581: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
59582: LD_ADDR_EXP 127
59586: PUSH
59587: LD_EXP 127
59591: PPUSH
59592: LD_VAR 0 1
59596: PPUSH
59597: LD_VAR 0 2
59601: PUSH
59602: LD_INT 0
59604: PLUS
59605: PPUSH
59606: CALL_OW 1
59610: ST_TO_ADDR
// end ;
59611: LD_VAR 0 3
59615: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
59616: LD_INT 0
59618: PPUSH
// if not mc_bases [ base ] then
59619: LD_EXP 116
59623: PUSH
59624: LD_VAR 0 1
59628: ARRAY
59629: NOT
59630: IFFALSE 59634
// exit ;
59632: GO 59659
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
59634: LD_ADDR_EXP 127
59638: PUSH
59639: LD_EXP 127
59643: PPUSH
59644: LD_VAR 0 1
59648: PPUSH
59649: LD_VAR 0 2
59653: PPUSH
59654: CALL_OW 1
59658: ST_TO_ADDR
// end ;
59659: LD_VAR 0 3
59663: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
59664: LD_INT 0
59666: PPUSH
59667: PPUSH
59668: PPUSH
59669: PPUSH
// if not mc_bases [ base ] then
59670: LD_EXP 116
59674: PUSH
59675: LD_VAR 0 1
59679: ARRAY
59680: NOT
59681: IFFALSE 59685
// exit ;
59683: GO 59750
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
59685: LD_ADDR_EXP 136
59689: PUSH
59690: LD_EXP 136
59694: PPUSH
59695: LD_VAR 0 1
59699: PUSH
59700: LD_EXP 136
59704: PUSH
59705: LD_VAR 0 1
59709: ARRAY
59710: PUSH
59711: LD_INT 1
59713: PLUS
59714: PUSH
59715: EMPTY
59716: LIST
59717: LIST
59718: PPUSH
59719: LD_VAR 0 1
59723: PUSH
59724: LD_VAR 0 2
59728: PUSH
59729: LD_VAR 0 3
59733: PUSH
59734: LD_VAR 0 4
59738: PUSH
59739: EMPTY
59740: LIST
59741: LIST
59742: LIST
59743: LIST
59744: PPUSH
59745: CALL 70871 0 3
59749: ST_TO_ADDR
// end ;
59750: LD_VAR 0 5
59754: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
59755: LD_INT 0
59757: PPUSH
// if not mc_bases [ base ] then
59758: LD_EXP 116
59762: PUSH
59763: LD_VAR 0 1
59767: ARRAY
59768: NOT
59769: IFFALSE 59773
// exit ;
59771: GO 59798
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
59773: LD_ADDR_EXP 153
59777: PUSH
59778: LD_EXP 153
59782: PPUSH
59783: LD_VAR 0 1
59787: PPUSH
59788: LD_VAR 0 2
59792: PPUSH
59793: CALL_OW 1
59797: ST_TO_ADDR
// end ;
59798: LD_VAR 0 3
59802: RET
// export function MC_GetMinesField ( base ) ; begin
59803: LD_INT 0
59805: PPUSH
// result := mc_mines [ base ] ;
59806: LD_ADDR_VAR 0 2
59810: PUSH
59811: LD_EXP 129
59815: PUSH
59816: LD_VAR 0 1
59820: ARRAY
59821: ST_TO_ADDR
// end ;
59822: LD_VAR 0 2
59826: RET
// export function MC_GetProduceList ( base ) ; begin
59827: LD_INT 0
59829: PPUSH
// result := mc_produce [ base ] ;
59830: LD_ADDR_VAR 0 2
59834: PUSH
59835: LD_EXP 137
59839: PUSH
59840: LD_VAR 0 1
59844: ARRAY
59845: ST_TO_ADDR
// end ;
59846: LD_VAR 0 2
59850: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
59851: LD_INT 0
59853: PPUSH
59854: PPUSH
// if not mc_bases then
59855: LD_EXP 116
59859: NOT
59860: IFFALSE 59864
// exit ;
59862: GO 59929
// if mc_bases [ base ] then
59864: LD_EXP 116
59868: PUSH
59869: LD_VAR 0 1
59873: ARRAY
59874: IFFALSE 59929
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59876: LD_ADDR_VAR 0 3
59880: PUSH
59881: LD_EXP 116
59885: PUSH
59886: LD_VAR 0 1
59890: ARRAY
59891: PPUSH
59892: LD_INT 30
59894: PUSH
59895: LD_VAR 0 2
59899: PUSH
59900: EMPTY
59901: LIST
59902: LIST
59903: PPUSH
59904: CALL_OW 72
59908: ST_TO_ADDR
// if result then
59909: LD_VAR 0 3
59913: IFFALSE 59929
// result := result [ 1 ] ;
59915: LD_ADDR_VAR 0 3
59919: PUSH
59920: LD_VAR 0 3
59924: PUSH
59925: LD_INT 1
59927: ARRAY
59928: ST_TO_ADDR
// end ; end ;
59929: LD_VAR 0 3
59933: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
59934: LD_INT 0
59936: PPUSH
59937: PPUSH
// if not mc_bases then
59938: LD_EXP 116
59942: NOT
59943: IFFALSE 59947
// exit ;
59945: GO 59992
// if mc_bases [ base ] then
59947: LD_EXP 116
59951: PUSH
59952: LD_VAR 0 1
59956: ARRAY
59957: IFFALSE 59992
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
59959: LD_ADDR_VAR 0 3
59963: PUSH
59964: LD_EXP 116
59968: PUSH
59969: LD_VAR 0 1
59973: ARRAY
59974: PPUSH
59975: LD_INT 30
59977: PUSH
59978: LD_VAR 0 2
59982: PUSH
59983: EMPTY
59984: LIST
59985: LIST
59986: PPUSH
59987: CALL_OW 72
59991: ST_TO_ADDR
// end ;
59992: LD_VAR 0 3
59996: RET
// export function MC_SetTame ( base , area ) ; begin
59997: LD_INT 0
59999: PPUSH
// if not mc_bases or not base then
60000: LD_EXP 116
60004: NOT
60005: PUSH
60006: LD_VAR 0 1
60010: NOT
60011: OR
60012: IFFALSE 60016
// exit ;
60014: GO 60041
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
60016: LD_ADDR_EXP 144
60020: PUSH
60021: LD_EXP 144
60025: PPUSH
60026: LD_VAR 0 1
60030: PPUSH
60031: LD_VAR 0 2
60035: PPUSH
60036: CALL_OW 1
60040: ST_TO_ADDR
// end ;
60041: LD_VAR 0 3
60045: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
60046: LD_INT 0
60048: PPUSH
60049: PPUSH
// if not mc_bases or not base then
60050: LD_EXP 116
60054: NOT
60055: PUSH
60056: LD_VAR 0 1
60060: NOT
60061: OR
60062: IFFALSE 60066
// exit ;
60064: GO 60168
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
60066: LD_ADDR_VAR 0 4
60070: PUSH
60071: LD_EXP 116
60075: PUSH
60076: LD_VAR 0 1
60080: ARRAY
60081: PPUSH
60082: LD_INT 30
60084: PUSH
60085: LD_VAR 0 2
60089: PUSH
60090: EMPTY
60091: LIST
60092: LIST
60093: PPUSH
60094: CALL_OW 72
60098: ST_TO_ADDR
// if not tmp then
60099: LD_VAR 0 4
60103: NOT
60104: IFFALSE 60108
// exit ;
60106: GO 60168
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
60108: LD_ADDR_EXP 148
60112: PUSH
60113: LD_EXP 148
60117: PPUSH
60118: LD_VAR 0 1
60122: PPUSH
60123: LD_EXP 148
60127: PUSH
60128: LD_VAR 0 1
60132: ARRAY
60133: PPUSH
60134: LD_EXP 148
60138: PUSH
60139: LD_VAR 0 1
60143: ARRAY
60144: PUSH
60145: LD_INT 1
60147: PLUS
60148: PPUSH
60149: LD_VAR 0 4
60153: PUSH
60154: LD_INT 1
60156: ARRAY
60157: PPUSH
60158: CALL_OW 2
60162: PPUSH
60163: CALL_OW 1
60167: ST_TO_ADDR
// end ;
60168: LD_VAR 0 3
60172: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
60173: LD_INT 0
60175: PPUSH
60176: PPUSH
// if not mc_bases or not base or not kinds then
60177: LD_EXP 116
60181: NOT
60182: PUSH
60183: LD_VAR 0 1
60187: NOT
60188: OR
60189: PUSH
60190: LD_VAR 0 2
60194: NOT
60195: OR
60196: IFFALSE 60200
// exit ;
60198: GO 60261
// for i in kinds do
60200: LD_ADDR_VAR 0 4
60204: PUSH
60205: LD_VAR 0 2
60209: PUSH
60210: FOR_IN
60211: IFFALSE 60259
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
60213: LD_ADDR_EXP 150
60217: PUSH
60218: LD_EXP 150
60222: PPUSH
60223: LD_VAR 0 1
60227: PUSH
60228: LD_EXP 150
60232: PUSH
60233: LD_VAR 0 1
60237: ARRAY
60238: PUSH
60239: LD_INT 1
60241: PLUS
60242: PUSH
60243: EMPTY
60244: LIST
60245: LIST
60246: PPUSH
60247: LD_VAR 0 4
60251: PPUSH
60252: CALL 70871 0 3
60256: ST_TO_ADDR
60257: GO 60210
60259: POP
60260: POP
// end ;
60261: LD_VAR 0 3
60265: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
60266: LD_INT 0
60268: PPUSH
// if not mc_bases or not base or not areas then
60269: LD_EXP 116
60273: NOT
60274: PUSH
60275: LD_VAR 0 1
60279: NOT
60280: OR
60281: PUSH
60282: LD_VAR 0 2
60286: NOT
60287: OR
60288: IFFALSE 60292
// exit ;
60290: GO 60317
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
60292: LD_ADDR_EXP 134
60296: PUSH
60297: LD_EXP 134
60301: PPUSH
60302: LD_VAR 0 1
60306: PPUSH
60307: LD_VAR 0 2
60311: PPUSH
60312: CALL_OW 1
60316: ST_TO_ADDR
// end ;
60317: LD_VAR 0 3
60321: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
60322: LD_INT 0
60324: PPUSH
// if not mc_bases or not base or not teleports_exit then
60325: LD_EXP 116
60329: NOT
60330: PUSH
60331: LD_VAR 0 1
60335: NOT
60336: OR
60337: PUSH
60338: LD_VAR 0 2
60342: NOT
60343: OR
60344: IFFALSE 60348
// exit ;
60346: GO 60373
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
60348: LD_ADDR_EXP 151
60352: PUSH
60353: LD_EXP 151
60357: PPUSH
60358: LD_VAR 0 1
60362: PPUSH
60363: LD_VAR 0 2
60367: PPUSH
60368: CALL_OW 1
60372: ST_TO_ADDR
// end ;
60373: LD_VAR 0 3
60377: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
60378: LD_INT 0
60380: PPUSH
60381: PPUSH
60382: PPUSH
// if not mc_bases or not base or not ext_list then
60383: LD_EXP 116
60387: NOT
60388: PUSH
60389: LD_VAR 0 1
60393: NOT
60394: OR
60395: PUSH
60396: LD_VAR 0 5
60400: NOT
60401: OR
60402: IFFALSE 60406
// exit ;
60404: GO 60579
// tmp := GetFacExtXYD ( x , y , d ) ;
60406: LD_ADDR_VAR 0 8
60410: PUSH
60411: LD_VAR 0 2
60415: PPUSH
60416: LD_VAR 0 3
60420: PPUSH
60421: LD_VAR 0 4
60425: PPUSH
60426: CALL 100258 0 3
60430: ST_TO_ADDR
// if not tmp then
60431: LD_VAR 0 8
60435: NOT
60436: IFFALSE 60440
// exit ;
60438: GO 60579
// for i in tmp do
60440: LD_ADDR_VAR 0 7
60444: PUSH
60445: LD_VAR 0 8
60449: PUSH
60450: FOR_IN
60451: IFFALSE 60577
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
60453: LD_ADDR_EXP 121
60457: PUSH
60458: LD_EXP 121
60462: PPUSH
60463: LD_VAR 0 1
60467: PPUSH
60468: LD_EXP 121
60472: PUSH
60473: LD_VAR 0 1
60477: ARRAY
60478: PPUSH
60479: LD_EXP 121
60483: PUSH
60484: LD_VAR 0 1
60488: ARRAY
60489: PUSH
60490: LD_INT 1
60492: PLUS
60493: PPUSH
60494: LD_VAR 0 5
60498: PUSH
60499: LD_INT 1
60501: ARRAY
60502: PUSH
60503: LD_VAR 0 7
60507: PUSH
60508: LD_INT 1
60510: ARRAY
60511: PUSH
60512: LD_VAR 0 7
60516: PUSH
60517: LD_INT 2
60519: ARRAY
60520: PUSH
60521: LD_VAR 0 7
60525: PUSH
60526: LD_INT 3
60528: ARRAY
60529: PUSH
60530: EMPTY
60531: LIST
60532: LIST
60533: LIST
60534: LIST
60535: PPUSH
60536: CALL_OW 2
60540: PPUSH
60541: CALL_OW 1
60545: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
60546: LD_ADDR_VAR 0 5
60550: PUSH
60551: LD_VAR 0 5
60555: PPUSH
60556: LD_INT 1
60558: PPUSH
60559: CALL_OW 3
60563: ST_TO_ADDR
// if not ext_list then
60564: LD_VAR 0 5
60568: NOT
60569: IFFALSE 60575
// exit ;
60571: POP
60572: POP
60573: GO 60579
// end ;
60575: GO 60450
60577: POP
60578: POP
// end ;
60579: LD_VAR 0 6
60583: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
60584: LD_INT 0
60586: PPUSH
// if not mc_bases or not base or not weapon_list then
60587: LD_EXP 116
60591: NOT
60592: PUSH
60593: LD_VAR 0 1
60597: NOT
60598: OR
60599: PUSH
60600: LD_VAR 0 2
60604: NOT
60605: OR
60606: IFFALSE 60610
// exit ;
60608: GO 60635
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
60610: LD_ADDR_EXP 155
60614: PUSH
60615: LD_EXP 155
60619: PPUSH
60620: LD_VAR 0 1
60624: PPUSH
60625: LD_VAR 0 2
60629: PPUSH
60630: CALL_OW 1
60634: ST_TO_ADDR
// end ;
60635: LD_VAR 0 3
60639: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
60640: LD_INT 0
60642: PPUSH
// if not mc_bases or not base or not tech_list then
60643: LD_EXP 116
60647: NOT
60648: PUSH
60649: LD_VAR 0 1
60653: NOT
60654: OR
60655: PUSH
60656: LD_VAR 0 2
60660: NOT
60661: OR
60662: IFFALSE 60666
// exit ;
60664: GO 60691
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
60666: LD_ADDR_EXP 143
60670: PUSH
60671: LD_EXP 143
60675: PPUSH
60676: LD_VAR 0 1
60680: PPUSH
60681: LD_VAR 0 2
60685: PPUSH
60686: CALL_OW 1
60690: ST_TO_ADDR
// end ;
60691: LD_VAR 0 3
60695: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
60696: LD_INT 0
60698: PPUSH
// if not mc_bases or not parking_area or not base then
60699: LD_EXP 116
60703: NOT
60704: PUSH
60705: LD_VAR 0 2
60709: NOT
60710: OR
60711: PUSH
60712: LD_VAR 0 1
60716: NOT
60717: OR
60718: IFFALSE 60722
// exit ;
60720: GO 60747
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
60722: LD_ADDR_EXP 140
60726: PUSH
60727: LD_EXP 140
60731: PPUSH
60732: LD_VAR 0 1
60736: PPUSH
60737: LD_VAR 0 2
60741: PPUSH
60742: CALL_OW 1
60746: ST_TO_ADDR
// end ;
60747: LD_VAR 0 3
60751: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
60752: LD_INT 0
60754: PPUSH
// if not mc_bases or not base or not scan_area then
60755: LD_EXP 116
60759: NOT
60760: PUSH
60761: LD_VAR 0 1
60765: NOT
60766: OR
60767: PUSH
60768: LD_VAR 0 2
60772: NOT
60773: OR
60774: IFFALSE 60778
// exit ;
60776: GO 60803
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
60778: LD_ADDR_EXP 141
60782: PUSH
60783: LD_EXP 141
60787: PPUSH
60788: LD_VAR 0 1
60792: PPUSH
60793: LD_VAR 0 2
60797: PPUSH
60798: CALL_OW 1
60802: ST_TO_ADDR
// end ;
60803: LD_VAR 0 3
60807: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
60808: LD_INT 0
60810: PPUSH
60811: PPUSH
// if not mc_bases or not base then
60812: LD_EXP 116
60816: NOT
60817: PUSH
60818: LD_VAR 0 1
60822: NOT
60823: OR
60824: IFFALSE 60828
// exit ;
60826: GO 60892
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
60828: LD_ADDR_VAR 0 3
60832: PUSH
60833: LD_INT 1
60835: PUSH
60836: LD_INT 2
60838: PUSH
60839: LD_INT 3
60841: PUSH
60842: LD_INT 4
60844: PUSH
60845: LD_INT 11
60847: PUSH
60848: EMPTY
60849: LIST
60850: LIST
60851: LIST
60852: LIST
60853: LIST
60854: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
60855: LD_ADDR_EXP 143
60859: PUSH
60860: LD_EXP 143
60864: PPUSH
60865: LD_VAR 0 1
60869: PPUSH
60870: LD_EXP 143
60874: PUSH
60875: LD_VAR 0 1
60879: ARRAY
60880: PUSH
60881: LD_VAR 0 3
60885: DIFF
60886: PPUSH
60887: CALL_OW 1
60891: ST_TO_ADDR
// end ;
60892: LD_VAR 0 2
60896: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
60897: LD_INT 0
60899: PPUSH
// result := mc_vehicles [ base ] ;
60900: LD_ADDR_VAR 0 3
60904: PUSH
60905: LD_EXP 135
60909: PUSH
60910: LD_VAR 0 1
60914: ARRAY
60915: ST_TO_ADDR
// if onlyCombat then
60916: LD_VAR 0 2
60920: IFFALSE 61098
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
60922: LD_ADDR_VAR 0 3
60926: PUSH
60927: LD_VAR 0 3
60931: PUSH
60932: LD_VAR 0 3
60936: PPUSH
60937: LD_INT 2
60939: PUSH
60940: LD_INT 34
60942: PUSH
60943: LD_INT 12
60945: PUSH
60946: EMPTY
60947: LIST
60948: LIST
60949: PUSH
60950: LD_INT 34
60952: PUSH
60953: LD_INT 51
60955: PUSH
60956: EMPTY
60957: LIST
60958: LIST
60959: PUSH
60960: LD_INT 34
60962: PUSH
60963: LD_EXP 96
60967: PUSH
60968: EMPTY
60969: LIST
60970: LIST
60971: PUSH
60972: LD_INT 34
60974: PUSH
60975: LD_INT 32
60977: PUSH
60978: EMPTY
60979: LIST
60980: LIST
60981: PUSH
60982: LD_INT 34
60984: PUSH
60985: LD_INT 13
60987: PUSH
60988: EMPTY
60989: LIST
60990: LIST
60991: PUSH
60992: LD_INT 34
60994: PUSH
60995: LD_INT 52
60997: PUSH
60998: EMPTY
60999: LIST
61000: LIST
61001: PUSH
61002: LD_INT 34
61004: PUSH
61005: LD_EXP 101
61009: PUSH
61010: EMPTY
61011: LIST
61012: LIST
61013: PUSH
61014: LD_INT 34
61016: PUSH
61017: LD_INT 14
61019: PUSH
61020: EMPTY
61021: LIST
61022: LIST
61023: PUSH
61024: LD_INT 34
61026: PUSH
61027: LD_INT 53
61029: PUSH
61030: EMPTY
61031: LIST
61032: LIST
61033: PUSH
61034: LD_INT 34
61036: PUSH
61037: LD_EXP 95
61041: PUSH
61042: EMPTY
61043: LIST
61044: LIST
61045: PUSH
61046: LD_INT 34
61048: PUSH
61049: LD_INT 31
61051: PUSH
61052: EMPTY
61053: LIST
61054: LIST
61055: PUSH
61056: LD_INT 34
61058: PUSH
61059: LD_INT 48
61061: PUSH
61062: EMPTY
61063: LIST
61064: LIST
61065: PUSH
61066: LD_INT 34
61068: PUSH
61069: LD_INT 8
61071: PUSH
61072: EMPTY
61073: LIST
61074: LIST
61075: PUSH
61076: EMPTY
61077: LIST
61078: LIST
61079: LIST
61080: LIST
61081: LIST
61082: LIST
61083: LIST
61084: LIST
61085: LIST
61086: LIST
61087: LIST
61088: LIST
61089: LIST
61090: LIST
61091: PPUSH
61092: CALL_OW 72
61096: DIFF
61097: ST_TO_ADDR
// end ; end_of_file
61098: LD_VAR 0 3
61102: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
61103: LD_INT 0
61105: PPUSH
61106: PPUSH
61107: PPUSH
// if not mc_bases or not skirmish then
61108: LD_EXP 116
61112: NOT
61113: PUSH
61114: LD_EXP 114
61118: NOT
61119: OR
61120: IFFALSE 61124
// exit ;
61122: GO 61289
// for i = 1 to mc_bases do
61124: LD_ADDR_VAR 0 4
61128: PUSH
61129: DOUBLE
61130: LD_INT 1
61132: DEC
61133: ST_TO_ADDR
61134: LD_EXP 116
61138: PUSH
61139: FOR_TO
61140: IFFALSE 61287
// begin if sci in mc_bases [ i ] then
61142: LD_VAR 0 2
61146: PUSH
61147: LD_EXP 116
61151: PUSH
61152: LD_VAR 0 4
61156: ARRAY
61157: IN
61158: IFFALSE 61285
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
61160: LD_ADDR_EXP 145
61164: PUSH
61165: LD_EXP 145
61169: PPUSH
61170: LD_VAR 0 4
61174: PUSH
61175: LD_EXP 145
61179: PUSH
61180: LD_VAR 0 4
61184: ARRAY
61185: PUSH
61186: LD_INT 1
61188: PLUS
61189: PUSH
61190: EMPTY
61191: LIST
61192: LIST
61193: PPUSH
61194: LD_VAR 0 1
61198: PPUSH
61199: CALL 70871 0 3
61203: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
61204: LD_ADDR_VAR 0 5
61208: PUSH
61209: LD_EXP 116
61213: PUSH
61214: LD_VAR 0 4
61218: ARRAY
61219: PPUSH
61220: LD_INT 2
61222: PUSH
61223: LD_INT 30
61225: PUSH
61226: LD_INT 0
61228: PUSH
61229: EMPTY
61230: LIST
61231: LIST
61232: PUSH
61233: LD_INT 30
61235: PUSH
61236: LD_INT 1
61238: PUSH
61239: EMPTY
61240: LIST
61241: LIST
61242: PUSH
61243: EMPTY
61244: LIST
61245: LIST
61246: LIST
61247: PPUSH
61248: CALL_OW 72
61252: PPUSH
61253: LD_VAR 0 1
61257: PPUSH
61258: CALL_OW 74
61262: ST_TO_ADDR
// if tmp then
61263: LD_VAR 0 5
61267: IFFALSE 61283
// ComStandNearbyBuilding ( ape , tmp ) ;
61269: LD_VAR 0 1
61273: PPUSH
61274: LD_VAR 0 5
61278: PPUSH
61279: CALL 67449 0 2
// break ;
61283: GO 61287
// end ; end ;
61285: GO 61139
61287: POP
61288: POP
// end ;
61289: LD_VAR 0 3
61293: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
61294: LD_INT 0
61296: PPUSH
61297: PPUSH
61298: PPUSH
// if not mc_bases or not skirmish then
61299: LD_EXP 116
61303: NOT
61304: PUSH
61305: LD_EXP 114
61309: NOT
61310: OR
61311: IFFALSE 61315
// exit ;
61313: GO 61404
// for i = 1 to mc_bases do
61315: LD_ADDR_VAR 0 4
61319: PUSH
61320: DOUBLE
61321: LD_INT 1
61323: DEC
61324: ST_TO_ADDR
61325: LD_EXP 116
61329: PUSH
61330: FOR_TO
61331: IFFALSE 61402
// begin if building in mc_busy_turret_list [ i ] then
61333: LD_VAR 0 1
61337: PUSH
61338: LD_EXP 126
61342: PUSH
61343: LD_VAR 0 4
61347: ARRAY
61348: IN
61349: IFFALSE 61400
// begin tmp := mc_busy_turret_list [ i ] diff building ;
61351: LD_ADDR_VAR 0 5
61355: PUSH
61356: LD_EXP 126
61360: PUSH
61361: LD_VAR 0 4
61365: ARRAY
61366: PUSH
61367: LD_VAR 0 1
61371: DIFF
61372: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
61373: LD_ADDR_EXP 126
61377: PUSH
61378: LD_EXP 126
61382: PPUSH
61383: LD_VAR 0 4
61387: PPUSH
61388: LD_VAR 0 5
61392: PPUSH
61393: CALL_OW 1
61397: ST_TO_ADDR
// break ;
61398: GO 61402
// end ; end ;
61400: GO 61330
61402: POP
61403: POP
// end ;
61404: LD_VAR 0 3
61408: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
61409: LD_INT 0
61411: PPUSH
61412: PPUSH
61413: PPUSH
// if not mc_bases or not skirmish then
61414: LD_EXP 116
61418: NOT
61419: PUSH
61420: LD_EXP 114
61424: NOT
61425: OR
61426: IFFALSE 61430
// exit ;
61428: GO 61629
// for i = 1 to mc_bases do
61430: LD_ADDR_VAR 0 5
61434: PUSH
61435: DOUBLE
61436: LD_INT 1
61438: DEC
61439: ST_TO_ADDR
61440: LD_EXP 116
61444: PUSH
61445: FOR_TO
61446: IFFALSE 61627
// if building in mc_bases [ i ] then
61448: LD_VAR 0 1
61452: PUSH
61453: LD_EXP 116
61457: PUSH
61458: LD_VAR 0 5
61462: ARRAY
61463: IN
61464: IFFALSE 61625
// begin tmp := mc_bases [ i ] diff building ;
61466: LD_ADDR_VAR 0 6
61470: PUSH
61471: LD_EXP 116
61475: PUSH
61476: LD_VAR 0 5
61480: ARRAY
61481: PUSH
61482: LD_VAR 0 1
61486: DIFF
61487: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
61488: LD_ADDR_EXP 116
61492: PUSH
61493: LD_EXP 116
61497: PPUSH
61498: LD_VAR 0 5
61502: PPUSH
61503: LD_VAR 0 6
61507: PPUSH
61508: CALL_OW 1
61512: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
61513: LD_VAR 0 1
61517: PUSH
61518: LD_EXP 124
61522: PUSH
61523: LD_VAR 0 5
61527: ARRAY
61528: IN
61529: IFFALSE 61568
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
61531: LD_ADDR_EXP 124
61535: PUSH
61536: LD_EXP 124
61540: PPUSH
61541: LD_VAR 0 5
61545: PPUSH
61546: LD_EXP 124
61550: PUSH
61551: LD_VAR 0 5
61555: ARRAY
61556: PUSH
61557: LD_VAR 0 1
61561: DIFF
61562: PPUSH
61563: CALL_OW 1
61567: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
61568: LD_VAR 0 1
61572: PUSH
61573: LD_EXP 125
61577: PUSH
61578: LD_VAR 0 5
61582: ARRAY
61583: IN
61584: IFFALSE 61623
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
61586: LD_ADDR_EXP 125
61590: PUSH
61591: LD_EXP 125
61595: PPUSH
61596: LD_VAR 0 5
61600: PPUSH
61601: LD_EXP 125
61605: PUSH
61606: LD_VAR 0 5
61610: ARRAY
61611: PUSH
61612: LD_VAR 0 1
61616: DIFF
61617: PPUSH
61618: CALL_OW 1
61622: ST_TO_ADDR
// break ;
61623: GO 61627
// end ;
61625: GO 61445
61627: POP
61628: POP
// end ;
61629: LD_VAR 0 4
61633: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
61634: LD_INT 0
61636: PPUSH
61637: PPUSH
61638: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
61639: LD_EXP 116
61643: NOT
61644: PUSH
61645: LD_EXP 114
61649: NOT
61650: OR
61651: PUSH
61652: LD_VAR 0 3
61656: PUSH
61657: LD_EXP 142
61661: IN
61662: NOT
61663: OR
61664: IFFALSE 61668
// exit ;
61666: GO 61791
// for i = 1 to mc_vehicles do
61668: LD_ADDR_VAR 0 6
61672: PUSH
61673: DOUBLE
61674: LD_INT 1
61676: DEC
61677: ST_TO_ADDR
61678: LD_EXP 135
61682: PUSH
61683: FOR_TO
61684: IFFALSE 61789
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
61686: LD_VAR 0 2
61690: PUSH
61691: LD_EXP 135
61695: PUSH
61696: LD_VAR 0 6
61700: ARRAY
61701: IN
61702: PUSH
61703: LD_VAR 0 1
61707: PUSH
61708: LD_EXP 135
61712: PUSH
61713: LD_VAR 0 6
61717: ARRAY
61718: IN
61719: OR
61720: IFFALSE 61787
// begin tmp := mc_vehicles [ i ] diff old ;
61722: LD_ADDR_VAR 0 7
61726: PUSH
61727: LD_EXP 135
61731: PUSH
61732: LD_VAR 0 6
61736: ARRAY
61737: PUSH
61738: LD_VAR 0 2
61742: DIFF
61743: ST_TO_ADDR
// tmp := tmp diff new ;
61744: LD_ADDR_VAR 0 7
61748: PUSH
61749: LD_VAR 0 7
61753: PUSH
61754: LD_VAR 0 1
61758: DIFF
61759: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
61760: LD_ADDR_EXP 135
61764: PUSH
61765: LD_EXP 135
61769: PPUSH
61770: LD_VAR 0 6
61774: PPUSH
61775: LD_VAR 0 7
61779: PPUSH
61780: CALL_OW 1
61784: ST_TO_ADDR
// break ;
61785: GO 61789
// end ;
61787: GO 61683
61789: POP
61790: POP
// end ;
61791: LD_VAR 0 5
61795: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
61796: LD_INT 0
61798: PPUSH
61799: PPUSH
61800: PPUSH
61801: PPUSH
// if not mc_bases or not skirmish then
61802: LD_EXP 116
61806: NOT
61807: PUSH
61808: LD_EXP 114
61812: NOT
61813: OR
61814: IFFALSE 61818
// exit ;
61816: GO 62210
// side := GetSide ( vehicle ) ;
61818: LD_ADDR_VAR 0 5
61822: PUSH
61823: LD_VAR 0 1
61827: PPUSH
61828: CALL_OW 255
61832: ST_TO_ADDR
// for i = 1 to mc_bases do
61833: LD_ADDR_VAR 0 4
61837: PUSH
61838: DOUBLE
61839: LD_INT 1
61841: DEC
61842: ST_TO_ADDR
61843: LD_EXP 116
61847: PUSH
61848: FOR_TO
61849: IFFALSE 62208
// begin if factory in mc_bases [ i ] then
61851: LD_VAR 0 2
61855: PUSH
61856: LD_EXP 116
61860: PUSH
61861: LD_VAR 0 4
61865: ARRAY
61866: IN
61867: IFFALSE 62206
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
61869: LD_EXP 138
61873: PUSH
61874: LD_VAR 0 4
61878: ARRAY
61879: PUSH
61880: LD_EXP 127
61884: PUSH
61885: LD_VAR 0 4
61889: ARRAY
61890: LESS
61891: PUSH
61892: LD_VAR 0 1
61896: PPUSH
61897: CALL_OW 264
61901: PUSH
61902: LD_INT 31
61904: PUSH
61905: LD_INT 32
61907: PUSH
61908: LD_INT 51
61910: PUSH
61911: LD_EXP 96
61915: PUSH
61916: LD_INT 12
61918: PUSH
61919: LD_INT 30
61921: PUSH
61922: LD_EXP 95
61926: PUSH
61927: LD_INT 11
61929: PUSH
61930: LD_INT 53
61932: PUSH
61933: LD_INT 14
61935: PUSH
61936: LD_EXP 99
61940: PUSH
61941: LD_INT 29
61943: PUSH
61944: LD_EXP 97
61948: PUSH
61949: LD_INT 13
61951: PUSH
61952: LD_INT 52
61954: PUSH
61955: LD_EXP 101
61959: PUSH
61960: LD_INT 48
61962: PUSH
61963: LD_INT 8
61965: PUSH
61966: EMPTY
61967: LIST
61968: LIST
61969: LIST
61970: LIST
61971: LIST
61972: LIST
61973: LIST
61974: LIST
61975: LIST
61976: LIST
61977: LIST
61978: LIST
61979: LIST
61980: LIST
61981: LIST
61982: LIST
61983: LIST
61984: LIST
61985: IN
61986: NOT
61987: AND
61988: IFFALSE 62036
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
61990: LD_ADDR_EXP 138
61994: PUSH
61995: LD_EXP 138
61999: PPUSH
62000: LD_VAR 0 4
62004: PUSH
62005: LD_EXP 138
62009: PUSH
62010: LD_VAR 0 4
62014: ARRAY
62015: PUSH
62016: LD_INT 1
62018: PLUS
62019: PUSH
62020: EMPTY
62021: LIST
62022: LIST
62023: PPUSH
62024: LD_VAR 0 1
62028: PPUSH
62029: CALL 70871 0 3
62033: ST_TO_ADDR
62034: GO 62080
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
62036: LD_ADDR_EXP 135
62040: PUSH
62041: LD_EXP 135
62045: PPUSH
62046: LD_VAR 0 4
62050: PUSH
62051: LD_EXP 135
62055: PUSH
62056: LD_VAR 0 4
62060: ARRAY
62061: PUSH
62062: LD_INT 1
62064: PLUS
62065: PUSH
62066: EMPTY
62067: LIST
62068: LIST
62069: PPUSH
62070: LD_VAR 0 1
62074: PPUSH
62075: CALL 70871 0 3
62079: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
62080: LD_VAR 0 1
62084: PPUSH
62085: CALL_OW 263
62089: PUSH
62090: LD_INT 2
62092: EQUAL
62093: IFFALSE 62122
// begin repeat wait ( 0 0$3 ) ;
62095: LD_INT 105
62097: PPUSH
62098: CALL_OW 67
// Connect ( vehicle ) ;
62102: LD_VAR 0 1
62106: PPUSH
62107: CALL 73842 0 1
// until IsControledBy ( vehicle ) ;
62111: LD_VAR 0 1
62115: PPUSH
62116: CALL_OW 312
62120: IFFALSE 62095
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
62122: LD_VAR 0 1
62126: PPUSH
62127: LD_EXP 140
62131: PUSH
62132: LD_VAR 0 4
62136: ARRAY
62137: PPUSH
62138: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
62142: LD_VAR 0 1
62146: PPUSH
62147: CALL_OW 263
62151: PUSH
62152: LD_INT 1
62154: NONEQUAL
62155: IFFALSE 62159
// break ;
62157: GO 62208
// repeat wait ( 0 0$1 ) ;
62159: LD_INT 35
62161: PPUSH
62162: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
62166: LD_VAR 0 1
62170: PPUSH
62171: LD_EXP 140
62175: PUSH
62176: LD_VAR 0 4
62180: ARRAY
62181: PPUSH
62182: CALL_OW 308
62186: IFFALSE 62159
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
62188: LD_VAR 0 1
62192: PPUSH
62193: CALL_OW 311
62197: PPUSH
62198: CALL_OW 121
// exit ;
62202: POP
62203: POP
62204: GO 62210
// end ; end ;
62206: GO 61848
62208: POP
62209: POP
// end ;
62210: LD_VAR 0 3
62214: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
62215: LD_INT 0
62217: PPUSH
62218: PPUSH
62219: PPUSH
62220: PPUSH
// if not mc_bases or not skirmish then
62221: LD_EXP 116
62225: NOT
62226: PUSH
62227: LD_EXP 114
62231: NOT
62232: OR
62233: IFFALSE 62237
// exit ;
62235: GO 62590
// repeat wait ( 0 0$1 ) ;
62237: LD_INT 35
62239: PPUSH
62240: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
62244: LD_VAR 0 2
62248: PPUSH
62249: LD_VAR 0 3
62253: PPUSH
62254: CALL_OW 284
62258: IFFALSE 62237
// if GetResourceTypeXY ( x , y ) = mat_artefact then
62260: LD_VAR 0 2
62264: PPUSH
62265: LD_VAR 0 3
62269: PPUSH
62270: CALL_OW 283
62274: PUSH
62275: LD_INT 4
62277: EQUAL
62278: IFFALSE 62282
// exit ;
62280: GO 62590
// for i = 1 to mc_bases do
62282: LD_ADDR_VAR 0 7
62286: PUSH
62287: DOUBLE
62288: LD_INT 1
62290: DEC
62291: ST_TO_ADDR
62292: LD_EXP 116
62296: PUSH
62297: FOR_TO
62298: IFFALSE 62588
// begin if mc_crates_area [ i ] then
62300: LD_EXP 134
62304: PUSH
62305: LD_VAR 0 7
62309: ARRAY
62310: IFFALSE 62421
// for j in mc_crates_area [ i ] do
62312: LD_ADDR_VAR 0 8
62316: PUSH
62317: LD_EXP 134
62321: PUSH
62322: LD_VAR 0 7
62326: ARRAY
62327: PUSH
62328: FOR_IN
62329: IFFALSE 62419
// if InArea ( x , y , j ) then
62331: LD_VAR 0 2
62335: PPUSH
62336: LD_VAR 0 3
62340: PPUSH
62341: LD_VAR 0 8
62345: PPUSH
62346: CALL_OW 309
62350: IFFALSE 62417
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62352: LD_ADDR_EXP 132
62356: PUSH
62357: LD_EXP 132
62361: PPUSH
62362: LD_VAR 0 7
62366: PUSH
62367: LD_EXP 132
62371: PUSH
62372: LD_VAR 0 7
62376: ARRAY
62377: PUSH
62378: LD_INT 1
62380: PLUS
62381: PUSH
62382: EMPTY
62383: LIST
62384: LIST
62385: PPUSH
62386: LD_VAR 0 4
62390: PUSH
62391: LD_VAR 0 2
62395: PUSH
62396: LD_VAR 0 3
62400: PUSH
62401: EMPTY
62402: LIST
62403: LIST
62404: LIST
62405: PPUSH
62406: CALL 70871 0 3
62410: ST_TO_ADDR
// exit ;
62411: POP
62412: POP
62413: POP
62414: POP
62415: GO 62590
// end ;
62417: GO 62328
62419: POP
62420: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62421: LD_ADDR_VAR 0 9
62425: PUSH
62426: LD_EXP 116
62430: PUSH
62431: LD_VAR 0 7
62435: ARRAY
62436: PPUSH
62437: LD_INT 2
62439: PUSH
62440: LD_INT 30
62442: PUSH
62443: LD_INT 0
62445: PUSH
62446: EMPTY
62447: LIST
62448: LIST
62449: PUSH
62450: LD_INT 30
62452: PUSH
62453: LD_INT 1
62455: PUSH
62456: EMPTY
62457: LIST
62458: LIST
62459: PUSH
62460: EMPTY
62461: LIST
62462: LIST
62463: LIST
62464: PPUSH
62465: CALL_OW 72
62469: ST_TO_ADDR
// if not depot then
62470: LD_VAR 0 9
62474: NOT
62475: IFFALSE 62479
// continue ;
62477: GO 62297
// for j in depot do
62479: LD_ADDR_VAR 0 8
62483: PUSH
62484: LD_VAR 0 9
62488: PUSH
62489: FOR_IN
62490: IFFALSE 62584
// if GetDistUnitXY ( j , x , y ) < 30 then
62492: LD_VAR 0 8
62496: PPUSH
62497: LD_VAR 0 2
62501: PPUSH
62502: LD_VAR 0 3
62506: PPUSH
62507: CALL_OW 297
62511: PUSH
62512: LD_INT 30
62514: LESS
62515: IFFALSE 62582
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
62517: LD_ADDR_EXP 132
62521: PUSH
62522: LD_EXP 132
62526: PPUSH
62527: LD_VAR 0 7
62531: PUSH
62532: LD_EXP 132
62536: PUSH
62537: LD_VAR 0 7
62541: ARRAY
62542: PUSH
62543: LD_INT 1
62545: PLUS
62546: PUSH
62547: EMPTY
62548: LIST
62549: LIST
62550: PPUSH
62551: LD_VAR 0 4
62555: PUSH
62556: LD_VAR 0 2
62560: PUSH
62561: LD_VAR 0 3
62565: PUSH
62566: EMPTY
62567: LIST
62568: LIST
62569: LIST
62570: PPUSH
62571: CALL 70871 0 3
62575: ST_TO_ADDR
// exit ;
62576: POP
62577: POP
62578: POP
62579: POP
62580: GO 62590
// end ;
62582: GO 62489
62584: POP
62585: POP
// end ;
62586: GO 62297
62588: POP
62589: POP
// end ;
62590: LD_VAR 0 6
62594: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
62595: LD_INT 0
62597: PPUSH
62598: PPUSH
62599: PPUSH
62600: PPUSH
// if not mc_bases or not skirmish then
62601: LD_EXP 116
62605: NOT
62606: PUSH
62607: LD_EXP 114
62611: NOT
62612: OR
62613: IFFALSE 62617
// exit ;
62615: GO 62894
// side := GetSide ( lab ) ;
62617: LD_ADDR_VAR 0 4
62621: PUSH
62622: LD_VAR 0 2
62626: PPUSH
62627: CALL_OW 255
62631: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
62632: LD_VAR 0 4
62636: PUSH
62637: LD_EXP 142
62641: IN
62642: NOT
62643: PUSH
62644: LD_EXP 143
62648: NOT
62649: OR
62650: PUSH
62651: LD_EXP 116
62655: NOT
62656: OR
62657: IFFALSE 62661
// exit ;
62659: GO 62894
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
62661: LD_ADDR_EXP 143
62665: PUSH
62666: LD_EXP 143
62670: PPUSH
62671: LD_VAR 0 4
62675: PPUSH
62676: LD_EXP 143
62680: PUSH
62681: LD_VAR 0 4
62685: ARRAY
62686: PUSH
62687: LD_VAR 0 1
62691: DIFF
62692: PPUSH
62693: CALL_OW 1
62697: ST_TO_ADDR
// for i = 1 to mc_bases do
62698: LD_ADDR_VAR 0 5
62702: PUSH
62703: DOUBLE
62704: LD_INT 1
62706: DEC
62707: ST_TO_ADDR
62708: LD_EXP 116
62712: PUSH
62713: FOR_TO
62714: IFFALSE 62892
// begin if lab in mc_bases [ i ] then
62716: LD_VAR 0 2
62720: PUSH
62721: LD_EXP 116
62725: PUSH
62726: LD_VAR 0 5
62730: ARRAY
62731: IN
62732: IFFALSE 62890
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
62734: LD_VAR 0 1
62738: PUSH
62739: LD_INT 11
62741: PUSH
62742: LD_INT 4
62744: PUSH
62745: LD_INT 3
62747: PUSH
62748: LD_INT 2
62750: PUSH
62751: EMPTY
62752: LIST
62753: LIST
62754: LIST
62755: LIST
62756: IN
62757: PUSH
62758: LD_EXP 146
62762: PUSH
62763: LD_VAR 0 5
62767: ARRAY
62768: AND
62769: IFFALSE 62890
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
62771: LD_ADDR_VAR 0 6
62775: PUSH
62776: LD_EXP 146
62780: PUSH
62781: LD_VAR 0 5
62785: ARRAY
62786: PUSH
62787: LD_INT 1
62789: ARRAY
62790: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
62791: LD_ADDR_EXP 146
62795: PUSH
62796: LD_EXP 146
62800: PPUSH
62801: LD_VAR 0 5
62805: PPUSH
62806: EMPTY
62807: PPUSH
62808: CALL_OW 1
62812: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
62813: LD_VAR 0 6
62817: PPUSH
62818: LD_INT 0
62820: PPUSH
62821: CALL_OW 109
// ComExitBuilding ( tmp ) ;
62825: LD_VAR 0 6
62829: PPUSH
62830: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
62834: LD_ADDR_EXP 145
62838: PUSH
62839: LD_EXP 145
62843: PPUSH
62844: LD_VAR 0 5
62848: PPUSH
62849: LD_EXP 145
62853: PUSH
62854: LD_VAR 0 5
62858: ARRAY
62859: PPUSH
62860: LD_INT 1
62862: PPUSH
62863: LD_VAR 0 6
62867: PPUSH
62868: CALL_OW 2
62872: PPUSH
62873: CALL_OW 1
62877: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
62878: LD_VAR 0 5
62882: PPUSH
62883: LD_INT 112
62885: PPUSH
62886: CALL 39413 0 2
// end ; end ; end ;
62890: GO 62713
62892: POP
62893: POP
// end ;
62894: LD_VAR 0 3
62898: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
62899: LD_INT 0
62901: PPUSH
62902: PPUSH
62903: PPUSH
62904: PPUSH
62905: PPUSH
62906: PPUSH
62907: PPUSH
62908: PPUSH
// if not mc_bases or not skirmish then
62909: LD_EXP 116
62913: NOT
62914: PUSH
62915: LD_EXP 114
62919: NOT
62920: OR
62921: IFFALSE 62925
// exit ;
62923: GO 64296
// for i = 1 to mc_bases do
62925: LD_ADDR_VAR 0 3
62929: PUSH
62930: DOUBLE
62931: LD_INT 1
62933: DEC
62934: ST_TO_ADDR
62935: LD_EXP 116
62939: PUSH
62940: FOR_TO
62941: IFFALSE 64294
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
62943: LD_VAR 0 1
62947: PUSH
62948: LD_EXP 116
62952: PUSH
62953: LD_VAR 0 3
62957: ARRAY
62958: IN
62959: PUSH
62960: LD_VAR 0 1
62964: PUSH
62965: LD_EXP 123
62969: PUSH
62970: LD_VAR 0 3
62974: ARRAY
62975: IN
62976: OR
62977: PUSH
62978: LD_VAR 0 1
62982: PUSH
62983: LD_EXP 138
62987: PUSH
62988: LD_VAR 0 3
62992: ARRAY
62993: IN
62994: OR
62995: PUSH
62996: LD_VAR 0 1
63000: PUSH
63001: LD_EXP 135
63005: PUSH
63006: LD_VAR 0 3
63010: ARRAY
63011: IN
63012: OR
63013: PUSH
63014: LD_VAR 0 1
63018: PUSH
63019: LD_EXP 145
63023: PUSH
63024: LD_VAR 0 3
63028: ARRAY
63029: IN
63030: OR
63031: PUSH
63032: LD_VAR 0 1
63036: PUSH
63037: LD_EXP 146
63041: PUSH
63042: LD_VAR 0 3
63046: ARRAY
63047: IN
63048: OR
63049: IFFALSE 64292
// begin if un in mc_ape [ i ] then
63051: LD_VAR 0 1
63055: PUSH
63056: LD_EXP 145
63060: PUSH
63061: LD_VAR 0 3
63065: ARRAY
63066: IN
63067: IFFALSE 63106
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
63069: LD_ADDR_EXP 145
63073: PUSH
63074: LD_EXP 145
63078: PPUSH
63079: LD_VAR 0 3
63083: PPUSH
63084: LD_EXP 145
63088: PUSH
63089: LD_VAR 0 3
63093: ARRAY
63094: PUSH
63095: LD_VAR 0 1
63099: DIFF
63100: PPUSH
63101: CALL_OW 1
63105: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
63106: LD_VAR 0 1
63110: PUSH
63111: LD_EXP 146
63115: PUSH
63116: LD_VAR 0 3
63120: ARRAY
63121: IN
63122: IFFALSE 63146
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63124: LD_ADDR_EXP 146
63128: PUSH
63129: LD_EXP 146
63133: PPUSH
63134: LD_VAR 0 3
63138: PPUSH
63139: EMPTY
63140: PPUSH
63141: CALL_OW 1
63145: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
63146: LD_VAR 0 1
63150: PPUSH
63151: CALL_OW 247
63155: PUSH
63156: LD_INT 2
63158: EQUAL
63159: PUSH
63160: LD_VAR 0 1
63164: PPUSH
63165: CALL_OW 110
63169: PUSH
63170: LD_INT 20
63172: EQUAL
63173: PUSH
63174: LD_VAR 0 1
63178: PUSH
63179: LD_EXP 138
63183: PUSH
63184: LD_VAR 0 3
63188: ARRAY
63189: IN
63190: OR
63191: PUSH
63192: LD_VAR 0 1
63196: PPUSH
63197: CALL_OW 264
63201: PUSH
63202: LD_INT 12
63204: PUSH
63205: LD_INT 51
63207: PUSH
63208: LD_EXP 96
63212: PUSH
63213: LD_INT 32
63215: PUSH
63216: LD_INT 13
63218: PUSH
63219: LD_INT 52
63221: PUSH
63222: LD_INT 31
63224: PUSH
63225: EMPTY
63226: LIST
63227: LIST
63228: LIST
63229: LIST
63230: LIST
63231: LIST
63232: LIST
63233: IN
63234: OR
63235: AND
63236: IFFALSE 63544
// begin if un in mc_defender [ i ] then
63238: LD_VAR 0 1
63242: PUSH
63243: LD_EXP 138
63247: PUSH
63248: LD_VAR 0 3
63252: ARRAY
63253: IN
63254: IFFALSE 63293
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
63256: LD_ADDR_EXP 138
63260: PUSH
63261: LD_EXP 138
63265: PPUSH
63266: LD_VAR 0 3
63270: PPUSH
63271: LD_EXP 138
63275: PUSH
63276: LD_VAR 0 3
63280: ARRAY
63281: PUSH
63282: LD_VAR 0 1
63286: DIFF
63287: PPUSH
63288: CALL_OW 1
63292: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
63293: LD_ADDR_VAR 0 8
63297: PUSH
63298: LD_VAR 0 3
63302: PPUSH
63303: LD_INT 3
63305: PPUSH
63306: CALL 59934 0 2
63310: ST_TO_ADDR
// if fac then
63311: LD_VAR 0 8
63315: IFFALSE 63544
// begin for j in fac do
63317: LD_ADDR_VAR 0 4
63321: PUSH
63322: LD_VAR 0 8
63326: PUSH
63327: FOR_IN
63328: IFFALSE 63542
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
63330: LD_ADDR_VAR 0 9
63334: PUSH
63335: LD_VAR 0 8
63339: PPUSH
63340: LD_VAR 0 1
63344: PPUSH
63345: CALL_OW 265
63349: PPUSH
63350: LD_VAR 0 1
63354: PPUSH
63355: CALL_OW 262
63359: PPUSH
63360: LD_VAR 0 1
63364: PPUSH
63365: CALL_OW 263
63369: PPUSH
63370: LD_VAR 0 1
63374: PPUSH
63375: CALL_OW 264
63379: PPUSH
63380: CALL 68367 0 5
63384: ST_TO_ADDR
// if components then
63385: LD_VAR 0 9
63389: IFFALSE 63540
// begin if GetWeapon ( un ) = ar_control_tower then
63391: LD_VAR 0 1
63395: PPUSH
63396: CALL_OW 264
63400: PUSH
63401: LD_INT 31
63403: EQUAL
63404: IFFALSE 63521
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
63406: LD_VAR 0 1
63410: PPUSH
63411: CALL_OW 311
63415: PPUSH
63416: LD_INT 0
63418: PPUSH
63419: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
63423: LD_ADDR_EXP 156
63427: PUSH
63428: LD_EXP 156
63432: PPUSH
63433: LD_VAR 0 3
63437: PPUSH
63438: LD_EXP 156
63442: PUSH
63443: LD_VAR 0 3
63447: ARRAY
63448: PUSH
63449: LD_VAR 0 1
63453: PPUSH
63454: CALL_OW 311
63458: DIFF
63459: PPUSH
63460: CALL_OW 1
63464: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
63465: LD_ADDR_VAR 0 7
63469: PUSH
63470: LD_EXP 137
63474: PUSH
63475: LD_VAR 0 3
63479: ARRAY
63480: PPUSH
63481: LD_INT 1
63483: PPUSH
63484: LD_VAR 0 9
63488: PPUSH
63489: CALL_OW 2
63493: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
63494: LD_ADDR_EXP 137
63498: PUSH
63499: LD_EXP 137
63503: PPUSH
63504: LD_VAR 0 3
63508: PPUSH
63509: LD_VAR 0 7
63513: PPUSH
63514: CALL_OW 1
63518: ST_TO_ADDR
// end else
63519: GO 63538
// MC_InsertProduceList ( i , [ components ] ) ;
63521: LD_VAR 0 3
63525: PPUSH
63526: LD_VAR 0 9
63530: PUSH
63531: EMPTY
63532: LIST
63533: PPUSH
63534: CALL 59479 0 2
// break ;
63538: GO 63542
// end ; end ;
63540: GO 63327
63542: POP
63543: POP
// end ; end ; if GetType ( un ) = unit_building then
63544: LD_VAR 0 1
63548: PPUSH
63549: CALL_OW 247
63553: PUSH
63554: LD_INT 3
63556: EQUAL
63557: IFFALSE 63960
// begin btype := GetBType ( un ) ;
63559: LD_ADDR_VAR 0 5
63563: PUSH
63564: LD_VAR 0 1
63568: PPUSH
63569: CALL_OW 266
63573: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
63574: LD_VAR 0 5
63578: PUSH
63579: LD_INT 29
63581: PUSH
63582: LD_INT 30
63584: PUSH
63585: EMPTY
63586: LIST
63587: LIST
63588: IN
63589: IFFALSE 63662
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
63591: LD_VAR 0 1
63595: PPUSH
63596: CALL_OW 250
63600: PPUSH
63601: LD_VAR 0 1
63605: PPUSH
63606: CALL_OW 251
63610: PPUSH
63611: LD_VAR 0 1
63615: PPUSH
63616: CALL_OW 255
63620: PPUSH
63621: CALL_OW 440
63625: NOT
63626: IFFALSE 63662
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
63628: LD_VAR 0 1
63632: PPUSH
63633: CALL_OW 250
63637: PPUSH
63638: LD_VAR 0 1
63642: PPUSH
63643: CALL_OW 251
63647: PPUSH
63648: LD_VAR 0 1
63652: PPUSH
63653: CALL_OW 255
63657: PPUSH
63658: CALL_OW 441
// end ; if btype = b_warehouse then
63662: LD_VAR 0 5
63666: PUSH
63667: LD_INT 1
63669: EQUAL
63670: IFFALSE 63688
// begin btype := b_depot ;
63672: LD_ADDR_VAR 0 5
63676: PUSH
63677: LD_INT 0
63679: ST_TO_ADDR
// pos := 1 ;
63680: LD_ADDR_VAR 0 6
63684: PUSH
63685: LD_INT 1
63687: ST_TO_ADDR
// end ; if btype = b_factory then
63688: LD_VAR 0 5
63692: PUSH
63693: LD_INT 3
63695: EQUAL
63696: IFFALSE 63714
// begin btype := b_workshop ;
63698: LD_ADDR_VAR 0 5
63702: PUSH
63703: LD_INT 2
63705: ST_TO_ADDR
// pos := 1 ;
63706: LD_ADDR_VAR 0 6
63710: PUSH
63711: LD_INT 1
63713: ST_TO_ADDR
// end ; if btype = b_barracks then
63714: LD_VAR 0 5
63718: PUSH
63719: LD_INT 5
63721: EQUAL
63722: IFFALSE 63732
// btype := b_armoury ;
63724: LD_ADDR_VAR 0 5
63728: PUSH
63729: LD_INT 4
63731: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
63732: LD_VAR 0 5
63736: PUSH
63737: LD_INT 7
63739: PUSH
63740: LD_INT 8
63742: PUSH
63743: EMPTY
63744: LIST
63745: LIST
63746: IN
63747: IFFALSE 63757
// btype := b_lab ;
63749: LD_ADDR_VAR 0 5
63753: PUSH
63754: LD_INT 6
63756: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
63757: LD_ADDR_EXP 121
63761: PUSH
63762: LD_EXP 121
63766: PPUSH
63767: LD_VAR 0 3
63771: PUSH
63772: LD_EXP 121
63776: PUSH
63777: LD_VAR 0 3
63781: ARRAY
63782: PUSH
63783: LD_INT 1
63785: PLUS
63786: PUSH
63787: EMPTY
63788: LIST
63789: LIST
63790: PPUSH
63791: LD_VAR 0 5
63795: PUSH
63796: LD_VAR 0 1
63800: PPUSH
63801: CALL_OW 250
63805: PUSH
63806: LD_VAR 0 1
63810: PPUSH
63811: CALL_OW 251
63815: PUSH
63816: LD_VAR 0 1
63820: PPUSH
63821: CALL_OW 254
63825: PUSH
63826: EMPTY
63827: LIST
63828: LIST
63829: LIST
63830: LIST
63831: PPUSH
63832: CALL 70871 0 3
63836: ST_TO_ADDR
// if pos = 1 then
63837: LD_VAR 0 6
63841: PUSH
63842: LD_INT 1
63844: EQUAL
63845: IFFALSE 63960
// begin tmp := mc_build_list [ i ] ;
63847: LD_ADDR_VAR 0 7
63851: PUSH
63852: LD_EXP 121
63856: PUSH
63857: LD_VAR 0 3
63861: ARRAY
63862: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
63863: LD_VAR 0 7
63867: PPUSH
63868: LD_INT 2
63870: PUSH
63871: LD_INT 30
63873: PUSH
63874: LD_INT 0
63876: PUSH
63877: EMPTY
63878: LIST
63879: LIST
63880: PUSH
63881: LD_INT 30
63883: PUSH
63884: LD_INT 1
63886: PUSH
63887: EMPTY
63888: LIST
63889: LIST
63890: PUSH
63891: EMPTY
63892: LIST
63893: LIST
63894: LIST
63895: PPUSH
63896: CALL_OW 72
63900: IFFALSE 63910
// pos := 2 ;
63902: LD_ADDR_VAR 0 6
63906: PUSH
63907: LD_INT 2
63909: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
63910: LD_ADDR_VAR 0 7
63914: PUSH
63915: LD_VAR 0 7
63919: PPUSH
63920: LD_VAR 0 6
63924: PPUSH
63925: LD_VAR 0 7
63929: PPUSH
63930: CALL 71197 0 3
63934: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
63935: LD_ADDR_EXP 121
63939: PUSH
63940: LD_EXP 121
63944: PPUSH
63945: LD_VAR 0 3
63949: PPUSH
63950: LD_VAR 0 7
63954: PPUSH
63955: CALL_OW 1
63959: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
63960: LD_VAR 0 1
63964: PUSH
63965: LD_EXP 116
63969: PUSH
63970: LD_VAR 0 3
63974: ARRAY
63975: IN
63976: IFFALSE 64015
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
63978: LD_ADDR_EXP 116
63982: PUSH
63983: LD_EXP 116
63987: PPUSH
63988: LD_VAR 0 3
63992: PPUSH
63993: LD_EXP 116
63997: PUSH
63998: LD_VAR 0 3
64002: ARRAY
64003: PUSH
64004: LD_VAR 0 1
64008: DIFF
64009: PPUSH
64010: CALL_OW 1
64014: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
64015: LD_VAR 0 1
64019: PUSH
64020: LD_EXP 123
64024: PUSH
64025: LD_VAR 0 3
64029: ARRAY
64030: IN
64031: IFFALSE 64070
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
64033: LD_ADDR_EXP 123
64037: PUSH
64038: LD_EXP 123
64042: PPUSH
64043: LD_VAR 0 3
64047: PPUSH
64048: LD_EXP 123
64052: PUSH
64053: LD_VAR 0 3
64057: ARRAY
64058: PUSH
64059: LD_VAR 0 1
64063: DIFF
64064: PPUSH
64065: CALL_OW 1
64069: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
64070: LD_VAR 0 1
64074: PUSH
64075: LD_EXP 135
64079: PUSH
64080: LD_VAR 0 3
64084: ARRAY
64085: IN
64086: IFFALSE 64125
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
64088: LD_ADDR_EXP 135
64092: PUSH
64093: LD_EXP 135
64097: PPUSH
64098: LD_VAR 0 3
64102: PPUSH
64103: LD_EXP 135
64107: PUSH
64108: LD_VAR 0 3
64112: ARRAY
64113: PUSH
64114: LD_VAR 0 1
64118: DIFF
64119: PPUSH
64120: CALL_OW 1
64124: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
64125: LD_VAR 0 1
64129: PUSH
64130: LD_EXP 138
64134: PUSH
64135: LD_VAR 0 3
64139: ARRAY
64140: IN
64141: IFFALSE 64180
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
64143: LD_ADDR_EXP 138
64147: PUSH
64148: LD_EXP 138
64152: PPUSH
64153: LD_VAR 0 3
64157: PPUSH
64158: LD_EXP 138
64162: PUSH
64163: LD_VAR 0 3
64167: ARRAY
64168: PUSH
64169: LD_VAR 0 1
64173: DIFF
64174: PPUSH
64175: CALL_OW 1
64179: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
64180: LD_VAR 0 1
64184: PUSH
64185: LD_EXP 125
64189: PUSH
64190: LD_VAR 0 3
64194: ARRAY
64195: IN
64196: IFFALSE 64235
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
64198: LD_ADDR_EXP 125
64202: PUSH
64203: LD_EXP 125
64207: PPUSH
64208: LD_VAR 0 3
64212: PPUSH
64213: LD_EXP 125
64217: PUSH
64218: LD_VAR 0 3
64222: ARRAY
64223: PUSH
64224: LD_VAR 0 1
64228: DIFF
64229: PPUSH
64230: CALL_OW 1
64234: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
64235: LD_VAR 0 1
64239: PUSH
64240: LD_EXP 124
64244: PUSH
64245: LD_VAR 0 3
64249: ARRAY
64250: IN
64251: IFFALSE 64290
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
64253: LD_ADDR_EXP 124
64257: PUSH
64258: LD_EXP 124
64262: PPUSH
64263: LD_VAR 0 3
64267: PPUSH
64268: LD_EXP 124
64272: PUSH
64273: LD_VAR 0 3
64277: ARRAY
64278: PUSH
64279: LD_VAR 0 1
64283: DIFF
64284: PPUSH
64285: CALL_OW 1
64289: ST_TO_ADDR
// end ; break ;
64290: GO 64294
// end ;
64292: GO 62940
64294: POP
64295: POP
// end ;
64296: LD_VAR 0 2
64300: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
64301: LD_INT 0
64303: PPUSH
64304: PPUSH
64305: PPUSH
// if not mc_bases or not skirmish then
64306: LD_EXP 116
64310: NOT
64311: PUSH
64312: LD_EXP 114
64316: NOT
64317: OR
64318: IFFALSE 64322
// exit ;
64320: GO 64537
// for i = 1 to mc_bases do
64322: LD_ADDR_VAR 0 3
64326: PUSH
64327: DOUBLE
64328: LD_INT 1
64330: DEC
64331: ST_TO_ADDR
64332: LD_EXP 116
64336: PUSH
64337: FOR_TO
64338: IFFALSE 64535
// begin if building in mc_construct_list [ i ] then
64340: LD_VAR 0 1
64344: PUSH
64345: LD_EXP 123
64349: PUSH
64350: LD_VAR 0 3
64354: ARRAY
64355: IN
64356: IFFALSE 64533
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64358: LD_ADDR_EXP 123
64362: PUSH
64363: LD_EXP 123
64367: PPUSH
64368: LD_VAR 0 3
64372: PPUSH
64373: LD_EXP 123
64377: PUSH
64378: LD_VAR 0 3
64382: ARRAY
64383: PUSH
64384: LD_VAR 0 1
64388: DIFF
64389: PPUSH
64390: CALL_OW 1
64394: ST_TO_ADDR
// if building in mc_lab [ i ] then
64395: LD_VAR 0 1
64399: PUSH
64400: LD_EXP 149
64404: PUSH
64405: LD_VAR 0 3
64409: ARRAY
64410: IN
64411: IFFALSE 64466
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
64413: LD_ADDR_EXP 150
64417: PUSH
64418: LD_EXP 150
64422: PPUSH
64423: LD_VAR 0 3
64427: PPUSH
64428: LD_EXP 150
64432: PUSH
64433: LD_VAR 0 3
64437: ARRAY
64438: PPUSH
64439: LD_INT 1
64441: PPUSH
64442: LD_EXP 150
64446: PUSH
64447: LD_VAR 0 3
64451: ARRAY
64452: PPUSH
64453: LD_INT 0
64455: PPUSH
64456: CALL 70289 0 4
64460: PPUSH
64461: CALL_OW 1
64465: ST_TO_ADDR
// if not building in mc_bases [ i ] then
64466: LD_VAR 0 1
64470: PUSH
64471: LD_EXP 116
64475: PUSH
64476: LD_VAR 0 3
64480: ARRAY
64481: IN
64482: NOT
64483: IFFALSE 64529
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64485: LD_ADDR_EXP 116
64489: PUSH
64490: LD_EXP 116
64494: PPUSH
64495: LD_VAR 0 3
64499: PUSH
64500: LD_EXP 116
64504: PUSH
64505: LD_VAR 0 3
64509: ARRAY
64510: PUSH
64511: LD_INT 1
64513: PLUS
64514: PUSH
64515: EMPTY
64516: LIST
64517: LIST
64518: PPUSH
64519: LD_VAR 0 1
64523: PPUSH
64524: CALL 70871 0 3
64528: ST_TO_ADDR
// exit ;
64529: POP
64530: POP
64531: GO 64537
// end ; end ;
64533: GO 64337
64535: POP
64536: POP
// end ;
64537: LD_VAR 0 2
64541: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
64542: LD_INT 0
64544: PPUSH
64545: PPUSH
64546: PPUSH
64547: PPUSH
64548: PPUSH
64549: PPUSH
64550: PPUSH
// if not mc_bases or not skirmish then
64551: LD_EXP 116
64555: NOT
64556: PUSH
64557: LD_EXP 114
64561: NOT
64562: OR
64563: IFFALSE 64567
// exit ;
64565: GO 65228
// for i = 1 to mc_bases do
64567: LD_ADDR_VAR 0 3
64571: PUSH
64572: DOUBLE
64573: LD_INT 1
64575: DEC
64576: ST_TO_ADDR
64577: LD_EXP 116
64581: PUSH
64582: FOR_TO
64583: IFFALSE 65226
// begin if building in mc_construct_list [ i ] then
64585: LD_VAR 0 1
64589: PUSH
64590: LD_EXP 123
64594: PUSH
64595: LD_VAR 0 3
64599: ARRAY
64600: IN
64601: IFFALSE 65224
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
64603: LD_ADDR_EXP 123
64607: PUSH
64608: LD_EXP 123
64612: PPUSH
64613: LD_VAR 0 3
64617: PPUSH
64618: LD_EXP 123
64622: PUSH
64623: LD_VAR 0 3
64627: ARRAY
64628: PUSH
64629: LD_VAR 0 1
64633: DIFF
64634: PPUSH
64635: CALL_OW 1
64639: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
64640: LD_ADDR_EXP 116
64644: PUSH
64645: LD_EXP 116
64649: PPUSH
64650: LD_VAR 0 3
64654: PUSH
64655: LD_EXP 116
64659: PUSH
64660: LD_VAR 0 3
64664: ARRAY
64665: PUSH
64666: LD_INT 1
64668: PLUS
64669: PUSH
64670: EMPTY
64671: LIST
64672: LIST
64673: PPUSH
64674: LD_VAR 0 1
64678: PPUSH
64679: CALL 70871 0 3
64683: ST_TO_ADDR
// btype := GetBType ( building ) ;
64684: LD_ADDR_VAR 0 5
64688: PUSH
64689: LD_VAR 0 1
64693: PPUSH
64694: CALL_OW 266
64698: ST_TO_ADDR
// side := GetSide ( building ) ;
64699: LD_ADDR_VAR 0 8
64703: PUSH
64704: LD_VAR 0 1
64708: PPUSH
64709: CALL_OW 255
64713: ST_TO_ADDR
// if btype = b_lab then
64714: LD_VAR 0 5
64718: PUSH
64719: LD_INT 6
64721: EQUAL
64722: IFFALSE 64772
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
64724: LD_ADDR_EXP 149
64728: PUSH
64729: LD_EXP 149
64733: PPUSH
64734: LD_VAR 0 3
64738: PUSH
64739: LD_EXP 149
64743: PUSH
64744: LD_VAR 0 3
64748: ARRAY
64749: PUSH
64750: LD_INT 1
64752: PLUS
64753: PUSH
64754: EMPTY
64755: LIST
64756: LIST
64757: PPUSH
64758: LD_VAR 0 1
64762: PPUSH
64763: CALL 70871 0 3
64767: ST_TO_ADDR
// exit ;
64768: POP
64769: POP
64770: GO 65228
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
64772: LD_VAR 0 5
64776: PUSH
64777: LD_INT 0
64779: PUSH
64780: LD_INT 2
64782: PUSH
64783: LD_INT 4
64785: PUSH
64786: EMPTY
64787: LIST
64788: LIST
64789: LIST
64790: IN
64791: IFFALSE 64915
// begin if btype = b_armoury then
64793: LD_VAR 0 5
64797: PUSH
64798: LD_INT 4
64800: EQUAL
64801: IFFALSE 64811
// btype := b_barracks ;
64803: LD_ADDR_VAR 0 5
64807: PUSH
64808: LD_INT 5
64810: ST_TO_ADDR
// if btype = b_depot then
64811: LD_VAR 0 5
64815: PUSH
64816: LD_INT 0
64818: EQUAL
64819: IFFALSE 64829
// btype := b_warehouse ;
64821: LD_ADDR_VAR 0 5
64825: PUSH
64826: LD_INT 1
64828: ST_TO_ADDR
// if btype = b_workshop then
64829: LD_VAR 0 5
64833: PUSH
64834: LD_INT 2
64836: EQUAL
64837: IFFALSE 64847
// btype := b_factory ;
64839: LD_ADDR_VAR 0 5
64843: PUSH
64844: LD_INT 3
64846: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
64847: LD_VAR 0 5
64851: PPUSH
64852: LD_VAR 0 8
64856: PPUSH
64857: CALL_OW 323
64861: PUSH
64862: LD_INT 1
64864: EQUAL
64865: IFFALSE 64911
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
64867: LD_ADDR_EXP 148
64871: PUSH
64872: LD_EXP 148
64876: PPUSH
64877: LD_VAR 0 3
64881: PUSH
64882: LD_EXP 148
64886: PUSH
64887: LD_VAR 0 3
64891: ARRAY
64892: PUSH
64893: LD_INT 1
64895: PLUS
64896: PUSH
64897: EMPTY
64898: LIST
64899: LIST
64900: PPUSH
64901: LD_VAR 0 1
64905: PPUSH
64906: CALL 70871 0 3
64910: ST_TO_ADDR
// exit ;
64911: POP
64912: POP
64913: GO 65228
// end ; if btype in [ b_bunker , b_turret ] then
64915: LD_VAR 0 5
64919: PUSH
64920: LD_INT 32
64922: PUSH
64923: LD_INT 33
64925: PUSH
64926: EMPTY
64927: LIST
64928: LIST
64929: IN
64930: IFFALSE 65220
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
64932: LD_ADDR_EXP 124
64936: PUSH
64937: LD_EXP 124
64941: PPUSH
64942: LD_VAR 0 3
64946: PUSH
64947: LD_EXP 124
64951: PUSH
64952: LD_VAR 0 3
64956: ARRAY
64957: PUSH
64958: LD_INT 1
64960: PLUS
64961: PUSH
64962: EMPTY
64963: LIST
64964: LIST
64965: PPUSH
64966: LD_VAR 0 1
64970: PPUSH
64971: CALL 70871 0 3
64975: ST_TO_ADDR
// if btype = b_bunker then
64976: LD_VAR 0 5
64980: PUSH
64981: LD_INT 32
64983: EQUAL
64984: IFFALSE 65220
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
64986: LD_ADDR_EXP 125
64990: PUSH
64991: LD_EXP 125
64995: PPUSH
64996: LD_VAR 0 3
65000: PUSH
65001: LD_EXP 125
65005: PUSH
65006: LD_VAR 0 3
65010: ARRAY
65011: PUSH
65012: LD_INT 1
65014: PLUS
65015: PUSH
65016: EMPTY
65017: LIST
65018: LIST
65019: PPUSH
65020: LD_VAR 0 1
65024: PPUSH
65025: CALL 70871 0 3
65029: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
65030: LD_ADDR_VAR 0 6
65034: PUSH
65035: LD_EXP 116
65039: PUSH
65040: LD_VAR 0 3
65044: ARRAY
65045: PPUSH
65046: LD_INT 25
65048: PUSH
65049: LD_INT 1
65051: PUSH
65052: EMPTY
65053: LIST
65054: LIST
65055: PUSH
65056: LD_INT 3
65058: PUSH
65059: LD_INT 54
65061: PUSH
65062: EMPTY
65063: LIST
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: EMPTY
65070: LIST
65071: LIST
65072: PPUSH
65073: CALL_OW 72
65077: ST_TO_ADDR
// if tmp then
65078: LD_VAR 0 6
65082: IFFALSE 65088
// exit ;
65084: POP
65085: POP
65086: GO 65228
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
65088: LD_ADDR_VAR 0 6
65092: PUSH
65093: LD_EXP 116
65097: PUSH
65098: LD_VAR 0 3
65102: ARRAY
65103: PPUSH
65104: LD_INT 2
65106: PUSH
65107: LD_INT 30
65109: PUSH
65110: LD_INT 4
65112: PUSH
65113: EMPTY
65114: LIST
65115: LIST
65116: PUSH
65117: LD_INT 30
65119: PUSH
65120: LD_INT 5
65122: PUSH
65123: EMPTY
65124: LIST
65125: LIST
65126: PUSH
65127: EMPTY
65128: LIST
65129: LIST
65130: LIST
65131: PPUSH
65132: CALL_OW 72
65136: ST_TO_ADDR
// if not tmp then
65137: LD_VAR 0 6
65141: NOT
65142: IFFALSE 65148
// exit ;
65144: POP
65145: POP
65146: GO 65228
// for j in tmp do
65148: LD_ADDR_VAR 0 4
65152: PUSH
65153: LD_VAR 0 6
65157: PUSH
65158: FOR_IN
65159: IFFALSE 65218
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
65161: LD_ADDR_VAR 0 7
65165: PUSH
65166: LD_VAR 0 4
65170: PPUSH
65171: CALL_OW 313
65175: PPUSH
65176: LD_INT 25
65178: PUSH
65179: LD_INT 1
65181: PUSH
65182: EMPTY
65183: LIST
65184: LIST
65185: PPUSH
65186: CALL_OW 72
65190: ST_TO_ADDR
// if units then
65191: LD_VAR 0 7
65195: IFFALSE 65216
// begin ComExitBuilding ( units [ 1 ] ) ;
65197: LD_VAR 0 7
65201: PUSH
65202: LD_INT 1
65204: ARRAY
65205: PPUSH
65206: CALL_OW 122
// exit ;
65210: POP
65211: POP
65212: POP
65213: POP
65214: GO 65228
// end ; end ;
65216: GO 65158
65218: POP
65219: POP
// end ; end ; exit ;
65220: POP
65221: POP
65222: GO 65228
// end ; end ;
65224: GO 64582
65226: POP
65227: POP
// end ;
65228: LD_VAR 0 2
65232: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
65233: LD_INT 0
65235: PPUSH
65236: PPUSH
65237: PPUSH
65238: PPUSH
65239: PPUSH
65240: PPUSH
65241: PPUSH
// if not mc_bases or not skirmish then
65242: LD_EXP 116
65246: NOT
65247: PUSH
65248: LD_EXP 114
65252: NOT
65253: OR
65254: IFFALSE 65258
// exit ;
65256: GO 65523
// btype := GetBType ( building ) ;
65258: LD_ADDR_VAR 0 6
65262: PUSH
65263: LD_VAR 0 1
65267: PPUSH
65268: CALL_OW 266
65272: ST_TO_ADDR
// x := GetX ( building ) ;
65273: LD_ADDR_VAR 0 7
65277: PUSH
65278: LD_VAR 0 1
65282: PPUSH
65283: CALL_OW 250
65287: ST_TO_ADDR
// y := GetY ( building ) ;
65288: LD_ADDR_VAR 0 8
65292: PUSH
65293: LD_VAR 0 1
65297: PPUSH
65298: CALL_OW 251
65302: ST_TO_ADDR
// d := GetDir ( building ) ;
65303: LD_ADDR_VAR 0 9
65307: PUSH
65308: LD_VAR 0 1
65312: PPUSH
65313: CALL_OW 254
65317: ST_TO_ADDR
// for i = 1 to mc_bases do
65318: LD_ADDR_VAR 0 4
65322: PUSH
65323: DOUBLE
65324: LD_INT 1
65326: DEC
65327: ST_TO_ADDR
65328: LD_EXP 116
65332: PUSH
65333: FOR_TO
65334: IFFALSE 65521
// begin if not mc_build_list [ i ] then
65336: LD_EXP 121
65340: PUSH
65341: LD_VAR 0 4
65345: ARRAY
65346: NOT
65347: IFFALSE 65351
// continue ;
65349: GO 65333
// for j := 1 to mc_build_list [ i ] do
65351: LD_ADDR_VAR 0 5
65355: PUSH
65356: DOUBLE
65357: LD_INT 1
65359: DEC
65360: ST_TO_ADDR
65361: LD_EXP 121
65365: PUSH
65366: LD_VAR 0 4
65370: ARRAY
65371: PUSH
65372: FOR_TO
65373: IFFALSE 65517
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
65375: LD_VAR 0 6
65379: PUSH
65380: LD_VAR 0 7
65384: PUSH
65385: LD_VAR 0 8
65389: PUSH
65390: LD_VAR 0 9
65394: PUSH
65395: EMPTY
65396: LIST
65397: LIST
65398: LIST
65399: LIST
65400: PPUSH
65401: LD_EXP 121
65405: PUSH
65406: LD_VAR 0 4
65410: ARRAY
65411: PUSH
65412: LD_VAR 0 5
65416: ARRAY
65417: PPUSH
65418: CALL 77053 0 2
65422: IFFALSE 65515
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
65424: LD_ADDR_EXP 121
65428: PUSH
65429: LD_EXP 121
65433: PPUSH
65434: LD_VAR 0 4
65438: PPUSH
65439: LD_EXP 121
65443: PUSH
65444: LD_VAR 0 4
65448: ARRAY
65449: PPUSH
65450: LD_VAR 0 5
65454: PPUSH
65455: CALL_OW 3
65459: PPUSH
65460: CALL_OW 1
65464: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
65465: LD_ADDR_EXP 123
65469: PUSH
65470: LD_EXP 123
65474: PPUSH
65475: LD_VAR 0 4
65479: PUSH
65480: LD_EXP 123
65484: PUSH
65485: LD_VAR 0 4
65489: ARRAY
65490: PUSH
65491: LD_INT 1
65493: PLUS
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PPUSH
65499: LD_VAR 0 1
65503: PPUSH
65504: CALL 70871 0 3
65508: ST_TO_ADDR
// exit ;
65509: POP
65510: POP
65511: POP
65512: POP
65513: GO 65523
// end ;
65515: GO 65372
65517: POP
65518: POP
// end ;
65519: GO 65333
65521: POP
65522: POP
// end ;
65523: LD_VAR 0 3
65527: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
65528: LD_INT 0
65530: PPUSH
65531: PPUSH
65532: PPUSH
// if not mc_bases or not skirmish then
65533: LD_EXP 116
65537: NOT
65538: PUSH
65539: LD_EXP 114
65543: NOT
65544: OR
65545: IFFALSE 65549
// exit ;
65547: GO 65739
// for i = 1 to mc_bases do
65549: LD_ADDR_VAR 0 4
65553: PUSH
65554: DOUBLE
65555: LD_INT 1
65557: DEC
65558: ST_TO_ADDR
65559: LD_EXP 116
65563: PUSH
65564: FOR_TO
65565: IFFALSE 65652
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
65567: LD_VAR 0 1
65571: PUSH
65572: LD_EXP 124
65576: PUSH
65577: LD_VAR 0 4
65581: ARRAY
65582: IN
65583: PUSH
65584: LD_VAR 0 1
65588: PUSH
65589: LD_EXP 125
65593: PUSH
65594: LD_VAR 0 4
65598: ARRAY
65599: IN
65600: NOT
65601: AND
65602: IFFALSE 65650
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
65604: LD_ADDR_EXP 125
65608: PUSH
65609: LD_EXP 125
65613: PPUSH
65614: LD_VAR 0 4
65618: PUSH
65619: LD_EXP 125
65623: PUSH
65624: LD_VAR 0 4
65628: ARRAY
65629: PUSH
65630: LD_INT 1
65632: PLUS
65633: PUSH
65634: EMPTY
65635: LIST
65636: LIST
65637: PPUSH
65638: LD_VAR 0 1
65642: PPUSH
65643: CALL 70871 0 3
65647: ST_TO_ADDR
// break ;
65648: GO 65652
// end ; end ;
65650: GO 65564
65652: POP
65653: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
65654: LD_VAR 0 1
65658: PPUSH
65659: CALL_OW 257
65663: PUSH
65664: LD_EXP 142
65668: IN
65669: PUSH
65670: LD_VAR 0 1
65674: PPUSH
65675: CALL_OW 266
65679: PUSH
65680: LD_INT 5
65682: EQUAL
65683: AND
65684: PUSH
65685: LD_VAR 0 2
65689: PPUSH
65690: CALL_OW 110
65694: PUSH
65695: LD_INT 18
65697: NONEQUAL
65698: AND
65699: IFFALSE 65739
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
65701: LD_VAR 0 2
65705: PPUSH
65706: CALL_OW 257
65710: PUSH
65711: LD_INT 5
65713: PUSH
65714: LD_INT 8
65716: PUSH
65717: LD_INT 9
65719: PUSH
65720: EMPTY
65721: LIST
65722: LIST
65723: LIST
65724: IN
65725: IFFALSE 65739
// SetClass ( unit , 1 ) ;
65727: LD_VAR 0 2
65731: PPUSH
65732: LD_INT 1
65734: PPUSH
65735: CALL_OW 336
// end ;
65739: LD_VAR 0 3
65743: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
65744: LD_INT 0
65746: PPUSH
65747: PPUSH
// if not mc_bases or not skirmish then
65748: LD_EXP 116
65752: NOT
65753: PUSH
65754: LD_EXP 114
65758: NOT
65759: OR
65760: IFFALSE 65764
// exit ;
65762: GO 65880
// if GetLives ( abandoned_vehicle ) > 250 then
65764: LD_VAR 0 2
65768: PPUSH
65769: CALL_OW 256
65773: PUSH
65774: LD_INT 250
65776: GREATER
65777: IFFALSE 65781
// exit ;
65779: GO 65880
// for i = 1 to mc_bases do
65781: LD_ADDR_VAR 0 6
65785: PUSH
65786: DOUBLE
65787: LD_INT 1
65789: DEC
65790: ST_TO_ADDR
65791: LD_EXP 116
65795: PUSH
65796: FOR_TO
65797: IFFALSE 65878
// begin if driver in mc_bases [ i ] then
65799: LD_VAR 0 1
65803: PUSH
65804: LD_EXP 116
65808: PUSH
65809: LD_VAR 0 6
65813: ARRAY
65814: IN
65815: IFFALSE 65876
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
65817: LD_VAR 0 1
65821: PPUSH
65822: LD_EXP 116
65826: PUSH
65827: LD_VAR 0 6
65831: ARRAY
65832: PPUSH
65833: LD_INT 2
65835: PUSH
65836: LD_INT 30
65838: PUSH
65839: LD_INT 0
65841: PUSH
65842: EMPTY
65843: LIST
65844: LIST
65845: PUSH
65846: LD_INT 30
65848: PUSH
65849: LD_INT 1
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: EMPTY
65857: LIST
65858: LIST
65859: LIST
65860: PPUSH
65861: CALL_OW 72
65865: PUSH
65866: LD_INT 1
65868: ARRAY
65869: PPUSH
65870: CALL 103489 0 2
// break ;
65874: GO 65878
// end ; end ;
65876: GO 65796
65878: POP
65879: POP
// end ; end_of_file
65880: LD_VAR 0 5
65884: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
65885: LD_INT 0
65887: PPUSH
65888: PPUSH
// if exist_mode then
65889: LD_VAR 0 2
65893: IFFALSE 65918
// unit := CreateCharacter ( prefix & ident ) else
65895: LD_ADDR_VAR 0 5
65899: PUSH
65900: LD_VAR 0 3
65904: PUSH
65905: LD_VAR 0 1
65909: STR
65910: PPUSH
65911: CALL_OW 34
65915: ST_TO_ADDR
65916: GO 65933
// unit := NewCharacter ( ident ) ;
65918: LD_ADDR_VAR 0 5
65922: PUSH
65923: LD_VAR 0 1
65927: PPUSH
65928: CALL_OW 25
65932: ST_TO_ADDR
// result := unit ;
65933: LD_ADDR_VAR 0 4
65937: PUSH
65938: LD_VAR 0 5
65942: ST_TO_ADDR
// end ;
65943: LD_VAR 0 4
65947: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
65948: LD_INT 0
65950: PPUSH
65951: PPUSH
// if not side or not nation then
65952: LD_VAR 0 1
65956: NOT
65957: PUSH
65958: LD_VAR 0 2
65962: NOT
65963: OR
65964: IFFALSE 65968
// exit ;
65966: GO 66736
// case nation of nation_american :
65968: LD_VAR 0 2
65972: PUSH
65973: LD_INT 1
65975: DOUBLE
65976: EQUAL
65977: IFTRUE 65981
65979: GO 66195
65981: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
65982: LD_ADDR_VAR 0 4
65986: PUSH
65987: LD_INT 35
65989: PUSH
65990: LD_INT 45
65992: PUSH
65993: LD_INT 46
65995: PUSH
65996: LD_INT 47
65998: PUSH
65999: LD_INT 82
66001: PUSH
66002: LD_INT 83
66004: PUSH
66005: LD_INT 84
66007: PUSH
66008: LD_INT 85
66010: PUSH
66011: LD_INT 86
66013: PUSH
66014: LD_INT 1
66016: PUSH
66017: LD_INT 2
66019: PUSH
66020: LD_INT 6
66022: PUSH
66023: LD_INT 15
66025: PUSH
66026: LD_INT 16
66028: PUSH
66029: LD_INT 7
66031: PUSH
66032: LD_INT 12
66034: PUSH
66035: LD_INT 13
66037: PUSH
66038: LD_INT 10
66040: PUSH
66041: LD_INT 14
66043: PUSH
66044: LD_INT 20
66046: PUSH
66047: LD_INT 21
66049: PUSH
66050: LD_INT 22
66052: PUSH
66053: LD_INT 25
66055: PUSH
66056: LD_INT 32
66058: PUSH
66059: LD_INT 27
66061: PUSH
66062: LD_INT 36
66064: PUSH
66065: LD_INT 69
66067: PUSH
66068: LD_INT 39
66070: PUSH
66071: LD_INT 34
66073: PUSH
66074: LD_INT 40
66076: PUSH
66077: LD_INT 48
66079: PUSH
66080: LD_INT 49
66082: PUSH
66083: LD_INT 50
66085: PUSH
66086: LD_INT 51
66088: PUSH
66089: LD_INT 52
66091: PUSH
66092: LD_INT 53
66094: PUSH
66095: LD_INT 54
66097: PUSH
66098: LD_INT 55
66100: PUSH
66101: LD_INT 56
66103: PUSH
66104: LD_INT 57
66106: PUSH
66107: LD_INT 58
66109: PUSH
66110: LD_INT 59
66112: PUSH
66113: LD_INT 60
66115: PUSH
66116: LD_INT 61
66118: PUSH
66119: LD_INT 62
66121: PUSH
66122: LD_INT 80
66124: PUSH
66125: LD_INT 82
66127: PUSH
66128: LD_INT 83
66130: PUSH
66131: LD_INT 84
66133: PUSH
66134: LD_INT 85
66136: PUSH
66137: LD_INT 86
66139: PUSH
66140: EMPTY
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: LIST
66182: LIST
66183: LIST
66184: LIST
66185: LIST
66186: LIST
66187: LIST
66188: LIST
66189: LIST
66190: LIST
66191: LIST
66192: ST_TO_ADDR
66193: GO 66660
66195: LD_INT 2
66197: DOUBLE
66198: EQUAL
66199: IFTRUE 66203
66201: GO 66429
66203: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
66204: LD_ADDR_VAR 0 4
66208: PUSH
66209: LD_INT 35
66211: PUSH
66212: LD_INT 45
66214: PUSH
66215: LD_INT 46
66217: PUSH
66218: LD_INT 47
66220: PUSH
66221: LD_INT 82
66223: PUSH
66224: LD_INT 83
66226: PUSH
66227: LD_INT 84
66229: PUSH
66230: LD_INT 85
66232: PUSH
66233: LD_INT 87
66235: PUSH
66236: LD_INT 70
66238: PUSH
66239: LD_INT 1
66241: PUSH
66242: LD_INT 11
66244: PUSH
66245: LD_INT 3
66247: PUSH
66248: LD_INT 4
66250: PUSH
66251: LD_INT 5
66253: PUSH
66254: LD_INT 6
66256: PUSH
66257: LD_INT 15
66259: PUSH
66260: LD_INT 18
66262: PUSH
66263: LD_INT 7
66265: PUSH
66266: LD_INT 17
66268: PUSH
66269: LD_INT 8
66271: PUSH
66272: LD_INT 20
66274: PUSH
66275: LD_INT 21
66277: PUSH
66278: LD_INT 22
66280: PUSH
66281: LD_INT 72
66283: PUSH
66284: LD_INT 26
66286: PUSH
66287: LD_INT 69
66289: PUSH
66290: LD_INT 39
66292: PUSH
66293: LD_INT 40
66295: PUSH
66296: LD_INT 41
66298: PUSH
66299: LD_INT 42
66301: PUSH
66302: LD_INT 43
66304: PUSH
66305: LD_INT 48
66307: PUSH
66308: LD_INT 49
66310: PUSH
66311: LD_INT 50
66313: PUSH
66314: LD_INT 51
66316: PUSH
66317: LD_INT 52
66319: PUSH
66320: LD_INT 53
66322: PUSH
66323: LD_INT 54
66325: PUSH
66326: LD_INT 55
66328: PUSH
66329: LD_INT 56
66331: PUSH
66332: LD_INT 60
66334: PUSH
66335: LD_INT 61
66337: PUSH
66338: LD_INT 62
66340: PUSH
66341: LD_INT 66
66343: PUSH
66344: LD_INT 67
66346: PUSH
66347: LD_INT 68
66349: PUSH
66350: LD_INT 81
66352: PUSH
66353: LD_INT 82
66355: PUSH
66356: LD_INT 83
66358: PUSH
66359: LD_INT 84
66361: PUSH
66362: LD_INT 85
66364: PUSH
66365: LD_INT 87
66367: PUSH
66368: LD_INT 88
66370: PUSH
66371: EMPTY
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: LIST
66377: LIST
66378: LIST
66379: LIST
66380: LIST
66381: LIST
66382: LIST
66383: LIST
66384: LIST
66385: LIST
66386: LIST
66387: LIST
66388: LIST
66389: LIST
66390: LIST
66391: LIST
66392: LIST
66393: LIST
66394: LIST
66395: LIST
66396: LIST
66397: LIST
66398: LIST
66399: LIST
66400: LIST
66401: LIST
66402: LIST
66403: LIST
66404: LIST
66405: LIST
66406: LIST
66407: LIST
66408: LIST
66409: LIST
66410: LIST
66411: LIST
66412: LIST
66413: LIST
66414: LIST
66415: LIST
66416: LIST
66417: LIST
66418: LIST
66419: LIST
66420: LIST
66421: LIST
66422: LIST
66423: LIST
66424: LIST
66425: LIST
66426: ST_TO_ADDR
66427: GO 66660
66429: LD_INT 3
66431: DOUBLE
66432: EQUAL
66433: IFTRUE 66437
66435: GO 66659
66437: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
66438: LD_ADDR_VAR 0 4
66442: PUSH
66443: LD_INT 46
66445: PUSH
66446: LD_INT 47
66448: PUSH
66449: LD_INT 1
66451: PUSH
66452: LD_INT 2
66454: PUSH
66455: LD_INT 82
66457: PUSH
66458: LD_INT 83
66460: PUSH
66461: LD_INT 84
66463: PUSH
66464: LD_INT 85
66466: PUSH
66467: LD_INT 86
66469: PUSH
66470: LD_INT 11
66472: PUSH
66473: LD_INT 9
66475: PUSH
66476: LD_INT 20
66478: PUSH
66479: LD_INT 19
66481: PUSH
66482: LD_INT 21
66484: PUSH
66485: LD_INT 24
66487: PUSH
66488: LD_INT 22
66490: PUSH
66491: LD_INT 25
66493: PUSH
66494: LD_INT 28
66496: PUSH
66497: LD_INT 29
66499: PUSH
66500: LD_INT 30
66502: PUSH
66503: LD_INT 31
66505: PUSH
66506: LD_INT 37
66508: PUSH
66509: LD_INT 38
66511: PUSH
66512: LD_INT 32
66514: PUSH
66515: LD_INT 27
66517: PUSH
66518: LD_INT 33
66520: PUSH
66521: LD_INT 69
66523: PUSH
66524: LD_INT 39
66526: PUSH
66527: LD_INT 34
66529: PUSH
66530: LD_INT 40
66532: PUSH
66533: LD_INT 71
66535: PUSH
66536: LD_INT 23
66538: PUSH
66539: LD_INT 44
66541: PUSH
66542: LD_INT 48
66544: PUSH
66545: LD_INT 49
66547: PUSH
66548: LD_INT 50
66550: PUSH
66551: LD_INT 51
66553: PUSH
66554: LD_INT 52
66556: PUSH
66557: LD_INT 53
66559: PUSH
66560: LD_INT 54
66562: PUSH
66563: LD_INT 55
66565: PUSH
66566: LD_INT 56
66568: PUSH
66569: LD_INT 57
66571: PUSH
66572: LD_INT 58
66574: PUSH
66575: LD_INT 59
66577: PUSH
66578: LD_INT 63
66580: PUSH
66581: LD_INT 64
66583: PUSH
66584: LD_INT 65
66586: PUSH
66587: LD_INT 82
66589: PUSH
66590: LD_INT 83
66592: PUSH
66593: LD_INT 84
66595: PUSH
66596: LD_INT 85
66598: PUSH
66599: LD_INT 86
66601: PUSH
66602: EMPTY
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: LIST
66608: LIST
66609: LIST
66610: LIST
66611: LIST
66612: LIST
66613: LIST
66614: LIST
66615: LIST
66616: LIST
66617: LIST
66618: LIST
66619: LIST
66620: LIST
66621: LIST
66622: LIST
66623: LIST
66624: LIST
66625: LIST
66626: LIST
66627: LIST
66628: LIST
66629: LIST
66630: LIST
66631: LIST
66632: LIST
66633: LIST
66634: LIST
66635: LIST
66636: LIST
66637: LIST
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: ST_TO_ADDR
66657: GO 66660
66659: POP
// if state > - 1 and state < 3 then
66660: LD_VAR 0 3
66664: PUSH
66665: LD_INT 1
66667: NEG
66668: GREATER
66669: PUSH
66670: LD_VAR 0 3
66674: PUSH
66675: LD_INT 3
66677: LESS
66678: AND
66679: IFFALSE 66736
// for i in result do
66681: LD_ADDR_VAR 0 5
66685: PUSH
66686: LD_VAR 0 4
66690: PUSH
66691: FOR_IN
66692: IFFALSE 66734
// if GetTech ( i , side ) <> state then
66694: LD_VAR 0 5
66698: PPUSH
66699: LD_VAR 0 1
66703: PPUSH
66704: CALL_OW 321
66708: PUSH
66709: LD_VAR 0 3
66713: NONEQUAL
66714: IFFALSE 66732
// result := result diff i ;
66716: LD_ADDR_VAR 0 4
66720: PUSH
66721: LD_VAR 0 4
66725: PUSH
66726: LD_VAR 0 5
66730: DIFF
66731: ST_TO_ADDR
66732: GO 66691
66734: POP
66735: POP
// end ;
66736: LD_VAR 0 4
66740: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
66741: LD_INT 0
66743: PPUSH
66744: PPUSH
66745: PPUSH
// result := true ;
66746: LD_ADDR_VAR 0 3
66750: PUSH
66751: LD_INT 1
66753: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
66754: LD_ADDR_VAR 0 5
66758: PUSH
66759: LD_VAR 0 2
66763: PPUSH
66764: CALL_OW 480
66768: ST_TO_ADDR
// if not tmp then
66769: LD_VAR 0 5
66773: NOT
66774: IFFALSE 66778
// exit ;
66776: GO 66827
// for i in tmp do
66778: LD_ADDR_VAR 0 4
66782: PUSH
66783: LD_VAR 0 5
66787: PUSH
66788: FOR_IN
66789: IFFALSE 66825
// if GetTech ( i , side ) <> state_researched then
66791: LD_VAR 0 4
66795: PPUSH
66796: LD_VAR 0 1
66800: PPUSH
66801: CALL_OW 321
66805: PUSH
66806: LD_INT 2
66808: NONEQUAL
66809: IFFALSE 66823
// begin result := false ;
66811: LD_ADDR_VAR 0 3
66815: PUSH
66816: LD_INT 0
66818: ST_TO_ADDR
// exit ;
66819: POP
66820: POP
66821: GO 66827
// end ;
66823: GO 66788
66825: POP
66826: POP
// end ;
66827: LD_VAR 0 3
66831: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
66832: LD_INT 0
66834: PPUSH
66835: PPUSH
66836: PPUSH
66837: PPUSH
66838: PPUSH
66839: PPUSH
66840: PPUSH
66841: PPUSH
66842: PPUSH
66843: PPUSH
66844: PPUSH
66845: PPUSH
66846: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
66847: LD_VAR 0 1
66851: NOT
66852: PUSH
66853: LD_VAR 0 1
66857: PPUSH
66858: CALL_OW 257
66862: PUSH
66863: LD_INT 9
66865: NONEQUAL
66866: OR
66867: IFFALSE 66871
// exit ;
66869: GO 67444
// side := GetSide ( unit ) ;
66871: LD_ADDR_VAR 0 9
66875: PUSH
66876: LD_VAR 0 1
66880: PPUSH
66881: CALL_OW 255
66885: ST_TO_ADDR
// tech_space := tech_spacanom ;
66886: LD_ADDR_VAR 0 12
66890: PUSH
66891: LD_INT 29
66893: ST_TO_ADDR
// tech_time := tech_taurad ;
66894: LD_ADDR_VAR 0 13
66898: PUSH
66899: LD_INT 28
66901: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
66902: LD_ADDR_VAR 0 11
66906: PUSH
66907: LD_VAR 0 1
66911: PPUSH
66912: CALL_OW 310
66916: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
66917: LD_VAR 0 11
66921: PPUSH
66922: CALL_OW 247
66926: PUSH
66927: LD_INT 2
66929: EQUAL
66930: IFFALSE 66934
// exit ;
66932: GO 67444
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
66934: LD_ADDR_VAR 0 8
66938: PUSH
66939: LD_INT 81
66941: PUSH
66942: LD_VAR 0 9
66946: PUSH
66947: EMPTY
66948: LIST
66949: LIST
66950: PUSH
66951: LD_INT 3
66953: PUSH
66954: LD_INT 21
66956: PUSH
66957: LD_INT 3
66959: PUSH
66960: EMPTY
66961: LIST
66962: LIST
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PPUSH
66972: CALL_OW 69
66976: ST_TO_ADDR
// if not tmp then
66977: LD_VAR 0 8
66981: NOT
66982: IFFALSE 66986
// exit ;
66984: GO 67444
// if in_unit then
66986: LD_VAR 0 11
66990: IFFALSE 67014
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
66992: LD_ADDR_VAR 0 10
66996: PUSH
66997: LD_VAR 0 8
67001: PPUSH
67002: LD_VAR 0 11
67006: PPUSH
67007: CALL_OW 74
67011: ST_TO_ADDR
67012: GO 67034
// enemy := NearestUnitToUnit ( tmp , unit ) ;
67014: LD_ADDR_VAR 0 10
67018: PUSH
67019: LD_VAR 0 8
67023: PPUSH
67024: LD_VAR 0 1
67028: PPUSH
67029: CALL_OW 74
67033: ST_TO_ADDR
// if not enemy then
67034: LD_VAR 0 10
67038: NOT
67039: IFFALSE 67043
// exit ;
67041: GO 67444
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
67043: LD_VAR 0 11
67047: PUSH
67048: LD_VAR 0 11
67052: PPUSH
67053: LD_VAR 0 10
67057: PPUSH
67058: CALL_OW 296
67062: PUSH
67063: LD_INT 13
67065: GREATER
67066: AND
67067: PUSH
67068: LD_VAR 0 1
67072: PPUSH
67073: LD_VAR 0 10
67077: PPUSH
67078: CALL_OW 296
67082: PUSH
67083: LD_INT 12
67085: GREATER
67086: OR
67087: IFFALSE 67091
// exit ;
67089: GO 67444
// missile := [ 1 ] ;
67091: LD_ADDR_VAR 0 14
67095: PUSH
67096: LD_INT 1
67098: PUSH
67099: EMPTY
67100: LIST
67101: ST_TO_ADDR
// if Researched ( side , tech_space ) then
67102: LD_VAR 0 9
67106: PPUSH
67107: LD_VAR 0 12
67111: PPUSH
67112: CALL_OW 325
67116: IFFALSE 67145
// missile := Insert ( missile , missile + 1 , 2 ) ;
67118: LD_ADDR_VAR 0 14
67122: PUSH
67123: LD_VAR 0 14
67127: PPUSH
67128: LD_VAR 0 14
67132: PUSH
67133: LD_INT 1
67135: PLUS
67136: PPUSH
67137: LD_INT 2
67139: PPUSH
67140: CALL_OW 2
67144: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
67145: LD_VAR 0 9
67149: PPUSH
67150: LD_VAR 0 13
67154: PPUSH
67155: CALL_OW 325
67159: PUSH
67160: LD_VAR 0 10
67164: PPUSH
67165: CALL_OW 255
67169: PPUSH
67170: LD_VAR 0 13
67174: PPUSH
67175: CALL_OW 325
67179: NOT
67180: AND
67181: IFFALSE 67210
// missile := Insert ( missile , missile + 1 , 3 ) ;
67183: LD_ADDR_VAR 0 14
67187: PUSH
67188: LD_VAR 0 14
67192: PPUSH
67193: LD_VAR 0 14
67197: PUSH
67198: LD_INT 1
67200: PLUS
67201: PPUSH
67202: LD_INT 3
67204: PPUSH
67205: CALL_OW 2
67209: ST_TO_ADDR
// if missile < 2 then
67210: LD_VAR 0 14
67214: PUSH
67215: LD_INT 2
67217: LESS
67218: IFFALSE 67222
// exit ;
67220: GO 67444
// x := GetX ( enemy ) ;
67222: LD_ADDR_VAR 0 4
67226: PUSH
67227: LD_VAR 0 10
67231: PPUSH
67232: CALL_OW 250
67236: ST_TO_ADDR
// y := GetY ( enemy ) ;
67237: LD_ADDR_VAR 0 5
67241: PUSH
67242: LD_VAR 0 10
67246: PPUSH
67247: CALL_OW 251
67251: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
67252: LD_ADDR_VAR 0 6
67256: PUSH
67257: LD_VAR 0 4
67261: PUSH
67262: LD_INT 1
67264: NEG
67265: PPUSH
67266: LD_INT 1
67268: PPUSH
67269: CALL_OW 12
67273: PLUS
67274: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
67275: LD_ADDR_VAR 0 7
67279: PUSH
67280: LD_VAR 0 5
67284: PUSH
67285: LD_INT 1
67287: NEG
67288: PPUSH
67289: LD_INT 1
67291: PPUSH
67292: CALL_OW 12
67296: PLUS
67297: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67298: LD_VAR 0 6
67302: PPUSH
67303: LD_VAR 0 7
67307: PPUSH
67308: CALL_OW 488
67312: NOT
67313: IFFALSE 67335
// begin _x := x ;
67315: LD_ADDR_VAR 0 6
67319: PUSH
67320: LD_VAR 0 4
67324: ST_TO_ADDR
// _y := y ;
67325: LD_ADDR_VAR 0 7
67329: PUSH
67330: LD_VAR 0 5
67334: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
67335: LD_ADDR_VAR 0 3
67339: PUSH
67340: LD_INT 1
67342: PPUSH
67343: LD_VAR 0 14
67347: PPUSH
67348: CALL_OW 12
67352: ST_TO_ADDR
// case i of 1 :
67353: LD_VAR 0 3
67357: PUSH
67358: LD_INT 1
67360: DOUBLE
67361: EQUAL
67362: IFTRUE 67366
67364: GO 67383
67366: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
67367: LD_VAR 0 1
67371: PPUSH
67372: LD_VAR 0 10
67376: PPUSH
67377: CALL_OW 115
67381: GO 67444
67383: LD_INT 2
67385: DOUBLE
67386: EQUAL
67387: IFTRUE 67391
67389: GO 67413
67391: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
67392: LD_VAR 0 1
67396: PPUSH
67397: LD_VAR 0 6
67401: PPUSH
67402: LD_VAR 0 7
67406: PPUSH
67407: CALL_OW 153
67411: GO 67444
67413: LD_INT 3
67415: DOUBLE
67416: EQUAL
67417: IFTRUE 67421
67419: GO 67443
67421: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
67422: LD_VAR 0 1
67426: PPUSH
67427: LD_VAR 0 6
67431: PPUSH
67432: LD_VAR 0 7
67436: PPUSH
67437: CALL_OW 154
67441: GO 67444
67443: POP
// end ;
67444: LD_VAR 0 2
67448: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
67449: LD_INT 0
67451: PPUSH
67452: PPUSH
67453: PPUSH
67454: PPUSH
67455: PPUSH
67456: PPUSH
// if not unit or not building then
67457: LD_VAR 0 1
67461: NOT
67462: PUSH
67463: LD_VAR 0 2
67467: NOT
67468: OR
67469: IFFALSE 67473
// exit ;
67471: GO 67631
// x := GetX ( building ) ;
67473: LD_ADDR_VAR 0 5
67477: PUSH
67478: LD_VAR 0 2
67482: PPUSH
67483: CALL_OW 250
67487: ST_TO_ADDR
// y := GetY ( building ) ;
67488: LD_ADDR_VAR 0 6
67492: PUSH
67493: LD_VAR 0 2
67497: PPUSH
67498: CALL_OW 251
67502: ST_TO_ADDR
// for i = 0 to 5 do
67503: LD_ADDR_VAR 0 4
67507: PUSH
67508: DOUBLE
67509: LD_INT 0
67511: DEC
67512: ST_TO_ADDR
67513: LD_INT 5
67515: PUSH
67516: FOR_TO
67517: IFFALSE 67629
// begin _x := ShiftX ( x , i , 3 ) ;
67519: LD_ADDR_VAR 0 7
67523: PUSH
67524: LD_VAR 0 5
67528: PPUSH
67529: LD_VAR 0 4
67533: PPUSH
67534: LD_INT 3
67536: PPUSH
67537: CALL_OW 272
67541: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
67542: LD_ADDR_VAR 0 8
67546: PUSH
67547: LD_VAR 0 6
67551: PPUSH
67552: LD_VAR 0 4
67556: PPUSH
67557: LD_INT 3
67559: PPUSH
67560: CALL_OW 273
67564: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
67565: LD_VAR 0 7
67569: PPUSH
67570: LD_VAR 0 8
67574: PPUSH
67575: CALL_OW 488
67579: NOT
67580: IFFALSE 67584
// continue ;
67582: GO 67516
// if HexInfo ( _x , _y ) = 0 then
67584: LD_VAR 0 7
67588: PPUSH
67589: LD_VAR 0 8
67593: PPUSH
67594: CALL_OW 428
67598: PUSH
67599: LD_INT 0
67601: EQUAL
67602: IFFALSE 67627
// begin ComMoveXY ( unit , _x , _y ) ;
67604: LD_VAR 0 1
67608: PPUSH
67609: LD_VAR 0 7
67613: PPUSH
67614: LD_VAR 0 8
67618: PPUSH
67619: CALL_OW 111
// exit ;
67623: POP
67624: POP
67625: GO 67631
// end ; end ;
67627: GO 67516
67629: POP
67630: POP
// end ;
67631: LD_VAR 0 3
67635: RET
// export function ScanBase ( side , base_area ) ; begin
67636: LD_INT 0
67638: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
67639: LD_ADDR_VAR 0 3
67643: PUSH
67644: LD_VAR 0 2
67648: PPUSH
67649: LD_INT 81
67651: PUSH
67652: LD_VAR 0 1
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PPUSH
67661: CALL_OW 70
67665: ST_TO_ADDR
// end ;
67666: LD_VAR 0 3
67670: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
67671: LD_INT 0
67673: PPUSH
67674: PPUSH
67675: PPUSH
67676: PPUSH
// result := false ;
67677: LD_ADDR_VAR 0 2
67681: PUSH
67682: LD_INT 0
67684: ST_TO_ADDR
// side := GetSide ( unit ) ;
67685: LD_ADDR_VAR 0 3
67689: PUSH
67690: LD_VAR 0 1
67694: PPUSH
67695: CALL_OW 255
67699: ST_TO_ADDR
// nat := GetNation ( unit ) ;
67700: LD_ADDR_VAR 0 4
67704: PUSH
67705: LD_VAR 0 1
67709: PPUSH
67710: CALL_OW 248
67714: ST_TO_ADDR
// case nat of 1 :
67715: LD_VAR 0 4
67719: PUSH
67720: LD_INT 1
67722: DOUBLE
67723: EQUAL
67724: IFTRUE 67728
67726: GO 67739
67728: POP
// tech := tech_lassight ; 2 :
67729: LD_ADDR_VAR 0 5
67733: PUSH
67734: LD_INT 12
67736: ST_TO_ADDR
67737: GO 67778
67739: LD_INT 2
67741: DOUBLE
67742: EQUAL
67743: IFTRUE 67747
67745: GO 67758
67747: POP
// tech := tech_mortar ; 3 :
67748: LD_ADDR_VAR 0 5
67752: PUSH
67753: LD_INT 41
67755: ST_TO_ADDR
67756: GO 67778
67758: LD_INT 3
67760: DOUBLE
67761: EQUAL
67762: IFTRUE 67766
67764: GO 67777
67766: POP
// tech := tech_bazooka ; end ;
67767: LD_ADDR_VAR 0 5
67771: PUSH
67772: LD_INT 44
67774: ST_TO_ADDR
67775: GO 67778
67777: POP
// if Researched ( side , tech ) then
67778: LD_VAR 0 3
67782: PPUSH
67783: LD_VAR 0 5
67787: PPUSH
67788: CALL_OW 325
67792: IFFALSE 67819
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
67794: LD_ADDR_VAR 0 2
67798: PUSH
67799: LD_INT 5
67801: PUSH
67802: LD_INT 8
67804: PUSH
67805: LD_INT 9
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: LIST
67812: PUSH
67813: LD_VAR 0 4
67817: ARRAY
67818: ST_TO_ADDR
// end ;
67819: LD_VAR 0 2
67823: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
67824: LD_INT 0
67826: PPUSH
67827: PPUSH
67828: PPUSH
// if not mines then
67829: LD_VAR 0 2
67833: NOT
67834: IFFALSE 67838
// exit ;
67836: GO 67982
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
67838: LD_ADDR_VAR 0 5
67842: PUSH
67843: LD_INT 81
67845: PUSH
67846: LD_VAR 0 1
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: LD_INT 3
67857: PUSH
67858: LD_INT 21
67860: PUSH
67861: LD_INT 3
67863: PUSH
67864: EMPTY
67865: LIST
67866: LIST
67867: PUSH
67868: EMPTY
67869: LIST
67870: LIST
67871: PUSH
67872: EMPTY
67873: LIST
67874: LIST
67875: PPUSH
67876: CALL_OW 69
67880: ST_TO_ADDR
// for i in mines do
67881: LD_ADDR_VAR 0 4
67885: PUSH
67886: LD_VAR 0 2
67890: PUSH
67891: FOR_IN
67892: IFFALSE 67980
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
67894: LD_VAR 0 4
67898: PUSH
67899: LD_INT 1
67901: ARRAY
67902: PPUSH
67903: LD_VAR 0 4
67907: PUSH
67908: LD_INT 2
67910: ARRAY
67911: PPUSH
67912: CALL_OW 458
67916: NOT
67917: IFFALSE 67921
// continue ;
67919: GO 67891
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
67921: LD_VAR 0 4
67925: PUSH
67926: LD_INT 1
67928: ARRAY
67929: PPUSH
67930: LD_VAR 0 4
67934: PUSH
67935: LD_INT 2
67937: ARRAY
67938: PPUSH
67939: CALL_OW 428
67943: PUSH
67944: LD_VAR 0 5
67948: IN
67949: IFFALSE 67978
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
67951: LD_VAR 0 4
67955: PUSH
67956: LD_INT 1
67958: ARRAY
67959: PPUSH
67960: LD_VAR 0 4
67964: PUSH
67965: LD_INT 2
67967: ARRAY
67968: PPUSH
67969: LD_VAR 0 1
67973: PPUSH
67974: CALL_OW 456
// end ;
67978: GO 67891
67980: POP
67981: POP
// end ;
67982: LD_VAR 0 3
67986: RET
// export function Count ( array ) ; var i ; begin
67987: LD_INT 0
67989: PPUSH
67990: PPUSH
// result := 0 ;
67991: LD_ADDR_VAR 0 2
67995: PUSH
67996: LD_INT 0
67998: ST_TO_ADDR
// for i in array do
67999: LD_ADDR_VAR 0 3
68003: PUSH
68004: LD_VAR 0 1
68008: PUSH
68009: FOR_IN
68010: IFFALSE 68034
// if i then
68012: LD_VAR 0 3
68016: IFFALSE 68032
// result := result + 1 ;
68018: LD_ADDR_VAR 0 2
68022: PUSH
68023: LD_VAR 0 2
68027: PUSH
68028: LD_INT 1
68030: PLUS
68031: ST_TO_ADDR
68032: GO 68009
68034: POP
68035: POP
// end ;
68036: LD_VAR 0 2
68040: RET
// export function IsEmpty ( building ) ; begin
68041: LD_INT 0
68043: PPUSH
// if not building then
68044: LD_VAR 0 1
68048: NOT
68049: IFFALSE 68053
// exit ;
68051: GO 68096
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68053: LD_ADDR_VAR 0 2
68057: PUSH
68058: LD_VAR 0 1
68062: PUSH
68063: LD_INT 22
68065: PUSH
68066: LD_VAR 0 1
68070: PPUSH
68071: CALL_OW 255
68075: PUSH
68076: EMPTY
68077: LIST
68078: LIST
68079: PUSH
68080: LD_INT 58
68082: PUSH
68083: EMPTY
68084: LIST
68085: PUSH
68086: EMPTY
68087: LIST
68088: LIST
68089: PPUSH
68090: CALL_OW 69
68094: IN
68095: ST_TO_ADDR
// end ;
68096: LD_VAR 0 2
68100: RET
// export function IsNotFull ( building ) ; begin
68101: LD_INT 0
68103: PPUSH
// if not building then
68104: LD_VAR 0 1
68108: NOT
68109: IFFALSE 68113
// exit ;
68111: GO 68132
// result := UnitsInside ( building ) < 6 ;
68113: LD_ADDR_VAR 0 2
68117: PUSH
68118: LD_VAR 0 1
68122: PPUSH
68123: CALL_OW 313
68127: PUSH
68128: LD_INT 6
68130: LESS
68131: ST_TO_ADDR
// end ;
68132: LD_VAR 0 2
68136: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68137: LD_INT 0
68139: PPUSH
68140: PPUSH
68141: PPUSH
68142: PPUSH
// tmp := [ ] ;
68143: LD_ADDR_VAR 0 3
68147: PUSH
68148: EMPTY
68149: ST_TO_ADDR
// list := [ ] ;
68150: LD_ADDR_VAR 0 5
68154: PUSH
68155: EMPTY
68156: ST_TO_ADDR
// for i = 16 to 25 do
68157: LD_ADDR_VAR 0 4
68161: PUSH
68162: DOUBLE
68163: LD_INT 16
68165: DEC
68166: ST_TO_ADDR
68167: LD_INT 25
68169: PUSH
68170: FOR_TO
68171: IFFALSE 68244
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68173: LD_ADDR_VAR 0 3
68177: PUSH
68178: LD_VAR 0 3
68182: PUSH
68183: LD_INT 22
68185: PUSH
68186: LD_VAR 0 1
68190: PPUSH
68191: CALL_OW 255
68195: PUSH
68196: EMPTY
68197: LIST
68198: LIST
68199: PUSH
68200: LD_INT 91
68202: PUSH
68203: LD_VAR 0 1
68207: PUSH
68208: LD_INT 6
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: LIST
68215: PUSH
68216: LD_INT 30
68218: PUSH
68219: LD_VAR 0 4
68223: PUSH
68224: EMPTY
68225: LIST
68226: LIST
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: LIST
68232: PUSH
68233: EMPTY
68234: LIST
68235: PPUSH
68236: CALL_OW 69
68240: ADD
68241: ST_TO_ADDR
68242: GO 68170
68244: POP
68245: POP
// for i = 1 to tmp do
68246: LD_ADDR_VAR 0 4
68250: PUSH
68251: DOUBLE
68252: LD_INT 1
68254: DEC
68255: ST_TO_ADDR
68256: LD_VAR 0 3
68260: PUSH
68261: FOR_TO
68262: IFFALSE 68350
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68264: LD_ADDR_VAR 0 5
68268: PUSH
68269: LD_VAR 0 5
68273: PUSH
68274: LD_VAR 0 3
68278: PUSH
68279: LD_VAR 0 4
68283: ARRAY
68284: PPUSH
68285: CALL_OW 266
68289: PUSH
68290: LD_VAR 0 3
68294: PUSH
68295: LD_VAR 0 4
68299: ARRAY
68300: PPUSH
68301: CALL_OW 250
68305: PUSH
68306: LD_VAR 0 3
68310: PUSH
68311: LD_VAR 0 4
68315: ARRAY
68316: PPUSH
68317: CALL_OW 251
68321: PUSH
68322: LD_VAR 0 3
68326: PUSH
68327: LD_VAR 0 4
68331: ARRAY
68332: PPUSH
68333: CALL_OW 254
68337: PUSH
68338: EMPTY
68339: LIST
68340: LIST
68341: LIST
68342: LIST
68343: PUSH
68344: EMPTY
68345: LIST
68346: ADD
68347: ST_TO_ADDR
68348: GO 68261
68350: POP
68351: POP
// result := list ;
68352: LD_ADDR_VAR 0 2
68356: PUSH
68357: LD_VAR 0 5
68361: ST_TO_ADDR
// end ;
68362: LD_VAR 0 2
68366: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68367: LD_INT 0
68369: PPUSH
68370: PPUSH
68371: PPUSH
68372: PPUSH
68373: PPUSH
68374: PPUSH
68375: PPUSH
// if not factory then
68376: LD_VAR 0 1
68380: NOT
68381: IFFALSE 68385
// exit ;
68383: GO 68978
// if control = control_apeman then
68385: LD_VAR 0 4
68389: PUSH
68390: LD_INT 5
68392: EQUAL
68393: IFFALSE 68502
// begin tmp := UnitsInside ( factory ) ;
68395: LD_ADDR_VAR 0 8
68399: PUSH
68400: LD_VAR 0 1
68404: PPUSH
68405: CALL_OW 313
68409: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68410: LD_VAR 0 8
68414: PPUSH
68415: LD_INT 25
68417: PUSH
68418: LD_INT 12
68420: PUSH
68421: EMPTY
68422: LIST
68423: LIST
68424: PPUSH
68425: CALL_OW 72
68429: NOT
68430: IFFALSE 68440
// control := control_manual ;
68432: LD_ADDR_VAR 0 4
68436: PUSH
68437: LD_INT 1
68439: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68440: LD_ADDR_VAR 0 8
68444: PUSH
68445: LD_VAR 0 1
68449: PPUSH
68450: CALL 68137 0 1
68454: ST_TO_ADDR
// if tmp then
68455: LD_VAR 0 8
68459: IFFALSE 68502
// begin for i in tmp do
68461: LD_ADDR_VAR 0 7
68465: PUSH
68466: LD_VAR 0 8
68470: PUSH
68471: FOR_IN
68472: IFFALSE 68500
// if i [ 1 ] = b_ext_radio then
68474: LD_VAR 0 7
68478: PUSH
68479: LD_INT 1
68481: ARRAY
68482: PUSH
68483: LD_INT 22
68485: EQUAL
68486: IFFALSE 68498
// begin control := control_remote ;
68488: LD_ADDR_VAR 0 4
68492: PUSH
68493: LD_INT 2
68495: ST_TO_ADDR
// break ;
68496: GO 68500
// end ;
68498: GO 68471
68500: POP
68501: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68502: LD_VAR 0 1
68506: PPUSH
68507: LD_VAR 0 2
68511: PPUSH
68512: LD_VAR 0 3
68516: PPUSH
68517: LD_VAR 0 4
68521: PPUSH
68522: LD_VAR 0 5
68526: PPUSH
68527: CALL_OW 448
68531: IFFALSE 68566
// begin result := [ chassis , engine , control , weapon ] ;
68533: LD_ADDR_VAR 0 6
68537: PUSH
68538: LD_VAR 0 2
68542: PUSH
68543: LD_VAR 0 3
68547: PUSH
68548: LD_VAR 0 4
68552: PUSH
68553: LD_VAR 0 5
68557: PUSH
68558: EMPTY
68559: LIST
68560: LIST
68561: LIST
68562: LIST
68563: ST_TO_ADDR
// exit ;
68564: GO 68978
// end ; _chassis := AvailableChassisList ( factory ) ;
68566: LD_ADDR_VAR 0 9
68570: PUSH
68571: LD_VAR 0 1
68575: PPUSH
68576: CALL_OW 475
68580: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68581: LD_ADDR_VAR 0 11
68585: PUSH
68586: LD_VAR 0 1
68590: PPUSH
68591: CALL_OW 476
68595: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68596: LD_ADDR_VAR 0 12
68600: PUSH
68601: LD_VAR 0 1
68605: PPUSH
68606: CALL_OW 477
68610: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68611: LD_ADDR_VAR 0 10
68615: PUSH
68616: LD_VAR 0 1
68620: PPUSH
68621: CALL_OW 478
68625: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
68626: LD_VAR 0 9
68630: NOT
68631: PUSH
68632: LD_VAR 0 11
68636: NOT
68637: OR
68638: PUSH
68639: LD_VAR 0 12
68643: NOT
68644: OR
68645: PUSH
68646: LD_VAR 0 10
68650: NOT
68651: OR
68652: IFFALSE 68687
// begin result := [ chassis , engine , control , weapon ] ;
68654: LD_ADDR_VAR 0 6
68658: PUSH
68659: LD_VAR 0 2
68663: PUSH
68664: LD_VAR 0 3
68668: PUSH
68669: LD_VAR 0 4
68673: PUSH
68674: LD_VAR 0 5
68678: PUSH
68679: EMPTY
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: ST_TO_ADDR
// exit ;
68685: GO 68978
// end ; if not chassis in _chassis then
68687: LD_VAR 0 2
68691: PUSH
68692: LD_VAR 0 9
68696: IN
68697: NOT
68698: IFFALSE 68724
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
68700: LD_ADDR_VAR 0 2
68704: PUSH
68705: LD_VAR 0 9
68709: PUSH
68710: LD_INT 1
68712: PPUSH
68713: LD_VAR 0 9
68717: PPUSH
68718: CALL_OW 12
68722: ARRAY
68723: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
68724: LD_VAR 0 2
68728: PPUSH
68729: LD_VAR 0 3
68733: PPUSH
68734: CALL 68983 0 2
68738: NOT
68739: IFFALSE 68798
// repeat engine := _engine [ 1 ] ;
68741: LD_ADDR_VAR 0 3
68745: PUSH
68746: LD_VAR 0 11
68750: PUSH
68751: LD_INT 1
68753: ARRAY
68754: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
68755: LD_ADDR_VAR 0 11
68759: PUSH
68760: LD_VAR 0 11
68764: PPUSH
68765: LD_INT 1
68767: PPUSH
68768: CALL_OW 3
68772: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
68773: LD_VAR 0 2
68777: PPUSH
68778: LD_VAR 0 3
68782: PPUSH
68783: CALL 68983 0 2
68787: PUSH
68788: LD_VAR 0 11
68792: PUSH
68793: EMPTY
68794: EQUAL
68795: OR
68796: IFFALSE 68741
// if not control in _control then
68798: LD_VAR 0 4
68802: PUSH
68803: LD_VAR 0 12
68807: IN
68808: NOT
68809: IFFALSE 68835
// control := _control [ rand ( 1 , _control ) ] ;
68811: LD_ADDR_VAR 0 4
68815: PUSH
68816: LD_VAR 0 12
68820: PUSH
68821: LD_INT 1
68823: PPUSH
68824: LD_VAR 0 12
68828: PPUSH
68829: CALL_OW 12
68833: ARRAY
68834: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
68835: LD_VAR 0 2
68839: PPUSH
68840: LD_VAR 0 5
68844: PPUSH
68845: CALL 69203 0 2
68849: NOT
68850: IFFALSE 68909
// repeat weapon := _weapon [ 1 ] ;
68852: LD_ADDR_VAR 0 5
68856: PUSH
68857: LD_VAR 0 10
68861: PUSH
68862: LD_INT 1
68864: ARRAY
68865: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
68866: LD_ADDR_VAR 0 10
68870: PUSH
68871: LD_VAR 0 10
68875: PPUSH
68876: LD_INT 1
68878: PPUSH
68879: CALL_OW 3
68883: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
68884: LD_VAR 0 2
68888: PPUSH
68889: LD_VAR 0 5
68893: PPUSH
68894: CALL 69203 0 2
68898: PUSH
68899: LD_VAR 0 10
68903: PUSH
68904: EMPTY
68905: EQUAL
68906: OR
68907: IFFALSE 68852
// result := [ ] ;
68909: LD_ADDR_VAR 0 6
68913: PUSH
68914: EMPTY
68915: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68916: LD_VAR 0 1
68920: PPUSH
68921: LD_VAR 0 2
68925: PPUSH
68926: LD_VAR 0 3
68930: PPUSH
68931: LD_VAR 0 4
68935: PPUSH
68936: LD_VAR 0 5
68940: PPUSH
68941: CALL_OW 448
68945: IFFALSE 68978
// result := [ chassis , engine , control , weapon ] ;
68947: LD_ADDR_VAR 0 6
68951: PUSH
68952: LD_VAR 0 2
68956: PUSH
68957: LD_VAR 0 3
68961: PUSH
68962: LD_VAR 0 4
68966: PUSH
68967: LD_VAR 0 5
68971: PUSH
68972: EMPTY
68973: LIST
68974: LIST
68975: LIST
68976: LIST
68977: ST_TO_ADDR
// end ;
68978: LD_VAR 0 6
68982: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
68983: LD_INT 0
68985: PPUSH
// if not chassis or not engine then
68986: LD_VAR 0 1
68990: NOT
68991: PUSH
68992: LD_VAR 0 2
68996: NOT
68997: OR
68998: IFFALSE 69002
// exit ;
69000: GO 69198
// case engine of engine_solar :
69002: LD_VAR 0 2
69006: PUSH
69007: LD_INT 2
69009: DOUBLE
69010: EQUAL
69011: IFTRUE 69015
69013: GO 69053
69015: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69016: LD_ADDR_VAR 0 3
69020: PUSH
69021: LD_INT 11
69023: PUSH
69024: LD_INT 12
69026: PUSH
69027: LD_INT 13
69029: PUSH
69030: LD_INT 14
69032: PUSH
69033: LD_INT 1
69035: PUSH
69036: LD_INT 2
69038: PUSH
69039: LD_INT 3
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: LIST
69046: LIST
69047: LIST
69048: LIST
69049: LIST
69050: ST_TO_ADDR
69051: GO 69182
69053: LD_INT 1
69055: DOUBLE
69056: EQUAL
69057: IFTRUE 69061
69059: GO 69123
69061: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69062: LD_ADDR_VAR 0 3
69066: PUSH
69067: LD_INT 11
69069: PUSH
69070: LD_INT 12
69072: PUSH
69073: LD_INT 13
69075: PUSH
69076: LD_INT 14
69078: PUSH
69079: LD_INT 1
69081: PUSH
69082: LD_INT 2
69084: PUSH
69085: LD_INT 3
69087: PUSH
69088: LD_INT 4
69090: PUSH
69091: LD_INT 5
69093: PUSH
69094: LD_INT 21
69096: PUSH
69097: LD_INT 23
69099: PUSH
69100: LD_INT 22
69102: PUSH
69103: LD_INT 24
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: LIST
69110: LIST
69111: LIST
69112: LIST
69113: LIST
69114: LIST
69115: LIST
69116: LIST
69117: LIST
69118: LIST
69119: LIST
69120: ST_TO_ADDR
69121: GO 69182
69123: LD_INT 3
69125: DOUBLE
69126: EQUAL
69127: IFTRUE 69131
69129: GO 69181
69131: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69132: LD_ADDR_VAR 0 3
69136: PUSH
69137: LD_INT 13
69139: PUSH
69140: LD_INT 14
69142: PUSH
69143: LD_INT 2
69145: PUSH
69146: LD_INT 3
69148: PUSH
69149: LD_INT 4
69151: PUSH
69152: LD_INT 5
69154: PUSH
69155: LD_INT 21
69157: PUSH
69158: LD_INT 22
69160: PUSH
69161: LD_INT 23
69163: PUSH
69164: LD_INT 24
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: LIST
69171: LIST
69172: LIST
69173: LIST
69174: LIST
69175: LIST
69176: LIST
69177: LIST
69178: ST_TO_ADDR
69179: GO 69182
69181: POP
// result := ( chassis in result ) ;
69182: LD_ADDR_VAR 0 3
69186: PUSH
69187: LD_VAR 0 1
69191: PUSH
69192: LD_VAR 0 3
69196: IN
69197: ST_TO_ADDR
// end ;
69198: LD_VAR 0 3
69202: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69203: LD_INT 0
69205: PPUSH
// if not chassis or not weapon then
69206: LD_VAR 0 1
69210: NOT
69211: PUSH
69212: LD_VAR 0 2
69216: NOT
69217: OR
69218: IFFALSE 69222
// exit ;
69220: GO 70284
// case weapon of us_machine_gun :
69222: LD_VAR 0 2
69226: PUSH
69227: LD_INT 2
69229: DOUBLE
69230: EQUAL
69231: IFTRUE 69235
69233: GO 69265
69235: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69236: LD_ADDR_VAR 0 3
69240: PUSH
69241: LD_INT 1
69243: PUSH
69244: LD_INT 2
69246: PUSH
69247: LD_INT 3
69249: PUSH
69250: LD_INT 4
69252: PUSH
69253: LD_INT 5
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: LIST
69262: ST_TO_ADDR
69263: GO 70268
69265: LD_INT 3
69267: DOUBLE
69268: EQUAL
69269: IFTRUE 69273
69271: GO 69303
69273: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69274: LD_ADDR_VAR 0 3
69278: PUSH
69279: LD_INT 1
69281: PUSH
69282: LD_INT 2
69284: PUSH
69285: LD_INT 3
69287: PUSH
69288: LD_INT 4
69290: PUSH
69291: LD_INT 5
69293: PUSH
69294: EMPTY
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: ST_TO_ADDR
69301: GO 70268
69303: LD_INT 11
69305: DOUBLE
69306: EQUAL
69307: IFTRUE 69311
69309: GO 69341
69311: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69312: LD_ADDR_VAR 0 3
69316: PUSH
69317: LD_INT 1
69319: PUSH
69320: LD_INT 2
69322: PUSH
69323: LD_INT 3
69325: PUSH
69326: LD_INT 4
69328: PUSH
69329: LD_INT 5
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: LIST
69338: ST_TO_ADDR
69339: GO 70268
69341: LD_INT 4
69343: DOUBLE
69344: EQUAL
69345: IFTRUE 69349
69347: GO 69375
69349: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69350: LD_ADDR_VAR 0 3
69354: PUSH
69355: LD_INT 2
69357: PUSH
69358: LD_INT 3
69360: PUSH
69361: LD_INT 4
69363: PUSH
69364: LD_INT 5
69366: PUSH
69367: EMPTY
69368: LIST
69369: LIST
69370: LIST
69371: LIST
69372: ST_TO_ADDR
69373: GO 70268
69375: LD_INT 5
69377: DOUBLE
69378: EQUAL
69379: IFTRUE 69383
69381: GO 69409
69383: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69384: LD_ADDR_VAR 0 3
69388: PUSH
69389: LD_INT 2
69391: PUSH
69392: LD_INT 3
69394: PUSH
69395: LD_INT 4
69397: PUSH
69398: LD_INT 5
69400: PUSH
69401: EMPTY
69402: LIST
69403: LIST
69404: LIST
69405: LIST
69406: ST_TO_ADDR
69407: GO 70268
69409: LD_INT 9
69411: DOUBLE
69412: EQUAL
69413: IFTRUE 69417
69415: GO 69443
69417: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69418: LD_ADDR_VAR 0 3
69422: PUSH
69423: LD_INT 2
69425: PUSH
69426: LD_INT 3
69428: PUSH
69429: LD_INT 4
69431: PUSH
69432: LD_INT 5
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: LIST
69439: LIST
69440: ST_TO_ADDR
69441: GO 70268
69443: LD_INT 7
69445: DOUBLE
69446: EQUAL
69447: IFTRUE 69451
69449: GO 69477
69451: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69452: LD_ADDR_VAR 0 3
69456: PUSH
69457: LD_INT 2
69459: PUSH
69460: LD_INT 3
69462: PUSH
69463: LD_INT 4
69465: PUSH
69466: LD_INT 5
69468: PUSH
69469: EMPTY
69470: LIST
69471: LIST
69472: LIST
69473: LIST
69474: ST_TO_ADDR
69475: GO 70268
69477: LD_INT 12
69479: DOUBLE
69480: EQUAL
69481: IFTRUE 69485
69483: GO 69511
69485: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69486: LD_ADDR_VAR 0 3
69490: PUSH
69491: LD_INT 2
69493: PUSH
69494: LD_INT 3
69496: PUSH
69497: LD_INT 4
69499: PUSH
69500: LD_INT 5
69502: PUSH
69503: EMPTY
69504: LIST
69505: LIST
69506: LIST
69507: LIST
69508: ST_TO_ADDR
69509: GO 70268
69511: LD_INT 13
69513: DOUBLE
69514: EQUAL
69515: IFTRUE 69519
69517: GO 69545
69519: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69520: LD_ADDR_VAR 0 3
69524: PUSH
69525: LD_INT 2
69527: PUSH
69528: LD_INT 3
69530: PUSH
69531: LD_INT 4
69533: PUSH
69534: LD_INT 5
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: LIST
69541: LIST
69542: ST_TO_ADDR
69543: GO 70268
69545: LD_INT 14
69547: DOUBLE
69548: EQUAL
69549: IFTRUE 69553
69551: GO 69571
69553: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69554: LD_ADDR_VAR 0 3
69558: PUSH
69559: LD_INT 4
69561: PUSH
69562: LD_INT 5
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: ST_TO_ADDR
69569: GO 70268
69571: LD_INT 6
69573: DOUBLE
69574: EQUAL
69575: IFTRUE 69579
69577: GO 69597
69579: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69580: LD_ADDR_VAR 0 3
69584: PUSH
69585: LD_INT 4
69587: PUSH
69588: LD_INT 5
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: ST_TO_ADDR
69595: GO 70268
69597: LD_INT 10
69599: DOUBLE
69600: EQUAL
69601: IFTRUE 69605
69603: GO 69623
69605: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69606: LD_ADDR_VAR 0 3
69610: PUSH
69611: LD_INT 4
69613: PUSH
69614: LD_INT 5
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: ST_TO_ADDR
69621: GO 70268
69623: LD_INT 22
69625: DOUBLE
69626: EQUAL
69627: IFTRUE 69631
69629: GO 69657
69631: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
69632: LD_ADDR_VAR 0 3
69636: PUSH
69637: LD_INT 11
69639: PUSH
69640: LD_INT 12
69642: PUSH
69643: LD_INT 13
69645: PUSH
69646: LD_INT 14
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: LIST
69653: LIST
69654: ST_TO_ADDR
69655: GO 70268
69657: LD_INT 23
69659: DOUBLE
69660: EQUAL
69661: IFTRUE 69665
69663: GO 69691
69665: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
69666: LD_ADDR_VAR 0 3
69670: PUSH
69671: LD_INT 11
69673: PUSH
69674: LD_INT 12
69676: PUSH
69677: LD_INT 13
69679: PUSH
69680: LD_INT 14
69682: PUSH
69683: EMPTY
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: ST_TO_ADDR
69689: GO 70268
69691: LD_INT 24
69693: DOUBLE
69694: EQUAL
69695: IFTRUE 69699
69697: GO 69725
69699: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
69700: LD_ADDR_VAR 0 3
69704: PUSH
69705: LD_INT 11
69707: PUSH
69708: LD_INT 12
69710: PUSH
69711: LD_INT 13
69713: PUSH
69714: LD_INT 14
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: LIST
69721: LIST
69722: ST_TO_ADDR
69723: GO 70268
69725: LD_INT 30
69727: DOUBLE
69728: EQUAL
69729: IFTRUE 69733
69731: GO 69759
69733: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
69734: LD_ADDR_VAR 0 3
69738: PUSH
69739: LD_INT 11
69741: PUSH
69742: LD_INT 12
69744: PUSH
69745: LD_INT 13
69747: PUSH
69748: LD_INT 14
69750: PUSH
69751: EMPTY
69752: LIST
69753: LIST
69754: LIST
69755: LIST
69756: ST_TO_ADDR
69757: GO 70268
69759: LD_INT 25
69761: DOUBLE
69762: EQUAL
69763: IFTRUE 69767
69765: GO 69785
69767: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
69768: LD_ADDR_VAR 0 3
69772: PUSH
69773: LD_INT 13
69775: PUSH
69776: LD_INT 14
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: ST_TO_ADDR
69783: GO 70268
69785: LD_INT 27
69787: DOUBLE
69788: EQUAL
69789: IFTRUE 69793
69791: GO 69811
69793: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
69794: LD_ADDR_VAR 0 3
69798: PUSH
69799: LD_INT 13
69801: PUSH
69802: LD_INT 14
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: ST_TO_ADDR
69809: GO 70268
69811: LD_EXP 100
69815: DOUBLE
69816: EQUAL
69817: IFTRUE 69821
69819: GO 69847
69821: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
69822: LD_ADDR_VAR 0 3
69826: PUSH
69827: LD_INT 11
69829: PUSH
69830: LD_INT 12
69832: PUSH
69833: LD_INT 13
69835: PUSH
69836: LD_INT 14
69838: PUSH
69839: EMPTY
69840: LIST
69841: LIST
69842: LIST
69843: LIST
69844: ST_TO_ADDR
69845: GO 70268
69847: LD_INT 28
69849: DOUBLE
69850: EQUAL
69851: IFTRUE 69855
69853: GO 69873
69855: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
69856: LD_ADDR_VAR 0 3
69860: PUSH
69861: LD_INT 13
69863: PUSH
69864: LD_INT 14
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: ST_TO_ADDR
69871: GO 70268
69873: LD_INT 29
69875: DOUBLE
69876: EQUAL
69877: IFTRUE 69881
69879: GO 69899
69881: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
69882: LD_ADDR_VAR 0 3
69886: PUSH
69887: LD_INT 13
69889: PUSH
69890: LD_INT 14
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: ST_TO_ADDR
69897: GO 70268
69899: LD_INT 31
69901: DOUBLE
69902: EQUAL
69903: IFTRUE 69907
69905: GO 69925
69907: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
69908: LD_ADDR_VAR 0 3
69912: PUSH
69913: LD_INT 13
69915: PUSH
69916: LD_INT 14
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: ST_TO_ADDR
69923: GO 70268
69925: LD_INT 26
69927: DOUBLE
69928: EQUAL
69929: IFTRUE 69933
69931: GO 69951
69933: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
69934: LD_ADDR_VAR 0 3
69938: PUSH
69939: LD_INT 13
69941: PUSH
69942: LD_INT 14
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: ST_TO_ADDR
69949: GO 70268
69951: LD_INT 42
69953: DOUBLE
69954: EQUAL
69955: IFTRUE 69959
69957: GO 69985
69959: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
69960: LD_ADDR_VAR 0 3
69964: PUSH
69965: LD_INT 21
69967: PUSH
69968: LD_INT 22
69970: PUSH
69971: LD_INT 23
69973: PUSH
69974: LD_INT 24
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: ST_TO_ADDR
69983: GO 70268
69985: LD_INT 43
69987: DOUBLE
69988: EQUAL
69989: IFTRUE 69993
69991: GO 70019
69993: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
69994: LD_ADDR_VAR 0 3
69998: PUSH
69999: LD_INT 21
70001: PUSH
70002: LD_INT 22
70004: PUSH
70005: LD_INT 23
70007: PUSH
70008: LD_INT 24
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: LIST
70015: LIST
70016: ST_TO_ADDR
70017: GO 70268
70019: LD_INT 44
70021: DOUBLE
70022: EQUAL
70023: IFTRUE 70027
70025: GO 70053
70027: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70028: LD_ADDR_VAR 0 3
70032: PUSH
70033: LD_INT 21
70035: PUSH
70036: LD_INT 22
70038: PUSH
70039: LD_INT 23
70041: PUSH
70042: LD_INT 24
70044: PUSH
70045: EMPTY
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: ST_TO_ADDR
70051: GO 70268
70053: LD_INT 45
70055: DOUBLE
70056: EQUAL
70057: IFTRUE 70061
70059: GO 70087
70061: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70062: LD_ADDR_VAR 0 3
70066: PUSH
70067: LD_INT 21
70069: PUSH
70070: LD_INT 22
70072: PUSH
70073: LD_INT 23
70075: PUSH
70076: LD_INT 24
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: LIST
70083: LIST
70084: ST_TO_ADDR
70085: GO 70268
70087: LD_INT 49
70089: DOUBLE
70090: EQUAL
70091: IFTRUE 70095
70093: GO 70121
70095: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70096: LD_ADDR_VAR 0 3
70100: PUSH
70101: LD_INT 21
70103: PUSH
70104: LD_INT 22
70106: PUSH
70107: LD_INT 23
70109: PUSH
70110: LD_INT 24
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: LIST
70117: LIST
70118: ST_TO_ADDR
70119: GO 70268
70121: LD_INT 51
70123: DOUBLE
70124: EQUAL
70125: IFTRUE 70129
70127: GO 70155
70129: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70130: LD_ADDR_VAR 0 3
70134: PUSH
70135: LD_INT 21
70137: PUSH
70138: LD_INT 22
70140: PUSH
70141: LD_INT 23
70143: PUSH
70144: LD_INT 24
70146: PUSH
70147: EMPTY
70148: LIST
70149: LIST
70150: LIST
70151: LIST
70152: ST_TO_ADDR
70153: GO 70268
70155: LD_INT 52
70157: DOUBLE
70158: EQUAL
70159: IFTRUE 70163
70161: GO 70189
70163: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70164: LD_ADDR_VAR 0 3
70168: PUSH
70169: LD_INT 21
70171: PUSH
70172: LD_INT 22
70174: PUSH
70175: LD_INT 23
70177: PUSH
70178: LD_INT 24
70180: PUSH
70181: EMPTY
70182: LIST
70183: LIST
70184: LIST
70185: LIST
70186: ST_TO_ADDR
70187: GO 70268
70189: LD_INT 53
70191: DOUBLE
70192: EQUAL
70193: IFTRUE 70197
70195: GO 70215
70197: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70198: LD_ADDR_VAR 0 3
70202: PUSH
70203: LD_INT 23
70205: PUSH
70206: LD_INT 24
70208: PUSH
70209: EMPTY
70210: LIST
70211: LIST
70212: ST_TO_ADDR
70213: GO 70268
70215: LD_INT 46
70217: DOUBLE
70218: EQUAL
70219: IFTRUE 70223
70221: GO 70241
70223: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70224: LD_ADDR_VAR 0 3
70228: PUSH
70229: LD_INT 23
70231: PUSH
70232: LD_INT 24
70234: PUSH
70235: EMPTY
70236: LIST
70237: LIST
70238: ST_TO_ADDR
70239: GO 70268
70241: LD_INT 47
70243: DOUBLE
70244: EQUAL
70245: IFTRUE 70249
70247: GO 70267
70249: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70250: LD_ADDR_VAR 0 3
70254: PUSH
70255: LD_INT 23
70257: PUSH
70258: LD_INT 24
70260: PUSH
70261: EMPTY
70262: LIST
70263: LIST
70264: ST_TO_ADDR
70265: GO 70268
70267: POP
// result := ( chassis in result ) ;
70268: LD_ADDR_VAR 0 3
70272: PUSH
70273: LD_VAR 0 1
70277: PUSH
70278: LD_VAR 0 3
70282: IN
70283: ST_TO_ADDR
// end ;
70284: LD_VAR 0 3
70288: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70289: LD_INT 0
70291: PPUSH
70292: PPUSH
70293: PPUSH
70294: PPUSH
70295: PPUSH
70296: PPUSH
70297: PPUSH
// result := array ;
70298: LD_ADDR_VAR 0 5
70302: PUSH
70303: LD_VAR 0 1
70307: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70308: LD_VAR 0 1
70312: NOT
70313: PUSH
70314: LD_VAR 0 2
70318: NOT
70319: OR
70320: PUSH
70321: LD_VAR 0 3
70325: NOT
70326: OR
70327: PUSH
70328: LD_VAR 0 2
70332: PUSH
70333: LD_VAR 0 1
70337: GREATER
70338: OR
70339: PUSH
70340: LD_VAR 0 3
70344: PUSH
70345: LD_VAR 0 1
70349: GREATER
70350: OR
70351: IFFALSE 70355
// exit ;
70353: GO 70651
// if direction then
70355: LD_VAR 0 4
70359: IFFALSE 70423
// begin d := 1 ;
70361: LD_ADDR_VAR 0 9
70365: PUSH
70366: LD_INT 1
70368: ST_TO_ADDR
// if i_from > i_to then
70369: LD_VAR 0 2
70373: PUSH
70374: LD_VAR 0 3
70378: GREATER
70379: IFFALSE 70405
// length := ( array - i_from ) + i_to else
70381: LD_ADDR_VAR 0 11
70385: PUSH
70386: LD_VAR 0 1
70390: PUSH
70391: LD_VAR 0 2
70395: MINUS
70396: PUSH
70397: LD_VAR 0 3
70401: PLUS
70402: ST_TO_ADDR
70403: GO 70421
// length := i_to - i_from ;
70405: LD_ADDR_VAR 0 11
70409: PUSH
70410: LD_VAR 0 3
70414: PUSH
70415: LD_VAR 0 2
70419: MINUS
70420: ST_TO_ADDR
// end else
70421: GO 70484
// begin d := - 1 ;
70423: LD_ADDR_VAR 0 9
70427: PUSH
70428: LD_INT 1
70430: NEG
70431: ST_TO_ADDR
// if i_from > i_to then
70432: LD_VAR 0 2
70436: PUSH
70437: LD_VAR 0 3
70441: GREATER
70442: IFFALSE 70462
// length := i_from - i_to else
70444: LD_ADDR_VAR 0 11
70448: PUSH
70449: LD_VAR 0 2
70453: PUSH
70454: LD_VAR 0 3
70458: MINUS
70459: ST_TO_ADDR
70460: GO 70484
// length := ( array - i_to ) + i_from ;
70462: LD_ADDR_VAR 0 11
70466: PUSH
70467: LD_VAR 0 1
70471: PUSH
70472: LD_VAR 0 3
70476: MINUS
70477: PUSH
70478: LD_VAR 0 2
70482: PLUS
70483: ST_TO_ADDR
// end ; if not length then
70484: LD_VAR 0 11
70488: NOT
70489: IFFALSE 70493
// exit ;
70491: GO 70651
// tmp := array ;
70493: LD_ADDR_VAR 0 10
70497: PUSH
70498: LD_VAR 0 1
70502: ST_TO_ADDR
// for i = 1 to length do
70503: LD_ADDR_VAR 0 6
70507: PUSH
70508: DOUBLE
70509: LD_INT 1
70511: DEC
70512: ST_TO_ADDR
70513: LD_VAR 0 11
70517: PUSH
70518: FOR_TO
70519: IFFALSE 70639
// begin for j = 1 to array do
70521: LD_ADDR_VAR 0 7
70525: PUSH
70526: DOUBLE
70527: LD_INT 1
70529: DEC
70530: ST_TO_ADDR
70531: LD_VAR 0 1
70535: PUSH
70536: FOR_TO
70537: IFFALSE 70625
// begin k := j + d ;
70539: LD_ADDR_VAR 0 8
70543: PUSH
70544: LD_VAR 0 7
70548: PUSH
70549: LD_VAR 0 9
70553: PLUS
70554: ST_TO_ADDR
// if k > array then
70555: LD_VAR 0 8
70559: PUSH
70560: LD_VAR 0 1
70564: GREATER
70565: IFFALSE 70575
// k := 1 ;
70567: LD_ADDR_VAR 0 8
70571: PUSH
70572: LD_INT 1
70574: ST_TO_ADDR
// if not k then
70575: LD_VAR 0 8
70579: NOT
70580: IFFALSE 70592
// k := array ;
70582: LD_ADDR_VAR 0 8
70586: PUSH
70587: LD_VAR 0 1
70591: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70592: LD_ADDR_VAR 0 10
70596: PUSH
70597: LD_VAR 0 10
70601: PPUSH
70602: LD_VAR 0 8
70606: PPUSH
70607: LD_VAR 0 1
70611: PUSH
70612: LD_VAR 0 7
70616: ARRAY
70617: PPUSH
70618: CALL_OW 1
70622: ST_TO_ADDR
// end ;
70623: GO 70536
70625: POP
70626: POP
// array := tmp ;
70627: LD_ADDR_VAR 0 1
70631: PUSH
70632: LD_VAR 0 10
70636: ST_TO_ADDR
// end ;
70637: GO 70518
70639: POP
70640: POP
// result := array ;
70641: LD_ADDR_VAR 0 5
70645: PUSH
70646: LD_VAR 0 1
70650: ST_TO_ADDR
// end ;
70651: LD_VAR 0 5
70655: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70656: LD_INT 0
70658: PPUSH
70659: PPUSH
// result := 0 ;
70660: LD_ADDR_VAR 0 3
70664: PUSH
70665: LD_INT 0
70667: ST_TO_ADDR
// if not array or not value in array then
70668: LD_VAR 0 1
70672: NOT
70673: PUSH
70674: LD_VAR 0 2
70678: PUSH
70679: LD_VAR 0 1
70683: IN
70684: NOT
70685: OR
70686: IFFALSE 70690
// exit ;
70688: GO 70744
// for i = 1 to array do
70690: LD_ADDR_VAR 0 4
70694: PUSH
70695: DOUBLE
70696: LD_INT 1
70698: DEC
70699: ST_TO_ADDR
70700: LD_VAR 0 1
70704: PUSH
70705: FOR_TO
70706: IFFALSE 70742
// if value = array [ i ] then
70708: LD_VAR 0 2
70712: PUSH
70713: LD_VAR 0 1
70717: PUSH
70718: LD_VAR 0 4
70722: ARRAY
70723: EQUAL
70724: IFFALSE 70740
// begin result := i ;
70726: LD_ADDR_VAR 0 3
70730: PUSH
70731: LD_VAR 0 4
70735: ST_TO_ADDR
// exit ;
70736: POP
70737: POP
70738: GO 70744
// end ;
70740: GO 70705
70742: POP
70743: POP
// end ;
70744: LD_VAR 0 3
70748: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
70749: LD_INT 0
70751: PPUSH
// vc_chassis := chassis ;
70752: LD_ADDR_OWVAR 37
70756: PUSH
70757: LD_VAR 0 1
70761: ST_TO_ADDR
// vc_engine := engine ;
70762: LD_ADDR_OWVAR 39
70766: PUSH
70767: LD_VAR 0 2
70771: ST_TO_ADDR
// vc_control := control ;
70772: LD_ADDR_OWVAR 38
70776: PUSH
70777: LD_VAR 0 3
70781: ST_TO_ADDR
// vc_weapon := weapon ;
70782: LD_ADDR_OWVAR 40
70786: PUSH
70787: LD_VAR 0 4
70791: ST_TO_ADDR
// vc_fuel_battery := fuel ;
70792: LD_ADDR_OWVAR 41
70796: PUSH
70797: LD_VAR 0 5
70801: ST_TO_ADDR
// end ;
70802: LD_VAR 0 6
70806: RET
// export function WantPlant ( unit ) ; var task ; begin
70807: LD_INT 0
70809: PPUSH
70810: PPUSH
// result := false ;
70811: LD_ADDR_VAR 0 2
70815: PUSH
70816: LD_INT 0
70818: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
70819: LD_ADDR_VAR 0 3
70823: PUSH
70824: LD_VAR 0 1
70828: PPUSH
70829: CALL_OW 437
70833: ST_TO_ADDR
// if task then
70834: LD_VAR 0 3
70838: IFFALSE 70866
// if task [ 1 ] [ 1 ] = p then
70840: LD_VAR 0 3
70844: PUSH
70845: LD_INT 1
70847: ARRAY
70848: PUSH
70849: LD_INT 1
70851: ARRAY
70852: PUSH
70853: LD_STRING p
70855: EQUAL
70856: IFFALSE 70866
// result := true ;
70858: LD_ADDR_VAR 0 2
70862: PUSH
70863: LD_INT 1
70865: ST_TO_ADDR
// end ;
70866: LD_VAR 0 2
70870: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
70871: LD_INT 0
70873: PPUSH
70874: PPUSH
70875: PPUSH
70876: PPUSH
// if pos < 1 then
70877: LD_VAR 0 2
70881: PUSH
70882: LD_INT 1
70884: LESS
70885: IFFALSE 70889
// exit ;
70887: GO 71192
// if pos = 1 then
70889: LD_VAR 0 2
70893: PUSH
70894: LD_INT 1
70896: EQUAL
70897: IFFALSE 70930
// result := Replace ( arr , pos [ 1 ] , value ) else
70899: LD_ADDR_VAR 0 4
70903: PUSH
70904: LD_VAR 0 1
70908: PPUSH
70909: LD_VAR 0 2
70913: PUSH
70914: LD_INT 1
70916: ARRAY
70917: PPUSH
70918: LD_VAR 0 3
70922: PPUSH
70923: CALL_OW 1
70927: ST_TO_ADDR
70928: GO 71192
// begin tmp := arr ;
70930: LD_ADDR_VAR 0 6
70934: PUSH
70935: LD_VAR 0 1
70939: ST_TO_ADDR
// s_arr := [ tmp ] ;
70940: LD_ADDR_VAR 0 7
70944: PUSH
70945: LD_VAR 0 6
70949: PUSH
70950: EMPTY
70951: LIST
70952: ST_TO_ADDR
// for i = 1 to pos - 1 do
70953: LD_ADDR_VAR 0 5
70957: PUSH
70958: DOUBLE
70959: LD_INT 1
70961: DEC
70962: ST_TO_ADDR
70963: LD_VAR 0 2
70967: PUSH
70968: LD_INT 1
70970: MINUS
70971: PUSH
70972: FOR_TO
70973: IFFALSE 71018
// begin tmp := tmp [ pos [ i ] ] ;
70975: LD_ADDR_VAR 0 6
70979: PUSH
70980: LD_VAR 0 6
70984: PUSH
70985: LD_VAR 0 2
70989: PUSH
70990: LD_VAR 0 5
70994: ARRAY
70995: ARRAY
70996: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
70997: LD_ADDR_VAR 0 7
71001: PUSH
71002: LD_VAR 0 7
71006: PUSH
71007: LD_VAR 0 6
71011: PUSH
71012: EMPTY
71013: LIST
71014: ADD
71015: ST_TO_ADDR
// end ;
71016: GO 70972
71018: POP
71019: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71020: LD_ADDR_VAR 0 6
71024: PUSH
71025: LD_VAR 0 6
71029: PPUSH
71030: LD_VAR 0 2
71034: PUSH
71035: LD_VAR 0 2
71039: ARRAY
71040: PPUSH
71041: LD_VAR 0 3
71045: PPUSH
71046: CALL_OW 1
71050: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71051: LD_ADDR_VAR 0 7
71055: PUSH
71056: LD_VAR 0 7
71060: PPUSH
71061: LD_VAR 0 7
71065: PPUSH
71066: LD_VAR 0 6
71070: PPUSH
71071: CALL_OW 1
71075: ST_TO_ADDR
// for i = s_arr downto 2 do
71076: LD_ADDR_VAR 0 5
71080: PUSH
71081: DOUBLE
71082: LD_VAR 0 7
71086: INC
71087: ST_TO_ADDR
71088: LD_INT 2
71090: PUSH
71091: FOR_DOWNTO
71092: IFFALSE 71176
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71094: LD_ADDR_VAR 0 6
71098: PUSH
71099: LD_VAR 0 7
71103: PUSH
71104: LD_VAR 0 5
71108: PUSH
71109: LD_INT 1
71111: MINUS
71112: ARRAY
71113: PPUSH
71114: LD_VAR 0 2
71118: PUSH
71119: LD_VAR 0 5
71123: PUSH
71124: LD_INT 1
71126: MINUS
71127: ARRAY
71128: PPUSH
71129: LD_VAR 0 7
71133: PUSH
71134: LD_VAR 0 5
71138: ARRAY
71139: PPUSH
71140: CALL_OW 1
71144: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71145: LD_ADDR_VAR 0 7
71149: PUSH
71150: LD_VAR 0 7
71154: PPUSH
71155: LD_VAR 0 5
71159: PUSH
71160: LD_INT 1
71162: MINUS
71163: PPUSH
71164: LD_VAR 0 6
71168: PPUSH
71169: CALL_OW 1
71173: ST_TO_ADDR
// end ;
71174: GO 71091
71176: POP
71177: POP
// result := s_arr [ 1 ] ;
71178: LD_ADDR_VAR 0 4
71182: PUSH
71183: LD_VAR 0 7
71187: PUSH
71188: LD_INT 1
71190: ARRAY
71191: ST_TO_ADDR
// end ; end ;
71192: LD_VAR 0 4
71196: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71197: LD_INT 0
71199: PPUSH
71200: PPUSH
// if not list then
71201: LD_VAR 0 1
71205: NOT
71206: IFFALSE 71210
// exit ;
71208: GO 71301
// i := list [ pos1 ] ;
71210: LD_ADDR_VAR 0 5
71214: PUSH
71215: LD_VAR 0 1
71219: PUSH
71220: LD_VAR 0 2
71224: ARRAY
71225: ST_TO_ADDR
// if not i then
71226: LD_VAR 0 5
71230: NOT
71231: IFFALSE 71235
// exit ;
71233: GO 71301
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71235: LD_ADDR_VAR 0 1
71239: PUSH
71240: LD_VAR 0 1
71244: PPUSH
71245: LD_VAR 0 2
71249: PPUSH
71250: LD_VAR 0 1
71254: PUSH
71255: LD_VAR 0 3
71259: ARRAY
71260: PPUSH
71261: CALL_OW 1
71265: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71266: LD_ADDR_VAR 0 1
71270: PUSH
71271: LD_VAR 0 1
71275: PPUSH
71276: LD_VAR 0 3
71280: PPUSH
71281: LD_VAR 0 5
71285: PPUSH
71286: CALL_OW 1
71290: ST_TO_ADDR
// result := list ;
71291: LD_ADDR_VAR 0 4
71295: PUSH
71296: LD_VAR 0 1
71300: ST_TO_ADDR
// end ;
71301: LD_VAR 0 4
71305: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71306: LD_INT 0
71308: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71309: LD_ADDR_VAR 0 5
71313: PUSH
71314: LD_VAR 0 1
71318: PPUSH
71319: CALL_OW 250
71323: PPUSH
71324: LD_VAR 0 1
71328: PPUSH
71329: CALL_OW 251
71333: PPUSH
71334: LD_VAR 0 2
71338: PPUSH
71339: LD_VAR 0 3
71343: PPUSH
71344: LD_VAR 0 4
71348: PPUSH
71349: CALL 71359 0 5
71353: ST_TO_ADDR
// end ;
71354: LD_VAR 0 5
71358: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71359: LD_INT 0
71361: PPUSH
71362: PPUSH
71363: PPUSH
71364: PPUSH
// if not list then
71365: LD_VAR 0 3
71369: NOT
71370: IFFALSE 71374
// exit ;
71372: GO 71762
// result := [ ] ;
71374: LD_ADDR_VAR 0 6
71378: PUSH
71379: EMPTY
71380: ST_TO_ADDR
// for i in list do
71381: LD_ADDR_VAR 0 7
71385: PUSH
71386: LD_VAR 0 3
71390: PUSH
71391: FOR_IN
71392: IFFALSE 71594
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71394: LD_ADDR_VAR 0 9
71398: PUSH
71399: LD_VAR 0 7
71403: PPUSH
71404: LD_VAR 0 1
71408: PPUSH
71409: LD_VAR 0 2
71413: PPUSH
71414: CALL_OW 297
71418: ST_TO_ADDR
// if not result then
71419: LD_VAR 0 6
71423: NOT
71424: IFFALSE 71450
// result := [ [ i , tmp ] ] else
71426: LD_ADDR_VAR 0 6
71430: PUSH
71431: LD_VAR 0 7
71435: PUSH
71436: LD_VAR 0 9
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: PUSH
71445: EMPTY
71446: LIST
71447: ST_TO_ADDR
71448: GO 71592
// begin if result [ result ] [ 2 ] < tmp then
71450: LD_VAR 0 6
71454: PUSH
71455: LD_VAR 0 6
71459: ARRAY
71460: PUSH
71461: LD_INT 2
71463: ARRAY
71464: PUSH
71465: LD_VAR 0 9
71469: LESS
71470: IFFALSE 71512
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71472: LD_ADDR_VAR 0 6
71476: PUSH
71477: LD_VAR 0 6
71481: PPUSH
71482: LD_VAR 0 6
71486: PUSH
71487: LD_INT 1
71489: PLUS
71490: PPUSH
71491: LD_VAR 0 7
71495: PUSH
71496: LD_VAR 0 9
71500: PUSH
71501: EMPTY
71502: LIST
71503: LIST
71504: PPUSH
71505: CALL_OW 2
71509: ST_TO_ADDR
71510: GO 71592
// for j = 1 to result do
71512: LD_ADDR_VAR 0 8
71516: PUSH
71517: DOUBLE
71518: LD_INT 1
71520: DEC
71521: ST_TO_ADDR
71522: LD_VAR 0 6
71526: PUSH
71527: FOR_TO
71528: IFFALSE 71590
// begin if tmp < result [ j ] [ 2 ] then
71530: LD_VAR 0 9
71534: PUSH
71535: LD_VAR 0 6
71539: PUSH
71540: LD_VAR 0 8
71544: ARRAY
71545: PUSH
71546: LD_INT 2
71548: ARRAY
71549: LESS
71550: IFFALSE 71588
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71552: LD_ADDR_VAR 0 6
71556: PUSH
71557: LD_VAR 0 6
71561: PPUSH
71562: LD_VAR 0 8
71566: PPUSH
71567: LD_VAR 0 7
71571: PUSH
71572: LD_VAR 0 9
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PPUSH
71581: CALL_OW 2
71585: ST_TO_ADDR
// break ;
71586: GO 71590
// end ; end ;
71588: GO 71527
71590: POP
71591: POP
// end ; end ;
71592: GO 71391
71594: POP
71595: POP
// if result and not asc then
71596: LD_VAR 0 6
71600: PUSH
71601: LD_VAR 0 4
71605: NOT
71606: AND
71607: IFFALSE 71682
// begin tmp := result ;
71609: LD_ADDR_VAR 0 9
71613: PUSH
71614: LD_VAR 0 6
71618: ST_TO_ADDR
// for i = tmp downto 1 do
71619: LD_ADDR_VAR 0 7
71623: PUSH
71624: DOUBLE
71625: LD_VAR 0 9
71629: INC
71630: ST_TO_ADDR
71631: LD_INT 1
71633: PUSH
71634: FOR_DOWNTO
71635: IFFALSE 71680
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71637: LD_ADDR_VAR 0 6
71641: PUSH
71642: LD_VAR 0 6
71646: PPUSH
71647: LD_VAR 0 9
71651: PUSH
71652: LD_VAR 0 7
71656: MINUS
71657: PUSH
71658: LD_INT 1
71660: PLUS
71661: PPUSH
71662: LD_VAR 0 9
71666: PUSH
71667: LD_VAR 0 7
71671: ARRAY
71672: PPUSH
71673: CALL_OW 1
71677: ST_TO_ADDR
71678: GO 71634
71680: POP
71681: POP
// end ; tmp := [ ] ;
71682: LD_ADDR_VAR 0 9
71686: PUSH
71687: EMPTY
71688: ST_TO_ADDR
// if mode then
71689: LD_VAR 0 5
71693: IFFALSE 71762
// begin for i = 1 to result do
71695: LD_ADDR_VAR 0 7
71699: PUSH
71700: DOUBLE
71701: LD_INT 1
71703: DEC
71704: ST_TO_ADDR
71705: LD_VAR 0 6
71709: PUSH
71710: FOR_TO
71711: IFFALSE 71750
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
71713: LD_ADDR_VAR 0 9
71717: PUSH
71718: LD_VAR 0 9
71722: PPUSH
71723: LD_VAR 0 7
71727: PPUSH
71728: LD_VAR 0 6
71732: PUSH
71733: LD_VAR 0 7
71737: ARRAY
71738: PUSH
71739: LD_INT 1
71741: ARRAY
71742: PPUSH
71743: CALL_OW 1
71747: ST_TO_ADDR
71748: GO 71710
71750: POP
71751: POP
// result := tmp ;
71752: LD_ADDR_VAR 0 6
71756: PUSH
71757: LD_VAR 0 9
71761: ST_TO_ADDR
// end ; end ;
71762: LD_VAR 0 6
71766: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
71767: LD_INT 0
71769: PPUSH
71770: PPUSH
71771: PPUSH
71772: PPUSH
71773: PPUSH
71774: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
71775: LD_ADDR_VAR 0 5
71779: PUSH
71780: LD_INT 0
71782: PUSH
71783: LD_INT 0
71785: PUSH
71786: LD_INT 0
71788: PUSH
71789: EMPTY
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: LIST
71795: LIST
71796: ST_TO_ADDR
// if not x or not y then
71797: LD_VAR 0 2
71801: NOT
71802: PUSH
71803: LD_VAR 0 3
71807: NOT
71808: OR
71809: IFFALSE 71813
// exit ;
71811: GO 73465
// if not range then
71813: LD_VAR 0 4
71817: NOT
71818: IFFALSE 71828
// range := 10 ;
71820: LD_ADDR_VAR 0 4
71824: PUSH
71825: LD_INT 10
71827: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
71828: LD_ADDR_VAR 0 8
71832: PUSH
71833: LD_INT 81
71835: PUSH
71836: LD_VAR 0 1
71840: PUSH
71841: EMPTY
71842: LIST
71843: LIST
71844: PUSH
71845: LD_INT 92
71847: PUSH
71848: LD_VAR 0 2
71852: PUSH
71853: LD_VAR 0 3
71857: PUSH
71858: LD_VAR 0 4
71862: PUSH
71863: EMPTY
71864: LIST
71865: LIST
71866: LIST
71867: LIST
71868: PUSH
71869: LD_INT 3
71871: PUSH
71872: LD_INT 21
71874: PUSH
71875: LD_INT 3
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: EMPTY
71883: LIST
71884: LIST
71885: PUSH
71886: EMPTY
71887: LIST
71888: LIST
71889: LIST
71890: PPUSH
71891: CALL_OW 69
71895: ST_TO_ADDR
// if not tmp then
71896: LD_VAR 0 8
71900: NOT
71901: IFFALSE 71905
// exit ;
71903: GO 73465
// for i in tmp do
71905: LD_ADDR_VAR 0 6
71909: PUSH
71910: LD_VAR 0 8
71914: PUSH
71915: FOR_IN
71916: IFFALSE 73440
// begin points := [ 0 , 0 , 0 ] ;
71918: LD_ADDR_VAR 0 9
71922: PUSH
71923: LD_INT 0
71925: PUSH
71926: LD_INT 0
71928: PUSH
71929: LD_INT 0
71931: PUSH
71932: EMPTY
71933: LIST
71934: LIST
71935: LIST
71936: ST_TO_ADDR
// bpoints := 1 ;
71937: LD_ADDR_VAR 0 10
71941: PUSH
71942: LD_INT 1
71944: ST_TO_ADDR
// case GetType ( i ) of unit_human :
71945: LD_VAR 0 6
71949: PPUSH
71950: CALL_OW 247
71954: PUSH
71955: LD_INT 1
71957: DOUBLE
71958: EQUAL
71959: IFTRUE 71963
71961: GO 72541
71963: POP
// begin if GetClass ( i ) = 1 then
71964: LD_VAR 0 6
71968: PPUSH
71969: CALL_OW 257
71973: PUSH
71974: LD_INT 1
71976: EQUAL
71977: IFFALSE 71998
// points := [ 10 , 5 , 3 ] ;
71979: LD_ADDR_VAR 0 9
71983: PUSH
71984: LD_INT 10
71986: PUSH
71987: LD_INT 5
71989: PUSH
71990: LD_INT 3
71992: PUSH
71993: EMPTY
71994: LIST
71995: LIST
71996: LIST
71997: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
71998: LD_VAR 0 6
72002: PPUSH
72003: CALL_OW 257
72007: PUSH
72008: LD_INT 2
72010: PUSH
72011: LD_INT 3
72013: PUSH
72014: LD_INT 4
72016: PUSH
72017: EMPTY
72018: LIST
72019: LIST
72020: LIST
72021: IN
72022: IFFALSE 72043
// points := [ 3 , 2 , 1 ] ;
72024: LD_ADDR_VAR 0 9
72028: PUSH
72029: LD_INT 3
72031: PUSH
72032: LD_INT 2
72034: PUSH
72035: LD_INT 1
72037: PUSH
72038: EMPTY
72039: LIST
72040: LIST
72041: LIST
72042: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72043: LD_VAR 0 6
72047: PPUSH
72048: CALL_OW 257
72052: PUSH
72053: LD_INT 5
72055: EQUAL
72056: IFFALSE 72077
// points := [ 130 , 5 , 2 ] ;
72058: LD_ADDR_VAR 0 9
72062: PUSH
72063: LD_INT 130
72065: PUSH
72066: LD_INT 5
72068: PUSH
72069: LD_INT 2
72071: PUSH
72072: EMPTY
72073: LIST
72074: LIST
72075: LIST
72076: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72077: LD_VAR 0 6
72081: PPUSH
72082: CALL_OW 257
72086: PUSH
72087: LD_INT 8
72089: EQUAL
72090: IFFALSE 72111
// points := [ 35 , 35 , 30 ] ;
72092: LD_ADDR_VAR 0 9
72096: PUSH
72097: LD_INT 35
72099: PUSH
72100: LD_INT 35
72102: PUSH
72103: LD_INT 30
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: LIST
72110: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72111: LD_VAR 0 6
72115: PPUSH
72116: CALL_OW 257
72120: PUSH
72121: LD_INT 9
72123: EQUAL
72124: IFFALSE 72145
// points := [ 20 , 55 , 40 ] ;
72126: LD_ADDR_VAR 0 9
72130: PUSH
72131: LD_INT 20
72133: PUSH
72134: LD_INT 55
72136: PUSH
72137: LD_INT 40
72139: PUSH
72140: EMPTY
72141: LIST
72142: LIST
72143: LIST
72144: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72145: LD_VAR 0 6
72149: PPUSH
72150: CALL_OW 257
72154: PUSH
72155: LD_INT 12
72157: PUSH
72158: LD_INT 16
72160: PUSH
72161: EMPTY
72162: LIST
72163: LIST
72164: IN
72165: IFFALSE 72186
// points := [ 5 , 3 , 2 ] ;
72167: LD_ADDR_VAR 0 9
72171: PUSH
72172: LD_INT 5
72174: PUSH
72175: LD_INT 3
72177: PUSH
72178: LD_INT 2
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: LIST
72185: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72186: LD_VAR 0 6
72190: PPUSH
72191: CALL_OW 257
72195: PUSH
72196: LD_INT 17
72198: EQUAL
72199: IFFALSE 72220
// points := [ 100 , 50 , 75 ] ;
72201: LD_ADDR_VAR 0 9
72205: PUSH
72206: LD_INT 100
72208: PUSH
72209: LD_INT 50
72211: PUSH
72212: LD_INT 75
72214: PUSH
72215: EMPTY
72216: LIST
72217: LIST
72218: LIST
72219: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72220: LD_VAR 0 6
72224: PPUSH
72225: CALL_OW 257
72229: PUSH
72230: LD_INT 15
72232: EQUAL
72233: IFFALSE 72254
// points := [ 10 , 5 , 3 ] ;
72235: LD_ADDR_VAR 0 9
72239: PUSH
72240: LD_INT 10
72242: PUSH
72243: LD_INT 5
72245: PUSH
72246: LD_INT 3
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: LIST
72253: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72254: LD_VAR 0 6
72258: PPUSH
72259: CALL_OW 257
72263: PUSH
72264: LD_INT 14
72266: EQUAL
72267: IFFALSE 72288
// points := [ 10 , 0 , 0 ] ;
72269: LD_ADDR_VAR 0 9
72273: PUSH
72274: LD_INT 10
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: LD_INT 0
72282: PUSH
72283: EMPTY
72284: LIST
72285: LIST
72286: LIST
72287: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72288: LD_VAR 0 6
72292: PPUSH
72293: CALL_OW 257
72297: PUSH
72298: LD_INT 11
72300: EQUAL
72301: IFFALSE 72322
// points := [ 30 , 10 , 5 ] ;
72303: LD_ADDR_VAR 0 9
72307: PUSH
72308: LD_INT 30
72310: PUSH
72311: LD_INT 10
72313: PUSH
72314: LD_INT 5
72316: PUSH
72317: EMPTY
72318: LIST
72319: LIST
72320: LIST
72321: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72322: LD_VAR 0 1
72326: PPUSH
72327: LD_INT 5
72329: PPUSH
72330: CALL_OW 321
72334: PUSH
72335: LD_INT 2
72337: EQUAL
72338: IFFALSE 72355
// bpoints := bpoints * 1.8 ;
72340: LD_ADDR_VAR 0 10
72344: PUSH
72345: LD_VAR 0 10
72349: PUSH
72350: LD_REAL  1.80000000000000E+0000
72353: MUL
72354: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72355: LD_VAR 0 6
72359: PPUSH
72360: CALL_OW 257
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: LD_INT 2
72370: PUSH
72371: LD_INT 3
72373: PUSH
72374: LD_INT 4
72376: PUSH
72377: EMPTY
72378: LIST
72379: LIST
72380: LIST
72381: LIST
72382: IN
72383: PUSH
72384: LD_VAR 0 1
72388: PPUSH
72389: LD_INT 51
72391: PPUSH
72392: CALL_OW 321
72396: PUSH
72397: LD_INT 2
72399: EQUAL
72400: AND
72401: IFFALSE 72418
// bpoints := bpoints * 1.2 ;
72403: LD_ADDR_VAR 0 10
72407: PUSH
72408: LD_VAR 0 10
72412: PUSH
72413: LD_REAL  1.20000000000000E+0000
72416: MUL
72417: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72418: LD_VAR 0 6
72422: PPUSH
72423: CALL_OW 257
72427: PUSH
72428: LD_INT 5
72430: PUSH
72431: LD_INT 7
72433: PUSH
72434: LD_INT 9
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: LIST
72441: IN
72442: PUSH
72443: LD_VAR 0 1
72447: PPUSH
72448: LD_INT 52
72450: PPUSH
72451: CALL_OW 321
72455: PUSH
72456: LD_INT 2
72458: EQUAL
72459: AND
72460: IFFALSE 72477
// bpoints := bpoints * 1.5 ;
72462: LD_ADDR_VAR 0 10
72466: PUSH
72467: LD_VAR 0 10
72471: PUSH
72472: LD_REAL  1.50000000000000E+0000
72475: MUL
72476: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72477: LD_VAR 0 1
72481: PPUSH
72482: LD_INT 66
72484: PPUSH
72485: CALL_OW 321
72489: PUSH
72490: LD_INT 2
72492: EQUAL
72493: IFFALSE 72510
// bpoints := bpoints * 1.1 ;
72495: LD_ADDR_VAR 0 10
72499: PUSH
72500: LD_VAR 0 10
72504: PUSH
72505: LD_REAL  1.10000000000000E+0000
72508: MUL
72509: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72510: LD_ADDR_VAR 0 10
72514: PUSH
72515: LD_VAR 0 10
72519: PUSH
72520: LD_VAR 0 6
72524: PPUSH
72525: LD_INT 1
72527: PPUSH
72528: CALL_OW 259
72532: PUSH
72533: LD_REAL  1.15000000000000E+0000
72536: MUL
72537: MUL
72538: ST_TO_ADDR
// end ; unit_vehicle :
72539: GO 73369
72541: LD_INT 2
72543: DOUBLE
72544: EQUAL
72545: IFTRUE 72549
72547: GO 73357
72549: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72550: LD_VAR 0 6
72554: PPUSH
72555: CALL_OW 264
72559: PUSH
72560: LD_INT 2
72562: PUSH
72563: LD_INT 42
72565: PUSH
72566: LD_INT 24
72568: PUSH
72569: EMPTY
72570: LIST
72571: LIST
72572: LIST
72573: IN
72574: IFFALSE 72595
// points := [ 25 , 5 , 3 ] ;
72576: LD_ADDR_VAR 0 9
72580: PUSH
72581: LD_INT 25
72583: PUSH
72584: LD_INT 5
72586: PUSH
72587: LD_INT 3
72589: PUSH
72590: EMPTY
72591: LIST
72592: LIST
72593: LIST
72594: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72595: LD_VAR 0 6
72599: PPUSH
72600: CALL_OW 264
72604: PUSH
72605: LD_INT 4
72607: PUSH
72608: LD_INT 43
72610: PUSH
72611: LD_INT 25
72613: PUSH
72614: EMPTY
72615: LIST
72616: LIST
72617: LIST
72618: IN
72619: IFFALSE 72640
// points := [ 40 , 15 , 5 ] ;
72621: LD_ADDR_VAR 0 9
72625: PUSH
72626: LD_INT 40
72628: PUSH
72629: LD_INT 15
72631: PUSH
72632: LD_INT 5
72634: PUSH
72635: EMPTY
72636: LIST
72637: LIST
72638: LIST
72639: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72640: LD_VAR 0 6
72644: PPUSH
72645: CALL_OW 264
72649: PUSH
72650: LD_INT 3
72652: PUSH
72653: LD_INT 23
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: IN
72660: IFFALSE 72681
// points := [ 7 , 25 , 8 ] ;
72662: LD_ADDR_VAR 0 9
72666: PUSH
72667: LD_INT 7
72669: PUSH
72670: LD_INT 25
72672: PUSH
72673: LD_INT 8
72675: PUSH
72676: EMPTY
72677: LIST
72678: LIST
72679: LIST
72680: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
72681: LD_VAR 0 6
72685: PPUSH
72686: CALL_OW 264
72690: PUSH
72691: LD_INT 5
72693: PUSH
72694: LD_INT 27
72696: PUSH
72697: LD_INT 44
72699: PUSH
72700: EMPTY
72701: LIST
72702: LIST
72703: LIST
72704: IN
72705: IFFALSE 72726
// points := [ 14 , 50 , 16 ] ;
72707: LD_ADDR_VAR 0 9
72711: PUSH
72712: LD_INT 14
72714: PUSH
72715: LD_INT 50
72717: PUSH
72718: LD_INT 16
72720: PUSH
72721: EMPTY
72722: LIST
72723: LIST
72724: LIST
72725: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
72726: LD_VAR 0 6
72730: PPUSH
72731: CALL_OW 264
72735: PUSH
72736: LD_INT 6
72738: PUSH
72739: LD_INT 46
72741: PUSH
72742: EMPTY
72743: LIST
72744: LIST
72745: IN
72746: IFFALSE 72767
// points := [ 32 , 120 , 70 ] ;
72748: LD_ADDR_VAR 0 9
72752: PUSH
72753: LD_INT 32
72755: PUSH
72756: LD_INT 120
72758: PUSH
72759: LD_INT 70
72761: PUSH
72762: EMPTY
72763: LIST
72764: LIST
72765: LIST
72766: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
72767: LD_VAR 0 6
72771: PPUSH
72772: CALL_OW 264
72776: PUSH
72777: LD_INT 7
72779: PUSH
72780: LD_INT 28
72782: PUSH
72783: LD_INT 45
72785: PUSH
72786: LD_EXP 100
72790: PUSH
72791: EMPTY
72792: LIST
72793: LIST
72794: LIST
72795: LIST
72796: IN
72797: IFFALSE 72818
// points := [ 35 , 20 , 45 ] ;
72799: LD_ADDR_VAR 0 9
72803: PUSH
72804: LD_INT 35
72806: PUSH
72807: LD_INT 20
72809: PUSH
72810: LD_INT 45
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: LIST
72817: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
72818: LD_VAR 0 6
72822: PPUSH
72823: CALL_OW 264
72827: PUSH
72828: LD_INT 47
72830: PUSH
72831: EMPTY
72832: LIST
72833: IN
72834: IFFALSE 72855
// points := [ 67 , 45 , 75 ] ;
72836: LD_ADDR_VAR 0 9
72840: PUSH
72841: LD_INT 67
72843: PUSH
72844: LD_INT 45
72846: PUSH
72847: LD_INT 75
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: LIST
72854: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
72855: LD_VAR 0 6
72859: PPUSH
72860: CALL_OW 264
72864: PUSH
72865: LD_INT 26
72867: PUSH
72868: EMPTY
72869: LIST
72870: IN
72871: IFFALSE 72892
// points := [ 120 , 30 , 80 ] ;
72873: LD_ADDR_VAR 0 9
72877: PUSH
72878: LD_INT 120
72880: PUSH
72881: LD_INT 30
72883: PUSH
72884: LD_INT 80
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: LIST
72891: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
72892: LD_VAR 0 6
72896: PPUSH
72897: CALL_OW 264
72901: PUSH
72902: LD_INT 22
72904: PUSH
72905: EMPTY
72906: LIST
72907: IN
72908: IFFALSE 72929
// points := [ 40 , 1 , 1 ] ;
72910: LD_ADDR_VAR 0 9
72914: PUSH
72915: LD_INT 40
72917: PUSH
72918: LD_INT 1
72920: PUSH
72921: LD_INT 1
72923: PUSH
72924: EMPTY
72925: LIST
72926: LIST
72927: LIST
72928: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
72929: LD_VAR 0 6
72933: PPUSH
72934: CALL_OW 264
72938: PUSH
72939: LD_INT 29
72941: PUSH
72942: EMPTY
72943: LIST
72944: IN
72945: IFFALSE 72966
// points := [ 70 , 200 , 400 ] ;
72947: LD_ADDR_VAR 0 9
72951: PUSH
72952: LD_INT 70
72954: PUSH
72955: LD_INT 200
72957: PUSH
72958: LD_INT 400
72960: PUSH
72961: EMPTY
72962: LIST
72963: LIST
72964: LIST
72965: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
72966: LD_VAR 0 6
72970: PPUSH
72971: CALL_OW 264
72975: PUSH
72976: LD_INT 14
72978: PUSH
72979: LD_INT 53
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: IN
72986: IFFALSE 73007
// points := [ 40 , 10 , 20 ] ;
72988: LD_ADDR_VAR 0 9
72992: PUSH
72993: LD_INT 40
72995: PUSH
72996: LD_INT 10
72998: PUSH
72999: LD_INT 20
73001: PUSH
73002: EMPTY
73003: LIST
73004: LIST
73005: LIST
73006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73007: LD_VAR 0 6
73011: PPUSH
73012: CALL_OW 264
73016: PUSH
73017: LD_INT 9
73019: PUSH
73020: EMPTY
73021: LIST
73022: IN
73023: IFFALSE 73044
// points := [ 5 , 70 , 20 ] ;
73025: LD_ADDR_VAR 0 9
73029: PUSH
73030: LD_INT 5
73032: PUSH
73033: LD_INT 70
73035: PUSH
73036: LD_INT 20
73038: PUSH
73039: EMPTY
73040: LIST
73041: LIST
73042: LIST
73043: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73044: LD_VAR 0 6
73048: PPUSH
73049: CALL_OW 264
73053: PUSH
73054: LD_INT 10
73056: PUSH
73057: EMPTY
73058: LIST
73059: IN
73060: IFFALSE 73081
// points := [ 35 , 110 , 70 ] ;
73062: LD_ADDR_VAR 0 9
73066: PUSH
73067: LD_INT 35
73069: PUSH
73070: LD_INT 110
73072: PUSH
73073: LD_INT 70
73075: PUSH
73076: EMPTY
73077: LIST
73078: LIST
73079: LIST
73080: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73081: LD_VAR 0 6
73085: PPUSH
73086: CALL_OW 265
73090: PUSH
73091: LD_INT 25
73093: EQUAL
73094: IFFALSE 73115
// points := [ 80 , 65 , 100 ] ;
73096: LD_ADDR_VAR 0 9
73100: PUSH
73101: LD_INT 80
73103: PUSH
73104: LD_INT 65
73106: PUSH
73107: LD_INT 100
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: LIST
73114: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73115: LD_VAR 0 6
73119: PPUSH
73120: CALL_OW 263
73124: PUSH
73125: LD_INT 1
73127: EQUAL
73128: IFFALSE 73163
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73130: LD_ADDR_VAR 0 10
73134: PUSH
73135: LD_VAR 0 10
73139: PUSH
73140: LD_VAR 0 6
73144: PPUSH
73145: CALL_OW 311
73149: PPUSH
73150: LD_INT 3
73152: PPUSH
73153: CALL_OW 259
73157: PUSH
73158: LD_INT 4
73160: MUL
73161: MUL
73162: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73163: LD_VAR 0 6
73167: PPUSH
73168: CALL_OW 263
73172: PUSH
73173: LD_INT 2
73175: EQUAL
73176: IFFALSE 73227
// begin j := IsControledBy ( i ) ;
73178: LD_ADDR_VAR 0 7
73182: PUSH
73183: LD_VAR 0 6
73187: PPUSH
73188: CALL_OW 312
73192: ST_TO_ADDR
// if j then
73193: LD_VAR 0 7
73197: IFFALSE 73227
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73199: LD_ADDR_VAR 0 10
73203: PUSH
73204: LD_VAR 0 10
73208: PUSH
73209: LD_VAR 0 7
73213: PPUSH
73214: LD_INT 3
73216: PPUSH
73217: CALL_OW 259
73221: PUSH
73222: LD_INT 3
73224: MUL
73225: MUL
73226: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73227: LD_VAR 0 6
73231: PPUSH
73232: CALL_OW 264
73236: PUSH
73237: LD_INT 5
73239: PUSH
73240: LD_INT 6
73242: PUSH
73243: LD_INT 46
73245: PUSH
73246: LD_INT 44
73248: PUSH
73249: LD_INT 47
73251: PUSH
73252: LD_INT 45
73254: PUSH
73255: LD_INT 28
73257: PUSH
73258: LD_INT 7
73260: PUSH
73261: LD_INT 27
73263: PUSH
73264: LD_INT 29
73266: PUSH
73267: EMPTY
73268: LIST
73269: LIST
73270: LIST
73271: LIST
73272: LIST
73273: LIST
73274: LIST
73275: LIST
73276: LIST
73277: LIST
73278: IN
73279: PUSH
73280: LD_VAR 0 1
73284: PPUSH
73285: LD_INT 52
73287: PPUSH
73288: CALL_OW 321
73292: PUSH
73293: LD_INT 2
73295: EQUAL
73296: AND
73297: IFFALSE 73314
// bpoints := bpoints * 1.2 ;
73299: LD_ADDR_VAR 0 10
73303: PUSH
73304: LD_VAR 0 10
73308: PUSH
73309: LD_REAL  1.20000000000000E+0000
73312: MUL
73313: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73314: LD_VAR 0 6
73318: PPUSH
73319: CALL_OW 264
73323: PUSH
73324: LD_INT 6
73326: PUSH
73327: LD_INT 46
73329: PUSH
73330: LD_INT 47
73332: PUSH
73333: EMPTY
73334: LIST
73335: LIST
73336: LIST
73337: IN
73338: IFFALSE 73355
// bpoints := bpoints * 1.2 ;
73340: LD_ADDR_VAR 0 10
73344: PUSH
73345: LD_VAR 0 10
73349: PUSH
73350: LD_REAL  1.20000000000000E+0000
73353: MUL
73354: ST_TO_ADDR
// end ; unit_building :
73355: GO 73369
73357: LD_INT 3
73359: DOUBLE
73360: EQUAL
73361: IFTRUE 73365
73363: GO 73368
73365: POP
// ; end ;
73366: GO 73369
73368: POP
// for j = 1 to 3 do
73369: LD_ADDR_VAR 0 7
73373: PUSH
73374: DOUBLE
73375: LD_INT 1
73377: DEC
73378: ST_TO_ADDR
73379: LD_INT 3
73381: PUSH
73382: FOR_TO
73383: IFFALSE 73436
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73385: LD_ADDR_VAR 0 5
73389: PUSH
73390: LD_VAR 0 5
73394: PPUSH
73395: LD_VAR 0 7
73399: PPUSH
73400: LD_VAR 0 5
73404: PUSH
73405: LD_VAR 0 7
73409: ARRAY
73410: PUSH
73411: LD_VAR 0 9
73415: PUSH
73416: LD_VAR 0 7
73420: ARRAY
73421: PUSH
73422: LD_VAR 0 10
73426: MUL
73427: PLUS
73428: PPUSH
73429: CALL_OW 1
73433: ST_TO_ADDR
73434: GO 73382
73436: POP
73437: POP
// end ;
73438: GO 71915
73440: POP
73441: POP
// result := Replace ( result , 4 , tmp ) ;
73442: LD_ADDR_VAR 0 5
73446: PUSH
73447: LD_VAR 0 5
73451: PPUSH
73452: LD_INT 4
73454: PPUSH
73455: LD_VAR 0 8
73459: PPUSH
73460: CALL_OW 1
73464: ST_TO_ADDR
// end ;
73465: LD_VAR 0 5
73469: RET
// export function DangerAtRange ( unit , range ) ; begin
73470: LD_INT 0
73472: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73473: LD_ADDR_VAR 0 3
73477: PUSH
73478: LD_VAR 0 1
73482: PPUSH
73483: CALL_OW 255
73487: PPUSH
73488: LD_VAR 0 1
73492: PPUSH
73493: CALL_OW 250
73497: PPUSH
73498: LD_VAR 0 1
73502: PPUSH
73503: CALL_OW 251
73507: PPUSH
73508: LD_VAR 0 2
73512: PPUSH
73513: CALL 71767 0 4
73517: ST_TO_ADDR
// end ;
73518: LD_VAR 0 3
73522: RET
// export function DangerInArea ( side , area ) ; begin
73523: LD_INT 0
73525: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73526: LD_ADDR_VAR 0 3
73530: PUSH
73531: LD_VAR 0 2
73535: PPUSH
73536: LD_INT 81
73538: PUSH
73539: LD_VAR 0 1
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PPUSH
73548: CALL_OW 70
73552: ST_TO_ADDR
// end ;
73553: LD_VAR 0 3
73557: RET
// export function IsExtension ( b ) ; begin
73558: LD_INT 0
73560: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73561: LD_ADDR_VAR 0 2
73565: PUSH
73566: LD_VAR 0 1
73570: PUSH
73571: LD_INT 23
73573: PUSH
73574: LD_INT 20
73576: PUSH
73577: LD_INT 22
73579: PUSH
73580: LD_INT 17
73582: PUSH
73583: LD_INT 24
73585: PUSH
73586: LD_INT 21
73588: PUSH
73589: LD_INT 19
73591: PUSH
73592: LD_INT 16
73594: PUSH
73595: LD_INT 25
73597: PUSH
73598: LD_INT 18
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: IN
73613: ST_TO_ADDR
// end ;
73614: LD_VAR 0 2
73618: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
73619: LD_INT 0
73621: PPUSH
73622: PPUSH
73623: PPUSH
// result := [ ] ;
73624: LD_ADDR_VAR 0 4
73628: PUSH
73629: EMPTY
73630: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73631: LD_ADDR_VAR 0 5
73635: PUSH
73636: LD_VAR 0 2
73640: PPUSH
73641: LD_INT 21
73643: PUSH
73644: LD_INT 3
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PPUSH
73651: CALL_OW 70
73655: ST_TO_ADDR
// if not tmp then
73656: LD_VAR 0 5
73660: NOT
73661: IFFALSE 73665
// exit ;
73663: GO 73729
// if checkLink then
73665: LD_VAR 0 3
73669: IFFALSE 73719
// begin for i in tmp do
73671: LD_ADDR_VAR 0 6
73675: PUSH
73676: LD_VAR 0 5
73680: PUSH
73681: FOR_IN
73682: IFFALSE 73717
// if GetBase ( i ) <> base then
73684: LD_VAR 0 6
73688: PPUSH
73689: CALL_OW 274
73693: PUSH
73694: LD_VAR 0 1
73698: NONEQUAL
73699: IFFALSE 73715
// ComLinkToBase ( base , i ) ;
73701: LD_VAR 0 1
73705: PPUSH
73706: LD_VAR 0 6
73710: PPUSH
73711: CALL_OW 169
73715: GO 73681
73717: POP
73718: POP
// end ; result := tmp ;
73719: LD_ADDR_VAR 0 4
73723: PUSH
73724: LD_VAR 0 5
73728: ST_TO_ADDR
// end ;
73729: LD_VAR 0 4
73733: RET
// export function ComComplete ( units , b ) ; var i ; begin
73734: LD_INT 0
73736: PPUSH
73737: PPUSH
// if not units then
73738: LD_VAR 0 1
73742: NOT
73743: IFFALSE 73747
// exit ;
73745: GO 73837
// for i in units do
73747: LD_ADDR_VAR 0 4
73751: PUSH
73752: LD_VAR 0 1
73756: PUSH
73757: FOR_IN
73758: IFFALSE 73835
// if BuildingStatus ( b ) = bs_build then
73760: LD_VAR 0 2
73764: PPUSH
73765: CALL_OW 461
73769: PUSH
73770: LD_INT 1
73772: EQUAL
73773: IFFALSE 73833
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
73775: LD_VAR 0 4
73779: PPUSH
73780: LD_STRING h
73782: PUSH
73783: LD_VAR 0 2
73787: PPUSH
73788: CALL_OW 250
73792: PUSH
73793: LD_VAR 0 2
73797: PPUSH
73798: CALL_OW 251
73802: PUSH
73803: LD_VAR 0 2
73807: PUSH
73808: LD_INT 0
73810: PUSH
73811: LD_INT 0
73813: PUSH
73814: LD_INT 0
73816: PUSH
73817: EMPTY
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: PUSH
73826: EMPTY
73827: LIST
73828: PPUSH
73829: CALL_OW 446
73833: GO 73757
73835: POP
73836: POP
// end ;
73837: LD_VAR 0 3
73841: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
73842: LD_INT 0
73844: PPUSH
73845: PPUSH
73846: PPUSH
73847: PPUSH
73848: PPUSH
73849: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
73850: LD_VAR 0 1
73854: NOT
73855: PUSH
73856: LD_VAR 0 1
73860: PPUSH
73861: CALL_OW 263
73865: PUSH
73866: LD_INT 2
73868: NONEQUAL
73869: OR
73870: IFFALSE 73874
// exit ;
73872: GO 74190
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
73874: LD_ADDR_VAR 0 6
73878: PUSH
73879: LD_INT 22
73881: PUSH
73882: LD_VAR 0 1
73886: PPUSH
73887: CALL_OW 255
73891: PUSH
73892: EMPTY
73893: LIST
73894: LIST
73895: PUSH
73896: LD_INT 2
73898: PUSH
73899: LD_INT 30
73901: PUSH
73902: LD_INT 36
73904: PUSH
73905: EMPTY
73906: LIST
73907: LIST
73908: PUSH
73909: LD_INT 34
73911: PUSH
73912: LD_INT 31
73914: PUSH
73915: EMPTY
73916: LIST
73917: LIST
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: LIST
73923: PUSH
73924: EMPTY
73925: LIST
73926: LIST
73927: PPUSH
73928: CALL_OW 69
73932: ST_TO_ADDR
// if not tmp then
73933: LD_VAR 0 6
73937: NOT
73938: IFFALSE 73942
// exit ;
73940: GO 74190
// result := [ ] ;
73942: LD_ADDR_VAR 0 2
73946: PUSH
73947: EMPTY
73948: ST_TO_ADDR
// for i in tmp do
73949: LD_ADDR_VAR 0 3
73953: PUSH
73954: LD_VAR 0 6
73958: PUSH
73959: FOR_IN
73960: IFFALSE 74031
// begin t := UnitsInside ( i ) ;
73962: LD_ADDR_VAR 0 4
73966: PUSH
73967: LD_VAR 0 3
73971: PPUSH
73972: CALL_OW 313
73976: ST_TO_ADDR
// if t then
73977: LD_VAR 0 4
73981: IFFALSE 74029
// for j in t do
73983: LD_ADDR_VAR 0 7
73987: PUSH
73988: LD_VAR 0 4
73992: PUSH
73993: FOR_IN
73994: IFFALSE 74027
// result := Replace ( result , result + 1 , j ) ;
73996: LD_ADDR_VAR 0 2
74000: PUSH
74001: LD_VAR 0 2
74005: PPUSH
74006: LD_VAR 0 2
74010: PUSH
74011: LD_INT 1
74013: PLUS
74014: PPUSH
74015: LD_VAR 0 7
74019: PPUSH
74020: CALL_OW 1
74024: ST_TO_ADDR
74025: GO 73993
74027: POP
74028: POP
// end ;
74029: GO 73959
74031: POP
74032: POP
// if not result then
74033: LD_VAR 0 2
74037: NOT
74038: IFFALSE 74042
// exit ;
74040: GO 74190
// mech := result [ 1 ] ;
74042: LD_ADDR_VAR 0 5
74046: PUSH
74047: LD_VAR 0 2
74051: PUSH
74052: LD_INT 1
74054: ARRAY
74055: ST_TO_ADDR
// if result > 1 then
74056: LD_VAR 0 2
74060: PUSH
74061: LD_INT 1
74063: GREATER
74064: IFFALSE 74176
// begin for i = 2 to result do
74066: LD_ADDR_VAR 0 3
74070: PUSH
74071: DOUBLE
74072: LD_INT 2
74074: DEC
74075: ST_TO_ADDR
74076: LD_VAR 0 2
74080: PUSH
74081: FOR_TO
74082: IFFALSE 74174
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74084: LD_ADDR_VAR 0 4
74088: PUSH
74089: LD_VAR 0 2
74093: PUSH
74094: LD_VAR 0 3
74098: ARRAY
74099: PPUSH
74100: LD_INT 3
74102: PPUSH
74103: CALL_OW 259
74107: PUSH
74108: LD_VAR 0 2
74112: PUSH
74113: LD_VAR 0 3
74117: ARRAY
74118: PPUSH
74119: CALL_OW 432
74123: MINUS
74124: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74125: LD_VAR 0 4
74129: PUSH
74130: LD_VAR 0 5
74134: PPUSH
74135: LD_INT 3
74137: PPUSH
74138: CALL_OW 259
74142: PUSH
74143: LD_VAR 0 5
74147: PPUSH
74148: CALL_OW 432
74152: MINUS
74153: GREATEREQUAL
74154: IFFALSE 74172
// mech := result [ i ] ;
74156: LD_ADDR_VAR 0 5
74160: PUSH
74161: LD_VAR 0 2
74165: PUSH
74166: LD_VAR 0 3
74170: ARRAY
74171: ST_TO_ADDR
// end ;
74172: GO 74081
74174: POP
74175: POP
// end ; ComLinkTo ( vehicle , mech ) ;
74176: LD_VAR 0 1
74180: PPUSH
74181: LD_VAR 0 5
74185: PPUSH
74186: CALL_OW 135
// end ;
74190: LD_VAR 0 2
74194: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74195: LD_INT 0
74197: PPUSH
74198: PPUSH
74199: PPUSH
74200: PPUSH
74201: PPUSH
74202: PPUSH
74203: PPUSH
74204: PPUSH
74205: PPUSH
74206: PPUSH
74207: PPUSH
74208: PPUSH
74209: PPUSH
// result := [ ] ;
74210: LD_ADDR_VAR 0 7
74214: PUSH
74215: EMPTY
74216: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74217: LD_VAR 0 1
74221: PPUSH
74222: CALL_OW 266
74226: PUSH
74227: LD_INT 0
74229: PUSH
74230: LD_INT 1
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: IN
74237: NOT
74238: IFFALSE 74242
// exit ;
74240: GO 75876
// if name then
74242: LD_VAR 0 3
74246: IFFALSE 74262
// SetBName ( base_dep , name ) ;
74248: LD_VAR 0 1
74252: PPUSH
74253: LD_VAR 0 3
74257: PPUSH
74258: CALL_OW 500
// base := GetBase ( base_dep ) ;
74262: LD_ADDR_VAR 0 15
74266: PUSH
74267: LD_VAR 0 1
74271: PPUSH
74272: CALL_OW 274
74276: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74277: LD_ADDR_VAR 0 16
74281: PUSH
74282: LD_VAR 0 1
74286: PPUSH
74287: CALL_OW 255
74291: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74292: LD_ADDR_VAR 0 17
74296: PUSH
74297: LD_VAR 0 1
74301: PPUSH
74302: CALL_OW 248
74306: ST_TO_ADDR
// if sources then
74307: LD_VAR 0 5
74311: IFFALSE 74358
// for i = 1 to 3 do
74313: LD_ADDR_VAR 0 8
74317: PUSH
74318: DOUBLE
74319: LD_INT 1
74321: DEC
74322: ST_TO_ADDR
74323: LD_INT 3
74325: PUSH
74326: FOR_TO
74327: IFFALSE 74356
// AddResourceType ( base , i , sources [ i ] ) ;
74329: LD_VAR 0 15
74333: PPUSH
74334: LD_VAR 0 8
74338: PPUSH
74339: LD_VAR 0 5
74343: PUSH
74344: LD_VAR 0 8
74348: ARRAY
74349: PPUSH
74350: CALL_OW 276
74354: GO 74326
74356: POP
74357: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
74358: LD_ADDR_VAR 0 18
74362: PUSH
74363: LD_VAR 0 15
74367: PPUSH
74368: LD_VAR 0 2
74372: PPUSH
74373: LD_INT 1
74375: PPUSH
74376: CALL 73619 0 3
74380: ST_TO_ADDR
// InitHc ;
74381: CALL_OW 19
// InitUc ;
74385: CALL_OW 18
// uc_side := side ;
74389: LD_ADDR_OWVAR 20
74393: PUSH
74394: LD_VAR 0 16
74398: ST_TO_ADDR
// uc_nation := nation ;
74399: LD_ADDR_OWVAR 21
74403: PUSH
74404: LD_VAR 0 17
74408: ST_TO_ADDR
// if buildings then
74409: LD_VAR 0 18
74413: IFFALSE 75735
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74415: LD_ADDR_VAR 0 19
74419: PUSH
74420: LD_VAR 0 18
74424: PPUSH
74425: LD_INT 2
74427: PUSH
74428: LD_INT 30
74430: PUSH
74431: LD_INT 29
74433: PUSH
74434: EMPTY
74435: LIST
74436: LIST
74437: PUSH
74438: LD_INT 30
74440: PUSH
74441: LD_INT 30
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: PUSH
74448: EMPTY
74449: LIST
74450: LIST
74451: LIST
74452: PPUSH
74453: CALL_OW 72
74457: ST_TO_ADDR
// if tmp then
74458: LD_VAR 0 19
74462: IFFALSE 74510
// for i in tmp do
74464: LD_ADDR_VAR 0 8
74468: PUSH
74469: LD_VAR 0 19
74473: PUSH
74474: FOR_IN
74475: IFFALSE 74508
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74477: LD_VAR 0 8
74481: PPUSH
74482: CALL_OW 250
74486: PPUSH
74487: LD_VAR 0 8
74491: PPUSH
74492: CALL_OW 251
74496: PPUSH
74497: LD_VAR 0 16
74501: PPUSH
74502: CALL_OW 441
74506: GO 74474
74508: POP
74509: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74510: LD_VAR 0 18
74514: PPUSH
74515: LD_INT 2
74517: PUSH
74518: LD_INT 30
74520: PUSH
74521: LD_INT 32
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PUSH
74528: LD_INT 30
74530: PUSH
74531: LD_INT 33
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: LIST
74542: PPUSH
74543: CALL_OW 72
74547: IFFALSE 74635
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74549: LD_ADDR_VAR 0 8
74553: PUSH
74554: LD_VAR 0 18
74558: PPUSH
74559: LD_INT 2
74561: PUSH
74562: LD_INT 30
74564: PUSH
74565: LD_INT 32
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PUSH
74572: LD_INT 30
74574: PUSH
74575: LD_INT 33
74577: PUSH
74578: EMPTY
74579: LIST
74580: LIST
74581: PUSH
74582: EMPTY
74583: LIST
74584: LIST
74585: LIST
74586: PPUSH
74587: CALL_OW 72
74591: PUSH
74592: FOR_IN
74593: IFFALSE 74633
// begin if not GetBWeapon ( i ) then
74595: LD_VAR 0 8
74599: PPUSH
74600: CALL_OW 269
74604: NOT
74605: IFFALSE 74631
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74607: LD_VAR 0 8
74611: PPUSH
74612: LD_VAR 0 8
74616: PPUSH
74617: LD_VAR 0 2
74621: PPUSH
74622: CALL 75881 0 2
74626: PPUSH
74627: CALL_OW 431
// end ;
74631: GO 74592
74633: POP
74634: POP
// end ; for i = 1 to personel do
74635: LD_ADDR_VAR 0 8
74639: PUSH
74640: DOUBLE
74641: LD_INT 1
74643: DEC
74644: ST_TO_ADDR
74645: LD_VAR 0 6
74649: PUSH
74650: FOR_TO
74651: IFFALSE 75715
// begin if i > 4 then
74653: LD_VAR 0 8
74657: PUSH
74658: LD_INT 4
74660: GREATER
74661: IFFALSE 74665
// break ;
74663: GO 75715
// case i of 1 :
74665: LD_VAR 0 8
74669: PUSH
74670: LD_INT 1
74672: DOUBLE
74673: EQUAL
74674: IFTRUE 74678
74676: GO 74758
74678: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74679: LD_ADDR_VAR 0 12
74683: PUSH
74684: LD_VAR 0 18
74688: PPUSH
74689: LD_INT 22
74691: PUSH
74692: LD_VAR 0 16
74696: PUSH
74697: EMPTY
74698: LIST
74699: LIST
74700: PUSH
74701: LD_INT 58
74703: PUSH
74704: EMPTY
74705: LIST
74706: PUSH
74707: LD_INT 2
74709: PUSH
74710: LD_INT 30
74712: PUSH
74713: LD_INT 32
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 30
74722: PUSH
74723: LD_INT 4
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 30
74732: PUSH
74733: LD_INT 5
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: PUSH
74740: EMPTY
74741: LIST
74742: LIST
74743: LIST
74744: LIST
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: LIST
74750: PPUSH
74751: CALL_OW 72
74755: ST_TO_ADDR
74756: GO 74980
74758: LD_INT 2
74760: DOUBLE
74761: EQUAL
74762: IFTRUE 74766
74764: GO 74828
74766: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
74767: LD_ADDR_VAR 0 12
74771: PUSH
74772: LD_VAR 0 18
74776: PPUSH
74777: LD_INT 22
74779: PUSH
74780: LD_VAR 0 16
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: PUSH
74789: LD_INT 2
74791: PUSH
74792: LD_INT 30
74794: PUSH
74795: LD_INT 0
74797: PUSH
74798: EMPTY
74799: LIST
74800: LIST
74801: PUSH
74802: LD_INT 30
74804: PUSH
74805: LD_INT 1
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: PUSH
74812: EMPTY
74813: LIST
74814: LIST
74815: LIST
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PPUSH
74821: CALL_OW 72
74825: ST_TO_ADDR
74826: GO 74980
74828: LD_INT 3
74830: DOUBLE
74831: EQUAL
74832: IFTRUE 74836
74834: GO 74898
74836: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
74837: LD_ADDR_VAR 0 12
74841: PUSH
74842: LD_VAR 0 18
74846: PPUSH
74847: LD_INT 22
74849: PUSH
74850: LD_VAR 0 16
74854: PUSH
74855: EMPTY
74856: LIST
74857: LIST
74858: PUSH
74859: LD_INT 2
74861: PUSH
74862: LD_INT 30
74864: PUSH
74865: LD_INT 2
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 30
74874: PUSH
74875: LD_INT 3
74877: PUSH
74878: EMPTY
74879: LIST
74880: LIST
74881: PUSH
74882: EMPTY
74883: LIST
74884: LIST
74885: LIST
74886: PUSH
74887: EMPTY
74888: LIST
74889: LIST
74890: PPUSH
74891: CALL_OW 72
74895: ST_TO_ADDR
74896: GO 74980
74898: LD_INT 4
74900: DOUBLE
74901: EQUAL
74902: IFTRUE 74906
74904: GO 74979
74906: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
74907: LD_ADDR_VAR 0 12
74911: PUSH
74912: LD_VAR 0 18
74916: PPUSH
74917: LD_INT 22
74919: PUSH
74920: LD_VAR 0 16
74924: PUSH
74925: EMPTY
74926: LIST
74927: LIST
74928: PUSH
74929: LD_INT 2
74931: PUSH
74932: LD_INT 30
74934: PUSH
74935: LD_INT 6
74937: PUSH
74938: EMPTY
74939: LIST
74940: LIST
74941: PUSH
74942: LD_INT 30
74944: PUSH
74945: LD_INT 7
74947: PUSH
74948: EMPTY
74949: LIST
74950: LIST
74951: PUSH
74952: LD_INT 30
74954: PUSH
74955: LD_INT 8
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: PUSH
74968: EMPTY
74969: LIST
74970: LIST
74971: PPUSH
74972: CALL_OW 72
74976: ST_TO_ADDR
74977: GO 74980
74979: POP
// if i = 1 then
74980: LD_VAR 0 8
74984: PUSH
74985: LD_INT 1
74987: EQUAL
74988: IFFALSE 75099
// begin tmp := [ ] ;
74990: LD_ADDR_VAR 0 19
74994: PUSH
74995: EMPTY
74996: ST_TO_ADDR
// for j in f do
74997: LD_ADDR_VAR 0 9
75001: PUSH
75002: LD_VAR 0 12
75006: PUSH
75007: FOR_IN
75008: IFFALSE 75081
// if GetBType ( j ) = b_bunker then
75010: LD_VAR 0 9
75014: PPUSH
75015: CALL_OW 266
75019: PUSH
75020: LD_INT 32
75022: EQUAL
75023: IFFALSE 75050
// tmp := Insert ( tmp , 1 , j ) else
75025: LD_ADDR_VAR 0 19
75029: PUSH
75030: LD_VAR 0 19
75034: PPUSH
75035: LD_INT 1
75037: PPUSH
75038: LD_VAR 0 9
75042: PPUSH
75043: CALL_OW 2
75047: ST_TO_ADDR
75048: GO 75079
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75050: LD_ADDR_VAR 0 19
75054: PUSH
75055: LD_VAR 0 19
75059: PPUSH
75060: LD_VAR 0 19
75064: PUSH
75065: LD_INT 1
75067: PLUS
75068: PPUSH
75069: LD_VAR 0 9
75073: PPUSH
75074: CALL_OW 2
75078: ST_TO_ADDR
75079: GO 75007
75081: POP
75082: POP
// if tmp then
75083: LD_VAR 0 19
75087: IFFALSE 75099
// f := tmp ;
75089: LD_ADDR_VAR 0 12
75093: PUSH
75094: LD_VAR 0 19
75098: ST_TO_ADDR
// end ; x := personel [ i ] ;
75099: LD_ADDR_VAR 0 13
75103: PUSH
75104: LD_VAR 0 6
75108: PUSH
75109: LD_VAR 0 8
75113: ARRAY
75114: ST_TO_ADDR
// if x = - 1 then
75115: LD_VAR 0 13
75119: PUSH
75120: LD_INT 1
75122: NEG
75123: EQUAL
75124: IFFALSE 75333
// begin for j in f do
75126: LD_ADDR_VAR 0 9
75130: PUSH
75131: LD_VAR 0 12
75135: PUSH
75136: FOR_IN
75137: IFFALSE 75329
// repeat InitHc ;
75139: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75143: LD_VAR 0 9
75147: PPUSH
75148: CALL_OW 266
75152: PUSH
75153: LD_INT 5
75155: EQUAL
75156: IFFALSE 75226
// begin if UnitsInside ( j ) < 3 then
75158: LD_VAR 0 9
75162: PPUSH
75163: CALL_OW 313
75167: PUSH
75168: LD_INT 3
75170: LESS
75171: IFFALSE 75207
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75173: LD_INT 0
75175: PPUSH
75176: LD_INT 5
75178: PUSH
75179: LD_INT 8
75181: PUSH
75182: LD_INT 9
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: LIST
75189: PUSH
75190: LD_VAR 0 17
75194: ARRAY
75195: PPUSH
75196: LD_VAR 0 4
75200: PPUSH
75201: CALL_OW 380
75205: GO 75224
// PrepareHuman ( false , i , skill ) ;
75207: LD_INT 0
75209: PPUSH
75210: LD_VAR 0 8
75214: PPUSH
75215: LD_VAR 0 4
75219: PPUSH
75220: CALL_OW 380
// end else
75224: GO 75243
// PrepareHuman ( false , i , skill ) ;
75226: LD_INT 0
75228: PPUSH
75229: LD_VAR 0 8
75233: PPUSH
75234: LD_VAR 0 4
75238: PPUSH
75239: CALL_OW 380
// un := CreateHuman ;
75243: LD_ADDR_VAR 0 14
75247: PUSH
75248: CALL_OW 44
75252: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75253: LD_ADDR_VAR 0 7
75257: PUSH
75258: LD_VAR 0 7
75262: PPUSH
75263: LD_INT 1
75265: PPUSH
75266: LD_VAR 0 14
75270: PPUSH
75271: CALL_OW 2
75275: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75276: LD_VAR 0 14
75280: PPUSH
75281: LD_VAR 0 9
75285: PPUSH
75286: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75290: LD_VAR 0 9
75294: PPUSH
75295: CALL_OW 313
75299: PUSH
75300: LD_INT 6
75302: EQUAL
75303: PUSH
75304: LD_VAR 0 9
75308: PPUSH
75309: CALL_OW 266
75313: PUSH
75314: LD_INT 32
75316: PUSH
75317: LD_INT 31
75319: PUSH
75320: EMPTY
75321: LIST
75322: LIST
75323: IN
75324: OR
75325: IFFALSE 75139
75327: GO 75136
75329: POP
75330: POP
// end else
75331: GO 75713
// for j = 1 to x do
75333: LD_ADDR_VAR 0 9
75337: PUSH
75338: DOUBLE
75339: LD_INT 1
75341: DEC
75342: ST_TO_ADDR
75343: LD_VAR 0 13
75347: PUSH
75348: FOR_TO
75349: IFFALSE 75711
// begin InitHc ;
75351: CALL_OW 19
// if not f then
75355: LD_VAR 0 12
75359: NOT
75360: IFFALSE 75449
// begin PrepareHuman ( false , i , skill ) ;
75362: LD_INT 0
75364: PPUSH
75365: LD_VAR 0 8
75369: PPUSH
75370: LD_VAR 0 4
75374: PPUSH
75375: CALL_OW 380
// un := CreateHuman ;
75379: LD_ADDR_VAR 0 14
75383: PUSH
75384: CALL_OW 44
75388: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75389: LD_ADDR_VAR 0 7
75393: PUSH
75394: LD_VAR 0 7
75398: PPUSH
75399: LD_INT 1
75401: PPUSH
75402: LD_VAR 0 14
75406: PPUSH
75407: CALL_OW 2
75411: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75412: LD_VAR 0 14
75416: PPUSH
75417: LD_VAR 0 1
75421: PPUSH
75422: CALL_OW 250
75426: PPUSH
75427: LD_VAR 0 1
75431: PPUSH
75432: CALL_OW 251
75436: PPUSH
75437: LD_INT 10
75439: PPUSH
75440: LD_INT 0
75442: PPUSH
75443: CALL_OW 50
// continue ;
75447: GO 75348
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75449: LD_VAR 0 12
75453: PUSH
75454: LD_INT 1
75456: ARRAY
75457: PPUSH
75458: CALL_OW 313
75462: PUSH
75463: LD_VAR 0 12
75467: PUSH
75468: LD_INT 1
75470: ARRAY
75471: PPUSH
75472: CALL_OW 266
75476: PUSH
75477: LD_INT 32
75479: PUSH
75480: LD_INT 31
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: IN
75487: AND
75488: PUSH
75489: LD_VAR 0 12
75493: PUSH
75494: LD_INT 1
75496: ARRAY
75497: PPUSH
75498: CALL_OW 313
75502: PUSH
75503: LD_INT 6
75505: EQUAL
75506: OR
75507: IFFALSE 75527
// f := Delete ( f , 1 ) ;
75509: LD_ADDR_VAR 0 12
75513: PUSH
75514: LD_VAR 0 12
75518: PPUSH
75519: LD_INT 1
75521: PPUSH
75522: CALL_OW 3
75526: ST_TO_ADDR
// if not f then
75527: LD_VAR 0 12
75531: NOT
75532: IFFALSE 75550
// begin x := x + 2 ;
75534: LD_ADDR_VAR 0 13
75538: PUSH
75539: LD_VAR 0 13
75543: PUSH
75544: LD_INT 2
75546: PLUS
75547: ST_TO_ADDR
// continue ;
75548: GO 75348
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75550: LD_VAR 0 12
75554: PUSH
75555: LD_INT 1
75557: ARRAY
75558: PPUSH
75559: CALL_OW 266
75563: PUSH
75564: LD_INT 5
75566: EQUAL
75567: IFFALSE 75641
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75569: LD_VAR 0 12
75573: PUSH
75574: LD_INT 1
75576: ARRAY
75577: PPUSH
75578: CALL_OW 313
75582: PUSH
75583: LD_INT 3
75585: LESS
75586: IFFALSE 75622
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75588: LD_INT 0
75590: PPUSH
75591: LD_INT 5
75593: PUSH
75594: LD_INT 8
75596: PUSH
75597: LD_INT 9
75599: PUSH
75600: EMPTY
75601: LIST
75602: LIST
75603: LIST
75604: PUSH
75605: LD_VAR 0 17
75609: ARRAY
75610: PPUSH
75611: LD_VAR 0 4
75615: PPUSH
75616: CALL_OW 380
75620: GO 75639
// PrepareHuman ( false , i , skill ) ;
75622: LD_INT 0
75624: PPUSH
75625: LD_VAR 0 8
75629: PPUSH
75630: LD_VAR 0 4
75634: PPUSH
75635: CALL_OW 380
// end else
75639: GO 75658
// PrepareHuman ( false , i , skill ) ;
75641: LD_INT 0
75643: PPUSH
75644: LD_VAR 0 8
75648: PPUSH
75649: LD_VAR 0 4
75653: PPUSH
75654: CALL_OW 380
// un := CreateHuman ;
75658: LD_ADDR_VAR 0 14
75662: PUSH
75663: CALL_OW 44
75667: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75668: LD_ADDR_VAR 0 7
75672: PUSH
75673: LD_VAR 0 7
75677: PPUSH
75678: LD_INT 1
75680: PPUSH
75681: LD_VAR 0 14
75685: PPUSH
75686: CALL_OW 2
75690: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75691: LD_VAR 0 14
75695: PPUSH
75696: LD_VAR 0 12
75700: PUSH
75701: LD_INT 1
75703: ARRAY
75704: PPUSH
75705: CALL_OW 52
// end ;
75709: GO 75348
75711: POP
75712: POP
// end ;
75713: GO 74650
75715: POP
75716: POP
// result := result ^ buildings ;
75717: LD_ADDR_VAR 0 7
75721: PUSH
75722: LD_VAR 0 7
75726: PUSH
75727: LD_VAR 0 18
75731: ADD
75732: ST_TO_ADDR
// end else
75733: GO 75876
// begin for i = 1 to personel do
75735: LD_ADDR_VAR 0 8
75739: PUSH
75740: DOUBLE
75741: LD_INT 1
75743: DEC
75744: ST_TO_ADDR
75745: LD_VAR 0 6
75749: PUSH
75750: FOR_TO
75751: IFFALSE 75874
// begin if i > 4 then
75753: LD_VAR 0 8
75757: PUSH
75758: LD_INT 4
75760: GREATER
75761: IFFALSE 75765
// break ;
75763: GO 75874
// x := personel [ i ] ;
75765: LD_ADDR_VAR 0 13
75769: PUSH
75770: LD_VAR 0 6
75774: PUSH
75775: LD_VAR 0 8
75779: ARRAY
75780: ST_TO_ADDR
// if x = - 1 then
75781: LD_VAR 0 13
75785: PUSH
75786: LD_INT 1
75788: NEG
75789: EQUAL
75790: IFFALSE 75794
// continue ;
75792: GO 75750
// PrepareHuman ( false , i , skill ) ;
75794: LD_INT 0
75796: PPUSH
75797: LD_VAR 0 8
75801: PPUSH
75802: LD_VAR 0 4
75806: PPUSH
75807: CALL_OW 380
// un := CreateHuman ;
75811: LD_ADDR_VAR 0 14
75815: PUSH
75816: CALL_OW 44
75820: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75821: LD_VAR 0 14
75825: PPUSH
75826: LD_VAR 0 1
75830: PPUSH
75831: CALL_OW 250
75835: PPUSH
75836: LD_VAR 0 1
75840: PPUSH
75841: CALL_OW 251
75845: PPUSH
75846: LD_INT 10
75848: PPUSH
75849: LD_INT 0
75851: PPUSH
75852: CALL_OW 50
// result := result ^ un ;
75856: LD_ADDR_VAR 0 7
75860: PUSH
75861: LD_VAR 0 7
75865: PUSH
75866: LD_VAR 0 14
75870: ADD
75871: ST_TO_ADDR
// end ;
75872: GO 75750
75874: POP
75875: POP
// end ; end ;
75876: LD_VAR 0 7
75880: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
75881: LD_INT 0
75883: PPUSH
75884: PPUSH
75885: PPUSH
75886: PPUSH
75887: PPUSH
75888: PPUSH
75889: PPUSH
75890: PPUSH
75891: PPUSH
75892: PPUSH
75893: PPUSH
75894: PPUSH
75895: PPUSH
75896: PPUSH
75897: PPUSH
75898: PPUSH
// result := false ;
75899: LD_ADDR_VAR 0 3
75903: PUSH
75904: LD_INT 0
75906: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
75907: LD_VAR 0 1
75911: NOT
75912: PUSH
75913: LD_VAR 0 1
75917: PPUSH
75918: CALL_OW 266
75922: PUSH
75923: LD_INT 32
75925: PUSH
75926: LD_INT 33
75928: PUSH
75929: EMPTY
75930: LIST
75931: LIST
75932: IN
75933: NOT
75934: OR
75935: IFFALSE 75939
// exit ;
75937: GO 77048
// nat := GetNation ( tower ) ;
75939: LD_ADDR_VAR 0 12
75943: PUSH
75944: LD_VAR 0 1
75948: PPUSH
75949: CALL_OW 248
75953: ST_TO_ADDR
// side := GetSide ( tower ) ;
75954: LD_ADDR_VAR 0 16
75958: PUSH
75959: LD_VAR 0 1
75963: PPUSH
75964: CALL_OW 255
75968: ST_TO_ADDR
// x := GetX ( tower ) ;
75969: LD_ADDR_VAR 0 10
75973: PUSH
75974: LD_VAR 0 1
75978: PPUSH
75979: CALL_OW 250
75983: ST_TO_ADDR
// y := GetY ( tower ) ;
75984: LD_ADDR_VAR 0 11
75988: PUSH
75989: LD_VAR 0 1
75993: PPUSH
75994: CALL_OW 251
75998: ST_TO_ADDR
// if not x or not y then
75999: LD_VAR 0 10
76003: NOT
76004: PUSH
76005: LD_VAR 0 11
76009: NOT
76010: OR
76011: IFFALSE 76015
// exit ;
76013: GO 77048
// weapon := 0 ;
76015: LD_ADDR_VAR 0 18
76019: PUSH
76020: LD_INT 0
76022: ST_TO_ADDR
// fac_list := [ ] ;
76023: LD_ADDR_VAR 0 17
76027: PUSH
76028: EMPTY
76029: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
76030: LD_ADDR_VAR 0 6
76034: PUSH
76035: LD_VAR 0 1
76039: PPUSH
76040: CALL_OW 274
76044: PPUSH
76045: LD_VAR 0 2
76049: PPUSH
76050: LD_INT 0
76052: PPUSH
76053: CALL 73619 0 3
76057: PPUSH
76058: LD_INT 30
76060: PUSH
76061: LD_INT 3
76063: PUSH
76064: EMPTY
76065: LIST
76066: LIST
76067: PPUSH
76068: CALL_OW 72
76072: ST_TO_ADDR
// if not factories then
76073: LD_VAR 0 6
76077: NOT
76078: IFFALSE 76082
// exit ;
76080: GO 77048
// for i in factories do
76082: LD_ADDR_VAR 0 8
76086: PUSH
76087: LD_VAR 0 6
76091: PUSH
76092: FOR_IN
76093: IFFALSE 76118
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76095: LD_ADDR_VAR 0 17
76099: PUSH
76100: LD_VAR 0 17
76104: PUSH
76105: LD_VAR 0 8
76109: PPUSH
76110: CALL_OW 478
76114: UNION
76115: ST_TO_ADDR
76116: GO 76092
76118: POP
76119: POP
// if not fac_list then
76120: LD_VAR 0 17
76124: NOT
76125: IFFALSE 76129
// exit ;
76127: GO 77048
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76129: LD_ADDR_VAR 0 5
76133: PUSH
76134: LD_INT 4
76136: PUSH
76137: LD_INT 5
76139: PUSH
76140: LD_INT 9
76142: PUSH
76143: LD_INT 10
76145: PUSH
76146: LD_INT 6
76148: PUSH
76149: LD_INT 7
76151: PUSH
76152: LD_INT 11
76154: PUSH
76155: EMPTY
76156: LIST
76157: LIST
76158: LIST
76159: LIST
76160: LIST
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 27
76166: PUSH
76167: LD_INT 28
76169: PUSH
76170: LD_INT 26
76172: PUSH
76173: LD_INT 30
76175: PUSH
76176: EMPTY
76177: LIST
76178: LIST
76179: LIST
76180: LIST
76181: PUSH
76182: LD_INT 43
76184: PUSH
76185: LD_INT 44
76187: PUSH
76188: LD_INT 46
76190: PUSH
76191: LD_INT 45
76193: PUSH
76194: LD_INT 47
76196: PUSH
76197: LD_INT 49
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: LIST
76207: PUSH
76208: EMPTY
76209: LIST
76210: LIST
76211: LIST
76212: PUSH
76213: LD_VAR 0 12
76217: ARRAY
76218: ST_TO_ADDR
// list := list isect fac_list ;
76219: LD_ADDR_VAR 0 5
76223: PUSH
76224: LD_VAR 0 5
76228: PUSH
76229: LD_VAR 0 17
76233: ISECT
76234: ST_TO_ADDR
// if not list then
76235: LD_VAR 0 5
76239: NOT
76240: IFFALSE 76244
// exit ;
76242: GO 77048
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76244: LD_VAR 0 12
76248: PUSH
76249: LD_INT 3
76251: EQUAL
76252: PUSH
76253: LD_INT 49
76255: PUSH
76256: LD_VAR 0 5
76260: IN
76261: AND
76262: PUSH
76263: LD_INT 31
76265: PPUSH
76266: LD_VAR 0 16
76270: PPUSH
76271: CALL_OW 321
76275: PUSH
76276: LD_INT 2
76278: EQUAL
76279: AND
76280: IFFALSE 76340
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76282: LD_INT 22
76284: PUSH
76285: LD_VAR 0 16
76289: PUSH
76290: EMPTY
76291: LIST
76292: LIST
76293: PUSH
76294: LD_INT 35
76296: PUSH
76297: LD_INT 49
76299: PUSH
76300: EMPTY
76301: LIST
76302: LIST
76303: PUSH
76304: LD_INT 91
76306: PUSH
76307: LD_VAR 0 1
76311: PUSH
76312: LD_INT 10
76314: PUSH
76315: EMPTY
76316: LIST
76317: LIST
76318: LIST
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: LIST
76324: PPUSH
76325: CALL_OW 69
76329: NOT
76330: IFFALSE 76340
// weapon := ru_time_lapser ;
76332: LD_ADDR_VAR 0 18
76336: PUSH
76337: LD_INT 49
76339: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76340: LD_VAR 0 12
76344: PUSH
76345: LD_INT 1
76347: PUSH
76348: LD_INT 2
76350: PUSH
76351: EMPTY
76352: LIST
76353: LIST
76354: IN
76355: PUSH
76356: LD_INT 11
76358: PUSH
76359: LD_VAR 0 5
76363: IN
76364: PUSH
76365: LD_INT 30
76367: PUSH
76368: LD_VAR 0 5
76372: IN
76373: OR
76374: AND
76375: PUSH
76376: LD_INT 6
76378: PPUSH
76379: LD_VAR 0 16
76383: PPUSH
76384: CALL_OW 321
76388: PUSH
76389: LD_INT 2
76391: EQUAL
76392: AND
76393: IFFALSE 76558
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76395: LD_INT 22
76397: PUSH
76398: LD_VAR 0 16
76402: PUSH
76403: EMPTY
76404: LIST
76405: LIST
76406: PUSH
76407: LD_INT 2
76409: PUSH
76410: LD_INT 35
76412: PUSH
76413: LD_INT 11
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 35
76422: PUSH
76423: LD_INT 30
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: EMPTY
76431: LIST
76432: LIST
76433: LIST
76434: PUSH
76435: LD_INT 91
76437: PUSH
76438: LD_VAR 0 1
76442: PUSH
76443: LD_INT 18
76445: PUSH
76446: EMPTY
76447: LIST
76448: LIST
76449: LIST
76450: PUSH
76451: EMPTY
76452: LIST
76453: LIST
76454: LIST
76455: PPUSH
76456: CALL_OW 69
76460: NOT
76461: PUSH
76462: LD_INT 22
76464: PUSH
76465: LD_VAR 0 16
76469: PUSH
76470: EMPTY
76471: LIST
76472: LIST
76473: PUSH
76474: LD_INT 2
76476: PUSH
76477: LD_INT 30
76479: PUSH
76480: LD_INT 32
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: PUSH
76487: LD_INT 30
76489: PUSH
76490: LD_INT 33
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: EMPTY
76498: LIST
76499: LIST
76500: LIST
76501: PUSH
76502: LD_INT 91
76504: PUSH
76505: LD_VAR 0 1
76509: PUSH
76510: LD_INT 12
76512: PUSH
76513: EMPTY
76514: LIST
76515: LIST
76516: LIST
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: LIST
76522: PUSH
76523: EMPTY
76524: LIST
76525: PPUSH
76526: CALL_OW 69
76530: PUSH
76531: LD_INT 2
76533: GREATER
76534: AND
76535: IFFALSE 76558
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76537: LD_ADDR_VAR 0 18
76541: PUSH
76542: LD_INT 11
76544: PUSH
76545: LD_INT 30
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_VAR 0 12
76556: ARRAY
76557: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76558: LD_VAR 0 18
76562: NOT
76563: PUSH
76564: LD_INT 40
76566: PPUSH
76567: LD_VAR 0 16
76571: PPUSH
76572: CALL_OW 321
76576: PUSH
76577: LD_INT 2
76579: EQUAL
76580: AND
76581: PUSH
76582: LD_INT 7
76584: PUSH
76585: LD_VAR 0 5
76589: IN
76590: PUSH
76591: LD_INT 28
76593: PUSH
76594: LD_VAR 0 5
76598: IN
76599: OR
76600: PUSH
76601: LD_INT 45
76603: PUSH
76604: LD_VAR 0 5
76608: IN
76609: OR
76610: AND
76611: IFFALSE 76865
// begin hex := GetHexInfo ( x , y ) ;
76613: LD_ADDR_VAR 0 4
76617: PUSH
76618: LD_VAR 0 10
76622: PPUSH
76623: LD_VAR 0 11
76627: PPUSH
76628: CALL_OW 546
76632: ST_TO_ADDR
// if hex [ 1 ] then
76633: LD_VAR 0 4
76637: PUSH
76638: LD_INT 1
76640: ARRAY
76641: IFFALSE 76645
// exit ;
76643: GO 77048
// height := hex [ 2 ] ;
76645: LD_ADDR_VAR 0 15
76649: PUSH
76650: LD_VAR 0 4
76654: PUSH
76655: LD_INT 2
76657: ARRAY
76658: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76659: LD_ADDR_VAR 0 14
76663: PUSH
76664: LD_INT 0
76666: PUSH
76667: LD_INT 2
76669: PUSH
76670: LD_INT 3
76672: PUSH
76673: LD_INT 5
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: LIST
76680: LIST
76681: ST_TO_ADDR
// for i in tmp do
76682: LD_ADDR_VAR 0 8
76686: PUSH
76687: LD_VAR 0 14
76691: PUSH
76692: FOR_IN
76693: IFFALSE 76863
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
76695: LD_ADDR_VAR 0 9
76699: PUSH
76700: LD_VAR 0 10
76704: PPUSH
76705: LD_VAR 0 8
76709: PPUSH
76710: LD_INT 5
76712: PPUSH
76713: CALL_OW 272
76717: PUSH
76718: LD_VAR 0 11
76722: PPUSH
76723: LD_VAR 0 8
76727: PPUSH
76728: LD_INT 5
76730: PPUSH
76731: CALL_OW 273
76735: PUSH
76736: EMPTY
76737: LIST
76738: LIST
76739: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
76740: LD_VAR 0 9
76744: PUSH
76745: LD_INT 1
76747: ARRAY
76748: PPUSH
76749: LD_VAR 0 9
76753: PUSH
76754: LD_INT 2
76756: ARRAY
76757: PPUSH
76758: CALL_OW 488
76762: IFFALSE 76861
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
76764: LD_ADDR_VAR 0 4
76768: PUSH
76769: LD_VAR 0 9
76773: PUSH
76774: LD_INT 1
76776: ARRAY
76777: PPUSH
76778: LD_VAR 0 9
76782: PUSH
76783: LD_INT 2
76785: ARRAY
76786: PPUSH
76787: CALL_OW 546
76791: ST_TO_ADDR
// if hex [ 1 ] then
76792: LD_VAR 0 4
76796: PUSH
76797: LD_INT 1
76799: ARRAY
76800: IFFALSE 76804
// continue ;
76802: GO 76692
// h := hex [ 2 ] ;
76804: LD_ADDR_VAR 0 13
76808: PUSH
76809: LD_VAR 0 4
76813: PUSH
76814: LD_INT 2
76816: ARRAY
76817: ST_TO_ADDR
// if h + 7 < height then
76818: LD_VAR 0 13
76822: PUSH
76823: LD_INT 7
76825: PLUS
76826: PUSH
76827: LD_VAR 0 15
76831: LESS
76832: IFFALSE 76861
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
76834: LD_ADDR_VAR 0 18
76838: PUSH
76839: LD_INT 7
76841: PUSH
76842: LD_INT 28
76844: PUSH
76845: LD_INT 45
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: LIST
76852: PUSH
76853: LD_VAR 0 12
76857: ARRAY
76858: ST_TO_ADDR
// break ;
76859: GO 76863
// end ; end ; end ;
76861: GO 76692
76863: POP
76864: POP
// end ; if not weapon then
76865: LD_VAR 0 18
76869: NOT
76870: IFFALSE 76930
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
76872: LD_ADDR_VAR 0 5
76876: PUSH
76877: LD_VAR 0 5
76881: PUSH
76882: LD_INT 11
76884: PUSH
76885: LD_INT 30
76887: PUSH
76888: LD_INT 49
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: LIST
76895: DIFF
76896: ST_TO_ADDR
// if not list then
76897: LD_VAR 0 5
76901: NOT
76902: IFFALSE 76906
// exit ;
76904: GO 77048
// weapon := list [ rand ( 1 , list ) ] ;
76906: LD_ADDR_VAR 0 18
76910: PUSH
76911: LD_VAR 0 5
76915: PUSH
76916: LD_INT 1
76918: PPUSH
76919: LD_VAR 0 5
76923: PPUSH
76924: CALL_OW 12
76928: ARRAY
76929: ST_TO_ADDR
// end ; if weapon then
76930: LD_VAR 0 18
76934: IFFALSE 77048
// begin tmp := CostOfWeapon ( weapon ) ;
76936: LD_ADDR_VAR 0 14
76940: PUSH
76941: LD_VAR 0 18
76945: PPUSH
76946: CALL_OW 451
76950: ST_TO_ADDR
// j := GetBase ( tower ) ;
76951: LD_ADDR_VAR 0 9
76955: PUSH
76956: LD_VAR 0 1
76960: PPUSH
76961: CALL_OW 274
76965: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
76966: LD_VAR 0 9
76970: PPUSH
76971: LD_INT 1
76973: PPUSH
76974: CALL_OW 275
76978: PUSH
76979: LD_VAR 0 14
76983: PUSH
76984: LD_INT 1
76986: ARRAY
76987: GREATEREQUAL
76988: PUSH
76989: LD_VAR 0 9
76993: PPUSH
76994: LD_INT 2
76996: PPUSH
76997: CALL_OW 275
77001: PUSH
77002: LD_VAR 0 14
77006: PUSH
77007: LD_INT 2
77009: ARRAY
77010: GREATEREQUAL
77011: AND
77012: PUSH
77013: LD_VAR 0 9
77017: PPUSH
77018: LD_INT 3
77020: PPUSH
77021: CALL_OW 275
77025: PUSH
77026: LD_VAR 0 14
77030: PUSH
77031: LD_INT 3
77033: ARRAY
77034: GREATEREQUAL
77035: AND
77036: IFFALSE 77048
// result := weapon ;
77038: LD_ADDR_VAR 0 3
77042: PUSH
77043: LD_VAR 0 18
77047: ST_TO_ADDR
// end ; end ;
77048: LD_VAR 0 3
77052: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77053: LD_INT 0
77055: PPUSH
77056: PPUSH
// result := true ;
77057: LD_ADDR_VAR 0 3
77061: PUSH
77062: LD_INT 1
77064: ST_TO_ADDR
// if array1 = array2 then
77065: LD_VAR 0 1
77069: PUSH
77070: LD_VAR 0 2
77074: EQUAL
77075: IFFALSE 77135
// begin for i = 1 to array1 do
77077: LD_ADDR_VAR 0 4
77081: PUSH
77082: DOUBLE
77083: LD_INT 1
77085: DEC
77086: ST_TO_ADDR
77087: LD_VAR 0 1
77091: PUSH
77092: FOR_TO
77093: IFFALSE 77131
// if array1 [ i ] <> array2 [ i ] then
77095: LD_VAR 0 1
77099: PUSH
77100: LD_VAR 0 4
77104: ARRAY
77105: PUSH
77106: LD_VAR 0 2
77110: PUSH
77111: LD_VAR 0 4
77115: ARRAY
77116: NONEQUAL
77117: IFFALSE 77129
// begin result := false ;
77119: LD_ADDR_VAR 0 3
77123: PUSH
77124: LD_INT 0
77126: ST_TO_ADDR
// break ;
77127: GO 77131
// end ;
77129: GO 77092
77131: POP
77132: POP
// end else
77133: GO 77143
// result := false ;
77135: LD_ADDR_VAR 0 3
77139: PUSH
77140: LD_INT 0
77142: ST_TO_ADDR
// end ;
77143: LD_VAR 0 3
77147: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
77148: LD_INT 0
77150: PPUSH
77151: PPUSH
// if not array1 or not array2 then
77152: LD_VAR 0 1
77156: NOT
77157: PUSH
77158: LD_VAR 0 2
77162: NOT
77163: OR
77164: IFFALSE 77168
// exit ;
77166: GO 77232
// result := true ;
77168: LD_ADDR_VAR 0 3
77172: PUSH
77173: LD_INT 1
77175: ST_TO_ADDR
// for i = 1 to array1 do
77176: LD_ADDR_VAR 0 4
77180: PUSH
77181: DOUBLE
77182: LD_INT 1
77184: DEC
77185: ST_TO_ADDR
77186: LD_VAR 0 1
77190: PUSH
77191: FOR_TO
77192: IFFALSE 77230
// if array1 [ i ] <> array2 [ i ] then
77194: LD_VAR 0 1
77198: PUSH
77199: LD_VAR 0 4
77203: ARRAY
77204: PUSH
77205: LD_VAR 0 2
77209: PUSH
77210: LD_VAR 0 4
77214: ARRAY
77215: NONEQUAL
77216: IFFALSE 77228
// begin result := false ;
77218: LD_ADDR_VAR 0 3
77222: PUSH
77223: LD_INT 0
77225: ST_TO_ADDR
// break ;
77226: GO 77230
// end ;
77228: GO 77191
77230: POP
77231: POP
// end ;
77232: LD_VAR 0 3
77236: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77237: LD_INT 0
77239: PPUSH
77240: PPUSH
77241: PPUSH
// pom := GetBase ( fac ) ;
77242: LD_ADDR_VAR 0 5
77246: PUSH
77247: LD_VAR 0 1
77251: PPUSH
77252: CALL_OW 274
77256: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77257: LD_ADDR_VAR 0 4
77261: PUSH
77262: LD_VAR 0 2
77266: PUSH
77267: LD_INT 1
77269: ARRAY
77270: PPUSH
77271: LD_VAR 0 2
77275: PUSH
77276: LD_INT 2
77278: ARRAY
77279: PPUSH
77280: LD_VAR 0 2
77284: PUSH
77285: LD_INT 3
77287: ARRAY
77288: PPUSH
77289: LD_VAR 0 2
77293: PUSH
77294: LD_INT 4
77296: ARRAY
77297: PPUSH
77298: CALL_OW 449
77302: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77303: LD_ADDR_VAR 0 3
77307: PUSH
77308: LD_VAR 0 5
77312: PPUSH
77313: LD_INT 1
77315: PPUSH
77316: CALL_OW 275
77320: PUSH
77321: LD_VAR 0 4
77325: PUSH
77326: LD_INT 1
77328: ARRAY
77329: GREATEREQUAL
77330: PUSH
77331: LD_VAR 0 5
77335: PPUSH
77336: LD_INT 2
77338: PPUSH
77339: CALL_OW 275
77343: PUSH
77344: LD_VAR 0 4
77348: PUSH
77349: LD_INT 2
77351: ARRAY
77352: GREATEREQUAL
77353: AND
77354: PUSH
77355: LD_VAR 0 5
77359: PPUSH
77360: LD_INT 3
77362: PPUSH
77363: CALL_OW 275
77367: PUSH
77368: LD_VAR 0 4
77372: PUSH
77373: LD_INT 3
77375: ARRAY
77376: GREATEREQUAL
77377: AND
77378: ST_TO_ADDR
// end ;
77379: LD_VAR 0 3
77383: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77384: LD_INT 0
77386: PPUSH
77387: PPUSH
77388: PPUSH
77389: PPUSH
// pom := GetBase ( building ) ;
77390: LD_ADDR_VAR 0 3
77394: PUSH
77395: LD_VAR 0 1
77399: PPUSH
77400: CALL_OW 274
77404: ST_TO_ADDR
// if not pom then
77405: LD_VAR 0 3
77409: NOT
77410: IFFALSE 77414
// exit ;
77412: GO 77584
// btype := GetBType ( building ) ;
77414: LD_ADDR_VAR 0 5
77418: PUSH
77419: LD_VAR 0 1
77423: PPUSH
77424: CALL_OW 266
77428: ST_TO_ADDR
// if btype = b_armoury then
77429: LD_VAR 0 5
77433: PUSH
77434: LD_INT 4
77436: EQUAL
77437: IFFALSE 77447
// btype := b_barracks ;
77439: LD_ADDR_VAR 0 5
77443: PUSH
77444: LD_INT 5
77446: ST_TO_ADDR
// if btype = b_depot then
77447: LD_VAR 0 5
77451: PUSH
77452: LD_INT 0
77454: EQUAL
77455: IFFALSE 77465
// btype := b_warehouse ;
77457: LD_ADDR_VAR 0 5
77461: PUSH
77462: LD_INT 1
77464: ST_TO_ADDR
// if btype = b_workshop then
77465: LD_VAR 0 5
77469: PUSH
77470: LD_INT 2
77472: EQUAL
77473: IFFALSE 77483
// btype := b_factory ;
77475: LD_ADDR_VAR 0 5
77479: PUSH
77480: LD_INT 3
77482: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77483: LD_ADDR_VAR 0 4
77487: PUSH
77488: LD_VAR 0 5
77492: PPUSH
77493: LD_VAR 0 1
77497: PPUSH
77498: CALL_OW 248
77502: PPUSH
77503: CALL_OW 450
77507: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77508: LD_ADDR_VAR 0 2
77512: PUSH
77513: LD_VAR 0 3
77517: PPUSH
77518: LD_INT 1
77520: PPUSH
77521: CALL_OW 275
77525: PUSH
77526: LD_VAR 0 4
77530: PUSH
77531: LD_INT 1
77533: ARRAY
77534: GREATEREQUAL
77535: PUSH
77536: LD_VAR 0 3
77540: PPUSH
77541: LD_INT 2
77543: PPUSH
77544: CALL_OW 275
77548: PUSH
77549: LD_VAR 0 4
77553: PUSH
77554: LD_INT 2
77556: ARRAY
77557: GREATEREQUAL
77558: AND
77559: PUSH
77560: LD_VAR 0 3
77564: PPUSH
77565: LD_INT 3
77567: PPUSH
77568: CALL_OW 275
77572: PUSH
77573: LD_VAR 0 4
77577: PUSH
77578: LD_INT 3
77580: ARRAY
77581: GREATEREQUAL
77582: AND
77583: ST_TO_ADDR
// end ;
77584: LD_VAR 0 2
77588: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77589: LD_INT 0
77591: PPUSH
77592: PPUSH
77593: PPUSH
// pom := GetBase ( building ) ;
77594: LD_ADDR_VAR 0 4
77598: PUSH
77599: LD_VAR 0 1
77603: PPUSH
77604: CALL_OW 274
77608: ST_TO_ADDR
// if not pom then
77609: LD_VAR 0 4
77613: NOT
77614: IFFALSE 77618
// exit ;
77616: GO 77719
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77618: LD_ADDR_VAR 0 5
77622: PUSH
77623: LD_VAR 0 2
77627: PPUSH
77628: LD_VAR 0 1
77632: PPUSH
77633: CALL_OW 248
77637: PPUSH
77638: CALL_OW 450
77642: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77643: LD_ADDR_VAR 0 3
77647: PUSH
77648: LD_VAR 0 4
77652: PPUSH
77653: LD_INT 1
77655: PPUSH
77656: CALL_OW 275
77660: PUSH
77661: LD_VAR 0 5
77665: PUSH
77666: LD_INT 1
77668: ARRAY
77669: GREATEREQUAL
77670: PUSH
77671: LD_VAR 0 4
77675: PPUSH
77676: LD_INT 2
77678: PPUSH
77679: CALL_OW 275
77683: PUSH
77684: LD_VAR 0 5
77688: PUSH
77689: LD_INT 2
77691: ARRAY
77692: GREATEREQUAL
77693: AND
77694: PUSH
77695: LD_VAR 0 4
77699: PPUSH
77700: LD_INT 3
77702: PPUSH
77703: CALL_OW 275
77707: PUSH
77708: LD_VAR 0 5
77712: PUSH
77713: LD_INT 3
77715: ARRAY
77716: GREATEREQUAL
77717: AND
77718: ST_TO_ADDR
// end ;
77719: LD_VAR 0 3
77723: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
77724: LD_INT 0
77726: PPUSH
77727: PPUSH
77728: PPUSH
77729: PPUSH
77730: PPUSH
77731: PPUSH
77732: PPUSH
77733: PPUSH
77734: PPUSH
77735: PPUSH
77736: PPUSH
// result := false ;
77737: LD_ADDR_VAR 0 8
77741: PUSH
77742: LD_INT 0
77744: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
77745: LD_VAR 0 5
77749: NOT
77750: PUSH
77751: LD_VAR 0 1
77755: NOT
77756: OR
77757: PUSH
77758: LD_VAR 0 2
77762: NOT
77763: OR
77764: PUSH
77765: LD_VAR 0 3
77769: NOT
77770: OR
77771: IFFALSE 77775
// exit ;
77773: GO 78589
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
77775: LD_ADDR_VAR 0 14
77779: PUSH
77780: LD_VAR 0 1
77784: PPUSH
77785: LD_VAR 0 2
77789: PPUSH
77790: LD_VAR 0 3
77794: PPUSH
77795: LD_VAR 0 4
77799: PPUSH
77800: LD_VAR 0 5
77804: PUSH
77805: LD_INT 1
77807: ARRAY
77808: PPUSH
77809: CALL_OW 248
77813: PPUSH
77814: LD_INT 0
77816: PPUSH
77817: CALL 79826 0 6
77821: ST_TO_ADDR
// if not hexes then
77822: LD_VAR 0 14
77826: NOT
77827: IFFALSE 77831
// exit ;
77829: GO 78589
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
77831: LD_ADDR_VAR 0 17
77835: PUSH
77836: LD_VAR 0 5
77840: PPUSH
77841: LD_INT 22
77843: PUSH
77844: LD_VAR 0 13
77848: PPUSH
77849: CALL_OW 255
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 2
77860: PUSH
77861: LD_INT 30
77863: PUSH
77864: LD_INT 0
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: LD_INT 30
77873: PUSH
77874: LD_INT 1
77876: PUSH
77877: EMPTY
77878: LIST
77879: LIST
77880: PUSH
77881: EMPTY
77882: LIST
77883: LIST
77884: LIST
77885: PUSH
77886: EMPTY
77887: LIST
77888: LIST
77889: PPUSH
77890: CALL_OW 72
77894: ST_TO_ADDR
// for i = 1 to hexes do
77895: LD_ADDR_VAR 0 9
77899: PUSH
77900: DOUBLE
77901: LD_INT 1
77903: DEC
77904: ST_TO_ADDR
77905: LD_VAR 0 14
77909: PUSH
77910: FOR_TO
77911: IFFALSE 78587
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
77913: LD_ADDR_VAR 0 13
77917: PUSH
77918: LD_VAR 0 14
77922: PUSH
77923: LD_VAR 0 9
77927: ARRAY
77928: PUSH
77929: LD_INT 1
77931: ARRAY
77932: PPUSH
77933: LD_VAR 0 14
77937: PUSH
77938: LD_VAR 0 9
77942: ARRAY
77943: PUSH
77944: LD_INT 2
77946: ARRAY
77947: PPUSH
77948: CALL_OW 428
77952: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
77953: LD_VAR 0 14
77957: PUSH
77958: LD_VAR 0 9
77962: ARRAY
77963: PUSH
77964: LD_INT 1
77966: ARRAY
77967: PPUSH
77968: LD_VAR 0 14
77972: PUSH
77973: LD_VAR 0 9
77977: ARRAY
77978: PUSH
77979: LD_INT 2
77981: ARRAY
77982: PPUSH
77983: CALL_OW 351
77987: PUSH
77988: LD_VAR 0 14
77992: PUSH
77993: LD_VAR 0 9
77997: ARRAY
77998: PUSH
77999: LD_INT 1
78001: ARRAY
78002: PPUSH
78003: LD_VAR 0 14
78007: PUSH
78008: LD_VAR 0 9
78012: ARRAY
78013: PUSH
78014: LD_INT 2
78016: ARRAY
78017: PPUSH
78018: CALL_OW 488
78022: NOT
78023: OR
78024: PUSH
78025: LD_VAR 0 13
78029: PPUSH
78030: CALL_OW 247
78034: PUSH
78035: LD_INT 3
78037: EQUAL
78038: OR
78039: IFFALSE 78045
// exit ;
78041: POP
78042: POP
78043: GO 78589
// if not tmp then
78045: LD_VAR 0 13
78049: NOT
78050: IFFALSE 78054
// continue ;
78052: GO 77910
// result := true ;
78054: LD_ADDR_VAR 0 8
78058: PUSH
78059: LD_INT 1
78061: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
78062: LD_VAR 0 6
78066: PUSH
78067: LD_VAR 0 13
78071: PPUSH
78072: CALL_OW 247
78076: PUSH
78077: LD_INT 2
78079: EQUAL
78080: AND
78081: PUSH
78082: LD_VAR 0 13
78086: PPUSH
78087: CALL_OW 263
78091: PUSH
78092: LD_INT 1
78094: EQUAL
78095: AND
78096: IFFALSE 78260
// begin if IsDrivenBy ( tmp ) then
78098: LD_VAR 0 13
78102: PPUSH
78103: CALL_OW 311
78107: IFFALSE 78111
// continue ;
78109: GO 77910
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
78111: LD_VAR 0 6
78115: PPUSH
78116: LD_INT 3
78118: PUSH
78119: LD_INT 60
78121: PUSH
78122: EMPTY
78123: LIST
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: PUSH
78129: LD_INT 3
78131: PUSH
78132: LD_INT 55
78134: PUSH
78135: EMPTY
78136: LIST
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: EMPTY
78143: LIST
78144: LIST
78145: PPUSH
78146: CALL_OW 72
78150: IFFALSE 78258
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
78152: LD_ADDR_VAR 0 18
78156: PUSH
78157: LD_VAR 0 6
78161: PPUSH
78162: LD_INT 3
78164: PUSH
78165: LD_INT 60
78167: PUSH
78168: EMPTY
78169: LIST
78170: PUSH
78171: EMPTY
78172: LIST
78173: LIST
78174: PUSH
78175: LD_INT 3
78177: PUSH
78178: LD_INT 55
78180: PUSH
78181: EMPTY
78182: LIST
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: EMPTY
78189: LIST
78190: LIST
78191: PPUSH
78192: CALL_OW 72
78196: PUSH
78197: LD_INT 1
78199: ARRAY
78200: ST_TO_ADDR
// if IsInUnit ( driver ) then
78201: LD_VAR 0 18
78205: PPUSH
78206: CALL_OW 310
78210: IFFALSE 78221
// ComExit ( driver ) ;
78212: LD_VAR 0 18
78216: PPUSH
78217: CALL 103010 0 1
// AddComEnterUnit ( driver , tmp ) ;
78221: LD_VAR 0 18
78225: PPUSH
78226: LD_VAR 0 13
78230: PPUSH
78231: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
78235: LD_VAR 0 18
78239: PPUSH
78240: LD_VAR 0 7
78244: PPUSH
78245: CALL_OW 173
// AddComExitVehicle ( driver ) ;
78249: LD_VAR 0 18
78253: PPUSH
78254: CALL_OW 181
// end ; continue ;
78258: GO 77910
// end ; if not cleaners or not tmp in cleaners then
78260: LD_VAR 0 6
78264: NOT
78265: PUSH
78266: LD_VAR 0 13
78270: PUSH
78271: LD_VAR 0 6
78275: IN
78276: NOT
78277: OR
78278: IFFALSE 78585
// begin if dep then
78280: LD_VAR 0 17
78284: IFFALSE 78420
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78286: LD_ADDR_VAR 0 16
78290: PUSH
78291: LD_VAR 0 17
78295: PUSH
78296: LD_INT 1
78298: ARRAY
78299: PPUSH
78300: CALL_OW 250
78304: PPUSH
78305: LD_VAR 0 17
78309: PUSH
78310: LD_INT 1
78312: ARRAY
78313: PPUSH
78314: CALL_OW 254
78318: PPUSH
78319: LD_INT 5
78321: PPUSH
78322: CALL_OW 272
78326: PUSH
78327: LD_VAR 0 17
78331: PUSH
78332: LD_INT 1
78334: ARRAY
78335: PPUSH
78336: CALL_OW 251
78340: PPUSH
78341: LD_VAR 0 17
78345: PUSH
78346: LD_INT 1
78348: ARRAY
78349: PPUSH
78350: CALL_OW 254
78354: PPUSH
78355: LD_INT 5
78357: PPUSH
78358: CALL_OW 273
78362: PUSH
78363: EMPTY
78364: LIST
78365: LIST
78366: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78367: LD_VAR 0 16
78371: PUSH
78372: LD_INT 1
78374: ARRAY
78375: PPUSH
78376: LD_VAR 0 16
78380: PUSH
78381: LD_INT 2
78383: ARRAY
78384: PPUSH
78385: CALL_OW 488
78389: IFFALSE 78420
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78391: LD_VAR 0 13
78395: PPUSH
78396: LD_VAR 0 16
78400: PUSH
78401: LD_INT 1
78403: ARRAY
78404: PPUSH
78405: LD_VAR 0 16
78409: PUSH
78410: LD_INT 2
78412: ARRAY
78413: PPUSH
78414: CALL_OW 111
// continue ;
78418: GO 77910
// end ; end ; r := GetDir ( tmp ) ;
78420: LD_ADDR_VAR 0 15
78424: PUSH
78425: LD_VAR 0 13
78429: PPUSH
78430: CALL_OW 254
78434: ST_TO_ADDR
// if r = 5 then
78435: LD_VAR 0 15
78439: PUSH
78440: LD_INT 5
78442: EQUAL
78443: IFFALSE 78453
// r := 0 ;
78445: LD_ADDR_VAR 0 15
78449: PUSH
78450: LD_INT 0
78452: ST_TO_ADDR
// for j = r to 5 do
78453: LD_ADDR_VAR 0 10
78457: PUSH
78458: DOUBLE
78459: LD_VAR 0 15
78463: DEC
78464: ST_TO_ADDR
78465: LD_INT 5
78467: PUSH
78468: FOR_TO
78469: IFFALSE 78583
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78471: LD_ADDR_VAR 0 11
78475: PUSH
78476: LD_VAR 0 13
78480: PPUSH
78481: CALL_OW 250
78485: PPUSH
78486: LD_VAR 0 10
78490: PPUSH
78491: LD_INT 2
78493: PPUSH
78494: CALL_OW 272
78498: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78499: LD_ADDR_VAR 0 12
78503: PUSH
78504: LD_VAR 0 13
78508: PPUSH
78509: CALL_OW 251
78513: PPUSH
78514: LD_VAR 0 10
78518: PPUSH
78519: LD_INT 2
78521: PPUSH
78522: CALL_OW 273
78526: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78527: LD_VAR 0 11
78531: PPUSH
78532: LD_VAR 0 12
78536: PPUSH
78537: CALL_OW 488
78541: PUSH
78542: LD_VAR 0 11
78546: PPUSH
78547: LD_VAR 0 12
78551: PPUSH
78552: CALL_OW 428
78556: NOT
78557: AND
78558: IFFALSE 78581
// begin ComMoveXY ( tmp , _x , _y ) ;
78560: LD_VAR 0 13
78564: PPUSH
78565: LD_VAR 0 11
78569: PPUSH
78570: LD_VAR 0 12
78574: PPUSH
78575: CALL_OW 111
// break ;
78579: GO 78583
// end ; end ;
78581: GO 78468
78583: POP
78584: POP
// end ; end ;
78585: GO 77910
78587: POP
78588: POP
// end ;
78589: LD_VAR 0 8
78593: RET
// export function BuildingTechInvented ( side , btype ) ; begin
78594: LD_INT 0
78596: PPUSH
// result := true ;
78597: LD_ADDR_VAR 0 3
78601: PUSH
78602: LD_INT 1
78604: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
78605: LD_VAR 0 2
78609: PUSH
78610: LD_INT 24
78612: DOUBLE
78613: EQUAL
78614: IFTRUE 78624
78616: LD_INT 33
78618: DOUBLE
78619: EQUAL
78620: IFTRUE 78624
78622: GO 78649
78624: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
78625: LD_ADDR_VAR 0 3
78629: PUSH
78630: LD_INT 32
78632: PPUSH
78633: LD_VAR 0 1
78637: PPUSH
78638: CALL_OW 321
78642: PUSH
78643: LD_INT 2
78645: EQUAL
78646: ST_TO_ADDR
78647: GO 78969
78649: LD_INT 20
78651: DOUBLE
78652: EQUAL
78653: IFTRUE 78657
78655: GO 78682
78657: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
78658: LD_ADDR_VAR 0 3
78662: PUSH
78663: LD_INT 6
78665: PPUSH
78666: LD_VAR 0 1
78670: PPUSH
78671: CALL_OW 321
78675: PUSH
78676: LD_INT 2
78678: EQUAL
78679: ST_TO_ADDR
78680: GO 78969
78682: LD_INT 22
78684: DOUBLE
78685: EQUAL
78686: IFTRUE 78696
78688: LD_INT 36
78690: DOUBLE
78691: EQUAL
78692: IFTRUE 78696
78694: GO 78721
78696: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
78697: LD_ADDR_VAR 0 3
78701: PUSH
78702: LD_INT 15
78704: PPUSH
78705: LD_VAR 0 1
78709: PPUSH
78710: CALL_OW 321
78714: PUSH
78715: LD_INT 2
78717: EQUAL
78718: ST_TO_ADDR
78719: GO 78969
78721: LD_INT 30
78723: DOUBLE
78724: EQUAL
78725: IFTRUE 78729
78727: GO 78754
78729: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
78730: LD_ADDR_VAR 0 3
78734: PUSH
78735: LD_INT 20
78737: PPUSH
78738: LD_VAR 0 1
78742: PPUSH
78743: CALL_OW 321
78747: PUSH
78748: LD_INT 2
78750: EQUAL
78751: ST_TO_ADDR
78752: GO 78969
78754: LD_INT 28
78756: DOUBLE
78757: EQUAL
78758: IFTRUE 78768
78760: LD_INT 21
78762: DOUBLE
78763: EQUAL
78764: IFTRUE 78768
78766: GO 78793
78768: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
78769: LD_ADDR_VAR 0 3
78773: PUSH
78774: LD_INT 21
78776: PPUSH
78777: LD_VAR 0 1
78781: PPUSH
78782: CALL_OW 321
78786: PUSH
78787: LD_INT 2
78789: EQUAL
78790: ST_TO_ADDR
78791: GO 78969
78793: LD_INT 16
78795: DOUBLE
78796: EQUAL
78797: IFTRUE 78801
78799: GO 78828
78801: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
78802: LD_ADDR_VAR 0 3
78806: PUSH
78807: LD_EXP 107
78811: PPUSH
78812: LD_VAR 0 1
78816: PPUSH
78817: CALL_OW 321
78821: PUSH
78822: LD_INT 2
78824: EQUAL
78825: ST_TO_ADDR
78826: GO 78969
78828: LD_INT 19
78830: DOUBLE
78831: EQUAL
78832: IFTRUE 78842
78834: LD_INT 23
78836: DOUBLE
78837: EQUAL
78838: IFTRUE 78842
78840: GO 78869
78842: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
78843: LD_ADDR_VAR 0 3
78847: PUSH
78848: LD_EXP 106
78852: PPUSH
78853: LD_VAR 0 1
78857: PPUSH
78858: CALL_OW 321
78862: PUSH
78863: LD_INT 2
78865: EQUAL
78866: ST_TO_ADDR
78867: GO 78969
78869: LD_INT 17
78871: DOUBLE
78872: EQUAL
78873: IFTRUE 78877
78875: GO 78902
78877: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
78878: LD_ADDR_VAR 0 3
78882: PUSH
78883: LD_INT 39
78885: PPUSH
78886: LD_VAR 0 1
78890: PPUSH
78891: CALL_OW 321
78895: PUSH
78896: LD_INT 2
78898: EQUAL
78899: ST_TO_ADDR
78900: GO 78969
78902: LD_INT 18
78904: DOUBLE
78905: EQUAL
78906: IFTRUE 78910
78908: GO 78935
78910: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
78911: LD_ADDR_VAR 0 3
78915: PUSH
78916: LD_INT 40
78918: PPUSH
78919: LD_VAR 0 1
78923: PPUSH
78924: CALL_OW 321
78928: PUSH
78929: LD_INT 2
78931: EQUAL
78932: ST_TO_ADDR
78933: GO 78969
78935: LD_INT 27
78937: DOUBLE
78938: EQUAL
78939: IFTRUE 78943
78941: GO 78968
78943: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
78944: LD_ADDR_VAR 0 3
78948: PUSH
78949: LD_INT 35
78951: PPUSH
78952: LD_VAR 0 1
78956: PPUSH
78957: CALL_OW 321
78961: PUSH
78962: LD_INT 2
78964: EQUAL
78965: ST_TO_ADDR
78966: GO 78969
78968: POP
// end ;
78969: LD_VAR 0 3
78973: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
78974: LD_INT 0
78976: PPUSH
78977: PPUSH
78978: PPUSH
78979: PPUSH
78980: PPUSH
78981: PPUSH
78982: PPUSH
78983: PPUSH
78984: PPUSH
78985: PPUSH
78986: PPUSH
// result := false ;
78987: LD_ADDR_VAR 0 6
78991: PUSH
78992: LD_INT 0
78994: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78995: LD_VAR 0 1
78999: NOT
79000: PUSH
79001: LD_VAR 0 1
79005: PPUSH
79006: CALL_OW 266
79010: PUSH
79011: LD_INT 0
79013: PUSH
79014: LD_INT 1
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: IN
79021: NOT
79022: OR
79023: PUSH
79024: LD_VAR 0 2
79028: NOT
79029: OR
79030: PUSH
79031: LD_VAR 0 5
79035: PUSH
79036: LD_INT 0
79038: PUSH
79039: LD_INT 1
79041: PUSH
79042: LD_INT 2
79044: PUSH
79045: LD_INT 3
79047: PUSH
79048: LD_INT 4
79050: PUSH
79051: LD_INT 5
79053: PUSH
79054: EMPTY
79055: LIST
79056: LIST
79057: LIST
79058: LIST
79059: LIST
79060: LIST
79061: IN
79062: NOT
79063: OR
79064: PUSH
79065: LD_VAR 0 3
79069: PPUSH
79070: LD_VAR 0 4
79074: PPUSH
79075: CALL_OW 488
79079: NOT
79080: OR
79081: IFFALSE 79085
// exit ;
79083: GO 79821
// side := GetSide ( depot ) ;
79085: LD_ADDR_VAR 0 9
79089: PUSH
79090: LD_VAR 0 1
79094: PPUSH
79095: CALL_OW 255
79099: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
79100: LD_VAR 0 9
79104: PPUSH
79105: LD_VAR 0 2
79109: PPUSH
79110: CALL 78594 0 2
79114: NOT
79115: IFFALSE 79119
// exit ;
79117: GO 79821
// pom := GetBase ( depot ) ;
79119: LD_ADDR_VAR 0 10
79123: PUSH
79124: LD_VAR 0 1
79128: PPUSH
79129: CALL_OW 274
79133: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
79134: LD_ADDR_VAR 0 11
79138: PUSH
79139: LD_VAR 0 2
79143: PPUSH
79144: LD_VAR 0 1
79148: PPUSH
79149: CALL_OW 248
79153: PPUSH
79154: CALL_OW 450
79158: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
79159: LD_VAR 0 10
79163: PPUSH
79164: LD_INT 1
79166: PPUSH
79167: CALL_OW 275
79171: PUSH
79172: LD_VAR 0 11
79176: PUSH
79177: LD_INT 1
79179: ARRAY
79180: GREATEREQUAL
79181: PUSH
79182: LD_VAR 0 10
79186: PPUSH
79187: LD_INT 2
79189: PPUSH
79190: CALL_OW 275
79194: PUSH
79195: LD_VAR 0 11
79199: PUSH
79200: LD_INT 2
79202: ARRAY
79203: GREATEREQUAL
79204: AND
79205: PUSH
79206: LD_VAR 0 10
79210: PPUSH
79211: LD_INT 3
79213: PPUSH
79214: CALL_OW 275
79218: PUSH
79219: LD_VAR 0 11
79223: PUSH
79224: LD_INT 3
79226: ARRAY
79227: GREATEREQUAL
79228: AND
79229: NOT
79230: IFFALSE 79234
// exit ;
79232: GO 79821
// if GetBType ( depot ) = b_depot then
79234: LD_VAR 0 1
79238: PPUSH
79239: CALL_OW 266
79243: PUSH
79244: LD_INT 0
79246: EQUAL
79247: IFFALSE 79259
// dist := 28 else
79249: LD_ADDR_VAR 0 14
79253: PUSH
79254: LD_INT 28
79256: ST_TO_ADDR
79257: GO 79267
// dist := 36 ;
79259: LD_ADDR_VAR 0 14
79263: PUSH
79264: LD_INT 36
79266: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
79267: LD_VAR 0 1
79271: PPUSH
79272: LD_VAR 0 3
79276: PPUSH
79277: LD_VAR 0 4
79281: PPUSH
79282: CALL_OW 297
79286: PUSH
79287: LD_VAR 0 14
79291: GREATER
79292: IFFALSE 79296
// exit ;
79294: GO 79821
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
79296: LD_ADDR_VAR 0 12
79300: PUSH
79301: LD_VAR 0 2
79305: PPUSH
79306: LD_VAR 0 3
79310: PPUSH
79311: LD_VAR 0 4
79315: PPUSH
79316: LD_VAR 0 5
79320: PPUSH
79321: LD_VAR 0 1
79325: PPUSH
79326: CALL_OW 248
79330: PPUSH
79331: LD_INT 0
79333: PPUSH
79334: CALL 79826 0 6
79338: ST_TO_ADDR
// if not hexes then
79339: LD_VAR 0 12
79343: NOT
79344: IFFALSE 79348
// exit ;
79346: GO 79821
// hex := GetHexInfo ( x , y ) ;
79348: LD_ADDR_VAR 0 15
79352: PUSH
79353: LD_VAR 0 3
79357: PPUSH
79358: LD_VAR 0 4
79362: PPUSH
79363: CALL_OW 546
79367: ST_TO_ADDR
// if hex [ 1 ] then
79368: LD_VAR 0 15
79372: PUSH
79373: LD_INT 1
79375: ARRAY
79376: IFFALSE 79380
// exit ;
79378: GO 79821
// height := hex [ 2 ] ;
79380: LD_ADDR_VAR 0 13
79384: PUSH
79385: LD_VAR 0 15
79389: PUSH
79390: LD_INT 2
79392: ARRAY
79393: ST_TO_ADDR
// for i = 1 to hexes do
79394: LD_ADDR_VAR 0 7
79398: PUSH
79399: DOUBLE
79400: LD_INT 1
79402: DEC
79403: ST_TO_ADDR
79404: LD_VAR 0 12
79408: PUSH
79409: FOR_TO
79410: IFFALSE 79740
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79412: LD_VAR 0 12
79416: PUSH
79417: LD_VAR 0 7
79421: ARRAY
79422: PUSH
79423: LD_INT 1
79425: ARRAY
79426: PPUSH
79427: LD_VAR 0 12
79431: PUSH
79432: LD_VAR 0 7
79436: ARRAY
79437: PUSH
79438: LD_INT 2
79440: ARRAY
79441: PPUSH
79442: CALL_OW 488
79446: NOT
79447: PUSH
79448: LD_VAR 0 12
79452: PUSH
79453: LD_VAR 0 7
79457: ARRAY
79458: PUSH
79459: LD_INT 1
79461: ARRAY
79462: PPUSH
79463: LD_VAR 0 12
79467: PUSH
79468: LD_VAR 0 7
79472: ARRAY
79473: PUSH
79474: LD_INT 2
79476: ARRAY
79477: PPUSH
79478: CALL_OW 428
79482: PUSH
79483: LD_INT 0
79485: GREATER
79486: OR
79487: PUSH
79488: LD_VAR 0 12
79492: PUSH
79493: LD_VAR 0 7
79497: ARRAY
79498: PUSH
79499: LD_INT 1
79501: ARRAY
79502: PPUSH
79503: LD_VAR 0 12
79507: PUSH
79508: LD_VAR 0 7
79512: ARRAY
79513: PUSH
79514: LD_INT 2
79516: ARRAY
79517: PPUSH
79518: CALL_OW 351
79522: OR
79523: IFFALSE 79529
// exit ;
79525: POP
79526: POP
79527: GO 79821
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79529: LD_ADDR_VAR 0 8
79533: PUSH
79534: LD_VAR 0 12
79538: PUSH
79539: LD_VAR 0 7
79543: ARRAY
79544: PUSH
79545: LD_INT 1
79547: ARRAY
79548: PPUSH
79549: LD_VAR 0 12
79553: PUSH
79554: LD_VAR 0 7
79558: ARRAY
79559: PUSH
79560: LD_INT 2
79562: ARRAY
79563: PPUSH
79564: CALL_OW 546
79568: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79569: LD_VAR 0 8
79573: PUSH
79574: LD_INT 1
79576: ARRAY
79577: PUSH
79578: LD_VAR 0 8
79582: PUSH
79583: LD_INT 2
79585: ARRAY
79586: PUSH
79587: LD_VAR 0 13
79591: PUSH
79592: LD_INT 2
79594: PLUS
79595: GREATER
79596: OR
79597: PUSH
79598: LD_VAR 0 8
79602: PUSH
79603: LD_INT 2
79605: ARRAY
79606: PUSH
79607: LD_VAR 0 13
79611: PUSH
79612: LD_INT 2
79614: MINUS
79615: LESS
79616: OR
79617: PUSH
79618: LD_VAR 0 8
79622: PUSH
79623: LD_INT 3
79625: ARRAY
79626: PUSH
79627: LD_INT 0
79629: PUSH
79630: LD_INT 8
79632: PUSH
79633: LD_INT 9
79635: PUSH
79636: LD_INT 10
79638: PUSH
79639: LD_INT 11
79641: PUSH
79642: LD_INT 12
79644: PUSH
79645: LD_INT 13
79647: PUSH
79648: LD_INT 16
79650: PUSH
79651: LD_INT 17
79653: PUSH
79654: LD_INT 18
79656: PUSH
79657: LD_INT 19
79659: PUSH
79660: LD_INT 20
79662: PUSH
79663: LD_INT 21
79665: PUSH
79666: EMPTY
79667: LIST
79668: LIST
79669: LIST
79670: LIST
79671: LIST
79672: LIST
79673: LIST
79674: LIST
79675: LIST
79676: LIST
79677: LIST
79678: LIST
79679: LIST
79680: IN
79681: NOT
79682: OR
79683: PUSH
79684: LD_VAR 0 8
79688: PUSH
79689: LD_INT 5
79691: ARRAY
79692: NOT
79693: OR
79694: PUSH
79695: LD_VAR 0 8
79699: PUSH
79700: LD_INT 6
79702: ARRAY
79703: PUSH
79704: LD_INT 1
79706: PUSH
79707: LD_INT 2
79709: PUSH
79710: LD_INT 7
79712: PUSH
79713: LD_INT 9
79715: PUSH
79716: LD_INT 10
79718: PUSH
79719: LD_INT 11
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: LIST
79726: LIST
79727: LIST
79728: LIST
79729: IN
79730: NOT
79731: OR
79732: IFFALSE 79738
// exit ;
79734: POP
79735: POP
79736: GO 79821
// end ;
79738: GO 79409
79740: POP
79741: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79742: LD_VAR 0 9
79746: PPUSH
79747: LD_VAR 0 3
79751: PPUSH
79752: LD_VAR 0 4
79756: PPUSH
79757: LD_INT 20
79759: PPUSH
79760: CALL 71767 0 4
79764: PUSH
79765: LD_INT 4
79767: ARRAY
79768: IFFALSE 79772
// exit ;
79770: GO 79821
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79772: LD_VAR 0 2
79776: PUSH
79777: LD_INT 29
79779: PUSH
79780: LD_INT 30
79782: PUSH
79783: EMPTY
79784: LIST
79785: LIST
79786: IN
79787: PUSH
79788: LD_VAR 0 3
79792: PPUSH
79793: LD_VAR 0 4
79797: PPUSH
79798: LD_VAR 0 9
79802: PPUSH
79803: CALL_OW 440
79807: NOT
79808: AND
79809: IFFALSE 79813
// exit ;
79811: GO 79821
// result := true ;
79813: LD_ADDR_VAR 0 6
79817: PUSH
79818: LD_INT 1
79820: ST_TO_ADDR
// end ;
79821: LD_VAR 0 6
79825: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
79826: LD_INT 0
79828: PPUSH
79829: PPUSH
79830: PPUSH
79831: PPUSH
79832: PPUSH
79833: PPUSH
79834: PPUSH
79835: PPUSH
79836: PPUSH
79837: PPUSH
79838: PPUSH
79839: PPUSH
79840: PPUSH
79841: PPUSH
79842: PPUSH
79843: PPUSH
79844: PPUSH
79845: PPUSH
79846: PPUSH
79847: PPUSH
79848: PPUSH
79849: PPUSH
79850: PPUSH
79851: PPUSH
79852: PPUSH
79853: PPUSH
79854: PPUSH
79855: PPUSH
79856: PPUSH
79857: PPUSH
79858: PPUSH
79859: PPUSH
79860: PPUSH
79861: PPUSH
79862: PPUSH
79863: PPUSH
79864: PPUSH
79865: PPUSH
79866: PPUSH
79867: PPUSH
79868: PPUSH
79869: PPUSH
79870: PPUSH
79871: PPUSH
79872: PPUSH
79873: PPUSH
79874: PPUSH
79875: PPUSH
79876: PPUSH
79877: PPUSH
79878: PPUSH
79879: PPUSH
79880: PPUSH
79881: PPUSH
79882: PPUSH
79883: PPUSH
79884: PPUSH
79885: PPUSH
// result = [ ] ;
79886: LD_ADDR_VAR 0 7
79890: PUSH
79891: EMPTY
79892: ST_TO_ADDR
// temp_list = [ ] ;
79893: LD_ADDR_VAR 0 9
79897: PUSH
79898: EMPTY
79899: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79900: LD_VAR 0 4
79904: PUSH
79905: LD_INT 0
79907: PUSH
79908: LD_INT 1
79910: PUSH
79911: LD_INT 2
79913: PUSH
79914: LD_INT 3
79916: PUSH
79917: LD_INT 4
79919: PUSH
79920: LD_INT 5
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: LIST
79929: LIST
79930: IN
79931: NOT
79932: PUSH
79933: LD_VAR 0 1
79937: PUSH
79938: LD_INT 0
79940: PUSH
79941: LD_INT 1
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: IN
79948: PUSH
79949: LD_VAR 0 5
79953: PUSH
79954: LD_INT 1
79956: PUSH
79957: LD_INT 2
79959: PUSH
79960: LD_INT 3
79962: PUSH
79963: EMPTY
79964: LIST
79965: LIST
79966: LIST
79967: IN
79968: NOT
79969: AND
79970: OR
79971: IFFALSE 79975
// exit ;
79973: GO 98366
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79975: LD_VAR 0 1
79979: PUSH
79980: LD_INT 6
79982: PUSH
79983: LD_INT 7
79985: PUSH
79986: LD_INT 8
79988: PUSH
79989: LD_INT 13
79991: PUSH
79992: LD_INT 12
79994: PUSH
79995: LD_INT 15
79997: PUSH
79998: LD_INT 11
80000: PUSH
80001: LD_INT 14
80003: PUSH
80004: LD_INT 10
80006: PUSH
80007: EMPTY
80008: LIST
80009: LIST
80010: LIST
80011: LIST
80012: LIST
80013: LIST
80014: LIST
80015: LIST
80016: LIST
80017: IN
80018: IFFALSE 80028
// btype = b_lab ;
80020: LD_ADDR_VAR 0 1
80024: PUSH
80025: LD_INT 6
80027: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
80028: LD_VAR 0 6
80032: PUSH
80033: LD_INT 0
80035: PUSH
80036: LD_INT 1
80038: PUSH
80039: LD_INT 2
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: LIST
80046: IN
80047: NOT
80048: PUSH
80049: LD_VAR 0 1
80053: PUSH
80054: LD_INT 0
80056: PUSH
80057: LD_INT 1
80059: PUSH
80060: LD_INT 2
80062: PUSH
80063: LD_INT 3
80065: PUSH
80066: LD_INT 6
80068: PUSH
80069: LD_INT 36
80071: PUSH
80072: LD_INT 4
80074: PUSH
80075: LD_INT 5
80077: PUSH
80078: LD_INT 31
80080: PUSH
80081: LD_INT 32
80083: PUSH
80084: LD_INT 33
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: IN
80100: NOT
80101: PUSH
80102: LD_VAR 0 6
80106: PUSH
80107: LD_INT 1
80109: EQUAL
80110: AND
80111: OR
80112: PUSH
80113: LD_VAR 0 1
80117: PUSH
80118: LD_INT 2
80120: PUSH
80121: LD_INT 3
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: IN
80128: NOT
80129: PUSH
80130: LD_VAR 0 6
80134: PUSH
80135: LD_INT 2
80137: EQUAL
80138: AND
80139: OR
80140: IFFALSE 80150
// mode = 0 ;
80142: LD_ADDR_VAR 0 6
80146: PUSH
80147: LD_INT 0
80149: ST_TO_ADDR
// case mode of 0 :
80150: LD_VAR 0 6
80154: PUSH
80155: LD_INT 0
80157: DOUBLE
80158: EQUAL
80159: IFTRUE 80163
80161: GO 91616
80163: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
80164: LD_ADDR_VAR 0 11
80168: PUSH
80169: LD_INT 0
80171: PUSH
80172: LD_INT 0
80174: PUSH
80175: EMPTY
80176: LIST
80177: LIST
80178: PUSH
80179: LD_INT 0
80181: PUSH
80182: LD_INT 1
80184: NEG
80185: PUSH
80186: EMPTY
80187: LIST
80188: LIST
80189: PUSH
80190: LD_INT 1
80192: PUSH
80193: LD_INT 0
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: PUSH
80200: LD_INT 1
80202: PUSH
80203: LD_INT 1
80205: PUSH
80206: EMPTY
80207: LIST
80208: LIST
80209: PUSH
80210: LD_INT 0
80212: PUSH
80213: LD_INT 1
80215: PUSH
80216: EMPTY
80217: LIST
80218: LIST
80219: PUSH
80220: LD_INT 1
80222: NEG
80223: PUSH
80224: LD_INT 0
80226: PUSH
80227: EMPTY
80228: LIST
80229: LIST
80230: PUSH
80231: LD_INT 1
80233: NEG
80234: PUSH
80235: LD_INT 1
80237: NEG
80238: PUSH
80239: EMPTY
80240: LIST
80241: LIST
80242: PUSH
80243: LD_INT 1
80245: NEG
80246: PUSH
80247: LD_INT 2
80249: NEG
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 0
80257: PUSH
80258: LD_INT 2
80260: NEG
80261: PUSH
80262: EMPTY
80263: LIST
80264: LIST
80265: PUSH
80266: LD_INT 1
80268: PUSH
80269: LD_INT 1
80271: NEG
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PUSH
80277: LD_INT 1
80279: PUSH
80280: LD_INT 2
80282: PUSH
80283: EMPTY
80284: LIST
80285: LIST
80286: PUSH
80287: LD_INT 0
80289: PUSH
80290: LD_INT 2
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 1
80299: NEG
80300: PUSH
80301: LD_INT 1
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: LD_INT 1
80310: PUSH
80311: LD_INT 3
80313: PUSH
80314: EMPTY
80315: LIST
80316: LIST
80317: PUSH
80318: LD_INT 0
80320: PUSH
80321: LD_INT 3
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 1
80330: NEG
80331: PUSH
80332: LD_INT 2
80334: PUSH
80335: EMPTY
80336: LIST
80337: LIST
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: LIST
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: LIST
80350: LIST
80351: LIST
80352: LIST
80353: LIST
80354: LIST
80355: LIST
80356: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
80357: LD_ADDR_VAR 0 12
80361: PUSH
80362: LD_INT 0
80364: PUSH
80365: LD_INT 0
80367: PUSH
80368: EMPTY
80369: LIST
80370: LIST
80371: PUSH
80372: LD_INT 0
80374: PUSH
80375: LD_INT 1
80377: NEG
80378: PUSH
80379: EMPTY
80380: LIST
80381: LIST
80382: PUSH
80383: LD_INT 1
80385: PUSH
80386: LD_INT 0
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: PUSH
80393: LD_INT 1
80395: PUSH
80396: LD_INT 1
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 0
80405: PUSH
80406: LD_INT 1
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 1
80415: NEG
80416: PUSH
80417: LD_INT 0
80419: PUSH
80420: EMPTY
80421: LIST
80422: LIST
80423: PUSH
80424: LD_INT 1
80426: NEG
80427: PUSH
80428: LD_INT 1
80430: NEG
80431: PUSH
80432: EMPTY
80433: LIST
80434: LIST
80435: PUSH
80436: LD_INT 1
80438: PUSH
80439: LD_INT 1
80441: NEG
80442: PUSH
80443: EMPTY
80444: LIST
80445: LIST
80446: PUSH
80447: LD_INT 2
80449: PUSH
80450: LD_INT 0
80452: PUSH
80453: EMPTY
80454: LIST
80455: LIST
80456: PUSH
80457: LD_INT 2
80459: PUSH
80460: LD_INT 1
80462: PUSH
80463: EMPTY
80464: LIST
80465: LIST
80466: PUSH
80467: LD_INT 1
80469: NEG
80470: PUSH
80471: LD_INT 1
80473: PUSH
80474: EMPTY
80475: LIST
80476: LIST
80477: PUSH
80478: LD_INT 2
80480: NEG
80481: PUSH
80482: LD_INT 0
80484: PUSH
80485: EMPTY
80486: LIST
80487: LIST
80488: PUSH
80489: LD_INT 2
80491: NEG
80492: PUSH
80493: LD_INT 1
80495: NEG
80496: PUSH
80497: EMPTY
80498: LIST
80499: LIST
80500: PUSH
80501: LD_INT 2
80503: NEG
80504: PUSH
80505: LD_INT 1
80507: PUSH
80508: EMPTY
80509: LIST
80510: LIST
80511: PUSH
80512: LD_INT 3
80514: NEG
80515: PUSH
80516: LD_INT 0
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 3
80525: NEG
80526: PUSH
80527: LD_INT 1
80529: NEG
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: EMPTY
80536: LIST
80537: LIST
80538: LIST
80539: LIST
80540: LIST
80541: LIST
80542: LIST
80543: LIST
80544: LIST
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: LIST
80552: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80553: LD_ADDR_VAR 0 13
80557: PUSH
80558: LD_INT 0
80560: PUSH
80561: LD_INT 0
80563: PUSH
80564: EMPTY
80565: LIST
80566: LIST
80567: PUSH
80568: LD_INT 0
80570: PUSH
80571: LD_INT 1
80573: NEG
80574: PUSH
80575: EMPTY
80576: LIST
80577: LIST
80578: PUSH
80579: LD_INT 1
80581: PUSH
80582: LD_INT 0
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: PUSH
80589: LD_INT 1
80591: PUSH
80592: LD_INT 1
80594: PUSH
80595: EMPTY
80596: LIST
80597: LIST
80598: PUSH
80599: LD_INT 0
80601: PUSH
80602: LD_INT 1
80604: PUSH
80605: EMPTY
80606: LIST
80607: LIST
80608: PUSH
80609: LD_INT 1
80611: NEG
80612: PUSH
80613: LD_INT 0
80615: PUSH
80616: EMPTY
80617: LIST
80618: LIST
80619: PUSH
80620: LD_INT 1
80622: NEG
80623: PUSH
80624: LD_INT 1
80626: NEG
80627: PUSH
80628: EMPTY
80629: LIST
80630: LIST
80631: PUSH
80632: LD_INT 1
80634: NEG
80635: PUSH
80636: LD_INT 2
80638: NEG
80639: PUSH
80640: EMPTY
80641: LIST
80642: LIST
80643: PUSH
80644: LD_INT 2
80646: PUSH
80647: LD_INT 1
80649: PUSH
80650: EMPTY
80651: LIST
80652: LIST
80653: PUSH
80654: LD_INT 2
80656: PUSH
80657: LD_INT 2
80659: PUSH
80660: EMPTY
80661: LIST
80662: LIST
80663: PUSH
80664: LD_INT 1
80666: PUSH
80667: LD_INT 2
80669: PUSH
80670: EMPTY
80671: LIST
80672: LIST
80673: PUSH
80674: LD_INT 2
80676: NEG
80677: PUSH
80678: LD_INT 1
80680: NEG
80681: PUSH
80682: EMPTY
80683: LIST
80684: LIST
80685: PUSH
80686: LD_INT 2
80688: NEG
80689: PUSH
80690: LD_INT 2
80692: NEG
80693: PUSH
80694: EMPTY
80695: LIST
80696: LIST
80697: PUSH
80698: LD_INT 2
80700: NEG
80701: PUSH
80702: LD_INT 3
80704: NEG
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: PUSH
80710: LD_INT 3
80712: NEG
80713: PUSH
80714: LD_INT 2
80716: NEG
80717: PUSH
80718: EMPTY
80719: LIST
80720: LIST
80721: PUSH
80722: LD_INT 3
80724: NEG
80725: PUSH
80726: LD_INT 3
80728: NEG
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: LIST
80738: LIST
80739: LIST
80740: LIST
80741: LIST
80742: LIST
80743: LIST
80744: LIST
80745: LIST
80746: LIST
80747: LIST
80748: LIST
80749: LIST
80750: LIST
80751: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80752: LD_ADDR_VAR 0 14
80756: PUSH
80757: LD_INT 0
80759: PUSH
80760: LD_INT 0
80762: PUSH
80763: EMPTY
80764: LIST
80765: LIST
80766: PUSH
80767: LD_INT 0
80769: PUSH
80770: LD_INT 1
80772: NEG
80773: PUSH
80774: EMPTY
80775: LIST
80776: LIST
80777: PUSH
80778: LD_INT 1
80780: PUSH
80781: LD_INT 0
80783: PUSH
80784: EMPTY
80785: LIST
80786: LIST
80787: PUSH
80788: LD_INT 1
80790: PUSH
80791: LD_INT 1
80793: PUSH
80794: EMPTY
80795: LIST
80796: LIST
80797: PUSH
80798: LD_INT 0
80800: PUSH
80801: LD_INT 1
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PUSH
80808: LD_INT 1
80810: NEG
80811: PUSH
80812: LD_INT 0
80814: PUSH
80815: EMPTY
80816: LIST
80817: LIST
80818: PUSH
80819: LD_INT 1
80821: NEG
80822: PUSH
80823: LD_INT 1
80825: NEG
80826: PUSH
80827: EMPTY
80828: LIST
80829: LIST
80830: PUSH
80831: LD_INT 1
80833: NEG
80834: PUSH
80835: LD_INT 2
80837: NEG
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 0
80845: PUSH
80846: LD_INT 2
80848: NEG
80849: PUSH
80850: EMPTY
80851: LIST
80852: LIST
80853: PUSH
80854: LD_INT 1
80856: PUSH
80857: LD_INT 1
80859: NEG
80860: PUSH
80861: EMPTY
80862: LIST
80863: LIST
80864: PUSH
80865: LD_INT 1
80867: PUSH
80868: LD_INT 2
80870: PUSH
80871: EMPTY
80872: LIST
80873: LIST
80874: PUSH
80875: LD_INT 0
80877: PUSH
80878: LD_INT 2
80880: PUSH
80881: EMPTY
80882: LIST
80883: LIST
80884: PUSH
80885: LD_INT 1
80887: NEG
80888: PUSH
80889: LD_INT 1
80891: PUSH
80892: EMPTY
80893: LIST
80894: LIST
80895: PUSH
80896: LD_INT 1
80898: NEG
80899: PUSH
80900: LD_INT 3
80902: NEG
80903: PUSH
80904: EMPTY
80905: LIST
80906: LIST
80907: PUSH
80908: LD_INT 0
80910: PUSH
80911: LD_INT 3
80913: NEG
80914: PUSH
80915: EMPTY
80916: LIST
80917: LIST
80918: PUSH
80919: LD_INT 1
80921: PUSH
80922: LD_INT 2
80924: NEG
80925: PUSH
80926: EMPTY
80927: LIST
80928: LIST
80929: PUSH
80930: EMPTY
80931: LIST
80932: LIST
80933: LIST
80934: LIST
80935: LIST
80936: LIST
80937: LIST
80938: LIST
80939: LIST
80940: LIST
80941: LIST
80942: LIST
80943: LIST
80944: LIST
80945: LIST
80946: LIST
80947: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80948: LD_ADDR_VAR 0 15
80952: PUSH
80953: LD_INT 0
80955: PUSH
80956: LD_INT 0
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: PUSH
80963: LD_INT 0
80965: PUSH
80966: LD_INT 1
80968: NEG
80969: PUSH
80970: EMPTY
80971: LIST
80972: LIST
80973: PUSH
80974: LD_INT 1
80976: PUSH
80977: LD_INT 0
80979: PUSH
80980: EMPTY
80981: LIST
80982: LIST
80983: PUSH
80984: LD_INT 1
80986: PUSH
80987: LD_INT 1
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 0
80996: PUSH
80997: LD_INT 1
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: PUSH
81004: LD_INT 1
81006: NEG
81007: PUSH
81008: LD_INT 0
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 1
81017: NEG
81018: PUSH
81019: LD_INT 1
81021: NEG
81022: PUSH
81023: EMPTY
81024: LIST
81025: LIST
81026: PUSH
81027: LD_INT 1
81029: PUSH
81030: LD_INT 1
81032: NEG
81033: PUSH
81034: EMPTY
81035: LIST
81036: LIST
81037: PUSH
81038: LD_INT 2
81040: PUSH
81041: LD_INT 0
81043: PUSH
81044: EMPTY
81045: LIST
81046: LIST
81047: PUSH
81048: LD_INT 2
81050: PUSH
81051: LD_INT 1
81053: PUSH
81054: EMPTY
81055: LIST
81056: LIST
81057: PUSH
81058: LD_INT 1
81060: NEG
81061: PUSH
81062: LD_INT 1
81064: PUSH
81065: EMPTY
81066: LIST
81067: LIST
81068: PUSH
81069: LD_INT 2
81071: NEG
81072: PUSH
81073: LD_INT 0
81075: PUSH
81076: EMPTY
81077: LIST
81078: LIST
81079: PUSH
81080: LD_INT 2
81082: NEG
81083: PUSH
81084: LD_INT 1
81086: NEG
81087: PUSH
81088: EMPTY
81089: LIST
81090: LIST
81091: PUSH
81092: LD_INT 2
81094: PUSH
81095: LD_INT 1
81097: NEG
81098: PUSH
81099: EMPTY
81100: LIST
81101: LIST
81102: PUSH
81103: LD_INT 3
81105: PUSH
81106: LD_INT 0
81108: PUSH
81109: EMPTY
81110: LIST
81111: LIST
81112: PUSH
81113: LD_INT 3
81115: PUSH
81116: LD_INT 1
81118: PUSH
81119: EMPTY
81120: LIST
81121: LIST
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: LIST
81127: LIST
81128: LIST
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: LIST
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
81141: LD_ADDR_VAR 0 16
81145: PUSH
81146: LD_INT 0
81148: PUSH
81149: LD_INT 0
81151: PUSH
81152: EMPTY
81153: LIST
81154: LIST
81155: PUSH
81156: LD_INT 0
81158: PUSH
81159: LD_INT 1
81161: NEG
81162: PUSH
81163: EMPTY
81164: LIST
81165: LIST
81166: PUSH
81167: LD_INT 1
81169: PUSH
81170: LD_INT 0
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PUSH
81177: LD_INT 1
81179: PUSH
81180: LD_INT 1
81182: PUSH
81183: EMPTY
81184: LIST
81185: LIST
81186: PUSH
81187: LD_INT 0
81189: PUSH
81190: LD_INT 1
81192: PUSH
81193: EMPTY
81194: LIST
81195: LIST
81196: PUSH
81197: LD_INT 1
81199: NEG
81200: PUSH
81201: LD_INT 0
81203: PUSH
81204: EMPTY
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 1
81210: NEG
81211: PUSH
81212: LD_INT 1
81214: NEG
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 1
81222: NEG
81223: PUSH
81224: LD_INT 2
81226: NEG
81227: PUSH
81228: EMPTY
81229: LIST
81230: LIST
81231: PUSH
81232: LD_INT 2
81234: PUSH
81235: LD_INT 1
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_INT 2
81244: PUSH
81245: LD_INT 2
81247: PUSH
81248: EMPTY
81249: LIST
81250: LIST
81251: PUSH
81252: LD_INT 1
81254: PUSH
81255: LD_INT 2
81257: PUSH
81258: EMPTY
81259: LIST
81260: LIST
81261: PUSH
81262: LD_INT 2
81264: NEG
81265: PUSH
81266: LD_INT 1
81268: NEG
81269: PUSH
81270: EMPTY
81271: LIST
81272: LIST
81273: PUSH
81274: LD_INT 2
81276: NEG
81277: PUSH
81278: LD_INT 2
81280: NEG
81281: PUSH
81282: EMPTY
81283: LIST
81284: LIST
81285: PUSH
81286: LD_INT 3
81288: PUSH
81289: LD_INT 2
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 3
81298: PUSH
81299: LD_INT 3
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: PUSH
81306: LD_INT 2
81308: PUSH
81309: LD_INT 3
81311: PUSH
81312: EMPTY
81313: LIST
81314: LIST
81315: PUSH
81316: EMPTY
81317: LIST
81318: LIST
81319: LIST
81320: LIST
81321: LIST
81322: LIST
81323: LIST
81324: LIST
81325: LIST
81326: LIST
81327: LIST
81328: LIST
81329: LIST
81330: LIST
81331: LIST
81332: LIST
81333: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81334: LD_ADDR_VAR 0 17
81338: PUSH
81339: LD_INT 0
81341: PUSH
81342: LD_INT 0
81344: PUSH
81345: EMPTY
81346: LIST
81347: LIST
81348: PUSH
81349: LD_INT 0
81351: PUSH
81352: LD_INT 1
81354: NEG
81355: PUSH
81356: EMPTY
81357: LIST
81358: LIST
81359: PUSH
81360: LD_INT 1
81362: PUSH
81363: LD_INT 0
81365: PUSH
81366: EMPTY
81367: LIST
81368: LIST
81369: PUSH
81370: LD_INT 1
81372: PUSH
81373: LD_INT 1
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: PUSH
81380: LD_INT 0
81382: PUSH
81383: LD_INT 1
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: PUSH
81390: LD_INT 1
81392: NEG
81393: PUSH
81394: LD_INT 0
81396: PUSH
81397: EMPTY
81398: LIST
81399: LIST
81400: PUSH
81401: LD_INT 1
81403: NEG
81404: PUSH
81405: LD_INT 1
81407: NEG
81408: PUSH
81409: EMPTY
81410: LIST
81411: LIST
81412: PUSH
81413: LD_INT 1
81415: NEG
81416: PUSH
81417: LD_INT 2
81419: NEG
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: LD_INT 0
81427: PUSH
81428: LD_INT 2
81430: NEG
81431: PUSH
81432: EMPTY
81433: LIST
81434: LIST
81435: PUSH
81436: LD_INT 1
81438: PUSH
81439: LD_INT 1
81441: NEG
81442: PUSH
81443: EMPTY
81444: LIST
81445: LIST
81446: PUSH
81447: LD_INT 2
81449: PUSH
81450: LD_INT 0
81452: PUSH
81453: EMPTY
81454: LIST
81455: LIST
81456: PUSH
81457: LD_INT 2
81459: PUSH
81460: LD_INT 1
81462: PUSH
81463: EMPTY
81464: LIST
81465: LIST
81466: PUSH
81467: LD_INT 2
81469: PUSH
81470: LD_INT 2
81472: PUSH
81473: EMPTY
81474: LIST
81475: LIST
81476: PUSH
81477: LD_INT 1
81479: PUSH
81480: LD_INT 2
81482: PUSH
81483: EMPTY
81484: LIST
81485: LIST
81486: PUSH
81487: LD_INT 0
81489: PUSH
81490: LD_INT 2
81492: PUSH
81493: EMPTY
81494: LIST
81495: LIST
81496: PUSH
81497: LD_INT 1
81499: NEG
81500: PUSH
81501: LD_INT 1
81503: PUSH
81504: EMPTY
81505: LIST
81506: LIST
81507: PUSH
81508: LD_INT 2
81510: NEG
81511: PUSH
81512: LD_INT 0
81514: PUSH
81515: EMPTY
81516: LIST
81517: LIST
81518: PUSH
81519: LD_INT 2
81521: NEG
81522: PUSH
81523: LD_INT 1
81525: NEG
81526: PUSH
81527: EMPTY
81528: LIST
81529: LIST
81530: PUSH
81531: LD_INT 2
81533: NEG
81534: PUSH
81535: LD_INT 2
81537: NEG
81538: PUSH
81539: EMPTY
81540: LIST
81541: LIST
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: LIST
81556: LIST
81557: LIST
81558: LIST
81559: LIST
81560: LIST
81561: LIST
81562: LIST
81563: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81564: LD_ADDR_VAR 0 18
81568: PUSH
81569: LD_INT 0
81571: PUSH
81572: LD_INT 0
81574: PUSH
81575: EMPTY
81576: LIST
81577: LIST
81578: PUSH
81579: LD_INT 0
81581: PUSH
81582: LD_INT 1
81584: NEG
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: PUSH
81590: LD_INT 1
81592: PUSH
81593: LD_INT 0
81595: PUSH
81596: EMPTY
81597: LIST
81598: LIST
81599: PUSH
81600: LD_INT 1
81602: PUSH
81603: LD_INT 1
81605: PUSH
81606: EMPTY
81607: LIST
81608: LIST
81609: PUSH
81610: LD_INT 0
81612: PUSH
81613: LD_INT 1
81615: PUSH
81616: EMPTY
81617: LIST
81618: LIST
81619: PUSH
81620: LD_INT 1
81622: NEG
81623: PUSH
81624: LD_INT 0
81626: PUSH
81627: EMPTY
81628: LIST
81629: LIST
81630: PUSH
81631: LD_INT 1
81633: NEG
81634: PUSH
81635: LD_INT 1
81637: NEG
81638: PUSH
81639: EMPTY
81640: LIST
81641: LIST
81642: PUSH
81643: LD_INT 1
81645: NEG
81646: PUSH
81647: LD_INT 2
81649: NEG
81650: PUSH
81651: EMPTY
81652: LIST
81653: LIST
81654: PUSH
81655: LD_INT 0
81657: PUSH
81658: LD_INT 2
81660: NEG
81661: PUSH
81662: EMPTY
81663: LIST
81664: LIST
81665: PUSH
81666: LD_INT 1
81668: PUSH
81669: LD_INT 1
81671: NEG
81672: PUSH
81673: EMPTY
81674: LIST
81675: LIST
81676: PUSH
81677: LD_INT 2
81679: PUSH
81680: LD_INT 0
81682: PUSH
81683: EMPTY
81684: LIST
81685: LIST
81686: PUSH
81687: LD_INT 2
81689: PUSH
81690: LD_INT 1
81692: PUSH
81693: EMPTY
81694: LIST
81695: LIST
81696: PUSH
81697: LD_INT 2
81699: PUSH
81700: LD_INT 2
81702: PUSH
81703: EMPTY
81704: LIST
81705: LIST
81706: PUSH
81707: LD_INT 1
81709: PUSH
81710: LD_INT 2
81712: PUSH
81713: EMPTY
81714: LIST
81715: LIST
81716: PUSH
81717: LD_INT 0
81719: PUSH
81720: LD_INT 2
81722: PUSH
81723: EMPTY
81724: LIST
81725: LIST
81726: PUSH
81727: LD_INT 1
81729: NEG
81730: PUSH
81731: LD_INT 1
81733: PUSH
81734: EMPTY
81735: LIST
81736: LIST
81737: PUSH
81738: LD_INT 2
81740: NEG
81741: PUSH
81742: LD_INT 0
81744: PUSH
81745: EMPTY
81746: LIST
81747: LIST
81748: PUSH
81749: LD_INT 2
81751: NEG
81752: PUSH
81753: LD_INT 1
81755: NEG
81756: PUSH
81757: EMPTY
81758: LIST
81759: LIST
81760: PUSH
81761: LD_INT 2
81763: NEG
81764: PUSH
81765: LD_INT 2
81767: NEG
81768: PUSH
81769: EMPTY
81770: LIST
81771: LIST
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: LIST
81777: LIST
81778: LIST
81779: LIST
81780: LIST
81781: LIST
81782: LIST
81783: LIST
81784: LIST
81785: LIST
81786: LIST
81787: LIST
81788: LIST
81789: LIST
81790: LIST
81791: LIST
81792: LIST
81793: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81794: LD_ADDR_VAR 0 19
81798: PUSH
81799: LD_INT 0
81801: PUSH
81802: LD_INT 0
81804: PUSH
81805: EMPTY
81806: LIST
81807: LIST
81808: PUSH
81809: LD_INT 0
81811: PUSH
81812: LD_INT 1
81814: NEG
81815: PUSH
81816: EMPTY
81817: LIST
81818: LIST
81819: PUSH
81820: LD_INT 1
81822: PUSH
81823: LD_INT 0
81825: PUSH
81826: EMPTY
81827: LIST
81828: LIST
81829: PUSH
81830: LD_INT 1
81832: PUSH
81833: LD_INT 1
81835: PUSH
81836: EMPTY
81837: LIST
81838: LIST
81839: PUSH
81840: LD_INT 0
81842: PUSH
81843: LD_INT 1
81845: PUSH
81846: EMPTY
81847: LIST
81848: LIST
81849: PUSH
81850: LD_INT 1
81852: NEG
81853: PUSH
81854: LD_INT 0
81856: PUSH
81857: EMPTY
81858: LIST
81859: LIST
81860: PUSH
81861: LD_INT 1
81863: NEG
81864: PUSH
81865: LD_INT 1
81867: NEG
81868: PUSH
81869: EMPTY
81870: LIST
81871: LIST
81872: PUSH
81873: LD_INT 1
81875: NEG
81876: PUSH
81877: LD_INT 2
81879: NEG
81880: PUSH
81881: EMPTY
81882: LIST
81883: LIST
81884: PUSH
81885: LD_INT 0
81887: PUSH
81888: LD_INT 2
81890: NEG
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: PUSH
81896: LD_INT 1
81898: PUSH
81899: LD_INT 1
81901: NEG
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: PUSH
81907: LD_INT 2
81909: PUSH
81910: LD_INT 0
81912: PUSH
81913: EMPTY
81914: LIST
81915: LIST
81916: PUSH
81917: LD_INT 2
81919: PUSH
81920: LD_INT 1
81922: PUSH
81923: EMPTY
81924: LIST
81925: LIST
81926: PUSH
81927: LD_INT 2
81929: PUSH
81930: LD_INT 2
81932: PUSH
81933: EMPTY
81934: LIST
81935: LIST
81936: PUSH
81937: LD_INT 1
81939: PUSH
81940: LD_INT 2
81942: PUSH
81943: EMPTY
81944: LIST
81945: LIST
81946: PUSH
81947: LD_INT 0
81949: PUSH
81950: LD_INT 2
81952: PUSH
81953: EMPTY
81954: LIST
81955: LIST
81956: PUSH
81957: LD_INT 1
81959: NEG
81960: PUSH
81961: LD_INT 1
81963: PUSH
81964: EMPTY
81965: LIST
81966: LIST
81967: PUSH
81968: LD_INT 2
81970: NEG
81971: PUSH
81972: LD_INT 0
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PUSH
81979: LD_INT 2
81981: NEG
81982: PUSH
81983: LD_INT 1
81985: NEG
81986: PUSH
81987: EMPTY
81988: LIST
81989: LIST
81990: PUSH
81991: LD_INT 2
81993: NEG
81994: PUSH
81995: LD_INT 2
81997: NEG
81998: PUSH
81999: EMPTY
82000: LIST
82001: LIST
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: LIST
82007: LIST
82008: LIST
82009: LIST
82010: LIST
82011: LIST
82012: LIST
82013: LIST
82014: LIST
82015: LIST
82016: LIST
82017: LIST
82018: LIST
82019: LIST
82020: LIST
82021: LIST
82022: LIST
82023: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82024: LD_ADDR_VAR 0 20
82028: PUSH
82029: LD_INT 0
82031: PUSH
82032: LD_INT 0
82034: PUSH
82035: EMPTY
82036: LIST
82037: LIST
82038: PUSH
82039: LD_INT 0
82041: PUSH
82042: LD_INT 1
82044: NEG
82045: PUSH
82046: EMPTY
82047: LIST
82048: LIST
82049: PUSH
82050: LD_INT 1
82052: PUSH
82053: LD_INT 0
82055: PUSH
82056: EMPTY
82057: LIST
82058: LIST
82059: PUSH
82060: LD_INT 1
82062: PUSH
82063: LD_INT 1
82065: PUSH
82066: EMPTY
82067: LIST
82068: LIST
82069: PUSH
82070: LD_INT 0
82072: PUSH
82073: LD_INT 1
82075: PUSH
82076: EMPTY
82077: LIST
82078: LIST
82079: PUSH
82080: LD_INT 1
82082: NEG
82083: PUSH
82084: LD_INT 0
82086: PUSH
82087: EMPTY
82088: LIST
82089: LIST
82090: PUSH
82091: LD_INT 1
82093: NEG
82094: PUSH
82095: LD_INT 1
82097: NEG
82098: PUSH
82099: EMPTY
82100: LIST
82101: LIST
82102: PUSH
82103: LD_INT 1
82105: NEG
82106: PUSH
82107: LD_INT 2
82109: NEG
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: PUSH
82115: LD_INT 0
82117: PUSH
82118: LD_INT 2
82120: NEG
82121: PUSH
82122: EMPTY
82123: LIST
82124: LIST
82125: PUSH
82126: LD_INT 1
82128: PUSH
82129: LD_INT 1
82131: NEG
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 2
82139: PUSH
82140: LD_INT 0
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: LD_INT 2
82149: PUSH
82150: LD_INT 1
82152: PUSH
82153: EMPTY
82154: LIST
82155: LIST
82156: PUSH
82157: LD_INT 2
82159: PUSH
82160: LD_INT 2
82162: PUSH
82163: EMPTY
82164: LIST
82165: LIST
82166: PUSH
82167: LD_INT 1
82169: PUSH
82170: LD_INT 2
82172: PUSH
82173: EMPTY
82174: LIST
82175: LIST
82176: PUSH
82177: LD_INT 0
82179: PUSH
82180: LD_INT 2
82182: PUSH
82183: EMPTY
82184: LIST
82185: LIST
82186: PUSH
82187: LD_INT 1
82189: NEG
82190: PUSH
82191: LD_INT 1
82193: PUSH
82194: EMPTY
82195: LIST
82196: LIST
82197: PUSH
82198: LD_INT 2
82200: NEG
82201: PUSH
82202: LD_INT 0
82204: PUSH
82205: EMPTY
82206: LIST
82207: LIST
82208: PUSH
82209: LD_INT 2
82211: NEG
82212: PUSH
82213: LD_INT 1
82215: NEG
82216: PUSH
82217: EMPTY
82218: LIST
82219: LIST
82220: PUSH
82221: LD_INT 2
82223: NEG
82224: PUSH
82225: LD_INT 2
82227: NEG
82228: PUSH
82229: EMPTY
82230: LIST
82231: LIST
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: LIST
82240: LIST
82241: LIST
82242: LIST
82243: LIST
82244: LIST
82245: LIST
82246: LIST
82247: LIST
82248: LIST
82249: LIST
82250: LIST
82251: LIST
82252: LIST
82253: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82254: LD_ADDR_VAR 0 21
82258: PUSH
82259: LD_INT 0
82261: PUSH
82262: LD_INT 0
82264: PUSH
82265: EMPTY
82266: LIST
82267: LIST
82268: PUSH
82269: LD_INT 0
82271: PUSH
82272: LD_INT 1
82274: NEG
82275: PUSH
82276: EMPTY
82277: LIST
82278: LIST
82279: PUSH
82280: LD_INT 1
82282: PUSH
82283: LD_INT 0
82285: PUSH
82286: EMPTY
82287: LIST
82288: LIST
82289: PUSH
82290: LD_INT 1
82292: PUSH
82293: LD_INT 1
82295: PUSH
82296: EMPTY
82297: LIST
82298: LIST
82299: PUSH
82300: LD_INT 0
82302: PUSH
82303: LD_INT 1
82305: PUSH
82306: EMPTY
82307: LIST
82308: LIST
82309: PUSH
82310: LD_INT 1
82312: NEG
82313: PUSH
82314: LD_INT 0
82316: PUSH
82317: EMPTY
82318: LIST
82319: LIST
82320: PUSH
82321: LD_INT 1
82323: NEG
82324: PUSH
82325: LD_INT 1
82327: NEG
82328: PUSH
82329: EMPTY
82330: LIST
82331: LIST
82332: PUSH
82333: LD_INT 1
82335: NEG
82336: PUSH
82337: LD_INT 2
82339: NEG
82340: PUSH
82341: EMPTY
82342: LIST
82343: LIST
82344: PUSH
82345: LD_INT 0
82347: PUSH
82348: LD_INT 2
82350: NEG
82351: PUSH
82352: EMPTY
82353: LIST
82354: LIST
82355: PUSH
82356: LD_INT 1
82358: PUSH
82359: LD_INT 1
82361: NEG
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: PUSH
82367: LD_INT 2
82369: PUSH
82370: LD_INT 0
82372: PUSH
82373: EMPTY
82374: LIST
82375: LIST
82376: PUSH
82377: LD_INT 2
82379: PUSH
82380: LD_INT 1
82382: PUSH
82383: EMPTY
82384: LIST
82385: LIST
82386: PUSH
82387: LD_INT 2
82389: PUSH
82390: LD_INT 2
82392: PUSH
82393: EMPTY
82394: LIST
82395: LIST
82396: PUSH
82397: LD_INT 1
82399: PUSH
82400: LD_INT 2
82402: PUSH
82403: EMPTY
82404: LIST
82405: LIST
82406: PUSH
82407: LD_INT 0
82409: PUSH
82410: LD_INT 2
82412: PUSH
82413: EMPTY
82414: LIST
82415: LIST
82416: PUSH
82417: LD_INT 1
82419: NEG
82420: PUSH
82421: LD_INT 1
82423: PUSH
82424: EMPTY
82425: LIST
82426: LIST
82427: PUSH
82428: LD_INT 2
82430: NEG
82431: PUSH
82432: LD_INT 0
82434: PUSH
82435: EMPTY
82436: LIST
82437: LIST
82438: PUSH
82439: LD_INT 2
82441: NEG
82442: PUSH
82443: LD_INT 1
82445: NEG
82446: PUSH
82447: EMPTY
82448: LIST
82449: LIST
82450: PUSH
82451: LD_INT 2
82453: NEG
82454: PUSH
82455: LD_INT 2
82457: NEG
82458: PUSH
82459: EMPTY
82460: LIST
82461: LIST
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: LIST
82467: LIST
82468: LIST
82469: LIST
82470: LIST
82471: LIST
82472: LIST
82473: LIST
82474: LIST
82475: LIST
82476: LIST
82477: LIST
82478: LIST
82479: LIST
82480: LIST
82481: LIST
82482: LIST
82483: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82484: LD_ADDR_VAR 0 22
82488: PUSH
82489: LD_INT 0
82491: PUSH
82492: LD_INT 0
82494: PUSH
82495: EMPTY
82496: LIST
82497: LIST
82498: PUSH
82499: LD_INT 0
82501: PUSH
82502: LD_INT 1
82504: NEG
82505: PUSH
82506: EMPTY
82507: LIST
82508: LIST
82509: PUSH
82510: LD_INT 1
82512: PUSH
82513: LD_INT 0
82515: PUSH
82516: EMPTY
82517: LIST
82518: LIST
82519: PUSH
82520: LD_INT 1
82522: PUSH
82523: LD_INT 1
82525: PUSH
82526: EMPTY
82527: LIST
82528: LIST
82529: PUSH
82530: LD_INT 0
82532: PUSH
82533: LD_INT 1
82535: PUSH
82536: EMPTY
82537: LIST
82538: LIST
82539: PUSH
82540: LD_INT 1
82542: NEG
82543: PUSH
82544: LD_INT 0
82546: PUSH
82547: EMPTY
82548: LIST
82549: LIST
82550: PUSH
82551: LD_INT 1
82553: NEG
82554: PUSH
82555: LD_INT 1
82557: NEG
82558: PUSH
82559: EMPTY
82560: LIST
82561: LIST
82562: PUSH
82563: LD_INT 1
82565: NEG
82566: PUSH
82567: LD_INT 2
82569: NEG
82570: PUSH
82571: EMPTY
82572: LIST
82573: LIST
82574: PUSH
82575: LD_INT 0
82577: PUSH
82578: LD_INT 2
82580: NEG
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: LD_INT 1
82588: PUSH
82589: LD_INT 1
82591: NEG
82592: PUSH
82593: EMPTY
82594: LIST
82595: LIST
82596: PUSH
82597: LD_INT 2
82599: PUSH
82600: LD_INT 0
82602: PUSH
82603: EMPTY
82604: LIST
82605: LIST
82606: PUSH
82607: LD_INT 2
82609: PUSH
82610: LD_INT 1
82612: PUSH
82613: EMPTY
82614: LIST
82615: LIST
82616: PUSH
82617: LD_INT 2
82619: PUSH
82620: LD_INT 2
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_INT 1
82629: PUSH
82630: LD_INT 2
82632: PUSH
82633: EMPTY
82634: LIST
82635: LIST
82636: PUSH
82637: LD_INT 0
82639: PUSH
82640: LD_INT 2
82642: PUSH
82643: EMPTY
82644: LIST
82645: LIST
82646: PUSH
82647: LD_INT 1
82649: NEG
82650: PUSH
82651: LD_INT 1
82653: PUSH
82654: EMPTY
82655: LIST
82656: LIST
82657: PUSH
82658: LD_INT 2
82660: NEG
82661: PUSH
82662: LD_INT 0
82664: PUSH
82665: EMPTY
82666: LIST
82667: LIST
82668: PUSH
82669: LD_INT 2
82671: NEG
82672: PUSH
82673: LD_INT 1
82675: NEG
82676: PUSH
82677: EMPTY
82678: LIST
82679: LIST
82680: PUSH
82681: LD_INT 2
82683: NEG
82684: PUSH
82685: LD_INT 2
82687: NEG
82688: PUSH
82689: EMPTY
82690: LIST
82691: LIST
82692: PUSH
82693: EMPTY
82694: LIST
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: LIST
82710: LIST
82711: LIST
82712: LIST
82713: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82714: LD_ADDR_VAR 0 23
82718: PUSH
82719: LD_INT 0
82721: PUSH
82722: LD_INT 0
82724: PUSH
82725: EMPTY
82726: LIST
82727: LIST
82728: PUSH
82729: LD_INT 0
82731: PUSH
82732: LD_INT 1
82734: NEG
82735: PUSH
82736: EMPTY
82737: LIST
82738: LIST
82739: PUSH
82740: LD_INT 1
82742: PUSH
82743: LD_INT 0
82745: PUSH
82746: EMPTY
82747: LIST
82748: LIST
82749: PUSH
82750: LD_INT 1
82752: PUSH
82753: LD_INT 1
82755: PUSH
82756: EMPTY
82757: LIST
82758: LIST
82759: PUSH
82760: LD_INT 0
82762: PUSH
82763: LD_INT 1
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PUSH
82770: LD_INT 1
82772: NEG
82773: PUSH
82774: LD_INT 0
82776: PUSH
82777: EMPTY
82778: LIST
82779: LIST
82780: PUSH
82781: LD_INT 1
82783: NEG
82784: PUSH
82785: LD_INT 1
82787: NEG
82788: PUSH
82789: EMPTY
82790: LIST
82791: LIST
82792: PUSH
82793: LD_INT 1
82795: NEG
82796: PUSH
82797: LD_INT 2
82799: NEG
82800: PUSH
82801: EMPTY
82802: LIST
82803: LIST
82804: PUSH
82805: LD_INT 0
82807: PUSH
82808: LD_INT 2
82810: NEG
82811: PUSH
82812: EMPTY
82813: LIST
82814: LIST
82815: PUSH
82816: LD_INT 1
82818: PUSH
82819: LD_INT 1
82821: NEG
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: LD_INT 2
82829: PUSH
82830: LD_INT 0
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: LD_INT 2
82839: PUSH
82840: LD_INT 1
82842: PUSH
82843: EMPTY
82844: LIST
82845: LIST
82846: PUSH
82847: LD_INT 2
82849: PUSH
82850: LD_INT 2
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 1
82859: PUSH
82860: LD_INT 2
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 0
82869: PUSH
82870: LD_INT 2
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 1
82879: NEG
82880: PUSH
82881: LD_INT 1
82883: PUSH
82884: EMPTY
82885: LIST
82886: LIST
82887: PUSH
82888: LD_INT 2
82890: NEG
82891: PUSH
82892: LD_INT 0
82894: PUSH
82895: EMPTY
82896: LIST
82897: LIST
82898: PUSH
82899: LD_INT 2
82901: NEG
82902: PUSH
82903: LD_INT 1
82905: NEG
82906: PUSH
82907: EMPTY
82908: LIST
82909: LIST
82910: PUSH
82911: LD_INT 2
82913: NEG
82914: PUSH
82915: LD_INT 2
82917: NEG
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: PUSH
82923: LD_INT 2
82925: NEG
82926: PUSH
82927: LD_INT 3
82929: NEG
82930: PUSH
82931: EMPTY
82932: LIST
82933: LIST
82934: PUSH
82935: LD_INT 1
82937: NEG
82938: PUSH
82939: LD_INT 3
82941: NEG
82942: PUSH
82943: EMPTY
82944: LIST
82945: LIST
82946: PUSH
82947: LD_INT 1
82949: PUSH
82950: LD_INT 2
82952: NEG
82953: PUSH
82954: EMPTY
82955: LIST
82956: LIST
82957: PUSH
82958: LD_INT 2
82960: PUSH
82961: LD_INT 1
82963: NEG
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: PUSH
82969: EMPTY
82970: LIST
82971: LIST
82972: LIST
82973: LIST
82974: LIST
82975: LIST
82976: LIST
82977: LIST
82978: LIST
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82994: LD_ADDR_VAR 0 24
82998: PUSH
82999: LD_INT 0
83001: PUSH
83002: LD_INT 0
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: PUSH
83009: LD_INT 0
83011: PUSH
83012: LD_INT 1
83014: NEG
83015: PUSH
83016: EMPTY
83017: LIST
83018: LIST
83019: PUSH
83020: LD_INT 1
83022: PUSH
83023: LD_INT 0
83025: PUSH
83026: EMPTY
83027: LIST
83028: LIST
83029: PUSH
83030: LD_INT 1
83032: PUSH
83033: LD_INT 1
83035: PUSH
83036: EMPTY
83037: LIST
83038: LIST
83039: PUSH
83040: LD_INT 0
83042: PUSH
83043: LD_INT 1
83045: PUSH
83046: EMPTY
83047: LIST
83048: LIST
83049: PUSH
83050: LD_INT 1
83052: NEG
83053: PUSH
83054: LD_INT 0
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: PUSH
83061: LD_INT 1
83063: NEG
83064: PUSH
83065: LD_INT 1
83067: NEG
83068: PUSH
83069: EMPTY
83070: LIST
83071: LIST
83072: PUSH
83073: LD_INT 1
83075: NEG
83076: PUSH
83077: LD_INT 2
83079: NEG
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: PUSH
83085: LD_INT 0
83087: PUSH
83088: LD_INT 2
83090: NEG
83091: PUSH
83092: EMPTY
83093: LIST
83094: LIST
83095: PUSH
83096: LD_INT 1
83098: PUSH
83099: LD_INT 1
83101: NEG
83102: PUSH
83103: EMPTY
83104: LIST
83105: LIST
83106: PUSH
83107: LD_INT 2
83109: PUSH
83110: LD_INT 0
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 2
83119: PUSH
83120: LD_INT 1
83122: PUSH
83123: EMPTY
83124: LIST
83125: LIST
83126: PUSH
83127: LD_INT 2
83129: PUSH
83130: LD_INT 2
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: PUSH
83137: LD_INT 1
83139: PUSH
83140: LD_INT 2
83142: PUSH
83143: EMPTY
83144: LIST
83145: LIST
83146: PUSH
83147: LD_INT 0
83149: PUSH
83150: LD_INT 2
83152: PUSH
83153: EMPTY
83154: LIST
83155: LIST
83156: PUSH
83157: LD_INT 1
83159: NEG
83160: PUSH
83161: LD_INT 1
83163: PUSH
83164: EMPTY
83165: LIST
83166: LIST
83167: PUSH
83168: LD_INT 2
83170: NEG
83171: PUSH
83172: LD_INT 0
83174: PUSH
83175: EMPTY
83176: LIST
83177: LIST
83178: PUSH
83179: LD_INT 2
83181: NEG
83182: PUSH
83183: LD_INT 1
83185: NEG
83186: PUSH
83187: EMPTY
83188: LIST
83189: LIST
83190: PUSH
83191: LD_INT 2
83193: NEG
83194: PUSH
83195: LD_INT 2
83197: NEG
83198: PUSH
83199: EMPTY
83200: LIST
83201: LIST
83202: PUSH
83203: LD_INT 1
83205: PUSH
83206: LD_INT 2
83208: NEG
83209: PUSH
83210: EMPTY
83211: LIST
83212: LIST
83213: PUSH
83214: LD_INT 2
83216: PUSH
83217: LD_INT 1
83219: NEG
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: PUSH
83225: LD_INT 3
83227: PUSH
83228: LD_INT 1
83230: PUSH
83231: EMPTY
83232: LIST
83233: LIST
83234: PUSH
83235: LD_INT 3
83237: PUSH
83238: LD_INT 2
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: LIST
83254: LIST
83255: LIST
83256: LIST
83257: LIST
83258: LIST
83259: LIST
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
83270: LD_ADDR_VAR 0 25
83274: PUSH
83275: LD_INT 0
83277: PUSH
83278: LD_INT 0
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: PUSH
83285: LD_INT 0
83287: PUSH
83288: LD_INT 1
83290: NEG
83291: PUSH
83292: EMPTY
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 1
83298: PUSH
83299: LD_INT 0
83301: PUSH
83302: EMPTY
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 1
83308: PUSH
83309: LD_INT 1
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: PUSH
83316: LD_INT 0
83318: PUSH
83319: LD_INT 1
83321: PUSH
83322: EMPTY
83323: LIST
83324: LIST
83325: PUSH
83326: LD_INT 1
83328: NEG
83329: PUSH
83330: LD_INT 0
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 1
83339: NEG
83340: PUSH
83341: LD_INT 1
83343: NEG
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: PUSH
83349: LD_INT 1
83351: NEG
83352: PUSH
83353: LD_INT 2
83355: NEG
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: PUSH
83361: LD_INT 0
83363: PUSH
83364: LD_INT 2
83366: NEG
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PUSH
83372: LD_INT 1
83374: PUSH
83375: LD_INT 1
83377: NEG
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 2
83385: PUSH
83386: LD_INT 0
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: PUSH
83393: LD_INT 2
83395: PUSH
83396: LD_INT 1
83398: PUSH
83399: EMPTY
83400: LIST
83401: LIST
83402: PUSH
83403: LD_INT 2
83405: PUSH
83406: LD_INT 2
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: PUSH
83413: LD_INT 1
83415: PUSH
83416: LD_INT 2
83418: PUSH
83419: EMPTY
83420: LIST
83421: LIST
83422: PUSH
83423: LD_INT 0
83425: PUSH
83426: LD_INT 2
83428: PUSH
83429: EMPTY
83430: LIST
83431: LIST
83432: PUSH
83433: LD_INT 1
83435: NEG
83436: PUSH
83437: LD_INT 1
83439: PUSH
83440: EMPTY
83441: LIST
83442: LIST
83443: PUSH
83444: LD_INT 2
83446: NEG
83447: PUSH
83448: LD_INT 0
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: LD_INT 2
83457: NEG
83458: PUSH
83459: LD_INT 1
83461: NEG
83462: PUSH
83463: EMPTY
83464: LIST
83465: LIST
83466: PUSH
83467: LD_INT 2
83469: NEG
83470: PUSH
83471: LD_INT 2
83473: NEG
83474: PUSH
83475: EMPTY
83476: LIST
83477: LIST
83478: PUSH
83479: LD_INT 3
83481: PUSH
83482: LD_INT 1
83484: PUSH
83485: EMPTY
83486: LIST
83487: LIST
83488: PUSH
83489: LD_INT 3
83491: PUSH
83492: LD_INT 2
83494: PUSH
83495: EMPTY
83496: LIST
83497: LIST
83498: PUSH
83499: LD_INT 2
83501: PUSH
83502: LD_INT 3
83504: PUSH
83505: EMPTY
83506: LIST
83507: LIST
83508: PUSH
83509: LD_INT 1
83511: PUSH
83512: LD_INT 3
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: LIST
83523: LIST
83524: LIST
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83544: LD_ADDR_VAR 0 26
83548: PUSH
83549: LD_INT 0
83551: PUSH
83552: LD_INT 0
83554: PUSH
83555: EMPTY
83556: LIST
83557: LIST
83558: PUSH
83559: LD_INT 0
83561: PUSH
83562: LD_INT 1
83564: NEG
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: PUSH
83570: LD_INT 1
83572: PUSH
83573: LD_INT 0
83575: PUSH
83576: EMPTY
83577: LIST
83578: LIST
83579: PUSH
83580: LD_INT 1
83582: PUSH
83583: LD_INT 1
83585: PUSH
83586: EMPTY
83587: LIST
83588: LIST
83589: PUSH
83590: LD_INT 0
83592: PUSH
83593: LD_INT 1
83595: PUSH
83596: EMPTY
83597: LIST
83598: LIST
83599: PUSH
83600: LD_INT 1
83602: NEG
83603: PUSH
83604: LD_INT 0
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PUSH
83611: LD_INT 1
83613: NEG
83614: PUSH
83615: LD_INT 1
83617: NEG
83618: PUSH
83619: EMPTY
83620: LIST
83621: LIST
83622: PUSH
83623: LD_INT 1
83625: NEG
83626: PUSH
83627: LD_INT 2
83629: NEG
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: PUSH
83635: LD_INT 0
83637: PUSH
83638: LD_INT 2
83640: NEG
83641: PUSH
83642: EMPTY
83643: LIST
83644: LIST
83645: PUSH
83646: LD_INT 1
83648: PUSH
83649: LD_INT 1
83651: NEG
83652: PUSH
83653: EMPTY
83654: LIST
83655: LIST
83656: PUSH
83657: LD_INT 2
83659: PUSH
83660: LD_INT 0
83662: PUSH
83663: EMPTY
83664: LIST
83665: LIST
83666: PUSH
83667: LD_INT 2
83669: PUSH
83670: LD_INT 1
83672: PUSH
83673: EMPTY
83674: LIST
83675: LIST
83676: PUSH
83677: LD_INT 2
83679: PUSH
83680: LD_INT 2
83682: PUSH
83683: EMPTY
83684: LIST
83685: LIST
83686: PUSH
83687: LD_INT 1
83689: PUSH
83690: LD_INT 2
83692: PUSH
83693: EMPTY
83694: LIST
83695: LIST
83696: PUSH
83697: LD_INT 0
83699: PUSH
83700: LD_INT 2
83702: PUSH
83703: EMPTY
83704: LIST
83705: LIST
83706: PUSH
83707: LD_INT 1
83709: NEG
83710: PUSH
83711: LD_INT 1
83713: PUSH
83714: EMPTY
83715: LIST
83716: LIST
83717: PUSH
83718: LD_INT 2
83720: NEG
83721: PUSH
83722: LD_INT 0
83724: PUSH
83725: EMPTY
83726: LIST
83727: LIST
83728: PUSH
83729: LD_INT 2
83731: NEG
83732: PUSH
83733: LD_INT 1
83735: NEG
83736: PUSH
83737: EMPTY
83738: LIST
83739: LIST
83740: PUSH
83741: LD_INT 2
83743: NEG
83744: PUSH
83745: LD_INT 2
83747: NEG
83748: PUSH
83749: EMPTY
83750: LIST
83751: LIST
83752: PUSH
83753: LD_INT 2
83755: PUSH
83756: LD_INT 3
83758: PUSH
83759: EMPTY
83760: LIST
83761: LIST
83762: PUSH
83763: LD_INT 1
83765: PUSH
83766: LD_INT 3
83768: PUSH
83769: EMPTY
83770: LIST
83771: LIST
83772: PUSH
83773: LD_INT 1
83775: NEG
83776: PUSH
83777: LD_INT 2
83779: PUSH
83780: EMPTY
83781: LIST
83782: LIST
83783: PUSH
83784: LD_INT 2
83786: NEG
83787: PUSH
83788: LD_INT 1
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: PUSH
83795: EMPTY
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: LIST
83818: LIST
83819: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83820: LD_ADDR_VAR 0 27
83824: PUSH
83825: LD_INT 0
83827: PUSH
83828: LD_INT 0
83830: PUSH
83831: EMPTY
83832: LIST
83833: LIST
83834: PUSH
83835: LD_INT 0
83837: PUSH
83838: LD_INT 1
83840: NEG
83841: PUSH
83842: EMPTY
83843: LIST
83844: LIST
83845: PUSH
83846: LD_INT 1
83848: PUSH
83849: LD_INT 0
83851: PUSH
83852: EMPTY
83853: LIST
83854: LIST
83855: PUSH
83856: LD_INT 1
83858: PUSH
83859: LD_INT 1
83861: PUSH
83862: EMPTY
83863: LIST
83864: LIST
83865: PUSH
83866: LD_INT 0
83868: PUSH
83869: LD_INT 1
83871: PUSH
83872: EMPTY
83873: LIST
83874: LIST
83875: PUSH
83876: LD_INT 1
83878: NEG
83879: PUSH
83880: LD_INT 0
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: PUSH
83887: LD_INT 1
83889: NEG
83890: PUSH
83891: LD_INT 1
83893: NEG
83894: PUSH
83895: EMPTY
83896: LIST
83897: LIST
83898: PUSH
83899: LD_INT 1
83901: NEG
83902: PUSH
83903: LD_INT 2
83905: NEG
83906: PUSH
83907: EMPTY
83908: LIST
83909: LIST
83910: PUSH
83911: LD_INT 0
83913: PUSH
83914: LD_INT 2
83916: NEG
83917: PUSH
83918: EMPTY
83919: LIST
83920: LIST
83921: PUSH
83922: LD_INT 1
83924: PUSH
83925: LD_INT 1
83927: NEG
83928: PUSH
83929: EMPTY
83930: LIST
83931: LIST
83932: PUSH
83933: LD_INT 2
83935: PUSH
83936: LD_INT 0
83938: PUSH
83939: EMPTY
83940: LIST
83941: LIST
83942: PUSH
83943: LD_INT 2
83945: PUSH
83946: LD_INT 1
83948: PUSH
83949: EMPTY
83950: LIST
83951: LIST
83952: PUSH
83953: LD_INT 2
83955: PUSH
83956: LD_INT 2
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 1
83965: PUSH
83966: LD_INT 2
83968: PUSH
83969: EMPTY
83970: LIST
83971: LIST
83972: PUSH
83973: LD_INT 0
83975: PUSH
83976: LD_INT 2
83978: PUSH
83979: EMPTY
83980: LIST
83981: LIST
83982: PUSH
83983: LD_INT 1
83985: NEG
83986: PUSH
83987: LD_INT 1
83989: PUSH
83990: EMPTY
83991: LIST
83992: LIST
83993: PUSH
83994: LD_INT 2
83996: NEG
83997: PUSH
83998: LD_INT 0
84000: PUSH
84001: EMPTY
84002: LIST
84003: LIST
84004: PUSH
84005: LD_INT 2
84007: NEG
84008: PUSH
84009: LD_INT 1
84011: NEG
84012: PUSH
84013: EMPTY
84014: LIST
84015: LIST
84016: PUSH
84017: LD_INT 2
84019: NEG
84020: PUSH
84021: LD_INT 2
84023: NEG
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: PUSH
84029: LD_INT 1
84031: NEG
84032: PUSH
84033: LD_INT 2
84035: PUSH
84036: EMPTY
84037: LIST
84038: LIST
84039: PUSH
84040: LD_INT 2
84042: NEG
84043: PUSH
84044: LD_INT 1
84046: PUSH
84047: EMPTY
84048: LIST
84049: LIST
84050: PUSH
84051: LD_INT 3
84053: NEG
84054: PUSH
84055: LD_INT 1
84057: NEG
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PUSH
84063: LD_INT 3
84065: NEG
84066: PUSH
84067: LD_INT 2
84069: NEG
84070: PUSH
84071: EMPTY
84072: LIST
84073: LIST
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: LIST
84090: LIST
84091: LIST
84092: LIST
84093: LIST
84094: LIST
84095: LIST
84096: LIST
84097: LIST
84098: LIST
84099: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
84100: LD_ADDR_VAR 0 28
84104: PUSH
84105: LD_INT 0
84107: PUSH
84108: LD_INT 0
84110: PUSH
84111: EMPTY
84112: LIST
84113: LIST
84114: PUSH
84115: LD_INT 0
84117: PUSH
84118: LD_INT 1
84120: NEG
84121: PUSH
84122: EMPTY
84123: LIST
84124: LIST
84125: PUSH
84126: LD_INT 1
84128: PUSH
84129: LD_INT 0
84131: PUSH
84132: EMPTY
84133: LIST
84134: LIST
84135: PUSH
84136: LD_INT 1
84138: PUSH
84139: LD_INT 1
84141: PUSH
84142: EMPTY
84143: LIST
84144: LIST
84145: PUSH
84146: LD_INT 0
84148: PUSH
84149: LD_INT 1
84151: PUSH
84152: EMPTY
84153: LIST
84154: LIST
84155: PUSH
84156: LD_INT 1
84158: NEG
84159: PUSH
84160: LD_INT 0
84162: PUSH
84163: EMPTY
84164: LIST
84165: LIST
84166: PUSH
84167: LD_INT 1
84169: NEG
84170: PUSH
84171: LD_INT 1
84173: NEG
84174: PUSH
84175: EMPTY
84176: LIST
84177: LIST
84178: PUSH
84179: LD_INT 1
84181: NEG
84182: PUSH
84183: LD_INT 2
84185: NEG
84186: PUSH
84187: EMPTY
84188: LIST
84189: LIST
84190: PUSH
84191: LD_INT 0
84193: PUSH
84194: LD_INT 2
84196: NEG
84197: PUSH
84198: EMPTY
84199: LIST
84200: LIST
84201: PUSH
84202: LD_INT 1
84204: PUSH
84205: LD_INT 1
84207: NEG
84208: PUSH
84209: EMPTY
84210: LIST
84211: LIST
84212: PUSH
84213: LD_INT 2
84215: PUSH
84216: LD_INT 0
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PUSH
84223: LD_INT 2
84225: PUSH
84226: LD_INT 1
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: PUSH
84233: LD_INT 2
84235: PUSH
84236: LD_INT 2
84238: PUSH
84239: EMPTY
84240: LIST
84241: LIST
84242: PUSH
84243: LD_INT 1
84245: PUSH
84246: LD_INT 2
84248: PUSH
84249: EMPTY
84250: LIST
84251: LIST
84252: PUSH
84253: LD_INT 0
84255: PUSH
84256: LD_INT 2
84258: PUSH
84259: EMPTY
84260: LIST
84261: LIST
84262: PUSH
84263: LD_INT 1
84265: NEG
84266: PUSH
84267: LD_INT 1
84269: PUSH
84270: EMPTY
84271: LIST
84272: LIST
84273: PUSH
84274: LD_INT 2
84276: NEG
84277: PUSH
84278: LD_INT 0
84280: PUSH
84281: EMPTY
84282: LIST
84283: LIST
84284: PUSH
84285: LD_INT 2
84287: NEG
84288: PUSH
84289: LD_INT 1
84291: NEG
84292: PUSH
84293: EMPTY
84294: LIST
84295: LIST
84296: PUSH
84297: LD_INT 2
84299: NEG
84300: PUSH
84301: LD_INT 2
84303: NEG
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: PUSH
84309: LD_INT 2
84311: NEG
84312: PUSH
84313: LD_INT 3
84315: NEG
84316: PUSH
84317: EMPTY
84318: LIST
84319: LIST
84320: PUSH
84321: LD_INT 1
84323: NEG
84324: PUSH
84325: LD_INT 3
84327: NEG
84328: PUSH
84329: EMPTY
84330: LIST
84331: LIST
84332: PUSH
84333: LD_INT 3
84335: NEG
84336: PUSH
84337: LD_INT 1
84339: NEG
84340: PUSH
84341: EMPTY
84342: LIST
84343: LIST
84344: PUSH
84345: LD_INT 3
84347: NEG
84348: PUSH
84349: LD_INT 2
84351: NEG
84352: PUSH
84353: EMPTY
84354: LIST
84355: LIST
84356: PUSH
84357: EMPTY
84358: LIST
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84382: LD_ADDR_VAR 0 29
84386: PUSH
84387: LD_INT 0
84389: PUSH
84390: LD_INT 0
84392: PUSH
84393: EMPTY
84394: LIST
84395: LIST
84396: PUSH
84397: LD_INT 0
84399: PUSH
84400: LD_INT 1
84402: NEG
84403: PUSH
84404: EMPTY
84405: LIST
84406: LIST
84407: PUSH
84408: LD_INT 1
84410: PUSH
84411: LD_INT 0
84413: PUSH
84414: EMPTY
84415: LIST
84416: LIST
84417: PUSH
84418: LD_INT 1
84420: PUSH
84421: LD_INT 1
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: PUSH
84428: LD_INT 0
84430: PUSH
84431: LD_INT 1
84433: PUSH
84434: EMPTY
84435: LIST
84436: LIST
84437: PUSH
84438: LD_INT 1
84440: NEG
84441: PUSH
84442: LD_INT 0
84444: PUSH
84445: EMPTY
84446: LIST
84447: LIST
84448: PUSH
84449: LD_INT 1
84451: NEG
84452: PUSH
84453: LD_INT 1
84455: NEG
84456: PUSH
84457: EMPTY
84458: LIST
84459: LIST
84460: PUSH
84461: LD_INT 1
84463: NEG
84464: PUSH
84465: LD_INT 2
84467: NEG
84468: PUSH
84469: EMPTY
84470: LIST
84471: LIST
84472: PUSH
84473: LD_INT 0
84475: PUSH
84476: LD_INT 2
84478: NEG
84479: PUSH
84480: EMPTY
84481: LIST
84482: LIST
84483: PUSH
84484: LD_INT 1
84486: PUSH
84487: LD_INT 1
84489: NEG
84490: PUSH
84491: EMPTY
84492: LIST
84493: LIST
84494: PUSH
84495: LD_INT 2
84497: PUSH
84498: LD_INT 0
84500: PUSH
84501: EMPTY
84502: LIST
84503: LIST
84504: PUSH
84505: LD_INT 2
84507: PUSH
84508: LD_INT 1
84510: PUSH
84511: EMPTY
84512: LIST
84513: LIST
84514: PUSH
84515: LD_INT 1
84517: PUSH
84518: LD_INT 2
84520: PUSH
84521: EMPTY
84522: LIST
84523: LIST
84524: PUSH
84525: LD_INT 0
84527: PUSH
84528: LD_INT 2
84530: PUSH
84531: EMPTY
84532: LIST
84533: LIST
84534: PUSH
84535: LD_INT 1
84537: NEG
84538: PUSH
84539: LD_INT 1
84541: PUSH
84542: EMPTY
84543: LIST
84544: LIST
84545: PUSH
84546: LD_INT 2
84548: NEG
84549: PUSH
84550: LD_INT 1
84552: NEG
84553: PUSH
84554: EMPTY
84555: LIST
84556: LIST
84557: PUSH
84558: LD_INT 2
84560: NEG
84561: PUSH
84562: LD_INT 2
84564: NEG
84565: PUSH
84566: EMPTY
84567: LIST
84568: LIST
84569: PUSH
84570: LD_INT 2
84572: NEG
84573: PUSH
84574: LD_INT 3
84576: NEG
84577: PUSH
84578: EMPTY
84579: LIST
84580: LIST
84581: PUSH
84582: LD_INT 2
84584: PUSH
84585: LD_INT 1
84587: NEG
84588: PUSH
84589: EMPTY
84590: LIST
84591: LIST
84592: PUSH
84593: LD_INT 3
84595: PUSH
84596: LD_INT 1
84598: PUSH
84599: EMPTY
84600: LIST
84601: LIST
84602: PUSH
84603: LD_INT 1
84605: PUSH
84606: LD_INT 3
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: PUSH
84613: LD_INT 1
84615: NEG
84616: PUSH
84617: LD_INT 2
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: PUSH
84624: LD_INT 3
84626: NEG
84627: PUSH
84628: LD_INT 2
84630: NEG
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PUSH
84636: EMPTY
84637: LIST
84638: LIST
84639: LIST
84640: LIST
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: LIST
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84661: LD_ADDR_VAR 0 30
84665: PUSH
84666: LD_INT 0
84668: PUSH
84669: LD_INT 0
84671: PUSH
84672: EMPTY
84673: LIST
84674: LIST
84675: PUSH
84676: LD_INT 0
84678: PUSH
84679: LD_INT 1
84681: NEG
84682: PUSH
84683: EMPTY
84684: LIST
84685: LIST
84686: PUSH
84687: LD_INT 1
84689: PUSH
84690: LD_INT 0
84692: PUSH
84693: EMPTY
84694: LIST
84695: LIST
84696: PUSH
84697: LD_INT 1
84699: PUSH
84700: LD_INT 1
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: PUSH
84707: LD_INT 0
84709: PUSH
84710: LD_INT 1
84712: PUSH
84713: EMPTY
84714: LIST
84715: LIST
84716: PUSH
84717: LD_INT 1
84719: NEG
84720: PUSH
84721: LD_INT 0
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: PUSH
84728: LD_INT 1
84730: NEG
84731: PUSH
84732: LD_INT 1
84734: NEG
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: PUSH
84740: LD_INT 1
84742: NEG
84743: PUSH
84744: LD_INT 2
84746: NEG
84747: PUSH
84748: EMPTY
84749: LIST
84750: LIST
84751: PUSH
84752: LD_INT 0
84754: PUSH
84755: LD_INT 2
84757: NEG
84758: PUSH
84759: EMPTY
84760: LIST
84761: LIST
84762: PUSH
84763: LD_INT 1
84765: PUSH
84766: LD_INT 1
84768: NEG
84769: PUSH
84770: EMPTY
84771: LIST
84772: LIST
84773: PUSH
84774: LD_INT 2
84776: PUSH
84777: LD_INT 0
84779: PUSH
84780: EMPTY
84781: LIST
84782: LIST
84783: PUSH
84784: LD_INT 2
84786: PUSH
84787: LD_INT 1
84789: PUSH
84790: EMPTY
84791: LIST
84792: LIST
84793: PUSH
84794: LD_INT 2
84796: PUSH
84797: LD_INT 2
84799: PUSH
84800: EMPTY
84801: LIST
84802: LIST
84803: PUSH
84804: LD_INT 1
84806: PUSH
84807: LD_INT 2
84809: PUSH
84810: EMPTY
84811: LIST
84812: LIST
84813: PUSH
84814: LD_INT 1
84816: NEG
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: PUSH
84825: LD_INT 2
84827: NEG
84828: PUSH
84829: LD_INT 0
84831: PUSH
84832: EMPTY
84833: LIST
84834: LIST
84835: PUSH
84836: LD_INT 2
84838: NEG
84839: PUSH
84840: LD_INT 1
84842: NEG
84843: PUSH
84844: EMPTY
84845: LIST
84846: LIST
84847: PUSH
84848: LD_INT 1
84850: NEG
84851: PUSH
84852: LD_INT 3
84854: NEG
84855: PUSH
84856: EMPTY
84857: LIST
84858: LIST
84859: PUSH
84860: LD_INT 1
84862: PUSH
84863: LD_INT 2
84865: NEG
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: PUSH
84871: LD_INT 3
84873: PUSH
84874: LD_INT 2
84876: PUSH
84877: EMPTY
84878: LIST
84879: LIST
84880: PUSH
84881: LD_INT 2
84883: PUSH
84884: LD_INT 3
84886: PUSH
84887: EMPTY
84888: LIST
84889: LIST
84890: PUSH
84891: LD_INT 2
84893: NEG
84894: PUSH
84895: LD_INT 1
84897: PUSH
84898: EMPTY
84899: LIST
84900: LIST
84901: PUSH
84902: LD_INT 3
84904: NEG
84905: PUSH
84906: LD_INT 1
84908: NEG
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: EMPTY
84915: LIST
84916: LIST
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84939: LD_ADDR_VAR 0 31
84943: PUSH
84944: LD_INT 0
84946: PUSH
84947: LD_INT 0
84949: PUSH
84950: EMPTY
84951: LIST
84952: LIST
84953: PUSH
84954: LD_INT 0
84956: PUSH
84957: LD_INT 1
84959: NEG
84960: PUSH
84961: EMPTY
84962: LIST
84963: LIST
84964: PUSH
84965: LD_INT 1
84967: PUSH
84968: LD_INT 0
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: PUSH
84975: LD_INT 1
84977: PUSH
84978: LD_INT 1
84980: PUSH
84981: EMPTY
84982: LIST
84983: LIST
84984: PUSH
84985: LD_INT 0
84987: PUSH
84988: LD_INT 1
84990: PUSH
84991: EMPTY
84992: LIST
84993: LIST
84994: PUSH
84995: LD_INT 1
84997: NEG
84998: PUSH
84999: LD_INT 0
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: PUSH
85006: LD_INT 1
85008: NEG
85009: PUSH
85010: LD_INT 1
85012: NEG
85013: PUSH
85014: EMPTY
85015: LIST
85016: LIST
85017: PUSH
85018: LD_INT 1
85020: NEG
85021: PUSH
85022: LD_INT 2
85024: NEG
85025: PUSH
85026: EMPTY
85027: LIST
85028: LIST
85029: PUSH
85030: LD_INT 1
85032: PUSH
85033: LD_INT 1
85035: NEG
85036: PUSH
85037: EMPTY
85038: LIST
85039: LIST
85040: PUSH
85041: LD_INT 2
85043: PUSH
85044: LD_INT 0
85046: PUSH
85047: EMPTY
85048: LIST
85049: LIST
85050: PUSH
85051: LD_INT 2
85053: PUSH
85054: LD_INT 1
85056: PUSH
85057: EMPTY
85058: LIST
85059: LIST
85060: PUSH
85061: LD_INT 2
85063: PUSH
85064: LD_INT 2
85066: PUSH
85067: EMPTY
85068: LIST
85069: LIST
85070: PUSH
85071: LD_INT 1
85073: PUSH
85074: LD_INT 2
85076: PUSH
85077: EMPTY
85078: LIST
85079: LIST
85080: PUSH
85081: LD_INT 0
85083: PUSH
85084: LD_INT 2
85086: PUSH
85087: EMPTY
85088: LIST
85089: LIST
85090: PUSH
85091: LD_INT 1
85093: NEG
85094: PUSH
85095: LD_INT 1
85097: PUSH
85098: EMPTY
85099: LIST
85100: LIST
85101: PUSH
85102: LD_INT 2
85104: NEG
85105: PUSH
85106: LD_INT 1
85108: NEG
85109: PUSH
85110: EMPTY
85111: LIST
85112: LIST
85113: PUSH
85114: LD_INT 2
85116: NEG
85117: PUSH
85118: LD_INT 2
85120: NEG
85121: PUSH
85122: EMPTY
85123: LIST
85124: LIST
85125: PUSH
85126: LD_INT 2
85128: NEG
85129: PUSH
85130: LD_INT 3
85132: NEG
85133: PUSH
85134: EMPTY
85135: LIST
85136: LIST
85137: PUSH
85138: LD_INT 2
85140: PUSH
85141: LD_INT 1
85143: NEG
85144: PUSH
85145: EMPTY
85146: LIST
85147: LIST
85148: PUSH
85149: LD_INT 3
85151: PUSH
85152: LD_INT 1
85154: PUSH
85155: EMPTY
85156: LIST
85157: LIST
85158: PUSH
85159: LD_INT 1
85161: PUSH
85162: LD_INT 3
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: PUSH
85169: LD_INT 1
85171: NEG
85172: PUSH
85173: LD_INT 2
85175: PUSH
85176: EMPTY
85177: LIST
85178: LIST
85179: PUSH
85180: LD_INT 3
85182: NEG
85183: PUSH
85184: LD_INT 2
85186: NEG
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PUSH
85192: EMPTY
85193: LIST
85194: LIST
85195: LIST
85196: LIST
85197: LIST
85198: LIST
85199: LIST
85200: LIST
85201: LIST
85202: LIST
85203: LIST
85204: LIST
85205: LIST
85206: LIST
85207: LIST
85208: LIST
85209: LIST
85210: LIST
85211: LIST
85212: LIST
85213: LIST
85214: LIST
85215: LIST
85216: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85217: LD_ADDR_VAR 0 32
85221: PUSH
85222: LD_INT 0
85224: PUSH
85225: LD_INT 0
85227: PUSH
85228: EMPTY
85229: LIST
85230: LIST
85231: PUSH
85232: LD_INT 0
85234: PUSH
85235: LD_INT 1
85237: NEG
85238: PUSH
85239: EMPTY
85240: LIST
85241: LIST
85242: PUSH
85243: LD_INT 1
85245: PUSH
85246: LD_INT 0
85248: PUSH
85249: EMPTY
85250: LIST
85251: LIST
85252: PUSH
85253: LD_INT 1
85255: PUSH
85256: LD_INT 1
85258: PUSH
85259: EMPTY
85260: LIST
85261: LIST
85262: PUSH
85263: LD_INT 0
85265: PUSH
85266: LD_INT 1
85268: PUSH
85269: EMPTY
85270: LIST
85271: LIST
85272: PUSH
85273: LD_INT 1
85275: NEG
85276: PUSH
85277: LD_INT 0
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: PUSH
85284: LD_INT 1
85286: NEG
85287: PUSH
85288: LD_INT 1
85290: NEG
85291: PUSH
85292: EMPTY
85293: LIST
85294: LIST
85295: PUSH
85296: LD_INT 1
85298: NEG
85299: PUSH
85300: LD_INT 2
85302: NEG
85303: PUSH
85304: EMPTY
85305: LIST
85306: LIST
85307: PUSH
85308: LD_INT 0
85310: PUSH
85311: LD_INT 2
85313: NEG
85314: PUSH
85315: EMPTY
85316: LIST
85317: LIST
85318: PUSH
85319: LD_INT 1
85321: PUSH
85322: LD_INT 1
85324: NEG
85325: PUSH
85326: EMPTY
85327: LIST
85328: LIST
85329: PUSH
85330: LD_INT 2
85332: PUSH
85333: LD_INT 1
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PUSH
85340: LD_INT 2
85342: PUSH
85343: LD_INT 2
85345: PUSH
85346: EMPTY
85347: LIST
85348: LIST
85349: PUSH
85350: LD_INT 1
85352: PUSH
85353: LD_INT 2
85355: PUSH
85356: EMPTY
85357: LIST
85358: LIST
85359: PUSH
85360: LD_INT 0
85362: PUSH
85363: LD_INT 2
85365: PUSH
85366: EMPTY
85367: LIST
85368: LIST
85369: PUSH
85370: LD_INT 1
85372: NEG
85373: PUSH
85374: LD_INT 1
85376: PUSH
85377: EMPTY
85378: LIST
85379: LIST
85380: PUSH
85381: LD_INT 2
85383: NEG
85384: PUSH
85385: LD_INT 0
85387: PUSH
85388: EMPTY
85389: LIST
85390: LIST
85391: PUSH
85392: LD_INT 2
85394: NEG
85395: PUSH
85396: LD_INT 1
85398: NEG
85399: PUSH
85400: EMPTY
85401: LIST
85402: LIST
85403: PUSH
85404: LD_INT 1
85406: NEG
85407: PUSH
85408: LD_INT 3
85410: NEG
85411: PUSH
85412: EMPTY
85413: LIST
85414: LIST
85415: PUSH
85416: LD_INT 1
85418: PUSH
85419: LD_INT 2
85421: NEG
85422: PUSH
85423: EMPTY
85424: LIST
85425: LIST
85426: PUSH
85427: LD_INT 3
85429: PUSH
85430: LD_INT 2
85432: PUSH
85433: EMPTY
85434: LIST
85435: LIST
85436: PUSH
85437: LD_INT 2
85439: PUSH
85440: LD_INT 3
85442: PUSH
85443: EMPTY
85444: LIST
85445: LIST
85446: PUSH
85447: LD_INT 2
85449: NEG
85450: PUSH
85451: LD_INT 1
85453: PUSH
85454: EMPTY
85455: LIST
85456: LIST
85457: PUSH
85458: LD_INT 3
85460: NEG
85461: PUSH
85462: LD_INT 1
85464: NEG
85465: PUSH
85466: EMPTY
85467: LIST
85468: LIST
85469: PUSH
85470: EMPTY
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: LIST
85478: LIST
85479: LIST
85480: LIST
85481: LIST
85482: LIST
85483: LIST
85484: LIST
85485: LIST
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85495: LD_ADDR_VAR 0 33
85499: PUSH
85500: LD_INT 0
85502: PUSH
85503: LD_INT 0
85505: PUSH
85506: EMPTY
85507: LIST
85508: LIST
85509: PUSH
85510: LD_INT 0
85512: PUSH
85513: LD_INT 1
85515: NEG
85516: PUSH
85517: EMPTY
85518: LIST
85519: LIST
85520: PUSH
85521: LD_INT 1
85523: PUSH
85524: LD_INT 0
85526: PUSH
85527: EMPTY
85528: LIST
85529: LIST
85530: PUSH
85531: LD_INT 1
85533: PUSH
85534: LD_INT 1
85536: PUSH
85537: EMPTY
85538: LIST
85539: LIST
85540: PUSH
85541: LD_INT 0
85543: PUSH
85544: LD_INT 1
85546: PUSH
85547: EMPTY
85548: LIST
85549: LIST
85550: PUSH
85551: LD_INT 1
85553: NEG
85554: PUSH
85555: LD_INT 0
85557: PUSH
85558: EMPTY
85559: LIST
85560: LIST
85561: PUSH
85562: LD_INT 1
85564: NEG
85565: PUSH
85566: LD_INT 1
85568: NEG
85569: PUSH
85570: EMPTY
85571: LIST
85572: LIST
85573: PUSH
85574: LD_INT 1
85576: NEG
85577: PUSH
85578: LD_INT 2
85580: NEG
85581: PUSH
85582: EMPTY
85583: LIST
85584: LIST
85585: PUSH
85586: LD_INT 1
85588: PUSH
85589: LD_INT 1
85591: NEG
85592: PUSH
85593: EMPTY
85594: LIST
85595: LIST
85596: PUSH
85597: LD_INT 2
85599: PUSH
85600: LD_INT 0
85602: PUSH
85603: EMPTY
85604: LIST
85605: LIST
85606: PUSH
85607: LD_INT 2
85609: PUSH
85610: LD_INT 1
85612: PUSH
85613: EMPTY
85614: LIST
85615: LIST
85616: PUSH
85617: LD_INT 1
85619: PUSH
85620: LD_INT 2
85622: PUSH
85623: EMPTY
85624: LIST
85625: LIST
85626: PUSH
85627: LD_INT 0
85629: PUSH
85630: LD_INT 2
85632: PUSH
85633: EMPTY
85634: LIST
85635: LIST
85636: PUSH
85637: LD_INT 1
85639: NEG
85640: PUSH
85641: LD_INT 1
85643: PUSH
85644: EMPTY
85645: LIST
85646: LIST
85647: PUSH
85648: LD_INT 2
85650: NEG
85651: PUSH
85652: LD_INT 0
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: PUSH
85659: LD_INT 2
85661: NEG
85662: PUSH
85663: LD_INT 1
85665: NEG
85666: PUSH
85667: EMPTY
85668: LIST
85669: LIST
85670: PUSH
85671: LD_INT 2
85673: NEG
85674: PUSH
85675: LD_INT 2
85677: NEG
85678: PUSH
85679: EMPTY
85680: LIST
85681: LIST
85682: PUSH
85683: LD_INT 2
85685: NEG
85686: PUSH
85687: LD_INT 3
85689: NEG
85690: PUSH
85691: EMPTY
85692: LIST
85693: LIST
85694: PUSH
85695: LD_INT 2
85697: PUSH
85698: LD_INT 1
85700: NEG
85701: PUSH
85702: EMPTY
85703: LIST
85704: LIST
85705: PUSH
85706: LD_INT 3
85708: PUSH
85709: LD_INT 1
85711: PUSH
85712: EMPTY
85713: LIST
85714: LIST
85715: PUSH
85716: LD_INT 1
85718: PUSH
85719: LD_INT 3
85721: PUSH
85722: EMPTY
85723: LIST
85724: LIST
85725: PUSH
85726: LD_INT 1
85728: NEG
85729: PUSH
85730: LD_INT 2
85732: PUSH
85733: EMPTY
85734: LIST
85735: LIST
85736: PUSH
85737: LD_INT 3
85739: NEG
85740: PUSH
85741: LD_INT 2
85743: NEG
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: LIST
85753: LIST
85754: LIST
85755: LIST
85756: LIST
85757: LIST
85758: LIST
85759: LIST
85760: LIST
85761: LIST
85762: LIST
85763: LIST
85764: LIST
85765: LIST
85766: LIST
85767: LIST
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85774: LD_ADDR_VAR 0 34
85778: PUSH
85779: LD_INT 0
85781: PUSH
85782: LD_INT 0
85784: PUSH
85785: EMPTY
85786: LIST
85787: LIST
85788: PUSH
85789: LD_INT 0
85791: PUSH
85792: LD_INT 1
85794: NEG
85795: PUSH
85796: EMPTY
85797: LIST
85798: LIST
85799: PUSH
85800: LD_INT 1
85802: PUSH
85803: LD_INT 0
85805: PUSH
85806: EMPTY
85807: LIST
85808: LIST
85809: PUSH
85810: LD_INT 1
85812: PUSH
85813: LD_INT 1
85815: PUSH
85816: EMPTY
85817: LIST
85818: LIST
85819: PUSH
85820: LD_INT 0
85822: PUSH
85823: LD_INT 1
85825: PUSH
85826: EMPTY
85827: LIST
85828: LIST
85829: PUSH
85830: LD_INT 1
85832: NEG
85833: PUSH
85834: LD_INT 0
85836: PUSH
85837: EMPTY
85838: LIST
85839: LIST
85840: PUSH
85841: LD_INT 1
85843: NEG
85844: PUSH
85845: LD_INT 1
85847: NEG
85848: PUSH
85849: EMPTY
85850: LIST
85851: LIST
85852: PUSH
85853: LD_INT 1
85855: NEG
85856: PUSH
85857: LD_INT 2
85859: NEG
85860: PUSH
85861: EMPTY
85862: LIST
85863: LIST
85864: PUSH
85865: LD_INT 0
85867: PUSH
85868: LD_INT 2
85870: NEG
85871: PUSH
85872: EMPTY
85873: LIST
85874: LIST
85875: PUSH
85876: LD_INT 1
85878: PUSH
85879: LD_INT 1
85881: NEG
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: LD_INT 2
85889: PUSH
85890: LD_INT 1
85892: PUSH
85893: EMPTY
85894: LIST
85895: LIST
85896: PUSH
85897: LD_INT 2
85899: PUSH
85900: LD_INT 2
85902: PUSH
85903: EMPTY
85904: LIST
85905: LIST
85906: PUSH
85907: LD_INT 1
85909: PUSH
85910: LD_INT 2
85912: PUSH
85913: EMPTY
85914: LIST
85915: LIST
85916: PUSH
85917: LD_INT 1
85919: NEG
85920: PUSH
85921: LD_INT 1
85923: PUSH
85924: EMPTY
85925: LIST
85926: LIST
85927: PUSH
85928: LD_INT 2
85930: NEG
85931: PUSH
85932: LD_INT 0
85934: PUSH
85935: EMPTY
85936: LIST
85937: LIST
85938: PUSH
85939: LD_INT 2
85941: NEG
85942: PUSH
85943: LD_INT 1
85945: NEG
85946: PUSH
85947: EMPTY
85948: LIST
85949: LIST
85950: PUSH
85951: LD_INT 2
85953: NEG
85954: PUSH
85955: LD_INT 2
85957: NEG
85958: PUSH
85959: EMPTY
85960: LIST
85961: LIST
85962: PUSH
85963: LD_INT 1
85965: NEG
85966: PUSH
85967: LD_INT 3
85969: NEG
85970: PUSH
85971: EMPTY
85972: LIST
85973: LIST
85974: PUSH
85975: LD_INT 1
85977: PUSH
85978: LD_INT 2
85980: NEG
85981: PUSH
85982: EMPTY
85983: LIST
85984: LIST
85985: PUSH
85986: LD_INT 3
85988: PUSH
85989: LD_INT 2
85991: PUSH
85992: EMPTY
85993: LIST
85994: LIST
85995: PUSH
85996: LD_INT 2
85998: PUSH
85999: LD_INT 3
86001: PUSH
86002: EMPTY
86003: LIST
86004: LIST
86005: PUSH
86006: LD_INT 2
86008: NEG
86009: PUSH
86010: LD_INT 1
86012: PUSH
86013: EMPTY
86014: LIST
86015: LIST
86016: PUSH
86017: LD_INT 3
86019: NEG
86020: PUSH
86021: LD_INT 1
86023: NEG
86024: PUSH
86025: EMPTY
86026: LIST
86027: LIST
86028: PUSH
86029: EMPTY
86030: LIST
86031: LIST
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: LIST
86046: LIST
86047: LIST
86048: LIST
86049: LIST
86050: LIST
86051: LIST
86052: LIST
86053: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86054: LD_ADDR_VAR 0 35
86058: PUSH
86059: LD_INT 0
86061: PUSH
86062: LD_INT 0
86064: PUSH
86065: EMPTY
86066: LIST
86067: LIST
86068: PUSH
86069: LD_INT 0
86071: PUSH
86072: LD_INT 1
86074: NEG
86075: PUSH
86076: EMPTY
86077: LIST
86078: LIST
86079: PUSH
86080: LD_INT 1
86082: PUSH
86083: LD_INT 0
86085: PUSH
86086: EMPTY
86087: LIST
86088: LIST
86089: PUSH
86090: LD_INT 1
86092: PUSH
86093: LD_INT 1
86095: PUSH
86096: EMPTY
86097: LIST
86098: LIST
86099: PUSH
86100: LD_INT 0
86102: PUSH
86103: LD_INT 1
86105: PUSH
86106: EMPTY
86107: LIST
86108: LIST
86109: PUSH
86110: LD_INT 1
86112: NEG
86113: PUSH
86114: LD_INT 0
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: PUSH
86121: LD_INT 1
86123: NEG
86124: PUSH
86125: LD_INT 1
86127: NEG
86128: PUSH
86129: EMPTY
86130: LIST
86131: LIST
86132: PUSH
86133: LD_INT 2
86135: PUSH
86136: LD_INT 1
86138: PUSH
86139: EMPTY
86140: LIST
86141: LIST
86142: PUSH
86143: LD_INT 2
86145: NEG
86146: PUSH
86147: LD_INT 1
86149: NEG
86150: PUSH
86151: EMPTY
86152: LIST
86153: LIST
86154: PUSH
86155: EMPTY
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: LIST
86165: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86166: LD_ADDR_VAR 0 36
86170: PUSH
86171: LD_INT 0
86173: PUSH
86174: LD_INT 0
86176: PUSH
86177: EMPTY
86178: LIST
86179: LIST
86180: PUSH
86181: LD_INT 0
86183: PUSH
86184: LD_INT 1
86186: NEG
86187: PUSH
86188: EMPTY
86189: LIST
86190: LIST
86191: PUSH
86192: LD_INT 1
86194: PUSH
86195: LD_INT 0
86197: PUSH
86198: EMPTY
86199: LIST
86200: LIST
86201: PUSH
86202: LD_INT 1
86204: PUSH
86205: LD_INT 1
86207: PUSH
86208: EMPTY
86209: LIST
86210: LIST
86211: PUSH
86212: LD_INT 0
86214: PUSH
86215: LD_INT 1
86217: PUSH
86218: EMPTY
86219: LIST
86220: LIST
86221: PUSH
86222: LD_INT 1
86224: NEG
86225: PUSH
86226: LD_INT 0
86228: PUSH
86229: EMPTY
86230: LIST
86231: LIST
86232: PUSH
86233: LD_INT 1
86235: NEG
86236: PUSH
86237: LD_INT 1
86239: NEG
86240: PUSH
86241: EMPTY
86242: LIST
86243: LIST
86244: PUSH
86245: LD_INT 1
86247: NEG
86248: PUSH
86249: LD_INT 2
86251: NEG
86252: PUSH
86253: EMPTY
86254: LIST
86255: LIST
86256: PUSH
86257: LD_INT 1
86259: PUSH
86260: LD_INT 2
86262: PUSH
86263: EMPTY
86264: LIST
86265: LIST
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: LIST
86271: LIST
86272: LIST
86273: LIST
86274: LIST
86275: LIST
86276: LIST
86277: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86278: LD_ADDR_VAR 0 37
86282: PUSH
86283: LD_INT 0
86285: PUSH
86286: LD_INT 0
86288: PUSH
86289: EMPTY
86290: LIST
86291: LIST
86292: PUSH
86293: LD_INT 0
86295: PUSH
86296: LD_INT 1
86298: NEG
86299: PUSH
86300: EMPTY
86301: LIST
86302: LIST
86303: PUSH
86304: LD_INT 1
86306: PUSH
86307: LD_INT 0
86309: PUSH
86310: EMPTY
86311: LIST
86312: LIST
86313: PUSH
86314: LD_INT 1
86316: PUSH
86317: LD_INT 1
86319: PUSH
86320: EMPTY
86321: LIST
86322: LIST
86323: PUSH
86324: LD_INT 0
86326: PUSH
86327: LD_INT 1
86329: PUSH
86330: EMPTY
86331: LIST
86332: LIST
86333: PUSH
86334: LD_INT 1
86336: NEG
86337: PUSH
86338: LD_INT 0
86340: PUSH
86341: EMPTY
86342: LIST
86343: LIST
86344: PUSH
86345: LD_INT 1
86347: NEG
86348: PUSH
86349: LD_INT 1
86351: NEG
86352: PUSH
86353: EMPTY
86354: LIST
86355: LIST
86356: PUSH
86357: LD_INT 1
86359: PUSH
86360: LD_INT 1
86362: NEG
86363: PUSH
86364: EMPTY
86365: LIST
86366: LIST
86367: PUSH
86368: LD_INT 1
86370: NEG
86371: PUSH
86372: LD_INT 1
86374: PUSH
86375: EMPTY
86376: LIST
86377: LIST
86378: PUSH
86379: EMPTY
86380: LIST
86381: LIST
86382: LIST
86383: LIST
86384: LIST
86385: LIST
86386: LIST
86387: LIST
86388: LIST
86389: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86390: LD_ADDR_VAR 0 38
86394: PUSH
86395: LD_INT 0
86397: PUSH
86398: LD_INT 0
86400: PUSH
86401: EMPTY
86402: LIST
86403: LIST
86404: PUSH
86405: LD_INT 0
86407: PUSH
86408: LD_INT 1
86410: NEG
86411: PUSH
86412: EMPTY
86413: LIST
86414: LIST
86415: PUSH
86416: LD_INT 1
86418: PUSH
86419: LD_INT 0
86421: PUSH
86422: EMPTY
86423: LIST
86424: LIST
86425: PUSH
86426: LD_INT 1
86428: PUSH
86429: LD_INT 1
86431: PUSH
86432: EMPTY
86433: LIST
86434: LIST
86435: PUSH
86436: LD_INT 0
86438: PUSH
86439: LD_INT 1
86441: PUSH
86442: EMPTY
86443: LIST
86444: LIST
86445: PUSH
86446: LD_INT 1
86448: NEG
86449: PUSH
86450: LD_INT 0
86452: PUSH
86453: EMPTY
86454: LIST
86455: LIST
86456: PUSH
86457: LD_INT 1
86459: NEG
86460: PUSH
86461: LD_INT 1
86463: NEG
86464: PUSH
86465: EMPTY
86466: LIST
86467: LIST
86468: PUSH
86469: LD_INT 2
86471: PUSH
86472: LD_INT 1
86474: PUSH
86475: EMPTY
86476: LIST
86477: LIST
86478: PUSH
86479: LD_INT 2
86481: NEG
86482: PUSH
86483: LD_INT 1
86485: NEG
86486: PUSH
86487: EMPTY
86488: LIST
86489: LIST
86490: PUSH
86491: EMPTY
86492: LIST
86493: LIST
86494: LIST
86495: LIST
86496: LIST
86497: LIST
86498: LIST
86499: LIST
86500: LIST
86501: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86502: LD_ADDR_VAR 0 39
86506: PUSH
86507: LD_INT 0
86509: PUSH
86510: LD_INT 0
86512: PUSH
86513: EMPTY
86514: LIST
86515: LIST
86516: PUSH
86517: LD_INT 0
86519: PUSH
86520: LD_INT 1
86522: NEG
86523: PUSH
86524: EMPTY
86525: LIST
86526: LIST
86527: PUSH
86528: LD_INT 1
86530: PUSH
86531: LD_INT 0
86533: PUSH
86534: EMPTY
86535: LIST
86536: LIST
86537: PUSH
86538: LD_INT 1
86540: PUSH
86541: LD_INT 1
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: PUSH
86548: LD_INT 0
86550: PUSH
86551: LD_INT 1
86553: PUSH
86554: EMPTY
86555: LIST
86556: LIST
86557: PUSH
86558: LD_INT 1
86560: NEG
86561: PUSH
86562: LD_INT 0
86564: PUSH
86565: EMPTY
86566: LIST
86567: LIST
86568: PUSH
86569: LD_INT 1
86571: NEG
86572: PUSH
86573: LD_INT 1
86575: NEG
86576: PUSH
86577: EMPTY
86578: LIST
86579: LIST
86580: PUSH
86581: LD_INT 1
86583: NEG
86584: PUSH
86585: LD_INT 2
86587: NEG
86588: PUSH
86589: EMPTY
86590: LIST
86591: LIST
86592: PUSH
86593: LD_INT 1
86595: PUSH
86596: LD_INT 2
86598: PUSH
86599: EMPTY
86600: LIST
86601: LIST
86602: PUSH
86603: EMPTY
86604: LIST
86605: LIST
86606: LIST
86607: LIST
86608: LIST
86609: LIST
86610: LIST
86611: LIST
86612: LIST
86613: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86614: LD_ADDR_VAR 0 40
86618: PUSH
86619: LD_INT 0
86621: PUSH
86622: LD_INT 0
86624: PUSH
86625: EMPTY
86626: LIST
86627: LIST
86628: PUSH
86629: LD_INT 0
86631: PUSH
86632: LD_INT 1
86634: NEG
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: PUSH
86640: LD_INT 1
86642: PUSH
86643: LD_INT 0
86645: PUSH
86646: EMPTY
86647: LIST
86648: LIST
86649: PUSH
86650: LD_INT 1
86652: PUSH
86653: LD_INT 1
86655: PUSH
86656: EMPTY
86657: LIST
86658: LIST
86659: PUSH
86660: LD_INT 0
86662: PUSH
86663: LD_INT 1
86665: PUSH
86666: EMPTY
86667: LIST
86668: LIST
86669: PUSH
86670: LD_INT 1
86672: NEG
86673: PUSH
86674: LD_INT 0
86676: PUSH
86677: EMPTY
86678: LIST
86679: LIST
86680: PUSH
86681: LD_INT 1
86683: NEG
86684: PUSH
86685: LD_INT 1
86687: NEG
86688: PUSH
86689: EMPTY
86690: LIST
86691: LIST
86692: PUSH
86693: LD_INT 1
86695: PUSH
86696: LD_INT 1
86698: NEG
86699: PUSH
86700: EMPTY
86701: LIST
86702: LIST
86703: PUSH
86704: LD_INT 1
86706: NEG
86707: PUSH
86708: LD_INT 1
86710: PUSH
86711: EMPTY
86712: LIST
86713: LIST
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: LIST
86719: LIST
86720: LIST
86721: LIST
86722: LIST
86723: LIST
86724: LIST
86725: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86726: LD_ADDR_VAR 0 41
86730: PUSH
86731: LD_INT 0
86733: PUSH
86734: LD_INT 0
86736: PUSH
86737: EMPTY
86738: LIST
86739: LIST
86740: PUSH
86741: LD_INT 0
86743: PUSH
86744: LD_INT 1
86746: NEG
86747: PUSH
86748: EMPTY
86749: LIST
86750: LIST
86751: PUSH
86752: LD_INT 1
86754: PUSH
86755: LD_INT 0
86757: PUSH
86758: EMPTY
86759: LIST
86760: LIST
86761: PUSH
86762: LD_INT 1
86764: PUSH
86765: LD_INT 1
86767: PUSH
86768: EMPTY
86769: LIST
86770: LIST
86771: PUSH
86772: LD_INT 0
86774: PUSH
86775: LD_INT 1
86777: PUSH
86778: EMPTY
86779: LIST
86780: LIST
86781: PUSH
86782: LD_INT 1
86784: NEG
86785: PUSH
86786: LD_INT 0
86788: PUSH
86789: EMPTY
86790: LIST
86791: LIST
86792: PUSH
86793: LD_INT 1
86795: NEG
86796: PUSH
86797: LD_INT 1
86799: NEG
86800: PUSH
86801: EMPTY
86802: LIST
86803: LIST
86804: PUSH
86805: LD_INT 1
86807: NEG
86808: PUSH
86809: LD_INT 2
86811: NEG
86812: PUSH
86813: EMPTY
86814: LIST
86815: LIST
86816: PUSH
86817: LD_INT 1
86819: PUSH
86820: LD_INT 1
86822: NEG
86823: PUSH
86824: EMPTY
86825: LIST
86826: LIST
86827: PUSH
86828: LD_INT 2
86830: PUSH
86831: LD_INT 0
86833: PUSH
86834: EMPTY
86835: LIST
86836: LIST
86837: PUSH
86838: LD_INT 2
86840: PUSH
86841: LD_INT 1
86843: PUSH
86844: EMPTY
86845: LIST
86846: LIST
86847: PUSH
86848: LD_INT 2
86850: PUSH
86851: LD_INT 2
86853: PUSH
86854: EMPTY
86855: LIST
86856: LIST
86857: PUSH
86858: LD_INT 1
86860: PUSH
86861: LD_INT 2
86863: PUSH
86864: EMPTY
86865: LIST
86866: LIST
86867: PUSH
86868: LD_INT 1
86870: NEG
86871: PUSH
86872: LD_INT 1
86874: PUSH
86875: EMPTY
86876: LIST
86877: LIST
86878: PUSH
86879: LD_INT 2
86881: NEG
86882: PUSH
86883: LD_INT 0
86885: PUSH
86886: EMPTY
86887: LIST
86888: LIST
86889: PUSH
86890: LD_INT 2
86892: NEG
86893: PUSH
86894: LD_INT 1
86896: NEG
86897: PUSH
86898: EMPTY
86899: LIST
86900: LIST
86901: PUSH
86902: LD_INT 2
86904: NEG
86905: PUSH
86906: LD_INT 2
86908: NEG
86909: PUSH
86910: EMPTY
86911: LIST
86912: LIST
86913: PUSH
86914: LD_INT 2
86916: NEG
86917: PUSH
86918: LD_INT 3
86920: NEG
86921: PUSH
86922: EMPTY
86923: LIST
86924: LIST
86925: PUSH
86926: LD_INT 2
86928: PUSH
86929: LD_INT 1
86931: NEG
86932: PUSH
86933: EMPTY
86934: LIST
86935: LIST
86936: PUSH
86937: LD_INT 3
86939: PUSH
86940: LD_INT 0
86942: PUSH
86943: EMPTY
86944: LIST
86945: LIST
86946: PUSH
86947: LD_INT 3
86949: PUSH
86950: LD_INT 1
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 3
86959: PUSH
86960: LD_INT 2
86962: PUSH
86963: EMPTY
86964: LIST
86965: LIST
86966: PUSH
86967: LD_INT 3
86969: PUSH
86970: LD_INT 3
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PUSH
86977: LD_INT 2
86979: PUSH
86980: LD_INT 3
86982: PUSH
86983: EMPTY
86984: LIST
86985: LIST
86986: PUSH
86987: LD_INT 2
86989: NEG
86990: PUSH
86991: LD_INT 1
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: PUSH
86998: LD_INT 3
87000: NEG
87001: PUSH
87002: LD_INT 0
87004: PUSH
87005: EMPTY
87006: LIST
87007: LIST
87008: PUSH
87009: LD_INT 3
87011: NEG
87012: PUSH
87013: LD_INT 1
87015: NEG
87016: PUSH
87017: EMPTY
87018: LIST
87019: LIST
87020: PUSH
87021: LD_INT 3
87023: NEG
87024: PUSH
87025: LD_INT 2
87027: NEG
87028: PUSH
87029: EMPTY
87030: LIST
87031: LIST
87032: PUSH
87033: LD_INT 3
87035: NEG
87036: PUSH
87037: LD_INT 3
87039: NEG
87040: PUSH
87041: EMPTY
87042: LIST
87043: LIST
87044: PUSH
87045: EMPTY
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: LIST
87056: LIST
87057: LIST
87058: LIST
87059: LIST
87060: LIST
87061: LIST
87062: LIST
87063: LIST
87064: LIST
87065: LIST
87066: LIST
87067: LIST
87068: LIST
87069: LIST
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87076: LD_ADDR_VAR 0 42
87080: PUSH
87081: LD_INT 0
87083: PUSH
87084: LD_INT 0
87086: PUSH
87087: EMPTY
87088: LIST
87089: LIST
87090: PUSH
87091: LD_INT 0
87093: PUSH
87094: LD_INT 1
87096: NEG
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PUSH
87102: LD_INT 1
87104: PUSH
87105: LD_INT 0
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 1
87114: PUSH
87115: LD_INT 1
87117: PUSH
87118: EMPTY
87119: LIST
87120: LIST
87121: PUSH
87122: LD_INT 0
87124: PUSH
87125: LD_INT 1
87127: PUSH
87128: EMPTY
87129: LIST
87130: LIST
87131: PUSH
87132: LD_INT 1
87134: NEG
87135: PUSH
87136: LD_INT 0
87138: PUSH
87139: EMPTY
87140: LIST
87141: LIST
87142: PUSH
87143: LD_INT 1
87145: NEG
87146: PUSH
87147: LD_INT 1
87149: NEG
87150: PUSH
87151: EMPTY
87152: LIST
87153: LIST
87154: PUSH
87155: LD_INT 1
87157: NEG
87158: PUSH
87159: LD_INT 2
87161: NEG
87162: PUSH
87163: EMPTY
87164: LIST
87165: LIST
87166: PUSH
87167: LD_INT 0
87169: PUSH
87170: LD_INT 2
87172: NEG
87173: PUSH
87174: EMPTY
87175: LIST
87176: LIST
87177: PUSH
87178: LD_INT 1
87180: PUSH
87181: LD_INT 1
87183: NEG
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 2
87191: PUSH
87192: LD_INT 1
87194: PUSH
87195: EMPTY
87196: LIST
87197: LIST
87198: PUSH
87199: LD_INT 2
87201: PUSH
87202: LD_INT 2
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 1
87211: PUSH
87212: LD_INT 2
87214: PUSH
87215: EMPTY
87216: LIST
87217: LIST
87218: PUSH
87219: LD_INT 0
87221: PUSH
87222: LD_INT 2
87224: PUSH
87225: EMPTY
87226: LIST
87227: LIST
87228: PUSH
87229: LD_INT 1
87231: NEG
87232: PUSH
87233: LD_INT 1
87235: PUSH
87236: EMPTY
87237: LIST
87238: LIST
87239: PUSH
87240: LD_INT 2
87242: NEG
87243: PUSH
87244: LD_INT 1
87246: NEG
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: PUSH
87252: LD_INT 2
87254: NEG
87255: PUSH
87256: LD_INT 2
87258: NEG
87259: PUSH
87260: EMPTY
87261: LIST
87262: LIST
87263: PUSH
87264: LD_INT 2
87266: NEG
87267: PUSH
87268: LD_INT 3
87270: NEG
87271: PUSH
87272: EMPTY
87273: LIST
87274: LIST
87275: PUSH
87276: LD_INT 1
87278: NEG
87279: PUSH
87280: LD_INT 3
87282: NEG
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 0
87290: PUSH
87291: LD_INT 3
87293: NEG
87294: PUSH
87295: EMPTY
87296: LIST
87297: LIST
87298: PUSH
87299: LD_INT 1
87301: PUSH
87302: LD_INT 2
87304: NEG
87305: PUSH
87306: EMPTY
87307: LIST
87308: LIST
87309: PUSH
87310: LD_INT 3
87312: PUSH
87313: LD_INT 2
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: PUSH
87320: LD_INT 3
87322: PUSH
87323: LD_INT 3
87325: PUSH
87326: EMPTY
87327: LIST
87328: LIST
87329: PUSH
87330: LD_INT 2
87332: PUSH
87333: LD_INT 3
87335: PUSH
87336: EMPTY
87337: LIST
87338: LIST
87339: PUSH
87340: LD_INT 1
87342: PUSH
87343: LD_INT 3
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 0
87352: PUSH
87353: LD_INT 3
87355: PUSH
87356: EMPTY
87357: LIST
87358: LIST
87359: PUSH
87360: LD_INT 1
87362: NEG
87363: PUSH
87364: LD_INT 2
87366: PUSH
87367: EMPTY
87368: LIST
87369: LIST
87370: PUSH
87371: LD_INT 3
87373: NEG
87374: PUSH
87375: LD_INT 2
87377: NEG
87378: PUSH
87379: EMPTY
87380: LIST
87381: LIST
87382: PUSH
87383: LD_INT 3
87385: NEG
87386: PUSH
87387: LD_INT 3
87389: NEG
87390: PUSH
87391: EMPTY
87392: LIST
87393: LIST
87394: PUSH
87395: EMPTY
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: LIST
87422: LIST
87423: LIST
87424: LIST
87425: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87426: LD_ADDR_VAR 0 43
87430: PUSH
87431: LD_INT 0
87433: PUSH
87434: LD_INT 0
87436: PUSH
87437: EMPTY
87438: LIST
87439: LIST
87440: PUSH
87441: LD_INT 0
87443: PUSH
87444: LD_INT 1
87446: NEG
87447: PUSH
87448: EMPTY
87449: LIST
87450: LIST
87451: PUSH
87452: LD_INT 1
87454: PUSH
87455: LD_INT 0
87457: PUSH
87458: EMPTY
87459: LIST
87460: LIST
87461: PUSH
87462: LD_INT 1
87464: PUSH
87465: LD_INT 1
87467: PUSH
87468: EMPTY
87469: LIST
87470: LIST
87471: PUSH
87472: LD_INT 0
87474: PUSH
87475: LD_INT 1
87477: PUSH
87478: EMPTY
87479: LIST
87480: LIST
87481: PUSH
87482: LD_INT 1
87484: NEG
87485: PUSH
87486: LD_INT 0
87488: PUSH
87489: EMPTY
87490: LIST
87491: LIST
87492: PUSH
87493: LD_INT 1
87495: NEG
87496: PUSH
87497: LD_INT 1
87499: NEG
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: PUSH
87505: LD_INT 1
87507: NEG
87508: PUSH
87509: LD_INT 2
87511: NEG
87512: PUSH
87513: EMPTY
87514: LIST
87515: LIST
87516: PUSH
87517: LD_INT 0
87519: PUSH
87520: LD_INT 2
87522: NEG
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 1
87530: PUSH
87531: LD_INT 1
87533: NEG
87534: PUSH
87535: EMPTY
87536: LIST
87537: LIST
87538: PUSH
87539: LD_INT 2
87541: PUSH
87542: LD_INT 0
87544: PUSH
87545: EMPTY
87546: LIST
87547: LIST
87548: PUSH
87549: LD_INT 2
87551: PUSH
87552: LD_INT 1
87554: PUSH
87555: EMPTY
87556: LIST
87557: LIST
87558: PUSH
87559: LD_INT 1
87561: PUSH
87562: LD_INT 2
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PUSH
87569: LD_INT 0
87571: PUSH
87572: LD_INT 2
87574: PUSH
87575: EMPTY
87576: LIST
87577: LIST
87578: PUSH
87579: LD_INT 1
87581: NEG
87582: PUSH
87583: LD_INT 1
87585: PUSH
87586: EMPTY
87587: LIST
87588: LIST
87589: PUSH
87590: LD_INT 2
87592: NEG
87593: PUSH
87594: LD_INT 0
87596: PUSH
87597: EMPTY
87598: LIST
87599: LIST
87600: PUSH
87601: LD_INT 2
87603: NEG
87604: PUSH
87605: LD_INT 1
87607: NEG
87608: PUSH
87609: EMPTY
87610: LIST
87611: LIST
87612: PUSH
87613: LD_INT 1
87615: NEG
87616: PUSH
87617: LD_INT 3
87619: NEG
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: PUSH
87625: LD_INT 0
87627: PUSH
87628: LD_INT 3
87630: NEG
87631: PUSH
87632: EMPTY
87633: LIST
87634: LIST
87635: PUSH
87636: LD_INT 1
87638: PUSH
87639: LD_INT 2
87641: NEG
87642: PUSH
87643: EMPTY
87644: LIST
87645: LIST
87646: PUSH
87647: LD_INT 2
87649: PUSH
87650: LD_INT 1
87652: NEG
87653: PUSH
87654: EMPTY
87655: LIST
87656: LIST
87657: PUSH
87658: LD_INT 3
87660: PUSH
87661: LD_INT 0
87663: PUSH
87664: EMPTY
87665: LIST
87666: LIST
87667: PUSH
87668: LD_INT 3
87670: PUSH
87671: LD_INT 1
87673: PUSH
87674: EMPTY
87675: LIST
87676: LIST
87677: PUSH
87678: LD_INT 1
87680: PUSH
87681: LD_INT 3
87683: PUSH
87684: EMPTY
87685: LIST
87686: LIST
87687: PUSH
87688: LD_INT 0
87690: PUSH
87691: LD_INT 3
87693: PUSH
87694: EMPTY
87695: LIST
87696: LIST
87697: PUSH
87698: LD_INT 1
87700: NEG
87701: PUSH
87702: LD_INT 2
87704: PUSH
87705: EMPTY
87706: LIST
87707: LIST
87708: PUSH
87709: LD_INT 2
87711: NEG
87712: PUSH
87713: LD_INT 1
87715: PUSH
87716: EMPTY
87717: LIST
87718: LIST
87719: PUSH
87720: LD_INT 3
87722: NEG
87723: PUSH
87724: LD_INT 0
87726: PUSH
87727: EMPTY
87728: LIST
87729: LIST
87730: PUSH
87731: LD_INT 3
87733: NEG
87734: PUSH
87735: LD_INT 1
87737: NEG
87738: PUSH
87739: EMPTY
87740: LIST
87741: LIST
87742: PUSH
87743: EMPTY
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: LIST
87758: LIST
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87774: LD_ADDR_VAR 0 44
87778: PUSH
87779: LD_INT 0
87781: PUSH
87782: LD_INT 0
87784: PUSH
87785: EMPTY
87786: LIST
87787: LIST
87788: PUSH
87789: LD_INT 0
87791: PUSH
87792: LD_INT 1
87794: NEG
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 1
87802: PUSH
87803: LD_INT 0
87805: PUSH
87806: EMPTY
87807: LIST
87808: LIST
87809: PUSH
87810: LD_INT 1
87812: PUSH
87813: LD_INT 1
87815: PUSH
87816: EMPTY
87817: LIST
87818: LIST
87819: PUSH
87820: LD_INT 0
87822: PUSH
87823: LD_INT 1
87825: PUSH
87826: EMPTY
87827: LIST
87828: LIST
87829: PUSH
87830: LD_INT 1
87832: NEG
87833: PUSH
87834: LD_INT 0
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: PUSH
87841: LD_INT 1
87843: NEG
87844: PUSH
87845: LD_INT 1
87847: NEG
87848: PUSH
87849: EMPTY
87850: LIST
87851: LIST
87852: PUSH
87853: LD_INT 1
87855: NEG
87856: PUSH
87857: LD_INT 2
87859: NEG
87860: PUSH
87861: EMPTY
87862: LIST
87863: LIST
87864: PUSH
87865: LD_INT 1
87867: PUSH
87868: LD_INT 1
87870: NEG
87871: PUSH
87872: EMPTY
87873: LIST
87874: LIST
87875: PUSH
87876: LD_INT 2
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 2
87888: PUSH
87889: LD_INT 1
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: PUSH
87896: LD_INT 2
87898: PUSH
87899: LD_INT 2
87901: PUSH
87902: EMPTY
87903: LIST
87904: LIST
87905: PUSH
87906: LD_INT 1
87908: PUSH
87909: LD_INT 2
87911: PUSH
87912: EMPTY
87913: LIST
87914: LIST
87915: PUSH
87916: LD_INT 1
87918: NEG
87919: PUSH
87920: LD_INT 1
87922: PUSH
87923: EMPTY
87924: LIST
87925: LIST
87926: PUSH
87927: LD_INT 2
87929: NEG
87930: PUSH
87931: LD_INT 0
87933: PUSH
87934: EMPTY
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 2
87940: NEG
87941: PUSH
87942: LD_INT 1
87944: NEG
87945: PUSH
87946: EMPTY
87947: LIST
87948: LIST
87949: PUSH
87950: LD_INT 2
87952: NEG
87953: PUSH
87954: LD_INT 2
87956: NEG
87957: PUSH
87958: EMPTY
87959: LIST
87960: LIST
87961: PUSH
87962: LD_INT 2
87964: NEG
87965: PUSH
87966: LD_INT 3
87968: NEG
87969: PUSH
87970: EMPTY
87971: LIST
87972: LIST
87973: PUSH
87974: LD_INT 2
87976: PUSH
87977: LD_INT 1
87979: NEG
87980: PUSH
87981: EMPTY
87982: LIST
87983: LIST
87984: PUSH
87985: LD_INT 3
87987: PUSH
87988: LD_INT 0
87990: PUSH
87991: EMPTY
87992: LIST
87993: LIST
87994: PUSH
87995: LD_INT 3
87997: PUSH
87998: LD_INT 1
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PUSH
88005: LD_INT 3
88007: PUSH
88008: LD_INT 2
88010: PUSH
88011: EMPTY
88012: LIST
88013: LIST
88014: PUSH
88015: LD_INT 3
88017: PUSH
88018: LD_INT 3
88020: PUSH
88021: EMPTY
88022: LIST
88023: LIST
88024: PUSH
88025: LD_INT 2
88027: PUSH
88028: LD_INT 3
88030: PUSH
88031: EMPTY
88032: LIST
88033: LIST
88034: PUSH
88035: LD_INT 2
88037: NEG
88038: PUSH
88039: LD_INT 1
88041: PUSH
88042: EMPTY
88043: LIST
88044: LIST
88045: PUSH
88046: LD_INT 3
88048: NEG
88049: PUSH
88050: LD_INT 0
88052: PUSH
88053: EMPTY
88054: LIST
88055: LIST
88056: PUSH
88057: LD_INT 3
88059: NEG
88060: PUSH
88061: LD_INT 1
88063: NEG
88064: PUSH
88065: EMPTY
88066: LIST
88067: LIST
88068: PUSH
88069: LD_INT 3
88071: NEG
88072: PUSH
88073: LD_INT 2
88075: NEG
88076: PUSH
88077: EMPTY
88078: LIST
88079: LIST
88080: PUSH
88081: LD_INT 3
88083: NEG
88084: PUSH
88085: LD_INT 3
88087: NEG
88088: PUSH
88089: EMPTY
88090: LIST
88091: LIST
88092: PUSH
88093: EMPTY
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: LIST
88104: LIST
88105: LIST
88106: LIST
88107: LIST
88108: LIST
88109: LIST
88110: LIST
88111: LIST
88112: LIST
88113: LIST
88114: LIST
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
88124: LD_ADDR_VAR 0 45
88128: PUSH
88129: LD_INT 0
88131: PUSH
88132: LD_INT 0
88134: PUSH
88135: EMPTY
88136: LIST
88137: LIST
88138: PUSH
88139: LD_INT 0
88141: PUSH
88142: LD_INT 1
88144: NEG
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: PUSH
88150: LD_INT 1
88152: PUSH
88153: LD_INT 0
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: LD_INT 1
88162: PUSH
88163: LD_INT 1
88165: PUSH
88166: EMPTY
88167: LIST
88168: LIST
88169: PUSH
88170: LD_INT 0
88172: PUSH
88173: LD_INT 1
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: PUSH
88180: LD_INT 1
88182: NEG
88183: PUSH
88184: LD_INT 0
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 1
88193: NEG
88194: PUSH
88195: LD_INT 1
88197: NEG
88198: PUSH
88199: EMPTY
88200: LIST
88201: LIST
88202: PUSH
88203: LD_INT 1
88205: NEG
88206: PUSH
88207: LD_INT 2
88209: NEG
88210: PUSH
88211: EMPTY
88212: LIST
88213: LIST
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: LD_INT 2
88220: NEG
88221: PUSH
88222: EMPTY
88223: LIST
88224: LIST
88225: PUSH
88226: LD_INT 1
88228: PUSH
88229: LD_INT 1
88231: NEG
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 2
88239: PUSH
88240: LD_INT 1
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 2
88249: PUSH
88250: LD_INT 2
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 1
88259: PUSH
88260: LD_INT 2
88262: PUSH
88263: EMPTY
88264: LIST
88265: LIST
88266: PUSH
88267: LD_INT 0
88269: PUSH
88270: LD_INT 2
88272: PUSH
88273: EMPTY
88274: LIST
88275: LIST
88276: PUSH
88277: LD_INT 1
88279: NEG
88280: PUSH
88281: LD_INT 1
88283: PUSH
88284: EMPTY
88285: LIST
88286: LIST
88287: PUSH
88288: LD_INT 2
88290: NEG
88291: PUSH
88292: LD_INT 1
88294: NEG
88295: PUSH
88296: EMPTY
88297: LIST
88298: LIST
88299: PUSH
88300: LD_INT 2
88302: NEG
88303: PUSH
88304: LD_INT 2
88306: NEG
88307: PUSH
88308: EMPTY
88309: LIST
88310: LIST
88311: PUSH
88312: LD_INT 2
88314: NEG
88315: PUSH
88316: LD_INT 3
88318: NEG
88319: PUSH
88320: EMPTY
88321: LIST
88322: LIST
88323: PUSH
88324: LD_INT 1
88326: NEG
88327: PUSH
88328: LD_INT 3
88330: NEG
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 0
88338: PUSH
88339: LD_INT 3
88341: NEG
88342: PUSH
88343: EMPTY
88344: LIST
88345: LIST
88346: PUSH
88347: LD_INT 1
88349: PUSH
88350: LD_INT 2
88352: NEG
88353: PUSH
88354: EMPTY
88355: LIST
88356: LIST
88357: PUSH
88358: LD_INT 3
88360: PUSH
88361: LD_INT 2
88363: PUSH
88364: EMPTY
88365: LIST
88366: LIST
88367: PUSH
88368: LD_INT 3
88370: PUSH
88371: LD_INT 3
88373: PUSH
88374: EMPTY
88375: LIST
88376: LIST
88377: PUSH
88378: LD_INT 2
88380: PUSH
88381: LD_INT 3
88383: PUSH
88384: EMPTY
88385: LIST
88386: LIST
88387: PUSH
88388: LD_INT 1
88390: PUSH
88391: LD_INT 3
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 0
88400: PUSH
88401: LD_INT 3
88403: PUSH
88404: EMPTY
88405: LIST
88406: LIST
88407: PUSH
88408: LD_INT 1
88410: NEG
88411: PUSH
88412: LD_INT 2
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: PUSH
88419: LD_INT 3
88421: NEG
88422: PUSH
88423: LD_INT 2
88425: NEG
88426: PUSH
88427: EMPTY
88428: LIST
88429: LIST
88430: PUSH
88431: LD_INT 3
88433: NEG
88434: PUSH
88435: LD_INT 3
88437: NEG
88438: PUSH
88439: EMPTY
88440: LIST
88441: LIST
88442: PUSH
88443: EMPTY
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: LIST
88452: LIST
88453: LIST
88454: LIST
88455: LIST
88456: LIST
88457: LIST
88458: LIST
88459: LIST
88460: LIST
88461: LIST
88462: LIST
88463: LIST
88464: LIST
88465: LIST
88466: LIST
88467: LIST
88468: LIST
88469: LIST
88470: LIST
88471: LIST
88472: LIST
88473: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88474: LD_ADDR_VAR 0 46
88478: PUSH
88479: LD_INT 0
88481: PUSH
88482: LD_INT 0
88484: PUSH
88485: EMPTY
88486: LIST
88487: LIST
88488: PUSH
88489: LD_INT 0
88491: PUSH
88492: LD_INT 1
88494: NEG
88495: PUSH
88496: EMPTY
88497: LIST
88498: LIST
88499: PUSH
88500: LD_INT 1
88502: PUSH
88503: LD_INT 0
88505: PUSH
88506: EMPTY
88507: LIST
88508: LIST
88509: PUSH
88510: LD_INT 1
88512: PUSH
88513: LD_INT 1
88515: PUSH
88516: EMPTY
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 0
88522: PUSH
88523: LD_INT 1
88525: PUSH
88526: EMPTY
88527: LIST
88528: LIST
88529: PUSH
88530: LD_INT 1
88532: NEG
88533: PUSH
88534: LD_INT 0
88536: PUSH
88537: EMPTY
88538: LIST
88539: LIST
88540: PUSH
88541: LD_INT 1
88543: NEG
88544: PUSH
88545: LD_INT 1
88547: NEG
88548: PUSH
88549: EMPTY
88550: LIST
88551: LIST
88552: PUSH
88553: LD_INT 1
88555: NEG
88556: PUSH
88557: LD_INT 2
88559: NEG
88560: PUSH
88561: EMPTY
88562: LIST
88563: LIST
88564: PUSH
88565: LD_INT 0
88567: PUSH
88568: LD_INT 2
88570: NEG
88571: PUSH
88572: EMPTY
88573: LIST
88574: LIST
88575: PUSH
88576: LD_INT 1
88578: PUSH
88579: LD_INT 1
88581: NEG
88582: PUSH
88583: EMPTY
88584: LIST
88585: LIST
88586: PUSH
88587: LD_INT 2
88589: PUSH
88590: LD_INT 0
88592: PUSH
88593: EMPTY
88594: LIST
88595: LIST
88596: PUSH
88597: LD_INT 2
88599: PUSH
88600: LD_INT 1
88602: PUSH
88603: EMPTY
88604: LIST
88605: LIST
88606: PUSH
88607: LD_INT 1
88609: PUSH
88610: LD_INT 2
88612: PUSH
88613: EMPTY
88614: LIST
88615: LIST
88616: PUSH
88617: LD_INT 0
88619: PUSH
88620: LD_INT 2
88622: PUSH
88623: EMPTY
88624: LIST
88625: LIST
88626: PUSH
88627: LD_INT 1
88629: NEG
88630: PUSH
88631: LD_INT 1
88633: PUSH
88634: EMPTY
88635: LIST
88636: LIST
88637: PUSH
88638: LD_INT 2
88640: NEG
88641: PUSH
88642: LD_INT 0
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 2
88651: NEG
88652: PUSH
88653: LD_INT 1
88655: NEG
88656: PUSH
88657: EMPTY
88658: LIST
88659: LIST
88660: PUSH
88661: LD_INT 1
88663: NEG
88664: PUSH
88665: LD_INT 3
88667: NEG
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: PUSH
88673: LD_INT 0
88675: PUSH
88676: LD_INT 3
88678: NEG
88679: PUSH
88680: EMPTY
88681: LIST
88682: LIST
88683: PUSH
88684: LD_INT 1
88686: PUSH
88687: LD_INT 2
88689: NEG
88690: PUSH
88691: EMPTY
88692: LIST
88693: LIST
88694: PUSH
88695: LD_INT 2
88697: PUSH
88698: LD_INT 1
88700: NEG
88701: PUSH
88702: EMPTY
88703: LIST
88704: LIST
88705: PUSH
88706: LD_INT 3
88708: PUSH
88709: LD_INT 0
88711: PUSH
88712: EMPTY
88713: LIST
88714: LIST
88715: PUSH
88716: LD_INT 3
88718: PUSH
88719: LD_INT 1
88721: PUSH
88722: EMPTY
88723: LIST
88724: LIST
88725: PUSH
88726: LD_INT 1
88728: PUSH
88729: LD_INT 3
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: PUSH
88736: LD_INT 0
88738: PUSH
88739: LD_INT 3
88741: PUSH
88742: EMPTY
88743: LIST
88744: LIST
88745: PUSH
88746: LD_INT 1
88748: NEG
88749: PUSH
88750: LD_INT 2
88752: PUSH
88753: EMPTY
88754: LIST
88755: LIST
88756: PUSH
88757: LD_INT 2
88759: NEG
88760: PUSH
88761: LD_INT 1
88763: PUSH
88764: EMPTY
88765: LIST
88766: LIST
88767: PUSH
88768: LD_INT 3
88770: NEG
88771: PUSH
88772: LD_INT 0
88774: PUSH
88775: EMPTY
88776: LIST
88777: LIST
88778: PUSH
88779: LD_INT 3
88781: NEG
88782: PUSH
88783: LD_INT 1
88785: NEG
88786: PUSH
88787: EMPTY
88788: LIST
88789: LIST
88790: PUSH
88791: EMPTY
88792: LIST
88793: LIST
88794: LIST
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: LIST
88803: LIST
88804: LIST
88805: LIST
88806: LIST
88807: LIST
88808: LIST
88809: LIST
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: LIST
88821: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88822: LD_ADDR_VAR 0 47
88826: PUSH
88827: LD_INT 0
88829: PUSH
88830: LD_INT 0
88832: PUSH
88833: EMPTY
88834: LIST
88835: LIST
88836: PUSH
88837: LD_INT 0
88839: PUSH
88840: LD_INT 1
88842: NEG
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: PUSH
88848: LD_INT 1
88850: PUSH
88851: LD_INT 0
88853: PUSH
88854: EMPTY
88855: LIST
88856: LIST
88857: PUSH
88858: LD_INT 1
88860: PUSH
88861: LD_INT 1
88863: PUSH
88864: EMPTY
88865: LIST
88866: LIST
88867: PUSH
88868: LD_INT 0
88870: PUSH
88871: LD_INT 1
88873: PUSH
88874: EMPTY
88875: LIST
88876: LIST
88877: PUSH
88878: LD_INT 1
88880: NEG
88881: PUSH
88882: LD_INT 0
88884: PUSH
88885: EMPTY
88886: LIST
88887: LIST
88888: PUSH
88889: LD_INT 1
88891: NEG
88892: PUSH
88893: LD_INT 1
88895: NEG
88896: PUSH
88897: EMPTY
88898: LIST
88899: LIST
88900: PUSH
88901: LD_INT 1
88903: NEG
88904: PUSH
88905: LD_INT 2
88907: NEG
88908: PUSH
88909: EMPTY
88910: LIST
88911: LIST
88912: PUSH
88913: LD_INT 0
88915: PUSH
88916: LD_INT 2
88918: NEG
88919: PUSH
88920: EMPTY
88921: LIST
88922: LIST
88923: PUSH
88924: LD_INT 1
88926: PUSH
88927: LD_INT 1
88929: NEG
88930: PUSH
88931: EMPTY
88932: LIST
88933: LIST
88934: PUSH
88935: LD_INT 2
88937: NEG
88938: PUSH
88939: LD_INT 1
88941: NEG
88942: PUSH
88943: EMPTY
88944: LIST
88945: LIST
88946: PUSH
88947: LD_INT 2
88949: NEG
88950: PUSH
88951: LD_INT 2
88953: NEG
88954: PUSH
88955: EMPTY
88956: LIST
88957: LIST
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: LIST
88963: LIST
88964: LIST
88965: LIST
88966: LIST
88967: LIST
88968: LIST
88969: LIST
88970: LIST
88971: LIST
88972: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88973: LD_ADDR_VAR 0 48
88977: PUSH
88978: LD_INT 0
88980: PUSH
88981: LD_INT 0
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: PUSH
88988: LD_INT 0
88990: PUSH
88991: LD_INT 1
88993: NEG
88994: PUSH
88995: EMPTY
88996: LIST
88997: LIST
88998: PUSH
88999: LD_INT 1
89001: PUSH
89002: LD_INT 0
89004: PUSH
89005: EMPTY
89006: LIST
89007: LIST
89008: PUSH
89009: LD_INT 1
89011: PUSH
89012: LD_INT 1
89014: PUSH
89015: EMPTY
89016: LIST
89017: LIST
89018: PUSH
89019: LD_INT 0
89021: PUSH
89022: LD_INT 1
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: PUSH
89029: LD_INT 1
89031: NEG
89032: PUSH
89033: LD_INT 0
89035: PUSH
89036: EMPTY
89037: LIST
89038: LIST
89039: PUSH
89040: LD_INT 1
89042: NEG
89043: PUSH
89044: LD_INT 1
89046: NEG
89047: PUSH
89048: EMPTY
89049: LIST
89050: LIST
89051: PUSH
89052: LD_INT 1
89054: NEG
89055: PUSH
89056: LD_INT 2
89058: NEG
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 0
89066: PUSH
89067: LD_INT 2
89069: NEG
89070: PUSH
89071: EMPTY
89072: LIST
89073: LIST
89074: PUSH
89075: LD_INT 1
89077: PUSH
89078: LD_INT 1
89080: NEG
89081: PUSH
89082: EMPTY
89083: LIST
89084: LIST
89085: PUSH
89086: LD_INT 2
89088: PUSH
89089: LD_INT 0
89091: PUSH
89092: EMPTY
89093: LIST
89094: LIST
89095: PUSH
89096: LD_INT 2
89098: PUSH
89099: LD_INT 1
89101: PUSH
89102: EMPTY
89103: LIST
89104: LIST
89105: PUSH
89106: EMPTY
89107: LIST
89108: LIST
89109: LIST
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
89120: LD_ADDR_VAR 0 49
89124: PUSH
89125: LD_INT 0
89127: PUSH
89128: LD_INT 0
89130: PUSH
89131: EMPTY
89132: LIST
89133: LIST
89134: PUSH
89135: LD_INT 0
89137: PUSH
89138: LD_INT 1
89140: NEG
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: PUSH
89146: LD_INT 1
89148: PUSH
89149: LD_INT 0
89151: PUSH
89152: EMPTY
89153: LIST
89154: LIST
89155: PUSH
89156: LD_INT 1
89158: PUSH
89159: LD_INT 1
89161: PUSH
89162: EMPTY
89163: LIST
89164: LIST
89165: PUSH
89166: LD_INT 0
89168: PUSH
89169: LD_INT 1
89171: PUSH
89172: EMPTY
89173: LIST
89174: LIST
89175: PUSH
89176: LD_INT 1
89178: NEG
89179: PUSH
89180: LD_INT 0
89182: PUSH
89183: EMPTY
89184: LIST
89185: LIST
89186: PUSH
89187: LD_INT 1
89189: NEG
89190: PUSH
89191: LD_INT 1
89193: NEG
89194: PUSH
89195: EMPTY
89196: LIST
89197: LIST
89198: PUSH
89199: LD_INT 1
89201: PUSH
89202: LD_INT 1
89204: NEG
89205: PUSH
89206: EMPTY
89207: LIST
89208: LIST
89209: PUSH
89210: LD_INT 2
89212: PUSH
89213: LD_INT 0
89215: PUSH
89216: EMPTY
89217: LIST
89218: LIST
89219: PUSH
89220: LD_INT 2
89222: PUSH
89223: LD_INT 1
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: PUSH
89230: LD_INT 2
89232: PUSH
89233: LD_INT 2
89235: PUSH
89236: EMPTY
89237: LIST
89238: LIST
89239: PUSH
89240: LD_INT 1
89242: PUSH
89243: LD_INT 2
89245: PUSH
89246: EMPTY
89247: LIST
89248: LIST
89249: PUSH
89250: EMPTY
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: LIST
89259: LIST
89260: LIST
89261: LIST
89262: LIST
89263: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
89264: LD_ADDR_VAR 0 50
89268: PUSH
89269: LD_INT 0
89271: PUSH
89272: LD_INT 0
89274: PUSH
89275: EMPTY
89276: LIST
89277: LIST
89278: PUSH
89279: LD_INT 0
89281: PUSH
89282: LD_INT 1
89284: NEG
89285: PUSH
89286: EMPTY
89287: LIST
89288: LIST
89289: PUSH
89290: LD_INT 1
89292: PUSH
89293: LD_INT 0
89295: PUSH
89296: EMPTY
89297: LIST
89298: LIST
89299: PUSH
89300: LD_INT 1
89302: PUSH
89303: LD_INT 1
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 0
89312: PUSH
89313: LD_INT 1
89315: PUSH
89316: EMPTY
89317: LIST
89318: LIST
89319: PUSH
89320: LD_INT 1
89322: NEG
89323: PUSH
89324: LD_INT 0
89326: PUSH
89327: EMPTY
89328: LIST
89329: LIST
89330: PUSH
89331: LD_INT 1
89333: NEG
89334: PUSH
89335: LD_INT 1
89337: NEG
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: PUSH
89343: LD_INT 2
89345: PUSH
89346: LD_INT 1
89348: PUSH
89349: EMPTY
89350: LIST
89351: LIST
89352: PUSH
89353: LD_INT 2
89355: PUSH
89356: LD_INT 2
89358: PUSH
89359: EMPTY
89360: LIST
89361: LIST
89362: PUSH
89363: LD_INT 1
89365: PUSH
89366: LD_INT 2
89368: PUSH
89369: EMPTY
89370: LIST
89371: LIST
89372: PUSH
89373: LD_INT 0
89375: PUSH
89376: LD_INT 2
89378: PUSH
89379: EMPTY
89380: LIST
89381: LIST
89382: PUSH
89383: LD_INT 1
89385: NEG
89386: PUSH
89387: LD_INT 1
89389: PUSH
89390: EMPTY
89391: LIST
89392: LIST
89393: PUSH
89394: EMPTY
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89408: LD_ADDR_VAR 0 51
89412: PUSH
89413: LD_INT 0
89415: PUSH
89416: LD_INT 0
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: PUSH
89423: LD_INT 0
89425: PUSH
89426: LD_INT 1
89428: NEG
89429: PUSH
89430: EMPTY
89431: LIST
89432: LIST
89433: PUSH
89434: LD_INT 1
89436: PUSH
89437: LD_INT 0
89439: PUSH
89440: EMPTY
89441: LIST
89442: LIST
89443: PUSH
89444: LD_INT 1
89446: PUSH
89447: LD_INT 1
89449: PUSH
89450: EMPTY
89451: LIST
89452: LIST
89453: PUSH
89454: LD_INT 0
89456: PUSH
89457: LD_INT 1
89459: PUSH
89460: EMPTY
89461: LIST
89462: LIST
89463: PUSH
89464: LD_INT 1
89466: NEG
89467: PUSH
89468: LD_INT 0
89470: PUSH
89471: EMPTY
89472: LIST
89473: LIST
89474: PUSH
89475: LD_INT 1
89477: NEG
89478: PUSH
89479: LD_INT 1
89481: NEG
89482: PUSH
89483: EMPTY
89484: LIST
89485: LIST
89486: PUSH
89487: LD_INT 1
89489: PUSH
89490: LD_INT 2
89492: PUSH
89493: EMPTY
89494: LIST
89495: LIST
89496: PUSH
89497: LD_INT 0
89499: PUSH
89500: LD_INT 2
89502: PUSH
89503: EMPTY
89504: LIST
89505: LIST
89506: PUSH
89507: LD_INT 1
89509: NEG
89510: PUSH
89511: LD_INT 1
89513: PUSH
89514: EMPTY
89515: LIST
89516: LIST
89517: PUSH
89518: LD_INT 2
89520: NEG
89521: PUSH
89522: LD_INT 0
89524: PUSH
89525: EMPTY
89526: LIST
89527: LIST
89528: PUSH
89529: LD_INT 2
89531: NEG
89532: PUSH
89533: LD_INT 1
89535: NEG
89536: PUSH
89537: EMPTY
89538: LIST
89539: LIST
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: LIST
89545: LIST
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89555: LD_ADDR_VAR 0 52
89559: PUSH
89560: LD_INT 0
89562: PUSH
89563: LD_INT 0
89565: PUSH
89566: EMPTY
89567: LIST
89568: LIST
89569: PUSH
89570: LD_INT 0
89572: PUSH
89573: LD_INT 1
89575: NEG
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 1
89583: PUSH
89584: LD_INT 0
89586: PUSH
89587: EMPTY
89588: LIST
89589: LIST
89590: PUSH
89591: LD_INT 1
89593: PUSH
89594: LD_INT 1
89596: PUSH
89597: EMPTY
89598: LIST
89599: LIST
89600: PUSH
89601: LD_INT 0
89603: PUSH
89604: LD_INT 1
89606: PUSH
89607: EMPTY
89608: LIST
89609: LIST
89610: PUSH
89611: LD_INT 1
89613: NEG
89614: PUSH
89615: LD_INT 0
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: LD_INT 1
89624: NEG
89625: PUSH
89626: LD_INT 1
89628: NEG
89629: PUSH
89630: EMPTY
89631: LIST
89632: LIST
89633: PUSH
89634: LD_INT 1
89636: NEG
89637: PUSH
89638: LD_INT 2
89640: NEG
89641: PUSH
89642: EMPTY
89643: LIST
89644: LIST
89645: PUSH
89646: LD_INT 1
89648: NEG
89649: PUSH
89650: LD_INT 1
89652: PUSH
89653: EMPTY
89654: LIST
89655: LIST
89656: PUSH
89657: LD_INT 2
89659: NEG
89660: PUSH
89661: LD_INT 0
89663: PUSH
89664: EMPTY
89665: LIST
89666: LIST
89667: PUSH
89668: LD_INT 2
89670: NEG
89671: PUSH
89672: LD_INT 1
89674: NEG
89675: PUSH
89676: EMPTY
89677: LIST
89678: LIST
89679: PUSH
89680: LD_INT 2
89682: NEG
89683: PUSH
89684: LD_INT 2
89686: NEG
89687: PUSH
89688: EMPTY
89689: LIST
89690: LIST
89691: PUSH
89692: EMPTY
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: LIST
89698: LIST
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89706: LD_ADDR_VAR 0 53
89710: PUSH
89711: LD_INT 0
89713: PUSH
89714: LD_INT 0
89716: PUSH
89717: EMPTY
89718: LIST
89719: LIST
89720: PUSH
89721: LD_INT 0
89723: PUSH
89724: LD_INT 1
89726: NEG
89727: PUSH
89728: EMPTY
89729: LIST
89730: LIST
89731: PUSH
89732: LD_INT 1
89734: PUSH
89735: LD_INT 0
89737: PUSH
89738: EMPTY
89739: LIST
89740: LIST
89741: PUSH
89742: LD_INT 1
89744: PUSH
89745: LD_INT 1
89747: PUSH
89748: EMPTY
89749: LIST
89750: LIST
89751: PUSH
89752: LD_INT 0
89754: PUSH
89755: LD_INT 1
89757: PUSH
89758: EMPTY
89759: LIST
89760: LIST
89761: PUSH
89762: LD_INT 1
89764: NEG
89765: PUSH
89766: LD_INT 0
89768: PUSH
89769: EMPTY
89770: LIST
89771: LIST
89772: PUSH
89773: LD_INT 1
89775: NEG
89776: PUSH
89777: LD_INT 1
89779: NEG
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: PUSH
89785: LD_INT 1
89787: NEG
89788: PUSH
89789: LD_INT 2
89791: NEG
89792: PUSH
89793: EMPTY
89794: LIST
89795: LIST
89796: PUSH
89797: LD_INT 0
89799: PUSH
89800: LD_INT 2
89802: NEG
89803: PUSH
89804: EMPTY
89805: LIST
89806: LIST
89807: PUSH
89808: LD_INT 1
89810: PUSH
89811: LD_INT 1
89813: NEG
89814: PUSH
89815: EMPTY
89816: LIST
89817: LIST
89818: PUSH
89819: LD_INT 2
89821: PUSH
89822: LD_INT 0
89824: PUSH
89825: EMPTY
89826: LIST
89827: LIST
89828: PUSH
89829: LD_INT 2
89831: PUSH
89832: LD_INT 1
89834: PUSH
89835: EMPTY
89836: LIST
89837: LIST
89838: PUSH
89839: LD_INT 2
89841: PUSH
89842: LD_INT 2
89844: PUSH
89845: EMPTY
89846: LIST
89847: LIST
89848: PUSH
89849: LD_INT 1
89851: PUSH
89852: LD_INT 2
89854: PUSH
89855: EMPTY
89856: LIST
89857: LIST
89858: PUSH
89859: LD_INT 0
89861: PUSH
89862: LD_INT 2
89864: PUSH
89865: EMPTY
89866: LIST
89867: LIST
89868: PUSH
89869: LD_INT 1
89871: NEG
89872: PUSH
89873: LD_INT 1
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: PUSH
89880: LD_INT 2
89882: NEG
89883: PUSH
89884: LD_INT 0
89886: PUSH
89887: EMPTY
89888: LIST
89889: LIST
89890: PUSH
89891: LD_INT 2
89893: NEG
89894: PUSH
89895: LD_INT 1
89897: NEG
89898: PUSH
89899: EMPTY
89900: LIST
89901: LIST
89902: PUSH
89903: LD_INT 2
89905: NEG
89906: PUSH
89907: LD_INT 2
89909: NEG
89910: PUSH
89911: EMPTY
89912: LIST
89913: LIST
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: LIST
89929: LIST
89930: LIST
89931: LIST
89932: LIST
89933: LIST
89934: LIST
89935: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89936: LD_ADDR_VAR 0 54
89940: PUSH
89941: LD_INT 0
89943: PUSH
89944: LD_INT 0
89946: PUSH
89947: EMPTY
89948: LIST
89949: LIST
89950: PUSH
89951: LD_INT 0
89953: PUSH
89954: LD_INT 1
89956: NEG
89957: PUSH
89958: EMPTY
89959: LIST
89960: LIST
89961: PUSH
89962: LD_INT 1
89964: PUSH
89965: LD_INT 0
89967: PUSH
89968: EMPTY
89969: LIST
89970: LIST
89971: PUSH
89972: LD_INT 1
89974: PUSH
89975: LD_INT 1
89977: PUSH
89978: EMPTY
89979: LIST
89980: LIST
89981: PUSH
89982: LD_INT 0
89984: PUSH
89985: LD_INT 1
89987: PUSH
89988: EMPTY
89989: LIST
89990: LIST
89991: PUSH
89992: LD_INT 1
89994: NEG
89995: PUSH
89996: LD_INT 0
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: PUSH
90003: LD_INT 1
90005: NEG
90006: PUSH
90007: LD_INT 1
90009: NEG
90010: PUSH
90011: EMPTY
90012: LIST
90013: LIST
90014: PUSH
90015: LD_INT 1
90017: NEG
90018: PUSH
90019: LD_INT 2
90021: NEG
90022: PUSH
90023: EMPTY
90024: LIST
90025: LIST
90026: PUSH
90027: LD_INT 0
90029: PUSH
90030: LD_INT 2
90032: NEG
90033: PUSH
90034: EMPTY
90035: LIST
90036: LIST
90037: PUSH
90038: LD_INT 1
90040: PUSH
90041: LD_INT 1
90043: NEG
90044: PUSH
90045: EMPTY
90046: LIST
90047: LIST
90048: PUSH
90049: LD_INT 2
90051: PUSH
90052: LD_INT 0
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: LD_INT 2
90061: PUSH
90062: LD_INT 1
90064: PUSH
90065: EMPTY
90066: LIST
90067: LIST
90068: PUSH
90069: LD_INT 2
90071: PUSH
90072: LD_INT 2
90074: PUSH
90075: EMPTY
90076: LIST
90077: LIST
90078: PUSH
90079: LD_INT 1
90081: PUSH
90082: LD_INT 2
90084: PUSH
90085: EMPTY
90086: LIST
90087: LIST
90088: PUSH
90089: LD_INT 0
90091: PUSH
90092: LD_INT 2
90094: PUSH
90095: EMPTY
90096: LIST
90097: LIST
90098: PUSH
90099: LD_INT 1
90101: NEG
90102: PUSH
90103: LD_INT 1
90105: PUSH
90106: EMPTY
90107: LIST
90108: LIST
90109: PUSH
90110: LD_INT 2
90112: NEG
90113: PUSH
90114: LD_INT 0
90116: PUSH
90117: EMPTY
90118: LIST
90119: LIST
90120: PUSH
90121: LD_INT 2
90123: NEG
90124: PUSH
90125: LD_INT 1
90127: NEG
90128: PUSH
90129: EMPTY
90130: LIST
90131: LIST
90132: PUSH
90133: LD_INT 2
90135: NEG
90136: PUSH
90137: LD_INT 2
90139: NEG
90140: PUSH
90141: EMPTY
90142: LIST
90143: LIST
90144: PUSH
90145: EMPTY
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: LIST
90154: LIST
90155: LIST
90156: LIST
90157: LIST
90158: LIST
90159: LIST
90160: LIST
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90166: LD_ADDR_VAR 0 55
90170: PUSH
90171: LD_INT 0
90173: PUSH
90174: LD_INT 0
90176: PUSH
90177: EMPTY
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 0
90183: PUSH
90184: LD_INT 1
90186: NEG
90187: PUSH
90188: EMPTY
90189: LIST
90190: LIST
90191: PUSH
90192: LD_INT 1
90194: PUSH
90195: LD_INT 0
90197: PUSH
90198: EMPTY
90199: LIST
90200: LIST
90201: PUSH
90202: LD_INT 1
90204: PUSH
90205: LD_INT 1
90207: PUSH
90208: EMPTY
90209: LIST
90210: LIST
90211: PUSH
90212: LD_INT 0
90214: PUSH
90215: LD_INT 1
90217: PUSH
90218: EMPTY
90219: LIST
90220: LIST
90221: PUSH
90222: LD_INT 1
90224: NEG
90225: PUSH
90226: LD_INT 0
90228: PUSH
90229: EMPTY
90230: LIST
90231: LIST
90232: PUSH
90233: LD_INT 1
90235: NEG
90236: PUSH
90237: LD_INT 1
90239: NEG
90240: PUSH
90241: EMPTY
90242: LIST
90243: LIST
90244: PUSH
90245: LD_INT 1
90247: NEG
90248: PUSH
90249: LD_INT 2
90251: NEG
90252: PUSH
90253: EMPTY
90254: LIST
90255: LIST
90256: PUSH
90257: LD_INT 0
90259: PUSH
90260: LD_INT 2
90262: NEG
90263: PUSH
90264: EMPTY
90265: LIST
90266: LIST
90267: PUSH
90268: LD_INT 1
90270: PUSH
90271: LD_INT 1
90273: NEG
90274: PUSH
90275: EMPTY
90276: LIST
90277: LIST
90278: PUSH
90279: LD_INT 2
90281: PUSH
90282: LD_INT 0
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: PUSH
90289: LD_INT 2
90291: PUSH
90292: LD_INT 1
90294: PUSH
90295: EMPTY
90296: LIST
90297: LIST
90298: PUSH
90299: LD_INT 2
90301: PUSH
90302: LD_INT 2
90304: PUSH
90305: EMPTY
90306: LIST
90307: LIST
90308: PUSH
90309: LD_INT 1
90311: PUSH
90312: LD_INT 2
90314: PUSH
90315: EMPTY
90316: LIST
90317: LIST
90318: PUSH
90319: LD_INT 0
90321: PUSH
90322: LD_INT 2
90324: PUSH
90325: EMPTY
90326: LIST
90327: LIST
90328: PUSH
90329: LD_INT 1
90331: NEG
90332: PUSH
90333: LD_INT 1
90335: PUSH
90336: EMPTY
90337: LIST
90338: LIST
90339: PUSH
90340: LD_INT 2
90342: NEG
90343: PUSH
90344: LD_INT 0
90346: PUSH
90347: EMPTY
90348: LIST
90349: LIST
90350: PUSH
90351: LD_INT 2
90353: NEG
90354: PUSH
90355: LD_INT 1
90357: NEG
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: PUSH
90363: LD_INT 2
90365: NEG
90366: PUSH
90367: LD_INT 2
90369: NEG
90370: PUSH
90371: EMPTY
90372: LIST
90373: LIST
90374: PUSH
90375: EMPTY
90376: LIST
90377: LIST
90378: LIST
90379: LIST
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: LIST
90385: LIST
90386: LIST
90387: LIST
90388: LIST
90389: LIST
90390: LIST
90391: LIST
90392: LIST
90393: LIST
90394: LIST
90395: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90396: LD_ADDR_VAR 0 56
90400: PUSH
90401: LD_INT 0
90403: PUSH
90404: LD_INT 0
90406: PUSH
90407: EMPTY
90408: LIST
90409: LIST
90410: PUSH
90411: LD_INT 0
90413: PUSH
90414: LD_INT 1
90416: NEG
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: PUSH
90422: LD_INT 1
90424: PUSH
90425: LD_INT 0
90427: PUSH
90428: EMPTY
90429: LIST
90430: LIST
90431: PUSH
90432: LD_INT 1
90434: PUSH
90435: LD_INT 1
90437: PUSH
90438: EMPTY
90439: LIST
90440: LIST
90441: PUSH
90442: LD_INT 0
90444: PUSH
90445: LD_INT 1
90447: PUSH
90448: EMPTY
90449: LIST
90450: LIST
90451: PUSH
90452: LD_INT 1
90454: NEG
90455: PUSH
90456: LD_INT 0
90458: PUSH
90459: EMPTY
90460: LIST
90461: LIST
90462: PUSH
90463: LD_INT 1
90465: NEG
90466: PUSH
90467: LD_INT 1
90469: NEG
90470: PUSH
90471: EMPTY
90472: LIST
90473: LIST
90474: PUSH
90475: LD_INT 1
90477: NEG
90478: PUSH
90479: LD_INT 2
90481: NEG
90482: PUSH
90483: EMPTY
90484: LIST
90485: LIST
90486: PUSH
90487: LD_INT 0
90489: PUSH
90490: LD_INT 2
90492: NEG
90493: PUSH
90494: EMPTY
90495: LIST
90496: LIST
90497: PUSH
90498: LD_INT 1
90500: PUSH
90501: LD_INT 1
90503: NEG
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: PUSH
90509: LD_INT 2
90511: PUSH
90512: LD_INT 0
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 2
90521: PUSH
90522: LD_INT 1
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: LD_INT 2
90531: PUSH
90532: LD_INT 2
90534: PUSH
90535: EMPTY
90536: LIST
90537: LIST
90538: PUSH
90539: LD_INT 1
90541: PUSH
90542: LD_INT 2
90544: PUSH
90545: EMPTY
90546: LIST
90547: LIST
90548: PUSH
90549: LD_INT 0
90551: PUSH
90552: LD_INT 2
90554: PUSH
90555: EMPTY
90556: LIST
90557: LIST
90558: PUSH
90559: LD_INT 1
90561: NEG
90562: PUSH
90563: LD_INT 1
90565: PUSH
90566: EMPTY
90567: LIST
90568: LIST
90569: PUSH
90570: LD_INT 2
90572: NEG
90573: PUSH
90574: LD_INT 0
90576: PUSH
90577: EMPTY
90578: LIST
90579: LIST
90580: PUSH
90581: LD_INT 2
90583: NEG
90584: PUSH
90585: LD_INT 1
90587: NEG
90588: PUSH
90589: EMPTY
90590: LIST
90591: LIST
90592: PUSH
90593: LD_INT 2
90595: NEG
90596: PUSH
90597: LD_INT 2
90599: NEG
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: LIST
90624: LIST
90625: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90626: LD_ADDR_VAR 0 57
90630: PUSH
90631: LD_INT 0
90633: PUSH
90634: LD_INT 0
90636: PUSH
90637: EMPTY
90638: LIST
90639: LIST
90640: PUSH
90641: LD_INT 0
90643: PUSH
90644: LD_INT 1
90646: NEG
90647: PUSH
90648: EMPTY
90649: LIST
90650: LIST
90651: PUSH
90652: LD_INT 1
90654: PUSH
90655: LD_INT 0
90657: PUSH
90658: EMPTY
90659: LIST
90660: LIST
90661: PUSH
90662: LD_INT 1
90664: PUSH
90665: LD_INT 1
90667: PUSH
90668: EMPTY
90669: LIST
90670: LIST
90671: PUSH
90672: LD_INT 0
90674: PUSH
90675: LD_INT 1
90677: PUSH
90678: EMPTY
90679: LIST
90680: LIST
90681: PUSH
90682: LD_INT 1
90684: NEG
90685: PUSH
90686: LD_INT 0
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 1
90695: NEG
90696: PUSH
90697: LD_INT 1
90699: NEG
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: PUSH
90705: LD_INT 1
90707: NEG
90708: PUSH
90709: LD_INT 2
90711: NEG
90712: PUSH
90713: EMPTY
90714: LIST
90715: LIST
90716: PUSH
90717: LD_INT 0
90719: PUSH
90720: LD_INT 2
90722: NEG
90723: PUSH
90724: EMPTY
90725: LIST
90726: LIST
90727: PUSH
90728: LD_INT 1
90730: PUSH
90731: LD_INT 1
90733: NEG
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: PUSH
90739: LD_INT 2
90741: PUSH
90742: LD_INT 0
90744: PUSH
90745: EMPTY
90746: LIST
90747: LIST
90748: PUSH
90749: LD_INT 2
90751: PUSH
90752: LD_INT 1
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: PUSH
90759: LD_INT 2
90761: PUSH
90762: LD_INT 2
90764: PUSH
90765: EMPTY
90766: LIST
90767: LIST
90768: PUSH
90769: LD_INT 1
90771: PUSH
90772: LD_INT 2
90774: PUSH
90775: EMPTY
90776: LIST
90777: LIST
90778: PUSH
90779: LD_INT 0
90781: PUSH
90782: LD_INT 2
90784: PUSH
90785: EMPTY
90786: LIST
90787: LIST
90788: PUSH
90789: LD_INT 1
90791: NEG
90792: PUSH
90793: LD_INT 1
90795: PUSH
90796: EMPTY
90797: LIST
90798: LIST
90799: PUSH
90800: LD_INT 2
90802: NEG
90803: PUSH
90804: LD_INT 0
90806: PUSH
90807: EMPTY
90808: LIST
90809: LIST
90810: PUSH
90811: LD_INT 2
90813: NEG
90814: PUSH
90815: LD_INT 1
90817: NEG
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PUSH
90823: LD_INT 2
90825: NEG
90826: PUSH
90827: LD_INT 2
90829: NEG
90830: PUSH
90831: EMPTY
90832: LIST
90833: LIST
90834: PUSH
90835: EMPTY
90836: LIST
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: LIST
90842: LIST
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90856: LD_ADDR_VAR 0 58
90860: PUSH
90861: LD_INT 0
90863: PUSH
90864: LD_INT 0
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: PUSH
90871: LD_INT 0
90873: PUSH
90874: LD_INT 1
90876: NEG
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: PUSH
90882: LD_INT 1
90884: PUSH
90885: LD_INT 0
90887: PUSH
90888: EMPTY
90889: LIST
90890: LIST
90891: PUSH
90892: LD_INT 1
90894: PUSH
90895: LD_INT 1
90897: PUSH
90898: EMPTY
90899: LIST
90900: LIST
90901: PUSH
90902: LD_INT 0
90904: PUSH
90905: LD_INT 1
90907: PUSH
90908: EMPTY
90909: LIST
90910: LIST
90911: PUSH
90912: LD_INT 1
90914: NEG
90915: PUSH
90916: LD_INT 0
90918: PUSH
90919: EMPTY
90920: LIST
90921: LIST
90922: PUSH
90923: LD_INT 1
90925: NEG
90926: PUSH
90927: LD_INT 1
90929: NEG
90930: PUSH
90931: EMPTY
90932: LIST
90933: LIST
90934: PUSH
90935: LD_INT 1
90937: NEG
90938: PUSH
90939: LD_INT 2
90941: NEG
90942: PUSH
90943: EMPTY
90944: LIST
90945: LIST
90946: PUSH
90947: LD_INT 0
90949: PUSH
90950: LD_INT 2
90952: NEG
90953: PUSH
90954: EMPTY
90955: LIST
90956: LIST
90957: PUSH
90958: LD_INT 1
90960: PUSH
90961: LD_INT 1
90963: NEG
90964: PUSH
90965: EMPTY
90966: LIST
90967: LIST
90968: PUSH
90969: LD_INT 2
90971: PUSH
90972: LD_INT 0
90974: PUSH
90975: EMPTY
90976: LIST
90977: LIST
90978: PUSH
90979: LD_INT 2
90981: PUSH
90982: LD_INT 1
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PUSH
90989: LD_INT 2
90991: PUSH
90992: LD_INT 2
90994: PUSH
90995: EMPTY
90996: LIST
90997: LIST
90998: PUSH
90999: LD_INT 1
91001: PUSH
91002: LD_INT 2
91004: PUSH
91005: EMPTY
91006: LIST
91007: LIST
91008: PUSH
91009: LD_INT 0
91011: PUSH
91012: LD_INT 2
91014: PUSH
91015: EMPTY
91016: LIST
91017: LIST
91018: PUSH
91019: LD_INT 1
91021: NEG
91022: PUSH
91023: LD_INT 1
91025: PUSH
91026: EMPTY
91027: LIST
91028: LIST
91029: PUSH
91030: LD_INT 2
91032: NEG
91033: PUSH
91034: LD_INT 0
91036: PUSH
91037: EMPTY
91038: LIST
91039: LIST
91040: PUSH
91041: LD_INT 2
91043: NEG
91044: PUSH
91045: LD_INT 1
91047: NEG
91048: PUSH
91049: EMPTY
91050: LIST
91051: LIST
91052: PUSH
91053: LD_INT 2
91055: NEG
91056: PUSH
91057: LD_INT 2
91059: NEG
91060: PUSH
91061: EMPTY
91062: LIST
91063: LIST
91064: PUSH
91065: EMPTY
91066: LIST
91067: LIST
91068: LIST
91069: LIST
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: LIST
91075: LIST
91076: LIST
91077: LIST
91078: LIST
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91086: LD_ADDR_VAR 0 59
91090: PUSH
91091: LD_INT 0
91093: PUSH
91094: LD_INT 0
91096: PUSH
91097: EMPTY
91098: LIST
91099: LIST
91100: PUSH
91101: LD_INT 0
91103: PUSH
91104: LD_INT 1
91106: NEG
91107: PUSH
91108: EMPTY
91109: LIST
91110: LIST
91111: PUSH
91112: LD_INT 1
91114: PUSH
91115: LD_INT 0
91117: PUSH
91118: EMPTY
91119: LIST
91120: LIST
91121: PUSH
91122: LD_INT 1
91124: PUSH
91125: LD_INT 1
91127: PUSH
91128: EMPTY
91129: LIST
91130: LIST
91131: PUSH
91132: LD_INT 0
91134: PUSH
91135: LD_INT 1
91137: PUSH
91138: EMPTY
91139: LIST
91140: LIST
91141: PUSH
91142: LD_INT 1
91144: NEG
91145: PUSH
91146: LD_INT 0
91148: PUSH
91149: EMPTY
91150: LIST
91151: LIST
91152: PUSH
91153: LD_INT 1
91155: NEG
91156: PUSH
91157: LD_INT 1
91159: NEG
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: PUSH
91165: EMPTY
91166: LIST
91167: LIST
91168: LIST
91169: LIST
91170: LIST
91171: LIST
91172: LIST
91173: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91174: LD_ADDR_VAR 0 60
91178: PUSH
91179: LD_INT 0
91181: PUSH
91182: LD_INT 0
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: PUSH
91189: LD_INT 0
91191: PUSH
91192: LD_INT 1
91194: NEG
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: PUSH
91200: LD_INT 1
91202: PUSH
91203: LD_INT 0
91205: PUSH
91206: EMPTY
91207: LIST
91208: LIST
91209: PUSH
91210: LD_INT 1
91212: PUSH
91213: LD_INT 1
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: PUSH
91220: LD_INT 0
91222: PUSH
91223: LD_INT 1
91225: PUSH
91226: EMPTY
91227: LIST
91228: LIST
91229: PUSH
91230: LD_INT 1
91232: NEG
91233: PUSH
91234: LD_INT 0
91236: PUSH
91237: EMPTY
91238: LIST
91239: LIST
91240: PUSH
91241: LD_INT 1
91243: NEG
91244: PUSH
91245: LD_INT 1
91247: NEG
91248: PUSH
91249: EMPTY
91250: LIST
91251: LIST
91252: PUSH
91253: EMPTY
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91262: LD_ADDR_VAR 0 61
91266: PUSH
91267: LD_INT 0
91269: PUSH
91270: LD_INT 0
91272: PUSH
91273: EMPTY
91274: LIST
91275: LIST
91276: PUSH
91277: LD_INT 0
91279: PUSH
91280: LD_INT 1
91282: NEG
91283: PUSH
91284: EMPTY
91285: LIST
91286: LIST
91287: PUSH
91288: LD_INT 1
91290: PUSH
91291: LD_INT 0
91293: PUSH
91294: EMPTY
91295: LIST
91296: LIST
91297: PUSH
91298: LD_INT 1
91300: PUSH
91301: LD_INT 1
91303: PUSH
91304: EMPTY
91305: LIST
91306: LIST
91307: PUSH
91308: LD_INT 0
91310: PUSH
91311: LD_INT 1
91313: PUSH
91314: EMPTY
91315: LIST
91316: LIST
91317: PUSH
91318: LD_INT 1
91320: NEG
91321: PUSH
91322: LD_INT 0
91324: PUSH
91325: EMPTY
91326: LIST
91327: LIST
91328: PUSH
91329: LD_INT 1
91331: NEG
91332: PUSH
91333: LD_INT 1
91335: NEG
91336: PUSH
91337: EMPTY
91338: LIST
91339: LIST
91340: PUSH
91341: EMPTY
91342: LIST
91343: LIST
91344: LIST
91345: LIST
91346: LIST
91347: LIST
91348: LIST
91349: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91350: LD_ADDR_VAR 0 62
91354: PUSH
91355: LD_INT 0
91357: PUSH
91358: LD_INT 0
91360: PUSH
91361: EMPTY
91362: LIST
91363: LIST
91364: PUSH
91365: LD_INT 0
91367: PUSH
91368: LD_INT 1
91370: NEG
91371: PUSH
91372: EMPTY
91373: LIST
91374: LIST
91375: PUSH
91376: LD_INT 1
91378: PUSH
91379: LD_INT 0
91381: PUSH
91382: EMPTY
91383: LIST
91384: LIST
91385: PUSH
91386: LD_INT 1
91388: PUSH
91389: LD_INT 1
91391: PUSH
91392: EMPTY
91393: LIST
91394: LIST
91395: PUSH
91396: LD_INT 0
91398: PUSH
91399: LD_INT 1
91401: PUSH
91402: EMPTY
91403: LIST
91404: LIST
91405: PUSH
91406: LD_INT 1
91408: NEG
91409: PUSH
91410: LD_INT 0
91412: PUSH
91413: EMPTY
91414: LIST
91415: LIST
91416: PUSH
91417: LD_INT 1
91419: NEG
91420: PUSH
91421: LD_INT 1
91423: NEG
91424: PUSH
91425: EMPTY
91426: LIST
91427: LIST
91428: PUSH
91429: EMPTY
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91438: LD_ADDR_VAR 0 63
91442: PUSH
91443: LD_INT 0
91445: PUSH
91446: LD_INT 0
91448: PUSH
91449: EMPTY
91450: LIST
91451: LIST
91452: PUSH
91453: LD_INT 0
91455: PUSH
91456: LD_INT 1
91458: NEG
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: PUSH
91464: LD_INT 1
91466: PUSH
91467: LD_INT 0
91469: PUSH
91470: EMPTY
91471: LIST
91472: LIST
91473: PUSH
91474: LD_INT 1
91476: PUSH
91477: LD_INT 1
91479: PUSH
91480: EMPTY
91481: LIST
91482: LIST
91483: PUSH
91484: LD_INT 0
91486: PUSH
91487: LD_INT 1
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: PUSH
91494: LD_INT 1
91496: NEG
91497: PUSH
91498: LD_INT 0
91500: PUSH
91501: EMPTY
91502: LIST
91503: LIST
91504: PUSH
91505: LD_INT 1
91507: NEG
91508: PUSH
91509: LD_INT 1
91511: NEG
91512: PUSH
91513: EMPTY
91514: LIST
91515: LIST
91516: PUSH
91517: EMPTY
91518: LIST
91519: LIST
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: LIST
91525: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91526: LD_ADDR_VAR 0 64
91530: PUSH
91531: LD_INT 0
91533: PUSH
91534: LD_INT 0
91536: PUSH
91537: EMPTY
91538: LIST
91539: LIST
91540: PUSH
91541: LD_INT 0
91543: PUSH
91544: LD_INT 1
91546: NEG
91547: PUSH
91548: EMPTY
91549: LIST
91550: LIST
91551: PUSH
91552: LD_INT 1
91554: PUSH
91555: LD_INT 0
91557: PUSH
91558: EMPTY
91559: LIST
91560: LIST
91561: PUSH
91562: LD_INT 1
91564: PUSH
91565: LD_INT 1
91567: PUSH
91568: EMPTY
91569: LIST
91570: LIST
91571: PUSH
91572: LD_INT 0
91574: PUSH
91575: LD_INT 1
91577: PUSH
91578: EMPTY
91579: LIST
91580: LIST
91581: PUSH
91582: LD_INT 1
91584: NEG
91585: PUSH
91586: LD_INT 0
91588: PUSH
91589: EMPTY
91590: LIST
91591: LIST
91592: PUSH
91593: LD_INT 1
91595: NEG
91596: PUSH
91597: LD_INT 1
91599: NEG
91600: PUSH
91601: EMPTY
91602: LIST
91603: LIST
91604: PUSH
91605: EMPTY
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: ST_TO_ADDR
// end ; 1 :
91614: GO 97511
91616: LD_INT 1
91618: DOUBLE
91619: EQUAL
91620: IFTRUE 91624
91622: GO 94247
91624: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91625: LD_ADDR_VAR 0 11
91629: PUSH
91630: LD_INT 1
91632: NEG
91633: PUSH
91634: LD_INT 3
91636: NEG
91637: PUSH
91638: EMPTY
91639: LIST
91640: LIST
91641: PUSH
91642: LD_INT 0
91644: PUSH
91645: LD_INT 3
91647: NEG
91648: PUSH
91649: EMPTY
91650: LIST
91651: LIST
91652: PUSH
91653: LD_INT 1
91655: PUSH
91656: LD_INT 2
91658: NEG
91659: PUSH
91660: EMPTY
91661: LIST
91662: LIST
91663: PUSH
91664: EMPTY
91665: LIST
91666: LIST
91667: LIST
91668: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91669: LD_ADDR_VAR 0 12
91673: PUSH
91674: LD_INT 2
91676: PUSH
91677: LD_INT 1
91679: NEG
91680: PUSH
91681: EMPTY
91682: LIST
91683: LIST
91684: PUSH
91685: LD_INT 3
91687: PUSH
91688: LD_INT 0
91690: PUSH
91691: EMPTY
91692: LIST
91693: LIST
91694: PUSH
91695: LD_INT 3
91697: PUSH
91698: LD_INT 1
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: LIST
91709: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91710: LD_ADDR_VAR 0 13
91714: PUSH
91715: LD_INT 3
91717: PUSH
91718: LD_INT 2
91720: PUSH
91721: EMPTY
91722: LIST
91723: LIST
91724: PUSH
91725: LD_INT 3
91727: PUSH
91728: LD_INT 3
91730: PUSH
91731: EMPTY
91732: LIST
91733: LIST
91734: PUSH
91735: LD_INT 2
91737: PUSH
91738: LD_INT 3
91740: PUSH
91741: EMPTY
91742: LIST
91743: LIST
91744: PUSH
91745: EMPTY
91746: LIST
91747: LIST
91748: LIST
91749: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91750: LD_ADDR_VAR 0 14
91754: PUSH
91755: LD_INT 1
91757: PUSH
91758: LD_INT 3
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PUSH
91765: LD_INT 0
91767: PUSH
91768: LD_INT 3
91770: PUSH
91771: EMPTY
91772: LIST
91773: LIST
91774: PUSH
91775: LD_INT 1
91777: NEG
91778: PUSH
91779: LD_INT 2
91781: PUSH
91782: EMPTY
91783: LIST
91784: LIST
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: LIST
91790: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91791: LD_ADDR_VAR 0 15
91795: PUSH
91796: LD_INT 2
91798: NEG
91799: PUSH
91800: LD_INT 1
91802: PUSH
91803: EMPTY
91804: LIST
91805: LIST
91806: PUSH
91807: LD_INT 3
91809: NEG
91810: PUSH
91811: LD_INT 0
91813: PUSH
91814: EMPTY
91815: LIST
91816: LIST
91817: PUSH
91818: LD_INT 3
91820: NEG
91821: PUSH
91822: LD_INT 1
91824: NEG
91825: PUSH
91826: EMPTY
91827: LIST
91828: LIST
91829: PUSH
91830: EMPTY
91831: LIST
91832: LIST
91833: LIST
91834: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91835: LD_ADDR_VAR 0 16
91839: PUSH
91840: LD_INT 2
91842: NEG
91843: PUSH
91844: LD_INT 3
91846: NEG
91847: PUSH
91848: EMPTY
91849: LIST
91850: LIST
91851: PUSH
91852: LD_INT 3
91854: NEG
91855: PUSH
91856: LD_INT 2
91858: NEG
91859: PUSH
91860: EMPTY
91861: LIST
91862: LIST
91863: PUSH
91864: LD_INT 3
91866: NEG
91867: PUSH
91868: LD_INT 3
91870: NEG
91871: PUSH
91872: EMPTY
91873: LIST
91874: LIST
91875: PUSH
91876: EMPTY
91877: LIST
91878: LIST
91879: LIST
91880: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91881: LD_ADDR_VAR 0 17
91885: PUSH
91886: LD_INT 1
91888: NEG
91889: PUSH
91890: LD_INT 3
91892: NEG
91893: PUSH
91894: EMPTY
91895: LIST
91896: LIST
91897: PUSH
91898: LD_INT 0
91900: PUSH
91901: LD_INT 3
91903: NEG
91904: PUSH
91905: EMPTY
91906: LIST
91907: LIST
91908: PUSH
91909: LD_INT 1
91911: PUSH
91912: LD_INT 2
91914: NEG
91915: PUSH
91916: EMPTY
91917: LIST
91918: LIST
91919: PUSH
91920: EMPTY
91921: LIST
91922: LIST
91923: LIST
91924: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91925: LD_ADDR_VAR 0 18
91929: PUSH
91930: LD_INT 2
91932: PUSH
91933: LD_INT 1
91935: NEG
91936: PUSH
91937: EMPTY
91938: LIST
91939: LIST
91940: PUSH
91941: LD_INT 3
91943: PUSH
91944: LD_INT 0
91946: PUSH
91947: EMPTY
91948: LIST
91949: LIST
91950: PUSH
91951: LD_INT 3
91953: PUSH
91954: LD_INT 1
91956: PUSH
91957: EMPTY
91958: LIST
91959: LIST
91960: PUSH
91961: EMPTY
91962: LIST
91963: LIST
91964: LIST
91965: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91966: LD_ADDR_VAR 0 19
91970: PUSH
91971: LD_INT 3
91973: PUSH
91974: LD_INT 2
91976: PUSH
91977: EMPTY
91978: LIST
91979: LIST
91980: PUSH
91981: LD_INT 3
91983: PUSH
91984: LD_INT 3
91986: PUSH
91987: EMPTY
91988: LIST
91989: LIST
91990: PUSH
91991: LD_INT 2
91993: PUSH
91994: LD_INT 3
91996: PUSH
91997: EMPTY
91998: LIST
91999: LIST
92000: PUSH
92001: EMPTY
92002: LIST
92003: LIST
92004: LIST
92005: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
92006: LD_ADDR_VAR 0 20
92010: PUSH
92011: LD_INT 1
92013: PUSH
92014: LD_INT 3
92016: PUSH
92017: EMPTY
92018: LIST
92019: LIST
92020: PUSH
92021: LD_INT 0
92023: PUSH
92024: LD_INT 3
92026: PUSH
92027: EMPTY
92028: LIST
92029: LIST
92030: PUSH
92031: LD_INT 1
92033: NEG
92034: PUSH
92035: LD_INT 2
92037: PUSH
92038: EMPTY
92039: LIST
92040: LIST
92041: PUSH
92042: EMPTY
92043: LIST
92044: LIST
92045: LIST
92046: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
92047: LD_ADDR_VAR 0 21
92051: PUSH
92052: LD_INT 2
92054: NEG
92055: PUSH
92056: LD_INT 1
92058: PUSH
92059: EMPTY
92060: LIST
92061: LIST
92062: PUSH
92063: LD_INT 3
92065: NEG
92066: PUSH
92067: LD_INT 0
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 3
92076: NEG
92077: PUSH
92078: LD_INT 1
92080: NEG
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: LIST
92090: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
92091: LD_ADDR_VAR 0 22
92095: PUSH
92096: LD_INT 2
92098: NEG
92099: PUSH
92100: LD_INT 3
92102: NEG
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 3
92110: NEG
92111: PUSH
92112: LD_INT 2
92114: NEG
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: PUSH
92120: LD_INT 3
92122: NEG
92123: PUSH
92124: LD_INT 3
92126: NEG
92127: PUSH
92128: EMPTY
92129: LIST
92130: LIST
92131: PUSH
92132: EMPTY
92133: LIST
92134: LIST
92135: LIST
92136: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
92137: LD_ADDR_VAR 0 23
92141: PUSH
92142: LD_INT 0
92144: PUSH
92145: LD_INT 3
92147: NEG
92148: PUSH
92149: EMPTY
92150: LIST
92151: LIST
92152: PUSH
92153: LD_INT 1
92155: NEG
92156: PUSH
92157: LD_INT 4
92159: NEG
92160: PUSH
92161: EMPTY
92162: LIST
92163: LIST
92164: PUSH
92165: LD_INT 1
92167: PUSH
92168: LD_INT 3
92170: NEG
92171: PUSH
92172: EMPTY
92173: LIST
92174: LIST
92175: PUSH
92176: EMPTY
92177: LIST
92178: LIST
92179: LIST
92180: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
92181: LD_ADDR_VAR 0 24
92185: PUSH
92186: LD_INT 3
92188: PUSH
92189: LD_INT 0
92191: PUSH
92192: EMPTY
92193: LIST
92194: LIST
92195: PUSH
92196: LD_INT 3
92198: PUSH
92199: LD_INT 1
92201: NEG
92202: PUSH
92203: EMPTY
92204: LIST
92205: LIST
92206: PUSH
92207: LD_INT 4
92209: PUSH
92210: LD_INT 1
92212: PUSH
92213: EMPTY
92214: LIST
92215: LIST
92216: PUSH
92217: EMPTY
92218: LIST
92219: LIST
92220: LIST
92221: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
92222: LD_ADDR_VAR 0 25
92226: PUSH
92227: LD_INT 3
92229: PUSH
92230: LD_INT 3
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: PUSH
92237: LD_INT 4
92239: PUSH
92240: LD_INT 3
92242: PUSH
92243: EMPTY
92244: LIST
92245: LIST
92246: PUSH
92247: LD_INT 3
92249: PUSH
92250: LD_INT 4
92252: PUSH
92253: EMPTY
92254: LIST
92255: LIST
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: LIST
92261: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
92262: LD_ADDR_VAR 0 26
92266: PUSH
92267: LD_INT 0
92269: PUSH
92270: LD_INT 3
92272: PUSH
92273: EMPTY
92274: LIST
92275: LIST
92276: PUSH
92277: LD_INT 1
92279: PUSH
92280: LD_INT 4
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: PUSH
92287: LD_INT 1
92289: NEG
92290: PUSH
92291: LD_INT 3
92293: PUSH
92294: EMPTY
92295: LIST
92296: LIST
92297: PUSH
92298: EMPTY
92299: LIST
92300: LIST
92301: LIST
92302: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
92303: LD_ADDR_VAR 0 27
92307: PUSH
92308: LD_INT 3
92310: NEG
92311: PUSH
92312: LD_INT 0
92314: PUSH
92315: EMPTY
92316: LIST
92317: LIST
92318: PUSH
92319: LD_INT 3
92321: NEG
92322: PUSH
92323: LD_INT 1
92325: PUSH
92326: EMPTY
92327: LIST
92328: LIST
92329: PUSH
92330: LD_INT 4
92332: NEG
92333: PUSH
92334: LD_INT 1
92336: NEG
92337: PUSH
92338: EMPTY
92339: LIST
92340: LIST
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: LIST
92346: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
92347: LD_ADDR_VAR 0 28
92351: PUSH
92352: LD_INT 3
92354: NEG
92355: PUSH
92356: LD_INT 3
92358: NEG
92359: PUSH
92360: EMPTY
92361: LIST
92362: LIST
92363: PUSH
92364: LD_INT 3
92366: NEG
92367: PUSH
92368: LD_INT 4
92370: NEG
92371: PUSH
92372: EMPTY
92373: LIST
92374: LIST
92375: PUSH
92376: LD_INT 4
92378: NEG
92379: PUSH
92380: LD_INT 3
92382: NEG
92383: PUSH
92384: EMPTY
92385: LIST
92386: LIST
92387: PUSH
92388: EMPTY
92389: LIST
92390: LIST
92391: LIST
92392: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92393: LD_ADDR_VAR 0 29
92397: PUSH
92398: LD_INT 1
92400: NEG
92401: PUSH
92402: LD_INT 3
92404: NEG
92405: PUSH
92406: EMPTY
92407: LIST
92408: LIST
92409: PUSH
92410: LD_INT 0
92412: PUSH
92413: LD_INT 3
92415: NEG
92416: PUSH
92417: EMPTY
92418: LIST
92419: LIST
92420: PUSH
92421: LD_INT 1
92423: PUSH
92424: LD_INT 2
92426: NEG
92427: PUSH
92428: EMPTY
92429: LIST
92430: LIST
92431: PUSH
92432: LD_INT 1
92434: NEG
92435: PUSH
92436: LD_INT 4
92438: NEG
92439: PUSH
92440: EMPTY
92441: LIST
92442: LIST
92443: PUSH
92444: LD_INT 0
92446: PUSH
92447: LD_INT 4
92449: NEG
92450: PUSH
92451: EMPTY
92452: LIST
92453: LIST
92454: PUSH
92455: LD_INT 1
92457: PUSH
92458: LD_INT 3
92460: NEG
92461: PUSH
92462: EMPTY
92463: LIST
92464: LIST
92465: PUSH
92466: LD_INT 1
92468: NEG
92469: PUSH
92470: LD_INT 5
92472: NEG
92473: PUSH
92474: EMPTY
92475: LIST
92476: LIST
92477: PUSH
92478: LD_INT 0
92480: PUSH
92481: LD_INT 5
92483: NEG
92484: PUSH
92485: EMPTY
92486: LIST
92487: LIST
92488: PUSH
92489: LD_INT 1
92491: PUSH
92492: LD_INT 4
92494: NEG
92495: PUSH
92496: EMPTY
92497: LIST
92498: LIST
92499: PUSH
92500: LD_INT 1
92502: NEG
92503: PUSH
92504: LD_INT 6
92506: NEG
92507: PUSH
92508: EMPTY
92509: LIST
92510: LIST
92511: PUSH
92512: LD_INT 0
92514: PUSH
92515: LD_INT 6
92517: NEG
92518: PUSH
92519: EMPTY
92520: LIST
92521: LIST
92522: PUSH
92523: LD_INT 1
92525: PUSH
92526: LD_INT 5
92528: NEG
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: PUSH
92534: EMPTY
92535: LIST
92536: LIST
92537: LIST
92538: LIST
92539: LIST
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92548: LD_ADDR_VAR 0 30
92552: PUSH
92553: LD_INT 2
92555: PUSH
92556: LD_INT 1
92558: NEG
92559: PUSH
92560: EMPTY
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 3
92566: PUSH
92567: LD_INT 0
92569: PUSH
92570: EMPTY
92571: LIST
92572: LIST
92573: PUSH
92574: LD_INT 3
92576: PUSH
92577: LD_INT 1
92579: PUSH
92580: EMPTY
92581: LIST
92582: LIST
92583: PUSH
92584: LD_INT 3
92586: PUSH
92587: LD_INT 1
92589: NEG
92590: PUSH
92591: EMPTY
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 4
92597: PUSH
92598: LD_INT 0
92600: PUSH
92601: EMPTY
92602: LIST
92603: LIST
92604: PUSH
92605: LD_INT 4
92607: PUSH
92608: LD_INT 1
92610: PUSH
92611: EMPTY
92612: LIST
92613: LIST
92614: PUSH
92615: LD_INT 4
92617: PUSH
92618: LD_INT 1
92620: NEG
92621: PUSH
92622: EMPTY
92623: LIST
92624: LIST
92625: PUSH
92626: LD_INT 5
92628: PUSH
92629: LD_INT 0
92631: PUSH
92632: EMPTY
92633: LIST
92634: LIST
92635: PUSH
92636: LD_INT 5
92638: PUSH
92639: LD_INT 1
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: PUSH
92646: LD_INT 5
92648: PUSH
92649: LD_INT 1
92651: NEG
92652: PUSH
92653: EMPTY
92654: LIST
92655: LIST
92656: PUSH
92657: LD_INT 6
92659: PUSH
92660: LD_INT 0
92662: PUSH
92663: EMPTY
92664: LIST
92665: LIST
92666: PUSH
92667: LD_INT 6
92669: PUSH
92670: LD_INT 1
92672: PUSH
92673: EMPTY
92674: LIST
92675: LIST
92676: PUSH
92677: EMPTY
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92691: LD_ADDR_VAR 0 31
92695: PUSH
92696: LD_INT 3
92698: PUSH
92699: LD_INT 2
92701: PUSH
92702: EMPTY
92703: LIST
92704: LIST
92705: PUSH
92706: LD_INT 3
92708: PUSH
92709: LD_INT 3
92711: PUSH
92712: EMPTY
92713: LIST
92714: LIST
92715: PUSH
92716: LD_INT 2
92718: PUSH
92719: LD_INT 3
92721: PUSH
92722: EMPTY
92723: LIST
92724: LIST
92725: PUSH
92726: LD_INT 4
92728: PUSH
92729: LD_INT 3
92731: PUSH
92732: EMPTY
92733: LIST
92734: LIST
92735: PUSH
92736: LD_INT 4
92738: PUSH
92739: LD_INT 4
92741: PUSH
92742: EMPTY
92743: LIST
92744: LIST
92745: PUSH
92746: LD_INT 3
92748: PUSH
92749: LD_INT 4
92751: PUSH
92752: EMPTY
92753: LIST
92754: LIST
92755: PUSH
92756: LD_INT 5
92758: PUSH
92759: LD_INT 4
92761: PUSH
92762: EMPTY
92763: LIST
92764: LIST
92765: PUSH
92766: LD_INT 5
92768: PUSH
92769: LD_INT 5
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: PUSH
92776: LD_INT 4
92778: PUSH
92779: LD_INT 5
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: PUSH
92786: LD_INT 6
92788: PUSH
92789: LD_INT 5
92791: PUSH
92792: EMPTY
92793: LIST
92794: LIST
92795: PUSH
92796: LD_INT 6
92798: PUSH
92799: LD_INT 6
92801: PUSH
92802: EMPTY
92803: LIST
92804: LIST
92805: PUSH
92806: LD_INT 5
92808: PUSH
92809: LD_INT 6
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: PUSH
92816: EMPTY
92817: LIST
92818: LIST
92819: LIST
92820: LIST
92821: LIST
92822: LIST
92823: LIST
92824: LIST
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92830: LD_ADDR_VAR 0 32
92834: PUSH
92835: LD_INT 1
92837: PUSH
92838: LD_INT 3
92840: PUSH
92841: EMPTY
92842: LIST
92843: LIST
92844: PUSH
92845: LD_INT 0
92847: PUSH
92848: LD_INT 3
92850: PUSH
92851: EMPTY
92852: LIST
92853: LIST
92854: PUSH
92855: LD_INT 1
92857: NEG
92858: PUSH
92859: LD_INT 2
92861: PUSH
92862: EMPTY
92863: LIST
92864: LIST
92865: PUSH
92866: LD_INT 1
92868: PUSH
92869: LD_INT 4
92871: PUSH
92872: EMPTY
92873: LIST
92874: LIST
92875: PUSH
92876: LD_INT 0
92878: PUSH
92879: LD_INT 4
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: PUSH
92886: LD_INT 1
92888: NEG
92889: PUSH
92890: LD_INT 3
92892: PUSH
92893: EMPTY
92894: LIST
92895: LIST
92896: PUSH
92897: LD_INT 1
92899: PUSH
92900: LD_INT 5
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: LD_INT 0
92909: PUSH
92910: LD_INT 5
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 1
92919: NEG
92920: PUSH
92921: LD_INT 4
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: PUSH
92928: LD_INT 1
92930: PUSH
92931: LD_INT 6
92933: PUSH
92934: EMPTY
92935: LIST
92936: LIST
92937: PUSH
92938: LD_INT 0
92940: PUSH
92941: LD_INT 6
92943: PUSH
92944: EMPTY
92945: LIST
92946: LIST
92947: PUSH
92948: LD_INT 1
92950: NEG
92951: PUSH
92952: LD_INT 5
92954: PUSH
92955: EMPTY
92956: LIST
92957: LIST
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92973: LD_ADDR_VAR 0 33
92977: PUSH
92978: LD_INT 2
92980: NEG
92981: PUSH
92982: LD_INT 1
92984: PUSH
92985: EMPTY
92986: LIST
92987: LIST
92988: PUSH
92989: LD_INT 3
92991: NEG
92992: PUSH
92993: LD_INT 0
92995: PUSH
92996: EMPTY
92997: LIST
92998: LIST
92999: PUSH
93000: LD_INT 3
93002: NEG
93003: PUSH
93004: LD_INT 1
93006: NEG
93007: PUSH
93008: EMPTY
93009: LIST
93010: LIST
93011: PUSH
93012: LD_INT 3
93014: NEG
93015: PUSH
93016: LD_INT 1
93018: PUSH
93019: EMPTY
93020: LIST
93021: LIST
93022: PUSH
93023: LD_INT 4
93025: NEG
93026: PUSH
93027: LD_INT 0
93029: PUSH
93030: EMPTY
93031: LIST
93032: LIST
93033: PUSH
93034: LD_INT 4
93036: NEG
93037: PUSH
93038: LD_INT 1
93040: NEG
93041: PUSH
93042: EMPTY
93043: LIST
93044: LIST
93045: PUSH
93046: LD_INT 4
93048: NEG
93049: PUSH
93050: LD_INT 1
93052: PUSH
93053: EMPTY
93054: LIST
93055: LIST
93056: PUSH
93057: LD_INT 5
93059: NEG
93060: PUSH
93061: LD_INT 0
93063: PUSH
93064: EMPTY
93065: LIST
93066: LIST
93067: PUSH
93068: LD_INT 5
93070: NEG
93071: PUSH
93072: LD_INT 1
93074: NEG
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: PUSH
93080: LD_INT 5
93082: NEG
93083: PUSH
93084: LD_INT 1
93086: PUSH
93087: EMPTY
93088: LIST
93089: LIST
93090: PUSH
93091: LD_INT 6
93093: NEG
93094: PUSH
93095: LD_INT 0
93097: PUSH
93098: EMPTY
93099: LIST
93100: LIST
93101: PUSH
93102: LD_INT 6
93104: NEG
93105: PUSH
93106: LD_INT 1
93108: NEG
93109: PUSH
93110: EMPTY
93111: LIST
93112: LIST
93113: PUSH
93114: EMPTY
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
93128: LD_ADDR_VAR 0 34
93132: PUSH
93133: LD_INT 2
93135: NEG
93136: PUSH
93137: LD_INT 3
93139: NEG
93140: PUSH
93141: EMPTY
93142: LIST
93143: LIST
93144: PUSH
93145: LD_INT 3
93147: NEG
93148: PUSH
93149: LD_INT 2
93151: NEG
93152: PUSH
93153: EMPTY
93154: LIST
93155: LIST
93156: PUSH
93157: LD_INT 3
93159: NEG
93160: PUSH
93161: LD_INT 3
93163: NEG
93164: PUSH
93165: EMPTY
93166: LIST
93167: LIST
93168: PUSH
93169: LD_INT 3
93171: NEG
93172: PUSH
93173: LD_INT 4
93175: NEG
93176: PUSH
93177: EMPTY
93178: LIST
93179: LIST
93180: PUSH
93181: LD_INT 4
93183: NEG
93184: PUSH
93185: LD_INT 3
93187: NEG
93188: PUSH
93189: EMPTY
93190: LIST
93191: LIST
93192: PUSH
93193: LD_INT 4
93195: NEG
93196: PUSH
93197: LD_INT 4
93199: NEG
93200: PUSH
93201: EMPTY
93202: LIST
93203: LIST
93204: PUSH
93205: LD_INT 4
93207: NEG
93208: PUSH
93209: LD_INT 5
93211: NEG
93212: PUSH
93213: EMPTY
93214: LIST
93215: LIST
93216: PUSH
93217: LD_INT 5
93219: NEG
93220: PUSH
93221: LD_INT 4
93223: NEG
93224: PUSH
93225: EMPTY
93226: LIST
93227: LIST
93228: PUSH
93229: LD_INT 5
93231: NEG
93232: PUSH
93233: LD_INT 5
93235: NEG
93236: PUSH
93237: EMPTY
93238: LIST
93239: LIST
93240: PUSH
93241: LD_INT 5
93243: NEG
93244: PUSH
93245: LD_INT 6
93247: NEG
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: PUSH
93253: LD_INT 6
93255: NEG
93256: PUSH
93257: LD_INT 5
93259: NEG
93260: PUSH
93261: EMPTY
93262: LIST
93263: LIST
93264: PUSH
93265: LD_INT 6
93267: NEG
93268: PUSH
93269: LD_INT 6
93271: NEG
93272: PUSH
93273: EMPTY
93274: LIST
93275: LIST
93276: PUSH
93277: EMPTY
93278: LIST
93279: LIST
93280: LIST
93281: LIST
93282: LIST
93283: LIST
93284: LIST
93285: LIST
93286: LIST
93287: LIST
93288: LIST
93289: LIST
93290: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
93291: LD_ADDR_VAR 0 41
93295: PUSH
93296: LD_INT 0
93298: PUSH
93299: LD_INT 2
93301: NEG
93302: PUSH
93303: EMPTY
93304: LIST
93305: LIST
93306: PUSH
93307: LD_INT 1
93309: NEG
93310: PUSH
93311: LD_INT 3
93313: NEG
93314: PUSH
93315: EMPTY
93316: LIST
93317: LIST
93318: PUSH
93319: LD_INT 1
93321: PUSH
93322: LD_INT 2
93324: NEG
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: PUSH
93330: EMPTY
93331: LIST
93332: LIST
93333: LIST
93334: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
93335: LD_ADDR_VAR 0 42
93339: PUSH
93340: LD_INT 2
93342: PUSH
93343: LD_INT 0
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: PUSH
93350: LD_INT 2
93352: PUSH
93353: LD_INT 1
93355: NEG
93356: PUSH
93357: EMPTY
93358: LIST
93359: LIST
93360: PUSH
93361: LD_INT 3
93363: PUSH
93364: LD_INT 1
93366: PUSH
93367: EMPTY
93368: LIST
93369: LIST
93370: PUSH
93371: EMPTY
93372: LIST
93373: LIST
93374: LIST
93375: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93376: LD_ADDR_VAR 0 43
93380: PUSH
93381: LD_INT 2
93383: PUSH
93384: LD_INT 2
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: PUSH
93391: LD_INT 3
93393: PUSH
93394: LD_INT 2
93396: PUSH
93397: EMPTY
93398: LIST
93399: LIST
93400: PUSH
93401: LD_INT 2
93403: PUSH
93404: LD_INT 3
93406: PUSH
93407: EMPTY
93408: LIST
93409: LIST
93410: PUSH
93411: EMPTY
93412: LIST
93413: LIST
93414: LIST
93415: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93416: LD_ADDR_VAR 0 44
93420: PUSH
93421: LD_INT 0
93423: PUSH
93424: LD_INT 2
93426: PUSH
93427: EMPTY
93428: LIST
93429: LIST
93430: PUSH
93431: LD_INT 1
93433: PUSH
93434: LD_INT 3
93436: PUSH
93437: EMPTY
93438: LIST
93439: LIST
93440: PUSH
93441: LD_INT 1
93443: NEG
93444: PUSH
93445: LD_INT 2
93447: PUSH
93448: EMPTY
93449: LIST
93450: LIST
93451: PUSH
93452: EMPTY
93453: LIST
93454: LIST
93455: LIST
93456: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93457: LD_ADDR_VAR 0 45
93461: PUSH
93462: LD_INT 2
93464: NEG
93465: PUSH
93466: LD_INT 0
93468: PUSH
93469: EMPTY
93470: LIST
93471: LIST
93472: PUSH
93473: LD_INT 2
93475: NEG
93476: PUSH
93477: LD_INT 1
93479: PUSH
93480: EMPTY
93481: LIST
93482: LIST
93483: PUSH
93484: LD_INT 3
93486: NEG
93487: PUSH
93488: LD_INT 1
93490: NEG
93491: PUSH
93492: EMPTY
93493: LIST
93494: LIST
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: LIST
93500: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93501: LD_ADDR_VAR 0 46
93505: PUSH
93506: LD_INT 2
93508: NEG
93509: PUSH
93510: LD_INT 2
93512: NEG
93513: PUSH
93514: EMPTY
93515: LIST
93516: LIST
93517: PUSH
93518: LD_INT 2
93520: NEG
93521: PUSH
93522: LD_INT 3
93524: NEG
93525: PUSH
93526: EMPTY
93527: LIST
93528: LIST
93529: PUSH
93530: LD_INT 3
93532: NEG
93533: PUSH
93534: LD_INT 2
93536: NEG
93537: PUSH
93538: EMPTY
93539: LIST
93540: LIST
93541: PUSH
93542: EMPTY
93543: LIST
93544: LIST
93545: LIST
93546: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93547: LD_ADDR_VAR 0 47
93551: PUSH
93552: LD_INT 2
93554: NEG
93555: PUSH
93556: LD_INT 3
93558: NEG
93559: PUSH
93560: EMPTY
93561: LIST
93562: LIST
93563: PUSH
93564: LD_INT 1
93566: NEG
93567: PUSH
93568: LD_INT 3
93570: NEG
93571: PUSH
93572: EMPTY
93573: LIST
93574: LIST
93575: PUSH
93576: EMPTY
93577: LIST
93578: LIST
93579: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93580: LD_ADDR_VAR 0 48
93584: PUSH
93585: LD_INT 1
93587: PUSH
93588: LD_INT 2
93590: NEG
93591: PUSH
93592: EMPTY
93593: LIST
93594: LIST
93595: PUSH
93596: LD_INT 2
93598: PUSH
93599: LD_INT 1
93601: NEG
93602: PUSH
93603: EMPTY
93604: LIST
93605: LIST
93606: PUSH
93607: EMPTY
93608: LIST
93609: LIST
93610: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93611: LD_ADDR_VAR 0 49
93615: PUSH
93616: LD_INT 3
93618: PUSH
93619: LD_INT 1
93621: PUSH
93622: EMPTY
93623: LIST
93624: LIST
93625: PUSH
93626: LD_INT 3
93628: PUSH
93629: LD_INT 2
93631: PUSH
93632: EMPTY
93633: LIST
93634: LIST
93635: PUSH
93636: EMPTY
93637: LIST
93638: LIST
93639: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93640: LD_ADDR_VAR 0 50
93644: PUSH
93645: LD_INT 2
93647: PUSH
93648: LD_INT 3
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: PUSH
93655: LD_INT 1
93657: PUSH
93658: LD_INT 3
93660: PUSH
93661: EMPTY
93662: LIST
93663: LIST
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93669: LD_ADDR_VAR 0 51
93673: PUSH
93674: LD_INT 1
93676: NEG
93677: PUSH
93678: LD_INT 2
93680: PUSH
93681: EMPTY
93682: LIST
93683: LIST
93684: PUSH
93685: LD_INT 2
93687: NEG
93688: PUSH
93689: LD_INT 1
93691: PUSH
93692: EMPTY
93693: LIST
93694: LIST
93695: PUSH
93696: EMPTY
93697: LIST
93698: LIST
93699: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93700: LD_ADDR_VAR 0 52
93704: PUSH
93705: LD_INT 3
93707: NEG
93708: PUSH
93709: LD_INT 1
93711: NEG
93712: PUSH
93713: EMPTY
93714: LIST
93715: LIST
93716: PUSH
93717: LD_INT 3
93719: NEG
93720: PUSH
93721: LD_INT 2
93723: NEG
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PUSH
93729: EMPTY
93730: LIST
93731: LIST
93732: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93733: LD_ADDR_VAR 0 53
93737: PUSH
93738: LD_INT 1
93740: NEG
93741: PUSH
93742: LD_INT 3
93744: NEG
93745: PUSH
93746: EMPTY
93747: LIST
93748: LIST
93749: PUSH
93750: LD_INT 0
93752: PUSH
93753: LD_INT 3
93755: NEG
93756: PUSH
93757: EMPTY
93758: LIST
93759: LIST
93760: PUSH
93761: LD_INT 1
93763: PUSH
93764: LD_INT 2
93766: NEG
93767: PUSH
93768: EMPTY
93769: LIST
93770: LIST
93771: PUSH
93772: EMPTY
93773: LIST
93774: LIST
93775: LIST
93776: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93777: LD_ADDR_VAR 0 54
93781: PUSH
93782: LD_INT 2
93784: PUSH
93785: LD_INT 1
93787: NEG
93788: PUSH
93789: EMPTY
93790: LIST
93791: LIST
93792: PUSH
93793: LD_INT 3
93795: PUSH
93796: LD_INT 0
93798: PUSH
93799: EMPTY
93800: LIST
93801: LIST
93802: PUSH
93803: LD_INT 3
93805: PUSH
93806: LD_INT 1
93808: PUSH
93809: EMPTY
93810: LIST
93811: LIST
93812: PUSH
93813: EMPTY
93814: LIST
93815: LIST
93816: LIST
93817: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93818: LD_ADDR_VAR 0 55
93822: PUSH
93823: LD_INT 3
93825: PUSH
93826: LD_INT 2
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 3
93835: PUSH
93836: LD_INT 3
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: LD_INT 2
93845: PUSH
93846: LD_INT 3
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: EMPTY
93854: LIST
93855: LIST
93856: LIST
93857: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93858: LD_ADDR_VAR 0 56
93862: PUSH
93863: LD_INT 1
93865: PUSH
93866: LD_INT 3
93868: PUSH
93869: EMPTY
93870: LIST
93871: LIST
93872: PUSH
93873: LD_INT 0
93875: PUSH
93876: LD_INT 3
93878: PUSH
93879: EMPTY
93880: LIST
93881: LIST
93882: PUSH
93883: LD_INT 1
93885: NEG
93886: PUSH
93887: LD_INT 2
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: PUSH
93894: EMPTY
93895: LIST
93896: LIST
93897: LIST
93898: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93899: LD_ADDR_VAR 0 57
93903: PUSH
93904: LD_INT 2
93906: NEG
93907: PUSH
93908: LD_INT 1
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: PUSH
93915: LD_INT 3
93917: NEG
93918: PUSH
93919: LD_INT 0
93921: PUSH
93922: EMPTY
93923: LIST
93924: LIST
93925: PUSH
93926: LD_INT 3
93928: NEG
93929: PUSH
93930: LD_INT 1
93932: NEG
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: LIST
93942: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93943: LD_ADDR_VAR 0 58
93947: PUSH
93948: LD_INT 2
93950: NEG
93951: PUSH
93952: LD_INT 3
93954: NEG
93955: PUSH
93956: EMPTY
93957: LIST
93958: LIST
93959: PUSH
93960: LD_INT 3
93962: NEG
93963: PUSH
93964: LD_INT 2
93966: NEG
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: PUSH
93972: LD_INT 3
93974: NEG
93975: PUSH
93976: LD_INT 3
93978: NEG
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: EMPTY
93985: LIST
93986: LIST
93987: LIST
93988: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93989: LD_ADDR_VAR 0 59
93993: PUSH
93994: LD_INT 1
93996: NEG
93997: PUSH
93998: LD_INT 2
94000: NEG
94001: PUSH
94002: EMPTY
94003: LIST
94004: LIST
94005: PUSH
94006: LD_INT 0
94008: PUSH
94009: LD_INT 2
94011: NEG
94012: PUSH
94013: EMPTY
94014: LIST
94015: LIST
94016: PUSH
94017: LD_INT 1
94019: PUSH
94020: LD_INT 1
94022: NEG
94023: PUSH
94024: EMPTY
94025: LIST
94026: LIST
94027: PUSH
94028: EMPTY
94029: LIST
94030: LIST
94031: LIST
94032: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
94033: LD_ADDR_VAR 0 60
94037: PUSH
94038: LD_INT 1
94040: PUSH
94041: LD_INT 1
94043: NEG
94044: PUSH
94045: EMPTY
94046: LIST
94047: LIST
94048: PUSH
94049: LD_INT 2
94051: PUSH
94052: LD_INT 0
94054: PUSH
94055: EMPTY
94056: LIST
94057: LIST
94058: PUSH
94059: LD_INT 2
94061: PUSH
94062: LD_INT 1
94064: PUSH
94065: EMPTY
94066: LIST
94067: LIST
94068: PUSH
94069: EMPTY
94070: LIST
94071: LIST
94072: LIST
94073: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
94074: LD_ADDR_VAR 0 61
94078: PUSH
94079: LD_INT 2
94081: PUSH
94082: LD_INT 1
94084: PUSH
94085: EMPTY
94086: LIST
94087: LIST
94088: PUSH
94089: LD_INT 2
94091: PUSH
94092: LD_INT 2
94094: PUSH
94095: EMPTY
94096: LIST
94097: LIST
94098: PUSH
94099: LD_INT 1
94101: PUSH
94102: LD_INT 2
94104: PUSH
94105: EMPTY
94106: LIST
94107: LIST
94108: PUSH
94109: EMPTY
94110: LIST
94111: LIST
94112: LIST
94113: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
94114: LD_ADDR_VAR 0 62
94118: PUSH
94119: LD_INT 1
94121: PUSH
94122: LD_INT 2
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: PUSH
94129: LD_INT 0
94131: PUSH
94132: LD_INT 2
94134: PUSH
94135: EMPTY
94136: LIST
94137: LIST
94138: PUSH
94139: LD_INT 1
94141: NEG
94142: PUSH
94143: LD_INT 1
94145: PUSH
94146: EMPTY
94147: LIST
94148: LIST
94149: PUSH
94150: EMPTY
94151: LIST
94152: LIST
94153: LIST
94154: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
94155: LD_ADDR_VAR 0 63
94159: PUSH
94160: LD_INT 1
94162: NEG
94163: PUSH
94164: LD_INT 1
94166: PUSH
94167: EMPTY
94168: LIST
94169: LIST
94170: PUSH
94171: LD_INT 2
94173: NEG
94174: PUSH
94175: LD_INT 0
94177: PUSH
94178: EMPTY
94179: LIST
94180: LIST
94181: PUSH
94182: LD_INT 2
94184: NEG
94185: PUSH
94186: LD_INT 1
94188: NEG
94189: PUSH
94190: EMPTY
94191: LIST
94192: LIST
94193: PUSH
94194: EMPTY
94195: LIST
94196: LIST
94197: LIST
94198: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
94199: LD_ADDR_VAR 0 64
94203: PUSH
94204: LD_INT 1
94206: NEG
94207: PUSH
94208: LD_INT 2
94210: NEG
94211: PUSH
94212: EMPTY
94213: LIST
94214: LIST
94215: PUSH
94216: LD_INT 2
94218: NEG
94219: PUSH
94220: LD_INT 1
94222: NEG
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: PUSH
94228: LD_INT 2
94230: NEG
94231: PUSH
94232: LD_INT 2
94234: NEG
94235: PUSH
94236: EMPTY
94237: LIST
94238: LIST
94239: PUSH
94240: EMPTY
94241: LIST
94242: LIST
94243: LIST
94244: ST_TO_ADDR
// end ; 2 :
94245: GO 97511
94247: LD_INT 2
94249: DOUBLE
94250: EQUAL
94251: IFTRUE 94255
94253: GO 97510
94255: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
94256: LD_ADDR_VAR 0 29
94260: PUSH
94261: LD_INT 4
94263: PUSH
94264: LD_INT 0
94266: PUSH
94267: EMPTY
94268: LIST
94269: LIST
94270: PUSH
94271: LD_INT 4
94273: PUSH
94274: LD_INT 1
94276: NEG
94277: PUSH
94278: EMPTY
94279: LIST
94280: LIST
94281: PUSH
94282: LD_INT 5
94284: PUSH
94285: LD_INT 0
94287: PUSH
94288: EMPTY
94289: LIST
94290: LIST
94291: PUSH
94292: LD_INT 5
94294: PUSH
94295: LD_INT 1
94297: PUSH
94298: EMPTY
94299: LIST
94300: LIST
94301: PUSH
94302: LD_INT 4
94304: PUSH
94305: LD_INT 1
94307: PUSH
94308: EMPTY
94309: LIST
94310: LIST
94311: PUSH
94312: LD_INT 3
94314: PUSH
94315: LD_INT 0
94317: PUSH
94318: EMPTY
94319: LIST
94320: LIST
94321: PUSH
94322: LD_INT 3
94324: PUSH
94325: LD_INT 1
94327: NEG
94328: PUSH
94329: EMPTY
94330: LIST
94331: LIST
94332: PUSH
94333: LD_INT 3
94335: PUSH
94336: LD_INT 2
94338: NEG
94339: PUSH
94340: EMPTY
94341: LIST
94342: LIST
94343: PUSH
94344: LD_INT 5
94346: PUSH
94347: LD_INT 2
94349: PUSH
94350: EMPTY
94351: LIST
94352: LIST
94353: PUSH
94354: LD_INT 3
94356: PUSH
94357: LD_INT 3
94359: PUSH
94360: EMPTY
94361: LIST
94362: LIST
94363: PUSH
94364: LD_INT 3
94366: PUSH
94367: LD_INT 2
94369: PUSH
94370: EMPTY
94371: LIST
94372: LIST
94373: PUSH
94374: LD_INT 4
94376: PUSH
94377: LD_INT 3
94379: PUSH
94380: EMPTY
94381: LIST
94382: LIST
94383: PUSH
94384: LD_INT 4
94386: PUSH
94387: LD_INT 4
94389: PUSH
94390: EMPTY
94391: LIST
94392: LIST
94393: PUSH
94394: LD_INT 3
94396: PUSH
94397: LD_INT 4
94399: PUSH
94400: EMPTY
94401: LIST
94402: LIST
94403: PUSH
94404: LD_INT 2
94406: PUSH
94407: LD_INT 3
94409: PUSH
94410: EMPTY
94411: LIST
94412: LIST
94413: PUSH
94414: LD_INT 2
94416: PUSH
94417: LD_INT 2
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: LD_INT 4
94426: PUSH
94427: LD_INT 2
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: PUSH
94434: LD_INT 2
94436: PUSH
94437: LD_INT 4
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: PUSH
94444: LD_INT 0
94446: PUSH
94447: LD_INT 4
94449: PUSH
94450: EMPTY
94451: LIST
94452: LIST
94453: PUSH
94454: LD_INT 0
94456: PUSH
94457: LD_INT 3
94459: PUSH
94460: EMPTY
94461: LIST
94462: LIST
94463: PUSH
94464: LD_INT 1
94466: PUSH
94467: LD_INT 4
94469: PUSH
94470: EMPTY
94471: LIST
94472: LIST
94473: PUSH
94474: LD_INT 1
94476: PUSH
94477: LD_INT 5
94479: PUSH
94480: EMPTY
94481: LIST
94482: LIST
94483: PUSH
94484: LD_INT 0
94486: PUSH
94487: LD_INT 5
94489: PUSH
94490: EMPTY
94491: LIST
94492: LIST
94493: PUSH
94494: LD_INT 1
94496: NEG
94497: PUSH
94498: LD_INT 4
94500: PUSH
94501: EMPTY
94502: LIST
94503: LIST
94504: PUSH
94505: LD_INT 1
94507: NEG
94508: PUSH
94509: LD_INT 3
94511: PUSH
94512: EMPTY
94513: LIST
94514: LIST
94515: PUSH
94516: LD_INT 2
94518: PUSH
94519: LD_INT 5
94521: PUSH
94522: EMPTY
94523: LIST
94524: LIST
94525: PUSH
94526: LD_INT 2
94528: NEG
94529: PUSH
94530: LD_INT 3
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: PUSH
94537: LD_INT 3
94539: NEG
94540: PUSH
94541: LD_INT 0
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: PUSH
94548: LD_INT 3
94550: NEG
94551: PUSH
94552: LD_INT 1
94554: NEG
94555: PUSH
94556: EMPTY
94557: LIST
94558: LIST
94559: PUSH
94560: LD_INT 2
94562: NEG
94563: PUSH
94564: LD_INT 0
94566: PUSH
94567: EMPTY
94568: LIST
94569: LIST
94570: PUSH
94571: LD_INT 2
94573: NEG
94574: PUSH
94575: LD_INT 1
94577: PUSH
94578: EMPTY
94579: LIST
94580: LIST
94581: PUSH
94582: LD_INT 3
94584: NEG
94585: PUSH
94586: LD_INT 1
94588: PUSH
94589: EMPTY
94590: LIST
94591: LIST
94592: PUSH
94593: LD_INT 4
94595: NEG
94596: PUSH
94597: LD_INT 0
94599: PUSH
94600: EMPTY
94601: LIST
94602: LIST
94603: PUSH
94604: LD_INT 4
94606: NEG
94607: PUSH
94608: LD_INT 1
94610: NEG
94611: PUSH
94612: EMPTY
94613: LIST
94614: LIST
94615: PUSH
94616: LD_INT 4
94618: NEG
94619: PUSH
94620: LD_INT 2
94622: NEG
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: PUSH
94628: LD_INT 2
94630: NEG
94631: PUSH
94632: LD_INT 2
94634: PUSH
94635: EMPTY
94636: LIST
94637: LIST
94638: PUSH
94639: LD_INT 4
94641: NEG
94642: PUSH
94643: LD_INT 4
94645: NEG
94646: PUSH
94647: EMPTY
94648: LIST
94649: LIST
94650: PUSH
94651: LD_INT 4
94653: NEG
94654: PUSH
94655: LD_INT 5
94657: NEG
94658: PUSH
94659: EMPTY
94660: LIST
94661: LIST
94662: PUSH
94663: LD_INT 3
94665: NEG
94666: PUSH
94667: LD_INT 4
94669: NEG
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: PUSH
94675: LD_INT 3
94677: NEG
94678: PUSH
94679: LD_INT 3
94681: NEG
94682: PUSH
94683: EMPTY
94684: LIST
94685: LIST
94686: PUSH
94687: LD_INT 4
94689: NEG
94690: PUSH
94691: LD_INT 3
94693: NEG
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: PUSH
94699: LD_INT 5
94701: NEG
94702: PUSH
94703: LD_INT 4
94705: NEG
94706: PUSH
94707: EMPTY
94708: LIST
94709: LIST
94710: PUSH
94711: LD_INT 5
94713: NEG
94714: PUSH
94715: LD_INT 5
94717: NEG
94718: PUSH
94719: EMPTY
94720: LIST
94721: LIST
94722: PUSH
94723: LD_INT 3
94725: NEG
94726: PUSH
94727: LD_INT 5
94729: NEG
94730: PUSH
94731: EMPTY
94732: LIST
94733: LIST
94734: PUSH
94735: LD_INT 5
94737: NEG
94738: PUSH
94739: LD_INT 3
94741: NEG
94742: PUSH
94743: EMPTY
94744: LIST
94745: LIST
94746: PUSH
94747: EMPTY
94748: LIST
94749: LIST
94750: LIST
94751: LIST
94752: LIST
94753: LIST
94754: LIST
94755: LIST
94756: LIST
94757: LIST
94758: LIST
94759: LIST
94760: LIST
94761: LIST
94762: LIST
94763: LIST
94764: LIST
94765: LIST
94766: LIST
94767: LIST
94768: LIST
94769: LIST
94770: LIST
94771: LIST
94772: LIST
94773: LIST
94774: LIST
94775: LIST
94776: LIST
94777: LIST
94778: LIST
94779: LIST
94780: LIST
94781: LIST
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94794: LD_ADDR_VAR 0 30
94798: PUSH
94799: LD_INT 4
94801: PUSH
94802: LD_INT 4
94804: PUSH
94805: EMPTY
94806: LIST
94807: LIST
94808: PUSH
94809: LD_INT 4
94811: PUSH
94812: LD_INT 3
94814: PUSH
94815: EMPTY
94816: LIST
94817: LIST
94818: PUSH
94819: LD_INT 5
94821: PUSH
94822: LD_INT 4
94824: PUSH
94825: EMPTY
94826: LIST
94827: LIST
94828: PUSH
94829: LD_INT 5
94831: PUSH
94832: LD_INT 5
94834: PUSH
94835: EMPTY
94836: LIST
94837: LIST
94838: PUSH
94839: LD_INT 4
94841: PUSH
94842: LD_INT 5
94844: PUSH
94845: EMPTY
94846: LIST
94847: LIST
94848: PUSH
94849: LD_INT 3
94851: PUSH
94852: LD_INT 4
94854: PUSH
94855: EMPTY
94856: LIST
94857: LIST
94858: PUSH
94859: LD_INT 3
94861: PUSH
94862: LD_INT 3
94864: PUSH
94865: EMPTY
94866: LIST
94867: LIST
94868: PUSH
94869: LD_INT 5
94871: PUSH
94872: LD_INT 3
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: PUSH
94879: LD_INT 3
94881: PUSH
94882: LD_INT 5
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 0
94891: PUSH
94892: LD_INT 3
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: PUSH
94899: LD_INT 0
94901: PUSH
94902: LD_INT 2
94904: PUSH
94905: EMPTY
94906: LIST
94907: LIST
94908: PUSH
94909: LD_INT 1
94911: PUSH
94912: LD_INT 3
94914: PUSH
94915: EMPTY
94916: LIST
94917: LIST
94918: PUSH
94919: LD_INT 1
94921: PUSH
94922: LD_INT 4
94924: PUSH
94925: EMPTY
94926: LIST
94927: LIST
94928: PUSH
94929: LD_INT 0
94931: PUSH
94932: LD_INT 4
94934: PUSH
94935: EMPTY
94936: LIST
94937: LIST
94938: PUSH
94939: LD_INT 1
94941: NEG
94942: PUSH
94943: LD_INT 3
94945: PUSH
94946: EMPTY
94947: LIST
94948: LIST
94949: PUSH
94950: LD_INT 1
94952: NEG
94953: PUSH
94954: LD_INT 2
94956: PUSH
94957: EMPTY
94958: LIST
94959: LIST
94960: PUSH
94961: LD_INT 2
94963: PUSH
94964: LD_INT 4
94966: PUSH
94967: EMPTY
94968: LIST
94969: LIST
94970: PUSH
94971: LD_INT 2
94973: NEG
94974: PUSH
94975: LD_INT 2
94977: PUSH
94978: EMPTY
94979: LIST
94980: LIST
94981: PUSH
94982: LD_INT 4
94984: NEG
94985: PUSH
94986: LD_INT 0
94988: PUSH
94989: EMPTY
94990: LIST
94991: LIST
94992: PUSH
94993: LD_INT 4
94995: NEG
94996: PUSH
94997: LD_INT 1
94999: NEG
95000: PUSH
95001: EMPTY
95002: LIST
95003: LIST
95004: PUSH
95005: LD_INT 3
95007: NEG
95008: PUSH
95009: LD_INT 0
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 3
95018: NEG
95019: PUSH
95020: LD_INT 1
95022: PUSH
95023: EMPTY
95024: LIST
95025: LIST
95026: PUSH
95027: LD_INT 4
95029: NEG
95030: PUSH
95031: LD_INT 1
95033: PUSH
95034: EMPTY
95035: LIST
95036: LIST
95037: PUSH
95038: LD_INT 5
95040: NEG
95041: PUSH
95042: LD_INT 0
95044: PUSH
95045: EMPTY
95046: LIST
95047: LIST
95048: PUSH
95049: LD_INT 5
95051: NEG
95052: PUSH
95053: LD_INT 1
95055: NEG
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 5
95063: NEG
95064: PUSH
95065: LD_INT 2
95067: NEG
95068: PUSH
95069: EMPTY
95070: LIST
95071: LIST
95072: PUSH
95073: LD_INT 3
95075: NEG
95076: PUSH
95077: LD_INT 2
95079: PUSH
95080: EMPTY
95081: LIST
95082: LIST
95083: PUSH
95084: LD_INT 3
95086: NEG
95087: PUSH
95088: LD_INT 3
95090: NEG
95091: PUSH
95092: EMPTY
95093: LIST
95094: LIST
95095: PUSH
95096: LD_INT 3
95098: NEG
95099: PUSH
95100: LD_INT 4
95102: NEG
95103: PUSH
95104: EMPTY
95105: LIST
95106: LIST
95107: PUSH
95108: LD_INT 2
95110: NEG
95111: PUSH
95112: LD_INT 3
95114: NEG
95115: PUSH
95116: EMPTY
95117: LIST
95118: LIST
95119: PUSH
95120: LD_INT 2
95122: NEG
95123: PUSH
95124: LD_INT 2
95126: NEG
95127: PUSH
95128: EMPTY
95129: LIST
95130: LIST
95131: PUSH
95132: LD_INT 3
95134: NEG
95135: PUSH
95136: LD_INT 2
95138: NEG
95139: PUSH
95140: EMPTY
95141: LIST
95142: LIST
95143: PUSH
95144: LD_INT 4
95146: NEG
95147: PUSH
95148: LD_INT 3
95150: NEG
95151: PUSH
95152: EMPTY
95153: LIST
95154: LIST
95155: PUSH
95156: LD_INT 4
95158: NEG
95159: PUSH
95160: LD_INT 4
95162: NEG
95163: PUSH
95164: EMPTY
95165: LIST
95166: LIST
95167: PUSH
95168: LD_INT 2
95170: NEG
95171: PUSH
95172: LD_INT 4
95174: NEG
95175: PUSH
95176: EMPTY
95177: LIST
95178: LIST
95179: PUSH
95180: LD_INT 4
95182: NEG
95183: PUSH
95184: LD_INT 2
95186: NEG
95187: PUSH
95188: EMPTY
95189: LIST
95190: LIST
95191: PUSH
95192: LD_INT 0
95194: PUSH
95195: LD_INT 4
95197: NEG
95198: PUSH
95199: EMPTY
95200: LIST
95201: LIST
95202: PUSH
95203: LD_INT 0
95205: PUSH
95206: LD_INT 5
95208: NEG
95209: PUSH
95210: EMPTY
95211: LIST
95212: LIST
95213: PUSH
95214: LD_INT 1
95216: PUSH
95217: LD_INT 4
95219: NEG
95220: PUSH
95221: EMPTY
95222: LIST
95223: LIST
95224: PUSH
95225: LD_INT 1
95227: PUSH
95228: LD_INT 3
95230: NEG
95231: PUSH
95232: EMPTY
95233: LIST
95234: LIST
95235: PUSH
95236: LD_INT 0
95238: PUSH
95239: LD_INT 3
95241: NEG
95242: PUSH
95243: EMPTY
95244: LIST
95245: LIST
95246: PUSH
95247: LD_INT 1
95249: NEG
95250: PUSH
95251: LD_INT 4
95253: NEG
95254: PUSH
95255: EMPTY
95256: LIST
95257: LIST
95258: PUSH
95259: LD_INT 1
95261: NEG
95262: PUSH
95263: LD_INT 5
95265: NEG
95266: PUSH
95267: EMPTY
95268: LIST
95269: LIST
95270: PUSH
95271: LD_INT 2
95273: PUSH
95274: LD_INT 3
95276: NEG
95277: PUSH
95278: EMPTY
95279: LIST
95280: LIST
95281: PUSH
95282: LD_INT 2
95284: NEG
95285: PUSH
95286: LD_INT 5
95288: NEG
95289: PUSH
95290: EMPTY
95291: LIST
95292: LIST
95293: PUSH
95294: EMPTY
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: LIST
95311: LIST
95312: LIST
95313: LIST
95314: LIST
95315: LIST
95316: LIST
95317: LIST
95318: LIST
95319: LIST
95320: LIST
95321: LIST
95322: LIST
95323: LIST
95324: LIST
95325: LIST
95326: LIST
95327: LIST
95328: LIST
95329: LIST
95330: LIST
95331: LIST
95332: LIST
95333: LIST
95334: LIST
95335: LIST
95336: LIST
95337: LIST
95338: LIST
95339: LIST
95340: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
95341: LD_ADDR_VAR 0 31
95345: PUSH
95346: LD_INT 0
95348: PUSH
95349: LD_INT 4
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: LD_INT 0
95358: PUSH
95359: LD_INT 3
95361: PUSH
95362: EMPTY
95363: LIST
95364: LIST
95365: PUSH
95366: LD_INT 1
95368: PUSH
95369: LD_INT 4
95371: PUSH
95372: EMPTY
95373: LIST
95374: LIST
95375: PUSH
95376: LD_INT 1
95378: PUSH
95379: LD_INT 5
95381: PUSH
95382: EMPTY
95383: LIST
95384: LIST
95385: PUSH
95386: LD_INT 0
95388: PUSH
95389: LD_INT 5
95391: PUSH
95392: EMPTY
95393: LIST
95394: LIST
95395: PUSH
95396: LD_INT 1
95398: NEG
95399: PUSH
95400: LD_INT 4
95402: PUSH
95403: EMPTY
95404: LIST
95405: LIST
95406: PUSH
95407: LD_INT 1
95409: NEG
95410: PUSH
95411: LD_INT 3
95413: PUSH
95414: EMPTY
95415: LIST
95416: LIST
95417: PUSH
95418: LD_INT 2
95420: PUSH
95421: LD_INT 5
95423: PUSH
95424: EMPTY
95425: LIST
95426: LIST
95427: PUSH
95428: LD_INT 2
95430: NEG
95431: PUSH
95432: LD_INT 3
95434: PUSH
95435: EMPTY
95436: LIST
95437: LIST
95438: PUSH
95439: LD_INT 3
95441: NEG
95442: PUSH
95443: LD_INT 0
95445: PUSH
95446: EMPTY
95447: LIST
95448: LIST
95449: PUSH
95450: LD_INT 3
95452: NEG
95453: PUSH
95454: LD_INT 1
95456: NEG
95457: PUSH
95458: EMPTY
95459: LIST
95460: LIST
95461: PUSH
95462: LD_INT 2
95464: NEG
95465: PUSH
95466: LD_INT 0
95468: PUSH
95469: EMPTY
95470: LIST
95471: LIST
95472: PUSH
95473: LD_INT 2
95475: NEG
95476: PUSH
95477: LD_INT 1
95479: PUSH
95480: EMPTY
95481: LIST
95482: LIST
95483: PUSH
95484: LD_INT 3
95486: NEG
95487: PUSH
95488: LD_INT 1
95490: PUSH
95491: EMPTY
95492: LIST
95493: LIST
95494: PUSH
95495: LD_INT 4
95497: NEG
95498: PUSH
95499: LD_INT 0
95501: PUSH
95502: EMPTY
95503: LIST
95504: LIST
95505: PUSH
95506: LD_INT 4
95508: NEG
95509: PUSH
95510: LD_INT 1
95512: NEG
95513: PUSH
95514: EMPTY
95515: LIST
95516: LIST
95517: PUSH
95518: LD_INT 4
95520: NEG
95521: PUSH
95522: LD_INT 2
95524: NEG
95525: PUSH
95526: EMPTY
95527: LIST
95528: LIST
95529: PUSH
95530: LD_INT 2
95532: NEG
95533: PUSH
95534: LD_INT 2
95536: PUSH
95537: EMPTY
95538: LIST
95539: LIST
95540: PUSH
95541: LD_INT 4
95543: NEG
95544: PUSH
95545: LD_INT 4
95547: NEG
95548: PUSH
95549: EMPTY
95550: LIST
95551: LIST
95552: PUSH
95553: LD_INT 4
95555: NEG
95556: PUSH
95557: LD_INT 5
95559: NEG
95560: PUSH
95561: EMPTY
95562: LIST
95563: LIST
95564: PUSH
95565: LD_INT 3
95567: NEG
95568: PUSH
95569: LD_INT 4
95571: NEG
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: PUSH
95577: LD_INT 3
95579: NEG
95580: PUSH
95581: LD_INT 3
95583: NEG
95584: PUSH
95585: EMPTY
95586: LIST
95587: LIST
95588: PUSH
95589: LD_INT 4
95591: NEG
95592: PUSH
95593: LD_INT 3
95595: NEG
95596: PUSH
95597: EMPTY
95598: LIST
95599: LIST
95600: PUSH
95601: LD_INT 5
95603: NEG
95604: PUSH
95605: LD_INT 4
95607: NEG
95608: PUSH
95609: EMPTY
95610: LIST
95611: LIST
95612: PUSH
95613: LD_INT 5
95615: NEG
95616: PUSH
95617: LD_INT 5
95619: NEG
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: PUSH
95625: LD_INT 3
95627: NEG
95628: PUSH
95629: LD_INT 5
95631: NEG
95632: PUSH
95633: EMPTY
95634: LIST
95635: LIST
95636: PUSH
95637: LD_INT 5
95639: NEG
95640: PUSH
95641: LD_INT 3
95643: NEG
95644: PUSH
95645: EMPTY
95646: LIST
95647: LIST
95648: PUSH
95649: LD_INT 0
95651: PUSH
95652: LD_INT 3
95654: NEG
95655: PUSH
95656: EMPTY
95657: LIST
95658: LIST
95659: PUSH
95660: LD_INT 0
95662: PUSH
95663: LD_INT 4
95665: NEG
95666: PUSH
95667: EMPTY
95668: LIST
95669: LIST
95670: PUSH
95671: LD_INT 1
95673: PUSH
95674: LD_INT 3
95676: NEG
95677: PUSH
95678: EMPTY
95679: LIST
95680: LIST
95681: PUSH
95682: LD_INT 1
95684: PUSH
95685: LD_INT 2
95687: NEG
95688: PUSH
95689: EMPTY
95690: LIST
95691: LIST
95692: PUSH
95693: LD_INT 0
95695: PUSH
95696: LD_INT 2
95698: NEG
95699: PUSH
95700: EMPTY
95701: LIST
95702: LIST
95703: PUSH
95704: LD_INT 1
95706: NEG
95707: PUSH
95708: LD_INT 3
95710: NEG
95711: PUSH
95712: EMPTY
95713: LIST
95714: LIST
95715: PUSH
95716: LD_INT 1
95718: NEG
95719: PUSH
95720: LD_INT 4
95722: NEG
95723: PUSH
95724: EMPTY
95725: LIST
95726: LIST
95727: PUSH
95728: LD_INT 2
95730: PUSH
95731: LD_INT 2
95733: NEG
95734: PUSH
95735: EMPTY
95736: LIST
95737: LIST
95738: PUSH
95739: LD_INT 2
95741: NEG
95742: PUSH
95743: LD_INT 4
95745: NEG
95746: PUSH
95747: EMPTY
95748: LIST
95749: LIST
95750: PUSH
95751: LD_INT 4
95753: PUSH
95754: LD_INT 0
95756: PUSH
95757: EMPTY
95758: LIST
95759: LIST
95760: PUSH
95761: LD_INT 4
95763: PUSH
95764: LD_INT 1
95766: NEG
95767: PUSH
95768: EMPTY
95769: LIST
95770: LIST
95771: PUSH
95772: LD_INT 5
95774: PUSH
95775: LD_INT 0
95777: PUSH
95778: EMPTY
95779: LIST
95780: LIST
95781: PUSH
95782: LD_INT 5
95784: PUSH
95785: LD_INT 1
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: PUSH
95792: LD_INT 4
95794: PUSH
95795: LD_INT 1
95797: PUSH
95798: EMPTY
95799: LIST
95800: LIST
95801: PUSH
95802: LD_INT 3
95804: PUSH
95805: LD_INT 0
95807: PUSH
95808: EMPTY
95809: LIST
95810: LIST
95811: PUSH
95812: LD_INT 3
95814: PUSH
95815: LD_INT 1
95817: NEG
95818: PUSH
95819: EMPTY
95820: LIST
95821: LIST
95822: PUSH
95823: LD_INT 3
95825: PUSH
95826: LD_INT 2
95828: NEG
95829: PUSH
95830: EMPTY
95831: LIST
95832: LIST
95833: PUSH
95834: LD_INT 5
95836: PUSH
95837: LD_INT 2
95839: PUSH
95840: EMPTY
95841: LIST
95842: LIST
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: LIST
95848: LIST
95849: LIST
95850: LIST
95851: LIST
95852: LIST
95853: LIST
95854: LIST
95855: LIST
95856: LIST
95857: LIST
95858: LIST
95859: LIST
95860: LIST
95861: LIST
95862: LIST
95863: LIST
95864: LIST
95865: LIST
95866: LIST
95867: LIST
95868: LIST
95869: LIST
95870: LIST
95871: LIST
95872: LIST
95873: LIST
95874: LIST
95875: LIST
95876: LIST
95877: LIST
95878: LIST
95879: LIST
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95891: LD_ADDR_VAR 0 32
95895: PUSH
95896: LD_INT 4
95898: NEG
95899: PUSH
95900: LD_INT 0
95902: PUSH
95903: EMPTY
95904: LIST
95905: LIST
95906: PUSH
95907: LD_INT 4
95909: NEG
95910: PUSH
95911: LD_INT 1
95913: NEG
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: LD_INT 3
95921: NEG
95922: PUSH
95923: LD_INT 0
95925: PUSH
95926: EMPTY
95927: LIST
95928: LIST
95929: PUSH
95930: LD_INT 3
95932: NEG
95933: PUSH
95934: LD_INT 1
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 4
95943: NEG
95944: PUSH
95945: LD_INT 1
95947: PUSH
95948: EMPTY
95949: LIST
95950: LIST
95951: PUSH
95952: LD_INT 5
95954: NEG
95955: PUSH
95956: LD_INT 0
95958: PUSH
95959: EMPTY
95960: LIST
95961: LIST
95962: PUSH
95963: LD_INT 5
95965: NEG
95966: PUSH
95967: LD_INT 1
95969: NEG
95970: PUSH
95971: EMPTY
95972: LIST
95973: LIST
95974: PUSH
95975: LD_INT 5
95977: NEG
95978: PUSH
95979: LD_INT 2
95981: NEG
95982: PUSH
95983: EMPTY
95984: LIST
95985: LIST
95986: PUSH
95987: LD_INT 3
95989: NEG
95990: PUSH
95991: LD_INT 2
95993: PUSH
95994: EMPTY
95995: LIST
95996: LIST
95997: PUSH
95998: LD_INT 3
96000: NEG
96001: PUSH
96002: LD_INT 3
96004: NEG
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: LD_INT 3
96012: NEG
96013: PUSH
96014: LD_INT 4
96016: NEG
96017: PUSH
96018: EMPTY
96019: LIST
96020: LIST
96021: PUSH
96022: LD_INT 2
96024: NEG
96025: PUSH
96026: LD_INT 3
96028: NEG
96029: PUSH
96030: EMPTY
96031: LIST
96032: LIST
96033: PUSH
96034: LD_INT 2
96036: NEG
96037: PUSH
96038: LD_INT 2
96040: NEG
96041: PUSH
96042: EMPTY
96043: LIST
96044: LIST
96045: PUSH
96046: LD_INT 3
96048: NEG
96049: PUSH
96050: LD_INT 2
96052: NEG
96053: PUSH
96054: EMPTY
96055: LIST
96056: LIST
96057: PUSH
96058: LD_INT 4
96060: NEG
96061: PUSH
96062: LD_INT 3
96064: NEG
96065: PUSH
96066: EMPTY
96067: LIST
96068: LIST
96069: PUSH
96070: LD_INT 4
96072: NEG
96073: PUSH
96074: LD_INT 4
96076: NEG
96077: PUSH
96078: EMPTY
96079: LIST
96080: LIST
96081: PUSH
96082: LD_INT 2
96084: NEG
96085: PUSH
96086: LD_INT 4
96088: NEG
96089: PUSH
96090: EMPTY
96091: LIST
96092: LIST
96093: PUSH
96094: LD_INT 4
96096: NEG
96097: PUSH
96098: LD_INT 2
96100: NEG
96101: PUSH
96102: EMPTY
96103: LIST
96104: LIST
96105: PUSH
96106: LD_INT 0
96108: PUSH
96109: LD_INT 4
96111: NEG
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: PUSH
96117: LD_INT 0
96119: PUSH
96120: LD_INT 5
96122: NEG
96123: PUSH
96124: EMPTY
96125: LIST
96126: LIST
96127: PUSH
96128: LD_INT 1
96130: PUSH
96131: LD_INT 4
96133: NEG
96134: PUSH
96135: EMPTY
96136: LIST
96137: LIST
96138: PUSH
96139: LD_INT 1
96141: PUSH
96142: LD_INT 3
96144: NEG
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: LD_INT 0
96152: PUSH
96153: LD_INT 3
96155: NEG
96156: PUSH
96157: EMPTY
96158: LIST
96159: LIST
96160: PUSH
96161: LD_INT 1
96163: NEG
96164: PUSH
96165: LD_INT 4
96167: NEG
96168: PUSH
96169: EMPTY
96170: LIST
96171: LIST
96172: PUSH
96173: LD_INT 1
96175: NEG
96176: PUSH
96177: LD_INT 5
96179: NEG
96180: PUSH
96181: EMPTY
96182: LIST
96183: LIST
96184: PUSH
96185: LD_INT 2
96187: PUSH
96188: LD_INT 3
96190: NEG
96191: PUSH
96192: EMPTY
96193: LIST
96194: LIST
96195: PUSH
96196: LD_INT 2
96198: NEG
96199: PUSH
96200: LD_INT 5
96202: NEG
96203: PUSH
96204: EMPTY
96205: LIST
96206: LIST
96207: PUSH
96208: LD_INT 3
96210: PUSH
96211: LD_INT 0
96213: PUSH
96214: EMPTY
96215: LIST
96216: LIST
96217: PUSH
96218: LD_INT 3
96220: PUSH
96221: LD_INT 1
96223: NEG
96224: PUSH
96225: EMPTY
96226: LIST
96227: LIST
96228: PUSH
96229: LD_INT 4
96231: PUSH
96232: LD_INT 0
96234: PUSH
96235: EMPTY
96236: LIST
96237: LIST
96238: PUSH
96239: LD_INT 4
96241: PUSH
96242: LD_INT 1
96244: PUSH
96245: EMPTY
96246: LIST
96247: LIST
96248: PUSH
96249: LD_INT 3
96251: PUSH
96252: LD_INT 1
96254: PUSH
96255: EMPTY
96256: LIST
96257: LIST
96258: PUSH
96259: LD_INT 2
96261: PUSH
96262: LD_INT 0
96264: PUSH
96265: EMPTY
96266: LIST
96267: LIST
96268: PUSH
96269: LD_INT 2
96271: PUSH
96272: LD_INT 1
96274: NEG
96275: PUSH
96276: EMPTY
96277: LIST
96278: LIST
96279: PUSH
96280: LD_INT 2
96282: PUSH
96283: LD_INT 2
96285: NEG
96286: PUSH
96287: EMPTY
96288: LIST
96289: LIST
96290: PUSH
96291: LD_INT 4
96293: PUSH
96294: LD_INT 2
96296: PUSH
96297: EMPTY
96298: LIST
96299: LIST
96300: PUSH
96301: LD_INT 4
96303: PUSH
96304: LD_INT 4
96306: PUSH
96307: EMPTY
96308: LIST
96309: LIST
96310: PUSH
96311: LD_INT 4
96313: PUSH
96314: LD_INT 3
96316: PUSH
96317: EMPTY
96318: LIST
96319: LIST
96320: PUSH
96321: LD_INT 5
96323: PUSH
96324: LD_INT 4
96326: PUSH
96327: EMPTY
96328: LIST
96329: LIST
96330: PUSH
96331: LD_INT 5
96333: PUSH
96334: LD_INT 5
96336: PUSH
96337: EMPTY
96338: LIST
96339: LIST
96340: PUSH
96341: LD_INT 4
96343: PUSH
96344: LD_INT 5
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PUSH
96351: LD_INT 3
96353: PUSH
96354: LD_INT 4
96356: PUSH
96357: EMPTY
96358: LIST
96359: LIST
96360: PUSH
96361: LD_INT 3
96363: PUSH
96364: LD_INT 3
96366: PUSH
96367: EMPTY
96368: LIST
96369: LIST
96370: PUSH
96371: LD_INT 5
96373: PUSH
96374: LD_INT 3
96376: PUSH
96377: EMPTY
96378: LIST
96379: LIST
96380: PUSH
96381: LD_INT 3
96383: PUSH
96384: LD_INT 5
96386: PUSH
96387: EMPTY
96388: LIST
96389: LIST
96390: PUSH
96391: EMPTY
96392: LIST
96393: LIST
96394: LIST
96395: LIST
96396: LIST
96397: LIST
96398: LIST
96399: LIST
96400: LIST
96401: LIST
96402: LIST
96403: LIST
96404: LIST
96405: LIST
96406: LIST
96407: LIST
96408: LIST
96409: LIST
96410: LIST
96411: LIST
96412: LIST
96413: LIST
96414: LIST
96415: LIST
96416: LIST
96417: LIST
96418: LIST
96419: LIST
96420: LIST
96421: LIST
96422: LIST
96423: LIST
96424: LIST
96425: LIST
96426: LIST
96427: LIST
96428: LIST
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: LIST
96437: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96438: LD_ADDR_VAR 0 33
96442: PUSH
96443: LD_INT 4
96445: NEG
96446: PUSH
96447: LD_INT 4
96449: NEG
96450: PUSH
96451: EMPTY
96452: LIST
96453: LIST
96454: PUSH
96455: LD_INT 4
96457: NEG
96458: PUSH
96459: LD_INT 5
96461: NEG
96462: PUSH
96463: EMPTY
96464: LIST
96465: LIST
96466: PUSH
96467: LD_INT 3
96469: NEG
96470: PUSH
96471: LD_INT 4
96473: NEG
96474: PUSH
96475: EMPTY
96476: LIST
96477: LIST
96478: PUSH
96479: LD_INT 3
96481: NEG
96482: PUSH
96483: LD_INT 3
96485: NEG
96486: PUSH
96487: EMPTY
96488: LIST
96489: LIST
96490: PUSH
96491: LD_INT 4
96493: NEG
96494: PUSH
96495: LD_INT 3
96497: NEG
96498: PUSH
96499: EMPTY
96500: LIST
96501: LIST
96502: PUSH
96503: LD_INT 5
96505: NEG
96506: PUSH
96507: LD_INT 4
96509: NEG
96510: PUSH
96511: EMPTY
96512: LIST
96513: LIST
96514: PUSH
96515: LD_INT 5
96517: NEG
96518: PUSH
96519: LD_INT 5
96521: NEG
96522: PUSH
96523: EMPTY
96524: LIST
96525: LIST
96526: PUSH
96527: LD_INT 3
96529: NEG
96530: PUSH
96531: LD_INT 5
96533: NEG
96534: PUSH
96535: EMPTY
96536: LIST
96537: LIST
96538: PUSH
96539: LD_INT 5
96541: NEG
96542: PUSH
96543: LD_INT 3
96545: NEG
96546: PUSH
96547: EMPTY
96548: LIST
96549: LIST
96550: PUSH
96551: LD_INT 0
96553: PUSH
96554: LD_INT 3
96556: NEG
96557: PUSH
96558: EMPTY
96559: LIST
96560: LIST
96561: PUSH
96562: LD_INT 0
96564: PUSH
96565: LD_INT 4
96567: NEG
96568: PUSH
96569: EMPTY
96570: LIST
96571: LIST
96572: PUSH
96573: LD_INT 1
96575: PUSH
96576: LD_INT 3
96578: NEG
96579: PUSH
96580: EMPTY
96581: LIST
96582: LIST
96583: PUSH
96584: LD_INT 1
96586: PUSH
96587: LD_INT 2
96589: NEG
96590: PUSH
96591: EMPTY
96592: LIST
96593: LIST
96594: PUSH
96595: LD_INT 0
96597: PUSH
96598: LD_INT 2
96600: NEG
96601: PUSH
96602: EMPTY
96603: LIST
96604: LIST
96605: PUSH
96606: LD_INT 1
96608: NEG
96609: PUSH
96610: LD_INT 3
96612: NEG
96613: PUSH
96614: EMPTY
96615: LIST
96616: LIST
96617: PUSH
96618: LD_INT 1
96620: NEG
96621: PUSH
96622: LD_INT 4
96624: NEG
96625: PUSH
96626: EMPTY
96627: LIST
96628: LIST
96629: PUSH
96630: LD_INT 2
96632: PUSH
96633: LD_INT 2
96635: NEG
96636: PUSH
96637: EMPTY
96638: LIST
96639: LIST
96640: PUSH
96641: LD_INT 2
96643: NEG
96644: PUSH
96645: LD_INT 4
96647: NEG
96648: PUSH
96649: EMPTY
96650: LIST
96651: LIST
96652: PUSH
96653: LD_INT 4
96655: PUSH
96656: LD_INT 0
96658: PUSH
96659: EMPTY
96660: LIST
96661: LIST
96662: PUSH
96663: LD_INT 4
96665: PUSH
96666: LD_INT 1
96668: NEG
96669: PUSH
96670: EMPTY
96671: LIST
96672: LIST
96673: PUSH
96674: LD_INT 5
96676: PUSH
96677: LD_INT 0
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PUSH
96684: LD_INT 5
96686: PUSH
96687: LD_INT 1
96689: PUSH
96690: EMPTY
96691: LIST
96692: LIST
96693: PUSH
96694: LD_INT 4
96696: PUSH
96697: LD_INT 1
96699: PUSH
96700: EMPTY
96701: LIST
96702: LIST
96703: PUSH
96704: LD_INT 3
96706: PUSH
96707: LD_INT 0
96709: PUSH
96710: EMPTY
96711: LIST
96712: LIST
96713: PUSH
96714: LD_INT 3
96716: PUSH
96717: LD_INT 1
96719: NEG
96720: PUSH
96721: EMPTY
96722: LIST
96723: LIST
96724: PUSH
96725: LD_INT 3
96727: PUSH
96728: LD_INT 2
96730: NEG
96731: PUSH
96732: EMPTY
96733: LIST
96734: LIST
96735: PUSH
96736: LD_INT 5
96738: PUSH
96739: LD_INT 2
96741: PUSH
96742: EMPTY
96743: LIST
96744: LIST
96745: PUSH
96746: LD_INT 3
96748: PUSH
96749: LD_INT 3
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PUSH
96756: LD_INT 3
96758: PUSH
96759: LD_INT 2
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: PUSH
96766: LD_INT 4
96768: PUSH
96769: LD_INT 3
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: PUSH
96776: LD_INT 4
96778: PUSH
96779: LD_INT 4
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: PUSH
96786: LD_INT 3
96788: PUSH
96789: LD_INT 4
96791: PUSH
96792: EMPTY
96793: LIST
96794: LIST
96795: PUSH
96796: LD_INT 2
96798: PUSH
96799: LD_INT 3
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PUSH
96806: LD_INT 2
96808: PUSH
96809: LD_INT 2
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: PUSH
96816: LD_INT 4
96818: PUSH
96819: LD_INT 2
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: PUSH
96826: LD_INT 2
96828: PUSH
96829: LD_INT 4
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: PUSH
96836: LD_INT 0
96838: PUSH
96839: LD_INT 4
96841: PUSH
96842: EMPTY
96843: LIST
96844: LIST
96845: PUSH
96846: LD_INT 0
96848: PUSH
96849: LD_INT 3
96851: PUSH
96852: EMPTY
96853: LIST
96854: LIST
96855: PUSH
96856: LD_INT 1
96858: PUSH
96859: LD_INT 4
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: LD_INT 1
96868: PUSH
96869: LD_INT 5
96871: PUSH
96872: EMPTY
96873: LIST
96874: LIST
96875: PUSH
96876: LD_INT 0
96878: PUSH
96879: LD_INT 5
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 1
96888: NEG
96889: PUSH
96890: LD_INT 4
96892: PUSH
96893: EMPTY
96894: LIST
96895: LIST
96896: PUSH
96897: LD_INT 1
96899: NEG
96900: PUSH
96901: LD_INT 3
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: PUSH
96908: LD_INT 2
96910: PUSH
96911: LD_INT 5
96913: PUSH
96914: EMPTY
96915: LIST
96916: LIST
96917: PUSH
96918: LD_INT 2
96920: NEG
96921: PUSH
96922: LD_INT 3
96924: PUSH
96925: EMPTY
96926: LIST
96927: LIST
96928: PUSH
96929: EMPTY
96930: LIST
96931: LIST
96932: LIST
96933: LIST
96934: LIST
96935: LIST
96936: LIST
96937: LIST
96938: LIST
96939: LIST
96940: LIST
96941: LIST
96942: LIST
96943: LIST
96944: LIST
96945: LIST
96946: LIST
96947: LIST
96948: LIST
96949: LIST
96950: LIST
96951: LIST
96952: LIST
96953: LIST
96954: LIST
96955: LIST
96956: LIST
96957: LIST
96958: LIST
96959: LIST
96960: LIST
96961: LIST
96962: LIST
96963: LIST
96964: LIST
96965: LIST
96966: LIST
96967: LIST
96968: LIST
96969: LIST
96970: LIST
96971: LIST
96972: LIST
96973: LIST
96974: LIST
96975: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96976: LD_ADDR_VAR 0 34
96980: PUSH
96981: LD_INT 0
96983: PUSH
96984: LD_INT 4
96986: NEG
96987: PUSH
96988: EMPTY
96989: LIST
96990: LIST
96991: PUSH
96992: LD_INT 0
96994: PUSH
96995: LD_INT 5
96997: NEG
96998: PUSH
96999: EMPTY
97000: LIST
97001: LIST
97002: PUSH
97003: LD_INT 1
97005: PUSH
97006: LD_INT 4
97008: NEG
97009: PUSH
97010: EMPTY
97011: LIST
97012: LIST
97013: PUSH
97014: LD_INT 1
97016: PUSH
97017: LD_INT 3
97019: NEG
97020: PUSH
97021: EMPTY
97022: LIST
97023: LIST
97024: PUSH
97025: LD_INT 0
97027: PUSH
97028: LD_INT 3
97030: NEG
97031: PUSH
97032: EMPTY
97033: LIST
97034: LIST
97035: PUSH
97036: LD_INT 1
97038: NEG
97039: PUSH
97040: LD_INT 4
97042: NEG
97043: PUSH
97044: EMPTY
97045: LIST
97046: LIST
97047: PUSH
97048: LD_INT 1
97050: NEG
97051: PUSH
97052: LD_INT 5
97054: NEG
97055: PUSH
97056: EMPTY
97057: LIST
97058: LIST
97059: PUSH
97060: LD_INT 2
97062: PUSH
97063: LD_INT 3
97065: NEG
97066: PUSH
97067: EMPTY
97068: LIST
97069: LIST
97070: PUSH
97071: LD_INT 2
97073: NEG
97074: PUSH
97075: LD_INT 5
97077: NEG
97078: PUSH
97079: EMPTY
97080: LIST
97081: LIST
97082: PUSH
97083: LD_INT 3
97085: PUSH
97086: LD_INT 0
97088: PUSH
97089: EMPTY
97090: LIST
97091: LIST
97092: PUSH
97093: LD_INT 3
97095: PUSH
97096: LD_INT 1
97098: NEG
97099: PUSH
97100: EMPTY
97101: LIST
97102: LIST
97103: PUSH
97104: LD_INT 4
97106: PUSH
97107: LD_INT 0
97109: PUSH
97110: EMPTY
97111: LIST
97112: LIST
97113: PUSH
97114: LD_INT 4
97116: PUSH
97117: LD_INT 1
97119: PUSH
97120: EMPTY
97121: LIST
97122: LIST
97123: PUSH
97124: LD_INT 3
97126: PUSH
97127: LD_INT 1
97129: PUSH
97130: EMPTY
97131: LIST
97132: LIST
97133: PUSH
97134: LD_INT 2
97136: PUSH
97137: LD_INT 0
97139: PUSH
97140: EMPTY
97141: LIST
97142: LIST
97143: PUSH
97144: LD_INT 2
97146: PUSH
97147: LD_INT 1
97149: NEG
97150: PUSH
97151: EMPTY
97152: LIST
97153: LIST
97154: PUSH
97155: LD_INT 2
97157: PUSH
97158: LD_INT 2
97160: NEG
97161: PUSH
97162: EMPTY
97163: LIST
97164: LIST
97165: PUSH
97166: LD_INT 4
97168: PUSH
97169: LD_INT 2
97171: PUSH
97172: EMPTY
97173: LIST
97174: LIST
97175: PUSH
97176: LD_INT 4
97178: PUSH
97179: LD_INT 4
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: PUSH
97186: LD_INT 4
97188: PUSH
97189: LD_INT 3
97191: PUSH
97192: EMPTY
97193: LIST
97194: LIST
97195: PUSH
97196: LD_INT 5
97198: PUSH
97199: LD_INT 4
97201: PUSH
97202: EMPTY
97203: LIST
97204: LIST
97205: PUSH
97206: LD_INT 5
97208: PUSH
97209: LD_INT 5
97211: PUSH
97212: EMPTY
97213: LIST
97214: LIST
97215: PUSH
97216: LD_INT 4
97218: PUSH
97219: LD_INT 5
97221: PUSH
97222: EMPTY
97223: LIST
97224: LIST
97225: PUSH
97226: LD_INT 3
97228: PUSH
97229: LD_INT 4
97231: PUSH
97232: EMPTY
97233: LIST
97234: LIST
97235: PUSH
97236: LD_INT 3
97238: PUSH
97239: LD_INT 3
97241: PUSH
97242: EMPTY
97243: LIST
97244: LIST
97245: PUSH
97246: LD_INT 5
97248: PUSH
97249: LD_INT 3
97251: PUSH
97252: EMPTY
97253: LIST
97254: LIST
97255: PUSH
97256: LD_INT 3
97258: PUSH
97259: LD_INT 5
97261: PUSH
97262: EMPTY
97263: LIST
97264: LIST
97265: PUSH
97266: LD_INT 0
97268: PUSH
97269: LD_INT 3
97271: PUSH
97272: EMPTY
97273: LIST
97274: LIST
97275: PUSH
97276: LD_INT 0
97278: PUSH
97279: LD_INT 2
97281: PUSH
97282: EMPTY
97283: LIST
97284: LIST
97285: PUSH
97286: LD_INT 1
97288: PUSH
97289: LD_INT 3
97291: PUSH
97292: EMPTY
97293: LIST
97294: LIST
97295: PUSH
97296: LD_INT 1
97298: PUSH
97299: LD_INT 4
97301: PUSH
97302: EMPTY
97303: LIST
97304: LIST
97305: PUSH
97306: LD_INT 0
97308: PUSH
97309: LD_INT 4
97311: PUSH
97312: EMPTY
97313: LIST
97314: LIST
97315: PUSH
97316: LD_INT 1
97318: NEG
97319: PUSH
97320: LD_INT 3
97322: PUSH
97323: EMPTY
97324: LIST
97325: LIST
97326: PUSH
97327: LD_INT 1
97329: NEG
97330: PUSH
97331: LD_INT 2
97333: PUSH
97334: EMPTY
97335: LIST
97336: LIST
97337: PUSH
97338: LD_INT 2
97340: PUSH
97341: LD_INT 4
97343: PUSH
97344: EMPTY
97345: LIST
97346: LIST
97347: PUSH
97348: LD_INT 2
97350: NEG
97351: PUSH
97352: LD_INT 2
97354: PUSH
97355: EMPTY
97356: LIST
97357: LIST
97358: PUSH
97359: LD_INT 4
97361: NEG
97362: PUSH
97363: LD_INT 0
97365: PUSH
97366: EMPTY
97367: LIST
97368: LIST
97369: PUSH
97370: LD_INT 4
97372: NEG
97373: PUSH
97374: LD_INT 1
97376: NEG
97377: PUSH
97378: EMPTY
97379: LIST
97380: LIST
97381: PUSH
97382: LD_INT 3
97384: NEG
97385: PUSH
97386: LD_INT 0
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PUSH
97393: LD_INT 3
97395: NEG
97396: PUSH
97397: LD_INT 1
97399: PUSH
97400: EMPTY
97401: LIST
97402: LIST
97403: PUSH
97404: LD_INT 4
97406: NEG
97407: PUSH
97408: LD_INT 1
97410: PUSH
97411: EMPTY
97412: LIST
97413: LIST
97414: PUSH
97415: LD_INT 5
97417: NEG
97418: PUSH
97419: LD_INT 0
97421: PUSH
97422: EMPTY
97423: LIST
97424: LIST
97425: PUSH
97426: LD_INT 5
97428: NEG
97429: PUSH
97430: LD_INT 1
97432: NEG
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: PUSH
97438: LD_INT 5
97440: NEG
97441: PUSH
97442: LD_INT 2
97444: NEG
97445: PUSH
97446: EMPTY
97447: LIST
97448: LIST
97449: PUSH
97450: LD_INT 3
97452: NEG
97453: PUSH
97454: LD_INT 2
97456: PUSH
97457: EMPTY
97458: LIST
97459: LIST
97460: PUSH
97461: EMPTY
97462: LIST
97463: LIST
97464: LIST
97465: LIST
97466: LIST
97467: LIST
97468: LIST
97469: LIST
97470: LIST
97471: LIST
97472: LIST
97473: LIST
97474: LIST
97475: LIST
97476: LIST
97477: LIST
97478: LIST
97479: LIST
97480: LIST
97481: LIST
97482: LIST
97483: LIST
97484: LIST
97485: LIST
97486: LIST
97487: LIST
97488: LIST
97489: LIST
97490: LIST
97491: LIST
97492: LIST
97493: LIST
97494: LIST
97495: LIST
97496: LIST
97497: LIST
97498: LIST
97499: LIST
97500: LIST
97501: LIST
97502: LIST
97503: LIST
97504: LIST
97505: LIST
97506: LIST
97507: ST_TO_ADDR
// end ; end ;
97508: GO 97511
97510: POP
// case btype of b_depot , b_warehouse :
97511: LD_VAR 0 1
97515: PUSH
97516: LD_INT 0
97518: DOUBLE
97519: EQUAL
97520: IFTRUE 97530
97522: LD_INT 1
97524: DOUBLE
97525: EQUAL
97526: IFTRUE 97530
97528: GO 97731
97530: POP
// case nation of nation_american :
97531: LD_VAR 0 5
97535: PUSH
97536: LD_INT 1
97538: DOUBLE
97539: EQUAL
97540: IFTRUE 97544
97542: GO 97600
97544: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
97545: LD_ADDR_VAR 0 9
97549: PUSH
97550: LD_VAR 0 11
97554: PUSH
97555: LD_VAR 0 12
97559: PUSH
97560: LD_VAR 0 13
97564: PUSH
97565: LD_VAR 0 14
97569: PUSH
97570: LD_VAR 0 15
97574: PUSH
97575: LD_VAR 0 16
97579: PUSH
97580: EMPTY
97581: LIST
97582: LIST
97583: LIST
97584: LIST
97585: LIST
97586: LIST
97587: PUSH
97588: LD_VAR 0 4
97592: PUSH
97593: LD_INT 1
97595: PLUS
97596: ARRAY
97597: ST_TO_ADDR
97598: GO 97729
97600: LD_INT 2
97602: DOUBLE
97603: EQUAL
97604: IFTRUE 97608
97606: GO 97664
97608: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
97609: LD_ADDR_VAR 0 9
97613: PUSH
97614: LD_VAR 0 17
97618: PUSH
97619: LD_VAR 0 18
97623: PUSH
97624: LD_VAR 0 19
97628: PUSH
97629: LD_VAR 0 20
97633: PUSH
97634: LD_VAR 0 21
97638: PUSH
97639: LD_VAR 0 22
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: LIST
97648: LIST
97649: LIST
97650: LIST
97651: PUSH
97652: LD_VAR 0 4
97656: PUSH
97657: LD_INT 1
97659: PLUS
97660: ARRAY
97661: ST_TO_ADDR
97662: GO 97729
97664: LD_INT 3
97666: DOUBLE
97667: EQUAL
97668: IFTRUE 97672
97670: GO 97728
97672: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97673: LD_ADDR_VAR 0 9
97677: PUSH
97678: LD_VAR 0 23
97682: PUSH
97683: LD_VAR 0 24
97687: PUSH
97688: LD_VAR 0 25
97692: PUSH
97693: LD_VAR 0 26
97697: PUSH
97698: LD_VAR 0 27
97702: PUSH
97703: LD_VAR 0 28
97707: PUSH
97708: EMPTY
97709: LIST
97710: LIST
97711: LIST
97712: LIST
97713: LIST
97714: LIST
97715: PUSH
97716: LD_VAR 0 4
97720: PUSH
97721: LD_INT 1
97723: PLUS
97724: ARRAY
97725: ST_TO_ADDR
97726: GO 97729
97728: POP
97729: GO 98284
97731: LD_INT 2
97733: DOUBLE
97734: EQUAL
97735: IFTRUE 97745
97737: LD_INT 3
97739: DOUBLE
97740: EQUAL
97741: IFTRUE 97745
97743: GO 97801
97745: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97746: LD_ADDR_VAR 0 9
97750: PUSH
97751: LD_VAR 0 29
97755: PUSH
97756: LD_VAR 0 30
97760: PUSH
97761: LD_VAR 0 31
97765: PUSH
97766: LD_VAR 0 32
97770: PUSH
97771: LD_VAR 0 33
97775: PUSH
97776: LD_VAR 0 34
97780: PUSH
97781: EMPTY
97782: LIST
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: PUSH
97789: LD_VAR 0 4
97793: PUSH
97794: LD_INT 1
97796: PLUS
97797: ARRAY
97798: ST_TO_ADDR
97799: GO 98284
97801: LD_INT 16
97803: DOUBLE
97804: EQUAL
97805: IFTRUE 97863
97807: LD_INT 17
97809: DOUBLE
97810: EQUAL
97811: IFTRUE 97863
97813: LD_INT 18
97815: DOUBLE
97816: EQUAL
97817: IFTRUE 97863
97819: LD_INT 19
97821: DOUBLE
97822: EQUAL
97823: IFTRUE 97863
97825: LD_INT 22
97827: DOUBLE
97828: EQUAL
97829: IFTRUE 97863
97831: LD_INT 20
97833: DOUBLE
97834: EQUAL
97835: IFTRUE 97863
97837: LD_INT 21
97839: DOUBLE
97840: EQUAL
97841: IFTRUE 97863
97843: LD_INT 23
97845: DOUBLE
97846: EQUAL
97847: IFTRUE 97863
97849: LD_INT 24
97851: DOUBLE
97852: EQUAL
97853: IFTRUE 97863
97855: LD_INT 25
97857: DOUBLE
97858: EQUAL
97859: IFTRUE 97863
97861: GO 97919
97863: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97864: LD_ADDR_VAR 0 9
97868: PUSH
97869: LD_VAR 0 35
97873: PUSH
97874: LD_VAR 0 36
97878: PUSH
97879: LD_VAR 0 37
97883: PUSH
97884: LD_VAR 0 38
97888: PUSH
97889: LD_VAR 0 39
97893: PUSH
97894: LD_VAR 0 40
97898: PUSH
97899: EMPTY
97900: LIST
97901: LIST
97902: LIST
97903: LIST
97904: LIST
97905: LIST
97906: PUSH
97907: LD_VAR 0 4
97911: PUSH
97912: LD_INT 1
97914: PLUS
97915: ARRAY
97916: ST_TO_ADDR
97917: GO 98284
97919: LD_INT 6
97921: DOUBLE
97922: EQUAL
97923: IFTRUE 97975
97925: LD_INT 7
97927: DOUBLE
97928: EQUAL
97929: IFTRUE 97975
97931: LD_INT 8
97933: DOUBLE
97934: EQUAL
97935: IFTRUE 97975
97937: LD_INT 13
97939: DOUBLE
97940: EQUAL
97941: IFTRUE 97975
97943: LD_INT 12
97945: DOUBLE
97946: EQUAL
97947: IFTRUE 97975
97949: LD_INT 15
97951: DOUBLE
97952: EQUAL
97953: IFTRUE 97975
97955: LD_INT 11
97957: DOUBLE
97958: EQUAL
97959: IFTRUE 97975
97961: LD_INT 14
97963: DOUBLE
97964: EQUAL
97965: IFTRUE 97975
97967: LD_INT 10
97969: DOUBLE
97970: EQUAL
97971: IFTRUE 97975
97973: GO 98031
97975: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
97976: LD_ADDR_VAR 0 9
97980: PUSH
97981: LD_VAR 0 41
97985: PUSH
97986: LD_VAR 0 42
97990: PUSH
97991: LD_VAR 0 43
97995: PUSH
97996: LD_VAR 0 44
98000: PUSH
98001: LD_VAR 0 45
98005: PUSH
98006: LD_VAR 0 46
98010: PUSH
98011: EMPTY
98012: LIST
98013: LIST
98014: LIST
98015: LIST
98016: LIST
98017: LIST
98018: PUSH
98019: LD_VAR 0 4
98023: PUSH
98024: LD_INT 1
98026: PLUS
98027: ARRAY
98028: ST_TO_ADDR
98029: GO 98284
98031: LD_INT 36
98033: DOUBLE
98034: EQUAL
98035: IFTRUE 98039
98037: GO 98095
98039: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
98040: LD_ADDR_VAR 0 9
98044: PUSH
98045: LD_VAR 0 47
98049: PUSH
98050: LD_VAR 0 48
98054: PUSH
98055: LD_VAR 0 49
98059: PUSH
98060: LD_VAR 0 50
98064: PUSH
98065: LD_VAR 0 51
98069: PUSH
98070: LD_VAR 0 52
98074: PUSH
98075: EMPTY
98076: LIST
98077: LIST
98078: LIST
98079: LIST
98080: LIST
98081: LIST
98082: PUSH
98083: LD_VAR 0 4
98087: PUSH
98088: LD_INT 1
98090: PLUS
98091: ARRAY
98092: ST_TO_ADDR
98093: GO 98284
98095: LD_INT 4
98097: DOUBLE
98098: EQUAL
98099: IFTRUE 98121
98101: LD_INT 5
98103: DOUBLE
98104: EQUAL
98105: IFTRUE 98121
98107: LD_INT 34
98109: DOUBLE
98110: EQUAL
98111: IFTRUE 98121
98113: LD_INT 37
98115: DOUBLE
98116: EQUAL
98117: IFTRUE 98121
98119: GO 98177
98121: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
98122: LD_ADDR_VAR 0 9
98126: PUSH
98127: LD_VAR 0 53
98131: PUSH
98132: LD_VAR 0 54
98136: PUSH
98137: LD_VAR 0 55
98141: PUSH
98142: LD_VAR 0 56
98146: PUSH
98147: LD_VAR 0 57
98151: PUSH
98152: LD_VAR 0 58
98156: PUSH
98157: EMPTY
98158: LIST
98159: LIST
98160: LIST
98161: LIST
98162: LIST
98163: LIST
98164: PUSH
98165: LD_VAR 0 4
98169: PUSH
98170: LD_INT 1
98172: PLUS
98173: ARRAY
98174: ST_TO_ADDR
98175: GO 98284
98177: LD_INT 31
98179: DOUBLE
98180: EQUAL
98181: IFTRUE 98227
98183: LD_INT 32
98185: DOUBLE
98186: EQUAL
98187: IFTRUE 98227
98189: LD_INT 33
98191: DOUBLE
98192: EQUAL
98193: IFTRUE 98227
98195: LD_INT 27
98197: DOUBLE
98198: EQUAL
98199: IFTRUE 98227
98201: LD_INT 26
98203: DOUBLE
98204: EQUAL
98205: IFTRUE 98227
98207: LD_INT 28
98209: DOUBLE
98210: EQUAL
98211: IFTRUE 98227
98213: LD_INT 29
98215: DOUBLE
98216: EQUAL
98217: IFTRUE 98227
98219: LD_INT 30
98221: DOUBLE
98222: EQUAL
98223: IFTRUE 98227
98225: GO 98283
98227: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
98228: LD_ADDR_VAR 0 9
98232: PUSH
98233: LD_VAR 0 59
98237: PUSH
98238: LD_VAR 0 60
98242: PUSH
98243: LD_VAR 0 61
98247: PUSH
98248: LD_VAR 0 62
98252: PUSH
98253: LD_VAR 0 63
98257: PUSH
98258: LD_VAR 0 64
98262: PUSH
98263: EMPTY
98264: LIST
98265: LIST
98266: LIST
98267: LIST
98268: LIST
98269: LIST
98270: PUSH
98271: LD_VAR 0 4
98275: PUSH
98276: LD_INT 1
98278: PLUS
98279: ARRAY
98280: ST_TO_ADDR
98281: GO 98284
98283: POP
// temp_list2 = [ ] ;
98284: LD_ADDR_VAR 0 10
98288: PUSH
98289: EMPTY
98290: ST_TO_ADDR
// for i in temp_list do
98291: LD_ADDR_VAR 0 8
98295: PUSH
98296: LD_VAR 0 9
98300: PUSH
98301: FOR_IN
98302: IFFALSE 98354
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
98304: LD_ADDR_VAR 0 10
98308: PUSH
98309: LD_VAR 0 10
98313: PUSH
98314: LD_VAR 0 8
98318: PUSH
98319: LD_INT 1
98321: ARRAY
98322: PUSH
98323: LD_VAR 0 2
98327: PLUS
98328: PUSH
98329: LD_VAR 0 8
98333: PUSH
98334: LD_INT 2
98336: ARRAY
98337: PUSH
98338: LD_VAR 0 3
98342: PLUS
98343: PUSH
98344: EMPTY
98345: LIST
98346: LIST
98347: PUSH
98348: EMPTY
98349: LIST
98350: ADD
98351: ST_TO_ADDR
98352: GO 98301
98354: POP
98355: POP
// result = temp_list2 ;
98356: LD_ADDR_VAR 0 7
98360: PUSH
98361: LD_VAR 0 10
98365: ST_TO_ADDR
// end ;
98366: LD_VAR 0 7
98370: RET
// export function EnemyInRange ( unit , dist ) ; begin
98371: LD_INT 0
98373: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98374: LD_ADDR_VAR 0 3
98378: PUSH
98379: LD_VAR 0 1
98383: PPUSH
98384: CALL_OW 255
98388: PPUSH
98389: LD_VAR 0 1
98393: PPUSH
98394: CALL_OW 250
98398: PPUSH
98399: LD_VAR 0 1
98403: PPUSH
98404: CALL_OW 251
98408: PPUSH
98409: LD_VAR 0 2
98413: PPUSH
98414: CALL 71767 0 4
98418: PUSH
98419: LD_INT 4
98421: ARRAY
98422: ST_TO_ADDR
// end ;
98423: LD_VAR 0 3
98427: RET
// export function PlayerSeeMe ( unit ) ; begin
98428: LD_INT 0
98430: PPUSH
// result := See ( your_side , unit ) ;
98431: LD_ADDR_VAR 0 2
98435: PUSH
98436: LD_OWVAR 2
98440: PPUSH
98441: LD_VAR 0 1
98445: PPUSH
98446: CALL_OW 292
98450: ST_TO_ADDR
// end ;
98451: LD_VAR 0 2
98455: RET
// export function ReverseDir ( unit ) ; begin
98456: LD_INT 0
98458: PPUSH
// if not unit then
98459: LD_VAR 0 1
98463: NOT
98464: IFFALSE 98468
// exit ;
98466: GO 98491
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
98468: LD_ADDR_VAR 0 2
98472: PUSH
98473: LD_VAR 0 1
98477: PPUSH
98478: CALL_OW 254
98482: PUSH
98483: LD_INT 3
98485: PLUS
98486: PUSH
98487: LD_INT 6
98489: MOD
98490: ST_TO_ADDR
// end ;
98491: LD_VAR 0 2
98495: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98496: LD_INT 0
98498: PPUSH
98499: PPUSH
98500: PPUSH
98501: PPUSH
98502: PPUSH
// if not hexes then
98503: LD_VAR 0 2
98507: NOT
98508: IFFALSE 98512
// exit ;
98510: GO 98660
// dist := 9999 ;
98512: LD_ADDR_VAR 0 5
98516: PUSH
98517: LD_INT 9999
98519: ST_TO_ADDR
// for i = 1 to hexes do
98520: LD_ADDR_VAR 0 4
98524: PUSH
98525: DOUBLE
98526: LD_INT 1
98528: DEC
98529: ST_TO_ADDR
98530: LD_VAR 0 2
98534: PUSH
98535: FOR_TO
98536: IFFALSE 98648
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98538: LD_VAR 0 1
98542: PPUSH
98543: LD_VAR 0 2
98547: PUSH
98548: LD_VAR 0 4
98552: ARRAY
98553: PUSH
98554: LD_INT 1
98556: ARRAY
98557: PPUSH
98558: LD_VAR 0 2
98562: PUSH
98563: LD_VAR 0 4
98567: ARRAY
98568: PUSH
98569: LD_INT 2
98571: ARRAY
98572: PPUSH
98573: CALL_OW 297
98577: PUSH
98578: LD_VAR 0 5
98582: LESS
98583: IFFALSE 98646
// begin hex := hexes [ i ] ;
98585: LD_ADDR_VAR 0 7
98589: PUSH
98590: LD_VAR 0 2
98594: PUSH
98595: LD_VAR 0 4
98599: ARRAY
98600: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98601: LD_ADDR_VAR 0 5
98605: PUSH
98606: LD_VAR 0 1
98610: PPUSH
98611: LD_VAR 0 2
98615: PUSH
98616: LD_VAR 0 4
98620: ARRAY
98621: PUSH
98622: LD_INT 1
98624: ARRAY
98625: PPUSH
98626: LD_VAR 0 2
98630: PUSH
98631: LD_VAR 0 4
98635: ARRAY
98636: PUSH
98637: LD_INT 2
98639: ARRAY
98640: PPUSH
98641: CALL_OW 297
98645: ST_TO_ADDR
// end ; end ;
98646: GO 98535
98648: POP
98649: POP
// result := hex ;
98650: LD_ADDR_VAR 0 3
98654: PUSH
98655: LD_VAR 0 7
98659: ST_TO_ADDR
// end ;
98660: LD_VAR 0 3
98664: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98665: LD_INT 0
98667: PPUSH
98668: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98669: LD_VAR 0 1
98673: NOT
98674: PUSH
98675: LD_VAR 0 1
98679: PUSH
98680: LD_INT 21
98682: PUSH
98683: LD_INT 2
98685: PUSH
98686: EMPTY
98687: LIST
98688: LIST
98689: PUSH
98690: LD_INT 23
98692: PUSH
98693: LD_INT 2
98695: PUSH
98696: EMPTY
98697: LIST
98698: LIST
98699: PUSH
98700: EMPTY
98701: LIST
98702: LIST
98703: PPUSH
98704: CALL_OW 69
98708: IN
98709: NOT
98710: OR
98711: IFFALSE 98715
// exit ;
98713: GO 98762
// for i = 1 to 3 do
98715: LD_ADDR_VAR 0 3
98719: PUSH
98720: DOUBLE
98721: LD_INT 1
98723: DEC
98724: ST_TO_ADDR
98725: LD_INT 3
98727: PUSH
98728: FOR_TO
98729: IFFALSE 98760
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98731: LD_VAR 0 1
98735: PPUSH
98736: CALL_OW 250
98740: PPUSH
98741: LD_VAR 0 1
98745: PPUSH
98746: CALL_OW 251
98750: PPUSH
98751: LD_INT 1
98753: PPUSH
98754: CALL_OW 453
98758: GO 98728
98760: POP
98761: POP
// end ;
98762: LD_VAR 0 2
98766: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98767: LD_INT 0
98769: PPUSH
98770: PPUSH
98771: PPUSH
98772: PPUSH
98773: PPUSH
98774: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98775: LD_VAR 0 1
98779: NOT
98780: PUSH
98781: LD_VAR 0 2
98785: NOT
98786: OR
98787: PUSH
98788: LD_VAR 0 1
98792: PPUSH
98793: CALL_OW 314
98797: OR
98798: IFFALSE 98802
// exit ;
98800: GO 99243
// x := GetX ( enemy_unit ) ;
98802: LD_ADDR_VAR 0 7
98806: PUSH
98807: LD_VAR 0 2
98811: PPUSH
98812: CALL_OW 250
98816: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98817: LD_ADDR_VAR 0 8
98821: PUSH
98822: LD_VAR 0 2
98826: PPUSH
98827: CALL_OW 251
98831: ST_TO_ADDR
// if not x or not y then
98832: LD_VAR 0 7
98836: NOT
98837: PUSH
98838: LD_VAR 0 8
98842: NOT
98843: OR
98844: IFFALSE 98848
// exit ;
98846: GO 99243
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98848: LD_ADDR_VAR 0 6
98852: PUSH
98853: LD_VAR 0 7
98857: PPUSH
98858: LD_INT 0
98860: PPUSH
98861: LD_INT 4
98863: PPUSH
98864: CALL_OW 272
98868: PUSH
98869: LD_VAR 0 8
98873: PPUSH
98874: LD_INT 0
98876: PPUSH
98877: LD_INT 4
98879: PPUSH
98880: CALL_OW 273
98884: PUSH
98885: EMPTY
98886: LIST
98887: LIST
98888: PUSH
98889: LD_VAR 0 7
98893: PPUSH
98894: LD_INT 1
98896: PPUSH
98897: LD_INT 4
98899: PPUSH
98900: CALL_OW 272
98904: PUSH
98905: LD_VAR 0 8
98909: PPUSH
98910: LD_INT 1
98912: PPUSH
98913: LD_INT 4
98915: PPUSH
98916: CALL_OW 273
98920: PUSH
98921: EMPTY
98922: LIST
98923: LIST
98924: PUSH
98925: LD_VAR 0 7
98929: PPUSH
98930: LD_INT 2
98932: PPUSH
98933: LD_INT 4
98935: PPUSH
98936: CALL_OW 272
98940: PUSH
98941: LD_VAR 0 8
98945: PPUSH
98946: LD_INT 2
98948: PPUSH
98949: LD_INT 4
98951: PPUSH
98952: CALL_OW 273
98956: PUSH
98957: EMPTY
98958: LIST
98959: LIST
98960: PUSH
98961: LD_VAR 0 7
98965: PPUSH
98966: LD_INT 3
98968: PPUSH
98969: LD_INT 4
98971: PPUSH
98972: CALL_OW 272
98976: PUSH
98977: LD_VAR 0 8
98981: PPUSH
98982: LD_INT 3
98984: PPUSH
98985: LD_INT 4
98987: PPUSH
98988: CALL_OW 273
98992: PUSH
98993: EMPTY
98994: LIST
98995: LIST
98996: PUSH
98997: LD_VAR 0 7
99001: PPUSH
99002: LD_INT 4
99004: PPUSH
99005: LD_INT 4
99007: PPUSH
99008: CALL_OW 272
99012: PUSH
99013: LD_VAR 0 8
99017: PPUSH
99018: LD_INT 4
99020: PPUSH
99021: LD_INT 4
99023: PPUSH
99024: CALL_OW 273
99028: PUSH
99029: EMPTY
99030: LIST
99031: LIST
99032: PUSH
99033: LD_VAR 0 7
99037: PPUSH
99038: LD_INT 5
99040: PPUSH
99041: LD_INT 4
99043: PPUSH
99044: CALL_OW 272
99048: PUSH
99049: LD_VAR 0 8
99053: PPUSH
99054: LD_INT 5
99056: PPUSH
99057: LD_INT 4
99059: PPUSH
99060: CALL_OW 273
99064: PUSH
99065: EMPTY
99066: LIST
99067: LIST
99068: PUSH
99069: EMPTY
99070: LIST
99071: LIST
99072: LIST
99073: LIST
99074: LIST
99075: LIST
99076: ST_TO_ADDR
// for i = tmp downto 1 do
99077: LD_ADDR_VAR 0 4
99081: PUSH
99082: DOUBLE
99083: LD_VAR 0 6
99087: INC
99088: ST_TO_ADDR
99089: LD_INT 1
99091: PUSH
99092: FOR_DOWNTO
99093: IFFALSE 99194
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
99095: LD_VAR 0 6
99099: PUSH
99100: LD_VAR 0 4
99104: ARRAY
99105: PUSH
99106: LD_INT 1
99108: ARRAY
99109: PPUSH
99110: LD_VAR 0 6
99114: PUSH
99115: LD_VAR 0 4
99119: ARRAY
99120: PUSH
99121: LD_INT 2
99123: ARRAY
99124: PPUSH
99125: CALL_OW 488
99129: NOT
99130: PUSH
99131: LD_VAR 0 6
99135: PUSH
99136: LD_VAR 0 4
99140: ARRAY
99141: PUSH
99142: LD_INT 1
99144: ARRAY
99145: PPUSH
99146: LD_VAR 0 6
99150: PUSH
99151: LD_VAR 0 4
99155: ARRAY
99156: PUSH
99157: LD_INT 2
99159: ARRAY
99160: PPUSH
99161: CALL_OW 428
99165: PUSH
99166: LD_INT 0
99168: NONEQUAL
99169: OR
99170: IFFALSE 99192
// tmp := Delete ( tmp , i ) ;
99172: LD_ADDR_VAR 0 6
99176: PUSH
99177: LD_VAR 0 6
99181: PPUSH
99182: LD_VAR 0 4
99186: PPUSH
99187: CALL_OW 3
99191: ST_TO_ADDR
99192: GO 99092
99194: POP
99195: POP
// j := GetClosestHex ( unit , tmp ) ;
99196: LD_ADDR_VAR 0 5
99200: PUSH
99201: LD_VAR 0 1
99205: PPUSH
99206: LD_VAR 0 6
99210: PPUSH
99211: CALL 98496 0 2
99215: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
99216: LD_VAR 0 1
99220: PPUSH
99221: LD_VAR 0 5
99225: PUSH
99226: LD_INT 1
99228: ARRAY
99229: PPUSH
99230: LD_VAR 0 5
99234: PUSH
99235: LD_INT 2
99237: ARRAY
99238: PPUSH
99239: CALL_OW 111
// end ;
99243: LD_VAR 0 3
99247: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
99248: LD_INT 0
99250: PPUSH
99251: PPUSH
99252: PPUSH
// uc_side = 0 ;
99253: LD_ADDR_OWVAR 20
99257: PUSH
99258: LD_INT 0
99260: ST_TO_ADDR
// uc_nation = 0 ;
99261: LD_ADDR_OWVAR 21
99265: PUSH
99266: LD_INT 0
99268: ST_TO_ADDR
// InitHc_All ( ) ;
99269: CALL_OW 584
// InitVc ;
99273: CALL_OW 20
// if mastodonts then
99277: LD_VAR 0 6
99281: IFFALSE 99348
// for i = 1 to mastodonts do
99283: LD_ADDR_VAR 0 11
99287: PUSH
99288: DOUBLE
99289: LD_INT 1
99291: DEC
99292: ST_TO_ADDR
99293: LD_VAR 0 6
99297: PUSH
99298: FOR_TO
99299: IFFALSE 99346
// begin vc_chassis := 31 ;
99301: LD_ADDR_OWVAR 37
99305: PUSH
99306: LD_INT 31
99308: ST_TO_ADDR
// vc_control := control_rider ;
99309: LD_ADDR_OWVAR 38
99313: PUSH
99314: LD_INT 4
99316: ST_TO_ADDR
// animal := CreateVehicle ;
99317: LD_ADDR_VAR 0 12
99321: PUSH
99322: CALL_OW 45
99326: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99327: LD_VAR 0 12
99331: PPUSH
99332: LD_VAR 0 8
99336: PPUSH
99337: LD_INT 0
99339: PPUSH
99340: CALL 101536 0 3
// end ;
99344: GO 99298
99346: POP
99347: POP
// if horses then
99348: LD_VAR 0 5
99352: IFFALSE 99419
// for i = 1 to horses do
99354: LD_ADDR_VAR 0 11
99358: PUSH
99359: DOUBLE
99360: LD_INT 1
99362: DEC
99363: ST_TO_ADDR
99364: LD_VAR 0 5
99368: PUSH
99369: FOR_TO
99370: IFFALSE 99417
// begin hc_class := 21 ;
99372: LD_ADDR_OWVAR 28
99376: PUSH
99377: LD_INT 21
99379: ST_TO_ADDR
// hc_gallery :=  ;
99380: LD_ADDR_OWVAR 33
99384: PUSH
99385: LD_STRING 
99387: ST_TO_ADDR
// animal := CreateHuman ;
99388: LD_ADDR_VAR 0 12
99392: PUSH
99393: CALL_OW 44
99397: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99398: LD_VAR 0 12
99402: PPUSH
99403: LD_VAR 0 8
99407: PPUSH
99408: LD_INT 0
99410: PPUSH
99411: CALL 101536 0 3
// end ;
99415: GO 99369
99417: POP
99418: POP
// if birds then
99419: LD_VAR 0 1
99423: IFFALSE 99490
// for i = 1 to birds do
99425: LD_ADDR_VAR 0 11
99429: PUSH
99430: DOUBLE
99431: LD_INT 1
99433: DEC
99434: ST_TO_ADDR
99435: LD_VAR 0 1
99439: PUSH
99440: FOR_TO
99441: IFFALSE 99488
// begin hc_class = 18 ;
99443: LD_ADDR_OWVAR 28
99447: PUSH
99448: LD_INT 18
99450: ST_TO_ADDR
// hc_gallery =  ;
99451: LD_ADDR_OWVAR 33
99455: PUSH
99456: LD_STRING 
99458: ST_TO_ADDR
// animal := CreateHuman ;
99459: LD_ADDR_VAR 0 12
99463: PUSH
99464: CALL_OW 44
99468: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99469: LD_VAR 0 12
99473: PPUSH
99474: LD_VAR 0 8
99478: PPUSH
99479: LD_INT 0
99481: PPUSH
99482: CALL 101536 0 3
// end ;
99486: GO 99440
99488: POP
99489: POP
// if tigers then
99490: LD_VAR 0 2
99494: IFFALSE 99578
// for i = 1 to tigers do
99496: LD_ADDR_VAR 0 11
99500: PUSH
99501: DOUBLE
99502: LD_INT 1
99504: DEC
99505: ST_TO_ADDR
99506: LD_VAR 0 2
99510: PUSH
99511: FOR_TO
99512: IFFALSE 99576
// begin hc_class = class_tiger ;
99514: LD_ADDR_OWVAR 28
99518: PUSH
99519: LD_INT 14
99521: ST_TO_ADDR
// hc_gallery =  ;
99522: LD_ADDR_OWVAR 33
99526: PUSH
99527: LD_STRING 
99529: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99530: LD_ADDR_OWVAR 35
99534: PUSH
99535: LD_INT 7
99537: NEG
99538: PPUSH
99539: LD_INT 7
99541: PPUSH
99542: CALL_OW 12
99546: ST_TO_ADDR
// animal := CreateHuman ;
99547: LD_ADDR_VAR 0 12
99551: PUSH
99552: CALL_OW 44
99556: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99557: LD_VAR 0 12
99561: PPUSH
99562: LD_VAR 0 8
99566: PPUSH
99567: LD_INT 0
99569: PPUSH
99570: CALL 101536 0 3
// end ;
99574: GO 99511
99576: POP
99577: POP
// if apemans then
99578: LD_VAR 0 3
99582: IFFALSE 99705
// for i = 1 to apemans do
99584: LD_ADDR_VAR 0 11
99588: PUSH
99589: DOUBLE
99590: LD_INT 1
99592: DEC
99593: ST_TO_ADDR
99594: LD_VAR 0 3
99598: PUSH
99599: FOR_TO
99600: IFFALSE 99703
// begin hc_class = class_apeman ;
99602: LD_ADDR_OWVAR 28
99606: PUSH
99607: LD_INT 12
99609: ST_TO_ADDR
// hc_gallery =  ;
99610: LD_ADDR_OWVAR 33
99614: PUSH
99615: LD_STRING 
99617: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
99618: LD_ADDR_OWVAR 35
99622: PUSH
99623: LD_INT 2
99625: NEG
99626: PPUSH
99627: LD_INT 2
99629: PPUSH
99630: CALL_OW 12
99634: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99635: LD_ADDR_OWVAR 31
99639: PUSH
99640: LD_INT 1
99642: PPUSH
99643: LD_INT 3
99645: PPUSH
99646: CALL_OW 12
99650: PUSH
99651: LD_INT 1
99653: PPUSH
99654: LD_INT 3
99656: PPUSH
99657: CALL_OW 12
99661: PUSH
99662: LD_INT 0
99664: PUSH
99665: LD_INT 0
99667: PUSH
99668: EMPTY
99669: LIST
99670: LIST
99671: LIST
99672: LIST
99673: ST_TO_ADDR
// animal := CreateHuman ;
99674: LD_ADDR_VAR 0 12
99678: PUSH
99679: CALL_OW 44
99683: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99684: LD_VAR 0 12
99688: PPUSH
99689: LD_VAR 0 8
99693: PPUSH
99694: LD_INT 0
99696: PPUSH
99697: CALL 101536 0 3
// end ;
99701: GO 99599
99703: POP
99704: POP
// if enchidnas then
99705: LD_VAR 0 4
99709: IFFALSE 99776
// for i = 1 to enchidnas do
99711: LD_ADDR_VAR 0 11
99715: PUSH
99716: DOUBLE
99717: LD_INT 1
99719: DEC
99720: ST_TO_ADDR
99721: LD_VAR 0 4
99725: PUSH
99726: FOR_TO
99727: IFFALSE 99774
// begin hc_class = 13 ;
99729: LD_ADDR_OWVAR 28
99733: PUSH
99734: LD_INT 13
99736: ST_TO_ADDR
// hc_gallery =  ;
99737: LD_ADDR_OWVAR 33
99741: PUSH
99742: LD_STRING 
99744: ST_TO_ADDR
// animal := CreateHuman ;
99745: LD_ADDR_VAR 0 12
99749: PUSH
99750: CALL_OW 44
99754: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99755: LD_VAR 0 12
99759: PPUSH
99760: LD_VAR 0 8
99764: PPUSH
99765: LD_INT 0
99767: PPUSH
99768: CALL 101536 0 3
// end ;
99772: GO 99726
99774: POP
99775: POP
// if fishes then
99776: LD_VAR 0 7
99780: IFFALSE 99847
// for i = 1 to fishes do
99782: LD_ADDR_VAR 0 11
99786: PUSH
99787: DOUBLE
99788: LD_INT 1
99790: DEC
99791: ST_TO_ADDR
99792: LD_VAR 0 7
99796: PUSH
99797: FOR_TO
99798: IFFALSE 99845
// begin hc_class = 20 ;
99800: LD_ADDR_OWVAR 28
99804: PUSH
99805: LD_INT 20
99807: ST_TO_ADDR
// hc_gallery =  ;
99808: LD_ADDR_OWVAR 33
99812: PUSH
99813: LD_STRING 
99815: ST_TO_ADDR
// animal := CreateHuman ;
99816: LD_ADDR_VAR 0 12
99820: PUSH
99821: CALL_OW 44
99825: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99826: LD_VAR 0 12
99830: PPUSH
99831: LD_VAR 0 9
99835: PPUSH
99836: LD_INT 0
99838: PPUSH
99839: CALL 101536 0 3
// end ;
99843: GO 99797
99845: POP
99846: POP
// end ;
99847: LD_VAR 0 10
99851: RET
// export function WantHeal ( sci , unit ) ; begin
99852: LD_INT 0
99854: PPUSH
// if GetTaskList ( sci ) > 0 then
99855: LD_VAR 0 1
99859: PPUSH
99860: CALL_OW 437
99864: PUSH
99865: LD_INT 0
99867: GREATER
99868: IFFALSE 99938
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99870: LD_VAR 0 1
99874: PPUSH
99875: CALL_OW 437
99879: PUSH
99880: LD_INT 1
99882: ARRAY
99883: PUSH
99884: LD_INT 1
99886: ARRAY
99887: PUSH
99888: LD_STRING l
99890: EQUAL
99891: PUSH
99892: LD_VAR 0 1
99896: PPUSH
99897: CALL_OW 437
99901: PUSH
99902: LD_INT 1
99904: ARRAY
99905: PUSH
99906: LD_INT 4
99908: ARRAY
99909: PUSH
99910: LD_VAR 0 2
99914: EQUAL
99915: AND
99916: IFFALSE 99928
// result := true else
99918: LD_ADDR_VAR 0 3
99922: PUSH
99923: LD_INT 1
99925: ST_TO_ADDR
99926: GO 99936
// result := false ;
99928: LD_ADDR_VAR 0 3
99932: PUSH
99933: LD_INT 0
99935: ST_TO_ADDR
// end else
99936: GO 99946
// result := false ;
99938: LD_ADDR_VAR 0 3
99942: PUSH
99943: LD_INT 0
99945: ST_TO_ADDR
// end ;
99946: LD_VAR 0 3
99950: RET
// export function HealTarget ( sci ) ; begin
99951: LD_INT 0
99953: PPUSH
// if not sci then
99954: LD_VAR 0 1
99958: NOT
99959: IFFALSE 99963
// exit ;
99961: GO 100028
// result := 0 ;
99963: LD_ADDR_VAR 0 2
99967: PUSH
99968: LD_INT 0
99970: ST_TO_ADDR
// if GetTaskList ( sci ) then
99971: LD_VAR 0 1
99975: PPUSH
99976: CALL_OW 437
99980: IFFALSE 100028
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99982: LD_VAR 0 1
99986: PPUSH
99987: CALL_OW 437
99991: PUSH
99992: LD_INT 1
99994: ARRAY
99995: PUSH
99996: LD_INT 1
99998: ARRAY
99999: PUSH
100000: LD_STRING l
100002: EQUAL
100003: IFFALSE 100028
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
100005: LD_ADDR_VAR 0 2
100009: PUSH
100010: LD_VAR 0 1
100014: PPUSH
100015: CALL_OW 437
100019: PUSH
100020: LD_INT 1
100022: ARRAY
100023: PUSH
100024: LD_INT 4
100026: ARRAY
100027: ST_TO_ADDR
// end ;
100028: LD_VAR 0 2
100032: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
100033: LD_INT 0
100035: PPUSH
100036: PPUSH
100037: PPUSH
100038: PPUSH
// if not base_units then
100039: LD_VAR 0 1
100043: NOT
100044: IFFALSE 100048
// exit ;
100046: GO 100135
// result := false ;
100048: LD_ADDR_VAR 0 2
100052: PUSH
100053: LD_INT 0
100055: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
100056: LD_ADDR_VAR 0 5
100060: PUSH
100061: LD_VAR 0 1
100065: PPUSH
100066: LD_INT 21
100068: PUSH
100069: LD_INT 3
100071: PUSH
100072: EMPTY
100073: LIST
100074: LIST
100075: PPUSH
100076: CALL_OW 72
100080: ST_TO_ADDR
// if not tmp then
100081: LD_VAR 0 5
100085: NOT
100086: IFFALSE 100090
// exit ;
100088: GO 100135
// for i in tmp do
100090: LD_ADDR_VAR 0 3
100094: PUSH
100095: LD_VAR 0 5
100099: PUSH
100100: FOR_IN
100101: IFFALSE 100133
// begin result := EnemyInRange ( i , 22 ) ;
100103: LD_ADDR_VAR 0 2
100107: PUSH
100108: LD_VAR 0 3
100112: PPUSH
100113: LD_INT 22
100115: PPUSH
100116: CALL 98371 0 2
100120: ST_TO_ADDR
// if result then
100121: LD_VAR 0 2
100125: IFFALSE 100131
// exit ;
100127: POP
100128: POP
100129: GO 100135
// end ;
100131: GO 100100
100133: POP
100134: POP
// end ;
100135: LD_VAR 0 2
100139: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
100140: LD_INT 0
100142: PPUSH
100143: PPUSH
// if not units then
100144: LD_VAR 0 1
100148: NOT
100149: IFFALSE 100153
// exit ;
100151: GO 100223
// result := [ ] ;
100153: LD_ADDR_VAR 0 3
100157: PUSH
100158: EMPTY
100159: ST_TO_ADDR
// for i in units do
100160: LD_ADDR_VAR 0 4
100164: PUSH
100165: LD_VAR 0 1
100169: PUSH
100170: FOR_IN
100171: IFFALSE 100221
// if GetTag ( i ) = tag then
100173: LD_VAR 0 4
100177: PPUSH
100178: CALL_OW 110
100182: PUSH
100183: LD_VAR 0 2
100187: EQUAL
100188: IFFALSE 100219
// result := Replace ( result , result + 1 , i ) ;
100190: LD_ADDR_VAR 0 3
100194: PUSH
100195: LD_VAR 0 3
100199: PPUSH
100200: LD_VAR 0 3
100204: PUSH
100205: LD_INT 1
100207: PLUS
100208: PPUSH
100209: LD_VAR 0 4
100213: PPUSH
100214: CALL_OW 1
100218: ST_TO_ADDR
100219: GO 100170
100221: POP
100222: POP
// end ;
100223: LD_VAR 0 3
100227: RET
// export function IsDriver ( un ) ; begin
100228: LD_INT 0
100230: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
100231: LD_ADDR_VAR 0 2
100235: PUSH
100236: LD_VAR 0 1
100240: PUSH
100241: LD_INT 55
100243: PUSH
100244: EMPTY
100245: LIST
100246: PPUSH
100247: CALL_OW 69
100251: IN
100252: ST_TO_ADDR
// end ;
100253: LD_VAR 0 2
100257: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
100258: LD_INT 0
100260: PPUSH
100261: PPUSH
// list := [ ] ;
100262: LD_ADDR_VAR 0 5
100266: PUSH
100267: EMPTY
100268: ST_TO_ADDR
// case d of 0 :
100269: LD_VAR 0 3
100273: PUSH
100274: LD_INT 0
100276: DOUBLE
100277: EQUAL
100278: IFTRUE 100282
100280: GO 100415
100282: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
100283: LD_ADDR_VAR 0 5
100287: PUSH
100288: LD_VAR 0 1
100292: PUSH
100293: LD_INT 4
100295: MINUS
100296: PUSH
100297: LD_VAR 0 2
100301: PUSH
100302: LD_INT 4
100304: MINUS
100305: PUSH
100306: LD_INT 2
100308: PUSH
100309: EMPTY
100310: LIST
100311: LIST
100312: LIST
100313: PUSH
100314: LD_VAR 0 1
100318: PUSH
100319: LD_INT 3
100321: MINUS
100322: PUSH
100323: LD_VAR 0 2
100327: PUSH
100328: LD_INT 1
100330: PUSH
100331: EMPTY
100332: LIST
100333: LIST
100334: LIST
100335: PUSH
100336: LD_VAR 0 1
100340: PUSH
100341: LD_INT 4
100343: PLUS
100344: PUSH
100345: LD_VAR 0 2
100349: PUSH
100350: LD_INT 4
100352: PUSH
100353: EMPTY
100354: LIST
100355: LIST
100356: LIST
100357: PUSH
100358: LD_VAR 0 1
100362: PUSH
100363: LD_INT 3
100365: PLUS
100366: PUSH
100367: LD_VAR 0 2
100371: PUSH
100372: LD_INT 3
100374: PLUS
100375: PUSH
100376: LD_INT 5
100378: PUSH
100379: EMPTY
100380: LIST
100381: LIST
100382: LIST
100383: PUSH
100384: LD_VAR 0 1
100388: PUSH
100389: LD_VAR 0 2
100393: PUSH
100394: LD_INT 4
100396: PLUS
100397: PUSH
100398: LD_INT 0
100400: PUSH
100401: EMPTY
100402: LIST
100403: LIST
100404: LIST
100405: PUSH
100406: EMPTY
100407: LIST
100408: LIST
100409: LIST
100410: LIST
100411: LIST
100412: ST_TO_ADDR
// end ; 1 :
100413: GO 101113
100415: LD_INT 1
100417: DOUBLE
100418: EQUAL
100419: IFTRUE 100423
100421: GO 100556
100423: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
100424: LD_ADDR_VAR 0 5
100428: PUSH
100429: LD_VAR 0 1
100433: PUSH
100434: LD_VAR 0 2
100438: PUSH
100439: LD_INT 4
100441: MINUS
100442: PUSH
100443: LD_INT 3
100445: PUSH
100446: EMPTY
100447: LIST
100448: LIST
100449: LIST
100450: PUSH
100451: LD_VAR 0 1
100455: PUSH
100456: LD_INT 3
100458: MINUS
100459: PUSH
100460: LD_VAR 0 2
100464: PUSH
100465: LD_INT 3
100467: MINUS
100468: PUSH
100469: LD_INT 2
100471: PUSH
100472: EMPTY
100473: LIST
100474: LIST
100475: LIST
100476: PUSH
100477: LD_VAR 0 1
100481: PUSH
100482: LD_INT 4
100484: MINUS
100485: PUSH
100486: LD_VAR 0 2
100490: PUSH
100491: LD_INT 1
100493: PUSH
100494: EMPTY
100495: LIST
100496: LIST
100497: LIST
100498: PUSH
100499: LD_VAR 0 1
100503: PUSH
100504: LD_VAR 0 2
100508: PUSH
100509: LD_INT 3
100511: PLUS
100512: PUSH
100513: LD_INT 0
100515: PUSH
100516: EMPTY
100517: LIST
100518: LIST
100519: LIST
100520: PUSH
100521: LD_VAR 0 1
100525: PUSH
100526: LD_INT 4
100528: PLUS
100529: PUSH
100530: LD_VAR 0 2
100534: PUSH
100535: LD_INT 4
100537: PLUS
100538: PUSH
100539: LD_INT 5
100541: PUSH
100542: EMPTY
100543: LIST
100544: LIST
100545: LIST
100546: PUSH
100547: EMPTY
100548: LIST
100549: LIST
100550: LIST
100551: LIST
100552: LIST
100553: ST_TO_ADDR
// end ; 2 :
100554: GO 101113
100556: LD_INT 2
100558: DOUBLE
100559: EQUAL
100560: IFTRUE 100564
100562: GO 100693
100564: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
100565: LD_ADDR_VAR 0 5
100569: PUSH
100570: LD_VAR 0 1
100574: PUSH
100575: LD_VAR 0 2
100579: PUSH
100580: LD_INT 3
100582: MINUS
100583: PUSH
100584: LD_INT 3
100586: PUSH
100587: EMPTY
100588: LIST
100589: LIST
100590: LIST
100591: PUSH
100592: LD_VAR 0 1
100596: PUSH
100597: LD_INT 4
100599: PLUS
100600: PUSH
100601: LD_VAR 0 2
100605: PUSH
100606: LD_INT 4
100608: PUSH
100609: EMPTY
100610: LIST
100611: LIST
100612: LIST
100613: PUSH
100614: LD_VAR 0 1
100618: PUSH
100619: LD_VAR 0 2
100623: PUSH
100624: LD_INT 4
100626: PLUS
100627: PUSH
100628: LD_INT 0
100630: PUSH
100631: EMPTY
100632: LIST
100633: LIST
100634: LIST
100635: PUSH
100636: LD_VAR 0 1
100640: PUSH
100641: LD_INT 3
100643: MINUS
100644: PUSH
100645: LD_VAR 0 2
100649: PUSH
100650: LD_INT 1
100652: PUSH
100653: EMPTY
100654: LIST
100655: LIST
100656: LIST
100657: PUSH
100658: LD_VAR 0 1
100662: PUSH
100663: LD_INT 4
100665: MINUS
100666: PUSH
100667: LD_VAR 0 2
100671: PUSH
100672: LD_INT 4
100674: MINUS
100675: PUSH
100676: LD_INT 2
100678: PUSH
100679: EMPTY
100680: LIST
100681: LIST
100682: LIST
100683: PUSH
100684: EMPTY
100685: LIST
100686: LIST
100687: LIST
100688: LIST
100689: LIST
100690: ST_TO_ADDR
// end ; 3 :
100691: GO 101113
100693: LD_INT 3
100695: DOUBLE
100696: EQUAL
100697: IFTRUE 100701
100699: GO 100834
100701: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
100702: LD_ADDR_VAR 0 5
100706: PUSH
100707: LD_VAR 0 1
100711: PUSH
100712: LD_INT 3
100714: PLUS
100715: PUSH
100716: LD_VAR 0 2
100720: PUSH
100721: LD_INT 4
100723: PUSH
100724: EMPTY
100725: LIST
100726: LIST
100727: LIST
100728: PUSH
100729: LD_VAR 0 1
100733: PUSH
100734: LD_INT 4
100736: PLUS
100737: PUSH
100738: LD_VAR 0 2
100742: PUSH
100743: LD_INT 4
100745: PLUS
100746: PUSH
100747: LD_INT 5
100749: PUSH
100750: EMPTY
100751: LIST
100752: LIST
100753: LIST
100754: PUSH
100755: LD_VAR 0 1
100759: PUSH
100760: LD_INT 4
100762: MINUS
100763: PUSH
100764: LD_VAR 0 2
100768: PUSH
100769: LD_INT 1
100771: PUSH
100772: EMPTY
100773: LIST
100774: LIST
100775: LIST
100776: PUSH
100777: LD_VAR 0 1
100781: PUSH
100782: LD_VAR 0 2
100786: PUSH
100787: LD_INT 4
100789: MINUS
100790: PUSH
100791: LD_INT 3
100793: PUSH
100794: EMPTY
100795: LIST
100796: LIST
100797: LIST
100798: PUSH
100799: LD_VAR 0 1
100803: PUSH
100804: LD_INT 3
100806: MINUS
100807: PUSH
100808: LD_VAR 0 2
100812: PUSH
100813: LD_INT 3
100815: MINUS
100816: PUSH
100817: LD_INT 2
100819: PUSH
100820: EMPTY
100821: LIST
100822: LIST
100823: LIST
100824: PUSH
100825: EMPTY
100826: LIST
100827: LIST
100828: LIST
100829: LIST
100830: LIST
100831: ST_TO_ADDR
// end ; 4 :
100832: GO 101113
100834: LD_INT 4
100836: DOUBLE
100837: EQUAL
100838: IFTRUE 100842
100840: GO 100975
100842: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
100843: LD_ADDR_VAR 0 5
100847: PUSH
100848: LD_VAR 0 1
100852: PUSH
100853: LD_VAR 0 2
100857: PUSH
100858: LD_INT 4
100860: PLUS
100861: PUSH
100862: LD_INT 0
100864: PUSH
100865: EMPTY
100866: LIST
100867: LIST
100868: LIST
100869: PUSH
100870: LD_VAR 0 1
100874: PUSH
100875: LD_INT 3
100877: PLUS
100878: PUSH
100879: LD_VAR 0 2
100883: PUSH
100884: LD_INT 3
100886: PLUS
100887: PUSH
100888: LD_INT 5
100890: PUSH
100891: EMPTY
100892: LIST
100893: LIST
100894: LIST
100895: PUSH
100896: LD_VAR 0 1
100900: PUSH
100901: LD_INT 4
100903: PLUS
100904: PUSH
100905: LD_VAR 0 2
100909: PUSH
100910: LD_INT 4
100912: PUSH
100913: EMPTY
100914: LIST
100915: LIST
100916: LIST
100917: PUSH
100918: LD_VAR 0 1
100922: PUSH
100923: LD_VAR 0 2
100927: PUSH
100928: LD_INT 3
100930: MINUS
100931: PUSH
100932: LD_INT 3
100934: PUSH
100935: EMPTY
100936: LIST
100937: LIST
100938: LIST
100939: PUSH
100940: LD_VAR 0 1
100944: PUSH
100945: LD_INT 4
100947: MINUS
100948: PUSH
100949: LD_VAR 0 2
100953: PUSH
100954: LD_INT 4
100956: MINUS
100957: PUSH
100958: LD_INT 2
100960: PUSH
100961: EMPTY
100962: LIST
100963: LIST
100964: LIST
100965: PUSH
100966: EMPTY
100967: LIST
100968: LIST
100969: LIST
100970: LIST
100971: LIST
100972: ST_TO_ADDR
// end ; 5 :
100973: GO 101113
100975: LD_INT 5
100977: DOUBLE
100978: EQUAL
100979: IFTRUE 100983
100981: GO 101112
100983: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
100984: LD_ADDR_VAR 0 5
100988: PUSH
100989: LD_VAR 0 1
100993: PUSH
100994: LD_INT 4
100996: MINUS
100997: PUSH
100998: LD_VAR 0 2
101002: PUSH
101003: LD_INT 1
101005: PUSH
101006: EMPTY
101007: LIST
101008: LIST
101009: LIST
101010: PUSH
101011: LD_VAR 0 1
101015: PUSH
101016: LD_VAR 0 2
101020: PUSH
101021: LD_INT 4
101023: MINUS
101024: PUSH
101025: LD_INT 3
101027: PUSH
101028: EMPTY
101029: LIST
101030: LIST
101031: LIST
101032: PUSH
101033: LD_VAR 0 1
101037: PUSH
101038: LD_INT 4
101040: PLUS
101041: PUSH
101042: LD_VAR 0 2
101046: PUSH
101047: LD_INT 4
101049: PLUS
101050: PUSH
101051: LD_INT 5
101053: PUSH
101054: EMPTY
101055: LIST
101056: LIST
101057: LIST
101058: PUSH
101059: LD_VAR 0 1
101063: PUSH
101064: LD_INT 3
101066: PLUS
101067: PUSH
101068: LD_VAR 0 2
101072: PUSH
101073: LD_INT 4
101075: PUSH
101076: EMPTY
101077: LIST
101078: LIST
101079: LIST
101080: PUSH
101081: LD_VAR 0 1
101085: PUSH
101086: LD_VAR 0 2
101090: PUSH
101091: LD_INT 3
101093: PLUS
101094: PUSH
101095: LD_INT 0
101097: PUSH
101098: EMPTY
101099: LIST
101100: LIST
101101: LIST
101102: PUSH
101103: EMPTY
101104: LIST
101105: LIST
101106: LIST
101107: LIST
101108: LIST
101109: ST_TO_ADDR
// end ; end ;
101110: GO 101113
101112: POP
// result := list ;
101113: LD_ADDR_VAR 0 4
101117: PUSH
101118: LD_VAR 0 5
101122: ST_TO_ADDR
// end ;
101123: LD_VAR 0 4
101127: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
101128: LD_INT 0
101130: PPUSH
101131: PPUSH
101132: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
101133: LD_VAR 0 1
101137: NOT
101138: PUSH
101139: LD_VAR 0 2
101143: PUSH
101144: LD_INT 1
101146: PUSH
101147: LD_INT 2
101149: PUSH
101150: LD_INT 3
101152: PUSH
101153: LD_INT 4
101155: PUSH
101156: EMPTY
101157: LIST
101158: LIST
101159: LIST
101160: LIST
101161: IN
101162: NOT
101163: OR
101164: IFFALSE 101168
// exit ;
101166: GO 101260
// tmp := [ ] ;
101168: LD_ADDR_VAR 0 5
101172: PUSH
101173: EMPTY
101174: ST_TO_ADDR
// for i in units do
101175: LD_ADDR_VAR 0 4
101179: PUSH
101180: LD_VAR 0 1
101184: PUSH
101185: FOR_IN
101186: IFFALSE 101229
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
101188: LD_ADDR_VAR 0 5
101192: PUSH
101193: LD_VAR 0 5
101197: PPUSH
101198: LD_VAR 0 5
101202: PUSH
101203: LD_INT 1
101205: PLUS
101206: PPUSH
101207: LD_VAR 0 4
101211: PPUSH
101212: LD_VAR 0 2
101216: PPUSH
101217: CALL_OW 259
101221: PPUSH
101222: CALL_OW 2
101226: ST_TO_ADDR
101227: GO 101185
101229: POP
101230: POP
// if not tmp then
101231: LD_VAR 0 5
101235: NOT
101236: IFFALSE 101240
// exit ;
101238: GO 101260
// result := SortListByListDesc ( units , tmp ) ;
101240: LD_ADDR_VAR 0 3
101244: PUSH
101245: LD_VAR 0 1
101249: PPUSH
101250: LD_VAR 0 5
101254: PPUSH
101255: CALL_OW 77
101259: ST_TO_ADDR
// end ;
101260: LD_VAR 0 3
101264: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
101265: LD_INT 0
101267: PPUSH
101268: PPUSH
101269: PPUSH
// result := false ;
101270: LD_ADDR_VAR 0 3
101274: PUSH
101275: LD_INT 0
101277: ST_TO_ADDR
// x := GetX ( building ) ;
101278: LD_ADDR_VAR 0 4
101282: PUSH
101283: LD_VAR 0 2
101287: PPUSH
101288: CALL_OW 250
101292: ST_TO_ADDR
// y := GetY ( building ) ;
101293: LD_ADDR_VAR 0 5
101297: PUSH
101298: LD_VAR 0 2
101302: PPUSH
101303: CALL_OW 251
101307: ST_TO_ADDR
// if not building or not x or not y then
101308: LD_VAR 0 2
101312: NOT
101313: PUSH
101314: LD_VAR 0 4
101318: NOT
101319: OR
101320: PUSH
101321: LD_VAR 0 5
101325: NOT
101326: OR
101327: IFFALSE 101331
// exit ;
101329: GO 101423
// if GetTaskList ( unit ) then
101331: LD_VAR 0 1
101335: PPUSH
101336: CALL_OW 437
101340: IFFALSE 101423
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101342: LD_STRING e
101344: PUSH
101345: LD_VAR 0 1
101349: PPUSH
101350: CALL_OW 437
101354: PUSH
101355: LD_INT 1
101357: ARRAY
101358: PUSH
101359: LD_INT 1
101361: ARRAY
101362: EQUAL
101363: PUSH
101364: LD_VAR 0 4
101368: PUSH
101369: LD_VAR 0 1
101373: PPUSH
101374: CALL_OW 437
101378: PUSH
101379: LD_INT 1
101381: ARRAY
101382: PUSH
101383: LD_INT 2
101385: ARRAY
101386: EQUAL
101387: AND
101388: PUSH
101389: LD_VAR 0 5
101393: PUSH
101394: LD_VAR 0 1
101398: PPUSH
101399: CALL_OW 437
101403: PUSH
101404: LD_INT 1
101406: ARRAY
101407: PUSH
101408: LD_INT 3
101410: ARRAY
101411: EQUAL
101412: AND
101413: IFFALSE 101423
// result := true end ;
101415: LD_ADDR_VAR 0 3
101419: PUSH
101420: LD_INT 1
101422: ST_TO_ADDR
// end ;
101423: LD_VAR 0 3
101427: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
101428: LD_INT 0
101430: PPUSH
// result := false ;
101431: LD_ADDR_VAR 0 4
101435: PUSH
101436: LD_INT 0
101438: ST_TO_ADDR
// if GetTaskList ( unit ) then
101439: LD_VAR 0 1
101443: PPUSH
101444: CALL_OW 437
101448: IFFALSE 101531
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
101450: LD_STRING M
101452: PUSH
101453: LD_VAR 0 1
101457: PPUSH
101458: CALL_OW 437
101462: PUSH
101463: LD_INT 1
101465: ARRAY
101466: PUSH
101467: LD_INT 1
101469: ARRAY
101470: EQUAL
101471: PUSH
101472: LD_VAR 0 2
101476: PUSH
101477: LD_VAR 0 1
101481: PPUSH
101482: CALL_OW 437
101486: PUSH
101487: LD_INT 1
101489: ARRAY
101490: PUSH
101491: LD_INT 2
101493: ARRAY
101494: EQUAL
101495: AND
101496: PUSH
101497: LD_VAR 0 3
101501: PUSH
101502: LD_VAR 0 1
101506: PPUSH
101507: CALL_OW 437
101511: PUSH
101512: LD_INT 1
101514: ARRAY
101515: PUSH
101516: LD_INT 3
101518: ARRAY
101519: EQUAL
101520: AND
101521: IFFALSE 101531
// result := true ;
101523: LD_ADDR_VAR 0 4
101527: PUSH
101528: LD_INT 1
101530: ST_TO_ADDR
// end ; end ;
101531: LD_VAR 0 4
101535: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
101536: LD_INT 0
101538: PPUSH
101539: PPUSH
101540: PPUSH
101541: PPUSH
// if not unit or not area then
101542: LD_VAR 0 1
101546: NOT
101547: PUSH
101548: LD_VAR 0 2
101552: NOT
101553: OR
101554: IFFALSE 101558
// exit ;
101556: GO 101722
// tmp := AreaToList ( area , i ) ;
101558: LD_ADDR_VAR 0 6
101562: PUSH
101563: LD_VAR 0 2
101567: PPUSH
101568: LD_VAR 0 5
101572: PPUSH
101573: CALL_OW 517
101577: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
101578: LD_ADDR_VAR 0 5
101582: PUSH
101583: DOUBLE
101584: LD_INT 1
101586: DEC
101587: ST_TO_ADDR
101588: LD_VAR 0 6
101592: PUSH
101593: LD_INT 1
101595: ARRAY
101596: PUSH
101597: FOR_TO
101598: IFFALSE 101720
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
101600: LD_ADDR_VAR 0 7
101604: PUSH
101605: LD_VAR 0 6
101609: PUSH
101610: LD_INT 1
101612: ARRAY
101613: PUSH
101614: LD_VAR 0 5
101618: ARRAY
101619: PUSH
101620: LD_VAR 0 6
101624: PUSH
101625: LD_INT 2
101627: ARRAY
101628: PUSH
101629: LD_VAR 0 5
101633: ARRAY
101634: PUSH
101635: EMPTY
101636: LIST
101637: LIST
101638: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
101639: LD_VAR 0 7
101643: PUSH
101644: LD_INT 1
101646: ARRAY
101647: PPUSH
101648: LD_VAR 0 7
101652: PUSH
101653: LD_INT 2
101655: ARRAY
101656: PPUSH
101657: CALL_OW 428
101661: PUSH
101662: LD_INT 0
101664: EQUAL
101665: IFFALSE 101718
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
101667: LD_VAR 0 1
101671: PPUSH
101672: LD_VAR 0 7
101676: PUSH
101677: LD_INT 1
101679: ARRAY
101680: PPUSH
101681: LD_VAR 0 7
101685: PUSH
101686: LD_INT 2
101688: ARRAY
101689: PPUSH
101690: LD_VAR 0 3
101694: PPUSH
101695: CALL_OW 48
// result := IsPlaced ( unit ) ;
101699: LD_ADDR_VAR 0 4
101703: PUSH
101704: LD_VAR 0 1
101708: PPUSH
101709: CALL_OW 305
101713: ST_TO_ADDR
// exit ;
101714: POP
101715: POP
101716: GO 101722
// end ; end ;
101718: GO 101597
101720: POP
101721: POP
// end ;
101722: LD_VAR 0 4
101726: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
101727: LD_INT 0
101729: PPUSH
101730: PPUSH
101731: PPUSH
// if not side or side > 8 then
101732: LD_VAR 0 1
101736: NOT
101737: PUSH
101738: LD_VAR 0 1
101742: PUSH
101743: LD_INT 8
101745: GREATER
101746: OR
101747: IFFALSE 101751
// exit ;
101749: GO 101938
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
101751: LD_ADDR_VAR 0 4
101755: PUSH
101756: LD_INT 22
101758: PUSH
101759: LD_VAR 0 1
101763: PUSH
101764: EMPTY
101765: LIST
101766: LIST
101767: PUSH
101768: LD_INT 21
101770: PUSH
101771: LD_INT 3
101773: PUSH
101774: EMPTY
101775: LIST
101776: LIST
101777: PUSH
101778: EMPTY
101779: LIST
101780: LIST
101781: PPUSH
101782: CALL_OW 69
101786: ST_TO_ADDR
// if not tmp then
101787: LD_VAR 0 4
101791: NOT
101792: IFFALSE 101796
// exit ;
101794: GO 101938
// enable_addtolog := true ;
101796: LD_ADDR_OWVAR 81
101800: PUSH
101801: LD_INT 1
101803: ST_TO_ADDR
// AddToLog ( [ ) ;
101804: LD_STRING [
101806: PPUSH
101807: CALL_OW 561
// for i in tmp do
101811: LD_ADDR_VAR 0 3
101815: PUSH
101816: LD_VAR 0 4
101820: PUSH
101821: FOR_IN
101822: IFFALSE 101929
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
101824: LD_STRING [
101826: PUSH
101827: LD_VAR 0 3
101831: PPUSH
101832: CALL_OW 266
101836: STR
101837: PUSH
101838: LD_STRING , 
101840: STR
101841: PUSH
101842: LD_VAR 0 3
101846: PPUSH
101847: CALL_OW 250
101851: STR
101852: PUSH
101853: LD_STRING , 
101855: STR
101856: PUSH
101857: LD_VAR 0 3
101861: PPUSH
101862: CALL_OW 251
101866: STR
101867: PUSH
101868: LD_STRING , 
101870: STR
101871: PUSH
101872: LD_VAR 0 3
101876: PPUSH
101877: CALL_OW 254
101881: STR
101882: PUSH
101883: LD_STRING , 
101885: STR
101886: PUSH
101887: LD_VAR 0 3
101891: PPUSH
101892: LD_INT 1
101894: PPUSH
101895: CALL_OW 268
101899: STR
101900: PUSH
101901: LD_STRING , 
101903: STR
101904: PUSH
101905: LD_VAR 0 3
101909: PPUSH
101910: LD_INT 2
101912: PPUSH
101913: CALL_OW 268
101917: STR
101918: PUSH
101919: LD_STRING ],
101921: STR
101922: PPUSH
101923: CALL_OW 561
// end ;
101927: GO 101821
101929: POP
101930: POP
// AddToLog ( ]; ) ;
101931: LD_STRING ];
101933: PPUSH
101934: CALL_OW 561
// end ;
101938: LD_VAR 0 2
101942: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
101943: LD_INT 0
101945: PPUSH
101946: PPUSH
101947: PPUSH
101948: PPUSH
101949: PPUSH
// if not area or not rate or not max then
101950: LD_VAR 0 1
101954: NOT
101955: PUSH
101956: LD_VAR 0 2
101960: NOT
101961: OR
101962: PUSH
101963: LD_VAR 0 4
101967: NOT
101968: OR
101969: IFFALSE 101973
// exit ;
101971: GO 102165
// while 1 do
101973: LD_INT 1
101975: IFFALSE 102165
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
101977: LD_ADDR_VAR 0 9
101981: PUSH
101982: LD_VAR 0 1
101986: PPUSH
101987: LD_INT 1
101989: PPUSH
101990: CALL_OW 287
101994: PUSH
101995: LD_INT 10
101997: MUL
101998: ST_TO_ADDR
// r := rate / 10 ;
101999: LD_ADDR_VAR 0 7
102003: PUSH
102004: LD_VAR 0 2
102008: PUSH
102009: LD_INT 10
102011: DIVREAL
102012: ST_TO_ADDR
// time := 1 1$00 ;
102013: LD_ADDR_VAR 0 8
102017: PUSH
102018: LD_INT 2100
102020: ST_TO_ADDR
// if amount < min then
102021: LD_VAR 0 9
102025: PUSH
102026: LD_VAR 0 3
102030: LESS
102031: IFFALSE 102049
// r := r * 2 else
102033: LD_ADDR_VAR 0 7
102037: PUSH
102038: LD_VAR 0 7
102042: PUSH
102043: LD_INT 2
102045: MUL
102046: ST_TO_ADDR
102047: GO 102075
// if amount > max then
102049: LD_VAR 0 9
102053: PUSH
102054: LD_VAR 0 4
102058: GREATER
102059: IFFALSE 102075
// r := r / 2 ;
102061: LD_ADDR_VAR 0 7
102065: PUSH
102066: LD_VAR 0 7
102070: PUSH
102071: LD_INT 2
102073: DIVREAL
102074: ST_TO_ADDR
// time := time / r ;
102075: LD_ADDR_VAR 0 8
102079: PUSH
102080: LD_VAR 0 8
102084: PUSH
102085: LD_VAR 0 7
102089: DIVREAL
102090: ST_TO_ADDR
// if time < 0 then
102091: LD_VAR 0 8
102095: PUSH
102096: LD_INT 0
102098: LESS
102099: IFFALSE 102116
// time := time * - 1 ;
102101: LD_ADDR_VAR 0 8
102105: PUSH
102106: LD_VAR 0 8
102110: PUSH
102111: LD_INT 1
102113: NEG
102114: MUL
102115: ST_TO_ADDR
// wait ( time ) ;
102116: LD_VAR 0 8
102120: PPUSH
102121: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
102125: LD_INT 35
102127: PPUSH
102128: LD_INT 875
102130: PPUSH
102131: CALL_OW 12
102135: PPUSH
102136: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
102140: LD_INT 1
102142: PPUSH
102143: LD_INT 5
102145: PPUSH
102146: CALL_OW 12
102150: PPUSH
102151: LD_VAR 0 1
102155: PPUSH
102156: LD_INT 1
102158: PPUSH
102159: CALL_OW 55
// end ;
102163: GO 101973
// end ;
102165: LD_VAR 0 5
102169: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
102170: LD_INT 0
102172: PPUSH
102173: PPUSH
102174: PPUSH
102175: PPUSH
102176: PPUSH
102177: PPUSH
102178: PPUSH
102179: PPUSH
// if not turrets or not factories then
102180: LD_VAR 0 1
102184: NOT
102185: PUSH
102186: LD_VAR 0 2
102190: NOT
102191: OR
102192: IFFALSE 102196
// exit ;
102194: GO 102503
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
102196: LD_ADDR_VAR 0 10
102200: PUSH
102201: LD_INT 5
102203: PUSH
102204: LD_INT 6
102206: PUSH
102207: EMPTY
102208: LIST
102209: LIST
102210: PUSH
102211: LD_INT 2
102213: PUSH
102214: LD_INT 4
102216: PUSH
102217: EMPTY
102218: LIST
102219: LIST
102220: PUSH
102221: LD_INT 3
102223: PUSH
102224: LD_INT 5
102226: PUSH
102227: EMPTY
102228: LIST
102229: LIST
102230: PUSH
102231: EMPTY
102232: LIST
102233: LIST
102234: LIST
102235: PUSH
102236: LD_INT 24
102238: PUSH
102239: LD_INT 25
102241: PUSH
102242: EMPTY
102243: LIST
102244: LIST
102245: PUSH
102246: LD_INT 23
102248: PUSH
102249: LD_INT 27
102251: PUSH
102252: EMPTY
102253: LIST
102254: LIST
102255: PUSH
102256: EMPTY
102257: LIST
102258: LIST
102259: PUSH
102260: LD_INT 42
102262: PUSH
102263: LD_INT 43
102265: PUSH
102266: EMPTY
102267: LIST
102268: LIST
102269: PUSH
102270: LD_INT 44
102272: PUSH
102273: LD_INT 46
102275: PUSH
102276: EMPTY
102277: LIST
102278: LIST
102279: PUSH
102280: LD_INT 45
102282: PUSH
102283: LD_INT 47
102285: PUSH
102286: EMPTY
102287: LIST
102288: LIST
102289: PUSH
102290: EMPTY
102291: LIST
102292: LIST
102293: LIST
102294: PUSH
102295: EMPTY
102296: LIST
102297: LIST
102298: LIST
102299: ST_TO_ADDR
// result := [ ] ;
102300: LD_ADDR_VAR 0 3
102304: PUSH
102305: EMPTY
102306: ST_TO_ADDR
// for i in turrets do
102307: LD_ADDR_VAR 0 4
102311: PUSH
102312: LD_VAR 0 1
102316: PUSH
102317: FOR_IN
102318: IFFALSE 102501
// begin nat := GetNation ( i ) ;
102320: LD_ADDR_VAR 0 7
102324: PUSH
102325: LD_VAR 0 4
102329: PPUSH
102330: CALL_OW 248
102334: ST_TO_ADDR
// weapon := 0 ;
102335: LD_ADDR_VAR 0 8
102339: PUSH
102340: LD_INT 0
102342: ST_TO_ADDR
// if not nat then
102343: LD_VAR 0 7
102347: NOT
102348: IFFALSE 102352
// continue ;
102350: GO 102317
// for j in list [ nat ] do
102352: LD_ADDR_VAR 0 5
102356: PUSH
102357: LD_VAR 0 10
102361: PUSH
102362: LD_VAR 0 7
102366: ARRAY
102367: PUSH
102368: FOR_IN
102369: IFFALSE 102410
// if GetBWeapon ( i ) = j [ 1 ] then
102371: LD_VAR 0 4
102375: PPUSH
102376: CALL_OW 269
102380: PUSH
102381: LD_VAR 0 5
102385: PUSH
102386: LD_INT 1
102388: ARRAY
102389: EQUAL
102390: IFFALSE 102408
// begin weapon := j [ 2 ] ;
102392: LD_ADDR_VAR 0 8
102396: PUSH
102397: LD_VAR 0 5
102401: PUSH
102402: LD_INT 2
102404: ARRAY
102405: ST_TO_ADDR
// break ;
102406: GO 102410
// end ;
102408: GO 102368
102410: POP
102411: POP
// if not weapon then
102412: LD_VAR 0 8
102416: NOT
102417: IFFALSE 102421
// continue ;
102419: GO 102317
// for k in factories do
102421: LD_ADDR_VAR 0 6
102425: PUSH
102426: LD_VAR 0 2
102430: PUSH
102431: FOR_IN
102432: IFFALSE 102497
// begin weapons := AvailableWeaponList ( k ) ;
102434: LD_ADDR_VAR 0 9
102438: PUSH
102439: LD_VAR 0 6
102443: PPUSH
102444: CALL_OW 478
102448: ST_TO_ADDR
// if not weapons then
102449: LD_VAR 0 9
102453: NOT
102454: IFFALSE 102458
// continue ;
102456: GO 102431
// if weapon in weapons then
102458: LD_VAR 0 8
102462: PUSH
102463: LD_VAR 0 9
102467: IN
102468: IFFALSE 102495
// begin result := [ i , weapon ] ;
102470: LD_ADDR_VAR 0 3
102474: PUSH
102475: LD_VAR 0 4
102479: PUSH
102480: LD_VAR 0 8
102484: PUSH
102485: EMPTY
102486: LIST
102487: LIST
102488: ST_TO_ADDR
// exit ;
102489: POP
102490: POP
102491: POP
102492: POP
102493: GO 102503
// end ; end ;
102495: GO 102431
102497: POP
102498: POP
// end ;
102499: GO 102317
102501: POP
102502: POP
// end ;
102503: LD_VAR 0 3
102507: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
102508: LD_INT 0
102510: PPUSH
// if not side or side > 8 then
102511: LD_VAR 0 3
102515: NOT
102516: PUSH
102517: LD_VAR 0 3
102521: PUSH
102522: LD_INT 8
102524: GREATER
102525: OR
102526: IFFALSE 102530
// exit ;
102528: GO 102589
// if not range then
102530: LD_VAR 0 4
102534: NOT
102535: IFFALSE 102546
// range := - 12 ;
102537: LD_ADDR_VAR 0 4
102541: PUSH
102542: LD_INT 12
102544: NEG
102545: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
102546: LD_VAR 0 1
102550: PPUSH
102551: LD_VAR 0 2
102555: PPUSH
102556: LD_VAR 0 3
102560: PPUSH
102561: LD_VAR 0 4
102565: PPUSH
102566: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
102570: LD_VAR 0 1
102574: PPUSH
102575: LD_VAR 0 2
102579: PPUSH
102580: LD_VAR 0 3
102584: PPUSH
102585: CALL_OW 331
// end ;
102589: LD_VAR 0 5
102593: RET
// export function Video ( mode ) ; begin
102594: LD_INT 0
102596: PPUSH
// ingame_video = mode ;
102597: LD_ADDR_OWVAR 52
102601: PUSH
102602: LD_VAR 0 1
102606: ST_TO_ADDR
// interface_hidden = mode ;
102607: LD_ADDR_OWVAR 54
102611: PUSH
102612: LD_VAR 0 1
102616: ST_TO_ADDR
// end ;
102617: LD_VAR 0 2
102621: RET
// export function Join ( array , element ) ; begin
102622: LD_INT 0
102624: PPUSH
// result := Replace ( array , array + 1 , element ) ;
102625: LD_ADDR_VAR 0 3
102629: PUSH
102630: LD_VAR 0 1
102634: PPUSH
102635: LD_VAR 0 1
102639: PUSH
102640: LD_INT 1
102642: PLUS
102643: PPUSH
102644: LD_VAR 0 2
102648: PPUSH
102649: CALL_OW 1
102653: ST_TO_ADDR
// end ;
102654: LD_VAR 0 3
102658: RET
// export function JoinUnion ( array , element ) ; begin
102659: LD_INT 0
102661: PPUSH
// result := array union element ;
102662: LD_ADDR_VAR 0 3
102666: PUSH
102667: LD_VAR 0 1
102671: PUSH
102672: LD_VAR 0 2
102676: UNION
102677: ST_TO_ADDR
// end ;
102678: LD_VAR 0 3
102682: RET
// export function GetBehemoths ( side ) ; begin
102683: LD_INT 0
102685: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
102686: LD_ADDR_VAR 0 2
102690: PUSH
102691: LD_INT 22
102693: PUSH
102694: LD_VAR 0 1
102698: PUSH
102699: EMPTY
102700: LIST
102701: LIST
102702: PUSH
102703: LD_INT 31
102705: PUSH
102706: LD_INT 25
102708: PUSH
102709: EMPTY
102710: LIST
102711: LIST
102712: PUSH
102713: EMPTY
102714: LIST
102715: LIST
102716: PPUSH
102717: CALL_OW 69
102721: ST_TO_ADDR
// end ;
102722: LD_VAR 0 2
102726: RET
// export function Shuffle ( array ) ; var i , index ; begin
102727: LD_INT 0
102729: PPUSH
102730: PPUSH
102731: PPUSH
// result := [ ] ;
102732: LD_ADDR_VAR 0 2
102736: PUSH
102737: EMPTY
102738: ST_TO_ADDR
// if not array then
102739: LD_VAR 0 1
102743: NOT
102744: IFFALSE 102748
// exit ;
102746: GO 102847
// Randomize ;
102748: CALL_OW 10
// for i = array downto 1 do
102752: LD_ADDR_VAR 0 3
102756: PUSH
102757: DOUBLE
102758: LD_VAR 0 1
102762: INC
102763: ST_TO_ADDR
102764: LD_INT 1
102766: PUSH
102767: FOR_DOWNTO
102768: IFFALSE 102845
// begin index := rand ( 1 , array ) ;
102770: LD_ADDR_VAR 0 4
102774: PUSH
102775: LD_INT 1
102777: PPUSH
102778: LD_VAR 0 1
102782: PPUSH
102783: CALL_OW 12
102787: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
102788: LD_ADDR_VAR 0 2
102792: PUSH
102793: LD_VAR 0 2
102797: PPUSH
102798: LD_VAR 0 2
102802: PUSH
102803: LD_INT 1
102805: PLUS
102806: PPUSH
102807: LD_VAR 0 1
102811: PUSH
102812: LD_VAR 0 4
102816: ARRAY
102817: PPUSH
102818: CALL_OW 2
102822: ST_TO_ADDR
// array := Delete ( array , index ) ;
102823: LD_ADDR_VAR 0 1
102827: PUSH
102828: LD_VAR 0 1
102832: PPUSH
102833: LD_VAR 0 4
102837: PPUSH
102838: CALL_OW 3
102842: ST_TO_ADDR
// end ;
102843: GO 102767
102845: POP
102846: POP
// end ;
102847: LD_VAR 0 2
102851: RET
// export function GetBaseMaterials ( base ) ; begin
102852: LD_INT 0
102854: PPUSH
// result := [ 0 , 0 , 0 ] ;
102855: LD_ADDR_VAR 0 2
102859: PUSH
102860: LD_INT 0
102862: PUSH
102863: LD_INT 0
102865: PUSH
102866: LD_INT 0
102868: PUSH
102869: EMPTY
102870: LIST
102871: LIST
102872: LIST
102873: ST_TO_ADDR
// if not base then
102874: LD_VAR 0 1
102878: NOT
102879: IFFALSE 102883
// exit ;
102881: GO 102932
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
102883: LD_ADDR_VAR 0 2
102887: PUSH
102888: LD_VAR 0 1
102892: PPUSH
102893: LD_INT 1
102895: PPUSH
102896: CALL_OW 275
102900: PUSH
102901: LD_VAR 0 1
102905: PPUSH
102906: LD_INT 2
102908: PPUSH
102909: CALL_OW 275
102913: PUSH
102914: LD_VAR 0 1
102918: PPUSH
102919: LD_INT 3
102921: PPUSH
102922: CALL_OW 275
102926: PUSH
102927: EMPTY
102928: LIST
102929: LIST
102930: LIST
102931: ST_TO_ADDR
// end ;
102932: LD_VAR 0 2
102936: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
102937: LD_INT 0
102939: PPUSH
102940: PPUSH
// result := array ;
102941: LD_ADDR_VAR 0 3
102945: PUSH
102946: LD_VAR 0 1
102950: ST_TO_ADDR
// if size > 0 then
102951: LD_VAR 0 2
102955: PUSH
102956: LD_INT 0
102958: GREATER
102959: IFFALSE 103005
// for i := array downto size do
102961: LD_ADDR_VAR 0 4
102965: PUSH
102966: DOUBLE
102967: LD_VAR 0 1
102971: INC
102972: ST_TO_ADDR
102973: LD_VAR 0 2
102977: PUSH
102978: FOR_DOWNTO
102979: IFFALSE 103003
// result := Delete ( result , result ) ;
102981: LD_ADDR_VAR 0 3
102985: PUSH
102986: LD_VAR 0 3
102990: PPUSH
102991: LD_VAR 0 3
102995: PPUSH
102996: CALL_OW 3
103000: ST_TO_ADDR
103001: GO 102978
103003: POP
103004: POP
// end ;
103005: LD_VAR 0 3
103009: RET
// export function ComExit ( unit ) ; var tmp ; begin
103010: LD_INT 0
103012: PPUSH
103013: PPUSH
// if not IsInUnit ( unit ) then
103014: LD_VAR 0 1
103018: PPUSH
103019: CALL_OW 310
103023: NOT
103024: IFFALSE 103028
// exit ;
103026: GO 103088
// tmp := IsInUnit ( unit ) ;
103028: LD_ADDR_VAR 0 3
103032: PUSH
103033: LD_VAR 0 1
103037: PPUSH
103038: CALL_OW 310
103042: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
103043: LD_VAR 0 3
103047: PPUSH
103048: CALL_OW 247
103052: PUSH
103053: LD_INT 2
103055: EQUAL
103056: IFFALSE 103069
// ComExitVehicle ( unit ) else
103058: LD_VAR 0 1
103062: PPUSH
103063: CALL_OW 121
103067: GO 103078
// ComExitBuilding ( unit ) ;
103069: LD_VAR 0 1
103073: PPUSH
103074: CALL_OW 122
// result := tmp ;
103078: LD_ADDR_VAR 0 2
103082: PUSH
103083: LD_VAR 0 3
103087: ST_TO_ADDR
// end ;
103088: LD_VAR 0 2
103092: RET
// export function ComExitAll ( units ) ; var i ; begin
103093: LD_INT 0
103095: PPUSH
103096: PPUSH
// if not units then
103097: LD_VAR 0 1
103101: NOT
103102: IFFALSE 103106
// exit ;
103104: GO 103132
// for i in units do
103106: LD_ADDR_VAR 0 3
103110: PUSH
103111: LD_VAR 0 1
103115: PUSH
103116: FOR_IN
103117: IFFALSE 103130
// ComExit ( i ) ;
103119: LD_VAR 0 3
103123: PPUSH
103124: CALL 103010 0 1
103128: GO 103116
103130: POP
103131: POP
// end ;
103132: LD_VAR 0 2
103136: RET
// export function ResetHc ; begin
103137: LD_INT 0
103139: PPUSH
// InitHc ;
103140: CALL_OW 19
// hc_importance := 0 ;
103144: LD_ADDR_OWVAR 32
103148: PUSH
103149: LD_INT 0
103151: ST_TO_ADDR
// end ;
103152: LD_VAR 0 1
103156: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
103157: LD_INT 0
103159: PPUSH
103160: PPUSH
103161: PPUSH
// _x := ( x1 + x2 ) div 2 ;
103162: LD_ADDR_VAR 0 6
103166: PUSH
103167: LD_VAR 0 1
103171: PUSH
103172: LD_VAR 0 3
103176: PLUS
103177: PUSH
103178: LD_INT 2
103180: DIV
103181: ST_TO_ADDR
// if _x < 0 then
103182: LD_VAR 0 6
103186: PUSH
103187: LD_INT 0
103189: LESS
103190: IFFALSE 103207
// _x := _x * - 1 ;
103192: LD_ADDR_VAR 0 6
103196: PUSH
103197: LD_VAR 0 6
103201: PUSH
103202: LD_INT 1
103204: NEG
103205: MUL
103206: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
103207: LD_ADDR_VAR 0 7
103211: PUSH
103212: LD_VAR 0 2
103216: PUSH
103217: LD_VAR 0 4
103221: PLUS
103222: PUSH
103223: LD_INT 2
103225: DIV
103226: ST_TO_ADDR
// if _y < 0 then
103227: LD_VAR 0 7
103231: PUSH
103232: LD_INT 0
103234: LESS
103235: IFFALSE 103252
// _y := _y * - 1 ;
103237: LD_ADDR_VAR 0 7
103241: PUSH
103242: LD_VAR 0 7
103246: PUSH
103247: LD_INT 1
103249: NEG
103250: MUL
103251: ST_TO_ADDR
// result := [ _x , _y ] ;
103252: LD_ADDR_VAR 0 5
103256: PUSH
103257: LD_VAR 0 6
103261: PUSH
103262: LD_VAR 0 7
103266: PUSH
103267: EMPTY
103268: LIST
103269: LIST
103270: ST_TO_ADDR
// end ;
103271: LD_VAR 0 5
103275: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
103276: LD_INT 0
103278: PPUSH
103279: PPUSH
103280: PPUSH
103281: PPUSH
// task := GetTaskList ( unit ) ;
103282: LD_ADDR_VAR 0 7
103286: PUSH
103287: LD_VAR 0 1
103291: PPUSH
103292: CALL_OW 437
103296: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
103297: LD_VAR 0 7
103301: NOT
103302: PUSH
103303: LD_VAR 0 1
103307: PPUSH
103308: LD_VAR 0 2
103312: PPUSH
103313: CALL_OW 308
103317: NOT
103318: AND
103319: IFFALSE 103323
// exit ;
103321: GO 103441
// if IsInArea ( unit , area ) then
103323: LD_VAR 0 1
103327: PPUSH
103328: LD_VAR 0 2
103332: PPUSH
103333: CALL_OW 308
103337: IFFALSE 103355
// begin ComMoveToArea ( unit , goAway ) ;
103339: LD_VAR 0 1
103343: PPUSH
103344: LD_VAR 0 3
103348: PPUSH
103349: CALL_OW 113
// exit ;
103353: GO 103441
// end ; if task [ 1 ] [ 1 ] <> M then
103355: LD_VAR 0 7
103359: PUSH
103360: LD_INT 1
103362: ARRAY
103363: PUSH
103364: LD_INT 1
103366: ARRAY
103367: PUSH
103368: LD_STRING M
103370: NONEQUAL
103371: IFFALSE 103375
// exit ;
103373: GO 103441
// x := task [ 1 ] [ 2 ] ;
103375: LD_ADDR_VAR 0 5
103379: PUSH
103380: LD_VAR 0 7
103384: PUSH
103385: LD_INT 1
103387: ARRAY
103388: PUSH
103389: LD_INT 2
103391: ARRAY
103392: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
103393: LD_ADDR_VAR 0 6
103397: PUSH
103398: LD_VAR 0 7
103402: PUSH
103403: LD_INT 1
103405: ARRAY
103406: PUSH
103407: LD_INT 3
103409: ARRAY
103410: ST_TO_ADDR
// if InArea ( x , y , area ) then
103411: LD_VAR 0 5
103415: PPUSH
103416: LD_VAR 0 6
103420: PPUSH
103421: LD_VAR 0 2
103425: PPUSH
103426: CALL_OW 309
103430: IFFALSE 103441
// ComStop ( unit ) ;
103432: LD_VAR 0 1
103436: PPUSH
103437: CALL_OW 141
// end ;
103441: LD_VAR 0 4
103445: RET
// export function Abs ( value ) ; begin
103446: LD_INT 0
103448: PPUSH
// result := value ;
103449: LD_ADDR_VAR 0 2
103453: PUSH
103454: LD_VAR 0 1
103458: ST_TO_ADDR
// if value < 0 then
103459: LD_VAR 0 1
103463: PUSH
103464: LD_INT 0
103466: LESS
103467: IFFALSE 103484
// result := value * - 1 ;
103469: LD_ADDR_VAR 0 2
103473: PUSH
103474: LD_VAR 0 1
103478: PUSH
103479: LD_INT 1
103481: NEG
103482: MUL
103483: ST_TO_ADDR
// end ;
103484: LD_VAR 0 2
103488: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
103489: LD_INT 0
103491: PPUSH
103492: PPUSH
103493: PPUSH
103494: PPUSH
103495: PPUSH
103496: PPUSH
103497: PPUSH
103498: PPUSH
// if not unit or not building then
103499: LD_VAR 0 1
103503: NOT
103504: PUSH
103505: LD_VAR 0 2
103509: NOT
103510: OR
103511: IFFALSE 103515
// exit ;
103513: GO 103741
// x := GetX ( building ) ;
103515: LD_ADDR_VAR 0 4
103519: PUSH
103520: LD_VAR 0 2
103524: PPUSH
103525: CALL_OW 250
103529: ST_TO_ADDR
// y := GetY ( building ) ;
103530: LD_ADDR_VAR 0 6
103534: PUSH
103535: LD_VAR 0 2
103539: PPUSH
103540: CALL_OW 251
103544: ST_TO_ADDR
// d := GetDir ( building ) ;
103545: LD_ADDR_VAR 0 8
103549: PUSH
103550: LD_VAR 0 2
103554: PPUSH
103555: CALL_OW 254
103559: ST_TO_ADDR
// r := 4 ;
103560: LD_ADDR_VAR 0 9
103564: PUSH
103565: LD_INT 4
103567: ST_TO_ADDR
// for i := 1 to 5 do
103568: LD_ADDR_VAR 0 10
103572: PUSH
103573: DOUBLE
103574: LD_INT 1
103576: DEC
103577: ST_TO_ADDR
103578: LD_INT 5
103580: PUSH
103581: FOR_TO
103582: IFFALSE 103739
// begin _x := ShiftX ( x , d , r + i ) ;
103584: LD_ADDR_VAR 0 5
103588: PUSH
103589: LD_VAR 0 4
103593: PPUSH
103594: LD_VAR 0 8
103598: PPUSH
103599: LD_VAR 0 9
103603: PUSH
103604: LD_VAR 0 10
103608: PLUS
103609: PPUSH
103610: CALL_OW 272
103614: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
103615: LD_ADDR_VAR 0 7
103619: PUSH
103620: LD_VAR 0 6
103624: PPUSH
103625: LD_VAR 0 8
103629: PPUSH
103630: LD_VAR 0 9
103634: PUSH
103635: LD_VAR 0 10
103639: PLUS
103640: PPUSH
103641: CALL_OW 273
103645: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
103646: LD_VAR 0 5
103650: PPUSH
103651: LD_VAR 0 7
103655: PPUSH
103656: CALL_OW 488
103660: PUSH
103661: LD_VAR 0 5
103665: PPUSH
103666: LD_VAR 0 7
103670: PPUSH
103671: CALL_OW 428
103675: PPUSH
103676: CALL_OW 247
103680: PUSH
103681: LD_INT 3
103683: PUSH
103684: LD_INT 2
103686: PUSH
103687: EMPTY
103688: LIST
103689: LIST
103690: IN
103691: NOT
103692: AND
103693: IFFALSE 103737
// begin ComMoveXY ( unit , _x , _y ) ;
103695: LD_VAR 0 1
103699: PPUSH
103700: LD_VAR 0 5
103704: PPUSH
103705: LD_VAR 0 7
103709: PPUSH
103710: CALL_OW 111
// result := [ _x , _y ] ;
103714: LD_ADDR_VAR 0 3
103718: PUSH
103719: LD_VAR 0 5
103723: PUSH
103724: LD_VAR 0 7
103728: PUSH
103729: EMPTY
103730: LIST
103731: LIST
103732: ST_TO_ADDR
// exit ;
103733: POP
103734: POP
103735: GO 103741
// end ; end ;
103737: GO 103581
103739: POP
103740: POP
// end ;
103741: LD_VAR 0 3
103745: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
103746: LD_INT 0
103748: PPUSH
103749: PPUSH
103750: PPUSH
// result := 0 ;
103751: LD_ADDR_VAR 0 3
103755: PUSH
103756: LD_INT 0
103758: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
103759: LD_VAR 0 1
103763: PUSH
103764: LD_INT 0
103766: LESS
103767: PUSH
103768: LD_VAR 0 1
103772: PUSH
103773: LD_INT 8
103775: GREATER
103776: OR
103777: PUSH
103778: LD_VAR 0 2
103782: PUSH
103783: LD_INT 0
103785: LESS
103786: OR
103787: PUSH
103788: LD_VAR 0 2
103792: PUSH
103793: LD_INT 8
103795: GREATER
103796: OR
103797: IFFALSE 103801
// exit ;
103799: GO 103876
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
103801: LD_ADDR_VAR 0 4
103805: PUSH
103806: LD_INT 22
103808: PUSH
103809: LD_VAR 0 2
103813: PUSH
103814: EMPTY
103815: LIST
103816: LIST
103817: PPUSH
103818: CALL_OW 69
103822: PUSH
103823: FOR_IN
103824: IFFALSE 103874
// begin un := UnitShoot ( i ) ;
103826: LD_ADDR_VAR 0 5
103830: PUSH
103831: LD_VAR 0 4
103835: PPUSH
103836: CALL_OW 504
103840: ST_TO_ADDR
// if GetSide ( un ) = side1 then
103841: LD_VAR 0 5
103845: PPUSH
103846: CALL_OW 255
103850: PUSH
103851: LD_VAR 0 1
103855: EQUAL
103856: IFFALSE 103872
// begin result := un ;
103858: LD_ADDR_VAR 0 3
103862: PUSH
103863: LD_VAR 0 5
103867: ST_TO_ADDR
// exit ;
103868: POP
103869: POP
103870: GO 103876
// end ; end ;
103872: GO 103823
103874: POP
103875: POP
// end ;
103876: LD_VAR 0 3
103880: RET
// export function GetCargoBay ( units ) ; begin
103881: LD_INT 0
103883: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
103884: LD_ADDR_VAR 0 2
103888: PUSH
103889: LD_VAR 0 1
103893: PPUSH
103894: LD_INT 2
103896: PUSH
103897: LD_INT 34
103899: PUSH
103900: LD_INT 12
103902: PUSH
103903: EMPTY
103904: LIST
103905: LIST
103906: PUSH
103907: LD_INT 34
103909: PUSH
103910: LD_INT 51
103912: PUSH
103913: EMPTY
103914: LIST
103915: LIST
103916: PUSH
103917: LD_INT 34
103919: PUSH
103920: LD_INT 32
103922: PUSH
103923: EMPTY
103924: LIST
103925: LIST
103926: PUSH
103927: LD_INT 34
103929: PUSH
103930: LD_EXP 96
103934: PUSH
103935: EMPTY
103936: LIST
103937: LIST
103938: PUSH
103939: EMPTY
103940: LIST
103941: LIST
103942: LIST
103943: LIST
103944: LIST
103945: PPUSH
103946: CALL_OW 72
103950: ST_TO_ADDR
// end ;
103951: LD_VAR 0 2
103955: RET
// export function Negate ( value ) ; begin
103956: LD_INT 0
103958: PPUSH
// result := not value ;
103959: LD_ADDR_VAR 0 2
103963: PUSH
103964: LD_VAR 0 1
103968: NOT
103969: ST_TO_ADDR
// end ;
103970: LD_VAR 0 2
103974: RET
// export function Inc ( value ) ; begin
103975: LD_INT 0
103977: PPUSH
// result := value + 1 ;
103978: LD_ADDR_VAR 0 2
103982: PUSH
103983: LD_VAR 0 1
103987: PUSH
103988: LD_INT 1
103990: PLUS
103991: ST_TO_ADDR
// end ;
103992: LD_VAR 0 2
103996: RET
// export function Dec ( value ) ; begin
103997: LD_INT 0
103999: PPUSH
// result := value - 1 ;
104000: LD_ADDR_VAR 0 2
104004: PUSH
104005: LD_VAR 0 1
104009: PUSH
104010: LD_INT 1
104012: MINUS
104013: ST_TO_ADDR
// end ;
104014: LD_VAR 0 2
104018: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
104019: LD_INT 0
104021: PPUSH
104022: PPUSH
104023: PPUSH
104024: PPUSH
104025: PPUSH
104026: PPUSH
104027: PPUSH
104028: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
104029: LD_VAR 0 1
104033: PPUSH
104034: LD_VAR 0 2
104038: PPUSH
104039: CALL_OW 488
104043: NOT
104044: PUSH
104045: LD_VAR 0 3
104049: PPUSH
104050: LD_VAR 0 4
104054: PPUSH
104055: CALL_OW 488
104059: NOT
104060: OR
104061: IFFALSE 104074
// begin result := - 1 ;
104063: LD_ADDR_VAR 0 5
104067: PUSH
104068: LD_INT 1
104070: NEG
104071: ST_TO_ADDR
// exit ;
104072: GO 104309
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
104074: LD_ADDR_VAR 0 12
104078: PUSH
104079: LD_VAR 0 1
104083: PPUSH
104084: LD_VAR 0 2
104088: PPUSH
104089: LD_VAR 0 3
104093: PPUSH
104094: LD_VAR 0 4
104098: PPUSH
104099: CALL 103157 0 4
104103: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
104104: LD_ADDR_VAR 0 11
104108: PUSH
104109: LD_VAR 0 1
104113: PPUSH
104114: LD_VAR 0 2
104118: PPUSH
104119: LD_VAR 0 12
104123: PUSH
104124: LD_INT 1
104126: ARRAY
104127: PPUSH
104128: LD_VAR 0 12
104132: PUSH
104133: LD_INT 2
104135: ARRAY
104136: PPUSH
104137: CALL_OW 298
104141: ST_TO_ADDR
// distance := 9999 ;
104142: LD_ADDR_VAR 0 10
104146: PUSH
104147: LD_INT 9999
104149: ST_TO_ADDR
// for i := 0 to 5 do
104150: LD_ADDR_VAR 0 6
104154: PUSH
104155: DOUBLE
104156: LD_INT 0
104158: DEC
104159: ST_TO_ADDR
104160: LD_INT 5
104162: PUSH
104163: FOR_TO
104164: IFFALSE 104307
// begin _x := ShiftX ( x1 , i , centerDist ) ;
104166: LD_ADDR_VAR 0 7
104170: PUSH
104171: LD_VAR 0 1
104175: PPUSH
104176: LD_VAR 0 6
104180: PPUSH
104181: LD_VAR 0 11
104185: PPUSH
104186: CALL_OW 272
104190: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
104191: LD_ADDR_VAR 0 8
104195: PUSH
104196: LD_VAR 0 2
104200: PPUSH
104201: LD_VAR 0 6
104205: PPUSH
104206: LD_VAR 0 11
104210: PPUSH
104211: CALL_OW 273
104215: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
104216: LD_VAR 0 7
104220: PPUSH
104221: LD_VAR 0 8
104225: PPUSH
104226: CALL_OW 488
104230: NOT
104231: IFFALSE 104235
// continue ;
104233: GO 104163
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
104235: LD_ADDR_VAR 0 9
104239: PUSH
104240: LD_VAR 0 12
104244: PUSH
104245: LD_INT 1
104247: ARRAY
104248: PPUSH
104249: LD_VAR 0 12
104253: PUSH
104254: LD_INT 2
104256: ARRAY
104257: PPUSH
104258: LD_VAR 0 7
104262: PPUSH
104263: LD_VAR 0 8
104267: PPUSH
104268: CALL_OW 298
104272: ST_TO_ADDR
// if tmp < distance then
104273: LD_VAR 0 9
104277: PUSH
104278: LD_VAR 0 10
104282: LESS
104283: IFFALSE 104305
// begin result := i ;
104285: LD_ADDR_VAR 0 5
104289: PUSH
104290: LD_VAR 0 6
104294: ST_TO_ADDR
// distance := tmp ;
104295: LD_ADDR_VAR 0 10
104299: PUSH
104300: LD_VAR 0 9
104304: ST_TO_ADDR
// end ; end ;
104305: GO 104163
104307: POP
104308: POP
// end ;
104309: LD_VAR 0 5
104313: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
104314: LD_INT 0
104316: PPUSH
104317: PPUSH
// if not driver or not IsInUnit ( driver ) then
104318: LD_VAR 0 1
104322: NOT
104323: PUSH
104324: LD_VAR 0 1
104328: PPUSH
104329: CALL_OW 310
104333: NOT
104334: OR
104335: IFFALSE 104339
// exit ;
104337: GO 104429
// vehicle := IsInUnit ( driver ) ;
104339: LD_ADDR_VAR 0 3
104343: PUSH
104344: LD_VAR 0 1
104348: PPUSH
104349: CALL_OW 310
104353: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104354: LD_VAR 0 1
104358: PPUSH
104359: LD_STRING \
104361: PUSH
104362: LD_INT 0
104364: PUSH
104365: LD_INT 0
104367: PUSH
104368: LD_INT 0
104370: PUSH
104371: LD_INT 0
104373: PUSH
104374: LD_INT 0
104376: PUSH
104377: LD_INT 0
104379: PUSH
104380: EMPTY
104381: LIST
104382: LIST
104383: LIST
104384: LIST
104385: LIST
104386: LIST
104387: LIST
104388: PUSH
104389: LD_STRING E
104391: PUSH
104392: LD_INT 0
104394: PUSH
104395: LD_INT 0
104397: PUSH
104398: LD_VAR 0 3
104402: PUSH
104403: LD_INT 0
104405: PUSH
104406: LD_INT 0
104408: PUSH
104409: LD_INT 0
104411: PUSH
104412: EMPTY
104413: LIST
104414: LIST
104415: LIST
104416: LIST
104417: LIST
104418: LIST
104419: LIST
104420: PUSH
104421: EMPTY
104422: LIST
104423: LIST
104424: PPUSH
104425: CALL_OW 446
// end ;
104429: LD_VAR 0 2
104433: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
104434: LD_INT 0
104436: PPUSH
104437: PPUSH
// if not driver or not IsInUnit ( driver ) then
104438: LD_VAR 0 1
104442: NOT
104443: PUSH
104444: LD_VAR 0 1
104448: PPUSH
104449: CALL_OW 310
104453: NOT
104454: OR
104455: IFFALSE 104459
// exit ;
104457: GO 104549
// vehicle := IsInUnit ( driver ) ;
104459: LD_ADDR_VAR 0 3
104463: PUSH
104464: LD_VAR 0 1
104468: PPUSH
104469: CALL_OW 310
104473: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
104474: LD_VAR 0 1
104478: PPUSH
104479: LD_STRING \
104481: PUSH
104482: LD_INT 0
104484: PUSH
104485: LD_INT 0
104487: PUSH
104488: LD_INT 0
104490: PUSH
104491: LD_INT 0
104493: PUSH
104494: LD_INT 0
104496: PUSH
104497: LD_INT 0
104499: PUSH
104500: EMPTY
104501: LIST
104502: LIST
104503: LIST
104504: LIST
104505: LIST
104506: LIST
104507: LIST
104508: PUSH
104509: LD_STRING E
104511: PUSH
104512: LD_INT 0
104514: PUSH
104515: LD_INT 0
104517: PUSH
104518: LD_VAR 0 3
104522: PUSH
104523: LD_INT 0
104525: PUSH
104526: LD_INT 0
104528: PUSH
104529: LD_INT 0
104531: PUSH
104532: EMPTY
104533: LIST
104534: LIST
104535: LIST
104536: LIST
104537: LIST
104538: LIST
104539: LIST
104540: PUSH
104541: EMPTY
104542: LIST
104543: LIST
104544: PPUSH
104545: CALL_OW 447
// end ;
104549: LD_VAR 0 2
104553: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
104554: LD_INT 0
104556: PPUSH
104557: PPUSH
104558: PPUSH
// tmp := [ ] ;
104559: LD_ADDR_VAR 0 5
104563: PUSH
104564: EMPTY
104565: ST_TO_ADDR
// for i in units do
104566: LD_ADDR_VAR 0 4
104570: PUSH
104571: LD_VAR 0 1
104575: PUSH
104576: FOR_IN
104577: IFFALSE 104615
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
104579: LD_ADDR_VAR 0 5
104583: PUSH
104584: LD_VAR 0 5
104588: PPUSH
104589: LD_VAR 0 5
104593: PUSH
104594: LD_INT 1
104596: PLUS
104597: PPUSH
104598: LD_VAR 0 4
104602: PPUSH
104603: CALL_OW 256
104607: PPUSH
104608: CALL_OW 2
104612: ST_TO_ADDR
104613: GO 104576
104615: POP
104616: POP
// if not tmp then
104617: LD_VAR 0 5
104621: NOT
104622: IFFALSE 104626
// exit ;
104624: GO 104674
// if asc then
104626: LD_VAR 0 2
104630: IFFALSE 104654
// result := SortListByListAsc ( units , tmp ) else
104632: LD_ADDR_VAR 0 3
104636: PUSH
104637: LD_VAR 0 1
104641: PPUSH
104642: LD_VAR 0 5
104646: PPUSH
104647: CALL_OW 76
104651: ST_TO_ADDR
104652: GO 104674
// result := SortListByListDesc ( units , tmp ) ;
104654: LD_ADDR_VAR 0 3
104658: PUSH
104659: LD_VAR 0 1
104663: PPUSH
104664: LD_VAR 0 5
104668: PPUSH
104669: CALL_OW 77
104673: ST_TO_ADDR
// end ;
104674: LD_VAR 0 3
104678: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
104679: LD_INT 0
104681: PPUSH
104682: PPUSH
// task := GetTaskList ( mech ) ;
104683: LD_ADDR_VAR 0 4
104687: PUSH
104688: LD_VAR 0 1
104692: PPUSH
104693: CALL_OW 437
104697: ST_TO_ADDR
// if not task then
104698: LD_VAR 0 4
104702: NOT
104703: IFFALSE 104707
// exit ;
104705: GO 104749
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
104707: LD_ADDR_VAR 0 3
104711: PUSH
104712: LD_VAR 0 4
104716: PUSH
104717: LD_INT 1
104719: ARRAY
104720: PUSH
104721: LD_INT 1
104723: ARRAY
104724: PUSH
104725: LD_STRING r
104727: EQUAL
104728: PUSH
104729: LD_VAR 0 4
104733: PUSH
104734: LD_INT 1
104736: ARRAY
104737: PUSH
104738: LD_INT 4
104740: ARRAY
104741: PUSH
104742: LD_VAR 0 2
104746: EQUAL
104747: AND
104748: ST_TO_ADDR
// end ;
104749: LD_VAR 0 3
104753: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
104754: LD_INT 0
104756: PPUSH
// SetDir ( unit , d ) ;
104757: LD_VAR 0 1
104761: PPUSH
104762: LD_VAR 0 4
104766: PPUSH
104767: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
104771: LD_VAR 0 1
104775: PPUSH
104776: LD_VAR 0 2
104780: PPUSH
104781: LD_VAR 0 3
104785: PPUSH
104786: LD_VAR 0 5
104790: PPUSH
104791: CALL_OW 48
// end ;
104795: LD_VAR 0 6
104799: RET
// export function ToNaturalNumber ( number ) ; begin
104800: LD_INT 0
104802: PPUSH
// result := number div 1 ;
104803: LD_ADDR_VAR 0 2
104807: PUSH
104808: LD_VAR 0 1
104812: PUSH
104813: LD_INT 1
104815: DIV
104816: ST_TO_ADDR
// if number < 0 then
104817: LD_VAR 0 1
104821: PUSH
104822: LD_INT 0
104824: LESS
104825: IFFALSE 104835
// result := 0 ;
104827: LD_ADDR_VAR 0 2
104831: PUSH
104832: LD_INT 0
104834: ST_TO_ADDR
// end ;
104835: LD_VAR 0 2
104839: RET
// export function SortByClass ( units , class ) ; var un ; begin
104840: LD_INT 0
104842: PPUSH
104843: PPUSH
// if not units or not class then
104844: LD_VAR 0 1
104848: NOT
104849: PUSH
104850: LD_VAR 0 2
104854: NOT
104855: OR
104856: IFFALSE 104860
// exit ;
104858: GO 104955
// result := [ ] ;
104860: LD_ADDR_VAR 0 3
104864: PUSH
104865: EMPTY
104866: ST_TO_ADDR
// for un in units do
104867: LD_ADDR_VAR 0 4
104871: PUSH
104872: LD_VAR 0 1
104876: PUSH
104877: FOR_IN
104878: IFFALSE 104953
// if GetClass ( un ) = class then
104880: LD_VAR 0 4
104884: PPUSH
104885: CALL_OW 257
104889: PUSH
104890: LD_VAR 0 2
104894: EQUAL
104895: IFFALSE 104922
// result := Insert ( result , 1 , un ) else
104897: LD_ADDR_VAR 0 3
104901: PUSH
104902: LD_VAR 0 3
104906: PPUSH
104907: LD_INT 1
104909: PPUSH
104910: LD_VAR 0 4
104914: PPUSH
104915: CALL_OW 2
104919: ST_TO_ADDR
104920: GO 104951
// result := Replace ( result , result + 1 , un ) ;
104922: LD_ADDR_VAR 0 3
104926: PUSH
104927: LD_VAR 0 3
104931: PPUSH
104932: LD_VAR 0 3
104936: PUSH
104937: LD_INT 1
104939: PLUS
104940: PPUSH
104941: LD_VAR 0 4
104945: PPUSH
104946: CALL_OW 1
104950: ST_TO_ADDR
104951: GO 104877
104953: POP
104954: POP
// end ;
104955: LD_VAR 0 3
104959: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
104960: LD_INT 0
104962: PPUSH
104963: PPUSH
104964: PPUSH
104965: PPUSH
104966: PPUSH
104967: PPUSH
104968: PPUSH
// result := [ ] ;
104969: LD_ADDR_VAR 0 4
104973: PUSH
104974: EMPTY
104975: ST_TO_ADDR
// if x - r < 0 then
104976: LD_VAR 0 1
104980: PUSH
104981: LD_VAR 0 3
104985: MINUS
104986: PUSH
104987: LD_INT 0
104989: LESS
104990: IFFALSE 105002
// min_x := 0 else
104992: LD_ADDR_VAR 0 8
104996: PUSH
104997: LD_INT 0
104999: ST_TO_ADDR
105000: GO 105018
// min_x := x - r ;
105002: LD_ADDR_VAR 0 8
105006: PUSH
105007: LD_VAR 0 1
105011: PUSH
105012: LD_VAR 0 3
105016: MINUS
105017: ST_TO_ADDR
// if y - r < 0 then
105018: LD_VAR 0 2
105022: PUSH
105023: LD_VAR 0 3
105027: MINUS
105028: PUSH
105029: LD_INT 0
105031: LESS
105032: IFFALSE 105044
// min_y := 0 else
105034: LD_ADDR_VAR 0 7
105038: PUSH
105039: LD_INT 0
105041: ST_TO_ADDR
105042: GO 105060
// min_y := y - r ;
105044: LD_ADDR_VAR 0 7
105048: PUSH
105049: LD_VAR 0 2
105053: PUSH
105054: LD_VAR 0 3
105058: MINUS
105059: ST_TO_ADDR
// max_x := x + r ;
105060: LD_ADDR_VAR 0 9
105064: PUSH
105065: LD_VAR 0 1
105069: PUSH
105070: LD_VAR 0 3
105074: PLUS
105075: ST_TO_ADDR
// max_y := y + r ;
105076: LD_ADDR_VAR 0 10
105080: PUSH
105081: LD_VAR 0 2
105085: PUSH
105086: LD_VAR 0 3
105090: PLUS
105091: ST_TO_ADDR
// for _x = min_x to max_x do
105092: LD_ADDR_VAR 0 5
105096: PUSH
105097: DOUBLE
105098: LD_VAR 0 8
105102: DEC
105103: ST_TO_ADDR
105104: LD_VAR 0 9
105108: PUSH
105109: FOR_TO
105110: IFFALSE 105211
// for _y = min_y to max_y do
105112: LD_ADDR_VAR 0 6
105116: PUSH
105117: DOUBLE
105118: LD_VAR 0 7
105122: DEC
105123: ST_TO_ADDR
105124: LD_VAR 0 10
105128: PUSH
105129: FOR_TO
105130: IFFALSE 105207
// begin if not ValidHex ( _x , _y ) then
105132: LD_VAR 0 5
105136: PPUSH
105137: LD_VAR 0 6
105141: PPUSH
105142: CALL_OW 488
105146: NOT
105147: IFFALSE 105151
// continue ;
105149: GO 105129
// if GetResourceTypeXY ( _x , _y ) then
105151: LD_VAR 0 5
105155: PPUSH
105156: LD_VAR 0 6
105160: PPUSH
105161: CALL_OW 283
105165: IFFALSE 105205
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
105167: LD_ADDR_VAR 0 4
105171: PUSH
105172: LD_VAR 0 4
105176: PPUSH
105177: LD_VAR 0 4
105181: PUSH
105182: LD_INT 1
105184: PLUS
105185: PPUSH
105186: LD_VAR 0 5
105190: PUSH
105191: LD_VAR 0 6
105195: PUSH
105196: EMPTY
105197: LIST
105198: LIST
105199: PPUSH
105200: CALL_OW 1
105204: ST_TO_ADDR
// end ;
105205: GO 105129
105207: POP
105208: POP
105209: GO 105109
105211: POP
105212: POP
// end ;
105213: LD_VAR 0 4
105217: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
105218: LD_INT 0
105220: PPUSH
105221: PPUSH
105222: PPUSH
105223: PPUSH
105224: PPUSH
105225: PPUSH
105226: PPUSH
105227: PPUSH
// if not units then
105228: LD_VAR 0 1
105232: NOT
105233: IFFALSE 105237
// exit ;
105235: GO 105662
// result := UnitFilter ( units , [ f_ok ] ) ;
105237: LD_ADDR_VAR 0 3
105241: PUSH
105242: LD_VAR 0 1
105246: PPUSH
105247: LD_INT 50
105249: PUSH
105250: EMPTY
105251: LIST
105252: PPUSH
105253: CALL_OW 72
105257: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
105258: LD_ADDR_VAR 0 8
105262: PUSH
105263: LD_VAR 0 1
105267: PUSH
105268: LD_INT 1
105270: ARRAY
105271: PPUSH
105272: CALL_OW 255
105276: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb ] ;
105277: LD_ADDR_VAR 0 10
105281: PUSH
105282: LD_INT 29
105284: PUSH
105285: LD_EXP 99
105289: PUSH
105290: EMPTY
105291: LIST
105292: LIST
105293: ST_TO_ADDR
// if not result then
105294: LD_VAR 0 3
105298: NOT
105299: IFFALSE 105303
// exit ;
105301: GO 105662
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
105303: LD_ADDR_VAR 0 5
105307: PUSH
105308: LD_INT 81
105310: PUSH
105311: LD_VAR 0 8
105315: PUSH
105316: EMPTY
105317: LIST
105318: LIST
105319: PPUSH
105320: CALL_OW 69
105324: ST_TO_ADDR
// for i in result do
105325: LD_ADDR_VAR 0 4
105329: PUSH
105330: LD_VAR 0 3
105334: PUSH
105335: FOR_IN
105336: IFFALSE 105660
// begin tag := GetTag ( i ) + 1 ;
105338: LD_ADDR_VAR 0 9
105342: PUSH
105343: LD_VAR 0 4
105347: PPUSH
105348: CALL_OW 110
105352: PUSH
105353: LD_INT 1
105355: PLUS
105356: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
105357: LD_ADDR_VAR 0 7
105361: PUSH
105362: LD_VAR 0 4
105366: PPUSH
105367: CALL_OW 250
105371: PPUSH
105372: LD_VAR 0 4
105376: PPUSH
105377: CALL_OW 251
105381: PPUSH
105382: LD_INT 6
105384: PPUSH
105385: CALL 104960 0 3
105389: ST_TO_ADDR
// if cr and not GetWeapon ( i ) in ignoreCratesWeapon then
105390: LD_VAR 0 7
105394: PUSH
105395: LD_VAR 0 4
105399: PPUSH
105400: CALL_OW 264
105404: PUSH
105405: LD_VAR 0 10
105409: IN
105410: NOT
105411: AND
105412: IFFALSE 105451
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
105414: LD_VAR 0 4
105418: PPUSH
105419: LD_VAR 0 7
105423: PUSH
105424: LD_INT 1
105426: ARRAY
105427: PUSH
105428: LD_INT 1
105430: ARRAY
105431: PPUSH
105432: LD_VAR 0 7
105436: PUSH
105437: LD_INT 1
105439: ARRAY
105440: PUSH
105441: LD_INT 2
105443: ARRAY
105444: PPUSH
105445: CALL_OW 116
105449: GO 105658
// if path > tag then
105451: LD_VAR 0 2
105455: PUSH
105456: LD_VAR 0 9
105460: GREATER
105461: IFFALSE 105628
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 12 ] ) ;
105463: LD_ADDR_VAR 0 6
105467: PUSH
105468: LD_VAR 0 5
105472: PPUSH
105473: LD_INT 91
105475: PUSH
105476: LD_VAR 0 4
105480: PUSH
105481: LD_INT 12
105483: PUSH
105484: EMPTY
105485: LIST
105486: LIST
105487: LIST
105488: PPUSH
105489: CALL_OW 72
105493: ST_TO_ADDR
// if nearEnemy then
105494: LD_VAR 0 6
105498: IFFALSE 105526
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
105500: LD_VAR 0 4
105504: PPUSH
105505: LD_VAR 0 6
105509: PPUSH
105510: LD_VAR 0 4
105514: PPUSH
105515: CALL_OW 74
105519: PPUSH
105520: CALL_OW 115
105524: GO 105626
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
105526: LD_VAR 0 4
105530: PPUSH
105531: LD_VAR 0 2
105535: PUSH
105536: LD_VAR 0 9
105540: ARRAY
105541: PUSH
105542: LD_INT 1
105544: ARRAY
105545: PPUSH
105546: LD_VAR 0 2
105550: PUSH
105551: LD_VAR 0 9
105555: ARRAY
105556: PUSH
105557: LD_INT 2
105559: ARRAY
105560: PPUSH
105561: CALL_OW 297
105565: PUSH
105566: LD_INT 6
105568: GREATER
105569: IFFALSE 105612
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
105571: LD_VAR 0 4
105575: PPUSH
105576: LD_VAR 0 2
105580: PUSH
105581: LD_VAR 0 9
105585: ARRAY
105586: PUSH
105587: LD_INT 1
105589: ARRAY
105590: PPUSH
105591: LD_VAR 0 2
105595: PUSH
105596: LD_VAR 0 9
105600: ARRAY
105601: PUSH
105602: LD_INT 2
105604: ARRAY
105605: PPUSH
105606: CALL_OW 114
105610: GO 105626
// SetTag ( i , tag ) ;
105612: LD_VAR 0 4
105616: PPUSH
105617: LD_VAR 0 9
105621: PPUSH
105622: CALL_OW 109
// end else
105626: GO 105658
// if enemy then
105628: LD_VAR 0 5
105632: IFFALSE 105658
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
105634: LD_VAR 0 4
105638: PPUSH
105639: LD_VAR 0 5
105643: PPUSH
105644: LD_VAR 0 4
105648: PPUSH
105649: CALL_OW 74
105653: PPUSH
105654: CALL_OW 115
// end ;
105658: GO 105335
105660: POP
105661: POP
// end ;
105662: LD_VAR 0 3
105666: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
105667: LD_INT 0
105669: PPUSH
105670: PPUSH
105671: PPUSH
// if not unit or IsInUnit ( unit ) then
105672: LD_VAR 0 1
105676: NOT
105677: PUSH
105678: LD_VAR 0 1
105682: PPUSH
105683: CALL_OW 310
105687: OR
105688: IFFALSE 105692
// exit ;
105690: GO 105783
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
105692: LD_ADDR_VAR 0 4
105696: PUSH
105697: LD_VAR 0 1
105701: PPUSH
105702: CALL_OW 250
105706: PPUSH
105707: LD_VAR 0 2
105711: PPUSH
105712: LD_INT 1
105714: PPUSH
105715: CALL_OW 272
105719: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
105720: LD_ADDR_VAR 0 5
105724: PUSH
105725: LD_VAR 0 1
105729: PPUSH
105730: CALL_OW 251
105734: PPUSH
105735: LD_VAR 0 2
105739: PPUSH
105740: LD_INT 1
105742: PPUSH
105743: CALL_OW 273
105747: ST_TO_ADDR
// if ValidHex ( x , y ) then
105748: LD_VAR 0 4
105752: PPUSH
105753: LD_VAR 0 5
105757: PPUSH
105758: CALL_OW 488
105762: IFFALSE 105783
// ComTurnXY ( unit , x , y ) ;
105764: LD_VAR 0 1
105768: PPUSH
105769: LD_VAR 0 4
105773: PPUSH
105774: LD_VAR 0 5
105778: PPUSH
105779: CALL_OW 118
// end ;
105783: LD_VAR 0 3
105787: RET
// export function SeeUnits ( side , units ) ; var i ; begin
105788: LD_INT 0
105790: PPUSH
105791: PPUSH
// result := false ;
105792: LD_ADDR_VAR 0 3
105796: PUSH
105797: LD_INT 0
105799: ST_TO_ADDR
// if not units then
105800: LD_VAR 0 2
105804: NOT
105805: IFFALSE 105809
// exit ;
105807: GO 105854
// for i in units do
105809: LD_ADDR_VAR 0 4
105813: PUSH
105814: LD_VAR 0 2
105818: PUSH
105819: FOR_IN
105820: IFFALSE 105852
// if See ( side , i ) then
105822: LD_VAR 0 1
105826: PPUSH
105827: LD_VAR 0 4
105831: PPUSH
105832: CALL_OW 292
105836: IFFALSE 105850
// begin result := true ;
105838: LD_ADDR_VAR 0 3
105842: PUSH
105843: LD_INT 1
105845: ST_TO_ADDR
// exit ;
105846: POP
105847: POP
105848: GO 105854
// end ;
105850: GO 105819
105852: POP
105853: POP
// end ;
105854: LD_VAR 0 3
105858: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
105859: LD_INT 0
105861: PPUSH
105862: PPUSH
105863: PPUSH
105864: PPUSH
// if not unit or not points then
105865: LD_VAR 0 1
105869: NOT
105870: PUSH
105871: LD_VAR 0 2
105875: NOT
105876: OR
105877: IFFALSE 105881
// exit ;
105879: GO 105971
// dist := 99999 ;
105881: LD_ADDR_VAR 0 5
105885: PUSH
105886: LD_INT 99999
105888: ST_TO_ADDR
// for i in points do
105889: LD_ADDR_VAR 0 4
105893: PUSH
105894: LD_VAR 0 2
105898: PUSH
105899: FOR_IN
105900: IFFALSE 105969
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
105902: LD_ADDR_VAR 0 6
105906: PUSH
105907: LD_VAR 0 1
105911: PPUSH
105912: LD_VAR 0 4
105916: PUSH
105917: LD_INT 1
105919: ARRAY
105920: PPUSH
105921: LD_VAR 0 4
105925: PUSH
105926: LD_INT 2
105928: ARRAY
105929: PPUSH
105930: CALL_OW 297
105934: ST_TO_ADDR
// if tmpDist < dist then
105935: LD_VAR 0 6
105939: PUSH
105940: LD_VAR 0 5
105944: LESS
105945: IFFALSE 105967
// begin result := i ;
105947: LD_ADDR_VAR 0 3
105951: PUSH
105952: LD_VAR 0 4
105956: ST_TO_ADDR
// dist := tmpDist ;
105957: LD_ADDR_VAR 0 5
105961: PUSH
105962: LD_VAR 0 6
105966: ST_TO_ADDR
// end ; end ;
105967: GO 105899
105969: POP
105970: POP
// end ; end_of_file end_of_file
105971: LD_VAR 0 3
105975: RET
// every 0 0$1 do
105976: GO 105978
105978: DISABLE
// begin enable ;
105979: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
105980: LD_STRING updateTimer(
105982: PUSH
105983: LD_OWVAR 1
105987: STR
105988: PUSH
105989: LD_STRING );
105991: STR
105992: PPUSH
105993: CALL_OW 559
// end ;
105997: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
105998: LD_INT 0
106000: PPUSH
// if p2 = 100 then
106001: LD_VAR 0 2
106005: PUSH
106006: LD_INT 100
106008: EQUAL
106009: IFFALSE 107012
// begin if not StreamModeActive then
106011: LD_EXP 160
106015: NOT
106016: IFFALSE 106026
// StreamModeActive := true ;
106018: LD_ADDR_EXP 160
106022: PUSH
106023: LD_INT 1
106025: ST_TO_ADDR
// if p3 = 0 then
106026: LD_VAR 0 3
106030: PUSH
106031: LD_INT 0
106033: EQUAL
106034: IFFALSE 106040
// InitStreamMode ;
106036: CALL 107172 0 0
// if p3 = 1 then
106040: LD_VAR 0 3
106044: PUSH
106045: LD_INT 1
106047: EQUAL
106048: IFFALSE 106058
// sRocket := true ;
106050: LD_ADDR_EXP 165
106054: PUSH
106055: LD_INT 1
106057: ST_TO_ADDR
// if p3 = 2 then
106058: LD_VAR 0 3
106062: PUSH
106063: LD_INT 2
106065: EQUAL
106066: IFFALSE 106076
// sSpeed := true ;
106068: LD_ADDR_EXP 164
106072: PUSH
106073: LD_INT 1
106075: ST_TO_ADDR
// if p3 = 3 then
106076: LD_VAR 0 3
106080: PUSH
106081: LD_INT 3
106083: EQUAL
106084: IFFALSE 106094
// sEngine := true ;
106086: LD_ADDR_EXP 166
106090: PUSH
106091: LD_INT 1
106093: ST_TO_ADDR
// if p3 = 4 then
106094: LD_VAR 0 3
106098: PUSH
106099: LD_INT 4
106101: EQUAL
106102: IFFALSE 106112
// sSpec := true ;
106104: LD_ADDR_EXP 163
106108: PUSH
106109: LD_INT 1
106111: ST_TO_ADDR
// if p3 = 5 then
106112: LD_VAR 0 3
106116: PUSH
106117: LD_INT 5
106119: EQUAL
106120: IFFALSE 106130
// sLevel := true ;
106122: LD_ADDR_EXP 167
106126: PUSH
106127: LD_INT 1
106129: ST_TO_ADDR
// if p3 = 6 then
106130: LD_VAR 0 3
106134: PUSH
106135: LD_INT 6
106137: EQUAL
106138: IFFALSE 106148
// sArmoury := true ;
106140: LD_ADDR_EXP 168
106144: PUSH
106145: LD_INT 1
106147: ST_TO_ADDR
// if p3 = 7 then
106148: LD_VAR 0 3
106152: PUSH
106153: LD_INT 7
106155: EQUAL
106156: IFFALSE 106166
// sRadar := true ;
106158: LD_ADDR_EXP 169
106162: PUSH
106163: LD_INT 1
106165: ST_TO_ADDR
// if p3 = 8 then
106166: LD_VAR 0 3
106170: PUSH
106171: LD_INT 8
106173: EQUAL
106174: IFFALSE 106184
// sBunker := true ;
106176: LD_ADDR_EXP 170
106180: PUSH
106181: LD_INT 1
106183: ST_TO_ADDR
// if p3 = 9 then
106184: LD_VAR 0 3
106188: PUSH
106189: LD_INT 9
106191: EQUAL
106192: IFFALSE 106202
// sHack := true ;
106194: LD_ADDR_EXP 171
106198: PUSH
106199: LD_INT 1
106201: ST_TO_ADDR
// if p3 = 10 then
106202: LD_VAR 0 3
106206: PUSH
106207: LD_INT 10
106209: EQUAL
106210: IFFALSE 106220
// sFire := true ;
106212: LD_ADDR_EXP 172
106216: PUSH
106217: LD_INT 1
106219: ST_TO_ADDR
// if p3 = 11 then
106220: LD_VAR 0 3
106224: PUSH
106225: LD_INT 11
106227: EQUAL
106228: IFFALSE 106238
// sRefresh := true ;
106230: LD_ADDR_EXP 173
106234: PUSH
106235: LD_INT 1
106237: ST_TO_ADDR
// if p3 = 12 then
106238: LD_VAR 0 3
106242: PUSH
106243: LD_INT 12
106245: EQUAL
106246: IFFALSE 106256
// sExp := true ;
106248: LD_ADDR_EXP 174
106252: PUSH
106253: LD_INT 1
106255: ST_TO_ADDR
// if p3 = 13 then
106256: LD_VAR 0 3
106260: PUSH
106261: LD_INT 13
106263: EQUAL
106264: IFFALSE 106274
// sDepot := true ;
106266: LD_ADDR_EXP 175
106270: PUSH
106271: LD_INT 1
106273: ST_TO_ADDR
// if p3 = 14 then
106274: LD_VAR 0 3
106278: PUSH
106279: LD_INT 14
106281: EQUAL
106282: IFFALSE 106292
// sFlag := true ;
106284: LD_ADDR_EXP 176
106288: PUSH
106289: LD_INT 1
106291: ST_TO_ADDR
// if p3 = 15 then
106292: LD_VAR 0 3
106296: PUSH
106297: LD_INT 15
106299: EQUAL
106300: IFFALSE 106310
// sKamikadze := true ;
106302: LD_ADDR_EXP 184
106306: PUSH
106307: LD_INT 1
106309: ST_TO_ADDR
// if p3 = 16 then
106310: LD_VAR 0 3
106314: PUSH
106315: LD_INT 16
106317: EQUAL
106318: IFFALSE 106328
// sTroll := true ;
106320: LD_ADDR_EXP 185
106324: PUSH
106325: LD_INT 1
106327: ST_TO_ADDR
// if p3 = 17 then
106328: LD_VAR 0 3
106332: PUSH
106333: LD_INT 17
106335: EQUAL
106336: IFFALSE 106346
// sSlow := true ;
106338: LD_ADDR_EXP 186
106342: PUSH
106343: LD_INT 1
106345: ST_TO_ADDR
// if p3 = 18 then
106346: LD_VAR 0 3
106350: PUSH
106351: LD_INT 18
106353: EQUAL
106354: IFFALSE 106364
// sLack := true ;
106356: LD_ADDR_EXP 187
106360: PUSH
106361: LD_INT 1
106363: ST_TO_ADDR
// if p3 = 19 then
106364: LD_VAR 0 3
106368: PUSH
106369: LD_INT 19
106371: EQUAL
106372: IFFALSE 106382
// sTank := true ;
106374: LD_ADDR_EXP 189
106378: PUSH
106379: LD_INT 1
106381: ST_TO_ADDR
// if p3 = 20 then
106382: LD_VAR 0 3
106386: PUSH
106387: LD_INT 20
106389: EQUAL
106390: IFFALSE 106400
// sRemote := true ;
106392: LD_ADDR_EXP 190
106396: PUSH
106397: LD_INT 1
106399: ST_TO_ADDR
// if p3 = 21 then
106400: LD_VAR 0 3
106404: PUSH
106405: LD_INT 21
106407: EQUAL
106408: IFFALSE 106418
// sPowell := true ;
106410: LD_ADDR_EXP 191
106414: PUSH
106415: LD_INT 1
106417: ST_TO_ADDR
// if p3 = 22 then
106418: LD_VAR 0 3
106422: PUSH
106423: LD_INT 22
106425: EQUAL
106426: IFFALSE 106436
// sTeleport := true ;
106428: LD_ADDR_EXP 194
106432: PUSH
106433: LD_INT 1
106435: ST_TO_ADDR
// if p3 = 23 then
106436: LD_VAR 0 3
106440: PUSH
106441: LD_INT 23
106443: EQUAL
106444: IFFALSE 106454
// sOilTower := true ;
106446: LD_ADDR_EXP 196
106450: PUSH
106451: LD_INT 1
106453: ST_TO_ADDR
// if p3 = 24 then
106454: LD_VAR 0 3
106458: PUSH
106459: LD_INT 24
106461: EQUAL
106462: IFFALSE 106472
// sShovel := true ;
106464: LD_ADDR_EXP 197
106468: PUSH
106469: LD_INT 1
106471: ST_TO_ADDR
// if p3 = 25 then
106472: LD_VAR 0 3
106476: PUSH
106477: LD_INT 25
106479: EQUAL
106480: IFFALSE 106490
// sSheik := true ;
106482: LD_ADDR_EXP 198
106486: PUSH
106487: LD_INT 1
106489: ST_TO_ADDR
// if p3 = 26 then
106490: LD_VAR 0 3
106494: PUSH
106495: LD_INT 26
106497: EQUAL
106498: IFFALSE 106508
// sEarthquake := true ;
106500: LD_ADDR_EXP 200
106504: PUSH
106505: LD_INT 1
106507: ST_TO_ADDR
// if p3 = 27 then
106508: LD_VAR 0 3
106512: PUSH
106513: LD_INT 27
106515: EQUAL
106516: IFFALSE 106526
// sAI := true ;
106518: LD_ADDR_EXP 201
106522: PUSH
106523: LD_INT 1
106525: ST_TO_ADDR
// if p3 = 28 then
106526: LD_VAR 0 3
106530: PUSH
106531: LD_INT 28
106533: EQUAL
106534: IFFALSE 106544
// sCargo := true ;
106536: LD_ADDR_EXP 204
106540: PUSH
106541: LD_INT 1
106543: ST_TO_ADDR
// if p3 = 29 then
106544: LD_VAR 0 3
106548: PUSH
106549: LD_INT 29
106551: EQUAL
106552: IFFALSE 106562
// sDLaser := true ;
106554: LD_ADDR_EXP 205
106558: PUSH
106559: LD_INT 1
106561: ST_TO_ADDR
// if p3 = 30 then
106562: LD_VAR 0 3
106566: PUSH
106567: LD_INT 30
106569: EQUAL
106570: IFFALSE 106580
// sExchange := true ;
106572: LD_ADDR_EXP 206
106576: PUSH
106577: LD_INT 1
106579: ST_TO_ADDR
// if p3 = 31 then
106580: LD_VAR 0 3
106584: PUSH
106585: LD_INT 31
106587: EQUAL
106588: IFFALSE 106598
// sFac := true ;
106590: LD_ADDR_EXP 207
106594: PUSH
106595: LD_INT 1
106597: ST_TO_ADDR
// if p3 = 32 then
106598: LD_VAR 0 3
106602: PUSH
106603: LD_INT 32
106605: EQUAL
106606: IFFALSE 106616
// sPower := true ;
106608: LD_ADDR_EXP 208
106612: PUSH
106613: LD_INT 1
106615: ST_TO_ADDR
// if p3 = 33 then
106616: LD_VAR 0 3
106620: PUSH
106621: LD_INT 33
106623: EQUAL
106624: IFFALSE 106634
// sRandom := true ;
106626: LD_ADDR_EXP 209
106630: PUSH
106631: LD_INT 1
106633: ST_TO_ADDR
// if p3 = 34 then
106634: LD_VAR 0 3
106638: PUSH
106639: LD_INT 34
106641: EQUAL
106642: IFFALSE 106652
// sShield := true ;
106644: LD_ADDR_EXP 210
106648: PUSH
106649: LD_INT 1
106651: ST_TO_ADDR
// if p3 = 35 then
106652: LD_VAR 0 3
106656: PUSH
106657: LD_INT 35
106659: EQUAL
106660: IFFALSE 106670
// sTime := true ;
106662: LD_ADDR_EXP 211
106666: PUSH
106667: LD_INT 1
106669: ST_TO_ADDR
// if p3 = 36 then
106670: LD_VAR 0 3
106674: PUSH
106675: LD_INT 36
106677: EQUAL
106678: IFFALSE 106688
// sTools := true ;
106680: LD_ADDR_EXP 212
106684: PUSH
106685: LD_INT 1
106687: ST_TO_ADDR
// if p3 = 101 then
106688: LD_VAR 0 3
106692: PUSH
106693: LD_INT 101
106695: EQUAL
106696: IFFALSE 106706
// sSold := true ;
106698: LD_ADDR_EXP 177
106702: PUSH
106703: LD_INT 1
106705: ST_TO_ADDR
// if p3 = 102 then
106706: LD_VAR 0 3
106710: PUSH
106711: LD_INT 102
106713: EQUAL
106714: IFFALSE 106724
// sDiff := true ;
106716: LD_ADDR_EXP 178
106720: PUSH
106721: LD_INT 1
106723: ST_TO_ADDR
// if p3 = 103 then
106724: LD_VAR 0 3
106728: PUSH
106729: LD_INT 103
106731: EQUAL
106732: IFFALSE 106742
// sFog := true ;
106734: LD_ADDR_EXP 181
106738: PUSH
106739: LD_INT 1
106741: ST_TO_ADDR
// if p3 = 104 then
106742: LD_VAR 0 3
106746: PUSH
106747: LD_INT 104
106749: EQUAL
106750: IFFALSE 106760
// sReset := true ;
106752: LD_ADDR_EXP 182
106756: PUSH
106757: LD_INT 1
106759: ST_TO_ADDR
// if p3 = 105 then
106760: LD_VAR 0 3
106764: PUSH
106765: LD_INT 105
106767: EQUAL
106768: IFFALSE 106778
// sSun := true ;
106770: LD_ADDR_EXP 183
106774: PUSH
106775: LD_INT 1
106777: ST_TO_ADDR
// if p3 = 106 then
106778: LD_VAR 0 3
106782: PUSH
106783: LD_INT 106
106785: EQUAL
106786: IFFALSE 106796
// sTiger := true ;
106788: LD_ADDR_EXP 179
106792: PUSH
106793: LD_INT 1
106795: ST_TO_ADDR
// if p3 = 107 then
106796: LD_VAR 0 3
106800: PUSH
106801: LD_INT 107
106803: EQUAL
106804: IFFALSE 106814
// sBomb := true ;
106806: LD_ADDR_EXP 180
106810: PUSH
106811: LD_INT 1
106813: ST_TO_ADDR
// if p3 = 108 then
106814: LD_VAR 0 3
106818: PUSH
106819: LD_INT 108
106821: EQUAL
106822: IFFALSE 106832
// sWound := true ;
106824: LD_ADDR_EXP 188
106828: PUSH
106829: LD_INT 1
106831: ST_TO_ADDR
// if p3 = 109 then
106832: LD_VAR 0 3
106836: PUSH
106837: LD_INT 109
106839: EQUAL
106840: IFFALSE 106850
// sBetray := true ;
106842: LD_ADDR_EXP 192
106846: PUSH
106847: LD_INT 1
106849: ST_TO_ADDR
// if p3 = 110 then
106850: LD_VAR 0 3
106854: PUSH
106855: LD_INT 110
106857: EQUAL
106858: IFFALSE 106868
// sContamin := true ;
106860: LD_ADDR_EXP 193
106864: PUSH
106865: LD_INT 1
106867: ST_TO_ADDR
// if p3 = 111 then
106868: LD_VAR 0 3
106872: PUSH
106873: LD_INT 111
106875: EQUAL
106876: IFFALSE 106886
// sOil := true ;
106878: LD_ADDR_EXP 195
106882: PUSH
106883: LD_INT 1
106885: ST_TO_ADDR
// if p3 = 112 then
106886: LD_VAR 0 3
106890: PUSH
106891: LD_INT 112
106893: EQUAL
106894: IFFALSE 106904
// sStu := true ;
106896: LD_ADDR_EXP 199
106900: PUSH
106901: LD_INT 1
106903: ST_TO_ADDR
// if p3 = 113 then
106904: LD_VAR 0 3
106908: PUSH
106909: LD_INT 113
106911: EQUAL
106912: IFFALSE 106922
// sBazooka := true ;
106914: LD_ADDR_EXP 202
106918: PUSH
106919: LD_INT 1
106921: ST_TO_ADDR
// if p3 = 114 then
106922: LD_VAR 0 3
106926: PUSH
106927: LD_INT 114
106929: EQUAL
106930: IFFALSE 106940
// sMortar := true ;
106932: LD_ADDR_EXP 203
106936: PUSH
106937: LD_INT 1
106939: ST_TO_ADDR
// if p3 = 115 then
106940: LD_VAR 0 3
106944: PUSH
106945: LD_INT 115
106947: EQUAL
106948: IFFALSE 106958
// sRanger := true ;
106950: LD_ADDR_EXP 213
106954: PUSH
106955: LD_INT 1
106957: ST_TO_ADDR
// if p3 = 116 then
106958: LD_VAR 0 3
106962: PUSH
106963: LD_INT 116
106965: EQUAL
106966: IFFALSE 106976
// sComputer := true ;
106968: LD_ADDR_EXP 214
106972: PUSH
106973: LD_INT 1
106975: ST_TO_ADDR
// if p3 = 117 then
106976: LD_VAR 0 3
106980: PUSH
106981: LD_INT 117
106983: EQUAL
106984: IFFALSE 106994
// s30 := true ;
106986: LD_ADDR_EXP 215
106990: PUSH
106991: LD_INT 1
106993: ST_TO_ADDR
// if p3 = 118 then
106994: LD_VAR 0 3
106998: PUSH
106999: LD_INT 118
107001: EQUAL
107002: IFFALSE 107012
// s60 := true ;
107004: LD_ADDR_EXP 216
107008: PUSH
107009: LD_INT 1
107011: ST_TO_ADDR
// end ; if p2 = 101 then
107012: LD_VAR 0 2
107016: PUSH
107017: LD_INT 101
107019: EQUAL
107020: IFFALSE 107148
// begin case p3 of 1 :
107022: LD_VAR 0 3
107026: PUSH
107027: LD_INT 1
107029: DOUBLE
107030: EQUAL
107031: IFTRUE 107035
107033: GO 107042
107035: POP
// hHackUnlimitedResources ; 2 :
107036: CALL 118744 0 0
107040: GO 107148
107042: LD_INT 2
107044: DOUBLE
107045: EQUAL
107046: IFTRUE 107050
107048: GO 107057
107050: POP
// hHackSetLevel10 ; 3 :
107051: CALL 118877 0 0
107055: GO 107148
107057: LD_INT 3
107059: DOUBLE
107060: EQUAL
107061: IFTRUE 107065
107063: GO 107072
107065: POP
// hHackSetLevel10YourUnits ; 4 :
107066: CALL 118962 0 0
107070: GO 107148
107072: LD_INT 4
107074: DOUBLE
107075: EQUAL
107076: IFTRUE 107080
107078: GO 107087
107080: POP
// hHackInvincible ; 5 :
107081: CALL 119410 0 0
107085: GO 107148
107087: LD_INT 5
107089: DOUBLE
107090: EQUAL
107091: IFTRUE 107095
107093: GO 107102
107095: POP
// hHackInvisible ; 6 :
107096: CALL 119521 0 0
107100: GO 107148
107102: LD_INT 6
107104: DOUBLE
107105: EQUAL
107106: IFTRUE 107110
107108: GO 107117
107110: POP
// hHackChangeYourSide ; 7 :
107111: CALL 119578 0 0
107115: GO 107148
107117: LD_INT 7
107119: DOUBLE
107120: EQUAL
107121: IFTRUE 107125
107123: GO 107132
107125: POP
// hHackChangeUnitSide ; 8 :
107126: CALL 119620 0 0
107130: GO 107148
107132: LD_INT 8
107134: DOUBLE
107135: EQUAL
107136: IFTRUE 107140
107138: GO 107147
107140: POP
// hHackFog ; end ;
107141: CALL 119721 0 0
107145: GO 107148
107147: POP
// end ; end ;
107148: LD_VAR 0 7
107152: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
107153: GO 107155
107155: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
107156: LD_STRING initStreamRollete();
107158: PPUSH
107159: CALL_OW 559
// InitStreamMode ;
107163: CALL 107172 0 0
// DefineStreamItems ( ) ;
107167: CALL 107636 0 0
// end ;
107171: END
// function InitStreamMode ; begin
107172: LD_INT 0
107174: PPUSH
// streamModeActive := false ;
107175: LD_ADDR_EXP 160
107179: PUSH
107180: LD_INT 0
107182: ST_TO_ADDR
// normalCounter := 36 ;
107183: LD_ADDR_EXP 161
107187: PUSH
107188: LD_INT 36
107190: ST_TO_ADDR
// hardcoreCounter := 16 ;
107191: LD_ADDR_EXP 162
107195: PUSH
107196: LD_INT 16
107198: ST_TO_ADDR
// sRocket := false ;
107199: LD_ADDR_EXP 165
107203: PUSH
107204: LD_INT 0
107206: ST_TO_ADDR
// sSpeed := false ;
107207: LD_ADDR_EXP 164
107211: PUSH
107212: LD_INT 0
107214: ST_TO_ADDR
// sEngine := false ;
107215: LD_ADDR_EXP 166
107219: PUSH
107220: LD_INT 0
107222: ST_TO_ADDR
// sSpec := false ;
107223: LD_ADDR_EXP 163
107227: PUSH
107228: LD_INT 0
107230: ST_TO_ADDR
// sLevel := false ;
107231: LD_ADDR_EXP 167
107235: PUSH
107236: LD_INT 0
107238: ST_TO_ADDR
// sArmoury := false ;
107239: LD_ADDR_EXP 168
107243: PUSH
107244: LD_INT 0
107246: ST_TO_ADDR
// sRadar := false ;
107247: LD_ADDR_EXP 169
107251: PUSH
107252: LD_INT 0
107254: ST_TO_ADDR
// sBunker := false ;
107255: LD_ADDR_EXP 170
107259: PUSH
107260: LD_INT 0
107262: ST_TO_ADDR
// sHack := false ;
107263: LD_ADDR_EXP 171
107267: PUSH
107268: LD_INT 0
107270: ST_TO_ADDR
// sFire := false ;
107271: LD_ADDR_EXP 172
107275: PUSH
107276: LD_INT 0
107278: ST_TO_ADDR
// sRefresh := false ;
107279: LD_ADDR_EXP 173
107283: PUSH
107284: LD_INT 0
107286: ST_TO_ADDR
// sExp := false ;
107287: LD_ADDR_EXP 174
107291: PUSH
107292: LD_INT 0
107294: ST_TO_ADDR
// sDepot := false ;
107295: LD_ADDR_EXP 175
107299: PUSH
107300: LD_INT 0
107302: ST_TO_ADDR
// sFlag := false ;
107303: LD_ADDR_EXP 176
107307: PUSH
107308: LD_INT 0
107310: ST_TO_ADDR
// sKamikadze := false ;
107311: LD_ADDR_EXP 184
107315: PUSH
107316: LD_INT 0
107318: ST_TO_ADDR
// sTroll := false ;
107319: LD_ADDR_EXP 185
107323: PUSH
107324: LD_INT 0
107326: ST_TO_ADDR
// sSlow := false ;
107327: LD_ADDR_EXP 186
107331: PUSH
107332: LD_INT 0
107334: ST_TO_ADDR
// sLack := false ;
107335: LD_ADDR_EXP 187
107339: PUSH
107340: LD_INT 0
107342: ST_TO_ADDR
// sTank := false ;
107343: LD_ADDR_EXP 189
107347: PUSH
107348: LD_INT 0
107350: ST_TO_ADDR
// sRemote := false ;
107351: LD_ADDR_EXP 190
107355: PUSH
107356: LD_INT 0
107358: ST_TO_ADDR
// sPowell := false ;
107359: LD_ADDR_EXP 191
107363: PUSH
107364: LD_INT 0
107366: ST_TO_ADDR
// sTeleport := false ;
107367: LD_ADDR_EXP 194
107371: PUSH
107372: LD_INT 0
107374: ST_TO_ADDR
// sOilTower := false ;
107375: LD_ADDR_EXP 196
107379: PUSH
107380: LD_INT 0
107382: ST_TO_ADDR
// sShovel := false ;
107383: LD_ADDR_EXP 197
107387: PUSH
107388: LD_INT 0
107390: ST_TO_ADDR
// sSheik := false ;
107391: LD_ADDR_EXP 198
107395: PUSH
107396: LD_INT 0
107398: ST_TO_ADDR
// sEarthquake := false ;
107399: LD_ADDR_EXP 200
107403: PUSH
107404: LD_INT 0
107406: ST_TO_ADDR
// sAI := false ;
107407: LD_ADDR_EXP 201
107411: PUSH
107412: LD_INT 0
107414: ST_TO_ADDR
// sCargo := false ;
107415: LD_ADDR_EXP 204
107419: PUSH
107420: LD_INT 0
107422: ST_TO_ADDR
// sDLaser := false ;
107423: LD_ADDR_EXP 205
107427: PUSH
107428: LD_INT 0
107430: ST_TO_ADDR
// sExchange := false ;
107431: LD_ADDR_EXP 206
107435: PUSH
107436: LD_INT 0
107438: ST_TO_ADDR
// sFac := false ;
107439: LD_ADDR_EXP 207
107443: PUSH
107444: LD_INT 0
107446: ST_TO_ADDR
// sPower := false ;
107447: LD_ADDR_EXP 208
107451: PUSH
107452: LD_INT 0
107454: ST_TO_ADDR
// sRandom := false ;
107455: LD_ADDR_EXP 209
107459: PUSH
107460: LD_INT 0
107462: ST_TO_ADDR
// sShield := false ;
107463: LD_ADDR_EXP 210
107467: PUSH
107468: LD_INT 0
107470: ST_TO_ADDR
// sTime := false ;
107471: LD_ADDR_EXP 211
107475: PUSH
107476: LD_INT 0
107478: ST_TO_ADDR
// sTools := false ;
107479: LD_ADDR_EXP 212
107483: PUSH
107484: LD_INT 0
107486: ST_TO_ADDR
// sSold := false ;
107487: LD_ADDR_EXP 177
107491: PUSH
107492: LD_INT 0
107494: ST_TO_ADDR
// sDiff := false ;
107495: LD_ADDR_EXP 178
107499: PUSH
107500: LD_INT 0
107502: ST_TO_ADDR
// sFog := false ;
107503: LD_ADDR_EXP 181
107507: PUSH
107508: LD_INT 0
107510: ST_TO_ADDR
// sReset := false ;
107511: LD_ADDR_EXP 182
107515: PUSH
107516: LD_INT 0
107518: ST_TO_ADDR
// sSun := false ;
107519: LD_ADDR_EXP 183
107523: PUSH
107524: LD_INT 0
107526: ST_TO_ADDR
// sTiger := false ;
107527: LD_ADDR_EXP 179
107531: PUSH
107532: LD_INT 0
107534: ST_TO_ADDR
// sBomb := false ;
107535: LD_ADDR_EXP 180
107539: PUSH
107540: LD_INT 0
107542: ST_TO_ADDR
// sWound := false ;
107543: LD_ADDR_EXP 188
107547: PUSH
107548: LD_INT 0
107550: ST_TO_ADDR
// sBetray := false ;
107551: LD_ADDR_EXP 192
107555: PUSH
107556: LD_INT 0
107558: ST_TO_ADDR
// sContamin := false ;
107559: LD_ADDR_EXP 193
107563: PUSH
107564: LD_INT 0
107566: ST_TO_ADDR
// sOil := false ;
107567: LD_ADDR_EXP 195
107571: PUSH
107572: LD_INT 0
107574: ST_TO_ADDR
// sStu := false ;
107575: LD_ADDR_EXP 199
107579: PUSH
107580: LD_INT 0
107582: ST_TO_ADDR
// sBazooka := false ;
107583: LD_ADDR_EXP 202
107587: PUSH
107588: LD_INT 0
107590: ST_TO_ADDR
// sMortar := false ;
107591: LD_ADDR_EXP 203
107595: PUSH
107596: LD_INT 0
107598: ST_TO_ADDR
// sRanger := false ;
107599: LD_ADDR_EXP 213
107603: PUSH
107604: LD_INT 0
107606: ST_TO_ADDR
// sComputer := false ;
107607: LD_ADDR_EXP 214
107611: PUSH
107612: LD_INT 0
107614: ST_TO_ADDR
// s30 := false ;
107615: LD_ADDR_EXP 215
107619: PUSH
107620: LD_INT 0
107622: ST_TO_ADDR
// s60 := false ;
107623: LD_ADDR_EXP 216
107627: PUSH
107628: LD_INT 0
107630: ST_TO_ADDR
// end ;
107631: LD_VAR 0 1
107635: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
107636: LD_INT 0
107638: PPUSH
107639: PPUSH
107640: PPUSH
107641: PPUSH
107642: PPUSH
// result := [ ] ;
107643: LD_ADDR_VAR 0 1
107647: PUSH
107648: EMPTY
107649: ST_TO_ADDR
// if campaign_id = 1 then
107650: LD_OWVAR 69
107654: PUSH
107655: LD_INT 1
107657: EQUAL
107658: IFFALSE 110824
// begin case mission_number of 1 :
107660: LD_OWVAR 70
107664: PUSH
107665: LD_INT 1
107667: DOUBLE
107668: EQUAL
107669: IFTRUE 107673
107671: GO 107749
107673: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
107674: LD_ADDR_VAR 0 1
107678: PUSH
107679: LD_INT 2
107681: PUSH
107682: LD_INT 4
107684: PUSH
107685: LD_INT 11
107687: PUSH
107688: LD_INT 12
107690: PUSH
107691: LD_INT 15
107693: PUSH
107694: LD_INT 16
107696: PUSH
107697: LD_INT 22
107699: PUSH
107700: LD_INT 23
107702: PUSH
107703: LD_INT 26
107705: PUSH
107706: EMPTY
107707: LIST
107708: LIST
107709: LIST
107710: LIST
107711: LIST
107712: LIST
107713: LIST
107714: LIST
107715: LIST
107716: PUSH
107717: LD_INT 101
107719: PUSH
107720: LD_INT 102
107722: PUSH
107723: LD_INT 106
107725: PUSH
107726: LD_INT 116
107728: PUSH
107729: LD_INT 117
107731: PUSH
107732: LD_INT 118
107734: PUSH
107735: EMPTY
107736: LIST
107737: LIST
107738: LIST
107739: LIST
107740: LIST
107741: LIST
107742: PUSH
107743: EMPTY
107744: LIST
107745: LIST
107746: ST_TO_ADDR
107747: GO 110822
107749: LD_INT 2
107751: DOUBLE
107752: EQUAL
107753: IFTRUE 107757
107755: GO 107841
107757: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
107758: LD_ADDR_VAR 0 1
107762: PUSH
107763: LD_INT 2
107765: PUSH
107766: LD_INT 4
107768: PUSH
107769: LD_INT 11
107771: PUSH
107772: LD_INT 12
107774: PUSH
107775: LD_INT 15
107777: PUSH
107778: LD_INT 16
107780: PUSH
107781: LD_INT 22
107783: PUSH
107784: LD_INT 23
107786: PUSH
107787: LD_INT 26
107789: PUSH
107790: EMPTY
107791: LIST
107792: LIST
107793: LIST
107794: LIST
107795: LIST
107796: LIST
107797: LIST
107798: LIST
107799: LIST
107800: PUSH
107801: LD_INT 101
107803: PUSH
107804: LD_INT 102
107806: PUSH
107807: LD_INT 105
107809: PUSH
107810: LD_INT 106
107812: PUSH
107813: LD_INT 108
107815: PUSH
107816: LD_INT 116
107818: PUSH
107819: LD_INT 117
107821: PUSH
107822: LD_INT 118
107824: PUSH
107825: EMPTY
107826: LIST
107827: LIST
107828: LIST
107829: LIST
107830: LIST
107831: LIST
107832: LIST
107833: LIST
107834: PUSH
107835: EMPTY
107836: LIST
107837: LIST
107838: ST_TO_ADDR
107839: GO 110822
107841: LD_INT 3
107843: DOUBLE
107844: EQUAL
107845: IFTRUE 107849
107847: GO 107937
107849: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
107850: LD_ADDR_VAR 0 1
107854: PUSH
107855: LD_INT 2
107857: PUSH
107858: LD_INT 4
107860: PUSH
107861: LD_INT 5
107863: PUSH
107864: LD_INT 11
107866: PUSH
107867: LD_INT 12
107869: PUSH
107870: LD_INT 15
107872: PUSH
107873: LD_INT 16
107875: PUSH
107876: LD_INT 22
107878: PUSH
107879: LD_INT 26
107881: PUSH
107882: LD_INT 36
107884: PUSH
107885: EMPTY
107886: LIST
107887: LIST
107888: LIST
107889: LIST
107890: LIST
107891: LIST
107892: LIST
107893: LIST
107894: LIST
107895: LIST
107896: PUSH
107897: LD_INT 101
107899: PUSH
107900: LD_INT 102
107902: PUSH
107903: LD_INT 105
107905: PUSH
107906: LD_INT 106
107908: PUSH
107909: LD_INT 108
107911: PUSH
107912: LD_INT 116
107914: PUSH
107915: LD_INT 117
107917: PUSH
107918: LD_INT 118
107920: PUSH
107921: EMPTY
107922: LIST
107923: LIST
107924: LIST
107925: LIST
107926: LIST
107927: LIST
107928: LIST
107929: LIST
107930: PUSH
107931: EMPTY
107932: LIST
107933: LIST
107934: ST_TO_ADDR
107935: GO 110822
107937: LD_INT 4
107939: DOUBLE
107940: EQUAL
107941: IFTRUE 107945
107943: GO 108041
107945: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
107946: LD_ADDR_VAR 0 1
107950: PUSH
107951: LD_INT 2
107953: PUSH
107954: LD_INT 4
107956: PUSH
107957: LD_INT 5
107959: PUSH
107960: LD_INT 8
107962: PUSH
107963: LD_INT 11
107965: PUSH
107966: LD_INT 12
107968: PUSH
107969: LD_INT 15
107971: PUSH
107972: LD_INT 16
107974: PUSH
107975: LD_INT 22
107977: PUSH
107978: LD_INT 23
107980: PUSH
107981: LD_INT 26
107983: PUSH
107984: LD_INT 36
107986: PUSH
107987: EMPTY
107988: LIST
107989: LIST
107990: LIST
107991: LIST
107992: LIST
107993: LIST
107994: LIST
107995: LIST
107996: LIST
107997: LIST
107998: LIST
107999: LIST
108000: PUSH
108001: LD_INT 101
108003: PUSH
108004: LD_INT 102
108006: PUSH
108007: LD_INT 105
108009: PUSH
108010: LD_INT 106
108012: PUSH
108013: LD_INT 108
108015: PUSH
108016: LD_INT 116
108018: PUSH
108019: LD_INT 117
108021: PUSH
108022: LD_INT 118
108024: PUSH
108025: EMPTY
108026: LIST
108027: LIST
108028: LIST
108029: LIST
108030: LIST
108031: LIST
108032: LIST
108033: LIST
108034: PUSH
108035: EMPTY
108036: LIST
108037: LIST
108038: ST_TO_ADDR
108039: GO 110822
108041: LD_INT 5
108043: DOUBLE
108044: EQUAL
108045: IFTRUE 108049
108047: GO 108161
108049: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
108050: LD_ADDR_VAR 0 1
108054: PUSH
108055: LD_INT 2
108057: PUSH
108058: LD_INT 4
108060: PUSH
108061: LD_INT 5
108063: PUSH
108064: LD_INT 6
108066: PUSH
108067: LD_INT 8
108069: PUSH
108070: LD_INT 11
108072: PUSH
108073: LD_INT 12
108075: PUSH
108076: LD_INT 15
108078: PUSH
108079: LD_INT 16
108081: PUSH
108082: LD_INT 22
108084: PUSH
108085: LD_INT 23
108087: PUSH
108088: LD_INT 25
108090: PUSH
108091: LD_INT 26
108093: PUSH
108094: LD_INT 36
108096: PUSH
108097: EMPTY
108098: LIST
108099: LIST
108100: LIST
108101: LIST
108102: LIST
108103: LIST
108104: LIST
108105: LIST
108106: LIST
108107: LIST
108108: LIST
108109: LIST
108110: LIST
108111: LIST
108112: PUSH
108113: LD_INT 101
108115: PUSH
108116: LD_INT 102
108118: PUSH
108119: LD_INT 105
108121: PUSH
108122: LD_INT 106
108124: PUSH
108125: LD_INT 108
108127: PUSH
108128: LD_INT 109
108130: PUSH
108131: LD_INT 112
108133: PUSH
108134: LD_INT 116
108136: PUSH
108137: LD_INT 117
108139: PUSH
108140: LD_INT 118
108142: PUSH
108143: EMPTY
108144: LIST
108145: LIST
108146: LIST
108147: LIST
108148: LIST
108149: LIST
108150: LIST
108151: LIST
108152: LIST
108153: LIST
108154: PUSH
108155: EMPTY
108156: LIST
108157: LIST
108158: ST_TO_ADDR
108159: GO 110822
108161: LD_INT 6
108163: DOUBLE
108164: EQUAL
108165: IFTRUE 108169
108167: GO 108301
108169: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
108170: LD_ADDR_VAR 0 1
108174: PUSH
108175: LD_INT 2
108177: PUSH
108178: LD_INT 4
108180: PUSH
108181: LD_INT 5
108183: PUSH
108184: LD_INT 6
108186: PUSH
108187: LD_INT 8
108189: PUSH
108190: LD_INT 11
108192: PUSH
108193: LD_INT 12
108195: PUSH
108196: LD_INT 15
108198: PUSH
108199: LD_INT 16
108201: PUSH
108202: LD_INT 20
108204: PUSH
108205: LD_INT 21
108207: PUSH
108208: LD_INT 22
108210: PUSH
108211: LD_INT 23
108213: PUSH
108214: LD_INT 25
108216: PUSH
108217: LD_INT 26
108219: PUSH
108220: LD_INT 30
108222: PUSH
108223: LD_INT 31
108225: PUSH
108226: LD_INT 32
108228: PUSH
108229: LD_INT 36
108231: PUSH
108232: EMPTY
108233: LIST
108234: LIST
108235: LIST
108236: LIST
108237: LIST
108238: LIST
108239: LIST
108240: LIST
108241: LIST
108242: LIST
108243: LIST
108244: LIST
108245: LIST
108246: LIST
108247: LIST
108248: LIST
108249: LIST
108250: LIST
108251: LIST
108252: PUSH
108253: LD_INT 101
108255: PUSH
108256: LD_INT 102
108258: PUSH
108259: LD_INT 105
108261: PUSH
108262: LD_INT 106
108264: PUSH
108265: LD_INT 108
108267: PUSH
108268: LD_INT 109
108270: PUSH
108271: LD_INT 112
108273: PUSH
108274: LD_INT 116
108276: PUSH
108277: LD_INT 117
108279: PUSH
108280: LD_INT 118
108282: PUSH
108283: EMPTY
108284: LIST
108285: LIST
108286: LIST
108287: LIST
108288: LIST
108289: LIST
108290: LIST
108291: LIST
108292: LIST
108293: LIST
108294: PUSH
108295: EMPTY
108296: LIST
108297: LIST
108298: ST_TO_ADDR
108299: GO 110822
108301: LD_INT 7
108303: DOUBLE
108304: EQUAL
108305: IFTRUE 108309
108307: GO 108421
108309: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
108310: LD_ADDR_VAR 0 1
108314: PUSH
108315: LD_INT 2
108317: PUSH
108318: LD_INT 4
108320: PUSH
108321: LD_INT 5
108323: PUSH
108324: LD_INT 7
108326: PUSH
108327: LD_INT 11
108329: PUSH
108330: LD_INT 12
108332: PUSH
108333: LD_INT 15
108335: PUSH
108336: LD_INT 16
108338: PUSH
108339: LD_INT 20
108341: PUSH
108342: LD_INT 21
108344: PUSH
108345: LD_INT 22
108347: PUSH
108348: LD_INT 23
108350: PUSH
108351: LD_INT 25
108353: PUSH
108354: LD_INT 26
108356: PUSH
108357: EMPTY
108358: LIST
108359: LIST
108360: LIST
108361: LIST
108362: LIST
108363: LIST
108364: LIST
108365: LIST
108366: LIST
108367: LIST
108368: LIST
108369: LIST
108370: LIST
108371: LIST
108372: PUSH
108373: LD_INT 101
108375: PUSH
108376: LD_INT 102
108378: PUSH
108379: LD_INT 103
108381: PUSH
108382: LD_INT 105
108384: PUSH
108385: LD_INT 106
108387: PUSH
108388: LD_INT 108
108390: PUSH
108391: LD_INT 112
108393: PUSH
108394: LD_INT 116
108396: PUSH
108397: LD_INT 117
108399: PUSH
108400: LD_INT 118
108402: PUSH
108403: EMPTY
108404: LIST
108405: LIST
108406: LIST
108407: LIST
108408: LIST
108409: LIST
108410: LIST
108411: LIST
108412: LIST
108413: LIST
108414: PUSH
108415: EMPTY
108416: LIST
108417: LIST
108418: ST_TO_ADDR
108419: GO 110822
108421: LD_INT 8
108423: DOUBLE
108424: EQUAL
108425: IFTRUE 108429
108427: GO 108569
108429: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
108430: LD_ADDR_VAR 0 1
108434: PUSH
108435: LD_INT 2
108437: PUSH
108438: LD_INT 4
108440: PUSH
108441: LD_INT 5
108443: PUSH
108444: LD_INT 6
108446: PUSH
108447: LD_INT 7
108449: PUSH
108450: LD_INT 8
108452: PUSH
108453: LD_INT 11
108455: PUSH
108456: LD_INT 12
108458: PUSH
108459: LD_INT 15
108461: PUSH
108462: LD_INT 16
108464: PUSH
108465: LD_INT 20
108467: PUSH
108468: LD_INT 21
108470: PUSH
108471: LD_INT 22
108473: PUSH
108474: LD_INT 23
108476: PUSH
108477: LD_INT 25
108479: PUSH
108480: LD_INT 26
108482: PUSH
108483: LD_INT 30
108485: PUSH
108486: LD_INT 31
108488: PUSH
108489: LD_INT 32
108491: PUSH
108492: LD_INT 36
108494: PUSH
108495: EMPTY
108496: LIST
108497: LIST
108498: LIST
108499: LIST
108500: LIST
108501: LIST
108502: LIST
108503: LIST
108504: LIST
108505: LIST
108506: LIST
108507: LIST
108508: LIST
108509: LIST
108510: LIST
108511: LIST
108512: LIST
108513: LIST
108514: LIST
108515: LIST
108516: PUSH
108517: LD_INT 101
108519: PUSH
108520: LD_INT 102
108522: PUSH
108523: LD_INT 103
108525: PUSH
108526: LD_INT 105
108528: PUSH
108529: LD_INT 106
108531: PUSH
108532: LD_INT 108
108534: PUSH
108535: LD_INT 109
108537: PUSH
108538: LD_INT 112
108540: PUSH
108541: LD_INT 116
108543: PUSH
108544: LD_INT 117
108546: PUSH
108547: LD_INT 118
108549: PUSH
108550: EMPTY
108551: LIST
108552: LIST
108553: LIST
108554: LIST
108555: LIST
108556: LIST
108557: LIST
108558: LIST
108559: LIST
108560: LIST
108561: LIST
108562: PUSH
108563: EMPTY
108564: LIST
108565: LIST
108566: ST_TO_ADDR
108567: GO 110822
108569: LD_INT 9
108571: DOUBLE
108572: EQUAL
108573: IFTRUE 108577
108575: GO 108725
108577: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
108578: LD_ADDR_VAR 0 1
108582: PUSH
108583: LD_INT 2
108585: PUSH
108586: LD_INT 4
108588: PUSH
108589: LD_INT 5
108591: PUSH
108592: LD_INT 6
108594: PUSH
108595: LD_INT 7
108597: PUSH
108598: LD_INT 8
108600: PUSH
108601: LD_INT 11
108603: PUSH
108604: LD_INT 12
108606: PUSH
108607: LD_INT 15
108609: PUSH
108610: LD_INT 16
108612: PUSH
108613: LD_INT 20
108615: PUSH
108616: LD_INT 21
108618: PUSH
108619: LD_INT 22
108621: PUSH
108622: LD_INT 23
108624: PUSH
108625: LD_INT 25
108627: PUSH
108628: LD_INT 26
108630: PUSH
108631: LD_INT 28
108633: PUSH
108634: LD_INT 30
108636: PUSH
108637: LD_INT 31
108639: PUSH
108640: LD_INT 32
108642: PUSH
108643: LD_INT 36
108645: PUSH
108646: EMPTY
108647: LIST
108648: LIST
108649: LIST
108650: LIST
108651: LIST
108652: LIST
108653: LIST
108654: LIST
108655: LIST
108656: LIST
108657: LIST
108658: LIST
108659: LIST
108660: LIST
108661: LIST
108662: LIST
108663: LIST
108664: LIST
108665: LIST
108666: LIST
108667: LIST
108668: PUSH
108669: LD_INT 101
108671: PUSH
108672: LD_INT 102
108674: PUSH
108675: LD_INT 103
108677: PUSH
108678: LD_INT 105
108680: PUSH
108681: LD_INT 106
108683: PUSH
108684: LD_INT 108
108686: PUSH
108687: LD_INT 109
108689: PUSH
108690: LD_INT 112
108692: PUSH
108693: LD_INT 114
108695: PUSH
108696: LD_INT 116
108698: PUSH
108699: LD_INT 117
108701: PUSH
108702: LD_INT 118
108704: PUSH
108705: EMPTY
108706: LIST
108707: LIST
108708: LIST
108709: LIST
108710: LIST
108711: LIST
108712: LIST
108713: LIST
108714: LIST
108715: LIST
108716: LIST
108717: LIST
108718: PUSH
108719: EMPTY
108720: LIST
108721: LIST
108722: ST_TO_ADDR
108723: GO 110822
108725: LD_INT 10
108727: DOUBLE
108728: EQUAL
108729: IFTRUE 108733
108731: GO 108929
108733: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
108734: LD_ADDR_VAR 0 1
108738: PUSH
108739: LD_INT 2
108741: PUSH
108742: LD_INT 4
108744: PUSH
108745: LD_INT 5
108747: PUSH
108748: LD_INT 6
108750: PUSH
108751: LD_INT 7
108753: PUSH
108754: LD_INT 8
108756: PUSH
108757: LD_INT 9
108759: PUSH
108760: LD_INT 10
108762: PUSH
108763: LD_INT 11
108765: PUSH
108766: LD_INT 12
108768: PUSH
108769: LD_INT 13
108771: PUSH
108772: LD_INT 14
108774: PUSH
108775: LD_INT 15
108777: PUSH
108778: LD_INT 16
108780: PUSH
108781: LD_INT 17
108783: PUSH
108784: LD_INT 18
108786: PUSH
108787: LD_INT 19
108789: PUSH
108790: LD_INT 20
108792: PUSH
108793: LD_INT 21
108795: PUSH
108796: LD_INT 22
108798: PUSH
108799: LD_INT 23
108801: PUSH
108802: LD_INT 24
108804: PUSH
108805: LD_INT 25
108807: PUSH
108808: LD_INT 26
108810: PUSH
108811: LD_INT 28
108813: PUSH
108814: LD_INT 30
108816: PUSH
108817: LD_INT 31
108819: PUSH
108820: LD_INT 32
108822: PUSH
108823: LD_INT 36
108825: PUSH
108826: EMPTY
108827: LIST
108828: LIST
108829: LIST
108830: LIST
108831: LIST
108832: LIST
108833: LIST
108834: LIST
108835: LIST
108836: LIST
108837: LIST
108838: LIST
108839: LIST
108840: LIST
108841: LIST
108842: LIST
108843: LIST
108844: LIST
108845: LIST
108846: LIST
108847: LIST
108848: LIST
108849: LIST
108850: LIST
108851: LIST
108852: LIST
108853: LIST
108854: LIST
108855: LIST
108856: PUSH
108857: LD_INT 101
108859: PUSH
108860: LD_INT 102
108862: PUSH
108863: LD_INT 103
108865: PUSH
108866: LD_INT 104
108868: PUSH
108869: LD_INT 105
108871: PUSH
108872: LD_INT 106
108874: PUSH
108875: LD_INT 107
108877: PUSH
108878: LD_INT 108
108880: PUSH
108881: LD_INT 109
108883: PUSH
108884: LD_INT 110
108886: PUSH
108887: LD_INT 111
108889: PUSH
108890: LD_INT 112
108892: PUSH
108893: LD_INT 114
108895: PUSH
108896: LD_INT 116
108898: PUSH
108899: LD_INT 117
108901: PUSH
108902: LD_INT 118
108904: PUSH
108905: EMPTY
108906: LIST
108907: LIST
108908: LIST
108909: LIST
108910: LIST
108911: LIST
108912: LIST
108913: LIST
108914: LIST
108915: LIST
108916: LIST
108917: LIST
108918: LIST
108919: LIST
108920: LIST
108921: LIST
108922: PUSH
108923: EMPTY
108924: LIST
108925: LIST
108926: ST_TO_ADDR
108927: GO 110822
108929: LD_INT 11
108931: DOUBLE
108932: EQUAL
108933: IFTRUE 108937
108935: GO 109141
108937: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
108938: LD_ADDR_VAR 0 1
108942: PUSH
108943: LD_INT 2
108945: PUSH
108946: LD_INT 3
108948: PUSH
108949: LD_INT 4
108951: PUSH
108952: LD_INT 5
108954: PUSH
108955: LD_INT 6
108957: PUSH
108958: LD_INT 7
108960: PUSH
108961: LD_INT 8
108963: PUSH
108964: LD_INT 9
108966: PUSH
108967: LD_INT 10
108969: PUSH
108970: LD_INT 11
108972: PUSH
108973: LD_INT 12
108975: PUSH
108976: LD_INT 13
108978: PUSH
108979: LD_INT 14
108981: PUSH
108982: LD_INT 15
108984: PUSH
108985: LD_INT 16
108987: PUSH
108988: LD_INT 17
108990: PUSH
108991: LD_INT 18
108993: PUSH
108994: LD_INT 19
108996: PUSH
108997: LD_INT 20
108999: PUSH
109000: LD_INT 21
109002: PUSH
109003: LD_INT 22
109005: PUSH
109006: LD_INT 23
109008: PUSH
109009: LD_INT 24
109011: PUSH
109012: LD_INT 25
109014: PUSH
109015: LD_INT 26
109017: PUSH
109018: LD_INT 28
109020: PUSH
109021: LD_INT 30
109023: PUSH
109024: LD_INT 31
109026: PUSH
109027: LD_INT 32
109029: PUSH
109030: LD_INT 34
109032: PUSH
109033: LD_INT 36
109035: PUSH
109036: EMPTY
109037: LIST
109038: LIST
109039: LIST
109040: LIST
109041: LIST
109042: LIST
109043: LIST
109044: LIST
109045: LIST
109046: LIST
109047: LIST
109048: LIST
109049: LIST
109050: LIST
109051: LIST
109052: LIST
109053: LIST
109054: LIST
109055: LIST
109056: LIST
109057: LIST
109058: LIST
109059: LIST
109060: LIST
109061: LIST
109062: LIST
109063: LIST
109064: LIST
109065: LIST
109066: LIST
109067: LIST
109068: PUSH
109069: LD_INT 101
109071: PUSH
109072: LD_INT 102
109074: PUSH
109075: LD_INT 103
109077: PUSH
109078: LD_INT 104
109080: PUSH
109081: LD_INT 105
109083: PUSH
109084: LD_INT 106
109086: PUSH
109087: LD_INT 107
109089: PUSH
109090: LD_INT 108
109092: PUSH
109093: LD_INT 109
109095: PUSH
109096: LD_INT 110
109098: PUSH
109099: LD_INT 111
109101: PUSH
109102: LD_INT 112
109104: PUSH
109105: LD_INT 114
109107: PUSH
109108: LD_INT 116
109110: PUSH
109111: LD_INT 117
109113: PUSH
109114: LD_INT 118
109116: PUSH
109117: EMPTY
109118: LIST
109119: LIST
109120: LIST
109121: LIST
109122: LIST
109123: LIST
109124: LIST
109125: LIST
109126: LIST
109127: LIST
109128: LIST
109129: LIST
109130: LIST
109131: LIST
109132: LIST
109133: LIST
109134: PUSH
109135: EMPTY
109136: LIST
109137: LIST
109138: ST_TO_ADDR
109139: GO 110822
109141: LD_INT 12
109143: DOUBLE
109144: EQUAL
109145: IFTRUE 109149
109147: GO 109369
109149: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
109150: LD_ADDR_VAR 0 1
109154: PUSH
109155: LD_INT 1
109157: PUSH
109158: LD_INT 2
109160: PUSH
109161: LD_INT 3
109163: PUSH
109164: LD_INT 4
109166: PUSH
109167: LD_INT 5
109169: PUSH
109170: LD_INT 6
109172: PUSH
109173: LD_INT 7
109175: PUSH
109176: LD_INT 8
109178: PUSH
109179: LD_INT 9
109181: PUSH
109182: LD_INT 10
109184: PUSH
109185: LD_INT 11
109187: PUSH
109188: LD_INT 12
109190: PUSH
109191: LD_INT 13
109193: PUSH
109194: LD_INT 14
109196: PUSH
109197: LD_INT 15
109199: PUSH
109200: LD_INT 16
109202: PUSH
109203: LD_INT 17
109205: PUSH
109206: LD_INT 18
109208: PUSH
109209: LD_INT 19
109211: PUSH
109212: LD_INT 20
109214: PUSH
109215: LD_INT 21
109217: PUSH
109218: LD_INT 22
109220: PUSH
109221: LD_INT 23
109223: PUSH
109224: LD_INT 24
109226: PUSH
109227: LD_INT 25
109229: PUSH
109230: LD_INT 26
109232: PUSH
109233: LD_INT 27
109235: PUSH
109236: LD_INT 28
109238: PUSH
109239: LD_INT 30
109241: PUSH
109242: LD_INT 31
109244: PUSH
109245: LD_INT 32
109247: PUSH
109248: LD_INT 33
109250: PUSH
109251: LD_INT 34
109253: PUSH
109254: LD_INT 36
109256: PUSH
109257: EMPTY
109258: LIST
109259: LIST
109260: LIST
109261: LIST
109262: LIST
109263: LIST
109264: LIST
109265: LIST
109266: LIST
109267: LIST
109268: LIST
109269: LIST
109270: LIST
109271: LIST
109272: LIST
109273: LIST
109274: LIST
109275: LIST
109276: LIST
109277: LIST
109278: LIST
109279: LIST
109280: LIST
109281: LIST
109282: LIST
109283: LIST
109284: LIST
109285: LIST
109286: LIST
109287: LIST
109288: LIST
109289: LIST
109290: LIST
109291: LIST
109292: PUSH
109293: LD_INT 101
109295: PUSH
109296: LD_INT 102
109298: PUSH
109299: LD_INT 103
109301: PUSH
109302: LD_INT 104
109304: PUSH
109305: LD_INT 105
109307: PUSH
109308: LD_INT 106
109310: PUSH
109311: LD_INT 107
109313: PUSH
109314: LD_INT 108
109316: PUSH
109317: LD_INT 109
109319: PUSH
109320: LD_INT 110
109322: PUSH
109323: LD_INT 111
109325: PUSH
109326: LD_INT 112
109328: PUSH
109329: LD_INT 113
109331: PUSH
109332: LD_INT 114
109334: PUSH
109335: LD_INT 116
109337: PUSH
109338: LD_INT 117
109340: PUSH
109341: LD_INT 118
109343: PUSH
109344: EMPTY
109345: LIST
109346: LIST
109347: LIST
109348: LIST
109349: LIST
109350: LIST
109351: LIST
109352: LIST
109353: LIST
109354: LIST
109355: LIST
109356: LIST
109357: LIST
109358: LIST
109359: LIST
109360: LIST
109361: LIST
109362: PUSH
109363: EMPTY
109364: LIST
109365: LIST
109366: ST_TO_ADDR
109367: GO 110822
109369: LD_INT 13
109371: DOUBLE
109372: EQUAL
109373: IFTRUE 109377
109375: GO 109585
109377: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
109378: LD_ADDR_VAR 0 1
109382: PUSH
109383: LD_INT 1
109385: PUSH
109386: LD_INT 2
109388: PUSH
109389: LD_INT 3
109391: PUSH
109392: LD_INT 4
109394: PUSH
109395: LD_INT 5
109397: PUSH
109398: LD_INT 8
109400: PUSH
109401: LD_INT 9
109403: PUSH
109404: LD_INT 10
109406: PUSH
109407: LD_INT 11
109409: PUSH
109410: LD_INT 12
109412: PUSH
109413: LD_INT 14
109415: PUSH
109416: LD_INT 15
109418: PUSH
109419: LD_INT 16
109421: PUSH
109422: LD_INT 17
109424: PUSH
109425: LD_INT 18
109427: PUSH
109428: LD_INT 19
109430: PUSH
109431: LD_INT 20
109433: PUSH
109434: LD_INT 21
109436: PUSH
109437: LD_INT 22
109439: PUSH
109440: LD_INT 23
109442: PUSH
109443: LD_INT 24
109445: PUSH
109446: LD_INT 25
109448: PUSH
109449: LD_INT 26
109451: PUSH
109452: LD_INT 27
109454: PUSH
109455: LD_INT 28
109457: PUSH
109458: LD_INT 30
109460: PUSH
109461: LD_INT 31
109463: PUSH
109464: LD_INT 32
109466: PUSH
109467: LD_INT 33
109469: PUSH
109470: LD_INT 34
109472: PUSH
109473: LD_INT 36
109475: PUSH
109476: EMPTY
109477: LIST
109478: LIST
109479: LIST
109480: LIST
109481: LIST
109482: LIST
109483: LIST
109484: LIST
109485: LIST
109486: LIST
109487: LIST
109488: LIST
109489: LIST
109490: LIST
109491: LIST
109492: LIST
109493: LIST
109494: LIST
109495: LIST
109496: LIST
109497: LIST
109498: LIST
109499: LIST
109500: LIST
109501: LIST
109502: LIST
109503: LIST
109504: LIST
109505: LIST
109506: LIST
109507: LIST
109508: PUSH
109509: LD_INT 101
109511: PUSH
109512: LD_INT 102
109514: PUSH
109515: LD_INT 103
109517: PUSH
109518: LD_INT 104
109520: PUSH
109521: LD_INT 105
109523: PUSH
109524: LD_INT 106
109526: PUSH
109527: LD_INT 107
109529: PUSH
109530: LD_INT 108
109532: PUSH
109533: LD_INT 109
109535: PUSH
109536: LD_INT 110
109538: PUSH
109539: LD_INT 111
109541: PUSH
109542: LD_INT 112
109544: PUSH
109545: LD_INT 113
109547: PUSH
109548: LD_INT 114
109550: PUSH
109551: LD_INT 116
109553: PUSH
109554: LD_INT 117
109556: PUSH
109557: LD_INT 118
109559: PUSH
109560: EMPTY
109561: LIST
109562: LIST
109563: LIST
109564: LIST
109565: LIST
109566: LIST
109567: LIST
109568: LIST
109569: LIST
109570: LIST
109571: LIST
109572: LIST
109573: LIST
109574: LIST
109575: LIST
109576: LIST
109577: LIST
109578: PUSH
109579: EMPTY
109580: LIST
109581: LIST
109582: ST_TO_ADDR
109583: GO 110822
109585: LD_INT 14
109587: DOUBLE
109588: EQUAL
109589: IFTRUE 109593
109591: GO 109817
109593: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
109594: LD_ADDR_VAR 0 1
109598: PUSH
109599: LD_INT 1
109601: PUSH
109602: LD_INT 2
109604: PUSH
109605: LD_INT 3
109607: PUSH
109608: LD_INT 4
109610: PUSH
109611: LD_INT 5
109613: PUSH
109614: LD_INT 6
109616: PUSH
109617: LD_INT 7
109619: PUSH
109620: LD_INT 8
109622: PUSH
109623: LD_INT 9
109625: PUSH
109626: LD_INT 10
109628: PUSH
109629: LD_INT 11
109631: PUSH
109632: LD_INT 12
109634: PUSH
109635: LD_INT 13
109637: PUSH
109638: LD_INT 14
109640: PUSH
109641: LD_INT 15
109643: PUSH
109644: LD_INT 16
109646: PUSH
109647: LD_INT 17
109649: PUSH
109650: LD_INT 18
109652: PUSH
109653: LD_INT 19
109655: PUSH
109656: LD_INT 20
109658: PUSH
109659: LD_INT 21
109661: PUSH
109662: LD_INT 22
109664: PUSH
109665: LD_INT 23
109667: PUSH
109668: LD_INT 24
109670: PUSH
109671: LD_INT 25
109673: PUSH
109674: LD_INT 26
109676: PUSH
109677: LD_INT 27
109679: PUSH
109680: LD_INT 28
109682: PUSH
109683: LD_INT 29
109685: PUSH
109686: LD_INT 30
109688: PUSH
109689: LD_INT 31
109691: PUSH
109692: LD_INT 32
109694: PUSH
109695: LD_INT 33
109697: PUSH
109698: LD_INT 34
109700: PUSH
109701: LD_INT 36
109703: PUSH
109704: EMPTY
109705: LIST
109706: LIST
109707: LIST
109708: LIST
109709: LIST
109710: LIST
109711: LIST
109712: LIST
109713: LIST
109714: LIST
109715: LIST
109716: LIST
109717: LIST
109718: LIST
109719: LIST
109720: LIST
109721: LIST
109722: LIST
109723: LIST
109724: LIST
109725: LIST
109726: LIST
109727: LIST
109728: LIST
109729: LIST
109730: LIST
109731: LIST
109732: LIST
109733: LIST
109734: LIST
109735: LIST
109736: LIST
109737: LIST
109738: LIST
109739: LIST
109740: PUSH
109741: LD_INT 101
109743: PUSH
109744: LD_INT 102
109746: PUSH
109747: LD_INT 103
109749: PUSH
109750: LD_INT 104
109752: PUSH
109753: LD_INT 105
109755: PUSH
109756: LD_INT 106
109758: PUSH
109759: LD_INT 107
109761: PUSH
109762: LD_INT 108
109764: PUSH
109765: LD_INT 109
109767: PUSH
109768: LD_INT 110
109770: PUSH
109771: LD_INT 111
109773: PUSH
109774: LD_INT 112
109776: PUSH
109777: LD_INT 113
109779: PUSH
109780: LD_INT 114
109782: PUSH
109783: LD_INT 116
109785: PUSH
109786: LD_INT 117
109788: PUSH
109789: LD_INT 118
109791: PUSH
109792: EMPTY
109793: LIST
109794: LIST
109795: LIST
109796: LIST
109797: LIST
109798: LIST
109799: LIST
109800: LIST
109801: LIST
109802: LIST
109803: LIST
109804: LIST
109805: LIST
109806: LIST
109807: LIST
109808: LIST
109809: LIST
109810: PUSH
109811: EMPTY
109812: LIST
109813: LIST
109814: ST_TO_ADDR
109815: GO 110822
109817: LD_INT 15
109819: DOUBLE
109820: EQUAL
109821: IFTRUE 109825
109823: GO 110049
109825: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
109826: LD_ADDR_VAR 0 1
109830: PUSH
109831: LD_INT 1
109833: PUSH
109834: LD_INT 2
109836: PUSH
109837: LD_INT 3
109839: PUSH
109840: LD_INT 4
109842: PUSH
109843: LD_INT 5
109845: PUSH
109846: LD_INT 6
109848: PUSH
109849: LD_INT 7
109851: PUSH
109852: LD_INT 8
109854: PUSH
109855: LD_INT 9
109857: PUSH
109858: LD_INT 10
109860: PUSH
109861: LD_INT 11
109863: PUSH
109864: LD_INT 12
109866: PUSH
109867: LD_INT 13
109869: PUSH
109870: LD_INT 14
109872: PUSH
109873: LD_INT 15
109875: PUSH
109876: LD_INT 16
109878: PUSH
109879: LD_INT 17
109881: PUSH
109882: LD_INT 18
109884: PUSH
109885: LD_INT 19
109887: PUSH
109888: LD_INT 20
109890: PUSH
109891: LD_INT 21
109893: PUSH
109894: LD_INT 22
109896: PUSH
109897: LD_INT 23
109899: PUSH
109900: LD_INT 24
109902: PUSH
109903: LD_INT 25
109905: PUSH
109906: LD_INT 26
109908: PUSH
109909: LD_INT 27
109911: PUSH
109912: LD_INT 28
109914: PUSH
109915: LD_INT 29
109917: PUSH
109918: LD_INT 30
109920: PUSH
109921: LD_INT 31
109923: PUSH
109924: LD_INT 32
109926: PUSH
109927: LD_INT 33
109929: PUSH
109930: LD_INT 34
109932: PUSH
109933: LD_INT 36
109935: PUSH
109936: EMPTY
109937: LIST
109938: LIST
109939: LIST
109940: LIST
109941: LIST
109942: LIST
109943: LIST
109944: LIST
109945: LIST
109946: LIST
109947: LIST
109948: LIST
109949: LIST
109950: LIST
109951: LIST
109952: LIST
109953: LIST
109954: LIST
109955: LIST
109956: LIST
109957: LIST
109958: LIST
109959: LIST
109960: LIST
109961: LIST
109962: LIST
109963: LIST
109964: LIST
109965: LIST
109966: LIST
109967: LIST
109968: LIST
109969: LIST
109970: LIST
109971: LIST
109972: PUSH
109973: LD_INT 101
109975: PUSH
109976: LD_INT 102
109978: PUSH
109979: LD_INT 103
109981: PUSH
109982: LD_INT 104
109984: PUSH
109985: LD_INT 105
109987: PUSH
109988: LD_INT 106
109990: PUSH
109991: LD_INT 107
109993: PUSH
109994: LD_INT 108
109996: PUSH
109997: LD_INT 109
109999: PUSH
110000: LD_INT 110
110002: PUSH
110003: LD_INT 111
110005: PUSH
110006: LD_INT 112
110008: PUSH
110009: LD_INT 113
110011: PUSH
110012: LD_INT 114
110014: PUSH
110015: LD_INT 116
110017: PUSH
110018: LD_INT 117
110020: PUSH
110021: LD_INT 118
110023: PUSH
110024: EMPTY
110025: LIST
110026: LIST
110027: LIST
110028: LIST
110029: LIST
110030: LIST
110031: LIST
110032: LIST
110033: LIST
110034: LIST
110035: LIST
110036: LIST
110037: LIST
110038: LIST
110039: LIST
110040: LIST
110041: LIST
110042: PUSH
110043: EMPTY
110044: LIST
110045: LIST
110046: ST_TO_ADDR
110047: GO 110822
110049: LD_INT 16
110051: DOUBLE
110052: EQUAL
110053: IFTRUE 110057
110055: GO 110193
110057: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
110058: LD_ADDR_VAR 0 1
110062: PUSH
110063: LD_INT 2
110065: PUSH
110066: LD_INT 4
110068: PUSH
110069: LD_INT 5
110071: PUSH
110072: LD_INT 7
110074: PUSH
110075: LD_INT 11
110077: PUSH
110078: LD_INT 12
110080: PUSH
110081: LD_INT 15
110083: PUSH
110084: LD_INT 16
110086: PUSH
110087: LD_INT 20
110089: PUSH
110090: LD_INT 21
110092: PUSH
110093: LD_INT 22
110095: PUSH
110096: LD_INT 23
110098: PUSH
110099: LD_INT 25
110101: PUSH
110102: LD_INT 26
110104: PUSH
110105: LD_INT 30
110107: PUSH
110108: LD_INT 31
110110: PUSH
110111: LD_INT 32
110113: PUSH
110114: LD_INT 33
110116: PUSH
110117: LD_INT 34
110119: PUSH
110120: EMPTY
110121: LIST
110122: LIST
110123: LIST
110124: LIST
110125: LIST
110126: LIST
110127: LIST
110128: LIST
110129: LIST
110130: LIST
110131: LIST
110132: LIST
110133: LIST
110134: LIST
110135: LIST
110136: LIST
110137: LIST
110138: LIST
110139: LIST
110140: PUSH
110141: LD_INT 101
110143: PUSH
110144: LD_INT 102
110146: PUSH
110147: LD_INT 103
110149: PUSH
110150: LD_INT 106
110152: PUSH
110153: LD_INT 108
110155: PUSH
110156: LD_INT 112
110158: PUSH
110159: LD_INT 113
110161: PUSH
110162: LD_INT 114
110164: PUSH
110165: LD_INT 116
110167: PUSH
110168: LD_INT 117
110170: PUSH
110171: LD_INT 118
110173: PUSH
110174: EMPTY
110175: LIST
110176: LIST
110177: LIST
110178: LIST
110179: LIST
110180: LIST
110181: LIST
110182: LIST
110183: LIST
110184: LIST
110185: LIST
110186: PUSH
110187: EMPTY
110188: LIST
110189: LIST
110190: ST_TO_ADDR
110191: GO 110822
110193: LD_INT 17
110195: DOUBLE
110196: EQUAL
110197: IFTRUE 110201
110199: GO 110425
110201: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
110202: LD_ADDR_VAR 0 1
110206: PUSH
110207: LD_INT 1
110209: PUSH
110210: LD_INT 2
110212: PUSH
110213: LD_INT 3
110215: PUSH
110216: LD_INT 4
110218: PUSH
110219: LD_INT 5
110221: PUSH
110222: LD_INT 6
110224: PUSH
110225: LD_INT 7
110227: PUSH
110228: LD_INT 8
110230: PUSH
110231: LD_INT 9
110233: PUSH
110234: LD_INT 10
110236: PUSH
110237: LD_INT 11
110239: PUSH
110240: LD_INT 12
110242: PUSH
110243: LD_INT 13
110245: PUSH
110246: LD_INT 14
110248: PUSH
110249: LD_INT 15
110251: PUSH
110252: LD_INT 16
110254: PUSH
110255: LD_INT 17
110257: PUSH
110258: LD_INT 18
110260: PUSH
110261: LD_INT 19
110263: PUSH
110264: LD_INT 20
110266: PUSH
110267: LD_INT 21
110269: PUSH
110270: LD_INT 22
110272: PUSH
110273: LD_INT 23
110275: PUSH
110276: LD_INT 24
110278: PUSH
110279: LD_INT 25
110281: PUSH
110282: LD_INT 26
110284: PUSH
110285: LD_INT 27
110287: PUSH
110288: LD_INT 28
110290: PUSH
110291: LD_INT 29
110293: PUSH
110294: LD_INT 30
110296: PUSH
110297: LD_INT 31
110299: PUSH
110300: LD_INT 32
110302: PUSH
110303: LD_INT 33
110305: PUSH
110306: LD_INT 34
110308: PUSH
110309: LD_INT 36
110311: PUSH
110312: EMPTY
110313: LIST
110314: LIST
110315: LIST
110316: LIST
110317: LIST
110318: LIST
110319: LIST
110320: LIST
110321: LIST
110322: LIST
110323: LIST
110324: LIST
110325: LIST
110326: LIST
110327: LIST
110328: LIST
110329: LIST
110330: LIST
110331: LIST
110332: LIST
110333: LIST
110334: LIST
110335: LIST
110336: LIST
110337: LIST
110338: LIST
110339: LIST
110340: LIST
110341: LIST
110342: LIST
110343: LIST
110344: LIST
110345: LIST
110346: LIST
110347: LIST
110348: PUSH
110349: LD_INT 101
110351: PUSH
110352: LD_INT 102
110354: PUSH
110355: LD_INT 103
110357: PUSH
110358: LD_INT 104
110360: PUSH
110361: LD_INT 105
110363: PUSH
110364: LD_INT 106
110366: PUSH
110367: LD_INT 107
110369: PUSH
110370: LD_INT 108
110372: PUSH
110373: LD_INT 109
110375: PUSH
110376: LD_INT 110
110378: PUSH
110379: LD_INT 111
110381: PUSH
110382: LD_INT 112
110384: PUSH
110385: LD_INT 113
110387: PUSH
110388: LD_INT 114
110390: PUSH
110391: LD_INT 116
110393: PUSH
110394: LD_INT 117
110396: PUSH
110397: LD_INT 118
110399: PUSH
110400: EMPTY
110401: LIST
110402: LIST
110403: LIST
110404: LIST
110405: LIST
110406: LIST
110407: LIST
110408: LIST
110409: LIST
110410: LIST
110411: LIST
110412: LIST
110413: LIST
110414: LIST
110415: LIST
110416: LIST
110417: LIST
110418: PUSH
110419: EMPTY
110420: LIST
110421: LIST
110422: ST_TO_ADDR
110423: GO 110822
110425: LD_INT 18
110427: DOUBLE
110428: EQUAL
110429: IFTRUE 110433
110431: GO 110581
110433: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
110434: LD_ADDR_VAR 0 1
110438: PUSH
110439: LD_INT 2
110441: PUSH
110442: LD_INT 4
110444: PUSH
110445: LD_INT 5
110447: PUSH
110448: LD_INT 7
110450: PUSH
110451: LD_INT 11
110453: PUSH
110454: LD_INT 12
110456: PUSH
110457: LD_INT 15
110459: PUSH
110460: LD_INT 16
110462: PUSH
110463: LD_INT 20
110465: PUSH
110466: LD_INT 21
110468: PUSH
110469: LD_INT 22
110471: PUSH
110472: LD_INT 23
110474: PUSH
110475: LD_INT 25
110477: PUSH
110478: LD_INT 26
110480: PUSH
110481: LD_INT 30
110483: PUSH
110484: LD_INT 31
110486: PUSH
110487: LD_INT 32
110489: PUSH
110490: LD_INT 33
110492: PUSH
110493: LD_INT 34
110495: PUSH
110496: LD_INT 35
110498: PUSH
110499: LD_INT 36
110501: PUSH
110502: EMPTY
110503: LIST
110504: LIST
110505: LIST
110506: LIST
110507: LIST
110508: LIST
110509: LIST
110510: LIST
110511: LIST
110512: LIST
110513: LIST
110514: LIST
110515: LIST
110516: LIST
110517: LIST
110518: LIST
110519: LIST
110520: LIST
110521: LIST
110522: LIST
110523: LIST
110524: PUSH
110525: LD_INT 101
110527: PUSH
110528: LD_INT 102
110530: PUSH
110531: LD_INT 103
110533: PUSH
110534: LD_INT 106
110536: PUSH
110537: LD_INT 108
110539: PUSH
110540: LD_INT 112
110542: PUSH
110543: LD_INT 113
110545: PUSH
110546: LD_INT 114
110548: PUSH
110549: LD_INT 115
110551: PUSH
110552: LD_INT 116
110554: PUSH
110555: LD_INT 117
110557: PUSH
110558: LD_INT 118
110560: PUSH
110561: EMPTY
110562: LIST
110563: LIST
110564: LIST
110565: LIST
110566: LIST
110567: LIST
110568: LIST
110569: LIST
110570: LIST
110571: LIST
110572: LIST
110573: LIST
110574: PUSH
110575: EMPTY
110576: LIST
110577: LIST
110578: ST_TO_ADDR
110579: GO 110822
110581: LD_INT 19
110583: DOUBLE
110584: EQUAL
110585: IFTRUE 110589
110587: GO 110821
110589: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
110590: LD_ADDR_VAR 0 1
110594: PUSH
110595: LD_INT 1
110597: PUSH
110598: LD_INT 2
110600: PUSH
110601: LD_INT 3
110603: PUSH
110604: LD_INT 4
110606: PUSH
110607: LD_INT 5
110609: PUSH
110610: LD_INT 6
110612: PUSH
110613: LD_INT 7
110615: PUSH
110616: LD_INT 8
110618: PUSH
110619: LD_INT 9
110621: PUSH
110622: LD_INT 10
110624: PUSH
110625: LD_INT 11
110627: PUSH
110628: LD_INT 12
110630: PUSH
110631: LD_INT 13
110633: PUSH
110634: LD_INT 14
110636: PUSH
110637: LD_INT 15
110639: PUSH
110640: LD_INT 16
110642: PUSH
110643: LD_INT 17
110645: PUSH
110646: LD_INT 18
110648: PUSH
110649: LD_INT 19
110651: PUSH
110652: LD_INT 20
110654: PUSH
110655: LD_INT 21
110657: PUSH
110658: LD_INT 22
110660: PUSH
110661: LD_INT 23
110663: PUSH
110664: LD_INT 24
110666: PUSH
110667: LD_INT 25
110669: PUSH
110670: LD_INT 26
110672: PUSH
110673: LD_INT 27
110675: PUSH
110676: LD_INT 28
110678: PUSH
110679: LD_INT 29
110681: PUSH
110682: LD_INT 30
110684: PUSH
110685: LD_INT 31
110687: PUSH
110688: LD_INT 32
110690: PUSH
110691: LD_INT 33
110693: PUSH
110694: LD_INT 34
110696: PUSH
110697: LD_INT 35
110699: PUSH
110700: LD_INT 36
110702: PUSH
110703: EMPTY
110704: LIST
110705: LIST
110706: LIST
110707: LIST
110708: LIST
110709: LIST
110710: LIST
110711: LIST
110712: LIST
110713: LIST
110714: LIST
110715: LIST
110716: LIST
110717: LIST
110718: LIST
110719: LIST
110720: LIST
110721: LIST
110722: LIST
110723: LIST
110724: LIST
110725: LIST
110726: LIST
110727: LIST
110728: LIST
110729: LIST
110730: LIST
110731: LIST
110732: LIST
110733: LIST
110734: LIST
110735: LIST
110736: LIST
110737: LIST
110738: LIST
110739: LIST
110740: PUSH
110741: LD_INT 101
110743: PUSH
110744: LD_INT 102
110746: PUSH
110747: LD_INT 103
110749: PUSH
110750: LD_INT 104
110752: PUSH
110753: LD_INT 105
110755: PUSH
110756: LD_INT 106
110758: PUSH
110759: LD_INT 107
110761: PUSH
110762: LD_INT 108
110764: PUSH
110765: LD_INT 109
110767: PUSH
110768: LD_INT 110
110770: PUSH
110771: LD_INT 111
110773: PUSH
110774: LD_INT 112
110776: PUSH
110777: LD_INT 113
110779: PUSH
110780: LD_INT 114
110782: PUSH
110783: LD_INT 115
110785: PUSH
110786: LD_INT 116
110788: PUSH
110789: LD_INT 117
110791: PUSH
110792: LD_INT 118
110794: PUSH
110795: EMPTY
110796: LIST
110797: LIST
110798: LIST
110799: LIST
110800: LIST
110801: LIST
110802: LIST
110803: LIST
110804: LIST
110805: LIST
110806: LIST
110807: LIST
110808: LIST
110809: LIST
110810: LIST
110811: LIST
110812: LIST
110813: LIST
110814: PUSH
110815: EMPTY
110816: LIST
110817: LIST
110818: ST_TO_ADDR
110819: GO 110822
110821: POP
// end else
110822: GO 111053
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
110824: LD_ADDR_VAR 0 1
110828: PUSH
110829: LD_INT 1
110831: PUSH
110832: LD_INT 2
110834: PUSH
110835: LD_INT 3
110837: PUSH
110838: LD_INT 4
110840: PUSH
110841: LD_INT 5
110843: PUSH
110844: LD_INT 6
110846: PUSH
110847: LD_INT 7
110849: PUSH
110850: LD_INT 8
110852: PUSH
110853: LD_INT 9
110855: PUSH
110856: LD_INT 10
110858: PUSH
110859: LD_INT 11
110861: PUSH
110862: LD_INT 12
110864: PUSH
110865: LD_INT 13
110867: PUSH
110868: LD_INT 14
110870: PUSH
110871: LD_INT 15
110873: PUSH
110874: LD_INT 16
110876: PUSH
110877: LD_INT 17
110879: PUSH
110880: LD_INT 18
110882: PUSH
110883: LD_INT 19
110885: PUSH
110886: LD_INT 20
110888: PUSH
110889: LD_INT 21
110891: PUSH
110892: LD_INT 22
110894: PUSH
110895: LD_INT 23
110897: PUSH
110898: LD_INT 24
110900: PUSH
110901: LD_INT 25
110903: PUSH
110904: LD_INT 26
110906: PUSH
110907: LD_INT 27
110909: PUSH
110910: LD_INT 28
110912: PUSH
110913: LD_INT 29
110915: PUSH
110916: LD_INT 30
110918: PUSH
110919: LD_INT 31
110921: PUSH
110922: LD_INT 32
110924: PUSH
110925: LD_INT 33
110927: PUSH
110928: LD_INT 34
110930: PUSH
110931: LD_INT 35
110933: PUSH
110934: LD_INT 36
110936: PUSH
110937: EMPTY
110938: LIST
110939: LIST
110940: LIST
110941: LIST
110942: LIST
110943: LIST
110944: LIST
110945: LIST
110946: LIST
110947: LIST
110948: LIST
110949: LIST
110950: LIST
110951: LIST
110952: LIST
110953: LIST
110954: LIST
110955: LIST
110956: LIST
110957: LIST
110958: LIST
110959: LIST
110960: LIST
110961: LIST
110962: LIST
110963: LIST
110964: LIST
110965: LIST
110966: LIST
110967: LIST
110968: LIST
110969: LIST
110970: LIST
110971: LIST
110972: LIST
110973: LIST
110974: PUSH
110975: LD_INT 101
110977: PUSH
110978: LD_INT 102
110980: PUSH
110981: LD_INT 103
110983: PUSH
110984: LD_INT 104
110986: PUSH
110987: LD_INT 105
110989: PUSH
110990: LD_INT 106
110992: PUSH
110993: LD_INT 107
110995: PUSH
110996: LD_INT 108
110998: PUSH
110999: LD_INT 109
111001: PUSH
111002: LD_INT 110
111004: PUSH
111005: LD_INT 111
111007: PUSH
111008: LD_INT 112
111010: PUSH
111011: LD_INT 113
111013: PUSH
111014: LD_INT 114
111016: PUSH
111017: LD_INT 115
111019: PUSH
111020: LD_INT 116
111022: PUSH
111023: LD_INT 117
111025: PUSH
111026: LD_INT 118
111028: PUSH
111029: EMPTY
111030: LIST
111031: LIST
111032: LIST
111033: LIST
111034: LIST
111035: LIST
111036: LIST
111037: LIST
111038: LIST
111039: LIST
111040: LIST
111041: LIST
111042: LIST
111043: LIST
111044: LIST
111045: LIST
111046: LIST
111047: LIST
111048: PUSH
111049: EMPTY
111050: LIST
111051: LIST
111052: ST_TO_ADDR
// if result then
111053: LD_VAR 0 1
111057: IFFALSE 111346
// begin normal :=  ;
111059: LD_ADDR_VAR 0 3
111063: PUSH
111064: LD_STRING 
111066: ST_TO_ADDR
// hardcore :=  ;
111067: LD_ADDR_VAR 0 4
111071: PUSH
111072: LD_STRING 
111074: ST_TO_ADDR
// for i = 1 to normalCounter do
111075: LD_ADDR_VAR 0 5
111079: PUSH
111080: DOUBLE
111081: LD_INT 1
111083: DEC
111084: ST_TO_ADDR
111085: LD_EXP 161
111089: PUSH
111090: FOR_TO
111091: IFFALSE 111192
// begin tmp := 0 ;
111093: LD_ADDR_VAR 0 2
111097: PUSH
111098: LD_STRING 0
111100: ST_TO_ADDR
// if result [ 1 ] then
111101: LD_VAR 0 1
111105: PUSH
111106: LD_INT 1
111108: ARRAY
111109: IFFALSE 111174
// if result [ 1 ] [ 1 ] = i then
111111: LD_VAR 0 1
111115: PUSH
111116: LD_INT 1
111118: ARRAY
111119: PUSH
111120: LD_INT 1
111122: ARRAY
111123: PUSH
111124: LD_VAR 0 5
111128: EQUAL
111129: IFFALSE 111174
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
111131: LD_ADDR_VAR 0 1
111135: PUSH
111136: LD_VAR 0 1
111140: PPUSH
111141: LD_INT 1
111143: PPUSH
111144: LD_VAR 0 1
111148: PUSH
111149: LD_INT 1
111151: ARRAY
111152: PPUSH
111153: LD_INT 1
111155: PPUSH
111156: CALL_OW 3
111160: PPUSH
111161: CALL_OW 1
111165: ST_TO_ADDR
// tmp := 1 ;
111166: LD_ADDR_VAR 0 2
111170: PUSH
111171: LD_STRING 1
111173: ST_TO_ADDR
// end ; normal := normal & tmp ;
111174: LD_ADDR_VAR 0 3
111178: PUSH
111179: LD_VAR 0 3
111183: PUSH
111184: LD_VAR 0 2
111188: STR
111189: ST_TO_ADDR
// end ;
111190: GO 111090
111192: POP
111193: POP
// for i = 1 to hardcoreCounter do
111194: LD_ADDR_VAR 0 5
111198: PUSH
111199: DOUBLE
111200: LD_INT 1
111202: DEC
111203: ST_TO_ADDR
111204: LD_EXP 162
111208: PUSH
111209: FOR_TO
111210: IFFALSE 111315
// begin tmp := 0 ;
111212: LD_ADDR_VAR 0 2
111216: PUSH
111217: LD_STRING 0
111219: ST_TO_ADDR
// if result [ 2 ] then
111220: LD_VAR 0 1
111224: PUSH
111225: LD_INT 2
111227: ARRAY
111228: IFFALSE 111297
// if result [ 2 ] [ 1 ] = 100 + i then
111230: LD_VAR 0 1
111234: PUSH
111235: LD_INT 2
111237: ARRAY
111238: PUSH
111239: LD_INT 1
111241: ARRAY
111242: PUSH
111243: LD_INT 100
111245: PUSH
111246: LD_VAR 0 5
111250: PLUS
111251: EQUAL
111252: IFFALSE 111297
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
111254: LD_ADDR_VAR 0 1
111258: PUSH
111259: LD_VAR 0 1
111263: PPUSH
111264: LD_INT 2
111266: PPUSH
111267: LD_VAR 0 1
111271: PUSH
111272: LD_INT 2
111274: ARRAY
111275: PPUSH
111276: LD_INT 1
111278: PPUSH
111279: CALL_OW 3
111283: PPUSH
111284: CALL_OW 1
111288: ST_TO_ADDR
// tmp := 1 ;
111289: LD_ADDR_VAR 0 2
111293: PUSH
111294: LD_STRING 1
111296: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
111297: LD_ADDR_VAR 0 4
111301: PUSH
111302: LD_VAR 0 4
111306: PUSH
111307: LD_VAR 0 2
111311: STR
111312: ST_TO_ADDR
// end ;
111313: GO 111209
111315: POP
111316: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
111317: LD_STRING getStreamItemsFromMission("
111319: PUSH
111320: LD_VAR 0 3
111324: STR
111325: PUSH
111326: LD_STRING ","
111328: STR
111329: PUSH
111330: LD_VAR 0 4
111334: STR
111335: PUSH
111336: LD_STRING ")
111338: STR
111339: PPUSH
111340: CALL_OW 559
// end else
111344: GO 111353
// ToLua ( getStreamItemsFromMission("","") ) ;
111346: LD_STRING getStreamItemsFromMission("","")
111348: PPUSH
111349: CALL_OW 559
// end ;
111353: LD_VAR 0 1
111357: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
111358: LD_EXP 160
111362: PUSH
111363: LD_EXP 165
111367: AND
111368: IFFALSE 111492
111370: GO 111372
111372: DISABLE
111373: LD_INT 0
111375: PPUSH
111376: PPUSH
// begin enable ;
111377: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
111378: LD_ADDR_VAR 0 2
111382: PUSH
111383: LD_INT 22
111385: PUSH
111386: LD_OWVAR 2
111390: PUSH
111391: EMPTY
111392: LIST
111393: LIST
111394: PUSH
111395: LD_INT 2
111397: PUSH
111398: LD_INT 34
111400: PUSH
111401: LD_INT 7
111403: PUSH
111404: EMPTY
111405: LIST
111406: LIST
111407: PUSH
111408: LD_INT 34
111410: PUSH
111411: LD_INT 45
111413: PUSH
111414: EMPTY
111415: LIST
111416: LIST
111417: PUSH
111418: LD_INT 34
111420: PUSH
111421: LD_INT 28
111423: PUSH
111424: EMPTY
111425: LIST
111426: LIST
111427: PUSH
111428: LD_INT 34
111430: PUSH
111431: LD_INT 47
111433: PUSH
111434: EMPTY
111435: LIST
111436: LIST
111437: PUSH
111438: EMPTY
111439: LIST
111440: LIST
111441: LIST
111442: LIST
111443: LIST
111444: PUSH
111445: EMPTY
111446: LIST
111447: LIST
111448: PPUSH
111449: CALL_OW 69
111453: ST_TO_ADDR
// if not tmp then
111454: LD_VAR 0 2
111458: NOT
111459: IFFALSE 111463
// exit ;
111461: GO 111492
// for i in tmp do
111463: LD_ADDR_VAR 0 1
111467: PUSH
111468: LD_VAR 0 2
111472: PUSH
111473: FOR_IN
111474: IFFALSE 111490
// begin SetLives ( i , 0 ) ;
111476: LD_VAR 0 1
111480: PPUSH
111481: LD_INT 0
111483: PPUSH
111484: CALL_OW 234
// end ;
111488: GO 111473
111490: POP
111491: POP
// end ;
111492: PPOPN 2
111494: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
111495: LD_EXP 160
111499: PUSH
111500: LD_EXP 166
111504: AND
111505: IFFALSE 111589
111507: GO 111509
111509: DISABLE
111510: LD_INT 0
111512: PPUSH
111513: PPUSH
// begin enable ;
111514: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
111515: LD_ADDR_VAR 0 2
111519: PUSH
111520: LD_INT 22
111522: PUSH
111523: LD_OWVAR 2
111527: PUSH
111528: EMPTY
111529: LIST
111530: LIST
111531: PUSH
111532: LD_INT 32
111534: PUSH
111535: LD_INT 3
111537: PUSH
111538: EMPTY
111539: LIST
111540: LIST
111541: PUSH
111542: EMPTY
111543: LIST
111544: LIST
111545: PPUSH
111546: CALL_OW 69
111550: ST_TO_ADDR
// if not tmp then
111551: LD_VAR 0 2
111555: NOT
111556: IFFALSE 111560
// exit ;
111558: GO 111589
// for i in tmp do
111560: LD_ADDR_VAR 0 1
111564: PUSH
111565: LD_VAR 0 2
111569: PUSH
111570: FOR_IN
111571: IFFALSE 111587
// begin SetLives ( i , 0 ) ;
111573: LD_VAR 0 1
111577: PPUSH
111578: LD_INT 0
111580: PPUSH
111581: CALL_OW 234
// end ;
111585: GO 111570
111587: POP
111588: POP
// end ;
111589: PPOPN 2
111591: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
111592: LD_EXP 160
111596: PUSH
111597: LD_EXP 163
111601: AND
111602: IFFALSE 111695
111604: GO 111606
111606: DISABLE
111607: LD_INT 0
111609: PPUSH
// begin enable ;
111610: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
111611: LD_ADDR_VAR 0 1
111615: PUSH
111616: LD_INT 22
111618: PUSH
111619: LD_OWVAR 2
111623: PUSH
111624: EMPTY
111625: LIST
111626: LIST
111627: PUSH
111628: LD_INT 2
111630: PUSH
111631: LD_INT 25
111633: PUSH
111634: LD_INT 5
111636: PUSH
111637: EMPTY
111638: LIST
111639: LIST
111640: PUSH
111641: LD_INT 25
111643: PUSH
111644: LD_INT 9
111646: PUSH
111647: EMPTY
111648: LIST
111649: LIST
111650: PUSH
111651: LD_INT 25
111653: PUSH
111654: LD_INT 8
111656: PUSH
111657: EMPTY
111658: LIST
111659: LIST
111660: PUSH
111661: EMPTY
111662: LIST
111663: LIST
111664: LIST
111665: LIST
111666: PUSH
111667: EMPTY
111668: LIST
111669: LIST
111670: PPUSH
111671: CALL_OW 69
111675: PUSH
111676: FOR_IN
111677: IFFALSE 111693
// begin SetClass ( i , 1 ) ;
111679: LD_VAR 0 1
111683: PPUSH
111684: LD_INT 1
111686: PPUSH
111687: CALL_OW 336
// end ;
111691: GO 111676
111693: POP
111694: POP
// end ;
111695: PPOPN 1
111697: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
111698: LD_EXP 160
111702: PUSH
111703: LD_EXP 164
111707: AND
111708: PUSH
111709: LD_OWVAR 65
111713: PUSH
111714: LD_INT 7
111716: LESS
111717: AND
111718: IFFALSE 111732
111720: GO 111722
111722: DISABLE
// begin enable ;
111723: ENABLE
// game_speed := 7 ;
111724: LD_ADDR_OWVAR 65
111728: PUSH
111729: LD_INT 7
111731: ST_TO_ADDR
// end ;
111732: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
111733: LD_EXP 160
111737: PUSH
111738: LD_EXP 167
111742: AND
111743: IFFALSE 111945
111745: GO 111747
111747: DISABLE
111748: LD_INT 0
111750: PPUSH
111751: PPUSH
111752: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
111753: LD_ADDR_VAR 0 3
111757: PUSH
111758: LD_INT 81
111760: PUSH
111761: LD_OWVAR 2
111765: PUSH
111766: EMPTY
111767: LIST
111768: LIST
111769: PUSH
111770: LD_INT 21
111772: PUSH
111773: LD_INT 1
111775: PUSH
111776: EMPTY
111777: LIST
111778: LIST
111779: PUSH
111780: EMPTY
111781: LIST
111782: LIST
111783: PPUSH
111784: CALL_OW 69
111788: ST_TO_ADDR
// if not tmp then
111789: LD_VAR 0 3
111793: NOT
111794: IFFALSE 111798
// exit ;
111796: GO 111945
// if tmp > 5 then
111798: LD_VAR 0 3
111802: PUSH
111803: LD_INT 5
111805: GREATER
111806: IFFALSE 111818
// k := 5 else
111808: LD_ADDR_VAR 0 2
111812: PUSH
111813: LD_INT 5
111815: ST_TO_ADDR
111816: GO 111828
// k := tmp ;
111818: LD_ADDR_VAR 0 2
111822: PUSH
111823: LD_VAR 0 3
111827: ST_TO_ADDR
// for i := 1 to k do
111828: LD_ADDR_VAR 0 1
111832: PUSH
111833: DOUBLE
111834: LD_INT 1
111836: DEC
111837: ST_TO_ADDR
111838: LD_VAR 0 2
111842: PUSH
111843: FOR_TO
111844: IFFALSE 111943
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
111846: LD_VAR 0 3
111850: PUSH
111851: LD_VAR 0 1
111855: ARRAY
111856: PPUSH
111857: LD_VAR 0 1
111861: PUSH
111862: LD_INT 4
111864: MOD
111865: PUSH
111866: LD_INT 1
111868: PLUS
111869: PPUSH
111870: CALL_OW 259
111874: PUSH
111875: LD_INT 10
111877: LESS
111878: IFFALSE 111941
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
111880: LD_VAR 0 3
111884: PUSH
111885: LD_VAR 0 1
111889: ARRAY
111890: PPUSH
111891: LD_VAR 0 1
111895: PUSH
111896: LD_INT 4
111898: MOD
111899: PUSH
111900: LD_INT 1
111902: PLUS
111903: PPUSH
111904: LD_VAR 0 3
111908: PUSH
111909: LD_VAR 0 1
111913: ARRAY
111914: PPUSH
111915: LD_VAR 0 1
111919: PUSH
111920: LD_INT 4
111922: MOD
111923: PUSH
111924: LD_INT 1
111926: PLUS
111927: PPUSH
111928: CALL_OW 259
111932: PUSH
111933: LD_INT 1
111935: PLUS
111936: PPUSH
111937: CALL_OW 237
111941: GO 111843
111943: POP
111944: POP
// end ;
111945: PPOPN 3
111947: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
111948: LD_EXP 160
111952: PUSH
111953: LD_EXP 168
111957: AND
111958: IFFALSE 111978
111960: GO 111962
111962: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
111963: LD_INT 4
111965: PPUSH
111966: LD_OWVAR 2
111970: PPUSH
111971: LD_INT 0
111973: PPUSH
111974: CALL_OW 324
111978: END
// every 0 0$1 trigger StreamModeActive and sShovel do
111979: LD_EXP 160
111983: PUSH
111984: LD_EXP 197
111988: AND
111989: IFFALSE 112009
111991: GO 111993
111993: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
111994: LD_INT 19
111996: PPUSH
111997: LD_OWVAR 2
112001: PPUSH
112002: LD_INT 0
112004: PPUSH
112005: CALL_OW 324
112009: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
112010: LD_EXP 160
112014: PUSH
112015: LD_EXP 169
112019: AND
112020: IFFALSE 112122
112022: GO 112024
112024: DISABLE
112025: LD_INT 0
112027: PPUSH
112028: PPUSH
// begin enable ;
112029: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
112030: LD_ADDR_VAR 0 2
112034: PUSH
112035: LD_INT 22
112037: PUSH
112038: LD_OWVAR 2
112042: PUSH
112043: EMPTY
112044: LIST
112045: LIST
112046: PUSH
112047: LD_INT 2
112049: PUSH
112050: LD_INT 34
112052: PUSH
112053: LD_INT 11
112055: PUSH
112056: EMPTY
112057: LIST
112058: LIST
112059: PUSH
112060: LD_INT 34
112062: PUSH
112063: LD_INT 30
112065: PUSH
112066: EMPTY
112067: LIST
112068: LIST
112069: PUSH
112070: EMPTY
112071: LIST
112072: LIST
112073: LIST
112074: PUSH
112075: EMPTY
112076: LIST
112077: LIST
112078: PPUSH
112079: CALL_OW 69
112083: ST_TO_ADDR
// if not tmp then
112084: LD_VAR 0 2
112088: NOT
112089: IFFALSE 112093
// exit ;
112091: GO 112122
// for i in tmp do
112093: LD_ADDR_VAR 0 1
112097: PUSH
112098: LD_VAR 0 2
112102: PUSH
112103: FOR_IN
112104: IFFALSE 112120
// begin SetLives ( i , 0 ) ;
112106: LD_VAR 0 1
112110: PPUSH
112111: LD_INT 0
112113: PPUSH
112114: CALL_OW 234
// end ;
112118: GO 112103
112120: POP
112121: POP
// end ;
112122: PPOPN 2
112124: END
// every 0 0$1 trigger StreamModeActive and sBunker do
112125: LD_EXP 160
112129: PUSH
112130: LD_EXP 170
112134: AND
112135: IFFALSE 112155
112137: GO 112139
112139: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
112140: LD_INT 32
112142: PPUSH
112143: LD_OWVAR 2
112147: PPUSH
112148: LD_INT 0
112150: PPUSH
112151: CALL_OW 324
112155: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
112156: LD_EXP 160
112160: PUSH
112161: LD_EXP 171
112165: AND
112166: IFFALSE 112347
112168: GO 112170
112170: DISABLE
112171: LD_INT 0
112173: PPUSH
112174: PPUSH
112175: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
112176: LD_ADDR_VAR 0 2
112180: PUSH
112181: LD_INT 22
112183: PUSH
112184: LD_OWVAR 2
112188: PUSH
112189: EMPTY
112190: LIST
112191: LIST
112192: PUSH
112193: LD_INT 33
112195: PUSH
112196: LD_INT 3
112198: PUSH
112199: EMPTY
112200: LIST
112201: LIST
112202: PUSH
112203: EMPTY
112204: LIST
112205: LIST
112206: PPUSH
112207: CALL_OW 69
112211: ST_TO_ADDR
// if not tmp then
112212: LD_VAR 0 2
112216: NOT
112217: IFFALSE 112221
// exit ;
112219: GO 112347
// side := 0 ;
112221: LD_ADDR_VAR 0 3
112225: PUSH
112226: LD_INT 0
112228: ST_TO_ADDR
// for i := 1 to 8 do
112229: LD_ADDR_VAR 0 1
112233: PUSH
112234: DOUBLE
112235: LD_INT 1
112237: DEC
112238: ST_TO_ADDR
112239: LD_INT 8
112241: PUSH
112242: FOR_TO
112243: IFFALSE 112291
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
112245: LD_OWVAR 2
112249: PUSH
112250: LD_VAR 0 1
112254: NONEQUAL
112255: PUSH
112256: LD_OWVAR 2
112260: PPUSH
112261: LD_VAR 0 1
112265: PPUSH
112266: CALL_OW 81
112270: PUSH
112271: LD_INT 2
112273: EQUAL
112274: AND
112275: IFFALSE 112289
// begin side := i ;
112277: LD_ADDR_VAR 0 3
112281: PUSH
112282: LD_VAR 0 1
112286: ST_TO_ADDR
// break ;
112287: GO 112291
// end ;
112289: GO 112242
112291: POP
112292: POP
// if not side then
112293: LD_VAR 0 3
112297: NOT
112298: IFFALSE 112302
// exit ;
112300: GO 112347
// for i := 1 to tmp do
112302: LD_ADDR_VAR 0 1
112306: PUSH
112307: DOUBLE
112308: LD_INT 1
112310: DEC
112311: ST_TO_ADDR
112312: LD_VAR 0 2
112316: PUSH
112317: FOR_TO
112318: IFFALSE 112345
// if Prob ( 60 ) then
112320: LD_INT 60
112322: PPUSH
112323: CALL_OW 13
112327: IFFALSE 112343
// SetSide ( i , side ) ;
112329: LD_VAR 0 1
112333: PPUSH
112334: LD_VAR 0 3
112338: PPUSH
112339: CALL_OW 235
112343: GO 112317
112345: POP
112346: POP
// end ;
112347: PPOPN 3
112349: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
112350: LD_EXP 160
112354: PUSH
112355: LD_EXP 173
112359: AND
112360: IFFALSE 112479
112362: GO 112364
112364: DISABLE
112365: LD_INT 0
112367: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
112368: LD_ADDR_VAR 0 1
112372: PUSH
112373: LD_INT 22
112375: PUSH
112376: LD_OWVAR 2
112380: PUSH
112381: EMPTY
112382: LIST
112383: LIST
112384: PUSH
112385: LD_INT 21
112387: PUSH
112388: LD_INT 1
112390: PUSH
112391: EMPTY
112392: LIST
112393: LIST
112394: PUSH
112395: LD_INT 3
112397: PUSH
112398: LD_INT 23
112400: PUSH
112401: LD_INT 0
112403: PUSH
112404: EMPTY
112405: LIST
112406: LIST
112407: PUSH
112408: EMPTY
112409: LIST
112410: LIST
112411: PUSH
112412: EMPTY
112413: LIST
112414: LIST
112415: LIST
112416: PPUSH
112417: CALL_OW 69
112421: PUSH
112422: FOR_IN
112423: IFFALSE 112477
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
112425: LD_VAR 0 1
112429: PPUSH
112430: CALL_OW 257
112434: PUSH
112435: LD_INT 1
112437: PUSH
112438: LD_INT 2
112440: PUSH
112441: LD_INT 3
112443: PUSH
112444: LD_INT 4
112446: PUSH
112447: EMPTY
112448: LIST
112449: LIST
112450: LIST
112451: LIST
112452: IN
112453: IFFALSE 112475
// SetClass ( un , rand ( 1 , 4 ) ) ;
112455: LD_VAR 0 1
112459: PPUSH
112460: LD_INT 1
112462: PPUSH
112463: LD_INT 4
112465: PPUSH
112466: CALL_OW 12
112470: PPUSH
112471: CALL_OW 336
112475: GO 112422
112477: POP
112478: POP
// end ;
112479: PPOPN 1
112481: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
112482: LD_EXP 160
112486: PUSH
112487: LD_EXP 172
112491: AND
112492: IFFALSE 112571
112494: GO 112496
112496: DISABLE
112497: LD_INT 0
112499: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
112500: LD_ADDR_VAR 0 1
112504: PUSH
112505: LD_INT 22
112507: PUSH
112508: LD_OWVAR 2
112512: PUSH
112513: EMPTY
112514: LIST
112515: LIST
112516: PUSH
112517: LD_INT 21
112519: PUSH
112520: LD_INT 3
112522: PUSH
112523: EMPTY
112524: LIST
112525: LIST
112526: PUSH
112527: EMPTY
112528: LIST
112529: LIST
112530: PPUSH
112531: CALL_OW 69
112535: ST_TO_ADDR
// if not tmp then
112536: LD_VAR 0 1
112540: NOT
112541: IFFALSE 112545
// exit ;
112543: GO 112571
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
112545: LD_VAR 0 1
112549: PUSH
112550: LD_INT 1
112552: PPUSH
112553: LD_VAR 0 1
112557: PPUSH
112558: CALL_OW 12
112562: ARRAY
112563: PPUSH
112564: LD_INT 100
112566: PPUSH
112567: CALL_OW 234
// end ;
112571: PPOPN 1
112573: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
112574: LD_EXP 160
112578: PUSH
112579: LD_EXP 174
112583: AND
112584: IFFALSE 112682
112586: GO 112588
112588: DISABLE
112589: LD_INT 0
112591: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
112592: LD_ADDR_VAR 0 1
112596: PUSH
112597: LD_INT 22
112599: PUSH
112600: LD_OWVAR 2
112604: PUSH
112605: EMPTY
112606: LIST
112607: LIST
112608: PUSH
112609: LD_INT 21
112611: PUSH
112612: LD_INT 1
112614: PUSH
112615: EMPTY
112616: LIST
112617: LIST
112618: PUSH
112619: EMPTY
112620: LIST
112621: LIST
112622: PPUSH
112623: CALL_OW 69
112627: ST_TO_ADDR
// if not tmp then
112628: LD_VAR 0 1
112632: NOT
112633: IFFALSE 112637
// exit ;
112635: GO 112682
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
112637: LD_VAR 0 1
112641: PUSH
112642: LD_INT 1
112644: PPUSH
112645: LD_VAR 0 1
112649: PPUSH
112650: CALL_OW 12
112654: ARRAY
112655: PPUSH
112656: LD_INT 1
112658: PPUSH
112659: LD_INT 4
112661: PPUSH
112662: CALL_OW 12
112666: PPUSH
112667: LD_INT 3000
112669: PPUSH
112670: LD_INT 9000
112672: PPUSH
112673: CALL_OW 12
112677: PPUSH
112678: CALL_OW 492
// end ;
112682: PPOPN 1
112684: END
// every 0 0$1 trigger StreamModeActive and sDepot do
112685: LD_EXP 160
112689: PUSH
112690: LD_EXP 175
112694: AND
112695: IFFALSE 112715
112697: GO 112699
112699: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
112700: LD_INT 1
112702: PPUSH
112703: LD_OWVAR 2
112707: PPUSH
112708: LD_INT 0
112710: PPUSH
112711: CALL_OW 324
112715: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
112716: LD_EXP 160
112720: PUSH
112721: LD_EXP 176
112725: AND
112726: IFFALSE 112809
112728: GO 112730
112730: DISABLE
112731: LD_INT 0
112733: PPUSH
112734: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
112735: LD_ADDR_VAR 0 2
112739: PUSH
112740: LD_INT 22
112742: PUSH
112743: LD_OWVAR 2
112747: PUSH
112748: EMPTY
112749: LIST
112750: LIST
112751: PUSH
112752: LD_INT 21
112754: PUSH
112755: LD_INT 3
112757: PUSH
112758: EMPTY
112759: LIST
112760: LIST
112761: PUSH
112762: EMPTY
112763: LIST
112764: LIST
112765: PPUSH
112766: CALL_OW 69
112770: ST_TO_ADDR
// if not tmp then
112771: LD_VAR 0 2
112775: NOT
112776: IFFALSE 112780
// exit ;
112778: GO 112809
// for i in tmp do
112780: LD_ADDR_VAR 0 1
112784: PUSH
112785: LD_VAR 0 2
112789: PUSH
112790: FOR_IN
112791: IFFALSE 112807
// SetBLevel ( i , 10 ) ;
112793: LD_VAR 0 1
112797: PPUSH
112798: LD_INT 10
112800: PPUSH
112801: CALL_OW 241
112805: GO 112790
112807: POP
112808: POP
// end ;
112809: PPOPN 2
112811: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
112812: LD_EXP 160
112816: PUSH
112817: LD_EXP 177
112821: AND
112822: IFFALSE 112933
112824: GO 112826
112826: DISABLE
112827: LD_INT 0
112829: PPUSH
112830: PPUSH
112831: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
112832: LD_ADDR_VAR 0 3
112836: PUSH
112837: LD_INT 22
112839: PUSH
112840: LD_OWVAR 2
112844: PUSH
112845: EMPTY
112846: LIST
112847: LIST
112848: PUSH
112849: LD_INT 25
112851: PUSH
112852: LD_INT 1
112854: PUSH
112855: EMPTY
112856: LIST
112857: LIST
112858: PUSH
112859: EMPTY
112860: LIST
112861: LIST
112862: PPUSH
112863: CALL_OW 69
112867: ST_TO_ADDR
// if not tmp then
112868: LD_VAR 0 3
112872: NOT
112873: IFFALSE 112877
// exit ;
112875: GO 112933
// un := tmp [ rand ( 1 , tmp ) ] ;
112877: LD_ADDR_VAR 0 2
112881: PUSH
112882: LD_VAR 0 3
112886: PUSH
112887: LD_INT 1
112889: PPUSH
112890: LD_VAR 0 3
112894: PPUSH
112895: CALL_OW 12
112899: ARRAY
112900: ST_TO_ADDR
// if Crawls ( un ) then
112901: LD_VAR 0 2
112905: PPUSH
112906: CALL_OW 318
112910: IFFALSE 112921
// ComWalk ( un ) ;
112912: LD_VAR 0 2
112916: PPUSH
112917: CALL_OW 138
// SetClass ( un , class_sniper ) ;
112921: LD_VAR 0 2
112925: PPUSH
112926: LD_INT 5
112928: PPUSH
112929: CALL_OW 336
// end ;
112933: PPOPN 3
112935: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
112936: LD_EXP 160
112940: PUSH
112941: LD_EXP 178
112945: AND
112946: PUSH
112947: LD_OWVAR 67
112951: PUSH
112952: LD_INT 4
112954: LESS
112955: AND
112956: IFFALSE 112975
112958: GO 112960
112960: DISABLE
// begin Difficulty := Difficulty + 1 ;
112961: LD_ADDR_OWVAR 67
112965: PUSH
112966: LD_OWVAR 67
112970: PUSH
112971: LD_INT 1
112973: PLUS
112974: ST_TO_ADDR
// end ;
112975: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
112976: LD_EXP 160
112980: PUSH
112981: LD_EXP 179
112985: AND
112986: IFFALSE 113089
112988: GO 112990
112990: DISABLE
112991: LD_INT 0
112993: PPUSH
// begin for i := 1 to 5 do
112994: LD_ADDR_VAR 0 1
112998: PUSH
112999: DOUBLE
113000: LD_INT 1
113002: DEC
113003: ST_TO_ADDR
113004: LD_INT 5
113006: PUSH
113007: FOR_TO
113008: IFFALSE 113087
// begin uc_nation := nation_nature ;
113010: LD_ADDR_OWVAR 21
113014: PUSH
113015: LD_INT 0
113017: ST_TO_ADDR
// uc_side := 0 ;
113018: LD_ADDR_OWVAR 20
113022: PUSH
113023: LD_INT 0
113025: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
113026: LD_ADDR_OWVAR 29
113030: PUSH
113031: LD_INT 12
113033: PUSH
113034: LD_INT 12
113036: PUSH
113037: EMPTY
113038: LIST
113039: LIST
113040: ST_TO_ADDR
// hc_agressivity := 20 ;
113041: LD_ADDR_OWVAR 35
113045: PUSH
113046: LD_INT 20
113048: ST_TO_ADDR
// hc_class := class_tiger ;
113049: LD_ADDR_OWVAR 28
113053: PUSH
113054: LD_INT 14
113056: ST_TO_ADDR
// hc_gallery :=  ;
113057: LD_ADDR_OWVAR 33
113061: PUSH
113062: LD_STRING 
113064: ST_TO_ADDR
// hc_name :=  ;
113065: LD_ADDR_OWVAR 26
113069: PUSH
113070: LD_STRING 
113072: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
113073: CALL_OW 44
113077: PPUSH
113078: LD_INT 0
113080: PPUSH
113081: CALL_OW 51
// end ;
113085: GO 113007
113087: POP
113088: POP
// end ;
113089: PPOPN 1
113091: END
// every 0 0$1 trigger StreamModeActive and sBomb do
113092: LD_EXP 160
113096: PUSH
113097: LD_EXP 180
113101: AND
113102: IFFALSE 113111
113104: GO 113106
113106: DISABLE
// StreamSibBomb ;
113107: CALL 113112 0 0
113111: END
// export function StreamSibBomb ; var i , x , y ; begin
113112: LD_INT 0
113114: PPUSH
113115: PPUSH
113116: PPUSH
113117: PPUSH
// result := false ;
113118: LD_ADDR_VAR 0 1
113122: PUSH
113123: LD_INT 0
113125: ST_TO_ADDR
// for i := 1 to 16 do
113126: LD_ADDR_VAR 0 2
113130: PUSH
113131: DOUBLE
113132: LD_INT 1
113134: DEC
113135: ST_TO_ADDR
113136: LD_INT 16
113138: PUSH
113139: FOR_TO
113140: IFFALSE 113339
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
113142: LD_ADDR_VAR 0 3
113146: PUSH
113147: LD_INT 10
113149: PUSH
113150: LD_INT 20
113152: PUSH
113153: LD_INT 30
113155: PUSH
113156: LD_INT 40
113158: PUSH
113159: LD_INT 50
113161: PUSH
113162: LD_INT 60
113164: PUSH
113165: LD_INT 70
113167: PUSH
113168: LD_INT 80
113170: PUSH
113171: LD_INT 90
113173: PUSH
113174: LD_INT 100
113176: PUSH
113177: LD_INT 110
113179: PUSH
113180: LD_INT 120
113182: PUSH
113183: LD_INT 130
113185: PUSH
113186: LD_INT 140
113188: PUSH
113189: LD_INT 150
113191: PUSH
113192: EMPTY
113193: LIST
113194: LIST
113195: LIST
113196: LIST
113197: LIST
113198: LIST
113199: LIST
113200: LIST
113201: LIST
113202: LIST
113203: LIST
113204: LIST
113205: LIST
113206: LIST
113207: LIST
113208: PUSH
113209: LD_INT 1
113211: PPUSH
113212: LD_INT 15
113214: PPUSH
113215: CALL_OW 12
113219: ARRAY
113220: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
113221: LD_ADDR_VAR 0 4
113225: PUSH
113226: LD_INT 10
113228: PUSH
113229: LD_INT 20
113231: PUSH
113232: LD_INT 30
113234: PUSH
113235: LD_INT 40
113237: PUSH
113238: LD_INT 50
113240: PUSH
113241: LD_INT 60
113243: PUSH
113244: LD_INT 70
113246: PUSH
113247: LD_INT 80
113249: PUSH
113250: LD_INT 90
113252: PUSH
113253: LD_INT 100
113255: PUSH
113256: LD_INT 110
113258: PUSH
113259: LD_INT 120
113261: PUSH
113262: LD_INT 130
113264: PUSH
113265: LD_INT 140
113267: PUSH
113268: LD_INT 150
113270: PUSH
113271: EMPTY
113272: LIST
113273: LIST
113274: LIST
113275: LIST
113276: LIST
113277: LIST
113278: LIST
113279: LIST
113280: LIST
113281: LIST
113282: LIST
113283: LIST
113284: LIST
113285: LIST
113286: LIST
113287: PUSH
113288: LD_INT 1
113290: PPUSH
113291: LD_INT 15
113293: PPUSH
113294: CALL_OW 12
113298: ARRAY
113299: ST_TO_ADDR
// if ValidHex ( x , y ) then
113300: LD_VAR 0 3
113304: PPUSH
113305: LD_VAR 0 4
113309: PPUSH
113310: CALL_OW 488
113314: IFFALSE 113337
// begin result := [ x , y ] ;
113316: LD_ADDR_VAR 0 1
113320: PUSH
113321: LD_VAR 0 3
113325: PUSH
113326: LD_VAR 0 4
113330: PUSH
113331: EMPTY
113332: LIST
113333: LIST
113334: ST_TO_ADDR
// break ;
113335: GO 113339
// end ; end ;
113337: GO 113139
113339: POP
113340: POP
// if result then
113341: LD_VAR 0 1
113345: IFFALSE 113405
// begin ToLua ( playSibBomb() ) ;
113347: LD_STRING playSibBomb()
113349: PPUSH
113350: CALL_OW 559
// wait ( 0 0$14 ) ;
113354: LD_INT 490
113356: PPUSH
113357: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
113361: LD_VAR 0 1
113365: PUSH
113366: LD_INT 1
113368: ARRAY
113369: PPUSH
113370: LD_VAR 0 1
113374: PUSH
113375: LD_INT 2
113377: ARRAY
113378: PPUSH
113379: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
113383: LD_VAR 0 1
113387: PUSH
113388: LD_INT 1
113390: ARRAY
113391: PPUSH
113392: LD_VAR 0 1
113396: PUSH
113397: LD_INT 2
113399: ARRAY
113400: PPUSH
113401: CALL_OW 429
// end ; end ;
113405: LD_VAR 0 1
113409: RET
// every 0 0$1 trigger StreamModeActive and sReset do
113410: LD_EXP 160
113414: PUSH
113415: LD_EXP 182
113419: AND
113420: IFFALSE 113432
113422: GO 113424
113424: DISABLE
// YouLost (  ) ;
113425: LD_STRING 
113427: PPUSH
113428: CALL_OW 104
113432: END
// every 0 0$1 trigger StreamModeActive and sFog do
113433: LD_EXP 160
113437: PUSH
113438: LD_EXP 181
113442: AND
113443: IFFALSE 113457
113445: GO 113447
113447: DISABLE
// FogOff ( your_side ) ;
113448: LD_OWVAR 2
113452: PPUSH
113453: CALL_OW 344
113457: END
// every 0 0$1 trigger StreamModeActive and sSun do
113458: LD_EXP 160
113462: PUSH
113463: LD_EXP 183
113467: AND
113468: IFFALSE 113496
113470: GO 113472
113472: DISABLE
// begin solar_recharge_percent := 0 ;
113473: LD_ADDR_OWVAR 79
113477: PUSH
113478: LD_INT 0
113480: ST_TO_ADDR
// wait ( 5 5$00 ) ;
113481: LD_INT 10500
113483: PPUSH
113484: CALL_OW 67
// solar_recharge_percent := 100 ;
113488: LD_ADDR_OWVAR 79
113492: PUSH
113493: LD_INT 100
113495: ST_TO_ADDR
// end ;
113496: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
113497: LD_EXP 160
113501: PUSH
113502: LD_EXP 184
113506: AND
113507: IFFALSE 113746
113509: GO 113511
113511: DISABLE
113512: LD_INT 0
113514: PPUSH
113515: PPUSH
113516: PPUSH
// begin tmp := [ ] ;
113517: LD_ADDR_VAR 0 3
113521: PUSH
113522: EMPTY
113523: ST_TO_ADDR
// for i := 1 to 6 do
113524: LD_ADDR_VAR 0 1
113528: PUSH
113529: DOUBLE
113530: LD_INT 1
113532: DEC
113533: ST_TO_ADDR
113534: LD_INT 6
113536: PUSH
113537: FOR_TO
113538: IFFALSE 113643
// begin uc_nation := nation_nature ;
113540: LD_ADDR_OWVAR 21
113544: PUSH
113545: LD_INT 0
113547: ST_TO_ADDR
// uc_side := 0 ;
113548: LD_ADDR_OWVAR 20
113552: PUSH
113553: LD_INT 0
113555: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
113556: LD_ADDR_OWVAR 29
113560: PUSH
113561: LD_INT 12
113563: PUSH
113564: LD_INT 12
113566: PUSH
113567: EMPTY
113568: LIST
113569: LIST
113570: ST_TO_ADDR
// hc_agressivity := 20 ;
113571: LD_ADDR_OWVAR 35
113575: PUSH
113576: LD_INT 20
113578: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
113579: LD_ADDR_OWVAR 28
113583: PUSH
113584: LD_INT 17
113586: ST_TO_ADDR
// hc_gallery :=  ;
113587: LD_ADDR_OWVAR 33
113591: PUSH
113592: LD_STRING 
113594: ST_TO_ADDR
// hc_name :=  ;
113595: LD_ADDR_OWVAR 26
113599: PUSH
113600: LD_STRING 
113602: ST_TO_ADDR
// un := CreateHuman ;
113603: LD_ADDR_VAR 0 2
113607: PUSH
113608: CALL_OW 44
113612: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
113613: LD_VAR 0 2
113617: PPUSH
113618: LD_INT 1
113620: PPUSH
113621: CALL_OW 51
// tmp := tmp ^ un ;
113625: LD_ADDR_VAR 0 3
113629: PUSH
113630: LD_VAR 0 3
113634: PUSH
113635: LD_VAR 0 2
113639: ADD
113640: ST_TO_ADDR
// end ;
113641: GO 113537
113643: POP
113644: POP
// repeat wait ( 0 0$1 ) ;
113645: LD_INT 35
113647: PPUSH
113648: CALL_OW 67
// for un in tmp do
113652: LD_ADDR_VAR 0 2
113656: PUSH
113657: LD_VAR 0 3
113661: PUSH
113662: FOR_IN
113663: IFFALSE 113737
// begin if IsDead ( un ) then
113665: LD_VAR 0 2
113669: PPUSH
113670: CALL_OW 301
113674: IFFALSE 113694
// begin tmp := tmp diff un ;
113676: LD_ADDR_VAR 0 3
113680: PUSH
113681: LD_VAR 0 3
113685: PUSH
113686: LD_VAR 0 2
113690: DIFF
113691: ST_TO_ADDR
// continue ;
113692: GO 113662
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
113694: LD_VAR 0 2
113698: PPUSH
113699: LD_INT 3
113701: PUSH
113702: LD_INT 22
113704: PUSH
113705: LD_INT 0
113707: PUSH
113708: EMPTY
113709: LIST
113710: LIST
113711: PUSH
113712: EMPTY
113713: LIST
113714: LIST
113715: PPUSH
113716: CALL_OW 69
113720: PPUSH
113721: LD_VAR 0 2
113725: PPUSH
113726: CALL_OW 74
113730: PPUSH
113731: CALL_OW 115
// end ;
113735: GO 113662
113737: POP
113738: POP
// until not tmp ;
113739: LD_VAR 0 3
113743: NOT
113744: IFFALSE 113645
// end ;
113746: PPOPN 3
113748: END
// every 0 0$1 trigger StreamModeActive and sTroll do
113749: LD_EXP 160
113753: PUSH
113754: LD_EXP 185
113758: AND
113759: IFFALSE 113813
113761: GO 113763
113763: DISABLE
// begin ToLua ( displayTroll(); ) ;
113764: LD_STRING displayTroll();
113766: PPUSH
113767: CALL_OW 559
// wait ( 3 3$00 ) ;
113771: LD_INT 6300
113773: PPUSH
113774: CALL_OW 67
// ToLua ( hideTroll(); ) ;
113778: LD_STRING hideTroll();
113780: PPUSH
113781: CALL_OW 559
// wait ( 1 1$00 ) ;
113785: LD_INT 2100
113787: PPUSH
113788: CALL_OW 67
// ToLua ( displayTroll(); ) ;
113792: LD_STRING displayTroll();
113794: PPUSH
113795: CALL_OW 559
// wait ( 1 1$00 ) ;
113799: LD_INT 2100
113801: PPUSH
113802: CALL_OW 67
// ToLua ( hideTroll(); ) ;
113806: LD_STRING hideTroll();
113808: PPUSH
113809: CALL_OW 559
// end ;
113813: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
113814: LD_EXP 160
113818: PUSH
113819: LD_EXP 186
113823: AND
113824: IFFALSE 113887
113826: GO 113828
113828: DISABLE
113829: LD_INT 0
113831: PPUSH
// begin p := 0 ;
113832: LD_ADDR_VAR 0 1
113836: PUSH
113837: LD_INT 0
113839: ST_TO_ADDR
// repeat game_speed := 1 ;
113840: LD_ADDR_OWVAR 65
113844: PUSH
113845: LD_INT 1
113847: ST_TO_ADDR
// wait ( 0 0$1 ) ;
113848: LD_INT 35
113850: PPUSH
113851: CALL_OW 67
// p := p + 1 ;
113855: LD_ADDR_VAR 0 1
113859: PUSH
113860: LD_VAR 0 1
113864: PUSH
113865: LD_INT 1
113867: PLUS
113868: ST_TO_ADDR
// until p >= 60 ;
113869: LD_VAR 0 1
113873: PUSH
113874: LD_INT 60
113876: GREATEREQUAL
113877: IFFALSE 113840
// game_speed := 4 ;
113879: LD_ADDR_OWVAR 65
113883: PUSH
113884: LD_INT 4
113886: ST_TO_ADDR
// end ;
113887: PPOPN 1
113889: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
113890: LD_EXP 160
113894: PUSH
113895: LD_EXP 187
113899: AND
113900: IFFALSE 114046
113902: GO 113904
113904: DISABLE
113905: LD_INT 0
113907: PPUSH
113908: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
113909: LD_ADDR_VAR 0 1
113913: PUSH
113914: LD_INT 22
113916: PUSH
113917: LD_OWVAR 2
113921: PUSH
113922: EMPTY
113923: LIST
113924: LIST
113925: PUSH
113926: LD_INT 2
113928: PUSH
113929: LD_INT 30
113931: PUSH
113932: LD_INT 0
113934: PUSH
113935: EMPTY
113936: LIST
113937: LIST
113938: PUSH
113939: LD_INT 30
113941: PUSH
113942: LD_INT 1
113944: PUSH
113945: EMPTY
113946: LIST
113947: LIST
113948: PUSH
113949: EMPTY
113950: LIST
113951: LIST
113952: LIST
113953: PUSH
113954: EMPTY
113955: LIST
113956: LIST
113957: PPUSH
113958: CALL_OW 69
113962: ST_TO_ADDR
// if not depot then
113963: LD_VAR 0 1
113967: NOT
113968: IFFALSE 113972
// exit ;
113970: GO 114046
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
113972: LD_ADDR_VAR 0 2
113976: PUSH
113977: LD_VAR 0 1
113981: PUSH
113982: LD_INT 1
113984: PPUSH
113985: LD_VAR 0 1
113989: PPUSH
113990: CALL_OW 12
113994: ARRAY
113995: PPUSH
113996: CALL_OW 274
114000: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
114001: LD_VAR 0 2
114005: PPUSH
114006: LD_INT 1
114008: PPUSH
114009: LD_INT 0
114011: PPUSH
114012: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
114016: LD_VAR 0 2
114020: PPUSH
114021: LD_INT 2
114023: PPUSH
114024: LD_INT 0
114026: PPUSH
114027: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
114031: LD_VAR 0 2
114035: PPUSH
114036: LD_INT 3
114038: PPUSH
114039: LD_INT 0
114041: PPUSH
114042: CALL_OW 277
// end ;
114046: PPOPN 2
114048: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
114049: LD_EXP 160
114053: PUSH
114054: LD_EXP 188
114058: AND
114059: IFFALSE 114156
114061: GO 114063
114063: DISABLE
114064: LD_INT 0
114066: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
114067: LD_ADDR_VAR 0 1
114071: PUSH
114072: LD_INT 22
114074: PUSH
114075: LD_OWVAR 2
114079: PUSH
114080: EMPTY
114081: LIST
114082: LIST
114083: PUSH
114084: LD_INT 21
114086: PUSH
114087: LD_INT 1
114089: PUSH
114090: EMPTY
114091: LIST
114092: LIST
114093: PUSH
114094: LD_INT 3
114096: PUSH
114097: LD_INT 23
114099: PUSH
114100: LD_INT 0
114102: PUSH
114103: EMPTY
114104: LIST
114105: LIST
114106: PUSH
114107: EMPTY
114108: LIST
114109: LIST
114110: PUSH
114111: EMPTY
114112: LIST
114113: LIST
114114: LIST
114115: PPUSH
114116: CALL_OW 69
114120: ST_TO_ADDR
// if not tmp then
114121: LD_VAR 0 1
114125: NOT
114126: IFFALSE 114130
// exit ;
114128: GO 114156
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
114130: LD_VAR 0 1
114134: PUSH
114135: LD_INT 1
114137: PPUSH
114138: LD_VAR 0 1
114142: PPUSH
114143: CALL_OW 12
114147: ARRAY
114148: PPUSH
114149: LD_INT 200
114151: PPUSH
114152: CALL_OW 234
// end ;
114156: PPOPN 1
114158: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
114159: LD_EXP 160
114163: PUSH
114164: LD_EXP 189
114168: AND
114169: IFFALSE 114248
114171: GO 114173
114173: DISABLE
114174: LD_INT 0
114176: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
114177: LD_ADDR_VAR 0 1
114181: PUSH
114182: LD_INT 22
114184: PUSH
114185: LD_OWVAR 2
114189: PUSH
114190: EMPTY
114191: LIST
114192: LIST
114193: PUSH
114194: LD_INT 21
114196: PUSH
114197: LD_INT 2
114199: PUSH
114200: EMPTY
114201: LIST
114202: LIST
114203: PUSH
114204: EMPTY
114205: LIST
114206: LIST
114207: PPUSH
114208: CALL_OW 69
114212: ST_TO_ADDR
// if not tmp then
114213: LD_VAR 0 1
114217: NOT
114218: IFFALSE 114222
// exit ;
114220: GO 114248
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
114222: LD_VAR 0 1
114226: PUSH
114227: LD_INT 1
114229: PPUSH
114230: LD_VAR 0 1
114234: PPUSH
114235: CALL_OW 12
114239: ARRAY
114240: PPUSH
114241: LD_INT 60
114243: PPUSH
114244: CALL_OW 234
// end ;
114248: PPOPN 1
114250: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
114251: LD_EXP 160
114255: PUSH
114256: LD_EXP 190
114260: AND
114261: IFFALSE 114360
114263: GO 114265
114265: DISABLE
114266: LD_INT 0
114268: PPUSH
114269: PPUSH
// begin enable ;
114270: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
114271: LD_ADDR_VAR 0 1
114275: PUSH
114276: LD_INT 22
114278: PUSH
114279: LD_OWVAR 2
114283: PUSH
114284: EMPTY
114285: LIST
114286: LIST
114287: PUSH
114288: LD_INT 61
114290: PUSH
114291: EMPTY
114292: LIST
114293: PUSH
114294: LD_INT 33
114296: PUSH
114297: LD_INT 2
114299: PUSH
114300: EMPTY
114301: LIST
114302: LIST
114303: PUSH
114304: EMPTY
114305: LIST
114306: LIST
114307: LIST
114308: PPUSH
114309: CALL_OW 69
114313: ST_TO_ADDR
// if not tmp then
114314: LD_VAR 0 1
114318: NOT
114319: IFFALSE 114323
// exit ;
114321: GO 114360
// for i in tmp do
114323: LD_ADDR_VAR 0 2
114327: PUSH
114328: LD_VAR 0 1
114332: PUSH
114333: FOR_IN
114334: IFFALSE 114358
// if IsControledBy ( i ) then
114336: LD_VAR 0 2
114340: PPUSH
114341: CALL_OW 312
114345: IFFALSE 114356
// ComUnlink ( i ) ;
114347: LD_VAR 0 2
114351: PPUSH
114352: CALL_OW 136
114356: GO 114333
114358: POP
114359: POP
// end ;
114360: PPOPN 2
114362: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
114363: LD_EXP 160
114367: PUSH
114368: LD_EXP 191
114372: AND
114373: IFFALSE 114513
114375: GO 114377
114377: DISABLE
114378: LD_INT 0
114380: PPUSH
114381: PPUSH
// begin ToLua ( displayPowell(); ) ;
114382: LD_STRING displayPowell();
114384: PPUSH
114385: CALL_OW 559
// uc_side := 0 ;
114389: LD_ADDR_OWVAR 20
114393: PUSH
114394: LD_INT 0
114396: ST_TO_ADDR
// uc_nation := 2 ;
114397: LD_ADDR_OWVAR 21
114401: PUSH
114402: LD_INT 2
114404: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
114405: LD_ADDR_OWVAR 37
114409: PUSH
114410: LD_INT 14
114412: ST_TO_ADDR
// vc_engine := engine_siberite ;
114413: LD_ADDR_OWVAR 39
114417: PUSH
114418: LD_INT 3
114420: ST_TO_ADDR
// vc_control := control_apeman ;
114421: LD_ADDR_OWVAR 38
114425: PUSH
114426: LD_INT 5
114428: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
114429: LD_ADDR_OWVAR 40
114433: PUSH
114434: LD_INT 29
114436: ST_TO_ADDR
// un := CreateVehicle ;
114437: LD_ADDR_VAR 0 2
114441: PUSH
114442: CALL_OW 45
114446: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
114447: LD_VAR 0 2
114451: PPUSH
114452: LD_INT 1
114454: PPUSH
114455: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
114459: LD_INT 35
114461: PPUSH
114462: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
114466: LD_VAR 0 2
114470: PPUSH
114471: LD_INT 22
114473: PUSH
114474: LD_OWVAR 2
114478: PUSH
114479: EMPTY
114480: LIST
114481: LIST
114482: PPUSH
114483: CALL_OW 69
114487: PPUSH
114488: LD_VAR 0 2
114492: PPUSH
114493: CALL_OW 74
114497: PPUSH
114498: CALL_OW 115
// until IsDead ( un ) ;
114502: LD_VAR 0 2
114506: PPUSH
114507: CALL_OW 301
114511: IFFALSE 114459
// end ;
114513: PPOPN 2
114515: END
// every 0 0$1 trigger StreamModeActive and sStu do
114516: LD_EXP 160
114520: PUSH
114521: LD_EXP 199
114525: AND
114526: IFFALSE 114542
114528: GO 114530
114530: DISABLE
// begin ToLua ( displayStucuk(); ) ;
114531: LD_STRING displayStucuk();
114533: PPUSH
114534: CALL_OW 559
// ResetFog ;
114538: CALL_OW 335
// end ;
114542: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
114543: LD_EXP 160
114547: PUSH
114548: LD_EXP 192
114552: AND
114553: IFFALSE 114694
114555: GO 114557
114557: DISABLE
114558: LD_INT 0
114560: PPUSH
114561: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
114562: LD_ADDR_VAR 0 2
114566: PUSH
114567: LD_INT 22
114569: PUSH
114570: LD_OWVAR 2
114574: PUSH
114575: EMPTY
114576: LIST
114577: LIST
114578: PUSH
114579: LD_INT 21
114581: PUSH
114582: LD_INT 1
114584: PUSH
114585: EMPTY
114586: LIST
114587: LIST
114588: PUSH
114589: EMPTY
114590: LIST
114591: LIST
114592: PPUSH
114593: CALL_OW 69
114597: ST_TO_ADDR
// if not tmp then
114598: LD_VAR 0 2
114602: NOT
114603: IFFALSE 114607
// exit ;
114605: GO 114694
// un := tmp [ rand ( 1 , tmp ) ] ;
114607: LD_ADDR_VAR 0 1
114611: PUSH
114612: LD_VAR 0 2
114616: PUSH
114617: LD_INT 1
114619: PPUSH
114620: LD_VAR 0 2
114624: PPUSH
114625: CALL_OW 12
114629: ARRAY
114630: ST_TO_ADDR
// SetSide ( un , 0 ) ;
114631: LD_VAR 0 1
114635: PPUSH
114636: LD_INT 0
114638: PPUSH
114639: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
114643: LD_VAR 0 1
114647: PPUSH
114648: LD_OWVAR 3
114652: PUSH
114653: LD_VAR 0 1
114657: DIFF
114658: PPUSH
114659: LD_VAR 0 1
114663: PPUSH
114664: CALL_OW 74
114668: PPUSH
114669: CALL_OW 115
// wait ( 0 0$20 ) ;
114673: LD_INT 700
114675: PPUSH
114676: CALL_OW 67
// SetSide ( un , your_side ) ;
114680: LD_VAR 0 1
114684: PPUSH
114685: LD_OWVAR 2
114689: PPUSH
114690: CALL_OW 235
// end ;
114694: PPOPN 2
114696: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
114697: LD_EXP 160
114701: PUSH
114702: LD_EXP 193
114706: AND
114707: IFFALSE 114813
114709: GO 114711
114711: DISABLE
114712: LD_INT 0
114714: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
114715: LD_ADDR_VAR 0 1
114719: PUSH
114720: LD_INT 22
114722: PUSH
114723: LD_OWVAR 2
114727: PUSH
114728: EMPTY
114729: LIST
114730: LIST
114731: PUSH
114732: LD_INT 2
114734: PUSH
114735: LD_INT 30
114737: PUSH
114738: LD_INT 0
114740: PUSH
114741: EMPTY
114742: LIST
114743: LIST
114744: PUSH
114745: LD_INT 30
114747: PUSH
114748: LD_INT 1
114750: PUSH
114751: EMPTY
114752: LIST
114753: LIST
114754: PUSH
114755: EMPTY
114756: LIST
114757: LIST
114758: LIST
114759: PUSH
114760: EMPTY
114761: LIST
114762: LIST
114763: PPUSH
114764: CALL_OW 69
114768: ST_TO_ADDR
// if not depot then
114769: LD_VAR 0 1
114773: NOT
114774: IFFALSE 114778
// exit ;
114776: GO 114813
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
114778: LD_VAR 0 1
114782: PUSH
114783: LD_INT 1
114785: ARRAY
114786: PPUSH
114787: CALL_OW 250
114791: PPUSH
114792: LD_VAR 0 1
114796: PUSH
114797: LD_INT 1
114799: ARRAY
114800: PPUSH
114801: CALL_OW 251
114805: PPUSH
114806: LD_INT 70
114808: PPUSH
114809: CALL_OW 495
// end ;
114813: PPOPN 1
114815: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
114816: LD_EXP 160
114820: PUSH
114821: LD_EXP 194
114825: AND
114826: IFFALSE 115037
114828: GO 114830
114830: DISABLE
114831: LD_INT 0
114833: PPUSH
114834: PPUSH
114835: PPUSH
114836: PPUSH
114837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
114838: LD_ADDR_VAR 0 5
114842: PUSH
114843: LD_INT 22
114845: PUSH
114846: LD_OWVAR 2
114850: PUSH
114851: EMPTY
114852: LIST
114853: LIST
114854: PUSH
114855: LD_INT 21
114857: PUSH
114858: LD_INT 1
114860: PUSH
114861: EMPTY
114862: LIST
114863: LIST
114864: PUSH
114865: EMPTY
114866: LIST
114867: LIST
114868: PPUSH
114869: CALL_OW 69
114873: ST_TO_ADDR
// if not tmp then
114874: LD_VAR 0 5
114878: NOT
114879: IFFALSE 114883
// exit ;
114881: GO 115037
// for i in tmp do
114883: LD_ADDR_VAR 0 1
114887: PUSH
114888: LD_VAR 0 5
114892: PUSH
114893: FOR_IN
114894: IFFALSE 115035
// begin d := rand ( 0 , 5 ) ;
114896: LD_ADDR_VAR 0 4
114900: PUSH
114901: LD_INT 0
114903: PPUSH
114904: LD_INT 5
114906: PPUSH
114907: CALL_OW 12
114911: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
114912: LD_ADDR_VAR 0 2
114916: PUSH
114917: LD_VAR 0 1
114921: PPUSH
114922: CALL_OW 250
114926: PPUSH
114927: LD_VAR 0 4
114931: PPUSH
114932: LD_INT 3
114934: PPUSH
114935: LD_INT 12
114937: PPUSH
114938: CALL_OW 12
114942: PPUSH
114943: CALL_OW 272
114947: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
114948: LD_ADDR_VAR 0 3
114952: PUSH
114953: LD_VAR 0 1
114957: PPUSH
114958: CALL_OW 251
114962: PPUSH
114963: LD_VAR 0 4
114967: PPUSH
114968: LD_INT 3
114970: PPUSH
114971: LD_INT 12
114973: PPUSH
114974: CALL_OW 12
114978: PPUSH
114979: CALL_OW 273
114983: ST_TO_ADDR
// if ValidHex ( x , y ) then
114984: LD_VAR 0 2
114988: PPUSH
114989: LD_VAR 0 3
114993: PPUSH
114994: CALL_OW 488
114998: IFFALSE 115033
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
115000: LD_VAR 0 1
115004: PPUSH
115005: LD_VAR 0 2
115009: PPUSH
115010: LD_VAR 0 3
115014: PPUSH
115015: LD_INT 3
115017: PPUSH
115018: LD_INT 6
115020: PPUSH
115021: CALL_OW 12
115025: PPUSH
115026: LD_INT 1
115028: PPUSH
115029: CALL_OW 483
// end ;
115033: GO 114893
115035: POP
115036: POP
// end ;
115037: PPOPN 5
115039: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
115040: LD_EXP 160
115044: PUSH
115045: LD_EXP 195
115049: AND
115050: IFFALSE 115144
115052: GO 115054
115054: DISABLE
115055: LD_INT 0
115057: PPUSH
115058: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
115059: LD_ADDR_VAR 0 2
115063: PUSH
115064: LD_INT 22
115066: PUSH
115067: LD_OWVAR 2
115071: PUSH
115072: EMPTY
115073: LIST
115074: LIST
115075: PUSH
115076: LD_INT 32
115078: PUSH
115079: LD_INT 1
115081: PUSH
115082: EMPTY
115083: LIST
115084: LIST
115085: PUSH
115086: LD_INT 21
115088: PUSH
115089: LD_INT 2
115091: PUSH
115092: EMPTY
115093: LIST
115094: LIST
115095: PUSH
115096: EMPTY
115097: LIST
115098: LIST
115099: LIST
115100: PPUSH
115101: CALL_OW 69
115105: ST_TO_ADDR
// if not tmp then
115106: LD_VAR 0 2
115110: NOT
115111: IFFALSE 115115
// exit ;
115113: GO 115144
// for i in tmp do
115115: LD_ADDR_VAR 0 1
115119: PUSH
115120: LD_VAR 0 2
115124: PUSH
115125: FOR_IN
115126: IFFALSE 115142
// SetFuel ( i , 0 ) ;
115128: LD_VAR 0 1
115132: PPUSH
115133: LD_INT 0
115135: PPUSH
115136: CALL_OW 240
115140: GO 115125
115142: POP
115143: POP
// end ;
115144: PPOPN 2
115146: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
115147: LD_EXP 160
115151: PUSH
115152: LD_EXP 196
115156: AND
115157: IFFALSE 115223
115159: GO 115161
115161: DISABLE
115162: LD_INT 0
115164: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
115165: LD_ADDR_VAR 0 1
115169: PUSH
115170: LD_INT 22
115172: PUSH
115173: LD_OWVAR 2
115177: PUSH
115178: EMPTY
115179: LIST
115180: LIST
115181: PUSH
115182: LD_INT 30
115184: PUSH
115185: LD_INT 29
115187: PUSH
115188: EMPTY
115189: LIST
115190: LIST
115191: PUSH
115192: EMPTY
115193: LIST
115194: LIST
115195: PPUSH
115196: CALL_OW 69
115200: ST_TO_ADDR
// if not tmp then
115201: LD_VAR 0 1
115205: NOT
115206: IFFALSE 115210
// exit ;
115208: GO 115223
// DestroyUnit ( tmp [ 1 ] ) ;
115210: LD_VAR 0 1
115214: PUSH
115215: LD_INT 1
115217: ARRAY
115218: PPUSH
115219: CALL_OW 65
// end ;
115223: PPOPN 1
115225: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
115226: LD_EXP 160
115230: PUSH
115231: LD_EXP 198
115235: AND
115236: IFFALSE 115365
115238: GO 115240
115240: DISABLE
115241: LD_INT 0
115243: PPUSH
// begin uc_side := 0 ;
115244: LD_ADDR_OWVAR 20
115248: PUSH
115249: LD_INT 0
115251: ST_TO_ADDR
// uc_nation := nation_arabian ;
115252: LD_ADDR_OWVAR 21
115256: PUSH
115257: LD_INT 2
115259: ST_TO_ADDR
// hc_gallery :=  ;
115260: LD_ADDR_OWVAR 33
115264: PUSH
115265: LD_STRING 
115267: ST_TO_ADDR
// hc_name :=  ;
115268: LD_ADDR_OWVAR 26
115272: PUSH
115273: LD_STRING 
115275: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
115276: LD_INT 1
115278: PPUSH
115279: LD_INT 11
115281: PPUSH
115282: LD_INT 10
115284: PPUSH
115285: CALL_OW 380
// un := CreateHuman ;
115289: LD_ADDR_VAR 0 1
115293: PUSH
115294: CALL_OW 44
115298: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
115299: LD_VAR 0 1
115303: PPUSH
115304: LD_INT 1
115306: PPUSH
115307: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
115311: LD_INT 35
115313: PPUSH
115314: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
115318: LD_VAR 0 1
115322: PPUSH
115323: LD_INT 22
115325: PUSH
115326: LD_OWVAR 2
115330: PUSH
115331: EMPTY
115332: LIST
115333: LIST
115334: PPUSH
115335: CALL_OW 69
115339: PPUSH
115340: LD_VAR 0 1
115344: PPUSH
115345: CALL_OW 74
115349: PPUSH
115350: CALL_OW 115
// until IsDead ( un ) ;
115354: LD_VAR 0 1
115358: PPUSH
115359: CALL_OW 301
115363: IFFALSE 115311
// end ;
115365: PPOPN 1
115367: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
115368: LD_EXP 160
115372: PUSH
115373: LD_EXP 200
115377: AND
115378: IFFALSE 115390
115380: GO 115382
115382: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
115383: LD_STRING earthquake(getX(game), 0, 32)
115385: PPUSH
115386: CALL_OW 559
115390: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
115391: LD_EXP 160
115395: PUSH
115396: LD_EXP 201
115400: AND
115401: IFFALSE 115492
115403: GO 115405
115405: DISABLE
115406: LD_INT 0
115408: PPUSH
// begin enable ;
115409: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
115410: LD_ADDR_VAR 0 1
115414: PUSH
115415: LD_INT 22
115417: PUSH
115418: LD_OWVAR 2
115422: PUSH
115423: EMPTY
115424: LIST
115425: LIST
115426: PUSH
115427: LD_INT 21
115429: PUSH
115430: LD_INT 2
115432: PUSH
115433: EMPTY
115434: LIST
115435: LIST
115436: PUSH
115437: LD_INT 33
115439: PUSH
115440: LD_INT 3
115442: PUSH
115443: EMPTY
115444: LIST
115445: LIST
115446: PUSH
115447: EMPTY
115448: LIST
115449: LIST
115450: LIST
115451: PPUSH
115452: CALL_OW 69
115456: ST_TO_ADDR
// if not tmp then
115457: LD_VAR 0 1
115461: NOT
115462: IFFALSE 115466
// exit ;
115464: GO 115492
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
115466: LD_VAR 0 1
115470: PUSH
115471: LD_INT 1
115473: PPUSH
115474: LD_VAR 0 1
115478: PPUSH
115479: CALL_OW 12
115483: ARRAY
115484: PPUSH
115485: LD_INT 1
115487: PPUSH
115488: CALL_OW 234
// end ;
115492: PPOPN 1
115494: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
115495: LD_EXP 160
115499: PUSH
115500: LD_EXP 202
115504: AND
115505: IFFALSE 115646
115507: GO 115509
115509: DISABLE
115510: LD_INT 0
115512: PPUSH
115513: PPUSH
115514: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
115515: LD_ADDR_VAR 0 3
115519: PUSH
115520: LD_INT 22
115522: PUSH
115523: LD_OWVAR 2
115527: PUSH
115528: EMPTY
115529: LIST
115530: LIST
115531: PUSH
115532: LD_INT 25
115534: PUSH
115535: LD_INT 1
115537: PUSH
115538: EMPTY
115539: LIST
115540: LIST
115541: PUSH
115542: EMPTY
115543: LIST
115544: LIST
115545: PPUSH
115546: CALL_OW 69
115550: ST_TO_ADDR
// if not tmp then
115551: LD_VAR 0 3
115555: NOT
115556: IFFALSE 115560
// exit ;
115558: GO 115646
// un := tmp [ rand ( 1 , tmp ) ] ;
115560: LD_ADDR_VAR 0 2
115564: PUSH
115565: LD_VAR 0 3
115569: PUSH
115570: LD_INT 1
115572: PPUSH
115573: LD_VAR 0 3
115577: PPUSH
115578: CALL_OW 12
115582: ARRAY
115583: ST_TO_ADDR
// if Crawls ( un ) then
115584: LD_VAR 0 2
115588: PPUSH
115589: CALL_OW 318
115593: IFFALSE 115604
// ComWalk ( un ) ;
115595: LD_VAR 0 2
115599: PPUSH
115600: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
115604: LD_VAR 0 2
115608: PPUSH
115609: LD_INT 9
115611: PPUSH
115612: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
115616: LD_INT 28
115618: PPUSH
115619: LD_OWVAR 2
115623: PPUSH
115624: LD_INT 2
115626: PPUSH
115627: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
115631: LD_INT 29
115633: PPUSH
115634: LD_OWVAR 2
115638: PPUSH
115639: LD_INT 2
115641: PPUSH
115642: CALL_OW 322
// end ;
115646: PPOPN 3
115648: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
115649: LD_EXP 160
115653: PUSH
115654: LD_EXP 203
115658: AND
115659: IFFALSE 115770
115661: GO 115663
115663: DISABLE
115664: LD_INT 0
115666: PPUSH
115667: PPUSH
115668: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
115669: LD_ADDR_VAR 0 3
115673: PUSH
115674: LD_INT 22
115676: PUSH
115677: LD_OWVAR 2
115681: PUSH
115682: EMPTY
115683: LIST
115684: LIST
115685: PUSH
115686: LD_INT 25
115688: PUSH
115689: LD_INT 1
115691: PUSH
115692: EMPTY
115693: LIST
115694: LIST
115695: PUSH
115696: EMPTY
115697: LIST
115698: LIST
115699: PPUSH
115700: CALL_OW 69
115704: ST_TO_ADDR
// if not tmp then
115705: LD_VAR 0 3
115709: NOT
115710: IFFALSE 115714
// exit ;
115712: GO 115770
// un := tmp [ rand ( 1 , tmp ) ] ;
115714: LD_ADDR_VAR 0 2
115718: PUSH
115719: LD_VAR 0 3
115723: PUSH
115724: LD_INT 1
115726: PPUSH
115727: LD_VAR 0 3
115731: PPUSH
115732: CALL_OW 12
115736: ARRAY
115737: ST_TO_ADDR
// if Crawls ( un ) then
115738: LD_VAR 0 2
115742: PPUSH
115743: CALL_OW 318
115747: IFFALSE 115758
// ComWalk ( un ) ;
115749: LD_VAR 0 2
115753: PPUSH
115754: CALL_OW 138
// SetClass ( un , class_mortar ) ;
115758: LD_VAR 0 2
115762: PPUSH
115763: LD_INT 8
115765: PPUSH
115766: CALL_OW 336
// end ;
115770: PPOPN 3
115772: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
115773: LD_EXP 160
115777: PUSH
115778: LD_EXP 204
115782: AND
115783: IFFALSE 115927
115785: GO 115787
115787: DISABLE
115788: LD_INT 0
115790: PPUSH
115791: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
115792: LD_ADDR_VAR 0 2
115796: PUSH
115797: LD_INT 22
115799: PUSH
115800: LD_OWVAR 2
115804: PUSH
115805: EMPTY
115806: LIST
115807: LIST
115808: PUSH
115809: LD_INT 21
115811: PUSH
115812: LD_INT 2
115814: PUSH
115815: EMPTY
115816: LIST
115817: LIST
115818: PUSH
115819: LD_INT 2
115821: PUSH
115822: LD_INT 34
115824: PUSH
115825: LD_INT 12
115827: PUSH
115828: EMPTY
115829: LIST
115830: LIST
115831: PUSH
115832: LD_INT 34
115834: PUSH
115835: LD_INT 51
115837: PUSH
115838: EMPTY
115839: LIST
115840: LIST
115841: PUSH
115842: LD_INT 34
115844: PUSH
115845: LD_INT 32
115847: PUSH
115848: EMPTY
115849: LIST
115850: LIST
115851: PUSH
115852: EMPTY
115853: LIST
115854: LIST
115855: LIST
115856: LIST
115857: PUSH
115858: EMPTY
115859: LIST
115860: LIST
115861: LIST
115862: PPUSH
115863: CALL_OW 69
115867: ST_TO_ADDR
// if not tmp then
115868: LD_VAR 0 2
115872: NOT
115873: IFFALSE 115877
// exit ;
115875: GO 115927
// for i in tmp do
115877: LD_ADDR_VAR 0 1
115881: PUSH
115882: LD_VAR 0 2
115886: PUSH
115887: FOR_IN
115888: IFFALSE 115925
// if GetCargo ( i , mat_artifact ) = 0 then
115890: LD_VAR 0 1
115894: PPUSH
115895: LD_INT 4
115897: PPUSH
115898: CALL_OW 289
115902: PUSH
115903: LD_INT 0
115905: EQUAL
115906: IFFALSE 115923
// SetCargo ( i , mat_siberit , 100 ) ;
115908: LD_VAR 0 1
115912: PPUSH
115913: LD_INT 3
115915: PPUSH
115916: LD_INT 100
115918: PPUSH
115919: CALL_OW 290
115923: GO 115887
115925: POP
115926: POP
// end ;
115927: PPOPN 2
115929: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
115930: LD_EXP 160
115934: PUSH
115935: LD_EXP 205
115939: AND
115940: IFFALSE 116123
115942: GO 115944
115944: DISABLE
115945: LD_INT 0
115947: PPUSH
115948: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
115949: LD_ADDR_VAR 0 2
115953: PUSH
115954: LD_INT 22
115956: PUSH
115957: LD_OWVAR 2
115961: PUSH
115962: EMPTY
115963: LIST
115964: LIST
115965: PPUSH
115966: CALL_OW 69
115970: ST_TO_ADDR
// if not tmp then
115971: LD_VAR 0 2
115975: NOT
115976: IFFALSE 115980
// exit ;
115978: GO 116123
// for i := 1 to 2 do
115980: LD_ADDR_VAR 0 1
115984: PUSH
115985: DOUBLE
115986: LD_INT 1
115988: DEC
115989: ST_TO_ADDR
115990: LD_INT 2
115992: PUSH
115993: FOR_TO
115994: IFFALSE 116121
// begin uc_side := your_side ;
115996: LD_ADDR_OWVAR 20
116000: PUSH
116001: LD_OWVAR 2
116005: ST_TO_ADDR
// uc_nation := nation_american ;
116006: LD_ADDR_OWVAR 21
116010: PUSH
116011: LD_INT 1
116013: ST_TO_ADDR
// vc_chassis := us_morphling ;
116014: LD_ADDR_OWVAR 37
116018: PUSH
116019: LD_INT 5
116021: ST_TO_ADDR
// vc_engine := engine_siberite ;
116022: LD_ADDR_OWVAR 39
116026: PUSH
116027: LD_INT 3
116029: ST_TO_ADDR
// vc_control := control_computer ;
116030: LD_ADDR_OWVAR 38
116034: PUSH
116035: LD_INT 3
116037: ST_TO_ADDR
// vc_weapon := us_double_laser ;
116038: LD_ADDR_OWVAR 40
116042: PUSH
116043: LD_INT 10
116045: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
116046: LD_VAR 0 2
116050: PUSH
116051: LD_INT 1
116053: ARRAY
116054: PPUSH
116055: CALL_OW 310
116059: NOT
116060: IFFALSE 116107
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
116062: CALL_OW 45
116066: PPUSH
116067: LD_VAR 0 2
116071: PUSH
116072: LD_INT 1
116074: ARRAY
116075: PPUSH
116076: CALL_OW 250
116080: PPUSH
116081: LD_VAR 0 2
116085: PUSH
116086: LD_INT 1
116088: ARRAY
116089: PPUSH
116090: CALL_OW 251
116094: PPUSH
116095: LD_INT 12
116097: PPUSH
116098: LD_INT 1
116100: PPUSH
116101: CALL_OW 50
116105: GO 116119
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
116107: CALL_OW 45
116111: PPUSH
116112: LD_INT 1
116114: PPUSH
116115: CALL_OW 51
// end ;
116119: GO 115993
116121: POP
116122: POP
// end ;
116123: PPOPN 2
116125: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
116126: LD_EXP 160
116130: PUSH
116131: LD_EXP 206
116135: AND
116136: IFFALSE 116358
116138: GO 116140
116140: DISABLE
116141: LD_INT 0
116143: PPUSH
116144: PPUSH
116145: PPUSH
116146: PPUSH
116147: PPUSH
116148: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
116149: LD_ADDR_VAR 0 6
116153: PUSH
116154: LD_INT 22
116156: PUSH
116157: LD_OWVAR 2
116161: PUSH
116162: EMPTY
116163: LIST
116164: LIST
116165: PUSH
116166: LD_INT 21
116168: PUSH
116169: LD_INT 1
116171: PUSH
116172: EMPTY
116173: LIST
116174: LIST
116175: PUSH
116176: LD_INT 3
116178: PUSH
116179: LD_INT 23
116181: PUSH
116182: LD_INT 0
116184: PUSH
116185: EMPTY
116186: LIST
116187: LIST
116188: PUSH
116189: EMPTY
116190: LIST
116191: LIST
116192: PUSH
116193: EMPTY
116194: LIST
116195: LIST
116196: LIST
116197: PPUSH
116198: CALL_OW 69
116202: ST_TO_ADDR
// if not tmp then
116203: LD_VAR 0 6
116207: NOT
116208: IFFALSE 116212
// exit ;
116210: GO 116358
// s1 := rand ( 1 , 4 ) ;
116212: LD_ADDR_VAR 0 2
116216: PUSH
116217: LD_INT 1
116219: PPUSH
116220: LD_INT 4
116222: PPUSH
116223: CALL_OW 12
116227: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
116228: LD_ADDR_VAR 0 4
116232: PUSH
116233: LD_VAR 0 6
116237: PUSH
116238: LD_INT 1
116240: ARRAY
116241: PPUSH
116242: LD_VAR 0 2
116246: PPUSH
116247: CALL_OW 259
116251: ST_TO_ADDR
// if s1 = 1 then
116252: LD_VAR 0 2
116256: PUSH
116257: LD_INT 1
116259: EQUAL
116260: IFFALSE 116280
// s2 := rand ( 2 , 4 ) else
116262: LD_ADDR_VAR 0 3
116266: PUSH
116267: LD_INT 2
116269: PPUSH
116270: LD_INT 4
116272: PPUSH
116273: CALL_OW 12
116277: ST_TO_ADDR
116278: GO 116288
// s2 := 1 ;
116280: LD_ADDR_VAR 0 3
116284: PUSH
116285: LD_INT 1
116287: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
116288: LD_ADDR_VAR 0 5
116292: PUSH
116293: LD_VAR 0 6
116297: PUSH
116298: LD_INT 1
116300: ARRAY
116301: PPUSH
116302: LD_VAR 0 3
116306: PPUSH
116307: CALL_OW 259
116311: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
116312: LD_VAR 0 6
116316: PUSH
116317: LD_INT 1
116319: ARRAY
116320: PPUSH
116321: LD_VAR 0 2
116325: PPUSH
116326: LD_VAR 0 5
116330: PPUSH
116331: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
116335: LD_VAR 0 6
116339: PUSH
116340: LD_INT 1
116342: ARRAY
116343: PPUSH
116344: LD_VAR 0 3
116348: PPUSH
116349: LD_VAR 0 4
116353: PPUSH
116354: CALL_OW 237
// end ;
116358: PPOPN 6
116360: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
116361: LD_EXP 160
116365: PUSH
116366: LD_EXP 207
116370: AND
116371: IFFALSE 116450
116373: GO 116375
116375: DISABLE
116376: LD_INT 0
116378: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
116379: LD_ADDR_VAR 0 1
116383: PUSH
116384: LD_INT 22
116386: PUSH
116387: LD_OWVAR 2
116391: PUSH
116392: EMPTY
116393: LIST
116394: LIST
116395: PUSH
116396: LD_INT 30
116398: PUSH
116399: LD_INT 3
116401: PUSH
116402: EMPTY
116403: LIST
116404: LIST
116405: PUSH
116406: EMPTY
116407: LIST
116408: LIST
116409: PPUSH
116410: CALL_OW 69
116414: ST_TO_ADDR
// if not tmp then
116415: LD_VAR 0 1
116419: NOT
116420: IFFALSE 116424
// exit ;
116422: GO 116450
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
116424: LD_VAR 0 1
116428: PUSH
116429: LD_INT 1
116431: PPUSH
116432: LD_VAR 0 1
116436: PPUSH
116437: CALL_OW 12
116441: ARRAY
116442: PPUSH
116443: LD_INT 1
116445: PPUSH
116446: CALL_OW 234
// end ;
116450: PPOPN 1
116452: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
116453: LD_EXP 160
116457: PUSH
116458: LD_EXP 208
116462: AND
116463: IFFALSE 116575
116465: GO 116467
116467: DISABLE
116468: LD_INT 0
116470: PPUSH
116471: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
116472: LD_ADDR_VAR 0 2
116476: PUSH
116477: LD_INT 22
116479: PUSH
116480: LD_OWVAR 2
116484: PUSH
116485: EMPTY
116486: LIST
116487: LIST
116488: PUSH
116489: LD_INT 2
116491: PUSH
116492: LD_INT 30
116494: PUSH
116495: LD_INT 27
116497: PUSH
116498: EMPTY
116499: LIST
116500: LIST
116501: PUSH
116502: LD_INT 30
116504: PUSH
116505: LD_INT 26
116507: PUSH
116508: EMPTY
116509: LIST
116510: LIST
116511: PUSH
116512: LD_INT 30
116514: PUSH
116515: LD_INT 28
116517: PUSH
116518: EMPTY
116519: LIST
116520: LIST
116521: PUSH
116522: EMPTY
116523: LIST
116524: LIST
116525: LIST
116526: LIST
116527: PUSH
116528: EMPTY
116529: LIST
116530: LIST
116531: PPUSH
116532: CALL_OW 69
116536: ST_TO_ADDR
// if not tmp then
116537: LD_VAR 0 2
116541: NOT
116542: IFFALSE 116546
// exit ;
116544: GO 116575
// for i in tmp do
116546: LD_ADDR_VAR 0 1
116550: PUSH
116551: LD_VAR 0 2
116555: PUSH
116556: FOR_IN
116557: IFFALSE 116573
// SetLives ( i , 1 ) ;
116559: LD_VAR 0 1
116563: PPUSH
116564: LD_INT 1
116566: PPUSH
116567: CALL_OW 234
116571: GO 116556
116573: POP
116574: POP
// end ;
116575: PPOPN 2
116577: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
116578: LD_EXP 160
116582: PUSH
116583: LD_EXP 209
116587: AND
116588: IFFALSE 116875
116590: GO 116592
116592: DISABLE
116593: LD_INT 0
116595: PPUSH
116596: PPUSH
116597: PPUSH
// begin i := rand ( 1 , 7 ) ;
116598: LD_ADDR_VAR 0 1
116602: PUSH
116603: LD_INT 1
116605: PPUSH
116606: LD_INT 7
116608: PPUSH
116609: CALL_OW 12
116613: ST_TO_ADDR
// case i of 1 :
116614: LD_VAR 0 1
116618: PUSH
116619: LD_INT 1
116621: DOUBLE
116622: EQUAL
116623: IFTRUE 116627
116625: GO 116637
116627: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
116628: LD_STRING earthquake(getX(game), 0, 32)
116630: PPUSH
116631: CALL_OW 559
116635: GO 116875
116637: LD_INT 2
116639: DOUBLE
116640: EQUAL
116641: IFTRUE 116645
116643: GO 116659
116645: POP
// begin ToLua ( displayStucuk(); ) ;
116646: LD_STRING displayStucuk();
116648: PPUSH
116649: CALL_OW 559
// ResetFog ;
116653: CALL_OW 335
// end ; 3 :
116657: GO 116875
116659: LD_INT 3
116661: DOUBLE
116662: EQUAL
116663: IFTRUE 116667
116665: GO 116771
116667: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
116668: LD_ADDR_VAR 0 2
116672: PUSH
116673: LD_INT 22
116675: PUSH
116676: LD_OWVAR 2
116680: PUSH
116681: EMPTY
116682: LIST
116683: LIST
116684: PUSH
116685: LD_INT 25
116687: PUSH
116688: LD_INT 1
116690: PUSH
116691: EMPTY
116692: LIST
116693: LIST
116694: PUSH
116695: EMPTY
116696: LIST
116697: LIST
116698: PPUSH
116699: CALL_OW 69
116703: ST_TO_ADDR
// if not tmp then
116704: LD_VAR 0 2
116708: NOT
116709: IFFALSE 116713
// exit ;
116711: GO 116875
// un := tmp [ rand ( 1 , tmp ) ] ;
116713: LD_ADDR_VAR 0 3
116717: PUSH
116718: LD_VAR 0 2
116722: PUSH
116723: LD_INT 1
116725: PPUSH
116726: LD_VAR 0 2
116730: PPUSH
116731: CALL_OW 12
116735: ARRAY
116736: ST_TO_ADDR
// if Crawls ( un ) then
116737: LD_VAR 0 3
116741: PPUSH
116742: CALL_OW 318
116746: IFFALSE 116757
// ComWalk ( un ) ;
116748: LD_VAR 0 3
116752: PPUSH
116753: CALL_OW 138
// SetClass ( un , class_mortar ) ;
116757: LD_VAR 0 3
116761: PPUSH
116762: LD_INT 8
116764: PPUSH
116765: CALL_OW 336
// end ; 4 :
116769: GO 116875
116771: LD_INT 4
116773: DOUBLE
116774: EQUAL
116775: IFTRUE 116779
116777: GO 116853
116779: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
116780: LD_ADDR_VAR 0 2
116784: PUSH
116785: LD_INT 22
116787: PUSH
116788: LD_OWVAR 2
116792: PUSH
116793: EMPTY
116794: LIST
116795: LIST
116796: PUSH
116797: LD_INT 30
116799: PUSH
116800: LD_INT 29
116802: PUSH
116803: EMPTY
116804: LIST
116805: LIST
116806: PUSH
116807: EMPTY
116808: LIST
116809: LIST
116810: PPUSH
116811: CALL_OW 69
116815: ST_TO_ADDR
// if not tmp then
116816: LD_VAR 0 2
116820: NOT
116821: IFFALSE 116825
// exit ;
116823: GO 116875
// CenterNowOnUnits ( tmp [ 1 ] ) ;
116825: LD_VAR 0 2
116829: PUSH
116830: LD_INT 1
116832: ARRAY
116833: PPUSH
116834: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
116838: LD_VAR 0 2
116842: PUSH
116843: LD_INT 1
116845: ARRAY
116846: PPUSH
116847: CALL_OW 65
// end ; 5 .. 7 :
116851: GO 116875
116853: LD_INT 5
116855: DOUBLE
116856: GREATEREQUAL
116857: IFFALSE 116865
116859: LD_INT 7
116861: DOUBLE
116862: LESSEQUAL
116863: IFTRUE 116867
116865: GO 116874
116867: POP
// StreamSibBomb ; end ;
116868: CALL 113112 0 0
116872: GO 116875
116874: POP
// end ;
116875: PPOPN 3
116877: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
116878: LD_EXP 160
116882: PUSH
116883: LD_EXP 210
116887: AND
116888: IFFALSE 117044
116890: GO 116892
116892: DISABLE
116893: LD_INT 0
116895: PPUSH
116896: PPUSH
116897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
116898: LD_ADDR_VAR 0 2
116902: PUSH
116903: LD_INT 81
116905: PUSH
116906: LD_OWVAR 2
116910: PUSH
116911: EMPTY
116912: LIST
116913: LIST
116914: PUSH
116915: LD_INT 2
116917: PUSH
116918: LD_INT 21
116920: PUSH
116921: LD_INT 1
116923: PUSH
116924: EMPTY
116925: LIST
116926: LIST
116927: PUSH
116928: LD_INT 21
116930: PUSH
116931: LD_INT 2
116933: PUSH
116934: EMPTY
116935: LIST
116936: LIST
116937: PUSH
116938: EMPTY
116939: LIST
116940: LIST
116941: LIST
116942: PUSH
116943: EMPTY
116944: LIST
116945: LIST
116946: PPUSH
116947: CALL_OW 69
116951: ST_TO_ADDR
// if not tmp then
116952: LD_VAR 0 2
116956: NOT
116957: IFFALSE 116961
// exit ;
116959: GO 117044
// p := 0 ;
116961: LD_ADDR_VAR 0 3
116965: PUSH
116966: LD_INT 0
116968: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
116969: LD_INT 35
116971: PPUSH
116972: CALL_OW 67
// p := p + 1 ;
116976: LD_ADDR_VAR 0 3
116980: PUSH
116981: LD_VAR 0 3
116985: PUSH
116986: LD_INT 1
116988: PLUS
116989: ST_TO_ADDR
// for i in tmp do
116990: LD_ADDR_VAR 0 1
116994: PUSH
116995: LD_VAR 0 2
116999: PUSH
117000: FOR_IN
117001: IFFALSE 117032
// if GetLives ( i ) < 1000 then
117003: LD_VAR 0 1
117007: PPUSH
117008: CALL_OW 256
117012: PUSH
117013: LD_INT 1000
117015: LESS
117016: IFFALSE 117030
// SetLives ( i , 1000 ) ;
117018: LD_VAR 0 1
117022: PPUSH
117023: LD_INT 1000
117025: PPUSH
117026: CALL_OW 234
117030: GO 117000
117032: POP
117033: POP
// until p > 20 ;
117034: LD_VAR 0 3
117038: PUSH
117039: LD_INT 20
117041: GREATER
117042: IFFALSE 116969
// end ;
117044: PPOPN 3
117046: END
// every 0 0$1 trigger StreamModeActive and sTime do
117047: LD_EXP 160
117051: PUSH
117052: LD_EXP 211
117056: AND
117057: IFFALSE 117092
117059: GO 117061
117061: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
117062: LD_INT 28
117064: PPUSH
117065: LD_OWVAR 2
117069: PPUSH
117070: LD_INT 2
117072: PPUSH
117073: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
117077: LD_INT 30
117079: PPUSH
117080: LD_OWVAR 2
117084: PPUSH
117085: LD_INT 2
117087: PPUSH
117088: CALL_OW 322
// end ;
117092: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
117093: LD_EXP 160
117097: PUSH
117098: LD_EXP 212
117102: AND
117103: IFFALSE 117224
117105: GO 117107
117107: DISABLE
117108: LD_INT 0
117110: PPUSH
117111: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
117112: LD_ADDR_VAR 0 2
117116: PUSH
117117: LD_INT 22
117119: PUSH
117120: LD_OWVAR 2
117124: PUSH
117125: EMPTY
117126: LIST
117127: LIST
117128: PUSH
117129: LD_INT 21
117131: PUSH
117132: LD_INT 1
117134: PUSH
117135: EMPTY
117136: LIST
117137: LIST
117138: PUSH
117139: LD_INT 3
117141: PUSH
117142: LD_INT 23
117144: PUSH
117145: LD_INT 0
117147: PUSH
117148: EMPTY
117149: LIST
117150: LIST
117151: PUSH
117152: EMPTY
117153: LIST
117154: LIST
117155: PUSH
117156: EMPTY
117157: LIST
117158: LIST
117159: LIST
117160: PPUSH
117161: CALL_OW 69
117165: ST_TO_ADDR
// if not tmp then
117166: LD_VAR 0 2
117170: NOT
117171: IFFALSE 117175
// exit ;
117173: GO 117224
// for i in tmp do
117175: LD_ADDR_VAR 0 1
117179: PUSH
117180: LD_VAR 0 2
117184: PUSH
117185: FOR_IN
117186: IFFALSE 117222
// begin if Crawls ( i ) then
117188: LD_VAR 0 1
117192: PPUSH
117193: CALL_OW 318
117197: IFFALSE 117208
// ComWalk ( i ) ;
117199: LD_VAR 0 1
117203: PPUSH
117204: CALL_OW 138
// SetClass ( i , 2 ) ;
117208: LD_VAR 0 1
117212: PPUSH
117213: LD_INT 2
117215: PPUSH
117216: CALL_OW 336
// end ;
117220: GO 117185
117222: POP
117223: POP
// end ;
117224: PPOPN 2
117226: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
117227: LD_EXP 160
117231: PUSH
117232: LD_EXP 213
117236: AND
117237: IFFALSE 117525
117239: GO 117241
117241: DISABLE
117242: LD_INT 0
117244: PPUSH
117245: PPUSH
117246: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
117247: LD_OWVAR 2
117251: PPUSH
117252: LD_INT 9
117254: PPUSH
117255: LD_INT 1
117257: PPUSH
117258: LD_INT 1
117260: PPUSH
117261: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
117265: LD_INT 9
117267: PPUSH
117268: LD_OWVAR 2
117272: PPUSH
117273: CALL_OW 343
// uc_side := 9 ;
117277: LD_ADDR_OWVAR 20
117281: PUSH
117282: LD_INT 9
117284: ST_TO_ADDR
// uc_nation := 2 ;
117285: LD_ADDR_OWVAR 21
117289: PUSH
117290: LD_INT 2
117292: ST_TO_ADDR
// hc_name := Dark Warrior ;
117293: LD_ADDR_OWVAR 26
117297: PUSH
117298: LD_STRING Dark Warrior
117300: ST_TO_ADDR
// hc_gallery :=  ;
117301: LD_ADDR_OWVAR 33
117305: PUSH
117306: LD_STRING 
117308: ST_TO_ADDR
// hc_noskilllimit := true ;
117309: LD_ADDR_OWVAR 76
117313: PUSH
117314: LD_INT 1
117316: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
117317: LD_ADDR_OWVAR 31
117321: PUSH
117322: LD_INT 30
117324: PUSH
117325: LD_INT 30
117327: PUSH
117328: LD_INT 30
117330: PUSH
117331: LD_INT 30
117333: PUSH
117334: EMPTY
117335: LIST
117336: LIST
117337: LIST
117338: LIST
117339: ST_TO_ADDR
// un := CreateHuman ;
117340: LD_ADDR_VAR 0 3
117344: PUSH
117345: CALL_OW 44
117349: ST_TO_ADDR
// hc_noskilllimit := false ;
117350: LD_ADDR_OWVAR 76
117354: PUSH
117355: LD_INT 0
117357: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
117358: LD_VAR 0 3
117362: PPUSH
117363: LD_INT 1
117365: PPUSH
117366: CALL_OW 51
// ToLua ( playRanger() ) ;
117370: LD_STRING playRanger()
117372: PPUSH
117373: CALL_OW 559
// p := 0 ;
117377: LD_ADDR_VAR 0 2
117381: PUSH
117382: LD_INT 0
117384: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
117385: LD_INT 35
117387: PPUSH
117388: CALL_OW 67
// p := p + 1 ;
117392: LD_ADDR_VAR 0 2
117396: PUSH
117397: LD_VAR 0 2
117401: PUSH
117402: LD_INT 1
117404: PLUS
117405: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
117406: LD_VAR 0 3
117410: PPUSH
117411: CALL_OW 256
117415: PUSH
117416: LD_INT 1000
117418: LESS
117419: IFFALSE 117433
// SetLives ( un , 1000 ) ;
117421: LD_VAR 0 3
117425: PPUSH
117426: LD_INT 1000
117428: PPUSH
117429: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
117433: LD_VAR 0 3
117437: PPUSH
117438: LD_INT 81
117440: PUSH
117441: LD_OWVAR 2
117445: PUSH
117446: EMPTY
117447: LIST
117448: LIST
117449: PUSH
117450: LD_INT 91
117452: PUSH
117453: LD_VAR 0 3
117457: PUSH
117458: LD_INT 30
117460: PUSH
117461: EMPTY
117462: LIST
117463: LIST
117464: LIST
117465: PUSH
117466: EMPTY
117467: LIST
117468: LIST
117469: PPUSH
117470: CALL_OW 69
117474: PPUSH
117475: LD_VAR 0 3
117479: PPUSH
117480: CALL_OW 74
117484: PPUSH
117485: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
117489: LD_VAR 0 2
117493: PUSH
117494: LD_INT 80
117496: GREATER
117497: PUSH
117498: LD_VAR 0 3
117502: PPUSH
117503: CALL_OW 301
117507: OR
117508: IFFALSE 117385
// if un then
117510: LD_VAR 0 3
117514: IFFALSE 117525
// RemoveUnit ( un ) ;
117516: LD_VAR 0 3
117520: PPUSH
117521: CALL_OW 64
// end ;
117525: PPOPN 3
117527: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
117528: LD_EXP 214
117532: IFFALSE 117648
117534: GO 117536
117536: DISABLE
117537: LD_INT 0
117539: PPUSH
117540: PPUSH
117541: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
117542: LD_ADDR_VAR 0 2
117546: PUSH
117547: LD_INT 81
117549: PUSH
117550: LD_OWVAR 2
117554: PUSH
117555: EMPTY
117556: LIST
117557: LIST
117558: PUSH
117559: LD_INT 21
117561: PUSH
117562: LD_INT 1
117564: PUSH
117565: EMPTY
117566: LIST
117567: LIST
117568: PUSH
117569: EMPTY
117570: LIST
117571: LIST
117572: PPUSH
117573: CALL_OW 69
117577: ST_TO_ADDR
// ToLua ( playComputer() ) ;
117578: LD_STRING playComputer()
117580: PPUSH
117581: CALL_OW 559
// if not tmp then
117585: LD_VAR 0 2
117589: NOT
117590: IFFALSE 117594
// exit ;
117592: GO 117648
// for i in tmp do
117594: LD_ADDR_VAR 0 1
117598: PUSH
117599: LD_VAR 0 2
117603: PUSH
117604: FOR_IN
117605: IFFALSE 117646
// for j := 1 to 4 do
117607: LD_ADDR_VAR 0 3
117611: PUSH
117612: DOUBLE
117613: LD_INT 1
117615: DEC
117616: ST_TO_ADDR
117617: LD_INT 4
117619: PUSH
117620: FOR_TO
117621: IFFALSE 117642
// SetSkill ( i , j , 10 ) ;
117623: LD_VAR 0 1
117627: PPUSH
117628: LD_VAR 0 3
117632: PPUSH
117633: LD_INT 10
117635: PPUSH
117636: CALL_OW 237
117640: GO 117620
117642: POP
117643: POP
117644: GO 117604
117646: POP
117647: POP
// end ;
117648: PPOPN 3
117650: END
// every 0 0$1 trigger s30 do var i , tmp ;
117651: LD_EXP 215
117655: IFFALSE 117724
117657: GO 117659
117659: DISABLE
117660: LD_INT 0
117662: PPUSH
117663: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
117664: LD_ADDR_VAR 0 2
117668: PUSH
117669: LD_INT 22
117671: PUSH
117672: LD_OWVAR 2
117676: PUSH
117677: EMPTY
117678: LIST
117679: LIST
117680: PPUSH
117681: CALL_OW 69
117685: ST_TO_ADDR
// if not tmp then
117686: LD_VAR 0 2
117690: NOT
117691: IFFALSE 117695
// exit ;
117693: GO 117724
// for i in tmp do
117695: LD_ADDR_VAR 0 1
117699: PUSH
117700: LD_VAR 0 2
117704: PUSH
117705: FOR_IN
117706: IFFALSE 117722
// SetLives ( i , 300 ) ;
117708: LD_VAR 0 1
117712: PPUSH
117713: LD_INT 300
117715: PPUSH
117716: CALL_OW 234
117720: GO 117705
117722: POP
117723: POP
// end ;
117724: PPOPN 2
117726: END
// every 0 0$1 trigger s60 do var i , tmp ;
117727: LD_EXP 216
117731: IFFALSE 117800
117733: GO 117735
117735: DISABLE
117736: LD_INT 0
117738: PPUSH
117739: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
117740: LD_ADDR_VAR 0 2
117744: PUSH
117745: LD_INT 22
117747: PUSH
117748: LD_OWVAR 2
117752: PUSH
117753: EMPTY
117754: LIST
117755: LIST
117756: PPUSH
117757: CALL_OW 69
117761: ST_TO_ADDR
// if not tmp then
117762: LD_VAR 0 2
117766: NOT
117767: IFFALSE 117771
// exit ;
117769: GO 117800
// for i in tmp do
117771: LD_ADDR_VAR 0 1
117775: PUSH
117776: LD_VAR 0 2
117780: PUSH
117781: FOR_IN
117782: IFFALSE 117798
// SetLives ( i , 600 ) ;
117784: LD_VAR 0 1
117788: PPUSH
117789: LD_INT 600
117791: PPUSH
117792: CALL_OW 234
117796: GO 117781
117798: POP
117799: POP
// end ;
117800: PPOPN 2
117802: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
117803: LD_INT 0
117805: PPUSH
// case cmd of 301 :
117806: LD_VAR 0 1
117810: PUSH
117811: LD_INT 301
117813: DOUBLE
117814: EQUAL
117815: IFTRUE 117819
117817: GO 117851
117819: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
117820: LD_VAR 0 6
117824: PPUSH
117825: LD_VAR 0 7
117829: PPUSH
117830: LD_VAR 0 8
117834: PPUSH
117835: LD_VAR 0 4
117839: PPUSH
117840: LD_VAR 0 5
117844: PPUSH
117845: CALL 119052 0 5
117849: GO 117972
117851: LD_INT 302
117853: DOUBLE
117854: EQUAL
117855: IFTRUE 117859
117857: GO 117896
117859: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
117860: LD_VAR 0 6
117864: PPUSH
117865: LD_VAR 0 7
117869: PPUSH
117870: LD_VAR 0 8
117874: PPUSH
117875: LD_VAR 0 9
117879: PPUSH
117880: LD_VAR 0 4
117884: PPUSH
117885: LD_VAR 0 5
117889: PPUSH
117890: CALL 119143 0 6
117894: GO 117972
117896: LD_INT 303
117898: DOUBLE
117899: EQUAL
117900: IFTRUE 117904
117902: GO 117941
117904: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
117905: LD_VAR 0 6
117909: PPUSH
117910: LD_VAR 0 7
117914: PPUSH
117915: LD_VAR 0 8
117919: PPUSH
117920: LD_VAR 0 9
117924: PPUSH
117925: LD_VAR 0 4
117929: PPUSH
117930: LD_VAR 0 5
117934: PPUSH
117935: CALL 117977 0 6
117939: GO 117972
117941: LD_INT 304
117943: DOUBLE
117944: EQUAL
117945: IFTRUE 117949
117947: GO 117971
117949: POP
// hHackTeleport ( unit , x , y ) ; end ;
117950: LD_VAR 0 2
117954: PPUSH
117955: LD_VAR 0 4
117959: PPUSH
117960: LD_VAR 0 5
117964: PPUSH
117965: CALL 119736 0 3
117969: GO 117972
117971: POP
// end ;
117972: LD_VAR 0 12
117976: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
117977: LD_INT 0
117979: PPUSH
117980: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
117981: LD_VAR 0 1
117985: PUSH
117986: LD_INT 1
117988: LESS
117989: PUSH
117990: LD_VAR 0 1
117994: PUSH
117995: LD_INT 3
117997: GREATER
117998: OR
117999: PUSH
118000: LD_VAR 0 5
118004: PPUSH
118005: LD_VAR 0 6
118009: PPUSH
118010: CALL_OW 428
118014: OR
118015: IFFALSE 118019
// exit ;
118017: GO 118739
// uc_side := your_side ;
118019: LD_ADDR_OWVAR 20
118023: PUSH
118024: LD_OWVAR 2
118028: ST_TO_ADDR
// uc_nation := nation ;
118029: LD_ADDR_OWVAR 21
118033: PUSH
118034: LD_VAR 0 1
118038: ST_TO_ADDR
// bc_level = 1 ;
118039: LD_ADDR_OWVAR 43
118043: PUSH
118044: LD_INT 1
118046: ST_TO_ADDR
// case btype of 1 :
118047: LD_VAR 0 2
118051: PUSH
118052: LD_INT 1
118054: DOUBLE
118055: EQUAL
118056: IFTRUE 118060
118058: GO 118071
118060: POP
// bc_type := b_depot ; 2 :
118061: LD_ADDR_OWVAR 42
118065: PUSH
118066: LD_INT 0
118068: ST_TO_ADDR
118069: GO 118683
118071: LD_INT 2
118073: DOUBLE
118074: EQUAL
118075: IFTRUE 118079
118077: GO 118090
118079: POP
// bc_type := b_warehouse ; 3 :
118080: LD_ADDR_OWVAR 42
118084: PUSH
118085: LD_INT 1
118087: ST_TO_ADDR
118088: GO 118683
118090: LD_INT 3
118092: DOUBLE
118093: EQUAL
118094: IFTRUE 118098
118096: GO 118109
118098: POP
// bc_type := b_lab ; 4 .. 9 :
118099: LD_ADDR_OWVAR 42
118103: PUSH
118104: LD_INT 6
118106: ST_TO_ADDR
118107: GO 118683
118109: LD_INT 4
118111: DOUBLE
118112: GREATEREQUAL
118113: IFFALSE 118121
118115: LD_INT 9
118117: DOUBLE
118118: LESSEQUAL
118119: IFTRUE 118123
118121: GO 118175
118123: POP
// begin bc_type := b_lab_half ;
118124: LD_ADDR_OWVAR 42
118128: PUSH
118129: LD_INT 7
118131: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
118132: LD_ADDR_OWVAR 44
118136: PUSH
118137: LD_INT 10
118139: PUSH
118140: LD_INT 11
118142: PUSH
118143: LD_INT 12
118145: PUSH
118146: LD_INT 15
118148: PUSH
118149: LD_INT 14
118151: PUSH
118152: LD_INT 13
118154: PUSH
118155: EMPTY
118156: LIST
118157: LIST
118158: LIST
118159: LIST
118160: LIST
118161: LIST
118162: PUSH
118163: LD_VAR 0 2
118167: PUSH
118168: LD_INT 3
118170: MINUS
118171: ARRAY
118172: ST_TO_ADDR
// end ; 10 .. 13 :
118173: GO 118683
118175: LD_INT 10
118177: DOUBLE
118178: GREATEREQUAL
118179: IFFALSE 118187
118181: LD_INT 13
118183: DOUBLE
118184: LESSEQUAL
118185: IFTRUE 118189
118187: GO 118266
118189: POP
// begin bc_type := b_lab_full ;
118190: LD_ADDR_OWVAR 42
118194: PUSH
118195: LD_INT 8
118197: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
118198: LD_ADDR_OWVAR 44
118202: PUSH
118203: LD_INT 10
118205: PUSH
118206: LD_INT 12
118208: PUSH
118209: LD_INT 14
118211: PUSH
118212: LD_INT 13
118214: PUSH
118215: EMPTY
118216: LIST
118217: LIST
118218: LIST
118219: LIST
118220: PUSH
118221: LD_VAR 0 2
118225: PUSH
118226: LD_INT 9
118228: MINUS
118229: ARRAY
118230: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
118231: LD_ADDR_OWVAR 45
118235: PUSH
118236: LD_INT 11
118238: PUSH
118239: LD_INT 15
118241: PUSH
118242: LD_INT 12
118244: PUSH
118245: LD_INT 15
118247: PUSH
118248: EMPTY
118249: LIST
118250: LIST
118251: LIST
118252: LIST
118253: PUSH
118254: LD_VAR 0 2
118258: PUSH
118259: LD_INT 9
118261: MINUS
118262: ARRAY
118263: ST_TO_ADDR
// end ; 14 :
118264: GO 118683
118266: LD_INT 14
118268: DOUBLE
118269: EQUAL
118270: IFTRUE 118274
118272: GO 118285
118274: POP
// bc_type := b_workshop ; 15 :
118275: LD_ADDR_OWVAR 42
118279: PUSH
118280: LD_INT 2
118282: ST_TO_ADDR
118283: GO 118683
118285: LD_INT 15
118287: DOUBLE
118288: EQUAL
118289: IFTRUE 118293
118291: GO 118304
118293: POP
// bc_type := b_factory ; 16 :
118294: LD_ADDR_OWVAR 42
118298: PUSH
118299: LD_INT 3
118301: ST_TO_ADDR
118302: GO 118683
118304: LD_INT 16
118306: DOUBLE
118307: EQUAL
118308: IFTRUE 118312
118310: GO 118323
118312: POP
// bc_type := b_ext_gun ; 17 :
118313: LD_ADDR_OWVAR 42
118317: PUSH
118318: LD_INT 17
118320: ST_TO_ADDR
118321: GO 118683
118323: LD_INT 17
118325: DOUBLE
118326: EQUAL
118327: IFTRUE 118331
118329: GO 118359
118331: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
118332: LD_ADDR_OWVAR 42
118336: PUSH
118337: LD_INT 19
118339: PUSH
118340: LD_INT 23
118342: PUSH
118343: LD_INT 19
118345: PUSH
118346: EMPTY
118347: LIST
118348: LIST
118349: LIST
118350: PUSH
118351: LD_VAR 0 1
118355: ARRAY
118356: ST_TO_ADDR
118357: GO 118683
118359: LD_INT 18
118361: DOUBLE
118362: EQUAL
118363: IFTRUE 118367
118365: GO 118378
118367: POP
// bc_type := b_ext_radar ; 19 :
118368: LD_ADDR_OWVAR 42
118372: PUSH
118373: LD_INT 20
118375: ST_TO_ADDR
118376: GO 118683
118378: LD_INT 19
118380: DOUBLE
118381: EQUAL
118382: IFTRUE 118386
118384: GO 118397
118386: POP
// bc_type := b_ext_radio ; 20 :
118387: LD_ADDR_OWVAR 42
118391: PUSH
118392: LD_INT 22
118394: ST_TO_ADDR
118395: GO 118683
118397: LD_INT 20
118399: DOUBLE
118400: EQUAL
118401: IFTRUE 118405
118403: GO 118416
118405: POP
// bc_type := b_ext_siberium ; 21 :
118406: LD_ADDR_OWVAR 42
118410: PUSH
118411: LD_INT 21
118413: ST_TO_ADDR
118414: GO 118683
118416: LD_INT 21
118418: DOUBLE
118419: EQUAL
118420: IFTRUE 118424
118422: GO 118435
118424: POP
// bc_type := b_ext_computer ; 22 :
118425: LD_ADDR_OWVAR 42
118429: PUSH
118430: LD_INT 24
118432: ST_TO_ADDR
118433: GO 118683
118435: LD_INT 22
118437: DOUBLE
118438: EQUAL
118439: IFTRUE 118443
118441: GO 118454
118443: POP
// bc_type := b_ext_track ; 23 :
118444: LD_ADDR_OWVAR 42
118448: PUSH
118449: LD_INT 16
118451: ST_TO_ADDR
118452: GO 118683
118454: LD_INT 23
118456: DOUBLE
118457: EQUAL
118458: IFTRUE 118462
118460: GO 118473
118462: POP
// bc_type := b_ext_laser ; 24 :
118463: LD_ADDR_OWVAR 42
118467: PUSH
118468: LD_INT 25
118470: ST_TO_ADDR
118471: GO 118683
118473: LD_INT 24
118475: DOUBLE
118476: EQUAL
118477: IFTRUE 118481
118479: GO 118492
118481: POP
// bc_type := b_control_tower ; 25 :
118482: LD_ADDR_OWVAR 42
118486: PUSH
118487: LD_INT 36
118489: ST_TO_ADDR
118490: GO 118683
118492: LD_INT 25
118494: DOUBLE
118495: EQUAL
118496: IFTRUE 118500
118498: GO 118511
118500: POP
// bc_type := b_breastwork ; 26 :
118501: LD_ADDR_OWVAR 42
118505: PUSH
118506: LD_INT 31
118508: ST_TO_ADDR
118509: GO 118683
118511: LD_INT 26
118513: DOUBLE
118514: EQUAL
118515: IFTRUE 118519
118517: GO 118530
118519: POP
// bc_type := b_bunker ; 27 :
118520: LD_ADDR_OWVAR 42
118524: PUSH
118525: LD_INT 32
118527: ST_TO_ADDR
118528: GO 118683
118530: LD_INT 27
118532: DOUBLE
118533: EQUAL
118534: IFTRUE 118538
118536: GO 118549
118538: POP
// bc_type := b_turret ; 28 :
118539: LD_ADDR_OWVAR 42
118543: PUSH
118544: LD_INT 33
118546: ST_TO_ADDR
118547: GO 118683
118549: LD_INT 28
118551: DOUBLE
118552: EQUAL
118553: IFTRUE 118557
118555: GO 118568
118557: POP
// bc_type := b_armoury ; 29 :
118558: LD_ADDR_OWVAR 42
118562: PUSH
118563: LD_INT 4
118565: ST_TO_ADDR
118566: GO 118683
118568: LD_INT 29
118570: DOUBLE
118571: EQUAL
118572: IFTRUE 118576
118574: GO 118587
118576: POP
// bc_type := b_barracks ; 30 :
118577: LD_ADDR_OWVAR 42
118581: PUSH
118582: LD_INT 5
118584: ST_TO_ADDR
118585: GO 118683
118587: LD_INT 30
118589: DOUBLE
118590: EQUAL
118591: IFTRUE 118595
118593: GO 118606
118595: POP
// bc_type := b_solar_power ; 31 :
118596: LD_ADDR_OWVAR 42
118600: PUSH
118601: LD_INT 27
118603: ST_TO_ADDR
118604: GO 118683
118606: LD_INT 31
118608: DOUBLE
118609: EQUAL
118610: IFTRUE 118614
118612: GO 118625
118614: POP
// bc_type := b_oil_power ; 32 :
118615: LD_ADDR_OWVAR 42
118619: PUSH
118620: LD_INT 26
118622: ST_TO_ADDR
118623: GO 118683
118625: LD_INT 32
118627: DOUBLE
118628: EQUAL
118629: IFTRUE 118633
118631: GO 118644
118633: POP
// bc_type := b_siberite_power ; 33 :
118634: LD_ADDR_OWVAR 42
118638: PUSH
118639: LD_INT 28
118641: ST_TO_ADDR
118642: GO 118683
118644: LD_INT 33
118646: DOUBLE
118647: EQUAL
118648: IFTRUE 118652
118650: GO 118663
118652: POP
// bc_type := b_oil_mine ; 34 :
118653: LD_ADDR_OWVAR 42
118657: PUSH
118658: LD_INT 29
118660: ST_TO_ADDR
118661: GO 118683
118663: LD_INT 34
118665: DOUBLE
118666: EQUAL
118667: IFTRUE 118671
118669: GO 118682
118671: POP
// bc_type := b_siberite_mine ; end ;
118672: LD_ADDR_OWVAR 42
118676: PUSH
118677: LD_INT 30
118679: ST_TO_ADDR
118680: GO 118683
118682: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
118683: LD_ADDR_VAR 0 8
118687: PUSH
118688: LD_VAR 0 5
118692: PPUSH
118693: LD_VAR 0 6
118697: PPUSH
118698: LD_VAR 0 3
118702: PPUSH
118703: CALL_OW 47
118707: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
118708: LD_OWVAR 42
118712: PUSH
118713: LD_INT 32
118715: PUSH
118716: LD_INT 33
118718: PUSH
118719: EMPTY
118720: LIST
118721: LIST
118722: IN
118723: IFFALSE 118739
// PlaceWeaponTurret ( b , weapon ) ;
118725: LD_VAR 0 8
118729: PPUSH
118730: LD_VAR 0 4
118734: PPUSH
118735: CALL_OW 431
// end ;
118739: LD_VAR 0 7
118743: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
118744: LD_INT 0
118746: PPUSH
118747: PPUSH
118748: PPUSH
118749: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
118750: LD_ADDR_VAR 0 4
118754: PUSH
118755: LD_INT 22
118757: PUSH
118758: LD_OWVAR 2
118762: PUSH
118763: EMPTY
118764: LIST
118765: LIST
118766: PUSH
118767: LD_INT 2
118769: PUSH
118770: LD_INT 30
118772: PUSH
118773: LD_INT 0
118775: PUSH
118776: EMPTY
118777: LIST
118778: LIST
118779: PUSH
118780: LD_INT 30
118782: PUSH
118783: LD_INT 1
118785: PUSH
118786: EMPTY
118787: LIST
118788: LIST
118789: PUSH
118790: EMPTY
118791: LIST
118792: LIST
118793: LIST
118794: PUSH
118795: EMPTY
118796: LIST
118797: LIST
118798: PPUSH
118799: CALL_OW 69
118803: ST_TO_ADDR
// if not tmp then
118804: LD_VAR 0 4
118808: NOT
118809: IFFALSE 118813
// exit ;
118811: GO 118872
// for i in tmp do
118813: LD_ADDR_VAR 0 2
118817: PUSH
118818: LD_VAR 0 4
118822: PUSH
118823: FOR_IN
118824: IFFALSE 118870
// for j = 1 to 3 do
118826: LD_ADDR_VAR 0 3
118830: PUSH
118831: DOUBLE
118832: LD_INT 1
118834: DEC
118835: ST_TO_ADDR
118836: LD_INT 3
118838: PUSH
118839: FOR_TO
118840: IFFALSE 118866
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
118842: LD_VAR 0 2
118846: PPUSH
118847: CALL_OW 274
118851: PPUSH
118852: LD_VAR 0 3
118856: PPUSH
118857: LD_INT 99999
118859: PPUSH
118860: CALL_OW 277
118864: GO 118839
118866: POP
118867: POP
118868: GO 118823
118870: POP
118871: POP
// end ;
118872: LD_VAR 0 1
118876: RET
// export function hHackSetLevel10 ; var i , j ; begin
118877: LD_INT 0
118879: PPUSH
118880: PPUSH
118881: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
118882: LD_ADDR_VAR 0 2
118886: PUSH
118887: LD_INT 21
118889: PUSH
118890: LD_INT 1
118892: PUSH
118893: EMPTY
118894: LIST
118895: LIST
118896: PPUSH
118897: CALL_OW 69
118901: PUSH
118902: FOR_IN
118903: IFFALSE 118955
// if IsSelected ( i ) then
118905: LD_VAR 0 2
118909: PPUSH
118910: CALL_OW 306
118914: IFFALSE 118953
// begin for j := 1 to 4 do
118916: LD_ADDR_VAR 0 3
118920: PUSH
118921: DOUBLE
118922: LD_INT 1
118924: DEC
118925: ST_TO_ADDR
118926: LD_INT 4
118928: PUSH
118929: FOR_TO
118930: IFFALSE 118951
// SetSkill ( i , j , 10 ) ;
118932: LD_VAR 0 2
118936: PPUSH
118937: LD_VAR 0 3
118941: PPUSH
118942: LD_INT 10
118944: PPUSH
118945: CALL_OW 237
118949: GO 118929
118951: POP
118952: POP
// end ;
118953: GO 118902
118955: POP
118956: POP
// end ;
118957: LD_VAR 0 1
118961: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
118962: LD_INT 0
118964: PPUSH
118965: PPUSH
118966: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
118967: LD_ADDR_VAR 0 2
118971: PUSH
118972: LD_INT 22
118974: PUSH
118975: LD_OWVAR 2
118979: PUSH
118980: EMPTY
118981: LIST
118982: LIST
118983: PUSH
118984: LD_INT 21
118986: PUSH
118987: LD_INT 1
118989: PUSH
118990: EMPTY
118991: LIST
118992: LIST
118993: PUSH
118994: EMPTY
118995: LIST
118996: LIST
118997: PPUSH
118998: CALL_OW 69
119002: PUSH
119003: FOR_IN
119004: IFFALSE 119045
// begin for j := 1 to 4 do
119006: LD_ADDR_VAR 0 3
119010: PUSH
119011: DOUBLE
119012: LD_INT 1
119014: DEC
119015: ST_TO_ADDR
119016: LD_INT 4
119018: PUSH
119019: FOR_TO
119020: IFFALSE 119041
// SetSkill ( i , j , 10 ) ;
119022: LD_VAR 0 2
119026: PPUSH
119027: LD_VAR 0 3
119031: PPUSH
119032: LD_INT 10
119034: PPUSH
119035: CALL_OW 237
119039: GO 119019
119041: POP
119042: POP
// end ;
119043: GO 119003
119045: POP
119046: POP
// end ;
119047: LD_VAR 0 1
119051: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
119052: LD_INT 0
119054: PPUSH
// uc_side := your_side ;
119055: LD_ADDR_OWVAR 20
119059: PUSH
119060: LD_OWVAR 2
119064: ST_TO_ADDR
// uc_nation := nation ;
119065: LD_ADDR_OWVAR 21
119069: PUSH
119070: LD_VAR 0 1
119074: ST_TO_ADDR
// InitHc ;
119075: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
119079: LD_INT 0
119081: PPUSH
119082: LD_VAR 0 2
119086: PPUSH
119087: LD_VAR 0 3
119091: PPUSH
119092: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
119096: LD_VAR 0 4
119100: PPUSH
119101: LD_VAR 0 5
119105: PPUSH
119106: CALL_OW 428
119110: PUSH
119111: LD_INT 0
119113: EQUAL
119114: IFFALSE 119138
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
119116: CALL_OW 44
119120: PPUSH
119121: LD_VAR 0 4
119125: PPUSH
119126: LD_VAR 0 5
119130: PPUSH
119131: LD_INT 1
119133: PPUSH
119134: CALL_OW 48
// end ;
119138: LD_VAR 0 6
119142: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
119143: LD_INT 0
119145: PPUSH
119146: PPUSH
// uc_side := your_side ;
119147: LD_ADDR_OWVAR 20
119151: PUSH
119152: LD_OWVAR 2
119156: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
119157: LD_VAR 0 1
119161: PUSH
119162: LD_INT 1
119164: PUSH
119165: LD_INT 2
119167: PUSH
119168: LD_INT 3
119170: PUSH
119171: LD_INT 4
119173: PUSH
119174: LD_INT 5
119176: PUSH
119177: EMPTY
119178: LIST
119179: LIST
119180: LIST
119181: LIST
119182: LIST
119183: IN
119184: IFFALSE 119196
// uc_nation := nation_american else
119186: LD_ADDR_OWVAR 21
119190: PUSH
119191: LD_INT 1
119193: ST_TO_ADDR
119194: GO 119239
// if chassis in [ 11 , 12 , 13 , 14 ] then
119196: LD_VAR 0 1
119200: PUSH
119201: LD_INT 11
119203: PUSH
119204: LD_INT 12
119206: PUSH
119207: LD_INT 13
119209: PUSH
119210: LD_INT 14
119212: PUSH
119213: EMPTY
119214: LIST
119215: LIST
119216: LIST
119217: LIST
119218: IN
119219: IFFALSE 119231
// uc_nation := nation_arabian else
119221: LD_ADDR_OWVAR 21
119225: PUSH
119226: LD_INT 2
119228: ST_TO_ADDR
119229: GO 119239
// uc_nation := nation_russian ;
119231: LD_ADDR_OWVAR 21
119235: PUSH
119236: LD_INT 3
119238: ST_TO_ADDR
// vc_chassis := chassis ;
119239: LD_ADDR_OWVAR 37
119243: PUSH
119244: LD_VAR 0 1
119248: ST_TO_ADDR
// vc_engine := engine ;
119249: LD_ADDR_OWVAR 39
119253: PUSH
119254: LD_VAR 0 2
119258: ST_TO_ADDR
// vc_control := control ;
119259: LD_ADDR_OWVAR 38
119263: PUSH
119264: LD_VAR 0 3
119268: ST_TO_ADDR
// vc_weapon := weapon ;
119269: LD_ADDR_OWVAR 40
119273: PUSH
119274: LD_VAR 0 4
119278: ST_TO_ADDR
// un := CreateVehicle ;
119279: LD_ADDR_VAR 0 8
119283: PUSH
119284: CALL_OW 45
119288: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
119289: LD_VAR 0 8
119293: PPUSH
119294: LD_INT 0
119296: PPUSH
119297: LD_INT 5
119299: PPUSH
119300: CALL_OW 12
119304: PPUSH
119305: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
119309: LD_VAR 0 8
119313: PPUSH
119314: LD_VAR 0 5
119318: PPUSH
119319: LD_VAR 0 6
119323: PPUSH
119324: LD_INT 1
119326: PPUSH
119327: CALL_OW 48
// end ;
119331: LD_VAR 0 7
119335: RET
// export hInvincible ; every 1 do
119336: GO 119338
119338: DISABLE
// hInvincible := [ ] ;
119339: LD_ADDR_EXP 217
119343: PUSH
119344: EMPTY
119345: ST_TO_ADDR
119346: END
// every 10 do var i ;
119347: GO 119349
119349: DISABLE
119350: LD_INT 0
119352: PPUSH
// begin enable ;
119353: ENABLE
// if not hInvincible then
119354: LD_EXP 217
119358: NOT
119359: IFFALSE 119363
// exit ;
119361: GO 119407
// for i in hInvincible do
119363: LD_ADDR_VAR 0 1
119367: PUSH
119368: LD_EXP 217
119372: PUSH
119373: FOR_IN
119374: IFFALSE 119405
// if GetLives ( i ) < 1000 then
119376: LD_VAR 0 1
119380: PPUSH
119381: CALL_OW 256
119385: PUSH
119386: LD_INT 1000
119388: LESS
119389: IFFALSE 119403
// SetLives ( i , 1000 ) ;
119391: LD_VAR 0 1
119395: PPUSH
119396: LD_INT 1000
119398: PPUSH
119399: CALL_OW 234
119403: GO 119373
119405: POP
119406: POP
// end ;
119407: PPOPN 1
119409: END
// export function hHackInvincible ; var i ; begin
119410: LD_INT 0
119412: PPUSH
119413: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
119414: LD_ADDR_VAR 0 2
119418: PUSH
119419: LD_INT 2
119421: PUSH
119422: LD_INT 21
119424: PUSH
119425: LD_INT 1
119427: PUSH
119428: EMPTY
119429: LIST
119430: LIST
119431: PUSH
119432: LD_INT 21
119434: PUSH
119435: LD_INT 2
119437: PUSH
119438: EMPTY
119439: LIST
119440: LIST
119441: PUSH
119442: EMPTY
119443: LIST
119444: LIST
119445: LIST
119446: PPUSH
119447: CALL_OW 69
119451: PUSH
119452: FOR_IN
119453: IFFALSE 119514
// if IsSelected ( i ) then
119455: LD_VAR 0 2
119459: PPUSH
119460: CALL_OW 306
119464: IFFALSE 119512
// begin if i in hInvincible then
119466: LD_VAR 0 2
119470: PUSH
119471: LD_EXP 217
119475: IN
119476: IFFALSE 119496
// hInvincible := hInvincible diff i else
119478: LD_ADDR_EXP 217
119482: PUSH
119483: LD_EXP 217
119487: PUSH
119488: LD_VAR 0 2
119492: DIFF
119493: ST_TO_ADDR
119494: GO 119512
// hInvincible := hInvincible union i ;
119496: LD_ADDR_EXP 217
119500: PUSH
119501: LD_EXP 217
119505: PUSH
119506: LD_VAR 0 2
119510: UNION
119511: ST_TO_ADDR
// end ;
119512: GO 119452
119514: POP
119515: POP
// end ;
119516: LD_VAR 0 1
119520: RET
// export function hHackInvisible ; var i , j ; begin
119521: LD_INT 0
119523: PPUSH
119524: PPUSH
119525: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
119526: LD_ADDR_VAR 0 2
119530: PUSH
119531: LD_INT 21
119533: PUSH
119534: LD_INT 1
119536: PUSH
119537: EMPTY
119538: LIST
119539: LIST
119540: PPUSH
119541: CALL_OW 69
119545: PUSH
119546: FOR_IN
119547: IFFALSE 119571
// if IsSelected ( i ) then
119549: LD_VAR 0 2
119553: PPUSH
119554: CALL_OW 306
119558: IFFALSE 119569
// ComForceInvisible ( i ) ;
119560: LD_VAR 0 2
119564: PPUSH
119565: CALL_OW 496
119569: GO 119546
119571: POP
119572: POP
// end ;
119573: LD_VAR 0 1
119577: RET
// export function hHackChangeYourSide ; begin
119578: LD_INT 0
119580: PPUSH
// if your_side = 8 then
119581: LD_OWVAR 2
119585: PUSH
119586: LD_INT 8
119588: EQUAL
119589: IFFALSE 119601
// your_side := 0 else
119591: LD_ADDR_OWVAR 2
119595: PUSH
119596: LD_INT 0
119598: ST_TO_ADDR
119599: GO 119615
// your_side := your_side + 1 ;
119601: LD_ADDR_OWVAR 2
119605: PUSH
119606: LD_OWVAR 2
119610: PUSH
119611: LD_INT 1
119613: PLUS
119614: ST_TO_ADDR
// end ;
119615: LD_VAR 0 1
119619: RET
// export function hHackChangeUnitSide ; var i , j ; begin
119620: LD_INT 0
119622: PPUSH
119623: PPUSH
119624: PPUSH
// for i in all_units do
119625: LD_ADDR_VAR 0 2
119629: PUSH
119630: LD_OWVAR 3
119634: PUSH
119635: FOR_IN
119636: IFFALSE 119714
// if IsSelected ( i ) then
119638: LD_VAR 0 2
119642: PPUSH
119643: CALL_OW 306
119647: IFFALSE 119712
// begin j := GetSide ( i ) ;
119649: LD_ADDR_VAR 0 3
119653: PUSH
119654: LD_VAR 0 2
119658: PPUSH
119659: CALL_OW 255
119663: ST_TO_ADDR
// if j = 8 then
119664: LD_VAR 0 3
119668: PUSH
119669: LD_INT 8
119671: EQUAL
119672: IFFALSE 119684
// j := 0 else
119674: LD_ADDR_VAR 0 3
119678: PUSH
119679: LD_INT 0
119681: ST_TO_ADDR
119682: GO 119698
// j := j + 1 ;
119684: LD_ADDR_VAR 0 3
119688: PUSH
119689: LD_VAR 0 3
119693: PUSH
119694: LD_INT 1
119696: PLUS
119697: ST_TO_ADDR
// SetSide ( i , j ) ;
119698: LD_VAR 0 2
119702: PPUSH
119703: LD_VAR 0 3
119707: PPUSH
119708: CALL_OW 235
// end ;
119712: GO 119635
119714: POP
119715: POP
// end ;
119716: LD_VAR 0 1
119720: RET
// export function hHackFog ; begin
119721: LD_INT 0
119723: PPUSH
// FogOff ( true ) ;
119724: LD_INT 1
119726: PPUSH
119727: CALL_OW 344
// end ;
119731: LD_VAR 0 1
119735: RET
// export function hHackTeleport ( unit , x , y ) ; begin
119736: LD_INT 0
119738: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
119739: LD_VAR 0 1
119743: PPUSH
119744: LD_VAR 0 2
119748: PPUSH
119749: LD_VAR 0 3
119753: PPUSH
119754: LD_INT 1
119756: PPUSH
119757: LD_INT 1
119759: PPUSH
119760: CALL_OW 483
// CenterOnXY ( x , y ) ;
119764: LD_VAR 0 2
119768: PPUSH
119769: LD_VAR 0 3
119773: PPUSH
119774: CALL_OW 84
// end ; end_of_file
119778: LD_VAR 0 4
119782: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
119783: LD_INT 0
119785: PPUSH
119786: PPUSH
119787: PPUSH
119788: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
119789: LD_VAR 0 1
119793: PPUSH
119794: CALL_OW 264
119798: PUSH
119799: LD_EXP 99
119803: EQUAL
119804: IFFALSE 119876
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
119806: LD_INT 68
119808: PPUSH
119809: LD_VAR 0 1
119813: PPUSH
119814: CALL_OW 255
119818: PPUSH
119819: CALL_OW 321
119823: PUSH
119824: LD_INT 2
119826: EQUAL
119827: IFFALSE 119839
// eff := 70 else
119829: LD_ADDR_VAR 0 4
119833: PUSH
119834: LD_INT 70
119836: ST_TO_ADDR
119837: GO 119847
// eff := 30 ;
119839: LD_ADDR_VAR 0 4
119843: PUSH
119844: LD_INT 30
119846: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
119847: LD_VAR 0 1
119851: PPUSH
119852: CALL_OW 250
119856: PPUSH
119857: LD_VAR 0 1
119861: PPUSH
119862: CALL_OW 251
119866: PPUSH
119867: LD_VAR 0 4
119871: PPUSH
119872: CALL_OW 495
// end ; end ;
119876: LD_VAR 0 2
119880: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
119881: LD_INT 0
119883: PPUSH
// end ;
119884: LD_VAR 0 4
119888: RET
// export function SOS_Command ( cmd ) ; begin
119889: LD_INT 0
119891: PPUSH
// end ;
119892: LD_VAR 0 2
119896: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
119897: LD_INT 0
119899: PPUSH
// end ;
119900: LD_VAR 0 6
119904: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
119905: LD_INT 0
119907: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
119908: LD_VAR 0 1
119912: PUSH
119913: LD_INT 250
119915: EQUAL
119916: PUSH
119917: LD_VAR 0 2
119921: PPUSH
119922: CALL_OW 264
119926: PUSH
119927: LD_EXP 102
119931: EQUAL
119932: AND
119933: IFFALSE 119954
// MinerPlaceMine ( unit , x , y ) ;
119935: LD_VAR 0 2
119939: PPUSH
119940: LD_VAR 0 4
119944: PPUSH
119945: LD_VAR 0 5
119949: PPUSH
119950: CALL 122303 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
119954: LD_VAR 0 1
119958: PUSH
119959: LD_INT 251
119961: EQUAL
119962: PUSH
119963: LD_VAR 0 2
119967: PPUSH
119968: CALL_OW 264
119972: PUSH
119973: LD_EXP 102
119977: EQUAL
119978: AND
119979: IFFALSE 120000
// MinerDetonateMine ( unit , x , y ) ;
119981: LD_VAR 0 2
119985: PPUSH
119986: LD_VAR 0 4
119990: PPUSH
119991: LD_VAR 0 5
119995: PPUSH
119996: CALL 122580 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
120000: LD_VAR 0 1
120004: PUSH
120005: LD_INT 252
120007: EQUAL
120008: PUSH
120009: LD_VAR 0 2
120013: PPUSH
120014: CALL_OW 264
120018: PUSH
120019: LD_EXP 102
120023: EQUAL
120024: AND
120025: IFFALSE 120046
// MinerCreateMinefield ( unit , x , y ) ;
120027: LD_VAR 0 2
120031: PPUSH
120032: LD_VAR 0 4
120036: PPUSH
120037: LD_VAR 0 5
120041: PPUSH
120042: CALL 122997 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
120046: LD_VAR 0 1
120050: PUSH
120051: LD_INT 253
120053: EQUAL
120054: PUSH
120055: LD_VAR 0 2
120059: PPUSH
120060: CALL_OW 257
120064: PUSH
120065: LD_INT 5
120067: EQUAL
120068: AND
120069: IFFALSE 120090
// ComBinocular ( unit , x , y ) ;
120071: LD_VAR 0 2
120075: PPUSH
120076: LD_VAR 0 4
120080: PPUSH
120081: LD_VAR 0 5
120085: PPUSH
120086: CALL 123368 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
120090: LD_VAR 0 1
120094: PUSH
120095: LD_INT 254
120097: EQUAL
120098: PUSH
120099: LD_VAR 0 2
120103: PPUSH
120104: CALL_OW 264
120108: PUSH
120109: LD_EXP 97
120113: EQUAL
120114: AND
120115: PUSH
120116: LD_VAR 0 3
120120: PPUSH
120121: CALL_OW 263
120125: PUSH
120126: LD_INT 3
120128: EQUAL
120129: AND
120130: IFFALSE 120146
// HackDestroyVehicle ( unit , selectedUnit ) ;
120132: LD_VAR 0 2
120136: PPUSH
120137: LD_VAR 0 3
120141: PPUSH
120142: CALL 121663 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
120146: LD_VAR 0 1
120150: PUSH
120151: LD_INT 255
120153: EQUAL
120154: PUSH
120155: LD_VAR 0 2
120159: PPUSH
120160: CALL_OW 264
120164: PUSH
120165: LD_INT 14
120167: PUSH
120168: LD_INT 53
120170: PUSH
120171: EMPTY
120172: LIST
120173: LIST
120174: IN
120175: AND
120176: PUSH
120177: LD_VAR 0 4
120181: PPUSH
120182: LD_VAR 0 5
120186: PPUSH
120187: CALL_OW 488
120191: AND
120192: IFFALSE 120216
// CutTreeXYR ( unit , x , y , 12 ) ;
120194: LD_VAR 0 2
120198: PPUSH
120199: LD_VAR 0 4
120203: PPUSH
120204: LD_VAR 0 5
120208: PPUSH
120209: LD_INT 12
120211: PPUSH
120212: CALL 120229 0 4
// end ;
120216: LD_VAR 0 6
120220: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
120221: LD_INT 0
120223: PPUSH
// end ;
120224: LD_VAR 0 4
120228: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
120229: LD_INT 0
120231: PPUSH
120232: PPUSH
120233: PPUSH
120234: PPUSH
120235: PPUSH
120236: PPUSH
120237: PPUSH
120238: PPUSH
120239: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
120240: LD_VAR 0 1
120244: NOT
120245: PUSH
120246: LD_VAR 0 2
120250: PPUSH
120251: LD_VAR 0 3
120255: PPUSH
120256: CALL_OW 488
120260: NOT
120261: OR
120262: PUSH
120263: LD_VAR 0 4
120267: NOT
120268: OR
120269: IFFALSE 120273
// exit ;
120271: GO 120613
// list := [ ] ;
120273: LD_ADDR_VAR 0 13
120277: PUSH
120278: EMPTY
120279: ST_TO_ADDR
// if x - r < 0 then
120280: LD_VAR 0 2
120284: PUSH
120285: LD_VAR 0 4
120289: MINUS
120290: PUSH
120291: LD_INT 0
120293: LESS
120294: IFFALSE 120306
// min_x := 0 else
120296: LD_ADDR_VAR 0 7
120300: PUSH
120301: LD_INT 0
120303: ST_TO_ADDR
120304: GO 120322
// min_x := x - r ;
120306: LD_ADDR_VAR 0 7
120310: PUSH
120311: LD_VAR 0 2
120315: PUSH
120316: LD_VAR 0 4
120320: MINUS
120321: ST_TO_ADDR
// if y - r < 0 then
120322: LD_VAR 0 3
120326: PUSH
120327: LD_VAR 0 4
120331: MINUS
120332: PUSH
120333: LD_INT 0
120335: LESS
120336: IFFALSE 120348
// min_y := 0 else
120338: LD_ADDR_VAR 0 8
120342: PUSH
120343: LD_INT 0
120345: ST_TO_ADDR
120346: GO 120364
// min_y := y - r ;
120348: LD_ADDR_VAR 0 8
120352: PUSH
120353: LD_VAR 0 3
120357: PUSH
120358: LD_VAR 0 4
120362: MINUS
120363: ST_TO_ADDR
// max_x := x + r ;
120364: LD_ADDR_VAR 0 9
120368: PUSH
120369: LD_VAR 0 2
120373: PUSH
120374: LD_VAR 0 4
120378: PLUS
120379: ST_TO_ADDR
// max_y := y + r ;
120380: LD_ADDR_VAR 0 10
120384: PUSH
120385: LD_VAR 0 3
120389: PUSH
120390: LD_VAR 0 4
120394: PLUS
120395: ST_TO_ADDR
// for _x = min_x to max_x do
120396: LD_ADDR_VAR 0 11
120400: PUSH
120401: DOUBLE
120402: LD_VAR 0 7
120406: DEC
120407: ST_TO_ADDR
120408: LD_VAR 0 9
120412: PUSH
120413: FOR_TO
120414: IFFALSE 120531
// for _y = min_y to max_y do
120416: LD_ADDR_VAR 0 12
120420: PUSH
120421: DOUBLE
120422: LD_VAR 0 8
120426: DEC
120427: ST_TO_ADDR
120428: LD_VAR 0 10
120432: PUSH
120433: FOR_TO
120434: IFFALSE 120527
// begin if not ValidHex ( _x , _y ) then
120436: LD_VAR 0 11
120440: PPUSH
120441: LD_VAR 0 12
120445: PPUSH
120446: CALL_OW 488
120450: NOT
120451: IFFALSE 120455
// continue ;
120453: GO 120433
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
120455: LD_VAR 0 11
120459: PPUSH
120460: LD_VAR 0 12
120464: PPUSH
120465: CALL_OW 351
120469: PUSH
120470: LD_VAR 0 11
120474: PPUSH
120475: LD_VAR 0 12
120479: PPUSH
120480: CALL_OW 554
120484: AND
120485: IFFALSE 120525
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
120487: LD_ADDR_VAR 0 13
120491: PUSH
120492: LD_VAR 0 13
120496: PPUSH
120497: LD_VAR 0 13
120501: PUSH
120502: LD_INT 1
120504: PLUS
120505: PPUSH
120506: LD_VAR 0 11
120510: PUSH
120511: LD_VAR 0 12
120515: PUSH
120516: EMPTY
120517: LIST
120518: LIST
120519: PPUSH
120520: CALL_OW 2
120524: ST_TO_ADDR
// end ;
120525: GO 120433
120527: POP
120528: POP
120529: GO 120413
120531: POP
120532: POP
// if not list then
120533: LD_VAR 0 13
120537: NOT
120538: IFFALSE 120542
// exit ;
120540: GO 120613
// for i in list do
120542: LD_ADDR_VAR 0 6
120546: PUSH
120547: LD_VAR 0 13
120551: PUSH
120552: FOR_IN
120553: IFFALSE 120611
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
120555: LD_VAR 0 1
120559: PPUSH
120560: LD_STRING M
120562: PUSH
120563: LD_VAR 0 6
120567: PUSH
120568: LD_INT 1
120570: ARRAY
120571: PUSH
120572: LD_VAR 0 6
120576: PUSH
120577: LD_INT 2
120579: ARRAY
120580: PUSH
120581: LD_INT 0
120583: PUSH
120584: LD_INT 0
120586: PUSH
120587: LD_INT 0
120589: PUSH
120590: LD_INT 0
120592: PUSH
120593: EMPTY
120594: LIST
120595: LIST
120596: LIST
120597: LIST
120598: LIST
120599: LIST
120600: LIST
120601: PUSH
120602: EMPTY
120603: LIST
120604: PPUSH
120605: CALL_OW 447
120609: GO 120552
120611: POP
120612: POP
// end ;
120613: LD_VAR 0 5
120617: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
120618: LD_EXP 220
120622: NOT
120623: IFFALSE 120673
120625: GO 120627
120627: DISABLE
// begin initHack := true ;
120628: LD_ADDR_EXP 220
120632: PUSH
120633: LD_INT 1
120635: ST_TO_ADDR
// hackTanks := [ ] ;
120636: LD_ADDR_EXP 221
120640: PUSH
120641: EMPTY
120642: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
120643: LD_ADDR_EXP 222
120647: PUSH
120648: EMPTY
120649: ST_TO_ADDR
// hackLimit := 3 ;
120650: LD_ADDR_EXP 223
120654: PUSH
120655: LD_INT 3
120657: ST_TO_ADDR
// hackDist := 12 ;
120658: LD_ADDR_EXP 224
120662: PUSH
120663: LD_INT 12
120665: ST_TO_ADDR
// hackCounter := [ ] ;
120666: LD_ADDR_EXP 225
120670: PUSH
120671: EMPTY
120672: ST_TO_ADDR
// end ;
120673: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
120674: LD_EXP 220
120678: PUSH
120679: LD_INT 34
120681: PUSH
120682: LD_EXP 97
120686: PUSH
120687: EMPTY
120688: LIST
120689: LIST
120690: PPUSH
120691: CALL_OW 69
120695: AND
120696: IFFALSE 120951
120698: GO 120700
120700: DISABLE
120701: LD_INT 0
120703: PPUSH
120704: PPUSH
// begin enable ;
120705: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
120706: LD_ADDR_VAR 0 1
120710: PUSH
120711: LD_INT 34
120713: PUSH
120714: LD_EXP 97
120718: PUSH
120719: EMPTY
120720: LIST
120721: LIST
120722: PPUSH
120723: CALL_OW 69
120727: PUSH
120728: FOR_IN
120729: IFFALSE 120949
// begin if not i in hackTanks then
120731: LD_VAR 0 1
120735: PUSH
120736: LD_EXP 221
120740: IN
120741: NOT
120742: IFFALSE 120825
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
120744: LD_ADDR_EXP 221
120748: PUSH
120749: LD_EXP 221
120753: PPUSH
120754: LD_EXP 221
120758: PUSH
120759: LD_INT 1
120761: PLUS
120762: PPUSH
120763: LD_VAR 0 1
120767: PPUSH
120768: CALL_OW 1
120772: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
120773: LD_ADDR_EXP 222
120777: PUSH
120778: LD_EXP 222
120782: PPUSH
120783: LD_EXP 222
120787: PUSH
120788: LD_INT 1
120790: PLUS
120791: PPUSH
120792: EMPTY
120793: PPUSH
120794: CALL_OW 1
120798: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
120799: LD_ADDR_EXP 225
120803: PUSH
120804: LD_EXP 225
120808: PPUSH
120809: LD_EXP 225
120813: PUSH
120814: LD_INT 1
120816: PLUS
120817: PPUSH
120818: EMPTY
120819: PPUSH
120820: CALL_OW 1
120824: ST_TO_ADDR
// end ; if not IsOk ( i ) then
120825: LD_VAR 0 1
120829: PPUSH
120830: CALL_OW 302
120834: NOT
120835: IFFALSE 120848
// begin HackUnlinkAll ( i ) ;
120837: LD_VAR 0 1
120841: PPUSH
120842: CALL 120954 0 1
// continue ;
120846: GO 120728
// end ; HackCheckCapturedStatus ( i ) ;
120848: LD_VAR 0 1
120852: PPUSH
120853: CALL 121397 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
120857: LD_ADDR_VAR 0 2
120861: PUSH
120862: LD_INT 81
120864: PUSH
120865: LD_VAR 0 1
120869: PPUSH
120870: CALL_OW 255
120874: PUSH
120875: EMPTY
120876: LIST
120877: LIST
120878: PUSH
120879: LD_INT 33
120881: PUSH
120882: LD_INT 3
120884: PUSH
120885: EMPTY
120886: LIST
120887: LIST
120888: PUSH
120889: LD_INT 91
120891: PUSH
120892: LD_VAR 0 1
120896: PUSH
120897: LD_EXP 224
120901: PUSH
120902: EMPTY
120903: LIST
120904: LIST
120905: LIST
120906: PUSH
120907: LD_INT 50
120909: PUSH
120910: EMPTY
120911: LIST
120912: PUSH
120913: EMPTY
120914: LIST
120915: LIST
120916: LIST
120917: LIST
120918: PPUSH
120919: CALL_OW 69
120923: ST_TO_ADDR
// if not tmp then
120924: LD_VAR 0 2
120928: NOT
120929: IFFALSE 120933
// continue ;
120931: GO 120728
// HackLink ( i , tmp ) ;
120933: LD_VAR 0 1
120937: PPUSH
120938: LD_VAR 0 2
120942: PPUSH
120943: CALL 121090 0 2
// end ;
120947: GO 120728
120949: POP
120950: POP
// end ;
120951: PPOPN 2
120953: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
120954: LD_INT 0
120956: PPUSH
120957: PPUSH
120958: PPUSH
// if not hack in hackTanks then
120959: LD_VAR 0 1
120963: PUSH
120964: LD_EXP 221
120968: IN
120969: NOT
120970: IFFALSE 120974
// exit ;
120972: GO 121085
// index := GetElementIndex ( hackTanks , hack ) ;
120974: LD_ADDR_VAR 0 4
120978: PUSH
120979: LD_EXP 221
120983: PPUSH
120984: LD_VAR 0 1
120988: PPUSH
120989: CALL 70656 0 2
120993: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
120994: LD_EXP 222
120998: PUSH
120999: LD_VAR 0 4
121003: ARRAY
121004: IFFALSE 121085
// begin for i in hackTanksCaptured [ index ] do
121006: LD_ADDR_VAR 0 3
121010: PUSH
121011: LD_EXP 222
121015: PUSH
121016: LD_VAR 0 4
121020: ARRAY
121021: PUSH
121022: FOR_IN
121023: IFFALSE 121049
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
121025: LD_VAR 0 3
121029: PUSH
121030: LD_INT 1
121032: ARRAY
121033: PPUSH
121034: LD_VAR 0 3
121038: PUSH
121039: LD_INT 2
121041: ARRAY
121042: PPUSH
121043: CALL_OW 235
121047: GO 121022
121049: POP
121050: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
121051: LD_ADDR_EXP 222
121055: PUSH
121056: LD_EXP 222
121060: PPUSH
121061: LD_VAR 0 4
121065: PPUSH
121066: EMPTY
121067: PPUSH
121068: CALL_OW 1
121072: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
121073: LD_VAR 0 1
121077: PPUSH
121078: LD_INT 0
121080: PPUSH
121081: CALL_OW 505
// end ; end ;
121085: LD_VAR 0 2
121089: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
121090: LD_INT 0
121092: PPUSH
121093: PPUSH
121094: PPUSH
// if not hack in hackTanks or not vehicles then
121095: LD_VAR 0 1
121099: PUSH
121100: LD_EXP 221
121104: IN
121105: NOT
121106: PUSH
121107: LD_VAR 0 2
121111: NOT
121112: OR
121113: IFFALSE 121117
// exit ;
121115: GO 121392
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
121117: LD_ADDR_VAR 0 2
121121: PUSH
121122: LD_VAR 0 1
121126: PPUSH
121127: LD_VAR 0 2
121131: PPUSH
121132: LD_INT 1
121134: PPUSH
121135: LD_INT 1
121137: PPUSH
121138: CALL 71306 0 4
121142: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
121143: LD_ADDR_VAR 0 5
121147: PUSH
121148: LD_EXP 221
121152: PPUSH
121153: LD_VAR 0 1
121157: PPUSH
121158: CALL 70656 0 2
121162: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
121163: LD_EXP 222
121167: PUSH
121168: LD_VAR 0 5
121172: ARRAY
121173: PUSH
121174: LD_EXP 223
121178: LESS
121179: IFFALSE 121368
// begin for i := 1 to vehicles do
121181: LD_ADDR_VAR 0 4
121185: PUSH
121186: DOUBLE
121187: LD_INT 1
121189: DEC
121190: ST_TO_ADDR
121191: LD_VAR 0 2
121195: PUSH
121196: FOR_TO
121197: IFFALSE 121366
// begin if hackTanksCaptured [ index ] = hackLimit then
121199: LD_EXP 222
121203: PUSH
121204: LD_VAR 0 5
121208: ARRAY
121209: PUSH
121210: LD_EXP 223
121214: EQUAL
121215: IFFALSE 121219
// break ;
121217: GO 121366
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
121219: LD_ADDR_EXP 225
121223: PUSH
121224: LD_EXP 225
121228: PPUSH
121229: LD_VAR 0 5
121233: PPUSH
121234: LD_EXP 225
121238: PUSH
121239: LD_VAR 0 5
121243: ARRAY
121244: PUSH
121245: LD_INT 1
121247: PLUS
121248: PPUSH
121249: CALL_OW 1
121253: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
121254: LD_ADDR_EXP 222
121258: PUSH
121259: LD_EXP 222
121263: PPUSH
121264: LD_VAR 0 5
121268: PUSH
121269: LD_EXP 222
121273: PUSH
121274: LD_VAR 0 5
121278: ARRAY
121279: PUSH
121280: LD_INT 1
121282: PLUS
121283: PUSH
121284: EMPTY
121285: LIST
121286: LIST
121287: PPUSH
121288: LD_VAR 0 2
121292: PUSH
121293: LD_VAR 0 4
121297: ARRAY
121298: PUSH
121299: LD_VAR 0 2
121303: PUSH
121304: LD_VAR 0 4
121308: ARRAY
121309: PPUSH
121310: CALL_OW 255
121314: PUSH
121315: EMPTY
121316: LIST
121317: LIST
121318: PPUSH
121319: CALL 70871 0 3
121323: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
121324: LD_VAR 0 2
121328: PUSH
121329: LD_VAR 0 4
121333: ARRAY
121334: PPUSH
121335: LD_VAR 0 1
121339: PPUSH
121340: CALL_OW 255
121344: PPUSH
121345: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
121349: LD_VAR 0 2
121353: PUSH
121354: LD_VAR 0 4
121358: ARRAY
121359: PPUSH
121360: CALL_OW 141
// end ;
121364: GO 121196
121366: POP
121367: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
121368: LD_VAR 0 1
121372: PPUSH
121373: LD_EXP 222
121377: PUSH
121378: LD_VAR 0 5
121382: ARRAY
121383: PUSH
121384: LD_INT 0
121386: PLUS
121387: PPUSH
121388: CALL_OW 505
// end ;
121392: LD_VAR 0 3
121396: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
121397: LD_INT 0
121399: PPUSH
121400: PPUSH
121401: PPUSH
121402: PPUSH
// if not hack in hackTanks then
121403: LD_VAR 0 1
121407: PUSH
121408: LD_EXP 221
121412: IN
121413: NOT
121414: IFFALSE 121418
// exit ;
121416: GO 121658
// index := GetElementIndex ( hackTanks , hack ) ;
121418: LD_ADDR_VAR 0 4
121422: PUSH
121423: LD_EXP 221
121427: PPUSH
121428: LD_VAR 0 1
121432: PPUSH
121433: CALL 70656 0 2
121437: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
121438: LD_ADDR_VAR 0 3
121442: PUSH
121443: DOUBLE
121444: LD_EXP 222
121448: PUSH
121449: LD_VAR 0 4
121453: ARRAY
121454: INC
121455: ST_TO_ADDR
121456: LD_INT 1
121458: PUSH
121459: FOR_DOWNTO
121460: IFFALSE 121632
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
121462: LD_ADDR_VAR 0 5
121466: PUSH
121467: LD_EXP 222
121471: PUSH
121472: LD_VAR 0 4
121476: ARRAY
121477: PUSH
121478: LD_VAR 0 3
121482: ARRAY
121483: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
121484: LD_VAR 0 5
121488: PUSH
121489: LD_INT 1
121491: ARRAY
121492: PPUSH
121493: CALL_OW 302
121497: NOT
121498: PUSH
121499: LD_VAR 0 5
121503: PUSH
121504: LD_INT 1
121506: ARRAY
121507: PPUSH
121508: CALL_OW 255
121512: PUSH
121513: LD_VAR 0 1
121517: PPUSH
121518: CALL_OW 255
121522: NONEQUAL
121523: OR
121524: IFFALSE 121630
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
121526: LD_VAR 0 5
121530: PUSH
121531: LD_INT 1
121533: ARRAY
121534: PPUSH
121535: CALL_OW 305
121539: PUSH
121540: LD_VAR 0 5
121544: PUSH
121545: LD_INT 1
121547: ARRAY
121548: PPUSH
121549: CALL_OW 255
121553: PUSH
121554: LD_VAR 0 1
121558: PPUSH
121559: CALL_OW 255
121563: EQUAL
121564: AND
121565: IFFALSE 121589
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
121567: LD_VAR 0 5
121571: PUSH
121572: LD_INT 1
121574: ARRAY
121575: PPUSH
121576: LD_VAR 0 5
121580: PUSH
121581: LD_INT 2
121583: ARRAY
121584: PPUSH
121585: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
121589: LD_ADDR_EXP 222
121593: PUSH
121594: LD_EXP 222
121598: PPUSH
121599: LD_VAR 0 4
121603: PPUSH
121604: LD_EXP 222
121608: PUSH
121609: LD_VAR 0 4
121613: ARRAY
121614: PPUSH
121615: LD_VAR 0 3
121619: PPUSH
121620: CALL_OW 3
121624: PPUSH
121625: CALL_OW 1
121629: ST_TO_ADDR
// end ; end ;
121630: GO 121459
121632: POP
121633: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
121634: LD_VAR 0 1
121638: PPUSH
121639: LD_EXP 222
121643: PUSH
121644: LD_VAR 0 4
121648: ARRAY
121649: PUSH
121650: LD_INT 0
121652: PLUS
121653: PPUSH
121654: CALL_OW 505
// end ;
121658: LD_VAR 0 2
121662: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
121663: LD_INT 0
121665: PPUSH
121666: PPUSH
121667: PPUSH
121668: PPUSH
// if not hack in hackTanks then
121669: LD_VAR 0 1
121673: PUSH
121674: LD_EXP 221
121678: IN
121679: NOT
121680: IFFALSE 121684
// exit ;
121682: GO 121769
// index := GetElementIndex ( hackTanks , hack ) ;
121684: LD_ADDR_VAR 0 5
121688: PUSH
121689: LD_EXP 221
121693: PPUSH
121694: LD_VAR 0 1
121698: PPUSH
121699: CALL 70656 0 2
121703: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
121704: LD_ADDR_VAR 0 4
121708: PUSH
121709: DOUBLE
121710: LD_INT 1
121712: DEC
121713: ST_TO_ADDR
121714: LD_EXP 222
121718: PUSH
121719: LD_VAR 0 5
121723: ARRAY
121724: PUSH
121725: FOR_TO
121726: IFFALSE 121767
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
121728: LD_EXP 222
121732: PUSH
121733: LD_VAR 0 5
121737: ARRAY
121738: PUSH
121739: LD_VAR 0 4
121743: ARRAY
121744: PUSH
121745: LD_INT 1
121747: ARRAY
121748: PUSH
121749: LD_VAR 0 2
121753: EQUAL
121754: IFFALSE 121765
// KillUnit ( vehicle ) ;
121756: LD_VAR 0 2
121760: PPUSH
121761: CALL_OW 66
121765: GO 121725
121767: POP
121768: POP
// end ;
121769: LD_VAR 0 3
121773: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
121774: LD_EXP 226
121778: NOT
121779: IFFALSE 121814
121781: GO 121783
121783: DISABLE
// begin initMiner := true ;
121784: LD_ADDR_EXP 226
121788: PUSH
121789: LD_INT 1
121791: ST_TO_ADDR
// minersList := [ ] ;
121792: LD_ADDR_EXP 227
121796: PUSH
121797: EMPTY
121798: ST_TO_ADDR
// minerMinesList := [ ] ;
121799: LD_ADDR_EXP 228
121803: PUSH
121804: EMPTY
121805: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
121806: LD_ADDR_EXP 229
121810: PUSH
121811: LD_INT 5
121813: ST_TO_ADDR
// end ;
121814: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
121815: LD_EXP 226
121819: PUSH
121820: LD_INT 34
121822: PUSH
121823: LD_EXP 102
121827: PUSH
121828: EMPTY
121829: LIST
121830: LIST
121831: PPUSH
121832: CALL_OW 69
121836: AND
121837: IFFALSE 122300
121839: GO 121841
121841: DISABLE
121842: LD_INT 0
121844: PPUSH
121845: PPUSH
121846: PPUSH
121847: PPUSH
// begin enable ;
121848: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
121849: LD_ADDR_VAR 0 1
121853: PUSH
121854: LD_INT 34
121856: PUSH
121857: LD_EXP 102
121861: PUSH
121862: EMPTY
121863: LIST
121864: LIST
121865: PPUSH
121866: CALL_OW 69
121870: PUSH
121871: FOR_IN
121872: IFFALSE 121944
// begin if not i in minersList then
121874: LD_VAR 0 1
121878: PUSH
121879: LD_EXP 227
121883: IN
121884: NOT
121885: IFFALSE 121942
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
121887: LD_ADDR_EXP 227
121891: PUSH
121892: LD_EXP 227
121896: PPUSH
121897: LD_EXP 227
121901: PUSH
121902: LD_INT 1
121904: PLUS
121905: PPUSH
121906: LD_VAR 0 1
121910: PPUSH
121911: CALL_OW 1
121915: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
121916: LD_ADDR_EXP 228
121920: PUSH
121921: LD_EXP 228
121925: PPUSH
121926: LD_EXP 228
121930: PUSH
121931: LD_INT 1
121933: PLUS
121934: PPUSH
121935: EMPTY
121936: PPUSH
121937: CALL_OW 1
121941: ST_TO_ADDR
// end end ;
121942: GO 121871
121944: POP
121945: POP
// for i := minerMinesList downto 1 do
121946: LD_ADDR_VAR 0 1
121950: PUSH
121951: DOUBLE
121952: LD_EXP 228
121956: INC
121957: ST_TO_ADDR
121958: LD_INT 1
121960: PUSH
121961: FOR_DOWNTO
121962: IFFALSE 122298
// begin if IsLive ( minersList [ i ] ) then
121964: LD_EXP 227
121968: PUSH
121969: LD_VAR 0 1
121973: ARRAY
121974: PPUSH
121975: CALL_OW 300
121979: IFFALSE 122007
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
121981: LD_EXP 227
121985: PUSH
121986: LD_VAR 0 1
121990: ARRAY
121991: PPUSH
121992: LD_EXP 228
121996: PUSH
121997: LD_VAR 0 1
122001: ARRAY
122002: PPUSH
122003: CALL_OW 505
// if not minerMinesList [ i ] then
122007: LD_EXP 228
122011: PUSH
122012: LD_VAR 0 1
122016: ARRAY
122017: NOT
122018: IFFALSE 122022
// continue ;
122020: GO 121961
// for j := minerMinesList [ i ] downto 1 do
122022: LD_ADDR_VAR 0 2
122026: PUSH
122027: DOUBLE
122028: LD_EXP 228
122032: PUSH
122033: LD_VAR 0 1
122037: ARRAY
122038: INC
122039: ST_TO_ADDR
122040: LD_INT 1
122042: PUSH
122043: FOR_DOWNTO
122044: IFFALSE 122294
// begin side := GetSide ( minersList [ i ] ) ;
122046: LD_ADDR_VAR 0 3
122050: PUSH
122051: LD_EXP 227
122055: PUSH
122056: LD_VAR 0 1
122060: ARRAY
122061: PPUSH
122062: CALL_OW 255
122066: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
122067: LD_ADDR_VAR 0 4
122071: PUSH
122072: LD_EXP 228
122076: PUSH
122077: LD_VAR 0 1
122081: ARRAY
122082: PUSH
122083: LD_VAR 0 2
122087: ARRAY
122088: PUSH
122089: LD_INT 1
122091: ARRAY
122092: PPUSH
122093: LD_EXP 228
122097: PUSH
122098: LD_VAR 0 1
122102: ARRAY
122103: PUSH
122104: LD_VAR 0 2
122108: ARRAY
122109: PUSH
122110: LD_INT 2
122112: ARRAY
122113: PPUSH
122114: CALL_OW 428
122118: ST_TO_ADDR
// if not tmp then
122119: LD_VAR 0 4
122123: NOT
122124: IFFALSE 122128
// continue ;
122126: GO 122043
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
122128: LD_VAR 0 4
122132: PUSH
122133: LD_INT 81
122135: PUSH
122136: LD_VAR 0 3
122140: PUSH
122141: EMPTY
122142: LIST
122143: LIST
122144: PPUSH
122145: CALL_OW 69
122149: IN
122150: PUSH
122151: LD_EXP 228
122155: PUSH
122156: LD_VAR 0 1
122160: ARRAY
122161: PUSH
122162: LD_VAR 0 2
122166: ARRAY
122167: PUSH
122168: LD_INT 1
122170: ARRAY
122171: PPUSH
122172: LD_EXP 228
122176: PUSH
122177: LD_VAR 0 1
122181: ARRAY
122182: PUSH
122183: LD_VAR 0 2
122187: ARRAY
122188: PUSH
122189: LD_INT 2
122191: ARRAY
122192: PPUSH
122193: CALL_OW 458
122197: AND
122198: IFFALSE 122292
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
122200: LD_EXP 228
122204: PUSH
122205: LD_VAR 0 1
122209: ARRAY
122210: PUSH
122211: LD_VAR 0 2
122215: ARRAY
122216: PUSH
122217: LD_INT 1
122219: ARRAY
122220: PPUSH
122221: LD_EXP 228
122225: PUSH
122226: LD_VAR 0 1
122230: ARRAY
122231: PUSH
122232: LD_VAR 0 2
122236: ARRAY
122237: PUSH
122238: LD_INT 2
122240: ARRAY
122241: PPUSH
122242: LD_VAR 0 3
122246: PPUSH
122247: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
122251: LD_ADDR_EXP 228
122255: PUSH
122256: LD_EXP 228
122260: PPUSH
122261: LD_VAR 0 1
122265: PPUSH
122266: LD_EXP 228
122270: PUSH
122271: LD_VAR 0 1
122275: ARRAY
122276: PPUSH
122277: LD_VAR 0 2
122281: PPUSH
122282: CALL_OW 3
122286: PPUSH
122287: CALL_OW 1
122291: ST_TO_ADDR
// end ; end ;
122292: GO 122043
122294: POP
122295: POP
// end ;
122296: GO 121961
122298: POP
122299: POP
// end ;
122300: PPOPN 4
122302: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
122303: LD_INT 0
122305: PPUSH
122306: PPUSH
// result := false ;
122307: LD_ADDR_VAR 0 4
122311: PUSH
122312: LD_INT 0
122314: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
122315: LD_VAR 0 1
122319: PPUSH
122320: CALL_OW 264
122324: PUSH
122325: LD_EXP 102
122329: EQUAL
122330: NOT
122331: IFFALSE 122335
// exit ;
122333: GO 122575
// index := GetElementIndex ( minersList , unit ) ;
122335: LD_ADDR_VAR 0 5
122339: PUSH
122340: LD_EXP 227
122344: PPUSH
122345: LD_VAR 0 1
122349: PPUSH
122350: CALL 70656 0 2
122354: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
122355: LD_EXP 228
122359: PUSH
122360: LD_VAR 0 5
122364: ARRAY
122365: PUSH
122366: LD_EXP 229
122370: GREATEREQUAL
122371: IFFALSE 122375
// exit ;
122373: GO 122575
// ComMoveXY ( unit , x , y ) ;
122375: LD_VAR 0 1
122379: PPUSH
122380: LD_VAR 0 2
122384: PPUSH
122385: LD_VAR 0 3
122389: PPUSH
122390: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
122394: LD_INT 35
122396: PPUSH
122397: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
122401: LD_VAR 0 1
122405: PPUSH
122406: LD_VAR 0 2
122410: PPUSH
122411: LD_VAR 0 3
122415: PPUSH
122416: CALL 101428 0 3
122420: NOT
122421: PUSH
122422: LD_VAR 0 1
122426: PPUSH
122427: CALL_OW 314
122431: AND
122432: IFFALSE 122436
// exit ;
122434: GO 122575
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
122436: LD_VAR 0 2
122440: PPUSH
122441: LD_VAR 0 3
122445: PPUSH
122446: CALL_OW 428
122450: PUSH
122451: LD_VAR 0 1
122455: EQUAL
122456: PUSH
122457: LD_VAR 0 1
122461: PPUSH
122462: CALL_OW 314
122466: NOT
122467: AND
122468: IFFALSE 122394
// PlaySoundXY ( x , y , PlantMine ) ;
122470: LD_VAR 0 2
122474: PPUSH
122475: LD_VAR 0 3
122479: PPUSH
122480: LD_STRING PlantMine
122482: PPUSH
122483: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
122487: LD_VAR 0 2
122491: PPUSH
122492: LD_VAR 0 3
122496: PPUSH
122497: LD_VAR 0 1
122501: PPUSH
122502: CALL_OW 255
122506: PPUSH
122507: LD_INT 0
122509: PPUSH
122510: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
122514: LD_ADDR_EXP 228
122518: PUSH
122519: LD_EXP 228
122523: PPUSH
122524: LD_VAR 0 5
122528: PUSH
122529: LD_EXP 228
122533: PUSH
122534: LD_VAR 0 5
122538: ARRAY
122539: PUSH
122540: LD_INT 1
122542: PLUS
122543: PUSH
122544: EMPTY
122545: LIST
122546: LIST
122547: PPUSH
122548: LD_VAR 0 2
122552: PUSH
122553: LD_VAR 0 3
122557: PUSH
122558: EMPTY
122559: LIST
122560: LIST
122561: PPUSH
122562: CALL 70871 0 3
122566: ST_TO_ADDR
// result := true ;
122567: LD_ADDR_VAR 0 4
122571: PUSH
122572: LD_INT 1
122574: ST_TO_ADDR
// end ;
122575: LD_VAR 0 4
122579: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
122580: LD_INT 0
122582: PPUSH
122583: PPUSH
122584: PPUSH
// if not unit in minersList then
122585: LD_VAR 0 1
122589: PUSH
122590: LD_EXP 227
122594: IN
122595: NOT
122596: IFFALSE 122600
// exit ;
122598: GO 122992
// index := GetElementIndex ( minersList , unit ) ;
122600: LD_ADDR_VAR 0 6
122604: PUSH
122605: LD_EXP 227
122609: PPUSH
122610: LD_VAR 0 1
122614: PPUSH
122615: CALL 70656 0 2
122619: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
122620: LD_ADDR_VAR 0 5
122624: PUSH
122625: DOUBLE
122626: LD_EXP 228
122630: PUSH
122631: LD_VAR 0 6
122635: ARRAY
122636: INC
122637: ST_TO_ADDR
122638: LD_INT 1
122640: PUSH
122641: FOR_DOWNTO
122642: IFFALSE 122803
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
122644: LD_EXP 228
122648: PUSH
122649: LD_VAR 0 6
122653: ARRAY
122654: PUSH
122655: LD_VAR 0 5
122659: ARRAY
122660: PUSH
122661: LD_INT 1
122663: ARRAY
122664: PUSH
122665: LD_VAR 0 2
122669: EQUAL
122670: PUSH
122671: LD_EXP 228
122675: PUSH
122676: LD_VAR 0 6
122680: ARRAY
122681: PUSH
122682: LD_VAR 0 5
122686: ARRAY
122687: PUSH
122688: LD_INT 2
122690: ARRAY
122691: PUSH
122692: LD_VAR 0 3
122696: EQUAL
122697: AND
122698: IFFALSE 122801
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
122700: LD_EXP 228
122704: PUSH
122705: LD_VAR 0 6
122709: ARRAY
122710: PUSH
122711: LD_VAR 0 5
122715: ARRAY
122716: PUSH
122717: LD_INT 1
122719: ARRAY
122720: PPUSH
122721: LD_EXP 228
122725: PUSH
122726: LD_VAR 0 6
122730: ARRAY
122731: PUSH
122732: LD_VAR 0 5
122736: ARRAY
122737: PUSH
122738: LD_INT 2
122740: ARRAY
122741: PPUSH
122742: LD_VAR 0 1
122746: PPUSH
122747: CALL_OW 255
122751: PPUSH
122752: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
122756: LD_ADDR_EXP 228
122760: PUSH
122761: LD_EXP 228
122765: PPUSH
122766: LD_VAR 0 6
122770: PPUSH
122771: LD_EXP 228
122775: PUSH
122776: LD_VAR 0 6
122780: ARRAY
122781: PPUSH
122782: LD_VAR 0 5
122786: PPUSH
122787: CALL_OW 3
122791: PPUSH
122792: CALL_OW 1
122796: ST_TO_ADDR
// exit ;
122797: POP
122798: POP
122799: GO 122992
// end ; end ;
122801: GO 122641
122803: POP
122804: POP
// for i := minerMinesList [ index ] downto 1 do
122805: LD_ADDR_VAR 0 5
122809: PUSH
122810: DOUBLE
122811: LD_EXP 228
122815: PUSH
122816: LD_VAR 0 6
122820: ARRAY
122821: INC
122822: ST_TO_ADDR
122823: LD_INT 1
122825: PUSH
122826: FOR_DOWNTO
122827: IFFALSE 122990
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
122829: LD_EXP 228
122833: PUSH
122834: LD_VAR 0 6
122838: ARRAY
122839: PUSH
122840: LD_VAR 0 5
122844: ARRAY
122845: PUSH
122846: LD_INT 1
122848: ARRAY
122849: PPUSH
122850: LD_EXP 228
122854: PUSH
122855: LD_VAR 0 6
122859: ARRAY
122860: PUSH
122861: LD_VAR 0 5
122865: ARRAY
122866: PUSH
122867: LD_INT 2
122869: ARRAY
122870: PPUSH
122871: LD_VAR 0 2
122875: PPUSH
122876: LD_VAR 0 3
122880: PPUSH
122881: CALL_OW 298
122885: PUSH
122886: LD_INT 6
122888: LESS
122889: IFFALSE 122988
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
122891: LD_EXP 228
122895: PUSH
122896: LD_VAR 0 6
122900: ARRAY
122901: PUSH
122902: LD_VAR 0 5
122906: ARRAY
122907: PUSH
122908: LD_INT 1
122910: ARRAY
122911: PPUSH
122912: LD_EXP 228
122916: PUSH
122917: LD_VAR 0 6
122921: ARRAY
122922: PUSH
122923: LD_VAR 0 5
122927: ARRAY
122928: PUSH
122929: LD_INT 2
122931: ARRAY
122932: PPUSH
122933: LD_VAR 0 1
122937: PPUSH
122938: CALL_OW 255
122942: PPUSH
122943: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
122947: LD_ADDR_EXP 228
122951: PUSH
122952: LD_EXP 228
122956: PPUSH
122957: LD_VAR 0 6
122961: PPUSH
122962: LD_EXP 228
122966: PUSH
122967: LD_VAR 0 6
122971: ARRAY
122972: PPUSH
122973: LD_VAR 0 5
122977: PPUSH
122978: CALL_OW 3
122982: PPUSH
122983: CALL_OW 1
122987: ST_TO_ADDR
// end ; end ;
122988: GO 122826
122990: POP
122991: POP
// end ;
122992: LD_VAR 0 4
122996: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
122997: LD_INT 0
122999: PPUSH
123000: PPUSH
123001: PPUSH
123002: PPUSH
123003: PPUSH
123004: PPUSH
123005: PPUSH
123006: PPUSH
123007: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
123008: LD_VAR 0 1
123012: PPUSH
123013: CALL_OW 264
123017: PUSH
123018: LD_EXP 102
123022: EQUAL
123023: NOT
123024: PUSH
123025: LD_VAR 0 1
123029: PUSH
123030: LD_EXP 227
123034: IN
123035: NOT
123036: OR
123037: IFFALSE 123041
// exit ;
123039: GO 123363
// index := GetElementIndex ( minersList , unit ) ;
123041: LD_ADDR_VAR 0 6
123045: PUSH
123046: LD_EXP 227
123050: PPUSH
123051: LD_VAR 0 1
123055: PPUSH
123056: CALL 70656 0 2
123060: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
123061: LD_ADDR_VAR 0 8
123065: PUSH
123066: LD_EXP 229
123070: PUSH
123071: LD_EXP 228
123075: PUSH
123076: LD_VAR 0 6
123080: ARRAY
123081: MINUS
123082: ST_TO_ADDR
// if not minesFreeAmount then
123083: LD_VAR 0 8
123087: NOT
123088: IFFALSE 123092
// exit ;
123090: GO 123363
// tmp := [ ] ;
123092: LD_ADDR_VAR 0 7
123096: PUSH
123097: EMPTY
123098: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
123099: LD_ADDR_VAR 0 5
123103: PUSH
123104: DOUBLE
123105: LD_INT 1
123107: DEC
123108: ST_TO_ADDR
123109: LD_VAR 0 8
123113: PUSH
123114: FOR_TO
123115: IFFALSE 123310
// begin _d := rand ( 0 , 5 ) ;
123117: LD_ADDR_VAR 0 11
123121: PUSH
123122: LD_INT 0
123124: PPUSH
123125: LD_INT 5
123127: PPUSH
123128: CALL_OW 12
123132: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
123133: LD_ADDR_VAR 0 12
123137: PUSH
123138: LD_INT 2
123140: PPUSH
123141: LD_INT 6
123143: PPUSH
123144: CALL_OW 12
123148: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
123149: LD_ADDR_VAR 0 9
123153: PUSH
123154: LD_VAR 0 2
123158: PPUSH
123159: LD_VAR 0 11
123163: PPUSH
123164: LD_VAR 0 12
123168: PPUSH
123169: CALL_OW 272
123173: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
123174: LD_ADDR_VAR 0 10
123178: PUSH
123179: LD_VAR 0 3
123183: PPUSH
123184: LD_VAR 0 11
123188: PPUSH
123189: LD_VAR 0 12
123193: PPUSH
123194: CALL_OW 273
123198: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
123199: LD_VAR 0 9
123203: PPUSH
123204: LD_VAR 0 10
123208: PPUSH
123209: CALL_OW 488
123213: PUSH
123214: LD_VAR 0 9
123218: PUSH
123219: LD_VAR 0 10
123223: PUSH
123224: EMPTY
123225: LIST
123226: LIST
123227: PUSH
123228: LD_VAR 0 7
123232: IN
123233: NOT
123234: AND
123235: PUSH
123236: LD_VAR 0 9
123240: PPUSH
123241: LD_VAR 0 10
123245: PPUSH
123246: CALL_OW 458
123250: NOT
123251: AND
123252: IFFALSE 123294
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
123254: LD_ADDR_VAR 0 7
123258: PUSH
123259: LD_VAR 0 7
123263: PPUSH
123264: LD_VAR 0 7
123268: PUSH
123269: LD_INT 1
123271: PLUS
123272: PPUSH
123273: LD_VAR 0 9
123277: PUSH
123278: LD_VAR 0 10
123282: PUSH
123283: EMPTY
123284: LIST
123285: LIST
123286: PPUSH
123287: CALL_OW 1
123291: ST_TO_ADDR
123292: GO 123308
// i := i - 1 ;
123294: LD_ADDR_VAR 0 5
123298: PUSH
123299: LD_VAR 0 5
123303: PUSH
123304: LD_INT 1
123306: MINUS
123307: ST_TO_ADDR
// end ;
123308: GO 123114
123310: POP
123311: POP
// for i in tmp do
123312: LD_ADDR_VAR 0 5
123316: PUSH
123317: LD_VAR 0 7
123321: PUSH
123322: FOR_IN
123323: IFFALSE 123361
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
123325: LD_VAR 0 1
123329: PPUSH
123330: LD_VAR 0 5
123334: PUSH
123335: LD_INT 1
123337: ARRAY
123338: PPUSH
123339: LD_VAR 0 5
123343: PUSH
123344: LD_INT 2
123346: ARRAY
123347: PPUSH
123348: CALL 122303 0 3
123352: NOT
123353: IFFALSE 123359
// exit ;
123355: POP
123356: POP
123357: GO 123363
123359: GO 123322
123361: POP
123362: POP
// end ;
123363: LD_VAR 0 4
123367: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
123368: LD_INT 0
123370: PPUSH
123371: PPUSH
123372: PPUSH
123373: PPUSH
123374: PPUSH
123375: PPUSH
123376: PPUSH
// if not GetClass ( unit ) = class_sniper then
123377: LD_VAR 0 1
123381: PPUSH
123382: CALL_OW 257
123386: PUSH
123387: LD_INT 5
123389: EQUAL
123390: NOT
123391: IFFALSE 123395
// exit ;
123393: GO 123783
// dist := 8 ;
123395: LD_ADDR_VAR 0 5
123399: PUSH
123400: LD_INT 8
123402: ST_TO_ADDR
// viewRange := 12 ;
123403: LD_ADDR_VAR 0 7
123407: PUSH
123408: LD_INT 12
123410: ST_TO_ADDR
// side := GetSide ( unit ) ;
123411: LD_ADDR_VAR 0 6
123415: PUSH
123416: LD_VAR 0 1
123420: PPUSH
123421: CALL_OW 255
123425: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
123426: LD_INT 61
123428: PPUSH
123429: LD_VAR 0 6
123433: PPUSH
123434: CALL_OW 321
123438: PUSH
123439: LD_INT 2
123441: EQUAL
123442: IFFALSE 123452
// viewRange := 16 ;
123444: LD_ADDR_VAR 0 7
123448: PUSH
123449: LD_INT 16
123451: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
123452: LD_VAR 0 1
123456: PPUSH
123457: LD_VAR 0 2
123461: PPUSH
123462: LD_VAR 0 3
123466: PPUSH
123467: CALL_OW 297
123471: PUSH
123472: LD_VAR 0 5
123476: GREATER
123477: IFFALSE 123556
// begin ComMoveXY ( unit , x , y ) ;
123479: LD_VAR 0 1
123483: PPUSH
123484: LD_VAR 0 2
123488: PPUSH
123489: LD_VAR 0 3
123493: PPUSH
123494: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
123498: LD_INT 35
123500: PPUSH
123501: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
123505: LD_VAR 0 1
123509: PPUSH
123510: LD_VAR 0 2
123514: PPUSH
123515: LD_VAR 0 3
123519: PPUSH
123520: CALL 101428 0 3
123524: NOT
123525: IFFALSE 123529
// exit ;
123527: GO 123783
// until GetDistUnitXY ( unit , x , y ) < dist ;
123529: LD_VAR 0 1
123533: PPUSH
123534: LD_VAR 0 2
123538: PPUSH
123539: LD_VAR 0 3
123543: PPUSH
123544: CALL_OW 297
123548: PUSH
123549: LD_VAR 0 5
123553: LESS
123554: IFFALSE 123498
// end ; ComTurnXY ( unit , x , y ) ;
123556: LD_VAR 0 1
123560: PPUSH
123561: LD_VAR 0 2
123565: PPUSH
123566: LD_VAR 0 3
123570: PPUSH
123571: CALL_OW 118
// wait ( 5 ) ;
123575: LD_INT 5
123577: PPUSH
123578: CALL_OW 67
// _d := GetDir ( unit ) ;
123582: LD_ADDR_VAR 0 10
123586: PUSH
123587: LD_VAR 0 1
123591: PPUSH
123592: CALL_OW 254
123596: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
123597: LD_ADDR_VAR 0 8
123601: PUSH
123602: LD_VAR 0 1
123606: PPUSH
123607: CALL_OW 250
123611: PPUSH
123612: LD_VAR 0 10
123616: PPUSH
123617: LD_VAR 0 5
123621: PPUSH
123622: CALL_OW 272
123626: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
123627: LD_ADDR_VAR 0 9
123631: PUSH
123632: LD_VAR 0 1
123636: PPUSH
123637: CALL_OW 251
123641: PPUSH
123642: LD_VAR 0 10
123646: PPUSH
123647: LD_VAR 0 5
123651: PPUSH
123652: CALL_OW 273
123656: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
123657: LD_VAR 0 8
123661: PPUSH
123662: LD_VAR 0 9
123666: PPUSH
123667: CALL_OW 488
123671: NOT
123672: IFFALSE 123676
// exit ;
123674: GO 123783
// ComAnimCustom ( unit , 1 ) ;
123676: LD_VAR 0 1
123680: PPUSH
123681: LD_INT 1
123683: PPUSH
123684: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
123688: LD_VAR 0 8
123692: PPUSH
123693: LD_VAR 0 9
123697: PPUSH
123698: LD_VAR 0 6
123702: PPUSH
123703: LD_VAR 0 7
123707: PPUSH
123708: CALL_OW 330
// repeat wait ( 1 ) ;
123712: LD_INT 1
123714: PPUSH
123715: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
123719: LD_VAR 0 1
123723: PPUSH
123724: CALL_OW 316
123728: PUSH
123729: LD_VAR 0 1
123733: PPUSH
123734: CALL_OW 314
123738: OR
123739: PUSH
123740: LD_VAR 0 1
123744: PPUSH
123745: CALL_OW 302
123749: NOT
123750: OR
123751: PUSH
123752: LD_VAR 0 1
123756: PPUSH
123757: CALL_OW 301
123761: OR
123762: IFFALSE 123712
// RemoveSeeing ( _x , _y , side ) ;
123764: LD_VAR 0 8
123768: PPUSH
123769: LD_VAR 0 9
123773: PPUSH
123774: LD_VAR 0 6
123778: PPUSH
123779: CALL_OW 331
// end ; end_of_file
123783: LD_VAR 0 4
123787: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
123788: LD_INT 0
123790: PPUSH
123791: PPUSH
123792: PPUSH
123793: PPUSH
123794: PPUSH
123795: PPUSH
123796: PPUSH
123797: PPUSH
123798: PPUSH
123799: PPUSH
123800: PPUSH
123801: PPUSH
123802: PPUSH
123803: PPUSH
123804: PPUSH
123805: PPUSH
123806: PPUSH
123807: PPUSH
123808: PPUSH
123809: PPUSH
123810: PPUSH
123811: PPUSH
123812: PPUSH
123813: PPUSH
123814: PPUSH
123815: PPUSH
123816: PPUSH
123817: PPUSH
123818: PPUSH
123819: PPUSH
123820: PPUSH
123821: PPUSH
123822: PPUSH
123823: PPUSH
// if not list then
123824: LD_VAR 0 1
123828: NOT
123829: IFFALSE 123833
// exit ;
123831: GO 128492
// base := list [ 1 ] ;
123833: LD_ADDR_VAR 0 3
123837: PUSH
123838: LD_VAR 0 1
123842: PUSH
123843: LD_INT 1
123845: ARRAY
123846: ST_TO_ADDR
// group := list [ 2 ] ;
123847: LD_ADDR_VAR 0 4
123851: PUSH
123852: LD_VAR 0 1
123856: PUSH
123857: LD_INT 2
123859: ARRAY
123860: ST_TO_ADDR
// path := list [ 3 ] ;
123861: LD_ADDR_VAR 0 5
123865: PUSH
123866: LD_VAR 0 1
123870: PUSH
123871: LD_INT 3
123873: ARRAY
123874: ST_TO_ADDR
// flags := list [ 4 ] ;
123875: LD_ADDR_VAR 0 6
123879: PUSH
123880: LD_VAR 0 1
123884: PUSH
123885: LD_INT 4
123887: ARRAY
123888: ST_TO_ADDR
// mined := [ ] ;
123889: LD_ADDR_VAR 0 27
123893: PUSH
123894: EMPTY
123895: ST_TO_ADDR
// bombed := [ ] ;
123896: LD_ADDR_VAR 0 28
123900: PUSH
123901: EMPTY
123902: ST_TO_ADDR
// healers := [ ] ;
123903: LD_ADDR_VAR 0 31
123907: PUSH
123908: EMPTY
123909: ST_TO_ADDR
// to_heal := [ ] ;
123910: LD_ADDR_VAR 0 30
123914: PUSH
123915: EMPTY
123916: ST_TO_ADDR
// repairs := [ ] ;
123917: LD_ADDR_VAR 0 33
123921: PUSH
123922: EMPTY
123923: ST_TO_ADDR
// to_repair := [ ] ;
123924: LD_ADDR_VAR 0 32
123928: PUSH
123929: EMPTY
123930: ST_TO_ADDR
// if not group or not path then
123931: LD_VAR 0 4
123935: NOT
123936: PUSH
123937: LD_VAR 0 5
123941: NOT
123942: OR
123943: IFFALSE 123947
// exit ;
123945: GO 128492
// side := GetSide ( group [ 1 ] ) ;
123947: LD_ADDR_VAR 0 35
123951: PUSH
123952: LD_VAR 0 4
123956: PUSH
123957: LD_INT 1
123959: ARRAY
123960: PPUSH
123961: CALL_OW 255
123965: ST_TO_ADDR
// if flags then
123966: LD_VAR 0 6
123970: IFFALSE 124114
// begin f_ignore_area := flags [ 1 ] ;
123972: LD_ADDR_VAR 0 17
123976: PUSH
123977: LD_VAR 0 6
123981: PUSH
123982: LD_INT 1
123984: ARRAY
123985: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
123986: LD_ADDR_VAR 0 18
123990: PUSH
123991: LD_VAR 0 6
123995: PUSH
123996: LD_INT 2
123998: ARRAY
123999: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
124000: LD_ADDR_VAR 0 19
124004: PUSH
124005: LD_VAR 0 6
124009: PUSH
124010: LD_INT 3
124012: ARRAY
124013: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
124014: LD_ADDR_VAR 0 20
124018: PUSH
124019: LD_VAR 0 6
124023: PUSH
124024: LD_INT 4
124026: ARRAY
124027: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
124028: LD_ADDR_VAR 0 21
124032: PUSH
124033: LD_VAR 0 6
124037: PUSH
124038: LD_INT 5
124040: ARRAY
124041: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
124042: LD_ADDR_VAR 0 22
124046: PUSH
124047: LD_VAR 0 6
124051: PUSH
124052: LD_INT 6
124054: ARRAY
124055: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
124056: LD_ADDR_VAR 0 23
124060: PUSH
124061: LD_VAR 0 6
124065: PUSH
124066: LD_INT 7
124068: ARRAY
124069: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
124070: LD_ADDR_VAR 0 24
124074: PUSH
124075: LD_VAR 0 6
124079: PUSH
124080: LD_INT 8
124082: ARRAY
124083: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
124084: LD_ADDR_VAR 0 25
124088: PUSH
124089: LD_VAR 0 6
124093: PUSH
124094: LD_INT 9
124096: ARRAY
124097: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
124098: LD_ADDR_VAR 0 26
124102: PUSH
124103: LD_VAR 0 6
124107: PUSH
124108: LD_INT 10
124110: ARRAY
124111: ST_TO_ADDR
// end else
124112: GO 124194
// begin f_ignore_area := false ;
124114: LD_ADDR_VAR 0 17
124118: PUSH
124119: LD_INT 0
124121: ST_TO_ADDR
// f_capture := false ;
124122: LD_ADDR_VAR 0 18
124126: PUSH
124127: LD_INT 0
124129: ST_TO_ADDR
// f_ignore_civ := false ;
124130: LD_ADDR_VAR 0 19
124134: PUSH
124135: LD_INT 0
124137: ST_TO_ADDR
// f_murder := false ;
124138: LD_ADDR_VAR 0 20
124142: PUSH
124143: LD_INT 0
124145: ST_TO_ADDR
// f_mines := false ;
124146: LD_ADDR_VAR 0 21
124150: PUSH
124151: LD_INT 0
124153: ST_TO_ADDR
// f_repair := false ;
124154: LD_ADDR_VAR 0 22
124158: PUSH
124159: LD_INT 0
124161: ST_TO_ADDR
// f_heal := false ;
124162: LD_ADDR_VAR 0 23
124166: PUSH
124167: LD_INT 0
124169: ST_TO_ADDR
// f_spacetime := false ;
124170: LD_ADDR_VAR 0 24
124174: PUSH
124175: LD_INT 0
124177: ST_TO_ADDR
// f_attack_depot := false ;
124178: LD_ADDR_VAR 0 25
124182: PUSH
124183: LD_INT 0
124185: ST_TO_ADDR
// f_crawl := false ;
124186: LD_ADDR_VAR 0 26
124190: PUSH
124191: LD_INT 0
124193: ST_TO_ADDR
// end ; if f_heal then
124194: LD_VAR 0 23
124198: IFFALSE 124225
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
124200: LD_ADDR_VAR 0 31
124204: PUSH
124205: LD_VAR 0 4
124209: PPUSH
124210: LD_INT 25
124212: PUSH
124213: LD_INT 4
124215: PUSH
124216: EMPTY
124217: LIST
124218: LIST
124219: PPUSH
124220: CALL_OW 72
124224: ST_TO_ADDR
// if f_repair then
124225: LD_VAR 0 22
124229: IFFALSE 124256
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
124231: LD_ADDR_VAR 0 33
124235: PUSH
124236: LD_VAR 0 4
124240: PPUSH
124241: LD_INT 25
124243: PUSH
124244: LD_INT 3
124246: PUSH
124247: EMPTY
124248: LIST
124249: LIST
124250: PPUSH
124251: CALL_OW 72
124255: ST_TO_ADDR
// units_path := [ ] ;
124256: LD_ADDR_VAR 0 16
124260: PUSH
124261: EMPTY
124262: ST_TO_ADDR
// for i = 1 to group do
124263: LD_ADDR_VAR 0 7
124267: PUSH
124268: DOUBLE
124269: LD_INT 1
124271: DEC
124272: ST_TO_ADDR
124273: LD_VAR 0 4
124277: PUSH
124278: FOR_TO
124279: IFFALSE 124308
// units_path := Replace ( units_path , i , path ) ;
124281: LD_ADDR_VAR 0 16
124285: PUSH
124286: LD_VAR 0 16
124290: PPUSH
124291: LD_VAR 0 7
124295: PPUSH
124296: LD_VAR 0 5
124300: PPUSH
124301: CALL_OW 1
124305: ST_TO_ADDR
124306: GO 124278
124308: POP
124309: POP
// repeat for i = group downto 1 do
124310: LD_ADDR_VAR 0 7
124314: PUSH
124315: DOUBLE
124316: LD_VAR 0 4
124320: INC
124321: ST_TO_ADDR
124322: LD_INT 1
124324: PUSH
124325: FOR_DOWNTO
124326: IFFALSE 128448
// begin wait ( 5 ) ;
124328: LD_INT 5
124330: PPUSH
124331: CALL_OW 67
// tmp := [ ] ;
124335: LD_ADDR_VAR 0 14
124339: PUSH
124340: EMPTY
124341: ST_TO_ADDR
// attacking := false ;
124342: LD_ADDR_VAR 0 29
124346: PUSH
124347: LD_INT 0
124349: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
124350: LD_VAR 0 4
124354: PUSH
124355: LD_VAR 0 7
124359: ARRAY
124360: PPUSH
124361: CALL_OW 301
124365: PUSH
124366: LD_VAR 0 4
124370: PUSH
124371: LD_VAR 0 7
124375: ARRAY
124376: NOT
124377: OR
124378: IFFALSE 124487
// begin if GetType ( group [ i ] ) = unit_human then
124380: LD_VAR 0 4
124384: PUSH
124385: LD_VAR 0 7
124389: ARRAY
124390: PPUSH
124391: CALL_OW 247
124395: PUSH
124396: LD_INT 1
124398: EQUAL
124399: IFFALSE 124445
// begin to_heal := to_heal diff group [ i ] ;
124401: LD_ADDR_VAR 0 30
124405: PUSH
124406: LD_VAR 0 30
124410: PUSH
124411: LD_VAR 0 4
124415: PUSH
124416: LD_VAR 0 7
124420: ARRAY
124421: DIFF
124422: ST_TO_ADDR
// healers := healers diff group [ i ] ;
124423: LD_ADDR_VAR 0 31
124427: PUSH
124428: LD_VAR 0 31
124432: PUSH
124433: LD_VAR 0 4
124437: PUSH
124438: LD_VAR 0 7
124442: ARRAY
124443: DIFF
124444: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
124445: LD_ADDR_VAR 0 4
124449: PUSH
124450: LD_VAR 0 4
124454: PPUSH
124455: LD_VAR 0 7
124459: PPUSH
124460: CALL_OW 3
124464: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
124465: LD_ADDR_VAR 0 16
124469: PUSH
124470: LD_VAR 0 16
124474: PPUSH
124475: LD_VAR 0 7
124479: PPUSH
124480: CALL_OW 3
124484: ST_TO_ADDR
// continue ;
124485: GO 124325
// end ; if f_repair then
124487: LD_VAR 0 22
124491: IFFALSE 124980
// begin if GetType ( group [ i ] ) = unit_vehicle then
124493: LD_VAR 0 4
124497: PUSH
124498: LD_VAR 0 7
124502: ARRAY
124503: PPUSH
124504: CALL_OW 247
124508: PUSH
124509: LD_INT 2
124511: EQUAL
124512: IFFALSE 124702
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
124514: LD_VAR 0 4
124518: PUSH
124519: LD_VAR 0 7
124523: ARRAY
124524: PPUSH
124525: CALL_OW 256
124529: PUSH
124530: LD_INT 700
124532: LESS
124533: PUSH
124534: LD_VAR 0 4
124538: PUSH
124539: LD_VAR 0 7
124543: ARRAY
124544: PUSH
124545: LD_VAR 0 32
124549: IN
124550: NOT
124551: AND
124552: IFFALSE 124576
// to_repair := to_repair union group [ i ] ;
124554: LD_ADDR_VAR 0 32
124558: PUSH
124559: LD_VAR 0 32
124563: PUSH
124564: LD_VAR 0 4
124568: PUSH
124569: LD_VAR 0 7
124573: ARRAY
124574: UNION
124575: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
124576: LD_VAR 0 4
124580: PUSH
124581: LD_VAR 0 7
124585: ARRAY
124586: PPUSH
124587: CALL_OW 256
124591: PUSH
124592: LD_INT 1000
124594: EQUAL
124595: PUSH
124596: LD_VAR 0 4
124600: PUSH
124601: LD_VAR 0 7
124605: ARRAY
124606: PUSH
124607: LD_VAR 0 32
124611: IN
124612: AND
124613: IFFALSE 124637
// to_repair := to_repair diff group [ i ] ;
124615: LD_ADDR_VAR 0 32
124619: PUSH
124620: LD_VAR 0 32
124624: PUSH
124625: LD_VAR 0 4
124629: PUSH
124630: LD_VAR 0 7
124634: ARRAY
124635: DIFF
124636: ST_TO_ADDR
// if group [ i ] in to_repair then
124637: LD_VAR 0 4
124641: PUSH
124642: LD_VAR 0 7
124646: ARRAY
124647: PUSH
124648: LD_VAR 0 32
124652: IN
124653: IFFALSE 124700
// begin if not IsInArea ( group [ i ] , f_repair ) then
124655: LD_VAR 0 4
124659: PUSH
124660: LD_VAR 0 7
124664: ARRAY
124665: PPUSH
124666: LD_VAR 0 22
124670: PPUSH
124671: CALL_OW 308
124675: NOT
124676: IFFALSE 124698
// ComMoveToArea ( group [ i ] , f_repair ) ;
124678: LD_VAR 0 4
124682: PUSH
124683: LD_VAR 0 7
124687: ARRAY
124688: PPUSH
124689: LD_VAR 0 22
124693: PPUSH
124694: CALL_OW 113
// continue ;
124698: GO 124325
// end ; end else
124700: GO 124980
// if group [ i ] in repairs then
124702: LD_VAR 0 4
124706: PUSH
124707: LD_VAR 0 7
124711: ARRAY
124712: PUSH
124713: LD_VAR 0 33
124717: IN
124718: IFFALSE 124980
// begin if IsInUnit ( group [ i ] ) then
124720: LD_VAR 0 4
124724: PUSH
124725: LD_VAR 0 7
124729: ARRAY
124730: PPUSH
124731: CALL_OW 310
124735: IFFALSE 124803
// begin z := IsInUnit ( group [ i ] ) ;
124737: LD_ADDR_VAR 0 13
124741: PUSH
124742: LD_VAR 0 4
124746: PUSH
124747: LD_VAR 0 7
124751: ARRAY
124752: PPUSH
124753: CALL_OW 310
124757: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
124758: LD_VAR 0 13
124762: PUSH
124763: LD_VAR 0 32
124767: IN
124768: PUSH
124769: LD_VAR 0 13
124773: PPUSH
124774: LD_VAR 0 22
124778: PPUSH
124779: CALL_OW 308
124783: AND
124784: IFFALSE 124801
// ComExitVehicle ( group [ i ] ) ;
124786: LD_VAR 0 4
124790: PUSH
124791: LD_VAR 0 7
124795: ARRAY
124796: PPUSH
124797: CALL_OW 121
// end else
124801: GO 124980
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
124803: LD_ADDR_VAR 0 13
124807: PUSH
124808: LD_VAR 0 4
124812: PPUSH
124813: LD_INT 95
124815: PUSH
124816: LD_VAR 0 22
124820: PUSH
124821: EMPTY
124822: LIST
124823: LIST
124824: PUSH
124825: LD_INT 58
124827: PUSH
124828: EMPTY
124829: LIST
124830: PUSH
124831: EMPTY
124832: LIST
124833: LIST
124834: PPUSH
124835: CALL_OW 72
124839: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
124840: LD_VAR 0 4
124844: PUSH
124845: LD_VAR 0 7
124849: ARRAY
124850: PPUSH
124851: CALL_OW 314
124855: NOT
124856: IFFALSE 124978
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
124858: LD_ADDR_VAR 0 10
124862: PUSH
124863: LD_VAR 0 13
124867: PPUSH
124868: LD_VAR 0 4
124872: PUSH
124873: LD_VAR 0 7
124877: ARRAY
124878: PPUSH
124879: CALL_OW 74
124883: ST_TO_ADDR
// if not x then
124884: LD_VAR 0 10
124888: NOT
124889: IFFALSE 124893
// continue ;
124891: GO 124325
// if GetLives ( x ) < 1000 then
124893: LD_VAR 0 10
124897: PPUSH
124898: CALL_OW 256
124902: PUSH
124903: LD_INT 1000
124905: LESS
124906: IFFALSE 124930
// ComRepairVehicle ( group [ i ] , x ) else
124908: LD_VAR 0 4
124912: PUSH
124913: LD_VAR 0 7
124917: ARRAY
124918: PPUSH
124919: LD_VAR 0 10
124923: PPUSH
124924: CALL_OW 129
124928: GO 124978
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
124930: LD_VAR 0 23
124934: PUSH
124935: LD_VAR 0 4
124939: PUSH
124940: LD_VAR 0 7
124944: ARRAY
124945: PPUSH
124946: CALL_OW 256
124950: PUSH
124951: LD_INT 1000
124953: LESS
124954: AND
124955: NOT
124956: IFFALSE 124978
// ComEnterUnit ( group [ i ] , x ) ;
124958: LD_VAR 0 4
124962: PUSH
124963: LD_VAR 0 7
124967: ARRAY
124968: PPUSH
124969: LD_VAR 0 10
124973: PPUSH
124974: CALL_OW 120
// end ; continue ;
124978: GO 124325
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
124980: LD_VAR 0 23
124984: PUSH
124985: LD_VAR 0 4
124989: PUSH
124990: LD_VAR 0 7
124994: ARRAY
124995: PPUSH
124996: CALL_OW 247
125000: PUSH
125001: LD_INT 1
125003: EQUAL
125004: AND
125005: IFFALSE 125483
// begin if group [ i ] in healers then
125007: LD_VAR 0 4
125011: PUSH
125012: LD_VAR 0 7
125016: ARRAY
125017: PUSH
125018: LD_VAR 0 31
125022: IN
125023: IFFALSE 125296
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
125025: LD_VAR 0 4
125029: PUSH
125030: LD_VAR 0 7
125034: ARRAY
125035: PPUSH
125036: LD_VAR 0 23
125040: PPUSH
125041: CALL_OW 308
125045: NOT
125046: PUSH
125047: LD_VAR 0 4
125051: PUSH
125052: LD_VAR 0 7
125056: ARRAY
125057: PPUSH
125058: CALL_OW 314
125062: NOT
125063: AND
125064: IFFALSE 125088
// ComMoveToArea ( group [ i ] , f_heal ) else
125066: LD_VAR 0 4
125070: PUSH
125071: LD_VAR 0 7
125075: ARRAY
125076: PPUSH
125077: LD_VAR 0 23
125081: PPUSH
125082: CALL_OW 113
125086: GO 125294
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
125088: LD_VAR 0 4
125092: PUSH
125093: LD_VAR 0 7
125097: ARRAY
125098: PPUSH
125099: CALL 99951 0 1
125103: PPUSH
125104: CALL_OW 256
125108: PUSH
125109: LD_INT 1000
125111: EQUAL
125112: IFFALSE 125131
// ComStop ( group [ i ] ) else
125114: LD_VAR 0 4
125118: PUSH
125119: LD_VAR 0 7
125123: ARRAY
125124: PPUSH
125125: CALL_OW 141
125129: GO 125294
// if not HasTask ( group [ i ] ) and to_heal then
125131: LD_VAR 0 4
125135: PUSH
125136: LD_VAR 0 7
125140: ARRAY
125141: PPUSH
125142: CALL_OW 314
125146: NOT
125147: PUSH
125148: LD_VAR 0 30
125152: AND
125153: IFFALSE 125294
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
125155: LD_ADDR_VAR 0 13
125159: PUSH
125160: LD_VAR 0 30
125164: PPUSH
125165: LD_INT 3
125167: PUSH
125168: LD_INT 54
125170: PUSH
125171: EMPTY
125172: LIST
125173: PUSH
125174: EMPTY
125175: LIST
125176: LIST
125177: PPUSH
125178: CALL_OW 72
125182: PPUSH
125183: LD_VAR 0 4
125187: PUSH
125188: LD_VAR 0 7
125192: ARRAY
125193: PPUSH
125194: CALL_OW 74
125198: ST_TO_ADDR
// if z then
125199: LD_VAR 0 13
125203: IFFALSE 125294
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
125205: LD_INT 91
125207: PUSH
125208: LD_VAR 0 13
125212: PUSH
125213: LD_INT 10
125215: PUSH
125216: EMPTY
125217: LIST
125218: LIST
125219: LIST
125220: PUSH
125221: LD_INT 81
125223: PUSH
125224: LD_VAR 0 13
125228: PPUSH
125229: CALL_OW 255
125233: PUSH
125234: EMPTY
125235: LIST
125236: LIST
125237: PUSH
125238: EMPTY
125239: LIST
125240: LIST
125241: PPUSH
125242: CALL_OW 69
125246: PUSH
125247: LD_INT 0
125249: EQUAL
125250: IFFALSE 125274
// ComHeal ( group [ i ] , z ) else
125252: LD_VAR 0 4
125256: PUSH
125257: LD_VAR 0 7
125261: ARRAY
125262: PPUSH
125263: LD_VAR 0 13
125267: PPUSH
125268: CALL_OW 128
125272: GO 125294
// ComMoveToArea ( group [ i ] , f_heal ) ;
125274: LD_VAR 0 4
125278: PUSH
125279: LD_VAR 0 7
125283: ARRAY
125284: PPUSH
125285: LD_VAR 0 23
125289: PPUSH
125290: CALL_OW 113
// end ; continue ;
125294: GO 124325
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
125296: LD_VAR 0 4
125300: PUSH
125301: LD_VAR 0 7
125305: ARRAY
125306: PPUSH
125307: CALL_OW 256
125311: PUSH
125312: LD_INT 700
125314: LESS
125315: PUSH
125316: LD_VAR 0 4
125320: PUSH
125321: LD_VAR 0 7
125325: ARRAY
125326: PUSH
125327: LD_VAR 0 30
125331: IN
125332: NOT
125333: AND
125334: IFFALSE 125358
// to_heal := to_heal union group [ i ] ;
125336: LD_ADDR_VAR 0 30
125340: PUSH
125341: LD_VAR 0 30
125345: PUSH
125346: LD_VAR 0 4
125350: PUSH
125351: LD_VAR 0 7
125355: ARRAY
125356: UNION
125357: ST_TO_ADDR
// if group [ i ] in to_heal then
125358: LD_VAR 0 4
125362: PUSH
125363: LD_VAR 0 7
125367: ARRAY
125368: PUSH
125369: LD_VAR 0 30
125373: IN
125374: IFFALSE 125483
// begin if GetLives ( group [ i ] ) = 1000 then
125376: LD_VAR 0 4
125380: PUSH
125381: LD_VAR 0 7
125385: ARRAY
125386: PPUSH
125387: CALL_OW 256
125391: PUSH
125392: LD_INT 1000
125394: EQUAL
125395: IFFALSE 125421
// to_heal := to_heal diff group [ i ] else
125397: LD_ADDR_VAR 0 30
125401: PUSH
125402: LD_VAR 0 30
125406: PUSH
125407: LD_VAR 0 4
125411: PUSH
125412: LD_VAR 0 7
125416: ARRAY
125417: DIFF
125418: ST_TO_ADDR
125419: GO 125483
// begin if not IsInArea ( group [ i ] , to_heal ) then
125421: LD_VAR 0 4
125425: PUSH
125426: LD_VAR 0 7
125430: ARRAY
125431: PPUSH
125432: LD_VAR 0 30
125436: PPUSH
125437: CALL_OW 308
125441: NOT
125442: IFFALSE 125466
// ComMoveToArea ( group [ i ] , f_heal ) else
125444: LD_VAR 0 4
125448: PUSH
125449: LD_VAR 0 7
125453: ARRAY
125454: PPUSH
125455: LD_VAR 0 23
125459: PPUSH
125460: CALL_OW 113
125464: GO 125481
// ComHold ( group [ i ] ) ;
125466: LD_VAR 0 4
125470: PUSH
125471: LD_VAR 0 7
125475: ARRAY
125476: PPUSH
125477: CALL_OW 140
// continue ;
125481: GO 124325
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
125483: LD_VAR 0 4
125487: PUSH
125488: LD_VAR 0 7
125492: ARRAY
125493: PPUSH
125494: LD_INT 10
125496: PPUSH
125497: CALL 98371 0 2
125501: NOT
125502: PUSH
125503: LD_VAR 0 16
125507: PUSH
125508: LD_VAR 0 7
125512: ARRAY
125513: PUSH
125514: EMPTY
125515: EQUAL
125516: NOT
125517: AND
125518: IFFALSE 125784
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
125520: LD_VAR 0 4
125524: PUSH
125525: LD_VAR 0 7
125529: ARRAY
125530: PPUSH
125531: CALL_OW 262
125535: PUSH
125536: LD_INT 1
125538: PUSH
125539: LD_INT 2
125541: PUSH
125542: EMPTY
125543: LIST
125544: LIST
125545: IN
125546: IFFALSE 125587
// if GetFuel ( group [ i ] ) < 10 then
125548: LD_VAR 0 4
125552: PUSH
125553: LD_VAR 0 7
125557: ARRAY
125558: PPUSH
125559: CALL_OW 261
125563: PUSH
125564: LD_INT 10
125566: LESS
125567: IFFALSE 125587
// SetFuel ( group [ i ] , 12 ) ;
125569: LD_VAR 0 4
125573: PUSH
125574: LD_VAR 0 7
125578: ARRAY
125579: PPUSH
125580: LD_INT 12
125582: PPUSH
125583: CALL_OW 240
// if units_path [ i ] then
125587: LD_VAR 0 16
125591: PUSH
125592: LD_VAR 0 7
125596: ARRAY
125597: IFFALSE 125782
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
125599: LD_VAR 0 4
125603: PUSH
125604: LD_VAR 0 7
125608: ARRAY
125609: PPUSH
125610: LD_VAR 0 16
125614: PUSH
125615: LD_VAR 0 7
125619: ARRAY
125620: PUSH
125621: LD_INT 1
125623: ARRAY
125624: PUSH
125625: LD_INT 1
125627: ARRAY
125628: PPUSH
125629: LD_VAR 0 16
125633: PUSH
125634: LD_VAR 0 7
125638: ARRAY
125639: PUSH
125640: LD_INT 1
125642: ARRAY
125643: PUSH
125644: LD_INT 2
125646: ARRAY
125647: PPUSH
125648: CALL_OW 297
125652: PUSH
125653: LD_INT 6
125655: GREATER
125656: IFFALSE 125731
// begin if not HasTask ( group [ i ] ) then
125658: LD_VAR 0 4
125662: PUSH
125663: LD_VAR 0 7
125667: ARRAY
125668: PPUSH
125669: CALL_OW 314
125673: NOT
125674: IFFALSE 125729
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
125676: LD_VAR 0 4
125680: PUSH
125681: LD_VAR 0 7
125685: ARRAY
125686: PPUSH
125687: LD_VAR 0 16
125691: PUSH
125692: LD_VAR 0 7
125696: ARRAY
125697: PUSH
125698: LD_INT 1
125700: ARRAY
125701: PUSH
125702: LD_INT 1
125704: ARRAY
125705: PPUSH
125706: LD_VAR 0 16
125710: PUSH
125711: LD_VAR 0 7
125715: ARRAY
125716: PUSH
125717: LD_INT 1
125719: ARRAY
125720: PUSH
125721: LD_INT 2
125723: ARRAY
125724: PPUSH
125725: CALL_OW 114
// end else
125729: GO 125782
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
125731: LD_ADDR_VAR 0 15
125735: PUSH
125736: LD_VAR 0 16
125740: PUSH
125741: LD_VAR 0 7
125745: ARRAY
125746: PPUSH
125747: LD_INT 1
125749: PPUSH
125750: CALL_OW 3
125754: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
125755: LD_ADDR_VAR 0 16
125759: PUSH
125760: LD_VAR 0 16
125764: PPUSH
125765: LD_VAR 0 7
125769: PPUSH
125770: LD_VAR 0 15
125774: PPUSH
125775: CALL_OW 1
125779: ST_TO_ADDR
// continue ;
125780: GO 124325
// end ; end ; end else
125782: GO 128446
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
125784: LD_ADDR_VAR 0 14
125788: PUSH
125789: LD_INT 81
125791: PUSH
125792: LD_VAR 0 4
125796: PUSH
125797: LD_VAR 0 7
125801: ARRAY
125802: PPUSH
125803: CALL_OW 255
125807: PUSH
125808: EMPTY
125809: LIST
125810: LIST
125811: PPUSH
125812: CALL_OW 69
125816: ST_TO_ADDR
// if not tmp then
125817: LD_VAR 0 14
125821: NOT
125822: IFFALSE 125826
// continue ;
125824: GO 124325
// if f_ignore_area then
125826: LD_VAR 0 17
125830: IFFALSE 125918
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
125832: LD_ADDR_VAR 0 15
125836: PUSH
125837: LD_VAR 0 14
125841: PPUSH
125842: LD_INT 3
125844: PUSH
125845: LD_INT 92
125847: PUSH
125848: LD_VAR 0 17
125852: PUSH
125853: LD_INT 1
125855: ARRAY
125856: PUSH
125857: LD_VAR 0 17
125861: PUSH
125862: LD_INT 2
125864: ARRAY
125865: PUSH
125866: LD_VAR 0 17
125870: PUSH
125871: LD_INT 3
125873: ARRAY
125874: PUSH
125875: EMPTY
125876: LIST
125877: LIST
125878: LIST
125879: LIST
125880: PUSH
125881: EMPTY
125882: LIST
125883: LIST
125884: PPUSH
125885: CALL_OW 72
125889: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
125890: LD_VAR 0 14
125894: PUSH
125895: LD_VAR 0 15
125899: DIFF
125900: IFFALSE 125918
// tmp := tmp diff tmp2 ;
125902: LD_ADDR_VAR 0 14
125906: PUSH
125907: LD_VAR 0 14
125911: PUSH
125912: LD_VAR 0 15
125916: DIFF
125917: ST_TO_ADDR
// end ; if not f_murder then
125918: LD_VAR 0 20
125922: NOT
125923: IFFALSE 125981
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
125925: LD_ADDR_VAR 0 15
125929: PUSH
125930: LD_VAR 0 14
125934: PPUSH
125935: LD_INT 3
125937: PUSH
125938: LD_INT 50
125940: PUSH
125941: EMPTY
125942: LIST
125943: PUSH
125944: EMPTY
125945: LIST
125946: LIST
125947: PPUSH
125948: CALL_OW 72
125952: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
125953: LD_VAR 0 14
125957: PUSH
125958: LD_VAR 0 15
125962: DIFF
125963: IFFALSE 125981
// tmp := tmp diff tmp2 ;
125965: LD_ADDR_VAR 0 14
125969: PUSH
125970: LD_VAR 0 14
125974: PUSH
125975: LD_VAR 0 15
125979: DIFF
125980: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
125981: LD_ADDR_VAR 0 14
125985: PUSH
125986: LD_VAR 0 4
125990: PUSH
125991: LD_VAR 0 7
125995: ARRAY
125996: PPUSH
125997: LD_VAR 0 14
126001: PPUSH
126002: LD_INT 1
126004: PPUSH
126005: LD_INT 1
126007: PPUSH
126008: CALL 71306 0 4
126012: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
126013: LD_VAR 0 4
126017: PUSH
126018: LD_VAR 0 7
126022: ARRAY
126023: PPUSH
126024: CALL_OW 257
126028: PUSH
126029: LD_INT 1
126031: EQUAL
126032: IFFALSE 126480
// begin if WantPlant ( group [ i ] ) then
126034: LD_VAR 0 4
126038: PUSH
126039: LD_VAR 0 7
126043: ARRAY
126044: PPUSH
126045: CALL 70807 0 1
126049: IFFALSE 126053
// continue ;
126051: GO 124325
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
126053: LD_VAR 0 18
126057: PUSH
126058: LD_VAR 0 4
126062: PUSH
126063: LD_VAR 0 7
126067: ARRAY
126068: PPUSH
126069: CALL_OW 310
126073: NOT
126074: AND
126075: PUSH
126076: LD_VAR 0 14
126080: PUSH
126081: LD_INT 1
126083: ARRAY
126084: PUSH
126085: LD_VAR 0 14
126089: PPUSH
126090: LD_INT 21
126092: PUSH
126093: LD_INT 2
126095: PUSH
126096: EMPTY
126097: LIST
126098: LIST
126099: PUSH
126100: LD_INT 58
126102: PUSH
126103: EMPTY
126104: LIST
126105: PUSH
126106: EMPTY
126107: LIST
126108: LIST
126109: PPUSH
126110: CALL_OW 72
126114: IN
126115: AND
126116: IFFALSE 126152
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
126118: LD_VAR 0 4
126122: PUSH
126123: LD_VAR 0 7
126127: ARRAY
126128: PPUSH
126129: LD_VAR 0 14
126133: PUSH
126134: LD_INT 1
126136: ARRAY
126137: PPUSH
126138: CALL_OW 120
// attacking := true ;
126142: LD_ADDR_VAR 0 29
126146: PUSH
126147: LD_INT 1
126149: ST_TO_ADDR
// continue ;
126150: GO 124325
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
126152: LD_VAR 0 26
126156: PUSH
126157: LD_VAR 0 4
126161: PUSH
126162: LD_VAR 0 7
126166: ARRAY
126167: PPUSH
126168: CALL_OW 257
126172: PUSH
126173: LD_INT 1
126175: EQUAL
126176: AND
126177: PUSH
126178: LD_VAR 0 4
126182: PUSH
126183: LD_VAR 0 7
126187: ARRAY
126188: PPUSH
126189: CALL_OW 256
126193: PUSH
126194: LD_INT 800
126196: LESS
126197: AND
126198: PUSH
126199: LD_VAR 0 4
126203: PUSH
126204: LD_VAR 0 7
126208: ARRAY
126209: PPUSH
126210: CALL_OW 318
126214: NOT
126215: AND
126216: IFFALSE 126233
// ComCrawl ( group [ i ] ) ;
126218: LD_VAR 0 4
126222: PUSH
126223: LD_VAR 0 7
126227: ARRAY
126228: PPUSH
126229: CALL_OW 137
// if f_mines then
126233: LD_VAR 0 21
126237: IFFALSE 126480
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
126239: LD_VAR 0 14
126243: PUSH
126244: LD_INT 1
126246: ARRAY
126247: PPUSH
126248: CALL_OW 247
126252: PUSH
126253: LD_INT 3
126255: EQUAL
126256: PUSH
126257: LD_VAR 0 14
126261: PUSH
126262: LD_INT 1
126264: ARRAY
126265: PUSH
126266: LD_VAR 0 27
126270: IN
126271: NOT
126272: AND
126273: IFFALSE 126480
// begin x := GetX ( tmp [ 1 ] ) ;
126275: LD_ADDR_VAR 0 10
126279: PUSH
126280: LD_VAR 0 14
126284: PUSH
126285: LD_INT 1
126287: ARRAY
126288: PPUSH
126289: CALL_OW 250
126293: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
126294: LD_ADDR_VAR 0 11
126298: PUSH
126299: LD_VAR 0 14
126303: PUSH
126304: LD_INT 1
126306: ARRAY
126307: PPUSH
126308: CALL_OW 251
126312: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
126313: LD_ADDR_VAR 0 12
126317: PUSH
126318: LD_VAR 0 4
126322: PUSH
126323: LD_VAR 0 7
126327: ARRAY
126328: PPUSH
126329: CALL 98456 0 1
126333: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
126334: LD_VAR 0 4
126338: PUSH
126339: LD_VAR 0 7
126343: ARRAY
126344: PPUSH
126345: LD_VAR 0 10
126349: PPUSH
126350: LD_VAR 0 11
126354: PPUSH
126355: LD_VAR 0 14
126359: PUSH
126360: LD_INT 1
126362: ARRAY
126363: PPUSH
126364: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
126368: LD_VAR 0 4
126372: PUSH
126373: LD_VAR 0 7
126377: ARRAY
126378: PPUSH
126379: LD_VAR 0 10
126383: PPUSH
126384: LD_VAR 0 12
126388: PPUSH
126389: LD_INT 7
126391: PPUSH
126392: CALL_OW 272
126396: PPUSH
126397: LD_VAR 0 11
126401: PPUSH
126402: LD_VAR 0 12
126406: PPUSH
126407: LD_INT 7
126409: PPUSH
126410: CALL_OW 273
126414: PPUSH
126415: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
126419: LD_VAR 0 4
126423: PUSH
126424: LD_VAR 0 7
126428: ARRAY
126429: PPUSH
126430: LD_INT 71
126432: PPUSH
126433: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
126437: LD_ADDR_VAR 0 27
126441: PUSH
126442: LD_VAR 0 27
126446: PPUSH
126447: LD_VAR 0 27
126451: PUSH
126452: LD_INT 1
126454: PLUS
126455: PPUSH
126456: LD_VAR 0 14
126460: PUSH
126461: LD_INT 1
126463: ARRAY
126464: PPUSH
126465: CALL_OW 1
126469: ST_TO_ADDR
// attacking := true ;
126470: LD_ADDR_VAR 0 29
126474: PUSH
126475: LD_INT 1
126477: ST_TO_ADDR
// continue ;
126478: GO 124325
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
126480: LD_VAR 0 4
126484: PUSH
126485: LD_VAR 0 7
126489: ARRAY
126490: PPUSH
126491: CALL_OW 257
126495: PUSH
126496: LD_INT 17
126498: EQUAL
126499: PUSH
126500: LD_VAR 0 4
126504: PUSH
126505: LD_VAR 0 7
126509: ARRAY
126510: PPUSH
126511: CALL_OW 110
126515: PUSH
126516: LD_INT 71
126518: EQUAL
126519: NOT
126520: AND
126521: IFFALSE 126667
// begin attacking := false ;
126523: LD_ADDR_VAR 0 29
126527: PUSH
126528: LD_INT 0
126530: ST_TO_ADDR
// k := 5 ;
126531: LD_ADDR_VAR 0 9
126535: PUSH
126536: LD_INT 5
126538: ST_TO_ADDR
// if tmp < k then
126539: LD_VAR 0 14
126543: PUSH
126544: LD_VAR 0 9
126548: LESS
126549: IFFALSE 126561
// k := tmp ;
126551: LD_ADDR_VAR 0 9
126555: PUSH
126556: LD_VAR 0 14
126560: ST_TO_ADDR
// for j = 1 to k do
126561: LD_ADDR_VAR 0 8
126565: PUSH
126566: DOUBLE
126567: LD_INT 1
126569: DEC
126570: ST_TO_ADDR
126571: LD_VAR 0 9
126575: PUSH
126576: FOR_TO
126577: IFFALSE 126665
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
126579: LD_VAR 0 14
126583: PUSH
126584: LD_VAR 0 8
126588: ARRAY
126589: PUSH
126590: LD_VAR 0 14
126594: PPUSH
126595: LD_INT 58
126597: PUSH
126598: EMPTY
126599: LIST
126600: PPUSH
126601: CALL_OW 72
126605: IN
126606: NOT
126607: IFFALSE 126663
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
126609: LD_VAR 0 4
126613: PUSH
126614: LD_VAR 0 7
126618: ARRAY
126619: PPUSH
126620: LD_VAR 0 14
126624: PUSH
126625: LD_VAR 0 8
126629: ARRAY
126630: PPUSH
126631: CALL_OW 115
// attacking := true ;
126635: LD_ADDR_VAR 0 29
126639: PUSH
126640: LD_INT 1
126642: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
126643: LD_VAR 0 4
126647: PUSH
126648: LD_VAR 0 7
126652: ARRAY
126653: PPUSH
126654: LD_INT 71
126656: PPUSH
126657: CALL_OW 109
// continue ;
126661: GO 126576
// end ; end ;
126663: GO 126576
126665: POP
126666: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
126667: LD_VAR 0 4
126671: PUSH
126672: LD_VAR 0 7
126676: ARRAY
126677: PPUSH
126678: CALL_OW 257
126682: PUSH
126683: LD_INT 8
126685: EQUAL
126686: PUSH
126687: LD_VAR 0 4
126691: PUSH
126692: LD_VAR 0 7
126696: ARRAY
126697: PPUSH
126698: CALL_OW 264
126702: PUSH
126703: LD_INT 28
126705: PUSH
126706: LD_INT 45
126708: PUSH
126709: LD_INT 7
126711: PUSH
126712: LD_INT 47
126714: PUSH
126715: EMPTY
126716: LIST
126717: LIST
126718: LIST
126719: LIST
126720: IN
126721: OR
126722: IFFALSE 126978
// begin attacking := false ;
126724: LD_ADDR_VAR 0 29
126728: PUSH
126729: LD_INT 0
126731: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
126732: LD_VAR 0 14
126736: PUSH
126737: LD_INT 1
126739: ARRAY
126740: PPUSH
126741: CALL_OW 266
126745: PUSH
126746: LD_INT 32
126748: PUSH
126749: LD_INT 31
126751: PUSH
126752: LD_INT 33
126754: PUSH
126755: LD_INT 4
126757: PUSH
126758: LD_INT 5
126760: PUSH
126761: EMPTY
126762: LIST
126763: LIST
126764: LIST
126765: LIST
126766: LIST
126767: IN
126768: IFFALSE 126954
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
126770: LD_ADDR_VAR 0 9
126774: PUSH
126775: LD_VAR 0 14
126779: PUSH
126780: LD_INT 1
126782: ARRAY
126783: PPUSH
126784: CALL_OW 266
126788: PPUSH
126789: LD_VAR 0 14
126793: PUSH
126794: LD_INT 1
126796: ARRAY
126797: PPUSH
126798: CALL_OW 250
126802: PPUSH
126803: LD_VAR 0 14
126807: PUSH
126808: LD_INT 1
126810: ARRAY
126811: PPUSH
126812: CALL_OW 251
126816: PPUSH
126817: LD_VAR 0 14
126821: PUSH
126822: LD_INT 1
126824: ARRAY
126825: PPUSH
126826: CALL_OW 254
126830: PPUSH
126831: LD_VAR 0 14
126835: PUSH
126836: LD_INT 1
126838: ARRAY
126839: PPUSH
126840: CALL_OW 248
126844: PPUSH
126845: LD_INT 0
126847: PPUSH
126848: CALL 79826 0 6
126852: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
126853: LD_ADDR_VAR 0 8
126857: PUSH
126858: LD_VAR 0 4
126862: PUSH
126863: LD_VAR 0 7
126867: ARRAY
126868: PPUSH
126869: LD_VAR 0 9
126873: PPUSH
126874: CALL 98496 0 2
126878: ST_TO_ADDR
// if j then
126879: LD_VAR 0 8
126883: IFFALSE 126952
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
126885: LD_VAR 0 8
126889: PUSH
126890: LD_INT 1
126892: ARRAY
126893: PPUSH
126894: LD_VAR 0 8
126898: PUSH
126899: LD_INT 2
126901: ARRAY
126902: PPUSH
126903: CALL_OW 488
126907: IFFALSE 126952
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
126909: LD_VAR 0 4
126913: PUSH
126914: LD_VAR 0 7
126918: ARRAY
126919: PPUSH
126920: LD_VAR 0 8
126924: PUSH
126925: LD_INT 1
126927: ARRAY
126928: PPUSH
126929: LD_VAR 0 8
126933: PUSH
126934: LD_INT 2
126936: ARRAY
126937: PPUSH
126938: CALL_OW 116
// attacking := true ;
126942: LD_ADDR_VAR 0 29
126946: PUSH
126947: LD_INT 1
126949: ST_TO_ADDR
// continue ;
126950: GO 124325
// end ; end else
126952: GO 126978
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
126954: LD_VAR 0 4
126958: PUSH
126959: LD_VAR 0 7
126963: ARRAY
126964: PPUSH
126965: LD_VAR 0 14
126969: PUSH
126970: LD_INT 1
126972: ARRAY
126973: PPUSH
126974: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
126978: LD_VAR 0 4
126982: PUSH
126983: LD_VAR 0 7
126987: ARRAY
126988: PPUSH
126989: CALL_OW 265
126993: PUSH
126994: LD_INT 11
126996: EQUAL
126997: IFFALSE 127275
// begin k := 10 ;
126999: LD_ADDR_VAR 0 9
127003: PUSH
127004: LD_INT 10
127006: ST_TO_ADDR
// x := 0 ;
127007: LD_ADDR_VAR 0 10
127011: PUSH
127012: LD_INT 0
127014: ST_TO_ADDR
// if tmp < k then
127015: LD_VAR 0 14
127019: PUSH
127020: LD_VAR 0 9
127024: LESS
127025: IFFALSE 127037
// k := tmp ;
127027: LD_ADDR_VAR 0 9
127031: PUSH
127032: LD_VAR 0 14
127036: ST_TO_ADDR
// for j = k downto 1 do
127037: LD_ADDR_VAR 0 8
127041: PUSH
127042: DOUBLE
127043: LD_VAR 0 9
127047: INC
127048: ST_TO_ADDR
127049: LD_INT 1
127051: PUSH
127052: FOR_DOWNTO
127053: IFFALSE 127128
// begin if GetType ( tmp [ j ] ) = unit_human then
127055: LD_VAR 0 14
127059: PUSH
127060: LD_VAR 0 8
127064: ARRAY
127065: PPUSH
127066: CALL_OW 247
127070: PUSH
127071: LD_INT 1
127073: EQUAL
127074: IFFALSE 127126
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
127076: LD_VAR 0 4
127080: PUSH
127081: LD_VAR 0 7
127085: ARRAY
127086: PPUSH
127087: LD_VAR 0 14
127091: PUSH
127092: LD_VAR 0 8
127096: ARRAY
127097: PPUSH
127098: CALL 98767 0 2
// x := tmp [ j ] ;
127102: LD_ADDR_VAR 0 10
127106: PUSH
127107: LD_VAR 0 14
127111: PUSH
127112: LD_VAR 0 8
127116: ARRAY
127117: ST_TO_ADDR
// attacking := true ;
127118: LD_ADDR_VAR 0 29
127122: PUSH
127123: LD_INT 1
127125: ST_TO_ADDR
// end ; end ;
127126: GO 127052
127128: POP
127129: POP
// if not x then
127130: LD_VAR 0 10
127134: NOT
127135: IFFALSE 127275
// begin attacking := true ;
127137: LD_ADDR_VAR 0 29
127141: PUSH
127142: LD_INT 1
127144: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
127145: LD_VAR 0 4
127149: PUSH
127150: LD_VAR 0 7
127154: ARRAY
127155: PPUSH
127156: CALL_OW 250
127160: PPUSH
127161: LD_VAR 0 4
127165: PUSH
127166: LD_VAR 0 7
127170: ARRAY
127171: PPUSH
127172: CALL_OW 251
127176: PPUSH
127177: CALL_OW 546
127181: PUSH
127182: LD_INT 2
127184: ARRAY
127185: PUSH
127186: LD_VAR 0 14
127190: PUSH
127191: LD_INT 1
127193: ARRAY
127194: PPUSH
127195: CALL_OW 250
127199: PPUSH
127200: LD_VAR 0 14
127204: PUSH
127205: LD_INT 1
127207: ARRAY
127208: PPUSH
127209: CALL_OW 251
127213: PPUSH
127214: CALL_OW 546
127218: PUSH
127219: LD_INT 2
127221: ARRAY
127222: EQUAL
127223: IFFALSE 127251
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
127225: LD_VAR 0 4
127229: PUSH
127230: LD_VAR 0 7
127234: ARRAY
127235: PPUSH
127236: LD_VAR 0 14
127240: PUSH
127241: LD_INT 1
127243: ARRAY
127244: PPUSH
127245: CALL 98767 0 2
127249: GO 127275
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
127251: LD_VAR 0 4
127255: PUSH
127256: LD_VAR 0 7
127260: ARRAY
127261: PPUSH
127262: LD_VAR 0 14
127266: PUSH
127267: LD_INT 1
127269: ARRAY
127270: PPUSH
127271: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
127275: LD_VAR 0 4
127279: PUSH
127280: LD_VAR 0 7
127284: ARRAY
127285: PPUSH
127286: CALL_OW 264
127290: PUSH
127291: LD_INT 29
127293: EQUAL
127294: IFFALSE 127660
// begin if WantsToAttack ( group [ i ] ) in bombed then
127296: LD_VAR 0 4
127300: PUSH
127301: LD_VAR 0 7
127305: ARRAY
127306: PPUSH
127307: CALL_OW 319
127311: PUSH
127312: LD_VAR 0 28
127316: IN
127317: IFFALSE 127321
// continue ;
127319: GO 124325
// k := 8 ;
127321: LD_ADDR_VAR 0 9
127325: PUSH
127326: LD_INT 8
127328: ST_TO_ADDR
// x := 0 ;
127329: LD_ADDR_VAR 0 10
127333: PUSH
127334: LD_INT 0
127336: ST_TO_ADDR
// if tmp < k then
127337: LD_VAR 0 14
127341: PUSH
127342: LD_VAR 0 9
127346: LESS
127347: IFFALSE 127359
// k := tmp ;
127349: LD_ADDR_VAR 0 9
127353: PUSH
127354: LD_VAR 0 14
127358: ST_TO_ADDR
// for j = 1 to k do
127359: LD_ADDR_VAR 0 8
127363: PUSH
127364: DOUBLE
127365: LD_INT 1
127367: DEC
127368: ST_TO_ADDR
127369: LD_VAR 0 9
127373: PUSH
127374: FOR_TO
127375: IFFALSE 127507
// begin if GetType ( tmp [ j ] ) = unit_building then
127377: LD_VAR 0 14
127381: PUSH
127382: LD_VAR 0 8
127386: ARRAY
127387: PPUSH
127388: CALL_OW 247
127392: PUSH
127393: LD_INT 3
127395: EQUAL
127396: IFFALSE 127505
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
127398: LD_VAR 0 14
127402: PUSH
127403: LD_VAR 0 8
127407: ARRAY
127408: PUSH
127409: LD_VAR 0 28
127413: IN
127414: NOT
127415: PUSH
127416: LD_VAR 0 14
127420: PUSH
127421: LD_VAR 0 8
127425: ARRAY
127426: PPUSH
127427: CALL_OW 313
127431: AND
127432: IFFALSE 127505
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
127434: LD_VAR 0 4
127438: PUSH
127439: LD_VAR 0 7
127443: ARRAY
127444: PPUSH
127445: LD_VAR 0 14
127449: PUSH
127450: LD_VAR 0 8
127454: ARRAY
127455: PPUSH
127456: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
127460: LD_ADDR_VAR 0 28
127464: PUSH
127465: LD_VAR 0 28
127469: PPUSH
127470: LD_VAR 0 28
127474: PUSH
127475: LD_INT 1
127477: PLUS
127478: PPUSH
127479: LD_VAR 0 14
127483: PUSH
127484: LD_VAR 0 8
127488: ARRAY
127489: PPUSH
127490: CALL_OW 1
127494: ST_TO_ADDR
// attacking := true ;
127495: LD_ADDR_VAR 0 29
127499: PUSH
127500: LD_INT 1
127502: ST_TO_ADDR
// break ;
127503: GO 127507
// end ; end ;
127505: GO 127374
127507: POP
127508: POP
// if not attacking and f_attack_depot then
127509: LD_VAR 0 29
127513: NOT
127514: PUSH
127515: LD_VAR 0 25
127519: AND
127520: IFFALSE 127615
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
127522: LD_ADDR_VAR 0 13
127526: PUSH
127527: LD_VAR 0 14
127531: PPUSH
127532: LD_INT 2
127534: PUSH
127535: LD_INT 30
127537: PUSH
127538: LD_INT 0
127540: PUSH
127541: EMPTY
127542: LIST
127543: LIST
127544: PUSH
127545: LD_INT 30
127547: PUSH
127548: LD_INT 1
127550: PUSH
127551: EMPTY
127552: LIST
127553: LIST
127554: PUSH
127555: EMPTY
127556: LIST
127557: LIST
127558: LIST
127559: PPUSH
127560: CALL_OW 72
127564: ST_TO_ADDR
// if z then
127565: LD_VAR 0 13
127569: IFFALSE 127615
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
127571: LD_VAR 0 4
127575: PUSH
127576: LD_VAR 0 7
127580: ARRAY
127581: PPUSH
127582: LD_VAR 0 13
127586: PPUSH
127587: LD_VAR 0 4
127591: PUSH
127592: LD_VAR 0 7
127596: ARRAY
127597: PPUSH
127598: CALL_OW 74
127602: PPUSH
127603: CALL_OW 115
// attacking := true ;
127607: LD_ADDR_VAR 0 29
127611: PUSH
127612: LD_INT 1
127614: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
127615: LD_VAR 0 4
127619: PUSH
127620: LD_VAR 0 7
127624: ARRAY
127625: PPUSH
127626: CALL_OW 256
127630: PUSH
127631: LD_INT 500
127633: LESS
127634: IFFALSE 127660
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
127636: LD_VAR 0 4
127640: PUSH
127641: LD_VAR 0 7
127645: ARRAY
127646: PPUSH
127647: LD_VAR 0 14
127651: PUSH
127652: LD_INT 1
127654: ARRAY
127655: PPUSH
127656: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
127660: LD_VAR 0 4
127664: PUSH
127665: LD_VAR 0 7
127669: ARRAY
127670: PPUSH
127671: CALL_OW 264
127675: PUSH
127676: LD_INT 49
127678: EQUAL
127679: IFFALSE 127800
// begin if not HasTask ( group [ i ] ) then
127681: LD_VAR 0 4
127685: PUSH
127686: LD_VAR 0 7
127690: ARRAY
127691: PPUSH
127692: CALL_OW 314
127696: NOT
127697: IFFALSE 127800
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
127699: LD_ADDR_VAR 0 9
127703: PUSH
127704: LD_INT 81
127706: PUSH
127707: LD_VAR 0 4
127711: PUSH
127712: LD_VAR 0 7
127716: ARRAY
127717: PPUSH
127718: CALL_OW 255
127722: PUSH
127723: EMPTY
127724: LIST
127725: LIST
127726: PPUSH
127727: CALL_OW 69
127731: PPUSH
127732: LD_VAR 0 4
127736: PUSH
127737: LD_VAR 0 7
127741: ARRAY
127742: PPUSH
127743: CALL_OW 74
127747: ST_TO_ADDR
// if k then
127748: LD_VAR 0 9
127752: IFFALSE 127800
// if GetDistUnits ( group [ i ] , k ) > 10 then
127754: LD_VAR 0 4
127758: PUSH
127759: LD_VAR 0 7
127763: ARRAY
127764: PPUSH
127765: LD_VAR 0 9
127769: PPUSH
127770: CALL_OW 296
127774: PUSH
127775: LD_INT 10
127777: GREATER
127778: IFFALSE 127800
// ComMoveUnit ( group [ i ] , k ) ;
127780: LD_VAR 0 4
127784: PUSH
127785: LD_VAR 0 7
127789: ARRAY
127790: PPUSH
127791: LD_VAR 0 9
127795: PPUSH
127796: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
127800: LD_VAR 0 4
127804: PUSH
127805: LD_VAR 0 7
127809: ARRAY
127810: PPUSH
127811: CALL_OW 256
127815: PUSH
127816: LD_INT 250
127818: LESS
127819: PUSH
127820: LD_VAR 0 4
127824: PUSH
127825: LD_VAR 0 7
127829: ARRAY
127830: PUSH
127831: LD_INT 21
127833: PUSH
127834: LD_INT 2
127836: PUSH
127837: EMPTY
127838: LIST
127839: LIST
127840: PUSH
127841: LD_INT 23
127843: PUSH
127844: LD_INT 2
127846: PUSH
127847: EMPTY
127848: LIST
127849: LIST
127850: PUSH
127851: EMPTY
127852: LIST
127853: LIST
127854: PPUSH
127855: CALL_OW 69
127859: IN
127860: AND
127861: IFFALSE 127986
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
127863: LD_ADDR_VAR 0 9
127867: PUSH
127868: LD_OWVAR 3
127872: PUSH
127873: LD_VAR 0 4
127877: PUSH
127878: LD_VAR 0 7
127882: ARRAY
127883: DIFF
127884: PPUSH
127885: LD_VAR 0 4
127889: PUSH
127890: LD_VAR 0 7
127894: ARRAY
127895: PPUSH
127896: CALL_OW 74
127900: ST_TO_ADDR
// if not k then
127901: LD_VAR 0 9
127905: NOT
127906: IFFALSE 127910
// continue ;
127908: GO 124325
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
127910: LD_VAR 0 9
127914: PUSH
127915: LD_INT 81
127917: PUSH
127918: LD_VAR 0 4
127922: PUSH
127923: LD_VAR 0 7
127927: ARRAY
127928: PPUSH
127929: CALL_OW 255
127933: PUSH
127934: EMPTY
127935: LIST
127936: LIST
127937: PPUSH
127938: CALL_OW 69
127942: IN
127943: PUSH
127944: LD_VAR 0 9
127948: PPUSH
127949: LD_VAR 0 4
127953: PUSH
127954: LD_VAR 0 7
127958: ARRAY
127959: PPUSH
127960: CALL_OW 296
127964: PUSH
127965: LD_INT 5
127967: LESS
127968: AND
127969: IFFALSE 127986
// ComAutodestruct ( group [ i ] ) ;
127971: LD_VAR 0 4
127975: PUSH
127976: LD_VAR 0 7
127980: ARRAY
127981: PPUSH
127982: CALL 98665 0 1
// end ; if f_attack_depot then
127986: LD_VAR 0 25
127990: IFFALSE 128102
// begin k := 6 ;
127992: LD_ADDR_VAR 0 9
127996: PUSH
127997: LD_INT 6
127999: ST_TO_ADDR
// if tmp < k then
128000: LD_VAR 0 14
128004: PUSH
128005: LD_VAR 0 9
128009: LESS
128010: IFFALSE 128022
// k := tmp ;
128012: LD_ADDR_VAR 0 9
128016: PUSH
128017: LD_VAR 0 14
128021: ST_TO_ADDR
// for j = 1 to k do
128022: LD_ADDR_VAR 0 8
128026: PUSH
128027: DOUBLE
128028: LD_INT 1
128030: DEC
128031: ST_TO_ADDR
128032: LD_VAR 0 9
128036: PUSH
128037: FOR_TO
128038: IFFALSE 128100
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
128040: LD_VAR 0 8
128044: PPUSH
128045: CALL_OW 266
128049: PUSH
128050: LD_INT 0
128052: PUSH
128053: LD_INT 1
128055: PUSH
128056: EMPTY
128057: LIST
128058: LIST
128059: IN
128060: IFFALSE 128098
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
128062: LD_VAR 0 4
128066: PUSH
128067: LD_VAR 0 7
128071: ARRAY
128072: PPUSH
128073: LD_VAR 0 14
128077: PUSH
128078: LD_VAR 0 8
128082: ARRAY
128083: PPUSH
128084: CALL_OW 115
// attacking := true ;
128088: LD_ADDR_VAR 0 29
128092: PUSH
128093: LD_INT 1
128095: ST_TO_ADDR
// break ;
128096: GO 128100
// end ;
128098: GO 128037
128100: POP
128101: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
128102: LD_VAR 0 4
128106: PUSH
128107: LD_VAR 0 7
128111: ARRAY
128112: PPUSH
128113: CALL_OW 302
128117: PUSH
128118: LD_VAR 0 29
128122: NOT
128123: AND
128124: IFFALSE 128446
// begin if GetTag ( group [ i ] ) = 71 then
128126: LD_VAR 0 4
128130: PUSH
128131: LD_VAR 0 7
128135: ARRAY
128136: PPUSH
128137: CALL_OW 110
128141: PUSH
128142: LD_INT 71
128144: EQUAL
128145: IFFALSE 128186
// begin if HasTask ( group [ i ] ) then
128147: LD_VAR 0 4
128151: PUSH
128152: LD_VAR 0 7
128156: ARRAY
128157: PPUSH
128158: CALL_OW 314
128162: IFFALSE 128168
// continue else
128164: GO 124325
128166: GO 128186
// SetTag ( group [ i ] , 0 ) ;
128168: LD_VAR 0 4
128172: PUSH
128173: LD_VAR 0 7
128177: ARRAY
128178: PPUSH
128179: LD_INT 0
128181: PPUSH
128182: CALL_OW 109
// end ; k := 8 ;
128186: LD_ADDR_VAR 0 9
128190: PUSH
128191: LD_INT 8
128193: ST_TO_ADDR
// x := 0 ;
128194: LD_ADDR_VAR 0 10
128198: PUSH
128199: LD_INT 0
128201: ST_TO_ADDR
// if tmp < k then
128202: LD_VAR 0 14
128206: PUSH
128207: LD_VAR 0 9
128211: LESS
128212: IFFALSE 128224
// k := tmp ;
128214: LD_ADDR_VAR 0 9
128218: PUSH
128219: LD_VAR 0 14
128223: ST_TO_ADDR
// for j = 1 to k do
128224: LD_ADDR_VAR 0 8
128228: PUSH
128229: DOUBLE
128230: LD_INT 1
128232: DEC
128233: ST_TO_ADDR
128234: LD_VAR 0 9
128238: PUSH
128239: FOR_TO
128240: IFFALSE 128338
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
128242: LD_VAR 0 14
128246: PUSH
128247: LD_VAR 0 8
128251: ARRAY
128252: PPUSH
128253: CALL_OW 247
128257: PUSH
128258: LD_INT 1
128260: EQUAL
128261: PUSH
128262: LD_VAR 0 14
128266: PUSH
128267: LD_VAR 0 8
128271: ARRAY
128272: PPUSH
128273: CALL_OW 256
128277: PUSH
128278: LD_INT 250
128280: LESS
128281: PUSH
128282: LD_VAR 0 20
128286: AND
128287: PUSH
128288: LD_VAR 0 20
128292: NOT
128293: PUSH
128294: LD_VAR 0 14
128298: PUSH
128299: LD_VAR 0 8
128303: ARRAY
128304: PPUSH
128305: CALL_OW 256
128309: PUSH
128310: LD_INT 250
128312: GREATEREQUAL
128313: AND
128314: OR
128315: AND
128316: IFFALSE 128336
// begin x := tmp [ j ] ;
128318: LD_ADDR_VAR 0 10
128322: PUSH
128323: LD_VAR 0 14
128327: PUSH
128328: LD_VAR 0 8
128332: ARRAY
128333: ST_TO_ADDR
// break ;
128334: GO 128338
// end ;
128336: GO 128239
128338: POP
128339: POP
// if x then
128340: LD_VAR 0 10
128344: IFFALSE 128368
// ComAttackUnit ( group [ i ] , x ) else
128346: LD_VAR 0 4
128350: PUSH
128351: LD_VAR 0 7
128355: ARRAY
128356: PPUSH
128357: LD_VAR 0 10
128361: PPUSH
128362: CALL_OW 115
128366: GO 128392
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
128368: LD_VAR 0 4
128372: PUSH
128373: LD_VAR 0 7
128377: ARRAY
128378: PPUSH
128379: LD_VAR 0 14
128383: PUSH
128384: LD_INT 1
128386: ARRAY
128387: PPUSH
128388: CALL_OW 115
// if not HasTask ( group [ i ] ) then
128392: LD_VAR 0 4
128396: PUSH
128397: LD_VAR 0 7
128401: ARRAY
128402: PPUSH
128403: CALL_OW 314
128407: NOT
128408: IFFALSE 128446
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
128410: LD_VAR 0 4
128414: PUSH
128415: LD_VAR 0 7
128419: ARRAY
128420: PPUSH
128421: LD_VAR 0 14
128425: PPUSH
128426: LD_VAR 0 4
128430: PUSH
128431: LD_VAR 0 7
128435: ARRAY
128436: PPUSH
128437: CALL_OW 74
128441: PPUSH
128442: CALL_OW 115
// end ; end ; end ;
128446: GO 124325
128448: POP
128449: POP
// wait ( 0 0$2 ) ;
128450: LD_INT 70
128452: PPUSH
128453: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
128457: LD_VAR 0 4
128461: NOT
128462: PUSH
128463: LD_VAR 0 4
128467: PUSH
128468: EMPTY
128469: EQUAL
128470: OR
128471: PUSH
128472: LD_INT 81
128474: PUSH
128475: LD_VAR 0 35
128479: PUSH
128480: EMPTY
128481: LIST
128482: LIST
128483: PPUSH
128484: CALL_OW 69
128488: NOT
128489: OR
128490: IFFALSE 124310
// end ;
128492: LD_VAR 0 2
128496: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
128497: LD_INT 0
128499: PPUSH
128500: PPUSH
128501: PPUSH
128502: PPUSH
128503: PPUSH
128504: PPUSH
// if not base or not mc_bases [ base ] or not solds then
128505: LD_VAR 0 1
128509: NOT
128510: PUSH
128511: LD_EXP 116
128515: PUSH
128516: LD_VAR 0 1
128520: ARRAY
128521: NOT
128522: OR
128523: PUSH
128524: LD_VAR 0 2
128528: NOT
128529: OR
128530: IFFALSE 128534
// exit ;
128532: GO 129088
// side := mc_sides [ base ] ;
128534: LD_ADDR_VAR 0 6
128538: PUSH
128539: LD_EXP 142
128543: PUSH
128544: LD_VAR 0 1
128548: ARRAY
128549: ST_TO_ADDR
// if not side then
128550: LD_VAR 0 6
128554: NOT
128555: IFFALSE 128559
// exit ;
128557: GO 129088
// for i in solds do
128559: LD_ADDR_VAR 0 7
128563: PUSH
128564: LD_VAR 0 2
128568: PUSH
128569: FOR_IN
128570: IFFALSE 128631
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
128572: LD_VAR 0 7
128576: PPUSH
128577: CALL_OW 310
128581: PPUSH
128582: CALL_OW 266
128586: PUSH
128587: LD_INT 32
128589: PUSH
128590: LD_INT 31
128592: PUSH
128593: EMPTY
128594: LIST
128595: LIST
128596: IN
128597: IFFALSE 128617
// solds := solds diff i else
128599: LD_ADDR_VAR 0 2
128603: PUSH
128604: LD_VAR 0 2
128608: PUSH
128609: LD_VAR 0 7
128613: DIFF
128614: ST_TO_ADDR
128615: GO 128629
// SetTag ( i , 18 ) ;
128617: LD_VAR 0 7
128621: PPUSH
128622: LD_INT 18
128624: PPUSH
128625: CALL_OW 109
128629: GO 128569
128631: POP
128632: POP
// if not solds then
128633: LD_VAR 0 2
128637: NOT
128638: IFFALSE 128642
// exit ;
128640: GO 129088
// repeat wait ( 0 0$2 ) ;
128642: LD_INT 70
128644: PPUSH
128645: CALL_OW 67
// enemy := mc_scan [ base ] ;
128649: LD_ADDR_VAR 0 4
128653: PUSH
128654: LD_EXP 139
128658: PUSH
128659: LD_VAR 0 1
128663: ARRAY
128664: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
128665: LD_EXP 116
128669: PUSH
128670: LD_VAR 0 1
128674: ARRAY
128675: NOT
128676: PUSH
128677: LD_EXP 116
128681: PUSH
128682: LD_VAR 0 1
128686: ARRAY
128687: PUSH
128688: EMPTY
128689: EQUAL
128690: OR
128691: IFFALSE 128728
// begin for i in solds do
128693: LD_ADDR_VAR 0 7
128697: PUSH
128698: LD_VAR 0 2
128702: PUSH
128703: FOR_IN
128704: IFFALSE 128717
// ComStop ( i ) ;
128706: LD_VAR 0 7
128710: PPUSH
128711: CALL_OW 141
128715: GO 128703
128717: POP
128718: POP
// solds := [ ] ;
128719: LD_ADDR_VAR 0 2
128723: PUSH
128724: EMPTY
128725: ST_TO_ADDR
// exit ;
128726: GO 129088
// end ; for i in solds do
128728: LD_ADDR_VAR 0 7
128732: PUSH
128733: LD_VAR 0 2
128737: PUSH
128738: FOR_IN
128739: IFFALSE 129060
// begin if IsInUnit ( i ) then
128741: LD_VAR 0 7
128745: PPUSH
128746: CALL_OW 310
128750: IFFALSE 128761
// ComExitBuilding ( i ) ;
128752: LD_VAR 0 7
128756: PPUSH
128757: CALL_OW 122
// if GetLives ( i ) > 500 then
128761: LD_VAR 0 7
128765: PPUSH
128766: CALL_OW 256
128770: PUSH
128771: LD_INT 500
128773: GREATER
128774: IFFALSE 128827
// begin e := NearestUnitToUnit ( enemy , i ) ;
128776: LD_ADDR_VAR 0 5
128780: PUSH
128781: LD_VAR 0 4
128785: PPUSH
128786: LD_VAR 0 7
128790: PPUSH
128791: CALL_OW 74
128795: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
128796: LD_VAR 0 7
128800: PPUSH
128801: LD_VAR 0 5
128805: PPUSH
128806: CALL_OW 250
128810: PPUSH
128811: LD_VAR 0 5
128815: PPUSH
128816: CALL_OW 251
128820: PPUSH
128821: CALL_OW 114
// end else
128825: GO 129058
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
128827: LD_VAR 0 7
128831: PPUSH
128832: LD_EXP 116
128836: PUSH
128837: LD_VAR 0 1
128841: ARRAY
128842: PPUSH
128843: LD_INT 2
128845: PUSH
128846: LD_INT 30
128848: PUSH
128849: LD_INT 0
128851: PUSH
128852: EMPTY
128853: LIST
128854: LIST
128855: PUSH
128856: LD_INT 30
128858: PUSH
128859: LD_INT 1
128861: PUSH
128862: EMPTY
128863: LIST
128864: LIST
128865: PUSH
128866: LD_INT 30
128868: PUSH
128869: LD_INT 6
128871: PUSH
128872: EMPTY
128873: LIST
128874: LIST
128875: PUSH
128876: EMPTY
128877: LIST
128878: LIST
128879: LIST
128880: LIST
128881: PPUSH
128882: CALL_OW 72
128886: PPUSH
128887: LD_VAR 0 7
128891: PPUSH
128892: CALL_OW 74
128896: PPUSH
128897: CALL_OW 296
128901: PUSH
128902: LD_INT 10
128904: GREATER
128905: IFFALSE 129058
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
128907: LD_ADDR_VAR 0 8
128911: PUSH
128912: LD_EXP 116
128916: PUSH
128917: LD_VAR 0 1
128921: ARRAY
128922: PPUSH
128923: LD_INT 2
128925: PUSH
128926: LD_INT 30
128928: PUSH
128929: LD_INT 0
128931: PUSH
128932: EMPTY
128933: LIST
128934: LIST
128935: PUSH
128936: LD_INT 30
128938: PUSH
128939: LD_INT 1
128941: PUSH
128942: EMPTY
128943: LIST
128944: LIST
128945: PUSH
128946: LD_INT 30
128948: PUSH
128949: LD_INT 6
128951: PUSH
128952: EMPTY
128953: LIST
128954: LIST
128955: PUSH
128956: EMPTY
128957: LIST
128958: LIST
128959: LIST
128960: LIST
128961: PPUSH
128962: CALL_OW 72
128966: PPUSH
128967: LD_VAR 0 7
128971: PPUSH
128972: CALL_OW 74
128976: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
128977: LD_VAR 0 7
128981: PPUSH
128982: LD_VAR 0 8
128986: PPUSH
128987: CALL_OW 250
128991: PPUSH
128992: LD_INT 3
128994: PPUSH
128995: LD_INT 5
128997: PPUSH
128998: CALL_OW 272
129002: PPUSH
129003: LD_VAR 0 8
129007: PPUSH
129008: CALL_OW 251
129012: PPUSH
129013: LD_INT 3
129015: PPUSH
129016: LD_INT 5
129018: PPUSH
129019: CALL_OW 273
129023: PPUSH
129024: CALL_OW 111
// SetTag ( i , 0 ) ;
129028: LD_VAR 0 7
129032: PPUSH
129033: LD_INT 0
129035: PPUSH
129036: CALL_OW 109
// solds := solds diff i ;
129040: LD_ADDR_VAR 0 2
129044: PUSH
129045: LD_VAR 0 2
129049: PUSH
129050: LD_VAR 0 7
129054: DIFF
129055: ST_TO_ADDR
// continue ;
129056: GO 128738
// end ; end ;
129058: GO 128738
129060: POP
129061: POP
// until not solds or not enemy ;
129062: LD_VAR 0 2
129066: NOT
129067: PUSH
129068: LD_VAR 0 4
129072: NOT
129073: OR
129074: IFFALSE 128642
// MC_Reset ( base , 18 ) ;
129076: LD_VAR 0 1
129080: PPUSH
129081: LD_INT 18
129083: PPUSH
129084: CALL 39413 0 2
// end ;
129088: LD_VAR 0 3
129092: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
129093: LD_INT 0
129095: PPUSH
129096: PPUSH
129097: PPUSH
129098: PPUSH
129099: PPUSH
129100: PPUSH
129101: PPUSH
129102: PPUSH
129103: PPUSH
129104: PPUSH
129105: PPUSH
129106: PPUSH
129107: PPUSH
129108: PPUSH
129109: PPUSH
129110: PPUSH
129111: PPUSH
129112: PPUSH
129113: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
129114: LD_ADDR_VAR 0 12
129118: PUSH
129119: LD_EXP 116
129123: PUSH
129124: LD_VAR 0 1
129128: ARRAY
129129: PPUSH
129130: LD_INT 25
129132: PUSH
129133: LD_INT 3
129135: PUSH
129136: EMPTY
129137: LIST
129138: LIST
129139: PPUSH
129140: CALL_OW 72
129144: ST_TO_ADDR
// if mc_remote_driver [ base ] then
129145: LD_EXP 156
129149: PUSH
129150: LD_VAR 0 1
129154: ARRAY
129155: IFFALSE 129179
// mechs := mechs diff mc_remote_driver [ base ] ;
129157: LD_ADDR_VAR 0 12
129161: PUSH
129162: LD_VAR 0 12
129166: PUSH
129167: LD_EXP 156
129171: PUSH
129172: LD_VAR 0 1
129176: ARRAY
129177: DIFF
129178: ST_TO_ADDR
// for i in mechs do
129179: LD_ADDR_VAR 0 4
129183: PUSH
129184: LD_VAR 0 12
129188: PUSH
129189: FOR_IN
129190: IFFALSE 129225
// if GetTag ( i ) > 0 then
129192: LD_VAR 0 4
129196: PPUSH
129197: CALL_OW 110
129201: PUSH
129202: LD_INT 0
129204: GREATER
129205: IFFALSE 129223
// mechs := mechs diff i ;
129207: LD_ADDR_VAR 0 12
129211: PUSH
129212: LD_VAR 0 12
129216: PUSH
129217: LD_VAR 0 4
129221: DIFF
129222: ST_TO_ADDR
129223: GO 129189
129225: POP
129226: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
129227: LD_ADDR_VAR 0 8
129231: PUSH
129232: LD_EXP 116
129236: PUSH
129237: LD_VAR 0 1
129241: ARRAY
129242: PPUSH
129243: LD_INT 2
129245: PUSH
129246: LD_INT 25
129248: PUSH
129249: LD_INT 1
129251: PUSH
129252: EMPTY
129253: LIST
129254: LIST
129255: PUSH
129256: LD_INT 25
129258: PUSH
129259: LD_INT 5
129261: PUSH
129262: EMPTY
129263: LIST
129264: LIST
129265: PUSH
129266: LD_INT 25
129268: PUSH
129269: LD_INT 8
129271: PUSH
129272: EMPTY
129273: LIST
129274: LIST
129275: PUSH
129276: LD_INT 25
129278: PUSH
129279: LD_INT 9
129281: PUSH
129282: EMPTY
129283: LIST
129284: LIST
129285: PUSH
129286: EMPTY
129287: LIST
129288: LIST
129289: LIST
129290: LIST
129291: LIST
129292: PPUSH
129293: CALL_OW 72
129297: ST_TO_ADDR
// if not defenders and not solds then
129298: LD_VAR 0 2
129302: NOT
129303: PUSH
129304: LD_VAR 0 8
129308: NOT
129309: AND
129310: IFFALSE 129314
// exit ;
129312: GO 131084
// depot_under_attack := false ;
129314: LD_ADDR_VAR 0 16
129318: PUSH
129319: LD_INT 0
129321: ST_TO_ADDR
// sold_defenders := [ ] ;
129322: LD_ADDR_VAR 0 17
129326: PUSH
129327: EMPTY
129328: ST_TO_ADDR
// if mechs then
129329: LD_VAR 0 12
129333: IFFALSE 129486
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
129335: LD_ADDR_VAR 0 4
129339: PUSH
129340: LD_VAR 0 2
129344: PPUSH
129345: LD_INT 21
129347: PUSH
129348: LD_INT 2
129350: PUSH
129351: EMPTY
129352: LIST
129353: LIST
129354: PPUSH
129355: CALL_OW 72
129359: PUSH
129360: FOR_IN
129361: IFFALSE 129484
// begin if GetTag ( i ) <> 20 then
129363: LD_VAR 0 4
129367: PPUSH
129368: CALL_OW 110
129372: PUSH
129373: LD_INT 20
129375: NONEQUAL
129376: IFFALSE 129390
// SetTag ( i , 20 ) ;
129378: LD_VAR 0 4
129382: PPUSH
129383: LD_INT 20
129385: PPUSH
129386: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
129390: LD_VAR 0 4
129394: PPUSH
129395: CALL_OW 263
129399: PUSH
129400: LD_INT 1
129402: EQUAL
129403: PUSH
129404: LD_VAR 0 4
129408: PPUSH
129409: CALL_OW 311
129413: NOT
129414: AND
129415: IFFALSE 129482
// begin un := mechs [ 1 ] ;
129417: LD_ADDR_VAR 0 10
129421: PUSH
129422: LD_VAR 0 12
129426: PUSH
129427: LD_INT 1
129429: ARRAY
129430: ST_TO_ADDR
// ComExit ( un ) ;
129431: LD_VAR 0 10
129435: PPUSH
129436: CALL 103010 0 1
// AddComEnterUnit ( un , i ) ;
129440: LD_VAR 0 10
129444: PPUSH
129445: LD_VAR 0 4
129449: PPUSH
129450: CALL_OW 180
// SetTag ( un , 19 ) ;
129454: LD_VAR 0 10
129458: PPUSH
129459: LD_INT 19
129461: PPUSH
129462: CALL_OW 109
// mechs := mechs diff un ;
129466: LD_ADDR_VAR 0 12
129470: PUSH
129471: LD_VAR 0 12
129475: PUSH
129476: LD_VAR 0 10
129480: DIFF
129481: ST_TO_ADDR
// end ; end ;
129482: GO 129360
129484: POP
129485: POP
// if solds then
129486: LD_VAR 0 8
129490: IFFALSE 129549
// for i in solds do
129492: LD_ADDR_VAR 0 4
129496: PUSH
129497: LD_VAR 0 8
129501: PUSH
129502: FOR_IN
129503: IFFALSE 129547
// if not GetTag ( i ) then
129505: LD_VAR 0 4
129509: PPUSH
129510: CALL_OW 110
129514: NOT
129515: IFFALSE 129545
// begin defenders := defenders union i ;
129517: LD_ADDR_VAR 0 2
129521: PUSH
129522: LD_VAR 0 2
129526: PUSH
129527: LD_VAR 0 4
129531: UNION
129532: ST_TO_ADDR
// SetTag ( i , 18 ) ;
129533: LD_VAR 0 4
129537: PPUSH
129538: LD_INT 18
129540: PPUSH
129541: CALL_OW 109
// end ;
129545: GO 129502
129547: POP
129548: POP
// repeat wait ( 0 0$2 ) ;
129549: LD_INT 70
129551: PPUSH
129552: CALL_OW 67
// enemy := mc_scan [ base ] ;
129556: LD_ADDR_VAR 0 21
129560: PUSH
129561: LD_EXP 139
129565: PUSH
129566: LD_VAR 0 1
129570: ARRAY
129571: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
129572: LD_EXP 116
129576: PUSH
129577: LD_VAR 0 1
129581: ARRAY
129582: NOT
129583: PUSH
129584: LD_EXP 116
129588: PUSH
129589: LD_VAR 0 1
129593: ARRAY
129594: PUSH
129595: EMPTY
129596: EQUAL
129597: OR
129598: IFFALSE 129635
// begin for i in defenders do
129600: LD_ADDR_VAR 0 4
129604: PUSH
129605: LD_VAR 0 2
129609: PUSH
129610: FOR_IN
129611: IFFALSE 129624
// ComStop ( i ) ;
129613: LD_VAR 0 4
129617: PPUSH
129618: CALL_OW 141
129622: GO 129610
129624: POP
129625: POP
// defenders := [ ] ;
129626: LD_ADDR_VAR 0 2
129630: PUSH
129631: EMPTY
129632: ST_TO_ADDR
// exit ;
129633: GO 131084
// end ; for i in defenders do
129635: LD_ADDR_VAR 0 4
129639: PUSH
129640: LD_VAR 0 2
129644: PUSH
129645: FOR_IN
129646: IFFALSE 130544
// begin e := NearestUnitToUnit ( enemy , i ) ;
129648: LD_ADDR_VAR 0 13
129652: PUSH
129653: LD_VAR 0 21
129657: PPUSH
129658: LD_VAR 0 4
129662: PPUSH
129663: CALL_OW 74
129667: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
129668: LD_ADDR_VAR 0 7
129672: PUSH
129673: LD_EXP 116
129677: PUSH
129678: LD_VAR 0 1
129682: ARRAY
129683: PPUSH
129684: LD_INT 2
129686: PUSH
129687: LD_INT 30
129689: PUSH
129690: LD_INT 0
129692: PUSH
129693: EMPTY
129694: LIST
129695: LIST
129696: PUSH
129697: LD_INT 30
129699: PUSH
129700: LD_INT 1
129702: PUSH
129703: EMPTY
129704: LIST
129705: LIST
129706: PUSH
129707: EMPTY
129708: LIST
129709: LIST
129710: LIST
129711: PPUSH
129712: CALL_OW 72
129716: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
129717: LD_ADDR_VAR 0 16
129721: PUSH
129722: LD_VAR 0 7
129726: NOT
129727: PUSH
129728: LD_VAR 0 7
129732: PPUSH
129733: LD_INT 3
129735: PUSH
129736: LD_INT 24
129738: PUSH
129739: LD_INT 600
129741: PUSH
129742: EMPTY
129743: LIST
129744: LIST
129745: PUSH
129746: EMPTY
129747: LIST
129748: LIST
129749: PPUSH
129750: CALL_OW 72
129754: OR
129755: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
129756: LD_VAR 0 4
129760: PPUSH
129761: CALL_OW 247
129765: PUSH
129766: LD_INT 2
129768: DOUBLE
129769: EQUAL
129770: IFTRUE 129774
129772: GO 130170
129774: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
129775: LD_VAR 0 4
129779: PPUSH
129780: CALL_OW 256
129784: PUSH
129785: LD_INT 1000
129787: EQUAL
129788: PUSH
129789: LD_VAR 0 4
129793: PPUSH
129794: LD_VAR 0 13
129798: PPUSH
129799: CALL_OW 296
129803: PUSH
129804: LD_INT 40
129806: LESS
129807: PUSH
129808: LD_VAR 0 13
129812: PPUSH
129813: LD_EXP 141
129817: PUSH
129818: LD_VAR 0 1
129822: ARRAY
129823: PPUSH
129824: CALL_OW 308
129828: OR
129829: AND
129830: IFFALSE 129952
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
129832: LD_VAR 0 4
129836: PPUSH
129837: CALL_OW 262
129841: PUSH
129842: LD_INT 1
129844: EQUAL
129845: PUSH
129846: LD_VAR 0 4
129850: PPUSH
129851: CALL_OW 261
129855: PUSH
129856: LD_INT 30
129858: LESS
129859: AND
129860: PUSH
129861: LD_VAR 0 7
129865: AND
129866: IFFALSE 129936
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
129868: LD_VAR 0 4
129872: PPUSH
129873: LD_VAR 0 7
129877: PPUSH
129878: LD_VAR 0 4
129882: PPUSH
129883: CALL_OW 74
129887: PPUSH
129888: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
129892: LD_VAR 0 4
129896: PPUSH
129897: LD_VAR 0 7
129901: PPUSH
129902: LD_VAR 0 4
129906: PPUSH
129907: CALL_OW 74
129911: PPUSH
129912: CALL_OW 296
129916: PUSH
129917: LD_INT 6
129919: LESS
129920: IFFALSE 129934
// SetFuel ( i , 100 ) ;
129922: LD_VAR 0 4
129926: PPUSH
129927: LD_INT 100
129929: PPUSH
129930: CALL_OW 240
// end else
129934: GO 129950
// ComAttackUnit ( i , e ) ;
129936: LD_VAR 0 4
129940: PPUSH
129941: LD_VAR 0 13
129945: PPUSH
129946: CALL_OW 115
// end else
129950: GO 130053
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
129952: LD_VAR 0 13
129956: PPUSH
129957: LD_EXP 141
129961: PUSH
129962: LD_VAR 0 1
129966: ARRAY
129967: PPUSH
129968: CALL_OW 308
129972: NOT
129973: PUSH
129974: LD_VAR 0 4
129978: PPUSH
129979: LD_VAR 0 13
129983: PPUSH
129984: CALL_OW 296
129988: PUSH
129989: LD_INT 40
129991: GREATEREQUAL
129992: AND
129993: PUSH
129994: LD_VAR 0 4
129998: PPUSH
129999: CALL_OW 256
130003: PUSH
130004: LD_INT 650
130006: LESSEQUAL
130007: OR
130008: PUSH
130009: LD_VAR 0 4
130013: PPUSH
130014: LD_EXP 140
130018: PUSH
130019: LD_VAR 0 1
130023: ARRAY
130024: PPUSH
130025: CALL_OW 308
130029: NOT
130030: AND
130031: IFFALSE 130053
// ComMoveToArea ( i , mc_parking [ base ] ) ;
130033: LD_VAR 0 4
130037: PPUSH
130038: LD_EXP 140
130042: PUSH
130043: LD_VAR 0 1
130047: ARRAY
130048: PPUSH
130049: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
130053: LD_VAR 0 4
130057: PPUSH
130058: CALL_OW 256
130062: PUSH
130063: LD_INT 1000
130065: LESS
130066: PUSH
130067: LD_VAR 0 4
130071: PPUSH
130072: CALL_OW 263
130076: PUSH
130077: LD_INT 1
130079: EQUAL
130080: AND
130081: PUSH
130082: LD_VAR 0 4
130086: PPUSH
130087: CALL_OW 311
130091: AND
130092: PUSH
130093: LD_VAR 0 4
130097: PPUSH
130098: LD_EXP 140
130102: PUSH
130103: LD_VAR 0 1
130107: ARRAY
130108: PPUSH
130109: CALL_OW 308
130113: AND
130114: IFFALSE 130168
// begin mech := IsDrivenBy ( i ) ;
130116: LD_ADDR_VAR 0 9
130120: PUSH
130121: LD_VAR 0 4
130125: PPUSH
130126: CALL_OW 311
130130: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
130131: LD_VAR 0 9
130135: PPUSH
130136: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
130140: LD_VAR 0 9
130144: PPUSH
130145: LD_VAR 0 4
130149: PPUSH
130150: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
130154: LD_VAR 0 9
130158: PPUSH
130159: LD_VAR 0 4
130163: PPUSH
130164: CALL_OW 180
// end ; end ; unit_human :
130168: GO 130515
130170: LD_INT 1
130172: DOUBLE
130173: EQUAL
130174: IFTRUE 130178
130176: GO 130514
130178: POP
// begin b := IsInUnit ( i ) ;
130179: LD_ADDR_VAR 0 18
130183: PUSH
130184: LD_VAR 0 4
130188: PPUSH
130189: CALL_OW 310
130193: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
130194: LD_ADDR_VAR 0 19
130198: PUSH
130199: LD_VAR 0 18
130203: NOT
130204: PUSH
130205: LD_VAR 0 18
130209: PPUSH
130210: CALL_OW 266
130214: PUSH
130215: LD_INT 32
130217: PUSH
130218: LD_INT 31
130220: PUSH
130221: EMPTY
130222: LIST
130223: LIST
130224: IN
130225: OR
130226: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
130227: LD_VAR 0 18
130231: PPUSH
130232: CALL_OW 266
130236: PUSH
130237: LD_INT 5
130239: EQUAL
130240: PUSH
130241: LD_VAR 0 4
130245: PPUSH
130246: CALL_OW 257
130250: PUSH
130251: LD_INT 1
130253: PUSH
130254: LD_INT 2
130256: PUSH
130257: LD_INT 3
130259: PUSH
130260: LD_INT 4
130262: PUSH
130263: EMPTY
130264: LIST
130265: LIST
130266: LIST
130267: LIST
130268: IN
130269: AND
130270: IFFALSE 130307
// begin class := AllowSpecClass ( i ) ;
130272: LD_ADDR_VAR 0 20
130276: PUSH
130277: LD_VAR 0 4
130281: PPUSH
130282: CALL 67671 0 1
130286: ST_TO_ADDR
// if class then
130287: LD_VAR 0 20
130291: IFFALSE 130307
// ComChangeProfession ( i , class ) ;
130293: LD_VAR 0 4
130297: PPUSH
130298: LD_VAR 0 20
130302: PPUSH
130303: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
130307: LD_VAR 0 16
130311: PUSH
130312: LD_VAR 0 2
130316: PPUSH
130317: LD_INT 21
130319: PUSH
130320: LD_INT 2
130322: PUSH
130323: EMPTY
130324: LIST
130325: LIST
130326: PPUSH
130327: CALL_OW 72
130331: PUSH
130332: LD_INT 1
130334: LESSEQUAL
130335: OR
130336: PUSH
130337: LD_VAR 0 19
130341: AND
130342: PUSH
130343: LD_VAR 0 4
130347: PUSH
130348: LD_VAR 0 17
130352: IN
130353: NOT
130354: AND
130355: IFFALSE 130448
// begin if b then
130357: LD_VAR 0 18
130361: IFFALSE 130410
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
130363: LD_VAR 0 18
130367: PPUSH
130368: LD_VAR 0 21
130372: PPUSH
130373: LD_VAR 0 18
130377: PPUSH
130378: CALL_OW 74
130382: PPUSH
130383: CALL_OW 296
130387: PUSH
130388: LD_INT 10
130390: LESS
130391: PUSH
130392: LD_VAR 0 18
130396: PPUSH
130397: CALL_OW 461
130401: PUSH
130402: LD_INT 7
130404: NONEQUAL
130405: AND
130406: IFFALSE 130410
// continue ;
130408: GO 129645
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
130410: LD_ADDR_VAR 0 17
130414: PUSH
130415: LD_VAR 0 17
130419: PPUSH
130420: LD_VAR 0 17
130424: PUSH
130425: LD_INT 1
130427: PLUS
130428: PPUSH
130429: LD_VAR 0 4
130433: PPUSH
130434: CALL_OW 1
130438: ST_TO_ADDR
// ComExitBuilding ( i ) ;
130439: LD_VAR 0 4
130443: PPUSH
130444: CALL_OW 122
// end ; if sold_defenders then
130448: LD_VAR 0 17
130452: IFFALSE 130512
// if i in sold_defenders then
130454: LD_VAR 0 4
130458: PUSH
130459: LD_VAR 0 17
130463: IN
130464: IFFALSE 130512
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
130466: LD_VAR 0 4
130470: PPUSH
130471: CALL_OW 314
130475: NOT
130476: PUSH
130477: LD_VAR 0 4
130481: PPUSH
130482: LD_VAR 0 13
130486: PPUSH
130487: CALL_OW 296
130491: PUSH
130492: LD_INT 30
130494: LESS
130495: AND
130496: IFFALSE 130512
// ComAttackUnit ( i , e ) ;
130498: LD_VAR 0 4
130502: PPUSH
130503: LD_VAR 0 13
130507: PPUSH
130508: CALL_OW 115
// end ; end ; end ;
130512: GO 130515
130514: POP
// if IsDead ( i ) then
130515: LD_VAR 0 4
130519: PPUSH
130520: CALL_OW 301
130524: IFFALSE 130542
// defenders := defenders diff i ;
130526: LD_ADDR_VAR 0 2
130530: PUSH
130531: LD_VAR 0 2
130535: PUSH
130536: LD_VAR 0 4
130540: DIFF
130541: ST_TO_ADDR
// end ;
130542: GO 129645
130544: POP
130545: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
130546: LD_VAR 0 21
130550: NOT
130551: PUSH
130552: LD_VAR 0 2
130556: NOT
130557: OR
130558: PUSH
130559: LD_EXP 116
130563: PUSH
130564: LD_VAR 0 1
130568: ARRAY
130569: NOT
130570: OR
130571: IFFALSE 129549
// MC_Reset ( base , 18 ) ;
130573: LD_VAR 0 1
130577: PPUSH
130578: LD_INT 18
130580: PPUSH
130581: CALL 39413 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
130585: LD_ADDR_VAR 0 2
130589: PUSH
130590: LD_VAR 0 2
130594: PUSH
130595: LD_VAR 0 2
130599: PPUSH
130600: LD_INT 2
130602: PUSH
130603: LD_INT 25
130605: PUSH
130606: LD_INT 1
130608: PUSH
130609: EMPTY
130610: LIST
130611: LIST
130612: PUSH
130613: LD_INT 25
130615: PUSH
130616: LD_INT 5
130618: PUSH
130619: EMPTY
130620: LIST
130621: LIST
130622: PUSH
130623: LD_INT 25
130625: PUSH
130626: LD_INT 8
130628: PUSH
130629: EMPTY
130630: LIST
130631: LIST
130632: PUSH
130633: LD_INT 25
130635: PUSH
130636: LD_INT 9
130638: PUSH
130639: EMPTY
130640: LIST
130641: LIST
130642: PUSH
130643: EMPTY
130644: LIST
130645: LIST
130646: LIST
130647: LIST
130648: LIST
130649: PPUSH
130650: CALL_OW 72
130654: DIFF
130655: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
130656: LD_VAR 0 21
130660: NOT
130661: PUSH
130662: LD_VAR 0 2
130666: PPUSH
130667: LD_INT 21
130669: PUSH
130670: LD_INT 2
130672: PUSH
130673: EMPTY
130674: LIST
130675: LIST
130676: PPUSH
130677: CALL_OW 72
130681: AND
130682: IFFALSE 131020
// begin tmp := FilterByTag ( defenders , 19 ) ;
130684: LD_ADDR_VAR 0 11
130688: PUSH
130689: LD_VAR 0 2
130693: PPUSH
130694: LD_INT 19
130696: PPUSH
130697: CALL 100140 0 2
130701: ST_TO_ADDR
// if tmp then
130702: LD_VAR 0 11
130706: IFFALSE 130776
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
130708: LD_ADDR_VAR 0 11
130712: PUSH
130713: LD_VAR 0 11
130717: PPUSH
130718: LD_INT 25
130720: PUSH
130721: LD_INT 3
130723: PUSH
130724: EMPTY
130725: LIST
130726: LIST
130727: PPUSH
130728: CALL_OW 72
130732: ST_TO_ADDR
// if tmp then
130733: LD_VAR 0 11
130737: IFFALSE 130776
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
130739: LD_ADDR_EXP 128
130743: PUSH
130744: LD_EXP 128
130748: PPUSH
130749: LD_VAR 0 1
130753: PPUSH
130754: LD_EXP 128
130758: PUSH
130759: LD_VAR 0 1
130763: ARRAY
130764: PUSH
130765: LD_VAR 0 11
130769: UNION
130770: PPUSH
130771: CALL_OW 1
130775: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
130776: LD_VAR 0 1
130780: PPUSH
130781: LD_INT 19
130783: PPUSH
130784: CALL 39413 0 2
// repeat wait ( 0 0$1 ) ;
130788: LD_INT 35
130790: PPUSH
130791: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
130795: LD_EXP 116
130799: PUSH
130800: LD_VAR 0 1
130804: ARRAY
130805: NOT
130806: PUSH
130807: LD_EXP 116
130811: PUSH
130812: LD_VAR 0 1
130816: ARRAY
130817: PUSH
130818: EMPTY
130819: EQUAL
130820: OR
130821: IFFALSE 130858
// begin for i in defenders do
130823: LD_ADDR_VAR 0 4
130827: PUSH
130828: LD_VAR 0 2
130832: PUSH
130833: FOR_IN
130834: IFFALSE 130847
// ComStop ( i ) ;
130836: LD_VAR 0 4
130840: PPUSH
130841: CALL_OW 141
130845: GO 130833
130847: POP
130848: POP
// defenders := [ ] ;
130849: LD_ADDR_VAR 0 2
130853: PUSH
130854: EMPTY
130855: ST_TO_ADDR
// exit ;
130856: GO 131084
// end ; for i in defenders do
130858: LD_ADDR_VAR 0 4
130862: PUSH
130863: LD_VAR 0 2
130867: PUSH
130868: FOR_IN
130869: IFFALSE 130958
// begin if not IsInArea ( i , mc_parking [ base ] ) then
130871: LD_VAR 0 4
130875: PPUSH
130876: LD_EXP 140
130880: PUSH
130881: LD_VAR 0 1
130885: ARRAY
130886: PPUSH
130887: CALL_OW 308
130891: NOT
130892: IFFALSE 130916
// ComMoveToArea ( i , mc_parking [ base ] ) else
130894: LD_VAR 0 4
130898: PPUSH
130899: LD_EXP 140
130903: PUSH
130904: LD_VAR 0 1
130908: ARRAY
130909: PPUSH
130910: CALL_OW 113
130914: GO 130956
// if GetControl ( i ) = control_manual then
130916: LD_VAR 0 4
130920: PPUSH
130921: CALL_OW 263
130925: PUSH
130926: LD_INT 1
130928: EQUAL
130929: IFFALSE 130956
// if IsDrivenBy ( i ) then
130931: LD_VAR 0 4
130935: PPUSH
130936: CALL_OW 311
130940: IFFALSE 130956
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
130942: LD_VAR 0 4
130946: PPUSH
130947: CALL_OW 311
130951: PPUSH
130952: CALL_OW 121
// end ;
130956: GO 130868
130958: POP
130959: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
130960: LD_VAR 0 2
130964: PPUSH
130965: LD_INT 95
130967: PUSH
130968: LD_EXP 140
130972: PUSH
130973: LD_VAR 0 1
130977: ARRAY
130978: PUSH
130979: EMPTY
130980: LIST
130981: LIST
130982: PPUSH
130983: CALL_OW 72
130987: PUSH
130988: LD_VAR 0 2
130992: EQUAL
130993: PUSH
130994: LD_EXP 139
130998: PUSH
130999: LD_VAR 0 1
131003: ARRAY
131004: OR
131005: PUSH
131006: LD_EXP 116
131010: PUSH
131011: LD_VAR 0 1
131015: ARRAY
131016: NOT
131017: OR
131018: IFFALSE 130788
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
131020: LD_ADDR_EXP 138
131024: PUSH
131025: LD_EXP 138
131029: PPUSH
131030: LD_VAR 0 1
131034: PPUSH
131035: LD_VAR 0 2
131039: PPUSH
131040: LD_INT 21
131042: PUSH
131043: LD_INT 2
131045: PUSH
131046: EMPTY
131047: LIST
131048: LIST
131049: PPUSH
131050: CALL_OW 72
131054: PPUSH
131055: CALL_OW 1
131059: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
131060: LD_VAR 0 1
131064: PPUSH
131065: LD_INT 19
131067: PPUSH
131068: CALL 39413 0 2
// MC_Reset ( base , 20 ) ;
131072: LD_VAR 0 1
131076: PPUSH
131077: LD_INT 20
131079: PPUSH
131080: CALL 39413 0 2
// end ; end_of_file
131084: LD_VAR 0 3
131088: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
131089: LD_VAR 0 1
131093: PUSH
131094: LD_INT 200
131096: DOUBLE
131097: GREATEREQUAL
131098: IFFALSE 131106
131100: LD_INT 299
131102: DOUBLE
131103: LESSEQUAL
131104: IFTRUE 131108
131106: GO 131140
131108: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
131109: LD_VAR 0 1
131113: PPUSH
131114: LD_VAR 0 2
131118: PPUSH
131119: LD_VAR 0 3
131123: PPUSH
131124: LD_VAR 0 4
131128: PPUSH
131129: LD_VAR 0 5
131133: PPUSH
131134: CALL 119905 0 5
131138: GO 131217
131140: LD_INT 300
131142: DOUBLE
131143: GREATEREQUAL
131144: IFFALSE 131152
131146: LD_INT 399
131148: DOUBLE
131149: LESSEQUAL
131150: IFTRUE 131154
131152: GO 131216
131154: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
131155: LD_VAR 0 1
131159: PPUSH
131160: LD_VAR 0 2
131164: PPUSH
131165: LD_VAR 0 3
131169: PPUSH
131170: LD_VAR 0 4
131174: PPUSH
131175: LD_VAR 0 5
131179: PPUSH
131180: LD_VAR 0 6
131184: PPUSH
131185: LD_VAR 0 7
131189: PPUSH
131190: LD_VAR 0 8
131194: PPUSH
131195: LD_VAR 0 9
131199: PPUSH
131200: LD_VAR 0 10
131204: PPUSH
131205: LD_VAR 0 11
131209: PPUSH
131210: CALL 117803 0 11
131214: GO 131217
131216: POP
// end ;
131217: PPOPN 11
131219: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
131220: LD_VAR 0 1
131224: PPUSH
131225: LD_VAR 0 2
131229: PPUSH
131230: LD_VAR 0 3
131234: PPUSH
131235: LD_VAR 0 4
131239: PPUSH
131240: LD_VAR 0 5
131244: PPUSH
131245: CALL 119897 0 5
// end ; end_of_file
131249: PPOPN 5
131251: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
131252: LD_VAR 0 1
131256: PPUSH
131257: LD_VAR 0 2
131261: PPUSH
131262: LD_VAR 0 3
131266: PPUSH
131267: LD_VAR 0 4
131271: PPUSH
131272: LD_VAR 0 5
131276: PPUSH
131277: LD_VAR 0 6
131281: PPUSH
131282: CALL 105998 0 6
// end ;
131286: PPOPN 6
131288: END
