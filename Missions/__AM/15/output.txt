// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// InitVariables ;
  11: CALL 65 0 0
// InitMacro ;
  15: CALL 33918 0 0
// InitNature ;
  19: CALL 33742 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// PrepareAlliance ;
  36: CALL 10891 0 0
// PrepareRussian ;
  40: CALL 6874 0 0
// PrepareLegion ;
  44: CALL 4114 0 0
// PreparePowell ;
  48: CALL 2868 0 0
// PrepareAmerican ;
  52: CALL 1640 0 0
// Action ;
  56: CALL 14798 0 0
// MC_Start ( ) ;
  60: CALL 36030 0 0
// end ;
  64: END
// export debug ; export KappaStatus , KurtStatus , JMMVeh , JMMGirlVeh , JMMGirlStatus , JMMGirl , KhatamStatus , BurlakStatus , StevensStatus , FastEnd , FakeInfo ; export missionStart , missionTime , missionStage , activeAttacks , powellAnger , powellSquadAttack , powellAllowRetreat , powellCenterCameraMode , russianDestroyed , legionDestroyed , allianceDestroyed , vsevolodFirstAttack , allowBehemothConstruct , behemothUnderConstruct , behemothDestroyedBeforeFinish , behemothDone , seeBehemoth , platonovHasBomb , allianceActive , lostCounter , rothCaptured , capturedUnit , trueAmericans ; export function InitVariables ; begin
  65: LD_INT 0
  67: PPUSH
// debug := 0 ;
  68: LD_ADDR_EXP 1
  72: PUSH
  73: LD_INT 0
  75: ST_TO_ADDR
// missionStart := false ;
  76: LD_ADDR_EXP 13
  80: PUSH
  81: LD_INT 0
  83: ST_TO_ADDR
// missionTime := 0 0$00 ;
  84: LD_ADDR_EXP 14
  88: PUSH
  89: LD_INT 0
  91: ST_TO_ADDR
// missionStage := 1 ;
  92: LD_ADDR_EXP 15
  96: PUSH
  97: LD_INT 1
  99: ST_TO_ADDR
// activeAttacks := false ;
 100: LD_ADDR_EXP 16
 104: PUSH
 105: LD_INT 0
 107: ST_TO_ADDR
// powellAnger := 0 ;
 108: LD_ADDR_EXP 17
 112: PUSH
 113: LD_INT 0
 115: ST_TO_ADDR
// powellAllowRetreat := true ;
 116: LD_ADDR_EXP 19
 120: PUSH
 121: LD_INT 1
 123: ST_TO_ADDR
// powellCenterCameraMode := false ;
 124: LD_ADDR_EXP 20
 128: PUSH
 129: LD_INT 0
 131: ST_TO_ADDR
// powellSquadAttack := [ [ ] , [ ] ] ;
 132: LD_ADDR_EXP 18
 136: PUSH
 137: EMPTY
 138: PUSH
 139: EMPTY
 140: PUSH
 141: EMPTY
 142: LIST
 143: LIST
 144: ST_TO_ADDR
// russianDestroyed := false ;
 145: LD_ADDR_EXP 21
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// legionDestroyed := false ;
 153: LD_ADDR_EXP 22
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// allianceDestroyed := false ;
 161: LD_ADDR_EXP 23
 165: PUSH
 166: LD_INT 0
 168: ST_TO_ADDR
// KappaStatus := LoadVariable ( 14_KappaStatus_1 , 0 ) ;
 169: LD_ADDR_EXP 2
 173: PUSH
 174: LD_STRING 14_KappaStatus_1
 176: PPUSH
 177: LD_INT 0
 179: PPUSH
 180: CALL_OW 30
 184: ST_TO_ADDR
// KurtStatus := LoadVariable ( 06_KurtStatus_1 , 0 ) ;
 185: LD_ADDR_EXP 3
 189: PUSH
 190: LD_STRING 06_KurtStatus_1
 192: PPUSH
 193: LD_INT 0
 195: PPUSH
 196: CALL_OW 30
 200: ST_TO_ADDR
// JMMVeh = LoadVariable ( 14_JMMVeh_1 , 0 ) ;
 201: LD_ADDR_EXP 4
 205: PUSH
 206: LD_STRING 14_JMMVeh_1
 208: PPUSH
 209: LD_INT 0
 211: PPUSH
 212: CALL_OW 30
 216: ST_TO_ADDR
// JMMGirlVeh = LoadVariable ( 14_JMMGirlVeh_1 , 0 ) ;
 217: LD_ADDR_EXP 5
 221: PUSH
 222: LD_STRING 14_JMMGirlVeh_1
 224: PPUSH
 225: LD_INT 0
 227: PPUSH
 228: CALL_OW 30
 232: ST_TO_ADDR
// JMMGirl = LoadVariable ( 14_JMMGirl_1 , 0 ) ;
 233: LD_ADDR_EXP 7
 237: PUSH
 238: LD_STRING 14_JMMGirl_1
 240: PPUSH
 241: LD_INT 0
 243: PPUSH
 244: CALL_OW 30
 248: ST_TO_ADDR
// JMMGirlStatus = LoadVariable ( 14_JMMGirlStatus_1 , 0 ) ;
 249: LD_ADDR_EXP 6
 253: PUSH
 254: LD_STRING 14_JMMGirlStatus_1
 256: PPUSH
 257: LD_INT 0
 259: PPUSH
 260: CALL_OW 30
 264: ST_TO_ADDR
// KhatamStatus = LoadVariable ( 10_KhatamStatus_1 , 0 ) ;
 265: LD_ADDR_EXP 8
 269: PUSH
 270: LD_STRING 10_KhatamStatus_1
 272: PPUSH
 273: LD_INT 0
 275: PPUSH
 276: CALL_OW 30
 280: ST_TO_ADDR
// BurlakStatus = LoadVariable ( 13_BurlakStatus_1 , 0 ) ;
 281: LD_ADDR_EXP 9
 285: PUSH
 286: LD_STRING 13_BurlakStatus_1
 288: PPUSH
 289: LD_INT 0
 291: PPUSH
 292: CALL_OW 30
 296: ST_TO_ADDR
// StevensStatus = LoadVariable ( 13_StevensStatus_1 , 0 ) ;
 297: LD_ADDR_EXP 10
 301: PUSH
 302: LD_STRING 13_StevensStatus_1
 304: PPUSH
 305: LD_INT 0
 307: PPUSH
 308: CALL_OW 30
 312: ST_TO_ADDR
// FastEnd := LoadVariable ( 14_FastEnd_1 , 0 ) ;
 313: LD_ADDR_EXP 11
 317: PUSH
 318: LD_STRING 14_FastEnd_1
 320: PPUSH
 321: LD_INT 0
 323: PPUSH
 324: CALL_OW 30
 328: ST_TO_ADDR
// FakeInfo := LoadVariable ( 12_MainDepositFake_1 , 0 ) ;
 329: LD_ADDR_EXP 12
 333: PUSH
 334: LD_STRING 12_MainDepositFake_1
 336: PPUSH
 337: LD_INT 0
 339: PPUSH
 340: CALL_OW 30
 344: ST_TO_ADDR
// vsevolodFirstAttack := true ;
 345: LD_ADDR_EXP 24
 349: PUSH
 350: LD_INT 1
 352: ST_TO_ADDR
// behemothUnderConstruct := false ;
 353: LD_ADDR_EXP 26
 357: PUSH
 358: LD_INT 0
 360: ST_TO_ADDR
// behemothDestroyedBeforeFinish := false ;
 361: LD_ADDR_EXP 27
 365: PUSH
 366: LD_INT 0
 368: ST_TO_ADDR
// behemothDone := false ;
 369: LD_ADDR_EXP 28
 373: PUSH
 374: LD_INT 0
 376: ST_TO_ADDR
// allowBehemothConstruct := false ;
 377: LD_ADDR_EXP 25
 381: PUSH
 382: LD_INT 0
 384: ST_TO_ADDR
// seeBehemoth := false ;
 385: LD_ADDR_EXP 29
 389: PUSH
 390: LD_INT 0
 392: ST_TO_ADDR
// platonovHasBomb := false ;
 393: LD_ADDR_EXP 30
 397: PUSH
 398: LD_INT 0
 400: ST_TO_ADDR
// allianceActive := false ;
 401: LD_ADDR_EXP 31
 405: PUSH
 406: LD_INT 0
 408: ST_TO_ADDR
// rothCaptured := false ;
 409: LD_ADDR_EXP 33
 413: PUSH
 414: LD_INT 0
 416: ST_TO_ADDR
// lostCounter := 0 ;
 417: LD_ADDR_EXP 32
 421: PUSH
 422: LD_INT 0
 424: ST_TO_ADDR
// capturedUnit := [ ] ;
 425: LD_ADDR_EXP 34
 429: PUSH
 430: EMPTY
 431: ST_TO_ADDR
// trueAmericans := [ ] ;
 432: LD_ADDR_EXP 35
 436: PUSH
 437: EMPTY
 438: ST_TO_ADDR
// end ;
 439: LD_VAR 0 1
 443: RET
// export function CustomInitMacro ( ) ; begin
 444: LD_INT 0
 446: PPUSH
// mc_parking := [ allianceParkingArea , russianParkingArea , legionParkingArea , powellParking ] ;
 447: LD_ADDR_EXP 123
 451: PUSH
 452: LD_INT 2
 454: PUSH
 455: LD_INT 3
 457: PUSH
 458: LD_INT 6
 460: PUSH
 461: LD_INT 10
 463: PUSH
 464: EMPTY
 465: LIST
 466: LIST
 467: LIST
 468: LIST
 469: ST_TO_ADDR
// mc_scan_area := [ allianceBaseArea , russianBaseArea , legionBaseArea , powellBase ] ;
 470: LD_ADDR_EXP 124
 474: PUSH
 475: LD_INT 1
 477: PUSH
 478: LD_INT 4
 480: PUSH
 481: LD_INT 5
 483: PUSH
 484: LD_INT 9
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: ST_TO_ADDR
// MC_SetLabKind ( 1 , [ b_lab_weapon , b_lab_siberium , b_lab_computer ] ) ;
 493: LD_INT 1
 495: PPUSH
 496: LD_INT 10
 498: PUSH
 499: LD_INT 11
 501: PUSH
 502: LD_INT 12
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: PPUSH
 510: CALL 58411 0 2
// MC_SetCratesArea ( 1 , [ allianceCratesArea ] ) ;
 514: LD_INT 1
 516: PPUSH
 517: LD_INT 17
 519: PUSH
 520: EMPTY
 521: LIST
 522: PPUSH
 523: CALL 58504 0 2
// MC_SetDefenderLimit ( 1 , 5 ) ;
 527: LD_INT 1
 529: PPUSH
 530: LD_INT 5
 532: PPUSH
 533: CALL 57854 0 2
// MC_SetProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_manual , ru_rocket ] ] ) ;
 537: LD_INT 1
 539: PPUSH
 540: LD_INT 24
 542: PUSH
 543: LD_INT 3
 545: PUSH
 546: LD_INT 3
 548: PUSH
 549: LD_INT 47
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 24
 560: PUSH
 561: LD_INT 3
 563: PUSH
 564: LD_INT 3
 566: PUSH
 567: LD_INT 47
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 24
 578: PUSH
 579: LD_INT 3
 581: PUSH
 582: LD_INT 3
 584: PUSH
 585: LD_INT 47
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: LD_INT 3
 599: PUSH
 600: LD_INT 1
 602: PUSH
 603: LD_INT 47
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: LD_INT 24
 614: PUSH
 615: LD_INT 3
 617: PUSH
 618: LD_INT 1
 620: PUSH
 621: LD_INT 47
 623: PUSH
 624: EMPTY
 625: LIST
 626: LIST
 627: LIST
 628: LIST
 629: PUSH
 630: EMPTY
 631: LIST
 632: LIST
 633: LIST
 634: LIST
 635: LIST
 636: PPUSH
 637: CALL 57669 0 2
// MC_SetLabKind ( 2 , [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_spacetime ] ) ;
 641: LD_INT 2
 643: PPUSH
 644: LD_INT 10
 646: PUSH
 647: LD_INT 11
 649: PUSH
 650: LD_INT 12
 652: PUSH
 653: LD_INT 14
 655: PUSH
 656: EMPTY
 657: LIST
 658: LIST
 659: LIST
 660: LIST
 661: PPUSH
 662: CALL 58411 0 2
// MC_SetCratesArea ( 2 , [ russianCratesArea ] ) ;
 666: LD_INT 2
 668: PPUSH
 669: LD_INT 16
 671: PUSH
 672: EMPTY
 673: LIST
 674: PPUSH
 675: CALL 58504 0 2
// MC_SetProduceList ( 2 , [ [ ru_medium_wheeled , engine_siberite , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_crane ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
 679: LD_INT 2
 681: PPUSH
 682: LD_INT 21
 684: PUSH
 685: LD_INT 3
 687: PUSH
 688: LD_INT 3
 690: PUSH
 691: LD_INT 51
 693: PUSH
 694: EMPTY
 695: LIST
 696: LIST
 697: LIST
 698: LIST
 699: PUSH
 700: LD_INT 22
 702: PUSH
 703: LD_INT 3
 705: PUSH
 706: LD_INT 3
 708: PUSH
 709: LD_INT 52
 711: PUSH
 712: EMPTY
 713: LIST
 714: LIST
 715: LIST
 716: LIST
 717: PUSH
 718: LD_INT 22
 720: PUSH
 721: LD_INT 3
 723: PUSH
 724: LD_INT 3
 726: PUSH
 727: LD_INT 52
 729: PUSH
 730: EMPTY
 731: LIST
 732: LIST
 733: LIST
 734: LIST
 735: PUSH
 736: LD_INT 24
 738: PUSH
 739: LD_INT 3
 741: PUSH
 742: LD_INT 3
 744: PUSH
 745: LD_INT 47
 747: PUSH
 748: EMPTY
 749: LIST
 750: LIST
 751: LIST
 752: LIST
 753: PUSH
 754: LD_INT 24
 756: PUSH
 757: LD_INT 3
 759: PUSH
 760: LD_INT 3
 762: PUSH
 763: LD_INT 47
 765: PUSH
 766: EMPTY
 767: LIST
 768: LIST
 769: LIST
 770: LIST
 771: PUSH
 772: LD_INT 24
 774: PUSH
 775: LD_INT 3
 777: PUSH
 778: LD_INT 3
 780: PUSH
 781: LD_INT 47
 783: PUSH
 784: EMPTY
 785: LIST
 786: LIST
 787: LIST
 788: LIST
 789: PUSH
 790: LD_INT 24
 792: PUSH
 793: LD_INT 3
 795: PUSH
 796: LD_INT 3
 798: PUSH
 799: LD_INT 47
 801: PUSH
 802: EMPTY
 803: LIST
 804: LIST
 805: LIST
 806: LIST
 807: PUSH
 808: LD_INT 24
 810: PUSH
 811: LD_INT 3
 813: PUSH
 814: LD_INT 3
 816: PUSH
 817: LD_INT 47
 819: PUSH
 820: EMPTY
 821: LIST
 822: LIST
 823: LIST
 824: LIST
 825: PUSH
 826: EMPTY
 827: LIST
 828: LIST
 829: LIST
 830: LIST
 831: LIST
 832: LIST
 833: LIST
 834: LIST
 835: PPUSH
 836: CALL 57669 0 2
// MC_SetDefenderLimit ( 2 , 5 ) ;
 840: LD_INT 2
 842: PPUSH
 843: LD_INT 5
 845: PPUSH
 846: CALL 57854 0 2
// MC_SetUpgradeBuilding ( 2 , b_depot ) ;
 850: LD_INT 2
 852: PPUSH
 853: LD_INT 0
 855: PPUSH
 856: CALL 58284 0 2
// MC_SetMinesField ( 3 , [ 10 , 12 , 15 ] [ Difficulty ] , legionMinefield ) ;
 860: LD_INT 3
 862: PPUSH
 863: LD_INT 10
 865: PUSH
 866: LD_INT 12
 868: PUSH
 869: LD_INT 15
 871: PUSH
 872: EMPTY
 873: LIST
 874: LIST
 875: LIST
 876: PUSH
 877: LD_OWVAR 67
 881: ARRAY
 882: PPUSH
 883: LD_INT 27
 885: PPUSH
 886: CALL 57351 0 3
// MC_SetLabKind ( 3 , [ b_lab_weapon , b_lab_siberium , b_lab_biological , b_lab_opto ] ) ;
 890: LD_INT 3
 892: PPUSH
 893: LD_INT 10
 895: PUSH
 896: LD_INT 11
 898: PUSH
 899: LD_INT 13
 901: PUSH
 902: LD_INT 15
 904: PUSH
 905: EMPTY
 906: LIST
 907: LIST
 908: LIST
 909: LIST
 910: PPUSH
 911: CALL 58411 0 2
// MC_SetCratesArea ( 3 , [ legionCratesArea ] ) ;
 915: LD_INT 3
 917: PPUSH
 918: LD_INT 15
 920: PUSH
 921: EMPTY
 922: LIST
 923: PPUSH
 924: CALL 58504 0 2
// mc_ape := Replace ( mc_ape , 3 , FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , class_apeman_soldier ] ] ) ) ;
 928: LD_ADDR_EXP 128
 932: PUSH
 933: LD_EXP 128
 937: PPUSH
 938: LD_INT 3
 940: PPUSH
 941: LD_INT 22
 943: PUSH
 944: LD_INT 8
 946: PUSH
 947: EMPTY
 948: LIST
 949: LIST
 950: PUSH
 951: LD_INT 25
 953: PUSH
 954: LD_INT 15
 956: PUSH
 957: EMPTY
 958: LIST
 959: LIST
 960: PUSH
 961: EMPTY
 962: LIST
 963: LIST
 964: PPUSH
 965: CALL_OW 69
 969: PPUSH
 970: CALL_OW 1
 974: ST_TO_ADDR
// MC_SetProduceList ( 3 , [ [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_solar , control_manual , ar_control_tower ] , [ ar_medium_trike , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
 975: LD_INT 3
 977: PPUSH
 978: LD_INT 13
 980: PUSH
 981: LD_INT 2
 983: PUSH
 984: LD_INT 1
 986: PUSH
 987: LD_INT 31
 989: PUSH
 990: EMPTY
 991: LIST
 992: LIST
 993: LIST
 994: LIST
 995: PUSH
 996: LD_INT 13
 998: PUSH
 999: LD_INT 2
1001: PUSH
1002: LD_INT 1
1004: PUSH
1005: LD_INT 31
1007: PUSH
1008: EMPTY
1009: LIST
1010: LIST
1011: LIST
1012: LIST
1013: PUSH
1014: LD_INT 13
1016: PUSH
1017: LD_INT 3
1019: PUSH
1020: LD_INT 2
1022: PUSH
1023: LD_INT 32
1025: PUSH
1026: EMPTY
1027: LIST
1028: LIST
1029: LIST
1030: LIST
1031: PUSH
1032: EMPTY
1033: LIST
1034: LIST
1035: LIST
1036: PPUSH
1037: CALL 57669 0 2
// MC_SetLabKind ( 4 , [ b_lab_weapon , b_lab_computer ] ) ;
1041: LD_INT 4
1043: PPUSH
1044: LD_INT 10
1046: PUSH
1047: LD_INT 12
1049: PUSH
1050: EMPTY
1051: LIST
1052: LIST
1053: PPUSH
1054: CALL 58411 0 2
// MC_SetCratesArea ( 4 , [ powellBase ] ) ;
1058: LD_INT 4
1060: PPUSH
1061: LD_INT 9
1063: PUSH
1064: EMPTY
1065: LIST
1066: PPUSH
1067: CALL 58504 0 2
// MC_SetBuildingList ( 4 , [ [ b_oil_power , 74 , 107 , 0 ] , [ b_bunker , 77 , 101 , 4 ] , [ b_bunker , 69 , 86 , 4 ] , [ b_solar_power , 77 , 110 , 3 ] , [ b_solar_power , 42 , 79 , 5 ] , [ b_oil_mine , 86 , 105 , 2 ] , [ b_siberite_mine , 40 , 75 , 1 ] , [ b_bunker , 80 , 106 , 4 ] , [ b_bunker , 75 , 114 , 5 ] , [ b_bunker , 82 , 110 , 5 ] , [ b_bunker , 62 , 78 , 4 ] , [ b_armoury , 39 , 61 , 3 ] ] ) ;
1071: LD_INT 4
1073: PPUSH
1074: LD_INT 26
1076: PUSH
1077: LD_INT 74
1079: PUSH
1080: LD_INT 107
1082: PUSH
1083: LD_INT 0
1085: PUSH
1086: EMPTY
1087: LIST
1088: LIST
1089: LIST
1090: LIST
1091: PUSH
1092: LD_INT 32
1094: PUSH
1095: LD_INT 77
1097: PUSH
1098: LD_INT 101
1100: PUSH
1101: LD_INT 4
1103: PUSH
1104: EMPTY
1105: LIST
1106: LIST
1107: LIST
1108: LIST
1109: PUSH
1110: LD_INT 32
1112: PUSH
1113: LD_INT 69
1115: PUSH
1116: LD_INT 86
1118: PUSH
1119: LD_INT 4
1121: PUSH
1122: EMPTY
1123: LIST
1124: LIST
1125: LIST
1126: LIST
1127: PUSH
1128: LD_INT 27
1130: PUSH
1131: LD_INT 77
1133: PUSH
1134: LD_INT 110
1136: PUSH
1137: LD_INT 3
1139: PUSH
1140: EMPTY
1141: LIST
1142: LIST
1143: LIST
1144: LIST
1145: PUSH
1146: LD_INT 27
1148: PUSH
1149: LD_INT 42
1151: PUSH
1152: LD_INT 79
1154: PUSH
1155: LD_INT 5
1157: PUSH
1158: EMPTY
1159: LIST
1160: LIST
1161: LIST
1162: LIST
1163: PUSH
1164: LD_INT 29
1166: PUSH
1167: LD_INT 86
1169: PUSH
1170: LD_INT 105
1172: PUSH
1173: LD_INT 2
1175: PUSH
1176: EMPTY
1177: LIST
1178: LIST
1179: LIST
1180: LIST
1181: PUSH
1182: LD_INT 30
1184: PUSH
1185: LD_INT 40
1187: PUSH
1188: LD_INT 75
1190: PUSH
1191: LD_INT 1
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: LIST
1198: LIST
1199: PUSH
1200: LD_INT 32
1202: PUSH
1203: LD_INT 80
1205: PUSH
1206: LD_INT 106
1208: PUSH
1209: LD_INT 4
1211: PUSH
1212: EMPTY
1213: LIST
1214: LIST
1215: LIST
1216: LIST
1217: PUSH
1218: LD_INT 32
1220: PUSH
1221: LD_INT 75
1223: PUSH
1224: LD_INT 114
1226: PUSH
1227: LD_INT 5
1229: PUSH
1230: EMPTY
1231: LIST
1232: LIST
1233: LIST
1234: LIST
1235: PUSH
1236: LD_INT 32
1238: PUSH
1239: LD_INT 82
1241: PUSH
1242: LD_INT 110
1244: PUSH
1245: LD_INT 5
1247: PUSH
1248: EMPTY
1249: LIST
1250: LIST
1251: LIST
1252: LIST
1253: PUSH
1254: LD_INT 32
1256: PUSH
1257: LD_INT 62
1259: PUSH
1260: LD_INT 78
1262: PUSH
1263: LD_INT 4
1265: PUSH
1266: EMPTY
1267: LIST
1268: LIST
1269: LIST
1270: LIST
1271: PUSH
1272: LD_INT 4
1274: PUSH
1275: LD_INT 39
1277: PUSH
1278: LD_INT 61
1280: PUSH
1281: LD_INT 3
1283: PUSH
1284: EMPTY
1285: LIST
1286: LIST
1287: LIST
1288: LIST
1289: PUSH
1290: EMPTY
1291: LIST
1292: LIST
1293: LIST
1294: LIST
1295: LIST
1296: LIST
1297: LIST
1298: LIST
1299: LIST
1300: LIST
1301: LIST
1302: LIST
1303: PPUSH
1304: CALL 57561 0 2
// MC_SetAllowedTurretWeapons ( 4 , [ us_double_gun , us_heavy_gun , us_rocket_launcher , us_laser ] ) ;
1308: LD_INT 4
1310: PPUSH
1311: LD_INT 5
1313: PUSH
1314: LD_INT 6
1316: PUSH
1317: LD_INT 7
1319: PUSH
1320: LD_INT 9
1322: PUSH
1323: EMPTY
1324: LIST
1325: LIST
1326: LIST
1327: LIST
1328: PPUSH
1329: CALL 58822 0 2
// MC_SetDepositsXY ( 4 , [ [ 40 , 75 , 1 ] , [ 86 , 105 , 0 ] ] ) ;
1333: LD_INT 4
1335: PPUSH
1336: LD_INT 40
1338: PUSH
1339: LD_INT 75
1341: PUSH
1342: LD_INT 1
1344: PUSH
1345: EMPTY
1346: LIST
1347: LIST
1348: LIST
1349: PUSH
1350: LD_INT 86
1352: PUSH
1353: LD_INT 105
1355: PUSH
1356: LD_INT 0
1358: PUSH
1359: EMPTY
1360: LIST
1361: LIST
1362: LIST
1363: PUSH
1364: EMPTY
1365: LIST
1366: LIST
1367: PPUSH
1368: CALL 57993 0 2
// MC_SetUpgradeBuilding ( 4 , b_workshop ) ;
1372: LD_INT 4
1374: PPUSH
1375: LD_INT 2
1377: PPUSH
1378: CALL 58284 0 2
// MC_SetUpgradeBuilding ( 4 , b_depot ) ;
1382: LD_INT 4
1384: PPUSH
1385: LD_INT 0
1387: PPUSH
1388: CALL 58284 0 2
// MC_SetFactoryExtension ( 4 , 54 , 85 , 2 , [ b_ext_noncombat , b_ext_track , b_ext_gun , b_ext_rocket ] ) ;
1392: LD_INT 4
1394: PPUSH
1395: LD_INT 54
1397: PPUSH
1398: LD_INT 85
1400: PPUSH
1401: LD_INT 2
1403: PPUSH
1404: LD_INT 19
1406: PUSH
1407: LD_INT 16
1409: PUSH
1410: LD_INT 17
1412: PUSH
1413: LD_INT 18
1415: PUSH
1416: EMPTY
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: PPUSH
1422: CALL 58616 0 5
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] ] ) ;
1426: LD_INT 4
1428: PPUSH
1429: LD_INT 3
1431: PUSH
1432: LD_INT 1
1434: PUSH
1435: LD_INT 1
1437: PUSH
1438: LD_INT 5
1440: PUSH
1441: EMPTY
1442: LIST
1443: LIST
1444: LIST
1445: LIST
1446: PUSH
1447: LD_INT 4
1449: PUSH
1450: LD_INT 1
1452: PUSH
1453: LD_INT 1
1455: PUSH
1456: LD_INT 6
1458: PUSH
1459: EMPTY
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: PUSH
1465: LD_INT 4
1467: PUSH
1468: LD_INT 1
1470: PUSH
1471: LD_INT 1
1473: PUSH
1474: LD_INT 7
1476: PUSH
1477: EMPTY
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: PUSH
1483: LD_INT 4
1485: PUSH
1486: LD_INT 1
1488: PUSH
1489: LD_INT 1
1491: PUSH
1492: LD_INT 6
1494: PUSH
1495: EMPTY
1496: LIST
1497: LIST
1498: LIST
1499: LIST
1500: PUSH
1501: EMPTY
1502: LIST
1503: LIST
1504: LIST
1505: LIST
1506: PPUSH
1507: CALL 57669 0 2
// MC_SetTame ( 4 , powellApe ) ;
1511: LD_INT 4
1513: PPUSH
1514: LD_INT 13
1516: PPUSH
1517: CALL 58235 0 2
// end ;
1521: LD_VAR 0 1
1525: RET
// every 0 0$1 trigger debug do var i , tmp ;
1526: LD_EXP 1
1530: IFFALSE 1637
1532: GO 1534
1534: DISABLE
1535: LD_INT 0
1537: PPUSH
1538: PPUSH
// begin enable ;
1539: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_type , unit_building ] ] , [ f_not , [ f_lives , 999 ] ] ] ) ;
1540: LD_ADDR_VAR 0 2
1544: PUSH
1545: LD_INT 22
1547: PUSH
1548: LD_INT 1
1550: PUSH
1551: EMPTY
1552: LIST
1553: LIST
1554: PUSH
1555: LD_INT 3
1557: PUSH
1558: LD_INT 21
1560: PUSH
1561: LD_INT 3
1563: PUSH
1564: EMPTY
1565: LIST
1566: LIST
1567: PUSH
1568: EMPTY
1569: LIST
1570: LIST
1571: PUSH
1572: LD_INT 3
1574: PUSH
1575: LD_INT 24
1577: PUSH
1578: LD_INT 999
1580: PUSH
1581: EMPTY
1582: LIST
1583: LIST
1584: PUSH
1585: EMPTY
1586: LIST
1587: LIST
1588: PUSH
1589: EMPTY
1590: LIST
1591: LIST
1592: LIST
1593: PPUSH
1594: CALL_OW 69
1598: ST_TO_ADDR
// if not tmp then
1599: LD_VAR 0 2
1603: NOT
1604: IFFALSE 1608
// exit ;
1606: GO 1637
// for i in tmp do
1608: LD_ADDR_VAR 0 1
1612: PUSH
1613: LD_VAR 0 2
1617: PUSH
1618: FOR_IN
1619: IFFALSE 1635
// SetLives ( i , 1000 ) ;
1621: LD_VAR 0 1
1625: PPUSH
1626: LD_INT 1000
1628: PPUSH
1629: CALL_OW 234
1633: GO 1618
1635: POP
1636: POP
// end ; end_of_file
1637: PPOPN 2
1639: END
// export JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ; export JMMNewVeh , GirlNewVeh ; export function PrepareAmerican ; begin
1640: LD_INT 0
1642: PPUSH
// uc_side := 1 ;
1643: LD_ADDR_OWVAR 20
1647: PUSH
1648: LD_INT 1
1650: ST_TO_ADDR
// uc_nation := 1 ;
1651: LD_ADDR_OWVAR 21
1655: PUSH
1656: LD_INT 1
1658: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 14_ ) ;
1659: LD_ADDR_EXP 36
1663: PUSH
1664: LD_STRING JMM
1666: PPUSH
1667: LD_EXP 1
1671: NOT
1672: PPUSH
1673: LD_STRING 14_
1675: PPUSH
1676: CALL 64061 0 3
1680: ST_TO_ADDR
// if not JMMVeh or not JMMVeh [ 1 ] [ 1 ] then
1681: LD_EXP 4
1685: NOT
1686: PUSH
1687: LD_EXP 4
1691: PUSH
1692: LD_INT 1
1694: ARRAY
1695: PUSH
1696: LD_INT 1
1698: ARRAY
1699: NOT
1700: OR
1701: IFFALSE 1724
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) else
1703: LD_INT 3
1705: PPUSH
1706: LD_INT 3
1708: PPUSH
1709: LD_INT 1
1711: PPUSH
1712: LD_INT 5
1714: PPUSH
1715: LD_INT 100
1717: PPUSH
1718: CALL 71087 0 5
1722: GO 1783
// PrepareVehicle ( JMMVeh [ 1 ] [ 1 ] , JMMVeh [ 2 ] [ 1 ] , JMMVeh [ 3 ] [ 1 ] , JMMVeh [ 4 ] [ 1 ] , 30 ) ;
1724: LD_EXP 4
1728: PUSH
1729: LD_INT 1
1731: ARRAY
1732: PUSH
1733: LD_INT 1
1735: ARRAY
1736: PPUSH
1737: LD_EXP 4
1741: PUSH
1742: LD_INT 2
1744: ARRAY
1745: PUSH
1746: LD_INT 1
1748: ARRAY
1749: PPUSH
1750: LD_EXP 4
1754: PUSH
1755: LD_INT 3
1757: ARRAY
1758: PUSH
1759: LD_INT 1
1761: ARRAY
1762: PPUSH
1763: LD_EXP 4
1767: PUSH
1768: LD_INT 4
1770: ARRAY
1771: PUSH
1772: LD_INT 1
1774: ARRAY
1775: PPUSH
1776: LD_INT 30
1778: PPUSH
1779: CALL 71087 0 5
// JMMNewVeh := CreateVehicle ;
1783: LD_ADDR_EXP 53
1787: PUSH
1788: CALL_OW 45
1792: ST_TO_ADDR
// if not JMMNewVeh then
1793: LD_EXP 53
1797: NOT
1798: IFFALSE 1829
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_double_gun , 100 ) ;
1800: LD_INT 3
1802: PPUSH
1803: LD_INT 3
1805: PPUSH
1806: LD_INT 1
1808: PPUSH
1809: LD_INT 5
1811: PPUSH
1812: LD_INT 100
1814: PPUSH
1815: CALL 71087 0 5
// JMMNewVeh := CreateVehicle ;
1819: LD_ADDR_EXP 53
1823: PUSH
1824: CALL_OW 45
1828: ST_TO_ADDR
// end ; SetDir ( JMMNewVeh , 4 ) ;
1829: LD_EXP 53
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: CALL_OW 233
// PlaceUnitXY ( JMMNewVeh , 79 , 91 , false ) ;
1841: LD_EXP 53
1845: PPUSH
1846: LD_INT 79
1848: PPUSH
1849: LD_INT 91
1851: PPUSH
1852: LD_INT 0
1854: PPUSH
1855: CALL_OW 48
// PlaceHumanInUnit ( JMM , JMMNewVeh ) ;
1859: LD_EXP 36
1863: PPUSH
1864: LD_EXP 53
1868: PPUSH
1869: CALL_OW 52
// if JMMGirlStatus and not KappaStatus then
1873: LD_EXP 6
1877: PUSH
1878: LD_EXP 2
1882: NOT
1883: AND
1884: IFFALSE 2142
// begin if not JMMGirlVeh then
1886: LD_EXP 5
1890: NOT
1891: IFFALSE 1914
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , us_laser , 100 ) else
1893: LD_INT 3
1895: PPUSH
1896: LD_INT 3
1898: PPUSH
1899: LD_INT 1
1901: PPUSH
1902: LD_INT 9
1904: PPUSH
1905: LD_INT 100
1907: PPUSH
1908: CALL 71087 0 5
1912: GO 1973
// PrepareVehicle ( JMMGirlVeh [ 1 ] [ 1 ] , JMMGirlVeh [ 2 ] [ 1 ] , JMMGirlVeh [ 3 ] [ 1 ] , JMMGirlVeh [ 4 ] [ 1 ] , 30 ) ;
1914: LD_EXP 5
1918: PUSH
1919: LD_INT 1
1921: ARRAY
1922: PUSH
1923: LD_INT 1
1925: ARRAY
1926: PPUSH
1927: LD_EXP 5
1931: PUSH
1932: LD_INT 2
1934: ARRAY
1935: PUSH
1936: LD_INT 1
1938: ARRAY
1939: PPUSH
1940: LD_EXP 5
1944: PUSH
1945: LD_INT 3
1947: ARRAY
1948: PUSH
1949: LD_INT 1
1951: ARRAY
1952: PPUSH
1953: LD_EXP 5
1957: PUSH
1958: LD_INT 4
1960: ARRAY
1961: PUSH
1962: LD_INT 1
1964: ARRAY
1965: PPUSH
1966: LD_INT 30
1968: PPUSH
1969: CALL 71087 0 5
// GirlNewVeh := CreateVehicle ;
1973: LD_ADDR_EXP 54
1977: PUSH
1978: CALL_OW 45
1982: ST_TO_ADDR
// SetDir ( GirlNewVeh , 4 ) ;
1983: LD_EXP 54
1987: PPUSH
1988: LD_INT 4
1990: PPUSH
1991: CALL_OW 233
// PlaceUnitXY ( GirlNewVeh , 82 , 96 , false ) ;
1995: LD_EXP 54
1999: PPUSH
2000: LD_INT 82
2002: PPUSH
2003: LD_INT 96
2005: PPUSH
2006: LD_INT 0
2008: PPUSH
2009: CALL_OW 48
// if JMMGirl = 1 then
2013: LD_EXP 7
2017: PUSH
2018: LD_INT 1
2020: EQUAL
2021: IFFALSE 2056
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
2023: LD_ADDR_EXP 37
2027: PUSH
2028: LD_STRING Joan
2030: PPUSH
2031: LD_INT 1
2033: PPUSH
2034: LD_STRING 14_
2036: PPUSH
2037: CALL 64061 0 3
2041: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , GirlNewVeh ) ;
2042: LD_EXP 37
2046: PPUSH
2047: LD_EXP 54
2051: PPUSH
2052: CALL_OW 52
// end ; if JMMGirl = 2 then
2056: LD_EXP 7
2060: PUSH
2061: LD_INT 2
2063: EQUAL
2064: IFFALSE 2099
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
2066: LD_ADDR_EXP 39
2070: PUSH
2071: LD_STRING Lisa
2073: PPUSH
2074: LD_INT 1
2076: PPUSH
2077: LD_STRING 14_
2079: PPUSH
2080: CALL 64061 0 3
2084: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , GirlNewVeh ) ;
2085: LD_EXP 39
2089: PPUSH
2090: LD_EXP 54
2094: PPUSH
2095: CALL_OW 52
// end ; if JMMGirl = 3 then
2099: LD_EXP 7
2103: PUSH
2104: LD_INT 3
2106: EQUAL
2107: IFFALSE 2142
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
2109: LD_ADDR_EXP 51
2113: PUSH
2114: LD_STRING Connie
2116: PPUSH
2117: LD_INT 1
2119: PPUSH
2120: LD_STRING 14_
2122: PPUSH
2123: CALL 64061 0 3
2127: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , GirlNewVeh ) ;
2128: LD_EXP 51
2132: PPUSH
2133: LD_EXP 54
2137: PPUSH
2138: CALL_OW 52
// end ; end ; end ;
2142: LD_VAR 0 1
2146: RET
// export function PrepareStevensSquad ; var tmp ; begin
2147: LD_INT 0
2149: PPUSH
2150: PPUSH
// uc_side := 1 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 1
2158: ST_TO_ADDR
// uc_nation := 1 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 1
2166: ST_TO_ADDR
// tmp := [ ] ;
2167: LD_ADDR_VAR 0 2
2171: PUSH
2172: EMPTY
2173: ST_TO_ADDR
// Stevens := PrepareUnit ( Stevens , ( not debug ) , 13f_ ) ;
2174: LD_ADDR_EXP 38
2178: PUSH
2179: LD_STRING Stevens
2181: PPUSH
2182: LD_EXP 1
2186: NOT
2187: PPUSH
2188: LD_STRING 13f_
2190: PPUSH
2191: CALL 64061 0 3
2195: ST_TO_ADDR
// if not Stevens then
2196: LD_EXP 38
2200: NOT
2201: IFFALSE 2257
// begin hc_name = Baker Smith ;
2203: LD_ADDR_OWVAR 26
2207: PUSH
2208: LD_STRING Baker Smith
2210: ST_TO_ADDR
// hc_gallery =  ;
2211: LD_ADDR_OWVAR 33
2215: PUSH
2216: LD_STRING 
2218: ST_TO_ADDR
// PrepareScientist ( sex_male , 10 ) ;
2219: LD_INT 1
2221: PPUSH
2222: LD_INT 10
2224: PPUSH
2225: CALL_OW 384
// Baker = CreateHuman ;
2229: LD_ADDR_EXP 52
2233: PUSH
2234: CALL_OW 44
2238: ST_TO_ADDR
// tmp := tmp ^ Baker ;
2239: LD_ADDR_VAR 0 2
2243: PUSH
2244: LD_VAR 0 2
2248: PUSH
2249: LD_EXP 52
2253: ADD
2254: ST_TO_ADDR
// end else
2255: GO 2273
// tmp := tmp ^ Stevens ;
2257: LD_ADDR_VAR 0 2
2261: PUSH
2262: LD_VAR 0 2
2266: PUSH
2267: LD_EXP 38
2271: ADD
2272: ST_TO_ADDR
// if not Lisa then
2273: LD_EXP 39
2277: NOT
2278: IFFALSE 2324
// begin Lisa := PrepareUnit ( Lisa , ( not debug ) , 13f_ ) ;
2280: LD_ADDR_EXP 39
2284: PUSH
2285: LD_STRING Lisa
2287: PPUSH
2288: LD_EXP 1
2292: NOT
2293: PPUSH
2294: LD_STRING 13f_
2296: PPUSH
2297: CALL 64061 0 3
2301: ST_TO_ADDR
// if Lisa then
2302: LD_EXP 39
2306: IFFALSE 2324
// tmp := tmp ^ Lisa ;
2308: LD_ADDR_VAR 0 2
2312: PUSH
2313: LD_VAR 0 2
2317: PUSH
2318: LD_EXP 39
2322: ADD
2323: ST_TO_ADDR
// end ; if not Donaldson then
2324: LD_EXP 40
2328: NOT
2329: IFFALSE 2375
// begin Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13f_ ) ;
2331: LD_ADDR_EXP 40
2335: PUSH
2336: LD_STRING Donaldson
2338: PPUSH
2339: LD_EXP 1
2343: NOT
2344: PPUSH
2345: LD_STRING 13f_
2347: PPUSH
2348: CALL 64061 0 3
2352: ST_TO_ADDR
// if Donaldson then
2353: LD_EXP 40
2357: IFFALSE 2375
// tmp := tmp ^ Donaldson ;
2359: LD_ADDR_VAR 0 2
2363: PUSH
2364: LD_VAR 0 2
2368: PUSH
2369: LD_EXP 40
2373: ADD
2374: ST_TO_ADDR
// end ; if not Bobby then
2375: LD_EXP 41
2379: NOT
2380: IFFALSE 2426
// begin Bobby := PrepareUnit ( Bobby , ( not debug ) , 13f_ ) ;
2382: LD_ADDR_EXP 41
2386: PUSH
2387: LD_STRING Bobby
2389: PPUSH
2390: LD_EXP 1
2394: NOT
2395: PPUSH
2396: LD_STRING 13f_
2398: PPUSH
2399: CALL 64061 0 3
2403: ST_TO_ADDR
// if Bobby then
2404: LD_EXP 41
2408: IFFALSE 2426
// tmp := tmp ^ Bobby ;
2410: LD_ADDR_VAR 0 2
2414: PUSH
2415: LD_VAR 0 2
2419: PUSH
2420: LD_EXP 41
2424: ADD
2425: ST_TO_ADDR
// end ; if not Cyrus then
2426: LD_EXP 42
2430: NOT
2431: IFFALSE 2477
// begin Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13f_ ) ;
2433: LD_ADDR_EXP 42
2437: PUSH
2438: LD_STRING Cyrus
2440: PPUSH
2441: LD_EXP 1
2445: NOT
2446: PPUSH
2447: LD_STRING 13f_
2449: PPUSH
2450: CALL 64061 0 3
2454: ST_TO_ADDR
// if Cyrus then
2455: LD_EXP 42
2459: IFFALSE 2477
// tmp := tmp ^ Cyrus ;
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 2
2470: PUSH
2471: LD_EXP 42
2475: ADD
2476: ST_TO_ADDR
// end ; if not Brown then
2477: LD_EXP 44
2481: NOT
2482: IFFALSE 2528
// begin Brown := PrepareUnit ( Brown , ( not debug ) , 13f_ ) ;
2484: LD_ADDR_EXP 44
2488: PUSH
2489: LD_STRING Brown
2491: PPUSH
2492: LD_EXP 1
2496: NOT
2497: PPUSH
2498: LD_STRING 13f_
2500: PPUSH
2501: CALL 64061 0 3
2505: ST_TO_ADDR
// if Brown then
2506: LD_EXP 44
2510: IFFALSE 2528
// tmp := tmp ^ Brown ;
2512: LD_ADDR_VAR 0 2
2516: PUSH
2517: LD_VAR 0 2
2521: PUSH
2522: LD_EXP 44
2526: ADD
2527: ST_TO_ADDR
// end ; if not Gladstone then
2528: LD_EXP 45
2532: NOT
2533: IFFALSE 2579
// begin Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13f_ ) ;
2535: LD_ADDR_EXP 45
2539: PUSH
2540: LD_STRING Gladstone
2542: PPUSH
2543: LD_EXP 1
2547: NOT
2548: PPUSH
2549: LD_STRING 13f_
2551: PPUSH
2552: CALL 64061 0 3
2556: ST_TO_ADDR
// if Gladstone then
2557: LD_EXP 45
2561: IFFALSE 2579
// tmp := tmp ^ Gladstone ;
2563: LD_ADDR_VAR 0 2
2567: PUSH
2568: LD_VAR 0 2
2572: PUSH
2573: LD_EXP 45
2577: ADD
2578: ST_TO_ADDR
// end ; if not Houten then
2579: LD_EXP 46
2583: NOT
2584: IFFALSE 2630
// begin Houten := PrepareUnit ( Houten , ( not debug ) , 13f_ ) ;
2586: LD_ADDR_EXP 46
2590: PUSH
2591: LD_STRING Houten
2593: PPUSH
2594: LD_EXP 1
2598: NOT
2599: PPUSH
2600: LD_STRING 13f_
2602: PPUSH
2603: CALL 64061 0 3
2607: ST_TO_ADDR
// if Houten then
2608: LD_EXP 46
2612: IFFALSE 2630
// tmp := tmp ^ Houten ;
2614: LD_ADDR_VAR 0 2
2618: PUSH
2619: LD_VAR 0 2
2623: PUSH
2624: LD_EXP 46
2628: ADD
2629: ST_TO_ADDR
// end ; if not Cornel then
2630: LD_EXP 47
2634: NOT
2635: IFFALSE 2681
// begin Cornel := PrepareUnit ( Cornel , ( not debug ) , 13f_ ) ;
2637: LD_ADDR_EXP 47
2641: PUSH
2642: LD_STRING Cornel
2644: PPUSH
2645: LD_EXP 1
2649: NOT
2650: PPUSH
2651: LD_STRING 13f_
2653: PPUSH
2654: CALL 64061 0 3
2658: ST_TO_ADDR
// if Cornel then
2659: LD_EXP 47
2663: IFFALSE 2681
// tmp := tmp ^ Cornel ;
2665: LD_ADDR_VAR 0 2
2669: PUSH
2670: LD_VAR 0 2
2674: PUSH
2675: LD_EXP 47
2679: ADD
2680: ST_TO_ADDR
// end ; if not Gary then
2681: LD_EXP 48
2685: NOT
2686: IFFALSE 2732
// begin Gary := PrepareUnit ( Gary , ( not debug ) , 13f_ ) ;
2688: LD_ADDR_EXP 48
2692: PUSH
2693: LD_STRING Gary
2695: PPUSH
2696: LD_EXP 1
2700: NOT
2701: PPUSH
2702: LD_STRING 13f_
2704: PPUSH
2705: CALL 64061 0 3
2709: ST_TO_ADDR
// if Gary then
2710: LD_EXP 48
2714: IFFALSE 2732
// tmp := tmp ^ Gary ;
2716: LD_ADDR_VAR 0 2
2720: PUSH
2721: LD_VAR 0 2
2725: PUSH
2726: LD_EXP 48
2730: ADD
2731: ST_TO_ADDR
// end ; if not Frank then
2732: LD_EXP 49
2736: NOT
2737: IFFALSE 2783
// begin Frank := PrepareUnit ( Frank , ( not debug ) , 13f_ ) ;
2739: LD_ADDR_EXP 49
2743: PUSH
2744: LD_STRING Frank
2746: PPUSH
2747: LD_EXP 1
2751: NOT
2752: PPUSH
2753: LD_STRING 13f_
2755: PPUSH
2756: CALL 64061 0 3
2760: ST_TO_ADDR
// if Frank then
2761: LD_EXP 49
2765: IFFALSE 2783
// tmp := tmp ^ Frank ;
2767: LD_ADDR_VAR 0 2
2771: PUSH
2772: LD_VAR 0 2
2776: PUSH
2777: LD_EXP 49
2781: ADD
2782: ST_TO_ADDR
// end ; if not Kikuchi then
2783: LD_EXP 50
2787: NOT
2788: IFFALSE 2834
// begin Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13f_ ) ;
2790: LD_ADDR_EXP 50
2794: PUSH
2795: LD_STRING Kikuchi
2797: PPUSH
2798: LD_EXP 1
2802: NOT
2803: PPUSH
2804: LD_STRING 13f_
2806: PPUSH
2807: CALL 64061 0 3
2811: ST_TO_ADDR
// if Kikuchi then
2812: LD_EXP 50
2816: IFFALSE 2834
// tmp := tmp ^ Kikuchi ;
2818: LD_ADDR_VAR 0 2
2822: PUSH
2823: LD_VAR 0 2
2827: PUSH
2828: LD_EXP 50
2832: ADD
2833: ST_TO_ADDR
// end ; tmp := tmp union CreateCharacterSet ( 13_other_survivors ) ;
2834: LD_ADDR_VAR 0 2
2838: PUSH
2839: LD_VAR 0 2
2843: PUSH
2844: LD_STRING 13_other_survivors
2846: PPUSH
2847: CALL_OW 31
2851: UNION
2852: ST_TO_ADDR
// result := tmp ;
2853: LD_ADDR_VAR 0 1
2857: PUSH
2858: LD_VAR 0 2
2862: ST_TO_ADDR
// end ; end_of_file
2863: LD_VAR 0 1
2867: RET
// export Powell ; export vip ; export function PreparePowell ; var i , b , veh , cl , tmp , depot , lab , armoury , workshop ; begin
2868: LD_INT 0
2870: PPUSH
2871: PPUSH
2872: PPUSH
2873: PPUSH
2874: PPUSH
2875: PPUSH
2876: PPUSH
2877: PPUSH
2878: PPUSH
2879: PPUSH
// uc_side := 4 ;
2880: LD_ADDR_OWVAR 20
2884: PUSH
2885: LD_INT 4
2887: ST_TO_ADDR
// uc_nation := 1 ;
2888: LD_ADDR_OWVAR 21
2892: PUSH
2893: LD_INT 1
2895: ST_TO_ADDR
// SetResourceType ( GetBase ( am_depot ) , mat_cans , 2500 ) ;
2896: LD_INT 387
2898: PPUSH
2899: CALL_OW 274
2903: PPUSH
2904: LD_INT 1
2906: PPUSH
2907: LD_INT 2500
2909: PPUSH
2910: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_oil , 400 ) ;
2914: LD_INT 387
2916: PPUSH
2917: CALL_OW 274
2921: PPUSH
2922: LD_INT 2
2924: PPUSH
2925: LD_INT 400
2927: PPUSH
2928: CALL_OW 277
// SetResourceType ( GetBase ( am_depot ) , mat_siberit , 10 ) ;
2932: LD_INT 387
2934: PPUSH
2935: CALL_OW 274
2939: PPUSH
2940: LD_INT 3
2942: PPUSH
2943: LD_INT 10
2945: PPUSH
2946: CALL_OW 277
// Powell := NewCharacter ( Powell ) ;
2950: LD_ADDR_EXP 55
2954: PUSH
2955: LD_STRING Powell
2957: PPUSH
2958: CALL_OW 25
2962: ST_TO_ADDR
// PlaceUnitXY ( Powell , 57 , 94 , false ) ;
2963: LD_EXP 55
2967: PPUSH
2968: LD_INT 57
2970: PPUSH
2971: LD_INT 94
2973: PPUSH
2974: LD_INT 0
2976: PPUSH
2977: CALL_OW 48
// ComTurnXY ( Powell , 58 , 94 ) ;
2981: LD_EXP 55
2985: PPUSH
2986: LD_INT 58
2988: PPUSH
2989: LD_INT 94
2991: PPUSH
2992: CALL_OW 118
// vip := [ ] ;
2996: LD_ADDR_EXP 56
3000: PUSH
3001: EMPTY
3002: ST_TO_ADDR
// tmp := [ ] ;
3003: LD_ADDR_VAR 0 6
3007: PUSH
3008: EMPTY
3009: ST_TO_ADDR
// if JMMGirl <> 2 then
3010: LD_EXP 7
3014: PUSH
3015: LD_INT 2
3017: NONEQUAL
3018: IFFALSE 3042
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 13s_ ) ;
3020: LD_ADDR_EXP 39
3024: PUSH
3025: LD_STRING Lisa
3027: PPUSH
3028: LD_EXP 1
3032: NOT
3033: PPUSH
3034: LD_STRING 13s_
3036: PPUSH
3037: CALL 64061 0 3
3041: ST_TO_ADDR
// if Lisa then
3042: LD_EXP 39
3046: IFFALSE 3064
// tmp := tmp ^ Lisa ;
3048: LD_ADDR_VAR 0 6
3052: PUSH
3053: LD_VAR 0 6
3057: PUSH
3058: LD_EXP 39
3062: ADD
3063: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 13s_ ) ;
3064: LD_ADDR_EXP 40
3068: PUSH
3069: LD_STRING Donaldson
3071: PPUSH
3072: LD_EXP 1
3076: NOT
3077: PPUSH
3078: LD_STRING 13s_
3080: PPUSH
3081: CALL 64061 0 3
3085: ST_TO_ADDR
// if Donaldson then
3086: LD_EXP 40
3090: IFFALSE 3108
// tmp := tmp ^ Donaldson ;
3092: LD_ADDR_VAR 0 6
3096: PUSH
3097: LD_VAR 0 6
3101: PUSH
3102: LD_EXP 40
3106: ADD
3107: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 13s_ ) ;
3108: LD_ADDR_EXP 41
3112: PUSH
3113: LD_STRING Bobby
3115: PPUSH
3116: LD_EXP 1
3120: NOT
3121: PPUSH
3122: LD_STRING 13s_
3124: PPUSH
3125: CALL 64061 0 3
3129: ST_TO_ADDR
// if Bobby then
3130: LD_EXP 41
3134: IFFALSE 3152
// tmp := tmp ^ Bobby ;
3136: LD_ADDR_VAR 0 6
3140: PUSH
3141: LD_VAR 0 6
3145: PUSH
3146: LD_EXP 41
3150: ADD
3151: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 13s_ ) ;
3152: LD_ADDR_EXP 42
3156: PUSH
3157: LD_STRING Cyrus
3159: PPUSH
3160: LD_EXP 1
3164: NOT
3165: PPUSH
3166: LD_STRING 13s_
3168: PPUSH
3169: CALL 64061 0 3
3173: ST_TO_ADDR
// if Cyrus then
3174: LD_EXP 42
3178: IFFALSE 3196
// tmp := tmp ^ Cyrus ;
3180: LD_ADDR_VAR 0 6
3184: PUSH
3185: LD_VAR 0 6
3189: PUSH
3190: LD_EXP 42
3194: ADD
3195: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , 13s_ ) ;
3196: LD_ADDR_EXP 43
3200: PUSH
3201: LD_STRING Denis
3203: PPUSH
3204: LD_EXP 1
3208: NOT
3209: PPUSH
3210: LD_STRING 13s_
3212: PPUSH
3213: CALL 64061 0 3
3217: ST_TO_ADDR
// if not Denis then
3218: LD_EXP 43
3222: NOT
3223: IFFALSE 3247
// Denis := PrepareUnit ( Denis , ( not debug ) , 13f_ ) ;
3225: LD_ADDR_EXP 43
3229: PUSH
3230: LD_STRING Denis
3232: PPUSH
3233: LD_EXP 1
3237: NOT
3238: PPUSH
3239: LD_STRING 13f_
3241: PPUSH
3242: CALL 64061 0 3
3246: ST_TO_ADDR
// if Denis then
3247: LD_EXP 43
3251: IFFALSE 3269
// tmp := tmp ^ Denis ;
3253: LD_ADDR_VAR 0 6
3257: PUSH
3258: LD_VAR 0 6
3262: PUSH
3263: LD_EXP 43
3267: ADD
3268: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , 13s_ ) ;
3269: LD_ADDR_EXP 44
3273: PUSH
3274: LD_STRING Brown
3276: PPUSH
3277: LD_EXP 1
3281: NOT
3282: PPUSH
3283: LD_STRING 13s_
3285: PPUSH
3286: CALL 64061 0 3
3290: ST_TO_ADDR
// if Brown then
3291: LD_EXP 44
3295: IFFALSE 3313
// tmp := tmp ^ Brown ;
3297: LD_ADDR_VAR 0 6
3301: PUSH
3302: LD_VAR 0 6
3306: PUSH
3307: LD_EXP 44
3311: ADD
3312: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 13s_ ) ;
3313: LD_ADDR_EXP 45
3317: PUSH
3318: LD_STRING Gladstone
3320: PPUSH
3321: LD_EXP 1
3325: NOT
3326: PPUSH
3327: LD_STRING 13s_
3329: PPUSH
3330: CALL 64061 0 3
3334: ST_TO_ADDR
// if Gladstone then
3335: LD_EXP 45
3339: IFFALSE 3357
// tmp := tmp ^ Gladstone ;
3341: LD_ADDR_VAR 0 6
3345: PUSH
3346: LD_VAR 0 6
3350: PUSH
3351: LD_EXP 45
3355: ADD
3356: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , 13s_ ) ;
3357: LD_ADDR_EXP 46
3361: PUSH
3362: LD_STRING Houten
3364: PPUSH
3365: LD_EXP 1
3369: NOT
3370: PPUSH
3371: LD_STRING 13s_
3373: PPUSH
3374: CALL 64061 0 3
3378: ST_TO_ADDR
// if Houten then
3379: LD_EXP 46
3383: IFFALSE 3401
// tmp := tmp ^ Houten ;
3385: LD_ADDR_VAR 0 6
3389: PUSH
3390: LD_VAR 0 6
3394: PUSH
3395: LD_EXP 46
3399: ADD
3400: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , 13s_ ) ;
3401: LD_ADDR_EXP 47
3405: PUSH
3406: LD_STRING Cornel
3408: PPUSH
3409: LD_EXP 1
3413: NOT
3414: PPUSH
3415: LD_STRING 13s_
3417: PPUSH
3418: CALL 64061 0 3
3422: ST_TO_ADDR
// if Cornel then
3423: LD_EXP 47
3427: IFFALSE 3445
// tmp := tmp ^ Cornel ;
3429: LD_ADDR_VAR 0 6
3433: PUSH
3434: LD_VAR 0 6
3438: PUSH
3439: LD_EXP 47
3443: ADD
3444: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , 13s_ ) ;
3445: LD_ADDR_EXP 48
3449: PUSH
3450: LD_STRING Gary
3452: PPUSH
3453: LD_EXP 1
3457: NOT
3458: PPUSH
3459: LD_STRING 13s_
3461: PPUSH
3462: CALL 64061 0 3
3466: ST_TO_ADDR
// if Gary then
3467: LD_EXP 48
3471: IFFALSE 3489
// tmp := tmp ^ Gary ;
3473: LD_ADDR_VAR 0 6
3477: PUSH
3478: LD_VAR 0 6
3482: PUSH
3483: LD_EXP 48
3487: ADD
3488: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , 13s_ ) ;
3489: LD_ADDR_EXP 49
3493: PUSH
3494: LD_STRING Frank
3496: PPUSH
3497: LD_EXP 1
3501: NOT
3502: PPUSH
3503: LD_STRING 13s_
3505: PPUSH
3506: CALL 64061 0 3
3510: ST_TO_ADDR
// if Frank then
3511: LD_EXP 49
3515: IFFALSE 3533
// tmp := tmp ^ Frank ;
3517: LD_ADDR_VAR 0 6
3521: PUSH
3522: LD_VAR 0 6
3526: PUSH
3527: LD_EXP 49
3531: ADD
3532: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 13s_ ) ;
3533: LD_ADDR_EXP 50
3537: PUSH
3538: LD_STRING Kikuchi
3540: PPUSH
3541: LD_EXP 1
3545: NOT
3546: PPUSH
3547: LD_STRING 13s_
3549: PPUSH
3550: CALL 64061 0 3
3554: ST_TO_ADDR
// if Kikuchi then
3555: LD_EXP 50
3559: IFFALSE 3577
// tmp := tmp ^ Kikuchi ;
3561: LD_ADDR_VAR 0 6
3565: PUSH
3566: LD_VAR 0 6
3570: PUSH
3571: LD_EXP 50
3575: ADD
3576: ST_TO_ADDR
// vip := tmp ;
3577: LD_ADDR_EXP 56
3581: PUSH
3582: LD_VAR 0 6
3586: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 13s_others ) ;
3587: LD_ADDR_VAR 0 6
3591: PUSH
3592: LD_VAR 0 6
3596: PUSH
3597: LD_STRING 13s_others
3599: PPUSH
3600: CALL_OW 31
3604: UNION
3605: ST_TO_ADDR
// if tmp < 20 then
3606: LD_VAR 0 6
3610: PUSH
3611: LD_INT 20
3613: LESS
3614: IFFALSE 3681
// for i = 1 to 20 - tmp do
3616: LD_ADDR_VAR 0 2
3620: PUSH
3621: DOUBLE
3622: LD_INT 1
3624: DEC
3625: ST_TO_ADDR
3626: LD_INT 20
3628: PUSH
3629: LD_VAR 0 6
3633: MINUS
3634: PUSH
3635: FOR_TO
3636: IFFALSE 3679
// begin PrepareHuman ( sex_male , i mod 4 + 1 , 5 ) ;
3638: LD_INT 1
3640: PPUSH
3641: LD_VAR 0 2
3645: PUSH
3646: LD_INT 4
3648: MOD
3649: PUSH
3650: LD_INT 1
3652: PLUS
3653: PPUSH
3654: LD_INT 5
3656: PPUSH
3657: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
3661: LD_ADDR_VAR 0 6
3665: PUSH
3666: LD_VAR 0 6
3670: PUSH
3671: CALL_OW 44
3675: ADD
3676: ST_TO_ADDR
// end ;
3677: GO 3635
3679: POP
3680: POP
// depot := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_depot ] ] ) [ 1 ] ;
3681: LD_ADDR_VAR 0 7
3685: PUSH
3686: LD_INT 22
3688: PUSH
3689: LD_INT 4
3691: PUSH
3692: EMPTY
3693: LIST
3694: LIST
3695: PUSH
3696: LD_INT 30
3698: PUSH
3699: LD_INT 0
3701: PUSH
3702: EMPTY
3703: LIST
3704: LIST
3705: PUSH
3706: EMPTY
3707: LIST
3708: LIST
3709: PPUSH
3710: CALL_OW 69
3714: PUSH
3715: LD_INT 1
3717: ARRAY
3718: ST_TO_ADDR
// lab := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_lab ] ] ) [ 1 ] ;
3719: LD_ADDR_VAR 0 8
3723: PUSH
3724: LD_INT 22
3726: PUSH
3727: LD_INT 4
3729: PUSH
3730: EMPTY
3731: LIST
3732: LIST
3733: PUSH
3734: LD_INT 30
3736: PUSH
3737: LD_INT 6
3739: PUSH
3740: EMPTY
3741: LIST
3742: LIST
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PPUSH
3748: CALL_OW 69
3752: PUSH
3753: LD_INT 1
3755: ARRAY
3756: ST_TO_ADDR
// armoury := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) [ 1 ] ;
3757: LD_ADDR_VAR 0 9
3761: PUSH
3762: LD_INT 22
3764: PUSH
3765: LD_INT 4
3767: PUSH
3768: EMPTY
3769: LIST
3770: LIST
3771: PUSH
3772: LD_INT 30
3774: PUSH
3775: LD_INT 4
3777: PUSH
3778: EMPTY
3779: LIST
3780: LIST
3781: PUSH
3782: EMPTY
3783: LIST
3784: LIST
3785: PPUSH
3786: CALL_OW 69
3790: PUSH
3791: LD_INT 1
3793: ARRAY
3794: ST_TO_ADDR
// workshop := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_workshop ] ] ) [ 1 ] ;
3795: LD_ADDR_VAR 0 10
3799: PUSH
3800: LD_INT 22
3802: PUSH
3803: LD_INT 4
3805: PUSH
3806: EMPTY
3807: LIST
3808: LIST
3809: PUSH
3810: LD_INT 30
3812: PUSH
3813: LD_INT 2
3815: PUSH
3816: EMPTY
3817: LIST
3818: LIST
3819: PUSH
3820: EMPTY
3821: LIST
3822: LIST
3823: PPUSH
3824: CALL_OW 69
3828: PUSH
3829: LD_INT 1
3831: ARRAY
3832: ST_TO_ADDR
// for i in tmp do
3833: LD_ADDR_VAR 0 2
3837: PUSH
3838: LD_VAR 0 6
3842: PUSH
3843: FOR_IN
3844: IFFALSE 3970
// begin cl := GetClass ( i ) ;
3846: LD_ADDR_VAR 0 5
3850: PUSH
3851: LD_VAR 0 2
3855: PPUSH
3856: CALL_OW 257
3860: ST_TO_ADDR
// if cl > 4 then
3861: LD_VAR 0 5
3865: PUSH
3866: LD_INT 4
3868: GREATER
3869: IFFALSE 3879
// cl := 1 ;
3871: LD_ADDR_VAR 0 5
3875: PUSH
3876: LD_INT 1
3878: ST_TO_ADDR
// b := [ armoury , depot , workshop , lab ] [ cl ] ;
3879: LD_ADDR_VAR 0 3
3883: PUSH
3884: LD_VAR 0 9
3888: PUSH
3889: LD_VAR 0 7
3893: PUSH
3894: LD_VAR 0 10
3898: PUSH
3899: LD_VAR 0 8
3903: PUSH
3904: EMPTY
3905: LIST
3906: LIST
3907: LIST
3908: LIST
3909: PUSH
3910: LD_VAR 0 5
3914: ARRAY
3915: ST_TO_ADDR
// if UnitsInside ( b ) < 5 then
3916: LD_VAR 0 3
3920: PPUSH
3921: CALL_OW 313
3925: PUSH
3926: LD_INT 5
3928: LESS
3929: IFFALSE 3947
// PlaceHumanInUnit ( i , b ) else
3931: LD_VAR 0 2
3935: PPUSH
3936: LD_VAR 0 3
3940: PPUSH
3941: CALL_OW 52
3945: GO 3968
// PlaceUnitXYR ( i , 58 , 91 , 6 , false ) ;
3947: LD_VAR 0 2
3951: PPUSH
3952: LD_INT 58
3954: PPUSH
3955: LD_INT 91
3957: PPUSH
3958: LD_INT 6
3960: PPUSH
3961: LD_INT 0
3963: PPUSH
3964: CALL_OW 50
// end ;
3968: GO 3843
3970: POP
3971: POP
// PrepareVehicle ( us_medium_wheeled , engine_combustion , control_manual , us_cargo_bay , 100 ) ;
3972: LD_INT 2
3974: PPUSH
3975: LD_INT 1
3977: PPUSH
3978: LD_INT 1
3980: PPUSH
3981: LD_INT 12
3983: PPUSH
3984: LD_INT 100
3986: PPUSH
3987: CALL 71087 0 5
// veh := CreateVehicle ;
3991: LD_ADDR_VAR 0 4
3995: PUSH
3996: CALL_OW 45
4000: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
4001: LD_VAR 0 4
4005: PPUSH
4006: LD_INT 4
4008: PPUSH
4009: CALL_OW 233
// PlaceUnitXY ( veh , 49 , 88 , false ) ;
4013: LD_VAR 0 4
4017: PPUSH
4018: LD_INT 49
4020: PPUSH
4021: LD_INT 88
4023: PPUSH
4024: LD_INT 0
4026: PPUSH
4027: CALL_OW 48
// SetCargo ( veh , mat_cans , 100 ) ;
4031: LD_VAR 0 4
4035: PPUSH
4036: LD_INT 1
4038: PPUSH
4039: LD_INT 100
4041: PPUSH
4042: CALL_OW 290
// uc_side := 0 ;
4046: LD_ADDR_OWVAR 20
4050: PUSH
4051: LD_INT 0
4053: ST_TO_ADDR
// uc_nation := 0 ;
4054: LD_ADDR_OWVAR 21
4058: PUSH
4059: LD_INT 0
4061: ST_TO_ADDR
// for i = 1 to 4 do
4062: LD_ADDR_VAR 0 2
4066: PUSH
4067: DOUBLE
4068: LD_INT 1
4070: DEC
4071: ST_TO_ADDR
4072: LD_INT 4
4074: PUSH
4075: FOR_TO
4076: IFFALSE 4107
// begin InitHc ;
4078: CALL_OW 19
// hc_class := class_apeman ;
4082: LD_ADDR_OWVAR 28
4086: PUSH
4087: LD_INT 12
4089: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , powellApe , false ) ;
4090: CALL_OW 44
4094: PPUSH
4095: LD_INT 13
4097: PPUSH
4098: LD_INT 0
4100: PPUSH
4101: CALL_OW 49
// end ;
4105: GO 4075
4107: POP
4108: POP
// end ; end_of_file
4109: LD_VAR 0 1
4113: RET
// export Kurt , Kozlov , Friend ; export powellBomb ; export function PrepareLegion ; var i , side , un , tmp ; begin
4114: LD_INT 0
4116: PPUSH
4117: PPUSH
4118: PPUSH
4119: PPUSH
4120: PPUSH
// side := 8 ;
4121: LD_ADDR_VAR 0 3
4125: PUSH
4126: LD_INT 8
4128: ST_TO_ADDR
// uc_side := side ;
4129: LD_ADDR_OWVAR 20
4133: PUSH
4134: LD_VAR 0 3
4138: ST_TO_ADDR
// uc_nation := 2 ;
4139: LD_ADDR_OWVAR 21
4143: PUSH
4144: LD_INT 2
4146: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
4147: LD_ADDR_VAR 0 2
4151: PUSH
4152: LD_INT 22
4154: PUSH
4155: LD_VAR 0 3
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PUSH
4164: LD_INT 21
4166: PUSH
4167: LD_INT 3
4169: PUSH
4170: EMPTY
4171: LIST
4172: LIST
4173: PUSH
4174: EMPTY
4175: LIST
4176: LIST
4177: PPUSH
4178: CALL_OW 69
4182: PUSH
4183: FOR_IN
4184: IFFALSE 4200
// SetBLevel ( i , 10 ) ;
4186: LD_VAR 0 2
4190: PPUSH
4191: LD_INT 10
4193: PPUSH
4194: CALL_OW 241
4198: GO 4183
4200: POP
4201: POP
// if KurtStatus then
4202: LD_EXP 3
4206: IFFALSE 4229
// Kurt := PrepareUnit ( Kurt , false ,  ) else
4208: LD_ADDR_EXP 57
4212: PUSH
4213: LD_STRING Kurt
4215: PPUSH
4216: LD_INT 0
4218: PPUSH
4219: LD_STRING 
4221: PPUSH
4222: CALL 64061 0 3
4226: ST_TO_ADDR
4227: GO 4251
// Kurt := PrepareUnit ( AltKurt , ( not debug ) ,  ) ;
4229: LD_ADDR_EXP 57
4233: PUSH
4234: LD_STRING AltKurt
4236: PPUSH
4237: LD_EXP 1
4241: NOT
4242: PPUSH
4243: LD_STRING 
4245: PPUSH
4246: CALL 64061 0 3
4250: ST_TO_ADDR
// if not Kurt then
4251: LD_EXP 57
4255: NOT
4256: IFFALSE 4282
// begin InitHc ;
4258: CALL_OW 19
// PrepareSoldier ( sex_male , 10 ) ;
4262: LD_INT 1
4264: PPUSH
4265: LD_INT 10
4267: PPUSH
4268: CALL_OW 381
// Kurt := CreateHuman ;
4272: LD_ADDR_EXP 57
4276: PUSH
4277: CALL_OW 44
4281: ST_TO_ADDR
// end ; PlaceHumanInUnit ( Kurt , ar_depot1 ) ;
4282: LD_EXP 57
4286: PPUSH
4287: LD_INT 324
4289: PPUSH
4290: CALL_OW 52
// Kozlov := PrepareUnit ( Kozlov , false ,  ) ;
4294: LD_ADDR_EXP 58
4298: PUSH
4299: LD_STRING Kozlov
4301: PPUSH
4302: LD_INT 0
4304: PPUSH
4305: LD_STRING 
4307: PPUSH
4308: CALL 64061 0 3
4312: ST_TO_ADDR
// PlaceHumanInUnit ( Kozlov , FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_lab_full ] ] ) [ 1 ] ) ;
4313: LD_EXP 58
4317: PPUSH
4318: LD_INT 22
4320: PUSH
4321: LD_INT 8
4323: PUSH
4324: EMPTY
4325: LIST
4326: LIST
4327: PUSH
4328: LD_INT 23
4330: PUSH
4331: LD_INT 3
4333: PUSH
4334: EMPTY
4335: LIST
4336: LIST
4337: PUSH
4338: LD_INT 30
4340: PUSH
4341: LD_INT 8
4343: PUSH
4344: EMPTY
4345: LIST
4346: LIST
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: LIST
4352: PPUSH
4353: CALL_OW 69
4357: PUSH
4358: LD_INT 1
4360: ARRAY
4361: PPUSH
4362: CALL_OW 52
// SetSkill ( Kozlov , class_mechanic , 10 ) ;
4366: LD_EXP 58
4370: PPUSH
4371: LD_INT 3
4373: PPUSH
4374: LD_INT 10
4376: PPUSH
4377: CALL_OW 237
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
4381: LD_ADDR_VAR 0 5
4385: PUSH
4386: LD_INT 22
4388: PUSH
4389: LD_VAR 0 3
4393: PUSH
4394: EMPTY
4395: LIST
4396: LIST
4397: PUSH
4398: LD_INT 30
4400: PUSH
4401: LD_INT 32
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 58
4410: PUSH
4411: EMPTY
4412: LIST
4413: PUSH
4414: EMPTY
4415: LIST
4416: LIST
4417: LIST
4418: PPUSH
4419: CALL_OW 69
4423: ST_TO_ADDR
// for i = 1 to 10 do
4424: LD_ADDR_VAR 0 2
4428: PUSH
4429: DOUBLE
4430: LD_INT 1
4432: DEC
4433: ST_TO_ADDR
4434: LD_INT 10
4436: PUSH
4437: FOR_TO
4438: IFFALSE 4510
// begin uc_nation := nation_nature ;
4440: LD_ADDR_OWVAR 21
4444: PUSH
4445: LD_INT 0
4447: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
4448: LD_ADDR_OWVAR 28
4452: PUSH
4453: LD_INT 15
4455: ST_TO_ADDR
// hc_gallery :=  ;
4456: LD_ADDR_OWVAR 33
4460: PUSH
4461: LD_STRING 
4463: ST_TO_ADDR
// hc_name :=  ;
4464: LD_ADDR_OWVAR 26
4468: PUSH
4469: LD_STRING 
4471: ST_TO_ADDR
// un := CreateHuman ;
4472: LD_ADDR_VAR 0 4
4476: PUSH
4477: CALL_OW 44
4481: ST_TO_ADDR
// PlaceHumanInUnit ( un , tmp [ tmp - i ] ) ;
4482: LD_VAR 0 4
4486: PPUSH
4487: LD_VAR 0 5
4491: PUSH
4492: LD_VAR 0 5
4496: PUSH
4497: LD_VAR 0 2
4501: MINUS
4502: ARRAY
4503: PPUSH
4504: CALL_OW 52
// end ;
4508: GO 4437
4510: POP
4511: POP
// tmp := CreateCharacterSet ( 12_kurt_squad ) ;
4512: LD_ADDR_VAR 0 5
4516: PUSH
4517: LD_STRING 12_kurt_squad
4519: PPUSH
4520: CALL_OW 31
4524: ST_TO_ADDR
// if tmp then
4525: LD_VAR 0 5
4529: IFFALSE 4563
// for i in tmp do
4531: LD_ADDR_VAR 0 2
4535: PUSH
4536: LD_VAR 0 5
4540: PUSH
4541: FOR_IN
4542: IFFALSE 4561
// PlaceUnitArea ( i , legionBaseArea , false ) ;
4544: LD_VAR 0 2
4548: PPUSH
4549: LD_INT 5
4551: PPUSH
4552: LD_INT 0
4554: PPUSH
4555: CALL_OW 49
4559: GO 4541
4561: POP
4562: POP
// PrepareBase ( ar_depot1 , legionBaseArea ,  , [ 8 , 9 , 10 ] [ Difficulty ] , [ 3000 , 500 , 150 ] , [ 16 , 6 , 6 , 8 ] ) ;
4563: LD_INT 324
4565: PPUSH
4566: LD_INT 5
4568: PPUSH
4569: LD_STRING 
4571: PPUSH
4572: LD_INT 8
4574: PUSH
4575: LD_INT 9
4577: PUSH
4578: LD_INT 10
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: LIST
4585: PUSH
4586: LD_OWVAR 67
4590: ARRAY
4591: PPUSH
4592: LD_INT 3000
4594: PUSH
4595: LD_INT 500
4597: PUSH
4598: LD_INT 150
4600: PUSH
4601: EMPTY
4602: LIST
4603: LIST
4604: LIST
4605: PPUSH
4606: LD_INT 16
4608: PUSH
4609: LD_INT 6
4611: PUSH
4612: LD_INT 6
4614: PUSH
4615: LD_INT 8
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: LIST
4623: PPUSH
4624: CALL 74496 0 6
// mc_bases := Replace ( mc_bases , 3 , FilterAllUnits ( [ [ f_side , side ] , [ f_nation , 2 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Kurt ) ;
4628: LD_ADDR_EXP 99
4632: PUSH
4633: LD_EXP 99
4637: PPUSH
4638: LD_INT 3
4640: PPUSH
4641: LD_INT 22
4643: PUSH
4644: LD_VAR 0 3
4648: PUSH
4649: EMPTY
4650: LIST
4651: LIST
4652: PUSH
4653: LD_INT 23
4655: PUSH
4656: LD_INT 2
4658: PUSH
4659: EMPTY
4660: LIST
4661: LIST
4662: PUSH
4663: LD_INT 3
4665: PUSH
4666: LD_INT 21
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PUSH
4676: EMPTY
4677: LIST
4678: LIST
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: LIST
4684: PPUSH
4685: CALL_OW 69
4689: PUSH
4690: LD_EXP 57
4694: DIFF
4695: PPUSH
4696: CALL_OW 1
4700: ST_TO_ADDR
// PrepareMechanic ( sex_male , 7 ) ;
4701: LD_INT 1
4703: PPUSH
4704: LD_INT 7
4706: PPUSH
4707: CALL_OW 383
// Friend := CreateHuman ;
4711: LD_ADDR_EXP 59
4715: PUSH
4716: CALL_OW 44
4720: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_selfpropelled_bomb , 100 ) ;
4721: LD_INT 14
4723: PPUSH
4724: LD_INT 3
4726: PPUSH
4727: LD_INT 1
4729: PPUSH
4730: LD_INT 29
4732: PPUSH
4733: LD_INT 100
4735: PPUSH
4736: CALL 71087 0 5
// powellBomb := CreateVehicle ;
4740: LD_ADDR_EXP 60
4744: PUSH
4745: CALL_OW 45
4749: ST_TO_ADDR
// PlaceUnitXY ( powellBomb , 90 , 51 , false ) ;
4750: LD_EXP 60
4754: PPUSH
4755: LD_INT 90
4757: PPUSH
4758: LD_INT 51
4760: PPUSH
4761: LD_INT 0
4763: PPUSH
4764: CALL_OW 48
// end ;
4768: LD_VAR 0 1
4772: RET
// export function RebuildKozlovFactory ; var fac , lab ; begin
4773: LD_INT 0
4775: PPUSH
4776: PPUSH
4777: PPUSH
// if IsLive ( kozlov_fac ) then
4778: LD_INT 332
4780: PPUSH
4781: CALL_OW 300
4785: IFFALSE 4789
// exit ;
4787: GO 5356
// ComExitBuilding ( Kozlov ) ;
4789: LD_EXP 58
4793: PPUSH
4794: CALL_OW 122
// if GetClass ( Kozlov ) <> 2 then
4798: LD_EXP 58
4802: PPUSH
4803: CALL_OW 257
4807: PUSH
4808: LD_INT 2
4810: NONEQUAL
4811: IFFALSE 4846
// begin AddComEnterUnit ( Kozlov , ar_depot1 ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 324
4820: PPUSH
4821: CALL_OW 180
// AddComChangeProfession ( Kozlov , class_engineer ) ;
4825: LD_EXP 58
4829: PPUSH
4830: LD_INT 2
4832: PPUSH
4833: CALL_OW 183
// AddComExitBuilding ( Kozlov ) ;
4837: LD_EXP 58
4841: PPUSH
4842: CALL_OW 182
// end ; AddComBuild ( Kozlov , b_workshop , 93 , 32 , 3 ) ;
4846: LD_EXP 58
4850: PPUSH
4851: LD_INT 2
4853: PPUSH
4854: LD_INT 93
4856: PPUSH
4857: LD_INT 32
4859: PPUSH
4860: LD_INT 3
4862: PPUSH
4863: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
4867: LD_INT 35
4869: PPUSH
4870: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) ;
4874: LD_INT 22
4876: PUSH
4877: LD_INT 8
4879: PUSH
4880: EMPTY
4881: LIST
4882: LIST
4883: PUSH
4884: LD_INT 30
4886: PUSH
4887: LD_INT 3
4889: PUSH
4890: EMPTY
4891: LIST
4892: LIST
4893: PUSH
4894: LD_INT 23
4896: PUSH
4897: LD_INT 3
4899: PUSH
4900: EMPTY
4901: LIST
4902: LIST
4903: PUSH
4904: LD_INT 57
4906: PUSH
4907: EMPTY
4908: LIST
4909: PUSH
4910: EMPTY
4911: LIST
4912: LIST
4913: LIST
4914: LIST
4915: PPUSH
4916: CALL_OW 69
4920: IFFALSE 4867
// fac := FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] , [ f_nation , 3 ] , [ f_constructed ] ] ) [ 1 ] ;
4922: LD_ADDR_VAR 0 2
4926: PUSH
4927: LD_INT 22
4929: PUSH
4930: LD_INT 8
4932: PUSH
4933: EMPTY
4934: LIST
4935: LIST
4936: PUSH
4937: LD_INT 30
4939: PUSH
4940: LD_INT 3
4942: PUSH
4943: EMPTY
4944: LIST
4945: LIST
4946: PUSH
4947: LD_INT 23
4949: PUSH
4950: LD_INT 3
4952: PUSH
4953: EMPTY
4954: LIST
4955: LIST
4956: PUSH
4957: LD_INT 57
4959: PUSH
4960: EMPTY
4961: LIST
4962: PUSH
4963: EMPTY
4964: LIST
4965: LIST
4966: LIST
4967: LIST
4968: PPUSH
4969: CALL_OW 69
4973: PUSH
4974: LD_INT 1
4976: ARRAY
4977: ST_TO_ADDR
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] ] ) then
4978: LD_INT 22
4980: PUSH
4981: LD_INT 8
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 23
4990: PUSH
4991: LD_INT 3
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 30
5000: PUSH
5001: LD_INT 21
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: PPUSH
5013: CALL_OW 69
5017: NOT
5018: IFFALSE 5096
// begin AddComBuild ( Kozlov , b_ext_siberium , 97 , 36 , 5 ) ;
5020: LD_EXP 58
5024: PPUSH
5025: LD_INT 21
5027: PPUSH
5028: LD_INT 97
5030: PPUSH
5031: LD_INT 36
5033: PPUSH
5034: LD_INT 5
5036: PPUSH
5037: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5041: LD_INT 35
5043: PPUSH
5044: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_siberium ] , [ f_constructed ] ] ) ;
5048: LD_INT 22
5050: PUSH
5051: LD_INT 8
5053: PUSH
5054: EMPTY
5055: LIST
5056: LIST
5057: PUSH
5058: LD_INT 23
5060: PUSH
5061: LD_INT 3
5063: PUSH
5064: EMPTY
5065: LIST
5066: LIST
5067: PUSH
5068: LD_INT 30
5070: PUSH
5071: LD_INT 21
5073: PUSH
5074: EMPTY
5075: LIST
5076: LIST
5077: PUSH
5078: LD_INT 57
5080: PUSH
5081: EMPTY
5082: LIST
5083: PUSH
5084: EMPTY
5085: LIST
5086: LIST
5087: LIST
5088: LIST
5089: PPUSH
5090: CALL_OW 69
5094: IFFALSE 5041
// end ; if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] ] ) then
5096: LD_INT 22
5098: PUSH
5099: LD_INT 8
5101: PUSH
5102: EMPTY
5103: LIST
5104: LIST
5105: PUSH
5106: LD_INT 23
5108: PUSH
5109: LD_INT 3
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_INT 30
5118: PUSH
5119: LD_INT 18
5121: PUSH
5122: EMPTY
5123: LIST
5124: LIST
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: LIST
5130: PPUSH
5131: CALL_OW 69
5135: NOT
5136: IFFALSE 5214
// begin AddComBuild ( Kozlov , b_ext_rocket , 89 , 32 , 1 ) ;
5138: LD_EXP 58
5142: PPUSH
5143: LD_INT 18
5145: PPUSH
5146: LD_INT 89
5148: PPUSH
5149: LD_INT 32
5151: PPUSH
5152: LD_INT 1
5154: PPUSH
5155: CALL_OW 205
// repeat wait ( 0 0$1 ) ;
5159: LD_INT 35
5161: PPUSH
5162: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 3 ] , [ f_btype , b_ext_rocket ] , [ f_constructed ] ] ) ;
5166: LD_INT 22
5168: PUSH
5169: LD_INT 8
5171: PUSH
5172: EMPTY
5173: LIST
5174: LIST
5175: PUSH
5176: LD_INT 23
5178: PUSH
5179: LD_INT 3
5181: PUSH
5182: EMPTY
5183: LIST
5184: LIST
5185: PUSH
5186: LD_INT 30
5188: PUSH
5189: LD_INT 18
5191: PUSH
5192: EMPTY
5193: LIST
5194: LIST
5195: PUSH
5196: LD_INT 57
5198: PUSH
5199: EMPTY
5200: LIST
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: LIST
5206: LIST
5207: PPUSH
5208: CALL_OW 69
5212: IFFALSE 5159
// end ; lab := kozlov_lab ;
5214: LD_ADDR_VAR 0 3
5218: PUSH
5219: LD_INT 336
5221: ST_TO_ADDR
// if not lab then
5222: LD_VAR 0 3
5226: NOT
5227: IFFALSE 5231
// exit ;
5229: GO 5356
// AddComEnterUnit ( Kozlov , lab [ 1 ] ) ;
5231: LD_EXP 58
5235: PPUSH
5236: LD_VAR 0 3
5240: PUSH
5241: LD_INT 1
5243: ARRAY
5244: PPUSH
5245: CALL_OW 180
// AddComChangeProfession ( Kozlov , 4 ) ;
5249: LD_EXP 58
5253: PPUSH
5254: LD_INT 4
5256: PPUSH
5257: CALL_OW 183
// ComResearch ( lab [ 1 ] , tech_sibFiss ) ;
5261: LD_VAR 0 3
5265: PUSH
5266: LD_INT 1
5268: ARRAY
5269: PPUSH
5270: LD_INT 25
5272: PPUSH
5273: CALL_OW 124
// repeat wait ( 0 0$1 ) ;
5277: LD_INT 35
5279: PPUSH
5280: CALL_OW 67
// until GetTech ( tech_sibFiss , 8 ) = state_researched ;
5284: LD_INT 25
5286: PPUSH
5287: LD_INT 8
5289: PPUSH
5290: CALL_OW 321
5294: PUSH
5295: LD_INT 2
5297: EQUAL
5298: IFFALSE 5277
// ComExitBuilding ( Kozlov ) ;
5300: LD_EXP 58
5304: PPUSH
5305: CALL_OW 122
// AddComEnterUnit ( Kozlov , fac ) ;
5309: LD_EXP 58
5313: PPUSH
5314: LD_VAR 0 2
5318: PPUSH
5319: CALL_OW 180
// AddComChangeProfession ( Kozlov , 3 ) ;
5323: LD_EXP 58
5327: PPUSH
5328: LD_INT 3
5330: PPUSH
5331: CALL_OW 183
// ComConstruct ( fac , ru_heavy_wheeled , engine_siberite , control_manual , ru_siberium_rocket ) ;
5335: LD_VAR 0 2
5339: PPUSH
5340: LD_INT 23
5342: PPUSH
5343: LD_INT 3
5345: PPUSH
5346: LD_INT 1
5348: PPUSH
5349: LD_INT 48
5351: PPUSH
5352: CALL_OW 125
// end ;
5356: LD_VAR 0 1
5360: RET
// every 0 0$10 trigger not legionDestroyed and missionStage >= 6 do
5361: LD_EXP 22
5365: NOT
5366: PUSH
5367: LD_EXP 15
5371: PUSH
5372: LD_INT 6
5374: GREATEREQUAL
5375: AND
5376: IFFALSE 5457
5378: GO 5380
5380: DISABLE
// begin MC_SetDefenderLimit ( 3 , 3 ) ;
5381: LD_INT 3
5383: PPUSH
5384: LD_INT 3
5386: PPUSH
5387: CALL 57854 0 2
// MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_manual , ar_rocket_launcher ] ] ) ;
5391: LD_INT 3
5393: PPUSH
5394: LD_INT 14
5396: PUSH
5397: LD_INT 1
5399: PUSH
5400: LD_INT 1
5402: PUSH
5403: LD_INT 28
5405: PUSH
5406: EMPTY
5407: LIST
5408: LIST
5409: LIST
5410: LIST
5411: PUSH
5412: LD_INT 14
5414: PUSH
5415: LD_INT 1
5417: PUSH
5418: LD_INT 1
5420: PUSH
5421: LD_INT 28
5423: PUSH
5424: EMPTY
5425: LIST
5426: LIST
5427: LIST
5428: LIST
5429: PUSH
5430: LD_INT 14
5432: PUSH
5433: LD_INT 1
5435: PUSH
5436: LD_INT 1
5438: PUSH
5439: LD_INT 28
5441: PUSH
5442: EMPTY
5443: LIST
5444: LIST
5445: LIST
5446: LIST
5447: PUSH
5448: EMPTY
5449: LIST
5450: LIST
5451: LIST
5452: PPUSH
5453: CALL 57717 0 2
// end ;
5457: END
// every 7 7$30 trigger not legionDestroyed and missionStage >= 6 and not MC_GetVehicles ( 3 , true ) do var i , tmp , target ;
5458: LD_EXP 22
5462: NOT
5463: PUSH
5464: LD_EXP 15
5468: PUSH
5469: LD_INT 6
5471: GREATEREQUAL
5472: AND
5473: PUSH
5474: LD_INT 3
5476: PPUSH
5477: LD_INT 1
5479: PPUSH
5480: CALL 59135 0 2
5484: NOT
5485: AND
5486: IFFALSE 6326
5488: GO 5490
5490: DISABLE
5491: LD_INT 0
5493: PPUSH
5494: PPUSH
5495: PPUSH
// begin enable ;
5496: ENABLE
// if not FilterAllUnits ( [ [ f_side , 8 ] , [ f_nation , 2 ] , [ f_btype , b_factory ] ] ) then
5497: LD_INT 22
5499: PUSH
5500: LD_INT 8
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: PUSH
5507: LD_INT 23
5509: PUSH
5510: LD_INT 2
5512: PUSH
5513: EMPTY
5514: LIST
5515: LIST
5516: PUSH
5517: LD_INT 30
5519: PUSH
5520: LD_INT 3
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: PUSH
5527: EMPTY
5528: LIST
5529: LIST
5530: LIST
5531: PPUSH
5532: CALL_OW 69
5536: NOT
5537: IFFALSE 5541
// exit ;
5539: GO 6326
// if Prob ( 40 ) then
5541: LD_INT 40
5543: PPUSH
5544: CALL_OW 13
5548: IFFALSE 5675
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5550: LD_INT 3
5552: PPUSH
5553: LD_INT 14
5555: PUSH
5556: LD_INT 1
5558: PUSH
5559: LD_INT 2
5561: PUSH
5562: LD_INT 28
5564: PUSH
5565: EMPTY
5566: LIST
5567: LIST
5568: LIST
5569: LIST
5570: PUSH
5571: LD_INT 14
5573: PUSH
5574: LD_INT 1
5576: PUSH
5577: LD_INT 2
5579: PUSH
5580: LD_INT 28
5582: PUSH
5583: EMPTY
5584: LIST
5585: LIST
5586: LIST
5587: LIST
5588: PUSH
5589: LD_INT 14
5591: PUSH
5592: LD_INT 1
5594: PUSH
5595: LD_INT 2
5597: PUSH
5598: LD_INT 28
5600: PUSH
5601: EMPTY
5602: LIST
5603: LIST
5604: LIST
5605: LIST
5606: PUSH
5607: LD_INT 14
5609: PUSH
5610: LD_INT 1
5612: PUSH
5613: LD_INT 2
5615: PUSH
5616: LD_INT 28
5618: PUSH
5619: EMPTY
5620: LIST
5621: LIST
5622: LIST
5623: LIST
5624: PUSH
5625: LD_INT 14
5627: PUSH
5628: LD_INT 1
5630: PUSH
5631: LD_INT 2
5633: PUSH
5634: LD_INT 28
5636: PUSH
5637: EMPTY
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: PUSH
5643: LD_INT 14
5645: PUSH
5646: LD_INT 1
5648: PUSH
5649: LD_INT 2
5651: PUSH
5652: LD_INT 26
5654: PUSH
5655: EMPTY
5656: LIST
5657: LIST
5658: LIST
5659: LIST
5660: PUSH
5661: EMPTY
5662: LIST
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: LIST
5668: PPUSH
5669: CALL 57717 0 2
// end else
5673: GO 5866
// begin MC_InsertProduceList ( 3 , [ [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gun , ar_flame_thrower , ar_flame_thrower ] [ Difficulty ] ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_flame_thrower , ar_flame_thrower , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , [ ar_flame_thrower , ar_selfpropelled_bomb , ar_selfpropelled_bomb ] [ Difficulty ] ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , ] ) ;
5675: LD_INT 3
5677: PPUSH
5678: LD_INT 14
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 27
5689: PUSH
5690: LD_INT 26
5692: PUSH
5693: LD_INT 26
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: PUSH
5701: LD_OWVAR 67
5705: ARRAY
5706: PUSH
5707: EMPTY
5708: LIST
5709: LIST
5710: LIST
5711: LIST
5712: PUSH
5713: LD_INT 14
5715: PUSH
5716: LD_INT 1
5718: PUSH
5719: LD_INT 2
5721: PUSH
5722: LD_INT 27
5724: PUSH
5725: LD_INT 26
5727: PUSH
5728: LD_INT 26
5730: PUSH
5731: EMPTY
5732: LIST
5733: LIST
5734: LIST
5735: PUSH
5736: LD_OWVAR 67
5740: ARRAY
5741: PUSH
5742: EMPTY
5743: LIST
5744: LIST
5745: LIST
5746: LIST
5747: PUSH
5748: LD_INT 14
5750: PUSH
5751: LD_INT 1
5753: PUSH
5754: LD_INT 2
5756: PUSH
5757: LD_INT 26
5759: PUSH
5760: LD_INT 26
5762: PUSH
5763: LD_INT 29
5765: PUSH
5766: EMPTY
5767: LIST
5768: LIST
5769: LIST
5770: PUSH
5771: LD_OWVAR 67
5775: ARRAY
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: LIST
5781: LIST
5782: PUSH
5783: LD_INT 13
5785: PUSH
5786: LD_INT 1
5788: PUSH
5789: LD_INT 2
5791: PUSH
5792: LD_INT 26
5794: PUSH
5795: LD_INT 29
5797: PUSH
5798: LD_INT 29
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: PUSH
5806: LD_OWVAR 67
5810: ARRAY
5811: PUSH
5812: EMPTY
5813: LIST
5814: LIST
5815: LIST
5816: LIST
5817: PUSH
5818: LD_INT 13
5820: PUSH
5821: LD_INT 1
5823: PUSH
5824: LD_INT 2
5826: PUSH
5827: LD_INT 29
5829: PUSH
5830: EMPTY
5831: LIST
5832: LIST
5833: LIST
5834: LIST
5835: PUSH
5836: LD_INT 14
5838: PUSH
5839: LD_INT 1
5841: PUSH
5842: LD_INT 2
5844: PUSH
5845: LD_INT 26
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: LIST
5852: LIST
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: LIST
5858: LIST
5859: LIST
5860: LIST
5861: PPUSH
5862: CALL 57717 0 2
// end ; repeat wait ( 0 0$1 ) ;
5866: LD_INT 35
5868: PPUSH
5869: CALL_OW 67
// until MC_GetVehicles ( 3 , true ) >= 6 ;
5873: LD_INT 3
5875: PPUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 59135 0 2
5883: PUSH
5884: LD_INT 6
5886: GREATEREQUAL
5887: IFFALSE 5866
// wait ( 0 0$30 ) ;
5889: LD_INT 1050
5891: PPUSH
5892: CALL_OW 67
// tmp := MC_GetVehicles ( 3 , true ) ;
5896: LD_ADDR_VAR 0 2
5900: PUSH
5901: LD_INT 3
5903: PPUSH
5904: LD_INT 1
5906: PPUSH
5907: CALL 59135 0 2
5911: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 3 , mc_vehicles [ 3 ] diff tmp ) ;
5912: LD_ADDR_EXP 118
5916: PUSH
5917: LD_EXP 118
5921: PPUSH
5922: LD_INT 3
5924: PPUSH
5925: LD_EXP 118
5929: PUSH
5930: LD_INT 3
5932: ARRAY
5933: PUSH
5934: LD_VAR 0 2
5938: DIFF
5939: PPUSH
5940: CALL_OW 1
5944: ST_TO_ADDR
// target := rand ( 0 , 2 ) ;
5945: LD_ADDR_VAR 0 3
5949: PUSH
5950: LD_INT 0
5952: PPUSH
5953: LD_INT 2
5955: PPUSH
5956: CALL_OW 12
5960: ST_TO_ADDR
// if target then
5961: LD_VAR 0 3
5965: IFFALSE 6093
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
5967: LD_ADDR_VAR 0 2
5971: PUSH
5972: LD_VAR 0 2
5976: PPUSH
5977: LD_INT 24
5979: PUSH
5980: LD_INT 250
5982: PUSH
5983: EMPTY
5984: LIST
5985: LIST
5986: PPUSH
5987: CALL_OW 72
5991: ST_TO_ADDR
// for i in tmp do
5992: LD_ADDR_VAR 0 1
5996: PUSH
5997: LD_VAR 0 2
6001: PUSH
6002: FOR_IN
6003: IFFALSE 6043
// if GetDistUnitXY ( i , 89 , 71 ) > 9 then
6005: LD_VAR 0 1
6009: PPUSH
6010: LD_INT 89
6012: PPUSH
6013: LD_INT 71
6015: PPUSH
6016: CALL_OW 297
6020: PUSH
6021: LD_INT 9
6023: GREATER
6024: IFFALSE 6041
// ComMoveXY ( i , 89 , 71 ) ;
6026: LD_VAR 0 1
6030: PPUSH
6031: LD_INT 89
6033: PPUSH
6034: LD_INT 71
6036: PPUSH
6037: CALL_OW 111
6041: GO 6002
6043: POP
6044: POP
// wait ( 0 0$1 ) ;
6045: LD_INT 35
6047: PPUSH
6048: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 89 , 71 , 9 ] ) >= ( tmp - 1 ) ;
6052: LD_VAR 0 2
6056: PPUSH
6057: LD_INT 92
6059: PUSH
6060: LD_INT 89
6062: PUSH
6063: LD_INT 71
6065: PUSH
6066: LD_INT 9
6068: PUSH
6069: EMPTY
6070: LIST
6071: LIST
6072: LIST
6073: LIST
6074: PPUSH
6075: CALL_OW 72
6079: PUSH
6080: LD_VAR 0 2
6084: PUSH
6085: LD_INT 1
6087: MINUS
6088: GREATEREQUAL
6089: IFFALSE 5967
// end else
6091: GO 6217
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
6093: LD_ADDR_VAR 0 2
6097: PUSH
6098: LD_VAR 0 2
6102: PPUSH
6103: LD_INT 24
6105: PUSH
6106: LD_INT 250
6108: PUSH
6109: EMPTY
6110: LIST
6111: LIST
6112: PPUSH
6113: CALL_OW 72
6117: ST_TO_ADDR
// for i in tmp do
6118: LD_ADDR_VAR 0 1
6122: PUSH
6123: LD_VAR 0 2
6127: PUSH
6128: FOR_IN
6129: IFFALSE 6169
// if GetDistUnitXY ( i , 125 , 129 ) > 9 then
6131: LD_VAR 0 1
6135: PPUSH
6136: LD_INT 125
6138: PPUSH
6139: LD_INT 129
6141: PPUSH
6142: CALL_OW 297
6146: PUSH
6147: LD_INT 9
6149: GREATER
6150: IFFALSE 6167
// ComMoveXY ( i , 125 , 129 ) ;
6152: LD_VAR 0 1
6156: PPUSH
6157: LD_INT 125
6159: PPUSH
6160: LD_INT 129
6162: PPUSH
6163: CALL_OW 111
6167: GO 6128
6169: POP
6170: POP
// wait ( 0 0$1 ) ;
6171: LD_INT 35
6173: PPUSH
6174: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 125 , 129 , 9 ] ) >= ( tmp - 1 ) ;
6178: LD_VAR 0 2
6182: PPUSH
6183: LD_INT 92
6185: PUSH
6186: LD_INT 125
6188: PUSH
6189: LD_INT 129
6191: PUSH
6192: LD_INT 9
6194: PUSH
6195: EMPTY
6196: LIST
6197: LIST
6198: LIST
6199: LIST
6200: PPUSH
6201: CALL_OW 72
6205: PUSH
6206: LD_VAR 0 2
6210: PUSH
6211: LD_INT 1
6213: MINUS
6214: GREATEREQUAL
6215: IFFALSE 6093
// end ; repeat wait ( 0 0$1 ) ;
6217: LD_INT 35
6219: PPUSH
6220: CALL_OW 67
// for i in tmp do
6224: LD_ADDR_VAR 0 1
6228: PUSH
6229: LD_VAR 0 2
6233: PUSH
6234: FOR_IN
6235: IFFALSE 6317
// begin if GetLives ( i ) > 251 then
6237: LD_VAR 0 1
6241: PPUSH
6242: CALL_OW 256
6246: PUSH
6247: LD_INT 251
6249: GREATER
6250: IFFALSE 6288
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) else
6252: LD_VAR 0 1
6256: PPUSH
6257: LD_INT 81
6259: PUSH
6260: LD_INT 8
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: PPUSH
6267: CALL_OW 69
6271: PPUSH
6272: LD_VAR 0 1
6276: PPUSH
6277: CALL_OW 74
6281: PPUSH
6282: CALL_OW 115
6286: GO 6315
// if IsDead ( i ) then
6288: LD_VAR 0 1
6292: PPUSH
6293: CALL_OW 301
6297: IFFALSE 6315
// tmp := tmp diff i ;
6299: LD_ADDR_VAR 0 2
6303: PUSH
6304: LD_VAR 0 2
6308: PUSH
6309: LD_VAR 0 1
6313: DIFF
6314: ST_TO_ADDR
// end ;
6315: GO 6234
6317: POP
6318: POP
// until not tmp ;
6319: LD_VAR 0 2
6323: NOT
6324: IFFALSE 6217
// end ;
6326: PPOPN 3
6328: END
// every 20 20$00 trigger not legionDestroyed and missionStage >= 6 and Difficulty > 1 do var i , un , tmp ;
6329: LD_EXP 22
6333: NOT
6334: PUSH
6335: LD_EXP 15
6339: PUSH
6340: LD_INT 6
6342: GREATEREQUAL
6343: AND
6344: PUSH
6345: LD_OWVAR 67
6349: PUSH
6350: LD_INT 1
6352: GREATER
6353: AND
6354: IFFALSE 6871
6356: GO 6358
6358: DISABLE
6359: LD_INT 0
6361: PPUSH
6362: PPUSH
6363: PPUSH
// begin enable ;
6364: ENABLE
// tmp := [ ] ;
6365: LD_ADDR_VAR 0 3
6369: PUSH
6370: EMPTY
6371: ST_TO_ADDR
// for i = 1 to [ 4 , 6 , 7 ] [ Difficulty ] do
6372: LD_ADDR_VAR 0 1
6376: PUSH
6377: DOUBLE
6378: LD_INT 1
6380: DEC
6381: ST_TO_ADDR
6382: LD_INT 4
6384: PUSH
6385: LD_INT 6
6387: PUSH
6388: LD_INT 7
6390: PUSH
6391: EMPTY
6392: LIST
6393: LIST
6394: LIST
6395: PUSH
6396: LD_OWVAR 67
6400: ARRAY
6401: PUSH
6402: FOR_TO
6403: IFFALSE 6563
// begin uc_side := 8 ;
6405: LD_ADDR_OWVAR 20
6409: PUSH
6410: LD_INT 8
6412: ST_TO_ADDR
// uc_nation := 2 ;
6413: LD_ADDR_OWVAR 21
6417: PUSH
6418: LD_INT 2
6420: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_apeman , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_gatling_gun ] [ rand ( 1 , 4 ) ] , 88 ) ;
6421: LD_INT 13
6423: PUSH
6424: LD_INT 14
6426: PUSH
6427: EMPTY
6428: LIST
6429: LIST
6430: PUSH
6431: LD_INT 1
6433: PPUSH
6434: LD_INT 2
6436: PPUSH
6437: CALL_OW 12
6441: ARRAY
6442: PPUSH
6443: LD_INT 1
6445: PPUSH
6446: LD_INT 5
6448: PPUSH
6449: LD_INT 27
6451: PUSH
6452: LD_INT 28
6454: PUSH
6455: LD_INT 26
6457: PUSH
6458: LD_INT 25
6460: PUSH
6461: EMPTY
6462: LIST
6463: LIST
6464: LIST
6465: LIST
6466: PUSH
6467: LD_INT 1
6469: PPUSH
6470: LD_INT 4
6472: PPUSH
6473: CALL_OW 12
6477: ARRAY
6478: PPUSH
6479: LD_INT 88
6481: PPUSH
6482: CALL 71087 0 5
// un := CreateVehicle ;
6486: LD_ADDR_VAR 0 2
6490: PUSH
6491: CALL_OW 45
6495: ST_TO_ADDR
// tmp := tmp ^ un ;
6496: LD_ADDR_VAR 0 3
6500: PUSH
6501: LD_VAR 0 3
6505: PUSH
6506: LD_VAR 0 2
6510: ADD
6511: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6512: LD_VAR 0 2
6516: PPUSH
6517: LD_INT 3
6519: PPUSH
6520: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6524: LD_VAR 0 2
6528: PPUSH
6529: LD_INT 30
6531: PPUSH
6532: LD_INT 0
6534: PPUSH
6535: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6539: LD_VAR 0 2
6543: PPUSH
6544: LD_INT 16
6546: PPUSH
6547: LD_INT 11
6549: PPUSH
6550: CALL_OW 111
// wait ( 0 0$2 ) ;
6554: LD_INT 70
6556: PPUSH
6557: CALL_OW 67
// end ;
6561: GO 6402
6563: POP
6564: POP
// for i = 1 to Difficulty do
6565: LD_ADDR_VAR 0 1
6569: PUSH
6570: DOUBLE
6571: LD_INT 1
6573: DEC
6574: ST_TO_ADDR
6575: LD_OWVAR 67
6579: PUSH
6580: FOR_TO
6581: IFFALSE 6706
// begin uc_side := 8 ;
6583: LD_ADDR_OWVAR 20
6587: PUSH
6588: LD_INT 8
6590: ST_TO_ADDR
// uc_nation := 2 ;
6591: LD_ADDR_OWVAR 21
6595: PUSH
6596: LD_INT 2
6598: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , [ 8 , 8 , 9 ] [ Difficulty ] ) ;
6599: LD_INT 0
6601: PPUSH
6602: LD_INT 8
6604: PPUSH
6605: LD_INT 8
6607: PUSH
6608: LD_INT 8
6610: PUSH
6611: LD_INT 9
6613: PUSH
6614: EMPTY
6615: LIST
6616: LIST
6617: LIST
6618: PUSH
6619: LD_OWVAR 67
6623: ARRAY
6624: PPUSH
6625: CALL_OW 380
// un := CreateHuman ;
6629: LD_ADDR_VAR 0 2
6633: PUSH
6634: CALL_OW 44
6638: ST_TO_ADDR
// tmp := tmp ^ un ;
6639: LD_ADDR_VAR 0 3
6643: PUSH
6644: LD_VAR 0 3
6648: PUSH
6649: LD_VAR 0 2
6653: ADD
6654: ST_TO_ADDR
// SetDir ( un , 3 ) ;
6655: LD_VAR 0 2
6659: PPUSH
6660: LD_INT 3
6662: PPUSH
6663: CALL_OW 233
// PlaceUnitArea ( un , northSpawn , false ) ;
6667: LD_VAR 0 2
6671: PPUSH
6672: LD_INT 30
6674: PPUSH
6675: LD_INT 0
6677: PPUSH
6678: CALL_OW 49
// ComMoveXY ( un , 16 , 11 ) ;
6682: LD_VAR 0 2
6686: PPUSH
6687: LD_INT 16
6689: PPUSH
6690: LD_INT 11
6692: PPUSH
6693: CALL_OW 111
// wait ( 0 0$2 ) ;
6697: LD_INT 70
6699: PPUSH
6700: CALL_OW 67
// end ;
6704: GO 6580
6706: POP
6707: POP
// repeat wait ( 0 0$1 ) ;
6708: LD_INT 35
6710: PPUSH
6711: CALL_OW 67
// for i in tmp do
6715: LD_ADDR_VAR 0 1
6719: PUSH
6720: LD_VAR 0 3
6724: PUSH
6725: FOR_IN
6726: IFFALSE 6862
// begin if GetLives ( i ) > 250 then
6728: LD_VAR 0 1
6732: PPUSH
6733: CALL_OW 256
6737: PUSH
6738: LD_INT 250
6740: GREATER
6741: IFFALSE 6833
// begin if not FilterAllUnits ( [ [ f_enemy , 8 ] , [ f_dist , i , 10 ] ] ) then
6743: LD_INT 81
6745: PUSH
6746: LD_INT 8
6748: PUSH
6749: EMPTY
6750: LIST
6751: LIST
6752: PUSH
6753: LD_INT 91
6755: PUSH
6756: LD_VAR 0 1
6760: PUSH
6761: LD_INT 10
6763: PUSH
6764: EMPTY
6765: LIST
6766: LIST
6767: LIST
6768: PUSH
6769: EMPTY
6770: LIST
6771: LIST
6772: PPUSH
6773: CALL_OW 69
6777: NOT
6778: IFFALSE 6797
// ComAgressiveMove ( i , 67 , 110 ) else
6780: LD_VAR 0 1
6784: PPUSH
6785: LD_INT 67
6787: PPUSH
6788: LD_INT 110
6790: PPUSH
6791: CALL_OW 114
6795: GO 6831
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
6797: LD_VAR 0 1
6801: PPUSH
6802: LD_INT 81
6804: PUSH
6805: LD_INT 8
6807: PUSH
6808: EMPTY
6809: LIST
6810: LIST
6811: PPUSH
6812: CALL_OW 69
6816: PPUSH
6817: LD_VAR 0 1
6821: PPUSH
6822: CALL_OW 74
6826: PPUSH
6827: CALL_OW 115
// end else
6831: GO 6860
// if IsDead ( i ) then
6833: LD_VAR 0 1
6837: PPUSH
6838: CALL_OW 301
6842: IFFALSE 6860
// tmp := tmp diff i ;
6844: LD_ADDR_VAR 0 3
6848: PUSH
6849: LD_VAR 0 3
6853: PUSH
6854: LD_VAR 0 1
6858: DIFF
6859: ST_TO_ADDR
// end ;
6860: GO 6725
6862: POP
6863: POP
// until not tmp ;
6864: LD_VAR 0 3
6868: NOT
6869: IFFALSE 6708
// end ; end_of_file
6871: PPOPN 3
6873: END
// export Platonov , Kovalyuk , Bystrov , Yakotich , Gleb , Bierezov ; export Vsevolod , sewiVeh ; export behemoths , behemothBuilders ; export function PrepareRussian ; var i , j , base , tmp , side , xy , b , teleport ; begin
6874: LD_INT 0
6876: PPUSH
6877: PPUSH
6878: PPUSH
6879: PPUSH
6880: PPUSH
6881: PPUSH
6882: PPUSH
6883: PPUSH
6884: PPUSH
// side := 3 ;
6885: LD_ADDR_VAR 0 6
6889: PUSH
6890: LD_INT 3
6892: ST_TO_ADDR
// uc_side := side ;
6893: LD_ADDR_OWVAR 20
6897: PUSH
6898: LD_VAR 0 6
6902: ST_TO_ADDR
// uc_nation := 3 ;
6903: LD_ADDR_OWVAR 21
6907: PUSH
6908: LD_INT 3
6910: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
6911: LD_ADDR_VAR 0 2
6915: PUSH
6916: LD_INT 22
6918: PUSH
6919: LD_VAR 0 6
6923: PUSH
6924: EMPTY
6925: LIST
6926: LIST
6927: PUSH
6928: LD_INT 21
6930: PUSH
6931: LD_INT 3
6933: PUSH
6934: EMPTY
6935: LIST
6936: LIST
6937: PUSH
6938: EMPTY
6939: LIST
6940: LIST
6941: PPUSH
6942: CALL_OW 69
6946: PUSH
6947: FOR_IN
6948: IFFALSE 6964
// SetBLevel ( i , 10 ) ;
6950: LD_VAR 0 2
6954: PPUSH
6955: LD_INT 10
6957: PPUSH
6958: CALL_OW 241
6962: GO 6947
6964: POP
6965: POP
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
6966: LD_ADDR_VAR 0 9
6970: PUSH
6971: LD_INT 22
6973: PUSH
6974: LD_VAR 0 6
6978: PUSH
6979: EMPTY
6980: LIST
6981: LIST
6982: PUSH
6983: LD_INT 30
6985: PUSH
6986: LD_INT 34
6988: PUSH
6989: EMPTY
6990: LIST
6991: LIST
6992: PUSH
6993: EMPTY
6994: LIST
6995: LIST
6996: PPUSH
6997: CALL_OW 69
7001: ST_TO_ADDR
// if teleport then
7002: LD_VAR 0 9
7006: IFFALSE 7027
// TeleportExit ( teleport [ 1 ] , 123 , 122 ) ;
7008: LD_VAR 0 9
7012: PUSH
7013: LD_INT 1
7015: ARRAY
7016: PPUSH
7017: LD_INT 123
7019: PPUSH
7020: LD_INT 122
7022: PPUSH
7023: CALL_OW 243
// Platonov := NewCharacter ( Platonov ) ;
7027: LD_ADDR_EXP 61
7031: PUSH
7032: LD_STRING Platonov
7034: PPUSH
7035: CALL_OW 25
7039: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
7040: LD_ADDR_EXP 62
7044: PUSH
7045: LD_STRING Kovalyuk
7047: PPUSH
7048: CALL_OW 25
7052: ST_TO_ADDR
// Yakotich := NewCharacter ( Yakotich ) ;
7053: LD_ADDR_EXP 64
7057: PUSH
7058: LD_STRING Yakotich
7060: PPUSH
7061: CALL_OW 25
7065: ST_TO_ADDR
// Bystrov := NewCharacter ( Bystrov ) ;
7066: LD_ADDR_EXP 63
7070: PUSH
7071: LD_STRING Bystrov
7073: PPUSH
7074: CALL_OW 25
7078: ST_TO_ADDR
// Gleb := NewCharacter ( Gleb ) ;
7079: LD_ADDR_EXP 65
7083: PUSH
7084: LD_STRING Gleb
7086: PPUSH
7087: CALL_OW 25
7091: ST_TO_ADDR
// if TestCharacters ( 03_Cornel ) then
7092: LD_STRING 03_Cornel
7094: PPUSH
7095: CALL_OW 28
7099: IFFALSE 7147
// begin Bierezov := NewCharacter ( Mikhail ) ;
7101: LD_ADDR_EXP 66
7105: PUSH
7106: LD_STRING Mikhail
7108: PPUSH
7109: CALL_OW 25
7113: ST_TO_ADDR
// PlaceUnitXYR ( Bierezov , 197 , 111 , 9 , false ) ;
7114: LD_EXP 66
7118: PPUSH
7119: LD_INT 197
7121: PPUSH
7122: LD_INT 111
7124: PPUSH
7125: LD_INT 9
7127: PPUSH
7128: LD_INT 0
7130: PPUSH
7131: CALL_OW 50
// SetClass ( Bierezov , 3 ) ;
7135: LD_EXP 66
7139: PPUSH
7140: LD_INT 3
7142: PPUSH
7143: CALL_OW 336
// end ; PlaceHumanInUnit ( Platonov , ru_depot ) ;
7147: LD_EXP 61
7151: PPUSH
7152: LD_INT 126
7154: PPUSH
7155: CALL_OW 52
// PlaceHumanInUnit ( Kovalyuk , ru_fac1 ) ;
7159: LD_EXP 62
7163: PPUSH
7164: LD_INT 134
7166: PPUSH
7167: CALL_OW 52
// PlaceUnitXYR ( Yakotich , 197 , 111 , 9 , false ) ;
7171: LD_EXP 64
7175: PPUSH
7176: LD_INT 197
7178: PPUSH
7179: LD_INT 111
7181: PPUSH
7182: LD_INT 9
7184: PPUSH
7185: LD_INT 0
7187: PPUSH
7188: CALL_OW 50
// PlaceUnitXYR ( Bystrov , 197 , 111 , 9 , false ) ;
7192: LD_EXP 63
7196: PPUSH
7197: LD_INT 197
7199: PPUSH
7200: LD_INT 111
7202: PPUSH
7203: LD_INT 9
7205: PPUSH
7206: LD_INT 0
7208: PPUSH
7209: CALL_OW 50
// PlaceUnitXYR ( Gleb , 197 , 111 , 9 , false ) ;
7213: LD_EXP 65
7217: PPUSH
7218: LD_INT 197
7220: PPUSH
7221: LD_INT 111
7223: PPUSH
7224: LD_INT 9
7226: PPUSH
7227: LD_INT 0
7229: PPUSH
7230: CALL_OW 50
// tmp := PrepareBase ( ru_depot , russianBaseArea , zhukov , [ 9 , 10 , 10 ] [ Difficulty ] , [ 90000 , 1000 , 300 ] , [ 21 , 8 , 13 , 8 ] ) ;
7234: LD_ADDR_VAR 0 5
7238: PUSH
7239: LD_INT 126
7241: PPUSH
7242: LD_INT 4
7244: PPUSH
7245: LD_STRING zhukov
7247: PPUSH
7248: LD_INT 9
7250: PUSH
7251: LD_INT 10
7253: PUSH
7254: LD_INT 10
7256: PUSH
7257: EMPTY
7258: LIST
7259: LIST
7260: LIST
7261: PUSH
7262: LD_OWVAR 67
7266: ARRAY
7267: PPUSH
7268: LD_INT 90000
7270: PUSH
7271: LD_INT 1000
7273: PUSH
7274: LD_INT 300
7276: PUSH
7277: EMPTY
7278: LIST
7279: LIST
7280: LIST
7281: PPUSH
7282: LD_INT 21
7284: PUSH
7285: LD_INT 8
7287: PUSH
7288: LD_INT 13
7290: PUSH
7291: LD_INT 8
7293: PUSH
7294: EMPTY
7295: LIST
7296: LIST
7297: LIST
7298: LIST
7299: PPUSH
7300: CALL 74496 0 6
7304: ST_TO_ADDR
// base := GetBase ( ru_depot2 ) ;
7305: LD_ADDR_VAR 0 4
7309: PUSH
7310: LD_INT 267
7312: PPUSH
7313: CALL_OW 274
7317: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 5000 ) ;
7318: LD_VAR 0 4
7322: PPUSH
7323: LD_INT 1
7325: PPUSH
7326: LD_INT 5000
7328: PPUSH
7329: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
7333: LD_VAR 0 4
7337: PPUSH
7338: LD_INT 2
7340: PPUSH
7341: LD_INT 200
7343: PPUSH
7344: CALL_OW 277
// SetResourceType ( base , mat_siberit , 200 ) ;
7348: LD_VAR 0 4
7352: PPUSH
7353: LD_INT 3
7355: PPUSH
7356: LD_INT 200
7358: PPUSH
7359: CALL_OW 277
// mc_bases := Replace ( mc_bases , 2 , tmp union FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Platonov ) ;
7363: LD_ADDR_EXP 99
7367: PUSH
7368: LD_EXP 99
7372: PPUSH
7373: LD_INT 2
7375: PPUSH
7376: LD_VAR 0 5
7380: PUSH
7381: LD_INT 22
7383: PUSH
7384: LD_VAR 0 6
7388: PUSH
7389: EMPTY
7390: LIST
7391: LIST
7392: PUSH
7393: LD_INT 3
7395: PUSH
7396: LD_INT 21
7398: PUSH
7399: LD_INT 2
7401: PUSH
7402: EMPTY
7403: LIST
7404: LIST
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: PPUSH
7414: CALL_OW 69
7418: UNION
7419: PUSH
7420: LD_EXP 61
7424: DIFF
7425: PPUSH
7426: CALL_OW 1
7430: ST_TO_ADDR
// behemoths := [ ] ;
7431: LD_ADDR_EXP 69
7435: PUSH
7436: EMPTY
7437: ST_TO_ADDR
// behemothBuilders := [ ] ;
7438: LD_ADDR_EXP 70
7442: PUSH
7443: EMPTY
7444: ST_TO_ADDR
// if Kovalyuk then
7445: LD_EXP 62
7449: IFFALSE 7471
// behemothBuilders := Join ( behemothBuilders , Kovalyuk ) ;
7451: LD_ADDR_EXP 70
7455: PUSH
7456: LD_EXP 70
7460: PPUSH
7461: LD_EXP 62
7465: PPUSH
7466: CALL 106832 0 2
7470: ST_TO_ADDR
// j := 3 ;
7471: LD_ADDR_VAR 0 3
7475: PUSH
7476: LD_INT 3
7478: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_class , 3 ] ] ) diff Kovalyuk do
7479: LD_ADDR_VAR 0 2
7483: PUSH
7484: LD_INT 22
7486: PUSH
7487: LD_INT 3
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 25
7496: PUSH
7497: LD_INT 3
7499: PUSH
7500: EMPTY
7501: LIST
7502: LIST
7503: PUSH
7504: EMPTY
7505: LIST
7506: LIST
7507: PPUSH
7508: CALL_OW 69
7512: PUSH
7513: LD_EXP 62
7517: DIFF
7518: PUSH
7519: FOR_IN
7520: IFFALSE 7570
// begin behemothBuilders := Join ( behemothBuilders , i ) ;
7522: LD_ADDR_EXP 70
7526: PUSH
7527: LD_EXP 70
7531: PPUSH
7532: LD_VAR 0 2
7536: PPUSH
7537: CALL 106832 0 2
7541: ST_TO_ADDR
// j := j - 1 ;
7542: LD_ADDR_VAR 0 3
7546: PUSH
7547: LD_VAR 0 3
7551: PUSH
7552: LD_INT 1
7554: MINUS
7555: ST_TO_ADDR
// if j = 0 then
7556: LD_VAR 0 3
7560: PUSH
7561: LD_INT 0
7563: EQUAL
7564: IFFALSE 7568
// break ;
7566: GO 7570
// end ;
7568: GO 7519
7570: POP
7571: POP
// end ;
7572: LD_VAR 0 1
7576: RET
// export function BuildBehemoths ; var i , j , xy , tmp ; begin
7577: LD_INT 0
7579: PPUSH
7580: PPUSH
7581: PPUSH
7582: PPUSH
7583: PPUSH
// xy := [ [ 209 , 149 ] , [ 219 , 154 ] , [ 223 , 149 ] , [ 232 , 155 ] ] ;
7584: LD_ADDR_VAR 0 4
7588: PUSH
7589: LD_INT 209
7591: PUSH
7592: LD_INT 149
7594: PUSH
7595: EMPTY
7596: LIST
7597: LIST
7598: PUSH
7599: LD_INT 219
7601: PUSH
7602: LD_INT 154
7604: PUSH
7605: EMPTY
7606: LIST
7607: LIST
7608: PUSH
7609: LD_INT 223
7611: PUSH
7612: LD_INT 149
7614: PUSH
7615: EMPTY
7616: LIST
7617: LIST
7618: PUSH
7619: LD_INT 232
7621: PUSH
7622: LD_INT 155
7624: PUSH
7625: EMPTY
7626: LIST
7627: LIST
7628: PUSH
7629: EMPTY
7630: LIST
7631: LIST
7632: LIST
7633: LIST
7634: ST_TO_ADDR
// if not behemothBuilders then
7635: LD_EXP 70
7639: NOT
7640: IFFALSE 7644
// exit ;
7642: GO 7748
// j := 1 ;
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_INT 1
7651: ST_TO_ADDR
// for i in behemothBuilders do
7652: LD_ADDR_VAR 0 2
7656: PUSH
7657: LD_EXP 70
7661: PUSH
7662: FOR_IN
7663: IFFALSE 7746
// begin if IsInUnit ( i ) then
7665: LD_VAR 0 2
7669: PPUSH
7670: CALL_OW 310
7674: IFFALSE 7685
// ComExitBuilding ( i ) ;
7676: LD_VAR 0 2
7680: PPUSH
7681: CALL_OW 122
// AddComBuildBehemoth ( i , b_behemoth , xy [ j ] [ 1 ] , xy [ j ] [ 2 ] , 0 ) ;
7685: LD_VAR 0 2
7689: PPUSH
7690: LD_INT 37
7692: PPUSH
7693: LD_VAR 0 4
7697: PUSH
7698: LD_VAR 0 3
7702: ARRAY
7703: PUSH
7704: LD_INT 1
7706: ARRAY
7707: PPUSH
7708: LD_VAR 0 4
7712: PUSH
7713: LD_VAR 0 3
7717: ARRAY
7718: PUSH
7719: LD_INT 2
7721: ARRAY
7722: PPUSH
7723: LD_INT 0
7725: PPUSH
7726: CALL_OW 230
// j := j + 1 ;
7730: LD_ADDR_VAR 0 3
7734: PUSH
7735: LD_VAR 0 3
7739: PUSH
7740: LD_INT 1
7742: PLUS
7743: ST_TO_ADDR
// end ;
7744: GO 7662
7746: POP
7747: POP
// end ;
7748: LD_VAR 0 1
7752: RET
// every 0 0$1 trigger FilterUnitsInArea ( behemothParking , [ f_btype , b_behemoth ] ) do
7753: LD_INT 24
7755: PPUSH
7756: LD_INT 30
7758: PUSH
7759: LD_INT 37
7761: PUSH
7762: EMPTY
7763: LIST
7764: LIST
7765: PPUSH
7766: CALL_OW 70
7770: IFFALSE 7783
7772: GO 7774
7774: DISABLE
// behemothUnderConstruct := true ;
7775: LD_ADDR_EXP 26
7779: PUSH
7780: LD_INT 1
7782: ST_TO_ADDR
7783: END
// every 0 0$3 trigger GetBehemoths ( 3 ) and not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) do var i , tmp ;
7784: LD_INT 3
7786: PPUSH
7787: CALL 106880 0 1
7791: PUSH
7792: LD_INT 22
7794: PUSH
7795: LD_INT 3
7797: PUSH
7798: EMPTY
7799: LIST
7800: LIST
7801: PUSH
7802: LD_INT 30
7804: PUSH
7805: LD_INT 37
7807: PUSH
7808: EMPTY
7809: LIST
7810: LIST
7811: PUSH
7812: EMPTY
7813: LIST
7814: LIST
7815: PPUSH
7816: CALL_OW 69
7820: NOT
7821: AND
7822: IFFALSE 8008
7824: GO 7826
7826: DISABLE
7827: LD_INT 0
7829: PPUSH
7830: PPUSH
// begin enable ;
7831: ENABLE
// tmp := GetBehemoths ( 3 ) ;
7832: LD_ADDR_VAR 0 2
7836: PUSH
7837: LD_INT 3
7839: PPUSH
7840: CALL 106880 0 1
7844: ST_TO_ADDR
// for i in tmp do
7845: LD_ADDR_VAR 0 1
7849: PUSH
7850: LD_VAR 0 2
7854: PUSH
7855: FOR_IN
7856: IFFALSE 8006
// begin if IsInArea ( i , powellBase ) and not GetTag ( i ) = 2 then
7858: LD_VAR 0 1
7862: PPUSH
7863: LD_INT 9
7865: PPUSH
7866: CALL_OW 308
7870: PUSH
7871: LD_VAR 0 1
7875: PPUSH
7876: CALL_OW 110
7880: PUSH
7881: LD_INT 2
7883: EQUAL
7884: NOT
7885: AND
7886: IFFALSE 7900
// SetTag ( i , 2 ) ;
7888: LD_VAR 0 1
7892: PPUSH
7893: LD_INT 2
7895: PPUSH
7896: CALL_OW 109
// if not FilterAllUnits ( [ [ f_enemy , 3 ] , [ f_dist , i , 12 ] ] ) and not GetTag ( i ) = 2 then
7900: LD_INT 81
7902: PUSH
7903: LD_INT 3
7905: PUSH
7906: EMPTY
7907: LIST
7908: LIST
7909: PUSH
7910: LD_INT 91
7912: PUSH
7913: LD_VAR 0 1
7917: PUSH
7918: LD_INT 12
7920: PUSH
7921: EMPTY
7922: LIST
7923: LIST
7924: LIST
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: PPUSH
7930: CALL_OW 69
7934: NOT
7935: PUSH
7936: LD_VAR 0 1
7940: PPUSH
7941: CALL_OW 110
7945: PUSH
7946: LD_INT 2
7948: EQUAL
7949: NOT
7950: AND
7951: IFFALSE 7970
// ComAgressiveMove ( i , 64 , 93 ) else
7953: LD_VAR 0 1
7957: PPUSH
7958: LD_INT 64
7960: PPUSH
7961: LD_INT 93
7963: PPUSH
7964: CALL_OW 114
7968: GO 8004
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 3 ] ) , i ) ) ;
7970: LD_VAR 0 1
7974: PPUSH
7975: LD_INT 81
7977: PUSH
7978: LD_INT 3
7980: PUSH
7981: EMPTY
7982: LIST
7983: LIST
7984: PPUSH
7985: CALL_OW 69
7989: PPUSH
7990: LD_VAR 0 1
7994: PPUSH
7995: CALL_OW 74
7999: PPUSH
8000: CALL_OW 115
// end ;
8004: GO 7855
8006: POP
8007: POP
// end ;
8008: PPOPN 2
8010: END
// export function PrepareRussianAttack ( strength ) ; var i , j ; begin
8011: LD_INT 0
8013: PPUSH
8014: PPUSH
8015: PPUSH
// result := [ ] ;
8016: LD_ADDR_VAR 0 2
8020: PUSH
8021: EMPTY
8022: ST_TO_ADDR
// uc_side := 6 ;
8023: LD_ADDR_OWVAR 20
8027: PUSH
8028: LD_INT 6
8030: ST_TO_ADDR
// uc_nation := 3 ;
8031: LD_ADDR_OWVAR 21
8035: PUSH
8036: LD_INT 3
8038: ST_TO_ADDR
// case strength of 1 :
8039: LD_VAR 0 1
8043: PUSH
8044: LD_INT 1
8046: DOUBLE
8047: EQUAL
8048: IFTRUE 8052
8050: GO 8190
8052: POP
// begin for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
8053: LD_ADDR_VAR 0 3
8057: PUSH
8058: DOUBLE
8059: LD_INT 1
8061: DEC
8062: ST_TO_ADDR
8063: LD_INT 4
8065: PUSH
8066: LD_INT 5
8068: PUSH
8069: LD_INT 6
8071: PUSH
8072: EMPTY
8073: LIST
8074: LIST
8075: LIST
8076: PUSH
8077: LD_OWVAR 67
8081: ARRAY
8082: PUSH
8083: FOR_TO
8084: IFFALSE 8186
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked ] [ i mod 2 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] , 80 ) ;
8086: LD_INT 22
8088: PUSH
8089: LD_INT 24
8091: PUSH
8092: EMPTY
8093: LIST
8094: LIST
8095: PUSH
8096: LD_VAR 0 3
8100: PUSH
8101: LD_INT 2
8103: MOD
8104: PUSH
8105: LD_INT 1
8107: PLUS
8108: ARRAY
8109: PPUSH
8110: LD_INT 1
8112: PUSH
8113: LD_INT 3
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: PUSH
8120: LD_INT 1
8122: PPUSH
8123: LD_INT 2
8125: PPUSH
8126: CALL_OW 12
8130: ARRAY
8131: PPUSH
8132: LD_INT 3
8134: PPUSH
8135: LD_INT 43
8137: PUSH
8138: LD_INT 44
8140: PUSH
8141: LD_INT 45
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: LIST
8148: PUSH
8149: LD_INT 1
8151: PPUSH
8152: LD_INT 3
8154: PPUSH
8155: CALL_OW 12
8159: ARRAY
8160: PPUSH
8161: LD_INT 80
8163: PPUSH
8164: CALL 71087 0 5
// result := result union CreateVehicle ;
8168: LD_ADDR_VAR 0 2
8172: PUSH
8173: LD_VAR 0 2
8177: PUSH
8178: CALL_OW 45
8182: UNION
8183: ST_TO_ADDR
// end ;
8184: GO 8083
8186: POP
8187: POP
// end ; 2 :
8188: GO 9134
8190: LD_INT 2
8192: DOUBLE
8193: EQUAL
8194: IFTRUE 8198
8196: GO 8354
8198: POP
// begin for i = 1 to [ 5 , 6 , 7 ] [ Difficulty ] do
8199: LD_ADDR_VAR 0 3
8203: PUSH
8204: DOUBLE
8205: LD_INT 1
8207: DEC
8208: ST_TO_ADDR
8209: LD_INT 5
8211: PUSH
8212: LD_INT 6
8214: PUSH
8215: LD_INT 7
8217: PUSH
8218: EMPTY
8219: LIST
8220: LIST
8221: LIST
8222: PUSH
8223: LD_OWVAR 67
8227: ARRAY
8228: PUSH
8229: FOR_TO
8230: IFFALSE 8350
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_gun , ru_rocket_launcher , ru_gun , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8232: LD_INT 22
8234: PUSH
8235: LD_INT 24
8237: PUSH
8238: LD_INT 24
8240: PUSH
8241: EMPTY
8242: LIST
8243: LIST
8244: LIST
8245: PUSH
8246: LD_VAR 0 3
8250: PUSH
8251: LD_INT 3
8253: MOD
8254: PUSH
8255: LD_INT 1
8257: PLUS
8258: ARRAY
8259: PPUSH
8260: LD_INT 1
8262: PUSH
8263: LD_INT 3
8265: PUSH
8266: EMPTY
8267: LIST
8268: LIST
8269: PUSH
8270: LD_INT 1
8272: PPUSH
8273: LD_INT 2
8275: PPUSH
8276: CALL_OW 12
8280: ARRAY
8281: PPUSH
8282: LD_INT 3
8284: PPUSH
8285: LD_INT 43
8287: PUSH
8288: LD_INT 44
8290: PUSH
8291: LD_INT 45
8293: PUSH
8294: LD_INT 44
8296: PUSH
8297: LD_INT 46
8299: PUSH
8300: LD_INT 46
8302: PUSH
8303: EMPTY
8304: LIST
8305: LIST
8306: LIST
8307: LIST
8308: LIST
8309: LIST
8310: PUSH
8311: LD_VAR 0 3
8315: PUSH
8316: LD_INT 6
8318: MOD
8319: PUSH
8320: LD_INT 1
8322: PLUS
8323: ARRAY
8324: PPUSH
8325: LD_INT 80
8327: PPUSH
8328: CALL 71087 0 5
// result := result union CreateVehicle ;
8332: LD_ADDR_VAR 0 2
8336: PUSH
8337: LD_VAR 0 2
8341: PUSH
8342: CALL_OW 45
8346: UNION
8347: ST_TO_ADDR
// end ;
8348: GO 8229
8350: POP
8351: POP
// end ; 3 :
8352: GO 9134
8354: LD_INT 3
8356: DOUBLE
8357: EQUAL
8358: IFTRUE 8362
8360: GO 8518
8362: POP
// begin for i = 1 to [ 5 , 7 , 8 ] [ Difficulty ] do
8363: LD_ADDR_VAR 0 3
8367: PUSH
8368: DOUBLE
8369: LD_INT 1
8371: DEC
8372: ST_TO_ADDR
8373: LD_INT 5
8375: PUSH
8376: LD_INT 7
8378: PUSH
8379: LD_INT 8
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: PUSH
8387: LD_OWVAR 67
8391: ARRAY
8392: PUSH
8393: FOR_TO
8394: IFFALSE 8514
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_gatling_gun , ru_rocket , ru_rocket_launcher , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8396: LD_INT 22
8398: PUSH
8399: LD_INT 24
8401: PUSH
8402: LD_INT 24
8404: PUSH
8405: EMPTY
8406: LIST
8407: LIST
8408: LIST
8409: PUSH
8410: LD_VAR 0 3
8414: PUSH
8415: LD_INT 3
8417: MOD
8418: PUSH
8419: LD_INT 1
8421: PLUS
8422: ARRAY
8423: PPUSH
8424: LD_INT 1
8426: PUSH
8427: LD_INT 3
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: LD_INT 1
8436: PPUSH
8437: LD_INT 2
8439: PPUSH
8440: CALL_OW 12
8444: ARRAY
8445: PPUSH
8446: LD_INT 3
8448: PPUSH
8449: LD_INT 43
8451: PUSH
8452: LD_INT 47
8454: PUSH
8455: LD_INT 45
8457: PUSH
8458: LD_INT 45
8460: PUSH
8461: LD_INT 46
8463: PUSH
8464: LD_INT 46
8466: PUSH
8467: EMPTY
8468: LIST
8469: LIST
8470: LIST
8471: LIST
8472: LIST
8473: LIST
8474: PUSH
8475: LD_VAR 0 3
8479: PUSH
8480: LD_INT 6
8482: MOD
8483: PUSH
8484: LD_INT 1
8486: PLUS
8487: ARRAY
8488: PPUSH
8489: LD_INT 80
8491: PPUSH
8492: CALL 71087 0 5
// result := result union CreateVehicle ;
8496: LD_ADDR_VAR 0 2
8500: PUSH
8501: LD_VAR 0 2
8505: PUSH
8506: CALL_OW 45
8510: UNION
8511: ST_TO_ADDR
// end ;
8512: GO 8393
8514: POP
8515: POP
// end ; 4 :
8516: GO 9134
8518: LD_INT 4
8520: DOUBLE
8521: EQUAL
8522: IFTRUE 8526
8524: GO 9133
8526: POP
// begin uc_nation := 3 ;
8527: LD_ADDR_OWVAR 21
8531: PUSH
8532: LD_INT 3
8534: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 9 ] [ Difficulty ] do
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: DOUBLE
8541: LD_INT 1
8543: DEC
8544: ST_TO_ADDR
8545: LD_INT 6
8547: PUSH
8548: LD_INT 8
8550: PUSH
8551: LD_INT 9
8553: PUSH
8554: EMPTY
8555: LIST
8556: LIST
8557: LIST
8558: PUSH
8559: LD_OWVAR 67
8563: ARRAY
8564: PUSH
8565: FOR_TO
8566: IFFALSE 8686
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket , ru_rocket_launcher , ru_heavy_gun , ru_heavy_gun ] [ i mod 6 + 1 ] , 80 ) ;
8568: LD_INT 22
8570: PUSH
8571: LD_INT 24
8573: PUSH
8574: LD_INT 24
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: LIST
8581: PUSH
8582: LD_VAR 0 3
8586: PUSH
8587: LD_INT 3
8589: MOD
8590: PUSH
8591: LD_INT 1
8593: PLUS
8594: ARRAY
8595: PPUSH
8596: LD_INT 1
8598: PUSH
8599: LD_INT 3
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: LD_INT 1
8608: PPUSH
8609: LD_INT 2
8611: PPUSH
8612: CALL_OW 12
8616: ARRAY
8617: PPUSH
8618: LD_INT 3
8620: PPUSH
8621: LD_INT 45
8623: PUSH
8624: LD_INT 47
8626: PUSH
8627: LD_INT 47
8629: PUSH
8630: LD_INT 45
8632: PUSH
8633: LD_INT 46
8635: PUSH
8636: LD_INT 46
8638: PUSH
8639: EMPTY
8640: LIST
8641: LIST
8642: LIST
8643: LIST
8644: LIST
8645: LIST
8646: PUSH
8647: LD_VAR 0 3
8651: PUSH
8652: LD_INT 6
8654: MOD
8655: PUSH
8656: LD_INT 1
8658: PLUS
8659: ARRAY
8660: PPUSH
8661: LD_INT 80
8663: PPUSH
8664: CALL 71087 0 5
// result := result union CreateVehicle ;
8668: LD_ADDR_VAR 0 2
8672: PUSH
8673: LD_VAR 0 2
8677: PUSH
8678: CALL_OW 45
8682: UNION
8683: ST_TO_ADDR
// end ;
8684: GO 8565
8686: POP
8687: POP
// if not KappaStatus then
8688: LD_EXP 2
8692: NOT
8693: IFFALSE 8928
// begin uc_nation := 1 ;
8695: LD_ADDR_OWVAR 21
8699: PUSH
8700: LD_INT 1
8702: ST_TO_ADDR
// for i = 1 to 3 do
8703: LD_ADDR_VAR 0 3
8707: PUSH
8708: DOUBLE
8709: LD_INT 1
8711: DEC
8712: ST_TO_ADDR
8713: LD_INT 3
8715: PUSH
8716: FOR_TO
8717: IFFALSE 8853
// begin j := rand ( 0 , 1 ) ;
8719: LD_ADDR_VAR 0 4
8723: PUSH
8724: LD_INT 0
8726: PPUSH
8727: LD_INT 1
8729: PPUSH
8730: CALL_OW 12
8734: ST_TO_ADDR
// PrepareVehicle ( [ us_medium_tracked , us_morphling , us_morphling , us_heavy_tracked ] [ j + rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher , us_heavy_gun ] [ j + rand ( 1 , 2 ) ] , 85 ) ;
8735: LD_INT 3
8737: PUSH
8738: LD_INT 5
8740: PUSH
8741: LD_INT 5
8743: PUSH
8744: LD_INT 4
8746: PUSH
8747: EMPTY
8748: LIST
8749: LIST
8750: LIST
8751: LIST
8752: PUSH
8753: LD_VAR 0 4
8757: PUSH
8758: LD_INT 1
8760: PPUSH
8761: LD_INT 3
8763: PPUSH
8764: CALL_OW 12
8768: PLUS
8769: ARRAY
8770: PPUSH
8771: LD_INT 1
8773: PUSH
8774: LD_INT 3
8776: PUSH
8777: EMPTY
8778: LIST
8779: LIST
8780: PUSH
8781: LD_INT 1
8783: PPUSH
8784: LD_INT 2
8786: PPUSH
8787: CALL_OW 12
8791: ARRAY
8792: PPUSH
8793: LD_INT 3
8795: PPUSH
8796: LD_INT 9
8798: PUSH
8799: LD_INT 7
8801: PUSH
8802: LD_INT 6
8804: PUSH
8805: EMPTY
8806: LIST
8807: LIST
8808: LIST
8809: PUSH
8810: LD_VAR 0 4
8814: PUSH
8815: LD_INT 1
8817: PPUSH
8818: LD_INT 2
8820: PPUSH
8821: CALL_OW 12
8825: PLUS
8826: ARRAY
8827: PPUSH
8828: LD_INT 85
8830: PPUSH
8831: CALL 71087 0 5
// result := result union CreateVehicle ;
8835: LD_ADDR_VAR 0 2
8839: PUSH
8840: LD_VAR 0 2
8844: PUSH
8845: CALL_OW 45
8849: UNION
8850: ST_TO_ADDR
// end ;
8851: GO 8716
8853: POP
8854: POP
// if vsevolodFirstAttack then
8855: LD_EXP 24
8859: IFFALSE 8926
// begin vsevolodFirstAttack := false ;
8861: LD_ADDR_EXP 24
8865: PUSH
8866: LD_INT 0
8868: ST_TO_ADDR
// PrepareVehicle ( us_morphling , engine_siberite , control_manual , us_heavy_gun , 100 ) ;
8869: LD_INT 5
8871: PPUSH
8872: LD_INT 3
8874: PPUSH
8875: LD_INT 1
8877: PPUSH
8878: LD_INT 6
8880: PPUSH
8881: LD_INT 100
8883: PPUSH
8884: CALL 71087 0 5
// sewiVeh := CreateVehicle ;
8888: LD_ADDR_EXP 68
8892: PUSH
8893: CALL_OW 45
8897: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
8898: LD_EXP 68
8902: PPUSH
8903: LD_INT 1
8905: PPUSH
8906: CALL_OW 242
// result := result union sewiVeh ;
8910: LD_ADDR_VAR 0 2
8914: PUSH
8915: LD_VAR 0 2
8919: PUSH
8920: LD_EXP 68
8924: UNION
8925: ST_TO_ADDR
// end ; end else
8926: GO 9131
// if vsevolodFirstAttack then
8928: LD_EXP 24
8932: IFFALSE 9131
// begin vsevolodFirstAttack := false ;
8934: LD_ADDR_EXP 24
8938: PUSH
8939: LD_INT 0
8941: ST_TO_ADDR
// uc_nation := 3 ;
8942: LD_ADDR_OWVAR 21
8946: PUSH
8947: LD_INT 3
8949: ST_TO_ADDR
// for i = 1 to 3 do
8950: LD_ADDR_VAR 0 3
8954: PUSH
8955: DOUBLE
8956: LD_INT 1
8958: DEC
8959: ST_TO_ADDR
8960: LD_INT 3
8962: PUSH
8963: FOR_TO
8964: IFFALSE 9072
// begin PrepareVehicle ( [ ru_medium_tracked , ru_heavy_tracked , ru_heavy_tracked ] [ i mod 3 + 1 ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ ru_rocket_launcher , ru_rocket , ru_rocket ] [ i mod 3 + 1 ] , 80 ) ;
8966: LD_INT 22
8968: PUSH
8969: LD_INT 24
8971: PUSH
8972: LD_INT 24
8974: PUSH
8975: EMPTY
8976: LIST
8977: LIST
8978: LIST
8979: PUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_INT 3
8987: MOD
8988: PUSH
8989: LD_INT 1
8991: PLUS
8992: ARRAY
8993: PPUSH
8994: LD_INT 1
8996: PUSH
8997: LD_INT 3
8999: PUSH
9000: EMPTY
9001: LIST
9002: LIST
9003: PUSH
9004: LD_INT 1
9006: PPUSH
9007: LD_INT 2
9009: PPUSH
9010: CALL_OW 12
9014: ARRAY
9015: PPUSH
9016: LD_INT 3
9018: PPUSH
9019: LD_INT 45
9021: PUSH
9022: LD_INT 47
9024: PUSH
9025: LD_INT 47
9027: PUSH
9028: EMPTY
9029: LIST
9030: LIST
9031: LIST
9032: PUSH
9033: LD_VAR 0 3
9037: PUSH
9038: LD_INT 3
9040: MOD
9041: PUSH
9042: LD_INT 1
9044: PLUS
9045: ARRAY
9046: PPUSH
9047: LD_INT 80
9049: PPUSH
9050: CALL 71087 0 5
// result := result union CreateVehicle ;
9054: LD_ADDR_VAR 0 2
9058: PUSH
9059: LD_VAR 0 2
9063: PUSH
9064: CALL_OW 45
9068: UNION
9069: ST_TO_ADDR
// end ;
9070: GO 8963
9072: POP
9073: POP
// PrepareVehicle ( ru_heavy_tracked , engine_siberite , control_manual , ru_rocket , 100 ) ;
9074: LD_INT 24
9076: PPUSH
9077: LD_INT 3
9079: PPUSH
9080: LD_INT 1
9082: PPUSH
9083: LD_INT 47
9085: PPUSH
9086: LD_INT 100
9088: PPUSH
9089: CALL 71087 0 5
// sewiVeh := CreateVehicle ;
9093: LD_ADDR_EXP 68
9097: PUSH
9098: CALL_OW 45
9102: ST_TO_ADDR
// SetMark ( sewiVeh , 1 ) ;
9103: LD_EXP 68
9107: PPUSH
9108: LD_INT 1
9110: PPUSH
9111: CALL_OW 242
// result := result union sewiVeh ;
9115: LD_ADDR_VAR 0 2
9119: PUSH
9120: LD_VAR 0 2
9124: PUSH
9125: LD_EXP 68
9129: UNION
9130: ST_TO_ADDR
// end ; end ; end ;
9131: GO 9134
9133: POP
// end ;
9134: LD_VAR 0 2
9138: RET
// every 0 0$30 trigger activeAttacks do var i , tmp , time , areas , strength , xy ;
9139: LD_EXP 16
9143: IFFALSE 9901
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
9152: PPUSH
9153: PPUSH
9154: PPUSH
9155: PPUSH
// begin areas := [ southSpawn , southWestSpawn ] ;
9156: LD_ADDR_VAR 0 4
9160: PUSH
9161: LD_INT 11
9163: PUSH
9164: LD_INT 12
9166: PUSH
9167: EMPTY
9168: LIST
9169: LIST
9170: ST_TO_ADDR
// time := [ 4 4$20 , 3 3$30 , 3 3$10 ] [ Difficulty ] ;
9171: LD_ADDR_VAR 0 3
9175: PUSH
9176: LD_INT 9100
9178: PUSH
9179: LD_INT 7350
9181: PUSH
9182: LD_INT 6650
9184: PUSH
9185: EMPTY
9186: LIST
9187: LIST
9188: LIST
9189: PUSH
9190: LD_OWVAR 67
9194: ARRAY
9195: ST_TO_ADDR
// xy := [ [ 70 , 118 ] , [ 78 , 31 ] ] ;
9196: LD_ADDR_VAR 0 6
9200: PUSH
9201: LD_INT 70
9203: PUSH
9204: LD_INT 118
9206: PUSH
9207: EMPTY
9208: LIST
9209: LIST
9210: PUSH
9211: LD_INT 78
9213: PUSH
9214: LD_INT 31
9216: PUSH
9217: EMPTY
9218: LIST
9219: LIST
9220: PUSH
9221: EMPTY
9222: LIST
9223: LIST
9224: ST_TO_ADDR
// repeat if missionStage = 2 then
9225: LD_EXP 15
9229: PUSH
9230: LD_INT 2
9232: EQUAL
9233: IFFALSE 9244
// wait ( 1 1$30 ) else
9235: LD_INT 3150
9237: PPUSH
9238: CALL_OW 67
9242: GO 9253
// wait ( time ) ;
9244: LD_VAR 0 3
9248: PPUSH
9249: CALL_OW 67
// if missionStage = 6 then
9253: LD_EXP 15
9257: PUSH
9258: LD_INT 6
9260: EQUAL
9261: IFFALSE 9289
// begin SetTech ( tech_weap1 , 6 , state_researched ) ;
9263: LD_INT 51
9265: PPUSH
9266: LD_INT 6
9268: PPUSH
9269: LD_INT 2
9271: PPUSH
9272: CALL_OW 322
// SetTech ( tech_comp1 , 6 , state_researched ) ;
9276: LD_INT 57
9278: PPUSH
9279: LD_INT 6
9281: PPUSH
9282: LD_INT 2
9284: PPUSH
9285: CALL_OW 322
// end ; if missionStage = 8 then
9289: LD_EXP 15
9293: PUSH
9294: LD_INT 8
9296: EQUAL
9297: IFFALSE 9325
// begin SetTech ( tech_weap2 , 6 , state_researched ) ;
9299: LD_INT 52
9301: PPUSH
9302: LD_INT 6
9304: PPUSH
9305: LD_INT 2
9307: PPUSH
9308: CALL_OW 322
// SetTech ( tech_comp2 , 6 , state_researched ) ;
9312: LD_INT 58
9314: PPUSH
9315: LD_INT 6
9317: PPUSH
9318: LD_INT 2
9320: PPUSH
9321: CALL_OW 322
// end ; if missionStage = 10 and Difficulty > 1 then
9325: LD_EXP 15
9329: PUSH
9330: LD_INT 10
9332: EQUAL
9333: PUSH
9334: LD_OWVAR 67
9338: PUSH
9339: LD_INT 1
9341: GREATER
9342: AND
9343: IFFALSE 9371
// begin SetTech ( tech_weap3 , 6 , state_researched ) ;
9345: LD_INT 53
9347: PPUSH
9348: LD_INT 6
9350: PPUSH
9351: LD_INT 2
9353: PPUSH
9354: CALL_OW 322
// SetTech ( tech_comp3 , 6 , state_researched ) ;
9358: LD_INT 59
9360: PPUSH
9361: LD_INT 6
9363: PPUSH
9364: LD_INT 2
9366: PPUSH
9367: CALL_OW 322
// end ; if activeAttacks then
9371: LD_EXP 16
9375: IFFALSE 9895
// begin if missionStage = 2 then
9377: LD_EXP 15
9381: PUSH
9382: LD_INT 2
9384: EQUAL
9385: IFFALSE 9395
// strength := 1 ;
9387: LD_ADDR_VAR 0 5
9391: PUSH
9392: LD_INT 1
9394: ST_TO_ADDR
// if missionStage > 2 then
9395: LD_EXP 15
9399: PUSH
9400: LD_INT 2
9402: GREATER
9403: IFFALSE 9413
// strength := 2 ;
9405: LD_ADDR_VAR 0 5
9409: PUSH
9410: LD_INT 2
9412: ST_TO_ADDR
// if missionStage > 6 then
9413: LD_EXP 15
9417: PUSH
9418: LD_INT 6
9420: GREATER
9421: IFFALSE 9431
// strength := 3 ;
9423: LD_ADDR_VAR 0 5
9427: PUSH
9428: LD_INT 3
9430: ST_TO_ADDR
// if missionStage > 10 then
9431: LD_EXP 15
9435: PUSH
9436: LD_INT 10
9438: GREATER
9439: IFFALSE 9449
// strength := 4 ;
9441: LD_ADDR_VAR 0 5
9445: PUSH
9446: LD_INT 4
9448: ST_TO_ADDR
// tmp := PrepareRussianAttack ( strength ) ;
9449: LD_ADDR_VAR 0 2
9453: PUSH
9454: LD_VAR 0 5
9458: PPUSH
9459: CALL 8011 0 1
9463: ST_TO_ADDR
// for i in tmp do
9464: LD_ADDR_VAR 0 1
9468: PUSH
9469: LD_VAR 0 2
9473: PUSH
9474: FOR_IN
9475: IFFALSE 9575
// begin PlaceUnitArea ( i , areas [ rand ( 1 , 2 ) ] , false ) ;
9477: LD_VAR 0 1
9481: PPUSH
9482: LD_VAR 0 4
9486: PUSH
9487: LD_INT 1
9489: PPUSH
9490: LD_INT 2
9492: PPUSH
9493: CALL_OW 12
9497: ARRAY
9498: PPUSH
9499: LD_INT 0
9501: PPUSH
9502: CALL_OW 49
// if i = sewiVeh then
9506: LD_VAR 0 1
9510: PUSH
9511: LD_EXP 68
9515: EQUAL
9516: IFFALSE 9551
// begin Vsevolod = PrepareUnit ( Vsevolod , false ,  ) ;
9518: LD_ADDR_EXP 67
9522: PUSH
9523: LD_STRING Vsevolod
9525: PPUSH
9526: LD_INT 0
9528: PPUSH
9529: LD_STRING 
9531: PPUSH
9532: CALL 64061 0 3
9536: ST_TO_ADDR
// PlaceHumanInUnit ( Vsevolod , i ) ;
9537: LD_EXP 67
9541: PPUSH
9542: LD_VAR 0 1
9546: PPUSH
9547: CALL_OW 52
// end ; ComMoveXY ( i , 111 , 197 ) ;
9551: LD_VAR 0 1
9555: PPUSH
9556: LD_INT 111
9558: PPUSH
9559: LD_INT 197
9561: PPUSH
9562: CALL_OW 111
// wait ( 0 0$2 ) ;
9566: LD_INT 70
9568: PPUSH
9569: CALL_OW 67
// end ;
9573: GO 9474
9575: POP
9576: POP
// repeat wait ( 0 0$1 ) ;
9577: LD_INT 35
9579: PPUSH
9580: CALL_OW 67
// for i in tmp do
9584: LD_ADDR_VAR 0 1
9588: PUSH
9589: LD_VAR 0 2
9593: PUSH
9594: FOR_IN
9595: IFFALSE 9876
// begin if FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) then
9597: LD_INT 81
9599: PUSH
9600: LD_INT 6
9602: PUSH
9603: EMPTY
9604: LIST
9605: LIST
9606: PUSH
9607: LD_INT 91
9609: PUSH
9610: LD_VAR 0 1
9614: PUSH
9615: LD_INT 12
9617: PUSH
9618: EMPTY
9619: LIST
9620: LIST
9621: LIST
9622: PUSH
9623: EMPTY
9624: LIST
9625: LIST
9626: PPUSH
9627: CALL_OW 69
9631: IFFALSE 9689
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , 6 ] , [ f_dist , i , 12 ] ] ) , i ) ) else
9633: LD_VAR 0 1
9637: PPUSH
9638: LD_INT 81
9640: PUSH
9641: LD_INT 6
9643: PUSH
9644: EMPTY
9645: LIST
9646: LIST
9647: PUSH
9648: LD_INT 91
9650: PUSH
9651: LD_VAR 0 1
9655: PUSH
9656: LD_INT 12
9658: PUSH
9659: EMPTY
9660: LIST
9661: LIST
9662: LIST
9663: PUSH
9664: EMPTY
9665: LIST
9666: LIST
9667: PPUSH
9668: CALL_OW 69
9672: PPUSH
9673: LD_VAR 0 1
9677: PPUSH
9678: CALL_OW 74
9682: PPUSH
9683: CALL_OW 115
9687: GO 9874
// if FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) then
9689: LD_INT 9
9691: PPUSH
9692: LD_INT 81
9694: PUSH
9695: LD_INT 6
9697: PUSH
9698: EMPTY
9699: LIST
9700: LIST
9701: PPUSH
9702: CALL_OW 70
9706: IFFALSE 9840
// begin if GetDistUnitXY ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) > 10 and not IsInArea ( i , powellBase ) then
9708: LD_VAR 0 1
9712: PPUSH
9713: LD_VAR 0 6
9717: PUSH
9718: LD_INT 1
9720: ARRAY
9721: PUSH
9722: LD_INT 1
9724: ARRAY
9725: PPUSH
9726: LD_VAR 0 6
9730: PUSH
9731: LD_INT 1
9733: ARRAY
9734: PUSH
9735: LD_INT 2
9737: ARRAY
9738: PPUSH
9739: CALL_OW 297
9743: PUSH
9744: LD_INT 10
9746: GREATER
9747: PUSH
9748: LD_VAR 0 1
9752: PPUSH
9753: LD_INT 9
9755: PPUSH
9756: CALL_OW 308
9760: NOT
9761: AND
9762: IFFALSE 9801
// ComAgressiveMove ( i , xy [ 1 ] [ 1 ] , xy [ 1 ] [ 2 ] ) else
9764: LD_VAR 0 1
9768: PPUSH
9769: LD_VAR 0 6
9773: PUSH
9774: LD_INT 1
9776: ARRAY
9777: PUSH
9778: LD_INT 1
9780: ARRAY
9781: PPUSH
9782: LD_VAR 0 6
9786: PUSH
9787: LD_INT 1
9789: ARRAY
9790: PUSH
9791: LD_INT 2
9793: ARRAY
9794: PPUSH
9795: CALL_OW 114
9799: GO 9838
// ComAttackUnit ( i , NearestUnitToUnit ( FilterUnitsInArea ( powellBase , [ f_enemy , 6 ] ) , i ) ) ;
9801: LD_VAR 0 1
9805: PPUSH
9806: LD_INT 9
9808: PPUSH
9809: LD_INT 81
9811: PUSH
9812: LD_INT 6
9814: PUSH
9815: EMPTY
9816: LIST
9817: LIST
9818: PPUSH
9819: CALL_OW 70
9823: PPUSH
9824: LD_VAR 0 1
9828: PPUSH
9829: CALL_OW 74
9833: PPUSH
9834: CALL_OW 115
// end else
9838: GO 9874
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 6 ] ) , i ) ) ;
9840: LD_VAR 0 1
9844: PPUSH
9845: LD_INT 81
9847: PUSH
9848: LD_INT 6
9850: PUSH
9851: EMPTY
9852: LIST
9853: LIST
9854: PPUSH
9855: CALL_OW 69
9859: PPUSH
9860: LD_VAR 0 1
9864: PPUSH
9865: CALL_OW 74
9869: PPUSH
9870: CALL_OW 115
// end ;
9874: GO 9594
9876: POP
9877: POP
// until not FilterAllUnits ( [ f_side , 6 ] ) ;
9878: LD_INT 22
9880: PUSH
9881: LD_INT 6
9883: PUSH
9884: EMPTY
9885: LIST
9886: LIST
9887: PPUSH
9888: CALL_OW 69
9892: NOT
9893: IFFALSE 9577
// end ; until russianDestroyed ;
9895: LD_EXP 21
9899: IFFALSE 9225
// end ;
9901: PPOPN 6
9903: END
// every 7 7$30 trigger not russianDestroyed and missionStage >= 6 and not MC_GetVehicles ( 2 , true ) do var i , tmp , target , teleport ;
9904: LD_EXP 21
9908: NOT
9909: PUSH
9910: LD_EXP 15
9914: PUSH
9915: LD_INT 6
9917: GREATEREQUAL
9918: AND
9919: PUSH
9920: LD_INT 2
9922: PPUSH
9923: LD_INT 1
9925: PPUSH
9926: CALL 59135 0 2
9930: NOT
9931: AND
9932: IFFALSE 10888
9934: GO 9936
9936: DISABLE
9937: LD_INT 0
9939: PPUSH
9940: PPUSH
9941: PPUSH
9942: PPUSH
// begin enable ;
9943: ENABLE
// if not FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_factory ] ] ) then
9944: LD_INT 22
9946: PUSH
9947: LD_INT 3
9949: PUSH
9950: EMPTY
9951: LIST
9952: LIST
9953: PUSH
9954: LD_INT 30
9956: PUSH
9957: LD_INT 3
9959: PUSH
9960: EMPTY
9961: LIST
9962: LIST
9963: PUSH
9964: EMPTY
9965: LIST
9966: LIST
9967: PPUSH
9968: CALL_OW 69
9972: NOT
9973: IFFALSE 9977
// exit ;
9975: GO 10888
// teleport := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_teleport ] ] ) ;
9977: LD_ADDR_VAR 0 4
9981: PUSH
9982: LD_INT 22
9984: PUSH
9985: LD_INT 3
9987: PUSH
9988: EMPTY
9989: LIST
9990: LIST
9991: PUSH
9992: LD_INT 30
9994: PUSH
9995: LD_INT 34
9997: PUSH
9998: EMPTY
9999: LIST
10000: LIST
10001: PUSH
10002: EMPTY
10003: LIST
10004: LIST
10005: PPUSH
10006: CALL_OW 69
10010: ST_TO_ADDR
// if Prob ( 40 ) then
10011: LD_INT 40
10013: PPUSH
10014: CALL_OW 13
10018: IFFALSE 10145
// begin MC_InsertProduceList ( 2 , [ [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_medium_tracked , engine_siberite , control_computer , ru_time_lapser ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10020: LD_INT 2
10022: PPUSH
10023: LD_INT 22
10025: PUSH
10026: LD_INT 3
10028: PUSH
10029: LD_INT 3
10031: PUSH
10032: LD_INT 49
10034: PUSH
10035: EMPTY
10036: LIST
10037: LIST
10038: LIST
10039: LIST
10040: PUSH
10041: LD_INT 22
10043: PUSH
10044: LD_INT 3
10046: PUSH
10047: LD_INT 3
10049: PUSH
10050: LD_INT 49
10052: PUSH
10053: EMPTY
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: PUSH
10059: LD_INT 22
10061: PUSH
10062: LD_INT 3
10064: PUSH
10065: LD_INT 3
10067: PUSH
10068: LD_INT 49
10070: PUSH
10071: EMPTY
10072: LIST
10073: LIST
10074: LIST
10075: LIST
10076: PUSH
10077: LD_INT 24
10079: PUSH
10080: LD_INT 3
10082: PUSH
10083: LD_INT 3
10085: PUSH
10086: LD_INT 46
10088: PUSH
10089: EMPTY
10090: LIST
10091: LIST
10092: LIST
10093: LIST
10094: PUSH
10095: LD_INT 24
10097: PUSH
10098: LD_INT 3
10100: PUSH
10101: LD_INT 3
10103: PUSH
10104: LD_INT 46
10106: PUSH
10107: EMPTY
10108: LIST
10109: LIST
10110: LIST
10111: LIST
10112: PUSH
10113: LD_INT 24
10115: PUSH
10116: LD_INT 3
10118: PUSH
10119: LD_INT 3
10121: PUSH
10122: LD_INT 46
10124: PUSH
10125: EMPTY
10126: LIST
10127: LIST
10128: LIST
10129: LIST
10130: PUSH
10131: EMPTY
10132: LIST
10133: LIST
10134: LIST
10135: LIST
10136: LIST
10137: LIST
10138: PPUSH
10139: CALL 57717 0 2
// end else
10143: GO 10268
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_heavy_gun ] ] ) ;
10145: LD_INT 2
10147: PPUSH
10148: LD_INT 24
10150: PUSH
10151: LD_INT 3
10153: PUSH
10154: LD_INT 3
10156: PUSH
10157: LD_INT 47
10159: PUSH
10160: EMPTY
10161: LIST
10162: LIST
10163: LIST
10164: LIST
10165: PUSH
10166: LD_INT 24
10168: PUSH
10169: LD_INT 3
10171: PUSH
10172: LD_INT 3
10174: PUSH
10175: LD_INT 47
10177: PUSH
10178: EMPTY
10179: LIST
10180: LIST
10181: LIST
10182: LIST
10183: PUSH
10184: LD_INT 24
10186: PUSH
10187: LD_INT 3
10189: PUSH
10190: LD_INT 3
10192: PUSH
10193: LD_INT 47
10195: PUSH
10196: EMPTY
10197: LIST
10198: LIST
10199: LIST
10200: LIST
10201: PUSH
10202: LD_INT 24
10204: PUSH
10205: LD_INT 3
10207: PUSH
10208: LD_INT 3
10210: PUSH
10211: LD_INT 46
10213: PUSH
10214: EMPTY
10215: LIST
10216: LIST
10217: LIST
10218: LIST
10219: PUSH
10220: LD_INT 24
10222: PUSH
10223: LD_INT 3
10225: PUSH
10226: LD_INT 3
10228: PUSH
10229: LD_INT 46
10231: PUSH
10232: EMPTY
10233: LIST
10234: LIST
10235: LIST
10236: LIST
10237: PUSH
10238: LD_INT 24
10240: PUSH
10241: LD_INT 3
10243: PUSH
10244: LD_INT 3
10246: PUSH
10247: LD_INT 46
10249: PUSH
10250: EMPTY
10251: LIST
10252: LIST
10253: LIST
10254: LIST
10255: PUSH
10256: EMPTY
10257: LIST
10258: LIST
10259: LIST
10260: LIST
10261: LIST
10262: LIST
10263: PPUSH
10264: CALL 57717 0 2
// end ; if Difficulty > 1 then
10268: LD_OWVAR 67
10272: PUSH
10273: LD_INT 1
10275: GREATER
10276: IFFALSE 10306
// MC_InsertProduceList ( 2 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
10278: LD_INT 2
10280: PPUSH
10281: LD_INT 24
10283: PUSH
10284: LD_INT 3
10286: PUSH
10287: LD_INT 3
10289: PUSH
10290: LD_INT 47
10292: PUSH
10293: EMPTY
10294: LIST
10295: LIST
10296: LIST
10297: LIST
10298: PUSH
10299: EMPTY
10300: LIST
10301: PPUSH
10302: CALL 57717 0 2
// repeat wait ( 0 0$1 ) ;
10306: LD_INT 35
10308: PPUSH
10309: CALL_OW 67
// until MC_GetVehicles ( 2 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
10313: LD_INT 2
10315: PPUSH
10316: LD_INT 1
10318: PPUSH
10319: CALL 59135 0 2
10323: PUSH
10324: LD_INT 6
10326: PUSH
10327: LD_INT 7
10329: PUSH
10330: LD_INT 7
10332: PUSH
10333: EMPTY
10334: LIST
10335: LIST
10336: LIST
10337: PUSH
10338: LD_OWVAR 67
10342: ARRAY
10343: GREATEREQUAL
10344: IFFALSE 10306
// wait ( 0 0$30 ) ;
10346: LD_INT 1050
10348: PPUSH
10349: CALL_OW 67
// tmp := MC_GetVehicles ( 2 , true ) ;
10353: LD_ADDR_VAR 0 2
10357: PUSH
10358: LD_INT 2
10360: PPUSH
10361: LD_INT 1
10363: PPUSH
10364: CALL 59135 0 2
10368: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 2 , mc_vehicles [ 2 ] diff tmp ) ;
10369: LD_ADDR_EXP 118
10373: PUSH
10374: LD_EXP 118
10378: PPUSH
10379: LD_INT 2
10381: PPUSH
10382: LD_EXP 118
10386: PUSH
10387: LD_INT 2
10389: ARRAY
10390: PUSH
10391: LD_VAR 0 2
10395: DIFF
10396: PPUSH
10397: CALL_OW 1
10401: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
10402: LD_ADDR_VAR 0 3
10406: PUSH
10407: LD_INT 0
10409: PPUSH
10410: LD_INT 1
10412: PPUSH
10413: CALL_OW 12
10417: ST_TO_ADDR
// if target then
10418: LD_VAR 0 3
10422: IFFALSE 10550
// begin repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10424: LD_ADDR_VAR 0 2
10428: PUSH
10429: LD_VAR 0 2
10433: PPUSH
10434: LD_INT 24
10436: PUSH
10437: LD_INT 250
10439: PUSH
10440: EMPTY
10441: LIST
10442: LIST
10443: PPUSH
10444: CALL_OW 72
10448: ST_TO_ADDR
// for i in tmp do
10449: LD_ADDR_VAR 0 1
10453: PUSH
10454: LD_VAR 0 2
10458: PUSH
10459: FOR_IN
10460: IFFALSE 10500
// if GetDistUnitXY ( i , 139 , 89 ) > 9 then
10462: LD_VAR 0 1
10466: PPUSH
10467: LD_INT 139
10469: PPUSH
10470: LD_INT 89
10472: PPUSH
10473: CALL_OW 297
10477: PUSH
10478: LD_INT 9
10480: GREATER
10481: IFFALSE 10498
// ComMoveXY ( i , 139 , 89 ) ;
10483: LD_VAR 0 1
10487: PPUSH
10488: LD_INT 139
10490: PPUSH
10491: LD_INT 89
10493: PPUSH
10494: CALL_OW 111
10498: GO 10459
10500: POP
10501: POP
// wait ( 0 0$1 ) ;
10502: LD_INT 35
10504: PPUSH
10505: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 139 , 89 , 9 ] ) >= ( tmp - 1 ) ;
10509: LD_VAR 0 2
10513: PPUSH
10514: LD_INT 92
10516: PUSH
10517: LD_INT 139
10519: PUSH
10520: LD_INT 89
10522: PUSH
10523: LD_INT 9
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: PPUSH
10532: CALL_OW 72
10536: PUSH
10537: LD_VAR 0 2
10541: PUSH
10542: LD_INT 1
10544: MINUS
10545: GREATEREQUAL
10546: IFFALSE 10424
// end else
10548: GO 10692
// begin ComEnterUnit ( tmp , teleport [ 1 ] ) ;
10550: LD_VAR 0 2
10554: PPUSH
10555: LD_VAR 0 4
10559: PUSH
10560: LD_INT 1
10562: ARRAY
10563: PPUSH
10564: CALL_OW 120
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
10568: LD_ADDR_VAR 0 2
10572: PUSH
10573: LD_VAR 0 2
10577: PPUSH
10578: LD_INT 24
10580: PUSH
10581: LD_INT 250
10583: PUSH
10584: EMPTY
10585: LIST
10586: LIST
10587: PPUSH
10588: CALL_OW 72
10592: ST_TO_ADDR
// for i in tmp do
10593: LD_ADDR_VAR 0 1
10597: PUSH
10598: LD_VAR 0 2
10602: PUSH
10603: FOR_IN
10604: IFFALSE 10644
// if GetDistUnitXY ( i , 124 , 139 ) > 9 then
10606: LD_VAR 0 1
10610: PPUSH
10611: LD_INT 124
10613: PPUSH
10614: LD_INT 139
10616: PPUSH
10617: CALL_OW 297
10621: PUSH
10622: LD_INT 9
10624: GREATER
10625: IFFALSE 10642
// ComMoveXY ( i , 124 , 139 ) ;
10627: LD_VAR 0 1
10631: PPUSH
10632: LD_INT 124
10634: PPUSH
10635: LD_INT 139
10637: PPUSH
10638: CALL_OW 111
10642: GO 10603
10644: POP
10645: POP
// wait ( 0 0$1 ) ;
10646: LD_INT 35
10648: PPUSH
10649: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 124 , 139 , 9 ] ) >= ( tmp - 1 ) ;
10653: LD_VAR 0 2
10657: PPUSH
10658: LD_INT 92
10660: PUSH
10661: LD_INT 124
10663: PUSH
10664: LD_INT 139
10666: PUSH
10667: LD_INT 9
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: LIST
10674: LIST
10675: PPUSH
10676: CALL_OW 72
10680: PUSH
10681: LD_VAR 0 2
10685: PUSH
10686: LD_INT 1
10688: MINUS
10689: GREATEREQUAL
10690: IFFALSE 10568
// end ; repeat wait ( 0 0$1 ) ;
10692: LD_INT 35
10694: PPUSH
10695: CALL_OW 67
// for i in tmp do
10699: LD_ADDR_VAR 0 1
10703: PUSH
10704: LD_VAR 0 2
10708: PUSH
10709: FOR_IN
10710: IFFALSE 10879
// begin if GetLives ( i ) > 251 then
10712: LD_VAR 0 1
10716: PPUSH
10717: CALL_OW 256
10721: PUSH
10722: LD_INT 251
10724: GREATER
10725: IFFALSE 10850
// begin if GetWeapon ( i ) = ru_time_lapser then
10727: LD_VAR 0 1
10731: PPUSH
10732: CALL_OW 264
10736: PUSH
10737: LD_INT 49
10739: EQUAL
10740: IFFALSE 10796
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) else
10742: LD_VAR 0 1
10746: PPUSH
10747: LD_INT 2
10749: PUSH
10750: LD_INT 22
10752: PUSH
10753: LD_INT 1
10755: PUSH
10756: EMPTY
10757: LIST
10758: LIST
10759: PUSH
10760: LD_INT 22
10762: PUSH
10763: LD_INT 8
10765: PUSH
10766: EMPTY
10767: LIST
10768: LIST
10769: PUSH
10770: EMPTY
10771: LIST
10772: LIST
10773: LIST
10774: PPUSH
10775: CALL_OW 69
10779: PPUSH
10780: LD_VAR 0 1
10784: PPUSH
10785: CALL_OW 74
10789: PPUSH
10790: CALL_OW 112
10794: GO 10848
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_or , [ f_side , 1 ] , [ f_side , 8 ] ] ) , i ) ) ;
10796: LD_VAR 0 1
10800: PPUSH
10801: LD_INT 2
10803: PUSH
10804: LD_INT 22
10806: PUSH
10807: LD_INT 1
10809: PUSH
10810: EMPTY
10811: LIST
10812: LIST
10813: PUSH
10814: LD_INT 22
10816: PUSH
10817: LD_INT 8
10819: PUSH
10820: EMPTY
10821: LIST
10822: LIST
10823: PUSH
10824: EMPTY
10825: LIST
10826: LIST
10827: LIST
10828: PPUSH
10829: CALL_OW 69
10833: PPUSH
10834: LD_VAR 0 1
10838: PPUSH
10839: CALL_OW 74
10843: PPUSH
10844: CALL_OW 115
// end else
10848: GO 10877
// if IsDead ( i ) then
10850: LD_VAR 0 1
10854: PPUSH
10855: CALL_OW 301
10859: IFFALSE 10877
// tmp := tmp diff i ;
10861: LD_ADDR_VAR 0 2
10865: PUSH
10866: LD_VAR 0 2
10870: PUSH
10871: LD_VAR 0 1
10875: DIFF
10876: ST_TO_ADDR
// end ;
10877: GO 10709
10879: POP
10880: POP
// until not tmp ;
10881: LD_VAR 0 2
10885: NOT
10886: IFFALSE 10692
// end ; end_of_file
10888: PPOPN 4
10890: END
// export Roth , Simms , Kirilenkova , Dolgov , Petrosyan , Petrovova , Kuzmov , Lipshchin , Gnyevko , Titov , Xavier , Belkov , Burlak , Karamazov , Kapitsova , Scholtze , Oblukov ; export allianceSpecialForce ; export function PrepareAlliance ; var i , tmp , base , side , teleport ; begin
10891: LD_INT 0
10893: PPUSH
10894: PPUSH
10895: PPUSH
10896: PPUSH
10897: PPUSH
10898: PPUSH
// side := 7 ;
10899: LD_ADDR_VAR 0 5
10903: PUSH
10904: LD_INT 7
10906: ST_TO_ADDR
// uc_side := side ;
10907: LD_ADDR_OWVAR 20
10911: PUSH
10912: LD_VAR 0 5
10916: ST_TO_ADDR
// uc_nation := 1 ;
10917: LD_ADDR_OWVAR 21
10921: PUSH
10922: LD_INT 1
10924: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) do
10925: LD_ADDR_VAR 0 2
10929: PUSH
10930: LD_INT 22
10932: PUSH
10933: LD_VAR 0 5
10937: PUSH
10938: EMPTY
10939: LIST
10940: LIST
10941: PUSH
10942: LD_INT 21
10944: PUSH
10945: LD_INT 3
10947: PUSH
10948: EMPTY
10949: LIST
10950: LIST
10951: PUSH
10952: EMPTY
10953: LIST
10954: LIST
10955: PPUSH
10956: CALL_OW 69
10960: PUSH
10961: FOR_IN
10962: IFFALSE 10978
// SetBLevel ( i , 10 ) ;
10964: LD_VAR 0 2
10968: PPUSH
10969: LD_INT 10
10971: PPUSH
10972: CALL_OW 241
10976: GO 10961
10978: POP
10979: POP
// base := GetBase ( al_depot ) ;
10980: LD_ADDR_VAR 0 4
10984: PUSH
10985: LD_INT 2
10987: PPUSH
10988: CALL_OW 274
10992: ST_TO_ADDR
// teleport := FilterAllUnits ( [ [ f_side , side ] , [ f_btype , b_teleport ] ] ) ;
10993: LD_ADDR_VAR 0 6
10997: PUSH
10998: LD_INT 22
11000: PUSH
11001: LD_VAR 0 5
11005: PUSH
11006: EMPTY
11007: LIST
11008: LIST
11009: PUSH
11010: LD_INT 30
11012: PUSH
11013: LD_INT 34
11015: PUSH
11016: EMPTY
11017: LIST
11018: LIST
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PPUSH
11024: CALL_OW 69
11028: ST_TO_ADDR
// if teleport then
11029: LD_VAR 0 6
11033: IFFALSE 11054
// TeleportExit ( teleport [ 1 ] , 262 , 119 ) ;
11035: LD_VAR 0 6
11039: PUSH
11040: LD_INT 1
11042: ARRAY
11043: PPUSH
11044: LD_INT 262
11046: PPUSH
11047: LD_INT 119
11049: PPUSH
11050: CALL_OW 243
// SetResourceType ( base , mat_cans , 19500 ) ;
11054: LD_VAR 0 4
11058: PPUSH
11059: LD_INT 1
11061: PPUSH
11062: LD_INT 19500
11064: PPUSH
11065: CALL_OW 277
// SetResourceType ( base , mat_oil , 200 ) ;
11069: LD_VAR 0 4
11073: PPUSH
11074: LD_INT 2
11076: PPUSH
11077: LD_INT 200
11079: PPUSH
11080: CALL_OW 277
// SetResourceType ( base , mat_siberit , 650 ) ;
11084: LD_VAR 0 4
11088: PPUSH
11089: LD_INT 3
11091: PPUSH
11092: LD_INT 650
11094: PPUSH
11095: CALL_OW 277
// Roth := NewCharacter ( Roth ) ;
11099: LD_ADDR_EXP 71
11103: PUSH
11104: LD_STRING Roth
11106: PPUSH
11107: CALL_OW 25
11111: ST_TO_ADDR
// Simms := PrepareUnit ( Simms , ( not debug ) , 10c_ ) ;
11112: LD_ADDR_EXP 72
11116: PUSH
11117: LD_STRING Simms
11119: PPUSH
11120: LD_EXP 1
11124: NOT
11125: PPUSH
11126: LD_STRING 10c_
11128: PPUSH
11129: CALL 64061 0 3
11133: ST_TO_ADDR
// if not Simms then
11134: LD_EXP 72
11138: NOT
11139: IFFALSE 11169
// begin uc_nation := 1 ;
11141: LD_ADDR_OWVAR 21
11145: PUSH
11146: LD_INT 1
11148: ST_TO_ADDR
// PrepareScientist ( sex_female , 10 ) ;
11149: LD_INT 2
11151: PPUSH
11152: LD_INT 10
11154: PPUSH
11155: CALL_OW 384
// Simms := CreateHuman ;
11159: LD_ADDR_EXP 72
11163: PUSH
11164: CALL_OW 44
11168: ST_TO_ADDR
// end ; uc_nation := 3 ;
11169: LD_ADDR_OWVAR 21
11173: PUSH
11174: LD_INT 3
11176: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
11177: LD_ADDR_EXP 73
11181: PUSH
11182: LD_STRING Kirilenkova
11184: PPUSH
11185: CALL_OW 25
11189: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
11190: LD_ADDR_EXP 87
11194: PUSH
11195: LD_STRING Oblukov
11197: PPUSH
11198: CALL_OW 25
11202: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
11203: LD_ADDR_EXP 74
11207: PUSH
11208: LD_STRING Dolgov
11210: PPUSH
11211: CALL_OW 25
11215: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
11216: LD_ADDR_EXP 75
11220: PUSH
11221: LD_STRING Petrosyan
11223: PPUSH
11224: CALL_OW 25
11228: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
11229: LD_ADDR_EXP 86
11233: PUSH
11234: LD_STRING Scholtze
11236: PPUSH
11237: CALL_OW 25
11241: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
11242: LD_ADDR_EXP 85
11246: PUSH
11247: LD_STRING Kapitsova
11249: PPUSH
11250: CALL_OW 25
11254: ST_TO_ADDR
// Petrovova := NewCharacter ( Petrovova ) ;
11255: LD_ADDR_EXP 76
11259: PUSH
11260: LD_STRING Petrovova
11262: PPUSH
11263: CALL_OW 25
11267: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
11268: LD_ADDR_EXP 77
11272: PUSH
11273: LD_STRING Kuzmov
11275: PPUSH
11276: CALL_OW 25
11280: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
11281: LD_ADDR_EXP 84
11285: PUSH
11286: LD_STRING Karamazov
11288: PPUSH
11289: CALL_OW 25
11293: ST_TO_ADDR
// if LoadVariable ( 13_Lipshchin_1 , 0 ) then
11294: LD_STRING 13_Lipshchin_1
11296: PPUSH
11297: LD_INT 0
11299: PPUSH
11300: CALL_OW 30
11304: IFFALSE 11319
// Lipshchin := NewCharacter ( Lipshchin ) ;
11306: LD_ADDR_EXP 78
11310: PUSH
11311: LD_STRING Lipshchin
11313: PPUSH
11314: CALL_OW 25
11318: ST_TO_ADDR
// if LoadVariable ( 13_Titov_1 , 0 ) then
11319: LD_STRING 13_Titov_1
11321: PPUSH
11322: LD_INT 0
11324: PPUSH
11325: CALL_OW 30
11329: IFFALSE 11344
// Titov := NewCharacter ( Titov ) ;
11331: LD_ADDR_EXP 80
11335: PUSH
11336: LD_STRING Titov
11338: PPUSH
11339: CALL_OW 25
11343: ST_TO_ADDR
// if LoadVariable ( 13_Gnyevko_1 , 0 ) then
11344: LD_STRING 13_Gnyevko_1
11346: PPUSH
11347: LD_INT 0
11349: PPUSH
11350: CALL_OW 30
11354: IFFALSE 11369
// Gnyevko := NewCharacter ( Gnyevko ) ;
11356: LD_ADDR_EXP 79
11360: PUSH
11361: LD_STRING Gnyevko
11363: PPUSH
11364: CALL_OW 25
11368: ST_TO_ADDR
// if LoadVariable ( 13_Xavier_1 , 0 ) then
11369: LD_STRING 13_Xavier_1
11371: PPUSH
11372: LD_INT 0
11374: PPUSH
11375: CALL_OW 30
11379: IFFALSE 11394
// Xavier := NewCharacter ( Xavier2 ) ;
11381: LD_ADDR_EXP 81
11385: PUSH
11386: LD_STRING Xavier2
11388: PPUSH
11389: CALL_OW 25
11393: ST_TO_ADDR
// if LoadVariable ( 13_Belkov_1 , 0 ) then
11394: LD_STRING 13_Belkov_1
11396: PPUSH
11397: LD_INT 0
11399: PPUSH
11400: CALL_OW 30
11404: IFFALSE 11419
// Belkov := NewCharacter ( Belkov ) ;
11406: LD_ADDR_EXP 82
11410: PUSH
11411: LD_STRING Belkov
11413: PPUSH
11414: CALL_OW 25
11418: ST_TO_ADDR
// if not BurlakStatus then
11419: LD_EXP 9
11423: NOT
11424: IFFALSE 11439
// Burlak = NewCharacter ( Burlak ) ;
11426: LD_ADDR_EXP 83
11430: PUSH
11431: LD_STRING Burlak
11433: PPUSH
11434: CALL_OW 25
11438: ST_TO_ADDR
// tmp := [ Roth , Kirilenkova , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova , Petrovova , Kuzmov , Karamazov ] ;
11439: LD_ADDR_VAR 0 3
11443: PUSH
11444: LD_EXP 71
11448: PUSH
11449: LD_EXP 73
11453: PUSH
11454: LD_EXP 87
11458: PUSH
11459: LD_EXP 74
11463: PUSH
11464: LD_EXP 75
11468: PUSH
11469: LD_EXP 86
11473: PUSH
11474: LD_EXP 85
11478: PUSH
11479: LD_EXP 76
11483: PUSH
11484: LD_EXP 77
11488: PUSH
11489: LD_EXP 84
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: LIST
11499: LIST
11500: LIST
11501: LIST
11502: LIST
11503: LIST
11504: LIST
11505: ST_TO_ADDR
// if Simms then
11506: LD_EXP 72
11510: IFFALSE 11528
// tmp := tmp ^ Simms ;
11512: LD_ADDR_VAR 0 3
11516: PUSH
11517: LD_VAR 0 3
11521: PUSH
11522: LD_EXP 72
11526: ADD
11527: ST_TO_ADDR
// if Titov then
11528: LD_EXP 80
11532: IFFALSE 11550
// tmp := tmp ^ Titov ;
11534: LD_ADDR_VAR 0 3
11538: PUSH
11539: LD_VAR 0 3
11543: PUSH
11544: LD_EXP 80
11548: ADD
11549: ST_TO_ADDR
// if Lipshchin then
11550: LD_EXP 78
11554: IFFALSE 11572
// tmp := tmp ^ Lipshchin ;
11556: LD_ADDR_VAR 0 3
11560: PUSH
11561: LD_VAR 0 3
11565: PUSH
11566: LD_EXP 78
11570: ADD
11571: ST_TO_ADDR
// if Gnyevko then
11572: LD_EXP 79
11576: IFFALSE 11594
// tmp := tmp ^ Gnyevko ;
11578: LD_ADDR_VAR 0 3
11582: PUSH
11583: LD_VAR 0 3
11587: PUSH
11588: LD_EXP 79
11592: ADD
11593: ST_TO_ADDR
// if Xavier then
11594: LD_EXP 81
11598: IFFALSE 11616
// tmp := tmp ^ Xavier ;
11600: LD_ADDR_VAR 0 3
11604: PUSH
11605: LD_VAR 0 3
11609: PUSH
11610: LD_EXP 81
11614: ADD
11615: ST_TO_ADDR
// if Belkov then
11616: LD_EXP 82
11620: IFFALSE 11638
// tmp := tmp ^ Belkov ;
11622: LD_ADDR_VAR 0 3
11626: PUSH
11627: LD_VAR 0 3
11631: PUSH
11632: LD_EXP 82
11636: ADD
11637: ST_TO_ADDR
// if Burlak then
11638: LD_EXP 83
11642: IFFALSE 11660
// tmp := tmp ^ Burlak ;
11644: LD_ADDR_VAR 0 3
11648: PUSH
11649: LD_VAR 0 3
11653: PUSH
11654: LD_EXP 83
11658: ADD
11659: ST_TO_ADDR
// for i = 1 to 8 do
11660: LD_ADDR_VAR 0 2
11664: PUSH
11665: DOUBLE
11666: LD_INT 1
11668: DEC
11669: ST_TO_ADDR
11670: LD_INT 8
11672: PUSH
11673: FOR_TO
11674: IFFALSE 11740
// begin uc_nation := [ 1 , 3 ] [ rand ( 1 , 2 ) ] ;
11676: LD_ADDR_OWVAR 21
11680: PUSH
11681: LD_INT 1
11683: PUSH
11684: LD_INT 3
11686: PUSH
11687: EMPTY
11688: LIST
11689: LIST
11690: PUSH
11691: LD_INT 1
11693: PPUSH
11694: LD_INT 2
11696: PPUSH
11697: CALL_OW 12
11701: ARRAY
11702: ST_TO_ADDR
// PrepareHuman ( false , i div 2 , 10 ) ;
11703: LD_INT 0
11705: PPUSH
11706: LD_VAR 0 2
11710: PUSH
11711: LD_INT 2
11713: DIV
11714: PPUSH
11715: LD_INT 10
11717: PPUSH
11718: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
11722: LD_ADDR_VAR 0 3
11726: PUSH
11727: LD_VAR 0 3
11731: PUSH
11732: CALL_OW 44
11736: ADD
11737: ST_TO_ADDR
// end ;
11738: GO 11673
11740: POP
11741: POP
// for i in tmp do
11742: LD_ADDR_VAR 0 2
11746: PUSH
11747: LD_VAR 0 3
11751: PUSH
11752: FOR_IN
11753: IFFALSE 11778
// PlaceUnitXYR ( i , 260 , 235 , 8 , false ) ;
11755: LD_VAR 0 2
11759: PPUSH
11760: LD_INT 260
11762: PPUSH
11763: LD_INT 235
11765: PPUSH
11766: LD_INT 8
11768: PPUSH
11769: LD_INT 0
11771: PPUSH
11772: CALL_OW 50
11776: GO 11752
11778: POP
11779: POP
// mc_bases := Replace ( mc_bases , 1 , FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff [ Roth , Simms ] ) ;
11780: LD_ADDR_EXP 99
11784: PUSH
11785: LD_EXP 99
11789: PPUSH
11790: LD_INT 1
11792: PPUSH
11793: LD_INT 22
11795: PUSH
11796: LD_VAR 0 5
11800: PUSH
11801: EMPTY
11802: LIST
11803: LIST
11804: PUSH
11805: LD_INT 3
11807: PUSH
11808: LD_INT 21
11810: PUSH
11811: LD_INT 2
11813: PUSH
11814: EMPTY
11815: LIST
11816: LIST
11817: PUSH
11818: EMPTY
11819: LIST
11820: LIST
11821: PUSH
11822: EMPTY
11823: LIST
11824: LIST
11825: PPUSH
11826: CALL_OW 69
11830: PUSH
11831: LD_EXP 71
11835: PUSH
11836: LD_EXP 72
11840: PUSH
11841: EMPTY
11842: LIST
11843: LIST
11844: DIFF
11845: PPUSH
11846: CALL_OW 1
11850: ST_TO_ADDR
// uc_side := 0 ;
11851: LD_ADDR_OWVAR 20
11855: PUSH
11856: LD_INT 0
11858: ST_TO_ADDR
// uc_nation := 0 ;
11859: LD_ADDR_OWVAR 21
11863: PUSH
11864: LD_INT 0
11866: ST_TO_ADDR
// for i = 1 to 5 do
11867: LD_ADDR_VAR 0 2
11871: PUSH
11872: DOUBLE
11873: LD_INT 1
11875: DEC
11876: ST_TO_ADDR
11877: LD_INT 5
11879: PUSH
11880: FOR_TO
11881: IFFALSE 11918
// begin InitHc ;
11883: CALL_OW 19
// hc_class := class_apeman ;
11887: LD_ADDR_OWVAR 28
11891: PUSH
11892: LD_INT 12
11894: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , 299 , 229 , 10 , false ) ;
11895: CALL_OW 44
11899: PPUSH
11900: LD_INT 299
11902: PPUSH
11903: LD_INT 229
11905: PPUSH
11906: LD_INT 10
11908: PPUSH
11909: LD_INT 0
11911: PPUSH
11912: CALL_OW 50
// end ;
11916: GO 11880
11918: POP
11919: POP
// ComMoveXY ( Roth , 259 , 235 ) ;
11920: LD_EXP 71
11924: PPUSH
11925: LD_INT 259
11927: PPUSH
11928: LD_INT 235
11930: PPUSH
11931: CALL_OW 111
// AddComTurnXY ( Roth , 262 , 235 ) ;
11935: LD_EXP 71
11939: PPUSH
11940: LD_INT 262
11942: PPUSH
11943: LD_INT 235
11945: PPUSH
11946: CALL_OW 178
// if Simms then
11950: LD_EXP 72
11954: IFFALSE 11985
// begin ComMoveXY ( Simms , 262 , 235 ) ;
11956: LD_EXP 72
11960: PPUSH
11961: LD_INT 262
11963: PPUSH
11964: LD_INT 235
11966: PPUSH
11967: CALL_OW 111
// AddComTurnUnit ( Simms , Roth ) ;
11971: LD_EXP 72
11975: PPUSH
11976: LD_EXP 71
11980: PPUSH
11981: CALL_OW 179
// end ; end ;
11985: LD_VAR 0 1
11989: RET
// every 4 4$00 trigger allianceActive and not allianceDestroyed do var i , tmp , target ;
11990: LD_EXP 31
11994: PUSH
11995: LD_EXP 23
11999: NOT
12000: AND
12001: IFFALSE 12177
12003: GO 12005
12005: DISABLE
12006: LD_INT 0
12008: PPUSH
12009: PPUSH
12010: PPUSH
// begin enable ;
12011: ENABLE
// tmp := FilterAllUnits ( [ [ f_enemy , 7 ] , [ f_or , [ f_engine , engine_siberite ] , [ f_btype , b_siberite_mine ] , [ f_btype , b_siberite_power ] , [ f_weapon , ru_time_lapser ] , [ f_weapon , us_double_laser ] , [ f_weapon , us_siberium_rocket ] ] ] ) ;
12012: LD_ADDR_VAR 0 2
12016: PUSH
12017: LD_INT 81
12019: PUSH
12020: LD_INT 7
12022: PUSH
12023: EMPTY
12024: LIST
12025: LIST
12026: PUSH
12027: LD_INT 2
12029: PUSH
12030: LD_INT 32
12032: PUSH
12033: LD_INT 3
12035: PUSH
12036: EMPTY
12037: LIST
12038: LIST
12039: PUSH
12040: LD_INT 30
12042: PUSH
12043: LD_INT 30
12045: PUSH
12046: EMPTY
12047: LIST
12048: LIST
12049: PUSH
12050: LD_INT 30
12052: PUSH
12053: LD_INT 28
12055: PUSH
12056: EMPTY
12057: LIST
12058: LIST
12059: PUSH
12060: LD_INT 34
12062: PUSH
12063: LD_INT 49
12065: PUSH
12066: EMPTY
12067: LIST
12068: LIST
12069: PUSH
12070: LD_INT 34
12072: PUSH
12073: LD_INT 10
12075: PUSH
12076: EMPTY
12077: LIST
12078: LIST
12079: PUSH
12080: LD_INT 34
12082: PUSH
12083: LD_INT 8
12085: PUSH
12086: EMPTY
12087: LIST
12088: LIST
12089: PUSH
12090: EMPTY
12091: LIST
12092: LIST
12093: LIST
12094: LIST
12095: LIST
12096: LIST
12097: LIST
12098: PUSH
12099: EMPTY
12100: LIST
12101: LIST
12102: PPUSH
12103: CALL_OW 69
12107: ST_TO_ADDR
// if not tmp then
12108: LD_VAR 0 2
12112: NOT
12113: IFFALSE 12117
// exit ;
12115: GO 12177
// target := tmp [ rand ( 1 , tmp ) ] ;
12117: LD_ADDR_VAR 0 3
12121: PUSH
12122: LD_VAR 0 2
12126: PUSH
12127: LD_INT 1
12129: PPUSH
12130: LD_VAR 0 2
12134: PPUSH
12135: CALL_OW 12
12139: ARRAY
12140: ST_TO_ADDR
// if GetSide ( target ) = 1 then
12141: LD_VAR 0 3
12145: PPUSH
12146: CALL_OW 255
12150: PUSH
12151: LD_INT 1
12153: EQUAL
12154: IFFALSE 12165
// CenterNowOnUnits ( target ) ;
12156: LD_VAR 0 3
12160: PPUSH
12161: CALL_OW 87
// SetLives ( target , 0 ) ;
12165: LD_VAR 0 3
12169: PPUSH
12170: LD_INT 0
12172: PPUSH
12173: CALL_OW 234
// end ;
12177: PPOPN 3
12179: END
// every 0 0$2 trigger not allianceDestroyed and allianceActive do var i , un , tmp ;
12180: LD_EXP 23
12184: NOT
12185: PUSH
12186: LD_EXP 31
12190: AND
12191: IFFALSE 12713
12193: GO 12195
12195: DISABLE
12196: LD_INT 0
12198: PPUSH
12199: PPUSH
12200: PPUSH
// begin uc_side := 7 ;
12201: LD_ADDR_OWVAR 20
12205: PUSH
12206: LD_INT 7
12208: ST_TO_ADDR
// uc_nation := 1 ;
12209: LD_ADDR_OWVAR 21
12213: PUSH
12214: LD_INT 1
12216: ST_TO_ADDR
// tmp := Shuffle ( [ [ 125 , 163 ] , [ 185 , 168 ] , [ 111 , 97 ] ] ) ;
12217: LD_ADDR_VAR 0 3
12221: PUSH
12222: LD_INT 125
12224: PUSH
12225: LD_INT 163
12227: PUSH
12228: EMPTY
12229: LIST
12230: LIST
12231: PUSH
12232: LD_INT 185
12234: PUSH
12235: LD_INT 168
12237: PUSH
12238: EMPTY
12239: LIST
12240: LIST
12241: PUSH
12242: LD_INT 111
12244: PUSH
12245: LD_INT 97
12247: PUSH
12248: EMPTY
12249: LIST
12250: LIST
12251: PUSH
12252: EMPTY
12253: LIST
12254: LIST
12255: LIST
12256: PPUSH
12257: CALL 106924 0 1
12261: ST_TO_ADDR
// allianceSpecialForce := [ ] ;
12262: LD_ADDR_EXP 88
12266: PUSH
12267: EMPTY
12268: ST_TO_ADDR
// for i = 1 to Difficulty do
12269: LD_ADDR_VAR 0 1
12273: PUSH
12274: DOUBLE
12275: LD_INT 1
12277: DEC
12278: ST_TO_ADDR
12279: LD_OWVAR 67
12283: PUSH
12284: FOR_TO
12285: IFFALSE 12443
// begin InitHc ;
12287: CALL_OW 19
// PrepareSoldier ( false , 8 ) ;
12291: LD_INT 0
12293: PPUSH
12294: LD_INT 8
12296: PPUSH
12297: CALL_OW 381
// un := CreateHuman ;
12301: LD_ADDR_VAR 0 2
12305: PUSH
12306: CALL_OW 44
12310: ST_TO_ADDR
// PlaceUnitXYR ( un , 258 , 267 , 4 , false ) ;
12311: LD_VAR 0 2
12315: PPUSH
12316: LD_INT 258
12318: PPUSH
12319: LD_INT 267
12321: PPUSH
12322: LD_INT 4
12324: PPUSH
12325: LD_INT 0
12327: PPUSH
12328: CALL_OW 50
// allianceSpecialForce := allianceSpecialForce union un ;
12332: LD_ADDR_EXP 88
12336: PUSH
12337: LD_EXP 88
12341: PUSH
12342: LD_VAR 0 2
12346: UNION
12347: ST_TO_ADDR
// TeleportUnit ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] , 4 , true ) ;
12348: LD_VAR 0 2
12352: PPUSH
12353: LD_VAR 0 3
12357: PUSH
12358: LD_VAR 0 1
12362: ARRAY
12363: PUSH
12364: LD_INT 1
12366: ARRAY
12367: PPUSH
12368: LD_VAR 0 3
12372: PUSH
12373: LD_VAR 0 1
12377: ARRAY
12378: PUSH
12379: LD_INT 2
12381: ARRAY
12382: PPUSH
12383: LD_INT 4
12385: PPUSH
12386: LD_INT 1
12388: PPUSH
12389: CALL_OW 483
// AddComMoveXY ( un , tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) ;
12393: LD_VAR 0 2
12397: PPUSH
12398: LD_VAR 0 3
12402: PUSH
12403: LD_VAR 0 1
12407: ARRAY
12408: PUSH
12409: LD_INT 1
12411: ARRAY
12412: PPUSH
12413: LD_VAR 0 3
12417: PUSH
12418: LD_VAR 0 1
12422: ARRAY
12423: PUSH
12424: LD_INT 2
12426: ARRAY
12427: PPUSH
12428: CALL_OW 171
// AddComInvisible ( un ) ;
12432: LD_VAR 0 2
12436: PPUSH
12437: CALL_OW 212
// end ;
12441: GO 12284
12443: POP
12444: POP
// repeat wait ( 0 0$20 ) ;
12445: LD_INT 700
12447: PPUSH
12448: CALL_OW 67
// for i in allianceSpecialForce do
12452: LD_ADDR_VAR 0 1
12456: PUSH
12457: LD_EXP 88
12461: PUSH
12462: FOR_IN
12463: IFFALSE 12698
// begin if IsInvisible ( i ) then
12465: LD_VAR 0 1
12469: PPUSH
12470: CALL_OW 571
12474: IFFALSE 12667
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_ok ] , [ f_outside ] , [ f_dist , i , [ 25 , 30 , 35 ] [ Difficulty ] ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) ;
12476: LD_ADDR_VAR 0 3
12480: PUSH
12481: LD_INT 22
12483: PUSH
12484: LD_INT 1
12486: PUSH
12487: EMPTY
12488: LIST
12489: LIST
12490: PUSH
12491: LD_INT 50
12493: PUSH
12494: EMPTY
12495: LIST
12496: PUSH
12497: LD_INT 56
12499: PUSH
12500: EMPTY
12501: LIST
12502: PUSH
12503: LD_INT 91
12505: PUSH
12506: LD_VAR 0 1
12510: PUSH
12511: LD_INT 25
12513: PUSH
12514: LD_INT 30
12516: PUSH
12517: LD_INT 35
12519: PUSH
12520: EMPTY
12521: LIST
12522: LIST
12523: LIST
12524: PUSH
12525: LD_OWVAR 67
12529: ARRAY
12530: PUSH
12531: EMPTY
12532: LIST
12533: LIST
12534: LIST
12535: PUSH
12536: LD_INT 2
12538: PUSH
12539: LD_INT 25
12541: PUSH
12542: LD_INT 1
12544: PUSH
12545: EMPTY
12546: LIST
12547: LIST
12548: PUSH
12549: LD_INT 25
12551: PUSH
12552: LD_INT 2
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: PUSH
12559: LD_INT 25
12561: PUSH
12562: LD_INT 3
12564: PUSH
12565: EMPTY
12566: LIST
12567: LIST
12568: PUSH
12569: LD_INT 25
12571: PUSH
12572: LD_INT 4
12574: PUSH
12575: EMPTY
12576: LIST
12577: LIST
12578: PUSH
12579: LD_INT 25
12581: PUSH
12582: LD_INT 5
12584: PUSH
12585: EMPTY
12586: LIST
12587: LIST
12588: PUSH
12589: LD_INT 25
12591: PUSH
12592: LD_INT 8
12594: PUSH
12595: EMPTY
12596: LIST
12597: LIST
12598: PUSH
12599: EMPTY
12600: LIST
12601: LIST
12602: LIST
12603: LIST
12604: LIST
12605: LIST
12606: LIST
12607: PUSH
12608: EMPTY
12609: LIST
12610: LIST
12611: LIST
12612: LIST
12613: LIST
12614: PPUSH
12615: CALL_OW 69
12619: ST_TO_ADDR
// if not tmp then
12620: LD_VAR 0 3
12624: NOT
12625: IFFALSE 12629
// continue ;
12627: GO 12462
// if Prob ( 30 * Difficulty ) then
12629: LD_INT 30
12631: PUSH
12632: LD_OWVAR 67
12636: MUL
12637: PPUSH
12638: CALL_OW 13
12642: IFFALSE 12667
// AllianceCaptureUnit ( tmp [ rand ( 1 , tmp ) ] ) ;
12644: LD_VAR 0 3
12648: PUSH
12649: LD_INT 1
12651: PPUSH
12652: LD_VAR 0 3
12656: PPUSH
12657: CALL_OW 12
12661: ARRAY
12662: PPUSH
12663: CALL 30124 0 1
// end ; if IsDead ( i ) then
12667: LD_VAR 0 1
12671: PPUSH
12672: CALL_OW 301
12676: IFFALSE 12696
// begin allianceSpecialForce := allianceSpecialForce diff i ;
12678: LD_ADDR_EXP 88
12682: PUSH
12683: LD_EXP 88
12687: PUSH
12688: LD_VAR 0 1
12692: DIFF
12693: ST_TO_ADDR
// continue ;
12694: GO 12462
// end ; end ;
12696: GO 12462
12698: POP
12699: POP
// until allianceDestroyed or not allianceSpecialForce ;
12700: LD_EXP 23
12704: PUSH
12705: LD_EXP 88
12709: NOT
12710: OR
12711: IFFALSE 12445
// end ;
12713: PPOPN 3
12715: END
// every 12 12$30 trigger not allianceDestroyed and allianceActive and not MC_GetVehicles ( 1 , true ) do var i , tmp , target , teleport ;
12716: LD_EXP 23
12720: NOT
12721: PUSH
12722: LD_EXP 31
12726: AND
12727: PUSH
12728: LD_INT 1
12730: PPUSH
12731: LD_INT 1
12733: PPUSH
12734: CALL 59135 0 2
12738: NOT
12739: AND
12740: IFFALSE 13707
12742: GO 12744
12744: DISABLE
12745: LD_INT 0
12747: PPUSH
12748: PPUSH
12749: PPUSH
12750: PPUSH
// begin enable ;
12751: ENABLE
// if not FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_factory ] ] ) then
12752: LD_INT 22
12754: PUSH
12755: LD_INT 7
12757: PUSH
12758: EMPTY
12759: LIST
12760: LIST
12761: PUSH
12762: LD_INT 30
12764: PUSH
12765: LD_INT 3
12767: PUSH
12768: EMPTY
12769: LIST
12770: LIST
12771: PUSH
12772: EMPTY
12773: LIST
12774: LIST
12775: PPUSH
12776: CALL_OW 69
12780: NOT
12781: IFFALSE 12785
// exit ;
12783: GO 13707
// teleport := FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_teleport ] ] ) ;
12785: LD_ADDR_VAR 0 4
12789: PUSH
12790: LD_INT 22
12792: PUSH
12793: LD_INT 7
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 30
12802: PUSH
12803: LD_INT 34
12805: PUSH
12806: EMPTY
12807: LIST
12808: LIST
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PPUSH
12814: CALL_OW 69
12818: ST_TO_ADDR
// if Prob ( 40 ) then
12819: LD_INT 40
12821: PPUSH
12822: CALL_OW 13
12826: IFFALSE 12953
// begin MC_InsertProduceList ( 1 , [ [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ us_morphling , engine_siberite , control_remote , us_heavy_gun ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket_launcher ] ] ) ;
12828: LD_INT 1
12830: PPUSH
12831: LD_INT 5
12833: PUSH
12834: LD_INT 3
12836: PUSH
12837: LD_INT 2
12839: PUSH
12840: LD_INT 6
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: LIST
12848: PUSH
12849: LD_INT 5
12851: PUSH
12852: LD_INT 3
12854: PUSH
12855: LD_INT 2
12857: PUSH
12858: LD_INT 6
12860: PUSH
12861: EMPTY
12862: LIST
12863: LIST
12864: LIST
12865: LIST
12866: PUSH
12867: LD_INT 5
12869: PUSH
12870: LD_INT 3
12872: PUSH
12873: LD_INT 2
12875: PUSH
12876: LD_INT 6
12878: PUSH
12879: EMPTY
12880: LIST
12881: LIST
12882: LIST
12883: LIST
12884: PUSH
12885: LD_INT 24
12887: PUSH
12888: LD_INT 3
12890: PUSH
12891: LD_INT 3
12893: PUSH
12894: LD_INT 45
12896: PUSH
12897: EMPTY
12898: LIST
12899: LIST
12900: LIST
12901: LIST
12902: PUSH
12903: LD_INT 24
12905: PUSH
12906: LD_INT 3
12908: PUSH
12909: LD_INT 3
12911: PUSH
12912: LD_INT 47
12914: PUSH
12915: EMPTY
12916: LIST
12917: LIST
12918: LIST
12919: LIST
12920: PUSH
12921: LD_INT 24
12923: PUSH
12924: LD_INT 3
12926: PUSH
12927: LD_INT 3
12929: PUSH
12930: LD_INT 45
12932: PUSH
12933: EMPTY
12934: LIST
12935: LIST
12936: LIST
12937: LIST
12938: PUSH
12939: EMPTY
12940: LIST
12941: LIST
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: PPUSH
12947: CALL 57717 0 2
// end else
12951: GO 13076
// begin MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ us_morphling , engine_siberite , control_remote , us_laser ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , ] ) ;
12953: LD_INT 1
12955: PPUSH
12956: LD_INT 24
12958: PUSH
12959: LD_INT 3
12961: PUSH
12962: LD_INT 3
12964: PUSH
12965: LD_INT 47
12967: PUSH
12968: EMPTY
12969: LIST
12970: LIST
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 24
12976: PUSH
12977: LD_INT 3
12979: PUSH
12980: LD_INT 3
12982: PUSH
12983: LD_INT 47
12985: PUSH
12986: EMPTY
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: PUSH
12992: LD_INT 5
12994: PUSH
12995: LD_INT 3
12997: PUSH
12998: LD_INT 2
13000: PUSH
13001: LD_INT 9
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: LIST
13008: LIST
13009: PUSH
13010: LD_INT 5
13012: PUSH
13013: LD_INT 3
13015: PUSH
13016: LD_INT 2
13018: PUSH
13019: LD_INT 9
13021: PUSH
13022: EMPTY
13023: LIST
13024: LIST
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 24
13030: PUSH
13031: LD_INT 1
13033: PUSH
13034: LD_INT 3
13036: PUSH
13037: LD_INT 45
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: LIST
13044: LIST
13045: PUSH
13046: LD_INT 24
13048: PUSH
13049: LD_INT 1
13051: PUSH
13052: LD_INT 3
13054: PUSH
13055: LD_INT 45
13057: PUSH
13058: EMPTY
13059: LIST
13060: LIST
13061: LIST
13062: LIST
13063: PUSH
13064: EMPTY
13065: LIST
13066: LIST
13067: LIST
13068: LIST
13069: LIST
13070: LIST
13071: PPUSH
13072: CALL 57717 0 2
// end ; if Difficulty > 1 then
13076: LD_OWVAR 67
13080: PUSH
13081: LD_INT 1
13083: GREATER
13084: IFFALSE 13114
// MC_InsertProduceList ( 1 , [ [ ru_heavy_tracked , engine_siberite , control_computer , ru_rocket ] ] ) ;
13086: LD_INT 1
13088: PPUSH
13089: LD_INT 24
13091: PUSH
13092: LD_INT 3
13094: PUSH
13095: LD_INT 3
13097: PUSH
13098: LD_INT 47
13100: PUSH
13101: EMPTY
13102: LIST
13103: LIST
13104: LIST
13105: LIST
13106: PUSH
13107: EMPTY
13108: LIST
13109: PPUSH
13110: CALL 57717 0 2
// repeat wait ( 0 0$1 ) ;
13114: LD_INT 35
13116: PPUSH
13117: CALL_OW 67
// until MC_GetVehicles ( 1 , true ) >= [ 6 , 7 , 7 ] [ Difficulty ] ;
13121: LD_INT 1
13123: PPUSH
13124: LD_INT 1
13126: PPUSH
13127: CALL 59135 0 2
13131: PUSH
13132: LD_INT 6
13134: PUSH
13135: LD_INT 7
13137: PUSH
13138: LD_INT 7
13140: PUSH
13141: EMPTY
13142: LIST
13143: LIST
13144: LIST
13145: PUSH
13146: LD_OWVAR 67
13150: ARRAY
13151: GREATEREQUAL
13152: IFFALSE 13114
// wait ( 0 0$40 ) ;
13154: LD_INT 1400
13156: PPUSH
13157: CALL_OW 67
// tmp := MC_GetVehicles ( 1 , true ) ;
13161: LD_ADDR_VAR 0 2
13165: PUSH
13166: LD_INT 1
13168: PPUSH
13169: LD_INT 1
13171: PPUSH
13172: CALL 59135 0 2
13176: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , 1 , mc_vehicles [ 1 ] diff tmp ) ;
13177: LD_ADDR_EXP 118
13181: PUSH
13182: LD_EXP 118
13186: PPUSH
13187: LD_INT 1
13189: PPUSH
13190: LD_EXP 118
13194: PUSH
13195: LD_INT 1
13197: ARRAY
13198: PUSH
13199: LD_VAR 0 2
13203: DIFF
13204: PPUSH
13205: CALL_OW 1
13209: ST_TO_ADDR
// target := rand ( 0 , 1 ) ;
13210: LD_ADDR_VAR 0 3
13214: PUSH
13215: LD_INT 0
13217: PPUSH
13218: LD_INT 1
13220: PPUSH
13221: CALL_OW 12
13225: ST_TO_ADDR
// if target then
13226: LD_VAR 0 3
13230: IFFALSE 13396
// begin for i in tmp do
13232: LD_ADDR_VAR 0 1
13236: PUSH
13237: LD_VAR 0 2
13241: PUSH
13242: FOR_IN
13243: IFFALSE 13268
// TeleportUnit ( i , 179 , 209 , 8 , true ) ;
13245: LD_VAR 0 1
13249: PPUSH
13250: LD_INT 179
13252: PPUSH
13253: LD_INT 209
13255: PPUSH
13256: LD_INT 8
13258: PPUSH
13259: LD_INT 1
13261: PPUSH
13262: CALL_OW 483
13266: GO 13242
13268: POP
13269: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13270: LD_ADDR_VAR 0 2
13274: PUSH
13275: LD_VAR 0 2
13279: PPUSH
13280: LD_INT 24
13282: PUSH
13283: LD_INT 250
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: PPUSH
13290: CALL_OW 72
13294: ST_TO_ADDR
// for i in tmp do
13295: LD_ADDR_VAR 0 1
13299: PUSH
13300: LD_VAR 0 2
13304: PUSH
13305: FOR_IN
13306: IFFALSE 13346
// if GetDistUnitXY ( i , 179 , 209 ) > 9 then
13308: LD_VAR 0 1
13312: PPUSH
13313: LD_INT 179
13315: PPUSH
13316: LD_INT 209
13318: PPUSH
13319: CALL_OW 297
13323: PUSH
13324: LD_INT 9
13326: GREATER
13327: IFFALSE 13344
// ComMoveXY ( i , 179 , 209 ) ;
13329: LD_VAR 0 1
13333: PPUSH
13334: LD_INT 179
13336: PPUSH
13337: LD_INT 209
13339: PPUSH
13340: CALL_OW 111
13344: GO 13305
13346: POP
13347: POP
// wait ( 0 0$1 ) ;
13348: LD_INT 35
13350: PPUSH
13351: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 179 , 209 , 9 ] ) >= ( tmp - 1 ) ;
13355: LD_VAR 0 2
13359: PPUSH
13360: LD_INT 92
13362: PUSH
13363: LD_INT 179
13365: PUSH
13366: LD_INT 209
13368: PUSH
13369: LD_INT 9
13371: PUSH
13372: EMPTY
13373: LIST
13374: LIST
13375: LIST
13376: LIST
13377: PPUSH
13378: CALL_OW 72
13382: PUSH
13383: LD_VAR 0 2
13387: PUSH
13388: LD_INT 1
13390: MINUS
13391: GREATEREQUAL
13392: IFFALSE 13270
// end else
13394: GO 13558
// begin for i in tmp do
13396: LD_ADDR_VAR 0 1
13400: PUSH
13401: LD_VAR 0 2
13405: PUSH
13406: FOR_IN
13407: IFFALSE 13432
// TeleportUnit ( i , 285 , 163 , 8 , true ) ;
13409: LD_VAR 0 1
13413: PPUSH
13414: LD_INT 285
13416: PPUSH
13417: LD_INT 163
13419: PPUSH
13420: LD_INT 8
13422: PPUSH
13423: LD_INT 1
13425: PPUSH
13426: CALL_OW 483
13430: GO 13406
13432: POP
13433: POP
// repeat tmp := UnitFilter ( tmp , [ f_lives , 250 ] ) ;
13434: LD_ADDR_VAR 0 2
13438: PUSH
13439: LD_VAR 0 2
13443: PPUSH
13444: LD_INT 24
13446: PUSH
13447: LD_INT 250
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PPUSH
13454: CALL_OW 72
13458: ST_TO_ADDR
// for i in tmp do
13459: LD_ADDR_VAR 0 1
13463: PUSH
13464: LD_VAR 0 2
13468: PUSH
13469: FOR_IN
13470: IFFALSE 13510
// if GetDistUnitXY ( i , 285 , 163 ) > 9 then
13472: LD_VAR 0 1
13476: PPUSH
13477: LD_INT 285
13479: PPUSH
13480: LD_INT 163
13482: PPUSH
13483: CALL_OW 297
13487: PUSH
13488: LD_INT 9
13490: GREATER
13491: IFFALSE 13508
// ComMoveXY ( i , 285 , 163 ) ;
13493: LD_VAR 0 1
13497: PPUSH
13498: LD_INT 285
13500: PPUSH
13501: LD_INT 163
13503: PPUSH
13504: CALL_OW 111
13508: GO 13469
13510: POP
13511: POP
// wait ( 0 0$1 ) ;
13512: LD_INT 35
13514: PPUSH
13515: CALL_OW 67
// until UnitFilter ( tmp , [ f_distxy , 285 , 163 , 9 ] ) >= ( tmp - 1 ) ;
13519: LD_VAR 0 2
13523: PPUSH
13524: LD_INT 92
13526: PUSH
13527: LD_INT 285
13529: PUSH
13530: LD_INT 163
13532: PUSH
13533: LD_INT 9
13535: PUSH
13536: EMPTY
13537: LIST
13538: LIST
13539: LIST
13540: LIST
13541: PPUSH
13542: CALL_OW 72
13546: PUSH
13547: LD_VAR 0 2
13551: PUSH
13552: LD_INT 1
13554: MINUS
13555: GREATEREQUAL
13556: IFFALSE 13434
// end ; repeat wait ( 0 0$1 ) ;
13558: LD_INT 35
13560: PPUSH
13561: CALL_OW 67
// for i in tmp do
13565: LD_ADDR_VAR 0 1
13569: PUSH
13570: LD_VAR 0 2
13574: PUSH
13575: FOR_IN
13576: IFFALSE 13698
// if GetLives ( i ) > 251 then
13578: LD_VAR 0 1
13582: PPUSH
13583: CALL_OW 256
13587: PUSH
13588: LD_INT 251
13590: GREATER
13591: IFFALSE 13680
// begin if GetWeapon ( i ) = ru_time_lapser then
13593: LD_VAR 0 1
13597: PPUSH
13598: CALL_OW 264
13602: PUSH
13603: LD_INT 49
13605: EQUAL
13606: IFFALSE 13644
// ComMoveUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) else
13608: LD_VAR 0 1
13612: PPUSH
13613: LD_INT 81
13615: PUSH
13616: LD_INT 7
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: PPUSH
13623: CALL_OW 69
13627: PPUSH
13628: LD_VAR 0 1
13632: PPUSH
13633: CALL_OW 74
13637: PPUSH
13638: CALL_OW 112
13642: GO 13678
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 7 ] ) , i ) ) ;
13644: LD_VAR 0 1
13648: PPUSH
13649: LD_INT 81
13651: PUSH
13652: LD_INT 7
13654: PUSH
13655: EMPTY
13656: LIST
13657: LIST
13658: PPUSH
13659: CALL_OW 69
13663: PPUSH
13664: LD_VAR 0 1
13668: PPUSH
13669: CALL_OW 74
13673: PPUSH
13674: CALL_OW 115
// end else
13678: GO 13696
// tmp := tmp diff i ;
13680: LD_ADDR_VAR 0 2
13684: PUSH
13685: LD_VAR 0 2
13689: PUSH
13690: LD_VAR 0 1
13694: DIFF
13695: ST_TO_ADDR
13696: GO 13575
13698: POP
13699: POP
// until not tmp ;
13700: LD_VAR 0 2
13704: NOT
13705: IFFALSE 13558
// end ; end_of_file
13707: PPOPN 4
13709: END
// export Omar , Heike , Khatam ; export function PrepareOmarInvasion ; var i , veh , un ; begin
13710: LD_INT 0
13712: PPUSH
13713: PPUSH
13714: PPUSH
13715: PPUSH
// missionStage := 13 ;
13716: LD_ADDR_EXP 15
13720: PUSH
13721: LD_INT 13
13723: ST_TO_ADDR
// uc_side := 2 ;
13724: LD_ADDR_OWVAR 20
13728: PUSH
13729: LD_INT 2
13731: ST_TO_ADDR
// uc_nation := 2 ;
13732: LD_ADDR_OWVAR 21
13736: PUSH
13737: LD_INT 2
13739: ST_TO_ADDR
// Omar := NewCharacter ( Omar ) ;
13740: LD_ADDR_EXP 89
13744: PUSH
13745: LD_STRING Omar
13747: PPUSH
13748: CALL_OW 25
13752: ST_TO_ADDR
// SetDir ( Omar , 4 ) ;
13753: LD_EXP 89
13757: PPUSH
13758: LD_INT 4
13760: PPUSH
13761: CALL_OW 233
// PlaceUnitXY ( Omar , 242 , 75 , false ) ;
13765: LD_EXP 89
13769: PPUSH
13770: LD_INT 242
13772: PPUSH
13773: LD_INT 75
13775: PPUSH
13776: LD_INT 0
13778: PPUSH
13779: CALL_OW 48
// Heike := NewCharacter ( Heike ) ;
13783: LD_ADDR_EXP 90
13787: PUSH
13788: LD_STRING Heike
13790: PPUSH
13791: CALL_OW 25
13795: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , ar_gun , 100 ) ;
13796: LD_INT 14
13798: PPUSH
13799: LD_INT 3
13801: PPUSH
13802: LD_INT 1
13804: PPUSH
13805: LD_INT 27
13807: PPUSH
13808: LD_INT 100
13810: PPUSH
13811: CALL 71087 0 5
// veh := CreateVehicle ;
13815: LD_ADDR_VAR 0 3
13819: PUSH
13820: CALL_OW 45
13824: ST_TO_ADDR
// SetMark ( veh , 1 ) ;
13825: LD_VAR 0 3
13829: PPUSH
13830: LD_INT 1
13832: PPUSH
13833: CALL_OW 242
// SetDir ( veh , 4 ) ;
13837: LD_VAR 0 3
13841: PPUSH
13842: LD_INT 4
13844: PPUSH
13845: CALL_OW 233
// PlaceUnitXY ( veh , 241 , 72 , false ) ;
13849: LD_VAR 0 3
13853: PPUSH
13854: LD_INT 241
13856: PPUSH
13857: LD_INT 72
13859: PPUSH
13860: LD_INT 0
13862: PPUSH
13863: CALL_OW 48
// PlaceHumanInUnit ( Heike , veh ) ;
13867: LD_EXP 90
13871: PPUSH
13872: LD_VAR 0 3
13876: PPUSH
13877: CALL_OW 52
// if KhatamStatus then
13881: LD_EXP 8
13885: IFFALSE 13936
// begin Khatam := NewCharacter ( Khatam ) ;
13887: LD_ADDR_EXP 91
13891: PUSH
13892: LD_STRING Khatam
13894: PPUSH
13895: CALL_OW 25
13899: ST_TO_ADDR
// PlaceUnitXYR ( Khatam , 245 , 78 , 3 , false ) ;
13900: LD_EXP 91
13904: PPUSH
13905: LD_INT 245
13907: PPUSH
13908: LD_INT 78
13910: PPUSH
13911: LD_INT 3
13913: PPUSH
13914: LD_INT 0
13916: PPUSH
13917: CALL_OW 50
// SetSkill ( Khatam , 4 , 10 ) ;
13921: LD_EXP 91
13925: PPUSH
13926: LD_INT 4
13928: PPUSH
13929: LD_INT 10
13931: PPUSH
13932: CALL_OW 237
// end ; for i = 1 to Difficulty do
13936: LD_ADDR_VAR 0 2
13940: PUSH
13941: DOUBLE
13942: LD_INT 1
13944: DEC
13945: ST_TO_ADDR
13946: LD_OWVAR 67
13950: PUSH
13951: FOR_TO
13952: IFFALSE 14018
// begin PrepareScientist ( false , 7 + Difficulty ) ;
13954: LD_INT 0
13956: PPUSH
13957: LD_INT 7
13959: PUSH
13960: LD_OWVAR 67
13964: PLUS
13965: PPUSH
13966: CALL_OW 384
// un := CreateHuman ;
13970: LD_ADDR_VAR 0 4
13974: PUSH
13975: CALL_OW 44
13979: ST_TO_ADDR
// PlaceUnitArea ( un , [ arabianAttackArea , arabianAttackArea2 ] [ i mod 2 + 1 ] , false ) ;
13980: LD_VAR 0 4
13984: PPUSH
13985: LD_INT 28
13987: PUSH
13988: LD_INT 29
13990: PUSH
13991: EMPTY
13992: LIST
13993: LIST
13994: PUSH
13995: LD_VAR 0 2
13999: PUSH
14000: LD_INT 2
14002: MOD
14003: PUSH
14004: LD_INT 1
14006: PLUS
14007: ARRAY
14008: PPUSH
14009: LD_INT 0
14011: PPUSH
14012: CALL_OW 49
// end ;
14016: GO 13951
14018: POP
14019: POP
// for i = 1 to 6 do
14020: LD_ADDR_VAR 0 2
14024: PUSH
14025: DOUBLE
14026: LD_INT 1
14028: DEC
14029: ST_TO_ADDR
14030: LD_INT 6
14032: PUSH
14033: FOR_TO
14034: IFFALSE 14079
// begin PrepareSoldier ( false , 7 + Difficulty ) ;
14036: LD_INT 0
14038: PPUSH
14039: LD_INT 7
14041: PUSH
14042: LD_OWVAR 67
14046: PLUS
14047: PPUSH
14048: CALL_OW 381
// un := CreateHuman ;
14052: LD_ADDR_VAR 0 4
14056: PUSH
14057: CALL_OW 44
14061: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14062: LD_VAR 0 4
14066: PPUSH
14067: LD_INT 28
14069: PPUSH
14070: LD_INT 0
14072: PPUSH
14073: CALL_OW 49
// end ;
14077: GO 14033
14079: POP
14080: POP
// for i = 1 to 3 do
14081: LD_ADDR_VAR 0 2
14085: PUSH
14086: DOUBLE
14087: LD_INT 1
14089: DEC
14090: ST_TO_ADDR
14091: LD_INT 3
14093: PUSH
14094: FOR_TO
14095: IFFALSE 14143
// begin PrepareHuman ( false , class_mortar , 7 + Difficulty ) ;
14097: LD_INT 0
14099: PPUSH
14100: LD_INT 8
14102: PPUSH
14103: LD_INT 7
14105: PUSH
14106: LD_OWVAR 67
14110: PLUS
14111: PPUSH
14112: CALL_OW 380
// un := CreateHuman ;
14116: LD_ADDR_VAR 0 4
14120: PUSH
14121: CALL_OW 44
14125: ST_TO_ADDR
// PlaceUnitArea ( un , arabianAttackArea , false ) ;
14126: LD_VAR 0 4
14130: PPUSH
14131: LD_INT 28
14133: PPUSH
14134: LD_INT 0
14136: PPUSH
14137: CALL_OW 49
// end ;
14141: GO 14094
14143: POP
14144: POP
// for i = 1 to 3 do
14145: LD_ADDR_VAR 0 2
14149: PUSH
14150: DOUBLE
14151: LD_INT 1
14153: DEC
14154: ST_TO_ADDR
14155: LD_INT 3
14157: PUSH
14158: FOR_TO
14159: IFFALSE 14249
// begin PrepareVehicle ( ar_half_tracked , engine_solar , control_manual , ar_rocket_launcher , 80 ) ;
14161: LD_INT 14
14163: PPUSH
14164: LD_INT 2
14166: PPUSH
14167: LD_INT 1
14169: PPUSH
14170: LD_INT 28
14172: PPUSH
14173: LD_INT 80
14175: PPUSH
14176: CALL 71087 0 5
// veh := CreateVehicle ;
14180: LD_ADDR_VAR 0 3
14184: PUSH
14185: CALL_OW 45
14189: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
14190: LD_VAR 0 3
14194: PPUSH
14195: LD_INT 3
14197: PPUSH
14198: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea2 , false ) ;
14202: LD_VAR 0 3
14206: PPUSH
14207: LD_INT 29
14209: PPUSH
14210: LD_INT 0
14212: PPUSH
14213: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14217: LD_INT 0
14219: PPUSH
14220: LD_INT 7
14222: PUSH
14223: LD_OWVAR 67
14227: PLUS
14228: PPUSH
14229: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14233: CALL_OW 44
14237: PPUSH
14238: LD_VAR 0 3
14242: PPUSH
14243: CALL_OW 52
// end ;
14247: GO 14158
14249: POP
14250: POP
// for i = 1 to 5 + Difficulty do
14251: LD_ADDR_VAR 0 2
14255: PUSH
14256: DOUBLE
14257: LD_INT 1
14259: DEC
14260: ST_TO_ADDR
14261: LD_INT 5
14263: PUSH
14264: LD_OWVAR 67
14268: PLUS
14269: PUSH
14270: FOR_TO
14271: IFFALSE 14398
// begin PrepareVehicle ( ar_half_tracked , rand ( 1 , 3 ) , control_manual , [ ar_rocket_launcher , ar_flame_thrower , ar_gun , ar_gatling_gun ] [ i mod 4 + 1 ] , 80 ) ;
14273: LD_INT 14
14275: PPUSH
14276: LD_INT 1
14278: PPUSH
14279: LD_INT 3
14281: PPUSH
14282: CALL_OW 12
14286: PPUSH
14287: LD_INT 1
14289: PPUSH
14290: LD_INT 28
14292: PUSH
14293: LD_INT 26
14295: PUSH
14296: LD_INT 27
14298: PUSH
14299: LD_INT 25
14301: PUSH
14302: EMPTY
14303: LIST
14304: LIST
14305: LIST
14306: LIST
14307: PUSH
14308: LD_VAR 0 2
14312: PUSH
14313: LD_INT 4
14315: MOD
14316: PUSH
14317: LD_INT 1
14319: PLUS
14320: ARRAY
14321: PPUSH
14322: LD_INT 80
14324: PPUSH
14325: CALL 71087 0 5
// veh := CreateVehicle ;
14329: LD_ADDR_VAR 0 3
14333: PUSH
14334: CALL_OW 45
14338: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14339: LD_VAR 0 3
14343: PPUSH
14344: LD_INT 4
14346: PPUSH
14347: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14351: LD_VAR 0 3
14355: PPUSH
14356: LD_INT 28
14358: PPUSH
14359: LD_INT 0
14361: PPUSH
14362: CALL_OW 49
// PrepareMechanic ( false , 7 + Difficulty ) ;
14366: LD_INT 0
14368: PPUSH
14369: LD_INT 7
14371: PUSH
14372: LD_OWVAR 67
14376: PLUS
14377: PPUSH
14378: CALL_OW 383
// PlaceHumanInUnit ( CreateHuman , veh ) ;
14382: CALL_OW 44
14386: PPUSH
14387: LD_VAR 0 3
14391: PPUSH
14392: CALL_OW 52
// end ;
14396: GO 14270
14398: POP
14399: POP
// for i = 1 to 3 do
14400: LD_ADDR_VAR 0 2
14404: PUSH
14405: DOUBLE
14406: LD_INT 1
14408: DEC
14409: ST_TO_ADDR
14410: LD_INT 3
14412: PUSH
14413: FOR_TO
14414: IFFALSE 14474
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , ar_selfpropelled_bomb , 80 ) ;
14416: LD_INT 14
14418: PPUSH
14419: LD_INT 3
14421: PPUSH
14422: LD_INT 5
14424: PPUSH
14425: LD_INT 29
14427: PPUSH
14428: LD_INT 80
14430: PPUSH
14431: CALL 71087 0 5
// veh := CreateVehicle ;
14435: LD_ADDR_VAR 0 3
14439: PUSH
14440: CALL_OW 45
14444: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
14445: LD_VAR 0 3
14449: PPUSH
14450: LD_INT 4
14452: PPUSH
14453: CALL_OW 233
// PlaceUnitArea ( veh , arabianAttackArea , false ) ;
14457: LD_VAR 0 3
14461: PPUSH
14462: LD_INT 28
14464: PPUSH
14465: LD_INT 0
14467: PPUSH
14468: CALL_OW 49
// end ;
14472: GO 14413
14474: POP
14475: POP
// end ;
14476: LD_VAR 0 1
14480: RET
// every 0 0$1 trigger FilterAllUnits ( [ f_side , 2 ] ) do var i , tmp , sci ;
14481: LD_INT 22
14483: PUSH
14484: LD_INT 2
14486: PUSH
14487: EMPTY
14488: LIST
14489: LIST
14490: PPUSH
14491: CALL_OW 69
14495: IFFALSE 14795
14497: GO 14499
14499: DISABLE
14500: LD_INT 0
14502: PPUSH
14503: PPUSH
14504: PPUSH
// begin sci := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 4 ] ] ) diff Khatam ;
14505: LD_ADDR_VAR 0 3
14509: PUSH
14510: LD_INT 22
14512: PUSH
14513: LD_INT 2
14515: PUSH
14516: EMPTY
14517: LIST
14518: LIST
14519: PUSH
14520: LD_INT 25
14522: PUSH
14523: LD_INT 4
14525: PUSH
14526: EMPTY
14527: LIST
14528: LIST
14529: PUSH
14530: EMPTY
14531: LIST
14532: LIST
14533: PPUSH
14534: CALL_OW 69
14538: PUSH
14539: LD_EXP 91
14543: DIFF
14544: ST_TO_ADDR
// tmp := FilterAllUnits ( [ f_side , 2 ] ) diff ( Khatam union sci ) ;
14545: LD_ADDR_VAR 0 2
14549: PUSH
14550: LD_INT 22
14552: PUSH
14553: LD_INT 2
14555: PUSH
14556: EMPTY
14557: LIST
14558: LIST
14559: PPUSH
14560: CALL_OW 69
14564: PUSH
14565: LD_EXP 91
14569: PUSH
14570: LD_VAR 0 3
14574: UNION
14575: DIFF
14576: ST_TO_ADDR
// if Khatam then
14577: LD_EXP 91
14581: IFFALSE 14598
// ComMoveXY ( Khatam , 211 , 92 ) ;
14583: LD_EXP 91
14587: PPUSH
14588: LD_INT 211
14590: PPUSH
14591: LD_INT 92
14593: PPUSH
14594: CALL_OW 111
// SetResourceVisibility ( 197 , 80 , 2 ) ;
14598: LD_INT 197
14600: PPUSH
14601: LD_INT 80
14603: PPUSH
14604: LD_INT 2
14606: PPUSH
14607: CALL_OW 441
// SetResourceVisibility ( 213 , 90 , 2 ) ;
14611: LD_INT 213
14613: PPUSH
14614: LD_INT 90
14616: PPUSH
14617: LD_INT 2
14619: PPUSH
14620: CALL_OW 441
// SetResourceVisibility ( 215 , 129 , 2 ) ;
14624: LD_INT 215
14626: PPUSH
14627: LD_INT 129
14629: PPUSH
14630: LD_INT 2
14632: PPUSH
14633: CALL_OW 441
// if sci then
14637: LD_VAR 0 3
14641: IFFALSE 14662
// ComContaminate ( sci [ 1 ] , 197 , 80 ) ;
14643: LD_VAR 0 3
14647: PUSH
14648: LD_INT 1
14650: ARRAY
14651: PPUSH
14652: LD_INT 197
14654: PPUSH
14655: LD_INT 80
14657: PPUSH
14658: CALL_OW 158
// if sci > 1 then
14662: LD_VAR 0 3
14666: PUSH
14667: LD_INT 1
14669: GREATER
14670: IFFALSE 14691
// ComContaminate ( sci [ 2 ] , 213 , 90 ) ;
14672: LD_VAR 0 3
14676: PUSH
14677: LD_INT 2
14679: ARRAY
14680: PPUSH
14681: LD_INT 213
14683: PPUSH
14684: LD_INT 90
14686: PPUSH
14687: CALL_OW 158
// if sci > 2 then
14691: LD_VAR 0 3
14695: PUSH
14696: LD_INT 2
14698: GREATER
14699: IFFALSE 14720
// ComContaminate ( sci [ 3 ] , 215 , 129 ) ;
14701: LD_VAR 0 3
14705: PUSH
14706: LD_INT 3
14708: ARRAY
14709: PPUSH
14710: LD_INT 215
14712: PPUSH
14713: LD_INT 129
14715: PPUSH
14716: CALL_OW 158
// repeat wait ( 0 0$1 ) ;
14720: LD_INT 35
14722: PPUSH
14723: CALL_OW 67
// for i in tmp do
14727: LD_ADDR_VAR 0 1
14731: PUSH
14732: LD_VAR 0 2
14736: PUSH
14737: FOR_IN
14738: IFFALSE 14776
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
14740: LD_VAR 0 1
14744: PPUSH
14745: LD_INT 81
14747: PUSH
14748: LD_INT 2
14750: PUSH
14751: EMPTY
14752: LIST
14753: LIST
14754: PPUSH
14755: CALL_OW 69
14759: PPUSH
14760: LD_VAR 0 1
14764: PPUSH
14765: CALL_OW 74
14769: PPUSH
14770: CALL_OW 115
14774: GO 14737
14776: POP
14777: POP
// until not FilterAllUnits ( [ f_side , 2 ] ) ;
14778: LD_INT 22
14780: PUSH
14781: LD_INT 2
14783: PUSH
14784: EMPTY
14785: LIST
14786: LIST
14787: PPUSH
14788: CALL_OW 69
14792: NOT
14793: IFFALSE 14720
// end ; end_of_file
14795: PPOPN 3
14797: END
// export function Action ; var i , t , cargo , tmp , options , dec , amount , macmilan_squad ; begin
14798: LD_INT 0
14800: PPUSH
14801: PPUSH
14802: PPUSH
14803: PPUSH
14804: PPUSH
14805: PPUSH
14806: PPUSH
14807: PPUSH
14808: PPUSH
// Video ( true ) ;
14809: LD_INT 1
14811: PPUSH
14812: CALL 106804 0 1
// tmp := AreaToList ( macmilanCameraArea , 0 ) ;
14816: LD_ADDR_VAR 0 5
14820: PUSH
14821: LD_INT 7
14823: PPUSH
14824: LD_INT 0
14826: PPUSH
14827: CALL_OW 517
14831: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
14832: LD_ADDR_VAR 0 2
14836: PUSH
14837: DOUBLE
14838: LD_INT 1
14840: DEC
14841: ST_TO_ADDR
14842: LD_VAR 0 5
14846: PUSH
14847: LD_INT 1
14849: ARRAY
14850: PUSH
14851: FOR_TO
14852: IFFALSE 14897
// RevealMapOnXY ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , 1 , - 15 ) ;
14854: LD_VAR 0 5
14858: PUSH
14859: LD_INT 1
14861: ARRAY
14862: PUSH
14863: LD_VAR 0 2
14867: ARRAY
14868: PPUSH
14869: LD_VAR 0 5
14873: PUSH
14874: LD_INT 2
14876: ARRAY
14877: PUSH
14878: LD_VAR 0 2
14882: ARRAY
14883: PPUSH
14884: LD_INT 1
14886: PPUSH
14887: LD_INT 15
14889: NEG
14890: PPUSH
14891: CALL 106718 0 4
14895: GO 14851
14897: POP
14898: POP
// CenterNowOnUnits ( Powell ) ;
14899: LD_EXP 55
14903: PPUSH
14904: CALL_OW 87
// tmp := [ JMMNewVeh ] ;
14908: LD_ADDR_VAR 0 5
14912: PUSH
14913: LD_EXP 53
14917: PUSH
14918: EMPTY
14919: LIST
14920: ST_TO_ADDR
// if GirlNewVeh then
14921: LD_EXP 54
14925: IFFALSE 14943
// tmp := tmp ^ GirlNewVeh ;
14927: LD_ADDR_VAR 0 5
14931: PUSH
14932: LD_VAR 0 5
14936: PUSH
14937: LD_EXP 54
14941: ADD
14942: ST_TO_ADDR
// ComMoveXY ( tmp , 60 , 109 ) ;
14943: LD_VAR 0 5
14947: PPUSH
14948: LD_INT 60
14950: PPUSH
14951: LD_INT 109
14953: PPUSH
14954: CALL_OW 111
// if KappaStatus then
14958: LD_EXP 2
14962: IFFALSE 15014
// begin Say ( JMM , D1nT-JMM-1 ) ;
14964: LD_EXP 36
14968: PPUSH
14969: LD_STRING D1nT-JMM-1
14971: PPUSH
14972: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
14976: LD_EXP 55
14980: PPUSH
14981: LD_STRING D1T-Pow-1
14983: PPUSH
14984: CALL_OW 88
// Say ( JMM , D1T-JMM-2 ) ;
14988: LD_EXP 36
14992: PPUSH
14993: LD_STRING D1T-JMM-2
14995: PPUSH
14996: CALL_OW 88
// Say ( Powell , D1T-Pow-2 ) ;
15000: LD_EXP 55
15004: PPUSH
15005: LD_STRING D1T-Pow-2
15007: PPUSH
15008: CALL_OW 88
// end else
15012: GO 15220
// if JMMGirlStatus then
15014: LD_EXP 6
15018: IFFALSE 15163
// begin Say ( JMM , D1T-JMM-1 ) ;
15020: LD_EXP 36
15024: PPUSH
15025: LD_STRING D1T-JMM-1
15027: PPUSH
15028: CALL_OW 88
// Say ( Powell , D1T-Pow-1 ) ;
15032: LD_EXP 55
15036: PPUSH
15037: LD_STRING D1T-Pow-1
15039: PPUSH
15040: CALL_OW 88
// Say ( JMM , D1T-JMM-3 ) ;
15044: LD_EXP 36
15048: PPUSH
15049: LD_STRING D1T-JMM-3
15051: PPUSH
15052: CALL_OW 88
// Say ( Powell , D1T-Pow-3 ) ;
15056: LD_EXP 55
15060: PPUSH
15061: LD_STRING D1T-Pow-3
15063: PPUSH
15064: CALL_OW 88
// if JMMGirl then
15068: LD_EXP 7
15072: IFFALSE 15161
// begin case JMMGirl of 1 :
15074: LD_EXP 7
15078: PUSH
15079: LD_INT 1
15081: DOUBLE
15082: EQUAL
15083: IFTRUE 15087
15085: GO 15102
15087: POP
// Say ( Joan , D1T-Joan-3 ) ; 2 :
15088: LD_EXP 37
15092: PPUSH
15093: LD_STRING D1T-Joan-3
15095: PPUSH
15096: CALL_OW 88
15100: GO 15149
15102: LD_INT 2
15104: DOUBLE
15105: EQUAL
15106: IFTRUE 15110
15108: GO 15125
15110: POP
// Say ( Lisa , D1T-Lisa-3 ) ; 3 :
15111: LD_EXP 39
15115: PPUSH
15116: LD_STRING D1T-Lisa-3
15118: PPUSH
15119: CALL_OW 88
15123: GO 15149
15125: LD_INT 3
15127: DOUBLE
15128: EQUAL
15129: IFTRUE 15133
15131: GO 15148
15133: POP
// Say ( Connie , D1T-Con-3 ) ; end ;
15134: LD_EXP 51
15138: PPUSH
15139: LD_STRING D1T-Con-3
15141: PPUSH
15142: CALL_OW 88
15146: GO 15149
15148: POP
// Say ( Powell , D1T-Pow-4 ) ;
15149: LD_EXP 55
15153: PPUSH
15154: LD_STRING D1T-Pow-4
15156: PPUSH
15157: CALL_OW 88
// end ; end else
15161: GO 15220
// if not FastEnd then
15163: LD_EXP 11
15167: NOT
15168: IFFALSE 15196
// begin Say ( JMM , D1T-JMM-4 ) ;
15170: LD_EXP 36
15174: PPUSH
15175: LD_STRING D1T-JMM-4
15177: PPUSH
15178: CALL_OW 88
// Say ( Powell , D1T-Pow-5 ) ;
15182: LD_EXP 55
15186: PPUSH
15187: LD_STRING D1T-Pow-5
15189: PPUSH
15190: CALL_OW 88
// end else
15194: GO 15220
// begin Say ( JMM , D1nT-JMM-1 ) ;
15196: LD_EXP 36
15200: PPUSH
15201: LD_STRING D1nT-JMM-1
15203: PPUSH
15204: CALL_OW 88
// Say ( Powell , D1nT-Pow-1 ) ;
15208: LD_EXP 55
15212: PPUSH
15213: LD_STRING D1nT-Pow-1
15215: PPUSH
15216: CALL_OW 88
// end ; repeat wait ( 0 0$1 ) ;
15220: LD_INT 35
15222: PPUSH
15223: CALL_OW 67
// until not HasTask ( JMMNewVeh ) ;
15227: LD_EXP 53
15231: PPUSH
15232: CALL_OW 314
15236: NOT
15237: IFFALSE 15220
// ComExitVehicle ( JMM ) ;
15239: LD_EXP 36
15243: PPUSH
15244: CALL_OW 121
// wait ( 3 ) ;
15248: LD_INT 3
15250: PPUSH
15251: CALL_OW 67
// ComMoveXY ( JMM , 60 , 94 ) ;
15255: LD_EXP 36
15259: PPUSH
15260: LD_INT 60
15262: PPUSH
15263: LD_INT 94
15265: PPUSH
15266: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
15270: LD_EXP 36
15274: PPUSH
15275: LD_EXP 55
15279: PPUSH
15280: CALL_OW 179
// if Joan then
15284: LD_EXP 37
15288: IFFALSE 15342
// begin ComExitVehicle ( Joan ) ;
15290: LD_EXP 37
15294: PPUSH
15295: CALL_OW 121
// AddComWait ( Joan , 0 0$1 ) ;
15299: LD_EXP 37
15303: PPUSH
15304: LD_INT 35
15306: PPUSH
15307: CALL_OW 202
// AddComMoveXY ( Joan , 65 , 104 ) ;
15311: LD_EXP 37
15315: PPUSH
15316: LD_INT 65
15318: PPUSH
15319: LD_INT 104
15321: PPUSH
15322: CALL_OW 171
// AddComTurnUnit ( Joan , JMM ) ;
15326: LD_EXP 37
15330: PPUSH
15331: LD_EXP 36
15335: PPUSH
15336: CALL_OW 179
// end else
15340: GO 15476
// if Lisa and JMMGirl = 2 then
15342: LD_EXP 39
15346: PUSH
15347: LD_EXP 7
15351: PUSH
15352: LD_INT 2
15354: EQUAL
15355: AND
15356: IFFALSE 15410
// begin ComExitVehicle ( Lisa ) ;
15358: LD_EXP 39
15362: PPUSH
15363: CALL_OW 121
// AddComWait ( Lisa , 0 0$1 ) ;
15367: LD_EXP 39
15371: PPUSH
15372: LD_INT 35
15374: PPUSH
15375: CALL_OW 202
// AddComMoveXY ( Lisa , 65 , 104 ) ;
15379: LD_EXP 39
15383: PPUSH
15384: LD_INT 65
15386: PPUSH
15387: LD_INT 104
15389: PPUSH
15390: CALL_OW 171
// AddComTurnUnit ( Lisa , JMM ) ;
15394: LD_EXP 39
15398: PPUSH
15399: LD_EXP 36
15403: PPUSH
15404: CALL_OW 179
// end else
15408: GO 15476
// if Connie and JMMGirl = 3 then
15410: LD_EXP 51
15414: PUSH
15415: LD_EXP 7
15419: PUSH
15420: LD_INT 3
15422: EQUAL
15423: AND
15424: IFFALSE 15476
// begin ComExitVehicle ( Connie ) ;
15426: LD_EXP 51
15430: PPUSH
15431: CALL_OW 121
// AddComWait ( Connie , 0 0$1 ) ;
15435: LD_EXP 51
15439: PPUSH
15440: LD_INT 35
15442: PPUSH
15443: CALL_OW 202
// AddComMoveXY ( Connie , 65 , 104 ) ;
15447: LD_EXP 51
15451: PPUSH
15452: LD_INT 65
15454: PPUSH
15455: LD_INT 104
15457: PPUSH
15458: CALL_OW 171
// AddComTurnUnit ( Connie , JMM ) ;
15462: LD_EXP 51
15466: PPUSH
15467: LD_EXP 36
15471: PPUSH
15472: CALL_OW 179
// end ; repeat wait ( 0 0$1 ) ;
15476: LD_INT 35
15478: PPUSH
15479: CALL_OW 67
// until GetDistUnits ( JMM , Powell ) < 6 ;
15483: LD_EXP 36
15487: PPUSH
15488: LD_EXP 55
15492: PPUSH
15493: CALL_OW 296
15497: PUSH
15498: LD_INT 6
15500: LESS
15501: IFFALSE 15476
// wait ( 0 0$0.5 ) ;
15503: LD_INT 18
15505: PPUSH
15506: CALL_OW 67
// Say ( JMM , D1-JMM-1 ) ;
15510: LD_EXP 36
15514: PPUSH
15515: LD_STRING D1-JMM-1
15517: PPUSH
15518: CALL_OW 88
// async ;
15522: ASYNC
// Say ( Powell , D1-Pow-1 ) ;
15523: LD_EXP 55
15527: PPUSH
15528: LD_STRING D1-Pow-1
15530: PPUSH
15531: CALL_OW 88
// if not dialogue_skipped then
15535: LD_OWVAR 59
15539: NOT
15540: IFFALSE 15549
// wait ( 0 0$2 ) ;
15542: LD_INT 70
15544: PPUSH
15545: CALL_OW 67
// RevealMapOnXY ( 170 , 99 , 1 , - 6 ) ;
15549: LD_INT 170
15551: PPUSH
15552: LD_INT 99
15554: PPUSH
15555: LD_INT 1
15557: PPUSH
15558: LD_INT 6
15560: NEG
15561: PPUSH
15562: CALL 106718 0 4
// RevealMapOnXY ( 174 , 115 , 1 , - 6 ) ;
15566: LD_INT 174
15568: PPUSH
15569: LD_INT 115
15571: PPUSH
15572: LD_INT 1
15574: PPUSH
15575: LD_INT 6
15577: NEG
15578: PPUSH
15579: CALL 106718 0 4
// RevealMapOnXY ( 169 , 71 , 1 , - 6 ) ;
15583: LD_INT 169
15585: PPUSH
15586: LD_INT 71
15588: PPUSH
15589: LD_INT 1
15591: PPUSH
15592: LD_INT 6
15594: NEG
15595: PPUSH
15596: CALL 106718 0 4
// if not dialogue_skipped then
15600: LD_OWVAR 59
15604: NOT
15605: IFFALSE 15624
// begin CenterOnXY ( 170 , 99 ) ;
15607: LD_INT 170
15609: PPUSH
15610: LD_INT 99
15612: PPUSH
15613: CALL_OW 84
// wait ( 0 0$2.3 ) ;
15617: LD_INT 80
15619: PPUSH
15620: CALL_OW 67
// end ; RevealMapOnXY ( 75 , 53 , 1 , - 9 ) ;
15624: LD_INT 75
15626: PPUSH
15627: LD_INT 53
15629: PPUSH
15630: LD_INT 1
15632: PPUSH
15633: LD_INT 9
15635: NEG
15636: PPUSH
15637: CALL 106718 0 4
// RevealMapOnXY ( 54 , 42 , 1 , - 9 ) ;
15641: LD_INT 54
15643: PPUSH
15644: LD_INT 42
15646: PPUSH
15647: LD_INT 1
15649: PPUSH
15650: LD_INT 9
15652: NEG
15653: PPUSH
15654: CALL 106718 0 4
// RevealMapOnXY ( 62 , 51 , 1 , - 9 ) ;
15658: LD_INT 62
15660: PPUSH
15661: LD_INT 51
15663: PPUSH
15664: LD_INT 1
15666: PPUSH
15667: LD_INT 9
15669: NEG
15670: PPUSH
15671: CALL 106718 0 4
// if not dialogue_skipped then
15675: LD_OWVAR 59
15679: NOT
15680: IFFALSE 15699
// begin CenterOnXY ( 75 , 53 ) ;
15682: LD_INT 75
15684: PPUSH
15685: LD_INT 53
15687: PPUSH
15688: CALL_OW 84
// wait ( 0 0$4 ) ;
15692: LD_INT 140
15694: PPUSH
15695: CALL_OW 67
// end ; CenterNowOnUnits ( Powell ) ;
15699: LD_EXP 55
15703: PPUSH
15704: CALL_OW 87
// if not dialogue_skipped then
15708: LD_OWVAR 59
15712: NOT
15713: IFFALSE 15722
// wait ( 0 0$2 ) ;
15715: LD_INT 70
15717: PPUSH
15718: CALL_OW 67
// sync ;
15722: SYNC
// Say ( JMM , D1-JMM-2 ) ;
15723: LD_EXP 36
15727: PPUSH
15728: LD_STRING D1-JMM-2
15730: PPUSH
15731: CALL_OW 88
// Say ( Powell , D1-Pow-2 ) ;
15735: LD_EXP 55
15739: PPUSH
15740: LD_STRING D1-Pow-2
15742: PPUSH
15743: CALL_OW 88
// Say ( JMM , D1-JMM-3 ) ;
15747: LD_EXP 36
15751: PPUSH
15752: LD_STRING D1-JMM-3
15754: PPUSH
15755: CALL_OW 88
// Say ( Powell , D1-Pow-3 ) ;
15759: LD_EXP 55
15763: PPUSH
15764: LD_STRING D1-Pow-3
15766: PPUSH
15767: CALL_OW 88
// Say ( JMM , D1-JMM-4 ) ;
15771: LD_EXP 36
15775: PPUSH
15776: LD_STRING D1-JMM-4
15778: PPUSH
15779: CALL_OW 88
// Say ( Powell , D1-Pow-4 ) ;
15783: LD_EXP 55
15787: PPUSH
15788: LD_STRING D1-Pow-4
15790: PPUSH
15791: CALL_OW 88
// Say ( JMM , D1-JMM-5 ) ;
15795: LD_EXP 36
15799: PPUSH
15800: LD_STRING D1-JMM-5
15802: PPUSH
15803: CALL_OW 88
// async ;
15807: ASYNC
// Say ( Powell , D1-Pow-5 ) ;
15808: LD_EXP 55
15812: PPUSH
15813: LD_STRING D1-Pow-5
15815: PPUSH
15816: CALL_OW 88
// if not dialogue_skipped then
15820: LD_OWVAR 59
15824: NOT
15825: IFFALSE 15834
// wait ( 0 0$3.6 ) ;
15827: LD_INT 126
15829: PPUSH
15830: CALL_OW 67
// RevealMapOnXY ( 134 , 210 , 1 , - 11 ) ;
15834: LD_INT 134
15836: PPUSH
15837: LD_INT 210
15839: PPUSH
15840: LD_INT 1
15842: PPUSH
15843: LD_INT 11
15845: NEG
15846: PPUSH
15847: CALL 106718 0 4
// if not dialogue_skipped then
15851: LD_OWVAR 59
15855: NOT
15856: IFFALSE 15875
// begin CenterOnXY ( 134 , 210 ) ;
15858: LD_INT 134
15860: PPUSH
15861: LD_INT 210
15863: PPUSH
15864: CALL_OW 84
// wait ( 0 0$2 ) ;
15868: LD_INT 70
15870: PPUSH
15871: CALL_OW 67
// end ; RevealMapOnXY ( 101 , 159 , 1 , - 10 ) ;
15875: LD_INT 101
15877: PPUSH
15878: LD_INT 159
15880: PPUSH
15881: LD_INT 1
15883: PPUSH
15884: LD_INT 10
15886: NEG
15887: PPUSH
15888: CALL 106718 0 4
// if not dialogue_skipped then
15892: LD_OWVAR 59
15896: NOT
15897: IFFALSE 15916
// begin CenterOnXY ( 101 , 159 ) ;
15899: LD_INT 101
15901: PPUSH
15902: LD_INT 159
15904: PPUSH
15905: CALL_OW 84
// wait ( 0 0$2 ) ;
15909: LD_INT 70
15911: PPUSH
15912: CALL_OW 67
// end ; sync ;
15916: SYNC
// CenterNowOnUnits ( Powell ) ;
15917: LD_EXP 55
15921: PPUSH
15922: CALL_OW 87
// options = [ 1 , 2 , 3 , 4 , 5 , 6 ] ;
15926: LD_ADDR_VAR 0 6
15930: PUSH
15931: LD_INT 1
15933: PUSH
15934: LD_INT 2
15936: PUSH
15937: LD_INT 3
15939: PUSH
15940: LD_INT 4
15942: PUSH
15943: LD_INT 5
15945: PUSH
15946: LD_INT 6
15948: PUSH
15949: EMPTY
15950: LIST
15951: LIST
15952: LIST
15953: LIST
15954: LIST
15955: LIST
15956: ST_TO_ADDR
// if not dialogue_skipped then
15957: LD_OWVAR 59
15961: NOT
15962: IFFALSE 16131
// begin game_speed := 4 ;
15964: LD_ADDR_OWVAR 65
15968: PUSH
15969: LD_INT 4
15971: ST_TO_ADDR
// wait ( 0 0$6 ) ;
15972: LD_INT 210
15974: PPUSH
15975: CALL_OW 67
// dec = SelectiveQuery ( Q1 , options ) ;
15979: LD_ADDR_VAR 0 7
15983: PUSH
15984: LD_STRING Q1
15986: PPUSH
15987: LD_VAR 0 6
15991: PPUSH
15992: CALL_OW 98
15996: ST_TO_ADDR
// repeat dec = SelectiveQuery ( Q1 , options ) ;
15997: LD_ADDR_VAR 0 7
16001: PUSH
16002: LD_STRING Q1
16004: PPUSH
16005: LD_VAR 0 6
16009: PPUSH
16010: CALL_OW 98
16014: ST_TO_ADDR
// options = options diff dec ;
16015: LD_ADDR_VAR 0 6
16019: PUSH
16020: LD_VAR 0 6
16024: PUSH
16025: LD_VAR 0 7
16029: DIFF
16030: ST_TO_ADDR
// ResolveQuery ( dec , options ) ;
16031: LD_VAR 0 7
16035: PPUSH
16036: LD_VAR 0 6
16040: PPUSH
16041: CALL 17434 0 2
// until ( dec in [ 5 , 6 ] ) or options = 2 ;
16045: LD_VAR 0 7
16049: PUSH
16050: LD_INT 5
16052: PUSH
16053: LD_INT 6
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: IN
16060: PUSH
16061: LD_VAR 0 6
16065: PUSH
16066: LD_INT 2
16068: EQUAL
16069: OR
16070: IFFALSE 15997
// if not ( dec in [ 5 , 6 ] ) then
16072: LD_VAR 0 7
16076: PUSH
16077: LD_INT 5
16079: PUSH
16080: LD_INT 6
16082: PUSH
16083: EMPTY
16084: LIST
16085: LIST
16086: IN
16087: NOT
16088: IFFALSE 16131
// begin dec = SelectiveQuery ( Q1a , [ 1 , 2 ] ) ;
16090: LD_ADDR_VAR 0 7
16094: PUSH
16095: LD_STRING Q1a
16097: PPUSH
16098: LD_INT 1
16100: PUSH
16101: LD_INT 2
16103: PUSH
16104: EMPTY
16105: LIST
16106: LIST
16107: PPUSH
16108: CALL_OW 98
16112: ST_TO_ADDR
// ResolveQuery ( dec + 4 , options ) ;
16113: LD_VAR 0 7
16117: PUSH
16118: LD_INT 4
16120: PLUS
16121: PPUSH
16122: LD_VAR 0 6
16126: PPUSH
16127: CALL 17434 0 2
// end ; end ; CenterOnXY ( 81 , 127 ) ;
16131: LD_INT 81
16133: PPUSH
16134: LD_INT 127
16136: PPUSH
16137: CALL_OW 84
// amount := 5 ;
16141: LD_ADDR_VAR 0 8
16145: PUSH
16146: LD_INT 5
16148: ST_TO_ADDR
// macmilan_squad := [ ] ;
16149: LD_ADDR_VAR 0 9
16153: PUSH
16154: EMPTY
16155: ST_TO_ADDR
// if vip < amount then
16156: LD_EXP 56
16160: PUSH
16161: LD_VAR 0 8
16165: LESS
16166: IFFALSE 16210
// tmp := vip union FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) else
16168: LD_ADDR_VAR 0 5
16172: PUSH
16173: LD_EXP 56
16177: PUSH
16178: LD_INT 22
16180: PUSH
16181: LD_INT 4
16183: PUSH
16184: EMPTY
16185: LIST
16186: LIST
16187: PUSH
16188: LD_INT 21
16190: PUSH
16191: LD_INT 1
16193: PUSH
16194: EMPTY
16195: LIST
16196: LIST
16197: PUSH
16198: EMPTY
16199: LIST
16200: LIST
16201: PPUSH
16202: CALL_OW 69
16206: UNION
16207: ST_TO_ADDR
16208: GO 16220
// tmp := vip ;
16210: LD_ADDR_VAR 0 5
16214: PUSH
16215: LD_EXP 56
16219: ST_TO_ADDR
// tmp := tmp diff Powell ;
16220: LD_ADDR_VAR 0 5
16224: PUSH
16225: LD_VAR 0 5
16229: PUSH
16230: LD_EXP 55
16234: DIFF
16235: ST_TO_ADDR
// if tmp < amount then
16236: LD_VAR 0 5
16240: PUSH
16241: LD_VAR 0 8
16245: LESS
16246: IFFALSE 16258
// amount := tmp ;
16248: LD_ADDR_VAR 0 8
16252: PUSH
16253: LD_VAR 0 5
16257: ST_TO_ADDR
// if GetClass ( tmp [ 1 ] ) <> 2 then
16258: LD_VAR 0 5
16262: PUSH
16263: LD_INT 1
16265: ARRAY
16266: PPUSH
16267: CALL_OW 257
16271: PUSH
16272: LD_INT 2
16274: NONEQUAL
16275: IFFALSE 16337
// begin if IsInUnit ( tmp [ 1 ] ) then
16277: LD_VAR 0 5
16281: PUSH
16282: LD_INT 1
16284: ARRAY
16285: PPUSH
16286: CALL_OW 310
16290: IFFALSE 16305
// ComExitBuilding ( tmp [ 1 ] ) ;
16292: LD_VAR 0 5
16296: PUSH
16297: LD_INT 1
16299: ARRAY
16300: PPUSH
16301: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , am_depot ) ;
16305: LD_VAR 0 5
16309: PUSH
16310: LD_INT 1
16312: ARRAY
16313: PPUSH
16314: LD_INT 387
16316: PPUSH
16317: CALL_OW 180
// AddComChangeProfession ( tmp [ 1 ] , 2 ) ;
16321: LD_VAR 0 5
16325: PUSH
16326: LD_INT 1
16328: ARRAY
16329: PPUSH
16330: LD_INT 2
16332: PPUSH
16333: CALL_OW 183
// end ; ComMoveXY ( JMM , 82 , 129 ) ;
16337: LD_EXP 36
16341: PPUSH
16342: LD_INT 82
16344: PPUSH
16345: LD_INT 129
16347: PPUSH
16348: CALL_OW 111
// AddComTurnUnit ( JMM , Powell ) ;
16352: LD_EXP 36
16356: PPUSH
16357: LD_EXP 55
16361: PPUSH
16362: CALL_OW 179
// ComMoveXY ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , 84 , 128 ) ;
16366: LD_INT 22
16368: PUSH
16369: LD_INT 1
16371: PUSH
16372: EMPTY
16373: LIST
16374: LIST
16375: PPUSH
16376: CALL_OW 69
16380: PUSH
16381: LD_EXP 36
16385: DIFF
16386: PPUSH
16387: LD_INT 84
16389: PPUSH
16390: LD_INT 128
16392: PPUSH
16393: CALL_OW 111
// AddComTurnUnit ( FilterAllUnits ( [ f_side , 1 ] ) diff JMM , JMM ) ;
16397: LD_INT 22
16399: PUSH
16400: LD_INT 1
16402: PUSH
16403: EMPTY
16404: LIST
16405: LIST
16406: PPUSH
16407: CALL_OW 69
16411: PUSH
16412: LD_EXP 36
16416: DIFF
16417: PPUSH
16418: LD_EXP 36
16422: PPUSH
16423: CALL_OW 179
// for i = 1 to amount do
16427: LD_ADDR_VAR 0 2
16431: PUSH
16432: DOUBLE
16433: LD_INT 1
16435: DEC
16436: ST_TO_ADDR
16437: LD_VAR 0 8
16441: PUSH
16442: FOR_TO
16443: IFFALSE 16611
// begin macmilan_squad := macmilan_squad ^ tmp [ i ] ;
16445: LD_ADDR_VAR 0 9
16449: PUSH
16450: LD_VAR 0 9
16454: PUSH
16455: LD_VAR 0 5
16459: PUSH
16460: LD_VAR 0 2
16464: ARRAY
16465: ADD
16466: ST_TO_ADDR
// if IsInUnit ( tmp [ i ] ) then
16467: LD_VAR 0 5
16471: PUSH
16472: LD_VAR 0 2
16476: ARRAY
16477: PPUSH
16478: CALL_OW 310
16482: IFFALSE 16499
// AddComExitBuilding ( tmp [ i ] ) ;
16484: LD_VAR 0 5
16488: PUSH
16489: LD_VAR 0 2
16493: ARRAY
16494: PPUSH
16495: CALL_OW 182
// if i = 2 and JMMNewVeh then
16499: LD_VAR 0 2
16503: PUSH
16504: LD_INT 2
16506: EQUAL
16507: PUSH
16508: LD_EXP 53
16512: AND
16513: IFFALSE 16571
// begin AddComEnterUnit ( tmp [ i ] , JMMNewVeh ) ;
16515: LD_VAR 0 5
16519: PUSH
16520: LD_VAR 0 2
16524: ARRAY
16525: PPUSH
16526: LD_EXP 53
16530: PPUSH
16531: CALL_OW 180
// AddComMoveXY ( tmp [ i ] , 86 , 133 ) ;
16535: LD_VAR 0 5
16539: PUSH
16540: LD_VAR 0 2
16544: ARRAY
16545: PPUSH
16546: LD_INT 86
16548: PPUSH
16549: LD_INT 133
16551: PPUSH
16552: CALL_OW 171
// AddComExitVehicle ( tmp [ i ] ) ;
16556: LD_VAR 0 5
16560: PUSH
16561: LD_VAR 0 2
16565: ARRAY
16566: PPUSH
16567: CALL_OW 181
// end ; AddComMoveToArea ( tmp [ i ] , macmilanSquadStand ) ;
16571: LD_VAR 0 5
16575: PUSH
16576: LD_VAR 0 2
16580: ARRAY
16581: PPUSH
16582: LD_INT 8
16584: PPUSH
16585: CALL_OW 173
// AddComTurnUnit ( tmp [ i ] , JMM ) ;
16589: LD_VAR 0 5
16593: PUSH
16594: LD_VAR 0 2
16598: ARRAY
16599: PPUSH
16600: LD_EXP 36
16604: PPUSH
16605: CALL_OW 179
// end ;
16609: GO 16442
16611: POP
16612: POP
// if GirlNewVeh then
16613: LD_EXP 54
16617: IFFALSE 16631
// SetSide ( GirlNewVeh , 4 ) ;
16619: LD_EXP 54
16623: PPUSH
16624: LD_INT 4
16626: PPUSH
16627: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
16631: LD_INT 35
16633: PPUSH
16634: CALL_OW 67
// until UnitFilter ( macmilan_squad , [ f_inarea , powellBase ] ) = 0 and not IsInArea ( JMM , powellBase ) ;
16638: LD_VAR 0 9
16642: PPUSH
16643: LD_INT 95
16645: PUSH
16646: LD_INT 9
16648: PUSH
16649: EMPTY
16650: LIST
16651: LIST
16652: PPUSH
16653: CALL_OW 72
16657: PUSH
16658: LD_INT 0
16660: EQUAL
16661: PUSH
16662: LD_EXP 36
16666: PPUSH
16667: LD_INT 9
16669: PPUSH
16670: CALL_OW 308
16674: NOT
16675: AND
16676: IFFALSE 16631
// wait ( 0 0$2 ) ;
16678: LD_INT 70
16680: PPUSH
16681: CALL_OW 67
// SetSide ( macmilan_squad , 1 ) ;
16685: LD_VAR 0 9
16689: PPUSH
16690: LD_INT 1
16692: PPUSH
16693: CALL_OW 235
// SetSide ( FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_distxy , 83 , 130 , 10 ] ] ) , 1 ) ;
16697: LD_INT 21
16699: PUSH
16700: LD_INT 2
16702: PUSH
16703: EMPTY
16704: LIST
16705: LIST
16706: PUSH
16707: LD_INT 92
16709: PUSH
16710: LD_INT 83
16712: PUSH
16713: LD_INT 130
16715: PUSH
16716: LD_INT 10
16718: PUSH
16719: EMPTY
16720: LIST
16721: LIST
16722: LIST
16723: LIST
16724: PUSH
16725: EMPTY
16726: LIST
16727: LIST
16728: PPUSH
16729: CALL_OW 69
16733: PPUSH
16734: LD_INT 1
16736: PPUSH
16737: CALL_OW 235
// Video ( false ) ;
16741: LD_INT 0
16743: PPUSH
16744: CALL 106804 0 1
// ChangeMissionObjectives ( M1 ) ;
16748: LD_STRING M1
16750: PPUSH
16751: CALL_OW 337
// SaveForQuickRestart ;
16755: CALL_OW 22
// missionStart := true ;
16759: LD_ADDR_EXP 13
16763: PUSH
16764: LD_INT 1
16766: ST_TO_ADDR
// missionStage := 2 ;
16767: LD_ADDR_EXP 15
16771: PUSH
16772: LD_INT 2
16774: ST_TO_ADDR
// wait ( 0 0$3 ) ;
16775: LD_INT 105
16777: PPUSH
16778: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] ] ) diff Powell ;
16782: LD_ADDR_VAR 0 5
16786: PUSH
16787: LD_INT 22
16789: PUSH
16790: LD_INT 4
16792: PUSH
16793: EMPTY
16794: LIST
16795: LIST
16796: PUSH
16797: LD_INT 21
16799: PUSH
16800: LD_INT 1
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: EMPTY
16808: LIST
16809: LIST
16810: PPUSH
16811: CALL_OW 69
16815: PUSH
16816: LD_EXP 55
16820: DIFF
16821: ST_TO_ADDR
// if not tmp then
16822: LD_VAR 0 5
16826: NOT
16827: IFFALSE 16842
// tmp := [ Powell ] ;
16829: LD_ADDR_VAR 0 5
16833: PUSH
16834: LD_EXP 55
16838: PUSH
16839: EMPTY
16840: LIST
16841: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 4 , FilterAllUnits ( [ [ f_side , 4 ] , [ f_nation , 1 ] , [ f_not , [ f_type , unit_vehicle ] ] ] ) diff Powell ) ;
16842: LD_ADDR_EXP 99
16846: PUSH
16847: LD_EXP 99
16851: PPUSH
16852: LD_INT 4
16854: PPUSH
16855: LD_INT 22
16857: PUSH
16858: LD_INT 4
16860: PUSH
16861: EMPTY
16862: LIST
16863: LIST
16864: PUSH
16865: LD_INT 23
16867: PUSH
16868: LD_INT 1
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 3
16877: PUSH
16878: LD_INT 21
16880: PUSH
16881: LD_INT 2
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: PUSH
16888: EMPTY
16889: LIST
16890: LIST
16891: PUSH
16892: EMPTY
16893: LIST
16894: LIST
16895: LIST
16896: PPUSH
16897: CALL_OW 69
16901: PUSH
16902: LD_EXP 55
16906: DIFF
16907: PPUSH
16908: CALL_OW 1
16912: ST_TO_ADDR
// cargo := FilterAllUnits ( [ [ f_side , 4 ] , [ f_weapon , us_cargo_bay ] ] ) [ 1 ] ;
16913: LD_ADDR_VAR 0 4
16917: PUSH
16918: LD_INT 22
16920: PUSH
16921: LD_INT 4
16923: PUSH
16924: EMPTY
16925: LIST
16926: LIST
16927: PUSH
16928: LD_INT 34
16930: PUSH
16931: LD_INT 12
16933: PUSH
16934: EMPTY
16935: LIST
16936: LIST
16937: PUSH
16938: EMPTY
16939: LIST
16940: LIST
16941: PPUSH
16942: CALL_OW 69
16946: PUSH
16947: LD_INT 1
16949: ARRAY
16950: ST_TO_ADDR
// if IsInUnit ( tmp [ 1 ] ) then
16951: LD_VAR 0 5
16955: PUSH
16956: LD_INT 1
16958: ARRAY
16959: PPUSH
16960: CALL_OW 310
16964: IFFALSE 16979
// ComExitBuilding ( tmp [ 1 ] ) ;
16966: LD_VAR 0 5
16970: PUSH
16971: LD_INT 1
16973: ARRAY
16974: PPUSH
16975: CALL_OW 122
// AddComEnterUnit ( tmp [ 1 ] , cargo ) ;
16979: LD_VAR 0 5
16983: PUSH
16984: LD_INT 1
16986: ARRAY
16987: PPUSH
16988: LD_VAR 0 4
16992: PPUSH
16993: CALL_OW 180
// AddComMoveXY ( tmp [ 1 ] , 80 , 136 ) ;
16997: LD_VAR 0 5
17001: PUSH
17002: LD_INT 1
17004: ARRAY
17005: PPUSH
17006: LD_INT 80
17008: PPUSH
17009: LD_INT 136
17011: PPUSH
17012: CALL_OW 171
// AddComUnload ( tmp [ 1 ] ) ;
17016: LD_VAR 0 5
17020: PUSH
17021: LD_INT 1
17023: ARRAY
17024: PPUSH
17025: CALL_OW 219
// AddComMoveXY ( tmp [ 1 ] , 59 , 112 ) ;
17029: LD_VAR 0 5
17033: PUSH
17034: LD_INT 1
17036: ARRAY
17037: PPUSH
17038: LD_INT 59
17040: PPUSH
17041: LD_INT 112
17043: PPUSH
17044: CALL_OW 171
// AddComExitVehicle ( tmp [ 1 ] ) ;
17048: LD_VAR 0 5
17052: PUSH
17053: LD_INT 1
17055: ARRAY
17056: PPUSH
17057: CALL_OW 181
// if Lisa in vip and GetSide ( Lisa ) = 1 then
17061: LD_EXP 39
17065: PUSH
17066: LD_EXP 56
17070: IN
17071: PUSH
17072: LD_EXP 39
17076: PPUSH
17077: CALL_OW 255
17081: PUSH
17082: LD_INT 1
17084: EQUAL
17085: AND
17086: IFFALSE 17102
// Say ( Lisa , D3nW-Lisa-1 ) else
17088: LD_EXP 39
17092: PPUSH
17093: LD_STRING D3nW-Lisa-1
17095: PPUSH
17096: CALL_OW 88
17100: GO 17346
// if Cyrus in vip and GetSide ( Cyrus ) = 1 then
17102: LD_EXP 42
17106: PUSH
17107: LD_EXP 56
17111: IN
17112: PUSH
17113: LD_EXP 42
17117: PPUSH
17118: CALL_OW 255
17122: PUSH
17123: LD_INT 1
17125: EQUAL
17126: AND
17127: IFFALSE 17143
// Say ( Cyrus , D3nW-Cyrus-1 ) else
17129: LD_EXP 42
17133: PPUSH
17134: LD_STRING D3nW-Cyrus-1
17136: PPUSH
17137: CALL_OW 88
17141: GO 17346
// if Bobby in vip and GetSide ( Bobby ) = 1 then
17143: LD_EXP 41
17147: PUSH
17148: LD_EXP 56
17152: IN
17153: PUSH
17154: LD_EXP 41
17158: PPUSH
17159: CALL_OW 255
17163: PUSH
17164: LD_INT 1
17166: EQUAL
17167: AND
17168: IFFALSE 17184
// Say ( Bobby , D3nW-Bobby-1 ) else
17170: LD_EXP 41
17174: PPUSH
17175: LD_STRING D3nW-Bobby-1
17177: PPUSH
17178: CALL_OW 88
17182: GO 17346
// if Gary in vip and GetSide ( Gary ) = 1 then
17184: LD_EXP 48
17188: PUSH
17189: LD_EXP 56
17193: IN
17194: PUSH
17195: LD_EXP 48
17199: PPUSH
17200: CALL_OW 255
17204: PUSH
17205: LD_INT 1
17207: EQUAL
17208: AND
17209: IFFALSE 17225
// Say ( Gary , D3nW-Gary-1 ) else
17211: LD_EXP 48
17215: PPUSH
17216: LD_STRING D3nW-Gary-1
17218: PPUSH
17219: CALL_OW 88
17223: GO 17346
// if Donaldson in vip and GetSide ( Donaldson ) = 1 then
17225: LD_EXP 40
17229: PUSH
17230: LD_EXP 56
17234: IN
17235: PUSH
17236: LD_EXP 40
17240: PPUSH
17241: CALL_OW 255
17245: PUSH
17246: LD_INT 1
17248: EQUAL
17249: AND
17250: IFFALSE 17266
// Say ( Donaldson , D3nW-Don-1 ) else
17252: LD_EXP 40
17256: PPUSH
17257: LD_STRING D3nW-Don-1
17259: PPUSH
17260: CALL_OW 88
17264: GO 17346
// if Cornel in vip and GetSide ( Cornel ) = 1 then
17266: LD_EXP 47
17270: PUSH
17271: LD_EXP 56
17275: IN
17276: PUSH
17277: LD_EXP 47
17281: PPUSH
17282: CALL_OW 255
17286: PUSH
17287: LD_INT 1
17289: EQUAL
17290: AND
17291: IFFALSE 17307
// Say ( Cornel , D3nW-Corn-1 ) else
17293: LD_EXP 47
17297: PPUSH
17298: LD_STRING D3nW-Corn-1
17300: PPUSH
17301: CALL_OW 88
17305: GO 17346
// if Frank in vip and GetSide ( Frank ) = 1 then
17307: LD_EXP 49
17311: PUSH
17312: LD_EXP 56
17316: IN
17317: PUSH
17318: LD_EXP 49
17322: PPUSH
17323: CALL_OW 255
17327: PUSH
17328: LD_INT 1
17330: EQUAL
17331: AND
17332: IFFALSE 17346
// Say ( Frank , D3nW-Frank-1 ) ;
17334: LD_EXP 49
17338: PPUSH
17339: LD_STRING D3nW-Frank-1
17341: PPUSH
17342: CALL_OW 88
// Say ( JMM , D3nW-JMM-1 ) ;
17346: LD_EXP 36
17350: PPUSH
17351: LD_STRING D3nW-JMM-1
17353: PPUSH
17354: CALL_OW 88
// Say ( JMM , D3nW-JMM-1a ) ;
17358: LD_EXP 36
17362: PPUSH
17363: LD_STRING D3nW-JMM-1a
17365: PPUSH
17366: CALL_OW 88
// t := 0 0$00 ;
17370: LD_ADDR_VAR 0 3
17374: PUSH
17375: LD_INT 0
17377: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
17378: LD_INT 35
17380: PPUSH
17381: CALL_OW 67
// t := t + 0 0$1 ;
17385: LD_ADDR_VAR 0 3
17389: PUSH
17390: LD_VAR 0 3
17394: PUSH
17395: LD_INT 35
17397: PLUS
17398: ST_TO_ADDR
// until HexInfo ( 59 , 112 ) or t > 1 1$00 ;
17399: LD_INT 59
17401: PPUSH
17402: LD_INT 112
17404: PPUSH
17405: CALL_OW 428
17409: PUSH
17410: LD_VAR 0 3
17414: PUSH
17415: LD_INT 2100
17417: GREATER
17418: OR
17419: IFFALSE 17378
// activeAttacks := true ;
17421: LD_ADDR_EXP 16
17425: PUSH
17426: LD_INT 1
17428: ST_TO_ADDR
// end ;
17429: LD_VAR 0 1
17433: RET
// export function ResolveQuery ( question , list_of_q ) ; begin
17434: LD_INT 0
17436: PPUSH
// case question of 1 :
17437: LD_VAR 0 1
17441: PUSH
17442: LD_INT 1
17444: DOUBLE
17445: EQUAL
17446: IFTRUE 17450
17448: GO 17501
17450: POP
// begin Say ( JMM , D2Mot-JMM-1 ) ;
17451: LD_EXP 36
17455: PPUSH
17456: LD_STRING D2Mot-JMM-1
17458: PPUSH
17459: CALL_OW 88
// Say ( Powell , D2Mot-Pow-1 ) ;
17463: LD_EXP 55
17467: PPUSH
17468: LD_STRING D2Mot-Pow-1
17470: PPUSH
17471: CALL_OW 88
// Say ( JMM , D2Mot-JMM-2 ) ;
17475: LD_EXP 36
17479: PPUSH
17480: LD_STRING D2Mot-JMM-2
17482: PPUSH
17483: CALL_OW 88
// Say ( Powell , D2Mot-Pow-2 ) ;
17487: LD_EXP 55
17491: PPUSH
17492: LD_STRING D2Mot-Pow-2
17494: PPUSH
17495: CALL_OW 88
// end ; 2 :
17499: GO 17844
17501: LD_INT 2
17503: DOUBLE
17504: EQUAL
17505: IFTRUE 17509
17507: GO 17585
17509: POP
// begin Say ( JMM , D2Rus-JMM-1 ) ;
17510: LD_EXP 36
17514: PPUSH
17515: LD_STRING D2Rus-JMM-1
17517: PPUSH
17518: CALL_OW 88
// Say ( Powell , D2Rus-Pow-1 ) ;
17522: LD_EXP 55
17526: PPUSH
17527: LD_STRING D2Rus-Pow-1
17529: PPUSH
17530: CALL_OW 88
// Say ( JMM , D2Rus-JMM-2 ) ;
17534: LD_EXP 36
17538: PPUSH
17539: LD_STRING D2Rus-JMM-2
17541: PPUSH
17542: CALL_OW 88
// if not ( 3 in list_of_q ) then
17546: LD_INT 3
17548: PUSH
17549: LD_VAR 0 2
17553: IN
17554: NOT
17555: IFFALSE 17571
// Say ( Powell , D2Rus-Pow-2 ) else
17557: LD_EXP 55
17561: PPUSH
17562: LD_STRING D2Rus-Pow-2
17564: PPUSH
17565: CALL_OW 88
17569: GO 17583
// Say ( Powell , D2Rus-Pow-2a ) ;
17571: LD_EXP 55
17575: PPUSH
17576: LD_STRING D2Rus-Pow-2a
17578: PPUSH
17579: CALL_OW 88
// end ; 3 :
17583: GO 17844
17585: LD_INT 3
17587: DOUBLE
17588: EQUAL
17589: IFTRUE 17593
17591: GO 17678
17593: POP
// begin Say ( JMM , D2Leg-JMM-1 ) ;
17594: LD_EXP 36
17598: PPUSH
17599: LD_STRING D2Leg-JMM-1
17601: PPUSH
17602: CALL_OW 88
// Say ( Powell , D2Leg-Pow-1 ) ;
17606: LD_EXP 55
17610: PPUSH
17611: LD_STRING D2Leg-Pow-1
17613: PPUSH
17614: CALL_OW 88
// if 2 in list_of_q then
17618: LD_INT 2
17620: PUSH
17621: LD_VAR 0 2
17625: IN
17626: IFFALSE 17652
// begin Say ( JMM , D2Leg-JMM-2 ) ;
17628: LD_EXP 36
17632: PPUSH
17633: LD_STRING D2Leg-JMM-2
17635: PPUSH
17636: CALL_OW 88
// Say ( Powell , D2Leg-Pow-2 ) ;
17640: LD_EXP 55
17644: PPUSH
17645: LD_STRING D2Leg-Pow-2
17647: PPUSH
17648: CALL_OW 88
// end ; Say ( JMM , D2Leg-JMM-3 ) ;
17652: LD_EXP 36
17656: PPUSH
17657: LD_STRING D2Leg-JMM-3
17659: PPUSH
17660: CALL_OW 88
// Say ( Powell , D2Leg-Pow-3 ) ;
17664: LD_EXP 55
17668: PPUSH
17669: LD_STRING D2Leg-Pow-3
17671: PPUSH
17672: CALL_OW 88
// end ; 4 :
17676: GO 17844
17678: LD_INT 4
17680: DOUBLE
17681: EQUAL
17682: IFTRUE 17686
17684: GO 17761
17686: POP
// begin Say ( JMM , D2Ar-JMM-1 ) ;
17687: LD_EXP 36
17691: PPUSH
17692: LD_STRING D2Ar-JMM-1
17694: PPUSH
17695: CALL_OW 88
// Say ( Powell , D2Ar-Pow-1 ) ;
17699: LD_EXP 55
17703: PPUSH
17704: LD_STRING D2Ar-Pow-1
17706: PPUSH
17707: CALL_OW 88
// Say ( JMM , D2Ar-JMM-2 ) ;
17711: LD_EXP 36
17715: PPUSH
17716: LD_STRING D2Ar-JMM-2
17718: PPUSH
17719: CALL_OW 88
// Say ( Powell , D2Ar-Pow-2 ) ;
17723: LD_EXP 55
17727: PPUSH
17728: LD_STRING D2Ar-Pow-2
17730: PPUSH
17731: CALL_OW 88
// Say ( JMM , D2Ar-JMM-3 ) ;
17735: LD_EXP 36
17739: PPUSH
17740: LD_STRING D2Ar-JMM-3
17742: PPUSH
17743: CALL_OW 88
// Say ( Powell , D2Ar-Pow-3 ) ;
17747: LD_EXP 55
17751: PPUSH
17752: LD_STRING D2Ar-Pow-3
17754: PPUSH
17755: CALL_OW 88
// end ; 5 :
17759: GO 17844
17761: LD_INT 5
17763: DOUBLE
17764: EQUAL
17765: IFTRUE 17769
17767: GO 17784
17769: POP
// Say ( JMM , D2Conf-JMM-1 ) ; 6 :
17770: LD_EXP 36
17774: PPUSH
17775: LD_STRING D2Conf-JMM-1
17777: PPUSH
17778: CALL_OW 88
17782: GO 17844
17784: LD_INT 6
17786: DOUBLE
17787: EQUAL
17788: IFTRUE 17792
17790: GO 17843
17792: POP
// begin Say ( JMM , D2Com-JMM-1 ) ;
17793: LD_EXP 36
17797: PPUSH
17798: LD_STRING D2Com-JMM-1
17800: PPUSH
17801: CALL_OW 88
// Say ( Powell , D2Com-Pow-1 ) ;
17805: LD_EXP 55
17809: PPUSH
17810: LD_STRING D2Com-Pow-1
17812: PPUSH
17813: CALL_OW 88
// Say ( JMM , D2Com-JMM-2 ) ;
17817: LD_EXP 36
17821: PPUSH
17822: LD_STRING D2Com-JMM-2
17824: PPUSH
17825: CALL_OW 88
// Say ( Powell , D2Com-Pow-2 ) ;
17829: LD_EXP 55
17833: PPUSH
17834: LD_STRING D2Com-Pow-2
17836: PPUSH
17837: CALL_OW 88
// end ; end ;
17841: GO 17844
17843: POP
// end ;
17844: LD_VAR 0 3
17848: RET
// every 0 0$5 trigger missionStart do var tmp ;
17849: LD_EXP 13
17853: IFFALSE 18136
17855: GO 17857
17857: DISABLE
17858: LD_INT 0
17860: PPUSH
// begin repeat wait ( 0 0$1 ) ;
17861: LD_INT 35
17863: PPUSH
17864: CALL_OW 67
// if FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) and missionStage in [ 2 , 3 , 4 , 5 ] then
17868: LD_INT 14
17870: PPUSH
17871: LD_INT 22
17873: PUSH
17874: LD_INT 1
17876: PUSH
17877: EMPTY
17878: LIST
17879: LIST
17880: PPUSH
17881: CALL_OW 70
17885: PUSH
17886: LD_EXP 15
17890: PUSH
17891: LD_INT 2
17893: PUSH
17894: LD_INT 3
17896: PUSH
17897: LD_INT 4
17899: PUSH
17900: LD_INT 5
17902: PUSH
17903: EMPTY
17904: LIST
17905: LIST
17906: LIST
17907: LIST
17908: IN
17909: AND
17910: IFFALSE 18126
// begin powellAnger := powellAnger + 1 ;
17912: LD_ADDR_EXP 17
17916: PUSH
17917: LD_EXP 17
17921: PUSH
17922: LD_INT 1
17924: PLUS
17925: ST_TO_ADDR
// Video ( true ) ;
17926: LD_INT 1
17928: PPUSH
17929: CALL 106804 0 1
// CenterNowOnUnits ( tmp ) ;
17933: LD_VAR 0 1
17937: PPUSH
17938: CALL_OW 87
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
17942: LD_INT 14
17944: PPUSH
17945: LD_INT 22
17947: PUSH
17948: LD_INT 1
17950: PUSH
17951: EMPTY
17952: LIST
17953: LIST
17954: PPUSH
17955: CALL_OW 70
17959: PPUSH
17960: LD_INT 86
17962: PPUSH
17963: LD_INT 133
17965: PPUSH
17966: CALL_OW 111
// async ;
17970: ASYNC
// case powellAnger of 1 :
17971: LD_EXP 17
17975: PUSH
17976: LD_INT 1
17978: DOUBLE
17979: EQUAL
17980: IFTRUE 17984
17982: GO 17999
17984: POP
// Say ( Powell , DBack1-Pow-1 ) ; 2 :
17985: LD_EXP 55
17989: PPUSH
17990: LD_STRING DBack1-Pow-1
17992: PPUSH
17993: CALL_OW 88
17997: GO 18046
17999: LD_INT 2
18001: DOUBLE
18002: EQUAL
18003: IFTRUE 18007
18005: GO 18022
18007: POP
// Say ( Powell , DBack2-Pow-1 ) ; 3 :
18008: LD_EXP 55
18012: PPUSH
18013: LD_STRING DBack2-Pow-1
18015: PPUSH
18016: CALL_OW 88
18020: GO 18046
18022: LD_INT 3
18024: DOUBLE
18025: EQUAL
18026: IFTRUE 18030
18028: GO 18045
18030: POP
// Say ( Powell , DBack3-Pow-1 ) ; end ;
18031: LD_EXP 55
18035: PPUSH
18036: LD_STRING DBack3-Pow-1
18038: PPUSH
18039: CALL_OW 88
18043: GO 18046
18045: POP
// sync ;
18046: SYNC
// repeat wait ( 0 0$1 ) ;
18047: LD_INT 35
18049: PPUSH
18050: CALL_OW 67
// ComMoveXY ( FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) , 86 , 133 ) ;
18054: LD_INT 14
18056: PPUSH
18057: LD_INT 22
18059: PUSH
18060: LD_INT 1
18062: PUSH
18063: EMPTY
18064: LIST
18065: LIST
18066: PPUSH
18067: CALL_OW 70
18071: PPUSH
18072: LD_INT 86
18074: PPUSH
18075: LD_INT 133
18077: PPUSH
18078: CALL_OW 111
// until not FilterUnitsInArea ( powellBorder , [ f_side , 1 ] ) ;
18082: LD_INT 14
18084: PPUSH
18085: LD_INT 22
18087: PUSH
18088: LD_INT 1
18090: PUSH
18091: EMPTY
18092: LIST
18093: LIST
18094: PPUSH
18095: CALL_OW 70
18099: NOT
18100: IFFALSE 18047
// if powellAnger >= 3 then
18102: LD_EXP 17
18106: PUSH
18107: LD_INT 3
18109: GREATEREQUAL
18110: IFFALSE 18119
// YouLost ( Dismissed ) ;
18112: LD_STRING Dismissed
18114: PPUSH
18115: CALL_OW 104
// Video ( false ) ;
18119: LD_INT 0
18121: PPUSH
18122: CALL 106804 0 1
// end ; until missionStage > 5 ;
18126: LD_EXP 15
18130: PUSH
18131: LD_INT 5
18133: GREATER
18134: IFFALSE 17861
// end ;
18136: PPOPN 1
18138: END
// every 0 0$30 trigger missionStart and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 4 and missionStage = 2 do var i , tmp , tmp2 , retreat , arm , bar , ru , un ;
18139: LD_EXP 13
18143: PUSH
18144: LD_INT 22
18146: PUSH
18147: LD_INT 4
18149: PUSH
18150: EMPTY
18151: LIST
18152: LIST
18153: PUSH
18154: LD_INT 21
18156: PUSH
18157: LD_INT 2
18159: PUSH
18160: EMPTY
18161: LIST
18162: LIST
18163: PUSH
18164: EMPTY
18165: LIST
18166: LIST
18167: PPUSH
18168: CALL_OW 69
18172: PUSH
18173: LD_INT 4
18175: GREATEREQUAL
18176: AND
18177: PUSH
18178: LD_EXP 15
18182: PUSH
18183: LD_INT 2
18185: EQUAL
18186: AND
18187: IFFALSE 20010
18189: GO 18191
18191: DISABLE
18192: LD_INT 0
18194: PPUSH
18195: PPUSH
18196: PPUSH
18197: PPUSH
18198: PPUSH
18199: PPUSH
18200: PPUSH
18201: PPUSH
// begin missionStage := 3 ;
18202: LD_ADDR_EXP 15
18206: PUSH
18207: LD_INT 3
18209: ST_TO_ADDR
// retreat := false ;
18210: LD_ADDR_VAR 0 4
18214: PUSH
18215: LD_INT 0
18217: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_armoury ] ] ) ;
18218: LD_ADDR_VAR 0 5
18222: PUSH
18223: LD_INT 22
18225: PUSH
18226: LD_INT 4
18228: PUSH
18229: EMPTY
18230: LIST
18231: LIST
18232: PUSH
18233: LD_INT 30
18235: PUSH
18236: LD_INT 4
18238: PUSH
18239: EMPTY
18240: LIST
18241: LIST
18242: PUSH
18243: EMPTY
18244: LIST
18245: LIST
18246: PPUSH
18247: CALL_OW 69
18251: ST_TO_ADDR
// bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18252: LD_ADDR_VAR 0 6
18256: PUSH
18257: LD_INT 22
18259: PUSH
18260: LD_INT 4
18262: PUSH
18263: EMPTY
18264: LIST
18265: LIST
18266: PUSH
18267: LD_INT 30
18269: PUSH
18270: LD_INT 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: PPUSH
18281: CALL_OW 69
18285: ST_TO_ADDR
// if not bar then
18286: LD_VAR 0 6
18290: NOT
18291: IFFALSE 18344
// begin repeat wait ( 0 0$1 ) ;
18293: LD_INT 35
18295: PPUSH
18296: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_not , [ f_constructed ] ] , [ f_btype , b_barracks ] ] ) ;
18300: LD_INT 22
18302: PUSH
18303: LD_INT 4
18305: PUSH
18306: EMPTY
18307: LIST
18308: LIST
18309: PUSH
18310: LD_INT 3
18312: PUSH
18313: LD_INT 57
18315: PUSH
18316: EMPTY
18317: LIST
18318: PUSH
18319: EMPTY
18320: LIST
18321: LIST
18322: PUSH
18323: LD_INT 30
18325: PUSH
18326: LD_INT 5
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: PUSH
18333: EMPTY
18334: LIST
18335: LIST
18336: LIST
18337: PPUSH
18338: CALL_OW 69
18342: IFFALSE 18293
// end ; bar := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_barracks ] ] ) ;
18344: LD_ADDR_VAR 0 6
18348: PUSH
18349: LD_INT 22
18351: PUSH
18352: LD_INT 4
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: PUSH
18359: LD_INT 30
18361: PUSH
18362: LD_INT 5
18364: PUSH
18365: EMPTY
18366: LIST
18367: LIST
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: PPUSH
18373: CALL_OW 69
18377: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
18378: LD_INT 35
18380: PPUSH
18381: CALL_OW 67
// until mc_vehicles [ 4 ] >= 4 ;
18385: LD_EXP 118
18389: PUSH
18390: LD_INT 4
18392: ARRAY
18393: PUSH
18394: LD_INT 4
18396: GREATEREQUAL
18397: IFFALSE 18378
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] ] ] ) diff ( Powell ^ vip ) ;
18399: LD_ADDR_VAR 0 2
18403: PUSH
18404: LD_INT 22
18406: PUSH
18407: LD_INT 4
18409: PUSH
18410: EMPTY
18411: LIST
18412: LIST
18413: PUSH
18414: LD_INT 2
18416: PUSH
18417: LD_INT 25
18419: PUSH
18420: LD_INT 1
18422: PUSH
18423: EMPTY
18424: LIST
18425: LIST
18426: PUSH
18427: LD_INT 25
18429: PUSH
18430: LD_INT 2
18432: PUSH
18433: EMPTY
18434: LIST
18435: LIST
18436: PUSH
18437: LD_INT 25
18439: PUSH
18440: LD_INT 3
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: LD_INT 25
18449: PUSH
18450: LD_INT 4
18452: PUSH
18453: EMPTY
18454: LIST
18455: LIST
18456: PUSH
18457: LD_INT 25
18459: PUSH
18460: LD_INT 5
18462: PUSH
18463: EMPTY
18464: LIST
18465: LIST
18466: PUSH
18467: EMPTY
18468: LIST
18469: LIST
18470: LIST
18471: LIST
18472: LIST
18473: LIST
18474: PUSH
18475: EMPTY
18476: LIST
18477: LIST
18478: PPUSH
18479: CALL_OW 69
18483: PUSH
18484: LD_EXP 55
18488: PUSH
18489: LD_EXP 56
18493: ADD
18494: DIFF
18495: ST_TO_ADDR
// tmp2 := UnitFilter ( tmp , [ f_sex , sex_male ] ) ;
18496: LD_ADDR_VAR 0 3
18500: PUSH
18501: LD_VAR 0 2
18505: PPUSH
18506: LD_INT 26
18508: PUSH
18509: LD_INT 1
18511: PUSH
18512: EMPTY
18513: LIST
18514: LIST
18515: PPUSH
18516: CALL_OW 72
18520: ST_TO_ADDR
// tmp := tmp diff tmp2 ;
18521: LD_ADDR_VAR 0 2
18525: PUSH
18526: LD_VAR 0 2
18530: PUSH
18531: LD_VAR 0 3
18535: DIFF
18536: ST_TO_ADDR
// tmp := SortBySkill ( tmp , 1 ) ;
18537: LD_ADDR_VAR 0 2
18541: PUSH
18542: LD_VAR 0 2
18546: PPUSH
18547: LD_INT 1
18549: PPUSH
18550: CALL 105457 0 2
18554: ST_TO_ADDR
// tmp2 := SortBySkill ( tmp2 , 1 ) ;
18555: LD_ADDR_VAR 0 3
18559: PUSH
18560: LD_VAR 0 3
18564: PPUSH
18565: LD_INT 1
18567: PPUSH
18568: CALL 105457 0 2
18572: ST_TO_ADDR
// for i = 1 to 4 do
18573: LD_ADDR_VAR 0 1
18577: PUSH
18578: DOUBLE
18579: LD_INT 1
18581: DEC
18582: ST_TO_ADDR
18583: LD_INT 4
18585: PUSH
18586: FOR_TO
18587: IFFALSE 18753
// begin if tmp2 then
18589: LD_VAR 0 3
18593: IFFALSE 18674
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp2 [ tmp2 ] ) ;
18595: LD_ADDR_EXP 18
18599: PUSH
18600: LD_EXP 18
18604: PPUSH
18605: LD_INT 1
18607: PPUSH
18608: LD_EXP 18
18612: PUSH
18613: LD_INT 1
18615: ARRAY
18616: PUSH
18617: LD_VAR 0 3
18621: PUSH
18622: LD_VAR 0 3
18626: ARRAY
18627: ADD
18628: PPUSH
18629: CALL_OW 1
18633: ST_TO_ADDR
// SetTag ( tmp2 [ tmp2 ] , 1 ) ;
18634: LD_VAR 0 3
18638: PUSH
18639: LD_VAR 0 3
18643: ARRAY
18644: PPUSH
18645: LD_INT 1
18647: PPUSH
18648: CALL_OW 109
// tmp2 := Delete ( tmp2 , tmp2 ) ;
18652: LD_ADDR_VAR 0 3
18656: PUSH
18657: LD_VAR 0 3
18661: PPUSH
18662: LD_VAR 0 3
18666: PPUSH
18667: CALL_OW 3
18671: ST_TO_ADDR
// end else
18672: GO 18751
// begin powellSquadAttack := Replace ( powellSquadAttack , 1 , powellSquadAttack [ 1 ] ^ tmp [ tmp ] ) ;
18674: LD_ADDR_EXP 18
18678: PUSH
18679: LD_EXP 18
18683: PPUSH
18684: LD_INT 1
18686: PPUSH
18687: LD_EXP 18
18691: PUSH
18692: LD_INT 1
18694: ARRAY
18695: PUSH
18696: LD_VAR 0 2
18700: PUSH
18701: LD_VAR 0 2
18705: ARRAY
18706: ADD
18707: PPUSH
18708: CALL_OW 1
18712: ST_TO_ADDR
// SetTag ( tmp [ tmp ] , 1 ) ;
18713: LD_VAR 0 2
18717: PUSH
18718: LD_VAR 0 2
18722: ARRAY
18723: PPUSH
18724: LD_INT 1
18726: PPUSH
18727: CALL_OW 109
// tmp := Delete ( tmp , tmp ) ;
18731: LD_ADDR_VAR 0 2
18735: PUSH
18736: LD_VAR 0 2
18740: PPUSH
18741: LD_VAR 0 2
18745: PPUSH
18746: CALL_OW 3
18750: ST_TO_ADDR
// end ; end ;
18751: GO 18586
18753: POP
18754: POP
// if tmp2 then
18755: LD_VAR 0 3
18759: IFFALSE 18777
// tmp := tmp union tmp2 ;
18761: LD_ADDR_VAR 0 2
18765: PUSH
18766: LD_VAR 0 2
18770: PUSH
18771: LD_VAR 0 3
18775: UNION
18776: ST_TO_ADDR
// for i = 1 to 4 do
18777: LD_ADDR_VAR 0 1
18781: PUSH
18782: DOUBLE
18783: LD_INT 1
18785: DEC
18786: ST_TO_ADDR
18787: LD_INT 4
18789: PUSH
18790: FOR_TO
18791: IFFALSE 18840
// powellSquadAttack := Replace ( powellSquadAttack , 2 , powellSquadAttack [ 2 ] ^ tmp [ tmp - i ] ) ;
18793: LD_ADDR_EXP 18
18797: PUSH
18798: LD_EXP 18
18802: PPUSH
18803: LD_INT 2
18805: PPUSH
18806: LD_EXP 18
18810: PUSH
18811: LD_INT 2
18813: ARRAY
18814: PUSH
18815: LD_VAR 0 2
18819: PUSH
18820: LD_VAR 0 2
18824: PUSH
18825: LD_VAR 0 1
18829: MINUS
18830: ARRAY
18831: ADD
18832: PPUSH
18833: CALL_OW 1
18837: ST_TO_ADDR
18838: GO 18790
18840: POP
18841: POP
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] diff powellSquadAttack [ 1 ] ) ;
18842: LD_ADDR_EXP 99
18846: PUSH
18847: LD_EXP 99
18851: PPUSH
18852: LD_INT 4
18854: PPUSH
18855: LD_EXP 99
18859: PUSH
18860: LD_INT 4
18862: ARRAY
18863: PUSH
18864: LD_EXP 18
18868: PUSH
18869: LD_INT 1
18871: ARRAY
18872: DIFF
18873: PPUSH
18874: CALL_OW 1
18878: ST_TO_ADDR
// if UnitsInside ( arm [ 1 ] ) then
18879: LD_VAR 0 5
18883: PUSH
18884: LD_INT 1
18886: ARRAY
18887: PPUSH
18888: CALL_OW 313
18892: IFFALSE 18947
// begin for i in UnitsInside ( arm [ 1 ] ) do
18894: LD_ADDR_VAR 0 1
18898: PUSH
18899: LD_VAR 0 5
18903: PUSH
18904: LD_INT 1
18906: ARRAY
18907: PPUSH
18908: CALL_OW 313
18912: PUSH
18913: FOR_IN
18914: IFFALSE 18945
// begin ComExitBuilding ( i ) ;
18916: LD_VAR 0 1
18920: PPUSH
18921: CALL_OW 122
// AddComEnterUnit ( i , bar [ 1 ] ) ;
18925: LD_VAR 0 1
18929: PPUSH
18930: LD_VAR 0 6
18934: PUSH
18935: LD_INT 1
18937: ARRAY
18938: PPUSH
18939: CALL_OW 180
// end ;
18943: GO 18913
18945: POP
18946: POP
// end ; wait ( 0 0$3 ) ;
18947: LD_INT 105
18949: PPUSH
18950: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
18954: LD_ADDR_VAR 0 1
18958: PUSH
18959: LD_EXP 18
18963: PUSH
18964: LD_INT 1
18966: ARRAY
18967: PUSH
18968: FOR_IN
18969: IFFALSE 19076
// begin if IsInUnit ( i ) then
18971: LD_VAR 0 1
18975: PPUSH
18976: CALL_OW 310
18980: IFFALSE 18991
// ComExitBuilding ( i ) ;
18982: LD_VAR 0 1
18986: PPUSH
18987: CALL_OW 122
// if GetClass ( i ) <> 1 then
18991: LD_VAR 0 1
18995: PPUSH
18996: CALL_OW 257
19000: PUSH
19001: LD_INT 1
19003: NONEQUAL
19004: IFFALSE 19045
// begin AddComEnterUnit ( i , arm [ 1 ] ) ;
19006: LD_VAR 0 1
19010: PPUSH
19011: LD_VAR 0 5
19015: PUSH
19016: LD_INT 1
19018: ARRAY
19019: PPUSH
19020: CALL_OW 180
// AddComChangeProfession ( i , class_soldier ) ;
19024: LD_VAR 0 1
19028: PPUSH
19029: LD_INT 1
19031: PPUSH
19032: CALL_OW 183
// AddComExitBuilding ( i ) ;
19036: LD_VAR 0 1
19040: PPUSH
19041: CALL_OW 182
// end ; AddComMoveXY ( i , 60 , 94 ) ;
19045: LD_VAR 0 1
19049: PPUSH
19050: LD_INT 60
19052: PPUSH
19053: LD_INT 94
19055: PPUSH
19056: CALL_OW 171
// AddComTurnUnit ( i , Powell ) ;
19060: LD_VAR 0 1
19064: PPUSH
19065: LD_EXP 55
19069: PPUSH
19070: CALL_OW 179
// end ;
19074: GO 18968
19076: POP
19077: POP
// wait ( 0 0$15 ) ;
19078: LD_INT 525
19080: PPUSH
19081: CALL_OW 67
// Say ( Powell , D4-Pow-1 ) ;
19085: LD_EXP 55
19089: PPUSH
19090: LD_STRING D4-Pow-1
19092: PPUSH
19093: CALL_OW 88
// tmp := UnitFilter ( powellSquadAttack [ 1 ] , [ f_sex , sex_male ] ) ;
19097: LD_ADDR_VAR 0 2
19101: PUSH
19102: LD_EXP 18
19106: PUSH
19107: LD_INT 1
19109: ARRAY
19110: PPUSH
19111: LD_INT 26
19113: PUSH
19114: LD_INT 1
19116: PUSH
19117: EMPTY
19118: LIST
19119: LIST
19120: PPUSH
19121: CALL_OW 72
19125: ST_TO_ADDR
// if tmp then
19126: LD_VAR 0 2
19130: IFFALSE 19148
// Say ( tmp [ 1 ] , D4-Sol1-1 ) ;
19132: LD_VAR 0 2
19136: PUSH
19137: LD_INT 1
19139: ARRAY
19140: PPUSH
19141: LD_STRING D4-Sol1-1
19143: PPUSH
19144: CALL_OW 88
// Say ( Powell , D4-Pow-2 ) ;
19148: LD_EXP 55
19152: PPUSH
19153: LD_STRING D4-Pow-2
19155: PPUSH
19156: CALL_OW 88
// for i = 1 to powellSquadAttack [ 1 ] do
19160: LD_ADDR_VAR 0 1
19164: PUSH
19165: DOUBLE
19166: LD_INT 1
19168: DEC
19169: ST_TO_ADDR
19170: LD_EXP 18
19174: PUSH
19175: LD_INT 1
19177: ARRAY
19178: PUSH
19179: FOR_TO
19180: IFFALSE 19273
// begin ComEnterUnit ( powellSquadAttack [ 1 ] [ i ] , mc_vehicles [ 4 ] [ 1 ] ) ;
19182: LD_EXP 18
19186: PUSH
19187: LD_INT 1
19189: ARRAY
19190: PUSH
19191: LD_VAR 0 1
19195: ARRAY
19196: PPUSH
19197: LD_EXP 118
19201: PUSH
19202: LD_INT 4
19204: ARRAY
19205: PUSH
19206: LD_INT 1
19208: ARRAY
19209: PPUSH
19210: CALL_OW 120
// mc_vehicles := Replace ( mc_vehicles , 4 , Delete ( mc_vehicles [ 4 ] , 1 ) ) ;
19214: LD_ADDR_EXP 118
19218: PUSH
19219: LD_EXP 118
19223: PPUSH
19224: LD_INT 4
19226: PPUSH
19227: LD_EXP 118
19231: PUSH
19232: LD_INT 4
19234: ARRAY
19235: PPUSH
19236: LD_INT 1
19238: PPUSH
19239: CALL_OW 3
19243: PPUSH
19244: CALL_OW 1
19248: ST_TO_ADDR
// DoNotAttack ( 8 , powellSquadAttack [ 1 ] [ i ] ) ;
19249: LD_INT 8
19251: PPUSH
19252: LD_EXP 18
19256: PUSH
19257: LD_INT 1
19259: ARRAY
19260: PUSH
19261: LD_VAR 0 1
19265: ARRAY
19266: PPUSH
19267: CALL_OW 471
// end ;
19271: GO 19179
19273: POP
19274: POP
// repeat wait ( 0 0$1 ) ;
19275: LD_INT 35
19277: PPUSH
19278: CALL_OW 67
// until UnitFilter ( powellSquadAttack [ 1 ] , [ f_driving ] ) >= 4 ;
19282: LD_EXP 18
19286: PUSH
19287: LD_INT 1
19289: ARRAY
19290: PPUSH
19291: LD_INT 55
19293: PUSH
19294: EMPTY
19295: LIST
19296: PPUSH
19297: CALL_OW 72
19301: PUSH
19302: LD_INT 4
19304: GREATEREQUAL
19305: IFFALSE 19275
// ComMoveXY ( powellSquadAttack [ 1 ] , 69 , 94 ) ;
19307: LD_EXP 18
19311: PUSH
19312: LD_INT 1
19314: ARRAY
19315: PPUSH
19316: LD_INT 69
19318: PPUSH
19319: LD_INT 94
19321: PPUSH
19322: CALL_OW 111
// AddComMoveXY ( powellSquadAttack [ 1 ] , 82 , 83 ) ;
19326: LD_EXP 18
19330: PUSH
19331: LD_INT 1
19333: ARRAY
19334: PPUSH
19335: LD_INT 82
19337: PPUSH
19338: LD_INT 83
19340: PPUSH
19341: CALL_OW 171
// AddComAgressiveMove ( powellSquadAttack [ 1 ] , 77 , 69 ) ;
19345: LD_EXP 18
19349: PUSH
19350: LD_INT 1
19352: ARRAY
19353: PPUSH
19354: LD_INT 77
19356: PPUSH
19357: LD_INT 69
19359: PPUSH
19360: CALL_OW 174
// repeat wait ( 3 ) ;
19364: LD_INT 3
19366: PPUSH
19367: CALL_OW 67
// for i in powellSquadAttack [ 1 ] do
19371: LD_ADDR_VAR 0 1
19375: PUSH
19376: LD_EXP 18
19380: PUSH
19381: LD_INT 1
19383: ARRAY
19384: PUSH
19385: FOR_IN
19386: IFFALSE 19522
// begin if GetLives ( i ) < 990 then
19388: LD_VAR 0 1
19392: PPUSH
19393: CALL_OW 256
19397: PUSH
19398: LD_INT 990
19400: LESS
19401: IFFALSE 19415
// SetLives ( i , 1000 ) ;
19403: LD_VAR 0 1
19407: PPUSH
19408: LD_INT 1000
19410: PPUSH
19411: CALL_OW 234
// if not IsInUnit ( i ) then
19415: LD_VAR 0 1
19419: PPUSH
19420: CALL_OW 310
19424: NOT
19425: IFFALSE 19520
// begin if not HasTask ( i ) then
19427: LD_VAR 0 1
19431: PPUSH
19432: CALL_OW 314
19436: NOT
19437: IFFALSE 19454
// ComMoveXY ( i , 64 , 93 ) ;
19439: LD_VAR 0 1
19443: PPUSH
19444: LD_INT 64
19446: PPUSH
19447: LD_INT 93
19449: PPUSH
19450: CALL_OW 111
// if not retreat and GetSex ( i ) = sex_male then
19454: LD_VAR 0 4
19458: NOT
19459: PUSH
19460: LD_VAR 0 1
19464: PPUSH
19465: CALL_OW 258
19469: PUSH
19470: LD_INT 1
19472: EQUAL
19473: AND
19474: IFFALSE 19520
// begin retreat := true ;
19476: LD_ADDR_VAR 0 4
19480: PUSH
19481: LD_INT 1
19483: ST_TO_ADDR
// SetTag ( i , 2 ) ;
19484: LD_VAR 0 1
19488: PPUSH
19489: LD_INT 2
19491: PPUSH
19492: CALL_OW 109
// Say ( i , D4a-Sol1-1 ) ;
19496: LD_VAR 0 1
19500: PPUSH
19501: LD_STRING D4a-Sol1-1
19503: PPUSH
19504: CALL_OW 88
// Say ( Powell , D4a-Pow-1 ) ;
19508: LD_EXP 55
19512: PPUSH
19513: LD_STRING D4a-Pow-1
19515: PPUSH
19516: CALL_OW 88
// end ; end ; end ;
19520: GO 19385
19522: POP
19523: POP
// until UnitFilter ( powellSquadAttack [ 1 ] , [ [ f_inarea , powellBase ] , [ f_not , [ f_driving ] ] ] ) >= 4 ;
19524: LD_EXP 18
19528: PUSH
19529: LD_INT 1
19531: ARRAY
19532: PPUSH
19533: LD_INT 95
19535: PUSH
19536: LD_INT 9
19538: PUSH
19539: EMPTY
19540: LIST
19541: LIST
19542: PUSH
19543: LD_INT 3
19545: PUSH
19546: LD_INT 55
19548: PUSH
19549: EMPTY
19550: LIST
19551: PUSH
19552: EMPTY
19553: LIST
19554: LIST
19555: PUSH
19556: EMPTY
19557: LIST
19558: LIST
19559: PPUSH
19560: CALL_OW 72
19564: PUSH
19565: LD_INT 4
19567: GREATEREQUAL
19568: IFFALSE 19364
// for i in powellSquadAttack [ 1 ] do
19570: LD_ADDR_VAR 0 1
19574: PUSH
19575: LD_EXP 18
19579: PUSH
19580: LD_INT 1
19582: ARRAY
19583: PUSH
19584: FOR_IN
19585: IFFALSE 19721
// begin if GetTag ( i ) = 2 then
19587: LD_VAR 0 1
19591: PPUSH
19592: CALL_OW 110
19596: PUSH
19597: LD_INT 2
19599: EQUAL
19600: IFFALSE 19662
// begin ComMoveXY ( i , 60 , 94 ) ;
19602: LD_VAR 0 1
19606: PPUSH
19607: LD_INT 60
19609: PPUSH
19610: LD_INT 94
19612: PPUSH
19613: CALL_OW 111
// AddComTurnUnit ( i , Powell ) ;
19617: LD_VAR 0 1
19621: PPUSH
19622: LD_EXP 55
19626: PPUSH
19627: CALL_OW 179
// wait ( 0 0$3 ) ;
19631: LD_INT 105
19633: PPUSH
19634: CALL_OW 67
// Say ( i , D4a-Sol1-2 ) ;
19638: LD_VAR 0 1
19642: PPUSH
19643: LD_STRING D4a-Sol1-2
19645: PPUSH
19646: CALL_OW 88
// Say ( Powell , D4a-Pow-2 ) ;
19650: LD_EXP 55
19654: PPUSH
19655: LD_STRING D4a-Pow-2
19657: PPUSH
19658: CALL_OW 88
// end ; SetTag ( i , 0 ) ;
19662: LD_VAR 0 1
19666: PPUSH
19667: LD_INT 0
19669: PPUSH
19670: CALL_OW 109
// mc_bases := Replace ( mc_bases , 4 , mc_bases [ 4 ] union i ) ;
19674: LD_ADDR_EXP 99
19678: PUSH
19679: LD_EXP 99
19683: PPUSH
19684: LD_INT 4
19686: PPUSH
19687: LD_EXP 99
19691: PUSH
19692: LD_INT 4
19694: ARRAY
19695: PUSH
19696: LD_VAR 0 1
19700: UNION
19701: PPUSH
19702: CALL_OW 1
19706: ST_TO_ADDR
// NormalAttack ( 8 , i ) ;
19707: LD_INT 8
19709: PPUSH
19710: LD_VAR 0 1
19714: PPUSH
19715: CALL_OW 472
// end ;
19719: GO 19584
19721: POP
19722: POP
// wait ( 4 4$00 ) ;
19723: LD_INT 8400
19725: PPUSH
19726: CALL_OW 67
// uc_side := 6 ;
19730: LD_ADDR_OWVAR 20
19734: PUSH
19735: LD_INT 6
19737: ST_TO_ADDR
// uc_nation := 3 ;
19738: LD_ADDR_OWVAR 21
19742: PUSH
19743: LD_INT 3
19745: ST_TO_ADDR
// ru := [ ] ;
19746: LD_ADDR_VAR 0 7
19750: PUSH
19751: EMPTY
19752: ST_TO_ADDR
// for i = 1 to 4 do
19753: LD_ADDR_VAR 0 1
19757: PUSH
19758: DOUBLE
19759: LD_INT 1
19761: DEC
19762: ST_TO_ADDR
19763: LD_INT 4
19765: PUSH
19766: FOR_TO
19767: IFFALSE 19868
// begin PrepareVehicle ( ru_medium_tracked , engine_combustion , control_computer , [ ru_gatling_gun , ru_gun ] [ rand ( 1 , 2 ) ] , 89 ) ;
19769: LD_INT 22
19771: PPUSH
19772: LD_INT 1
19774: PPUSH
19775: LD_INT 3
19777: PPUSH
19778: LD_INT 43
19780: PUSH
19781: LD_INT 44
19783: PUSH
19784: EMPTY
19785: LIST
19786: LIST
19787: PUSH
19788: LD_INT 1
19790: PPUSH
19791: LD_INT 2
19793: PPUSH
19794: CALL_OW 12
19798: ARRAY
19799: PPUSH
19800: LD_INT 89
19802: PPUSH
19803: CALL 71087 0 5
// un := CreateVehicle ;
19807: LD_ADDR_VAR 0 8
19811: PUSH
19812: CALL_OW 45
19816: ST_TO_ADDR
// SetDir ( un , 4 ) ;
19817: LD_VAR 0 8
19821: PPUSH
19822: LD_INT 4
19824: PPUSH
19825: CALL_OW 233
// PlaceUnitXYR ( un , 136 , 90 , 8 , false ) ;
19829: LD_VAR 0 8
19833: PPUSH
19834: LD_INT 136
19836: PPUSH
19837: LD_INT 90
19839: PPUSH
19840: LD_INT 8
19842: PPUSH
19843: LD_INT 0
19845: PPUSH
19846: CALL_OW 50
// ru := ru ^ un ;
19850: LD_ADDR_VAR 0 7
19854: PUSH
19855: LD_VAR 0 7
19859: PUSH
19860: LD_VAR 0 8
19864: ADD
19865: ST_TO_ADDR
// end ;
19866: GO 19766
19868: POP
19869: POP
// if ru then
19870: LD_VAR 0 7
19874: IFFALSE 19891
// ComAgressiveMove ( ru , 80 , 92 ) ;
19876: LD_VAR 0 7
19880: PPUSH
19881: LD_INT 80
19883: PPUSH
19884: LD_INT 92
19886: PPUSH
19887: CALL_OW 114
// wait ( 8 8$00 ) ;
19891: LD_INT 16800
19893: PPUSH
19894: CALL_OW 67
// MC_SetProduceList ( 4 , [ [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_manual , us_double_gun ] ] ) ;
19898: LD_INT 4
19900: PPUSH
19901: LD_INT 3
19903: PUSH
19904: LD_INT 1
19906: PUSH
19907: LD_INT 1
19909: PUSH
19910: LD_INT 5
19912: PUSH
19913: EMPTY
19914: LIST
19915: LIST
19916: LIST
19917: LIST
19918: PUSH
19919: LD_INT 4
19921: PUSH
19922: LD_INT 1
19924: PUSH
19925: LD_INT 1
19927: PUSH
19928: LD_INT 6
19930: PUSH
19931: EMPTY
19932: LIST
19933: LIST
19934: LIST
19935: LIST
19936: PUSH
19937: LD_INT 4
19939: PUSH
19940: LD_INT 1
19942: PUSH
19943: LD_INT 1
19945: PUSH
19946: LD_INT 7
19948: PUSH
19949: EMPTY
19950: LIST
19951: LIST
19952: LIST
19953: LIST
19954: PUSH
19955: LD_INT 3
19957: PUSH
19958: LD_INT 1
19960: PUSH
19961: LD_INT 1
19963: PUSH
19964: LD_INT 7
19966: PUSH
19967: EMPTY
19968: LIST
19969: LIST
19970: LIST
19971: LIST
19972: PUSH
19973: LD_INT 3
19975: PUSH
19976: LD_INT 1
19978: PUSH
19979: LD_INT 1
19981: PUSH
19982: LD_INT 5
19984: PUSH
19985: EMPTY
19986: LIST
19987: LIST
19988: LIST
19989: LIST
19990: PUSH
19991: EMPTY
19992: LIST
19993: LIST
19994: LIST
19995: LIST
19996: LIST
19997: PPUSH
19998: CALL 57669 0 2
// missionStage := 4 ;
20002: LD_ADDR_EXP 15
20006: PUSH
20007: LD_INT 4
20009: ST_TO_ADDR
// end ;
20010: PPOPN 8
20012: END
// every 0 0$30 trigger missionStage = 4 and FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] ] ) >= 5 do var i , j , tmp , tmp2 , xy , forces , _xy , dist , fac , arm , speaker , emp_towers , veh ;
20013: LD_EXP 15
20017: PUSH
20018: LD_INT 4
20020: EQUAL
20021: PUSH
20022: LD_INT 22
20024: PUSH
20025: LD_INT 4
20027: PUSH
20028: EMPTY
20029: LIST
20030: LIST
20031: PUSH
20032: LD_INT 21
20034: PUSH
20035: LD_INT 2
20037: PUSH
20038: EMPTY
20039: LIST
20040: LIST
20041: PUSH
20042: EMPTY
20043: LIST
20044: LIST
20045: PPUSH
20046: CALL_OW 69
20050: PUSH
20051: LD_INT 5
20053: GREATEREQUAL
20054: AND
20055: IFFALSE 24148
20057: GO 20059
20059: DISABLE
20060: LD_INT 0
20062: PPUSH
20063: PPUSH
20064: PPUSH
20065: PPUSH
20066: PPUSH
20067: PPUSH
20068: PPUSH
20069: PPUSH
20070: PPUSH
20071: PPUSH
20072: PPUSH
20073: PPUSH
20074: PPUSH
// begin missionStage := 5 ;
20075: LD_ADDR_EXP 15
20079: PUSH
20080: LD_INT 5
20082: ST_TO_ADDR
// arm := FilterAllUnits ( [ [ f_side , 4 ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ;
20083: LD_ADDR_VAR 0 10
20087: PUSH
20088: LD_INT 22
20090: PUSH
20091: LD_INT 4
20093: PUSH
20094: EMPTY
20095: LIST
20096: LIST
20097: PUSH
20098: LD_INT 2
20100: PUSH
20101: LD_INT 30
20103: PUSH
20104: LD_INT 4
20106: PUSH
20107: EMPTY
20108: LIST
20109: LIST
20110: PUSH
20111: LD_INT 30
20113: PUSH
20114: LD_INT 5
20116: PUSH
20117: EMPTY
20118: LIST
20119: LIST
20120: PUSH
20121: EMPTY
20122: LIST
20123: LIST
20124: LIST
20125: PUSH
20126: EMPTY
20127: LIST
20128: LIST
20129: PPUSH
20130: CALL_OW 69
20134: ST_TO_ADDR
// forces := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_human ] , [ f_not , [ f_class , 16 ] ] , [ f_not , [ f_class , 12 ] ] ] ) diff Powell ;
20135: LD_ADDR_VAR 0 6
20139: PUSH
20140: LD_INT 22
20142: PUSH
20143: LD_INT 4
20145: PUSH
20146: EMPTY
20147: LIST
20148: LIST
20149: PUSH
20150: LD_INT 21
20152: PUSH
20153: LD_INT 1
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: PUSH
20160: LD_INT 3
20162: PUSH
20163: LD_INT 25
20165: PUSH
20166: LD_INT 16
20168: PUSH
20169: EMPTY
20170: LIST
20171: LIST
20172: PUSH
20173: EMPTY
20174: LIST
20175: LIST
20176: PUSH
20177: LD_INT 3
20179: PUSH
20180: LD_INT 25
20182: PUSH
20183: LD_INT 12
20185: PUSH
20186: EMPTY
20187: LIST
20188: LIST
20189: PUSH
20190: EMPTY
20191: LIST
20192: LIST
20193: PUSH
20194: EMPTY
20195: LIST
20196: LIST
20197: LIST
20198: LIST
20199: PPUSH
20200: CALL_OW 69
20204: PUSH
20205: LD_EXP 55
20209: DIFF
20210: ST_TO_ADDR
// fac := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) [ 1 ] ;
20211: LD_ADDR_VAR 0 9
20215: PUSH
20216: LD_INT 22
20218: PUSH
20219: LD_INT 4
20221: PUSH
20222: EMPTY
20223: LIST
20224: LIST
20225: PUSH
20226: LD_INT 30
20228: PUSH
20229: LD_INT 3
20231: PUSH
20232: EMPTY
20233: LIST
20234: LIST
20235: PUSH
20236: EMPTY
20237: LIST
20238: LIST
20239: PPUSH
20240: CALL_OW 69
20244: PUSH
20245: LD_INT 1
20247: ARRAY
20248: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20249: LD_INT 35
20251: PPUSH
20252: CALL_OW 67
// until mc_vehicles [ 4 ] >= 5 and UnitFilter ( mc_vehicles [ 4 ] , [ f_empty ] ) >= 5 ;
20256: LD_EXP 118
20260: PUSH
20261: LD_INT 4
20263: ARRAY
20264: PUSH
20265: LD_INT 5
20267: GREATEREQUAL
20268: PUSH
20269: LD_EXP 118
20273: PUSH
20274: LD_INT 4
20276: ARRAY
20277: PPUSH
20278: LD_INT 58
20280: PUSH
20281: EMPTY
20282: LIST
20283: PPUSH
20284: CALL_OW 72
20288: PUSH
20289: LD_INT 5
20291: GREATEREQUAL
20292: AND
20293: IFFALSE 20249
// powellAllowRetreat := false ;
20295: LD_ADDR_EXP 19
20299: PUSH
20300: LD_INT 0
20302: ST_TO_ADDR
// wait ( 0 0$20 ) ;
20303: LD_INT 700
20305: PPUSH
20306: CALL_OW 67
// activeAttacks := false ;
20310: LD_ADDR_EXP 16
20314: PUSH
20315: LD_INT 0
20317: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
20318: LD_INT 35
20320: PPUSH
20321: CALL_OW 67
// until FilterAllUnits ( [ f_side , 6 ] ) = 0 ;
20325: LD_INT 22
20327: PUSH
20328: LD_INT 6
20330: PUSH
20331: EMPTY
20332: LIST
20333: LIST
20334: PPUSH
20335: CALL_OW 69
20339: PUSH
20340: LD_INT 0
20342: EQUAL
20343: IFFALSE 20318
// tmp := mc_vehicles [ 4 ] ;
20345: LD_ADDR_VAR 0 3
20349: PUSH
20350: LD_EXP 118
20354: PUSH
20355: LD_INT 4
20357: ARRAY
20358: ST_TO_ADDR
// for i = 1 to powellSquadAttack do
20359: LD_ADDR_VAR 0 1
20363: PUSH
20364: DOUBLE
20365: LD_INT 1
20367: DEC
20368: ST_TO_ADDR
20369: LD_EXP 18
20373: PUSH
20374: FOR_TO
20375: IFFALSE 20636
// begin for j in powellSquadAttack [ i ] do
20377: LD_ADDR_VAR 0 2
20381: PUSH
20382: LD_EXP 18
20386: PUSH
20387: LD_VAR 0 1
20391: ARRAY
20392: PUSH
20393: FOR_IN
20394: IFFALSE 20632
// begin forces := forces diff j ;
20396: LD_ADDR_VAR 0 6
20400: PUSH
20401: LD_VAR 0 6
20405: PUSH
20406: LD_VAR 0 2
20410: DIFF
20411: ST_TO_ADDR
// SetTag ( j , 1 ) ;
20412: LD_VAR 0 2
20416: PPUSH
20417: LD_INT 1
20419: PPUSH
20420: CALL_OW 109
// wait ( 0 0$2 ) ;
20424: LD_INT 70
20426: PPUSH
20427: CALL_OW 67
// if IsInUnit ( j ) then
20431: LD_VAR 0 2
20435: PPUSH
20436: CALL_OW 310
20440: IFFALSE 20451
// ComExitBuilding ( j ) ;
20442: LD_VAR 0 2
20446: PPUSH
20447: CALL_OW 122
// if GetClass ( j ) <> 1 then
20451: LD_VAR 0 2
20455: PPUSH
20456: CALL_OW 257
20460: PUSH
20461: LD_INT 1
20463: NONEQUAL
20464: IFFALSE 20544
// begin if UnitsInside ( arm [ 1 ] ) >= 5 then
20466: LD_VAR 0 10
20470: PUSH
20471: LD_INT 1
20473: ARRAY
20474: PPUSH
20475: CALL_OW 313
20479: PUSH
20480: LD_INT 5
20482: GREATEREQUAL
20483: IFFALSE 20505
// AddComEnterUnit ( j , arm [ 2 ] ) else
20485: LD_VAR 0 2
20489: PPUSH
20490: LD_VAR 0 10
20494: PUSH
20495: LD_INT 2
20497: ARRAY
20498: PPUSH
20499: CALL_OW 180
20503: GO 20523
// AddComEnterUnit ( j , arm [ 1 ] ) ;
20505: LD_VAR 0 2
20509: PPUSH
20510: LD_VAR 0 10
20514: PUSH
20515: LD_INT 1
20517: ARRAY
20518: PPUSH
20519: CALL_OW 180
// AddComChangeProfession ( j , 1 ) ;
20523: LD_VAR 0 2
20527: PPUSH
20528: LD_INT 1
20530: PPUSH
20531: CALL_OW 183
// AddComExitBuilding ( j ) ;
20535: LD_VAR 0 2
20539: PPUSH
20540: CALL_OW 182
// end ; if i = 2 then
20544: LD_VAR 0 1
20548: PUSH
20549: LD_INT 2
20551: EQUAL
20552: IFFALSE 20569
// AddComMoveXY ( j , 61 , 93 ) ;
20554: LD_VAR 0 2
20558: PPUSH
20559: LD_INT 61
20561: PPUSH
20562: LD_INT 93
20564: PPUSH
20565: CALL_OW 171
// if i = 1 then
20569: LD_VAR 0 1
20573: PUSH
20574: LD_INT 1
20576: EQUAL
20577: IFFALSE 20630
// begin AddComEnterUnit ( j , tmp [ 1 ] ) ;
20579: LD_VAR 0 2
20583: PPUSH
20584: LD_VAR 0 3
20588: PUSH
20589: LD_INT 1
20591: ARRAY
20592: PPUSH
20593: CALL_OW 180
// tmp := Delete ( tmp , 1 ) ;
20597: LD_ADDR_VAR 0 3
20601: PUSH
20602: LD_VAR 0 3
20606: PPUSH
20607: LD_INT 1
20609: PPUSH
20610: CALL_OW 3
20614: ST_TO_ADDR
// AddComMoveXY ( j , 69 , 94 ) ;
20615: LD_VAR 0 2
20619: PPUSH
20620: LD_INT 69
20622: PPUSH
20623: LD_INT 94
20625: PPUSH
20626: CALL_OW 171
// end ; end ;
20630: GO 20393
20632: POP
20633: POP
// end ;
20634: GO 20374
20636: POP
20637: POP
// wait ( 0 0$55 ) ;
20638: LD_INT 1925
20640: PPUSH
20641: CALL_OW 67
// MC_Kill ( 4 ) ;
20645: LD_INT 4
20647: PPUSH
20648: CALL 34153 0 1
// tmp := UnitsInside ( fac ) ;
20652: LD_ADDR_VAR 0 3
20656: PUSH
20657: LD_VAR 0 9
20661: PPUSH
20662: CALL_OW 313
20666: ST_TO_ADDR
// if tmp then
20667: LD_VAR 0 3
20671: IFFALSE 20792
// for i in tmp do
20673: LD_ADDR_VAR 0 1
20677: PUSH
20678: LD_VAR 0 3
20682: PUSH
20683: FOR_IN
20684: IFFALSE 20790
// begin ComExitBuilding ( i ) ;
20686: LD_VAR 0 1
20690: PPUSH
20691: CALL_OW 122
// if UnitsInside ( arm [ 2 ] ) < 6 then
20695: LD_VAR 0 10
20699: PUSH
20700: LD_INT 2
20702: ARRAY
20703: PPUSH
20704: CALL_OW 313
20708: PUSH
20709: LD_INT 6
20711: LESS
20712: IFFALSE 20734
// AddComEnterUnit ( i , arm [ 2 ] ) else
20714: LD_VAR 0 1
20718: PPUSH
20719: LD_VAR 0 10
20723: PUSH
20724: LD_INT 2
20726: ARRAY
20727: PPUSH
20728: CALL_OW 180
20732: GO 20788
// if UnitsInside ( arm [ 1 ] ) < 6 then
20734: LD_VAR 0 10
20738: PUSH
20739: LD_INT 1
20741: ARRAY
20742: PPUSH
20743: CALL_OW 313
20747: PUSH
20748: LD_INT 6
20750: LESS
20751: IFFALSE 20773
// AddComEnterUnit ( i , arm [ 1 ] ) else
20753: LD_VAR 0 1
20757: PPUSH
20758: LD_VAR 0 10
20762: PUSH
20763: LD_INT 1
20765: ARRAY
20766: PPUSH
20767: CALL_OW 180
20771: GO 20788
// AddComMoveXY ( i , 37 , 68 ) ;
20773: LD_VAR 0 1
20777: PPUSH
20778: LD_INT 37
20780: PPUSH
20781: LD_INT 68
20783: PPUSH
20784: CALL_OW 171
// end ;
20788: GO 20683
20790: POP
20791: POP
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) diff vip ;
20792: LD_ADDR_VAR 0 11
20796: PUSH
20797: LD_VAR 0 6
20801: PPUSH
20802: LD_INT 26
20804: PUSH
20805: LD_INT 1
20807: PUSH
20808: EMPTY
20809: LIST
20810: LIST
20811: PPUSH
20812: CALL_OW 72
20816: PUSH
20817: LD_EXP 56
20821: DIFF
20822: ST_TO_ADDR
// if not speaker then
20823: LD_VAR 0 11
20827: NOT
20828: IFFALSE 20855
// speaker := UnitFilter ( forces , [ f_sex , sex_male ] ) ;
20830: LD_ADDR_VAR 0 11
20834: PUSH
20835: LD_VAR 0 6
20839: PPUSH
20840: LD_INT 26
20842: PUSH
20843: LD_INT 1
20845: PUSH
20846: EMPTY
20847: LIST
20848: LIST
20849: PPUSH
20850: CALL_OW 72
20854: ST_TO_ADDR
// if speaker then
20855: LD_VAR 0 11
20859: IFFALSE 20875
// speaker := speaker [ 1 ] ;
20861: LD_ADDR_VAR 0 11
20865: PUSH
20866: LD_VAR 0 11
20870: PUSH
20871: LD_INT 1
20873: ARRAY
20874: ST_TO_ADDR
// Video ( true ) ;
20875: LD_INT 1
20877: PPUSH
20878: CALL 106804 0 1
// CenterNowOnUnits ( Powell ) ;
20882: LD_EXP 55
20886: PPUSH
20887: CALL_OW 87
// tmp := UnitFilter ( forces , [ f_not , [ f_class , 1 ] ] ) ;
20891: LD_ADDR_VAR 0 3
20895: PUSH
20896: LD_VAR 0 6
20900: PPUSH
20901: LD_INT 3
20903: PUSH
20904: LD_INT 25
20906: PUSH
20907: LD_INT 1
20909: PUSH
20910: EMPTY
20911: LIST
20912: LIST
20913: PUSH
20914: EMPTY
20915: LIST
20916: LIST
20917: PPUSH
20918: CALL_OW 72
20922: ST_TO_ADDR
// emp_towers := FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_bunker ] , [ f_empty ] ] ) ;
20923: LD_ADDR_VAR 0 12
20927: PUSH
20928: LD_INT 22
20930: PUSH
20931: LD_INT 4
20933: PUSH
20934: EMPTY
20935: LIST
20936: LIST
20937: PUSH
20938: LD_INT 30
20940: PUSH
20941: LD_INT 32
20943: PUSH
20944: EMPTY
20945: LIST
20946: LIST
20947: PUSH
20948: LD_INT 58
20950: PUSH
20951: EMPTY
20952: LIST
20953: PUSH
20954: EMPTY
20955: LIST
20956: LIST
20957: LIST
20958: PPUSH
20959: CALL_OW 69
20963: ST_TO_ADDR
// for i = 1 to 6 do
20964: LD_ADDR_VAR 0 1
20968: PUSH
20969: DOUBLE
20970: LD_INT 1
20972: DEC
20973: ST_TO_ADDR
20974: LD_INT 6
20976: PUSH
20977: FOR_TO
20978: IFFALSE 21119
// begin if IsInUnit ( tmp [ i ] ) then
20980: LD_VAR 0 3
20984: PUSH
20985: LD_VAR 0 1
20989: ARRAY
20990: PPUSH
20991: CALL_OW 310
20995: IFFALSE 21012
// ComExitBuilding ( tmp [ i ] ) ;
20997: LD_VAR 0 3
21001: PUSH
21002: LD_VAR 0 1
21006: ARRAY
21007: PPUSH
21008: CALL_OW 122
// AddComEnterUnit ( tmp [ i ] , arm [ 1 ] ) ;
21012: LD_VAR 0 3
21016: PUSH
21017: LD_VAR 0 1
21021: ARRAY
21022: PPUSH
21023: LD_VAR 0 10
21027: PUSH
21028: LD_INT 1
21030: ARRAY
21031: PPUSH
21032: CALL_OW 180
// AddComChangeProfession ( tmp [ i ] , class_soldier ) ;
21036: LD_VAR 0 3
21040: PUSH
21041: LD_VAR 0 1
21045: ARRAY
21046: PPUSH
21047: LD_INT 1
21049: PPUSH
21050: CALL_OW 183
// if emp_towers then
21054: LD_VAR 0 12
21058: IFFALSE 21117
// begin AddComExitBuilding ( tmp [ i ] ) ;
21060: LD_VAR 0 3
21064: PUSH
21065: LD_VAR 0 1
21069: ARRAY
21070: PPUSH
21071: CALL_OW 182
// AddComEnterUnit ( tmp [ i ] , emp_towers [ 1 ] ) ;
21075: LD_VAR 0 3
21079: PUSH
21080: LD_VAR 0 1
21084: ARRAY
21085: PPUSH
21086: LD_VAR 0 12
21090: PUSH
21091: LD_INT 1
21093: ARRAY
21094: PPUSH
21095: CALL_OW 180
// emp_towers := Delete ( emp_towers , 1 ) ;
21099: LD_ADDR_VAR 0 12
21103: PUSH
21104: LD_VAR 0 12
21108: PPUSH
21109: LD_INT 1
21111: PPUSH
21112: CALL_OW 3
21116: ST_TO_ADDR
// end ; end ;
21117: GO 20977
21119: POP
21120: POP
// tmp := UnitFilter ( powellSquadAttack [ 1 ] ^ powellSquadAttack [ 2 ] , [ f_sex , sex_male ] ) ;
21121: LD_ADDR_VAR 0 3
21125: PUSH
21126: LD_EXP 18
21130: PUSH
21131: LD_INT 1
21133: ARRAY
21134: PUSH
21135: LD_EXP 18
21139: PUSH
21140: LD_INT 2
21142: ARRAY
21143: ADD
21144: PPUSH
21145: LD_INT 26
21147: PUSH
21148: LD_INT 1
21150: PUSH
21151: EMPTY
21152: LIST
21153: LIST
21154: PPUSH
21155: CALL_OW 72
21159: ST_TO_ADDR
// for i in powellSquadAttack [ 2 ] do
21160: LD_ADDR_VAR 0 1
21164: PUSH
21165: LD_EXP 18
21169: PUSH
21170: LD_INT 2
21172: ARRAY
21173: PUSH
21174: FOR_IN
21175: IFFALSE 21193
// ComTurnUnit ( i , Powell ) ;
21177: LD_VAR 0 1
21181: PPUSH
21182: LD_EXP 55
21186: PPUSH
21187: CALL_OW 119
21191: GO 21174
21193: POP
21194: POP
// Say ( Powell , D5-Pow-1 ) ;
21195: LD_EXP 55
21199: PPUSH
21200: LD_STRING D5-Pow-1
21202: PPUSH
21203: CALL_OW 88
// if tmp then
21207: LD_VAR 0 3
21211: IFFALSE 21229
// Say ( tmp [ 1 ] , D5-Sol2-1 ) ;
21213: LD_VAR 0 3
21217: PUSH
21218: LD_INT 1
21220: ARRAY
21221: PPUSH
21222: LD_STRING D5-Sol2-1
21224: PPUSH
21225: CALL_OW 88
// Say ( Powell , D5-Pow-2 ) ;
21229: LD_EXP 55
21233: PPUSH
21234: LD_STRING D5-Pow-2
21236: PPUSH
21237: CALL_OW 88
// if tmp > 1 then
21241: LD_VAR 0 3
21245: PUSH
21246: LD_INT 1
21248: GREATER
21249: IFFALSE 21267
// Say ( tmp [ 2 ] , D5-Sol2-2 ) ;
21251: LD_VAR 0 3
21255: PUSH
21256: LD_INT 2
21258: ARRAY
21259: PPUSH
21260: LD_STRING D5-Sol2-2
21262: PPUSH
21263: CALL_OW 88
// Say ( Powell , D5-Pow-3 ) ;
21267: LD_EXP 55
21271: PPUSH
21272: LD_STRING D5-Pow-3
21274: PPUSH
21275: CALL_OW 88
// wait ( 0 0$1 ) ;
21279: LD_INT 35
21281: PPUSH
21282: CALL_OW 67
// tmp := powellSquadAttack [ 1 ] union powellSquadAttack [ 2 ] ;
21286: LD_ADDR_VAR 0 3
21290: PUSH
21291: LD_EXP 18
21295: PUSH
21296: LD_INT 1
21298: ARRAY
21299: PUSH
21300: LD_EXP 18
21304: PUSH
21305: LD_INT 2
21307: ARRAY
21308: UNION
21309: ST_TO_ADDR
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21310: LD_VAR 0 3
21314: PPUSH
21315: LD_INT 80
21317: PPUSH
21318: LD_INT 67
21320: PPUSH
21321: CALL_OW 114
// wait ( 0 0$2 ) ;
21325: LD_INT 70
21327: PPUSH
21328: CALL_OW 67
// CenterOnXY ( 79 , 72 ) ;
21332: LD_INT 79
21334: PPUSH
21335: LD_INT 72
21337: PPUSH
21338: CALL_OW 84
// repeat wait ( 0 0$1 ) ;
21342: LD_INT 35
21344: PPUSH
21345: CALL_OW 67
// until UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) ;
21349: LD_VAR 0 3
21353: PPUSH
21354: LD_INT 3
21356: PUSH
21357: LD_INT 24
21359: PUSH
21360: LD_INT 1000
21362: PUSH
21363: EMPTY
21364: LIST
21365: LIST
21366: PUSH
21367: EMPTY
21368: LIST
21369: LIST
21370: PPUSH
21371: CALL_OW 72
21375: IFFALSE 21342
// Say ( Powell , D5a-Pow-1 ) ;
21377: LD_EXP 55
21381: PPUSH
21382: LD_STRING D5a-Pow-1
21384: PPUSH
21385: CALL_OW 88
// Say ( Powell , D5a-Pow-1a ) ;
21389: LD_EXP 55
21393: PPUSH
21394: LD_STRING D5a-Pow-1a
21396: PPUSH
21397: CALL_OW 88
// wait ( 0 0$0.3 ) ;
21401: LD_INT 10
21403: PPUSH
21404: CALL_OW 67
// Say ( Powell , D5a-Pow-1b ) ;
21408: LD_EXP 55
21412: PPUSH
21413: LD_STRING D5a-Pow-1b
21415: PPUSH
21416: CALL_OW 88
// Say ( Powell , D5a-Pow-1c ) ;
21420: LD_EXP 55
21424: PPUSH
21425: LD_STRING D5a-Pow-1c
21427: PPUSH
21428: CALL_OW 88
// Say ( Powell , D5a-Pow-1d ) ;
21432: LD_EXP 55
21436: PPUSH
21437: LD_STRING D5a-Pow-1d
21439: PPUSH
21440: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
21444: LD_INT 35
21446: PPUSH
21447: CALL_OW 67
// if not HasTask ( tmp ) then
21451: LD_VAR 0 3
21455: PPUSH
21456: CALL_OW 314
21460: NOT
21461: IFFALSE 21478
// ComAgressiveMove ( tmp , 80 , 67 ) ;
21463: LD_VAR 0 3
21467: PPUSH
21468: LD_INT 80
21470: PPUSH
21471: LD_INT 67
21473: PPUSH
21474: CALL_OW 114
// until not UnitFilter ( tmp , [ f_lives , 1 ] ) ;
21478: LD_VAR 0 3
21482: PPUSH
21483: LD_INT 24
21485: PUSH
21486: LD_INT 1
21488: PUSH
21489: EMPTY
21490: LIST
21491: LIST
21492: PPUSH
21493: CALL_OW 72
21497: NOT
21498: IFFALSE 21444
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 60 , 93 , 10 ] , [ f_not , [ f_inside ] ] ] ) diff Powell ;
21500: LD_ADDR_VAR 0 3
21504: PUSH
21505: LD_INT 22
21507: PUSH
21508: LD_INT 4
21510: PUSH
21511: EMPTY
21512: LIST
21513: LIST
21514: PUSH
21515: LD_INT 92
21517: PUSH
21518: LD_INT 60
21520: PUSH
21521: LD_INT 93
21523: PUSH
21524: LD_INT 10
21526: PUSH
21527: EMPTY
21528: LIST
21529: LIST
21530: LIST
21531: LIST
21532: PUSH
21533: LD_INT 3
21535: PUSH
21536: LD_INT 54
21538: PUSH
21539: EMPTY
21540: LIST
21541: PUSH
21542: EMPTY
21543: LIST
21544: LIST
21545: PUSH
21546: EMPTY
21547: LIST
21548: LIST
21549: LIST
21550: PPUSH
21551: CALL_OW 69
21555: PUSH
21556: LD_EXP 55
21560: DIFF
21561: ST_TO_ADDR
// if tmp then
21562: LD_VAR 0 3
21566: IFFALSE 21600
// for i in tmp do
21568: LD_ADDR_VAR 0 1
21572: PUSH
21573: LD_VAR 0 3
21577: PUSH
21578: FOR_IN
21579: IFFALSE 21598
// ComMoveXY ( i , 36 , 67 ) ;
21581: LD_VAR 0 1
21585: PPUSH
21586: LD_INT 36
21588: PPUSH
21589: LD_INT 67
21591: PPUSH
21592: CALL_OW 111
21596: GO 21578
21598: POP
21599: POP
// wait ( 0 0$3 ) ;
21600: LD_INT 105
21602: PPUSH
21603: CALL_OW 67
// Say ( speaker , D6-Sol3-1 ) ;
21607: LD_VAR 0 11
21611: PPUSH
21612: LD_STRING D6-Sol3-1
21614: PPUSH
21615: CALL_OW 88
// CenterNowOnUnits ( Powell ) ;
21619: LD_EXP 55
21623: PPUSH
21624: CALL_OW 87
// Say ( Powell , D6-Pow-1 ) ;
21628: LD_EXP 55
21632: PPUSH
21633: LD_STRING D6-Pow-1
21635: PPUSH
21636: CALL_OW 88
// tmp := [ ] ;
21640: LD_ADDR_VAR 0 3
21644: PUSH
21645: EMPTY
21646: ST_TO_ADDR
// for i = 1 to 2 do
21647: LD_ADDR_VAR 0 1
21651: PUSH
21652: DOUBLE
21653: LD_INT 1
21655: DEC
21656: ST_TO_ADDR
21657: LD_INT 2
21659: PUSH
21660: FOR_TO
21661: IFFALSE 21775
// begin uc_side := 8 ;
21663: LD_ADDR_OWVAR 20
21667: PUSH
21668: LD_INT 8
21670: ST_TO_ADDR
// uc_nation := 2 ;
21671: LD_ADDR_OWVAR 21
21675: PUSH
21676: LD_INT 2
21678: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_remote , ar_selfpropelled_bomb , 100 ) ;
21679: LD_INT 14
21681: PPUSH
21682: LD_INT 3
21684: PPUSH
21685: LD_INT 2
21687: PPUSH
21688: LD_INT 29
21690: PPUSH
21691: LD_INT 100
21693: PPUSH
21694: CALL 71087 0 5
// veh := CreateVehicle ;
21698: LD_ADDR_VAR 0 13
21702: PUSH
21703: CALL_OW 45
21707: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
21708: LD_VAR 0 13
21712: PPUSH
21713: LD_INT 4
21715: PPUSH
21716: CALL_OW 233
// PlaceUnitXYR ( veh , 99 , 83 , 6 , false ) ;
21720: LD_VAR 0 13
21724: PPUSH
21725: LD_INT 99
21727: PPUSH
21728: LD_INT 83
21730: PPUSH
21731: LD_INT 6
21733: PPUSH
21734: LD_INT 0
21736: PPUSH
21737: CALL_OW 50
// wait ( 3 ) ;
21741: LD_INT 3
21743: PPUSH
21744: CALL_OW 67
// Connect ( veh ) ;
21748: LD_VAR 0 13
21752: PPUSH
21753: CALL 74142 0 1
// tmp := tmp ^ veh ;
21757: LD_ADDR_VAR 0 3
21761: PUSH
21762: LD_VAR 0 3
21766: PUSH
21767: LD_VAR 0 13
21771: ADD
21772: ST_TO_ADDR
// end ;
21773: GO 21660
21775: POP
21776: POP
// wait ( 0 0$1 ) ;
21777: LD_INT 35
21779: PPUSH
21780: CALL_OW 67
// PlaceSeeing ( 99 , 83 , 1 , 10 ) ;
21784: LD_INT 99
21786: PPUSH
21787: LD_INT 83
21789: PPUSH
21790: LD_INT 1
21792: PPUSH
21793: LD_INT 10
21795: PPUSH
21796: CALL_OW 330
// CenterNowOnXY ( 99 , 83 ) ;
21800: LD_INT 99
21802: PPUSH
21803: LD_INT 83
21805: PPUSH
21806: CALL_OW 86
// Say ( speaker , D6-Sol3-2 ) ;
21810: LD_VAR 0 11
21814: PPUSH
21815: LD_STRING D6-Sol3-2
21817: PPUSH
21818: CALL_OW 88
// async ;
21822: ASYNC
// Say ( Powell , D6-Pow-2 ) ;
21823: LD_EXP 55
21827: PPUSH
21828: LD_STRING D6-Pow-2
21830: PPUSH
21831: CALL_OW 88
// ComAttackUnit ( tmp [ 1 ] , fac ) ;
21835: LD_VAR 0 3
21839: PUSH
21840: LD_INT 1
21842: ARRAY
21843: PPUSH
21844: LD_VAR 0 9
21848: PPUSH
21849: CALL_OW 115
// ComAttackUnit ( tmp [ 2 ] , NearestUnitToUnit ( FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_building ] ] ) , tmp [ 2 ] ) ) ;
21853: LD_VAR 0 3
21857: PUSH
21858: LD_INT 2
21860: ARRAY
21861: PPUSH
21862: LD_INT 22
21864: PUSH
21865: LD_INT 4
21867: PUSH
21868: EMPTY
21869: LIST
21870: LIST
21871: PUSH
21872: LD_INT 21
21874: PUSH
21875: LD_INT 3
21877: PUSH
21878: EMPTY
21879: LIST
21880: LIST
21881: PUSH
21882: EMPTY
21883: LIST
21884: LIST
21885: PPUSH
21886: CALL_OW 69
21890: PPUSH
21891: LD_VAR 0 3
21895: PUSH
21896: LD_INT 2
21898: ARRAY
21899: PPUSH
21900: CALL_OW 74
21904: PPUSH
21905: CALL_OW 115
// CenterNowOnUnits ( Powell ) ;
21909: LD_EXP 55
21913: PPUSH
21914: CALL_OW 87
// RemoveSeeing ( 99 , 83 , 1 ) ;
21918: LD_INT 99
21920: PPUSH
21921: LD_INT 83
21923: PPUSH
21924: LD_INT 1
21926: PPUSH
21927: CALL_OW 331
// repeat wait ( 4 ) ;
21931: LD_INT 4
21933: PPUSH
21934: CALL_OW 67
// if GetLives ( tmp [ 1 ] ) < 1000 then
21938: LD_VAR 0 3
21942: PUSH
21943: LD_INT 1
21945: ARRAY
21946: PPUSH
21947: CALL_OW 256
21951: PUSH
21952: LD_INT 1000
21954: LESS
21955: IFFALSE 21973
// SetLives ( tmp [ 1 ] , 1000 ) ;
21957: LD_VAR 0 3
21961: PUSH
21962: LD_INT 1
21964: ARRAY
21965: PPUSH
21966: LD_INT 1000
21968: PPUSH
21969: CALL_OW 234
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_btype , b_factory ] ] ) = 0 ;
21973: LD_INT 22
21975: PUSH
21976: LD_INT 4
21978: PUSH
21979: EMPTY
21980: LIST
21981: LIST
21982: PUSH
21983: LD_INT 30
21985: PUSH
21986: LD_INT 3
21988: PUSH
21989: EMPTY
21990: LIST
21991: LIST
21992: PUSH
21993: EMPTY
21994: LIST
21995: LIST
21996: PPUSH
21997: CALL_OW 69
22001: PUSH
22002: LD_INT 0
22004: EQUAL
22005: IFFALSE 21931
// sync ;
22007: SYNC
// Say ( Powell , D6a-Pow-1 ) ;
22008: LD_EXP 55
22012: PPUSH
22013: LD_STRING D6a-Pow-1
22015: PPUSH
22016: CALL_OW 88
// Say ( Speaker , D6a-Sol3-1 ) ;
22020: LD_VAR 0 11
22024: PPUSH
22025: LD_STRING D6a-Sol3-1
22027: PPUSH
22028: CALL_OW 88
// Say ( Powell , D6a-Pow-2 ) ;
22032: LD_EXP 55
22036: PPUSH
22037: LD_STRING D6a-Pow-2
22039: PPUSH
22040: CALL_OW 88
// Say ( Speaker , D6a-Sol3-2 ) ;
22044: LD_VAR 0 11
22048: PPUSH
22049: LD_STRING D6a-Sol3-2
22051: PPUSH
22052: CALL_OW 88
// Say ( Powell , D6a-Pow-3 ) ;
22056: LD_EXP 55
22060: PPUSH
22061: LD_STRING D6a-Pow-3
22063: PPUSH
22064: CALL_OW 88
// powellCenterCameraMode := true ;
22068: LD_ADDR_EXP 20
22072: PUSH
22073: LD_INT 1
22075: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
22076: LD_ADDR_VAR 0 1
22080: PUSH
22081: LD_INT 22
22083: PUSH
22084: LD_INT 8
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: PUSH
22091: LD_INT 25
22093: PUSH
22094: LD_INT 2
22096: PUSH
22097: EMPTY
22098: LIST
22099: LIST
22100: PUSH
22101: EMPTY
22102: LIST
22103: LIST
22104: PPUSH
22105: CALL_OW 69
22109: PUSH
22110: FOR_IN
22111: IFFALSE 22166
// begin SetTag ( i , 1 ) ;
22113: LD_VAR 0 1
22117: PPUSH
22118: LD_INT 1
22120: PPUSH
22121: CALL_OW 109
// ComExitBuilding ( i ) ;
22125: LD_VAR 0 1
22129: PPUSH
22130: CALL_OW 122
// AddComMoveXY ( i , 35 , 6 ) ;
22134: LD_VAR 0 1
22138: PPUSH
22139: LD_INT 35
22141: PPUSH
22142: LD_INT 6
22144: PPUSH
22145: CALL_OW 171
// AddComMoveXY ( i , 53 , 4 ) ;
22149: LD_VAR 0 1
22153: PPUSH
22154: LD_INT 53
22156: PPUSH
22157: LD_INT 4
22159: PPUSH
22160: CALL_OW 171
// end ;
22164: GO 22110
22166: POP
22167: POP
// tmp := FilterAllUnits ( [ [ f_side , 4 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_weapon , us_cargo_bay ] ] ] ) ;
22168: LD_ADDR_VAR 0 3
22172: PUSH
22173: LD_INT 22
22175: PUSH
22176: LD_INT 4
22178: PUSH
22179: EMPTY
22180: LIST
22181: LIST
22182: PUSH
22183: LD_INT 21
22185: PUSH
22186: LD_INT 2
22188: PUSH
22189: EMPTY
22190: LIST
22191: LIST
22192: PUSH
22193: LD_INT 3
22195: PUSH
22196: LD_INT 34
22198: PUSH
22199: LD_INT 12
22201: PUSH
22202: EMPTY
22203: LIST
22204: LIST
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: PUSH
22210: EMPTY
22211: LIST
22212: LIST
22213: LIST
22214: PPUSH
22215: CALL_OW 69
22219: ST_TO_ADDR
// ComEnterUnit ( Powell , NearestUnitToUnit ( tmp , Powell ) ) ;
22220: LD_EXP 55
22224: PPUSH
22225: LD_VAR 0 3
22229: PPUSH
22230: LD_EXP 55
22234: PPUSH
22235: CALL_OW 74
22239: PPUSH
22240: CALL_OW 120
// AddComMoveXY ( Powell , 100 , 88 ) ;
22244: LD_EXP 55
22248: PPUSH
22249: LD_INT 100
22251: PPUSH
22252: LD_INT 88
22254: PPUSH
22255: CALL_OW 171
// AddComMoveXY ( Powell , 100 , 75 ) ;
22259: LD_EXP 55
22263: PPUSH
22264: LD_INT 100
22266: PPUSH
22267: LD_INT 75
22269: PPUSH
22270: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 53 ) ;
22274: LD_EXP 55
22278: PPUSH
22279: LD_INT 88
22281: PPUSH
22282: LD_INT 53
22284: PPUSH
22285: CALL_OW 171
// DoNotAttack ( 8 , Powell ) ;
22289: LD_INT 8
22291: PPUSH
22292: LD_EXP 55
22296: PPUSH
22297: CALL_OW 471
// repeat wait ( 3 ) ;
22301: LD_INT 3
22303: PPUSH
22304: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 4 ] , [ f_distxy , 100 , 75 , 6 ] ] ) ;
22308: LD_INT 22
22310: PUSH
22311: LD_INT 4
22313: PUSH
22314: EMPTY
22315: LIST
22316: LIST
22317: PUSH
22318: LD_INT 92
22320: PUSH
22321: LD_INT 100
22323: PUSH
22324: LD_INT 75
22326: PUSH
22327: LD_INT 6
22329: PUSH
22330: EMPTY
22331: LIST
22332: LIST
22333: LIST
22334: LIST
22335: PUSH
22336: EMPTY
22337: LIST
22338: LIST
22339: PPUSH
22340: CALL_OW 69
22344: IFFALSE 22301
// async ;
22346: ASYNC
// Say ( Powell , D6b-Pow-1 ) ;
22347: LD_EXP 55
22351: PPUSH
22352: LD_STRING D6b-Pow-1
22354: PPUSH
22355: CALL_OW 88
// repeat wait ( 3 ) ;
22359: LD_INT 3
22361: PPUSH
22362: CALL_OW 67
// if GetLives ( IsInUnit ( Powell ) ) < 1000 then
22366: LD_EXP 55
22370: PPUSH
22371: CALL_OW 310
22375: PPUSH
22376: CALL_OW 256
22380: PUSH
22381: LD_INT 1000
22383: LESS
22384: IFFALSE 22403
// SetLives ( IsInUnit ( Powell ) , 1000 ) ;
22386: LD_EXP 55
22390: PPUSH
22391: CALL_OW 310
22395: PPUSH
22396: LD_INT 1000
22398: PPUSH
22399: CALL_OW 234
// if GetLives ( Powell ) < 1000 then
22403: LD_EXP 55
22407: PPUSH
22408: CALL_OW 256
22412: PUSH
22413: LD_INT 1000
22415: LESS
22416: IFFALSE 22430
// SetLives ( Powell , 1000 ) ;
22418: LD_EXP 55
22422: PPUSH
22423: LD_INT 1000
22425: PPUSH
22426: CALL_OW 234
// if GetDistUnits ( Powell , powellBomb ) < 5 or GetDistUnits ( IsInUnit ( Powell ) , powellBomb ) < 5 then
22430: LD_EXP 55
22434: PPUSH
22435: LD_EXP 60
22439: PPUSH
22440: CALL_OW 296
22444: PUSH
22445: LD_INT 5
22447: LESS
22448: PUSH
22449: LD_EXP 55
22453: PPUSH
22454: CALL_OW 310
22458: PPUSH
22459: LD_EXP 60
22463: PPUSH
22464: CALL_OW 296
22468: PUSH
22469: LD_INT 5
22471: LESS
22472: OR
22473: IFFALSE 22492
// SetLives ( IsInUnit ( Powell ) , 100 ) ;
22475: LD_EXP 55
22479: PPUSH
22480: CALL_OW 310
22484: PPUSH
22485: LD_INT 100
22487: PPUSH
22488: CALL_OW 234
// until not IsInUnit ( Powell ) ;
22492: LD_EXP 55
22496: PPUSH
22497: CALL_OW 310
22501: NOT
22502: IFFALSE 22359
// game_speed := 4 ;
22504: LD_ADDR_OWVAR 65
22508: PUSH
22509: LD_INT 4
22511: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1a ) ;
22512: LD_EXP 55
22516: PPUSH
22517: LD_STRING D6b-Pow-1a
22519: PPUSH
22520: CALL_OW 88
// AddComEnterUnit ( Powell , powellBomb ) ;
22524: LD_EXP 55
22528: PPUSH
22529: LD_EXP 60
22533: PPUSH
22534: CALL_OW 180
// sync ;
22538: SYNC
// repeat wait ( 0 0$1 ) ;
22539: LD_INT 35
22541: PPUSH
22542: CALL_OW 67
// until IsInUnit ( Powell ) ;
22546: LD_EXP 55
22550: PPUSH
22551: CALL_OW 310
22555: IFFALSE 22539
// DoNotAttack ( 8 , IsInUnit ( Powell ) ) ;
22557: LD_INT 8
22559: PPUSH
22560: LD_EXP 55
22564: PPUSH
22565: CALL_OW 310
22569: PPUSH
22570: CALL_OW 471
// AddComMoveXY ( Powell , 91 , 44 ) ;
22574: LD_EXP 55
22578: PPUSH
22579: LD_INT 91
22581: PPUSH
22582: LD_INT 44
22584: PPUSH
22585: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22589: LD_EXP 55
22593: PPUSH
22594: LD_INT 96
22596: PPUSH
22597: LD_INT 44
22599: PPUSH
22600: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22604: LD_EXP 55
22608: PPUSH
22609: LD_INT 96
22611: PPUSH
22612: LD_INT 41
22614: PPUSH
22615: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22619: LD_EXP 55
22623: PPUSH
22624: LD_INT 92
22626: PPUSH
22627: LD_INT 39
22629: PPUSH
22630: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22634: LD_EXP 55
22638: PPUSH
22639: LD_INT 88
22641: PPUSH
22642: LD_INT 41
22644: PPUSH
22645: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22649: LD_EXP 55
22653: PPUSH
22654: LD_INT 91
22656: PPUSH
22657: LD_INT 44
22659: PPUSH
22660: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 44 ) ;
22664: LD_EXP 55
22668: PPUSH
22669: LD_INT 96
22671: PPUSH
22672: LD_INT 44
22674: PPUSH
22675: CALL_OW 171
// AddComMoveXY ( Powell , 96 , 41 ) ;
22679: LD_EXP 55
22683: PPUSH
22684: LD_INT 96
22686: PPUSH
22687: LD_INT 41
22689: PPUSH
22690: CALL_OW 171
// AddComMoveXY ( Powell , 92 , 39 ) ;
22694: LD_EXP 55
22698: PPUSH
22699: LD_INT 92
22701: PPUSH
22702: LD_INT 39
22704: PPUSH
22705: CALL_OW 171
// AddComMoveXY ( Powell , 88 , 41 ) ;
22709: LD_EXP 55
22713: PPUSH
22714: LD_INT 88
22716: PPUSH
22717: LD_INT 41
22719: PPUSH
22720: CALL_OW 171
// AddComMoveXY ( Powell , 91 , 44 ) ;
22724: LD_EXP 55
22728: PPUSH
22729: LD_INT 91
22731: PPUSH
22732: LD_INT 44
22734: PPUSH
22735: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 39 ) ;
22739: LD_EXP 55
22743: PPUSH
22744: LD_INT 93
22746: PPUSH
22747: LD_INT 39
22749: PPUSH
22750: CALL_OW 171
// AddComMoveXY ( Powell , 93 , 36 ) ;
22754: LD_EXP 55
22758: PPUSH
22759: LD_INT 93
22761: PPUSH
22762: LD_INT 36
22764: PPUSH
22765: CALL_OW 171
// wait ( 0 0$3.5 ) ;
22769: LD_INT 122
22771: PPUSH
22772: CALL_OW 67
// game_speed := 4 ;
22776: LD_ADDR_OWVAR 65
22780: PUSH
22781: LD_INT 4
22783: ST_TO_ADDR
// Say ( Powell , D6b-Pow-1b ) ;
22784: LD_EXP 55
22788: PPUSH
22789: LD_STRING D6b-Pow-1b
22791: PPUSH
22792: CALL_OW 88
// tmp := [ ] ;
22796: LD_ADDR_VAR 0 3
22800: PUSH
22801: EMPTY
22802: ST_TO_ADDR
// xy := [ [ 78 , 47 ] , [ 106 , 53 ] ] ;
22803: LD_ADDR_VAR 0 5
22807: PUSH
22808: LD_INT 78
22810: PUSH
22811: LD_INT 47
22813: PUSH
22814: EMPTY
22815: LIST
22816: LIST
22817: PUSH
22818: LD_INT 106
22820: PUSH
22821: LD_INT 53
22823: PUSH
22824: EMPTY
22825: LIST
22826: LIST
22827: PUSH
22828: EMPTY
22829: LIST
22830: LIST
22831: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_distxy , 90 , 52 , 12 ] ] ) do
22832: LD_ADDR_VAR 0 1
22836: PUSH
22837: LD_INT 22
22839: PUSH
22840: LD_INT 8
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PUSH
22847: LD_INT 21
22849: PUSH
22850: LD_INT 3
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 92
22859: PUSH
22860: LD_INT 90
22862: PUSH
22863: LD_INT 52
22865: PUSH
22866: LD_INT 12
22868: PUSH
22869: EMPTY
22870: LIST
22871: LIST
22872: LIST
22873: LIST
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: LIST
22879: PPUSH
22880: CALL_OW 69
22884: PUSH
22885: FOR_IN
22886: IFFALSE 22911
// tmp := tmp ^ UnitsInside ( i ) ;
22888: LD_ADDR_VAR 0 3
22892: PUSH
22893: LD_VAR 0 3
22897: PUSH
22898: LD_VAR 0 1
22902: PPUSH
22903: CALL_OW 313
22907: ADD
22908: ST_TO_ADDR
22909: GO 22885
22911: POP
22912: POP
// for i in tmp do
22913: LD_ADDR_VAR 0 1
22917: PUSH
22918: LD_VAR 0 3
22922: PUSH
22923: FOR_IN
22924: IFFALSE 23086
// begin dist := 9999 ;
22926: LD_ADDR_VAR 0 8
22930: PUSH
22931: LD_INT 9999
22933: ST_TO_ADDR
// _xy := [ ] ;
22934: LD_ADDR_VAR 0 7
22938: PUSH
22939: EMPTY
22940: ST_TO_ADDR
// SetTag ( i , 1 ) ;
22941: LD_VAR 0 1
22945: PPUSH
22946: LD_INT 1
22948: PPUSH
22949: CALL_OW 109
// ComExitBuilding ( i ) ;
22953: LD_VAR 0 1
22957: PPUSH
22958: CALL_OW 122
// for j in xy do
22962: LD_ADDR_VAR 0 2
22966: PUSH
22967: LD_VAR 0 5
22971: PUSH
22972: FOR_IN
22973: IFFALSE 23055
// if GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) < dist then
22975: LD_VAR 0 1
22979: PPUSH
22980: LD_VAR 0 2
22984: PUSH
22985: LD_INT 1
22987: ARRAY
22988: PPUSH
22989: LD_VAR 0 2
22993: PUSH
22994: LD_INT 2
22996: ARRAY
22997: PPUSH
22998: CALL_OW 297
23002: PUSH
23003: LD_VAR 0 8
23007: LESS
23008: IFFALSE 23053
// begin dist := GetDistUnitXY ( i , j [ 1 ] , j [ 2 ] ) ;
23010: LD_ADDR_VAR 0 8
23014: PUSH
23015: LD_VAR 0 1
23019: PPUSH
23020: LD_VAR 0 2
23024: PUSH
23025: LD_INT 1
23027: ARRAY
23028: PPUSH
23029: LD_VAR 0 2
23033: PUSH
23034: LD_INT 2
23036: ARRAY
23037: PPUSH
23038: CALL_OW 297
23042: ST_TO_ADDR
// _xy := j ;
23043: LD_ADDR_VAR 0 7
23047: PUSH
23048: LD_VAR 0 2
23052: ST_TO_ADDR
// end ;
23053: GO 22972
23055: POP
23056: POP
// AddComMoveXY ( i , _xy [ 1 ] , _xy [ 2 ] ) ;
23057: LD_VAR 0 1
23061: PPUSH
23062: LD_VAR 0 7
23066: PUSH
23067: LD_INT 1
23069: ARRAY
23070: PPUSH
23071: LD_VAR 0 7
23075: PUSH
23076: LD_INT 2
23078: ARRAY
23079: PPUSH
23080: CALL_OW 171
// end ;
23084: GO 22923
23086: POP
23087: POP
// tmp2 := UnitFilter ( tmp , [ [ f_sex , sex_male ] , [ f_class , 1 ] ] ) ;
23088: LD_ADDR_VAR 0 4
23092: PUSH
23093: LD_VAR 0 3
23097: PPUSH
23098: LD_INT 26
23100: PUSH
23101: LD_INT 1
23103: PUSH
23104: EMPTY
23105: LIST
23106: LIST
23107: PUSH
23108: LD_INT 25
23110: PUSH
23111: LD_INT 1
23113: PUSH
23114: EMPTY
23115: LIST
23116: LIST
23117: PUSH
23118: EMPTY
23119: LIST
23120: LIST
23121: PPUSH
23122: CALL_OW 72
23126: ST_TO_ADDR
// if tmp2 < 2 then
23127: LD_VAR 0 4
23131: PUSH
23132: LD_INT 2
23134: LESS
23135: IFFALSE 23204
// tmp2 := FilterAllUnits ( [ [ f_side , 8 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_soldier ] ] ] ) diff [ Kurt , Kozlov ] ;
23137: LD_ADDR_VAR 0 4
23141: PUSH
23142: LD_INT 22
23144: PUSH
23145: LD_INT 8
23147: PUSH
23148: EMPTY
23149: LIST
23150: LIST
23151: PUSH
23152: LD_INT 26
23154: PUSH
23155: LD_INT 1
23157: PUSH
23158: EMPTY
23159: LIST
23160: LIST
23161: PUSH
23162: LD_INT 3
23164: PUSH
23165: LD_INT 25
23167: PUSH
23168: LD_INT 15
23170: PUSH
23171: EMPTY
23172: LIST
23173: LIST
23174: PUSH
23175: EMPTY
23176: LIST
23177: LIST
23178: PUSH
23179: EMPTY
23180: LIST
23181: LIST
23182: LIST
23183: PPUSH
23184: CALL_OW 69
23188: PUSH
23189: LD_EXP 57
23193: PUSH
23194: LD_EXP 58
23198: PUSH
23199: EMPTY
23200: LIST
23201: LIST
23202: DIFF
23203: ST_TO_ADDR
// if tmp2 then
23204: LD_VAR 0 4
23208: IFFALSE 23226
// Say ( tmp2 [ 1 ] , D6b-ArSol1-1 ) ;
23210: LD_VAR 0 4
23214: PUSH
23215: LD_INT 1
23217: ARRAY
23218: PPUSH
23219: LD_STRING D6b-ArSol1-1
23221: PPUSH
23222: CALL_OW 88
// async ;
23226: ASYNC
// Say ( Powell , D6b-Pow-2 ) ;
23227: LD_EXP 55
23231: PPUSH
23232: LD_STRING D6b-Pow-2
23234: PPUSH
23235: CALL_OW 88
// wait ( 0 0$1 ) ;
23239: LD_INT 35
23241: PPUSH
23242: CALL_OW 67
// if tmp2 > 1 then
23246: LD_VAR 0 4
23250: PUSH
23251: LD_INT 1
23253: GREATER
23254: IFFALSE 23272
// Say ( tmp2 [ 2 ] , D6b-ArSol2-1 ) ;
23256: LD_VAR 0 4
23260: PUSH
23261: LD_INT 2
23263: ARRAY
23264: PPUSH
23265: LD_STRING D6b-ArSol2-1
23267: PPUSH
23268: CALL_OW 88
// sync ;
23272: SYNC
// repeat wait ( 5 ) ;
23273: LD_INT 5
23275: PPUSH
23276: CALL_OW 67
// until GetSide ( HexInfo ( 93 , 36 ) ) = 4 ;
23280: LD_INT 93
23282: PPUSH
23283: LD_INT 36
23285: PPUSH
23286: CALL_OW 428
23290: PPUSH
23291: CALL_OW 255
23295: PUSH
23296: LD_INT 4
23298: EQUAL
23299: IFFALSE 23273
// DialogueOn ;
23301: CALL_OW 6
// dwait ( 0 0$0.3 ) ;
23305: LD_INT 10
23307: PPUSH
23308: CALL_OW 68
// Say ( Powell , D6b-Pow-2a ) ;
23312: LD_EXP 55
23316: PPUSH
23317: LD_STRING D6b-Pow-2a
23319: PPUSH
23320: CALL_OW 88
// DialogueOff ;
23324: CALL_OW 7
// ComAttackUnit ( IsInUnit ( Powell ) , kozlov_fac ) ;
23328: LD_EXP 55
23332: PPUSH
23333: CALL_OW 310
23337: PPUSH
23338: LD_INT 332
23340: PPUSH
23341: CALL_OW 115
// PlaceSeeing ( 93 , 35 , 1 , - 6 ) ;
23345: LD_INT 93
23347: PPUSH
23348: LD_INT 35
23350: PPUSH
23351: LD_INT 1
23353: PPUSH
23354: LD_INT 6
23356: NEG
23357: PPUSH
23358: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
23362: LD_INT 35
23364: PPUSH
23365: CALL_OW 67
// if GetLives ( kozlov_fac ) < 1000 and IsLive ( kozlov_fac ) then
23369: LD_INT 332
23371: PPUSH
23372: CALL_OW 256
23376: PUSH
23377: LD_INT 1000
23379: LESS
23380: PUSH
23381: LD_INT 332
23383: PPUSH
23384: CALL_OW 300
23388: AND
23389: IFFALSE 23401
// SetLives ( kozlov_fac , 0 ) ;
23391: LD_INT 332
23393: PPUSH
23394: LD_INT 0
23396: PPUSH
23397: CALL_OW 234
// until IsDead ( kozlov_fac ) or IsDead ( Powell ) ;
23401: LD_INT 332
23403: PPUSH
23404: CALL_OW 301
23408: PUSH
23409: LD_EXP 55
23413: PPUSH
23414: CALL_OW 301
23418: OR
23419: IFFALSE 23362
// game_speed := 4 ;
23421: LD_ADDR_OWVAR 65
23425: PUSH
23426: LD_INT 4
23428: ST_TO_ADDR
// powellCenterCameraMode := false ;
23429: LD_ADDR_EXP 20
23433: PUSH
23434: LD_INT 0
23436: ST_TO_ADDR
// for i in tmp union FilterAllUnits ( [ [ f_side , 8 ] , [ f_class , 2 ] ] ) do
23437: LD_ADDR_VAR 0 1
23441: PUSH
23442: LD_VAR 0 3
23446: PUSH
23447: LD_INT 22
23449: PUSH
23450: LD_INT 8
23452: PUSH
23453: EMPTY
23454: LIST
23455: LIST
23456: PUSH
23457: LD_INT 25
23459: PUSH
23460: LD_INT 2
23462: PUSH
23463: EMPTY
23464: LIST
23465: LIST
23466: PUSH
23467: EMPTY
23468: LIST
23469: LIST
23470: PPUSH
23471: CALL_OW 69
23475: UNION
23476: PUSH
23477: FOR_IN
23478: IFFALSE 23494
// SetTag ( i , 0 ) ;
23480: LD_VAR 0 1
23484: PPUSH
23485: LD_INT 0
23487: PPUSH
23488: CALL_OW 109
23492: GO 23477
23494: POP
23495: POP
// wait ( 0 0$3 ) ;
23496: LD_INT 105
23498: PPUSH
23499: CALL_OW 67
// RemoveSeeing ( 93 , 35 , 1 ) ;
23503: LD_INT 93
23505: PPUSH
23506: LD_INT 35
23508: PPUSH
23509: LD_INT 1
23511: PPUSH
23512: CALL_OW 331
// DialogueOn ;
23516: CALL_OW 6
// Say ( speaker , D6c-Sol3-1 ) ;
23520: LD_VAR 0 11
23524: PPUSH
23525: LD_STRING D6c-Sol3-1
23527: PPUSH
23528: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
23532: LD_INT 10
23534: PPUSH
23535: CALL_OW 68
// CenterNowOnUnits ( JMM ) ;
23539: LD_EXP 36
23543: PPUSH
23544: CALL_OW 87
// Say ( JMM , D6c-JMM-1 ) ;
23548: LD_EXP 36
23552: PPUSH
23553: LD_STRING D6c-JMM-1
23555: PPUSH
23556: CALL_OW 88
// if Cyrus then
23560: LD_EXP 42
23564: IFFALSE 23578
// Say ( Cyrus , D6c-Cyrus-1 ) ;
23566: LD_EXP 42
23570: PPUSH
23571: LD_STRING D6c-Cyrus-1
23573: PPUSH
23574: CALL_OW 88
// if Bobby then
23578: LD_EXP 41
23582: IFFALSE 23596
// Say ( Bobby , D6c-Bobby-1 ) ;
23584: LD_EXP 41
23588: PPUSH
23589: LD_STRING D6c-Bobby-1
23591: PPUSH
23592: CALL_OW 88
// if Cornel then
23596: LD_EXP 47
23600: IFFALSE 23614
// Say ( Cornel , D6c-Corn-1 ) ;
23602: LD_EXP 47
23606: PPUSH
23607: LD_STRING D6c-Corn-1
23609: PPUSH
23610: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_or , [ f_side , 1 ] , [ f_side , 4 ] ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) diff [ speaker union JMM union vip ] ;
23614: LD_ADDR_VAR 0 4
23618: PUSH
23619: LD_INT 2
23621: PUSH
23622: LD_INT 22
23624: PUSH
23625: LD_INT 1
23627: PUSH
23628: EMPTY
23629: LIST
23630: LIST
23631: PUSH
23632: LD_INT 22
23634: PUSH
23635: LD_INT 4
23637: PUSH
23638: EMPTY
23639: LIST
23640: LIST
23641: PUSH
23642: EMPTY
23643: LIST
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 26
23649: PUSH
23650: LD_INT 1
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PUSH
23657: LD_INT 3
23659: PUSH
23660: LD_INT 25
23662: PUSH
23663: LD_INT 16
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PUSH
23670: LD_INT 25
23672: PUSH
23673: LD_INT 12
23675: PUSH
23676: EMPTY
23677: LIST
23678: LIST
23679: PUSH
23680: EMPTY
23681: LIST
23682: LIST
23683: LIST
23684: PUSH
23685: EMPTY
23686: LIST
23687: LIST
23688: LIST
23689: PPUSH
23690: CALL_OW 69
23694: PUSH
23695: LD_VAR 0 11
23699: PUSH
23700: LD_EXP 36
23704: UNION
23705: PUSH
23706: LD_EXP 56
23710: UNION
23711: PUSH
23712: EMPTY
23713: LIST
23714: DIFF
23715: ST_TO_ADDR
// if tmp2 then
23716: LD_VAR 0 4
23720: IFFALSE 23738
// Say ( tmp2 [ 1 ] , D6c-Sol1-1 ) ;
23722: LD_VAR 0 4
23726: PUSH
23727: LD_INT 1
23729: ARRAY
23730: PPUSH
23731: LD_STRING D6c-Sol1-1
23733: PPUSH
23734: CALL_OW 88
// if Lisa then
23738: LD_EXP 39
23742: IFFALSE 23756
// Say ( Lisa , D6c-Lisa-1 ) ;
23744: LD_EXP 39
23748: PPUSH
23749: LD_STRING D6c-Lisa-1
23751: PPUSH
23752: CALL_OW 88
// if Gary then
23756: LD_EXP 48
23760: IFFALSE 23774
// Say ( Gary , D6c-Gary-1 ) ;
23762: LD_EXP 48
23766: PPUSH
23767: LD_STRING D6c-Gary-1
23769: PPUSH
23770: CALL_OW 88
// if Donaldson then
23774: LD_EXP 40
23778: IFFALSE 23792
// Say ( Donaldson , D6c-Don-1 ) ;
23780: LD_EXP 40
23784: PPUSH
23785: LD_STRING D6c-Don-1
23787: PPUSH
23788: CALL_OW 88
// if tmp2 > 1 then
23792: LD_VAR 0 4
23796: PUSH
23797: LD_INT 1
23799: GREATER
23800: IFFALSE 23818
// Say ( tmp2 [ 2 ] , D6c-Sol2-1 ) ;
23802: LD_VAR 0 4
23806: PUSH
23807: LD_INT 2
23809: ARRAY
23810: PPUSH
23811: LD_STRING D6c-Sol2-1
23813: PPUSH
23814: CALL_OW 88
// Say ( speaker , D6c-Sol3-2 ) ;
23818: LD_VAR 0 11
23822: PPUSH
23823: LD_STRING D6c-Sol3-2
23825: PPUSH
23826: CALL_OW 88
// dwait ( 0 0$1 ) ;
23830: LD_INT 35
23832: PPUSH
23833: CALL_OW 68
// Say ( JMM , D6c-JMM-2 ) ;
23837: LD_EXP 36
23841: PPUSH
23842: LD_STRING D6c-JMM-2
23844: PPUSH
23845: CALL_OW 88
// DialogueOff ;
23849: CALL_OW 7
// Video ( false ) ;
23853: LD_INT 0
23855: PPUSH
23856: CALL 106804 0 1
// SetSide ( FilterAllUnits ( [ f_side , 4 ] ) , 1 ) ;
23860: LD_INT 22
23862: PUSH
23863: LD_INT 4
23865: PUSH
23866: EMPTY
23867: LIST
23868: LIST
23869: PPUSH
23870: CALL_OW 69
23874: PPUSH
23875: LD_INT 1
23877: PPUSH
23878: CALL_OW 235
// ChangeSideFog ( 4 , 4 ) ;
23882: LD_INT 4
23884: PPUSH
23885: LD_INT 4
23887: PPUSH
23888: CALL_OW 343
// for i in GetTechNation ( 4 , 1 , 2 ) do
23892: LD_ADDR_VAR 0 1
23896: PUSH
23897: LD_INT 4
23899: PPUSH
23900: LD_INT 1
23902: PPUSH
23903: LD_INT 2
23905: PPUSH
23906: CALL 64124 0 3
23910: PUSH
23911: FOR_IN
23912: IFFALSE 23949
// if GetTech ( i , 1 ) <> state_researched then
23914: LD_VAR 0 1
23918: PPUSH
23919: LD_INT 1
23921: PPUSH
23922: CALL_OW 321
23926: PUSH
23927: LD_INT 2
23929: NONEQUAL
23930: IFFALSE 23947
// SetTech ( i , 1 , state_researched ) ;
23932: LD_VAR 0 1
23936: PPUSH
23937: LD_INT 1
23939: PPUSH
23940: LD_INT 2
23942: PPUSH
23943: CALL_OW 322
23947: GO 23911
23949: POP
23950: POP
// missionStage := 6 ;
23951: LD_ADDR_EXP 15
23955: PUSH
23956: LD_INT 6
23958: ST_TO_ADDR
// activeAttacks := true ;
23959: LD_ADDR_EXP 16
23963: PUSH
23964: LD_INT 1
23966: ST_TO_ADDR
// ChangeMissionObjectives ( M2 ) ;
23967: LD_STRING M2
23969: PPUSH
23970: CALL_OW 337
// SaveForQuickRestart ;
23974: CALL_OW 22
// wait ( 0 0$40 ) ;
23978: LD_INT 1400
23980: PPUSH
23981: CALL_OW 67
// DialogueOn ;
23985: CALL_OW 6
// SayRadio ( Friend , D7-Friend-1 ) ;
23989: LD_EXP 59
23993: PPUSH
23994: LD_STRING D7-Friend-1
23996: PPUSH
23997: CALL_OW 94
// Say ( JMM , D7-JMM-1 ) ;
24001: LD_EXP 36
24005: PPUSH
24006: LD_STRING D7-JMM-1
24008: PPUSH
24009: CALL_OW 88
// SayRadio ( Friend , D7-Friend-2 ) ;
24013: LD_EXP 59
24017: PPUSH
24018: LD_STRING D7-Friend-2
24020: PPUSH
24021: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
24025: LD_EXP 36
24029: PPUSH
24030: LD_STRING D7-JMM-2
24032: PPUSH
24033: CALL_OW 88
// SayRadio ( Friend , D7-Friend-3 ) ;
24037: LD_EXP 59
24041: PPUSH
24042: LD_STRING D7-Friend-3
24044: PPUSH
24045: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
24049: LD_EXP 36
24053: PPUSH
24054: LD_STRING D7-JMM-3
24056: PPUSH
24057: CALL_OW 88
// SayRadio ( Friend , D7-Friend-4 ) ;
24061: LD_EXP 59
24065: PPUSH
24066: LD_STRING D7-Friend-4
24068: PPUSH
24069: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
24073: LD_EXP 36
24077: PPUSH
24078: LD_STRING D7-JMM-4
24080: PPUSH
24081: CALL_OW 88
// SayRadio ( Friend , D7-Friend-5 ) ;
24085: LD_EXP 59
24089: PPUSH
24090: LD_STRING D7-Friend-5
24092: PPUSH
24093: CALL_OW 94
// Say ( JMM , D7-JMM-5 ) ;
24097: LD_EXP 36
24101: PPUSH
24102: LD_STRING D7-JMM-5
24104: PPUSH
24105: CALL_OW 88
// SayRadio ( Friend , D7-Friend-6 ) ;
24109: LD_EXP 59
24113: PPUSH
24114: LD_STRING D7-Friend-6
24116: PPUSH
24117: CALL_OW 94
// Say ( JMM , D7-JMM-6 ) ;
24121: LD_EXP 36
24125: PPUSH
24126: LD_STRING D7-JMM-6
24128: PPUSH
24129: CALL_OW 88
// DialogueOff ;
24133: CALL_OW 7
// ChangeMissionObjectives ( Mlegion ) ;
24137: LD_STRING Mlegion
24139: PPUSH
24140: CALL_OW 337
// RebuildKozlovFactory ;
24144: CALL 4773 0 0
// end ;
24148: PPOPN 13
24150: END
// every 0 0$2 trigger powellCenterCameraMode and IsLive ( Powell ) do
24151: LD_EXP 20
24155: PUSH
24156: LD_EXP 55
24160: PPUSH
24161: CALL_OW 300
24165: AND
24166: IFFALSE 24208
24168: GO 24170
24170: DISABLE
// begin enable ;
24171: ENABLE
// if IsInUnit ( Powell ) then
24172: LD_EXP 55
24176: PPUSH
24177: CALL_OW 310
24181: IFFALSE 24199
// CenterOnUnits ( IsInUnit ( Powell ) ) else
24183: LD_EXP 55
24187: PPUSH
24188: CALL_OW 310
24192: PPUSH
24193: CALL_OW 85
24197: GO 24208
// CenterOnUnits ( Powell ) ;
24199: LD_EXP 55
24203: PPUSH
24204: CALL_OW 85
// end ;
24208: END
// every 0 0$3 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) do var bomb , target ;
24209: LD_INT 22
24211: PUSH
24212: LD_INT 8
24214: PUSH
24215: EMPTY
24216: LIST
24217: LIST
24218: PUSH
24219: LD_INT 34
24221: PUSH
24222: LD_INT 48
24224: PUSH
24225: EMPTY
24226: LIST
24227: LIST
24228: PUSH
24229: EMPTY
24230: LIST
24231: LIST
24232: PPUSH
24233: CALL_OW 69
24237: IFFALSE 24500
24239: GO 24241
24241: DISABLE
24242: LD_INT 0
24244: PPUSH
24245: PPUSH
// begin if missionStage < 9 then
24246: LD_EXP 15
24250: PUSH
24251: LD_INT 9
24253: LESS
24254: IFFALSE 24264
// missionStage := 9 ;
24256: LD_ADDR_EXP 15
24260: PUSH
24261: LD_INT 9
24263: ST_TO_ADDR
// bomb := FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
24264: LD_ADDR_VAR 0 1
24268: PUSH
24269: LD_INT 22
24271: PUSH
24272: LD_INT 8
24274: PUSH
24275: EMPTY
24276: LIST
24277: LIST
24278: PUSH
24279: LD_INT 34
24281: PUSH
24282: LD_INT 48
24284: PUSH
24285: EMPTY
24286: LIST
24287: LIST
24288: PUSH
24289: EMPTY
24290: LIST
24291: LIST
24292: PPUSH
24293: CALL_OW 69
24297: PUSH
24298: LD_INT 1
24300: ARRAY
24301: ST_TO_ADDR
// wait ( 0 0$05 ) ;
24302: LD_INT 175
24304: PPUSH
24305: CALL_OW 67
// if FakeInfo or KurtStatus in [ 0 , 2 ] then
24309: LD_EXP 12
24313: PUSH
24314: LD_EXP 3
24318: PUSH
24319: LD_INT 0
24321: PUSH
24322: LD_INT 2
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: IN
24329: OR
24330: IFFALSE 24353
// target := [ 68 , 108 , 1 ] else
24332: LD_ADDR_VAR 0 2
24336: PUSH
24337: LD_INT 68
24339: PUSH
24340: LD_INT 108
24342: PUSH
24343: LD_INT 1
24345: PUSH
24346: EMPTY
24347: LIST
24348: LIST
24349: LIST
24350: ST_TO_ADDR
24351: GO 24372
// target := [ 181 , 88 , 2 ] ;
24353: LD_ADDR_VAR 0 2
24357: PUSH
24358: LD_INT 181
24360: PUSH
24361: LD_INT 88
24363: PUSH
24364: LD_INT 2
24366: PUSH
24367: EMPTY
24368: LIST
24369: LIST
24370: LIST
24371: ST_TO_ADDR
// AddComAttackPlace ( bomb , target [ 1 ] , target [ 2 ] ) ;
24372: LD_VAR 0 1
24376: PPUSH
24377: LD_VAR 0 2
24381: PUSH
24382: LD_INT 1
24384: ARRAY
24385: PPUSH
24386: LD_VAR 0 2
24390: PUSH
24391: LD_INT 2
24393: ARRAY
24394: PPUSH
24395: CALL_OW 176
// if target [ 3 ] = 1 then
24399: LD_VAR 0 2
24403: PUSH
24404: LD_INT 3
24406: ARRAY
24407: PUSH
24408: LD_INT 1
24410: EQUAL
24411: IFFALSE 24427
// SayRadio ( Kurt , D12-Kurt-1 ) else
24413: LD_EXP 57
24417: PPUSH
24418: LD_STRING D12-Kurt-1
24420: PPUSH
24421: CALL_OW 94
24425: GO 24451
// begin SayRadio ( Kurt , D12a-Kurt-1 ) ;
24427: LD_EXP 57
24431: PPUSH
24432: LD_STRING D12a-Kurt-1
24434: PPUSH
24435: CALL_OW 94
// SayRadio ( Roth , D12a-Roth-1 ) ;
24439: LD_EXP 71
24443: PPUSH
24444: LD_STRING D12a-Roth-1
24446: PPUSH
24447: CALL_OW 94
// end ; wait ( 0 0$10 ) ;
24451: LD_INT 350
24453: PPUSH
24454: CALL_OW 67
// AddComRecycle ( bomb , FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24458: LD_VAR 0 1
24462: PPUSH
24463: LD_INT 22
24465: PUSH
24466: LD_INT 8
24468: PUSH
24469: EMPTY
24470: LIST
24471: LIST
24472: PUSH
24473: LD_INT 30
24475: PUSH
24476: LD_INT 3
24478: PUSH
24479: EMPTY
24480: LIST
24481: LIST
24482: PUSH
24483: EMPTY
24484: LIST
24485: LIST
24486: PPUSH
24487: CALL_OW 69
24491: PUSH
24492: LD_INT 1
24494: ARRAY
24495: PPUSH
24496: CALL_OW 228
// end ;
24500: PPOPN 2
24502: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] , [ f_nation , 2 ] ] ) <= [ 8 , 7 , 6 ] [ Difficulty ] and not FilterAllUnits ( [ [ f_side , 8 ] , [ f_weapon , ru_siberium_rocket ] ] ) and IsOk ( Kurt ) do
24503: LD_INT 22
24505: PUSH
24506: LD_INT 8
24508: PUSH
24509: EMPTY
24510: LIST
24511: LIST
24512: PUSH
24513: LD_INT 21
24515: PUSH
24516: LD_INT 1
24518: PUSH
24519: EMPTY
24520: LIST
24521: LIST
24522: PUSH
24523: LD_INT 23
24525: PUSH
24526: LD_INT 2
24528: PUSH
24529: EMPTY
24530: LIST
24531: LIST
24532: PUSH
24533: EMPTY
24534: LIST
24535: LIST
24536: LIST
24537: PPUSH
24538: CALL_OW 69
24542: PUSH
24543: LD_INT 8
24545: PUSH
24546: LD_INT 7
24548: PUSH
24549: LD_INT 6
24551: PUSH
24552: EMPTY
24553: LIST
24554: LIST
24555: LIST
24556: PUSH
24557: LD_OWVAR 67
24561: ARRAY
24562: LESSEQUAL
24563: PUSH
24564: LD_INT 22
24566: PUSH
24567: LD_INT 8
24569: PUSH
24570: EMPTY
24571: LIST
24572: LIST
24573: PUSH
24574: LD_INT 34
24576: PUSH
24577: LD_INT 48
24579: PUSH
24580: EMPTY
24581: LIST
24582: LIST
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: PPUSH
24588: CALL_OW 69
24592: NOT
24593: AND
24594: PUSH
24595: LD_EXP 57
24599: PPUSH
24600: CALL_OW 302
24604: AND
24605: IFFALSE 24922
24607: GO 24609
24609: DISABLE
// begin DialogueOn ;
24610: CALL_OW 6
// Say ( JMM , D13-JMM-1 ) ;
24614: LD_EXP 36
24618: PPUSH
24619: LD_STRING D13-JMM-1
24621: PPUSH
24622: CALL_OW 88
// Say ( Kurt , D13-Kurt-1 ) ;
24626: LD_EXP 57
24630: PPUSH
24631: LD_STRING D13-Kurt-1
24633: PPUSH
24634: CALL_OW 88
// Say ( JMM , D13-JMM-2 ) ;
24638: LD_EXP 36
24642: PPUSH
24643: LD_STRING D13-JMM-2
24645: PPUSH
24646: CALL_OW 88
// if FakeInfo then
24650: LD_EXP 12
24654: IFFALSE 24674
// begin Say ( Kurt , D13-Kurt-2 ) ;
24656: LD_EXP 57
24660: PPUSH
24661: LD_STRING D13-Kurt-2
24663: PPUSH
24664: CALL_OW 88
// DialogueOff ;
24668: CALL_OW 7
// exit ;
24672: GO 24922
// end ; if not KurtStatus then
24674: LD_EXP 3
24678: NOT
24679: IFFALSE 24695
// Say ( Kurt , D13-Kurt-2b ) else
24681: LD_EXP 57
24685: PPUSH
24686: LD_STRING D13-Kurt-2b
24688: PPUSH
24689: CALL_OW 88
24693: GO 24707
// Say ( Kurt , D13-Kurt-2a ) ;
24695: LD_EXP 57
24699: PPUSH
24700: LD_STRING D13-Kurt-2a
24702: PPUSH
24703: CALL_OW 88
// Say ( Kurt , D13-Kurt-2a ) ;
24707: LD_EXP 57
24711: PPUSH
24712: LD_STRING D13-Kurt-2a
24714: PPUSH
24715: CALL_OW 88
// Say ( JMM , D13-JMM-3 ) ;
24719: LD_EXP 36
24723: PPUSH
24724: LD_STRING D13-JMM-3
24726: PPUSH
24727: CALL_OW 88
// Say ( Kurt , D13-Kurt-3 ) ;
24731: LD_EXP 57
24735: PPUSH
24736: LD_STRING D13-Kurt-3
24738: PPUSH
24739: CALL_OW 88
// Say ( JMM , D13-JMM-4 ) ;
24743: LD_EXP 36
24747: PPUSH
24748: LD_STRING D13-JMM-4
24750: PPUSH
24751: CALL_OW 88
// DialogueOff ;
24755: CALL_OW 7
// MC_Kill ( 3 ) ;
24759: LD_INT 3
24761: PPUSH
24762: CALL 34153 0 1
// KillUnit ( Kozlov ) ;
24766: LD_EXP 58
24770: PPUSH
24771: CALL_OW 66
// KillUnit ( FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_building ] , [ f_nation , 3 ] , [ f_btype , b_factory ] ] ) [ 1 ] ) ;
24775: LD_INT 22
24777: PUSH
24778: LD_INT 8
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: PUSH
24785: LD_INT 21
24787: PUSH
24788: LD_INT 3
24790: PUSH
24791: EMPTY
24792: LIST
24793: LIST
24794: PUSH
24795: LD_INT 23
24797: PUSH
24798: LD_INT 3
24800: PUSH
24801: EMPTY
24802: LIST
24803: LIST
24804: PUSH
24805: LD_INT 30
24807: PUSH
24808: LD_INT 3
24810: PUSH
24811: EMPTY
24812: LIST
24813: LIST
24814: PUSH
24815: EMPTY
24816: LIST
24817: LIST
24818: LIST
24819: LIST
24820: PPUSH
24821: CALL_OW 69
24825: PUSH
24826: LD_INT 1
24828: ARRAY
24829: PPUSH
24830: CALL_OW 66
// ChangeSideFog ( 8 , 1 ) ;
24834: LD_INT 8
24836: PPUSH
24837: LD_INT 1
24839: PPUSH
24840: CALL_OW 343
// SetSide ( FilterAllUnits ( [ f_side , 8 ] ) , 1 ) ;
24844: LD_INT 22
24846: PUSH
24847: LD_INT 8
24849: PUSH
24850: EMPTY
24851: LIST
24852: LIST
24853: PPUSH
24854: CALL_OW 69
24858: PPUSH
24859: LD_INT 1
24861: PPUSH
24862: CALL_OW 235
// SetAttitude ( 8 , 1 , att_friend , true ) ;
24866: LD_INT 8
24868: PPUSH
24869: LD_INT 1
24871: PPUSH
24872: LD_INT 1
24874: PPUSH
24875: LD_INT 1
24877: PPUSH
24878: CALL_OW 80
// PlaceUnitXY ( Friend , 37 , 1 , false ) ;
24882: LD_EXP 59
24886: PPUSH
24887: LD_INT 37
24889: PPUSH
24890: LD_INT 1
24892: PPUSH
24893: LD_INT 0
24895: PPUSH
24896: CALL_OW 48
// wait ( 0 0$1 ) ;
24900: LD_INT 35
24902: PPUSH
24903: CALL_OW 67
// ComMoveXY ( Friend , 60 , 95 ) ;
24907: LD_EXP 59
24911: PPUSH
24912: LD_INT 60
24914: PPUSH
24915: LD_INT 95
24917: PPUSH
24918: CALL_OW 111
// end ;
24922: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 8 ] , [ f_type , unit_human ] ] ) = 0 do
24923: LD_INT 22
24925: PUSH
24926: LD_INT 8
24928: PUSH
24929: EMPTY
24930: LIST
24931: LIST
24932: PUSH
24933: LD_INT 21
24935: PUSH
24936: LD_INT 1
24938: PUSH
24939: EMPTY
24940: LIST
24941: LIST
24942: PUSH
24943: EMPTY
24944: LIST
24945: LIST
24946: PPUSH
24947: CALL_OW 69
24951: PUSH
24952: LD_INT 0
24954: EQUAL
24955: IFFALSE 24975
24957: GO 24959
24959: DISABLE
// begin ChangeMissionObjectives ( MlegionOut ) ;
24960: LD_STRING MlegionOut
24962: PPUSH
24963: CALL_OW 337
// legionDestroyed := true ;
24967: LD_ADDR_EXP 22
24971: PUSH
24972: LD_INT 1
24974: ST_TO_ADDR
// end ;
24975: END
// every 0 0$1 trigger See ( 1 , Friend ) do var dec ;
24976: LD_INT 1
24978: PPUSH
24979: LD_EXP 59
24983: PPUSH
24984: CALL_OW 292
24988: IFFALSE 25288
24990: GO 24992
24992: DISABLE
24993: LD_INT 0
24995: PPUSH
// begin CenterNowOnUnits ( Friend ) ;
24996: LD_EXP 59
25000: PPUSH
25001: CALL_OW 87
// DialogueOn ;
25005: CALL_OW 6
// Say ( JMM , D14-JMM-1 ) ;
25009: LD_EXP 36
25013: PPUSH
25014: LD_STRING D14-JMM-1
25016: PPUSH
25017: CALL_OW 88
// Say ( Friend , D14-Friend-1 ) ;
25021: LD_EXP 59
25025: PPUSH
25026: LD_STRING D14-Friend-1
25028: PPUSH
25029: CALL_OW 88
// Say ( JMM , D14-JMM-2 ) ;
25033: LD_EXP 36
25037: PPUSH
25038: LD_STRING D14-JMM-2
25040: PPUSH
25041: CALL_OW 88
// Say ( Friend , D14-Friend-2 ) ;
25045: LD_EXP 59
25049: PPUSH
25050: LD_STRING D14-Friend-2
25052: PPUSH
25053: CALL_OW 88
// Say ( JMM , D14-JMM-3 ) ;
25057: LD_EXP 36
25061: PPUSH
25062: LD_STRING D14-JMM-3
25064: PPUSH
25065: CALL_OW 88
// Say ( Friend , D14-Friend-3 ) ;
25069: LD_EXP 59
25073: PPUSH
25074: LD_STRING D14-Friend-3
25076: PPUSH
25077: CALL_OW 88
// DialogueOff ;
25081: CALL_OW 7
// dec = Query ( Q14 ) ;
25085: LD_ADDR_VAR 0 1
25089: PUSH
25090: LD_STRING Q14
25092: PPUSH
25093: CALL_OW 97
25097: ST_TO_ADDR
// if dec = 1 then
25098: LD_VAR 0 1
25102: PUSH
25103: LD_INT 1
25105: EQUAL
25106: IFFALSE 25140
// begin DialogueOn ;
25108: CALL_OW 6
// Say ( JMM , D14a-JMM-1 ) ;
25112: LD_EXP 36
25116: PPUSH
25117: LD_STRING D14a-JMM-1
25119: PPUSH
25120: CALL_OW 88
// DialogueOff ;
25124: CALL_OW 7
// SetSide ( Friend , 1 ) ;
25128: LD_EXP 59
25132: PPUSH
25133: LD_INT 1
25135: PPUSH
25136: CALL_OW 235
// end ; if dec = 2 then
25140: LD_VAR 0 1
25144: PUSH
25145: LD_INT 2
25147: EQUAL
25148: IFFALSE 25194
// begin DialogueOn ;
25150: CALL_OW 6
// Say ( JMM , D14b-JMM-1 ) ;
25154: LD_EXP 36
25158: PPUSH
25159: LD_STRING D14b-JMM-1
25161: PPUSH
25162: CALL_OW 88
// DialogueOff ;
25166: CALL_OW 7
// ComMoveXY ( Friend , 9 , 2 ) ;
25170: LD_EXP 59
25174: PPUSH
25175: LD_INT 9
25177: PPUSH
25178: LD_INT 2
25180: PPUSH
25181: CALL_OW 111
// AddComHold ( Friend ) ;
25185: LD_EXP 59
25189: PPUSH
25190: CALL_OW 200
// end ; if dec = 3 then
25194: LD_VAR 0 1
25198: PUSH
25199: LD_INT 3
25201: EQUAL
25202: IFFALSE 25288
// begin DialogueOn ;
25204: CALL_OW 6
// Say ( JMM , D14c-JMM-1 ) ;
25208: LD_EXP 36
25212: PPUSH
25213: LD_STRING D14c-JMM-1
25215: PPUSH
25216: CALL_OW 88
// Say ( Friend , D14c-Friend-1 ) ;
25220: LD_EXP 59
25224: PPUSH
25225: LD_STRING D14c-Friend-1
25227: PPUSH
25228: CALL_OW 88
// Say ( JMM , D14c-JMM-2 ) ;
25232: LD_EXP 36
25236: PPUSH
25237: LD_STRING D14c-JMM-2
25239: PPUSH
25240: CALL_OW 88
// DialogueOff ;
25244: CALL_OW 7
// SetAttitude ( 8 , 1 , att_enemy , true ) ;
25248: LD_INT 8
25250: PPUSH
25251: LD_INT 1
25253: PPUSH
25254: LD_INT 2
25256: PPUSH
25257: LD_INT 1
25259: PPUSH
25260: CALL_OW 80
// ComMoveXY ( Friend , 9 , 2 ) ;
25264: LD_EXP 59
25268: PPUSH
25269: LD_INT 9
25271: PPUSH
25272: LD_INT 2
25274: PPUSH
25275: CALL_OW 111
// AddComHold ( Friend ) ;
25279: LD_EXP 59
25283: PPUSH
25284: CALL_OW 200
// end ; end ;
25288: PPOPN 1
25290: END
// every 0 0$1 trigger HexInfo ( 9 , 2 ) = Friend and GetSide ( Friend ) = 8 do
25291: LD_INT 9
25293: PPUSH
25294: LD_INT 2
25296: PPUSH
25297: CALL_OW 428
25301: PUSH
25302: LD_EXP 59
25306: EQUAL
25307: PUSH
25308: LD_EXP 59
25312: PPUSH
25313: CALL_OW 255
25317: PUSH
25318: LD_INT 8
25320: EQUAL
25321: AND
25322: IFFALSE 25336
25324: GO 25326
25326: DISABLE
// RemoveUnit ( Friend ) ;
25327: LD_EXP 59
25331: PPUSH
25332: CALL_OW 64
25336: END
// every 0 0$1 trigger missionTime >= 15 15$00 and JMMGirl and KappaStatus do var i , veh , vehG ;
25337: LD_EXP 14
25341: PUSH
25342: LD_INT 31500
25344: GREATEREQUAL
25345: PUSH
25346: LD_EXP 7
25350: AND
25351: PUSH
25352: LD_EXP 2
25356: AND
25357: IFFALSE 25787
25359: GO 25361
25361: DISABLE
25362: LD_INT 0
25364: PPUSH
25365: PPUSH
25366: PPUSH
// begin missionStage := 7 ;
25367: LD_ADDR_EXP 15
25371: PUSH
25372: LD_INT 7
25374: ST_TO_ADDR
// uc_side = 1 ;
25375: LD_ADDR_OWVAR 20
25379: PUSH
25380: LD_INT 1
25382: ST_TO_ADDR
// uc_nation = 1 ;
25383: LD_ADDR_OWVAR 21
25387: PUSH
25388: LD_INT 1
25390: ST_TO_ADDR
// for i = 1 to 5 do
25391: LD_ADDR_VAR 0 1
25395: PUSH
25396: DOUBLE
25397: LD_INT 1
25399: DEC
25400: ST_TO_ADDR
25401: LD_INT 5
25403: PUSH
25404: FOR_TO
25405: IFFALSE 25501
// begin vc_engine = 3 ;
25407: LD_ADDR_OWVAR 39
25411: PUSH
25412: LD_INT 3
25414: ST_TO_ADDR
// vc_control = 3 ;
25415: LD_ADDR_OWVAR 38
25419: PUSH
25420: LD_INT 3
25422: ST_TO_ADDR
// vc_chassis = 3 ;
25423: LD_ADDR_OWVAR 37
25427: PUSH
25428: LD_INT 3
25430: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25431: LD_ADDR_OWVAR 40
25435: PUSH
25436: LD_INT 5
25438: PUSH
25439: LD_INT 9
25441: PUSH
25442: LD_INT 7
25444: PUSH
25445: EMPTY
25446: LIST
25447: LIST
25448: LIST
25449: PUSH
25450: LD_INT 1
25452: PPUSH
25453: LD_INT 3
25455: PPUSH
25456: CALL_OW 12
25460: ARRAY
25461: ST_TO_ADDR
// veh = CreateVehicle ;
25462: LD_ADDR_VAR 0 2
25466: PUSH
25467: CALL_OW 45
25471: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25472: LD_VAR 0 2
25476: PPUSH
25477: LD_INT 1
25479: PPUSH
25480: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25484: LD_VAR 0 2
25488: PPUSH
25489: LD_INT 19
25491: PPUSH
25492: LD_INT 0
25494: PPUSH
25495: CALL_OW 49
// end ;
25499: GO 25404
25501: POP
25502: POP
// vc_engine = 3 ;
25503: LD_ADDR_OWVAR 39
25507: PUSH
25508: LD_INT 3
25510: ST_TO_ADDR
// vc_control = 1 ;
25511: LD_ADDR_OWVAR 38
25515: PUSH
25516: LD_INT 1
25518: ST_TO_ADDR
// vc_chassis = 3 ;
25519: LD_ADDR_OWVAR 37
25523: PUSH
25524: LD_INT 3
25526: ST_TO_ADDR
// vc_weapon = [ 5 , 9 , 7 ] [ Rand ( 1 , 3 ) ] ;
25527: LD_ADDR_OWVAR 40
25531: PUSH
25532: LD_INT 5
25534: PUSH
25535: LD_INT 9
25537: PUSH
25538: LD_INT 7
25540: PUSH
25541: EMPTY
25542: LIST
25543: LIST
25544: LIST
25545: PUSH
25546: LD_INT 1
25548: PPUSH
25549: LD_INT 3
25551: PPUSH
25552: CALL_OW 12
25556: ARRAY
25557: ST_TO_ADDR
// vehG = CreateVehicle ;
25558: LD_ADDR_VAR 0 3
25562: PUSH
25563: CALL_OW 45
25567: ST_TO_ADDR
// SetDir ( vehG , 1 ) ;
25568: LD_VAR 0 3
25572: PPUSH
25573: LD_INT 1
25575: PPUSH
25576: CALL_OW 233
// PlaceUnitArea ( vehG , reinforcementsArea , false ) ;
25580: LD_VAR 0 3
25584: PPUSH
25585: LD_INT 19
25587: PPUSH
25588: LD_INT 0
25590: PPUSH
25591: CALL_OW 49
// if JMMGirl = 1 then
25595: LD_EXP 7
25599: PUSH
25600: LD_INT 1
25602: EQUAL
25603: IFFALSE 25659
// begin Joan = PrepareUnit ( Joan , true , 14_ ) ;
25605: LD_ADDR_EXP 37
25609: PUSH
25610: LD_STRING Joan
25612: PPUSH
25613: LD_INT 1
25615: PPUSH
25616: LD_STRING 14_
25618: PPUSH
25619: CALL 64061 0 3
25623: ST_TO_ADDR
// PlaceHumanInUnit ( Joan , vehG ) ;
25624: LD_EXP 37
25628: PPUSH
25629: LD_VAR 0 3
25633: PPUSH
25634: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25638: LD_VAR 0 3
25642: PPUSH
25643: CALL_OW 87
// SayRadio ( Joan , D10BW-Joan-1 ) ;
25647: LD_EXP 37
25651: PPUSH
25652: LD_STRING D10BW-Joan-1
25654: PPUSH
25655: CALL_OW 94
// end ; if JMMGirl = 2 then
25659: LD_EXP 7
25663: PUSH
25664: LD_INT 2
25666: EQUAL
25667: IFFALSE 25723
// begin Lisa = PrepareUnit ( Lisa , true , 14_ ) ;
25669: LD_ADDR_EXP 39
25673: PUSH
25674: LD_STRING Lisa
25676: PPUSH
25677: LD_INT 1
25679: PPUSH
25680: LD_STRING 14_
25682: PPUSH
25683: CALL 64061 0 3
25687: ST_TO_ADDR
// PlaceHumanInUnit ( Lisa , vehG ) ;
25688: LD_EXP 39
25692: PPUSH
25693: LD_VAR 0 3
25697: PPUSH
25698: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25702: LD_VAR 0 3
25706: PPUSH
25707: CALL_OW 87
// SayRadio ( Lisa , D10BW-Lisa-1 ) ;
25711: LD_EXP 39
25715: PPUSH
25716: LD_STRING D10BW-Lisa-1
25718: PPUSH
25719: CALL_OW 94
// end ; if JMMGirl = 3 then
25723: LD_EXP 7
25727: PUSH
25728: LD_INT 3
25730: EQUAL
25731: IFFALSE 25787
// begin Connie = PrepareUnit ( Connie , true , 14_ ) ;
25733: LD_ADDR_EXP 51
25737: PUSH
25738: LD_STRING Connie
25740: PPUSH
25741: LD_INT 1
25743: PPUSH
25744: LD_STRING 14_
25746: PPUSH
25747: CALL 64061 0 3
25751: ST_TO_ADDR
// PlaceHumanInUnit ( Connie , vehG ) ;
25752: LD_EXP 51
25756: PPUSH
25757: LD_VAR 0 3
25761: PPUSH
25762: CALL_OW 52
// CenterNowOnUnits ( vehG ) ;
25766: LD_VAR 0 3
25770: PPUSH
25771: CALL_OW 87
// SayRadio ( Lisa , D10BW-Con-1 ) ;
25775: LD_EXP 39
25779: PPUSH
25780: LD_STRING D10BW-Con-1
25782: PPUSH
25783: CALL_OW 94
// end ; end ;
25787: PPOPN 3
25789: END
// every 0 0$1 trigger missionTime >= 45 45$00 do var i , veh , tmp ;
25790: LD_EXP 14
25794: PUSH
25795: LD_INT 94500
25797: GREATEREQUAL
25798: IFFALSE 26210
25800: GO 25802
25802: DISABLE
25803: LD_INT 0
25805: PPUSH
25806: PPUSH
25807: PPUSH
// begin tmp := PrepareStevensSquad ;
25808: LD_ADDR_VAR 0 3
25812: PUSH
25813: CALL 2147 0 0
25817: ST_TO_ADDR
// if not tmp then
25818: LD_VAR 0 3
25822: NOT
25823: IFFALSE 25827
// exit ;
25825: GO 26210
// uc_side := 1 ;
25827: LD_ADDR_OWVAR 20
25831: PUSH
25832: LD_INT 1
25834: ST_TO_ADDR
// uc_nation := 1 ;
25835: LD_ADDR_OWVAR 21
25839: PUSH
25840: LD_INT 1
25842: ST_TO_ADDR
// for i in tmp do
25843: LD_ADDR_VAR 0 1
25847: PUSH
25848: LD_VAR 0 3
25852: PUSH
25853: FOR_IN
25854: IFFALSE 25951
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_manual , [ us_double_gun , us_laser , us_rocket_launcher ] [ rand ( 1 , 3 ) ] , 40 ) ;
25856: LD_INT 3
25858: PPUSH
25859: LD_INT 3
25861: PPUSH
25862: LD_INT 1
25864: PPUSH
25865: LD_INT 5
25867: PUSH
25868: LD_INT 9
25870: PUSH
25871: LD_INT 7
25873: PUSH
25874: EMPTY
25875: LIST
25876: LIST
25877: LIST
25878: PUSH
25879: LD_INT 1
25881: PPUSH
25882: LD_INT 3
25884: PPUSH
25885: CALL_OW 12
25889: ARRAY
25890: PPUSH
25891: LD_INT 40
25893: PPUSH
25894: CALL 71087 0 5
// veh := CreateVehicle ;
25898: LD_ADDR_VAR 0 2
25902: PUSH
25903: CALL_OW 45
25907: ST_TO_ADDR
// SetDir ( veh , 1 ) ;
25908: LD_VAR 0 2
25912: PPUSH
25913: LD_INT 1
25915: PPUSH
25916: CALL_OW 233
// PlaceUnitArea ( veh , reinforcementsArea , false ) ;
25920: LD_VAR 0 2
25924: PPUSH
25925: LD_INT 19
25927: PPUSH
25928: LD_INT 0
25930: PPUSH
25931: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
25935: LD_VAR 0 1
25939: PPUSH
25940: LD_VAR 0 2
25944: PPUSH
25945: CALL_OW 52
// end ;
25949: GO 25853
25951: POP
25952: POP
// missionStage := 8 ;
25953: LD_ADDR_EXP 15
25957: PUSH
25958: LD_INT 8
25960: ST_TO_ADDR
// DialogueOn ;
25961: CALL_OW 6
// if Stevens then
25965: LD_EXP 38
25969: IFFALSE 26083
// begin CenterNowOnUnits ( IsInUnit ( Stevens ) ) ;
25971: LD_EXP 38
25975: PPUSH
25976: CALL_OW 310
25980: PPUSH
25981: CALL_OW 87
// SayRadio ( Stevens , D8-Huck-1 ) ;
25985: LD_EXP 38
25989: PPUSH
25990: LD_STRING D8-Huck-1
25992: PPUSH
25993: CALL_OW 94
// Say ( JMM , D8-JMM-1 ) ;
25997: LD_EXP 36
26001: PPUSH
26002: LD_STRING D8-JMM-1
26004: PPUSH
26005: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-2 ) ;
26009: LD_EXP 38
26013: PPUSH
26014: LD_STRING D8-Huck-2
26016: PPUSH
26017: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26021: LD_EXP 36
26025: PPUSH
26026: LD_STRING D8-JMM-2
26028: PPUSH
26029: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-3 ) ;
26033: LD_EXP 38
26037: PPUSH
26038: LD_STRING D8-Huck-3
26040: PPUSH
26041: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26045: LD_EXP 36
26049: PPUSH
26050: LD_STRING D8-JMM-3
26052: PPUSH
26053: CALL_OW 88
// SayRadio ( Stevens , D8-Huck-4 ) ;
26057: LD_EXP 38
26061: PPUSH
26062: LD_STRING D8-Huck-4
26064: PPUSH
26065: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26069: LD_EXP 36
26073: PPUSH
26074: LD_STRING D8-JMM-4
26076: PPUSH
26077: CALL_OW 88
// end else
26081: GO 26193
// begin CenterNowOnUnits ( IsInUnit ( Baker ) ) ;
26083: LD_EXP 52
26087: PPUSH
26088: CALL_OW 310
26092: PPUSH
26093: CALL_OW 87
// SayRadio ( Baker , D8-Huck-1 ) ;
26097: LD_EXP 52
26101: PPUSH
26102: LD_STRING D8-Huck-1
26104: PPUSH
26105: CALL_OW 94
// Say ( JMM , D8-JMM-1a ) ;
26109: LD_EXP 36
26113: PPUSH
26114: LD_STRING D8-JMM-1a
26116: PPUSH
26117: CALL_OW 88
// SayRadio ( Baker , D8-Huck-2 ) ;
26121: LD_EXP 52
26125: PPUSH
26126: LD_STRING D8-Huck-2
26128: PPUSH
26129: CALL_OW 94
// Say ( JMM , D8-JMM-2 ) ;
26133: LD_EXP 36
26137: PPUSH
26138: LD_STRING D8-JMM-2
26140: PPUSH
26141: CALL_OW 88
// SayRadio ( Baker , D8-Huck-3 ) ;
26145: LD_EXP 52
26149: PPUSH
26150: LD_STRING D8-Huck-3
26152: PPUSH
26153: CALL_OW 94
// Say ( JMM , D8-JMM-3 ) ;
26157: LD_EXP 36
26161: PPUSH
26162: LD_STRING D8-JMM-3
26164: PPUSH
26165: CALL_OW 88
// SayRadio ( Baker , D8-Huck-4 ) ;
26169: LD_EXP 52
26173: PPUSH
26174: LD_STRING D8-Huck-4
26176: PPUSH
26177: CALL_OW 94
// Say ( JMM , D8-JMM-4 ) ;
26181: LD_EXP 36
26185: PPUSH
26186: LD_STRING D8-JMM-4
26188: PPUSH
26189: CALL_OW 88
// end ; DialogueOff ;
26193: CALL_OW 7
// SetTech ( tech_SibFiss , 1 , state_enabled ) ;
26197: LD_INT 25
26199: PPUSH
26200: LD_INT 1
26202: PPUSH
26203: LD_INT 1
26205: PPUSH
26206: CALL_OW 322
// end ;
26210: PPOPN 3
26212: END
// every 0 0$1 trigger See ( 1 , sewiVeh ) do
26213: LD_INT 1
26215: PPUSH
26216: LD_EXP 68
26220: PPUSH
26221: CALL_OW 292
26225: IFFALSE 26476
26227: GO 26229
26229: DISABLE
// begin CenterNowOnUnits ( sewiVeh ) ;
26230: LD_EXP 68
26234: PPUSH
26235: CALL_OW 87
// DialogueOn ;
26239: CALL_OW 6
// Say ( JMM , D10nB-JMM-1 ) ;
26243: LD_EXP 36
26247: PPUSH
26248: LD_STRING D10nB-JMM-1
26250: PPUSH
26251: CALL_OW 88
// if BurlakStatus = 1 then
26255: LD_EXP 9
26259: PUSH
26260: LD_INT 1
26262: EQUAL
26263: IFFALSE 26277
// begin SayRadio ( Vsevolod , D10nB-Vse-1a ) ;
26265: LD_EXP 67
26269: PPUSH
26270: LD_STRING D10nB-Vse-1a
26272: PPUSH
26273: CALL_OW 94
// end ; if BurlakStatus = 0 then
26277: LD_EXP 9
26281: PUSH
26282: LD_INT 0
26284: EQUAL
26285: IFFALSE 26299
// SayRadio ( Vsevolod , D10nB-Vse-1 ) ;
26287: LD_EXP 67
26291: PPUSH
26292: LD_STRING D10nB-Vse-1
26294: PPUSH
26295: CALL_OW 94
// Say ( JMM , D10nB-JMM-2 ) ;
26299: LD_EXP 36
26303: PPUSH
26304: LD_STRING D10nB-JMM-2
26306: PPUSH
26307: CALL_OW 88
// if KappaStatus then
26311: LD_EXP 2
26315: IFFALSE 26329
// SayRadio ( Vsevolod , D10nB-Vse-5a ) ;
26317: LD_EXP 67
26321: PPUSH
26322: LD_STRING D10nB-Vse-5a
26324: PPUSH
26325: CALL_OW 94
// if not KappaStatus and JMMGirlStatus = 0 then
26329: LD_EXP 2
26333: NOT
26334: PUSH
26335: LD_EXP 6
26339: PUSH
26340: LD_INT 0
26342: EQUAL
26343: AND
26344: IFFALSE 26472
// begin if JMMGirl = 1 then
26346: LD_EXP 7
26350: PUSH
26351: LD_INT 1
26353: EQUAL
26354: IFFALSE 26404
// begin SayRadio ( Vsevolod , D10nB-Vse-2 ) ;
26356: LD_EXP 67
26360: PPUSH
26361: LD_STRING D10nB-Vse-2
26363: PPUSH
26364: CALL_OW 94
// Say ( JMM , D10nB-JMM-3 ) ;
26368: LD_EXP 36
26372: PPUSH
26373: LD_STRING D10nB-JMM-3
26375: PPUSH
26376: CALL_OW 88
// SayRadio ( Vsevolod , D10nB-Vse-3 ) ;
26380: LD_EXP 67
26384: PPUSH
26385: LD_STRING D10nB-Vse-3
26387: PPUSH
26388: CALL_OW 94
// Say ( JMM , D10nB-JMM-4 ) ;
26392: LD_EXP 36
26396: PPUSH
26397: LD_STRING D10nB-JMM-4
26399: PPUSH
26400: CALL_OW 88
// end ; if JMMGirl = 2 then
26404: LD_EXP 7
26408: PUSH
26409: LD_INT 2
26411: EQUAL
26412: IFFALSE 26438
// begin SayRadio ( Vsevolod , D10nB-Vse-4 ) ;
26414: LD_EXP 67
26418: PPUSH
26419: LD_STRING D10nB-Vse-4
26421: PPUSH
26422: CALL_OW 94
// Say ( JMM , D10nB-JMM-5 ) ;
26426: LD_EXP 36
26430: PPUSH
26431: LD_STRING D10nB-JMM-5
26433: PPUSH
26434: CALL_OW 88
// end ; if JMMGirl = 3 then
26438: LD_EXP 7
26442: PUSH
26443: LD_INT 3
26445: EQUAL
26446: IFFALSE 26472
// begin SayRadio ( Vsevolod , D10nB-Vse-5 ) ;
26448: LD_EXP 67
26452: PPUSH
26453: LD_STRING D10nB-Vse-5
26455: PPUSH
26456: CALL_OW 94
// Say ( JMM , D10nB-JMM-6 ) ;
26460: LD_EXP 36
26464: PPUSH
26465: LD_STRING D10nB-JMM-6
26467: PPUSH
26468: CALL_OW 88
// end ; end ; DialogueOff ;
26472: CALL_OW 7
// end ;
26476: END
// every 0 0$1 trigger missionTime >= 55 55$00 do var tmp ;
26477: LD_EXP 14
26481: PUSH
26482: LD_INT 115500
26484: GREATEREQUAL
26485: IFFALSE 26844
26487: GO 26489
26489: DISABLE
26490: LD_INT 0
26492: PPUSH
// begin missionStage := 10 ;
26493: LD_ADDR_EXP 15
26497: PUSH
26498: LD_INT 10
26500: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] ] , [ f_not , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
26501: LD_ADDR_VAR 0 1
26505: PUSH
26506: LD_INT 22
26508: PUSH
26509: LD_INT 1
26511: PUSH
26512: EMPTY
26513: LIST
26514: LIST
26515: PUSH
26516: LD_INT 26
26518: PUSH
26519: LD_INT 1
26521: PUSH
26522: EMPTY
26523: LIST
26524: LIST
26525: PUSH
26526: LD_INT 3
26528: PUSH
26529: LD_INT 25
26531: PUSH
26532: LD_INT 12
26534: PUSH
26535: EMPTY
26536: LIST
26537: LIST
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: PUSH
26543: LD_INT 3
26545: PUSH
26546: LD_INT 25
26548: PUSH
26549: LD_INT 16
26551: PUSH
26552: EMPTY
26553: LIST
26554: LIST
26555: PUSH
26556: EMPTY
26557: LIST
26558: LIST
26559: PUSH
26560: EMPTY
26561: LIST
26562: LIST
26563: LIST
26564: LIST
26565: PPUSH
26566: CALL_OW 69
26570: PUSH
26571: LD_EXP 36
26575: PUSH
26576: LD_EXP 38
26580: PUSH
26581: LD_EXP 52
26585: PUSH
26586: LD_EXP 39
26590: PUSH
26591: LD_EXP 40
26595: PUSH
26596: LD_EXP 41
26600: PUSH
26601: LD_EXP 42
26605: PUSH
26606: LD_EXP 43
26610: PUSH
26611: LD_EXP 44
26615: PUSH
26616: LD_EXP 45
26620: PUSH
26621: LD_EXP 46
26625: PUSH
26626: LD_EXP 47
26630: PUSH
26631: LD_EXP 48
26635: PUSH
26636: LD_EXP 49
26640: PUSH
26641: LD_EXP 50
26645: PUSH
26646: EMPTY
26647: LIST
26648: LIST
26649: LIST
26650: LIST
26651: LIST
26652: LIST
26653: LIST
26654: LIST
26655: LIST
26656: LIST
26657: LIST
26658: LIST
26659: LIST
26660: LIST
26661: LIST
26662: DIFF
26663: ST_TO_ADDR
// if not tmp and Brown then
26664: LD_VAR 0 1
26668: NOT
26669: PUSH
26670: LD_EXP 44
26674: AND
26675: IFFALSE 26690
// tmp := [ Brown ] ;
26677: LD_ADDR_VAR 0 1
26681: PUSH
26682: LD_EXP 44
26686: PUSH
26687: EMPTY
26688: LIST
26689: ST_TO_ADDR
// DialogueOn ;
26690: CALL_OW 6
// Say ( tmp [ 1 ] , D11-Sol1-1 ) ;
26694: LD_VAR 0 1
26698: PUSH
26699: LD_INT 1
26701: ARRAY
26702: PPUSH
26703: LD_STRING D11-Sol1-1
26705: PPUSH
26706: CALL_OW 88
// SayRadio ( Platonov , D11-Pla-1 ) ;
26710: LD_EXP 61
26714: PPUSH
26715: LD_STRING D11-Pla-1
26717: PPUSH
26718: CALL_OW 94
// SayRadio ( Kovalyuk , D11-Kov-1 ) ;
26722: LD_EXP 62
26726: PPUSH
26727: LD_STRING D11-Kov-1
26729: PPUSH
26730: CALL_OW 94
// SayRadio ( Platonov , D11-Pla-2 ) ;
26734: LD_EXP 61
26738: PPUSH
26739: LD_STRING D11-Pla-2
26741: PPUSH
26742: CALL_OW 94
// Say ( tmp [ 1 ] , D11-Sol1-2 ) ;
26746: LD_VAR 0 1
26750: PUSH
26751: LD_INT 1
26753: ARRAY
26754: PPUSH
26755: LD_STRING D11-Sol1-2
26757: PPUSH
26758: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
26762: LD_EXP 36
26766: PPUSH
26767: LD_STRING D11-JMM-2
26769: PPUSH
26770: CALL_OW 88
// DialogueOff ;
26774: CALL_OW 7
// allowBehemothConstruct := true ;
26778: LD_ADDR_EXP 25
26782: PUSH
26783: LD_INT 1
26785: ST_TO_ADDR
// ChangeMissionObjectives ( M4 ) ;
26786: LD_STRING M4
26788: PPUSH
26789: CALL_OW 337
// BuildBehemoths ;
26793: CALL 7577 0 0
// repeat wait ( 15 15$00 ) ;
26797: LD_INT 31500
26799: PPUSH
26800: CALL_OW 67
// if behemothDestroyedBeforeFinish then
26804: LD_EXP 27
26808: IFFALSE 26812
// break ;
26810: GO 26844
// if GetResourceType ( GetBase ( ru_depot2 ) , mat_cans ) >= 1000 then
26812: LD_INT 267
26814: PPUSH
26815: CALL_OW 274
26819: PPUSH
26820: LD_INT 1
26822: PPUSH
26823: CALL_OW 275
26827: PUSH
26828: LD_INT 1000
26830: GREATEREQUAL
26831: IFFALSE 26837
// BuildBehemoths ;
26833: CALL 7577 0 0
// until not behemothBuilders ;
26837: LD_EXP 70
26841: NOT
26842: IFFALSE 26797
// end ;
26844: PPOPN 1
26846: END
// every 0 0$1 trigger not behemothBuilders and not behemothDone and allowBehemothConstruct do
26847: LD_EXP 70
26851: NOT
26852: PUSH
26853: LD_EXP 28
26857: NOT
26858: AND
26859: PUSH
26860: LD_EXP 25
26864: AND
26865: IFFALSE 26885
26867: GO 26869
26869: DISABLE
// begin ChangeMissionObjectives ( M4a ) ;
26870: LD_STRING M4a
26872: PPUSH
26873: CALL_OW 337
// behemothDestroyedBeforeFinish := true ;
26877: LD_ADDR_EXP 27
26881: PUSH
26882: LD_INT 1
26884: ST_TO_ADDR
// end ;
26885: END
// every 0 0$1 trigger behemothDone do
26886: LD_EXP 28
26890: IFFALSE 26902
26892: GO 26894
26894: DISABLE
// ChangeMissionObjectives ( M4b ) ;
26895: LD_STRING M4b
26897: PPUSH
26898: CALL_OW 337
26902: END
// every 0 0$1 trigger not seeBehemoth do var tmp , i ;
26903: LD_EXP 29
26907: NOT
26908: IFFALSE 27104
26910: GO 26912
26912: DISABLE
26913: LD_INT 0
26915: PPUSH
26916: PPUSH
// begin enable ;
26917: ENABLE
// tmp := GetBehemoths ( 3 ) ;
26918: LD_ADDR_VAR 0 1
26922: PUSH
26923: LD_INT 3
26925: PPUSH
26926: CALL 106880 0 1
26930: ST_TO_ADDR
// if not tmp and not behemothDone then
26931: LD_VAR 0 1
26935: NOT
26936: PUSH
26937: LD_EXP 28
26941: NOT
26942: AND
26943: IFFALSE 26979
// tmp := FilterAllUnits ( [ [ f_side , 3 ] , [ f_btype , b_behemoth ] ] ) ;
26945: LD_ADDR_VAR 0 1
26949: PUSH
26950: LD_INT 22
26952: PUSH
26953: LD_INT 3
26955: PUSH
26956: EMPTY
26957: LIST
26958: LIST
26959: PUSH
26960: LD_INT 30
26962: PUSH
26963: LD_INT 37
26965: PUSH
26966: EMPTY
26967: LIST
26968: LIST
26969: PUSH
26970: EMPTY
26971: LIST
26972: LIST
26973: PPUSH
26974: CALL_OW 69
26978: ST_TO_ADDR
// if not tmp then
26979: LD_VAR 0 1
26983: NOT
26984: IFFALSE 26988
// exit ;
26986: GO 27104
// for i in tmp do
26988: LD_ADDR_VAR 0 2
26992: PUSH
26993: LD_VAR 0 1
26997: PUSH
26998: FOR_IN
26999: IFFALSE 27102
// if See ( 1 , i ) then
27001: LD_INT 1
27003: PPUSH
27004: LD_VAR 0 2
27008: PPUSH
27009: CALL_OW 292
27013: IFFALSE 27100
// begin if GetType ( i ) = unit_building then
27015: LD_VAR 0 2
27019: PPUSH
27020: CALL_OW 247
27024: PUSH
27025: LD_INT 3
27027: EQUAL
27028: IFFALSE 27066
// begin CenterNowOnUnits ( i ) ;
27030: LD_VAR 0 2
27034: PPUSH
27035: CALL_OW 87
// Say ( JMM , D17a-JMM-1 ) ;
27039: LD_EXP 36
27043: PPUSH
27044: LD_STRING D17a-JMM-1
27046: PPUSH
27047: CALL_OW 88
// seeBehemoth := true ;
27051: LD_ADDR_EXP 29
27055: PUSH
27056: LD_INT 1
27058: ST_TO_ADDR
// disable ;
27059: DISABLE
// exit ;
27060: POP
27061: POP
27062: GO 27104
// end else
27064: GO 27100
// begin CenterNowOnUnits ( i ) ;
27066: LD_VAR 0 2
27070: PPUSH
27071: CALL_OW 87
// Say ( JMM , D17b-JMM-1 ) ;
27075: LD_EXP 36
27079: PPUSH
27080: LD_STRING D17b-JMM-1
27082: PPUSH
27083: CALL_OW 88
// seeBehemoth := true ;
27087: LD_ADDR_EXP 29
27091: PUSH
27092: LD_INT 1
27094: ST_TO_ADDR
// disable ;
27095: DISABLE
// exit ;
27096: POP
27097: POP
27098: GO 27104
// end ; end ;
27100: GO 26998
27102: POP
27103: POP
// end ;
27104: PPOPN 2
27106: END
// every 0 0$1 trigger missionTime >= 55 55$30 do var bomb , dec , tmp ;
27107: LD_EXP 14
27111: PUSH
27112: LD_INT 116550
27114: GREATEREQUAL
27115: IFFALSE 28291
27117: GO 27119
27119: DISABLE
27120: LD_INT 0
27122: PPUSH
27123: PPUSH
27124: PPUSH
// begin MC_InsertProduceList ( 2 , [ [ ru_heavy_wheeled , engine_siberite , control_computer , ru_siberium_rocket ] ] ) ;
27125: LD_INT 2
27127: PPUSH
27128: LD_INT 23
27130: PUSH
27131: LD_INT 3
27133: PUSH
27134: LD_INT 3
27136: PUSH
27137: LD_INT 48
27139: PUSH
27140: EMPTY
27141: LIST
27142: LIST
27143: LIST
27144: LIST
27145: PUSH
27146: EMPTY
27147: LIST
27148: PPUSH
27149: CALL 57717 0 2
// repeat wait ( 0 0$1 ) ;
27153: LD_INT 35
27155: PPUSH
27156: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) ;
27160: LD_INT 22
27162: PUSH
27163: LD_INT 3
27165: PUSH
27166: EMPTY
27167: LIST
27168: LIST
27169: PUSH
27170: LD_INT 34
27172: PUSH
27173: LD_INT 48
27175: PUSH
27176: EMPTY
27177: LIST
27178: LIST
27179: PUSH
27180: EMPTY
27181: LIST
27182: LIST
27183: PPUSH
27184: CALL_OW 69
27188: IFFALSE 27153
// bomb := FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] ;
27190: LD_ADDR_VAR 0 1
27194: PUSH
27195: LD_INT 22
27197: PUSH
27198: LD_INT 3
27200: PUSH
27201: EMPTY
27202: LIST
27203: LIST
27204: PUSH
27205: LD_INT 34
27207: PUSH
27208: LD_INT 48
27210: PUSH
27211: EMPTY
27212: LIST
27213: LIST
27214: PUSH
27215: EMPTY
27216: LIST
27217: LIST
27218: PPUSH
27219: CALL_OW 69
27223: PUSH
27224: LD_INT 1
27226: ARRAY
27227: ST_TO_ADDR
// missionStage := 12 ;
27228: LD_ADDR_EXP 15
27232: PUSH
27233: LD_INT 12
27235: ST_TO_ADDR
// platonovHasBomb := true ;
27236: LD_ADDR_EXP 30
27240: PUSH
27241: LD_INT 1
27243: ST_TO_ADDR
// AddComMoveXY ( bomb , 181 , 86 ) ;
27244: LD_VAR 0 1
27248: PPUSH
27249: LD_INT 181
27251: PPUSH
27252: LD_INT 86
27254: PPUSH
27255: CALL_OW 171
// AddComHold ( bomb ) ;
27259: LD_VAR 0 1
27263: PPUSH
27264: CALL_OW 200
// wait ( 0 0$10 ) ;
27268: LD_INT 350
27270: PPUSH
27271: CALL_OW 67
// DialogueOn ;
27275: CALL_OW 6
// SayRadio ( Platonov , D15-Pla-1 ) ;
27279: LD_EXP 61
27283: PPUSH
27284: LD_STRING D15-Pla-1
27286: PPUSH
27287: CALL_OW 94
// dec = Query ( Q15a ) ;
27291: LD_ADDR_VAR 0 2
27295: PUSH
27296: LD_STRING Q15a
27298: PPUSH
27299: CALL_OW 97
27303: ST_TO_ADDR
// if dec = 1 then
27304: LD_VAR 0 2
27308: PUSH
27309: LD_INT 1
27311: EQUAL
27312: IFFALSE 27335
// begin Say ( JMM , D15a-JMM-1 ) ;
27314: LD_EXP 36
27318: PPUSH
27319: LD_STRING D15a-JMM-1
27321: PPUSH
27322: CALL_OW 88
// YouLost ( Surrender ) ;
27326: LD_STRING Surrender
27328: PPUSH
27329: CALL_OW 104
// exit ;
27333: GO 28291
// end ; if dec = 2 then
27335: LD_VAR 0 2
27339: PUSH
27340: LD_INT 2
27342: EQUAL
27343: IFFALSE 27412
// begin Say ( JMM , D15b-JMM-1 ) ;
27345: LD_EXP 36
27349: PPUSH
27350: LD_STRING D15b-JMM-1
27352: PPUSH
27353: CALL_OW 88
// SayRadio ( Platonov , D15b-Pla-1 ) ;
27357: LD_EXP 61
27361: PPUSH
27362: LD_STRING D15b-Pla-1
27364: PPUSH
27365: CALL_OW 94
// DialogueOff ;
27369: CALL_OW 7
// wait ( 3 3$00 ) ;
27373: LD_INT 6300
27375: PPUSH
27376: CALL_OW 67
// DialogueOn ;
27380: CALL_OW 6
// Say ( JMM , D15d-JMM-1a ) ;
27384: LD_EXP 36
27388: PPUSH
27389: LD_STRING D15d-JMM-1a
27391: PPUSH
27392: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27396: LD_EXP 61
27400: PPUSH
27401: LD_STRING D15d-Pla-1
27403: PPUSH
27404: CALL_OW 94
// DialogueOff ;
27408: CALL_OW 7
// end ; if dec = 3 then
27412: LD_VAR 0 2
27416: PUSH
27417: LD_INT 3
27419: EQUAL
27420: IFFALSE 27474
// begin Say ( JMM , D15c-JMM-1 ) ;
27422: LD_EXP 36
27426: PPUSH
27427: LD_STRING D15c-JMM-1
27429: PPUSH
27430: CALL_OW 88
// SayRadio ( Platonov , D15c-Pla-1 ) ;
27434: LD_EXP 61
27438: PPUSH
27439: LD_STRING D15c-Pla-1
27441: PPUSH
27442: CALL_OW 94
// DialogueOff ;
27446: CALL_OW 7
// wait ( 0 0$15 ) ;
27450: LD_INT 525
27452: PPUSH
27453: CALL_OW 67
// ComAttackPlace ( bomb , 60 , 95 ) ;
27457: LD_VAR 0 1
27461: PPUSH
27462: LD_INT 60
27464: PPUSH
27465: LD_INT 95
27467: PPUSH
27468: CALL_OW 116
// exit ;
27472: GO 28291
// end ; if dec = 4 then
27474: LD_VAR 0 2
27478: PUSH
27479: LD_INT 4
27481: EQUAL
27482: IFFALSE 27512
// begin Say ( JMM , D15d-JMM-1 ) ;
27484: LD_EXP 36
27488: PPUSH
27489: LD_STRING D15d-JMM-1
27491: PPUSH
27492: CALL_OW 88
// SayRadio ( Platonov , D15d-Pla-1 ) ;
27496: LD_EXP 61
27500: PPUSH
27501: LD_STRING D15d-Pla-1
27503: PPUSH
27504: CALL_OW 94
// DialogueOff ;
27508: CALL_OW 7
// end ; if IsOk ( Friend ) and GetSide ( Friend ) = 1 and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27512: LD_EXP 59
27516: PPUSH
27517: CALL_OW 302
27521: PUSH
27522: LD_EXP 59
27526: PPUSH
27527: CALL_OW 255
27531: PUSH
27532: LD_INT 1
27534: EQUAL
27535: AND
27536: PUSH
27537: LD_INT 22
27539: PUSH
27540: LD_INT 1
27542: PUSH
27543: EMPTY
27544: LIST
27545: LIST
27546: PUSH
27547: LD_INT 34
27549: PUSH
27550: LD_INT 8
27552: PUSH
27553: EMPTY
27554: LIST
27555: LIST
27556: PUSH
27557: EMPTY
27558: LIST
27559: LIST
27560: PPUSH
27561: CALL_OW 69
27565: NOT
27566: AND
27567: IFFALSE 28192
// begin SetSide ( Friend , 8 ) ;
27569: LD_EXP 59
27573: PPUSH
27574: LD_INT 8
27576: PPUSH
27577: CALL_OW 235
// if IsInUnit ( Friend ) then
27581: LD_EXP 59
27585: PPUSH
27586: CALL_OW 310
27590: IFFALSE 27601
// ComExitBuilding ( Friend ) ;
27592: LD_EXP 59
27596: PPUSH
27597: CALL_OW 122
// if IsDriver ( Friend ) then
27601: LD_EXP 59
27605: PPUSH
27606: CALL 104557 0 1
27610: IFFALSE 27621
// ComExitVehicle ( Friend ) ;
27612: LD_EXP 59
27616: PPUSH
27617: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27621: LD_EXP 59
27625: PPUSH
27626: LD_INT 9
27628: PPUSH
27629: LD_INT 2
27631: PPUSH
27632: CALL_OW 171
// wait ( 0 0$05 ) ;
27636: LD_INT 175
27638: PPUSH
27639: CALL_OW 67
// CenterNowOnUnits ( Friend ) ;
27643: LD_EXP 59
27647: PPUSH
27648: CALL_OW 87
// DialogueOn ;
27652: CALL_OW 6
// Say ( JMM , D16-JMM-1 ) ;
27656: LD_EXP 36
27660: PPUSH
27661: LD_STRING D16-JMM-1
27663: PPUSH
27664: CALL_OW 88
// Say ( Friend , D16-Friend-1 ) ;
27668: LD_EXP 59
27672: PPUSH
27673: LD_STRING D16-Friend-1
27675: PPUSH
27676: CALL_OW 88
// Say ( JMM , D16-JMM-2 ) ;
27680: LD_EXP 36
27684: PPUSH
27685: LD_STRING D16-JMM-2
27687: PPUSH
27688: CALL_OW 88
// DialogueOff ;
27692: CALL_OW 7
// SetSide ( Friend , 1 ) ;
27696: LD_EXP 59
27700: PPUSH
27701: LD_INT 1
27703: PPUSH
27704: CALL_OW 235
// ComHold ( Friend ) ;
27708: LD_EXP 59
27712: PPUSH
27713: CALL_OW 140
// wait ( 0 0$20 ) ;
27717: LD_INT 700
27719: PPUSH
27720: CALL_OW 67
// if GetDistUnitXY ( Friend , 9 , 2 ) < 30 then
27724: LD_EXP 59
27728: PPUSH
27729: LD_INT 9
27731: PPUSH
27732: LD_INT 2
27734: PPUSH
27735: CALL_OW 297
27739: PUSH
27740: LD_INT 30
27742: LESS
27743: IFFALSE 27812
// begin SetSide ( Friend , 8 ) ;
27745: LD_EXP 59
27749: PPUSH
27750: LD_INT 8
27752: PPUSH
27753: CALL_OW 235
// if IsInUnit ( Friend ) then
27757: LD_EXP 59
27761: PPUSH
27762: CALL_OW 310
27766: IFFALSE 27777
// ComExitBuilding ( Friend ) ;
27768: LD_EXP 59
27772: PPUSH
27773: CALL_OW 122
// if IsDriver ( Friend ) then
27777: LD_EXP 59
27781: PPUSH
27782: CALL 104557 0 1
27786: IFFALSE 27797
// ComExitVehicle ( Friend ) ;
27788: LD_EXP 59
27792: PPUSH
27793: CALL_OW 121
// AddComMoveXY ( Friend , 9 , 2 ) ;
27797: LD_EXP 59
27801: PPUSH
27802: LD_INT 9
27804: PPUSH
27805: LD_INT 2
27807: PPUSH
27808: CALL_OW 171
// end ; wait ( 0 0$30 ) ;
27812: LD_INT 1050
27814: PPUSH
27815: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
27819: LD_INT 22
27821: PUSH
27822: LD_INT 1
27824: PUSH
27825: EMPTY
27826: LIST
27827: LIST
27828: PUSH
27829: LD_INT 34
27831: PUSH
27832: LD_INT 8
27834: PUSH
27835: EMPTY
27836: LIST
27837: LIST
27838: PUSH
27839: EMPTY
27840: LIST
27841: LIST
27842: PPUSH
27843: CALL_OW 69
27847: NOT
27848: IFFALSE 28170
// begin tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_not , [ f_class , class_apeman ] , [ f_class , class_apeman_engineer ] ] ] ) diff [ JMM , Stevens , Baker , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
27850: LD_ADDR_VAR 0 3
27854: PUSH
27855: LD_INT 22
27857: PUSH
27858: LD_INT 1
27860: PUSH
27861: EMPTY
27862: LIST
27863: LIST
27864: PUSH
27865: LD_INT 26
27867: PUSH
27868: LD_INT 1
27870: PUSH
27871: EMPTY
27872: LIST
27873: LIST
27874: PUSH
27875: LD_INT 3
27877: PUSH
27878: LD_INT 25
27880: PUSH
27881: LD_INT 12
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 25
27890: PUSH
27891: LD_INT 16
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: LIST
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: LIST
27907: PPUSH
27908: CALL_OW 69
27912: PUSH
27913: LD_EXP 36
27917: PUSH
27918: LD_EXP 38
27922: PUSH
27923: LD_EXP 52
27927: PUSH
27928: LD_EXP 39
27932: PUSH
27933: LD_EXP 40
27937: PUSH
27938: LD_EXP 41
27942: PUSH
27943: LD_EXP 42
27947: PUSH
27948: LD_EXP 43
27952: PUSH
27953: LD_EXP 44
27957: PUSH
27958: LD_EXP 45
27962: PUSH
27963: LD_EXP 46
27967: PUSH
27968: LD_EXP 47
27972: PUSH
27973: LD_EXP 48
27977: PUSH
27978: LD_EXP 49
27982: PUSH
27983: LD_EXP 50
27987: PUSH
27988: EMPTY
27989: LIST
27990: LIST
27991: LIST
27992: LIST
27993: LIST
27994: LIST
27995: LIST
27996: LIST
27997: LIST
27998: LIST
27999: LIST
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: DIFF
28005: ST_TO_ADDR
// DialogueOn ;
28006: CALL_OW 6
// SayRadio ( Platonov , D16a-Pla-1 ) ;
28010: LD_EXP 61
28014: PPUSH
28015: LD_STRING D16a-Pla-1
28017: PPUSH
28018: CALL_OW 94
// if Stevens then
28022: LD_EXP 38
28026: IFFALSE 28042
// Say ( Stevens , D16a-Huck-1 ) else
28028: LD_EXP 38
28032: PPUSH
28033: LD_STRING D16a-Huck-1
28035: PPUSH
28036: CALL_OW 88
28040: GO 28084
// if Baker then
28042: LD_EXP 52
28046: IFFALSE 28062
// Say ( Baker , D16a-Huck-1 ) else
28048: LD_EXP 52
28052: PPUSH
28053: LD_STRING D16a-Huck-1
28055: PPUSH
28056: CALL_OW 88
28060: GO 28084
// if tmp then
28062: LD_VAR 0 3
28066: IFFALSE 28084
// Say ( tmp [ 1 ] , D16a-Sol1-1 ) ;
28068: LD_VAR 0 3
28072: PUSH
28073: LD_INT 1
28075: ARRAY
28076: PPUSH
28077: LD_STRING D16a-Sol1-1
28079: PPUSH
28080: CALL_OW 88
// if GetSide ( Friend ) = 8 then
28084: LD_EXP 59
28088: PPUSH
28089: CALL_OW 255
28093: PUSH
28094: LD_INT 8
28096: EQUAL
28097: IFFALSE 28113
// Say ( JMM , D16a-JMM-1 ) else
28099: LD_EXP 36
28103: PPUSH
28104: LD_STRING D16a-JMM-1
28106: PPUSH
28107: CALL_OW 88
28111: GO 28149
// begin Say ( JMM , D16a-JMM-1a ) ;
28113: LD_EXP 36
28117: PPUSH
28118: LD_STRING D16a-JMM-1a
28120: PPUSH
28121: CALL_OW 88
// Say ( Friend , D16a-Friend-1 ) ;
28125: LD_EXP 59
28129: PPUSH
28130: LD_STRING D16a-Friend-1
28132: PPUSH
28133: CALL_OW 88
// SetSide ( Friend , 3 ) ;
28137: LD_EXP 59
28141: PPUSH
28142: LD_INT 3
28144: PPUSH
28145: CALL_OW 235
// end ; DialogueOff ;
28149: CALL_OW 7
// ComAttackPlace ( bomb , 60 , 95 ) ;
28153: LD_VAR 0 1
28157: PPUSH
28158: LD_INT 60
28160: PPUSH
28161: LD_INT 95
28163: PPUSH
28164: CALL_OW 116
// end else
28168: GO 28190
// begin DialogueOn ;
28170: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28174: LD_EXP 61
28178: PPUSH
28179: LD_STRING D16c-Pla-
28181: PPUSH
28182: CALL_OW 94
// DialogueOff ;
28186: CALL_OW 7
// end ; end else
28190: GO 28291
// begin wait ( 3 3$00 ) ;
28192: LD_INT 6300
28194: PPUSH
28195: CALL_OW 67
// if not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
28199: LD_INT 22
28201: PUSH
28202: LD_INT 1
28204: PUSH
28205: EMPTY
28206: LIST
28207: LIST
28208: PUSH
28209: LD_INT 34
28211: PUSH
28212: LD_INT 8
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: EMPTY
28220: LIST
28221: LIST
28222: PPUSH
28223: CALL_OW 69
28227: NOT
28228: IFFALSE 28271
// begin SayRadio ( Platonov , D16b-Pla-1 ) ;
28230: LD_EXP 61
28234: PPUSH
28235: LD_STRING D16b-Pla-1
28237: PPUSH
28238: CALL_OW 94
// Say ( JMM , D16b-JMM- ) ;
28242: LD_EXP 36
28246: PPUSH
28247: LD_STRING D16b-JMM-
28249: PPUSH
28250: CALL_OW 88
// ComAttackPlace ( bomb , 60 , 95 ) ;
28254: LD_VAR 0 1
28258: PPUSH
28259: LD_INT 60
28261: PPUSH
28262: LD_INT 95
28264: PPUSH
28265: CALL_OW 116
// end else
28269: GO 28291
// begin DialogueOn ;
28271: CALL_OW 6
// SayRadio ( Platonov , D16c-Pla- ) ;
28275: LD_EXP 61
28279: PPUSH
28280: LD_STRING D16c-Pla-
28282: PPUSH
28283: CALL_OW 94
// DialogueOff ;
28287: CALL_OW 7
// end ; end ; end ;
28291: PPOPN 3
28293: END
// every 0 0$1 trigger missionTime >= 60 60$00 and not allianceDestroyed and IsOk ( Roth ) do var dec ;
28294: LD_EXP 14
28298: PUSH
28299: LD_INT 126000
28301: GREATEREQUAL
28302: PUSH
28303: LD_EXP 23
28307: NOT
28308: AND
28309: PUSH
28310: LD_EXP 71
28314: PPUSH
28315: CALL_OW 302
28319: AND
28320: IFFALSE 28678
28322: GO 28324
28324: DISABLE
28325: LD_INT 0
28327: PPUSH
// begin missionStage = 11 ;
28328: LD_ADDR_EXP 15
28332: PUSH
28333: LD_INT 11
28335: ST_TO_ADDR
// DialogueOn ;
28336: CALL_OW 6
// SayRadio ( Roth , D9-Roth-1 ) ;
28340: LD_EXP 71
28344: PPUSH
28345: LD_STRING D9-Roth-1
28347: PPUSH
28348: CALL_OW 94
// Say ( JMM , D9-JMM-1 ) ;
28352: LD_EXP 36
28356: PPUSH
28357: LD_STRING D9-JMM-1
28359: PPUSH
28360: CALL_OW 88
// SayRadio ( Roth , D9-Roth-2 ) ;
28364: LD_EXP 71
28368: PPUSH
28369: LD_STRING D9-Roth-2
28371: PPUSH
28372: CALL_OW 94
// SayRadio ( Roth , D9-Roth-2a ) ;
28376: LD_EXP 71
28380: PPUSH
28381: LD_STRING D9-Roth-2a
28383: PPUSH
28384: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-2 ) ;
28388: LD_EXP 61
28392: PPUSH
28393: LD_STRING D9-Pla-2
28395: PPUSH
28396: CALL_OW 94
// SayRadio ( Roth , D9-Roth-3 ) ;
28400: LD_EXP 71
28404: PPUSH
28405: LD_STRING D9-Roth-3
28407: PPUSH
28408: CALL_OW 94
// SayRadio ( Platonov , D9-Pla-3 ) ;
28412: LD_EXP 61
28416: PPUSH
28417: LD_STRING D9-Pla-3
28419: PPUSH
28420: CALL_OW 94
// SayRadio ( Roth , D9-Roth-4 ) ;
28424: LD_EXP 71
28428: PPUSH
28429: LD_STRING D9-Roth-4
28431: PPUSH
28432: CALL_OW 94
// dec = Query ( Q9 ) ;
28436: LD_ADDR_VAR 0 1
28440: PUSH
28441: LD_STRING Q9
28443: PPUSH
28444: CALL_OW 97
28448: ST_TO_ADDR
// if dec = 1 then
28449: LD_VAR 0 1
28453: PUSH
28454: LD_INT 1
28456: EQUAL
28457: IFFALSE 28471
// SayRadio ( Roth , D9a-Roth-1 ) ;
28459: LD_EXP 71
28463: PPUSH
28464: LD_STRING D9a-Roth-1
28466: PPUSH
28467: CALL_OW 94
// if dec = 2 then
28471: LD_VAR 0 1
28475: PUSH
28476: LD_INT 2
28478: EQUAL
28479: IFFALSE 28505
// begin Say ( JMM , D9b-JMM-1 ) ;
28481: LD_EXP 36
28485: PPUSH
28486: LD_STRING D9b-JMM-1
28488: PPUSH
28489: CALL_OW 88
// SayRadio ( Roth , D9b-Roth-1 ) ;
28493: LD_EXP 71
28497: PPUSH
28498: LD_STRING D9b-Roth-1
28500: PPUSH
28501: CALL_OW 94
// end ; if dec = 3 then
28505: LD_VAR 0 1
28509: PUSH
28510: LD_INT 3
28512: EQUAL
28513: IFFALSE 28575
// begin Say ( JMM , D9c-JMM-1 ) ;
28515: LD_EXP 36
28519: PPUSH
28520: LD_STRING D9c-JMM-1
28522: PPUSH
28523: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-1 ) ;
28527: LD_EXP 71
28531: PPUSH
28532: LD_STRING D9c-Roth-1
28534: PPUSH
28535: CALL_OW 94
// Say ( JMM , D9c-JMM-2 ) ;
28539: LD_EXP 36
28543: PPUSH
28544: LD_STRING D9c-JMM-2
28546: PPUSH
28547: CALL_OW 88
// SayRadio ( Roth , D9c-Roth-2 ) ;
28551: LD_EXP 71
28555: PPUSH
28556: LD_STRING D9c-Roth-2
28558: PPUSH
28559: CALL_OW 94
// Say ( JMM , D9c-JMM-3 ) ;
28563: LD_EXP 36
28567: PPUSH
28568: LD_STRING D9c-JMM-3
28570: PPUSH
28571: CALL_OW 88
// end ; SayRadio ( Roth , D9c-Roth-3 ) ;
28575: LD_EXP 71
28579: PPUSH
28580: LD_STRING D9c-Roth-3
28582: PPUSH
28583: CALL_OW 94
// SayRadio ( Roth , D9cont-Roth-1 ) ;
28587: LD_EXP 71
28591: PPUSH
28592: LD_STRING D9cont-Roth-1
28594: PPUSH
28595: CALL_OW 94
// Say ( JMM , D9cont-JMM-1 ) ;
28599: LD_EXP 36
28603: PPUSH
28604: LD_STRING D9cont-JMM-1
28606: PPUSH
28607: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-2 ) ;
28611: LD_EXP 71
28615: PPUSH
28616: LD_STRING D9cont-Roth-2
28618: PPUSH
28619: CALL_OW 94
// Say ( JMM , D9cont-JMM-2 ) ;
28623: LD_EXP 36
28627: PPUSH
28628: LD_STRING D9cont-JMM-2
28630: PPUSH
28631: CALL_OW 88
// SayRadio ( Roth , D9cont-Roth-3 ) ;
28635: LD_EXP 71
28639: PPUSH
28640: LD_STRING D9cont-Roth-3
28642: PPUSH
28643: CALL_OW 94
// Say ( JMM , D9cont-JMM-3 ) ;
28647: LD_EXP 36
28651: PPUSH
28652: LD_STRING D9cont-JMM-3
28654: PPUSH
28655: CALL_OW 88
// DialogueOff ;
28659: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
28663: LD_STRING M3
28665: PPUSH
28666: CALL_OW 337
// allianceActive := true ;
28670: LD_ADDR_EXP 31
28674: PUSH
28675: LD_INT 1
28677: ST_TO_ADDR
// end ;
28678: PPOPN 1
28680: END
// every 0 0$2 trigger IsDead ( Platonov ) and IsDead ( Yakotich ) and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_ok ] ] ) < [ 7 , 8 , 9 ] [ Difficulty ] do var i , tmp , tmp2 , omarOnMotherLode ;
28681: LD_EXP 61
28685: PPUSH
28686: CALL_OW 301
28690: PUSH
28691: LD_EXP 64
28695: PPUSH
28696: CALL_OW 301
28700: AND
28701: PUSH
28702: LD_INT 22
28704: PUSH
28705: LD_INT 3
28707: PUSH
28708: EMPTY
28709: LIST
28710: LIST
28711: PUSH
28712: LD_INT 21
28714: PUSH
28715: LD_INT 1
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 50
28724: PUSH
28725: EMPTY
28726: LIST
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: LIST
28732: PPUSH
28733: CALL_OW 69
28737: PUSH
28738: LD_INT 7
28740: PUSH
28741: LD_INT 8
28743: PUSH
28744: LD_INT 9
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: LIST
28751: PUSH
28752: LD_OWVAR 67
28756: ARRAY
28757: LESS
28758: AND
28759: IFFALSE 29530
28761: GO 28763
28763: DISABLE
28764: LD_INT 0
28766: PPUSH
28767: PPUSH
28768: PPUSH
28769: PPUSH
// begin MC_Kill ( 1 ) ;
28770: LD_INT 1
28772: PPUSH
28773: CALL 34153 0 1
// SetAttitude ( 1 , 3 , att_friend , true ) ;
28777: LD_INT 1
28779: PPUSH
28780: LD_INT 3
28782: PPUSH
28783: LD_INT 1
28785: PPUSH
28786: LD_INT 1
28788: PPUSH
28789: CALL_OW 80
// for i in FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] , [ f_lives , 900 ] ] ) do
28793: LD_ADDR_VAR 0 1
28797: PUSH
28798: LD_INT 22
28800: PUSH
28801: LD_INT 3
28803: PUSH
28804: EMPTY
28805: LIST
28806: LIST
28807: PUSH
28808: LD_INT 21
28810: PUSH
28811: LD_INT 1
28813: PUSH
28814: EMPTY
28815: LIST
28816: LIST
28817: PUSH
28818: LD_INT 24
28820: PUSH
28821: LD_INT 900
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: LIST
28832: PPUSH
28833: CALL_OW 69
28837: PUSH
28838: FOR_IN
28839: IFFALSE 28870
// if GetSex ( i ) = sex_male then
28841: LD_VAR 0 1
28845: PPUSH
28846: CALL_OW 258
28850: PUSH
28851: LD_INT 1
28853: EQUAL
28854: IFFALSE 28868
// begin tmp = i ;
28856: LD_ADDR_VAR 0 2
28860: PUSH
28861: LD_VAR 0 1
28865: ST_TO_ADDR
// break ;
28866: GO 28870
// end ;
28868: GO 28838
28870: POP
28871: POP
// if tmp = 0 then
28872: LD_VAR 0 2
28876: PUSH
28877: LD_INT 0
28879: EQUAL
28880: IFFALSE 28934
// begin uc_side = 3 ;
28882: LD_ADDR_OWVAR 20
28886: PUSH
28887: LD_INT 3
28889: ST_TO_ADDR
// uc_nation = 3 ;
28890: LD_ADDR_OWVAR 21
28894: PUSH
28895: LD_INT 3
28897: ST_TO_ADDR
// hc_name =  ;
28898: LD_ADDR_OWVAR 26
28902: PUSH
28903: LD_STRING 
28905: ST_TO_ADDR
// hc_gallery =  ;
28906: LD_ADDR_OWVAR 33
28910: PUSH
28911: LD_STRING 
28913: ST_TO_ADDR
// PrepareSoldier ( sex_male , 10 ) ;
28914: LD_INT 1
28916: PPUSH
28917: LD_INT 10
28919: PPUSH
28920: CALL_OW 381
// tmp = CreateHuman ;
28924: LD_ADDR_VAR 0 2
28928: PUSH
28929: CALL_OW 44
28933: ST_TO_ADDR
// end ; DialogueOn ;
28934: CALL_OW 6
// Say ( tmp , DSurrenderRussians-RSol1-1a ) ;
28938: LD_VAR 0 2
28942: PPUSH
28943: LD_STRING DSurrenderRussians-RSol1-1a
28945: PPUSH
28946: CALL_OW 88
// DialogueOff ;
28950: CALL_OW 7
// russianDestroyed := true ;
28954: LD_ADDR_EXP 21
28958: PUSH
28959: LD_INT 1
28961: ST_TO_ADDR
// ComExitBuilding ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) ) ;
28962: LD_INT 22
28964: PUSH
28965: LD_INT 3
28967: PUSH
28968: EMPTY
28969: LIST
28970: LIST
28971: PUSH
28972: LD_INT 21
28974: PUSH
28975: LD_INT 1
28977: PUSH
28978: EMPTY
28979: LIST
28980: LIST
28981: PUSH
28982: EMPTY
28983: LIST
28984: LIST
28985: PPUSH
28986: CALL_OW 69
28990: PPUSH
28991: CALL_OW 122
// wait ( 0 0$1 ) ;
28995: LD_INT 35
28997: PPUSH
28998: CALL_OW 67
// AddComMoveToArea ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) , russianEscapeArea ) ;
29002: LD_INT 22
29004: PUSH
29005: LD_INT 3
29007: PUSH
29008: EMPTY
29009: LIST
29010: LIST
29011: PUSH
29012: LD_INT 21
29014: PUSH
29015: LD_INT 1
29017: PUSH
29018: EMPTY
29019: LIST
29020: LIST
29021: PUSH
29022: EMPTY
29023: LIST
29024: LIST
29025: PPUSH
29026: CALL_OW 69
29030: PPUSH
29031: LD_INT 25
29033: PPUSH
29034: CALL_OW 173
// wait ( 0 0$10 ) ;
29038: LD_INT 350
29040: PPUSH
29041: CALL_OW 67
// PrepareOmarInvasion ;
29045: CALL 13710 0 0
// tmp := [ GetX ( Omar ) , GetY ( Omar ) ] ;
29049: LD_ADDR_VAR 0 2
29053: PUSH
29054: LD_EXP 89
29058: PPUSH
29059: CALL_OW 250
29063: PUSH
29064: LD_EXP 89
29068: PPUSH
29069: CALL_OW 251
29073: PUSH
29074: EMPTY
29075: LIST
29076: LIST
29077: ST_TO_ADDR
// PlaceSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 , - 8 ) ;
29078: LD_VAR 0 2
29082: PUSH
29083: LD_INT 1
29085: ARRAY
29086: PPUSH
29087: LD_VAR 0 2
29091: PUSH
29092: LD_INT 2
29094: ARRAY
29095: PPUSH
29096: LD_INT 1
29098: PPUSH
29099: LD_INT 8
29101: NEG
29102: PPUSH
29103: CALL_OW 330
// CenterNowOnUnits ( Omar ) ;
29107: LD_EXP 89
29111: PPUSH
29112: CALL_OW 87
// DialogueOn ;
29116: CALL_OW 6
// Say ( JMM , D19-JMM-1 ) ;
29120: LD_EXP 36
29124: PPUSH
29125: LD_STRING D19-JMM-1
29127: PPUSH
29128: CALL_OW 88
// tmp2 := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex_male ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Joan , Stevens , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Connie , Baker ] ;
29132: LD_ADDR_VAR 0 3
29136: PUSH
29137: LD_INT 22
29139: PUSH
29140: LD_INT 1
29142: PUSH
29143: EMPTY
29144: LIST
29145: LIST
29146: PUSH
29147: LD_INT 26
29149: PUSH
29150: LD_INT 1
29152: PUSH
29153: EMPTY
29154: LIST
29155: LIST
29156: PUSH
29157: LD_INT 2
29159: PUSH
29160: LD_INT 25
29162: PUSH
29163: LD_INT 1
29165: PUSH
29166: EMPTY
29167: LIST
29168: LIST
29169: PUSH
29170: LD_INT 25
29172: PUSH
29173: LD_INT 2
29175: PUSH
29176: EMPTY
29177: LIST
29178: LIST
29179: PUSH
29180: LD_INT 25
29182: PUSH
29183: LD_INT 3
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 25
29192: PUSH
29193: LD_INT 4
29195: PUSH
29196: EMPTY
29197: LIST
29198: LIST
29199: PUSH
29200: LD_INT 25
29202: PUSH
29203: LD_INT 5
29205: PUSH
29206: EMPTY
29207: LIST
29208: LIST
29209: PUSH
29210: LD_INT 25
29212: PUSH
29213: LD_INT 8
29215: PUSH
29216: EMPTY
29217: LIST
29218: LIST
29219: PUSH
29220: EMPTY
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: LIST
29226: LIST
29227: LIST
29228: PUSH
29229: EMPTY
29230: LIST
29231: LIST
29232: LIST
29233: PPUSH
29234: CALL_OW 69
29238: PUSH
29239: LD_EXP 36
29243: PUSH
29244: LD_EXP 37
29248: PUSH
29249: LD_EXP 38
29253: PUSH
29254: LD_EXP 39
29258: PUSH
29259: LD_EXP 40
29263: PUSH
29264: LD_EXP 41
29268: PUSH
29269: LD_EXP 42
29273: PUSH
29274: LD_EXP 43
29278: PUSH
29279: LD_EXP 44
29283: PUSH
29284: LD_EXP 45
29288: PUSH
29289: LD_EXP 46
29293: PUSH
29294: LD_EXP 47
29298: PUSH
29299: LD_EXP 48
29303: PUSH
29304: LD_EXP 49
29308: PUSH
29309: LD_EXP 50
29313: PUSH
29314: LD_EXP 51
29318: PUSH
29319: LD_EXP 52
29323: PUSH
29324: EMPTY
29325: LIST
29326: LIST
29327: LIST
29328: LIST
29329: LIST
29330: LIST
29331: LIST
29332: LIST
29333: LIST
29334: LIST
29335: LIST
29336: LIST
29337: LIST
29338: LIST
29339: LIST
29340: LIST
29341: LIST
29342: DIFF
29343: ST_TO_ADDR
// if tmp2 then
29344: LD_VAR 0 3
29348: IFFALSE 29366
// Say ( tmp2 [ 1 ] , D19-Sol1-1 ) ;
29350: LD_VAR 0 3
29354: PUSH
29355: LD_INT 1
29357: ARRAY
29358: PPUSH
29359: LD_STRING D19-Sol1-1
29361: PPUSH
29362: CALL_OW 88
// Say ( JMM , D19-JMM-2 ) ;
29366: LD_EXP 36
29370: PPUSH
29371: LD_STRING D19-JMM-2
29373: PPUSH
29374: CALL_OW 88
// DialogueOff ;
29378: CALL_OW 7
// RemoveSeeing ( tmp [ 1 ] , tmp [ 2 ] , 1 ) ;
29382: LD_VAR 0 2
29386: PUSH
29387: LD_INT 1
29389: ARRAY
29390: PPUSH
29391: LD_VAR 0 2
29395: PUSH
29396: LD_INT 2
29398: ARRAY
29399: PPUSH
29400: LD_INT 1
29402: PPUSH
29403: CALL_OW 331
// ChangeMissionObjectives ( M5 ) ;
29407: LD_STRING M5
29409: PPUSH
29410: CALL_OW 337
// omarOnMotherLode := false ;
29414: LD_ADDR_VAR 0 4
29418: PUSH
29419: LD_INT 0
29421: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
29422: LD_INT 35
29424: PPUSH
29425: CALL_OW 67
// if GetDistUnitXY ( Omar , 215 , 100 ) < 10 and not omarOnMotherLode then
29429: LD_EXP 89
29433: PPUSH
29434: LD_INT 215
29436: PPUSH
29437: LD_INT 100
29439: PPUSH
29440: CALL_OW 297
29444: PUSH
29445: LD_INT 10
29447: LESS
29448: PUSH
29449: LD_VAR 0 4
29453: NOT
29454: AND
29455: IFFALSE 29489
// begin omarOnMotherLode := true ;
29457: LD_ADDR_VAR 0 4
29461: PUSH
29462: LD_INT 1
29464: ST_TO_ADDR
// Say ( JMM , D19b-JMM-1 ) ;
29465: LD_EXP 36
29469: PPUSH
29470: LD_STRING D19b-JMM-1
29472: PPUSH
29473: CALL_OW 88
// Say ( Omar , DOmarContam-Omar-1 ) ;
29477: LD_EXP 89
29481: PPUSH
29482: LD_STRING DOmarContam-Omar-1
29484: PPUSH
29485: CALL_OW 88
// end ; until IsDead ( Omar ) ;
29489: LD_EXP 89
29493: PPUSH
29494: CALL_OW 301
29498: IFFALSE 29422
// Say ( JMM , D19a-JMM-1 ) ;
29500: LD_EXP 36
29504: PPUSH
29505: LD_STRING D19a-JMM-1
29507: PPUSH
29508: CALL_OW 88
// if Heike then
29512: LD_EXP 90
29516: IFFALSE 29530
// Say ( Heike , D19a-Hke-1 ) ;
29518: LD_EXP 90
29522: PPUSH
29523: LD_STRING D19a-Hke-1
29525: PPUSH
29526: CALL_OW 88
// end ;
29530: PPOPN 4
29532: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) and russianDestroyed do var i , tmp ;
29533: LD_INT 22
29535: PUSH
29536: LD_INT 3
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: PUSH
29543: LD_INT 21
29545: PUSH
29546: LD_INT 1
29548: PUSH
29549: EMPTY
29550: LIST
29551: LIST
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PPUSH
29557: CALL_OW 69
29561: PUSH
29562: LD_EXP 21
29566: AND
29567: IFFALSE 29635
29569: GO 29571
29571: DISABLE
29572: LD_INT 0
29574: PPUSH
29575: PPUSH
// begin enable ;
29576: ENABLE
// tmp := FilterUnitsInArea ( russianEscapeArea , [ f_side , 3 ] ) ;
29577: LD_ADDR_VAR 0 2
29581: PUSH
29582: LD_INT 25
29584: PPUSH
29585: LD_INT 22
29587: PUSH
29588: LD_INT 3
29590: PUSH
29591: EMPTY
29592: LIST
29593: LIST
29594: PPUSH
29595: CALL_OW 70
29599: ST_TO_ADDR
// if not tmp then
29600: LD_VAR 0 2
29604: NOT
29605: IFFALSE 29609
// exit ;
29607: GO 29635
// for i in tmp do
29609: LD_ADDR_VAR 0 1
29613: PUSH
29614: LD_VAR 0 2
29618: PUSH
29619: FOR_IN
29620: IFFALSE 29633
// RemoveUnit ( i ) ;
29622: LD_VAR 0 1
29626: PPUSH
29627: CALL_OW 64
29631: GO 29619
29633: POP
29634: POP
// end ;
29635: PPOPN 2
29637: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) < 6 do var tmp , i ;
29638: LD_INT 22
29640: PUSH
29641: LD_INT 7
29643: PUSH
29644: EMPTY
29645: LIST
29646: LIST
29647: PUSH
29648: LD_INT 21
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: EMPTY
29655: LIST
29656: LIST
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PPUSH
29662: CALL_OW 69
29666: PUSH
29667: LD_INT 6
29669: LESS
29670: IFFALSE 30121
29672: GO 29674
29674: DISABLE
29675: LD_INT 0
29677: PPUSH
29678: PPUSH
// begin MC_Kill ( 1 ) ;
29679: LD_INT 1
29681: PPUSH
29682: CALL 34153 0 1
// SetAttitude ( 7 , 1 , att_friend , true ) ;
29686: LD_INT 7
29688: PPUSH
29689: LD_INT 1
29691: PPUSH
29692: LD_INT 1
29694: PPUSH
29695: LD_INT 1
29697: PPUSH
29698: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_sex , sex_male ] ] ) diff Roth ;
29702: LD_ADDR_VAR 0 1
29706: PUSH
29707: LD_INT 22
29709: PUSH
29710: LD_INT 7
29712: PUSH
29713: EMPTY
29714: LIST
29715: LIST
29716: PUSH
29717: LD_INT 26
29719: PUSH
29720: LD_INT 1
29722: PUSH
29723: EMPTY
29724: LIST
29725: LIST
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PPUSH
29731: CALL_OW 69
29735: PUSH
29736: LD_EXP 71
29740: DIFF
29741: ST_TO_ADDR
// if tmp then
29742: LD_VAR 0 1
29746: IFFALSE 29764
// tmp := tmp [ 1 ] else
29748: LD_ADDR_VAR 0 1
29752: PUSH
29753: LD_VAR 0 1
29757: PUSH
29758: LD_INT 1
29760: ARRAY
29761: ST_TO_ADDR
29762: GO 29800
// begin uc_side := 7 ;
29764: LD_ADDR_OWVAR 20
29768: PUSH
29769: LD_INT 7
29771: ST_TO_ADDR
// uc_nation := 1 ;
29772: LD_ADDR_OWVAR 21
29776: PUSH
29777: LD_INT 1
29779: ST_TO_ADDR
// PrepareScientist ( sex_male , 8 ) ;
29780: LD_INT 1
29782: PPUSH
29783: LD_INT 8
29785: PPUSH
29786: CALL_OW 384
// tmp := CreateHuman ;
29790: LD_ADDR_VAR 0 1
29794: PUSH
29795: CALL_OW 44
29799: ST_TO_ADDR
// end ; DialogueOn ;
29800: CALL_OW 6
// if IsOK ( Roth ) then
29804: LD_EXP 71
29808: PPUSH
29809: CALL_OW 302
29813: IFFALSE 29827
// Say ( JMM , DAb-JMM-1 ) ;
29815: LD_EXP 36
29819: PPUSH
29820: LD_STRING DAb-JMM-1
29822: PPUSH
29823: CALL_OW 88
// if IsOK ( Roth ) then
29827: LD_EXP 71
29831: PPUSH
29832: CALL_OW 302
29836: IFFALSE 29860
// begin Say ( Roth , DSurrenderAlliance-Roth-1 ) ;
29838: LD_EXP 71
29842: PPUSH
29843: LD_STRING DSurrenderAlliance-Roth-1
29845: PPUSH
29846: CALL_OW 88
// RothCaptured := true ;
29850: LD_ADDR_EXP 33
29854: PUSH
29855: LD_INT 1
29857: ST_TO_ADDR
// end else
29858: GO 29872
// Say ( tmp , DSurrenderAlliance-Sci1-1 ) ;
29860: LD_VAR 0 1
29864: PPUSH
29865: LD_STRING DSurrenderAlliance-Sci1-1
29867: PPUSH
29868: CALL_OW 88
// DialogueOff ;
29872: CALL_OW 7
// allianceDestroyed := true ;
29876: LD_ADDR_EXP 23
29880: PUSH
29881: LD_INT 1
29883: ST_TO_ADDR
// if trueAmericans then
29884: LD_EXP 35
29888: IFFALSE 29964
// begin if trueAmericans = 1 then
29890: LD_EXP 35
29894: PUSH
29895: LD_INT 1
29897: EQUAL
29898: IFFALSE 29914
// Say ( JMM , DAb-JMM-1a ) else
29900: LD_EXP 36
29904: PPUSH
29905: LD_STRING DAb-JMM-1a
29907: PPUSH
29908: CALL_OW 88
29912: GO 29926
// Say ( JMM , DAb-JMM-1b ) ;
29914: LD_EXP 36
29918: PPUSH
29919: LD_STRING DAb-JMM-1b
29921: PPUSH
29922: CALL_OW 88
// CenterNowOnUnits ( trueAmericans ) ;
29926: LD_EXP 35
29930: PPUSH
29931: CALL_OW 87
// for i in trueAmericans do
29935: LD_ADDR_VAR 0 2
29939: PUSH
29940: LD_EXP 35
29944: PUSH
29945: FOR_IN
29946: IFFALSE 29962
// SetSide ( i , 1 ) ;
29948: LD_VAR 0 2
29952: PPUSH
29953: LD_INT 1
29955: PPUSH
29956: CALL_OW 235
29960: GO 29945
29962: POP
29963: POP
// end ; repeat wait ( 0 0$1 ) ;
29964: LD_INT 35
29966: PPUSH
29967: CALL_OW 67
// for i in FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) do
29971: LD_ADDR_VAR 0 2
29975: PUSH
29976: LD_INT 22
29978: PUSH
29979: LD_INT 7
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: LD_INT 21
29988: PUSH
29989: LD_INT 1
29991: PUSH
29992: EMPTY
29993: LIST
29994: LIST
29995: PUSH
29996: EMPTY
29997: LIST
29998: LIST
29999: PPUSH
30000: CALL_OW 69
30004: PUSH
30005: FOR_IN
30006: IFFALSE 30088
// begin if IsInUnit ( i ) then
30008: LD_VAR 0 2
30012: PPUSH
30013: CALL_OW 310
30017: IFFALSE 30028
// ComExitBuilding ( i ) ;
30019: LD_VAR 0 2
30023: PPUSH
30024: CALL_OW 122
// if IsDriver ( i ) then
30028: LD_VAR 0 2
30032: PPUSH
30033: CALL 104557 0 1
30037: IFFALSE 30048
// ComExitVehicle ( i ) ;
30039: LD_VAR 0 2
30043: PPUSH
30044: CALL_OW 121
// if not IsInArea ( i , allianceEscapeArea ) then
30048: LD_VAR 0 2
30052: PPUSH
30053: LD_INT 26
30055: PPUSH
30056: CALL_OW 308
30060: NOT
30061: IFFALSE 30077
// AddComMoveToArea ( i , allianceEscapeArea ) else
30063: LD_VAR 0 2
30067: PPUSH
30068: LD_INT 26
30070: PPUSH
30071: CALL_OW 173
30075: GO 30086
// RemoveUnit ( i ) ;
30077: LD_VAR 0 2
30081: PPUSH
30082: CALL_OW 64
// end ;
30086: GO 30005
30088: POP
30089: POP
// until not FilterAllUnits ( [ [ f_side , 7 ] , [ f_type , unit_human ] ] ) ;
30090: LD_INT 22
30092: PUSH
30093: LD_INT 7
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: LD_INT 21
30102: PUSH
30103: LD_INT 1
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: PUSH
30110: EMPTY
30111: LIST
30112: LIST
30113: PPUSH
30114: CALL_OW 69
30118: NOT
30119: IFFALSE 29964
// end ;
30121: PPOPN 2
30123: END
// export function AllianceCaptureUnit ( unit ) ; var join ; begin
30124: LD_INT 0
30126: PPUSH
30127: PPUSH
// if not unit then
30128: LD_VAR 0 1
30132: NOT
30133: IFFALSE 30137
// exit ;
30135: GO 31635
// DoNotAttack ( 7 , unit ) ;
30137: LD_INT 7
30139: PPUSH
30140: LD_VAR 0 1
30144: PPUSH
30145: CALL_OW 471
// TeleportUnit ( unit , 260 , 235 , 3 , true ) ;
30149: LD_VAR 0 1
30153: PPUSH
30154: LD_INT 260
30156: PPUSH
30157: LD_INT 235
30159: PPUSH
30160: LD_INT 3
30162: PPUSH
30163: LD_INT 1
30165: PPUSH
30166: CALL_OW 483
// SetSide ( unit , 4 ) ;
30170: LD_VAR 0 1
30174: PPUSH
30175: LD_INT 4
30177: PPUSH
30178: CALL_OW 235
// capturedUnit := capturedUnit + 1 ;
30182: LD_ADDR_EXP 34
30186: PUSH
30187: LD_EXP 34
30191: PUSH
30192: LD_INT 1
30194: PLUS
30195: ST_TO_ADDR
// wait ( 0 0$2 ) ;
30196: LD_INT 70
30198: PPUSH
30199: CALL_OW 67
// PlaceSeeing ( 260 , 235 , 1 , - 8 ) ;
30203: LD_INT 260
30205: PPUSH
30206: LD_INT 235
30208: PPUSH
30209: LD_INT 1
30211: PPUSH
30212: LD_INT 8
30214: NEG
30215: PPUSH
30216: CALL_OW 330
// CenterNowOnUnits ( unit ) ;
30220: LD_VAR 0 1
30224: PPUSH
30225: CALL_OW 87
// ComTurnUnit ( unit , Roth ) ;
30229: LD_VAR 0 1
30233: PPUSH
30234: LD_EXP 71
30238: PPUSH
30239: CALL_OW 119
// DialogueOn ;
30243: CALL_OW 6
// case unit of JMM :
30247: LD_VAR 0 1
30251: PUSH
30252: LD_EXP 36
30256: DOUBLE
30257: EQUAL
30258: IFTRUE 30262
30260: GO 30277
30262: POP
// ForceSay ( JMM , DA1-JMM-1 ) ; Joan :
30263: LD_EXP 36
30267: PPUSH
30268: LD_STRING DA1-JMM-1
30270: PPUSH
30271: CALL_OW 91
30275: GO 30719
30277: LD_EXP 37
30281: DOUBLE
30282: EQUAL
30283: IFTRUE 30287
30285: GO 30302
30287: POP
// ForceSay ( Joan , DA1-Joan-1 ) ; Lisa :
30288: LD_EXP 37
30292: PPUSH
30293: LD_STRING DA1-Joan-1
30295: PPUSH
30296: CALL_OW 91
30300: GO 30719
30302: LD_EXP 39
30306: DOUBLE
30307: EQUAL
30308: IFTRUE 30312
30310: GO 30327
30312: POP
// ForceSay ( Lisa , DA1-Lisa-1 ) ; Donaldson :
30313: LD_EXP 39
30317: PPUSH
30318: LD_STRING DA1-Lisa-1
30320: PPUSH
30321: CALL_OW 91
30325: GO 30719
30327: LD_EXP 40
30331: DOUBLE
30332: EQUAL
30333: IFTRUE 30337
30335: GO 30352
30337: POP
// ForceSay ( Donaldson , DA1-Don-1 ) ; Cornel :
30338: LD_EXP 40
30342: PPUSH
30343: LD_STRING DA1-Don-1
30345: PPUSH
30346: CALL_OW 91
30350: GO 30719
30352: LD_EXP 47
30356: DOUBLE
30357: EQUAL
30358: IFTRUE 30362
30360: GO 30377
30362: POP
// ForceSay ( Cornel , DA1-Corn-1 ) ; Denis :
30363: LD_EXP 47
30367: PPUSH
30368: LD_STRING DA1-Corn-1
30370: PPUSH
30371: CALL_OW 91
30375: GO 30719
30377: LD_EXP 43
30381: DOUBLE
30382: EQUAL
30383: IFTRUE 30387
30385: GO 30402
30387: POP
// ForceSay ( Denis , DA1-Den-1 ) ; Bobby :
30388: LD_EXP 43
30392: PPUSH
30393: LD_STRING DA1-Den-1
30395: PPUSH
30396: CALL_OW 91
30400: GO 30719
30402: LD_EXP 41
30406: DOUBLE
30407: EQUAL
30408: IFTRUE 30412
30410: GO 30427
30412: POP
// ForceSay ( Bobby , DA1-Bobby-1 ) ; Gladstone :
30413: LD_EXP 41
30417: PPUSH
30418: LD_STRING DA1-Bobby-1
30420: PPUSH
30421: CALL_OW 91
30425: GO 30719
30427: LD_EXP 45
30431: DOUBLE
30432: EQUAL
30433: IFTRUE 30437
30435: GO 30452
30437: POP
// ForceSay ( Gladstone , DA1-Glad-1 ) ; Cyrus :
30438: LD_EXP 45
30442: PPUSH
30443: LD_STRING DA1-Glad-1
30445: PPUSH
30446: CALL_OW 91
30450: GO 30719
30452: LD_EXP 42
30456: DOUBLE
30457: EQUAL
30458: IFTRUE 30462
30460: GO 30477
30462: POP
// ForceSay ( Cyrus , DA1-Cyrus-1 ) ; Stevens :
30463: LD_EXP 42
30467: PPUSH
30468: LD_STRING DA1-Cyrus-1
30470: PPUSH
30471: CALL_OW 91
30475: GO 30719
30477: LD_EXP 38
30481: DOUBLE
30482: EQUAL
30483: IFTRUE 30487
30485: GO 30502
30487: POP
// ForceSay ( Stevens , DA1-Huck-1 ) ; Baker :
30488: LD_EXP 38
30492: PPUSH
30493: LD_STRING DA1-Huck-1
30495: PPUSH
30496: CALL_OW 91
30500: GO 30719
30502: LD_EXP 52
30506: DOUBLE
30507: EQUAL
30508: IFTRUE 30512
30510: GO 30527
30512: POP
// ForceSay ( Baker , DA1-Huck-1 ) ; Brown :
30513: LD_EXP 52
30517: PPUSH
30518: LD_STRING DA1-Huck-1
30520: PPUSH
30521: CALL_OW 91
30525: GO 30719
30527: LD_EXP 44
30531: DOUBLE
30532: EQUAL
30533: IFTRUE 30537
30535: GO 30552
30537: POP
// ForceSay ( Brown , DA1-Brown-1 ) ; Gary :
30538: LD_EXP 44
30542: PPUSH
30543: LD_STRING DA1-Brown-1
30545: PPUSH
30546: CALL_OW 91
30550: GO 30719
30552: LD_EXP 48
30556: DOUBLE
30557: EQUAL
30558: IFTRUE 30562
30560: GO 30577
30562: POP
// ForceSay ( Gary , DA1-Gary-1 ) ; Connie :
30563: LD_EXP 48
30567: PPUSH
30568: LD_STRING DA1-Gary-1
30570: PPUSH
30571: CALL_OW 91
30575: GO 30719
30577: LD_EXP 51
30581: DOUBLE
30582: EQUAL
30583: IFTRUE 30587
30585: GO 30602
30587: POP
// ForceSay ( Connie , DA1-Con-1 ) ; Kurt :
30588: LD_EXP 51
30592: PPUSH
30593: LD_STRING DA1-Con-1
30595: PPUSH
30596: CALL_OW 91
30600: GO 30719
30602: LD_EXP 57
30606: DOUBLE
30607: EQUAL
30608: IFTRUE 30612
30610: GO 30627
30612: POP
// ForceSay ( Kurt , DA1-Kurt-1 ) ; Kikuchi :
30613: LD_EXP 57
30617: PPUSH
30618: LD_STRING DA1-Kurt-1
30620: PPUSH
30621: CALL_OW 91
30625: GO 30719
30627: LD_EXP 50
30631: DOUBLE
30632: EQUAL
30633: IFTRUE 30637
30635: GO 30652
30637: POP
// ForceSay ( Kikuchi , DA1-Yam-1 ) ; Frank :
30638: LD_EXP 50
30642: PPUSH
30643: LD_STRING DA1-Yam-1
30645: PPUSH
30646: CALL_OW 91
30650: GO 30719
30652: LD_EXP 49
30656: DOUBLE
30657: EQUAL
30658: IFTRUE 30662
30660: GO 30677
30662: POP
// ForceSay ( Frank , DA1-Frank-1 ) ; else
30663: LD_EXP 49
30667: PPUSH
30668: LD_STRING DA1-Frank-1
30670: PPUSH
30671: CALL_OW 91
30675: GO 30719
30677: POP
// begin if GetSex ( unit ) = sex_male then
30678: LD_VAR 0 1
30682: PPUSH
30683: CALL_OW 258
30687: PUSH
30688: LD_INT 1
30690: EQUAL
30691: IFFALSE 30707
// ForceSay ( unit , DA1-Sol1-1 ) else
30693: LD_VAR 0 1
30697: PPUSH
30698: LD_STRING DA1-Sol1-1
30700: PPUSH
30701: CALL_OW 91
30705: GO 30719
// ForceSay ( unit , DA1-FSol1-1 ) ;
30707: LD_VAR 0 1
30711: PPUSH
30712: LD_STRING DA1-FSol1-1
30714: PPUSH
30715: CALL_OW 91
// end ; end ; Say ( Roth , DA-Roth-1 ) ;
30719: LD_EXP 71
30723: PPUSH
30724: LD_STRING DA-Roth-1
30726: PPUSH
30727: CALL_OW 88
// if capturedUnit = 1 then
30731: LD_EXP 34
30735: PUSH
30736: LD_INT 1
30738: EQUAL
30739: IFFALSE 30767
// begin Say ( Simms , DA-Sim-1 ) ;
30741: LD_EXP 72
30745: PPUSH
30746: LD_STRING DA-Sim-1
30748: PPUSH
30749: CALL_OW 88
// Say ( Roth , DA-Roth-2 ) ;
30753: LD_EXP 71
30757: PPUSH
30758: LD_STRING DA-Roth-2
30760: PPUSH
30761: CALL_OW 88
// end else
30765: GO 30779
// Say ( Simms , DA-Sim-2 ) ;
30767: LD_EXP 72
30771: PPUSH
30772: LD_STRING DA-Sim-2
30774: PPUSH
30775: CALL_OW 88
// case unit of JMM :
30779: LD_VAR 0 1
30783: PUSH
30784: LD_EXP 36
30788: DOUBLE
30789: EQUAL
30790: IFTRUE 30794
30792: GO 30809
30794: POP
// ForceSay ( JMM , DA1-JMM-1a ) ; Joan :
30795: LD_EXP 36
30799: PPUSH
30800: LD_STRING DA1-JMM-1a
30802: PPUSH
30803: CALL_OW 91
30807: GO 31316
30809: LD_EXP 37
30813: DOUBLE
30814: EQUAL
30815: IFTRUE 30819
30817: GO 30834
30819: POP
// ForceSay ( Joan , DA1-Joan-1a ) ; Lisa :
30820: LD_EXP 37
30824: PPUSH
30825: LD_STRING DA1-Joan-1a
30827: PPUSH
30828: CALL_OW 91
30832: GO 31316
30834: LD_EXP 39
30838: DOUBLE
30839: EQUAL
30840: IFTRUE 30844
30842: GO 30859
30844: POP
// ForceSay ( Lisa , DA1-Lisa-1a ) ; Donaldson :
30845: LD_EXP 39
30849: PPUSH
30850: LD_STRING DA1-Lisa-1a
30852: PPUSH
30853: CALL_OW 91
30857: GO 31316
30859: LD_EXP 40
30863: DOUBLE
30864: EQUAL
30865: IFTRUE 30869
30867: GO 30884
30869: POP
// ForceSay ( Donaldson , DA1-Don-1a ) ; Cornel :
30870: LD_EXP 40
30874: PPUSH
30875: LD_STRING DA1-Don-1a
30877: PPUSH
30878: CALL_OW 91
30882: GO 31316
30884: LD_EXP 47
30888: DOUBLE
30889: EQUAL
30890: IFTRUE 30894
30892: GO 30909
30894: POP
// ForceSay ( Cornel , DA1-Corn-1a ) ; Denis :
30895: LD_EXP 47
30899: PPUSH
30900: LD_STRING DA1-Corn-1a
30902: PPUSH
30903: CALL_OW 91
30907: GO 31316
30909: LD_EXP 43
30913: DOUBLE
30914: EQUAL
30915: IFTRUE 30919
30917: GO 30934
30919: POP
// ForceSay ( Denis , DA1-Den-1a ) ; Bobby :
30920: LD_EXP 43
30924: PPUSH
30925: LD_STRING DA1-Den-1a
30927: PPUSH
30928: CALL_OW 91
30932: GO 31316
30934: LD_EXP 41
30938: DOUBLE
30939: EQUAL
30940: IFTRUE 30944
30942: GO 30959
30944: POP
// ForceSay ( Bobby , DA1-Bobby-1a ) ; Gladstone :
30945: LD_EXP 41
30949: PPUSH
30950: LD_STRING DA1-Bobby-1a
30952: PPUSH
30953: CALL_OW 91
30957: GO 31316
30959: LD_EXP 45
30963: DOUBLE
30964: EQUAL
30965: IFTRUE 30969
30967: GO 30984
30969: POP
// ForceSay ( Gladstone , DA1-Glad-1a ) ; Cyrus :
30970: LD_EXP 45
30974: PPUSH
30975: LD_STRING DA1-Glad-1a
30977: PPUSH
30978: CALL_OW 91
30982: GO 31316
30984: LD_EXP 42
30988: DOUBLE
30989: EQUAL
30990: IFTRUE 30994
30992: GO 31009
30994: POP
// ForceSay ( Cyrus , DA1-Cyrus-1a ) ; Stevens :
30995: LD_EXP 42
30999: PPUSH
31000: LD_STRING DA1-Cyrus-1a
31002: PPUSH
31003: CALL_OW 91
31007: GO 31316
31009: LD_EXP 38
31013: DOUBLE
31014: EQUAL
31015: IFTRUE 31019
31017: GO 31034
31019: POP
// ForceSay ( Stevens , DA1-Huck-1a ) ; Baker :
31020: LD_EXP 38
31024: PPUSH
31025: LD_STRING DA1-Huck-1a
31027: PPUSH
31028: CALL_OW 91
31032: GO 31316
31034: LD_EXP 52
31038: DOUBLE
31039: EQUAL
31040: IFTRUE 31044
31042: GO 31059
31044: POP
// ForceSay ( Baker , DA1-Huck-1a ) ; Brown :
31045: LD_EXP 52
31049: PPUSH
31050: LD_STRING DA1-Huck-1a
31052: PPUSH
31053: CALL_OW 91
31057: GO 31316
31059: LD_EXP 44
31063: DOUBLE
31064: EQUAL
31065: IFTRUE 31069
31067: GO 31084
31069: POP
// ForceSay ( Brown , DA1-Brown-1a ) ; Gary :
31070: LD_EXP 44
31074: PPUSH
31075: LD_STRING DA1-Brown-1a
31077: PPUSH
31078: CALL_OW 91
31082: GO 31316
31084: LD_EXP 48
31088: DOUBLE
31089: EQUAL
31090: IFTRUE 31094
31092: GO 31109
31094: POP
// ForceSay ( Gary , DA1-Gary-1a ) ; Connie :
31095: LD_EXP 48
31099: PPUSH
31100: LD_STRING DA1-Gary-1a
31102: PPUSH
31103: CALL_OW 91
31107: GO 31316
31109: LD_EXP 51
31113: DOUBLE
31114: EQUAL
31115: IFTRUE 31119
31117: GO 31134
31119: POP
// ForceSay ( Connie , DA1-Con-1a ) ; Kurt :
31120: LD_EXP 51
31124: PPUSH
31125: LD_STRING DA1-Con-1a
31127: PPUSH
31128: CALL_OW 91
31132: GO 31316
31134: LD_EXP 57
31138: DOUBLE
31139: EQUAL
31140: IFTRUE 31144
31142: GO 31159
31144: POP
// ForceSay ( Kurt , DA1-Kurt-1a ) ; Kikuchi :
31145: LD_EXP 57
31149: PPUSH
31150: LD_STRING DA1-Kurt-1a
31152: PPUSH
31153: CALL_OW 91
31157: GO 31316
31159: LD_EXP 50
31163: DOUBLE
31164: EQUAL
31165: IFTRUE 31169
31167: GO 31184
31169: POP
// ForceSay ( Kikuchi , DA1-Yam-1a ) ; Frank :
31170: LD_EXP 50
31174: PPUSH
31175: LD_STRING DA1-Yam-1a
31177: PPUSH
31178: CALL_OW 91
31182: GO 31316
31184: LD_EXP 49
31188: DOUBLE
31189: EQUAL
31190: IFTRUE 31194
31192: GO 31209
31194: POP
// ForceSay ( Frank , DA1-Frank-1a ) ; else
31195: LD_EXP 49
31199: PPUSH
31200: LD_STRING DA1-Frank-1a
31202: PPUSH
31203: CALL_OW 91
31207: GO 31316
31209: POP
// begin join := rand ( 0 , 1 ) ;
31210: LD_ADDR_VAR 0 3
31214: PUSH
31215: LD_INT 0
31217: PPUSH
31218: LD_INT 1
31220: PPUSH
31221: CALL_OW 12
31225: ST_TO_ADDR
// if join then
31226: LD_VAR 0 3
31230: IFFALSE 31275
// begin if GetSex ( unit ) = sex_male then
31232: LD_VAR 0 1
31236: PPUSH
31237: CALL_OW 258
31241: PUSH
31242: LD_INT 1
31244: EQUAL
31245: IFFALSE 31261
// ForceSay ( unit , DA1-Sol1-1b ) else
31247: LD_VAR 0 1
31251: PPUSH
31252: LD_STRING DA1-Sol1-1b
31254: PPUSH
31255: CALL_OW 91
31259: GO 31273
// ForceSay ( unit , DA1-FSol1-1b ) ;
31261: LD_VAR 0 1
31265: PPUSH
31266: LD_STRING DA1-FSol1-1b
31268: PPUSH
31269: CALL_OW 91
// end else
31273: GO 31316
// begin if GetSex ( unit ) = sex_male then
31275: LD_VAR 0 1
31279: PPUSH
31280: CALL_OW 258
31284: PUSH
31285: LD_INT 1
31287: EQUAL
31288: IFFALSE 31304
// ForceSay ( unit , DA1-Sol1-1a ) else
31290: LD_VAR 0 1
31294: PPUSH
31295: LD_STRING DA1-Sol1-1a
31297: PPUSH
31298: CALL_OW 91
31302: GO 31316
// ForceSay ( unit , DA1-FSol1-1a ) ;
31304: LD_VAR 0 1
31308: PPUSH
31309: LD_STRING DA1-FSol1-1a
31311: PPUSH
31312: CALL_OW 91
// end ; end ; end ; if unit = JMM then
31316: LD_VAR 0 1
31320: PUSH
31321: LD_EXP 36
31325: EQUAL
31326: IFFALSE 31337
// begin YouLost ( JMMCaptured ) ;
31328: LD_STRING JMMCaptured
31330: PPUSH
31331: CALL_OW 104
// exit ;
31335: GO 31635
// end ; if unit in [ Donaldson , Denis , Bobby , Stevens , Baker , Brown , Kikuchi ] or join then
31337: LD_VAR 0 1
31341: PUSH
31342: LD_EXP 40
31346: PUSH
31347: LD_EXP 43
31351: PUSH
31352: LD_EXP 41
31356: PUSH
31357: LD_EXP 38
31361: PUSH
31362: LD_EXP 52
31366: PUSH
31367: LD_EXP 44
31371: PUSH
31372: LD_EXP 50
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: IN
31386: PUSH
31387: LD_VAR 0 3
31391: OR
31392: IFFALSE 31491
// begin Say ( Roth , DA-Roth-3 ) ;
31394: LD_EXP 71
31398: PPUSH
31399: LD_STRING DA-Roth-3
31401: PPUSH
31402: CALL_OW 88
// SetSide ( unit , 7 ) ;
31406: LD_VAR 0 1
31410: PPUSH
31411: LD_INT 7
31413: PPUSH
31414: CALL_OW 235
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] ^ unit ) ;
31418: LD_ADDR_EXP 99
31422: PUSH
31423: LD_EXP 99
31427: PPUSH
31428: LD_INT 1
31430: PPUSH
31431: LD_EXP 99
31435: PUSH
31436: LD_INT 1
31438: ARRAY
31439: PUSH
31440: LD_VAR 0 1
31444: ADD
31445: PPUSH
31446: CALL_OW 1
31450: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31451: LD_INT 260
31453: PPUSH
31454: LD_INT 235
31456: PPUSH
31457: LD_INT 1
31459: PPUSH
31460: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31464: LD_VAR 0 1
31468: PPUSH
31469: LD_INT 1000
31471: PPUSH
31472: CALL_OW 234
// DialogueOff ;
31476: CALL_OW 7
// ComFree ( unit ) ;
31480: LD_VAR 0 1
31484: PPUSH
31485: CALL_OW 139
// end else
31489: GO 31572
// begin Say ( Roth , DA-Roth-3a ) ;
31491: LD_EXP 71
31495: PPUSH
31496: LD_STRING DA-Roth-3a
31498: PPUSH
31499: CALL_OW 88
// trueAmericans := trueAmericans ^ unit ;
31503: LD_ADDR_EXP 35
31507: PUSH
31508: LD_EXP 35
31512: PUSH
31513: LD_VAR 0 1
31517: ADD
31518: ST_TO_ADDR
// RemoveSeeing ( 260 , 235 , 1 ) ;
31519: LD_INT 260
31521: PPUSH
31522: LD_INT 235
31524: PPUSH
31525: LD_INT 1
31527: PPUSH
31528: CALL_OW 331
// SetLives ( unit , 1000 ) ;
31532: LD_VAR 0 1
31536: PPUSH
31537: LD_INT 1000
31539: PPUSH
31540: CALL_OW 234
// DialogueOff ;
31544: CALL_OW 7
// ComMoveXY ( unit , 272 , 254 ) ;
31548: LD_VAR 0 1
31552: PPUSH
31553: LD_INT 272
31555: PPUSH
31556: LD_INT 254
31558: PPUSH
31559: CALL_OW 111
// AddComHold ( unit ) ;
31563: LD_VAR 0 1
31567: PPUSH
31568: CALL_OW 200
// end ; if capturedUnit = 1 then
31572: LD_EXP 34
31576: PUSH
31577: LD_INT 1
31579: EQUAL
31580: IFFALSE 31635
// begin DialogueOn ;
31582: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
31586: LD_EXP 36
31590: PPUSH
31591: CALL_OW 87
// Say ( JMM , DAa-JMM-1 ) ;
31595: LD_EXP 36
31599: PPUSH
31600: LD_STRING DAa-JMM-1
31602: PPUSH
31603: CALL_OW 88
// Say ( JMM , DAa-JMM-1a ) ;
31607: LD_EXP 36
31611: PPUSH
31612: LD_STRING DAa-JMM-1a
31614: PPUSH
31615: CALL_OW 88
// Say ( JMM , DAa-JMM-1b ) ;
31619: LD_EXP 36
31623: PPUSH
31624: LD_STRING DAa-JMM-1b
31626: PPUSH
31627: CALL_OW 88
// DialogueOff ;
31631: CALL_OW 7
// end ; end ;
31635: LD_VAR 0 2
31639: RET
// every 0 0$1 trigger missionStage >= 13 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_ok ] ] ) = 0 and russianDestroyed and legionDestroyed and allianceDestroyed do var m1 , m2 , m3 ;
31640: LD_EXP 15
31644: PUSH
31645: LD_INT 13
31647: GREATEREQUAL
31648: PUSH
31649: LD_INT 22
31651: PUSH
31652: LD_INT 2
31654: PUSH
31655: EMPTY
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 21
31661: PUSH
31662: LD_INT 1
31664: PUSH
31665: EMPTY
31666: LIST
31667: LIST
31668: PUSH
31669: EMPTY
31670: LIST
31671: LIST
31672: PPUSH
31673: CALL_OW 69
31677: PUSH
31678: LD_INT 0
31680: EQUAL
31681: AND
31682: PUSH
31683: LD_INT 22
31685: PUSH
31686: LD_INT 2
31688: PUSH
31689: EMPTY
31690: LIST
31691: LIST
31692: PUSH
31693: LD_INT 21
31695: PUSH
31696: LD_INT 2
31698: PUSH
31699: EMPTY
31700: LIST
31701: LIST
31702: PUSH
31703: LD_INT 50
31705: PUSH
31706: EMPTY
31707: LIST
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: LIST
31713: PPUSH
31714: CALL_OW 69
31718: PUSH
31719: LD_INT 0
31721: EQUAL
31722: AND
31723: PUSH
31724: LD_EXP 21
31728: AND
31729: PUSH
31730: LD_EXP 22
31734: AND
31735: PUSH
31736: LD_EXP 23
31740: AND
31741: IFFALSE 32345
31743: GO 31745
31745: DISABLE
31746: LD_INT 0
31748: PPUSH
31749: PPUSH
31750: PPUSH
// begin m1 := false ;
31751: LD_ADDR_VAR 0 1
31755: PUSH
31756: LD_INT 0
31758: ST_TO_ADDR
// m2 := false ;
31759: LD_ADDR_VAR 0 2
31763: PUSH
31764: LD_INT 0
31766: ST_TO_ADDR
// m3 := false ;
31767: LD_ADDR_VAR 0 3
31771: PUSH
31772: LD_INT 0
31774: ST_TO_ADDR
// CenterNowOnUnits ( JMM ) ;
31775: LD_EXP 36
31779: PPUSH
31780: CALL_OW 87
// music_class := 5 ;
31784: LD_ADDR_OWVAR 72
31788: PUSH
31789: LD_INT 5
31791: ST_TO_ADDR
// music_nat := 5 ;
31792: LD_ADDR_OWVAR 71
31796: PUSH
31797: LD_INT 5
31799: ST_TO_ADDR
// DialogueOn ;
31800: CALL_OW 6
// Say ( JMM , D20-JMM-1 ) ;
31804: LD_EXP 36
31808: PPUSH
31809: LD_STRING D20-JMM-1
31811: PPUSH
31812: CALL_OW 88
// if IsOK ( Joan ) then
31816: LD_EXP 37
31820: PPUSH
31821: CALL_OW 302
31825: IFFALSE 31839
// Say ( Joan , D20-Joan-1 ) ;
31827: LD_EXP 37
31831: PPUSH
31832: LD_STRING D20-Joan-1
31834: PPUSH
31835: CALL_OW 88
// if IsOk ( Lisa ) then
31839: LD_EXP 39
31843: PPUSH
31844: CALL_OW 302
31848: IFFALSE 31862
// Say ( Lisa , D20-Lisa-1 ) ;
31850: LD_EXP 39
31854: PPUSH
31855: LD_STRING D20-Lisa-1
31857: PPUSH
31858: CALL_OW 88
// if IsOk ( Donaldson ) then
31862: LD_EXP 40
31866: PPUSH
31867: CALL_OW 302
31871: IFFALSE 31885
// Say ( Donaldson , D20-Don-1 ) ;
31873: LD_EXP 40
31877: PPUSH
31878: LD_STRING D20-Don-1
31880: PPUSH
31881: CALL_OW 88
// if IsOK ( Cornel ) then
31885: LD_EXP 47
31889: PPUSH
31890: CALL_OW 302
31894: IFFALSE 31908
// Say ( Cornel , D20-Corn-1 ) ;
31896: LD_EXP 47
31900: PPUSH
31901: LD_STRING D20-Corn-1
31903: PPUSH
31904: CALL_OW 88
// if IsOk ( Denis ) then
31908: LD_EXP 43
31912: PPUSH
31913: CALL_OW 302
31917: IFFALSE 31931
// Say ( Denis , D20-Den-1 ) ;
31919: LD_EXP 43
31923: PPUSH
31924: LD_STRING D20-Den-1
31926: PPUSH
31927: CALL_OW 88
// if IsOk ( Bobby ) then
31931: LD_EXP 41
31935: PPUSH
31936: CALL_OW 302
31940: IFFALSE 31954
// Say ( Bobby , D20-Bobby-1 ) ;
31942: LD_EXP 41
31946: PPUSH
31947: LD_STRING D20-Bobby-1
31949: PPUSH
31950: CALL_OW 88
// if IsOk ( Gladstone ) then
31954: LD_EXP 45
31958: PPUSH
31959: CALL_OW 302
31963: IFFALSE 31977
// Say ( Gladstone , D20-Glad-1 ) ;
31965: LD_EXP 45
31969: PPUSH
31970: LD_STRING D20-Glad-1
31972: PPUSH
31973: CALL_OW 88
// if IsOk ( Cyrus ) then
31977: LD_EXP 42
31981: PPUSH
31982: CALL_OW 302
31986: IFFALSE 32000
// Say ( Cyrus , D20-Cyrus-1 ) ;
31988: LD_EXP 42
31992: PPUSH
31993: LD_STRING D20-Cyrus-1
31995: PPUSH
31996: CALL_OW 88
// if IsOk ( Stevens ) then
32000: LD_EXP 38
32004: PPUSH
32005: CALL_OW 302
32009: IFFALSE 32023
// Say ( Stevens , D20-Huck-1 ) ;
32011: LD_EXP 38
32015: PPUSH
32016: LD_STRING D20-Huck-1
32018: PPUSH
32019: CALL_OW 88
// if IsOk ( Brown ) then
32023: LD_EXP 44
32027: PPUSH
32028: CALL_OW 302
32032: IFFALSE 32046
// Say ( Brown , D20-Brown-1 ) ;
32034: LD_EXP 44
32038: PPUSH
32039: LD_STRING D20-Brown-1
32041: PPUSH
32042: CALL_OW 88
// if IsOk ( Gary ) then
32046: LD_EXP 48
32050: PPUSH
32051: CALL_OW 302
32055: IFFALSE 32069
// Say ( Gary , D20-Gary-1 ) ;
32057: LD_EXP 48
32061: PPUSH
32062: LD_STRING D20-Gary-1
32064: PPUSH
32065: CALL_OW 88
// if IsOk ( Connie ) then
32069: LD_EXP 51
32073: PPUSH
32074: CALL_OW 302
32078: IFFALSE 32092
// Say ( Connie , D20-Con-1 ) ;
32080: LD_EXP 51
32084: PPUSH
32085: LD_STRING D20-Con-1
32087: PPUSH
32088: CALL_OW 88
// if IsOk ( Kurt ) then
32092: LD_EXP 57
32096: PPUSH
32097: CALL_OW 302
32101: IFFALSE 32115
// Say ( Kurt , D20-Kurt-1 ) ;
32103: LD_EXP 57
32107: PPUSH
32108: LD_STRING D20-Kurt-1
32110: PPUSH
32111: CALL_OW 88
// if IsOk ( Kikuchi ) then
32115: LD_EXP 50
32119: PPUSH
32120: CALL_OW 302
32124: IFFALSE 32138
// Say ( Kikuchi , D20-Yam-1 ) ;
32126: LD_EXP 50
32130: PPUSH
32131: LD_STRING D20-Yam-1
32133: PPUSH
32134: CALL_OW 88
// if IsOk ( Frank ) then
32138: LD_EXP 49
32142: PPUSH
32143: CALL_OW 302
32147: IFFALSE 32161
// Say ( Frank , D20-Frank-1 ) ;
32149: LD_EXP 49
32153: PPUSH
32154: LD_STRING D20-Frank-1
32156: PPUSH
32157: CALL_OW 88
// DialogueOff ;
32161: CALL_OW 7
// if RothCaptured then
32165: LD_EXP 33
32169: IFFALSE 32191
// begin m1 := true ;
32171: LD_ADDR_VAR 0 1
32175: PUSH
32176: LD_INT 1
32178: ST_TO_ADDR
// AddMedal ( Roth , 1 ) ;
32179: LD_STRING Roth
32181: PPUSH
32182: LD_INT 1
32184: PPUSH
32185: CALL_OW 101
// end else
32189: GO 32202
// AddMedal ( Roth , - 1 ) ;
32191: LD_STRING Roth
32193: PPUSH
32194: LD_INT 1
32196: NEG
32197: PPUSH
32198: CALL_OW 101
// if behemothDestroyedBeforeFinish then
32202: LD_EXP 27
32206: IFFALSE 32228
// begin m2 := true ;
32208: LD_ADDR_VAR 0 2
32212: PUSH
32213: LD_INT 1
32215: ST_TO_ADDR
// AddMedal ( Project , 1 ) ;
32216: LD_STRING Project
32218: PPUSH
32219: LD_INT 1
32221: PPUSH
32222: CALL_OW 101
// end else
32226: GO 32239
// AddMedal ( Project , - 1 ) ;
32228: LD_STRING Project
32230: PPUSH
32231: LD_INT 1
32233: NEG
32234: PPUSH
32235: CALL_OW 101
// if lostCounter = 0 then
32239: LD_EXP 32
32243: PUSH
32244: LD_INT 0
32246: EQUAL
32247: IFFALSE 32269
// begin m3 := true ;
32249: LD_ADDR_VAR 0 3
32253: PUSH
32254: LD_INT 1
32256: ST_TO_ADDR
// AddMedal ( NoLosses , 1 ) ;
32257: LD_STRING NoLosses
32259: PPUSH
32260: LD_INT 1
32262: PPUSH
32263: CALL_OW 101
// end else
32267: GO 32280
// AddMedal ( NoLosses , - 1 ) ;
32269: LD_STRING NoLosses
32271: PPUSH
32272: LD_INT 1
32274: NEG
32275: PPUSH
32276: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
32280: LD_VAR 0 1
32284: PUSH
32285: LD_VAR 0 2
32289: AND
32290: PUSH
32291: LD_VAR 0 3
32295: AND
32296: PUSH
32297: LD_OWVAR 67
32301: PUSH
32302: LD_INT 3
32304: EQUAL
32305: AND
32306: IFFALSE 32318
// SetAchievementEX ( ACH_AMER , 15 ) ;
32308: LD_STRING ACH_AMER
32310: PPUSH
32311: LD_INT 15
32313: PPUSH
32314: CALL_OW 564
// GiveMedals ( MAIN ) ;
32318: LD_STRING MAIN
32320: PPUSH
32321: CALL_OW 102
// music_class := 4 ;
32325: LD_ADDR_OWVAR 72
32329: PUSH
32330: LD_INT 4
32332: ST_TO_ADDR
// music_nat := 1 ;
32333: LD_ADDR_OWVAR 71
32337: PUSH
32338: LD_INT 1
32340: ST_TO_ADDR
// YouWin ;
32341: CALL_OW 103
// end ; end_of_file
32345: PPOPN 3
32347: END
// export function CustomEvent ( event ) ; begin
32348: LD_INT 0
32350: PPUSH
// end ;
32351: LD_VAR 0 2
32355: RET
// on Contact ( s1 , s2 ) do begin if s1 = 1 and s2 = 4 and IsLive ( Powell ) then
32356: LD_VAR 0 1
32360: PUSH
32361: LD_INT 1
32363: EQUAL
32364: PUSH
32365: LD_VAR 0 2
32369: PUSH
32370: LD_INT 4
32372: EQUAL
32373: AND
32374: PUSH
32375: LD_EXP 55
32379: PPUSH
32380: CALL_OW 300
32384: AND
32385: IFFALSE 32401
// begin wait ( 0 0$2 ) ;
32387: LD_INT 70
32389: PPUSH
32390: CALL_OW 67
// YouLost ( Dismissed ) ;
32394: LD_STRING Dismissed
32396: PPUSH
32397: CALL_OW 104
// end ; end ;
32401: PPOPN 2
32403: END
// on SibDepositContaminated ( unit , x , y ) do begin if InArea ( x , y , motherLodeArea ) then
32404: LD_VAR 0 2
32408: PPUSH
32409: LD_VAR 0 3
32413: PPUSH
32414: LD_INT 18
32416: PPUSH
32417: CALL_OW 309
32421: IFFALSE 32430
// YouLost ( Motherlode3 ) ;
32423: LD_STRING Motherlode3
32425: PPUSH
32426: CALL_OW 104
// end ;
32430: PPOPN 3
32432: END
// on BehemothConstructed ( behemoth ) do begin if not behemothDestroyedBeforeFinish then
32433: LD_EXP 27
32437: NOT
32438: IFFALSE 32448
// behemothDone := true ;
32440: LD_ADDR_EXP 28
32444: PUSH
32445: LD_INT 1
32447: ST_TO_ADDR
// end ;
32448: PPOPN 1
32450: END
// on SiberiteRocketExploded ( unit , x , y ) do begin if GetSide ( unit ) = 1 and platonovHasBomb and FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) and not FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_siberium_rocket ] ] ) then
32451: LD_VAR 0 1
32455: PPUSH
32456: CALL_OW 255
32460: PUSH
32461: LD_INT 1
32463: EQUAL
32464: PUSH
32465: LD_EXP 30
32469: AND
32470: PUSH
32471: LD_INT 22
32473: PUSH
32474: LD_INT 3
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: LD_INT 34
32483: PUSH
32484: LD_INT 48
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PPUSH
32495: CALL_OW 69
32499: AND
32500: PUSH
32501: LD_INT 22
32503: PUSH
32504: LD_INT 1
32506: PUSH
32507: EMPTY
32508: LIST
32509: LIST
32510: PUSH
32511: LD_INT 34
32513: PUSH
32514: LD_INT 8
32516: PUSH
32517: EMPTY
32518: LIST
32519: LIST
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PPUSH
32525: CALL_OW 69
32529: NOT
32530: AND
32531: IFFALSE 32583
// begin wait ( 0 0$5 ) ;
32533: LD_INT 175
32535: PPUSH
32536: CALL_OW 67
// ComAttackPlace ( FilterAllUnits ( [ [ f_side , 3 ] , [ f_weapon , ru_siberium_rocket ] ] ) [ 1 ] , 60 , 95 ) ;
32540: LD_INT 22
32542: PUSH
32543: LD_INT 3
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 34
32552: PUSH
32553: LD_INT 48
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PPUSH
32564: CALL_OW 69
32568: PUSH
32569: LD_INT 1
32571: ARRAY
32572: PPUSH
32573: LD_INT 60
32575: PPUSH
32576: LD_INT 95
32578: PPUSH
32579: CALL_OW 116
// end ; if InArea ( x , y , motherLodeArea ) then
32583: LD_VAR 0 2
32587: PPUSH
32588: LD_VAR 0 3
32592: PPUSH
32593: LD_INT 18
32595: PPUSH
32596: CALL_OW 309
32600: IFFALSE 32660
// begin if GetSide ( unit ) = 1 then
32602: LD_VAR 0 1
32606: PPUSH
32607: CALL_OW 255
32611: PUSH
32612: LD_INT 1
32614: EQUAL
32615: IFFALSE 32631
// begin wait ( 0 0$6 ) ;
32617: LD_INT 210
32619: PPUSH
32620: CALL_OW 67
// YouLost ( Motherlode2 ) ;
32624: LD_STRING Motherlode2
32626: PPUSH
32627: CALL_OW 104
// end ; if GetSide ( unit ) = 8 then
32631: LD_VAR 0 1
32635: PPUSH
32636: CALL_OW 255
32640: PUSH
32641: LD_INT 8
32643: EQUAL
32644: IFFALSE 32660
// begin wait ( 0 0$6 ) ;
32646: LD_INT 210
32648: PPUSH
32649: CALL_OW 67
// YouLost ( Motherlode1 ) ;
32653: LD_STRING Motherlode1
32655: PPUSH
32656: CALL_OW 104
// end ; end ; if GetSide ( unit ) = 3 then
32660: LD_VAR 0 1
32664: PPUSH
32665: CALL_OW 255
32669: PUSH
32670: LD_INT 3
32672: EQUAL
32673: IFFALSE 32694
// begin wait ( 0 0$5 ) ;
32675: LD_INT 175
32677: PPUSH
32678: CALL_OW 67
// SayRadio ( Platonov , D18-Pla-1 ) ;
32682: LD_EXP 61
32686: PPUSH
32687: LD_STRING D18-Pla-1
32689: PPUSH
32690: CALL_OW 94
// end ; end ;
32694: PPOPN 3
32696: END
// on UnitDestroyed ( un ) do begin if un in behemothBuilders then
32697: LD_VAR 0 1
32701: PUSH
32702: LD_EXP 70
32706: IN
32707: IFFALSE 32727
// begin behemothBuilders := behemothBuilders diff un ;
32709: LD_ADDR_EXP 70
32713: PUSH
32714: LD_EXP 70
32718: PUSH
32719: LD_VAR 0 1
32723: DIFF
32724: ST_TO_ADDR
// exit ;
32725: GO 32825
// end ; if un = JMM then
32727: LD_VAR 0 1
32731: PUSH
32732: LD_EXP 36
32736: EQUAL
32737: IFFALSE 32748
// begin YouLost ( JMM ) ;
32739: LD_STRING JMM
32741: PPUSH
32742: CALL_OW 104
// exit ;
32746: GO 32825
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_not , [ f_class , class_apeman_engineer ] , [ f_class , class_apeman ] ] ] ) then
32748: LD_VAR 0 1
32752: PUSH
32753: LD_INT 22
32755: PUSH
32756: LD_INT 1
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: PUSH
32763: LD_INT 3
32765: PUSH
32766: LD_INT 25
32768: PUSH
32769: LD_INT 16
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: PUSH
32776: LD_INT 25
32778: PUSH
32779: LD_INT 12
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: EMPTY
32787: LIST
32788: LIST
32789: LIST
32790: PUSH
32791: EMPTY
32792: LIST
32793: LIST
32794: PPUSH
32795: CALL_OW 69
32799: IN
32800: IFFALSE 32816
// lostCounter := lostCounter + 1 ;
32802: LD_ADDR_EXP 32
32806: PUSH
32807: LD_EXP 32
32811: PUSH
32812: LD_INT 1
32814: PLUS
32815: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
32816: LD_VAR 0 1
32820: PPUSH
32821: CALL 61109 0 1
// end ;
32825: PPOPN 1
32827: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
32828: LD_VAR 0 1
32832: PPUSH
32833: LD_VAR 0 2
32837: PPUSH
32838: CALL 63443 0 2
// end ;
32842: PPOPN 2
32844: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
32845: LD_VAR 0 1
32849: PPUSH
32850: CALL 62511 0 1
// end ;
32854: PPOPN 1
32856: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 8 ] , [ f_btype , b_workshop ] , [ f_nation , 3 ] ] ) then
32857: LD_VAR 0 1
32861: PUSH
32862: LD_INT 22
32864: PUSH
32865: LD_INT 8
32867: PUSH
32868: EMPTY
32869: LIST
32870: LIST
32871: PUSH
32872: LD_INT 30
32874: PUSH
32875: LD_INT 2
32877: PUSH
32878: EMPTY
32879: LIST
32880: LIST
32881: PUSH
32882: LD_INT 23
32884: PUSH
32885: LD_INT 3
32887: PUSH
32888: EMPTY
32889: LIST
32890: LIST
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: LIST
32896: PPUSH
32897: CALL_OW 69
32901: IN
32902: IFFALSE 32929
// begin ComUpgrade ( building ) ;
32904: LD_VAR 0 1
32908: PPUSH
32909: CALL_OW 146
// ComComplete ( Kozlov , building ) ;
32913: LD_EXP 58
32917: PPUSH
32918: LD_VAR 0 1
32922: PPUSH
32923: CALL 74060 0 2
// exit ;
32927: GO 32938
// end ; MCE_BuildingComplete ( building ) ;
32929: LD_VAR 0 1
32933: PPUSH
32934: CALL 62752 0 1
// end ;
32938: PPOPN 1
32940: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
32941: LD_VAR 0 1
32945: PPUSH
32946: LD_VAR 0 2
32950: PPUSH
32951: CALL 60805 0 2
// end ;
32955: PPOPN 2
32957: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
32958: LD_VAR 0 1
32962: PPUSH
32963: LD_VAR 0 2
32967: PPUSH
32968: LD_VAR 0 3
32972: PPUSH
32973: LD_VAR 0 4
32977: PPUSH
32978: LD_VAR 0 5
32982: PPUSH
32983: CALL 60425 0 5
// end ;
32987: PPOPN 5
32989: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
32990: LD_VAR 0 1
32994: PPUSH
32995: LD_VAR 0 2
32999: PPUSH
33000: CALL 60021 0 2
// end ;
33004: PPOPN 2
33006: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
33007: LD_VAR 0 1
33011: PPUSH
33012: LD_VAR 0 2
33016: PPUSH
33017: LD_VAR 0 3
33021: PPUSH
33022: LD_VAR 0 4
33026: PPUSH
33027: CALL 59859 0 4
// end ;
33031: PPOPN 4
33033: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
33034: LD_VAR 0 1
33038: PPUSH
33039: LD_VAR 0 2
33043: PPUSH
33044: LD_VAR 0 3
33048: PPUSH
33049: CALL 59634 0 3
// end ;
33053: PPOPN 3
33055: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
33056: LD_VAR 0 1
33060: PPUSH
33061: LD_VAR 0 2
33065: PPUSH
33066: CALL 59519 0 2
// end ;
33070: PPOPN 2
33072: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
33073: LD_VAR 0 1
33077: PPUSH
33078: LD_VAR 0 2
33082: PPUSH
33083: CALL 63704 0 2
// end ;
33087: PPOPN 2
33089: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin if GetSide ( driver ) = 4 and driver in powellSquadAttack [ 1 ] and powellAllowRetreat then
33090: LD_VAR 0 1
33094: PPUSH
33095: CALL_OW 255
33099: PUSH
33100: LD_INT 4
33102: EQUAL
33103: PUSH
33104: LD_VAR 0 1
33108: PUSH
33109: LD_EXP 18
33113: PUSH
33114: LD_INT 1
33116: ARRAY
33117: IN
33118: AND
33119: PUSH
33120: LD_EXP 19
33124: AND
33125: IFFALSE 33144
// begin ComMoveXY ( driver , 61 , 93 ) ;
33127: LD_VAR 0 1
33131: PPUSH
33132: LD_INT 61
33134: PPUSH
33135: LD_INT 93
33137: PPUSH
33138: CALL_OW 111
// exit ;
33142: GO 33168
// end ; MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
33144: LD_VAR 0 1
33148: PPUSH
33149: LD_VAR 0 2
33153: PPUSH
33154: LD_VAR 0 3
33158: PPUSH
33159: LD_VAR 0 4
33163: PPUSH
33164: CALL 63920 0 4
// end ;
33168: PPOPN 4
33170: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
33171: LD_VAR 0 1
33175: PPUSH
33176: LD_VAR 0 2
33180: PPUSH
33181: CALL 59328 0 2
// end ;
33185: PPOPN 2
33187: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
33188: LD_VAR 0 1
33192: PPUSH
33193: CALL 107232 0 1
// end ; end_of_file
33197: PPOPN 1
33199: END
// every 0 0$30 trigger missionStage = 2 do var time ;
33200: LD_EXP 15
33204: PUSH
33205: LD_INT 2
33207: EQUAL
33208: IFFALSE 33687
33210: GO 33212
33212: DISABLE
33213: LD_INT 0
33215: PPUSH
// begin time := 0 0$40 ;
33216: LD_ADDR_VAR 0 1
33220: PUSH
33221: LD_INT 1400
33223: ST_TO_ADDR
// repeat wait ( time ) ;
33224: LD_VAR 0 1
33228: PPUSH
33229: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 150 , 19 , true ) ;
33233: LD_INT 1
33235: PPUSH
33236: LD_INT 5
33238: PPUSH
33239: CALL_OW 12
33243: PPUSH
33244: LD_INT 106
33246: PPUSH
33247: LD_INT 150
33249: PPUSH
33250: LD_INT 19
33252: PPUSH
33253: LD_INT 1
33255: PPUSH
33256: CALL_OW 56
// time := time + 0 0$9 ;
33260: LD_ADDR_VAR 0 1
33264: PUSH
33265: LD_VAR 0 1
33269: PUSH
33270: LD_INT 315
33272: PLUS
33273: ST_TO_ADDR
// wait ( rand ( 0 0$13 , 0 0$24 ) ) ;
33274: LD_INT 455
33276: PPUSH
33277: LD_INT 840
33279: PPUSH
33280: CALL_OW 12
33284: PPUSH
33285: CALL_OW 67
// if Prob ( 50 ) then
33289: LD_INT 50
33291: PPUSH
33292: CALL_OW 13
33296: IFFALSE 33325
// CreateCratesXYR ( rand ( 1 , 5 ) , 62 , 108 , 10 , true ) ;
33298: LD_INT 1
33300: PPUSH
33301: LD_INT 5
33303: PPUSH
33304: CALL_OW 12
33308: PPUSH
33309: LD_INT 62
33311: PPUSH
33312: LD_INT 108
33314: PPUSH
33315: LD_INT 10
33317: PPUSH
33318: LD_INT 1
33320: PPUSH
33321: CALL_OW 56
// until missionStage > 4 ;
33325: LD_EXP 15
33329: PUSH
33330: LD_INT 4
33332: GREATER
33333: IFFALSE 33224
// repeat wait ( 0 0$1 ) ;
33335: LD_INT 35
33337: PPUSH
33338: CALL_OW 67
// until missionStage = 6 ;
33342: LD_EXP 15
33346: PUSH
33347: LD_INT 6
33349: EQUAL
33350: IFFALSE 33335
// time := 0 0$50 ;
33352: LD_ADDR_VAR 0 1
33356: PUSH
33357: LD_INT 1750
33359: ST_TO_ADDR
// repeat wait ( time ) ;
33360: LD_VAR 0 1
33364: PPUSH
33365: CALL_OW 67
// if Prob ( 50 ) then
33369: LD_INT 50
33371: PPUSH
33372: CALL_OW 13
33376: IFFALSE 33405
// CreateCratesXYR ( rand ( 1 , 5 ) , 106 , 89 , 45 , true ) ;
33378: LD_INT 1
33380: PPUSH
33381: LD_INT 5
33383: PPUSH
33384: CALL_OW 12
33388: PPUSH
33389: LD_INT 106
33391: PPUSH
33392: LD_INT 89
33394: PPUSH
33395: LD_INT 45
33397: PPUSH
33398: LD_INT 1
33400: PPUSH
33401: CALL_OW 56
// time := time + 0 0$3 ;
33405: LD_ADDR_VAR 0 1
33409: PUSH
33410: LD_VAR 0 1
33414: PUSH
33415: LD_INT 105
33417: PLUS
33418: ST_TO_ADDR
// if Prob ( 30 ) then
33419: LD_INT 30
33421: PPUSH
33422: CALL_OW 13
33426: IFFALSE 33472
// begin wait ( rand ( 0 0$15 , 0 0$21 ) ) ;
33428: LD_INT 525
33430: PPUSH
33431: LD_INT 735
33433: PPUSH
33434: CALL_OW 12
33438: PPUSH
33439: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 21 , 26 , 12 , true ) ;
33443: LD_INT 1
33445: PPUSH
33446: LD_INT 5
33448: PPUSH
33449: CALL_OW 12
33453: PPUSH
33454: LD_INT 21
33456: PPUSH
33457: LD_INT 26
33459: PPUSH
33460: LD_INT 12
33462: PPUSH
33463: LD_INT 1
33465: PPUSH
33466: CALL_OW 56
// end else
33470: GO 33508
// begin wait ( rand ( 0 0$20 , 0 0$35 ) ) ;
33472: LD_INT 700
33474: PPUSH
33475: LD_INT 1225
33477: PPUSH
33478: CALL_OW 12
33482: PPUSH
33483: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , russianCratesArea , true ) ;
33487: LD_INT 1
33489: PPUSH
33490: LD_INT 5
33492: PPUSH
33493: CALL_OW 12
33497: PPUSH
33498: LD_INT 16
33500: PPUSH
33501: LD_INT 1
33503: PPUSH
33504: CALL_OW 55
// end ; if Prob ( 50 ) then
33508: LD_INT 50
33510: PPUSH
33511: CALL_OW 13
33515: IFFALSE 33561
// begin wait ( rand ( 0 0$20 , 0 0$30 ) ) ;
33517: LD_INT 700
33519: PPUSH
33520: LD_INT 1050
33522: PPUSH
33523: CALL_OW 12
33527: PPUSH
33528: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 181 , 218 , 16 , true ) ;
33532: LD_INT 1
33534: PPUSH
33535: LD_INT 5
33537: PPUSH
33538: CALL_OW 12
33542: PPUSH
33543: LD_INT 181
33545: PPUSH
33546: LD_INT 218
33548: PPUSH
33549: LD_INT 16
33551: PPUSH
33552: LD_INT 1
33554: PPUSH
33555: CALL_OW 56
// end else
33559: GO 33597
// begin wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
33561: LD_INT 350
33563: PPUSH
33564: LD_INT 525
33566: PPUSH
33567: CALL_OW 12
33571: PPUSH
33572: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , legionCratesArea , true ) ;
33576: LD_INT 1
33578: PPUSH
33579: LD_INT 5
33581: PPUSH
33582: CALL_OW 12
33586: PPUSH
33587: LD_INT 15
33589: PPUSH
33590: LD_INT 1
33592: PPUSH
33593: CALL_OW 55
// end ; if Prob ( [ 45 , 32 , 25 ] [ Difficulty ] ) then
33597: LD_INT 45
33599: PUSH
33600: LD_INT 32
33602: PUSH
33603: LD_INT 25
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: LIST
33610: PUSH
33611: LD_OWVAR 67
33615: ARRAY
33616: PPUSH
33617: CALL_OW 13
33621: IFFALSE 33665
// begin wait ( rand ( 0 0$15 , 0 0$25 ) ) ;
33623: LD_INT 525
33625: PPUSH
33626: LD_INT 875
33628: PPUSH
33629: CALL_OW 12
33633: PPUSH
33634: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 103 , 140 , 20 , true ) ;
33638: LD_INT 1
33640: PPUSH
33641: LD_INT 5
33643: PPUSH
33644: CALL_OW 12
33648: PPUSH
33649: LD_INT 103
33651: PPUSH
33652: LD_INT 140
33654: PPUSH
33655: LD_INT 20
33657: PPUSH
33658: LD_INT 1
33660: PPUSH
33661: CALL_OW 56
// end ; if time > 2 2$20 then
33665: LD_VAR 0 1
33669: PUSH
33670: LD_INT 4900
33672: GREATER
33673: IFFALSE 33683
// time := 0 0$50 ;
33675: LD_ADDR_VAR 0 1
33679: PUSH
33680: LD_INT 1750
33682: ST_TO_ADDR
// until false ;
33683: LD_INT 0
33685: IFFALSE 33360
// end ; end_of_file
33687: PPOPN 1
33689: END
// every 0 0$1 trigger missionStart and missionStage >= 6 do
33690: LD_EXP 13
33694: PUSH
33695: LD_EXP 15
33699: PUSH
33700: LD_INT 6
33702: GREATEREQUAL
33703: AND
33704: IFFALSE 33741
33706: GO 33708
33708: DISABLE
// begin enable ;
33709: ENABLE
// missionTime := missionTime + 0 0$1 ;
33710: LD_ADDR_EXP 14
33714: PUSH
33715: LD_EXP 14
33719: PUSH
33720: LD_INT 35
33722: PLUS
33723: ST_TO_ADDR
// display_strings = [ #Am15-1 , missionTime ] ;
33724: LD_ADDR_OWVAR 47
33728: PUSH
33729: LD_STRING #Am15-1
33731: PUSH
33732: LD_EXP 14
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: ST_TO_ADDR
// end ; end_of_file
33741: END
// export function InitNature ; begin
33742: LD_INT 0
33744: PPUSH
// PrepareNature ( 3 , 3 , 2 , 1 , 1 , 0 , 0 , natureArea1 , 0 ) ;
33745: LD_INT 3
33747: PPUSH
33748: LD_INT 3
33750: PPUSH
33751: LD_INT 2
33753: PPUSH
33754: LD_INT 1
33756: PPUSH
33757: LD_INT 1
33759: PPUSH
33760: LD_INT 0
33762: PPUSH
33763: LD_INT 0
33765: PPUSH
33766: LD_INT 20
33768: PPUSH
33769: LD_INT 0
33771: PPUSH
33772: CALL 98901 0 9
// PrepareNature ( 2 , 1 , 1 , 1 , 1 , 0 , 0 , natureArea2 , 0 ) ;
33776: LD_INT 2
33778: PPUSH
33779: LD_INT 1
33781: PPUSH
33782: LD_INT 1
33784: PPUSH
33785: LD_INT 1
33787: PPUSH
33788: LD_INT 1
33790: PPUSH
33791: LD_INT 0
33793: PPUSH
33794: LD_INT 0
33796: PPUSH
33797: LD_INT 21
33799: PPUSH
33800: LD_INT 0
33802: PPUSH
33803: CALL 98901 0 9
// PrepareNature ( 4 , 1 , 2 , 4 , 2 , 1 , 0 , natureArea3 , 0 ) ;
33807: LD_INT 4
33809: PPUSH
33810: LD_INT 1
33812: PPUSH
33813: LD_INT 2
33815: PPUSH
33816: LD_INT 4
33818: PPUSH
33819: LD_INT 2
33821: PPUSH
33822: LD_INT 1
33824: PPUSH
33825: LD_INT 0
33827: PPUSH
33828: LD_INT 22
33830: PPUSH
33831: LD_INT 0
33833: PPUSH
33834: CALL 98901 0 9
// PrepareNature ( 0 , 0 , 0 , 0 , 0 , 0 , 9 , 0 , natureWaterArea ) ;
33838: LD_INT 0
33840: PPUSH
33841: LD_INT 0
33843: PPUSH
33844: LD_INT 0
33846: PPUSH
33847: LD_INT 0
33849: PPUSH
33850: LD_INT 0
33852: PPUSH
33853: LD_INT 0
33855: PPUSH
33856: LD_INT 9
33858: PPUSH
33859: LD_INT 0
33861: PPUSH
33862: LD_INT 23
33864: PPUSH
33865: CALL 98901 0 9
// end ; end_of_file
33869: LD_VAR 0 1
33873: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
33874: GO 33876
33876: DISABLE
// begin ru_radar := 98 ;
33877: LD_ADDR_EXP 92
33881: PUSH
33882: LD_INT 98
33884: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
33885: LD_ADDR_EXP 93
33889: PUSH
33890: LD_INT 89
33892: ST_TO_ADDR
// us_hack := 99 ;
33893: LD_ADDR_EXP 94
33897: PUSH
33898: LD_INT 99
33900: ST_TO_ADDR
// us_artillery := 97 ;
33901: LD_ADDR_EXP 95
33905: PUSH
33906: LD_INT 97
33908: ST_TO_ADDR
// ar_bio_bomb := 91 ;
33909: LD_ADDR_EXP 96
33913: PUSH
33914: LD_INT 91
33916: ST_TO_ADDR
// end ; end_of_file
33917: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
33918: LD_INT 0
33920: PPUSH
33921: PPUSH
// skirmish := false ;
33922: LD_ADDR_EXP 97
33926: PUSH
33927: LD_INT 0
33929: ST_TO_ADDR
// debug_mc := false ;
33930: LD_ADDR_EXP 98
33934: PUSH
33935: LD_INT 0
33937: ST_TO_ADDR
// mc_bases := [ ] ;
33938: LD_ADDR_EXP 99
33942: PUSH
33943: EMPTY
33944: ST_TO_ADDR
// mc_sides := [ ] ;
33945: LD_ADDR_EXP 125
33949: PUSH
33950: EMPTY
33951: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
33952: LD_ADDR_EXP 100
33956: PUSH
33957: EMPTY
33958: ST_TO_ADDR
// mc_building_repairs := [ ] ;
33959: LD_ADDR_EXP 101
33963: PUSH
33964: EMPTY
33965: ST_TO_ADDR
// mc_need_heal := [ ] ;
33966: LD_ADDR_EXP 102
33970: PUSH
33971: EMPTY
33972: ST_TO_ADDR
// mc_healers := [ ] ;
33973: LD_ADDR_EXP 103
33977: PUSH
33978: EMPTY
33979: ST_TO_ADDR
// mc_build_list := [ ] ;
33980: LD_ADDR_EXP 104
33984: PUSH
33985: EMPTY
33986: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
33987: LD_ADDR_EXP 131
33991: PUSH
33992: EMPTY
33993: ST_TO_ADDR
// mc_builders := [ ] ;
33994: LD_ADDR_EXP 105
33998: PUSH
33999: EMPTY
34000: ST_TO_ADDR
// mc_construct_list := [ ] ;
34001: LD_ADDR_EXP 106
34005: PUSH
34006: EMPTY
34007: ST_TO_ADDR
// mc_turret_list := [ ] ;
34008: LD_ADDR_EXP 107
34012: PUSH
34013: EMPTY
34014: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
34015: LD_ADDR_EXP 108
34019: PUSH
34020: EMPTY
34021: ST_TO_ADDR
// mc_miners := [ ] ;
34022: LD_ADDR_EXP 113
34026: PUSH
34027: EMPTY
34028: ST_TO_ADDR
// mc_mines := [ ] ;
34029: LD_ADDR_EXP 112
34033: PUSH
34034: EMPTY
34035: ST_TO_ADDR
// mc_minefields := [ ] ;
34036: LD_ADDR_EXP 114
34040: PUSH
34041: EMPTY
34042: ST_TO_ADDR
// mc_crates := [ ] ;
34043: LD_ADDR_EXP 115
34047: PUSH
34048: EMPTY
34049: ST_TO_ADDR
// mc_crates_collector := [ ] ;
34050: LD_ADDR_EXP 116
34054: PUSH
34055: EMPTY
34056: ST_TO_ADDR
// mc_crates_area := [ ] ;
34057: LD_ADDR_EXP 117
34061: PUSH
34062: EMPTY
34063: ST_TO_ADDR
// mc_vehicles := [ ] ;
34064: LD_ADDR_EXP 118
34068: PUSH
34069: EMPTY
34070: ST_TO_ADDR
// mc_attack := [ ] ;
34071: LD_ADDR_EXP 119
34075: PUSH
34076: EMPTY
34077: ST_TO_ADDR
// mc_produce := [ ] ;
34078: LD_ADDR_EXP 120
34082: PUSH
34083: EMPTY
34084: ST_TO_ADDR
// mc_defender := [ ] ;
34085: LD_ADDR_EXP 121
34089: PUSH
34090: EMPTY
34091: ST_TO_ADDR
// mc_parking := [ ] ;
34092: LD_ADDR_EXP 123
34096: PUSH
34097: EMPTY
34098: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
34099: LD_ADDR_EXP 109
34103: PUSH
34104: EMPTY
34105: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
34106: LD_ADDR_EXP 111
34110: PUSH
34111: EMPTY
34112: ST_TO_ADDR
// mc_scan := [ ] ;
34113: LD_ADDR_EXP 122
34117: PUSH
34118: EMPTY
34119: ST_TO_ADDR
// mc_scan_area := [ ] ;
34120: LD_ADDR_EXP 124
34124: PUSH
34125: EMPTY
34126: ST_TO_ADDR
// mc_tech := [ ] ;
34127: LD_ADDR_EXP 126
34131: PUSH
34132: EMPTY
34133: ST_TO_ADDR
// mc_class := [ ] ;
34134: LD_ADDR_EXP 140
34138: PUSH
34139: EMPTY
34140: ST_TO_ADDR
// mc_class_case_use := [ ] ;
34141: LD_ADDR_EXP 141
34145: PUSH
34146: EMPTY
34147: ST_TO_ADDR
// end ;
34148: LD_VAR 0 1
34152: RET
// export function MC_Kill ( base ) ; begin
34153: LD_INT 0
34155: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
34156: LD_ADDR_EXP 99
34160: PUSH
34161: LD_EXP 99
34165: PPUSH
34166: LD_VAR 0 1
34170: PPUSH
34171: EMPTY
34172: PPUSH
34173: CALL_OW 1
34177: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
34178: LD_ADDR_EXP 100
34182: PUSH
34183: LD_EXP 100
34187: PPUSH
34188: LD_VAR 0 1
34192: PPUSH
34193: EMPTY
34194: PPUSH
34195: CALL_OW 1
34199: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
34200: LD_ADDR_EXP 101
34204: PUSH
34205: LD_EXP 101
34209: PPUSH
34210: LD_VAR 0 1
34214: PPUSH
34215: EMPTY
34216: PPUSH
34217: CALL_OW 1
34221: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
34222: LD_ADDR_EXP 102
34226: PUSH
34227: LD_EXP 102
34231: PPUSH
34232: LD_VAR 0 1
34236: PPUSH
34237: EMPTY
34238: PPUSH
34239: CALL_OW 1
34243: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
34244: LD_ADDR_EXP 103
34248: PUSH
34249: LD_EXP 103
34253: PPUSH
34254: LD_VAR 0 1
34258: PPUSH
34259: EMPTY
34260: PPUSH
34261: CALL_OW 1
34265: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
34266: LD_ADDR_EXP 104
34270: PUSH
34271: LD_EXP 104
34275: PPUSH
34276: LD_VAR 0 1
34280: PPUSH
34281: EMPTY
34282: PPUSH
34283: CALL_OW 1
34287: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
34288: LD_ADDR_EXP 105
34292: PUSH
34293: LD_EXP 105
34297: PPUSH
34298: LD_VAR 0 1
34302: PPUSH
34303: EMPTY
34304: PPUSH
34305: CALL_OW 1
34309: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
34310: LD_ADDR_EXP 106
34314: PUSH
34315: LD_EXP 106
34319: PPUSH
34320: LD_VAR 0 1
34324: PPUSH
34325: EMPTY
34326: PPUSH
34327: CALL_OW 1
34331: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
34332: LD_ADDR_EXP 107
34336: PUSH
34337: LD_EXP 107
34341: PPUSH
34342: LD_VAR 0 1
34346: PPUSH
34347: EMPTY
34348: PPUSH
34349: CALL_OW 1
34353: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
34354: LD_ADDR_EXP 108
34358: PUSH
34359: LD_EXP 108
34363: PPUSH
34364: LD_VAR 0 1
34368: PPUSH
34369: EMPTY
34370: PPUSH
34371: CALL_OW 1
34375: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
34376: LD_ADDR_EXP 109
34380: PUSH
34381: LD_EXP 109
34385: PPUSH
34386: LD_VAR 0 1
34390: PPUSH
34391: EMPTY
34392: PPUSH
34393: CALL_OW 1
34397: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
34398: LD_ADDR_EXP 110
34402: PUSH
34403: LD_EXP 110
34407: PPUSH
34408: LD_VAR 0 1
34412: PPUSH
34413: LD_INT 0
34415: PPUSH
34416: CALL_OW 1
34420: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
34421: LD_ADDR_EXP 111
34425: PUSH
34426: LD_EXP 111
34430: PPUSH
34431: LD_VAR 0 1
34435: PPUSH
34436: EMPTY
34437: PPUSH
34438: CALL_OW 1
34442: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
34443: LD_ADDR_EXP 112
34447: PUSH
34448: LD_EXP 112
34452: PPUSH
34453: LD_VAR 0 1
34457: PPUSH
34458: EMPTY
34459: PPUSH
34460: CALL_OW 1
34464: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
34465: LD_ADDR_EXP 113
34469: PUSH
34470: LD_EXP 113
34474: PPUSH
34475: LD_VAR 0 1
34479: PPUSH
34480: EMPTY
34481: PPUSH
34482: CALL_OW 1
34486: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
34487: LD_ADDR_EXP 114
34491: PUSH
34492: LD_EXP 114
34496: PPUSH
34497: LD_VAR 0 1
34501: PPUSH
34502: EMPTY
34503: PPUSH
34504: CALL_OW 1
34508: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
34509: LD_ADDR_EXP 115
34513: PUSH
34514: LD_EXP 115
34518: PPUSH
34519: LD_VAR 0 1
34523: PPUSH
34524: EMPTY
34525: PPUSH
34526: CALL_OW 1
34530: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
34531: LD_ADDR_EXP 116
34535: PUSH
34536: LD_EXP 116
34540: PPUSH
34541: LD_VAR 0 1
34545: PPUSH
34546: EMPTY
34547: PPUSH
34548: CALL_OW 1
34552: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
34553: LD_ADDR_EXP 117
34557: PUSH
34558: LD_EXP 117
34562: PPUSH
34563: LD_VAR 0 1
34567: PPUSH
34568: EMPTY
34569: PPUSH
34570: CALL_OW 1
34574: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
34575: LD_ADDR_EXP 118
34579: PUSH
34580: LD_EXP 118
34584: PPUSH
34585: LD_VAR 0 1
34589: PPUSH
34590: EMPTY
34591: PPUSH
34592: CALL_OW 1
34596: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
34597: LD_ADDR_EXP 119
34601: PUSH
34602: LD_EXP 119
34606: PPUSH
34607: LD_VAR 0 1
34611: PPUSH
34612: EMPTY
34613: PPUSH
34614: CALL_OW 1
34618: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
34619: LD_ADDR_EXP 120
34623: PUSH
34624: LD_EXP 120
34628: PPUSH
34629: LD_VAR 0 1
34633: PPUSH
34634: EMPTY
34635: PPUSH
34636: CALL_OW 1
34640: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
34641: LD_ADDR_EXP 121
34645: PUSH
34646: LD_EXP 121
34650: PPUSH
34651: LD_VAR 0 1
34655: PPUSH
34656: EMPTY
34657: PPUSH
34658: CALL_OW 1
34662: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
34663: LD_ADDR_EXP 122
34667: PUSH
34668: LD_EXP 122
34672: PPUSH
34673: LD_VAR 0 1
34677: PPUSH
34678: EMPTY
34679: PPUSH
34680: CALL_OW 1
34684: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
34685: LD_ADDR_EXP 123
34689: PUSH
34690: LD_EXP 123
34694: PPUSH
34695: LD_VAR 0 1
34699: PPUSH
34700: EMPTY
34701: PPUSH
34702: CALL_OW 1
34706: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
34707: LD_ADDR_EXP 124
34711: PUSH
34712: LD_EXP 124
34716: PPUSH
34717: LD_VAR 0 1
34721: PPUSH
34722: EMPTY
34723: PPUSH
34724: CALL_OW 1
34728: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
34729: LD_ADDR_EXP 126
34733: PUSH
34734: LD_EXP 126
34738: PPUSH
34739: LD_VAR 0 1
34743: PPUSH
34744: EMPTY
34745: PPUSH
34746: CALL_OW 1
34750: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
34751: LD_ADDR_EXP 128
34755: PUSH
34756: LD_EXP 128
34760: PPUSH
34761: LD_VAR 0 1
34765: PPUSH
34766: EMPTY
34767: PPUSH
34768: CALL_OW 1
34772: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
34773: LD_ADDR_EXP 129
34777: PUSH
34778: LD_EXP 129
34782: PPUSH
34783: LD_VAR 0 1
34787: PPUSH
34788: EMPTY
34789: PPUSH
34790: CALL_OW 1
34794: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
34795: LD_ADDR_EXP 130
34799: PUSH
34800: LD_EXP 130
34804: PPUSH
34805: LD_VAR 0 1
34809: PPUSH
34810: EMPTY
34811: PPUSH
34812: CALL_OW 1
34816: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
34817: LD_ADDR_EXP 131
34821: PUSH
34822: LD_EXP 131
34826: PPUSH
34827: LD_VAR 0 1
34831: PPUSH
34832: EMPTY
34833: PPUSH
34834: CALL_OW 1
34838: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
34839: LD_ADDR_EXP 132
34843: PUSH
34844: LD_EXP 132
34848: PPUSH
34849: LD_VAR 0 1
34853: PPUSH
34854: EMPTY
34855: PPUSH
34856: CALL_OW 1
34860: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
34861: LD_ADDR_EXP 133
34865: PUSH
34866: LD_EXP 133
34870: PPUSH
34871: LD_VAR 0 1
34875: PPUSH
34876: EMPTY
34877: PPUSH
34878: CALL_OW 1
34882: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
34883: LD_ADDR_EXP 134
34887: PUSH
34888: LD_EXP 134
34892: PPUSH
34893: LD_VAR 0 1
34897: PPUSH
34898: EMPTY
34899: PPUSH
34900: CALL_OW 1
34904: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
34905: LD_ADDR_EXP 135
34909: PUSH
34910: LD_EXP 135
34914: PPUSH
34915: LD_VAR 0 1
34919: PPUSH
34920: EMPTY
34921: PPUSH
34922: CALL_OW 1
34926: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
34927: LD_ADDR_EXP 136
34931: PUSH
34932: LD_EXP 136
34936: PPUSH
34937: LD_VAR 0 1
34941: PPUSH
34942: EMPTY
34943: PPUSH
34944: CALL_OW 1
34948: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
34949: LD_ADDR_EXP 137
34953: PUSH
34954: LD_EXP 137
34958: PPUSH
34959: LD_VAR 0 1
34963: PPUSH
34964: EMPTY
34965: PPUSH
34966: CALL_OW 1
34970: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
34971: LD_ADDR_EXP 138
34975: PUSH
34976: LD_EXP 138
34980: PPUSH
34981: LD_VAR 0 1
34985: PPUSH
34986: EMPTY
34987: PPUSH
34988: CALL_OW 1
34992: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
34993: LD_ADDR_EXP 139
34997: PUSH
34998: LD_EXP 139
35002: PPUSH
35003: LD_VAR 0 1
35007: PPUSH
35008: EMPTY
35009: PPUSH
35010: CALL_OW 1
35014: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35015: LD_ADDR_EXP 140
35019: PUSH
35020: LD_EXP 140
35024: PPUSH
35025: LD_VAR 0 1
35029: PPUSH
35030: EMPTY
35031: PPUSH
35032: CALL_OW 1
35036: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35037: LD_ADDR_EXP 141
35041: PUSH
35042: LD_EXP 141
35046: PPUSH
35047: LD_VAR 0 1
35051: PPUSH
35052: LD_INT 0
35054: PPUSH
35055: CALL_OW 1
35059: ST_TO_ADDR
// end ;
35060: LD_VAR 0 2
35064: RET
// export function MC_Add ( side , units ) ; var base ; begin
35065: LD_INT 0
35067: PPUSH
35068: PPUSH
// base := mc_bases + 1 ;
35069: LD_ADDR_VAR 0 4
35073: PUSH
35074: LD_EXP 99
35078: PUSH
35079: LD_INT 1
35081: PLUS
35082: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
35083: LD_ADDR_EXP 125
35087: PUSH
35088: LD_EXP 125
35092: PPUSH
35093: LD_VAR 0 4
35097: PPUSH
35098: LD_VAR 0 1
35102: PPUSH
35103: CALL_OW 1
35107: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
35108: LD_ADDR_EXP 99
35112: PUSH
35113: LD_EXP 99
35117: PPUSH
35118: LD_VAR 0 4
35122: PPUSH
35123: LD_VAR 0 2
35127: PPUSH
35128: CALL_OW 1
35132: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
35133: LD_ADDR_EXP 100
35137: PUSH
35138: LD_EXP 100
35142: PPUSH
35143: LD_VAR 0 4
35147: PPUSH
35148: EMPTY
35149: PPUSH
35150: CALL_OW 1
35154: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
35155: LD_ADDR_EXP 101
35159: PUSH
35160: LD_EXP 101
35164: PPUSH
35165: LD_VAR 0 4
35169: PPUSH
35170: EMPTY
35171: PPUSH
35172: CALL_OW 1
35176: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
35177: LD_ADDR_EXP 102
35181: PUSH
35182: LD_EXP 102
35186: PPUSH
35187: LD_VAR 0 4
35191: PPUSH
35192: EMPTY
35193: PPUSH
35194: CALL_OW 1
35198: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
35199: LD_ADDR_EXP 103
35203: PUSH
35204: LD_EXP 103
35208: PPUSH
35209: LD_VAR 0 4
35213: PPUSH
35214: EMPTY
35215: PPUSH
35216: CALL_OW 1
35220: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
35221: LD_ADDR_EXP 104
35225: PUSH
35226: LD_EXP 104
35230: PPUSH
35231: LD_VAR 0 4
35235: PPUSH
35236: EMPTY
35237: PPUSH
35238: CALL_OW 1
35242: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
35243: LD_ADDR_EXP 105
35247: PUSH
35248: LD_EXP 105
35252: PPUSH
35253: LD_VAR 0 4
35257: PPUSH
35258: EMPTY
35259: PPUSH
35260: CALL_OW 1
35264: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
35265: LD_ADDR_EXP 106
35269: PUSH
35270: LD_EXP 106
35274: PPUSH
35275: LD_VAR 0 4
35279: PPUSH
35280: EMPTY
35281: PPUSH
35282: CALL_OW 1
35286: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
35287: LD_ADDR_EXP 107
35291: PUSH
35292: LD_EXP 107
35296: PPUSH
35297: LD_VAR 0 4
35301: PPUSH
35302: EMPTY
35303: PPUSH
35304: CALL_OW 1
35308: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
35309: LD_ADDR_EXP 108
35313: PUSH
35314: LD_EXP 108
35318: PPUSH
35319: LD_VAR 0 4
35323: PPUSH
35324: EMPTY
35325: PPUSH
35326: CALL_OW 1
35330: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
35331: LD_ADDR_EXP 109
35335: PUSH
35336: LD_EXP 109
35340: PPUSH
35341: LD_VAR 0 4
35345: PPUSH
35346: EMPTY
35347: PPUSH
35348: CALL_OW 1
35352: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
35353: LD_ADDR_EXP 110
35357: PUSH
35358: LD_EXP 110
35362: PPUSH
35363: LD_VAR 0 4
35367: PPUSH
35368: LD_INT 0
35370: PPUSH
35371: CALL_OW 1
35375: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
35376: LD_ADDR_EXP 111
35380: PUSH
35381: LD_EXP 111
35385: PPUSH
35386: LD_VAR 0 4
35390: PPUSH
35391: EMPTY
35392: PPUSH
35393: CALL_OW 1
35397: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
35398: LD_ADDR_EXP 112
35402: PUSH
35403: LD_EXP 112
35407: PPUSH
35408: LD_VAR 0 4
35412: PPUSH
35413: EMPTY
35414: PPUSH
35415: CALL_OW 1
35419: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
35420: LD_ADDR_EXP 113
35424: PUSH
35425: LD_EXP 113
35429: PPUSH
35430: LD_VAR 0 4
35434: PPUSH
35435: EMPTY
35436: PPUSH
35437: CALL_OW 1
35441: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
35442: LD_ADDR_EXP 114
35446: PUSH
35447: LD_EXP 114
35451: PPUSH
35452: LD_VAR 0 4
35456: PPUSH
35457: EMPTY
35458: PPUSH
35459: CALL_OW 1
35463: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
35464: LD_ADDR_EXP 115
35468: PUSH
35469: LD_EXP 115
35473: PPUSH
35474: LD_VAR 0 4
35478: PPUSH
35479: EMPTY
35480: PPUSH
35481: CALL_OW 1
35485: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
35486: LD_ADDR_EXP 116
35490: PUSH
35491: LD_EXP 116
35495: PPUSH
35496: LD_VAR 0 4
35500: PPUSH
35501: EMPTY
35502: PPUSH
35503: CALL_OW 1
35507: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
35508: LD_ADDR_EXP 117
35512: PUSH
35513: LD_EXP 117
35517: PPUSH
35518: LD_VAR 0 4
35522: PPUSH
35523: EMPTY
35524: PPUSH
35525: CALL_OW 1
35529: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
35530: LD_ADDR_EXP 118
35534: PUSH
35535: LD_EXP 118
35539: PPUSH
35540: LD_VAR 0 4
35544: PPUSH
35545: EMPTY
35546: PPUSH
35547: CALL_OW 1
35551: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
35552: LD_ADDR_EXP 119
35556: PUSH
35557: LD_EXP 119
35561: PPUSH
35562: LD_VAR 0 4
35566: PPUSH
35567: EMPTY
35568: PPUSH
35569: CALL_OW 1
35573: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
35574: LD_ADDR_EXP 120
35578: PUSH
35579: LD_EXP 120
35583: PPUSH
35584: LD_VAR 0 4
35588: PPUSH
35589: EMPTY
35590: PPUSH
35591: CALL_OW 1
35595: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
35596: LD_ADDR_EXP 121
35600: PUSH
35601: LD_EXP 121
35605: PPUSH
35606: LD_VAR 0 4
35610: PPUSH
35611: EMPTY
35612: PPUSH
35613: CALL_OW 1
35617: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
35618: LD_ADDR_EXP 122
35622: PUSH
35623: LD_EXP 122
35627: PPUSH
35628: LD_VAR 0 4
35632: PPUSH
35633: EMPTY
35634: PPUSH
35635: CALL_OW 1
35639: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
35640: LD_ADDR_EXP 123
35644: PUSH
35645: LD_EXP 123
35649: PPUSH
35650: LD_VAR 0 4
35654: PPUSH
35655: EMPTY
35656: PPUSH
35657: CALL_OW 1
35661: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
35662: LD_ADDR_EXP 124
35666: PUSH
35667: LD_EXP 124
35671: PPUSH
35672: LD_VAR 0 4
35676: PPUSH
35677: EMPTY
35678: PPUSH
35679: CALL_OW 1
35683: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
35684: LD_ADDR_EXP 126
35688: PUSH
35689: LD_EXP 126
35693: PPUSH
35694: LD_VAR 0 4
35698: PPUSH
35699: EMPTY
35700: PPUSH
35701: CALL_OW 1
35705: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
35706: LD_ADDR_EXP 128
35710: PUSH
35711: LD_EXP 128
35715: PPUSH
35716: LD_VAR 0 4
35720: PPUSH
35721: EMPTY
35722: PPUSH
35723: CALL_OW 1
35727: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
35728: LD_ADDR_EXP 129
35732: PUSH
35733: LD_EXP 129
35737: PPUSH
35738: LD_VAR 0 4
35742: PPUSH
35743: EMPTY
35744: PPUSH
35745: CALL_OW 1
35749: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
35750: LD_ADDR_EXP 130
35754: PUSH
35755: LD_EXP 130
35759: PPUSH
35760: LD_VAR 0 4
35764: PPUSH
35765: EMPTY
35766: PPUSH
35767: CALL_OW 1
35771: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
35772: LD_ADDR_EXP 131
35776: PUSH
35777: LD_EXP 131
35781: PPUSH
35782: LD_VAR 0 4
35786: PPUSH
35787: EMPTY
35788: PPUSH
35789: CALL_OW 1
35793: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
35794: LD_ADDR_EXP 132
35798: PUSH
35799: LD_EXP 132
35803: PPUSH
35804: LD_VAR 0 4
35808: PPUSH
35809: EMPTY
35810: PPUSH
35811: CALL_OW 1
35815: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
35816: LD_ADDR_EXP 133
35820: PUSH
35821: LD_EXP 133
35825: PPUSH
35826: LD_VAR 0 4
35830: PPUSH
35831: EMPTY
35832: PPUSH
35833: CALL_OW 1
35837: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
35838: LD_ADDR_EXP 134
35842: PUSH
35843: LD_EXP 134
35847: PPUSH
35848: LD_VAR 0 4
35852: PPUSH
35853: EMPTY
35854: PPUSH
35855: CALL_OW 1
35859: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
35860: LD_ADDR_EXP 135
35864: PUSH
35865: LD_EXP 135
35869: PPUSH
35870: LD_VAR 0 4
35874: PPUSH
35875: EMPTY
35876: PPUSH
35877: CALL_OW 1
35881: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
35882: LD_ADDR_EXP 136
35886: PUSH
35887: LD_EXP 136
35891: PPUSH
35892: LD_VAR 0 4
35896: PPUSH
35897: EMPTY
35898: PPUSH
35899: CALL_OW 1
35903: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
35904: LD_ADDR_EXP 137
35908: PUSH
35909: LD_EXP 137
35913: PPUSH
35914: LD_VAR 0 4
35918: PPUSH
35919: EMPTY
35920: PPUSH
35921: CALL_OW 1
35925: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
35926: LD_ADDR_EXP 138
35930: PUSH
35931: LD_EXP 138
35935: PPUSH
35936: LD_VAR 0 4
35940: PPUSH
35941: EMPTY
35942: PPUSH
35943: CALL_OW 1
35947: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
35948: LD_ADDR_EXP 139
35952: PUSH
35953: LD_EXP 139
35957: PPUSH
35958: LD_VAR 0 4
35962: PPUSH
35963: EMPTY
35964: PPUSH
35965: CALL_OW 1
35969: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
35970: LD_ADDR_EXP 140
35974: PUSH
35975: LD_EXP 140
35979: PPUSH
35980: LD_VAR 0 4
35984: PPUSH
35985: EMPTY
35986: PPUSH
35987: CALL_OW 1
35991: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
35992: LD_ADDR_EXP 141
35996: PUSH
35997: LD_EXP 141
36001: PPUSH
36002: LD_VAR 0 4
36006: PPUSH
36007: LD_INT 0
36009: PPUSH
36010: CALL_OW 1
36014: ST_TO_ADDR
// result := base ;
36015: LD_ADDR_VAR 0 3
36019: PUSH
36020: LD_VAR 0 4
36024: ST_TO_ADDR
// end ;
36025: LD_VAR 0 3
36029: RET
// export function MC_Start ( ) ; var i ; begin
36030: LD_INT 0
36032: PPUSH
36033: PPUSH
// for i = 1 to mc_bases do
36034: LD_ADDR_VAR 0 2
36038: PUSH
36039: DOUBLE
36040: LD_INT 1
36042: DEC
36043: ST_TO_ADDR
36044: LD_EXP 99
36048: PUSH
36049: FOR_TO
36050: IFFALSE 37127
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
36052: LD_ADDR_EXP 99
36056: PUSH
36057: LD_EXP 99
36061: PPUSH
36062: LD_VAR 0 2
36066: PPUSH
36067: LD_EXP 99
36071: PUSH
36072: LD_VAR 0 2
36076: ARRAY
36077: PUSH
36078: LD_INT 0
36080: DIFF
36081: PPUSH
36082: CALL_OW 1
36086: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
36087: LD_ADDR_EXP 100
36091: PUSH
36092: LD_EXP 100
36096: PPUSH
36097: LD_VAR 0 2
36101: PPUSH
36102: EMPTY
36103: PPUSH
36104: CALL_OW 1
36108: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
36109: LD_ADDR_EXP 101
36113: PUSH
36114: LD_EXP 101
36118: PPUSH
36119: LD_VAR 0 2
36123: PPUSH
36124: EMPTY
36125: PPUSH
36126: CALL_OW 1
36130: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
36131: LD_ADDR_EXP 102
36135: PUSH
36136: LD_EXP 102
36140: PPUSH
36141: LD_VAR 0 2
36145: PPUSH
36146: EMPTY
36147: PPUSH
36148: CALL_OW 1
36152: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
36153: LD_ADDR_EXP 103
36157: PUSH
36158: LD_EXP 103
36162: PPUSH
36163: LD_VAR 0 2
36167: PPUSH
36168: EMPTY
36169: PUSH
36170: EMPTY
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PPUSH
36176: CALL_OW 1
36180: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
36181: LD_ADDR_EXP 104
36185: PUSH
36186: LD_EXP 104
36190: PPUSH
36191: LD_VAR 0 2
36195: PPUSH
36196: EMPTY
36197: PPUSH
36198: CALL_OW 1
36202: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
36203: LD_ADDR_EXP 131
36207: PUSH
36208: LD_EXP 131
36212: PPUSH
36213: LD_VAR 0 2
36217: PPUSH
36218: EMPTY
36219: PPUSH
36220: CALL_OW 1
36224: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
36225: LD_ADDR_EXP 105
36229: PUSH
36230: LD_EXP 105
36234: PPUSH
36235: LD_VAR 0 2
36239: PPUSH
36240: EMPTY
36241: PPUSH
36242: CALL_OW 1
36246: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
36247: LD_ADDR_EXP 106
36251: PUSH
36252: LD_EXP 106
36256: PPUSH
36257: LD_VAR 0 2
36261: PPUSH
36262: EMPTY
36263: PPUSH
36264: CALL_OW 1
36268: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
36269: LD_ADDR_EXP 107
36273: PUSH
36274: LD_EXP 107
36278: PPUSH
36279: LD_VAR 0 2
36283: PPUSH
36284: LD_EXP 99
36288: PUSH
36289: LD_VAR 0 2
36293: ARRAY
36294: PPUSH
36295: LD_INT 2
36297: PUSH
36298: LD_INT 30
36300: PUSH
36301: LD_INT 32
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 30
36310: PUSH
36311: LD_INT 33
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: LIST
36322: PPUSH
36323: CALL_OW 72
36327: PPUSH
36328: CALL_OW 1
36332: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
36333: LD_ADDR_EXP 108
36337: PUSH
36338: LD_EXP 108
36342: PPUSH
36343: LD_VAR 0 2
36347: PPUSH
36348: LD_EXP 99
36352: PUSH
36353: LD_VAR 0 2
36357: ARRAY
36358: PPUSH
36359: LD_INT 2
36361: PUSH
36362: LD_INT 30
36364: PUSH
36365: LD_INT 32
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 30
36374: PUSH
36375: LD_INT 31
36377: PUSH
36378: EMPTY
36379: LIST
36380: LIST
36381: PUSH
36382: EMPTY
36383: LIST
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 58
36389: PUSH
36390: EMPTY
36391: LIST
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PPUSH
36397: CALL_OW 72
36401: PPUSH
36402: CALL_OW 1
36406: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
36407: LD_ADDR_EXP 109
36411: PUSH
36412: LD_EXP 109
36416: PPUSH
36417: LD_VAR 0 2
36421: PPUSH
36422: EMPTY
36423: PPUSH
36424: CALL_OW 1
36428: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
36429: LD_ADDR_EXP 113
36433: PUSH
36434: LD_EXP 113
36438: PPUSH
36439: LD_VAR 0 2
36443: PPUSH
36444: EMPTY
36445: PPUSH
36446: CALL_OW 1
36450: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
36451: LD_ADDR_EXP 112
36455: PUSH
36456: LD_EXP 112
36460: PPUSH
36461: LD_VAR 0 2
36465: PPUSH
36466: EMPTY
36467: PPUSH
36468: CALL_OW 1
36472: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
36473: LD_ADDR_EXP 114
36477: PUSH
36478: LD_EXP 114
36482: PPUSH
36483: LD_VAR 0 2
36487: PPUSH
36488: EMPTY
36489: PPUSH
36490: CALL_OW 1
36494: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
36495: LD_ADDR_EXP 115
36499: PUSH
36500: LD_EXP 115
36504: PPUSH
36505: LD_VAR 0 2
36509: PPUSH
36510: EMPTY
36511: PPUSH
36512: CALL_OW 1
36516: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
36517: LD_ADDR_EXP 116
36521: PUSH
36522: LD_EXP 116
36526: PPUSH
36527: LD_VAR 0 2
36531: PPUSH
36532: EMPTY
36533: PPUSH
36534: CALL_OW 1
36538: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
36539: LD_ADDR_EXP 117
36543: PUSH
36544: LD_EXP 117
36548: PPUSH
36549: LD_VAR 0 2
36553: PPUSH
36554: EMPTY
36555: PPUSH
36556: CALL_OW 1
36560: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
36561: LD_ADDR_EXP 118
36565: PUSH
36566: LD_EXP 118
36570: PPUSH
36571: LD_VAR 0 2
36575: PPUSH
36576: EMPTY
36577: PPUSH
36578: CALL_OW 1
36582: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
36583: LD_ADDR_EXP 119
36587: PUSH
36588: LD_EXP 119
36592: PPUSH
36593: LD_VAR 0 2
36597: PPUSH
36598: EMPTY
36599: PPUSH
36600: CALL_OW 1
36604: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
36605: LD_ADDR_EXP 120
36609: PUSH
36610: LD_EXP 120
36614: PPUSH
36615: LD_VAR 0 2
36619: PPUSH
36620: EMPTY
36621: PPUSH
36622: CALL_OW 1
36626: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
36627: LD_ADDR_EXP 121
36631: PUSH
36632: LD_EXP 121
36636: PPUSH
36637: LD_VAR 0 2
36641: PPUSH
36642: EMPTY
36643: PPUSH
36644: CALL_OW 1
36648: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
36649: LD_ADDR_EXP 110
36653: PUSH
36654: LD_EXP 110
36658: PPUSH
36659: LD_VAR 0 2
36663: PPUSH
36664: LD_INT 0
36666: PPUSH
36667: CALL_OW 1
36671: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
36672: LD_ADDR_EXP 123
36676: PUSH
36677: LD_EXP 123
36681: PPUSH
36682: LD_VAR 0 2
36686: PPUSH
36687: LD_INT 0
36689: PPUSH
36690: CALL_OW 1
36694: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36695: LD_ADDR_EXP 111
36699: PUSH
36700: LD_EXP 111
36704: PPUSH
36705: LD_VAR 0 2
36709: PPUSH
36710: EMPTY
36711: PPUSH
36712: CALL_OW 1
36716: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
36717: LD_ADDR_EXP 122
36721: PUSH
36722: LD_EXP 122
36726: PPUSH
36727: LD_VAR 0 2
36731: PPUSH
36732: LD_INT 0
36734: PPUSH
36735: CALL_OW 1
36739: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
36740: LD_ADDR_EXP 124
36744: PUSH
36745: LD_EXP 124
36749: PPUSH
36750: LD_VAR 0 2
36754: PPUSH
36755: EMPTY
36756: PPUSH
36757: CALL_OW 1
36761: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
36762: LD_ADDR_EXP 127
36766: PUSH
36767: LD_EXP 127
36771: PPUSH
36772: LD_VAR 0 2
36776: PPUSH
36777: LD_INT 0
36779: PPUSH
36780: CALL_OW 1
36784: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
36785: LD_ADDR_EXP 128
36789: PUSH
36790: LD_EXP 128
36794: PPUSH
36795: LD_VAR 0 2
36799: PPUSH
36800: EMPTY
36801: PPUSH
36802: CALL_OW 1
36806: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
36807: LD_ADDR_EXP 129
36811: PUSH
36812: LD_EXP 129
36816: PPUSH
36817: LD_VAR 0 2
36821: PPUSH
36822: EMPTY
36823: PPUSH
36824: CALL_OW 1
36828: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36829: LD_ADDR_EXP 130
36833: PUSH
36834: LD_EXP 130
36838: PPUSH
36839: LD_VAR 0 2
36843: PPUSH
36844: EMPTY
36845: PPUSH
36846: CALL_OW 1
36850: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
36851: LD_ADDR_EXP 132
36855: PUSH
36856: LD_EXP 132
36860: PPUSH
36861: LD_VAR 0 2
36865: PPUSH
36866: LD_EXP 99
36870: PUSH
36871: LD_VAR 0 2
36875: ARRAY
36876: PPUSH
36877: LD_INT 2
36879: PUSH
36880: LD_INT 30
36882: PUSH
36883: LD_INT 6
36885: PUSH
36886: EMPTY
36887: LIST
36888: LIST
36889: PUSH
36890: LD_INT 30
36892: PUSH
36893: LD_INT 7
36895: PUSH
36896: EMPTY
36897: LIST
36898: LIST
36899: PUSH
36900: LD_INT 30
36902: PUSH
36903: LD_INT 8
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: LIST
36914: LIST
36915: PPUSH
36916: CALL_OW 72
36920: PPUSH
36921: CALL_OW 1
36925: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
36926: LD_ADDR_EXP 133
36930: PUSH
36931: LD_EXP 133
36935: PPUSH
36936: LD_VAR 0 2
36940: PPUSH
36941: EMPTY
36942: PPUSH
36943: CALL_OW 1
36947: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
36948: LD_ADDR_EXP 134
36952: PUSH
36953: LD_EXP 134
36957: PPUSH
36958: LD_VAR 0 2
36962: PPUSH
36963: EMPTY
36964: PPUSH
36965: CALL_OW 1
36969: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
36970: LD_ADDR_EXP 135
36974: PUSH
36975: LD_EXP 135
36979: PPUSH
36980: LD_VAR 0 2
36984: PPUSH
36985: EMPTY
36986: PPUSH
36987: CALL_OW 1
36991: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
36992: LD_ADDR_EXP 136
36996: PUSH
36997: LD_EXP 136
37001: PPUSH
37002: LD_VAR 0 2
37006: PPUSH
37007: EMPTY
37008: PPUSH
37009: CALL_OW 1
37013: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
37014: LD_ADDR_EXP 137
37018: PUSH
37019: LD_EXP 137
37023: PPUSH
37024: LD_VAR 0 2
37028: PPUSH
37029: EMPTY
37030: PPUSH
37031: CALL_OW 1
37035: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
37036: LD_ADDR_EXP 138
37040: PUSH
37041: LD_EXP 138
37045: PPUSH
37046: LD_VAR 0 2
37050: PPUSH
37051: EMPTY
37052: PPUSH
37053: CALL_OW 1
37057: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
37058: LD_ADDR_EXP 139
37062: PUSH
37063: LD_EXP 139
37067: PPUSH
37068: LD_VAR 0 2
37072: PPUSH
37073: EMPTY
37074: PPUSH
37075: CALL_OW 1
37079: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
37080: LD_ADDR_EXP 140
37084: PUSH
37085: LD_EXP 140
37089: PPUSH
37090: LD_VAR 0 2
37094: PPUSH
37095: EMPTY
37096: PPUSH
37097: CALL_OW 1
37101: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
37102: LD_ADDR_EXP 141
37106: PUSH
37107: LD_EXP 141
37111: PPUSH
37112: LD_VAR 0 2
37116: PPUSH
37117: LD_INT 0
37119: PPUSH
37120: CALL_OW 1
37124: ST_TO_ADDR
// end ;
37125: GO 36049
37127: POP
37128: POP
// MC_InitSides ( ) ;
37129: CALL 37415 0 0
// MC_InitResearch ( ) ;
37133: CALL 37154 0 0
// CustomInitMacro ( ) ;
37137: CALL 444 0 0
// skirmish := true ;
37141: LD_ADDR_EXP 97
37145: PUSH
37146: LD_INT 1
37148: ST_TO_ADDR
// end ;
37149: LD_VAR 0 1
37153: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
37154: LD_INT 0
37156: PPUSH
37157: PPUSH
37158: PPUSH
37159: PPUSH
37160: PPUSH
37161: PPUSH
// if not mc_bases then
37162: LD_EXP 99
37166: NOT
37167: IFFALSE 37171
// exit ;
37169: GO 37410
// for i = 1 to 8 do
37171: LD_ADDR_VAR 0 2
37175: PUSH
37176: DOUBLE
37177: LD_INT 1
37179: DEC
37180: ST_TO_ADDR
37181: LD_INT 8
37183: PUSH
37184: FOR_TO
37185: IFFALSE 37211
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
37187: LD_ADDR_EXP 126
37191: PUSH
37192: LD_EXP 126
37196: PPUSH
37197: LD_VAR 0 2
37201: PPUSH
37202: EMPTY
37203: PPUSH
37204: CALL_OW 1
37208: ST_TO_ADDR
37209: GO 37184
37211: POP
37212: POP
// tmp := [ ] ;
37213: LD_ADDR_VAR 0 5
37217: PUSH
37218: EMPTY
37219: ST_TO_ADDR
// for i = 1 to mc_sides do
37220: LD_ADDR_VAR 0 2
37224: PUSH
37225: DOUBLE
37226: LD_INT 1
37228: DEC
37229: ST_TO_ADDR
37230: LD_EXP 125
37234: PUSH
37235: FOR_TO
37236: IFFALSE 37294
// if not mc_sides [ i ] in tmp then
37238: LD_EXP 125
37242: PUSH
37243: LD_VAR 0 2
37247: ARRAY
37248: PUSH
37249: LD_VAR 0 5
37253: IN
37254: NOT
37255: IFFALSE 37292
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
37257: LD_ADDR_VAR 0 5
37261: PUSH
37262: LD_VAR 0 5
37266: PPUSH
37267: LD_VAR 0 5
37271: PUSH
37272: LD_INT 1
37274: PLUS
37275: PPUSH
37276: LD_EXP 125
37280: PUSH
37281: LD_VAR 0 2
37285: ARRAY
37286: PPUSH
37287: CALL_OW 2
37291: ST_TO_ADDR
37292: GO 37235
37294: POP
37295: POP
// if not tmp then
37296: LD_VAR 0 5
37300: NOT
37301: IFFALSE 37305
// exit ;
37303: GO 37410
// for j in tmp do
37305: LD_ADDR_VAR 0 3
37309: PUSH
37310: LD_VAR 0 5
37314: PUSH
37315: FOR_IN
37316: IFFALSE 37408
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
37318: LD_ADDR_VAR 0 6
37322: PUSH
37323: LD_INT 22
37325: PUSH
37326: LD_VAR 0 3
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PPUSH
37335: CALL_OW 69
37339: ST_TO_ADDR
// if not un then
37340: LD_VAR 0 6
37344: NOT
37345: IFFALSE 37349
// continue ;
37347: GO 37315
// nation := GetNation ( un [ 1 ] ) ;
37349: LD_ADDR_VAR 0 4
37353: PUSH
37354: LD_VAR 0 6
37358: PUSH
37359: LD_INT 1
37361: ARRAY
37362: PPUSH
37363: CALL_OW 248
37367: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
37368: LD_ADDR_EXP 126
37372: PUSH
37373: LD_EXP 126
37377: PPUSH
37378: LD_VAR 0 3
37382: PPUSH
37383: LD_VAR 0 3
37387: PPUSH
37388: LD_VAR 0 4
37392: PPUSH
37393: LD_INT 1
37395: PPUSH
37396: CALL 64124 0 3
37400: PPUSH
37401: CALL_OW 1
37405: ST_TO_ADDR
// end ;
37406: GO 37315
37408: POP
37409: POP
// end ;
37410: LD_VAR 0 1
37414: RET
// export function MC_InitSides ( ) ; var i ; begin
37415: LD_INT 0
37417: PPUSH
37418: PPUSH
// if not mc_bases then
37419: LD_EXP 99
37423: NOT
37424: IFFALSE 37428
// exit ;
37426: GO 37502
// for i = 1 to mc_bases do
37428: LD_ADDR_VAR 0 2
37432: PUSH
37433: DOUBLE
37434: LD_INT 1
37436: DEC
37437: ST_TO_ADDR
37438: LD_EXP 99
37442: PUSH
37443: FOR_TO
37444: IFFALSE 37500
// if mc_bases [ i ] then
37446: LD_EXP 99
37450: PUSH
37451: LD_VAR 0 2
37455: ARRAY
37456: IFFALSE 37498
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
37458: LD_ADDR_EXP 125
37462: PUSH
37463: LD_EXP 125
37467: PPUSH
37468: LD_VAR 0 2
37472: PPUSH
37473: LD_EXP 99
37477: PUSH
37478: LD_VAR 0 2
37482: ARRAY
37483: PUSH
37484: LD_INT 1
37486: ARRAY
37487: PPUSH
37488: CALL_OW 255
37492: PPUSH
37493: CALL_OW 1
37497: ST_TO_ADDR
37498: GO 37443
37500: POP
37501: POP
// end ;
37502: LD_VAR 0 1
37506: RET
// every 0 0$01 trigger skirmish do
37507: LD_EXP 97
37511: IFFALSE 37665
37513: GO 37515
37515: DISABLE
// begin enable ;
37516: ENABLE
// MC_CheckBuildings ( ) ;
37517: CALL 42163 0 0
// MC_CheckPeopleLife ( ) ;
37521: CALL 42288 0 0
// RaiseSailEvent ( 100 ) ;
37525: LD_INT 100
37527: PPUSH
37528: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
37532: LD_INT 103
37534: PPUSH
37535: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
37539: LD_INT 104
37541: PPUSH
37542: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
37546: LD_INT 105
37548: PPUSH
37549: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
37553: LD_INT 106
37555: PPUSH
37556: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
37560: LD_INT 107
37562: PPUSH
37563: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
37567: LD_INT 108
37569: PPUSH
37570: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
37574: LD_INT 109
37576: PPUSH
37577: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
37581: LD_INT 110
37583: PPUSH
37584: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
37588: LD_INT 111
37590: PPUSH
37591: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
37595: LD_INT 112
37597: PPUSH
37598: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
37602: LD_INT 113
37604: PPUSH
37605: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
37609: LD_INT 120
37611: PPUSH
37612: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
37616: LD_INT 121
37618: PPUSH
37619: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
37623: LD_INT 122
37625: PPUSH
37626: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
37630: LD_INT 123
37632: PPUSH
37633: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
37637: LD_INT 124
37639: PPUSH
37640: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
37644: LD_INT 125
37646: PPUSH
37647: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
37651: LD_INT 126
37653: PPUSH
37654: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
37658: LD_INT 200
37660: PPUSH
37661: CALL_OW 427
// end ;
37665: END
// on SailEvent ( event ) do begin if event < 100 then
37666: LD_VAR 0 1
37670: PUSH
37671: LD_INT 100
37673: LESS
37674: IFFALSE 37685
// CustomEvent ( event ) ;
37676: LD_VAR 0 1
37680: PPUSH
37681: CALL 32348 0 1
// if event = 100 then
37685: LD_VAR 0 1
37689: PUSH
37690: LD_INT 100
37692: EQUAL
37693: IFFALSE 37699
// MC_ClassManager ( ) ;
37695: CALL 38091 0 0
// if event = 101 then
37699: LD_VAR 0 1
37703: PUSH
37704: LD_INT 101
37706: EQUAL
37707: IFFALSE 37713
// MC_RepairBuildings ( ) ;
37709: CALL 42884 0 0
// if event = 102 then
37713: LD_VAR 0 1
37717: PUSH
37718: LD_INT 102
37720: EQUAL
37721: IFFALSE 37727
// MC_Heal ( ) ;
37723: CALL 43616 0 0
// if event = 103 then
37727: LD_VAR 0 1
37731: PUSH
37732: LD_INT 103
37734: EQUAL
37735: IFFALSE 37741
// MC_Build ( ) ;
37737: CALL 44038 0 0
// if event = 104 then
37741: LD_VAR 0 1
37745: PUSH
37746: LD_INT 104
37748: EQUAL
37749: IFFALSE 37755
// MC_TurretWeapon ( ) ;
37751: CALL 45651 0 0
// if event = 105 then
37755: LD_VAR 0 1
37759: PUSH
37760: LD_INT 105
37762: EQUAL
37763: IFFALSE 37769
// MC_BuildUpgrade ( ) ;
37765: CALL 45202 0 0
// if event = 106 then
37769: LD_VAR 0 1
37773: PUSH
37774: LD_INT 106
37776: EQUAL
37777: IFFALSE 37783
// MC_PlantMines ( ) ;
37779: CALL 46081 0 0
// if event = 107 then
37783: LD_VAR 0 1
37787: PUSH
37788: LD_INT 107
37790: EQUAL
37791: IFFALSE 37797
// MC_CollectCrates ( ) ;
37793: CALL 47115 0 0
// if event = 108 then
37797: LD_VAR 0 1
37801: PUSH
37802: LD_INT 108
37804: EQUAL
37805: IFFALSE 37811
// MC_LinkRemoteControl ( ) ;
37807: CALL 48891 0 0
// if event = 109 then
37811: LD_VAR 0 1
37815: PUSH
37816: LD_INT 109
37818: EQUAL
37819: IFFALSE 37825
// MC_ProduceVehicle ( ) ;
37821: CALL 49072 0 0
// if event = 110 then
37825: LD_VAR 0 1
37829: PUSH
37830: LD_INT 110
37832: EQUAL
37833: IFFALSE 37839
// MC_SendAttack ( ) ;
37835: CALL 49538 0 0
// if event = 111 then
37839: LD_VAR 0 1
37843: PUSH
37844: LD_INT 111
37846: EQUAL
37847: IFFALSE 37853
// MC_Defend ( ) ;
37849: CALL 49646 0 0
// if event = 112 then
37853: LD_VAR 0 1
37857: PUSH
37858: LD_INT 112
37860: EQUAL
37861: IFFALSE 37867
// MC_Research ( ) ;
37863: CALL 50251 0 0
// if event = 113 then
37867: LD_VAR 0 1
37871: PUSH
37872: LD_INT 113
37874: EQUAL
37875: IFFALSE 37881
// MC_MinesTrigger ( ) ;
37877: CALL 51365 0 0
// if event = 120 then
37881: LD_VAR 0 1
37885: PUSH
37886: LD_INT 120
37888: EQUAL
37889: IFFALSE 37895
// MC_RepairVehicle ( ) ;
37891: CALL 51464 0 0
// if event = 121 then
37895: LD_VAR 0 1
37899: PUSH
37900: LD_INT 121
37902: EQUAL
37903: IFFALSE 37909
// MC_TameApe ( ) ;
37905: CALL 52194 0 0
// if event = 122 then
37909: LD_VAR 0 1
37913: PUSH
37914: LD_INT 122
37916: EQUAL
37917: IFFALSE 37923
// MC_ChangeApeClass ( ) ;
37919: CALL 53023 0 0
// if event = 123 then
37923: LD_VAR 0 1
37927: PUSH
37928: LD_INT 123
37930: EQUAL
37931: IFFALSE 37937
// MC_Bazooka ( ) ;
37933: CALL 53673 0 0
// if event = 124 then
37937: LD_VAR 0 1
37941: PUSH
37942: LD_INT 124
37944: EQUAL
37945: IFFALSE 37951
// MC_TeleportExit ( ) ;
37947: CALL 53871 0 0
// if event = 125 then
37951: LD_VAR 0 1
37955: PUSH
37956: LD_INT 125
37958: EQUAL
37959: IFFALSE 37965
// MC_Deposits ( ) ;
37961: CALL 54518 0 0
// if event = 126 then
37965: LD_VAR 0 1
37969: PUSH
37970: LD_INT 126
37972: EQUAL
37973: IFFALSE 37979
// MC_RemoteDriver ( ) ;
37975: CALL 55143 0 0
// if event = 200 then
37979: LD_VAR 0 1
37983: PUSH
37984: LD_INT 200
37986: EQUAL
37987: IFFALSE 37993
// MC_Idle ( ) ;
37989: CALL 57092 0 0
// end ;
37993: PPOPN 1
37995: END
// export function MC_Reset ( base , tag ) ; var i ; begin
37996: LD_INT 0
37998: PPUSH
37999: PPUSH
// if not mc_bases [ base ] or not tag then
38000: LD_EXP 99
38004: PUSH
38005: LD_VAR 0 1
38009: ARRAY
38010: NOT
38011: PUSH
38012: LD_VAR 0 2
38016: NOT
38017: OR
38018: IFFALSE 38022
// exit ;
38020: GO 38086
// for i in mc_bases [ base ] union mc_ape [ base ] do
38022: LD_ADDR_VAR 0 4
38026: PUSH
38027: LD_EXP 99
38031: PUSH
38032: LD_VAR 0 1
38036: ARRAY
38037: PUSH
38038: LD_EXP 128
38042: PUSH
38043: LD_VAR 0 1
38047: ARRAY
38048: UNION
38049: PUSH
38050: FOR_IN
38051: IFFALSE 38084
// if GetTag ( i ) = tag then
38053: LD_VAR 0 4
38057: PPUSH
38058: CALL_OW 110
38062: PUSH
38063: LD_VAR 0 2
38067: EQUAL
38068: IFFALSE 38082
// SetTag ( i , 0 ) ;
38070: LD_VAR 0 4
38074: PPUSH
38075: LD_INT 0
38077: PPUSH
38078: CALL_OW 109
38082: GO 38050
38084: POP
38085: POP
// end ;
38086: LD_VAR 0 3
38090: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
38091: LD_INT 0
38093: PPUSH
38094: PPUSH
38095: PPUSH
38096: PPUSH
38097: PPUSH
38098: PPUSH
38099: PPUSH
38100: PPUSH
// if not mc_bases then
38101: LD_EXP 99
38105: NOT
38106: IFFALSE 38110
// exit ;
38108: GO 38568
// for i = 1 to mc_bases do
38110: LD_ADDR_VAR 0 2
38114: PUSH
38115: DOUBLE
38116: LD_INT 1
38118: DEC
38119: ST_TO_ADDR
38120: LD_EXP 99
38124: PUSH
38125: FOR_TO
38126: IFFALSE 38566
// begin tmp := MC_ClassCheckReq ( i ) ;
38128: LD_ADDR_VAR 0 4
38132: PUSH
38133: LD_VAR 0 2
38137: PPUSH
38138: CALL 38573 0 1
38142: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
38143: LD_ADDR_EXP 140
38147: PUSH
38148: LD_EXP 140
38152: PPUSH
38153: LD_VAR 0 2
38157: PPUSH
38158: LD_VAR 0 4
38162: PPUSH
38163: CALL_OW 1
38167: ST_TO_ADDR
// if not tmp then
38168: LD_VAR 0 4
38172: NOT
38173: IFFALSE 38177
// continue ;
38175: GO 38125
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
38177: LD_ADDR_VAR 0 6
38181: PUSH
38182: LD_EXP 99
38186: PUSH
38187: LD_VAR 0 2
38191: ARRAY
38192: PPUSH
38193: LD_INT 2
38195: PUSH
38196: LD_INT 30
38198: PUSH
38199: LD_INT 4
38201: PUSH
38202: EMPTY
38203: LIST
38204: LIST
38205: PUSH
38206: LD_INT 30
38208: PUSH
38209: LD_INT 5
38211: PUSH
38212: EMPTY
38213: LIST
38214: LIST
38215: PUSH
38216: EMPTY
38217: LIST
38218: LIST
38219: LIST
38220: PPUSH
38221: CALL_OW 72
38225: PUSH
38226: LD_EXP 99
38230: PUSH
38231: LD_VAR 0 2
38235: ARRAY
38236: PPUSH
38237: LD_INT 2
38239: PUSH
38240: LD_INT 30
38242: PUSH
38243: LD_INT 0
38245: PUSH
38246: EMPTY
38247: LIST
38248: LIST
38249: PUSH
38250: LD_INT 30
38252: PUSH
38253: LD_INT 1
38255: PUSH
38256: EMPTY
38257: LIST
38258: LIST
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: LIST
38264: PPUSH
38265: CALL_OW 72
38269: PUSH
38270: LD_EXP 99
38274: PUSH
38275: LD_VAR 0 2
38279: ARRAY
38280: PPUSH
38281: LD_INT 30
38283: PUSH
38284: LD_INT 3
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: PPUSH
38291: CALL_OW 72
38295: PUSH
38296: LD_EXP 99
38300: PUSH
38301: LD_VAR 0 2
38305: ARRAY
38306: PPUSH
38307: LD_INT 2
38309: PUSH
38310: LD_INT 30
38312: PUSH
38313: LD_INT 6
38315: PUSH
38316: EMPTY
38317: LIST
38318: LIST
38319: PUSH
38320: LD_INT 30
38322: PUSH
38323: LD_INT 7
38325: PUSH
38326: EMPTY
38327: LIST
38328: LIST
38329: PUSH
38330: LD_INT 30
38332: PUSH
38333: LD_INT 8
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: EMPTY
38341: LIST
38342: LIST
38343: LIST
38344: LIST
38345: PPUSH
38346: CALL_OW 72
38350: PUSH
38351: EMPTY
38352: LIST
38353: LIST
38354: LIST
38355: LIST
38356: ST_TO_ADDR
// for j = 1 to 4 do
38357: LD_ADDR_VAR 0 3
38361: PUSH
38362: DOUBLE
38363: LD_INT 1
38365: DEC
38366: ST_TO_ADDR
38367: LD_INT 4
38369: PUSH
38370: FOR_TO
38371: IFFALSE 38562
// begin if not tmp [ j ] then
38373: LD_VAR 0 4
38377: PUSH
38378: LD_VAR 0 3
38382: ARRAY
38383: NOT
38384: IFFALSE 38388
// continue ;
38386: GO 38370
// for p in tmp [ j ] do
38388: LD_ADDR_VAR 0 5
38392: PUSH
38393: LD_VAR 0 4
38397: PUSH
38398: LD_VAR 0 3
38402: ARRAY
38403: PUSH
38404: FOR_IN
38405: IFFALSE 38558
// begin if not b [ j ] then
38407: LD_VAR 0 6
38411: PUSH
38412: LD_VAR 0 3
38416: ARRAY
38417: NOT
38418: IFFALSE 38422
// break ;
38420: GO 38558
// e := 0 ;
38422: LD_ADDR_VAR 0 7
38426: PUSH
38427: LD_INT 0
38429: ST_TO_ADDR
// for k in b [ j ] do
38430: LD_ADDR_VAR 0 8
38434: PUSH
38435: LD_VAR 0 6
38439: PUSH
38440: LD_VAR 0 3
38444: ARRAY
38445: PUSH
38446: FOR_IN
38447: IFFALSE 38474
// if IsNotFull ( k ) then
38449: LD_VAR 0 8
38453: PPUSH
38454: CALL 68475 0 1
38458: IFFALSE 38472
// begin e := k ;
38460: LD_ADDR_VAR 0 7
38464: PUSH
38465: LD_VAR 0 8
38469: ST_TO_ADDR
// break ;
38470: GO 38474
// end ;
38472: GO 38446
38474: POP
38475: POP
// if e and not UnitGoingToBuilding ( p , e ) then
38476: LD_VAR 0 7
38480: PUSH
38481: LD_VAR 0 5
38485: PPUSH
38486: LD_VAR 0 7
38490: PPUSH
38491: CALL 105594 0 2
38495: NOT
38496: AND
38497: IFFALSE 38556
// begin if IsInUnit ( p ) then
38499: LD_VAR 0 5
38503: PPUSH
38504: CALL_OW 310
38508: IFFALSE 38519
// ComExitBuilding ( p ) ;
38510: LD_VAR 0 5
38514: PPUSH
38515: CALL_OW 122
// ComEnterUnit ( p , e ) ;
38519: LD_VAR 0 5
38523: PPUSH
38524: LD_VAR 0 7
38528: PPUSH
38529: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
38533: LD_VAR 0 5
38537: PPUSH
38538: LD_VAR 0 3
38542: PPUSH
38543: CALL_OW 183
// AddComExitBuilding ( p ) ;
38547: LD_VAR 0 5
38551: PPUSH
38552: CALL_OW 182
// end ; end ;
38556: GO 38404
38558: POP
38559: POP
// end ;
38560: GO 38370
38562: POP
38563: POP
// end ;
38564: GO 38125
38566: POP
38567: POP
// end ;
38568: LD_VAR 0 1
38572: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
38573: LD_INT 0
38575: PPUSH
38576: PPUSH
38577: PPUSH
38578: PPUSH
38579: PPUSH
38580: PPUSH
38581: PPUSH
38582: PPUSH
38583: PPUSH
38584: PPUSH
38585: PPUSH
38586: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38587: LD_VAR 0 1
38591: NOT
38592: PUSH
38593: LD_EXP 99
38597: PUSH
38598: LD_VAR 0 1
38602: ARRAY
38603: NOT
38604: OR
38605: PUSH
38606: LD_EXP 99
38610: PUSH
38611: LD_VAR 0 1
38615: ARRAY
38616: PPUSH
38617: LD_INT 2
38619: PUSH
38620: LD_INT 30
38622: PUSH
38623: LD_INT 0
38625: PUSH
38626: EMPTY
38627: LIST
38628: LIST
38629: PUSH
38630: LD_INT 30
38632: PUSH
38633: LD_INT 1
38635: PUSH
38636: EMPTY
38637: LIST
38638: LIST
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: LIST
38644: PPUSH
38645: CALL_OW 72
38649: NOT
38650: OR
38651: IFFALSE 38655
// exit ;
38653: GO 42158
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38655: LD_ADDR_VAR 0 4
38659: PUSH
38660: LD_EXP 99
38664: PUSH
38665: LD_VAR 0 1
38669: ARRAY
38670: PPUSH
38671: LD_INT 2
38673: PUSH
38674: LD_INT 25
38676: PUSH
38677: LD_INT 1
38679: PUSH
38680: EMPTY
38681: LIST
38682: LIST
38683: PUSH
38684: LD_INT 25
38686: PUSH
38687: LD_INT 2
38689: PUSH
38690: EMPTY
38691: LIST
38692: LIST
38693: PUSH
38694: LD_INT 25
38696: PUSH
38697: LD_INT 3
38699: PUSH
38700: EMPTY
38701: LIST
38702: LIST
38703: PUSH
38704: LD_INT 25
38706: PUSH
38707: LD_INT 4
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 25
38716: PUSH
38717: LD_INT 5
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: LD_INT 25
38726: PUSH
38727: LD_INT 8
38729: PUSH
38730: EMPTY
38731: LIST
38732: LIST
38733: PUSH
38734: LD_INT 25
38736: PUSH
38737: LD_INT 9
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PUSH
38744: EMPTY
38745: LIST
38746: LIST
38747: LIST
38748: LIST
38749: LIST
38750: LIST
38751: LIST
38752: LIST
38753: PPUSH
38754: CALL_OW 72
38758: ST_TO_ADDR
// if not tmp then
38759: LD_VAR 0 4
38763: NOT
38764: IFFALSE 38768
// exit ;
38766: GO 42158
// for i in tmp do
38768: LD_ADDR_VAR 0 3
38772: PUSH
38773: LD_VAR 0 4
38777: PUSH
38778: FOR_IN
38779: IFFALSE 38810
// if GetTag ( i ) then
38781: LD_VAR 0 3
38785: PPUSH
38786: CALL_OW 110
38790: IFFALSE 38808
// tmp := tmp diff i ;
38792: LD_ADDR_VAR 0 4
38796: PUSH
38797: LD_VAR 0 4
38801: PUSH
38802: LD_VAR 0 3
38806: DIFF
38807: ST_TO_ADDR
38808: GO 38778
38810: POP
38811: POP
// if not tmp then
38812: LD_VAR 0 4
38816: NOT
38817: IFFALSE 38821
// exit ;
38819: GO 42158
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
38821: LD_ADDR_VAR 0 5
38825: PUSH
38826: LD_EXP 99
38830: PUSH
38831: LD_VAR 0 1
38835: ARRAY
38836: PPUSH
38837: LD_INT 2
38839: PUSH
38840: LD_INT 25
38842: PUSH
38843: LD_INT 1
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 25
38852: PUSH
38853: LD_INT 5
38855: PUSH
38856: EMPTY
38857: LIST
38858: LIST
38859: PUSH
38860: LD_INT 25
38862: PUSH
38863: LD_INT 8
38865: PUSH
38866: EMPTY
38867: LIST
38868: LIST
38869: PUSH
38870: LD_INT 25
38872: PUSH
38873: LD_INT 9
38875: PUSH
38876: EMPTY
38877: LIST
38878: LIST
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: LIST
38884: LIST
38885: LIST
38886: PPUSH
38887: CALL_OW 72
38891: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
38892: LD_ADDR_VAR 0 6
38896: PUSH
38897: LD_EXP 99
38901: PUSH
38902: LD_VAR 0 1
38906: ARRAY
38907: PPUSH
38908: LD_INT 25
38910: PUSH
38911: LD_INT 2
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PPUSH
38918: CALL_OW 72
38922: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
38923: LD_ADDR_VAR 0 7
38927: PUSH
38928: LD_EXP 99
38932: PUSH
38933: LD_VAR 0 1
38937: ARRAY
38938: PPUSH
38939: LD_INT 25
38941: PUSH
38942: LD_INT 3
38944: PUSH
38945: EMPTY
38946: LIST
38947: LIST
38948: PPUSH
38949: CALL_OW 72
38953: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
38954: LD_ADDR_VAR 0 8
38958: PUSH
38959: LD_EXP 99
38963: PUSH
38964: LD_VAR 0 1
38968: ARRAY
38969: PPUSH
38970: LD_INT 25
38972: PUSH
38973: LD_INT 4
38975: PUSH
38976: EMPTY
38977: LIST
38978: LIST
38979: PUSH
38980: LD_INT 24
38982: PUSH
38983: LD_INT 251
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PUSH
38990: EMPTY
38991: LIST
38992: LIST
38993: PPUSH
38994: CALL_OW 72
38998: ST_TO_ADDR
// if mc_scan [ base ] then
38999: LD_EXP 122
39003: PUSH
39004: LD_VAR 0 1
39008: ARRAY
39009: IFFALSE 39470
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
39011: LD_ADDR_EXP 141
39015: PUSH
39016: LD_EXP 141
39020: PPUSH
39021: LD_VAR 0 1
39025: PPUSH
39026: LD_INT 4
39028: PPUSH
39029: CALL_OW 1
39033: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
39034: LD_ADDR_VAR 0 12
39038: PUSH
39039: LD_EXP 99
39043: PUSH
39044: LD_VAR 0 1
39048: ARRAY
39049: PPUSH
39050: LD_INT 2
39052: PUSH
39053: LD_INT 30
39055: PUSH
39056: LD_INT 4
39058: PUSH
39059: EMPTY
39060: LIST
39061: LIST
39062: PUSH
39063: LD_INT 30
39065: PUSH
39066: LD_INT 5
39068: PUSH
39069: EMPTY
39070: LIST
39071: LIST
39072: PUSH
39073: EMPTY
39074: LIST
39075: LIST
39076: LIST
39077: PPUSH
39078: CALL_OW 72
39082: ST_TO_ADDR
// if not b then
39083: LD_VAR 0 12
39087: NOT
39088: IFFALSE 39092
// exit ;
39090: GO 42158
// p := [ ] ;
39092: LD_ADDR_VAR 0 11
39096: PUSH
39097: EMPTY
39098: ST_TO_ADDR
// if sci >= 2 then
39099: LD_VAR 0 8
39103: PUSH
39104: LD_INT 2
39106: GREATEREQUAL
39107: IFFALSE 39138
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
39109: LD_ADDR_VAR 0 8
39113: PUSH
39114: LD_VAR 0 8
39118: PUSH
39119: LD_INT 1
39121: ARRAY
39122: PUSH
39123: LD_VAR 0 8
39127: PUSH
39128: LD_INT 2
39130: ARRAY
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: ST_TO_ADDR
39136: GO 39199
// if sci = 1 then
39138: LD_VAR 0 8
39142: PUSH
39143: LD_INT 1
39145: EQUAL
39146: IFFALSE 39167
// sci := [ sci [ 1 ] ] else
39148: LD_ADDR_VAR 0 8
39152: PUSH
39153: LD_VAR 0 8
39157: PUSH
39158: LD_INT 1
39160: ARRAY
39161: PUSH
39162: EMPTY
39163: LIST
39164: ST_TO_ADDR
39165: GO 39199
// if sci = 0 then
39167: LD_VAR 0 8
39171: PUSH
39172: LD_INT 0
39174: EQUAL
39175: IFFALSE 39199
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
39177: LD_ADDR_VAR 0 11
39181: PUSH
39182: LD_VAR 0 4
39186: PPUSH
39187: LD_INT 4
39189: PPUSH
39190: CALL 105457 0 2
39194: PUSH
39195: LD_INT 1
39197: ARRAY
39198: ST_TO_ADDR
// if eng > 4 then
39199: LD_VAR 0 6
39203: PUSH
39204: LD_INT 4
39206: GREATER
39207: IFFALSE 39253
// for i = eng downto 4 do
39209: LD_ADDR_VAR 0 3
39213: PUSH
39214: DOUBLE
39215: LD_VAR 0 6
39219: INC
39220: ST_TO_ADDR
39221: LD_INT 4
39223: PUSH
39224: FOR_DOWNTO
39225: IFFALSE 39251
// eng := eng diff eng [ i ] ;
39227: LD_ADDR_VAR 0 6
39231: PUSH
39232: LD_VAR 0 6
39236: PUSH
39237: LD_VAR 0 6
39241: PUSH
39242: LD_VAR 0 3
39246: ARRAY
39247: DIFF
39248: ST_TO_ADDR
39249: GO 39224
39251: POP
39252: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
39253: LD_ADDR_VAR 0 4
39257: PUSH
39258: LD_VAR 0 4
39262: PUSH
39263: LD_VAR 0 5
39267: PUSH
39268: LD_VAR 0 6
39272: UNION
39273: PUSH
39274: LD_VAR 0 7
39278: UNION
39279: PUSH
39280: LD_VAR 0 8
39284: UNION
39285: DIFF
39286: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
39287: LD_ADDR_VAR 0 13
39291: PUSH
39292: LD_EXP 99
39296: PUSH
39297: LD_VAR 0 1
39301: ARRAY
39302: PPUSH
39303: LD_INT 2
39305: PUSH
39306: LD_INT 30
39308: PUSH
39309: LD_INT 32
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: LD_INT 30
39318: PUSH
39319: LD_INT 31
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: EMPTY
39327: LIST
39328: LIST
39329: LIST
39330: PPUSH
39331: CALL_OW 72
39335: PUSH
39336: LD_EXP 99
39340: PUSH
39341: LD_VAR 0 1
39345: ARRAY
39346: PPUSH
39347: LD_INT 2
39349: PUSH
39350: LD_INT 30
39352: PUSH
39353: LD_INT 4
39355: PUSH
39356: EMPTY
39357: LIST
39358: LIST
39359: PUSH
39360: LD_INT 30
39362: PUSH
39363: LD_INT 5
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: EMPTY
39371: LIST
39372: LIST
39373: LIST
39374: PPUSH
39375: CALL_OW 72
39379: PUSH
39380: LD_INT 6
39382: MUL
39383: PLUS
39384: ST_TO_ADDR
// if bcount < tmp then
39385: LD_VAR 0 13
39389: PUSH
39390: LD_VAR 0 4
39394: LESS
39395: IFFALSE 39441
// for i = tmp downto bcount do
39397: LD_ADDR_VAR 0 3
39401: PUSH
39402: DOUBLE
39403: LD_VAR 0 4
39407: INC
39408: ST_TO_ADDR
39409: LD_VAR 0 13
39413: PUSH
39414: FOR_DOWNTO
39415: IFFALSE 39439
// tmp := Delete ( tmp , tmp ) ;
39417: LD_ADDR_VAR 0 4
39421: PUSH
39422: LD_VAR 0 4
39426: PPUSH
39427: LD_VAR 0 4
39431: PPUSH
39432: CALL_OW 3
39436: ST_TO_ADDR
39437: GO 39414
39439: POP
39440: POP
// result := [ tmp , 0 , 0 , p ] ;
39441: LD_ADDR_VAR 0 2
39445: PUSH
39446: LD_VAR 0 4
39450: PUSH
39451: LD_INT 0
39453: PUSH
39454: LD_INT 0
39456: PUSH
39457: LD_VAR 0 11
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: LIST
39466: LIST
39467: ST_TO_ADDR
// exit ;
39468: GO 42158
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39470: LD_EXP 99
39474: PUSH
39475: LD_VAR 0 1
39479: ARRAY
39480: PPUSH
39481: LD_INT 2
39483: PUSH
39484: LD_INT 30
39486: PUSH
39487: LD_INT 6
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: PUSH
39494: LD_INT 30
39496: PUSH
39497: LD_INT 7
39499: PUSH
39500: EMPTY
39501: LIST
39502: LIST
39503: PUSH
39504: LD_INT 30
39506: PUSH
39507: LD_INT 8
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: PPUSH
39520: CALL_OW 72
39524: NOT
39525: PUSH
39526: LD_EXP 99
39530: PUSH
39531: LD_VAR 0 1
39535: ARRAY
39536: PPUSH
39537: LD_INT 30
39539: PUSH
39540: LD_INT 3
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PPUSH
39547: CALL_OW 72
39551: NOT
39552: AND
39553: IFFALSE 39625
// begin if eng = tmp then
39555: LD_VAR 0 6
39559: PUSH
39560: LD_VAR 0 4
39564: EQUAL
39565: IFFALSE 39569
// exit ;
39567: GO 42158
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
39569: LD_ADDR_EXP 141
39573: PUSH
39574: LD_EXP 141
39578: PPUSH
39579: LD_VAR 0 1
39583: PPUSH
39584: LD_INT 1
39586: PPUSH
39587: CALL_OW 1
39591: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
39592: LD_ADDR_VAR 0 2
39596: PUSH
39597: LD_INT 0
39599: PUSH
39600: LD_VAR 0 4
39604: PUSH
39605: LD_VAR 0 6
39609: DIFF
39610: PUSH
39611: LD_INT 0
39613: PUSH
39614: LD_INT 0
39616: PUSH
39617: EMPTY
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: ST_TO_ADDR
// exit ;
39623: GO 42158
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39625: LD_EXP 126
39629: PUSH
39630: LD_EXP 125
39634: PUSH
39635: LD_VAR 0 1
39639: ARRAY
39640: ARRAY
39641: PUSH
39642: LD_EXP 99
39646: PUSH
39647: LD_VAR 0 1
39651: ARRAY
39652: PPUSH
39653: LD_INT 2
39655: PUSH
39656: LD_INT 30
39658: PUSH
39659: LD_INT 6
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: LD_INT 30
39668: PUSH
39669: LD_INT 7
39671: PUSH
39672: EMPTY
39673: LIST
39674: LIST
39675: PUSH
39676: LD_INT 30
39678: PUSH
39679: LD_INT 8
39681: PUSH
39682: EMPTY
39683: LIST
39684: LIST
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: LIST
39690: LIST
39691: PPUSH
39692: CALL_OW 72
39696: AND
39697: PUSH
39698: LD_EXP 99
39702: PUSH
39703: LD_VAR 0 1
39707: ARRAY
39708: PPUSH
39709: LD_INT 30
39711: PUSH
39712: LD_INT 3
39714: PUSH
39715: EMPTY
39716: LIST
39717: LIST
39718: PPUSH
39719: CALL_OW 72
39723: NOT
39724: AND
39725: IFFALSE 39939
// begin if sci >= 6 then
39727: LD_VAR 0 8
39731: PUSH
39732: LD_INT 6
39734: GREATEREQUAL
39735: IFFALSE 39739
// exit ;
39737: GO 42158
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
39739: LD_ADDR_EXP 141
39743: PUSH
39744: LD_EXP 141
39748: PPUSH
39749: LD_VAR 0 1
39753: PPUSH
39754: LD_INT 2
39756: PPUSH
39757: CALL_OW 1
39761: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
39762: LD_ADDR_VAR 0 9
39766: PUSH
39767: LD_VAR 0 4
39771: PUSH
39772: LD_VAR 0 8
39776: DIFF
39777: PPUSH
39778: LD_INT 4
39780: PPUSH
39781: CALL 105457 0 2
39785: ST_TO_ADDR
// p := [ ] ;
39786: LD_ADDR_VAR 0 11
39790: PUSH
39791: EMPTY
39792: ST_TO_ADDR
// if sci < 6 and sort > 6 then
39793: LD_VAR 0 8
39797: PUSH
39798: LD_INT 6
39800: LESS
39801: PUSH
39802: LD_VAR 0 9
39806: PUSH
39807: LD_INT 6
39809: GREATER
39810: AND
39811: IFFALSE 39892
// begin for i = 1 to 6 - sci do
39813: LD_ADDR_VAR 0 3
39817: PUSH
39818: DOUBLE
39819: LD_INT 1
39821: DEC
39822: ST_TO_ADDR
39823: LD_INT 6
39825: PUSH
39826: LD_VAR 0 8
39830: MINUS
39831: PUSH
39832: FOR_TO
39833: IFFALSE 39888
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
39835: LD_ADDR_VAR 0 11
39839: PUSH
39840: LD_VAR 0 11
39844: PPUSH
39845: LD_VAR 0 11
39849: PUSH
39850: LD_INT 1
39852: PLUS
39853: PPUSH
39854: LD_VAR 0 9
39858: PUSH
39859: LD_INT 1
39861: ARRAY
39862: PPUSH
39863: CALL_OW 2
39867: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
39868: LD_ADDR_VAR 0 9
39872: PUSH
39873: LD_VAR 0 9
39877: PPUSH
39878: LD_INT 1
39880: PPUSH
39881: CALL_OW 3
39885: ST_TO_ADDR
// end ;
39886: GO 39832
39888: POP
39889: POP
// end else
39890: GO 39912
// if sort then
39892: LD_VAR 0 9
39896: IFFALSE 39912
// p := sort [ 1 ] ;
39898: LD_ADDR_VAR 0 11
39902: PUSH
39903: LD_VAR 0 9
39907: PUSH
39908: LD_INT 1
39910: ARRAY
39911: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
39912: LD_ADDR_VAR 0 2
39916: PUSH
39917: LD_INT 0
39919: PUSH
39920: LD_INT 0
39922: PUSH
39923: LD_INT 0
39925: PUSH
39926: LD_VAR 0 11
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: LIST
39935: LIST
39936: ST_TO_ADDR
// exit ;
39937: GO 42158
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
39939: LD_EXP 126
39943: PUSH
39944: LD_EXP 125
39948: PUSH
39949: LD_VAR 0 1
39953: ARRAY
39954: ARRAY
39955: PUSH
39956: LD_EXP 99
39960: PUSH
39961: LD_VAR 0 1
39965: ARRAY
39966: PPUSH
39967: LD_INT 2
39969: PUSH
39970: LD_INT 30
39972: PUSH
39973: LD_INT 6
39975: PUSH
39976: EMPTY
39977: LIST
39978: LIST
39979: PUSH
39980: LD_INT 30
39982: PUSH
39983: LD_INT 7
39985: PUSH
39986: EMPTY
39987: LIST
39988: LIST
39989: PUSH
39990: LD_INT 30
39992: PUSH
39993: LD_INT 8
39995: PUSH
39996: EMPTY
39997: LIST
39998: LIST
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: PPUSH
40006: CALL_OW 72
40010: AND
40011: PUSH
40012: LD_EXP 99
40016: PUSH
40017: LD_VAR 0 1
40021: ARRAY
40022: PPUSH
40023: LD_INT 30
40025: PUSH
40026: LD_INT 3
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PPUSH
40033: CALL_OW 72
40037: AND
40038: IFFALSE 40772
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
40040: LD_ADDR_EXP 141
40044: PUSH
40045: LD_EXP 141
40049: PPUSH
40050: LD_VAR 0 1
40054: PPUSH
40055: LD_INT 3
40057: PPUSH
40058: CALL_OW 1
40062: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40063: LD_ADDR_VAR 0 2
40067: PUSH
40068: LD_INT 0
40070: PUSH
40071: LD_INT 0
40073: PUSH
40074: LD_INT 0
40076: PUSH
40077: LD_INT 0
40079: PUSH
40080: EMPTY
40081: LIST
40082: LIST
40083: LIST
40084: LIST
40085: ST_TO_ADDR
// if not eng then
40086: LD_VAR 0 6
40090: NOT
40091: IFFALSE 40154
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
40093: LD_ADDR_VAR 0 11
40097: PUSH
40098: LD_VAR 0 4
40102: PPUSH
40103: LD_INT 2
40105: PPUSH
40106: CALL 105457 0 2
40110: PUSH
40111: LD_INT 1
40113: ARRAY
40114: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
40115: LD_ADDR_VAR 0 2
40119: PUSH
40120: LD_VAR 0 2
40124: PPUSH
40125: LD_INT 2
40127: PPUSH
40128: LD_VAR 0 11
40132: PPUSH
40133: CALL_OW 1
40137: ST_TO_ADDR
// tmp := tmp diff p ;
40138: LD_ADDR_VAR 0 4
40142: PUSH
40143: LD_VAR 0 4
40147: PUSH
40148: LD_VAR 0 11
40152: DIFF
40153: ST_TO_ADDR
// end ; if tmp and sci < 6 then
40154: LD_VAR 0 4
40158: PUSH
40159: LD_VAR 0 8
40163: PUSH
40164: LD_INT 6
40166: LESS
40167: AND
40168: IFFALSE 40356
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
40170: LD_ADDR_VAR 0 9
40174: PUSH
40175: LD_VAR 0 4
40179: PUSH
40180: LD_VAR 0 8
40184: PUSH
40185: LD_VAR 0 7
40189: UNION
40190: DIFF
40191: PPUSH
40192: LD_INT 4
40194: PPUSH
40195: CALL 105457 0 2
40199: ST_TO_ADDR
// p := [ ] ;
40200: LD_ADDR_VAR 0 11
40204: PUSH
40205: EMPTY
40206: ST_TO_ADDR
// if sort then
40207: LD_VAR 0 9
40211: IFFALSE 40327
// for i = 1 to 6 - sci do
40213: LD_ADDR_VAR 0 3
40217: PUSH
40218: DOUBLE
40219: LD_INT 1
40221: DEC
40222: ST_TO_ADDR
40223: LD_INT 6
40225: PUSH
40226: LD_VAR 0 8
40230: MINUS
40231: PUSH
40232: FOR_TO
40233: IFFALSE 40325
// begin if i = sort then
40235: LD_VAR 0 3
40239: PUSH
40240: LD_VAR 0 9
40244: EQUAL
40245: IFFALSE 40249
// break ;
40247: GO 40325
// if GetClass ( i ) = 4 then
40249: LD_VAR 0 3
40253: PPUSH
40254: CALL_OW 257
40258: PUSH
40259: LD_INT 4
40261: EQUAL
40262: IFFALSE 40266
// continue ;
40264: GO 40232
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40266: LD_ADDR_VAR 0 11
40270: PUSH
40271: LD_VAR 0 11
40275: PPUSH
40276: LD_VAR 0 11
40280: PUSH
40281: LD_INT 1
40283: PLUS
40284: PPUSH
40285: LD_VAR 0 9
40289: PUSH
40290: LD_VAR 0 3
40294: ARRAY
40295: PPUSH
40296: CALL_OW 2
40300: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40301: LD_ADDR_VAR 0 4
40305: PUSH
40306: LD_VAR 0 4
40310: PUSH
40311: LD_VAR 0 9
40315: PUSH
40316: LD_VAR 0 3
40320: ARRAY
40321: DIFF
40322: ST_TO_ADDR
// end ;
40323: GO 40232
40325: POP
40326: POP
// if p then
40327: LD_VAR 0 11
40331: IFFALSE 40356
// result := Replace ( result , 4 , p ) ;
40333: LD_ADDR_VAR 0 2
40337: PUSH
40338: LD_VAR 0 2
40342: PPUSH
40343: LD_INT 4
40345: PPUSH
40346: LD_VAR 0 11
40350: PPUSH
40351: CALL_OW 1
40355: ST_TO_ADDR
// end ; if tmp and mech < 6 then
40356: LD_VAR 0 4
40360: PUSH
40361: LD_VAR 0 7
40365: PUSH
40366: LD_INT 6
40368: LESS
40369: AND
40370: IFFALSE 40558
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
40372: LD_ADDR_VAR 0 9
40376: PUSH
40377: LD_VAR 0 4
40381: PUSH
40382: LD_VAR 0 8
40386: PUSH
40387: LD_VAR 0 7
40391: UNION
40392: DIFF
40393: PPUSH
40394: LD_INT 3
40396: PPUSH
40397: CALL 105457 0 2
40401: ST_TO_ADDR
// p := [ ] ;
40402: LD_ADDR_VAR 0 11
40406: PUSH
40407: EMPTY
40408: ST_TO_ADDR
// if sort then
40409: LD_VAR 0 9
40413: IFFALSE 40529
// for i = 1 to 6 - mech do
40415: LD_ADDR_VAR 0 3
40419: PUSH
40420: DOUBLE
40421: LD_INT 1
40423: DEC
40424: ST_TO_ADDR
40425: LD_INT 6
40427: PUSH
40428: LD_VAR 0 7
40432: MINUS
40433: PUSH
40434: FOR_TO
40435: IFFALSE 40527
// begin if i = sort then
40437: LD_VAR 0 3
40441: PUSH
40442: LD_VAR 0 9
40446: EQUAL
40447: IFFALSE 40451
// break ;
40449: GO 40527
// if GetClass ( i ) = 3 then
40451: LD_VAR 0 3
40455: PPUSH
40456: CALL_OW 257
40460: PUSH
40461: LD_INT 3
40463: EQUAL
40464: IFFALSE 40468
// continue ;
40466: GO 40434
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40468: LD_ADDR_VAR 0 11
40472: PUSH
40473: LD_VAR 0 11
40477: PPUSH
40478: LD_VAR 0 11
40482: PUSH
40483: LD_INT 1
40485: PLUS
40486: PPUSH
40487: LD_VAR 0 9
40491: PUSH
40492: LD_VAR 0 3
40496: ARRAY
40497: PPUSH
40498: CALL_OW 2
40502: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40503: LD_ADDR_VAR 0 4
40507: PUSH
40508: LD_VAR 0 4
40512: PUSH
40513: LD_VAR 0 9
40517: PUSH
40518: LD_VAR 0 3
40522: ARRAY
40523: DIFF
40524: ST_TO_ADDR
// end ;
40525: GO 40434
40527: POP
40528: POP
// if p then
40529: LD_VAR 0 11
40533: IFFALSE 40558
// result := Replace ( result , 3 , p ) ;
40535: LD_ADDR_VAR 0 2
40539: PUSH
40540: LD_VAR 0 2
40544: PPUSH
40545: LD_INT 3
40547: PPUSH
40548: LD_VAR 0 11
40552: PPUSH
40553: CALL_OW 1
40557: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
40558: LD_VAR 0 4
40562: PUSH
40563: LD_INT 6
40565: GREATER
40566: PUSH
40567: LD_VAR 0 6
40571: PUSH
40572: LD_INT 6
40574: LESS
40575: AND
40576: IFFALSE 40770
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
40578: LD_ADDR_VAR 0 9
40582: PUSH
40583: LD_VAR 0 4
40587: PUSH
40588: LD_VAR 0 8
40592: PUSH
40593: LD_VAR 0 7
40597: UNION
40598: PUSH
40599: LD_VAR 0 6
40603: UNION
40604: DIFF
40605: PPUSH
40606: LD_INT 2
40608: PPUSH
40609: CALL 105457 0 2
40613: ST_TO_ADDR
// p := [ ] ;
40614: LD_ADDR_VAR 0 11
40618: PUSH
40619: EMPTY
40620: ST_TO_ADDR
// if sort then
40621: LD_VAR 0 9
40625: IFFALSE 40741
// for i = 1 to 6 - eng do
40627: LD_ADDR_VAR 0 3
40631: PUSH
40632: DOUBLE
40633: LD_INT 1
40635: DEC
40636: ST_TO_ADDR
40637: LD_INT 6
40639: PUSH
40640: LD_VAR 0 6
40644: MINUS
40645: PUSH
40646: FOR_TO
40647: IFFALSE 40739
// begin if i = sort then
40649: LD_VAR 0 3
40653: PUSH
40654: LD_VAR 0 9
40658: EQUAL
40659: IFFALSE 40663
// break ;
40661: GO 40739
// if GetClass ( i ) = 2 then
40663: LD_VAR 0 3
40667: PPUSH
40668: CALL_OW 257
40672: PUSH
40673: LD_INT 2
40675: EQUAL
40676: IFFALSE 40680
// continue ;
40678: GO 40646
// p := Insert ( p , p + 1 , sort [ i ] ) ;
40680: LD_ADDR_VAR 0 11
40684: PUSH
40685: LD_VAR 0 11
40689: PPUSH
40690: LD_VAR 0 11
40694: PUSH
40695: LD_INT 1
40697: PLUS
40698: PPUSH
40699: LD_VAR 0 9
40703: PUSH
40704: LD_VAR 0 3
40708: ARRAY
40709: PPUSH
40710: CALL_OW 2
40714: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
40715: LD_ADDR_VAR 0 4
40719: PUSH
40720: LD_VAR 0 4
40724: PUSH
40725: LD_VAR 0 9
40729: PUSH
40730: LD_VAR 0 3
40734: ARRAY
40735: DIFF
40736: ST_TO_ADDR
// end ;
40737: GO 40646
40739: POP
40740: POP
// if p then
40741: LD_VAR 0 11
40745: IFFALSE 40770
// result := Replace ( result , 2 , p ) ;
40747: LD_ADDR_VAR 0 2
40751: PUSH
40752: LD_VAR 0 2
40756: PPUSH
40757: LD_INT 2
40759: PPUSH
40760: LD_VAR 0 11
40764: PPUSH
40765: CALL_OW 1
40769: ST_TO_ADDR
// end ; exit ;
40770: GO 42158
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
40772: LD_EXP 126
40776: PUSH
40777: LD_EXP 125
40781: PUSH
40782: LD_VAR 0 1
40786: ARRAY
40787: ARRAY
40788: NOT
40789: PUSH
40790: LD_EXP 99
40794: PUSH
40795: LD_VAR 0 1
40799: ARRAY
40800: PPUSH
40801: LD_INT 30
40803: PUSH
40804: LD_INT 3
40806: PUSH
40807: EMPTY
40808: LIST
40809: LIST
40810: PPUSH
40811: CALL_OW 72
40815: AND
40816: PUSH
40817: LD_EXP 104
40821: PUSH
40822: LD_VAR 0 1
40826: ARRAY
40827: AND
40828: IFFALSE 41436
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
40830: LD_ADDR_EXP 141
40834: PUSH
40835: LD_EXP 141
40839: PPUSH
40840: LD_VAR 0 1
40844: PPUSH
40845: LD_INT 5
40847: PPUSH
40848: CALL_OW 1
40852: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
40853: LD_ADDR_VAR 0 2
40857: PUSH
40858: LD_INT 0
40860: PUSH
40861: LD_INT 0
40863: PUSH
40864: LD_INT 0
40866: PUSH
40867: LD_INT 0
40869: PUSH
40870: EMPTY
40871: LIST
40872: LIST
40873: LIST
40874: LIST
40875: ST_TO_ADDR
// if sci > 1 then
40876: LD_VAR 0 8
40880: PUSH
40881: LD_INT 1
40883: GREATER
40884: IFFALSE 40912
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
40886: LD_ADDR_VAR 0 4
40890: PUSH
40891: LD_VAR 0 4
40895: PUSH
40896: LD_VAR 0 8
40900: PUSH
40901: LD_VAR 0 8
40905: PUSH
40906: LD_INT 1
40908: ARRAY
40909: DIFF
40910: DIFF
40911: ST_TO_ADDR
// if tmp and not sci then
40912: LD_VAR 0 4
40916: PUSH
40917: LD_VAR 0 8
40921: NOT
40922: AND
40923: IFFALSE 40992
// begin sort := SortBySkill ( tmp , 4 ) ;
40925: LD_ADDR_VAR 0 9
40929: PUSH
40930: LD_VAR 0 4
40934: PPUSH
40935: LD_INT 4
40937: PPUSH
40938: CALL 105457 0 2
40942: ST_TO_ADDR
// if sort then
40943: LD_VAR 0 9
40947: IFFALSE 40963
// p := sort [ 1 ] ;
40949: LD_ADDR_VAR 0 11
40953: PUSH
40954: LD_VAR 0 9
40958: PUSH
40959: LD_INT 1
40961: ARRAY
40962: ST_TO_ADDR
// if p then
40963: LD_VAR 0 11
40967: IFFALSE 40992
// result := Replace ( result , 4 , p ) ;
40969: LD_ADDR_VAR 0 2
40973: PUSH
40974: LD_VAR 0 2
40978: PPUSH
40979: LD_INT 4
40981: PPUSH
40982: LD_VAR 0 11
40986: PPUSH
40987: CALL_OW 1
40991: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
40992: LD_ADDR_VAR 0 4
40996: PUSH
40997: LD_VAR 0 4
41001: PUSH
41002: LD_VAR 0 7
41006: DIFF
41007: ST_TO_ADDR
// if tmp and mech < 6 then
41008: LD_VAR 0 4
41012: PUSH
41013: LD_VAR 0 7
41017: PUSH
41018: LD_INT 6
41020: LESS
41021: AND
41022: IFFALSE 41210
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
41024: LD_ADDR_VAR 0 9
41028: PUSH
41029: LD_VAR 0 4
41033: PUSH
41034: LD_VAR 0 8
41038: PUSH
41039: LD_VAR 0 7
41043: UNION
41044: DIFF
41045: PPUSH
41046: LD_INT 3
41048: PPUSH
41049: CALL 105457 0 2
41053: ST_TO_ADDR
// p := [ ] ;
41054: LD_ADDR_VAR 0 11
41058: PUSH
41059: EMPTY
41060: ST_TO_ADDR
// if sort then
41061: LD_VAR 0 9
41065: IFFALSE 41181
// for i = 1 to 6 - mech do
41067: LD_ADDR_VAR 0 3
41071: PUSH
41072: DOUBLE
41073: LD_INT 1
41075: DEC
41076: ST_TO_ADDR
41077: LD_INT 6
41079: PUSH
41080: LD_VAR 0 7
41084: MINUS
41085: PUSH
41086: FOR_TO
41087: IFFALSE 41179
// begin if i = sort then
41089: LD_VAR 0 3
41093: PUSH
41094: LD_VAR 0 9
41098: EQUAL
41099: IFFALSE 41103
// break ;
41101: GO 41179
// if GetClass ( i ) = 3 then
41103: LD_VAR 0 3
41107: PPUSH
41108: CALL_OW 257
41112: PUSH
41113: LD_INT 3
41115: EQUAL
41116: IFFALSE 41120
// continue ;
41118: GO 41086
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41120: LD_ADDR_VAR 0 11
41124: PUSH
41125: LD_VAR 0 11
41129: PPUSH
41130: LD_VAR 0 11
41134: PUSH
41135: LD_INT 1
41137: PLUS
41138: PPUSH
41139: LD_VAR 0 9
41143: PUSH
41144: LD_VAR 0 3
41148: ARRAY
41149: PPUSH
41150: CALL_OW 2
41154: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41155: LD_ADDR_VAR 0 4
41159: PUSH
41160: LD_VAR 0 4
41164: PUSH
41165: LD_VAR 0 9
41169: PUSH
41170: LD_VAR 0 3
41174: ARRAY
41175: DIFF
41176: ST_TO_ADDR
// end ;
41177: GO 41086
41179: POP
41180: POP
// if p then
41181: LD_VAR 0 11
41185: IFFALSE 41210
// result := Replace ( result , 3 , p ) ;
41187: LD_ADDR_VAR 0 2
41191: PUSH
41192: LD_VAR 0 2
41196: PPUSH
41197: LD_INT 3
41199: PPUSH
41200: LD_VAR 0 11
41204: PPUSH
41205: CALL_OW 1
41209: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41210: LD_ADDR_VAR 0 4
41214: PUSH
41215: LD_VAR 0 4
41219: PUSH
41220: LD_VAR 0 6
41224: DIFF
41225: ST_TO_ADDR
// if tmp and eng < 6 then
41226: LD_VAR 0 4
41230: PUSH
41231: LD_VAR 0 6
41235: PUSH
41236: LD_INT 6
41238: LESS
41239: AND
41240: IFFALSE 41434
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
41242: LD_ADDR_VAR 0 9
41246: PUSH
41247: LD_VAR 0 4
41251: PUSH
41252: LD_VAR 0 8
41256: PUSH
41257: LD_VAR 0 7
41261: UNION
41262: PUSH
41263: LD_VAR 0 6
41267: UNION
41268: DIFF
41269: PPUSH
41270: LD_INT 2
41272: PPUSH
41273: CALL 105457 0 2
41277: ST_TO_ADDR
// p := [ ] ;
41278: LD_ADDR_VAR 0 11
41282: PUSH
41283: EMPTY
41284: ST_TO_ADDR
// if sort then
41285: LD_VAR 0 9
41289: IFFALSE 41405
// for i = 1 to 6 - eng do
41291: LD_ADDR_VAR 0 3
41295: PUSH
41296: DOUBLE
41297: LD_INT 1
41299: DEC
41300: ST_TO_ADDR
41301: LD_INT 6
41303: PUSH
41304: LD_VAR 0 6
41308: MINUS
41309: PUSH
41310: FOR_TO
41311: IFFALSE 41403
// begin if i = sort then
41313: LD_VAR 0 3
41317: PUSH
41318: LD_VAR 0 9
41322: EQUAL
41323: IFFALSE 41327
// break ;
41325: GO 41403
// if GetClass ( i ) = 2 then
41327: LD_VAR 0 3
41331: PPUSH
41332: CALL_OW 257
41336: PUSH
41337: LD_INT 2
41339: EQUAL
41340: IFFALSE 41344
// continue ;
41342: GO 41310
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41344: LD_ADDR_VAR 0 11
41348: PUSH
41349: LD_VAR 0 11
41353: PPUSH
41354: LD_VAR 0 11
41358: PUSH
41359: LD_INT 1
41361: PLUS
41362: PPUSH
41363: LD_VAR 0 9
41367: PUSH
41368: LD_VAR 0 3
41372: ARRAY
41373: PPUSH
41374: CALL_OW 2
41378: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41379: LD_ADDR_VAR 0 4
41383: PUSH
41384: LD_VAR 0 4
41388: PUSH
41389: LD_VAR 0 9
41393: PUSH
41394: LD_VAR 0 3
41398: ARRAY
41399: DIFF
41400: ST_TO_ADDR
// end ;
41401: GO 41310
41403: POP
41404: POP
// if p then
41405: LD_VAR 0 11
41409: IFFALSE 41434
// result := Replace ( result , 2 , p ) ;
41411: LD_ADDR_VAR 0 2
41415: PUSH
41416: LD_VAR 0 2
41420: PPUSH
41421: LD_INT 2
41423: PPUSH
41424: LD_VAR 0 11
41428: PPUSH
41429: CALL_OW 1
41433: ST_TO_ADDR
// end ; exit ;
41434: GO 42158
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
41436: LD_EXP 126
41440: PUSH
41441: LD_EXP 125
41445: PUSH
41446: LD_VAR 0 1
41450: ARRAY
41451: ARRAY
41452: NOT
41453: PUSH
41454: LD_EXP 99
41458: PUSH
41459: LD_VAR 0 1
41463: ARRAY
41464: PPUSH
41465: LD_INT 30
41467: PUSH
41468: LD_INT 3
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: PPUSH
41475: CALL_OW 72
41479: AND
41480: PUSH
41481: LD_EXP 104
41485: PUSH
41486: LD_VAR 0 1
41490: ARRAY
41491: NOT
41492: AND
41493: IFFALSE 42158
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
41495: LD_ADDR_EXP 141
41499: PUSH
41500: LD_EXP 141
41504: PPUSH
41505: LD_VAR 0 1
41509: PPUSH
41510: LD_INT 6
41512: PPUSH
41513: CALL_OW 1
41517: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
41518: LD_ADDR_VAR 0 2
41522: PUSH
41523: LD_INT 0
41525: PUSH
41526: LD_INT 0
41528: PUSH
41529: LD_INT 0
41531: PUSH
41532: LD_INT 0
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: ST_TO_ADDR
// if sci >= 1 then
41541: LD_VAR 0 8
41545: PUSH
41546: LD_INT 1
41548: GREATEREQUAL
41549: IFFALSE 41571
// tmp := tmp diff sci [ 1 ] ;
41551: LD_ADDR_VAR 0 4
41555: PUSH
41556: LD_VAR 0 4
41560: PUSH
41561: LD_VAR 0 8
41565: PUSH
41566: LD_INT 1
41568: ARRAY
41569: DIFF
41570: ST_TO_ADDR
// if tmp and not sci then
41571: LD_VAR 0 4
41575: PUSH
41576: LD_VAR 0 8
41580: NOT
41581: AND
41582: IFFALSE 41651
// begin sort := SortBySkill ( tmp , 4 ) ;
41584: LD_ADDR_VAR 0 9
41588: PUSH
41589: LD_VAR 0 4
41593: PPUSH
41594: LD_INT 4
41596: PPUSH
41597: CALL 105457 0 2
41601: ST_TO_ADDR
// if sort then
41602: LD_VAR 0 9
41606: IFFALSE 41622
// p := sort [ 1 ] ;
41608: LD_ADDR_VAR 0 11
41612: PUSH
41613: LD_VAR 0 9
41617: PUSH
41618: LD_INT 1
41620: ARRAY
41621: ST_TO_ADDR
// if p then
41622: LD_VAR 0 11
41626: IFFALSE 41651
// result := Replace ( result , 4 , p ) ;
41628: LD_ADDR_VAR 0 2
41632: PUSH
41633: LD_VAR 0 2
41637: PPUSH
41638: LD_INT 4
41640: PPUSH
41641: LD_VAR 0 11
41645: PPUSH
41646: CALL_OW 1
41650: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
41651: LD_ADDR_VAR 0 4
41655: PUSH
41656: LD_VAR 0 4
41660: PUSH
41661: LD_VAR 0 7
41665: DIFF
41666: ST_TO_ADDR
// if tmp and mech < 6 then
41667: LD_VAR 0 4
41671: PUSH
41672: LD_VAR 0 7
41676: PUSH
41677: LD_INT 6
41679: LESS
41680: AND
41681: IFFALSE 41863
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
41683: LD_ADDR_VAR 0 9
41687: PUSH
41688: LD_VAR 0 4
41692: PUSH
41693: LD_VAR 0 7
41697: DIFF
41698: PPUSH
41699: LD_INT 3
41701: PPUSH
41702: CALL 105457 0 2
41706: ST_TO_ADDR
// p := [ ] ;
41707: LD_ADDR_VAR 0 11
41711: PUSH
41712: EMPTY
41713: ST_TO_ADDR
// if sort then
41714: LD_VAR 0 9
41718: IFFALSE 41834
// for i = 1 to 6 - mech do
41720: LD_ADDR_VAR 0 3
41724: PUSH
41725: DOUBLE
41726: LD_INT 1
41728: DEC
41729: ST_TO_ADDR
41730: LD_INT 6
41732: PUSH
41733: LD_VAR 0 7
41737: MINUS
41738: PUSH
41739: FOR_TO
41740: IFFALSE 41832
// begin if i = sort then
41742: LD_VAR 0 3
41746: PUSH
41747: LD_VAR 0 9
41751: EQUAL
41752: IFFALSE 41756
// break ;
41754: GO 41832
// if GetClass ( i ) = 3 then
41756: LD_VAR 0 3
41760: PPUSH
41761: CALL_OW 257
41765: PUSH
41766: LD_INT 3
41768: EQUAL
41769: IFFALSE 41773
// continue ;
41771: GO 41739
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41773: LD_ADDR_VAR 0 11
41777: PUSH
41778: LD_VAR 0 11
41782: PPUSH
41783: LD_VAR 0 11
41787: PUSH
41788: LD_INT 1
41790: PLUS
41791: PPUSH
41792: LD_VAR 0 9
41796: PUSH
41797: LD_VAR 0 3
41801: ARRAY
41802: PPUSH
41803: CALL_OW 2
41807: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
41808: LD_ADDR_VAR 0 4
41812: PUSH
41813: LD_VAR 0 4
41817: PUSH
41818: LD_VAR 0 9
41822: PUSH
41823: LD_VAR 0 3
41827: ARRAY
41828: DIFF
41829: ST_TO_ADDR
// end ;
41830: GO 41739
41832: POP
41833: POP
// if p then
41834: LD_VAR 0 11
41838: IFFALSE 41863
// result := Replace ( result , 3 , p ) ;
41840: LD_ADDR_VAR 0 2
41844: PUSH
41845: LD_VAR 0 2
41849: PPUSH
41850: LD_INT 3
41852: PPUSH
41853: LD_VAR 0 11
41857: PPUSH
41858: CALL_OW 1
41862: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
41863: LD_ADDR_VAR 0 4
41867: PUSH
41868: LD_VAR 0 4
41872: PUSH
41873: LD_VAR 0 6
41877: DIFF
41878: ST_TO_ADDR
// if tmp and eng < 4 then
41879: LD_VAR 0 4
41883: PUSH
41884: LD_VAR 0 6
41888: PUSH
41889: LD_INT 4
41891: LESS
41892: AND
41893: IFFALSE 42083
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
41895: LD_ADDR_VAR 0 9
41899: PUSH
41900: LD_VAR 0 4
41904: PUSH
41905: LD_VAR 0 7
41909: PUSH
41910: LD_VAR 0 6
41914: UNION
41915: DIFF
41916: PPUSH
41917: LD_INT 2
41919: PPUSH
41920: CALL 105457 0 2
41924: ST_TO_ADDR
// p := [ ] ;
41925: LD_ADDR_VAR 0 11
41929: PUSH
41930: EMPTY
41931: ST_TO_ADDR
// if sort then
41932: LD_VAR 0 9
41936: IFFALSE 42052
// for i = 1 to 4 - eng do
41938: LD_ADDR_VAR 0 3
41942: PUSH
41943: DOUBLE
41944: LD_INT 1
41946: DEC
41947: ST_TO_ADDR
41948: LD_INT 4
41950: PUSH
41951: LD_VAR 0 6
41955: MINUS
41956: PUSH
41957: FOR_TO
41958: IFFALSE 42050
// begin if i = sort then
41960: LD_VAR 0 3
41964: PUSH
41965: LD_VAR 0 9
41969: EQUAL
41970: IFFALSE 41974
// break ;
41972: GO 42050
// if GetClass ( i ) = 2 then
41974: LD_VAR 0 3
41978: PPUSH
41979: CALL_OW 257
41983: PUSH
41984: LD_INT 2
41986: EQUAL
41987: IFFALSE 41991
// continue ;
41989: GO 41957
// p := Insert ( p , p + 1 , sort [ i ] ) ;
41991: LD_ADDR_VAR 0 11
41995: PUSH
41996: LD_VAR 0 11
42000: PPUSH
42001: LD_VAR 0 11
42005: PUSH
42006: LD_INT 1
42008: PLUS
42009: PPUSH
42010: LD_VAR 0 9
42014: PUSH
42015: LD_VAR 0 3
42019: ARRAY
42020: PPUSH
42021: CALL_OW 2
42025: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
42026: LD_ADDR_VAR 0 4
42030: PUSH
42031: LD_VAR 0 4
42035: PUSH
42036: LD_VAR 0 9
42040: PUSH
42041: LD_VAR 0 3
42045: ARRAY
42046: DIFF
42047: ST_TO_ADDR
// end ;
42048: GO 41957
42050: POP
42051: POP
// if p then
42052: LD_VAR 0 11
42056: IFFALSE 42081
// result := Replace ( result , 2 , p ) ;
42058: LD_ADDR_VAR 0 2
42062: PUSH
42063: LD_VAR 0 2
42067: PPUSH
42068: LD_INT 2
42070: PPUSH
42071: LD_VAR 0 11
42075: PPUSH
42076: CALL_OW 1
42080: ST_TO_ADDR
// end else
42081: GO 42127
// for i = eng downto 5 do
42083: LD_ADDR_VAR 0 3
42087: PUSH
42088: DOUBLE
42089: LD_VAR 0 6
42093: INC
42094: ST_TO_ADDR
42095: LD_INT 5
42097: PUSH
42098: FOR_DOWNTO
42099: IFFALSE 42125
// tmp := tmp union eng [ i ] ;
42101: LD_ADDR_VAR 0 4
42105: PUSH
42106: LD_VAR 0 4
42110: PUSH
42111: LD_VAR 0 6
42115: PUSH
42116: LD_VAR 0 3
42120: ARRAY
42121: UNION
42122: ST_TO_ADDR
42123: GO 42098
42125: POP
42126: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
42127: LD_ADDR_VAR 0 2
42131: PUSH
42132: LD_VAR 0 2
42136: PPUSH
42137: LD_INT 1
42139: PPUSH
42140: LD_VAR 0 4
42144: PUSH
42145: LD_VAR 0 5
42149: DIFF
42150: PPUSH
42151: CALL_OW 1
42155: ST_TO_ADDR
// exit ;
42156: GO 42158
// end ; end ;
42158: LD_VAR 0 2
42162: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
42163: LD_INT 0
42165: PPUSH
42166: PPUSH
42167: PPUSH
// if not mc_bases then
42168: LD_EXP 99
42172: NOT
42173: IFFALSE 42177
// exit ;
42175: GO 42283
// for i = 1 to mc_bases do
42177: LD_ADDR_VAR 0 2
42181: PUSH
42182: DOUBLE
42183: LD_INT 1
42185: DEC
42186: ST_TO_ADDR
42187: LD_EXP 99
42191: PUSH
42192: FOR_TO
42193: IFFALSE 42274
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
42195: LD_ADDR_VAR 0 3
42199: PUSH
42200: LD_EXP 99
42204: PUSH
42205: LD_VAR 0 2
42209: ARRAY
42210: PPUSH
42211: LD_INT 21
42213: PUSH
42214: LD_INT 3
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 3
42223: PUSH
42224: LD_INT 24
42226: PUSH
42227: LD_INT 1000
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: PUSH
42234: EMPTY
42235: LIST
42236: LIST
42237: PUSH
42238: EMPTY
42239: LIST
42240: LIST
42241: PPUSH
42242: CALL_OW 72
42246: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
42247: LD_ADDR_EXP 100
42251: PUSH
42252: LD_EXP 100
42256: PPUSH
42257: LD_VAR 0 2
42261: PPUSH
42262: LD_VAR 0 3
42266: PPUSH
42267: CALL_OW 1
42271: ST_TO_ADDR
// end ;
42272: GO 42192
42274: POP
42275: POP
// RaiseSailEvent ( 101 ) ;
42276: LD_INT 101
42278: PPUSH
42279: CALL_OW 427
// end ;
42283: LD_VAR 0 1
42287: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
42288: LD_INT 0
42290: PPUSH
42291: PPUSH
42292: PPUSH
42293: PPUSH
42294: PPUSH
42295: PPUSH
42296: PPUSH
// if not mc_bases then
42297: LD_EXP 99
42301: NOT
42302: IFFALSE 42306
// exit ;
42304: GO 42879
// for i = 1 to mc_bases do
42306: LD_ADDR_VAR 0 2
42310: PUSH
42311: DOUBLE
42312: LD_INT 1
42314: DEC
42315: ST_TO_ADDR
42316: LD_EXP 99
42320: PUSH
42321: FOR_TO
42322: IFFALSE 42870
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
42324: LD_ADDR_VAR 0 5
42328: PUSH
42329: LD_EXP 99
42333: PUSH
42334: LD_VAR 0 2
42338: ARRAY
42339: PUSH
42340: LD_EXP 128
42344: PUSH
42345: LD_VAR 0 2
42349: ARRAY
42350: UNION
42351: PPUSH
42352: LD_INT 21
42354: PUSH
42355: LD_INT 1
42357: PUSH
42358: EMPTY
42359: LIST
42360: LIST
42361: PUSH
42362: LD_INT 1
42364: PUSH
42365: LD_INT 3
42367: PUSH
42368: LD_INT 54
42370: PUSH
42371: EMPTY
42372: LIST
42373: PUSH
42374: EMPTY
42375: LIST
42376: LIST
42377: PUSH
42378: LD_INT 3
42380: PUSH
42381: LD_INT 24
42383: PUSH
42384: LD_INT 800
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: EMPTY
42396: LIST
42397: LIST
42398: LIST
42399: PUSH
42400: EMPTY
42401: LIST
42402: LIST
42403: PPUSH
42404: CALL_OW 72
42408: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
42409: LD_ADDR_VAR 0 6
42413: PUSH
42414: LD_EXP 99
42418: PUSH
42419: LD_VAR 0 2
42423: ARRAY
42424: PPUSH
42425: LD_INT 21
42427: PUSH
42428: LD_INT 1
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 1
42437: PUSH
42438: LD_INT 3
42440: PUSH
42441: LD_INT 54
42443: PUSH
42444: EMPTY
42445: LIST
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 3
42453: PUSH
42454: LD_INT 24
42456: PUSH
42457: LD_INT 250
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: EMPTY
42469: LIST
42470: LIST
42471: LIST
42472: PUSH
42473: EMPTY
42474: LIST
42475: LIST
42476: PPUSH
42477: CALL_OW 72
42481: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
42482: LD_ADDR_VAR 0 7
42486: PUSH
42487: LD_VAR 0 5
42491: PUSH
42492: LD_VAR 0 6
42496: DIFF
42497: ST_TO_ADDR
// if not need_heal_1 then
42498: LD_VAR 0 6
42502: NOT
42503: IFFALSE 42536
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
42505: LD_ADDR_EXP 102
42509: PUSH
42510: LD_EXP 102
42514: PPUSH
42515: LD_VAR 0 2
42519: PUSH
42520: LD_INT 1
42522: PUSH
42523: EMPTY
42524: LIST
42525: LIST
42526: PPUSH
42527: EMPTY
42528: PPUSH
42529: CALL 71209 0 3
42533: ST_TO_ADDR
42534: GO 42606
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
42536: LD_ADDR_EXP 102
42540: PUSH
42541: LD_EXP 102
42545: PPUSH
42546: LD_VAR 0 2
42550: PUSH
42551: LD_INT 1
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PPUSH
42558: LD_EXP 102
42562: PUSH
42563: LD_VAR 0 2
42567: ARRAY
42568: PUSH
42569: LD_INT 1
42571: ARRAY
42572: PPUSH
42573: LD_INT 3
42575: PUSH
42576: LD_INT 24
42578: PUSH
42579: LD_INT 1000
42581: PUSH
42582: EMPTY
42583: LIST
42584: LIST
42585: PUSH
42586: EMPTY
42587: LIST
42588: LIST
42589: PPUSH
42590: CALL_OW 72
42594: PUSH
42595: LD_VAR 0 6
42599: UNION
42600: PPUSH
42601: CALL 71209 0 3
42605: ST_TO_ADDR
// if not need_heal_2 then
42606: LD_VAR 0 7
42610: NOT
42611: IFFALSE 42644
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
42613: LD_ADDR_EXP 102
42617: PUSH
42618: LD_EXP 102
42622: PPUSH
42623: LD_VAR 0 2
42627: PUSH
42628: LD_INT 2
42630: PUSH
42631: EMPTY
42632: LIST
42633: LIST
42634: PPUSH
42635: EMPTY
42636: PPUSH
42637: CALL 71209 0 3
42641: ST_TO_ADDR
42642: GO 42676
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
42644: LD_ADDR_EXP 102
42648: PUSH
42649: LD_EXP 102
42653: PPUSH
42654: LD_VAR 0 2
42658: PUSH
42659: LD_INT 2
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PPUSH
42666: LD_VAR 0 7
42670: PPUSH
42671: CALL 71209 0 3
42675: ST_TO_ADDR
// if need_heal_2 then
42676: LD_VAR 0 7
42680: IFFALSE 42852
// for j in need_heal_2 do
42682: LD_ADDR_VAR 0 3
42686: PUSH
42687: LD_VAR 0 7
42691: PUSH
42692: FOR_IN
42693: IFFALSE 42850
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
42695: LD_ADDR_VAR 0 5
42699: PUSH
42700: LD_EXP 99
42704: PUSH
42705: LD_VAR 0 2
42709: ARRAY
42710: PPUSH
42711: LD_INT 2
42713: PUSH
42714: LD_INT 30
42716: PUSH
42717: LD_INT 6
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 30
42726: PUSH
42727: LD_INT 7
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: LD_INT 30
42736: PUSH
42737: LD_INT 8
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 30
42746: PUSH
42747: LD_INT 0
42749: PUSH
42750: EMPTY
42751: LIST
42752: LIST
42753: PUSH
42754: LD_INT 30
42756: PUSH
42757: LD_INT 1
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 25
42766: PUSH
42767: LD_INT 4
42769: PUSH
42770: EMPTY
42771: LIST
42772: LIST
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: LIST
42778: LIST
42779: LIST
42780: LIST
42781: LIST
42782: PPUSH
42783: CALL_OW 72
42787: ST_TO_ADDR
// if tmp then
42788: LD_VAR 0 5
42792: IFFALSE 42848
// begin k := NearestUnitToUnit ( tmp , j ) ;
42794: LD_ADDR_VAR 0 4
42798: PUSH
42799: LD_VAR 0 5
42803: PPUSH
42804: LD_VAR 0 3
42808: PPUSH
42809: CALL_OW 74
42813: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
42814: LD_VAR 0 3
42818: PPUSH
42819: LD_VAR 0 4
42823: PPUSH
42824: CALL_OW 296
42828: PUSH
42829: LD_INT 7
42831: GREATER
42832: IFFALSE 42848
// ComMoveUnit ( j , k ) ;
42834: LD_VAR 0 3
42838: PPUSH
42839: LD_VAR 0 4
42843: PPUSH
42844: CALL_OW 112
// end ; end ;
42848: GO 42692
42850: POP
42851: POP
// if not need_heal_1 and not need_heal_2 then
42852: LD_VAR 0 6
42856: NOT
42857: PUSH
42858: LD_VAR 0 7
42862: NOT
42863: AND
42864: IFFALSE 42868
// continue ;
42866: GO 42321
// end ;
42868: GO 42321
42870: POP
42871: POP
// RaiseSailEvent ( 102 ) ;
42872: LD_INT 102
42874: PPUSH
42875: CALL_OW 427
// end ;
42879: LD_VAR 0 1
42883: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
42884: LD_INT 0
42886: PPUSH
42887: PPUSH
42888: PPUSH
42889: PPUSH
42890: PPUSH
42891: PPUSH
// if not mc_bases then
42892: LD_EXP 99
42896: NOT
42897: IFFALSE 42901
// exit ;
42899: GO 43611
// for i = 1 to mc_bases do
42901: LD_ADDR_VAR 0 2
42905: PUSH
42906: DOUBLE
42907: LD_INT 1
42909: DEC
42910: ST_TO_ADDR
42911: LD_EXP 99
42915: PUSH
42916: FOR_TO
42917: IFFALSE 43609
// begin if not mc_building_need_repair [ i ] then
42919: LD_EXP 100
42923: PUSH
42924: LD_VAR 0 2
42928: ARRAY
42929: NOT
42930: IFFALSE 43104
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
42932: LD_ADDR_VAR 0 6
42936: PUSH
42937: LD_EXP 118
42941: PUSH
42942: LD_VAR 0 2
42946: ARRAY
42947: PPUSH
42948: LD_INT 3
42950: PUSH
42951: LD_INT 24
42953: PUSH
42954: LD_INT 1000
42956: PUSH
42957: EMPTY
42958: LIST
42959: LIST
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 2
42967: PUSH
42968: LD_INT 34
42970: PUSH
42971: LD_INT 13
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PUSH
42978: LD_INT 34
42980: PUSH
42981: LD_INT 52
42983: PUSH
42984: EMPTY
42985: LIST
42986: LIST
42987: PUSH
42988: EMPTY
42989: LIST
42990: LIST
42991: LIST
42992: PUSH
42993: EMPTY
42994: LIST
42995: LIST
42996: PPUSH
42997: CALL_OW 72
43001: ST_TO_ADDR
// if cranes then
43002: LD_VAR 0 6
43006: IFFALSE 43068
// for j in cranes do
43008: LD_ADDR_VAR 0 3
43012: PUSH
43013: LD_VAR 0 6
43017: PUSH
43018: FOR_IN
43019: IFFALSE 43066
// if not IsInArea ( j , mc_parking [ i ] ) then
43021: LD_VAR 0 3
43025: PPUSH
43026: LD_EXP 123
43030: PUSH
43031: LD_VAR 0 2
43035: ARRAY
43036: PPUSH
43037: CALL_OW 308
43041: NOT
43042: IFFALSE 43064
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43044: LD_VAR 0 3
43048: PPUSH
43049: LD_EXP 123
43053: PUSH
43054: LD_VAR 0 2
43058: ARRAY
43059: PPUSH
43060: CALL_OW 113
43064: GO 43018
43066: POP
43067: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
43068: LD_ADDR_EXP 101
43072: PUSH
43073: LD_EXP 101
43077: PPUSH
43078: LD_VAR 0 2
43082: PPUSH
43083: EMPTY
43084: PPUSH
43085: CALL_OW 1
43089: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
43090: LD_VAR 0 2
43094: PPUSH
43095: LD_INT 101
43097: PPUSH
43098: CALL 37996 0 2
// continue ;
43102: GO 42916
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
43104: LD_ADDR_EXP 105
43108: PUSH
43109: LD_EXP 105
43113: PPUSH
43114: LD_VAR 0 2
43118: PPUSH
43119: EMPTY
43120: PPUSH
43121: CALL_OW 1
43125: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
43126: LD_VAR 0 2
43130: PPUSH
43131: LD_INT 103
43133: PPUSH
43134: CALL 37996 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
43138: LD_ADDR_VAR 0 5
43142: PUSH
43143: LD_EXP 99
43147: PUSH
43148: LD_VAR 0 2
43152: ARRAY
43153: PUSH
43154: LD_EXP 128
43158: PUSH
43159: LD_VAR 0 2
43163: ARRAY
43164: UNION
43165: PPUSH
43166: LD_INT 2
43168: PUSH
43169: LD_INT 25
43171: PUSH
43172: LD_INT 2
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 25
43181: PUSH
43182: LD_INT 16
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: EMPTY
43190: LIST
43191: LIST
43192: LIST
43193: PUSH
43194: EMPTY
43195: LIST
43196: PPUSH
43197: CALL_OW 72
43201: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
43202: LD_ADDR_VAR 0 6
43206: PUSH
43207: LD_EXP 118
43211: PUSH
43212: LD_VAR 0 2
43216: ARRAY
43217: PPUSH
43218: LD_INT 2
43220: PUSH
43221: LD_INT 34
43223: PUSH
43224: LD_INT 13
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PUSH
43231: LD_INT 34
43233: PUSH
43234: LD_INT 52
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: LIST
43245: PPUSH
43246: CALL_OW 72
43250: ST_TO_ADDR
// if cranes then
43251: LD_VAR 0 6
43255: IFFALSE 43391
// begin for j in cranes do
43257: LD_ADDR_VAR 0 3
43261: PUSH
43262: LD_VAR 0 6
43266: PUSH
43267: FOR_IN
43268: IFFALSE 43389
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
43270: LD_VAR 0 3
43274: PPUSH
43275: CALL_OW 256
43279: PUSH
43280: LD_INT 500
43282: GREATEREQUAL
43283: PUSH
43284: LD_VAR 0 3
43288: PPUSH
43289: CALL_OW 314
43293: NOT
43294: AND
43295: IFFALSE 43329
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
43297: LD_VAR 0 3
43301: PPUSH
43302: LD_EXP 100
43306: PUSH
43307: LD_VAR 0 2
43311: ARRAY
43312: PPUSH
43313: LD_VAR 0 3
43317: PPUSH
43318: CALL_OW 74
43322: PPUSH
43323: CALL_OW 130
43327: GO 43387
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
43329: LD_VAR 0 3
43333: PPUSH
43334: CALL_OW 256
43338: PUSH
43339: LD_INT 500
43341: LESS
43342: PUSH
43343: LD_VAR 0 3
43347: PPUSH
43348: LD_EXP 123
43352: PUSH
43353: LD_VAR 0 2
43357: ARRAY
43358: PPUSH
43359: CALL_OW 308
43363: NOT
43364: AND
43365: IFFALSE 43387
// ComMoveToArea ( j , mc_parking [ i ] ) ;
43367: LD_VAR 0 3
43371: PPUSH
43372: LD_EXP 123
43376: PUSH
43377: LD_VAR 0 2
43381: ARRAY
43382: PPUSH
43383: CALL_OW 113
43387: GO 43267
43389: POP
43390: POP
// end ; if not tmp then
43391: LD_VAR 0 5
43395: NOT
43396: IFFALSE 43400
// continue ;
43398: GO 42916
// for j in tmp do
43400: LD_ADDR_VAR 0 3
43404: PUSH
43405: LD_VAR 0 5
43409: PUSH
43410: FOR_IN
43411: IFFALSE 43605
// begin if mc_need_heal [ i ] then
43413: LD_EXP 102
43417: PUSH
43418: LD_VAR 0 2
43422: ARRAY
43423: IFFALSE 43471
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
43425: LD_VAR 0 3
43429: PUSH
43430: LD_EXP 102
43434: PUSH
43435: LD_VAR 0 2
43439: ARRAY
43440: PUSH
43441: LD_INT 1
43443: ARRAY
43444: IN
43445: PUSH
43446: LD_VAR 0 3
43450: PUSH
43451: LD_EXP 102
43455: PUSH
43456: LD_VAR 0 2
43460: ARRAY
43461: PUSH
43462: LD_INT 2
43464: ARRAY
43465: IN
43466: OR
43467: IFFALSE 43471
// continue ;
43469: GO 43410
// if IsInUnit ( j ) then
43471: LD_VAR 0 3
43475: PPUSH
43476: CALL_OW 310
43480: IFFALSE 43491
// ComExitBuilding ( j ) ;
43482: LD_VAR 0 3
43486: PPUSH
43487: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
43491: LD_VAR 0 3
43495: PUSH
43496: LD_EXP 101
43500: PUSH
43501: LD_VAR 0 2
43505: ARRAY
43506: IN
43507: NOT
43508: IFFALSE 43566
// begin SetTag ( j , 101 ) ;
43510: LD_VAR 0 3
43514: PPUSH
43515: LD_INT 101
43517: PPUSH
43518: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
43522: LD_ADDR_EXP 101
43526: PUSH
43527: LD_EXP 101
43531: PPUSH
43532: LD_VAR 0 2
43536: PUSH
43537: LD_EXP 101
43541: PUSH
43542: LD_VAR 0 2
43546: ARRAY
43547: PUSH
43548: LD_INT 1
43550: PLUS
43551: PUSH
43552: EMPTY
43553: LIST
43554: LIST
43555: PPUSH
43556: LD_VAR 0 3
43560: PPUSH
43561: CALL 71209 0 3
43565: ST_TO_ADDR
// end ; wait ( 1 ) ;
43566: LD_INT 1
43568: PPUSH
43569: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
43573: LD_VAR 0 3
43577: PPUSH
43578: LD_EXP 100
43582: PUSH
43583: LD_VAR 0 2
43587: ARRAY
43588: PPUSH
43589: LD_VAR 0 3
43593: PPUSH
43594: CALL_OW 74
43598: PPUSH
43599: CALL_OW 130
// end ;
43603: GO 43410
43605: POP
43606: POP
// end ;
43607: GO 42916
43609: POP
43610: POP
// end ;
43611: LD_VAR 0 1
43615: RET
// export function MC_Heal ; var i , j , tmp ; begin
43616: LD_INT 0
43618: PPUSH
43619: PPUSH
43620: PPUSH
43621: PPUSH
// if not mc_bases then
43622: LD_EXP 99
43626: NOT
43627: IFFALSE 43631
// exit ;
43629: GO 44033
// for i = 1 to mc_bases do
43631: LD_ADDR_VAR 0 2
43635: PUSH
43636: DOUBLE
43637: LD_INT 1
43639: DEC
43640: ST_TO_ADDR
43641: LD_EXP 99
43645: PUSH
43646: FOR_TO
43647: IFFALSE 44031
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
43649: LD_EXP 102
43653: PUSH
43654: LD_VAR 0 2
43658: ARRAY
43659: PUSH
43660: LD_INT 1
43662: ARRAY
43663: NOT
43664: PUSH
43665: LD_EXP 102
43669: PUSH
43670: LD_VAR 0 2
43674: ARRAY
43675: PUSH
43676: LD_INT 2
43678: ARRAY
43679: NOT
43680: AND
43681: IFFALSE 43719
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
43683: LD_ADDR_EXP 103
43687: PUSH
43688: LD_EXP 103
43692: PPUSH
43693: LD_VAR 0 2
43697: PPUSH
43698: EMPTY
43699: PPUSH
43700: CALL_OW 1
43704: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
43705: LD_VAR 0 2
43709: PPUSH
43710: LD_INT 102
43712: PPUSH
43713: CALL 37996 0 2
// continue ;
43717: GO 43646
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
43719: LD_ADDR_VAR 0 4
43723: PUSH
43724: LD_EXP 99
43728: PUSH
43729: LD_VAR 0 2
43733: ARRAY
43734: PPUSH
43735: LD_INT 25
43737: PUSH
43738: LD_INT 4
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PPUSH
43745: CALL_OW 72
43749: ST_TO_ADDR
// if not tmp then
43750: LD_VAR 0 4
43754: NOT
43755: IFFALSE 43759
// continue ;
43757: GO 43646
// if mc_taming [ i ] then
43759: LD_EXP 130
43763: PUSH
43764: LD_VAR 0 2
43768: ARRAY
43769: IFFALSE 43793
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
43771: LD_ADDR_EXP 130
43775: PUSH
43776: LD_EXP 130
43780: PPUSH
43781: LD_VAR 0 2
43785: PPUSH
43786: EMPTY
43787: PPUSH
43788: CALL_OW 1
43792: ST_TO_ADDR
// for j in tmp do
43793: LD_ADDR_VAR 0 3
43797: PUSH
43798: LD_VAR 0 4
43802: PUSH
43803: FOR_IN
43804: IFFALSE 44027
// begin if IsInUnit ( j ) then
43806: LD_VAR 0 3
43810: PPUSH
43811: CALL_OW 310
43815: IFFALSE 43826
// ComExitBuilding ( j ) ;
43817: LD_VAR 0 3
43821: PPUSH
43822: CALL_OW 122
// if not j in mc_healers [ i ] then
43826: LD_VAR 0 3
43830: PUSH
43831: LD_EXP 103
43835: PUSH
43836: LD_VAR 0 2
43840: ARRAY
43841: IN
43842: NOT
43843: IFFALSE 43889
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
43845: LD_ADDR_EXP 103
43849: PUSH
43850: LD_EXP 103
43854: PPUSH
43855: LD_VAR 0 2
43859: PUSH
43860: LD_EXP 103
43864: PUSH
43865: LD_VAR 0 2
43869: ARRAY
43870: PUSH
43871: LD_INT 1
43873: PLUS
43874: PUSH
43875: EMPTY
43876: LIST
43877: LIST
43878: PPUSH
43879: LD_VAR 0 3
43883: PPUSH
43884: CALL 71209 0 3
43888: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
43889: LD_VAR 0 3
43893: PPUSH
43894: CALL_OW 110
43898: PUSH
43899: LD_INT 102
43901: NONEQUAL
43902: IFFALSE 43916
// SetTag ( j , 102 ) ;
43904: LD_VAR 0 3
43908: PPUSH
43909: LD_INT 102
43911: PPUSH
43912: CALL_OW 109
// Wait ( 3 ) ;
43916: LD_INT 3
43918: PPUSH
43919: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
43923: LD_EXP 102
43927: PUSH
43928: LD_VAR 0 2
43932: ARRAY
43933: PUSH
43934: LD_INT 1
43936: ARRAY
43937: IFFALSE 43969
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
43939: LD_VAR 0 3
43943: PPUSH
43944: LD_EXP 102
43948: PUSH
43949: LD_VAR 0 2
43953: ARRAY
43954: PUSH
43955: LD_INT 1
43957: ARRAY
43958: PUSH
43959: LD_INT 1
43961: ARRAY
43962: PPUSH
43963: CALL_OW 128
43967: GO 44025
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
43969: LD_VAR 0 3
43973: PPUSH
43974: CALL_OW 314
43978: NOT
43979: PUSH
43980: LD_EXP 102
43984: PUSH
43985: LD_VAR 0 2
43989: ARRAY
43990: PUSH
43991: LD_INT 2
43993: ARRAY
43994: AND
43995: IFFALSE 44025
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
43997: LD_VAR 0 3
44001: PPUSH
44002: LD_EXP 102
44006: PUSH
44007: LD_VAR 0 2
44011: ARRAY
44012: PUSH
44013: LD_INT 2
44015: ARRAY
44016: PUSH
44017: LD_INT 1
44019: ARRAY
44020: PPUSH
44021: CALL_OW 128
// end ;
44025: GO 43803
44027: POP
44028: POP
// end ;
44029: GO 43646
44031: POP
44032: POP
// end ;
44033: LD_VAR 0 1
44037: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
44038: LD_INT 0
44040: PPUSH
44041: PPUSH
44042: PPUSH
44043: PPUSH
44044: PPUSH
// if not mc_bases then
44045: LD_EXP 99
44049: NOT
44050: IFFALSE 44054
// exit ;
44052: GO 45197
// for i = 1 to mc_bases do
44054: LD_ADDR_VAR 0 2
44058: PUSH
44059: DOUBLE
44060: LD_INT 1
44062: DEC
44063: ST_TO_ADDR
44064: LD_EXP 99
44068: PUSH
44069: FOR_TO
44070: IFFALSE 45195
// begin if mc_scan [ i ] then
44072: LD_EXP 122
44076: PUSH
44077: LD_VAR 0 2
44081: ARRAY
44082: IFFALSE 44086
// continue ;
44084: GO 44069
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
44086: LD_EXP 104
44090: PUSH
44091: LD_VAR 0 2
44095: ARRAY
44096: NOT
44097: PUSH
44098: LD_EXP 106
44102: PUSH
44103: LD_VAR 0 2
44107: ARRAY
44108: NOT
44109: AND
44110: PUSH
44111: LD_EXP 105
44115: PUSH
44116: LD_VAR 0 2
44120: ARRAY
44121: AND
44122: IFFALSE 44160
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
44124: LD_ADDR_EXP 105
44128: PUSH
44129: LD_EXP 105
44133: PPUSH
44134: LD_VAR 0 2
44138: PPUSH
44139: EMPTY
44140: PPUSH
44141: CALL_OW 1
44145: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
44146: LD_VAR 0 2
44150: PPUSH
44151: LD_INT 103
44153: PPUSH
44154: CALL 37996 0 2
// continue ;
44158: GO 44069
// end ; if mc_construct_list [ i ] then
44160: LD_EXP 106
44164: PUSH
44165: LD_VAR 0 2
44169: ARRAY
44170: IFFALSE 44390
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44172: LD_ADDR_VAR 0 4
44176: PUSH
44177: LD_EXP 99
44181: PUSH
44182: LD_VAR 0 2
44186: ARRAY
44187: PPUSH
44188: LD_INT 25
44190: PUSH
44191: LD_INT 2
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PPUSH
44198: CALL_OW 72
44202: PUSH
44203: LD_EXP 101
44207: PUSH
44208: LD_VAR 0 2
44212: ARRAY
44213: DIFF
44214: ST_TO_ADDR
// if not tmp then
44215: LD_VAR 0 4
44219: NOT
44220: IFFALSE 44224
// continue ;
44222: GO 44069
// for j in tmp do
44224: LD_ADDR_VAR 0 3
44228: PUSH
44229: LD_VAR 0 4
44233: PUSH
44234: FOR_IN
44235: IFFALSE 44386
// begin if not mc_builders [ i ] then
44237: LD_EXP 105
44241: PUSH
44242: LD_VAR 0 2
44246: ARRAY
44247: NOT
44248: IFFALSE 44306
// begin SetTag ( j , 103 ) ;
44250: LD_VAR 0 3
44254: PPUSH
44255: LD_INT 103
44257: PPUSH
44258: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44262: LD_ADDR_EXP 105
44266: PUSH
44267: LD_EXP 105
44271: PPUSH
44272: LD_VAR 0 2
44276: PUSH
44277: LD_EXP 105
44281: PUSH
44282: LD_VAR 0 2
44286: ARRAY
44287: PUSH
44288: LD_INT 1
44290: PLUS
44291: PUSH
44292: EMPTY
44293: LIST
44294: LIST
44295: PPUSH
44296: LD_VAR 0 3
44300: PPUSH
44301: CALL 71209 0 3
44305: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44306: LD_VAR 0 3
44310: PPUSH
44311: CALL_OW 310
44315: IFFALSE 44326
// ComExitBuilding ( j ) ;
44317: LD_VAR 0 3
44321: PPUSH
44322: CALL_OW 122
// wait ( 3 ) ;
44326: LD_INT 3
44328: PPUSH
44329: CALL_OW 67
// if not mc_construct_list [ i ] then
44333: LD_EXP 106
44337: PUSH
44338: LD_VAR 0 2
44342: ARRAY
44343: NOT
44344: IFFALSE 44348
// break ;
44346: GO 44386
// if not HasTask ( j ) then
44348: LD_VAR 0 3
44352: PPUSH
44353: CALL_OW 314
44357: NOT
44358: IFFALSE 44384
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
44360: LD_VAR 0 3
44364: PPUSH
44365: LD_EXP 106
44369: PUSH
44370: LD_VAR 0 2
44374: ARRAY
44375: PUSH
44376: LD_INT 1
44378: ARRAY
44379: PPUSH
44380: CALL 74060 0 2
// end ;
44384: GO 44234
44386: POP
44387: POP
// end else
44388: GO 45193
// if mc_build_list [ i ] then
44390: LD_EXP 104
44394: PUSH
44395: LD_VAR 0 2
44399: ARRAY
44400: IFFALSE 45193
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44402: LD_ADDR_VAR 0 5
44406: PUSH
44407: LD_EXP 99
44411: PUSH
44412: LD_VAR 0 2
44416: ARRAY
44417: PPUSH
44418: LD_INT 2
44420: PUSH
44421: LD_INT 30
44423: PUSH
44424: LD_INT 0
44426: PUSH
44427: EMPTY
44428: LIST
44429: LIST
44430: PUSH
44431: LD_INT 30
44433: PUSH
44434: LD_INT 1
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: LIST
44445: PPUSH
44446: CALL_OW 72
44450: ST_TO_ADDR
// if depot then
44451: LD_VAR 0 5
44455: IFFALSE 44473
// depot := depot [ 1 ] else
44457: LD_ADDR_VAR 0 5
44461: PUSH
44462: LD_VAR 0 5
44466: PUSH
44467: LD_INT 1
44469: ARRAY
44470: ST_TO_ADDR
44471: GO 44481
// depot := 0 ;
44473: LD_ADDR_VAR 0 5
44477: PUSH
44478: LD_INT 0
44480: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
44481: LD_EXP 104
44485: PUSH
44486: LD_VAR 0 2
44490: ARRAY
44491: PUSH
44492: LD_INT 1
44494: ARRAY
44495: PUSH
44496: LD_INT 1
44498: ARRAY
44499: PPUSH
44500: CALL 73890 0 1
44504: PUSH
44505: LD_EXP 99
44509: PUSH
44510: LD_VAR 0 2
44514: ARRAY
44515: PPUSH
44516: LD_INT 2
44518: PUSH
44519: LD_INT 30
44521: PUSH
44522: LD_INT 2
44524: PUSH
44525: EMPTY
44526: LIST
44527: LIST
44528: PUSH
44529: LD_INT 30
44531: PUSH
44532: LD_INT 3
44534: PUSH
44535: EMPTY
44536: LIST
44537: LIST
44538: PUSH
44539: EMPTY
44540: LIST
44541: LIST
44542: LIST
44543: PPUSH
44544: CALL_OW 72
44548: NOT
44549: AND
44550: IFFALSE 44655
// begin for j = 1 to mc_build_list [ i ] do
44552: LD_ADDR_VAR 0 3
44556: PUSH
44557: DOUBLE
44558: LD_INT 1
44560: DEC
44561: ST_TO_ADDR
44562: LD_EXP 104
44566: PUSH
44567: LD_VAR 0 2
44571: ARRAY
44572: PUSH
44573: FOR_TO
44574: IFFALSE 44653
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
44576: LD_EXP 104
44580: PUSH
44581: LD_VAR 0 2
44585: ARRAY
44586: PUSH
44587: LD_VAR 0 3
44591: ARRAY
44592: PUSH
44593: LD_INT 1
44595: ARRAY
44596: PUSH
44597: LD_INT 2
44599: EQUAL
44600: IFFALSE 44651
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
44602: LD_ADDR_EXP 104
44606: PUSH
44607: LD_EXP 104
44611: PPUSH
44612: LD_VAR 0 2
44616: PPUSH
44617: LD_EXP 104
44621: PUSH
44622: LD_VAR 0 2
44626: ARRAY
44627: PPUSH
44628: LD_VAR 0 3
44632: PPUSH
44633: LD_INT 1
44635: PPUSH
44636: LD_INT 0
44638: PPUSH
44639: CALL 70627 0 4
44643: PPUSH
44644: CALL_OW 1
44648: ST_TO_ADDR
// break ;
44649: GO 44653
// end ;
44651: GO 44573
44653: POP
44654: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
44655: LD_EXP 104
44659: PUSH
44660: LD_VAR 0 2
44664: ARRAY
44665: PUSH
44666: LD_INT 1
44668: ARRAY
44669: PUSH
44670: LD_INT 1
44672: ARRAY
44673: PUSH
44674: LD_INT 0
44676: EQUAL
44677: PUSH
44678: LD_VAR 0 5
44682: PUSH
44683: LD_VAR 0 5
44687: PPUSH
44688: LD_EXP 104
44692: PUSH
44693: LD_VAR 0 2
44697: ARRAY
44698: PUSH
44699: LD_INT 1
44701: ARRAY
44702: PUSH
44703: LD_INT 1
44705: ARRAY
44706: PPUSH
44707: LD_EXP 104
44711: PUSH
44712: LD_VAR 0 2
44716: ARRAY
44717: PUSH
44718: LD_INT 1
44720: ARRAY
44721: PUSH
44722: LD_INT 2
44724: ARRAY
44725: PPUSH
44726: LD_EXP 104
44730: PUSH
44731: LD_VAR 0 2
44735: ARRAY
44736: PUSH
44737: LD_INT 1
44739: ARRAY
44740: PUSH
44741: LD_INT 3
44743: ARRAY
44744: PPUSH
44745: LD_EXP 104
44749: PUSH
44750: LD_VAR 0 2
44754: ARRAY
44755: PUSH
44756: LD_INT 1
44758: ARRAY
44759: PUSH
44760: LD_INT 4
44762: ARRAY
44763: PPUSH
44764: CALL 78624 0 5
44768: AND
44769: OR
44770: IFFALSE 45051
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
44772: LD_ADDR_VAR 0 4
44776: PUSH
44777: LD_EXP 99
44781: PUSH
44782: LD_VAR 0 2
44786: ARRAY
44787: PPUSH
44788: LD_INT 25
44790: PUSH
44791: LD_INT 2
44793: PUSH
44794: EMPTY
44795: LIST
44796: LIST
44797: PPUSH
44798: CALL_OW 72
44802: PUSH
44803: LD_EXP 101
44807: PUSH
44808: LD_VAR 0 2
44812: ARRAY
44813: DIFF
44814: ST_TO_ADDR
// if not tmp then
44815: LD_VAR 0 4
44819: NOT
44820: IFFALSE 44824
// continue ;
44822: GO 44069
// for j in tmp do
44824: LD_ADDR_VAR 0 3
44828: PUSH
44829: LD_VAR 0 4
44833: PUSH
44834: FOR_IN
44835: IFFALSE 45047
// begin if not mc_builders [ i ] then
44837: LD_EXP 105
44841: PUSH
44842: LD_VAR 0 2
44846: ARRAY
44847: NOT
44848: IFFALSE 44906
// begin SetTag ( j , 103 ) ;
44850: LD_VAR 0 3
44854: PPUSH
44855: LD_INT 103
44857: PPUSH
44858: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
44862: LD_ADDR_EXP 105
44866: PUSH
44867: LD_EXP 105
44871: PPUSH
44872: LD_VAR 0 2
44876: PUSH
44877: LD_EXP 105
44881: PUSH
44882: LD_VAR 0 2
44886: ARRAY
44887: PUSH
44888: LD_INT 1
44890: PLUS
44891: PUSH
44892: EMPTY
44893: LIST
44894: LIST
44895: PPUSH
44896: LD_VAR 0 3
44900: PPUSH
44901: CALL 71209 0 3
44905: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
44906: LD_VAR 0 3
44910: PPUSH
44911: CALL_OW 310
44915: IFFALSE 44926
// ComExitBuilding ( j ) ;
44917: LD_VAR 0 3
44921: PPUSH
44922: CALL_OW 122
// wait ( 3 ) ;
44926: LD_INT 3
44928: PPUSH
44929: CALL_OW 67
// if not mc_build_list [ i ] then
44933: LD_EXP 104
44937: PUSH
44938: LD_VAR 0 2
44942: ARRAY
44943: NOT
44944: IFFALSE 44948
// break ;
44946: GO 45047
// if not HasTask ( j ) then
44948: LD_VAR 0 3
44952: PPUSH
44953: CALL_OW 314
44957: NOT
44958: IFFALSE 45045
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
44960: LD_VAR 0 3
44964: PPUSH
44965: LD_EXP 104
44969: PUSH
44970: LD_VAR 0 2
44974: ARRAY
44975: PUSH
44976: LD_INT 1
44978: ARRAY
44979: PUSH
44980: LD_INT 1
44982: ARRAY
44983: PPUSH
44984: LD_EXP 104
44988: PUSH
44989: LD_VAR 0 2
44993: ARRAY
44994: PUSH
44995: LD_INT 1
44997: ARRAY
44998: PUSH
44999: LD_INT 2
45001: ARRAY
45002: PPUSH
45003: LD_EXP 104
45007: PUSH
45008: LD_VAR 0 2
45012: ARRAY
45013: PUSH
45014: LD_INT 1
45016: ARRAY
45017: PUSH
45018: LD_INT 3
45020: ARRAY
45021: PPUSH
45022: LD_EXP 104
45026: PUSH
45027: LD_VAR 0 2
45031: ARRAY
45032: PUSH
45033: LD_INT 1
45035: ARRAY
45036: PUSH
45037: LD_INT 4
45039: ARRAY
45040: PPUSH
45041: CALL_OW 145
// end ;
45045: GO 44834
45047: POP
45048: POP
// end else
45049: GO 45193
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
45051: LD_EXP 99
45055: PUSH
45056: LD_VAR 0 2
45060: ARRAY
45061: PPUSH
45062: LD_EXP 104
45066: PUSH
45067: LD_VAR 0 2
45071: ARRAY
45072: PUSH
45073: LD_INT 1
45075: ARRAY
45076: PUSH
45077: LD_INT 1
45079: ARRAY
45080: PPUSH
45081: LD_EXP 104
45085: PUSH
45086: LD_VAR 0 2
45090: ARRAY
45091: PUSH
45092: LD_INT 1
45094: ARRAY
45095: PUSH
45096: LD_INT 2
45098: ARRAY
45099: PPUSH
45100: LD_EXP 104
45104: PUSH
45105: LD_VAR 0 2
45109: ARRAY
45110: PUSH
45111: LD_INT 1
45113: ARRAY
45114: PUSH
45115: LD_INT 3
45117: ARRAY
45118: PPUSH
45119: LD_EXP 104
45123: PUSH
45124: LD_VAR 0 2
45128: ARRAY
45129: PUSH
45130: LD_INT 1
45132: ARRAY
45133: PUSH
45134: LD_INT 4
45136: ARRAY
45137: PPUSH
45138: CALL 77960 0 5
45142: NOT
45143: IFFALSE 45193
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
45145: LD_ADDR_EXP 104
45149: PUSH
45150: LD_EXP 104
45154: PPUSH
45155: LD_VAR 0 2
45159: PPUSH
45160: LD_EXP 104
45164: PUSH
45165: LD_VAR 0 2
45169: ARRAY
45170: PPUSH
45171: LD_INT 1
45173: PPUSH
45174: LD_INT 1
45176: NEG
45177: PPUSH
45178: LD_INT 0
45180: PPUSH
45181: CALL 70627 0 4
45185: PPUSH
45186: CALL_OW 1
45190: ST_TO_ADDR
// continue ;
45191: GO 44069
// end ; end ; end ;
45193: GO 44069
45195: POP
45196: POP
// end ;
45197: LD_VAR 0 1
45201: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
45202: LD_INT 0
45204: PPUSH
45205: PPUSH
45206: PPUSH
45207: PPUSH
45208: PPUSH
45209: PPUSH
// if not mc_bases then
45210: LD_EXP 99
45214: NOT
45215: IFFALSE 45219
// exit ;
45217: GO 45646
// for i = 1 to mc_bases do
45219: LD_ADDR_VAR 0 2
45223: PUSH
45224: DOUBLE
45225: LD_INT 1
45227: DEC
45228: ST_TO_ADDR
45229: LD_EXP 99
45233: PUSH
45234: FOR_TO
45235: IFFALSE 45644
// begin tmp := mc_build_upgrade [ i ] ;
45237: LD_ADDR_VAR 0 4
45241: PUSH
45242: LD_EXP 131
45246: PUSH
45247: LD_VAR 0 2
45251: ARRAY
45252: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
45253: LD_ADDR_VAR 0 6
45257: PUSH
45258: LD_EXP 132
45262: PUSH
45263: LD_VAR 0 2
45267: ARRAY
45268: PPUSH
45269: LD_INT 2
45271: PUSH
45272: LD_INT 30
45274: PUSH
45275: LD_INT 6
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: LD_INT 30
45284: PUSH
45285: LD_INT 7
45287: PUSH
45288: EMPTY
45289: LIST
45290: LIST
45291: PUSH
45292: EMPTY
45293: LIST
45294: LIST
45295: LIST
45296: PPUSH
45297: CALL_OW 72
45301: ST_TO_ADDR
// if not tmp and not lab then
45302: LD_VAR 0 4
45306: NOT
45307: PUSH
45308: LD_VAR 0 6
45312: NOT
45313: AND
45314: IFFALSE 45318
// continue ;
45316: GO 45234
// if tmp then
45318: LD_VAR 0 4
45322: IFFALSE 45442
// for j in tmp do
45324: LD_ADDR_VAR 0 3
45328: PUSH
45329: LD_VAR 0 4
45333: PUSH
45334: FOR_IN
45335: IFFALSE 45440
// begin if UpgradeCost ( j ) then
45337: LD_VAR 0 3
45341: PPUSH
45342: CALL 77620 0 1
45346: IFFALSE 45438
// begin ComUpgrade ( j ) ;
45348: LD_VAR 0 3
45352: PPUSH
45353: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
45357: LD_ADDR_EXP 131
45361: PUSH
45362: LD_EXP 131
45366: PPUSH
45367: LD_VAR 0 2
45371: PPUSH
45372: LD_EXP 131
45376: PUSH
45377: LD_VAR 0 2
45381: ARRAY
45382: PUSH
45383: LD_VAR 0 3
45387: DIFF
45388: PPUSH
45389: CALL_OW 1
45393: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45394: LD_ADDR_EXP 106
45398: PUSH
45399: LD_EXP 106
45403: PPUSH
45404: LD_VAR 0 2
45408: PUSH
45409: LD_EXP 106
45413: PUSH
45414: LD_VAR 0 2
45418: ARRAY
45419: PUSH
45420: LD_INT 1
45422: PLUS
45423: PUSH
45424: EMPTY
45425: LIST
45426: LIST
45427: PPUSH
45428: LD_VAR 0 3
45432: PPUSH
45433: CALL 71209 0 3
45437: ST_TO_ADDR
// end ; end ;
45438: GO 45334
45440: POP
45441: POP
// if not lab or not mc_lab_upgrade [ i ] then
45442: LD_VAR 0 6
45446: NOT
45447: PUSH
45448: LD_EXP 133
45452: PUSH
45453: LD_VAR 0 2
45457: ARRAY
45458: NOT
45459: OR
45460: IFFALSE 45464
// continue ;
45462: GO 45234
// for j in lab do
45464: LD_ADDR_VAR 0 3
45468: PUSH
45469: LD_VAR 0 6
45473: PUSH
45474: FOR_IN
45475: IFFALSE 45640
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
45477: LD_VAR 0 3
45481: PPUSH
45482: CALL_OW 266
45486: PUSH
45487: LD_INT 6
45489: PUSH
45490: LD_INT 7
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: IN
45497: PUSH
45498: LD_VAR 0 3
45502: PPUSH
45503: CALL_OW 461
45507: PUSH
45508: LD_INT 1
45510: NONEQUAL
45511: AND
45512: IFFALSE 45638
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
45514: LD_VAR 0 3
45518: PPUSH
45519: LD_EXP 133
45523: PUSH
45524: LD_VAR 0 2
45528: ARRAY
45529: PUSH
45530: LD_INT 1
45532: ARRAY
45533: PPUSH
45534: CALL 77825 0 2
45538: IFFALSE 45638
// begin ComCancel ( j ) ;
45540: LD_VAR 0 3
45544: PPUSH
45545: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
45549: LD_VAR 0 3
45553: PPUSH
45554: LD_EXP 133
45558: PUSH
45559: LD_VAR 0 2
45563: ARRAY
45564: PUSH
45565: LD_INT 1
45567: ARRAY
45568: PPUSH
45569: CALL_OW 207
// if not j in mc_construct_list [ i ] then
45573: LD_VAR 0 3
45577: PUSH
45578: LD_EXP 106
45582: PUSH
45583: LD_VAR 0 2
45587: ARRAY
45588: IN
45589: NOT
45590: IFFALSE 45636
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
45592: LD_ADDR_EXP 106
45596: PUSH
45597: LD_EXP 106
45601: PPUSH
45602: LD_VAR 0 2
45606: PUSH
45607: LD_EXP 106
45611: PUSH
45612: LD_VAR 0 2
45616: ARRAY
45617: PUSH
45618: LD_INT 1
45620: PLUS
45621: PUSH
45622: EMPTY
45623: LIST
45624: LIST
45625: PPUSH
45626: LD_VAR 0 3
45630: PPUSH
45631: CALL 71209 0 3
45635: ST_TO_ADDR
// break ;
45636: GO 45640
// end ; end ; end ;
45638: GO 45474
45640: POP
45641: POP
// end ;
45642: GO 45234
45644: POP
45645: POP
// end ;
45646: LD_VAR 0 1
45650: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
45651: LD_INT 0
45653: PPUSH
45654: PPUSH
45655: PPUSH
45656: PPUSH
45657: PPUSH
45658: PPUSH
45659: PPUSH
45660: PPUSH
45661: PPUSH
// if not mc_bases then
45662: LD_EXP 99
45666: NOT
45667: IFFALSE 45671
// exit ;
45669: GO 46076
// for i = 1 to mc_bases do
45671: LD_ADDR_VAR 0 2
45675: PUSH
45676: DOUBLE
45677: LD_INT 1
45679: DEC
45680: ST_TO_ADDR
45681: LD_EXP 99
45685: PUSH
45686: FOR_TO
45687: IFFALSE 46074
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
45689: LD_EXP 107
45693: PUSH
45694: LD_VAR 0 2
45698: ARRAY
45699: NOT
45700: PUSH
45701: LD_EXP 99
45705: PUSH
45706: LD_VAR 0 2
45710: ARRAY
45711: PPUSH
45712: LD_INT 30
45714: PUSH
45715: LD_INT 3
45717: PUSH
45718: EMPTY
45719: LIST
45720: LIST
45721: PPUSH
45722: CALL_OW 72
45726: NOT
45727: OR
45728: IFFALSE 45732
// continue ;
45730: GO 45686
// busy := false ;
45732: LD_ADDR_VAR 0 8
45736: PUSH
45737: LD_INT 0
45739: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
45740: LD_ADDR_VAR 0 4
45744: PUSH
45745: LD_EXP 99
45749: PUSH
45750: LD_VAR 0 2
45754: ARRAY
45755: PPUSH
45756: LD_INT 30
45758: PUSH
45759: LD_INT 3
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PPUSH
45766: CALL_OW 72
45770: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
45771: LD_ADDR_VAR 0 6
45775: PUSH
45776: LD_EXP 107
45780: PUSH
45781: LD_VAR 0 2
45785: ARRAY
45786: PPUSH
45787: LD_INT 2
45789: PUSH
45790: LD_INT 30
45792: PUSH
45793: LD_INT 32
45795: PUSH
45796: EMPTY
45797: LIST
45798: LIST
45799: PUSH
45800: LD_INT 30
45802: PUSH
45803: LD_INT 33
45805: PUSH
45806: EMPTY
45807: LIST
45808: LIST
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: LIST
45814: PPUSH
45815: CALL_OW 72
45819: ST_TO_ADDR
// if not t then
45820: LD_VAR 0 6
45824: NOT
45825: IFFALSE 45829
// continue ;
45827: GO 45686
// for j in tmp do
45829: LD_ADDR_VAR 0 3
45833: PUSH
45834: LD_VAR 0 4
45838: PUSH
45839: FOR_IN
45840: IFFALSE 45870
// if not BuildingStatus ( j ) = bs_idle then
45842: LD_VAR 0 3
45846: PPUSH
45847: CALL_OW 461
45851: PUSH
45852: LD_INT 2
45854: EQUAL
45855: NOT
45856: IFFALSE 45868
// begin busy := true ;
45858: LD_ADDR_VAR 0 8
45862: PUSH
45863: LD_INT 1
45865: ST_TO_ADDR
// break ;
45866: GO 45870
// end ;
45868: GO 45839
45870: POP
45871: POP
// if busy then
45872: LD_VAR 0 8
45876: IFFALSE 45880
// continue ;
45878: GO 45686
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
45880: LD_ADDR_VAR 0 7
45884: PUSH
45885: LD_VAR 0 6
45889: PPUSH
45890: LD_INT 35
45892: PUSH
45893: LD_INT 0
45895: PUSH
45896: EMPTY
45897: LIST
45898: LIST
45899: PPUSH
45900: CALL_OW 72
45904: ST_TO_ADDR
// if tw then
45905: LD_VAR 0 7
45909: IFFALSE 45986
// begin tw := tw [ 1 ] ;
45911: LD_ADDR_VAR 0 7
45915: PUSH
45916: LD_VAR 0 7
45920: PUSH
45921: LD_INT 1
45923: ARRAY
45924: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
45925: LD_ADDR_VAR 0 9
45929: PUSH
45930: LD_VAR 0 7
45934: PPUSH
45935: LD_EXP 124
45939: PUSH
45940: LD_VAR 0 2
45944: ARRAY
45945: PPUSH
45946: CALL 76179 0 2
45950: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
45951: LD_EXP 138
45955: PUSH
45956: LD_VAR 0 2
45960: ARRAY
45961: IFFALSE 45984
// if not weapon in mc_allowed_tower_weapons [ i ] then
45963: LD_VAR 0 9
45967: PUSH
45968: LD_EXP 138
45972: PUSH
45973: LD_VAR 0 2
45977: ARRAY
45978: IN
45979: NOT
45980: IFFALSE 45984
// continue ;
45982: GO 45686
// end else
45984: GO 46049
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
45986: LD_ADDR_VAR 0 5
45990: PUSH
45991: LD_EXP 107
45995: PUSH
45996: LD_VAR 0 2
46000: ARRAY
46001: PPUSH
46002: LD_VAR 0 4
46006: PPUSH
46007: CALL 106380 0 2
46011: ST_TO_ADDR
// if not tmp2 then
46012: LD_VAR 0 5
46016: NOT
46017: IFFALSE 46021
// continue ;
46019: GO 45686
// tw := tmp2 [ 1 ] ;
46021: LD_ADDR_VAR 0 7
46025: PUSH
46026: LD_VAR 0 5
46030: PUSH
46031: LD_INT 1
46033: ARRAY
46034: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
46035: LD_ADDR_VAR 0 9
46039: PUSH
46040: LD_VAR 0 5
46044: PUSH
46045: LD_INT 2
46047: ARRAY
46048: ST_TO_ADDR
// end ; if not weapon then
46049: LD_VAR 0 9
46053: NOT
46054: IFFALSE 46058
// continue ;
46056: GO 45686
// ComPlaceWeapon ( tw , weapon ) ;
46058: LD_VAR 0 7
46062: PPUSH
46063: LD_VAR 0 9
46067: PPUSH
46068: CALL_OW 148
// end ;
46072: GO 45686
46074: POP
46075: POP
// end ;
46076: LD_VAR 0 1
46080: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
46081: LD_INT 0
46083: PPUSH
46084: PPUSH
46085: PPUSH
46086: PPUSH
46087: PPUSH
46088: PPUSH
// if not mc_bases then
46089: LD_EXP 99
46093: NOT
46094: IFFALSE 46098
// exit ;
46096: GO 47110
// for i = 1 to mc_bases do
46098: LD_ADDR_VAR 0 2
46102: PUSH
46103: DOUBLE
46104: LD_INT 1
46106: DEC
46107: ST_TO_ADDR
46108: LD_EXP 99
46112: PUSH
46113: FOR_TO
46114: IFFALSE 47108
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
46116: LD_EXP 112
46120: PUSH
46121: LD_VAR 0 2
46125: ARRAY
46126: NOT
46127: PUSH
46128: LD_EXP 112
46132: PUSH
46133: LD_VAR 0 2
46137: ARRAY
46138: PUSH
46139: LD_EXP 113
46143: PUSH
46144: LD_VAR 0 2
46148: ARRAY
46149: EQUAL
46150: OR
46151: IFFALSE 46155
// continue ;
46153: GO 46113
// if mc_miners [ i ] then
46155: LD_EXP 113
46159: PUSH
46160: LD_VAR 0 2
46164: ARRAY
46165: IFFALSE 46795
// begin k := 1 ;
46167: LD_ADDR_VAR 0 4
46171: PUSH
46172: LD_INT 1
46174: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
46175: LD_ADDR_VAR 0 3
46179: PUSH
46180: DOUBLE
46181: LD_EXP 113
46185: PUSH
46186: LD_VAR 0 2
46190: ARRAY
46191: INC
46192: ST_TO_ADDR
46193: LD_INT 1
46195: PUSH
46196: FOR_DOWNTO
46197: IFFALSE 46793
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
46199: LD_EXP 113
46203: PUSH
46204: LD_VAR 0 2
46208: ARRAY
46209: PUSH
46210: LD_VAR 0 3
46214: ARRAY
46215: PPUSH
46216: CALL_OW 301
46220: PUSH
46221: LD_EXP 113
46225: PUSH
46226: LD_VAR 0 2
46230: ARRAY
46231: PUSH
46232: LD_VAR 0 3
46236: ARRAY
46237: PPUSH
46238: CALL_OW 257
46242: PUSH
46243: LD_INT 1
46245: NONEQUAL
46246: OR
46247: IFFALSE 46310
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
46249: LD_ADDR_VAR 0 5
46253: PUSH
46254: LD_EXP 113
46258: PUSH
46259: LD_VAR 0 2
46263: ARRAY
46264: PUSH
46265: LD_EXP 113
46269: PUSH
46270: LD_VAR 0 2
46274: ARRAY
46275: PUSH
46276: LD_VAR 0 3
46280: ARRAY
46281: DIFF
46282: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
46283: LD_ADDR_EXP 113
46287: PUSH
46288: LD_EXP 113
46292: PPUSH
46293: LD_VAR 0 2
46297: PPUSH
46298: LD_VAR 0 5
46302: PPUSH
46303: CALL_OW 1
46307: ST_TO_ADDR
// continue ;
46308: GO 46196
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
46310: LD_EXP 113
46314: PUSH
46315: LD_VAR 0 2
46319: ARRAY
46320: PUSH
46321: LD_VAR 0 3
46325: ARRAY
46326: PPUSH
46327: CALL 71145 0 1
46331: PUSH
46332: LD_EXP 113
46336: PUSH
46337: LD_VAR 0 2
46341: ARRAY
46342: PUSH
46343: LD_VAR 0 3
46347: ARRAY
46348: PPUSH
46349: CALL_OW 255
46353: PPUSH
46354: LD_EXP 112
46358: PUSH
46359: LD_VAR 0 2
46363: ARRAY
46364: PUSH
46365: LD_VAR 0 4
46369: ARRAY
46370: PUSH
46371: LD_INT 1
46373: ARRAY
46374: PPUSH
46375: LD_EXP 112
46379: PUSH
46380: LD_VAR 0 2
46384: ARRAY
46385: PUSH
46386: LD_VAR 0 4
46390: ARRAY
46391: PUSH
46392: LD_INT 2
46394: ARRAY
46395: PPUSH
46396: LD_INT 15
46398: PPUSH
46399: CALL 72105 0 4
46403: PUSH
46404: LD_INT 4
46406: ARRAY
46407: PUSH
46408: LD_EXP 113
46412: PUSH
46413: LD_VAR 0 2
46417: ARRAY
46418: PUSH
46419: LD_VAR 0 3
46423: ARRAY
46424: PPUSH
46425: LD_INT 10
46427: PPUSH
46428: CALL 73802 0 2
46432: PUSH
46433: LD_INT 4
46435: ARRAY
46436: OR
46437: AND
46438: IFFALSE 46461
// ComStop ( mc_miners [ i ] [ j ] ) ;
46440: LD_EXP 113
46444: PUSH
46445: LD_VAR 0 2
46449: ARRAY
46450: PUSH
46451: LD_VAR 0 3
46455: ARRAY
46456: PPUSH
46457: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
46461: LD_EXP 113
46465: PUSH
46466: LD_VAR 0 2
46470: ARRAY
46471: PUSH
46472: LD_VAR 0 3
46476: ARRAY
46477: PPUSH
46478: CALL_OW 257
46482: PUSH
46483: LD_INT 1
46485: EQUAL
46486: PUSH
46487: LD_EXP 113
46491: PUSH
46492: LD_VAR 0 2
46496: ARRAY
46497: PUSH
46498: LD_VAR 0 3
46502: ARRAY
46503: PPUSH
46504: CALL_OW 459
46508: NOT
46509: AND
46510: PUSH
46511: LD_EXP 113
46515: PUSH
46516: LD_VAR 0 2
46520: ARRAY
46521: PUSH
46522: LD_VAR 0 3
46526: ARRAY
46527: PPUSH
46528: CALL_OW 255
46532: PPUSH
46533: LD_EXP 112
46537: PUSH
46538: LD_VAR 0 2
46542: ARRAY
46543: PUSH
46544: LD_VAR 0 4
46548: ARRAY
46549: PUSH
46550: LD_INT 1
46552: ARRAY
46553: PPUSH
46554: LD_EXP 112
46558: PUSH
46559: LD_VAR 0 2
46563: ARRAY
46564: PUSH
46565: LD_VAR 0 4
46569: ARRAY
46570: PUSH
46571: LD_INT 2
46573: ARRAY
46574: PPUSH
46575: LD_INT 15
46577: PPUSH
46578: CALL 72105 0 4
46582: PUSH
46583: LD_INT 4
46585: ARRAY
46586: PUSH
46587: LD_INT 0
46589: EQUAL
46590: AND
46591: PUSH
46592: LD_EXP 113
46596: PUSH
46597: LD_VAR 0 2
46601: ARRAY
46602: PUSH
46603: LD_VAR 0 3
46607: ARRAY
46608: PPUSH
46609: CALL_OW 314
46613: NOT
46614: AND
46615: IFFALSE 46791
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
46617: LD_EXP 113
46621: PUSH
46622: LD_VAR 0 2
46626: ARRAY
46627: PUSH
46628: LD_VAR 0 3
46632: ARRAY
46633: PPUSH
46634: CALL_OW 310
46638: IFFALSE 46661
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
46640: LD_EXP 113
46644: PUSH
46645: LD_VAR 0 2
46649: ARRAY
46650: PUSH
46651: LD_VAR 0 3
46655: ARRAY
46656: PPUSH
46657: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
46661: LD_EXP 113
46665: PUSH
46666: LD_VAR 0 2
46670: ARRAY
46671: PUSH
46672: LD_VAR 0 3
46676: ARRAY
46677: PPUSH
46678: CALL_OW 314
46682: NOT
46683: IFFALSE 46751
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
46685: LD_EXP 113
46689: PUSH
46690: LD_VAR 0 2
46694: ARRAY
46695: PUSH
46696: LD_VAR 0 3
46700: ARRAY
46701: PPUSH
46702: LD_EXP 112
46706: PUSH
46707: LD_VAR 0 2
46711: ARRAY
46712: PUSH
46713: LD_VAR 0 4
46717: ARRAY
46718: PUSH
46719: LD_INT 1
46721: ARRAY
46722: PPUSH
46723: LD_EXP 112
46727: PUSH
46728: LD_VAR 0 2
46732: ARRAY
46733: PUSH
46734: LD_VAR 0 4
46738: ARRAY
46739: PUSH
46740: LD_INT 2
46742: ARRAY
46743: PPUSH
46744: LD_INT 0
46746: PPUSH
46747: CALL_OW 193
// k := k + 1 ;
46751: LD_ADDR_VAR 0 4
46755: PUSH
46756: LD_VAR 0 4
46760: PUSH
46761: LD_INT 1
46763: PLUS
46764: ST_TO_ADDR
// if k > mc_mines [ i ] then
46765: LD_VAR 0 4
46769: PUSH
46770: LD_EXP 112
46774: PUSH
46775: LD_VAR 0 2
46779: ARRAY
46780: GREATER
46781: IFFALSE 46791
// k := 1 ;
46783: LD_ADDR_VAR 0 4
46787: PUSH
46788: LD_INT 1
46790: ST_TO_ADDR
// end ; end ;
46791: GO 46196
46793: POP
46794: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
46795: LD_ADDR_VAR 0 5
46799: PUSH
46800: LD_EXP 99
46804: PUSH
46805: LD_VAR 0 2
46809: ARRAY
46810: PPUSH
46811: LD_INT 2
46813: PUSH
46814: LD_INT 30
46816: PUSH
46817: LD_INT 4
46819: PUSH
46820: EMPTY
46821: LIST
46822: LIST
46823: PUSH
46824: LD_INT 30
46826: PUSH
46827: LD_INT 5
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: PUSH
46834: LD_INT 30
46836: PUSH
46837: LD_INT 32
46839: PUSH
46840: EMPTY
46841: LIST
46842: LIST
46843: PUSH
46844: EMPTY
46845: LIST
46846: LIST
46847: LIST
46848: LIST
46849: PPUSH
46850: CALL_OW 72
46854: ST_TO_ADDR
// if not tmp then
46855: LD_VAR 0 5
46859: NOT
46860: IFFALSE 46864
// continue ;
46862: GO 46113
// list := [ ] ;
46864: LD_ADDR_VAR 0 6
46868: PUSH
46869: EMPTY
46870: ST_TO_ADDR
// for j in tmp do
46871: LD_ADDR_VAR 0 3
46875: PUSH
46876: LD_VAR 0 5
46880: PUSH
46881: FOR_IN
46882: IFFALSE 46951
// begin for k in UnitsInside ( j ) do
46884: LD_ADDR_VAR 0 4
46888: PUSH
46889: LD_VAR 0 3
46893: PPUSH
46894: CALL_OW 313
46898: PUSH
46899: FOR_IN
46900: IFFALSE 46947
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
46902: LD_VAR 0 4
46906: PPUSH
46907: CALL_OW 257
46911: PUSH
46912: LD_INT 1
46914: EQUAL
46915: PUSH
46916: LD_VAR 0 4
46920: PPUSH
46921: CALL_OW 459
46925: NOT
46926: AND
46927: IFFALSE 46945
// list := list ^ k ;
46929: LD_ADDR_VAR 0 6
46933: PUSH
46934: LD_VAR 0 6
46938: PUSH
46939: LD_VAR 0 4
46943: ADD
46944: ST_TO_ADDR
46945: GO 46899
46947: POP
46948: POP
// end ;
46949: GO 46881
46951: POP
46952: POP
// list := list diff mc_miners [ i ] ;
46953: LD_ADDR_VAR 0 6
46957: PUSH
46958: LD_VAR 0 6
46962: PUSH
46963: LD_EXP 113
46967: PUSH
46968: LD_VAR 0 2
46972: ARRAY
46973: DIFF
46974: ST_TO_ADDR
// if not list then
46975: LD_VAR 0 6
46979: NOT
46980: IFFALSE 46984
// continue ;
46982: GO 46113
// k := mc_mines [ i ] - mc_miners [ i ] ;
46984: LD_ADDR_VAR 0 4
46988: PUSH
46989: LD_EXP 112
46993: PUSH
46994: LD_VAR 0 2
46998: ARRAY
46999: PUSH
47000: LD_EXP 113
47004: PUSH
47005: LD_VAR 0 2
47009: ARRAY
47010: MINUS
47011: ST_TO_ADDR
// if k > list then
47012: LD_VAR 0 4
47016: PUSH
47017: LD_VAR 0 6
47021: GREATER
47022: IFFALSE 47034
// k := list ;
47024: LD_ADDR_VAR 0 4
47028: PUSH
47029: LD_VAR 0 6
47033: ST_TO_ADDR
// for j = 1 to k do
47034: LD_ADDR_VAR 0 3
47038: PUSH
47039: DOUBLE
47040: LD_INT 1
47042: DEC
47043: ST_TO_ADDR
47044: LD_VAR 0 4
47048: PUSH
47049: FOR_TO
47050: IFFALSE 47104
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
47052: LD_ADDR_EXP 113
47056: PUSH
47057: LD_EXP 113
47061: PPUSH
47062: LD_VAR 0 2
47066: PUSH
47067: LD_EXP 113
47071: PUSH
47072: LD_VAR 0 2
47076: ARRAY
47077: PUSH
47078: LD_INT 1
47080: PLUS
47081: PUSH
47082: EMPTY
47083: LIST
47084: LIST
47085: PPUSH
47086: LD_VAR 0 6
47090: PUSH
47091: LD_VAR 0 3
47095: ARRAY
47096: PPUSH
47097: CALL 71209 0 3
47101: ST_TO_ADDR
47102: GO 47049
47104: POP
47105: POP
// end ;
47106: GO 46113
47108: POP
47109: POP
// end ;
47110: LD_VAR 0 1
47114: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
47115: LD_INT 0
47117: PPUSH
47118: PPUSH
47119: PPUSH
47120: PPUSH
47121: PPUSH
47122: PPUSH
47123: PPUSH
47124: PPUSH
47125: PPUSH
47126: PPUSH
// if not mc_bases then
47127: LD_EXP 99
47131: NOT
47132: IFFALSE 47136
// exit ;
47134: GO 48886
// for i = 1 to mc_bases do
47136: LD_ADDR_VAR 0 2
47140: PUSH
47141: DOUBLE
47142: LD_INT 1
47144: DEC
47145: ST_TO_ADDR
47146: LD_EXP 99
47150: PUSH
47151: FOR_TO
47152: IFFALSE 48884
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
47154: LD_EXP 99
47158: PUSH
47159: LD_VAR 0 2
47163: ARRAY
47164: NOT
47165: PUSH
47166: LD_EXP 106
47170: PUSH
47171: LD_VAR 0 2
47175: ARRAY
47176: OR
47177: IFFALSE 47181
// continue ;
47179: GO 47151
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
47181: LD_EXP 115
47185: PUSH
47186: LD_VAR 0 2
47190: ARRAY
47191: NOT
47192: PUSH
47193: LD_EXP 116
47197: PUSH
47198: LD_VAR 0 2
47202: ARRAY
47203: AND
47204: IFFALSE 47242
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
47206: LD_ADDR_EXP 116
47210: PUSH
47211: LD_EXP 116
47215: PPUSH
47216: LD_VAR 0 2
47220: PPUSH
47221: EMPTY
47222: PPUSH
47223: CALL_OW 1
47227: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
47228: LD_VAR 0 2
47232: PPUSH
47233: LD_INT 107
47235: PPUSH
47236: CALL 37996 0 2
// continue ;
47240: GO 47151
// end ; target := [ ] ;
47242: LD_ADDR_VAR 0 6
47246: PUSH
47247: EMPTY
47248: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
47249: LD_ADDR_VAR 0 3
47253: PUSH
47254: DOUBLE
47255: LD_EXP 115
47259: PUSH
47260: LD_VAR 0 2
47264: ARRAY
47265: INC
47266: ST_TO_ADDR
47267: LD_INT 1
47269: PUSH
47270: FOR_DOWNTO
47271: IFFALSE 47531
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
47273: LD_EXP 115
47277: PUSH
47278: LD_VAR 0 2
47282: ARRAY
47283: PUSH
47284: LD_VAR 0 3
47288: ARRAY
47289: PUSH
47290: LD_INT 2
47292: ARRAY
47293: PPUSH
47294: LD_EXP 115
47298: PUSH
47299: LD_VAR 0 2
47303: ARRAY
47304: PUSH
47305: LD_VAR 0 3
47309: ARRAY
47310: PUSH
47311: LD_INT 3
47313: ARRAY
47314: PPUSH
47315: CALL_OW 488
47319: PUSH
47320: LD_EXP 115
47324: PUSH
47325: LD_VAR 0 2
47329: ARRAY
47330: PUSH
47331: LD_VAR 0 3
47335: ARRAY
47336: PUSH
47337: LD_INT 2
47339: ARRAY
47340: PPUSH
47341: LD_EXP 115
47345: PUSH
47346: LD_VAR 0 2
47350: ARRAY
47351: PUSH
47352: LD_VAR 0 3
47356: ARRAY
47357: PUSH
47358: LD_INT 3
47360: ARRAY
47361: PPUSH
47362: CALL_OW 284
47366: PUSH
47367: LD_INT 0
47369: EQUAL
47370: AND
47371: IFFALSE 47426
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
47373: LD_ADDR_VAR 0 5
47377: PUSH
47378: LD_EXP 115
47382: PUSH
47383: LD_VAR 0 2
47387: ARRAY
47388: PPUSH
47389: LD_VAR 0 3
47393: PPUSH
47394: CALL_OW 3
47398: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
47399: LD_ADDR_EXP 115
47403: PUSH
47404: LD_EXP 115
47408: PPUSH
47409: LD_VAR 0 2
47413: PPUSH
47414: LD_VAR 0 5
47418: PPUSH
47419: CALL_OW 1
47423: ST_TO_ADDR
// continue ;
47424: GO 47270
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
47426: LD_EXP 99
47430: PUSH
47431: LD_VAR 0 2
47435: ARRAY
47436: PUSH
47437: LD_INT 1
47439: ARRAY
47440: PPUSH
47441: CALL_OW 255
47445: PPUSH
47446: LD_EXP 115
47450: PUSH
47451: LD_VAR 0 2
47455: ARRAY
47456: PUSH
47457: LD_VAR 0 3
47461: ARRAY
47462: PUSH
47463: LD_INT 2
47465: ARRAY
47466: PPUSH
47467: LD_EXP 115
47471: PUSH
47472: LD_VAR 0 2
47476: ARRAY
47477: PUSH
47478: LD_VAR 0 3
47482: ARRAY
47483: PUSH
47484: LD_INT 3
47486: ARRAY
47487: PPUSH
47488: LD_INT 30
47490: PPUSH
47491: CALL 72105 0 4
47495: PUSH
47496: LD_INT 4
47498: ARRAY
47499: PUSH
47500: LD_INT 0
47502: EQUAL
47503: IFFALSE 47529
// begin target := mc_crates [ i ] [ j ] ;
47505: LD_ADDR_VAR 0 6
47509: PUSH
47510: LD_EXP 115
47514: PUSH
47515: LD_VAR 0 2
47519: ARRAY
47520: PUSH
47521: LD_VAR 0 3
47525: ARRAY
47526: ST_TO_ADDR
// break ;
47527: GO 47531
// end ; end ;
47529: GO 47270
47531: POP
47532: POP
// if not target then
47533: LD_VAR 0 6
47537: NOT
47538: IFFALSE 47542
// continue ;
47540: GO 47151
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
47542: LD_ADDR_VAR 0 7
47546: PUSH
47547: LD_EXP 118
47551: PUSH
47552: LD_VAR 0 2
47556: ARRAY
47557: PPUSH
47558: LD_INT 2
47560: PUSH
47561: LD_INT 3
47563: PUSH
47564: LD_INT 58
47566: PUSH
47567: EMPTY
47568: LIST
47569: PUSH
47570: EMPTY
47571: LIST
47572: LIST
47573: PUSH
47574: LD_INT 61
47576: PUSH
47577: EMPTY
47578: LIST
47579: PUSH
47580: LD_INT 33
47582: PUSH
47583: LD_INT 5
47585: PUSH
47586: EMPTY
47587: LIST
47588: LIST
47589: PUSH
47590: LD_INT 33
47592: PUSH
47593: LD_INT 3
47595: PUSH
47596: EMPTY
47597: LIST
47598: LIST
47599: PUSH
47600: EMPTY
47601: LIST
47602: LIST
47603: LIST
47604: LIST
47605: LIST
47606: PUSH
47607: LD_INT 2
47609: PUSH
47610: LD_INT 34
47612: PUSH
47613: LD_INT 32
47615: PUSH
47616: EMPTY
47617: LIST
47618: LIST
47619: PUSH
47620: LD_INT 34
47622: PUSH
47623: LD_INT 51
47625: PUSH
47626: EMPTY
47627: LIST
47628: LIST
47629: PUSH
47630: LD_INT 34
47632: PUSH
47633: LD_INT 12
47635: PUSH
47636: EMPTY
47637: LIST
47638: LIST
47639: PUSH
47640: EMPTY
47641: LIST
47642: LIST
47643: LIST
47644: LIST
47645: PUSH
47646: EMPTY
47647: LIST
47648: LIST
47649: PPUSH
47650: CALL_OW 72
47654: ST_TO_ADDR
// if not cargo then
47655: LD_VAR 0 7
47659: NOT
47660: IFFALSE 48303
// begin if mc_crates_collector [ i ] < 5 then
47662: LD_EXP 116
47666: PUSH
47667: LD_VAR 0 2
47671: ARRAY
47672: PUSH
47673: LD_INT 5
47675: LESS
47676: IFFALSE 48042
// begin if mc_ape [ i ] then
47678: LD_EXP 128
47682: PUSH
47683: LD_VAR 0 2
47687: ARRAY
47688: IFFALSE 47735
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
47690: LD_ADDR_VAR 0 5
47694: PUSH
47695: LD_EXP 128
47699: PUSH
47700: LD_VAR 0 2
47704: ARRAY
47705: PPUSH
47706: LD_INT 25
47708: PUSH
47709: LD_INT 16
47711: PUSH
47712: EMPTY
47713: LIST
47714: LIST
47715: PUSH
47716: LD_INT 24
47718: PUSH
47719: LD_INT 750
47721: PUSH
47722: EMPTY
47723: LIST
47724: LIST
47725: PUSH
47726: EMPTY
47727: LIST
47728: LIST
47729: PPUSH
47730: CALL_OW 72
47734: ST_TO_ADDR
// if not tmp then
47735: LD_VAR 0 5
47739: NOT
47740: IFFALSE 47787
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
47742: LD_ADDR_VAR 0 5
47746: PUSH
47747: LD_EXP 99
47751: PUSH
47752: LD_VAR 0 2
47756: ARRAY
47757: PPUSH
47758: LD_INT 25
47760: PUSH
47761: LD_INT 2
47763: PUSH
47764: EMPTY
47765: LIST
47766: LIST
47767: PUSH
47768: LD_INT 24
47770: PUSH
47771: LD_INT 750
47773: PUSH
47774: EMPTY
47775: LIST
47776: LIST
47777: PUSH
47778: EMPTY
47779: LIST
47780: LIST
47781: PPUSH
47782: CALL_OW 72
47786: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
47787: LD_EXP 128
47791: PUSH
47792: LD_VAR 0 2
47796: ARRAY
47797: PUSH
47798: LD_EXP 99
47802: PUSH
47803: LD_VAR 0 2
47807: ARRAY
47808: PPUSH
47809: LD_INT 25
47811: PUSH
47812: LD_INT 2
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PUSH
47819: LD_INT 24
47821: PUSH
47822: LD_INT 750
47824: PUSH
47825: EMPTY
47826: LIST
47827: LIST
47828: PUSH
47829: EMPTY
47830: LIST
47831: LIST
47832: PPUSH
47833: CALL_OW 72
47837: AND
47838: PUSH
47839: LD_VAR 0 5
47843: PUSH
47844: LD_INT 5
47846: LESS
47847: AND
47848: IFFALSE 47930
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
47850: LD_ADDR_VAR 0 3
47854: PUSH
47855: LD_EXP 99
47859: PUSH
47860: LD_VAR 0 2
47864: ARRAY
47865: PPUSH
47866: LD_INT 25
47868: PUSH
47869: LD_INT 2
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: PUSH
47876: LD_INT 24
47878: PUSH
47879: LD_INT 750
47881: PUSH
47882: EMPTY
47883: LIST
47884: LIST
47885: PUSH
47886: EMPTY
47887: LIST
47888: LIST
47889: PPUSH
47890: CALL_OW 72
47894: PUSH
47895: FOR_IN
47896: IFFALSE 47928
// begin tmp := tmp union j ;
47898: LD_ADDR_VAR 0 5
47902: PUSH
47903: LD_VAR 0 5
47907: PUSH
47908: LD_VAR 0 3
47912: UNION
47913: ST_TO_ADDR
// if tmp >= 5 then
47914: LD_VAR 0 5
47918: PUSH
47919: LD_INT 5
47921: GREATEREQUAL
47922: IFFALSE 47926
// break ;
47924: GO 47928
// end ;
47926: GO 47895
47928: POP
47929: POP
// end ; if not tmp then
47930: LD_VAR 0 5
47934: NOT
47935: IFFALSE 47939
// continue ;
47937: GO 47151
// for j in tmp do
47939: LD_ADDR_VAR 0 3
47943: PUSH
47944: LD_VAR 0 5
47948: PUSH
47949: FOR_IN
47950: IFFALSE 48040
// if not GetTag ( j ) then
47952: LD_VAR 0 3
47956: PPUSH
47957: CALL_OW 110
47961: NOT
47962: IFFALSE 48038
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
47964: LD_ADDR_EXP 116
47968: PUSH
47969: LD_EXP 116
47973: PPUSH
47974: LD_VAR 0 2
47978: PUSH
47979: LD_EXP 116
47983: PUSH
47984: LD_VAR 0 2
47988: ARRAY
47989: PUSH
47990: LD_INT 1
47992: PLUS
47993: PUSH
47994: EMPTY
47995: LIST
47996: LIST
47997: PPUSH
47998: LD_VAR 0 3
48002: PPUSH
48003: CALL 71209 0 3
48007: ST_TO_ADDR
// SetTag ( j , 107 ) ;
48008: LD_VAR 0 3
48012: PPUSH
48013: LD_INT 107
48015: PPUSH
48016: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
48020: LD_EXP 116
48024: PUSH
48025: LD_VAR 0 2
48029: ARRAY
48030: PUSH
48031: LD_INT 5
48033: GREATEREQUAL
48034: IFFALSE 48038
// break ;
48036: GO 48040
// end ;
48038: GO 47949
48040: POP
48041: POP
// end ; if mc_crates_collector [ i ] and target then
48042: LD_EXP 116
48046: PUSH
48047: LD_VAR 0 2
48051: ARRAY
48052: PUSH
48053: LD_VAR 0 6
48057: AND
48058: IFFALSE 48301
// begin if mc_crates_collector [ i ] < target [ 1 ] then
48060: LD_EXP 116
48064: PUSH
48065: LD_VAR 0 2
48069: ARRAY
48070: PUSH
48071: LD_VAR 0 6
48075: PUSH
48076: LD_INT 1
48078: ARRAY
48079: LESS
48080: IFFALSE 48100
// tmp := mc_crates_collector [ i ] else
48082: LD_ADDR_VAR 0 5
48086: PUSH
48087: LD_EXP 116
48091: PUSH
48092: LD_VAR 0 2
48096: ARRAY
48097: ST_TO_ADDR
48098: GO 48114
// tmp := target [ 1 ] ;
48100: LD_ADDR_VAR 0 5
48104: PUSH
48105: LD_VAR 0 6
48109: PUSH
48110: LD_INT 1
48112: ARRAY
48113: ST_TO_ADDR
// k := 0 ;
48114: LD_ADDR_VAR 0 4
48118: PUSH
48119: LD_INT 0
48121: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
48122: LD_ADDR_VAR 0 3
48126: PUSH
48127: LD_EXP 116
48131: PUSH
48132: LD_VAR 0 2
48136: ARRAY
48137: PUSH
48138: FOR_IN
48139: IFFALSE 48299
// begin k := k + 1 ;
48141: LD_ADDR_VAR 0 4
48145: PUSH
48146: LD_VAR 0 4
48150: PUSH
48151: LD_INT 1
48153: PLUS
48154: ST_TO_ADDR
// if k > tmp then
48155: LD_VAR 0 4
48159: PUSH
48160: LD_VAR 0 5
48164: GREATER
48165: IFFALSE 48169
// break ;
48167: GO 48299
// if not GetClass ( j ) in [ 2 , 16 ] then
48169: LD_VAR 0 3
48173: PPUSH
48174: CALL_OW 257
48178: PUSH
48179: LD_INT 2
48181: PUSH
48182: LD_INT 16
48184: PUSH
48185: EMPTY
48186: LIST
48187: LIST
48188: IN
48189: NOT
48190: IFFALSE 48243
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
48192: LD_ADDR_EXP 116
48196: PUSH
48197: LD_EXP 116
48201: PPUSH
48202: LD_VAR 0 2
48206: PPUSH
48207: LD_EXP 116
48211: PUSH
48212: LD_VAR 0 2
48216: ARRAY
48217: PUSH
48218: LD_VAR 0 3
48222: DIFF
48223: PPUSH
48224: CALL_OW 1
48228: ST_TO_ADDR
// SetTag ( j , 0 ) ;
48229: LD_VAR 0 3
48233: PPUSH
48234: LD_INT 0
48236: PPUSH
48237: CALL_OW 109
// continue ;
48241: GO 48138
// end ; if IsInUnit ( j ) then
48243: LD_VAR 0 3
48247: PPUSH
48248: CALL_OW 310
48252: IFFALSE 48263
// ComExitBuilding ( j ) ;
48254: LD_VAR 0 3
48258: PPUSH
48259: CALL_OW 122
// wait ( 3 ) ;
48263: LD_INT 3
48265: PPUSH
48266: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48270: LD_VAR 0 3
48274: PPUSH
48275: LD_VAR 0 6
48279: PUSH
48280: LD_INT 2
48282: ARRAY
48283: PPUSH
48284: LD_VAR 0 6
48288: PUSH
48289: LD_INT 3
48291: ARRAY
48292: PPUSH
48293: CALL_OW 117
// end ;
48297: GO 48138
48299: POP
48300: POP
// end ; end else
48301: GO 48882
// begin for j in cargo do
48303: LD_ADDR_VAR 0 3
48307: PUSH
48308: LD_VAR 0 7
48312: PUSH
48313: FOR_IN
48314: IFFALSE 48880
// begin if GetTag ( j ) <> 0 then
48316: LD_VAR 0 3
48320: PPUSH
48321: CALL_OW 110
48325: PUSH
48326: LD_INT 0
48328: NONEQUAL
48329: IFFALSE 48333
// continue ;
48331: GO 48313
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
48333: LD_VAR 0 3
48337: PPUSH
48338: CALL_OW 256
48342: PUSH
48343: LD_INT 1000
48345: LESS
48346: PUSH
48347: LD_VAR 0 3
48351: PPUSH
48352: LD_EXP 123
48356: PUSH
48357: LD_VAR 0 2
48361: ARRAY
48362: PPUSH
48363: CALL_OW 308
48367: NOT
48368: AND
48369: IFFALSE 48391
// ComMoveToArea ( j , mc_parking [ i ] ) ;
48371: LD_VAR 0 3
48375: PPUSH
48376: LD_EXP 123
48380: PUSH
48381: LD_VAR 0 2
48385: ARRAY
48386: PPUSH
48387: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
48391: LD_VAR 0 3
48395: PPUSH
48396: CALL_OW 256
48400: PUSH
48401: LD_INT 1000
48403: LESS
48404: PUSH
48405: LD_VAR 0 3
48409: PPUSH
48410: LD_EXP 123
48414: PUSH
48415: LD_VAR 0 2
48419: ARRAY
48420: PPUSH
48421: CALL_OW 308
48425: AND
48426: IFFALSE 48430
// continue ;
48428: GO 48313
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
48430: LD_VAR 0 3
48434: PPUSH
48435: CALL_OW 262
48439: PUSH
48440: LD_INT 2
48442: EQUAL
48443: PUSH
48444: LD_VAR 0 3
48448: PPUSH
48449: CALL_OW 261
48453: PUSH
48454: LD_INT 15
48456: LESS
48457: AND
48458: IFFALSE 48462
// continue ;
48460: GO 48313
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
48462: LD_VAR 0 3
48466: PPUSH
48467: CALL_OW 262
48471: PUSH
48472: LD_INT 1
48474: EQUAL
48475: PUSH
48476: LD_VAR 0 3
48480: PPUSH
48481: CALL_OW 261
48485: PUSH
48486: LD_INT 10
48488: LESS
48489: AND
48490: IFFALSE 48819
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
48492: LD_ADDR_VAR 0 8
48496: PUSH
48497: LD_EXP 99
48501: PUSH
48502: LD_VAR 0 2
48506: ARRAY
48507: PPUSH
48508: LD_INT 2
48510: PUSH
48511: LD_INT 30
48513: PUSH
48514: LD_INT 0
48516: PUSH
48517: EMPTY
48518: LIST
48519: LIST
48520: PUSH
48521: LD_INT 30
48523: PUSH
48524: LD_INT 1
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: PUSH
48531: EMPTY
48532: LIST
48533: LIST
48534: LIST
48535: PPUSH
48536: CALL_OW 72
48540: ST_TO_ADDR
// if not depot then
48541: LD_VAR 0 8
48545: NOT
48546: IFFALSE 48550
// continue ;
48548: GO 48313
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
48550: LD_VAR 0 3
48554: PPUSH
48555: LD_VAR 0 8
48559: PPUSH
48560: LD_VAR 0 3
48564: PPUSH
48565: CALL_OW 74
48569: PPUSH
48570: CALL_OW 296
48574: PUSH
48575: LD_INT 6
48577: LESS
48578: IFFALSE 48594
// SetFuel ( j , 100 ) else
48580: LD_VAR 0 3
48584: PPUSH
48585: LD_INT 100
48587: PPUSH
48588: CALL_OW 240
48592: GO 48819
// if GetFuel ( j ) = 0 then
48594: LD_VAR 0 3
48598: PPUSH
48599: CALL_OW 261
48603: PUSH
48604: LD_INT 0
48606: EQUAL
48607: IFFALSE 48819
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
48609: LD_ADDR_EXP 118
48613: PUSH
48614: LD_EXP 118
48618: PPUSH
48619: LD_VAR 0 2
48623: PPUSH
48624: LD_EXP 118
48628: PUSH
48629: LD_VAR 0 2
48633: ARRAY
48634: PUSH
48635: LD_VAR 0 3
48639: DIFF
48640: PPUSH
48641: CALL_OW 1
48645: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
48646: LD_VAR 0 3
48650: PPUSH
48651: CALL_OW 263
48655: PUSH
48656: LD_INT 1
48658: EQUAL
48659: IFFALSE 48675
// ComExitVehicle ( IsInUnit ( j ) ) ;
48661: LD_VAR 0 3
48665: PPUSH
48666: CALL_OW 310
48670: PPUSH
48671: CALL_OW 121
// if GetControl ( j ) = control_remote then
48675: LD_VAR 0 3
48679: PPUSH
48680: CALL_OW 263
48684: PUSH
48685: LD_INT 2
48687: EQUAL
48688: IFFALSE 48699
// ComUnlink ( j ) ;
48690: LD_VAR 0 3
48694: PPUSH
48695: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
48699: LD_ADDR_VAR 0 9
48703: PUSH
48704: LD_VAR 0 2
48708: PPUSH
48709: LD_INT 3
48711: PPUSH
48712: CALL 58172 0 2
48716: ST_TO_ADDR
// if fac then
48717: LD_VAR 0 9
48721: IFFALSE 48817
// begin for k in fac do
48723: LD_ADDR_VAR 0 4
48727: PUSH
48728: LD_VAR 0 9
48732: PUSH
48733: FOR_IN
48734: IFFALSE 48815
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
48736: LD_ADDR_VAR 0 10
48740: PUSH
48741: LD_VAR 0 9
48745: PPUSH
48746: LD_VAR 0 3
48750: PPUSH
48751: CALL_OW 265
48755: PPUSH
48756: LD_VAR 0 3
48760: PPUSH
48761: CALL_OW 262
48765: PPUSH
48766: LD_VAR 0 3
48770: PPUSH
48771: CALL_OW 263
48775: PPUSH
48776: LD_VAR 0 3
48780: PPUSH
48781: CALL_OW 264
48785: PPUSH
48786: CALL 68741 0 5
48790: ST_TO_ADDR
// if components then
48791: LD_VAR 0 10
48795: IFFALSE 48813
// begin MC_InsertProduceList ( i , components ) ;
48797: LD_VAR 0 2
48801: PPUSH
48802: LD_VAR 0 10
48806: PPUSH
48807: CALL 57717 0 2
// break ;
48811: GO 48815
// end ; end ;
48813: GO 48733
48815: POP
48816: POP
// end ; continue ;
48817: GO 48313
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
48819: LD_VAR 0 3
48823: PPUSH
48824: LD_INT 1
48826: PPUSH
48827: CALL_OW 289
48831: PUSH
48832: LD_INT 100
48834: LESS
48835: PUSH
48836: LD_VAR 0 3
48840: PPUSH
48841: CALL_OW 314
48845: NOT
48846: AND
48847: IFFALSE 48876
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
48849: LD_VAR 0 3
48853: PPUSH
48854: LD_VAR 0 6
48858: PUSH
48859: LD_INT 2
48861: ARRAY
48862: PPUSH
48863: LD_VAR 0 6
48867: PUSH
48868: LD_INT 3
48870: ARRAY
48871: PPUSH
48872: CALL_OW 117
// break ;
48876: GO 48880
// end ;
48878: GO 48313
48880: POP
48881: POP
// end ; end ;
48882: GO 47151
48884: POP
48885: POP
// end ;
48886: LD_VAR 0 1
48890: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
48891: LD_INT 0
48893: PPUSH
48894: PPUSH
48895: PPUSH
48896: PPUSH
// if not mc_bases then
48897: LD_EXP 99
48901: NOT
48902: IFFALSE 48906
// exit ;
48904: GO 49067
// for i = 1 to mc_bases do
48906: LD_ADDR_VAR 0 2
48910: PUSH
48911: DOUBLE
48912: LD_INT 1
48914: DEC
48915: ST_TO_ADDR
48916: LD_EXP 99
48920: PUSH
48921: FOR_TO
48922: IFFALSE 49065
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
48924: LD_ADDR_VAR 0 4
48928: PUSH
48929: LD_EXP 118
48933: PUSH
48934: LD_VAR 0 2
48938: ARRAY
48939: PUSH
48940: LD_EXP 121
48944: PUSH
48945: LD_VAR 0 2
48949: ARRAY
48950: UNION
48951: PPUSH
48952: LD_INT 33
48954: PUSH
48955: LD_INT 2
48957: PUSH
48958: EMPTY
48959: LIST
48960: LIST
48961: PPUSH
48962: CALL_OW 72
48966: ST_TO_ADDR
// if tmp then
48967: LD_VAR 0 4
48971: IFFALSE 49063
// for j in tmp do
48973: LD_ADDR_VAR 0 3
48977: PUSH
48978: LD_VAR 0 4
48982: PUSH
48983: FOR_IN
48984: IFFALSE 49061
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
48986: LD_VAR 0 3
48990: PPUSH
48991: CALL_OW 312
48995: NOT
48996: PUSH
48997: LD_VAR 0 3
49001: PPUSH
49002: CALL_OW 256
49006: PUSH
49007: LD_INT 250
49009: GREATEREQUAL
49010: AND
49011: IFFALSE 49024
// Connect ( j ) else
49013: LD_VAR 0 3
49017: PPUSH
49018: CALL 74142 0 1
49022: GO 49059
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
49024: LD_VAR 0 3
49028: PPUSH
49029: CALL_OW 256
49033: PUSH
49034: LD_INT 250
49036: LESS
49037: PUSH
49038: LD_VAR 0 3
49042: PPUSH
49043: CALL_OW 312
49047: AND
49048: IFFALSE 49059
// ComUnlink ( j ) ;
49050: LD_VAR 0 3
49054: PPUSH
49055: CALL_OW 136
49059: GO 48983
49061: POP
49062: POP
// end ;
49063: GO 48921
49065: POP
49066: POP
// end ;
49067: LD_VAR 0 1
49071: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
49072: LD_INT 0
49074: PPUSH
49075: PPUSH
49076: PPUSH
49077: PPUSH
49078: PPUSH
// if not mc_bases then
49079: LD_EXP 99
49083: NOT
49084: IFFALSE 49088
// exit ;
49086: GO 49533
// for i = 1 to mc_bases do
49088: LD_ADDR_VAR 0 2
49092: PUSH
49093: DOUBLE
49094: LD_INT 1
49096: DEC
49097: ST_TO_ADDR
49098: LD_EXP 99
49102: PUSH
49103: FOR_TO
49104: IFFALSE 49531
// begin if not mc_produce [ i ] then
49106: LD_EXP 120
49110: PUSH
49111: LD_VAR 0 2
49115: ARRAY
49116: NOT
49117: IFFALSE 49121
// continue ;
49119: GO 49103
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
49121: LD_ADDR_VAR 0 5
49125: PUSH
49126: LD_EXP 99
49130: PUSH
49131: LD_VAR 0 2
49135: ARRAY
49136: PPUSH
49137: LD_INT 30
49139: PUSH
49140: LD_INT 3
49142: PUSH
49143: EMPTY
49144: LIST
49145: LIST
49146: PPUSH
49147: CALL_OW 72
49151: ST_TO_ADDR
// if not fac then
49152: LD_VAR 0 5
49156: NOT
49157: IFFALSE 49161
// continue ;
49159: GO 49103
// for j in fac do
49161: LD_ADDR_VAR 0 3
49165: PUSH
49166: LD_VAR 0 5
49170: PUSH
49171: FOR_IN
49172: IFFALSE 49527
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
49174: LD_VAR 0 3
49178: PPUSH
49179: CALL_OW 461
49183: PUSH
49184: LD_INT 2
49186: NONEQUAL
49187: PUSH
49188: LD_VAR 0 3
49192: PPUSH
49193: LD_INT 15
49195: PPUSH
49196: CALL 73802 0 2
49200: PUSH
49201: LD_INT 4
49203: ARRAY
49204: OR
49205: IFFALSE 49209
// continue ;
49207: GO 49171
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
49209: LD_VAR 0 3
49213: PPUSH
49214: LD_EXP 120
49218: PUSH
49219: LD_VAR 0 2
49223: ARRAY
49224: PUSH
49225: LD_INT 1
49227: ARRAY
49228: PUSH
49229: LD_INT 1
49231: ARRAY
49232: PPUSH
49233: LD_EXP 120
49237: PUSH
49238: LD_VAR 0 2
49242: ARRAY
49243: PUSH
49244: LD_INT 1
49246: ARRAY
49247: PUSH
49248: LD_INT 2
49250: ARRAY
49251: PPUSH
49252: LD_EXP 120
49256: PUSH
49257: LD_VAR 0 2
49261: ARRAY
49262: PUSH
49263: LD_INT 1
49265: ARRAY
49266: PUSH
49267: LD_INT 3
49269: ARRAY
49270: PPUSH
49271: LD_EXP 120
49275: PUSH
49276: LD_VAR 0 2
49280: ARRAY
49281: PUSH
49282: LD_INT 1
49284: ARRAY
49285: PUSH
49286: LD_INT 4
49288: ARRAY
49289: PPUSH
49290: CALL_OW 448
49294: PUSH
49295: LD_VAR 0 3
49299: PPUSH
49300: LD_EXP 120
49304: PUSH
49305: LD_VAR 0 2
49309: ARRAY
49310: PUSH
49311: LD_INT 1
49313: ARRAY
49314: PUSH
49315: LD_INT 1
49317: ARRAY
49318: PUSH
49319: LD_EXP 120
49323: PUSH
49324: LD_VAR 0 2
49328: ARRAY
49329: PUSH
49330: LD_INT 1
49332: ARRAY
49333: PUSH
49334: LD_INT 2
49336: ARRAY
49337: PUSH
49338: LD_EXP 120
49342: PUSH
49343: LD_VAR 0 2
49347: ARRAY
49348: PUSH
49349: LD_INT 1
49351: ARRAY
49352: PUSH
49353: LD_INT 3
49355: ARRAY
49356: PUSH
49357: LD_EXP 120
49361: PUSH
49362: LD_VAR 0 2
49366: ARRAY
49367: PUSH
49368: LD_INT 1
49370: ARRAY
49371: PUSH
49372: LD_INT 4
49374: ARRAY
49375: PUSH
49376: EMPTY
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: PPUSH
49382: CALL 77473 0 2
49386: AND
49387: IFFALSE 49525
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
49389: LD_VAR 0 3
49393: PPUSH
49394: LD_EXP 120
49398: PUSH
49399: LD_VAR 0 2
49403: ARRAY
49404: PUSH
49405: LD_INT 1
49407: ARRAY
49408: PUSH
49409: LD_INT 1
49411: ARRAY
49412: PPUSH
49413: LD_EXP 120
49417: PUSH
49418: LD_VAR 0 2
49422: ARRAY
49423: PUSH
49424: LD_INT 1
49426: ARRAY
49427: PUSH
49428: LD_INT 2
49430: ARRAY
49431: PPUSH
49432: LD_EXP 120
49436: PUSH
49437: LD_VAR 0 2
49441: ARRAY
49442: PUSH
49443: LD_INT 1
49445: ARRAY
49446: PUSH
49447: LD_INT 3
49449: ARRAY
49450: PPUSH
49451: LD_EXP 120
49455: PUSH
49456: LD_VAR 0 2
49460: ARRAY
49461: PUSH
49462: LD_INT 1
49464: ARRAY
49465: PUSH
49466: LD_INT 4
49468: ARRAY
49469: PPUSH
49470: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
49474: LD_ADDR_VAR 0 4
49478: PUSH
49479: LD_EXP 120
49483: PUSH
49484: LD_VAR 0 2
49488: ARRAY
49489: PPUSH
49490: LD_INT 1
49492: PPUSH
49493: CALL_OW 3
49497: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
49498: LD_ADDR_EXP 120
49502: PUSH
49503: LD_EXP 120
49507: PPUSH
49508: LD_VAR 0 2
49512: PPUSH
49513: LD_VAR 0 4
49517: PPUSH
49518: CALL_OW 1
49522: ST_TO_ADDR
// break ;
49523: GO 49527
// end ; end ;
49525: GO 49171
49527: POP
49528: POP
// end ;
49529: GO 49103
49531: POP
49532: POP
// end ;
49533: LD_VAR 0 1
49537: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
49538: LD_INT 0
49540: PPUSH
49541: PPUSH
49542: PPUSH
// if not mc_bases then
49543: LD_EXP 99
49547: NOT
49548: IFFALSE 49552
// exit ;
49550: GO 49641
// for i = 1 to mc_bases do
49552: LD_ADDR_VAR 0 2
49556: PUSH
49557: DOUBLE
49558: LD_INT 1
49560: DEC
49561: ST_TO_ADDR
49562: LD_EXP 99
49566: PUSH
49567: FOR_TO
49568: IFFALSE 49639
// begin if mc_attack [ i ] then
49570: LD_EXP 119
49574: PUSH
49575: LD_VAR 0 2
49579: ARRAY
49580: IFFALSE 49637
// begin tmp := mc_attack [ i ] [ 1 ] ;
49582: LD_ADDR_VAR 0 3
49586: PUSH
49587: LD_EXP 119
49591: PUSH
49592: LD_VAR 0 2
49596: ARRAY
49597: PUSH
49598: LD_INT 1
49600: ARRAY
49601: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
49602: LD_ADDR_EXP 119
49606: PUSH
49607: LD_EXP 119
49611: PPUSH
49612: LD_VAR 0 2
49616: PPUSH
49617: EMPTY
49618: PPUSH
49619: CALL_OW 1
49623: ST_TO_ADDR
// Attack ( tmp ) ;
49624: LD_VAR 0 3
49628: PPUSH
49629: CALL 99686 0 1
// exit ;
49633: POP
49634: POP
49635: GO 49641
// end ; end ;
49637: GO 49567
49639: POP
49640: POP
// end ;
49641: LD_VAR 0 1
49645: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
49646: LD_INT 0
49648: PPUSH
49649: PPUSH
49650: PPUSH
49651: PPUSH
49652: PPUSH
49653: PPUSH
49654: PPUSH
// if not mc_bases then
49655: LD_EXP 99
49659: NOT
49660: IFFALSE 49664
// exit ;
49662: GO 50246
// for i = 1 to mc_bases do
49664: LD_ADDR_VAR 0 2
49668: PUSH
49669: DOUBLE
49670: LD_INT 1
49672: DEC
49673: ST_TO_ADDR
49674: LD_EXP 99
49678: PUSH
49679: FOR_TO
49680: IFFALSE 50244
// begin if not mc_bases [ i ] then
49682: LD_EXP 99
49686: PUSH
49687: LD_VAR 0 2
49691: ARRAY
49692: NOT
49693: IFFALSE 49697
// continue ;
49695: GO 49679
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
49697: LD_ADDR_VAR 0 7
49701: PUSH
49702: LD_EXP 99
49706: PUSH
49707: LD_VAR 0 2
49711: ARRAY
49712: PUSH
49713: LD_INT 1
49715: ARRAY
49716: PPUSH
49717: CALL 68045 0 1
49721: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
49722: LD_ADDR_EXP 122
49726: PUSH
49727: LD_EXP 122
49731: PPUSH
49732: LD_VAR 0 2
49736: PPUSH
49737: LD_EXP 99
49741: PUSH
49742: LD_VAR 0 2
49746: ARRAY
49747: PUSH
49748: LD_INT 1
49750: ARRAY
49751: PPUSH
49752: CALL_OW 255
49756: PPUSH
49757: LD_EXP 124
49761: PUSH
49762: LD_VAR 0 2
49766: ARRAY
49767: PPUSH
49768: CALL 65688 0 2
49772: PPUSH
49773: CALL_OW 1
49777: ST_TO_ADDR
// if not mc_scan [ i ] then
49778: LD_EXP 122
49782: PUSH
49783: LD_VAR 0 2
49787: ARRAY
49788: NOT
49789: IFFALSE 49944
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
49791: LD_ADDR_VAR 0 4
49795: PUSH
49796: LD_EXP 99
49800: PUSH
49801: LD_VAR 0 2
49805: ARRAY
49806: PPUSH
49807: LD_INT 2
49809: PUSH
49810: LD_INT 25
49812: PUSH
49813: LD_INT 5
49815: PUSH
49816: EMPTY
49817: LIST
49818: LIST
49819: PUSH
49820: LD_INT 25
49822: PUSH
49823: LD_INT 8
49825: PUSH
49826: EMPTY
49827: LIST
49828: LIST
49829: PUSH
49830: LD_INT 25
49832: PUSH
49833: LD_INT 9
49835: PUSH
49836: EMPTY
49837: LIST
49838: LIST
49839: PUSH
49840: EMPTY
49841: LIST
49842: LIST
49843: LIST
49844: LIST
49845: PPUSH
49846: CALL_OW 72
49850: ST_TO_ADDR
// if not tmp then
49851: LD_VAR 0 4
49855: NOT
49856: IFFALSE 49860
// continue ;
49858: GO 49679
// for j in tmp do
49860: LD_ADDR_VAR 0 3
49864: PUSH
49865: LD_VAR 0 4
49869: PUSH
49870: FOR_IN
49871: IFFALSE 49942
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
49873: LD_VAR 0 3
49877: PPUSH
49878: CALL_OW 310
49882: PPUSH
49883: CALL_OW 266
49887: PUSH
49888: LD_INT 5
49890: EQUAL
49891: PUSH
49892: LD_VAR 0 3
49896: PPUSH
49897: CALL_OW 257
49901: PUSH
49902: LD_INT 1
49904: EQUAL
49905: AND
49906: PUSH
49907: LD_VAR 0 3
49911: PPUSH
49912: CALL_OW 459
49916: NOT
49917: AND
49918: PUSH
49919: LD_VAR 0 7
49923: AND
49924: IFFALSE 49940
// ComChangeProfession ( j , class ) ;
49926: LD_VAR 0 3
49930: PPUSH
49931: LD_VAR 0 7
49935: PPUSH
49936: CALL_OW 123
49940: GO 49870
49942: POP
49943: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
49944: LD_EXP 122
49948: PUSH
49949: LD_VAR 0 2
49953: ARRAY
49954: PUSH
49955: LD_EXP 121
49959: PUSH
49960: LD_VAR 0 2
49964: ARRAY
49965: NOT
49966: AND
49967: PUSH
49968: LD_EXP 99
49972: PUSH
49973: LD_VAR 0 2
49977: ARRAY
49978: PPUSH
49979: LD_INT 30
49981: PUSH
49982: LD_INT 32
49984: PUSH
49985: EMPTY
49986: LIST
49987: LIST
49988: PPUSH
49989: CALL_OW 72
49993: NOT
49994: AND
49995: PUSH
49996: LD_EXP 99
50000: PUSH
50001: LD_VAR 0 2
50005: ARRAY
50006: PPUSH
50007: LD_INT 2
50009: PUSH
50010: LD_INT 30
50012: PUSH
50013: LD_INT 4
50015: PUSH
50016: EMPTY
50017: LIST
50018: LIST
50019: PUSH
50020: LD_INT 30
50022: PUSH
50023: LD_INT 5
50025: PUSH
50026: EMPTY
50027: LIST
50028: LIST
50029: PUSH
50030: EMPTY
50031: LIST
50032: LIST
50033: LIST
50034: PPUSH
50035: CALL_OW 72
50039: NOT
50040: AND
50041: IFFALSE 50173
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
50043: LD_ADDR_VAR 0 4
50047: PUSH
50048: LD_EXP 99
50052: PUSH
50053: LD_VAR 0 2
50057: ARRAY
50058: PPUSH
50059: LD_INT 2
50061: PUSH
50062: LD_INT 25
50064: PUSH
50065: LD_INT 1
50067: PUSH
50068: EMPTY
50069: LIST
50070: LIST
50071: PUSH
50072: LD_INT 25
50074: PUSH
50075: LD_INT 5
50077: PUSH
50078: EMPTY
50079: LIST
50080: LIST
50081: PUSH
50082: LD_INT 25
50084: PUSH
50085: LD_INT 8
50087: PUSH
50088: EMPTY
50089: LIST
50090: LIST
50091: PUSH
50092: LD_INT 25
50094: PUSH
50095: LD_INT 9
50097: PUSH
50098: EMPTY
50099: LIST
50100: LIST
50101: PUSH
50102: EMPTY
50103: LIST
50104: LIST
50105: LIST
50106: LIST
50107: LIST
50108: PPUSH
50109: CALL_OW 72
50113: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
50114: LD_ADDR_VAR 0 4
50118: PUSH
50119: LD_VAR 0 4
50123: PUSH
50124: LD_VAR 0 4
50128: PPUSH
50129: LD_INT 18
50131: PPUSH
50132: CALL 104469 0 2
50136: DIFF
50137: ST_TO_ADDR
// if tmp then
50138: LD_VAR 0 4
50142: IFFALSE 50173
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
50144: LD_VAR 0 2
50148: PPUSH
50149: LD_VAR 0 4
50153: PPUSH
50154: LD_EXP 124
50158: PUSH
50159: LD_VAR 0 2
50163: ARRAY
50164: PPUSH
50165: CALL 65723 0 3
// exit ;
50169: POP
50170: POP
50171: GO 50246
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
50173: LD_EXP 122
50177: PUSH
50178: LD_VAR 0 2
50182: ARRAY
50183: PUSH
50184: LD_EXP 121
50188: PUSH
50189: LD_VAR 0 2
50193: ARRAY
50194: AND
50195: IFFALSE 50242
// begin tmp := mc_defender [ i ] ;
50197: LD_ADDR_VAR 0 4
50201: PUSH
50202: LD_EXP 121
50206: PUSH
50207: LD_VAR 0 2
50211: ARRAY
50212: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
50213: LD_VAR 0 2
50217: PPUSH
50218: LD_VAR 0 4
50222: PPUSH
50223: LD_EXP 122
50227: PUSH
50228: LD_VAR 0 2
50232: ARRAY
50233: PPUSH
50234: CALL 66284 0 3
// exit ;
50238: POP
50239: POP
50240: GO 50246
// end ; end ;
50242: GO 49679
50244: POP
50245: POP
// end ;
50246: LD_VAR 0 1
50250: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
50251: LD_INT 0
50253: PPUSH
50254: PPUSH
50255: PPUSH
50256: PPUSH
50257: PPUSH
50258: PPUSH
50259: PPUSH
50260: PPUSH
50261: PPUSH
50262: PPUSH
50263: PPUSH
// if not mc_bases then
50264: LD_EXP 99
50268: NOT
50269: IFFALSE 50273
// exit ;
50271: GO 51360
// for i = 1 to mc_bases do
50273: LD_ADDR_VAR 0 2
50277: PUSH
50278: DOUBLE
50279: LD_INT 1
50281: DEC
50282: ST_TO_ADDR
50283: LD_EXP 99
50287: PUSH
50288: FOR_TO
50289: IFFALSE 51358
// begin tmp := mc_lab [ i ] ;
50291: LD_ADDR_VAR 0 6
50295: PUSH
50296: LD_EXP 132
50300: PUSH
50301: LD_VAR 0 2
50305: ARRAY
50306: ST_TO_ADDR
// if not tmp then
50307: LD_VAR 0 6
50311: NOT
50312: IFFALSE 50316
// continue ;
50314: GO 50288
// idle_lab := 0 ;
50316: LD_ADDR_VAR 0 11
50320: PUSH
50321: LD_INT 0
50323: ST_TO_ADDR
// for j in tmp do
50324: LD_ADDR_VAR 0 3
50328: PUSH
50329: LD_VAR 0 6
50333: PUSH
50334: FOR_IN
50335: IFFALSE 51354
// begin researching := false ;
50337: LD_ADDR_VAR 0 10
50341: PUSH
50342: LD_INT 0
50344: ST_TO_ADDR
// side := GetSide ( j ) ;
50345: LD_ADDR_VAR 0 4
50349: PUSH
50350: LD_VAR 0 3
50354: PPUSH
50355: CALL_OW 255
50359: ST_TO_ADDR
// if not mc_tech [ side ] then
50360: LD_EXP 126
50364: PUSH
50365: LD_VAR 0 4
50369: ARRAY
50370: NOT
50371: IFFALSE 50375
// continue ;
50373: GO 50334
// if BuildingStatus ( j ) = bs_idle then
50375: LD_VAR 0 3
50379: PPUSH
50380: CALL_OW 461
50384: PUSH
50385: LD_INT 2
50387: EQUAL
50388: IFFALSE 50576
// begin if idle_lab and UnitsInside ( j ) < 6 then
50390: LD_VAR 0 11
50394: PUSH
50395: LD_VAR 0 3
50399: PPUSH
50400: CALL_OW 313
50404: PUSH
50405: LD_INT 6
50407: LESS
50408: AND
50409: IFFALSE 50480
// begin tmp2 := UnitsInside ( idle_lab ) ;
50411: LD_ADDR_VAR 0 9
50415: PUSH
50416: LD_VAR 0 11
50420: PPUSH
50421: CALL_OW 313
50425: ST_TO_ADDR
// if tmp2 then
50426: LD_VAR 0 9
50430: IFFALSE 50472
// for x in tmp2 do
50432: LD_ADDR_VAR 0 7
50436: PUSH
50437: LD_VAR 0 9
50441: PUSH
50442: FOR_IN
50443: IFFALSE 50470
// begin ComExitBuilding ( x ) ;
50445: LD_VAR 0 7
50449: PPUSH
50450: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
50454: LD_VAR 0 7
50458: PPUSH
50459: LD_VAR 0 3
50463: PPUSH
50464: CALL_OW 180
// end ;
50468: GO 50442
50470: POP
50471: POP
// idle_lab := 0 ;
50472: LD_ADDR_VAR 0 11
50476: PUSH
50477: LD_INT 0
50479: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
50480: LD_ADDR_VAR 0 5
50484: PUSH
50485: LD_EXP 126
50489: PUSH
50490: LD_VAR 0 4
50494: ARRAY
50495: PUSH
50496: FOR_IN
50497: IFFALSE 50557
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
50499: LD_VAR 0 3
50503: PPUSH
50504: LD_VAR 0 5
50508: PPUSH
50509: CALL_OW 430
50513: PUSH
50514: LD_VAR 0 4
50518: PPUSH
50519: LD_VAR 0 5
50523: PPUSH
50524: CALL 64793 0 2
50528: AND
50529: IFFALSE 50555
// begin researching := true ;
50531: LD_ADDR_VAR 0 10
50535: PUSH
50536: LD_INT 1
50538: ST_TO_ADDR
// ComResearch ( j , t ) ;
50539: LD_VAR 0 3
50543: PPUSH
50544: LD_VAR 0 5
50548: PPUSH
50549: CALL_OW 124
// break ;
50553: GO 50557
// end ;
50555: GO 50496
50557: POP
50558: POP
// if not researching then
50559: LD_VAR 0 10
50563: NOT
50564: IFFALSE 50576
// idle_lab := j ;
50566: LD_ADDR_VAR 0 11
50570: PUSH
50571: LD_VAR 0 3
50575: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
50576: LD_VAR 0 3
50580: PPUSH
50581: CALL_OW 461
50585: PUSH
50586: LD_INT 10
50588: EQUAL
50589: IFFALSE 51177
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
50591: LD_EXP 128
50595: PUSH
50596: LD_VAR 0 2
50600: ARRAY
50601: NOT
50602: PUSH
50603: LD_EXP 129
50607: PUSH
50608: LD_VAR 0 2
50612: ARRAY
50613: NOT
50614: AND
50615: PUSH
50616: LD_EXP 126
50620: PUSH
50621: LD_VAR 0 4
50625: ARRAY
50626: PUSH
50627: LD_INT 1
50629: GREATER
50630: AND
50631: IFFALSE 50762
// begin ComCancel ( j ) ;
50633: LD_VAR 0 3
50637: PPUSH
50638: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
50642: LD_ADDR_EXP 126
50646: PUSH
50647: LD_EXP 126
50651: PPUSH
50652: LD_VAR 0 4
50656: PPUSH
50657: LD_EXP 126
50661: PUSH
50662: LD_VAR 0 4
50666: ARRAY
50667: PPUSH
50668: LD_EXP 126
50672: PUSH
50673: LD_VAR 0 4
50677: ARRAY
50678: PUSH
50679: LD_INT 1
50681: MINUS
50682: PPUSH
50683: LD_EXP 126
50687: PUSH
50688: LD_VAR 0 4
50692: ARRAY
50693: PPUSH
50694: LD_INT 0
50696: PPUSH
50697: CALL 70627 0 4
50701: PPUSH
50702: CALL_OW 1
50706: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
50707: LD_ADDR_EXP 126
50711: PUSH
50712: LD_EXP 126
50716: PPUSH
50717: LD_VAR 0 4
50721: PPUSH
50722: LD_EXP 126
50726: PUSH
50727: LD_VAR 0 4
50731: ARRAY
50732: PPUSH
50733: LD_EXP 126
50737: PUSH
50738: LD_VAR 0 4
50742: ARRAY
50743: PPUSH
50744: LD_INT 1
50746: PPUSH
50747: LD_INT 0
50749: PPUSH
50750: CALL 70627 0 4
50754: PPUSH
50755: CALL_OW 1
50759: ST_TO_ADDR
// continue ;
50760: GO 50334
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
50762: LD_EXP 128
50766: PUSH
50767: LD_VAR 0 2
50771: ARRAY
50772: PUSH
50773: LD_EXP 129
50777: PUSH
50778: LD_VAR 0 2
50782: ARRAY
50783: NOT
50784: AND
50785: IFFALSE 50912
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
50787: LD_ADDR_EXP 129
50791: PUSH
50792: LD_EXP 129
50796: PPUSH
50797: LD_VAR 0 2
50801: PUSH
50802: LD_EXP 129
50806: PUSH
50807: LD_VAR 0 2
50811: ARRAY
50812: PUSH
50813: LD_INT 1
50815: PLUS
50816: PUSH
50817: EMPTY
50818: LIST
50819: LIST
50820: PPUSH
50821: LD_EXP 128
50825: PUSH
50826: LD_VAR 0 2
50830: ARRAY
50831: PUSH
50832: LD_INT 1
50834: ARRAY
50835: PPUSH
50836: CALL 71209 0 3
50840: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
50841: LD_EXP 128
50845: PUSH
50846: LD_VAR 0 2
50850: ARRAY
50851: PUSH
50852: LD_INT 1
50854: ARRAY
50855: PPUSH
50856: LD_INT 112
50858: PPUSH
50859: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
50863: LD_ADDR_VAR 0 9
50867: PUSH
50868: LD_EXP 128
50872: PUSH
50873: LD_VAR 0 2
50877: ARRAY
50878: PPUSH
50879: LD_INT 1
50881: PPUSH
50882: CALL_OW 3
50886: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
50887: LD_ADDR_EXP 128
50891: PUSH
50892: LD_EXP 128
50896: PPUSH
50897: LD_VAR 0 2
50901: PPUSH
50902: LD_VAR 0 9
50906: PPUSH
50907: CALL_OW 1
50911: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
50912: LD_EXP 128
50916: PUSH
50917: LD_VAR 0 2
50921: ARRAY
50922: PUSH
50923: LD_EXP 129
50927: PUSH
50928: LD_VAR 0 2
50932: ARRAY
50933: AND
50934: PUSH
50935: LD_EXP 129
50939: PUSH
50940: LD_VAR 0 2
50944: ARRAY
50945: PUSH
50946: LD_INT 1
50948: ARRAY
50949: PPUSH
50950: CALL_OW 310
50954: NOT
50955: AND
50956: PUSH
50957: LD_VAR 0 3
50961: PPUSH
50962: CALL_OW 313
50966: PUSH
50967: LD_INT 6
50969: EQUAL
50970: AND
50971: IFFALSE 51027
// begin tmp2 := UnitsInside ( j ) ;
50973: LD_ADDR_VAR 0 9
50977: PUSH
50978: LD_VAR 0 3
50982: PPUSH
50983: CALL_OW 313
50987: ST_TO_ADDR
// if tmp2 = 6 then
50988: LD_VAR 0 9
50992: PUSH
50993: LD_INT 6
50995: EQUAL
50996: IFFALSE 51027
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
50998: LD_VAR 0 9
51002: PUSH
51003: LD_INT 1
51005: ARRAY
51006: PPUSH
51007: LD_INT 112
51009: PPUSH
51010: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
51014: LD_VAR 0 9
51018: PUSH
51019: LD_INT 1
51021: ARRAY
51022: PPUSH
51023: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
51027: LD_EXP 129
51031: PUSH
51032: LD_VAR 0 2
51036: ARRAY
51037: PUSH
51038: LD_EXP 129
51042: PUSH
51043: LD_VAR 0 2
51047: ARRAY
51048: PUSH
51049: LD_INT 1
51051: ARRAY
51052: PPUSH
51053: CALL_OW 314
51057: NOT
51058: AND
51059: PUSH
51060: LD_EXP 129
51064: PUSH
51065: LD_VAR 0 2
51069: ARRAY
51070: PUSH
51071: LD_INT 1
51073: ARRAY
51074: PPUSH
51075: CALL_OW 310
51079: NOT
51080: AND
51081: IFFALSE 51107
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
51083: LD_EXP 129
51087: PUSH
51088: LD_VAR 0 2
51092: ARRAY
51093: PUSH
51094: LD_INT 1
51096: ARRAY
51097: PPUSH
51098: LD_VAR 0 3
51102: PPUSH
51103: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
51107: LD_EXP 129
51111: PUSH
51112: LD_VAR 0 2
51116: ARRAY
51117: PUSH
51118: LD_INT 1
51120: ARRAY
51121: PPUSH
51122: CALL_OW 310
51126: PUSH
51127: LD_EXP 129
51131: PUSH
51132: LD_VAR 0 2
51136: ARRAY
51137: PUSH
51138: LD_INT 1
51140: ARRAY
51141: PPUSH
51142: CALL_OW 310
51146: PPUSH
51147: CALL_OW 461
51151: PUSH
51152: LD_INT 3
51154: NONEQUAL
51155: AND
51156: IFFALSE 51177
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
51158: LD_EXP 129
51162: PUSH
51163: LD_VAR 0 2
51167: ARRAY
51168: PUSH
51169: LD_INT 1
51171: ARRAY
51172: PPUSH
51173: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
51177: LD_VAR 0 3
51181: PPUSH
51182: CALL_OW 461
51186: PUSH
51187: LD_INT 6
51189: EQUAL
51190: PUSH
51191: LD_VAR 0 6
51195: PUSH
51196: LD_INT 1
51198: GREATER
51199: AND
51200: IFFALSE 51352
// begin sci := [ ] ;
51202: LD_ADDR_VAR 0 8
51206: PUSH
51207: EMPTY
51208: ST_TO_ADDR
// for x in ( tmp diff j ) do
51209: LD_ADDR_VAR 0 7
51213: PUSH
51214: LD_VAR 0 6
51218: PUSH
51219: LD_VAR 0 3
51223: DIFF
51224: PUSH
51225: FOR_IN
51226: IFFALSE 51278
// begin if sci = 6 then
51228: LD_VAR 0 8
51232: PUSH
51233: LD_INT 6
51235: EQUAL
51236: IFFALSE 51240
// break ;
51238: GO 51278
// if BuildingStatus ( x ) = bs_idle then
51240: LD_VAR 0 7
51244: PPUSH
51245: CALL_OW 461
51249: PUSH
51250: LD_INT 2
51252: EQUAL
51253: IFFALSE 51276
// sci := sci ^ UnitsInside ( x ) ;
51255: LD_ADDR_VAR 0 8
51259: PUSH
51260: LD_VAR 0 8
51264: PUSH
51265: LD_VAR 0 7
51269: PPUSH
51270: CALL_OW 313
51274: ADD
51275: ST_TO_ADDR
// end ;
51276: GO 51225
51278: POP
51279: POP
// if not sci then
51280: LD_VAR 0 8
51284: NOT
51285: IFFALSE 51289
// continue ;
51287: GO 50334
// for x in sci do
51289: LD_ADDR_VAR 0 7
51293: PUSH
51294: LD_VAR 0 8
51298: PUSH
51299: FOR_IN
51300: IFFALSE 51350
// if IsInUnit ( x ) and not HasTask ( x ) then
51302: LD_VAR 0 7
51306: PPUSH
51307: CALL_OW 310
51311: PUSH
51312: LD_VAR 0 7
51316: PPUSH
51317: CALL_OW 314
51321: NOT
51322: AND
51323: IFFALSE 51348
// begin ComExitBuilding ( x ) ;
51325: LD_VAR 0 7
51329: PPUSH
51330: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
51334: LD_VAR 0 7
51338: PPUSH
51339: LD_VAR 0 3
51343: PPUSH
51344: CALL_OW 180
// end ;
51348: GO 51299
51350: POP
51351: POP
// end ; end ;
51352: GO 50334
51354: POP
51355: POP
// end ;
51356: GO 50288
51358: POP
51359: POP
// end ;
51360: LD_VAR 0 1
51364: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
51365: LD_INT 0
51367: PPUSH
51368: PPUSH
// if not mc_bases then
51369: LD_EXP 99
51373: NOT
51374: IFFALSE 51378
// exit ;
51376: GO 51459
// for i = 1 to mc_bases do
51378: LD_ADDR_VAR 0 2
51382: PUSH
51383: DOUBLE
51384: LD_INT 1
51386: DEC
51387: ST_TO_ADDR
51388: LD_EXP 99
51392: PUSH
51393: FOR_TO
51394: IFFALSE 51457
// if mc_mines [ i ] and mc_miners [ i ] then
51396: LD_EXP 112
51400: PUSH
51401: LD_VAR 0 2
51405: ARRAY
51406: PUSH
51407: LD_EXP 113
51411: PUSH
51412: LD_VAR 0 2
51416: ARRAY
51417: AND
51418: IFFALSE 51455
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
51420: LD_EXP 113
51424: PUSH
51425: LD_VAR 0 2
51429: ARRAY
51430: PUSH
51431: LD_INT 1
51433: ARRAY
51434: PPUSH
51435: CALL_OW 255
51439: PPUSH
51440: LD_EXP 112
51444: PUSH
51445: LD_VAR 0 2
51449: ARRAY
51450: PPUSH
51451: CALL 68198 0 2
51455: GO 51393
51457: POP
51458: POP
// end ;
51459: LD_VAR 0 1
51463: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
51464: LD_INT 0
51466: PPUSH
51467: PPUSH
51468: PPUSH
51469: PPUSH
51470: PPUSH
51471: PPUSH
51472: PPUSH
51473: PPUSH
// if not mc_bases or not mc_parking then
51474: LD_EXP 99
51478: NOT
51479: PUSH
51480: LD_EXP 123
51484: NOT
51485: OR
51486: IFFALSE 51490
// exit ;
51488: GO 52189
// for i = 1 to mc_bases do
51490: LD_ADDR_VAR 0 2
51494: PUSH
51495: DOUBLE
51496: LD_INT 1
51498: DEC
51499: ST_TO_ADDR
51500: LD_EXP 99
51504: PUSH
51505: FOR_TO
51506: IFFALSE 52187
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
51508: LD_EXP 99
51512: PUSH
51513: LD_VAR 0 2
51517: ARRAY
51518: NOT
51519: PUSH
51520: LD_EXP 123
51524: PUSH
51525: LD_VAR 0 2
51529: ARRAY
51530: NOT
51531: OR
51532: IFFALSE 51536
// continue ;
51534: GO 51505
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
51536: LD_ADDR_VAR 0 5
51540: PUSH
51541: LD_EXP 99
51545: PUSH
51546: LD_VAR 0 2
51550: ARRAY
51551: PUSH
51552: LD_INT 1
51554: ARRAY
51555: PPUSH
51556: CALL_OW 255
51560: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51561: LD_ADDR_VAR 0 6
51565: PUSH
51566: LD_EXP 99
51570: PUSH
51571: LD_VAR 0 2
51575: ARRAY
51576: PPUSH
51577: LD_INT 30
51579: PUSH
51580: LD_INT 3
51582: PUSH
51583: EMPTY
51584: LIST
51585: LIST
51586: PPUSH
51587: CALL_OW 72
51591: ST_TO_ADDR
// if not fac then
51592: LD_VAR 0 6
51596: NOT
51597: IFFALSE 51648
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
51599: LD_ADDR_VAR 0 6
51603: PUSH
51604: LD_EXP 99
51608: PUSH
51609: LD_VAR 0 2
51613: ARRAY
51614: PPUSH
51615: LD_INT 2
51617: PUSH
51618: LD_INT 30
51620: PUSH
51621: LD_INT 0
51623: PUSH
51624: EMPTY
51625: LIST
51626: LIST
51627: PUSH
51628: LD_INT 30
51630: PUSH
51631: LD_INT 1
51633: PUSH
51634: EMPTY
51635: LIST
51636: LIST
51637: PUSH
51638: EMPTY
51639: LIST
51640: LIST
51641: LIST
51642: PPUSH
51643: CALL_OW 72
51647: ST_TO_ADDR
// if not fac then
51648: LD_VAR 0 6
51652: NOT
51653: IFFALSE 51657
// continue ;
51655: GO 51505
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51657: LD_ADDR_VAR 0 7
51661: PUSH
51662: LD_EXP 123
51666: PUSH
51667: LD_VAR 0 2
51671: ARRAY
51672: PPUSH
51673: LD_INT 22
51675: PUSH
51676: LD_VAR 0 5
51680: PUSH
51681: EMPTY
51682: LIST
51683: LIST
51684: PUSH
51685: LD_INT 21
51687: PUSH
51688: LD_INT 2
51690: PUSH
51691: EMPTY
51692: LIST
51693: LIST
51694: PUSH
51695: LD_INT 3
51697: PUSH
51698: LD_INT 24
51700: PUSH
51701: LD_INT 1000
51703: PUSH
51704: EMPTY
51705: LIST
51706: LIST
51707: PUSH
51708: EMPTY
51709: LIST
51710: LIST
51711: PUSH
51712: EMPTY
51713: LIST
51714: LIST
51715: LIST
51716: PPUSH
51717: CALL_OW 70
51721: ST_TO_ADDR
// for j in fac do
51722: LD_ADDR_VAR 0 3
51726: PUSH
51727: LD_VAR 0 6
51731: PUSH
51732: FOR_IN
51733: IFFALSE 51814
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
51735: LD_ADDR_VAR 0 7
51739: PUSH
51740: LD_VAR 0 7
51744: PUSH
51745: LD_INT 22
51747: PUSH
51748: LD_VAR 0 5
51752: PUSH
51753: EMPTY
51754: LIST
51755: LIST
51756: PUSH
51757: LD_INT 91
51759: PUSH
51760: LD_VAR 0 3
51764: PUSH
51765: LD_INT 15
51767: PUSH
51768: EMPTY
51769: LIST
51770: LIST
51771: LIST
51772: PUSH
51773: LD_INT 21
51775: PUSH
51776: LD_INT 2
51778: PUSH
51779: EMPTY
51780: LIST
51781: LIST
51782: PUSH
51783: LD_INT 3
51785: PUSH
51786: LD_INT 24
51788: PUSH
51789: LD_INT 1000
51791: PUSH
51792: EMPTY
51793: LIST
51794: LIST
51795: PUSH
51796: EMPTY
51797: LIST
51798: LIST
51799: PUSH
51800: EMPTY
51801: LIST
51802: LIST
51803: LIST
51804: LIST
51805: PPUSH
51806: CALL_OW 69
51810: UNION
51811: ST_TO_ADDR
51812: GO 51732
51814: POP
51815: POP
// if not vehs then
51816: LD_VAR 0 7
51820: NOT
51821: IFFALSE 51847
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
51823: LD_ADDR_EXP 111
51827: PUSH
51828: LD_EXP 111
51832: PPUSH
51833: LD_VAR 0 2
51837: PPUSH
51838: EMPTY
51839: PPUSH
51840: CALL_OW 1
51844: ST_TO_ADDR
// continue ;
51845: GO 51505
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
51847: LD_ADDR_VAR 0 8
51851: PUSH
51852: LD_EXP 99
51856: PUSH
51857: LD_VAR 0 2
51861: ARRAY
51862: PPUSH
51863: LD_INT 30
51865: PUSH
51866: LD_INT 3
51868: PUSH
51869: EMPTY
51870: LIST
51871: LIST
51872: PPUSH
51873: CALL_OW 72
51877: ST_TO_ADDR
// if tmp then
51878: LD_VAR 0 8
51882: IFFALSE 51985
// begin for j in tmp do
51884: LD_ADDR_VAR 0 3
51888: PUSH
51889: LD_VAR 0 8
51893: PUSH
51894: FOR_IN
51895: IFFALSE 51983
// for k in UnitsInside ( j ) do
51897: LD_ADDR_VAR 0 4
51901: PUSH
51902: LD_VAR 0 3
51906: PPUSH
51907: CALL_OW 313
51911: PUSH
51912: FOR_IN
51913: IFFALSE 51979
// if k then
51915: LD_VAR 0 4
51919: IFFALSE 51977
// if not k in mc_repair_vehicle [ i ] then
51921: LD_VAR 0 4
51925: PUSH
51926: LD_EXP 111
51930: PUSH
51931: LD_VAR 0 2
51935: ARRAY
51936: IN
51937: NOT
51938: IFFALSE 51977
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
51940: LD_ADDR_EXP 111
51944: PUSH
51945: LD_EXP 111
51949: PPUSH
51950: LD_VAR 0 2
51954: PPUSH
51955: LD_EXP 111
51959: PUSH
51960: LD_VAR 0 2
51964: ARRAY
51965: PUSH
51966: LD_VAR 0 4
51970: UNION
51971: PPUSH
51972: CALL_OW 1
51976: ST_TO_ADDR
51977: GO 51912
51979: POP
51980: POP
51981: GO 51894
51983: POP
51984: POP
// end ; if not mc_repair_vehicle [ i ] then
51985: LD_EXP 111
51989: PUSH
51990: LD_VAR 0 2
51994: ARRAY
51995: NOT
51996: IFFALSE 52000
// continue ;
51998: GO 51505
// for j in mc_repair_vehicle [ i ] do
52000: LD_ADDR_VAR 0 3
52004: PUSH
52005: LD_EXP 111
52009: PUSH
52010: LD_VAR 0 2
52014: ARRAY
52015: PUSH
52016: FOR_IN
52017: IFFALSE 52183
// begin if GetClass ( j ) <> 3 then
52019: LD_VAR 0 3
52023: PPUSH
52024: CALL_OW 257
52028: PUSH
52029: LD_INT 3
52031: NONEQUAL
52032: IFFALSE 52073
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
52034: LD_ADDR_EXP 111
52038: PUSH
52039: LD_EXP 111
52043: PPUSH
52044: LD_VAR 0 2
52048: PPUSH
52049: LD_EXP 111
52053: PUSH
52054: LD_VAR 0 2
52058: ARRAY
52059: PUSH
52060: LD_VAR 0 3
52064: DIFF
52065: PPUSH
52066: CALL_OW 1
52070: ST_TO_ADDR
// continue ;
52071: GO 52016
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
52073: LD_VAR 0 3
52077: PPUSH
52078: CALL_OW 311
52082: NOT
52083: PUSH
52084: LD_VAR 0 3
52088: PUSH
52089: LD_EXP 102
52093: PUSH
52094: LD_VAR 0 2
52098: ARRAY
52099: PUSH
52100: LD_INT 1
52102: ARRAY
52103: IN
52104: NOT
52105: AND
52106: PUSH
52107: LD_VAR 0 3
52111: PUSH
52112: LD_EXP 102
52116: PUSH
52117: LD_VAR 0 2
52121: ARRAY
52122: PUSH
52123: LD_INT 2
52125: ARRAY
52126: IN
52127: NOT
52128: AND
52129: IFFALSE 52181
// begin if IsInUnit ( j ) then
52131: LD_VAR 0 3
52135: PPUSH
52136: CALL_OW 310
52140: IFFALSE 52151
// ComExitBuilding ( j ) ;
52142: LD_VAR 0 3
52146: PPUSH
52147: CALL_OW 122
// if not HasTask ( j ) then
52151: LD_VAR 0 3
52155: PPUSH
52156: CALL_OW 314
52160: NOT
52161: IFFALSE 52181
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
52163: LD_VAR 0 3
52167: PPUSH
52168: LD_VAR 0 7
52172: PUSH
52173: LD_INT 1
52175: ARRAY
52176: PPUSH
52177: CALL_OW 189
// end ; end ;
52181: GO 52016
52183: POP
52184: POP
// end ;
52185: GO 51505
52187: POP
52188: POP
// end ;
52189: LD_VAR 0 1
52193: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
52194: LD_INT 0
52196: PPUSH
52197: PPUSH
52198: PPUSH
52199: PPUSH
52200: PPUSH
52201: PPUSH
52202: PPUSH
52203: PPUSH
52204: PPUSH
52205: PPUSH
52206: PPUSH
// if not mc_bases then
52207: LD_EXP 99
52211: NOT
52212: IFFALSE 52216
// exit ;
52214: GO 53018
// for i = 1 to mc_bases do
52216: LD_ADDR_VAR 0 2
52220: PUSH
52221: DOUBLE
52222: LD_INT 1
52224: DEC
52225: ST_TO_ADDR
52226: LD_EXP 99
52230: PUSH
52231: FOR_TO
52232: IFFALSE 53016
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
52234: LD_EXP 127
52238: PUSH
52239: LD_VAR 0 2
52243: ARRAY
52244: NOT
52245: PUSH
52246: LD_EXP 102
52250: PUSH
52251: LD_VAR 0 2
52255: ARRAY
52256: PUSH
52257: LD_INT 1
52259: ARRAY
52260: OR
52261: PUSH
52262: LD_EXP 102
52266: PUSH
52267: LD_VAR 0 2
52271: ARRAY
52272: PUSH
52273: LD_INT 2
52275: ARRAY
52276: OR
52277: PUSH
52278: LD_EXP 125
52282: PUSH
52283: LD_VAR 0 2
52287: ARRAY
52288: PPUSH
52289: LD_INT 1
52291: PPUSH
52292: CALL_OW 325
52296: NOT
52297: OR
52298: PUSH
52299: LD_EXP 122
52303: PUSH
52304: LD_VAR 0 2
52308: ARRAY
52309: OR
52310: IFFALSE 52314
// continue ;
52312: GO 52231
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
52314: LD_ADDR_VAR 0 8
52318: PUSH
52319: LD_EXP 99
52323: PUSH
52324: LD_VAR 0 2
52328: ARRAY
52329: PPUSH
52330: LD_INT 25
52332: PUSH
52333: LD_INT 4
52335: PUSH
52336: EMPTY
52337: LIST
52338: LIST
52339: PUSH
52340: LD_INT 50
52342: PUSH
52343: EMPTY
52344: LIST
52345: PUSH
52346: LD_INT 3
52348: PUSH
52349: LD_INT 60
52351: PUSH
52352: EMPTY
52353: LIST
52354: PUSH
52355: EMPTY
52356: LIST
52357: LIST
52358: PUSH
52359: EMPTY
52360: LIST
52361: LIST
52362: LIST
52363: PPUSH
52364: CALL_OW 72
52368: PUSH
52369: LD_EXP 103
52373: PUSH
52374: LD_VAR 0 2
52378: ARRAY
52379: DIFF
52380: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
52381: LD_ADDR_VAR 0 9
52385: PUSH
52386: LD_EXP 99
52390: PUSH
52391: LD_VAR 0 2
52395: ARRAY
52396: PPUSH
52397: LD_INT 2
52399: PUSH
52400: LD_INT 30
52402: PUSH
52403: LD_INT 0
52405: PUSH
52406: EMPTY
52407: LIST
52408: LIST
52409: PUSH
52410: LD_INT 30
52412: PUSH
52413: LD_INT 1
52415: PUSH
52416: EMPTY
52417: LIST
52418: LIST
52419: PUSH
52420: EMPTY
52421: LIST
52422: LIST
52423: LIST
52424: PPUSH
52425: CALL_OW 72
52429: ST_TO_ADDR
// if not tmp or not dep then
52430: LD_VAR 0 8
52434: NOT
52435: PUSH
52436: LD_VAR 0 9
52440: NOT
52441: OR
52442: IFFALSE 52446
// continue ;
52444: GO 52231
// side := GetSide ( tmp [ 1 ] ) ;
52446: LD_ADDR_VAR 0 11
52450: PUSH
52451: LD_VAR 0 8
52455: PUSH
52456: LD_INT 1
52458: ARRAY
52459: PPUSH
52460: CALL_OW 255
52464: ST_TO_ADDR
// dep := dep [ 1 ] ;
52465: LD_ADDR_VAR 0 9
52469: PUSH
52470: LD_VAR 0 9
52474: PUSH
52475: LD_INT 1
52477: ARRAY
52478: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
52479: LD_ADDR_VAR 0 7
52483: PUSH
52484: LD_EXP 127
52488: PUSH
52489: LD_VAR 0 2
52493: ARRAY
52494: PPUSH
52495: LD_INT 22
52497: PUSH
52498: LD_INT 0
52500: PUSH
52501: EMPTY
52502: LIST
52503: LIST
52504: PUSH
52505: LD_INT 25
52507: PUSH
52508: LD_INT 12
52510: PUSH
52511: EMPTY
52512: LIST
52513: LIST
52514: PUSH
52515: EMPTY
52516: LIST
52517: LIST
52518: PPUSH
52519: CALL_OW 70
52523: PUSH
52524: LD_INT 22
52526: PUSH
52527: LD_INT 0
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: PUSH
52534: LD_INT 25
52536: PUSH
52537: LD_INT 12
52539: PUSH
52540: EMPTY
52541: LIST
52542: LIST
52543: PUSH
52544: LD_INT 91
52546: PUSH
52547: LD_VAR 0 9
52551: PUSH
52552: LD_INT 20
52554: PUSH
52555: EMPTY
52556: LIST
52557: LIST
52558: LIST
52559: PUSH
52560: EMPTY
52561: LIST
52562: LIST
52563: LIST
52564: PPUSH
52565: CALL_OW 69
52569: UNION
52570: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
52571: LD_ADDR_VAR 0 10
52575: PUSH
52576: LD_EXP 127
52580: PUSH
52581: LD_VAR 0 2
52585: ARRAY
52586: PPUSH
52587: LD_INT 81
52589: PUSH
52590: LD_VAR 0 11
52594: PUSH
52595: EMPTY
52596: LIST
52597: LIST
52598: PPUSH
52599: CALL_OW 70
52603: ST_TO_ADDR
// if not apes or danger_at_area then
52604: LD_VAR 0 7
52608: NOT
52609: PUSH
52610: LD_VAR 0 10
52614: OR
52615: IFFALSE 52665
// begin if mc_taming [ i ] then
52617: LD_EXP 130
52621: PUSH
52622: LD_VAR 0 2
52626: ARRAY
52627: IFFALSE 52663
// begin MC_Reset ( i , 121 ) ;
52629: LD_VAR 0 2
52633: PPUSH
52634: LD_INT 121
52636: PPUSH
52637: CALL 37996 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
52641: LD_ADDR_EXP 130
52645: PUSH
52646: LD_EXP 130
52650: PPUSH
52651: LD_VAR 0 2
52655: PPUSH
52656: EMPTY
52657: PPUSH
52658: CALL_OW 1
52662: ST_TO_ADDR
// end ; continue ;
52663: GO 52231
// end ; for j in tmp do
52665: LD_ADDR_VAR 0 3
52669: PUSH
52670: LD_VAR 0 8
52674: PUSH
52675: FOR_IN
52676: IFFALSE 53012
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
52678: LD_VAR 0 3
52682: PUSH
52683: LD_EXP 130
52687: PUSH
52688: LD_VAR 0 2
52692: ARRAY
52693: IN
52694: NOT
52695: PUSH
52696: LD_EXP 130
52700: PUSH
52701: LD_VAR 0 2
52705: ARRAY
52706: PUSH
52707: LD_INT 3
52709: LESS
52710: AND
52711: IFFALSE 52769
// begin SetTag ( j , 121 ) ;
52713: LD_VAR 0 3
52717: PPUSH
52718: LD_INT 121
52720: PPUSH
52721: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
52725: LD_ADDR_EXP 130
52729: PUSH
52730: LD_EXP 130
52734: PPUSH
52735: LD_VAR 0 2
52739: PUSH
52740: LD_EXP 130
52744: PUSH
52745: LD_VAR 0 2
52749: ARRAY
52750: PUSH
52751: LD_INT 1
52753: PLUS
52754: PUSH
52755: EMPTY
52756: LIST
52757: LIST
52758: PPUSH
52759: LD_VAR 0 3
52763: PPUSH
52764: CALL 71209 0 3
52768: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
52769: LD_VAR 0 3
52773: PUSH
52774: LD_EXP 130
52778: PUSH
52779: LD_VAR 0 2
52783: ARRAY
52784: IN
52785: IFFALSE 53010
// begin if GetClass ( j ) <> 4 then
52787: LD_VAR 0 3
52791: PPUSH
52792: CALL_OW 257
52796: PUSH
52797: LD_INT 4
52799: NONEQUAL
52800: IFFALSE 52853
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
52802: LD_ADDR_EXP 130
52806: PUSH
52807: LD_EXP 130
52811: PPUSH
52812: LD_VAR 0 2
52816: PPUSH
52817: LD_EXP 130
52821: PUSH
52822: LD_VAR 0 2
52826: ARRAY
52827: PUSH
52828: LD_VAR 0 3
52832: DIFF
52833: PPUSH
52834: CALL_OW 1
52838: ST_TO_ADDR
// SetTag ( j , 0 ) ;
52839: LD_VAR 0 3
52843: PPUSH
52844: LD_INT 0
52846: PPUSH
52847: CALL_OW 109
// continue ;
52851: GO 52675
// end ; if IsInUnit ( j ) then
52853: LD_VAR 0 3
52857: PPUSH
52858: CALL_OW 310
52862: IFFALSE 52873
// ComExitBuilding ( j ) ;
52864: LD_VAR 0 3
52868: PPUSH
52869: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
52873: LD_ADDR_VAR 0 6
52877: PUSH
52878: LD_VAR 0 7
52882: PPUSH
52883: LD_VAR 0 3
52887: PPUSH
52888: CALL_OW 74
52892: ST_TO_ADDR
// if not ape then
52893: LD_VAR 0 6
52897: NOT
52898: IFFALSE 52902
// break ;
52900: GO 53012
// x := GetX ( ape ) ;
52902: LD_ADDR_VAR 0 4
52906: PUSH
52907: LD_VAR 0 6
52911: PPUSH
52912: CALL_OW 250
52916: ST_TO_ADDR
// y := GetY ( ape ) ;
52917: LD_ADDR_VAR 0 5
52921: PUSH
52922: LD_VAR 0 6
52926: PPUSH
52927: CALL_OW 251
52931: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
52932: LD_VAR 0 4
52936: PPUSH
52937: LD_VAR 0 5
52941: PPUSH
52942: CALL_OW 488
52946: NOT
52947: PUSH
52948: LD_VAR 0 11
52952: PPUSH
52953: LD_VAR 0 4
52957: PPUSH
52958: LD_VAR 0 5
52962: PPUSH
52963: LD_INT 20
52965: PPUSH
52966: CALL 72105 0 4
52970: PUSH
52971: LD_INT 4
52973: ARRAY
52974: OR
52975: IFFALSE 52979
// break ;
52977: GO 53012
// if not HasTask ( j ) then
52979: LD_VAR 0 3
52983: PPUSH
52984: CALL_OW 314
52988: NOT
52989: IFFALSE 53010
// ComTameXY ( j , x , y ) ;
52991: LD_VAR 0 3
52995: PPUSH
52996: LD_VAR 0 4
53000: PPUSH
53001: LD_VAR 0 5
53005: PPUSH
53006: CALL_OW 131
// end ; end ;
53010: GO 52675
53012: POP
53013: POP
// end ;
53014: GO 52231
53016: POP
53017: POP
// end ;
53018: LD_VAR 0 1
53022: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
53023: LD_INT 0
53025: PPUSH
53026: PPUSH
53027: PPUSH
53028: PPUSH
53029: PPUSH
53030: PPUSH
53031: PPUSH
53032: PPUSH
// if not mc_bases then
53033: LD_EXP 99
53037: NOT
53038: IFFALSE 53042
// exit ;
53040: GO 53668
// for i = 1 to mc_bases do
53042: LD_ADDR_VAR 0 2
53046: PUSH
53047: DOUBLE
53048: LD_INT 1
53050: DEC
53051: ST_TO_ADDR
53052: LD_EXP 99
53056: PUSH
53057: FOR_TO
53058: IFFALSE 53666
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
53060: LD_EXP 128
53064: PUSH
53065: LD_VAR 0 2
53069: ARRAY
53070: NOT
53071: PUSH
53072: LD_EXP 128
53076: PUSH
53077: LD_VAR 0 2
53081: ARRAY
53082: PPUSH
53083: LD_INT 25
53085: PUSH
53086: LD_INT 12
53088: PUSH
53089: EMPTY
53090: LIST
53091: LIST
53092: PPUSH
53093: CALL_OW 72
53097: NOT
53098: OR
53099: IFFALSE 53103
// continue ;
53101: GO 53057
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
53103: LD_ADDR_VAR 0 5
53107: PUSH
53108: LD_EXP 128
53112: PUSH
53113: LD_VAR 0 2
53117: ARRAY
53118: PUSH
53119: LD_INT 1
53121: ARRAY
53122: PPUSH
53123: CALL_OW 255
53127: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
53128: LD_VAR 0 5
53132: PPUSH
53133: LD_INT 2
53135: PPUSH
53136: CALL_OW 325
53140: IFFALSE 53393
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53142: LD_ADDR_VAR 0 4
53146: PUSH
53147: LD_EXP 128
53151: PUSH
53152: LD_VAR 0 2
53156: ARRAY
53157: PPUSH
53158: LD_INT 25
53160: PUSH
53161: LD_INT 16
53163: PUSH
53164: EMPTY
53165: LIST
53166: LIST
53167: PPUSH
53168: CALL_OW 72
53172: ST_TO_ADDR
// if tmp < 6 then
53173: LD_VAR 0 4
53177: PUSH
53178: LD_INT 6
53180: LESS
53181: IFFALSE 53393
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53183: LD_ADDR_VAR 0 6
53187: PUSH
53188: LD_EXP 99
53192: PUSH
53193: LD_VAR 0 2
53197: ARRAY
53198: PPUSH
53199: LD_INT 2
53201: PUSH
53202: LD_INT 30
53204: PUSH
53205: LD_INT 0
53207: PUSH
53208: EMPTY
53209: LIST
53210: LIST
53211: PUSH
53212: LD_INT 30
53214: PUSH
53215: LD_INT 1
53217: PUSH
53218: EMPTY
53219: LIST
53220: LIST
53221: PUSH
53222: EMPTY
53223: LIST
53224: LIST
53225: LIST
53226: PPUSH
53227: CALL_OW 72
53231: ST_TO_ADDR
// if depot then
53232: LD_VAR 0 6
53236: IFFALSE 53393
// begin selected := 0 ;
53238: LD_ADDR_VAR 0 7
53242: PUSH
53243: LD_INT 0
53245: ST_TO_ADDR
// for j in depot do
53246: LD_ADDR_VAR 0 3
53250: PUSH
53251: LD_VAR 0 6
53255: PUSH
53256: FOR_IN
53257: IFFALSE 53288
// begin if UnitsInside ( j ) < 6 then
53259: LD_VAR 0 3
53263: PPUSH
53264: CALL_OW 313
53268: PUSH
53269: LD_INT 6
53271: LESS
53272: IFFALSE 53286
// begin selected := j ;
53274: LD_ADDR_VAR 0 7
53278: PUSH
53279: LD_VAR 0 3
53283: ST_TO_ADDR
// break ;
53284: GO 53288
// end ; end ;
53286: GO 53256
53288: POP
53289: POP
// if selected then
53290: LD_VAR 0 7
53294: IFFALSE 53393
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53296: LD_ADDR_VAR 0 3
53300: PUSH
53301: LD_EXP 128
53305: PUSH
53306: LD_VAR 0 2
53310: ARRAY
53311: PPUSH
53312: LD_INT 25
53314: PUSH
53315: LD_INT 12
53317: PUSH
53318: EMPTY
53319: LIST
53320: LIST
53321: PPUSH
53322: CALL_OW 72
53326: PUSH
53327: FOR_IN
53328: IFFALSE 53391
// if not HasTask ( j ) then
53330: LD_VAR 0 3
53334: PPUSH
53335: CALL_OW 314
53339: NOT
53340: IFFALSE 53389
// begin if not IsInUnit ( j ) then
53342: LD_VAR 0 3
53346: PPUSH
53347: CALL_OW 310
53351: NOT
53352: IFFALSE 53368
// ComEnterUnit ( j , selected ) ;
53354: LD_VAR 0 3
53358: PPUSH
53359: LD_VAR 0 7
53363: PPUSH
53364: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
53368: LD_VAR 0 3
53372: PPUSH
53373: LD_INT 16
53375: PPUSH
53376: CALL_OW 183
// AddComExitBuilding ( j ) ;
53380: LD_VAR 0 3
53384: PPUSH
53385: CALL_OW 182
// end ;
53389: GO 53327
53391: POP
53392: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
53393: LD_VAR 0 5
53397: PPUSH
53398: LD_INT 11
53400: PPUSH
53401: CALL_OW 325
53405: IFFALSE 53664
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
53407: LD_ADDR_VAR 0 4
53411: PUSH
53412: LD_EXP 128
53416: PUSH
53417: LD_VAR 0 2
53421: ARRAY
53422: PPUSH
53423: LD_INT 25
53425: PUSH
53426: LD_INT 16
53428: PUSH
53429: EMPTY
53430: LIST
53431: LIST
53432: PPUSH
53433: CALL_OW 72
53437: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
53438: LD_VAR 0 4
53442: PUSH
53443: LD_INT 6
53445: GREATEREQUAL
53446: PUSH
53447: LD_VAR 0 5
53451: PPUSH
53452: LD_INT 2
53454: PPUSH
53455: CALL_OW 325
53459: NOT
53460: OR
53461: IFFALSE 53664
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
53463: LD_ADDR_VAR 0 8
53467: PUSH
53468: LD_EXP 99
53472: PUSH
53473: LD_VAR 0 2
53477: ARRAY
53478: PPUSH
53479: LD_INT 2
53481: PUSH
53482: LD_INT 30
53484: PUSH
53485: LD_INT 4
53487: PUSH
53488: EMPTY
53489: LIST
53490: LIST
53491: PUSH
53492: LD_INT 30
53494: PUSH
53495: LD_INT 5
53497: PUSH
53498: EMPTY
53499: LIST
53500: LIST
53501: PUSH
53502: EMPTY
53503: LIST
53504: LIST
53505: LIST
53506: PPUSH
53507: CALL_OW 72
53511: ST_TO_ADDR
// if barracks then
53512: LD_VAR 0 8
53516: IFFALSE 53664
// begin selected := 0 ;
53518: LD_ADDR_VAR 0 7
53522: PUSH
53523: LD_INT 0
53525: ST_TO_ADDR
// for j in barracks do
53526: LD_ADDR_VAR 0 3
53530: PUSH
53531: LD_VAR 0 8
53535: PUSH
53536: FOR_IN
53537: IFFALSE 53568
// begin if UnitsInside ( j ) < 6 then
53539: LD_VAR 0 3
53543: PPUSH
53544: CALL_OW 313
53548: PUSH
53549: LD_INT 6
53551: LESS
53552: IFFALSE 53566
// begin selected := j ;
53554: LD_ADDR_VAR 0 7
53558: PUSH
53559: LD_VAR 0 3
53563: ST_TO_ADDR
// break ;
53564: GO 53568
// end ; end ;
53566: GO 53536
53568: POP
53569: POP
// if selected then
53570: LD_VAR 0 7
53574: IFFALSE 53664
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
53576: LD_ADDR_VAR 0 3
53580: PUSH
53581: LD_EXP 128
53585: PUSH
53586: LD_VAR 0 2
53590: ARRAY
53591: PPUSH
53592: LD_INT 25
53594: PUSH
53595: LD_INT 12
53597: PUSH
53598: EMPTY
53599: LIST
53600: LIST
53601: PPUSH
53602: CALL_OW 72
53606: PUSH
53607: FOR_IN
53608: IFFALSE 53662
// if not IsInUnit ( j ) and not HasTask ( j ) then
53610: LD_VAR 0 3
53614: PPUSH
53615: CALL_OW 310
53619: NOT
53620: PUSH
53621: LD_VAR 0 3
53625: PPUSH
53626: CALL_OW 314
53630: NOT
53631: AND
53632: IFFALSE 53660
// begin ComEnterUnit ( j , selected ) ;
53634: LD_VAR 0 3
53638: PPUSH
53639: LD_VAR 0 7
53643: PPUSH
53644: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
53648: LD_VAR 0 3
53652: PPUSH
53653: LD_INT 15
53655: PPUSH
53656: CALL_OW 183
// end ;
53660: GO 53607
53662: POP
53663: POP
// end ; end ; end ; end ; end ;
53664: GO 53057
53666: POP
53667: POP
// end ;
53668: LD_VAR 0 1
53672: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
53673: LD_INT 0
53675: PPUSH
53676: PPUSH
53677: PPUSH
53678: PPUSH
// if not mc_bases then
53679: LD_EXP 99
53683: NOT
53684: IFFALSE 53688
// exit ;
53686: GO 53866
// for i = 1 to mc_bases do
53688: LD_ADDR_VAR 0 2
53692: PUSH
53693: DOUBLE
53694: LD_INT 1
53696: DEC
53697: ST_TO_ADDR
53698: LD_EXP 99
53702: PUSH
53703: FOR_TO
53704: IFFALSE 53864
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
53706: LD_ADDR_VAR 0 4
53710: PUSH
53711: LD_EXP 99
53715: PUSH
53716: LD_VAR 0 2
53720: ARRAY
53721: PPUSH
53722: LD_INT 25
53724: PUSH
53725: LD_INT 9
53727: PUSH
53728: EMPTY
53729: LIST
53730: LIST
53731: PPUSH
53732: CALL_OW 72
53736: ST_TO_ADDR
// if not tmp then
53737: LD_VAR 0 4
53741: NOT
53742: IFFALSE 53746
// continue ;
53744: GO 53703
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
53746: LD_EXP 125
53750: PUSH
53751: LD_VAR 0 2
53755: ARRAY
53756: PPUSH
53757: LD_INT 29
53759: PPUSH
53760: CALL_OW 325
53764: NOT
53765: PUSH
53766: LD_EXP 125
53770: PUSH
53771: LD_VAR 0 2
53775: ARRAY
53776: PPUSH
53777: LD_INT 28
53779: PPUSH
53780: CALL_OW 325
53784: NOT
53785: AND
53786: IFFALSE 53790
// continue ;
53788: GO 53703
// for j in tmp do
53790: LD_ADDR_VAR 0 3
53794: PUSH
53795: LD_VAR 0 4
53799: PUSH
53800: FOR_IN
53801: IFFALSE 53860
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
53803: LD_VAR 0 3
53807: PUSH
53808: LD_EXP 102
53812: PUSH
53813: LD_VAR 0 2
53817: ARRAY
53818: PUSH
53819: LD_INT 1
53821: ARRAY
53822: IN
53823: NOT
53824: PUSH
53825: LD_VAR 0 3
53829: PUSH
53830: LD_EXP 102
53834: PUSH
53835: LD_VAR 0 2
53839: ARRAY
53840: PUSH
53841: LD_INT 2
53843: ARRAY
53844: IN
53845: NOT
53846: AND
53847: IFFALSE 53858
// ComSpaceTimeShoot ( j ) ;
53849: LD_VAR 0 3
53853: PPUSH
53854: CALL 64884 0 1
53858: GO 53800
53860: POP
53861: POP
// end ;
53862: GO 53703
53864: POP
53865: POP
// end ;
53866: LD_VAR 0 1
53870: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
53871: LD_INT 0
53873: PPUSH
53874: PPUSH
53875: PPUSH
53876: PPUSH
53877: PPUSH
53878: PPUSH
53879: PPUSH
53880: PPUSH
53881: PPUSH
// if not mc_bases then
53882: LD_EXP 99
53886: NOT
53887: IFFALSE 53891
// exit ;
53889: GO 54513
// for i = 1 to mc_bases do
53891: LD_ADDR_VAR 0 2
53895: PUSH
53896: DOUBLE
53897: LD_INT 1
53899: DEC
53900: ST_TO_ADDR
53901: LD_EXP 99
53905: PUSH
53906: FOR_TO
53907: IFFALSE 54511
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
53909: LD_EXP 134
53913: PUSH
53914: LD_VAR 0 2
53918: ARRAY
53919: NOT
53920: PUSH
53921: LD_INT 38
53923: PPUSH
53924: LD_EXP 125
53928: PUSH
53929: LD_VAR 0 2
53933: ARRAY
53934: PPUSH
53935: CALL_OW 321
53939: PUSH
53940: LD_INT 2
53942: NONEQUAL
53943: OR
53944: IFFALSE 53948
// continue ;
53946: GO 53906
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
53948: LD_ADDR_VAR 0 8
53952: PUSH
53953: LD_EXP 99
53957: PUSH
53958: LD_VAR 0 2
53962: ARRAY
53963: PPUSH
53964: LD_INT 30
53966: PUSH
53967: LD_INT 34
53969: PUSH
53970: EMPTY
53971: LIST
53972: LIST
53973: PPUSH
53974: CALL_OW 72
53978: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
53979: LD_ADDR_VAR 0 9
53983: PUSH
53984: LD_EXP 99
53988: PUSH
53989: LD_VAR 0 2
53993: ARRAY
53994: PPUSH
53995: LD_INT 25
53997: PUSH
53998: LD_INT 4
54000: PUSH
54001: EMPTY
54002: LIST
54003: LIST
54004: PPUSH
54005: CALL_OW 72
54009: PPUSH
54010: LD_INT 0
54012: PPUSH
54013: CALL 104469 0 2
54017: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
54018: LD_VAR 0 9
54022: NOT
54023: PUSH
54024: LD_VAR 0 8
54028: NOT
54029: OR
54030: PUSH
54031: LD_EXP 99
54035: PUSH
54036: LD_VAR 0 2
54040: ARRAY
54041: PPUSH
54042: LD_INT 124
54044: PPUSH
54045: CALL 104469 0 2
54049: OR
54050: IFFALSE 54054
// continue ;
54052: GO 53906
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
54054: LD_EXP 135
54058: PUSH
54059: LD_VAR 0 2
54063: ARRAY
54064: PUSH
54065: LD_EXP 134
54069: PUSH
54070: LD_VAR 0 2
54074: ARRAY
54075: LESS
54076: PUSH
54077: LD_EXP 135
54081: PUSH
54082: LD_VAR 0 2
54086: ARRAY
54087: PUSH
54088: LD_VAR 0 8
54092: LESS
54093: AND
54094: IFFALSE 54509
// begin tmp := sci [ 1 ] ;
54096: LD_ADDR_VAR 0 7
54100: PUSH
54101: LD_VAR 0 9
54105: PUSH
54106: LD_INT 1
54108: ARRAY
54109: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
54110: LD_VAR 0 7
54114: PPUSH
54115: LD_INT 124
54117: PPUSH
54118: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
54122: LD_ADDR_VAR 0 3
54126: PUSH
54127: DOUBLE
54128: LD_EXP 134
54132: PUSH
54133: LD_VAR 0 2
54137: ARRAY
54138: INC
54139: ST_TO_ADDR
54140: LD_EXP 134
54144: PUSH
54145: LD_VAR 0 2
54149: ARRAY
54150: PUSH
54151: FOR_DOWNTO
54152: IFFALSE 54495
// begin if IsInUnit ( tmp ) then
54154: LD_VAR 0 7
54158: PPUSH
54159: CALL_OW 310
54163: IFFALSE 54174
// ComExitBuilding ( tmp ) ;
54165: LD_VAR 0 7
54169: PPUSH
54170: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
54174: LD_INT 35
54176: PPUSH
54177: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
54181: LD_VAR 0 7
54185: PPUSH
54186: CALL_OW 310
54190: NOT
54191: PUSH
54192: LD_VAR 0 7
54196: PPUSH
54197: CALL_OW 314
54201: NOT
54202: AND
54203: IFFALSE 54174
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
54205: LD_ADDR_VAR 0 6
54209: PUSH
54210: LD_VAR 0 7
54214: PPUSH
54215: CALL_OW 250
54219: PUSH
54220: LD_VAR 0 7
54224: PPUSH
54225: CALL_OW 251
54229: PUSH
54230: EMPTY
54231: LIST
54232: LIST
54233: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
54234: LD_INT 35
54236: PPUSH
54237: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
54241: LD_ADDR_VAR 0 4
54245: PUSH
54246: LD_EXP 134
54250: PUSH
54251: LD_VAR 0 2
54255: ARRAY
54256: PUSH
54257: LD_VAR 0 3
54261: ARRAY
54262: PUSH
54263: LD_INT 1
54265: ARRAY
54266: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
54267: LD_ADDR_VAR 0 5
54271: PUSH
54272: LD_EXP 134
54276: PUSH
54277: LD_VAR 0 2
54281: ARRAY
54282: PUSH
54283: LD_VAR 0 3
54287: ARRAY
54288: PUSH
54289: LD_INT 2
54291: ARRAY
54292: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
54293: LD_VAR 0 7
54297: PPUSH
54298: LD_INT 10
54300: PPUSH
54301: CALL 73802 0 2
54305: PUSH
54306: LD_INT 4
54308: ARRAY
54309: IFFALSE 54347
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
54311: LD_VAR 0 7
54315: PPUSH
54316: LD_VAR 0 6
54320: PUSH
54321: LD_INT 1
54323: ARRAY
54324: PPUSH
54325: LD_VAR 0 6
54329: PUSH
54330: LD_INT 2
54332: ARRAY
54333: PPUSH
54334: CALL_OW 111
// wait ( 0 0$10 ) ;
54338: LD_INT 350
54340: PPUSH
54341: CALL_OW 67
// end else
54345: GO 54373
// begin ComMoveXY ( tmp , x , y ) ;
54347: LD_VAR 0 7
54351: PPUSH
54352: LD_VAR 0 4
54356: PPUSH
54357: LD_VAR 0 5
54361: PPUSH
54362: CALL_OW 111
// wait ( 0 0$3 ) ;
54366: LD_INT 105
54368: PPUSH
54369: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
54373: LD_VAR 0 7
54377: PPUSH
54378: LD_VAR 0 4
54382: PPUSH
54383: LD_VAR 0 5
54387: PPUSH
54388: CALL_OW 307
54392: IFFALSE 54234
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
54394: LD_VAR 0 7
54398: PPUSH
54399: LD_VAR 0 4
54403: PPUSH
54404: LD_VAR 0 5
54408: PPUSH
54409: LD_VAR 0 8
54413: PUSH
54414: LD_VAR 0 3
54418: ARRAY
54419: PPUSH
54420: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
54424: LD_INT 35
54426: PPUSH
54427: CALL_OW 67
// until not HasTask ( tmp ) ;
54431: LD_VAR 0 7
54435: PPUSH
54436: CALL_OW 314
54440: NOT
54441: IFFALSE 54424
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
54443: LD_ADDR_EXP 135
54447: PUSH
54448: LD_EXP 135
54452: PPUSH
54453: LD_VAR 0 2
54457: PUSH
54458: LD_EXP 135
54462: PUSH
54463: LD_VAR 0 2
54467: ARRAY
54468: PUSH
54469: LD_INT 1
54471: PLUS
54472: PUSH
54473: EMPTY
54474: LIST
54475: LIST
54476: PPUSH
54477: LD_VAR 0 8
54481: PUSH
54482: LD_VAR 0 3
54486: ARRAY
54487: PPUSH
54488: CALL 71209 0 3
54492: ST_TO_ADDR
// end ;
54493: GO 54151
54495: POP
54496: POP
// MC_Reset ( i , 124 ) ;
54497: LD_VAR 0 2
54501: PPUSH
54502: LD_INT 124
54504: PPUSH
54505: CALL 37996 0 2
// end ; end ;
54509: GO 53906
54511: POP
54512: POP
// end ;
54513: LD_VAR 0 1
54517: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
54518: LD_INT 0
54520: PPUSH
54521: PPUSH
54522: PPUSH
// if not mc_bases then
54523: LD_EXP 99
54527: NOT
54528: IFFALSE 54532
// exit ;
54530: GO 55138
// for i = 1 to mc_bases do
54532: LD_ADDR_VAR 0 2
54536: PUSH
54537: DOUBLE
54538: LD_INT 1
54540: DEC
54541: ST_TO_ADDR
54542: LD_EXP 99
54546: PUSH
54547: FOR_TO
54548: IFFALSE 55136
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
54550: LD_ADDR_VAR 0 3
54554: PUSH
54555: LD_EXP 99
54559: PUSH
54560: LD_VAR 0 2
54564: ARRAY
54565: PPUSH
54566: LD_INT 25
54568: PUSH
54569: LD_INT 4
54571: PUSH
54572: EMPTY
54573: LIST
54574: LIST
54575: PPUSH
54576: CALL_OW 72
54580: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
54581: LD_VAR 0 3
54585: NOT
54586: PUSH
54587: LD_EXP 136
54591: PUSH
54592: LD_VAR 0 2
54596: ARRAY
54597: NOT
54598: OR
54599: PUSH
54600: LD_EXP 99
54604: PUSH
54605: LD_VAR 0 2
54609: ARRAY
54610: PPUSH
54611: LD_INT 2
54613: PUSH
54614: LD_INT 30
54616: PUSH
54617: LD_INT 0
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: PUSH
54624: LD_INT 30
54626: PUSH
54627: LD_INT 1
54629: PUSH
54630: EMPTY
54631: LIST
54632: LIST
54633: PUSH
54634: EMPTY
54635: LIST
54636: LIST
54637: LIST
54638: PPUSH
54639: CALL_OW 72
54643: NOT
54644: OR
54645: IFFALSE 54695
// begin if mc_deposits_finder [ i ] then
54647: LD_EXP 137
54651: PUSH
54652: LD_VAR 0 2
54656: ARRAY
54657: IFFALSE 54693
// begin MC_Reset ( i , 125 ) ;
54659: LD_VAR 0 2
54663: PPUSH
54664: LD_INT 125
54666: PPUSH
54667: CALL 37996 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54671: LD_ADDR_EXP 137
54675: PUSH
54676: LD_EXP 137
54680: PPUSH
54681: LD_VAR 0 2
54685: PPUSH
54686: EMPTY
54687: PPUSH
54688: CALL_OW 1
54692: ST_TO_ADDR
// end ; continue ;
54693: GO 54547
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
54695: LD_EXP 136
54699: PUSH
54700: LD_VAR 0 2
54704: ARRAY
54705: PUSH
54706: LD_INT 1
54708: ARRAY
54709: PUSH
54710: LD_INT 3
54712: ARRAY
54713: PUSH
54714: LD_INT 1
54716: EQUAL
54717: PUSH
54718: LD_INT 20
54720: PPUSH
54721: LD_EXP 125
54725: PUSH
54726: LD_VAR 0 2
54730: ARRAY
54731: PPUSH
54732: CALL_OW 321
54736: PUSH
54737: LD_INT 2
54739: NONEQUAL
54740: AND
54741: IFFALSE 54791
// begin if mc_deposits_finder [ i ] then
54743: LD_EXP 137
54747: PUSH
54748: LD_VAR 0 2
54752: ARRAY
54753: IFFALSE 54789
// begin MC_Reset ( i , 125 ) ;
54755: LD_VAR 0 2
54759: PPUSH
54760: LD_INT 125
54762: PPUSH
54763: CALL 37996 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54767: LD_ADDR_EXP 137
54771: PUSH
54772: LD_EXP 137
54776: PPUSH
54777: LD_VAR 0 2
54781: PPUSH
54782: EMPTY
54783: PPUSH
54784: CALL_OW 1
54788: ST_TO_ADDR
// end ; continue ;
54789: GO 54547
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
54791: LD_EXP 136
54795: PUSH
54796: LD_VAR 0 2
54800: ARRAY
54801: PUSH
54802: LD_INT 1
54804: ARRAY
54805: PUSH
54806: LD_INT 1
54808: ARRAY
54809: PPUSH
54810: LD_EXP 136
54814: PUSH
54815: LD_VAR 0 2
54819: ARRAY
54820: PUSH
54821: LD_INT 1
54823: ARRAY
54824: PUSH
54825: LD_INT 2
54827: ARRAY
54828: PPUSH
54829: LD_EXP 125
54833: PUSH
54834: LD_VAR 0 2
54838: ARRAY
54839: PPUSH
54840: CALL_OW 440
54844: IFFALSE 54887
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
54846: LD_ADDR_EXP 136
54850: PUSH
54851: LD_EXP 136
54855: PPUSH
54856: LD_VAR 0 2
54860: PPUSH
54861: LD_EXP 136
54865: PUSH
54866: LD_VAR 0 2
54870: ARRAY
54871: PPUSH
54872: LD_INT 1
54874: PPUSH
54875: CALL_OW 3
54879: PPUSH
54880: CALL_OW 1
54884: ST_TO_ADDR
54885: GO 55134
// begin if not mc_deposits_finder [ i ] then
54887: LD_EXP 137
54891: PUSH
54892: LD_VAR 0 2
54896: ARRAY
54897: NOT
54898: IFFALSE 54950
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
54900: LD_ADDR_EXP 137
54904: PUSH
54905: LD_EXP 137
54909: PPUSH
54910: LD_VAR 0 2
54914: PPUSH
54915: LD_VAR 0 3
54919: PUSH
54920: LD_INT 1
54922: ARRAY
54923: PUSH
54924: EMPTY
54925: LIST
54926: PPUSH
54927: CALL_OW 1
54931: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
54932: LD_VAR 0 3
54936: PUSH
54937: LD_INT 1
54939: ARRAY
54940: PPUSH
54941: LD_INT 125
54943: PPUSH
54944: CALL_OW 109
// end else
54948: GO 55134
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
54950: LD_EXP 137
54954: PUSH
54955: LD_VAR 0 2
54959: ARRAY
54960: PUSH
54961: LD_INT 1
54963: ARRAY
54964: PPUSH
54965: CALL_OW 310
54969: IFFALSE 54992
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
54971: LD_EXP 137
54975: PUSH
54976: LD_VAR 0 2
54980: ARRAY
54981: PUSH
54982: LD_INT 1
54984: ARRAY
54985: PPUSH
54986: CALL_OW 122
54990: GO 55134
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
54992: LD_EXP 137
54996: PUSH
54997: LD_VAR 0 2
55001: ARRAY
55002: PUSH
55003: LD_INT 1
55005: ARRAY
55006: PPUSH
55007: CALL_OW 314
55011: NOT
55012: PUSH
55013: LD_EXP 137
55017: PUSH
55018: LD_VAR 0 2
55022: ARRAY
55023: PUSH
55024: LD_INT 1
55026: ARRAY
55027: PPUSH
55028: LD_EXP 136
55032: PUSH
55033: LD_VAR 0 2
55037: ARRAY
55038: PUSH
55039: LD_INT 1
55041: ARRAY
55042: PUSH
55043: LD_INT 1
55045: ARRAY
55046: PPUSH
55047: LD_EXP 136
55051: PUSH
55052: LD_VAR 0 2
55056: ARRAY
55057: PUSH
55058: LD_INT 1
55060: ARRAY
55061: PUSH
55062: LD_INT 2
55064: ARRAY
55065: PPUSH
55066: CALL_OW 297
55070: PUSH
55071: LD_INT 6
55073: GREATER
55074: AND
55075: IFFALSE 55134
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
55077: LD_EXP 137
55081: PUSH
55082: LD_VAR 0 2
55086: ARRAY
55087: PUSH
55088: LD_INT 1
55090: ARRAY
55091: PPUSH
55092: LD_EXP 136
55096: PUSH
55097: LD_VAR 0 2
55101: ARRAY
55102: PUSH
55103: LD_INT 1
55105: ARRAY
55106: PUSH
55107: LD_INT 1
55109: ARRAY
55110: PPUSH
55111: LD_EXP 136
55115: PUSH
55116: LD_VAR 0 2
55120: ARRAY
55121: PUSH
55122: LD_INT 1
55124: ARRAY
55125: PUSH
55126: LD_INT 2
55128: ARRAY
55129: PPUSH
55130: CALL_OW 111
// end ; end ; end ;
55134: GO 54547
55136: POP
55137: POP
// end ;
55138: LD_VAR 0 1
55142: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
55143: LD_INT 0
55145: PPUSH
55146: PPUSH
55147: PPUSH
55148: PPUSH
55149: PPUSH
55150: PPUSH
55151: PPUSH
55152: PPUSH
55153: PPUSH
55154: PPUSH
55155: PPUSH
// if not mc_bases then
55156: LD_EXP 99
55160: NOT
55161: IFFALSE 55165
// exit ;
55163: GO 56105
// for i = 1 to mc_bases do
55165: LD_ADDR_VAR 0 2
55169: PUSH
55170: DOUBLE
55171: LD_INT 1
55173: DEC
55174: ST_TO_ADDR
55175: LD_EXP 99
55179: PUSH
55180: FOR_TO
55181: IFFALSE 56103
// begin if not mc_bases [ i ] or mc_scan [ i ] then
55183: LD_EXP 99
55187: PUSH
55188: LD_VAR 0 2
55192: ARRAY
55193: NOT
55194: PUSH
55195: LD_EXP 122
55199: PUSH
55200: LD_VAR 0 2
55204: ARRAY
55205: OR
55206: IFFALSE 55210
// continue ;
55208: GO 55180
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
55210: LD_ADDR_VAR 0 7
55214: PUSH
55215: LD_EXP 99
55219: PUSH
55220: LD_VAR 0 2
55224: ARRAY
55225: PUSH
55226: LD_INT 1
55228: ARRAY
55229: PPUSH
55230: CALL_OW 248
55234: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
55235: LD_VAR 0 7
55239: PUSH
55240: LD_INT 3
55242: EQUAL
55243: PUSH
55244: LD_EXP 118
55248: PUSH
55249: LD_VAR 0 2
55253: ARRAY
55254: PUSH
55255: LD_EXP 121
55259: PUSH
55260: LD_VAR 0 2
55264: ARRAY
55265: UNION
55266: PPUSH
55267: LD_INT 33
55269: PUSH
55270: LD_INT 2
55272: PUSH
55273: EMPTY
55274: LIST
55275: LIST
55276: PPUSH
55277: CALL_OW 72
55281: NOT
55282: OR
55283: IFFALSE 55287
// continue ;
55285: GO 55180
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
55287: LD_ADDR_VAR 0 9
55291: PUSH
55292: LD_EXP 99
55296: PUSH
55297: LD_VAR 0 2
55301: ARRAY
55302: PPUSH
55303: LD_INT 30
55305: PUSH
55306: LD_INT 36
55308: PUSH
55309: EMPTY
55310: LIST
55311: LIST
55312: PPUSH
55313: CALL_OW 72
55317: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
55318: LD_ADDR_VAR 0 10
55322: PUSH
55323: LD_EXP 118
55327: PUSH
55328: LD_VAR 0 2
55332: ARRAY
55333: PPUSH
55334: LD_INT 34
55336: PUSH
55337: LD_INT 31
55339: PUSH
55340: EMPTY
55341: LIST
55342: LIST
55343: PPUSH
55344: CALL_OW 72
55348: ST_TO_ADDR
// if not cts and not mcts then
55349: LD_VAR 0 9
55353: NOT
55354: PUSH
55355: LD_VAR 0 10
55359: NOT
55360: AND
55361: IFFALSE 55365
// continue ;
55363: GO 55180
// x := cts ;
55365: LD_ADDR_VAR 0 11
55369: PUSH
55370: LD_VAR 0 9
55374: ST_TO_ADDR
// if not x then
55375: LD_VAR 0 11
55379: NOT
55380: IFFALSE 55392
// x := mcts ;
55382: LD_ADDR_VAR 0 11
55386: PUSH
55387: LD_VAR 0 10
55391: ST_TO_ADDR
// if not x then
55392: LD_VAR 0 11
55396: NOT
55397: IFFALSE 55401
// continue ;
55399: GO 55180
// if mc_remote_driver [ i ] then
55401: LD_EXP 139
55405: PUSH
55406: LD_VAR 0 2
55410: ARRAY
55411: IFFALSE 55798
// for j in mc_remote_driver [ i ] do
55413: LD_ADDR_VAR 0 3
55417: PUSH
55418: LD_EXP 139
55422: PUSH
55423: LD_VAR 0 2
55427: ARRAY
55428: PUSH
55429: FOR_IN
55430: IFFALSE 55796
// begin if GetClass ( j ) <> 3 then
55432: LD_VAR 0 3
55436: PPUSH
55437: CALL_OW 257
55441: PUSH
55442: LD_INT 3
55444: NONEQUAL
55445: IFFALSE 55498
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
55447: LD_ADDR_EXP 139
55451: PUSH
55452: LD_EXP 139
55456: PPUSH
55457: LD_VAR 0 2
55461: PPUSH
55462: LD_EXP 139
55466: PUSH
55467: LD_VAR 0 2
55471: ARRAY
55472: PUSH
55473: LD_VAR 0 3
55477: DIFF
55478: PPUSH
55479: CALL_OW 1
55483: ST_TO_ADDR
// SetTag ( j , 0 ) ;
55484: LD_VAR 0 3
55488: PPUSH
55489: LD_INT 0
55491: PPUSH
55492: CALL_OW 109
// continue ;
55496: GO 55429
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
55498: LD_EXP 118
55502: PUSH
55503: LD_VAR 0 2
55507: ARRAY
55508: PPUSH
55509: LD_INT 34
55511: PUSH
55512: LD_INT 31
55514: PUSH
55515: EMPTY
55516: LIST
55517: LIST
55518: PUSH
55519: LD_INT 58
55521: PUSH
55522: EMPTY
55523: LIST
55524: PUSH
55525: EMPTY
55526: LIST
55527: LIST
55528: PPUSH
55529: CALL_OW 72
55533: PUSH
55534: LD_VAR 0 3
55538: PPUSH
55539: CALL 104557 0 1
55543: NOT
55544: AND
55545: IFFALSE 55616
// begin if IsInUnit ( j ) then
55547: LD_VAR 0 3
55551: PPUSH
55552: CALL_OW 310
55556: IFFALSE 55567
// ComExitBuilding ( j ) ;
55558: LD_VAR 0 3
55562: PPUSH
55563: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
55567: LD_VAR 0 3
55571: PPUSH
55572: LD_EXP 118
55576: PUSH
55577: LD_VAR 0 2
55581: ARRAY
55582: PPUSH
55583: LD_INT 34
55585: PUSH
55586: LD_INT 31
55588: PUSH
55589: EMPTY
55590: LIST
55591: LIST
55592: PUSH
55593: LD_INT 58
55595: PUSH
55596: EMPTY
55597: LIST
55598: PUSH
55599: EMPTY
55600: LIST
55601: LIST
55602: PPUSH
55603: CALL_OW 72
55607: PUSH
55608: LD_INT 1
55610: ARRAY
55611: PPUSH
55612: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
55616: LD_VAR 0 3
55620: PPUSH
55621: CALL_OW 310
55625: NOT
55626: PUSH
55627: LD_VAR 0 3
55631: PPUSH
55632: CALL_OW 310
55636: PPUSH
55637: CALL_OW 266
55641: PUSH
55642: LD_INT 36
55644: NONEQUAL
55645: PUSH
55646: LD_VAR 0 3
55650: PPUSH
55651: CALL 104557 0 1
55655: NOT
55656: AND
55657: OR
55658: IFFALSE 55794
// begin if IsInUnit ( j ) then
55660: LD_VAR 0 3
55664: PPUSH
55665: CALL_OW 310
55669: IFFALSE 55680
// ComExitBuilding ( j ) ;
55671: LD_VAR 0 3
55675: PPUSH
55676: CALL_OW 122
// ct := 0 ;
55680: LD_ADDR_VAR 0 8
55684: PUSH
55685: LD_INT 0
55687: ST_TO_ADDR
// for k in x do
55688: LD_ADDR_VAR 0 4
55692: PUSH
55693: LD_VAR 0 11
55697: PUSH
55698: FOR_IN
55699: IFFALSE 55772
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
55701: LD_VAR 0 4
55705: PPUSH
55706: CALL_OW 264
55710: PUSH
55711: LD_INT 31
55713: EQUAL
55714: PUSH
55715: LD_VAR 0 4
55719: PPUSH
55720: CALL_OW 311
55724: NOT
55725: AND
55726: PUSH
55727: LD_VAR 0 4
55731: PPUSH
55732: CALL_OW 266
55736: PUSH
55737: LD_INT 36
55739: EQUAL
55740: PUSH
55741: LD_VAR 0 4
55745: PPUSH
55746: CALL_OW 313
55750: PUSH
55751: LD_INT 3
55753: LESS
55754: AND
55755: OR
55756: IFFALSE 55770
// begin ct := k ;
55758: LD_ADDR_VAR 0 8
55762: PUSH
55763: LD_VAR 0 4
55767: ST_TO_ADDR
// break ;
55768: GO 55772
// end ;
55770: GO 55698
55772: POP
55773: POP
// if ct then
55774: LD_VAR 0 8
55778: IFFALSE 55794
// ComEnterUnit ( j , ct ) ;
55780: LD_VAR 0 3
55784: PPUSH
55785: LD_VAR 0 8
55789: PPUSH
55790: CALL_OW 120
// end ; end ;
55794: GO 55429
55796: POP
55797: POP
// places := 0 ;
55798: LD_ADDR_VAR 0 5
55802: PUSH
55803: LD_INT 0
55805: ST_TO_ADDR
// for j = 1 to x do
55806: LD_ADDR_VAR 0 3
55810: PUSH
55811: DOUBLE
55812: LD_INT 1
55814: DEC
55815: ST_TO_ADDR
55816: LD_VAR 0 11
55820: PUSH
55821: FOR_TO
55822: IFFALSE 55898
// if GetWeapon ( x [ j ] ) = ar_control_tower then
55824: LD_VAR 0 11
55828: PUSH
55829: LD_VAR 0 3
55833: ARRAY
55834: PPUSH
55835: CALL_OW 264
55839: PUSH
55840: LD_INT 31
55842: EQUAL
55843: IFFALSE 55861
// places := places + 1 else
55845: LD_ADDR_VAR 0 5
55849: PUSH
55850: LD_VAR 0 5
55854: PUSH
55855: LD_INT 1
55857: PLUS
55858: ST_TO_ADDR
55859: GO 55896
// if GetBType ( x [ j ] ) = b_control_tower then
55861: LD_VAR 0 11
55865: PUSH
55866: LD_VAR 0 3
55870: ARRAY
55871: PPUSH
55872: CALL_OW 266
55876: PUSH
55877: LD_INT 36
55879: EQUAL
55880: IFFALSE 55896
// places := places + 3 ;
55882: LD_ADDR_VAR 0 5
55886: PUSH
55887: LD_VAR 0 5
55891: PUSH
55892: LD_INT 3
55894: PLUS
55895: ST_TO_ADDR
55896: GO 55821
55898: POP
55899: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
55900: LD_VAR 0 5
55904: PUSH
55905: LD_INT 0
55907: EQUAL
55908: PUSH
55909: LD_VAR 0 5
55913: PUSH
55914: LD_EXP 139
55918: PUSH
55919: LD_VAR 0 2
55923: ARRAY
55924: LESSEQUAL
55925: OR
55926: IFFALSE 55930
// continue ;
55928: GO 55180
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
55930: LD_ADDR_VAR 0 6
55934: PUSH
55935: LD_EXP 99
55939: PUSH
55940: LD_VAR 0 2
55944: ARRAY
55945: PPUSH
55946: LD_INT 25
55948: PUSH
55949: LD_INT 3
55951: PUSH
55952: EMPTY
55953: LIST
55954: LIST
55955: PPUSH
55956: CALL_OW 72
55960: PUSH
55961: LD_EXP 139
55965: PUSH
55966: LD_VAR 0 2
55970: ARRAY
55971: DIFF
55972: PPUSH
55973: LD_INT 3
55975: PPUSH
55976: CALL 105457 0 2
55980: ST_TO_ADDR
// for j in tmp do
55981: LD_ADDR_VAR 0 3
55985: PUSH
55986: LD_VAR 0 6
55990: PUSH
55991: FOR_IN
55992: IFFALSE 56027
// if GetTag ( j ) > 0 then
55994: LD_VAR 0 3
55998: PPUSH
55999: CALL_OW 110
56003: PUSH
56004: LD_INT 0
56006: GREATER
56007: IFFALSE 56025
// tmp := tmp diff j ;
56009: LD_ADDR_VAR 0 6
56013: PUSH
56014: LD_VAR 0 6
56018: PUSH
56019: LD_VAR 0 3
56023: DIFF
56024: ST_TO_ADDR
56025: GO 55991
56027: POP
56028: POP
// if not tmp then
56029: LD_VAR 0 6
56033: NOT
56034: IFFALSE 56038
// continue ;
56036: GO 55180
// if places then
56038: LD_VAR 0 5
56042: IFFALSE 56101
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
56044: LD_ADDR_EXP 139
56048: PUSH
56049: LD_EXP 139
56053: PPUSH
56054: LD_VAR 0 2
56058: PPUSH
56059: LD_EXP 139
56063: PUSH
56064: LD_VAR 0 2
56068: ARRAY
56069: PUSH
56070: LD_VAR 0 6
56074: PUSH
56075: LD_INT 1
56077: ARRAY
56078: UNION
56079: PPUSH
56080: CALL_OW 1
56084: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
56085: LD_VAR 0 6
56089: PUSH
56090: LD_INT 1
56092: ARRAY
56093: PPUSH
56094: LD_INT 126
56096: PPUSH
56097: CALL_OW 109
// end ; end ;
56101: GO 55180
56103: POP
56104: POP
// end ;
56105: LD_VAR 0 1
56109: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
56110: LD_INT 0
56112: PPUSH
56113: PPUSH
56114: PPUSH
56115: PPUSH
56116: PPUSH
56117: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
56118: LD_VAR 0 1
56122: NOT
56123: PUSH
56124: LD_VAR 0 2
56128: NOT
56129: OR
56130: PUSH
56131: LD_VAR 0 3
56135: NOT
56136: OR
56137: PUSH
56138: LD_VAR 0 4
56142: PUSH
56143: LD_INT 1
56145: PUSH
56146: LD_INT 2
56148: PUSH
56149: LD_INT 3
56151: PUSH
56152: LD_INT 4
56154: PUSH
56155: LD_INT 5
56157: PUSH
56158: LD_INT 8
56160: PUSH
56161: LD_INT 9
56163: PUSH
56164: LD_INT 15
56166: PUSH
56167: LD_INT 16
56169: PUSH
56170: EMPTY
56171: LIST
56172: LIST
56173: LIST
56174: LIST
56175: LIST
56176: LIST
56177: LIST
56178: LIST
56179: LIST
56180: IN
56181: NOT
56182: OR
56183: IFFALSE 56187
// exit ;
56185: GO 57087
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
56187: LD_ADDR_VAR 0 2
56191: PUSH
56192: LD_VAR 0 2
56196: PPUSH
56197: LD_INT 21
56199: PUSH
56200: LD_INT 3
56202: PUSH
56203: EMPTY
56204: LIST
56205: LIST
56206: PUSH
56207: LD_INT 24
56209: PUSH
56210: LD_INT 250
56212: PUSH
56213: EMPTY
56214: LIST
56215: LIST
56216: PUSH
56217: EMPTY
56218: LIST
56219: LIST
56220: PPUSH
56221: CALL_OW 72
56225: ST_TO_ADDR
// case class of 1 , 15 :
56226: LD_VAR 0 4
56230: PUSH
56231: LD_INT 1
56233: DOUBLE
56234: EQUAL
56235: IFTRUE 56245
56237: LD_INT 15
56239: DOUBLE
56240: EQUAL
56241: IFTRUE 56245
56243: GO 56330
56245: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
56246: LD_ADDR_VAR 0 8
56250: PUSH
56251: LD_VAR 0 2
56255: PPUSH
56256: LD_INT 2
56258: PUSH
56259: LD_INT 30
56261: PUSH
56262: LD_INT 32
56264: PUSH
56265: EMPTY
56266: LIST
56267: LIST
56268: PUSH
56269: LD_INT 30
56271: PUSH
56272: LD_INT 31
56274: PUSH
56275: EMPTY
56276: LIST
56277: LIST
56278: PUSH
56279: EMPTY
56280: LIST
56281: LIST
56282: LIST
56283: PPUSH
56284: CALL_OW 72
56288: PUSH
56289: LD_VAR 0 2
56293: PPUSH
56294: LD_INT 2
56296: PUSH
56297: LD_INT 30
56299: PUSH
56300: LD_INT 4
56302: PUSH
56303: EMPTY
56304: LIST
56305: LIST
56306: PUSH
56307: LD_INT 30
56309: PUSH
56310: LD_INT 5
56312: PUSH
56313: EMPTY
56314: LIST
56315: LIST
56316: PUSH
56317: EMPTY
56318: LIST
56319: LIST
56320: LIST
56321: PPUSH
56322: CALL_OW 72
56326: ADD
56327: ST_TO_ADDR
56328: GO 56576
56330: LD_INT 2
56332: DOUBLE
56333: EQUAL
56334: IFTRUE 56344
56336: LD_INT 16
56338: DOUBLE
56339: EQUAL
56340: IFTRUE 56344
56342: GO 56390
56344: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
56345: LD_ADDR_VAR 0 8
56349: PUSH
56350: LD_VAR 0 2
56354: PPUSH
56355: LD_INT 2
56357: PUSH
56358: LD_INT 30
56360: PUSH
56361: LD_INT 0
56363: PUSH
56364: EMPTY
56365: LIST
56366: LIST
56367: PUSH
56368: LD_INT 30
56370: PUSH
56371: LD_INT 1
56373: PUSH
56374: EMPTY
56375: LIST
56376: LIST
56377: PUSH
56378: EMPTY
56379: LIST
56380: LIST
56381: LIST
56382: PPUSH
56383: CALL_OW 72
56387: ST_TO_ADDR
56388: GO 56576
56390: LD_INT 3
56392: DOUBLE
56393: EQUAL
56394: IFTRUE 56398
56396: GO 56444
56398: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
56399: LD_ADDR_VAR 0 8
56403: PUSH
56404: LD_VAR 0 2
56408: PPUSH
56409: LD_INT 2
56411: PUSH
56412: LD_INT 30
56414: PUSH
56415: LD_INT 2
56417: PUSH
56418: EMPTY
56419: LIST
56420: LIST
56421: PUSH
56422: LD_INT 30
56424: PUSH
56425: LD_INT 3
56427: PUSH
56428: EMPTY
56429: LIST
56430: LIST
56431: PUSH
56432: EMPTY
56433: LIST
56434: LIST
56435: LIST
56436: PPUSH
56437: CALL_OW 72
56441: ST_TO_ADDR
56442: GO 56576
56444: LD_INT 4
56446: DOUBLE
56447: EQUAL
56448: IFTRUE 56452
56450: GO 56509
56452: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
56453: LD_ADDR_VAR 0 8
56457: PUSH
56458: LD_VAR 0 2
56462: PPUSH
56463: LD_INT 2
56465: PUSH
56466: LD_INT 30
56468: PUSH
56469: LD_INT 6
56471: PUSH
56472: EMPTY
56473: LIST
56474: LIST
56475: PUSH
56476: LD_INT 30
56478: PUSH
56479: LD_INT 7
56481: PUSH
56482: EMPTY
56483: LIST
56484: LIST
56485: PUSH
56486: LD_INT 30
56488: PUSH
56489: LD_INT 8
56491: PUSH
56492: EMPTY
56493: LIST
56494: LIST
56495: PUSH
56496: EMPTY
56497: LIST
56498: LIST
56499: LIST
56500: LIST
56501: PPUSH
56502: CALL_OW 72
56506: ST_TO_ADDR
56507: GO 56576
56509: LD_INT 5
56511: DOUBLE
56512: EQUAL
56513: IFTRUE 56529
56515: LD_INT 8
56517: DOUBLE
56518: EQUAL
56519: IFTRUE 56529
56521: LD_INT 9
56523: DOUBLE
56524: EQUAL
56525: IFTRUE 56529
56527: GO 56575
56529: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
56530: LD_ADDR_VAR 0 8
56534: PUSH
56535: LD_VAR 0 2
56539: PPUSH
56540: LD_INT 2
56542: PUSH
56543: LD_INT 30
56545: PUSH
56546: LD_INT 4
56548: PUSH
56549: EMPTY
56550: LIST
56551: LIST
56552: PUSH
56553: LD_INT 30
56555: PUSH
56556: LD_INT 5
56558: PUSH
56559: EMPTY
56560: LIST
56561: LIST
56562: PUSH
56563: EMPTY
56564: LIST
56565: LIST
56566: LIST
56567: PPUSH
56568: CALL_OW 72
56572: ST_TO_ADDR
56573: GO 56576
56575: POP
// if not tmp then
56576: LD_VAR 0 8
56580: NOT
56581: IFFALSE 56585
// exit ;
56583: GO 57087
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
56585: LD_VAR 0 4
56589: PUSH
56590: LD_INT 1
56592: PUSH
56593: LD_INT 15
56595: PUSH
56596: EMPTY
56597: LIST
56598: LIST
56599: IN
56600: PUSH
56601: LD_EXP 108
56605: PUSH
56606: LD_VAR 0 1
56610: ARRAY
56611: AND
56612: IFFALSE 56768
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
56614: LD_ADDR_VAR 0 9
56618: PUSH
56619: LD_EXP 108
56623: PUSH
56624: LD_VAR 0 1
56628: ARRAY
56629: PUSH
56630: LD_INT 1
56632: ARRAY
56633: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
56634: LD_VAR 0 9
56638: PUSH
56639: LD_EXP 109
56643: PUSH
56644: LD_VAR 0 1
56648: ARRAY
56649: IN
56650: NOT
56651: IFFALSE 56766
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
56653: LD_ADDR_EXP 109
56657: PUSH
56658: LD_EXP 109
56662: PPUSH
56663: LD_VAR 0 1
56667: PUSH
56668: LD_EXP 109
56672: PUSH
56673: LD_VAR 0 1
56677: ARRAY
56678: PUSH
56679: LD_INT 1
56681: PLUS
56682: PUSH
56683: EMPTY
56684: LIST
56685: LIST
56686: PPUSH
56687: LD_VAR 0 9
56691: PPUSH
56692: CALL 71209 0 3
56696: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
56697: LD_ADDR_EXP 108
56701: PUSH
56702: LD_EXP 108
56706: PPUSH
56707: LD_VAR 0 1
56711: PPUSH
56712: LD_EXP 108
56716: PUSH
56717: LD_VAR 0 1
56721: ARRAY
56722: PUSH
56723: LD_VAR 0 9
56727: DIFF
56728: PPUSH
56729: CALL_OW 1
56733: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
56734: LD_VAR 0 3
56738: PPUSH
56739: LD_EXP 109
56743: PUSH
56744: LD_VAR 0 1
56748: ARRAY
56749: PUSH
56750: LD_EXP 109
56754: PUSH
56755: LD_VAR 0 1
56759: ARRAY
56760: ARRAY
56761: PPUSH
56762: CALL_OW 120
// end ; exit ;
56766: GO 57087
// end ; if tmp > 1 then
56768: LD_VAR 0 8
56772: PUSH
56773: LD_INT 1
56775: GREATER
56776: IFFALSE 56880
// for i = 2 to tmp do
56778: LD_ADDR_VAR 0 6
56782: PUSH
56783: DOUBLE
56784: LD_INT 2
56786: DEC
56787: ST_TO_ADDR
56788: LD_VAR 0 8
56792: PUSH
56793: FOR_TO
56794: IFFALSE 56878
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
56796: LD_VAR 0 8
56800: PUSH
56801: LD_VAR 0 6
56805: ARRAY
56806: PPUSH
56807: CALL_OW 461
56811: PUSH
56812: LD_INT 6
56814: EQUAL
56815: IFFALSE 56876
// begin x := tmp [ i ] ;
56817: LD_ADDR_VAR 0 9
56821: PUSH
56822: LD_VAR 0 8
56826: PUSH
56827: LD_VAR 0 6
56831: ARRAY
56832: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
56833: LD_ADDR_VAR 0 8
56837: PUSH
56838: LD_VAR 0 8
56842: PPUSH
56843: LD_VAR 0 6
56847: PPUSH
56848: CALL_OW 3
56852: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
56853: LD_ADDR_VAR 0 8
56857: PUSH
56858: LD_VAR 0 8
56862: PPUSH
56863: LD_INT 1
56865: PPUSH
56866: LD_VAR 0 9
56870: PPUSH
56871: CALL_OW 2
56875: ST_TO_ADDR
// end ;
56876: GO 56793
56878: POP
56879: POP
// for i in tmp do
56880: LD_ADDR_VAR 0 6
56884: PUSH
56885: LD_VAR 0 8
56889: PUSH
56890: FOR_IN
56891: IFFALSE 56960
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
56893: LD_VAR 0 6
56897: PPUSH
56898: CALL_OW 313
56902: PUSH
56903: LD_INT 6
56905: LESS
56906: PUSH
56907: LD_VAR 0 6
56911: PPUSH
56912: CALL_OW 266
56916: PUSH
56917: LD_INT 31
56919: PUSH
56920: LD_INT 32
56922: PUSH
56923: EMPTY
56924: LIST
56925: LIST
56926: IN
56927: NOT
56928: AND
56929: PUSH
56930: LD_VAR 0 6
56934: PPUSH
56935: CALL_OW 313
56939: PUSH
56940: LD_INT 0
56942: EQUAL
56943: OR
56944: IFFALSE 56958
// begin j := i ;
56946: LD_ADDR_VAR 0 7
56950: PUSH
56951: LD_VAR 0 6
56955: ST_TO_ADDR
// break ;
56956: GO 56960
// end ; end ;
56958: GO 56890
56960: POP
56961: POP
// if j then
56962: LD_VAR 0 7
56966: IFFALSE 56984
// ComEnterUnit ( unit , j ) else
56968: LD_VAR 0 3
56972: PPUSH
56973: LD_VAR 0 7
56977: PPUSH
56978: CALL_OW 120
56982: GO 57087
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
56984: LD_ADDR_VAR 0 10
56988: PUSH
56989: LD_VAR 0 2
56993: PPUSH
56994: LD_INT 2
56996: PUSH
56997: LD_INT 30
56999: PUSH
57000: LD_INT 0
57002: PUSH
57003: EMPTY
57004: LIST
57005: LIST
57006: PUSH
57007: LD_INT 30
57009: PUSH
57010: LD_INT 1
57012: PUSH
57013: EMPTY
57014: LIST
57015: LIST
57016: PUSH
57017: EMPTY
57018: LIST
57019: LIST
57020: LIST
57021: PPUSH
57022: CALL_OW 72
57026: ST_TO_ADDR
// if depot then
57027: LD_VAR 0 10
57031: IFFALSE 57087
// begin depot := NearestUnitToUnit ( depot , unit ) ;
57033: LD_ADDR_VAR 0 10
57037: PUSH
57038: LD_VAR 0 10
57042: PPUSH
57043: LD_VAR 0 3
57047: PPUSH
57048: CALL_OW 74
57052: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
57053: LD_VAR 0 3
57057: PPUSH
57058: LD_VAR 0 10
57062: PPUSH
57063: CALL_OW 296
57067: PUSH
57068: LD_INT 10
57070: GREATER
57071: IFFALSE 57087
// ComStandNearbyBuilding ( unit , depot ) ;
57073: LD_VAR 0 3
57077: PPUSH
57078: LD_VAR 0 10
57082: PPUSH
57083: CALL 65501 0 2
// end ; end ; end ;
57087: LD_VAR 0 5
57091: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
57092: LD_INT 0
57094: PPUSH
57095: PPUSH
57096: PPUSH
57097: PPUSH
// if not mc_bases then
57098: LD_EXP 99
57102: NOT
57103: IFFALSE 57107
// exit ;
57105: GO 57346
// for i = 1 to mc_bases do
57107: LD_ADDR_VAR 0 2
57111: PUSH
57112: DOUBLE
57113: LD_INT 1
57115: DEC
57116: ST_TO_ADDR
57117: LD_EXP 99
57121: PUSH
57122: FOR_TO
57123: IFFALSE 57344
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
57125: LD_ADDR_VAR 0 4
57129: PUSH
57130: LD_EXP 99
57134: PUSH
57135: LD_VAR 0 2
57139: ARRAY
57140: PPUSH
57141: LD_INT 21
57143: PUSH
57144: LD_INT 1
57146: PUSH
57147: EMPTY
57148: LIST
57149: LIST
57150: PPUSH
57151: CALL_OW 72
57155: PUSH
57156: LD_EXP 128
57160: PUSH
57161: LD_VAR 0 2
57165: ARRAY
57166: UNION
57167: ST_TO_ADDR
// if not tmp then
57168: LD_VAR 0 4
57172: NOT
57173: IFFALSE 57177
// continue ;
57175: GO 57122
// for j in tmp do
57177: LD_ADDR_VAR 0 3
57181: PUSH
57182: LD_VAR 0 4
57186: PUSH
57187: FOR_IN
57188: IFFALSE 57340
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
57190: LD_VAR 0 3
57194: PPUSH
57195: CALL_OW 110
57199: NOT
57200: PUSH
57201: LD_VAR 0 3
57205: PPUSH
57206: CALL_OW 314
57210: NOT
57211: AND
57212: PUSH
57213: LD_VAR 0 3
57217: PPUSH
57218: CALL_OW 311
57222: NOT
57223: AND
57224: PUSH
57225: LD_VAR 0 3
57229: PPUSH
57230: CALL_OW 310
57234: NOT
57235: AND
57236: PUSH
57237: LD_VAR 0 3
57241: PUSH
57242: LD_EXP 102
57246: PUSH
57247: LD_VAR 0 2
57251: ARRAY
57252: PUSH
57253: LD_INT 1
57255: ARRAY
57256: IN
57257: NOT
57258: AND
57259: PUSH
57260: LD_VAR 0 3
57264: PUSH
57265: LD_EXP 102
57269: PUSH
57270: LD_VAR 0 2
57274: ARRAY
57275: PUSH
57276: LD_INT 2
57278: ARRAY
57279: IN
57280: NOT
57281: AND
57282: PUSH
57283: LD_VAR 0 3
57287: PUSH
57288: LD_EXP 111
57292: PUSH
57293: LD_VAR 0 2
57297: ARRAY
57298: IN
57299: NOT
57300: AND
57301: IFFALSE 57338
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
57303: LD_VAR 0 2
57307: PPUSH
57308: LD_EXP 99
57312: PUSH
57313: LD_VAR 0 2
57317: ARRAY
57318: PPUSH
57319: LD_VAR 0 3
57323: PPUSH
57324: LD_VAR 0 3
57328: PPUSH
57329: CALL_OW 257
57333: PPUSH
57334: CALL 56110 0 4
// end ;
57338: GO 57187
57340: POP
57341: POP
// end ;
57342: GO 57122
57344: POP
57345: POP
// end ;
57346: LD_VAR 0 1
57350: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
57351: LD_INT 0
57353: PPUSH
57354: PPUSH
57355: PPUSH
57356: PPUSH
57357: PPUSH
57358: PPUSH
// if not mc_bases [ base ] then
57359: LD_EXP 99
57363: PUSH
57364: LD_VAR 0 1
57368: ARRAY
57369: NOT
57370: IFFALSE 57374
// exit ;
57372: GO 57556
// tmp := [ ] ;
57374: LD_ADDR_VAR 0 6
57378: PUSH
57379: EMPTY
57380: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
57381: LD_ADDR_VAR 0 7
57385: PUSH
57386: LD_VAR 0 3
57390: PPUSH
57391: LD_INT 0
57393: PPUSH
57394: CALL_OW 517
57398: ST_TO_ADDR
// if not list then
57399: LD_VAR 0 7
57403: NOT
57404: IFFALSE 57408
// exit ;
57406: GO 57556
// for i = 1 to amount do
57408: LD_ADDR_VAR 0 5
57412: PUSH
57413: DOUBLE
57414: LD_INT 1
57416: DEC
57417: ST_TO_ADDR
57418: LD_VAR 0 2
57422: PUSH
57423: FOR_TO
57424: IFFALSE 57504
// begin x := rand ( 1 , list [ 1 ] ) ;
57426: LD_ADDR_VAR 0 8
57430: PUSH
57431: LD_INT 1
57433: PPUSH
57434: LD_VAR 0 7
57438: PUSH
57439: LD_INT 1
57441: ARRAY
57442: PPUSH
57443: CALL_OW 12
57447: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
57448: LD_ADDR_VAR 0 6
57452: PUSH
57453: LD_VAR 0 6
57457: PPUSH
57458: LD_VAR 0 5
57462: PPUSH
57463: LD_VAR 0 7
57467: PUSH
57468: LD_INT 1
57470: ARRAY
57471: PUSH
57472: LD_VAR 0 8
57476: ARRAY
57477: PUSH
57478: LD_VAR 0 7
57482: PUSH
57483: LD_INT 2
57485: ARRAY
57486: PUSH
57487: LD_VAR 0 8
57491: ARRAY
57492: PUSH
57493: EMPTY
57494: LIST
57495: LIST
57496: PPUSH
57497: CALL_OW 1
57501: ST_TO_ADDR
// end ;
57502: GO 57423
57504: POP
57505: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
57506: LD_ADDR_EXP 112
57510: PUSH
57511: LD_EXP 112
57515: PPUSH
57516: LD_VAR 0 1
57520: PPUSH
57521: LD_VAR 0 6
57525: PPUSH
57526: CALL_OW 1
57530: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
57531: LD_ADDR_EXP 114
57535: PUSH
57536: LD_EXP 114
57540: PPUSH
57541: LD_VAR 0 1
57545: PPUSH
57546: LD_VAR 0 3
57550: PPUSH
57551: CALL_OW 1
57555: ST_TO_ADDR
// end ;
57556: LD_VAR 0 4
57560: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
57561: LD_INT 0
57563: PPUSH
// if not mc_bases [ base ] then
57564: LD_EXP 99
57568: PUSH
57569: LD_VAR 0 1
57573: ARRAY
57574: NOT
57575: IFFALSE 57579
// exit ;
57577: GO 57604
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
57579: LD_ADDR_EXP 104
57583: PUSH
57584: LD_EXP 104
57588: PPUSH
57589: LD_VAR 0 1
57593: PPUSH
57594: LD_VAR 0 2
57598: PPUSH
57599: CALL_OW 1
57603: ST_TO_ADDR
// end ;
57604: LD_VAR 0 3
57608: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
57609: LD_INT 0
57611: PPUSH
// if not mc_bases [ base ] then
57612: LD_EXP 99
57616: PUSH
57617: LD_VAR 0 1
57621: ARRAY
57622: NOT
57623: IFFALSE 57627
// exit ;
57625: GO 57664
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
57627: LD_ADDR_EXP 104
57631: PUSH
57632: LD_EXP 104
57636: PPUSH
57637: LD_VAR 0 1
57641: PPUSH
57642: LD_EXP 104
57646: PUSH
57647: LD_VAR 0 1
57651: ARRAY
57652: PUSH
57653: LD_VAR 0 2
57657: UNION
57658: PPUSH
57659: CALL_OW 1
57663: ST_TO_ADDR
// end ;
57664: LD_VAR 0 3
57668: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
57669: LD_INT 0
57671: PPUSH
// if not mc_bases [ base ] then
57672: LD_EXP 99
57676: PUSH
57677: LD_VAR 0 1
57681: ARRAY
57682: NOT
57683: IFFALSE 57687
// exit ;
57685: GO 57712
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
57687: LD_ADDR_EXP 120
57691: PUSH
57692: LD_EXP 120
57696: PPUSH
57697: LD_VAR 0 1
57701: PPUSH
57702: LD_VAR 0 2
57706: PPUSH
57707: CALL_OW 1
57711: ST_TO_ADDR
// end ;
57712: LD_VAR 0 3
57716: RET
// export function MC_InsertProduceList ( base , components ) ; begin
57717: LD_INT 0
57719: PPUSH
// if not mc_bases [ base ] then
57720: LD_EXP 99
57724: PUSH
57725: LD_VAR 0 1
57729: ARRAY
57730: NOT
57731: IFFALSE 57735
// exit ;
57733: GO 57772
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
57735: LD_ADDR_EXP 120
57739: PUSH
57740: LD_EXP 120
57744: PPUSH
57745: LD_VAR 0 1
57749: PPUSH
57750: LD_EXP 120
57754: PUSH
57755: LD_VAR 0 1
57759: ARRAY
57760: PUSH
57761: LD_VAR 0 2
57765: ADD
57766: PPUSH
57767: CALL_OW 1
57771: ST_TO_ADDR
// end ;
57772: LD_VAR 0 3
57776: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
57777: LD_INT 0
57779: PPUSH
// if not mc_bases [ base ] then
57780: LD_EXP 99
57784: PUSH
57785: LD_VAR 0 1
57789: ARRAY
57790: NOT
57791: IFFALSE 57795
// exit ;
57793: GO 57849
// mc_defender := Replace ( mc_defender , base , deflist ) ;
57795: LD_ADDR_EXP 121
57799: PUSH
57800: LD_EXP 121
57804: PPUSH
57805: LD_VAR 0 1
57809: PPUSH
57810: LD_VAR 0 2
57814: PPUSH
57815: CALL_OW 1
57819: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
57820: LD_ADDR_EXP 110
57824: PUSH
57825: LD_EXP 110
57829: PPUSH
57830: LD_VAR 0 1
57834: PPUSH
57835: LD_VAR 0 2
57839: PUSH
57840: LD_INT 0
57842: PLUS
57843: PPUSH
57844: CALL_OW 1
57848: ST_TO_ADDR
// end ;
57849: LD_VAR 0 3
57853: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
57854: LD_INT 0
57856: PPUSH
// if not mc_bases [ base ] then
57857: LD_EXP 99
57861: PUSH
57862: LD_VAR 0 1
57866: ARRAY
57867: NOT
57868: IFFALSE 57872
// exit ;
57870: GO 57897
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
57872: LD_ADDR_EXP 110
57876: PUSH
57877: LD_EXP 110
57881: PPUSH
57882: LD_VAR 0 1
57886: PPUSH
57887: LD_VAR 0 2
57891: PPUSH
57892: CALL_OW 1
57896: ST_TO_ADDR
// end ;
57897: LD_VAR 0 3
57901: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
57902: LD_INT 0
57904: PPUSH
57905: PPUSH
57906: PPUSH
57907: PPUSH
// if not mc_bases [ base ] then
57908: LD_EXP 99
57912: PUSH
57913: LD_VAR 0 1
57917: ARRAY
57918: NOT
57919: IFFALSE 57923
// exit ;
57921: GO 57988
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
57923: LD_ADDR_EXP 119
57927: PUSH
57928: LD_EXP 119
57932: PPUSH
57933: LD_VAR 0 1
57937: PUSH
57938: LD_EXP 119
57942: PUSH
57943: LD_VAR 0 1
57947: ARRAY
57948: PUSH
57949: LD_INT 1
57951: PLUS
57952: PUSH
57953: EMPTY
57954: LIST
57955: LIST
57956: PPUSH
57957: LD_VAR 0 1
57961: PUSH
57962: LD_VAR 0 2
57966: PUSH
57967: LD_VAR 0 3
57971: PUSH
57972: LD_VAR 0 4
57976: PUSH
57977: EMPTY
57978: LIST
57979: LIST
57980: LIST
57981: LIST
57982: PPUSH
57983: CALL 71209 0 3
57987: ST_TO_ADDR
// end ;
57988: LD_VAR 0 5
57992: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
57993: LD_INT 0
57995: PPUSH
// if not mc_bases [ base ] then
57996: LD_EXP 99
58000: PUSH
58001: LD_VAR 0 1
58005: ARRAY
58006: NOT
58007: IFFALSE 58011
// exit ;
58009: GO 58036
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
58011: LD_ADDR_EXP 136
58015: PUSH
58016: LD_EXP 136
58020: PPUSH
58021: LD_VAR 0 1
58025: PPUSH
58026: LD_VAR 0 2
58030: PPUSH
58031: CALL_OW 1
58035: ST_TO_ADDR
// end ;
58036: LD_VAR 0 3
58040: RET
// export function MC_GetMinesField ( base ) ; begin
58041: LD_INT 0
58043: PPUSH
// result := mc_mines [ base ] ;
58044: LD_ADDR_VAR 0 2
58048: PUSH
58049: LD_EXP 112
58053: PUSH
58054: LD_VAR 0 1
58058: ARRAY
58059: ST_TO_ADDR
// end ;
58060: LD_VAR 0 2
58064: RET
// export function MC_GetProduceList ( base ) ; begin
58065: LD_INT 0
58067: PPUSH
// result := mc_produce [ base ] ;
58068: LD_ADDR_VAR 0 2
58072: PUSH
58073: LD_EXP 120
58077: PUSH
58078: LD_VAR 0 1
58082: ARRAY
58083: ST_TO_ADDR
// end ;
58084: LD_VAR 0 2
58088: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
58089: LD_INT 0
58091: PPUSH
58092: PPUSH
// if not mc_bases then
58093: LD_EXP 99
58097: NOT
58098: IFFALSE 58102
// exit ;
58100: GO 58167
// if mc_bases [ base ] then
58102: LD_EXP 99
58106: PUSH
58107: LD_VAR 0 1
58111: ARRAY
58112: IFFALSE 58167
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58114: LD_ADDR_VAR 0 3
58118: PUSH
58119: LD_EXP 99
58123: PUSH
58124: LD_VAR 0 1
58128: ARRAY
58129: PPUSH
58130: LD_INT 30
58132: PUSH
58133: LD_VAR 0 2
58137: PUSH
58138: EMPTY
58139: LIST
58140: LIST
58141: PPUSH
58142: CALL_OW 72
58146: ST_TO_ADDR
// if result then
58147: LD_VAR 0 3
58151: IFFALSE 58167
// result := result [ 1 ] ;
58153: LD_ADDR_VAR 0 3
58157: PUSH
58158: LD_VAR 0 3
58162: PUSH
58163: LD_INT 1
58165: ARRAY
58166: ST_TO_ADDR
// end ; end ;
58167: LD_VAR 0 3
58171: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
58172: LD_INT 0
58174: PPUSH
58175: PPUSH
// if not mc_bases then
58176: LD_EXP 99
58180: NOT
58181: IFFALSE 58185
// exit ;
58183: GO 58230
// if mc_bases [ base ] then
58185: LD_EXP 99
58189: PUSH
58190: LD_VAR 0 1
58194: ARRAY
58195: IFFALSE 58230
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58197: LD_ADDR_VAR 0 3
58201: PUSH
58202: LD_EXP 99
58206: PUSH
58207: LD_VAR 0 1
58211: ARRAY
58212: PPUSH
58213: LD_INT 30
58215: PUSH
58216: LD_VAR 0 2
58220: PUSH
58221: EMPTY
58222: LIST
58223: LIST
58224: PPUSH
58225: CALL_OW 72
58229: ST_TO_ADDR
// end ;
58230: LD_VAR 0 3
58234: RET
// export function MC_SetTame ( base , area ) ; begin
58235: LD_INT 0
58237: PPUSH
// if not mc_bases or not base then
58238: LD_EXP 99
58242: NOT
58243: PUSH
58244: LD_VAR 0 1
58248: NOT
58249: OR
58250: IFFALSE 58254
// exit ;
58252: GO 58279
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
58254: LD_ADDR_EXP 127
58258: PUSH
58259: LD_EXP 127
58263: PPUSH
58264: LD_VAR 0 1
58268: PPUSH
58269: LD_VAR 0 2
58273: PPUSH
58274: CALL_OW 1
58278: ST_TO_ADDR
// end ;
58279: LD_VAR 0 3
58283: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
58284: LD_INT 0
58286: PPUSH
58287: PPUSH
// if not mc_bases or not base then
58288: LD_EXP 99
58292: NOT
58293: PUSH
58294: LD_VAR 0 1
58298: NOT
58299: OR
58300: IFFALSE 58304
// exit ;
58302: GO 58406
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
58304: LD_ADDR_VAR 0 4
58308: PUSH
58309: LD_EXP 99
58313: PUSH
58314: LD_VAR 0 1
58318: ARRAY
58319: PPUSH
58320: LD_INT 30
58322: PUSH
58323: LD_VAR 0 2
58327: PUSH
58328: EMPTY
58329: LIST
58330: LIST
58331: PPUSH
58332: CALL_OW 72
58336: ST_TO_ADDR
// if not tmp then
58337: LD_VAR 0 4
58341: NOT
58342: IFFALSE 58346
// exit ;
58344: GO 58406
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
58346: LD_ADDR_EXP 131
58350: PUSH
58351: LD_EXP 131
58355: PPUSH
58356: LD_VAR 0 1
58360: PPUSH
58361: LD_EXP 131
58365: PUSH
58366: LD_VAR 0 1
58370: ARRAY
58371: PPUSH
58372: LD_EXP 131
58376: PUSH
58377: LD_VAR 0 1
58381: ARRAY
58382: PUSH
58383: LD_INT 1
58385: PLUS
58386: PPUSH
58387: LD_VAR 0 4
58391: PUSH
58392: LD_INT 1
58394: ARRAY
58395: PPUSH
58396: CALL_OW 2
58400: PPUSH
58401: CALL_OW 1
58405: ST_TO_ADDR
// end ;
58406: LD_VAR 0 3
58410: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
58411: LD_INT 0
58413: PPUSH
58414: PPUSH
// if not mc_bases or not base or not kinds then
58415: LD_EXP 99
58419: NOT
58420: PUSH
58421: LD_VAR 0 1
58425: NOT
58426: OR
58427: PUSH
58428: LD_VAR 0 2
58432: NOT
58433: OR
58434: IFFALSE 58438
// exit ;
58436: GO 58499
// for i in kinds do
58438: LD_ADDR_VAR 0 4
58442: PUSH
58443: LD_VAR 0 2
58447: PUSH
58448: FOR_IN
58449: IFFALSE 58497
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
58451: LD_ADDR_EXP 133
58455: PUSH
58456: LD_EXP 133
58460: PPUSH
58461: LD_VAR 0 1
58465: PUSH
58466: LD_EXP 133
58470: PUSH
58471: LD_VAR 0 1
58475: ARRAY
58476: PUSH
58477: LD_INT 1
58479: PLUS
58480: PUSH
58481: EMPTY
58482: LIST
58483: LIST
58484: PPUSH
58485: LD_VAR 0 4
58489: PPUSH
58490: CALL 71209 0 3
58494: ST_TO_ADDR
58495: GO 58448
58497: POP
58498: POP
// end ;
58499: LD_VAR 0 3
58503: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
58504: LD_INT 0
58506: PPUSH
// if not mc_bases or not base or not areas then
58507: LD_EXP 99
58511: NOT
58512: PUSH
58513: LD_VAR 0 1
58517: NOT
58518: OR
58519: PUSH
58520: LD_VAR 0 2
58524: NOT
58525: OR
58526: IFFALSE 58530
// exit ;
58528: GO 58555
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
58530: LD_ADDR_EXP 117
58534: PUSH
58535: LD_EXP 117
58539: PPUSH
58540: LD_VAR 0 1
58544: PPUSH
58545: LD_VAR 0 2
58549: PPUSH
58550: CALL_OW 1
58554: ST_TO_ADDR
// end ;
58555: LD_VAR 0 3
58559: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
58560: LD_INT 0
58562: PPUSH
// if not mc_bases or not base or not teleports_exit then
58563: LD_EXP 99
58567: NOT
58568: PUSH
58569: LD_VAR 0 1
58573: NOT
58574: OR
58575: PUSH
58576: LD_VAR 0 2
58580: NOT
58581: OR
58582: IFFALSE 58586
// exit ;
58584: GO 58611
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
58586: LD_ADDR_EXP 134
58590: PUSH
58591: LD_EXP 134
58595: PPUSH
58596: LD_VAR 0 1
58600: PPUSH
58601: LD_VAR 0 2
58605: PPUSH
58606: CALL_OW 1
58610: ST_TO_ADDR
// end ;
58611: LD_VAR 0 3
58615: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
58616: LD_INT 0
58618: PPUSH
58619: PPUSH
58620: PPUSH
// if not mc_bases or not base or not ext_list then
58621: LD_EXP 99
58625: NOT
58626: PUSH
58627: LD_VAR 0 1
58631: NOT
58632: OR
58633: PUSH
58634: LD_VAR 0 5
58638: NOT
58639: OR
58640: IFFALSE 58644
// exit ;
58642: GO 58817
// tmp := GetFacExtXYD ( x , y , d ) ;
58644: LD_ADDR_VAR 0 8
58648: PUSH
58649: LD_VAR 0 2
58653: PPUSH
58654: LD_VAR 0 3
58658: PPUSH
58659: LD_VAR 0 4
58663: PPUSH
58664: CALL 104587 0 3
58668: ST_TO_ADDR
// if not tmp then
58669: LD_VAR 0 8
58673: NOT
58674: IFFALSE 58678
// exit ;
58676: GO 58817
// for i in tmp do
58678: LD_ADDR_VAR 0 7
58682: PUSH
58683: LD_VAR 0 8
58687: PUSH
58688: FOR_IN
58689: IFFALSE 58815
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
58691: LD_ADDR_EXP 104
58695: PUSH
58696: LD_EXP 104
58700: PPUSH
58701: LD_VAR 0 1
58705: PPUSH
58706: LD_EXP 104
58710: PUSH
58711: LD_VAR 0 1
58715: ARRAY
58716: PPUSH
58717: LD_EXP 104
58721: PUSH
58722: LD_VAR 0 1
58726: ARRAY
58727: PUSH
58728: LD_INT 1
58730: PLUS
58731: PPUSH
58732: LD_VAR 0 5
58736: PUSH
58737: LD_INT 1
58739: ARRAY
58740: PUSH
58741: LD_VAR 0 7
58745: PUSH
58746: LD_INT 1
58748: ARRAY
58749: PUSH
58750: LD_VAR 0 7
58754: PUSH
58755: LD_INT 2
58757: ARRAY
58758: PUSH
58759: LD_VAR 0 7
58763: PUSH
58764: LD_INT 3
58766: ARRAY
58767: PUSH
58768: EMPTY
58769: LIST
58770: LIST
58771: LIST
58772: LIST
58773: PPUSH
58774: CALL_OW 2
58778: PPUSH
58779: CALL_OW 1
58783: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
58784: LD_ADDR_VAR 0 5
58788: PUSH
58789: LD_VAR 0 5
58793: PPUSH
58794: LD_INT 1
58796: PPUSH
58797: CALL_OW 3
58801: ST_TO_ADDR
// if not ext_list then
58802: LD_VAR 0 5
58806: NOT
58807: IFFALSE 58813
// exit ;
58809: POP
58810: POP
58811: GO 58817
// end ;
58813: GO 58688
58815: POP
58816: POP
// end ;
58817: LD_VAR 0 6
58821: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
58822: LD_INT 0
58824: PPUSH
// if not mc_bases or not base or not weapon_list then
58825: LD_EXP 99
58829: NOT
58830: PUSH
58831: LD_VAR 0 1
58835: NOT
58836: OR
58837: PUSH
58838: LD_VAR 0 2
58842: NOT
58843: OR
58844: IFFALSE 58848
// exit ;
58846: GO 58873
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
58848: LD_ADDR_EXP 138
58852: PUSH
58853: LD_EXP 138
58857: PPUSH
58858: LD_VAR 0 1
58862: PPUSH
58863: LD_VAR 0 2
58867: PPUSH
58868: CALL_OW 1
58872: ST_TO_ADDR
// end ;
58873: LD_VAR 0 3
58877: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
58878: LD_INT 0
58880: PPUSH
// if not mc_bases or not base or not tech_list then
58881: LD_EXP 99
58885: NOT
58886: PUSH
58887: LD_VAR 0 1
58891: NOT
58892: OR
58893: PUSH
58894: LD_VAR 0 2
58898: NOT
58899: OR
58900: IFFALSE 58904
// exit ;
58902: GO 58929
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
58904: LD_ADDR_EXP 126
58908: PUSH
58909: LD_EXP 126
58913: PPUSH
58914: LD_VAR 0 1
58918: PPUSH
58919: LD_VAR 0 2
58923: PPUSH
58924: CALL_OW 1
58928: ST_TO_ADDR
// end ;
58929: LD_VAR 0 3
58933: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
58934: LD_INT 0
58936: PPUSH
// if not mc_bases or not parking_area or not base then
58937: LD_EXP 99
58941: NOT
58942: PUSH
58943: LD_VAR 0 2
58947: NOT
58948: OR
58949: PUSH
58950: LD_VAR 0 1
58954: NOT
58955: OR
58956: IFFALSE 58960
// exit ;
58958: GO 58985
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
58960: LD_ADDR_EXP 123
58964: PUSH
58965: LD_EXP 123
58969: PPUSH
58970: LD_VAR 0 1
58974: PPUSH
58975: LD_VAR 0 2
58979: PPUSH
58980: CALL_OW 1
58984: ST_TO_ADDR
// end ;
58985: LD_VAR 0 3
58989: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
58990: LD_INT 0
58992: PPUSH
// if not mc_bases or not base or not scan_area then
58993: LD_EXP 99
58997: NOT
58998: PUSH
58999: LD_VAR 0 1
59003: NOT
59004: OR
59005: PUSH
59006: LD_VAR 0 2
59010: NOT
59011: OR
59012: IFFALSE 59016
// exit ;
59014: GO 59041
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
59016: LD_ADDR_EXP 124
59020: PUSH
59021: LD_EXP 124
59025: PPUSH
59026: LD_VAR 0 1
59030: PPUSH
59031: LD_VAR 0 2
59035: PPUSH
59036: CALL_OW 1
59040: ST_TO_ADDR
// end ;
59041: LD_VAR 0 3
59045: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
59046: LD_INT 0
59048: PPUSH
59049: PPUSH
// if not mc_bases or not base then
59050: LD_EXP 99
59054: NOT
59055: PUSH
59056: LD_VAR 0 1
59060: NOT
59061: OR
59062: IFFALSE 59066
// exit ;
59064: GO 59130
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
59066: LD_ADDR_VAR 0 3
59070: PUSH
59071: LD_INT 1
59073: PUSH
59074: LD_INT 2
59076: PUSH
59077: LD_INT 3
59079: PUSH
59080: LD_INT 4
59082: PUSH
59083: LD_INT 11
59085: PUSH
59086: EMPTY
59087: LIST
59088: LIST
59089: LIST
59090: LIST
59091: LIST
59092: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
59093: LD_ADDR_EXP 126
59097: PUSH
59098: LD_EXP 126
59102: PPUSH
59103: LD_VAR 0 1
59107: PPUSH
59108: LD_EXP 126
59112: PUSH
59113: LD_VAR 0 1
59117: ARRAY
59118: PUSH
59119: LD_VAR 0 3
59123: DIFF
59124: PPUSH
59125: CALL_OW 1
59129: ST_TO_ADDR
// end ;
59130: LD_VAR 0 2
59134: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
59135: LD_INT 0
59137: PPUSH
// result := mc_vehicles [ base ] ;
59138: LD_ADDR_VAR 0 3
59142: PUSH
59143: LD_EXP 118
59147: PUSH
59148: LD_VAR 0 1
59152: ARRAY
59153: ST_TO_ADDR
// if onlyCombat then
59154: LD_VAR 0 2
59158: IFFALSE 59323
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
59160: LD_ADDR_VAR 0 3
59164: PUSH
59165: LD_VAR 0 3
59169: PUSH
59170: LD_VAR 0 3
59174: PPUSH
59175: LD_INT 2
59177: PUSH
59178: LD_INT 34
59180: PUSH
59181: LD_INT 12
59183: PUSH
59184: EMPTY
59185: LIST
59186: LIST
59187: PUSH
59188: LD_INT 34
59190: PUSH
59191: LD_INT 51
59193: PUSH
59194: EMPTY
59195: LIST
59196: LIST
59197: PUSH
59198: LD_INT 34
59200: PUSH
59201: LD_EXP 93
59205: PUSH
59206: EMPTY
59207: LIST
59208: LIST
59209: PUSH
59210: LD_INT 34
59212: PUSH
59213: LD_INT 32
59215: PUSH
59216: EMPTY
59217: LIST
59218: LIST
59219: PUSH
59220: LD_INT 34
59222: PUSH
59223: LD_INT 13
59225: PUSH
59226: EMPTY
59227: LIST
59228: LIST
59229: PUSH
59230: LD_INT 34
59232: PUSH
59233: LD_INT 52
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: PUSH
59240: LD_INT 34
59242: PUSH
59243: LD_INT 14
59245: PUSH
59246: EMPTY
59247: LIST
59248: LIST
59249: PUSH
59250: LD_INT 34
59252: PUSH
59253: LD_INT 53
59255: PUSH
59256: EMPTY
59257: LIST
59258: LIST
59259: PUSH
59260: LD_INT 34
59262: PUSH
59263: LD_EXP 92
59267: PUSH
59268: EMPTY
59269: LIST
59270: LIST
59271: PUSH
59272: LD_INT 34
59274: PUSH
59275: LD_INT 31
59277: PUSH
59278: EMPTY
59279: LIST
59280: LIST
59281: PUSH
59282: LD_INT 34
59284: PUSH
59285: LD_INT 48
59287: PUSH
59288: EMPTY
59289: LIST
59290: LIST
59291: PUSH
59292: LD_INT 34
59294: PUSH
59295: LD_INT 8
59297: PUSH
59298: EMPTY
59299: LIST
59300: LIST
59301: PUSH
59302: EMPTY
59303: LIST
59304: LIST
59305: LIST
59306: LIST
59307: LIST
59308: LIST
59309: LIST
59310: LIST
59311: LIST
59312: LIST
59313: LIST
59314: LIST
59315: LIST
59316: PPUSH
59317: CALL_OW 72
59321: DIFF
59322: ST_TO_ADDR
// end ; end_of_file
59323: LD_VAR 0 3
59327: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
59328: LD_INT 0
59330: PPUSH
59331: PPUSH
59332: PPUSH
// if not mc_bases or not skirmish then
59333: LD_EXP 99
59337: NOT
59338: PUSH
59339: LD_EXP 97
59343: NOT
59344: OR
59345: IFFALSE 59349
// exit ;
59347: GO 59514
// for i = 1 to mc_bases do
59349: LD_ADDR_VAR 0 4
59353: PUSH
59354: DOUBLE
59355: LD_INT 1
59357: DEC
59358: ST_TO_ADDR
59359: LD_EXP 99
59363: PUSH
59364: FOR_TO
59365: IFFALSE 59512
// begin if sci in mc_bases [ i ] then
59367: LD_VAR 0 2
59371: PUSH
59372: LD_EXP 99
59376: PUSH
59377: LD_VAR 0 4
59381: ARRAY
59382: IN
59383: IFFALSE 59510
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
59385: LD_ADDR_EXP 128
59389: PUSH
59390: LD_EXP 128
59394: PPUSH
59395: LD_VAR 0 4
59399: PUSH
59400: LD_EXP 128
59404: PUSH
59405: LD_VAR 0 4
59409: ARRAY
59410: PUSH
59411: LD_INT 1
59413: PLUS
59414: PUSH
59415: EMPTY
59416: LIST
59417: LIST
59418: PPUSH
59419: LD_VAR 0 1
59423: PPUSH
59424: CALL 71209 0 3
59428: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
59429: LD_ADDR_VAR 0 5
59433: PUSH
59434: LD_EXP 99
59438: PUSH
59439: LD_VAR 0 4
59443: ARRAY
59444: PPUSH
59445: LD_INT 2
59447: PUSH
59448: LD_INT 30
59450: PUSH
59451: LD_INT 0
59453: PUSH
59454: EMPTY
59455: LIST
59456: LIST
59457: PUSH
59458: LD_INT 30
59460: PUSH
59461: LD_INT 1
59463: PUSH
59464: EMPTY
59465: LIST
59466: LIST
59467: PUSH
59468: EMPTY
59469: LIST
59470: LIST
59471: LIST
59472: PPUSH
59473: CALL_OW 72
59477: PPUSH
59478: LD_VAR 0 1
59482: PPUSH
59483: CALL_OW 74
59487: ST_TO_ADDR
// if tmp then
59488: LD_VAR 0 5
59492: IFFALSE 59508
// ComStandNearbyBuilding ( ape , tmp ) ;
59494: LD_VAR 0 1
59498: PPUSH
59499: LD_VAR 0 5
59503: PPUSH
59504: CALL 65501 0 2
// break ;
59508: GO 59512
// end ; end ;
59510: GO 59364
59512: POP
59513: POP
// end ;
59514: LD_VAR 0 3
59518: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
59519: LD_INT 0
59521: PPUSH
59522: PPUSH
59523: PPUSH
// if not mc_bases or not skirmish then
59524: LD_EXP 99
59528: NOT
59529: PUSH
59530: LD_EXP 97
59534: NOT
59535: OR
59536: IFFALSE 59540
// exit ;
59538: GO 59629
// for i = 1 to mc_bases do
59540: LD_ADDR_VAR 0 4
59544: PUSH
59545: DOUBLE
59546: LD_INT 1
59548: DEC
59549: ST_TO_ADDR
59550: LD_EXP 99
59554: PUSH
59555: FOR_TO
59556: IFFALSE 59627
// begin if building in mc_busy_turret_list [ i ] then
59558: LD_VAR 0 1
59562: PUSH
59563: LD_EXP 109
59567: PUSH
59568: LD_VAR 0 4
59572: ARRAY
59573: IN
59574: IFFALSE 59625
// begin tmp := mc_busy_turret_list [ i ] diff building ;
59576: LD_ADDR_VAR 0 5
59580: PUSH
59581: LD_EXP 109
59585: PUSH
59586: LD_VAR 0 4
59590: ARRAY
59591: PUSH
59592: LD_VAR 0 1
59596: DIFF
59597: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
59598: LD_ADDR_EXP 109
59602: PUSH
59603: LD_EXP 109
59607: PPUSH
59608: LD_VAR 0 4
59612: PPUSH
59613: LD_VAR 0 5
59617: PPUSH
59618: CALL_OW 1
59622: ST_TO_ADDR
// break ;
59623: GO 59627
// end ; end ;
59625: GO 59555
59627: POP
59628: POP
// end ;
59629: LD_VAR 0 3
59633: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
59634: LD_INT 0
59636: PPUSH
59637: PPUSH
59638: PPUSH
// if not mc_bases or not skirmish then
59639: LD_EXP 99
59643: NOT
59644: PUSH
59645: LD_EXP 97
59649: NOT
59650: OR
59651: IFFALSE 59655
// exit ;
59653: GO 59854
// for i = 1 to mc_bases do
59655: LD_ADDR_VAR 0 5
59659: PUSH
59660: DOUBLE
59661: LD_INT 1
59663: DEC
59664: ST_TO_ADDR
59665: LD_EXP 99
59669: PUSH
59670: FOR_TO
59671: IFFALSE 59852
// if building in mc_bases [ i ] then
59673: LD_VAR 0 1
59677: PUSH
59678: LD_EXP 99
59682: PUSH
59683: LD_VAR 0 5
59687: ARRAY
59688: IN
59689: IFFALSE 59850
// begin tmp := mc_bases [ i ] diff building ;
59691: LD_ADDR_VAR 0 6
59695: PUSH
59696: LD_EXP 99
59700: PUSH
59701: LD_VAR 0 5
59705: ARRAY
59706: PUSH
59707: LD_VAR 0 1
59711: DIFF
59712: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
59713: LD_ADDR_EXP 99
59717: PUSH
59718: LD_EXP 99
59722: PPUSH
59723: LD_VAR 0 5
59727: PPUSH
59728: LD_VAR 0 6
59732: PPUSH
59733: CALL_OW 1
59737: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
59738: LD_VAR 0 1
59742: PUSH
59743: LD_EXP 107
59747: PUSH
59748: LD_VAR 0 5
59752: ARRAY
59753: IN
59754: IFFALSE 59793
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
59756: LD_ADDR_EXP 107
59760: PUSH
59761: LD_EXP 107
59765: PPUSH
59766: LD_VAR 0 5
59770: PPUSH
59771: LD_EXP 107
59775: PUSH
59776: LD_VAR 0 5
59780: ARRAY
59781: PUSH
59782: LD_VAR 0 1
59786: DIFF
59787: PPUSH
59788: CALL_OW 1
59792: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
59793: LD_VAR 0 1
59797: PUSH
59798: LD_EXP 108
59802: PUSH
59803: LD_VAR 0 5
59807: ARRAY
59808: IN
59809: IFFALSE 59848
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
59811: LD_ADDR_EXP 108
59815: PUSH
59816: LD_EXP 108
59820: PPUSH
59821: LD_VAR 0 5
59825: PPUSH
59826: LD_EXP 108
59830: PUSH
59831: LD_VAR 0 5
59835: ARRAY
59836: PUSH
59837: LD_VAR 0 1
59841: DIFF
59842: PPUSH
59843: CALL_OW 1
59847: ST_TO_ADDR
// break ;
59848: GO 59852
// end ;
59850: GO 59670
59852: POP
59853: POP
// end ;
59854: LD_VAR 0 4
59858: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
59859: LD_INT 0
59861: PPUSH
59862: PPUSH
59863: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
59864: LD_EXP 99
59868: NOT
59869: PUSH
59870: LD_EXP 97
59874: NOT
59875: OR
59876: PUSH
59877: LD_VAR 0 3
59881: PUSH
59882: LD_EXP 125
59886: IN
59887: NOT
59888: OR
59889: IFFALSE 59893
// exit ;
59891: GO 60016
// for i = 1 to mc_vehicles do
59893: LD_ADDR_VAR 0 6
59897: PUSH
59898: DOUBLE
59899: LD_INT 1
59901: DEC
59902: ST_TO_ADDR
59903: LD_EXP 118
59907: PUSH
59908: FOR_TO
59909: IFFALSE 60014
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
59911: LD_VAR 0 2
59915: PUSH
59916: LD_EXP 118
59920: PUSH
59921: LD_VAR 0 6
59925: ARRAY
59926: IN
59927: PUSH
59928: LD_VAR 0 1
59932: PUSH
59933: LD_EXP 118
59937: PUSH
59938: LD_VAR 0 6
59942: ARRAY
59943: IN
59944: OR
59945: IFFALSE 60012
// begin tmp := mc_vehicles [ i ] diff old ;
59947: LD_ADDR_VAR 0 7
59951: PUSH
59952: LD_EXP 118
59956: PUSH
59957: LD_VAR 0 6
59961: ARRAY
59962: PUSH
59963: LD_VAR 0 2
59967: DIFF
59968: ST_TO_ADDR
// tmp := tmp diff new ;
59969: LD_ADDR_VAR 0 7
59973: PUSH
59974: LD_VAR 0 7
59978: PUSH
59979: LD_VAR 0 1
59983: DIFF
59984: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
59985: LD_ADDR_EXP 118
59989: PUSH
59990: LD_EXP 118
59994: PPUSH
59995: LD_VAR 0 6
59999: PPUSH
60000: LD_VAR 0 7
60004: PPUSH
60005: CALL_OW 1
60009: ST_TO_ADDR
// break ;
60010: GO 60014
// end ;
60012: GO 59908
60014: POP
60015: POP
// end ;
60016: LD_VAR 0 5
60020: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
60021: LD_INT 0
60023: PPUSH
60024: PPUSH
60025: PPUSH
60026: PPUSH
// if not mc_bases or not skirmish then
60027: LD_EXP 99
60031: NOT
60032: PUSH
60033: LD_EXP 97
60037: NOT
60038: OR
60039: IFFALSE 60043
// exit ;
60041: GO 60420
// side := GetSide ( vehicle ) ;
60043: LD_ADDR_VAR 0 5
60047: PUSH
60048: LD_VAR 0 1
60052: PPUSH
60053: CALL_OW 255
60057: ST_TO_ADDR
// for i = 1 to mc_bases do
60058: LD_ADDR_VAR 0 4
60062: PUSH
60063: DOUBLE
60064: LD_INT 1
60066: DEC
60067: ST_TO_ADDR
60068: LD_EXP 99
60072: PUSH
60073: FOR_TO
60074: IFFALSE 60418
// begin if factory in mc_bases [ i ] then
60076: LD_VAR 0 2
60080: PUSH
60081: LD_EXP 99
60085: PUSH
60086: LD_VAR 0 4
60090: ARRAY
60091: IN
60092: IFFALSE 60416
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
60094: LD_EXP 121
60098: PUSH
60099: LD_VAR 0 4
60103: ARRAY
60104: PUSH
60105: LD_EXP 110
60109: PUSH
60110: LD_VAR 0 4
60114: ARRAY
60115: LESS
60116: PUSH
60117: LD_VAR 0 1
60121: PPUSH
60122: CALL_OW 264
60126: PUSH
60127: LD_INT 31
60129: PUSH
60130: LD_INT 32
60132: PUSH
60133: LD_INT 51
60135: PUSH
60136: LD_EXP 93
60140: PUSH
60141: LD_INT 12
60143: PUSH
60144: LD_INT 30
60146: PUSH
60147: LD_EXP 92
60151: PUSH
60152: LD_INT 11
60154: PUSH
60155: LD_INT 53
60157: PUSH
60158: LD_INT 14
60160: PUSH
60161: LD_EXP 96
60165: PUSH
60166: LD_INT 29
60168: PUSH
60169: LD_EXP 94
60173: PUSH
60174: LD_INT 13
60176: PUSH
60177: LD_INT 52
60179: PUSH
60180: LD_INT 48
60182: PUSH
60183: LD_INT 8
60185: PUSH
60186: EMPTY
60187: LIST
60188: LIST
60189: LIST
60190: LIST
60191: LIST
60192: LIST
60193: LIST
60194: LIST
60195: LIST
60196: LIST
60197: LIST
60198: LIST
60199: LIST
60200: LIST
60201: LIST
60202: LIST
60203: LIST
60204: IN
60205: NOT
60206: AND
60207: IFFALSE 60255
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
60209: LD_ADDR_EXP 121
60213: PUSH
60214: LD_EXP 121
60218: PPUSH
60219: LD_VAR 0 4
60223: PUSH
60224: LD_EXP 121
60228: PUSH
60229: LD_VAR 0 4
60233: ARRAY
60234: PUSH
60235: LD_INT 1
60237: PLUS
60238: PUSH
60239: EMPTY
60240: LIST
60241: LIST
60242: PPUSH
60243: LD_VAR 0 1
60247: PPUSH
60248: CALL 71209 0 3
60252: ST_TO_ADDR
60253: GO 60299
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
60255: LD_ADDR_EXP 118
60259: PUSH
60260: LD_EXP 118
60264: PPUSH
60265: LD_VAR 0 4
60269: PUSH
60270: LD_EXP 118
60274: PUSH
60275: LD_VAR 0 4
60279: ARRAY
60280: PUSH
60281: LD_INT 1
60283: PLUS
60284: PUSH
60285: EMPTY
60286: LIST
60287: LIST
60288: PPUSH
60289: LD_VAR 0 1
60293: PPUSH
60294: CALL 71209 0 3
60298: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
60299: LD_VAR 0 1
60303: PPUSH
60304: CALL_OW 263
60308: PUSH
60309: LD_INT 2
60311: EQUAL
60312: IFFALSE 60332
// begin repeat wait ( 0 0$1 ) ;
60314: LD_INT 35
60316: PPUSH
60317: CALL_OW 67
// until IsControledBy ( vehicle ) ;
60321: LD_VAR 0 1
60325: PPUSH
60326: CALL_OW 312
60330: IFFALSE 60314
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
60332: LD_VAR 0 1
60336: PPUSH
60337: LD_EXP 123
60341: PUSH
60342: LD_VAR 0 4
60346: ARRAY
60347: PPUSH
60348: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
60352: LD_VAR 0 1
60356: PPUSH
60357: CALL_OW 263
60361: PUSH
60362: LD_INT 1
60364: NONEQUAL
60365: IFFALSE 60369
// break ;
60367: GO 60418
// repeat wait ( 0 0$1 ) ;
60369: LD_INT 35
60371: PPUSH
60372: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
60376: LD_VAR 0 1
60380: PPUSH
60381: LD_EXP 123
60385: PUSH
60386: LD_VAR 0 4
60390: ARRAY
60391: PPUSH
60392: CALL_OW 308
60396: IFFALSE 60369
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
60398: LD_VAR 0 1
60402: PPUSH
60403: CALL_OW 311
60407: PPUSH
60408: CALL_OW 121
// exit ;
60412: POP
60413: POP
60414: GO 60420
// end ; end ;
60416: GO 60073
60418: POP
60419: POP
// end ;
60420: LD_VAR 0 3
60424: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
60425: LD_INT 0
60427: PPUSH
60428: PPUSH
60429: PPUSH
60430: PPUSH
// if not mc_bases or not skirmish then
60431: LD_EXP 99
60435: NOT
60436: PUSH
60437: LD_EXP 97
60441: NOT
60442: OR
60443: IFFALSE 60447
// exit ;
60445: GO 60800
// repeat wait ( 0 0$1 ) ;
60447: LD_INT 35
60449: PPUSH
60450: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
60454: LD_VAR 0 2
60458: PPUSH
60459: LD_VAR 0 3
60463: PPUSH
60464: CALL_OW 284
60468: IFFALSE 60447
// if GetResourceTypeXY ( x , y ) = mat_artefact then
60470: LD_VAR 0 2
60474: PPUSH
60475: LD_VAR 0 3
60479: PPUSH
60480: CALL_OW 283
60484: PUSH
60485: LD_INT 4
60487: EQUAL
60488: IFFALSE 60492
// exit ;
60490: GO 60800
// for i = 1 to mc_bases do
60492: LD_ADDR_VAR 0 7
60496: PUSH
60497: DOUBLE
60498: LD_INT 1
60500: DEC
60501: ST_TO_ADDR
60502: LD_EXP 99
60506: PUSH
60507: FOR_TO
60508: IFFALSE 60798
// begin if mc_crates_area [ i ] then
60510: LD_EXP 117
60514: PUSH
60515: LD_VAR 0 7
60519: ARRAY
60520: IFFALSE 60631
// for j in mc_crates_area [ i ] do
60522: LD_ADDR_VAR 0 8
60526: PUSH
60527: LD_EXP 117
60531: PUSH
60532: LD_VAR 0 7
60536: ARRAY
60537: PUSH
60538: FOR_IN
60539: IFFALSE 60629
// if InArea ( x , y , j ) then
60541: LD_VAR 0 2
60545: PPUSH
60546: LD_VAR 0 3
60550: PPUSH
60551: LD_VAR 0 8
60555: PPUSH
60556: CALL_OW 309
60560: IFFALSE 60627
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60562: LD_ADDR_EXP 115
60566: PUSH
60567: LD_EXP 115
60571: PPUSH
60572: LD_VAR 0 7
60576: PUSH
60577: LD_EXP 115
60581: PUSH
60582: LD_VAR 0 7
60586: ARRAY
60587: PUSH
60588: LD_INT 1
60590: PLUS
60591: PUSH
60592: EMPTY
60593: LIST
60594: LIST
60595: PPUSH
60596: LD_VAR 0 4
60600: PUSH
60601: LD_VAR 0 2
60605: PUSH
60606: LD_VAR 0 3
60610: PUSH
60611: EMPTY
60612: LIST
60613: LIST
60614: LIST
60615: PPUSH
60616: CALL 71209 0 3
60620: ST_TO_ADDR
// exit ;
60621: POP
60622: POP
60623: POP
60624: POP
60625: GO 60800
// end ;
60627: GO 60538
60629: POP
60630: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60631: LD_ADDR_VAR 0 9
60635: PUSH
60636: LD_EXP 99
60640: PUSH
60641: LD_VAR 0 7
60645: ARRAY
60646: PPUSH
60647: LD_INT 2
60649: PUSH
60650: LD_INT 30
60652: PUSH
60653: LD_INT 0
60655: PUSH
60656: EMPTY
60657: LIST
60658: LIST
60659: PUSH
60660: LD_INT 30
60662: PUSH
60663: LD_INT 1
60665: PUSH
60666: EMPTY
60667: LIST
60668: LIST
60669: PUSH
60670: EMPTY
60671: LIST
60672: LIST
60673: LIST
60674: PPUSH
60675: CALL_OW 72
60679: ST_TO_ADDR
// if not depot then
60680: LD_VAR 0 9
60684: NOT
60685: IFFALSE 60689
// continue ;
60687: GO 60507
// for j in depot do
60689: LD_ADDR_VAR 0 8
60693: PUSH
60694: LD_VAR 0 9
60698: PUSH
60699: FOR_IN
60700: IFFALSE 60794
// if GetDistUnitXY ( j , x , y ) < 30 then
60702: LD_VAR 0 8
60706: PPUSH
60707: LD_VAR 0 2
60711: PPUSH
60712: LD_VAR 0 3
60716: PPUSH
60717: CALL_OW 297
60721: PUSH
60722: LD_INT 30
60724: LESS
60725: IFFALSE 60792
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
60727: LD_ADDR_EXP 115
60731: PUSH
60732: LD_EXP 115
60736: PPUSH
60737: LD_VAR 0 7
60741: PUSH
60742: LD_EXP 115
60746: PUSH
60747: LD_VAR 0 7
60751: ARRAY
60752: PUSH
60753: LD_INT 1
60755: PLUS
60756: PUSH
60757: EMPTY
60758: LIST
60759: LIST
60760: PPUSH
60761: LD_VAR 0 4
60765: PUSH
60766: LD_VAR 0 2
60770: PUSH
60771: LD_VAR 0 3
60775: PUSH
60776: EMPTY
60777: LIST
60778: LIST
60779: LIST
60780: PPUSH
60781: CALL 71209 0 3
60785: ST_TO_ADDR
// exit ;
60786: POP
60787: POP
60788: POP
60789: POP
60790: GO 60800
// end ;
60792: GO 60699
60794: POP
60795: POP
// end ;
60796: GO 60507
60798: POP
60799: POP
// end ;
60800: LD_VAR 0 6
60804: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
60805: LD_INT 0
60807: PPUSH
60808: PPUSH
60809: PPUSH
60810: PPUSH
// if not mc_bases or not skirmish then
60811: LD_EXP 99
60815: NOT
60816: PUSH
60817: LD_EXP 97
60821: NOT
60822: OR
60823: IFFALSE 60827
// exit ;
60825: GO 61104
// side := GetSide ( lab ) ;
60827: LD_ADDR_VAR 0 4
60831: PUSH
60832: LD_VAR 0 2
60836: PPUSH
60837: CALL_OW 255
60841: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
60842: LD_VAR 0 4
60846: PUSH
60847: LD_EXP 125
60851: IN
60852: NOT
60853: PUSH
60854: LD_EXP 126
60858: NOT
60859: OR
60860: PUSH
60861: LD_EXP 99
60865: NOT
60866: OR
60867: IFFALSE 60871
// exit ;
60869: GO 61104
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
60871: LD_ADDR_EXP 126
60875: PUSH
60876: LD_EXP 126
60880: PPUSH
60881: LD_VAR 0 4
60885: PPUSH
60886: LD_EXP 126
60890: PUSH
60891: LD_VAR 0 4
60895: ARRAY
60896: PUSH
60897: LD_VAR 0 1
60901: DIFF
60902: PPUSH
60903: CALL_OW 1
60907: ST_TO_ADDR
// for i = 1 to mc_bases do
60908: LD_ADDR_VAR 0 5
60912: PUSH
60913: DOUBLE
60914: LD_INT 1
60916: DEC
60917: ST_TO_ADDR
60918: LD_EXP 99
60922: PUSH
60923: FOR_TO
60924: IFFALSE 61102
// begin if lab in mc_bases [ i ] then
60926: LD_VAR 0 2
60930: PUSH
60931: LD_EXP 99
60935: PUSH
60936: LD_VAR 0 5
60940: ARRAY
60941: IN
60942: IFFALSE 61100
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
60944: LD_VAR 0 1
60948: PUSH
60949: LD_INT 11
60951: PUSH
60952: LD_INT 4
60954: PUSH
60955: LD_INT 3
60957: PUSH
60958: LD_INT 2
60960: PUSH
60961: EMPTY
60962: LIST
60963: LIST
60964: LIST
60965: LIST
60966: IN
60967: PUSH
60968: LD_EXP 129
60972: PUSH
60973: LD_VAR 0 5
60977: ARRAY
60978: AND
60979: IFFALSE 61100
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
60981: LD_ADDR_VAR 0 6
60985: PUSH
60986: LD_EXP 129
60990: PUSH
60991: LD_VAR 0 5
60995: ARRAY
60996: PUSH
60997: LD_INT 1
60999: ARRAY
61000: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61001: LD_ADDR_EXP 129
61005: PUSH
61006: LD_EXP 129
61010: PPUSH
61011: LD_VAR 0 5
61015: PPUSH
61016: EMPTY
61017: PPUSH
61018: CALL_OW 1
61022: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
61023: LD_VAR 0 6
61027: PPUSH
61028: LD_INT 0
61030: PPUSH
61031: CALL_OW 109
// ComExitBuilding ( tmp ) ;
61035: LD_VAR 0 6
61039: PPUSH
61040: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
61044: LD_ADDR_EXP 128
61048: PUSH
61049: LD_EXP 128
61053: PPUSH
61054: LD_VAR 0 5
61058: PPUSH
61059: LD_EXP 128
61063: PUSH
61064: LD_VAR 0 5
61068: ARRAY
61069: PPUSH
61070: LD_INT 1
61072: PPUSH
61073: LD_VAR 0 6
61077: PPUSH
61078: CALL_OW 2
61082: PPUSH
61083: CALL_OW 1
61087: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
61088: LD_VAR 0 5
61092: PPUSH
61093: LD_INT 112
61095: PPUSH
61096: CALL 37996 0 2
// end ; end ; end ;
61100: GO 60923
61102: POP
61103: POP
// end ;
61104: LD_VAR 0 3
61108: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
61109: LD_INT 0
61111: PPUSH
61112: PPUSH
61113: PPUSH
61114: PPUSH
61115: PPUSH
61116: PPUSH
61117: PPUSH
61118: PPUSH
// if not mc_bases or not skirmish then
61119: LD_EXP 99
61123: NOT
61124: PUSH
61125: LD_EXP 97
61129: NOT
61130: OR
61131: IFFALSE 61135
// exit ;
61133: GO 62506
// for i = 1 to mc_bases do
61135: LD_ADDR_VAR 0 3
61139: PUSH
61140: DOUBLE
61141: LD_INT 1
61143: DEC
61144: ST_TO_ADDR
61145: LD_EXP 99
61149: PUSH
61150: FOR_TO
61151: IFFALSE 62504
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
61153: LD_VAR 0 1
61157: PUSH
61158: LD_EXP 99
61162: PUSH
61163: LD_VAR 0 3
61167: ARRAY
61168: IN
61169: PUSH
61170: LD_VAR 0 1
61174: PUSH
61175: LD_EXP 106
61179: PUSH
61180: LD_VAR 0 3
61184: ARRAY
61185: IN
61186: OR
61187: PUSH
61188: LD_VAR 0 1
61192: PUSH
61193: LD_EXP 121
61197: PUSH
61198: LD_VAR 0 3
61202: ARRAY
61203: IN
61204: OR
61205: PUSH
61206: LD_VAR 0 1
61210: PUSH
61211: LD_EXP 118
61215: PUSH
61216: LD_VAR 0 3
61220: ARRAY
61221: IN
61222: OR
61223: PUSH
61224: LD_VAR 0 1
61228: PUSH
61229: LD_EXP 128
61233: PUSH
61234: LD_VAR 0 3
61238: ARRAY
61239: IN
61240: OR
61241: PUSH
61242: LD_VAR 0 1
61246: PUSH
61247: LD_EXP 129
61251: PUSH
61252: LD_VAR 0 3
61256: ARRAY
61257: IN
61258: OR
61259: IFFALSE 62502
// begin if un in mc_ape [ i ] then
61261: LD_VAR 0 1
61265: PUSH
61266: LD_EXP 128
61270: PUSH
61271: LD_VAR 0 3
61275: ARRAY
61276: IN
61277: IFFALSE 61316
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
61279: LD_ADDR_EXP 128
61283: PUSH
61284: LD_EXP 128
61288: PPUSH
61289: LD_VAR 0 3
61293: PPUSH
61294: LD_EXP 128
61298: PUSH
61299: LD_VAR 0 3
61303: ARRAY
61304: PUSH
61305: LD_VAR 0 1
61309: DIFF
61310: PPUSH
61311: CALL_OW 1
61315: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
61316: LD_VAR 0 1
61320: PUSH
61321: LD_EXP 129
61325: PUSH
61326: LD_VAR 0 3
61330: ARRAY
61331: IN
61332: IFFALSE 61356
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
61334: LD_ADDR_EXP 129
61338: PUSH
61339: LD_EXP 129
61343: PPUSH
61344: LD_VAR 0 3
61348: PPUSH
61349: EMPTY
61350: PPUSH
61351: CALL_OW 1
61355: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
61356: LD_VAR 0 1
61360: PPUSH
61361: CALL_OW 247
61365: PUSH
61366: LD_INT 2
61368: EQUAL
61369: PUSH
61370: LD_VAR 0 1
61374: PPUSH
61375: CALL_OW 110
61379: PUSH
61380: LD_INT 20
61382: EQUAL
61383: PUSH
61384: LD_VAR 0 1
61388: PUSH
61389: LD_EXP 121
61393: PUSH
61394: LD_VAR 0 3
61398: ARRAY
61399: IN
61400: OR
61401: PUSH
61402: LD_VAR 0 1
61406: PPUSH
61407: CALL_OW 264
61411: PUSH
61412: LD_INT 12
61414: PUSH
61415: LD_INT 51
61417: PUSH
61418: LD_EXP 93
61422: PUSH
61423: LD_INT 32
61425: PUSH
61426: LD_INT 13
61428: PUSH
61429: LD_INT 52
61431: PUSH
61432: LD_INT 31
61434: PUSH
61435: EMPTY
61436: LIST
61437: LIST
61438: LIST
61439: LIST
61440: LIST
61441: LIST
61442: LIST
61443: IN
61444: OR
61445: AND
61446: IFFALSE 61754
// begin if un in mc_defender [ i ] then
61448: LD_VAR 0 1
61452: PUSH
61453: LD_EXP 121
61457: PUSH
61458: LD_VAR 0 3
61462: ARRAY
61463: IN
61464: IFFALSE 61503
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
61466: LD_ADDR_EXP 121
61470: PUSH
61471: LD_EXP 121
61475: PPUSH
61476: LD_VAR 0 3
61480: PPUSH
61481: LD_EXP 121
61485: PUSH
61486: LD_VAR 0 3
61490: ARRAY
61491: PUSH
61492: LD_VAR 0 1
61496: DIFF
61497: PPUSH
61498: CALL_OW 1
61502: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
61503: LD_ADDR_VAR 0 8
61507: PUSH
61508: LD_VAR 0 3
61512: PPUSH
61513: LD_INT 3
61515: PPUSH
61516: CALL 58172 0 2
61520: ST_TO_ADDR
// if fac then
61521: LD_VAR 0 8
61525: IFFALSE 61754
// begin for j in fac do
61527: LD_ADDR_VAR 0 4
61531: PUSH
61532: LD_VAR 0 8
61536: PUSH
61537: FOR_IN
61538: IFFALSE 61752
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
61540: LD_ADDR_VAR 0 9
61544: PUSH
61545: LD_VAR 0 8
61549: PPUSH
61550: LD_VAR 0 1
61554: PPUSH
61555: CALL_OW 265
61559: PPUSH
61560: LD_VAR 0 1
61564: PPUSH
61565: CALL_OW 262
61569: PPUSH
61570: LD_VAR 0 1
61574: PPUSH
61575: CALL_OW 263
61579: PPUSH
61580: LD_VAR 0 1
61584: PPUSH
61585: CALL_OW 264
61589: PPUSH
61590: CALL 68741 0 5
61594: ST_TO_ADDR
// if components then
61595: LD_VAR 0 9
61599: IFFALSE 61750
// begin if GetWeapon ( un ) = ar_control_tower then
61601: LD_VAR 0 1
61605: PPUSH
61606: CALL_OW 264
61610: PUSH
61611: LD_INT 31
61613: EQUAL
61614: IFFALSE 61731
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
61616: LD_VAR 0 1
61620: PPUSH
61621: CALL_OW 311
61625: PPUSH
61626: LD_INT 0
61628: PPUSH
61629: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
61633: LD_ADDR_EXP 139
61637: PUSH
61638: LD_EXP 139
61642: PPUSH
61643: LD_VAR 0 3
61647: PPUSH
61648: LD_EXP 139
61652: PUSH
61653: LD_VAR 0 3
61657: ARRAY
61658: PUSH
61659: LD_VAR 0 1
61663: PPUSH
61664: CALL_OW 311
61668: DIFF
61669: PPUSH
61670: CALL_OW 1
61674: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
61675: LD_ADDR_VAR 0 7
61679: PUSH
61680: LD_EXP 120
61684: PUSH
61685: LD_VAR 0 3
61689: ARRAY
61690: PPUSH
61691: LD_INT 1
61693: PPUSH
61694: LD_VAR 0 9
61698: PPUSH
61699: CALL_OW 2
61703: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
61704: LD_ADDR_EXP 120
61708: PUSH
61709: LD_EXP 120
61713: PPUSH
61714: LD_VAR 0 3
61718: PPUSH
61719: LD_VAR 0 7
61723: PPUSH
61724: CALL_OW 1
61728: ST_TO_ADDR
// end else
61729: GO 61748
// MC_InsertProduceList ( i , [ components ] ) ;
61731: LD_VAR 0 3
61735: PPUSH
61736: LD_VAR 0 9
61740: PUSH
61741: EMPTY
61742: LIST
61743: PPUSH
61744: CALL 57717 0 2
// break ;
61748: GO 61752
// end ; end ;
61750: GO 61537
61752: POP
61753: POP
// end ; end ; if GetType ( un ) = unit_building then
61754: LD_VAR 0 1
61758: PPUSH
61759: CALL_OW 247
61763: PUSH
61764: LD_INT 3
61766: EQUAL
61767: IFFALSE 62170
// begin btype := GetBType ( un ) ;
61769: LD_ADDR_VAR 0 5
61773: PUSH
61774: LD_VAR 0 1
61778: PPUSH
61779: CALL_OW 266
61783: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
61784: LD_VAR 0 5
61788: PUSH
61789: LD_INT 29
61791: PUSH
61792: LD_INT 30
61794: PUSH
61795: EMPTY
61796: LIST
61797: LIST
61798: IN
61799: IFFALSE 61872
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
61801: LD_VAR 0 1
61805: PPUSH
61806: CALL_OW 250
61810: PPUSH
61811: LD_VAR 0 1
61815: PPUSH
61816: CALL_OW 251
61820: PPUSH
61821: LD_VAR 0 1
61825: PPUSH
61826: CALL_OW 255
61830: PPUSH
61831: CALL_OW 440
61835: NOT
61836: IFFALSE 61872
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
61838: LD_VAR 0 1
61842: PPUSH
61843: CALL_OW 250
61847: PPUSH
61848: LD_VAR 0 1
61852: PPUSH
61853: CALL_OW 251
61857: PPUSH
61858: LD_VAR 0 1
61862: PPUSH
61863: CALL_OW 255
61867: PPUSH
61868: CALL_OW 441
// end ; if btype = b_warehouse then
61872: LD_VAR 0 5
61876: PUSH
61877: LD_INT 1
61879: EQUAL
61880: IFFALSE 61898
// begin btype := b_depot ;
61882: LD_ADDR_VAR 0 5
61886: PUSH
61887: LD_INT 0
61889: ST_TO_ADDR
// pos := 1 ;
61890: LD_ADDR_VAR 0 6
61894: PUSH
61895: LD_INT 1
61897: ST_TO_ADDR
// end ; if btype = b_factory then
61898: LD_VAR 0 5
61902: PUSH
61903: LD_INT 3
61905: EQUAL
61906: IFFALSE 61924
// begin btype := b_workshop ;
61908: LD_ADDR_VAR 0 5
61912: PUSH
61913: LD_INT 2
61915: ST_TO_ADDR
// pos := 1 ;
61916: LD_ADDR_VAR 0 6
61920: PUSH
61921: LD_INT 1
61923: ST_TO_ADDR
// end ; if btype = b_barracks then
61924: LD_VAR 0 5
61928: PUSH
61929: LD_INT 5
61931: EQUAL
61932: IFFALSE 61942
// btype := b_armoury ;
61934: LD_ADDR_VAR 0 5
61938: PUSH
61939: LD_INT 4
61941: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
61942: LD_VAR 0 5
61946: PUSH
61947: LD_INT 7
61949: PUSH
61950: LD_INT 8
61952: PUSH
61953: EMPTY
61954: LIST
61955: LIST
61956: IN
61957: IFFALSE 61967
// btype := b_lab ;
61959: LD_ADDR_VAR 0 5
61963: PUSH
61964: LD_INT 6
61966: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
61967: LD_ADDR_EXP 104
61971: PUSH
61972: LD_EXP 104
61976: PPUSH
61977: LD_VAR 0 3
61981: PUSH
61982: LD_EXP 104
61986: PUSH
61987: LD_VAR 0 3
61991: ARRAY
61992: PUSH
61993: LD_INT 1
61995: PLUS
61996: PUSH
61997: EMPTY
61998: LIST
61999: LIST
62000: PPUSH
62001: LD_VAR 0 5
62005: PUSH
62006: LD_VAR 0 1
62010: PPUSH
62011: CALL_OW 250
62015: PUSH
62016: LD_VAR 0 1
62020: PPUSH
62021: CALL_OW 251
62025: PUSH
62026: LD_VAR 0 1
62030: PPUSH
62031: CALL_OW 254
62035: PUSH
62036: EMPTY
62037: LIST
62038: LIST
62039: LIST
62040: LIST
62041: PPUSH
62042: CALL 71209 0 3
62046: ST_TO_ADDR
// if pos = 1 then
62047: LD_VAR 0 6
62051: PUSH
62052: LD_INT 1
62054: EQUAL
62055: IFFALSE 62170
// begin tmp := mc_build_list [ i ] ;
62057: LD_ADDR_VAR 0 7
62061: PUSH
62062: LD_EXP 104
62066: PUSH
62067: LD_VAR 0 3
62071: ARRAY
62072: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
62073: LD_VAR 0 7
62077: PPUSH
62078: LD_INT 2
62080: PUSH
62081: LD_INT 30
62083: PUSH
62084: LD_INT 0
62086: PUSH
62087: EMPTY
62088: LIST
62089: LIST
62090: PUSH
62091: LD_INT 30
62093: PUSH
62094: LD_INT 1
62096: PUSH
62097: EMPTY
62098: LIST
62099: LIST
62100: PUSH
62101: EMPTY
62102: LIST
62103: LIST
62104: LIST
62105: PPUSH
62106: CALL_OW 72
62110: IFFALSE 62120
// pos := 2 ;
62112: LD_ADDR_VAR 0 6
62116: PUSH
62117: LD_INT 2
62119: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
62120: LD_ADDR_VAR 0 7
62124: PUSH
62125: LD_VAR 0 7
62129: PPUSH
62130: LD_VAR 0 6
62134: PPUSH
62135: LD_VAR 0 7
62139: PPUSH
62140: CALL 71535 0 3
62144: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
62145: LD_ADDR_EXP 104
62149: PUSH
62150: LD_EXP 104
62154: PPUSH
62155: LD_VAR 0 3
62159: PPUSH
62160: LD_VAR 0 7
62164: PPUSH
62165: CALL_OW 1
62169: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
62170: LD_VAR 0 1
62174: PUSH
62175: LD_EXP 99
62179: PUSH
62180: LD_VAR 0 3
62184: ARRAY
62185: IN
62186: IFFALSE 62225
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
62188: LD_ADDR_EXP 99
62192: PUSH
62193: LD_EXP 99
62197: PPUSH
62198: LD_VAR 0 3
62202: PPUSH
62203: LD_EXP 99
62207: PUSH
62208: LD_VAR 0 3
62212: ARRAY
62213: PUSH
62214: LD_VAR 0 1
62218: DIFF
62219: PPUSH
62220: CALL_OW 1
62224: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
62225: LD_VAR 0 1
62229: PUSH
62230: LD_EXP 106
62234: PUSH
62235: LD_VAR 0 3
62239: ARRAY
62240: IN
62241: IFFALSE 62280
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
62243: LD_ADDR_EXP 106
62247: PUSH
62248: LD_EXP 106
62252: PPUSH
62253: LD_VAR 0 3
62257: PPUSH
62258: LD_EXP 106
62262: PUSH
62263: LD_VAR 0 3
62267: ARRAY
62268: PUSH
62269: LD_VAR 0 1
62273: DIFF
62274: PPUSH
62275: CALL_OW 1
62279: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
62280: LD_VAR 0 1
62284: PUSH
62285: LD_EXP 118
62289: PUSH
62290: LD_VAR 0 3
62294: ARRAY
62295: IN
62296: IFFALSE 62335
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
62298: LD_ADDR_EXP 118
62302: PUSH
62303: LD_EXP 118
62307: PPUSH
62308: LD_VAR 0 3
62312: PPUSH
62313: LD_EXP 118
62317: PUSH
62318: LD_VAR 0 3
62322: ARRAY
62323: PUSH
62324: LD_VAR 0 1
62328: DIFF
62329: PPUSH
62330: CALL_OW 1
62334: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
62335: LD_VAR 0 1
62339: PUSH
62340: LD_EXP 121
62344: PUSH
62345: LD_VAR 0 3
62349: ARRAY
62350: IN
62351: IFFALSE 62390
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
62353: LD_ADDR_EXP 121
62357: PUSH
62358: LD_EXP 121
62362: PPUSH
62363: LD_VAR 0 3
62367: PPUSH
62368: LD_EXP 121
62372: PUSH
62373: LD_VAR 0 3
62377: ARRAY
62378: PUSH
62379: LD_VAR 0 1
62383: DIFF
62384: PPUSH
62385: CALL_OW 1
62389: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
62390: LD_VAR 0 1
62394: PUSH
62395: LD_EXP 108
62399: PUSH
62400: LD_VAR 0 3
62404: ARRAY
62405: IN
62406: IFFALSE 62445
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
62408: LD_ADDR_EXP 108
62412: PUSH
62413: LD_EXP 108
62417: PPUSH
62418: LD_VAR 0 3
62422: PPUSH
62423: LD_EXP 108
62427: PUSH
62428: LD_VAR 0 3
62432: ARRAY
62433: PUSH
62434: LD_VAR 0 1
62438: DIFF
62439: PPUSH
62440: CALL_OW 1
62444: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
62445: LD_VAR 0 1
62449: PUSH
62450: LD_EXP 107
62454: PUSH
62455: LD_VAR 0 3
62459: ARRAY
62460: IN
62461: IFFALSE 62500
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
62463: LD_ADDR_EXP 107
62467: PUSH
62468: LD_EXP 107
62472: PPUSH
62473: LD_VAR 0 3
62477: PPUSH
62478: LD_EXP 107
62482: PUSH
62483: LD_VAR 0 3
62487: ARRAY
62488: PUSH
62489: LD_VAR 0 1
62493: DIFF
62494: PPUSH
62495: CALL_OW 1
62499: ST_TO_ADDR
// end ; break ;
62500: GO 62504
// end ;
62502: GO 61150
62504: POP
62505: POP
// end ;
62506: LD_VAR 0 2
62510: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
62511: LD_INT 0
62513: PPUSH
62514: PPUSH
62515: PPUSH
// if not mc_bases or not skirmish then
62516: LD_EXP 99
62520: NOT
62521: PUSH
62522: LD_EXP 97
62526: NOT
62527: OR
62528: IFFALSE 62532
// exit ;
62530: GO 62747
// for i = 1 to mc_bases do
62532: LD_ADDR_VAR 0 3
62536: PUSH
62537: DOUBLE
62538: LD_INT 1
62540: DEC
62541: ST_TO_ADDR
62542: LD_EXP 99
62546: PUSH
62547: FOR_TO
62548: IFFALSE 62745
// begin if building in mc_construct_list [ i ] then
62550: LD_VAR 0 1
62554: PUSH
62555: LD_EXP 106
62559: PUSH
62560: LD_VAR 0 3
62564: ARRAY
62565: IN
62566: IFFALSE 62743
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62568: LD_ADDR_EXP 106
62572: PUSH
62573: LD_EXP 106
62577: PPUSH
62578: LD_VAR 0 3
62582: PPUSH
62583: LD_EXP 106
62587: PUSH
62588: LD_VAR 0 3
62592: ARRAY
62593: PUSH
62594: LD_VAR 0 1
62598: DIFF
62599: PPUSH
62600: CALL_OW 1
62604: ST_TO_ADDR
// if building in mc_lab [ i ] then
62605: LD_VAR 0 1
62609: PUSH
62610: LD_EXP 132
62614: PUSH
62615: LD_VAR 0 3
62619: ARRAY
62620: IN
62621: IFFALSE 62676
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
62623: LD_ADDR_EXP 133
62627: PUSH
62628: LD_EXP 133
62632: PPUSH
62633: LD_VAR 0 3
62637: PPUSH
62638: LD_EXP 133
62642: PUSH
62643: LD_VAR 0 3
62647: ARRAY
62648: PPUSH
62649: LD_INT 1
62651: PPUSH
62652: LD_EXP 133
62656: PUSH
62657: LD_VAR 0 3
62661: ARRAY
62662: PPUSH
62663: LD_INT 0
62665: PPUSH
62666: CALL 70627 0 4
62670: PPUSH
62671: CALL_OW 1
62675: ST_TO_ADDR
// if not building in mc_bases [ i ] then
62676: LD_VAR 0 1
62680: PUSH
62681: LD_EXP 99
62685: PUSH
62686: LD_VAR 0 3
62690: ARRAY
62691: IN
62692: NOT
62693: IFFALSE 62739
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62695: LD_ADDR_EXP 99
62699: PUSH
62700: LD_EXP 99
62704: PPUSH
62705: LD_VAR 0 3
62709: PUSH
62710: LD_EXP 99
62714: PUSH
62715: LD_VAR 0 3
62719: ARRAY
62720: PUSH
62721: LD_INT 1
62723: PLUS
62724: PUSH
62725: EMPTY
62726: LIST
62727: LIST
62728: PPUSH
62729: LD_VAR 0 1
62733: PPUSH
62734: CALL 71209 0 3
62738: ST_TO_ADDR
// exit ;
62739: POP
62740: POP
62741: GO 62747
// end ; end ;
62743: GO 62547
62745: POP
62746: POP
// end ;
62747: LD_VAR 0 2
62751: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
62752: LD_INT 0
62754: PPUSH
62755: PPUSH
62756: PPUSH
62757: PPUSH
62758: PPUSH
62759: PPUSH
62760: PPUSH
// if not mc_bases or not skirmish then
62761: LD_EXP 99
62765: NOT
62766: PUSH
62767: LD_EXP 97
62771: NOT
62772: OR
62773: IFFALSE 62777
// exit ;
62775: GO 63438
// for i = 1 to mc_bases do
62777: LD_ADDR_VAR 0 3
62781: PUSH
62782: DOUBLE
62783: LD_INT 1
62785: DEC
62786: ST_TO_ADDR
62787: LD_EXP 99
62791: PUSH
62792: FOR_TO
62793: IFFALSE 63436
// begin if building in mc_construct_list [ i ] then
62795: LD_VAR 0 1
62799: PUSH
62800: LD_EXP 106
62804: PUSH
62805: LD_VAR 0 3
62809: ARRAY
62810: IN
62811: IFFALSE 63434
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
62813: LD_ADDR_EXP 106
62817: PUSH
62818: LD_EXP 106
62822: PPUSH
62823: LD_VAR 0 3
62827: PPUSH
62828: LD_EXP 106
62832: PUSH
62833: LD_VAR 0 3
62837: ARRAY
62838: PUSH
62839: LD_VAR 0 1
62843: DIFF
62844: PPUSH
62845: CALL_OW 1
62849: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
62850: LD_ADDR_EXP 99
62854: PUSH
62855: LD_EXP 99
62859: PPUSH
62860: LD_VAR 0 3
62864: PUSH
62865: LD_EXP 99
62869: PUSH
62870: LD_VAR 0 3
62874: ARRAY
62875: PUSH
62876: LD_INT 1
62878: PLUS
62879: PUSH
62880: EMPTY
62881: LIST
62882: LIST
62883: PPUSH
62884: LD_VAR 0 1
62888: PPUSH
62889: CALL 71209 0 3
62893: ST_TO_ADDR
// btype := GetBType ( building ) ;
62894: LD_ADDR_VAR 0 5
62898: PUSH
62899: LD_VAR 0 1
62903: PPUSH
62904: CALL_OW 266
62908: ST_TO_ADDR
// side := GetSide ( building ) ;
62909: LD_ADDR_VAR 0 8
62913: PUSH
62914: LD_VAR 0 1
62918: PPUSH
62919: CALL_OW 255
62923: ST_TO_ADDR
// if btype = b_lab then
62924: LD_VAR 0 5
62928: PUSH
62929: LD_INT 6
62931: EQUAL
62932: IFFALSE 62982
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
62934: LD_ADDR_EXP 132
62938: PUSH
62939: LD_EXP 132
62943: PPUSH
62944: LD_VAR 0 3
62948: PUSH
62949: LD_EXP 132
62953: PUSH
62954: LD_VAR 0 3
62958: ARRAY
62959: PUSH
62960: LD_INT 1
62962: PLUS
62963: PUSH
62964: EMPTY
62965: LIST
62966: LIST
62967: PPUSH
62968: LD_VAR 0 1
62972: PPUSH
62973: CALL 71209 0 3
62977: ST_TO_ADDR
// exit ;
62978: POP
62979: POP
62980: GO 63438
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
62982: LD_VAR 0 5
62986: PUSH
62987: LD_INT 0
62989: PUSH
62990: LD_INT 2
62992: PUSH
62993: LD_INT 4
62995: PUSH
62996: EMPTY
62997: LIST
62998: LIST
62999: LIST
63000: IN
63001: IFFALSE 63125
// begin if btype = b_armoury then
63003: LD_VAR 0 5
63007: PUSH
63008: LD_INT 4
63010: EQUAL
63011: IFFALSE 63021
// btype := b_barracks ;
63013: LD_ADDR_VAR 0 5
63017: PUSH
63018: LD_INT 5
63020: ST_TO_ADDR
// if btype = b_depot then
63021: LD_VAR 0 5
63025: PUSH
63026: LD_INT 0
63028: EQUAL
63029: IFFALSE 63039
// btype := b_warehouse ;
63031: LD_ADDR_VAR 0 5
63035: PUSH
63036: LD_INT 1
63038: ST_TO_ADDR
// if btype = b_workshop then
63039: LD_VAR 0 5
63043: PUSH
63044: LD_INT 2
63046: EQUAL
63047: IFFALSE 63057
// btype := b_factory ;
63049: LD_ADDR_VAR 0 5
63053: PUSH
63054: LD_INT 3
63056: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
63057: LD_VAR 0 5
63061: PPUSH
63062: LD_VAR 0 8
63066: PPUSH
63067: CALL_OW 323
63071: PUSH
63072: LD_INT 1
63074: EQUAL
63075: IFFALSE 63121
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
63077: LD_ADDR_EXP 131
63081: PUSH
63082: LD_EXP 131
63086: PPUSH
63087: LD_VAR 0 3
63091: PUSH
63092: LD_EXP 131
63096: PUSH
63097: LD_VAR 0 3
63101: ARRAY
63102: PUSH
63103: LD_INT 1
63105: PLUS
63106: PUSH
63107: EMPTY
63108: LIST
63109: LIST
63110: PPUSH
63111: LD_VAR 0 1
63115: PPUSH
63116: CALL 71209 0 3
63120: ST_TO_ADDR
// exit ;
63121: POP
63122: POP
63123: GO 63438
// end ; if btype in [ b_bunker , b_turret ] then
63125: LD_VAR 0 5
63129: PUSH
63130: LD_INT 32
63132: PUSH
63133: LD_INT 33
63135: PUSH
63136: EMPTY
63137: LIST
63138: LIST
63139: IN
63140: IFFALSE 63430
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
63142: LD_ADDR_EXP 107
63146: PUSH
63147: LD_EXP 107
63151: PPUSH
63152: LD_VAR 0 3
63156: PUSH
63157: LD_EXP 107
63161: PUSH
63162: LD_VAR 0 3
63166: ARRAY
63167: PUSH
63168: LD_INT 1
63170: PLUS
63171: PUSH
63172: EMPTY
63173: LIST
63174: LIST
63175: PPUSH
63176: LD_VAR 0 1
63180: PPUSH
63181: CALL 71209 0 3
63185: ST_TO_ADDR
// if btype = b_bunker then
63186: LD_VAR 0 5
63190: PUSH
63191: LD_INT 32
63193: EQUAL
63194: IFFALSE 63430
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63196: LD_ADDR_EXP 108
63200: PUSH
63201: LD_EXP 108
63205: PPUSH
63206: LD_VAR 0 3
63210: PUSH
63211: LD_EXP 108
63215: PUSH
63216: LD_VAR 0 3
63220: ARRAY
63221: PUSH
63222: LD_INT 1
63224: PLUS
63225: PUSH
63226: EMPTY
63227: LIST
63228: LIST
63229: PPUSH
63230: LD_VAR 0 1
63234: PPUSH
63235: CALL 71209 0 3
63239: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
63240: LD_ADDR_VAR 0 6
63244: PUSH
63245: LD_EXP 99
63249: PUSH
63250: LD_VAR 0 3
63254: ARRAY
63255: PPUSH
63256: LD_INT 25
63258: PUSH
63259: LD_INT 1
63261: PUSH
63262: EMPTY
63263: LIST
63264: LIST
63265: PUSH
63266: LD_INT 3
63268: PUSH
63269: LD_INT 54
63271: PUSH
63272: EMPTY
63273: LIST
63274: PUSH
63275: EMPTY
63276: LIST
63277: LIST
63278: PUSH
63279: EMPTY
63280: LIST
63281: LIST
63282: PPUSH
63283: CALL_OW 72
63287: ST_TO_ADDR
// if tmp then
63288: LD_VAR 0 6
63292: IFFALSE 63298
// exit ;
63294: POP
63295: POP
63296: GO 63438
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
63298: LD_ADDR_VAR 0 6
63302: PUSH
63303: LD_EXP 99
63307: PUSH
63308: LD_VAR 0 3
63312: ARRAY
63313: PPUSH
63314: LD_INT 2
63316: PUSH
63317: LD_INT 30
63319: PUSH
63320: LD_INT 4
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: PUSH
63327: LD_INT 30
63329: PUSH
63330: LD_INT 5
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: PUSH
63337: EMPTY
63338: LIST
63339: LIST
63340: LIST
63341: PPUSH
63342: CALL_OW 72
63346: ST_TO_ADDR
// if not tmp then
63347: LD_VAR 0 6
63351: NOT
63352: IFFALSE 63358
// exit ;
63354: POP
63355: POP
63356: GO 63438
// for j in tmp do
63358: LD_ADDR_VAR 0 4
63362: PUSH
63363: LD_VAR 0 6
63367: PUSH
63368: FOR_IN
63369: IFFALSE 63428
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
63371: LD_ADDR_VAR 0 7
63375: PUSH
63376: LD_VAR 0 4
63380: PPUSH
63381: CALL_OW 313
63385: PPUSH
63386: LD_INT 25
63388: PUSH
63389: LD_INT 1
63391: PUSH
63392: EMPTY
63393: LIST
63394: LIST
63395: PPUSH
63396: CALL_OW 72
63400: ST_TO_ADDR
// if units then
63401: LD_VAR 0 7
63405: IFFALSE 63426
// begin ComExitBuilding ( units [ 1 ] ) ;
63407: LD_VAR 0 7
63411: PUSH
63412: LD_INT 1
63414: ARRAY
63415: PPUSH
63416: CALL_OW 122
// exit ;
63420: POP
63421: POP
63422: POP
63423: POP
63424: GO 63438
// end ; end ;
63426: GO 63368
63428: POP
63429: POP
// end ; end ; exit ;
63430: POP
63431: POP
63432: GO 63438
// end ; end ;
63434: GO 62792
63436: POP
63437: POP
// end ;
63438: LD_VAR 0 2
63442: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
63443: LD_INT 0
63445: PPUSH
63446: PPUSH
63447: PPUSH
63448: PPUSH
63449: PPUSH
63450: PPUSH
63451: PPUSH
// if not mc_bases or not skirmish then
63452: LD_EXP 99
63456: NOT
63457: PUSH
63458: LD_EXP 97
63462: NOT
63463: OR
63464: IFFALSE 63468
// exit ;
63466: GO 63699
// btype := GetBType ( building ) ;
63468: LD_ADDR_VAR 0 6
63472: PUSH
63473: LD_VAR 0 1
63477: PPUSH
63478: CALL_OW 266
63482: ST_TO_ADDR
// x := GetX ( building ) ;
63483: LD_ADDR_VAR 0 7
63487: PUSH
63488: LD_VAR 0 1
63492: PPUSH
63493: CALL_OW 250
63497: ST_TO_ADDR
// y := GetY ( building ) ;
63498: LD_ADDR_VAR 0 8
63502: PUSH
63503: LD_VAR 0 1
63507: PPUSH
63508: CALL_OW 251
63512: ST_TO_ADDR
// d := GetDir ( building ) ;
63513: LD_ADDR_VAR 0 9
63517: PUSH
63518: LD_VAR 0 1
63522: PPUSH
63523: CALL_OW 254
63527: ST_TO_ADDR
// for i = 1 to mc_bases do
63528: LD_ADDR_VAR 0 4
63532: PUSH
63533: DOUBLE
63534: LD_INT 1
63536: DEC
63537: ST_TO_ADDR
63538: LD_EXP 99
63542: PUSH
63543: FOR_TO
63544: IFFALSE 63697
// begin if not mc_build_list [ i ] then
63546: LD_EXP 104
63550: PUSH
63551: LD_VAR 0 4
63555: ARRAY
63556: NOT
63557: IFFALSE 63561
// continue ;
63559: GO 63543
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
63561: LD_VAR 0 6
63565: PUSH
63566: LD_VAR 0 7
63570: PUSH
63571: LD_VAR 0 8
63575: PUSH
63576: LD_VAR 0 9
63580: PUSH
63581: EMPTY
63582: LIST
63583: LIST
63584: LIST
63585: LIST
63586: PPUSH
63587: LD_EXP 104
63591: PUSH
63592: LD_VAR 0 4
63596: ARRAY
63597: PUSH
63598: LD_INT 1
63600: ARRAY
63601: PPUSH
63602: CALL 77378 0 2
63606: IFFALSE 63695
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
63608: LD_ADDR_EXP 104
63612: PUSH
63613: LD_EXP 104
63617: PPUSH
63618: LD_VAR 0 4
63622: PPUSH
63623: LD_EXP 104
63627: PUSH
63628: LD_VAR 0 4
63632: ARRAY
63633: PPUSH
63634: LD_INT 1
63636: PPUSH
63637: CALL_OW 3
63641: PPUSH
63642: CALL_OW 1
63646: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
63647: LD_ADDR_EXP 106
63651: PUSH
63652: LD_EXP 106
63656: PPUSH
63657: LD_VAR 0 4
63661: PUSH
63662: LD_EXP 106
63666: PUSH
63667: LD_VAR 0 4
63671: ARRAY
63672: PUSH
63673: LD_INT 1
63675: PLUS
63676: PUSH
63677: EMPTY
63678: LIST
63679: LIST
63680: PPUSH
63681: LD_VAR 0 1
63685: PPUSH
63686: CALL 71209 0 3
63690: ST_TO_ADDR
// exit ;
63691: POP
63692: POP
63693: GO 63699
// end ; end ;
63695: GO 63543
63697: POP
63698: POP
// end ;
63699: LD_VAR 0 3
63703: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
63704: LD_INT 0
63706: PPUSH
63707: PPUSH
63708: PPUSH
// if not mc_bases or not skirmish then
63709: LD_EXP 99
63713: NOT
63714: PUSH
63715: LD_EXP 97
63719: NOT
63720: OR
63721: IFFALSE 63725
// exit ;
63723: GO 63915
// for i = 1 to mc_bases do
63725: LD_ADDR_VAR 0 4
63729: PUSH
63730: DOUBLE
63731: LD_INT 1
63733: DEC
63734: ST_TO_ADDR
63735: LD_EXP 99
63739: PUSH
63740: FOR_TO
63741: IFFALSE 63828
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
63743: LD_VAR 0 1
63747: PUSH
63748: LD_EXP 107
63752: PUSH
63753: LD_VAR 0 4
63757: ARRAY
63758: IN
63759: PUSH
63760: LD_VAR 0 1
63764: PUSH
63765: LD_EXP 108
63769: PUSH
63770: LD_VAR 0 4
63774: ARRAY
63775: IN
63776: NOT
63777: AND
63778: IFFALSE 63826
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
63780: LD_ADDR_EXP 108
63784: PUSH
63785: LD_EXP 108
63789: PPUSH
63790: LD_VAR 0 4
63794: PUSH
63795: LD_EXP 108
63799: PUSH
63800: LD_VAR 0 4
63804: ARRAY
63805: PUSH
63806: LD_INT 1
63808: PLUS
63809: PUSH
63810: EMPTY
63811: LIST
63812: LIST
63813: PPUSH
63814: LD_VAR 0 1
63818: PPUSH
63819: CALL 71209 0 3
63823: ST_TO_ADDR
// break ;
63824: GO 63828
// end ; end ;
63826: GO 63740
63828: POP
63829: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
63830: LD_VAR 0 1
63834: PPUSH
63835: CALL_OW 257
63839: PUSH
63840: LD_EXP 125
63844: IN
63845: PUSH
63846: LD_VAR 0 1
63850: PPUSH
63851: CALL_OW 266
63855: PUSH
63856: LD_INT 5
63858: EQUAL
63859: AND
63860: PUSH
63861: LD_VAR 0 2
63865: PPUSH
63866: CALL_OW 110
63870: PUSH
63871: LD_INT 18
63873: NONEQUAL
63874: AND
63875: IFFALSE 63915
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
63877: LD_VAR 0 2
63881: PPUSH
63882: CALL_OW 257
63886: PUSH
63887: LD_INT 5
63889: PUSH
63890: LD_INT 8
63892: PUSH
63893: LD_INT 9
63895: PUSH
63896: EMPTY
63897: LIST
63898: LIST
63899: LIST
63900: IN
63901: IFFALSE 63915
// SetClass ( unit , 1 ) ;
63903: LD_VAR 0 2
63907: PPUSH
63908: LD_INT 1
63910: PPUSH
63911: CALL_OW 336
// end ;
63915: LD_VAR 0 3
63919: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
63920: LD_INT 0
63922: PPUSH
63923: PPUSH
// if not mc_bases or not skirmish then
63924: LD_EXP 99
63928: NOT
63929: PUSH
63930: LD_EXP 97
63934: NOT
63935: OR
63936: IFFALSE 63940
// exit ;
63938: GO 64056
// if GetLives ( abandoned_vehicle ) > 250 then
63940: LD_VAR 0 2
63944: PPUSH
63945: CALL_OW 256
63949: PUSH
63950: LD_INT 250
63952: GREATER
63953: IFFALSE 63957
// exit ;
63955: GO 64056
// for i = 1 to mc_bases do
63957: LD_ADDR_VAR 0 6
63961: PUSH
63962: DOUBLE
63963: LD_INT 1
63965: DEC
63966: ST_TO_ADDR
63967: LD_EXP 99
63971: PUSH
63972: FOR_TO
63973: IFFALSE 64054
// begin if driver in mc_bases [ i ] then
63975: LD_VAR 0 1
63979: PUSH
63980: LD_EXP 99
63984: PUSH
63985: LD_VAR 0 6
63989: ARRAY
63990: IN
63991: IFFALSE 64052
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
63993: LD_VAR 0 1
63997: PPUSH
63998: LD_EXP 99
64002: PUSH
64003: LD_VAR 0 6
64007: ARRAY
64008: PPUSH
64009: LD_INT 2
64011: PUSH
64012: LD_INT 30
64014: PUSH
64015: LD_INT 0
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: PUSH
64022: LD_INT 30
64024: PUSH
64025: LD_INT 1
64027: PUSH
64028: EMPTY
64029: LIST
64030: LIST
64031: PUSH
64032: EMPTY
64033: LIST
64034: LIST
64035: LIST
64036: PPUSH
64037: CALL_OW 72
64041: PUSH
64042: LD_INT 1
64044: ARRAY
64045: PPUSH
64046: CALL_OW 112
// break ;
64050: GO 64054
// end ; end ;
64052: GO 63972
64054: POP
64055: POP
// end ; end_of_file
64056: LD_VAR 0 5
64060: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
64061: LD_INT 0
64063: PPUSH
64064: PPUSH
// if exist_mode then
64065: LD_VAR 0 2
64069: IFFALSE 64094
// unit := CreateCharacter ( prefix & ident ) else
64071: LD_ADDR_VAR 0 5
64075: PUSH
64076: LD_VAR 0 3
64080: PUSH
64081: LD_VAR 0 1
64085: STR
64086: PPUSH
64087: CALL_OW 34
64091: ST_TO_ADDR
64092: GO 64109
// unit := NewCharacter ( ident ) ;
64094: LD_ADDR_VAR 0 5
64098: PUSH
64099: LD_VAR 0 1
64103: PPUSH
64104: CALL_OW 25
64108: ST_TO_ADDR
// result := unit ;
64109: LD_ADDR_VAR 0 4
64113: PUSH
64114: LD_VAR 0 5
64118: ST_TO_ADDR
// end ;
64119: LD_VAR 0 4
64123: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
64124: LD_INT 0
64126: PPUSH
64127: PPUSH
// if not side or not nation then
64128: LD_VAR 0 1
64132: NOT
64133: PUSH
64134: LD_VAR 0 2
64138: NOT
64139: OR
64140: IFFALSE 64144
// exit ;
64142: GO 64788
// case nation of nation_american :
64144: LD_VAR 0 2
64148: PUSH
64149: LD_INT 1
64151: DOUBLE
64152: EQUAL
64153: IFTRUE 64157
64155: GO 64331
64157: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
64158: LD_ADDR_VAR 0 4
64162: PUSH
64163: LD_INT 35
64165: PUSH
64166: LD_INT 45
64168: PUSH
64169: LD_INT 46
64171: PUSH
64172: LD_INT 47
64174: PUSH
64175: LD_INT 1
64177: PUSH
64178: LD_INT 2
64180: PUSH
64181: LD_INT 6
64183: PUSH
64184: LD_INT 15
64186: PUSH
64187: LD_INT 16
64189: PUSH
64190: LD_INT 7
64192: PUSH
64193: LD_INT 12
64195: PUSH
64196: LD_INT 13
64198: PUSH
64199: LD_INT 10
64201: PUSH
64202: LD_INT 14
64204: PUSH
64205: LD_INT 20
64207: PUSH
64208: LD_INT 21
64210: PUSH
64211: LD_INT 22
64213: PUSH
64214: LD_INT 25
64216: PUSH
64217: LD_INT 32
64219: PUSH
64220: LD_INT 27
64222: PUSH
64223: LD_INT 36
64225: PUSH
64226: LD_INT 69
64228: PUSH
64229: LD_INT 39
64231: PUSH
64232: LD_INT 34
64234: PUSH
64235: LD_INT 40
64237: PUSH
64238: LD_INT 48
64240: PUSH
64241: LD_INT 49
64243: PUSH
64244: LD_INT 50
64246: PUSH
64247: LD_INT 51
64249: PUSH
64250: LD_INT 52
64252: PUSH
64253: LD_INT 53
64255: PUSH
64256: LD_INT 54
64258: PUSH
64259: LD_INT 55
64261: PUSH
64262: LD_INT 56
64264: PUSH
64265: LD_INT 57
64267: PUSH
64268: LD_INT 58
64270: PUSH
64271: LD_INT 59
64273: PUSH
64274: LD_INT 60
64276: PUSH
64277: LD_INT 61
64279: PUSH
64280: LD_INT 62
64282: PUSH
64283: LD_INT 80
64285: PUSH
64286: EMPTY
64287: LIST
64288: LIST
64289: LIST
64290: LIST
64291: LIST
64292: LIST
64293: LIST
64294: LIST
64295: LIST
64296: LIST
64297: LIST
64298: LIST
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: LIST
64304: LIST
64305: LIST
64306: LIST
64307: LIST
64308: LIST
64309: LIST
64310: LIST
64311: LIST
64312: LIST
64313: LIST
64314: LIST
64315: LIST
64316: LIST
64317: LIST
64318: LIST
64319: LIST
64320: LIST
64321: LIST
64322: LIST
64323: LIST
64324: LIST
64325: LIST
64326: LIST
64327: LIST
64328: ST_TO_ADDR
64329: GO 64712
64331: LD_INT 2
64333: DOUBLE
64334: EQUAL
64335: IFTRUE 64339
64337: GO 64521
64339: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
64340: LD_ADDR_VAR 0 4
64344: PUSH
64345: LD_INT 35
64347: PUSH
64348: LD_INT 45
64350: PUSH
64351: LD_INT 46
64353: PUSH
64354: LD_INT 47
64356: PUSH
64357: LD_INT 70
64359: PUSH
64360: LD_INT 1
64362: PUSH
64363: LD_INT 11
64365: PUSH
64366: LD_INT 3
64368: PUSH
64369: LD_INT 4
64371: PUSH
64372: LD_INT 5
64374: PUSH
64375: LD_INT 6
64377: PUSH
64378: LD_INT 15
64380: PUSH
64381: LD_INT 18
64383: PUSH
64384: LD_INT 7
64386: PUSH
64387: LD_INT 17
64389: PUSH
64390: LD_INT 8
64392: PUSH
64393: LD_INT 20
64395: PUSH
64396: LD_INT 21
64398: PUSH
64399: LD_INT 22
64401: PUSH
64402: LD_INT 72
64404: PUSH
64405: LD_INT 26
64407: PUSH
64408: LD_INT 69
64410: PUSH
64411: LD_INT 39
64413: PUSH
64414: LD_INT 40
64416: PUSH
64417: LD_INT 41
64419: PUSH
64420: LD_INT 42
64422: PUSH
64423: LD_INT 43
64425: PUSH
64426: LD_INT 48
64428: PUSH
64429: LD_INT 49
64431: PUSH
64432: LD_INT 50
64434: PUSH
64435: LD_INT 51
64437: PUSH
64438: LD_INT 52
64440: PUSH
64441: LD_INT 53
64443: PUSH
64444: LD_INT 54
64446: PUSH
64447: LD_INT 55
64449: PUSH
64450: LD_INT 56
64452: PUSH
64453: LD_INT 60
64455: PUSH
64456: LD_INT 61
64458: PUSH
64459: LD_INT 62
64461: PUSH
64462: LD_INT 66
64464: PUSH
64465: LD_INT 67
64467: PUSH
64468: LD_INT 68
64470: PUSH
64471: LD_INT 81
64473: PUSH
64474: EMPTY
64475: LIST
64476: LIST
64477: LIST
64478: LIST
64479: LIST
64480: LIST
64481: LIST
64482: LIST
64483: LIST
64484: LIST
64485: LIST
64486: LIST
64487: LIST
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: LIST
64493: LIST
64494: LIST
64495: LIST
64496: LIST
64497: LIST
64498: LIST
64499: LIST
64500: LIST
64501: LIST
64502: LIST
64503: LIST
64504: LIST
64505: LIST
64506: LIST
64507: LIST
64508: LIST
64509: LIST
64510: LIST
64511: LIST
64512: LIST
64513: LIST
64514: LIST
64515: LIST
64516: LIST
64517: LIST
64518: ST_TO_ADDR
64519: GO 64712
64521: LD_INT 3
64523: DOUBLE
64524: EQUAL
64525: IFTRUE 64529
64527: GO 64711
64529: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
64530: LD_ADDR_VAR 0 4
64534: PUSH
64535: LD_INT 46
64537: PUSH
64538: LD_INT 47
64540: PUSH
64541: LD_INT 1
64543: PUSH
64544: LD_INT 2
64546: PUSH
64547: LD_INT 11
64549: PUSH
64550: LD_INT 9
64552: PUSH
64553: LD_INT 20
64555: PUSH
64556: LD_INT 19
64558: PUSH
64559: LD_INT 21
64561: PUSH
64562: LD_INT 24
64564: PUSH
64565: LD_INT 22
64567: PUSH
64568: LD_INT 25
64570: PUSH
64571: LD_INT 28
64573: PUSH
64574: LD_INT 29
64576: PUSH
64577: LD_INT 30
64579: PUSH
64580: LD_INT 31
64582: PUSH
64583: LD_INT 37
64585: PUSH
64586: LD_INT 38
64588: PUSH
64589: LD_INT 32
64591: PUSH
64592: LD_INT 27
64594: PUSH
64595: LD_INT 33
64597: PUSH
64598: LD_INT 69
64600: PUSH
64601: LD_INT 39
64603: PUSH
64604: LD_INT 34
64606: PUSH
64607: LD_INT 40
64609: PUSH
64610: LD_INT 71
64612: PUSH
64613: LD_INT 23
64615: PUSH
64616: LD_INT 44
64618: PUSH
64619: LD_INT 48
64621: PUSH
64622: LD_INT 49
64624: PUSH
64625: LD_INT 50
64627: PUSH
64628: LD_INT 51
64630: PUSH
64631: LD_INT 52
64633: PUSH
64634: LD_INT 53
64636: PUSH
64637: LD_INT 54
64639: PUSH
64640: LD_INT 55
64642: PUSH
64643: LD_INT 56
64645: PUSH
64646: LD_INT 57
64648: PUSH
64649: LD_INT 58
64651: PUSH
64652: LD_INT 59
64654: PUSH
64655: LD_INT 63
64657: PUSH
64658: LD_INT 64
64660: PUSH
64661: LD_INT 65
64663: PUSH
64664: EMPTY
64665: LIST
64666: LIST
64667: LIST
64668: LIST
64669: LIST
64670: LIST
64671: LIST
64672: LIST
64673: LIST
64674: LIST
64675: LIST
64676: LIST
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: LIST
64706: LIST
64707: LIST
64708: ST_TO_ADDR
64709: GO 64712
64711: POP
// if state > - 1 and state < 3 then
64712: LD_VAR 0 3
64716: PUSH
64717: LD_INT 1
64719: NEG
64720: GREATER
64721: PUSH
64722: LD_VAR 0 3
64726: PUSH
64727: LD_INT 3
64729: LESS
64730: AND
64731: IFFALSE 64788
// for i in result do
64733: LD_ADDR_VAR 0 5
64737: PUSH
64738: LD_VAR 0 4
64742: PUSH
64743: FOR_IN
64744: IFFALSE 64786
// if GetTech ( i , side ) <> state then
64746: LD_VAR 0 5
64750: PPUSH
64751: LD_VAR 0 1
64755: PPUSH
64756: CALL_OW 321
64760: PUSH
64761: LD_VAR 0 3
64765: NONEQUAL
64766: IFFALSE 64784
// result := result diff i ;
64768: LD_ADDR_VAR 0 4
64772: PUSH
64773: LD_VAR 0 4
64777: PUSH
64778: LD_VAR 0 5
64782: DIFF
64783: ST_TO_ADDR
64784: GO 64743
64786: POP
64787: POP
// end ;
64788: LD_VAR 0 4
64792: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
64793: LD_INT 0
64795: PPUSH
64796: PPUSH
64797: PPUSH
// result := true ;
64798: LD_ADDR_VAR 0 3
64802: PUSH
64803: LD_INT 1
64805: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
64806: LD_ADDR_VAR 0 5
64810: PUSH
64811: LD_VAR 0 2
64815: PPUSH
64816: CALL_OW 480
64820: ST_TO_ADDR
// if not tmp then
64821: LD_VAR 0 5
64825: NOT
64826: IFFALSE 64830
// exit ;
64828: GO 64879
// for i in tmp do
64830: LD_ADDR_VAR 0 4
64834: PUSH
64835: LD_VAR 0 5
64839: PUSH
64840: FOR_IN
64841: IFFALSE 64877
// if GetTech ( i , side ) <> state_researched then
64843: LD_VAR 0 4
64847: PPUSH
64848: LD_VAR 0 1
64852: PPUSH
64853: CALL_OW 321
64857: PUSH
64858: LD_INT 2
64860: NONEQUAL
64861: IFFALSE 64875
// begin result := false ;
64863: LD_ADDR_VAR 0 3
64867: PUSH
64868: LD_INT 0
64870: ST_TO_ADDR
// exit ;
64871: POP
64872: POP
64873: GO 64879
// end ;
64875: GO 64840
64877: POP
64878: POP
// end ;
64879: LD_VAR 0 3
64883: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
64884: LD_INT 0
64886: PPUSH
64887: PPUSH
64888: PPUSH
64889: PPUSH
64890: PPUSH
64891: PPUSH
64892: PPUSH
64893: PPUSH
64894: PPUSH
64895: PPUSH
64896: PPUSH
64897: PPUSH
64898: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
64899: LD_VAR 0 1
64903: NOT
64904: PUSH
64905: LD_VAR 0 1
64909: PPUSH
64910: CALL_OW 257
64914: PUSH
64915: LD_INT 9
64917: NONEQUAL
64918: OR
64919: IFFALSE 64923
// exit ;
64921: GO 65496
// side := GetSide ( unit ) ;
64923: LD_ADDR_VAR 0 9
64927: PUSH
64928: LD_VAR 0 1
64932: PPUSH
64933: CALL_OW 255
64937: ST_TO_ADDR
// tech_space := tech_spacanom ;
64938: LD_ADDR_VAR 0 12
64942: PUSH
64943: LD_INT 29
64945: ST_TO_ADDR
// tech_time := tech_taurad ;
64946: LD_ADDR_VAR 0 13
64950: PUSH
64951: LD_INT 28
64953: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
64954: LD_ADDR_VAR 0 11
64958: PUSH
64959: LD_VAR 0 1
64963: PPUSH
64964: CALL_OW 310
64968: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
64969: LD_VAR 0 11
64973: PPUSH
64974: CALL_OW 247
64978: PUSH
64979: LD_INT 2
64981: EQUAL
64982: IFFALSE 64986
// exit ;
64984: GO 65496
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
64986: LD_ADDR_VAR 0 8
64990: PUSH
64991: LD_INT 81
64993: PUSH
64994: LD_VAR 0 9
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: PUSH
65003: LD_INT 3
65005: PUSH
65006: LD_INT 21
65008: PUSH
65009: LD_INT 3
65011: PUSH
65012: EMPTY
65013: LIST
65014: LIST
65015: PUSH
65016: EMPTY
65017: LIST
65018: LIST
65019: PUSH
65020: EMPTY
65021: LIST
65022: LIST
65023: PPUSH
65024: CALL_OW 69
65028: ST_TO_ADDR
// if not tmp then
65029: LD_VAR 0 8
65033: NOT
65034: IFFALSE 65038
// exit ;
65036: GO 65496
// if in_unit then
65038: LD_VAR 0 11
65042: IFFALSE 65066
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
65044: LD_ADDR_VAR 0 10
65048: PUSH
65049: LD_VAR 0 8
65053: PPUSH
65054: LD_VAR 0 11
65058: PPUSH
65059: CALL_OW 74
65063: ST_TO_ADDR
65064: GO 65086
// enemy := NearestUnitToUnit ( tmp , unit ) ;
65066: LD_ADDR_VAR 0 10
65070: PUSH
65071: LD_VAR 0 8
65075: PPUSH
65076: LD_VAR 0 1
65080: PPUSH
65081: CALL_OW 74
65085: ST_TO_ADDR
// if not enemy then
65086: LD_VAR 0 10
65090: NOT
65091: IFFALSE 65095
// exit ;
65093: GO 65496
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
65095: LD_VAR 0 11
65099: PUSH
65100: LD_VAR 0 11
65104: PPUSH
65105: LD_VAR 0 10
65109: PPUSH
65110: CALL_OW 296
65114: PUSH
65115: LD_INT 13
65117: GREATER
65118: AND
65119: PUSH
65120: LD_VAR 0 1
65124: PPUSH
65125: LD_VAR 0 10
65129: PPUSH
65130: CALL_OW 296
65134: PUSH
65135: LD_INT 12
65137: GREATER
65138: OR
65139: IFFALSE 65143
// exit ;
65141: GO 65496
// missile := [ 1 ] ;
65143: LD_ADDR_VAR 0 14
65147: PUSH
65148: LD_INT 1
65150: PUSH
65151: EMPTY
65152: LIST
65153: ST_TO_ADDR
// if Researched ( side , tech_space ) then
65154: LD_VAR 0 9
65158: PPUSH
65159: LD_VAR 0 12
65163: PPUSH
65164: CALL_OW 325
65168: IFFALSE 65197
// missile := Insert ( missile , missile + 1 , 2 ) ;
65170: LD_ADDR_VAR 0 14
65174: PUSH
65175: LD_VAR 0 14
65179: PPUSH
65180: LD_VAR 0 14
65184: PUSH
65185: LD_INT 1
65187: PLUS
65188: PPUSH
65189: LD_INT 2
65191: PPUSH
65192: CALL_OW 2
65196: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
65197: LD_VAR 0 9
65201: PPUSH
65202: LD_VAR 0 13
65206: PPUSH
65207: CALL_OW 325
65211: PUSH
65212: LD_VAR 0 10
65216: PPUSH
65217: CALL_OW 255
65221: PPUSH
65222: LD_VAR 0 13
65226: PPUSH
65227: CALL_OW 325
65231: NOT
65232: AND
65233: IFFALSE 65262
// missile := Insert ( missile , missile + 1 , 3 ) ;
65235: LD_ADDR_VAR 0 14
65239: PUSH
65240: LD_VAR 0 14
65244: PPUSH
65245: LD_VAR 0 14
65249: PUSH
65250: LD_INT 1
65252: PLUS
65253: PPUSH
65254: LD_INT 3
65256: PPUSH
65257: CALL_OW 2
65261: ST_TO_ADDR
// if missile < 2 then
65262: LD_VAR 0 14
65266: PUSH
65267: LD_INT 2
65269: LESS
65270: IFFALSE 65274
// exit ;
65272: GO 65496
// x := GetX ( enemy ) ;
65274: LD_ADDR_VAR 0 4
65278: PUSH
65279: LD_VAR 0 10
65283: PPUSH
65284: CALL_OW 250
65288: ST_TO_ADDR
// y := GetY ( enemy ) ;
65289: LD_ADDR_VAR 0 5
65293: PUSH
65294: LD_VAR 0 10
65298: PPUSH
65299: CALL_OW 251
65303: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
65304: LD_ADDR_VAR 0 6
65308: PUSH
65309: LD_VAR 0 4
65313: PUSH
65314: LD_INT 1
65316: NEG
65317: PPUSH
65318: LD_INT 1
65320: PPUSH
65321: CALL_OW 12
65325: PLUS
65326: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
65327: LD_ADDR_VAR 0 7
65331: PUSH
65332: LD_VAR 0 5
65336: PUSH
65337: LD_INT 1
65339: NEG
65340: PPUSH
65341: LD_INT 1
65343: PPUSH
65344: CALL_OW 12
65348: PLUS
65349: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65350: LD_VAR 0 6
65354: PPUSH
65355: LD_VAR 0 7
65359: PPUSH
65360: CALL_OW 488
65364: NOT
65365: IFFALSE 65387
// begin _x := x ;
65367: LD_ADDR_VAR 0 6
65371: PUSH
65372: LD_VAR 0 4
65376: ST_TO_ADDR
// _y := y ;
65377: LD_ADDR_VAR 0 7
65381: PUSH
65382: LD_VAR 0 5
65386: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
65387: LD_ADDR_VAR 0 3
65391: PUSH
65392: LD_INT 1
65394: PPUSH
65395: LD_VAR 0 14
65399: PPUSH
65400: CALL_OW 12
65404: ST_TO_ADDR
// case i of 1 :
65405: LD_VAR 0 3
65409: PUSH
65410: LD_INT 1
65412: DOUBLE
65413: EQUAL
65414: IFTRUE 65418
65416: GO 65435
65418: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
65419: LD_VAR 0 1
65423: PPUSH
65424: LD_VAR 0 10
65428: PPUSH
65429: CALL_OW 115
65433: GO 65496
65435: LD_INT 2
65437: DOUBLE
65438: EQUAL
65439: IFTRUE 65443
65441: GO 65465
65443: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
65444: LD_VAR 0 1
65448: PPUSH
65449: LD_VAR 0 6
65453: PPUSH
65454: LD_VAR 0 7
65458: PPUSH
65459: CALL_OW 153
65463: GO 65496
65465: LD_INT 3
65467: DOUBLE
65468: EQUAL
65469: IFTRUE 65473
65471: GO 65495
65473: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
65474: LD_VAR 0 1
65478: PPUSH
65479: LD_VAR 0 6
65483: PPUSH
65484: LD_VAR 0 7
65488: PPUSH
65489: CALL_OW 154
65493: GO 65496
65495: POP
// end ;
65496: LD_VAR 0 2
65500: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
65501: LD_INT 0
65503: PPUSH
65504: PPUSH
65505: PPUSH
65506: PPUSH
65507: PPUSH
65508: PPUSH
// if not unit or not building then
65509: LD_VAR 0 1
65513: NOT
65514: PUSH
65515: LD_VAR 0 2
65519: NOT
65520: OR
65521: IFFALSE 65525
// exit ;
65523: GO 65683
// x := GetX ( building ) ;
65525: LD_ADDR_VAR 0 5
65529: PUSH
65530: LD_VAR 0 2
65534: PPUSH
65535: CALL_OW 250
65539: ST_TO_ADDR
// y := GetY ( building ) ;
65540: LD_ADDR_VAR 0 6
65544: PUSH
65545: LD_VAR 0 2
65549: PPUSH
65550: CALL_OW 251
65554: ST_TO_ADDR
// for i = 0 to 5 do
65555: LD_ADDR_VAR 0 4
65559: PUSH
65560: DOUBLE
65561: LD_INT 0
65563: DEC
65564: ST_TO_ADDR
65565: LD_INT 5
65567: PUSH
65568: FOR_TO
65569: IFFALSE 65681
// begin _x := ShiftX ( x , i , 3 ) ;
65571: LD_ADDR_VAR 0 7
65575: PUSH
65576: LD_VAR 0 5
65580: PPUSH
65581: LD_VAR 0 4
65585: PPUSH
65586: LD_INT 3
65588: PPUSH
65589: CALL_OW 272
65593: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
65594: LD_ADDR_VAR 0 8
65598: PUSH
65599: LD_VAR 0 6
65603: PPUSH
65604: LD_VAR 0 4
65608: PPUSH
65609: LD_INT 3
65611: PPUSH
65612: CALL_OW 273
65616: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
65617: LD_VAR 0 7
65621: PPUSH
65622: LD_VAR 0 8
65626: PPUSH
65627: CALL_OW 488
65631: NOT
65632: IFFALSE 65636
// continue ;
65634: GO 65568
// if HexInfo ( _x , _y ) = 0 then
65636: LD_VAR 0 7
65640: PPUSH
65641: LD_VAR 0 8
65645: PPUSH
65646: CALL_OW 428
65650: PUSH
65651: LD_INT 0
65653: EQUAL
65654: IFFALSE 65679
// begin ComMoveXY ( unit , _x , _y ) ;
65656: LD_VAR 0 1
65660: PPUSH
65661: LD_VAR 0 7
65665: PPUSH
65666: LD_VAR 0 8
65670: PPUSH
65671: CALL_OW 111
// exit ;
65675: POP
65676: POP
65677: GO 65683
// end ; end ;
65679: GO 65568
65681: POP
65682: POP
// end ;
65683: LD_VAR 0 3
65687: RET
// export function ScanBase ( side , base_area ) ; begin
65688: LD_INT 0
65690: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
65691: LD_ADDR_VAR 0 3
65695: PUSH
65696: LD_VAR 0 2
65700: PPUSH
65701: LD_INT 81
65703: PUSH
65704: LD_VAR 0 1
65708: PUSH
65709: EMPTY
65710: LIST
65711: LIST
65712: PPUSH
65713: CALL_OW 70
65717: ST_TO_ADDR
// end ;
65718: LD_VAR 0 3
65722: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
65723: LD_INT 0
65725: PPUSH
65726: PPUSH
65727: PPUSH
65728: PPUSH
65729: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
65730: LD_VAR 0 1
65734: NOT
65735: PUSH
65736: LD_EXP 99
65740: PUSH
65741: LD_VAR 0 1
65745: ARRAY
65746: NOT
65747: OR
65748: PUSH
65749: LD_VAR 0 2
65753: NOT
65754: OR
65755: PUSH
65756: LD_VAR 0 3
65760: NOT
65761: OR
65762: IFFALSE 65766
// exit ;
65764: GO 66279
// side := mc_sides [ base ] ;
65766: LD_ADDR_VAR 0 6
65770: PUSH
65771: LD_EXP 125
65775: PUSH
65776: LD_VAR 0 1
65780: ARRAY
65781: ST_TO_ADDR
// if not side then
65782: LD_VAR 0 6
65786: NOT
65787: IFFALSE 65791
// exit ;
65789: GO 66279
// for i in solds do
65791: LD_ADDR_VAR 0 7
65795: PUSH
65796: LD_VAR 0 2
65800: PUSH
65801: FOR_IN
65802: IFFALSE 65863
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
65804: LD_VAR 0 7
65808: PPUSH
65809: CALL_OW 310
65813: PPUSH
65814: CALL_OW 266
65818: PUSH
65819: LD_INT 32
65821: PUSH
65822: LD_INT 31
65824: PUSH
65825: EMPTY
65826: LIST
65827: LIST
65828: IN
65829: IFFALSE 65849
// solds := solds diff i else
65831: LD_ADDR_VAR 0 2
65835: PUSH
65836: LD_VAR 0 2
65840: PUSH
65841: LD_VAR 0 7
65845: DIFF
65846: ST_TO_ADDR
65847: GO 65861
// SetTag ( i , 18 ) ;
65849: LD_VAR 0 7
65853: PPUSH
65854: LD_INT 18
65856: PPUSH
65857: CALL_OW 109
65861: GO 65801
65863: POP
65864: POP
// if not solds then
65865: LD_VAR 0 2
65869: NOT
65870: IFFALSE 65874
// exit ;
65872: GO 66279
// repeat wait ( 0 0$1 ) ;
65874: LD_INT 35
65876: PPUSH
65877: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
65881: LD_ADDR_VAR 0 5
65885: PUSH
65886: LD_VAR 0 6
65890: PPUSH
65891: LD_VAR 0 3
65895: PPUSH
65896: CALL 65688 0 2
65900: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
65901: LD_EXP 99
65905: PUSH
65906: LD_VAR 0 1
65910: ARRAY
65911: NOT
65912: PUSH
65913: LD_EXP 99
65917: PUSH
65918: LD_VAR 0 1
65922: ARRAY
65923: PUSH
65924: EMPTY
65925: EQUAL
65926: OR
65927: IFFALSE 65964
// begin for i in solds do
65929: LD_ADDR_VAR 0 7
65933: PUSH
65934: LD_VAR 0 2
65938: PUSH
65939: FOR_IN
65940: IFFALSE 65953
// ComStop ( i ) ;
65942: LD_VAR 0 7
65946: PPUSH
65947: CALL_OW 141
65951: GO 65939
65953: POP
65954: POP
// solds := [ ] ;
65955: LD_ADDR_VAR 0 2
65959: PUSH
65960: EMPTY
65961: ST_TO_ADDR
// exit ;
65962: GO 66279
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
65964: LD_VAR 0 5
65968: NOT
65969: PUSH
65970: LD_VAR 0 5
65974: PUSH
65975: LD_INT 3
65977: GREATER
65978: OR
65979: PUSH
65980: LD_EXP 121
65984: PUSH
65985: LD_VAR 0 1
65989: ARRAY
65990: OR
65991: IFFALSE 66032
// begin for i in solds do
65993: LD_ADDR_VAR 0 7
65997: PUSH
65998: LD_VAR 0 2
66002: PUSH
66003: FOR_IN
66004: IFFALSE 66028
// if HasTask ( i ) then
66006: LD_VAR 0 7
66010: PPUSH
66011: CALL_OW 314
66015: IFFALSE 66026
// ComStop ( i ) ;
66017: LD_VAR 0 7
66021: PPUSH
66022: CALL_OW 141
66026: GO 66003
66028: POP
66029: POP
// break ;
66030: GO 66267
// end ; for i in solds do
66032: LD_ADDR_VAR 0 7
66036: PUSH
66037: LD_VAR 0 2
66041: PUSH
66042: FOR_IN
66043: IFFALSE 66259
// begin if IsInUnit ( i ) then
66045: LD_VAR 0 7
66049: PPUSH
66050: CALL_OW 310
66054: IFFALSE 66065
// ComExitBuilding ( i ) ;
66056: LD_VAR 0 7
66060: PPUSH
66061: CALL_OW 122
// if GetLives ( i ) > 333 then
66065: LD_VAR 0 7
66069: PPUSH
66070: CALL_OW 256
66074: PUSH
66075: LD_INT 333
66077: GREATER
66078: IFFALSE 66106
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
66080: LD_VAR 0 7
66084: PPUSH
66085: LD_VAR 0 5
66089: PPUSH
66090: LD_VAR 0 7
66094: PPUSH
66095: CALL_OW 74
66099: PPUSH
66100: CALL_OW 115
66104: GO 66257
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
66106: LD_ADDR_VAR 0 8
66110: PUSH
66111: LD_EXP 99
66115: PUSH
66116: LD_VAR 0 1
66120: ARRAY
66121: PPUSH
66122: LD_INT 2
66124: PUSH
66125: LD_INT 30
66127: PUSH
66128: LD_INT 0
66130: PUSH
66131: EMPTY
66132: LIST
66133: LIST
66134: PUSH
66135: LD_INT 30
66137: PUSH
66138: LD_INT 1
66140: PUSH
66141: EMPTY
66142: LIST
66143: LIST
66144: PUSH
66145: LD_INT 30
66147: PUSH
66148: LD_INT 6
66150: PUSH
66151: EMPTY
66152: LIST
66153: LIST
66154: PUSH
66155: EMPTY
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: PPUSH
66161: CALL_OW 72
66165: PPUSH
66166: LD_VAR 0 7
66170: PPUSH
66171: CALL_OW 74
66175: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
66176: LD_VAR 0 7
66180: PPUSH
66181: LD_VAR 0 8
66185: PPUSH
66186: CALL_OW 250
66190: PPUSH
66191: LD_INT 3
66193: PPUSH
66194: LD_INT 5
66196: PPUSH
66197: CALL_OW 272
66201: PPUSH
66202: LD_VAR 0 8
66206: PPUSH
66207: CALL_OW 251
66211: PPUSH
66212: LD_INT 3
66214: PPUSH
66215: LD_INT 5
66217: PPUSH
66218: CALL_OW 273
66222: PPUSH
66223: CALL_OW 111
// SetTag ( i , 0 ) ;
66227: LD_VAR 0 7
66231: PPUSH
66232: LD_INT 0
66234: PPUSH
66235: CALL_OW 109
// solds := solds diff i ;
66239: LD_ADDR_VAR 0 2
66243: PUSH
66244: LD_VAR 0 2
66248: PUSH
66249: LD_VAR 0 7
66253: DIFF
66254: ST_TO_ADDR
// continue ;
66255: GO 66042
// end ; end ;
66257: GO 66042
66259: POP
66260: POP
// until solds ;
66261: LD_VAR 0 2
66265: IFFALSE 65874
// MC_Reset ( base , 18 ) ;
66267: LD_VAR 0 1
66271: PPUSH
66272: LD_INT 18
66274: PPUSH
66275: CALL 37996 0 2
// end ;
66279: LD_VAR 0 4
66283: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
66284: LD_INT 0
66286: PPUSH
66287: PPUSH
66288: PPUSH
66289: PPUSH
66290: PPUSH
66291: PPUSH
66292: PPUSH
66293: PPUSH
66294: PPUSH
66295: PPUSH
66296: PPUSH
66297: PPUSH
66298: PPUSH
66299: PPUSH
66300: PPUSH
66301: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
66302: LD_ADDR_VAR 0 12
66306: PUSH
66307: LD_EXP 99
66311: PUSH
66312: LD_VAR 0 1
66316: ARRAY
66317: PPUSH
66318: LD_INT 25
66320: PUSH
66321: LD_INT 3
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PPUSH
66328: CALL_OW 72
66332: ST_TO_ADDR
// if mc_remote_driver [ base ] then
66333: LD_EXP 139
66337: PUSH
66338: LD_VAR 0 1
66342: ARRAY
66343: IFFALSE 66367
// mechs := mechs diff mc_remote_driver [ base ] ;
66345: LD_ADDR_VAR 0 12
66349: PUSH
66350: LD_VAR 0 12
66354: PUSH
66355: LD_EXP 139
66359: PUSH
66360: LD_VAR 0 1
66364: ARRAY
66365: DIFF
66366: ST_TO_ADDR
// for i in mechs do
66367: LD_ADDR_VAR 0 5
66371: PUSH
66372: LD_VAR 0 12
66376: PUSH
66377: FOR_IN
66378: IFFALSE 66413
// if GetTag ( i ) > 0 then
66380: LD_VAR 0 5
66384: PPUSH
66385: CALL_OW 110
66389: PUSH
66390: LD_INT 0
66392: GREATER
66393: IFFALSE 66411
// mechs := mechs diff i ;
66395: LD_ADDR_VAR 0 12
66399: PUSH
66400: LD_VAR 0 12
66404: PUSH
66405: LD_VAR 0 5
66409: DIFF
66410: ST_TO_ADDR
66411: GO 66377
66413: POP
66414: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66415: LD_ADDR_VAR 0 8
66419: PUSH
66420: LD_EXP 99
66424: PUSH
66425: LD_VAR 0 1
66429: ARRAY
66430: PPUSH
66431: LD_INT 2
66433: PUSH
66434: LD_INT 25
66436: PUSH
66437: LD_INT 1
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 25
66446: PUSH
66447: LD_INT 5
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 25
66456: PUSH
66457: LD_INT 8
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: LD_INT 25
66466: PUSH
66467: LD_INT 9
66469: PUSH
66470: EMPTY
66471: LIST
66472: LIST
66473: PUSH
66474: EMPTY
66475: LIST
66476: LIST
66477: LIST
66478: LIST
66479: LIST
66480: PPUSH
66481: CALL_OW 72
66485: ST_TO_ADDR
// if not defenders and not solds then
66486: LD_VAR 0 2
66490: NOT
66491: PUSH
66492: LD_VAR 0 8
66496: NOT
66497: AND
66498: IFFALSE 66502
// exit ;
66500: GO 68040
// depot_under_attack := false ;
66502: LD_ADDR_VAR 0 16
66506: PUSH
66507: LD_INT 0
66509: ST_TO_ADDR
// sold_defenders := [ ] ;
66510: LD_ADDR_VAR 0 17
66514: PUSH
66515: EMPTY
66516: ST_TO_ADDR
// if mechs then
66517: LD_VAR 0 12
66521: IFFALSE 66650
// for i in defenders do
66523: LD_ADDR_VAR 0 5
66527: PUSH
66528: LD_VAR 0 2
66532: PUSH
66533: FOR_IN
66534: IFFALSE 66648
// begin SetTag ( i , 20 ) ;
66536: LD_VAR 0 5
66540: PPUSH
66541: LD_INT 20
66543: PPUSH
66544: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
66548: LD_VAR 0 5
66552: PPUSH
66553: CALL_OW 263
66557: PUSH
66558: LD_INT 1
66560: EQUAL
66561: PUSH
66562: LD_VAR 0 5
66566: PPUSH
66567: CALL_OW 311
66571: NOT
66572: AND
66573: PUSH
66574: LD_VAR 0 12
66578: AND
66579: IFFALSE 66646
// begin un := mechs [ 1 ] ;
66581: LD_ADDR_VAR 0 10
66585: PUSH
66586: LD_VAR 0 12
66590: PUSH
66591: LD_INT 1
66593: ARRAY
66594: ST_TO_ADDR
// ComExitBuilding ( un ) ;
66595: LD_VAR 0 10
66599: PPUSH
66600: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
66604: LD_VAR 0 10
66608: PPUSH
66609: LD_VAR 0 5
66613: PPUSH
66614: CALL_OW 180
// SetTag ( un , 19 ) ;
66618: LD_VAR 0 10
66622: PPUSH
66623: LD_INT 19
66625: PPUSH
66626: CALL_OW 109
// mechs := mechs diff un ;
66630: LD_ADDR_VAR 0 12
66634: PUSH
66635: LD_VAR 0 12
66639: PUSH
66640: LD_VAR 0 10
66644: DIFF
66645: ST_TO_ADDR
// end ; end ;
66646: GO 66533
66648: POP
66649: POP
// if solds then
66650: LD_VAR 0 8
66654: IFFALSE 66713
// for i in solds do
66656: LD_ADDR_VAR 0 5
66660: PUSH
66661: LD_VAR 0 8
66665: PUSH
66666: FOR_IN
66667: IFFALSE 66711
// if not GetTag ( i ) then
66669: LD_VAR 0 5
66673: PPUSH
66674: CALL_OW 110
66678: NOT
66679: IFFALSE 66709
// begin defenders := defenders union i ;
66681: LD_ADDR_VAR 0 2
66685: PUSH
66686: LD_VAR 0 2
66690: PUSH
66691: LD_VAR 0 5
66695: UNION
66696: ST_TO_ADDR
// SetTag ( i , 18 ) ;
66697: LD_VAR 0 5
66701: PPUSH
66702: LD_INT 18
66704: PPUSH
66705: CALL_OW 109
// end ;
66709: GO 66666
66711: POP
66712: POP
// repeat wait ( 0 0$1 ) ;
66713: LD_INT 35
66715: PPUSH
66716: CALL_OW 67
// enemy := mc_scan [ base ] ;
66720: LD_ADDR_VAR 0 3
66724: PUSH
66725: LD_EXP 122
66729: PUSH
66730: LD_VAR 0 1
66734: ARRAY
66735: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
66736: LD_EXP 99
66740: PUSH
66741: LD_VAR 0 1
66745: ARRAY
66746: NOT
66747: PUSH
66748: LD_EXP 99
66752: PUSH
66753: LD_VAR 0 1
66757: ARRAY
66758: PUSH
66759: EMPTY
66760: EQUAL
66761: OR
66762: IFFALSE 66799
// begin for i in defenders do
66764: LD_ADDR_VAR 0 5
66768: PUSH
66769: LD_VAR 0 2
66773: PUSH
66774: FOR_IN
66775: IFFALSE 66788
// ComStop ( i ) ;
66777: LD_VAR 0 5
66781: PPUSH
66782: CALL_OW 141
66786: GO 66774
66788: POP
66789: POP
// defenders := [ ] ;
66790: LD_ADDR_VAR 0 2
66794: PUSH
66795: EMPTY
66796: ST_TO_ADDR
// exit ;
66797: GO 68040
// end ; for i in defenders do
66799: LD_ADDR_VAR 0 5
66803: PUSH
66804: LD_VAR 0 2
66808: PUSH
66809: FOR_IN
66810: IFFALSE 67540
// begin e := NearestUnitToUnit ( enemy , i ) ;
66812: LD_ADDR_VAR 0 13
66816: PUSH
66817: LD_VAR 0 3
66821: PPUSH
66822: LD_VAR 0 5
66826: PPUSH
66827: CALL_OW 74
66831: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
66832: LD_ADDR_VAR 0 16
66836: PUSH
66837: LD_EXP 99
66841: PUSH
66842: LD_VAR 0 1
66846: ARRAY
66847: PPUSH
66848: LD_INT 2
66850: PUSH
66851: LD_INT 30
66853: PUSH
66854: LD_INT 0
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: PUSH
66861: LD_INT 30
66863: PUSH
66864: LD_INT 1
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: LIST
66875: PPUSH
66876: CALL_OW 72
66880: NOT
66881: PUSH
66882: LD_EXP 99
66886: PUSH
66887: LD_VAR 0 1
66891: ARRAY
66892: PPUSH
66893: LD_INT 2
66895: PUSH
66896: LD_INT 30
66898: PUSH
66899: LD_INT 0
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 30
66908: PUSH
66909: LD_INT 1
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: EMPTY
66917: LIST
66918: LIST
66919: LIST
66920: PPUSH
66921: CALL_OW 72
66925: PPUSH
66926: CALL_OW 256
66930: PUSH
66931: LD_INT 600
66933: LESS
66934: OR
66935: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
66936: LD_VAR 0 5
66940: PPUSH
66941: CALL_OW 247
66945: PUSH
66946: LD_INT 2
66948: DOUBLE
66949: EQUAL
66950: IFTRUE 66954
66952: GO 67246
66954: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
66955: LD_VAR 0 5
66959: PPUSH
66960: CALL_OW 256
66964: PUSH
66965: LD_INT 650
66967: GREATER
66968: PUSH
66969: LD_VAR 0 5
66973: PPUSH
66974: LD_VAR 0 13
66978: PPUSH
66979: CALL_OW 296
66983: PUSH
66984: LD_INT 40
66986: LESS
66987: PUSH
66988: LD_VAR 0 13
66992: PPUSH
66993: LD_EXP 124
66997: PUSH
66998: LD_VAR 0 1
67002: ARRAY
67003: PPUSH
67004: CALL_OW 308
67008: OR
67009: AND
67010: IFFALSE 67028
// ComAttackUnit ( i , e ) else
67012: LD_VAR 0 5
67016: PPUSH
67017: LD_VAR 0 13
67021: PPUSH
67022: CALL_OW 115
67026: GO 67129
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
67028: LD_VAR 0 13
67032: PPUSH
67033: LD_EXP 124
67037: PUSH
67038: LD_VAR 0 1
67042: ARRAY
67043: PPUSH
67044: CALL_OW 308
67048: NOT
67049: PUSH
67050: LD_VAR 0 5
67054: PPUSH
67055: LD_VAR 0 13
67059: PPUSH
67060: CALL_OW 296
67064: PUSH
67065: LD_INT 40
67067: GREATEREQUAL
67068: AND
67069: PUSH
67070: LD_VAR 0 5
67074: PPUSH
67075: CALL_OW 256
67079: PUSH
67080: LD_INT 650
67082: LESSEQUAL
67083: OR
67084: PUSH
67085: LD_VAR 0 5
67089: PPUSH
67090: LD_EXP 123
67094: PUSH
67095: LD_VAR 0 1
67099: ARRAY
67100: PPUSH
67101: CALL_OW 308
67105: NOT
67106: AND
67107: IFFALSE 67129
// ComMoveToArea ( i , mc_parking [ base ] ) ;
67109: LD_VAR 0 5
67113: PPUSH
67114: LD_EXP 123
67118: PUSH
67119: LD_VAR 0 1
67123: ARRAY
67124: PPUSH
67125: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
67129: LD_VAR 0 5
67133: PPUSH
67134: CALL_OW 256
67138: PUSH
67139: LD_INT 998
67141: LESS
67142: PUSH
67143: LD_VAR 0 5
67147: PPUSH
67148: CALL_OW 263
67152: PUSH
67153: LD_INT 1
67155: EQUAL
67156: AND
67157: PUSH
67158: LD_VAR 0 5
67162: PPUSH
67163: CALL_OW 311
67167: AND
67168: PUSH
67169: LD_VAR 0 5
67173: PPUSH
67174: LD_EXP 123
67178: PUSH
67179: LD_VAR 0 1
67183: ARRAY
67184: PPUSH
67185: CALL_OW 308
67189: AND
67190: IFFALSE 67244
// begin mech := IsDrivenBy ( i ) ;
67192: LD_ADDR_VAR 0 9
67196: PUSH
67197: LD_VAR 0 5
67201: PPUSH
67202: CALL_OW 311
67206: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
67207: LD_VAR 0 9
67211: PPUSH
67212: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
67216: LD_VAR 0 9
67220: PPUSH
67221: LD_VAR 0 5
67225: PPUSH
67226: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
67230: LD_VAR 0 9
67234: PPUSH
67235: LD_VAR 0 5
67239: PPUSH
67240: CALL_OW 180
// end ; end ; unit_human :
67244: GO 67511
67246: LD_INT 1
67248: DOUBLE
67249: EQUAL
67250: IFTRUE 67254
67252: GO 67510
67254: POP
// begin b := IsInUnit ( i ) ;
67255: LD_ADDR_VAR 0 18
67259: PUSH
67260: LD_VAR 0 5
67264: PPUSH
67265: CALL_OW 310
67269: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
67270: LD_ADDR_VAR 0 19
67274: PUSH
67275: LD_VAR 0 18
67279: NOT
67280: PUSH
67281: LD_VAR 0 18
67285: PPUSH
67286: CALL_OW 266
67290: PUSH
67291: LD_INT 32
67293: PUSH
67294: LD_INT 31
67296: PUSH
67297: EMPTY
67298: LIST
67299: LIST
67300: IN
67301: OR
67302: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
67303: LD_VAR 0 16
67307: PUSH
67308: LD_VAR 0 2
67312: PPUSH
67313: LD_INT 21
67315: PUSH
67316: LD_INT 2
67318: PUSH
67319: EMPTY
67320: LIST
67321: LIST
67322: PPUSH
67323: CALL_OW 72
67327: PUSH
67328: LD_INT 1
67330: LESSEQUAL
67331: OR
67332: PUSH
67333: LD_VAR 0 19
67337: AND
67338: PUSH
67339: LD_VAR 0 5
67343: PUSH
67344: LD_VAR 0 17
67348: IN
67349: NOT
67350: AND
67351: IFFALSE 67444
// begin if b then
67353: LD_VAR 0 18
67357: IFFALSE 67406
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
67359: LD_VAR 0 18
67363: PPUSH
67364: LD_VAR 0 3
67368: PPUSH
67369: LD_VAR 0 18
67373: PPUSH
67374: CALL_OW 74
67378: PPUSH
67379: CALL_OW 296
67383: PUSH
67384: LD_INT 10
67386: LESS
67387: PUSH
67388: LD_VAR 0 18
67392: PPUSH
67393: CALL_OW 461
67397: PUSH
67398: LD_INT 7
67400: NONEQUAL
67401: AND
67402: IFFALSE 67406
// continue ;
67404: GO 66809
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
67406: LD_ADDR_VAR 0 17
67410: PUSH
67411: LD_VAR 0 17
67415: PPUSH
67416: LD_VAR 0 17
67420: PUSH
67421: LD_INT 1
67423: PLUS
67424: PPUSH
67425: LD_VAR 0 5
67429: PPUSH
67430: CALL_OW 1
67434: ST_TO_ADDR
// ComExitBuilding ( i ) ;
67435: LD_VAR 0 5
67439: PPUSH
67440: CALL_OW 122
// end ; if sold_defenders then
67444: LD_VAR 0 17
67448: IFFALSE 67508
// if i in sold_defenders then
67450: LD_VAR 0 5
67454: PUSH
67455: LD_VAR 0 17
67459: IN
67460: IFFALSE 67508
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
67462: LD_VAR 0 5
67466: PPUSH
67467: CALL_OW 314
67471: NOT
67472: PUSH
67473: LD_VAR 0 5
67477: PPUSH
67478: LD_VAR 0 13
67482: PPUSH
67483: CALL_OW 296
67487: PUSH
67488: LD_INT 30
67490: LESS
67491: AND
67492: IFFALSE 67508
// ComAttackUnit ( i , e ) ;
67494: LD_VAR 0 5
67498: PPUSH
67499: LD_VAR 0 13
67503: PPUSH
67504: CALL_OW 115
// end ; end ; end ;
67508: GO 67511
67510: POP
// if IsDead ( i ) then
67511: LD_VAR 0 5
67515: PPUSH
67516: CALL_OW 301
67520: IFFALSE 67538
// defenders := defenders diff i ;
67522: LD_ADDR_VAR 0 2
67526: PUSH
67527: LD_VAR 0 2
67531: PUSH
67532: LD_VAR 0 5
67536: DIFF
67537: ST_TO_ADDR
// end ;
67538: GO 66809
67540: POP
67541: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
67542: LD_VAR 0 3
67546: NOT
67547: PUSH
67548: LD_VAR 0 2
67552: NOT
67553: OR
67554: PUSH
67555: LD_EXP 99
67559: PUSH
67560: LD_VAR 0 1
67564: ARRAY
67565: NOT
67566: OR
67567: IFFALSE 66713
// MC_Reset ( base , 18 ) ;
67569: LD_VAR 0 1
67573: PPUSH
67574: LD_INT 18
67576: PPUSH
67577: CALL 37996 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67581: LD_ADDR_VAR 0 2
67585: PUSH
67586: LD_VAR 0 2
67590: PUSH
67591: LD_VAR 0 2
67595: PPUSH
67596: LD_INT 2
67598: PUSH
67599: LD_INT 25
67601: PUSH
67602: LD_INT 1
67604: PUSH
67605: EMPTY
67606: LIST
67607: LIST
67608: PUSH
67609: LD_INT 25
67611: PUSH
67612: LD_INT 5
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: PUSH
67619: LD_INT 25
67621: PUSH
67622: LD_INT 8
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: PUSH
67629: LD_INT 25
67631: PUSH
67632: LD_INT 9
67634: PUSH
67635: EMPTY
67636: LIST
67637: LIST
67638: PUSH
67639: EMPTY
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: PPUSH
67646: CALL_OW 72
67650: DIFF
67651: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
67652: LD_VAR 0 3
67656: NOT
67657: PUSH
67658: LD_VAR 0 2
67662: PPUSH
67663: LD_INT 21
67665: PUSH
67666: LD_INT 2
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PPUSH
67673: CALL_OW 72
67677: AND
67678: IFFALSE 68016
// begin tmp := FilterByTag ( defenders , 19 ) ;
67680: LD_ADDR_VAR 0 11
67684: PUSH
67685: LD_VAR 0 2
67689: PPUSH
67690: LD_INT 19
67692: PPUSH
67693: CALL 104469 0 2
67697: ST_TO_ADDR
// if tmp then
67698: LD_VAR 0 11
67702: IFFALSE 67772
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
67704: LD_ADDR_VAR 0 11
67708: PUSH
67709: LD_VAR 0 11
67713: PPUSH
67714: LD_INT 25
67716: PUSH
67717: LD_INT 3
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PPUSH
67724: CALL_OW 72
67728: ST_TO_ADDR
// if tmp then
67729: LD_VAR 0 11
67733: IFFALSE 67772
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
67735: LD_ADDR_EXP 111
67739: PUSH
67740: LD_EXP 111
67744: PPUSH
67745: LD_VAR 0 1
67749: PPUSH
67750: LD_EXP 111
67754: PUSH
67755: LD_VAR 0 1
67759: ARRAY
67760: PUSH
67761: LD_VAR 0 11
67765: UNION
67766: PPUSH
67767: CALL_OW 1
67771: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
67772: LD_VAR 0 1
67776: PPUSH
67777: LD_INT 19
67779: PPUSH
67780: CALL 37996 0 2
// repeat wait ( 0 0$1 ) ;
67784: LD_INT 35
67786: PPUSH
67787: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
67791: LD_EXP 99
67795: PUSH
67796: LD_VAR 0 1
67800: ARRAY
67801: NOT
67802: PUSH
67803: LD_EXP 99
67807: PUSH
67808: LD_VAR 0 1
67812: ARRAY
67813: PUSH
67814: EMPTY
67815: EQUAL
67816: OR
67817: IFFALSE 67854
// begin for i in defenders do
67819: LD_ADDR_VAR 0 5
67823: PUSH
67824: LD_VAR 0 2
67828: PUSH
67829: FOR_IN
67830: IFFALSE 67843
// ComStop ( i ) ;
67832: LD_VAR 0 5
67836: PPUSH
67837: CALL_OW 141
67841: GO 67829
67843: POP
67844: POP
// defenders := [ ] ;
67845: LD_ADDR_VAR 0 2
67849: PUSH
67850: EMPTY
67851: ST_TO_ADDR
// exit ;
67852: GO 68040
// end ; for i in defenders do
67854: LD_ADDR_VAR 0 5
67858: PUSH
67859: LD_VAR 0 2
67863: PUSH
67864: FOR_IN
67865: IFFALSE 67954
// begin if not IsInArea ( i , mc_parking [ base ] ) then
67867: LD_VAR 0 5
67871: PPUSH
67872: LD_EXP 123
67876: PUSH
67877: LD_VAR 0 1
67881: ARRAY
67882: PPUSH
67883: CALL_OW 308
67887: NOT
67888: IFFALSE 67912
// ComMoveToArea ( i , mc_parking [ base ] ) else
67890: LD_VAR 0 5
67894: PPUSH
67895: LD_EXP 123
67899: PUSH
67900: LD_VAR 0 1
67904: ARRAY
67905: PPUSH
67906: CALL_OW 113
67910: GO 67952
// if GetControl ( i ) = control_manual then
67912: LD_VAR 0 5
67916: PPUSH
67917: CALL_OW 263
67921: PUSH
67922: LD_INT 1
67924: EQUAL
67925: IFFALSE 67952
// if IsDrivenBy ( i ) then
67927: LD_VAR 0 5
67931: PPUSH
67932: CALL_OW 311
67936: IFFALSE 67952
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
67938: LD_VAR 0 5
67942: PPUSH
67943: CALL_OW 311
67947: PPUSH
67948: CALL_OW 121
// end ;
67952: GO 67864
67954: POP
67955: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
67956: LD_VAR 0 2
67960: PPUSH
67961: LD_INT 95
67963: PUSH
67964: LD_EXP 123
67968: PUSH
67969: LD_VAR 0 1
67973: ARRAY
67974: PUSH
67975: EMPTY
67976: LIST
67977: LIST
67978: PPUSH
67979: CALL_OW 72
67983: PUSH
67984: LD_VAR 0 2
67988: EQUAL
67989: PUSH
67990: LD_EXP 122
67994: PUSH
67995: LD_VAR 0 1
67999: ARRAY
68000: OR
68001: PUSH
68002: LD_EXP 99
68006: PUSH
68007: LD_VAR 0 1
68011: ARRAY
68012: NOT
68013: OR
68014: IFFALSE 67784
// end ; MC_Reset ( base , 19 ) ;
68016: LD_VAR 0 1
68020: PPUSH
68021: LD_INT 19
68023: PPUSH
68024: CALL 37996 0 2
// MC_Reset ( base , 20 ) ;
68028: LD_VAR 0 1
68032: PPUSH
68033: LD_INT 20
68035: PPUSH
68036: CALL 37996 0 2
// end ;
68040: LD_VAR 0 4
68044: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
68045: LD_INT 0
68047: PPUSH
68048: PPUSH
68049: PPUSH
68050: PPUSH
// result := false ;
68051: LD_ADDR_VAR 0 2
68055: PUSH
68056: LD_INT 0
68058: ST_TO_ADDR
// side := GetSide ( unit ) ;
68059: LD_ADDR_VAR 0 3
68063: PUSH
68064: LD_VAR 0 1
68068: PPUSH
68069: CALL_OW 255
68073: ST_TO_ADDR
// nat := GetNation ( unit ) ;
68074: LD_ADDR_VAR 0 4
68078: PUSH
68079: LD_VAR 0 1
68083: PPUSH
68084: CALL_OW 248
68088: ST_TO_ADDR
// case nat of 1 :
68089: LD_VAR 0 4
68093: PUSH
68094: LD_INT 1
68096: DOUBLE
68097: EQUAL
68098: IFTRUE 68102
68100: GO 68113
68102: POP
// tech := tech_lassight ; 2 :
68103: LD_ADDR_VAR 0 5
68107: PUSH
68108: LD_INT 12
68110: ST_TO_ADDR
68111: GO 68152
68113: LD_INT 2
68115: DOUBLE
68116: EQUAL
68117: IFTRUE 68121
68119: GO 68132
68121: POP
// tech := tech_mortar ; 3 :
68122: LD_ADDR_VAR 0 5
68126: PUSH
68127: LD_INT 41
68129: ST_TO_ADDR
68130: GO 68152
68132: LD_INT 3
68134: DOUBLE
68135: EQUAL
68136: IFTRUE 68140
68138: GO 68151
68140: POP
// tech := tech_bazooka ; end ;
68141: LD_ADDR_VAR 0 5
68145: PUSH
68146: LD_INT 44
68148: ST_TO_ADDR
68149: GO 68152
68151: POP
// if Researched ( side , tech ) then
68152: LD_VAR 0 3
68156: PPUSH
68157: LD_VAR 0 5
68161: PPUSH
68162: CALL_OW 325
68166: IFFALSE 68193
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
68168: LD_ADDR_VAR 0 2
68172: PUSH
68173: LD_INT 5
68175: PUSH
68176: LD_INT 8
68178: PUSH
68179: LD_INT 9
68181: PUSH
68182: EMPTY
68183: LIST
68184: LIST
68185: LIST
68186: PUSH
68187: LD_VAR 0 4
68191: ARRAY
68192: ST_TO_ADDR
// end ;
68193: LD_VAR 0 2
68197: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
68198: LD_INT 0
68200: PPUSH
68201: PPUSH
68202: PPUSH
// if not mines then
68203: LD_VAR 0 2
68207: NOT
68208: IFFALSE 68212
// exit ;
68210: GO 68356
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
68212: LD_ADDR_VAR 0 5
68216: PUSH
68217: LD_INT 81
68219: PUSH
68220: LD_VAR 0 1
68224: PUSH
68225: EMPTY
68226: LIST
68227: LIST
68228: PUSH
68229: LD_INT 3
68231: PUSH
68232: LD_INT 21
68234: PUSH
68235: LD_INT 3
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: PUSH
68246: EMPTY
68247: LIST
68248: LIST
68249: PPUSH
68250: CALL_OW 69
68254: ST_TO_ADDR
// for i in mines do
68255: LD_ADDR_VAR 0 4
68259: PUSH
68260: LD_VAR 0 2
68264: PUSH
68265: FOR_IN
68266: IFFALSE 68354
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
68268: LD_VAR 0 4
68272: PUSH
68273: LD_INT 1
68275: ARRAY
68276: PPUSH
68277: LD_VAR 0 4
68281: PUSH
68282: LD_INT 2
68284: ARRAY
68285: PPUSH
68286: CALL_OW 458
68290: NOT
68291: IFFALSE 68295
// continue ;
68293: GO 68265
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
68295: LD_VAR 0 4
68299: PUSH
68300: LD_INT 1
68302: ARRAY
68303: PPUSH
68304: LD_VAR 0 4
68308: PUSH
68309: LD_INT 2
68311: ARRAY
68312: PPUSH
68313: CALL_OW 428
68317: PUSH
68318: LD_VAR 0 5
68322: IN
68323: IFFALSE 68352
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
68325: LD_VAR 0 4
68329: PUSH
68330: LD_INT 1
68332: ARRAY
68333: PPUSH
68334: LD_VAR 0 4
68338: PUSH
68339: LD_INT 2
68341: ARRAY
68342: PPUSH
68343: LD_VAR 0 1
68347: PPUSH
68348: CALL_OW 456
// end ;
68352: GO 68265
68354: POP
68355: POP
// end ;
68356: LD_VAR 0 3
68360: RET
// export function Count ( array ) ; var i ; begin
68361: LD_INT 0
68363: PPUSH
68364: PPUSH
// result := 0 ;
68365: LD_ADDR_VAR 0 2
68369: PUSH
68370: LD_INT 0
68372: ST_TO_ADDR
// for i in array do
68373: LD_ADDR_VAR 0 3
68377: PUSH
68378: LD_VAR 0 1
68382: PUSH
68383: FOR_IN
68384: IFFALSE 68408
// if i then
68386: LD_VAR 0 3
68390: IFFALSE 68406
// result := result + 1 ;
68392: LD_ADDR_VAR 0 2
68396: PUSH
68397: LD_VAR 0 2
68401: PUSH
68402: LD_INT 1
68404: PLUS
68405: ST_TO_ADDR
68406: GO 68383
68408: POP
68409: POP
// end ;
68410: LD_VAR 0 2
68414: RET
// export function IsEmpty ( building ) ; begin
68415: LD_INT 0
68417: PPUSH
// if not building then
68418: LD_VAR 0 1
68422: NOT
68423: IFFALSE 68427
// exit ;
68425: GO 68470
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
68427: LD_ADDR_VAR 0 2
68431: PUSH
68432: LD_VAR 0 1
68436: PUSH
68437: LD_INT 22
68439: PUSH
68440: LD_VAR 0 1
68444: PPUSH
68445: CALL_OW 255
68449: PUSH
68450: EMPTY
68451: LIST
68452: LIST
68453: PUSH
68454: LD_INT 58
68456: PUSH
68457: EMPTY
68458: LIST
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PPUSH
68464: CALL_OW 69
68468: IN
68469: ST_TO_ADDR
// end ;
68470: LD_VAR 0 2
68474: RET
// export function IsNotFull ( building ) ; begin
68475: LD_INT 0
68477: PPUSH
// if not building then
68478: LD_VAR 0 1
68482: NOT
68483: IFFALSE 68487
// exit ;
68485: GO 68506
// result := UnitsInside ( building ) < 6 ;
68487: LD_ADDR_VAR 0 2
68491: PUSH
68492: LD_VAR 0 1
68496: PPUSH
68497: CALL_OW 313
68501: PUSH
68502: LD_INT 6
68504: LESS
68505: ST_TO_ADDR
// end ;
68506: LD_VAR 0 2
68510: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
68511: LD_INT 0
68513: PPUSH
68514: PPUSH
68515: PPUSH
68516: PPUSH
// tmp := [ ] ;
68517: LD_ADDR_VAR 0 3
68521: PUSH
68522: EMPTY
68523: ST_TO_ADDR
// list := [ ] ;
68524: LD_ADDR_VAR 0 5
68528: PUSH
68529: EMPTY
68530: ST_TO_ADDR
// for i = 16 to 25 do
68531: LD_ADDR_VAR 0 4
68535: PUSH
68536: DOUBLE
68537: LD_INT 16
68539: DEC
68540: ST_TO_ADDR
68541: LD_INT 25
68543: PUSH
68544: FOR_TO
68545: IFFALSE 68618
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
68547: LD_ADDR_VAR 0 3
68551: PUSH
68552: LD_VAR 0 3
68556: PUSH
68557: LD_INT 22
68559: PUSH
68560: LD_VAR 0 1
68564: PPUSH
68565: CALL_OW 255
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: LD_INT 91
68576: PUSH
68577: LD_VAR 0 1
68581: PUSH
68582: LD_INT 6
68584: PUSH
68585: EMPTY
68586: LIST
68587: LIST
68588: LIST
68589: PUSH
68590: LD_INT 30
68592: PUSH
68593: LD_VAR 0 4
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: PUSH
68602: EMPTY
68603: LIST
68604: LIST
68605: LIST
68606: PUSH
68607: EMPTY
68608: LIST
68609: PPUSH
68610: CALL_OW 69
68614: ADD
68615: ST_TO_ADDR
68616: GO 68544
68618: POP
68619: POP
// for i = 1 to tmp do
68620: LD_ADDR_VAR 0 4
68624: PUSH
68625: DOUBLE
68626: LD_INT 1
68628: DEC
68629: ST_TO_ADDR
68630: LD_VAR 0 3
68634: PUSH
68635: FOR_TO
68636: IFFALSE 68724
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
68638: LD_ADDR_VAR 0 5
68642: PUSH
68643: LD_VAR 0 5
68647: PUSH
68648: LD_VAR 0 3
68652: PUSH
68653: LD_VAR 0 4
68657: ARRAY
68658: PPUSH
68659: CALL_OW 266
68663: PUSH
68664: LD_VAR 0 3
68668: PUSH
68669: LD_VAR 0 4
68673: ARRAY
68674: PPUSH
68675: CALL_OW 250
68679: PUSH
68680: LD_VAR 0 3
68684: PUSH
68685: LD_VAR 0 4
68689: ARRAY
68690: PPUSH
68691: CALL_OW 251
68695: PUSH
68696: LD_VAR 0 3
68700: PUSH
68701: LD_VAR 0 4
68705: ARRAY
68706: PPUSH
68707: CALL_OW 254
68711: PUSH
68712: EMPTY
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: PUSH
68718: EMPTY
68719: LIST
68720: ADD
68721: ST_TO_ADDR
68722: GO 68635
68724: POP
68725: POP
// result := list ;
68726: LD_ADDR_VAR 0 2
68730: PUSH
68731: LD_VAR 0 5
68735: ST_TO_ADDR
// end ;
68736: LD_VAR 0 2
68740: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
68741: LD_INT 0
68743: PPUSH
68744: PPUSH
68745: PPUSH
68746: PPUSH
68747: PPUSH
68748: PPUSH
68749: PPUSH
// if not factory then
68750: LD_VAR 0 1
68754: NOT
68755: IFFALSE 68759
// exit ;
68757: GO 69352
// if control = control_apeman then
68759: LD_VAR 0 4
68763: PUSH
68764: LD_INT 5
68766: EQUAL
68767: IFFALSE 68876
// begin tmp := UnitsInside ( factory ) ;
68769: LD_ADDR_VAR 0 8
68773: PUSH
68774: LD_VAR 0 1
68778: PPUSH
68779: CALL_OW 313
68783: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
68784: LD_VAR 0 8
68788: PPUSH
68789: LD_INT 25
68791: PUSH
68792: LD_INT 12
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: PPUSH
68799: CALL_OW 72
68803: NOT
68804: IFFALSE 68814
// control := control_manual ;
68806: LD_ADDR_VAR 0 4
68810: PUSH
68811: LD_INT 1
68813: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
68814: LD_ADDR_VAR 0 8
68818: PUSH
68819: LD_VAR 0 1
68823: PPUSH
68824: CALL 68511 0 1
68828: ST_TO_ADDR
// if tmp then
68829: LD_VAR 0 8
68833: IFFALSE 68876
// begin for i in tmp do
68835: LD_ADDR_VAR 0 7
68839: PUSH
68840: LD_VAR 0 8
68844: PUSH
68845: FOR_IN
68846: IFFALSE 68874
// if i [ 1 ] = b_ext_radio then
68848: LD_VAR 0 7
68852: PUSH
68853: LD_INT 1
68855: ARRAY
68856: PUSH
68857: LD_INT 22
68859: EQUAL
68860: IFFALSE 68872
// begin control := control_remote ;
68862: LD_ADDR_VAR 0 4
68866: PUSH
68867: LD_INT 2
68869: ST_TO_ADDR
// break ;
68870: GO 68874
// end ;
68872: GO 68845
68874: POP
68875: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
68876: LD_VAR 0 1
68880: PPUSH
68881: LD_VAR 0 2
68885: PPUSH
68886: LD_VAR 0 3
68890: PPUSH
68891: LD_VAR 0 4
68895: PPUSH
68896: LD_VAR 0 5
68900: PPUSH
68901: CALL_OW 448
68905: IFFALSE 68940
// begin result := [ chassis , engine , control , weapon ] ;
68907: LD_ADDR_VAR 0 6
68911: PUSH
68912: LD_VAR 0 2
68916: PUSH
68917: LD_VAR 0 3
68921: PUSH
68922: LD_VAR 0 4
68926: PUSH
68927: LD_VAR 0 5
68931: PUSH
68932: EMPTY
68933: LIST
68934: LIST
68935: LIST
68936: LIST
68937: ST_TO_ADDR
// exit ;
68938: GO 69352
// end ; _chassis := AvailableChassisList ( factory ) ;
68940: LD_ADDR_VAR 0 9
68944: PUSH
68945: LD_VAR 0 1
68949: PPUSH
68950: CALL_OW 475
68954: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
68955: LD_ADDR_VAR 0 11
68959: PUSH
68960: LD_VAR 0 1
68964: PPUSH
68965: CALL_OW 476
68969: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
68970: LD_ADDR_VAR 0 12
68974: PUSH
68975: LD_VAR 0 1
68979: PPUSH
68980: CALL_OW 477
68984: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
68985: LD_ADDR_VAR 0 10
68989: PUSH
68990: LD_VAR 0 1
68994: PPUSH
68995: CALL_OW 478
68999: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
69000: LD_VAR 0 9
69004: NOT
69005: PUSH
69006: LD_VAR 0 11
69010: NOT
69011: OR
69012: PUSH
69013: LD_VAR 0 12
69017: NOT
69018: OR
69019: PUSH
69020: LD_VAR 0 10
69024: NOT
69025: OR
69026: IFFALSE 69061
// begin result := [ chassis , engine , control , weapon ] ;
69028: LD_ADDR_VAR 0 6
69032: PUSH
69033: LD_VAR 0 2
69037: PUSH
69038: LD_VAR 0 3
69042: PUSH
69043: LD_VAR 0 4
69047: PUSH
69048: LD_VAR 0 5
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: LIST
69057: LIST
69058: ST_TO_ADDR
// exit ;
69059: GO 69352
// end ; if not chassis in _chassis then
69061: LD_VAR 0 2
69065: PUSH
69066: LD_VAR 0 9
69070: IN
69071: NOT
69072: IFFALSE 69098
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
69074: LD_ADDR_VAR 0 2
69078: PUSH
69079: LD_VAR 0 9
69083: PUSH
69084: LD_INT 1
69086: PPUSH
69087: LD_VAR 0 9
69091: PPUSH
69092: CALL_OW 12
69096: ARRAY
69097: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
69098: LD_VAR 0 2
69102: PPUSH
69103: LD_VAR 0 3
69107: PPUSH
69108: CALL 69357 0 2
69112: NOT
69113: IFFALSE 69172
// repeat engine := _engine [ 1 ] ;
69115: LD_ADDR_VAR 0 3
69119: PUSH
69120: LD_VAR 0 11
69124: PUSH
69125: LD_INT 1
69127: ARRAY
69128: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
69129: LD_ADDR_VAR 0 11
69133: PUSH
69134: LD_VAR 0 11
69138: PPUSH
69139: LD_INT 1
69141: PPUSH
69142: CALL_OW 3
69146: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
69147: LD_VAR 0 2
69151: PPUSH
69152: LD_VAR 0 3
69156: PPUSH
69157: CALL 69357 0 2
69161: PUSH
69162: LD_VAR 0 11
69166: PUSH
69167: EMPTY
69168: EQUAL
69169: OR
69170: IFFALSE 69115
// if not control in _control then
69172: LD_VAR 0 4
69176: PUSH
69177: LD_VAR 0 12
69181: IN
69182: NOT
69183: IFFALSE 69209
// control := _control [ rand ( 1 , _control ) ] ;
69185: LD_ADDR_VAR 0 4
69189: PUSH
69190: LD_VAR 0 12
69194: PUSH
69195: LD_INT 1
69197: PPUSH
69198: LD_VAR 0 12
69202: PPUSH
69203: CALL_OW 12
69207: ARRAY
69208: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
69209: LD_VAR 0 2
69213: PPUSH
69214: LD_VAR 0 5
69218: PPUSH
69219: CALL 69577 0 2
69223: NOT
69224: IFFALSE 69283
// repeat weapon := _weapon [ 1 ] ;
69226: LD_ADDR_VAR 0 5
69230: PUSH
69231: LD_VAR 0 10
69235: PUSH
69236: LD_INT 1
69238: ARRAY
69239: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
69240: LD_ADDR_VAR 0 10
69244: PUSH
69245: LD_VAR 0 10
69249: PPUSH
69250: LD_INT 1
69252: PPUSH
69253: CALL_OW 3
69257: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
69258: LD_VAR 0 2
69262: PPUSH
69263: LD_VAR 0 5
69267: PPUSH
69268: CALL 69577 0 2
69272: PUSH
69273: LD_VAR 0 10
69277: PUSH
69278: EMPTY
69279: EQUAL
69280: OR
69281: IFFALSE 69226
// result := [ ] ;
69283: LD_ADDR_VAR 0 6
69287: PUSH
69288: EMPTY
69289: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
69290: LD_VAR 0 1
69294: PPUSH
69295: LD_VAR 0 2
69299: PPUSH
69300: LD_VAR 0 3
69304: PPUSH
69305: LD_VAR 0 4
69309: PPUSH
69310: LD_VAR 0 5
69314: PPUSH
69315: CALL_OW 448
69319: IFFALSE 69352
// result := [ chassis , engine , control , weapon ] ;
69321: LD_ADDR_VAR 0 6
69325: PUSH
69326: LD_VAR 0 2
69330: PUSH
69331: LD_VAR 0 3
69335: PUSH
69336: LD_VAR 0 4
69340: PUSH
69341: LD_VAR 0 5
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: LIST
69350: LIST
69351: ST_TO_ADDR
// end ;
69352: LD_VAR 0 6
69356: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
69357: LD_INT 0
69359: PPUSH
// if not chassis or not engine then
69360: LD_VAR 0 1
69364: NOT
69365: PUSH
69366: LD_VAR 0 2
69370: NOT
69371: OR
69372: IFFALSE 69376
// exit ;
69374: GO 69572
// case engine of engine_solar :
69376: LD_VAR 0 2
69380: PUSH
69381: LD_INT 2
69383: DOUBLE
69384: EQUAL
69385: IFTRUE 69389
69387: GO 69427
69389: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
69390: LD_ADDR_VAR 0 3
69394: PUSH
69395: LD_INT 11
69397: PUSH
69398: LD_INT 12
69400: PUSH
69401: LD_INT 13
69403: PUSH
69404: LD_INT 14
69406: PUSH
69407: LD_INT 1
69409: PUSH
69410: LD_INT 2
69412: PUSH
69413: LD_INT 3
69415: PUSH
69416: EMPTY
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: ST_TO_ADDR
69425: GO 69556
69427: LD_INT 1
69429: DOUBLE
69430: EQUAL
69431: IFTRUE 69435
69433: GO 69497
69435: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
69436: LD_ADDR_VAR 0 3
69440: PUSH
69441: LD_INT 11
69443: PUSH
69444: LD_INT 12
69446: PUSH
69447: LD_INT 13
69449: PUSH
69450: LD_INT 14
69452: PUSH
69453: LD_INT 1
69455: PUSH
69456: LD_INT 2
69458: PUSH
69459: LD_INT 3
69461: PUSH
69462: LD_INT 4
69464: PUSH
69465: LD_INT 5
69467: PUSH
69468: LD_INT 21
69470: PUSH
69471: LD_INT 23
69473: PUSH
69474: LD_INT 22
69476: PUSH
69477: LD_INT 24
69479: PUSH
69480: EMPTY
69481: LIST
69482: LIST
69483: LIST
69484: LIST
69485: LIST
69486: LIST
69487: LIST
69488: LIST
69489: LIST
69490: LIST
69491: LIST
69492: LIST
69493: LIST
69494: ST_TO_ADDR
69495: GO 69556
69497: LD_INT 3
69499: DOUBLE
69500: EQUAL
69501: IFTRUE 69505
69503: GO 69555
69505: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
69506: LD_ADDR_VAR 0 3
69510: PUSH
69511: LD_INT 13
69513: PUSH
69514: LD_INT 14
69516: PUSH
69517: LD_INT 2
69519: PUSH
69520: LD_INT 3
69522: PUSH
69523: LD_INT 4
69525: PUSH
69526: LD_INT 5
69528: PUSH
69529: LD_INT 21
69531: PUSH
69532: LD_INT 22
69534: PUSH
69535: LD_INT 23
69537: PUSH
69538: LD_INT 24
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: LIST
69545: LIST
69546: LIST
69547: LIST
69548: LIST
69549: LIST
69550: LIST
69551: LIST
69552: ST_TO_ADDR
69553: GO 69556
69555: POP
// result := ( chassis in result ) ;
69556: LD_ADDR_VAR 0 3
69560: PUSH
69561: LD_VAR 0 1
69565: PUSH
69566: LD_VAR 0 3
69570: IN
69571: ST_TO_ADDR
// end ;
69572: LD_VAR 0 3
69576: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
69577: LD_INT 0
69579: PPUSH
// if not chassis or not weapon then
69580: LD_VAR 0 1
69584: NOT
69585: PUSH
69586: LD_VAR 0 2
69590: NOT
69591: OR
69592: IFFALSE 69596
// exit ;
69594: GO 70622
// case weapon of us_machine_gun :
69596: LD_VAR 0 2
69600: PUSH
69601: LD_INT 2
69603: DOUBLE
69604: EQUAL
69605: IFTRUE 69609
69607: GO 69639
69609: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
69610: LD_ADDR_VAR 0 3
69614: PUSH
69615: LD_INT 1
69617: PUSH
69618: LD_INT 2
69620: PUSH
69621: LD_INT 3
69623: PUSH
69624: LD_INT 4
69626: PUSH
69627: LD_INT 5
69629: PUSH
69630: EMPTY
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: ST_TO_ADDR
69637: GO 70606
69639: LD_INT 3
69641: DOUBLE
69642: EQUAL
69643: IFTRUE 69647
69645: GO 69677
69647: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
69648: LD_ADDR_VAR 0 3
69652: PUSH
69653: LD_INT 1
69655: PUSH
69656: LD_INT 2
69658: PUSH
69659: LD_INT 3
69661: PUSH
69662: LD_INT 4
69664: PUSH
69665: LD_INT 5
69667: PUSH
69668: EMPTY
69669: LIST
69670: LIST
69671: LIST
69672: LIST
69673: LIST
69674: ST_TO_ADDR
69675: GO 70606
69677: LD_INT 11
69679: DOUBLE
69680: EQUAL
69681: IFTRUE 69685
69683: GO 69715
69685: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
69686: LD_ADDR_VAR 0 3
69690: PUSH
69691: LD_INT 1
69693: PUSH
69694: LD_INT 2
69696: PUSH
69697: LD_INT 3
69699: PUSH
69700: LD_INT 4
69702: PUSH
69703: LD_INT 5
69705: PUSH
69706: EMPTY
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: LIST
69712: ST_TO_ADDR
69713: GO 70606
69715: LD_INT 4
69717: DOUBLE
69718: EQUAL
69719: IFTRUE 69723
69721: GO 69749
69723: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
69724: LD_ADDR_VAR 0 3
69728: PUSH
69729: LD_INT 2
69731: PUSH
69732: LD_INT 3
69734: PUSH
69735: LD_INT 4
69737: PUSH
69738: LD_INT 5
69740: PUSH
69741: EMPTY
69742: LIST
69743: LIST
69744: LIST
69745: LIST
69746: ST_TO_ADDR
69747: GO 70606
69749: LD_INT 5
69751: DOUBLE
69752: EQUAL
69753: IFTRUE 69757
69755: GO 69783
69757: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
69758: LD_ADDR_VAR 0 3
69762: PUSH
69763: LD_INT 2
69765: PUSH
69766: LD_INT 3
69768: PUSH
69769: LD_INT 4
69771: PUSH
69772: LD_INT 5
69774: PUSH
69775: EMPTY
69776: LIST
69777: LIST
69778: LIST
69779: LIST
69780: ST_TO_ADDR
69781: GO 70606
69783: LD_INT 9
69785: DOUBLE
69786: EQUAL
69787: IFTRUE 69791
69789: GO 69817
69791: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
69792: LD_ADDR_VAR 0 3
69796: PUSH
69797: LD_INT 2
69799: PUSH
69800: LD_INT 3
69802: PUSH
69803: LD_INT 4
69805: PUSH
69806: LD_INT 5
69808: PUSH
69809: EMPTY
69810: LIST
69811: LIST
69812: LIST
69813: LIST
69814: ST_TO_ADDR
69815: GO 70606
69817: LD_INT 7
69819: DOUBLE
69820: EQUAL
69821: IFTRUE 69825
69823: GO 69851
69825: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
69826: LD_ADDR_VAR 0 3
69830: PUSH
69831: LD_INT 2
69833: PUSH
69834: LD_INT 3
69836: PUSH
69837: LD_INT 4
69839: PUSH
69840: LD_INT 5
69842: PUSH
69843: EMPTY
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: ST_TO_ADDR
69849: GO 70606
69851: LD_INT 12
69853: DOUBLE
69854: EQUAL
69855: IFTRUE 69859
69857: GO 69885
69859: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
69860: LD_ADDR_VAR 0 3
69864: PUSH
69865: LD_INT 2
69867: PUSH
69868: LD_INT 3
69870: PUSH
69871: LD_INT 4
69873: PUSH
69874: LD_INT 5
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: LIST
69881: LIST
69882: ST_TO_ADDR
69883: GO 70606
69885: LD_INT 13
69887: DOUBLE
69888: EQUAL
69889: IFTRUE 69893
69891: GO 69919
69893: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
69894: LD_ADDR_VAR 0 3
69898: PUSH
69899: LD_INT 2
69901: PUSH
69902: LD_INT 3
69904: PUSH
69905: LD_INT 4
69907: PUSH
69908: LD_INT 5
69910: PUSH
69911: EMPTY
69912: LIST
69913: LIST
69914: LIST
69915: LIST
69916: ST_TO_ADDR
69917: GO 70606
69919: LD_INT 14
69921: DOUBLE
69922: EQUAL
69923: IFTRUE 69927
69925: GO 69945
69927: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
69928: LD_ADDR_VAR 0 3
69932: PUSH
69933: LD_INT 4
69935: PUSH
69936: LD_INT 5
69938: PUSH
69939: EMPTY
69940: LIST
69941: LIST
69942: ST_TO_ADDR
69943: GO 70606
69945: LD_INT 6
69947: DOUBLE
69948: EQUAL
69949: IFTRUE 69953
69951: GO 69971
69953: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
69954: LD_ADDR_VAR 0 3
69958: PUSH
69959: LD_INT 4
69961: PUSH
69962: LD_INT 5
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: ST_TO_ADDR
69969: GO 70606
69971: LD_INT 10
69973: DOUBLE
69974: EQUAL
69975: IFTRUE 69979
69977: GO 69997
69979: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
69980: LD_ADDR_VAR 0 3
69984: PUSH
69985: LD_INT 4
69987: PUSH
69988: LD_INT 5
69990: PUSH
69991: EMPTY
69992: LIST
69993: LIST
69994: ST_TO_ADDR
69995: GO 70606
69997: LD_INT 22
69999: DOUBLE
70000: EQUAL
70001: IFTRUE 70005
70003: GO 70031
70005: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
70006: LD_ADDR_VAR 0 3
70010: PUSH
70011: LD_INT 11
70013: PUSH
70014: LD_INT 12
70016: PUSH
70017: LD_INT 13
70019: PUSH
70020: LD_INT 14
70022: PUSH
70023: EMPTY
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: ST_TO_ADDR
70029: GO 70606
70031: LD_INT 23
70033: DOUBLE
70034: EQUAL
70035: IFTRUE 70039
70037: GO 70065
70039: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
70040: LD_ADDR_VAR 0 3
70044: PUSH
70045: LD_INT 11
70047: PUSH
70048: LD_INT 12
70050: PUSH
70051: LD_INT 13
70053: PUSH
70054: LD_INT 14
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: LIST
70061: LIST
70062: ST_TO_ADDR
70063: GO 70606
70065: LD_INT 24
70067: DOUBLE
70068: EQUAL
70069: IFTRUE 70073
70071: GO 70099
70073: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
70074: LD_ADDR_VAR 0 3
70078: PUSH
70079: LD_INT 11
70081: PUSH
70082: LD_INT 12
70084: PUSH
70085: LD_INT 13
70087: PUSH
70088: LD_INT 14
70090: PUSH
70091: EMPTY
70092: LIST
70093: LIST
70094: LIST
70095: LIST
70096: ST_TO_ADDR
70097: GO 70606
70099: LD_INT 30
70101: DOUBLE
70102: EQUAL
70103: IFTRUE 70107
70105: GO 70133
70107: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
70108: LD_ADDR_VAR 0 3
70112: PUSH
70113: LD_INT 11
70115: PUSH
70116: LD_INT 12
70118: PUSH
70119: LD_INT 13
70121: PUSH
70122: LD_INT 14
70124: PUSH
70125: EMPTY
70126: LIST
70127: LIST
70128: LIST
70129: LIST
70130: ST_TO_ADDR
70131: GO 70606
70133: LD_INT 25
70135: DOUBLE
70136: EQUAL
70137: IFTRUE 70141
70139: GO 70159
70141: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
70142: LD_ADDR_VAR 0 3
70146: PUSH
70147: LD_INT 13
70149: PUSH
70150: LD_INT 14
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: ST_TO_ADDR
70157: GO 70606
70159: LD_INT 27
70161: DOUBLE
70162: EQUAL
70163: IFTRUE 70167
70165: GO 70185
70167: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
70168: LD_ADDR_VAR 0 3
70172: PUSH
70173: LD_INT 13
70175: PUSH
70176: LD_INT 14
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: ST_TO_ADDR
70183: GO 70606
70185: LD_INT 28
70187: DOUBLE
70188: EQUAL
70189: IFTRUE 70193
70191: GO 70211
70193: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
70194: LD_ADDR_VAR 0 3
70198: PUSH
70199: LD_INT 13
70201: PUSH
70202: LD_INT 14
70204: PUSH
70205: EMPTY
70206: LIST
70207: LIST
70208: ST_TO_ADDR
70209: GO 70606
70211: LD_INT 29
70213: DOUBLE
70214: EQUAL
70215: IFTRUE 70219
70217: GO 70237
70219: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
70220: LD_ADDR_VAR 0 3
70224: PUSH
70225: LD_INT 13
70227: PUSH
70228: LD_INT 14
70230: PUSH
70231: EMPTY
70232: LIST
70233: LIST
70234: ST_TO_ADDR
70235: GO 70606
70237: LD_INT 31
70239: DOUBLE
70240: EQUAL
70241: IFTRUE 70245
70243: GO 70263
70245: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
70246: LD_ADDR_VAR 0 3
70250: PUSH
70251: LD_INT 13
70253: PUSH
70254: LD_INT 14
70256: PUSH
70257: EMPTY
70258: LIST
70259: LIST
70260: ST_TO_ADDR
70261: GO 70606
70263: LD_INT 26
70265: DOUBLE
70266: EQUAL
70267: IFTRUE 70271
70269: GO 70289
70271: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
70272: LD_ADDR_VAR 0 3
70276: PUSH
70277: LD_INT 13
70279: PUSH
70280: LD_INT 14
70282: PUSH
70283: EMPTY
70284: LIST
70285: LIST
70286: ST_TO_ADDR
70287: GO 70606
70289: LD_INT 42
70291: DOUBLE
70292: EQUAL
70293: IFTRUE 70297
70295: GO 70323
70297: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
70298: LD_ADDR_VAR 0 3
70302: PUSH
70303: LD_INT 21
70305: PUSH
70306: LD_INT 22
70308: PUSH
70309: LD_INT 23
70311: PUSH
70312: LD_INT 24
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: ST_TO_ADDR
70321: GO 70606
70323: LD_INT 43
70325: DOUBLE
70326: EQUAL
70327: IFTRUE 70331
70329: GO 70357
70331: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
70332: LD_ADDR_VAR 0 3
70336: PUSH
70337: LD_INT 21
70339: PUSH
70340: LD_INT 22
70342: PUSH
70343: LD_INT 23
70345: PUSH
70346: LD_INT 24
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: LIST
70353: LIST
70354: ST_TO_ADDR
70355: GO 70606
70357: LD_INT 44
70359: DOUBLE
70360: EQUAL
70361: IFTRUE 70365
70363: GO 70391
70365: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
70366: LD_ADDR_VAR 0 3
70370: PUSH
70371: LD_INT 21
70373: PUSH
70374: LD_INT 22
70376: PUSH
70377: LD_INT 23
70379: PUSH
70380: LD_INT 24
70382: PUSH
70383: EMPTY
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: ST_TO_ADDR
70389: GO 70606
70391: LD_INT 45
70393: DOUBLE
70394: EQUAL
70395: IFTRUE 70399
70397: GO 70425
70399: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
70400: LD_ADDR_VAR 0 3
70404: PUSH
70405: LD_INT 21
70407: PUSH
70408: LD_INT 22
70410: PUSH
70411: LD_INT 23
70413: PUSH
70414: LD_INT 24
70416: PUSH
70417: EMPTY
70418: LIST
70419: LIST
70420: LIST
70421: LIST
70422: ST_TO_ADDR
70423: GO 70606
70425: LD_INT 49
70427: DOUBLE
70428: EQUAL
70429: IFTRUE 70433
70431: GO 70459
70433: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
70434: LD_ADDR_VAR 0 3
70438: PUSH
70439: LD_INT 21
70441: PUSH
70442: LD_INT 22
70444: PUSH
70445: LD_INT 23
70447: PUSH
70448: LD_INT 24
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: LIST
70455: LIST
70456: ST_TO_ADDR
70457: GO 70606
70459: LD_INT 51
70461: DOUBLE
70462: EQUAL
70463: IFTRUE 70467
70465: GO 70493
70467: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
70468: LD_ADDR_VAR 0 3
70472: PUSH
70473: LD_INT 21
70475: PUSH
70476: LD_INT 22
70478: PUSH
70479: LD_INT 23
70481: PUSH
70482: LD_INT 24
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: LIST
70489: LIST
70490: ST_TO_ADDR
70491: GO 70606
70493: LD_INT 52
70495: DOUBLE
70496: EQUAL
70497: IFTRUE 70501
70499: GO 70527
70501: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
70502: LD_ADDR_VAR 0 3
70506: PUSH
70507: LD_INT 21
70509: PUSH
70510: LD_INT 22
70512: PUSH
70513: LD_INT 23
70515: PUSH
70516: LD_INT 24
70518: PUSH
70519: EMPTY
70520: LIST
70521: LIST
70522: LIST
70523: LIST
70524: ST_TO_ADDR
70525: GO 70606
70527: LD_INT 53
70529: DOUBLE
70530: EQUAL
70531: IFTRUE 70535
70533: GO 70553
70535: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
70536: LD_ADDR_VAR 0 3
70540: PUSH
70541: LD_INT 23
70543: PUSH
70544: LD_INT 24
70546: PUSH
70547: EMPTY
70548: LIST
70549: LIST
70550: ST_TO_ADDR
70551: GO 70606
70553: LD_INT 46
70555: DOUBLE
70556: EQUAL
70557: IFTRUE 70561
70559: GO 70579
70561: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
70562: LD_ADDR_VAR 0 3
70566: PUSH
70567: LD_INT 23
70569: PUSH
70570: LD_INT 24
70572: PUSH
70573: EMPTY
70574: LIST
70575: LIST
70576: ST_TO_ADDR
70577: GO 70606
70579: LD_INT 47
70581: DOUBLE
70582: EQUAL
70583: IFTRUE 70587
70585: GO 70605
70587: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
70588: LD_ADDR_VAR 0 3
70592: PUSH
70593: LD_INT 23
70595: PUSH
70596: LD_INT 24
70598: PUSH
70599: EMPTY
70600: LIST
70601: LIST
70602: ST_TO_ADDR
70603: GO 70606
70605: POP
// result := ( chassis in result ) ;
70606: LD_ADDR_VAR 0 3
70610: PUSH
70611: LD_VAR 0 1
70615: PUSH
70616: LD_VAR 0 3
70620: IN
70621: ST_TO_ADDR
// end ;
70622: LD_VAR 0 3
70626: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
70627: LD_INT 0
70629: PPUSH
70630: PPUSH
70631: PPUSH
70632: PPUSH
70633: PPUSH
70634: PPUSH
70635: PPUSH
// result := array ;
70636: LD_ADDR_VAR 0 5
70640: PUSH
70641: LD_VAR 0 1
70645: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
70646: LD_VAR 0 1
70650: NOT
70651: PUSH
70652: LD_VAR 0 2
70656: NOT
70657: OR
70658: PUSH
70659: LD_VAR 0 3
70663: NOT
70664: OR
70665: PUSH
70666: LD_VAR 0 2
70670: PUSH
70671: LD_VAR 0 1
70675: GREATER
70676: OR
70677: PUSH
70678: LD_VAR 0 3
70682: PUSH
70683: LD_VAR 0 1
70687: GREATER
70688: OR
70689: IFFALSE 70693
// exit ;
70691: GO 70989
// if direction then
70693: LD_VAR 0 4
70697: IFFALSE 70761
// begin d := 1 ;
70699: LD_ADDR_VAR 0 9
70703: PUSH
70704: LD_INT 1
70706: ST_TO_ADDR
// if i_from > i_to then
70707: LD_VAR 0 2
70711: PUSH
70712: LD_VAR 0 3
70716: GREATER
70717: IFFALSE 70743
// length := ( array - i_from ) + i_to else
70719: LD_ADDR_VAR 0 11
70723: PUSH
70724: LD_VAR 0 1
70728: PUSH
70729: LD_VAR 0 2
70733: MINUS
70734: PUSH
70735: LD_VAR 0 3
70739: PLUS
70740: ST_TO_ADDR
70741: GO 70759
// length := i_to - i_from ;
70743: LD_ADDR_VAR 0 11
70747: PUSH
70748: LD_VAR 0 3
70752: PUSH
70753: LD_VAR 0 2
70757: MINUS
70758: ST_TO_ADDR
// end else
70759: GO 70822
// begin d := - 1 ;
70761: LD_ADDR_VAR 0 9
70765: PUSH
70766: LD_INT 1
70768: NEG
70769: ST_TO_ADDR
// if i_from > i_to then
70770: LD_VAR 0 2
70774: PUSH
70775: LD_VAR 0 3
70779: GREATER
70780: IFFALSE 70800
// length := i_from - i_to else
70782: LD_ADDR_VAR 0 11
70786: PUSH
70787: LD_VAR 0 2
70791: PUSH
70792: LD_VAR 0 3
70796: MINUS
70797: ST_TO_ADDR
70798: GO 70822
// length := ( array - i_to ) + i_from ;
70800: LD_ADDR_VAR 0 11
70804: PUSH
70805: LD_VAR 0 1
70809: PUSH
70810: LD_VAR 0 3
70814: MINUS
70815: PUSH
70816: LD_VAR 0 2
70820: PLUS
70821: ST_TO_ADDR
// end ; if not length then
70822: LD_VAR 0 11
70826: NOT
70827: IFFALSE 70831
// exit ;
70829: GO 70989
// tmp := array ;
70831: LD_ADDR_VAR 0 10
70835: PUSH
70836: LD_VAR 0 1
70840: ST_TO_ADDR
// for i = 1 to length do
70841: LD_ADDR_VAR 0 6
70845: PUSH
70846: DOUBLE
70847: LD_INT 1
70849: DEC
70850: ST_TO_ADDR
70851: LD_VAR 0 11
70855: PUSH
70856: FOR_TO
70857: IFFALSE 70977
// begin for j = 1 to array do
70859: LD_ADDR_VAR 0 7
70863: PUSH
70864: DOUBLE
70865: LD_INT 1
70867: DEC
70868: ST_TO_ADDR
70869: LD_VAR 0 1
70873: PUSH
70874: FOR_TO
70875: IFFALSE 70963
// begin k := j + d ;
70877: LD_ADDR_VAR 0 8
70881: PUSH
70882: LD_VAR 0 7
70886: PUSH
70887: LD_VAR 0 9
70891: PLUS
70892: ST_TO_ADDR
// if k > array then
70893: LD_VAR 0 8
70897: PUSH
70898: LD_VAR 0 1
70902: GREATER
70903: IFFALSE 70913
// k := 1 ;
70905: LD_ADDR_VAR 0 8
70909: PUSH
70910: LD_INT 1
70912: ST_TO_ADDR
// if not k then
70913: LD_VAR 0 8
70917: NOT
70918: IFFALSE 70930
// k := array ;
70920: LD_ADDR_VAR 0 8
70924: PUSH
70925: LD_VAR 0 1
70929: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
70930: LD_ADDR_VAR 0 10
70934: PUSH
70935: LD_VAR 0 10
70939: PPUSH
70940: LD_VAR 0 8
70944: PPUSH
70945: LD_VAR 0 1
70949: PUSH
70950: LD_VAR 0 7
70954: ARRAY
70955: PPUSH
70956: CALL_OW 1
70960: ST_TO_ADDR
// end ;
70961: GO 70874
70963: POP
70964: POP
// array := tmp ;
70965: LD_ADDR_VAR 0 1
70969: PUSH
70970: LD_VAR 0 10
70974: ST_TO_ADDR
// end ;
70975: GO 70856
70977: POP
70978: POP
// result := array ;
70979: LD_ADDR_VAR 0 5
70983: PUSH
70984: LD_VAR 0 1
70988: ST_TO_ADDR
// end ;
70989: LD_VAR 0 5
70993: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
70994: LD_INT 0
70996: PPUSH
70997: PPUSH
// result := 0 ;
70998: LD_ADDR_VAR 0 3
71002: PUSH
71003: LD_INT 0
71005: ST_TO_ADDR
// if not array or not value in array then
71006: LD_VAR 0 1
71010: NOT
71011: PUSH
71012: LD_VAR 0 2
71016: PUSH
71017: LD_VAR 0 1
71021: IN
71022: NOT
71023: OR
71024: IFFALSE 71028
// exit ;
71026: GO 71082
// for i = 1 to array do
71028: LD_ADDR_VAR 0 4
71032: PUSH
71033: DOUBLE
71034: LD_INT 1
71036: DEC
71037: ST_TO_ADDR
71038: LD_VAR 0 1
71042: PUSH
71043: FOR_TO
71044: IFFALSE 71080
// if value = array [ i ] then
71046: LD_VAR 0 2
71050: PUSH
71051: LD_VAR 0 1
71055: PUSH
71056: LD_VAR 0 4
71060: ARRAY
71061: EQUAL
71062: IFFALSE 71078
// begin result := i ;
71064: LD_ADDR_VAR 0 3
71068: PUSH
71069: LD_VAR 0 4
71073: ST_TO_ADDR
// exit ;
71074: POP
71075: POP
71076: GO 71082
// end ;
71078: GO 71043
71080: POP
71081: POP
// end ;
71082: LD_VAR 0 3
71086: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
71087: LD_INT 0
71089: PPUSH
// vc_chassis := chassis ;
71090: LD_ADDR_OWVAR 37
71094: PUSH
71095: LD_VAR 0 1
71099: ST_TO_ADDR
// vc_engine := engine ;
71100: LD_ADDR_OWVAR 39
71104: PUSH
71105: LD_VAR 0 2
71109: ST_TO_ADDR
// vc_control := control ;
71110: LD_ADDR_OWVAR 38
71114: PUSH
71115: LD_VAR 0 3
71119: ST_TO_ADDR
// vc_weapon := weapon ;
71120: LD_ADDR_OWVAR 40
71124: PUSH
71125: LD_VAR 0 4
71129: ST_TO_ADDR
// vc_fuel_battery := fuel ;
71130: LD_ADDR_OWVAR 41
71134: PUSH
71135: LD_VAR 0 5
71139: ST_TO_ADDR
// end ;
71140: LD_VAR 0 6
71144: RET
// export function WantPlant ( unit ) ; var task ; begin
71145: LD_INT 0
71147: PPUSH
71148: PPUSH
// result := false ;
71149: LD_ADDR_VAR 0 2
71153: PUSH
71154: LD_INT 0
71156: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
71157: LD_ADDR_VAR 0 3
71161: PUSH
71162: LD_VAR 0 1
71166: PPUSH
71167: CALL_OW 437
71171: ST_TO_ADDR
// if task then
71172: LD_VAR 0 3
71176: IFFALSE 71204
// if task [ 1 ] [ 1 ] = p then
71178: LD_VAR 0 3
71182: PUSH
71183: LD_INT 1
71185: ARRAY
71186: PUSH
71187: LD_INT 1
71189: ARRAY
71190: PUSH
71191: LD_STRING p
71193: EQUAL
71194: IFFALSE 71204
// result := true ;
71196: LD_ADDR_VAR 0 2
71200: PUSH
71201: LD_INT 1
71203: ST_TO_ADDR
// end ;
71204: LD_VAR 0 2
71208: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
71209: LD_INT 0
71211: PPUSH
71212: PPUSH
71213: PPUSH
71214: PPUSH
// if pos < 1 then
71215: LD_VAR 0 2
71219: PUSH
71220: LD_INT 1
71222: LESS
71223: IFFALSE 71227
// exit ;
71225: GO 71530
// if pos = 1 then
71227: LD_VAR 0 2
71231: PUSH
71232: LD_INT 1
71234: EQUAL
71235: IFFALSE 71268
// result := Replace ( arr , pos [ 1 ] , value ) else
71237: LD_ADDR_VAR 0 4
71241: PUSH
71242: LD_VAR 0 1
71246: PPUSH
71247: LD_VAR 0 2
71251: PUSH
71252: LD_INT 1
71254: ARRAY
71255: PPUSH
71256: LD_VAR 0 3
71260: PPUSH
71261: CALL_OW 1
71265: ST_TO_ADDR
71266: GO 71530
// begin tmp := arr ;
71268: LD_ADDR_VAR 0 6
71272: PUSH
71273: LD_VAR 0 1
71277: ST_TO_ADDR
// s_arr := [ tmp ] ;
71278: LD_ADDR_VAR 0 7
71282: PUSH
71283: LD_VAR 0 6
71287: PUSH
71288: EMPTY
71289: LIST
71290: ST_TO_ADDR
// for i = 1 to pos - 1 do
71291: LD_ADDR_VAR 0 5
71295: PUSH
71296: DOUBLE
71297: LD_INT 1
71299: DEC
71300: ST_TO_ADDR
71301: LD_VAR 0 2
71305: PUSH
71306: LD_INT 1
71308: MINUS
71309: PUSH
71310: FOR_TO
71311: IFFALSE 71356
// begin tmp := tmp [ pos [ i ] ] ;
71313: LD_ADDR_VAR 0 6
71317: PUSH
71318: LD_VAR 0 6
71322: PUSH
71323: LD_VAR 0 2
71327: PUSH
71328: LD_VAR 0 5
71332: ARRAY
71333: ARRAY
71334: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
71335: LD_ADDR_VAR 0 7
71339: PUSH
71340: LD_VAR 0 7
71344: PUSH
71345: LD_VAR 0 6
71349: PUSH
71350: EMPTY
71351: LIST
71352: ADD
71353: ST_TO_ADDR
// end ;
71354: GO 71310
71356: POP
71357: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
71358: LD_ADDR_VAR 0 6
71362: PUSH
71363: LD_VAR 0 6
71367: PPUSH
71368: LD_VAR 0 2
71372: PUSH
71373: LD_VAR 0 2
71377: ARRAY
71378: PPUSH
71379: LD_VAR 0 3
71383: PPUSH
71384: CALL_OW 1
71388: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
71389: LD_ADDR_VAR 0 7
71393: PUSH
71394: LD_VAR 0 7
71398: PPUSH
71399: LD_VAR 0 7
71403: PPUSH
71404: LD_VAR 0 6
71408: PPUSH
71409: CALL_OW 1
71413: ST_TO_ADDR
// for i = s_arr downto 2 do
71414: LD_ADDR_VAR 0 5
71418: PUSH
71419: DOUBLE
71420: LD_VAR 0 7
71424: INC
71425: ST_TO_ADDR
71426: LD_INT 2
71428: PUSH
71429: FOR_DOWNTO
71430: IFFALSE 71514
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
71432: LD_ADDR_VAR 0 6
71436: PUSH
71437: LD_VAR 0 7
71441: PUSH
71442: LD_VAR 0 5
71446: PUSH
71447: LD_INT 1
71449: MINUS
71450: ARRAY
71451: PPUSH
71452: LD_VAR 0 2
71456: PUSH
71457: LD_VAR 0 5
71461: PUSH
71462: LD_INT 1
71464: MINUS
71465: ARRAY
71466: PPUSH
71467: LD_VAR 0 7
71471: PUSH
71472: LD_VAR 0 5
71476: ARRAY
71477: PPUSH
71478: CALL_OW 1
71482: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
71483: LD_ADDR_VAR 0 7
71487: PUSH
71488: LD_VAR 0 7
71492: PPUSH
71493: LD_VAR 0 5
71497: PUSH
71498: LD_INT 1
71500: MINUS
71501: PPUSH
71502: LD_VAR 0 6
71506: PPUSH
71507: CALL_OW 1
71511: ST_TO_ADDR
// end ;
71512: GO 71429
71514: POP
71515: POP
// result := s_arr [ 1 ] ;
71516: LD_ADDR_VAR 0 4
71520: PUSH
71521: LD_VAR 0 7
71525: PUSH
71526: LD_INT 1
71528: ARRAY
71529: ST_TO_ADDR
// end ; end ;
71530: LD_VAR 0 4
71534: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
71535: LD_INT 0
71537: PPUSH
71538: PPUSH
// if not list then
71539: LD_VAR 0 1
71543: NOT
71544: IFFALSE 71548
// exit ;
71546: GO 71639
// i := list [ pos1 ] ;
71548: LD_ADDR_VAR 0 5
71552: PUSH
71553: LD_VAR 0 1
71557: PUSH
71558: LD_VAR 0 2
71562: ARRAY
71563: ST_TO_ADDR
// if not i then
71564: LD_VAR 0 5
71568: NOT
71569: IFFALSE 71573
// exit ;
71571: GO 71639
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
71573: LD_ADDR_VAR 0 1
71577: PUSH
71578: LD_VAR 0 1
71582: PPUSH
71583: LD_VAR 0 2
71587: PPUSH
71588: LD_VAR 0 1
71592: PUSH
71593: LD_VAR 0 3
71597: ARRAY
71598: PPUSH
71599: CALL_OW 1
71603: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
71604: LD_ADDR_VAR 0 1
71608: PUSH
71609: LD_VAR 0 1
71613: PPUSH
71614: LD_VAR 0 3
71618: PPUSH
71619: LD_VAR 0 5
71623: PPUSH
71624: CALL_OW 1
71628: ST_TO_ADDR
// result := list ;
71629: LD_ADDR_VAR 0 4
71633: PUSH
71634: LD_VAR 0 1
71638: ST_TO_ADDR
// end ;
71639: LD_VAR 0 4
71643: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
71644: LD_INT 0
71646: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
71647: LD_ADDR_VAR 0 5
71651: PUSH
71652: LD_VAR 0 1
71656: PPUSH
71657: CALL_OW 250
71661: PPUSH
71662: LD_VAR 0 1
71666: PPUSH
71667: CALL_OW 251
71671: PPUSH
71672: LD_VAR 0 2
71676: PPUSH
71677: LD_VAR 0 3
71681: PPUSH
71682: LD_VAR 0 4
71686: PPUSH
71687: CALL 71697 0 5
71691: ST_TO_ADDR
// end ;
71692: LD_VAR 0 5
71696: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
71697: LD_INT 0
71699: PPUSH
71700: PPUSH
71701: PPUSH
71702: PPUSH
// if not list then
71703: LD_VAR 0 3
71707: NOT
71708: IFFALSE 71712
// exit ;
71710: GO 72100
// result := [ ] ;
71712: LD_ADDR_VAR 0 6
71716: PUSH
71717: EMPTY
71718: ST_TO_ADDR
// for i in list do
71719: LD_ADDR_VAR 0 7
71723: PUSH
71724: LD_VAR 0 3
71728: PUSH
71729: FOR_IN
71730: IFFALSE 71932
// begin tmp := GetDistUnitXY ( i , x , y ) ;
71732: LD_ADDR_VAR 0 9
71736: PUSH
71737: LD_VAR 0 7
71741: PPUSH
71742: LD_VAR 0 1
71746: PPUSH
71747: LD_VAR 0 2
71751: PPUSH
71752: CALL_OW 297
71756: ST_TO_ADDR
// if not result then
71757: LD_VAR 0 6
71761: NOT
71762: IFFALSE 71788
// result := [ [ i , tmp ] ] else
71764: LD_ADDR_VAR 0 6
71768: PUSH
71769: LD_VAR 0 7
71773: PUSH
71774: LD_VAR 0 9
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: PUSH
71783: EMPTY
71784: LIST
71785: ST_TO_ADDR
71786: GO 71930
// begin if result [ result ] [ 2 ] < tmp then
71788: LD_VAR 0 6
71792: PUSH
71793: LD_VAR 0 6
71797: ARRAY
71798: PUSH
71799: LD_INT 2
71801: ARRAY
71802: PUSH
71803: LD_VAR 0 9
71807: LESS
71808: IFFALSE 71850
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
71810: LD_ADDR_VAR 0 6
71814: PUSH
71815: LD_VAR 0 6
71819: PPUSH
71820: LD_VAR 0 6
71824: PUSH
71825: LD_INT 1
71827: PLUS
71828: PPUSH
71829: LD_VAR 0 7
71833: PUSH
71834: LD_VAR 0 9
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PPUSH
71843: CALL_OW 2
71847: ST_TO_ADDR
71848: GO 71930
// for j = 1 to result do
71850: LD_ADDR_VAR 0 8
71854: PUSH
71855: DOUBLE
71856: LD_INT 1
71858: DEC
71859: ST_TO_ADDR
71860: LD_VAR 0 6
71864: PUSH
71865: FOR_TO
71866: IFFALSE 71928
// begin if tmp < result [ j ] [ 2 ] then
71868: LD_VAR 0 9
71872: PUSH
71873: LD_VAR 0 6
71877: PUSH
71878: LD_VAR 0 8
71882: ARRAY
71883: PUSH
71884: LD_INT 2
71886: ARRAY
71887: LESS
71888: IFFALSE 71926
// begin result := Insert ( result , j , [ i , tmp ] ) ;
71890: LD_ADDR_VAR 0 6
71894: PUSH
71895: LD_VAR 0 6
71899: PPUSH
71900: LD_VAR 0 8
71904: PPUSH
71905: LD_VAR 0 7
71909: PUSH
71910: LD_VAR 0 9
71914: PUSH
71915: EMPTY
71916: LIST
71917: LIST
71918: PPUSH
71919: CALL_OW 2
71923: ST_TO_ADDR
// break ;
71924: GO 71928
// end ; end ;
71926: GO 71865
71928: POP
71929: POP
// end ; end ;
71930: GO 71729
71932: POP
71933: POP
// if result and not asc then
71934: LD_VAR 0 6
71938: PUSH
71939: LD_VAR 0 4
71943: NOT
71944: AND
71945: IFFALSE 72020
// begin tmp := result ;
71947: LD_ADDR_VAR 0 9
71951: PUSH
71952: LD_VAR 0 6
71956: ST_TO_ADDR
// for i = tmp downto 1 do
71957: LD_ADDR_VAR 0 7
71961: PUSH
71962: DOUBLE
71963: LD_VAR 0 9
71967: INC
71968: ST_TO_ADDR
71969: LD_INT 1
71971: PUSH
71972: FOR_DOWNTO
71973: IFFALSE 72018
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
71975: LD_ADDR_VAR 0 6
71979: PUSH
71980: LD_VAR 0 6
71984: PPUSH
71985: LD_VAR 0 9
71989: PUSH
71990: LD_VAR 0 7
71994: MINUS
71995: PUSH
71996: LD_INT 1
71998: PLUS
71999: PPUSH
72000: LD_VAR 0 9
72004: PUSH
72005: LD_VAR 0 7
72009: ARRAY
72010: PPUSH
72011: CALL_OW 1
72015: ST_TO_ADDR
72016: GO 71972
72018: POP
72019: POP
// end ; tmp := [ ] ;
72020: LD_ADDR_VAR 0 9
72024: PUSH
72025: EMPTY
72026: ST_TO_ADDR
// if mode then
72027: LD_VAR 0 5
72031: IFFALSE 72100
// begin for i = 1 to result do
72033: LD_ADDR_VAR 0 7
72037: PUSH
72038: DOUBLE
72039: LD_INT 1
72041: DEC
72042: ST_TO_ADDR
72043: LD_VAR 0 6
72047: PUSH
72048: FOR_TO
72049: IFFALSE 72088
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
72051: LD_ADDR_VAR 0 9
72055: PUSH
72056: LD_VAR 0 9
72060: PPUSH
72061: LD_VAR 0 7
72065: PPUSH
72066: LD_VAR 0 6
72070: PUSH
72071: LD_VAR 0 7
72075: ARRAY
72076: PUSH
72077: LD_INT 1
72079: ARRAY
72080: PPUSH
72081: CALL_OW 1
72085: ST_TO_ADDR
72086: GO 72048
72088: POP
72089: POP
// result := tmp ;
72090: LD_ADDR_VAR 0 6
72094: PUSH
72095: LD_VAR 0 9
72099: ST_TO_ADDR
// end ; end ;
72100: LD_VAR 0 6
72104: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
72105: LD_INT 0
72107: PPUSH
72108: PPUSH
72109: PPUSH
72110: PPUSH
72111: PPUSH
72112: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
72113: LD_ADDR_VAR 0 5
72117: PUSH
72118: LD_INT 0
72120: PUSH
72121: LD_INT 0
72123: PUSH
72124: LD_INT 0
72126: PUSH
72127: EMPTY
72128: PUSH
72129: EMPTY
72130: LIST
72131: LIST
72132: LIST
72133: LIST
72134: ST_TO_ADDR
// if not x or not y then
72135: LD_VAR 0 2
72139: NOT
72140: PUSH
72141: LD_VAR 0 3
72145: NOT
72146: OR
72147: IFFALSE 72151
// exit ;
72149: GO 73797
// if not range then
72151: LD_VAR 0 4
72155: NOT
72156: IFFALSE 72166
// range := 10 ;
72158: LD_ADDR_VAR 0 4
72162: PUSH
72163: LD_INT 10
72165: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
72166: LD_ADDR_VAR 0 8
72170: PUSH
72171: LD_INT 81
72173: PUSH
72174: LD_VAR 0 1
72178: PUSH
72179: EMPTY
72180: LIST
72181: LIST
72182: PUSH
72183: LD_INT 92
72185: PUSH
72186: LD_VAR 0 2
72190: PUSH
72191: LD_VAR 0 3
72195: PUSH
72196: LD_VAR 0 4
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: LIST
72205: LIST
72206: PUSH
72207: LD_INT 3
72209: PUSH
72210: LD_INT 21
72212: PUSH
72213: LD_INT 3
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: EMPTY
72221: LIST
72222: LIST
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: LIST
72228: PPUSH
72229: CALL_OW 69
72233: ST_TO_ADDR
// if not tmp then
72234: LD_VAR 0 8
72238: NOT
72239: IFFALSE 72243
// exit ;
72241: GO 73797
// for i in tmp do
72243: LD_ADDR_VAR 0 6
72247: PUSH
72248: LD_VAR 0 8
72252: PUSH
72253: FOR_IN
72254: IFFALSE 73772
// begin points := [ 0 , 0 , 0 ] ;
72256: LD_ADDR_VAR 0 9
72260: PUSH
72261: LD_INT 0
72263: PUSH
72264: LD_INT 0
72266: PUSH
72267: LD_INT 0
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: LIST
72274: ST_TO_ADDR
// bpoints := 1 ;
72275: LD_ADDR_VAR 0 10
72279: PUSH
72280: LD_INT 1
72282: ST_TO_ADDR
// case GetType ( i ) of unit_human :
72283: LD_VAR 0 6
72287: PPUSH
72288: CALL_OW 247
72292: PUSH
72293: LD_INT 1
72295: DOUBLE
72296: EQUAL
72297: IFTRUE 72301
72299: GO 72879
72301: POP
// begin if GetClass ( i ) = 1 then
72302: LD_VAR 0 6
72306: PPUSH
72307: CALL_OW 257
72311: PUSH
72312: LD_INT 1
72314: EQUAL
72315: IFFALSE 72336
// points := [ 10 , 5 , 3 ] ;
72317: LD_ADDR_VAR 0 9
72321: PUSH
72322: LD_INT 10
72324: PUSH
72325: LD_INT 5
72327: PUSH
72328: LD_INT 3
72330: PUSH
72331: EMPTY
72332: LIST
72333: LIST
72334: LIST
72335: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
72336: LD_VAR 0 6
72340: PPUSH
72341: CALL_OW 257
72345: PUSH
72346: LD_INT 2
72348: PUSH
72349: LD_INT 3
72351: PUSH
72352: LD_INT 4
72354: PUSH
72355: EMPTY
72356: LIST
72357: LIST
72358: LIST
72359: IN
72360: IFFALSE 72381
// points := [ 3 , 2 , 1 ] ;
72362: LD_ADDR_VAR 0 9
72366: PUSH
72367: LD_INT 3
72369: PUSH
72370: LD_INT 2
72372: PUSH
72373: LD_INT 1
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: LIST
72380: ST_TO_ADDR
// if GetClass ( i ) = 5 then
72381: LD_VAR 0 6
72385: PPUSH
72386: CALL_OW 257
72390: PUSH
72391: LD_INT 5
72393: EQUAL
72394: IFFALSE 72415
// points := [ 130 , 5 , 2 ] ;
72396: LD_ADDR_VAR 0 9
72400: PUSH
72401: LD_INT 130
72403: PUSH
72404: LD_INT 5
72406: PUSH
72407: LD_INT 2
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: LIST
72414: ST_TO_ADDR
// if GetClass ( i ) = 8 then
72415: LD_VAR 0 6
72419: PPUSH
72420: CALL_OW 257
72424: PUSH
72425: LD_INT 8
72427: EQUAL
72428: IFFALSE 72449
// points := [ 35 , 35 , 30 ] ;
72430: LD_ADDR_VAR 0 9
72434: PUSH
72435: LD_INT 35
72437: PUSH
72438: LD_INT 35
72440: PUSH
72441: LD_INT 30
72443: PUSH
72444: EMPTY
72445: LIST
72446: LIST
72447: LIST
72448: ST_TO_ADDR
// if GetClass ( i ) = 9 then
72449: LD_VAR 0 6
72453: PPUSH
72454: CALL_OW 257
72458: PUSH
72459: LD_INT 9
72461: EQUAL
72462: IFFALSE 72483
// points := [ 20 , 55 , 40 ] ;
72464: LD_ADDR_VAR 0 9
72468: PUSH
72469: LD_INT 20
72471: PUSH
72472: LD_INT 55
72474: PUSH
72475: LD_INT 40
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: LIST
72482: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
72483: LD_VAR 0 6
72487: PPUSH
72488: CALL_OW 257
72492: PUSH
72493: LD_INT 12
72495: PUSH
72496: LD_INT 16
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: IN
72503: IFFALSE 72524
// points := [ 5 , 3 , 2 ] ;
72505: LD_ADDR_VAR 0 9
72509: PUSH
72510: LD_INT 5
72512: PUSH
72513: LD_INT 3
72515: PUSH
72516: LD_INT 2
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: LIST
72523: ST_TO_ADDR
// if GetClass ( i ) = 17 then
72524: LD_VAR 0 6
72528: PPUSH
72529: CALL_OW 257
72533: PUSH
72534: LD_INT 17
72536: EQUAL
72537: IFFALSE 72558
// points := [ 100 , 50 , 75 ] ;
72539: LD_ADDR_VAR 0 9
72543: PUSH
72544: LD_INT 100
72546: PUSH
72547: LD_INT 50
72549: PUSH
72550: LD_INT 75
72552: PUSH
72553: EMPTY
72554: LIST
72555: LIST
72556: LIST
72557: ST_TO_ADDR
// if GetClass ( i ) = 15 then
72558: LD_VAR 0 6
72562: PPUSH
72563: CALL_OW 257
72567: PUSH
72568: LD_INT 15
72570: EQUAL
72571: IFFALSE 72592
// points := [ 10 , 5 , 3 ] ;
72573: LD_ADDR_VAR 0 9
72577: PUSH
72578: LD_INT 10
72580: PUSH
72581: LD_INT 5
72583: PUSH
72584: LD_INT 3
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: LIST
72591: ST_TO_ADDR
// if GetClass ( i ) = 14 then
72592: LD_VAR 0 6
72596: PPUSH
72597: CALL_OW 257
72601: PUSH
72602: LD_INT 14
72604: EQUAL
72605: IFFALSE 72626
// points := [ 10 , 0 , 0 ] ;
72607: LD_ADDR_VAR 0 9
72611: PUSH
72612: LD_INT 10
72614: PUSH
72615: LD_INT 0
72617: PUSH
72618: LD_INT 0
72620: PUSH
72621: EMPTY
72622: LIST
72623: LIST
72624: LIST
72625: ST_TO_ADDR
// if GetClass ( i ) = 11 then
72626: LD_VAR 0 6
72630: PPUSH
72631: CALL_OW 257
72635: PUSH
72636: LD_INT 11
72638: EQUAL
72639: IFFALSE 72660
// points := [ 30 , 10 , 5 ] ;
72641: LD_ADDR_VAR 0 9
72645: PUSH
72646: LD_INT 30
72648: PUSH
72649: LD_INT 10
72651: PUSH
72652: LD_INT 5
72654: PUSH
72655: EMPTY
72656: LIST
72657: LIST
72658: LIST
72659: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
72660: LD_VAR 0 1
72664: PPUSH
72665: LD_INT 5
72667: PPUSH
72668: CALL_OW 321
72672: PUSH
72673: LD_INT 2
72675: EQUAL
72676: IFFALSE 72693
// bpoints := bpoints * 1.8 ;
72678: LD_ADDR_VAR 0 10
72682: PUSH
72683: LD_VAR 0 10
72687: PUSH
72688: LD_REAL  1.80000000000000E+0000
72691: MUL
72692: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
72693: LD_VAR 0 6
72697: PPUSH
72698: CALL_OW 257
72702: PUSH
72703: LD_INT 1
72705: PUSH
72706: LD_INT 2
72708: PUSH
72709: LD_INT 3
72711: PUSH
72712: LD_INT 4
72714: PUSH
72715: EMPTY
72716: LIST
72717: LIST
72718: LIST
72719: LIST
72720: IN
72721: PUSH
72722: LD_VAR 0 1
72726: PPUSH
72727: LD_INT 51
72729: PPUSH
72730: CALL_OW 321
72734: PUSH
72735: LD_INT 2
72737: EQUAL
72738: AND
72739: IFFALSE 72756
// bpoints := bpoints * 1.2 ;
72741: LD_ADDR_VAR 0 10
72745: PUSH
72746: LD_VAR 0 10
72750: PUSH
72751: LD_REAL  1.20000000000000E+0000
72754: MUL
72755: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
72756: LD_VAR 0 6
72760: PPUSH
72761: CALL_OW 257
72765: PUSH
72766: LD_INT 5
72768: PUSH
72769: LD_INT 7
72771: PUSH
72772: LD_INT 9
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: LIST
72779: IN
72780: PUSH
72781: LD_VAR 0 1
72785: PPUSH
72786: LD_INT 52
72788: PPUSH
72789: CALL_OW 321
72793: PUSH
72794: LD_INT 2
72796: EQUAL
72797: AND
72798: IFFALSE 72815
// bpoints := bpoints * 1.5 ;
72800: LD_ADDR_VAR 0 10
72804: PUSH
72805: LD_VAR 0 10
72809: PUSH
72810: LD_REAL  1.50000000000000E+0000
72813: MUL
72814: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
72815: LD_VAR 0 1
72819: PPUSH
72820: LD_INT 66
72822: PPUSH
72823: CALL_OW 321
72827: PUSH
72828: LD_INT 2
72830: EQUAL
72831: IFFALSE 72848
// bpoints := bpoints * 1.1 ;
72833: LD_ADDR_VAR 0 10
72837: PUSH
72838: LD_VAR 0 10
72842: PUSH
72843: LD_REAL  1.10000000000000E+0000
72846: MUL
72847: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
72848: LD_ADDR_VAR 0 10
72852: PUSH
72853: LD_VAR 0 10
72857: PUSH
72858: LD_VAR 0 6
72862: PPUSH
72863: LD_INT 1
72865: PPUSH
72866: CALL_OW 259
72870: PUSH
72871: LD_REAL  1.15000000000000E+0000
72874: MUL
72875: MUL
72876: ST_TO_ADDR
// end ; unit_vehicle :
72877: GO 73701
72879: LD_INT 2
72881: DOUBLE
72882: EQUAL
72883: IFTRUE 72887
72885: GO 73689
72887: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
72888: LD_VAR 0 6
72892: PPUSH
72893: CALL_OW 264
72897: PUSH
72898: LD_INT 2
72900: PUSH
72901: LD_INT 42
72903: PUSH
72904: LD_INT 24
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: LIST
72911: IN
72912: IFFALSE 72933
// points := [ 25 , 5 , 3 ] ;
72914: LD_ADDR_VAR 0 9
72918: PUSH
72919: LD_INT 25
72921: PUSH
72922: LD_INT 5
72924: PUSH
72925: LD_INT 3
72927: PUSH
72928: EMPTY
72929: LIST
72930: LIST
72931: LIST
72932: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
72933: LD_VAR 0 6
72937: PPUSH
72938: CALL_OW 264
72942: PUSH
72943: LD_INT 4
72945: PUSH
72946: LD_INT 43
72948: PUSH
72949: LD_INT 25
72951: PUSH
72952: EMPTY
72953: LIST
72954: LIST
72955: LIST
72956: IN
72957: IFFALSE 72978
// points := [ 40 , 15 , 5 ] ;
72959: LD_ADDR_VAR 0 9
72963: PUSH
72964: LD_INT 40
72966: PUSH
72967: LD_INT 15
72969: PUSH
72970: LD_INT 5
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: LIST
72977: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
72978: LD_VAR 0 6
72982: PPUSH
72983: CALL_OW 264
72987: PUSH
72988: LD_INT 3
72990: PUSH
72991: LD_INT 23
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: IN
72998: IFFALSE 73019
// points := [ 7 , 25 , 8 ] ;
73000: LD_ADDR_VAR 0 9
73004: PUSH
73005: LD_INT 7
73007: PUSH
73008: LD_INT 25
73010: PUSH
73011: LD_INT 8
73013: PUSH
73014: EMPTY
73015: LIST
73016: LIST
73017: LIST
73018: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
73019: LD_VAR 0 6
73023: PPUSH
73024: CALL_OW 264
73028: PUSH
73029: LD_INT 5
73031: PUSH
73032: LD_INT 27
73034: PUSH
73035: LD_INT 44
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: LIST
73042: IN
73043: IFFALSE 73064
// points := [ 14 , 50 , 16 ] ;
73045: LD_ADDR_VAR 0 9
73049: PUSH
73050: LD_INT 14
73052: PUSH
73053: LD_INT 50
73055: PUSH
73056: LD_INT 16
73058: PUSH
73059: EMPTY
73060: LIST
73061: LIST
73062: LIST
73063: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
73064: LD_VAR 0 6
73068: PPUSH
73069: CALL_OW 264
73073: PUSH
73074: LD_INT 6
73076: PUSH
73077: LD_INT 46
73079: PUSH
73080: EMPTY
73081: LIST
73082: LIST
73083: IN
73084: IFFALSE 73105
// points := [ 32 , 120 , 70 ] ;
73086: LD_ADDR_VAR 0 9
73090: PUSH
73091: LD_INT 32
73093: PUSH
73094: LD_INT 120
73096: PUSH
73097: LD_INT 70
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: LIST
73104: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
73105: LD_VAR 0 6
73109: PPUSH
73110: CALL_OW 264
73114: PUSH
73115: LD_INT 7
73117: PUSH
73118: LD_INT 28
73120: PUSH
73121: LD_INT 45
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: LIST
73128: IN
73129: IFFALSE 73150
// points := [ 35 , 20 , 45 ] ;
73131: LD_ADDR_VAR 0 9
73135: PUSH
73136: LD_INT 35
73138: PUSH
73139: LD_INT 20
73141: PUSH
73142: LD_INT 45
73144: PUSH
73145: EMPTY
73146: LIST
73147: LIST
73148: LIST
73149: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
73150: LD_VAR 0 6
73154: PPUSH
73155: CALL_OW 264
73159: PUSH
73160: LD_INT 47
73162: PUSH
73163: EMPTY
73164: LIST
73165: IN
73166: IFFALSE 73187
// points := [ 67 , 45 , 75 ] ;
73168: LD_ADDR_VAR 0 9
73172: PUSH
73173: LD_INT 67
73175: PUSH
73176: LD_INT 45
73178: PUSH
73179: LD_INT 75
73181: PUSH
73182: EMPTY
73183: LIST
73184: LIST
73185: LIST
73186: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
73187: LD_VAR 0 6
73191: PPUSH
73192: CALL_OW 264
73196: PUSH
73197: LD_INT 26
73199: PUSH
73200: EMPTY
73201: LIST
73202: IN
73203: IFFALSE 73224
// points := [ 120 , 30 , 80 ] ;
73205: LD_ADDR_VAR 0 9
73209: PUSH
73210: LD_INT 120
73212: PUSH
73213: LD_INT 30
73215: PUSH
73216: LD_INT 80
73218: PUSH
73219: EMPTY
73220: LIST
73221: LIST
73222: LIST
73223: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
73224: LD_VAR 0 6
73228: PPUSH
73229: CALL_OW 264
73233: PUSH
73234: LD_INT 22
73236: PUSH
73237: EMPTY
73238: LIST
73239: IN
73240: IFFALSE 73261
// points := [ 40 , 1 , 1 ] ;
73242: LD_ADDR_VAR 0 9
73246: PUSH
73247: LD_INT 40
73249: PUSH
73250: LD_INT 1
73252: PUSH
73253: LD_INT 1
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: LIST
73260: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
73261: LD_VAR 0 6
73265: PPUSH
73266: CALL_OW 264
73270: PUSH
73271: LD_INT 29
73273: PUSH
73274: EMPTY
73275: LIST
73276: IN
73277: IFFALSE 73298
// points := [ 70 , 200 , 400 ] ;
73279: LD_ADDR_VAR 0 9
73283: PUSH
73284: LD_INT 70
73286: PUSH
73287: LD_INT 200
73289: PUSH
73290: LD_INT 400
73292: PUSH
73293: EMPTY
73294: LIST
73295: LIST
73296: LIST
73297: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
73298: LD_VAR 0 6
73302: PPUSH
73303: CALL_OW 264
73307: PUSH
73308: LD_INT 14
73310: PUSH
73311: LD_INT 53
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: IN
73318: IFFALSE 73339
// points := [ 40 , 10 , 20 ] ;
73320: LD_ADDR_VAR 0 9
73324: PUSH
73325: LD_INT 40
73327: PUSH
73328: LD_INT 10
73330: PUSH
73331: LD_INT 20
73333: PUSH
73334: EMPTY
73335: LIST
73336: LIST
73337: LIST
73338: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
73339: LD_VAR 0 6
73343: PPUSH
73344: CALL_OW 264
73348: PUSH
73349: LD_INT 9
73351: PUSH
73352: EMPTY
73353: LIST
73354: IN
73355: IFFALSE 73376
// points := [ 5 , 70 , 20 ] ;
73357: LD_ADDR_VAR 0 9
73361: PUSH
73362: LD_INT 5
73364: PUSH
73365: LD_INT 70
73367: PUSH
73368: LD_INT 20
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: LIST
73375: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
73376: LD_VAR 0 6
73380: PPUSH
73381: CALL_OW 264
73385: PUSH
73386: LD_INT 10
73388: PUSH
73389: EMPTY
73390: LIST
73391: IN
73392: IFFALSE 73413
// points := [ 35 , 110 , 70 ] ;
73394: LD_ADDR_VAR 0 9
73398: PUSH
73399: LD_INT 35
73401: PUSH
73402: LD_INT 110
73404: PUSH
73405: LD_INT 70
73407: PUSH
73408: EMPTY
73409: LIST
73410: LIST
73411: LIST
73412: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
73413: LD_VAR 0 6
73417: PPUSH
73418: CALL_OW 265
73422: PUSH
73423: LD_INT 25
73425: EQUAL
73426: IFFALSE 73447
// points := [ 80 , 65 , 100 ] ;
73428: LD_ADDR_VAR 0 9
73432: PUSH
73433: LD_INT 80
73435: PUSH
73436: LD_INT 65
73438: PUSH
73439: LD_INT 100
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: LIST
73446: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
73447: LD_VAR 0 6
73451: PPUSH
73452: CALL_OW 263
73456: PUSH
73457: LD_INT 1
73459: EQUAL
73460: IFFALSE 73495
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
73462: LD_ADDR_VAR 0 10
73466: PUSH
73467: LD_VAR 0 10
73471: PUSH
73472: LD_VAR 0 6
73476: PPUSH
73477: CALL_OW 311
73481: PPUSH
73482: LD_INT 3
73484: PPUSH
73485: CALL_OW 259
73489: PUSH
73490: LD_INT 4
73492: MUL
73493: MUL
73494: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
73495: LD_VAR 0 6
73499: PPUSH
73500: CALL_OW 263
73504: PUSH
73505: LD_INT 2
73507: EQUAL
73508: IFFALSE 73559
// begin j := IsControledBy ( i ) ;
73510: LD_ADDR_VAR 0 7
73514: PUSH
73515: LD_VAR 0 6
73519: PPUSH
73520: CALL_OW 312
73524: ST_TO_ADDR
// if j then
73525: LD_VAR 0 7
73529: IFFALSE 73559
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
73531: LD_ADDR_VAR 0 10
73535: PUSH
73536: LD_VAR 0 10
73540: PUSH
73541: LD_VAR 0 7
73545: PPUSH
73546: LD_INT 3
73548: PPUSH
73549: CALL_OW 259
73553: PUSH
73554: LD_INT 3
73556: MUL
73557: MUL
73558: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
73559: LD_VAR 0 6
73563: PPUSH
73564: CALL_OW 264
73568: PUSH
73569: LD_INT 5
73571: PUSH
73572: LD_INT 6
73574: PUSH
73575: LD_INT 46
73577: PUSH
73578: LD_INT 44
73580: PUSH
73581: LD_INT 47
73583: PUSH
73584: LD_INT 45
73586: PUSH
73587: LD_INT 28
73589: PUSH
73590: LD_INT 7
73592: PUSH
73593: LD_INT 27
73595: PUSH
73596: LD_INT 29
73598: PUSH
73599: EMPTY
73600: LIST
73601: LIST
73602: LIST
73603: LIST
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: IN
73611: PUSH
73612: LD_VAR 0 1
73616: PPUSH
73617: LD_INT 52
73619: PPUSH
73620: CALL_OW 321
73624: PUSH
73625: LD_INT 2
73627: EQUAL
73628: AND
73629: IFFALSE 73646
// bpoints := bpoints * 1.2 ;
73631: LD_ADDR_VAR 0 10
73635: PUSH
73636: LD_VAR 0 10
73640: PUSH
73641: LD_REAL  1.20000000000000E+0000
73644: MUL
73645: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
73646: LD_VAR 0 6
73650: PPUSH
73651: CALL_OW 264
73655: PUSH
73656: LD_INT 6
73658: PUSH
73659: LD_INT 46
73661: PUSH
73662: LD_INT 47
73664: PUSH
73665: EMPTY
73666: LIST
73667: LIST
73668: LIST
73669: IN
73670: IFFALSE 73687
// bpoints := bpoints * 1.2 ;
73672: LD_ADDR_VAR 0 10
73676: PUSH
73677: LD_VAR 0 10
73681: PUSH
73682: LD_REAL  1.20000000000000E+0000
73685: MUL
73686: ST_TO_ADDR
// end ; unit_building :
73687: GO 73701
73689: LD_INT 3
73691: DOUBLE
73692: EQUAL
73693: IFTRUE 73697
73695: GO 73700
73697: POP
// ; end ;
73698: GO 73701
73700: POP
// for j = 1 to 3 do
73701: LD_ADDR_VAR 0 7
73705: PUSH
73706: DOUBLE
73707: LD_INT 1
73709: DEC
73710: ST_TO_ADDR
73711: LD_INT 3
73713: PUSH
73714: FOR_TO
73715: IFFALSE 73768
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
73717: LD_ADDR_VAR 0 5
73721: PUSH
73722: LD_VAR 0 5
73726: PPUSH
73727: LD_VAR 0 7
73731: PPUSH
73732: LD_VAR 0 5
73736: PUSH
73737: LD_VAR 0 7
73741: ARRAY
73742: PUSH
73743: LD_VAR 0 9
73747: PUSH
73748: LD_VAR 0 7
73752: ARRAY
73753: PUSH
73754: LD_VAR 0 10
73758: MUL
73759: PLUS
73760: PPUSH
73761: CALL_OW 1
73765: ST_TO_ADDR
73766: GO 73714
73768: POP
73769: POP
// end ;
73770: GO 72253
73772: POP
73773: POP
// result := Replace ( result , 4 , tmp ) ;
73774: LD_ADDR_VAR 0 5
73778: PUSH
73779: LD_VAR 0 5
73783: PPUSH
73784: LD_INT 4
73786: PPUSH
73787: LD_VAR 0 8
73791: PPUSH
73792: CALL_OW 1
73796: ST_TO_ADDR
// end ;
73797: LD_VAR 0 5
73801: RET
// export function DangerAtRange ( unit , range ) ; begin
73802: LD_INT 0
73804: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
73805: LD_ADDR_VAR 0 3
73809: PUSH
73810: LD_VAR 0 1
73814: PPUSH
73815: CALL_OW 255
73819: PPUSH
73820: LD_VAR 0 1
73824: PPUSH
73825: CALL_OW 250
73829: PPUSH
73830: LD_VAR 0 1
73834: PPUSH
73835: CALL_OW 251
73839: PPUSH
73840: LD_VAR 0 2
73844: PPUSH
73845: CALL 72105 0 4
73849: ST_TO_ADDR
// end ;
73850: LD_VAR 0 3
73854: RET
// export function DangerInArea ( side , area ) ; begin
73855: LD_INT 0
73857: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
73858: LD_ADDR_VAR 0 3
73862: PUSH
73863: LD_VAR 0 2
73867: PPUSH
73868: LD_INT 81
73870: PUSH
73871: LD_VAR 0 1
73875: PUSH
73876: EMPTY
73877: LIST
73878: LIST
73879: PPUSH
73880: CALL_OW 70
73884: ST_TO_ADDR
// end ;
73885: LD_VAR 0 3
73889: RET
// export function IsExtension ( b ) ; begin
73890: LD_INT 0
73892: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
73893: LD_ADDR_VAR 0 2
73897: PUSH
73898: LD_VAR 0 1
73902: PUSH
73903: LD_INT 23
73905: PUSH
73906: LD_INT 20
73908: PUSH
73909: LD_INT 22
73911: PUSH
73912: LD_INT 17
73914: PUSH
73915: LD_INT 24
73917: PUSH
73918: LD_INT 21
73920: PUSH
73921: LD_INT 19
73923: PUSH
73924: LD_INT 16
73926: PUSH
73927: LD_INT 25
73929: PUSH
73930: LD_INT 18
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: LIST
73937: LIST
73938: LIST
73939: LIST
73940: LIST
73941: LIST
73942: LIST
73943: LIST
73944: IN
73945: ST_TO_ADDR
// end ;
73946: LD_VAR 0 2
73950: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
73951: LD_INT 0
73953: PPUSH
73954: PPUSH
73955: PPUSH
// result := [ ] ;
73956: LD_ADDR_VAR 0 3
73960: PUSH
73961: EMPTY
73962: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
73963: LD_ADDR_VAR 0 4
73967: PUSH
73968: LD_VAR 0 2
73972: PPUSH
73973: LD_INT 21
73975: PUSH
73976: LD_INT 3
73978: PUSH
73979: EMPTY
73980: LIST
73981: LIST
73982: PPUSH
73983: CALL_OW 70
73987: ST_TO_ADDR
// if not tmp then
73988: LD_VAR 0 4
73992: NOT
73993: IFFALSE 73997
// exit ;
73995: GO 74055
// for i in tmp do
73997: LD_ADDR_VAR 0 5
74001: PUSH
74002: LD_VAR 0 4
74006: PUSH
74007: FOR_IN
74008: IFFALSE 74043
// if GetBase ( i ) <> base then
74010: LD_VAR 0 5
74014: PPUSH
74015: CALL_OW 274
74019: PUSH
74020: LD_VAR 0 1
74024: NONEQUAL
74025: IFFALSE 74041
// ComLinkToBase ( base , i ) ;
74027: LD_VAR 0 1
74031: PPUSH
74032: LD_VAR 0 5
74036: PPUSH
74037: CALL_OW 169
74041: GO 74007
74043: POP
74044: POP
// result := tmp ;
74045: LD_ADDR_VAR 0 3
74049: PUSH
74050: LD_VAR 0 4
74054: ST_TO_ADDR
// end ;
74055: LD_VAR 0 3
74059: RET
// export function ComComplete ( unit , b ) ; var i ; begin
74060: LD_INT 0
74062: PPUSH
74063: PPUSH
// if BuildingStatus ( b ) = bs_build then
74064: LD_VAR 0 2
74068: PPUSH
74069: CALL_OW 461
74073: PUSH
74074: LD_INT 1
74076: EQUAL
74077: IFFALSE 74137
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
74079: LD_VAR 0 1
74083: PPUSH
74084: LD_STRING h
74086: PUSH
74087: LD_VAR 0 2
74091: PPUSH
74092: CALL_OW 250
74096: PUSH
74097: LD_VAR 0 2
74101: PPUSH
74102: CALL_OW 251
74106: PUSH
74107: LD_VAR 0 2
74111: PUSH
74112: LD_INT 0
74114: PUSH
74115: LD_INT 0
74117: PUSH
74118: LD_INT 0
74120: PUSH
74121: EMPTY
74122: LIST
74123: LIST
74124: LIST
74125: LIST
74126: LIST
74127: LIST
74128: LIST
74129: PUSH
74130: EMPTY
74131: LIST
74132: PPUSH
74133: CALL_OW 446
// end ;
74137: LD_VAR 0 3
74141: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
74142: LD_INT 0
74144: PPUSH
74145: PPUSH
74146: PPUSH
74147: PPUSH
74148: PPUSH
74149: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
74150: LD_VAR 0 1
74154: NOT
74155: PUSH
74156: LD_VAR 0 1
74160: PPUSH
74161: CALL_OW 263
74165: PUSH
74166: LD_INT 2
74168: EQUAL
74169: NOT
74170: OR
74171: IFFALSE 74175
// exit ;
74173: GO 74491
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
74175: LD_ADDR_VAR 0 6
74179: PUSH
74180: LD_INT 22
74182: PUSH
74183: LD_VAR 0 1
74187: PPUSH
74188: CALL_OW 255
74192: PUSH
74193: EMPTY
74194: LIST
74195: LIST
74196: PUSH
74197: LD_INT 2
74199: PUSH
74200: LD_INT 30
74202: PUSH
74203: LD_INT 36
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: LD_INT 34
74212: PUSH
74213: LD_INT 31
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: LIST
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PPUSH
74229: CALL_OW 69
74233: ST_TO_ADDR
// if not tmp then
74234: LD_VAR 0 6
74238: NOT
74239: IFFALSE 74243
// exit ;
74241: GO 74491
// result := [ ] ;
74243: LD_ADDR_VAR 0 2
74247: PUSH
74248: EMPTY
74249: ST_TO_ADDR
// for i in tmp do
74250: LD_ADDR_VAR 0 3
74254: PUSH
74255: LD_VAR 0 6
74259: PUSH
74260: FOR_IN
74261: IFFALSE 74332
// begin t := UnitsInside ( i ) ;
74263: LD_ADDR_VAR 0 4
74267: PUSH
74268: LD_VAR 0 3
74272: PPUSH
74273: CALL_OW 313
74277: ST_TO_ADDR
// if t then
74278: LD_VAR 0 4
74282: IFFALSE 74330
// for j in t do
74284: LD_ADDR_VAR 0 7
74288: PUSH
74289: LD_VAR 0 4
74293: PUSH
74294: FOR_IN
74295: IFFALSE 74328
// result := Insert ( result , result + 1 , j ) ;
74297: LD_ADDR_VAR 0 2
74301: PUSH
74302: LD_VAR 0 2
74306: PPUSH
74307: LD_VAR 0 2
74311: PUSH
74312: LD_INT 1
74314: PLUS
74315: PPUSH
74316: LD_VAR 0 7
74320: PPUSH
74321: CALL_OW 2
74325: ST_TO_ADDR
74326: GO 74294
74328: POP
74329: POP
// end ;
74330: GO 74260
74332: POP
74333: POP
// if not result then
74334: LD_VAR 0 2
74338: NOT
74339: IFFALSE 74343
// exit ;
74341: GO 74491
// mech := result [ 1 ] ;
74343: LD_ADDR_VAR 0 5
74347: PUSH
74348: LD_VAR 0 2
74352: PUSH
74353: LD_INT 1
74355: ARRAY
74356: ST_TO_ADDR
// if result > 1 then
74357: LD_VAR 0 2
74361: PUSH
74362: LD_INT 1
74364: GREATER
74365: IFFALSE 74477
// for i = 2 to result do
74367: LD_ADDR_VAR 0 3
74371: PUSH
74372: DOUBLE
74373: LD_INT 2
74375: DEC
74376: ST_TO_ADDR
74377: LD_VAR 0 2
74381: PUSH
74382: FOR_TO
74383: IFFALSE 74475
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
74385: LD_ADDR_VAR 0 4
74389: PUSH
74390: LD_VAR 0 2
74394: PUSH
74395: LD_VAR 0 3
74399: ARRAY
74400: PPUSH
74401: LD_INT 3
74403: PPUSH
74404: CALL_OW 259
74408: PUSH
74409: LD_VAR 0 2
74413: PUSH
74414: LD_VAR 0 3
74418: ARRAY
74419: PPUSH
74420: CALL_OW 432
74424: MINUS
74425: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
74426: LD_VAR 0 4
74430: PUSH
74431: LD_VAR 0 5
74435: PPUSH
74436: LD_INT 3
74438: PPUSH
74439: CALL_OW 259
74443: PUSH
74444: LD_VAR 0 5
74448: PPUSH
74449: CALL_OW 432
74453: MINUS
74454: GREATEREQUAL
74455: IFFALSE 74473
// mech := result [ i ] ;
74457: LD_ADDR_VAR 0 5
74461: PUSH
74462: LD_VAR 0 2
74466: PUSH
74467: LD_VAR 0 3
74471: ARRAY
74472: ST_TO_ADDR
// end ;
74473: GO 74382
74475: POP
74476: POP
// ComLinkTo ( vehicle , mech ) ;
74477: LD_VAR 0 1
74481: PPUSH
74482: LD_VAR 0 5
74486: PPUSH
74487: CALL_OW 135
// end ;
74491: LD_VAR 0 2
74495: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
74496: LD_INT 0
74498: PPUSH
74499: PPUSH
74500: PPUSH
74501: PPUSH
74502: PPUSH
74503: PPUSH
74504: PPUSH
74505: PPUSH
74506: PPUSH
74507: PPUSH
74508: PPUSH
74509: PPUSH
74510: PPUSH
// result := [ ] ;
74511: LD_ADDR_VAR 0 7
74515: PUSH
74516: EMPTY
74517: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
74518: LD_VAR 0 1
74522: PPUSH
74523: CALL_OW 266
74527: PUSH
74528: LD_INT 0
74530: PUSH
74531: LD_INT 1
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: IN
74538: NOT
74539: IFFALSE 74543
// exit ;
74541: GO 76174
// if name then
74543: LD_VAR 0 3
74547: IFFALSE 74563
// SetBName ( base_dep , name ) ;
74549: LD_VAR 0 1
74553: PPUSH
74554: LD_VAR 0 3
74558: PPUSH
74559: CALL_OW 500
// base := GetBase ( base_dep ) ;
74563: LD_ADDR_VAR 0 15
74567: PUSH
74568: LD_VAR 0 1
74572: PPUSH
74573: CALL_OW 274
74577: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
74578: LD_ADDR_VAR 0 16
74582: PUSH
74583: LD_VAR 0 1
74587: PPUSH
74588: CALL_OW 255
74592: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
74593: LD_ADDR_VAR 0 17
74597: PUSH
74598: LD_VAR 0 1
74602: PPUSH
74603: CALL_OW 248
74607: ST_TO_ADDR
// if sources then
74608: LD_VAR 0 5
74612: IFFALSE 74659
// for i = 1 to 3 do
74614: LD_ADDR_VAR 0 8
74618: PUSH
74619: DOUBLE
74620: LD_INT 1
74622: DEC
74623: ST_TO_ADDR
74624: LD_INT 3
74626: PUSH
74627: FOR_TO
74628: IFFALSE 74657
// AddResourceType ( base , i , sources [ i ] ) ;
74630: LD_VAR 0 15
74634: PPUSH
74635: LD_VAR 0 8
74639: PPUSH
74640: LD_VAR 0 5
74644: PUSH
74645: LD_VAR 0 8
74649: ARRAY
74650: PPUSH
74651: CALL_OW 276
74655: GO 74627
74657: POP
74658: POP
// buildings := GetBaseBuildings ( base , area ) ;
74659: LD_ADDR_VAR 0 18
74663: PUSH
74664: LD_VAR 0 15
74668: PPUSH
74669: LD_VAR 0 2
74673: PPUSH
74674: CALL 73951 0 2
74678: ST_TO_ADDR
// InitHc ;
74679: CALL_OW 19
// InitUc ;
74683: CALL_OW 18
// uc_side := side ;
74687: LD_ADDR_OWVAR 20
74691: PUSH
74692: LD_VAR 0 16
74696: ST_TO_ADDR
// uc_nation := nation ;
74697: LD_ADDR_OWVAR 21
74701: PUSH
74702: LD_VAR 0 17
74706: ST_TO_ADDR
// if buildings then
74707: LD_VAR 0 18
74711: IFFALSE 76033
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
74713: LD_ADDR_VAR 0 19
74717: PUSH
74718: LD_VAR 0 18
74722: PPUSH
74723: LD_INT 2
74725: PUSH
74726: LD_INT 30
74728: PUSH
74729: LD_INT 29
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: LD_INT 30
74738: PUSH
74739: LD_INT 30
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: PUSH
74746: EMPTY
74747: LIST
74748: LIST
74749: LIST
74750: PPUSH
74751: CALL_OW 72
74755: ST_TO_ADDR
// if tmp then
74756: LD_VAR 0 19
74760: IFFALSE 74808
// for i in tmp do
74762: LD_ADDR_VAR 0 8
74766: PUSH
74767: LD_VAR 0 19
74771: PUSH
74772: FOR_IN
74773: IFFALSE 74806
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
74775: LD_VAR 0 8
74779: PPUSH
74780: CALL_OW 250
74784: PPUSH
74785: LD_VAR 0 8
74789: PPUSH
74790: CALL_OW 251
74794: PPUSH
74795: LD_VAR 0 16
74799: PPUSH
74800: CALL_OW 441
74804: GO 74772
74806: POP
74807: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
74808: LD_VAR 0 18
74812: PPUSH
74813: LD_INT 2
74815: PUSH
74816: LD_INT 30
74818: PUSH
74819: LD_INT 32
74821: PUSH
74822: EMPTY
74823: LIST
74824: LIST
74825: PUSH
74826: LD_INT 30
74828: PUSH
74829: LD_INT 33
74831: PUSH
74832: EMPTY
74833: LIST
74834: LIST
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: LIST
74840: PPUSH
74841: CALL_OW 72
74845: IFFALSE 74933
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
74847: LD_ADDR_VAR 0 8
74851: PUSH
74852: LD_VAR 0 18
74856: PPUSH
74857: LD_INT 2
74859: PUSH
74860: LD_INT 30
74862: PUSH
74863: LD_INT 32
74865: PUSH
74866: EMPTY
74867: LIST
74868: LIST
74869: PUSH
74870: LD_INT 30
74872: PUSH
74873: LD_INT 33
74875: PUSH
74876: EMPTY
74877: LIST
74878: LIST
74879: PUSH
74880: EMPTY
74881: LIST
74882: LIST
74883: LIST
74884: PPUSH
74885: CALL_OW 72
74889: PUSH
74890: FOR_IN
74891: IFFALSE 74931
// begin if not GetBWeapon ( i ) then
74893: LD_VAR 0 8
74897: PPUSH
74898: CALL_OW 269
74902: NOT
74903: IFFALSE 74929
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
74905: LD_VAR 0 8
74909: PPUSH
74910: LD_VAR 0 8
74914: PPUSH
74915: LD_VAR 0 2
74919: PPUSH
74920: CALL 76179 0 2
74924: PPUSH
74925: CALL_OW 431
// end ;
74929: GO 74890
74931: POP
74932: POP
// end ; for i = 1 to personel do
74933: LD_ADDR_VAR 0 8
74937: PUSH
74938: DOUBLE
74939: LD_INT 1
74941: DEC
74942: ST_TO_ADDR
74943: LD_VAR 0 6
74947: PUSH
74948: FOR_TO
74949: IFFALSE 76013
// begin if i > 4 then
74951: LD_VAR 0 8
74955: PUSH
74956: LD_INT 4
74958: GREATER
74959: IFFALSE 74963
// break ;
74961: GO 76013
// case i of 1 :
74963: LD_VAR 0 8
74967: PUSH
74968: LD_INT 1
74970: DOUBLE
74971: EQUAL
74972: IFTRUE 74976
74974: GO 75056
74976: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
74977: LD_ADDR_VAR 0 12
74981: PUSH
74982: LD_VAR 0 18
74986: PPUSH
74987: LD_INT 22
74989: PUSH
74990: LD_VAR 0 16
74994: PUSH
74995: EMPTY
74996: LIST
74997: LIST
74998: PUSH
74999: LD_INT 58
75001: PUSH
75002: EMPTY
75003: LIST
75004: PUSH
75005: LD_INT 2
75007: PUSH
75008: LD_INT 30
75010: PUSH
75011: LD_INT 32
75013: PUSH
75014: EMPTY
75015: LIST
75016: LIST
75017: PUSH
75018: LD_INT 30
75020: PUSH
75021: LD_INT 4
75023: PUSH
75024: EMPTY
75025: LIST
75026: LIST
75027: PUSH
75028: LD_INT 30
75030: PUSH
75031: LD_INT 5
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: PUSH
75038: EMPTY
75039: LIST
75040: LIST
75041: LIST
75042: LIST
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: LIST
75048: PPUSH
75049: CALL_OW 72
75053: ST_TO_ADDR
75054: GO 75278
75056: LD_INT 2
75058: DOUBLE
75059: EQUAL
75060: IFTRUE 75064
75062: GO 75126
75064: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
75065: LD_ADDR_VAR 0 12
75069: PUSH
75070: LD_VAR 0 18
75074: PPUSH
75075: LD_INT 22
75077: PUSH
75078: LD_VAR 0 16
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: PUSH
75087: LD_INT 2
75089: PUSH
75090: LD_INT 30
75092: PUSH
75093: LD_INT 0
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: LD_INT 30
75102: PUSH
75103: LD_INT 1
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: PUSH
75110: EMPTY
75111: LIST
75112: LIST
75113: LIST
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PPUSH
75119: CALL_OW 72
75123: ST_TO_ADDR
75124: GO 75278
75126: LD_INT 3
75128: DOUBLE
75129: EQUAL
75130: IFTRUE 75134
75132: GO 75196
75134: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
75135: LD_ADDR_VAR 0 12
75139: PUSH
75140: LD_VAR 0 18
75144: PPUSH
75145: LD_INT 22
75147: PUSH
75148: LD_VAR 0 16
75152: PUSH
75153: EMPTY
75154: LIST
75155: LIST
75156: PUSH
75157: LD_INT 2
75159: PUSH
75160: LD_INT 30
75162: PUSH
75163: LD_INT 2
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 30
75172: PUSH
75173: LD_INT 3
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: LIST
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PPUSH
75189: CALL_OW 72
75193: ST_TO_ADDR
75194: GO 75278
75196: LD_INT 4
75198: DOUBLE
75199: EQUAL
75200: IFTRUE 75204
75202: GO 75277
75204: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
75205: LD_ADDR_VAR 0 12
75209: PUSH
75210: LD_VAR 0 18
75214: PPUSH
75215: LD_INT 22
75217: PUSH
75218: LD_VAR 0 16
75222: PUSH
75223: EMPTY
75224: LIST
75225: LIST
75226: PUSH
75227: LD_INT 2
75229: PUSH
75230: LD_INT 30
75232: PUSH
75233: LD_INT 6
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 30
75242: PUSH
75243: LD_INT 7
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 30
75252: PUSH
75253: LD_INT 8
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: EMPTY
75261: LIST
75262: LIST
75263: LIST
75264: LIST
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PPUSH
75270: CALL_OW 72
75274: ST_TO_ADDR
75275: GO 75278
75277: POP
// if i = 1 then
75278: LD_VAR 0 8
75282: PUSH
75283: LD_INT 1
75285: EQUAL
75286: IFFALSE 75397
// begin tmp := [ ] ;
75288: LD_ADDR_VAR 0 19
75292: PUSH
75293: EMPTY
75294: ST_TO_ADDR
// for j in f do
75295: LD_ADDR_VAR 0 9
75299: PUSH
75300: LD_VAR 0 12
75304: PUSH
75305: FOR_IN
75306: IFFALSE 75379
// if GetBType ( j ) = b_bunker then
75308: LD_VAR 0 9
75312: PPUSH
75313: CALL_OW 266
75317: PUSH
75318: LD_INT 32
75320: EQUAL
75321: IFFALSE 75348
// tmp := Insert ( tmp , 1 , j ) else
75323: LD_ADDR_VAR 0 19
75327: PUSH
75328: LD_VAR 0 19
75332: PPUSH
75333: LD_INT 1
75335: PPUSH
75336: LD_VAR 0 9
75340: PPUSH
75341: CALL_OW 2
75345: ST_TO_ADDR
75346: GO 75377
// tmp := Insert ( tmp , tmp + 1 , j ) ;
75348: LD_ADDR_VAR 0 19
75352: PUSH
75353: LD_VAR 0 19
75357: PPUSH
75358: LD_VAR 0 19
75362: PUSH
75363: LD_INT 1
75365: PLUS
75366: PPUSH
75367: LD_VAR 0 9
75371: PPUSH
75372: CALL_OW 2
75376: ST_TO_ADDR
75377: GO 75305
75379: POP
75380: POP
// if tmp then
75381: LD_VAR 0 19
75385: IFFALSE 75397
// f := tmp ;
75387: LD_ADDR_VAR 0 12
75391: PUSH
75392: LD_VAR 0 19
75396: ST_TO_ADDR
// end ; x := personel [ i ] ;
75397: LD_ADDR_VAR 0 13
75401: PUSH
75402: LD_VAR 0 6
75406: PUSH
75407: LD_VAR 0 8
75411: ARRAY
75412: ST_TO_ADDR
// if x = - 1 then
75413: LD_VAR 0 13
75417: PUSH
75418: LD_INT 1
75420: NEG
75421: EQUAL
75422: IFFALSE 75631
// begin for j in f do
75424: LD_ADDR_VAR 0 9
75428: PUSH
75429: LD_VAR 0 12
75433: PUSH
75434: FOR_IN
75435: IFFALSE 75627
// repeat InitHc ;
75437: CALL_OW 19
// if GetBType ( j ) = b_barracks then
75441: LD_VAR 0 9
75445: PPUSH
75446: CALL_OW 266
75450: PUSH
75451: LD_INT 5
75453: EQUAL
75454: IFFALSE 75524
// begin if UnitsInside ( j ) < 3 then
75456: LD_VAR 0 9
75460: PPUSH
75461: CALL_OW 313
75465: PUSH
75466: LD_INT 3
75468: LESS
75469: IFFALSE 75505
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75471: LD_INT 0
75473: PPUSH
75474: LD_INT 5
75476: PUSH
75477: LD_INT 8
75479: PUSH
75480: LD_INT 9
75482: PUSH
75483: EMPTY
75484: LIST
75485: LIST
75486: LIST
75487: PUSH
75488: LD_VAR 0 17
75492: ARRAY
75493: PPUSH
75494: LD_VAR 0 4
75498: PPUSH
75499: CALL_OW 380
75503: GO 75522
// PrepareHuman ( false , i , skill ) ;
75505: LD_INT 0
75507: PPUSH
75508: LD_VAR 0 8
75512: PPUSH
75513: LD_VAR 0 4
75517: PPUSH
75518: CALL_OW 380
// end else
75522: GO 75541
// PrepareHuman ( false , i , skill ) ;
75524: LD_INT 0
75526: PPUSH
75527: LD_VAR 0 8
75531: PPUSH
75532: LD_VAR 0 4
75536: PPUSH
75537: CALL_OW 380
// un := CreateHuman ;
75541: LD_ADDR_VAR 0 14
75545: PUSH
75546: CALL_OW 44
75550: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75551: LD_ADDR_VAR 0 7
75555: PUSH
75556: LD_VAR 0 7
75560: PPUSH
75561: LD_INT 1
75563: PPUSH
75564: LD_VAR 0 14
75568: PPUSH
75569: CALL_OW 2
75573: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
75574: LD_VAR 0 14
75578: PPUSH
75579: LD_VAR 0 9
75583: PPUSH
75584: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
75588: LD_VAR 0 9
75592: PPUSH
75593: CALL_OW 313
75597: PUSH
75598: LD_INT 6
75600: EQUAL
75601: PUSH
75602: LD_VAR 0 9
75606: PPUSH
75607: CALL_OW 266
75611: PUSH
75612: LD_INT 32
75614: PUSH
75615: LD_INT 31
75617: PUSH
75618: EMPTY
75619: LIST
75620: LIST
75621: IN
75622: OR
75623: IFFALSE 75437
75625: GO 75434
75627: POP
75628: POP
// end else
75629: GO 76011
// for j = 1 to x do
75631: LD_ADDR_VAR 0 9
75635: PUSH
75636: DOUBLE
75637: LD_INT 1
75639: DEC
75640: ST_TO_ADDR
75641: LD_VAR 0 13
75645: PUSH
75646: FOR_TO
75647: IFFALSE 76009
// begin InitHc ;
75649: CALL_OW 19
// if not f then
75653: LD_VAR 0 12
75657: NOT
75658: IFFALSE 75747
// begin PrepareHuman ( false , i , skill ) ;
75660: LD_INT 0
75662: PPUSH
75663: LD_VAR 0 8
75667: PPUSH
75668: LD_VAR 0 4
75672: PPUSH
75673: CALL_OW 380
// un := CreateHuman ;
75677: LD_ADDR_VAR 0 14
75681: PUSH
75682: CALL_OW 44
75686: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75687: LD_ADDR_VAR 0 7
75691: PUSH
75692: LD_VAR 0 7
75696: PPUSH
75697: LD_INT 1
75699: PPUSH
75700: LD_VAR 0 14
75704: PPUSH
75705: CALL_OW 2
75709: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
75710: LD_VAR 0 14
75714: PPUSH
75715: LD_VAR 0 1
75719: PPUSH
75720: CALL_OW 250
75724: PPUSH
75725: LD_VAR 0 1
75729: PPUSH
75730: CALL_OW 251
75734: PPUSH
75735: LD_INT 10
75737: PPUSH
75738: LD_INT 0
75740: PPUSH
75741: CALL_OW 50
// continue ;
75745: GO 75646
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
75747: LD_VAR 0 12
75751: PUSH
75752: LD_INT 1
75754: ARRAY
75755: PPUSH
75756: CALL_OW 313
75760: PUSH
75761: LD_VAR 0 12
75765: PUSH
75766: LD_INT 1
75768: ARRAY
75769: PPUSH
75770: CALL_OW 266
75774: PUSH
75775: LD_INT 32
75777: PUSH
75778: LD_INT 31
75780: PUSH
75781: EMPTY
75782: LIST
75783: LIST
75784: IN
75785: AND
75786: PUSH
75787: LD_VAR 0 12
75791: PUSH
75792: LD_INT 1
75794: ARRAY
75795: PPUSH
75796: CALL_OW 313
75800: PUSH
75801: LD_INT 6
75803: EQUAL
75804: OR
75805: IFFALSE 75825
// f := Delete ( f , 1 ) ;
75807: LD_ADDR_VAR 0 12
75811: PUSH
75812: LD_VAR 0 12
75816: PPUSH
75817: LD_INT 1
75819: PPUSH
75820: CALL_OW 3
75824: ST_TO_ADDR
// if not f then
75825: LD_VAR 0 12
75829: NOT
75830: IFFALSE 75848
// begin x := x + 2 ;
75832: LD_ADDR_VAR 0 13
75836: PUSH
75837: LD_VAR 0 13
75841: PUSH
75842: LD_INT 2
75844: PLUS
75845: ST_TO_ADDR
// continue ;
75846: GO 75646
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
75848: LD_VAR 0 12
75852: PUSH
75853: LD_INT 1
75855: ARRAY
75856: PPUSH
75857: CALL_OW 266
75861: PUSH
75862: LD_INT 5
75864: EQUAL
75865: IFFALSE 75939
// begin if UnitsInside ( f [ 1 ] ) < 3 then
75867: LD_VAR 0 12
75871: PUSH
75872: LD_INT 1
75874: ARRAY
75875: PPUSH
75876: CALL_OW 313
75880: PUSH
75881: LD_INT 3
75883: LESS
75884: IFFALSE 75920
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
75886: LD_INT 0
75888: PPUSH
75889: LD_INT 5
75891: PUSH
75892: LD_INT 8
75894: PUSH
75895: LD_INT 9
75897: PUSH
75898: EMPTY
75899: LIST
75900: LIST
75901: LIST
75902: PUSH
75903: LD_VAR 0 17
75907: ARRAY
75908: PPUSH
75909: LD_VAR 0 4
75913: PPUSH
75914: CALL_OW 380
75918: GO 75937
// PrepareHuman ( false , i , skill ) ;
75920: LD_INT 0
75922: PPUSH
75923: LD_VAR 0 8
75927: PPUSH
75928: LD_VAR 0 4
75932: PPUSH
75933: CALL_OW 380
// end else
75937: GO 75956
// PrepareHuman ( false , i , skill ) ;
75939: LD_INT 0
75941: PPUSH
75942: LD_VAR 0 8
75946: PPUSH
75947: LD_VAR 0 4
75951: PPUSH
75952: CALL_OW 380
// un := CreateHuman ;
75956: LD_ADDR_VAR 0 14
75960: PUSH
75961: CALL_OW 44
75965: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
75966: LD_ADDR_VAR 0 7
75970: PUSH
75971: LD_VAR 0 7
75975: PPUSH
75976: LD_INT 1
75978: PPUSH
75979: LD_VAR 0 14
75983: PPUSH
75984: CALL_OW 2
75988: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
75989: LD_VAR 0 14
75993: PPUSH
75994: LD_VAR 0 12
75998: PUSH
75999: LD_INT 1
76001: ARRAY
76002: PPUSH
76003: CALL_OW 52
// end ;
76007: GO 75646
76009: POP
76010: POP
// end ;
76011: GO 74948
76013: POP
76014: POP
// result := result ^ buildings ;
76015: LD_ADDR_VAR 0 7
76019: PUSH
76020: LD_VAR 0 7
76024: PUSH
76025: LD_VAR 0 18
76029: ADD
76030: ST_TO_ADDR
// end else
76031: GO 76174
// begin for i = 1 to personel do
76033: LD_ADDR_VAR 0 8
76037: PUSH
76038: DOUBLE
76039: LD_INT 1
76041: DEC
76042: ST_TO_ADDR
76043: LD_VAR 0 6
76047: PUSH
76048: FOR_TO
76049: IFFALSE 76172
// begin if i > 4 then
76051: LD_VAR 0 8
76055: PUSH
76056: LD_INT 4
76058: GREATER
76059: IFFALSE 76063
// break ;
76061: GO 76172
// x := personel [ i ] ;
76063: LD_ADDR_VAR 0 13
76067: PUSH
76068: LD_VAR 0 6
76072: PUSH
76073: LD_VAR 0 8
76077: ARRAY
76078: ST_TO_ADDR
// if x = - 1 then
76079: LD_VAR 0 13
76083: PUSH
76084: LD_INT 1
76086: NEG
76087: EQUAL
76088: IFFALSE 76092
// continue ;
76090: GO 76048
// PrepareHuman ( false , i , skill ) ;
76092: LD_INT 0
76094: PPUSH
76095: LD_VAR 0 8
76099: PPUSH
76100: LD_VAR 0 4
76104: PPUSH
76105: CALL_OW 380
// un := CreateHuman ;
76109: LD_ADDR_VAR 0 14
76113: PUSH
76114: CALL_OW 44
76118: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
76119: LD_VAR 0 14
76123: PPUSH
76124: LD_VAR 0 1
76128: PPUSH
76129: CALL_OW 250
76133: PPUSH
76134: LD_VAR 0 1
76138: PPUSH
76139: CALL_OW 251
76143: PPUSH
76144: LD_INT 10
76146: PPUSH
76147: LD_INT 0
76149: PPUSH
76150: CALL_OW 50
// result := result ^ un ;
76154: LD_ADDR_VAR 0 7
76158: PUSH
76159: LD_VAR 0 7
76163: PUSH
76164: LD_VAR 0 14
76168: ADD
76169: ST_TO_ADDR
// end ;
76170: GO 76048
76172: POP
76173: POP
// end ; end ;
76174: LD_VAR 0 7
76178: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
76179: LD_INT 0
76181: PPUSH
76182: PPUSH
76183: PPUSH
76184: PPUSH
76185: PPUSH
76186: PPUSH
76187: PPUSH
76188: PPUSH
76189: PPUSH
76190: PPUSH
76191: PPUSH
76192: PPUSH
76193: PPUSH
76194: PPUSH
76195: PPUSH
76196: PPUSH
// result := false ;
76197: LD_ADDR_VAR 0 3
76201: PUSH
76202: LD_INT 0
76204: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
76205: LD_VAR 0 1
76209: NOT
76210: PUSH
76211: LD_VAR 0 1
76215: PPUSH
76216: CALL_OW 266
76220: PUSH
76221: LD_INT 32
76223: PUSH
76224: LD_INT 33
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: IN
76231: NOT
76232: OR
76233: IFFALSE 76237
// exit ;
76235: GO 77373
// nat := GetNation ( tower ) ;
76237: LD_ADDR_VAR 0 12
76241: PUSH
76242: LD_VAR 0 1
76246: PPUSH
76247: CALL_OW 248
76251: ST_TO_ADDR
// side := GetSide ( tower ) ;
76252: LD_ADDR_VAR 0 16
76256: PUSH
76257: LD_VAR 0 1
76261: PPUSH
76262: CALL_OW 255
76266: ST_TO_ADDR
// x := GetX ( tower ) ;
76267: LD_ADDR_VAR 0 10
76271: PUSH
76272: LD_VAR 0 1
76276: PPUSH
76277: CALL_OW 250
76281: ST_TO_ADDR
// y := GetY ( tower ) ;
76282: LD_ADDR_VAR 0 11
76286: PUSH
76287: LD_VAR 0 1
76291: PPUSH
76292: CALL_OW 251
76296: ST_TO_ADDR
// if not x or not y then
76297: LD_VAR 0 10
76301: NOT
76302: PUSH
76303: LD_VAR 0 11
76307: NOT
76308: OR
76309: IFFALSE 76313
// exit ;
76311: GO 77373
// weapon := 0 ;
76313: LD_ADDR_VAR 0 18
76317: PUSH
76318: LD_INT 0
76320: ST_TO_ADDR
// fac_list := [ ] ;
76321: LD_ADDR_VAR 0 17
76325: PUSH
76326: EMPTY
76327: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
76328: LD_ADDR_VAR 0 6
76332: PUSH
76333: LD_VAR 0 1
76337: PPUSH
76338: CALL_OW 274
76342: PPUSH
76343: LD_VAR 0 2
76347: PPUSH
76348: CALL 73951 0 2
76352: PPUSH
76353: LD_INT 30
76355: PUSH
76356: LD_INT 3
76358: PUSH
76359: EMPTY
76360: LIST
76361: LIST
76362: PPUSH
76363: CALL_OW 72
76367: ST_TO_ADDR
// if not factories then
76368: LD_VAR 0 6
76372: NOT
76373: IFFALSE 76377
// exit ;
76375: GO 77373
// for i in factories do
76377: LD_ADDR_VAR 0 8
76381: PUSH
76382: LD_VAR 0 6
76386: PUSH
76387: FOR_IN
76388: IFFALSE 76413
// fac_list := fac_list union AvailableWeaponList ( i ) ;
76390: LD_ADDR_VAR 0 17
76394: PUSH
76395: LD_VAR 0 17
76399: PUSH
76400: LD_VAR 0 8
76404: PPUSH
76405: CALL_OW 478
76409: UNION
76410: ST_TO_ADDR
76411: GO 76387
76413: POP
76414: POP
// if not fac_list then
76415: LD_VAR 0 17
76419: NOT
76420: IFFALSE 76424
// exit ;
76422: GO 77373
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
76424: LD_ADDR_VAR 0 5
76428: PUSH
76429: LD_INT 4
76431: PUSH
76432: LD_INT 5
76434: PUSH
76435: LD_INT 9
76437: PUSH
76438: LD_INT 10
76440: PUSH
76441: LD_INT 6
76443: PUSH
76444: LD_INT 7
76446: PUSH
76447: LD_INT 11
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: LIST
76454: LIST
76455: LIST
76456: LIST
76457: LIST
76458: PUSH
76459: LD_INT 27
76461: PUSH
76462: LD_INT 28
76464: PUSH
76465: LD_INT 26
76467: PUSH
76468: LD_INT 30
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: LIST
76475: LIST
76476: PUSH
76477: LD_INT 43
76479: PUSH
76480: LD_INT 44
76482: PUSH
76483: LD_INT 46
76485: PUSH
76486: LD_INT 45
76488: PUSH
76489: LD_INT 47
76491: PUSH
76492: LD_INT 49
76494: PUSH
76495: EMPTY
76496: LIST
76497: LIST
76498: LIST
76499: LIST
76500: LIST
76501: LIST
76502: PUSH
76503: EMPTY
76504: LIST
76505: LIST
76506: LIST
76507: PUSH
76508: LD_VAR 0 12
76512: ARRAY
76513: ST_TO_ADDR
// for i in list do
76514: LD_ADDR_VAR 0 8
76518: PUSH
76519: LD_VAR 0 5
76523: PUSH
76524: FOR_IN
76525: IFFALSE 76558
// if not i in fac_list then
76527: LD_VAR 0 8
76531: PUSH
76532: LD_VAR 0 17
76536: IN
76537: NOT
76538: IFFALSE 76556
// list := list diff i ;
76540: LD_ADDR_VAR 0 5
76544: PUSH
76545: LD_VAR 0 5
76549: PUSH
76550: LD_VAR 0 8
76554: DIFF
76555: ST_TO_ADDR
76556: GO 76524
76558: POP
76559: POP
// if not list then
76560: LD_VAR 0 5
76564: NOT
76565: IFFALSE 76569
// exit ;
76567: GO 77373
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
76569: LD_VAR 0 12
76573: PUSH
76574: LD_INT 3
76576: EQUAL
76577: PUSH
76578: LD_INT 49
76580: PUSH
76581: LD_VAR 0 5
76585: IN
76586: AND
76587: PUSH
76588: LD_INT 31
76590: PPUSH
76591: LD_VAR 0 16
76595: PPUSH
76596: CALL_OW 321
76600: PUSH
76601: LD_INT 2
76603: EQUAL
76604: AND
76605: IFFALSE 76665
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
76607: LD_INT 22
76609: PUSH
76610: LD_VAR 0 16
76614: PUSH
76615: EMPTY
76616: LIST
76617: LIST
76618: PUSH
76619: LD_INT 35
76621: PUSH
76622: LD_INT 49
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: PUSH
76629: LD_INT 91
76631: PUSH
76632: LD_VAR 0 1
76636: PUSH
76637: LD_INT 10
76639: PUSH
76640: EMPTY
76641: LIST
76642: LIST
76643: LIST
76644: PUSH
76645: EMPTY
76646: LIST
76647: LIST
76648: LIST
76649: PPUSH
76650: CALL_OW 69
76654: NOT
76655: IFFALSE 76665
// weapon := ru_time_lapser ;
76657: LD_ADDR_VAR 0 18
76661: PUSH
76662: LD_INT 49
76664: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
76665: LD_VAR 0 12
76669: PUSH
76670: LD_INT 1
76672: PUSH
76673: LD_INT 2
76675: PUSH
76676: EMPTY
76677: LIST
76678: LIST
76679: IN
76680: PUSH
76681: LD_INT 11
76683: PUSH
76684: LD_VAR 0 5
76688: IN
76689: PUSH
76690: LD_INT 30
76692: PUSH
76693: LD_VAR 0 5
76697: IN
76698: OR
76699: AND
76700: PUSH
76701: LD_INT 6
76703: PPUSH
76704: LD_VAR 0 16
76708: PPUSH
76709: CALL_OW 321
76713: PUSH
76714: LD_INT 2
76716: EQUAL
76717: AND
76718: IFFALSE 76883
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
76720: LD_INT 22
76722: PUSH
76723: LD_VAR 0 16
76727: PUSH
76728: EMPTY
76729: LIST
76730: LIST
76731: PUSH
76732: LD_INT 2
76734: PUSH
76735: LD_INT 35
76737: PUSH
76738: LD_INT 11
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 35
76747: PUSH
76748: LD_INT 30
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: PUSH
76755: EMPTY
76756: LIST
76757: LIST
76758: LIST
76759: PUSH
76760: LD_INT 91
76762: PUSH
76763: LD_VAR 0 1
76767: PUSH
76768: LD_INT 18
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: LIST
76775: PUSH
76776: EMPTY
76777: LIST
76778: LIST
76779: LIST
76780: PPUSH
76781: CALL_OW 69
76785: NOT
76786: PUSH
76787: LD_INT 22
76789: PUSH
76790: LD_VAR 0 16
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: PUSH
76799: LD_INT 2
76801: PUSH
76802: LD_INT 30
76804: PUSH
76805: LD_INT 32
76807: PUSH
76808: EMPTY
76809: LIST
76810: LIST
76811: PUSH
76812: LD_INT 30
76814: PUSH
76815: LD_INT 33
76817: PUSH
76818: EMPTY
76819: LIST
76820: LIST
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 91
76829: PUSH
76830: LD_VAR 0 1
76834: PUSH
76835: LD_INT 12
76837: PUSH
76838: EMPTY
76839: LIST
76840: LIST
76841: LIST
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: LIST
76847: PUSH
76848: EMPTY
76849: LIST
76850: PPUSH
76851: CALL_OW 69
76855: PUSH
76856: LD_INT 2
76858: GREATER
76859: AND
76860: IFFALSE 76883
// weapon := [ us_radar , ar_radar ] [ nat ] ;
76862: LD_ADDR_VAR 0 18
76866: PUSH
76867: LD_INT 11
76869: PUSH
76870: LD_INT 30
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: PUSH
76877: LD_VAR 0 12
76881: ARRAY
76882: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
76883: LD_VAR 0 18
76887: NOT
76888: PUSH
76889: LD_INT 40
76891: PPUSH
76892: LD_VAR 0 16
76896: PPUSH
76897: CALL_OW 321
76901: PUSH
76902: LD_INT 2
76904: EQUAL
76905: AND
76906: PUSH
76907: LD_INT 7
76909: PUSH
76910: LD_VAR 0 5
76914: IN
76915: PUSH
76916: LD_INT 28
76918: PUSH
76919: LD_VAR 0 5
76923: IN
76924: OR
76925: PUSH
76926: LD_INT 45
76928: PUSH
76929: LD_VAR 0 5
76933: IN
76934: OR
76935: AND
76936: IFFALSE 77190
// begin hex := GetHexInfo ( x , y ) ;
76938: LD_ADDR_VAR 0 4
76942: PUSH
76943: LD_VAR 0 10
76947: PPUSH
76948: LD_VAR 0 11
76952: PPUSH
76953: CALL_OW 546
76957: ST_TO_ADDR
// if hex [ 1 ] then
76958: LD_VAR 0 4
76962: PUSH
76963: LD_INT 1
76965: ARRAY
76966: IFFALSE 76970
// exit ;
76968: GO 77373
// height := hex [ 2 ] ;
76970: LD_ADDR_VAR 0 15
76974: PUSH
76975: LD_VAR 0 4
76979: PUSH
76980: LD_INT 2
76982: ARRAY
76983: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
76984: LD_ADDR_VAR 0 14
76988: PUSH
76989: LD_INT 0
76991: PUSH
76992: LD_INT 2
76994: PUSH
76995: LD_INT 3
76997: PUSH
76998: LD_INT 5
77000: PUSH
77001: EMPTY
77002: LIST
77003: LIST
77004: LIST
77005: LIST
77006: ST_TO_ADDR
// for i in tmp do
77007: LD_ADDR_VAR 0 8
77011: PUSH
77012: LD_VAR 0 14
77016: PUSH
77017: FOR_IN
77018: IFFALSE 77188
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
77020: LD_ADDR_VAR 0 9
77024: PUSH
77025: LD_VAR 0 10
77029: PPUSH
77030: LD_VAR 0 8
77034: PPUSH
77035: LD_INT 5
77037: PPUSH
77038: CALL_OW 272
77042: PUSH
77043: LD_VAR 0 11
77047: PPUSH
77048: LD_VAR 0 8
77052: PPUSH
77053: LD_INT 5
77055: PPUSH
77056: CALL_OW 273
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
77065: LD_VAR 0 9
77069: PUSH
77070: LD_INT 1
77072: ARRAY
77073: PPUSH
77074: LD_VAR 0 9
77078: PUSH
77079: LD_INT 2
77081: ARRAY
77082: PPUSH
77083: CALL_OW 488
77087: IFFALSE 77186
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
77089: LD_ADDR_VAR 0 4
77093: PUSH
77094: LD_VAR 0 9
77098: PUSH
77099: LD_INT 1
77101: ARRAY
77102: PPUSH
77103: LD_VAR 0 9
77107: PUSH
77108: LD_INT 2
77110: ARRAY
77111: PPUSH
77112: CALL_OW 546
77116: ST_TO_ADDR
// if hex [ 1 ] then
77117: LD_VAR 0 4
77121: PUSH
77122: LD_INT 1
77124: ARRAY
77125: IFFALSE 77129
// continue ;
77127: GO 77017
// h := hex [ 2 ] ;
77129: LD_ADDR_VAR 0 13
77133: PUSH
77134: LD_VAR 0 4
77138: PUSH
77139: LD_INT 2
77141: ARRAY
77142: ST_TO_ADDR
// if h + 7 < height then
77143: LD_VAR 0 13
77147: PUSH
77148: LD_INT 7
77150: PLUS
77151: PUSH
77152: LD_VAR 0 15
77156: LESS
77157: IFFALSE 77186
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
77159: LD_ADDR_VAR 0 18
77163: PUSH
77164: LD_INT 7
77166: PUSH
77167: LD_INT 28
77169: PUSH
77170: LD_INT 45
77172: PUSH
77173: EMPTY
77174: LIST
77175: LIST
77176: LIST
77177: PUSH
77178: LD_VAR 0 12
77182: ARRAY
77183: ST_TO_ADDR
// break ;
77184: GO 77188
// end ; end ; end ;
77186: GO 77017
77188: POP
77189: POP
// end ; if not weapon then
77190: LD_VAR 0 18
77194: NOT
77195: IFFALSE 77255
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
77197: LD_ADDR_VAR 0 5
77201: PUSH
77202: LD_VAR 0 5
77206: PUSH
77207: LD_INT 11
77209: PUSH
77210: LD_INT 30
77212: PUSH
77213: LD_INT 49
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: LIST
77220: DIFF
77221: ST_TO_ADDR
// if not list then
77222: LD_VAR 0 5
77226: NOT
77227: IFFALSE 77231
// exit ;
77229: GO 77373
// weapon := list [ rand ( 1 , list ) ] ;
77231: LD_ADDR_VAR 0 18
77235: PUSH
77236: LD_VAR 0 5
77240: PUSH
77241: LD_INT 1
77243: PPUSH
77244: LD_VAR 0 5
77248: PPUSH
77249: CALL_OW 12
77253: ARRAY
77254: ST_TO_ADDR
// end ; if weapon then
77255: LD_VAR 0 18
77259: IFFALSE 77373
// begin tmp := CostOfWeapon ( weapon ) ;
77261: LD_ADDR_VAR 0 14
77265: PUSH
77266: LD_VAR 0 18
77270: PPUSH
77271: CALL_OW 451
77275: ST_TO_ADDR
// j := GetBase ( tower ) ;
77276: LD_ADDR_VAR 0 9
77280: PUSH
77281: LD_VAR 0 1
77285: PPUSH
77286: CALL_OW 274
77290: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
77291: LD_VAR 0 9
77295: PPUSH
77296: LD_INT 1
77298: PPUSH
77299: CALL_OW 275
77303: PUSH
77304: LD_VAR 0 14
77308: PUSH
77309: LD_INT 1
77311: ARRAY
77312: GREATEREQUAL
77313: PUSH
77314: LD_VAR 0 9
77318: PPUSH
77319: LD_INT 2
77321: PPUSH
77322: CALL_OW 275
77326: PUSH
77327: LD_VAR 0 14
77331: PUSH
77332: LD_INT 2
77334: ARRAY
77335: GREATEREQUAL
77336: AND
77337: PUSH
77338: LD_VAR 0 9
77342: PPUSH
77343: LD_INT 3
77345: PPUSH
77346: CALL_OW 275
77350: PUSH
77351: LD_VAR 0 14
77355: PUSH
77356: LD_INT 3
77358: ARRAY
77359: GREATEREQUAL
77360: AND
77361: IFFALSE 77373
// result := weapon ;
77363: LD_ADDR_VAR 0 3
77367: PUSH
77368: LD_VAR 0 18
77372: ST_TO_ADDR
// end ; end ;
77373: LD_VAR 0 3
77377: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
77378: LD_INT 0
77380: PPUSH
77381: PPUSH
// result := true ;
77382: LD_ADDR_VAR 0 3
77386: PUSH
77387: LD_INT 1
77389: ST_TO_ADDR
// if array1 = array2 then
77390: LD_VAR 0 1
77394: PUSH
77395: LD_VAR 0 2
77399: EQUAL
77400: IFFALSE 77460
// begin for i = 1 to array1 do
77402: LD_ADDR_VAR 0 4
77406: PUSH
77407: DOUBLE
77408: LD_INT 1
77410: DEC
77411: ST_TO_ADDR
77412: LD_VAR 0 1
77416: PUSH
77417: FOR_TO
77418: IFFALSE 77456
// if array1 [ i ] <> array2 [ i ] then
77420: LD_VAR 0 1
77424: PUSH
77425: LD_VAR 0 4
77429: ARRAY
77430: PUSH
77431: LD_VAR 0 2
77435: PUSH
77436: LD_VAR 0 4
77440: ARRAY
77441: NONEQUAL
77442: IFFALSE 77454
// begin result := false ;
77444: LD_ADDR_VAR 0 3
77448: PUSH
77449: LD_INT 0
77451: ST_TO_ADDR
// break ;
77452: GO 77456
// end ;
77454: GO 77417
77456: POP
77457: POP
// end else
77458: GO 77468
// result := false ;
77460: LD_ADDR_VAR 0 3
77464: PUSH
77465: LD_INT 0
77467: ST_TO_ADDR
// end ;
77468: LD_VAR 0 3
77472: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
77473: LD_INT 0
77475: PPUSH
77476: PPUSH
77477: PPUSH
// pom := GetBase ( fac ) ;
77478: LD_ADDR_VAR 0 5
77482: PUSH
77483: LD_VAR 0 1
77487: PPUSH
77488: CALL_OW 274
77492: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
77493: LD_ADDR_VAR 0 4
77497: PUSH
77498: LD_VAR 0 2
77502: PUSH
77503: LD_INT 1
77505: ARRAY
77506: PPUSH
77507: LD_VAR 0 2
77511: PUSH
77512: LD_INT 2
77514: ARRAY
77515: PPUSH
77516: LD_VAR 0 2
77520: PUSH
77521: LD_INT 3
77523: ARRAY
77524: PPUSH
77525: LD_VAR 0 2
77529: PUSH
77530: LD_INT 4
77532: ARRAY
77533: PPUSH
77534: CALL_OW 449
77538: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77539: LD_ADDR_VAR 0 3
77543: PUSH
77544: LD_VAR 0 5
77548: PPUSH
77549: LD_INT 1
77551: PPUSH
77552: CALL_OW 275
77556: PUSH
77557: LD_VAR 0 4
77561: PUSH
77562: LD_INT 1
77564: ARRAY
77565: GREATEREQUAL
77566: PUSH
77567: LD_VAR 0 5
77571: PPUSH
77572: LD_INT 2
77574: PPUSH
77575: CALL_OW 275
77579: PUSH
77580: LD_VAR 0 4
77584: PUSH
77585: LD_INT 2
77587: ARRAY
77588: GREATEREQUAL
77589: AND
77590: PUSH
77591: LD_VAR 0 5
77595: PPUSH
77596: LD_INT 3
77598: PPUSH
77599: CALL_OW 275
77603: PUSH
77604: LD_VAR 0 4
77608: PUSH
77609: LD_INT 3
77611: ARRAY
77612: GREATEREQUAL
77613: AND
77614: ST_TO_ADDR
// end ;
77615: LD_VAR 0 3
77619: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
77620: LD_INT 0
77622: PPUSH
77623: PPUSH
77624: PPUSH
77625: PPUSH
// pom := GetBase ( building ) ;
77626: LD_ADDR_VAR 0 3
77630: PUSH
77631: LD_VAR 0 1
77635: PPUSH
77636: CALL_OW 274
77640: ST_TO_ADDR
// if not pom then
77641: LD_VAR 0 3
77645: NOT
77646: IFFALSE 77650
// exit ;
77648: GO 77820
// btype := GetBType ( building ) ;
77650: LD_ADDR_VAR 0 5
77654: PUSH
77655: LD_VAR 0 1
77659: PPUSH
77660: CALL_OW 266
77664: ST_TO_ADDR
// if btype = b_armoury then
77665: LD_VAR 0 5
77669: PUSH
77670: LD_INT 4
77672: EQUAL
77673: IFFALSE 77683
// btype := b_barracks ;
77675: LD_ADDR_VAR 0 5
77679: PUSH
77680: LD_INT 5
77682: ST_TO_ADDR
// if btype = b_depot then
77683: LD_VAR 0 5
77687: PUSH
77688: LD_INT 0
77690: EQUAL
77691: IFFALSE 77701
// btype := b_warehouse ;
77693: LD_ADDR_VAR 0 5
77697: PUSH
77698: LD_INT 1
77700: ST_TO_ADDR
// if btype = b_workshop then
77701: LD_VAR 0 5
77705: PUSH
77706: LD_INT 2
77708: EQUAL
77709: IFFALSE 77719
// btype := b_factory ;
77711: LD_ADDR_VAR 0 5
77715: PUSH
77716: LD_INT 3
77718: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77719: LD_ADDR_VAR 0 4
77723: PUSH
77724: LD_VAR 0 5
77728: PPUSH
77729: LD_VAR 0 1
77733: PPUSH
77734: CALL_OW 248
77738: PPUSH
77739: CALL_OW 450
77743: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77744: LD_ADDR_VAR 0 2
77748: PUSH
77749: LD_VAR 0 3
77753: PPUSH
77754: LD_INT 1
77756: PPUSH
77757: CALL_OW 275
77761: PUSH
77762: LD_VAR 0 4
77766: PUSH
77767: LD_INT 1
77769: ARRAY
77770: GREATEREQUAL
77771: PUSH
77772: LD_VAR 0 3
77776: PPUSH
77777: LD_INT 2
77779: PPUSH
77780: CALL_OW 275
77784: PUSH
77785: LD_VAR 0 4
77789: PUSH
77790: LD_INT 2
77792: ARRAY
77793: GREATEREQUAL
77794: AND
77795: PUSH
77796: LD_VAR 0 3
77800: PPUSH
77801: LD_INT 3
77803: PPUSH
77804: CALL_OW 275
77808: PUSH
77809: LD_VAR 0 4
77813: PUSH
77814: LD_INT 3
77816: ARRAY
77817: GREATEREQUAL
77818: AND
77819: ST_TO_ADDR
// end ;
77820: LD_VAR 0 2
77824: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
77825: LD_INT 0
77827: PPUSH
77828: PPUSH
77829: PPUSH
// pom := GetBase ( building ) ;
77830: LD_ADDR_VAR 0 4
77834: PUSH
77835: LD_VAR 0 1
77839: PPUSH
77840: CALL_OW 274
77844: ST_TO_ADDR
// if not pom then
77845: LD_VAR 0 4
77849: NOT
77850: IFFALSE 77854
// exit ;
77852: GO 77955
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
77854: LD_ADDR_VAR 0 5
77858: PUSH
77859: LD_VAR 0 2
77863: PPUSH
77864: LD_VAR 0 1
77868: PPUSH
77869: CALL_OW 248
77873: PPUSH
77874: CALL_OW 450
77878: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
77879: LD_ADDR_VAR 0 3
77883: PUSH
77884: LD_VAR 0 4
77888: PPUSH
77889: LD_INT 1
77891: PPUSH
77892: CALL_OW 275
77896: PUSH
77897: LD_VAR 0 5
77901: PUSH
77902: LD_INT 1
77904: ARRAY
77905: GREATEREQUAL
77906: PUSH
77907: LD_VAR 0 4
77911: PPUSH
77912: LD_INT 2
77914: PPUSH
77915: CALL_OW 275
77919: PUSH
77920: LD_VAR 0 5
77924: PUSH
77925: LD_INT 2
77927: ARRAY
77928: GREATEREQUAL
77929: AND
77930: PUSH
77931: LD_VAR 0 4
77935: PPUSH
77936: LD_INT 3
77938: PPUSH
77939: CALL_OW 275
77943: PUSH
77944: LD_VAR 0 5
77948: PUSH
77949: LD_INT 3
77951: ARRAY
77952: GREATEREQUAL
77953: AND
77954: ST_TO_ADDR
// end ;
77955: LD_VAR 0 3
77959: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
77960: LD_INT 0
77962: PPUSH
77963: PPUSH
77964: PPUSH
77965: PPUSH
77966: PPUSH
77967: PPUSH
77968: PPUSH
77969: PPUSH
77970: PPUSH
77971: PPUSH
// result := false ;
77972: LD_ADDR_VAR 0 6
77976: PUSH
77977: LD_INT 0
77979: ST_TO_ADDR
// if not base or not btype or not x or not y then
77980: LD_VAR 0 1
77984: NOT
77985: PUSH
77986: LD_VAR 0 2
77990: NOT
77991: OR
77992: PUSH
77993: LD_VAR 0 3
77997: NOT
77998: OR
77999: PUSH
78000: LD_VAR 0 4
78004: NOT
78005: OR
78006: IFFALSE 78010
// exit ;
78008: GO 78619
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
78010: LD_ADDR_VAR 0 12
78014: PUSH
78015: LD_VAR 0 2
78019: PPUSH
78020: LD_VAR 0 3
78024: PPUSH
78025: LD_VAR 0 4
78029: PPUSH
78030: LD_VAR 0 5
78034: PPUSH
78035: LD_VAR 0 1
78039: PUSH
78040: LD_INT 1
78042: ARRAY
78043: PPUSH
78044: CALL_OW 248
78048: PPUSH
78049: LD_INT 0
78051: PPUSH
78052: CALL 79456 0 6
78056: ST_TO_ADDR
// if not hexes then
78057: LD_VAR 0 12
78061: NOT
78062: IFFALSE 78066
// exit ;
78064: GO 78619
// for i = 1 to hexes do
78066: LD_ADDR_VAR 0 7
78070: PUSH
78071: DOUBLE
78072: LD_INT 1
78074: DEC
78075: ST_TO_ADDR
78076: LD_VAR 0 12
78080: PUSH
78081: FOR_TO
78082: IFFALSE 78617
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
78084: LD_ADDR_VAR 0 11
78088: PUSH
78089: LD_VAR 0 12
78093: PUSH
78094: LD_VAR 0 7
78098: ARRAY
78099: PUSH
78100: LD_INT 1
78102: ARRAY
78103: PPUSH
78104: LD_VAR 0 12
78108: PUSH
78109: LD_VAR 0 7
78113: ARRAY
78114: PUSH
78115: LD_INT 2
78117: ARRAY
78118: PPUSH
78119: CALL_OW 428
78123: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
78124: LD_VAR 0 12
78128: PUSH
78129: LD_VAR 0 7
78133: ARRAY
78134: PUSH
78135: LD_INT 1
78137: ARRAY
78138: PPUSH
78139: LD_VAR 0 12
78143: PUSH
78144: LD_VAR 0 7
78148: ARRAY
78149: PUSH
78150: LD_INT 2
78152: ARRAY
78153: PPUSH
78154: CALL_OW 351
78158: PUSH
78159: LD_VAR 0 12
78163: PUSH
78164: LD_VAR 0 7
78168: ARRAY
78169: PUSH
78170: LD_INT 1
78172: ARRAY
78173: PPUSH
78174: LD_VAR 0 12
78178: PUSH
78179: LD_VAR 0 7
78183: ARRAY
78184: PUSH
78185: LD_INT 2
78187: ARRAY
78188: PPUSH
78189: CALL_OW 488
78193: NOT
78194: OR
78195: PUSH
78196: LD_VAR 0 11
78200: PPUSH
78201: CALL_OW 247
78205: PUSH
78206: LD_INT 3
78208: EQUAL
78209: OR
78210: IFFALSE 78216
// exit ;
78212: POP
78213: POP
78214: GO 78619
// if not tmp or not tmp in base then
78216: LD_VAR 0 11
78220: NOT
78221: PUSH
78222: LD_VAR 0 11
78226: PUSH
78227: LD_VAR 0 1
78231: IN
78232: NOT
78233: OR
78234: IFFALSE 78238
// continue ;
78236: GO 78081
// result := true ;
78238: LD_ADDR_VAR 0 6
78242: PUSH
78243: LD_INT 1
78245: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
78246: LD_ADDR_VAR 0 15
78250: PUSH
78251: LD_VAR 0 1
78255: PPUSH
78256: LD_INT 22
78258: PUSH
78259: LD_VAR 0 11
78263: PPUSH
78264: CALL_OW 255
78268: PUSH
78269: EMPTY
78270: LIST
78271: LIST
78272: PUSH
78273: LD_INT 2
78275: PUSH
78276: LD_INT 30
78278: PUSH
78279: LD_INT 0
78281: PUSH
78282: EMPTY
78283: LIST
78284: LIST
78285: PUSH
78286: LD_INT 30
78288: PUSH
78289: LD_INT 1
78291: PUSH
78292: EMPTY
78293: LIST
78294: LIST
78295: PUSH
78296: EMPTY
78297: LIST
78298: LIST
78299: LIST
78300: PUSH
78301: EMPTY
78302: LIST
78303: LIST
78304: PPUSH
78305: CALL_OW 72
78309: ST_TO_ADDR
// if dep then
78310: LD_VAR 0 15
78314: IFFALSE 78450
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
78316: LD_ADDR_VAR 0 14
78320: PUSH
78321: LD_VAR 0 15
78325: PUSH
78326: LD_INT 1
78328: ARRAY
78329: PPUSH
78330: CALL_OW 250
78334: PPUSH
78335: LD_VAR 0 15
78339: PUSH
78340: LD_INT 1
78342: ARRAY
78343: PPUSH
78344: CALL_OW 254
78348: PPUSH
78349: LD_INT 5
78351: PPUSH
78352: CALL_OW 272
78356: PUSH
78357: LD_VAR 0 15
78361: PUSH
78362: LD_INT 1
78364: ARRAY
78365: PPUSH
78366: CALL_OW 251
78370: PPUSH
78371: LD_VAR 0 15
78375: PUSH
78376: LD_INT 1
78378: ARRAY
78379: PPUSH
78380: CALL_OW 254
78384: PPUSH
78385: LD_INT 5
78387: PPUSH
78388: CALL_OW 273
78392: PUSH
78393: EMPTY
78394: LIST
78395: LIST
78396: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
78397: LD_VAR 0 14
78401: PUSH
78402: LD_INT 1
78404: ARRAY
78405: PPUSH
78406: LD_VAR 0 14
78410: PUSH
78411: LD_INT 2
78413: ARRAY
78414: PPUSH
78415: CALL_OW 488
78419: IFFALSE 78450
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
78421: LD_VAR 0 11
78425: PPUSH
78426: LD_VAR 0 14
78430: PUSH
78431: LD_INT 1
78433: ARRAY
78434: PPUSH
78435: LD_VAR 0 14
78439: PUSH
78440: LD_INT 2
78442: ARRAY
78443: PPUSH
78444: CALL_OW 111
// continue ;
78448: GO 78081
// end ; end ; r := GetDir ( tmp ) ;
78450: LD_ADDR_VAR 0 13
78454: PUSH
78455: LD_VAR 0 11
78459: PPUSH
78460: CALL_OW 254
78464: ST_TO_ADDR
// if r = 5 then
78465: LD_VAR 0 13
78469: PUSH
78470: LD_INT 5
78472: EQUAL
78473: IFFALSE 78483
// r := 0 ;
78475: LD_ADDR_VAR 0 13
78479: PUSH
78480: LD_INT 0
78482: ST_TO_ADDR
// for j = r to 5 do
78483: LD_ADDR_VAR 0 8
78487: PUSH
78488: DOUBLE
78489: LD_VAR 0 13
78493: DEC
78494: ST_TO_ADDR
78495: LD_INT 5
78497: PUSH
78498: FOR_TO
78499: IFFALSE 78613
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
78501: LD_ADDR_VAR 0 9
78505: PUSH
78506: LD_VAR 0 11
78510: PPUSH
78511: CALL_OW 250
78515: PPUSH
78516: LD_VAR 0 8
78520: PPUSH
78521: LD_INT 2
78523: PPUSH
78524: CALL_OW 272
78528: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
78529: LD_ADDR_VAR 0 10
78533: PUSH
78534: LD_VAR 0 11
78538: PPUSH
78539: CALL_OW 251
78543: PPUSH
78544: LD_VAR 0 8
78548: PPUSH
78549: LD_INT 2
78551: PPUSH
78552: CALL_OW 273
78556: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
78557: LD_VAR 0 9
78561: PPUSH
78562: LD_VAR 0 10
78566: PPUSH
78567: CALL_OW 488
78571: PUSH
78572: LD_VAR 0 9
78576: PPUSH
78577: LD_VAR 0 10
78581: PPUSH
78582: CALL_OW 428
78586: NOT
78587: AND
78588: IFFALSE 78611
// begin ComMoveXY ( tmp , _x , _y ) ;
78590: LD_VAR 0 11
78594: PPUSH
78595: LD_VAR 0 9
78599: PPUSH
78600: LD_VAR 0 10
78604: PPUSH
78605: CALL_OW 111
// break ;
78609: GO 78613
// end ; end ;
78611: GO 78498
78613: POP
78614: POP
// end ;
78615: GO 78081
78617: POP
78618: POP
// end ;
78619: LD_VAR 0 6
78623: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
78624: LD_INT 0
78626: PPUSH
78627: PPUSH
78628: PPUSH
78629: PPUSH
78630: PPUSH
78631: PPUSH
78632: PPUSH
78633: PPUSH
78634: PPUSH
78635: PPUSH
// result := false ;
78636: LD_ADDR_VAR 0 6
78640: PUSH
78641: LD_INT 0
78643: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
78644: LD_VAR 0 1
78648: NOT
78649: PUSH
78650: LD_VAR 0 1
78654: PPUSH
78655: CALL_OW 266
78659: PUSH
78660: LD_INT 0
78662: PUSH
78663: LD_INT 1
78665: PUSH
78666: EMPTY
78667: LIST
78668: LIST
78669: IN
78670: NOT
78671: OR
78672: PUSH
78673: LD_VAR 0 2
78677: NOT
78678: OR
78679: PUSH
78680: LD_VAR 0 5
78684: PUSH
78685: LD_INT 0
78687: PUSH
78688: LD_INT 1
78690: PUSH
78691: LD_INT 2
78693: PUSH
78694: LD_INT 3
78696: PUSH
78697: LD_INT 4
78699: PUSH
78700: LD_INT 5
78702: PUSH
78703: EMPTY
78704: LIST
78705: LIST
78706: LIST
78707: LIST
78708: LIST
78709: LIST
78710: IN
78711: NOT
78712: OR
78713: PUSH
78714: LD_VAR 0 3
78718: PPUSH
78719: LD_VAR 0 4
78723: PPUSH
78724: CALL_OW 488
78728: NOT
78729: OR
78730: IFFALSE 78734
// exit ;
78732: GO 79451
// pom := GetBase ( depot ) ;
78734: LD_ADDR_VAR 0 10
78738: PUSH
78739: LD_VAR 0 1
78743: PPUSH
78744: CALL_OW 274
78748: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
78749: LD_ADDR_VAR 0 11
78753: PUSH
78754: LD_VAR 0 2
78758: PPUSH
78759: LD_VAR 0 1
78763: PPUSH
78764: CALL_OW 248
78768: PPUSH
78769: CALL_OW 450
78773: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
78774: LD_VAR 0 10
78778: PPUSH
78779: LD_INT 1
78781: PPUSH
78782: CALL_OW 275
78786: PUSH
78787: LD_VAR 0 11
78791: PUSH
78792: LD_INT 1
78794: ARRAY
78795: GREATEREQUAL
78796: PUSH
78797: LD_VAR 0 10
78801: PPUSH
78802: LD_INT 2
78804: PPUSH
78805: CALL_OW 275
78809: PUSH
78810: LD_VAR 0 11
78814: PUSH
78815: LD_INT 2
78817: ARRAY
78818: GREATEREQUAL
78819: AND
78820: PUSH
78821: LD_VAR 0 10
78825: PPUSH
78826: LD_INT 3
78828: PPUSH
78829: CALL_OW 275
78833: PUSH
78834: LD_VAR 0 11
78838: PUSH
78839: LD_INT 3
78841: ARRAY
78842: GREATEREQUAL
78843: AND
78844: NOT
78845: IFFALSE 78849
// exit ;
78847: GO 79451
// if GetBType ( depot ) = b_depot then
78849: LD_VAR 0 1
78853: PPUSH
78854: CALL_OW 266
78858: PUSH
78859: LD_INT 0
78861: EQUAL
78862: IFFALSE 78874
// dist := 28 else
78864: LD_ADDR_VAR 0 14
78868: PUSH
78869: LD_INT 28
78871: ST_TO_ADDR
78872: GO 78882
// dist := 36 ;
78874: LD_ADDR_VAR 0 14
78878: PUSH
78879: LD_INT 36
78881: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
78882: LD_VAR 0 1
78886: PPUSH
78887: LD_VAR 0 3
78891: PPUSH
78892: LD_VAR 0 4
78896: PPUSH
78897: CALL_OW 297
78901: PUSH
78902: LD_VAR 0 14
78906: GREATER
78907: IFFALSE 78911
// exit ;
78909: GO 79451
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
78911: LD_ADDR_VAR 0 12
78915: PUSH
78916: LD_VAR 0 2
78920: PPUSH
78921: LD_VAR 0 3
78925: PPUSH
78926: LD_VAR 0 4
78930: PPUSH
78931: LD_VAR 0 5
78935: PPUSH
78936: LD_VAR 0 1
78940: PPUSH
78941: CALL_OW 248
78945: PPUSH
78946: LD_INT 0
78948: PPUSH
78949: CALL 79456 0 6
78953: ST_TO_ADDR
// if not hexes then
78954: LD_VAR 0 12
78958: NOT
78959: IFFALSE 78963
// exit ;
78961: GO 79451
// hex := GetHexInfo ( x , y ) ;
78963: LD_ADDR_VAR 0 15
78967: PUSH
78968: LD_VAR 0 3
78972: PPUSH
78973: LD_VAR 0 4
78977: PPUSH
78978: CALL_OW 546
78982: ST_TO_ADDR
// if hex [ 1 ] then
78983: LD_VAR 0 15
78987: PUSH
78988: LD_INT 1
78990: ARRAY
78991: IFFALSE 78995
// exit ;
78993: GO 79451
// height := hex [ 2 ] ;
78995: LD_ADDR_VAR 0 13
78999: PUSH
79000: LD_VAR 0 15
79004: PUSH
79005: LD_INT 2
79007: ARRAY
79008: ST_TO_ADDR
// for i = 1 to hexes do
79009: LD_ADDR_VAR 0 7
79013: PUSH
79014: DOUBLE
79015: LD_INT 1
79017: DEC
79018: ST_TO_ADDR
79019: LD_VAR 0 12
79023: PUSH
79024: FOR_TO
79025: IFFALSE 79355
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
79027: LD_VAR 0 12
79031: PUSH
79032: LD_VAR 0 7
79036: ARRAY
79037: PUSH
79038: LD_INT 1
79040: ARRAY
79041: PPUSH
79042: LD_VAR 0 12
79046: PUSH
79047: LD_VAR 0 7
79051: ARRAY
79052: PUSH
79053: LD_INT 2
79055: ARRAY
79056: PPUSH
79057: CALL_OW 488
79061: NOT
79062: PUSH
79063: LD_VAR 0 12
79067: PUSH
79068: LD_VAR 0 7
79072: ARRAY
79073: PUSH
79074: LD_INT 1
79076: ARRAY
79077: PPUSH
79078: LD_VAR 0 12
79082: PUSH
79083: LD_VAR 0 7
79087: ARRAY
79088: PUSH
79089: LD_INT 2
79091: ARRAY
79092: PPUSH
79093: CALL_OW 428
79097: PUSH
79098: LD_INT 0
79100: GREATER
79101: OR
79102: PUSH
79103: LD_VAR 0 12
79107: PUSH
79108: LD_VAR 0 7
79112: ARRAY
79113: PUSH
79114: LD_INT 1
79116: ARRAY
79117: PPUSH
79118: LD_VAR 0 12
79122: PUSH
79123: LD_VAR 0 7
79127: ARRAY
79128: PUSH
79129: LD_INT 2
79131: ARRAY
79132: PPUSH
79133: CALL_OW 351
79137: OR
79138: IFFALSE 79144
// exit ;
79140: POP
79141: POP
79142: GO 79451
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79144: LD_ADDR_VAR 0 8
79148: PUSH
79149: LD_VAR 0 12
79153: PUSH
79154: LD_VAR 0 7
79158: ARRAY
79159: PUSH
79160: LD_INT 1
79162: ARRAY
79163: PPUSH
79164: LD_VAR 0 12
79168: PUSH
79169: LD_VAR 0 7
79173: ARRAY
79174: PUSH
79175: LD_INT 2
79177: ARRAY
79178: PPUSH
79179: CALL_OW 546
79183: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
79184: LD_VAR 0 8
79188: PUSH
79189: LD_INT 1
79191: ARRAY
79192: PUSH
79193: LD_VAR 0 8
79197: PUSH
79198: LD_INT 2
79200: ARRAY
79201: PUSH
79202: LD_VAR 0 13
79206: PUSH
79207: LD_INT 2
79209: PLUS
79210: GREATER
79211: OR
79212: PUSH
79213: LD_VAR 0 8
79217: PUSH
79218: LD_INT 2
79220: ARRAY
79221: PUSH
79222: LD_VAR 0 13
79226: PUSH
79227: LD_INT 2
79229: MINUS
79230: LESS
79231: OR
79232: PUSH
79233: LD_VAR 0 8
79237: PUSH
79238: LD_INT 3
79240: ARRAY
79241: PUSH
79242: LD_INT 0
79244: PUSH
79245: LD_INT 8
79247: PUSH
79248: LD_INT 9
79250: PUSH
79251: LD_INT 10
79253: PUSH
79254: LD_INT 11
79256: PUSH
79257: LD_INT 12
79259: PUSH
79260: LD_INT 13
79262: PUSH
79263: LD_INT 16
79265: PUSH
79266: LD_INT 17
79268: PUSH
79269: LD_INT 18
79271: PUSH
79272: LD_INT 19
79274: PUSH
79275: LD_INT 20
79277: PUSH
79278: LD_INT 21
79280: PUSH
79281: EMPTY
79282: LIST
79283: LIST
79284: LIST
79285: LIST
79286: LIST
79287: LIST
79288: LIST
79289: LIST
79290: LIST
79291: LIST
79292: LIST
79293: LIST
79294: LIST
79295: IN
79296: NOT
79297: OR
79298: PUSH
79299: LD_VAR 0 8
79303: PUSH
79304: LD_INT 5
79306: ARRAY
79307: NOT
79308: OR
79309: PUSH
79310: LD_VAR 0 8
79314: PUSH
79315: LD_INT 6
79317: ARRAY
79318: PUSH
79319: LD_INT 1
79321: PUSH
79322: LD_INT 2
79324: PUSH
79325: LD_INT 7
79327: PUSH
79328: LD_INT 9
79330: PUSH
79331: LD_INT 10
79333: PUSH
79334: LD_INT 11
79336: PUSH
79337: EMPTY
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: IN
79345: NOT
79346: OR
79347: IFFALSE 79353
// exit ;
79349: POP
79350: POP
79351: GO 79451
// end ;
79353: GO 79024
79355: POP
79356: POP
// side := GetSide ( depot ) ;
79357: LD_ADDR_VAR 0 9
79361: PUSH
79362: LD_VAR 0 1
79366: PPUSH
79367: CALL_OW 255
79371: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79372: LD_VAR 0 9
79376: PPUSH
79377: LD_VAR 0 3
79381: PPUSH
79382: LD_VAR 0 4
79386: PPUSH
79387: LD_INT 20
79389: PPUSH
79390: CALL 72105 0 4
79394: PUSH
79395: LD_INT 4
79397: ARRAY
79398: IFFALSE 79402
// exit ;
79400: GO 79451
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
79402: LD_VAR 0 2
79406: PUSH
79407: LD_INT 29
79409: PUSH
79410: LD_INT 30
79412: PUSH
79413: EMPTY
79414: LIST
79415: LIST
79416: IN
79417: PUSH
79418: LD_VAR 0 3
79422: PPUSH
79423: LD_VAR 0 4
79427: PPUSH
79428: LD_VAR 0 9
79432: PPUSH
79433: CALL_OW 440
79437: NOT
79438: AND
79439: IFFALSE 79443
// exit ;
79441: GO 79451
// result := true ;
79443: LD_ADDR_VAR 0 6
79447: PUSH
79448: LD_INT 1
79450: ST_TO_ADDR
// end ;
79451: LD_VAR 0 6
79455: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
79456: LD_INT 0
79458: PPUSH
79459: PPUSH
79460: PPUSH
79461: PPUSH
79462: PPUSH
79463: PPUSH
79464: PPUSH
79465: PPUSH
79466: PPUSH
79467: PPUSH
79468: PPUSH
79469: PPUSH
79470: PPUSH
79471: PPUSH
79472: PPUSH
79473: PPUSH
79474: PPUSH
79475: PPUSH
79476: PPUSH
79477: PPUSH
79478: PPUSH
79479: PPUSH
79480: PPUSH
79481: PPUSH
79482: PPUSH
79483: PPUSH
79484: PPUSH
79485: PPUSH
79486: PPUSH
79487: PPUSH
79488: PPUSH
79489: PPUSH
79490: PPUSH
79491: PPUSH
79492: PPUSH
79493: PPUSH
79494: PPUSH
79495: PPUSH
79496: PPUSH
79497: PPUSH
79498: PPUSH
79499: PPUSH
79500: PPUSH
79501: PPUSH
79502: PPUSH
79503: PPUSH
79504: PPUSH
79505: PPUSH
79506: PPUSH
79507: PPUSH
79508: PPUSH
79509: PPUSH
79510: PPUSH
79511: PPUSH
79512: PPUSH
79513: PPUSH
79514: PPUSH
79515: PPUSH
// result = [ ] ;
79516: LD_ADDR_VAR 0 7
79520: PUSH
79521: EMPTY
79522: ST_TO_ADDR
// temp_list = [ ] ;
79523: LD_ADDR_VAR 0 9
79527: PUSH
79528: EMPTY
79529: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
79530: LD_VAR 0 4
79534: PUSH
79535: LD_INT 0
79537: PUSH
79538: LD_INT 1
79540: PUSH
79541: LD_INT 2
79543: PUSH
79544: LD_INT 3
79546: PUSH
79547: LD_INT 4
79549: PUSH
79550: LD_INT 5
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: LIST
79557: LIST
79558: LIST
79559: LIST
79560: IN
79561: NOT
79562: PUSH
79563: LD_VAR 0 1
79567: PUSH
79568: LD_INT 0
79570: PUSH
79571: LD_INT 1
79573: PUSH
79574: EMPTY
79575: LIST
79576: LIST
79577: IN
79578: PUSH
79579: LD_VAR 0 5
79583: PUSH
79584: LD_INT 1
79586: PUSH
79587: LD_INT 2
79589: PUSH
79590: LD_INT 3
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: LIST
79597: IN
79598: NOT
79599: AND
79600: OR
79601: IFFALSE 79605
// exit ;
79603: GO 97996
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
79605: LD_VAR 0 1
79609: PUSH
79610: LD_INT 6
79612: PUSH
79613: LD_INT 7
79615: PUSH
79616: LD_INT 8
79618: PUSH
79619: LD_INT 13
79621: PUSH
79622: LD_INT 12
79624: PUSH
79625: LD_INT 15
79627: PUSH
79628: LD_INT 11
79630: PUSH
79631: LD_INT 14
79633: PUSH
79634: LD_INT 10
79636: PUSH
79637: EMPTY
79638: LIST
79639: LIST
79640: LIST
79641: LIST
79642: LIST
79643: LIST
79644: LIST
79645: LIST
79646: LIST
79647: IN
79648: IFFALSE 79658
// btype = b_lab ;
79650: LD_ADDR_VAR 0 1
79654: PUSH
79655: LD_INT 6
79657: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
79658: LD_VAR 0 6
79662: PUSH
79663: LD_INT 0
79665: PUSH
79666: LD_INT 1
79668: PUSH
79669: LD_INT 2
79671: PUSH
79672: EMPTY
79673: LIST
79674: LIST
79675: LIST
79676: IN
79677: NOT
79678: PUSH
79679: LD_VAR 0 1
79683: PUSH
79684: LD_INT 0
79686: PUSH
79687: LD_INT 1
79689: PUSH
79690: LD_INT 2
79692: PUSH
79693: LD_INT 3
79695: PUSH
79696: LD_INT 6
79698: PUSH
79699: LD_INT 36
79701: PUSH
79702: LD_INT 4
79704: PUSH
79705: LD_INT 5
79707: PUSH
79708: LD_INT 31
79710: PUSH
79711: LD_INT 32
79713: PUSH
79714: LD_INT 33
79716: PUSH
79717: EMPTY
79718: LIST
79719: LIST
79720: LIST
79721: LIST
79722: LIST
79723: LIST
79724: LIST
79725: LIST
79726: LIST
79727: LIST
79728: LIST
79729: IN
79730: NOT
79731: PUSH
79732: LD_VAR 0 6
79736: PUSH
79737: LD_INT 1
79739: EQUAL
79740: AND
79741: OR
79742: PUSH
79743: LD_VAR 0 1
79747: PUSH
79748: LD_INT 2
79750: PUSH
79751: LD_INT 3
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: IN
79758: NOT
79759: PUSH
79760: LD_VAR 0 6
79764: PUSH
79765: LD_INT 2
79767: EQUAL
79768: AND
79769: OR
79770: IFFALSE 79780
// mode = 0 ;
79772: LD_ADDR_VAR 0 6
79776: PUSH
79777: LD_INT 0
79779: ST_TO_ADDR
// case mode of 0 :
79780: LD_VAR 0 6
79784: PUSH
79785: LD_INT 0
79787: DOUBLE
79788: EQUAL
79789: IFTRUE 79793
79791: GO 91246
79793: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
79794: LD_ADDR_VAR 0 11
79798: PUSH
79799: LD_INT 0
79801: PUSH
79802: LD_INT 0
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 0
79811: PUSH
79812: LD_INT 1
79814: NEG
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 1
79822: PUSH
79823: LD_INT 0
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 1
79832: PUSH
79833: LD_INT 1
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 0
79842: PUSH
79843: LD_INT 1
79845: PUSH
79846: EMPTY
79847: LIST
79848: LIST
79849: PUSH
79850: LD_INT 1
79852: NEG
79853: PUSH
79854: LD_INT 0
79856: PUSH
79857: EMPTY
79858: LIST
79859: LIST
79860: PUSH
79861: LD_INT 1
79863: NEG
79864: PUSH
79865: LD_INT 1
79867: NEG
79868: PUSH
79869: EMPTY
79870: LIST
79871: LIST
79872: PUSH
79873: LD_INT 1
79875: NEG
79876: PUSH
79877: LD_INT 2
79879: NEG
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 0
79887: PUSH
79888: LD_INT 2
79890: NEG
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 1
79898: PUSH
79899: LD_INT 1
79901: NEG
79902: PUSH
79903: EMPTY
79904: LIST
79905: LIST
79906: PUSH
79907: LD_INT 1
79909: PUSH
79910: LD_INT 2
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: PUSH
79917: LD_INT 0
79919: PUSH
79920: LD_INT 2
79922: PUSH
79923: EMPTY
79924: LIST
79925: LIST
79926: PUSH
79927: LD_INT 1
79929: NEG
79930: PUSH
79931: LD_INT 1
79933: PUSH
79934: EMPTY
79935: LIST
79936: LIST
79937: PUSH
79938: LD_INT 1
79940: PUSH
79941: LD_INT 3
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 0
79950: PUSH
79951: LD_INT 3
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PUSH
79958: LD_INT 1
79960: NEG
79961: PUSH
79962: LD_INT 2
79964: PUSH
79965: EMPTY
79966: LIST
79967: LIST
79968: PUSH
79969: EMPTY
79970: LIST
79971: LIST
79972: LIST
79973: LIST
79974: LIST
79975: LIST
79976: LIST
79977: LIST
79978: LIST
79979: LIST
79980: LIST
79981: LIST
79982: LIST
79983: LIST
79984: LIST
79985: LIST
79986: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
79987: LD_ADDR_VAR 0 12
79991: PUSH
79992: LD_INT 0
79994: PUSH
79995: LD_INT 0
79997: PUSH
79998: EMPTY
79999: LIST
80000: LIST
80001: PUSH
80002: LD_INT 0
80004: PUSH
80005: LD_INT 1
80007: NEG
80008: PUSH
80009: EMPTY
80010: LIST
80011: LIST
80012: PUSH
80013: LD_INT 1
80015: PUSH
80016: LD_INT 0
80018: PUSH
80019: EMPTY
80020: LIST
80021: LIST
80022: PUSH
80023: LD_INT 1
80025: PUSH
80026: LD_INT 1
80028: PUSH
80029: EMPTY
80030: LIST
80031: LIST
80032: PUSH
80033: LD_INT 0
80035: PUSH
80036: LD_INT 1
80038: PUSH
80039: EMPTY
80040: LIST
80041: LIST
80042: PUSH
80043: LD_INT 1
80045: NEG
80046: PUSH
80047: LD_INT 0
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 1
80056: NEG
80057: PUSH
80058: LD_INT 1
80060: NEG
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: PUSH
80066: LD_INT 1
80068: PUSH
80069: LD_INT 1
80071: NEG
80072: PUSH
80073: EMPTY
80074: LIST
80075: LIST
80076: PUSH
80077: LD_INT 2
80079: PUSH
80080: LD_INT 0
80082: PUSH
80083: EMPTY
80084: LIST
80085: LIST
80086: PUSH
80087: LD_INT 2
80089: PUSH
80090: LD_INT 1
80092: PUSH
80093: EMPTY
80094: LIST
80095: LIST
80096: PUSH
80097: LD_INT 1
80099: NEG
80100: PUSH
80101: LD_INT 1
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 2
80110: NEG
80111: PUSH
80112: LD_INT 0
80114: PUSH
80115: EMPTY
80116: LIST
80117: LIST
80118: PUSH
80119: LD_INT 2
80121: NEG
80122: PUSH
80123: LD_INT 1
80125: NEG
80126: PUSH
80127: EMPTY
80128: LIST
80129: LIST
80130: PUSH
80131: LD_INT 2
80133: NEG
80134: PUSH
80135: LD_INT 1
80137: PUSH
80138: EMPTY
80139: LIST
80140: LIST
80141: PUSH
80142: LD_INT 3
80144: NEG
80145: PUSH
80146: LD_INT 0
80148: PUSH
80149: EMPTY
80150: LIST
80151: LIST
80152: PUSH
80153: LD_INT 3
80155: NEG
80156: PUSH
80157: LD_INT 1
80159: NEG
80160: PUSH
80161: EMPTY
80162: LIST
80163: LIST
80164: PUSH
80165: EMPTY
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
80183: LD_ADDR_VAR 0 13
80187: PUSH
80188: LD_INT 0
80190: PUSH
80191: LD_INT 0
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 0
80200: PUSH
80201: LD_INT 1
80203: NEG
80204: PUSH
80205: EMPTY
80206: LIST
80207: LIST
80208: PUSH
80209: LD_INT 1
80211: PUSH
80212: LD_INT 0
80214: PUSH
80215: EMPTY
80216: LIST
80217: LIST
80218: PUSH
80219: LD_INT 1
80221: PUSH
80222: LD_INT 1
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 0
80231: PUSH
80232: LD_INT 1
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 1
80241: NEG
80242: PUSH
80243: LD_INT 0
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 1
80252: NEG
80253: PUSH
80254: LD_INT 1
80256: NEG
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 1
80264: NEG
80265: PUSH
80266: LD_INT 2
80268: NEG
80269: PUSH
80270: EMPTY
80271: LIST
80272: LIST
80273: PUSH
80274: LD_INT 2
80276: PUSH
80277: LD_INT 1
80279: PUSH
80280: EMPTY
80281: LIST
80282: LIST
80283: PUSH
80284: LD_INT 2
80286: PUSH
80287: LD_INT 2
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 1
80296: PUSH
80297: LD_INT 2
80299: PUSH
80300: EMPTY
80301: LIST
80302: LIST
80303: PUSH
80304: LD_INT 2
80306: NEG
80307: PUSH
80308: LD_INT 1
80310: NEG
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 2
80318: NEG
80319: PUSH
80320: LD_INT 2
80322: NEG
80323: PUSH
80324: EMPTY
80325: LIST
80326: LIST
80327: PUSH
80328: LD_INT 2
80330: NEG
80331: PUSH
80332: LD_INT 3
80334: NEG
80335: PUSH
80336: EMPTY
80337: LIST
80338: LIST
80339: PUSH
80340: LD_INT 3
80342: NEG
80343: PUSH
80344: LD_INT 2
80346: NEG
80347: PUSH
80348: EMPTY
80349: LIST
80350: LIST
80351: PUSH
80352: LD_INT 3
80354: NEG
80355: PUSH
80356: LD_INT 3
80358: NEG
80359: PUSH
80360: EMPTY
80361: LIST
80362: LIST
80363: PUSH
80364: EMPTY
80365: LIST
80366: LIST
80367: LIST
80368: LIST
80369: LIST
80370: LIST
80371: LIST
80372: LIST
80373: LIST
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
80382: LD_ADDR_VAR 0 14
80386: PUSH
80387: LD_INT 0
80389: PUSH
80390: LD_INT 0
80392: PUSH
80393: EMPTY
80394: LIST
80395: LIST
80396: PUSH
80397: LD_INT 0
80399: PUSH
80400: LD_INT 1
80402: NEG
80403: PUSH
80404: EMPTY
80405: LIST
80406: LIST
80407: PUSH
80408: LD_INT 1
80410: PUSH
80411: LD_INT 0
80413: PUSH
80414: EMPTY
80415: LIST
80416: LIST
80417: PUSH
80418: LD_INT 1
80420: PUSH
80421: LD_INT 1
80423: PUSH
80424: EMPTY
80425: LIST
80426: LIST
80427: PUSH
80428: LD_INT 0
80430: PUSH
80431: LD_INT 1
80433: PUSH
80434: EMPTY
80435: LIST
80436: LIST
80437: PUSH
80438: LD_INT 1
80440: NEG
80441: PUSH
80442: LD_INT 0
80444: PUSH
80445: EMPTY
80446: LIST
80447: LIST
80448: PUSH
80449: LD_INT 1
80451: NEG
80452: PUSH
80453: LD_INT 1
80455: NEG
80456: PUSH
80457: EMPTY
80458: LIST
80459: LIST
80460: PUSH
80461: LD_INT 1
80463: NEG
80464: PUSH
80465: LD_INT 2
80467: NEG
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 0
80475: PUSH
80476: LD_INT 2
80478: NEG
80479: PUSH
80480: EMPTY
80481: LIST
80482: LIST
80483: PUSH
80484: LD_INT 1
80486: PUSH
80487: LD_INT 1
80489: NEG
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 1
80497: PUSH
80498: LD_INT 2
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 0
80507: PUSH
80508: LD_INT 2
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 1
80517: NEG
80518: PUSH
80519: LD_INT 1
80521: PUSH
80522: EMPTY
80523: LIST
80524: LIST
80525: PUSH
80526: LD_INT 1
80528: NEG
80529: PUSH
80530: LD_INT 3
80532: NEG
80533: PUSH
80534: EMPTY
80535: LIST
80536: LIST
80537: PUSH
80538: LD_INT 0
80540: PUSH
80541: LD_INT 3
80543: NEG
80544: PUSH
80545: EMPTY
80546: LIST
80547: LIST
80548: PUSH
80549: LD_INT 1
80551: PUSH
80552: LD_INT 2
80554: NEG
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: LIST
80566: LIST
80567: LIST
80568: LIST
80569: LIST
80570: LIST
80571: LIST
80572: LIST
80573: LIST
80574: LIST
80575: LIST
80576: LIST
80577: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
80578: LD_ADDR_VAR 0 15
80582: PUSH
80583: LD_INT 0
80585: PUSH
80586: LD_INT 0
80588: PUSH
80589: EMPTY
80590: LIST
80591: LIST
80592: PUSH
80593: LD_INT 0
80595: PUSH
80596: LD_INT 1
80598: NEG
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: PUSH
80604: LD_INT 1
80606: PUSH
80607: LD_INT 0
80609: PUSH
80610: EMPTY
80611: LIST
80612: LIST
80613: PUSH
80614: LD_INT 1
80616: PUSH
80617: LD_INT 1
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: PUSH
80624: LD_INT 0
80626: PUSH
80627: LD_INT 1
80629: PUSH
80630: EMPTY
80631: LIST
80632: LIST
80633: PUSH
80634: LD_INT 1
80636: NEG
80637: PUSH
80638: LD_INT 0
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 1
80647: NEG
80648: PUSH
80649: LD_INT 1
80651: NEG
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 1
80659: PUSH
80660: LD_INT 1
80662: NEG
80663: PUSH
80664: EMPTY
80665: LIST
80666: LIST
80667: PUSH
80668: LD_INT 2
80670: PUSH
80671: LD_INT 0
80673: PUSH
80674: EMPTY
80675: LIST
80676: LIST
80677: PUSH
80678: LD_INT 2
80680: PUSH
80681: LD_INT 1
80683: PUSH
80684: EMPTY
80685: LIST
80686: LIST
80687: PUSH
80688: LD_INT 1
80690: NEG
80691: PUSH
80692: LD_INT 1
80694: PUSH
80695: EMPTY
80696: LIST
80697: LIST
80698: PUSH
80699: LD_INT 2
80701: NEG
80702: PUSH
80703: LD_INT 0
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: PUSH
80710: LD_INT 2
80712: NEG
80713: PUSH
80714: LD_INT 1
80716: NEG
80717: PUSH
80718: EMPTY
80719: LIST
80720: LIST
80721: PUSH
80722: LD_INT 2
80724: PUSH
80725: LD_INT 1
80727: NEG
80728: PUSH
80729: EMPTY
80730: LIST
80731: LIST
80732: PUSH
80733: LD_INT 3
80735: PUSH
80736: LD_INT 0
80738: PUSH
80739: EMPTY
80740: LIST
80741: LIST
80742: PUSH
80743: LD_INT 3
80745: PUSH
80746: LD_INT 1
80748: PUSH
80749: EMPTY
80750: LIST
80751: LIST
80752: PUSH
80753: EMPTY
80754: LIST
80755: LIST
80756: LIST
80757: LIST
80758: LIST
80759: LIST
80760: LIST
80761: LIST
80762: LIST
80763: LIST
80764: LIST
80765: LIST
80766: LIST
80767: LIST
80768: LIST
80769: LIST
80770: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
80771: LD_ADDR_VAR 0 16
80775: PUSH
80776: LD_INT 0
80778: PUSH
80779: LD_INT 0
80781: PUSH
80782: EMPTY
80783: LIST
80784: LIST
80785: PUSH
80786: LD_INT 0
80788: PUSH
80789: LD_INT 1
80791: NEG
80792: PUSH
80793: EMPTY
80794: LIST
80795: LIST
80796: PUSH
80797: LD_INT 1
80799: PUSH
80800: LD_INT 0
80802: PUSH
80803: EMPTY
80804: LIST
80805: LIST
80806: PUSH
80807: LD_INT 1
80809: PUSH
80810: LD_INT 1
80812: PUSH
80813: EMPTY
80814: LIST
80815: LIST
80816: PUSH
80817: LD_INT 0
80819: PUSH
80820: LD_INT 1
80822: PUSH
80823: EMPTY
80824: LIST
80825: LIST
80826: PUSH
80827: LD_INT 1
80829: NEG
80830: PUSH
80831: LD_INT 0
80833: PUSH
80834: EMPTY
80835: LIST
80836: LIST
80837: PUSH
80838: LD_INT 1
80840: NEG
80841: PUSH
80842: LD_INT 1
80844: NEG
80845: PUSH
80846: EMPTY
80847: LIST
80848: LIST
80849: PUSH
80850: LD_INT 1
80852: NEG
80853: PUSH
80854: LD_INT 2
80856: NEG
80857: PUSH
80858: EMPTY
80859: LIST
80860: LIST
80861: PUSH
80862: LD_INT 2
80864: PUSH
80865: LD_INT 1
80867: PUSH
80868: EMPTY
80869: LIST
80870: LIST
80871: PUSH
80872: LD_INT 2
80874: PUSH
80875: LD_INT 2
80877: PUSH
80878: EMPTY
80879: LIST
80880: LIST
80881: PUSH
80882: LD_INT 1
80884: PUSH
80885: LD_INT 2
80887: PUSH
80888: EMPTY
80889: LIST
80890: LIST
80891: PUSH
80892: LD_INT 2
80894: NEG
80895: PUSH
80896: LD_INT 1
80898: NEG
80899: PUSH
80900: EMPTY
80901: LIST
80902: LIST
80903: PUSH
80904: LD_INT 2
80906: NEG
80907: PUSH
80908: LD_INT 2
80910: NEG
80911: PUSH
80912: EMPTY
80913: LIST
80914: LIST
80915: PUSH
80916: LD_INT 3
80918: PUSH
80919: LD_INT 2
80921: PUSH
80922: EMPTY
80923: LIST
80924: LIST
80925: PUSH
80926: LD_INT 3
80928: PUSH
80929: LD_INT 3
80931: PUSH
80932: EMPTY
80933: LIST
80934: LIST
80935: PUSH
80936: LD_INT 2
80938: PUSH
80939: LD_INT 3
80941: PUSH
80942: EMPTY
80943: LIST
80944: LIST
80945: PUSH
80946: EMPTY
80947: LIST
80948: LIST
80949: LIST
80950: LIST
80951: LIST
80952: LIST
80953: LIST
80954: LIST
80955: LIST
80956: LIST
80957: LIST
80958: LIST
80959: LIST
80960: LIST
80961: LIST
80962: LIST
80963: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
80964: LD_ADDR_VAR 0 17
80968: PUSH
80969: LD_INT 0
80971: PUSH
80972: LD_INT 0
80974: PUSH
80975: EMPTY
80976: LIST
80977: LIST
80978: PUSH
80979: LD_INT 0
80981: PUSH
80982: LD_INT 1
80984: NEG
80985: PUSH
80986: EMPTY
80987: LIST
80988: LIST
80989: PUSH
80990: LD_INT 1
80992: PUSH
80993: LD_INT 0
80995: PUSH
80996: EMPTY
80997: LIST
80998: LIST
80999: PUSH
81000: LD_INT 1
81002: PUSH
81003: LD_INT 1
81005: PUSH
81006: EMPTY
81007: LIST
81008: LIST
81009: PUSH
81010: LD_INT 0
81012: PUSH
81013: LD_INT 1
81015: PUSH
81016: EMPTY
81017: LIST
81018: LIST
81019: PUSH
81020: LD_INT 1
81022: NEG
81023: PUSH
81024: LD_INT 0
81026: PUSH
81027: EMPTY
81028: LIST
81029: LIST
81030: PUSH
81031: LD_INT 1
81033: NEG
81034: PUSH
81035: LD_INT 1
81037: NEG
81038: PUSH
81039: EMPTY
81040: LIST
81041: LIST
81042: PUSH
81043: LD_INT 1
81045: NEG
81046: PUSH
81047: LD_INT 2
81049: NEG
81050: PUSH
81051: EMPTY
81052: LIST
81053: LIST
81054: PUSH
81055: LD_INT 0
81057: PUSH
81058: LD_INT 2
81060: NEG
81061: PUSH
81062: EMPTY
81063: LIST
81064: LIST
81065: PUSH
81066: LD_INT 1
81068: PUSH
81069: LD_INT 1
81071: NEG
81072: PUSH
81073: EMPTY
81074: LIST
81075: LIST
81076: PUSH
81077: LD_INT 2
81079: PUSH
81080: LD_INT 0
81082: PUSH
81083: EMPTY
81084: LIST
81085: LIST
81086: PUSH
81087: LD_INT 2
81089: PUSH
81090: LD_INT 1
81092: PUSH
81093: EMPTY
81094: LIST
81095: LIST
81096: PUSH
81097: LD_INT 2
81099: PUSH
81100: LD_INT 2
81102: PUSH
81103: EMPTY
81104: LIST
81105: LIST
81106: PUSH
81107: LD_INT 1
81109: PUSH
81110: LD_INT 2
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 0
81119: PUSH
81120: LD_INT 2
81122: PUSH
81123: EMPTY
81124: LIST
81125: LIST
81126: PUSH
81127: LD_INT 1
81129: NEG
81130: PUSH
81131: LD_INT 1
81133: PUSH
81134: EMPTY
81135: LIST
81136: LIST
81137: PUSH
81138: LD_INT 2
81140: NEG
81141: PUSH
81142: LD_INT 0
81144: PUSH
81145: EMPTY
81146: LIST
81147: LIST
81148: PUSH
81149: LD_INT 2
81151: NEG
81152: PUSH
81153: LD_INT 1
81155: NEG
81156: PUSH
81157: EMPTY
81158: LIST
81159: LIST
81160: PUSH
81161: LD_INT 2
81163: NEG
81164: PUSH
81165: LD_INT 2
81167: NEG
81168: PUSH
81169: EMPTY
81170: LIST
81171: LIST
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: LIST
81183: LIST
81184: LIST
81185: LIST
81186: LIST
81187: LIST
81188: LIST
81189: LIST
81190: LIST
81191: LIST
81192: LIST
81193: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81194: LD_ADDR_VAR 0 18
81198: PUSH
81199: LD_INT 0
81201: PUSH
81202: LD_INT 0
81204: PUSH
81205: EMPTY
81206: LIST
81207: LIST
81208: PUSH
81209: LD_INT 0
81211: PUSH
81212: LD_INT 1
81214: NEG
81215: PUSH
81216: EMPTY
81217: LIST
81218: LIST
81219: PUSH
81220: LD_INT 1
81222: PUSH
81223: LD_INT 0
81225: PUSH
81226: EMPTY
81227: LIST
81228: LIST
81229: PUSH
81230: LD_INT 1
81232: PUSH
81233: LD_INT 1
81235: PUSH
81236: EMPTY
81237: LIST
81238: LIST
81239: PUSH
81240: LD_INT 0
81242: PUSH
81243: LD_INT 1
81245: PUSH
81246: EMPTY
81247: LIST
81248: LIST
81249: PUSH
81250: LD_INT 1
81252: NEG
81253: PUSH
81254: LD_INT 0
81256: PUSH
81257: EMPTY
81258: LIST
81259: LIST
81260: PUSH
81261: LD_INT 1
81263: NEG
81264: PUSH
81265: LD_INT 1
81267: NEG
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: PUSH
81273: LD_INT 1
81275: NEG
81276: PUSH
81277: LD_INT 2
81279: NEG
81280: PUSH
81281: EMPTY
81282: LIST
81283: LIST
81284: PUSH
81285: LD_INT 0
81287: PUSH
81288: LD_INT 2
81290: NEG
81291: PUSH
81292: EMPTY
81293: LIST
81294: LIST
81295: PUSH
81296: LD_INT 1
81298: PUSH
81299: LD_INT 1
81301: NEG
81302: PUSH
81303: EMPTY
81304: LIST
81305: LIST
81306: PUSH
81307: LD_INT 2
81309: PUSH
81310: LD_INT 0
81312: PUSH
81313: EMPTY
81314: LIST
81315: LIST
81316: PUSH
81317: LD_INT 2
81319: PUSH
81320: LD_INT 1
81322: PUSH
81323: EMPTY
81324: LIST
81325: LIST
81326: PUSH
81327: LD_INT 2
81329: PUSH
81330: LD_INT 2
81332: PUSH
81333: EMPTY
81334: LIST
81335: LIST
81336: PUSH
81337: LD_INT 1
81339: PUSH
81340: LD_INT 2
81342: PUSH
81343: EMPTY
81344: LIST
81345: LIST
81346: PUSH
81347: LD_INT 0
81349: PUSH
81350: LD_INT 2
81352: PUSH
81353: EMPTY
81354: LIST
81355: LIST
81356: PUSH
81357: LD_INT 1
81359: NEG
81360: PUSH
81361: LD_INT 1
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: LD_INT 2
81370: NEG
81371: PUSH
81372: LD_INT 0
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: PUSH
81379: LD_INT 2
81381: NEG
81382: PUSH
81383: LD_INT 1
81385: NEG
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PUSH
81391: LD_INT 2
81393: NEG
81394: PUSH
81395: LD_INT 2
81397: NEG
81398: PUSH
81399: EMPTY
81400: LIST
81401: LIST
81402: PUSH
81403: EMPTY
81404: LIST
81405: LIST
81406: LIST
81407: LIST
81408: LIST
81409: LIST
81410: LIST
81411: LIST
81412: LIST
81413: LIST
81414: LIST
81415: LIST
81416: LIST
81417: LIST
81418: LIST
81419: LIST
81420: LIST
81421: LIST
81422: LIST
81423: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81424: LD_ADDR_VAR 0 19
81428: PUSH
81429: LD_INT 0
81431: PUSH
81432: LD_INT 0
81434: PUSH
81435: EMPTY
81436: LIST
81437: LIST
81438: PUSH
81439: LD_INT 0
81441: PUSH
81442: LD_INT 1
81444: NEG
81445: PUSH
81446: EMPTY
81447: LIST
81448: LIST
81449: PUSH
81450: LD_INT 1
81452: PUSH
81453: LD_INT 0
81455: PUSH
81456: EMPTY
81457: LIST
81458: LIST
81459: PUSH
81460: LD_INT 1
81462: PUSH
81463: LD_INT 1
81465: PUSH
81466: EMPTY
81467: LIST
81468: LIST
81469: PUSH
81470: LD_INT 0
81472: PUSH
81473: LD_INT 1
81475: PUSH
81476: EMPTY
81477: LIST
81478: LIST
81479: PUSH
81480: LD_INT 1
81482: NEG
81483: PUSH
81484: LD_INT 0
81486: PUSH
81487: EMPTY
81488: LIST
81489: LIST
81490: PUSH
81491: LD_INT 1
81493: NEG
81494: PUSH
81495: LD_INT 1
81497: NEG
81498: PUSH
81499: EMPTY
81500: LIST
81501: LIST
81502: PUSH
81503: LD_INT 1
81505: NEG
81506: PUSH
81507: LD_INT 2
81509: NEG
81510: PUSH
81511: EMPTY
81512: LIST
81513: LIST
81514: PUSH
81515: LD_INT 0
81517: PUSH
81518: LD_INT 2
81520: NEG
81521: PUSH
81522: EMPTY
81523: LIST
81524: LIST
81525: PUSH
81526: LD_INT 1
81528: PUSH
81529: LD_INT 1
81531: NEG
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: PUSH
81537: LD_INT 2
81539: PUSH
81540: LD_INT 0
81542: PUSH
81543: EMPTY
81544: LIST
81545: LIST
81546: PUSH
81547: LD_INT 2
81549: PUSH
81550: LD_INT 1
81552: PUSH
81553: EMPTY
81554: LIST
81555: LIST
81556: PUSH
81557: LD_INT 2
81559: PUSH
81560: LD_INT 2
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: LD_INT 1
81569: PUSH
81570: LD_INT 2
81572: PUSH
81573: EMPTY
81574: LIST
81575: LIST
81576: PUSH
81577: LD_INT 0
81579: PUSH
81580: LD_INT 2
81582: PUSH
81583: EMPTY
81584: LIST
81585: LIST
81586: PUSH
81587: LD_INT 1
81589: NEG
81590: PUSH
81591: LD_INT 1
81593: PUSH
81594: EMPTY
81595: LIST
81596: LIST
81597: PUSH
81598: LD_INT 2
81600: NEG
81601: PUSH
81602: LD_INT 0
81604: PUSH
81605: EMPTY
81606: LIST
81607: LIST
81608: PUSH
81609: LD_INT 2
81611: NEG
81612: PUSH
81613: LD_INT 1
81615: NEG
81616: PUSH
81617: EMPTY
81618: LIST
81619: LIST
81620: PUSH
81621: LD_INT 2
81623: NEG
81624: PUSH
81625: LD_INT 2
81627: NEG
81628: PUSH
81629: EMPTY
81630: LIST
81631: LIST
81632: PUSH
81633: EMPTY
81634: LIST
81635: LIST
81636: LIST
81637: LIST
81638: LIST
81639: LIST
81640: LIST
81641: LIST
81642: LIST
81643: LIST
81644: LIST
81645: LIST
81646: LIST
81647: LIST
81648: LIST
81649: LIST
81650: LIST
81651: LIST
81652: LIST
81653: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81654: LD_ADDR_VAR 0 20
81658: PUSH
81659: LD_INT 0
81661: PUSH
81662: LD_INT 0
81664: PUSH
81665: EMPTY
81666: LIST
81667: LIST
81668: PUSH
81669: LD_INT 0
81671: PUSH
81672: LD_INT 1
81674: NEG
81675: PUSH
81676: EMPTY
81677: LIST
81678: LIST
81679: PUSH
81680: LD_INT 1
81682: PUSH
81683: LD_INT 0
81685: PUSH
81686: EMPTY
81687: LIST
81688: LIST
81689: PUSH
81690: LD_INT 1
81692: PUSH
81693: LD_INT 1
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: PUSH
81700: LD_INT 0
81702: PUSH
81703: LD_INT 1
81705: PUSH
81706: EMPTY
81707: LIST
81708: LIST
81709: PUSH
81710: LD_INT 1
81712: NEG
81713: PUSH
81714: LD_INT 0
81716: PUSH
81717: EMPTY
81718: LIST
81719: LIST
81720: PUSH
81721: LD_INT 1
81723: NEG
81724: PUSH
81725: LD_INT 1
81727: NEG
81728: PUSH
81729: EMPTY
81730: LIST
81731: LIST
81732: PUSH
81733: LD_INT 1
81735: NEG
81736: PUSH
81737: LD_INT 2
81739: NEG
81740: PUSH
81741: EMPTY
81742: LIST
81743: LIST
81744: PUSH
81745: LD_INT 0
81747: PUSH
81748: LD_INT 2
81750: NEG
81751: PUSH
81752: EMPTY
81753: LIST
81754: LIST
81755: PUSH
81756: LD_INT 1
81758: PUSH
81759: LD_INT 1
81761: NEG
81762: PUSH
81763: EMPTY
81764: LIST
81765: LIST
81766: PUSH
81767: LD_INT 2
81769: PUSH
81770: LD_INT 0
81772: PUSH
81773: EMPTY
81774: LIST
81775: LIST
81776: PUSH
81777: LD_INT 2
81779: PUSH
81780: LD_INT 1
81782: PUSH
81783: EMPTY
81784: LIST
81785: LIST
81786: PUSH
81787: LD_INT 2
81789: PUSH
81790: LD_INT 2
81792: PUSH
81793: EMPTY
81794: LIST
81795: LIST
81796: PUSH
81797: LD_INT 1
81799: PUSH
81800: LD_INT 2
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PUSH
81807: LD_INT 0
81809: PUSH
81810: LD_INT 2
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: PUSH
81817: LD_INT 1
81819: NEG
81820: PUSH
81821: LD_INT 1
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: PUSH
81828: LD_INT 2
81830: NEG
81831: PUSH
81832: LD_INT 0
81834: PUSH
81835: EMPTY
81836: LIST
81837: LIST
81838: PUSH
81839: LD_INT 2
81841: NEG
81842: PUSH
81843: LD_INT 1
81845: NEG
81846: PUSH
81847: EMPTY
81848: LIST
81849: LIST
81850: PUSH
81851: LD_INT 2
81853: NEG
81854: PUSH
81855: LD_INT 2
81857: NEG
81858: PUSH
81859: EMPTY
81860: LIST
81861: LIST
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: LIST
81867: LIST
81868: LIST
81869: LIST
81870: LIST
81871: LIST
81872: LIST
81873: LIST
81874: LIST
81875: LIST
81876: LIST
81877: LIST
81878: LIST
81879: LIST
81880: LIST
81881: LIST
81882: LIST
81883: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
81884: LD_ADDR_VAR 0 21
81888: PUSH
81889: LD_INT 0
81891: PUSH
81892: LD_INT 0
81894: PUSH
81895: EMPTY
81896: LIST
81897: LIST
81898: PUSH
81899: LD_INT 0
81901: PUSH
81902: LD_INT 1
81904: NEG
81905: PUSH
81906: EMPTY
81907: LIST
81908: LIST
81909: PUSH
81910: LD_INT 1
81912: PUSH
81913: LD_INT 0
81915: PUSH
81916: EMPTY
81917: LIST
81918: LIST
81919: PUSH
81920: LD_INT 1
81922: PUSH
81923: LD_INT 1
81925: PUSH
81926: EMPTY
81927: LIST
81928: LIST
81929: PUSH
81930: LD_INT 0
81932: PUSH
81933: LD_INT 1
81935: PUSH
81936: EMPTY
81937: LIST
81938: LIST
81939: PUSH
81940: LD_INT 1
81942: NEG
81943: PUSH
81944: LD_INT 0
81946: PUSH
81947: EMPTY
81948: LIST
81949: LIST
81950: PUSH
81951: LD_INT 1
81953: NEG
81954: PUSH
81955: LD_INT 1
81957: NEG
81958: PUSH
81959: EMPTY
81960: LIST
81961: LIST
81962: PUSH
81963: LD_INT 1
81965: NEG
81966: PUSH
81967: LD_INT 2
81969: NEG
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: LD_INT 0
81977: PUSH
81978: LD_INT 2
81980: NEG
81981: PUSH
81982: EMPTY
81983: LIST
81984: LIST
81985: PUSH
81986: LD_INT 1
81988: PUSH
81989: LD_INT 1
81991: NEG
81992: PUSH
81993: EMPTY
81994: LIST
81995: LIST
81996: PUSH
81997: LD_INT 2
81999: PUSH
82000: LD_INT 0
82002: PUSH
82003: EMPTY
82004: LIST
82005: LIST
82006: PUSH
82007: LD_INT 2
82009: PUSH
82010: LD_INT 1
82012: PUSH
82013: EMPTY
82014: LIST
82015: LIST
82016: PUSH
82017: LD_INT 2
82019: PUSH
82020: LD_INT 2
82022: PUSH
82023: EMPTY
82024: LIST
82025: LIST
82026: PUSH
82027: LD_INT 1
82029: PUSH
82030: LD_INT 2
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: LD_INT 0
82039: PUSH
82040: LD_INT 2
82042: PUSH
82043: EMPTY
82044: LIST
82045: LIST
82046: PUSH
82047: LD_INT 1
82049: NEG
82050: PUSH
82051: LD_INT 1
82053: PUSH
82054: EMPTY
82055: LIST
82056: LIST
82057: PUSH
82058: LD_INT 2
82060: NEG
82061: PUSH
82062: LD_INT 0
82064: PUSH
82065: EMPTY
82066: LIST
82067: LIST
82068: PUSH
82069: LD_INT 2
82071: NEG
82072: PUSH
82073: LD_INT 1
82075: NEG
82076: PUSH
82077: EMPTY
82078: LIST
82079: LIST
82080: PUSH
82081: LD_INT 2
82083: NEG
82084: PUSH
82085: LD_INT 2
82087: NEG
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PUSH
82093: EMPTY
82094: LIST
82095: LIST
82096: LIST
82097: LIST
82098: LIST
82099: LIST
82100: LIST
82101: LIST
82102: LIST
82103: LIST
82104: LIST
82105: LIST
82106: LIST
82107: LIST
82108: LIST
82109: LIST
82110: LIST
82111: LIST
82112: LIST
82113: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
82114: LD_ADDR_VAR 0 22
82118: PUSH
82119: LD_INT 0
82121: PUSH
82122: LD_INT 0
82124: PUSH
82125: EMPTY
82126: LIST
82127: LIST
82128: PUSH
82129: LD_INT 0
82131: PUSH
82132: LD_INT 1
82134: NEG
82135: PUSH
82136: EMPTY
82137: LIST
82138: LIST
82139: PUSH
82140: LD_INT 1
82142: PUSH
82143: LD_INT 0
82145: PUSH
82146: EMPTY
82147: LIST
82148: LIST
82149: PUSH
82150: LD_INT 1
82152: PUSH
82153: LD_INT 1
82155: PUSH
82156: EMPTY
82157: LIST
82158: LIST
82159: PUSH
82160: LD_INT 0
82162: PUSH
82163: LD_INT 1
82165: PUSH
82166: EMPTY
82167: LIST
82168: LIST
82169: PUSH
82170: LD_INT 1
82172: NEG
82173: PUSH
82174: LD_INT 0
82176: PUSH
82177: EMPTY
82178: LIST
82179: LIST
82180: PUSH
82181: LD_INT 1
82183: NEG
82184: PUSH
82185: LD_INT 1
82187: NEG
82188: PUSH
82189: EMPTY
82190: LIST
82191: LIST
82192: PUSH
82193: LD_INT 1
82195: NEG
82196: PUSH
82197: LD_INT 2
82199: NEG
82200: PUSH
82201: EMPTY
82202: LIST
82203: LIST
82204: PUSH
82205: LD_INT 0
82207: PUSH
82208: LD_INT 2
82210: NEG
82211: PUSH
82212: EMPTY
82213: LIST
82214: LIST
82215: PUSH
82216: LD_INT 1
82218: PUSH
82219: LD_INT 1
82221: NEG
82222: PUSH
82223: EMPTY
82224: LIST
82225: LIST
82226: PUSH
82227: LD_INT 2
82229: PUSH
82230: LD_INT 0
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 2
82239: PUSH
82240: LD_INT 1
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: PUSH
82247: LD_INT 2
82249: PUSH
82250: LD_INT 2
82252: PUSH
82253: EMPTY
82254: LIST
82255: LIST
82256: PUSH
82257: LD_INT 1
82259: PUSH
82260: LD_INT 2
82262: PUSH
82263: EMPTY
82264: LIST
82265: LIST
82266: PUSH
82267: LD_INT 0
82269: PUSH
82270: LD_INT 2
82272: PUSH
82273: EMPTY
82274: LIST
82275: LIST
82276: PUSH
82277: LD_INT 1
82279: NEG
82280: PUSH
82281: LD_INT 1
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: PUSH
82288: LD_INT 2
82290: NEG
82291: PUSH
82292: LD_INT 0
82294: PUSH
82295: EMPTY
82296: LIST
82297: LIST
82298: PUSH
82299: LD_INT 2
82301: NEG
82302: PUSH
82303: LD_INT 1
82305: NEG
82306: PUSH
82307: EMPTY
82308: LIST
82309: LIST
82310: PUSH
82311: LD_INT 2
82313: NEG
82314: PUSH
82315: LD_INT 2
82317: NEG
82318: PUSH
82319: EMPTY
82320: LIST
82321: LIST
82322: PUSH
82323: EMPTY
82324: LIST
82325: LIST
82326: LIST
82327: LIST
82328: LIST
82329: LIST
82330: LIST
82331: LIST
82332: LIST
82333: LIST
82334: LIST
82335: LIST
82336: LIST
82337: LIST
82338: LIST
82339: LIST
82340: LIST
82341: LIST
82342: LIST
82343: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
82344: LD_ADDR_VAR 0 23
82348: PUSH
82349: LD_INT 0
82351: PUSH
82352: LD_INT 0
82354: PUSH
82355: EMPTY
82356: LIST
82357: LIST
82358: PUSH
82359: LD_INT 0
82361: PUSH
82362: LD_INT 1
82364: NEG
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: LD_INT 1
82372: PUSH
82373: LD_INT 0
82375: PUSH
82376: EMPTY
82377: LIST
82378: LIST
82379: PUSH
82380: LD_INT 1
82382: PUSH
82383: LD_INT 1
82385: PUSH
82386: EMPTY
82387: LIST
82388: LIST
82389: PUSH
82390: LD_INT 0
82392: PUSH
82393: LD_INT 1
82395: PUSH
82396: EMPTY
82397: LIST
82398: LIST
82399: PUSH
82400: LD_INT 1
82402: NEG
82403: PUSH
82404: LD_INT 0
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: PUSH
82411: LD_INT 1
82413: NEG
82414: PUSH
82415: LD_INT 1
82417: NEG
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: LD_INT 1
82425: NEG
82426: PUSH
82427: LD_INT 2
82429: NEG
82430: PUSH
82431: EMPTY
82432: LIST
82433: LIST
82434: PUSH
82435: LD_INT 0
82437: PUSH
82438: LD_INT 2
82440: NEG
82441: PUSH
82442: EMPTY
82443: LIST
82444: LIST
82445: PUSH
82446: LD_INT 1
82448: PUSH
82449: LD_INT 1
82451: NEG
82452: PUSH
82453: EMPTY
82454: LIST
82455: LIST
82456: PUSH
82457: LD_INT 2
82459: PUSH
82460: LD_INT 0
82462: PUSH
82463: EMPTY
82464: LIST
82465: LIST
82466: PUSH
82467: LD_INT 2
82469: PUSH
82470: LD_INT 1
82472: PUSH
82473: EMPTY
82474: LIST
82475: LIST
82476: PUSH
82477: LD_INT 2
82479: PUSH
82480: LD_INT 2
82482: PUSH
82483: EMPTY
82484: LIST
82485: LIST
82486: PUSH
82487: LD_INT 1
82489: PUSH
82490: LD_INT 2
82492: PUSH
82493: EMPTY
82494: LIST
82495: LIST
82496: PUSH
82497: LD_INT 0
82499: PUSH
82500: LD_INT 2
82502: PUSH
82503: EMPTY
82504: LIST
82505: LIST
82506: PUSH
82507: LD_INT 1
82509: NEG
82510: PUSH
82511: LD_INT 1
82513: PUSH
82514: EMPTY
82515: LIST
82516: LIST
82517: PUSH
82518: LD_INT 2
82520: NEG
82521: PUSH
82522: LD_INT 0
82524: PUSH
82525: EMPTY
82526: LIST
82527: LIST
82528: PUSH
82529: LD_INT 2
82531: NEG
82532: PUSH
82533: LD_INT 1
82535: NEG
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: PUSH
82541: LD_INT 2
82543: NEG
82544: PUSH
82545: LD_INT 2
82547: NEG
82548: PUSH
82549: EMPTY
82550: LIST
82551: LIST
82552: PUSH
82553: LD_INT 2
82555: NEG
82556: PUSH
82557: LD_INT 3
82559: NEG
82560: PUSH
82561: EMPTY
82562: LIST
82563: LIST
82564: PUSH
82565: LD_INT 1
82567: NEG
82568: PUSH
82569: LD_INT 3
82571: NEG
82572: PUSH
82573: EMPTY
82574: LIST
82575: LIST
82576: PUSH
82577: LD_INT 1
82579: PUSH
82580: LD_INT 2
82582: NEG
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: PUSH
82588: LD_INT 2
82590: PUSH
82591: LD_INT 1
82593: NEG
82594: PUSH
82595: EMPTY
82596: LIST
82597: LIST
82598: PUSH
82599: EMPTY
82600: LIST
82601: LIST
82602: LIST
82603: LIST
82604: LIST
82605: LIST
82606: LIST
82607: LIST
82608: LIST
82609: LIST
82610: LIST
82611: LIST
82612: LIST
82613: LIST
82614: LIST
82615: LIST
82616: LIST
82617: LIST
82618: LIST
82619: LIST
82620: LIST
82621: LIST
82622: LIST
82623: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
82624: LD_ADDR_VAR 0 24
82628: PUSH
82629: LD_INT 0
82631: PUSH
82632: LD_INT 0
82634: PUSH
82635: EMPTY
82636: LIST
82637: LIST
82638: PUSH
82639: LD_INT 0
82641: PUSH
82642: LD_INT 1
82644: NEG
82645: PUSH
82646: EMPTY
82647: LIST
82648: LIST
82649: PUSH
82650: LD_INT 1
82652: PUSH
82653: LD_INT 0
82655: PUSH
82656: EMPTY
82657: LIST
82658: LIST
82659: PUSH
82660: LD_INT 1
82662: PUSH
82663: LD_INT 1
82665: PUSH
82666: EMPTY
82667: LIST
82668: LIST
82669: PUSH
82670: LD_INT 0
82672: PUSH
82673: LD_INT 1
82675: PUSH
82676: EMPTY
82677: LIST
82678: LIST
82679: PUSH
82680: LD_INT 1
82682: NEG
82683: PUSH
82684: LD_INT 0
82686: PUSH
82687: EMPTY
82688: LIST
82689: LIST
82690: PUSH
82691: LD_INT 1
82693: NEG
82694: PUSH
82695: LD_INT 1
82697: NEG
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PUSH
82703: LD_INT 1
82705: NEG
82706: PUSH
82707: LD_INT 2
82709: NEG
82710: PUSH
82711: EMPTY
82712: LIST
82713: LIST
82714: PUSH
82715: LD_INT 0
82717: PUSH
82718: LD_INT 2
82720: NEG
82721: PUSH
82722: EMPTY
82723: LIST
82724: LIST
82725: PUSH
82726: LD_INT 1
82728: PUSH
82729: LD_INT 1
82731: NEG
82732: PUSH
82733: EMPTY
82734: LIST
82735: LIST
82736: PUSH
82737: LD_INT 2
82739: PUSH
82740: LD_INT 0
82742: PUSH
82743: EMPTY
82744: LIST
82745: LIST
82746: PUSH
82747: LD_INT 2
82749: PUSH
82750: LD_INT 1
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: PUSH
82757: LD_INT 2
82759: PUSH
82760: LD_INT 2
82762: PUSH
82763: EMPTY
82764: LIST
82765: LIST
82766: PUSH
82767: LD_INT 1
82769: PUSH
82770: LD_INT 2
82772: PUSH
82773: EMPTY
82774: LIST
82775: LIST
82776: PUSH
82777: LD_INT 0
82779: PUSH
82780: LD_INT 2
82782: PUSH
82783: EMPTY
82784: LIST
82785: LIST
82786: PUSH
82787: LD_INT 1
82789: NEG
82790: PUSH
82791: LD_INT 1
82793: PUSH
82794: EMPTY
82795: LIST
82796: LIST
82797: PUSH
82798: LD_INT 2
82800: NEG
82801: PUSH
82802: LD_INT 0
82804: PUSH
82805: EMPTY
82806: LIST
82807: LIST
82808: PUSH
82809: LD_INT 2
82811: NEG
82812: PUSH
82813: LD_INT 1
82815: NEG
82816: PUSH
82817: EMPTY
82818: LIST
82819: LIST
82820: PUSH
82821: LD_INT 2
82823: NEG
82824: PUSH
82825: LD_INT 2
82827: NEG
82828: PUSH
82829: EMPTY
82830: LIST
82831: LIST
82832: PUSH
82833: LD_INT 1
82835: PUSH
82836: LD_INT 2
82838: NEG
82839: PUSH
82840: EMPTY
82841: LIST
82842: LIST
82843: PUSH
82844: LD_INT 2
82846: PUSH
82847: LD_INT 1
82849: NEG
82850: PUSH
82851: EMPTY
82852: LIST
82853: LIST
82854: PUSH
82855: LD_INT 3
82857: PUSH
82858: LD_INT 1
82860: PUSH
82861: EMPTY
82862: LIST
82863: LIST
82864: PUSH
82865: LD_INT 3
82867: PUSH
82868: LD_INT 2
82870: PUSH
82871: EMPTY
82872: LIST
82873: LIST
82874: PUSH
82875: EMPTY
82876: LIST
82877: LIST
82878: LIST
82879: LIST
82880: LIST
82881: LIST
82882: LIST
82883: LIST
82884: LIST
82885: LIST
82886: LIST
82887: LIST
82888: LIST
82889: LIST
82890: LIST
82891: LIST
82892: LIST
82893: LIST
82894: LIST
82895: LIST
82896: LIST
82897: LIST
82898: LIST
82899: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
82900: LD_ADDR_VAR 0 25
82904: PUSH
82905: LD_INT 0
82907: PUSH
82908: LD_INT 0
82910: PUSH
82911: EMPTY
82912: LIST
82913: LIST
82914: PUSH
82915: LD_INT 0
82917: PUSH
82918: LD_INT 1
82920: NEG
82921: PUSH
82922: EMPTY
82923: LIST
82924: LIST
82925: PUSH
82926: LD_INT 1
82928: PUSH
82929: LD_INT 0
82931: PUSH
82932: EMPTY
82933: LIST
82934: LIST
82935: PUSH
82936: LD_INT 1
82938: PUSH
82939: LD_INT 1
82941: PUSH
82942: EMPTY
82943: LIST
82944: LIST
82945: PUSH
82946: LD_INT 0
82948: PUSH
82949: LD_INT 1
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: LD_INT 1
82958: NEG
82959: PUSH
82960: LD_INT 0
82962: PUSH
82963: EMPTY
82964: LIST
82965: LIST
82966: PUSH
82967: LD_INT 1
82969: NEG
82970: PUSH
82971: LD_INT 1
82973: NEG
82974: PUSH
82975: EMPTY
82976: LIST
82977: LIST
82978: PUSH
82979: LD_INT 1
82981: NEG
82982: PUSH
82983: LD_INT 2
82985: NEG
82986: PUSH
82987: EMPTY
82988: LIST
82989: LIST
82990: PUSH
82991: LD_INT 0
82993: PUSH
82994: LD_INT 2
82996: NEG
82997: PUSH
82998: EMPTY
82999: LIST
83000: LIST
83001: PUSH
83002: LD_INT 1
83004: PUSH
83005: LD_INT 1
83007: NEG
83008: PUSH
83009: EMPTY
83010: LIST
83011: LIST
83012: PUSH
83013: LD_INT 2
83015: PUSH
83016: LD_INT 0
83018: PUSH
83019: EMPTY
83020: LIST
83021: LIST
83022: PUSH
83023: LD_INT 2
83025: PUSH
83026: LD_INT 1
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: PUSH
83033: LD_INT 2
83035: PUSH
83036: LD_INT 2
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: PUSH
83043: LD_INT 1
83045: PUSH
83046: LD_INT 2
83048: PUSH
83049: EMPTY
83050: LIST
83051: LIST
83052: PUSH
83053: LD_INT 0
83055: PUSH
83056: LD_INT 2
83058: PUSH
83059: EMPTY
83060: LIST
83061: LIST
83062: PUSH
83063: LD_INT 1
83065: NEG
83066: PUSH
83067: LD_INT 1
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: LD_INT 2
83076: NEG
83077: PUSH
83078: LD_INT 0
83080: PUSH
83081: EMPTY
83082: LIST
83083: LIST
83084: PUSH
83085: LD_INT 2
83087: NEG
83088: PUSH
83089: LD_INT 1
83091: NEG
83092: PUSH
83093: EMPTY
83094: LIST
83095: LIST
83096: PUSH
83097: LD_INT 2
83099: NEG
83100: PUSH
83101: LD_INT 2
83103: NEG
83104: PUSH
83105: EMPTY
83106: LIST
83107: LIST
83108: PUSH
83109: LD_INT 3
83111: PUSH
83112: LD_INT 1
83114: PUSH
83115: EMPTY
83116: LIST
83117: LIST
83118: PUSH
83119: LD_INT 3
83121: PUSH
83122: LD_INT 2
83124: PUSH
83125: EMPTY
83126: LIST
83127: LIST
83128: PUSH
83129: LD_INT 2
83131: PUSH
83132: LD_INT 3
83134: PUSH
83135: EMPTY
83136: LIST
83137: LIST
83138: PUSH
83139: LD_INT 1
83141: PUSH
83142: LD_INT 3
83144: PUSH
83145: EMPTY
83146: LIST
83147: LIST
83148: PUSH
83149: EMPTY
83150: LIST
83151: LIST
83152: LIST
83153: LIST
83154: LIST
83155: LIST
83156: LIST
83157: LIST
83158: LIST
83159: LIST
83160: LIST
83161: LIST
83162: LIST
83163: LIST
83164: LIST
83165: LIST
83166: LIST
83167: LIST
83168: LIST
83169: LIST
83170: LIST
83171: LIST
83172: LIST
83173: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
83174: LD_ADDR_VAR 0 26
83178: PUSH
83179: LD_INT 0
83181: PUSH
83182: LD_INT 0
83184: PUSH
83185: EMPTY
83186: LIST
83187: LIST
83188: PUSH
83189: LD_INT 0
83191: PUSH
83192: LD_INT 1
83194: NEG
83195: PUSH
83196: EMPTY
83197: LIST
83198: LIST
83199: PUSH
83200: LD_INT 1
83202: PUSH
83203: LD_INT 0
83205: PUSH
83206: EMPTY
83207: LIST
83208: LIST
83209: PUSH
83210: LD_INT 1
83212: PUSH
83213: LD_INT 1
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: PUSH
83220: LD_INT 0
83222: PUSH
83223: LD_INT 1
83225: PUSH
83226: EMPTY
83227: LIST
83228: LIST
83229: PUSH
83230: LD_INT 1
83232: NEG
83233: PUSH
83234: LD_INT 0
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: PUSH
83241: LD_INT 1
83243: NEG
83244: PUSH
83245: LD_INT 1
83247: NEG
83248: PUSH
83249: EMPTY
83250: LIST
83251: LIST
83252: PUSH
83253: LD_INT 1
83255: NEG
83256: PUSH
83257: LD_INT 2
83259: NEG
83260: PUSH
83261: EMPTY
83262: LIST
83263: LIST
83264: PUSH
83265: LD_INT 0
83267: PUSH
83268: LD_INT 2
83270: NEG
83271: PUSH
83272: EMPTY
83273: LIST
83274: LIST
83275: PUSH
83276: LD_INT 1
83278: PUSH
83279: LD_INT 1
83281: NEG
83282: PUSH
83283: EMPTY
83284: LIST
83285: LIST
83286: PUSH
83287: LD_INT 2
83289: PUSH
83290: LD_INT 0
83292: PUSH
83293: EMPTY
83294: LIST
83295: LIST
83296: PUSH
83297: LD_INT 2
83299: PUSH
83300: LD_INT 1
83302: PUSH
83303: EMPTY
83304: LIST
83305: LIST
83306: PUSH
83307: LD_INT 2
83309: PUSH
83310: LD_INT 2
83312: PUSH
83313: EMPTY
83314: LIST
83315: LIST
83316: PUSH
83317: LD_INT 1
83319: PUSH
83320: LD_INT 2
83322: PUSH
83323: EMPTY
83324: LIST
83325: LIST
83326: PUSH
83327: LD_INT 0
83329: PUSH
83330: LD_INT 2
83332: PUSH
83333: EMPTY
83334: LIST
83335: LIST
83336: PUSH
83337: LD_INT 1
83339: NEG
83340: PUSH
83341: LD_INT 1
83343: PUSH
83344: EMPTY
83345: LIST
83346: LIST
83347: PUSH
83348: LD_INT 2
83350: NEG
83351: PUSH
83352: LD_INT 0
83354: PUSH
83355: EMPTY
83356: LIST
83357: LIST
83358: PUSH
83359: LD_INT 2
83361: NEG
83362: PUSH
83363: LD_INT 1
83365: NEG
83366: PUSH
83367: EMPTY
83368: LIST
83369: LIST
83370: PUSH
83371: LD_INT 2
83373: NEG
83374: PUSH
83375: LD_INT 2
83377: NEG
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: PUSH
83383: LD_INT 2
83385: PUSH
83386: LD_INT 3
83388: PUSH
83389: EMPTY
83390: LIST
83391: LIST
83392: PUSH
83393: LD_INT 1
83395: PUSH
83396: LD_INT 3
83398: PUSH
83399: EMPTY
83400: LIST
83401: LIST
83402: PUSH
83403: LD_INT 1
83405: NEG
83406: PUSH
83407: LD_INT 2
83409: PUSH
83410: EMPTY
83411: LIST
83412: LIST
83413: PUSH
83414: LD_INT 2
83416: NEG
83417: PUSH
83418: LD_INT 1
83420: PUSH
83421: EMPTY
83422: LIST
83423: LIST
83424: PUSH
83425: EMPTY
83426: LIST
83427: LIST
83428: LIST
83429: LIST
83430: LIST
83431: LIST
83432: LIST
83433: LIST
83434: LIST
83435: LIST
83436: LIST
83437: LIST
83438: LIST
83439: LIST
83440: LIST
83441: LIST
83442: LIST
83443: LIST
83444: LIST
83445: LIST
83446: LIST
83447: LIST
83448: LIST
83449: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83450: LD_ADDR_VAR 0 27
83454: PUSH
83455: LD_INT 0
83457: PUSH
83458: LD_INT 0
83460: PUSH
83461: EMPTY
83462: LIST
83463: LIST
83464: PUSH
83465: LD_INT 0
83467: PUSH
83468: LD_INT 1
83470: NEG
83471: PUSH
83472: EMPTY
83473: LIST
83474: LIST
83475: PUSH
83476: LD_INT 1
83478: PUSH
83479: LD_INT 0
83481: PUSH
83482: EMPTY
83483: LIST
83484: LIST
83485: PUSH
83486: LD_INT 1
83488: PUSH
83489: LD_INT 1
83491: PUSH
83492: EMPTY
83493: LIST
83494: LIST
83495: PUSH
83496: LD_INT 0
83498: PUSH
83499: LD_INT 1
83501: PUSH
83502: EMPTY
83503: LIST
83504: LIST
83505: PUSH
83506: LD_INT 1
83508: NEG
83509: PUSH
83510: LD_INT 0
83512: PUSH
83513: EMPTY
83514: LIST
83515: LIST
83516: PUSH
83517: LD_INT 1
83519: NEG
83520: PUSH
83521: LD_INT 1
83523: NEG
83524: PUSH
83525: EMPTY
83526: LIST
83527: LIST
83528: PUSH
83529: LD_INT 1
83531: NEG
83532: PUSH
83533: LD_INT 2
83535: NEG
83536: PUSH
83537: EMPTY
83538: LIST
83539: LIST
83540: PUSH
83541: LD_INT 0
83543: PUSH
83544: LD_INT 2
83546: NEG
83547: PUSH
83548: EMPTY
83549: LIST
83550: LIST
83551: PUSH
83552: LD_INT 1
83554: PUSH
83555: LD_INT 1
83557: NEG
83558: PUSH
83559: EMPTY
83560: LIST
83561: LIST
83562: PUSH
83563: LD_INT 2
83565: PUSH
83566: LD_INT 0
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: PUSH
83573: LD_INT 2
83575: PUSH
83576: LD_INT 1
83578: PUSH
83579: EMPTY
83580: LIST
83581: LIST
83582: PUSH
83583: LD_INT 2
83585: PUSH
83586: LD_INT 2
83588: PUSH
83589: EMPTY
83590: LIST
83591: LIST
83592: PUSH
83593: LD_INT 1
83595: PUSH
83596: LD_INT 2
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: PUSH
83603: LD_INT 0
83605: PUSH
83606: LD_INT 2
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: PUSH
83613: LD_INT 1
83615: NEG
83616: PUSH
83617: LD_INT 1
83619: PUSH
83620: EMPTY
83621: LIST
83622: LIST
83623: PUSH
83624: LD_INT 2
83626: NEG
83627: PUSH
83628: LD_INT 0
83630: PUSH
83631: EMPTY
83632: LIST
83633: LIST
83634: PUSH
83635: LD_INT 2
83637: NEG
83638: PUSH
83639: LD_INT 1
83641: NEG
83642: PUSH
83643: EMPTY
83644: LIST
83645: LIST
83646: PUSH
83647: LD_INT 2
83649: NEG
83650: PUSH
83651: LD_INT 2
83653: NEG
83654: PUSH
83655: EMPTY
83656: LIST
83657: LIST
83658: PUSH
83659: LD_INT 1
83661: NEG
83662: PUSH
83663: LD_INT 2
83665: PUSH
83666: EMPTY
83667: LIST
83668: LIST
83669: PUSH
83670: LD_INT 2
83672: NEG
83673: PUSH
83674: LD_INT 1
83676: PUSH
83677: EMPTY
83678: LIST
83679: LIST
83680: PUSH
83681: LD_INT 3
83683: NEG
83684: PUSH
83685: LD_INT 1
83687: NEG
83688: PUSH
83689: EMPTY
83690: LIST
83691: LIST
83692: PUSH
83693: LD_INT 3
83695: NEG
83696: PUSH
83697: LD_INT 2
83699: NEG
83700: PUSH
83701: EMPTY
83702: LIST
83703: LIST
83704: PUSH
83705: EMPTY
83706: LIST
83707: LIST
83708: LIST
83709: LIST
83710: LIST
83711: LIST
83712: LIST
83713: LIST
83714: LIST
83715: LIST
83716: LIST
83717: LIST
83718: LIST
83719: LIST
83720: LIST
83721: LIST
83722: LIST
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: LIST
83729: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
83730: LD_ADDR_VAR 0 28
83734: PUSH
83735: LD_INT 0
83737: PUSH
83738: LD_INT 0
83740: PUSH
83741: EMPTY
83742: LIST
83743: LIST
83744: PUSH
83745: LD_INT 0
83747: PUSH
83748: LD_INT 1
83750: NEG
83751: PUSH
83752: EMPTY
83753: LIST
83754: LIST
83755: PUSH
83756: LD_INT 1
83758: PUSH
83759: LD_INT 0
83761: PUSH
83762: EMPTY
83763: LIST
83764: LIST
83765: PUSH
83766: LD_INT 1
83768: PUSH
83769: LD_INT 1
83771: PUSH
83772: EMPTY
83773: LIST
83774: LIST
83775: PUSH
83776: LD_INT 0
83778: PUSH
83779: LD_INT 1
83781: PUSH
83782: EMPTY
83783: LIST
83784: LIST
83785: PUSH
83786: LD_INT 1
83788: NEG
83789: PUSH
83790: LD_INT 0
83792: PUSH
83793: EMPTY
83794: LIST
83795: LIST
83796: PUSH
83797: LD_INT 1
83799: NEG
83800: PUSH
83801: LD_INT 1
83803: NEG
83804: PUSH
83805: EMPTY
83806: LIST
83807: LIST
83808: PUSH
83809: LD_INT 1
83811: NEG
83812: PUSH
83813: LD_INT 2
83815: NEG
83816: PUSH
83817: EMPTY
83818: LIST
83819: LIST
83820: PUSH
83821: LD_INT 0
83823: PUSH
83824: LD_INT 2
83826: NEG
83827: PUSH
83828: EMPTY
83829: LIST
83830: LIST
83831: PUSH
83832: LD_INT 1
83834: PUSH
83835: LD_INT 1
83837: NEG
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: PUSH
83843: LD_INT 2
83845: PUSH
83846: LD_INT 0
83848: PUSH
83849: EMPTY
83850: LIST
83851: LIST
83852: PUSH
83853: LD_INT 2
83855: PUSH
83856: LD_INT 1
83858: PUSH
83859: EMPTY
83860: LIST
83861: LIST
83862: PUSH
83863: LD_INT 2
83865: PUSH
83866: LD_INT 2
83868: PUSH
83869: EMPTY
83870: LIST
83871: LIST
83872: PUSH
83873: LD_INT 1
83875: PUSH
83876: LD_INT 2
83878: PUSH
83879: EMPTY
83880: LIST
83881: LIST
83882: PUSH
83883: LD_INT 0
83885: PUSH
83886: LD_INT 2
83888: PUSH
83889: EMPTY
83890: LIST
83891: LIST
83892: PUSH
83893: LD_INT 1
83895: NEG
83896: PUSH
83897: LD_INT 1
83899: PUSH
83900: EMPTY
83901: LIST
83902: LIST
83903: PUSH
83904: LD_INT 2
83906: NEG
83907: PUSH
83908: LD_INT 0
83910: PUSH
83911: EMPTY
83912: LIST
83913: LIST
83914: PUSH
83915: LD_INT 2
83917: NEG
83918: PUSH
83919: LD_INT 1
83921: NEG
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: PUSH
83927: LD_INT 2
83929: NEG
83930: PUSH
83931: LD_INT 2
83933: NEG
83934: PUSH
83935: EMPTY
83936: LIST
83937: LIST
83938: PUSH
83939: LD_INT 2
83941: NEG
83942: PUSH
83943: LD_INT 3
83945: NEG
83946: PUSH
83947: EMPTY
83948: LIST
83949: LIST
83950: PUSH
83951: LD_INT 1
83953: NEG
83954: PUSH
83955: LD_INT 3
83957: NEG
83958: PUSH
83959: EMPTY
83960: LIST
83961: LIST
83962: PUSH
83963: LD_INT 3
83965: NEG
83966: PUSH
83967: LD_INT 1
83969: NEG
83970: PUSH
83971: EMPTY
83972: LIST
83973: LIST
83974: PUSH
83975: LD_INT 3
83977: NEG
83978: PUSH
83979: LD_INT 2
83981: NEG
83982: PUSH
83983: EMPTY
83984: LIST
83985: LIST
83986: PUSH
83987: EMPTY
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: LIST
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: LIST
84003: LIST
84004: LIST
84005: LIST
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84012: LD_ADDR_VAR 0 29
84016: PUSH
84017: LD_INT 0
84019: PUSH
84020: LD_INT 0
84022: PUSH
84023: EMPTY
84024: LIST
84025: LIST
84026: PUSH
84027: LD_INT 0
84029: PUSH
84030: LD_INT 1
84032: NEG
84033: PUSH
84034: EMPTY
84035: LIST
84036: LIST
84037: PUSH
84038: LD_INT 1
84040: PUSH
84041: LD_INT 0
84043: PUSH
84044: EMPTY
84045: LIST
84046: LIST
84047: PUSH
84048: LD_INT 1
84050: PUSH
84051: LD_INT 1
84053: PUSH
84054: EMPTY
84055: LIST
84056: LIST
84057: PUSH
84058: LD_INT 0
84060: PUSH
84061: LD_INT 1
84063: PUSH
84064: EMPTY
84065: LIST
84066: LIST
84067: PUSH
84068: LD_INT 1
84070: NEG
84071: PUSH
84072: LD_INT 0
84074: PUSH
84075: EMPTY
84076: LIST
84077: LIST
84078: PUSH
84079: LD_INT 1
84081: NEG
84082: PUSH
84083: LD_INT 1
84085: NEG
84086: PUSH
84087: EMPTY
84088: LIST
84089: LIST
84090: PUSH
84091: LD_INT 1
84093: NEG
84094: PUSH
84095: LD_INT 2
84097: NEG
84098: PUSH
84099: EMPTY
84100: LIST
84101: LIST
84102: PUSH
84103: LD_INT 0
84105: PUSH
84106: LD_INT 2
84108: NEG
84109: PUSH
84110: EMPTY
84111: LIST
84112: LIST
84113: PUSH
84114: LD_INT 1
84116: PUSH
84117: LD_INT 1
84119: NEG
84120: PUSH
84121: EMPTY
84122: LIST
84123: LIST
84124: PUSH
84125: LD_INT 2
84127: PUSH
84128: LD_INT 0
84130: PUSH
84131: EMPTY
84132: LIST
84133: LIST
84134: PUSH
84135: LD_INT 2
84137: PUSH
84138: LD_INT 1
84140: PUSH
84141: EMPTY
84142: LIST
84143: LIST
84144: PUSH
84145: LD_INT 1
84147: PUSH
84148: LD_INT 2
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: PUSH
84155: LD_INT 0
84157: PUSH
84158: LD_INT 2
84160: PUSH
84161: EMPTY
84162: LIST
84163: LIST
84164: PUSH
84165: LD_INT 1
84167: NEG
84168: PUSH
84169: LD_INT 1
84171: PUSH
84172: EMPTY
84173: LIST
84174: LIST
84175: PUSH
84176: LD_INT 2
84178: NEG
84179: PUSH
84180: LD_INT 1
84182: NEG
84183: PUSH
84184: EMPTY
84185: LIST
84186: LIST
84187: PUSH
84188: LD_INT 2
84190: NEG
84191: PUSH
84192: LD_INT 2
84194: NEG
84195: PUSH
84196: EMPTY
84197: LIST
84198: LIST
84199: PUSH
84200: LD_INT 2
84202: NEG
84203: PUSH
84204: LD_INT 3
84206: NEG
84207: PUSH
84208: EMPTY
84209: LIST
84210: LIST
84211: PUSH
84212: LD_INT 2
84214: PUSH
84215: LD_INT 1
84217: NEG
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PUSH
84223: LD_INT 3
84225: PUSH
84226: LD_INT 1
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: PUSH
84233: LD_INT 1
84235: PUSH
84236: LD_INT 3
84238: PUSH
84239: EMPTY
84240: LIST
84241: LIST
84242: PUSH
84243: LD_INT 1
84245: NEG
84246: PUSH
84247: LD_INT 2
84249: PUSH
84250: EMPTY
84251: LIST
84252: LIST
84253: PUSH
84254: LD_INT 3
84256: NEG
84257: PUSH
84258: LD_INT 2
84260: NEG
84261: PUSH
84262: EMPTY
84263: LIST
84264: LIST
84265: PUSH
84266: EMPTY
84267: LIST
84268: LIST
84269: LIST
84270: LIST
84271: LIST
84272: LIST
84273: LIST
84274: LIST
84275: LIST
84276: LIST
84277: LIST
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84291: LD_ADDR_VAR 0 30
84295: PUSH
84296: LD_INT 0
84298: PUSH
84299: LD_INT 0
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: PUSH
84306: LD_INT 0
84308: PUSH
84309: LD_INT 1
84311: NEG
84312: PUSH
84313: EMPTY
84314: LIST
84315: LIST
84316: PUSH
84317: LD_INT 1
84319: PUSH
84320: LD_INT 0
84322: PUSH
84323: EMPTY
84324: LIST
84325: LIST
84326: PUSH
84327: LD_INT 1
84329: PUSH
84330: LD_INT 1
84332: PUSH
84333: EMPTY
84334: LIST
84335: LIST
84336: PUSH
84337: LD_INT 0
84339: PUSH
84340: LD_INT 1
84342: PUSH
84343: EMPTY
84344: LIST
84345: LIST
84346: PUSH
84347: LD_INT 1
84349: NEG
84350: PUSH
84351: LD_INT 0
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: PUSH
84358: LD_INT 1
84360: NEG
84361: PUSH
84362: LD_INT 1
84364: NEG
84365: PUSH
84366: EMPTY
84367: LIST
84368: LIST
84369: PUSH
84370: LD_INT 1
84372: NEG
84373: PUSH
84374: LD_INT 2
84376: NEG
84377: PUSH
84378: EMPTY
84379: LIST
84380: LIST
84381: PUSH
84382: LD_INT 0
84384: PUSH
84385: LD_INT 2
84387: NEG
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PUSH
84393: LD_INT 1
84395: PUSH
84396: LD_INT 1
84398: NEG
84399: PUSH
84400: EMPTY
84401: LIST
84402: LIST
84403: PUSH
84404: LD_INT 2
84406: PUSH
84407: LD_INT 0
84409: PUSH
84410: EMPTY
84411: LIST
84412: LIST
84413: PUSH
84414: LD_INT 2
84416: PUSH
84417: LD_INT 1
84419: PUSH
84420: EMPTY
84421: LIST
84422: LIST
84423: PUSH
84424: LD_INT 2
84426: PUSH
84427: LD_INT 2
84429: PUSH
84430: EMPTY
84431: LIST
84432: LIST
84433: PUSH
84434: LD_INT 1
84436: PUSH
84437: LD_INT 2
84439: PUSH
84440: EMPTY
84441: LIST
84442: LIST
84443: PUSH
84444: LD_INT 1
84446: NEG
84447: PUSH
84448: LD_INT 1
84450: PUSH
84451: EMPTY
84452: LIST
84453: LIST
84454: PUSH
84455: LD_INT 2
84457: NEG
84458: PUSH
84459: LD_INT 0
84461: PUSH
84462: EMPTY
84463: LIST
84464: LIST
84465: PUSH
84466: LD_INT 2
84468: NEG
84469: PUSH
84470: LD_INT 1
84472: NEG
84473: PUSH
84474: EMPTY
84475: LIST
84476: LIST
84477: PUSH
84478: LD_INT 1
84480: NEG
84481: PUSH
84482: LD_INT 3
84484: NEG
84485: PUSH
84486: EMPTY
84487: LIST
84488: LIST
84489: PUSH
84490: LD_INT 1
84492: PUSH
84493: LD_INT 2
84495: NEG
84496: PUSH
84497: EMPTY
84498: LIST
84499: LIST
84500: PUSH
84501: LD_INT 3
84503: PUSH
84504: LD_INT 2
84506: PUSH
84507: EMPTY
84508: LIST
84509: LIST
84510: PUSH
84511: LD_INT 2
84513: PUSH
84514: LD_INT 3
84516: PUSH
84517: EMPTY
84518: LIST
84519: LIST
84520: PUSH
84521: LD_INT 2
84523: NEG
84524: PUSH
84525: LD_INT 1
84527: PUSH
84528: EMPTY
84529: LIST
84530: LIST
84531: PUSH
84532: LD_INT 3
84534: NEG
84535: PUSH
84536: LD_INT 1
84538: NEG
84539: PUSH
84540: EMPTY
84541: LIST
84542: LIST
84543: PUSH
84544: EMPTY
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: LIST
84553: LIST
84554: LIST
84555: LIST
84556: LIST
84557: LIST
84558: LIST
84559: LIST
84560: LIST
84561: LIST
84562: LIST
84563: LIST
84564: LIST
84565: LIST
84566: LIST
84567: LIST
84568: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
84569: LD_ADDR_VAR 0 31
84573: PUSH
84574: LD_INT 0
84576: PUSH
84577: LD_INT 0
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: PUSH
84584: LD_INT 0
84586: PUSH
84587: LD_INT 1
84589: NEG
84590: PUSH
84591: EMPTY
84592: LIST
84593: LIST
84594: PUSH
84595: LD_INT 1
84597: PUSH
84598: LD_INT 0
84600: PUSH
84601: EMPTY
84602: LIST
84603: LIST
84604: PUSH
84605: LD_INT 1
84607: PUSH
84608: LD_INT 1
84610: PUSH
84611: EMPTY
84612: LIST
84613: LIST
84614: PUSH
84615: LD_INT 0
84617: PUSH
84618: LD_INT 1
84620: PUSH
84621: EMPTY
84622: LIST
84623: LIST
84624: PUSH
84625: LD_INT 1
84627: NEG
84628: PUSH
84629: LD_INT 0
84631: PUSH
84632: EMPTY
84633: LIST
84634: LIST
84635: PUSH
84636: LD_INT 1
84638: NEG
84639: PUSH
84640: LD_INT 1
84642: NEG
84643: PUSH
84644: EMPTY
84645: LIST
84646: LIST
84647: PUSH
84648: LD_INT 1
84650: NEG
84651: PUSH
84652: LD_INT 2
84654: NEG
84655: PUSH
84656: EMPTY
84657: LIST
84658: LIST
84659: PUSH
84660: LD_INT 1
84662: PUSH
84663: LD_INT 1
84665: NEG
84666: PUSH
84667: EMPTY
84668: LIST
84669: LIST
84670: PUSH
84671: LD_INT 2
84673: PUSH
84674: LD_INT 0
84676: PUSH
84677: EMPTY
84678: LIST
84679: LIST
84680: PUSH
84681: LD_INT 2
84683: PUSH
84684: LD_INT 1
84686: PUSH
84687: EMPTY
84688: LIST
84689: LIST
84690: PUSH
84691: LD_INT 2
84693: PUSH
84694: LD_INT 2
84696: PUSH
84697: EMPTY
84698: LIST
84699: LIST
84700: PUSH
84701: LD_INT 1
84703: PUSH
84704: LD_INT 2
84706: PUSH
84707: EMPTY
84708: LIST
84709: LIST
84710: PUSH
84711: LD_INT 0
84713: PUSH
84714: LD_INT 2
84716: PUSH
84717: EMPTY
84718: LIST
84719: LIST
84720: PUSH
84721: LD_INT 1
84723: NEG
84724: PUSH
84725: LD_INT 1
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: PUSH
84732: LD_INT 2
84734: NEG
84735: PUSH
84736: LD_INT 1
84738: NEG
84739: PUSH
84740: EMPTY
84741: LIST
84742: LIST
84743: PUSH
84744: LD_INT 2
84746: NEG
84747: PUSH
84748: LD_INT 2
84750: NEG
84751: PUSH
84752: EMPTY
84753: LIST
84754: LIST
84755: PUSH
84756: LD_INT 2
84758: NEG
84759: PUSH
84760: LD_INT 3
84762: NEG
84763: PUSH
84764: EMPTY
84765: LIST
84766: LIST
84767: PUSH
84768: LD_INT 2
84770: PUSH
84771: LD_INT 1
84773: NEG
84774: PUSH
84775: EMPTY
84776: LIST
84777: LIST
84778: PUSH
84779: LD_INT 3
84781: PUSH
84782: LD_INT 1
84784: PUSH
84785: EMPTY
84786: LIST
84787: LIST
84788: PUSH
84789: LD_INT 1
84791: PUSH
84792: LD_INT 3
84794: PUSH
84795: EMPTY
84796: LIST
84797: LIST
84798: PUSH
84799: LD_INT 1
84801: NEG
84802: PUSH
84803: LD_INT 2
84805: PUSH
84806: EMPTY
84807: LIST
84808: LIST
84809: PUSH
84810: LD_INT 3
84812: NEG
84813: PUSH
84814: LD_INT 2
84816: NEG
84817: PUSH
84818: EMPTY
84819: LIST
84820: LIST
84821: PUSH
84822: EMPTY
84823: LIST
84824: LIST
84825: LIST
84826: LIST
84827: LIST
84828: LIST
84829: LIST
84830: LIST
84831: LIST
84832: LIST
84833: LIST
84834: LIST
84835: LIST
84836: LIST
84837: LIST
84838: LIST
84839: LIST
84840: LIST
84841: LIST
84842: LIST
84843: LIST
84844: LIST
84845: LIST
84846: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
84847: LD_ADDR_VAR 0 32
84851: PUSH
84852: LD_INT 0
84854: PUSH
84855: LD_INT 0
84857: PUSH
84858: EMPTY
84859: LIST
84860: LIST
84861: PUSH
84862: LD_INT 0
84864: PUSH
84865: LD_INT 1
84867: NEG
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: PUSH
84873: LD_INT 1
84875: PUSH
84876: LD_INT 0
84878: PUSH
84879: EMPTY
84880: LIST
84881: LIST
84882: PUSH
84883: LD_INT 1
84885: PUSH
84886: LD_INT 1
84888: PUSH
84889: EMPTY
84890: LIST
84891: LIST
84892: PUSH
84893: LD_INT 0
84895: PUSH
84896: LD_INT 1
84898: PUSH
84899: EMPTY
84900: LIST
84901: LIST
84902: PUSH
84903: LD_INT 1
84905: NEG
84906: PUSH
84907: LD_INT 0
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: PUSH
84914: LD_INT 1
84916: NEG
84917: PUSH
84918: LD_INT 1
84920: NEG
84921: PUSH
84922: EMPTY
84923: LIST
84924: LIST
84925: PUSH
84926: LD_INT 1
84928: NEG
84929: PUSH
84930: LD_INT 2
84932: NEG
84933: PUSH
84934: EMPTY
84935: LIST
84936: LIST
84937: PUSH
84938: LD_INT 0
84940: PUSH
84941: LD_INT 2
84943: NEG
84944: PUSH
84945: EMPTY
84946: LIST
84947: LIST
84948: PUSH
84949: LD_INT 1
84951: PUSH
84952: LD_INT 1
84954: NEG
84955: PUSH
84956: EMPTY
84957: LIST
84958: LIST
84959: PUSH
84960: LD_INT 2
84962: PUSH
84963: LD_INT 1
84965: PUSH
84966: EMPTY
84967: LIST
84968: LIST
84969: PUSH
84970: LD_INT 2
84972: PUSH
84973: LD_INT 2
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: PUSH
84980: LD_INT 1
84982: PUSH
84983: LD_INT 2
84985: PUSH
84986: EMPTY
84987: LIST
84988: LIST
84989: PUSH
84990: LD_INT 0
84992: PUSH
84993: LD_INT 2
84995: PUSH
84996: EMPTY
84997: LIST
84998: LIST
84999: PUSH
85000: LD_INT 1
85002: NEG
85003: PUSH
85004: LD_INT 1
85006: PUSH
85007: EMPTY
85008: LIST
85009: LIST
85010: PUSH
85011: LD_INT 2
85013: NEG
85014: PUSH
85015: LD_INT 0
85017: PUSH
85018: EMPTY
85019: LIST
85020: LIST
85021: PUSH
85022: LD_INT 2
85024: NEG
85025: PUSH
85026: LD_INT 1
85028: NEG
85029: PUSH
85030: EMPTY
85031: LIST
85032: LIST
85033: PUSH
85034: LD_INT 1
85036: NEG
85037: PUSH
85038: LD_INT 3
85040: NEG
85041: PUSH
85042: EMPTY
85043: LIST
85044: LIST
85045: PUSH
85046: LD_INT 1
85048: PUSH
85049: LD_INT 2
85051: NEG
85052: PUSH
85053: EMPTY
85054: LIST
85055: LIST
85056: PUSH
85057: LD_INT 3
85059: PUSH
85060: LD_INT 2
85062: PUSH
85063: EMPTY
85064: LIST
85065: LIST
85066: PUSH
85067: LD_INT 2
85069: PUSH
85070: LD_INT 3
85072: PUSH
85073: EMPTY
85074: LIST
85075: LIST
85076: PUSH
85077: LD_INT 2
85079: NEG
85080: PUSH
85081: LD_INT 1
85083: PUSH
85084: EMPTY
85085: LIST
85086: LIST
85087: PUSH
85088: LD_INT 3
85090: NEG
85091: PUSH
85092: LD_INT 1
85094: NEG
85095: PUSH
85096: EMPTY
85097: LIST
85098: LIST
85099: PUSH
85100: EMPTY
85101: LIST
85102: LIST
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
85125: LD_ADDR_VAR 0 33
85129: PUSH
85130: LD_INT 0
85132: PUSH
85133: LD_INT 0
85135: PUSH
85136: EMPTY
85137: LIST
85138: LIST
85139: PUSH
85140: LD_INT 0
85142: PUSH
85143: LD_INT 1
85145: NEG
85146: PUSH
85147: EMPTY
85148: LIST
85149: LIST
85150: PUSH
85151: LD_INT 1
85153: PUSH
85154: LD_INT 0
85156: PUSH
85157: EMPTY
85158: LIST
85159: LIST
85160: PUSH
85161: LD_INT 1
85163: PUSH
85164: LD_INT 1
85166: PUSH
85167: EMPTY
85168: LIST
85169: LIST
85170: PUSH
85171: LD_INT 0
85173: PUSH
85174: LD_INT 1
85176: PUSH
85177: EMPTY
85178: LIST
85179: LIST
85180: PUSH
85181: LD_INT 1
85183: NEG
85184: PUSH
85185: LD_INT 0
85187: PUSH
85188: EMPTY
85189: LIST
85190: LIST
85191: PUSH
85192: LD_INT 1
85194: NEG
85195: PUSH
85196: LD_INT 1
85198: NEG
85199: PUSH
85200: EMPTY
85201: LIST
85202: LIST
85203: PUSH
85204: LD_INT 1
85206: NEG
85207: PUSH
85208: LD_INT 2
85210: NEG
85211: PUSH
85212: EMPTY
85213: LIST
85214: LIST
85215: PUSH
85216: LD_INT 1
85218: PUSH
85219: LD_INT 1
85221: NEG
85222: PUSH
85223: EMPTY
85224: LIST
85225: LIST
85226: PUSH
85227: LD_INT 2
85229: PUSH
85230: LD_INT 0
85232: PUSH
85233: EMPTY
85234: LIST
85235: LIST
85236: PUSH
85237: LD_INT 2
85239: PUSH
85240: LD_INT 1
85242: PUSH
85243: EMPTY
85244: LIST
85245: LIST
85246: PUSH
85247: LD_INT 1
85249: PUSH
85250: LD_INT 2
85252: PUSH
85253: EMPTY
85254: LIST
85255: LIST
85256: PUSH
85257: LD_INT 0
85259: PUSH
85260: LD_INT 2
85262: PUSH
85263: EMPTY
85264: LIST
85265: LIST
85266: PUSH
85267: LD_INT 1
85269: NEG
85270: PUSH
85271: LD_INT 1
85273: PUSH
85274: EMPTY
85275: LIST
85276: LIST
85277: PUSH
85278: LD_INT 2
85280: NEG
85281: PUSH
85282: LD_INT 0
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: PUSH
85289: LD_INT 2
85291: NEG
85292: PUSH
85293: LD_INT 1
85295: NEG
85296: PUSH
85297: EMPTY
85298: LIST
85299: LIST
85300: PUSH
85301: LD_INT 2
85303: NEG
85304: PUSH
85305: LD_INT 2
85307: NEG
85308: PUSH
85309: EMPTY
85310: LIST
85311: LIST
85312: PUSH
85313: LD_INT 2
85315: NEG
85316: PUSH
85317: LD_INT 3
85319: NEG
85320: PUSH
85321: EMPTY
85322: LIST
85323: LIST
85324: PUSH
85325: LD_INT 2
85327: PUSH
85328: LD_INT 1
85330: NEG
85331: PUSH
85332: EMPTY
85333: LIST
85334: LIST
85335: PUSH
85336: LD_INT 3
85338: PUSH
85339: LD_INT 1
85341: PUSH
85342: EMPTY
85343: LIST
85344: LIST
85345: PUSH
85346: LD_INT 1
85348: PUSH
85349: LD_INT 3
85351: PUSH
85352: EMPTY
85353: LIST
85354: LIST
85355: PUSH
85356: LD_INT 1
85358: NEG
85359: PUSH
85360: LD_INT 2
85362: PUSH
85363: EMPTY
85364: LIST
85365: LIST
85366: PUSH
85367: LD_INT 3
85369: NEG
85370: PUSH
85371: LD_INT 2
85373: NEG
85374: PUSH
85375: EMPTY
85376: LIST
85377: LIST
85378: PUSH
85379: EMPTY
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: LIST
85386: LIST
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: LIST
85392: LIST
85393: LIST
85394: LIST
85395: LIST
85396: LIST
85397: LIST
85398: LIST
85399: LIST
85400: LIST
85401: LIST
85402: LIST
85403: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
85404: LD_ADDR_VAR 0 34
85408: PUSH
85409: LD_INT 0
85411: PUSH
85412: LD_INT 0
85414: PUSH
85415: EMPTY
85416: LIST
85417: LIST
85418: PUSH
85419: LD_INT 0
85421: PUSH
85422: LD_INT 1
85424: NEG
85425: PUSH
85426: EMPTY
85427: LIST
85428: LIST
85429: PUSH
85430: LD_INT 1
85432: PUSH
85433: LD_INT 0
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PUSH
85440: LD_INT 1
85442: PUSH
85443: LD_INT 1
85445: PUSH
85446: EMPTY
85447: LIST
85448: LIST
85449: PUSH
85450: LD_INT 0
85452: PUSH
85453: LD_INT 1
85455: PUSH
85456: EMPTY
85457: LIST
85458: LIST
85459: PUSH
85460: LD_INT 1
85462: NEG
85463: PUSH
85464: LD_INT 0
85466: PUSH
85467: EMPTY
85468: LIST
85469: LIST
85470: PUSH
85471: LD_INT 1
85473: NEG
85474: PUSH
85475: LD_INT 1
85477: NEG
85478: PUSH
85479: EMPTY
85480: LIST
85481: LIST
85482: PUSH
85483: LD_INT 1
85485: NEG
85486: PUSH
85487: LD_INT 2
85489: NEG
85490: PUSH
85491: EMPTY
85492: LIST
85493: LIST
85494: PUSH
85495: LD_INT 0
85497: PUSH
85498: LD_INT 2
85500: NEG
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: PUSH
85506: LD_INT 1
85508: PUSH
85509: LD_INT 1
85511: NEG
85512: PUSH
85513: EMPTY
85514: LIST
85515: LIST
85516: PUSH
85517: LD_INT 2
85519: PUSH
85520: LD_INT 1
85522: PUSH
85523: EMPTY
85524: LIST
85525: LIST
85526: PUSH
85527: LD_INT 2
85529: PUSH
85530: LD_INT 2
85532: PUSH
85533: EMPTY
85534: LIST
85535: LIST
85536: PUSH
85537: LD_INT 1
85539: PUSH
85540: LD_INT 2
85542: PUSH
85543: EMPTY
85544: LIST
85545: LIST
85546: PUSH
85547: LD_INT 1
85549: NEG
85550: PUSH
85551: LD_INT 1
85553: PUSH
85554: EMPTY
85555: LIST
85556: LIST
85557: PUSH
85558: LD_INT 2
85560: NEG
85561: PUSH
85562: LD_INT 0
85564: PUSH
85565: EMPTY
85566: LIST
85567: LIST
85568: PUSH
85569: LD_INT 2
85571: NEG
85572: PUSH
85573: LD_INT 1
85575: NEG
85576: PUSH
85577: EMPTY
85578: LIST
85579: LIST
85580: PUSH
85581: LD_INT 2
85583: NEG
85584: PUSH
85585: LD_INT 2
85587: NEG
85588: PUSH
85589: EMPTY
85590: LIST
85591: LIST
85592: PUSH
85593: LD_INT 1
85595: NEG
85596: PUSH
85597: LD_INT 3
85599: NEG
85600: PUSH
85601: EMPTY
85602: LIST
85603: LIST
85604: PUSH
85605: LD_INT 1
85607: PUSH
85608: LD_INT 2
85610: NEG
85611: PUSH
85612: EMPTY
85613: LIST
85614: LIST
85615: PUSH
85616: LD_INT 3
85618: PUSH
85619: LD_INT 2
85621: PUSH
85622: EMPTY
85623: LIST
85624: LIST
85625: PUSH
85626: LD_INT 2
85628: PUSH
85629: LD_INT 3
85631: PUSH
85632: EMPTY
85633: LIST
85634: LIST
85635: PUSH
85636: LD_INT 2
85638: NEG
85639: PUSH
85640: LD_INT 1
85642: PUSH
85643: EMPTY
85644: LIST
85645: LIST
85646: PUSH
85647: LD_INT 3
85649: NEG
85650: PUSH
85651: LD_INT 1
85653: NEG
85654: PUSH
85655: EMPTY
85656: LIST
85657: LIST
85658: PUSH
85659: EMPTY
85660: LIST
85661: LIST
85662: LIST
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: LIST
85674: LIST
85675: LIST
85676: LIST
85677: LIST
85678: LIST
85679: LIST
85680: LIST
85681: LIST
85682: LIST
85683: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
85684: LD_ADDR_VAR 0 35
85688: PUSH
85689: LD_INT 0
85691: PUSH
85692: LD_INT 0
85694: PUSH
85695: EMPTY
85696: LIST
85697: LIST
85698: PUSH
85699: LD_INT 0
85701: PUSH
85702: LD_INT 1
85704: NEG
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: LD_INT 1
85712: PUSH
85713: LD_INT 0
85715: PUSH
85716: EMPTY
85717: LIST
85718: LIST
85719: PUSH
85720: LD_INT 1
85722: PUSH
85723: LD_INT 1
85725: PUSH
85726: EMPTY
85727: LIST
85728: LIST
85729: PUSH
85730: LD_INT 0
85732: PUSH
85733: LD_INT 1
85735: PUSH
85736: EMPTY
85737: LIST
85738: LIST
85739: PUSH
85740: LD_INT 1
85742: NEG
85743: PUSH
85744: LD_INT 0
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: PUSH
85751: LD_INT 1
85753: NEG
85754: PUSH
85755: LD_INT 1
85757: NEG
85758: PUSH
85759: EMPTY
85760: LIST
85761: LIST
85762: PUSH
85763: LD_INT 2
85765: PUSH
85766: LD_INT 1
85768: PUSH
85769: EMPTY
85770: LIST
85771: LIST
85772: PUSH
85773: LD_INT 2
85775: NEG
85776: PUSH
85777: LD_INT 1
85779: NEG
85780: PUSH
85781: EMPTY
85782: LIST
85783: LIST
85784: PUSH
85785: EMPTY
85786: LIST
85787: LIST
85788: LIST
85789: LIST
85790: LIST
85791: LIST
85792: LIST
85793: LIST
85794: LIST
85795: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
85796: LD_ADDR_VAR 0 36
85800: PUSH
85801: LD_INT 0
85803: PUSH
85804: LD_INT 0
85806: PUSH
85807: EMPTY
85808: LIST
85809: LIST
85810: PUSH
85811: LD_INT 0
85813: PUSH
85814: LD_INT 1
85816: NEG
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PUSH
85822: LD_INT 1
85824: PUSH
85825: LD_INT 0
85827: PUSH
85828: EMPTY
85829: LIST
85830: LIST
85831: PUSH
85832: LD_INT 1
85834: PUSH
85835: LD_INT 1
85837: PUSH
85838: EMPTY
85839: LIST
85840: LIST
85841: PUSH
85842: LD_INT 0
85844: PUSH
85845: LD_INT 1
85847: PUSH
85848: EMPTY
85849: LIST
85850: LIST
85851: PUSH
85852: LD_INT 1
85854: NEG
85855: PUSH
85856: LD_INT 0
85858: PUSH
85859: EMPTY
85860: LIST
85861: LIST
85862: PUSH
85863: LD_INT 1
85865: NEG
85866: PUSH
85867: LD_INT 1
85869: NEG
85870: PUSH
85871: EMPTY
85872: LIST
85873: LIST
85874: PUSH
85875: LD_INT 1
85877: NEG
85878: PUSH
85879: LD_INT 2
85881: NEG
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PUSH
85887: LD_INT 1
85889: PUSH
85890: LD_INT 2
85892: PUSH
85893: EMPTY
85894: LIST
85895: LIST
85896: PUSH
85897: EMPTY
85898: LIST
85899: LIST
85900: LIST
85901: LIST
85902: LIST
85903: LIST
85904: LIST
85905: LIST
85906: LIST
85907: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
85908: LD_ADDR_VAR 0 37
85912: PUSH
85913: LD_INT 0
85915: PUSH
85916: LD_INT 0
85918: PUSH
85919: EMPTY
85920: LIST
85921: LIST
85922: PUSH
85923: LD_INT 0
85925: PUSH
85926: LD_INT 1
85928: NEG
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 1
85936: PUSH
85937: LD_INT 0
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 1
85946: PUSH
85947: LD_INT 1
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 0
85956: PUSH
85957: LD_INT 1
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PUSH
85964: LD_INT 1
85966: NEG
85967: PUSH
85968: LD_INT 0
85970: PUSH
85971: EMPTY
85972: LIST
85973: LIST
85974: PUSH
85975: LD_INT 1
85977: NEG
85978: PUSH
85979: LD_INT 1
85981: NEG
85982: PUSH
85983: EMPTY
85984: LIST
85985: LIST
85986: PUSH
85987: LD_INT 1
85989: PUSH
85990: LD_INT 1
85992: NEG
85993: PUSH
85994: EMPTY
85995: LIST
85996: LIST
85997: PUSH
85998: LD_INT 1
86000: NEG
86001: PUSH
86002: LD_INT 1
86004: PUSH
86005: EMPTY
86006: LIST
86007: LIST
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: LIST
86013: LIST
86014: LIST
86015: LIST
86016: LIST
86017: LIST
86018: LIST
86019: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
86020: LD_ADDR_VAR 0 38
86024: PUSH
86025: LD_INT 0
86027: PUSH
86028: LD_INT 0
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: PUSH
86035: LD_INT 0
86037: PUSH
86038: LD_INT 1
86040: NEG
86041: PUSH
86042: EMPTY
86043: LIST
86044: LIST
86045: PUSH
86046: LD_INT 1
86048: PUSH
86049: LD_INT 0
86051: PUSH
86052: EMPTY
86053: LIST
86054: LIST
86055: PUSH
86056: LD_INT 1
86058: PUSH
86059: LD_INT 1
86061: PUSH
86062: EMPTY
86063: LIST
86064: LIST
86065: PUSH
86066: LD_INT 0
86068: PUSH
86069: LD_INT 1
86071: PUSH
86072: EMPTY
86073: LIST
86074: LIST
86075: PUSH
86076: LD_INT 1
86078: NEG
86079: PUSH
86080: LD_INT 0
86082: PUSH
86083: EMPTY
86084: LIST
86085: LIST
86086: PUSH
86087: LD_INT 1
86089: NEG
86090: PUSH
86091: LD_INT 1
86093: NEG
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PUSH
86099: LD_INT 2
86101: PUSH
86102: LD_INT 1
86104: PUSH
86105: EMPTY
86106: LIST
86107: LIST
86108: PUSH
86109: LD_INT 2
86111: NEG
86112: PUSH
86113: LD_INT 1
86115: NEG
86116: PUSH
86117: EMPTY
86118: LIST
86119: LIST
86120: PUSH
86121: EMPTY
86122: LIST
86123: LIST
86124: LIST
86125: LIST
86126: LIST
86127: LIST
86128: LIST
86129: LIST
86130: LIST
86131: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
86132: LD_ADDR_VAR 0 39
86136: PUSH
86137: LD_INT 0
86139: PUSH
86140: LD_INT 0
86142: PUSH
86143: EMPTY
86144: LIST
86145: LIST
86146: PUSH
86147: LD_INT 0
86149: PUSH
86150: LD_INT 1
86152: NEG
86153: PUSH
86154: EMPTY
86155: LIST
86156: LIST
86157: PUSH
86158: LD_INT 1
86160: PUSH
86161: LD_INT 0
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PUSH
86168: LD_INT 1
86170: PUSH
86171: LD_INT 1
86173: PUSH
86174: EMPTY
86175: LIST
86176: LIST
86177: PUSH
86178: LD_INT 0
86180: PUSH
86181: LD_INT 1
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 1
86190: NEG
86191: PUSH
86192: LD_INT 0
86194: PUSH
86195: EMPTY
86196: LIST
86197: LIST
86198: PUSH
86199: LD_INT 1
86201: NEG
86202: PUSH
86203: LD_INT 1
86205: NEG
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: PUSH
86211: LD_INT 1
86213: NEG
86214: PUSH
86215: LD_INT 2
86217: NEG
86218: PUSH
86219: EMPTY
86220: LIST
86221: LIST
86222: PUSH
86223: LD_INT 1
86225: PUSH
86226: LD_INT 2
86228: PUSH
86229: EMPTY
86230: LIST
86231: LIST
86232: PUSH
86233: EMPTY
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
86244: LD_ADDR_VAR 0 40
86248: PUSH
86249: LD_INT 0
86251: PUSH
86252: LD_INT 0
86254: PUSH
86255: EMPTY
86256: LIST
86257: LIST
86258: PUSH
86259: LD_INT 0
86261: PUSH
86262: LD_INT 1
86264: NEG
86265: PUSH
86266: EMPTY
86267: LIST
86268: LIST
86269: PUSH
86270: LD_INT 1
86272: PUSH
86273: LD_INT 0
86275: PUSH
86276: EMPTY
86277: LIST
86278: LIST
86279: PUSH
86280: LD_INT 1
86282: PUSH
86283: LD_INT 1
86285: PUSH
86286: EMPTY
86287: LIST
86288: LIST
86289: PUSH
86290: LD_INT 0
86292: PUSH
86293: LD_INT 1
86295: PUSH
86296: EMPTY
86297: LIST
86298: LIST
86299: PUSH
86300: LD_INT 1
86302: NEG
86303: PUSH
86304: LD_INT 0
86306: PUSH
86307: EMPTY
86308: LIST
86309: LIST
86310: PUSH
86311: LD_INT 1
86313: NEG
86314: PUSH
86315: LD_INT 1
86317: NEG
86318: PUSH
86319: EMPTY
86320: LIST
86321: LIST
86322: PUSH
86323: LD_INT 1
86325: PUSH
86326: LD_INT 1
86328: NEG
86329: PUSH
86330: EMPTY
86331: LIST
86332: LIST
86333: PUSH
86334: LD_INT 1
86336: NEG
86337: PUSH
86338: LD_INT 1
86340: PUSH
86341: EMPTY
86342: LIST
86343: LIST
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: LIST
86349: LIST
86350: LIST
86351: LIST
86352: LIST
86353: LIST
86354: LIST
86355: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86356: LD_ADDR_VAR 0 41
86360: PUSH
86361: LD_INT 0
86363: PUSH
86364: LD_INT 0
86366: PUSH
86367: EMPTY
86368: LIST
86369: LIST
86370: PUSH
86371: LD_INT 0
86373: PUSH
86374: LD_INT 1
86376: NEG
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PUSH
86382: LD_INT 1
86384: PUSH
86385: LD_INT 0
86387: PUSH
86388: EMPTY
86389: LIST
86390: LIST
86391: PUSH
86392: LD_INT 1
86394: PUSH
86395: LD_INT 1
86397: PUSH
86398: EMPTY
86399: LIST
86400: LIST
86401: PUSH
86402: LD_INT 0
86404: PUSH
86405: LD_INT 1
86407: PUSH
86408: EMPTY
86409: LIST
86410: LIST
86411: PUSH
86412: LD_INT 1
86414: NEG
86415: PUSH
86416: LD_INT 0
86418: PUSH
86419: EMPTY
86420: LIST
86421: LIST
86422: PUSH
86423: LD_INT 1
86425: NEG
86426: PUSH
86427: LD_INT 1
86429: NEG
86430: PUSH
86431: EMPTY
86432: LIST
86433: LIST
86434: PUSH
86435: LD_INT 1
86437: NEG
86438: PUSH
86439: LD_INT 2
86441: NEG
86442: PUSH
86443: EMPTY
86444: LIST
86445: LIST
86446: PUSH
86447: LD_INT 1
86449: PUSH
86450: LD_INT 1
86452: NEG
86453: PUSH
86454: EMPTY
86455: LIST
86456: LIST
86457: PUSH
86458: LD_INT 2
86460: PUSH
86461: LD_INT 0
86463: PUSH
86464: EMPTY
86465: LIST
86466: LIST
86467: PUSH
86468: LD_INT 2
86470: PUSH
86471: LD_INT 1
86473: PUSH
86474: EMPTY
86475: LIST
86476: LIST
86477: PUSH
86478: LD_INT 2
86480: PUSH
86481: LD_INT 2
86483: PUSH
86484: EMPTY
86485: LIST
86486: LIST
86487: PUSH
86488: LD_INT 1
86490: PUSH
86491: LD_INT 2
86493: PUSH
86494: EMPTY
86495: LIST
86496: LIST
86497: PUSH
86498: LD_INT 1
86500: NEG
86501: PUSH
86502: LD_INT 1
86504: PUSH
86505: EMPTY
86506: LIST
86507: LIST
86508: PUSH
86509: LD_INT 2
86511: NEG
86512: PUSH
86513: LD_INT 0
86515: PUSH
86516: EMPTY
86517: LIST
86518: LIST
86519: PUSH
86520: LD_INT 2
86522: NEG
86523: PUSH
86524: LD_INT 1
86526: NEG
86527: PUSH
86528: EMPTY
86529: LIST
86530: LIST
86531: PUSH
86532: LD_INT 2
86534: NEG
86535: PUSH
86536: LD_INT 2
86538: NEG
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: LD_INT 2
86546: NEG
86547: PUSH
86548: LD_INT 3
86550: NEG
86551: PUSH
86552: EMPTY
86553: LIST
86554: LIST
86555: PUSH
86556: LD_INT 2
86558: PUSH
86559: LD_INT 1
86561: NEG
86562: PUSH
86563: EMPTY
86564: LIST
86565: LIST
86566: PUSH
86567: LD_INT 3
86569: PUSH
86570: LD_INT 0
86572: PUSH
86573: EMPTY
86574: LIST
86575: LIST
86576: PUSH
86577: LD_INT 3
86579: PUSH
86580: LD_INT 1
86582: PUSH
86583: EMPTY
86584: LIST
86585: LIST
86586: PUSH
86587: LD_INT 3
86589: PUSH
86590: LD_INT 2
86592: PUSH
86593: EMPTY
86594: LIST
86595: LIST
86596: PUSH
86597: LD_INT 3
86599: PUSH
86600: LD_INT 3
86602: PUSH
86603: EMPTY
86604: LIST
86605: LIST
86606: PUSH
86607: LD_INT 2
86609: PUSH
86610: LD_INT 3
86612: PUSH
86613: EMPTY
86614: LIST
86615: LIST
86616: PUSH
86617: LD_INT 2
86619: NEG
86620: PUSH
86621: LD_INT 1
86623: PUSH
86624: EMPTY
86625: LIST
86626: LIST
86627: PUSH
86628: LD_INT 3
86630: NEG
86631: PUSH
86632: LD_INT 0
86634: PUSH
86635: EMPTY
86636: LIST
86637: LIST
86638: PUSH
86639: LD_INT 3
86641: NEG
86642: PUSH
86643: LD_INT 1
86645: NEG
86646: PUSH
86647: EMPTY
86648: LIST
86649: LIST
86650: PUSH
86651: LD_INT 3
86653: NEG
86654: PUSH
86655: LD_INT 2
86657: NEG
86658: PUSH
86659: EMPTY
86660: LIST
86661: LIST
86662: PUSH
86663: LD_INT 3
86665: NEG
86666: PUSH
86667: LD_INT 3
86669: NEG
86670: PUSH
86671: EMPTY
86672: LIST
86673: LIST
86674: PUSH
86675: EMPTY
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: LIST
86681: LIST
86682: LIST
86683: LIST
86684: LIST
86685: LIST
86686: LIST
86687: LIST
86688: LIST
86689: LIST
86690: LIST
86691: LIST
86692: LIST
86693: LIST
86694: LIST
86695: LIST
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: LIST
86702: LIST
86703: LIST
86704: LIST
86705: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
86706: LD_ADDR_VAR 0 42
86710: PUSH
86711: LD_INT 0
86713: PUSH
86714: LD_INT 0
86716: PUSH
86717: EMPTY
86718: LIST
86719: LIST
86720: PUSH
86721: LD_INT 0
86723: PUSH
86724: LD_INT 1
86726: NEG
86727: PUSH
86728: EMPTY
86729: LIST
86730: LIST
86731: PUSH
86732: LD_INT 1
86734: PUSH
86735: LD_INT 0
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: PUSH
86742: LD_INT 1
86744: PUSH
86745: LD_INT 1
86747: PUSH
86748: EMPTY
86749: LIST
86750: LIST
86751: PUSH
86752: LD_INT 0
86754: PUSH
86755: LD_INT 1
86757: PUSH
86758: EMPTY
86759: LIST
86760: LIST
86761: PUSH
86762: LD_INT 1
86764: NEG
86765: PUSH
86766: LD_INT 0
86768: PUSH
86769: EMPTY
86770: LIST
86771: LIST
86772: PUSH
86773: LD_INT 1
86775: NEG
86776: PUSH
86777: LD_INT 1
86779: NEG
86780: PUSH
86781: EMPTY
86782: LIST
86783: LIST
86784: PUSH
86785: LD_INT 1
86787: NEG
86788: PUSH
86789: LD_INT 2
86791: NEG
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: PUSH
86797: LD_INT 0
86799: PUSH
86800: LD_INT 2
86802: NEG
86803: PUSH
86804: EMPTY
86805: LIST
86806: LIST
86807: PUSH
86808: LD_INT 1
86810: PUSH
86811: LD_INT 1
86813: NEG
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: PUSH
86819: LD_INT 2
86821: PUSH
86822: LD_INT 1
86824: PUSH
86825: EMPTY
86826: LIST
86827: LIST
86828: PUSH
86829: LD_INT 2
86831: PUSH
86832: LD_INT 2
86834: PUSH
86835: EMPTY
86836: LIST
86837: LIST
86838: PUSH
86839: LD_INT 1
86841: PUSH
86842: LD_INT 2
86844: PUSH
86845: EMPTY
86846: LIST
86847: LIST
86848: PUSH
86849: LD_INT 0
86851: PUSH
86852: LD_INT 2
86854: PUSH
86855: EMPTY
86856: LIST
86857: LIST
86858: PUSH
86859: LD_INT 1
86861: NEG
86862: PUSH
86863: LD_INT 1
86865: PUSH
86866: EMPTY
86867: LIST
86868: LIST
86869: PUSH
86870: LD_INT 2
86872: NEG
86873: PUSH
86874: LD_INT 1
86876: NEG
86877: PUSH
86878: EMPTY
86879: LIST
86880: LIST
86881: PUSH
86882: LD_INT 2
86884: NEG
86885: PUSH
86886: LD_INT 2
86888: NEG
86889: PUSH
86890: EMPTY
86891: LIST
86892: LIST
86893: PUSH
86894: LD_INT 2
86896: NEG
86897: PUSH
86898: LD_INT 3
86900: NEG
86901: PUSH
86902: EMPTY
86903: LIST
86904: LIST
86905: PUSH
86906: LD_INT 1
86908: NEG
86909: PUSH
86910: LD_INT 3
86912: NEG
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 0
86920: PUSH
86921: LD_INT 3
86923: NEG
86924: PUSH
86925: EMPTY
86926: LIST
86927: LIST
86928: PUSH
86929: LD_INT 1
86931: PUSH
86932: LD_INT 2
86934: NEG
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PUSH
86940: LD_INT 3
86942: PUSH
86943: LD_INT 2
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 3
86952: PUSH
86953: LD_INT 3
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: LD_INT 2
86962: PUSH
86963: LD_INT 3
86965: PUSH
86966: EMPTY
86967: LIST
86968: LIST
86969: PUSH
86970: LD_INT 1
86972: PUSH
86973: LD_INT 3
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: PUSH
86980: LD_INT 0
86982: PUSH
86983: LD_INT 3
86985: PUSH
86986: EMPTY
86987: LIST
86988: LIST
86989: PUSH
86990: LD_INT 1
86992: NEG
86993: PUSH
86994: LD_INT 2
86996: PUSH
86997: EMPTY
86998: LIST
86999: LIST
87000: PUSH
87001: LD_INT 3
87003: NEG
87004: PUSH
87005: LD_INT 2
87007: NEG
87008: PUSH
87009: EMPTY
87010: LIST
87011: LIST
87012: PUSH
87013: LD_INT 3
87015: NEG
87016: PUSH
87017: LD_INT 3
87019: NEG
87020: PUSH
87021: EMPTY
87022: LIST
87023: LIST
87024: PUSH
87025: EMPTY
87026: LIST
87027: LIST
87028: LIST
87029: LIST
87030: LIST
87031: LIST
87032: LIST
87033: LIST
87034: LIST
87035: LIST
87036: LIST
87037: LIST
87038: LIST
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: LIST
87054: LIST
87055: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
87056: LD_ADDR_VAR 0 43
87060: PUSH
87061: LD_INT 0
87063: PUSH
87064: LD_INT 0
87066: PUSH
87067: EMPTY
87068: LIST
87069: LIST
87070: PUSH
87071: LD_INT 0
87073: PUSH
87074: LD_INT 1
87076: NEG
87077: PUSH
87078: EMPTY
87079: LIST
87080: LIST
87081: PUSH
87082: LD_INT 1
87084: PUSH
87085: LD_INT 0
87087: PUSH
87088: EMPTY
87089: LIST
87090: LIST
87091: PUSH
87092: LD_INT 1
87094: PUSH
87095: LD_INT 1
87097: PUSH
87098: EMPTY
87099: LIST
87100: LIST
87101: PUSH
87102: LD_INT 0
87104: PUSH
87105: LD_INT 1
87107: PUSH
87108: EMPTY
87109: LIST
87110: LIST
87111: PUSH
87112: LD_INT 1
87114: NEG
87115: PUSH
87116: LD_INT 0
87118: PUSH
87119: EMPTY
87120: LIST
87121: LIST
87122: PUSH
87123: LD_INT 1
87125: NEG
87126: PUSH
87127: LD_INT 1
87129: NEG
87130: PUSH
87131: EMPTY
87132: LIST
87133: LIST
87134: PUSH
87135: LD_INT 1
87137: NEG
87138: PUSH
87139: LD_INT 2
87141: NEG
87142: PUSH
87143: EMPTY
87144: LIST
87145: LIST
87146: PUSH
87147: LD_INT 0
87149: PUSH
87150: LD_INT 2
87152: NEG
87153: PUSH
87154: EMPTY
87155: LIST
87156: LIST
87157: PUSH
87158: LD_INT 1
87160: PUSH
87161: LD_INT 1
87163: NEG
87164: PUSH
87165: EMPTY
87166: LIST
87167: LIST
87168: PUSH
87169: LD_INT 2
87171: PUSH
87172: LD_INT 0
87174: PUSH
87175: EMPTY
87176: LIST
87177: LIST
87178: PUSH
87179: LD_INT 2
87181: PUSH
87182: LD_INT 1
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PUSH
87189: LD_INT 1
87191: PUSH
87192: LD_INT 2
87194: PUSH
87195: EMPTY
87196: LIST
87197: LIST
87198: PUSH
87199: LD_INT 0
87201: PUSH
87202: LD_INT 2
87204: PUSH
87205: EMPTY
87206: LIST
87207: LIST
87208: PUSH
87209: LD_INT 1
87211: NEG
87212: PUSH
87213: LD_INT 1
87215: PUSH
87216: EMPTY
87217: LIST
87218: LIST
87219: PUSH
87220: LD_INT 2
87222: NEG
87223: PUSH
87224: LD_INT 0
87226: PUSH
87227: EMPTY
87228: LIST
87229: LIST
87230: PUSH
87231: LD_INT 2
87233: NEG
87234: PUSH
87235: LD_INT 1
87237: NEG
87238: PUSH
87239: EMPTY
87240: LIST
87241: LIST
87242: PUSH
87243: LD_INT 1
87245: NEG
87246: PUSH
87247: LD_INT 3
87249: NEG
87250: PUSH
87251: EMPTY
87252: LIST
87253: LIST
87254: PUSH
87255: LD_INT 0
87257: PUSH
87258: LD_INT 3
87260: NEG
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: PUSH
87266: LD_INT 1
87268: PUSH
87269: LD_INT 2
87271: NEG
87272: PUSH
87273: EMPTY
87274: LIST
87275: LIST
87276: PUSH
87277: LD_INT 2
87279: PUSH
87280: LD_INT 1
87282: NEG
87283: PUSH
87284: EMPTY
87285: LIST
87286: LIST
87287: PUSH
87288: LD_INT 3
87290: PUSH
87291: LD_INT 0
87293: PUSH
87294: EMPTY
87295: LIST
87296: LIST
87297: PUSH
87298: LD_INT 3
87300: PUSH
87301: LD_INT 1
87303: PUSH
87304: EMPTY
87305: LIST
87306: LIST
87307: PUSH
87308: LD_INT 1
87310: PUSH
87311: LD_INT 3
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PUSH
87318: LD_INT 0
87320: PUSH
87321: LD_INT 3
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PUSH
87328: LD_INT 1
87330: NEG
87331: PUSH
87332: LD_INT 2
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PUSH
87339: LD_INT 2
87341: NEG
87342: PUSH
87343: LD_INT 1
87345: PUSH
87346: EMPTY
87347: LIST
87348: LIST
87349: PUSH
87350: LD_INT 3
87352: NEG
87353: PUSH
87354: LD_INT 0
87356: PUSH
87357: EMPTY
87358: LIST
87359: LIST
87360: PUSH
87361: LD_INT 3
87363: NEG
87364: PUSH
87365: LD_INT 1
87367: NEG
87368: PUSH
87369: EMPTY
87370: LIST
87371: LIST
87372: PUSH
87373: EMPTY
87374: LIST
87375: LIST
87376: LIST
87377: LIST
87378: LIST
87379: LIST
87380: LIST
87381: LIST
87382: LIST
87383: LIST
87384: LIST
87385: LIST
87386: LIST
87387: LIST
87388: LIST
87389: LIST
87390: LIST
87391: LIST
87392: LIST
87393: LIST
87394: LIST
87395: LIST
87396: LIST
87397: LIST
87398: LIST
87399: LIST
87400: LIST
87401: LIST
87402: LIST
87403: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87404: LD_ADDR_VAR 0 44
87408: PUSH
87409: LD_INT 0
87411: PUSH
87412: LD_INT 0
87414: PUSH
87415: EMPTY
87416: LIST
87417: LIST
87418: PUSH
87419: LD_INT 0
87421: PUSH
87422: LD_INT 1
87424: NEG
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: PUSH
87430: LD_INT 1
87432: PUSH
87433: LD_INT 0
87435: PUSH
87436: EMPTY
87437: LIST
87438: LIST
87439: PUSH
87440: LD_INT 1
87442: PUSH
87443: LD_INT 1
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: PUSH
87450: LD_INT 0
87452: PUSH
87453: LD_INT 1
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: PUSH
87460: LD_INT 1
87462: NEG
87463: PUSH
87464: LD_INT 0
87466: PUSH
87467: EMPTY
87468: LIST
87469: LIST
87470: PUSH
87471: LD_INT 1
87473: NEG
87474: PUSH
87475: LD_INT 1
87477: NEG
87478: PUSH
87479: EMPTY
87480: LIST
87481: LIST
87482: PUSH
87483: LD_INT 1
87485: NEG
87486: PUSH
87487: LD_INT 2
87489: NEG
87490: PUSH
87491: EMPTY
87492: LIST
87493: LIST
87494: PUSH
87495: LD_INT 1
87497: PUSH
87498: LD_INT 1
87500: NEG
87501: PUSH
87502: EMPTY
87503: LIST
87504: LIST
87505: PUSH
87506: LD_INT 2
87508: PUSH
87509: LD_INT 0
87511: PUSH
87512: EMPTY
87513: LIST
87514: LIST
87515: PUSH
87516: LD_INT 2
87518: PUSH
87519: LD_INT 1
87521: PUSH
87522: EMPTY
87523: LIST
87524: LIST
87525: PUSH
87526: LD_INT 2
87528: PUSH
87529: LD_INT 2
87531: PUSH
87532: EMPTY
87533: LIST
87534: LIST
87535: PUSH
87536: LD_INT 1
87538: PUSH
87539: LD_INT 2
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: PUSH
87546: LD_INT 1
87548: NEG
87549: PUSH
87550: LD_INT 1
87552: PUSH
87553: EMPTY
87554: LIST
87555: LIST
87556: PUSH
87557: LD_INT 2
87559: NEG
87560: PUSH
87561: LD_INT 0
87563: PUSH
87564: EMPTY
87565: LIST
87566: LIST
87567: PUSH
87568: LD_INT 2
87570: NEG
87571: PUSH
87572: LD_INT 1
87574: NEG
87575: PUSH
87576: EMPTY
87577: LIST
87578: LIST
87579: PUSH
87580: LD_INT 2
87582: NEG
87583: PUSH
87584: LD_INT 2
87586: NEG
87587: PUSH
87588: EMPTY
87589: LIST
87590: LIST
87591: PUSH
87592: LD_INT 2
87594: NEG
87595: PUSH
87596: LD_INT 3
87598: NEG
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: PUSH
87604: LD_INT 2
87606: PUSH
87607: LD_INT 1
87609: NEG
87610: PUSH
87611: EMPTY
87612: LIST
87613: LIST
87614: PUSH
87615: LD_INT 3
87617: PUSH
87618: LD_INT 0
87620: PUSH
87621: EMPTY
87622: LIST
87623: LIST
87624: PUSH
87625: LD_INT 3
87627: PUSH
87628: LD_INT 1
87630: PUSH
87631: EMPTY
87632: LIST
87633: LIST
87634: PUSH
87635: LD_INT 3
87637: PUSH
87638: LD_INT 2
87640: PUSH
87641: EMPTY
87642: LIST
87643: LIST
87644: PUSH
87645: LD_INT 3
87647: PUSH
87648: LD_INT 3
87650: PUSH
87651: EMPTY
87652: LIST
87653: LIST
87654: PUSH
87655: LD_INT 2
87657: PUSH
87658: LD_INT 3
87660: PUSH
87661: EMPTY
87662: LIST
87663: LIST
87664: PUSH
87665: LD_INT 2
87667: NEG
87668: PUSH
87669: LD_INT 1
87671: PUSH
87672: EMPTY
87673: LIST
87674: LIST
87675: PUSH
87676: LD_INT 3
87678: NEG
87679: PUSH
87680: LD_INT 0
87682: PUSH
87683: EMPTY
87684: LIST
87685: LIST
87686: PUSH
87687: LD_INT 3
87689: NEG
87690: PUSH
87691: LD_INT 1
87693: NEG
87694: PUSH
87695: EMPTY
87696: LIST
87697: LIST
87698: PUSH
87699: LD_INT 3
87701: NEG
87702: PUSH
87703: LD_INT 2
87705: NEG
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: PUSH
87711: LD_INT 3
87713: NEG
87714: PUSH
87715: LD_INT 3
87717: NEG
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: LIST
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: LIST
87743: LIST
87744: LIST
87745: LIST
87746: LIST
87747: LIST
87748: LIST
87749: LIST
87750: LIST
87751: LIST
87752: LIST
87753: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
87754: LD_ADDR_VAR 0 45
87758: PUSH
87759: LD_INT 0
87761: PUSH
87762: LD_INT 0
87764: PUSH
87765: EMPTY
87766: LIST
87767: LIST
87768: PUSH
87769: LD_INT 0
87771: PUSH
87772: LD_INT 1
87774: NEG
87775: PUSH
87776: EMPTY
87777: LIST
87778: LIST
87779: PUSH
87780: LD_INT 1
87782: PUSH
87783: LD_INT 0
87785: PUSH
87786: EMPTY
87787: LIST
87788: LIST
87789: PUSH
87790: LD_INT 1
87792: PUSH
87793: LD_INT 1
87795: PUSH
87796: EMPTY
87797: LIST
87798: LIST
87799: PUSH
87800: LD_INT 0
87802: PUSH
87803: LD_INT 1
87805: PUSH
87806: EMPTY
87807: LIST
87808: LIST
87809: PUSH
87810: LD_INT 1
87812: NEG
87813: PUSH
87814: LD_INT 0
87816: PUSH
87817: EMPTY
87818: LIST
87819: LIST
87820: PUSH
87821: LD_INT 1
87823: NEG
87824: PUSH
87825: LD_INT 1
87827: NEG
87828: PUSH
87829: EMPTY
87830: LIST
87831: LIST
87832: PUSH
87833: LD_INT 1
87835: NEG
87836: PUSH
87837: LD_INT 2
87839: NEG
87840: PUSH
87841: EMPTY
87842: LIST
87843: LIST
87844: PUSH
87845: LD_INT 0
87847: PUSH
87848: LD_INT 2
87850: NEG
87851: PUSH
87852: EMPTY
87853: LIST
87854: LIST
87855: PUSH
87856: LD_INT 1
87858: PUSH
87859: LD_INT 1
87861: NEG
87862: PUSH
87863: EMPTY
87864: LIST
87865: LIST
87866: PUSH
87867: LD_INT 2
87869: PUSH
87870: LD_INT 1
87872: PUSH
87873: EMPTY
87874: LIST
87875: LIST
87876: PUSH
87877: LD_INT 2
87879: PUSH
87880: LD_INT 2
87882: PUSH
87883: EMPTY
87884: LIST
87885: LIST
87886: PUSH
87887: LD_INT 1
87889: PUSH
87890: LD_INT 2
87892: PUSH
87893: EMPTY
87894: LIST
87895: LIST
87896: PUSH
87897: LD_INT 0
87899: PUSH
87900: LD_INT 2
87902: PUSH
87903: EMPTY
87904: LIST
87905: LIST
87906: PUSH
87907: LD_INT 1
87909: NEG
87910: PUSH
87911: LD_INT 1
87913: PUSH
87914: EMPTY
87915: LIST
87916: LIST
87917: PUSH
87918: LD_INT 2
87920: NEG
87921: PUSH
87922: LD_INT 1
87924: NEG
87925: PUSH
87926: EMPTY
87927: LIST
87928: LIST
87929: PUSH
87930: LD_INT 2
87932: NEG
87933: PUSH
87934: LD_INT 2
87936: NEG
87937: PUSH
87938: EMPTY
87939: LIST
87940: LIST
87941: PUSH
87942: LD_INT 2
87944: NEG
87945: PUSH
87946: LD_INT 3
87948: NEG
87949: PUSH
87950: EMPTY
87951: LIST
87952: LIST
87953: PUSH
87954: LD_INT 1
87956: NEG
87957: PUSH
87958: LD_INT 3
87960: NEG
87961: PUSH
87962: EMPTY
87963: LIST
87964: LIST
87965: PUSH
87966: LD_INT 0
87968: PUSH
87969: LD_INT 3
87971: NEG
87972: PUSH
87973: EMPTY
87974: LIST
87975: LIST
87976: PUSH
87977: LD_INT 1
87979: PUSH
87980: LD_INT 2
87982: NEG
87983: PUSH
87984: EMPTY
87985: LIST
87986: LIST
87987: PUSH
87988: LD_INT 3
87990: PUSH
87991: LD_INT 2
87993: PUSH
87994: EMPTY
87995: LIST
87996: LIST
87997: PUSH
87998: LD_INT 3
88000: PUSH
88001: LD_INT 3
88003: PUSH
88004: EMPTY
88005: LIST
88006: LIST
88007: PUSH
88008: LD_INT 2
88010: PUSH
88011: LD_INT 3
88013: PUSH
88014: EMPTY
88015: LIST
88016: LIST
88017: PUSH
88018: LD_INT 1
88020: PUSH
88021: LD_INT 3
88023: PUSH
88024: EMPTY
88025: LIST
88026: LIST
88027: PUSH
88028: LD_INT 0
88030: PUSH
88031: LD_INT 3
88033: PUSH
88034: EMPTY
88035: LIST
88036: LIST
88037: PUSH
88038: LD_INT 1
88040: NEG
88041: PUSH
88042: LD_INT 2
88044: PUSH
88045: EMPTY
88046: LIST
88047: LIST
88048: PUSH
88049: LD_INT 3
88051: NEG
88052: PUSH
88053: LD_INT 2
88055: NEG
88056: PUSH
88057: EMPTY
88058: LIST
88059: LIST
88060: PUSH
88061: LD_INT 3
88063: NEG
88064: PUSH
88065: LD_INT 3
88067: NEG
88068: PUSH
88069: EMPTY
88070: LIST
88071: LIST
88072: PUSH
88073: EMPTY
88074: LIST
88075: LIST
88076: LIST
88077: LIST
88078: LIST
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: LIST
88087: LIST
88088: LIST
88089: LIST
88090: LIST
88091: LIST
88092: LIST
88093: LIST
88094: LIST
88095: LIST
88096: LIST
88097: LIST
88098: LIST
88099: LIST
88100: LIST
88101: LIST
88102: LIST
88103: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
88104: LD_ADDR_VAR 0 46
88108: PUSH
88109: LD_INT 0
88111: PUSH
88112: LD_INT 0
88114: PUSH
88115: EMPTY
88116: LIST
88117: LIST
88118: PUSH
88119: LD_INT 0
88121: PUSH
88122: LD_INT 1
88124: NEG
88125: PUSH
88126: EMPTY
88127: LIST
88128: LIST
88129: PUSH
88130: LD_INT 1
88132: PUSH
88133: LD_INT 0
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: PUSH
88140: LD_INT 1
88142: PUSH
88143: LD_INT 1
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: PUSH
88150: LD_INT 0
88152: PUSH
88153: LD_INT 1
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: LD_INT 1
88162: NEG
88163: PUSH
88164: LD_INT 0
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 1
88173: NEG
88174: PUSH
88175: LD_INT 1
88177: NEG
88178: PUSH
88179: EMPTY
88180: LIST
88181: LIST
88182: PUSH
88183: LD_INT 1
88185: NEG
88186: PUSH
88187: LD_INT 2
88189: NEG
88190: PUSH
88191: EMPTY
88192: LIST
88193: LIST
88194: PUSH
88195: LD_INT 0
88197: PUSH
88198: LD_INT 2
88200: NEG
88201: PUSH
88202: EMPTY
88203: LIST
88204: LIST
88205: PUSH
88206: LD_INT 1
88208: PUSH
88209: LD_INT 1
88211: NEG
88212: PUSH
88213: EMPTY
88214: LIST
88215: LIST
88216: PUSH
88217: LD_INT 2
88219: PUSH
88220: LD_INT 0
88222: PUSH
88223: EMPTY
88224: LIST
88225: LIST
88226: PUSH
88227: LD_INT 2
88229: PUSH
88230: LD_INT 1
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PUSH
88237: LD_INT 1
88239: PUSH
88240: LD_INT 2
88242: PUSH
88243: EMPTY
88244: LIST
88245: LIST
88246: PUSH
88247: LD_INT 0
88249: PUSH
88250: LD_INT 2
88252: PUSH
88253: EMPTY
88254: LIST
88255: LIST
88256: PUSH
88257: LD_INT 1
88259: NEG
88260: PUSH
88261: LD_INT 1
88263: PUSH
88264: EMPTY
88265: LIST
88266: LIST
88267: PUSH
88268: LD_INT 2
88270: NEG
88271: PUSH
88272: LD_INT 0
88274: PUSH
88275: EMPTY
88276: LIST
88277: LIST
88278: PUSH
88279: LD_INT 2
88281: NEG
88282: PUSH
88283: LD_INT 1
88285: NEG
88286: PUSH
88287: EMPTY
88288: LIST
88289: LIST
88290: PUSH
88291: LD_INT 1
88293: NEG
88294: PUSH
88295: LD_INT 3
88297: NEG
88298: PUSH
88299: EMPTY
88300: LIST
88301: LIST
88302: PUSH
88303: LD_INT 0
88305: PUSH
88306: LD_INT 3
88308: NEG
88309: PUSH
88310: EMPTY
88311: LIST
88312: LIST
88313: PUSH
88314: LD_INT 1
88316: PUSH
88317: LD_INT 2
88319: NEG
88320: PUSH
88321: EMPTY
88322: LIST
88323: LIST
88324: PUSH
88325: LD_INT 2
88327: PUSH
88328: LD_INT 1
88330: NEG
88331: PUSH
88332: EMPTY
88333: LIST
88334: LIST
88335: PUSH
88336: LD_INT 3
88338: PUSH
88339: LD_INT 0
88341: PUSH
88342: EMPTY
88343: LIST
88344: LIST
88345: PUSH
88346: LD_INT 3
88348: PUSH
88349: LD_INT 1
88351: PUSH
88352: EMPTY
88353: LIST
88354: LIST
88355: PUSH
88356: LD_INT 1
88358: PUSH
88359: LD_INT 3
88361: PUSH
88362: EMPTY
88363: LIST
88364: LIST
88365: PUSH
88366: LD_INT 0
88368: PUSH
88369: LD_INT 3
88371: PUSH
88372: EMPTY
88373: LIST
88374: LIST
88375: PUSH
88376: LD_INT 1
88378: NEG
88379: PUSH
88380: LD_INT 2
88382: PUSH
88383: EMPTY
88384: LIST
88385: LIST
88386: PUSH
88387: LD_INT 2
88389: NEG
88390: PUSH
88391: LD_INT 1
88393: PUSH
88394: EMPTY
88395: LIST
88396: LIST
88397: PUSH
88398: LD_INT 3
88400: NEG
88401: PUSH
88402: LD_INT 0
88404: PUSH
88405: EMPTY
88406: LIST
88407: LIST
88408: PUSH
88409: LD_INT 3
88411: NEG
88412: PUSH
88413: LD_INT 1
88415: NEG
88416: PUSH
88417: EMPTY
88418: LIST
88419: LIST
88420: PUSH
88421: EMPTY
88422: LIST
88423: LIST
88424: LIST
88425: LIST
88426: LIST
88427: LIST
88428: LIST
88429: LIST
88430: LIST
88431: LIST
88432: LIST
88433: LIST
88434: LIST
88435: LIST
88436: LIST
88437: LIST
88438: LIST
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: LIST
88448: LIST
88449: LIST
88450: LIST
88451: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
88452: LD_ADDR_VAR 0 47
88456: PUSH
88457: LD_INT 0
88459: PUSH
88460: LD_INT 0
88462: PUSH
88463: EMPTY
88464: LIST
88465: LIST
88466: PUSH
88467: LD_INT 0
88469: PUSH
88470: LD_INT 1
88472: NEG
88473: PUSH
88474: EMPTY
88475: LIST
88476: LIST
88477: PUSH
88478: LD_INT 1
88480: PUSH
88481: LD_INT 0
88483: PUSH
88484: EMPTY
88485: LIST
88486: LIST
88487: PUSH
88488: LD_INT 1
88490: PUSH
88491: LD_INT 1
88493: PUSH
88494: EMPTY
88495: LIST
88496: LIST
88497: PUSH
88498: LD_INT 0
88500: PUSH
88501: LD_INT 1
88503: PUSH
88504: EMPTY
88505: LIST
88506: LIST
88507: PUSH
88508: LD_INT 1
88510: NEG
88511: PUSH
88512: LD_INT 0
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: PUSH
88519: LD_INT 1
88521: NEG
88522: PUSH
88523: LD_INT 1
88525: NEG
88526: PUSH
88527: EMPTY
88528: LIST
88529: LIST
88530: PUSH
88531: LD_INT 1
88533: NEG
88534: PUSH
88535: LD_INT 2
88537: NEG
88538: PUSH
88539: EMPTY
88540: LIST
88541: LIST
88542: PUSH
88543: LD_INT 0
88545: PUSH
88546: LD_INT 2
88548: NEG
88549: PUSH
88550: EMPTY
88551: LIST
88552: LIST
88553: PUSH
88554: LD_INT 1
88556: PUSH
88557: LD_INT 1
88559: NEG
88560: PUSH
88561: EMPTY
88562: LIST
88563: LIST
88564: PUSH
88565: LD_INT 2
88567: NEG
88568: PUSH
88569: LD_INT 1
88571: NEG
88572: PUSH
88573: EMPTY
88574: LIST
88575: LIST
88576: PUSH
88577: LD_INT 2
88579: NEG
88580: PUSH
88581: LD_INT 2
88583: NEG
88584: PUSH
88585: EMPTY
88586: LIST
88587: LIST
88588: PUSH
88589: EMPTY
88590: LIST
88591: LIST
88592: LIST
88593: LIST
88594: LIST
88595: LIST
88596: LIST
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
88603: LD_ADDR_VAR 0 48
88607: PUSH
88608: LD_INT 0
88610: PUSH
88611: LD_INT 0
88613: PUSH
88614: EMPTY
88615: LIST
88616: LIST
88617: PUSH
88618: LD_INT 0
88620: PUSH
88621: LD_INT 1
88623: NEG
88624: PUSH
88625: EMPTY
88626: LIST
88627: LIST
88628: PUSH
88629: LD_INT 1
88631: PUSH
88632: LD_INT 0
88634: PUSH
88635: EMPTY
88636: LIST
88637: LIST
88638: PUSH
88639: LD_INT 1
88641: PUSH
88642: LD_INT 1
88644: PUSH
88645: EMPTY
88646: LIST
88647: LIST
88648: PUSH
88649: LD_INT 0
88651: PUSH
88652: LD_INT 1
88654: PUSH
88655: EMPTY
88656: LIST
88657: LIST
88658: PUSH
88659: LD_INT 1
88661: NEG
88662: PUSH
88663: LD_INT 0
88665: PUSH
88666: EMPTY
88667: LIST
88668: LIST
88669: PUSH
88670: LD_INT 1
88672: NEG
88673: PUSH
88674: LD_INT 1
88676: NEG
88677: PUSH
88678: EMPTY
88679: LIST
88680: LIST
88681: PUSH
88682: LD_INT 1
88684: NEG
88685: PUSH
88686: LD_INT 2
88688: NEG
88689: PUSH
88690: EMPTY
88691: LIST
88692: LIST
88693: PUSH
88694: LD_INT 0
88696: PUSH
88697: LD_INT 2
88699: NEG
88700: PUSH
88701: EMPTY
88702: LIST
88703: LIST
88704: PUSH
88705: LD_INT 1
88707: PUSH
88708: LD_INT 1
88710: NEG
88711: PUSH
88712: EMPTY
88713: LIST
88714: LIST
88715: PUSH
88716: LD_INT 2
88718: PUSH
88719: LD_INT 0
88721: PUSH
88722: EMPTY
88723: LIST
88724: LIST
88725: PUSH
88726: LD_INT 2
88728: PUSH
88729: LD_INT 1
88731: PUSH
88732: EMPTY
88733: LIST
88734: LIST
88735: PUSH
88736: EMPTY
88737: LIST
88738: LIST
88739: LIST
88740: LIST
88741: LIST
88742: LIST
88743: LIST
88744: LIST
88745: LIST
88746: LIST
88747: LIST
88748: LIST
88749: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
88750: LD_ADDR_VAR 0 49
88754: PUSH
88755: LD_INT 0
88757: PUSH
88758: LD_INT 0
88760: PUSH
88761: EMPTY
88762: LIST
88763: LIST
88764: PUSH
88765: LD_INT 0
88767: PUSH
88768: LD_INT 1
88770: NEG
88771: PUSH
88772: EMPTY
88773: LIST
88774: LIST
88775: PUSH
88776: LD_INT 1
88778: PUSH
88779: LD_INT 0
88781: PUSH
88782: EMPTY
88783: LIST
88784: LIST
88785: PUSH
88786: LD_INT 1
88788: PUSH
88789: LD_INT 1
88791: PUSH
88792: EMPTY
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 0
88798: PUSH
88799: LD_INT 1
88801: PUSH
88802: EMPTY
88803: LIST
88804: LIST
88805: PUSH
88806: LD_INT 1
88808: NEG
88809: PUSH
88810: LD_INT 0
88812: PUSH
88813: EMPTY
88814: LIST
88815: LIST
88816: PUSH
88817: LD_INT 1
88819: NEG
88820: PUSH
88821: LD_INT 1
88823: NEG
88824: PUSH
88825: EMPTY
88826: LIST
88827: LIST
88828: PUSH
88829: LD_INT 1
88831: PUSH
88832: LD_INT 1
88834: NEG
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: PUSH
88840: LD_INT 2
88842: PUSH
88843: LD_INT 0
88845: PUSH
88846: EMPTY
88847: LIST
88848: LIST
88849: PUSH
88850: LD_INT 2
88852: PUSH
88853: LD_INT 1
88855: PUSH
88856: EMPTY
88857: LIST
88858: LIST
88859: PUSH
88860: LD_INT 2
88862: PUSH
88863: LD_INT 2
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: LD_INT 1
88872: PUSH
88873: LD_INT 2
88875: PUSH
88876: EMPTY
88877: LIST
88878: LIST
88879: PUSH
88880: EMPTY
88881: LIST
88882: LIST
88883: LIST
88884: LIST
88885: LIST
88886: LIST
88887: LIST
88888: LIST
88889: LIST
88890: LIST
88891: LIST
88892: LIST
88893: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
88894: LD_ADDR_VAR 0 50
88898: PUSH
88899: LD_INT 0
88901: PUSH
88902: LD_INT 0
88904: PUSH
88905: EMPTY
88906: LIST
88907: LIST
88908: PUSH
88909: LD_INT 0
88911: PUSH
88912: LD_INT 1
88914: NEG
88915: PUSH
88916: EMPTY
88917: LIST
88918: LIST
88919: PUSH
88920: LD_INT 1
88922: PUSH
88923: LD_INT 0
88925: PUSH
88926: EMPTY
88927: LIST
88928: LIST
88929: PUSH
88930: LD_INT 1
88932: PUSH
88933: LD_INT 1
88935: PUSH
88936: EMPTY
88937: LIST
88938: LIST
88939: PUSH
88940: LD_INT 0
88942: PUSH
88943: LD_INT 1
88945: PUSH
88946: EMPTY
88947: LIST
88948: LIST
88949: PUSH
88950: LD_INT 1
88952: NEG
88953: PUSH
88954: LD_INT 0
88956: PUSH
88957: EMPTY
88958: LIST
88959: LIST
88960: PUSH
88961: LD_INT 1
88963: NEG
88964: PUSH
88965: LD_INT 1
88967: NEG
88968: PUSH
88969: EMPTY
88970: LIST
88971: LIST
88972: PUSH
88973: LD_INT 2
88975: PUSH
88976: LD_INT 1
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PUSH
88983: LD_INT 2
88985: PUSH
88986: LD_INT 2
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PUSH
88993: LD_INT 1
88995: PUSH
88996: LD_INT 2
88998: PUSH
88999: EMPTY
89000: LIST
89001: LIST
89002: PUSH
89003: LD_INT 0
89005: PUSH
89006: LD_INT 2
89008: PUSH
89009: EMPTY
89010: LIST
89011: LIST
89012: PUSH
89013: LD_INT 1
89015: NEG
89016: PUSH
89017: LD_INT 1
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: PUSH
89024: EMPTY
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: LIST
89034: LIST
89035: LIST
89036: LIST
89037: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
89038: LD_ADDR_VAR 0 51
89042: PUSH
89043: LD_INT 0
89045: PUSH
89046: LD_INT 0
89048: PUSH
89049: EMPTY
89050: LIST
89051: LIST
89052: PUSH
89053: LD_INT 0
89055: PUSH
89056: LD_INT 1
89058: NEG
89059: PUSH
89060: EMPTY
89061: LIST
89062: LIST
89063: PUSH
89064: LD_INT 1
89066: PUSH
89067: LD_INT 0
89069: PUSH
89070: EMPTY
89071: LIST
89072: LIST
89073: PUSH
89074: LD_INT 1
89076: PUSH
89077: LD_INT 1
89079: PUSH
89080: EMPTY
89081: LIST
89082: LIST
89083: PUSH
89084: LD_INT 0
89086: PUSH
89087: LD_INT 1
89089: PUSH
89090: EMPTY
89091: LIST
89092: LIST
89093: PUSH
89094: LD_INT 1
89096: NEG
89097: PUSH
89098: LD_INT 0
89100: PUSH
89101: EMPTY
89102: LIST
89103: LIST
89104: PUSH
89105: LD_INT 1
89107: NEG
89108: PUSH
89109: LD_INT 1
89111: NEG
89112: PUSH
89113: EMPTY
89114: LIST
89115: LIST
89116: PUSH
89117: LD_INT 1
89119: PUSH
89120: LD_INT 2
89122: PUSH
89123: EMPTY
89124: LIST
89125: LIST
89126: PUSH
89127: LD_INT 0
89129: PUSH
89130: LD_INT 2
89132: PUSH
89133: EMPTY
89134: LIST
89135: LIST
89136: PUSH
89137: LD_INT 1
89139: NEG
89140: PUSH
89141: LD_INT 1
89143: PUSH
89144: EMPTY
89145: LIST
89146: LIST
89147: PUSH
89148: LD_INT 2
89150: NEG
89151: PUSH
89152: LD_INT 0
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PUSH
89159: LD_INT 2
89161: NEG
89162: PUSH
89163: LD_INT 1
89165: NEG
89166: PUSH
89167: EMPTY
89168: LIST
89169: LIST
89170: PUSH
89171: EMPTY
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: LIST
89177: LIST
89178: LIST
89179: LIST
89180: LIST
89181: LIST
89182: LIST
89183: LIST
89184: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89185: LD_ADDR_VAR 0 52
89189: PUSH
89190: LD_INT 0
89192: PUSH
89193: LD_INT 0
89195: PUSH
89196: EMPTY
89197: LIST
89198: LIST
89199: PUSH
89200: LD_INT 0
89202: PUSH
89203: LD_INT 1
89205: NEG
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: PUSH
89211: LD_INT 1
89213: PUSH
89214: LD_INT 0
89216: PUSH
89217: EMPTY
89218: LIST
89219: LIST
89220: PUSH
89221: LD_INT 1
89223: PUSH
89224: LD_INT 1
89226: PUSH
89227: EMPTY
89228: LIST
89229: LIST
89230: PUSH
89231: LD_INT 0
89233: PUSH
89234: LD_INT 1
89236: PUSH
89237: EMPTY
89238: LIST
89239: LIST
89240: PUSH
89241: LD_INT 1
89243: NEG
89244: PUSH
89245: LD_INT 0
89247: PUSH
89248: EMPTY
89249: LIST
89250: LIST
89251: PUSH
89252: LD_INT 1
89254: NEG
89255: PUSH
89256: LD_INT 1
89258: NEG
89259: PUSH
89260: EMPTY
89261: LIST
89262: LIST
89263: PUSH
89264: LD_INT 1
89266: NEG
89267: PUSH
89268: LD_INT 2
89270: NEG
89271: PUSH
89272: EMPTY
89273: LIST
89274: LIST
89275: PUSH
89276: LD_INT 1
89278: NEG
89279: PUSH
89280: LD_INT 1
89282: PUSH
89283: EMPTY
89284: LIST
89285: LIST
89286: PUSH
89287: LD_INT 2
89289: NEG
89290: PUSH
89291: LD_INT 0
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: PUSH
89298: LD_INT 2
89300: NEG
89301: PUSH
89302: LD_INT 1
89304: NEG
89305: PUSH
89306: EMPTY
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 2
89312: NEG
89313: PUSH
89314: LD_INT 2
89316: NEG
89317: PUSH
89318: EMPTY
89319: LIST
89320: LIST
89321: PUSH
89322: EMPTY
89323: LIST
89324: LIST
89325: LIST
89326: LIST
89327: LIST
89328: LIST
89329: LIST
89330: LIST
89331: LIST
89332: LIST
89333: LIST
89334: LIST
89335: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89336: LD_ADDR_VAR 0 53
89340: PUSH
89341: LD_INT 0
89343: PUSH
89344: LD_INT 0
89346: PUSH
89347: EMPTY
89348: LIST
89349: LIST
89350: PUSH
89351: LD_INT 0
89353: PUSH
89354: LD_INT 1
89356: NEG
89357: PUSH
89358: EMPTY
89359: LIST
89360: LIST
89361: PUSH
89362: LD_INT 1
89364: PUSH
89365: LD_INT 0
89367: PUSH
89368: EMPTY
89369: LIST
89370: LIST
89371: PUSH
89372: LD_INT 1
89374: PUSH
89375: LD_INT 1
89377: PUSH
89378: EMPTY
89379: LIST
89380: LIST
89381: PUSH
89382: LD_INT 0
89384: PUSH
89385: LD_INT 1
89387: PUSH
89388: EMPTY
89389: LIST
89390: LIST
89391: PUSH
89392: LD_INT 1
89394: NEG
89395: PUSH
89396: LD_INT 0
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: PUSH
89403: LD_INT 1
89405: NEG
89406: PUSH
89407: LD_INT 1
89409: NEG
89410: PUSH
89411: EMPTY
89412: LIST
89413: LIST
89414: PUSH
89415: LD_INT 1
89417: NEG
89418: PUSH
89419: LD_INT 2
89421: NEG
89422: PUSH
89423: EMPTY
89424: LIST
89425: LIST
89426: PUSH
89427: LD_INT 0
89429: PUSH
89430: LD_INT 2
89432: NEG
89433: PUSH
89434: EMPTY
89435: LIST
89436: LIST
89437: PUSH
89438: LD_INT 1
89440: PUSH
89441: LD_INT 1
89443: NEG
89444: PUSH
89445: EMPTY
89446: LIST
89447: LIST
89448: PUSH
89449: LD_INT 2
89451: PUSH
89452: LD_INT 0
89454: PUSH
89455: EMPTY
89456: LIST
89457: LIST
89458: PUSH
89459: LD_INT 2
89461: PUSH
89462: LD_INT 1
89464: PUSH
89465: EMPTY
89466: LIST
89467: LIST
89468: PUSH
89469: LD_INT 2
89471: PUSH
89472: LD_INT 2
89474: PUSH
89475: EMPTY
89476: LIST
89477: LIST
89478: PUSH
89479: LD_INT 1
89481: PUSH
89482: LD_INT 2
89484: PUSH
89485: EMPTY
89486: LIST
89487: LIST
89488: PUSH
89489: LD_INT 0
89491: PUSH
89492: LD_INT 2
89494: PUSH
89495: EMPTY
89496: LIST
89497: LIST
89498: PUSH
89499: LD_INT 1
89501: NEG
89502: PUSH
89503: LD_INT 1
89505: PUSH
89506: EMPTY
89507: LIST
89508: LIST
89509: PUSH
89510: LD_INT 2
89512: NEG
89513: PUSH
89514: LD_INT 0
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: PUSH
89521: LD_INT 2
89523: NEG
89524: PUSH
89525: LD_INT 1
89527: NEG
89528: PUSH
89529: EMPTY
89530: LIST
89531: LIST
89532: PUSH
89533: LD_INT 2
89535: NEG
89536: PUSH
89537: LD_INT 2
89539: NEG
89540: PUSH
89541: EMPTY
89542: LIST
89543: LIST
89544: PUSH
89545: EMPTY
89546: LIST
89547: LIST
89548: LIST
89549: LIST
89550: LIST
89551: LIST
89552: LIST
89553: LIST
89554: LIST
89555: LIST
89556: LIST
89557: LIST
89558: LIST
89559: LIST
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89566: LD_ADDR_VAR 0 54
89570: PUSH
89571: LD_INT 0
89573: PUSH
89574: LD_INT 0
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: LD_INT 0
89583: PUSH
89584: LD_INT 1
89586: NEG
89587: PUSH
89588: EMPTY
89589: LIST
89590: LIST
89591: PUSH
89592: LD_INT 1
89594: PUSH
89595: LD_INT 0
89597: PUSH
89598: EMPTY
89599: LIST
89600: LIST
89601: PUSH
89602: LD_INT 1
89604: PUSH
89605: LD_INT 1
89607: PUSH
89608: EMPTY
89609: LIST
89610: LIST
89611: PUSH
89612: LD_INT 0
89614: PUSH
89615: LD_INT 1
89617: PUSH
89618: EMPTY
89619: LIST
89620: LIST
89621: PUSH
89622: LD_INT 1
89624: NEG
89625: PUSH
89626: LD_INT 0
89628: PUSH
89629: EMPTY
89630: LIST
89631: LIST
89632: PUSH
89633: LD_INT 1
89635: NEG
89636: PUSH
89637: LD_INT 1
89639: NEG
89640: PUSH
89641: EMPTY
89642: LIST
89643: LIST
89644: PUSH
89645: LD_INT 1
89647: NEG
89648: PUSH
89649: LD_INT 2
89651: NEG
89652: PUSH
89653: EMPTY
89654: LIST
89655: LIST
89656: PUSH
89657: LD_INT 0
89659: PUSH
89660: LD_INT 2
89662: NEG
89663: PUSH
89664: EMPTY
89665: LIST
89666: LIST
89667: PUSH
89668: LD_INT 1
89670: PUSH
89671: LD_INT 1
89673: NEG
89674: PUSH
89675: EMPTY
89676: LIST
89677: LIST
89678: PUSH
89679: LD_INT 2
89681: PUSH
89682: LD_INT 0
89684: PUSH
89685: EMPTY
89686: LIST
89687: LIST
89688: PUSH
89689: LD_INT 2
89691: PUSH
89692: LD_INT 1
89694: PUSH
89695: EMPTY
89696: LIST
89697: LIST
89698: PUSH
89699: LD_INT 2
89701: PUSH
89702: LD_INT 2
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: PUSH
89709: LD_INT 1
89711: PUSH
89712: LD_INT 2
89714: PUSH
89715: EMPTY
89716: LIST
89717: LIST
89718: PUSH
89719: LD_INT 0
89721: PUSH
89722: LD_INT 2
89724: PUSH
89725: EMPTY
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 1
89731: NEG
89732: PUSH
89733: LD_INT 1
89735: PUSH
89736: EMPTY
89737: LIST
89738: LIST
89739: PUSH
89740: LD_INT 2
89742: NEG
89743: PUSH
89744: LD_INT 0
89746: PUSH
89747: EMPTY
89748: LIST
89749: LIST
89750: PUSH
89751: LD_INT 2
89753: NEG
89754: PUSH
89755: LD_INT 1
89757: NEG
89758: PUSH
89759: EMPTY
89760: LIST
89761: LIST
89762: PUSH
89763: LD_INT 2
89765: NEG
89766: PUSH
89767: LD_INT 2
89769: NEG
89770: PUSH
89771: EMPTY
89772: LIST
89773: LIST
89774: PUSH
89775: EMPTY
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: LIST
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
89796: LD_ADDR_VAR 0 55
89800: PUSH
89801: LD_INT 0
89803: PUSH
89804: LD_INT 0
89806: PUSH
89807: EMPTY
89808: LIST
89809: LIST
89810: PUSH
89811: LD_INT 0
89813: PUSH
89814: LD_INT 1
89816: NEG
89817: PUSH
89818: EMPTY
89819: LIST
89820: LIST
89821: PUSH
89822: LD_INT 1
89824: PUSH
89825: LD_INT 0
89827: PUSH
89828: EMPTY
89829: LIST
89830: LIST
89831: PUSH
89832: LD_INT 1
89834: PUSH
89835: LD_INT 1
89837: PUSH
89838: EMPTY
89839: LIST
89840: LIST
89841: PUSH
89842: LD_INT 0
89844: PUSH
89845: LD_INT 1
89847: PUSH
89848: EMPTY
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 1
89854: NEG
89855: PUSH
89856: LD_INT 0
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: PUSH
89863: LD_INT 1
89865: NEG
89866: PUSH
89867: LD_INT 1
89869: NEG
89870: PUSH
89871: EMPTY
89872: LIST
89873: LIST
89874: PUSH
89875: LD_INT 1
89877: NEG
89878: PUSH
89879: LD_INT 2
89881: NEG
89882: PUSH
89883: EMPTY
89884: LIST
89885: LIST
89886: PUSH
89887: LD_INT 0
89889: PUSH
89890: LD_INT 2
89892: NEG
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: PUSH
89898: LD_INT 1
89900: PUSH
89901: LD_INT 1
89903: NEG
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: PUSH
89909: LD_INT 2
89911: PUSH
89912: LD_INT 0
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: PUSH
89919: LD_INT 2
89921: PUSH
89922: LD_INT 1
89924: PUSH
89925: EMPTY
89926: LIST
89927: LIST
89928: PUSH
89929: LD_INT 2
89931: PUSH
89932: LD_INT 2
89934: PUSH
89935: EMPTY
89936: LIST
89937: LIST
89938: PUSH
89939: LD_INT 1
89941: PUSH
89942: LD_INT 2
89944: PUSH
89945: EMPTY
89946: LIST
89947: LIST
89948: PUSH
89949: LD_INT 0
89951: PUSH
89952: LD_INT 2
89954: PUSH
89955: EMPTY
89956: LIST
89957: LIST
89958: PUSH
89959: LD_INT 1
89961: NEG
89962: PUSH
89963: LD_INT 1
89965: PUSH
89966: EMPTY
89967: LIST
89968: LIST
89969: PUSH
89970: LD_INT 2
89972: NEG
89973: PUSH
89974: LD_INT 0
89976: PUSH
89977: EMPTY
89978: LIST
89979: LIST
89980: PUSH
89981: LD_INT 2
89983: NEG
89984: PUSH
89985: LD_INT 1
89987: NEG
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 2
89995: NEG
89996: PUSH
89997: LD_INT 2
89999: NEG
90000: PUSH
90001: EMPTY
90002: LIST
90003: LIST
90004: PUSH
90005: EMPTY
90006: LIST
90007: LIST
90008: LIST
90009: LIST
90010: LIST
90011: LIST
90012: LIST
90013: LIST
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: LIST
90020: LIST
90021: LIST
90022: LIST
90023: LIST
90024: LIST
90025: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90026: LD_ADDR_VAR 0 56
90030: PUSH
90031: LD_INT 0
90033: PUSH
90034: LD_INT 0
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 0
90043: PUSH
90044: LD_INT 1
90046: NEG
90047: PUSH
90048: EMPTY
90049: LIST
90050: LIST
90051: PUSH
90052: LD_INT 1
90054: PUSH
90055: LD_INT 0
90057: PUSH
90058: EMPTY
90059: LIST
90060: LIST
90061: PUSH
90062: LD_INT 1
90064: PUSH
90065: LD_INT 1
90067: PUSH
90068: EMPTY
90069: LIST
90070: LIST
90071: PUSH
90072: LD_INT 0
90074: PUSH
90075: LD_INT 1
90077: PUSH
90078: EMPTY
90079: LIST
90080: LIST
90081: PUSH
90082: LD_INT 1
90084: NEG
90085: PUSH
90086: LD_INT 0
90088: PUSH
90089: EMPTY
90090: LIST
90091: LIST
90092: PUSH
90093: LD_INT 1
90095: NEG
90096: PUSH
90097: LD_INT 1
90099: NEG
90100: PUSH
90101: EMPTY
90102: LIST
90103: LIST
90104: PUSH
90105: LD_INT 1
90107: NEG
90108: PUSH
90109: LD_INT 2
90111: NEG
90112: PUSH
90113: EMPTY
90114: LIST
90115: LIST
90116: PUSH
90117: LD_INT 0
90119: PUSH
90120: LD_INT 2
90122: NEG
90123: PUSH
90124: EMPTY
90125: LIST
90126: LIST
90127: PUSH
90128: LD_INT 1
90130: PUSH
90131: LD_INT 1
90133: NEG
90134: PUSH
90135: EMPTY
90136: LIST
90137: LIST
90138: PUSH
90139: LD_INT 2
90141: PUSH
90142: LD_INT 0
90144: PUSH
90145: EMPTY
90146: LIST
90147: LIST
90148: PUSH
90149: LD_INT 2
90151: PUSH
90152: LD_INT 1
90154: PUSH
90155: EMPTY
90156: LIST
90157: LIST
90158: PUSH
90159: LD_INT 2
90161: PUSH
90162: LD_INT 2
90164: PUSH
90165: EMPTY
90166: LIST
90167: LIST
90168: PUSH
90169: LD_INT 1
90171: PUSH
90172: LD_INT 2
90174: PUSH
90175: EMPTY
90176: LIST
90177: LIST
90178: PUSH
90179: LD_INT 0
90181: PUSH
90182: LD_INT 2
90184: PUSH
90185: EMPTY
90186: LIST
90187: LIST
90188: PUSH
90189: LD_INT 1
90191: NEG
90192: PUSH
90193: LD_INT 1
90195: PUSH
90196: EMPTY
90197: LIST
90198: LIST
90199: PUSH
90200: LD_INT 2
90202: NEG
90203: PUSH
90204: LD_INT 0
90206: PUSH
90207: EMPTY
90208: LIST
90209: LIST
90210: PUSH
90211: LD_INT 2
90213: NEG
90214: PUSH
90215: LD_INT 1
90217: NEG
90218: PUSH
90219: EMPTY
90220: LIST
90221: LIST
90222: PUSH
90223: LD_INT 2
90225: NEG
90226: PUSH
90227: LD_INT 2
90229: NEG
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: PUSH
90235: EMPTY
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: LIST
90250: LIST
90251: LIST
90252: LIST
90253: LIST
90254: LIST
90255: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90256: LD_ADDR_VAR 0 57
90260: PUSH
90261: LD_INT 0
90263: PUSH
90264: LD_INT 0
90266: PUSH
90267: EMPTY
90268: LIST
90269: LIST
90270: PUSH
90271: LD_INT 0
90273: PUSH
90274: LD_INT 1
90276: NEG
90277: PUSH
90278: EMPTY
90279: LIST
90280: LIST
90281: PUSH
90282: LD_INT 1
90284: PUSH
90285: LD_INT 0
90287: PUSH
90288: EMPTY
90289: LIST
90290: LIST
90291: PUSH
90292: LD_INT 1
90294: PUSH
90295: LD_INT 1
90297: PUSH
90298: EMPTY
90299: LIST
90300: LIST
90301: PUSH
90302: LD_INT 0
90304: PUSH
90305: LD_INT 1
90307: PUSH
90308: EMPTY
90309: LIST
90310: LIST
90311: PUSH
90312: LD_INT 1
90314: NEG
90315: PUSH
90316: LD_INT 0
90318: PUSH
90319: EMPTY
90320: LIST
90321: LIST
90322: PUSH
90323: LD_INT 1
90325: NEG
90326: PUSH
90327: LD_INT 1
90329: NEG
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: PUSH
90335: LD_INT 1
90337: NEG
90338: PUSH
90339: LD_INT 2
90341: NEG
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: PUSH
90347: LD_INT 0
90349: PUSH
90350: LD_INT 2
90352: NEG
90353: PUSH
90354: EMPTY
90355: LIST
90356: LIST
90357: PUSH
90358: LD_INT 1
90360: PUSH
90361: LD_INT 1
90363: NEG
90364: PUSH
90365: EMPTY
90366: LIST
90367: LIST
90368: PUSH
90369: LD_INT 2
90371: PUSH
90372: LD_INT 0
90374: PUSH
90375: EMPTY
90376: LIST
90377: LIST
90378: PUSH
90379: LD_INT 2
90381: PUSH
90382: LD_INT 1
90384: PUSH
90385: EMPTY
90386: LIST
90387: LIST
90388: PUSH
90389: LD_INT 2
90391: PUSH
90392: LD_INT 2
90394: PUSH
90395: EMPTY
90396: LIST
90397: LIST
90398: PUSH
90399: LD_INT 1
90401: PUSH
90402: LD_INT 2
90404: PUSH
90405: EMPTY
90406: LIST
90407: LIST
90408: PUSH
90409: LD_INT 0
90411: PUSH
90412: LD_INT 2
90414: PUSH
90415: EMPTY
90416: LIST
90417: LIST
90418: PUSH
90419: LD_INT 1
90421: NEG
90422: PUSH
90423: LD_INT 1
90425: PUSH
90426: EMPTY
90427: LIST
90428: LIST
90429: PUSH
90430: LD_INT 2
90432: NEG
90433: PUSH
90434: LD_INT 0
90436: PUSH
90437: EMPTY
90438: LIST
90439: LIST
90440: PUSH
90441: LD_INT 2
90443: NEG
90444: PUSH
90445: LD_INT 1
90447: NEG
90448: PUSH
90449: EMPTY
90450: LIST
90451: LIST
90452: PUSH
90453: LD_INT 2
90455: NEG
90456: PUSH
90457: LD_INT 2
90459: NEG
90460: PUSH
90461: EMPTY
90462: LIST
90463: LIST
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: LIST
90472: LIST
90473: LIST
90474: LIST
90475: LIST
90476: LIST
90477: LIST
90478: LIST
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
90486: LD_ADDR_VAR 0 58
90490: PUSH
90491: LD_INT 0
90493: PUSH
90494: LD_INT 0
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: PUSH
90501: LD_INT 0
90503: PUSH
90504: LD_INT 1
90506: NEG
90507: PUSH
90508: EMPTY
90509: LIST
90510: LIST
90511: PUSH
90512: LD_INT 1
90514: PUSH
90515: LD_INT 0
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: PUSH
90522: LD_INT 1
90524: PUSH
90525: LD_INT 1
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: PUSH
90532: LD_INT 0
90534: PUSH
90535: LD_INT 1
90537: PUSH
90538: EMPTY
90539: LIST
90540: LIST
90541: PUSH
90542: LD_INT 1
90544: NEG
90545: PUSH
90546: LD_INT 0
90548: PUSH
90549: EMPTY
90550: LIST
90551: LIST
90552: PUSH
90553: LD_INT 1
90555: NEG
90556: PUSH
90557: LD_INT 1
90559: NEG
90560: PUSH
90561: EMPTY
90562: LIST
90563: LIST
90564: PUSH
90565: LD_INT 1
90567: NEG
90568: PUSH
90569: LD_INT 2
90571: NEG
90572: PUSH
90573: EMPTY
90574: LIST
90575: LIST
90576: PUSH
90577: LD_INT 0
90579: PUSH
90580: LD_INT 2
90582: NEG
90583: PUSH
90584: EMPTY
90585: LIST
90586: LIST
90587: PUSH
90588: LD_INT 1
90590: PUSH
90591: LD_INT 1
90593: NEG
90594: PUSH
90595: EMPTY
90596: LIST
90597: LIST
90598: PUSH
90599: LD_INT 2
90601: PUSH
90602: LD_INT 0
90604: PUSH
90605: EMPTY
90606: LIST
90607: LIST
90608: PUSH
90609: LD_INT 2
90611: PUSH
90612: LD_INT 1
90614: PUSH
90615: EMPTY
90616: LIST
90617: LIST
90618: PUSH
90619: LD_INT 2
90621: PUSH
90622: LD_INT 2
90624: PUSH
90625: EMPTY
90626: LIST
90627: LIST
90628: PUSH
90629: LD_INT 1
90631: PUSH
90632: LD_INT 2
90634: PUSH
90635: EMPTY
90636: LIST
90637: LIST
90638: PUSH
90639: LD_INT 0
90641: PUSH
90642: LD_INT 2
90644: PUSH
90645: EMPTY
90646: LIST
90647: LIST
90648: PUSH
90649: LD_INT 1
90651: NEG
90652: PUSH
90653: LD_INT 1
90655: PUSH
90656: EMPTY
90657: LIST
90658: LIST
90659: PUSH
90660: LD_INT 2
90662: NEG
90663: PUSH
90664: LD_INT 0
90666: PUSH
90667: EMPTY
90668: LIST
90669: LIST
90670: PUSH
90671: LD_INT 2
90673: NEG
90674: PUSH
90675: LD_INT 1
90677: NEG
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 2
90685: NEG
90686: PUSH
90687: LD_INT 2
90689: NEG
90690: PUSH
90691: EMPTY
90692: LIST
90693: LIST
90694: PUSH
90695: EMPTY
90696: LIST
90697: LIST
90698: LIST
90699: LIST
90700: LIST
90701: LIST
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90716: LD_ADDR_VAR 0 59
90720: PUSH
90721: LD_INT 0
90723: PUSH
90724: LD_INT 0
90726: PUSH
90727: EMPTY
90728: LIST
90729: LIST
90730: PUSH
90731: LD_INT 0
90733: PUSH
90734: LD_INT 1
90736: NEG
90737: PUSH
90738: EMPTY
90739: LIST
90740: LIST
90741: PUSH
90742: LD_INT 1
90744: PUSH
90745: LD_INT 0
90747: PUSH
90748: EMPTY
90749: LIST
90750: LIST
90751: PUSH
90752: LD_INT 1
90754: PUSH
90755: LD_INT 1
90757: PUSH
90758: EMPTY
90759: LIST
90760: LIST
90761: PUSH
90762: LD_INT 0
90764: PUSH
90765: LD_INT 1
90767: PUSH
90768: EMPTY
90769: LIST
90770: LIST
90771: PUSH
90772: LD_INT 1
90774: NEG
90775: PUSH
90776: LD_INT 0
90778: PUSH
90779: EMPTY
90780: LIST
90781: LIST
90782: PUSH
90783: LD_INT 1
90785: NEG
90786: PUSH
90787: LD_INT 1
90789: NEG
90790: PUSH
90791: EMPTY
90792: LIST
90793: LIST
90794: PUSH
90795: EMPTY
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90804: LD_ADDR_VAR 0 60
90808: PUSH
90809: LD_INT 0
90811: PUSH
90812: LD_INT 0
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: LD_INT 0
90821: PUSH
90822: LD_INT 1
90824: NEG
90825: PUSH
90826: EMPTY
90827: LIST
90828: LIST
90829: PUSH
90830: LD_INT 1
90832: PUSH
90833: LD_INT 0
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: LD_INT 1
90842: PUSH
90843: LD_INT 1
90845: PUSH
90846: EMPTY
90847: LIST
90848: LIST
90849: PUSH
90850: LD_INT 0
90852: PUSH
90853: LD_INT 1
90855: PUSH
90856: EMPTY
90857: LIST
90858: LIST
90859: PUSH
90860: LD_INT 1
90862: NEG
90863: PUSH
90864: LD_INT 0
90866: PUSH
90867: EMPTY
90868: LIST
90869: LIST
90870: PUSH
90871: LD_INT 1
90873: NEG
90874: PUSH
90875: LD_INT 1
90877: NEG
90878: PUSH
90879: EMPTY
90880: LIST
90881: LIST
90882: PUSH
90883: EMPTY
90884: LIST
90885: LIST
90886: LIST
90887: LIST
90888: LIST
90889: LIST
90890: LIST
90891: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90892: LD_ADDR_VAR 0 61
90896: PUSH
90897: LD_INT 0
90899: PUSH
90900: LD_INT 0
90902: PUSH
90903: EMPTY
90904: LIST
90905: LIST
90906: PUSH
90907: LD_INT 0
90909: PUSH
90910: LD_INT 1
90912: NEG
90913: PUSH
90914: EMPTY
90915: LIST
90916: LIST
90917: PUSH
90918: LD_INT 1
90920: PUSH
90921: LD_INT 0
90923: PUSH
90924: EMPTY
90925: LIST
90926: LIST
90927: PUSH
90928: LD_INT 1
90930: PUSH
90931: LD_INT 1
90933: PUSH
90934: EMPTY
90935: LIST
90936: LIST
90937: PUSH
90938: LD_INT 0
90940: PUSH
90941: LD_INT 1
90943: PUSH
90944: EMPTY
90945: LIST
90946: LIST
90947: PUSH
90948: LD_INT 1
90950: NEG
90951: PUSH
90952: LD_INT 0
90954: PUSH
90955: EMPTY
90956: LIST
90957: LIST
90958: PUSH
90959: LD_INT 1
90961: NEG
90962: PUSH
90963: LD_INT 1
90965: NEG
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: LIST
90975: LIST
90976: LIST
90977: LIST
90978: LIST
90979: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
90980: LD_ADDR_VAR 0 62
90984: PUSH
90985: LD_INT 0
90987: PUSH
90988: LD_INT 0
90990: PUSH
90991: EMPTY
90992: LIST
90993: LIST
90994: PUSH
90995: LD_INT 0
90997: PUSH
90998: LD_INT 1
91000: NEG
91001: PUSH
91002: EMPTY
91003: LIST
91004: LIST
91005: PUSH
91006: LD_INT 1
91008: PUSH
91009: LD_INT 0
91011: PUSH
91012: EMPTY
91013: LIST
91014: LIST
91015: PUSH
91016: LD_INT 1
91018: PUSH
91019: LD_INT 1
91021: PUSH
91022: EMPTY
91023: LIST
91024: LIST
91025: PUSH
91026: LD_INT 0
91028: PUSH
91029: LD_INT 1
91031: PUSH
91032: EMPTY
91033: LIST
91034: LIST
91035: PUSH
91036: LD_INT 1
91038: NEG
91039: PUSH
91040: LD_INT 0
91042: PUSH
91043: EMPTY
91044: LIST
91045: LIST
91046: PUSH
91047: LD_INT 1
91049: NEG
91050: PUSH
91051: LD_INT 1
91053: NEG
91054: PUSH
91055: EMPTY
91056: LIST
91057: LIST
91058: PUSH
91059: EMPTY
91060: LIST
91061: LIST
91062: LIST
91063: LIST
91064: LIST
91065: LIST
91066: LIST
91067: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91068: LD_ADDR_VAR 0 63
91072: PUSH
91073: LD_INT 0
91075: PUSH
91076: LD_INT 0
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: LD_INT 0
91085: PUSH
91086: LD_INT 1
91088: NEG
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: PUSH
91094: LD_INT 1
91096: PUSH
91097: LD_INT 0
91099: PUSH
91100: EMPTY
91101: LIST
91102: LIST
91103: PUSH
91104: LD_INT 1
91106: PUSH
91107: LD_INT 1
91109: PUSH
91110: EMPTY
91111: LIST
91112: LIST
91113: PUSH
91114: LD_INT 0
91116: PUSH
91117: LD_INT 1
91119: PUSH
91120: EMPTY
91121: LIST
91122: LIST
91123: PUSH
91124: LD_INT 1
91126: NEG
91127: PUSH
91128: LD_INT 0
91130: PUSH
91131: EMPTY
91132: LIST
91133: LIST
91134: PUSH
91135: LD_INT 1
91137: NEG
91138: PUSH
91139: LD_INT 1
91141: NEG
91142: PUSH
91143: EMPTY
91144: LIST
91145: LIST
91146: PUSH
91147: EMPTY
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: LIST
91154: LIST
91155: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
91156: LD_ADDR_VAR 0 64
91160: PUSH
91161: LD_INT 0
91163: PUSH
91164: LD_INT 0
91166: PUSH
91167: EMPTY
91168: LIST
91169: LIST
91170: PUSH
91171: LD_INT 0
91173: PUSH
91174: LD_INT 1
91176: NEG
91177: PUSH
91178: EMPTY
91179: LIST
91180: LIST
91181: PUSH
91182: LD_INT 1
91184: PUSH
91185: LD_INT 0
91187: PUSH
91188: EMPTY
91189: LIST
91190: LIST
91191: PUSH
91192: LD_INT 1
91194: PUSH
91195: LD_INT 1
91197: PUSH
91198: EMPTY
91199: LIST
91200: LIST
91201: PUSH
91202: LD_INT 0
91204: PUSH
91205: LD_INT 1
91207: PUSH
91208: EMPTY
91209: LIST
91210: LIST
91211: PUSH
91212: LD_INT 1
91214: NEG
91215: PUSH
91216: LD_INT 0
91218: PUSH
91219: EMPTY
91220: LIST
91221: LIST
91222: PUSH
91223: LD_INT 1
91225: NEG
91226: PUSH
91227: LD_INT 1
91229: NEG
91230: PUSH
91231: EMPTY
91232: LIST
91233: LIST
91234: PUSH
91235: EMPTY
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: ST_TO_ADDR
// end ; 1 :
91244: GO 97141
91246: LD_INT 1
91248: DOUBLE
91249: EQUAL
91250: IFTRUE 91254
91252: GO 93877
91254: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91255: LD_ADDR_VAR 0 11
91259: PUSH
91260: LD_INT 1
91262: NEG
91263: PUSH
91264: LD_INT 3
91266: NEG
91267: PUSH
91268: EMPTY
91269: LIST
91270: LIST
91271: PUSH
91272: LD_INT 0
91274: PUSH
91275: LD_INT 3
91277: NEG
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: PUSH
91283: LD_INT 1
91285: PUSH
91286: LD_INT 2
91288: NEG
91289: PUSH
91290: EMPTY
91291: LIST
91292: LIST
91293: PUSH
91294: EMPTY
91295: LIST
91296: LIST
91297: LIST
91298: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91299: LD_ADDR_VAR 0 12
91303: PUSH
91304: LD_INT 2
91306: PUSH
91307: LD_INT 1
91309: NEG
91310: PUSH
91311: EMPTY
91312: LIST
91313: LIST
91314: PUSH
91315: LD_INT 3
91317: PUSH
91318: LD_INT 0
91320: PUSH
91321: EMPTY
91322: LIST
91323: LIST
91324: PUSH
91325: LD_INT 3
91327: PUSH
91328: LD_INT 1
91330: PUSH
91331: EMPTY
91332: LIST
91333: LIST
91334: PUSH
91335: EMPTY
91336: LIST
91337: LIST
91338: LIST
91339: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91340: LD_ADDR_VAR 0 13
91344: PUSH
91345: LD_INT 3
91347: PUSH
91348: LD_INT 2
91350: PUSH
91351: EMPTY
91352: LIST
91353: LIST
91354: PUSH
91355: LD_INT 3
91357: PUSH
91358: LD_INT 3
91360: PUSH
91361: EMPTY
91362: LIST
91363: LIST
91364: PUSH
91365: LD_INT 2
91367: PUSH
91368: LD_INT 3
91370: PUSH
91371: EMPTY
91372: LIST
91373: LIST
91374: PUSH
91375: EMPTY
91376: LIST
91377: LIST
91378: LIST
91379: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91380: LD_ADDR_VAR 0 14
91384: PUSH
91385: LD_INT 1
91387: PUSH
91388: LD_INT 3
91390: PUSH
91391: EMPTY
91392: LIST
91393: LIST
91394: PUSH
91395: LD_INT 0
91397: PUSH
91398: LD_INT 3
91400: PUSH
91401: EMPTY
91402: LIST
91403: LIST
91404: PUSH
91405: LD_INT 1
91407: NEG
91408: PUSH
91409: LD_INT 2
91411: PUSH
91412: EMPTY
91413: LIST
91414: LIST
91415: PUSH
91416: EMPTY
91417: LIST
91418: LIST
91419: LIST
91420: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91421: LD_ADDR_VAR 0 15
91425: PUSH
91426: LD_INT 2
91428: NEG
91429: PUSH
91430: LD_INT 1
91432: PUSH
91433: EMPTY
91434: LIST
91435: LIST
91436: PUSH
91437: LD_INT 3
91439: NEG
91440: PUSH
91441: LD_INT 0
91443: PUSH
91444: EMPTY
91445: LIST
91446: LIST
91447: PUSH
91448: LD_INT 3
91450: NEG
91451: PUSH
91452: LD_INT 1
91454: NEG
91455: PUSH
91456: EMPTY
91457: LIST
91458: LIST
91459: PUSH
91460: EMPTY
91461: LIST
91462: LIST
91463: LIST
91464: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91465: LD_ADDR_VAR 0 16
91469: PUSH
91470: LD_INT 2
91472: NEG
91473: PUSH
91474: LD_INT 3
91476: NEG
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: PUSH
91482: LD_INT 3
91484: NEG
91485: PUSH
91486: LD_INT 2
91488: NEG
91489: PUSH
91490: EMPTY
91491: LIST
91492: LIST
91493: PUSH
91494: LD_INT 3
91496: NEG
91497: PUSH
91498: LD_INT 3
91500: NEG
91501: PUSH
91502: EMPTY
91503: LIST
91504: LIST
91505: PUSH
91506: EMPTY
91507: LIST
91508: LIST
91509: LIST
91510: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
91511: LD_ADDR_VAR 0 17
91515: PUSH
91516: LD_INT 1
91518: NEG
91519: PUSH
91520: LD_INT 3
91522: NEG
91523: PUSH
91524: EMPTY
91525: LIST
91526: LIST
91527: PUSH
91528: LD_INT 0
91530: PUSH
91531: LD_INT 3
91533: NEG
91534: PUSH
91535: EMPTY
91536: LIST
91537: LIST
91538: PUSH
91539: LD_INT 1
91541: PUSH
91542: LD_INT 2
91544: NEG
91545: PUSH
91546: EMPTY
91547: LIST
91548: LIST
91549: PUSH
91550: EMPTY
91551: LIST
91552: LIST
91553: LIST
91554: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
91555: LD_ADDR_VAR 0 18
91559: PUSH
91560: LD_INT 2
91562: PUSH
91563: LD_INT 1
91565: NEG
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: PUSH
91571: LD_INT 3
91573: PUSH
91574: LD_INT 0
91576: PUSH
91577: EMPTY
91578: LIST
91579: LIST
91580: PUSH
91581: LD_INT 3
91583: PUSH
91584: LD_INT 1
91586: PUSH
91587: EMPTY
91588: LIST
91589: LIST
91590: PUSH
91591: EMPTY
91592: LIST
91593: LIST
91594: LIST
91595: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
91596: LD_ADDR_VAR 0 19
91600: PUSH
91601: LD_INT 3
91603: PUSH
91604: LD_INT 2
91606: PUSH
91607: EMPTY
91608: LIST
91609: LIST
91610: PUSH
91611: LD_INT 3
91613: PUSH
91614: LD_INT 3
91616: PUSH
91617: EMPTY
91618: LIST
91619: LIST
91620: PUSH
91621: LD_INT 2
91623: PUSH
91624: LD_INT 3
91626: PUSH
91627: EMPTY
91628: LIST
91629: LIST
91630: PUSH
91631: EMPTY
91632: LIST
91633: LIST
91634: LIST
91635: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
91636: LD_ADDR_VAR 0 20
91640: PUSH
91641: LD_INT 1
91643: PUSH
91644: LD_INT 3
91646: PUSH
91647: EMPTY
91648: LIST
91649: LIST
91650: PUSH
91651: LD_INT 0
91653: PUSH
91654: LD_INT 3
91656: PUSH
91657: EMPTY
91658: LIST
91659: LIST
91660: PUSH
91661: LD_INT 1
91663: NEG
91664: PUSH
91665: LD_INT 2
91667: PUSH
91668: EMPTY
91669: LIST
91670: LIST
91671: PUSH
91672: EMPTY
91673: LIST
91674: LIST
91675: LIST
91676: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
91677: LD_ADDR_VAR 0 21
91681: PUSH
91682: LD_INT 2
91684: NEG
91685: PUSH
91686: LD_INT 1
91688: PUSH
91689: EMPTY
91690: LIST
91691: LIST
91692: PUSH
91693: LD_INT 3
91695: NEG
91696: PUSH
91697: LD_INT 0
91699: PUSH
91700: EMPTY
91701: LIST
91702: LIST
91703: PUSH
91704: LD_INT 3
91706: NEG
91707: PUSH
91708: LD_INT 1
91710: NEG
91711: PUSH
91712: EMPTY
91713: LIST
91714: LIST
91715: PUSH
91716: EMPTY
91717: LIST
91718: LIST
91719: LIST
91720: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
91721: LD_ADDR_VAR 0 22
91725: PUSH
91726: LD_INT 2
91728: NEG
91729: PUSH
91730: LD_INT 3
91732: NEG
91733: PUSH
91734: EMPTY
91735: LIST
91736: LIST
91737: PUSH
91738: LD_INT 3
91740: NEG
91741: PUSH
91742: LD_INT 2
91744: NEG
91745: PUSH
91746: EMPTY
91747: LIST
91748: LIST
91749: PUSH
91750: LD_INT 3
91752: NEG
91753: PUSH
91754: LD_INT 3
91756: NEG
91757: PUSH
91758: EMPTY
91759: LIST
91760: LIST
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: LIST
91766: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
91767: LD_ADDR_VAR 0 23
91771: PUSH
91772: LD_INT 0
91774: PUSH
91775: LD_INT 3
91777: NEG
91778: PUSH
91779: EMPTY
91780: LIST
91781: LIST
91782: PUSH
91783: LD_INT 1
91785: NEG
91786: PUSH
91787: LD_INT 4
91789: NEG
91790: PUSH
91791: EMPTY
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 1
91797: PUSH
91798: LD_INT 3
91800: NEG
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: EMPTY
91807: LIST
91808: LIST
91809: LIST
91810: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
91811: LD_ADDR_VAR 0 24
91815: PUSH
91816: LD_INT 3
91818: PUSH
91819: LD_INT 0
91821: PUSH
91822: EMPTY
91823: LIST
91824: LIST
91825: PUSH
91826: LD_INT 3
91828: PUSH
91829: LD_INT 1
91831: NEG
91832: PUSH
91833: EMPTY
91834: LIST
91835: LIST
91836: PUSH
91837: LD_INT 4
91839: PUSH
91840: LD_INT 1
91842: PUSH
91843: EMPTY
91844: LIST
91845: LIST
91846: PUSH
91847: EMPTY
91848: LIST
91849: LIST
91850: LIST
91851: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
91852: LD_ADDR_VAR 0 25
91856: PUSH
91857: LD_INT 3
91859: PUSH
91860: LD_INT 3
91862: PUSH
91863: EMPTY
91864: LIST
91865: LIST
91866: PUSH
91867: LD_INT 4
91869: PUSH
91870: LD_INT 3
91872: PUSH
91873: EMPTY
91874: LIST
91875: LIST
91876: PUSH
91877: LD_INT 3
91879: PUSH
91880: LD_INT 4
91882: PUSH
91883: EMPTY
91884: LIST
91885: LIST
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: LIST
91891: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
91892: LD_ADDR_VAR 0 26
91896: PUSH
91897: LD_INT 0
91899: PUSH
91900: LD_INT 3
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: PUSH
91907: LD_INT 1
91909: PUSH
91910: LD_INT 4
91912: PUSH
91913: EMPTY
91914: LIST
91915: LIST
91916: PUSH
91917: LD_INT 1
91919: NEG
91920: PUSH
91921: LD_INT 3
91923: PUSH
91924: EMPTY
91925: LIST
91926: LIST
91927: PUSH
91928: EMPTY
91929: LIST
91930: LIST
91931: LIST
91932: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
91933: LD_ADDR_VAR 0 27
91937: PUSH
91938: LD_INT 3
91940: NEG
91941: PUSH
91942: LD_INT 0
91944: PUSH
91945: EMPTY
91946: LIST
91947: LIST
91948: PUSH
91949: LD_INT 3
91951: NEG
91952: PUSH
91953: LD_INT 1
91955: PUSH
91956: EMPTY
91957: LIST
91958: LIST
91959: PUSH
91960: LD_INT 4
91962: NEG
91963: PUSH
91964: LD_INT 1
91966: NEG
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: LIST
91976: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
91977: LD_ADDR_VAR 0 28
91981: PUSH
91982: LD_INT 3
91984: NEG
91985: PUSH
91986: LD_INT 3
91988: NEG
91989: PUSH
91990: EMPTY
91991: LIST
91992: LIST
91993: PUSH
91994: LD_INT 3
91996: NEG
91997: PUSH
91998: LD_INT 4
92000: NEG
92001: PUSH
92002: EMPTY
92003: LIST
92004: LIST
92005: PUSH
92006: LD_INT 4
92008: NEG
92009: PUSH
92010: LD_INT 3
92012: NEG
92013: PUSH
92014: EMPTY
92015: LIST
92016: LIST
92017: PUSH
92018: EMPTY
92019: LIST
92020: LIST
92021: LIST
92022: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
92023: LD_ADDR_VAR 0 29
92027: PUSH
92028: LD_INT 1
92030: NEG
92031: PUSH
92032: LD_INT 3
92034: NEG
92035: PUSH
92036: EMPTY
92037: LIST
92038: LIST
92039: PUSH
92040: LD_INT 0
92042: PUSH
92043: LD_INT 3
92045: NEG
92046: PUSH
92047: EMPTY
92048: LIST
92049: LIST
92050: PUSH
92051: LD_INT 1
92053: PUSH
92054: LD_INT 2
92056: NEG
92057: PUSH
92058: EMPTY
92059: LIST
92060: LIST
92061: PUSH
92062: LD_INT 1
92064: NEG
92065: PUSH
92066: LD_INT 4
92068: NEG
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 0
92076: PUSH
92077: LD_INT 4
92079: NEG
92080: PUSH
92081: EMPTY
92082: LIST
92083: LIST
92084: PUSH
92085: LD_INT 1
92087: PUSH
92088: LD_INT 3
92090: NEG
92091: PUSH
92092: EMPTY
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 1
92098: NEG
92099: PUSH
92100: LD_INT 5
92102: NEG
92103: PUSH
92104: EMPTY
92105: LIST
92106: LIST
92107: PUSH
92108: LD_INT 0
92110: PUSH
92111: LD_INT 5
92113: NEG
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: PUSH
92119: LD_INT 1
92121: PUSH
92122: LD_INT 4
92124: NEG
92125: PUSH
92126: EMPTY
92127: LIST
92128: LIST
92129: PUSH
92130: LD_INT 1
92132: NEG
92133: PUSH
92134: LD_INT 6
92136: NEG
92137: PUSH
92138: EMPTY
92139: LIST
92140: LIST
92141: PUSH
92142: LD_INT 0
92144: PUSH
92145: LD_INT 6
92147: NEG
92148: PUSH
92149: EMPTY
92150: LIST
92151: LIST
92152: PUSH
92153: LD_INT 1
92155: PUSH
92156: LD_INT 5
92158: NEG
92159: PUSH
92160: EMPTY
92161: LIST
92162: LIST
92163: PUSH
92164: EMPTY
92165: LIST
92166: LIST
92167: LIST
92168: LIST
92169: LIST
92170: LIST
92171: LIST
92172: LIST
92173: LIST
92174: LIST
92175: LIST
92176: LIST
92177: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
92178: LD_ADDR_VAR 0 30
92182: PUSH
92183: LD_INT 2
92185: PUSH
92186: LD_INT 1
92188: NEG
92189: PUSH
92190: EMPTY
92191: LIST
92192: LIST
92193: PUSH
92194: LD_INT 3
92196: PUSH
92197: LD_INT 0
92199: PUSH
92200: EMPTY
92201: LIST
92202: LIST
92203: PUSH
92204: LD_INT 3
92206: PUSH
92207: LD_INT 1
92209: PUSH
92210: EMPTY
92211: LIST
92212: LIST
92213: PUSH
92214: LD_INT 3
92216: PUSH
92217: LD_INT 1
92219: NEG
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: PUSH
92225: LD_INT 4
92227: PUSH
92228: LD_INT 0
92230: PUSH
92231: EMPTY
92232: LIST
92233: LIST
92234: PUSH
92235: LD_INT 4
92237: PUSH
92238: LD_INT 1
92240: PUSH
92241: EMPTY
92242: LIST
92243: LIST
92244: PUSH
92245: LD_INT 4
92247: PUSH
92248: LD_INT 1
92250: NEG
92251: PUSH
92252: EMPTY
92253: LIST
92254: LIST
92255: PUSH
92256: LD_INT 5
92258: PUSH
92259: LD_INT 0
92261: PUSH
92262: EMPTY
92263: LIST
92264: LIST
92265: PUSH
92266: LD_INT 5
92268: PUSH
92269: LD_INT 1
92271: PUSH
92272: EMPTY
92273: LIST
92274: LIST
92275: PUSH
92276: LD_INT 5
92278: PUSH
92279: LD_INT 1
92281: NEG
92282: PUSH
92283: EMPTY
92284: LIST
92285: LIST
92286: PUSH
92287: LD_INT 6
92289: PUSH
92290: LD_INT 0
92292: PUSH
92293: EMPTY
92294: LIST
92295: LIST
92296: PUSH
92297: LD_INT 6
92299: PUSH
92300: LD_INT 1
92302: PUSH
92303: EMPTY
92304: LIST
92305: LIST
92306: PUSH
92307: EMPTY
92308: LIST
92309: LIST
92310: LIST
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
92321: LD_ADDR_VAR 0 31
92325: PUSH
92326: LD_INT 3
92328: PUSH
92329: LD_INT 2
92331: PUSH
92332: EMPTY
92333: LIST
92334: LIST
92335: PUSH
92336: LD_INT 3
92338: PUSH
92339: LD_INT 3
92341: PUSH
92342: EMPTY
92343: LIST
92344: LIST
92345: PUSH
92346: LD_INT 2
92348: PUSH
92349: LD_INT 3
92351: PUSH
92352: EMPTY
92353: LIST
92354: LIST
92355: PUSH
92356: LD_INT 4
92358: PUSH
92359: LD_INT 3
92361: PUSH
92362: EMPTY
92363: LIST
92364: LIST
92365: PUSH
92366: LD_INT 4
92368: PUSH
92369: LD_INT 4
92371: PUSH
92372: EMPTY
92373: LIST
92374: LIST
92375: PUSH
92376: LD_INT 3
92378: PUSH
92379: LD_INT 4
92381: PUSH
92382: EMPTY
92383: LIST
92384: LIST
92385: PUSH
92386: LD_INT 5
92388: PUSH
92389: LD_INT 4
92391: PUSH
92392: EMPTY
92393: LIST
92394: LIST
92395: PUSH
92396: LD_INT 5
92398: PUSH
92399: LD_INT 5
92401: PUSH
92402: EMPTY
92403: LIST
92404: LIST
92405: PUSH
92406: LD_INT 4
92408: PUSH
92409: LD_INT 5
92411: PUSH
92412: EMPTY
92413: LIST
92414: LIST
92415: PUSH
92416: LD_INT 6
92418: PUSH
92419: LD_INT 5
92421: PUSH
92422: EMPTY
92423: LIST
92424: LIST
92425: PUSH
92426: LD_INT 6
92428: PUSH
92429: LD_INT 6
92431: PUSH
92432: EMPTY
92433: LIST
92434: LIST
92435: PUSH
92436: LD_INT 5
92438: PUSH
92439: LD_INT 6
92441: PUSH
92442: EMPTY
92443: LIST
92444: LIST
92445: PUSH
92446: EMPTY
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: LIST
92453: LIST
92454: LIST
92455: LIST
92456: LIST
92457: LIST
92458: LIST
92459: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
92460: LD_ADDR_VAR 0 32
92464: PUSH
92465: LD_INT 1
92467: PUSH
92468: LD_INT 3
92470: PUSH
92471: EMPTY
92472: LIST
92473: LIST
92474: PUSH
92475: LD_INT 0
92477: PUSH
92478: LD_INT 3
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: PUSH
92485: LD_INT 1
92487: NEG
92488: PUSH
92489: LD_INT 2
92491: PUSH
92492: EMPTY
92493: LIST
92494: LIST
92495: PUSH
92496: LD_INT 1
92498: PUSH
92499: LD_INT 4
92501: PUSH
92502: EMPTY
92503: LIST
92504: LIST
92505: PUSH
92506: LD_INT 0
92508: PUSH
92509: LD_INT 4
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: LD_INT 1
92518: NEG
92519: PUSH
92520: LD_INT 3
92522: PUSH
92523: EMPTY
92524: LIST
92525: LIST
92526: PUSH
92527: LD_INT 1
92529: PUSH
92530: LD_INT 5
92532: PUSH
92533: EMPTY
92534: LIST
92535: LIST
92536: PUSH
92537: LD_INT 0
92539: PUSH
92540: LD_INT 5
92542: PUSH
92543: EMPTY
92544: LIST
92545: LIST
92546: PUSH
92547: LD_INT 1
92549: NEG
92550: PUSH
92551: LD_INT 4
92553: PUSH
92554: EMPTY
92555: LIST
92556: LIST
92557: PUSH
92558: LD_INT 1
92560: PUSH
92561: LD_INT 6
92563: PUSH
92564: EMPTY
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 0
92570: PUSH
92571: LD_INT 6
92573: PUSH
92574: EMPTY
92575: LIST
92576: LIST
92577: PUSH
92578: LD_INT 1
92580: NEG
92581: PUSH
92582: LD_INT 5
92584: PUSH
92585: EMPTY
92586: LIST
92587: LIST
92588: PUSH
92589: EMPTY
92590: LIST
92591: LIST
92592: LIST
92593: LIST
92594: LIST
92595: LIST
92596: LIST
92597: LIST
92598: LIST
92599: LIST
92600: LIST
92601: LIST
92602: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
92603: LD_ADDR_VAR 0 33
92607: PUSH
92608: LD_INT 2
92610: NEG
92611: PUSH
92612: LD_INT 1
92614: PUSH
92615: EMPTY
92616: LIST
92617: LIST
92618: PUSH
92619: LD_INT 3
92621: NEG
92622: PUSH
92623: LD_INT 0
92625: PUSH
92626: EMPTY
92627: LIST
92628: LIST
92629: PUSH
92630: LD_INT 3
92632: NEG
92633: PUSH
92634: LD_INT 1
92636: NEG
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: LD_INT 3
92644: NEG
92645: PUSH
92646: LD_INT 1
92648: PUSH
92649: EMPTY
92650: LIST
92651: LIST
92652: PUSH
92653: LD_INT 4
92655: NEG
92656: PUSH
92657: LD_INT 0
92659: PUSH
92660: EMPTY
92661: LIST
92662: LIST
92663: PUSH
92664: LD_INT 4
92666: NEG
92667: PUSH
92668: LD_INT 1
92670: NEG
92671: PUSH
92672: EMPTY
92673: LIST
92674: LIST
92675: PUSH
92676: LD_INT 4
92678: NEG
92679: PUSH
92680: LD_INT 1
92682: PUSH
92683: EMPTY
92684: LIST
92685: LIST
92686: PUSH
92687: LD_INT 5
92689: NEG
92690: PUSH
92691: LD_INT 0
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: LD_INT 5
92700: NEG
92701: PUSH
92702: LD_INT 1
92704: NEG
92705: PUSH
92706: EMPTY
92707: LIST
92708: LIST
92709: PUSH
92710: LD_INT 5
92712: NEG
92713: PUSH
92714: LD_INT 1
92716: PUSH
92717: EMPTY
92718: LIST
92719: LIST
92720: PUSH
92721: LD_INT 6
92723: NEG
92724: PUSH
92725: LD_INT 0
92727: PUSH
92728: EMPTY
92729: LIST
92730: LIST
92731: PUSH
92732: LD_INT 6
92734: NEG
92735: PUSH
92736: LD_INT 1
92738: NEG
92739: PUSH
92740: EMPTY
92741: LIST
92742: LIST
92743: PUSH
92744: EMPTY
92745: LIST
92746: LIST
92747: LIST
92748: LIST
92749: LIST
92750: LIST
92751: LIST
92752: LIST
92753: LIST
92754: LIST
92755: LIST
92756: LIST
92757: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
92758: LD_ADDR_VAR 0 34
92762: PUSH
92763: LD_INT 2
92765: NEG
92766: PUSH
92767: LD_INT 3
92769: NEG
92770: PUSH
92771: EMPTY
92772: LIST
92773: LIST
92774: PUSH
92775: LD_INT 3
92777: NEG
92778: PUSH
92779: LD_INT 2
92781: NEG
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: PUSH
92787: LD_INT 3
92789: NEG
92790: PUSH
92791: LD_INT 3
92793: NEG
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: PUSH
92799: LD_INT 3
92801: NEG
92802: PUSH
92803: LD_INT 4
92805: NEG
92806: PUSH
92807: EMPTY
92808: LIST
92809: LIST
92810: PUSH
92811: LD_INT 4
92813: NEG
92814: PUSH
92815: LD_INT 3
92817: NEG
92818: PUSH
92819: EMPTY
92820: LIST
92821: LIST
92822: PUSH
92823: LD_INT 4
92825: NEG
92826: PUSH
92827: LD_INT 4
92829: NEG
92830: PUSH
92831: EMPTY
92832: LIST
92833: LIST
92834: PUSH
92835: LD_INT 4
92837: NEG
92838: PUSH
92839: LD_INT 5
92841: NEG
92842: PUSH
92843: EMPTY
92844: LIST
92845: LIST
92846: PUSH
92847: LD_INT 5
92849: NEG
92850: PUSH
92851: LD_INT 4
92853: NEG
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: LD_INT 5
92861: NEG
92862: PUSH
92863: LD_INT 5
92865: NEG
92866: PUSH
92867: EMPTY
92868: LIST
92869: LIST
92870: PUSH
92871: LD_INT 5
92873: NEG
92874: PUSH
92875: LD_INT 6
92877: NEG
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 6
92885: NEG
92886: PUSH
92887: LD_INT 5
92889: NEG
92890: PUSH
92891: EMPTY
92892: LIST
92893: LIST
92894: PUSH
92895: LD_INT 6
92897: NEG
92898: PUSH
92899: LD_INT 6
92901: NEG
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: PUSH
92907: EMPTY
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
92921: LD_ADDR_VAR 0 41
92925: PUSH
92926: LD_INT 0
92928: PUSH
92929: LD_INT 2
92931: NEG
92932: PUSH
92933: EMPTY
92934: LIST
92935: LIST
92936: PUSH
92937: LD_INT 1
92939: NEG
92940: PUSH
92941: LD_INT 3
92943: NEG
92944: PUSH
92945: EMPTY
92946: LIST
92947: LIST
92948: PUSH
92949: LD_INT 1
92951: PUSH
92952: LD_INT 2
92954: NEG
92955: PUSH
92956: EMPTY
92957: LIST
92958: LIST
92959: PUSH
92960: EMPTY
92961: LIST
92962: LIST
92963: LIST
92964: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
92965: LD_ADDR_VAR 0 42
92969: PUSH
92970: LD_INT 2
92972: PUSH
92973: LD_INT 0
92975: PUSH
92976: EMPTY
92977: LIST
92978: LIST
92979: PUSH
92980: LD_INT 2
92982: PUSH
92983: LD_INT 1
92985: NEG
92986: PUSH
92987: EMPTY
92988: LIST
92989: LIST
92990: PUSH
92991: LD_INT 3
92993: PUSH
92994: LD_INT 1
92996: PUSH
92997: EMPTY
92998: LIST
92999: LIST
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: LIST
93005: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
93006: LD_ADDR_VAR 0 43
93010: PUSH
93011: LD_INT 2
93013: PUSH
93014: LD_INT 2
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: PUSH
93021: LD_INT 3
93023: PUSH
93024: LD_INT 2
93026: PUSH
93027: EMPTY
93028: LIST
93029: LIST
93030: PUSH
93031: LD_INT 2
93033: PUSH
93034: LD_INT 3
93036: PUSH
93037: EMPTY
93038: LIST
93039: LIST
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: LIST
93045: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
93046: LD_ADDR_VAR 0 44
93050: PUSH
93051: LD_INT 0
93053: PUSH
93054: LD_INT 2
93056: PUSH
93057: EMPTY
93058: LIST
93059: LIST
93060: PUSH
93061: LD_INT 1
93063: PUSH
93064: LD_INT 3
93066: PUSH
93067: EMPTY
93068: LIST
93069: LIST
93070: PUSH
93071: LD_INT 1
93073: NEG
93074: PUSH
93075: LD_INT 2
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: EMPTY
93083: LIST
93084: LIST
93085: LIST
93086: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
93087: LD_ADDR_VAR 0 45
93091: PUSH
93092: LD_INT 2
93094: NEG
93095: PUSH
93096: LD_INT 0
93098: PUSH
93099: EMPTY
93100: LIST
93101: LIST
93102: PUSH
93103: LD_INT 2
93105: NEG
93106: PUSH
93107: LD_INT 1
93109: PUSH
93110: EMPTY
93111: LIST
93112: LIST
93113: PUSH
93114: LD_INT 3
93116: NEG
93117: PUSH
93118: LD_INT 1
93120: NEG
93121: PUSH
93122: EMPTY
93123: LIST
93124: LIST
93125: PUSH
93126: EMPTY
93127: LIST
93128: LIST
93129: LIST
93130: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
93131: LD_ADDR_VAR 0 46
93135: PUSH
93136: LD_INT 2
93138: NEG
93139: PUSH
93140: LD_INT 2
93142: NEG
93143: PUSH
93144: EMPTY
93145: LIST
93146: LIST
93147: PUSH
93148: LD_INT 2
93150: NEG
93151: PUSH
93152: LD_INT 3
93154: NEG
93155: PUSH
93156: EMPTY
93157: LIST
93158: LIST
93159: PUSH
93160: LD_INT 3
93162: NEG
93163: PUSH
93164: LD_INT 2
93166: NEG
93167: PUSH
93168: EMPTY
93169: LIST
93170: LIST
93171: PUSH
93172: EMPTY
93173: LIST
93174: LIST
93175: LIST
93176: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
93177: LD_ADDR_VAR 0 47
93181: PUSH
93182: LD_INT 2
93184: NEG
93185: PUSH
93186: LD_INT 3
93188: NEG
93189: PUSH
93190: EMPTY
93191: LIST
93192: LIST
93193: PUSH
93194: LD_INT 1
93196: NEG
93197: PUSH
93198: LD_INT 3
93200: NEG
93201: PUSH
93202: EMPTY
93203: LIST
93204: LIST
93205: PUSH
93206: EMPTY
93207: LIST
93208: LIST
93209: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
93210: LD_ADDR_VAR 0 48
93214: PUSH
93215: LD_INT 1
93217: PUSH
93218: LD_INT 2
93220: NEG
93221: PUSH
93222: EMPTY
93223: LIST
93224: LIST
93225: PUSH
93226: LD_INT 2
93228: PUSH
93229: LD_INT 1
93231: NEG
93232: PUSH
93233: EMPTY
93234: LIST
93235: LIST
93236: PUSH
93237: EMPTY
93238: LIST
93239: LIST
93240: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
93241: LD_ADDR_VAR 0 49
93245: PUSH
93246: LD_INT 3
93248: PUSH
93249: LD_INT 1
93251: PUSH
93252: EMPTY
93253: LIST
93254: LIST
93255: PUSH
93256: LD_INT 3
93258: PUSH
93259: LD_INT 2
93261: PUSH
93262: EMPTY
93263: LIST
93264: LIST
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
93270: LD_ADDR_VAR 0 50
93274: PUSH
93275: LD_INT 2
93277: PUSH
93278: LD_INT 3
93280: PUSH
93281: EMPTY
93282: LIST
93283: LIST
93284: PUSH
93285: LD_INT 1
93287: PUSH
93288: LD_INT 3
93290: PUSH
93291: EMPTY
93292: LIST
93293: LIST
93294: PUSH
93295: EMPTY
93296: LIST
93297: LIST
93298: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
93299: LD_ADDR_VAR 0 51
93303: PUSH
93304: LD_INT 1
93306: NEG
93307: PUSH
93308: LD_INT 2
93310: PUSH
93311: EMPTY
93312: LIST
93313: LIST
93314: PUSH
93315: LD_INT 2
93317: NEG
93318: PUSH
93319: LD_INT 1
93321: PUSH
93322: EMPTY
93323: LIST
93324: LIST
93325: PUSH
93326: EMPTY
93327: LIST
93328: LIST
93329: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
93330: LD_ADDR_VAR 0 52
93334: PUSH
93335: LD_INT 3
93337: NEG
93338: PUSH
93339: LD_INT 1
93341: NEG
93342: PUSH
93343: EMPTY
93344: LIST
93345: LIST
93346: PUSH
93347: LD_INT 3
93349: NEG
93350: PUSH
93351: LD_INT 2
93353: NEG
93354: PUSH
93355: EMPTY
93356: LIST
93357: LIST
93358: PUSH
93359: EMPTY
93360: LIST
93361: LIST
93362: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
93363: LD_ADDR_VAR 0 53
93367: PUSH
93368: LD_INT 1
93370: NEG
93371: PUSH
93372: LD_INT 3
93374: NEG
93375: PUSH
93376: EMPTY
93377: LIST
93378: LIST
93379: PUSH
93380: LD_INT 0
93382: PUSH
93383: LD_INT 3
93385: NEG
93386: PUSH
93387: EMPTY
93388: LIST
93389: LIST
93390: PUSH
93391: LD_INT 1
93393: PUSH
93394: LD_INT 2
93396: NEG
93397: PUSH
93398: EMPTY
93399: LIST
93400: LIST
93401: PUSH
93402: EMPTY
93403: LIST
93404: LIST
93405: LIST
93406: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
93407: LD_ADDR_VAR 0 54
93411: PUSH
93412: LD_INT 2
93414: PUSH
93415: LD_INT 1
93417: NEG
93418: PUSH
93419: EMPTY
93420: LIST
93421: LIST
93422: PUSH
93423: LD_INT 3
93425: PUSH
93426: LD_INT 0
93428: PUSH
93429: EMPTY
93430: LIST
93431: LIST
93432: PUSH
93433: LD_INT 3
93435: PUSH
93436: LD_INT 1
93438: PUSH
93439: EMPTY
93440: LIST
93441: LIST
93442: PUSH
93443: EMPTY
93444: LIST
93445: LIST
93446: LIST
93447: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
93448: LD_ADDR_VAR 0 55
93452: PUSH
93453: LD_INT 3
93455: PUSH
93456: LD_INT 2
93458: PUSH
93459: EMPTY
93460: LIST
93461: LIST
93462: PUSH
93463: LD_INT 3
93465: PUSH
93466: LD_INT 3
93468: PUSH
93469: EMPTY
93470: LIST
93471: LIST
93472: PUSH
93473: LD_INT 2
93475: PUSH
93476: LD_INT 3
93478: PUSH
93479: EMPTY
93480: LIST
93481: LIST
93482: PUSH
93483: EMPTY
93484: LIST
93485: LIST
93486: LIST
93487: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
93488: LD_ADDR_VAR 0 56
93492: PUSH
93493: LD_INT 1
93495: PUSH
93496: LD_INT 3
93498: PUSH
93499: EMPTY
93500: LIST
93501: LIST
93502: PUSH
93503: LD_INT 0
93505: PUSH
93506: LD_INT 3
93508: PUSH
93509: EMPTY
93510: LIST
93511: LIST
93512: PUSH
93513: LD_INT 1
93515: NEG
93516: PUSH
93517: LD_INT 2
93519: PUSH
93520: EMPTY
93521: LIST
93522: LIST
93523: PUSH
93524: EMPTY
93525: LIST
93526: LIST
93527: LIST
93528: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
93529: LD_ADDR_VAR 0 57
93533: PUSH
93534: LD_INT 2
93536: NEG
93537: PUSH
93538: LD_INT 1
93540: PUSH
93541: EMPTY
93542: LIST
93543: LIST
93544: PUSH
93545: LD_INT 3
93547: NEG
93548: PUSH
93549: LD_INT 0
93551: PUSH
93552: EMPTY
93553: LIST
93554: LIST
93555: PUSH
93556: LD_INT 3
93558: NEG
93559: PUSH
93560: LD_INT 1
93562: NEG
93563: PUSH
93564: EMPTY
93565: LIST
93566: LIST
93567: PUSH
93568: EMPTY
93569: LIST
93570: LIST
93571: LIST
93572: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
93573: LD_ADDR_VAR 0 58
93577: PUSH
93578: LD_INT 2
93580: NEG
93581: PUSH
93582: LD_INT 3
93584: NEG
93585: PUSH
93586: EMPTY
93587: LIST
93588: LIST
93589: PUSH
93590: LD_INT 3
93592: NEG
93593: PUSH
93594: LD_INT 2
93596: NEG
93597: PUSH
93598: EMPTY
93599: LIST
93600: LIST
93601: PUSH
93602: LD_INT 3
93604: NEG
93605: PUSH
93606: LD_INT 3
93608: NEG
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: PUSH
93614: EMPTY
93615: LIST
93616: LIST
93617: LIST
93618: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
93619: LD_ADDR_VAR 0 59
93623: PUSH
93624: LD_INT 1
93626: NEG
93627: PUSH
93628: LD_INT 2
93630: NEG
93631: PUSH
93632: EMPTY
93633: LIST
93634: LIST
93635: PUSH
93636: LD_INT 0
93638: PUSH
93639: LD_INT 2
93641: NEG
93642: PUSH
93643: EMPTY
93644: LIST
93645: LIST
93646: PUSH
93647: LD_INT 1
93649: PUSH
93650: LD_INT 1
93652: NEG
93653: PUSH
93654: EMPTY
93655: LIST
93656: LIST
93657: PUSH
93658: EMPTY
93659: LIST
93660: LIST
93661: LIST
93662: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
93663: LD_ADDR_VAR 0 60
93667: PUSH
93668: LD_INT 1
93670: PUSH
93671: LD_INT 1
93673: NEG
93674: PUSH
93675: EMPTY
93676: LIST
93677: LIST
93678: PUSH
93679: LD_INT 2
93681: PUSH
93682: LD_INT 0
93684: PUSH
93685: EMPTY
93686: LIST
93687: LIST
93688: PUSH
93689: LD_INT 2
93691: PUSH
93692: LD_INT 1
93694: PUSH
93695: EMPTY
93696: LIST
93697: LIST
93698: PUSH
93699: EMPTY
93700: LIST
93701: LIST
93702: LIST
93703: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
93704: LD_ADDR_VAR 0 61
93708: PUSH
93709: LD_INT 2
93711: PUSH
93712: LD_INT 1
93714: PUSH
93715: EMPTY
93716: LIST
93717: LIST
93718: PUSH
93719: LD_INT 2
93721: PUSH
93722: LD_INT 2
93724: PUSH
93725: EMPTY
93726: LIST
93727: LIST
93728: PUSH
93729: LD_INT 1
93731: PUSH
93732: LD_INT 2
93734: PUSH
93735: EMPTY
93736: LIST
93737: LIST
93738: PUSH
93739: EMPTY
93740: LIST
93741: LIST
93742: LIST
93743: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
93744: LD_ADDR_VAR 0 62
93748: PUSH
93749: LD_INT 1
93751: PUSH
93752: LD_INT 2
93754: PUSH
93755: EMPTY
93756: LIST
93757: LIST
93758: PUSH
93759: LD_INT 0
93761: PUSH
93762: LD_INT 2
93764: PUSH
93765: EMPTY
93766: LIST
93767: LIST
93768: PUSH
93769: LD_INT 1
93771: NEG
93772: PUSH
93773: LD_INT 1
93775: PUSH
93776: EMPTY
93777: LIST
93778: LIST
93779: PUSH
93780: EMPTY
93781: LIST
93782: LIST
93783: LIST
93784: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
93785: LD_ADDR_VAR 0 63
93789: PUSH
93790: LD_INT 1
93792: NEG
93793: PUSH
93794: LD_INT 1
93796: PUSH
93797: EMPTY
93798: LIST
93799: LIST
93800: PUSH
93801: LD_INT 2
93803: NEG
93804: PUSH
93805: LD_INT 0
93807: PUSH
93808: EMPTY
93809: LIST
93810: LIST
93811: PUSH
93812: LD_INT 2
93814: NEG
93815: PUSH
93816: LD_INT 1
93818: NEG
93819: PUSH
93820: EMPTY
93821: LIST
93822: LIST
93823: PUSH
93824: EMPTY
93825: LIST
93826: LIST
93827: LIST
93828: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
93829: LD_ADDR_VAR 0 64
93833: PUSH
93834: LD_INT 1
93836: NEG
93837: PUSH
93838: LD_INT 2
93840: NEG
93841: PUSH
93842: EMPTY
93843: LIST
93844: LIST
93845: PUSH
93846: LD_INT 2
93848: NEG
93849: PUSH
93850: LD_INT 1
93852: NEG
93853: PUSH
93854: EMPTY
93855: LIST
93856: LIST
93857: PUSH
93858: LD_INT 2
93860: NEG
93861: PUSH
93862: LD_INT 2
93864: NEG
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: EMPTY
93871: LIST
93872: LIST
93873: LIST
93874: ST_TO_ADDR
// end ; 2 :
93875: GO 97141
93877: LD_INT 2
93879: DOUBLE
93880: EQUAL
93881: IFTRUE 93885
93883: GO 97140
93885: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
93886: LD_ADDR_VAR 0 29
93890: PUSH
93891: LD_INT 4
93893: PUSH
93894: LD_INT 0
93896: PUSH
93897: EMPTY
93898: LIST
93899: LIST
93900: PUSH
93901: LD_INT 4
93903: PUSH
93904: LD_INT 1
93906: NEG
93907: PUSH
93908: EMPTY
93909: LIST
93910: LIST
93911: PUSH
93912: LD_INT 5
93914: PUSH
93915: LD_INT 0
93917: PUSH
93918: EMPTY
93919: LIST
93920: LIST
93921: PUSH
93922: LD_INT 5
93924: PUSH
93925: LD_INT 1
93927: PUSH
93928: EMPTY
93929: LIST
93930: LIST
93931: PUSH
93932: LD_INT 4
93934: PUSH
93935: LD_INT 1
93937: PUSH
93938: EMPTY
93939: LIST
93940: LIST
93941: PUSH
93942: LD_INT 3
93944: PUSH
93945: LD_INT 0
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PUSH
93952: LD_INT 3
93954: PUSH
93955: LD_INT 1
93957: NEG
93958: PUSH
93959: EMPTY
93960: LIST
93961: LIST
93962: PUSH
93963: LD_INT 3
93965: PUSH
93966: LD_INT 2
93968: NEG
93969: PUSH
93970: EMPTY
93971: LIST
93972: LIST
93973: PUSH
93974: LD_INT 5
93976: PUSH
93977: LD_INT 2
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: LD_INT 3
93986: PUSH
93987: LD_INT 3
93989: PUSH
93990: EMPTY
93991: LIST
93992: LIST
93993: PUSH
93994: LD_INT 3
93996: PUSH
93997: LD_INT 2
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: PUSH
94004: LD_INT 4
94006: PUSH
94007: LD_INT 3
94009: PUSH
94010: EMPTY
94011: LIST
94012: LIST
94013: PUSH
94014: LD_INT 4
94016: PUSH
94017: LD_INT 4
94019: PUSH
94020: EMPTY
94021: LIST
94022: LIST
94023: PUSH
94024: LD_INT 3
94026: PUSH
94027: LD_INT 4
94029: PUSH
94030: EMPTY
94031: LIST
94032: LIST
94033: PUSH
94034: LD_INT 2
94036: PUSH
94037: LD_INT 3
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PUSH
94044: LD_INT 2
94046: PUSH
94047: LD_INT 2
94049: PUSH
94050: EMPTY
94051: LIST
94052: LIST
94053: PUSH
94054: LD_INT 4
94056: PUSH
94057: LD_INT 2
94059: PUSH
94060: EMPTY
94061: LIST
94062: LIST
94063: PUSH
94064: LD_INT 2
94066: PUSH
94067: LD_INT 4
94069: PUSH
94070: EMPTY
94071: LIST
94072: LIST
94073: PUSH
94074: LD_INT 0
94076: PUSH
94077: LD_INT 4
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PUSH
94084: LD_INT 0
94086: PUSH
94087: LD_INT 3
94089: PUSH
94090: EMPTY
94091: LIST
94092: LIST
94093: PUSH
94094: LD_INT 1
94096: PUSH
94097: LD_INT 4
94099: PUSH
94100: EMPTY
94101: LIST
94102: LIST
94103: PUSH
94104: LD_INT 1
94106: PUSH
94107: LD_INT 5
94109: PUSH
94110: EMPTY
94111: LIST
94112: LIST
94113: PUSH
94114: LD_INT 0
94116: PUSH
94117: LD_INT 5
94119: PUSH
94120: EMPTY
94121: LIST
94122: LIST
94123: PUSH
94124: LD_INT 1
94126: NEG
94127: PUSH
94128: LD_INT 4
94130: PUSH
94131: EMPTY
94132: LIST
94133: LIST
94134: PUSH
94135: LD_INT 1
94137: NEG
94138: PUSH
94139: LD_INT 3
94141: PUSH
94142: EMPTY
94143: LIST
94144: LIST
94145: PUSH
94146: LD_INT 2
94148: PUSH
94149: LD_INT 5
94151: PUSH
94152: EMPTY
94153: LIST
94154: LIST
94155: PUSH
94156: LD_INT 2
94158: NEG
94159: PUSH
94160: LD_INT 3
94162: PUSH
94163: EMPTY
94164: LIST
94165: LIST
94166: PUSH
94167: LD_INT 3
94169: NEG
94170: PUSH
94171: LD_INT 0
94173: PUSH
94174: EMPTY
94175: LIST
94176: LIST
94177: PUSH
94178: LD_INT 3
94180: NEG
94181: PUSH
94182: LD_INT 1
94184: NEG
94185: PUSH
94186: EMPTY
94187: LIST
94188: LIST
94189: PUSH
94190: LD_INT 2
94192: NEG
94193: PUSH
94194: LD_INT 0
94196: PUSH
94197: EMPTY
94198: LIST
94199: LIST
94200: PUSH
94201: LD_INT 2
94203: NEG
94204: PUSH
94205: LD_INT 1
94207: PUSH
94208: EMPTY
94209: LIST
94210: LIST
94211: PUSH
94212: LD_INT 3
94214: NEG
94215: PUSH
94216: LD_INT 1
94218: PUSH
94219: EMPTY
94220: LIST
94221: LIST
94222: PUSH
94223: LD_INT 4
94225: NEG
94226: PUSH
94227: LD_INT 0
94229: PUSH
94230: EMPTY
94231: LIST
94232: LIST
94233: PUSH
94234: LD_INT 4
94236: NEG
94237: PUSH
94238: LD_INT 1
94240: NEG
94241: PUSH
94242: EMPTY
94243: LIST
94244: LIST
94245: PUSH
94246: LD_INT 4
94248: NEG
94249: PUSH
94250: LD_INT 2
94252: NEG
94253: PUSH
94254: EMPTY
94255: LIST
94256: LIST
94257: PUSH
94258: LD_INT 2
94260: NEG
94261: PUSH
94262: LD_INT 2
94264: PUSH
94265: EMPTY
94266: LIST
94267: LIST
94268: PUSH
94269: LD_INT 4
94271: NEG
94272: PUSH
94273: LD_INT 4
94275: NEG
94276: PUSH
94277: EMPTY
94278: LIST
94279: LIST
94280: PUSH
94281: LD_INT 4
94283: NEG
94284: PUSH
94285: LD_INT 5
94287: NEG
94288: PUSH
94289: EMPTY
94290: LIST
94291: LIST
94292: PUSH
94293: LD_INT 3
94295: NEG
94296: PUSH
94297: LD_INT 4
94299: NEG
94300: PUSH
94301: EMPTY
94302: LIST
94303: LIST
94304: PUSH
94305: LD_INT 3
94307: NEG
94308: PUSH
94309: LD_INT 3
94311: NEG
94312: PUSH
94313: EMPTY
94314: LIST
94315: LIST
94316: PUSH
94317: LD_INT 4
94319: NEG
94320: PUSH
94321: LD_INT 3
94323: NEG
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: PUSH
94329: LD_INT 5
94331: NEG
94332: PUSH
94333: LD_INT 4
94335: NEG
94336: PUSH
94337: EMPTY
94338: LIST
94339: LIST
94340: PUSH
94341: LD_INT 5
94343: NEG
94344: PUSH
94345: LD_INT 5
94347: NEG
94348: PUSH
94349: EMPTY
94350: LIST
94351: LIST
94352: PUSH
94353: LD_INT 3
94355: NEG
94356: PUSH
94357: LD_INT 5
94359: NEG
94360: PUSH
94361: EMPTY
94362: LIST
94363: LIST
94364: PUSH
94365: LD_INT 5
94367: NEG
94368: PUSH
94369: LD_INT 3
94371: NEG
94372: PUSH
94373: EMPTY
94374: LIST
94375: LIST
94376: PUSH
94377: EMPTY
94378: LIST
94379: LIST
94380: LIST
94381: LIST
94382: LIST
94383: LIST
94384: LIST
94385: LIST
94386: LIST
94387: LIST
94388: LIST
94389: LIST
94390: LIST
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
94424: LD_ADDR_VAR 0 30
94428: PUSH
94429: LD_INT 4
94431: PUSH
94432: LD_INT 4
94434: PUSH
94435: EMPTY
94436: LIST
94437: LIST
94438: PUSH
94439: LD_INT 4
94441: PUSH
94442: LD_INT 3
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PUSH
94449: LD_INT 5
94451: PUSH
94452: LD_INT 4
94454: PUSH
94455: EMPTY
94456: LIST
94457: LIST
94458: PUSH
94459: LD_INT 5
94461: PUSH
94462: LD_INT 5
94464: PUSH
94465: EMPTY
94466: LIST
94467: LIST
94468: PUSH
94469: LD_INT 4
94471: PUSH
94472: LD_INT 5
94474: PUSH
94475: EMPTY
94476: LIST
94477: LIST
94478: PUSH
94479: LD_INT 3
94481: PUSH
94482: LD_INT 4
94484: PUSH
94485: EMPTY
94486: LIST
94487: LIST
94488: PUSH
94489: LD_INT 3
94491: PUSH
94492: LD_INT 3
94494: PUSH
94495: EMPTY
94496: LIST
94497: LIST
94498: PUSH
94499: LD_INT 5
94501: PUSH
94502: LD_INT 3
94504: PUSH
94505: EMPTY
94506: LIST
94507: LIST
94508: PUSH
94509: LD_INT 3
94511: PUSH
94512: LD_INT 5
94514: PUSH
94515: EMPTY
94516: LIST
94517: LIST
94518: PUSH
94519: LD_INT 0
94521: PUSH
94522: LD_INT 3
94524: PUSH
94525: EMPTY
94526: LIST
94527: LIST
94528: PUSH
94529: LD_INT 0
94531: PUSH
94532: LD_INT 2
94534: PUSH
94535: EMPTY
94536: LIST
94537: LIST
94538: PUSH
94539: LD_INT 1
94541: PUSH
94542: LD_INT 3
94544: PUSH
94545: EMPTY
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 1
94551: PUSH
94552: LD_INT 4
94554: PUSH
94555: EMPTY
94556: LIST
94557: LIST
94558: PUSH
94559: LD_INT 0
94561: PUSH
94562: LD_INT 4
94564: PUSH
94565: EMPTY
94566: LIST
94567: LIST
94568: PUSH
94569: LD_INT 1
94571: NEG
94572: PUSH
94573: LD_INT 3
94575: PUSH
94576: EMPTY
94577: LIST
94578: LIST
94579: PUSH
94580: LD_INT 1
94582: NEG
94583: PUSH
94584: LD_INT 2
94586: PUSH
94587: EMPTY
94588: LIST
94589: LIST
94590: PUSH
94591: LD_INT 2
94593: PUSH
94594: LD_INT 4
94596: PUSH
94597: EMPTY
94598: LIST
94599: LIST
94600: PUSH
94601: LD_INT 2
94603: NEG
94604: PUSH
94605: LD_INT 2
94607: PUSH
94608: EMPTY
94609: LIST
94610: LIST
94611: PUSH
94612: LD_INT 4
94614: NEG
94615: PUSH
94616: LD_INT 0
94618: PUSH
94619: EMPTY
94620: LIST
94621: LIST
94622: PUSH
94623: LD_INT 4
94625: NEG
94626: PUSH
94627: LD_INT 1
94629: NEG
94630: PUSH
94631: EMPTY
94632: LIST
94633: LIST
94634: PUSH
94635: LD_INT 3
94637: NEG
94638: PUSH
94639: LD_INT 0
94641: PUSH
94642: EMPTY
94643: LIST
94644: LIST
94645: PUSH
94646: LD_INT 3
94648: NEG
94649: PUSH
94650: LD_INT 1
94652: PUSH
94653: EMPTY
94654: LIST
94655: LIST
94656: PUSH
94657: LD_INT 4
94659: NEG
94660: PUSH
94661: LD_INT 1
94663: PUSH
94664: EMPTY
94665: LIST
94666: LIST
94667: PUSH
94668: LD_INT 5
94670: NEG
94671: PUSH
94672: LD_INT 0
94674: PUSH
94675: EMPTY
94676: LIST
94677: LIST
94678: PUSH
94679: LD_INT 5
94681: NEG
94682: PUSH
94683: LD_INT 1
94685: NEG
94686: PUSH
94687: EMPTY
94688: LIST
94689: LIST
94690: PUSH
94691: LD_INT 5
94693: NEG
94694: PUSH
94695: LD_INT 2
94697: NEG
94698: PUSH
94699: EMPTY
94700: LIST
94701: LIST
94702: PUSH
94703: LD_INT 3
94705: NEG
94706: PUSH
94707: LD_INT 2
94709: PUSH
94710: EMPTY
94711: LIST
94712: LIST
94713: PUSH
94714: LD_INT 3
94716: NEG
94717: PUSH
94718: LD_INT 3
94720: NEG
94721: PUSH
94722: EMPTY
94723: LIST
94724: LIST
94725: PUSH
94726: LD_INT 3
94728: NEG
94729: PUSH
94730: LD_INT 4
94732: NEG
94733: PUSH
94734: EMPTY
94735: LIST
94736: LIST
94737: PUSH
94738: LD_INT 2
94740: NEG
94741: PUSH
94742: LD_INT 3
94744: NEG
94745: PUSH
94746: EMPTY
94747: LIST
94748: LIST
94749: PUSH
94750: LD_INT 2
94752: NEG
94753: PUSH
94754: LD_INT 2
94756: NEG
94757: PUSH
94758: EMPTY
94759: LIST
94760: LIST
94761: PUSH
94762: LD_INT 3
94764: NEG
94765: PUSH
94766: LD_INT 2
94768: NEG
94769: PUSH
94770: EMPTY
94771: LIST
94772: LIST
94773: PUSH
94774: LD_INT 4
94776: NEG
94777: PUSH
94778: LD_INT 3
94780: NEG
94781: PUSH
94782: EMPTY
94783: LIST
94784: LIST
94785: PUSH
94786: LD_INT 4
94788: NEG
94789: PUSH
94790: LD_INT 4
94792: NEG
94793: PUSH
94794: EMPTY
94795: LIST
94796: LIST
94797: PUSH
94798: LD_INT 2
94800: NEG
94801: PUSH
94802: LD_INT 4
94804: NEG
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 4
94812: NEG
94813: PUSH
94814: LD_INT 2
94816: NEG
94817: PUSH
94818: EMPTY
94819: LIST
94820: LIST
94821: PUSH
94822: LD_INT 0
94824: PUSH
94825: LD_INT 4
94827: NEG
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: LD_INT 0
94835: PUSH
94836: LD_INT 5
94838: NEG
94839: PUSH
94840: EMPTY
94841: LIST
94842: LIST
94843: PUSH
94844: LD_INT 1
94846: PUSH
94847: LD_INT 4
94849: NEG
94850: PUSH
94851: EMPTY
94852: LIST
94853: LIST
94854: PUSH
94855: LD_INT 1
94857: PUSH
94858: LD_INT 3
94860: NEG
94861: PUSH
94862: EMPTY
94863: LIST
94864: LIST
94865: PUSH
94866: LD_INT 0
94868: PUSH
94869: LD_INT 3
94871: NEG
94872: PUSH
94873: EMPTY
94874: LIST
94875: LIST
94876: PUSH
94877: LD_INT 1
94879: NEG
94880: PUSH
94881: LD_INT 4
94883: NEG
94884: PUSH
94885: EMPTY
94886: LIST
94887: LIST
94888: PUSH
94889: LD_INT 1
94891: NEG
94892: PUSH
94893: LD_INT 5
94895: NEG
94896: PUSH
94897: EMPTY
94898: LIST
94899: LIST
94900: PUSH
94901: LD_INT 2
94903: PUSH
94904: LD_INT 3
94906: NEG
94907: PUSH
94908: EMPTY
94909: LIST
94910: LIST
94911: PUSH
94912: LD_INT 2
94914: NEG
94915: PUSH
94916: LD_INT 5
94918: NEG
94919: PUSH
94920: EMPTY
94921: LIST
94922: LIST
94923: PUSH
94924: EMPTY
94925: LIST
94926: LIST
94927: LIST
94928: LIST
94929: LIST
94930: LIST
94931: LIST
94932: LIST
94933: LIST
94934: LIST
94935: LIST
94936: LIST
94937: LIST
94938: LIST
94939: LIST
94940: LIST
94941: LIST
94942: LIST
94943: LIST
94944: LIST
94945: LIST
94946: LIST
94947: LIST
94948: LIST
94949: LIST
94950: LIST
94951: LIST
94952: LIST
94953: LIST
94954: LIST
94955: LIST
94956: LIST
94957: LIST
94958: LIST
94959: LIST
94960: LIST
94961: LIST
94962: LIST
94963: LIST
94964: LIST
94965: LIST
94966: LIST
94967: LIST
94968: LIST
94969: LIST
94970: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
94971: LD_ADDR_VAR 0 31
94975: PUSH
94976: LD_INT 0
94978: PUSH
94979: LD_INT 4
94981: PUSH
94982: EMPTY
94983: LIST
94984: LIST
94985: PUSH
94986: LD_INT 0
94988: PUSH
94989: LD_INT 3
94991: PUSH
94992: EMPTY
94993: LIST
94994: LIST
94995: PUSH
94996: LD_INT 1
94998: PUSH
94999: LD_INT 4
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: PUSH
95006: LD_INT 1
95008: PUSH
95009: LD_INT 5
95011: PUSH
95012: EMPTY
95013: LIST
95014: LIST
95015: PUSH
95016: LD_INT 0
95018: PUSH
95019: LD_INT 5
95021: PUSH
95022: EMPTY
95023: LIST
95024: LIST
95025: PUSH
95026: LD_INT 1
95028: NEG
95029: PUSH
95030: LD_INT 4
95032: PUSH
95033: EMPTY
95034: LIST
95035: LIST
95036: PUSH
95037: LD_INT 1
95039: NEG
95040: PUSH
95041: LD_INT 3
95043: PUSH
95044: EMPTY
95045: LIST
95046: LIST
95047: PUSH
95048: LD_INT 2
95050: PUSH
95051: LD_INT 5
95053: PUSH
95054: EMPTY
95055: LIST
95056: LIST
95057: PUSH
95058: LD_INT 2
95060: NEG
95061: PUSH
95062: LD_INT 3
95064: PUSH
95065: EMPTY
95066: LIST
95067: LIST
95068: PUSH
95069: LD_INT 3
95071: NEG
95072: PUSH
95073: LD_INT 0
95075: PUSH
95076: EMPTY
95077: LIST
95078: LIST
95079: PUSH
95080: LD_INT 3
95082: NEG
95083: PUSH
95084: LD_INT 1
95086: NEG
95087: PUSH
95088: EMPTY
95089: LIST
95090: LIST
95091: PUSH
95092: LD_INT 2
95094: NEG
95095: PUSH
95096: LD_INT 0
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: PUSH
95103: LD_INT 2
95105: NEG
95106: PUSH
95107: LD_INT 1
95109: PUSH
95110: EMPTY
95111: LIST
95112: LIST
95113: PUSH
95114: LD_INT 3
95116: NEG
95117: PUSH
95118: LD_INT 1
95120: PUSH
95121: EMPTY
95122: LIST
95123: LIST
95124: PUSH
95125: LD_INT 4
95127: NEG
95128: PUSH
95129: LD_INT 0
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: PUSH
95136: LD_INT 4
95138: NEG
95139: PUSH
95140: LD_INT 1
95142: NEG
95143: PUSH
95144: EMPTY
95145: LIST
95146: LIST
95147: PUSH
95148: LD_INT 4
95150: NEG
95151: PUSH
95152: LD_INT 2
95154: NEG
95155: PUSH
95156: EMPTY
95157: LIST
95158: LIST
95159: PUSH
95160: LD_INT 2
95162: NEG
95163: PUSH
95164: LD_INT 2
95166: PUSH
95167: EMPTY
95168: LIST
95169: LIST
95170: PUSH
95171: LD_INT 4
95173: NEG
95174: PUSH
95175: LD_INT 4
95177: NEG
95178: PUSH
95179: EMPTY
95180: LIST
95181: LIST
95182: PUSH
95183: LD_INT 4
95185: NEG
95186: PUSH
95187: LD_INT 5
95189: NEG
95190: PUSH
95191: EMPTY
95192: LIST
95193: LIST
95194: PUSH
95195: LD_INT 3
95197: NEG
95198: PUSH
95199: LD_INT 4
95201: NEG
95202: PUSH
95203: EMPTY
95204: LIST
95205: LIST
95206: PUSH
95207: LD_INT 3
95209: NEG
95210: PUSH
95211: LD_INT 3
95213: NEG
95214: PUSH
95215: EMPTY
95216: LIST
95217: LIST
95218: PUSH
95219: LD_INT 4
95221: NEG
95222: PUSH
95223: LD_INT 3
95225: NEG
95226: PUSH
95227: EMPTY
95228: LIST
95229: LIST
95230: PUSH
95231: LD_INT 5
95233: NEG
95234: PUSH
95235: LD_INT 4
95237: NEG
95238: PUSH
95239: EMPTY
95240: LIST
95241: LIST
95242: PUSH
95243: LD_INT 5
95245: NEG
95246: PUSH
95247: LD_INT 5
95249: NEG
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PUSH
95255: LD_INT 3
95257: NEG
95258: PUSH
95259: LD_INT 5
95261: NEG
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: PUSH
95267: LD_INT 5
95269: NEG
95270: PUSH
95271: LD_INT 3
95273: NEG
95274: PUSH
95275: EMPTY
95276: LIST
95277: LIST
95278: PUSH
95279: LD_INT 0
95281: PUSH
95282: LD_INT 3
95284: NEG
95285: PUSH
95286: EMPTY
95287: LIST
95288: LIST
95289: PUSH
95290: LD_INT 0
95292: PUSH
95293: LD_INT 4
95295: NEG
95296: PUSH
95297: EMPTY
95298: LIST
95299: LIST
95300: PUSH
95301: LD_INT 1
95303: PUSH
95304: LD_INT 3
95306: NEG
95307: PUSH
95308: EMPTY
95309: LIST
95310: LIST
95311: PUSH
95312: LD_INT 1
95314: PUSH
95315: LD_INT 2
95317: NEG
95318: PUSH
95319: EMPTY
95320: LIST
95321: LIST
95322: PUSH
95323: LD_INT 0
95325: PUSH
95326: LD_INT 2
95328: NEG
95329: PUSH
95330: EMPTY
95331: LIST
95332: LIST
95333: PUSH
95334: LD_INT 1
95336: NEG
95337: PUSH
95338: LD_INT 3
95340: NEG
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: PUSH
95346: LD_INT 1
95348: NEG
95349: PUSH
95350: LD_INT 4
95352: NEG
95353: PUSH
95354: EMPTY
95355: LIST
95356: LIST
95357: PUSH
95358: LD_INT 2
95360: PUSH
95361: LD_INT 2
95363: NEG
95364: PUSH
95365: EMPTY
95366: LIST
95367: LIST
95368: PUSH
95369: LD_INT 2
95371: NEG
95372: PUSH
95373: LD_INT 4
95375: NEG
95376: PUSH
95377: EMPTY
95378: LIST
95379: LIST
95380: PUSH
95381: LD_INT 4
95383: PUSH
95384: LD_INT 0
95386: PUSH
95387: EMPTY
95388: LIST
95389: LIST
95390: PUSH
95391: LD_INT 4
95393: PUSH
95394: LD_INT 1
95396: NEG
95397: PUSH
95398: EMPTY
95399: LIST
95400: LIST
95401: PUSH
95402: LD_INT 5
95404: PUSH
95405: LD_INT 0
95407: PUSH
95408: EMPTY
95409: LIST
95410: LIST
95411: PUSH
95412: LD_INT 5
95414: PUSH
95415: LD_INT 1
95417: PUSH
95418: EMPTY
95419: LIST
95420: LIST
95421: PUSH
95422: LD_INT 4
95424: PUSH
95425: LD_INT 1
95427: PUSH
95428: EMPTY
95429: LIST
95430: LIST
95431: PUSH
95432: LD_INT 3
95434: PUSH
95435: LD_INT 0
95437: PUSH
95438: EMPTY
95439: LIST
95440: LIST
95441: PUSH
95442: LD_INT 3
95444: PUSH
95445: LD_INT 1
95447: NEG
95448: PUSH
95449: EMPTY
95450: LIST
95451: LIST
95452: PUSH
95453: LD_INT 3
95455: PUSH
95456: LD_INT 2
95458: NEG
95459: PUSH
95460: EMPTY
95461: LIST
95462: LIST
95463: PUSH
95464: LD_INT 5
95466: PUSH
95467: LD_INT 2
95469: PUSH
95470: EMPTY
95471: LIST
95472: LIST
95473: PUSH
95474: EMPTY
95475: LIST
95476: LIST
95477: LIST
95478: LIST
95479: LIST
95480: LIST
95481: LIST
95482: LIST
95483: LIST
95484: LIST
95485: LIST
95486: LIST
95487: LIST
95488: LIST
95489: LIST
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: LIST
95508: LIST
95509: LIST
95510: LIST
95511: LIST
95512: LIST
95513: LIST
95514: LIST
95515: LIST
95516: LIST
95517: LIST
95518: LIST
95519: LIST
95520: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
95521: LD_ADDR_VAR 0 32
95525: PUSH
95526: LD_INT 4
95528: NEG
95529: PUSH
95530: LD_INT 0
95532: PUSH
95533: EMPTY
95534: LIST
95535: LIST
95536: PUSH
95537: LD_INT 4
95539: NEG
95540: PUSH
95541: LD_INT 1
95543: NEG
95544: PUSH
95545: EMPTY
95546: LIST
95547: LIST
95548: PUSH
95549: LD_INT 3
95551: NEG
95552: PUSH
95553: LD_INT 0
95555: PUSH
95556: EMPTY
95557: LIST
95558: LIST
95559: PUSH
95560: LD_INT 3
95562: NEG
95563: PUSH
95564: LD_INT 1
95566: PUSH
95567: EMPTY
95568: LIST
95569: LIST
95570: PUSH
95571: LD_INT 4
95573: NEG
95574: PUSH
95575: LD_INT 1
95577: PUSH
95578: EMPTY
95579: LIST
95580: LIST
95581: PUSH
95582: LD_INT 5
95584: NEG
95585: PUSH
95586: LD_INT 0
95588: PUSH
95589: EMPTY
95590: LIST
95591: LIST
95592: PUSH
95593: LD_INT 5
95595: NEG
95596: PUSH
95597: LD_INT 1
95599: NEG
95600: PUSH
95601: EMPTY
95602: LIST
95603: LIST
95604: PUSH
95605: LD_INT 5
95607: NEG
95608: PUSH
95609: LD_INT 2
95611: NEG
95612: PUSH
95613: EMPTY
95614: LIST
95615: LIST
95616: PUSH
95617: LD_INT 3
95619: NEG
95620: PUSH
95621: LD_INT 2
95623: PUSH
95624: EMPTY
95625: LIST
95626: LIST
95627: PUSH
95628: LD_INT 3
95630: NEG
95631: PUSH
95632: LD_INT 3
95634: NEG
95635: PUSH
95636: EMPTY
95637: LIST
95638: LIST
95639: PUSH
95640: LD_INT 3
95642: NEG
95643: PUSH
95644: LD_INT 4
95646: NEG
95647: PUSH
95648: EMPTY
95649: LIST
95650: LIST
95651: PUSH
95652: LD_INT 2
95654: NEG
95655: PUSH
95656: LD_INT 3
95658: NEG
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: PUSH
95664: LD_INT 2
95666: NEG
95667: PUSH
95668: LD_INT 2
95670: NEG
95671: PUSH
95672: EMPTY
95673: LIST
95674: LIST
95675: PUSH
95676: LD_INT 3
95678: NEG
95679: PUSH
95680: LD_INT 2
95682: NEG
95683: PUSH
95684: EMPTY
95685: LIST
95686: LIST
95687: PUSH
95688: LD_INT 4
95690: NEG
95691: PUSH
95692: LD_INT 3
95694: NEG
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: PUSH
95700: LD_INT 4
95702: NEG
95703: PUSH
95704: LD_INT 4
95706: NEG
95707: PUSH
95708: EMPTY
95709: LIST
95710: LIST
95711: PUSH
95712: LD_INT 2
95714: NEG
95715: PUSH
95716: LD_INT 4
95718: NEG
95719: PUSH
95720: EMPTY
95721: LIST
95722: LIST
95723: PUSH
95724: LD_INT 4
95726: NEG
95727: PUSH
95728: LD_INT 2
95730: NEG
95731: PUSH
95732: EMPTY
95733: LIST
95734: LIST
95735: PUSH
95736: LD_INT 0
95738: PUSH
95739: LD_INT 4
95741: NEG
95742: PUSH
95743: EMPTY
95744: LIST
95745: LIST
95746: PUSH
95747: LD_INT 0
95749: PUSH
95750: LD_INT 5
95752: NEG
95753: PUSH
95754: EMPTY
95755: LIST
95756: LIST
95757: PUSH
95758: LD_INT 1
95760: PUSH
95761: LD_INT 4
95763: NEG
95764: PUSH
95765: EMPTY
95766: LIST
95767: LIST
95768: PUSH
95769: LD_INT 1
95771: PUSH
95772: LD_INT 3
95774: NEG
95775: PUSH
95776: EMPTY
95777: LIST
95778: LIST
95779: PUSH
95780: LD_INT 0
95782: PUSH
95783: LD_INT 3
95785: NEG
95786: PUSH
95787: EMPTY
95788: LIST
95789: LIST
95790: PUSH
95791: LD_INT 1
95793: NEG
95794: PUSH
95795: LD_INT 4
95797: NEG
95798: PUSH
95799: EMPTY
95800: LIST
95801: LIST
95802: PUSH
95803: LD_INT 1
95805: NEG
95806: PUSH
95807: LD_INT 5
95809: NEG
95810: PUSH
95811: EMPTY
95812: LIST
95813: LIST
95814: PUSH
95815: LD_INT 2
95817: PUSH
95818: LD_INT 3
95820: NEG
95821: PUSH
95822: EMPTY
95823: LIST
95824: LIST
95825: PUSH
95826: LD_INT 2
95828: NEG
95829: PUSH
95830: LD_INT 5
95832: NEG
95833: PUSH
95834: EMPTY
95835: LIST
95836: LIST
95837: PUSH
95838: LD_INT 3
95840: PUSH
95841: LD_INT 0
95843: PUSH
95844: EMPTY
95845: LIST
95846: LIST
95847: PUSH
95848: LD_INT 3
95850: PUSH
95851: LD_INT 1
95853: NEG
95854: PUSH
95855: EMPTY
95856: LIST
95857: LIST
95858: PUSH
95859: LD_INT 4
95861: PUSH
95862: LD_INT 0
95864: PUSH
95865: EMPTY
95866: LIST
95867: LIST
95868: PUSH
95869: LD_INT 4
95871: PUSH
95872: LD_INT 1
95874: PUSH
95875: EMPTY
95876: LIST
95877: LIST
95878: PUSH
95879: LD_INT 3
95881: PUSH
95882: LD_INT 1
95884: PUSH
95885: EMPTY
95886: LIST
95887: LIST
95888: PUSH
95889: LD_INT 2
95891: PUSH
95892: LD_INT 0
95894: PUSH
95895: EMPTY
95896: LIST
95897: LIST
95898: PUSH
95899: LD_INT 2
95901: PUSH
95902: LD_INT 1
95904: NEG
95905: PUSH
95906: EMPTY
95907: LIST
95908: LIST
95909: PUSH
95910: LD_INT 2
95912: PUSH
95913: LD_INT 2
95915: NEG
95916: PUSH
95917: EMPTY
95918: LIST
95919: LIST
95920: PUSH
95921: LD_INT 4
95923: PUSH
95924: LD_INT 2
95926: PUSH
95927: EMPTY
95928: LIST
95929: LIST
95930: PUSH
95931: LD_INT 4
95933: PUSH
95934: LD_INT 4
95936: PUSH
95937: EMPTY
95938: LIST
95939: LIST
95940: PUSH
95941: LD_INT 4
95943: PUSH
95944: LD_INT 3
95946: PUSH
95947: EMPTY
95948: LIST
95949: LIST
95950: PUSH
95951: LD_INT 5
95953: PUSH
95954: LD_INT 4
95956: PUSH
95957: EMPTY
95958: LIST
95959: LIST
95960: PUSH
95961: LD_INT 5
95963: PUSH
95964: LD_INT 5
95966: PUSH
95967: EMPTY
95968: LIST
95969: LIST
95970: PUSH
95971: LD_INT 4
95973: PUSH
95974: LD_INT 5
95976: PUSH
95977: EMPTY
95978: LIST
95979: LIST
95980: PUSH
95981: LD_INT 3
95983: PUSH
95984: LD_INT 4
95986: PUSH
95987: EMPTY
95988: LIST
95989: LIST
95990: PUSH
95991: LD_INT 3
95993: PUSH
95994: LD_INT 3
95996: PUSH
95997: EMPTY
95998: LIST
95999: LIST
96000: PUSH
96001: LD_INT 5
96003: PUSH
96004: LD_INT 3
96006: PUSH
96007: EMPTY
96008: LIST
96009: LIST
96010: PUSH
96011: LD_INT 3
96013: PUSH
96014: LD_INT 5
96016: PUSH
96017: EMPTY
96018: LIST
96019: LIST
96020: PUSH
96021: EMPTY
96022: LIST
96023: LIST
96024: LIST
96025: LIST
96026: LIST
96027: LIST
96028: LIST
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: LIST
96064: LIST
96065: LIST
96066: LIST
96067: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
96068: LD_ADDR_VAR 0 33
96072: PUSH
96073: LD_INT 4
96075: NEG
96076: PUSH
96077: LD_INT 4
96079: NEG
96080: PUSH
96081: EMPTY
96082: LIST
96083: LIST
96084: PUSH
96085: LD_INT 4
96087: NEG
96088: PUSH
96089: LD_INT 5
96091: NEG
96092: PUSH
96093: EMPTY
96094: LIST
96095: LIST
96096: PUSH
96097: LD_INT 3
96099: NEG
96100: PUSH
96101: LD_INT 4
96103: NEG
96104: PUSH
96105: EMPTY
96106: LIST
96107: LIST
96108: PUSH
96109: LD_INT 3
96111: NEG
96112: PUSH
96113: LD_INT 3
96115: NEG
96116: PUSH
96117: EMPTY
96118: LIST
96119: LIST
96120: PUSH
96121: LD_INT 4
96123: NEG
96124: PUSH
96125: LD_INT 3
96127: NEG
96128: PUSH
96129: EMPTY
96130: LIST
96131: LIST
96132: PUSH
96133: LD_INT 5
96135: NEG
96136: PUSH
96137: LD_INT 4
96139: NEG
96140: PUSH
96141: EMPTY
96142: LIST
96143: LIST
96144: PUSH
96145: LD_INT 5
96147: NEG
96148: PUSH
96149: LD_INT 5
96151: NEG
96152: PUSH
96153: EMPTY
96154: LIST
96155: LIST
96156: PUSH
96157: LD_INT 3
96159: NEG
96160: PUSH
96161: LD_INT 5
96163: NEG
96164: PUSH
96165: EMPTY
96166: LIST
96167: LIST
96168: PUSH
96169: LD_INT 5
96171: NEG
96172: PUSH
96173: LD_INT 3
96175: NEG
96176: PUSH
96177: EMPTY
96178: LIST
96179: LIST
96180: PUSH
96181: LD_INT 0
96183: PUSH
96184: LD_INT 3
96186: NEG
96187: PUSH
96188: EMPTY
96189: LIST
96190: LIST
96191: PUSH
96192: LD_INT 0
96194: PUSH
96195: LD_INT 4
96197: NEG
96198: PUSH
96199: EMPTY
96200: LIST
96201: LIST
96202: PUSH
96203: LD_INT 1
96205: PUSH
96206: LD_INT 3
96208: NEG
96209: PUSH
96210: EMPTY
96211: LIST
96212: LIST
96213: PUSH
96214: LD_INT 1
96216: PUSH
96217: LD_INT 2
96219: NEG
96220: PUSH
96221: EMPTY
96222: LIST
96223: LIST
96224: PUSH
96225: LD_INT 0
96227: PUSH
96228: LD_INT 2
96230: NEG
96231: PUSH
96232: EMPTY
96233: LIST
96234: LIST
96235: PUSH
96236: LD_INT 1
96238: NEG
96239: PUSH
96240: LD_INT 3
96242: NEG
96243: PUSH
96244: EMPTY
96245: LIST
96246: LIST
96247: PUSH
96248: LD_INT 1
96250: NEG
96251: PUSH
96252: LD_INT 4
96254: NEG
96255: PUSH
96256: EMPTY
96257: LIST
96258: LIST
96259: PUSH
96260: LD_INT 2
96262: PUSH
96263: LD_INT 2
96265: NEG
96266: PUSH
96267: EMPTY
96268: LIST
96269: LIST
96270: PUSH
96271: LD_INT 2
96273: NEG
96274: PUSH
96275: LD_INT 4
96277: NEG
96278: PUSH
96279: EMPTY
96280: LIST
96281: LIST
96282: PUSH
96283: LD_INT 4
96285: PUSH
96286: LD_INT 0
96288: PUSH
96289: EMPTY
96290: LIST
96291: LIST
96292: PUSH
96293: LD_INT 4
96295: PUSH
96296: LD_INT 1
96298: NEG
96299: PUSH
96300: EMPTY
96301: LIST
96302: LIST
96303: PUSH
96304: LD_INT 5
96306: PUSH
96307: LD_INT 0
96309: PUSH
96310: EMPTY
96311: LIST
96312: LIST
96313: PUSH
96314: LD_INT 5
96316: PUSH
96317: LD_INT 1
96319: PUSH
96320: EMPTY
96321: LIST
96322: LIST
96323: PUSH
96324: LD_INT 4
96326: PUSH
96327: LD_INT 1
96329: PUSH
96330: EMPTY
96331: LIST
96332: LIST
96333: PUSH
96334: LD_INT 3
96336: PUSH
96337: LD_INT 0
96339: PUSH
96340: EMPTY
96341: LIST
96342: LIST
96343: PUSH
96344: LD_INT 3
96346: PUSH
96347: LD_INT 1
96349: NEG
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: PUSH
96355: LD_INT 3
96357: PUSH
96358: LD_INT 2
96360: NEG
96361: PUSH
96362: EMPTY
96363: LIST
96364: LIST
96365: PUSH
96366: LD_INT 5
96368: PUSH
96369: LD_INT 2
96371: PUSH
96372: EMPTY
96373: LIST
96374: LIST
96375: PUSH
96376: LD_INT 3
96378: PUSH
96379: LD_INT 3
96381: PUSH
96382: EMPTY
96383: LIST
96384: LIST
96385: PUSH
96386: LD_INT 3
96388: PUSH
96389: LD_INT 2
96391: PUSH
96392: EMPTY
96393: LIST
96394: LIST
96395: PUSH
96396: LD_INT 4
96398: PUSH
96399: LD_INT 3
96401: PUSH
96402: EMPTY
96403: LIST
96404: LIST
96405: PUSH
96406: LD_INT 4
96408: PUSH
96409: LD_INT 4
96411: PUSH
96412: EMPTY
96413: LIST
96414: LIST
96415: PUSH
96416: LD_INT 3
96418: PUSH
96419: LD_INT 4
96421: PUSH
96422: EMPTY
96423: LIST
96424: LIST
96425: PUSH
96426: LD_INT 2
96428: PUSH
96429: LD_INT 3
96431: PUSH
96432: EMPTY
96433: LIST
96434: LIST
96435: PUSH
96436: LD_INT 2
96438: PUSH
96439: LD_INT 2
96441: PUSH
96442: EMPTY
96443: LIST
96444: LIST
96445: PUSH
96446: LD_INT 4
96448: PUSH
96449: LD_INT 2
96451: PUSH
96452: EMPTY
96453: LIST
96454: LIST
96455: PUSH
96456: LD_INT 2
96458: PUSH
96459: LD_INT 4
96461: PUSH
96462: EMPTY
96463: LIST
96464: LIST
96465: PUSH
96466: LD_INT 0
96468: PUSH
96469: LD_INT 4
96471: PUSH
96472: EMPTY
96473: LIST
96474: LIST
96475: PUSH
96476: LD_INT 0
96478: PUSH
96479: LD_INT 3
96481: PUSH
96482: EMPTY
96483: LIST
96484: LIST
96485: PUSH
96486: LD_INT 1
96488: PUSH
96489: LD_INT 4
96491: PUSH
96492: EMPTY
96493: LIST
96494: LIST
96495: PUSH
96496: LD_INT 1
96498: PUSH
96499: LD_INT 5
96501: PUSH
96502: EMPTY
96503: LIST
96504: LIST
96505: PUSH
96506: LD_INT 0
96508: PUSH
96509: LD_INT 5
96511: PUSH
96512: EMPTY
96513: LIST
96514: LIST
96515: PUSH
96516: LD_INT 1
96518: NEG
96519: PUSH
96520: LD_INT 4
96522: PUSH
96523: EMPTY
96524: LIST
96525: LIST
96526: PUSH
96527: LD_INT 1
96529: NEG
96530: PUSH
96531: LD_INT 3
96533: PUSH
96534: EMPTY
96535: LIST
96536: LIST
96537: PUSH
96538: LD_INT 2
96540: PUSH
96541: LD_INT 5
96543: PUSH
96544: EMPTY
96545: LIST
96546: LIST
96547: PUSH
96548: LD_INT 2
96550: NEG
96551: PUSH
96552: LD_INT 3
96554: PUSH
96555: EMPTY
96556: LIST
96557: LIST
96558: PUSH
96559: EMPTY
96560: LIST
96561: LIST
96562: LIST
96563: LIST
96564: LIST
96565: LIST
96566: LIST
96567: LIST
96568: LIST
96569: LIST
96570: LIST
96571: LIST
96572: LIST
96573: LIST
96574: LIST
96575: LIST
96576: LIST
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: LIST
96595: LIST
96596: LIST
96597: LIST
96598: LIST
96599: LIST
96600: LIST
96601: LIST
96602: LIST
96603: LIST
96604: LIST
96605: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
96606: LD_ADDR_VAR 0 34
96610: PUSH
96611: LD_INT 0
96613: PUSH
96614: LD_INT 4
96616: NEG
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PUSH
96622: LD_INT 0
96624: PUSH
96625: LD_INT 5
96627: NEG
96628: PUSH
96629: EMPTY
96630: LIST
96631: LIST
96632: PUSH
96633: LD_INT 1
96635: PUSH
96636: LD_INT 4
96638: NEG
96639: PUSH
96640: EMPTY
96641: LIST
96642: LIST
96643: PUSH
96644: LD_INT 1
96646: PUSH
96647: LD_INT 3
96649: NEG
96650: PUSH
96651: EMPTY
96652: LIST
96653: LIST
96654: PUSH
96655: LD_INT 0
96657: PUSH
96658: LD_INT 3
96660: NEG
96661: PUSH
96662: EMPTY
96663: LIST
96664: LIST
96665: PUSH
96666: LD_INT 1
96668: NEG
96669: PUSH
96670: LD_INT 4
96672: NEG
96673: PUSH
96674: EMPTY
96675: LIST
96676: LIST
96677: PUSH
96678: LD_INT 1
96680: NEG
96681: PUSH
96682: LD_INT 5
96684: NEG
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: PUSH
96690: LD_INT 2
96692: PUSH
96693: LD_INT 3
96695: NEG
96696: PUSH
96697: EMPTY
96698: LIST
96699: LIST
96700: PUSH
96701: LD_INT 2
96703: NEG
96704: PUSH
96705: LD_INT 5
96707: NEG
96708: PUSH
96709: EMPTY
96710: LIST
96711: LIST
96712: PUSH
96713: LD_INT 3
96715: PUSH
96716: LD_INT 0
96718: PUSH
96719: EMPTY
96720: LIST
96721: LIST
96722: PUSH
96723: LD_INT 3
96725: PUSH
96726: LD_INT 1
96728: NEG
96729: PUSH
96730: EMPTY
96731: LIST
96732: LIST
96733: PUSH
96734: LD_INT 4
96736: PUSH
96737: LD_INT 0
96739: PUSH
96740: EMPTY
96741: LIST
96742: LIST
96743: PUSH
96744: LD_INT 4
96746: PUSH
96747: LD_INT 1
96749: PUSH
96750: EMPTY
96751: LIST
96752: LIST
96753: PUSH
96754: LD_INT 3
96756: PUSH
96757: LD_INT 1
96759: PUSH
96760: EMPTY
96761: LIST
96762: LIST
96763: PUSH
96764: LD_INT 2
96766: PUSH
96767: LD_INT 0
96769: PUSH
96770: EMPTY
96771: LIST
96772: LIST
96773: PUSH
96774: LD_INT 2
96776: PUSH
96777: LD_INT 1
96779: NEG
96780: PUSH
96781: EMPTY
96782: LIST
96783: LIST
96784: PUSH
96785: LD_INT 2
96787: PUSH
96788: LD_INT 2
96790: NEG
96791: PUSH
96792: EMPTY
96793: LIST
96794: LIST
96795: PUSH
96796: LD_INT 4
96798: PUSH
96799: LD_INT 2
96801: PUSH
96802: EMPTY
96803: LIST
96804: LIST
96805: PUSH
96806: LD_INT 4
96808: PUSH
96809: LD_INT 4
96811: PUSH
96812: EMPTY
96813: LIST
96814: LIST
96815: PUSH
96816: LD_INT 4
96818: PUSH
96819: LD_INT 3
96821: PUSH
96822: EMPTY
96823: LIST
96824: LIST
96825: PUSH
96826: LD_INT 5
96828: PUSH
96829: LD_INT 4
96831: PUSH
96832: EMPTY
96833: LIST
96834: LIST
96835: PUSH
96836: LD_INT 5
96838: PUSH
96839: LD_INT 5
96841: PUSH
96842: EMPTY
96843: LIST
96844: LIST
96845: PUSH
96846: LD_INT 4
96848: PUSH
96849: LD_INT 5
96851: PUSH
96852: EMPTY
96853: LIST
96854: LIST
96855: PUSH
96856: LD_INT 3
96858: PUSH
96859: LD_INT 4
96861: PUSH
96862: EMPTY
96863: LIST
96864: LIST
96865: PUSH
96866: LD_INT 3
96868: PUSH
96869: LD_INT 3
96871: PUSH
96872: EMPTY
96873: LIST
96874: LIST
96875: PUSH
96876: LD_INT 5
96878: PUSH
96879: LD_INT 3
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 3
96888: PUSH
96889: LD_INT 5
96891: PUSH
96892: EMPTY
96893: LIST
96894: LIST
96895: PUSH
96896: LD_INT 0
96898: PUSH
96899: LD_INT 3
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: PUSH
96906: LD_INT 0
96908: PUSH
96909: LD_INT 2
96911: PUSH
96912: EMPTY
96913: LIST
96914: LIST
96915: PUSH
96916: LD_INT 1
96918: PUSH
96919: LD_INT 3
96921: PUSH
96922: EMPTY
96923: LIST
96924: LIST
96925: PUSH
96926: LD_INT 1
96928: PUSH
96929: LD_INT 4
96931: PUSH
96932: EMPTY
96933: LIST
96934: LIST
96935: PUSH
96936: LD_INT 0
96938: PUSH
96939: LD_INT 4
96941: PUSH
96942: EMPTY
96943: LIST
96944: LIST
96945: PUSH
96946: LD_INT 1
96948: NEG
96949: PUSH
96950: LD_INT 3
96952: PUSH
96953: EMPTY
96954: LIST
96955: LIST
96956: PUSH
96957: LD_INT 1
96959: NEG
96960: PUSH
96961: LD_INT 2
96963: PUSH
96964: EMPTY
96965: LIST
96966: LIST
96967: PUSH
96968: LD_INT 2
96970: PUSH
96971: LD_INT 4
96973: PUSH
96974: EMPTY
96975: LIST
96976: LIST
96977: PUSH
96978: LD_INT 2
96980: NEG
96981: PUSH
96982: LD_INT 2
96984: PUSH
96985: EMPTY
96986: LIST
96987: LIST
96988: PUSH
96989: LD_INT 4
96991: NEG
96992: PUSH
96993: LD_INT 0
96995: PUSH
96996: EMPTY
96997: LIST
96998: LIST
96999: PUSH
97000: LD_INT 4
97002: NEG
97003: PUSH
97004: LD_INT 1
97006: NEG
97007: PUSH
97008: EMPTY
97009: LIST
97010: LIST
97011: PUSH
97012: LD_INT 3
97014: NEG
97015: PUSH
97016: LD_INT 0
97018: PUSH
97019: EMPTY
97020: LIST
97021: LIST
97022: PUSH
97023: LD_INT 3
97025: NEG
97026: PUSH
97027: LD_INT 1
97029: PUSH
97030: EMPTY
97031: LIST
97032: LIST
97033: PUSH
97034: LD_INT 4
97036: NEG
97037: PUSH
97038: LD_INT 1
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: PUSH
97045: LD_INT 5
97047: NEG
97048: PUSH
97049: LD_INT 0
97051: PUSH
97052: EMPTY
97053: LIST
97054: LIST
97055: PUSH
97056: LD_INT 5
97058: NEG
97059: PUSH
97060: LD_INT 1
97062: NEG
97063: PUSH
97064: EMPTY
97065: LIST
97066: LIST
97067: PUSH
97068: LD_INT 5
97070: NEG
97071: PUSH
97072: LD_INT 2
97074: NEG
97075: PUSH
97076: EMPTY
97077: LIST
97078: LIST
97079: PUSH
97080: LD_INT 3
97082: NEG
97083: PUSH
97084: LD_INT 2
97086: PUSH
97087: EMPTY
97088: LIST
97089: LIST
97090: PUSH
97091: EMPTY
97092: LIST
97093: LIST
97094: LIST
97095: LIST
97096: LIST
97097: LIST
97098: LIST
97099: LIST
97100: LIST
97101: LIST
97102: LIST
97103: LIST
97104: LIST
97105: LIST
97106: LIST
97107: LIST
97108: LIST
97109: LIST
97110: LIST
97111: LIST
97112: LIST
97113: LIST
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: ST_TO_ADDR
// end ; end ;
97138: GO 97141
97140: POP
// case btype of b_depot , b_warehouse :
97141: LD_VAR 0 1
97145: PUSH
97146: LD_INT 0
97148: DOUBLE
97149: EQUAL
97150: IFTRUE 97160
97152: LD_INT 1
97154: DOUBLE
97155: EQUAL
97156: IFTRUE 97160
97158: GO 97361
97160: POP
// case nation of nation_american :
97161: LD_VAR 0 5
97165: PUSH
97166: LD_INT 1
97168: DOUBLE
97169: EQUAL
97170: IFTRUE 97174
97172: GO 97230
97174: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
97175: LD_ADDR_VAR 0 9
97179: PUSH
97180: LD_VAR 0 11
97184: PUSH
97185: LD_VAR 0 12
97189: PUSH
97190: LD_VAR 0 13
97194: PUSH
97195: LD_VAR 0 14
97199: PUSH
97200: LD_VAR 0 15
97204: PUSH
97205: LD_VAR 0 16
97209: PUSH
97210: EMPTY
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: PUSH
97218: LD_VAR 0 4
97222: PUSH
97223: LD_INT 1
97225: PLUS
97226: ARRAY
97227: ST_TO_ADDR
97228: GO 97359
97230: LD_INT 2
97232: DOUBLE
97233: EQUAL
97234: IFTRUE 97238
97236: GO 97294
97238: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
97239: LD_ADDR_VAR 0 9
97243: PUSH
97244: LD_VAR 0 17
97248: PUSH
97249: LD_VAR 0 18
97253: PUSH
97254: LD_VAR 0 19
97258: PUSH
97259: LD_VAR 0 20
97263: PUSH
97264: LD_VAR 0 21
97268: PUSH
97269: LD_VAR 0 22
97273: PUSH
97274: EMPTY
97275: LIST
97276: LIST
97277: LIST
97278: LIST
97279: LIST
97280: LIST
97281: PUSH
97282: LD_VAR 0 4
97286: PUSH
97287: LD_INT 1
97289: PLUS
97290: ARRAY
97291: ST_TO_ADDR
97292: GO 97359
97294: LD_INT 3
97296: DOUBLE
97297: EQUAL
97298: IFTRUE 97302
97300: GO 97358
97302: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
97303: LD_ADDR_VAR 0 9
97307: PUSH
97308: LD_VAR 0 23
97312: PUSH
97313: LD_VAR 0 24
97317: PUSH
97318: LD_VAR 0 25
97322: PUSH
97323: LD_VAR 0 26
97327: PUSH
97328: LD_VAR 0 27
97332: PUSH
97333: LD_VAR 0 28
97337: PUSH
97338: EMPTY
97339: LIST
97340: LIST
97341: LIST
97342: LIST
97343: LIST
97344: LIST
97345: PUSH
97346: LD_VAR 0 4
97350: PUSH
97351: LD_INT 1
97353: PLUS
97354: ARRAY
97355: ST_TO_ADDR
97356: GO 97359
97358: POP
97359: GO 97914
97361: LD_INT 2
97363: DOUBLE
97364: EQUAL
97365: IFTRUE 97375
97367: LD_INT 3
97369: DOUBLE
97370: EQUAL
97371: IFTRUE 97375
97373: GO 97431
97375: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
97376: LD_ADDR_VAR 0 9
97380: PUSH
97381: LD_VAR 0 29
97385: PUSH
97386: LD_VAR 0 30
97390: PUSH
97391: LD_VAR 0 31
97395: PUSH
97396: LD_VAR 0 32
97400: PUSH
97401: LD_VAR 0 33
97405: PUSH
97406: LD_VAR 0 34
97410: PUSH
97411: EMPTY
97412: LIST
97413: LIST
97414: LIST
97415: LIST
97416: LIST
97417: LIST
97418: PUSH
97419: LD_VAR 0 4
97423: PUSH
97424: LD_INT 1
97426: PLUS
97427: ARRAY
97428: ST_TO_ADDR
97429: GO 97914
97431: LD_INT 16
97433: DOUBLE
97434: EQUAL
97435: IFTRUE 97493
97437: LD_INT 17
97439: DOUBLE
97440: EQUAL
97441: IFTRUE 97493
97443: LD_INT 18
97445: DOUBLE
97446: EQUAL
97447: IFTRUE 97493
97449: LD_INT 19
97451: DOUBLE
97452: EQUAL
97453: IFTRUE 97493
97455: LD_INT 22
97457: DOUBLE
97458: EQUAL
97459: IFTRUE 97493
97461: LD_INT 20
97463: DOUBLE
97464: EQUAL
97465: IFTRUE 97493
97467: LD_INT 21
97469: DOUBLE
97470: EQUAL
97471: IFTRUE 97493
97473: LD_INT 23
97475: DOUBLE
97476: EQUAL
97477: IFTRUE 97493
97479: LD_INT 24
97481: DOUBLE
97482: EQUAL
97483: IFTRUE 97493
97485: LD_INT 25
97487: DOUBLE
97488: EQUAL
97489: IFTRUE 97493
97491: GO 97549
97493: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
97494: LD_ADDR_VAR 0 9
97498: PUSH
97499: LD_VAR 0 35
97503: PUSH
97504: LD_VAR 0 36
97508: PUSH
97509: LD_VAR 0 37
97513: PUSH
97514: LD_VAR 0 38
97518: PUSH
97519: LD_VAR 0 39
97523: PUSH
97524: LD_VAR 0 40
97528: PUSH
97529: EMPTY
97530: LIST
97531: LIST
97532: LIST
97533: LIST
97534: LIST
97535: LIST
97536: PUSH
97537: LD_VAR 0 4
97541: PUSH
97542: LD_INT 1
97544: PLUS
97545: ARRAY
97546: ST_TO_ADDR
97547: GO 97914
97549: LD_INT 6
97551: DOUBLE
97552: EQUAL
97553: IFTRUE 97605
97555: LD_INT 7
97557: DOUBLE
97558: EQUAL
97559: IFTRUE 97605
97561: LD_INT 8
97563: DOUBLE
97564: EQUAL
97565: IFTRUE 97605
97567: LD_INT 13
97569: DOUBLE
97570: EQUAL
97571: IFTRUE 97605
97573: LD_INT 12
97575: DOUBLE
97576: EQUAL
97577: IFTRUE 97605
97579: LD_INT 15
97581: DOUBLE
97582: EQUAL
97583: IFTRUE 97605
97585: LD_INT 11
97587: DOUBLE
97588: EQUAL
97589: IFTRUE 97605
97591: LD_INT 14
97593: DOUBLE
97594: EQUAL
97595: IFTRUE 97605
97597: LD_INT 10
97599: DOUBLE
97600: EQUAL
97601: IFTRUE 97605
97603: GO 97661
97605: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
97606: LD_ADDR_VAR 0 9
97610: PUSH
97611: LD_VAR 0 41
97615: PUSH
97616: LD_VAR 0 42
97620: PUSH
97621: LD_VAR 0 43
97625: PUSH
97626: LD_VAR 0 44
97630: PUSH
97631: LD_VAR 0 45
97635: PUSH
97636: LD_VAR 0 46
97640: PUSH
97641: EMPTY
97642: LIST
97643: LIST
97644: LIST
97645: LIST
97646: LIST
97647: LIST
97648: PUSH
97649: LD_VAR 0 4
97653: PUSH
97654: LD_INT 1
97656: PLUS
97657: ARRAY
97658: ST_TO_ADDR
97659: GO 97914
97661: LD_INT 36
97663: DOUBLE
97664: EQUAL
97665: IFTRUE 97669
97667: GO 97725
97669: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
97670: LD_ADDR_VAR 0 9
97674: PUSH
97675: LD_VAR 0 47
97679: PUSH
97680: LD_VAR 0 48
97684: PUSH
97685: LD_VAR 0 49
97689: PUSH
97690: LD_VAR 0 50
97694: PUSH
97695: LD_VAR 0 51
97699: PUSH
97700: LD_VAR 0 52
97704: PUSH
97705: EMPTY
97706: LIST
97707: LIST
97708: LIST
97709: LIST
97710: LIST
97711: LIST
97712: PUSH
97713: LD_VAR 0 4
97717: PUSH
97718: LD_INT 1
97720: PLUS
97721: ARRAY
97722: ST_TO_ADDR
97723: GO 97914
97725: LD_INT 4
97727: DOUBLE
97728: EQUAL
97729: IFTRUE 97751
97731: LD_INT 5
97733: DOUBLE
97734: EQUAL
97735: IFTRUE 97751
97737: LD_INT 34
97739: DOUBLE
97740: EQUAL
97741: IFTRUE 97751
97743: LD_INT 37
97745: DOUBLE
97746: EQUAL
97747: IFTRUE 97751
97749: GO 97807
97751: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
97752: LD_ADDR_VAR 0 9
97756: PUSH
97757: LD_VAR 0 53
97761: PUSH
97762: LD_VAR 0 54
97766: PUSH
97767: LD_VAR 0 55
97771: PUSH
97772: LD_VAR 0 56
97776: PUSH
97777: LD_VAR 0 57
97781: PUSH
97782: LD_VAR 0 58
97786: PUSH
97787: EMPTY
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: PUSH
97795: LD_VAR 0 4
97799: PUSH
97800: LD_INT 1
97802: PLUS
97803: ARRAY
97804: ST_TO_ADDR
97805: GO 97914
97807: LD_INT 31
97809: DOUBLE
97810: EQUAL
97811: IFTRUE 97857
97813: LD_INT 32
97815: DOUBLE
97816: EQUAL
97817: IFTRUE 97857
97819: LD_INT 33
97821: DOUBLE
97822: EQUAL
97823: IFTRUE 97857
97825: LD_INT 27
97827: DOUBLE
97828: EQUAL
97829: IFTRUE 97857
97831: LD_INT 26
97833: DOUBLE
97834: EQUAL
97835: IFTRUE 97857
97837: LD_INT 28
97839: DOUBLE
97840: EQUAL
97841: IFTRUE 97857
97843: LD_INT 29
97845: DOUBLE
97846: EQUAL
97847: IFTRUE 97857
97849: LD_INT 30
97851: DOUBLE
97852: EQUAL
97853: IFTRUE 97857
97855: GO 97913
97857: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
97858: LD_ADDR_VAR 0 9
97862: PUSH
97863: LD_VAR 0 59
97867: PUSH
97868: LD_VAR 0 60
97872: PUSH
97873: LD_VAR 0 61
97877: PUSH
97878: LD_VAR 0 62
97882: PUSH
97883: LD_VAR 0 63
97887: PUSH
97888: LD_VAR 0 64
97892: PUSH
97893: EMPTY
97894: LIST
97895: LIST
97896: LIST
97897: LIST
97898: LIST
97899: LIST
97900: PUSH
97901: LD_VAR 0 4
97905: PUSH
97906: LD_INT 1
97908: PLUS
97909: ARRAY
97910: ST_TO_ADDR
97911: GO 97914
97913: POP
// temp_list2 = [ ] ;
97914: LD_ADDR_VAR 0 10
97918: PUSH
97919: EMPTY
97920: ST_TO_ADDR
// for i in temp_list do
97921: LD_ADDR_VAR 0 8
97925: PUSH
97926: LD_VAR 0 9
97930: PUSH
97931: FOR_IN
97932: IFFALSE 97984
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
97934: LD_ADDR_VAR 0 10
97938: PUSH
97939: LD_VAR 0 10
97943: PUSH
97944: LD_VAR 0 8
97948: PUSH
97949: LD_INT 1
97951: ARRAY
97952: PUSH
97953: LD_VAR 0 2
97957: PLUS
97958: PUSH
97959: LD_VAR 0 8
97963: PUSH
97964: LD_INT 2
97966: ARRAY
97967: PUSH
97968: LD_VAR 0 3
97972: PLUS
97973: PUSH
97974: EMPTY
97975: LIST
97976: LIST
97977: PUSH
97978: EMPTY
97979: LIST
97980: ADD
97981: ST_TO_ADDR
97982: GO 97931
97984: POP
97985: POP
// result = temp_list2 ;
97986: LD_ADDR_VAR 0 7
97990: PUSH
97991: LD_VAR 0 10
97995: ST_TO_ADDR
// end ;
97996: LD_VAR 0 7
98000: RET
// export function EnemyInRange ( unit , dist ) ; begin
98001: LD_INT 0
98003: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
98004: LD_ADDR_VAR 0 3
98008: PUSH
98009: LD_VAR 0 1
98013: PPUSH
98014: CALL_OW 255
98018: PPUSH
98019: LD_VAR 0 1
98023: PPUSH
98024: CALL_OW 250
98028: PPUSH
98029: LD_VAR 0 1
98033: PPUSH
98034: CALL_OW 251
98038: PPUSH
98039: LD_VAR 0 2
98043: PPUSH
98044: CALL 72105 0 4
98048: PUSH
98049: LD_INT 4
98051: ARRAY
98052: ST_TO_ADDR
// end ;
98053: LD_VAR 0 3
98057: RET
// export function PlayerSeeMe ( unit ) ; begin
98058: LD_INT 0
98060: PPUSH
// result := See ( your_side , unit ) ;
98061: LD_ADDR_VAR 0 2
98065: PUSH
98066: LD_OWVAR 2
98070: PPUSH
98071: LD_VAR 0 1
98075: PPUSH
98076: CALL_OW 292
98080: ST_TO_ADDR
// end ;
98081: LD_VAR 0 2
98085: RET
// export function ReverseDir ( unit ) ; begin
98086: LD_INT 0
98088: PPUSH
// if not unit then
98089: LD_VAR 0 1
98093: NOT
98094: IFFALSE 98098
// exit ;
98096: GO 98144
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
98098: LD_ADDR_VAR 0 2
98102: PUSH
98103: LD_INT 3
98105: PUSH
98106: LD_INT 4
98108: PUSH
98109: LD_INT 5
98111: PUSH
98112: LD_INT 0
98114: PUSH
98115: LD_INT 1
98117: PUSH
98118: LD_INT 2
98120: PUSH
98121: EMPTY
98122: LIST
98123: LIST
98124: LIST
98125: LIST
98126: LIST
98127: LIST
98128: PUSH
98129: LD_VAR 0 1
98133: PPUSH
98134: CALL_OW 254
98138: PUSH
98139: LD_INT 1
98141: PLUS
98142: ARRAY
98143: ST_TO_ADDR
// end ;
98144: LD_VAR 0 2
98148: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
98149: LD_INT 0
98151: PPUSH
98152: PPUSH
98153: PPUSH
98154: PPUSH
98155: PPUSH
// if not hexes then
98156: LD_VAR 0 2
98160: NOT
98161: IFFALSE 98165
// exit ;
98163: GO 98313
// dist := 9999 ;
98165: LD_ADDR_VAR 0 5
98169: PUSH
98170: LD_INT 9999
98172: ST_TO_ADDR
// for i = 1 to hexes do
98173: LD_ADDR_VAR 0 4
98177: PUSH
98178: DOUBLE
98179: LD_INT 1
98181: DEC
98182: ST_TO_ADDR
98183: LD_VAR 0 2
98187: PUSH
98188: FOR_TO
98189: IFFALSE 98301
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
98191: LD_VAR 0 1
98195: PPUSH
98196: LD_VAR 0 2
98200: PUSH
98201: LD_VAR 0 4
98205: ARRAY
98206: PUSH
98207: LD_INT 1
98209: ARRAY
98210: PPUSH
98211: LD_VAR 0 2
98215: PUSH
98216: LD_VAR 0 4
98220: ARRAY
98221: PUSH
98222: LD_INT 2
98224: ARRAY
98225: PPUSH
98226: CALL_OW 297
98230: PUSH
98231: LD_VAR 0 5
98235: LESS
98236: IFFALSE 98299
// begin hex := hexes [ i ] ;
98238: LD_ADDR_VAR 0 7
98242: PUSH
98243: LD_VAR 0 2
98247: PUSH
98248: LD_VAR 0 4
98252: ARRAY
98253: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
98254: LD_ADDR_VAR 0 5
98258: PUSH
98259: LD_VAR 0 1
98263: PPUSH
98264: LD_VAR 0 2
98268: PUSH
98269: LD_VAR 0 4
98273: ARRAY
98274: PUSH
98275: LD_INT 1
98277: ARRAY
98278: PPUSH
98279: LD_VAR 0 2
98283: PUSH
98284: LD_VAR 0 4
98288: ARRAY
98289: PUSH
98290: LD_INT 2
98292: ARRAY
98293: PPUSH
98294: CALL_OW 297
98298: ST_TO_ADDR
// end ; end ;
98299: GO 98188
98301: POP
98302: POP
// result := hex ;
98303: LD_ADDR_VAR 0 3
98307: PUSH
98308: LD_VAR 0 7
98312: ST_TO_ADDR
// end ;
98313: LD_VAR 0 3
98317: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
98318: LD_INT 0
98320: PPUSH
98321: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
98322: LD_VAR 0 1
98326: NOT
98327: PUSH
98328: LD_VAR 0 1
98332: PUSH
98333: LD_INT 21
98335: PUSH
98336: LD_INT 2
98338: PUSH
98339: EMPTY
98340: LIST
98341: LIST
98342: PUSH
98343: LD_INT 23
98345: PUSH
98346: LD_INT 2
98348: PUSH
98349: EMPTY
98350: LIST
98351: LIST
98352: PUSH
98353: EMPTY
98354: LIST
98355: LIST
98356: PPUSH
98357: CALL_OW 69
98361: IN
98362: NOT
98363: OR
98364: IFFALSE 98368
// exit ;
98366: GO 98415
// for i = 1 to 3 do
98368: LD_ADDR_VAR 0 3
98372: PUSH
98373: DOUBLE
98374: LD_INT 1
98376: DEC
98377: ST_TO_ADDR
98378: LD_INT 3
98380: PUSH
98381: FOR_TO
98382: IFFALSE 98413
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
98384: LD_VAR 0 1
98388: PPUSH
98389: CALL_OW 250
98393: PPUSH
98394: LD_VAR 0 1
98398: PPUSH
98399: CALL_OW 251
98403: PPUSH
98404: LD_INT 1
98406: PPUSH
98407: CALL_OW 453
98411: GO 98381
98413: POP
98414: POP
// end ;
98415: LD_VAR 0 2
98419: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
98420: LD_INT 0
98422: PPUSH
98423: PPUSH
98424: PPUSH
98425: PPUSH
98426: PPUSH
98427: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
98428: LD_VAR 0 1
98432: NOT
98433: PUSH
98434: LD_VAR 0 2
98438: NOT
98439: OR
98440: PUSH
98441: LD_VAR 0 1
98445: PPUSH
98446: CALL_OW 314
98450: OR
98451: IFFALSE 98455
// exit ;
98453: GO 98896
// x := GetX ( enemy_unit ) ;
98455: LD_ADDR_VAR 0 7
98459: PUSH
98460: LD_VAR 0 2
98464: PPUSH
98465: CALL_OW 250
98469: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
98470: LD_ADDR_VAR 0 8
98474: PUSH
98475: LD_VAR 0 2
98479: PPUSH
98480: CALL_OW 251
98484: ST_TO_ADDR
// if not x or not y then
98485: LD_VAR 0 7
98489: NOT
98490: PUSH
98491: LD_VAR 0 8
98495: NOT
98496: OR
98497: IFFALSE 98501
// exit ;
98499: GO 98896
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
98501: LD_ADDR_VAR 0 6
98505: PUSH
98506: LD_VAR 0 7
98510: PPUSH
98511: LD_INT 0
98513: PPUSH
98514: LD_INT 4
98516: PPUSH
98517: CALL_OW 272
98521: PUSH
98522: LD_VAR 0 8
98526: PPUSH
98527: LD_INT 0
98529: PPUSH
98530: LD_INT 4
98532: PPUSH
98533: CALL_OW 273
98537: PUSH
98538: EMPTY
98539: LIST
98540: LIST
98541: PUSH
98542: LD_VAR 0 7
98546: PPUSH
98547: LD_INT 1
98549: PPUSH
98550: LD_INT 4
98552: PPUSH
98553: CALL_OW 272
98557: PUSH
98558: LD_VAR 0 8
98562: PPUSH
98563: LD_INT 1
98565: PPUSH
98566: LD_INT 4
98568: PPUSH
98569: CALL_OW 273
98573: PUSH
98574: EMPTY
98575: LIST
98576: LIST
98577: PUSH
98578: LD_VAR 0 7
98582: PPUSH
98583: LD_INT 2
98585: PPUSH
98586: LD_INT 4
98588: PPUSH
98589: CALL_OW 272
98593: PUSH
98594: LD_VAR 0 8
98598: PPUSH
98599: LD_INT 2
98601: PPUSH
98602: LD_INT 4
98604: PPUSH
98605: CALL_OW 273
98609: PUSH
98610: EMPTY
98611: LIST
98612: LIST
98613: PUSH
98614: LD_VAR 0 7
98618: PPUSH
98619: LD_INT 3
98621: PPUSH
98622: LD_INT 4
98624: PPUSH
98625: CALL_OW 272
98629: PUSH
98630: LD_VAR 0 8
98634: PPUSH
98635: LD_INT 3
98637: PPUSH
98638: LD_INT 4
98640: PPUSH
98641: CALL_OW 273
98645: PUSH
98646: EMPTY
98647: LIST
98648: LIST
98649: PUSH
98650: LD_VAR 0 7
98654: PPUSH
98655: LD_INT 4
98657: PPUSH
98658: LD_INT 4
98660: PPUSH
98661: CALL_OW 272
98665: PUSH
98666: LD_VAR 0 8
98670: PPUSH
98671: LD_INT 4
98673: PPUSH
98674: LD_INT 4
98676: PPUSH
98677: CALL_OW 273
98681: PUSH
98682: EMPTY
98683: LIST
98684: LIST
98685: PUSH
98686: LD_VAR 0 7
98690: PPUSH
98691: LD_INT 5
98693: PPUSH
98694: LD_INT 4
98696: PPUSH
98697: CALL_OW 272
98701: PUSH
98702: LD_VAR 0 8
98706: PPUSH
98707: LD_INT 5
98709: PPUSH
98710: LD_INT 4
98712: PPUSH
98713: CALL_OW 273
98717: PUSH
98718: EMPTY
98719: LIST
98720: LIST
98721: PUSH
98722: EMPTY
98723: LIST
98724: LIST
98725: LIST
98726: LIST
98727: LIST
98728: LIST
98729: ST_TO_ADDR
// for i = tmp downto 1 do
98730: LD_ADDR_VAR 0 4
98734: PUSH
98735: DOUBLE
98736: LD_VAR 0 6
98740: INC
98741: ST_TO_ADDR
98742: LD_INT 1
98744: PUSH
98745: FOR_DOWNTO
98746: IFFALSE 98847
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
98748: LD_VAR 0 6
98752: PUSH
98753: LD_VAR 0 4
98757: ARRAY
98758: PUSH
98759: LD_INT 1
98761: ARRAY
98762: PPUSH
98763: LD_VAR 0 6
98767: PUSH
98768: LD_VAR 0 4
98772: ARRAY
98773: PUSH
98774: LD_INT 2
98776: ARRAY
98777: PPUSH
98778: CALL_OW 488
98782: NOT
98783: PUSH
98784: LD_VAR 0 6
98788: PUSH
98789: LD_VAR 0 4
98793: ARRAY
98794: PUSH
98795: LD_INT 1
98797: ARRAY
98798: PPUSH
98799: LD_VAR 0 6
98803: PUSH
98804: LD_VAR 0 4
98808: ARRAY
98809: PUSH
98810: LD_INT 2
98812: ARRAY
98813: PPUSH
98814: CALL_OW 428
98818: PUSH
98819: LD_INT 0
98821: NONEQUAL
98822: OR
98823: IFFALSE 98845
// tmp := Delete ( tmp , i ) ;
98825: LD_ADDR_VAR 0 6
98829: PUSH
98830: LD_VAR 0 6
98834: PPUSH
98835: LD_VAR 0 4
98839: PPUSH
98840: CALL_OW 3
98844: ST_TO_ADDR
98845: GO 98745
98847: POP
98848: POP
// j := GetClosestHex ( unit , tmp ) ;
98849: LD_ADDR_VAR 0 5
98853: PUSH
98854: LD_VAR 0 1
98858: PPUSH
98859: LD_VAR 0 6
98863: PPUSH
98864: CALL 98149 0 2
98868: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
98869: LD_VAR 0 1
98873: PPUSH
98874: LD_VAR 0 5
98878: PUSH
98879: LD_INT 1
98881: ARRAY
98882: PPUSH
98883: LD_VAR 0 5
98887: PUSH
98888: LD_INT 2
98890: ARRAY
98891: PPUSH
98892: CALL_OW 111
// end ;
98896: LD_VAR 0 3
98900: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
98901: LD_INT 0
98903: PPUSH
98904: PPUSH
98905: PPUSH
// uc_side = 0 ;
98906: LD_ADDR_OWVAR 20
98910: PUSH
98911: LD_INT 0
98913: ST_TO_ADDR
// uc_nation = 0 ;
98914: LD_ADDR_OWVAR 21
98918: PUSH
98919: LD_INT 0
98921: ST_TO_ADDR
// InitHc ;
98922: CALL_OW 19
// InitVc ;
98926: CALL_OW 20
// if mastodonts then
98930: LD_VAR 0 6
98934: IFFALSE 99001
// for i = 1 to mastodonts do
98936: LD_ADDR_VAR 0 11
98940: PUSH
98941: DOUBLE
98942: LD_INT 1
98944: DEC
98945: ST_TO_ADDR
98946: LD_VAR 0 6
98950: PUSH
98951: FOR_TO
98952: IFFALSE 98999
// begin vc_chassis := 31 ;
98954: LD_ADDR_OWVAR 37
98958: PUSH
98959: LD_INT 31
98961: ST_TO_ADDR
// vc_control := control_rider ;
98962: LD_ADDR_OWVAR 38
98966: PUSH
98967: LD_INT 4
98969: ST_TO_ADDR
// animal := CreateVehicle ;
98970: LD_ADDR_VAR 0 12
98974: PUSH
98975: CALL_OW 45
98979: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
98980: LD_VAR 0 12
98984: PPUSH
98985: LD_VAR 0 8
98989: PPUSH
98990: LD_INT 0
98992: PPUSH
98993: CALL 105746 0 3
// end ;
98997: GO 98951
98999: POP
99000: POP
// if horses then
99001: LD_VAR 0 5
99005: IFFALSE 99072
// for i = 1 to horses do
99007: LD_ADDR_VAR 0 11
99011: PUSH
99012: DOUBLE
99013: LD_INT 1
99015: DEC
99016: ST_TO_ADDR
99017: LD_VAR 0 5
99021: PUSH
99022: FOR_TO
99023: IFFALSE 99070
// begin hc_class := 21 ;
99025: LD_ADDR_OWVAR 28
99029: PUSH
99030: LD_INT 21
99032: ST_TO_ADDR
// hc_gallery :=  ;
99033: LD_ADDR_OWVAR 33
99037: PUSH
99038: LD_STRING 
99040: ST_TO_ADDR
// animal := CreateHuman ;
99041: LD_ADDR_VAR 0 12
99045: PUSH
99046: CALL_OW 44
99050: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99051: LD_VAR 0 12
99055: PPUSH
99056: LD_VAR 0 8
99060: PPUSH
99061: LD_INT 0
99063: PPUSH
99064: CALL 105746 0 3
// end ;
99068: GO 99022
99070: POP
99071: POP
// if birds then
99072: LD_VAR 0 1
99076: IFFALSE 99143
// for i = 1 to birds do
99078: LD_ADDR_VAR 0 11
99082: PUSH
99083: DOUBLE
99084: LD_INT 1
99086: DEC
99087: ST_TO_ADDR
99088: LD_VAR 0 1
99092: PUSH
99093: FOR_TO
99094: IFFALSE 99141
// begin hc_class = 18 ;
99096: LD_ADDR_OWVAR 28
99100: PUSH
99101: LD_INT 18
99103: ST_TO_ADDR
// hc_gallery =  ;
99104: LD_ADDR_OWVAR 33
99108: PUSH
99109: LD_STRING 
99111: ST_TO_ADDR
// animal := CreateHuman ;
99112: LD_ADDR_VAR 0 12
99116: PUSH
99117: CALL_OW 44
99121: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99122: LD_VAR 0 12
99126: PPUSH
99127: LD_VAR 0 8
99131: PPUSH
99132: LD_INT 0
99134: PPUSH
99135: CALL 105746 0 3
// end ;
99139: GO 99093
99141: POP
99142: POP
// if tigers then
99143: LD_VAR 0 2
99147: IFFALSE 99231
// for i = 1 to tigers do
99149: LD_ADDR_VAR 0 11
99153: PUSH
99154: DOUBLE
99155: LD_INT 1
99157: DEC
99158: ST_TO_ADDR
99159: LD_VAR 0 2
99163: PUSH
99164: FOR_TO
99165: IFFALSE 99229
// begin hc_class = class_tiger ;
99167: LD_ADDR_OWVAR 28
99171: PUSH
99172: LD_INT 14
99174: ST_TO_ADDR
// hc_gallery =  ;
99175: LD_ADDR_OWVAR 33
99179: PUSH
99180: LD_STRING 
99182: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
99183: LD_ADDR_OWVAR 35
99187: PUSH
99188: LD_INT 7
99190: NEG
99191: PPUSH
99192: LD_INT 7
99194: PPUSH
99195: CALL_OW 12
99199: ST_TO_ADDR
// animal := CreateHuman ;
99200: LD_ADDR_VAR 0 12
99204: PUSH
99205: CALL_OW 44
99209: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99210: LD_VAR 0 12
99214: PPUSH
99215: LD_VAR 0 8
99219: PPUSH
99220: LD_INT 0
99222: PPUSH
99223: CALL 105746 0 3
// end ;
99227: GO 99164
99229: POP
99230: POP
// if apemans then
99231: LD_VAR 0 3
99235: IFFALSE 99358
// for i = 1 to apemans do
99237: LD_ADDR_VAR 0 11
99241: PUSH
99242: DOUBLE
99243: LD_INT 1
99245: DEC
99246: ST_TO_ADDR
99247: LD_VAR 0 3
99251: PUSH
99252: FOR_TO
99253: IFFALSE 99356
// begin hc_class = class_apeman ;
99255: LD_ADDR_OWVAR 28
99259: PUSH
99260: LD_INT 12
99262: ST_TO_ADDR
// hc_gallery =  ;
99263: LD_ADDR_OWVAR 33
99267: PUSH
99268: LD_STRING 
99270: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
99271: LD_ADDR_OWVAR 35
99275: PUSH
99276: LD_INT 5
99278: NEG
99279: PPUSH
99280: LD_INT 5
99282: PPUSH
99283: CALL_OW 12
99287: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
99288: LD_ADDR_OWVAR 31
99292: PUSH
99293: LD_INT 1
99295: PPUSH
99296: LD_INT 3
99298: PPUSH
99299: CALL_OW 12
99303: PUSH
99304: LD_INT 1
99306: PPUSH
99307: LD_INT 3
99309: PPUSH
99310: CALL_OW 12
99314: PUSH
99315: LD_INT 0
99317: PUSH
99318: LD_INT 0
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: LIST
99325: LIST
99326: ST_TO_ADDR
// animal := CreateHuman ;
99327: LD_ADDR_VAR 0 12
99331: PUSH
99332: CALL_OW 44
99336: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99337: LD_VAR 0 12
99341: PPUSH
99342: LD_VAR 0 8
99346: PPUSH
99347: LD_INT 0
99349: PPUSH
99350: CALL 105746 0 3
// end ;
99354: GO 99252
99356: POP
99357: POP
// if enchidnas then
99358: LD_VAR 0 4
99362: IFFALSE 99429
// for i = 1 to enchidnas do
99364: LD_ADDR_VAR 0 11
99368: PUSH
99369: DOUBLE
99370: LD_INT 1
99372: DEC
99373: ST_TO_ADDR
99374: LD_VAR 0 4
99378: PUSH
99379: FOR_TO
99380: IFFALSE 99427
// begin hc_class = 13 ;
99382: LD_ADDR_OWVAR 28
99386: PUSH
99387: LD_INT 13
99389: ST_TO_ADDR
// hc_gallery =  ;
99390: LD_ADDR_OWVAR 33
99394: PUSH
99395: LD_STRING 
99397: ST_TO_ADDR
// animal := CreateHuman ;
99398: LD_ADDR_VAR 0 12
99402: PUSH
99403: CALL_OW 44
99407: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
99408: LD_VAR 0 12
99412: PPUSH
99413: LD_VAR 0 8
99417: PPUSH
99418: LD_INT 0
99420: PPUSH
99421: CALL 105746 0 3
// end ;
99425: GO 99379
99427: POP
99428: POP
// if fishes then
99429: LD_VAR 0 7
99433: IFFALSE 99500
// for i = 1 to fishes do
99435: LD_ADDR_VAR 0 11
99439: PUSH
99440: DOUBLE
99441: LD_INT 1
99443: DEC
99444: ST_TO_ADDR
99445: LD_VAR 0 7
99449: PUSH
99450: FOR_TO
99451: IFFALSE 99498
// begin hc_class = 20 ;
99453: LD_ADDR_OWVAR 28
99457: PUSH
99458: LD_INT 20
99460: ST_TO_ADDR
// hc_gallery =  ;
99461: LD_ADDR_OWVAR 33
99465: PUSH
99466: LD_STRING 
99468: ST_TO_ADDR
// animal := CreateHuman ;
99469: LD_ADDR_VAR 0 12
99473: PUSH
99474: CALL_OW 44
99478: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
99479: LD_VAR 0 12
99483: PPUSH
99484: LD_VAR 0 9
99488: PPUSH
99489: LD_INT 0
99491: PPUSH
99492: CALL 105746 0 3
// end ;
99496: GO 99450
99498: POP
99499: POP
// end ;
99500: LD_VAR 0 10
99504: RET
// export function WantHeal ( sci , unit ) ; begin
99505: LD_INT 0
99507: PPUSH
// if GetTaskList ( sci ) > 0 then
99508: LD_VAR 0 1
99512: PPUSH
99513: CALL_OW 437
99517: PUSH
99518: LD_INT 0
99520: GREATER
99521: IFFALSE 99591
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
99523: LD_VAR 0 1
99527: PPUSH
99528: CALL_OW 437
99532: PUSH
99533: LD_INT 1
99535: ARRAY
99536: PUSH
99537: LD_INT 1
99539: ARRAY
99540: PUSH
99541: LD_STRING l
99543: EQUAL
99544: PUSH
99545: LD_VAR 0 1
99549: PPUSH
99550: CALL_OW 437
99554: PUSH
99555: LD_INT 1
99557: ARRAY
99558: PUSH
99559: LD_INT 4
99561: ARRAY
99562: PUSH
99563: LD_VAR 0 2
99567: EQUAL
99568: AND
99569: IFFALSE 99581
// result := true else
99571: LD_ADDR_VAR 0 3
99575: PUSH
99576: LD_INT 1
99578: ST_TO_ADDR
99579: GO 99589
// result := false ;
99581: LD_ADDR_VAR 0 3
99585: PUSH
99586: LD_INT 0
99588: ST_TO_ADDR
// end else
99589: GO 99599
// result := false ;
99591: LD_ADDR_VAR 0 3
99595: PUSH
99596: LD_INT 0
99598: ST_TO_ADDR
// end ;
99599: LD_VAR 0 3
99603: RET
// export function HealTarget ( sci ) ; begin
99604: LD_INT 0
99606: PPUSH
// if not sci then
99607: LD_VAR 0 1
99611: NOT
99612: IFFALSE 99616
// exit ;
99614: GO 99681
// result := 0 ;
99616: LD_ADDR_VAR 0 2
99620: PUSH
99621: LD_INT 0
99623: ST_TO_ADDR
// if GetTaskList ( sci ) then
99624: LD_VAR 0 1
99628: PPUSH
99629: CALL_OW 437
99633: IFFALSE 99681
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
99635: LD_VAR 0 1
99639: PPUSH
99640: CALL_OW 437
99644: PUSH
99645: LD_INT 1
99647: ARRAY
99648: PUSH
99649: LD_INT 1
99651: ARRAY
99652: PUSH
99653: LD_STRING l
99655: EQUAL
99656: IFFALSE 99681
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
99658: LD_ADDR_VAR 0 2
99662: PUSH
99663: LD_VAR 0 1
99667: PPUSH
99668: CALL_OW 437
99672: PUSH
99673: LD_INT 1
99675: ARRAY
99676: PUSH
99677: LD_INT 4
99679: ARRAY
99680: ST_TO_ADDR
// end ;
99681: LD_VAR 0 2
99685: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99686: LD_INT 0
99688: PPUSH
99689: PPUSH
99690: PPUSH
99691: PPUSH
99692: PPUSH
99693: PPUSH
99694: PPUSH
99695: PPUSH
99696: PPUSH
99697: PPUSH
99698: PPUSH
99699: PPUSH
99700: PPUSH
99701: PPUSH
99702: PPUSH
99703: PPUSH
99704: PPUSH
99705: PPUSH
99706: PPUSH
99707: PPUSH
99708: PPUSH
99709: PPUSH
99710: PPUSH
99711: PPUSH
99712: PPUSH
99713: PPUSH
99714: PPUSH
99715: PPUSH
99716: PPUSH
99717: PPUSH
99718: PPUSH
99719: PPUSH
99720: PPUSH
99721: PPUSH
// if not list then
99722: LD_VAR 0 1
99726: NOT
99727: IFFALSE 99731
// exit ;
99729: GO 104357
// base := list [ 1 ] ;
99731: LD_ADDR_VAR 0 3
99735: PUSH
99736: LD_VAR 0 1
99740: PUSH
99741: LD_INT 1
99743: ARRAY
99744: ST_TO_ADDR
// group := list [ 2 ] ;
99745: LD_ADDR_VAR 0 4
99749: PUSH
99750: LD_VAR 0 1
99754: PUSH
99755: LD_INT 2
99757: ARRAY
99758: ST_TO_ADDR
// path := list [ 3 ] ;
99759: LD_ADDR_VAR 0 5
99763: PUSH
99764: LD_VAR 0 1
99768: PUSH
99769: LD_INT 3
99771: ARRAY
99772: ST_TO_ADDR
// flags := list [ 4 ] ;
99773: LD_ADDR_VAR 0 6
99777: PUSH
99778: LD_VAR 0 1
99782: PUSH
99783: LD_INT 4
99785: ARRAY
99786: ST_TO_ADDR
// mined := [ ] ;
99787: LD_ADDR_VAR 0 27
99791: PUSH
99792: EMPTY
99793: ST_TO_ADDR
// bombed := [ ] ;
99794: LD_ADDR_VAR 0 28
99798: PUSH
99799: EMPTY
99800: ST_TO_ADDR
// healers := [ ] ;
99801: LD_ADDR_VAR 0 31
99805: PUSH
99806: EMPTY
99807: ST_TO_ADDR
// to_heal := [ ] ;
99808: LD_ADDR_VAR 0 30
99812: PUSH
99813: EMPTY
99814: ST_TO_ADDR
// repairs := [ ] ;
99815: LD_ADDR_VAR 0 33
99819: PUSH
99820: EMPTY
99821: ST_TO_ADDR
// to_repair := [ ] ;
99822: LD_ADDR_VAR 0 32
99826: PUSH
99827: EMPTY
99828: ST_TO_ADDR
// if not group or not path then
99829: LD_VAR 0 4
99833: NOT
99834: PUSH
99835: LD_VAR 0 5
99839: NOT
99840: OR
99841: IFFALSE 99845
// exit ;
99843: GO 104357
// side := GetSide ( group [ 1 ] ) ;
99845: LD_ADDR_VAR 0 35
99849: PUSH
99850: LD_VAR 0 4
99854: PUSH
99855: LD_INT 1
99857: ARRAY
99858: PPUSH
99859: CALL_OW 255
99863: ST_TO_ADDR
// if flags then
99864: LD_VAR 0 6
99868: IFFALSE 100012
// begin f_ignore_area := flags [ 1 ] ;
99870: LD_ADDR_VAR 0 17
99874: PUSH
99875: LD_VAR 0 6
99879: PUSH
99880: LD_INT 1
99882: ARRAY
99883: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
99884: LD_ADDR_VAR 0 18
99888: PUSH
99889: LD_VAR 0 6
99893: PUSH
99894: LD_INT 2
99896: ARRAY
99897: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
99898: LD_ADDR_VAR 0 19
99902: PUSH
99903: LD_VAR 0 6
99907: PUSH
99908: LD_INT 3
99910: ARRAY
99911: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
99912: LD_ADDR_VAR 0 20
99916: PUSH
99917: LD_VAR 0 6
99921: PUSH
99922: LD_INT 4
99924: ARRAY
99925: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
99926: LD_ADDR_VAR 0 21
99930: PUSH
99931: LD_VAR 0 6
99935: PUSH
99936: LD_INT 5
99938: ARRAY
99939: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
99940: LD_ADDR_VAR 0 22
99944: PUSH
99945: LD_VAR 0 6
99949: PUSH
99950: LD_INT 6
99952: ARRAY
99953: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
99954: LD_ADDR_VAR 0 23
99958: PUSH
99959: LD_VAR 0 6
99963: PUSH
99964: LD_INT 7
99966: ARRAY
99967: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
99968: LD_ADDR_VAR 0 24
99972: PUSH
99973: LD_VAR 0 6
99977: PUSH
99978: LD_INT 8
99980: ARRAY
99981: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
99982: LD_ADDR_VAR 0 25
99986: PUSH
99987: LD_VAR 0 6
99991: PUSH
99992: LD_INT 9
99994: ARRAY
99995: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
99996: LD_ADDR_VAR 0 26
100000: PUSH
100001: LD_VAR 0 6
100005: PUSH
100006: LD_INT 10
100008: ARRAY
100009: ST_TO_ADDR
// end else
100010: GO 100092
// begin f_ignore_area := false ;
100012: LD_ADDR_VAR 0 17
100016: PUSH
100017: LD_INT 0
100019: ST_TO_ADDR
// f_capture := false ;
100020: LD_ADDR_VAR 0 18
100024: PUSH
100025: LD_INT 0
100027: ST_TO_ADDR
// f_ignore_civ := false ;
100028: LD_ADDR_VAR 0 19
100032: PUSH
100033: LD_INT 0
100035: ST_TO_ADDR
// f_murder := false ;
100036: LD_ADDR_VAR 0 20
100040: PUSH
100041: LD_INT 0
100043: ST_TO_ADDR
// f_mines := false ;
100044: LD_ADDR_VAR 0 21
100048: PUSH
100049: LD_INT 0
100051: ST_TO_ADDR
// f_repair := false ;
100052: LD_ADDR_VAR 0 22
100056: PUSH
100057: LD_INT 0
100059: ST_TO_ADDR
// f_heal := false ;
100060: LD_ADDR_VAR 0 23
100064: PUSH
100065: LD_INT 0
100067: ST_TO_ADDR
// f_spacetime := false ;
100068: LD_ADDR_VAR 0 24
100072: PUSH
100073: LD_INT 0
100075: ST_TO_ADDR
// f_attack_depot := false ;
100076: LD_ADDR_VAR 0 25
100080: PUSH
100081: LD_INT 0
100083: ST_TO_ADDR
// f_crawl := false ;
100084: LD_ADDR_VAR 0 26
100088: PUSH
100089: LD_INT 0
100091: ST_TO_ADDR
// end ; if f_heal then
100092: LD_VAR 0 23
100096: IFFALSE 100123
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100098: LD_ADDR_VAR 0 31
100102: PUSH
100103: LD_VAR 0 4
100107: PPUSH
100108: LD_INT 25
100110: PUSH
100111: LD_INT 4
100113: PUSH
100114: EMPTY
100115: LIST
100116: LIST
100117: PPUSH
100118: CALL_OW 72
100122: ST_TO_ADDR
// if f_repair then
100123: LD_VAR 0 22
100127: IFFALSE 100154
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100129: LD_ADDR_VAR 0 33
100133: PUSH
100134: LD_VAR 0 4
100138: PPUSH
100139: LD_INT 25
100141: PUSH
100142: LD_INT 3
100144: PUSH
100145: EMPTY
100146: LIST
100147: LIST
100148: PPUSH
100149: CALL_OW 72
100153: ST_TO_ADDR
// units_path := [ ] ;
100154: LD_ADDR_VAR 0 16
100158: PUSH
100159: EMPTY
100160: ST_TO_ADDR
// for i = 1 to group do
100161: LD_ADDR_VAR 0 7
100165: PUSH
100166: DOUBLE
100167: LD_INT 1
100169: DEC
100170: ST_TO_ADDR
100171: LD_VAR 0 4
100175: PUSH
100176: FOR_TO
100177: IFFALSE 100206
// units_path := Replace ( units_path , i , path ) ;
100179: LD_ADDR_VAR 0 16
100183: PUSH
100184: LD_VAR 0 16
100188: PPUSH
100189: LD_VAR 0 7
100193: PPUSH
100194: LD_VAR 0 5
100198: PPUSH
100199: CALL_OW 1
100203: ST_TO_ADDR
100204: GO 100176
100206: POP
100207: POP
// repeat for i = group downto 1 do
100208: LD_ADDR_VAR 0 7
100212: PUSH
100213: DOUBLE
100214: LD_VAR 0 4
100218: INC
100219: ST_TO_ADDR
100220: LD_INT 1
100222: PUSH
100223: FOR_DOWNTO
100224: IFFALSE 104320
// begin wait ( 5 ) ;
100226: LD_INT 5
100228: PPUSH
100229: CALL_OW 67
// tmp := [ ] ;
100233: LD_ADDR_VAR 0 14
100237: PUSH
100238: EMPTY
100239: ST_TO_ADDR
// attacking := false ;
100240: LD_ADDR_VAR 0 29
100244: PUSH
100245: LD_INT 0
100247: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100248: LD_VAR 0 4
100252: PUSH
100253: LD_VAR 0 7
100257: ARRAY
100258: PPUSH
100259: CALL_OW 301
100263: PUSH
100264: LD_VAR 0 4
100268: PUSH
100269: LD_VAR 0 7
100273: ARRAY
100274: NOT
100275: OR
100276: IFFALSE 100385
// begin if GetType ( group [ i ] ) = unit_human then
100278: LD_VAR 0 4
100282: PUSH
100283: LD_VAR 0 7
100287: ARRAY
100288: PPUSH
100289: CALL_OW 247
100293: PUSH
100294: LD_INT 1
100296: EQUAL
100297: IFFALSE 100343
// begin to_heal := to_heal diff group [ i ] ;
100299: LD_ADDR_VAR 0 30
100303: PUSH
100304: LD_VAR 0 30
100308: PUSH
100309: LD_VAR 0 4
100313: PUSH
100314: LD_VAR 0 7
100318: ARRAY
100319: DIFF
100320: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100321: LD_ADDR_VAR 0 31
100325: PUSH
100326: LD_VAR 0 31
100330: PUSH
100331: LD_VAR 0 4
100335: PUSH
100336: LD_VAR 0 7
100340: ARRAY
100341: DIFF
100342: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100343: LD_ADDR_VAR 0 4
100347: PUSH
100348: LD_VAR 0 4
100352: PPUSH
100353: LD_VAR 0 7
100357: PPUSH
100358: CALL_OW 3
100362: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100363: LD_ADDR_VAR 0 16
100367: PUSH
100368: LD_VAR 0 16
100372: PPUSH
100373: LD_VAR 0 7
100377: PPUSH
100378: CALL_OW 3
100382: ST_TO_ADDR
// continue ;
100383: GO 100223
// end ; if f_repair then
100385: LD_VAR 0 22
100389: IFFALSE 100878
// begin if GetType ( group [ i ] ) = unit_vehicle then
100391: LD_VAR 0 4
100395: PUSH
100396: LD_VAR 0 7
100400: ARRAY
100401: PPUSH
100402: CALL_OW 247
100406: PUSH
100407: LD_INT 2
100409: EQUAL
100410: IFFALSE 100600
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100412: LD_VAR 0 4
100416: PUSH
100417: LD_VAR 0 7
100421: ARRAY
100422: PPUSH
100423: CALL_OW 256
100427: PUSH
100428: LD_INT 700
100430: LESS
100431: PUSH
100432: LD_VAR 0 4
100436: PUSH
100437: LD_VAR 0 7
100441: ARRAY
100442: PUSH
100443: LD_VAR 0 32
100447: IN
100448: NOT
100449: AND
100450: IFFALSE 100474
// to_repair := to_repair union group [ i ] ;
100452: LD_ADDR_VAR 0 32
100456: PUSH
100457: LD_VAR 0 32
100461: PUSH
100462: LD_VAR 0 4
100466: PUSH
100467: LD_VAR 0 7
100471: ARRAY
100472: UNION
100473: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100474: LD_VAR 0 4
100478: PUSH
100479: LD_VAR 0 7
100483: ARRAY
100484: PPUSH
100485: CALL_OW 256
100489: PUSH
100490: LD_INT 1000
100492: EQUAL
100493: PUSH
100494: LD_VAR 0 4
100498: PUSH
100499: LD_VAR 0 7
100503: ARRAY
100504: PUSH
100505: LD_VAR 0 32
100509: IN
100510: AND
100511: IFFALSE 100535
// to_repair := to_repair diff group [ i ] ;
100513: LD_ADDR_VAR 0 32
100517: PUSH
100518: LD_VAR 0 32
100522: PUSH
100523: LD_VAR 0 4
100527: PUSH
100528: LD_VAR 0 7
100532: ARRAY
100533: DIFF
100534: ST_TO_ADDR
// if group [ i ] in to_repair then
100535: LD_VAR 0 4
100539: PUSH
100540: LD_VAR 0 7
100544: ARRAY
100545: PUSH
100546: LD_VAR 0 32
100550: IN
100551: IFFALSE 100598
// begin if not IsInArea ( group [ i ] , f_repair ) then
100553: LD_VAR 0 4
100557: PUSH
100558: LD_VAR 0 7
100562: ARRAY
100563: PPUSH
100564: LD_VAR 0 22
100568: PPUSH
100569: CALL_OW 308
100573: NOT
100574: IFFALSE 100596
// ComMoveToArea ( group [ i ] , f_repair ) ;
100576: LD_VAR 0 4
100580: PUSH
100581: LD_VAR 0 7
100585: ARRAY
100586: PPUSH
100587: LD_VAR 0 22
100591: PPUSH
100592: CALL_OW 113
// continue ;
100596: GO 100223
// end ; end else
100598: GO 100878
// if group [ i ] in repairs then
100600: LD_VAR 0 4
100604: PUSH
100605: LD_VAR 0 7
100609: ARRAY
100610: PUSH
100611: LD_VAR 0 33
100615: IN
100616: IFFALSE 100878
// begin if IsInUnit ( group [ i ] ) then
100618: LD_VAR 0 4
100622: PUSH
100623: LD_VAR 0 7
100627: ARRAY
100628: PPUSH
100629: CALL_OW 310
100633: IFFALSE 100701
// begin z := IsInUnit ( group [ i ] ) ;
100635: LD_ADDR_VAR 0 13
100639: PUSH
100640: LD_VAR 0 4
100644: PUSH
100645: LD_VAR 0 7
100649: ARRAY
100650: PPUSH
100651: CALL_OW 310
100655: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100656: LD_VAR 0 13
100660: PUSH
100661: LD_VAR 0 32
100665: IN
100666: PUSH
100667: LD_VAR 0 13
100671: PPUSH
100672: LD_VAR 0 22
100676: PPUSH
100677: CALL_OW 308
100681: AND
100682: IFFALSE 100699
// ComExitVehicle ( group [ i ] ) ;
100684: LD_VAR 0 4
100688: PUSH
100689: LD_VAR 0 7
100693: ARRAY
100694: PPUSH
100695: CALL_OW 121
// end else
100699: GO 100878
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100701: LD_ADDR_VAR 0 13
100705: PUSH
100706: LD_VAR 0 4
100710: PPUSH
100711: LD_INT 95
100713: PUSH
100714: LD_VAR 0 22
100718: PUSH
100719: EMPTY
100720: LIST
100721: LIST
100722: PUSH
100723: LD_INT 58
100725: PUSH
100726: EMPTY
100727: LIST
100728: PUSH
100729: EMPTY
100730: LIST
100731: LIST
100732: PPUSH
100733: CALL_OW 72
100737: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
100738: LD_VAR 0 4
100742: PUSH
100743: LD_VAR 0 7
100747: ARRAY
100748: PPUSH
100749: CALL_OW 314
100753: NOT
100754: IFFALSE 100876
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
100756: LD_ADDR_VAR 0 10
100760: PUSH
100761: LD_VAR 0 13
100765: PPUSH
100766: LD_VAR 0 4
100770: PUSH
100771: LD_VAR 0 7
100775: ARRAY
100776: PPUSH
100777: CALL_OW 74
100781: ST_TO_ADDR
// if not x then
100782: LD_VAR 0 10
100786: NOT
100787: IFFALSE 100791
// continue ;
100789: GO 100223
// if GetLives ( x ) < 1000 then
100791: LD_VAR 0 10
100795: PPUSH
100796: CALL_OW 256
100800: PUSH
100801: LD_INT 1000
100803: LESS
100804: IFFALSE 100828
// ComRepairVehicle ( group [ i ] , x ) else
100806: LD_VAR 0 4
100810: PUSH
100811: LD_VAR 0 7
100815: ARRAY
100816: PPUSH
100817: LD_VAR 0 10
100821: PPUSH
100822: CALL_OW 129
100826: GO 100876
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
100828: LD_VAR 0 23
100832: PUSH
100833: LD_VAR 0 4
100837: PUSH
100838: LD_VAR 0 7
100842: ARRAY
100843: PPUSH
100844: CALL_OW 256
100848: PUSH
100849: LD_INT 1000
100851: LESS
100852: AND
100853: NOT
100854: IFFALSE 100876
// ComEnterUnit ( group [ i ] , x ) ;
100856: LD_VAR 0 4
100860: PUSH
100861: LD_VAR 0 7
100865: ARRAY
100866: PPUSH
100867: LD_VAR 0 10
100871: PPUSH
100872: CALL_OW 120
// end ; continue ;
100876: GO 100223
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
100878: LD_VAR 0 23
100882: PUSH
100883: LD_VAR 0 4
100887: PUSH
100888: LD_VAR 0 7
100892: ARRAY
100893: PPUSH
100894: CALL_OW 247
100898: PUSH
100899: LD_INT 1
100901: EQUAL
100902: AND
100903: IFFALSE 101381
// begin if group [ i ] in healers then
100905: LD_VAR 0 4
100909: PUSH
100910: LD_VAR 0 7
100914: ARRAY
100915: PUSH
100916: LD_VAR 0 31
100920: IN
100921: IFFALSE 101194
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
100923: LD_VAR 0 4
100927: PUSH
100928: LD_VAR 0 7
100932: ARRAY
100933: PPUSH
100934: LD_VAR 0 23
100938: PPUSH
100939: CALL_OW 308
100943: NOT
100944: PUSH
100945: LD_VAR 0 4
100949: PUSH
100950: LD_VAR 0 7
100954: ARRAY
100955: PPUSH
100956: CALL_OW 314
100960: NOT
100961: AND
100962: IFFALSE 100986
// ComMoveToArea ( group [ i ] , f_heal ) else
100964: LD_VAR 0 4
100968: PUSH
100969: LD_VAR 0 7
100973: ARRAY
100974: PPUSH
100975: LD_VAR 0 23
100979: PPUSH
100980: CALL_OW 113
100984: GO 101192
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
100986: LD_VAR 0 4
100990: PUSH
100991: LD_VAR 0 7
100995: ARRAY
100996: PPUSH
100997: CALL 99604 0 1
101001: PPUSH
101002: CALL_OW 256
101006: PUSH
101007: LD_INT 1000
101009: EQUAL
101010: IFFALSE 101029
// ComStop ( group [ i ] ) else
101012: LD_VAR 0 4
101016: PUSH
101017: LD_VAR 0 7
101021: ARRAY
101022: PPUSH
101023: CALL_OW 141
101027: GO 101192
// if not HasTask ( group [ i ] ) and to_heal then
101029: LD_VAR 0 4
101033: PUSH
101034: LD_VAR 0 7
101038: ARRAY
101039: PPUSH
101040: CALL_OW 314
101044: NOT
101045: PUSH
101046: LD_VAR 0 30
101050: AND
101051: IFFALSE 101192
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
101053: LD_ADDR_VAR 0 13
101057: PUSH
101058: LD_VAR 0 30
101062: PPUSH
101063: LD_INT 3
101065: PUSH
101066: LD_INT 54
101068: PUSH
101069: EMPTY
101070: LIST
101071: PUSH
101072: EMPTY
101073: LIST
101074: LIST
101075: PPUSH
101076: CALL_OW 72
101080: PPUSH
101081: LD_VAR 0 4
101085: PUSH
101086: LD_VAR 0 7
101090: ARRAY
101091: PPUSH
101092: CALL_OW 74
101096: ST_TO_ADDR
// if z then
101097: LD_VAR 0 13
101101: IFFALSE 101192
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101103: LD_INT 91
101105: PUSH
101106: LD_VAR 0 13
101110: PUSH
101111: LD_INT 10
101113: PUSH
101114: EMPTY
101115: LIST
101116: LIST
101117: LIST
101118: PUSH
101119: LD_INT 81
101121: PUSH
101122: LD_VAR 0 13
101126: PPUSH
101127: CALL_OW 255
101131: PUSH
101132: EMPTY
101133: LIST
101134: LIST
101135: PUSH
101136: EMPTY
101137: LIST
101138: LIST
101139: PPUSH
101140: CALL_OW 69
101144: PUSH
101145: LD_INT 0
101147: EQUAL
101148: IFFALSE 101172
// ComHeal ( group [ i ] , z ) else
101150: LD_VAR 0 4
101154: PUSH
101155: LD_VAR 0 7
101159: ARRAY
101160: PPUSH
101161: LD_VAR 0 13
101165: PPUSH
101166: CALL_OW 128
101170: GO 101192
// ComMoveToArea ( group [ i ] , f_heal ) ;
101172: LD_VAR 0 4
101176: PUSH
101177: LD_VAR 0 7
101181: ARRAY
101182: PPUSH
101183: LD_VAR 0 23
101187: PPUSH
101188: CALL_OW 113
// end ; continue ;
101192: GO 100223
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101194: LD_VAR 0 4
101198: PUSH
101199: LD_VAR 0 7
101203: ARRAY
101204: PPUSH
101205: CALL_OW 256
101209: PUSH
101210: LD_INT 700
101212: LESS
101213: PUSH
101214: LD_VAR 0 4
101218: PUSH
101219: LD_VAR 0 7
101223: ARRAY
101224: PUSH
101225: LD_VAR 0 30
101229: IN
101230: NOT
101231: AND
101232: IFFALSE 101256
// to_heal := to_heal union group [ i ] ;
101234: LD_ADDR_VAR 0 30
101238: PUSH
101239: LD_VAR 0 30
101243: PUSH
101244: LD_VAR 0 4
101248: PUSH
101249: LD_VAR 0 7
101253: ARRAY
101254: UNION
101255: ST_TO_ADDR
// if group [ i ] in to_heal then
101256: LD_VAR 0 4
101260: PUSH
101261: LD_VAR 0 7
101265: ARRAY
101266: PUSH
101267: LD_VAR 0 30
101271: IN
101272: IFFALSE 101381
// begin if GetLives ( group [ i ] ) = 1000 then
101274: LD_VAR 0 4
101278: PUSH
101279: LD_VAR 0 7
101283: ARRAY
101284: PPUSH
101285: CALL_OW 256
101289: PUSH
101290: LD_INT 1000
101292: EQUAL
101293: IFFALSE 101319
// to_heal := to_heal diff group [ i ] else
101295: LD_ADDR_VAR 0 30
101299: PUSH
101300: LD_VAR 0 30
101304: PUSH
101305: LD_VAR 0 4
101309: PUSH
101310: LD_VAR 0 7
101314: ARRAY
101315: DIFF
101316: ST_TO_ADDR
101317: GO 101381
// begin if not IsInArea ( group [ i ] , to_heal ) then
101319: LD_VAR 0 4
101323: PUSH
101324: LD_VAR 0 7
101328: ARRAY
101329: PPUSH
101330: LD_VAR 0 30
101334: PPUSH
101335: CALL_OW 308
101339: NOT
101340: IFFALSE 101364
// ComMoveToArea ( group [ i ] , f_heal ) else
101342: LD_VAR 0 4
101346: PUSH
101347: LD_VAR 0 7
101351: ARRAY
101352: PPUSH
101353: LD_VAR 0 23
101357: PPUSH
101358: CALL_OW 113
101362: GO 101379
// ComHold ( group [ i ] ) ;
101364: LD_VAR 0 4
101368: PUSH
101369: LD_VAR 0 7
101373: ARRAY
101374: PPUSH
101375: CALL_OW 140
// continue ;
101379: GO 100223
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101381: LD_VAR 0 4
101385: PUSH
101386: LD_VAR 0 7
101390: ARRAY
101391: PPUSH
101392: LD_INT 10
101394: PPUSH
101395: CALL 98001 0 2
101399: NOT
101400: PUSH
101401: LD_VAR 0 16
101405: PUSH
101406: LD_VAR 0 7
101410: ARRAY
101411: PUSH
101412: EMPTY
101413: EQUAL
101414: NOT
101415: AND
101416: IFFALSE 101682
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101418: LD_VAR 0 4
101422: PUSH
101423: LD_VAR 0 7
101427: ARRAY
101428: PPUSH
101429: CALL_OW 262
101433: PUSH
101434: LD_INT 1
101436: PUSH
101437: LD_INT 2
101439: PUSH
101440: EMPTY
101441: LIST
101442: LIST
101443: IN
101444: IFFALSE 101485
// if GetFuel ( group [ i ] ) < 10 then
101446: LD_VAR 0 4
101450: PUSH
101451: LD_VAR 0 7
101455: ARRAY
101456: PPUSH
101457: CALL_OW 261
101461: PUSH
101462: LD_INT 10
101464: LESS
101465: IFFALSE 101485
// SetFuel ( group [ i ] , 12 ) ;
101467: LD_VAR 0 4
101471: PUSH
101472: LD_VAR 0 7
101476: ARRAY
101477: PPUSH
101478: LD_INT 12
101480: PPUSH
101481: CALL_OW 240
// if units_path [ i ] then
101485: LD_VAR 0 16
101489: PUSH
101490: LD_VAR 0 7
101494: ARRAY
101495: IFFALSE 101680
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101497: LD_VAR 0 4
101501: PUSH
101502: LD_VAR 0 7
101506: ARRAY
101507: PPUSH
101508: LD_VAR 0 16
101512: PUSH
101513: LD_VAR 0 7
101517: ARRAY
101518: PUSH
101519: LD_INT 1
101521: ARRAY
101522: PUSH
101523: LD_INT 1
101525: ARRAY
101526: PPUSH
101527: LD_VAR 0 16
101531: PUSH
101532: LD_VAR 0 7
101536: ARRAY
101537: PUSH
101538: LD_INT 1
101540: ARRAY
101541: PUSH
101542: LD_INT 2
101544: ARRAY
101545: PPUSH
101546: CALL_OW 297
101550: PUSH
101551: LD_INT 6
101553: GREATER
101554: IFFALSE 101629
// begin if not HasTask ( group [ i ] ) then
101556: LD_VAR 0 4
101560: PUSH
101561: LD_VAR 0 7
101565: ARRAY
101566: PPUSH
101567: CALL_OW 314
101571: NOT
101572: IFFALSE 101627
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101574: LD_VAR 0 4
101578: PUSH
101579: LD_VAR 0 7
101583: ARRAY
101584: PPUSH
101585: LD_VAR 0 16
101589: PUSH
101590: LD_VAR 0 7
101594: ARRAY
101595: PUSH
101596: LD_INT 1
101598: ARRAY
101599: PUSH
101600: LD_INT 1
101602: ARRAY
101603: PPUSH
101604: LD_VAR 0 16
101608: PUSH
101609: LD_VAR 0 7
101613: ARRAY
101614: PUSH
101615: LD_INT 1
101617: ARRAY
101618: PUSH
101619: LD_INT 2
101621: ARRAY
101622: PPUSH
101623: CALL_OW 114
// end else
101627: GO 101680
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101629: LD_ADDR_VAR 0 15
101633: PUSH
101634: LD_VAR 0 16
101638: PUSH
101639: LD_VAR 0 7
101643: ARRAY
101644: PPUSH
101645: LD_INT 1
101647: PPUSH
101648: CALL_OW 3
101652: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101653: LD_ADDR_VAR 0 16
101657: PUSH
101658: LD_VAR 0 16
101662: PPUSH
101663: LD_VAR 0 7
101667: PPUSH
101668: LD_VAR 0 15
101672: PPUSH
101673: CALL_OW 1
101677: ST_TO_ADDR
// continue ;
101678: GO 100223
// end ; end ; end else
101680: GO 104318
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101682: LD_ADDR_VAR 0 14
101686: PUSH
101687: LD_INT 81
101689: PUSH
101690: LD_VAR 0 4
101694: PUSH
101695: LD_VAR 0 7
101699: ARRAY
101700: PPUSH
101701: CALL_OW 255
101705: PUSH
101706: EMPTY
101707: LIST
101708: LIST
101709: PPUSH
101710: CALL_OW 69
101714: ST_TO_ADDR
// if not tmp then
101715: LD_VAR 0 14
101719: NOT
101720: IFFALSE 101724
// continue ;
101722: GO 100223
// if f_ignore_area then
101724: LD_VAR 0 17
101728: IFFALSE 101816
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
101730: LD_ADDR_VAR 0 15
101734: PUSH
101735: LD_VAR 0 14
101739: PPUSH
101740: LD_INT 3
101742: PUSH
101743: LD_INT 92
101745: PUSH
101746: LD_VAR 0 17
101750: PUSH
101751: LD_INT 1
101753: ARRAY
101754: PUSH
101755: LD_VAR 0 17
101759: PUSH
101760: LD_INT 2
101762: ARRAY
101763: PUSH
101764: LD_VAR 0 17
101768: PUSH
101769: LD_INT 3
101771: ARRAY
101772: PUSH
101773: EMPTY
101774: LIST
101775: LIST
101776: LIST
101777: LIST
101778: PUSH
101779: EMPTY
101780: LIST
101781: LIST
101782: PPUSH
101783: CALL_OW 72
101787: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101788: LD_VAR 0 14
101792: PUSH
101793: LD_VAR 0 15
101797: DIFF
101798: IFFALSE 101816
// tmp := tmp diff tmp2 ;
101800: LD_ADDR_VAR 0 14
101804: PUSH
101805: LD_VAR 0 14
101809: PUSH
101810: LD_VAR 0 15
101814: DIFF
101815: ST_TO_ADDR
// end ; if not f_murder then
101816: LD_VAR 0 20
101820: NOT
101821: IFFALSE 101879
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
101823: LD_ADDR_VAR 0 15
101827: PUSH
101828: LD_VAR 0 14
101832: PPUSH
101833: LD_INT 3
101835: PUSH
101836: LD_INT 50
101838: PUSH
101839: EMPTY
101840: LIST
101841: PUSH
101842: EMPTY
101843: LIST
101844: LIST
101845: PPUSH
101846: CALL_OW 72
101850: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101851: LD_VAR 0 14
101855: PUSH
101856: LD_VAR 0 15
101860: DIFF
101861: IFFALSE 101879
// tmp := tmp diff tmp2 ;
101863: LD_ADDR_VAR 0 14
101867: PUSH
101868: LD_VAR 0 14
101872: PUSH
101873: LD_VAR 0 15
101877: DIFF
101878: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
101879: LD_ADDR_VAR 0 14
101883: PUSH
101884: LD_VAR 0 4
101888: PUSH
101889: LD_VAR 0 7
101893: ARRAY
101894: PPUSH
101895: LD_VAR 0 14
101899: PPUSH
101900: LD_INT 1
101902: PPUSH
101903: LD_INT 1
101905: PPUSH
101906: CALL 71644 0 4
101910: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
101911: LD_VAR 0 4
101915: PUSH
101916: LD_VAR 0 7
101920: ARRAY
101921: PPUSH
101922: CALL_OW 257
101926: PUSH
101927: LD_INT 1
101929: EQUAL
101930: IFFALSE 102378
// begin if WantPlant ( group [ i ] ) then
101932: LD_VAR 0 4
101936: PUSH
101937: LD_VAR 0 7
101941: ARRAY
101942: PPUSH
101943: CALL 71145 0 1
101947: IFFALSE 101951
// continue ;
101949: GO 100223
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
101951: LD_VAR 0 18
101955: PUSH
101956: LD_VAR 0 4
101960: PUSH
101961: LD_VAR 0 7
101965: ARRAY
101966: PPUSH
101967: CALL_OW 310
101971: NOT
101972: AND
101973: PUSH
101974: LD_VAR 0 14
101978: PUSH
101979: LD_INT 1
101981: ARRAY
101982: PUSH
101983: LD_VAR 0 14
101987: PPUSH
101988: LD_INT 21
101990: PUSH
101991: LD_INT 2
101993: PUSH
101994: EMPTY
101995: LIST
101996: LIST
101997: PUSH
101998: LD_INT 58
102000: PUSH
102001: EMPTY
102002: LIST
102003: PUSH
102004: EMPTY
102005: LIST
102006: LIST
102007: PPUSH
102008: CALL_OW 72
102012: IN
102013: AND
102014: IFFALSE 102050
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
102016: LD_VAR 0 4
102020: PUSH
102021: LD_VAR 0 7
102025: ARRAY
102026: PPUSH
102027: LD_VAR 0 14
102031: PUSH
102032: LD_INT 1
102034: ARRAY
102035: PPUSH
102036: CALL_OW 120
// attacking := true ;
102040: LD_ADDR_VAR 0 29
102044: PUSH
102045: LD_INT 1
102047: ST_TO_ADDR
// continue ;
102048: GO 100223
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
102050: LD_VAR 0 26
102054: PUSH
102055: LD_VAR 0 4
102059: PUSH
102060: LD_VAR 0 7
102064: ARRAY
102065: PPUSH
102066: CALL_OW 257
102070: PUSH
102071: LD_INT 1
102073: EQUAL
102074: AND
102075: PUSH
102076: LD_VAR 0 4
102080: PUSH
102081: LD_VAR 0 7
102085: ARRAY
102086: PPUSH
102087: CALL_OW 256
102091: PUSH
102092: LD_INT 800
102094: LESS
102095: AND
102096: PUSH
102097: LD_VAR 0 4
102101: PUSH
102102: LD_VAR 0 7
102106: ARRAY
102107: PPUSH
102108: CALL_OW 318
102112: NOT
102113: AND
102114: IFFALSE 102131
// ComCrawl ( group [ i ] ) ;
102116: LD_VAR 0 4
102120: PUSH
102121: LD_VAR 0 7
102125: ARRAY
102126: PPUSH
102127: CALL_OW 137
// if f_mines then
102131: LD_VAR 0 21
102135: IFFALSE 102378
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102137: LD_VAR 0 14
102141: PUSH
102142: LD_INT 1
102144: ARRAY
102145: PPUSH
102146: CALL_OW 247
102150: PUSH
102151: LD_INT 3
102153: EQUAL
102154: PUSH
102155: LD_VAR 0 14
102159: PUSH
102160: LD_INT 1
102162: ARRAY
102163: PUSH
102164: LD_VAR 0 27
102168: IN
102169: NOT
102170: AND
102171: IFFALSE 102378
// begin x := GetX ( tmp [ 1 ] ) ;
102173: LD_ADDR_VAR 0 10
102177: PUSH
102178: LD_VAR 0 14
102182: PUSH
102183: LD_INT 1
102185: ARRAY
102186: PPUSH
102187: CALL_OW 250
102191: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102192: LD_ADDR_VAR 0 11
102196: PUSH
102197: LD_VAR 0 14
102201: PUSH
102202: LD_INT 1
102204: ARRAY
102205: PPUSH
102206: CALL_OW 251
102210: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102211: LD_ADDR_VAR 0 12
102215: PUSH
102216: LD_VAR 0 4
102220: PUSH
102221: LD_VAR 0 7
102225: ARRAY
102226: PPUSH
102227: CALL 98086 0 1
102231: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102232: LD_VAR 0 4
102236: PUSH
102237: LD_VAR 0 7
102241: ARRAY
102242: PPUSH
102243: LD_VAR 0 10
102247: PPUSH
102248: LD_VAR 0 11
102252: PPUSH
102253: LD_VAR 0 14
102257: PUSH
102258: LD_INT 1
102260: ARRAY
102261: PPUSH
102262: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102266: LD_VAR 0 4
102270: PUSH
102271: LD_VAR 0 7
102275: ARRAY
102276: PPUSH
102277: LD_VAR 0 10
102281: PPUSH
102282: LD_VAR 0 12
102286: PPUSH
102287: LD_INT 7
102289: PPUSH
102290: CALL_OW 272
102294: PPUSH
102295: LD_VAR 0 11
102299: PPUSH
102300: LD_VAR 0 12
102304: PPUSH
102305: LD_INT 7
102307: PPUSH
102308: CALL_OW 273
102312: PPUSH
102313: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102317: LD_VAR 0 4
102321: PUSH
102322: LD_VAR 0 7
102326: ARRAY
102327: PPUSH
102328: LD_INT 71
102330: PPUSH
102331: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102335: LD_ADDR_VAR 0 27
102339: PUSH
102340: LD_VAR 0 27
102344: PPUSH
102345: LD_VAR 0 27
102349: PUSH
102350: LD_INT 1
102352: PLUS
102353: PPUSH
102354: LD_VAR 0 14
102358: PUSH
102359: LD_INT 1
102361: ARRAY
102362: PPUSH
102363: CALL_OW 1
102367: ST_TO_ADDR
// attacking := true ;
102368: LD_ADDR_VAR 0 29
102372: PUSH
102373: LD_INT 1
102375: ST_TO_ADDR
// continue ;
102376: GO 100223
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102378: LD_VAR 0 4
102382: PUSH
102383: LD_VAR 0 7
102387: ARRAY
102388: PPUSH
102389: CALL_OW 257
102393: PUSH
102394: LD_INT 17
102396: EQUAL
102397: PUSH
102398: LD_VAR 0 4
102402: PUSH
102403: LD_VAR 0 7
102407: ARRAY
102408: PPUSH
102409: CALL_OW 110
102413: PUSH
102414: LD_INT 71
102416: EQUAL
102417: NOT
102418: AND
102419: IFFALSE 102565
// begin attacking := false ;
102421: LD_ADDR_VAR 0 29
102425: PUSH
102426: LD_INT 0
102428: ST_TO_ADDR
// k := 5 ;
102429: LD_ADDR_VAR 0 9
102433: PUSH
102434: LD_INT 5
102436: ST_TO_ADDR
// if tmp < k then
102437: LD_VAR 0 14
102441: PUSH
102442: LD_VAR 0 9
102446: LESS
102447: IFFALSE 102459
// k := tmp ;
102449: LD_ADDR_VAR 0 9
102453: PUSH
102454: LD_VAR 0 14
102458: ST_TO_ADDR
// for j = 1 to k do
102459: LD_ADDR_VAR 0 8
102463: PUSH
102464: DOUBLE
102465: LD_INT 1
102467: DEC
102468: ST_TO_ADDR
102469: LD_VAR 0 9
102473: PUSH
102474: FOR_TO
102475: IFFALSE 102563
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102477: LD_VAR 0 14
102481: PUSH
102482: LD_VAR 0 8
102486: ARRAY
102487: PUSH
102488: LD_VAR 0 14
102492: PPUSH
102493: LD_INT 58
102495: PUSH
102496: EMPTY
102497: LIST
102498: PPUSH
102499: CALL_OW 72
102503: IN
102504: NOT
102505: IFFALSE 102561
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102507: LD_VAR 0 4
102511: PUSH
102512: LD_VAR 0 7
102516: ARRAY
102517: PPUSH
102518: LD_VAR 0 14
102522: PUSH
102523: LD_VAR 0 8
102527: ARRAY
102528: PPUSH
102529: CALL_OW 115
// attacking := true ;
102533: LD_ADDR_VAR 0 29
102537: PUSH
102538: LD_INT 1
102540: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102541: LD_VAR 0 4
102545: PUSH
102546: LD_VAR 0 7
102550: ARRAY
102551: PPUSH
102552: LD_INT 71
102554: PPUSH
102555: CALL_OW 109
// continue ;
102559: GO 102474
// end ; end ;
102561: GO 102474
102563: POP
102564: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102565: LD_VAR 0 4
102569: PUSH
102570: LD_VAR 0 7
102574: ARRAY
102575: PPUSH
102576: CALL_OW 257
102580: PUSH
102581: LD_INT 8
102583: EQUAL
102584: PUSH
102585: LD_VAR 0 4
102589: PUSH
102590: LD_VAR 0 7
102594: ARRAY
102595: PPUSH
102596: CALL_OW 264
102600: PUSH
102601: LD_INT 28
102603: PUSH
102604: LD_INT 45
102606: PUSH
102607: LD_INT 7
102609: PUSH
102610: LD_INT 47
102612: PUSH
102613: EMPTY
102614: LIST
102615: LIST
102616: LIST
102617: LIST
102618: IN
102619: OR
102620: IFFALSE 102850
// begin attacking := false ;
102622: LD_ADDR_VAR 0 29
102626: PUSH
102627: LD_INT 0
102629: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102630: LD_VAR 0 14
102634: PUSH
102635: LD_INT 1
102637: ARRAY
102638: PPUSH
102639: CALL_OW 266
102643: PUSH
102644: LD_INT 32
102646: PUSH
102647: LD_INT 31
102649: PUSH
102650: LD_INT 33
102652: PUSH
102653: LD_INT 4
102655: PUSH
102656: LD_INT 5
102658: PUSH
102659: EMPTY
102660: LIST
102661: LIST
102662: LIST
102663: LIST
102664: LIST
102665: IN
102666: IFFALSE 102850
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102668: LD_ADDR_VAR 0 9
102672: PUSH
102673: LD_VAR 0 14
102677: PUSH
102678: LD_INT 1
102680: ARRAY
102681: PPUSH
102682: CALL_OW 266
102686: PPUSH
102687: LD_VAR 0 14
102691: PUSH
102692: LD_INT 1
102694: ARRAY
102695: PPUSH
102696: CALL_OW 250
102700: PPUSH
102701: LD_VAR 0 14
102705: PUSH
102706: LD_INT 1
102708: ARRAY
102709: PPUSH
102710: CALL_OW 251
102714: PPUSH
102715: LD_VAR 0 14
102719: PUSH
102720: LD_INT 1
102722: ARRAY
102723: PPUSH
102724: CALL_OW 254
102728: PPUSH
102729: LD_VAR 0 14
102733: PUSH
102734: LD_INT 1
102736: ARRAY
102737: PPUSH
102738: CALL_OW 248
102742: PPUSH
102743: LD_INT 0
102745: PPUSH
102746: CALL 79456 0 6
102750: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
102751: LD_ADDR_VAR 0 8
102755: PUSH
102756: LD_VAR 0 4
102760: PUSH
102761: LD_VAR 0 7
102765: ARRAY
102766: PPUSH
102767: LD_VAR 0 9
102771: PPUSH
102772: CALL 98149 0 2
102776: ST_TO_ADDR
// if j then
102777: LD_VAR 0 8
102781: IFFALSE 102850
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
102783: LD_VAR 0 8
102787: PUSH
102788: LD_INT 1
102790: ARRAY
102791: PPUSH
102792: LD_VAR 0 8
102796: PUSH
102797: LD_INT 2
102799: ARRAY
102800: PPUSH
102801: CALL_OW 488
102805: IFFALSE 102850
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
102807: LD_VAR 0 4
102811: PUSH
102812: LD_VAR 0 7
102816: ARRAY
102817: PPUSH
102818: LD_VAR 0 8
102822: PUSH
102823: LD_INT 1
102825: ARRAY
102826: PPUSH
102827: LD_VAR 0 8
102831: PUSH
102832: LD_INT 2
102834: ARRAY
102835: PPUSH
102836: CALL_OW 116
// attacking := true ;
102840: LD_ADDR_VAR 0 29
102844: PUSH
102845: LD_INT 1
102847: ST_TO_ADDR
// continue ;
102848: GO 100223
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
102850: LD_VAR 0 4
102854: PUSH
102855: LD_VAR 0 7
102859: ARRAY
102860: PPUSH
102861: CALL_OW 265
102865: PUSH
102866: LD_INT 11
102868: EQUAL
102869: IFFALSE 103147
// begin k := 10 ;
102871: LD_ADDR_VAR 0 9
102875: PUSH
102876: LD_INT 10
102878: ST_TO_ADDR
// x := 0 ;
102879: LD_ADDR_VAR 0 10
102883: PUSH
102884: LD_INT 0
102886: ST_TO_ADDR
// if tmp < k then
102887: LD_VAR 0 14
102891: PUSH
102892: LD_VAR 0 9
102896: LESS
102897: IFFALSE 102909
// k := tmp ;
102899: LD_ADDR_VAR 0 9
102903: PUSH
102904: LD_VAR 0 14
102908: ST_TO_ADDR
// for j = k downto 1 do
102909: LD_ADDR_VAR 0 8
102913: PUSH
102914: DOUBLE
102915: LD_VAR 0 9
102919: INC
102920: ST_TO_ADDR
102921: LD_INT 1
102923: PUSH
102924: FOR_DOWNTO
102925: IFFALSE 103000
// begin if GetType ( tmp [ j ] ) = unit_human then
102927: LD_VAR 0 14
102931: PUSH
102932: LD_VAR 0 8
102936: ARRAY
102937: PPUSH
102938: CALL_OW 247
102942: PUSH
102943: LD_INT 1
102945: EQUAL
102946: IFFALSE 102998
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
102948: LD_VAR 0 4
102952: PUSH
102953: LD_VAR 0 7
102957: ARRAY
102958: PPUSH
102959: LD_VAR 0 14
102963: PUSH
102964: LD_VAR 0 8
102968: ARRAY
102969: PPUSH
102970: CALL 98420 0 2
// x := tmp [ j ] ;
102974: LD_ADDR_VAR 0 10
102978: PUSH
102979: LD_VAR 0 14
102983: PUSH
102984: LD_VAR 0 8
102988: ARRAY
102989: ST_TO_ADDR
// attacking := true ;
102990: LD_ADDR_VAR 0 29
102994: PUSH
102995: LD_INT 1
102997: ST_TO_ADDR
// end ; end ;
102998: GO 102924
103000: POP
103001: POP
// if not x then
103002: LD_VAR 0 10
103006: NOT
103007: IFFALSE 103147
// begin attacking := true ;
103009: LD_ADDR_VAR 0 29
103013: PUSH
103014: LD_INT 1
103016: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
103017: LD_VAR 0 4
103021: PUSH
103022: LD_VAR 0 7
103026: ARRAY
103027: PPUSH
103028: CALL_OW 250
103032: PPUSH
103033: LD_VAR 0 4
103037: PUSH
103038: LD_VAR 0 7
103042: ARRAY
103043: PPUSH
103044: CALL_OW 251
103048: PPUSH
103049: CALL_OW 546
103053: PUSH
103054: LD_INT 2
103056: ARRAY
103057: PUSH
103058: LD_VAR 0 14
103062: PUSH
103063: LD_INT 1
103065: ARRAY
103066: PPUSH
103067: CALL_OW 250
103071: PPUSH
103072: LD_VAR 0 14
103076: PUSH
103077: LD_INT 1
103079: ARRAY
103080: PPUSH
103081: CALL_OW 251
103085: PPUSH
103086: CALL_OW 546
103090: PUSH
103091: LD_INT 2
103093: ARRAY
103094: EQUAL
103095: IFFALSE 103123
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103097: LD_VAR 0 4
103101: PUSH
103102: LD_VAR 0 7
103106: ARRAY
103107: PPUSH
103108: LD_VAR 0 14
103112: PUSH
103113: LD_INT 1
103115: ARRAY
103116: PPUSH
103117: CALL 98420 0 2
103121: GO 103147
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103123: LD_VAR 0 4
103127: PUSH
103128: LD_VAR 0 7
103132: ARRAY
103133: PPUSH
103134: LD_VAR 0 14
103138: PUSH
103139: LD_INT 1
103141: ARRAY
103142: PPUSH
103143: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103147: LD_VAR 0 4
103151: PUSH
103152: LD_VAR 0 7
103156: ARRAY
103157: PPUSH
103158: CALL_OW 264
103162: PUSH
103163: LD_INT 29
103165: EQUAL
103166: IFFALSE 103532
// begin if WantsToAttack ( group [ i ] ) in bombed then
103168: LD_VAR 0 4
103172: PUSH
103173: LD_VAR 0 7
103177: ARRAY
103178: PPUSH
103179: CALL_OW 319
103183: PUSH
103184: LD_VAR 0 28
103188: IN
103189: IFFALSE 103193
// continue ;
103191: GO 100223
// k := 8 ;
103193: LD_ADDR_VAR 0 9
103197: PUSH
103198: LD_INT 8
103200: ST_TO_ADDR
// x := 0 ;
103201: LD_ADDR_VAR 0 10
103205: PUSH
103206: LD_INT 0
103208: ST_TO_ADDR
// if tmp < k then
103209: LD_VAR 0 14
103213: PUSH
103214: LD_VAR 0 9
103218: LESS
103219: IFFALSE 103231
// k := tmp ;
103221: LD_ADDR_VAR 0 9
103225: PUSH
103226: LD_VAR 0 14
103230: ST_TO_ADDR
// for j = 1 to k do
103231: LD_ADDR_VAR 0 8
103235: PUSH
103236: DOUBLE
103237: LD_INT 1
103239: DEC
103240: ST_TO_ADDR
103241: LD_VAR 0 9
103245: PUSH
103246: FOR_TO
103247: IFFALSE 103379
// begin if GetType ( tmp [ j ] ) = unit_building then
103249: LD_VAR 0 14
103253: PUSH
103254: LD_VAR 0 8
103258: ARRAY
103259: PPUSH
103260: CALL_OW 247
103264: PUSH
103265: LD_INT 3
103267: EQUAL
103268: IFFALSE 103377
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103270: LD_VAR 0 14
103274: PUSH
103275: LD_VAR 0 8
103279: ARRAY
103280: PUSH
103281: LD_VAR 0 28
103285: IN
103286: NOT
103287: PUSH
103288: LD_VAR 0 14
103292: PUSH
103293: LD_VAR 0 8
103297: ARRAY
103298: PPUSH
103299: CALL_OW 313
103303: AND
103304: IFFALSE 103377
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103306: LD_VAR 0 4
103310: PUSH
103311: LD_VAR 0 7
103315: ARRAY
103316: PPUSH
103317: LD_VAR 0 14
103321: PUSH
103322: LD_VAR 0 8
103326: ARRAY
103327: PPUSH
103328: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103332: LD_ADDR_VAR 0 28
103336: PUSH
103337: LD_VAR 0 28
103341: PPUSH
103342: LD_VAR 0 28
103346: PUSH
103347: LD_INT 1
103349: PLUS
103350: PPUSH
103351: LD_VAR 0 14
103355: PUSH
103356: LD_VAR 0 8
103360: ARRAY
103361: PPUSH
103362: CALL_OW 1
103366: ST_TO_ADDR
// attacking := true ;
103367: LD_ADDR_VAR 0 29
103371: PUSH
103372: LD_INT 1
103374: ST_TO_ADDR
// break ;
103375: GO 103379
// end ; end ;
103377: GO 103246
103379: POP
103380: POP
// if not attacking and f_attack_depot then
103381: LD_VAR 0 29
103385: NOT
103386: PUSH
103387: LD_VAR 0 25
103391: AND
103392: IFFALSE 103487
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103394: LD_ADDR_VAR 0 13
103398: PUSH
103399: LD_VAR 0 14
103403: PPUSH
103404: LD_INT 2
103406: PUSH
103407: LD_INT 30
103409: PUSH
103410: LD_INT 0
103412: PUSH
103413: EMPTY
103414: LIST
103415: LIST
103416: PUSH
103417: LD_INT 30
103419: PUSH
103420: LD_INT 1
103422: PUSH
103423: EMPTY
103424: LIST
103425: LIST
103426: PUSH
103427: EMPTY
103428: LIST
103429: LIST
103430: LIST
103431: PPUSH
103432: CALL_OW 72
103436: ST_TO_ADDR
// if z then
103437: LD_VAR 0 13
103441: IFFALSE 103487
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103443: LD_VAR 0 4
103447: PUSH
103448: LD_VAR 0 7
103452: ARRAY
103453: PPUSH
103454: LD_VAR 0 13
103458: PPUSH
103459: LD_VAR 0 4
103463: PUSH
103464: LD_VAR 0 7
103468: ARRAY
103469: PPUSH
103470: CALL_OW 74
103474: PPUSH
103475: CALL_OW 115
// attacking := true ;
103479: LD_ADDR_VAR 0 29
103483: PUSH
103484: LD_INT 1
103486: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103487: LD_VAR 0 4
103491: PUSH
103492: LD_VAR 0 7
103496: ARRAY
103497: PPUSH
103498: CALL_OW 256
103502: PUSH
103503: LD_INT 500
103505: LESS
103506: IFFALSE 103532
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103508: LD_VAR 0 4
103512: PUSH
103513: LD_VAR 0 7
103517: ARRAY
103518: PPUSH
103519: LD_VAR 0 14
103523: PUSH
103524: LD_INT 1
103526: ARRAY
103527: PPUSH
103528: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103532: LD_VAR 0 4
103536: PUSH
103537: LD_VAR 0 7
103541: ARRAY
103542: PPUSH
103543: CALL_OW 264
103547: PUSH
103548: LD_INT 49
103550: EQUAL
103551: IFFALSE 103672
// begin if not HasTask ( group [ i ] ) then
103553: LD_VAR 0 4
103557: PUSH
103558: LD_VAR 0 7
103562: ARRAY
103563: PPUSH
103564: CALL_OW 314
103568: NOT
103569: IFFALSE 103672
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103571: LD_ADDR_VAR 0 9
103575: PUSH
103576: LD_INT 81
103578: PUSH
103579: LD_VAR 0 4
103583: PUSH
103584: LD_VAR 0 7
103588: ARRAY
103589: PPUSH
103590: CALL_OW 255
103594: PUSH
103595: EMPTY
103596: LIST
103597: LIST
103598: PPUSH
103599: CALL_OW 69
103603: PPUSH
103604: LD_VAR 0 4
103608: PUSH
103609: LD_VAR 0 7
103613: ARRAY
103614: PPUSH
103615: CALL_OW 74
103619: ST_TO_ADDR
// if k then
103620: LD_VAR 0 9
103624: IFFALSE 103672
// if GetDistUnits ( group [ i ] , k ) > 10 then
103626: LD_VAR 0 4
103630: PUSH
103631: LD_VAR 0 7
103635: ARRAY
103636: PPUSH
103637: LD_VAR 0 9
103641: PPUSH
103642: CALL_OW 296
103646: PUSH
103647: LD_INT 10
103649: GREATER
103650: IFFALSE 103672
// ComMoveUnit ( group [ i ] , k ) ;
103652: LD_VAR 0 4
103656: PUSH
103657: LD_VAR 0 7
103661: ARRAY
103662: PPUSH
103663: LD_VAR 0 9
103667: PPUSH
103668: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103672: LD_VAR 0 4
103676: PUSH
103677: LD_VAR 0 7
103681: ARRAY
103682: PPUSH
103683: CALL_OW 256
103687: PUSH
103688: LD_INT 250
103690: LESS
103691: PUSH
103692: LD_VAR 0 4
103696: PUSH
103697: LD_VAR 0 7
103701: ARRAY
103702: PUSH
103703: LD_INT 21
103705: PUSH
103706: LD_INT 2
103708: PUSH
103709: EMPTY
103710: LIST
103711: LIST
103712: PUSH
103713: LD_INT 23
103715: PUSH
103716: LD_INT 2
103718: PUSH
103719: EMPTY
103720: LIST
103721: LIST
103722: PUSH
103723: EMPTY
103724: LIST
103725: LIST
103726: PPUSH
103727: CALL_OW 69
103731: IN
103732: AND
103733: IFFALSE 103858
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
103735: LD_ADDR_VAR 0 9
103739: PUSH
103740: LD_OWVAR 3
103744: PUSH
103745: LD_VAR 0 4
103749: PUSH
103750: LD_VAR 0 7
103754: ARRAY
103755: DIFF
103756: PPUSH
103757: LD_VAR 0 4
103761: PUSH
103762: LD_VAR 0 7
103766: ARRAY
103767: PPUSH
103768: CALL_OW 74
103772: ST_TO_ADDR
// if not k then
103773: LD_VAR 0 9
103777: NOT
103778: IFFALSE 103782
// continue ;
103780: GO 100223
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
103782: LD_VAR 0 9
103786: PUSH
103787: LD_INT 81
103789: PUSH
103790: LD_VAR 0 4
103794: PUSH
103795: LD_VAR 0 7
103799: ARRAY
103800: PPUSH
103801: CALL_OW 255
103805: PUSH
103806: EMPTY
103807: LIST
103808: LIST
103809: PPUSH
103810: CALL_OW 69
103814: IN
103815: PUSH
103816: LD_VAR 0 9
103820: PPUSH
103821: LD_VAR 0 4
103825: PUSH
103826: LD_VAR 0 7
103830: ARRAY
103831: PPUSH
103832: CALL_OW 296
103836: PUSH
103837: LD_INT 5
103839: LESS
103840: AND
103841: IFFALSE 103858
// ComAutodestruct ( group [ i ] ) ;
103843: LD_VAR 0 4
103847: PUSH
103848: LD_VAR 0 7
103852: ARRAY
103853: PPUSH
103854: CALL 98318 0 1
// end ; if f_attack_depot then
103858: LD_VAR 0 25
103862: IFFALSE 103974
// begin k := 6 ;
103864: LD_ADDR_VAR 0 9
103868: PUSH
103869: LD_INT 6
103871: ST_TO_ADDR
// if tmp < k then
103872: LD_VAR 0 14
103876: PUSH
103877: LD_VAR 0 9
103881: LESS
103882: IFFALSE 103894
// k := tmp ;
103884: LD_ADDR_VAR 0 9
103888: PUSH
103889: LD_VAR 0 14
103893: ST_TO_ADDR
// for j = 1 to k do
103894: LD_ADDR_VAR 0 8
103898: PUSH
103899: DOUBLE
103900: LD_INT 1
103902: DEC
103903: ST_TO_ADDR
103904: LD_VAR 0 9
103908: PUSH
103909: FOR_TO
103910: IFFALSE 103972
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103912: LD_VAR 0 8
103916: PPUSH
103917: CALL_OW 266
103921: PUSH
103922: LD_INT 0
103924: PUSH
103925: LD_INT 1
103927: PUSH
103928: EMPTY
103929: LIST
103930: LIST
103931: IN
103932: IFFALSE 103970
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103934: LD_VAR 0 4
103938: PUSH
103939: LD_VAR 0 7
103943: ARRAY
103944: PPUSH
103945: LD_VAR 0 14
103949: PUSH
103950: LD_VAR 0 8
103954: ARRAY
103955: PPUSH
103956: CALL_OW 115
// attacking := true ;
103960: LD_ADDR_VAR 0 29
103964: PUSH
103965: LD_INT 1
103967: ST_TO_ADDR
// break ;
103968: GO 103972
// end ;
103970: GO 103909
103972: POP
103973: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103974: LD_VAR 0 4
103978: PUSH
103979: LD_VAR 0 7
103983: ARRAY
103984: PPUSH
103985: CALL_OW 302
103989: PUSH
103990: LD_VAR 0 29
103994: NOT
103995: AND
103996: IFFALSE 104318
// begin if GetTag ( group [ i ] ) = 71 then
103998: LD_VAR 0 4
104002: PUSH
104003: LD_VAR 0 7
104007: ARRAY
104008: PPUSH
104009: CALL_OW 110
104013: PUSH
104014: LD_INT 71
104016: EQUAL
104017: IFFALSE 104058
// begin if HasTask ( group [ i ] ) then
104019: LD_VAR 0 4
104023: PUSH
104024: LD_VAR 0 7
104028: ARRAY
104029: PPUSH
104030: CALL_OW 314
104034: IFFALSE 104040
// continue else
104036: GO 100223
104038: GO 104058
// SetTag ( group [ i ] , 0 ) ;
104040: LD_VAR 0 4
104044: PUSH
104045: LD_VAR 0 7
104049: ARRAY
104050: PPUSH
104051: LD_INT 0
104053: PPUSH
104054: CALL_OW 109
// end ; k := 8 ;
104058: LD_ADDR_VAR 0 9
104062: PUSH
104063: LD_INT 8
104065: ST_TO_ADDR
// x := 0 ;
104066: LD_ADDR_VAR 0 10
104070: PUSH
104071: LD_INT 0
104073: ST_TO_ADDR
// if tmp < k then
104074: LD_VAR 0 14
104078: PUSH
104079: LD_VAR 0 9
104083: LESS
104084: IFFALSE 104096
// k := tmp ;
104086: LD_ADDR_VAR 0 9
104090: PUSH
104091: LD_VAR 0 14
104095: ST_TO_ADDR
// for j = 1 to k do
104096: LD_ADDR_VAR 0 8
104100: PUSH
104101: DOUBLE
104102: LD_INT 1
104104: DEC
104105: ST_TO_ADDR
104106: LD_VAR 0 9
104110: PUSH
104111: FOR_TO
104112: IFFALSE 104210
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104114: LD_VAR 0 14
104118: PUSH
104119: LD_VAR 0 8
104123: ARRAY
104124: PPUSH
104125: CALL_OW 247
104129: PUSH
104130: LD_INT 1
104132: EQUAL
104133: PUSH
104134: LD_VAR 0 14
104138: PUSH
104139: LD_VAR 0 8
104143: ARRAY
104144: PPUSH
104145: CALL_OW 256
104149: PUSH
104150: LD_INT 250
104152: LESS
104153: PUSH
104154: LD_VAR 0 20
104158: AND
104159: PUSH
104160: LD_VAR 0 20
104164: NOT
104165: PUSH
104166: LD_VAR 0 14
104170: PUSH
104171: LD_VAR 0 8
104175: ARRAY
104176: PPUSH
104177: CALL_OW 256
104181: PUSH
104182: LD_INT 250
104184: GREATEREQUAL
104185: AND
104186: OR
104187: AND
104188: IFFALSE 104208
// begin x := tmp [ j ] ;
104190: LD_ADDR_VAR 0 10
104194: PUSH
104195: LD_VAR 0 14
104199: PUSH
104200: LD_VAR 0 8
104204: ARRAY
104205: ST_TO_ADDR
// break ;
104206: GO 104210
// end ;
104208: GO 104111
104210: POP
104211: POP
// if x then
104212: LD_VAR 0 10
104216: IFFALSE 104240
// ComAttackUnit ( group [ i ] , x ) else
104218: LD_VAR 0 4
104222: PUSH
104223: LD_VAR 0 7
104227: ARRAY
104228: PPUSH
104229: LD_VAR 0 10
104233: PPUSH
104234: CALL_OW 115
104238: GO 104264
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104240: LD_VAR 0 4
104244: PUSH
104245: LD_VAR 0 7
104249: ARRAY
104250: PPUSH
104251: LD_VAR 0 14
104255: PUSH
104256: LD_INT 1
104258: ARRAY
104259: PPUSH
104260: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104264: LD_VAR 0 4
104268: PUSH
104269: LD_VAR 0 7
104273: ARRAY
104274: PPUSH
104275: CALL_OW 314
104279: NOT
104280: IFFALSE 104318
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104282: LD_VAR 0 4
104286: PUSH
104287: LD_VAR 0 7
104291: ARRAY
104292: PPUSH
104293: LD_VAR 0 14
104297: PPUSH
104298: LD_VAR 0 4
104302: PUSH
104303: LD_VAR 0 7
104307: ARRAY
104308: PPUSH
104309: CALL_OW 74
104313: PPUSH
104314: CALL_OW 115
// end ; end ; end ;
104318: GO 100223
104320: POP
104321: POP
// wait ( 0 0$1 ) ;
104322: LD_INT 35
104324: PPUSH
104325: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104329: LD_VAR 0 4
104333: PUSH
104334: EMPTY
104335: EQUAL
104336: PUSH
104337: LD_INT 81
104339: PUSH
104340: LD_VAR 0 35
104344: PUSH
104345: EMPTY
104346: LIST
104347: LIST
104348: PPUSH
104349: CALL_OW 69
104353: NOT
104354: OR
104355: IFFALSE 100208
// end ;
104357: LD_VAR 0 2
104361: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
104362: LD_INT 0
104364: PPUSH
104365: PPUSH
104366: PPUSH
104367: PPUSH
// if not base_units then
104368: LD_VAR 0 1
104372: NOT
104373: IFFALSE 104377
// exit ;
104375: GO 104464
// result := false ;
104377: LD_ADDR_VAR 0 2
104381: PUSH
104382: LD_INT 0
104384: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
104385: LD_ADDR_VAR 0 5
104389: PUSH
104390: LD_VAR 0 1
104394: PPUSH
104395: LD_INT 21
104397: PUSH
104398: LD_INT 3
104400: PUSH
104401: EMPTY
104402: LIST
104403: LIST
104404: PPUSH
104405: CALL_OW 72
104409: ST_TO_ADDR
// if not tmp then
104410: LD_VAR 0 5
104414: NOT
104415: IFFALSE 104419
// exit ;
104417: GO 104464
// for i in tmp do
104419: LD_ADDR_VAR 0 3
104423: PUSH
104424: LD_VAR 0 5
104428: PUSH
104429: FOR_IN
104430: IFFALSE 104462
// begin result := EnemyInRange ( i , 22 ) ;
104432: LD_ADDR_VAR 0 2
104436: PUSH
104437: LD_VAR 0 3
104441: PPUSH
104442: LD_INT 22
104444: PPUSH
104445: CALL 98001 0 2
104449: ST_TO_ADDR
// if result then
104450: LD_VAR 0 2
104454: IFFALSE 104460
// exit ;
104456: POP
104457: POP
104458: GO 104464
// end ;
104460: GO 104429
104462: POP
104463: POP
// end ;
104464: LD_VAR 0 2
104468: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
104469: LD_INT 0
104471: PPUSH
104472: PPUSH
// if not units then
104473: LD_VAR 0 1
104477: NOT
104478: IFFALSE 104482
// exit ;
104480: GO 104552
// result := [ ] ;
104482: LD_ADDR_VAR 0 3
104486: PUSH
104487: EMPTY
104488: ST_TO_ADDR
// for i in units do
104489: LD_ADDR_VAR 0 4
104493: PUSH
104494: LD_VAR 0 1
104498: PUSH
104499: FOR_IN
104500: IFFALSE 104550
// if GetTag ( i ) = tag then
104502: LD_VAR 0 4
104506: PPUSH
104507: CALL_OW 110
104511: PUSH
104512: LD_VAR 0 2
104516: EQUAL
104517: IFFALSE 104548
// result := Insert ( result , result + 1 , i ) ;
104519: LD_ADDR_VAR 0 3
104523: PUSH
104524: LD_VAR 0 3
104528: PPUSH
104529: LD_VAR 0 3
104533: PUSH
104534: LD_INT 1
104536: PLUS
104537: PPUSH
104538: LD_VAR 0 4
104542: PPUSH
104543: CALL_OW 2
104547: ST_TO_ADDR
104548: GO 104499
104550: POP
104551: POP
// end ;
104552: LD_VAR 0 3
104556: RET
// export function IsDriver ( un ) ; begin
104557: LD_INT 0
104559: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
104560: LD_ADDR_VAR 0 2
104564: PUSH
104565: LD_VAR 0 1
104569: PUSH
104570: LD_INT 55
104572: PUSH
104573: EMPTY
104574: LIST
104575: PPUSH
104576: CALL_OW 69
104580: IN
104581: ST_TO_ADDR
// end ;
104582: LD_VAR 0 2
104586: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
104587: LD_INT 0
104589: PPUSH
104590: PPUSH
// list := [ ] ;
104591: LD_ADDR_VAR 0 5
104595: PUSH
104596: EMPTY
104597: ST_TO_ADDR
// case d of 0 :
104598: LD_VAR 0 3
104602: PUSH
104603: LD_INT 0
104605: DOUBLE
104606: EQUAL
104607: IFTRUE 104611
104609: GO 104744
104611: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
104612: LD_ADDR_VAR 0 5
104616: PUSH
104617: LD_VAR 0 1
104621: PUSH
104622: LD_INT 4
104624: MINUS
104625: PUSH
104626: LD_VAR 0 2
104630: PUSH
104631: LD_INT 4
104633: MINUS
104634: PUSH
104635: LD_INT 2
104637: PUSH
104638: EMPTY
104639: LIST
104640: LIST
104641: LIST
104642: PUSH
104643: LD_VAR 0 1
104647: PUSH
104648: LD_INT 3
104650: MINUS
104651: PUSH
104652: LD_VAR 0 2
104656: PUSH
104657: LD_INT 1
104659: PUSH
104660: EMPTY
104661: LIST
104662: LIST
104663: LIST
104664: PUSH
104665: LD_VAR 0 1
104669: PUSH
104670: LD_INT 4
104672: PLUS
104673: PUSH
104674: LD_VAR 0 2
104678: PUSH
104679: LD_INT 4
104681: PUSH
104682: EMPTY
104683: LIST
104684: LIST
104685: LIST
104686: PUSH
104687: LD_VAR 0 1
104691: PUSH
104692: LD_INT 3
104694: PLUS
104695: PUSH
104696: LD_VAR 0 2
104700: PUSH
104701: LD_INT 3
104703: PLUS
104704: PUSH
104705: LD_INT 5
104707: PUSH
104708: EMPTY
104709: LIST
104710: LIST
104711: LIST
104712: PUSH
104713: LD_VAR 0 1
104717: PUSH
104718: LD_VAR 0 2
104722: PUSH
104723: LD_INT 4
104725: PLUS
104726: PUSH
104727: LD_INT 0
104729: PUSH
104730: EMPTY
104731: LIST
104732: LIST
104733: LIST
104734: PUSH
104735: EMPTY
104736: LIST
104737: LIST
104738: LIST
104739: LIST
104740: LIST
104741: ST_TO_ADDR
// end ; 1 :
104742: GO 105442
104744: LD_INT 1
104746: DOUBLE
104747: EQUAL
104748: IFTRUE 104752
104750: GO 104885
104752: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
104753: LD_ADDR_VAR 0 5
104757: PUSH
104758: LD_VAR 0 1
104762: PUSH
104763: LD_VAR 0 2
104767: PUSH
104768: LD_INT 4
104770: MINUS
104771: PUSH
104772: LD_INT 3
104774: PUSH
104775: EMPTY
104776: LIST
104777: LIST
104778: LIST
104779: PUSH
104780: LD_VAR 0 1
104784: PUSH
104785: LD_INT 3
104787: MINUS
104788: PUSH
104789: LD_VAR 0 2
104793: PUSH
104794: LD_INT 3
104796: MINUS
104797: PUSH
104798: LD_INT 2
104800: PUSH
104801: EMPTY
104802: LIST
104803: LIST
104804: LIST
104805: PUSH
104806: LD_VAR 0 1
104810: PUSH
104811: LD_INT 4
104813: MINUS
104814: PUSH
104815: LD_VAR 0 2
104819: PUSH
104820: LD_INT 1
104822: PUSH
104823: EMPTY
104824: LIST
104825: LIST
104826: LIST
104827: PUSH
104828: LD_VAR 0 1
104832: PUSH
104833: LD_VAR 0 2
104837: PUSH
104838: LD_INT 3
104840: PLUS
104841: PUSH
104842: LD_INT 0
104844: PUSH
104845: EMPTY
104846: LIST
104847: LIST
104848: LIST
104849: PUSH
104850: LD_VAR 0 1
104854: PUSH
104855: LD_INT 4
104857: PLUS
104858: PUSH
104859: LD_VAR 0 2
104863: PUSH
104864: LD_INT 4
104866: PLUS
104867: PUSH
104868: LD_INT 5
104870: PUSH
104871: EMPTY
104872: LIST
104873: LIST
104874: LIST
104875: PUSH
104876: EMPTY
104877: LIST
104878: LIST
104879: LIST
104880: LIST
104881: LIST
104882: ST_TO_ADDR
// end ; 2 :
104883: GO 105442
104885: LD_INT 2
104887: DOUBLE
104888: EQUAL
104889: IFTRUE 104893
104891: GO 105022
104893: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
104894: LD_ADDR_VAR 0 5
104898: PUSH
104899: LD_VAR 0 1
104903: PUSH
104904: LD_VAR 0 2
104908: PUSH
104909: LD_INT 3
104911: MINUS
104912: PUSH
104913: LD_INT 3
104915: PUSH
104916: EMPTY
104917: LIST
104918: LIST
104919: LIST
104920: PUSH
104921: LD_VAR 0 1
104925: PUSH
104926: LD_INT 4
104928: PLUS
104929: PUSH
104930: LD_VAR 0 2
104934: PUSH
104935: LD_INT 4
104937: PUSH
104938: EMPTY
104939: LIST
104940: LIST
104941: LIST
104942: PUSH
104943: LD_VAR 0 1
104947: PUSH
104948: LD_VAR 0 2
104952: PUSH
104953: LD_INT 4
104955: PLUS
104956: PUSH
104957: LD_INT 0
104959: PUSH
104960: EMPTY
104961: LIST
104962: LIST
104963: LIST
104964: PUSH
104965: LD_VAR 0 1
104969: PUSH
104970: LD_INT 3
104972: MINUS
104973: PUSH
104974: LD_VAR 0 2
104978: PUSH
104979: LD_INT 1
104981: PUSH
104982: EMPTY
104983: LIST
104984: LIST
104985: LIST
104986: PUSH
104987: LD_VAR 0 1
104991: PUSH
104992: LD_INT 4
104994: MINUS
104995: PUSH
104996: LD_VAR 0 2
105000: PUSH
105001: LD_INT 4
105003: MINUS
105004: PUSH
105005: LD_INT 2
105007: PUSH
105008: EMPTY
105009: LIST
105010: LIST
105011: LIST
105012: PUSH
105013: EMPTY
105014: LIST
105015: LIST
105016: LIST
105017: LIST
105018: LIST
105019: ST_TO_ADDR
// end ; 3 :
105020: GO 105442
105022: LD_INT 3
105024: DOUBLE
105025: EQUAL
105026: IFTRUE 105030
105028: GO 105163
105030: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
105031: LD_ADDR_VAR 0 5
105035: PUSH
105036: LD_VAR 0 1
105040: PUSH
105041: LD_INT 3
105043: PLUS
105044: PUSH
105045: LD_VAR 0 2
105049: PUSH
105050: LD_INT 4
105052: PUSH
105053: EMPTY
105054: LIST
105055: LIST
105056: LIST
105057: PUSH
105058: LD_VAR 0 1
105062: PUSH
105063: LD_INT 4
105065: PLUS
105066: PUSH
105067: LD_VAR 0 2
105071: PUSH
105072: LD_INT 4
105074: PLUS
105075: PUSH
105076: LD_INT 5
105078: PUSH
105079: EMPTY
105080: LIST
105081: LIST
105082: LIST
105083: PUSH
105084: LD_VAR 0 1
105088: PUSH
105089: LD_INT 4
105091: MINUS
105092: PUSH
105093: LD_VAR 0 2
105097: PUSH
105098: LD_INT 1
105100: PUSH
105101: EMPTY
105102: LIST
105103: LIST
105104: LIST
105105: PUSH
105106: LD_VAR 0 1
105110: PUSH
105111: LD_VAR 0 2
105115: PUSH
105116: LD_INT 4
105118: MINUS
105119: PUSH
105120: LD_INT 3
105122: PUSH
105123: EMPTY
105124: LIST
105125: LIST
105126: LIST
105127: PUSH
105128: LD_VAR 0 1
105132: PUSH
105133: LD_INT 3
105135: MINUS
105136: PUSH
105137: LD_VAR 0 2
105141: PUSH
105142: LD_INT 3
105144: MINUS
105145: PUSH
105146: LD_INT 2
105148: PUSH
105149: EMPTY
105150: LIST
105151: LIST
105152: LIST
105153: PUSH
105154: EMPTY
105155: LIST
105156: LIST
105157: LIST
105158: LIST
105159: LIST
105160: ST_TO_ADDR
// end ; 4 :
105161: GO 105442
105163: LD_INT 4
105165: DOUBLE
105166: EQUAL
105167: IFTRUE 105171
105169: GO 105304
105171: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
105172: LD_ADDR_VAR 0 5
105176: PUSH
105177: LD_VAR 0 1
105181: PUSH
105182: LD_VAR 0 2
105186: PUSH
105187: LD_INT 4
105189: PLUS
105190: PUSH
105191: LD_INT 0
105193: PUSH
105194: EMPTY
105195: LIST
105196: LIST
105197: LIST
105198: PUSH
105199: LD_VAR 0 1
105203: PUSH
105204: LD_INT 3
105206: PLUS
105207: PUSH
105208: LD_VAR 0 2
105212: PUSH
105213: LD_INT 3
105215: PLUS
105216: PUSH
105217: LD_INT 5
105219: PUSH
105220: EMPTY
105221: LIST
105222: LIST
105223: LIST
105224: PUSH
105225: LD_VAR 0 1
105229: PUSH
105230: LD_INT 4
105232: PLUS
105233: PUSH
105234: LD_VAR 0 2
105238: PUSH
105239: LD_INT 4
105241: PUSH
105242: EMPTY
105243: LIST
105244: LIST
105245: LIST
105246: PUSH
105247: LD_VAR 0 1
105251: PUSH
105252: LD_VAR 0 2
105256: PUSH
105257: LD_INT 3
105259: MINUS
105260: PUSH
105261: LD_INT 3
105263: PUSH
105264: EMPTY
105265: LIST
105266: LIST
105267: LIST
105268: PUSH
105269: LD_VAR 0 1
105273: PUSH
105274: LD_INT 4
105276: MINUS
105277: PUSH
105278: LD_VAR 0 2
105282: PUSH
105283: LD_INT 4
105285: MINUS
105286: PUSH
105287: LD_INT 2
105289: PUSH
105290: EMPTY
105291: LIST
105292: LIST
105293: LIST
105294: PUSH
105295: EMPTY
105296: LIST
105297: LIST
105298: LIST
105299: LIST
105300: LIST
105301: ST_TO_ADDR
// end ; 5 :
105302: GO 105442
105304: LD_INT 5
105306: DOUBLE
105307: EQUAL
105308: IFTRUE 105312
105310: GO 105441
105312: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
105313: LD_ADDR_VAR 0 5
105317: PUSH
105318: LD_VAR 0 1
105322: PUSH
105323: LD_INT 4
105325: MINUS
105326: PUSH
105327: LD_VAR 0 2
105331: PUSH
105332: LD_INT 1
105334: PUSH
105335: EMPTY
105336: LIST
105337: LIST
105338: LIST
105339: PUSH
105340: LD_VAR 0 1
105344: PUSH
105345: LD_VAR 0 2
105349: PUSH
105350: LD_INT 4
105352: MINUS
105353: PUSH
105354: LD_INT 3
105356: PUSH
105357: EMPTY
105358: LIST
105359: LIST
105360: LIST
105361: PUSH
105362: LD_VAR 0 1
105366: PUSH
105367: LD_INT 4
105369: PLUS
105370: PUSH
105371: LD_VAR 0 2
105375: PUSH
105376: LD_INT 4
105378: PLUS
105379: PUSH
105380: LD_INT 5
105382: PUSH
105383: EMPTY
105384: LIST
105385: LIST
105386: LIST
105387: PUSH
105388: LD_VAR 0 1
105392: PUSH
105393: LD_INT 3
105395: PLUS
105396: PUSH
105397: LD_VAR 0 2
105401: PUSH
105402: LD_INT 4
105404: PUSH
105405: EMPTY
105406: LIST
105407: LIST
105408: LIST
105409: PUSH
105410: LD_VAR 0 1
105414: PUSH
105415: LD_VAR 0 2
105419: PUSH
105420: LD_INT 3
105422: PLUS
105423: PUSH
105424: LD_INT 0
105426: PUSH
105427: EMPTY
105428: LIST
105429: LIST
105430: LIST
105431: PUSH
105432: EMPTY
105433: LIST
105434: LIST
105435: LIST
105436: LIST
105437: LIST
105438: ST_TO_ADDR
// end ; end ;
105439: GO 105442
105441: POP
// result := list ;
105442: LD_ADDR_VAR 0 4
105446: PUSH
105447: LD_VAR 0 5
105451: ST_TO_ADDR
// end ;
105452: LD_VAR 0 4
105456: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
105457: LD_INT 0
105459: PPUSH
105460: PPUSH
105461: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
105462: LD_VAR 0 1
105466: NOT
105467: PUSH
105468: LD_VAR 0 2
105472: PUSH
105473: LD_INT 1
105475: PUSH
105476: LD_INT 2
105478: PUSH
105479: LD_INT 3
105481: PUSH
105482: LD_INT 4
105484: PUSH
105485: EMPTY
105486: LIST
105487: LIST
105488: LIST
105489: LIST
105490: IN
105491: NOT
105492: OR
105493: IFFALSE 105497
// exit ;
105495: GO 105589
// tmp := [ ] ;
105497: LD_ADDR_VAR 0 5
105501: PUSH
105502: EMPTY
105503: ST_TO_ADDR
// for i in units do
105504: LD_ADDR_VAR 0 4
105508: PUSH
105509: LD_VAR 0 1
105513: PUSH
105514: FOR_IN
105515: IFFALSE 105558
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
105517: LD_ADDR_VAR 0 5
105521: PUSH
105522: LD_VAR 0 5
105526: PPUSH
105527: LD_VAR 0 5
105531: PUSH
105532: LD_INT 1
105534: PLUS
105535: PPUSH
105536: LD_VAR 0 4
105540: PPUSH
105541: LD_VAR 0 2
105545: PPUSH
105546: CALL_OW 259
105550: PPUSH
105551: CALL_OW 2
105555: ST_TO_ADDR
105556: GO 105514
105558: POP
105559: POP
// if not tmp then
105560: LD_VAR 0 5
105564: NOT
105565: IFFALSE 105569
// exit ;
105567: GO 105589
// result := SortListByListDesc ( units , tmp ) ;
105569: LD_ADDR_VAR 0 3
105573: PUSH
105574: LD_VAR 0 1
105578: PPUSH
105579: LD_VAR 0 5
105583: PPUSH
105584: CALL_OW 77
105588: ST_TO_ADDR
// end ;
105589: LD_VAR 0 3
105593: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
105594: LD_INT 0
105596: PPUSH
105597: PPUSH
105598: PPUSH
// x := GetX ( building ) ;
105599: LD_ADDR_VAR 0 4
105603: PUSH
105604: LD_VAR 0 2
105608: PPUSH
105609: CALL_OW 250
105613: ST_TO_ADDR
// y := GetY ( building ) ;
105614: LD_ADDR_VAR 0 5
105618: PUSH
105619: LD_VAR 0 2
105623: PPUSH
105624: CALL_OW 251
105628: ST_TO_ADDR
// if GetTaskList ( unit ) then
105629: LD_VAR 0 1
105633: PPUSH
105634: CALL_OW 437
105638: IFFALSE 105733
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
105640: LD_STRING e
105642: PUSH
105643: LD_VAR 0 1
105647: PPUSH
105648: CALL_OW 437
105652: PUSH
105653: LD_INT 1
105655: ARRAY
105656: PUSH
105657: LD_INT 1
105659: ARRAY
105660: EQUAL
105661: PUSH
105662: LD_VAR 0 4
105666: PUSH
105667: LD_VAR 0 1
105671: PPUSH
105672: CALL_OW 437
105676: PUSH
105677: LD_INT 1
105679: ARRAY
105680: PUSH
105681: LD_INT 2
105683: ARRAY
105684: EQUAL
105685: AND
105686: PUSH
105687: LD_VAR 0 5
105691: PUSH
105692: LD_VAR 0 1
105696: PPUSH
105697: CALL_OW 437
105701: PUSH
105702: LD_INT 1
105704: ARRAY
105705: PUSH
105706: LD_INT 3
105708: ARRAY
105709: EQUAL
105710: AND
105711: IFFALSE 105723
// result := true else
105713: LD_ADDR_VAR 0 3
105717: PUSH
105718: LD_INT 1
105720: ST_TO_ADDR
105721: GO 105731
// result := false ;
105723: LD_ADDR_VAR 0 3
105727: PUSH
105728: LD_INT 0
105730: ST_TO_ADDR
// end else
105731: GO 105741
// result := false ;
105733: LD_ADDR_VAR 0 3
105737: PUSH
105738: LD_INT 0
105740: ST_TO_ADDR
// end ;
105741: LD_VAR 0 3
105745: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
105746: LD_INT 0
105748: PPUSH
105749: PPUSH
105750: PPUSH
105751: PPUSH
// if not unit or not area then
105752: LD_VAR 0 1
105756: NOT
105757: PUSH
105758: LD_VAR 0 2
105762: NOT
105763: OR
105764: IFFALSE 105768
// exit ;
105766: GO 105932
// tmp := AreaToList ( area , i ) ;
105768: LD_ADDR_VAR 0 6
105772: PUSH
105773: LD_VAR 0 2
105777: PPUSH
105778: LD_VAR 0 5
105782: PPUSH
105783: CALL_OW 517
105787: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
105788: LD_ADDR_VAR 0 5
105792: PUSH
105793: DOUBLE
105794: LD_INT 1
105796: DEC
105797: ST_TO_ADDR
105798: LD_VAR 0 6
105802: PUSH
105803: LD_INT 1
105805: ARRAY
105806: PUSH
105807: FOR_TO
105808: IFFALSE 105930
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
105810: LD_ADDR_VAR 0 7
105814: PUSH
105815: LD_VAR 0 6
105819: PUSH
105820: LD_INT 1
105822: ARRAY
105823: PUSH
105824: LD_VAR 0 5
105828: ARRAY
105829: PUSH
105830: LD_VAR 0 6
105834: PUSH
105835: LD_INT 2
105837: ARRAY
105838: PUSH
105839: LD_VAR 0 5
105843: ARRAY
105844: PUSH
105845: EMPTY
105846: LIST
105847: LIST
105848: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
105849: LD_VAR 0 7
105853: PUSH
105854: LD_INT 1
105856: ARRAY
105857: PPUSH
105858: LD_VAR 0 7
105862: PUSH
105863: LD_INT 2
105865: ARRAY
105866: PPUSH
105867: CALL_OW 428
105871: PUSH
105872: LD_INT 0
105874: EQUAL
105875: IFFALSE 105928
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
105877: LD_VAR 0 1
105881: PPUSH
105882: LD_VAR 0 7
105886: PUSH
105887: LD_INT 1
105889: ARRAY
105890: PPUSH
105891: LD_VAR 0 7
105895: PUSH
105896: LD_INT 2
105898: ARRAY
105899: PPUSH
105900: LD_VAR 0 3
105904: PPUSH
105905: CALL_OW 48
// result := IsPlaced ( unit ) ;
105909: LD_ADDR_VAR 0 4
105913: PUSH
105914: LD_VAR 0 1
105918: PPUSH
105919: CALL_OW 305
105923: ST_TO_ADDR
// exit ;
105924: POP
105925: POP
105926: GO 105932
// end ; end ;
105928: GO 105807
105930: POP
105931: POP
// end ;
105932: LD_VAR 0 4
105936: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
105937: LD_INT 0
105939: PPUSH
105940: PPUSH
105941: PPUSH
// if not side or side > 8 then
105942: LD_VAR 0 1
105946: NOT
105947: PUSH
105948: LD_VAR 0 1
105952: PUSH
105953: LD_INT 8
105955: GREATER
105956: OR
105957: IFFALSE 105961
// exit ;
105959: GO 106148
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
105961: LD_ADDR_VAR 0 4
105965: PUSH
105966: LD_INT 22
105968: PUSH
105969: LD_VAR 0 1
105973: PUSH
105974: EMPTY
105975: LIST
105976: LIST
105977: PUSH
105978: LD_INT 21
105980: PUSH
105981: LD_INT 3
105983: PUSH
105984: EMPTY
105985: LIST
105986: LIST
105987: PUSH
105988: EMPTY
105989: LIST
105990: LIST
105991: PPUSH
105992: CALL_OW 69
105996: ST_TO_ADDR
// if not tmp then
105997: LD_VAR 0 4
106001: NOT
106002: IFFALSE 106006
// exit ;
106004: GO 106148
// enable_addtolog := true ;
106006: LD_ADDR_OWVAR 81
106010: PUSH
106011: LD_INT 1
106013: ST_TO_ADDR
// AddToLog ( [ ) ;
106014: LD_STRING [
106016: PPUSH
106017: CALL_OW 561
// for i in tmp do
106021: LD_ADDR_VAR 0 3
106025: PUSH
106026: LD_VAR 0 4
106030: PUSH
106031: FOR_IN
106032: IFFALSE 106139
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
106034: LD_STRING [
106036: PUSH
106037: LD_VAR 0 3
106041: PPUSH
106042: CALL_OW 266
106046: STR
106047: PUSH
106048: LD_STRING , 
106050: STR
106051: PUSH
106052: LD_VAR 0 3
106056: PPUSH
106057: CALL_OW 250
106061: STR
106062: PUSH
106063: LD_STRING , 
106065: STR
106066: PUSH
106067: LD_VAR 0 3
106071: PPUSH
106072: CALL_OW 251
106076: STR
106077: PUSH
106078: LD_STRING , 
106080: STR
106081: PUSH
106082: LD_VAR 0 3
106086: PPUSH
106087: CALL_OW 254
106091: STR
106092: PUSH
106093: LD_STRING , 
106095: STR
106096: PUSH
106097: LD_VAR 0 3
106101: PPUSH
106102: LD_INT 1
106104: PPUSH
106105: CALL_OW 268
106109: STR
106110: PUSH
106111: LD_STRING , 
106113: STR
106114: PUSH
106115: LD_VAR 0 3
106119: PPUSH
106120: LD_INT 2
106122: PPUSH
106123: CALL_OW 268
106127: STR
106128: PUSH
106129: LD_STRING ],
106131: STR
106132: PPUSH
106133: CALL_OW 561
// end ;
106137: GO 106031
106139: POP
106140: POP
// AddToLog ( ]; ) ;
106141: LD_STRING ];
106143: PPUSH
106144: CALL_OW 561
// end ;
106148: LD_VAR 0 2
106152: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
106153: LD_INT 0
106155: PPUSH
106156: PPUSH
106157: PPUSH
106158: PPUSH
106159: PPUSH
// if not area or not rate or not max then
106160: LD_VAR 0 1
106164: NOT
106165: PUSH
106166: LD_VAR 0 2
106170: NOT
106171: OR
106172: PUSH
106173: LD_VAR 0 4
106177: NOT
106178: OR
106179: IFFALSE 106183
// exit ;
106181: GO 106375
// while 1 do
106183: LD_INT 1
106185: IFFALSE 106375
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
106187: LD_ADDR_VAR 0 9
106191: PUSH
106192: LD_VAR 0 1
106196: PPUSH
106197: LD_INT 1
106199: PPUSH
106200: CALL_OW 287
106204: PUSH
106205: LD_INT 10
106207: MUL
106208: ST_TO_ADDR
// r := rate / 10 ;
106209: LD_ADDR_VAR 0 7
106213: PUSH
106214: LD_VAR 0 2
106218: PUSH
106219: LD_INT 10
106221: DIVREAL
106222: ST_TO_ADDR
// time := 1 1$00 ;
106223: LD_ADDR_VAR 0 8
106227: PUSH
106228: LD_INT 2100
106230: ST_TO_ADDR
// if amount < min then
106231: LD_VAR 0 9
106235: PUSH
106236: LD_VAR 0 3
106240: LESS
106241: IFFALSE 106259
// r := r * 2 else
106243: LD_ADDR_VAR 0 7
106247: PUSH
106248: LD_VAR 0 7
106252: PUSH
106253: LD_INT 2
106255: MUL
106256: ST_TO_ADDR
106257: GO 106285
// if amount > max then
106259: LD_VAR 0 9
106263: PUSH
106264: LD_VAR 0 4
106268: GREATER
106269: IFFALSE 106285
// r := r / 2 ;
106271: LD_ADDR_VAR 0 7
106275: PUSH
106276: LD_VAR 0 7
106280: PUSH
106281: LD_INT 2
106283: DIVREAL
106284: ST_TO_ADDR
// time := time / r ;
106285: LD_ADDR_VAR 0 8
106289: PUSH
106290: LD_VAR 0 8
106294: PUSH
106295: LD_VAR 0 7
106299: DIVREAL
106300: ST_TO_ADDR
// if time < 0 then
106301: LD_VAR 0 8
106305: PUSH
106306: LD_INT 0
106308: LESS
106309: IFFALSE 106326
// time := time * - 1 ;
106311: LD_ADDR_VAR 0 8
106315: PUSH
106316: LD_VAR 0 8
106320: PUSH
106321: LD_INT 1
106323: NEG
106324: MUL
106325: ST_TO_ADDR
// wait ( time ) ;
106326: LD_VAR 0 8
106330: PPUSH
106331: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
106335: LD_INT 35
106337: PPUSH
106338: LD_INT 875
106340: PPUSH
106341: CALL_OW 12
106345: PPUSH
106346: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
106350: LD_INT 1
106352: PPUSH
106353: LD_INT 5
106355: PPUSH
106356: CALL_OW 12
106360: PPUSH
106361: LD_VAR 0 1
106365: PPUSH
106366: LD_INT 1
106368: PPUSH
106369: CALL_OW 55
// end ;
106373: GO 106183
// end ;
106375: LD_VAR 0 5
106379: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
106380: LD_INT 0
106382: PPUSH
106383: PPUSH
106384: PPUSH
106385: PPUSH
106386: PPUSH
106387: PPUSH
106388: PPUSH
106389: PPUSH
// if not turrets or not factories then
106390: LD_VAR 0 1
106394: NOT
106395: PUSH
106396: LD_VAR 0 2
106400: NOT
106401: OR
106402: IFFALSE 106406
// exit ;
106404: GO 106713
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
106406: LD_ADDR_VAR 0 10
106410: PUSH
106411: LD_INT 5
106413: PUSH
106414: LD_INT 6
106416: PUSH
106417: EMPTY
106418: LIST
106419: LIST
106420: PUSH
106421: LD_INT 2
106423: PUSH
106424: LD_INT 4
106426: PUSH
106427: EMPTY
106428: LIST
106429: LIST
106430: PUSH
106431: LD_INT 3
106433: PUSH
106434: LD_INT 5
106436: PUSH
106437: EMPTY
106438: LIST
106439: LIST
106440: PUSH
106441: EMPTY
106442: LIST
106443: LIST
106444: LIST
106445: PUSH
106446: LD_INT 24
106448: PUSH
106449: LD_INT 25
106451: PUSH
106452: EMPTY
106453: LIST
106454: LIST
106455: PUSH
106456: LD_INT 23
106458: PUSH
106459: LD_INT 27
106461: PUSH
106462: EMPTY
106463: LIST
106464: LIST
106465: PUSH
106466: EMPTY
106467: LIST
106468: LIST
106469: PUSH
106470: LD_INT 42
106472: PUSH
106473: LD_INT 43
106475: PUSH
106476: EMPTY
106477: LIST
106478: LIST
106479: PUSH
106480: LD_INT 44
106482: PUSH
106483: LD_INT 46
106485: PUSH
106486: EMPTY
106487: LIST
106488: LIST
106489: PUSH
106490: LD_INT 45
106492: PUSH
106493: LD_INT 47
106495: PUSH
106496: EMPTY
106497: LIST
106498: LIST
106499: PUSH
106500: EMPTY
106501: LIST
106502: LIST
106503: LIST
106504: PUSH
106505: EMPTY
106506: LIST
106507: LIST
106508: LIST
106509: ST_TO_ADDR
// result := [ ] ;
106510: LD_ADDR_VAR 0 3
106514: PUSH
106515: EMPTY
106516: ST_TO_ADDR
// for i in turrets do
106517: LD_ADDR_VAR 0 4
106521: PUSH
106522: LD_VAR 0 1
106526: PUSH
106527: FOR_IN
106528: IFFALSE 106711
// begin nat := GetNation ( i ) ;
106530: LD_ADDR_VAR 0 7
106534: PUSH
106535: LD_VAR 0 4
106539: PPUSH
106540: CALL_OW 248
106544: ST_TO_ADDR
// weapon := 0 ;
106545: LD_ADDR_VAR 0 8
106549: PUSH
106550: LD_INT 0
106552: ST_TO_ADDR
// if not nat then
106553: LD_VAR 0 7
106557: NOT
106558: IFFALSE 106562
// continue ;
106560: GO 106527
// for j in list [ nat ] do
106562: LD_ADDR_VAR 0 5
106566: PUSH
106567: LD_VAR 0 10
106571: PUSH
106572: LD_VAR 0 7
106576: ARRAY
106577: PUSH
106578: FOR_IN
106579: IFFALSE 106620
// if GetBWeapon ( i ) = j [ 1 ] then
106581: LD_VAR 0 4
106585: PPUSH
106586: CALL_OW 269
106590: PUSH
106591: LD_VAR 0 5
106595: PUSH
106596: LD_INT 1
106598: ARRAY
106599: EQUAL
106600: IFFALSE 106618
// begin weapon := j [ 2 ] ;
106602: LD_ADDR_VAR 0 8
106606: PUSH
106607: LD_VAR 0 5
106611: PUSH
106612: LD_INT 2
106614: ARRAY
106615: ST_TO_ADDR
// break ;
106616: GO 106620
// end ;
106618: GO 106578
106620: POP
106621: POP
// if not weapon then
106622: LD_VAR 0 8
106626: NOT
106627: IFFALSE 106631
// continue ;
106629: GO 106527
// for k in factories do
106631: LD_ADDR_VAR 0 6
106635: PUSH
106636: LD_VAR 0 2
106640: PUSH
106641: FOR_IN
106642: IFFALSE 106707
// begin weapons := AvailableWeaponList ( k ) ;
106644: LD_ADDR_VAR 0 9
106648: PUSH
106649: LD_VAR 0 6
106653: PPUSH
106654: CALL_OW 478
106658: ST_TO_ADDR
// if not weapons then
106659: LD_VAR 0 9
106663: NOT
106664: IFFALSE 106668
// continue ;
106666: GO 106641
// if weapon in weapons then
106668: LD_VAR 0 8
106672: PUSH
106673: LD_VAR 0 9
106677: IN
106678: IFFALSE 106705
// begin result := [ i , weapon ] ;
106680: LD_ADDR_VAR 0 3
106684: PUSH
106685: LD_VAR 0 4
106689: PUSH
106690: LD_VAR 0 8
106694: PUSH
106695: EMPTY
106696: LIST
106697: LIST
106698: ST_TO_ADDR
// exit ;
106699: POP
106700: POP
106701: POP
106702: POP
106703: GO 106713
// end ; end ;
106705: GO 106641
106707: POP
106708: POP
// end ;
106709: GO 106527
106711: POP
106712: POP
// end ;
106713: LD_VAR 0 3
106717: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
106718: LD_INT 0
106720: PPUSH
// if not side or side > 8 then
106721: LD_VAR 0 3
106725: NOT
106726: PUSH
106727: LD_VAR 0 3
106731: PUSH
106732: LD_INT 8
106734: GREATER
106735: OR
106736: IFFALSE 106740
// exit ;
106738: GO 106799
// if not range then
106740: LD_VAR 0 4
106744: NOT
106745: IFFALSE 106756
// range := - 12 ;
106747: LD_ADDR_VAR 0 4
106751: PUSH
106752: LD_INT 12
106754: NEG
106755: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
106756: LD_VAR 0 1
106760: PPUSH
106761: LD_VAR 0 2
106765: PPUSH
106766: LD_VAR 0 3
106770: PPUSH
106771: LD_VAR 0 4
106775: PPUSH
106776: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
106780: LD_VAR 0 1
106784: PPUSH
106785: LD_VAR 0 2
106789: PPUSH
106790: LD_VAR 0 3
106794: PPUSH
106795: CALL_OW 331
// end ;
106799: LD_VAR 0 5
106803: RET
// export function Video ( mode ) ; begin
106804: LD_INT 0
106806: PPUSH
// ingame_video = mode ;
106807: LD_ADDR_OWVAR 52
106811: PUSH
106812: LD_VAR 0 1
106816: ST_TO_ADDR
// interface_hidden = mode ;
106817: LD_ADDR_OWVAR 54
106821: PUSH
106822: LD_VAR 0 1
106826: ST_TO_ADDR
// end ;
106827: LD_VAR 0 2
106831: RET
// export function Join ( array , element ) ; begin
106832: LD_INT 0
106834: PPUSH
// result := array ^ element ;
106835: LD_ADDR_VAR 0 3
106839: PUSH
106840: LD_VAR 0 1
106844: PUSH
106845: LD_VAR 0 2
106849: ADD
106850: ST_TO_ADDR
// end ;
106851: LD_VAR 0 3
106855: RET
// export function JoinUnion ( array , element ) ; begin
106856: LD_INT 0
106858: PPUSH
// result := array union element ;
106859: LD_ADDR_VAR 0 3
106863: PUSH
106864: LD_VAR 0 1
106868: PUSH
106869: LD_VAR 0 2
106873: UNION
106874: ST_TO_ADDR
// end ;
106875: LD_VAR 0 3
106879: RET
// export function GetBehemoths ( side ) ; begin
106880: LD_INT 0
106882: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
106883: LD_ADDR_VAR 0 2
106887: PUSH
106888: LD_INT 22
106890: PUSH
106891: LD_VAR 0 1
106895: PUSH
106896: EMPTY
106897: LIST
106898: LIST
106899: PUSH
106900: LD_INT 31
106902: PUSH
106903: LD_INT 25
106905: PUSH
106906: EMPTY
106907: LIST
106908: LIST
106909: PUSH
106910: EMPTY
106911: LIST
106912: LIST
106913: PPUSH
106914: CALL_OW 69
106918: ST_TO_ADDR
// end ;
106919: LD_VAR 0 2
106923: RET
// export function Shuffle ( array ) ; var i , index ; begin
106924: LD_INT 0
106926: PPUSH
106927: PPUSH
106928: PPUSH
// result := [ ] ;
106929: LD_ADDR_VAR 0 2
106933: PUSH
106934: EMPTY
106935: ST_TO_ADDR
// if not array then
106936: LD_VAR 0 1
106940: NOT
106941: IFFALSE 106945
// exit ;
106943: GO 107044
// Randomize ;
106945: CALL_OW 10
// for i = array downto 1 do
106949: LD_ADDR_VAR 0 3
106953: PUSH
106954: DOUBLE
106955: LD_VAR 0 1
106959: INC
106960: ST_TO_ADDR
106961: LD_INT 1
106963: PUSH
106964: FOR_DOWNTO
106965: IFFALSE 107042
// begin index := rand ( 1 , array ) ;
106967: LD_ADDR_VAR 0 4
106971: PUSH
106972: LD_INT 1
106974: PPUSH
106975: LD_VAR 0 1
106979: PPUSH
106980: CALL_OW 12
106984: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
106985: LD_ADDR_VAR 0 2
106989: PUSH
106990: LD_VAR 0 2
106994: PPUSH
106995: LD_VAR 0 2
106999: PUSH
107000: LD_INT 1
107002: PLUS
107003: PPUSH
107004: LD_VAR 0 1
107008: PUSH
107009: LD_VAR 0 4
107013: ARRAY
107014: PPUSH
107015: CALL_OW 2
107019: ST_TO_ADDR
// array := Delete ( array , index ) ;
107020: LD_ADDR_VAR 0 1
107024: PUSH
107025: LD_VAR 0 1
107029: PPUSH
107030: LD_VAR 0 4
107034: PPUSH
107035: CALL_OW 3
107039: ST_TO_ADDR
// end ;
107040: GO 106964
107042: POP
107043: POP
// end ;
107044: LD_VAR 0 2
107048: RET
// export function GetBaseMaterials ( base ) ; begin
107049: LD_INT 0
107051: PPUSH
// result := [ 0 , 0 , 0 ] ;
107052: LD_ADDR_VAR 0 2
107056: PUSH
107057: LD_INT 0
107059: PUSH
107060: LD_INT 0
107062: PUSH
107063: LD_INT 0
107065: PUSH
107066: EMPTY
107067: LIST
107068: LIST
107069: LIST
107070: ST_TO_ADDR
// if not base then
107071: LD_VAR 0 1
107075: NOT
107076: IFFALSE 107080
// exit ;
107078: GO 107129
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
107080: LD_ADDR_VAR 0 2
107084: PUSH
107085: LD_VAR 0 1
107089: PPUSH
107090: LD_INT 1
107092: PPUSH
107093: CALL_OW 275
107097: PUSH
107098: LD_VAR 0 1
107102: PPUSH
107103: LD_INT 2
107105: PPUSH
107106: CALL_OW 275
107110: PUSH
107111: LD_VAR 0 1
107115: PPUSH
107116: LD_INT 3
107118: PPUSH
107119: CALL_OW 275
107123: PUSH
107124: EMPTY
107125: LIST
107126: LIST
107127: LIST
107128: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
107129: LD_VAR 0 2
107133: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
107134: LD_INT 0
107136: PPUSH
107137: PPUSH
107138: PPUSH
107139: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107140: LD_VAR 0 1
107144: PPUSH
107145: CALL_OW 264
107149: PUSH
107150: LD_EXP 96
107154: EQUAL
107155: IFFALSE 107227
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107157: LD_INT 68
107159: PPUSH
107160: LD_VAR 0 1
107164: PPUSH
107165: CALL_OW 255
107169: PPUSH
107170: CALL_OW 321
107174: PUSH
107175: LD_INT 2
107177: EQUAL
107178: IFFALSE 107190
// eff := 70 else
107180: LD_ADDR_VAR 0 6
107184: PUSH
107185: LD_INT 70
107187: ST_TO_ADDR
107188: GO 107198
// eff := 30 ;
107190: LD_ADDR_VAR 0 6
107194: PUSH
107195: LD_INT 30
107197: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107198: LD_VAR 0 1
107202: PPUSH
107203: CALL_OW 250
107207: PPUSH
107208: LD_VAR 0 1
107212: PPUSH
107213: CALL_OW 251
107217: PPUSH
107218: LD_VAR 0 6
107222: PPUSH
107223: CALL_OW 495
// end ; end ;
107227: LD_VAR 0 4
107231: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
107232: LD_INT 0
107234: PPUSH
107235: PPUSH
107236: PPUSH
107237: PPUSH
107238: PPUSH
107239: PPUSH
// if cmd = 124 then
107240: LD_VAR 0 1
107244: PUSH
107245: LD_INT 124
107247: EQUAL
107248: IFFALSE 107454
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
107250: LD_ADDR_VAR 0 5
107254: PUSH
107255: LD_INT 2
107257: PUSH
107258: LD_INT 34
107260: PUSH
107261: LD_INT 53
107263: PUSH
107264: EMPTY
107265: LIST
107266: LIST
107267: PUSH
107268: LD_INT 34
107270: PUSH
107271: LD_INT 14
107273: PUSH
107274: EMPTY
107275: LIST
107276: LIST
107277: PUSH
107278: EMPTY
107279: LIST
107280: LIST
107281: LIST
107282: PPUSH
107283: CALL_OW 69
107287: ST_TO_ADDR
// if not tmp then
107288: LD_VAR 0 5
107292: NOT
107293: IFFALSE 107297
// exit ;
107295: GO 107454
// for i in tmp do
107297: LD_ADDR_VAR 0 3
107301: PUSH
107302: LD_VAR 0 5
107306: PUSH
107307: FOR_IN
107308: IFFALSE 107452
// begin taskList := GetTaskList ( i ) ;
107310: LD_ADDR_VAR 0 6
107314: PUSH
107315: LD_VAR 0 3
107319: PPUSH
107320: CALL_OW 437
107324: ST_TO_ADDR
// if not taskList then
107325: LD_VAR 0 6
107329: NOT
107330: IFFALSE 107334
// continue ;
107332: GO 107307
// for j = 1 to taskList do
107334: LD_ADDR_VAR 0 4
107338: PUSH
107339: DOUBLE
107340: LD_INT 1
107342: DEC
107343: ST_TO_ADDR
107344: LD_VAR 0 6
107348: PUSH
107349: FOR_TO
107350: IFFALSE 107448
// if taskList [ j ] [ 1 ] = | then
107352: LD_VAR 0 6
107356: PUSH
107357: LD_VAR 0 4
107361: ARRAY
107362: PUSH
107363: LD_INT 1
107365: ARRAY
107366: PUSH
107367: LD_STRING |
107369: EQUAL
107370: IFFALSE 107446
// begin _taskList := Delete ( taskList , 1 ) ;
107372: LD_ADDR_VAR 0 7
107376: PUSH
107377: LD_VAR 0 6
107381: PPUSH
107382: LD_INT 1
107384: PPUSH
107385: CALL_OW 3
107389: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
107390: LD_VAR 0 3
107394: PPUSH
107395: LD_VAR 0 7
107399: PPUSH
107400: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
107404: LD_VAR 0 3
107408: PPUSH
107409: LD_VAR 0 6
107413: PUSH
107414: LD_VAR 0 4
107418: ARRAY
107419: PUSH
107420: LD_INT 2
107422: ARRAY
107423: PPUSH
107424: LD_VAR 0 6
107428: PUSH
107429: LD_VAR 0 4
107433: ARRAY
107434: PUSH
107435: LD_INT 3
107437: ARRAY
107438: PPUSH
107439: LD_INT 8
107441: PPUSH
107442: CALL 107459 0 4
// end ;
107446: GO 107349
107448: POP
107449: POP
// end ;
107450: GO 107307
107452: POP
107453: POP
// end ; end ;
107454: LD_VAR 0 2
107458: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107459: LD_INT 0
107461: PPUSH
107462: PPUSH
107463: PPUSH
107464: PPUSH
107465: PPUSH
107466: PPUSH
107467: PPUSH
107468: PPUSH
107469: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107470: LD_VAR 0 1
107474: NOT
107475: PUSH
107476: LD_VAR 0 2
107480: PPUSH
107481: LD_VAR 0 3
107485: PPUSH
107486: CALL_OW 488
107490: NOT
107491: OR
107492: PUSH
107493: LD_VAR 0 4
107497: NOT
107498: OR
107499: IFFALSE 107503
// exit ;
107501: GO 107843
// list := [ ] ;
107503: LD_ADDR_VAR 0 13
107507: PUSH
107508: EMPTY
107509: ST_TO_ADDR
// if x - r < 0 then
107510: LD_VAR 0 2
107514: PUSH
107515: LD_VAR 0 4
107519: MINUS
107520: PUSH
107521: LD_INT 0
107523: LESS
107524: IFFALSE 107536
// min_x := 0 else
107526: LD_ADDR_VAR 0 7
107530: PUSH
107531: LD_INT 0
107533: ST_TO_ADDR
107534: GO 107552
// min_x := x - r ;
107536: LD_ADDR_VAR 0 7
107540: PUSH
107541: LD_VAR 0 2
107545: PUSH
107546: LD_VAR 0 4
107550: MINUS
107551: ST_TO_ADDR
// if y - r < 0 then
107552: LD_VAR 0 3
107556: PUSH
107557: LD_VAR 0 4
107561: MINUS
107562: PUSH
107563: LD_INT 0
107565: LESS
107566: IFFALSE 107578
// min_y := 0 else
107568: LD_ADDR_VAR 0 8
107572: PUSH
107573: LD_INT 0
107575: ST_TO_ADDR
107576: GO 107594
// min_y := y - r ;
107578: LD_ADDR_VAR 0 8
107582: PUSH
107583: LD_VAR 0 3
107587: PUSH
107588: LD_VAR 0 4
107592: MINUS
107593: ST_TO_ADDR
// max_x := x + r ;
107594: LD_ADDR_VAR 0 9
107598: PUSH
107599: LD_VAR 0 2
107603: PUSH
107604: LD_VAR 0 4
107608: PLUS
107609: ST_TO_ADDR
// max_y := y + r ;
107610: LD_ADDR_VAR 0 10
107614: PUSH
107615: LD_VAR 0 3
107619: PUSH
107620: LD_VAR 0 4
107624: PLUS
107625: ST_TO_ADDR
// for _x = min_x to max_x do
107626: LD_ADDR_VAR 0 11
107630: PUSH
107631: DOUBLE
107632: LD_VAR 0 7
107636: DEC
107637: ST_TO_ADDR
107638: LD_VAR 0 9
107642: PUSH
107643: FOR_TO
107644: IFFALSE 107761
// for _y = min_y to max_y do
107646: LD_ADDR_VAR 0 12
107650: PUSH
107651: DOUBLE
107652: LD_VAR 0 8
107656: DEC
107657: ST_TO_ADDR
107658: LD_VAR 0 10
107662: PUSH
107663: FOR_TO
107664: IFFALSE 107757
// begin if not ValidHex ( _x , _y ) then
107666: LD_VAR 0 11
107670: PPUSH
107671: LD_VAR 0 12
107675: PPUSH
107676: CALL_OW 488
107680: NOT
107681: IFFALSE 107685
// continue ;
107683: GO 107663
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107685: LD_VAR 0 11
107689: PPUSH
107690: LD_VAR 0 12
107694: PPUSH
107695: CALL_OW 351
107699: PUSH
107700: LD_VAR 0 11
107704: PPUSH
107705: LD_VAR 0 12
107709: PPUSH
107710: CALL_OW 554
107714: AND
107715: IFFALSE 107755
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107717: LD_ADDR_VAR 0 13
107721: PUSH
107722: LD_VAR 0 13
107726: PPUSH
107727: LD_VAR 0 13
107731: PUSH
107732: LD_INT 1
107734: PLUS
107735: PPUSH
107736: LD_VAR 0 11
107740: PUSH
107741: LD_VAR 0 12
107745: PUSH
107746: EMPTY
107747: LIST
107748: LIST
107749: PPUSH
107750: CALL_OW 2
107754: ST_TO_ADDR
// end ;
107755: GO 107663
107757: POP
107758: POP
107759: GO 107643
107761: POP
107762: POP
// if not list then
107763: LD_VAR 0 13
107767: NOT
107768: IFFALSE 107772
// exit ;
107770: GO 107843
// for i in list do
107772: LD_ADDR_VAR 0 6
107776: PUSH
107777: LD_VAR 0 13
107781: PUSH
107782: FOR_IN
107783: IFFALSE 107841
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107785: LD_VAR 0 1
107789: PPUSH
107790: LD_STRING M
107792: PUSH
107793: LD_VAR 0 6
107797: PUSH
107798: LD_INT 1
107800: ARRAY
107801: PUSH
107802: LD_VAR 0 6
107806: PUSH
107807: LD_INT 2
107809: ARRAY
107810: PUSH
107811: LD_INT 0
107813: PUSH
107814: LD_INT 0
107816: PUSH
107817: LD_INT 0
107819: PUSH
107820: LD_INT 0
107822: PUSH
107823: EMPTY
107824: LIST
107825: LIST
107826: LIST
107827: LIST
107828: LIST
107829: LIST
107830: LIST
107831: PUSH
107832: EMPTY
107833: LIST
107834: PPUSH
107835: CALL_OW 447
107839: GO 107782
107841: POP
107842: POP
// end ;
107843: LD_VAR 0 5
107847: RET
